Set Implicit Arguments.
Unset Strict Implicit.
Require Export point_cocyclicite.
(* point_cocyclicite:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export point_angle.
 
Lemma calcul4 :
 forall a b c d : AV,
 R (plus (plus a b) (plus c d)) (plus (plus a c) (plus b d)).
 
Theorem angle_inscrit :
 forall A B M O : PO,
 isocele O M A ->
 isocele O M B ->
 R (double (cons (vec M A) (vec M B))) (cons (vec O A) (vec O B)).
 
Lemma triangle_rectangle :
 forall A B M O : PO,
 isocele O M A ->
 isocele O M B ->
 orthogonal (vec M A) (vec M B) -> R (cons (vec O A) (vec O B)) pi.
 
Lemma triangle_diametre :
 forall A B M O : PO,
 isocele O M A ->
 isocele O M B ->
 R (cons (vec O A) (vec O B)) pi -> orthogonal (vec M A) (vec M B).
 
Theorem cocyclique :
 forall M A B O M' : PO,
 isocele O A B ->
 isocele O M A ->
 isocele O M B ->
 isocele O M' A ->
 isocele O M' B ->
 R (double (cons (vec M' A) (vec M' B))) (double (cons (vec M A) (vec M B))).
 
Lemma exists_opp_angle : forall a : AV, exists b : AV, R (plus a b) zero.
Parameter pisurdeux : AV.
 
Axiom double_pisurdeux : R (double pisurdeux) pi.
Hint Resolve double_pisurdeux.
 
Lemma construction_orthogonal : forall u : V, exists v : V, orthogonal v u.
 
Lemma unicite_circonscrit :
 forall M A B O O' : PO,
 isocele O A B ->
 isocele O M B ->
 isocele O M A ->
 isocele O' A B ->
 isocele O' M B ->
 isocele O' M A ->
 (colineaire (vec O A) (vec O' A) /\ colineaire (vec O B) (vec O' B)) /\
 colineaire (vec O M) (vec O' M).
 
Lemma construction_isocele_base :
 forall (A B : PO) (a : AV),
 exists u : V,
   (exists v : V,
      R (cons (vec A B) u) (cons v (vec B A)) /\ R (cons u v) (double a)).
 
Lemma abba : forall A B : PO, R (cons (vec A B) (vec B A)) pi.
Hint Resolve abba.
 
Lemma calcul5 :
 forall a b c d : AV,
 R (plus (plus a (plus b c)) (plus d d))
   (plus a (plus (plus d b) (plus d c))).
 
Lemma construction_circonscrit_vecteur :
 forall M A B : PO,
 ex
   (fun u : V =>
    ex
      (fun v : V =>
       ex
         (fun w : V =>
          (R (cons u v) (double (cons (vec M A) (vec M B))) /\
           R (cons u w) (double (cons (vec B A) (vec B M))) /\
           R (cons v w) (double (cons (vec A B) (vec A M)))) /\
          R (cons (vec A B) u) (cons v (vec B A)) /\
          R (cons w (vec M B)) (cons (vec B M) v) /\
          R (cons (vec M A) w) (cons u (vec A M))))).
 
Axiom
  construction_circonscrit :
    forall M A B : PO,
    ~ colineaire (vec M A) (vec M B) ->
    exists O : PO, isocele O A B /\ isocele O A M /\ isocele O B M.
 
Definition circonscrit (M A B O : PO) :=
  isocele O A B /\ isocele O A M /\ isocele O B M.
 
Definition sont_cocycliques (M A B M' : PO) :=
  ex
    (fun O : PO =>
     ex
       (fun O' : PO =>
        (circonscrit M A B O /\ circonscrit M' A B O') /\
        colineaire (vec O A) (vec O' A) /\ colineaire (vec O B) (vec O' B))).
 
Lemma isocele_sym : forall A B C : PO, isocele A B C -> isocele A C B.
Hint Resolve isocele_sym.
 
Theorem reciproque_cocyclique :
 forall M A B M' : PO,
 ~ colineaire (vec M A) (vec M B) ->
 R (double (cons (vec M' A) (vec M' B))) (double (cons (vec M A) (vec M B))) ->
 sont_cocycliques M A B M'.
 
Axiom
  cocyclicite_six :
    forall A B C D : PO,
    sont_cocycliques C A B D ->
    ex
      (fun O : PO =>
       (circonscrit C A B O /\ circonscrit D A B O) /\ isocele O C D).
 
Lemma changement_base_cocyclique :
 forall A B C D : PO,
 ~ colineaire (vec C A) (vec C B) ->
 R (double (cons (vec C A) (vec C B))) (double (cons (vec D A) (vec D B))) ->
 R (double (cons (vec A C) (vec A D))) (double (cons (vec B C) (vec B D))).
 
Lemma changement_base_cocyclique_2 :
 forall A B C D : PO,
 ~ colineaire (vec C A) (vec C B) ->
 R (double (cons (vec C A) (vec C B))) (double (cons (vec D A) (vec D B))) ->
 R (double (cons (vec B C) (vec B A))) (double (cons (vec D C) (vec D A))).
 
Axiom non_zero_pi : ~ R pi zero.
 
Lemma deux_rectangles :
 forall A B C D : PO,
 orthogonal (vec C A) (vec C B) ->
 orthogonal (vec D A) (vec D B) ->
 R (double (cons (vec B C) (vec B A))) (double (cons (vec D C) (vec D A))). *)
 
Definition orthocentre (H A B C : PO) :=
  (orthogonal (vec H A) (vec B C) /\ orthogonal (vec H B) (vec A C)) /\
  orthogonal (vec H C) (vec A B).
Section Theoreme.
Parameter H A B C : PO.
Hypothesis triangle : ~ colineaire (vec A B) (vec A C).
Hypothesis H_orthocentre : orthocentre H A B C.
 
Lemma orthocentre_double :
 R (double (cons (vec H C) (vec H B))) (double (cons (vec A B) (vec A C))).
unfold orthocentre in H_orthocentre.
elim H_orthocentre; intros H0 H1; elim H0; intros H2 H3;
 clear H0 H_orthocentre; try exact H3.
apply
 transitive
  with
    (double
       (plus (cons (vec H C) (vec A B))
          (plus (cons (vec A B) (vec A C)) (cons (vec A C) (vec H B))))).
apply R_double.
auto.
apply
 transitive
  with
    (plus (double (cons (vec H C) (vec A B)))
       (double (plus (cons (vec A B) (vec A C)) (cons (vec A C) (vec H B))))).
auto.
apply
 transitive
  with
    (plus (double (cons (vec H C) (vec A B)))
       (plus (double (cons (vec A B) (vec A C)))
          (double (cons (vec A C) (vec H B))))).
apply compatible; auto.
apply transitive with (plus pi (plus (double (cons (vec A B) (vec A C))) pi)).
apply compatible; auto.
apply compatible; auto.
cut (orthogonal (vec A C) (vec H B)); (intros; auto).
apply transitive with (plus (plus (double (cons (vec A B) (vec A C))) pi) pi).
auto.
apply transitive with (plus (double (cons (vec A B) (vec A C))) (plus pi pi)).
auto.
apply transitive with (plus (double (cons (vec A B) (vec A C))) zero).
apply compatible; auto.
apply transitive with (plus zero (double (cons (vec A B) (vec A C)))).
auto.
auto.
Qed.
 
Theorem symetrique_orthocentre_cercle :
 forall H' : PO,
 R (cons (vec H' B) (vec B C)) (cons (vec B C) (vec H B)) ->
 R (cons (vec H' C) (vec B C)) (cons (vec B C) (vec H C)) ->
 sont_cocycliques A B C H'.
intros H' H0 H1; try assumption.
apply reciproque_cocyclique; auto.
cut (R (cons (vec H C) (vec H B)) (cons (vec H' B) (vec H' C))).
intros H2.
apply transitive with (double (cons (vec H C) (vec H B))); auto.
apply orthocentre_double.
apply reflexion with (vec B C); auto.
Qed.
End Theoreme.