Require Export TopologicalSpaces.
(* TopologicalSpaces:
Require Export Ensembles.
From ZornsLemma Require Import EnsemblesImplicit.
From ZornsLemma Require Export Families.
From ZornsLemma Require Export IndexedFamilies.
From ZornsLemma Require Export FiniteTypes.
From ZornsLemma Require Import EnsemblesSpec.

Record TopologicalSpace : Type := {
  point_set : Type;
  open : Ensemble point_set -> Prop;
  open_family_union : forall F : Family point_set,
    (forall S : Ensemble point_set, In F S -> open S) ->
    open (FamilyUnion F);
  open_intersection2: forall U V:Ensemble point_set,
    open U -> open V -> open (Intersection U V);
  open_full : open Full_set
}.

Arguments open {t}.
Arguments open_family_union {t}.
Arguments open_intersection2 {t}.

Lemma open_empty: forall X:TopologicalSpace,
  open (@Empty_set (point_set X)).

Lemma open_union2: forall {X:TopologicalSpace}
  (U V:Ensemble (point_set X)), open U -> open V -> open (Union U V).

Lemma open_indexed_union: forall {X:TopologicalSpace} {A:Type}
  (F:IndexedFamily A (point_set X)),
  (forall a:A, open (F a)) -> open (IndexedUnion F).

Lemma open_finite_indexed_intersection:
  forall {X:TopologicalSpace} {A:Type}
    (F:IndexedFamily A (point_set X)),
    FiniteT A -> (forall a:A, open (F a)) ->
    open (IndexedIntersection F).

Definition closed {X:TopologicalSpace} (F:Ensemble (point_set X)) :=
  open (Ensembles.Complement F).

Lemma closed_complement_open: forall {X:TopologicalSpace}
  (U:Ensemble (point_set X)), closed (Ensembles.Complement U) ->

Lemma closed_union2: forall {X:TopologicalSpace}
  (F G:Ensemble (point_set X)),
  closed F -> closed G -> closed (Union F G).

Lemma closed_intersection2: forall {X:TopologicalSpace}
  (F G:Ensemble (point_set X)),
  closed F -> closed G -> closed (Intersection F G).

Lemma closed_family_intersection: forall {X:TopologicalSpace}
  (F:Family (point_set X)),
  (forall S:Ensemble (point_set X), In F S -> closed S) ->
  closed (FamilyIntersection F).

Lemma closed_indexed_intersection: forall {X:TopologicalSpace}
  {A:Type} (F:IndexedFamily A (point_set X)),
  (forall a:A, closed (F a)) -> closed (IndexedIntersection F).

Lemma closed_finite_indexed_union: forall {X:TopologicalSpace}
  {A:Type} (F:IndexedFamily A (point_set X)),
  FiniteT A -> (forall a:A, closed (F a)) ->
  closed (IndexedUnion F).

Hint Unfold closed : topology.
Hint Resolve (@open_family_union) (@open_intersection2) open_full
  open_empty (@open_union2) (@open_indexed_union)
  (@open_finite_indexed_intersection) (@closed_complement_open)
  (@closed_union2) (@closed_intersection2) (@closed_family_intersection)
  (@closed_indexed_intersection) (@closed_finite_indexed_union)
  : topology.

Section Build_from_closed_sets.

Variable X:Type.
Variable closedP : Ensemble X -> Prop.
Hypothesis closedP_empty: closedP Empty_set.
Hypothesis closedP_union2: forall F G:Ensemble X,
  closedP F -> closedP G -> closedP (Union F G).
Hypothesis closedP_family_intersection: forall F:Family X,
  (forall G:Ensemble X, In F G -> closedP G) ->
  closedP (FamilyIntersection F).

Definition Build_TopologicalSpace_from_closed_sets : TopologicalSpace.

Lemma Build_TopologicalSpace_from_closed_sets_closed:
  forall (F:Ensemble (point_set Build_TopologicalSpace_from_closed_sets)),
  closed F <-> closedP F.

End Build_from_closed_sets.

Arguments Build_TopologicalSpace_from_closed_sets {X}. *)
Require Export Neighborhoods.
(* Neighborhoods:
Require Export TopologicalSpaces.
Require Export Ensembles.
From ZornsLemma Require Import EnsemblesImplicit.
Require Export InteriorsClosures.

Definition open_neighborhood {X:TopologicalSpace}
  (U:Ensemble (point_set X)) (x:point_set X) :=
  open U /\ In U x.

Definition neighborhood {X:TopologicalSpace}
  (N:Ensemble (point_set X)) (x:point_set X) :=
  exists U:Ensemble (point_set X),
    open_neighborhood U x /\ Included U N.

Lemma open_neighborhood_is_neighborhood: forall {X:TopologicalSpace}
  (U:Ensemble (point_set X)) (x:point_set X),
  open_neighborhood U x -> neighborhood U x.

Lemma neighborhood_interior: forall {X:TopologicalSpace}
  (N:Ensemble (point_set X)) (x:point_set X),
  neighborhood N x -> In (interior N) x.

Lemma interior_neighborhood: forall {X:TopologicalSpace}
  (N:Ensemble (point_set X)) (x:point_set X),
  In (interior N) x -> neighborhood N x. *)
From ZornsLemma Require Export InverseImage.
Require Export OpenBases.
(* OpenBases:
Require Export TopologicalSpaces.
Require Import ClassicalChoice.
From ZornsLemma Require Import EnsemblesSpec.

Section OpenBasis.

Variable X : TopologicalSpace.
Variable B : Family (point_set X).

Record open_basis : Prop :=
  { open_basis_elements :
     forall V:Ensemble (point_set X), In B V -> open V;
    open_basis_cover :
     forall (x:point_set X) (U:Ensemble (point_set X)),
        open U -> In U x -> exists V:Ensemble (point_set X),
        In B V /\ Included V U /\ In V x
  }.

Hypothesis Hbasis: open_basis.

Lemma coverable_by_open_basis_impl_open:
  forall U:Ensemble (point_set X),
    (forall x:point_set X, In U x -> exists V:Ensemble (point_set X),
     In B V /\ Included V U /\ In V x) -> open U.

End OpenBasis.

Arguments open_basis {X}.
Arguments coverable_by_open_basis_impl_open {X}.
Arguments open_basis_elements {X}.
Arguments open_basis_cover {X}.

Section BuildFromOpenBasis.

Variable X : Type.
Variable B : Family X.

Definition open_basis_cond :=
  forall U V:Ensemble X, In B U -> In B V ->
    forall x:X, In (Intersection U V) x ->
      exists W:Ensemble X, In B W /\ In W x /\
                           Included W (Intersection U V).
Definition open_basis_cover_cond :=
  forall x:X, exists U:Ensemble X, In B U /\ In U x.

Hypothesis Hbasis : open_basis_cond.
Hypothesis Hbasis_cover: open_basis_cover_cond.

Inductive B_open : Ensemble X -> Prop :=
  | B_open_intro: forall F:Family X, Included F B ->
    B_open (FamilyUnion F).

Definition Build_TopologicalSpace_from_open_basis : TopologicalSpace.

Lemma Build_TopologicalSpace_from_open_basis_point_set:
  point_set Build_TopologicalSpace_from_open_basis = X.

Lemma Build_TopologicalSpace_from_open_basis_basis:
  @open_basis Build_TopologicalSpace_from_open_basis B.

End BuildFromOpenBasis.

Arguments open_basis_cond {X}.
Arguments open_basis_cover_cond {X}.
Arguments Build_TopologicalSpace_from_open_basis {X}.
Arguments Build_TopologicalSpace_from_open_basis_point_set {X}.
Arguments Build_TopologicalSpace_from_open_basis_basis {X}. *)
Require Export NeighborhoodBases.
(* NeighborhoodBases:
Require Export TopologicalSpaces.
Require Export Neighborhoods.
Require Export OpenBases.
From ZornsLemma Require Export IndexedFamilies.
From ZornsLemma Require Export EnsemblesSpec.

Record neighborhood_basis {X:TopologicalSpace}
  (NB:Family (point_set X)) (x:point_set X) : Prop := {
  neighborhood_basis_elements: forall N:Ensemble (point_set X),
    In NB N -> neighborhood N x;
  neighborhood_basis_cond: forall N:Ensemble (point_set X),
    neighborhood N x -> exists N':Ensemble (point_set X),
    In NB N' /\ Included N' N
}.

Record open_neighborhood_basis {X:TopologicalSpace}
  (NB:Family (point_set X)) (x:point_set X) : Prop := {
  open_neighborhood_basis_elements: forall U:Ensemble (point_set X),
    In NB U -> open_neighborhood U x;
  open_neighborhood_basis_cond: forall U:Ensemble (point_set X),
    open_neighborhood U x -> exists V:Ensemble (point_set X),
    In NB V /\ Included V U
}.

Lemma open_neighborhood_basis_is_neighborhood_basis:
  forall {X:TopologicalSpace} (NB:Family (point_set X)) (x:point_set X),
  open_neighborhood_basis NB x -> neighborhood_basis NB x.

Lemma open_basis_to_open_neighborhood_basis:
  forall {X:TopologicalSpace} (B:Family (point_set X)) (x:point_set X),
    open_basis B -> open_neighborhood_basis
                    [ U:Ensemble (point_set X) | In B U /\ In U x ]
                    x.

Lemma open_neighborhood_bases_to_open_basis:
  forall {X:TopologicalSpace} (NB : point_set X -> Family (point_set X)),
    (forall x:point_set X, open_neighborhood_basis (NB x) x) ->
    open_basis (IndexedUnion NB).

Section build_from_open_neighborhood_bases.

Variable X:Type.
Variable NB : X -> Family X.

Hypothesis neighborhood_basis_cond :
  forall (U V:Ensemble X) (x:X), In (NB x) U -> In (NB x) V ->
    exists W:Ensemble X, In (NB x) W /\ Included W (Intersection U V).
Hypothesis neighborhood_basis_cond2 :
  forall (U:Ensemble X) (x:X), In (NB x) U -> In U x.
Hypothesis neighborhood_basis_inhabited_cond :
  forall x:X, Inhabited (NB x).
Hypothesis neighborhood_basis_system_cond :
  forall (x y:X) (U:Ensemble X), In (NB x) U -> In U y ->
  exists V:Ensemble X, In (NB y) V /\ Included V U.

Definition Build_TopologicalSpace_from_open_neighborhood_bases :
  TopologicalSpace.

Lemma Build_TopologicalSpace_from_open_neighborhood_bases_basis:
  forall x:X,
    open_neighborhood_basis (NB x) x
      (X:=Build_TopologicalSpace_from_open_neighborhood_bases).

End build_from_open_neighborhood_bases. *)
Require Export Subbases.
(* Subbases:
Require Export TopologicalSpaces.
Require Export OpenBases.
From ZornsLemma Require Export FiniteTypes.
From ZornsLemma Require Export EnsemblesSpec.

Section Subbasis.

Variable X:TopologicalSpace.
Variable SB:Family (point_set X).

Record subbasis : Prop := {
  subbasis_elements: forall U:Ensemble (point_set X),
    In SB U -> open U;
  subbasis_cover: forall (U:Ensemble (point_set X)) (x:point_set X),
    In U x -> open U ->
    exists A:Type, FiniteT A /\
    exists V:A->Ensemble (point_set X),
      (forall a:A, In SB (V a)) /\
      In (IndexedIntersection V) x /\
      Included (IndexedIntersection V) U
}.

Lemma open_basis_is_subbasis: open_basis SB -> subbasis.

Lemma finite_intersections_of_subbasis_form_open_basis:
  subbasis ->
  open_basis [ U:Ensemble (point_set X) |
              exists A:Type, FiniteT A /\
              exists V:A->Ensemble (point_set X),
              (forall a:A, In SB (V a)) /\
              U = IndexedIntersection V ].

End Subbasis.

Arguments subbasis {X}.

Section build_from_subbasis.

Variable X:Type.
Variable S:Family X.

From ZornsLemma Require Import FiniteIntersections.

Definition Build_TopologicalSpace_from_subbasis : TopologicalSpace.

Lemma Build_TopologicalSpace_from_subbasis_subbasis:
  @subbasis Build_TopologicalSpace_from_subbasis S.

End build_from_subbasis. *)

Section continuity.

Variable X Y:TopologicalSpace.
Variable f:point_set X -> point_set Y.

Definition continuous : Prop :=
  forall V:Ensemble (point_set Y), open V ->
  open (inverse_image f V).

Definition continuous_at (x:point_set X) : Prop :=
  forall V:Ensemble (point_set Y),
  neighborhood V (f x) -> neighborhood (inverse_image f V) x.

Lemma continuous_at_open_neighborhoods:
  forall x:point_set X,
  (forall V:Ensemble (point_set Y),
  open_neighborhood V (f x) -> neighborhood (inverse_image f V) x) ->
  continuous_at x.
Proof.
intros.
red; intros.
destruct H0 as [V' [? ?]].
pose proof (H V' H0).
destruct H2 as [U' [? ?]].
exists U'; split; trivial.
apply (inverse_image_increasing f) in H1; auto with sets.
Qed.

Lemma pointwise_continuity :
  (forall x:point_set X, continuous_at x) -> continuous.
Proof.
intros.
red; intros.
assert (interior (inverse_image f V) = inverse_image f V).
apply Extensionality_Ensembles; split.
apply interior_deflationary.
red; intros.
destruct H1.
assert (neighborhood V (f x)).
exists V; repeat split; auto with sets.
pose proof (H x V H2).
destruct H3 as [U].
destruct H3.
destruct H3.
assert (Included U (interior (inverse_image f V))).
apply interior_maximal; trivial.
auto.

rewrite <- H1; apply interior_open.
Qed.

Lemma continuous_func_continuous_everywhere:
  continuous -> forall x:point_set X, continuous_at x.
Proof.
intros.
apply continuous_at_open_neighborhoods.
intros.
apply open_neighborhood_is_neighborhood.
destruct H0; split; try constructor; auto.
Qed.

Lemma continuous_at_neighborhood_basis:
  forall (x:point_set X) (NB:Family (point_set Y)),
  neighborhood_basis NB (f x) ->
  (forall V:Ensemble (point_set Y),
  In NB V -> neighborhood (inverse_image f V) x) ->
  continuous_at x.
Proof.
intros.
red; intros.
destruct H.
apply neighborhood_basis_cond in H1.
destruct H1 as [N [? ?]].
pose proof (H0 N H).
destruct H2 as [U [? ?]].
exists U; split; trivial.
assert (Included (inverse_image f N) (inverse_image f V));
  auto with sets.
Qed.

Lemma continuous_open_basis:
  forall (B:Family (point_set Y)), open_basis B ->
  (forall V:Ensemble (point_set Y),
    In B V -> open (inverse_image f V)) -> continuous.
Proof.
intros.
apply pointwise_continuity.
intro.
pose proof (open_basis_to_open_neighborhood_basis B (f x) H).
apply open_neighborhood_basis_is_neighborhood_basis in H1.
apply (continuous_at_neighborhood_basis _ _ H1).
intros.
destruct H2 as [[? ?]].
apply open_neighborhood_is_neighborhood.
split; try constructor; auto.
Qed.

Lemma continuous_subbasis:
  forall (SB:Family (point_set Y)), subbasis SB ->
  (forall V:Ensemble (point_set Y),
     In SB V -> open (inverse_image f V)) -> continuous.
Proof.
intros.
apply (continuous_open_basis _
  (finite_intersections_of_subbasis_form_open_basis _ _ H)).
intros.
destruct H1.
destruct H1 as [A [? [V' []]]].
rewrite H3.
assert (inverse_image f (IndexedIntersection V') =
  IndexedIntersection (fun a:A => inverse_image f (V' a))).
apply Extensionality_Ensembles; split; red; intros.
destruct H4.
inversion_clear H4.
constructor; intros.
constructor.
apply H5.
destruct H4.
constructor.
constructor; intros.
destruct (H4 a).
exact H5.

rewrite H4.
apply open_finite_indexed_intersection; trivial.
intros.
apply H0.
apply H2.
Qed.

End continuity.

Arguments continuous {X} {Y}.
Arguments continuous_at {X} {Y}.

Lemma continuous_composition_at: forall {X Y Z:TopologicalSpace}
  (f:point_set Y -> point_set Z) (g:point_set X -> point_set Y)
  (x:point_set X),
  continuous_at f (g x) -> continuous_at g x ->
  continuous_at (fun x:point_set X => f (g x)) x.
Proof.
intros.
red; intros.
rewrite inverse_image_composition.
auto.
Qed.

Lemma continuous_composition: forall {X Y Z:TopologicalSpace}
  (f:point_set Y -> point_set Z) (g:point_set X -> point_set Y),
  continuous f -> continuous g ->
  continuous (fun x:point_set X => f (g x)).
Proof.
intros.
red; intros.
rewrite inverse_image_composition.
auto.
Qed.

Lemma continuous_identity: forall (X:TopologicalSpace),
  continuous (fun x:point_set X => x).
Proof.
intros.
red; intros.
apply eq_ind with (1:=H).
apply Extensionality_Ensembles; split; red; intros.
constructor; trivial.
destruct H0; trivial.
Qed.

Lemma continuous_constant: forall (X Y:TopologicalSpace)
  (y0:point_set Y), continuous (fun x:point_set X => y0).
Proof.
intros.
pose (f := fun _:point_set X => y0).
fold f.
red; intros.
destruct (classic (In V y0)).
replace (inverse_image f V) with (@Full_set (point_set X)).
apply open_full.
apply Extensionality_Ensembles; split; red; intros.
constructor; trivial.
constructor.
replace (inverse_image f V) with (@Empty_set (point_set X)).
apply open_empty.
apply Extensionality_Ensembles; split; auto with sets;
  red; intros.
destruct H1.
contradiction H0.
Qed.

Lemma continuous_at_is_local: forall (X Y:TopologicalSpace)
  (x0:point_set X) (f g:point_set X -> point_set Y)
  (N:Ensemble (point_set X)),
  neighborhood N x0 -> (forall x:point_set X, In N x -> f x = g x) ->
  continuous_at f x0 -> continuous_at g x0.
Proof.
intros.
red; intros.
destruct H as [U1 [[]]].
rewrite <- H0 in H2.
apply H1 in H2.
destruct H2 as [U2 [[]]].
exists (Intersection U1 U2).
repeat split; trivial.
apply open_intersection2; trivial.
destruct H7.
rewrite <- H0.
apply H6 in H8.
destruct H8; trivial.
auto.
auto.
Qed.
