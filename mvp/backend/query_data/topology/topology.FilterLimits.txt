Require Export TopologicalSpaces.
(* TopologicalSpaces:
Require Export Ensembles.
From ZornsLemma Require Import EnsemblesImplicit.
From ZornsLemma Require Export Families.
From ZornsLemma Require Export IndexedFamilies.
From ZornsLemma Require Export FiniteTypes.
From ZornsLemma Require Import EnsemblesSpec.

Record TopologicalSpace : Type := {
  point_set : Type;
  open : Ensemble point_set -> Prop;
  open_family_union : forall F : Family point_set,
    (forall S : Ensemble point_set, In F S -> open S) ->
    open (FamilyUnion F);
  open_intersection2: forall U V:Ensemble point_set,
    open U -> open V -> open (Intersection U V);
  open_full : open Full_set
}.

Arguments open {t}.
Arguments open_family_union {t}.
Arguments open_intersection2 {t}.

Lemma open_empty: forall X:TopologicalSpace,
  open (@Empty_set (point_set X)).

Lemma open_union2: forall {X:TopologicalSpace}
  (U V:Ensemble (point_set X)), open U -> open V -> open (Union U V).

Lemma open_indexed_union: forall {X:TopologicalSpace} {A:Type}
  (F:IndexedFamily A (point_set X)),
  (forall a:A, open (F a)) -> open (IndexedUnion F).

Lemma open_finite_indexed_intersection:
  forall {X:TopologicalSpace} {A:Type}
    (F:IndexedFamily A (point_set X)),
    FiniteT A -> (forall a:A, open (F a)) ->
    open (IndexedIntersection F).

Definition closed {X:TopologicalSpace} (F:Ensemble (point_set X)) :=
  open (Ensembles.Complement F).

Lemma closed_complement_open: forall {X:TopologicalSpace}
  (U:Ensemble (point_set X)), closed (Ensembles.Complement U) ->

Lemma closed_union2: forall {X:TopologicalSpace}
  (F G:Ensemble (point_set X)),
  closed F -> closed G -> closed (Union F G).

Lemma closed_intersection2: forall {X:TopologicalSpace}
  (F G:Ensemble (point_set X)),
  closed F -> closed G -> closed (Intersection F G).

Lemma closed_family_intersection: forall {X:TopologicalSpace}
  (F:Family (point_set X)),
  (forall S:Ensemble (point_set X), In F S -> closed S) ->
  closed (FamilyIntersection F).

Lemma closed_indexed_intersection: forall {X:TopologicalSpace}
  {A:Type} (F:IndexedFamily A (point_set X)),
  (forall a:A, closed (F a)) -> closed (IndexedIntersection F).

Lemma closed_finite_indexed_union: forall {X:TopologicalSpace}
  {A:Type} (F:IndexedFamily A (point_set X)),
  FiniteT A -> (forall a:A, closed (F a)) ->
  closed (IndexedUnion F).

Hint Unfold closed : topology.
Hint Resolve (@open_family_union) (@open_intersection2) open_full
  open_empty (@open_union2) (@open_indexed_union)
  (@open_finite_indexed_intersection) (@closed_complement_open)
  (@closed_union2) (@closed_intersection2) (@closed_family_intersection)
  (@closed_indexed_intersection) (@closed_finite_indexed_union)
  : topology.

Section Build_from_closed_sets.

Variable X:Type.
Variable closedP : Ensemble X -> Prop.
Hypothesis closedP_empty: closedP Empty_set.
Hypothesis closedP_union2: forall F G:Ensemble X,
  closedP F -> closedP G -> closedP (Union F G).
Hypothesis closedP_family_intersection: forall F:Family X,
  (forall G:Ensemble X, In F G -> closedP G) ->
  closedP (FamilyIntersection F).

Definition Build_TopologicalSpace_from_closed_sets : TopologicalSpace.

Lemma Build_TopologicalSpace_from_closed_sets_closed:
  forall (F:Ensemble (point_set Build_TopologicalSpace_from_closed_sets)),
  closed F <-> closedP F.

End Build_from_closed_sets.

Arguments Build_TopologicalSpace_from_closed_sets {X}. *)
Require Export Filters.
(* Filters:
From ZornsLemma Require Export Families.
From ZornsLemma Require Import EnsemblesSpec.

Record Filter (X:Type) : Type := {
  filter_family: Family X;
  filter_intersection: forall S1 S2:Ensemble X,
    In filter_family S1 -> In filter_family S2 ->
    In filter_family (Intersection S1 S2);
  filter_upward_closed: forall S1 S2:Ensemble X,
    In filter_family S1 -> Included S1 S2 ->
    In filter_family S2;
  filter_full: In filter_family Full_set;
  filter_empty: ~ In filter_family Empty_set
}.

Arguments filter_family {X}.

Record filter_basis {X:Type} (F:Filter X) (B:Family X) : Prop := {
  filter_basis_elements: Included B (filter_family F);
  filter_basis_cond: forall S:Ensemble X,
    In (filter_family F) S -> exists S':Ensemble X,
    In B S' /\ Included S' S
}.

From ZornsLemma Require Export IndexedFamilies.
From ZornsLemma Require Export FiniteTypes.

Lemma filter_finite_indexed_intersection: forall {X:Type} (F:Filter X)
  {A:Type} (S:IndexedFamily A X),
  FiniteT A -> (forall a:A, In (filter_family F) (S a)) ->
  In (filter_family F) (IndexedIntersection S).

Section filter_from_basis.

Variable X:Type.
Variable B:Family X.
Hypothesis B_nonempty: Inhabited B.
Hypothesis B_empty: ~ In B Empty_set.
Hypothesis B_basis_cond: forall S1 S2:Ensemble X,
  In B S1 -> In B S2 -> exists T:Ensemble X,
  In B T /\ Included T (Intersection S1 S2).

Definition Build_Filter_from_basis : Filter X.

Lemma filter_from_basis_basis: filter_basis Build_Filter_from_basis B.

End filter_from_basis.

Arguments Build_Filter_from_basis {X}.

From ZornsLemma Require Export FiniteTypes.
From ZornsLemma Require Export IndexedFamilies.

Record filter_subbasis {X:Type} (F:Filter X) (B:Family X) : Prop := {
  filter_subbasis_elements: Included B (filter_family F);
  filter_subbasis_cond: forall S:Ensemble X,
    In (filter_family F) S -> exists J:Type, FiniteT J /\
          exists T:J->Ensemble X,
          (forall j:J, In B (T j)) /\
          Included (IndexedIntersection T) S
}.

Section filter_from_subbasis.

Variable X:Type.
Variable B:Family X.
Hypothesis B_subbasis_cond: forall (J:Type) (V:J->Ensemble X),
  FiniteT J -> (forall j:J, In B (V j)) ->
  Inhabited (IndexedIntersection V).

From ZornsLemma Require Import FiniteIntersections.

Definition Build_Filter_from_subbasis: Filter X.

Lemma filter_from_subbasis_subbasis:
  filter_subbasis Build_Filter_from_subbasis B.

End filter_from_subbasis.

Arguments Build_Filter_from_subbasis {X}.

Definition ultrafilter {X:Type} (F:Filter X) : Prop :=
  forall S:Ensemble X, In (filter_family F) S \/
                       In (filter_family F) (Ensembles.Complement S).

From ZornsLemma Require Import ZornsLemma.

Lemma ultrafilter_extension: forall {X:Type} (F:Filter X),
  exists U:Filter X, Included (filter_family F) (filter_family U) /\
                     ultrafilter U.
Proof.
intros.
pose (PO := { F':Filter X | Included (filter_family F) (filter_family F') }).
pose (PO_ord := fun (F1' F2':PO) =>
  Included (filter_family (proj1_sig F1')) (filter_family (proj1_sig F2'))).
assert (exists U:PO, premaximal PO_ord U).
apply ZornsLemmaForPreorders.
constructor.
red; intro.
destruct x.
red; simpl.
auto with sets.
red; intros.
destruct x; destruct y; destruct z.
red in H; simpl in H.
red in H0; simpl in H0.
red; simpl.
auto with sets.

intros.
From ZornsLemma Require Import DecidableDec.

From ZornsLemma Require Export InverseImage.

Definition filter_direct_image {X Y:Type} (f:X->Y) (F:Filter X) : Filter Y.

Section filter_sum.

Variable X:Type.
Variable F G:Filter X.
Hypothesis F_G_compat: forall S T:Ensemble X,
  In (filter_family F) S -> In (filter_family G) T ->
  Inhabited (Intersection S T).

Definition filter_sum : Filter X.

End filter_sum.

Arguments filter_sum {X}. *)
Require Export Neighborhoods.
(* Neighborhoods:
Require Export TopologicalSpaces.
Require Export Ensembles.
From ZornsLemma Require Import EnsemblesImplicit.
Require Export InteriorsClosures.

Definition open_neighborhood {X:TopologicalSpace}
  (U:Ensemble (point_set X)) (x:point_set X) :=
  open U /\ In U x.

Definition neighborhood {X:TopologicalSpace}
  (N:Ensemble (point_set X)) (x:point_set X) :=
  exists U:Ensemble (point_set X),
    open_neighborhood U x /\ Included U N.

Lemma open_neighborhood_is_neighborhood: forall {X:TopologicalSpace}
  (U:Ensemble (point_set X)) (x:point_set X),
  open_neighborhood U x -> neighborhood U x.

Lemma neighborhood_interior: forall {X:TopologicalSpace}
  (N:Ensemble (point_set X)) (x:point_set X),
  neighborhood N x -> In (interior N) x.

Lemma interior_neighborhood: forall {X:TopologicalSpace}
  (N:Ensemble (point_set X)) (x:point_set X),
  In (interior N) x -> neighborhood N x. *)

Definition neighborhood_filter {X:TopologicalSpace} (x0:point_set X) :
  Filter (point_set X).
refine (Build_Filter _
  [ N:Ensemble (point_set X) | neighborhood N x0 ]
  _ _ _ _).
intros.
destruct H; destruct H0; constructor.
destruct H as [U []].
destruct H0 as [V []].
destruct H.
destruct H0.
exists (Intersection U V); split.
split.
apply open_intersection2; trivial.
constructor; trivial.
red; intros.
destruct H5; constructor; auto.

intros.
destruct H.
destruct H as [U [[]]].
constructor.
exists U; repeat split; trivial.
auto with sets.

constructor.
exists Full_set; repeat split; auto with sets topology.

red; intro.
destruct H.
destruct H as [U [[]]].
apply H1 in H0.
destruct H0.
Defined.

Definition filter_limit {X:TopologicalSpace} (F:Filter (point_set X))
  (x0:point_set X) : Prop :=
  Included (filter_family (neighborhood_filter x0))
           (filter_family F).

Definition filter_cluster_point {X:TopologicalSpace}
  (F:Filter (point_set X)) (x0:point_set X) : Prop :=
  forall S:Ensemble (point_set X), In (filter_family F) S ->
  In (closure S) x0.

Lemma filter_limit_is_cluster_point:
  forall {X:TopologicalSpace} (F:Filter (point_set X)) (x0:point_set X),
  filter_limit F x0 -> filter_cluster_point F x0.
Proof.
intros.
red; intros.
apply meets_every_open_neighborhood_impl_closure.
intros.
assert (In (filter_family F) U).
apply H.
simpl.
constructor.
exists U; repeat split; auto with sets.
assert (In (filter_family F) (Intersection S U)).
apply filter_intersection; trivial.
apply NNPP; red; intro.
assert (Intersection S U = Empty_set).
apply Extensionality_Ensembles; split; red; intros.
contradiction H5.
exists x; trivial.
destruct H6.
rewrite H6 in H4.
contradiction (filter_empty _ F).
Qed.

Lemma ultrafilter_cluster_point_is_limit: forall {X:TopologicalSpace}
  (F:Filter (point_set X)) (x0:point_set X),
  filter_cluster_point F x0 -> ultrafilter F ->
  filter_limit F x0.
Proof.
intros.
red.
red; intros N ?.
destruct H1.
destruct H1 as [U [[]]].
cut (In (filter_family F) U).
intros; apply filter_upward_closed with U; trivial.
clear N H3.
apply NNPP; intro.
assert (In (filter_family F) (Complement U)).
pose proof (H0 U).
tauto.
pose proof (H _ H4).
rewrite closure_fixes_closed in H5.
contradiction H5; trivial.
red; rewrite Complement_Complement; trivial.
Qed.

Lemma closure_impl_filter_limit: forall {X:TopologicalSpace}
  (S:Ensemble (point_set X)) (x0:point_set X),
  In (closure S) x0 ->
  exists F:Filter (point_set X),
    In (filter_family F) S /\ filter_limit F x0.
Proof.
intros.
assert (Inhabited S).
destruct (closure_impl_meets_every_open_neighborhood _ _ _ H
  Full_set).
apply open_full.
constructor.
destruct H0.
exists x; trivial.

unshelve refine (let H1:=_ in let H2:=_ in let H3:=_ in
  let Sfilt := Build_Filter_from_basis (Singleton S)
  H1 H2 H3 in _).
exists S; constructor.
red; intro.
inversion H2.
rewrite H3 in H0.
destruct H0.
destruct H0.

intros.
destruct H3.
destruct H4.
exists S; split; auto with sets.

unshelve refine (let H4:=_ in
  ex_intro _ (filter_sum (neighborhood_filter x0) Sfilt H4) _).
intros.
simpl in H4.
destruct H4.
destruct H4 as [U [[]]].
simpl in H5.
destruct H5.
destruct H5 as [T0 []].
destruct H5.
destruct (closure_impl_meets_every_open_neighborhood
  _ _ _ H U); trivial.
destruct H5.
exists x; constructor; auto.

split.
simpl.
constructor.
exists S.
split; auto with sets.
exists ( (Full_set, S) ).
constructor; split.
constructor.
exists Full_set; repeat split.
apply open_full.
constructor.
exists S; split; auto with sets.
apply Extensionality_Ensembles; split; red; intros.
constructor; trivial; constructor.
destruct H5; trivial.

red; red; intros U ?.
constructor.
exists U.
split; auto with sets.
exists ( (U, Full_set) ).
constructor.
split; trivial.
constructor.
exists S; split; auto with sets.
red; intros; constructor.
apply Extensionality_Ensembles; split; red; intros.
constructor; trivial; constructor.
destruct H6; trivial.
Qed.

Require Export Continuity.
(* Continuity:
Require Export TopologicalSpaces.
Require Export Neighborhoods.
From ZornsLemma Require Export InverseImage.
Require Export OpenBases.
Require Export NeighborhoodBases.
Require Export Subbases.

Section continuity.

Variable X Y:TopologicalSpace.
Variable f:point_set X -> point_set Y.

Definition continuous : Prop :=
  forall V:Ensemble (point_set Y), open V ->
  open (inverse_image f V).

Definition continuous_at (x:point_set X) : Prop :=
  forall V:Ensemble (point_set Y),
  neighborhood V (f x) -> neighborhood (inverse_image f V) x.

Lemma continuous_at_open_neighborhoods:
  forall x:point_set X,
  (forall V:Ensemble (point_set Y),
  open_neighborhood V (f x) -> neighborhood (inverse_image f V) x) ->
  continuous_at x.

Lemma pointwise_continuity :
  (forall x:point_set X, continuous_at x) -> continuous.

Lemma continuous_func_continuous_everywhere:
  continuous -> forall x:point_set X, continuous_at x.

Lemma continuous_at_neighborhood_basis:
  forall (x:point_set X) (NB:Family (point_set Y)),
  neighborhood_basis NB (f x) ->
  (forall V:Ensemble (point_set Y),
  In NB V -> neighborhood (inverse_image f V) x) ->
  continuous_at x.

Lemma continuous_open_basis:
  forall (B:Family (point_set Y)), open_basis B ->
  (forall V:Ensemble (point_set Y),
    In B V -> open (inverse_image f V)) -> continuous.

Lemma continuous_subbasis:
  forall (SB:Family (point_set Y)), subbasis SB ->
  (forall V:Ensemble (point_set Y),
     In SB V -> open (inverse_image f V)) -> continuous.

End continuity.

Arguments continuous {X} {Y}.
Arguments continuous_at {X} {Y}.

Lemma continuous_composition_at: forall {X Y Z:TopologicalSpace}
  (f:point_set Y -> point_set Z) (g:point_set X -> point_set Y)
  (x:point_set X),
  continuous_at f (g x) -> continuous_at g x ->
  continuous_at (fun x:point_set X => f (g x)) x.

Lemma continuous_composition: forall {X Y Z:TopologicalSpace}
  (f:point_set Y -> point_set Z) (g:point_set X -> point_set Y),
  continuous f -> continuous g ->
  continuous (fun x:point_set X => f (g x)).

Lemma continuous_identity: forall (X:TopologicalSpace),
  continuous (fun x:point_set X => x).

Lemma continuous_constant: forall (X Y:TopologicalSpace)
  (y0:point_set Y), continuous (fun x:point_set X => y0).

Lemma continuous_at_is_local: forall (X Y:TopologicalSpace)
  (x0:point_set X) (f g:point_set X -> point_set Y)
  (N:Ensemble (point_set X)),
  neighborhood N x0 -> (forall x:point_set X, In N x -> f x = g x) ->
  continuous_at f x0 -> continuous_at g x0. *)

Lemma continuous_function_preserves_filter_limits:
  forall (X Y:TopologicalSpace) (f:point_set X -> point_set Y)
    (x:point_set X) (F:Filter (point_set X)),
  filter_limit F x -> continuous_at f x ->
  filter_limit (filter_direct_image f F) (f x).
Proof.
intros.
red; intros.
intros V ?.
destruct H1.
constructor.
cut (In (filter_family (neighborhood_filter x))
  (inverse_image f V)).
apply H.
constructor.
apply H0; trivial.
Qed.

Lemma func_preserving_filter_limits_is_continuous:
  forall (X Y:TopologicalSpace) (f:point_set X -> point_set Y)
    (x:point_set X),
  (forall F:Filter (point_set X), filter_limit F x ->
                     filter_limit (filter_direct_image f F) (f x)) ->
  continuous_at f x.
Proof.
intros.
assert (filter_limit (filter_direct_image f (neighborhood_filter x))
  (f x)).
apply H.
red; auto with sets.
red; intros V ?.
assert (In (filter_family (filter_direct_image f (neighborhood_filter x)))
  V).
apply H0.
constructor.
trivial.
destruct H2.
destruct H2.
trivial.
Qed.
