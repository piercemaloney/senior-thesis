Require Export FilterLimits.
(* FilterLimits:
Require Export TopologicalSpaces.
Require Export Filters.
Require Export Neighborhoods.

Definition neighborhood_filter {X:TopologicalSpace} (x0:point_set X) :
  Filter (point_set X).

Definition filter_limit {X:TopologicalSpace} (F:Filter (point_set X))
  (x0:point_set X) : Prop :=
  Included (filter_family (neighborhood_filter x0))
           (filter_family F).

Definition filter_cluster_point {X:TopologicalSpace}
  (F:Filter (point_set X)) (x0:point_set X) : Prop :=
  forall S:Ensemble (point_set X), In (filter_family F) S ->
  In (closure S) x0.

Lemma filter_limit_is_cluster_point:
  forall {X:TopologicalSpace} (F:Filter (point_set X)) (x0:point_set X),
  filter_limit F x0 -> filter_cluster_point F x0.

Lemma ultrafilter_cluster_point_is_limit: forall {X:TopologicalSpace}
  (F:Filter (point_set X)) (x0:point_set X),
  filter_cluster_point F x0 -> ultrafilter F ->
  filter_limit F x0.

Lemma closure_impl_filter_limit: forall {X:TopologicalSpace}
  (S:Ensemble (point_set X)) (x0:point_set X),
  In (closure S) x0 ->
  exists F:Filter (point_set X),
    In (filter_family F) S /\ filter_limit F x0.

Require Export Continuity.

Lemma continuous_function_preserves_filter_limits:
  forall (X Y:TopologicalSpace) (f:point_set X -> point_set Y)
    (x:point_set X) (F:Filter (point_set X)),
  filter_limit F x -> continuous_at f x ->
  filter_limit (filter_direct_image f F) (f x).

Lemma func_preserving_filter_limits_is_continuous:
  forall (X Y:TopologicalSpace) (f:point_set X -> point_set Y)
    (x:point_set X),
  (forall F:Filter (point_set X), filter_limit F x ->
                     filter_limit (filter_direct_image f F) (f x)) ->
  continuous_at f x. *)
Require Export Nets.
(* Nets:
Require Export TopologicalSpaces.
Require Export DirectedSets.
Require Export InteriorsClosures.
Require Export Continuity.

Set Asymmetric Patterns.

Section Net.

Variable I:DirectedSet.
Variable X:TopologicalSpace.

Definition Net := DS_set I -> point_set X.

Definition net_limit (x:Net) (x0:point_set X) : Prop :=
  forall U:Ensemble (point_set X), open U -> In U x0 ->
  for large i:DS_set I, In U (x i).

Definition net_cluster_point (x:Net) (x0:point_set X) : Prop :=
  forall U:Ensemble (point_set X), open U -> In U x0 ->
  exists arbitrarily large i:DS_set I, In U (x i).

Lemma net_limit_is_cluster_point: forall (x:Net) (x0:point_set X),
  net_limit x x0 -> net_cluster_point x x0.

Lemma net_limit_in_closure: forall (S:Ensemble (point_set X))
  (x:Net) (x0:point_set X),
  (exists arbitrarily large i:DS_set I, In S (x i)) ->
  net_limit x x0 -> In (closure S) x0.

Lemma net_cluster_point_in_closure: forall (S:Ensemble (point_set X))
  (x:Net) (x0:point_set X),
  (for large i:DS_set I, In S (x i)) ->
  net_cluster_point x x0 -> In (closure S) x0.

End Net.

Arguments net_limit {I} {X}.
Arguments net_cluster_point {I} {X}.
Arguments net_limit_is_cluster_point {I} {X}.
Arguments net_limit_in_closure {I} {X}.
Arguments net_cluster_point_in_closure {I} {X}.

Section neighborhood_net.

Variable X:TopologicalSpace.
Variable x:point_set X.

Inductive neighborhood_net_DS_set : Type :=
  | intro_neighborhood_net_DS :
    forall (U:Ensemble (point_set X)) (y:point_set X),
    open U -> In U x -> In U y -> neighborhood_net_DS_set.

Definition neighborhood_net_DS_ord
  (Uy Vz:neighborhood_net_DS_set) : Prop :=
  match Uy, Vz with
  | intro_neighborhood_net_DS U _ _ _ _,
    intro_neighborhood_net_DS V _ _ _ _ =>
    Included V U
  end.

Definition neighborhood_net_DS : DirectedSet.

Definition neighborhood_net : Net neighborhood_net_DS X :=
  fun (x:neighborhood_net_DS_set) => match x with
  | intro_neighborhood_net_DS _ y _ _ _ => y
  end.

Lemma neighborhood_net_limit: net_limit neighborhood_net x.

End neighborhood_net.

Lemma net_limits_determine_topology:
  forall {X:TopologicalSpace} (S:Ensemble (point_set X))
  (x0:point_set X), In (closure S) x0 ->
  exists I:DirectedSet, exists x:Net I X,
  (forall i:DS_set I, In S (x i)) /\ net_limit x x0.

Section Nets_and_continuity.

Variable X Y:TopologicalSpace.
Variable f:point_set X -> point_set Y.

Lemma continuous_func_preserves_net_limits:
  forall {I:DirectedSet} (x:Net I X) (x0:point_set X),
    net_limit x x0 -> continuous_at f x0 ->
    net_limit (fun i:DS_set I => f (x i)) (f x0).

Lemma func_preserving_net_limits_is_continuous:
  forall x0:point_set X,
  (forall (I:DirectedSet) (x:Net I X),
    net_limit x x0 -> net_limit (fun i:DS_set I => f (x i)) (f x0))
  -> continuous_at f x0.

End Nets_and_continuity.

Section Subnet.

Variable X:TopologicalSpace.
Variable I:DirectedSet.
Variable x:Net I X.

Inductive Subnet {J:DirectedSet} : Net J X -> Prop :=
  | intro_subnet: forall h:DS_set J -> DS_set I,
    (forall j1 j2:DS_set J, DS_ord j1 j2 ->
       DS_ord (h j1) (h j2)) ->
    (exists arbitrarily large i:DS_set I,
       exists j:DS_set J, h j = i) ->
    Subnet (fun j:DS_set J => x (h j)).

Lemma subnet_limit: forall (x0:point_set X) {J:DirectedSet}
  (y:Net J X), net_limit x x0 -> Subnet y ->
  net_limit y x0.

Lemma subnet_cluster_point: forall (x0:point_set X) {J:DirectedSet}
  (y:Net J X), net_cluster_point y x0 ->
  Subnet y -> net_cluster_point x x0.

Section cluster_point_subnet.

Variable x0:point_set X.
Hypothesis x0_cluster_point: net_cluster_point x x0.
Hypothesis I_nonempty: inhabited (DS_set I).

Record cluster_point_subnet_DS_set : Type := {
  cps_i:DS_set I;
  cps_U:Ensemble (point_set X);
  cps_U_open_neigh: open_neighborhood cps_U x0;
  cps_xi_in_U: In cps_U (x cps_i)
}.

Definition cluster_point_subnet_DS_ord
  (iU1 iU2 : cluster_point_subnet_DS_set) : Prop :=
  DS_ord (cps_i iU1) (cps_i iU2) /\
  Included (cps_U iU2) (cps_U iU1).

Definition cluster_point_subnet_DS : DirectedSet.

Definition cluster_point_subnet : Net
  cluster_point_subnet_DS X :=
  fun (iU:DS_set cluster_point_subnet_DS) =>
  x (cps_i iU).

Lemma cluster_point_subnet_is_subnet:
  Subnet cluster_point_subnet.

Lemma cluster_point_subnet_converges:
  net_limit cluster_point_subnet x0.

Lemma net_cluster_point_impl_subnet_converges:
  exists J:DirectedSet, exists y:Net J X,
  Subnet y /\ net_limit y x0.

End cluster_point_subnet.

End Subnet. *)

Section net_tail_filter.

Variable X:TopologicalSpace.
Variable J:DirectedSet.
Variable x:Net J X.
Hypothesis J_nonempty: inhabited (DS_set J).

Definition net_tail (j:DS_set J) :=
  Im [ i:DS_set J | DS_ord j i ] x.

Definition tail_filter_basis : Family (point_set X) :=
  Im Full_set net_tail.

Definition tail_filter : Filter (point_set X).
refine (Build_Filter_from_basis tail_filter_basis _ _ _).
destruct J_nonempty as [j].
exists (net_tail j).
exists j; trivial.
constructor.
intro.
inversion H as [j].
assert (In Empty_set (x j)).
rewrite H1.
exists j; trivial.
constructor.
apply preord_refl; apply DS_ord_cond.
destruct H3.

intros.
destruct H.
destruct H0.
destruct (DS_join_cond x0 x1) as [k []].
exists (net_tail k); split.
exists k; trivial.
constructor.
red; intros.
constructor.
destruct H5 as [i0].
destruct H5.
rewrite H1.
exists i0; trivial.
constructor.
apply preord_trans with k; trivial.
apply DS_ord_cond.
destruct H5 as [i0].
destruct H5.
rewrite H2.
exists i0; trivial.
constructor.
apply preord_trans with k; trivial.
apply DS_ord_cond.
Defined.

Lemma net_limit_impl_tail_filter_limit: forall x0:point_set X,
  net_limit x x0 -> filter_limit tail_filter x0.
Proof.
intros.
red; intros.
red; intros U ?.
destruct H0.
destruct H0 as [V []].
destruct H0.
pose proof (H V H0 H2).
destruct H3 as [j0].
apply filter_upward_closed with (net_tail j0).
constructor.
exists (net_tail j0).
split.
exists j0; trivial.
constructor.
auto with sets.
intros y ?.
apply H1.
destruct H4 as [j].
rewrite H5.
apply H3.
destruct H4; assumption.
Qed.

Lemma tail_filter_limit_impl_net_limit: forall x0:point_set X,
  filter_limit tail_filter x0 -> net_limit x x0.
Proof.
intros.
intros U ? ?.
assert (In (filter_family tail_filter) U).
apply H.
constructor.
apply open_neighborhood_is_neighborhood.
split; trivial.
destruct H2.
destruct H2 as [T []].
destruct H2 as [j0].
exists j0.
intros.
apply H3.
rewrite H4.
exists j; trivial.
constructor; assumption.
Qed.

Lemma net_cluster_point_impl_tail_filter_cluster_point:
  forall x0:point_set X,
  net_cluster_point x x0 -> filter_cluster_point tail_filter x0.
Proof.
intros.
red; intros.
destruct H0.
destruct H0 as [T []].
destruct H0 as [j0].
apply meets_every_open_neighborhood_impl_closure.
intros.
pose proof (H U H3 H4).
destruct (H5 j0) as [j' []].
exists (x j').
constructor; trivial.
apply H1.
rewrite H2.
exists j'.
constructor; trivial.
reflexivity.
Qed.

Lemma tail_filter_cluster_point_impl_net_cluster_point:
  forall x0:point_set X,
  filter_cluster_point tail_filter x0 -> net_cluster_point x x0.
Proof.
intros.
red; intros.
red; intros.
assert (In (closure (net_tail i)) x0).
apply H.
constructor.
exists (net_tail i).
split.
exists i; trivial.
constructor.
auto with sets.
pose proof (closure_impl_meets_every_open_neighborhood _ _ _ H2
  U H0 H1).
destruct H3.
destruct H3.
destruct H3.
exists x1; split.
destruct H3; trivial.
rewrite <- H5; trivial.
Qed.

End net_tail_filter.

Arguments net_tail {X} {J}.
Arguments tail_filter {X} {J}.

Section filter_to_net.

Variable X:TopologicalSpace.
Variable F:Filter (point_set X).

Record filter_to_net_DS_set : Type := {
  ftn_S : Ensemble (point_set X);
  ftn_x : point_set X;
  ftn_S_in_F : In (filter_family F) ftn_S;
  ftn_x_in_S : In ftn_S ftn_x
}.

Definition filter_to_net_DS : DirectedSet.
refine (Build_DirectedSet filter_to_net_DS_set
  (fun x1 x2:filter_to_net_DS_set =>
     Included (ftn_S x2) (ftn_S x1)) _ _).
constructor.
red; intros.
auto with sets.
red; intros.
auto with sets.
intros.
destruct i.
destruct j.
assert (In (filter_family F) (Intersection ftn_S0 ftn_S1)).
apply filter_intersection; trivial.
assert (Inhabited (Intersection ftn_S0 ftn_S1)).
apply NNPP; red; intro.
assert (Intersection ftn_S0 ftn_S1 = Empty_set).
apply Extensionality_Ensembles; split; red; intros.
contradiction H0.
exists x; trivial.
destruct H1.
rewrite H1 in H.
contradiction (filter_empty _ F).
destruct H0 as [ftn_x'].
exists (Build_filter_to_net_DS_set
  (Intersection ftn_S0 ftn_S1) ftn_x' H H0).
simpl.
split; auto with sets.
Defined.

Definition filter_to_net : Net filter_to_net_DS X :=
  ftn_x.

Lemma filter_limit_impl_filter_to_net_limit: forall x0:point_set X,
  filter_limit F x0 -> net_limit filter_to_net x0.
Proof.
intros.
intros U ? ?.
assert (In (filter_family F) U).
apply H.
constructor.
apply open_neighborhood_is_neighborhood.
split; trivial.
exists (Build_filter_to_net_DS_set U x0 H2 H1).
destruct j.
simpl.
auto.
Qed.

Lemma filter_to_net_limit_impl_filter_limit: forall x0:point_set X,
  net_limit filter_to_net x0 -> filter_limit F x0.
Proof.
intros.
intros U ?.
destruct H0.
destruct H0 as [V []].
apply filter_upward_closed with V; trivial.
destruct H0.
destruct (H V H0 H2) as [[]].
apply filter_upward_closed with ftn_S0.
trivial.
red; intros.
pose proof (H3
  (Build_filter_to_net_DS_set ftn_S0 x ftn_S_in_F0 H4)).
simpl in H5.
apply H5; auto with sets.
Qed.

Lemma filter_cluster_point_impl_filter_to_net_cluster_point:
  forall x0:point_set X,
  filter_cluster_point F x0 -> net_cluster_point filter_to_net x0.
Proof.
intros.
red; intros.
red; intros.
destruct i.
pose proof (H ftn_S0 ftn_S_in_F0).
pose proof (closure_impl_meets_every_open_neighborhood _ _
  _ H2 U H0 H1).
destruct H3.
destruct H3.
exists (Build_filter_to_net_DS_set ftn_S0 x ftn_S_in_F0 H3).
simpl.
split; auto with sets.
Qed.

Lemma filter_to_net_cluster_point_impl_filter_cluster_point:
  forall x0:point_set X,
  net_cluster_point filter_to_net x0 -> filter_cluster_point F x0.
Proof.
intros.
red; intros.
apply meets_every_open_neighborhood_impl_closure; intros.
assert (Inhabited S).
apply NNPP; red; intro.
assert (S = Empty_set).
apply Extensionality_Ensembles; split; red; intros.
contradiction H3.
exists x; trivial.
destruct H4.
rewrite H4 in H0.
contradiction (filter_empty _ F).
destruct H3 as [y].
pose (j0 := Build_filter_to_net_DS_set S y H0 H3).
destruct (H U H1 H2 j0) as [j' []].
exists (filter_to_net j').
constructor; trivial.
destruct j'.
simpl.
simpl in H5.
simpl in H4.
auto.
Qed.

End filter_to_net.
