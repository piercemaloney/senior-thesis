Require Export TopologicalSpaces.
(* TopologicalSpaces:
Require Export Ensembles.
From ZornsLemma Require Import EnsemblesImplicit.
From ZornsLemma Require Export Families.
From ZornsLemma Require Export IndexedFamilies.
From ZornsLemma Require Export FiniteTypes.
From ZornsLemma Require Import EnsemblesSpec.

Record TopologicalSpace : Type := {
  point_set : Type;
  open : Ensemble point_set -> Prop;
  open_family_union : forall F : Family point_set,
    (forall S : Ensemble point_set, In F S -> open S) ->
    open (FamilyUnion F);
  open_intersection2: forall U V:Ensemble point_set,
    open U -> open V -> open (Intersection U V);
  open_full : open Full_set
}.

Arguments open {t}.
Arguments open_family_union {t}.
Arguments open_intersection2 {t}.

Lemma open_empty: forall X:TopologicalSpace,
  open (@Empty_set (point_set X)).

Lemma open_union2: forall {X:TopologicalSpace}
  (U V:Ensemble (point_set X)), open U -> open V -> open (Union U V).

Lemma open_indexed_union: forall {X:TopologicalSpace} {A:Type}
  (F:IndexedFamily A (point_set X)),
  (forall a:A, open (F a)) -> open (IndexedUnion F).

Lemma open_finite_indexed_intersection:
  forall {X:TopologicalSpace} {A:Type}
    (F:IndexedFamily A (point_set X)),
    FiniteT A -> (forall a:A, open (F a)) ->
    open (IndexedIntersection F).

Definition closed {X:TopologicalSpace} (F:Ensemble (point_set X)) :=
  open (Ensembles.Complement F).

Lemma closed_complement_open: forall {X:TopologicalSpace}
  (U:Ensemble (point_set X)), closed (Ensembles.Complement U) ->

Lemma closed_union2: forall {X:TopologicalSpace}
  (F G:Ensemble (point_set X)),
  closed F -> closed G -> closed (Union F G).

Lemma closed_intersection2: forall {X:TopologicalSpace}
  (F G:Ensemble (point_set X)),
  closed F -> closed G -> closed (Intersection F G).

Lemma closed_family_intersection: forall {X:TopologicalSpace}
  (F:Family (point_set X)),
  (forall S:Ensemble (point_set X), In F S -> closed S) ->
  closed (FamilyIntersection F).

Lemma closed_indexed_intersection: forall {X:TopologicalSpace}
  {A:Type} (F:IndexedFamily A (point_set X)),
  (forall a:A, closed (F a)) -> closed (IndexedIntersection F).

Lemma closed_finite_indexed_union: forall {X:TopologicalSpace}
  {A:Type} (F:IndexedFamily A (point_set X)),
  FiniteT A -> (forall a:A, closed (F a)) ->
  closed (IndexedUnion F).

Hint Unfold closed : topology.
Hint Resolve (@open_family_union) (@open_intersection2) open_full
  open_empty (@open_union2) (@open_indexed_union)
  (@open_finite_indexed_intersection) (@closed_complement_open)
  (@closed_union2) (@closed_intersection2) (@closed_family_intersection)
  (@closed_indexed_intersection) (@closed_finite_indexed_union)
  : topology.

Section Build_from_closed_sets.

Variable X:Type.
Variable closedP : Ensemble X -> Prop.
Hypothesis closedP_empty: closedP Empty_set.
Hypothesis closedP_union2: forall F G:Ensemble X,
  closedP F -> closedP G -> closedP (Union F G).
Hypothesis closedP_family_intersection: forall F:Family X,
  (forall G:Ensemble X, In F G -> closedP G) ->
  closedP (FamilyIntersection F).

Definition Build_TopologicalSpace_from_closed_sets : TopologicalSpace.

Lemma Build_TopologicalSpace_from_closed_sets_closed:
  forall (F:Ensemble (point_set Build_TopologicalSpace_from_closed_sets)),
  closed F <-> closedP F.

End Build_from_closed_sets.

Arguments Build_TopologicalSpace_from_closed_sets {X}. *)
Require Export WeakTopology.
(* WeakTopology:
Require Export TopologicalSpaces.
Require Export Subbases.
From ZornsLemma Require Export InverseImage.
Require Export Continuity.
Require Export Nets.

Section WeakTopology.

Variable X:Type.
Variable A:Type.
Variable Y:A->TopologicalSpace.
Variable f:forall a:A, X->point_set (Y a).

Inductive weak_topology_subbasis : Family X :=
  | intro_fa_inv_image: forall (a:A) (V:Ensemble (point_set (Y a))),
    open V -> In weak_topology_subbasis (inverse_image (f a) V).

Definition WeakTopology : TopologicalSpace :=
  Build_TopologicalSpace_from_subbasis X weak_topology_subbasis.

Lemma weak_topology_makes_continuous_funcs:
  forall a:A, continuous (f a) (X:=WeakTopology).

Lemma weak_topology_is_weakest: forall (T':Family X)
  (H1:_) (H2:_) (H3:_),
  (forall a:A, continuous (f a)
     (X := Build_TopologicalSpace X T' H1 H2 H3)) ->
  forall U:Ensemble X, @open WeakTopology U -> T' U.

Section WeakTopology_and_Nets.

Variable I:DirectedSet.
Hypothesis I_nonempty: inhabited (DS_set I).
Variable x:Net I WeakTopology.
Variable x0:X.

Lemma net_limit_in_weak_topology_impl_net_limit_in_projections :
  net_limit x x0 ->
  forall a:A, net_limit (fun i:DS_set I => (f a) (x i)) ((f a) x0).

From ZornsLemma Require Import FiniteIntersections.

Lemma net_limit_in_projections_impl_net_limit_in_weak_topology :
  (forall a:A, net_limit (fun i:DS_set I => (f a) (x i))
                         ((f a) x0)) ->
  net_limit x x0.

End WeakTopology_and_Nets.

End WeakTopology.

Arguments WeakTopology {X} {A} {Y}.
Arguments weak_topology_subbasis {X} {A} {Y}.

Section WeakTopology1.

Variable X:Type.
Variable Y:TopologicalSpace.
Variable f:X->point_set Y.

Definition WeakTopology1 := WeakTopology (True_rect f).

Lemma weak_topology1_topology:
  forall U:Ensemble X, @open WeakTopology1 U ->
  exists V:Ensemble (point_set Y), open V /\ U = inverse_image f V.

Lemma weak_topology1_makes_continuous_func:
  continuous f (X:=WeakTopology1).

End WeakTopology1.

Arguments WeakTopology1 {X} {Y}. *)
From ZornsLemma Require Import DependentTypeChoice.

Section product_topology.

Variable A:Type.
Variable X:forall a:A, TopologicalSpace.

Definition product_space_point_set : Type :=
  forall a:A, point_set (X a).
Definition product_space_proj (a:A) : product_space_point_set ->
                                      point_set (X a) :=
  fun (x:product_space_point_set) => x a.

Definition ProductTopology : TopologicalSpace :=
  WeakTopology product_space_proj.

Lemma product_space_proj_continuous: forall a:A,
  continuous (product_space_proj a) (X:=ProductTopology).
Proof.
apply weak_topology_makes_continuous_funcs.
Qed.

Lemma product_net_limit: forall (I:DirectedSet)
  (x:Net I ProductTopology) (x0:point_set ProductTopology),
  inhabited (DS_set I) ->
  (forall a:A, net_limit (fun i:DS_set I => x i a) (x0 a)) ->
  net_limit x x0.
Proof.
intros.
apply net_limit_in_projections_impl_net_limit_in_weak_topology;
  trivial.
Qed.

Require Export FilterLimits.
(* FilterLimits:
Require Export TopologicalSpaces.
Require Export Filters.
Require Export Neighborhoods.

Definition neighborhood_filter {X:TopologicalSpace} (x0:point_set X) :
  Filter (point_set X).

Definition filter_limit {X:TopologicalSpace} (F:Filter (point_set X))
  (x0:point_set X) : Prop :=
  Included (filter_family (neighborhood_filter x0))
           (filter_family F).

Definition filter_cluster_point {X:TopologicalSpace}
  (F:Filter (point_set X)) (x0:point_set X) : Prop :=
  forall S:Ensemble (point_set X), In (filter_family F) S ->
  In (closure S) x0.

Lemma filter_limit_is_cluster_point:
  forall {X:TopologicalSpace} (F:Filter (point_set X)) (x0:point_set X),
  filter_limit F x0 -> filter_cluster_point F x0.

Lemma ultrafilter_cluster_point_is_limit: forall {X:TopologicalSpace}
  (F:Filter (point_set X)) (x0:point_set X),
  filter_cluster_point F x0 -> ultrafilter F ->
  filter_limit F x0.

Lemma closure_impl_filter_limit: forall {X:TopologicalSpace}
  (S:Ensemble (point_set X)) (x0:point_set X),
  In (closure S) x0 ->
  exists F:Filter (point_set X),
    In (filter_family F) S /\ filter_limit F x0.

Require Export Continuity.

Lemma continuous_function_preserves_filter_limits:
  forall (X Y:TopologicalSpace) (f:point_set X -> point_set Y)
    (x:point_set X) (F:Filter (point_set X)),
  filter_limit F x -> continuous_at f x ->
  filter_limit (filter_direct_image f F) (f x).

Lemma func_preserving_filter_limits_is_continuous:
  forall (X Y:TopologicalSpace) (f:point_set X -> point_set Y)
    (x:point_set X),
  (forall F:Filter (point_set X), filter_limit F x ->
                     filter_limit (filter_direct_image f F) (f x)) ->
  continuous_at f x. *)

Lemma product_filter_limit:
  forall (F:Filter (point_set ProductTopology))
    (x0:point_set ProductTopology),
  (forall a:A, filter_limit (filter_direct_image
                     (product_space_proj a) F) (x0 a)) ->
  filter_limit F x0.
Proof.
intros.
assert (subbasis
  (weak_topology_subbasis product_space_proj)
  (X:=ProductTopology)).
apply Build_TopologicalSpace_from_subbasis_subbasis.
red; intros.
red; intros U ?.
destruct H1.
destruct H1 as [U' []].
cut (In (filter_family F) U').
intro.
apply filter_upward_closed with U'; trivial.
destruct H1.
destruct (subbasis_cover _ _ H0 _ _ H3 H1) as
  [B [? [V [? []]]]].
cut (In (filter_family F) (IndexedIntersection V)).
intro.
apply filter_upward_closed with (1:=H8); trivial.
apply filter_finite_indexed_intersection; trivial.

intro b.
pose proof (H5 b).
inversion H8.
apply H.
constructor.
apply open_neighborhood_is_neighborhood.
constructor; trivial.
destruct H6.
pose proof (H6 b).
rewrite <- H9 in H11.
destruct H11.
exact H11.
Qed.

Require Export Compactness.
(* Compactness:
Require Export TopologicalSpaces.
Require Export Nets.
Require Export FilterLimits.
Require Export Continuity.

Set Asymmetric Patterns.

Definition compact (X:TopologicalSpace) :=
  forall C:Family (point_set X),
    (forall U:Ensemble (point_set X), In C U -> open U) ->
    FamilyUnion C = Full_set ->
    exists C':Family (point_set X),
      Finite _ C' /\ Included C' C /\
      FamilyUnion C' = Full_set.

Lemma compactness_on_indexed_covers:
  forall (X:TopologicalSpace) (A:Type) (C:IndexedFamily A (point_set X)),
    compact X ->
    (forall a:A, open (C a)) -> IndexedUnion C = Full_set ->
  exists A':Ensemble A, Finite _ A' /\
    IndexedUnion (fun a':{a':A | In A' a'} => C (proj1_sig a')) = Full_set.

Lemma compact_finite_nonempty_closed_intersection:
  forall X:TopologicalSpace, compact X ->
  forall F:Family (point_set X),
    (forall G:Ensemble (point_set X), In F G -> closed G) ->
    (forall F':Family (point_set X), Finite _ F' -> Included F' F ->
     Inhabited (FamilyIntersection F')) ->
    Inhabited (FamilyIntersection F).

Lemma finite_nonempty_closed_intersection_impl_compact:
  forall X:TopologicalSpace,
  (forall F:Family (point_set X),
    (forall G:Ensemble (point_set X), In F G -> closed G) ->
    (forall F':Family (point_set X), Finite _ F' -> Included F' F ->
     Inhabited (FamilyIntersection F')) ->
    Inhabited (FamilyIntersection F)) ->
  compact X.

Lemma compact_impl_filter_cluster_point:
  forall X:TopologicalSpace, compact X ->
    forall F:Filter (point_set X), exists x0:point_set X,
    filter_cluster_point F x0.

Lemma filter_cluster_point_impl_compact:
  forall X:TopologicalSpace,
    (forall F:Filter (point_set X), exists x0:point_set X,
      filter_cluster_point F x0) -> compact X.

Lemma ultrafilter_limit_impl_compact:
  forall X:TopologicalSpace,
    (forall U:Filter (point_set X), ultrafilter U ->
      exists x0:point_set X, filter_limit U x0) -> compact X.

Lemma compact_impl_net_cluster_point:
  forall X:TopologicalSpace, compact X ->
    forall (I:DirectedSet) (x:Net I X), inhabited (DS_set I) ->
    exists x0:point_set X, net_cluster_point x x0.

Lemma net_cluster_point_impl_compact: forall X:TopologicalSpace,
  (forall (I:DirectedSet) (x:Net I X), inhabited (DS_set I) ->
    exists x0:point_set X, net_cluster_point x x0) ->
  compact X.

Require Export SeparatednessAxioms.
Require Export SubspaceTopology.

Lemma compact_closed: forall (X:TopologicalSpace)
  (S:Ensemble (point_set X)), Hausdorff X ->
  compact (SubspaceTopology S) -> closed S.

Lemma closed_compact: forall (X:TopologicalSpace) (S:Ensemble (point_set X)),
  compact X -> closed S -> compact (SubspaceTopology S).

Lemma compact_image: forall {X Y:TopologicalSpace}
  (f:point_set X->point_set Y),
  compact X -> continuous f -> surjective f -> compact Y.

Lemma compact_Hausdorff_impl_normal_sep: forall X:TopologicalSpace,
  compact X -> Hausdorff X -> normal_sep X. *)

Theorem TychonoffProductTheorem:
  (forall a:A, compact (X a)) -> compact ProductTopology.
Proof.
intro.
apply ultrafilter_limit_impl_compact; intros.
destruct (choice_on_dependent_type (fun (a:A) (x:point_set (X a)) =>
  filter_limit (filter_direct_image (product_space_proj a) U) x))
  as [choice_fun].
intro.
destruct (compact_impl_filter_cluster_point _ (H a)
  (filter_direct_image (product_space_proj a) U)) as [xa].
exists xa.
apply ultrafilter_cluster_point_is_limit; trivial.
red; intros.
destruct (H0 (inverse_image (product_space_proj a) S));
  [left | right]; constructor; try rewrite inverse_image_complement; trivial.
exists choice_fun.
apply product_filter_limit; trivial.
Qed.

End product_topology.

Arguments ProductTopology {A}.
Arguments product_space_proj {A} {X}.

Lemma product_map_continuous: forall {A:Type}
  (X:TopologicalSpace) (Y:A->TopologicalSpace)
  (f:forall a:A, point_set X -> point_set (Y a)) (x:point_set X),
  (forall a:A, continuous_at (f a) x) ->
  continuous_at (fun x:point_set X => (fun a:A => f a x)) x
    (Y:=ProductTopology Y).
Proof.
intros.
apply func_preserving_net_limits_is_continuous.
intros.
apply product_net_limit.
destruct (H0 Full_set) as [i].
apply open_full.
constructor.
exists; exact i.
intros.
apply continuous_func_preserves_net_limits; trivial.
Qed.

Section product_topology2.

Variable X Y:TopologicalSpace.

Inductive twoT := | twoT_1 | twoT_2.
Let prod2_fun (i:twoT) := match i with
  | twoT_1 => X | twoT_2 => Y end.
Let prod2 := ProductTopology prod2_fun.

Let prod2_conv1 (p:point_set prod2) : point_set X * point_set Y :=
  (p twoT_1, p twoT_2).
Let prod2_conv2 (p : point_set X * point_set Y) : point_set prod2 :=
  let (x,y):=p in fun i:twoT => match i with
    | twoT_1 => x | twoT_2 => y
  end.

Lemma prod2_comp1: forall p:point_set prod2,
  prod2_conv2 (prod2_conv1 p) = p.
Proof.
intros.
Require Import FunctionalExtensionality.
extensionality i.
destruct i; trivial.
Qed.

Lemma prod2_comp2: forall p:point_set X * point_set Y,
  prod2_conv1 (prod2_conv2 p) = p.
Proof.
intros.
destruct p as [x y].
trivial.
Qed.

Let prod2_proj := fun i:twoT =>
  match i return (point_set X * point_set Y ->
                  point_set (prod2_fun i)) with
  | twoT_1 => @fst (point_set X) (point_set Y)
  | twoT_2 => @snd (point_set X) (point_set Y)
  end.

Definition ProductTopology2 : TopologicalSpace :=
  WeakTopology prod2_proj.

Lemma prod2_conv1_cont: continuous prod2_conv1 (Y:=ProductTopology2).
Proof.
apply pointwise_continuity.
intros p.
apply func_preserving_net_limits_is_continuous.
intros.
apply net_limit_in_projections_impl_net_limit_in_weak_topology.
destruct (H Full_set).
apply open_full.
constructor.
exact (inhabits x0).
destruct a.
simpl.
apply net_limit_in_weak_topology_impl_net_limit_in_projections
  with (a:=twoT_1) in H.
exact H.
simpl.
apply net_limit_in_weak_topology_impl_net_limit_in_projections
  with (a:=twoT_2) in H.
exact H.
Qed.

Lemma prod2_conv2_cont: continuous prod2_conv2 (X:=ProductTopology2).
Proof.
apply pointwise_continuity.
destruct x as [x y].
apply func_preserving_net_limits_is_continuous.
intros.
apply net_limit_in_projections_impl_net_limit_in_weak_topology.
destruct (H Full_set).
apply open_full.
constructor.
exact (inhabits x1).
destruct a.
unfold product_space_proj.
simpl.
replace (fun i:DS_set I => prod2_conv2 (x0 i) twoT_1) with
  (fun i:DS_set I => fst (x0 i)).
apply net_limit_in_weak_topology_impl_net_limit_in_projections
  with (a:=twoT_1) in H.
simpl in H.
trivial.
extensionality i.
destruct (x0 i) as [xi yi].
trivial.
unfold product_space_proj.
simpl.
replace (fun i:DS_set I => prod2_conv2 (x0 i) twoT_2) with
  (fun i:DS_set I => snd (x0 i)).
apply net_limit_in_weak_topology_impl_net_limit_in_projections
  with (a:=twoT_2) in H.
simpl in H.
trivial.
extensionality i.
destruct (x0 i) as [xi yi].
trivial.
Qed.

Lemma product2_fst_continuous:
  continuous (@fst (point_set X) (point_set Y))
    (X:=ProductTopology2).
Proof.
exact (weak_topology_makes_continuous_funcs
  _ _ _ prod2_proj twoT_1).
Qed.

Lemma product2_snd_continuous:
  continuous (@snd (point_set X) (point_set Y))
    (X:=ProductTopology2).
Proof.
exact (weak_topology_makes_continuous_funcs
  _ _ _ prod2_proj twoT_2).
Qed.

Lemma product2_map_continuous: forall (W:TopologicalSpace)
  (f:point_set W -> point_set X) (g:point_set W -> point_set Y)
  (w:point_set W),
  continuous_at f w -> continuous_at g w ->
  continuous_at (fun w:point_set W => (f w, g w)) w
  (Y:=ProductTopology2).
Proof.
intros.
replace (fun w:point_set W => (f w, g w)) with
  (fun w:point_set W => prod2_conv1
              (fun i:twoT => match i with
                | twoT_1 => f w
                | twoT_2 => g w end)).
apply (@continuous_composition_at W prod2 ProductTopology2
  prod2_conv1
  (fun w:point_set W =>
     fun i:twoT => match i with
         | twoT_1 => f w | twoT_2 => g w end)).
apply continuous_func_continuous_everywhere.
apply prod2_conv1_cont.
apply product_map_continuous.
destruct a; trivial.
extensionality w0.
trivial.
Qed.

Inductive ProductTopology2_basis :
  Family (point_set ProductTopology2) :=
| intro_product2_basis_elt:
  forall (U:Ensemble (point_set X))
         (V:Ensemble (point_set Y)),
  open U -> open V ->
  In ProductTopology2_basis
  [ p:point_set ProductTopology2 |
    let (x,y):=p in (In U x /\ In V y) ].

Lemma ProductTopology2_basis_is_basis:
  open_basis ProductTopology2_basis.
Proof.
From ZornsLemma Require Import FiniteIntersections.
assert (open_basis (finite_intersections (weak_topology_subbasis prod2_proj))
  (X:=ProductTopology2)) by apply
  Build_TopologicalSpace_from_open_basis_basis.
apply eq_ind with (1:=H).
apply Extensionality_Ensembles; split; red; intros U ?.
induction H0.
replace (@Full_set (point_set X * point_set Y)) with
  [ p:point_set ProductTopology2 |
    let (x,y):=p in (In Full_set x /\ In Full_set y) ].
constructor; try apply open_full.
apply Extensionality_Ensembles; split; red; intros.
constructor.
destruct x.
constructor; split; constructor.
destruct H0.
destruct a.
replace (inverse_image (prod2_proj twoT_1) V) with
  [ p:point_set ProductTopology2 |
    let (x,y):=p in (In V x /\ In Full_set y) ].
constructor; trivial.
apply open_full.
apply Extensionality_Ensembles; split; red; intros.
destruct H1.
destruct x.
destruct H1.
constructor.
trivial.
destruct H1.
destruct x.
constructor.
split; trivial.
constructor.
replace (inverse_image (prod2_proj twoT_2) V) with
  [ p:point_set ProductTopology2 |
    let (x,y):=p in (In Full_set x /\ In V y) ].
constructor; trivial.
apply open_full.
apply Extensionality_Ensembles; split; red; intros.
destruct H1.
destruct x.
destruct H1.
constructor.
trivial.
destruct H1.
destruct x.
constructor.
split.
constructor.
trivial.

destruct IHfinite_intersections as [U1 V1].
destruct IHfinite_intersections0 as [U2 V2].
replace (@Intersection (point_set X * point_set Y)
  [p:point_set ProductTopology2 | let (x,y):=p in In U1 x /\ In V1 y]
  [p:point_set ProductTopology2 | let (x,y):=p in In U2 x /\ In V2 y])
with
  [p:point_set ProductTopology2 | let (x,y):=p in
   (In (Intersection U1 U2) x /\ In (Intersection V1 V2) y)].
constructor; apply open_intersection2; trivial.
apply Extensionality_Ensembles; split; red; intros.
destruct H6.
destruct x.
destruct H6.
destruct H6.
destruct H7.
constructor.
constructor.
split; trivial.
constructor.
split; trivial.
destruct H6.
destruct H6.
destruct H7.
destruct x.
destruct H6.
destruct H7.
constructor.
split; constructor; trivial.

destruct H0.
replace [p:point_set ProductTopology2 | let (x,y):=p in
         In U x /\ In V y] with
  (Intersection (inverse_image (prod2_proj twoT_1) U)
                (inverse_image (prod2_proj twoT_2) V)).
constructor 3.
constructor.
constructor; trivial.
constructor.
constructor; trivial.
apply Extensionality_Ensembles; split; red; intros.
destruct H2.
destruct H2.
destruct H3.
constructor.
destruct x.
split; trivial.
destruct H2.
destruct x.
destruct H2.
constructor; constructor; trivial.
Qed.

End product_topology2.

Section two_arg_convenience_results.

Variable X Y Z:TopologicalSpace.
Variable f:point_set X -> point_set Y -> point_set Z.

Definition continuous_2arg :=
  continuous (fun p:point_set X * point_set Y =>
              let (x,y):=p in f x y)
  (X:=ProductTopology2 X Y).
Definition continuous_at_2arg (x:point_set X) (y:point_set Y) :=
  continuous_at (fun p:point_set X * point_set Y =>
                 let (x,y):=p in f x y)  (x, y)
  (X:=ProductTopology2 X Y).

Lemma continuous_2arg_func_continuous_everywhere:
  continuous_2arg -> forall (x:point_set X) (y:point_set Y),
                       continuous_at_2arg x y.
Proof.
intros.
apply continuous_func_continuous_everywhere; trivial.
Qed.

Lemma pointwise_continuity_2arg:
  (forall (x:point_set X) (y:point_set Y),
   continuous_at_2arg x y) -> continuous_2arg.
Proof.
intros.
apply pointwise_continuity.
intros.
destruct x as [x y].
apply H.
Qed.

End two_arg_convenience_results.

Arguments continuous_2arg {X} {Y} {Z}.
Arguments continuous_at_2arg {X} {Y} {Z}.

Lemma continuous_composition_at_2arg:
  forall (W X Y Z:TopologicalSpace)
    (f:point_set X -> point_set Y -> point_set Z)
    (g:point_set W -> point_set X) (h:point_set W -> point_set Y)
    (w:point_set W),
  continuous_at_2arg f (g w) (h w) ->
  continuous_at g w -> continuous_at h w ->
  continuous_at (fun w:point_set W => f (g w) (h w)) w.
Proof.
intros.
apply (continuous_composition_at
  (fun p:point_set (ProductTopology2 X Y) =>
      let (x,y):=p in f x y)
  (fun w:point_set W => (g w, h w))).
exact H.
apply product2_map_continuous; trivial.
Qed.
