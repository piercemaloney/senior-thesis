Require Export TopologicalSpaces.
(* TopologicalSpaces:
Require Export Ensembles.
From ZornsLemma Require Import EnsemblesImplicit.
From ZornsLemma Require Export Families.
From ZornsLemma Require Export IndexedFamilies.
From ZornsLemma Require Export FiniteTypes.
From ZornsLemma Require Import EnsemblesSpec.

Record TopologicalSpace : Type := {
  point_set : Type;
  open : Ensemble point_set -> Prop;
  open_family_union : forall F : Family point_set,
    (forall S : Ensemble point_set, In F S -> open S) ->
    open (FamilyUnion F);
  open_intersection2: forall U V:Ensemble point_set,
    open U -> open V -> open (Intersection U V);
  open_full : open Full_set
}.

Arguments open {t}.
Arguments open_family_union {t}.
Arguments open_intersection2 {t}.

Lemma open_empty: forall X:TopologicalSpace,
  open (@Empty_set (point_set X)).

Lemma open_union2: forall {X:TopologicalSpace}
  (U V:Ensemble (point_set X)), open U -> open V -> open (Union U V).

Lemma open_indexed_union: forall {X:TopologicalSpace} {A:Type}
  (F:IndexedFamily A (point_set X)),
  (forall a:A, open (F a)) -> open (IndexedUnion F).

Lemma open_finite_indexed_intersection:
  forall {X:TopologicalSpace} {A:Type}
    (F:IndexedFamily A (point_set X)),
    FiniteT A -> (forall a:A, open (F a)) ->
    open (IndexedIntersection F).

Definition closed {X:TopologicalSpace} (F:Ensemble (point_set X)) :=
  open (Ensembles.Complement F).

Lemma closed_complement_open: forall {X:TopologicalSpace}
  (U:Ensemble (point_set X)), closed (Ensembles.Complement U) ->

Lemma closed_union2: forall {X:TopologicalSpace}
  (F G:Ensemble (point_set X)),
  closed F -> closed G -> closed (Union F G).

Lemma closed_intersection2: forall {X:TopologicalSpace}
  (F G:Ensemble (point_set X)),
  closed F -> closed G -> closed (Intersection F G).

Lemma closed_family_intersection: forall {X:TopologicalSpace}
  (F:Family (point_set X)),
  (forall S:Ensemble (point_set X), In F S -> closed S) ->
  closed (FamilyIntersection F).

Lemma closed_indexed_intersection: forall {X:TopologicalSpace}
  {A:Type} (F:IndexedFamily A (point_set X)),
  (forall a:A, closed (F a)) -> closed (IndexedIntersection F).

Lemma closed_finite_indexed_union: forall {X:TopologicalSpace}
  {A:Type} (F:IndexedFamily A (point_set X)),
  FiniteT A -> (forall a:A, closed (F a)) ->
  closed (IndexedUnion F).

Hint Unfold closed : topology.
Hint Resolve (@open_family_union) (@open_intersection2) open_full
  open_empty (@open_union2) (@open_indexed_union)
  (@open_finite_indexed_intersection) (@closed_complement_open)
  (@closed_union2) (@closed_intersection2) (@closed_family_intersection)
  (@closed_indexed_intersection) (@closed_finite_indexed_union)
  : topology.

Section Build_from_closed_sets.

Variable X:Type.
Variable closedP : Ensemble X -> Prop.
Hypothesis closedP_empty: closedP Empty_set.
Hypothesis closedP_union2: forall F G:Ensemble X,
  closedP F -> closedP G -> closedP (Union F G).
Hypothesis closedP_family_intersection: forall F:Family X,
  (forall G:Ensemble X, In F G -> closedP G) ->
  closedP (FamilyIntersection F).

Definition Build_TopologicalSpace_from_closed_sets : TopologicalSpace.

Lemma Build_TopologicalSpace_from_closed_sets_closed:
  forall (F:Ensemble (point_set Build_TopologicalSpace_from_closed_sets)),
  closed F <-> closedP F.

End Build_from_closed_sets.

Arguments Build_TopologicalSpace_from_closed_sets {X}. *)
From ZornsLemma Require Export CountableTypes.
Require Export NeighborhoodBases.
(* NeighborhoodBases:
Require Export TopologicalSpaces.
Require Export Neighborhoods.
Require Export OpenBases.
From ZornsLemma Require Export IndexedFamilies.
From ZornsLemma Require Export EnsemblesSpec.

Record neighborhood_basis {X:TopologicalSpace}
  (NB:Family (point_set X)) (x:point_set X) : Prop := {
  neighborhood_basis_elements: forall N:Ensemble (point_set X),
    In NB N -> neighborhood N x;
  neighborhood_basis_cond: forall N:Ensemble (point_set X),
    neighborhood N x -> exists N':Ensemble (point_set X),
    In NB N' /\ Included N' N
}.

Record open_neighborhood_basis {X:TopologicalSpace}
  (NB:Family (point_set X)) (x:point_set X) : Prop := {
  open_neighborhood_basis_elements: forall U:Ensemble (point_set X),
    In NB U -> open_neighborhood U x;
  open_neighborhood_basis_cond: forall U:Ensemble (point_set X),
    open_neighborhood U x -> exists V:Ensemble (point_set X),
    In NB V /\ Included V U
}.

Lemma open_neighborhood_basis_is_neighborhood_basis:
  forall {X:TopologicalSpace} (NB:Family (point_set X)) (x:point_set X),
  open_neighborhood_basis NB x -> neighborhood_basis NB x.

Lemma open_basis_to_open_neighborhood_basis:
  forall {X:TopologicalSpace} (B:Family (point_set X)) (x:point_set X),
    open_basis B -> open_neighborhood_basis
                    [ U:Ensemble (point_set X) | In B U /\ In U x ]
                    x.

Lemma open_neighborhood_bases_to_open_basis:
  forall {X:TopologicalSpace} (NB : point_set X -> Family (point_set X)),
    (forall x:point_set X, open_neighborhood_basis (NB x) x) ->
    open_basis (IndexedUnion NB).

Section build_from_open_neighborhood_bases.

Variable X:Type.
Variable NB : X -> Family X.

Hypothesis neighborhood_basis_cond :
  forall (U V:Ensemble X) (x:X), In (NB x) U -> In (NB x) V ->
    exists W:Ensemble X, In (NB x) W /\ Included W (Intersection U V).
Hypothesis neighborhood_basis_cond2 :
  forall (U:Ensemble X) (x:X), In (NB x) U -> In U x.
Hypothesis neighborhood_basis_inhabited_cond :
  forall x:X, Inhabited (NB x).
Hypothesis neighborhood_basis_system_cond :
  forall (x y:X) (U:Ensemble X), In (NB x) U -> In U y ->
  exists V:Ensemble X, In (NB y) V /\ Included V U.

Definition Build_TopologicalSpace_from_open_neighborhood_bases :
  TopologicalSpace.

Lemma Build_TopologicalSpace_from_open_neighborhood_bases_basis:
  forall x:X,
    open_neighborhood_basis (NB x) x
      (X:=Build_TopologicalSpace_from_open_neighborhood_bases).

End build_from_open_neighborhood_bases. *)
From ZornsLemma Require Import EnsemblesSpec.

Global Set Asymmetric Patterns.

Definition first_countable (X:TopologicalSpace) : Prop :=
  forall x:point_set X, exists NBx:Family (point_set X),
    neighborhood_basis NBx x /\ Countable NBx.

Lemma first_countable_open_neighborhood_bases:
  forall X:TopologicalSpace, first_countable X ->
    forall x:point_set X, exists NBx:Family (point_set X),
      open_neighborhood_basis NBx x /\ Countable NBx.
Proof.
intros.
destruct (H x) as [NBx [? ?]].
exists (@Im (Ensemble (point_set X)) (Ensemble (point_set X)) NBx (@interior X)).
split.
constructor.
intros.
destruct H2 as [U].
split.
rewrite H3; apply interior_open.
rewrite H3; apply neighborhood_interior.
apply H0; trivial.
intros.
destruct H0.
destruct (neighborhood_basis_cond U) as [N].
apply open_neighborhood_is_neighborhood; trivial.
destruct H0.
exists (interior N).
split.
exists N; trivial.
pose proof (interior_deflationary N).
auto with sets.

apply countable_img; trivial.
Qed.

Require Export Nets.
(* Nets:
Require Export TopologicalSpaces.
Require Export DirectedSets.
Require Export InteriorsClosures.
Require Export Continuity.

Set Asymmetric Patterns.

Section Net.

Variable I:DirectedSet.
Variable X:TopologicalSpace.

Definition Net := DS_set I -> point_set X.

Definition net_limit (x:Net) (x0:point_set X) : Prop :=
  forall U:Ensemble (point_set X), open U -> In U x0 ->
  for large i:DS_set I, In U (x i).

Definition net_cluster_point (x:Net) (x0:point_set X) : Prop :=
  forall U:Ensemble (point_set X), open U -> In U x0 ->
  exists arbitrarily large i:DS_set I, In U (x i).

Lemma net_limit_is_cluster_point: forall (x:Net) (x0:point_set X),
  net_limit x x0 -> net_cluster_point x x0.

Lemma net_limit_in_closure: forall (S:Ensemble (point_set X))
  (x:Net) (x0:point_set X),
  (exists arbitrarily large i:DS_set I, In S (x i)) ->
  net_limit x x0 -> In (closure S) x0.

Lemma net_cluster_point_in_closure: forall (S:Ensemble (point_set X))
  (x:Net) (x0:point_set X),
  (for large i:DS_set I, In S (x i)) ->
  net_cluster_point x x0 -> In (closure S) x0.

End Net.

Arguments net_limit {I} {X}.
Arguments net_cluster_point {I} {X}.
Arguments net_limit_is_cluster_point {I} {X}.
Arguments net_limit_in_closure {I} {X}.
Arguments net_cluster_point_in_closure {I} {X}.

Section neighborhood_net.

Variable X:TopologicalSpace.
Variable x:point_set X.

Inductive neighborhood_net_DS_set : Type :=
  | intro_neighborhood_net_DS :
    forall (U:Ensemble (point_set X)) (y:point_set X),
    open U -> In U x -> In U y -> neighborhood_net_DS_set.

Definition neighborhood_net_DS_ord
  (Uy Vz:neighborhood_net_DS_set) : Prop :=
  match Uy, Vz with
  | intro_neighborhood_net_DS U _ _ _ _,
    intro_neighborhood_net_DS V _ _ _ _ =>
    Included V U
  end.

Definition neighborhood_net_DS : DirectedSet.

Definition neighborhood_net : Net neighborhood_net_DS X :=
  fun (x:neighborhood_net_DS_set) => match x with
  | intro_neighborhood_net_DS _ y _ _ _ => y
  end.

Lemma neighborhood_net_limit: net_limit neighborhood_net x.

End neighborhood_net.

Lemma net_limits_determine_topology:
  forall {X:TopologicalSpace} (S:Ensemble (point_set X))
  (x0:point_set X), In (closure S) x0 ->
  exists I:DirectedSet, exists x:Net I X,
  (forall i:DS_set I, In S (x i)) /\ net_limit x x0.

Section Nets_and_continuity.

Variable X Y:TopologicalSpace.
Variable f:point_set X -> point_set Y.

Lemma continuous_func_preserves_net_limits:
  forall {I:DirectedSet} (x:Net I X) (x0:point_set X),
    net_limit x x0 -> continuous_at f x0 ->
    net_limit (fun i:DS_set I => f (x i)) (f x0).

Lemma func_preserving_net_limits_is_continuous:
  forall x0:point_set X,
  (forall (I:DirectedSet) (x:Net I X),
    net_limit x x0 -> net_limit (fun i:DS_set I => f (x i)) (f x0))
  -> continuous_at f x0.

End Nets_and_continuity.

Section Subnet.

Variable X:TopologicalSpace.
Variable I:DirectedSet.
Variable x:Net I X.

Inductive Subnet {J:DirectedSet} : Net J X -> Prop :=
  | intro_subnet: forall h:DS_set J -> DS_set I,
    (forall j1 j2:DS_set J, DS_ord j1 j2 ->
       DS_ord (h j1) (h j2)) ->
    (exists arbitrarily large i:DS_set I,
       exists j:DS_set J, h j = i) ->
    Subnet (fun j:DS_set J => x (h j)).

Lemma subnet_limit: forall (x0:point_set X) {J:DirectedSet}
  (y:Net J X), net_limit x x0 -> Subnet y ->
  net_limit y x0.

Lemma subnet_cluster_point: forall (x0:point_set X) {J:DirectedSet}
  (y:Net J X), net_cluster_point y x0 ->
  Subnet y -> net_cluster_point x x0.

Section cluster_point_subnet.

Variable x0:point_set X.
Hypothesis x0_cluster_point: net_cluster_point x x0.
Hypothesis I_nonempty: inhabited (DS_set I).

Record cluster_point_subnet_DS_set : Type := {
  cps_i:DS_set I;
  cps_U:Ensemble (point_set X);
  cps_U_open_neigh: open_neighborhood cps_U x0;
  cps_xi_in_U: In cps_U (x cps_i)
}.

Definition cluster_point_subnet_DS_ord
  (iU1 iU2 : cluster_point_subnet_DS_set) : Prop :=
  DS_ord (cps_i iU1) (cps_i iU2) /\
  Included (cps_U iU2) (cps_U iU1).

Definition cluster_point_subnet_DS : DirectedSet.

Definition cluster_point_subnet : Net
  cluster_point_subnet_DS X :=
  fun (iU:DS_set cluster_point_subnet_DS) =>
  x (cps_i iU).

Lemma cluster_point_subnet_is_subnet:
  Subnet cluster_point_subnet.

Lemma cluster_point_subnet_converges:
  net_limit cluster_point_subnet x0.

Lemma net_cluster_point_impl_subnet_converges:
  exists J:DirectedSet, exists y:Net J X,
  Subnet y /\ net_limit y x0.

End cluster_point_subnet.

End Subnet. *)

Lemma first_countable_sequence_closure:
  forall (X:TopologicalSpace) (S:Ensemble (point_set X)) (x:point_set X),
  first_countable X -> In (closure S) x ->
  exists y:Net nat_DS X, (forall n:nat, In S (y n)) /\
                         net_limit y x.
Proof.
intros.
destruct (first_countable_open_neighborhood_bases _ H x) as [NB []].
destruct H2 as [g].
pose (U (n:nat) := IndexedIntersection
  (fun x: {x:{x:Ensemble (point_set X) | In NB x} | (g x < n)%nat} =>
     proj1_sig (proj1_sig x))).
assert (forall n:nat, open (U n)).
intros.
apply open_finite_indexed_intersection.
apply inj_finite with _ (fun x:{x:{x:Ensemble (point_set X) | In NB x}
                           | (g x < n)%nat} =>
  exist (fun m:nat => (m<n)%nat) (g (proj1_sig x)) (proj2_sig x)).
From ZornsLemma Require Import InfiniteTypes.
apply finite_nat_initial_segment.
red.
intros [[x0 P] p] [[y0 Q] q] ?.
simpl in H3.
From ZornsLemma Require Import Proj1SigInjective.
apply subset_eq_compatT.
apply subset_eq_compatT.
injection H3; intros.
apply H2 in H4.
injection H4; trivial.
intros; apply classic.
intros.
destruct a as [[x0]].
simpl.
Opaque In. apply H1; trivial. Transparent In.

Require Import ClassicalChoice.
destruct (choice (fun (n:nat) (x:point_set X) => In (U n) x /\
                                                 In S x)) as [y].
intros n.
destruct (closure_impl_meets_every_open_neighborhood _ _ _ H0 (U n))
  as [y]; trivial.
constructor; trivial.
destruct a as [[x0]].
simpl.
apply H1; trivial.
exists y; destruct H4; split; trivial.
exists y.
split.
apply H4.

red; intros V ? ?.
destruct H1.
destruct (open_neighborhood_basis_cond V) as [W []].
split; trivial.
pose (a := (exist _ W H1 : {x:Ensemble (point_set X)|In NB x})).
exists (Datatypes.S (g a)).
intros.
simpl in j.
simpl in H8.
apply H7.
assert (Included (U j) W).
red; intros.
destruct H9.
exact (H9 (exist _ a H8)).
apply H9.
apply H4.
Qed.

Inductive separable (X:TopologicalSpace) : Prop :=
  | intro_dense_ctbl: forall S:Ensemble (point_set X),
    Countable S -> dense S -> separable X.

Definition Lindelof (X:TopologicalSpace) : Prop :=
  forall cover:Family (point_set X),
    (forall U:Ensemble (point_set X),
       In cover U -> open U) ->
    FamilyUnion cover = Full_set ->
  exists subcover:Family (point_set X), Included subcover cover /\
     Countable subcover /\ FamilyUnion subcover = Full_set.

Inductive second_countable (X:TopologicalSpace) : Prop :=
  | intro_ctbl_basis: forall B:Family (point_set X),
    open_basis B -> Countable B -> second_countable X.

Lemma second_countable_impl_first_countable:
  forall X:TopologicalSpace, second_countable X -> first_countable X.
Proof.
intros.
destruct H.
red; intros.
exists [ U:Ensemble (point_set X) | In B U /\ In U x ]; split.
apply open_neighborhood_basis_is_neighborhood_basis.
apply open_basis_to_open_neighborhood_basis; trivial.
apply countable_downward_closed with B; trivial.
red; intros.
destruct H1 as [[? ?]]; trivial.
Qed.

Lemma second_countable_impl_separable:
  forall X:TopologicalSpace, second_countable X -> separable X.
Proof.
intros.
destruct H.
Require Import ClassicalChoice.
destruct (choice (fun (U:{U:Ensemble (point_set X) | In B U /\ Inhabited U})
  (x:point_set X) => In (proj1_sig U) x)) as [choice_fun].
intros.
destruct x as [U [? ?]].
simpl.
destruct i0.
exists x; trivial.

exists (Im Full_set choice_fun).
apply countable_img.
red.
match goal with |- CountableT ?S =>
  pose (g := fun (x:S) =>
    match x return {U:Ensemble (point_set X) | In B U} with
    | exist (exist U (conj i _)) _ => exist _ U i
    end)
end.
apply inj_countable with g.
assumption.
red; intros.
unfold g in H2.
destruct x1 as [[U [? ?]]].
destruct x2 as [[V [? ?]]].
From ZornsLemma Require Import Proj1SigInjective.
apply subset_eq_compatT.
apply subset_eq_compatT.
injection H2; trivial.

apply meets_every_nonempty_open_impl_dense.
intros.
destruct H3.
destruct H.
destruct (open_basis_cover x U) as [V [? [? ?]]]; trivial.
assert (In B V /\ Inhabited V).
split; trivial.
exists x; trivial.
exists (choice_fun (exist _ V H6)).

constructor.

pose proof (H1 (exist _ V H6)).
simpl in H7.

exists (exist (fun U0:Ensemble (point_set X) => In B U0 /\ Inhabited U0) V H6).
constructor.
reflexivity.
apply H4.
pose proof (H1 (exist _ V H6)).
simpl in H7.
assumption.
Qed.

Lemma second_countable_impl_Lindelof:
  forall X:TopologicalSpace, second_countable X -> Lindelof X.
Proof.
intros.
destruct H.
red; intros.

pose (basis_elts_contained_in_cover_elt :=
  [ U:Ensemble (point_set X) | In B U /\ Inhabited U /\
    exists V:Ensemble (point_set X), In cover V /\ Included U V ]).
destruct (choice (fun (U:{U | In basis_elts_contained_in_cover_elt U})
  (V:Ensemble (point_set X)) => In cover V /\ Included (proj1_sig U) V))
  as [choice_fun].
intros.
destruct x.
simpl.
destruct i as [[? [? ?]]].
exact H5.
exists (Im Full_set choice_fun).
repeat split.
red; intros.
destruct H4.
destruct (H3 x).
rewrite H5; assumption.
apply countable_img.
apply countable_type_ensemble.
apply countable_downward_closed with B; trivial.
red; intros.
destruct H4 as [[]].
assumption.

apply Extensionality_Ensembles; red; split; red; intros.
constructor.
clear H4.
assert (In (FamilyUnion cover) x).
rewrite H2; constructor.
destruct H4.

destruct H.
destruct (open_basis_cover x S) as [V]; trivial.
apply H1; trivial.

destruct H as [? [? ?]].

assert (In basis_elts_contained_in_cover_elt V).
constructor.
repeat split; trivial.
exists x; trivial.
exists S; split; trivial.

exists (choice_fun (exist _ V H8)).
exists (exist _ V H8).
constructor.
reflexivity.

pose proof (H3 (exist _ V H8)).
destruct H9.
simpl in H10.
apply H10; trivial.
Qed.
