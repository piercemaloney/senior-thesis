Require Export RTopology.
(* RTopology:
Require Export TopologicalSpaces.
Require Export OrderTopology.
Require Export Reals.

Definition RTop := OrderTopology Rle.

Require Export MetricSpaces.

Definition R_metric (x y:R) : R := Rabs (y-x).

Lemma R_metric_is_metric: metric R_metric.

Lemma Rmetric_bound: forall x y z:R, R_metric x z < y - x ->
  z < y.

Lemma Rmetric_bound2: forall x y z:R, R_metric y z < y - x ->
  x < z.

Lemma RTop_metrization: metrizes RTop R_metric.

Corollary RTop_metrizable: metrizable RTop.

Lemma RTop_separable: separable RTop.

Require Export Compactness.

Lemma bounded_real_net_has_cluster_point: forall (I:DirectedSet)
  (x:Net I RTop) (a b:R), (forall i:DS_set I, a <= x i <= b) ->
  exists x0:point_set RTop, net_cluster_point x x0.

Lemma R_closed_interval_compact: forall a b:R, a <= b ->
  compact (SubspaceTopology ([x:point_set RTop | a <= x <= b])).

Lemma R_compact_subset_bounded: forall A:Ensemble (point_set RTop),
  compact (SubspaceTopology A) -> bound A.

Lemma Ropp_continuous: continuous Ropp (X:=RTop) (Y:=RTop).

Require Export Connectedness.

Lemma R_connected: connected RTop.

Require Export Completeness.

Lemma R_cauchy_sequence_bounded: forall x:nat->R,
  cauchy R_metric x -> bound (Im Full_set x).

Lemma R_cauchy_sequence_lower_bound: forall x:nat->R,
  cauchy R_metric x -> lower_bound (Im Full_set x).

Lemma R_metric_complete: complete R_metric R_metric_is_metric. *)
Require Export ProductTopology.
(* ProductTopology:
Require Export TopologicalSpaces.
Require Export WeakTopology.
From ZornsLemma Require Import DependentTypeChoice.

Section product_topology.

Variable A:Type.
Variable X:forall a:A, TopologicalSpace.

Definition product_space_point_set : Type :=
  forall a:A, point_set (X a).
Definition product_space_proj (a:A) : product_space_point_set ->
                                      point_set (X a) :=
  fun (x:product_space_point_set) => x a.

Definition ProductTopology : TopologicalSpace :=
  WeakTopology product_space_proj.

Lemma product_space_proj_continuous: forall a:A,
  continuous (product_space_proj a) (X:=ProductTopology).

Lemma product_net_limit: forall (I:DirectedSet)
  (x:Net I ProductTopology) (x0:point_set ProductTopology),
  inhabited (DS_set I) ->
  (forall a:A, net_limit (fun i:DS_set I => x i a) (x0 a)) ->
  net_limit x x0.

Require Export FilterLimits.

Lemma product_filter_limit:
  forall (F:Filter (point_set ProductTopology))
    (x0:point_set ProductTopology),
  (forall a:A, filter_limit (filter_direct_image
                     (product_space_proj a) F) (x0 a)) ->
  filter_limit F x0.

Require Export Compactness.

Theorem TychonoffProductTheorem:
  (forall a:A, compact (X a)) -> compact ProductTopology.

End product_topology.

Arguments ProductTopology {A}.
Arguments product_space_proj {A} {X}.

Lemma product_map_continuous: forall {A:Type}
  (X:TopologicalSpace) (Y:A->TopologicalSpace)
  (f:forall a:A, point_set X -> point_set (Y a)) (x:point_set X),
  (forall a:A, continuous_at (f a) x) ->
  continuous_at (fun x:point_set X => (fun a:A => f a x)) x
    (Y:=ProductTopology Y).

Section product_topology2.

Variable X Y:TopologicalSpace.

Inductive twoT := | twoT_1 | twoT_2.
Let prod2_fun (i:twoT) := match i with
  | twoT_1 => X | twoT_2 => Y end.
Let prod2 := ProductTopology prod2_fun.

Let prod2_conv1 (p:point_set prod2) : point_set X * point_set Y :=
  (p twoT_1, p twoT_2).
Let prod2_conv2 (p : point_set X * point_set Y) : point_set prod2 :=
  let (x,y):=p in fun i:twoT => match i with
    | twoT_1 => x | twoT_2 => y
  end.

Lemma prod2_comp1: forall p:point_set prod2,
  prod2_conv2 (prod2_conv1 p) = p.

Lemma prod2_comp2: forall p:point_set X * point_set Y,
  prod2_conv1 (prod2_conv2 p) = p.

Let prod2_proj := fun i:twoT =>
  match i return (point_set X * point_set Y ->
                  point_set (prod2_fun i)) with
  | twoT_1 => @fst (point_set X) (point_set Y)
  | twoT_2 => @snd (point_set X) (point_set Y)
  end.

Definition ProductTopology2 : TopologicalSpace :=
  WeakTopology prod2_proj.

Lemma prod2_conv1_cont: continuous prod2_conv1 (Y:=ProductTopology2).

Lemma prod2_conv2_cont: continuous prod2_conv2 (X:=ProductTopology2).

Lemma product2_fst_continuous:
  continuous (@fst (point_set X) (point_set Y))
    (X:=ProductTopology2).

Lemma product2_snd_continuous:
  continuous (@snd (point_set X) (point_set Y))
    (X:=ProductTopology2).

Lemma product2_map_continuous: forall (W:TopologicalSpace)
  (f:point_set W -> point_set X) (g:point_set W -> point_set Y)
  (w:point_set W),
  continuous_at f w -> continuous_at g w ->
  continuous_at (fun w:point_set W => (f w, g w)) w
  (Y:=ProductTopology2).

Inductive ProductTopology2_basis :
  Family (point_set ProductTopology2) :=
| intro_product2_basis_elt:
  forall (U:Ensemble (point_set X))
         (V:Ensemble (point_set Y)),
  open U -> open V ->
  In ProductTopology2_basis
  [ p:point_set ProductTopology2 |
    let (x,y):=p in (In U x /\ In V y) ].

Lemma ProductTopology2_basis_is_basis:
  open_basis ProductTopology2_basis.
Proof.
From ZornsLemma Require Import FiniteIntersections.

End product_topology2.

Section two_arg_convenience_results.

Variable X Y Z:TopologicalSpace.
Variable f:point_set X -> point_set Y -> point_set Z.

Definition continuous_2arg :=
  continuous (fun p:point_set X * point_set Y =>
              let (x,y):=p in f x y)
  (X:=ProductTopology2 X Y).
Definition continuous_at_2arg (x:point_set X) (y:point_set Y) :=
  continuous_at (fun p:point_set X * point_set Y =>
                 let (x,y):=p in f x y)  (x, y)
  (X:=ProductTopology2 X Y).

Lemma continuous_2arg_func_continuous_everywhere:
  continuous_2arg -> forall (x:point_set X) (y:point_set Y),
                       continuous_at_2arg x y.

Lemma pointwise_continuity_2arg:
  (forall (x:point_set X) (y:point_set Y),
   continuous_at_2arg x y) -> continuous_2arg.

End two_arg_convenience_results.

Arguments continuous_2arg {X} {Y} {Z}.
Arguments continuous_at_2arg {X} {Y} {Z}.

Lemma continuous_composition_at_2arg:
  forall (W X Y Z:TopologicalSpace)
    (f:point_set X -> point_set Y -> point_set Z)
    (g:point_set W -> point_set X) (h:point_set W -> point_set Y)
    (w:point_set W),
  continuous_at_2arg f (g w) (h w) ->
  continuous_at g w -> continuous_at h w ->
  continuous_at (fun w:point_set W => f (g w) (h w)) w. *)

Lemma Rplus_continuous: continuous_2arg Rplus (X:=RTop) (Y:=RTop) (Z:=RTop).
Proof.
apply pointwise_continuity_2arg.
intros.
red.
pose proof (RTop_metrization (x+y)).
apply continuous_at_neighborhood_basis with
  (metric_topology_neighborhood_basis R_metric (x+y)).
apply open_neighborhood_basis_is_neighborhood_basis.
apply RTop_metrization.

intros.
destruct H0.
exists ([ p:point_set RTop * point_set RTop | let (x',y'):=p in
  In (open_ball _ R_metric x (r/2)) x' /\
  In (open_ball _ R_metric y (r/2)) y' ]).
repeat split.
apply ProductTopology2_basis_is_basis.
constructor.
pose proof (RTop_metrization x).
destruct H1.
apply (open_neighborhood_basis_elements
  (open_ball _ R_metric x (r/2))).
constructor.
Require Import Fourier.
fourier.
destruct (RTop_metrization y).
apply (open_neighborhood_basis_elements
  (open_ball _ R_metric y (r/2))).
constructor.
fourier.
rewrite metric_zero.
fourier.
apply R_metric_is_metric.
rewrite metric_zero.
fourier.
apply R_metric_is_metric.
destruct x0 as [x' y'].
destruct H1 as [[[] []]].
unfold R_metric.
replace (x'+y' - (x+y)) with ((x'-x) + (y'-y)) by ring.
apply Rle_lt_trans with (Rabs (x'-x) + Rabs(y'-y)).
apply Rabs_triang.
replace r with (r/2+r/2) by field; apply Rplus_lt_compat; trivial.
Qed.

Corollary sum_continuous: forall (X:TopologicalSpace)
  (f g:point_set X -> point_set RTop) (x:point_set X),
  continuous_at f x -> continuous_at g x ->
  continuous_at (fun x:point_set X => f x + g x) x (Y:=RTop).
Proof.
intros.
apply continuous_composition_at_2arg; trivial.
apply continuous_func_continuous_everywhere.
apply Rplus_continuous.
Qed.

Lemma Rminus_continuous: continuous_2arg Rminus
  (X:=RTop) (Y:=RTop) (Z:=RTop).
Proof.
unfold Rminus.
apply pointwise_continuity_2arg; intros.
red.
pose proof (sum_continuous _
  (fun p:point_set (ProductTopology2 RTop RTop) => fst p)
  (fun p:point_set (ProductTopology2 RTop RTop) => -snd p) (x,y)).
simpl in H.
match goal with |- continuous_at ?f ?q =>
  replace f with (fun p:R*R => fst p + - snd p) end.
apply sum_continuous.
apply continuous_func_continuous_everywhere.
apply product2_fst_continuous.
apply (continuous_composition_at (Y:=RTop)).
apply continuous_func_continuous_everywhere.
apply Ropp_continuous.
apply continuous_func_continuous_everywhere.
apply product2_snd_continuous.

Require Import FunctionalExtensionality.
extensionality p.
destruct p as [x' y'].
trivial.
Qed.

Corollary diff_continuous: forall (X:TopologicalSpace)
  (f g:point_set X -> point_set RTop) (x:point_set X),
  continuous_at f x -> continuous_at g x ->
  continuous_at (fun x:point_set X => f x - g x) x (Y:=RTop).
Proof.
intros.
apply continuous_composition_at_2arg; trivial.
apply continuous_func_continuous_everywhere.
exact Rminus_continuous.
Qed.

Lemma const_multiple_func_continuous: forall c:R,
  continuous (fun x:R => c*x) (X:=RTop) (Y:=RTop).
Proof.
intros.
apply pointwise_continuity; intros.
apply metric_space_fun_continuity with R_metric R_metric;
  try apply RTop_metrization.
destruct (classic (c=0)).
exists 1.
split.
red; auto with real.
intros.
rewrite H.
unfold R_metric.
replace (0*x'-0*x) with 0 by ring.
rewrite Rabs_R0.
trivial.

intros.
exists (eps / Rabs c).
split.
apply Rmult_gt_0_compat; trivial.
apply Rinv_0_lt_compat.
apply Rabs_pos_lt; trivial.
intros.
unfold R_metric.
replace (c*x' - c*x) with (c*(x'-x)) by ring.
rewrite Rabs_mult.
replace eps with (Rabs c * (eps / Rabs c)); try field.
apply Rmult_lt_compat_l.
apply Rabs_pos_lt; trivial.
trivial.
apply Rabs_no_R0; trivial.
Qed.

Corollary const_multiple_continuous: forall (X:TopologicalSpace)
  (f:point_set X -> point_set RTop) (c:R) (x:point_set X),
  continuous_at f x -> continuous_at (fun x:point_set X => c * f x) x
                       (Y:=RTop).
Proof.
intros.
apply continuous_composition_at; trivial.
apply continuous_func_continuous_everywhere.
apply const_multiple_func_continuous with (c:=c).
Qed.

Lemma Rmult_continuous_at_origin: continuous_at_2arg Rmult 0 0
                                  (X:=RTop) (Y:=RTop) (Z:=RTop).
Proof.
red.
pose proof (RTop_metrization 0).
apply continuous_at_neighborhood_basis with
  (metric_topology_neighborhood_basis R_metric 0).
apply open_neighborhood_basis_is_neighborhood_basis.
replace (0*0) with 0 by auto with real.
apply H.

intros.
destruct H0.
exists (characteristic_function_to_ensemble
  (fun p:point_set RTop * point_set RTop => let (x',y'):=p in
  In (open_ball _ R_metric 0 r) x' /\
  In (open_ball _ R_metric 0 1) y' )).
repeat split.
apply ProductTopology2_basis_is_basis.
constructor.
destruct H.
apply (open_neighborhood_basis_elements (open_ball _ R_metric 0 r)).
constructor; trivial.
destruct H.
apply (open_neighborhood_basis_elements (open_ball _ R_metric 0 1)).
constructor; red; auto with real.
rewrite metric_zero; trivial.
apply R_metric_is_metric.
rewrite metric_zero; auto with real.
apply R_metric_is_metric.

destruct H1.
destruct x as [x y].
destruct H1 as [[] []].
unfold R_metric in H1, H2.
unfold R_metric.
replace (x*y-0) with (x*y) by auto with real.
replace (x-0) with x in H1 by auto with real.
replace (y-0) with y in H2 by auto with real.
rewrite Rabs_mult.
replace r with (r*1) by auto with real.
apply Rmult_le_0_lt_compat; trivial.
apply Rabs_pos.
apply Rabs_pos.
Qed.

Lemma Rmult_continuous: continuous_2arg Rmult (X:=RTop) (Y:=RTop) (Z:=RTop).
Proof.
apply pointwise_continuity_2arg.
intros x0 y0.
red.
match goal with |- continuous_at ?f ?q => replace f with
  (fun p:point_set RTop*point_set RTop =>
   (fst p - x0) * (snd p - y0) + y0 * fst p + x0 * snd p - x0 * y0) end.
apply diff_continuous.
apply sum_continuous.
apply sum_continuous.
apply continuous_composition_at_2arg with RTop RTop.
simpl.
replace (x0-x0) with 0 by ring.
replace (y0-y0) with 0 by ring.
apply Rmult_continuous_at_origin.
apply diff_continuous.
apply continuous_func_continuous_everywhere; apply product2_fst_continuous.
apply continuous_func_continuous_everywhere; apply continuous_constant.
apply diff_continuous.
apply continuous_func_continuous_everywhere; apply product2_snd_continuous.
apply continuous_func_continuous_everywhere; apply continuous_constant.
apply const_multiple_continuous.
apply continuous_func_continuous_everywhere; apply product2_fst_continuous.
apply const_multiple_continuous.
apply continuous_func_continuous_everywhere; apply product2_snd_continuous.
apply continuous_func_continuous_everywhere; apply continuous_constant.

extensionality p.
destruct p as [x y].
simpl.
ring.
Qed.

Corollary product_continuous: forall (X:TopologicalSpace)
  (f g:point_set X -> point_set RTop) (x:point_set X),
  continuous_at f x -> continuous_at g x ->
  continuous_at (fun x:point_set X => f x * g x) x (Y:=RTop).
Proof.
intros.
apply continuous_composition_at_2arg; trivial.
apply continuous_func_continuous_everywhere.
exact Rmult_continuous.
Qed.

Lemma Rinv_continuous_at_1: continuous_at Rinv 1 (X:=RTop) (Y:=RTop).
Proof.
apply metric_space_fun_continuity with R_metric R_metric;
  try apply RTop_metrization.
intros.
exists (Rmin (1/2) (eps/2)).
split; intros.
apply Rmin_Rgt_r; split; fourier.
assert (x' > 1/2).
assert (Rabs (x'-1) < 1/2).
apply Rlt_le_trans with (1 := H0).
apply Rmin_l.
destruct (Rabs_def2 _ _ H1).
fourier.
assert (/ x' < 2).
rewrite <- Rinv_involutive.
apply Rinv_lt_contravar.
apply Rmult_lt_0_compat; fourier.
unfold Rdiv in H1.
replace (1 * / 2) with (/ 2) in H1 by auto with real.
exact H1.
intro.
fourier.

unfold R_metric.
replace (/ x' - / 1) with ((1 - x') * / x'); try field.
rewrite Rabs_mult.
rewrite (Rabs_right (/ x')).
rewrite Rabs_minus_sym.
assert (Rabs (x' - 1) < eps/2).
apply Rlt_le_trans with (1:=H0).
apply Rmin_r.
replace eps with ((eps/2) * 2) by field.
apply Rmult_gt_0_lt_compat; trivial.
apply Rinv_0_lt_compat.
fourier.
fourier.
left.
apply Rinv_0_lt_compat.
fourier.
intro.
fourier.
Qed.

Lemma Rinv_continuous: forall x0:R, x0<>0 -> continuous_at Rinv x0
                                             (X:=RTop) (Y:=RTop).
Proof.
intros.
apply continuous_at_is_local with
  (f:=fun x:R => /x0 * Rinv (/x0 * x))
  (N:=Complement (Singleton 0)).
apply open_neighborhood_is_neighborhood.
split.
apply Hausdorff_impl_T1_sep.
apply T3_sep_impl_Hausdorff.
apply normal_sep_impl_T3_sep.
apply metrizable_impl_normal_sep.
exists R_metric.
apply R_metric_is_metric.
apply RTop_metrization.

intro.
destruct H0.
contradiction H.
reflexivity.

intros.
assert (x<>0).
intro.
contradiction H0.
rewrite H1; constructor.
simpl.
field; split; trivial.

apply const_multiple_continuous.
apply (continuous_composition_at (Y:=RTop)).
replace (/x0 * x0) with 1.
apply Rinv_continuous_at_1.
field; trivial.
apply continuous_func_continuous_everywhere.
apply const_multiple_func_continuous with (c:=/ x0).
Qed.

Lemma Rdiv_continuous: forall x y:R, y <> 0 ->
  continuous_at_2arg Rdiv x y (X:=RTop) (Y:=RTop) (Z:=RTop).
Proof.
intros.
red.
match goal with |- continuous_at ?f ?q => replace f with
  (fun p:point_set RTop * point_set RTop => fst p * / snd p) end.
apply product_continuous.
apply continuous_func_continuous_everywhere; apply product2_fst_continuous.
apply continuous_composition_at.
simpl.
apply Rinv_continuous; trivial.
apply continuous_func_continuous_everywhere; apply product2_snd_continuous.

extensionality p.
destruct p as [x' y'].
trivial.
Qed.

Corollary quotient_continuous: forall (X:TopologicalSpace)
  (f g:point_set X -> point_set RTop) (x0:point_set X),
  continuous_at f x0 -> continuous_at g x0 -> g x0 <> 0 ->
  continuous_at (fun x:point_set X => f x / g x) x0 (Y:=RTop).
Proof.
intros.
apply continuous_composition_at_2arg; trivial.
apply Rdiv_continuous; trivial.
Qed.

Lemma Rabs_continuous: continuous Rabs (X:=RTop) (Y:=RTop).
Proof.
apply pointwise_continuity; intros.
apply metric_space_fun_continuity with R_metric R_metric;
  try apply RTop_metrization.
intros.
exists eps; split; trivial.
intros.
apply Rle_lt_trans with (2 := H0).
apply Rabs_triang_inv2.
Qed.

Require Export Homeomorphisms.
(* Homeomorphisms:
Require Export TopologicalSpaces.
Require Export Continuity.

Inductive homeomorphism {X Y:TopologicalSpace}
  (f:point_set X -> point_set Y) : Prop :=
| intro_homeomorphism: forall g:point_set Y -> point_set X,
  continuous f -> continuous g ->
  (forall x:point_set X, g (f x) = x) ->
  (forall y:point_set Y, f (g y) = y) -> homeomorphism f.

Lemma homeomorphism_is_invertible: forall {X Y:TopologicalSpace}
  (f:point_set X -> point_set Y),
  homeomorphism f -> invertible f.

Definition open_map {X Y:TopologicalSpace}
  (f:point_set X -> point_set Y) : Prop :=
forall U:Ensemble (point_set X), open U -> open (Im U f).

Lemma homeomorphism_is_open_map: forall {X Y:TopologicalSpace}
  (f:point_set X -> point_set Y),
  homeomorphism f -> open_map f.

Lemma invertible_open_map_is_homeomorphism: forall {X Y:TopologicalSpace}
  (f:point_set X -> point_set Y),
  invertible f -> continuous f -> open_map f -> homeomorphism f.

Inductive homeomorphic (X Y:TopologicalSpace) : Prop :=
| intro_homeomorphic: forall f:point_set X -> point_set Y,
    homeomorphism f -> homeomorphic X Y.

Require Export Relation_Definitions.
From ZornsLemma Require Import Relation_Definitions_Implicit.

Lemma homeomorphic_equiv: equivalence homeomorphic. *)

Lemma open_interval_homeomorphic_to_real_line:
  let U:=characteristic_function_to_ensemble
      (fun x:point_set RTop => -1 < x < 1) in
  homeomorphic RTop (SubspaceTopology U).
Proof.
intros.
assert (forall x:R, -1 < x / (1 + Rabs x) < 1).
intros.
assert (0 < 1 + Rabs x).
apply Rlt_le_trans with 1; auto with real.
pattern 1 at 1; replace 1 with (1+0) by auto with real.
apply Rplus_le_compat_l.
apply Rabs_pos.
apply and_comm; apply Rabs_def2.
unfold Rdiv; rewrite Rabs_mult.
rewrite Rabs_Rinv.
rewrite (Rabs_right (1 + Rabs x)); try (left; trivial).
pattern 1 at 2; replace 1 with ((1 + Rabs x) * / (1 + Rabs x)).
apply Rmult_lt_compat_r.
apply Rinv_0_lt_compat; trivial.
pattern (Rabs x) at 1; replace (Rabs x) with (0 + Rabs x); auto with real.
field.
apply Rgt_not_eq; trivial.
apply Rgt_not_eq; trivial.

assert (forall x:point_set RTop, In U (x / (1 + Rabs x))).
intros; constructor; apply H.
Require Import ContinuousFactorization.
(* ContinuousFactorization:
Require Export TopologicalSpaces.
Require Export Continuity.
Require Export SubspaceTopology.

Section continuous_factorization.

Variable X Y:TopologicalSpace.
Variable f:point_set X -> point_set Y.
Variable S:Ensemble (point_set Y).
Hypothesis f_cont: continuous f.
Hypothesis f_img: forall x:point_set X, In S (f x).

Definition continuous_factorization :
  point_set X -> point_set (SubspaceTopology S) :=
  fun x:point_set X => exist _ (f x) (f_img x).

Lemma factorization_is_continuous:
  continuous continuous_factorization.

End continuous_factorization.

Arguments continuous_factorization {X} {Y}.

Section continuous_surj_factorization.

Variable X Y:TopologicalSpace.
Variable f:point_set X -> point_set Y.
Hypothesis f_cont: continuous f.

Definition continuous_surj_factorization :
  point_set X -> point_set (SubspaceTopology (Im Full_set f)).

Lemma continuous_surj_factorization_is_surjective:
  surjective continuous_surj_factorization.

Lemma continuous_surj_factorization_is_continuous:
  continuous continuous_surj_factorization.

End continuous_surj_factorization.

Arguments continuous_surj_factorization {X} {Y}. *)
exists (continuous_factorization _ _ H0).
exists (fun x:point_set (SubspaceTopology U) =>
  (subspace_inc U x) / (1 - Rabs (subspace_inc U x))).
apply factorization_is_continuous.
apply pointwise_continuity; intros.
apply quotient_continuous.
apply continuous_func_continuous_everywhere; apply continuous_identity.
apply sum_continuous.
apply continuous_func_continuous_everywhere; apply continuous_constant.
apply continuous_func_continuous_everywhere; apply Rabs_continuous.
apply Rgt_not_eq.
apply Rlt_le_trans with 1; auto with real.
pattern 1 at 1; replace 1 with (1+0) by auto with real.
apply Rplus_le_compat_l.
apply Rabs_pos.

apply pointwise_continuity; intros.
apply quotient_continuous.
apply continuous_func_continuous_everywhere; apply subspace_inc_continuous.
apply diff_continuous.
apply continuous_func_continuous_everywhere; apply continuous_constant.
apply continuous_composition_at.
apply continuous_func_continuous_everywhere; apply Rabs_continuous.
apply continuous_func_continuous_everywhere; apply subspace_inc_continuous.
apply Rgt_not_eq.
apply Rgt_minus.
red.
destruct x as [x [[]]]; simpl.
apply Rabs_def1; trivial.

simpl.
intros.
unfold Rabs at 1 3; destruct Rcase_abs.
rewrite Rabs_left.
field.
split; intro; fourier.
assert (/ (1 + -x) > 0).
apply Rinv_0_lt_compat.
fourier.
replace 0 with (x*0) by auto with real.
apply Rmult_lt_gt_compat_neg_l; trivial.

rewrite Rabs_right.
field.
split; intro; fourier.
assert (/ (1+x) > 0).
apply Rinv_0_lt_compat.
fourier.
apply Rle_ge.
apply Rge_le in r.
red in H1.
unfold Rdiv.
replace 0 with (0 * / (1+x)); auto with real.

intros.
destruct y as [x].
simpl.
From ZornsLemma Require Import Proj1SigInjective.
apply subset_eq_compatT.
destruct i.
destruct H1.
assert (Rabs x < 1).
apply Rabs_def1; trivial.

unfold Rabs at 1 3; destruct Rcase_abs.
rewrite Rabs_left.
field.
split; intro; fourier.
replace (1 - -x) with (1+x) by ring.
assert (/ (1+x) > 0).
apply Rinv_0_lt_compat.
fourier.
unfold Rdiv.
replace 0 with (x*0) by auto with real.
apply Rmult_lt_gt_compat_neg_l; trivial.

rewrite Rabs_right.
field.
split; intro; fourier.
assert (/ (1-x) > 0).
apply Rinv_0_lt_compat.
apply Rgt_minus; trivial.
unfold Rdiv.
red in H4.
apply Rge_le in r.
apply Rle_ge.
replace 0 with (0 * / (1-x)); auto with real.
Qed.
