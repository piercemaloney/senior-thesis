Require Export TopologicalSpaces.
(* TopologicalSpaces:
Require Export Ensembles.
From ZornsLemma Require Import EnsemblesImplicit.
From ZornsLemma Require Export Families.
From ZornsLemma Require Export IndexedFamilies.
From ZornsLemma Require Export FiniteTypes.
From ZornsLemma Require Import EnsemblesSpec.

Record TopologicalSpace : Type := {
  point_set : Type;
  open : Ensemble point_set -> Prop;
  open_family_union : forall F : Family point_set,
    (forall S : Ensemble point_set, In F S -> open S) ->
    open (FamilyUnion F);
  open_intersection2: forall U V:Ensemble point_set,
    open U -> open V -> open (Intersection U V);
  open_full : open Full_set
}.

Arguments open {t}.
Arguments open_family_union {t}.
Arguments open_intersection2 {t}.

Lemma open_empty: forall X:TopologicalSpace,
  open (@Empty_set (point_set X)).

Lemma open_union2: forall {X:TopologicalSpace}
  (U V:Ensemble (point_set X)), open U -> open V -> open (Union U V).

Lemma open_indexed_union: forall {X:TopologicalSpace} {A:Type}
  (F:IndexedFamily A (point_set X)),
  (forall a:A, open (F a)) -> open (IndexedUnion F).

Lemma open_finite_indexed_intersection:
  forall {X:TopologicalSpace} {A:Type}
    (F:IndexedFamily A (point_set X)),
    FiniteT A -> (forall a:A, open (F a)) ->
    open (IndexedIntersection F).

Definition closed {X:TopologicalSpace} (F:Ensemble (point_set X)) :=
  open (Ensembles.Complement F).

Lemma closed_complement_open: forall {X:TopologicalSpace}
  (U:Ensemble (point_set X)), closed (Ensembles.Complement U) ->

Lemma closed_union2: forall {X:TopologicalSpace}
  (F G:Ensemble (point_set X)),
  closed F -> closed G -> closed (Union F G).

Lemma closed_intersection2: forall {X:TopologicalSpace}
  (F G:Ensemble (point_set X)),
  closed F -> closed G -> closed (Intersection F G).

Lemma closed_family_intersection: forall {X:TopologicalSpace}
  (F:Family (point_set X)),
  (forall S:Ensemble (point_set X), In F S -> closed S) ->
  closed (FamilyIntersection F).

Lemma closed_indexed_intersection: forall {X:TopologicalSpace}
  {A:Type} (F:IndexedFamily A (point_set X)),
  (forall a:A, closed (F a)) -> closed (IndexedIntersection F).

Lemma closed_finite_indexed_union: forall {X:TopologicalSpace}
  {A:Type} (F:IndexedFamily A (point_set X)),
  FiniteT A -> (forall a:A, closed (F a)) ->
  closed (IndexedUnion F).

Hint Unfold closed : topology.
Hint Resolve (@open_family_union) (@open_intersection2) open_full
  open_empty (@open_union2) (@open_indexed_union)
  (@open_finite_indexed_intersection) (@closed_complement_open)
  (@closed_union2) (@closed_intersection2) (@closed_family_intersection)
  (@closed_indexed_intersection) (@closed_finite_indexed_union)
  : topology.

Section Build_from_closed_sets.

Variable X:Type.
Variable closedP : Ensemble X -> Prop.
Hypothesis closedP_empty: closedP Empty_set.
Hypothesis closedP_union2: forall F G:Ensemble X,
  closedP F -> closedP G -> closedP (Union F G).
Hypothesis closedP_family_intersection: forall F:Family X,
  (forall G:Ensemble X, In F G -> closedP G) ->
  closedP (FamilyIntersection F).

Definition Build_TopologicalSpace_from_closed_sets : TopologicalSpace.

Lemma Build_TopologicalSpace_from_closed_sets_closed:
  forall (F:Ensemble (point_set Build_TopologicalSpace_from_closed_sets)),
  closed F <-> closedP F.

End Build_from_closed_sets.

Arguments Build_TopologicalSpace_from_closed_sets {X}. *)
Require Import InteriorsClosures.
(* InteriorsClosures:
Require Export TopologicalSpaces.
From ZornsLemma Require Export EnsemblesSpec.

Section interior_closure.

Variable X:TopologicalSpace.
Variable S:Ensemble (point_set X).

Definition interior := FamilyUnion
  [ U:Ensemble (point_set X) | open U /\ Included U S ].
Definition closure := FamilyIntersection
  [ F:Ensemble (point_set X) | closed F /\ Included S F ].

Lemma interior_open : open interior.

Lemma interior_deflationary : Included interior S.

Lemma interior_fixes_open: open S -> interior = S.

Lemma interior_maximal: forall U:Ensemble (point_set X),
  open U -> Included U S -> Included U interior.

Lemma closure_closed : closed closure.

Lemma closure_inflationary : Included S closure.

Lemma closure_fixes_closed : closed S -> closure = S.

Lemma closure_minimal: forall F:Ensemble (point_set X),
  closed F -> Included S F -> Included closure F.

End interior_closure.

Arguments interior {X}.
Arguments closure {X}.
Arguments interior_open {X}.
Arguments interior_deflationary {X}.
Arguments interior_fixes_open {X}.
Arguments interior_maximal {X}.
Arguments closure_closed {X}.
Arguments closure_inflationary {X}.
Arguments closure_fixes_closed {X}.
Arguments closure_minimal {X}.

Section interior_closure_relations.

Variable X:TopologicalSpace.

Lemma interior_increasing: forall S T:Ensemble (point_set X),
  Included S T -> Included (interior S) (interior T).

Lemma interior_intersection: forall S T:Ensemble (point_set X),
  interior (Intersection S T) =
  Intersection (interior S) (interior T).

Lemma interior_union: forall S T:Ensemble (point_set X),
  Included (Union (interior S) (interior T))
           (interior (Union S T)).

Lemma complement_inclusion: forall {Y:Type} (S T:Ensemble Y),
  Included S T -> Included (Complement T) (Complement S).

Lemma interior_complement: forall S:Ensemble (point_set X),
  interior (Complement S) = Complement (closure S).

Lemma closure_increasing: forall S T:Ensemble (point_set X),
  Included S T -> Included (closure S) (closure T).

Lemma closure_complement: forall S:Ensemble (point_set X),
  closure (Complement S) = Complement (interior S).

Lemma closure_union: forall S T:Ensemble (point_set X),
  closure (Union S T) = Union (closure S) (closure T).

Lemma closure_intersection: forall S T:Ensemble (point_set X),
  Included (closure (Intersection S T))
           (Intersection (closure S) (closure T)).

Lemma meets_every_open_neighborhood_impl_closure:
  forall (S:Ensemble (point_set X)) (x:point_set X),
  (forall U:Ensemble (point_set X), open U -> In U x ->
                                Inhabited (Intersection S U)) ->
  In (closure S) x.

Lemma closure_impl_meets_every_open_neighborhood:
  forall (S:Ensemble (point_set X)) (x:point_set X),
  In (closure S) x ->
  forall U:Ensemble (point_set X), open U -> In U x ->
    Inhabited (Intersection S U).

Definition dense (S:Ensemble (point_set X)) : Prop :=
  closure S = Full_set.

Lemma dense_meets_every_nonempty_open:
  forall S:Ensemble (point_set X), dense S ->
    forall U:Ensemble (point_set X), open U -> Inhabited U ->
    Inhabited (Intersection S U).

Lemma meets_every_nonempty_open_impl_dense:
  forall S:Ensemble (point_set X),
  (forall U:Ensemble (point_set X), open U -> Inhabited U ->
   Inhabited (Intersection S U)) ->
  dense S.

End interior_closure_relations.

Arguments interior_increasing {X}.
Arguments interior_intersection {X}.
Arguments interior_union {X}.
Arguments interior_complement {X}.
Arguments closure_increasing {X}.
Arguments closure_complement {X}.
Arguments closure_union {X}.
Arguments closure_intersection {X}.
Arguments dense {X}.

Section Build_from_closure.

Variable X:Type.
Variable cl : Ensemble X -> Ensemble X.
Hypothesis cl_inflationary: forall S:Ensemble X,
  Included S (cl S).
Hypothesis cl_respects_union: forall S1 S2:Ensemble X,
  cl (Union S1 S2) = Union (cl S1) (cl S2).
Hypothesis cl_empty: cl Empty_set = Empty_set.
Hypothesis cl_idempotent: forall S:Ensemble X,
  cl (cl S) = cl S.

Lemma cl_increasing: forall S1 S2:Ensemble X,
  Included S1 S2 -> Included (cl S1) (cl S2).

Definition Build_TopologicalSpace_from_closure_operator : TopologicalSpace.

Lemma Build_TopologicalSpace_from_closure_operator_closure:
  forall S:Ensemble (point_set Build_TopologicalSpace_from_closure_operator),
    closure S = cl S.

End Build_from_closure.

Arguments Build_TopologicalSpace_from_closure_operator {X}. *)

Definition T0_sep (X:TopologicalSpace) : Prop :=
  forall x y:point_set X, x <> y ->
  (exists U:Ensemble (point_set X), open U /\ In U x /\ ~ In U y) \/
  (exists U:Ensemble (point_set X), open U /\ ~ In U x /\ In U y).

Definition T1_sep (X:TopologicalSpace) : Prop :=
  forall x:point_set X, closed (Singleton x).

Definition Hausdorff (X:TopologicalSpace) : Prop :=
  forall x y:point_set X, x <> y ->
    exists U:Ensemble (point_set X),
    exists V:Ensemble (point_set X),
  open U /\ open V /\ In U x /\ In V y /\
  Intersection U V = Empty_set.
Definition T2_sep := Hausdorff.

Definition T3_sep (X:TopologicalSpace) : Prop :=
  T1_sep X /\
  forall (x:point_set X) (F:Ensemble (point_set X)),
  closed F -> ~ In F x -> exists U:Ensemble (point_set X),
                          exists V:Ensemble (point_set X),
        open U /\ open V /\ In U x /\ Included F V /\
        Intersection U V = Empty_set.

Definition normal_sep (X:TopologicalSpace) : Prop :=
  T1_sep X /\
  forall (F G:Ensemble (point_set X)),
  closed F -> closed G -> Intersection F G = Empty_set ->
  exists U:Ensemble (point_set X), exists V:Ensemble (point_set X),
  open U /\ open V /\ Included F U /\ Included G V /\
  Intersection U V = Empty_set.
Definition T4_sep := normal_sep.

Lemma T1_sep_impl_T0_sep: forall X:TopologicalSpace,
  T1_sep X -> T0_sep X.
Proof.
intros.
red; intros.
left.
exists (Complement (Singleton y)); repeat split.
apply H.
repeat red; intro.
destruct H1; contradiction H0; trivial.
red; intro.
repeat red in H1.
apply H1; constructor.
Qed.

Lemma Hausdorff_impl_T1_sep: forall X:TopologicalSpace,
  Hausdorff X -> T1_sep X.
Proof.
intros.
red; intros.
assert (closure (Singleton x) = Singleton x).
apply Extensionality_Ensembles; split.
red; intros.
assert (x = x0).
apply NNPP.
red; intro.
pose proof (H x x0 H1).
destruct H2 as [U [V ?]].
intuition.
assert (In (interior (Complement (Singleton x))) x0).
exists V.
constructor; split; trivial.
red; intros.
red; red; intro.
destruct H8.
assert (In Empty_set x).
rewrite <- H7.
constructor; trivial.
destruct H8.
assumption.
rewrite interior_complement in H6.
contradiction H6; exact H0.
destruct H1; constructor.
apply closure_inflationary.

rewrite <- H0; apply closure_closed.
Qed.

Lemma T3_sep_impl_Hausdorff: forall X:TopologicalSpace,
  T3_sep X -> Hausdorff X.
Proof.
intros.
destruct H.
red; intros.
pose proof (H0 x (Singleton y)).
match type of H2 with | ?A -> ?B -> ?C => assert C end.
apply H2.
apply H.
red; intro.
destruct H3.
contradiction H1; trivial.
destruct H3 as [U [V [? [? [? [? ?]]]]]].
exists U; exists V; repeat split; auto with sets.
Qed.

Lemma normal_sep_impl_T3_sep: forall X:TopologicalSpace,
  normal_sep X -> T3_sep X.
Proof.
intros.
destruct H.
split; trivial.
intros.
pose proof (H0 (Singleton x) F).
match type of H3 with | ?A -> ?B -> ?C -> ?D => assert D end.
apply H3; trivial.
apply Extensionality_Ensembles; split; auto with sets.
red; intros.
destruct H4 as [? []].
contradiction H2.
destruct H4 as [U [V [? [? [? [? ?]]]]]].
exists U; exists V; repeat split; auto with sets.
Qed.

Section Hausdorff_and_nets.
Require Export Nets.
(* Nets:
Require Export TopologicalSpaces.
Require Export DirectedSets.
Require Export InteriorsClosures.
Require Export Continuity.

Set Asymmetric Patterns.

Section Net.

Variable I:DirectedSet.
Variable X:TopologicalSpace.

Definition Net := DS_set I -> point_set X.

Definition net_limit (x:Net) (x0:point_set X) : Prop :=
  forall U:Ensemble (point_set X), open U -> In U x0 ->
  for large i:DS_set I, In U (x i).

Definition net_cluster_point (x:Net) (x0:point_set X) : Prop :=
  forall U:Ensemble (point_set X), open U -> In U x0 ->
  exists arbitrarily large i:DS_set I, In U (x i).

Lemma net_limit_is_cluster_point: forall (x:Net) (x0:point_set X),
  net_limit x x0 -> net_cluster_point x x0.

Lemma net_limit_in_closure: forall (S:Ensemble (point_set X))
  (x:Net) (x0:point_set X),
  (exists arbitrarily large i:DS_set I, In S (x i)) ->
  net_limit x x0 -> In (closure S) x0.

Lemma net_cluster_point_in_closure: forall (S:Ensemble (point_set X))
  (x:Net) (x0:point_set X),
  (for large i:DS_set I, In S (x i)) ->
  net_cluster_point x x0 -> In (closure S) x0.

End Net.

Arguments net_limit {I} {X}.
Arguments net_cluster_point {I} {X}.
Arguments net_limit_is_cluster_point {I} {X}.
Arguments net_limit_in_closure {I} {X}.
Arguments net_cluster_point_in_closure {I} {X}.

Section neighborhood_net.

Variable X:TopologicalSpace.
Variable x:point_set X.

Inductive neighborhood_net_DS_set : Type :=
  | intro_neighborhood_net_DS :
    forall (U:Ensemble (point_set X)) (y:point_set X),
    open U -> In U x -> In U y -> neighborhood_net_DS_set.

Definition neighborhood_net_DS_ord
  (Uy Vz:neighborhood_net_DS_set) : Prop :=
  match Uy, Vz with
  | intro_neighborhood_net_DS U _ _ _ _,
    intro_neighborhood_net_DS V _ _ _ _ =>
    Included V U
  end.

Definition neighborhood_net_DS : DirectedSet.

Definition neighborhood_net : Net neighborhood_net_DS X :=
  fun (x:neighborhood_net_DS_set) => match x with
  | intro_neighborhood_net_DS _ y _ _ _ => y
  end.

Lemma neighborhood_net_limit: net_limit neighborhood_net x.

End neighborhood_net.

Lemma net_limits_determine_topology:
  forall {X:TopologicalSpace} (S:Ensemble (point_set X))
  (x0:point_set X), In (closure S) x0 ->
  exists I:DirectedSet, exists x:Net I X,
  (forall i:DS_set I, In S (x i)) /\ net_limit x x0.

Section Nets_and_continuity.

Variable X Y:TopologicalSpace.
Variable f:point_set X -> point_set Y.

Lemma continuous_func_preserves_net_limits:
  forall {I:DirectedSet} (x:Net I X) (x0:point_set X),
    net_limit x x0 -> continuous_at f x0 ->
    net_limit (fun i:DS_set I => f (x i)) (f x0).

Lemma func_preserving_net_limits_is_continuous:
  forall x0:point_set X,
  (forall (I:DirectedSet) (x:Net I X),
    net_limit x x0 -> net_limit (fun i:DS_set I => f (x i)) (f x0))
  -> continuous_at f x0.

End Nets_and_continuity.

Section Subnet.

Variable X:TopologicalSpace.
Variable I:DirectedSet.
Variable x:Net I X.

Inductive Subnet {J:DirectedSet} : Net J X -> Prop :=
  | intro_subnet: forall h:DS_set J -> DS_set I,
    (forall j1 j2:DS_set J, DS_ord j1 j2 ->
       DS_ord (h j1) (h j2)) ->
    (exists arbitrarily large i:DS_set I,
       exists j:DS_set J, h j = i) ->
    Subnet (fun j:DS_set J => x (h j)).

Lemma subnet_limit: forall (x0:point_set X) {J:DirectedSet}
  (y:Net J X), net_limit x x0 -> Subnet y ->
  net_limit y x0.

Lemma subnet_cluster_point: forall (x0:point_set X) {J:DirectedSet}
  (y:Net J X), net_cluster_point y x0 ->
  Subnet y -> net_cluster_point x x0.

Section cluster_point_subnet.

Variable x0:point_set X.
Hypothesis x0_cluster_point: net_cluster_point x x0.
Hypothesis I_nonempty: inhabited (DS_set I).

Record cluster_point_subnet_DS_set : Type := {
  cps_i:DS_set I;
  cps_U:Ensemble (point_set X);
  cps_U_open_neigh: open_neighborhood cps_U x0;
  cps_xi_in_U: In cps_U (x cps_i)
}.

Definition cluster_point_subnet_DS_ord
  (iU1 iU2 : cluster_point_subnet_DS_set) : Prop :=
  DS_ord (cps_i iU1) (cps_i iU2) /\
  Included (cps_U iU2) (cps_U iU1).

Definition cluster_point_subnet_DS : DirectedSet.

Definition cluster_point_subnet : Net
  cluster_point_subnet_DS X :=
  fun (iU:DS_set cluster_point_subnet_DS) =>
  x (cps_i iU).

Lemma cluster_point_subnet_is_subnet:
  Subnet cluster_point_subnet.

Lemma cluster_point_subnet_converges:
  net_limit cluster_point_subnet x0.

Lemma net_cluster_point_impl_subnet_converges:
  exists J:DirectedSet, exists y:Net J X,
  Subnet y /\ net_limit y x0.

End cluster_point_subnet.

End Subnet. *)

Lemma Hausdorff_impl_net_limit_unique:
  forall {X:TopologicalSpace} {I:DirectedSet} (x:Net I X),
    Hausdorff X -> uniqueness (net_limit x).
Proof.
intros.
red; intros x1 x2 ? ?.
apply NNPP; intro.
destruct (H x1 x2) as [U [V [? [? [? [? ?]]]]]]; trivial.
destruct (H0 U H3 H5) as [i].
destruct (H1 V H4 H6) as [j].
destruct (DS_join_cond i j) as [k [? ?]].
assert (In (Intersection U V) (x k)).
constructor; (apply H8 || apply H9); trivial.
rewrite H7 in H12.
destruct H12.
Qed.

Lemma Hausdorff_impl_net_limit_is_unique_cluster_point:
  forall {X:TopologicalSpace} {I:DirectedSet} (x:Net I X)
    (x0:point_set X), Hausdorff X -> net_limit x x0 ->
    forall y:point_set X, net_cluster_point x y -> y = x0.
Proof.
intros.
destruct (net_cluster_point_impl_subnet_converges _ _ x y H1) as
  [J [x' [? ?]]].
destruct (H0 Full_set).
apply open_full.
constructor.
exists; exact x1.
assert (net_limit x' x0).
apply subnet_limit with _ x; trivial.
apply Hausdorff_impl_net_limit_unique with x'; trivial.
Qed.

Lemma net_limit_is_unique_cluster_point_impl_Hausdorff:
  forall (X:TopologicalSpace),
  (forall (I:DirectedSet) (x:Net I X) (x0 y:point_set X),
  net_limit x x0 -> net_cluster_point x y ->
  y = x0) -> Hausdorff X.
Proof.
intros.
red; intros.
assert (~ net_cluster_point (neighborhood_net _ x) y).
red; intro.
contradiction H0.
symmetry.
apply H with _ (neighborhood_net _ x).
apply neighborhood_net_limit.
assumption.

apply not_all_ex_not in H1.
destruct H1 as [V].
apply imply_to_and in H1.
destruct H1.
apply imply_to_and in H2.
destruct H2.
apply not_all_ex_not in H3.
destruct H3 as [[U]].
exists U; exists V; repeat split; trivial.
apply Extensionality_Ensembles; split; auto with sets.
red; intros.
destruct H4.
contradiction H3.
exists (intro_neighborhood_net_DS X x U x0 o i H4).
split.
simpl; auto with sets.
simpl.
trivial.
Qed.

Lemma net_limit_uniqueness_impl_Hausdorff:
  forall X:TopologicalSpace,
  (forall (I:DirectedSet) (x:Net I X), uniqueness (net_limit x)) ->
  Hausdorff X.
Proof.
intros.
apply net_limit_is_unique_cluster_point_impl_Hausdorff.
intros.
pose proof (net_cluster_point_impl_subnet_converges _ _ _ _ H1).
destruct H2 as [J [x' [? ?]]].
destruct (H0 Full_set).
apply open_full.
constructor.
exists; exact x1.
assert (net_limit x' x0).
apply subnet_limit with _ x; trivial.
unfold uniqueness in H.
apply H with _ x'; trivial.
Qed.

End Hausdorff_and_nets.
