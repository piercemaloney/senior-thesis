Require Export TopologicalSpaces.
(* TopologicalSpaces:
Require Export Ensembles.
From ZornsLemma Require Import EnsemblesImplicit.
From ZornsLemma Require Export Families.
From ZornsLemma Require Export IndexedFamilies.
From ZornsLemma Require Export FiniteTypes.
From ZornsLemma Require Import EnsemblesSpec.

Record TopologicalSpace : Type := {
  point_set : Type;
  open : Ensemble point_set -> Prop;
  open_family_union : forall F : Family point_set,
    (forall S : Ensemble point_set, In F S -> open S) ->
    open (FamilyUnion F);
  open_intersection2: forall U V:Ensemble point_set,
    open U -> open V -> open (Intersection U V);
  open_full : open Full_set
}.

Arguments open {t}.
Arguments open_family_union {t}.
Arguments open_intersection2 {t}.

Lemma open_empty: forall X:TopologicalSpace,
  open (@Empty_set (point_set X)).

Lemma open_union2: forall {X:TopologicalSpace}
  (U V:Ensemble (point_set X)), open U -> open V -> open (Union U V).

Lemma open_indexed_union: forall {X:TopologicalSpace} {A:Type}
  (F:IndexedFamily A (point_set X)),
  (forall a:A, open (F a)) -> open (IndexedUnion F).

Lemma open_finite_indexed_intersection:
  forall {X:TopologicalSpace} {A:Type}
    (F:IndexedFamily A (point_set X)),
    FiniteT A -> (forall a:A, open (F a)) ->
    open (IndexedIntersection F).

Definition closed {X:TopologicalSpace} (F:Ensemble (point_set X)) :=
  open (Ensembles.Complement F).

Lemma closed_complement_open: forall {X:TopologicalSpace}
  (U:Ensemble (point_set X)), closed (Ensembles.Complement U) ->

Lemma closed_union2: forall {X:TopologicalSpace}
  (F G:Ensemble (point_set X)),
  closed F -> closed G -> closed (Union F G).

Lemma closed_intersection2: forall {X:TopologicalSpace}
  (F G:Ensemble (point_set X)),
  closed F -> closed G -> closed (Intersection F G).

Lemma closed_family_intersection: forall {X:TopologicalSpace}
  (F:Family (point_set X)),
  (forall S:Ensemble (point_set X), In F S -> closed S) ->
  closed (FamilyIntersection F).

Lemma closed_indexed_intersection: forall {X:TopologicalSpace}
  {A:Type} (F:IndexedFamily A (point_set X)),
  (forall a:A, closed (F a)) -> closed (IndexedIntersection F).

Lemma closed_finite_indexed_union: forall {X:TopologicalSpace}
  {A:Type} (F:IndexedFamily A (point_set X)),
  FiniteT A -> (forall a:A, closed (F a)) ->
  closed (IndexedUnion F).

Hint Unfold closed : topology.
Hint Resolve (@open_family_union) (@open_intersection2) open_full
  open_empty (@open_union2) (@open_indexed_union)
  (@open_finite_indexed_intersection) (@closed_complement_open)
  (@closed_union2) (@closed_intersection2) (@closed_family_intersection)
  (@closed_indexed_intersection) (@closed_finite_indexed_union)
  : topology.

Section Build_from_closed_sets.

Variable X:Type.
Variable closedP : Ensemble X -> Prop.
Hypothesis closedP_empty: closedP Empty_set.
Hypothesis closedP_union2: forall F G:Ensemble X,
  closedP F -> closedP G -> closedP (Union F G).
Hypothesis closedP_family_intersection: forall F:Family X,
  (forall G:Ensemble X, In F G -> closedP G) ->
  closedP (FamilyIntersection F).

Definition Build_TopologicalSpace_from_closed_sets : TopologicalSpace.

Lemma Build_TopologicalSpace_from_closed_sets_closed:
  forall (F:Ensemble (point_set Build_TopologicalSpace_from_closed_sets)),
  closed F <-> closedP F.

End Build_from_closed_sets.

Arguments Build_TopologicalSpace_from_closed_sets {X}. *)
Require Export OrderTopology.
(* OrderTopology:
Require Export Subbases.
From ZornsLemma Require Export Relation_Definitions_Implicit.
Require Export SeparatednessAxioms.

Section OrderTopology.

Variable X:Type.
Variable R:relation X.
Hypothesis R_ord: order R.

Inductive order_topology_subbasis : Family X :=
  | intro_lower_interval: forall x:X,
    In order_topology_subbasis [ y:X | R y x /\ y <> x ]
  | intro_upper_interval: forall x:X,
    In order_topology_subbasis [ y:X | R x y /\ y <> x].

Definition OrderTopology : TopologicalSpace :=
  Build_TopologicalSpace_from_subbasis X order_topology_subbasis.

Section if_total_order.

Hypothesis R_total: forall x y:X, R x y \/ R y x.

Lemma lower_closed_interval_closed: forall x:X,
  closed [ y:X | R y x ] (X:=OrderTopology).

Lemma upper_closed_interval_closed: forall x:X,
  closed [y:X | R x y] (X:=OrderTopology).

Lemma order_topology_Hausdorff: Hausdorff OrderTopology.

End if_total_order.

End OrderTopology.

Arguments OrderTopology {X}. *)
Require Export Reals.

Definition RTop := OrderTopology Rle.

Require Export MetricSpaces.
(* MetricSpaces:
Require Export Reals.
Require Export TopologicalSpaces.
Require Export NeighborhoodBases.
Require Import RationalsInReals.
From ZornsLemma Require Export EnsemblesSpec.

Open Scope R_scope.

Section metric.

Variable X:Type.
Variable d:X->X->R.

Record metric : Prop := {
  metric_nonneg: forall x y:X, d x y >= 0;
  metric_sym: forall x y:X, d x y = d y x;
  triangle_inequality: forall x y z:X, d x z <= d x y + d y z;
  metric_zero: forall x:X, d x x = 0;
  metric_strict: forall x y:X, d x y = 0 -> x = y
}.

End metric.

Arguments metric {X}.

Section metric_topology.

Variable X:Type.
Variable d:X->X->R.
Hypothesis d_is_metric: metric d.

Definition open_ball (x0:X) (r:R) : Ensemble X :=
  [ x:X | d x0 x < r ].

Inductive metric_topology_neighborhood_basis (x:X) : Family X :=
  | intro_open_ball: forall r:R, r > 0 ->
    In (metric_topology_neighborhood_basis x) (open_ball x r).

Definition MetricTopology : TopologicalSpace.

End metric_topology.

Arguments metric_topology_neighborhood_basis {X}.
Arguments MetricTopology {X}.

Definition metrizes (X:TopologicalSpace)
  (d:point_set X -> point_set X -> R) : Prop :=
  forall x:point_set X, open_neighborhood_basis
             (metric_topology_neighborhood_basis d x) x.

Inductive metrizable (X:TopologicalSpace) : Prop :=
  | intro_metrizable: forall d:point_set X -> point_set X -> R,
    metric d -> metrizes X d ->
    metrizable X.

Lemma MetricTopology_metrizable: forall (X:Type) (d:X->X->R)
  (d_metric: metric d),
  metrizes (MetricTopology d d_metric) d.

Require Export Nets.

Lemma metric_space_net_limit: forall (X:TopologicalSpace)
  (d:point_set X -> point_set X -> R), metrizes X d ->
  forall (I:DirectedSet) (x:Net I X) (x0:point_set X),
  (forall eps:R, eps > 0 -> for large i:DS_set I, d x0 (x i) < eps) ->
  net_limit x x0.

Lemma metric_space_net_limit_converse: forall (X:TopologicalSpace)
  (d:point_set X -> point_set X -> R), metrizes X d ->
  forall (I:DirectedSet) (x:Net I X) (x0:point_set X),
    net_limit x x0 -> forall eps:R, eps > 0 ->
                         for large i:DS_set I, d x0 (x i) < eps.

Lemma metric_space_net_cluster_point: forall (X:TopologicalSpace)
  (d:point_set X -> point_set X -> R), metrizes X d ->
  forall (I:DirectedSet) (x:Net I X) (x0:point_set X),
  (forall eps:R, eps > 0 ->
     exists arbitrarily large i:DS_set I, d x0 (x i) < eps) ->
  net_cluster_point x x0.

Lemma metric_space_net_cluster_point_converse: forall (X:TopologicalSpace)
  (d:point_set X -> point_set X -> R), metrizes X d ->
  forall (I:DirectedSet) (x:Net I X) (x0:point_set X),
    net_cluster_point x x0 -> forall eps:R, eps > 0 ->
                exists arbitrarily large i:DS_set I, d x0 (x i) < eps.

Require Export Continuity.

Lemma metric_space_fun_continuity_converse: forall (X Y:TopologicalSpace)
  (f:point_set X->point_set Y) (x:point_set X)
  (dX:point_set X -> point_set X -> R)
  (dY:point_set Y -> point_set Y -> R),
  metrizes X dX -> metrizes Y dY ->
  continuous_at f x -> forall eps:R, eps > 0 ->
                         exists delta:R, delta > 0 /\
                         forall x':point_set X, dX x x' < delta ->
                                        dY (f x) (f x') < eps.

Lemma metric_space_fun_continuity: forall (X Y:TopologicalSpace)
  (f:point_set X->point_set Y) (x:point_set X)
  (dX:point_set X -> point_set X -> R)
  (dY:point_set Y -> point_set Y -> R),
  metrizes X dX -> metrizes Y dY ->
  (forall eps:R, eps > 0 -> exists delta:R, delta > 0 /\
                         forall x':point_set X, dX x x' < delta ->
                                        dY (f x) (f x') < eps) ->
  continuous_at f x.

Require Export CountabilityAxioms.

Lemma metrizable_impl_first_countable: forall X:TopologicalSpace,
  metrizable X -> first_countable X.

Lemma metrizable_separable_impl_second_countable:
  forall X:TopologicalSpace, metrizable X -> separable X ->
    second_countable X.
Proof.
intros.
destruct H.
destruct H0.
exists (Im [p:(Q*(point_set X))%type |
            let (r,x):=p in (r>0)%Q /\ In S x]
  (fun p:(Q*(point_set X))%type =>
      let (r,x):=p in open_ball _ d x (Q2R r))).
constructor.
intros.
destruct H3.
destruct H3.
destruct x as [r x].
destruct H3.
destruct (H1 x).
destruct (open_neighborhood_basis_elements y).
rewrite H4.
constructor; trivial.
assert (Q2R 0 = 0).
unfold Q2R.
simpl.
ring.
rewrite <- H6.
apply Qlt_Rlt; trivial.
assumption.

intros.
destruct (H1 x).
destruct (open_neighborhood_basis_cond U) as [V [[r]]].
split; trivial.

destruct (dense_meets_every_nonempty_open _ _ H2
  (open_ball _ d x (r/2))).
destruct (open_neighborhood_basis_elements
  (open_ball _ d x (r/2))).
constructor; trivial.
apply Rmult_lt_0_compat; auto with real.
destruct (open_neighborhood_basis_elements
  (open_ball (point_set X) d x (r/2))).
constructor; trivial.
apply Rmult_lt_0_compat; auto with real.
assumption.
exists x.
constructor.
rewrite metric_zero.
apply Rmult_lt_0_compat; auto with real.
trivial.

destruct H7.
destruct H8.

destruct (rationals_dense_in_reals (d x x0) (r - d x x0)) as [r'].
assert (d x x0 + d x x0 < r/2 + r/2).
auto with *.
assert (r/2 + r/2 = r).
field.
rewrite H10 in H9; clear H10.
assert ((d x x0 + d x x0) - d x x0 < r - d x x0).
unfold Rminus.
auto with *.
ring_simplify in H10.
ring_simplify.
assumption.

exists (open_ball _ d x0 (Q2R r')); repeat split.
exists ( (r', x0) ); auto.
constructor; split; trivial.
assert (Q2R r' > 0).
apply Rgt_ge_trans with (d x x0).
apply H9.
apply metric_nonneg; trivial.
apply Rlt_Qlt.
unfold Q2R at 1.
simpl.
ring_simplify.
assumption.

red; intros y ?.
destruct H10.
apply H6.
constructor.
apply Rle_lt_trans with (d x x0 + d x0 y).
apply triangle_inequality; trivial.
apply Rlt_trans with (d x x0 + Q2R r').
auto with *.
destruct H9.
assert (d x x0 + Q2R r' < d x x0 + (r - d x x0)).
auto with *.
ring_simplify in H12.
assumption.
destruct H9.
rewrite metric_sym; trivial.

apply countable_img.
destruct H0 as [h].

destruct (Q_countable).
destruct countable_nat_product as [g].

red.

match goal with |- CountableT ?T =>
exists (fun x:T =>
  match x with
  | exist (r, x0) (intro_characteristic_sat (conj r_pos i)) =>
    g (h (exist _ x0 i), f r)
  end)
end.
red; intros.
destruct x1 as [[r1 x1] [[pos_r1 i1]]].
destruct x2 as [[r2 x2] [[pos_r2 i2]]].
From ZornsLemma Require Import Proj1SigInjective.

Lemma metrizable_Lindelof_impl_second_countable:
  forall X:TopologicalSpace, metrizable X -> Lindelof X ->
    second_countable X.

Section dist_to_set.

Variable X:Type.
Variable d:X->X->R.
Hypothesis d_is_metric: metric d.
Variable S:Ensemble X.
Hypothesis S_nonempty: Inhabited S.

Require Export SupInf.

Definition dist_to_set (x:X) : R.

Lemma dist_to_set_triangle_inequality: forall (x y:X),
  dist_to_set y <= dist_to_set x + d x y.

End dist_to_set.

Arguments dist_to_set {X}.
Arguments dist_to_set_triangle_inequality {X}.

Section dist_to_set_and_topology.

Variable X:TopologicalSpace.
Variable d:point_set X -> point_set X -> R.
Hypothesis d_is_metric: metric d.
Hypothesis d_metrizes_X: metrizes X d.
Variable S:Ensemble (point_set X).
Hypothesis S_nonempty: Inhabited S.

Lemma dist_to_set_zero_impl_closure: forall x:point_set X,
  dist_to_set d d_is_metric S S_nonempty x = 0 -> In (closure S) x.

Lemma closure_impl_dist_to_set_zero: forall x:point_set X,
  In (closure S) x -> dist_to_set d d_is_metric S S_nonempty x = 0.

Variable T:Ensemble (point_set X).
Hypothesis T_nonempty: Inhabited T.

Lemma closer_to_S_than_T_open: open
  [x:point_set X | dist_to_set d d_is_metric S S_nonempty x <
                   dist_to_set d d_is_metric T T_nonempty x].

End dist_to_set_and_topology.

Require Export SeparatednessAxioms.

Lemma metrizable_impl_normal_sep: forall X:TopologicalSpace,
  metrizable X -> normal_sep X.
Proof.
intros.
destruct H.
split.
red; intros.
assert (closure (Singleton x) = Singleton x).
apply Extensionality_Ensembles; split.
red; intros.
assert (x0 = x).
apply metric_strict with d; trivial.
apply NNPP; intro.
assert (d x0 x > 0).
destruct (total_order_T (d x0 x) 0) as [[?|?]|?]; trivial.
assert (0 < 0).
apply Rle_lt_trans with (d x0 x); trivial.
assert (d x0 x >= 0); auto with *.
apply metric_nonneg; trivial.
contradict H3; apply Rlt_irrefl.
contradiction H2.

assert (In (interior (Complement (Singleton x))) x0).
exists (open_ball _ d x0 (d x0 x)).
split.
destruct (H0 x0).
destruct (open_neighborhood_basis_elements
  (open_ball (point_set X) d x0 (d x0 x))).
constructor; trivial.
split.
assumption.
red; intros.
intro.
destruct H7.
destruct H6.
revert H6; apply Rlt_irrefl.
constructor.
rewrite metric_zero; trivial.

rewrite interior_complement in H4.
contradiction H4.

rewrite H2; constructor.

apply closure_inflationary.

rewrite <- H1; apply closure_closed.

intros.
From ZornsLemma Require Import DecidableDec. *)

Definition R_metric (x y:R) : R := Rabs (y-x).

Lemma R_metric_is_metric: metric R_metric.
Proof.
constructor.
intros.
unfold R_metric.
pose proof (Rabs_pos (y-x)).
auto with *.

intros.
unfold R_metric.
replace (y-x) with (-(x-y)); try ring.
apply Rabs_Ropp.

intros.
unfold R_metric.
replace (z-x) with ((y-x) + (z-y)); try ring.
apply Rabs_triang.

intros.
unfold R_metric.
replace (x-x) with 0; try ring.
exact Rabs_R0.

intros.
assert (y-x=0).
apply NNPP.
contradict H.
apply Rabs_no_R0; assumption.
auto with *.
Qed.

Lemma Rmetric_bound: forall x y z:R, R_metric x z < y - x ->
  z < y.
Proof.
intros.
replace z with (x + (z-x)); try ring.
apply Rle_lt_trans with (x + R_metric x z).
assert (z - x <= R_metric x z).
apply Rle_abs.
auto with real.
replace y with (x + (y-x)); try ring.
auto with real.
Qed.

Lemma Rmetric_bound2: forall x y z:R, R_metric y z < y - x ->
  x < z.
Proof.
intros.
replace z with (y + (z-y)); try ring.
apply Rlt_le_trans with (y - R_metric y z).
apply Rlt_minus in H.
apply Rminus_lt.
replace (x - (y - R_metric y z)) with
  (R_metric y z - (y - x)); try ring.
trivial.
assert (y - z <= R_metric y z).
rewrite (metric_sym _ _ R_metric_is_metric y z).
apply Rle_abs.
apply Rle_minus in H0.
apply Rminus_le.
replace (y - R_metric y z - (y + (z - y))) with
  (y - z - R_metric y z); trivial; ring.
Qed.

Lemma RTop_metrization: metrizes RTop R_metric.
Proof.
refine (let Hsubbasis := Build_TopologicalSpace_from_subbasis_subbasis
  _ (order_topology_subbasis _ Rle) in _).
clearbody Hsubbasis.
red; intros.
constructor.
intros.
destruct H.
assert (open_ball (point_set RTop) R_metric x r = Intersection
  [ y:R | x-r <= y /\ y <> x-r ]
  [ y:R | y <= x+r /\ y <> x+r ]).
apply Extensionality_Ensembles; split; red; intros.
destruct H0.
assert (x - r < x0).
apply Rmetric_bound2 with x.
ring_simplify; trivial.
assert (x + r > x0).
apply Rmetric_bound with x.
ring_simplify; trivial.
repeat split; auto with real.
constructor.
destruct H0.
destruct H0.
destruct H0.
destruct H1.
destruct H1.
apply Rabs_def1.
assert (x0-x <= r).
apply Rminus_le.
apply Rle_minus in H1.
replace (x0 - x - r) with (x0 - (x + r)); trivial; ring.
assert (x0 - x <> r).
intro.
contradiction H3.
rewrite <- H5.
ring.
destruct (total_order_T (x0 - x) r) as [[|]|]; try tauto.
assert (r < r).
apply Rlt_le_trans with (x0 - x); trivial.
contradict H6.
apply Rlt_irrefl.
assert (-r <= x0 - x).
apply Rle_minus in H0.
apply Rminus_le.
replace (-r - (x0 - x)) with (x - r - x0); try ring; trivial.
assert (-r <> x0 - x).
intro.
contradiction H2.
replace r with (- -r); try ring.
rewrite H5; ring.
destruct (total_order_T (-r) (x0 - x)) as [[|]|]; try tauto.
assert (-r < -r).
apply Rle_lt_trans with (x0 - x); trivial.
contradict H6.
apply Rlt_irrefl.

rewrite H0.
constructor.
apply (@open_intersection2 RTop).
apply Hsubbasis; constructor.
apply Hsubbasis; constructor.
assert (x-r < x).
apply Rminus_lt.
ring_simplify.
auto with real.
assert (x+r > x).
apply Rminus_gt.
ring_simplify; trivial.
repeat split; auto with real.

intros.
destruct H.
destruct H.
destruct H0.
pose proof (H _ H0).
assert (exists eps:R, eps > 0 /\ Included (open_ball _ R_metric x eps) S).
clear H0.
induction H2.
exists 1.
split.
red.
auto with real.
intro; constructor.
destruct H0.
destruct H1.
destruct H0.
exists (x0-x).
split.
destruct (total_order_T x0 x) as [[]|].
assert (x < x).
apply Rle_lt_trans with x0; trivial.
contradict H2.
apply Rlt_irrefl.
congruence.
apply Rgt_minus; trivial.
red; intros y ?.
destruct H2.
constructor.
assert (y < x0).
apply Rmetric_bound with x; trivial.
split; auto with real.

destruct H1.
destruct H0.
exists (x - x0).
split.
destruct (total_order_T x0 x) as [[]|].
apply Rgt_minus; trivial.
congruence.
assert (x < x).
apply Rlt_le_trans with x0; trivial.
contradict H2.
apply Rlt_irrefl.
intros y ?.
destruct H2.
constructor.
assert (x0 < y).
apply Rmetric_bound2 with x; trivial.
split; auto with real.
destruct H1.
apply IHfinite_intersections in H1.
apply IHfinite_intersections0 in H3.
destruct H1 as [eps1 []].
destruct H3 as [eps2 []].
exists (Rmin eps1 eps2).
split.
unfold Rmin.
destruct Rle_dec; trivial.
red; intros y ?.
destruct H6.
constructor.
apply H4.
constructor.
apply Rlt_le_trans with (Rmin eps1 eps2); trivial.
unfold Rmin; destruct Rle_dec; auto with real.
apply H5.
constructor.
apply Rlt_le_trans with (Rmin eps1 eps2); trivial.
unfold Rmin; destruct Rle_dec; auto with real.

destruct H3 as [eps []].
exists (open_ball R R_metric x eps).
split.
constructor.
trivial.
assert (Included S (FamilyUnion F)).
intros y ?.
exists S; trivial.
auto with sets.
Qed.

Corollary RTop_metrizable: metrizable RTop.
Proof.
exists R_metric.
exact R_metric_is_metric.
exact RTop_metrization.
Qed.

Lemma RTop_separable: separable RTop.
Proof.
Require Import RationalsInReals.
(* RationalsInReals:
Require Export Reals.
Require Export QArith.
Require Export Qreals.

Open Scope R_scope.
Lemma inverses_of_nats_approach_0:
  forall eps:R, eps > 0 -> exists n:nat, (n > 0)%nat /\
                                         / (INR n) < eps.

Lemma Z_interpolation: forall x y:R, y > x+1 ->
  exists n:Z, x < IZR n < y.

Local Notation " ' x " := (Zpos x) (at level 20, no associativity) : Z_scope.

Lemma rational_interpolation: forall (x y:R) (n:positive),
  x<y -> IZR (' n) > 1/(y-x) ->
  exists m:Z, x < Q2R (m # n) < y.

Lemma rationals_dense_in_reals: forall x y:R, x<y ->
  exists q:Q, x < Q2R q < y. *)
exists (Im Full_set Q2R).
apply countable_img.
apply countable_type_ensemble.
exact Q_countable.

apply meets_every_nonempty_open_impl_dense.
intros.
destruct H0 as [x].
destruct (RTop_metrization x).
destruct (open_neighborhood_basis_cond U) as [V []].
split; trivial.
destruct H1.
destruct (rationals_dense_in_reals (x-r) (x+r)) as [q].
apply Rminus_gt.
replace (x+r-(x-r)) with (r+r); try ring.
apply Rgt_trans with r; auto with real.
pattern r at 3.
replace r with (r+0); try ring.
auto with real.

exists (Q2R q).
constructor.
exists q; trivial.
constructor.
apply H2.
constructor.
destruct H3.
apply Rabs_def1.
apply Rminus_lt.
apply Rlt_minus in H4.
replace (Q2R q - x - r) with (Q2R q - (x + r)); trivial; ring.
apply Rminus_lt.
apply Rlt_minus in H3.
replace (-r - (Q2R q - x)) with (x - r - Q2R q); trivial; ring.
Qed.

Require Export Compactness.
(* Compactness:
Require Export TopologicalSpaces.
Require Export Nets.
Require Export FilterLimits.
Require Export Continuity.

Set Asymmetric Patterns.

Definition compact (X:TopologicalSpace) :=
  forall C:Family (point_set X),
    (forall U:Ensemble (point_set X), In C U -> open U) ->
    FamilyUnion C = Full_set ->
    exists C':Family (point_set X),
      Finite _ C' /\ Included C' C /\
      FamilyUnion C' = Full_set.

Lemma compactness_on_indexed_covers:
  forall (X:TopologicalSpace) (A:Type) (C:IndexedFamily A (point_set X)),
    compact X ->
    (forall a:A, open (C a)) -> IndexedUnion C = Full_set ->
  exists A':Ensemble A, Finite _ A' /\
    IndexedUnion (fun a':{a':A | In A' a'} => C (proj1_sig a')) = Full_set.

Lemma compact_finite_nonempty_closed_intersection:
  forall X:TopologicalSpace, compact X ->
  forall F:Family (point_set X),
    (forall G:Ensemble (point_set X), In F G -> closed G) ->
    (forall F':Family (point_set X), Finite _ F' -> Included F' F ->
     Inhabited (FamilyIntersection F')) ->
    Inhabited (FamilyIntersection F).

Lemma finite_nonempty_closed_intersection_impl_compact:
  forall X:TopologicalSpace,
  (forall F:Family (point_set X),
    (forall G:Ensemble (point_set X), In F G -> closed G) ->
    (forall F':Family (point_set X), Finite _ F' -> Included F' F ->
     Inhabited (FamilyIntersection F')) ->
    Inhabited (FamilyIntersection F)) ->
  compact X.

Lemma compact_impl_filter_cluster_point:
  forall X:TopologicalSpace, compact X ->
    forall F:Filter (point_set X), exists x0:point_set X,
    filter_cluster_point F x0.

Lemma filter_cluster_point_impl_compact:
  forall X:TopologicalSpace,
    (forall F:Filter (point_set X), exists x0:point_set X,
      filter_cluster_point F x0) -> compact X.

Lemma ultrafilter_limit_impl_compact:
  forall X:TopologicalSpace,
    (forall U:Filter (point_set X), ultrafilter U ->
      exists x0:point_set X, filter_limit U x0) -> compact X.

Lemma compact_impl_net_cluster_point:
  forall X:TopologicalSpace, compact X ->
    forall (I:DirectedSet) (x:Net I X), inhabited (DS_set I) ->
    exists x0:point_set X, net_cluster_point x x0.

Lemma net_cluster_point_impl_compact: forall X:TopologicalSpace,
  (forall (I:DirectedSet) (x:Net I X), inhabited (DS_set I) ->
    exists x0:point_set X, net_cluster_point x x0) ->
  compact X.

Require Export SeparatednessAxioms.
Require Export SubspaceTopology.

Lemma compact_closed: forall (X:TopologicalSpace)
  (S:Ensemble (point_set X)), Hausdorff X ->
  compact (SubspaceTopology S) -> closed S.

Lemma closed_compact: forall (X:TopologicalSpace) (S:Ensemble (point_set X)),
  compact X -> closed S -> compact (SubspaceTopology S).

Lemma compact_image: forall {X Y:TopologicalSpace}
  (f:point_set X->point_set Y),
  compact X -> continuous f -> surjective f -> compact Y.

Lemma compact_Hausdorff_impl_normal_sep: forall X:TopologicalSpace,
  compact X -> Hausdorff X -> normal_sep X. *)

Lemma bounded_real_net_has_cluster_point: forall (I:DirectedSet)
  (x:Net I RTop) (a b:R), (forall i:DS_set I, a <= x i <= b) ->
  exists x0:point_set RTop, net_cluster_point x x0.
Proof.

intros.
destruct (classic (inhabited (DS_set I))) as [Hinh|Hempty].
assert (forall i:DS_set I, { y:R | is_glb
                             (Im [ j:DS_set I | DS_ord i j ] x) y }).
intro.
apply inf.
exists a.
red; intros.
destruct H0.
destruct (H x0).
rewrite H1.
auto with real.
exists (x i).
exists i; trivial.
constructor.
apply preord_refl.
apply DS_ord_cond.

assert ({ x0:R | is_lub (Im Full_set (fun i:DS_set I => proj1_sig (X i)))
                        x0 }).
apply sup.
exists b.
red; intros.
destruct H0 as [i].
destruct (X i).
simpl in H1.
rewrite H1.
destruct i0.
cut (b >= x0).
auto with real.
apply Rge_trans with (x i).
destruct (H i).
auto with real.
apply H2.
exists i; trivial.
constructor.
apply preord_refl.
apply DS_ord_cond.

destruct Hinh as [i0].
exists (proj1_sig (X i0)).
exists i0; trivial.
constructor.

destruct H0 as [x0].
exists x0.
assert (forall i j:DS_set I, DS_ord i j ->
  proj1_sig (X i) <= proj1_sig (X j)).
intros.
destruct (X i0).
destruct (X j).
simpl.
destruct i1.
destruct i2.
apply H4.
red; intros.
destruct H5.
destruct H5.
apply H1.
exists x3; trivial.
constructor.
apply preord_trans with j; trivial.
apply DS_ord_cond.

red; intros.
destruct (RTop_metrization x0).
destruct (open_neighborhood_basis_cond U).
split; trivial.
destruct H3.
destruct H3.
destruct (lub_approx _ _ r i).
trivial.
destruct H5.
destruct H5.
destruct H6.
red; intros.
destruct (DS_join_cond x1 i0).
destruct H9.
remember (X x2) as y2.
destruct y2.
destruct (glb_approx _ _ r i1).
trivial.
destruct H11.
destruct H11.
destruct H11.
destruct H12.
exists x4.
split.
apply preord_trans with x2; trivial.
apply DS_ord_cond.
apply H4.
constructor.
assert (y <= proj1_sig (X x2)).
rewrite H7.
apply H0; trivial.
rewrite <- Heqy2 in H15.
simpl in H15.
assert (proj1_sig (X x2) <= x0).
apply i.
exists x2; trivial.
constructor.
rewrite <- Heqy2 in H16.
simpl in H16.
rewrite <- H13.
apply Rabs_def1.

cut (y0 < x0 + r).
intro.
apply Rlt_minus in H17.
apply Rminus_lt.
replace (y0 - x0 - r) with (y0-(x0+r)); trivial; ring.
apply Rlt_le_trans with (x3 + r).
trivial.
auto with real.

cut (y0 > x0 - r).
intro.
apply Rlt_minus in H17.
apply Rminus_lt.
replace (-r - (y0-x0)) with (x0-r-y0); trivial; ring.
apply Rge_gt_trans with y.
apply Rge_trans with x3; auto with real.
trivial.

exists a.
red; intros.
red; intros.
contradiction Hempty.
exists; exact i.
Qed.

Lemma R_closed_interval_compact: forall a b:R, a <= b ->
  compact (SubspaceTopology ([x:point_set RTop | a <= x <= b])).
Proof.
intros a b Hbound.
apply net_cluster_point_impl_compact.
intros.
pose (y := fun i:DS_set I => proj1_sig (x i)).
destruct (bounded_real_net_has_cluster_point _ y a b).
intros.
unfold y.
destruct (x i).
destruct i0.
simpl.
trivial.

assert (closed [x:point_set RTop | a <= x <= b]).
assert ([x:point_set RTop | a <= x <= b] = Intersection
                [ x:point_set RTop | a <= x ]
                [ x:point_set RTop | x <= b ]).
apply Extensionality_Ensembles; split; red; intros.
destruct H1.
destruct H1.
constructor; constructor; trivial.
destruct H1.
destruct H1.
destruct H2.
constructor.
auto.
rewrite H1.
apply closed_intersection2.
apply upper_closed_interval_closed.
constructor; red; intros; auto with real.
apply Rle_trans with y0; trivial.
intros.
destruct (total_order_T x1 y0) as [[|]|]; auto with real.
apply lower_closed_interval_closed.
constructor; red; intros; auto with real.
apply Rle_trans with y0; trivial.
intros.
destruct (total_order_T x1 y0) as [[|]|]; auto with real.

assert (Ensembles.In [x:point_set RTop | a <= x <= b] x0).
rewrite <- (closure_fixes_closed _ H1).
apply net_cluster_point_in_closure with y.
destruct H as [i0].
exists i0.
intros.
constructor.
unfold y.
destruct (x j).
simpl.
destruct i.
trivial.
trivial.

exists (exist _ x0 H2).
red; intros.
destruct (subspace_topology_topology _ _ _ H3) as [V].
destruct H5.
red; intros.
assert (Ensembles.In V x0).
rewrite H6 in H4.
destruct H4.
simpl in H4.
trivial.

destruct (H0 V H5 H7 i) as [j []].
exists j.
split; trivial.
rewrite H6.
constructor.
simpl.
exact H9.
Qed.

Lemma R_compact_subset_bounded: forall A:Ensemble (point_set RTop),
  compact (SubspaceTopology A) -> bound A.
Proof.
intros.
destruct (H (Im Full_set (fun y:R => inverse_image (subspace_inc _)
                   [ x:point_set RTop | y - 1 < x < y + 1 ]))).
intros.
destruct H0.
rewrite H1.
apply subspace_inc_continuous.
replace [x0:point_set RTop | x-1 < x0 < x+1] with
  (Intersection [x0:point_set RTop | x-1 <= x0 /\ x0 <> x-1]
                [x0:point_set RTop | x0 <= x+1 /\ x0 <> x+1]).
pose proof (Build_TopologicalSpace_from_subbasis_subbasis
  _ (order_topology_subbasis _ Rle)).
apply open_intersection2.
apply H2.
constructor.
apply H2.
constructor.
apply Extensionality_Ensembles; split; red; intros.
destruct H2.
destruct H2.
destruct H2.
destruct H3.
destruct H3.
constructor.
split.
destruct (total_order_T (x-1) x0) as [[|]|]; auto with real.
contradiction H4; symmetry; trivial.
assert (x0 < x0).
apply Rlt_le_trans with (x-1); auto with real.
contradict H6; apply Rlt_irrefl.
destruct (total_order_T x0 (x+1)) as [[|]|]; auto with real.
contradiction H5.
assert (x0 < x0).
apply Rle_lt_trans with (x+1); auto with real.
contradict H6; apply Rlt_irrefl.
destruct H2.
destruct H2.
constructor; constructor; split; auto with real.

apply Extensionality_Ensembles; split; red; intros.
constructor.
eexists.
exists (proj1_sig x).
constructor.
reflexivity.
constructor.
constructor.
destruct x.
simpl.
split; apply Rminus_lt; auto with real.
replace (x-1-x) with (-1); try ring.
apply Ropp_lt_gt_0_contravar.
exact Rlt_0_1.

destruct H0.
destruct H1.
assert (exists a:R, forall S:Ensemble (point_set (SubspaceTopology A)),
  forall b:point_set (SubspaceTopology A),
  Ensembles.In x S -> Ensembles.In S b -> proj1_sig b < a).
clear H2.
induction H0.
exists 0.
intros.
destruct H0.
destruct IHFinite.
cut (Included A0 (Add A0 x)); auto with sets.
assert (Ensembles.In (Add A0 x) x).
right.
constructor.
apply H1 in H4.
destruct H4.
exists (Rmax x0 (x+1)).
intros.
destruct H6.
apply Rlt_le_trans with x0.
apply H3 with x1; trivial.
unfold Rmax.
destruct Rle_dec; auto with real.
destruct H6.
rewrite H5 in H7.
destruct H7.
destruct H6.
apply Rlt_le_trans with (x+1).
apply H6.
unfold Rmax; destruct Rle_dec; auto with real.

destruct H3 as [a].
exists a.
red; intros.
assert (Ensembles.In (FamilyUnion x)
  (exist (fun x:R => Ensembles.In A x) x0 H4)).
rewrite H2; constructor.
inversion H5.
pose proof (H3 _ _ H6 H7).
simpl in H9.
auto with real.
Qed.

Lemma Ropp_continuous: continuous Ropp (X:=RTop) (Y:=RTop).
Proof.
apply pointwise_continuity.
intro.
apply metric_space_fun_continuity with R_metric R_metric;
  try apply RTop_metrization.
intros.
exists eps.
split; trivial.
intros.
unfold R_metric.
replace (-x' - -x) with (x-x'); try ring.
rewrite Rabs_minus_sym; trivial.
Qed.

Require Export Connectedness.
(* Connectedness:
Require Export TopologicalSpaces.

Definition clopen {X:TopologicalSpace} (S:Ensemble (point_set X))
  : Prop :=
  open S /\ closed S.

Definition connected (X:TopologicalSpace) : Prop :=
  forall S:Ensemble (point_set X), clopen S ->
        S = Empty_set \/ S = Full_set.

Require Export Continuity.

Lemma connected_img: forall {X Y:TopologicalSpace}
  (f:point_set X -> point_set Y),
  connected X -> continuous f -> surjective f -> connected Y.

Require Export SubspaceTopology.

Lemma connected_union: forall {X:TopologicalSpace}
  {A:Type} (S:IndexedFamily A (point_set X)),
  (forall a:A, connected (SubspaceTopology (S a))) ->
  Inhabited (IndexedIntersection S) ->
  IndexedUnion S = Full_set -> connected X. *)

Lemma R_connected: connected RTop.
Proof.
cut (forall S:Ensemble (point_set RTop),
  clopen S -> Ensembles.In S 0 -> S = Full_set).
intro.
red; intros.
destruct (classic (Ensembles.In S 0)).
right.
apply H; trivial.
left.
assert (Complement S = Full_set).
apply H; trivial.
destruct H0; split; trivial.
red; rewrite Complement_Complement; trivial.
apply Extensionality_Ensembles; split; red; intros.
assert (Ensembles.In (Complement S) x).
rewrite H2; constructor.
contradiction H4.
destruct H3.

cut (forall S:Ensemble (point_set RTop),
  clopen S -> Ensembles.In S 0 -> forall x:R, x > 0 ->
                                  Ensembles.In S x).
intro.
assert (forall S:Ensemble (point_set RTop),
  clopen S -> Ensembles.In S 0 -> forall x:R, x < 0 ->
                                  Ensembles.In S x).
intros.
pose (T := inverse_image Ropp S).

assert (Ensembles.In T (-x)).
apply H.
destruct H0; split.
apply Ropp_continuous; trivial.
red.
subst T.
rewrite <- inverse_image_complement.
apply Ropp_continuous; trivial.
constructor.
replace (-0) with 0; trivial; ring.
cut (0 < -x); auto with real.
destruct H3.
rewrite Ropp_involutive in H3; trivial.

intros.
apply Extensionality_Ensembles; split; red; intros.
constructor.
destruct (total_order_T x 0) as [[|]|].
apply H0; trivial.
congruence.
apply H; trivial.

intros.
apply NNPP; intro.
pose (T := [ y:R | forall z:R, 0 <= z <= y -> Ensembles.In S z ]).
assert (Ensembles.In T 0).
constructor.
intros.
assert (z = 0).
destruct H3; auto with real.
rewrite H4; trivial.

destruct (sup T).
exists x.
red; intros.
cut (~ x0>x).
apply Rnot_lt_le; auto with real.
intro.
destruct H4.
apply H2.
apply H4.
split; auto with real.
exists 0.
exact H3.

assert (0 <= x0).
apply i.
exact H3.

destruct (RTop_metrization x0).
assert (Ensembles.In S x0).
rewrite <- (closure_fixes_closed S); try apply H.
apply meets_every_open_neighborhood_impl_closure.
intros.
destruct (open_neighborhood_basis_cond U).
split; trivial.
destruct H7.
destruct H7.
destruct (lub_approx _ _ r i).
trivial.
destruct H9.
exists (Rmax x1 0).
constructor.
unfold Rmax.
destruct Rle_dec.
trivial.
apply H9.
auto with real.

apply H8.
constructor.
unfold Rmax.
destruct Rle_dec.
unfold R_metric.
rewrite Rabs_minus_sym.
replace (x0-0) with x0; try ring.
apply Rabs_def1.
apply Rminus_lt.
destruct H10.
apply Rlt_le_trans with x1; trivial.
apply Rlt_le_trans with 0; auto with real.

apply Rabs_def1.
apply Rle_lt_trans with 0; auto with real.
destruct H10.
apply Rle_minus; trivial.
destruct H10.
apply Rminus_lt.
apply Rlt_minus in H10.
replace (-r - (x1-x0)) with (x0-r-x1); trivial; ring.

destruct (open_neighborhood_basis_cond S).
split; trivial.
apply H.
destruct H6.
destruct H6.

destruct (lub_approx _ _ r i).
trivial.
destruct H8.

assert (Ensembles.In T (x0+r/2)).
constructor.
intros.
destruct H10.
destruct (total_order_T z x1) as [[|]|].
apply H8.
split; auto with real.
apply H8.
split; auto with real.
apply H7.
constructor.
apply Rabs_def1.
apply Rle_lt_trans with (r/2).
apply Rminus_le.
apply Rle_minus in H11.
replace (z-x0-r/2) with (z-(x0+r/2)); trivial; ring.
apply Rminus_gt.
replace (r-r/2) with (r/2); try field.
apply Rmult_gt_0_compat; auto with real.
auto with *.
apply Rlt_trans with (x1 - x0).
destruct H9.
apply Rlt_minus in H9.
apply Rminus_lt.
replace (-r - (x1-x0)) with (x0-r-x1); trivial; ring.
cut (x1<z); trivial.
intro.
unfold Rminus.
auto with real.

assert (x0 + r/2 <= x0).
apply i.
exact H10.

absurd (x0 + r/2 > x0).
apply Rge_not_gt; auto with real.
apply Rminus_gt.
ring_simplify.
apply Rmult_gt_0_compat; auto with real.
apply Rinv_0_lt_compat.
auto with real.
Qed.

Require Export Completeness.
(* Completeness:
Require Export MetricSpaces.

Section Completeness.

Variable X:Type.
Variable d:X->X->R.
Hypothesis d_metric: metric d.

Definition cauchy (x:nat->X) : Prop :=
  forall eps:R, eps > 0 -> exists N:nat, forall m n:nat,
    (m >= N)%nat -> (n >= N)%nat -> d (x m) (x n) < eps.

Lemma convergent_sequence_is_cauchy:
  forall (x:Net nat_DS (MetricTopology d d_metric))
    (x0:point_set (MetricTopology d d_metric)),
  net_limit x x0 -> cauchy x.

Lemma cauchy_sequence_with_cluster_point_converges:
  forall (x:Net nat_DS (MetricTopology d d_metric))
    (x0:point_set (MetricTopology d d_metric)),
  cauchy x -> net_cluster_point x x0 -> net_limit x x0.

Definition complete : Prop :=
  forall x:nat->X, cauchy x ->
    exists x0:X, net_limit x x0 (I:=nat_DS)
      (X:=MetricTopology d d_metric).

End Completeness.

Arguments cauchy {X}.
Arguments complete {X}.

Section closed_subset_of_complete.

Variable X:Type.
Variable d:X->X->R.
Hypothesis d_metric:metric d.
Variable F:Ensemble X.

Let FT := { x:X | In F x }.
Let d_restriction := fun x y:FT => d (proj1_sig x) (proj1_sig y).

Lemma d_restriction_metric: metric d_restriction.
Proof.
From ZornsLemma Require Import Proj1SigInjective.

Lemma closed_subset_of_complete_is_complete:
  complete d d_metric ->
  closed F (X:=MetricTopology d d_metric) ->
  complete d_restriction d_restriction_metric.

Lemma complete_subset_is_closed:
  complete d_restriction d_restriction_metric ->
  closed F (X:=MetricTopology d d_metric).

End closed_subset_of_complete. *)

Lemma R_cauchy_sequence_bounded: forall x:nat->R,
  cauchy R_metric x -> bound (Im Full_set x).
Proof.
intros.
destruct (H 1) as [N].
red; auto with real.
assert (exists y:R, forall n:nat, (n<N)%nat -> x n <= y).
clear H0; induction N.
exists 0.
intros.
contradict H0.
auto with arith.
destruct IHN as [y].
exists (Rmax y (x N)).
intros.
apply lt_n_Sm_le in H1.
destruct (le_lt_or_eq _ _ H1).
apply Rle_trans with y.
apply H0; trivial.
apply Rmax_l.
rewrite H2.
apply Rmax_r.

destruct H1 as [y].
exists (Rmax y (x N + 1)).
red; intros.
destruct H2 as [n].
rewrite H3; clear y0 H3.
destruct (le_or_lt N n).
apply Rle_trans with (x N + 1).
assert (R_metric (x n) (x N) < 1).
apply H0; auto with arith.
apply Rabs_def2 in H4.
destruct H4.
Require Import Fourier.
fourier.
apply Rmax_r.
apply Rle_trans with y; auto.
apply Rmax_l.
Qed.

Lemma R_cauchy_sequence_lower_bound: forall x:nat->R,
  cauchy R_metric x -> lower_bound (Im Full_set x).
Proof.
intros.
assert (cauchy R_metric (fun n:nat => - x n)).
red; intros.
destruct (H eps H0) as [N].
exists N.
intros.
replace (R_metric (- x m) (- x n)) with (R_metric (x m) (x n)).
apply H1; trivial.
unfold R_metric.
replace (x n - x m) with (- (- x n - - x m)) by ring.
apply Rabs_Ropp.
destruct (R_cauchy_sequence_bounded _ H0) as [m].
exists (-m).
red; intros.
cut (-x0 <= m).
intros; fourier.
apply H1.
destruct H2 as [n].
exists n; trivial.
f_equal; trivial.
Qed.

Lemma R_metric_complete: complete R_metric R_metric_is_metric.
Proof.
red; intros.
destruct (R_cauchy_sequence_bounded _ H) as [b].
destruct (R_cauchy_sequence_lower_bound _ H) as [a].
destruct (bounded_real_net_has_cluster_point nat_DS x a b) as [x0].
intros; split; [ cut (x i >= a); auto with real; apply H1 | apply H0 ];
  exists i; trivial; constructor.
exists x0.
apply cauchy_sequence_with_cluster_point_converges; trivial.
apply metric_space_net_cluster_point with R_metric;
  try apply MetricTopology_metrizable.
intros.
apply metric_space_net_cluster_point_converse with RTop; trivial.
apply RTop_metrization.
Qed.
