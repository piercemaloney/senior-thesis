Require Export Completeness.
(* Completeness:
Require Export MetricSpaces.

Section Completeness.

Variable X:Type.
Variable d:X->X->R.
Hypothesis d_metric: metric d.

Definition cauchy (x:nat->X) : Prop :=
  forall eps:R, eps > 0 -> exists N:nat, forall m n:nat,
    (m >= N)%nat -> (n >= N)%nat -> d (x m) (x n) < eps.

Lemma convergent_sequence_is_cauchy:
  forall (x:Net nat_DS (MetricTopology d d_metric))
    (x0:point_set (MetricTopology d d_metric)),
  net_limit x x0 -> cauchy x.

Lemma cauchy_sequence_with_cluster_point_converges:
  forall (x:Net nat_DS (MetricTopology d d_metric))
    (x0:point_set (MetricTopology d d_metric)),
  cauchy x -> net_cluster_point x x0 -> net_limit x x0.

Definition complete : Prop :=
  forall x:nat->X, cauchy x ->
    exists x0:X, net_limit x x0 (I:=nat_DS)
      (X:=MetricTopology d d_metric).

End Completeness.

Arguments cauchy {X}.
Arguments complete {X}.

Section closed_subset_of_complete.

Variable X:Type.
Variable d:X->X->R.
Hypothesis d_metric:metric d.
Variable F:Ensemble X.

Let FT := { x:X | In F x }.
Let d_restriction := fun x y:FT => d (proj1_sig x) (proj1_sig y).

Lemma d_restriction_metric: metric d_restriction.
Proof.
From ZornsLemma Require Import Proj1SigInjective.

Lemma closed_subset_of_complete_is_complete:
  complete d d_metric ->
  closed F (X:=MetricTopology d d_metric) ->
  complete d_restriction d_restriction_metric.

Lemma complete_subset_is_closed:
  complete d_restriction d_restriction_metric ->
  closed F (X:=MetricTopology d d_metric).

End closed_subset_of_complete. *)
Require Import UniformTopology.
(* UniformTopology:
Require Export MetricSpaces.

Section UniformTopology.

Variable X Y:Type.
Variable d:Y->Y->R.
Variable y0:X->Y. 
Hypothesis d_metric: metric d.
Hypothesis X_inhabited: inhabited X.

Definition uniform_space := { f:X->Y | bound (Im Full_set
                                      (fun x:X => d (y0 x) (f x))) }.

Definition uniform_metric (f g:uniform_space) : R.

Lemma uniform_metric_is_metric: metric uniform_metric.
Proof.
constructor; intros.
unfold uniform_metric.
destruct x as [f0 Hf]; destruct y as [g0 Hg]; destruct sup.
simpl.
destruct X_inhabited as [x0].
apply Rge_trans with (d (f0 x0) (g0 x0)).
cut (d (f0 x0) (g0 x0) <= x); auto with real.
apply i.
exists x0; trivial.
constructor.
apply d_metric.
unfold uniform_metric.
destruct x as [f0 Hf]; destruct y as [g0 Hg].
destruct sup.
destruct sup.
simpl.
assert (Im Full_set (fun x:X => d (f0 x) (g0 x)) =
        Im Full_set (fun x:X => d (g0 x) (f0 x))).
apply Extensionality_Ensembles; split; red; intros.
destruct H.
exists x1.
constructor.
rewrite metric_sym; trivial.
destruct H.
exists x1.
constructor.
rewrite metric_sym; trivial.
apply Rle_antisym.
apply i.
rewrite H.
apply i0.
apply i0.
rewrite <- H.
apply i.

destruct x as [f0 Hf]; destruct y as [g0 Hg]; destruct z as [h0 Hh].
simpl.
repeat destruct sup; simpl.
apply i.
red; intros.
destruct H.
rewrite H0.
apply Rle_trans with (d (f0 x2) (g0 x2) + d (g0 x2) (h0 x2)).
apply d_metric.
assert (d (f0 x2) (g0 x2) <= x0) by
  (apply i0; exists x2; trivial).
assert (d (g0 x2) (h0 x2) <= x1) by
  (apply i1; exists x2; trivial).
auto with real.

destruct x as [f0 Hf].
simpl.
destruct sup; simpl.
apply Rle_antisym.
apply i.
red; intros.
destruct H.
rewrite metric_zero in H0; trivial.
right; trivial.
apply i.
destruct X_inhabited as [x0].
exists x0.
constructor.
symmetry; apply d_metric.

destruct x as [f0 Hf]; destruct y as [g0 Hg].
From ZornsLemma Require Import Proj1SigInjective.

Definition UniformTopology : TopologicalSpace :=
  MetricTopology uniform_metric uniform_metric_is_metric.

Require Export Completeness.

Lemma uniform_metric_complete: complete d d_metric ->
  complete uniform_metric uniform_metric_is_metric.

End UniformTopology.

Arguments uniform_space {X} {Y}.
Arguments uniform_metric {X} {Y}.
Arguments UniformTopology {X} {Y}.

Section UniformTopology_and_continuity.

Variable X:TopologicalSpace.
Variable Y:Type.
Variable d:Y->Y->R.
Variable y0:point_set X -> Y.
Hypothesis d_metric: metric d.
Hypothesis X_inh: inhabited (point_set X).

Lemma continuous_functions_at_point_closed_in_uniform_metric:
  forall x0:point_set X,
  closed (fun f:uniform_space d y0 => continuous_at (proj1_sig f) x0
                                      (Y:=MetricTopology d d_metric))
    (X:=UniformTopology d y0 d_metric X_inh).

Lemma continuous_functions_closed_in_uniform_metric:
  closed (fun f:uniform_space d y0 => continuous (proj1_sig f)
                                      (Y:=MetricTopology d d_metric))
    (X:=UniformTopology d y0 d_metric X_inh).

End UniformTopology_and_continuity. *)
Require Import RTopology.
(* RTopology:
Require Export TopologicalSpaces.
Require Export OrderTopology.
Require Export Reals.

Definition RTop := OrderTopology Rle.

Require Export MetricSpaces.

Definition R_metric (x y:R) : R := Rabs (y-x).

Lemma R_metric_is_metric: metric R_metric.

Lemma Rmetric_bound: forall x y z:R, R_metric x z < y - x ->
  z < y.

Lemma Rmetric_bound2: forall x y z:R, R_metric y z < y - x ->
  x < z.

Lemma RTop_metrization: metrizes RTop R_metric.

Corollary RTop_metrizable: metrizable RTop.

Lemma RTop_separable: separable RTop.

Require Export Compactness.

Lemma bounded_real_net_has_cluster_point: forall (I:DirectedSet)
  (x:Net I RTop) (a b:R), (forall i:DS_set I, a <= x i <= b) ->
  exists x0:point_set RTop, net_cluster_point x x0.

Lemma R_closed_interval_compact: forall a b:R, a <= b ->
  compact (SubspaceTopology ([x:point_set RTop | a <= x <= b])).

Lemma R_compact_subset_bounded: forall A:Ensemble (point_set RTop),
  compact (SubspaceTopology A) -> bound A.

Lemma Ropp_continuous: continuous Ropp (X:=RTop) (Y:=RTop).

Require Export Connectedness.

Lemma R_connected: connected RTop.

Require Export Completeness.

Lemma R_cauchy_sequence_bounded: forall x:nat->R,
  cauchy R_metric x -> bound (Im Full_set x).

Lemma R_cauchy_sequence_lower_bound: forall x:nat->R,
  cauchy R_metric x -> lower_bound (Im Full_set x).

Lemma R_metric_complete: complete R_metric R_metric_is_metric. *)

Lemma completion_exists: forall (X:Type) (d:X->X->R) (d_metric:metric d),
  exists Y:Type, exists i:X->Y, exists d':Y->Y->R,
  exists d'_metric:metric d',
  injective i /\ dense (Im Full_set i) (X:=MetricTopology d' d'_metric) /\
  (forall x1 x2:X, d' (i x1) (i x2) = d x1 x2) /\
  complete d' d'_metric.
Proof.
intros.

cut (exists Y:Type, exists i:X->Y, exists d':Y->Y->R,
  exists d'_metric:metric d', injective i /\
  (forall x1 x2:X, d' (i x1) (i x2) = d x1 x2) /\
  complete d' d'_metric).
intros.
destruct H as [Y [i [d' [d'_metric [? []]]]]].
pose (F := closure (Im Full_set i) (X:=MetricTopology d' d'_metric)).
exists {y:Y | In F y}.
assert (forall x:X, In F (i x)).
intros.
apply closure_inflationary.
exists x; trivial.
constructor.
exists (fun x:X => exist _ (i x) (H2 x)).
exists (fun y1 y2 => d' (proj1_sig y1) (proj1_sig y2)).
assert (d'_metric0 : metric (fun (y1 y2:{y:Y | In F y}) =>
                       d' (proj1_sig y1) (proj1_sig y2))).
constructor; try destruct x; try destruct y; try destruct z; simpl;
  try apply d'_metric.
intros.
From ZornsLemma Require Import Proj1SigInjective.
apply subset_eq_compatT.
apply d'_metric; trivial.
exists d'_metric0.
repeat split.
red; intros.
injection H3; intros.
apply H; trivial.
red.
apply Extensionality_Ensembles; split; red; intros.
constructor.
simpl in x.
destruct x.
clear H3.
generalize i0.
apply first_countable_sequence_closure in i0.
destruct i0.
destruct H3.
assert (forall n:nat, { x:X | x0 n = i x }).
intros.
Require Import Description.
apply constructive_definite_description.
apply -> unique_existence.
split.
destruct (H3 n).
exists x1; trivial.
red; intros.
apply H.
rewrite H5 in H6; trivial.
assert (forall n:nat, In F (i (proj1_sig (X0 n)))).
intros; apply H2.
intros.
apply (@net_limit_in_closure nat_DS
  (MetricTopology _ d'_metric0)
  _ (fun n:nat => exist _ (i (proj1_sig (X0 n))) (H5 n))).
red; intros.
exists i1.
split.
simpl; auto with arith.
exists (proj1_sig (X0 i1)).
constructor.
apply subset_eq_compatT.
reflexivity.
pose proof (metric_space_net_limit_converse (MetricTopology d' d'_metric) d'
  (MetricTopology_metrizable _ d' d'_metric) nat_DS x0 x H4).
apply metric_space_net_limit with (1:=MetricTopology_metrizable _ _ d'_metric0).

intros.
destruct (H6 eps H7).
exists x1.
intros.
simpl.
destruct (X0 j).
simpl.
rewrite <- e.
apply H8; trivial.
apply metrizable_impl_first_countable.
exists d'; trivial.
apply MetricTopology_metrizable.

intros.
simpl.
apply H0.
apply (closed_subset_of_complete_is_complete Y d' d'_metric F);
  trivial.
apply closure_closed.

destruct (classic (inhabited X)).
destruct H as [x0].

assert (forall x y z:X, R_metric (d x z) (d y z) <= d x y).
unfold R_metric.
assert (forall a b:R, -b <= a -> a <= b -> Rabs a <= b).
intros.
unfold Rabs.
Require Import Fourier.
destruct Rcase_abs; fourier.
intros.
apply H.
assert (d x z <= d x y + d y z) by apply d_metric.
fourier.
rewrite (metric_sym _ _ d_metric x y).
assert (d y z <= d y x + d x z) by apply d_metric.
fourier.

exists (uniform_space R_metric (d x0)).
unshelve refine (let H0:=_ in ex_intro _ (fun x:X => exist _ (d x) (H0 x)) _).
intros.
exists (d x0 x).
red; intros.
destruct H0.
rewrite H1; trivial.
exists (uniform_metric R_metric (d x0) R_metric_is_metric
  (inhabits x0)).
exists (uniform_metric_is_metric _ _ _ _ _ _).
repeat split.
red; intros.
injection H1; intros.
apply d_metric.
rewrite H2; apply d_metric.

intros.
unfold uniform_metric; destruct sup; simpl.
apply Rle_antisym.
apply i.
red; intros.
destruct H1.
rewrite H2; apply H.
apply i.
exists x1.
constructor.
rewrite metric_zero; trivial.
unfold R_metric.
rewrite (metric_sym _ _ d_metric x2 x1).
rewrite Rminus_0_r.
symmetry; apply Rabs_right; apply d_metric.

apply uniform_metric_complete.
exact R_metric_complete.

exists False.
exists (fun x:X => H (inhabits x)).
exists (False_rect _).
assert (metric (False_rect (False->R))).
constructor; intros; destruct x.
exists H0.
repeat split.
red; intros.
contradiction (H (inhabits x1)).
intros.
contradiction (H (inhabits x1)).
red; intros.
contradiction (x O).
Qed.
