Require Export TopologicalSpaces.
(* TopologicalSpaces:
Require Export Ensembles.
From ZornsLemma Require Import EnsemblesImplicit.
From ZornsLemma Require Export Families.
From ZornsLemma Require Export IndexedFamilies.
From ZornsLemma Require Export FiniteTypes.
From ZornsLemma Require Import EnsemblesSpec.

Record TopologicalSpace : Type := {
  point_set : Type;
  open : Ensemble point_set -> Prop;
  open_family_union : forall F : Family point_set,
    (forall S : Ensemble point_set, In F S -> open S) ->
    open (FamilyUnion F);
  open_intersection2: forall U V:Ensemble point_set,
    open U -> open V -> open (Intersection U V);
  open_full : open Full_set
}.

Arguments open {t}.
Arguments open_family_union {t}.
Arguments open_intersection2 {t}.

Lemma open_empty: forall X:TopologicalSpace,
  open (@Empty_set (point_set X)).

Lemma open_union2: forall {X:TopologicalSpace}
  (U V:Ensemble (point_set X)), open U -> open V -> open (Union U V).

Lemma open_indexed_union: forall {X:TopologicalSpace} {A:Type}
  (F:IndexedFamily A (point_set X)),
  (forall a:A, open (F a)) -> open (IndexedUnion F).

Lemma open_finite_indexed_intersection:
  forall {X:TopologicalSpace} {A:Type}
    (F:IndexedFamily A (point_set X)),
    FiniteT A -> (forall a:A, open (F a)) ->
    open (IndexedIntersection F).

Definition closed {X:TopologicalSpace} (F:Ensemble (point_set X)) :=
  open (Ensembles.Complement F).

Lemma closed_complement_open: forall {X:TopologicalSpace}
  (U:Ensemble (point_set X)), closed (Ensembles.Complement U) ->

Lemma closed_union2: forall {X:TopologicalSpace}
  (F G:Ensemble (point_set X)),
  closed F -> closed G -> closed (Union F G).

Lemma closed_intersection2: forall {X:TopologicalSpace}
  (F G:Ensemble (point_set X)),
  closed F -> closed G -> closed (Intersection F G).

Lemma closed_family_intersection: forall {X:TopologicalSpace}
  (F:Family (point_set X)),
  (forall S:Ensemble (point_set X), In F S -> closed S) ->
  closed (FamilyIntersection F).

Lemma closed_indexed_intersection: forall {X:TopologicalSpace}
  {A:Type} (F:IndexedFamily A (point_set X)),
  (forall a:A, closed (F a)) -> closed (IndexedIntersection F).

Lemma closed_finite_indexed_union: forall {X:TopologicalSpace}
  {A:Type} (F:IndexedFamily A (point_set X)),
  FiniteT A -> (forall a:A, closed (F a)) ->
  closed (IndexedUnion F).

Hint Unfold closed : topology.
Hint Resolve (@open_family_union) (@open_intersection2) open_full
  open_empty (@open_union2) (@open_indexed_union)
  (@open_finite_indexed_intersection) (@closed_complement_open)
  (@closed_union2) (@closed_intersection2) (@closed_family_intersection)
  (@closed_indexed_intersection) (@closed_finite_indexed_union)
  : topology.

Section Build_from_closed_sets.

Variable X:Type.
Variable closedP : Ensemble X -> Prop.
Hypothesis closedP_empty: closedP Empty_set.
Hypothesis closedP_union2: forall F G:Ensemble X,
  closedP F -> closedP G -> closedP (Union F G).
Hypothesis closedP_family_intersection: forall F:Family X,
  (forall G:Ensemble X, In F G -> closedP G) ->
  closedP (FamilyIntersection F).

Definition Build_TopologicalSpace_from_closed_sets : TopologicalSpace.

Lemma Build_TopologicalSpace_from_closed_sets_closed:
  forall (F:Ensemble (point_set Build_TopologicalSpace_from_closed_sets)),
  closed F <-> closedP F.

End Build_from_closed_sets.

Arguments Build_TopologicalSpace_from_closed_sets {X}. *)
Require Export Ensembles.
From ZornsLemma Require Import EnsemblesImplicit.
Require Export InteriorsClosures.
(* InteriorsClosures:
Require Export TopologicalSpaces.
From ZornsLemma Require Export EnsemblesSpec.

Section interior_closure.

Variable X:TopologicalSpace.
Variable S:Ensemble (point_set X).

Definition interior := FamilyUnion
  [ U:Ensemble (point_set X) | open U /\ Included U S ].
Definition closure := FamilyIntersection
  [ F:Ensemble (point_set X) | closed F /\ Included S F ].

Lemma interior_open : open interior.

Lemma interior_deflationary : Included interior S.

Lemma interior_fixes_open: open S -> interior = S.

Lemma interior_maximal: forall U:Ensemble (point_set X),
  open U -> Included U S -> Included U interior.

Lemma closure_closed : closed closure.

Lemma closure_inflationary : Included S closure.

Lemma closure_fixes_closed : closed S -> closure = S.

Lemma closure_minimal: forall F:Ensemble (point_set X),
  closed F -> Included S F -> Included closure F.

End interior_closure.

Arguments interior {X}.
Arguments closure {X}.
Arguments interior_open {X}.
Arguments interior_deflationary {X}.
Arguments interior_fixes_open {X}.
Arguments interior_maximal {X}.
Arguments closure_closed {X}.
Arguments closure_inflationary {X}.
Arguments closure_fixes_closed {X}.
Arguments closure_minimal {X}.

Section interior_closure_relations.

Variable X:TopologicalSpace.

Lemma interior_increasing: forall S T:Ensemble (point_set X),
  Included S T -> Included (interior S) (interior T).

Lemma interior_intersection: forall S T:Ensemble (point_set X),
  interior (Intersection S T) =
  Intersection (interior S) (interior T).

Lemma interior_union: forall S T:Ensemble (point_set X),
  Included (Union (interior S) (interior T))
           (interior (Union S T)).

Lemma complement_inclusion: forall {Y:Type} (S T:Ensemble Y),
  Included S T -> Included (Complement T) (Complement S).

Lemma interior_complement: forall S:Ensemble (point_set X),
  interior (Complement S) = Complement (closure S).

Lemma closure_increasing: forall S T:Ensemble (point_set X),
  Included S T -> Included (closure S) (closure T).

Lemma closure_complement: forall S:Ensemble (point_set X),
  closure (Complement S) = Complement (interior S).

Lemma closure_union: forall S T:Ensemble (point_set X),
  closure (Union S T) = Union (closure S) (closure T).

Lemma closure_intersection: forall S T:Ensemble (point_set X),
  Included (closure (Intersection S T))
           (Intersection (closure S) (closure T)).

Lemma meets_every_open_neighborhood_impl_closure:
  forall (S:Ensemble (point_set X)) (x:point_set X),
  (forall U:Ensemble (point_set X), open U -> In U x ->
                                Inhabited (Intersection S U)) ->
  In (closure S) x.

Lemma closure_impl_meets_every_open_neighborhood:
  forall (S:Ensemble (point_set X)) (x:point_set X),
  In (closure S) x ->
  forall U:Ensemble (point_set X), open U -> In U x ->
    Inhabited (Intersection S U).

Definition dense (S:Ensemble (point_set X)) : Prop :=
  closure S = Full_set.

Lemma dense_meets_every_nonempty_open:
  forall S:Ensemble (point_set X), dense S ->
    forall U:Ensemble (point_set X), open U -> Inhabited U ->
    Inhabited (Intersection S U).

Lemma meets_every_nonempty_open_impl_dense:
  forall S:Ensemble (point_set X),
  (forall U:Ensemble (point_set X), open U -> Inhabited U ->
   Inhabited (Intersection S U)) ->
  dense S.

End interior_closure_relations.

Arguments interior_increasing {X}.
Arguments interior_intersection {X}.
Arguments interior_union {X}.
Arguments interior_complement {X}.
Arguments closure_increasing {X}.
Arguments closure_complement {X}.
Arguments closure_union {X}.
Arguments closure_intersection {X}.
Arguments dense {X}.

Section Build_from_closure.

Variable X:Type.
Variable cl : Ensemble X -> Ensemble X.
Hypothesis cl_inflationary: forall S:Ensemble X,
  Included S (cl S).
Hypothesis cl_respects_union: forall S1 S2:Ensemble X,
  cl (Union S1 S2) = Union (cl S1) (cl S2).
Hypothesis cl_empty: cl Empty_set = Empty_set.
Hypothesis cl_idempotent: forall S:Ensemble X,
  cl (cl S) = cl S.

Lemma cl_increasing: forall S1 S2:Ensemble X,
  Included S1 S2 -> Included (cl S1) (cl S2).

Definition Build_TopologicalSpace_from_closure_operator : TopologicalSpace.

Lemma Build_TopologicalSpace_from_closure_operator_closure:
  forall S:Ensemble (point_set Build_TopologicalSpace_from_closure_operator),
    closure S = cl S.

End Build_from_closure.

Arguments Build_TopologicalSpace_from_closure_operator {X}. *)

Definition open_neighborhood {X:TopologicalSpace}
  (U:Ensemble (point_set X)) (x:point_set X) :=
  open U /\ In U x.

Definition neighborhood {X:TopologicalSpace}
  (N:Ensemble (point_set X)) (x:point_set X) :=
  exists U:Ensemble (point_set X),
    open_neighborhood U x /\ Included U N.

Lemma open_neighborhood_is_neighborhood: forall {X:TopologicalSpace}
  (U:Ensemble (point_set X)) (x:point_set X),
  open_neighborhood U x -> neighborhood U x.
Proof.
intros.
exists U; auto with sets.
Qed.

Lemma neighborhood_interior: forall {X:TopologicalSpace}
  (N:Ensemble (point_set X)) (x:point_set X),
  neighborhood N x -> In (interior N) x.
Proof.
intros.
destruct H.
destruct H.
destruct H.
assert (Included x0 (interior N)).
apply interior_maximal; trivial.
auto with sets.
Qed.

Lemma interior_neighborhood: forall {X:TopologicalSpace}
  (N:Ensemble (point_set X)) (x:point_set X),
  In (interior N) x -> neighborhood N x.
Proof.
intros.
exists (interior N).
repeat split.
apply interior_open.
assumption.
apply interior_deflationary.
Qed.
