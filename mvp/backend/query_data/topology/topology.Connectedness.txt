Require Export TopologicalSpaces.
(* TopologicalSpaces:
Require Export Ensembles.
From ZornsLemma Require Import EnsemblesImplicit.
From ZornsLemma Require Export Families.
From ZornsLemma Require Export IndexedFamilies.
From ZornsLemma Require Export FiniteTypes.
From ZornsLemma Require Import EnsemblesSpec.

Record TopologicalSpace : Type := {
  point_set : Type;
  open : Ensemble point_set -> Prop;
  open_family_union : forall F : Family point_set,
    (forall S : Ensemble point_set, In F S -> open S) ->
    open (FamilyUnion F);
  open_intersection2: forall U V:Ensemble point_set,
    open U -> open V -> open (Intersection U V);
  open_full : open Full_set
}.

Arguments open {t}.
Arguments open_family_union {t}.
Arguments open_intersection2 {t}.

Lemma open_empty: forall X:TopologicalSpace,
  open (@Empty_set (point_set X)).

Lemma open_union2: forall {X:TopologicalSpace}
  (U V:Ensemble (point_set X)), open U -> open V -> open (Union U V).

Lemma open_indexed_union: forall {X:TopologicalSpace} {A:Type}
  (F:IndexedFamily A (point_set X)),
  (forall a:A, open (F a)) -> open (IndexedUnion F).

Lemma open_finite_indexed_intersection:
  forall {X:TopologicalSpace} {A:Type}
    (F:IndexedFamily A (point_set X)),
    FiniteT A -> (forall a:A, open (F a)) ->
    open (IndexedIntersection F).

Definition closed {X:TopologicalSpace} (F:Ensemble (point_set X)) :=
  open (Ensembles.Complement F).

Lemma closed_complement_open: forall {X:TopologicalSpace}
  (U:Ensemble (point_set X)), closed (Ensembles.Complement U) ->

Lemma closed_union2: forall {X:TopologicalSpace}
  (F G:Ensemble (point_set X)),
  closed F -> closed G -> closed (Union F G).

Lemma closed_intersection2: forall {X:TopologicalSpace}
  (F G:Ensemble (point_set X)),
  closed F -> closed G -> closed (Intersection F G).

Lemma closed_family_intersection: forall {X:TopologicalSpace}
  (F:Family (point_set X)),
  (forall S:Ensemble (point_set X), In F S -> closed S) ->
  closed (FamilyIntersection F).

Lemma closed_indexed_intersection: forall {X:TopologicalSpace}
  {A:Type} (F:IndexedFamily A (point_set X)),
  (forall a:A, closed (F a)) -> closed (IndexedIntersection F).

Lemma closed_finite_indexed_union: forall {X:TopologicalSpace}
  {A:Type} (F:IndexedFamily A (point_set X)),
  FiniteT A -> (forall a:A, closed (F a)) ->
  closed (IndexedUnion F).

Hint Unfold closed : topology.
Hint Resolve (@open_family_union) (@open_intersection2) open_full
  open_empty (@open_union2) (@open_indexed_union)
  (@open_finite_indexed_intersection) (@closed_complement_open)
  (@closed_union2) (@closed_intersection2) (@closed_family_intersection)
  (@closed_indexed_intersection) (@closed_finite_indexed_union)
  : topology.

Section Build_from_closed_sets.

Variable X:Type.
Variable closedP : Ensemble X -> Prop.
Hypothesis closedP_empty: closedP Empty_set.
Hypothesis closedP_union2: forall F G:Ensemble X,
  closedP F -> closedP G -> closedP (Union F G).
Hypothesis closedP_family_intersection: forall F:Family X,
  (forall G:Ensemble X, In F G -> closedP G) ->
  closedP (FamilyIntersection F).

Definition Build_TopologicalSpace_from_closed_sets : TopologicalSpace.

Lemma Build_TopologicalSpace_from_closed_sets_closed:
  forall (F:Ensemble (point_set Build_TopologicalSpace_from_closed_sets)),
  closed F <-> closedP F.

End Build_from_closed_sets.

Arguments Build_TopologicalSpace_from_closed_sets {X}. *)

Definition clopen {X:TopologicalSpace} (S:Ensemble (point_set X))
  : Prop :=
  open S /\ closed S.

Definition connected (X:TopologicalSpace) : Prop :=
  forall S:Ensemble (point_set X), clopen S ->
        S = Empty_set \/ S = Full_set.

Require Export Continuity.
(* Continuity:
Require Export TopologicalSpaces.
Require Export Neighborhoods.
From ZornsLemma Require Export InverseImage.
Require Export OpenBases.
Require Export NeighborhoodBases.
Require Export Subbases.

Section continuity.

Variable X Y:TopologicalSpace.
Variable f:point_set X -> point_set Y.

Definition continuous : Prop :=
  forall V:Ensemble (point_set Y), open V ->
  open (inverse_image f V).

Definition continuous_at (x:point_set X) : Prop :=
  forall V:Ensemble (point_set Y),
  neighborhood V (f x) -> neighborhood (inverse_image f V) x.

Lemma continuous_at_open_neighborhoods:
  forall x:point_set X,
  (forall V:Ensemble (point_set Y),
  open_neighborhood V (f x) -> neighborhood (inverse_image f V) x) ->
  continuous_at x.

Lemma pointwise_continuity :
  (forall x:point_set X, continuous_at x) -> continuous.

Lemma continuous_func_continuous_everywhere:
  continuous -> forall x:point_set X, continuous_at x.

Lemma continuous_at_neighborhood_basis:
  forall (x:point_set X) (NB:Family (point_set Y)),
  neighborhood_basis NB (f x) ->
  (forall V:Ensemble (point_set Y),
  In NB V -> neighborhood (inverse_image f V) x) ->
  continuous_at x.

Lemma continuous_open_basis:
  forall (B:Family (point_set Y)), open_basis B ->
  (forall V:Ensemble (point_set Y),
    In B V -> open (inverse_image f V)) -> continuous.

Lemma continuous_subbasis:
  forall (SB:Family (point_set Y)), subbasis SB ->
  (forall V:Ensemble (point_set Y),
     In SB V -> open (inverse_image f V)) -> continuous.

End continuity.

Arguments continuous {X} {Y}.
Arguments continuous_at {X} {Y}.

Lemma continuous_composition_at: forall {X Y Z:TopologicalSpace}
  (f:point_set Y -> point_set Z) (g:point_set X -> point_set Y)
  (x:point_set X),
  continuous_at f (g x) -> continuous_at g x ->
  continuous_at (fun x:point_set X => f (g x)) x.

Lemma continuous_composition: forall {X Y Z:TopologicalSpace}
  (f:point_set Y -> point_set Z) (g:point_set X -> point_set Y),
  continuous f -> continuous g ->
  continuous (fun x:point_set X => f (g x)).

Lemma continuous_identity: forall (X:TopologicalSpace),
  continuous (fun x:point_set X => x).

Lemma continuous_constant: forall (X Y:TopologicalSpace)
  (y0:point_set Y), continuous (fun x:point_set X => y0).

Lemma continuous_at_is_local: forall (X Y:TopologicalSpace)
  (x0:point_set X) (f g:point_set X -> point_set Y)
  (N:Ensemble (point_set X)),
  neighborhood N x0 -> (forall x:point_set X, In N x -> f x = g x) ->
  continuous_at f x0 -> continuous_at g x0. *)

Lemma connected_img: forall {X Y:TopologicalSpace}
  (f:point_set X -> point_set Y),
  connected X -> continuous f -> surjective f -> connected Y.
Proof.
intros.
red; intros.
destruct (H (inverse_image f S)).
split.
apply H0.
apply H2.
red.
rewrite <- inverse_image_complement.
apply H0.
apply H2.

left.
apply Extensionality_Ensembles; split; red; intros.
destruct (H1 x).
assert (In Empty_set x0).
rewrite <- H3.
constructor.
rewrite H5.
trivial.
destruct H6.
destruct H4.

right.
apply Extensionality_Ensembles; split; red; intros.
constructor.
destruct (H1 x).
rewrite <- H5.
assert (In (inverse_image f S) x0).
rewrite H3; constructor.
destruct H6; trivial.
Qed.

Require Export SubspaceTopology.
(* SubspaceTopology:
Require Export TopologicalSpaces.
Require Import WeakTopology.

Section Subspace.

Variable X:TopologicalSpace.
Variable A:Ensemble (point_set X).

Definition SubspaceTopology : TopologicalSpace :=
  WeakTopology1 (proj1_sig (P:=fun x:point_set X => In A x)).

Definition subspace_inc : point_set SubspaceTopology ->
  point_set X :=
  proj1_sig (P:=fun x:point_set X => In A x).

Lemma subspace_topology_topology: forall U:Ensemble {x:point_set X | In A x},
  @open SubspaceTopology U -> exists V:Ensemble (point_set X),
  open V /\ U = inverse_image subspace_inc V.

Lemma subspace_inc_continuous:
  continuous subspace_inc.

End Subspace.

Arguments SubspaceTopology {X}.
Arguments subspace_inc {X}. *)

Lemma connected_union: forall {X:TopologicalSpace}
  {A:Type} (S:IndexedFamily A (point_set X)),
  (forall a:A, connected (SubspaceTopology (S a))) ->
  Inhabited (IndexedIntersection S) ->
  IndexedUnion S = Full_set -> connected X.
Proof.
intros.
pose (inc := fun (a:A) => subspace_inc (S a)).
destruct H0.
destruct H0.
red; intros.
assert (forall a:A, clopen (inverse_image (inc a) S0)).
intro.
split.
apply subspace_inc_continuous.
apply H2.
red.
rewrite <- inverse_image_complement.
apply subspace_inc_continuous.
apply H2.
destruct (classic (In S0 x)).
right.
assert (forall a:A, inverse_image (inc a) S0 = Full_set).
intro.
destruct (H a _ (H3 a)).
assert (In (@Empty_set (point_set (SubspaceTopology (S a))))
  (exist _ x (H0 a))).
rewrite <- H5.
constructor.
simpl.
trivial.
destruct H6.
trivial.
apply Extensionality_Ensembles; split; red; intros.
constructor.
assert (In (IndexedUnion S) x0).
rewrite H1; constructor.
destruct H7.
assert (In (@Full_set (point_set (SubspaceTopology (S a))))
  (exist _ x0 H7)).
constructor.
rewrite <- H5 in H8.
destruct H8.
simpl in H8.
trivial.

left.
assert (forall a:A, inverse_image (inc a) S0 = Empty_set).
intros.
destruct (H a _ (H3 a)).
trivial.
assert (In (@Full_set (point_set (SubspaceTopology (S a))))
  (exist _ x (H0 a))).
constructor.
rewrite <- H5 in H6.
destruct H6.
simpl in H6.
contradiction H4.

apply Extensionality_Ensembles; split; red; intros.
assert (In (IndexedUnion S) x0).
rewrite H1; constructor.
destruct H7.
assert (In (@Empty_set (point_set (SubspaceTopology (S a))))
  (exist _ x0 H7)).
rewrite <- H5.
constructor.
simpl.
trivial.
destruct H8.
destruct H6.
Qed.
