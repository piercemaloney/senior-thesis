Require Export Subbases.
(* Subbases:
Require Export TopologicalSpaces.
Require Export OpenBases.
From ZornsLemma Require Export FiniteTypes.
From ZornsLemma Require Export EnsemblesSpec.

Section Subbasis.

Variable X:TopologicalSpace.
Variable SB:Family (point_set X).

Record subbasis : Prop := {
  subbasis_elements: forall U:Ensemble (point_set X),
    In SB U -> open U;
  subbasis_cover: forall (U:Ensemble (point_set X)) (x:point_set X),
    In U x -> open U ->
    exists A:Type, FiniteT A /\
    exists V:A->Ensemble (point_set X),
      (forall a:A, In SB (V a)) /\
      In (IndexedIntersection V) x /\
      Included (IndexedIntersection V) U
}.

Lemma open_basis_is_subbasis: open_basis SB -> subbasis.

Lemma finite_intersections_of_subbasis_form_open_basis:
  subbasis ->
  open_basis [ U:Ensemble (point_set X) |
              exists A:Type, FiniteT A /\
              exists V:A->Ensemble (point_set X),
              (forall a:A, In SB (V a)) /\
              U = IndexedIntersection V ].

End Subbasis.

Arguments subbasis {X}.

Section build_from_subbasis.

Variable X:Type.
Variable S:Family X.

From ZornsLemma Require Import FiniteIntersections.

Definition Build_TopologicalSpace_from_subbasis : TopologicalSpace.

Lemma Build_TopologicalSpace_from_subbasis_subbasis:
  @subbasis Build_TopologicalSpace_from_subbasis S.

End build_from_subbasis. *)
From ZornsLemma Require Export Relation_Definitions_Implicit.
Require Export SeparatednessAxioms.
(* SeparatednessAxioms:
Require Export TopologicalSpaces.
Require Import InteriorsClosures.

Definition T0_sep (X:TopologicalSpace) : Prop :=
  forall x y:point_set X, x <> y ->
  (exists U:Ensemble (point_set X), open U /\ In U x /\ ~ In U y) \/
  (exists U:Ensemble (point_set X), open U /\ ~ In U x /\ In U y).

Definition T1_sep (X:TopologicalSpace) : Prop :=
  forall x:point_set X, closed (Singleton x).

Definition Hausdorff (X:TopologicalSpace) : Prop :=
  forall x y:point_set X, x <> y ->
    exists U:Ensemble (point_set X),
    exists V:Ensemble (point_set X),
  open U /\ open V /\ In U x /\ In V y /\
  Intersection U V = Empty_set.
Definition T2_sep := Hausdorff.

Definition T3_sep (X:TopologicalSpace) : Prop :=
  T1_sep X /\
  forall (x:point_set X) (F:Ensemble (point_set X)),
  closed F -> ~ In F x -> exists U:Ensemble (point_set X),
                          exists V:Ensemble (point_set X),
        open U /\ open V /\ In U x /\ Included F V /\
        Intersection U V = Empty_set.

Definition normal_sep (X:TopologicalSpace) : Prop :=
  T1_sep X /\
  forall (F G:Ensemble (point_set X)),
  closed F -> closed G -> Intersection F G = Empty_set ->
  exists U:Ensemble (point_set X), exists V:Ensemble (point_set X),
  open U /\ open V /\ Included F U /\ Included G V /\
  Intersection U V = Empty_set.
Definition T4_sep := normal_sep.

Lemma T1_sep_impl_T0_sep: forall X:TopologicalSpace,
  T1_sep X -> T0_sep X.

Lemma Hausdorff_impl_T1_sep: forall X:TopologicalSpace,
  Hausdorff X -> T1_sep X.

Lemma T3_sep_impl_Hausdorff: forall X:TopologicalSpace,
  T3_sep X -> Hausdorff X.

Lemma normal_sep_impl_T3_sep: forall X:TopologicalSpace,
  normal_sep X -> T3_sep X.

Section Hausdorff_and_nets.
Require Export Nets.

Lemma Hausdorff_impl_net_limit_unique:
  forall {X:TopologicalSpace} {I:DirectedSet} (x:Net I X),
    Hausdorff X -> uniqueness (net_limit x).

Lemma Hausdorff_impl_net_limit_is_unique_cluster_point:
  forall {X:TopologicalSpace} {I:DirectedSet} (x:Net I X)
    (x0:point_set X), Hausdorff X -> net_limit x x0 ->
    forall y:point_set X, net_cluster_point x y -> y = x0.

Lemma net_limit_is_unique_cluster_point_impl_Hausdorff:
  forall (X:TopologicalSpace),
  (forall (I:DirectedSet) (x:Net I X) (x0 y:point_set X),
  net_limit x x0 -> net_cluster_point x y ->
  y = x0) -> Hausdorff X.

Lemma net_limit_uniqueness_impl_Hausdorff:
  forall X:TopologicalSpace,
  (forall (I:DirectedSet) (x:Net I X), uniqueness (net_limit x)) ->
  Hausdorff X.

End Hausdorff_and_nets. *)

Section OrderTopology.

Variable X:Type.
Variable R:relation X.
Hypothesis R_ord: order R.

Inductive order_topology_subbasis : Family X :=
  | intro_lower_interval: forall x:X,
    In order_topology_subbasis [ y:X | R y x /\ y <> x ]
  | intro_upper_interval: forall x:X,
    In order_topology_subbasis [ y:X | R x y /\ y <> x].

Definition OrderTopology : TopologicalSpace :=
  Build_TopologicalSpace_from_subbasis X order_topology_subbasis.

Section if_total_order.

Hypothesis R_total: forall x y:X, R x y \/ R y x.

Lemma lower_closed_interval_closed: forall x:X,
  closed [ y:X | R y x ] (X:=OrderTopology).
Proof.
intro.
red.
match goal with |- open ?U => cut (U = interior U) end.
intro.
rewrite H; apply interior_open.
apply Extensionality_Ensembles; split.
2:apply interior_deflationary.
intros y ?.
red in H.
red in H.
assert (R x y).
destruct (R_total x y); trivial.
contradiction H.
constructor; trivial.
exists ([z:X | R x z /\ z <> x]).
constructor; split.
apply (Build_TopologicalSpace_from_subbasis_subbasis
  _ order_topology_subbasis).
constructor.
red; intros z ?.
destruct H1.
destruct H1.
intro.
destruct H3.
contradiction H2.
apply (ord_antisym R_ord); trivial.
constructor.
split; trivial.
intro.
contradiction H.
constructor.
destruct H1; apply (ord_refl R_ord).
Qed.

Lemma upper_closed_interval_closed: forall x:X,
  closed [y:X | R x y] (X:=OrderTopology).
Proof.
intro.
red.
match goal with |- open ?U => cut (U = interior U) end.
intro.
rewrite H; apply interior_open.
apply Extensionality_Ensembles; split.
2:apply interior_deflationary.
intros y ?.
red in H.
red in H.
assert (R y x).
destruct (R_total x y); trivial.
contradiction H.
constructor; trivial.
exists ([z:X | R z x /\ z <> x]).
constructor; split.
apply (Build_TopologicalSpace_from_subbasis_subbasis
  _ order_topology_subbasis).
constructor.
red; intros z ?.
destruct H1.
destruct H1.
intro.
destruct H3.
contradiction H2.
apply (ord_antisym R_ord); trivial.
constructor.
split; trivial.
intro.
contradiction H.
constructor.
destruct H1; apply (ord_refl R_ord).
Qed.

Lemma order_topology_Hausdorff: Hausdorff OrderTopology.
Proof.
red.
match goal with |- forall x y:point_set OrderTopology, ?P =>
  cut (forall x y:point_set OrderTopology, R x y -> P)
  end.
intros.
destruct (R_total x y).
exact (H x y H1 H0).
assert (y <> x).
auto.
destruct (H y x H1 H2) as [V [U [? [? [? []]]]]].
exists U; exists V; repeat split; trivial.
transitivity (Intersection V U); trivial.
apply Extensionality_Ensembles; split; red; intros.
destruct H8; constructor; trivial.
destruct H8; constructor; trivial.

intros.
pose proof (Build_TopologicalSpace_from_subbasis_subbasis
  _ order_topology_subbasis).
destruct (classic (exists z:X, R x z /\ R z y /\ z <> x /\ z <> y)).
destruct H2 as [z [? [? []]]].
exists ([w:X | R w z /\ w <> z]);
exists ([w:X | R z w /\ w <> z]).
repeat split; trivial.
apply H1.
constructor.
apply H1.
constructor.
auto.
auto.
apply Extensionality_Ensembles; split; red; intros.
destruct H6.
destruct H6.
destruct H7.
destruct H6.
destruct H7.
contradiction H8.
apply (ord_antisym R_ord); trivial.
destruct H6.

exists ([w:X | R w y /\ w <> y]);
exists ([w:X | R x w /\ w <> x]).
repeat split.
apply H1.
constructor.
apply H1.
constructor.
trivial.
trivial.
trivial.
auto.
apply Extensionality_Ensembles; split; red; intros.
destruct H3.
destruct H3.
destruct H4.
destruct H3.
destruct H4.
contradiction H2.
exists x0; repeat split; trivial.
destruct H3.
Qed.

End if_total_order.

End OrderTopology.

Arguments OrderTopology {X}.
