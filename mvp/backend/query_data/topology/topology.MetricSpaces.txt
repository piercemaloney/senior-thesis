Require Export Reals.
Require Export TopologicalSpaces.
(* TopologicalSpaces:
Require Export Ensembles.
From ZornsLemma Require Import EnsemblesImplicit.
From ZornsLemma Require Export Families.
From ZornsLemma Require Export IndexedFamilies.
From ZornsLemma Require Export FiniteTypes.
From ZornsLemma Require Import EnsemblesSpec.

Record TopologicalSpace : Type := {
  point_set : Type;
  open : Ensemble point_set -> Prop;
  open_family_union : forall F : Family point_set,
    (forall S : Ensemble point_set, In F S -> open S) ->
    open (FamilyUnion F);
  open_intersection2: forall U V:Ensemble point_set,
    open U -> open V -> open (Intersection U V);
  open_full : open Full_set
}.

Arguments open {t}.
Arguments open_family_union {t}.
Arguments open_intersection2 {t}.

Lemma open_empty: forall X:TopologicalSpace,
  open (@Empty_set (point_set X)).

Lemma open_union2: forall {X:TopologicalSpace}
  (U V:Ensemble (point_set X)), open U -> open V -> open (Union U V).

Lemma open_indexed_union: forall {X:TopologicalSpace} {A:Type}
  (F:IndexedFamily A (point_set X)),
  (forall a:A, open (F a)) -> open (IndexedUnion F).

Lemma open_finite_indexed_intersection:
  forall {X:TopologicalSpace} {A:Type}
    (F:IndexedFamily A (point_set X)),
    FiniteT A -> (forall a:A, open (F a)) ->
    open (IndexedIntersection F).

Definition closed {X:TopologicalSpace} (F:Ensemble (point_set X)) :=
  open (Ensembles.Complement F).

Lemma closed_complement_open: forall {X:TopologicalSpace}
  (U:Ensemble (point_set X)), closed (Ensembles.Complement U) ->

Lemma closed_union2: forall {X:TopologicalSpace}
  (F G:Ensemble (point_set X)),
  closed F -> closed G -> closed (Union F G).

Lemma closed_intersection2: forall {X:TopologicalSpace}
  (F G:Ensemble (point_set X)),
  closed F -> closed G -> closed (Intersection F G).

Lemma closed_family_intersection: forall {X:TopologicalSpace}
  (F:Family (point_set X)),
  (forall S:Ensemble (point_set X), In F S -> closed S) ->
  closed (FamilyIntersection F).

Lemma closed_indexed_intersection: forall {X:TopologicalSpace}
  {A:Type} (F:IndexedFamily A (point_set X)),
  (forall a:A, closed (F a)) -> closed (IndexedIntersection F).

Lemma closed_finite_indexed_union: forall {X:TopologicalSpace}
  {A:Type} (F:IndexedFamily A (point_set X)),
  FiniteT A -> (forall a:A, closed (F a)) ->
  closed (IndexedUnion F).

Hint Unfold closed : topology.
Hint Resolve (@open_family_union) (@open_intersection2) open_full
  open_empty (@open_union2) (@open_indexed_union)
  (@open_finite_indexed_intersection) (@closed_complement_open)
  (@closed_union2) (@closed_intersection2) (@closed_family_intersection)
  (@closed_indexed_intersection) (@closed_finite_indexed_union)
  : topology.

Section Build_from_closed_sets.

Variable X:Type.
Variable closedP : Ensemble X -> Prop.
Hypothesis closedP_empty: closedP Empty_set.
Hypothesis closedP_union2: forall F G:Ensemble X,
  closedP F -> closedP G -> closedP (Union F G).
Hypothesis closedP_family_intersection: forall F:Family X,
  (forall G:Ensemble X, In F G -> closedP G) ->
  closedP (FamilyIntersection F).

Definition Build_TopologicalSpace_from_closed_sets : TopologicalSpace.

Lemma Build_TopologicalSpace_from_closed_sets_closed:
  forall (F:Ensemble (point_set Build_TopologicalSpace_from_closed_sets)),
  closed F <-> closedP F.

End Build_from_closed_sets.

Arguments Build_TopologicalSpace_from_closed_sets {X}. *)
Require Export NeighborhoodBases.
(* NeighborhoodBases:
Require Export TopologicalSpaces.
Require Export Neighborhoods.
Require Export OpenBases.
From ZornsLemma Require Export IndexedFamilies.
From ZornsLemma Require Export EnsemblesSpec.

Record neighborhood_basis {X:TopologicalSpace}
  (NB:Family (point_set X)) (x:point_set X) : Prop := {
  neighborhood_basis_elements: forall N:Ensemble (point_set X),
    In NB N -> neighborhood N x;
  neighborhood_basis_cond: forall N:Ensemble (point_set X),
    neighborhood N x -> exists N':Ensemble (point_set X),
    In NB N' /\ Included N' N
}.

Record open_neighborhood_basis {X:TopologicalSpace}
  (NB:Family (point_set X)) (x:point_set X) : Prop := {
  open_neighborhood_basis_elements: forall U:Ensemble (point_set X),
    In NB U -> open_neighborhood U x;
  open_neighborhood_basis_cond: forall U:Ensemble (point_set X),
    open_neighborhood U x -> exists V:Ensemble (point_set X),
    In NB V /\ Included V U
}.

Lemma open_neighborhood_basis_is_neighborhood_basis:
  forall {X:TopologicalSpace} (NB:Family (point_set X)) (x:point_set X),
  open_neighborhood_basis NB x -> neighborhood_basis NB x.

Lemma open_basis_to_open_neighborhood_basis:
  forall {X:TopologicalSpace} (B:Family (point_set X)) (x:point_set X),
    open_basis B -> open_neighborhood_basis
                    [ U:Ensemble (point_set X) | In B U /\ In U x ]
                    x.

Lemma open_neighborhood_bases_to_open_basis:
  forall {X:TopologicalSpace} (NB : point_set X -> Family (point_set X)),
    (forall x:point_set X, open_neighborhood_basis (NB x) x) ->
    open_basis (IndexedUnion NB).

Section build_from_open_neighborhood_bases.

Variable X:Type.
Variable NB : X -> Family X.

Hypothesis neighborhood_basis_cond :
  forall (U V:Ensemble X) (x:X), In (NB x) U -> In (NB x) V ->
    exists W:Ensemble X, In (NB x) W /\ Included W (Intersection U V).
Hypothesis neighborhood_basis_cond2 :
  forall (U:Ensemble X) (x:X), In (NB x) U -> In U x.
Hypothesis neighborhood_basis_inhabited_cond :
  forall x:X, Inhabited (NB x).
Hypothesis neighborhood_basis_system_cond :
  forall (x y:X) (U:Ensemble X), In (NB x) U -> In U y ->
  exists V:Ensemble X, In (NB y) V /\ Included V U.

Definition Build_TopologicalSpace_from_open_neighborhood_bases :
  TopologicalSpace.

Lemma Build_TopologicalSpace_from_open_neighborhood_bases_basis:
  forall x:X,
    open_neighborhood_basis (NB x) x
      (X:=Build_TopologicalSpace_from_open_neighborhood_bases).

End build_from_open_neighborhood_bases. *)
Require Import RationalsInReals.
(* RationalsInReals:
Require Export Reals.
Require Export QArith.
Require Export Qreals.

Open Scope R_scope.
Lemma inverses_of_nats_approach_0:
  forall eps:R, eps > 0 -> exists n:nat, (n > 0)%nat /\
                                         / (INR n) < eps.

Lemma Z_interpolation: forall x y:R, y > x+1 ->
  exists n:Z, x < IZR n < y.

Local Notation " ' x " := (Zpos x) (at level 20, no associativity) : Z_scope.

Lemma rational_interpolation: forall (x y:R) (n:positive),
  x<y -> IZR (' n) > 1/(y-x) ->
  exists m:Z, x < Q2R (m # n) < y.

Lemma rationals_dense_in_reals: forall x y:R, x<y ->
  exists q:Q, x < Q2R q < y. *)
From ZornsLemma Require Export EnsemblesSpec.

Open Scope R_scope.

Section metric.

Variable X:Type.
Variable d:X->X->R.

Record metric : Prop := {
  metric_nonneg: forall x y:X, d x y >= 0;
  metric_sym: forall x y:X, d x y = d y x;
  triangle_inequality: forall x y z:X, d x z <= d x y + d y z;
  metric_zero: forall x:X, d x x = 0;
  metric_strict: forall x y:X, d x y = 0 -> x = y
}.

End metric.

Arguments metric {X}.

Section metric_topology.

Variable X:Type.
Variable d:X->X->R.
Hypothesis d_is_metric: metric d.

Definition open_ball (x0:X) (r:R) : Ensemble X :=
  [ x:X | d x0 x < r ].

Inductive metric_topology_neighborhood_basis (x:X) : Family X :=
  | intro_open_ball: forall r:R, r > 0 ->
    In (metric_topology_neighborhood_basis x) (open_ball x r).

Definition MetricTopology : TopologicalSpace.
refine (Build_TopologicalSpace_from_open_neighborhood_bases
  X metric_topology_neighborhood_basis _ _ _ _).

intros.
destruct H as [r1].
destruct H0 as [r2].
exists (open_ball x (Rmin r1 r2)); split.
constructor.
apply Rmin_Rgt_r; split; trivial.
red; intros.
destruct H1.
constructor; constructor.
apply Rlt_le_trans with (Rmin r1 r2); trivial.
apply Rmin_l.
apply Rlt_le_trans with (Rmin r1 r2); trivial.
apply Rmin_r.

intros.
destruct H.
constructor.
rewrite metric_zero; trivial.

intro.
exists (open_ball x 1).
constructor.
auto with *.

intros.
destruct H.
destruct H0.
exists (open_ball y (r - d x y)); split.
constructor.
apply Rgt_minus; trivial.
red; intros z ?.
destruct H1.
constructor.
apply Rle_lt_trans with (d x y + d y z).
apply triangle_inequality; trivial.
assert (d x y + d y z < d x y + (r - d x y)).
auto with *.
ring_simplify in H2.
assumption.
Defined.

End metric_topology.

Arguments metric_topology_neighborhood_basis {X}.
Arguments MetricTopology {X}.

Definition metrizes (X:TopologicalSpace)
  (d:point_set X -> point_set X -> R) : Prop :=
  forall x:point_set X, open_neighborhood_basis
             (metric_topology_neighborhood_basis d x) x.

Inductive metrizable (X:TopologicalSpace) : Prop :=
  | intro_metrizable: forall d:point_set X -> point_set X -> R,
    metric d -> metrizes X d ->
    metrizable X.

Lemma MetricTopology_metrizable: forall (X:Type) (d:X->X->R)
  (d_metric: metric d),
  metrizes (MetricTopology d d_metric) d.
Proof.
intros.
red.
intros.
apply Build_TopologicalSpace_from_open_neighborhood_bases_basis.
Qed.

Require Export Nets.
(* Nets:
Require Export TopologicalSpaces.
Require Export DirectedSets.
Require Export InteriorsClosures.
Require Export Continuity.

Set Asymmetric Patterns.

Section Net.

Variable I:DirectedSet.
Variable X:TopologicalSpace.

Definition Net := DS_set I -> point_set X.

Definition net_limit (x:Net) (x0:point_set X) : Prop :=
  forall U:Ensemble (point_set X), open U -> In U x0 ->
  for large i:DS_set I, In U (x i).

Definition net_cluster_point (x:Net) (x0:point_set X) : Prop :=
  forall U:Ensemble (point_set X), open U -> In U x0 ->
  exists arbitrarily large i:DS_set I, In U (x i).

Lemma net_limit_is_cluster_point: forall (x:Net) (x0:point_set X),
  net_limit x x0 -> net_cluster_point x x0.

Lemma net_limit_in_closure: forall (S:Ensemble (point_set X))
  (x:Net) (x0:point_set X),
  (exists arbitrarily large i:DS_set I, In S (x i)) ->
  net_limit x x0 -> In (closure S) x0.

Lemma net_cluster_point_in_closure: forall (S:Ensemble (point_set X))
  (x:Net) (x0:point_set X),
  (for large i:DS_set I, In S (x i)) ->
  net_cluster_point x x0 -> In (closure S) x0.

End Net.

Arguments net_limit {I} {X}.
Arguments net_cluster_point {I} {X}.
Arguments net_limit_is_cluster_point {I} {X}.
Arguments net_limit_in_closure {I} {X}.
Arguments net_cluster_point_in_closure {I} {X}.

Section neighborhood_net.

Variable X:TopologicalSpace.
Variable x:point_set X.

Inductive neighborhood_net_DS_set : Type :=
  | intro_neighborhood_net_DS :
    forall (U:Ensemble (point_set X)) (y:point_set X),
    open U -> In U x -> In U y -> neighborhood_net_DS_set.

Definition neighborhood_net_DS_ord
  (Uy Vz:neighborhood_net_DS_set) : Prop :=
  match Uy, Vz with
  | intro_neighborhood_net_DS U _ _ _ _,
    intro_neighborhood_net_DS V _ _ _ _ =>
    Included V U
  end.

Definition neighborhood_net_DS : DirectedSet.

Definition neighborhood_net : Net neighborhood_net_DS X :=
  fun (x:neighborhood_net_DS_set) => match x with
  | intro_neighborhood_net_DS _ y _ _ _ => y
  end.

Lemma neighborhood_net_limit: net_limit neighborhood_net x.

End neighborhood_net.

Lemma net_limits_determine_topology:
  forall {X:TopologicalSpace} (S:Ensemble (point_set X))
  (x0:point_set X), In (closure S) x0 ->
  exists I:DirectedSet, exists x:Net I X,
  (forall i:DS_set I, In S (x i)) /\ net_limit x x0.

Section Nets_and_continuity.

Variable X Y:TopologicalSpace.
Variable f:point_set X -> point_set Y.

Lemma continuous_func_preserves_net_limits:
  forall {I:DirectedSet} (x:Net I X) (x0:point_set X),
    net_limit x x0 -> continuous_at f x0 ->
    net_limit (fun i:DS_set I => f (x i)) (f x0).

Lemma func_preserving_net_limits_is_continuous:
  forall x0:point_set X,
  (forall (I:DirectedSet) (x:Net I X),
    net_limit x x0 -> net_limit (fun i:DS_set I => f (x i)) (f x0))
  -> continuous_at f x0.

End Nets_and_continuity.

Section Subnet.

Variable X:TopologicalSpace.
Variable I:DirectedSet.
Variable x:Net I X.

Inductive Subnet {J:DirectedSet} : Net J X -> Prop :=
  | intro_subnet: forall h:DS_set J -> DS_set I,
    (forall j1 j2:DS_set J, DS_ord j1 j2 ->
       DS_ord (h j1) (h j2)) ->
    (exists arbitrarily large i:DS_set I,
       exists j:DS_set J, h j = i) ->
    Subnet (fun j:DS_set J => x (h j)).

Lemma subnet_limit: forall (x0:point_set X) {J:DirectedSet}
  (y:Net J X), net_limit x x0 -> Subnet y ->
  net_limit y x0.

Lemma subnet_cluster_point: forall (x0:point_set X) {J:DirectedSet}
  (y:Net J X), net_cluster_point y x0 ->
  Subnet y -> net_cluster_point x x0.

Section cluster_point_subnet.

Variable x0:point_set X.
Hypothesis x0_cluster_point: net_cluster_point x x0.
Hypothesis I_nonempty: inhabited (DS_set I).

Record cluster_point_subnet_DS_set : Type := {
  cps_i:DS_set I;
  cps_U:Ensemble (point_set X);
  cps_U_open_neigh: open_neighborhood cps_U x0;
  cps_xi_in_U: In cps_U (x cps_i)
}.

Definition cluster_point_subnet_DS_ord
  (iU1 iU2 : cluster_point_subnet_DS_set) : Prop :=
  DS_ord (cps_i iU1) (cps_i iU2) /\
  Included (cps_U iU2) (cps_U iU1).

Definition cluster_point_subnet_DS : DirectedSet.

Definition cluster_point_subnet : Net
  cluster_point_subnet_DS X :=
  fun (iU:DS_set cluster_point_subnet_DS) =>
  x (cps_i iU).

Lemma cluster_point_subnet_is_subnet:
  Subnet cluster_point_subnet.

Lemma cluster_point_subnet_converges:
  net_limit cluster_point_subnet x0.

Lemma net_cluster_point_impl_subnet_converges:
  exists J:DirectedSet, exists y:Net J X,
  Subnet y /\ net_limit y x0.

End cluster_point_subnet.

End Subnet. *)

Lemma metric_space_net_limit: forall (X:TopologicalSpace)
  (d:point_set X -> point_set X -> R), metrizes X d ->
  forall (I:DirectedSet) (x:Net I X) (x0:point_set X),
  (forall eps:R, eps > 0 -> for large i:DS_set I, d x0 (x i) < eps) ->
  net_limit x x0.
Proof.
intros.
red; intros.
destruct (H x0).
destruct (open_neighborhood_basis_cond U) as [V []].
split; trivial.
destruct H3.
apply eventually_impl_base with (2:=H0 r H3).
intros.
apply H4.
constructor; trivial.
Qed.

Lemma metric_space_net_limit_converse: forall (X:TopologicalSpace)
  (d:point_set X -> point_set X -> R), metrizes X d ->
  forall (I:DirectedSet) (x:Net I X) (x0:point_set X),
    net_limit x x0 -> forall eps:R, eps > 0 ->
                         for large i:DS_set I, d x0 (x i) < eps.
Proof.
intros.
pose (U:=open_ball _ d x0 eps).
assert (open_neighborhood U x0).
apply H.
constructor; trivial.
destruct H2.
destruct (H0 U) as [i]; trivial.
exists i; intros.
apply H4; trivial.
Qed.

Lemma metric_space_net_cluster_point: forall (X:TopologicalSpace)
  (d:point_set X -> point_set X -> R), metrizes X d ->
  forall (I:DirectedSet) (x:Net I X) (x0:point_set X),
  (forall eps:R, eps > 0 ->
     exists arbitrarily large i:DS_set I, d x0 (x i) < eps) ->
  net_cluster_point x x0.
Proof.
intros.
red; intros.
destruct (H x0).
destruct (open_neighborhood_basis_cond U) as
  [? [[]]].
split; trivial.
red; intros.
destruct (H0 r H3 i) as [j []].
exists j; split; trivial.
apply H4.
constructor; trivial.
Qed.

Lemma metric_space_net_cluster_point_converse: forall (X:TopologicalSpace)
  (d:point_set X -> point_set X -> R), metrizes X d ->
  forall (I:DirectedSet) (x:Net I X) (x0:point_set X),
    net_cluster_point x x0 -> forall eps:R, eps > 0 ->
                exists arbitrarily large i:DS_set I, d x0 (x i) < eps.
Proof.
intros.
pose (U:=open_ball _ d x0 eps).
assert (open_neighborhood U x0).
apply H.
constructor; trivial.
destruct H2.
pose proof (H0 U H2 H3).
red; intros.
destruct (H4 i) as [j []].
exists j.
split; trivial.
destruct H6; trivial.
Qed.

Require Export Continuity.
(* Continuity:
Require Export TopologicalSpaces.
Require Export Neighborhoods.
From ZornsLemma Require Export InverseImage.
Require Export OpenBases.
Require Export NeighborhoodBases.
Require Export Subbases.

Section continuity.

Variable X Y:TopologicalSpace.
Variable f:point_set X -> point_set Y.

Definition continuous : Prop :=
  forall V:Ensemble (point_set Y), open V ->
  open (inverse_image f V).

Definition continuous_at (x:point_set X) : Prop :=
  forall V:Ensemble (point_set Y),
  neighborhood V (f x) -> neighborhood (inverse_image f V) x.

Lemma continuous_at_open_neighborhoods:
  forall x:point_set X,
  (forall V:Ensemble (point_set Y),
  open_neighborhood V (f x) -> neighborhood (inverse_image f V) x) ->
  continuous_at x.

Lemma pointwise_continuity :
  (forall x:point_set X, continuous_at x) -> continuous.

Lemma continuous_func_continuous_everywhere:
  continuous -> forall x:point_set X, continuous_at x.

Lemma continuous_at_neighborhood_basis:
  forall (x:point_set X) (NB:Family (point_set Y)),
  neighborhood_basis NB (f x) ->
  (forall V:Ensemble (point_set Y),
  In NB V -> neighborhood (inverse_image f V) x) ->
  continuous_at x.

Lemma continuous_open_basis:
  forall (B:Family (point_set Y)), open_basis B ->
  (forall V:Ensemble (point_set Y),
    In B V -> open (inverse_image f V)) -> continuous.

Lemma continuous_subbasis:
  forall (SB:Family (point_set Y)), subbasis SB ->
  (forall V:Ensemble (point_set Y),
     In SB V -> open (inverse_image f V)) -> continuous.

End continuity.

Arguments continuous {X} {Y}.
Arguments continuous_at {X} {Y}.

Lemma continuous_composition_at: forall {X Y Z:TopologicalSpace}
  (f:point_set Y -> point_set Z) (g:point_set X -> point_set Y)
  (x:point_set X),
  continuous_at f (g x) -> continuous_at g x ->
  continuous_at (fun x:point_set X => f (g x)) x.

Lemma continuous_composition: forall {X Y Z:TopologicalSpace}
  (f:point_set Y -> point_set Z) (g:point_set X -> point_set Y),
  continuous f -> continuous g ->
  continuous (fun x:point_set X => f (g x)).

Lemma continuous_identity: forall (X:TopologicalSpace),
  continuous (fun x:point_set X => x).

Lemma continuous_constant: forall (X Y:TopologicalSpace)
  (y0:point_set Y), continuous (fun x:point_set X => y0).

Lemma continuous_at_is_local: forall (X Y:TopologicalSpace)
  (x0:point_set X) (f g:point_set X -> point_set Y)
  (N:Ensemble (point_set X)),
  neighborhood N x0 -> (forall x:point_set X, In N x -> f x = g x) ->
  continuous_at f x0 -> continuous_at g x0. *)

Lemma metric_space_fun_continuity_converse: forall (X Y:TopologicalSpace)
  (f:point_set X->point_set Y) (x:point_set X)
  (dX:point_set X -> point_set X -> R)
  (dY:point_set Y -> point_set Y -> R),
  metrizes X dX -> metrizes Y dY ->
  continuous_at f x -> forall eps:R, eps > 0 ->
                         exists delta:R, delta > 0 /\
                         forall x':point_set X, dX x x' < delta ->
                                        dY (f x) (f x') < eps.
Proof.
intros.
destruct (H x).
destruct (H0 (f x)).
assert (neighborhood (open_ball _ dY (f x) eps) (f x)).
apply open_neighborhood_is_neighborhood.
apply open_neighborhood_basis_elements0.
constructor; trivial.
apply H1 in H3.
destruct H3 as [U].
destruct H3.
destruct (open_neighborhood_basis_cond U H3) as [V].
destruct H5.
destruct H5 as [delta].
exists delta.
split; trivial.
intros.
assert (In (inverse_image f (open_ball _ dY (f x) eps)) x').
apply H4.
apply H6.
constructor.
trivial.
destruct H8.
destruct H8.
trivial.
Qed.

Lemma metric_space_fun_continuity: forall (X Y:TopologicalSpace)
  (f:point_set X->point_set Y) (x:point_set X)
  (dX:point_set X -> point_set X -> R)
  (dY:point_set Y -> point_set Y -> R),
  metrizes X dX -> metrizes Y dY ->
  (forall eps:R, eps > 0 -> exists delta:R, delta > 0 /\
                         forall x':point_set X, dX x x' < delta ->
                                        dY (f x) (f x') < eps) ->
  continuous_at f x.
Proof.
intros.
destruct (H x).
destruct (H0 (f x)).
red; intros.
destruct H2 as [V'].
destruct H2.
destruct (open_neighborhood_basis_cond0 V' H2).
destruct H4.
destruct H4 as [eps].
destruct (H1 eps H4) as [delta []].
exists (open_ball _ dX x delta).
split.
apply open_neighborhood_basis_elements.
constructor; trivial.
intros x' ?.
destruct H8.
constructor.
apply H3.
apply H5.
constructor.
apply H7; trivial.
Qed.

Require Export CountabilityAxioms.
(* CountabilityAxioms:
Require Export TopologicalSpaces.
From ZornsLemma Require Export CountableTypes.
Require Export NeighborhoodBases.
From ZornsLemma Require Import EnsemblesSpec.

Global Set Asymmetric Patterns.

Definition first_countable (X:TopologicalSpace) : Prop :=
  forall x:point_set X, exists NBx:Family (point_set X),
    neighborhood_basis NBx x /\ Countable NBx.

Lemma first_countable_open_neighborhood_bases:
  forall X:TopologicalSpace, first_countable X ->
    forall x:point_set X, exists NBx:Family (point_set X),
      open_neighborhood_basis NBx x /\ Countable NBx.

Require Export Nets.

Lemma first_countable_sequence_closure:
  forall (X:TopologicalSpace) (S:Ensemble (point_set X)) (x:point_set X),
  first_countable X -> In (closure S) x ->
  exists y:Net nat_DS X, (forall n:nat, In S (y n)) /\
                         net_limit y x.
Proof.
intros.
destruct (first_countable_open_neighborhood_bases _ H x) as [NB []].
destruct H2 as [g].
pose (U (n:nat) := IndexedIntersection
  (fun x: {x:{x:Ensemble (point_set X) | In NB x} | (g x < n)%nat} =>
     proj1_sig (proj1_sig x))).
assert (forall n:nat, open (U n)).
intros.
apply open_finite_indexed_intersection.
apply inj_finite with _ (fun x:{x:{x:Ensemble (point_set X) | In NB x}
                           | (g x < n)%nat} =>
  exist (fun m:nat => (m<n)%nat) (g (proj1_sig x)) (proj2_sig x)).
From ZornsLemma Require Import InfiniteTypes.
apply finite_nat_initial_segment.
red.
intros [[x0 P] p] [[y0 Q] q] ?.
simpl in H3.
From ZornsLemma Require Import Proj1SigInjective.

Inductive separable (X:TopologicalSpace) : Prop :=
  | intro_dense_ctbl: forall S:Ensemble (point_set X),
    Countable S -> dense S -> separable X.

Definition Lindelof (X:TopologicalSpace) : Prop :=
  forall cover:Family (point_set X),
    (forall U:Ensemble (point_set X),
       In cover U -> open U) ->
    FamilyUnion cover = Full_set ->
  exists subcover:Family (point_set X), Included subcover cover /\
     Countable subcover /\ FamilyUnion subcover = Full_set.

Inductive second_countable (X:TopologicalSpace) : Prop :=
  | intro_ctbl_basis: forall B:Family (point_set X),
    open_basis B -> Countable B -> second_countable X.

Lemma second_countable_impl_first_countable:
  forall X:TopologicalSpace, second_countable X -> first_countable X.

Lemma second_countable_impl_separable:
  forall X:TopologicalSpace, second_countable X -> separable X.
Proof.
intros.
destruct H.
Require Import ClassicalChoice.
destruct (choice (fun (U:{U:Ensemble (point_set X) | In B U /\ Inhabited U})
  (x:point_set X) => In (proj1_sig U) x)) as [choice_fun].
intros.
destruct x as [U [? ?]].
simpl.
destruct i0.
exists x; trivial.

exists (Im Full_set choice_fun).
apply countable_img.
red.
match goal with |- CountableT ?S =>
  pose (g := fun (x:S) =>
    match x return {U:Ensemble (point_set X) | In B U} with
    | exist (exist U (conj i _)) _ => exist _ U i
    end)
end.
apply inj_countable with g.
assumption.
red; intros.
unfold g in H2.
destruct x1 as [[U [? ?]]].
destruct x2 as [[V [? ?]]].
From ZornsLemma Require Import Proj1SigInjective.

Lemma second_countable_impl_Lindelof:
  forall X:TopologicalSpace, second_countable X -> Lindelof X. *)

Lemma metrizable_impl_first_countable: forall X:TopologicalSpace,
  metrizable X -> first_countable X.
Proof.
intros.
destruct H.
red; intros.
exists (Im [n:nat | (n>0)%nat]
           (fun n:nat => open_ball _ d x (/ (INR n)))).
split.
apply open_neighborhood_basis_is_neighborhood_basis.
constructor.
intros.
destruct H1 as [n ? V].
destruct H1.
apply H0.
rewrite H2; constructor.
auto with *.

intros.
destruct (H0 x).
destruct (open_neighborhood_basis_cond U) as [V [[eps] ?]]; trivial.
destruct (inverses_of_nats_approach_0 eps H2) as [n [? ?]].
exists (open_ball _ d x (/ (INR n))); split.
exists n; trivial.
constructor; trivial.
red; intros y ?.
apply H3.
destruct H6.
constructor.
apply Rlt_trans with (/ INR n); trivial.

apply countable_img.
apply countable_type_ensemble.
exists (fun n:nat => n).
red; intros; trivial.
Qed.

Lemma metrizable_separable_impl_second_countable:
  forall X:TopologicalSpace, metrizable X -> separable X ->
    second_countable X.
Proof.
intros.
destruct H.
destruct H0.
exists (Im [p:(Q*(point_set X))%type |
            let (r,x):=p in (r>0)%Q /\ In S x]
  (fun p:(Q*(point_set X))%type =>
      let (r,x):=p in open_ball _ d x (Q2R r))).
constructor.
intros.
destruct H3.
destruct H3.
destruct x as [r x].
destruct H3.
destruct (H1 x).
destruct (open_neighborhood_basis_elements y).
rewrite H4.
constructor; trivial.
assert (Q2R 0 = 0).
unfold Q2R.
simpl.
ring.
rewrite <- H6.
apply Qlt_Rlt; trivial.
assumption.

intros.
destruct (H1 x).
destruct (open_neighborhood_basis_cond U) as [V [[r]]].
split; trivial.

destruct (dense_meets_every_nonempty_open _ _ H2
  (open_ball _ d x (r/2))).
destruct (open_neighborhood_basis_elements
  (open_ball _ d x (r/2))).
constructor; trivial.
apply Rmult_lt_0_compat; auto with real.
destruct (open_neighborhood_basis_elements
  (open_ball (point_set X) d x (r/2))).
constructor; trivial.
apply Rmult_lt_0_compat; auto with real.
assumption.
exists x.
constructor.
rewrite metric_zero.
apply Rmult_lt_0_compat; auto with real.
trivial.

destruct H7.
destruct H8.

destruct (rationals_dense_in_reals (d x x0) (r - d x x0)) as [r'].
assert (d x x0 + d x x0 < r/2 + r/2).
auto with *.
assert (r/2 + r/2 = r).
field.
rewrite H10 in H9; clear H10.
assert ((d x x0 + d x x0) - d x x0 < r - d x x0).
unfold Rminus.
auto with *.
ring_simplify in H10.
ring_simplify.
assumption.

exists (open_ball _ d x0 (Q2R r')); repeat split.
exists ( (r', x0) ); auto.
constructor; split; trivial.
assert (Q2R r' > 0).
apply Rgt_ge_trans with (d x x0).
apply H9.
apply metric_nonneg; trivial.
apply Rlt_Qlt.
unfold Q2R at 1.
simpl.
ring_simplify.
assumption.

red; intros y ?.
destruct H10.
apply H6.
constructor.
apply Rle_lt_trans with (d x x0 + d x0 y).
apply triangle_inequality; trivial.
apply Rlt_trans with (d x x0 + Q2R r').
auto with *.
destruct H9.
assert (d x x0 + Q2R r' < d x x0 + (r - d x x0)).
auto with *.
ring_simplify in H12.
assumption.
destruct H9.
rewrite metric_sym; trivial.

apply countable_img.
destruct H0 as [h].

destruct (Q_countable).
destruct countable_nat_product as [g].

red.

match goal with |- CountableT ?T =>
exists (fun x:T =>
  match x with
  | exist (r, x0) (intro_characteristic_sat (conj r_pos i)) =>
    g (h (exist _ x0 i), f r)
  end)
end.
red; intros.
destruct x1 as [[r1 x1] [[pos_r1 i1]]].
destruct x2 as [[r2 x2] [[pos_r2 i2]]].
From ZornsLemma Require Import Proj1SigInjective.
apply subset_eq_compatT.
apply H4 in H5.
f_equal.
injection H5; intros.
apply H3; trivial.
injection H5; intros.
apply H0 in H7.
injection H7; trivial.
Qed.

Lemma metrizable_Lindelof_impl_second_countable:
  forall X:TopologicalSpace, metrizable X -> Lindelof X ->
    second_countable X.
Proof.
intros.
destruct H.
Require Import ClassicalChoice.
destruct (choice (fun (n:{n:nat | (n > 0)%nat}) (S:Family (point_set X)) =>
  Included S (Im Full_set (fun x:point_set X =>
                            open_ball _ d x (/ (INR (proj1_sig n)))))
  /\ Countable S /\ FamilyUnion S = Full_set))
as [choice_fun].
destruct x as [n].
apply H0.
intros.
destruct H2 as [x ? U].
destruct (H1 x).
Opaque In. apply open_neighborhood_basis_elements. Transparent In.
rewrite H3; constructor.
simpl.
auto with *.

apply Extensionality_Ensembles; split; red; intros.
constructor.
simpl.
exists (open_ball _ d x (/ INR n)).
exists x; trivial.
constructor.
rewrite metric_zero; auto with *.

exists (IndexedUnion choice_fun).
constructor.
intros.
destruct H3 as [n V].
destruct (H2 n) as [? [? ?]].
apply H4 in H3.
destruct H3 as [x ? V].
destruct (H1 x).
Opaque In. apply open_neighborhood_basis_elements. Transparent In.
rewrite H7; constructor.
destruct n as [n g].
simpl.
auto with *.

intros.
destruct (H1 x).
destruct (open_neighborhood_basis_cond U) as [V [? ?]].
split; trivial.
inversion H5.
destruct (inverses_of_nats_approach_0 (r/2)) as [n [? ?]].
apply Rmult_lt_0_compat; auto with *.
pose (nsig := exist (fun n:nat => (n>0)%nat) n H9).
destruct (H2 nsig) as [? [? ?]].
assert (In (FamilyUnion (choice_fun nsig)) x).
rewrite H13; constructor.
destruct H14 as [W].
pose proof (H11 _ H14).
destruct H16 as [y ? W].
rewrite H17 in H15; destruct H15.
exists W; repeat split.
exists nsig; trivial.
assert (Included W V); auto with *.
rewrite H17; rewrite <- H8.
red; intros z ?.
destruct H18.
constructor.
apply Rle_lt_trans with (d x y + d y z).
apply triangle_inequality; trivial.
rewrite (metric_sym _ d H x y).
apply Rlt_trans with (/ INR (proj1_sig nsig) + / INR (proj1_sig nsig)).
auto with *.
simpl.
assert (r = r/2 + r/2).
field.
rewrite H19; clear H19.
auto with *.
rewrite H17; constructor.
assumption.

apply countable_union.
apply countable_type_ensemble.
exists (fun n:nat => n).
red; intros; trivial.
intro.
destruct (H2 a) as [? [? ?]]; trivial.
Qed.

Section dist_to_set.

Variable X:Type.
Variable d:X->X->R.
Hypothesis d_is_metric: metric d.
Variable S:Ensemble X.
Hypothesis S_nonempty: Inhabited S.

Require Export SupInf.
(* SupInf:
Require Export Reals.
From ZornsLemma Require Import EnsemblesImplicit.
From ZornsLemma Require Import ImageImplicit.

Definition sup := completeness.

Open Scope R_scope.

Definition is_lower_bound (E:R->Prop) (m:R) :=
  forall x:R, E x -> x >= m.
Definition lower_bound (E:R->Prop) :=
  exists m:R, is_lower_bound E m.
Definition is_glb (E:R->Prop) (m:R) :=
  is_lower_bound E m /\ (forall b:R, is_lower_bound E b -> b <= m).

Definition inf: forall E:R->Prop, lower_bound E -> (exists x:R, E x) ->
  { m:R | is_glb E m }.

Lemma lub_approx: forall (S:Ensemble R) (m:R) (eps:R),
  is_lub S m -> eps > 0 -> exists x:R, In S x /\
    m - eps < x <= m.

Lemma glb_approx: forall (S:Ensemble R) (m:R) (eps:R),
  is_glb S m -> eps > 0 -> exists x:R, In S x /\ m <= x < m + eps.

Lemma lt_plus_epsilon_le: forall x y:R,
  (forall eps:R, eps > 0 -> x < y + eps) -> x <= y.

Lemma gt_minus_epsilon_ge: forall x y:R,
  (forall eps:R, eps > 0 -> x > y - eps) -> x >= y. *)

Definition dist_to_set (x:X) : R.
refine (proj1_sig (inf (Im S (d x)) _ _)).
exists 0.
red; intros.
destruct H.
rewrite H0; apply metric_nonneg; trivial.
destruct S_nonempty.
exists (d x x0); exists x0; trivial.
Defined.

Lemma dist_to_set_triangle_inequality: forall (x y:X),
  dist_to_set y <= dist_to_set x + d x y.
Proof.
intros.
unfold dist_to_set at 1; destruct inf as [dSy [? ?]].
simpl.
unfold dist_to_set at 1; destruct inf as [dSx].
simpl.
clear r.
apply lt_plus_epsilon_le.
intros.
destruct (glb_approx _ _ _ i0 H) as [dxz [[z]]].
rewrite H1 in H2; clear y0 H1.
destruct H2.
apply Rle_lt_trans with (d y z).
assert (d y z >= dSy); auto with *.
apply i.
exists z; trivial.
apply Rle_lt_trans with (d y x + d x z).
apply triangle_inequality; trivial.
rewrite (metric_sym _ _ d_is_metric y x).
replace (dSx + d x y + eps) with (d x y + (dSx + eps)).
auto with *.
ring.
Qed.

End dist_to_set.

Arguments dist_to_set {X}.
Arguments dist_to_set_triangle_inequality {X}.

Section dist_to_set_and_topology.

Variable X:TopologicalSpace.
Variable d:point_set X -> point_set X -> R.
Hypothesis d_is_metric: metric d.
Hypothesis d_metrizes_X: metrizes X d.
Variable S:Ensemble (point_set X).
Hypothesis S_nonempty: Inhabited S.

Lemma dist_to_set_zero_impl_closure: forall x:point_set X,
  dist_to_set d d_is_metric S S_nonempty x = 0 -> In (closure S) x.
Proof.
intros.
apply NNPP; intro.
destruct (d_metrizes_X x).
destruct (open_neighborhood_basis_cond (Complement (closure S))) as [V [? ?]].
split; trivial.
apply closure_closed.
destruct H1 as [r].
unfold dist_to_set in H.
destruct inf in H.
simpl in H.
rewrite H in i; clear x0 H.
destruct i.
assert (is_lower_bound (Im S (d x)) r).
red; intros y ?.
destruct H4 as [y].
rewrite H5; clear y0 H5.
destruct (total_order_T (d x y) r) as [[?|?]|?]; auto with *.
assert (In (open_ball _ d x r) y).
constructor; trivial.
apply H2 in H5.
contradiction H5.
apply closure_inflationary; trivial.
apply H3 in H4.
assert (0 < 0).
apply Rlt_le_trans with r; trivial.
revert H5; apply Rlt_irrefl.
Qed.

Lemma closure_impl_dist_to_set_zero: forall x:point_set X,
  In (closure S) x -> dist_to_set d d_is_metric S S_nonempty x = 0.
Proof.
intros.
unfold dist_to_set; destruct inf.
destruct i.
simpl.
apply Rle_antisym.
apply lt_plus_epsilon_le.
intros.
ring_simplify.
assert (exists y:point_set X, In S y /\ d x y < eps).
apply NNPP; intro.
pose proof (not_ex_all_not _ _ H1).
clear H1.
simpl in H2.
assert (In (interior (Complement S)) x).
exists (open_ball _ d x eps).
red; split.
destruct (d_metrizes_X x).
destruct (open_neighborhood_basis_elements (open_ball _ d x eps)).
constructor; trivial.
split.
assumption.

red; intros y ?.
destruct H4.
red; red; intro.
contradiction (H2 y).
split; trivial.

constructor.
rewrite metric_zero; trivial.

rewrite interior_complement in H1.
contradiction H1; trivial.

destruct H1 as [y [? ?]].
apply Rle_lt_trans with (d x y); trivial.
assert (d x y >= x0).
apply i.
exists y; trivial.
auto with *.

apply r.
red; intros.
destruct H0.
rewrite H1; apply metric_nonneg; trivial.
Qed.

Variable T:Ensemble (point_set X).
Hypothesis T_nonempty: Inhabited T.

Lemma closer_to_S_than_T_open: open
  [x:point_set X | dist_to_set d d_is_metric S S_nonempty x <
                   dist_to_set d d_is_metric T T_nonempty x].
Proof.
match goal with |- open ?U => assert (interior U = U) end.
apply Extensionality_Ensembles; split.
apply interior_deflationary.
red; intros.
destruct H.
match type of H with ?d1 < ?d2 => pose (eps := d2 - d1) end.
match goal with |- In (interior ?U) x =>
  assert (Included (open_ball _ d x (eps/2)) (interior U)) end.
apply interior_maximal.
destruct (d_metrizes_X x).
destruct (open_neighborhood_basis_elements
  (open_ball _ d x (eps/2))).
constructor.
assert (eps > 0).
apply Rgt_minus; auto with *.
apply Rmult_gt_0_compat; auto with *.
assumption.
red; intros.
destruct H0.
constructor.
apply Rle_lt_trans with
  (dist_to_set d d_is_metric S S_nonempty x +
   d x x0).
apply dist_to_set_triangle_inequality.
apply Rlt_le_trans with
  (dist_to_set d d_is_metric T T_nonempty x - d x x0).
apply Rminus_lt.
ring_simplify.
assert (2 * d x x0 < eps).
replace eps with (2 * (eps / 2)).
auto with *.
field.
match goal with |- ?LHS < 0 => replace LHS with (2 * d x x0 - eps) end.
apply Rlt_minus; trivial.
unfold eps; ring.

assert (dist_to_set d d_is_metric T T_nonempty x <=
        dist_to_set d d_is_metric T T_nonempty x0 + d x x0).
rewrite (metric_sym _ d d_is_metric x x0).
apply dist_to_set_triangle_inequality.
apply Rminus_le.
apply Rle_minus in H1.
match type of H1 with ?A <= 0 =>
  match goal with |- ?B <= 0 =>
    replace B with A end end.
assumption.
ring.

apply H0.
constructor.
rewrite metric_zero.
apply Rmult_gt_0_compat; auto with *.
apply Rgt_minus; trivial.
trivial.

rewrite <- H; apply interior_open.
Qed.

End dist_to_set_and_topology.

Require Export SeparatednessAxioms.
(* SeparatednessAxioms:
Require Export TopologicalSpaces.
Require Import InteriorsClosures.

Definition T0_sep (X:TopologicalSpace) : Prop :=
  forall x y:point_set X, x <> y ->
  (exists U:Ensemble (point_set X), open U /\ In U x /\ ~ In U y) \/
  (exists U:Ensemble (point_set X), open U /\ ~ In U x /\ In U y).

Definition T1_sep (X:TopologicalSpace) : Prop :=
  forall x:point_set X, closed (Singleton x).

Definition Hausdorff (X:TopologicalSpace) : Prop :=
  forall x y:point_set X, x <> y ->
    exists U:Ensemble (point_set X),
    exists V:Ensemble (point_set X),
  open U /\ open V /\ In U x /\ In V y /\
  Intersection U V = Empty_set.
Definition T2_sep := Hausdorff.

Definition T3_sep (X:TopologicalSpace) : Prop :=
  T1_sep X /\
  forall (x:point_set X) (F:Ensemble (point_set X)),
  closed F -> ~ In F x -> exists U:Ensemble (point_set X),
                          exists V:Ensemble (point_set X),
        open U /\ open V /\ In U x /\ Included F V /\
        Intersection U V = Empty_set.

Definition normal_sep (X:TopologicalSpace) : Prop :=
  T1_sep X /\
  forall (F G:Ensemble (point_set X)),
  closed F -> closed G -> Intersection F G = Empty_set ->
  exists U:Ensemble (point_set X), exists V:Ensemble (point_set X),
  open U /\ open V /\ Included F U /\ Included G V /\
  Intersection U V = Empty_set.
Definition T4_sep := normal_sep.

Lemma T1_sep_impl_T0_sep: forall X:TopologicalSpace,
  T1_sep X -> T0_sep X.

Lemma Hausdorff_impl_T1_sep: forall X:TopologicalSpace,
  Hausdorff X -> T1_sep X.

Lemma T3_sep_impl_Hausdorff: forall X:TopologicalSpace,
  T3_sep X -> Hausdorff X.

Lemma normal_sep_impl_T3_sep: forall X:TopologicalSpace,
  normal_sep X -> T3_sep X.

Section Hausdorff_and_nets.
Require Export Nets.

Lemma Hausdorff_impl_net_limit_unique:
  forall {X:TopologicalSpace} {I:DirectedSet} (x:Net I X),
    Hausdorff X -> uniqueness (net_limit x).

Lemma Hausdorff_impl_net_limit_is_unique_cluster_point:
  forall {X:TopologicalSpace} {I:DirectedSet} (x:Net I X)
    (x0:point_set X), Hausdorff X -> net_limit x x0 ->
    forall y:point_set X, net_cluster_point x y -> y = x0.

Lemma net_limit_is_unique_cluster_point_impl_Hausdorff:
  forall (X:TopologicalSpace),
  (forall (I:DirectedSet) (x:Net I X) (x0 y:point_set X),
  net_limit x x0 -> net_cluster_point x y ->
  y = x0) -> Hausdorff X.

Lemma net_limit_uniqueness_impl_Hausdorff:
  forall X:TopologicalSpace,
  (forall (I:DirectedSet) (x:Net I X), uniqueness (net_limit x)) ->
  Hausdorff X.

End Hausdorff_and_nets. *)

Lemma metrizable_impl_normal_sep: forall X:TopologicalSpace,
  metrizable X -> normal_sep X.
Proof.
intros.
destruct H.
split.
red; intros.
assert (closure (Singleton x) = Singleton x).
apply Extensionality_Ensembles; split.
red; intros.
assert (x0 = x).
apply metric_strict with d; trivial.
apply NNPP; intro.
assert (d x0 x > 0).
destruct (total_order_T (d x0 x) 0) as [[?|?]|?]; trivial.
assert (0 < 0).
apply Rle_lt_trans with (d x0 x); trivial.
assert (d x0 x >= 0); auto with *.
apply metric_nonneg; trivial.
contradict H3; apply Rlt_irrefl.
contradiction H2.

assert (In (interior (Complement (Singleton x))) x0).
exists (open_ball _ d x0 (d x0 x)).
split.
destruct (H0 x0).
destruct (open_neighborhood_basis_elements
  (open_ball (point_set X) d x0 (d x0 x))).
constructor; trivial.
split.
assumption.
red; intros.
intro.
destruct H7.
destruct H6.
revert H6; apply Rlt_irrefl.
constructor.
rewrite metric_zero; trivial.

rewrite interior_complement in H4.
contradiction H4.

rewrite H2; constructor.

apply closure_inflationary.

rewrite <- H1; apply closure_closed.

intros.
From ZornsLemma Require Import DecidableDec.
case (classic_dec (Inhabited F)); intro.
case (classic_dec (Inhabited G)); intro.

pose (U := [ x:point_set X | dist_to_set d H F i x <
                             dist_to_set d H G i0 x ]).
pose (V := [ x:point_set X | dist_to_set d H G i0 x <
                             dist_to_set d H F i x ]).
exists U; exists V; repeat split.
apply closer_to_S_than_T_open; trivial.
apply closer_to_S_than_T_open; trivial.
replace (dist_to_set d H F i x) with 0.
destruct (total_order_T 0 (dist_to_set d H G i0 x)) as [[?|?]|?]; trivial.
symmetry in e.
apply dist_to_set_zero_impl_closure in e.
rewrite closure_fixes_closed in e; trivial.
assert (In Empty_set x).
rewrite <- H3; constructor; trivial.
destruct H5.
trivial.

assert (0 < 0).
apply Rle_lt_trans with (dist_to_set d H G i0 x); auto with sets.
unfold dist_to_set; destruct inf.
simpl.
apply i1.
red; intros.
destruct H5.
rewrite H6; apply metric_nonneg; trivial.
contradict H5; apply Rlt_irrefl.

unfold dist_to_set; destruct inf.
simpl.
apply Rle_antisym.
apply i1.
red; intros.
destruct H5.
rewrite H6; apply metric_nonneg; trivial.
destruct i1.
assert (0 >= x0); auto with *.
apply H5.
exists x; trivial.
symmetry; apply metric_zero; trivial.

replace (dist_to_set d H G i0 x) with 0.
destruct (total_order_T 0 (dist_to_set d H F i x)) as [[?|?]|?]; trivial.
symmetry in e.
apply dist_to_set_zero_impl_closure in e.
rewrite closure_fixes_closed in e; trivial.
assert (In Empty_set x).
rewrite <- H3; constructor; trivial.
destruct H5.
trivial.

assert (0 < 0).
apply Rle_lt_trans with (dist_to_set d H F i x); auto with *.
unfold dist_to_set; destruct inf.
simpl.
apply i1.
red; intros.
destruct H5.
rewrite H6; apply metric_nonneg; trivial.
contradict H5; apply Rlt_irrefl.

symmetry.
apply closure_impl_dist_to_set_zero; trivial.
apply closure_inflationary; trivial.

apply Extensionality_Ensembles; split; auto with sets.
red; intros.
destruct H4.
destruct H4.
destruct H5.
contradict H5.
auto with *.

exists Full_set; exists Empty_set; repeat split; auto with topology.
red; intros.
contradiction n.
exists x; trivial.

auto with sets.

exists Empty_set; exists Full_set; repeat split; auto with topology.
red; intros.
contradiction n.
exists x; trivial.
auto with sets.
Qed.
