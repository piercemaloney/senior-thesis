
Require Export reduce.
(* reduce:
Require Export Bool. 
Require Export fifo. 

Unset Standard Proposition Elimination Names.

Section REDUCE.

Variable E : Set.

Variable f : E -> Z.

Fixpoint reduce (q : queue E) : Z :=
  match q with
  | empty => 0%Z
  | input d q' => (reduce q' + f d)%Z
  end.

Hypothesis positive_function : forall a : E, (f a > 0)%Z.

Lemma sum_positive :
 forall a b : Z, (a >= 0)%Z -> (b > 0)%Z -> (a + b >= 0)%Z.

Lemma reduce_nil : reduce (empty E) = 0%Z.

Lemma reduce_null_fun :
 forall q : queue E, (forall d : E, f d = 0%Z) -> reduce q = 0%Z.

Lemma reduce_positive : forall q : queue E, (reduce q >= 0)%Z.

Lemma reduce_append :
 forall (q1 : queue E) (d : E) (q2 : queue E),
 reduce (append E q1 (input E d q2)) = (reduce (append E q1 q2) + f d)%Z.

Lemma reduce_append_nil1 :
 forall (d : E) (q2 : queue E), reduce (input E d q2) = (reduce q2 + f d)%Z.

Lemma reduce_append_nil2 :
 forall (q1 : queue E) (d : E),
 reduce (append E q1 (input E d (empty E))) = (reduce q1 + f d)%Z.

Lemma reduce_append_nil2_symmetric :
 forall (q1 : queue E) (d : E),
 reduce q1 = (reduce (append E q1 (input E d (empty E))) - f d)%Z.

End REDUCE.

Section DISJOINT.

Variable E : Set.

Definition fun_or (pred1 pred2 : E -> bool) (a : E) := pred1 a || pred2 a.

Definition fun_sum (f1 f2 : E -> Z) (a : E) := (f1 a + f2 a)%Z.

Definition fun_minus (f1 f2 : E -> Z) (a : E) := (f1 a - f2 a)%Z.

Variable f : E -> Z.

Lemma disjoint_reduce :
 forall (f1 f2 : E -> Z) (q : queue E),
 reduce E (fun_sum f1 f2) q = (reduce E f1 q + reduce E f2 q)%Z.

Lemma disjoint_reduce3 :
 forall (f1 f2 : E -> Z) (q : queue E),
 reduce E (fun_minus f1 f2) q = (reduce E f1 q - reduce E f2 q)%Z.

Lemma reduce_simpl :
 forall (f1 f2 : E -> Z) (q : queue E),
 (forall d : E, f1 d = f2 d) -> reduce E f1 q = reduce E f2 q.

End DISJOINT.

Section REDUCE_MORE.

Variable data : Set.
Hypothesis eq_data_dec : eq_dec data.

Variable f : data -> Z.

Lemma reduce_first_out :
 forall (q : queue data) (m : data),
 first data q = value data m ->
 reduce data f (first_out data q) = (reduce data f q - f m)%Z.

End REDUCE_MORE.

Section reduce_pos.

Variable E : Set.

Variable f : E -> Z.
Hypothesis positive_function : forall a : E, (f a >= 0)%Z.

Lemma reduce_positive_or_null : forall q : queue E, (reduce E f q >= 0)%Z.

End reduce_pos.

Section reduce_strictly_pos.

Variable E : Set.

Variable f : E -> Z.
Hypothesis positive_function : forall a : E, (f a >= 0)%Z.

Hypothesis eq_E_dec : eq_dec E.

Lemma reduce_in_queue_strictly_positive :
 forall (x : E) (q : queue E),
 (f x > 0)%Z -> In_queue E x q -> (reduce E f q > 0)%Z.
End reduce_strictly_pos.

Section reduce_in_q_null.
Variable E : Set.

Variable f : E -> Z.

Hypothesis eq_E_dec : eq_dec E.

Lemma reduce_in_queue_null :
 forall q : queue E,
 (forall x : E, In_queue E x q -> f x = 0%Z) -> reduce E f q = 0%Z.

End reduce_in_q_null. *)
Require Export table.
(* table:
Require Import List.
Require Export finite.

Unset Standard Proposition Elimination Names.

Section TABLE1.

Variable E F : Set.
Hypothesis eq_E_dec : eq_dec E.
Variable t : E -> F.
Variable x0 : E.
Variable y0 : F.

Definition change_x0 (x : E) :=
  if eq_E_dec x0 x then y0 else t x.

Lemma here : change_x0 x0 = y0.
	
Lemma elsewhere : forall x : E, x0 <> x -> change_x0 x = t x.

End TABLE1.

Section TABLE2.

Variable E F G : Set.
Hypothesis eq_E_dec : eq_dec E.
Hypothesis eq_F_dec : eq_dec F.
Variable t : E -> F -> G.
Variable x0 : E.
Variable y0 : F.
Variable z0 : G.

Definition change_x0y0 :=
  change_x0 E (F -> G) eq_E_dec t x0 (change_x0 F G eq_F_dec (t x0) y0 z0).

Lemma here2 : change_x0y0 x0 y0 = z0.
                     
Remark elsewhere2_x : forall x : E, x <> x0 -> change_x0y0 x = t x.

Remark elsewhere2_y :
 forall y : F,
 y <> y0 -> (fun x : E => change_x0y0 x y) = (fun x : E => t x y).

Lemma elsewhere2 :
 forall (x : E) (y : F), x <> x0 \/ y <> y0 -> change_x0y0 x y = t x y. 
	
End TABLE2.
 
Section CHANGE_SUM1.

Variable E : Set.
Hypothesis eq_E_dec : eq_dec E.
Variable f : E -> Z.
Variable x0 : E.
Variable y0 : Z.

Lemma sigma_nowhere :
 forall l : list E,
 ~ In x0 l -> sigma E l (change_x0 E Z eq_E_dec f x0 y0) = sigma E l f. 

Lemma sigma_change :
 forall l : list E,
 only_once E eq_E_dec x0 l ->
 sigma E l (change_x0 E Z eq_E_dec f x0 y0) = (sigma E l f - f x0 + y0)%Z.
 	
End CHANGE_SUM1.

Section SUM1_S.

Variable E : Set.
Hypothesis eq_E_dec : eq_dec E.
Variable L : list E.
Hypothesis finite_E : list_of_elements E eq_E_dec L.
Variable f : E -> Z.
Variable x0 : E.

Remark sigma_change_S :
 sigma E L (change_x0 E Z eq_E_dec f x0 (f x0 + 1)%Z) = (sigma E L f + 1)%Z.    

Lemma sigma__S :
 forall g : E -> Z,
 g x0 = (f x0 + 1)%Z ->
 (forall x : E, x <> x0 -> g x = f x) -> sigma E L g = (sigma E L f + 1)%Z.    
   
Remark sigma_change_pred :
 sigma E L (change_x0 E Z eq_E_dec f x0 (f x0 - 1)%Z) = (sigma E L f - 1)%Z.    
   
Lemma sigma__pred :
 forall g : E -> Z,
 g x0 = (f x0 - 1)%Z ->
 (forall x : E, x <> x0 -> g x = f x) -> sigma E L g = (sigma E L f - 1)%Z.    
 
End SUM1_S. *)
Require Export abstract_machine.
(* abstract_machine:
Require Import List.
Require Export fifo.
Require Export table. 
Require Export reduce. 
Require Export sigma2. 

Unset Standard Proposition Elimination Names.

Section MACHINE.

Parameter Site : Set. 
Parameter owner : Site.

Axiom eq_site_dec : eq_dec Site. 

Definition change_site (E : Set) := change_x0 Site E eq_site_dec.

Lemma that_site :
 forall (E : Set) (f : Site -> E) (s0 : Site) (x : E),
 change_site E f s0 x s0 = x.

Lemma other_site :
 forall (E : Set) (f : Site -> E) (s0 s1 : Site) (x : E),
 s0 <> s1 -> change_site E f s0 x s1 = f s1.

Definition eq_queue_dec := eq_couple_dec Site Site eq_site_dec eq_site_dec.

Definition change_queue (Q : Set) := update2_table Site eq_site_dec Q.

Lemma that_queue :
 forall (E : Set) (f : Site -> Site -> E) (s0 s1 : Site) (x : E),
 change_queue E f s0 s1 x s0 s1 = x.

Lemma other_queue :
 forall (E : Set) (f : Site -> Site -> E) (s0 s1 s2 s3 : Site) (x : E),
 s2 <> s0 \/ s3 <> s1 -> change_queue E f s0 s1 x s2 s3 = f s2 s3.

Parameter LS : list Site.

Axiom finite_site : list_of_elements Site eq_site_dec LS.

Lemma in_s_LS : forall s : Site, In s LS.

Variable Data : Set.

Definition Bag_of_Data := Site -> Site -> queue Data.

End MACHINE.

Section M_ACTION.

Variable Message : Set.
Let Bag_of_message := Bag_of_Data Message.

Definition Post_message (m0 : Message) (b0 : Bag_of_message)
  (s0 s1 : Site) :=
  change_queue (queue Message) b0 s0 s1 (input Message m0 (b0 s0 s1)).

Definition Collect_message (b0 : Bag_of_message) (s0 s1 : Site) :=
  change_queue (queue Message) b0 s0 s1 (first_out Message (b0 s0 s1)).

Lemma post_here :
 forall (b0 : Bag_of_message) (m0 : Message) (s0 s1 : Site),
 Post_message m0 b0 s0 s1 s0 s1 = input Message m0 (b0 s0 s1).

Lemma post_elsewhere :
 forall (b0 : Bag_of_message) (m0 : Message) (s0 s1 s2 s3 : Site),
 s0 <> s2 \/ s1 <> s3 -> Post_message m0 b0 s0 s1 s2 s3 = b0 s2 s3.

Lemma collect_here :
 forall (b0 : Bag_of_message) (s0 s1 : Site),
 Collect_message b0 s0 s1 s0 s1 = first_out Message (b0 s0 s1).

Lemma collect_elsewhere :
 forall (b0 : Bag_of_message) (s0 s1 s2 s3 : Site),
 s0 <> s2 \/ s1 <> s3 -> Collect_message b0 s0 s1 s2 s3 = b0 s2 s3.

End M_ACTION.

Section IN_Q_EFFECT.

Variable Message : Set.
Let Bag_of_message := Bag_of_Data Message.

Lemma in_post :
 forall (m m' : Message) (bom : Bag_of_message) (s1 s2 s3 s4 : Site),
 m <> m' ->
 In_queue Message m (Post_message Message m' bom s1 s2 s3 s4) ->
 In_queue Message m (bom s3 s4).

Lemma not_in_post :
 forall (m m' : Message) (bom : Bag_of_message) (s1 s2 s3 s4 : Site),
 m <> m' ->
 ~ In_queue Message m (bom s3 s4) ->
 ~ In_queue Message m (Post_message Message m' bom s1 s2 s3 s4).

Lemma not_in_collect :
 forall (m : Message) (bom : Bag_of_message) (s1 s2 s3 s4 : Site),
 ~ In_queue Message m (bom s3 s4) ->
 ~ In_queue Message m (Collect_message Message bom s1 s2 s3 s4).

Lemma in_collect :
 forall (m : Message) (bom : Bag_of_message) (s1 s2 s3 s4 : Site),
 In_queue Message m (Collect_message Message bom s1 s2 s3 s4) ->
 In_queue Message m (bom s3 s4).

Hypothesis eq_message_dec : eq_dec Message.

Lemma in_queue_decidable :
 forall (m : Message) (q : queue Message),
 {In_queue Message m q} + {~ In_queue Message m q}.

End IN_Q_EFFECT.

Section REDUCE_EFFECT.

Variable Message : Set.
Let Bag_of_message := Bag_of_Data Message.

Variable f : Message -> Z.

Lemma reduce_post_message :
 forall (m : Message) (s1 s2 : Site) (b : Bag_of_message),
 reduce Message f (Post_message Message m b s1 s2 s1 s2) =
 (reduce Message f (b s1 s2) + f m)%Z.

Lemma reduce_collect_message :
 forall (m : Message) (s1 s2 : Site) (b : Bag_of_message),
 first Message (b s1 s2) = value Message m ->
 reduce Message f (Collect_message Message b s1 s2 s1 s2) =
 (reduce Message f (b s1 s2) - f m)%Z.

Lemma reduce_post_message_null :
 forall (m : Message) (s1 s2 s3 s4 : Site) (b : Bag_of_message),
 f m = 0%Z ->
 reduce Message f (Post_message Message m b s1 s2 s3 s4) =
 reduce Message f (b s3 s4).

Lemma reduce_collect_message_null :
 forall (m : Message) (s1 s2 s3 s4 : Site) (b : Bag_of_message),
 first Message (b s1 s2) = value Message m ->
 f m = 0%Z ->
 reduce Message f (Collect_message Message b s1 s2 s3 s4) =
 reduce Message f (b s3 s4).

End REDUCE_EFFECT.

Section SIG_SEND.

Let Send_T := Site -> Z.

Definition sigma_send_table (t : Send_T) :=
  sigma_table Site LS Z (fun (s : Site) (x : Z) => x) t.

Definition Inc_send_table (t0 : Send_T) (s0 : Site) :=
  update_table Site eq_site_dec Z t0 s0 (t0 s0 + 1)%Z.  

Definition Dec_send_table (t0 : Send_T) (s0 : Site) :=
  update_table Site eq_site_dec Z t0 s0 (t0 s0 - 1)%Z.  

Let Date_T := Site -> nat.

Definition Set_date_table (d0 : Date_T) (s0 : Site) 
  (new_date : nat) := update_table Site eq_site_dec nat d0 s0 new_date.

End SIG_SEND.

Section SEND_EFFECT.

Let Send_T := Site -> Z.

Lemma sigma_inc_send_table :
 forall (t : Send_T) (s : Site),
 sigma_send_table (Inc_send_table t s) = (sigma_send_table t + 1)%Z.

Lemma sigma_dec_send_table :
 forall (t : Send_T) (s : Site),
 sigma_send_table (Dec_send_table t s) = (sigma_send_table t - 1)%Z.

End SEND_EFFECT. 

Section SIG_RECV.

Let Recv_T := Site -> bool.

Definition sigma_receive_table (t : Recv_T) :=
  sigma_table Site LS bool (fun s : Site => Int) t.

Definition Set_rec_table (r0 : Recv_T) (s0 : Site) :=
  change_site bool r0 s0 true.

Definition Reset_rec_table (r0 : Recv_T) (s0 : Site) :=
  change_site bool r0 s0 false.

Lemma sigma_set_receive_table :
 forall (t : Recv_T) (s : Site),
 t s = false ->
 sigma_receive_table (Set_rec_table t s) = (sigma_receive_table t + 1)%Z.

Lemma sigma_reset_receive_table :
 forall (t : Recv_T) (s : Site),
 t s = true ->
 sigma_receive_table (Reset_rec_table t s) = (sigma_receive_table t - 1)%Z.

End SIG_RECV.

Section BUT_OWNER.

Variable Data : Set.
Let Table := Site -> Data.
Variable f : Site -> Data -> Z.

Definition sigma_table_but_owner (st : Table) :=
  sigma_but Site owner eq_site_dec LS (fun s : Site => f s (st s)).

Lemma sigma_sigma_but_owner :
 forall t : Table,
 sigma_table Site LS Data f t =
 (sigma_table_but_owner t + f owner (t owner))%Z.

End BUT_OWNER. *)

Section SUM_REDUCE.

Variable Data : Set.

Variable s0 : Site.

Let Bag_of_message := Bag_of_Data Data.

Variable f : Data -> Z.

Definition sigma_reduce (bom : Bag_of_message) :=
  sigma Site LS (fun si : Site => reduce Data f (bom s0 si)). 

Lemma sigma_reduce_pos :
 forall (s0 s1 : Site) (bom : Bag_of_message),
 (forall m : Data, (f m > 0)%Z) -> (sigma_reduce bom >= 0)%Z.
Proof.
  intros s1 s2 bom H.
  unfold sigma_reduce in |- *.
  apply sigma_pos.
  intro x_.
  apply reduce_positive.
  auto.
Qed.

End SUM_REDUCE.