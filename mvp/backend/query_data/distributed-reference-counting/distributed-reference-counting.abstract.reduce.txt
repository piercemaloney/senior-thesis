
Require Export Bool. 
Require Export fifo. 
(* fifo:
Require Export bibli.

Unset Standard Proposition Elimination Names.

Section DEF_FIFO.

Variable data : Set.

Inductive queue : Set :=
  | empty : queue
  | input : data -> queue -> queue.
	
Inductive exc : Set :=
  | value : data -> exc
  | error : exc.
	
Definition last (q : queue) :=
  match q with
  | empty => error
  | input d _ => value d
  end.

Fixpoint first (q : queue) : exc :=
  match q with
  | empty => error
  | input d q' =>
      match q' with
      | empty => value d
      | input _ _ => first q'
      end
  end.
	
Fixpoint first_out (q : queue) : queue :=
  match q with
  | empty => empty
  | input d q' =>
      match q' with
      | empty => empty
      | input _ _ => input d (first_out q')
      end
  end.
	
Fixpoint In_queue (d : data) (q : queue) {struct q} : Prop :=
  match q with
  | empty => False
  | input d' q' => d = d' \/ In_queue d q'
  end.
	
Lemma not_in_empty : forall d : data, ~ In_queue d empty.

Hypothesis eq_data_dec : eq_dec data.

Fixpoint card (d : data) (q : queue) {struct q} : Z :=
  match q with
  | empty => 0%Z
  | input d' q' =>
      if eq_data_dec d d'
      then (card d q' + 1)%Z
      else card d q'
  end.

Lemma card_pos : forall (d : data) (q : queue), (card d q >= 0)%Z.

Lemma card_strct_pos :
 forall (d : data) (q : queue), In_queue d q -> (card d q > 0)%Z.

Lemma card_null :
 forall (d : data) (q : queue), ~ In_queue d q -> card d q = 0%Z.

End DEF_FIFO.

Section BELONG.

Variable data : Set.

Lemma first_in :
 forall (d : data) (q : queue data),
 first data q = value data d -> In_queue data d q.

Lemma in_q_input :
 forall (d' d : data) (q : queue data),
 d <> d' -> In_queue data d (input data d' q) -> In_queue data d q.

Lemma not_in_q_input :
 forall (data : Set) (d' d : data) (q : queue data),
 d <> d' -> ~ In_queue data d (input data d' q) -> ~ In_queue data d q.
		
Lemma in_q_output :
 forall (d : data) (q : queue data),
 In_queue data d (first_out data q) -> In_queue data d q.

Lemma not_in_q_output :
 forall (data : Set) (d : data) (q : queue data),
 ~ In_queue data d q -> ~ In_queue data d (first_out data q).

Hypothesis eq_data_dec : eq_dec data.

Lemma equality_from_queue_membership :
 forall (x y : data) (q : queue data),
 In_queue data y q -> ~ In_queue data x q -> x <> y.

End BELONG.

Section MORE_NOT_INQ.

Variable data : Set.

Hypothesis eq_data_dec : eq_dec data.

Lemma not_in_q_input2 :
 forall (d' d : data) (q : queue data),
 ~ In_queue data d (input data d' q) -> ~ In_queue data d q.
		
End MORE_NOT_INQ.

Section OCCUR.

Variable data : Set.

Hypothesis eq_data_dec : eq_dec data.

Lemma input_S_card :
 forall (d d' : data) (q : queue data),
 d = d' ->
 card data eq_data_dec d (input data d' q) =
 (card data eq_data_dec d q + 1)%Z.

Lemma input_diff_card :
 forall (d d' : data) (q : queue data),
 d <> d' ->
 card data eq_data_dec d (input data d' q) = card data eq_data_dec d q.

Lemma firstout_pred_card :
 forall (d : data) (q : queue data),
 first data q = value data d ->
 card data eq_data_dec d (first_out data q) =
 (card data eq_data_dec d q - 1)%Z.

Lemma firstout_diff_card :
 forall (d : data) (q : queue data),
 first data q <> value data d ->
 card data eq_data_dec d (first_out data q) = card data eq_data_dec d q.

End OCCUR.

Section APPEND.

Variable data : Set.

Fixpoint append (q : queue data) : queue data -> queue data :=
  fun q2 : queue data =>
  match q with
  | empty => q2
  | input d q' => input data d (append q' q2)
  end.

Lemma append_nil1 : forall q : queue data, append (empty data) q = q.

Lemma append_nil2 : forall q : queue data, append q (empty data) = q.

Lemma input_append :
 forall (d : data) (q1 q2 : queue data),
 input data d (append q1 q2) = append (input data d q1) q2.

Lemma append_assoc :
 forall q1 q2 q3 : queue data,
 append q1 (append q2 q3) = append (append q1 q2) q3.

Lemma append_right_non_empty :
 forall (q1 q2 : queue data) (d : data),
 append q1 (input data d q2) <> empty data.

Lemma case_append_right :
 forall (E : Set) (x y : E) (q1 q2 : queue data) (d : data),
 match append q1 (input data d q2) with
 | empty => x
 | input _ _ => y
 end = y. 

Lemma case_first_value :
 forall (E : Set) (x y : E) (d : data) (q : queue data),
 first data q = value data d ->
 match q with
 | empty => x
 | input _ _ => y
 end = y. 

Lemma append_first_out :
 forall (q1 : queue data) (d : data),
 first_out data (append q1 (input data d (empty data))) = q1.

Lemma append_first :
 forall (q1 : queue data) (d : data),
 first data (append q1 (input data d (empty data))) = value data d.

Lemma first_out_input :
 forall (d0 d1 : data) (q : queue data),
 first_out data (input data d0 (input data d1 q)) =
 input data d0 (first_out data (input data d1 q)).

Lemma first_input :
 forall (d0 d1 : data) (q : queue data),
 first data (input data d0 (input data d1 q)) = first data (input data d1 q).

Lemma append_first_out2 :
 forall (d : data) (q1 : queue data),
 first data q1 = value data d ->
 append (first_out data q1) (input data d (empty data)) = q1.

End APPEND.

Section INQUEUE_APPEND.

Variable data : Set.

Lemma inqueue_append :
 forall (m : data) (q1 q2 : queue data),
 In_queue data m q1 \/ In_queue data m q2 ->
 In_queue data m (append data q1 q2).

Lemma not_inqueue_append :
 forall (m : data) (q1 q2 : queue data),
 ~ In_queue data m q1 /\ ~ In_queue data m q2 ->
 ~ In_queue data m (append data q1 q2).

Lemma in_q_shuffle1 :
 forall (m1 m2 : data) (q3 q4 : queue data),
 In_queue data m2 (input data m1 (append data q3 q4)) ->
 In_queue data m2 (append data q3 (input data m1 q4)).

Lemma not_in_q_shuffle1 :
 forall (m1 m2 : data) (q3 q4 : queue data),
 ~ In_queue data m2 (input data m1 (append data q3 q4)) ->
 ~ In_queue data m2 (append data q3 (input data m1 q4)).

Lemma not_in_q_shuffle :
 forall (m1 m2 : data) (q1 q2 q3 q4 : queue data),
 ~ In_queue data m2 (append data q1 (input data m1 q2)) ->
 append data q1 q2 = append data q3 q4 ->
 ~ In_queue data m2 (append data q3 (input data m1 q4)).

Lemma in_q_shuffle :
 forall (m1 m2 : data) (q1 q2 q3 q4 : queue data),
 In_queue data m2 (append data q3 (input data m1 q4)) ->
 append data q1 q2 = append data q3 q4 ->
 In_queue data m2 (append data q1 (input data m1 q2)).

End INQUEUE_APPEND. *)

Unset Standard Proposition Elimination Names.

Section REDUCE.

Variable E : Set.

Variable f : E -> Z.

Fixpoint reduce (q : queue E) : Z :=
  match q with
  | empty => 0%Z
  | input d q' => (reduce q' + f d)%Z
  end.

Hypothesis positive_function : forall a : E, (f a > 0)%Z.

Lemma sum_positive :
 forall a b : Z, (a >= 0)%Z -> (b > 0)%Z -> (a + b >= 0)%Z.
Proof.
 intros a b H H0.
 omega.
Qed.

Lemma reduce_nil : reduce (empty E) = 0%Z.
Proof.
 simpl in |- *.
 trivial.
Qed.

Lemma reduce_null_fun :
 forall q : queue E, (forall d : E, f d = 0%Z) -> reduce q = 0%Z.
Proof.
  intro; elim q.
  intro; apply reduce_nil.
  intros; simpl in |- *.
  rewrite H.
  rewrite H0.
  auto.
  auto.
Qed.

Lemma reduce_positive : forall q : queue E, (reduce q >= 0)%Z.
Proof.
  intros q.
  elim q.
  simpl in |- *.
  omega.
  intros d q0 H.
  simpl in |- *.
  apply sum_positive.
  auto.
  exact (positive_function d).
Qed.

Lemma reduce_append :
 forall (q1 : queue E) (d : E) (q2 : queue E),
 reduce (append E q1 (input E d q2)) = (reduce (append E q1 q2) + f d)%Z.

Proof.
  intro q1.
  elim q1.
  intros d q2.
  rewrite append_nil1.
  auto.
  
  intros d q H d0 q2.
  rewrite <- input_append.
  simpl in |- *.
  rewrite H.
  omega.
Qed.

Lemma reduce_append_nil1 :
 forall (d : E) (q2 : queue E), reduce (input E d q2) = (reduce q2 + f d)%Z.
Proof.
  intros d q2.
  rewrite <- (append_nil1 E (input E d q2)).
  pattern q2 at 2 in |- *.
  rewrite <- (append_nil1 E q2).
  apply reduce_append.
Qed.

Lemma reduce_append_nil2 :
 forall (q1 : queue E) (d : E),
 reduce (append E q1 (input E d (empty E))) = (reduce q1 + f d)%Z.
Proof.
  intros q1 d.
  pattern q1 at 2 in |- *.
  rewrite <- (append_nil2 E q1).
  apply reduce_append.
Qed. 

Lemma reduce_append_nil2_symmetric :
 forall (q1 : queue E) (d : E),
 reduce q1 = (reduce (append E q1 (input E d (empty E))) - f d)%Z.
Proof.
  intros q1 d.
  rewrite (reduce_append_nil2 q1 d).
  omega.
Qed. 

End REDUCE.

Section DISJOINT.

Variable E : Set.

Definition fun_or (pred1 pred2 : E -> bool) (a : E) := pred1 a || pred2 a.

Definition fun_sum (f1 f2 : E -> Z) (a : E) := (f1 a + f2 a)%Z.

Definition fun_minus (f1 f2 : E -> Z) (a : E) := (f1 a - f2 a)%Z.

Variable f : E -> Z.

Lemma disjoint_reduce :
 forall (f1 f2 : E -> Z) (q : queue E),
 reduce E (fun_sum f1 f2) q = (reduce E f1 q + reduce E f2 q)%Z.
Proof.
  simple induction q.
  simpl in |- *.
  auto.
  
  intros d q0 H.
  simpl in |- *.
  rewrite H.
  unfold fun_sum in |- *.
  omega.
Qed.

Lemma disjoint_reduce3 :
 forall (f1 f2 : E -> Z) (q : queue E),
 reduce E (fun_minus f1 f2) q = (reduce E f1 q - reduce E f2 q)%Z.
Proof.
  simple induction q.
  simpl in |- *; auto.
  intros d q0 H.
  simpl in |- *.
  rewrite H.
  unfold fun_minus in |- *.
  omega.
Qed.

Lemma reduce_simpl :
 forall (f1 f2 : E -> Z) (q : queue E),
 (forall d : E, f1 d = f2 d) -> reduce E f1 q = reduce E f2 q.
Proof.
  simple induction q.
  simpl in |- *; auto.
  intros d q0 H H0.
  simpl in |- *.
  rewrite H.
  rewrite H0.
  auto.
  auto.
Qed.

End DISJOINT.

Section REDUCE_MORE.

Variable data : Set.
Hypothesis eq_data_dec : eq_dec data.

Variable f : data -> Z.

Lemma reduce_first_out :
 forall (q : queue data) (m : data),
 first data q = value data m ->
 reduce data f (first_out data q) = (reduce data f q - f m)%Z.

Proof.
  intros q m H.
  rewrite (reduce_append_nil2_symmetric data f (first_out data q) m).
  rewrite (append_first_out2 data m q).
  auto.
  auto.
Qed.

End REDUCE_MORE.

Section reduce_pos.

Variable E : Set.

Variable f : E -> Z.
Hypothesis positive_function : forall a : E, (f a >= 0)%Z.

Lemma reduce_positive_or_null : forall q : queue E, (reduce E f q >= 0)%Z.
Proof.
  intros q.
  elim q.
  simpl in |- *.
  omega.
  
  intros d q0 H.
  simpl in |- *.
  generalize (positive_function d).
  intro H0.
  omega.
Qed.

End reduce_pos.

Section reduce_strictly_pos.

Variable E : Set.

Variable f : E -> Z.
Hypothesis positive_function : forall a : E, (f a >= 0)%Z.

Hypothesis eq_E_dec : eq_dec E.

Lemma reduce_in_queue_strictly_positive :
 forall (x : E) (q : queue E),
 (f x > 0)%Z -> In_queue E x q -> (reduce E f q > 0)%Z.
Proof.
  simple induction q; simpl in |- *.
  intuition.
  
  intro d.
  case (eq_E_dec d x); intro.
  rewrite e; intros.
  generalize (reduce_positive_or_null E f positive_function q0); intro.
  clear H.
  omega.
  
  intros q0 H H0 H1.
  elim H1; intro.
  elim n; auto.
  
  generalize (positive_function d); intro.
  generalize (H H0 H2); intro.
  omega.
Qed.
End reduce_strictly_pos.

Section reduce_in_q_null.
Variable E : Set.

Variable f : E -> Z.

Hypothesis eq_E_dec : eq_dec E.

Lemma reduce_in_queue_null :
 forall q : queue E,
 (forall x : E, In_queue E x q -> f x = 0%Z) -> reduce E f q = 0%Z.
Proof.
  simple induction q; simpl in |- *.
  auto.
  
  intros d q0 H H0.
  rewrite H0.
  rewrite H.
  auto.
  intros x H1.
  apply H0.
  right; auto.
  left; auto.
Qed.

End reduce_in_q_null.
