
Require Export DistributedReferenceCounting.machine0.machine.
Require Export counting.
(* counting:
Require Export DistributedReferenceCounting.machine0.machine.

Section CONTROL.

Variable s0 : Site.

Definition ctrl_copy (s1 : Site) (bom : Bag_of_message) :=
  card_mess copy (bom s0 s1).

Definition ctrl_dec (s1 : Site) (bom : Bag_of_message) :=
  card_mess dec (bom s1 s0).

Definition ctrl_inc (s1 : Site) (bom : Bag_of_message) :=
  card_mess (inc_dec s0) (bom s1 owner).

Definition sigma_ctrl_copy (bom : Bag_of_message) :=
  sigma Site LS (fun si : Site => ctrl_copy si bom). 

Definition sigma_ctrl_dec (bom : Bag_of_message) :=
  sigma Site LS (fun si : Site => ctrl_dec si bom). 

Definition sigma_ctrl_inc (bom : Bag_of_message) :=
  sigma Site LS (fun si : Site => ctrl_inc si bom). 

Definition sigma_ctrl (bom : Bag_of_message) :=
  (sigma_ctrl_copy bom + sigma_ctrl_dec bom + sigma_ctrl_inc bom)%Z. 

End CONTROL.

Section CONTROL_POS.

Variable bom : Bag_of_message.

Lemma ctrl_copy_pos : forall s0 s1 : Site, (ctrl_copy s0 s1 bom >= 0)%Z.

Lemma ctrl_dec_pos : forall s0 s1 : Site, (ctrl_dec s0 s1 bom >= 0)%Z.

Remark ctrl_inc_pos : forall s0 s1 : Site, (ctrl_inc s0 s1 bom >= 0)%Z.

Remark ctrl_inc_strct_pos :
 forall s0 s1 : Site,
 In_queue Message (inc_dec s0) (bom s1 owner) -> (ctrl_inc s0 s1 bom > 0)%Z.

Remark sigma_ctrl_copy_pos :
 forall s0 : Site, (sigma_ctrl_copy s0 bom >= 0)%Z. 

Remark sigma_ctrl_dec_pos : forall s0 : Site, (sigma_ctrl_dec s0 bom >= 0)%Z. 

Remark sigma_ctrl_inc_strct_pos :
 forall s0 s1 : Site,
 In_queue Message (inc_dec s0) (bom s1 owner) ->
 (sigma_ctrl_inc s0 bom > 0)%Z. 

Lemma sigma_ctrl_strct_pos :
 forall s0 s1 : Site,
 In_queue Message (inc_dec s0) (bom s1 owner) -> (sigma_ctrl s0 bom > 0)%Z. 

End CONTROL_POS.

Section XY.

Variable c0 : Config.

Definition xi (s0 : Site) :=
  (Int (rt c0 s0) + ctrl_copy owner s0 (bm c0) + ctrl_dec owner s0 (bm c0))%Z. 

Definition yi (s0 : Site) :=
  sigma Site LS (fun s' : Site => ctrl_inc s' s0 (bm c0)).

Definition sigma_xi := sigma Site LS (fun s' : Site => xi s'). 

Definition sigma_yi := sigma Site LS (fun s' : Site => yi s').

End XY.

Section ALT_CTRL.

Remark S_card_mess :
 forall (q0 : queue Message) (m : Message),
 card_mess m (input Message m q0) = (card_mess m q0 + 1)%Z.

Remark card_mess_diff :
 forall (q0 : queue Message) (m m' : Message),
 m <> m' -> card_mess m (input Message m' q0) = card_mess m q0.

Remark S_sigma_card_inc :
 forall (s0 : Site) (q0 : queue Message),
 sigma Site LS
   (fun s' : Site => card_mess (inc_dec s') (input Message (inc_dec s0) q0)) =
 (sigma Site LS (fun s' : Site => card_mess (inc_dec s') q0) + 1)%Z.

Remark diff_sigma_card_inc :
 forall q0 : queue Message,
 sigma Site LS
   (fun s' : Site => card_mess (inc_dec s') (input Message dec q0)) =
 sigma Site LS (fun s' : Site => card_mess (inc_dec s') q0).

Lemma alt_dec_inc :
 forall q0 : queue Message,
 alternate q0 ->
 (card_mess dec q0 + 1 >=
  sigma Site LS (fun s' : Site => card_mess (inc_dec s') q0))%Z.

Lemma D_dec_inc :
 forall q0 : queue Message,
 alternate q0 ->
 D_queue q0 ->
 (card_mess dec q0 >=
  sigma Site LS (fun s' : Site => card_mess (inc_dec s') q0))%Z.

End ALT_CTRL. *)

Section INITIALIZATION.

Definition time_init : nat := 0.

Definition date_init : Date_table := fun _ : Site => 0.

Definition send_init : Send_table := fun _ : Site => 0%Z.
	
Definition rec_init : Rec_table := fun _ : Site => false.
	
Definition bag_init : Bag_of_message := fun _ _ : Site => empty Message.
	
Definition config_init : Config :=
  mkconfig time_init date_init send_init rec_init bag_init.

End INITIALIZATION.

Section INIT_COUNT.

Lemma init_le_dt_time :
 forall s0 : Site, dt config_init s0 <= time config_init.
Proof.
 auto.
Qed.

Lemma init_copy_diff_site :
 forall s1 s2 : Site,
 In_queue Message copy (bm config_init s1 s2) -> s1 <> s2.
Proof.
 simpl in |- *; contradiction.
Qed.

Lemma st_rt_init :
 forall s0 : Site, (st config_init s0 > 0)%Z -> rt config_init s0 = true.
Proof.
 intro; unfold config_init in |- *; simpl in |- *; unfold send_init in |- *;
  intros.
 absurd (0 > 0)%Z; omega.
Qed.

Remark sigma_ctrl_copy_init :
 forall s0 : Site, sigma_ctrl_copy s0 bag_init = 0%Z.
Proof.
 intros; unfold sigma_ctrl_copy in |- *; apply sigma_null.
Qed.

Remark sigma_ctrl_dec_init :
 forall s0 : Site, sigma_ctrl_dec s0 bag_init = 0%Z.
Proof.
 intros; unfold sigma_ctrl_dec in |- *; apply sigma_null.
Qed.

Remark sigma_ctrl_inc_init :
 forall s0 : Site, sigma_ctrl_inc s0 bag_init = 0%Z.
Proof.
 intros; unfold sigma_ctrl_inc in |- *; apply sigma_null.
Qed.

Lemma sigma_ctrl_init : forall s0 : Site, sigma_ctrl s0 bag_init = 0%Z.
Proof.
 intros; unfold sigma_ctrl in |- *; rewrite sigma_ctrl_copy_init;
  rewrite sigma_ctrl_dec_init; rewrite sigma_ctrl_inc_init; 
  omega.
Qed.

End INIT_COUNT.

Section INIT_XY.

Remark yi_init :
 (fun s0 : Site => yi config_init s0) = (fun s0 : Site => 0%Z).
Proof.
 apply funct_eq; intros; unfold yi in |- *; simpl in |- *; apply sigma_null.
Qed.

Lemma sigma_xi_init : sigma_xi config_init = 0%Z.
Proof.
 intros; unfold sigma_xi in |- *; apply sigma_null.
Qed.

Lemma sigma_yi_init : sigma_yi config_init = 0%Z.
Proof.
 intros; unfold sigma_yi in |- *; simpl in |- *.
 rewrite yi_init; apply sigma_null.
Qed.

End INIT_XY.

Section INIT_ALT.

Variable s0 : Site.

Lemma D_init : D_queue (bm config_init s0 owner).
Proof.
 apply D_empty.
Qed.

Lemma alt_init : alternate (bm config_init s0 owner).
Proof.
 apply alt_null.
Qed.

End INIT_ALT.

Section INIT_RELAT.

Remark init_no_parent : forall s1 s2 : Site, ~ parent config_init s1 s2.
Proof.
 intros; red in |- *; intro.
 elim H; simpl in |- *; trivial.
Qed.

Lemma init_parent_cr :
 forall s1 s2 : Site,
 parent config_init s1 s2 -> dt config_init s1 < dt config_init s2.
Proof.
 intros; absurd (parent config_init s1 s2).
 apply init_no_parent.

 trivial.
Qed.

End INIT_RELAT.