
Require Export counting.
(* counting:
Require Export DistributedReferenceCounting.machine0.machine.

Section CONTROL.

Variable s0 : Site.

Definition ctrl_copy (s1 : Site) (bom : Bag_of_message) :=
  card_mess copy (bom s0 s1).

Definition ctrl_dec (s1 : Site) (bom : Bag_of_message) :=
  card_mess dec (bom s1 s0).

Definition ctrl_inc (s1 : Site) (bom : Bag_of_message) :=
  card_mess (inc_dec s0) (bom s1 owner).

Definition sigma_ctrl_copy (bom : Bag_of_message) :=
  sigma Site LS (fun si : Site => ctrl_copy si bom). 

Definition sigma_ctrl_dec (bom : Bag_of_message) :=
  sigma Site LS (fun si : Site => ctrl_dec si bom). 

Definition sigma_ctrl_inc (bom : Bag_of_message) :=
  sigma Site LS (fun si : Site => ctrl_inc si bom). 

Definition sigma_ctrl (bom : Bag_of_message) :=
  (sigma_ctrl_copy bom + sigma_ctrl_dec bom + sigma_ctrl_inc bom)%Z. 

End CONTROL.

Section CONTROL_POS.

Variable bom : Bag_of_message.

Lemma ctrl_copy_pos : forall s0 s1 : Site, (ctrl_copy s0 s1 bom >= 0)%Z.

Lemma ctrl_dec_pos : forall s0 s1 : Site, (ctrl_dec s0 s1 bom >= 0)%Z.

Remark ctrl_inc_pos : forall s0 s1 : Site, (ctrl_inc s0 s1 bom >= 0)%Z.

Remark ctrl_inc_strct_pos :
 forall s0 s1 : Site,
 In_queue Message (inc_dec s0) (bom s1 owner) -> (ctrl_inc s0 s1 bom > 0)%Z.

Remark sigma_ctrl_copy_pos :
 forall s0 : Site, (sigma_ctrl_copy s0 bom >= 0)%Z. 

Remark sigma_ctrl_dec_pos : forall s0 : Site, (sigma_ctrl_dec s0 bom >= 0)%Z. 

Remark sigma_ctrl_inc_strct_pos :
 forall s0 s1 : Site,
 In_queue Message (inc_dec s0) (bom s1 owner) ->
 (sigma_ctrl_inc s0 bom > 0)%Z. 

Lemma sigma_ctrl_strct_pos :
 forall s0 s1 : Site,
 In_queue Message (inc_dec s0) (bom s1 owner) -> (sigma_ctrl s0 bom > 0)%Z. 

End CONTROL_POS.

Section XY.

Variable c0 : Config.

Definition xi (s0 : Site) :=
  (Int (rt c0 s0) + ctrl_copy owner s0 (bm c0) + ctrl_dec owner s0 (bm c0))%Z. 

Definition yi (s0 : Site) :=
  sigma Site LS (fun s' : Site => ctrl_inc s' s0 (bm c0)).

Definition sigma_xi := sigma Site LS (fun s' : Site => xi s'). 

Definition sigma_yi := sigma Site LS (fun s' : Site => yi s').

End XY.

Section ALT_CTRL.

Remark S_card_mess :
 forall (q0 : queue Message) (m : Message),
 card_mess m (input Message m q0) = (card_mess m q0 + 1)%Z.

Remark card_mess_diff :
 forall (q0 : queue Message) (m m' : Message),
 m <> m' -> card_mess m (input Message m' q0) = card_mess m q0.

Remark S_sigma_card_inc :
 forall (s0 : Site) (q0 : queue Message),
 sigma Site LS
   (fun s' : Site => card_mess (inc_dec s') (input Message (inc_dec s0) q0)) =
 (sigma Site LS (fun s' : Site => card_mess (inc_dec s') q0) + 1)%Z.

Remark diff_sigma_card_inc :
 forall q0 : queue Message,
 sigma Site LS
   (fun s' : Site => card_mess (inc_dec s') (input Message dec q0)) =
 sigma Site LS (fun s' : Site => card_mess (inc_dec s') q0).

Lemma alt_dec_inc :
 forall q0 : queue Message,
 alternate q0 ->
 (card_mess dec q0 + 1 >=
  sigma Site LS (fun s' : Site => card_mess (inc_dec s') q0))%Z.

Lemma D_dec_inc :
 forall q0 : queue Message,
 alternate q0 ->
 D_queue q0 ->
 (card_mess dec q0 >=
  sigma Site LS (fun s' : Site => card_mess (inc_dec s') q0))%Z.

End ALT_CTRL. *)

Unset Standard Proposition Elimination Names.

Section M_ACTION.

Definition Post_message (m0 : Message) (b0 : Bag_of_message)
  (s0 s1 : Site) :=
  change_queue (queue Message) b0 s0 s1 (input Message m0 (b0 s0 s1)).

Definition Collect_message (b0 : Bag_of_message) (s0 s1 : Site) :=
  change_queue (queue Message) b0 s0 s1 (first_out Message (b0 s0 s1)).

Lemma post_here :
 forall (b0 : Bag_of_message) (m0 : Message) (s0 s1 : Site),
 Post_message m0 b0 s0 s1 s0 s1 = input Message m0 (b0 s0 s1).
Proof.
 intros; unfold Post_message in |- *; apply that_queue.
Qed.

Lemma post_elsewhere :
 forall (b0 : Bag_of_message) (m0 : Message) (s0 s1 s2 s3 : Site),
 s0 <> s2 \/ s1 <> s3 -> Post_message m0 b0 s0 s1 s2 s3 = b0 s2 s3.
Proof.
 intros; unfold Post_message in |- *; apply other_queue; elim H; auto.
Qed.

Lemma collect_here :
 forall (b0 : Bag_of_message) (s0 s1 : Site),
 Collect_message b0 s0 s1 s0 s1 = first_out Message (b0 s0 s1).
Proof.
 intros; unfold Collect_message in |- *; apply that_queue.
Qed.

Lemma collect_elsewhere :
 forall (b0 : Bag_of_message) (s0 s1 s2 s3 : Site),
 s0 <> s2 \/ s1 <> s3 -> Collect_message b0 s0 s1 s2 s3 = b0 s2 s3.
Proof.
 intros; unfold Collect_message in |- *; apply other_queue; elim H; auto.
Qed.

End M_ACTION.

Section IN_Q_EFFECT.

Lemma in_post :
 forall (m m' : Message) (bom : Bag_of_message) (s1 s2 s3 s4 : Site),
 m <> m' ->
 In_queue Message m (Post_message m' bom s1 s2 s3 s4) ->
 In_queue Message m (bom s3 s4).
Proof.
 intros m m' bom s1 s2 s3 s4; case (eq_queue_dec s1 s3 s2 s4); intro.
 decompose [and] a; rewrite H; rewrite H0.
 rewrite post_here.
 intros; apply in_q_input with (d' := m'); trivial.

 rewrite post_elsewhere; auto.
Qed.

Lemma in_collect :
 forall (m : Message) (bom : Bag_of_message) (s1 s2 s3 s4 : Site),
 In_queue Message m (Collect_message bom s1 s2 s3 s4) ->
 In_queue Message m (bom s3 s4).
Proof.
 intros m bom s1 s2 s3 s4; case (eq_queue_dec s1 s3 s2 s4); intro.
 decompose [and] a; rewrite H; rewrite H0.
 rewrite collect_here; intros; apply in_q_output; trivial.

 rewrite collect_elsewhere; auto.
Qed.

End IN_Q_EFFECT.

Section CARD_EFFECT.

Lemma post_card_mess :
 forall (m : Message) (s1 s2 : Site) (b : Bag_of_message),
 card_mess m (Post_message m b s1 s2 s1 s2) = (card_mess m (b s1 s2) + 1)%Z. 
Proof.
 intros; unfold card_mess in |- *; rewrite post_here; apply input_S_card;
  trivial.
Qed.

Lemma diff_post_card_mess :
 forall (m m' : Message) (s1 s2 s3 s4 : Site) (b : Bag_of_message),
 m <> m' \/ s1 <> s3 \/ s2 <> s4 ->
 card_mess m (Post_message m' b s3 s4 s1 s2) = card_mess m (b s1 s2). 
Proof.
 intros; unfold card_mess in |- *; elim H; intros.
 case (eq_queue_dec s1 s3 s2 s4); intro.
 decompose [and] a; rewrite H1; rewrite H2; rewrite post_here;
  apply input_diff_card; trivial.

 rewrite post_elsewhere; elim o; auto.

 rewrite post_elsewhere; elim H0; auto.
Qed.

Lemma collect_card_mess :
 forall (m : Message) (s1 s2 : Site) (b : Bag_of_message),
 first Message (b s1 s2) = value Message m ->
 card_mess m (Collect_message b s1 s2 s1 s2) = (card_mess m (b s1 s2) - 1)%Z. 
Proof.
 intros; unfold card_mess in |- *; rewrite collect_here;
  apply firstout_pred_card; trivial.
Qed.

Lemma diff_collect_card_mess :
 forall (m : Message) (s1 s2 s3 s4 : Site) (b : Bag_of_message),
 first Message (b s1 s2) <> value Message m \/ s1 <> s3 \/ s2 <> s4 ->
 card_mess m (Collect_message b s3 s4 s1 s2) = card_mess m (b s1 s2). 
Proof.
 intros; unfold card_mess in |- *; elim H; intros.
 case (eq_queue_dec s1 s3 s2 s4); intro.
 decompose [and] a; rewrite <- H1; rewrite <- H2; rewrite collect_here.
 apply firstout_diff_card; auto.

 rewrite collect_elsewhere; elim o; auto.

 rewrite collect_elsewhere; elim H0; auto.
Qed.

End CARD_EFFECT.

Section MESS_ALT.

Variable b0 : Bag_of_message.

Variable s0 : Site.

Lemma D_collect :
 forall s1 s2 : Site,
 D_queue (b0 s0 owner) -> D_queue (Collect_message b0 s1 s2 s0 owner).
Proof.
 intros; case (eq_queue_dec s1 s0 s2 owner); intro.
 decompose [and] a; rewrite H0; rewrite H1.
 rewrite collect_here; apply D_first_out; trivial.

 rewrite collect_elsewhere; auto.
Qed.

Lemma D_post_elsewhere :
 forall (s1 s2 : Site) (m : Message),
 s1 <> s0 \/ s2 <> owner ->
 D_queue (b0 s0 owner) -> D_queue (Post_message m b0 s1 s2 s0 owner).
Proof.
 intros; rewrite post_elsewhere; trivial.
Qed.

Lemma D_post_dec : D_queue (Post_message dec b0 s0 owner s0 owner).
Proof.
 intros; rewrite post_here; apply D_dec; trivial.
Qed.

Lemma alt_collect :
 forall s1 s2 : Site,
 alternate (b0 s0 owner) -> alternate (Collect_message b0 s1 s2 s0 owner).
Proof.
 intros; case (eq_queue_dec s1 s0 s2 owner); intro.
 decompose [and] a; rewrite H0; rewrite H1.
 rewrite collect_here; apply alt_first_out; trivial.

 rewrite collect_elsewhere; auto.
Qed.

Lemma alt_post_elsewhere :
 forall (s1 s2 : Site) (m : Message),
 s1 <> s0 \/ s2 <> owner ->
 alternate (b0 s0 owner) -> alternate (Post_message m b0 s1 s2 s0 owner).
Proof.
 intros; rewrite post_elsewhere; trivial.
Qed.

Lemma alt_post_dec :
 alternate (b0 s0 owner) -> alternate (Post_message dec b0 s0 owner s0 owner).
Proof.
 intros; rewrite post_here; apply alt_dec_alt; trivial.
Qed.

Lemma alt_post_inc :
 forall s1 : Site,
 alternate (b0 s0 owner) ->
 b0 s0 owner = empty Message \/
 last Message (b0 s0 owner) = value Message dec ->
 alternate (Post_message (inc_dec s1) b0 s0 owner s0 owner).
Proof.
 intros s1 H; rewrite post_here; inversion H; simpl in |- *; intros.
 apply alt_single_inc.

 decompose [or] H0; discriminate H2.

 apply alt_inc_dec; trivial.

 decompose [or] H2; discriminate H3.
Qed.

End MESS_ALT.
