
Require Import List.
Require Export finite.
(* finite:
Require Import List.
Require Export bibli.

Unset Standard Proposition Elimination Names.

Section DEFIN.

Variable E : Set.

Hypothesis eq_E_dec : eq_dec E.

Fixpoint only_once (x : E) (l : list E) {struct l} : Prop :=
  match l with
  | nil => False
  | y :: l' =>
      if eq_E_dec x y then ~ In x l' else only_once x l'
  end.

Definition list_of_elements (l : list E) := forall x : E, only_once x l.

Lemma only_once_in : forall (l : list E) (x : E), only_once x l -> In x l.

Lemma equality_from_membership :
 forall (x y : E) (l : list E), In y l -> ~ In x l -> x <> y.

End DEFIN.

Section SUM.

Variable E : Set.

Fixpoint sigma (l1 : list E) : (E -> Z) -> Z :=
  fun f : E -> Z =>
  match l1 with
  | nil => 0%Z
  | e :: l2 => (f e + sigma l2 f)%Z
  end.
	
Lemma sigma_null : forall l : list E, sigma l (fun e : E => 0%Z) = 0%Z.

Lemma sigma_pos :
 forall (f : E -> Z) (l : list E),
 (forall x_ : E, (f x_ >= 0)%Z) -> (sigma l f >= 0)%Z.

Lemma le_sigma :
 forall (l : list E) (f : E -> Z) (x : E),
 (forall x_ : E, (f x_ >= 0)%Z) -> In x l -> (f x <= sigma l f)%Z.

Lemma sigma_simpl :
 forall (l : list E) (f g : E -> Z),
 (forall x : E, In x l -> f x = g x) -> sigma l f = sigma l g.

Remark le_sigma_sigma :
 forall (l : list E) (f g : E -> Z),
 (forall x : E, (f x <= g x)%Z) -> (sigma l f <= sigma l g)%Z.

Lemma ge_sigma_sigma :
 forall (l : list E) (f g : E -> Z),
 (forall x : E, (f x >= g x)%Z) -> (sigma l f >= sigma l g)%Z.

Hypothesis eq_E_dec : eq_dec E.

Lemma lt_sigma_sigma :
 forall (l : list E) (f g : E -> Z),
 (forall x : E, (f x <= g x)%Z) ->
 (exists y : E, (f y < g y)%Z /\ In y l) -> (sigma l f < sigma l g)%Z.

End SUM.

Section SIGMA_BUT.

Variable E : Set.

Variable x0 : E.

Hypothesis eq_E_dec : eq_dec E.

Variable f : E -> Z.

Fixpoint sigma_but (l1 : list E) : (E -> Z) -> Z :=
  fun f : E -> Z =>
  match l1 with
  | nil => 0%Z
  | e :: l2 =>
      if eq_E_dec e x0
      then sigma_but l2 f
      else (f e + sigma_but l2 f)%Z
  end.

Lemma sigma_but_pos :
 forall (f : E -> Z) (l : list E),
 (forall x_ : E, (f x_ >= 0)%Z) -> (sigma_but l f >= 0)%Z.

Lemma sigma_sigma_but_not_in :
 forall l : list E, ~ In x0 l -> sigma E l f = sigma_but l f.

Lemma sigma_sigma_but :
 forall l : list E,
 only_once E eq_E_dec x0 l -> sigma E l f = (sigma_but l f + f x0)%Z.

Lemma sigma_but_simpl :
 forall (l : list E) (f g : E -> Z),
 (forall x : E, x <> x0 -> In x l -> f x = g x) ->
 sigma_but l f = sigma_but l g.

End SIGMA_BUT. *)

Unset Standard Proposition Elimination Names.

Section TABLE1.

Variable E F : Set.
Hypothesis eq_E_dec : eq_dec E.
Variable t : E -> F.
Variable x0 : E.
Variable y0 : F.

Definition change_x0 (x : E) :=
  if eq_E_dec x0 x then y0 else t x.

Lemma here : change_x0 x0 = y0.
Proof.
 unfold change_x0 in |- *; rewrite case_eq; trivial.
Qed.
	
Lemma elsewhere : forall x : E, x0 <> x -> change_x0 x = t x.
Proof.
 intros; unfold change_x0 in |- *.
 rewrite case_ineq; trivial.
Qed.

End TABLE1.

Section TABLE2.

Variable E F G : Set.
Hypothesis eq_E_dec : eq_dec E.
Hypothesis eq_F_dec : eq_dec F.
Variable t : E -> F -> G.
Variable x0 : E.
Variable y0 : F.
Variable z0 : G.

Definition change_x0y0 :=
  change_x0 E (F -> G) eq_E_dec t x0 (change_x0 F G eq_F_dec (t x0) y0 z0).

Lemma here2 : change_x0y0 x0 y0 = z0.
Proof.
 intros; unfold change_x0y0 in |- *; simpl in |- *.
 do 2 rewrite here; auto.
Qed.
                     
Remark elsewhere2_x : forall x : E, x <> x0 -> change_x0y0 x = t x.
Proof.
 intros; unfold change_x0y0 in |- *; simpl in |- *.
 rewrite elsewhere; auto.
Qed.

Remark elsewhere2_y :
 forall y : F,
 y <> y0 -> (fun x : E => change_x0y0 x y) = (fun x : E => t x y).
Proof.
 intros; apply funct_eq.
 intros; unfold change_x0y0 in |- *.
 case (eq_E_dec e x0); intros.
 rewrite e0; rewrite here.
 rewrite elsewhere; auto.
	
 rewrite elsewhere; auto.
Qed.

Lemma elsewhere2 :
 forall (x : E) (y : F), x <> x0 \/ y <> y0 -> change_x0y0 x y = t x y. 
Proof.
 intros; elim H; intros.
 rewrite elsewhere2_x; auto.

 apply
  f_equal
   with
     (f := fun g : E -> G => g x)
     (x := fun x' : E => change_x0y0 x' y)
     (y := fun x' : E => t x' y). 
 apply elsewhere2_y; auto.
Qed.
	
End TABLE2.
 
Section CHANGE_SUM1.

Variable E : Set.
Hypothesis eq_E_dec : eq_dec E.
Variable f : E -> Z.
Variable x0 : E.
Variable y0 : Z.

Lemma sigma_nowhere :
 forall l : list E,
 ~ In x0 l -> sigma E l (change_x0 E Z eq_E_dec f x0 y0) = sigma E l f. 
Proof.
 intros; apply sigma_simpl.
 intros; apply elsewhere.
 apply sym_not_eq; apply in_not_in with (l := l); auto.
Qed.

Lemma sigma_change :
 forall l : list E,
 only_once E eq_E_dec x0 l ->
 sigma E l (change_x0 E Z eq_E_dec f x0 y0) = (sigma E l f - f x0 + y0)%Z.
Proof.
 simple induction l; simpl in |- *.
 contradiction.

 intros a l0 hrec; case (eq_E_dec x0 a); intros.
 rewrite <- e; rewrite here.
 rewrite sigma_nowhere.
 omega.
	
 trivial.
	
 rewrite elsewhere.
 rewrite hrec.
 omega.
	
 trivial.

 trivial.
Qed.
 	
End CHANGE_SUM1.

Section SUM1_S.

Variable E : Set.
Hypothesis eq_E_dec : eq_dec E.
Variable L : list E.
Hypothesis finite_E : list_of_elements E eq_E_dec L.
Variable f : E -> Z.
Variable x0 : E.

Remark sigma_change_S :
 sigma E L (change_x0 E Z eq_E_dec f x0 (f x0 + 1)%Z) = (sigma E L f + 1)%Z.    
Proof.
 rewrite sigma_change.
 omega. 
	
 auto.
Qed.

Lemma sigma__S :
 forall g : E -> Z,
 g x0 = (f x0 + 1)%Z ->
 (forall x : E, x <> x0 -> g x = f x) -> sigma E L g = (sigma E L f + 1)%Z.    
Proof.
 intros; rewrite <- sigma_change_S.
 apply sigma_simpl.
 intros; unfold change_x0 in |- *.
 case (eq_E_dec x0 x); simpl in |- *; intro.
 rewrite <- e; auto.

 auto.
Qed.
   
Remark sigma_change_pred :
 sigma E L (change_x0 E Z eq_E_dec f x0 (f x0 - 1)%Z) = (sigma E L f - 1)%Z.    
Proof.
 rewrite sigma_change.
 omega.
		
 auto.
Qed.
   
Lemma sigma__pred :
 forall g : E -> Z,
 g x0 = (f x0 - 1)%Z ->
 (forall x : E, x <> x0 -> g x = f x) -> sigma E L g = (sigma E L f - 1)%Z.    
Proof.
 intros; rewrite <- sigma_change_pred.
 apply sigma_simpl.
 intros; unfold change_x0 in |- *.
 case (eq_E_dec x0 x); simpl in |- *; intro.
 rewrite <- e; auto.

 auto.
Qed.
 
End SUM1_S.
