
Require Export init.
(* init:
Require Export DistributedReferenceCounting.machine0.machine.
Require Export counting.

Section INITIALIZATION.

Definition time_init : nat := 0.

Definition date_init : Date_table := fun _ : Site => 0.

Definition send_init : Send_table := fun _ : Site => 0%Z.
	
Definition rec_init : Rec_table := fun _ : Site => false.
	
Definition bag_init : Bag_of_message := fun _ _ : Site => empty Message.
	
Definition config_init : Config :=
  mkconfig time_init date_init send_init rec_init bag_init.

End INITIALIZATION.

Section INIT_COUNT.

Lemma init_le_dt_time :
 forall s0 : Site, dt config_init s0 <= time config_init.

Lemma init_copy_diff_site :
 forall s1 s2 : Site,
 In_queue Message copy (bm config_init s1 s2) -> s1 <> s2.

Lemma st_rt_init :
 forall s0 : Site, (st config_init s0 > 0)%Z -> rt config_init s0 = true.

Remark sigma_ctrl_copy_init :
 forall s0 : Site, sigma_ctrl_copy s0 bag_init = 0%Z.

Remark sigma_ctrl_dec_init :
 forall s0 : Site, sigma_ctrl_dec s0 bag_init = 0%Z.

Remark sigma_ctrl_inc_init :
 forall s0 : Site, sigma_ctrl_inc s0 bag_init = 0%Z.

Lemma sigma_ctrl_init : forall s0 : Site, sigma_ctrl s0 bag_init = 0%Z.

End INIT_COUNT.

Section INIT_XY.

Remark yi_init :
 (fun s0 : Site => yi config_init s0) = (fun s0 : Site => 0%Z).

Lemma sigma_xi_init : sigma_xi config_init = 0%Z.

Lemma sigma_yi_init : sigma_yi config_init = 0%Z.

End INIT_XY.

Section INIT_ALT.

Variable s0 : Site.

Lemma D_init : D_queue (bm config_init s0 owner).

Lemma alt_init : alternate (bm config_init s0 owner).

End INIT_ALT.

Section INIT_RELAT.

Remark init_no_parent : forall s1 s2 : Site, ~ parent config_init s1 s2.

Lemma init_parent_cr :
 forall s1 s2 : Site,
 parent config_init s1 s2 -> dt config_init s1 < dt config_init s2.

End INIT_RELAT. *)
Require Export table_act.
(* table_act:
Require Export DistributedReferenceCounting.machine0.machine.

Section T_ACTION.

Definition Update_table (d0 : Date_table) (s0 : Site) 
  (new_date : nat) := change_site nat d0 s0 new_date.

Definition Set_rec_table (r0 : Rec_table) (s0 : Site) :=
  change_site bool r0 s0 true.

Definition Reset_rec_table (r0 : Rec_table) (s0 : Site) :=
  change_site bool r0 s0 false.
                 
Definition Inc_send_table (t0 : Send_table) (s0 : Site) :=
  change_site Z t0 s0 (t0 s0 + 1)%Z.  

Definition Dec_send_table (t0 : Send_table) (s0 : Site) :=
  change_site Z t0 s0 (t0 s0 - 1)%Z.  

End T_ACTION.

Section DT_EFFECT.

Lemma update_here :
 forall (d0 : Date_table) (s0 : Site) (newdate : nat),
 Update_table d0 s0 newdate s0 = newdate.

Lemma update_elsewhere :
 forall (d0 : Date_table) (s0 s1 : Site) (newdate : nat),
 s0 <> s1 -> Update_table d0 s0 newdate s1 = d0 s1.

End DT_EFFECT.

Section ST_EFFECT.

Lemma S_inc_send_table :
 forall (t0 : Send_table) (s0 : Site),
 Inc_send_table t0 s0 s0 = (t0 s0 + 1)%Z.

Lemma no_inc_send_table :
 forall (t0 : Send_table) (s0 s1 : Site),
 s0 <> s1 -> Inc_send_table t0 s0 s1 = t0 s1.

Lemma pred_dec_send_table :
 forall (t0 : Send_table) (s0 : Site),
 Dec_send_table t0 s0 s0 = (t0 s0 - 1)%Z.

Lemma no_dec_send_table :
 forall (t0 : Send_table) (s0 s1 : Site),
 s0 <> s1 -> Dec_send_table t0 s0 s1 = t0 s1.

End ST_EFFECT.

Section RT_EFFECT.

Lemma true_set_rec_table :
 forall (r0 : Rec_table) (s0 : Site), Set_rec_table r0 s0 s0 = true.

Lemma S_set_rec_table :
 forall (r0 : Rec_table) (s0 : Site),
 r0 s0 = false -> Int (Set_rec_table r0 s0 s0) = (Int (r0 s0) + 1)%Z.

Lemma inch_set_rec_table :
 forall (r0 : Rec_table) (s0 s1 : Site),
 s0 <> s1 -> Set_rec_table r0 s0 s1 = r0 s1.

Lemma no_set_rec_table :
 forall (r0 : Rec_table) (s0 s1 : Site),
 s0 <> s1 -> Int (Set_rec_table r0 s0 s1) = Int (r0 s1).

Remark false_reset_rec_table :
 forall (r0 : Rec_table) (s0 : Site), Reset_rec_table r0 s0 s0 = false.

Lemma pred_reset_rec_table :
 forall (r0 : Rec_table) (s0 : Site),
 r0 s0 = true -> Int (Reset_rec_table r0 s0 s0) = (Int (r0 s0) - 1)%Z.

Lemma inch_reset_rec_table :
 forall (r0 : Rec_table) (s0 s1 : Site),
 s0 <> s1 -> Reset_rec_table r0 s0 s1 = r0 s1.

Lemma no_reset_rec_table :
 forall (r0 : Rec_table) (s0 s1 : Site),
 s0 <> s1 -> Int (Reset_rec_table r0 s0 s1) = Int (r0 s1).

End RT_EFFECT. *)
Require Export mess_act.
(* mess_act:
Require Export counting.

Unset Standard Proposition Elimination Names.

Section M_ACTION.

Definition Post_message (m0 : Message) (b0 : Bag_of_message)
  (s0 s1 : Site) :=
  change_queue (queue Message) b0 s0 s1 (input Message m0 (b0 s0 s1)).

Definition Collect_message (b0 : Bag_of_message) (s0 s1 : Site) :=
  change_queue (queue Message) b0 s0 s1 (first_out Message (b0 s0 s1)).

Lemma post_here :
 forall (b0 : Bag_of_message) (m0 : Message) (s0 s1 : Site),
 Post_message m0 b0 s0 s1 s0 s1 = input Message m0 (b0 s0 s1).

Lemma post_elsewhere :
 forall (b0 : Bag_of_message) (m0 : Message) (s0 s1 s2 s3 : Site),
 s0 <> s2 \/ s1 <> s3 -> Post_message m0 b0 s0 s1 s2 s3 = b0 s2 s3.

Lemma collect_here :
 forall (b0 : Bag_of_message) (s0 s1 : Site),
 Collect_message b0 s0 s1 s0 s1 = first_out Message (b0 s0 s1).

Lemma collect_elsewhere :
 forall (b0 : Bag_of_message) (s0 s1 s2 s3 : Site),
 s0 <> s2 \/ s1 <> s3 -> Collect_message b0 s0 s1 s2 s3 = b0 s2 s3.

End M_ACTION.

Section IN_Q_EFFECT.

Lemma in_post :
 forall (m m' : Message) (bom : Bag_of_message) (s1 s2 s3 s4 : Site),
 m <> m' ->
 In_queue Message m (Post_message m' bom s1 s2 s3 s4) ->
 In_queue Message m (bom s3 s4).

Lemma in_collect :
 forall (m : Message) (bom : Bag_of_message) (s1 s2 s3 s4 : Site),
 In_queue Message m (Collect_message bom s1 s2 s3 s4) ->
 In_queue Message m (bom s3 s4).

End IN_Q_EFFECT.

Section CARD_EFFECT.

Lemma post_card_mess :
 forall (m : Message) (s1 s2 : Site) (b : Bag_of_message),
 card_mess m (Post_message m b s1 s2 s1 s2) = (card_mess m (b s1 s2) + 1)%Z. 

Lemma diff_post_card_mess :
 forall (m m' : Message) (s1 s2 s3 s4 : Site) (b : Bag_of_message),
 m <> m' \/ s1 <> s3 \/ s2 <> s4 ->
 card_mess m (Post_message m' b s3 s4 s1 s2) = card_mess m (b s1 s2). 

Lemma collect_card_mess :
 forall (m : Message) (s1 s2 : Site) (b : Bag_of_message),
 first Message (b s1 s2) = value Message m ->
 card_mess m (Collect_message b s1 s2 s1 s2) = (card_mess m (b s1 s2) - 1)%Z. 

Lemma diff_collect_card_mess :
 forall (m : Message) (s1 s2 s3 s4 : Site) (b : Bag_of_message),
 first Message (b s1 s2) <> value Message m \/ s1 <> s3 \/ s2 <> s4 ->
 card_mess m (Collect_message b s3 s4 s1 s2) = card_mess m (b s1 s2). 

End CARD_EFFECT.

Section MESS_ALT.

Variable b0 : Bag_of_message.

Variable s0 : Site.

Lemma D_collect :
 forall s1 s2 : Site,
 D_queue (b0 s0 owner) -> D_queue (Collect_message b0 s1 s2 s0 owner).

Lemma D_post_elsewhere :
 forall (s1 s2 : Site) (m : Message),
 s1 <> s0 \/ s2 <> owner ->
 D_queue (b0 s0 owner) -> D_queue (Post_message m b0 s1 s2 s0 owner).

Lemma D_post_dec : D_queue (Post_message dec b0 s0 owner s0 owner).

Lemma alt_collect :
 forall s1 s2 : Site,
 alternate (b0 s0 owner) -> alternate (Collect_message b0 s1 s2 s0 owner).

Lemma alt_post_elsewhere :
 forall (s1 s2 : Site) (m : Message),
 s1 <> s0 \/ s2 <> owner ->
 alternate (b0 s0 owner) -> alternate (Post_message m b0 s1 s2 s0 owner).

Lemma alt_post_dec :
 alternate (b0 s0 owner) -> alternate (Post_message dec b0 s0 owner s0 owner).

Lemma alt_post_inc :
 forall s1 : Site,
 alternate (b0 s0 owner) ->
 b0 s0 owner = empty Message \/
 last Message (b0 s0 owner) = value Message dec ->
 alternate (Post_message (inc_dec s1) b0 s0 owner s0 owner).

End MESS_ALT. *)

Unset Standard Proposition Elimination Names.

Section DEF_REC_COP1.

Definition rec_copy1_trans (c : Config) (s1 s2 : Site) :=
  mkconfig (S (time c)) (dt c) (st c) (rt c)
    (Post_message dec (Collect_message (bm c) s1 s2) s2 s1). 

End DEF_REC_COP1.

Section REC_COP1_EFFECT.

Variable c0 : Config.

Variable s1 s2 : Site.

Lemma rcop1_trans_le_dt_time :
 forall s0 : Site,
 dt c0 s0 <= time c0 ->
 dt (rec_copy1_trans c0 s1 s2) s0 <= time (rec_copy1_trans c0 s1 s2).
Proof.
 simpl in |- *; auto.
Qed.

Lemma rcop1_trans_diff_site :
 forall s3 s4 : Site,
 (In_queue Message copy (bm c0 s3 s4) -> s3 <> s4) ->
 In_queue Message copy (bm (rec_copy1_trans c0 s1 s2) s3 s4) -> s3 <> s4.
Proof.
 simpl in |- *; intros; apply H.
 apply in_collect with (s1 := s1) (s2 := s2).
 apply in_post with (m' := dec) (s1 := s2) (s2 := s1).
 discriminate.

 trivial.
Qed.

Lemma rcop1_trans_in_queue :
 forall s0 s3 s4 : Site,
 In_queue Message (inc_dec s0) (bm (rec_copy1_trans c0 s1 s2) s3 s4) ->
 In_queue Message (inc_dec s0) (bm c0 s3 s4).
Proof.
 simpl in |- *; intros.
 apply in_collect with (s1 := s1) (s2 := s2).
 apply in_post with (m' := dec) (s1 := s2) (s2 := s1).
 discriminate.

 auto.
Qed.

Lemma rcop1_trans_st_rt :
 forall s0 : Site,
 ((st c0 s0 > 0)%Z -> rt c0 s0 = true) ->
 (st (rec_copy1_trans c0 s1 s2) s0 > 0)%Z ->
 rt (rec_copy1_trans c0 s1 s2) s0 = true.
Proof.
 simpl in |- *; intros; auto.
Qed.

End REC_COP1_EFFECT.

Section REC_COP1_CTRL.

Variable c0 : Config.

Variable s0 s1 s2 : Site.

Hypothesis first_mess : first Message (bm c0 s1 s2) = value Message copy.

Lemma rcop1_trans_ctrl_copy :
 forall s3 : Site,
 ctrl_copy s0 s3 (bm (rec_copy1_trans c0 s1 s2)) =
 (if eq_site_dec s0 s1
  then
   
   if eq_site_dec s3 s2
   then  (ctrl_copy s0 s3 (bm c0) - 1)%Z
   else  ctrl_copy s0 s3 (bm c0)
  else  ctrl_copy s0 s3 (bm c0)).
Proof.
 intros; unfold ctrl_copy in |- *; simpl in |- *.
 rewrite diff_post_card_mess.
 case (eq_site_dec s0 s1); intro.
 case (eq_site_dec s3 s2); intro.
 rewrite e; rewrite e0; apply collect_card_mess; trivial.

 apply diff_collect_card_mess; auto.

 apply diff_collect_card_mess; auto.

 left; discriminate.
Qed.

Lemma rcop1_trans_ctrl_dec :
 forall s3 : Site,
 ctrl_dec s0 s3 (bm (rec_copy1_trans c0 s1 s2)) =
 (if eq_site_dec s0 s1
  then
   
   if eq_site_dec s3 s2
   then  (ctrl_dec s0 s3 (bm c0) + 1)%Z
   else  ctrl_dec s0 s3 (bm c0)
  else  ctrl_dec s0 s3 (bm c0)).
Proof.
 intros; unfold ctrl_dec in |- *; simpl in |- *.
 case (eq_site_dec s0 s1); intro.
 case (eq_site_dec s3 s2); intro.
 rewrite e; rewrite e0; rewrite post_card_mess.
 rewrite diff_collect_card_mess.
 auto.

 apply diff_or_elsewhere with (m := copy); [ trivial | discriminate ].

 rewrite diff_post_card_mess.
 rewrite diff_collect_card_mess.
 auto.

 apply diff_or_elsewhere with (m := copy); [ trivial | discriminate ].

 auto.

 rewrite diff_post_card_mess.
 rewrite diff_collect_card_mess.
 auto.

 apply diff_or_elsewhere with (m := copy); [ trivial | discriminate ].

 auto.
Qed.

Lemma rcop1_trans_ctrl_inc :
 forall s3 : Site,
 ctrl_inc s0 s3 (bm (rec_copy1_trans c0 s1 s2)) = ctrl_inc s0 s3 (bm c0).
Proof.
 unfold ctrl_inc in |- *; simpl in |- *; intros.
 rewrite diff_post_card_mess.
 rewrite diff_collect_card_mess.
 auto.
 
 apply diff_or_elsewhere with (m := copy); [ trivial | discriminate ].

 left; discriminate.
Qed.

Remark rcop1_trans_sigma_copy :
 sigma_ctrl_copy s0 (bm (rec_copy1_trans c0 s1 s2)) =
 (if eq_site_dec s0 s1
  then  (sigma_ctrl_copy s0 (bm c0) - 1)%Z
  else  sigma_ctrl_copy s0 (bm c0)).
Proof.
 intros; unfold sigma_ctrl_copy in |- *.
 case (eq_site_dec s0 s1); intro.
 apply sigma__pred with (eq_E_dec := eq_site_dec) (x0 := s2).
 exact finite_site.

 rewrite rcop1_trans_ctrl_copy.
 rewrite e; rewrite case_eq; apply case_eq.

 intros; rewrite rcop1_trans_ctrl_copy.
 rewrite e; rewrite case_eq; apply case_ineq; trivial.

 apply sigma_simpl; intros; rewrite rcop1_trans_ctrl_copy.
 apply case_ineq; trivial.
Qed.

Remark rcop1_trans_sigma_dec :
 sigma_ctrl_dec s0 (bm (rec_copy1_trans c0 s1 s2)) =
 (if eq_site_dec s0 s1
  then  (sigma_ctrl_dec s0 (bm c0) + 1)%Z
  else  sigma_ctrl_dec s0 (bm c0)).
Proof.
 intros; unfold sigma_ctrl_dec in |- *.
 case (eq_site_dec s0 s1); intro.
 apply sigma__S with (eq_E_dec := eq_site_dec) (x0 := s2).
 exact finite_site.

 rewrite rcop1_trans_ctrl_dec.
 rewrite e; rewrite case_eq; apply case_eq.

 intros; rewrite rcop1_trans_ctrl_dec.
 rewrite e; rewrite case_eq; apply case_ineq; trivial.

 apply sigma_simpl; intros; rewrite rcop1_trans_ctrl_dec.
 apply case_ineq; trivial.
Qed.

Remark rcop1_trans_sigma_inc :
 sigma_ctrl_inc s0 (bm (rec_copy1_trans c0 s1 s2)) =
 sigma_ctrl_inc s0 (bm c0).
Proof.
 unfold sigma_ctrl_inc in |- *; apply sigma_simpl; intros;
  apply rcop1_trans_ctrl_inc; auto.
Qed.

Lemma rcop1_trans_sigma_ctrl :
 sigma_ctrl s0 (bm (rec_copy1_trans c0 s1 s2)) = sigma_ctrl s0 (bm c0).
Proof.
 intros; unfold sigma_ctrl in |- *.
 rewrite rcop1_trans_sigma_copy.
 rewrite rcop1_trans_sigma_dec.
 rewrite rcop1_trans_sigma_inc.
 simpl in |- *; case (eq_site_dec s0 s1); intro; omega.
Qed.

End REC_COP1_CTRL.

Section REC_COP1_XY.

Variable c0 : Config.

Variable s1 s2 : Site.

Hypothesis first_mess : first Message (bm c0 s1 s2) = value Message copy.

Remark rcop1_trans_xi :
 forall s0 : Site, xi (rec_copy1_trans c0 s1 s2) s0 = xi c0 s0.
Proof.
 intro; unfold xi in |- *.
 rewrite rcop1_trans_ctrl_copy.
 rewrite rcop1_trans_ctrl_dec.
 simpl in |- *; case (eq_site_dec owner s1); intro.
 case (eq_site_dec s0 s2); intro.
 omega.

 trivial.

 trivial.

 trivial.

 trivial.
Qed.

Remark rcop1_trans_yi :
 forall s0 : Site, yi (rec_copy1_trans c0 s1 s2) s0 = yi c0 s0.
Proof.
 intro; unfold yi in |- *; apply sigma_simpl.
 intros; apply rcop1_trans_ctrl_inc; trivial.
Qed.

Lemma rcop1_trans_sigma_xi :
 sigma_xi (rec_copy1_trans c0 s1 s2) = sigma_xi c0.
Proof.
 unfold sigma_xi in |- *; apply sigma_simpl; intros; apply rcop1_trans_xi.
Qed.

Lemma rcop1_trans_sigma_yi :
 sigma_yi (rec_copy1_trans c0 s1 s2) = sigma_yi c0.
Proof.
 unfold sigma_yi in |- *; apply sigma_simpl; intros; apply rcop1_trans_yi.
Qed.

End REC_COP1_XY.

Section REC_COP1_ALT.

Variable c0 : Config.

Variable s0 s1 s2 : Site.

Lemma rcop1_trans_D :
 D_queue (bm c0 s0 owner) -> D_queue (bm (rec_copy1_trans c0 s1 s2) s0 owner).
Proof.
 simpl in |- *; intros.
 case (eq_queue_dec s2 s0 s1 owner); intro.
 decompose [and] a; rewrite H0; rewrite H1.
 apply D_post_dec.

 apply D_post_elsewhere.
 trivial.

 apply D_collect; trivial.
Qed.

Lemma rcop1_trans_alt :
 alternate (bm c0 s0 owner) ->
 alternate (bm (rec_copy1_trans c0 s1 s2) s0 owner).
Proof.
 case (eq_queue_dec s2 s0 s1 owner); intros; simpl in |- *.
 decompose [and] a; rewrite H0; rewrite H1.
 apply alt_post_dec.
 apply alt_collect; trivial.

 apply alt_post_elsewhere.
 trivial.

 apply alt_collect; trivial.
Qed.

End REC_COP1_ALT.

Section REC_COP1_RELAT.

Variable c0 : Config.

Variable s1 s2 : Site.

Remark rcop1_trans_parent :
 forall s3 s4 : Site,
 parent (rec_copy1_trans c0 s1 s2) s4 s3 -> parent c0 s4 s3.
Proof.
 intros; elim H.
 intros; apply parent_intro.
 apply rcop1_trans_in_queue with (s1 := s1) (s2 := s2); trivial.
Qed.

Lemma rcop1_trans_parent_cr :
 forall s3 s4 : Site,
 (parent c0 s3 s4 -> dt c0 s3 < dt c0 s4) ->
 parent (rec_copy1_trans c0 s1 s2) s3 s4 ->
 dt (rec_copy1_trans c0 s1 s2) s3 < dt (rec_copy1_trans c0 s1 s2) s4.
Proof.
 simpl in |- *; intros; apply H.
 apply rcop1_trans_parent; trivial.
Qed.

End REC_COP1_RELAT.
