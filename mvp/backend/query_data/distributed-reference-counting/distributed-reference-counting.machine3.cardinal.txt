
Require Export reduce.
(* reduce:
Require Export Bool. 
Require Export fifo. 

Unset Standard Proposition Elimination Names.

Section REDUCE.

Variable E : Set.

Variable f : E -> Z.

Fixpoint reduce (q : queue E) : Z :=
  match q with
  | empty => 0%Z
  | input d q' => (reduce q' + f d)%Z
  end.

Hypothesis positive_function : forall a : E, (f a > 0)%Z.

Lemma sum_positive :
 forall a b : Z, (a >= 0)%Z -> (b > 0)%Z -> (a + b >= 0)%Z.

Lemma reduce_nil : reduce (empty E) = 0%Z.

Lemma reduce_null_fun :
 forall q : queue E, (forall d : E, f d = 0%Z) -> reduce q = 0%Z.

Lemma reduce_positive : forall q : queue E, (reduce q >= 0)%Z.

Lemma reduce_append :
 forall (q1 : queue E) (d : E) (q2 : queue E),
 reduce (append E q1 (input E d q2)) = (reduce (append E q1 q2) + f d)%Z.

Lemma reduce_append_nil1 :
 forall (d : E) (q2 : queue E), reduce (input E d q2) = (reduce q2 + f d)%Z.

Lemma reduce_append_nil2 :
 forall (q1 : queue E) (d : E),
 reduce (append E q1 (input E d (empty E))) = (reduce q1 + f d)%Z.

Lemma reduce_append_nil2_symmetric :
 forall (q1 : queue E) (d : E),
 reduce q1 = (reduce (append E q1 (input E d (empty E))) - f d)%Z.

End REDUCE.

Section DISJOINT.

Variable E : Set.

Definition fun_or (pred1 pred2 : E -> bool) (a : E) := pred1 a || pred2 a.

Definition fun_sum (f1 f2 : E -> Z) (a : E) := (f1 a + f2 a)%Z.

Definition fun_minus (f1 f2 : E -> Z) (a : E) := (f1 a - f2 a)%Z.

Variable f : E -> Z.

Lemma disjoint_reduce :
 forall (f1 f2 : E -> Z) (q : queue E),
 reduce E (fun_sum f1 f2) q = (reduce E f1 q + reduce E f2 q)%Z.

Lemma disjoint_reduce3 :
 forall (f1 f2 : E -> Z) (q : queue E),
 reduce E (fun_minus f1 f2) q = (reduce E f1 q - reduce E f2 q)%Z.

Lemma reduce_simpl :
 forall (f1 f2 : E -> Z) (q : queue E),
 (forall d : E, f1 d = f2 d) -> reduce E f1 q = reduce E f2 q.

End DISJOINT.

Section REDUCE_MORE.

Variable data : Set.
Hypothesis eq_data_dec : eq_dec data.

Variable f : data -> Z.

Lemma reduce_first_out :
 forall (q : queue data) (m : data),
 first data q = value data m ->
 reduce data f (first_out data q) = (reduce data f q - f m)%Z.

End REDUCE_MORE.

Section reduce_pos.

Variable E : Set.

Variable f : E -> Z.
Hypothesis positive_function : forall a : E, (f a >= 0)%Z.

Lemma reduce_positive_or_null : forall q : queue E, (reduce E f q >= 0)%Z.

End reduce_pos.

Section reduce_strictly_pos.

Variable E : Set.

Variable f : E -> Z.
Hypothesis positive_function : forall a : E, (f a >= 0)%Z.

Hypothesis eq_E_dec : eq_dec E.

Lemma reduce_in_queue_strictly_positive :
 forall (x : E) (q : queue E),
 (f x > 0)%Z -> In_queue E x q -> (reduce E f q > 0)%Z.
End reduce_strictly_pos.

Section reduce_in_q_null.
Variable E : Set.

Variable f : E -> Z.

Hypothesis eq_E_dec : eq_dec E.

Lemma reduce_in_queue_null :
 forall q : queue E,
 (forall x : E, In_queue E x q -> f x = 0%Z) -> reduce E f q = 0%Z.

End reduce_in_q_null. *)
Require Export DistributedReferenceCounting.machine3.machine.

Section COUNT_MESSAGE.

Definition dec_predicate (m : Message) :=
  match m with
  | dec => true
  | _ => false
  end.

Definition inc_predicate (m : Message) :=
  match m with
  | inc_dec _ => true
  | _ => false
  end.

Variable s0 : Site.

Definition site_inc_predicate (m : Message) :=
  match m with
  | inc_dec s => if eq_site_dec s s0 then true else false
  | _ => false
  end.

Definition copy_predicate (m : Message) :=
  match m with
  | copy => true
  | _ => false
  end.

Definition dec_count (m : Message) :=
  match m with
  | dec => 1%Z
  | _ => 0%Z
  end.

Definition inc_count (m : Message) := 0%Z.

Definition copy_count (m : Message) :=
  match m with
  | copy => 1%Z
  | _ => 0%Z
  end.

Definition cardinal_count :=
  fun_sum Message dec_count (fun_sum Message inc_count copy_count).

Definition cardinal := reduce Message cardinal_count.

Lemma disjoint_cardinal :
 forall q : queue Message,
 cardinal q =
 (reduce Message dec_count q +
  (reduce Message inc_count q + reduce Message copy_count q))%Z.
Proof.
  intro.
  rewrite <- disjoint_reduce.
  rewrite <- disjoint_reduce.
  unfold cardinal in |- *.
  unfold cardinal_count in |- *.
  auto.
Qed.

Lemma cardinal_first_out :
 forall (q : queue Message) (m : Message),
 first Message q = value Message m ->
 cardinal (first_out Message q) = (cardinal q - cardinal_count m)%Z.
Proof.
  intros.
  unfold cardinal in |- *.
  apply reduce_first_out.
  auto.
Qed.

End COUNT_MESSAGE.

Section SIG_WEIGHT.
Let Bag_of_message := Bag_of_Data Message.

Definition sigma_weight (bm : Bag_of_message) :=
  sigma2_table Site LS LS (queue Message) (fun s1 s2 : Site => cardinal) bm.

End SIG_WEIGHT.

