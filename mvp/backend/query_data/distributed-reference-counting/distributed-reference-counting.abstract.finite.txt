
Require Import List.
Require Export bibli.
(* bibli:
Require Export Arith.
Require Export Omega.
Require Import List.

Global Set Asymmetric Patterns.

Section SEPAR.

Lemma eq_bool_dec : forall b : bool, {b = true} + {b = false}.

Definition eq_dec (E : Set) := forall a b : E, {a = b} + {a <> b}.

Lemma case_eq :
 forall (E F : Set) (eq_E_dec : eq_dec E) (x : E) (y z : F),
 match eq_E_dec x x with
 | left _ => y
 | right _ => z
 end = y. 

Lemma case_ineq :
 forall (E F : Set) (eq_E_dec : eq_dec E) (x x' : E) (y z : F),
 x <> x' -> match eq_E_dec x x' with
            | left _ => y
            | right _ => z
            end = z. 

Lemma eq_couple_dec :
 forall (E F : Set) (eq_E_dec : eq_dec E) (eq_F_dec : eq_dec F) 
   (x1 x2 : E) (y1 y2 : F), {x1 = x2 /\ y1 = y2} + {x1 <> x2 \/ y1 <> y2}.

End SEPAR.

Section OTHER.

Definition Int (b : bool) := if b then 1%Z else 0%Z.

Lemma true_not_false : forall b : bool, b = true -> false <> b.

Axiom
  funct_eq :
    forall (E F : Set) (g h : E -> F), (forall e : E, g e = h e) -> g = h. 

Lemma in_not_in :
 forall (E : Set) (a b : E) (l : list E), In a l -> ~ In b l -> a <> b. 

End OTHER.

Section PointFixe.

Variable A : Set.
Variable P : A -> Set.
Variable R : A -> A -> Prop.
Hypothesis Rwf : well_founded R.
Variable F : forall x : A, (forall y : A, R y x -> P y) -> P x.

Hypothesis
  F_ext :
    forall (x : A) (f g : forall y : A, R y x -> P y),
    (forall (y : A) (p : R y x), f y p = g y p) -> F x f = F x g.

Fixpoint Fix_F (x : A) (r : Acc R x) {struct r} : P x :=
  F x (fun (y : A) (p : R y x) => Fix_F y (Acc_inv r y p)).

Scheme Acc_inv_dep := Induction for Acc Sort Prop.

Lemma Fix_F_eq :
 forall (x : A) (r : Acc R x),
 Fix_F x r = F x (fun (y : A) (p : R y x) => Fix_F y (Acc_inv r y p)).
                                     
Lemma Fix_F_inv : forall (x : A) (r s : Acc R x), Fix_F x r = Fix_F x s.

Definition Fix (x : A) := Fix_F x (Rwf x).

Lemma fix_eq : forall x : A, Fix x = F x (fun (y : A) (p : R y x) => Fix y).

End PointFixe.

Section WF_ROOT.

Variable E : Set.

Variable f : E -> nat.

Variable R : E -> E -> Prop.

Hypothesis R_dec : forall x : E, {y : E | R y x} + {(forall y : E, ~ R y x)}.

Hypothesis strict : forall x y : E, R x y -> f x < f y.

Lemma lt_acc : forall (n : nat) (y : E), f y < n -> Acc R y.

Lemma wf_R : well_founded R.

Definition F (x : E) (f : forall y : E, R y x -> E) :=
  match R_dec x with
  | inleft z => let (y0, r0) := z in f y0 r0
  | inright _ => x
  end.

Lemma F_eq :
 forall (x : E) (f1 f2 : forall y : E, R y x -> E),
 (forall (y : E) (r : R y x), f1 y r = f2 y r) -> F x f1 = F x f2.

Definition root := Fix E (fun _ : E => E) R wf_R F.

Definition root_eq := fix_eq E (fun _ : E => E) R wf_R F F_eq.

Lemma root_no_R : forall x y : E, ~ R y (root x).

Lemma prop_root :
 forall (P : E -> Prop) (x : E),
 P x -> (forall y z : E, P y -> R z y -> P z) -> P (root x).

End WF_ROOT. *)

Unset Standard Proposition Elimination Names.

Section DEFIN.

Variable E : Set.

Hypothesis eq_E_dec : eq_dec E.

Fixpoint only_once (x : E) (l : list E) {struct l} : Prop :=
  match l with
  | nil => False
  | y :: l' =>
      if eq_E_dec x y then ~ In x l' else only_once x l'
  end.

Definition list_of_elements (l : list E) := forall x : E, only_once x l.

Lemma only_once_in : forall (l : list E) (x : E), only_once x l -> In x l.
Proof.
 simple induction l.
 auto.
 simpl in |- *; intros a l0 hrec x.
 case (eq_E_dec x a); auto.
Qed.

Lemma equality_from_membership :
 forall (x y : E) (l : list E), In y l -> ~ In x l -> x <> y.
Proof.
  simple induction l.
  simpl in |- *; intuition.
  
  intros a l' H.
  simpl in |- *.
  case (eq_E_dec a y).
  intro e.
  rewrite e.
  intro H0.
  intuition.
  
  intros n H0 H1.
  apply H.
  auto.
  intuition.
  intuition.
Qed.

End DEFIN.

Section SUM.

Variable E : Set.

Fixpoint sigma (l1 : list E) : (E -> Z) -> Z :=
  fun f : E -> Z =>
  match l1 with
  | nil => 0%Z
  | e :: l2 => (f e + sigma l2 f)%Z
  end.
	
Lemma sigma_null : forall l : list E, sigma l (fun e : E => 0%Z) = 0%Z.
Proof. 
 simple induction l; auto.  
Qed.

Lemma sigma_pos :
 forall (f : E -> Z) (l : list E),
 (forall x_ : E, (f x_ >= 0)%Z) -> (sigma l f >= 0)%Z.
Proof.
 intros; elim l; simpl in |- *.
 omega.

 intros; generalize (H a); omega.
Qed.

Lemma le_sigma :
 forall (l : list E) (f : E -> Z) (x : E),
 (forall x_ : E, (f x_ >= 0)%Z) -> In x l -> (f x <= sigma l f)%Z.
Proof.
 simple induction l; simpl in |- *; intros.
 contradiction.

 decompose [or] H1.
 rewrite H2; generalize (sigma_pos f l0 H0); omega.

 generalize (H0 a); generalize (H f x H0 H2); omega.
Qed.

Lemma sigma_simpl :
 forall (l : list E) (f g : E -> Z),
 (forall x : E, In x l -> f x = g x) -> sigma l f = sigma l g.
Proof.
 simple induction l.
 auto.

 simpl in |- *; intros.
 rewrite (H f g).
 rewrite (H0 a); auto.

 auto.
Qed.

Remark le_sigma_sigma :
 forall (l : list E) (f g : E -> Z),
 (forall x : E, (f x <= g x)%Z) -> (sigma l f <= sigma l g)%Z.
Proof.
 simple induction l; simpl in |- *; intros.
 trivial with zarith.

 generalize (H f g H0); generalize (H0 a); omega.
Qed.

Lemma ge_sigma_sigma :
 forall (l : list E) (f g : E -> Z),
 (forall x : E, (f x >= g x)%Z) -> (sigma l f >= sigma l g)%Z.
Proof.
 intros; apply Zle_ge; apply le_sigma_sigma; intros; apply Zge_le; trivial.
Qed.

Hypothesis eq_E_dec : eq_dec E.

Lemma lt_sigma_sigma :
 forall (l : list E) (f g : E -> Z),
 (forall x : E, (f x <= g x)%Z) ->
 (exists y : E, (f y < g y)%Z /\ In y l) -> (sigma l f < sigma l g)%Z.
Proof.
 intros; elim H0; elim l; simpl in |- *; intros.
 elim H1; contradiction.

 decompose [and or] H2.
 rewrite H5; generalize (le_sigma_sigma l0 f g H); omega.

 cut (sigma l0 f < sigma l0 g)%Z.
 generalize (H a); omega.

 apply (H1 x); auto.
Qed.

End SUM.

Section SIGMA_BUT.

Variable E : Set.

Variable x0 : E.

Hypothesis eq_E_dec : eq_dec E.

Variable f : E -> Z.

Fixpoint sigma_but (l1 : list E) : (E -> Z) -> Z :=
  fun f : E -> Z =>
  match l1 with
  | nil => 0%Z
  | e :: l2 =>
      if eq_E_dec e x0
      then sigma_but l2 f
      else (f e + sigma_but l2 f)%Z
  end.

Lemma sigma_but_pos :
 forall (f : E -> Z) (l : list E),
 (forall x_ : E, (f x_ >= 0)%Z) -> (sigma_but l f >= 0)%Z.
Proof.
  intros; elim l; simpl in |- *.
  omega.
  intros a l0 H0.
  case (eq_E_dec a x0); intro.
  auto.
  generalize (H a); omega.
Qed.

Lemma sigma_sigma_but_not_in :
 forall l : list E, ~ In x0 l -> sigma E l f = sigma_but l f.
Proof.
  simple induction l.
  simpl in |- *.
  auto.
  
  intros a l0 H H0.
  case (eq_E_dec a x0).
  intros e.
  elim H0.
  rewrite e; simpl in |- *.
  left; auto.
  
  intros n.
  simpl in |- *.
  rewrite case_ineq.
  rewrite H.
  auto.
  
  generalize H0.
  simpl in |- *.
  intro H1.
  generalize H1.
  intuition.
  
  auto.
Qed.

Lemma sigma_sigma_but :
 forall l : list E,
 only_once E eq_E_dec x0 l -> sigma E l f = (sigma_but l f + f x0)%Z.
Proof.
  simple induction l.
  simpl in |- *; intuition.
  
  intros a l0 H H0.
  case (eq_E_dec a x0).
  intro; rewrite e; simpl in |- *.
  rewrite case_eq.
  rewrite sigma_sigma_but_not_in.
  omega.
  
  generalize H0; simpl in |- *.
  rewrite e.
  case (eq_E_dec x0 x0).
  auto.
  
  intuition.
  
  intros n.
  simpl in |- *.
  rewrite case_ineq.
  rewrite H.
  omega.
  
  generalize H0; simpl in |- *.
  case (eq_E_dec x0 a).
  intros e H1.
  rewrite e in n.
  elim n.
  auto.
  
  intro n0.
  auto.
  
  auto.
Qed.

Lemma sigma_but_simpl :
 forall (l : list E) (f g : E -> Z),
 (forall x : E, x <> x0 -> In x l -> f x = g x) ->
 sigma_but l f = sigma_but l g.
Proof.
  simple induction l.
  auto.
  
  simpl in |- *; intros.
  case (eq_E_dec a x0).
  intro e.
  apply (H f0 g).
  intros x H1 H2.
  apply H0.
  auto.
  
  right; auto.
  
  intro n.
  rewrite H0.
  rewrite (H f0 g).
  auto.
  
  intros x H1 H2.
  apply H0.
  auto.
  
  right; auto.
  
  auto.
  
  left; auto.
Qed.

End SIGMA_BUT.
