
Require Import strategies.
(* strategies:
Require Import Constants.

Inductive strategy : Set :=
    mkstrat :
      (forall n : nat, four < n -> {p : nat | p < n /\ two <= p}) -> strategy. *)
Require Import Arith.
Require Import euclid.
(* euclid:
Require Import Arith.
Require Import Constants.
Require Import Le_lt_compl.
Require Import Mult_compl.

Lemma lt_b_qbr : forall b q r : nat, 0 < r -> 0 < q -> r < b -> b < q * b + r.

Hint Resolve lt_b_qbr: arith.

Lemma lt_q_qbr : forall b q r : nat, 0 < r -> one < b -> q < q * b + r.
Hint Resolve lt_q_qbr: arith.

Lemma lt_q_qbr' : forall b q r : nat, 0 < q -> one < b -> q < q * b + r.

Hint Resolve lt_q_qbr': arith.

Lemma le_q_qbr : forall b q r : nat, 0 < b -> q <= q * b + r.
  
Hint Resolve le_q_qbr: arith.

Lemma lt_O_q : forall b q r : nat, b < q * b + r -> 0 < r -> r < b -> 0 < q. *)
Require Import shift.
(* shift:
Require Import Arith.
Require Import Peano_dec.
Require Import Constants.
Require Import Mult_compl.
Require Import Wf_nat. 
Require Import euclid.
Require Import Le_lt_compl.
Require Import Euclid.
Require Import Compare_dec.

Lemma plus_n_1 : forall n : nat, S n = n + 1.

Definition shift (n : nat) := two * n.

Lemma Unshift :
 forall n : nat, {m : nat &  {n = shift m} + {n = S (shift m)}}.

Lemma half_lt :
 forall a b : nat, 0 < b -> b = shift a \/ b = S (shift a) -> a < b.
Hint Resolve half_lt: arith. *)
Require Import two_power.
(* two_power:
Require Import Arith.
Require Import Peano_dec.
Require Import Constants.
Require Import Mult_compl.
Require Import Le_lt_compl.

Fixpoint two_power (m : nat) : nat :=
  match m with
  | O => 1
  | S n => two * two_power n
  end.

Lemma zero_lt_pow : forall a : nat, 0 < two_power a.
Hint Resolve zero_lt_pow: arith.

Lemma two_power_S : forall n : nat, two_power (S n) = two_power n * two.

Lemma two_power_S_lt : forall n : nat, two_power n < two_power (S n).

Lemma two_power_mono : forall n p : nat, n < p -> two_power n < two_power p.

Lemma two_power_le : forall n p : nat, n <= p -> two_power n <= two_power p.

Lemma two_power_monoR : forall n p : nat, two_power n < two_power p -> n < p.

Lemma holes_in_powers :
 forall n z : nat,
 two_power n < z -> z < two_power (S n) -> forall p : nat, z <> two_power p.

Lemma log2_unicity :
 forall n p z : nat,
 two_power n < z ->
 z < two_power (S n) -> two_power p < z -> z < two_power (S p) -> n = p. *)
Require Import log2_spec.
(* log2_spec:
Require Import Arith.
Require Import Peano_dec.
Require Import Constants.
Require Import Mult_compl.
Require Import Wf_nat. 
Require Import euclid.
Require Import Le_lt_compl.
Require Import shift.
Require Import Compare_dec.
Require Import two_power.

Definition log2_spec (n0 : nat) :=
  {l : nat & 
  {n0 = two_power l} + {two_power l < n0 /\ n0 < two_power (S l)}}.

Section applications.
 Variable log2 : forall n : nat, 0 < n -> log2_spec n.
 
 Lemma ceiling_log2 :
  forall n : nat,
  one < n -> {l : nat | two_power (pred l) < n /\ n <= two_power l}.
 
 Lemma floor_log2 :
  forall n : nat,
  0 < n -> {l : nat | two_power l <= n /\ n < two_power (S l)}.
End applications. *)
Require Import Euclid.
Require Import Le_lt_compl.
(* Le_lt_compl:
Require Import Arith.
Require Import Constants.

Lemma lt_or_Zero : forall q : nat, 0 < q \/ q = 0.

Lemma one_cases : forall q : nat, 1 < q \/ q = 0 \/ q = 1.

Lemma enum1 : forall n : nat, n < two -> n = 0 \/ n = 1.

Lemma le5 :
 forall P : nat -> Prop,
 P 0 ->
 P one ->
 P two ->
 P three ->
 P four -> (forall n : nat, four < n -> P n) -> forall n : nat, P n.

Lemma enum4 :
 forall n : nat,
 n < S four -> n = 0 \/ n = one \/ n = two \/ n = three \/ n = four.

Lemma not_le_lt : forall n m : nat, ~ n <= m -> m < n.
Hint Immediate not_le_lt: arith.

Lemma not_lt_le : forall n m : nat, ~ n < m -> m <= n.
Hint Immediate not_lt_le: arith.

Lemma lt_not_lt : forall n p : nat, n < p -> ~ p < S n.

Lemma lt_a_a_plus_b : forall a b : nat, 0 < b -> a < a + b.

Hint Resolve lt_a_a_plus_b: arith. *)
Require Import Mult_compl.
(* Mult_compl:
Require Import Arith.
Require Import Constants.
Require Import Le_lt_compl.

Lemma mult_le_l : forall a b c : nat, b <= c -> a * b <= a * c.
Hint Resolve mult_le_l: arith.

Lemma mult_lt_l : forall a b c : nat, 0 < a -> b < c -> a * b < a * c.

Hint Resolve mult_lt_l: arith.

Lemma mult_le_r : forall a b c : nat, b <= c -> b * a <= c * a.
Hint Resolve mult_le_r: arith.

Lemma mult_lt_r : forall a b c : nat, 0 < a -> b < c -> b * a < c * a.
Hint Resolve mult_lt_r: arith.

Lemma mult_inj_l : forall a b c : nat, a * c < b * c -> a < b.

Lemma mult_p_lt_qp : forall p q : nat, 0 < p -> one < q -> p < q * p.  

Lemma mult_p_le_qp : forall p q : nat, 0 < q -> p <= q * p.

Hint Resolve mult_p_lt_qp mult_p_le_qp: arith.
 
Lemma mult_p_lt_pq : forall p q : nat, 0 < p -> one < q -> p < p * q.  

Lemma mult_p_le_pq : forall p q : nat, 0 < q -> p <= p * q.

Hint Resolve mult_p_lt_pq mult_p_le_pq: arith.

Lemma quotient_positive : forall q n n0 : nat, n = q * n0 -> 0 < n -> 0 < q.

Lemma quotient_gt_one : forall q n n0 : nat, n0 < n -> n = q * n0 -> one < q. *)
Require Import Constants.
(* Constants:
Global Set Asymmetric Patterns.

Definition one := 1.
Definition two := 2.
Definition three := 3.
Definition four := 4. *)

Section import_log2.
Variable log2_r : forall n : nat, 0 < n -> log2_spec n. 

Lemma dicho : strategy.

Proof.
 split.
 intros n H.
 elim (ceiling_log2 log2_r n).
 2: apply lt_trans with four; unfold one, four in |- *; auto with arith.
 intros x y.
 elim y; intros.
 cut (0 < 2).
 2: auto with arith.
 intro H'.
 elim (quotient 2 H' x); intros.
 refine match quotient (two_power x0) _ n with
        | exist n0 e => exist _ n0 _
        end.

 unfold gt in |- *.
 apply lt_le_trans with 1; auto with arith.

 elim p; intros.
 elim e; intros.
 elim H2; intros H4 H5.
 elim H3; intros H6 H7.
 clear y p e H2 H3 H'.
 cut (0 < x0).
 2: case (lt_or_Zero x0); [ auto with arith | intro ].
 2: cut (x <= one).
 2: intro.
 2: absurd (n <= two).  
 2: unfold not in |- *; intro.
 2: absurd (four < two).  
 2: apply le_not_lt; auto with arith.
 2: unfold four, two in |- *; auto with arith.
 2: apply lt_le_trans with n; auto with arith.
 2: replace two with (two_power one).
 2: apply le_trans with (two_power x).
 2: auto with arith.
 2: apply two_power_le; auto with arith.
 2: simpl in |- *; auto with arith.
 2: rewrite H4; rewrite H2; simpl in |- *; auto with arith.
 intro x0_pos.
 cut (1 < two_power x0).
 2: replace 1 with (two_power 0).
 2: apply two_power_mono; auto with arith.
 2: simpl in |- *; auto with arith.
 intro H8. 
 cut (x0 < x).
 2: rewrite H4.
 2: apply lt_le_trans with (x0 * 2).
 2: rewrite mult_comm; apply mult_p_lt_qp; auto with arith.
 2: auto with arith.
 intro H9.
 cut (x0 <= pred x).
 2: apply le_S_n.
 2: elim (S_pred _ _ H9).
 2: auto with arith.
 intro H10.
 cut (0 < n0).
 2: case (lt_or_Zero n0); [ auto with arith | intro ].
 2: absurd (n < two_power x0).
 2: apply le_not_lt.
 2: apply le_trans with (two_power (pred x)).
 2: apply two_power_le; auto with arith.
 2: auto with arith.
 2: rewrite H6; rewrite H2; simpl in |- *.
 2: auto with arith.
 intro H11. 
 split.
 apply lt_le_trans with (n0 * two_power x0).
 rewrite mult_comm; apply mult_p_lt_qp; auto with arith.
 rewrite H6; auto with arith.

 apply not_lt_le.
 unfold not in |- *; intro H12.
 case (enum1 n0 H12); intro.
 absurd (0 < n0); [ rewrite H2; auto with arith | auto with arith ].

 cut (n < two_power (S x0)).
 2: rewrite H6.
 2: rewrite H2.
 2: rewrite mult_1_l.
 2: rewrite two_power_S.
 2: rewrite mult_comm; simpl in |- *.
 2: rewrite <- plus_n_O.
 2: apply plus_lt_compat_l.
 2: auto with arith.
 intro.
 cut (two_power x0 <= n).
 intro H13.
 cut (S x0 <= x); [ intro H14 | auto with arith ].
 case (le_lt_or_eq _ _ H14); intro.
 cut (S x0 <= pred x); [ intro | auto with arith ].
 absurd (n < n); [ auto with arith | idtac ].
 apply lt_trans with (two_power (S x0)).
 auto with arith.
 apply le_lt_trans with (two_power (pred x)).
 apply two_power_le; auto with arith.
 auto with arith.
 
 cut (x0 <= 1).
 intro H16.
 absurd (n < four).
 apply lt_asym.
 auto with arith.

 apply lt_le_trans with (two_power (S x0)).
 auto with arith.
 replace four with (two_power 2).
 apply two_power_le; auto with arith.
 unfold four in |- *; simpl in |- *; auto with arith.
 apply (fun p n m : nat => plus_le_reg_l n m p) with x0.
 replace (x0 + x0) with (x0 * 2).
 rewrite plus_comm; simpl in |- *.
 apply le_trans with x.
 rewrite H4; auto with arith.
 elim H15; auto with arith.
 rewrite mult_comm; simpl in |- *; rewrite <- plus_n_O; auto with arith.
 rewrite <- (mult_1_l (two_power x0)).
 elim H2; rewrite H6; auto with arith.
Qed.

End import_log2.

