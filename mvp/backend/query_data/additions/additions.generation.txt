

Require Import monoid.
(* monoid:
Require Import Arith.
Require Import Constants.

Section monoid_def.

Variable M : Set.

Record monoid : Set := mkmonoid
  {u : M;
   o : M -> M -> M;
   point_assoc : forall a b c : M, o a (o b c) = o (o a b) c;
   u_neutral_l : forall a : M, o u a = a;
   u_neutral_r : forall a : M, o a u = a}.

Hint Resolve point_assoc u_neutral_r u_neutral_l: arith.

Variable MO : monoid.
Let u' := u MO.
Let o' := o MO.
Remark o'_assoc : forall a b c : M, o' a (o' b c) = o' (o' a b) c.
Hint Resolve o'_assoc: arith.

Remark u'_neutral_l : forall a : M, o' u' a = a.
Hint Resolve u'_neutral_l: arith.

Remark u'_neutral_r : forall a : M, o' a u' = a.
Hint Resolve u'_neutral_r: arith.

Fixpoint power (x : M) (n : nat) {struct n} : M :=
  match n with
  | O => u'
  | S n => o' x (power x n)
  end.
                                     
Lemma power_u : forall m : nat, power u' m = u'.
Hint Resolve power_u: arith.

Lemma power_plus :
 forall (a : M) (n p : nat), power a (n + p) = o' (power a n) (power a p).
Hint Resolve power_plus: arith.

Lemma power_1 : forall a : M, power a 1 = a.

Lemma power_sym :
 forall (a : M) (n p : nat),
 o' (power a n) (power a p) = o' (power a p) (power a n).
Hint Resolve power_sym: arith.

Lemma power_mult :
 forall (a : M) (n p : nat), power a (p * n) = power (power a n) p.
Hint Resolve power_mult: arith.

Lemma a2x : forall (a : M) (x : nat), power (o' a a) x = power a (x + x).

Lemma power_eucl :
 forall (m : M) (b q r : nat),
 power m (q * b + r) = o' (power (power m b) q) (power m r).
Hint Resolve power_eucl: arith.

End monoid_def. *)

Require Import spec.

Require Import Constants.
(* Constants:
Global Set Asymmetric Patterns.

Definition one := 1.
Definition two := 2.
Definition three := 3.
Definition four := 4. *)

Require Import machine.
(* machine:
Require Import monoid.
Require Import Constants.

Inductive Instr : Set :=
  | MUL : Instr
  | SQR : Instr
  | PUSH : Instr
  | SWAP : Instr.       

Inductive Code : Set :=
  | End : Code
  | seq : Instr -> Code -> Code.

Fixpoint app (c : Code) : Code -> Code :=
  fun c' : Code => match c with
                   | End => c'
                   | seq i c => seq i (app c c')
                   end.

Section Monoid.
 Variable M : Set.
 Variable MO : monoid M.
 Let uM := u _ MO.
 Let oM := o _ MO.

 Inductive Stack : Set :=
   | emptystack : Stack
   | push : M -> Stack -> Stack.

 Definition top (s : Stack) :=
   match s return M with
   | emptystack => uM
   | push m _ => m
   end.
 Definition pop (s : Stack) :=
   match s return Stack with
   | emptystack => emptystack
   | push _ r => r
   end.

 Record Config : Set := config {config_X : M; config_S : Stack}.

 Lemma Config_inv :
  forall (a a' : M) (s s' : Stack),
  a = a' -> s = s' -> config a s = config a' s'.
 
 Hint Resolve Config_inv: arith.

 Definition Exec1 (c : Instr) (v : Config) : Config :=
   let (m, s) := v in
   match c with
   | MUL => config (oM m (top s)) (pop s) 
   | SQR => config (oM m m) s
   | PUSH => config m (push m s)
   | SWAP => config m (push (top (pop s)) (push (top s) (pop (pop s))))
   end.
 
Fixpoint Exec (c : Code) : Config -> Config :=
  fun v : Config =>
  match c with
  | End => v
  | seq i c => Exec c (Exec1 i v)
  end.

 Lemma Exec_app :
  forall (c c' : Code) (v : Config), Exec (app c c') v = Exec c' (Exec c v).

End Monoid. *)

Require Import Euclid.

Require Import Le_lt_compl.
(* Le_lt_compl:
Require Import Arith.
Require Import Constants.

Lemma lt_or_Zero : forall q : nat, 0 < q \/ q = 0.

Lemma one_cases : forall q : nat, 1 < q \/ q = 0 \/ q = 1.

Lemma enum1 : forall n : nat, n < two -> n = 0 \/ n = 1.

Lemma le5 :
 forall P : nat -> Prop,
 P 0 ->
 P one ->
 P two ->
 P three ->
 P four -> (forall n : nat, four < n -> P n) -> forall n : nat, P n.

Lemma enum4 :
 forall n : nat,
 n < S four -> n = 0 \/ n = one \/ n = two \/ n = three \/ n = four.

Lemma not_le_lt : forall n m : nat, ~ n <= m -> m < n.
Hint Immediate not_le_lt: arith.

Lemma not_lt_le : forall n m : nat, ~ n < m -> m <= n.
Hint Immediate not_lt_le: arith.

Lemma lt_not_lt : forall n p : nat, n < p -> ~ p < S n.

Lemma lt_a_a_plus_b : forall a b : nat, 0 < b -> a < a + b.

Hint Resolve lt_a_a_plus_b: arith. *)

Require Import euclid.
(* euclid:
Require Import Arith.
Require Import Constants.
Require Import Le_lt_compl.
Require Import Mult_compl.

Lemma lt_b_qbr : forall b q r : nat, 0 < r -> 0 < q -> r < b -> b < q * b + r.

Hint Resolve lt_b_qbr: arith.

Lemma lt_q_qbr : forall b q r : nat, 0 < r -> one < b -> q < q * b + r.
Hint Resolve lt_q_qbr: arith.

Lemma lt_q_qbr' : forall b q r : nat, 0 < q -> one < b -> q < q * b + r.

Hint Resolve lt_q_qbr': arith.

Lemma le_q_qbr : forall b q r : nat, 0 < b -> q <= q * b + r.
  
Hint Resolve le_q_qbr: arith.

Lemma lt_O_q : forall b q r : nat, b < q * b + r -> 0 < r -> r < b -> 0 < q. *)

Require Import shift.
(* shift:
Require Import Arith.
Require Import Peano_dec.
Require Import Constants.
Require Import Mult_compl.
Require Import Wf_nat. 
Require Import euclid.
Require Import Le_lt_compl.
Require Import Euclid.
Require Import Compare_dec.

Lemma plus_n_1 : forall n : nat, S n = n + 1.

Definition shift (n : nat) := two * n.

Lemma Unshift :
 forall n : nat, {m : nat &  {n = shift m} + {n = S (shift m)}}.

Lemma half_lt :
 forall a b : nat, 0 < b -> b = shift a \/ b = S (shift a) -> a < b.
Hint Resolve half_lt: arith. *)

Require Import two_power.
(* two_power:
Require Import Arith.
Require Import Peano_dec.
Require Import Constants.
Require Import Mult_compl.
Require Import Le_lt_compl.

Fixpoint two_power (m : nat) : nat :=
  match m with
  | O => 1
  | S n => two * two_power n
  end.

Lemma zero_lt_pow : forall a : nat, 0 < two_power a.
Hint Resolve zero_lt_pow: arith.

Lemma two_power_S : forall n : nat, two_power (S n) = two_power n * two.

Lemma two_power_S_lt : forall n : nat, two_power n < two_power (S n).

Lemma two_power_mono : forall n p : nat, n < p -> two_power n < two_power p.

Lemma two_power_le : forall n p : nat, n <= p -> two_power n <= two_power p.

Lemma two_power_monoR : forall n p : nat, two_power n < two_power p -> n < p.

Lemma holes_in_powers :
 forall n z : nat,
 two_power n < z -> z < two_power (S n) -> forall p : nat, z <> two_power p.

Lemma log2_unicity :
 forall n p z : nat,
 two_power n < z ->
 z < two_power (S n) -> two_power p < z -> z < two_power (S p) -> n = p. *)

Require Import log2_spec.
(* log2_spec:
Require Import Arith.
Require Import Peano_dec.
Require Import Constants.
Require Import Mult_compl.
Require Import Wf_nat. 
Require Import euclid.
Require Import Le_lt_compl.
Require Import shift.
Require Import Compare_dec.
Require Import two_power.

Definition log2_spec (n0 : nat) :=
  {l : nat & 
  {n0 = two_power l} + {two_power l < n0 /\ n0 < two_power (S l)}}.

Section applications.
 Variable log2 : forall n : nat, 0 < n -> log2_spec n.
 
 Lemma ceiling_log2 :
  forall n : nat,
  one < n -> {l : nat | two_power (pred l) < n /\ n <= two_power l}.
 
 Lemma floor_log2 :
  forall n : nat,
  0 < n -> {l : nat | two_power l <= n /\ n < two_power (S l)}.
End applications. *)

Require Import develop.
(* develop:
Require Import Constants.
Require Import monoid.
Require Import spec.
Require Import machine.
Require Import Wf_compl.
Require Import Plus.
Require Import Mult.
Require Import Lt.
Require Import Mult_compl.
Require Import euclid.
Require Import two_power.

Lemma M3 : gencode (Call_M three).

Lemma M2q : forall q : nat, gencode (Call_M (two_power q)).

Lemma C2M : forall p q : nat, gencode (Call_C p q) -> gencode (Call_M p).

Lemma MMC :
 forall p q : nat,
 gencode (Call_M p) -> gencode (Call_M q) -> gencode (Call_C (q * p) p).

Lemma KMC :
 forall p q r : nat,
 gencode (Call_K p r) -> gencode (Call_M q) -> gencode (Call_C (q * p + r) p).

Lemma MMK :
 forall p q : nat,
 gencode (Call_M p) -> gencode (Call_M q) -> gencode (Call_K (q * p) p).

Lemma KMK :
 forall p q r : nat,
 gencode (Call_K p r) -> gencode (Call_M q) -> gencode (Call_K (q * p + r) p). *)

Require Import Arith.

Require Import Peano_dec.

Require Import Compare_dec.

Require Import strategies.
(* strategies:
Require Import Constants.

Inductive strategy : Set :=
    mkstrat :
      (forall n : nat, four < n -> {p : nat | p < n /\ two <= p}) -> strategy. *)

Require Import Mult_compl.
(* Mult_compl:
Require Import Arith.
Require Import Constants.
Require Import Le_lt_compl.

Lemma mult_le_l : forall a b c : nat, b <= c -> a * b <= a * c.
Hint Resolve mult_le_l: arith.

Lemma mult_lt_l : forall a b c : nat, 0 < a -> b < c -> a * b < a * c.

Hint Resolve mult_lt_l: arith.

Lemma mult_le_r : forall a b c : nat, b <= c -> b * a <= c * a.
Hint Resolve mult_le_r: arith.

Lemma mult_lt_r : forall a b c : nat, 0 < a -> b < c -> b * a < c * a.
Hint Resolve mult_lt_r: arith.

Lemma mult_inj_l : forall a b c : nat, a * c < b * c -> a < b.

Lemma mult_p_lt_qp : forall p q : nat, 0 < p -> one < q -> p < q * p.  

Lemma mult_p_le_qp : forall p q : nat, 0 < q -> p <= q * p.

Hint Resolve mult_p_lt_qp mult_p_le_qp: arith.
 
Lemma mult_p_lt_pq : forall p q : nat, 0 < p -> one < q -> p < p * q.  

Lemma mult_p_le_pq : forall p q : nat, 0 < q -> p <= p * q.

Hint Resolve mult_p_lt_pq mult_p_le_pq: arith.

Lemma quotient_positive : forall q n n0 : nat, n = q * n0 -> 0 < n -> 0 < q.

Lemma quotient_gt_one : forall q n n0 : nat, n0 < n -> n = q * n0 -> one < q. *)

Require Import Wf_nat.

Require Import Wf_compl.
(* Wf_compl:
Section Prop_induction.

 Variable A : Set.
 Variable R : A -> A -> Prop.
 Hypothesis W : well_founded R.
 Hint Resolve W: arith.

 Lemma Prop_wfi :
  forall P : A -> Prop,
  (forall x : A, (forall y : A, R y x -> P y) -> P x) -> forall a : A, P a.

End Prop_induction.

Definition coarser (A : Set) (R S : A -> A -> Prop) :=
  forall x y : A, R x y -> S x y.

Lemma wf_coarser :
 forall (A : Set) (R S : A -> A -> Prop),
 coarser A R S -> well_founded S -> well_founded R. *)



Inductive Call_lt : Call -> Call -> Prop :=

  | M_M_lt : forall p q : nat, p < q -> Call_lt (Call_M p) (Call_M q)

  | C_M_lt : forall p q : nat, p < q -> Call_lt (Call_C q p) (Call_M q)

  | M_C_lt : forall p q r : nat, p < r -> Call_lt (Call_M p) (Call_C r q)

  | M_K_lt : forall p q r : nat, p <= r -> Call_lt (Call_M p) (Call_K r q)

  | K_C_lt : forall p q r s : nat, q < s -> Call_lt (Call_K q p) (Call_C s r)

  | K_K_lt : forall p q r s : nat, q < s -> Call_lt (Call_K q p) (Call_K s r).



Definition Call_measure (c : Call) :=

  match c return nat with

  | Call_M n =>

      

      S (three * n)

      

  | Call_C n p => three * n

      

  | Call_K n p => S (S (three * n))

  end.



Lemma measure_compat : coarser Call Call_lt (ltof Call Call_measure).



Proof.

 unfold coarser, ltof in |- *.

 simple induction 1; unfold Call_measure in |- *. 

 intros; apply lt_n_S; apply mult_lt_l; auto with arith.

 unfold three in |- *; auto with arith.

 auto with arith.

 intros.

 apply lt_le_trans with (three * S p).

 simpl in |- *.

 apply lt_n_S.

 rewrite <- plus_n_O.

 apply plus_lt_compat_l.

 rewrite <- plus_Snm_nSm.

 simpl in |- *; auto with arith.

 auto with arith.

 auto with arith.

 intros.

 apply lt_le_trans with (three * S q).

 replace (three * S q) with (S (S (S (three * q)))).

 auto with arith.

 rewrite <- mult_n_Sm.

 rewrite plus_comm; simpl in |- *; auto with arith.

 auto with arith.

 intros; do 2 apply lt_n_S; apply mult_lt_l; auto with arith.

 unfold three in |- *; auto with arith.

Qed.



Lemma Wf_Call_lt : well_founded Call_lt.



Proof.

 apply wf_coarser with (ltof Call Call_measure).

 exact measure_compat.

 apply well_founded_ltof.

Qed.



Section generation.

  Variable gamma : strategy.

  Variable log2_r : forall n : nat, 0 < n -> log2_spec n.



  Lemma chain_cases :

   forall p : nat,

   0 < p ->

   {q : nat | q < p /\ two <= q} + {l : nat | p = two_power l} + {p = three}.

  

  Proof.

  refine

   (fun p _H =>

    match eq_nat_dec p three with

    | left h => inright _ h

    | right n =>

        match log2_r p _ with

        | existS l b =>

            match b with

            | left _ => inleft _ (inr _ (exist _ l _))

            | right a =>

                match gamma with

                | mkstrat s =>

                    match s p _ with

                    | exist q _ => inleft _ (inl _ (exist _ q _))

                    end

                end

            end

        end

    end); auto.



  case (le_or_lt (S four) p); [ auto with arith | intro H2 ].

  case (enum4 p H2); intro.

  absurd (0 < p); [ rewrite H; auto with arith | auto with arith ]. 

  elim H; intro H3.

  absurd (p = one); [ replace one with (two_power 0) | auto with arith ].

  apply holes_in_powers with l; elim a; auto with arith.

  simpl in |- *; auto with arith.

  elim H3; intro H4.  

  absurd (p = two); [ replace two with (two_power one) | auto with arith ].

  apply holes_in_powers with l; elim a; auto with arith.

  simpl in |- *; auto with arith. 

  elim H4; intro H5.

  elim (n H5).

  absurd (p = four); [ replace four with (two_power two) | auto with arith ].

  apply holes_in_powers with l; elim a; auto with arith.

  simpl in |- *; auto with arith. 

 Qed.



 Lemma COND3 :

  forall (A : nat -> Set) (p : nat),

  (p = three -> A p) ->

  (forall q : nat, p = two_power q -> A p) ->

  (forall q : nat, q < p -> two <= q -> A p) -> 0 < p -> A p.



 Proof.

 refine

  (fun A p case3 case_2n case_gamma h =>

   match chain_cases p _ with

   | inleft b =>

       match b with

       | inl b1 => match b1 with

                   | exist q hq => case_gamma q _ _

                   end

       | inr b2 => match b2 with

                   | exist q hq => case_2n q hq

                   end

       end

   | inright h => case3 h

   end); auto; elim hq; auto.



 Qed.



 Lemma chain_algo : forall c : Call, conform c -> gencode c.

 

 Proof.

 refine

  (well_founded_induction Wf_Call_lt (fun c => conform c -> gencode c) _).

 intros c; case c; [ intro p | intros p n0 | intros p n0 ]; intros hr hc;

  simpl in hc.



 apply (COND3 (fun n => gencode (Call_M n)) p); auto with arith.

 intros h; rewrite h; apply M3.

 intros q h; rewrite h; apply M2q.

 refine (fun q _ _ => C2M p q (hr (Call_C p q) _ _)); auto with arith.

  constructor 2; auto with arith.

  simpl in |- *; auto with arith.



 elim hc; intros hc1 hc2.

 cut (n0 > 0);

  [ intro Hn0 | unfold gt in |- *; apply lt_trans with 1; auto with arith ].

 elim (eucl_dev n0 Hn0 p); intros q r E1 E2.

 elim (zerop r); intro Z.

 rewrite Z in E2; rewrite <- plus_n_O in E2; rewrite E2.

 cut (0 < q).

 intro Hq.

 refine (MMC n0 q (hr (Call_M n0) _ _) (hr (Call_M q) _ _)).

  constructor 3; auto with arith.

  simpl in |- *; auto with arith.

  constructor 3.

  rewrite E2; rewrite <- mult_comm; apply mult_p_lt_qp; auto with arith.

  simpl in |- *; auto with arith.

 

  apply quotient_positive with p n0; auto with arith.

  apply le_lt_trans with n0; auto with arith.



 cut (0 < q).

 intro Hq; rewrite E2.

 refine (KMC n0 q r (hr (Call_K n0 r) _ _) (hr (Call_M q) _ _)).

  constructor 5; auto with arith.

  simpl in |- *; auto with arith.

  constructor 3; auto with arith.

  rewrite E2; auto with arith.  

  simpl in |- *; auto with arith.



  apply lt_O_q with n0 r; auto; rewrite <- E2; auto.



 elim hc; intros hc1 hc2.

 cut (n0 > 0); [ intro Hn0 | unfold gt in |- *; auto with arith ].

 elim (eucl_dev n0 Hn0 p); intros q r E1 E2.

 elim (zerop r); intro Z.

 rewrite Z in E2; rewrite <- plus_n_O in E2; rewrite E2.

 cut (0 < q).

 intro Hq.

 refine (MMK n0 q (hr (Call_M n0) _ _) (hr (Call_M q) _ _)).

  constructor 4; auto with arith.

  simpl in |- *; auto with arith.

  constructor 4.

  rewrite E2; apply mult_p_le_pq; auto with arith.

  simpl in |- *; auto with arith.

 

  apply quotient_positive with p n0; auto with arith.

  apply le_lt_trans with n0; auto with arith.



 cut (0 < q).

 intro Hq; rewrite E2.

 refine (KMK n0 q r (hr (Call_K n0 r) _ _) (hr (Call_M q) _ _)). 

  constructor 6; auto with arith.

  simpl in |- *; auto with arith.

  constructor 4; auto with arith.

  rewrite E2; auto with arith.  

  simpl in |- *; auto with arith.



  apply lt_O_q with n0 r; auto; rewrite <- E2; auto.



Qed.



 Lemma power_algo : forall n : nat, 0 < n -> addchain_spec n.

 

 Proof.

  intros; split.

  apply chain_algo.

  simpl in |- *; auto with arith.

 Qed.

 

End generation.



