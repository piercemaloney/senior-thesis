

Require Import monoid.
(* monoid:
Require Import Arith.
Require Import Constants.

Section monoid_def.

Variable M : Set.

Record monoid : Set := mkmonoid
  {u : M;
   o : M -> M -> M;
   point_assoc : forall a b c : M, o a (o b c) = o (o a b) c;
   u_neutral_l : forall a : M, o u a = a;
   u_neutral_r : forall a : M, o a u = a}.

Hint Resolve point_assoc u_neutral_r u_neutral_l: arith.

Variable MO : monoid.
Let u' := u MO.
Let o' := o MO.
Remark o'_assoc : forall a b c : M, o' a (o' b c) = o' (o' a b) c.
Hint Resolve o'_assoc: arith.

Remark u'_neutral_l : forall a : M, o' u' a = a.
Hint Resolve u'_neutral_l: arith.

Remark u'_neutral_r : forall a : M, o' a u' = a.
Hint Resolve u'_neutral_r: arith.

Fixpoint power (x : M) (n : nat) {struct n} : M :=
  match n with
  | O => u'
  | S n => o' x (power x n)
  end.
                                     
Lemma power_u : forall m : nat, power u' m = u'.
Hint Resolve power_u: arith.

Lemma power_plus :
 forall (a : M) (n p : nat), power a (n + p) = o' (power a n) (power a p).
Hint Resolve power_plus: arith.

Lemma power_1 : forall a : M, power a 1 = a.

Lemma power_sym :
 forall (a : M) (n p : nat),
 o' (power a n) (power a p) = o' (power a p) (power a n).
Hint Resolve power_sym: arith.

Lemma power_mult :
 forall (a : M) (n p : nat), power a (p * n) = power (power a n) p.
Hint Resolve power_mult: arith.

Lemma a2x : forall (a : M) (x : nat), power (o' a a) x = power a (x + x).

Lemma power_eucl :
 forall (m : M) (b q r : nat),
 power m (q * b + r) = o' (power (power m b) q) (power m r).
Hint Resolve power_eucl: arith.

End monoid_def. *)

Require Import Arith.

Require Import ZArith.

Require Import Compare_dec.

Require Import fmpc.
(* fmpc:
 *)



Record Mat2 : Set := mat2 {M11 : Z; M12 : Z; M21 : Z; M22 : Z}.



Definition Id2 := mat2 1 0 0 1.   



Definition Mat_mult (M M' : Mat2) :=

  mat2 (M11 M * M11 M' + M12 M * M21 M') (M11 M * M12 M' + M12 M * M22 M')

    (M21 M * M11 M' + M22 M * M21 M') (M21 M * M12 M' + M22 M * M22 M').



Axiom

  Mat_assoc :

    forall M M' M'' : Mat2,

    Mat_mult M (Mat_mult M' M'') = Mat_mult (Mat_mult M M') M''.



Lemma matrix : monoid Mat2.

 refine (mkmonoid Mat2 Id2 Mat_mult _ _ _).



 exact Mat_assoc.

 simple induction a. 

  intros M13 M14 M23 M24.

  unfold Id2, Mat_mult in |- *; simpl in |- *.

  repeat elim Zplus_0_r_reverse.

  case M13; case M14; case M23; case M24; auto.

  simple induction a. 

  intros.

  unfold Id2, Mat_mult in |- *; simpl in |- *.

  repeat elim Zmult_0_r_reverse.

  repeat rewrite Zmult_1_r. 

  simpl in |- *; repeat elim Zplus_0_r_reverse.

  auto with arith.

Defined.



Fixpoint Fib (n : nat) : nat :=

  match n return nat with

  | O =>   1

       

  | S p =>

      match p return nat with

      | O =>   1

          

      | S q => Fib q + Fib p

      end

  end.



Lemma Unfold_FibO : Fib 0 = 1.

Proof.

 unfold Fib in |- *; simpl in |- *; auto with arith.

Qed.



Lemma Unfold_Fib1 : Fib 1 = 1.

Proof.

 unfold Fib in |- *; simpl in |- *; auto with arith.

Qed.



Lemma Unfold_FibSSn : forall n : nat, Fib (S (S n)) = Fib (S n) + Fib n.

Proof.

 intro n; unfold Fib at 1 in |- *.

 simpl in |- *; auto with arith.

Qed.



Definition shift_Fib (n : nat) :=

  match n return nat with

  | O => 0

  | S p => Fib p

  end.



Lemma Unfold_shift_Fib : forall n : nat, shift_Fib (S n) = Fib n.

Proof.

 intro n; unfold shift_Fib in |- *; auto with arith.

Qed.



Lemma Simpl_shift_Fib :

 forall n : nat, shift_Fib (S (S n)) = shift_Fib (S n) + shift_Fib n.

Proof.

 simple induction n.

 unfold shift_Fib, Fib in |- *; simpl in |- *; auto with arith.

 intros.

 unfold shift_Fib in |- *.

 rewrite Unfold_FibSSn; auto with arith.

Qed.



Definition fib_mat := mat2 1 1 1 0.



Lemma fib_mat_n :

 forall (n : nat) (a b d : Z),

 power Mat2 matrix fib_mat n = mat2 a b b d ->

 power Mat2 matrix fib_mat (S n) = mat2 (a + b) (b + d) a b.

Proof.

 intros; simpl in |- *.

 rewrite H.

 unfold Mat_mult in |- *.

 simpl in |- *.

 repeat elim Zplus_0_r_reverse.

 case a; case b; case d; auto.

Qed.



Lemma fib_n :

 forall n : nat,

 power Mat2 matrix fib_mat (S n) =

 mat2 (Z_of_nat (shift_Fib (S (S n)))) (Z_of_nat (shift_Fib (S n)))

   (Z_of_nat (shift_Fib (S n))) (Z_of_nat (shift_Fib n)).

Proof.

 simple induction n.

 unfold power, shift_Fib, o, u in |- *; simpl in |- *.

 unfold fib_mat in |- *; simpl in |- *.

 unfold Mat_mult, Id2 in |- *; simpl in |- *; auto with arith.

 intros.

 rewrite (fib_mat_n (S n0) _ _ _ H).

 repeat rewrite <- Znat.inj_plus.

 rewrite (Simpl_shift_Fib (S n0)).

 pattern (shift_Fib (S (S n0))) at 4 in |- *.

 rewrite (Simpl_shift_Fib n0).

 auto with arith.

Qed.



Lemma fib_computation :

 forall n : nat,

 0 < n -> Z_of_nat (Fib n) = M11 (power Mat2 matrix fib_mat n).

Proof.

 simple induction n.

 intro; absurd (0 < 0); auto with arith.

 intros.

 rewrite fib_n; unfold M11 in |- *; auto with arith.

Qed.
