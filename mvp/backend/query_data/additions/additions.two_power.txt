
Require Import Arith.
Require Import Peano_dec.
Require Import Constants.
(* Constants:
Global Set Asymmetric Patterns.

Definition one := 1.
Definition two := 2.
Definition three := 3.
Definition four := 4. *)
Require Import Mult_compl.
(* Mult_compl:
Require Import Arith.
Require Import Constants.
Require Import Le_lt_compl.

Lemma mult_le_l : forall a b c : nat, b <= c -> a * b <= a * c.
Hint Resolve mult_le_l: arith.

Lemma mult_lt_l : forall a b c : nat, 0 < a -> b < c -> a * b < a * c.

Hint Resolve mult_lt_l: arith.

Lemma mult_le_r : forall a b c : nat, b <= c -> b * a <= c * a.
Hint Resolve mult_le_r: arith.

Lemma mult_lt_r : forall a b c : nat, 0 < a -> b < c -> b * a < c * a.
Hint Resolve mult_lt_r: arith.

Lemma mult_inj_l : forall a b c : nat, a * c < b * c -> a < b.

Lemma mult_p_lt_qp : forall p q : nat, 0 < p -> one < q -> p < q * p.  

Lemma mult_p_le_qp : forall p q : nat, 0 < q -> p <= q * p.

Hint Resolve mult_p_lt_qp mult_p_le_qp: arith.
 
Lemma mult_p_lt_pq : forall p q : nat, 0 < p -> one < q -> p < p * q.  

Lemma mult_p_le_pq : forall p q : nat, 0 < q -> p <= p * q.

Hint Resolve mult_p_lt_pq mult_p_le_pq: arith.

Lemma quotient_positive : forall q n n0 : nat, n = q * n0 -> 0 < n -> 0 < q.

Lemma quotient_gt_one : forall q n n0 : nat, n0 < n -> n = q * n0 -> one < q. *)
Require Import Le_lt_compl.
(* Le_lt_compl:
Require Import Arith.
Require Import Constants.

Lemma lt_or_Zero : forall q : nat, 0 < q \/ q = 0.

Lemma one_cases : forall q : nat, 1 < q \/ q = 0 \/ q = 1.

Lemma enum1 : forall n : nat, n < two -> n = 0 \/ n = 1.

Lemma le5 :
 forall P : nat -> Prop,
 P 0 ->
 P one ->
 P two ->
 P three ->
 P four -> (forall n : nat, four < n -> P n) -> forall n : nat, P n.

Lemma enum4 :
 forall n : nat,
 n < S four -> n = 0 \/ n = one \/ n = two \/ n = three \/ n = four.

Lemma not_le_lt : forall n m : nat, ~ n <= m -> m < n.
Hint Immediate not_le_lt: arith.

Lemma not_lt_le : forall n m : nat, ~ n < m -> m <= n.
Hint Immediate not_lt_le: arith.

Lemma lt_not_lt : forall n p : nat, n < p -> ~ p < S n.

Lemma lt_a_a_plus_b : forall a b : nat, 0 < b -> a < a + b.

Hint Resolve lt_a_a_plus_b: arith. *)

Fixpoint two_power (m : nat) : nat :=
  match m with
  | O => 1
  | S n => two * two_power n
  end.

Lemma zero_lt_pow : forall a : nat, 0 < two_power a.

Proof.
 simple induction a; simpl in |- *.
 auto with arith.
 intros.
 apply lt_plus_trans; auto with arith.
Qed.
Hint Resolve zero_lt_pow: arith.

Lemma two_power_S : forall n : nat, two_power (S n) = two_power n * two.

Proof.
 intros; unfold two_power at 1 in |- *; rewrite mult_comm; auto with arith.
Qed.

Lemma two_power_S_lt : forall n : nat, two_power n < two_power (S n).

Proof.
 intro; rewrite two_power_S.
 rewrite mult_comm; apply mult_p_lt_qp; auto with arith.
Qed.

Lemma two_power_mono : forall n p : nat, n < p -> two_power n < two_power p.

Proof.
 simple induction 1.
 intros; apply two_power_S_lt; auto with arith.
 intros.
 apply lt_trans with (two_power m); auto with arith.
 apply two_power_S_lt; auto with arith.
Qed.

Lemma two_power_le : forall n p : nat, n <= p -> two_power n <= two_power p.

Proof.
 intros n p H; case (le_lt_or_eq _ _ H); intro H1.
 apply lt_le_weak; apply two_power_mono; auto with arith.
 rewrite H1; auto with arith.
Qed.

Lemma two_power_monoR : forall n p : nat, two_power n < two_power p -> n < p.

Proof.
 intros.
 apply not_le_lt.
 unfold not in |- *; intro.
 elim (lt_not_le (two_power n) (two_power p) H).
 case (le_lt_or_eq p n H0); intro.
 apply lt_le_weak.
 apply two_power_mono; auto with arith.
 auto with arith.
 rewrite H1; auto with arith.
Qed.

Lemma holes_in_powers :
 forall n z : nat,
 two_power n < z -> z < two_power (S n) -> forall p : nat, z <> two_power p.

Proof.
 unfold not in |- *; intros.
 cut (n < p).
 intro.
 cut (p < S n).
 intro.
 case (lt_not_lt n p); auto with arith.
 apply two_power_monoR.
 elim H1; auto with arith.
 apply two_power_monoR.
 elim H1; auto with arith.
Qed.

Lemma log2_unicity :
 forall n p z : nat,
 two_power n < z ->
 z < two_power (S n) -> two_power p < z -> z < two_power (S p) -> n = p.
Proof.
 intros.
 case (le_or_lt n p); intros.		                     
 case (le_lt_or_eq n p H3); intros.
 absurd (z < z).
 auto with arith.
 apply lt_trans with (two_power (S n)).
 auto with arith.
 apply le_lt_trans with (two_power p).
 apply two_power_le; auto with arith.
 auto with arith.
 auto with arith.
 absurd (z < z).
 auto with arith.
 apply lt_trans with (two_power (S p)).
 auto with arith.
 apply le_lt_trans with (two_power n).
 apply two_power_le; auto with arith.
 auto with arith.
Qed.