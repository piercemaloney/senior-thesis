

Require Import strategies.
(* strategies:
Require Import Constants.

Inductive strategy : Set :=
    mkstrat :
      (forall n : nat, four < n -> {p : nat | p < n /\ two <= p}) -> strategy. *)

Require Import Arith.

Require Import euclid.
(* euclid:
Require Import Arith.
Require Import Constants.
Require Import Le_lt_compl.
Require Import Mult_compl.

Lemma lt_b_qbr : forall b q r : nat, 0 < r -> 0 < q -> r < b -> b < q * b + r.

Hint Resolve lt_b_qbr: arith.

Lemma lt_q_qbr : forall b q r : nat, 0 < r -> one < b -> q < q * b + r.
Hint Resolve lt_q_qbr: arith.

Lemma lt_q_qbr' : forall b q r : nat, 0 < q -> one < b -> q < q * b + r.

Hint Resolve lt_q_qbr': arith.

Lemma le_q_qbr : forall b q r : nat, 0 < b -> q <= q * b + r.
  
Hint Resolve le_q_qbr: arith.

Lemma lt_O_q : forall b q r : nat, b < q * b + r -> 0 < r -> r < b -> 0 < q. *)

Require Import shift.
(* shift:
Require Import Arith.
Require Import Peano_dec.
Require Import Constants.
Require Import Mult_compl.
Require Import Wf_nat. 
Require Import euclid.
Require Import Le_lt_compl.
Require Import Euclid.
Require Import Compare_dec.

Lemma plus_n_1 : forall n : nat, S n = n + 1.

Definition shift (n : nat) := two * n.

Lemma Unshift :
 forall n : nat, {m : nat &  {n = shift m} + {n = S (shift m)}}.

Lemma half_lt :
 forall a b : nat, 0 < b -> b = shift a \/ b = S (shift a) -> a < b.
Hint Resolve half_lt: arith. *)

Require Import Euclid.

Require Import Le_lt_compl.
(* Le_lt_compl:
Require Import Arith.
Require Import Constants.

Lemma lt_or_Zero : forall q : nat, 0 < q \/ q = 0.

Lemma one_cases : forall q : nat, 1 < q \/ q = 0 \/ q = 1.

Lemma enum1 : forall n : nat, n < two -> n = 0 \/ n = 1.

Lemma le5 :
 forall P : nat -> Prop,
 P 0 ->
 P one ->
 P two ->
 P three ->
 P four -> (forall n : nat, four < n -> P n) -> forall n : nat, P n.

Lemma enum4 :
 forall n : nat,
 n < S four -> n = 0 \/ n = one \/ n = two \/ n = three \/ n = four.

Lemma not_le_lt : forall n m : nat, ~ n <= m -> m < n.
Hint Immediate not_le_lt: arith.

Lemma not_lt_le : forall n m : nat, ~ n < m -> m <= n.
Hint Immediate not_lt_le: arith.

Lemma lt_not_lt : forall n p : nat, n < p -> ~ p < S n.

Lemma lt_a_a_plus_b : forall a b : nat, 0 < b -> a < a + b.

Hint Resolve lt_a_a_plus_b: arith. *)

Require Import Mult_compl.
(* Mult_compl:
Require Import Arith.
Require Import Constants.
Require Import Le_lt_compl.

Lemma mult_le_l : forall a b c : nat, b <= c -> a * b <= a * c.
Hint Resolve mult_le_l: arith.

Lemma mult_lt_l : forall a b c : nat, 0 < a -> b < c -> a * b < a * c.

Hint Resolve mult_lt_l: arith.

Lemma mult_le_r : forall a b c : nat, b <= c -> b * a <= c * a.
Hint Resolve mult_le_r: arith.

Lemma mult_lt_r : forall a b c : nat, 0 < a -> b < c -> b * a < c * a.
Hint Resolve mult_lt_r: arith.

Lemma mult_inj_l : forall a b c : nat, a * c < b * c -> a < b.

Lemma mult_p_lt_qp : forall p q : nat, 0 < p -> one < q -> p < q * p.  

Lemma mult_p_le_qp : forall p q : nat, 0 < q -> p <= q * p.

Hint Resolve mult_p_lt_qp mult_p_le_qp: arith.
 
Lemma mult_p_lt_pq : forall p q : nat, 0 < p -> one < q -> p < p * q.  

Lemma mult_p_le_pq : forall p q : nat, 0 < q -> p <= p * q.

Hint Resolve mult_p_lt_pq mult_p_le_pq: arith.

Lemma quotient_positive : forall q n n0 : nat, n = q * n0 -> 0 < n -> 0 < q.

Lemma quotient_gt_one : forall q n n0 : nat, n0 < n -> n = q * n0 -> one < q. *)

Require Import Constants.
(* Constants:
Global Set Asymmetric Patterns.

Definition one := 1.
Definition two := 2.
Definition three := 3.
Definition four := 4. *)



Lemma binary : strategy.  



Proof. 

 refine

  (mkstrat

     (fun n h => match quotient two _ n with

                 | exist n0 e => exist _ n0 _

                 end)).



 auto with arith.

 elim e; simple induction 1; intros H1 H2.

  
 case (enum1 x H2); intro H3.



 cut (n = n0 * two); [ intro eg | idtac ].

 cut (two <= n0); [ intro H'1 | idtac ].

 split; auto.

 rewrite eg; apply mult_p_lt_pq.

 apply lt_le_trans with 2; auto with arith.

 auto with arith.

   

 apply not_lt_le; unfold not in |- *; intro.

 absurd (n < four); [ apply lt_asym; auto with arith | idtac ].

 rewrite eg; replace four with (two * two).

 apply mult_lt_r.

 auto with arith.

 auto with arith.

 simpl in |- *; auto with arith.

 rewrite (plus_n_O (n0 * two)); elim H3; auto with arith.



 cut (two <= n0); [ intro H'1 | idtac ].

 split; [ idtac | auto with arith ].

 rewrite H1; rewrite mult_comm; apply lt_b_qbr.

 rewrite H3; auto with arith.

 auto with arith.

 apply lt_le_trans with two; [ idtac | auto with arith ].

 rewrite H3; auto with arith.

 apply not_lt_le; unfold not in |- *; intro.

 cut (n <= three).

 intro; absurd (four < three);

  [ unfold four, three in |- *; auto with arith | idtac ].

 apply lt_le_trans with n; auto with arith.

 replace three with (one * two + x).

 rewrite H1; auto with arith.

 rewrite H3; simpl in |- *; auto with arith.

Qed.



