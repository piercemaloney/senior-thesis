
Require Import Constants.
(* Constants:
Global Set Asymmetric Patterns.

Definition one := 1.
Definition two := 2.
Definition three := 3.
Definition four := 4. *)
Require Import generation.
(* generation:
Require Import monoid.
Require Import spec.
Require Import Constants.
Require Import machine.
Require Import Euclid.
Require Import Le_lt_compl.
Require Import euclid.
Require Import shift.
Require Import two_power.
Require Import log2_spec.
Require Import develop.
Require Import Arith.
Require Import Peano_dec.
Require Import Compare_dec.
Require Import strategies.
Require Import Mult_compl.
Require Import Wf_nat.
Require Import Wf_compl.

Inductive Call_lt : Call -> Call -> Prop :=
  | M_M_lt : forall p q : nat, p < q -> Call_lt (Call_M p) (Call_M q)
  | C_M_lt : forall p q : nat, p < q -> Call_lt (Call_C q p) (Call_M q)
  | M_C_lt : forall p q r : nat, p < r -> Call_lt (Call_M p) (Call_C r q)
  | M_K_lt : forall p q r : nat, p <= r -> Call_lt (Call_M p) (Call_K r q)
  | K_C_lt : forall p q r s : nat, q < s -> Call_lt (Call_K q p) (Call_C s r)
  | K_K_lt : forall p q r s : nat, q < s -> Call_lt (Call_K q p) (Call_K s r).

Definition Call_measure (c : Call) :=
  match c return nat with
  | Call_M n =>
      
      S (three * n)
      
  | Call_C n p => three * n
      
  | Call_K n p => S (S (three * n))
  end.

Lemma measure_compat : coarser Call Call_lt (ltof Call Call_measure).

Lemma Wf_Call_lt : well_founded Call_lt.

Section generation.
  Variable gamma : strategy.
  Variable log2_r : forall n : nat, 0 < n -> log2_spec n.

  Lemma chain_cases :
   forall p : nat,
   0 < p ->
   {q : nat | q < p /\ two <= q} + {l : nat | p = two_power l} + {p = three}.

 Lemma COND3 :
  forall (A : nat -> Set) (p : nat),
  (p = three -> A p) ->
  (forall q : nat, p = two_power q -> A p) ->
  (forall q : nat, q < p -> two <= q -> A p) -> 0 < p -> A p.

 Lemma chain_algo : forall c : Call, conform c -> gencode c.

 Lemma power_algo : forall n : nat, 0 < n -> addchain_spec n.
 
End generation. *)
Require Import monoid.
(* monoid:
Require Import Arith.
Require Import Constants.

Section monoid_def.

Variable M : Set.

Record monoid : Set := mkmonoid
  {u : M;
   o : M -> M -> M;
   point_assoc : forall a b c : M, o a (o b c) = o (o a b) c;
   u_neutral_l : forall a : M, o u a = a;
   u_neutral_r : forall a : M, o a u = a}.

Hint Resolve point_assoc u_neutral_r u_neutral_l: arith.

Variable MO : monoid.
Let u' := u MO.
Let o' := o MO.
Remark o'_assoc : forall a b c : M, o' a (o' b c) = o' (o' a b) c.
Hint Resolve o'_assoc: arith.

Remark u'_neutral_l : forall a : M, o' u' a = a.
Hint Resolve u'_neutral_l: arith.

Remark u'_neutral_r : forall a : M, o' a u' = a.
Hint Resolve u'_neutral_r: arith.

Fixpoint power (x : M) (n : nat) {struct n} : M :=
  match n with
  | O => u'
  | S n => o' x (power x n)
  end.
                                     
Lemma power_u : forall m : nat, power u' m = u'.
Hint Resolve power_u: arith.

Lemma power_plus :
 forall (a : M) (n p : nat), power a (n + p) = o' (power a n) (power a p).
Hint Resolve power_plus: arith.

Lemma power_1 : forall a : M, power a 1 = a.

Lemma power_sym :
 forall (a : M) (n p : nat),
 o' (power a n) (power a p) = o' (power a p) (power a n).
Hint Resolve power_sym: arith.

Lemma power_mult :
 forall (a : M) (n p : nat), power a (p * n) = power (power a n) p.
Hint Resolve power_mult: arith.

Lemma a2x : forall (a : M) (x : nat), power (o' a a) x = power a (x + x).

Lemma power_eucl :
 forall (m : M) (b q r : nat),
 power m (q * b + r) = o' (power (power m b) q) (power m r).
Hint Resolve power_eucl: arith.

End monoid_def. *)
Require Import machine.
(* machine:
Require Import monoid.
Require Import Constants.

Inductive Instr : Set :=
  | MUL : Instr
  | SQR : Instr
  | PUSH : Instr
  | SWAP : Instr.       

Inductive Code : Set :=
  | End : Code
  | seq : Instr -> Code -> Code.

Fixpoint app (c : Code) : Code -> Code :=
  fun c' : Code => match c with
                   | End => c'
                   | seq i c => seq i (app c c')
                   end.

Section Monoid.
 Variable M : Set.
 Variable MO : monoid M.
 Let uM := u _ MO.
 Let oM := o _ MO.

 Inductive Stack : Set :=
   | emptystack : Stack
   | push : M -> Stack -> Stack.

 Definition top (s : Stack) :=
   match s return M with
   | emptystack => uM
   | push m _ => m
   end.
 Definition pop (s : Stack) :=
   match s return Stack with
   | emptystack => emptystack
   | push _ r => r
   end.

 Record Config : Set := config {config_X : M; config_S : Stack}.

 Lemma Config_inv :
  forall (a a' : M) (s s' : Stack),
  a = a' -> s = s' -> config a s = config a' s'.
 
 Hint Resolve Config_inv: arith.

 Definition Exec1 (c : Instr) (v : Config) : Config :=
   let (m, s) := v in
   match c with
   | MUL => config (oM m (top s)) (pop s) 
   | SQR => config (oM m m) s
   | PUSH => config m (push m s)
   | SWAP => config m (push (top (pop s)) (push (top s) (pop (pop s))))
   end.
 
Fixpoint Exec (c : Code) : Config -> Config :=
  fun v : Config =>
  match c with
  | End => v
  | seq i c => Exec c (Exec1 i v)
  end.

 Lemma Exec_app :
  forall (c c' : Code) (v : Config), Exec (app c c') v = Exec c' (Exec c v).

End Monoid. *)
Require Import strategies.
(* strategies:
Require Import Constants.

Inductive strategy : Set :=
    mkstrat :
      (forall n : nat, four < n -> {p : nat | p < n /\ two <= p}) -> strategy. *)
Require Import spec.
(* spec:
Require Import monoid.
Require Import machine.
Require Import Constants.

Inductive Call : Set :=
  | Call_M : nat -> Call
  | Call_C : nat -> nat -> Call
  | Call_K : nat -> nat -> Call.
 
Definition conform (c : Call) : Prop :=
  match c return Prop with
  | Call_M n =>
        0 < n
       
  | Call_C n p => 1 < p /\ p < n
       
  | Call_K n p => 0 < p /\ p < n
  end.

Inductive Spec : Call -> Code -> Prop :=
  | m_spec :
      forall (n : nat) (c : Code),
      (forall (M : Set) (MO : monoid M) (a : M) (s : Stack M),
       Exec M MO c (config M a s) = config M (power M MO a n) s) ->
      Spec (Call_M n) c
  | c_spec :
      forall (p q : nat) (c : Code),
      (forall (M : Set) (MO : monoid M) (a : M) (s : Stack M),
       Exec M MO c (config M a s) = config M (power M MO a p) s) ->
      Spec (Call_C p q) c
  | k_spec :
      forall (p q : nat) (c : Code),
      (forall (M : Set) (MO : monoid M) (a : M) (s : Stack M),
       Exec M MO c (config M a s) =
       config M (power M MO a p) (push M (power M MO a q) s)) ->
      Spec (Call_K p q) c.

Inductive gencode (c : Call) : Set :=
    gencode_intro : forall co : Code, Spec c co -> gencode c.

Inductive addchain_spec (n : nat) : Set :=
    addchain_spec_intro : gencode (Call_M n) -> addchain_spec n. *)
Require Import log2_spec.
(* log2_spec:
Require Import Arith.
Require Import Peano_dec.
Require Import Constants.
Require Import Mult_compl.
Require Import Wf_nat. 
Require Import euclid.
Require Import Le_lt_compl.
Require Import shift.
Require Import Compare_dec.
Require Import two_power.

Definition log2_spec (n0 : nat) :=
  {l : nat & 
  {n0 = two_power l} + {two_power l < n0 /\ n0 < two_power (S l)}}.

Section applications.
 Variable log2 : forall n : nat, 0 < n -> log2_spec n.
 
 Lemma ceiling_log2 :
  forall n : nat,
  one < n -> {l : nat | two_power (pred l) < n /\ n <= two_power l}.
 
 Lemma floor_log2 :
  forall n : nat,
  0 < n -> {l : nat | two_power l <= n /\ n < two_power (S l)}.
End applications. *)
Require Import log2_implementation.
(* log2_implementation:
Require Import Arith.
Require Import Peano_dec.
Require Import Constants.
Require Import Mult_compl.
Require Import Wf_nat. 
Require Import euclid.
Require Import Le_lt_compl.
Require Import Euclid.
Require Import shift.
Require Import Compare_dec.
Require Import imperative.
Require Import while.
Require Import two_power.
Require Import log2_spec.

Section log2_computation.
 Variable n0 : nat.
 Hypothesis pos_n0 : 0 < n0.
 Hint Resolve pos_n0: arith.

  Record state : Set := mkstate
    {state_n : nat; state_p : nat; state_b : bool}.
 
  Inductive ok : state -> Prop :=
    | oktrue : forall p : nat, n0 = two_power p -> ok (mkstate one p true)
    | okfalse :
        forall p : nat,
        two_power p < n0 -> n0 < two_power (S p) -> ok (mkstate one p false).

  Let init (s : state) := state_n s = n0 /\ state_p s = 0 /\ state_b s = true.

  Inductive final : state -> Prop :=
      mkfinal : forall (p : nat) (b : bool), final (mkstate one p b).
 
  Inductive invar : state -> Prop :=
    | exact :
        forall n p : nat,
        n0 = two_power p * n -> 0 < n -> invar (mkstate n p true)
    | inexact :
        forall n p : nat,
        two_power p * n < n0 ->
        n0 < two_power p * S n -> 0 < n -> invar (mkstate n p false).
 
  Definition stat_order := ltof state state_n.
 
  Lemma decomp :
              forall s : state,
              s = mkstate (state_n s) (state_p s) (state_b s).

  Lemma invar_inv1 :
               forall n p : nat,
               invar (mkstate n p true) -> n0 = two_power p * n.

  Lemma invar_inv2 :
               forall n p : nat,
               invar (mkstate n p false) ->
               two_power p * n < n0 /\ n0 < two_power p * S n.

  Lemma invar_inv3 :
               forall (n p : nat) (b : bool), invar (mkstate n p b) -> 0 < n.

  Lemma final_inv :
               forall (n p : nat) (b : bool),
               final (mkstate n p b) -> n = one.

  Lemma not_final :
               forall (n p : nat) (b : bool),
               invar (mkstate n p b) -> ~ final (mkstate n p b) -> one < n.

  Lemma wf_stat_order : well_founded stat_order.
 Hint Resolve wf_stat_order: arith.

 Lemma log2_impl : log2_spec n0.

End log2_computation. *)
Require Import Compare_dec.

Require Import while.
(* while:
Global Set Asymmetric Patterns.

Section while_do.
 Variable St : Set. 
 Variable postcond : St -> Prop.
 Variable precond : St -> Prop.
 Variable Invar : St -> Prop.
 Variable term_order : St -> St -> Prop.
 Variable LoopExit : St -> Prop.
 Hypothesis
   LoopExit_dec : forall s : St, Invar s -> {LoopExit s} + {~ LoopExit s}.
 Hypothesis
   Onestep :
     forall s : St,
     ~ LoopExit s -> Invar s -> {s' : St | Invar s' /\ term_order s' s}.
 Hypothesis LoopExit_ok : forall s : St, LoopExit s -> Invar s -> postcond s.
 Hypothesis loopstart : forall s : St, precond s -> Invar s.

 Hypothesis Termi : well_founded term_order.

  Remark loopexec :
   forall s : St, Invar s -> {s' : St | Invar s' /\ LoopExit s'}.

  Lemma startloop :
   forall s : St, precond s -> {s' : St | Invar s' /\ LoopExit s'}.

 Lemma while_not : forall s : St, precond s -> {s' : St | postcond s'}.
End while_do. *)
Require Import imperative.
(* imperative:
Set Asymmetric Patterns.

Goal
forall (A : Set) (Pre Post : A -> Prop) (B : Set),
{a : A | Pre a} ->
(forall a : A, Pre a -> {a' : A | Post a'}) ->
(forall a : A, Post a -> B) -> B.
exact
 (fun A Pre Post B start body return_ =>
  match start with
  | exist a pre =>
      match body a pre with
      | exist a' post => return_ a' post
      end
  end).
Save Imperative. *)
Require Import develop.
(* develop:
Require Import Constants.
Require Import monoid.
Require Import spec.
Require Import machine.
Require Import Wf_compl.
Require Import Plus.
Require Import Mult.
Require Import Lt.
Require Import Mult_compl.
Require Import euclid.
Require Import two_power.

Lemma M3 : gencode (Call_M three).

Lemma M2q : forall q : nat, gencode (Call_M (two_power q)).

Lemma C2M : forall p q : nat, gencode (Call_C p q) -> gencode (Call_M p).

Lemma MMC :
 forall p q : nat,
 gencode (Call_M p) -> gencode (Call_M q) -> gencode (Call_C (q * p) p).

Lemma KMC :
 forall p q r : nat,
 gencode (Call_K p r) -> gencode (Call_M q) -> gencode (Call_C (q * p + r) p).

Lemma MMK :
 forall p q : nat,
 gencode (Call_M p) -> gencode (Call_M q) -> gencode (Call_K (q * p) p).

Lemma KMK :
 forall p q r : nat,
 gencode (Call_K p r) -> gencode (Call_M q) -> gencode (Call_K (q * p + r) p). *)
Require Import dicho_strat.
(* dicho_strat:
Require Import strategies.
Require Import Arith.
Require Import euclid.
Require Import shift.
Require Import two_power.
Require Import log2_spec.
Require Import Euclid.
Require Import Le_lt_compl.
Require Import Mult_compl.
Require Import Constants.

Section import_log2.
Variable log2_r : forall n : nat, 0 < n -> log2_spec n. 

Lemma dicho : strategy.

End import_log2. *)
Require Import binary_strat.
(* binary_strat:
Require Import strategies.
Require Import Arith.
Require Import euclid.
Require Import shift.
Require Import Euclid.
Require Import Le_lt_compl.
Require Import Mult_compl.
Require Import Constants.

Lemma binary : strategy. *)
Require Import trivial.
(* trivial:
Require Import monoid.
Require Import Plus.

Lemma trivial : monoid nat.

Lemma obsolete_debug : forall n : nat, power nat trivial n 1 = n. *)
Require Import standard.
(* standard:
Require Import monoid.
Require Import Mult.

Lemma standard : monoid nat. *)
Require Import monofun.
(* monofun:
Require Import monoid.

Section fun_.
 Variable A : Set.
 Hypothesis eta_A : forall f g : A -> A, (forall x : A, f x = g x) -> f = g.

 Let comp (f g : A -> A) (x : A) := g (f x).
 Let Id (a : A) := a.

 Lemma funmono : monoid (A -> A).
End fun_. *)
Require Import matrix.
(* matrix:
Require Import monoid.
Require Import Arith.
Require Import ZArith.
Require Import Compare_dec.
Require Import fmpc.

Record Mat2 : Set := mat2 {M11 : Z; M12 : Z; M21 : Z; M22 : Z}.

Definition Id2 := mat2 1 0 0 1.   

Definition Mat_mult (M M' : Mat2) :=
  mat2 (M11 M * M11 M' + M12 M * M21 M') (M11 M * M12 M' + M12 M * M22 M')
    (M21 M * M11 M' + M22 M * M21 M') (M21 M * M12 M' + M22 M * M22 M').

Axiom
  Mat_assoc :
    forall M M' M'' : Mat2,
    Mat_mult M (Mat_mult M' M'') = Mat_mult (Mat_mult M M') M''.

Lemma matrix : monoid Mat2.

Fixpoint Fib (n : nat) : nat :=
  match n return nat with
  | O =>   1
       
  | S p =>
      match p return nat with
      | O =>   1
          
      | S q => Fib q + Fib p
      end
  end.

Lemma Unfold_FibO : Fib 0 = 1.

Lemma Unfold_Fib1 : Fib 1 = 1.

Lemma Unfold_FibSSn : forall n : nat, Fib (S (S n)) = Fib (S n) + Fib n.

Definition shift_Fib (n : nat) :=
  match n return nat with
  | O => 0
  | S p => Fib p
  end.

Lemma Unfold_shift_Fib : forall n : nat, shift_Fib (S n) = Fib n.

Lemma Simpl_shift_Fib :
 forall n : nat, shift_Fib (S (S n)) = shift_Fib (S n) + shift_Fib n.

Definition fib_mat := mat2 1 1 1 0.

Lemma fib_mat_n :
 forall (n : nat) (a b d : Z),
 power Mat2 matrix fib_mat n = mat2 a b b d ->
 power Mat2 matrix fib_mat (S n) = mat2 (a + b) (b + d) a b.

Lemma fib_n :
 forall n : nat,
 power Mat2 matrix fib_mat (S n) =
 mat2 (Z_of_nat (shift_Fib (S (S n)))) (Z_of_nat (shift_Fib (S n)))
   (Z_of_nat (shift_Fib (S n))) (Z_of_nat (shift_Fib n)).

Lemma fib_computation :
 forall n : nat,
 0 < n -> Z_of_nat (Fib n) = M11 (power Mat2 matrix fib_mat n). *)
Require Import ZArith.

Definition code_gen (s : strategy) := chain_algo s log2_impl.
Definition power_algo_r (s : strategy) := power_algo s log2_impl.

Theorem addchains :
 forall (gamma : strategy) (n : nat) (M : Set) (MO : monoid M) (a : M),
 {b : M | b = power M MO a n}.

Proof.
 intros gamma n M MO a; elim (zerop n); intro H;
  [ exists (u M MO)
  | exists
     (config_X M
        (Exec M MO
           match power_algo gamma log2_impl n H with
           | addchain_spec_intro gc =>
               match gc with
               | gencode_intro co _ => co
               end
           end (config M a (emptystack M)))) ].

 rewrite H; auto with arith.
 elim (power_algo gamma log2_impl n H); intro g; elim g; intros co s. 
 inversion_clear s.
 rewrite H0; simpl in |- *; auto with arith.
Qed.

Definition dic := dicho log2_impl.

Opaque matrix.

Lemma fibonacci : forall n : nat, {q : Z | q = Z_of_nat (Fib n)}.

refine
 (fun n =>
  match zerop n with
  | left e => exist _ 1%Z _
  | right l =>
      match addchains dic n Mat2 matrix fib_mat with
      | exist m e => exist _ (M11 m) _
      end
  end).

rewrite e; rewrite Unfold_FibO; auto with arith.
rewrite fib_computation.
 rewrite e; auto with arith.
auto with arith.
Qed.

Transparent matrix.