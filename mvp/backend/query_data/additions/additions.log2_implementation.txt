

Require Import Arith.

Require Import Peano_dec.

Require Import Constants.
(* Constants:
Global Set Asymmetric Patterns.

Definition one := 1.
Definition two := 2.
Definition three := 3.
Definition four := 4. *)

Require Import Mult_compl.
(* Mult_compl:
Require Import Arith.
Require Import Constants.
Require Import Le_lt_compl.

Lemma mult_le_l : forall a b c : nat, b <= c -> a * b <= a * c.
Hint Resolve mult_le_l: arith.

Lemma mult_lt_l : forall a b c : nat, 0 < a -> b < c -> a * b < a * c.

Hint Resolve mult_lt_l: arith.

Lemma mult_le_r : forall a b c : nat, b <= c -> b * a <= c * a.
Hint Resolve mult_le_r: arith.

Lemma mult_lt_r : forall a b c : nat, 0 < a -> b < c -> b * a < c * a.
Hint Resolve mult_lt_r: arith.

Lemma mult_inj_l : forall a b c : nat, a * c < b * c -> a < b.

Lemma mult_p_lt_qp : forall p q : nat, 0 < p -> one < q -> p < q * p.  

Lemma mult_p_le_qp : forall p q : nat, 0 < q -> p <= q * p.

Hint Resolve mult_p_lt_qp mult_p_le_qp: arith.
 
Lemma mult_p_lt_pq : forall p q : nat, 0 < p -> one < q -> p < p * q.  

Lemma mult_p_le_pq : forall p q : nat, 0 < q -> p <= p * q.

Hint Resolve mult_p_lt_pq mult_p_le_pq: arith.

Lemma quotient_positive : forall q n n0 : nat, n = q * n0 -> 0 < n -> 0 < q.

Lemma quotient_gt_one : forall q n n0 : nat, n0 < n -> n = q * n0 -> one < q. *)

Require Import Wf_nat. 

Require Import euclid.
(* euclid:
Require Import Arith.
Require Import Constants.
Require Import Le_lt_compl.
Require Import Mult_compl.

Lemma lt_b_qbr : forall b q r : nat, 0 < r -> 0 < q -> r < b -> b < q * b + r.

Hint Resolve lt_b_qbr: arith.

Lemma lt_q_qbr : forall b q r : nat, 0 < r -> one < b -> q < q * b + r.
Hint Resolve lt_q_qbr: arith.

Lemma lt_q_qbr' : forall b q r : nat, 0 < q -> one < b -> q < q * b + r.

Hint Resolve lt_q_qbr': arith.

Lemma le_q_qbr : forall b q r : nat, 0 < b -> q <= q * b + r.
  
Hint Resolve le_q_qbr: arith.

Lemma lt_O_q : forall b q r : nat, b < q * b + r -> 0 < r -> r < b -> 0 < q. *)

Require Import Le_lt_compl.
(* Le_lt_compl:
Require Import Arith.
Require Import Constants.

Lemma lt_or_Zero : forall q : nat, 0 < q \/ q = 0.

Lemma one_cases : forall q : nat, 1 < q \/ q = 0 \/ q = 1.

Lemma enum1 : forall n : nat, n < two -> n = 0 \/ n = 1.

Lemma le5 :
 forall P : nat -> Prop,
 P 0 ->
 P one ->
 P two ->
 P three ->
 P four -> (forall n : nat, four < n -> P n) -> forall n : nat, P n.

Lemma enum4 :
 forall n : nat,
 n < S four -> n = 0 \/ n = one \/ n = two \/ n = three \/ n = four.

Lemma not_le_lt : forall n m : nat, ~ n <= m -> m < n.
Hint Immediate not_le_lt: arith.

Lemma not_lt_le : forall n m : nat, ~ n < m -> m <= n.
Hint Immediate not_lt_le: arith.

Lemma lt_not_lt : forall n p : nat, n < p -> ~ p < S n.

Lemma lt_a_a_plus_b : forall a b : nat, 0 < b -> a < a + b.

Hint Resolve lt_a_a_plus_b: arith. *)

Require Import Euclid.

Require Import shift.
(* shift:
Require Import Arith.
Require Import Peano_dec.
Require Import Constants.
Require Import Mult_compl.
Require Import Wf_nat. 
Require Import euclid.
Require Import Le_lt_compl.
Require Import Euclid.
Require Import Compare_dec.

Lemma plus_n_1 : forall n : nat, S n = n + 1.

Definition shift (n : nat) := two * n.

Lemma Unshift :
 forall n : nat, {m : nat &  {n = shift m} + {n = S (shift m)}}.

Lemma half_lt :
 forall a b : nat, 0 < b -> b = shift a \/ b = S (shift a) -> a < b.
Hint Resolve half_lt: arith. *)

Require Import Compare_dec.

Require Import imperative.
(* imperative:
Set Asymmetric Patterns.

Goal
forall (A : Set) (Pre Post : A -> Prop) (B : Set),
{a : A | Pre a} ->
(forall a : A, Pre a -> {a' : A | Post a'}) ->
(forall a : A, Post a -> B) -> B.
exact
 (fun A Pre Post B start body return_ =>
  match start with
  | exist a pre =>
      match body a pre with
      | exist a' post => return_ a' post
      end
  end).
Save Imperative. *)

Require Import while.
(* while:
Global Set Asymmetric Patterns.

Section while_do.
 Variable St : Set. 
 Variable postcond : St -> Prop.
 Variable precond : St -> Prop.
 Variable Invar : St -> Prop.
 Variable term_order : St -> St -> Prop.
 Variable LoopExit : St -> Prop.
 Hypothesis
   LoopExit_dec : forall s : St, Invar s -> {LoopExit s} + {~ LoopExit s}.
 Hypothesis
   Onestep :
     forall s : St,
     ~ LoopExit s -> Invar s -> {s' : St | Invar s' /\ term_order s' s}.
 Hypothesis LoopExit_ok : forall s : St, LoopExit s -> Invar s -> postcond s.
 Hypothesis loopstart : forall s : St, precond s -> Invar s.

 Hypothesis Termi : well_founded term_order.

  Remark loopexec :
   forall s : St, Invar s -> {s' : St | Invar s' /\ LoopExit s'}.

  Lemma startloop :
   forall s : St, precond s -> {s' : St | Invar s' /\ LoopExit s'}.

 Lemma while_not : forall s : St, precond s -> {s' : St | postcond s'}.
End while_do. *)

Require Import two_power.
(* two_power:
Require Import Arith.
Require Import Peano_dec.
Require Import Constants.
Require Import Mult_compl.
Require Import Le_lt_compl.

Fixpoint two_power (m : nat) : nat :=
  match m with
  | O => 1
  | S n => two * two_power n
  end.

Lemma zero_lt_pow : forall a : nat, 0 < two_power a.
Hint Resolve zero_lt_pow: arith.

Lemma two_power_S : forall n : nat, two_power (S n) = two_power n * two.

Lemma two_power_S_lt : forall n : nat, two_power n < two_power (S n).

Lemma two_power_mono : forall n p : nat, n < p -> two_power n < two_power p.

Lemma two_power_le : forall n p : nat, n <= p -> two_power n <= two_power p.

Lemma two_power_monoR : forall n p : nat, two_power n < two_power p -> n < p.

Lemma holes_in_powers :
 forall n z : nat,
 two_power n < z -> z < two_power (S n) -> forall p : nat, z <> two_power p.

Lemma log2_unicity :
 forall n p z : nat,
 two_power n < z ->
 z < two_power (S n) -> two_power p < z -> z < two_power (S p) -> n = p. *)

Require Import log2_spec.
(* log2_spec:
Require Import Arith.
Require Import Peano_dec.
Require Import Constants.
Require Import Mult_compl.
Require Import Wf_nat. 
Require Import euclid.
Require Import Le_lt_compl.
Require Import shift.
Require Import Compare_dec.
Require Import two_power.

Definition log2_spec (n0 : nat) :=
  {l : nat & 
  {n0 = two_power l} + {two_power l < n0 /\ n0 < two_power (S l)}}.

Section applications.
 Variable log2 : forall n : nat, 0 < n -> log2_spec n.
 
 Lemma ceiling_log2 :
  forall n : nat,
  one < n -> {l : nat | two_power (pred l) < n /\ n <= two_power l}.
 
 Lemma floor_log2 :
  forall n : nat,
  0 < n -> {l : nat | two_power l <= n /\ n < two_power (S l)}.
End applications. *)



Section log2_computation.

 Variable n0 : nat.

 Hypothesis pos_n0 : 0 < n0.

 Hint Resolve pos_n0: arith.



  Record state : Set := mkstate

    {state_n : nat; state_p : nat; state_b : bool}.

 

  Inductive ok : state -> Prop :=

    | oktrue : forall p : nat, n0 = two_power p -> ok (mkstate one p true)

    | okfalse :

        forall p : nat,

        two_power p < n0 -> n0 < two_power (S p) -> ok (mkstate one p false).



  Let init (s : state) := state_n s = n0 /\ state_p s = 0 /\ state_b s = true.



  Inductive final : state -> Prop :=

      mkfinal : forall (p : nat) (b : bool), final (mkstate one p b).

 

  Inductive invar : state -> Prop :=

    | exact :

        forall n p : nat,

        n0 = two_power p * n -> 0 < n -> invar (mkstate n p true)

    | inexact :

        forall n p : nat,

        two_power p * n < n0 ->

        n0 < two_power p * S n -> 0 < n -> invar (mkstate n p false).

 

  Definition stat_order := ltof state state_n.

 

  Lemma decomp :

              forall s : state,

              s = mkstate (state_n s) (state_p s) (state_b s).

 Proof.

   simple induction s; simpl in |- *; auto with arith.

 Qed.



  Lemma invar_inv1 :

               forall n p : nat,

               invar (mkstate n p true) -> n0 = two_power p * n.

 Proof.

  intros; inversion_clear H; auto with arith.

 Qed.



  Lemma invar_inv2 :

               forall n p : nat,

               invar (mkstate n p false) ->

               two_power p * n < n0 /\ n0 < two_power p * S n.

 Proof.

  intros.

  inversion_clear H; split; auto with arith.

 Qed.



  Lemma invar_inv3 :

               forall (n p : nat) (b : bool), invar (mkstate n p b) -> 0 < n.

 Proof.

  intros.

  inversion_clear H; auto with arith.

 Qed.



  Lemma final_inv :

               forall (n p : nat) (b : bool),

               final (mkstate n p b) -> n = one.

 Proof.

  intros.

  inversion_clear H; auto with arith.

 Qed.



  Lemma not_final :

               forall (n p : nat) (b : bool),

               invar (mkstate n p b) -> ~ final (mkstate n p b) -> one < n.

 Proof.

  intros.

  case (le_or_lt n one); [ intro | auto with arith ].

  cut (0 < n); [ intro | apply invar_inv3 with p b; auto with arith ].

  case (enum1 n).

  unfold two in |- *; auto with arith.

  intro; absurd (0 < n); auto with arith.

  rewrite H3; auto with arith.

  intro; absurd (final (mkstate n p b)); [ auto with arith | idtac ].

  rewrite H3; split; auto with arith.

 Qed.



  Lemma wf_stat_order : well_founded stat_order.

 Proof.

  unfold stat_order in |- *; apply well_founded_ltof.

 Qed.

 Hint Resolve wf_stat_order: arith.



 Lemma log2_impl : log2_spec n0.

 

 Proof.

  apply Imperative with state init ok;

   [ 

   

   exists (mkstate n0 0 true)

   | 

      

      intros a pre; apply while_not with init invar stat_order final a;

      [  

          

         simple induction s; intros state_n0 state_p0 state_b0 i;

         elim (le_lt_eq_dec 1 state_n0); [ right | left | idtac ]

      | 

         

         simple induction s; intros state_n0 state_p0 state_b0; 

         elim state_b0; intros h i; elim (Unshift state_n0); 

         intros m b';

         [ elim b';

            [ exists (mkstate m (S state_p0) true)

            | exists (mkstate m (S state_p0) false) ]

         | exists (mkstate m (S state_p0) false) ]

      | idtac

      | idtac

      | idtac

      | idtac ]

   | 

      

      simple induction a; intros state_n0 state_p0 state_b0; 

      elim state_b0; intro h; exists state_p0 ].



Hint Unfold init: arith.



split; auto; split; auto.



red in |- *; intros f; inversion f; auto.

rewrite <- H0 in a0; simpl in a0.

absurd (1 < 1); auto with arith.

rewrite <- b; constructor 1.

inversion i; auto.



  cut (one < state_n0).

  intro n_ge_1.

  2: apply not_final with state_p0 true; auto with arith.



  inversion i.

  

  split.

  left.

  rewrite two_power_S.

  rewrite <- mult_assoc; auto with arith.

  unfold shift in a0.

  rewrite <- a0; auto.

  unfold shift in a0.

  apply quotient_positive with state_n0 two; auto.

  rewrite mult_comm; exact a0.

  unfold stat_order, ltof in |- *.

  apply half_lt.

  apply lt_trans with one; auto with arith.

  auto with arith.



  cut (one < state_n0).

  intro n_ge_1.

  2: apply not_final with state_p0 true; auto with arith.

  inversion i.



  split.

  right.

  rewrite two_power_S.

  rewrite <- mult_assoc; auto with arith.

  rewrite (invar_inv1 state_n0 state_p0); auto.

  rewrite b.

  unfold shift in |- *.

  auto with arith.

  rewrite two_power_S.

  rewrite <- mult_assoc.

  rewrite (invar_inv1 state_n0 state_p0); auto.

  rewrite b.

  unfold shift in |- *.

  apply mult_lt_l.

  auto with arith.

  simpl in |- *; auto with arith.

  case (lt_or_Zero m); auto with arith.

  intro.

  absurd (one < state_n0); auto with arith.

  rewrite b.

  rewrite H3; simpl in |- *; auto with arith.

  unfold stat_order, ltof in |- *; apply half_lt.

  simpl in |- *.

  apply lt_trans with one; auto with arith.

  auto with arith.



  cut (one < state_n0).

  intro n_ge_1.

  2: apply not_final with state_p0 false; auto with arith.

  inversion i.



  cut (two_power (S state_p0) * m < n0).

  intro n0_left'.



  cut (n0 < two_power (S state_p0) * S m).

  intro n0_right'.



  cut (m < state_n0).

  intro m_little.



  split.

  right; auto with arith.

  case (lt_or_Zero m); auto with arith.

  intro.

  absurd (one < state_n0); auto with arith.

  simpl in b'; elim b'; intros eg; rewrite eg.

  rewrite H4; simpl in |- *; auto with arith.

  rewrite H4; simpl in |- *; auto with arith.

  unfold stat_order, ltof in |- *.

  simpl in |- *.

  exact m_little.

 

  apply half_lt.

  apply lt_trans with one; auto with arith.

  simpl in b'; elim b'; auto with arith.



  simpl in b'; elim b'; intros eg.

  apply lt_trans with (two_power state_p0 * S state_n0); auto with arith.

  rewrite two_power_S.

  rewrite <- mult_assoc; auto with arith.

  apply mult_lt_l.

  auto with arith.

  rewrite eg.

  unfold shift in |- *; simpl in |- *; auto with arith.

  replace (two_power (S state_p0) * S m) with

   (two_power state_p0 * S state_n0).

  elim (invar_inv2 state_n0 state_p0); auto with arith.

  elim H0; auto with arith.

  rewrite two_power_S.

  rewrite <- mult_assoc.

  simpl in |- *.

  unfold shift in |- *; simpl in |- *.

  rewrite <- plus_n_Sm.

  rewrite eg; auto with arith.



  apply le_lt_trans with (two_power state_p0 * state_n0); auto with arith.

  simpl in b'; elim b'; intro eg.

  rewrite eg.

  rewrite two_power_S.

  rewrite <- mult_assoc; auto with arith.

  rewrite eg.

  rewrite two_power_S.

  rewrite <- mult_assoc; auto with arith.



  simple induction s.

  simple induction state_b0.

  intros.

  rewrite (final_inv state_n0 state_p0 true).

  

  left.

  rewrite (invar_inv1 _ _ H0).

  rewrite (final_inv _ _ _ H).

  auto with arith.

  auto with arith.

  

  intros.

  rewrite (final_inv state_n0 state_p0 false).

  right.

  

  elim (invar_inv2 _ _ H0).

  rewrite (final_inv _ _ _ H).

  intros.

  rewrite <- (mult_1_r (two_power state_p0)); auto with arith.

  

  elim (invar_inv2 _ _ H0).

  rewrite (final_inv _ _ _ H).

  intros.

  rewrite two_power_S.

  exact H2.

  auto with arith.

  

  simple induction s.

  simple induction state_b0.

  intro.

  inversion_clear H.

  elim H1.

  simpl in |- *; intros.

  left.

  rewrite H; simpl in |- *.

  rewrite <- H0; auto with arith.

  simpl in H0; rewrite H0; auto with arith.

  

  intro.

  inversion_clear H.

  elim H1.

  intros.

  simpl in H2.

  discriminate H2.

  

  auto with arith.

  auto with arith.

  

  left.

  inversion h; auto.

 

  right.

  inversion h; split; auto.



Qed. 



End log2_computation.

