
Require Import Constants.
(* Constants:
Global Set Asymmetric Patterns.

Definition one := 1.
Definition two := 2.
Definition three := 3.
Definition four := 4. *)
Require Import monoid.
(* monoid:
Require Import Arith.
Require Import Constants.

Section monoid_def.

Variable M : Set.

Record monoid : Set := mkmonoid
  {u : M;
   o : M -> M -> M;
   point_assoc : forall a b c : M, o a (o b c) = o (o a b) c;
   u_neutral_l : forall a : M, o u a = a;
   u_neutral_r : forall a : M, o a u = a}.

Hint Resolve point_assoc u_neutral_r u_neutral_l: arith.

Variable MO : monoid.
Let u' := u MO.
Let o' := o MO.
Remark o'_assoc : forall a b c : M, o' a (o' b c) = o' (o' a b) c.
Hint Resolve o'_assoc: arith.

Remark u'_neutral_l : forall a : M, o' u' a = a.
Hint Resolve u'_neutral_l: arith.

Remark u'_neutral_r : forall a : M, o' a u' = a.
Hint Resolve u'_neutral_r: arith.

Fixpoint power (x : M) (n : nat) {struct n} : M :=
  match n with
  | O => u'
  | S n => o' x (power x n)
  end.
                                     
Lemma power_u : forall m : nat, power u' m = u'.
Hint Resolve power_u: arith.

Lemma power_plus :
 forall (a : M) (n p : nat), power a (n + p) = o' (power a n) (power a p).
Hint Resolve power_plus: arith.

Lemma power_1 : forall a : M, power a 1 = a.

Lemma power_sym :
 forall (a : M) (n p : nat),
 o' (power a n) (power a p) = o' (power a p) (power a n).
Hint Resolve power_sym: arith.

Lemma power_mult :
 forall (a : M) (n p : nat), power a (p * n) = power (power a n) p.
Hint Resolve power_mult: arith.

Lemma a2x : forall (a : M) (x : nat), power (o' a a) x = power a (x + x).

Lemma power_eucl :
 forall (m : M) (b q r : nat),
 power m (q * b + r) = o' (power (power m b) q) (power m r).
Hint Resolve power_eucl: arith.

End monoid_def. *)
Require Import spec.
(* spec:
Require Import monoid.
Require Import machine.
Require Import Constants.

Inductive Call : Set :=
  | Call_M : nat -> Call
  | Call_C : nat -> nat -> Call
  | Call_K : nat -> nat -> Call.
 
Definition conform (c : Call) : Prop :=
  match c return Prop with
  | Call_M n =>
        0 < n
       
  | Call_C n p => 1 < p /\ p < n
       
  | Call_K n p => 0 < p /\ p < n
  end.

Inductive Spec : Call -> Code -> Prop :=
  | m_spec :
      forall (n : nat) (c : Code),
      (forall (M : Set) (MO : monoid M) (a : M) (s : Stack M),
       Exec M MO c (config M a s) = config M (power M MO a n) s) ->
      Spec (Call_M n) c
  | c_spec :
      forall (p q : nat) (c : Code),
      (forall (M : Set) (MO : monoid M) (a : M) (s : Stack M),
       Exec M MO c (config M a s) = config M (power M MO a p) s) ->
      Spec (Call_C p q) c
  | k_spec :
      forall (p q : nat) (c : Code),
      (forall (M : Set) (MO : monoid M) (a : M) (s : Stack M),
       Exec M MO c (config M a s) =
       config M (power M MO a p) (push M (power M MO a q) s)) ->
      Spec (Call_K p q) c.

Inductive gencode (c : Call) : Set :=
    gencode_intro : forall co : Code, Spec c co -> gencode c.

Inductive addchain_spec (n : nat) : Set :=
    addchain_spec_intro : gencode (Call_M n) -> addchain_spec n. *)
Require Import machine.
(* machine:
Require Import monoid.
Require Import Constants.

Inductive Instr : Set :=
  | MUL : Instr
  | SQR : Instr
  | PUSH : Instr
  | SWAP : Instr.       

Inductive Code : Set :=
  | End : Code
  | seq : Instr -> Code -> Code.

Fixpoint app (c : Code) : Code -> Code :=
  fun c' : Code => match c with
                   | End => c'
                   | seq i c => seq i (app c c')
                   end.

Section Monoid.
 Variable M : Set.
 Variable MO : monoid M.
 Let uM := u _ MO.
 Let oM := o _ MO.

 Inductive Stack : Set :=
   | emptystack : Stack
   | push : M -> Stack -> Stack.

 Definition top (s : Stack) :=
   match s return M with
   | emptystack => uM
   | push m _ => m
   end.
 Definition pop (s : Stack) :=
   match s return Stack with
   | emptystack => emptystack
   | push _ r => r
   end.

 Record Config : Set := config {config_X : M; config_S : Stack}.

 Lemma Config_inv :
  forall (a a' : M) (s s' : Stack),
  a = a' -> s = s' -> config a s = config a' s'.
 
 Hint Resolve Config_inv: arith.

 Definition Exec1 (c : Instr) (v : Config) : Config :=
   let (m, s) := v in
   match c with
   | MUL => config (oM m (top s)) (pop s) 
   | SQR => config (oM m m) s
   | PUSH => config m (push m s)
   | SWAP => config m (push (top (pop s)) (push (top s) (pop (pop s))))
   end.
 
Fixpoint Exec (c : Code) : Config -> Config :=
  fun v : Config =>
  match c with
  | End => v
  | seq i c => Exec c (Exec1 i v)
  end.

 Lemma Exec_app :
  forall (c c' : Code) (v : Config), Exec (app c c') v = Exec c' (Exec c v).

End Monoid. *)
Require Import Wf_compl.
(* Wf_compl:
Section Prop_induction.

 Variable A : Set.
 Variable R : A -> A -> Prop.
 Hypothesis W : well_founded R.
 Hint Resolve W: arith.

 Lemma Prop_wfi :
  forall P : A -> Prop,
  (forall x : A, (forall y : A, R y x -> P y) -> P x) -> forall a : A, P a.

End Prop_induction.

Definition coarser (A : Set) (R S : A -> A -> Prop) :=
  forall x y : A, R x y -> S x y.

Lemma wf_coarser :
 forall (A : Set) (R S : A -> A -> Prop),
 coarser A R S -> well_founded S -> well_founded R. *)
Require Import Plus.
Require Import Mult.
Require Import Lt.
Require Import Mult_compl.
(* Mult_compl:
Require Import Arith.
Require Import Constants.
Require Import Le_lt_compl.

Lemma mult_le_l : forall a b c : nat, b <= c -> a * b <= a * c.
Hint Resolve mult_le_l: arith.

Lemma mult_lt_l : forall a b c : nat, 0 < a -> b < c -> a * b < a * c.

Hint Resolve mult_lt_l: arith.

Lemma mult_le_r : forall a b c : nat, b <= c -> b * a <= c * a.
Hint Resolve mult_le_r: arith.

Lemma mult_lt_r : forall a b c : nat, 0 < a -> b < c -> b * a < c * a.
Hint Resolve mult_lt_r: arith.

Lemma mult_inj_l : forall a b c : nat, a * c < b * c -> a < b.

Lemma mult_p_lt_qp : forall p q : nat, 0 < p -> one < q -> p < q * p.  

Lemma mult_p_le_qp : forall p q : nat, 0 < q -> p <= q * p.

Hint Resolve mult_p_lt_qp mult_p_le_qp: arith.
 
Lemma mult_p_lt_pq : forall p q : nat, 0 < p -> one < q -> p < p * q.  

Lemma mult_p_le_pq : forall p q : nat, 0 < q -> p <= p * q.

Hint Resolve mult_p_lt_pq mult_p_le_pq: arith.

Lemma quotient_positive : forall q n n0 : nat, n = q * n0 -> 0 < n -> 0 < q.

Lemma quotient_gt_one : forall q n n0 : nat, n0 < n -> n = q * n0 -> one < q. *)
Require Import euclid.
(* euclid:
Require Import Arith.
Require Import Constants.
Require Import Le_lt_compl.
Require Import Mult_compl.

Lemma lt_b_qbr : forall b q r : nat, 0 < r -> 0 < q -> r < b -> b < q * b + r.

Hint Resolve lt_b_qbr: arith.

Lemma lt_q_qbr : forall b q r : nat, 0 < r -> one < b -> q < q * b + r.
Hint Resolve lt_q_qbr: arith.

Lemma lt_q_qbr' : forall b q r : nat, 0 < q -> one < b -> q < q * b + r.

Hint Resolve lt_q_qbr': arith.

Lemma le_q_qbr : forall b q r : nat, 0 < b -> q <= q * b + r.
  
Hint Resolve le_q_qbr: arith.

Lemma lt_O_q : forall b q r : nat, b < q * b + r -> 0 < r -> r < b -> 0 < q. *)
Require Import two_power.
(* two_power:
Require Import Arith.
Require Import Peano_dec.
Require Import Constants.
Require Import Mult_compl.
Require Import Le_lt_compl.

Fixpoint two_power (m : nat) : nat :=
  match m with
  | O => 1
  | S n => two * two_power n
  end.

Lemma zero_lt_pow : forall a : nat, 0 < two_power a.
Hint Resolve zero_lt_pow: arith.

Lemma two_power_S : forall n : nat, two_power (S n) = two_power n * two.

Lemma two_power_S_lt : forall n : nat, two_power n < two_power (S n).

Lemma two_power_mono : forall n p : nat, n < p -> two_power n < two_power p.

Lemma two_power_le : forall n p : nat, n <= p -> two_power n <= two_power p.

Lemma two_power_monoR : forall n p : nat, two_power n < two_power p -> n < p.

Lemma holes_in_powers :
 forall n z : nat,
 two_power n < z -> z < two_power (S n) -> forall p : nat, z <> two_power p.

Lemma log2_unicity :
 forall n p z : nat,
 two_power n < z ->
 z < two_power (S n) -> two_power p < z -> z < two_power (S p) -> n = p. *)

Lemma M3 : gencode (Call_M three).

Proof.
 refine (gencode_intro _ (seq PUSH (seq SQR (seq MUL End))) _).

 constructor 1.
 simpl in |- *; unfold power, three in |- *; intros.
 rewrite (u_neutral_r M MO).
 rewrite <- (point_assoc M MO); auto with arith.
 Qed.

Lemma M2q : forall q : nat, gencode (Call_M (two_power q)).

Proof.
 refine
  (let t := fun q : nat => gencode (Call_M (two_power q)) in
   (fix M2q (q : nat) : t q :=
      match q as x return (t x) with
      | O => gencode_intro _ End _
      | S p =>
          match M2q p with
          | gencode_intro c s => gencode_intro _ (seq SQR c) _
          end
      end)).

 constructor 1.
 unfold power in |- *; simpl in |- *.
 intros; rewrite (u_neutral_r M MO); auto with arith.
 constructor 1; auto with arith.
 intros; simpl in |- *.
 inversion_clear s.
 rewrite H.
 apply Config_inv; auto with arith.
 rewrite <- plus_n_O.
 apply a2x; auto with arith.
Qed.

Lemma C2M : forall p q : nat, gencode (Call_C p q) -> gencode (Call_M p).

Proof.
 refine
  (fun p q g => match g with
                | gencode_intro c s => gencode_intro _ c _
                end).

 constructor 1.
 inversion_clear s.
 auto with arith.
Qed.

Lemma MMC :
 forall p q : nat,
 gencode (Call_M p) -> gencode (Call_M q) -> gencode (Call_C (q * p) p).

Proof.
 refine
  (fun p q g g' =>
   match g with
   | gencode_intro c s =>
       match g' with
       | gencode_intro c' s0 => gencode_intro _ (app c c') _
       end
   end).

 constructor 2.
 intros; rewrite Exec_app.
 inversion_clear s.
 rewrite H.
 inversion_clear s0.
 rewrite (H0 M MO).
 rewrite power_mult; auto with arith.
Qed.

Lemma KMC :
 forall p q r : nat,
 gencode (Call_K p r) -> gencode (Call_M q) -> gencode (Call_C (q * p + r) p).

Proof.
 refine
  (fun p q r g g' =>
   match g with
   | gencode_intro cpr s =>
       match g' with
       | gencode_intro cq s0 =>
           gencode_intro _ (app cpr (app cq (seq MUL End))) _
       end
   end).

 inversion_clear s; inversion_clear s0.
 constructor 2.
 intros; rewrite Exec_app.
 rewrite (H M MO a).
 rewrite (Exec_app M MO); simpl in |- *; rewrite H0.
 simpl in |- *.
 apply Config_inv.
 rewrite power_eucl; auto with arith.
 auto with arith.
Qed.

Lemma MMK :
 forall p q : nat,
 gencode (Call_M p) -> gencode (Call_M q) -> gencode (Call_K (q * p) p).

Proof.
 refine
  (fun p q g g' =>
   match g with
   | gencode_intro cp s =>
       match g' with
       | gencode_intro cq s0 => gencode_intro _ (app cp (seq PUSH cq)) _
       end
   end).

 inversion_clear s; inversion_clear s0.
 constructor 3.
 intros; rewrite Exec_app. 
 rewrite H; simpl in |- *.
 rewrite H0; simpl in |- *.
 apply Config_inv; auto with arith.
 rewrite <- power_mult; auto with arith.
Qed.

Lemma KMK :
 forall p q r : nat,
 gencode (Call_K p r) -> gencode (Call_M q) -> gencode (Call_K (q * p + r) p).

Proof.
  refine
   (fun p q r g g' =>
    match g with
    | gencode_intro kpr s =>
        match g' with
        | gencode_intro mq s0 =>
            gencode_intro _
              (app kpr (seq PUSH (seq SWAP (app mq (seq MUL End))))) _
        end
    end).

 inversion_clear s; inversion_clear s0.
 constructor 3.
 intros; rewrite Exec_app.
 rewrite H; simpl in |- *.
 rewrite Exec_app.
 rewrite H0; simpl in |- *. auto with arith.
 rewrite power_eucl; auto with arith.
Qed.

