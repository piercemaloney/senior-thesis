

Require Import Arith.

Require Import Constants.
(* Constants:
Global Set Asymmetric Patterns.

Definition one := 1.
Definition two := 2.
Definition three := 3.
Definition four := 4. *)

Require Import Le_lt_compl.
(* Le_lt_compl:
Require Import Arith.
Require Import Constants.

Lemma lt_or_Zero : forall q : nat, 0 < q \/ q = 0.

Lemma one_cases : forall q : nat, 1 < q \/ q = 0 \/ q = 1.

Lemma enum1 : forall n : nat, n < two -> n = 0 \/ n = 1.

Lemma le5 :
 forall P : nat -> Prop,
 P 0 ->
 P one ->
 P two ->
 P three ->
 P four -> (forall n : nat, four < n -> P n) -> forall n : nat, P n.

Lemma enum4 :
 forall n : nat,
 n < S four -> n = 0 \/ n = one \/ n = two \/ n = three \/ n = four.

Lemma not_le_lt : forall n m : nat, ~ n <= m -> m < n.
Hint Immediate not_le_lt: arith.

Lemma not_lt_le : forall n m : nat, ~ n < m -> m <= n.
Hint Immediate not_lt_le: arith.

Lemma lt_not_lt : forall n p : nat, n < p -> ~ p < S n.

Lemma lt_a_a_plus_b : forall a b : nat, 0 < b -> a < a + b.

Hint Resolve lt_a_a_plus_b: arith. *)



Lemma mult_le_l : forall a b c : nat, b <= c -> a * b <= a * c.



Proof.

 simple induction a; simpl in |- *; [ auto with arith | intros ].

 apply plus_le_compat; auto with arith.

Qed.

Hint Resolve mult_le_l: arith.



Lemma mult_lt_l : forall a b c : nat, 0 < a -> b < c -> a * b < a * c.



Proof.

 simple induction a.

 intros; absurd (0 < 0); auto with arith.

 intros; simpl in |- *.

 apply lt_le_trans with (c + n * b).

 rewrite (plus_comm b (n * b)); rewrite (plus_comm c (n * b));

  apply plus_lt_compat_l; auto with arith.

 apply plus_le_compat_l; auto with arith.

Qed.



Hint Resolve mult_lt_l: arith.



Lemma mult_le_r : forall a b c : nat, b <= c -> b * a <= c * a.



Proof.

 intros; rewrite (mult_comm b a); rewrite (mult_comm c a); auto with arith.

Qed.

Hint Resolve mult_le_r: arith.



Lemma mult_lt_r : forall a b c : nat, 0 < a -> b < c -> b * a < c * a.



Proof.

 intros; rewrite (mult_comm b a); rewrite (mult_comm c a); auto with arith.

Qed.

Hint Resolve mult_lt_r: arith.



Lemma mult_inj_l : forall a b c : nat, a * c < b * c -> a < b.



Proof.

 intros.

 case (le_or_lt b a); [ intro | auto with arith ].

 absurd (b * c <= a * c); auto with arith.

Qed.



Lemma mult_p_lt_qp : forall p q : nat, 0 < p -> one < q -> p < q * p.  



Proof.

 intros.

 rewrite mult_comm.

 pattern p at 1 in |- *; rewrite <- mult_1_r; auto with arith.

Qed.



Lemma mult_p_le_qp : forall p q : nat, 0 < q -> p <= q * p.



Proof.

 intros.

 pattern p at 1 in |- *; rewrite <- mult_1_r.

 rewrite <- (mult_comm p q); auto with arith.

Qed.



Hint Resolve mult_p_lt_qp mult_p_le_qp: arith.

 

Lemma mult_p_lt_pq : forall p q : nat, 0 < p -> one < q -> p < p * q.  



Proof.

 intros; rewrite mult_comm; auto with arith.

Qed.



Lemma mult_p_le_pq : forall p q : nat, 0 < q -> p <= p * q.



Proof.

 intros; rewrite mult_comm; auto with arith.

Qed.



Hint Resolve mult_p_lt_pq mult_p_le_pq: arith.



Lemma quotient_positive : forall q n n0 : nat, n = q * n0 -> 0 < n -> 0 < q.



Proof.

 intros q n n0 H H0.

 case (lt_or_Zero q); [ auto with arith | intro H1 ].

 absurd (0 < q * n0).

 rewrite H1; simpl in |- *; auto with arith.

 rewrite <- H; auto with arith.

Qed.



Lemma quotient_gt_one : forall q n n0 : nat, n0 < n -> n = q * n0 -> one < q.



Proof.

 intros q n n0 H H0; case (one_cases q);

  [ auto with arith

  | simple induction 1; intro; absurd (n0 < n); auto with arith ].

 rewrite H0; rewrite H2; auto with arith.

 rewrite H0; rewrite H2; simpl in |- *; rewrite <- plus_n_O; auto with arith.

Qed.



