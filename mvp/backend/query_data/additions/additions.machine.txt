
Require Import monoid.
(* monoid:
Require Import Arith.
Require Import Constants.

Section monoid_def.

Variable M : Set.

Record monoid : Set := mkmonoid
  {u : M;
   o : M -> M -> M;
   point_assoc : forall a b c : M, o a (o b c) = o (o a b) c;
   u_neutral_l : forall a : M, o u a = a;
   u_neutral_r : forall a : M, o a u = a}.

Hint Resolve point_assoc u_neutral_r u_neutral_l: arith.

Variable MO : monoid.
Let u' := u MO.
Let o' := o MO.
Remark o'_assoc : forall a b c : M, o' a (o' b c) = o' (o' a b) c.
Hint Resolve o'_assoc: arith.

Remark u'_neutral_l : forall a : M, o' u' a = a.
Hint Resolve u'_neutral_l: arith.

Remark u'_neutral_r : forall a : M, o' a u' = a.
Hint Resolve u'_neutral_r: arith.

Fixpoint power (x : M) (n : nat) {struct n} : M :=
  match n with
  | O => u'
  | S n => o' x (power x n)
  end.
                                     
Lemma power_u : forall m : nat, power u' m = u'.
Hint Resolve power_u: arith.

Lemma power_plus :
 forall (a : M) (n p : nat), power a (n + p) = o' (power a n) (power a p).
Hint Resolve power_plus: arith.

Lemma power_1 : forall a : M, power a 1 = a.

Lemma power_sym :
 forall (a : M) (n p : nat),
 o' (power a n) (power a p) = o' (power a p) (power a n).
Hint Resolve power_sym: arith.

Lemma power_mult :
 forall (a : M) (n p : nat), power a (p * n) = power (power a n) p.
Hint Resolve power_mult: arith.

Lemma a2x : forall (a : M) (x : nat), power (o' a a) x = power a (x + x).

Lemma power_eucl :
 forall (m : M) (b q r : nat),
 power m (q * b + r) = o' (power (power m b) q) (power m r).
Hint Resolve power_eucl: arith.

End monoid_def. *)
Require Import Constants.
(* Constants:
Global Set Asymmetric Patterns.

Definition one := 1.
Definition two := 2.
Definition three := 3.
Definition four := 4. *)

Inductive Instr : Set :=
  | MUL : Instr
  | SQR : Instr
  | PUSH : Instr
  | SWAP : Instr.       

Inductive Code : Set :=
  | End : Code
  | seq : Instr -> Code -> Code.

Fixpoint app (c : Code) : Code -> Code :=
  fun c' : Code => match c with
                   | End => c'
                   | seq i c => seq i (app c c')
                   end.

Section Monoid.
 Variable M : Set.
 Variable MO : monoid M.
 Let uM := u _ MO.
 Let oM := o _ MO.

 Inductive Stack : Set :=
   | emptystack : Stack
   | push : M -> Stack -> Stack.

 Definition top (s : Stack) :=
   match s return M with
   | emptystack => uM
   | push m _ => m
   end.
 Definition pop (s : Stack) :=
   match s return Stack with
   | emptystack => emptystack
   | push _ r => r
   end.

 Record Config : Set := config {config_X : M; config_S : Stack}.

 Lemma Config_inv :
  forall (a a' : M) (s s' : Stack),
  a = a' -> s = s' -> config a s = config a' s'.
 
 Proof.
  intros. rewrite H; rewrite H0; auto.
 Qed.
 
 Hint Resolve Config_inv: arith.

 Definition Exec1 (c : Instr) (v : Config) : Config :=
   let (m, s) := v in
   match c with
   | MUL => config (oM m (top s)) (pop s) 
   | SQR => config (oM m m) s
   | PUSH => config m (push m s)
   | SWAP => config m (push (top (pop s)) (push (top s) (pop (pop s))))
   end.
 
Fixpoint Exec (c : Code) : Config -> Config :=
  fun v : Config =>
  match c with
  | End => v
  | seq i c => Exec c (Exec1 i v)
  end.

 Lemma Exec_app :
  forall (c c' : Code) (v : Config), Exec (app c c') v = Exec c' (Exec c v).
 
 Proof.
  simple induction c; simpl in |- *.
  auto.
  intros; rewrite H; auto. 
 Qed.

End Monoid.

