
Require Import Bool.
Require Import NArith.
Require Import Ndec.
Require Import ZArith.
Require Import EqNat.
From IntMap Require Import Allmaps.
Require Import bases.
(* bases:
Require Import Bool.
Require Import Arith.
Require Import ZArith.
Require Import NArith.
Require Import Ndec.
From IntMap Require Import Allmaps.
Require Import EqNat.
Require Export Max.

Lemma nat_sum : forall n : nat, n = 0 \/ (exists m : nat, n = S m).

Lemma le_n_n : forall n : nat, n <= n.

Lemma le_l_or_r : forall n m : nat, n <= m \/ m <= n.

Lemma plus_n_O : forall n : nat, n + 0 = n.
 
 Lemma S_plus_l : forall n m : nat, S (n + m) = S n + m.
 
 Lemma S_plus_r : forall n m : nat, S (n + m) = n + S m.

Lemma max_le_Sr_0 :
 forall n m : nat, max n m <= max n (S m) /\ max (S n) m <= max (S n) (S m).

Lemma max_le_Sr : forall n m : nat, max n m <= max n (S m).

Lemma plus_O_r : forall n : nat, n + 0 = n.

Lemma plus_O_l : forall n : nat, n + 0 = n.

Lemma le_mult_lS : forall n m : nat, n * m <= S n * m.

Lemma le_mult_rS : forall n m : nat, n * m <= n * S m.

Lemma le_disj : forall n m : nat, n <= m -> n = m \/ S n <= m.

Lemma le_mult_l : forall n m p : nat, n <= m -> n * p <= m * p.

Lemma le_mult_r : forall n m p : nat, n <= m -> p * n <= p * m.

Lemma le_mult_mult : forall n m p q : nat, n <= m -> p <= q -> n * p <= m * q.

Lemma Sn_eq_Sm_n_eq_m : forall n m : nat, S n = S m -> n = m.

Lemma bool_dec_eq : forall a b : bool, {a = b} + {a <> b}.

Lemma bool_is_false_or_true : forall a : bool, a = false \/ a = true.

Lemma bool_is_true_or_false : forall a : bool, a = true \/ a = false.

Lemma in_M0_false :
 forall (A : Set) (a : A), ~ (exists e : ad, MapGet A (M0 A) e = Some a).

Lemma in_M1_id :
 forall (A : Set) (a : A) (x : ad) (e : A),
 (exists c : ad, MapGet A (M1 A x e) c = Some a) -> a = e.

Lemma in_M2_disj :
 forall (A : Set) (a : A) (m0 m1 : Map A),
 (exists c : ad, MapGet A (M2 A m0 m1) c = Some a) ->
 (exists c : ad, MapGet A m0 c = Some a) \/
 (exists c : ad, MapGet A m1 c = Some a).

Lemma aux_Neqb_1_0 : forall p : positive, Peqb p p = true.

Lemma aux_Neqb_1_1 : forall p p0 : positive, Peqb p p0 = true -> p = p0.

Lemma aux_Neqb_trans :
 forall a b c : ad, Neqb a b = true -> Neqb b c = true -> Neqb a c = true.

Lemma indprinciple_nat_gen :
 forall P : nat -> Prop,
 (forall n : nat, (forall m : nat, m < n -> P m) -> P n) ->
 forall n m : nat, m <= n -> P m.

Lemma beq_nat_complete : forall n m : nat, beq_nat n m = true -> n = m.

Lemma beq_nat_correct : forall n : nat, beq_nat n n = true. *)
Require Import defs.
(* defs:
Require Import Bool.
Require Import Arith.
Require Import ZArith.
From IntMap Require Import Allmaps.
Require Import EqNat.
Require Import bases.

Inductive term : Set :=
    app : ad -> term_list -> term
with term_list : Set :=
  | tnil : term_list
  | tcons : term -> term_list -> term_list.

Scheme term_term_list_rec := Induction for term
  Sort Set
  with term_list_term_rec := Induction for term_list 
  Sort Set.

Scheme term_term_list_ind := Induction for term
  Sort Prop
  with term_list_term_ind := Induction for term_list 
  Sort Prop.

Lemma term_list_disj :
 forall l : term_list,
 l = tnil \/ (exists hd : term, (exists tl : term_list, l = tcons hd tl)).

Fixpoint lst_length (l : term_list) : nat :=
  match l with
  | tnil => 0
  | tcons _ l' => S (lst_length l')
  end.

Fixpoint term_high (t : term) : nat :=
  match t with
  | app a l => S (term_high_0 l)
  end
 
 with term_high_0 (l : term_list) : nat :=
  match l with
  | tnil => 0
  | tcons hd tl => max (term_high hd) (term_high_0 tl)
  end.

Lemma high_aux_0 :
 forall (a : ad) (l : term_list), S (term_high_0 l) <= term_high (app a l).

Lemma high_aux_1 :
 forall (a : ad) (l : term_list), S (term_high_0 l) = term_high (app a l).

Lemma high_aux_2 : forall (l : term_list) (c : ad), 1 <= term_high (app c l).

Lemma high_aux_3 :
 forall (t : term) (tl : term_list), term_high t <= term_high_0 (tcons t tl).

Lemma high_aux_4 :
 forall (t : term) (tl : term_list),
 term_high_0 tl <= term_high_0 (tcons t tl).

Fixpoint taille_term (t : term) : nat :=
  match t with
  | app c l => S (mtaille_term_list l)
  end
 
 with mtaille_term_list (l : term_list) : nat :=
  match l with
  | tnil => 0
  | tcons hd tl => max (taille_term hd) (mtaille_term_list tl)
  end.

Inductive prec_list : Set :=
  | prec_cons : ad -> prec_list -> prec_list -> prec_list
  | prec_empty : prec_list.

Lemma pl_sum :
 forall pl : prec_list,
 pl = prec_empty \/
 (exists a : ad,
    (exists la : prec_list, (exists ls : prec_list, pl = prec_cons a la ls))).

Definition state := Map prec_list.

Definition preDTA := Map state.

Inductive DTA : Set :=
    dta : preDTA -> ad -> DTA.

Fixpoint taille_0 (l : prec_list) : nat :=
  match l with
  | prec_empty => 0
  | prec_cons x y z => S (taille_0 y + taille_0 z)
  end.

Fixpoint taille_1 (s : state) : nat :=
  match s with
  | M0 => 0
  | M1 x y => taille_0 y
  | M2 x y => max (taille_1 x) (taille_1 y)
  end.

Fixpoint DTA_taille (d : preDTA) : nat :=
  match d with
  | M0 => 0
  | M1 x y => taille_1 y
  | M2 x y => max (DTA_taille x) (DTA_taille y)
  end.

Lemma taille_aux_0 :
 forall (a : ad) (la ls : prec_list),
 S (taille_0 la) <= taille_0 (prec_cons a la ls).

Lemma taille_aux_1 :
 forall (a : ad) (la ls : prec_list), 1 <= taille_0 (prec_cons a la ls).

Lemma taille_aux_2 :
 forall (a : ad) (la ls : prec_list),
 S (taille_0 ls) <= taille_0 (prec_cons a la ls).

Inductive prec_occur : prec_list -> ad -> Prop :=
  | prec_hd :
      forall (a : ad) (pl0 pl1 : prec_list),
      prec_occur (prec_cons a pl0 pl1) a
  | prec_int0 :
      forall (a b : ad) (pl0 pl1 : prec_list),
      prec_occur pl0 b -> prec_occur (prec_cons a pl0 pl1) b
  | prec_int1 :
      forall (a b : ad) (pl0 pl1 : prec_list),
      prec_occur pl1 b -> prec_occur (prec_cons a pl0 pl1) b.

Inductive prec_contained : prec_list -> prec_list -> Prop :=
  | prec_id : forall p : prec_list, prec_contained p p
  | prec_c_int0 :
      forall (p p0 p1 : prec_list) (a : ad),
      prec_contained p p0 -> prec_contained p (prec_cons a p0 p1)
  | prec_c_int1 :
      forall (p p0 p1 : prec_list) (a : ad),
      prec_contained p p1 -> prec_contained p (prec_cons a p0 p1).

Definition state_in_dta (d : preDTA) (s : state) : Prop :=
  exists a : ad, MapGet state d a = Some s.

Definition state_in_dta_diff (d : preDTA) (s : state) 
  (a : ad) : Prop := exists b : ad, MapGet state d b = Some s /\ a <> b.

Definition prec_in_dta (d : preDTA) (p : prec_list) : Prop :=
  exists s : state,
    (exists a : ad,
       (exists c : ad,
          MapGet state d a = Some s /\
          MapGet prec_list s c = Some p)).

Definition prec_in_dta_cont (d : preDTA) (p : prec_list) : Prop :=
  exists s : state,
    (exists b : ad,
       (exists c : ad,
          (exists p0 : prec_list,
             MapGet state d b = Some s /\
             MapGet prec_list s c = Some p0 /\ prec_contained p p0))).

Definition prec_in_dta_diff (d : preDTA) (p : prec_list) 
  (a : ad) : Prop :=
  exists s : state,
    (exists b : ad,
       (exists c : ad,
          MapGet state d b = Some s /\
          MapGet prec_list s c = Some p /\ a <> b)).

Definition prec_in_dta_diff_cont (d : preDTA) (p : prec_list) 
  (a : ad) : Prop :=
  exists s : state,
    (exists b : ad,
       (exists c : ad,
          (exists p0 : prec_list,
             MapGet state d b = Some s /\
             MapGet prec_list s c = Some p0 /\
             prec_contained p p0 /\ a <> b))).

Definition prec_in_state (s : state) (p : prec_list) : Prop :=
  exists c : ad, MapGet prec_list s c = Some p.

Lemma prec_in_state_M0_false :
 forall p : prec_list, ~ prec_in_state (M0 prec_list) p.

Lemma state_in_dta_M0_false : forall s : state, ~ state_in_dta (M0 state) s.

Lemma prec_occur_1 :
 forall (a : ad) (p0 p1 p2 : prec_list),
 prec_contained (prec_cons a p0 p1) p2 -> prec_occur p2 a.

Lemma prec_contained_0 :
 forall (a : ad) (p0 p1 p2 : prec_list),
 prec_contained (prec_cons a p0 p1) p2 -> prec_contained p0 p2.

Lemma prec_contained_1 :
 forall (a : ad) (p0 p1 p2 : prec_list),
 prec_contained (prec_cons a p0 p1) p2 -> prec_contained p1 p2.

Inductive term_occur : term -> term -> Prop :=
  | to_eq : forall t : term, term_occur t t
  | to_st :
      forall (t : term) (a : ad) (tl : term_list),
      term_list_occur t tl -> term_occur t (app a tl)
with term_list_occur : term -> term_list -> Prop :=
  | tlo_head :
      forall (t hd : term) (tl : term_list),
      term_occur t hd -> term_list_occur t (tcons hd tl)
  | tlo_tail :
      forall (t hd : term) (tl : term_list),
      term_list_occur t tl -> term_list_occur t (tcons hd tl).

Definition term_occur_def_0 (t : term) :=
  forall u : term, term_occur u t -> term_high u <= term_high t.

Definition term_occur_def_1 (t : term_list) :=
  forall u : term, term_list_occur u t -> term_high u <= term_high_0 t.

Lemma term_occur_0_0 :
 forall (a : ad) (t : term_list),
 term_occur_def_1 t -> term_occur_def_0 (app a t).

Lemma term_occur_0_1 : term_occur_def_1 tnil.

Lemma term_occur_0_2 :
 forall t : term,
 term_occur_def_0 t ->
 forall t0 : term_list, term_occur_def_1 t0 -> term_occur_def_1 (tcons t t0).

Lemma term_occur_0 :
 forall t u : term, term_occur u t -> term_high u <= term_high t.

Lemma term_occur_1 :
 forall (t : term_list) (u : term),
 term_list_occur u t -> term_high u <= term_high_0 t.

Definition indprinciple_3_aux (n : nat) :=
  forall P : term -> Prop,
  (forall (a : ad) (tl : term_list),
   (forall u : term, term_list_occur u tl -> P u) -> P (app a tl)) ->
  forall t : term, term_high t <= n -> P t.

Lemma indprinciple_3_0 : indprinciple_3_aux 0.

Lemma indprinciple_3_1 :
 forall n : nat, indprinciple_3_aux n -> indprinciple_3_aux (S n).

Lemma indprinciple_3_2 :
 forall (n : nat) (P : term -> Prop),
 (forall (a : ad) (tl : term_list),
  (forall u : term, term_list_occur u tl -> P u) -> P (app a tl)) ->
 forall t : term, term_high t <= n -> P t.

Lemma indprinciple_term :
 forall P : term -> Prop,
 (forall (a : ad) (tl : term_list),
  (forall u : term, term_list_occur u tl -> P u) -> P (app a tl)) ->
 forall t : term, P t.

Lemma Ndouble_inv_N0 : forall x : ad, Ndouble x = N0 -> x = N0.

Lemma Ndouble_inv_xO :
 forall (x : ad) (p : positive), Ndouble x = Npos (xO p) -> x = Npos p.

Lemma Ndouble_plus_one_inv_xH :
 forall x : ad, Ndouble_plus_one x = Npos 1 -> x = N0.

Lemma Ndouble_plus_one_inv_xI :
 forall (x : ad) (p : positive),
 Ndouble_plus_one x = Npos (xI p) -> x = Npos p. *)
Require Import semantics.
(* semantics:
Require Import Bool.
Require Import Arith.
Require Import Classical_Prop.
From IntMap Require Import Allmaps.
Require Import bases.
Require Import defs.

Unset Standard Proposition Elimination Names.

Fixpoint rec_term (d : preDTA) (a : ad) (t : term) 
 (n : nat) {struct n} : bool :=
  match n with
  | O => false
  | S k =>
      match t with
      | app c l =>
          match MapGet _ d a with
          | None => false
          | Some lts =>
              match MapGet _ lts c with
              | None => false
              | Some pre => rec_list_terms d pre l k
              end
          end
      end
  end
 
 with rec_list_terms (d : preDTA) (pre : prec_list) 
 (l : term_list) (n : nat) {struct n} : bool :=
  match n with
  | O => false
  | S k =>
      match pre with
      | prec_empty => match l with
                      | tnil => true
                      | _ => false
                      end
      | prec_cons st stp pre' =>
          match l with
          | tnil => false
          | tcons hd tl =>
              rec_list_terms d pre' l k
              || rec_term d st hd k && rec_list_terms d stp tl k
          end
      end
  end.

Lemma borne_0_0 :
 forall p : prec_list,
 prec_in_state (M0 prec_list) p -> taille_0 p <= taille_1 (M0 prec_list).

Lemma borne_0_1 :
 forall (a : ad) (p' p : prec_list),
 prec_in_state (M1 prec_list a p') p ->
 taille_0 p <= taille_1 (M1 prec_list a p').

Lemma borne_0_2 :
 forall (m0 m1 : Map prec_list) (p : prec_list),
 (prec_in_state m0 p -> taille_0 p <= taille_1 m0) ->
 (prec_in_state m1 p -> taille_0 p <= taille_1 m1) ->
 prec_in_state (M2 prec_list m0 m1) p ->
 taille_0 p <= taille_1 (M2 prec_list m0 m1).

Lemma borne_0 :
 forall (s : state) (p : prec_list),
 prec_in_state s p -> taille_0 p <= taille_1 s.

Lemma borne_1_0 :
 forall s : state,
 state_in_dta (M0 state) s -> taille_1 s <= DTA_taille (M0 state).

Lemma borne_1_1 :
 forall (a : ad) (s' s : state),
 state_in_dta (M1 state a s') s -> taille_1 s <= DTA_taille (M1 state a s').

Lemma borne_1_2 :
 forall (m0 m1 : Map state) (s : state),
 (state_in_dta m0 s -> taille_1 s <= DTA_taille m0) ->
 (state_in_dta m1 s -> taille_1 s <= DTA_taille m1) ->
 state_in_dta (M2 state m0 m1) s -> taille_1 s <= DTA_taille (M2 state m0 m1).

Lemma borne_1 :
 forall (d : preDTA) (s : state),
 state_in_dta d s -> taille_1 s <= DTA_taille d.

Lemma borne_2 :
 forall (d : preDTA) (p : prec_list),
 prec_in_dta d p -> taille_0 p <= DTA_taille d.

Definition essence (t : term) (d : preDTA) : nat :=
  S (term_high t) * S (DTA_taille d).

Definition essence_list (l : term_list) (d : preDTA) 
  (pl : prec_list) : nat :=
  match l, pl with
  | tnil, _ => 1
  | _, prec_empty => 1
  | _, prec_cons a la ls =>
      taille_0 pl + S (term_high_0 l) * S (DTA_taille d)
  end.

Lemma conservation_0_0 : forall n n0 : nat, S n * S n0 = S (n0 + n * S n0).

Lemma conservation_0 :
 forall (d : preDTA) (p : prec_list) (c : ad) (l : term_list),
 prec_in_dta d p -> S (essence_list l d p) <= essence (app c l) d.

Lemma conservation_1 :
 forall (d : preDTA) (l : term_list), 1 <= essence_list l d prec_empty.

Lemma conservation_2 :
 forall (d : preDTA) (p : prec_list), 1 <= essence_list tnil d p.

Lemma conservation_3 :
 forall (d : preDTA) (hd : term) (tl : term_list) (a : ad)
   (la ls : prec_list),
 S (essence_list (tcons hd tl) d ls) <=
 essence_list (tcons hd tl) d (prec_cons a la ls).

Lemma conservation_4 :
 forall (d : preDTA) (hd : term) (tl : term_list) (a : ad)
   (la ls : prec_list),
 S (essence_list tl d la) <= essence_list (tcons hd tl) d (prec_cons a la ls).

Lemma conservation_5_0 :
 forall (a : ad) (la ls : prec_list), 1 <= taille_0 (prec_cons a la ls).

Lemma conservation_5 :
 forall (d : preDTA) (hd : term) (tl : term_list) (a : ad)
   (la ls : prec_list),
 S (essence hd d) <= essence_list (tcons hd tl) d (prec_cons a la ls).

Definition dta_rec_term (d : DTA) (t : term) : bool :=
  match d with
  | dta p a => rec_term p a t (essence t p)
  end.

Inductive reconnaissance : preDTA -> ad -> term -> Prop :=
    rec_dta :
      forall (d : preDTA) (a : ad) (t : term) (ladj : state),
      MapGet state d a = Some ladj ->
      state_reconnait d ladj t -> reconnaissance d a t
with state_reconnait : preDTA -> state -> term -> Prop :=
    rec_st :
      forall (d : preDTA) (s : state) (c : ad) (tl : term_list)
        (l : prec_list),
      MapGet prec_list s c = Some l ->
      liste_reconnait d l tl -> state_reconnait d s (app c tl)
with liste_reconnait : preDTA -> prec_list -> term_list -> Prop :=
  | rec_empty : forall d : preDTA, liste_reconnait d prec_empty tnil
  | rec_consi :
      forall (d : preDTA) (a : ad) (la ls : prec_list) 
        (hd : term) (tl : term_list),
      reconnaissance d a hd ->
      liste_reconnait d la tl ->
      liste_reconnait d (prec_cons a la ls) (tcons hd tl)
  | rec_consn :
      forall (d : preDTA) (a : ad) (la ls : prec_list) 
        (hd : term) (tl : term_list),
      liste_reconnait d ls (tcons hd tl) ->
      liste_reconnait d (prec_cons a la ls) (tcons hd tl).

Definition reconnait (d : DTA) (t : term) : Prop :=
  match d with
  | dta p a => reconnaissance p a t
  end.

Scheme mreconnaissance_ind := Induction for reconnaissance
  Sort Prop
  with mstrec_ind := Induction for state_reconnait 
  Sort Prop
  with mlrec_ind := Induction for liste_reconnait Sort Prop.

Lemma sem_listes_0 :
 forall (d : preDTA) (p : prec_list) (hd : term) (tl : term_list),
 liste_reconnait d p (tcons hd tl) -> p <> prec_empty.

Lemma sem_listes_1 :
 forall (d : preDTA) (hd : term) (tl : term_list),
 ~ liste_reconnait d prec_empty (tcons hd tl).

Lemma sem_listes_2 :
 forall (d : preDTA) (pl : prec_list),
 liste_reconnait d pl tnil -> pl = prec_empty.

Definition sem_equiv_prop_t (t : term) :=
  forall (d : preDTA) (a : ad) (n : nat),
  rec_term d a t n = true -> reconnaissance d a t.
Definition sem_equiv_prop_l (l : term_list) :=
  forall (d : preDTA) (p : prec_list) (n : nat),
  rec_list_terms d p l n = true -> liste_reconnait d p l.

Lemma semantic_equiv_0_0 :
 forall (d : preDTA) (p : prec_list) (n : nat),
 rec_list_terms d p tnil n = true -> p = prec_empty.

Lemma semantic_equiv_0_1 : sem_equiv_prop_l tnil.

Lemma semantic_equiv_0_2 :
 forall (d : preDTA) (a a' : ad) (l : term_list) (n : nat) 
   (s : state) (p : prec_list),
 rec_term d a (app a' l) (S n) = true ->
 MapGet state d a = Some s ->
 MapGet prec_list s a' = Some p -> rec_list_terms d p l n = true.

Lemma semantic_equiv_0_3 :
 forall (d : preDTA) (a a' : ad) (l : term_list) (n : nat),
 rec_term d a (app a' l) (S n) = true ->
 exists s : state, MapGet state d a = Some s.

Lemma semantic_equiv_0_4 :
 forall (d : preDTA) (a a' : ad) (l : term_list) (n : nat) (s : state),
 MapGet state d a = Some s ->
 rec_term d a (app a' l) (S n) = true ->
 exists p : prec_list, MapGet prec_list s a' = Some p.

Lemma semantic_equiv_0_5 :
 forall (a : ad) (t : term_list),
 sem_equiv_prop_l t -> sem_equiv_prop_t (app a t).

Lemma semantic_equiv_0_6 :
 forall (n : nat) (t : term) (t0 : term_list),
 (forall (d : preDTA) (a : ad) (m : nat),
  rec_term d a t m = true -> reconnaissance d a t) ->
 (forall (d : preDTA) (p : prec_list) (m : nat),
  rec_list_terms d p t0 m = true -> liste_reconnait d p t0) ->
 forall (d : preDTA) (p : prec_list),
 rec_list_terms d p (tcons t t0) n = true -> liste_reconnait d p (tcons t t0).

Lemma semantic_equiv_0_7 :
 forall t : term,
 sem_equiv_prop_t t ->
 forall t0 : term_list, sem_equiv_prop_l t0 -> sem_equiv_prop_l (tcons t t0).

Lemma semantic_equiv_0 :
 forall (d : preDTA) (a : ad) (t : term) (n : nat),
 rec_term d a t n = true -> reconnaissance d a t.

Definition invar_term (t : term) : Prop :=
  forall (n m : nat) (d : preDTA) (a : ad),
  rec_term d a t n = true -> n <= m -> rec_term d a t m = true.

Definition invar_list (tl : term_list) : Prop :=
  forall (n m : nat) (d : preDTA) (p : prec_list),
  rec_list_terms d p tl n = true -> n <= m -> rec_list_terms d p tl m = true.

Lemma invar_0 : invar_list tnil.

Lemma invar_1_0 :
 forall (d : preDTA) (a c : ad) (t : term_list) (n : nat) 
   (s : state) (p : prec_list),
 MapGet state d a = Some s ->
 MapGet prec_list s c = Some p ->
 rec_list_terms d p t n = true -> rec_term d a (app c t) (S n) = true.

Lemma invar_1_1 :
 forall (d : preDTA) (a c : ad) (t : term_list) (n : nat),
 rec_term d a (app c t) (S n) = true ->
 exists p : prec_list, rec_list_terms d p t n = true.

Lemma invar_1 :
 forall (a : ad) (t : term_list), invar_list t -> invar_term (app a t).

Lemma invar_2_0 :
 forall (d : preDTA) (p : prec_list) (n : nat),
 rec_list_terms d p tnil n = true -> p = prec_empty.

Lemma invar_2_1 :
 forall (d : preDTA) (a : ad) (la ls : prec_list) (hd : term)
   (tl : term_list) (n : nat),
 rec_list_terms d (prec_cons a la ls) (tcons hd tl) (S n) = true ->
 rec_list_terms d ls (tcons hd tl) n = true \/
 rec_term d a hd n = true /\ rec_list_terms d la tl n = true.

Lemma invar_2_2 :
 forall (d : preDTA) (a : ad) (la ls : prec_list) (hd : term)
   (tl : term_list) (n : nat),
 rec_list_terms d ls (tcons hd tl) n = true \/
 rec_term d a hd n = true /\ rec_list_terms d la tl n = true ->
 rec_list_terms d (prec_cons a la ls) (tcons hd tl) (S n) = true.
 
Lemma invar_2 :
 forall t : term,
 invar_term t ->
 forall t0 : term_list, invar_list t0 -> invar_list (tcons t t0).

Lemma invar : forall t : term, invar_term t.

Lemma invarl : forall tl : term_list, invar_list tl.

Definition dta_reconnait (d : preDTA) (a : ad) (t : term)
  (pr : reconnaissance d a t) := rec_term d a t (essence t d) = true.

Definition st_reconnait (d : preDTA) (s : state) (t : term)
  (pr : state_reconnait d s t) :=
  match t with
  | app c l =>
      exists p : prec_list,
        MapGet prec_list s c = Some p /\
        rec_list_terms d p l (essence_list l d p) = true
  end.

Definition pre_reconnait (d : preDTA) (p : prec_list) 
  (t : term_list) (pr : liste_reconnait d p t) :=
  rec_list_terms d p t (essence_list t d p) = true.

Lemma semantic_equiv_1_0 :
 forall (d : preDTA) (a : ad) (t : term) (ladj : state)
   (e : MapGet state d a = Some ladj) (s : state_reconnait d ladj t),
 st_reconnait d ladj t s -> dta_reconnait d a t (rec_dta d a t ladj e s).

Lemma semantic_equiv_1_1 :
 forall (d : preDTA) (s : state) (c : ad) (tl : term_list) 
   (l : prec_list) (e : MapGet prec_list s c = Some l)
   (l0 : liste_reconnait d l tl),
 pre_reconnait d l tl l0 ->
 st_reconnait d s (app c tl) (rec_st d s c tl l e l0).

Lemma semantic_equiv_1_2 :
 forall d : preDTA, pre_reconnait d prec_empty tnil (rec_empty d).

Lemma semantic_equiv_1_3 :
 forall (d : preDTA) (a : ad) (la ls : prec_list) (hd : term)
   (tl : term_list) (r : reconnaissance d a hd),
 dta_reconnait d a hd r ->
 forall l : liste_reconnait d la tl,
 pre_reconnait d la tl l ->
 pre_reconnait d (prec_cons a la ls) (tcons hd tl)
   (rec_consi d a la ls hd tl r l).

Lemma semantic_equiv_1_4_0 :
 forall (d : preDTA) (a : ad) (la ls : prec_list) (l : term_list) (n : nat),
 l <> tnil ->
 rec_list_terms d ls l n = true ->
 rec_list_terms d (prec_cons a la ls) l (S n) = true.

Lemma semantic_equiv_1_4 :
 forall (d : preDTA) (a : ad) (la ls : prec_list) (hd : term)
   (tl : term_list) (l : liste_reconnait d ls (tcons hd tl)),
 pre_reconnait d ls (tcons hd tl) l ->
 pre_reconnait d (prec_cons a la ls) (tcons hd tl)
   (rec_consn d a la ls hd tl l).

Lemma semantic_equiv_1 :
 forall (d : preDTA) (a : ad) (t : term),
 reconnaissance d a t -> rec_term d a t (essence t d) = true. *)

Definition pl_compat (pl0 pl1 : prec_list) : Prop :=
  pl0 = prec_empty /\ pl1 = prec_empty \/
  pl0 <> prec_empty /\ pl1 <> prec_empty.

Definition mpl_compat (s0 s1 : state) : Prop :=
  forall (c : ad) (p0 p1 : prec_list),
  MapGet prec_list s0 c = Some p0 ->
  MapGet prec_list s1 c = Some p1 -> pl_compat p0 p1.

Definition dta_correct (d : preDTA) : Prop :=
  forall (s0 s1 : state) (a0 a1 : ad),
  MapGet state d a0 = Some s0 ->
  MapGet state d a1 = Some s1 -> mpl_compat s0 s1.

Definition dta_compat (d0 d1 : preDTA) : Prop :=
  forall (s0 s1 : state) (a0 a1 : ad),
  MapGet state d0 a0 = Some s0 ->
  MapGet state d1 a1 = Some s1 -> mpl_compat s0 s1.

Definition DTA_compat (d0 d1 : DTA) : Prop :=
  match d0, d1 with
  | dta p0 a0, dta p1 a1 => dta_compat p0 p1
  end.

Lemma pl_compat_sym :
 forall pl0 pl1 : prec_list, pl_compat pl0 pl1 -> pl_compat pl1 pl0.
Proof.
	unfold pl_compat in |- *. intros. elim H; intros. elim H0. intros. left. 
	split; assumption. elim H0. intros. right. split; assumption.
Qed.

Lemma mpl_compat_0 :
 forall (c : ad) (pl0 pl1 : prec_list),
 mpl_compat (M1 prec_list c pl0) (M1 prec_list c pl1) -> pl_compat pl0 pl1.
Proof.
	intros. unfold mpl_compat in H. apply (H c pl0 pl1). simpl in |- *.
	rewrite (Neqb_correct c). trivial. simpl in |- *. rewrite (Neqb_correct c).
	trivial.
Qed.

Lemma mpl_compat_1 :
 forall s0 s1 s2 s3 : state,
 mpl_compat (M2 prec_list s0 s1) (M2 prec_list s2 s3) -> mpl_compat s0 s2.
Proof.
	intros. unfold mpl_compat in H. unfold mpl_compat in |- *. intros.
	induction  c as [| p]. apply (H N0 p0 p1). simpl in |- *. assumption. simpl in |- *.
	assumption. apply (H (Npos (xO p)) p0 p1). simpl in |- *. assumption.
	simpl in |- *. assumption.
Qed.

Lemma mpl_compat_2 :
 forall s0 s1 s2 s3 : state,
 mpl_compat (M2 prec_list s0 s1) (M2 prec_list s2 s3) -> mpl_compat s1 s3.
Proof.
	intros. unfold mpl_compat in H. unfold mpl_compat in |- *. intros.
	induction  c as [| p]. apply (H (Npos 1) p0 p1). simpl in |- *. assumption. simpl in |- *.
	assumption. apply (H (Npos (xI p)) p0 p1). simpl in |- *. assumption.
	simpl in |- *. assumption.
Qed.

Lemma mpl_compat_3 :
 forall (s0 s1 : state) (pl : prec_list),
 mpl_compat (M2 prec_list s0 s1) (M1 prec_list N0 pl) ->
 mpl_compat s0 (M1 prec_list N0 pl).
Proof.
	intros. unfold mpl_compat in H. unfold mpl_compat in |- *. intros. unfold MapGet in H1.
	elim (bool_is_true_or_false (Neqb N0 c)); intros. rewrite H2 in H1.
	inversion H1. apply (H N0 p0 p1). simpl in |- *. 
	rewrite <- (Neqb_complete N0 c H2) in H0. assumption. simpl in |- *. rewrite H4.
	trivial. rewrite H2 in H1. inversion H1.
Qed.

Lemma mpl_compat_4 :
 forall (s0 s1 : state) (pl : prec_list),
 mpl_compat (M2 prec_list s0 s1) (M1 prec_list (Npos 1) pl) ->
 mpl_compat s1 (M1 prec_list N0 pl).
Proof.
	intros. unfold mpl_compat in |- *. unfold mpl_compat in H. intros. unfold MapGet in H1.
	elim (bool_is_true_or_false (Neqb N0 c)); intros; rewrite H2 in H1;
  inversion H1. rewrite H4 in H. apply (H (Npos 1) p0 p1). simpl in |- *.
	rewrite <- (Neqb_complete N0 c H2) in H0. assumption. simpl in |- *. trivial.
Qed.

Lemma mpl_compat_5 :
 forall (s0 s1 : state) (pl : prec_list) (p : positive),
 mpl_compat (M2 prec_list s0 s1) (M1 prec_list (Npos (xO p)) pl) ->
 mpl_compat s0 (M1 prec_list (Npos p) pl).
Proof.
	unfold mpl_compat in |- *. intros. unfold MapGet in H1.
	elim (bool_is_true_or_false (Neqb (Npos p) c)); intros; rewrite H2 in H1;
  inversion H1.
	rewrite H4 in H. apply (H (Npos (xO p)) p0 p1). simpl in |- *. 
	rewrite <- (Neqb_complete (Npos p) c H2) in H0. assumption. simpl in |- *. rewrite (aux_Neqb_1_0 p).
	trivial.
Qed.

Lemma mpl_compat_6 :
 forall (s0 s1 : state) (pl : prec_list) (p : positive),
 mpl_compat (M2 prec_list s0 s1) (M1 prec_list (Npos (xI p)) pl) ->
 mpl_compat s1 (M1 prec_list (Npos p) pl).
Proof.
	unfold mpl_compat in |- *. intros. unfold MapGet in H1.
	elim (bool_is_true_or_false (Neqb (Npos p) c)); intros; rewrite H2 in H1;
  inversion H1.
	rewrite H4 in H. apply (H (Npos (xI p)) p0 p1). simpl in |- *. 
	rewrite <- (Neqb_complete (Npos p) c H2) in H0. assumption. simpl in |- *. rewrite (aux_Neqb_1_0 p).
	trivial.
Qed.

Lemma mpl_compat_sym :
 forall s0 s1 : state, mpl_compat s0 s1 -> mpl_compat s1 s0.
Proof.
	unfold mpl_compat in |- *. intros. apply (pl_compat_sym p1 p0). exact (H c p1 p0 H1 H0).
Qed.

Inductive pl_tl_length : prec_list -> nat -> Prop :=
  | pl_tl_O : pl_tl_length prec_empty 0
  | pl_tl_S :
      forall (a : ad) (pl : prec_list) (n : nat),
      pl_tl_length pl n -> pl_tl_length (prec_cons a pl prec_empty) (S n)
  | pl_tl_propag :
      forall (a : ad) (la ls : prec_list) (n : nat),
      pl_tl_length la n ->
      pl_tl_length ls (S n) -> pl_tl_length (prec_cons a la ls) (S n).

Lemma pl_tl_length_pl_compat :
 forall (p0 p1 : prec_list) (n : nat),
 pl_tl_length p0 n -> pl_tl_length p1 n -> pl_compat p0 p1.
Proof.
	intros. inversion H. inversion H0. unfold pl_compat in |- *. left.
	split; reflexivity. rewrite <- H2 in H5. inversion H5. rewrite <- H2 in H6. inversion H6. inversion H0. rewrite <- H5 in H3. inversion H3.
	unfold pl_compat in |- *. right. split; intro; inversion H7. unfold pl_compat in |- *.
	right. split; intro; inversion H8. inversion H0. rewrite <- H6 in H4.
	inversion H4. unfold pl_compat in |- *. right. split; intro; inversion H8.
	unfold pl_compat in |- *. right. split; intro; inversion H9.
Qed.

Definition pl_tl_length_rec_def_0 (n : nat) :=
  forall (d : preDTA) (pl : prec_list) (tl : term_list),
  pl_tl_length pl n -> liste_reconnait d pl tl -> n = lst_length tl.

Definition pl_tl_length_rec_def_1 (d : preDTA) (pl : prec_list)
  (tl : term_list) :=
  forall n : nat,
  pl_tl_length_rec_def_0 n ->
  pl_tl_length pl (S n) -> liste_reconnait d pl tl -> S n = lst_length tl.

Lemma pl_tl_length_rec_0 : pl_tl_length_rec_def_0 0.
Proof.
	unfold pl_tl_length_rec_def_0 in |- *.
	intros. inversion H. rewrite <- H1 in H0. inversion H0. reflexivity.
Qed.

Lemma pl_tl_length_rec_1 :
 forall d : preDTA, pl_tl_length_rec_def_1 d prec_empty tnil.
Proof.
	unfold pl_tl_length_rec_def_1 in |- *. intros. inversion H0.
Qed.

Lemma pl_tl_length_rec_2 :
 forall (d : preDTA) (a : ad) (la ls : prec_list) (hd : term)
   (tl : term_list),
 reconnaissance d a hd ->
 liste_reconnait d la tl ->
 pl_tl_length_rec_def_1 d la tl ->
 pl_tl_length_rec_def_1 d (prec_cons a la ls) (tcons hd tl).
Proof.
	unfold pl_tl_length_rec_def_1 in |- *. intros. simpl in |- *. unfold pl_tl_length_rec_def_0 in H2.
	rewrite (H2 d la tl). reflexivity. inversion H3. exact H6. exact H7. exact H0.
Qed.

Lemma pl_tl_length_rec_3 :
 forall (d : preDTA) (a : ad) (la ls : prec_list) (hd : term)
   (tl : term_list),
 liste_reconnait d ls (tcons hd tl) ->
 pl_tl_length_rec_def_1 d ls (tcons hd tl) ->
 pl_tl_length_rec_def_1 d (prec_cons a la ls) (tcons hd tl).
Proof.
	unfold pl_tl_length_rec_def_1 in |- *. intros. apply (H0 n H1). inversion H2. 
	rewrite <- H7 in H. inversion H. exact H9. exact H.
Qed.

Lemma pl_tl_length_rec_4 :
 forall (p : preDTA) (p0 : prec_list) (t : term_list),
 liste_reconnait p p0 t -> pl_tl_length_rec_def_1 p p0 t.
Proof.
	exact
  (liste_reconnait_ind pl_tl_length_rec_def_1 pl_tl_length_rec_1
     pl_tl_length_rec_2 pl_tl_length_rec_3).
Qed.

Lemma pl_tl_length_rec_5 :
 forall n : nat, pl_tl_length_rec_def_0 n -> pl_tl_length_rec_def_0 (S n).
Proof.
	intros. unfold pl_tl_length_rec_def_0 in |- *. intros. 
	exact (pl_tl_length_rec_4 d pl tl H1 n H H0 H1).
Qed.

Lemma pl_tl_length_rec_6 :
 forall (d : preDTA) (pl : prec_list) (tl : term_list) (n : nat),
 pl_tl_length pl n -> liste_reconnait d pl tl -> n = lst_length tl.
Proof.
	intros. exact
  (nat_ind pl_tl_length_rec_def_0 pl_tl_length_rec_0 pl_tl_length_rec_5 n d
     pl tl H H0).
Qed.

Definition pl_compatible (pl0 pl1 : prec_list) : Prop :=
  exists n : nat, pl_tl_length pl0 n /\ pl_tl_length pl1 n.

Definition st_compatible (s0 s1 : state) : Prop :=
  forall (c : ad) (pl0 pl1 : prec_list),
  MapGet prec_list s0 c = Some pl0 ->
  MapGet prec_list s1 c = Some pl1 -> pl_compatible pl0 pl1.

Definition predta_compatible (d0 d1 : preDTA) : Prop :=
  forall s0 s1 : state,
  state_in_dta d0 s0 -> state_in_dta d1 s1 -> st_compatible s0 s1.

Definition dta_compatible (d0 d1 : DTA) : Prop :=
  match d0, d1 with
  | dta p0 a0, dta p1 a1 => predta_compatible p0 p1
  end.

Lemma pl_compatible_sym :
 forall pl0 pl1 : prec_list, pl_compatible pl0 pl1 -> pl_compatible pl1 pl0.
Proof.
	unfold pl_compatible in |- *. intros. elim H. intros. elim H0. intros. split with x. 
	split; assumption.
Qed.

Lemma pl_compatible_empt_r :
 forall p : prec_list, pl_compatible p prec_empty -> p = prec_empty.
Proof.
	unfold pl_compatible in |- *. intros. elim H. intros. elim H0. intros. inversion H2.
	rewrite <- H4 in H1. inversion H1. reflexivity.
Qed.

Lemma pl_compatible_empt_l :
 forall p : prec_list, pl_compatible prec_empty p -> p = prec_empty.
Proof.
	intros. exact (pl_compatible_empt_r p (pl_compatible_sym prec_empty p H)).
Qed.

Lemma pl_compatible_cons_r :
 forall (p : prec_list) (a : ad) (la ls : prec_list),
 pl_compatible p (prec_cons a la ls) ->
 exists a0 : ad,
   (exists la0 : prec_list,
      (exists ls0 : prec_list, p = prec_cons a0 la0 ls0)).
Proof.
	intros. unfold pl_compatible in H. elim H. intros. elim H0. intros.
	elim (pl_sum p). intro. rewrite H3 in H1. inversion H1. rewrite <- H5 in H2.
	inversion H2. intro. exact H3.
Qed.

Lemma pl_compatible_cons_l :
 forall (p : prec_list) (a : ad) (la ls : prec_list),
 pl_compatible (prec_cons a la ls) p ->
 exists a0 : ad,
   (exists la0 : prec_list,
      (exists ls0 : prec_list, p = prec_cons a0 la0 ls0)).
Proof.
	intros. exact (pl_compatible_cons_r p a la ls (pl_compatible_sym _ _ H)).
Qed.

Lemma pl_compatible_compat :
 forall p0 p1 : prec_list, pl_compatible p0 p1 -> pl_compat p0 p1.
Proof.
	simple induction p0. intros. elim (pl_compatible_cons_l _ _ _ _ H1).
	intros. elim H2. intros. elim H3. intros. elim H4. intros.
	rewrite H4. unfold pl_compat in |- *. right. split; intro; inversion H5.
	intros. elim (pl_compatible_empt_l _ H). unfold pl_compat in |- *. induction  p1 as [a p1_1 Hrecp1_1 p1_0 Hrecp1_0| ].
	right. split; intro; inversion H0. left. split; reflexivity.
Qed.

Definition st_compatible_compat_def (s0 : state) : Prop :=
  forall s1 : state, st_compatible s0 s1 -> mpl_compat s0 s1.

Lemma st_compatible_compat_0 : st_compatible_compat_def (M0 prec_list).
Proof.
	unfold st_compatible_compat_def in |- *. intros. unfold mpl_compat in |- *.
	intros. inversion H0.
Qed.

Lemma st_compatible_compat_1 :
 forall (a : ad) (a0 : prec_list),
 st_compatible_compat_def (M1 prec_list a a0).
Proof.
	unfold st_compatible_compat_def in |- *. intros. unfold mpl_compat in |- *.
	intros. induction  s1 as [| a1 a2| s1_1 Hrecs1_1 s1_0 Hrecs1_0]. inversion H1. unfold st_compatible in |- *.
	unfold st_compatible in H. exact (pl_compatible_compat _ _ (H _ _ _ H0 H1)). unfold st_compatible in H. exact (pl_compatible_compat _ _ (H _ _ _ H0 H1)).
Qed.

Lemma st_compatible_compat_2 :
 forall m : Map prec_list,
 st_compatible_compat_def m ->
 forall m0 : Map prec_list,
 st_compatible_compat_def m0 -> st_compatible_compat_def (M2 prec_list m m0).
Proof.
	unfold st_compatible_compat_def in |- *. unfold mpl_compat in |- *. intros.
	induction  s1 as [| a a0| s1_1 Hrecs1_1 s1_0 Hrecs1_0]. inversion H3. induction  a as [| p]. induction  c as [| p].
	simpl in H2. apply (H (M1 prec_list N0 a0)) with (c := N0) (p0 := p0) (p1 := p1). unfold st_compatible in |- *. intros. unfold st_compatible in H1. apply (H1 N0 pl0 pl1). simpl in |- *.
	induction  c as [| p]. exact H4. inversion H5. simpl in |- *. induction  c as [| p].
	simpl in H5. exact H5. inversion H5. exact H2. exact H3.
	inversion H3. induction  c as [| p2]. inversion H3. simpl in H3. elim (bool_is_true_or_false (Peqb p p2)); intro; rewrite H4 in H3;
  inversion H3. induction  p2 as [p2 Hrecp2| p2 Hrecp2| ]. simpl in H2. apply
  (H0 (M1 prec_list (Npos p2) p1)) with (c := Npos p2) (p0 := p0) (p3 := p1).
	unfold st_compatible in H1. unfold st_compatible in |- *. intros.
	simpl in H7. rewrite (aux_Neqb_1_1 _ _ H4) in H1. apply (H1 (Npos (xI p2)) pl0 pl1). simpl in |- *. elim (Ndiscr c); intro y.
	elim y. intros x y0. rewrite y0 in H7. elim (bool_is_true_or_false (Peqb p2 x)); intro; rewrite H8 in H7. rewrite <- (aux_Neqb_1_1 _ _ H8) in y0. rewrite y0 in H5. exact H5.
	inversion H7. rewrite y in H7. inversion H7. simpl in |- *. rewrite (aux_Neqb_1_0 p2). inversion H3. induction  c as [| p3]. inversion H7.
	elim (bool_is_true_or_false (Peqb p2 p3)); intro; rewrite H8 in H7. exact H7. inversion H7. exact H2. simpl in |- *.
	rewrite (aux_Neqb_1_0 p2). reflexivity. apply
  (H (M1 prec_list (Npos p2) a0)) with (c := Npos p2) (p0 := p0) (p1 := p1).
	unfold st_compatible in |- *. unfold st_compatible in H1. intros.
	apply (H1 (Npos (xO p2)) pl0 pl1). simpl in |- *. simpl in H2.
	induction  c as [| p3]; simpl in H7. inversion H7. elim (bool_is_true_or_false (Peqb p2 p3)); intro; rewrite H8 in H7. rewrite <- (aux_Neqb_1_1 _ _ H8) in H5.
	exact H5. inversion H7. rewrite (aux_Neqb_1_1 _ _ H4).
	simpl in |- *. rewrite (aux_Neqb_1_0 p2). simpl in H7. induction  c as [| p3]. inversion H7. elim (bool_is_true_or_false (Peqb p2 p3)); intro; rewrite H8 in H7. inversion H7. reflexivity.
	inversion H7. simpl in H2. exact H2. simpl in |- *. rewrite (aux_Neqb_1_0 p2). exact H3. apply (H0 (M1 prec_list N0 a0)) with (c := N0) (p0 := p0) (p1 := p1). unfold st_compatible in |- *.
	unfold st_compatible in H1. intros. induction  c as [| p2]. apply (H1 (Npos 1) pl0 pl1). simpl in |- *. simpl in H2. exact H5. simpl in |- *.
	rewrite (aux_Neqb_1_1 _ _ H4). simpl in H7. exact H7.
	inversion H7. simpl in H2. exact H2. simpl in |- *. exact H3.
	cut (st_compatible m s1_1). cut (st_compatible m0 s1_0).
	intros. induction  c as [| p]; simpl in H2; simpl in H3. exact (H _ H5 _ _ _ H2 H3). induction  p as [p Hrecp| p Hrecp| ]. exact (H0 _ H4 _ _ _ H2 H3).
	exact (H _ H5 _ _ _ H2 H3). exact (H0 _ H4 _ _ _ H2 H3).
	unfold st_compatible in |- *. unfold st_compatible in H1. intros.
	apply (H1 (Ndouble_plus_one c0) pl0 pl1). induction  c0 as [| p]; simpl in |- *; exact H4. induction  c0 as [| p]; simpl in |- *; exact H5. unfold st_compatible in |- *. unfold st_compatible in H1. intros.
	apply (H1 (Ndouble c0) pl0 pl1). induction  c0 as [| p]; simpl in |- *; assumption. induction  c0 as [| p]; simpl in |- *; assumption.
Qed.

Lemma st_compatible_compat :
 forall s0 s1 : state, st_compatible s0 s1 -> mpl_compat s0 s1.
Proof.
	exact
  (Map_ind prec_list st_compatible_compat_def st_compatible_compat_0
     st_compatible_compat_1 st_compatible_compat_2).
Qed.

Definition predta_compatible_compat_def (d0 : preDTA) : Prop :=
  forall d1 : preDTA, predta_compatible d0 d1 -> dta_compat d0 d1.

Lemma predta_compatible_compat_0 : predta_compatible_compat_def (M0 state).
Proof.
	unfold predta_compatible_compat_def in |- *. intros. unfold dta_compat in |- *.
	intros. inversion H0.
Qed.

Lemma predta_compatible_compat_1 :
 forall (a : ad) (a0 : state), predta_compatible_compat_def (M1 state a a0).
Proof.
	unfold predta_compatible_compat_def in |- *. intros. unfold dta_compat in |- *.
	unfold predta_compatible in H. intros. induction  d1 as [| a3 a4| d1_1 Hrecd1_1 d1_0 Hrecd1_0].
	inversion H1. apply (st_compatible_compat s0 s1). apply (H s0 s1). split with a1. assumption. split with a2. assumption.
	apply (st_compatible_compat s0 s1). apply (H s0 s1). split with a1. exact H0. split with a2. exact H1.
Qed.

Lemma predta_compatible_compat_2 :
 forall m : Map state,
 predta_compatible_compat_def m ->
 forall m0 : Map state,
 predta_compatible_compat_def m0 ->
 predta_compatible_compat_def (M2 state m m0).
Proof.
	unfold predta_compatible_compat_def in |- *. unfold dta_compat in |- *.
	unfold predta_compatible in |- *. intros. cut (predta_compatible m d1).
	cut (predta_compatible m0 d1). unfold predta_compatible in |- *.
	intros. induction  a0 as [| p]. apply (H d1) with (s0 := s0) (s1 := s1) (a0 := N0) (a1 := a1). intros. exact (H5 _ _ H6 H7). simpl in H2. assumption. exact H3. induction  p as [p Hrecp| p Hrecp| ]. apply (H0 d1) with (s0 := s0) (s1 := s1) (a0 := Npos p) (a1 := a1). intros. exact (H4 _ _ H6 H7). simpl in H2. exact H2. exact H3. apply (H d1) with (s0 := s0) (s1 := s1) (a0 := Npos p) (a1 := a1). intros. exact (H5 _ _ H6 H7). simpl in H2. exact H2. exact H3. apply (H0 d1) with (s0 := s0) (s1 := s1) (a0 := N0) (a1 := a1). exact H4. simpl in H2.
	exact H2. exact H3. unfold predta_compatible in |- *. intros.
	apply (H1 s2 s3). elim H4. intros. split with (Ndouble_plus_one x). induction  x as [| p]; simpl in |- *; exact H6.
	exact H5. unfold predta_compatible in |- *. intros. apply (H1 s2 s3). elim H4. intros. split with (Ndouble x); intros.
	induction  x as [| p]; simpl in |- *; exact H6. exact H5.
Qed.

Lemma predta_compatible_compat :
 forall d0 d1 : preDTA, predta_compatible d0 d1 -> dta_compat d0 d1.
Proof.
	exact
  (Map_ind state predta_compatible_compat_def predta_compatible_compat_0
     predta_compatible_compat_1 predta_compatible_compat_2).
Qed.

Lemma dta_compatible_compat :
 forall d0 d1 : DTA, dta_compatible d0 d1 -> DTA_compat d0 d1.
Proof.
	simple induction d0. simple induction d1. simpl in |- *. exact (fun (p0 : preDTA) (a : ad) => predta_compatible_compat p p0).
Qed.

Definition signature : Set := Map nat.

Definition state_correct_wrt_sign (s : state) (sigma : signature) : Prop :=
  forall (a : ad) (p : prec_list),
  MapGet prec_list s a = Some p ->
  exists n : nat, MapGet nat sigma a = Some n /\ pl_tl_length p n.

Definition predta_correct_wrt_sign (d : preDTA) (sigma : signature) : Prop :=
  forall (a : ad) (s : state),
  MapGet state d a = Some s -> state_correct_wrt_sign s sigma.

Definition dta_correct_wrt_sign (d : DTA) (sigma : signature) : Prop :=
  match d with
  | dta d a => predta_correct_wrt_sign d sigma
  end.

Lemma states_correct_wrt_sign_compatibles :
 forall (sigma : signature) (s s' : state),
 state_correct_wrt_sign s sigma ->
 state_correct_wrt_sign s' sigma -> st_compatible s s'.
Proof.
	unfold st_compatible in |- *. intros. unfold state_correct_wrt_sign in H. unfold state_correct_wrt_sign in H0. elim (H _ _ H1).
	elim (H0 _ _ H2). intros. elim H3. elim H4. intros. rewrite H7 in H5. inversion H5. unfold pl_compatible in |- *. split with x.
	split. rewrite H10. exact H6. exact H8.
Qed.

Lemma predtas_correct_wrt_sign_compatibles :
 forall (sigma : signature) (d d' : preDTA),
 predta_correct_wrt_sign d sigma ->
 predta_correct_wrt_sign d' sigma -> predta_compatible d d'.
Proof.
	unfold predta_compatible in |- *. unfold predta_correct_wrt_sign in |- *.
	intros. elim H1. elim H2. intros. exact
  (states_correct_wrt_sign_compatibles sigma s0 s1 (H _ _ H4) (H0 _ _ H3)).
Qed.

Lemma dtas_correct_wrt_sign_compatibles :
 forall (sigma : signature) (d d' : DTA),
 dta_correct_wrt_sign d sigma ->
 dta_correct_wrt_sign d' sigma -> dta_compatible d d'.
Proof.
	unfold dta_correct_wrt_sign in |- *. unfold dta_compatible in |- *.
	intros. induction  d as (p, a). induction  d' as (p0, a0). exact (predtas_correct_wrt_sign_compatibles _ _ _ H H0).
Qed.

Fixpoint pl_compat_check (p : prec_list) : option nat :=
  match p with
  | prec_empty => Some 0
  | prec_cons a la ls =>
      match ls with
      | prec_empty =>
          match pl_compat_check la with
          | None => None
          | Some n => Some (S n)
          end
      | prec_cons _ _ _ =>
          match pl_compat_check la, pl_compat_check ls with
          | None, _ => None
          | _, None => None
          | Some n, Some m =>
              if beq_nat (S n) m then Some m else None
          end
      end
  end.

Lemma pl_compat_check_correct :
 forall (p : prec_list) (n : nat),
 pl_tl_length p n -> pl_compat_check p = Some n.
Proof.
	simple induction p. intros. inversion H1. simpl in |- *. rewrite (H _ H6).
	reflexivity. simpl in |- *. elim (pl_sum p1); intros. rewrite H8 in H7. inversion H7. elim H8. intros. elim H9. intros. elim H10.
	intros. rewrite H11. rewrite <- H11. rewrite (H _ H6).
	rewrite (H0 _ H7). rewrite (beq_nat_correct n0). reflexivity.
	intros. inversion H. reflexivity.
Qed.

Lemma pl_compat_check_complete :
 forall (p : prec_list) (n : nat),
 pl_compat_check p = Some n -> pl_tl_length p n.
Proof.
	simple induction p. intros. simpl in H1. elim (pl_sum p1). intros.
	rewrite H2 in H1. elim (option_sum nat (pl_compat_check p0)).
	intro y. elim y. intros x y0. rewrite y0 in H1. inversion H1.
	rewrite H2. exact (pl_tl_S a p0 x (H _ y0)). intro y. rewrite y in H1. inversion H1. intros. elim H2. intros. elim H3. intros.
	elim H4. intros. rewrite H5 in H1. rewrite <- H5 in H1. elim (option_sum nat (pl_compat_check p0)). intro y. elim y. intros x2 y0.
	rewrite y0 in H1. elim (option_sum nat (pl_compat_check p1)).
	intro y1. elim y1. intros x3 y2. rewrite y2 in H1. elim (nat_sum x3).
	intros. rewrite H6 in H1. inversion H1. intros. elim H6. intros.
	rewrite H7 in H1. elim (bool_is_true_or_false (beq_nat x2 x4)); intro H8; rewrite H8 in H1. inversion H1. rewrite (beq_nat_complete _ _ H8) in y0. rewrite H7 in y2. exact (pl_tl_propag _ _ _ _ (H _ y0) (H0 _ y2)). inversion H1. intro y1. rewrite y1 in H1.
	inversion H1. intro y. rewrite y in H1. elim (option_sum nat (pl_compat_check p1)). intros y0. elim y0. intros x2 y1. 
        inversion H1. inversion H1. intros. simpl in H. inversion H. 
        exact pl_tl_O.
Qed.

Inductive pre_ad : Set :=
  | pre_ad_empty : pre_ad
  | pre_ad_O : pre_ad -> pre_ad
  | pre_ad_I : pre_ad -> pre_ad.

Fixpoint pre_ad_concat (pa : pre_ad) : ad -> ad :=
  fun a : ad =>
  match pa with
  | pre_ad_empty => a
  | pre_ad_O pa' => pre_ad_concat pa' (Ndouble a)
  | pre_ad_I pa' => pre_ad_concat pa' (Ndouble_plus_one a)
  end.

Fixpoint st_compat_check_0 (pa : pre_ad) (sigma : signature) 
 (s : state) {struct s} : bool :=
  match s with
  | M0 => true
  | M1 a p =>
      match pl_compat_check p, MapGet nat sigma (pre_ad_concat pa a) with
      | None, _ => false
      | _, None => false
      | Some n, Some m => beq_nat n m
      end
  | M2 x y =>
      st_compat_check_0 (pre_ad_O pa) sigma x &&
      st_compat_check_0 (pre_ad_I pa) sigma y
  end.

Definition st_compat_check (s : state) (sigma : signature) : bool :=
  st_compat_check_0 pre_ad_empty sigma s.

Fixpoint predta_compat_check (d : preDTA) : signature -> bool :=
  fun sigma : signature =>
  match d with
  | M0 => true
  | M1 a s => st_compat_check s sigma
  | M2 x y => predta_compat_check x sigma && predta_compat_check y sigma
  end.

Definition dta_compat_check (d : DTA) (sigma : signature) : bool :=
  match d with
  | dta p a => predta_compat_check p sigma
  end.

Definition state_correct_wrt_sign_with_offset (s : state) 
  (sigma : signature) (pa : pre_ad) : Prop :=
  forall (a : ad) (p : prec_list),
  MapGet prec_list s a = Some p ->
  exists n : nat,
    MapGet nat sigma (pre_ad_concat pa a) = Some n /\ pl_tl_length p n.

Lemma state_correct_wrt_sign_with_offset_M2 :
 forall (s0 s1 : state) (sigma : signature) (pa : pre_ad),
 state_correct_wrt_sign_with_offset (M2 prec_list s0 s1) sigma pa ->
 state_correct_wrt_sign_with_offset s0 sigma (pre_ad_O pa) /\
 state_correct_wrt_sign_with_offset s1 sigma (pre_ad_I pa).
Proof.
	unfold state_correct_wrt_sign_with_offset in |- *. intros. split.
	intros. elim (H (Ndouble a) p). intros. split with x.
	induction  a as [| p0]; simpl in |- *; simpl in H1; exact H1. induction  a as [| p0]; simpl in |- *; exact H0. intros. elim (H (Ndouble_plus_one a) p).
	intros. split with x. induction  a as [| p0]; simpl in |- *; simpl in H1; exact H1. induction  a as [| p0]; simpl in |- *; exact H0.
Qed.

Lemma predta_correct_wrt_sign_M2 :
 forall (d0 d1 : preDTA) (sigma : signature),
 predta_correct_wrt_sign (M2 state d0 d1) sigma ->
 predta_correct_wrt_sign d0 sigma /\ predta_correct_wrt_sign d1 sigma.
Proof.
	unfold predta_correct_wrt_sign in |- *. intros. split. intros.
	apply (H (Ndouble a) s). induction  a as [| p]; simpl in |- *; exact H0.
	intros. apply (H (Ndouble_plus_one a) s). induction  a as [| p]; simpl in |- *; exact H0.
Qed.

Lemma st_compat_check_0_correct :
 forall (s : state) (sigma : signature) (pa : pre_ad),
 state_correct_wrt_sign_with_offset s sigma pa ->
 st_compat_check_0 pa sigma s = true.
Proof.
	unfold state_correct_wrt_sign_with_offset in |- *. simple induction s.
	intros. reflexivity. intros. simpl in |- *. elim (H a a0). intros.
	elim H0. intros. rewrite (pl_compat_check_correct _ _ H2).
	rewrite H1. exact (beq_nat_correct x). simpl in |- *. rewrite (Neqb_correct a). reflexivity. intros. simpl in |- *. rewrite (H sigma (pre_ad_O pa)). rewrite (H0 sigma (pre_ad_I pa)).
	reflexivity. intros. elim (H1 (Ndouble_plus_one a) p).
	intros. simpl in |- *. split with x. exact H3. induction  a as [| p0]; simpl in |- *; exact H2. intros. elim (H1 (Ndouble a) p). intros. simpl in |- *.
	split with x. exact H3. induction  a as [| p0]; simpl in |- *; exact H2.
Qed.

Lemma st_compat_check_0_complete :
 forall (s : state) (sigma : signature) (pa : pre_ad),
 st_compat_check_0 pa sigma s = true ->
 state_correct_wrt_sign_with_offset s sigma pa.
Proof.
	unfold state_correct_wrt_sign_with_offset in |- *. simple induction s.
	intros. inversion H0. intros. simpl in H. elim (option_sum nat (pl_compat_check a0)); intro y. elim y. intros x y0. rewrite y0 in H. elim (option_sum nat (MapGet nat sigma (pre_ad_concat pa a))); intro y1. elim y1. intros x0 y2. rewrite y2 in H. simpl in H0.
	elim (bool_is_true_or_false (Neqb a a1)); intro; rewrite H1 in H0. inversion H0. split with x. rewrite (beq_nat_complete _ _ H). split. rewrite (Neqb_complete _ _ H1) in y2. exact y2.
	rewrite (beq_nat_complete _ _ H) in y0. rewrite H3 in y0.
	exact (pl_compat_check_complete p x0 y0). inversion H0.
	rewrite y1 in H. inversion H. rewrite y in H. elim (option_sum nat (MapGet nat sigma (pre_ad_concat pa a))); intro y0. elim y0.
	intros x y1. inversion H. 
	inversion H. intros. simpl in H1. elim (bool_is_true_or_false (st_compat_check_0 (pre_ad_O pa) sigma m));
  intro; rewrite H3 in H1. elim (bool_is_true_or_false (st_compat_check_0 (pre_ad_I pa) sigma m0));
  intros; rewrite H4 in H1. induction  a as [| p0]. simpl in H2. elim (H sigma (pre_ad_O pa) H3 N0 p H2). intros. split with x. simpl in H5. exact H5. induction  p0 as [p0 Hrecp0| p0 Hrecp0| ]. simpl in H2.
	elim (H0 sigma (pre_ad_I pa) H4 (Npos p0) p H2). intros.
	split with x. simpl in H5. exact H5. simpl in H2. elim (H sigma (pre_ad_O pa) H3 (Npos p0) p H2). intros. split with x. 
	simpl in H5. exact H5. simpl in H2. elim (H0 sigma (pre_ad_I pa) H4 N0 p H2). intros. split with x. simpl in H5. exact H5.
	inversion H1. inversion H1.
Qed.

Lemma st_compat_check_correct :
 forall (s : state) (sigma : signature),
 state_correct_wrt_sign s sigma -> st_compat_check s sigma = true.
Proof.
	intros. unfold st_compat_check in |- *. apply (st_compat_check_0_correct s sigma pre_ad_empty). unfold state_correct_wrt_sign_with_offset in |- *.
	simpl in |- *. exact H.
Qed.

Lemma st_compat_check_complete :
 forall (s : state) (sigma : signature),
 st_compat_check s sigma = true -> state_correct_wrt_sign s sigma.
Proof.
	intros. unfold state_correct_wrt_sign in |- *. intros. cut (state_correct_wrt_sign_with_offset s sigma pre_ad_empty).
	intro. unfold state_correct_wrt_sign_with_offset in H1.
	elim (H1 a p H0). intros. split with x. simpl in H2.
	exact H2. apply (st_compat_check_0_complete s sigma pre_ad_empty). unfold st_compat_check in H. exact H.
Qed.

Lemma predta_compat_check_correct :
 forall (d : preDTA) (sigma : signature),
 predta_correct_wrt_sign d sigma -> predta_compat_check d sigma = true.
Proof.
	simple induction d. intros. reflexivity. intros. simpl in |- *. unfold predta_correct_wrt_sign in H. apply (st_compat_check_correct a0 sigma). apply (H a a0). simpl in |- *.  rewrite (Neqb_correct a).
	reflexivity. intros. simpl in |- *. rewrite (H sigma). rewrite (H0 sigma). reflexivity. unfold predta_correct_wrt_sign in |- *. unfold predta_correct_wrt_sign in H1. intros. apply (H1 (Ndouble_plus_one a) s). induction  a as [| p]; simpl in |- *; exact H2.
	unfold predta_correct_wrt_sign in H1. unfold predta_correct_wrt_sign in |- *.
	intros. apply (H1 (Ndouble a) s). induction  a as [| p]; simpl in |- *; exact H2.
Qed.

Lemma predta_compat_check_complete :
 forall (d : preDTA) (sigma : signature),
 predta_compat_check d sigma = true -> predta_correct_wrt_sign d sigma.
Proof.
	simple induction d. intros. unfold predta_correct_wrt_sign in |- *. intros.
	inversion H0. intros. simpl in H. unfold predta_correct_wrt_sign in |- *.
	intros. simpl in H0. elim (bool_is_true_or_false (Neqb a a1)); intros. rewrite H1 in H0. inversion H0. rewrite H3 in H. exact (st_compat_check_complete s sigma H). rewrite H1 in H0. inversion H0. intros. unfold predta_correct_wrt_sign in |- *. simpl in H1. elim (bool_is_true_or_false (predta_compat_check m sigma)); intros;
  rewrite H2 in H1. elim (bool_is_true_or_false (predta_compat_check m0 sigma)); intros;
  rewrite H4 in H1. unfold predta_correct_wrt_sign in H. unfold predta_correct_wrt_sign in H0. induction  a as [| p]. simpl in H3.
	exact (H sigma H2 _ _ H3). induction  p as [p Hrecp| p Hrecp| ]; simpl in H3. exact (H0 _ H4 _ _ H3). exact (H _ H2 _ _ H3). exact (H0 _ H4 _ _ H3).
	inversion H1. inversion H1.
Qed.

Lemma dta_compat_check_correct :
 forall (d : DTA) (sigma : signature),
 dta_correct_wrt_sign d sigma -> dta_compat_check d sigma = true.
Proof.
	simple induction d. intro. intro. exact (predta_compat_check_correct p).
Qed.

Lemma dta_compat_check_complete :
 forall (d : DTA) (sigma : signature),
 dta_compat_check d sigma = true -> dta_correct_wrt_sign d sigma.
Proof.
	simple induction d. intro. intro. exact (predta_compat_check_complete p).
Qed.