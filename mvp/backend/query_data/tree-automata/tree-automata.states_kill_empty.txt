
Require Import ZArith.
Require Import NArith Ndec.
From IntMap Require Import Allmaps.
Require Import bases.
(* bases:
Require Import Bool.
Require Import Arith.
Require Import ZArith.
Require Import NArith.
Require Import Ndec.
From IntMap Require Import Allmaps.
Require Import EqNat.
Require Export Max.

Lemma nat_sum : forall n : nat, n = 0 \/ (exists m : nat, n = S m).

Lemma le_n_n : forall n : nat, n <= n.

Lemma le_l_or_r : forall n m : nat, n <= m \/ m <= n.

Lemma plus_n_O : forall n : nat, n + 0 = n.
 
 Lemma S_plus_l : forall n m : nat, S (n + m) = S n + m.
 
 Lemma S_plus_r : forall n m : nat, S (n + m) = n + S m.

Lemma max_le_Sr_0 :
 forall n m : nat, max n m <= max n (S m) /\ max (S n) m <= max (S n) (S m).

Lemma max_le_Sr : forall n m : nat, max n m <= max n (S m).

Lemma plus_O_r : forall n : nat, n + 0 = n.

Lemma plus_O_l : forall n : nat, n + 0 = n.

Lemma le_mult_lS : forall n m : nat, n * m <= S n * m.

Lemma le_mult_rS : forall n m : nat, n * m <= n * S m.

Lemma le_disj : forall n m : nat, n <= m -> n = m \/ S n <= m.

Lemma le_mult_l : forall n m p : nat, n <= m -> n * p <= m * p.

Lemma le_mult_r : forall n m p : nat, n <= m -> p * n <= p * m.

Lemma le_mult_mult : forall n m p q : nat, n <= m -> p <= q -> n * p <= m * q.

Lemma Sn_eq_Sm_n_eq_m : forall n m : nat, S n = S m -> n = m.

Lemma bool_dec_eq : forall a b : bool, {a = b} + {a <> b}.

Lemma bool_is_false_or_true : forall a : bool, a = false \/ a = true.

Lemma bool_is_true_or_false : forall a : bool, a = true \/ a = false.

Lemma in_M0_false :
 forall (A : Set) (a : A), ~ (exists e : ad, MapGet A (M0 A) e = Some a).

Lemma in_M1_id :
 forall (A : Set) (a : A) (x : ad) (e : A),
 (exists c : ad, MapGet A (M1 A x e) c = Some a) -> a = e.

Lemma in_M2_disj :
 forall (A : Set) (a : A) (m0 m1 : Map A),
 (exists c : ad, MapGet A (M2 A m0 m1) c = Some a) ->
 (exists c : ad, MapGet A m0 c = Some a) \/
 (exists c : ad, MapGet A m1 c = Some a).

Lemma aux_Neqb_1_0 : forall p : positive, Peqb p p = true.

Lemma aux_Neqb_1_1 : forall p p0 : positive, Peqb p p0 = true -> p = p0.

Lemma aux_Neqb_trans :
 forall a b c : ad, Neqb a b = true -> Neqb b c = true -> Neqb a c = true.

Lemma indprinciple_nat_gen :
 forall P : nat -> Prop,
 (forall n : nat, (forall m : nat, m < n -> P m) -> P n) ->
 forall n m : nat, m <= n -> P m.

Lemma beq_nat_complete : forall n m : nat, beq_nat n m = true -> n = m.

Lemma beq_nat_correct : forall n : nat, beq_nat n n = true. *)
Require Import defs.
(* defs:
Require Import Bool.
Require Import Arith.
Require Import ZArith.
From IntMap Require Import Allmaps.
Require Import EqNat.
Require Import bases.

Inductive term : Set :=
    app : ad -> term_list -> term
with term_list : Set :=
  | tnil : term_list
  | tcons : term -> term_list -> term_list.

Scheme term_term_list_rec := Induction for term
  Sort Set
  with term_list_term_rec := Induction for term_list 
  Sort Set.

Scheme term_term_list_ind := Induction for term
  Sort Prop
  with term_list_term_ind := Induction for term_list 
  Sort Prop.

Lemma term_list_disj :
 forall l : term_list,
 l = tnil \/ (exists hd : term, (exists tl : term_list, l = tcons hd tl)).

Fixpoint lst_length (l : term_list) : nat :=
  match l with
  | tnil => 0
  | tcons _ l' => S (lst_length l')
  end.

Fixpoint term_high (t : term) : nat :=
  match t with
  | app a l => S (term_high_0 l)
  end
 
 with term_high_0 (l : term_list) : nat :=
  match l with
  | tnil => 0
  | tcons hd tl => max (term_high hd) (term_high_0 tl)
  end.

Lemma high_aux_0 :
 forall (a : ad) (l : term_list), S (term_high_0 l) <= term_high (app a l).

Lemma high_aux_1 :
 forall (a : ad) (l : term_list), S (term_high_0 l) = term_high (app a l).

Lemma high_aux_2 : forall (l : term_list) (c : ad), 1 <= term_high (app c l).

Lemma high_aux_3 :
 forall (t : term) (tl : term_list), term_high t <= term_high_0 (tcons t tl).

Lemma high_aux_4 :
 forall (t : term) (tl : term_list),
 term_high_0 tl <= term_high_0 (tcons t tl).

Fixpoint taille_term (t : term) : nat :=
  match t with
  | app c l => S (mtaille_term_list l)
  end
 
 with mtaille_term_list (l : term_list) : nat :=
  match l with
  | tnil => 0
  | tcons hd tl => max (taille_term hd) (mtaille_term_list tl)
  end.

Inductive prec_list : Set :=
  | prec_cons : ad -> prec_list -> prec_list -> prec_list
  | prec_empty : prec_list.

Lemma pl_sum :
 forall pl : prec_list,
 pl = prec_empty \/
 (exists a : ad,
    (exists la : prec_list, (exists ls : prec_list, pl = prec_cons a la ls))).

Definition state := Map prec_list.

Definition preDTA := Map state.

Inductive DTA : Set :=
    dta : preDTA -> ad -> DTA.

Fixpoint taille_0 (l : prec_list) : nat :=
  match l with
  | prec_empty => 0
  | prec_cons x y z => S (taille_0 y + taille_0 z)
  end.

Fixpoint taille_1 (s : state) : nat :=
  match s with
  | M0 => 0
  | M1 x y => taille_0 y
  | M2 x y => max (taille_1 x) (taille_1 y)
  end.

Fixpoint DTA_taille (d : preDTA) : nat :=
  match d with
  | M0 => 0
  | M1 x y => taille_1 y
  | M2 x y => max (DTA_taille x) (DTA_taille y)
  end.

Lemma taille_aux_0 :
 forall (a : ad) (la ls : prec_list),
 S (taille_0 la) <= taille_0 (prec_cons a la ls).

Lemma taille_aux_1 :
 forall (a : ad) (la ls : prec_list), 1 <= taille_0 (prec_cons a la ls).

Lemma taille_aux_2 :
 forall (a : ad) (la ls : prec_list),
 S (taille_0 ls) <= taille_0 (prec_cons a la ls).

Inductive prec_occur : prec_list -> ad -> Prop :=
  | prec_hd :
      forall (a : ad) (pl0 pl1 : prec_list),
      prec_occur (prec_cons a pl0 pl1) a
  | prec_int0 :
      forall (a b : ad) (pl0 pl1 : prec_list),
      prec_occur pl0 b -> prec_occur (prec_cons a pl0 pl1) b
  | prec_int1 :
      forall (a b : ad) (pl0 pl1 : prec_list),
      prec_occur pl1 b -> prec_occur (prec_cons a pl0 pl1) b.

Inductive prec_contained : prec_list -> prec_list -> Prop :=
  | prec_id : forall p : prec_list, prec_contained p p
  | prec_c_int0 :
      forall (p p0 p1 : prec_list) (a : ad),
      prec_contained p p0 -> prec_contained p (prec_cons a p0 p1)
  | prec_c_int1 :
      forall (p p0 p1 : prec_list) (a : ad),
      prec_contained p p1 -> prec_contained p (prec_cons a p0 p1).

Definition state_in_dta (d : preDTA) (s : state) : Prop :=
  exists a : ad, MapGet state d a = Some s.

Definition state_in_dta_diff (d : preDTA) (s : state) 
  (a : ad) : Prop := exists b : ad, MapGet state d b = Some s /\ a <> b.

Definition prec_in_dta (d : preDTA) (p : prec_list) : Prop :=
  exists s : state,
    (exists a : ad,
       (exists c : ad,
          MapGet state d a = Some s /\
          MapGet prec_list s c = Some p)).

Definition prec_in_dta_cont (d : preDTA) (p : prec_list) : Prop :=
  exists s : state,
    (exists b : ad,
       (exists c : ad,
          (exists p0 : prec_list,
             MapGet state d b = Some s /\
             MapGet prec_list s c = Some p0 /\ prec_contained p p0))).

Definition prec_in_dta_diff (d : preDTA) (p : prec_list) 
  (a : ad) : Prop :=
  exists s : state,
    (exists b : ad,
       (exists c : ad,
          MapGet state d b = Some s /\
          MapGet prec_list s c = Some p /\ a <> b)).

Definition prec_in_dta_diff_cont (d : preDTA) (p : prec_list) 
  (a : ad) : Prop :=
  exists s : state,
    (exists b : ad,
       (exists c : ad,
          (exists p0 : prec_list,
             MapGet state d b = Some s /\
             MapGet prec_list s c = Some p0 /\
             prec_contained p p0 /\ a <> b))).

Definition prec_in_state (s : state) (p : prec_list) : Prop :=
  exists c : ad, MapGet prec_list s c = Some p.

Lemma prec_in_state_M0_false :
 forall p : prec_list, ~ prec_in_state (M0 prec_list) p.

Lemma state_in_dta_M0_false : forall s : state, ~ state_in_dta (M0 state) s.

Lemma prec_occur_1 :
 forall (a : ad) (p0 p1 p2 : prec_list),
 prec_contained (prec_cons a p0 p1) p2 -> prec_occur p2 a.

Lemma prec_contained_0 :
 forall (a : ad) (p0 p1 p2 : prec_list),
 prec_contained (prec_cons a p0 p1) p2 -> prec_contained p0 p2.

Lemma prec_contained_1 :
 forall (a : ad) (p0 p1 p2 : prec_list),
 prec_contained (prec_cons a p0 p1) p2 -> prec_contained p1 p2.

Inductive term_occur : term -> term -> Prop :=
  | to_eq : forall t : term, term_occur t t
  | to_st :
      forall (t : term) (a : ad) (tl : term_list),
      term_list_occur t tl -> term_occur t (app a tl)
with term_list_occur : term -> term_list -> Prop :=
  | tlo_head :
      forall (t hd : term) (tl : term_list),
      term_occur t hd -> term_list_occur t (tcons hd tl)
  | tlo_tail :
      forall (t hd : term) (tl : term_list),
      term_list_occur t tl -> term_list_occur t (tcons hd tl).

Definition term_occur_def_0 (t : term) :=
  forall u : term, term_occur u t -> term_high u <= term_high t.

Definition term_occur_def_1 (t : term_list) :=
  forall u : term, term_list_occur u t -> term_high u <= term_high_0 t.

Lemma term_occur_0_0 :
 forall (a : ad) (t : term_list),
 term_occur_def_1 t -> term_occur_def_0 (app a t).

Lemma term_occur_0_1 : term_occur_def_1 tnil.

Lemma term_occur_0_2 :
 forall t : term,
 term_occur_def_0 t ->
 forall t0 : term_list, term_occur_def_1 t0 -> term_occur_def_1 (tcons t t0).

Lemma term_occur_0 :
 forall t u : term, term_occur u t -> term_high u <= term_high t.

Lemma term_occur_1 :
 forall (t : term_list) (u : term),
 term_list_occur u t -> term_high u <= term_high_0 t.

Definition indprinciple_3_aux (n : nat) :=
  forall P : term -> Prop,
  (forall (a : ad) (tl : term_list),
   (forall u : term, term_list_occur u tl -> P u) -> P (app a tl)) ->
  forall t : term, term_high t <= n -> P t.

Lemma indprinciple_3_0 : indprinciple_3_aux 0.

Lemma indprinciple_3_1 :
 forall n : nat, indprinciple_3_aux n -> indprinciple_3_aux (S n).

Lemma indprinciple_3_2 :
 forall (n : nat) (P : term -> Prop),
 (forall (a : ad) (tl : term_list),
  (forall u : term, term_list_occur u tl -> P u) -> P (app a tl)) ->
 forall t : term, term_high t <= n -> P t.

Lemma indprinciple_term :
 forall P : term -> Prop,
 (forall (a : ad) (tl : term_list),
  (forall u : term, term_list_occur u tl -> P u) -> P (app a tl)) ->
 forall t : term, P t.

Lemma Ndouble_inv_N0 : forall x : ad, Ndouble x = N0 -> x = N0.

Lemma Ndouble_inv_xO :
 forall (x : ad) (p : positive), Ndouble x = Npos (xO p) -> x = Npos p.

Lemma Ndouble_plus_one_inv_xH :
 forall x : ad, Ndouble_plus_one x = Npos 1 -> x = N0.

Lemma Ndouble_plus_one_inv_xI :
 forall (x : ad) (p : positive),
 Ndouble_plus_one x = Npos (xI p) -> x = Npos p. *)
Require Import semantics.
(* semantics:
Require Import Bool.
Require Import Arith.
Require Import Classical_Prop.
From IntMap Require Import Allmaps.
Require Import bases.
Require Import defs.

Unset Standard Proposition Elimination Names.

Fixpoint rec_term (d : preDTA) (a : ad) (t : term) 
 (n : nat) {struct n} : bool :=
  match n with
  | O => false
  | S k =>
      match t with
      | app c l =>
          match MapGet _ d a with
          | None => false
          | Some lts =>
              match MapGet _ lts c with
              | None => false
              | Some pre => rec_list_terms d pre l k
              end
          end
      end
  end
 
 with rec_list_terms (d : preDTA) (pre : prec_list) 
 (l : term_list) (n : nat) {struct n} : bool :=
  match n with
  | O => false
  | S k =>
      match pre with
      | prec_empty => match l with
                      | tnil => true
                      | _ => false
                      end
      | prec_cons st stp pre' =>
          match l with
          | tnil => false
          | tcons hd tl =>
              rec_list_terms d pre' l k
              || rec_term d st hd k && rec_list_terms d stp tl k
          end
      end
  end.

Lemma borne_0_0 :
 forall p : prec_list,
 prec_in_state (M0 prec_list) p -> taille_0 p <= taille_1 (M0 prec_list).

Lemma borne_0_1 :
 forall (a : ad) (p' p : prec_list),
 prec_in_state (M1 prec_list a p') p ->
 taille_0 p <= taille_1 (M1 prec_list a p').

Lemma borne_0_2 :
 forall (m0 m1 : Map prec_list) (p : prec_list),
 (prec_in_state m0 p -> taille_0 p <= taille_1 m0) ->
 (prec_in_state m1 p -> taille_0 p <= taille_1 m1) ->
 prec_in_state (M2 prec_list m0 m1) p ->
 taille_0 p <= taille_1 (M2 prec_list m0 m1).

Lemma borne_0 :
 forall (s : state) (p : prec_list),
 prec_in_state s p -> taille_0 p <= taille_1 s.

Lemma borne_1_0 :
 forall s : state,
 state_in_dta (M0 state) s -> taille_1 s <= DTA_taille (M0 state).

Lemma borne_1_1 :
 forall (a : ad) (s' s : state),
 state_in_dta (M1 state a s') s -> taille_1 s <= DTA_taille (M1 state a s').

Lemma borne_1_2 :
 forall (m0 m1 : Map state) (s : state),
 (state_in_dta m0 s -> taille_1 s <= DTA_taille m0) ->
 (state_in_dta m1 s -> taille_1 s <= DTA_taille m1) ->
 state_in_dta (M2 state m0 m1) s -> taille_1 s <= DTA_taille (M2 state m0 m1).

Lemma borne_1 :
 forall (d : preDTA) (s : state),
 state_in_dta d s -> taille_1 s <= DTA_taille d.

Lemma borne_2 :
 forall (d : preDTA) (p : prec_list),
 prec_in_dta d p -> taille_0 p <= DTA_taille d.

Definition essence (t : term) (d : preDTA) : nat :=
  S (term_high t) * S (DTA_taille d).

Definition essence_list (l : term_list) (d : preDTA) 
  (pl : prec_list) : nat :=
  match l, pl with
  | tnil, _ => 1
  | _, prec_empty => 1
  | _, prec_cons a la ls =>
      taille_0 pl + S (term_high_0 l) * S (DTA_taille d)
  end.

Lemma conservation_0_0 : forall n n0 : nat, S n * S n0 = S (n0 + n * S n0).

Lemma conservation_0 :
 forall (d : preDTA) (p : prec_list) (c : ad) (l : term_list),
 prec_in_dta d p -> S (essence_list l d p) <= essence (app c l) d.

Lemma conservation_1 :
 forall (d : preDTA) (l : term_list), 1 <= essence_list l d prec_empty.

Lemma conservation_2 :
 forall (d : preDTA) (p : prec_list), 1 <= essence_list tnil d p.

Lemma conservation_3 :
 forall (d : preDTA) (hd : term) (tl : term_list) (a : ad)
   (la ls : prec_list),
 S (essence_list (tcons hd tl) d ls) <=
 essence_list (tcons hd tl) d (prec_cons a la ls).

Lemma conservation_4 :
 forall (d : preDTA) (hd : term) (tl : term_list) (a : ad)
   (la ls : prec_list),
 S (essence_list tl d la) <= essence_list (tcons hd tl) d (prec_cons a la ls).

Lemma conservation_5_0 :
 forall (a : ad) (la ls : prec_list), 1 <= taille_0 (prec_cons a la ls).

Lemma conservation_5 :
 forall (d : preDTA) (hd : term) (tl : term_list) (a : ad)
   (la ls : prec_list),
 S (essence hd d) <= essence_list (tcons hd tl) d (prec_cons a la ls).

Definition dta_rec_term (d : DTA) (t : term) : bool :=
  match d with
  | dta p a => rec_term p a t (essence t p)
  end.

Inductive reconnaissance : preDTA -> ad -> term -> Prop :=
    rec_dta :
      forall (d : preDTA) (a : ad) (t : term) (ladj : state),
      MapGet state d a = Some ladj ->
      state_reconnait d ladj t -> reconnaissance d a t
with state_reconnait : preDTA -> state -> term -> Prop :=
    rec_st :
      forall (d : preDTA) (s : state) (c : ad) (tl : term_list)
        (l : prec_list),
      MapGet prec_list s c = Some l ->
      liste_reconnait d l tl -> state_reconnait d s (app c tl)
with liste_reconnait : preDTA -> prec_list -> term_list -> Prop :=
  | rec_empty : forall d : preDTA, liste_reconnait d prec_empty tnil
  | rec_consi :
      forall (d : preDTA) (a : ad) (la ls : prec_list) 
        (hd : term) (tl : term_list),
      reconnaissance d a hd ->
      liste_reconnait d la tl ->
      liste_reconnait d (prec_cons a la ls) (tcons hd tl)
  | rec_consn :
      forall (d : preDTA) (a : ad) (la ls : prec_list) 
        (hd : term) (tl : term_list),
      liste_reconnait d ls (tcons hd tl) ->
      liste_reconnait d (prec_cons a la ls) (tcons hd tl).

Definition reconnait (d : DTA) (t : term) : Prop :=
  match d with
  | dta p a => reconnaissance p a t
  end.

Scheme mreconnaissance_ind := Induction for reconnaissance
  Sort Prop
  with mstrec_ind := Induction for state_reconnait 
  Sort Prop
  with mlrec_ind := Induction for liste_reconnait Sort Prop.

Lemma sem_listes_0 :
 forall (d : preDTA) (p : prec_list) (hd : term) (tl : term_list),
 liste_reconnait d p (tcons hd tl) -> p <> prec_empty.

Lemma sem_listes_1 :
 forall (d : preDTA) (hd : term) (tl : term_list),
 ~ liste_reconnait d prec_empty (tcons hd tl).

Lemma sem_listes_2 :
 forall (d : preDTA) (pl : prec_list),
 liste_reconnait d pl tnil -> pl = prec_empty.

Definition sem_equiv_prop_t (t : term) :=
  forall (d : preDTA) (a : ad) (n : nat),
  rec_term d a t n = true -> reconnaissance d a t.
Definition sem_equiv_prop_l (l : term_list) :=
  forall (d : preDTA) (p : prec_list) (n : nat),
  rec_list_terms d p l n = true -> liste_reconnait d p l.

Lemma semantic_equiv_0_0 :
 forall (d : preDTA) (p : prec_list) (n : nat),
 rec_list_terms d p tnil n = true -> p = prec_empty.

Lemma semantic_equiv_0_1 : sem_equiv_prop_l tnil.

Lemma semantic_equiv_0_2 :
 forall (d : preDTA) (a a' : ad) (l : term_list) (n : nat) 
   (s : state) (p : prec_list),
 rec_term d a (app a' l) (S n) = true ->
 MapGet state d a = Some s ->
 MapGet prec_list s a' = Some p -> rec_list_terms d p l n = true.

Lemma semantic_equiv_0_3 :
 forall (d : preDTA) (a a' : ad) (l : term_list) (n : nat),
 rec_term d a (app a' l) (S n) = true ->
 exists s : state, MapGet state d a = Some s.

Lemma semantic_equiv_0_4 :
 forall (d : preDTA) (a a' : ad) (l : term_list) (n : nat) (s : state),
 MapGet state d a = Some s ->
 rec_term d a (app a' l) (S n) = true ->
 exists p : prec_list, MapGet prec_list s a' = Some p.

Lemma semantic_equiv_0_5 :
 forall (a : ad) (t : term_list),
 sem_equiv_prop_l t -> sem_equiv_prop_t (app a t).

Lemma semantic_equiv_0_6 :
 forall (n : nat) (t : term) (t0 : term_list),
 (forall (d : preDTA) (a : ad) (m : nat),
  rec_term d a t m = true -> reconnaissance d a t) ->
 (forall (d : preDTA) (p : prec_list) (m : nat),
  rec_list_terms d p t0 m = true -> liste_reconnait d p t0) ->
 forall (d : preDTA) (p : prec_list),
 rec_list_terms d p (tcons t t0) n = true -> liste_reconnait d p (tcons t t0).

Lemma semantic_equiv_0_7 :
 forall t : term,
 sem_equiv_prop_t t ->
 forall t0 : term_list, sem_equiv_prop_l t0 -> sem_equiv_prop_l (tcons t t0).

Lemma semantic_equiv_0 :
 forall (d : preDTA) (a : ad) (t : term) (n : nat),
 rec_term d a t n = true -> reconnaissance d a t.

Definition invar_term (t : term) : Prop :=
  forall (n m : nat) (d : preDTA) (a : ad),
  rec_term d a t n = true -> n <= m -> rec_term d a t m = true.

Definition invar_list (tl : term_list) : Prop :=
  forall (n m : nat) (d : preDTA) (p : prec_list),
  rec_list_terms d p tl n = true -> n <= m -> rec_list_terms d p tl m = true.

Lemma invar_0 : invar_list tnil.

Lemma invar_1_0 :
 forall (d : preDTA) (a c : ad) (t : term_list) (n : nat) 
   (s : state) (p : prec_list),
 MapGet state d a = Some s ->
 MapGet prec_list s c = Some p ->
 rec_list_terms d p t n = true -> rec_term d a (app c t) (S n) = true.

Lemma invar_1_1 :
 forall (d : preDTA) (a c : ad) (t : term_list) (n : nat),
 rec_term d a (app c t) (S n) = true ->
 exists p : prec_list, rec_list_terms d p t n = true.

Lemma invar_1 :
 forall (a : ad) (t : term_list), invar_list t -> invar_term (app a t).

Lemma invar_2_0 :
 forall (d : preDTA) (p : prec_list) (n : nat),
 rec_list_terms d p tnil n = true -> p = prec_empty.

Lemma invar_2_1 :
 forall (d : preDTA) (a : ad) (la ls : prec_list) (hd : term)
   (tl : term_list) (n : nat),
 rec_list_terms d (prec_cons a la ls) (tcons hd tl) (S n) = true ->
 rec_list_terms d ls (tcons hd tl) n = true \/
 rec_term d a hd n = true /\ rec_list_terms d la tl n = true.

Lemma invar_2_2 :
 forall (d : preDTA) (a : ad) (la ls : prec_list) (hd : term)
   (tl : term_list) (n : nat),
 rec_list_terms d ls (tcons hd tl) n = true \/
 rec_term d a hd n = true /\ rec_list_terms d la tl n = true ->
 rec_list_terms d (prec_cons a la ls) (tcons hd tl) (S n) = true.
 
Lemma invar_2 :
 forall t : term,
 invar_term t ->
 forall t0 : term_list, invar_list t0 -> invar_list (tcons t t0).

Lemma invar : forall t : term, invar_term t.

Lemma invarl : forall tl : term_list, invar_list tl.

Definition dta_reconnait (d : preDTA) (a : ad) (t : term)
  (pr : reconnaissance d a t) := rec_term d a t (essence t d) = true.

Definition st_reconnait (d : preDTA) (s : state) (t : term)
  (pr : state_reconnait d s t) :=
  match t with
  | app c l =>
      exists p : prec_list,
        MapGet prec_list s c = Some p /\
        rec_list_terms d p l (essence_list l d p) = true
  end.

Definition pre_reconnait (d : preDTA) (p : prec_list) 
  (t : term_list) (pr : liste_reconnait d p t) :=
  rec_list_terms d p t (essence_list t d p) = true.

Lemma semantic_equiv_1_0 :
 forall (d : preDTA) (a : ad) (t : term) (ladj : state)
   (e : MapGet state d a = Some ladj) (s : state_reconnait d ladj t),
 st_reconnait d ladj t s -> dta_reconnait d a t (rec_dta d a t ladj e s).

Lemma semantic_equiv_1_1 :
 forall (d : preDTA) (s : state) (c : ad) (tl : term_list) 
   (l : prec_list) (e : MapGet prec_list s c = Some l)
   (l0 : liste_reconnait d l tl),
 pre_reconnait d l tl l0 ->
 st_reconnait d s (app c tl) (rec_st d s c tl l e l0).

Lemma semantic_equiv_1_2 :
 forall d : preDTA, pre_reconnait d prec_empty tnil (rec_empty d).

Lemma semantic_equiv_1_3 :
 forall (d : preDTA) (a : ad) (la ls : prec_list) (hd : term)
   (tl : term_list) (r : reconnaissance d a hd),
 dta_reconnait d a hd r ->
 forall l : liste_reconnait d la tl,
 pre_reconnait d la tl l ->
 pre_reconnait d (prec_cons a la ls) (tcons hd tl)
   (rec_consi d a la ls hd tl r l).

Lemma semantic_equiv_1_4_0 :
 forall (d : preDTA) (a : ad) (la ls : prec_list) (l : term_list) (n : nat),
 l <> tnil ->
 rec_list_terms d ls l n = true ->
 rec_list_terms d (prec_cons a la ls) l (S n) = true.

Lemma semantic_equiv_1_4 :
 forall (d : preDTA) (a : ad) (la ls : prec_list) (hd : term)
   (tl : term_list) (l : liste_reconnait d ls (tcons hd tl)),
 pre_reconnait d ls (tcons hd tl) l ->
 pre_reconnait d (prec_cons a la ls) (tcons hd tl)
   (rec_consn d a la ls hd tl l).

Lemma semantic_equiv_1 :
 forall (d : preDTA) (a : ad) (t : term),
 reconnaissance d a t -> rec_term d a t (essence t d) = true. *)
Require Import lattice_fixpoint.
(* lattice_fixpoint:
Require Import Classical_Prop.
Require Import Bool.
Require Import Arith.
Require Import NArith.
Require Import Ndec.
From IntMap Require Import Allmaps.
Require Import bases.

Fixpoint domain_equal (A B : Set) (m0 : Map A) (m1 : Map B) {struct m1} :
 Prop :=
  match m0, m1 with
  | M0, M0 => True
  | M0, M1 _ _ => False
  | M0, M2 _ _ => False
  | M1 _ _, M0 => False
  | M1 a _, M1 b _ => a = b
  | M1 _ _, M2 _ _ => False
  | M2 _ _, M0 => False
  | M2 _ _, M1 _ _ => False
  | M2 a b, M2 c d => domain_equal A B a c /\ domain_equal A B b d
  end.

Lemma domain_equal_mapget :
 forall (A B : Set) (m0 : Map A) (m1 : Map B) (a : ad) (x : A),
 domain_equal A B m0 m1 ->
 MapGet A m0 a = Some x -> exists y : B, MapGet B m1 a = Some y.

Lemma domain_equal_reflexive :
 forall (A : Set) (m : Map A), domain_equal A A m m.

Lemma domain_equal_symmetric :
 forall (A B : Set) (m0 : Map A) (m1 : Map B),
 domain_equal A B m0 m1 -> domain_equal B A m1 m0.

Lemma domain_equal_transitive :
 forall (A0 A1 A2 : Set) (m0 : Map A0) (m1 : Map A1) (m2 : Map A2),
 domain_equal A0 A1 m0 m1 ->
 domain_equal A1 A2 m1 m2 -> domain_equal A0 A2 m0 m2.

Lemma map_sum :
 forall (A : Set) (m : Map A),
 m = M0 A \/
 (exists a : ad, (exists x : A, m = M1 A a x)) \/
 (exists x : Map A, (exists y : Map A, m = M2 A x y)).

Definition mEnsemble (A : Set) := Map A -> Prop.

Definition mRelation (A : Set) := Map A -> Map A -> Prop.

Definition r_symmetric (A : Set) (r : mRelation A) :=
  forall x y : Map A, r x y -> r y x.

Definition r_antisymmetric (A : Set) (r : mRelation A) :=
  forall x y : Map A, r x y -> r y x -> x = y.

Definition r_transitive (A : Set) (r : mRelation A) :=
  forall x y z : Map A, r x y -> r y z -> r x z.

Definition r_reflexive (A : Set) (r : mRelation A) := forall x : Map A, r x x.

Definition r_order (A : Set) (r : mRelation A) :=
  r_reflexive A r /\ r_antisymmetric A r /\ r_transitive A r.

Definition mini (A : Set) (r : mRelation A) (T : mEnsemble A) 
  (e : Map A) := T e /\ (forall x : Map A, T x -> r e x).

Definition maxi (A : Set) (r : mRelation A) (T : mEnsemble A) 
  (e : Map A) := T e /\ (forall x : Map A, T x -> r x e).

Definition mLattice (A : Set) (r : mRelation A) (T : mEnsemble A)
  (e f : Map A) := r_order A r /\ mini A r T e /\ maxi A r T f.

Inductive prechain (A : Set) : Set :=
  | single : Map A -> prechain A
  | concat : prechain A -> Map A -> prechain A.

Lemma prechain_sum :
 forall (A : Set) (p : prechain A),
 (exists x : Map A, p = single A x) \/
 (exists x : Map A, (exists y : prechain A, p = concat A y x)).

Inductive prechain_dom_ok (A : Set) : mEnsemble A -> prechain A -> Prop :=
  | domok_single :
      forall (x : Map A) (T : mEnsemble A),
      T x -> prechain_dom_ok A T (single A x)
  | domok_concat :
      forall (x : Map A) (T : mEnsemble A) (p : prechain A),
      T x -> prechain_dom_ok A T p -> prechain_dom_ok A T (concat A p x).

Fixpoint chain_length (A : Set) (p : prechain A) {struct p} : nat :=
  match p with
  | single x => 1
  | concat x y => S (chain_length A x)
  end.

Definition prechain_last (A : Set) (p : prechain A) : 
  Map A := match p with
           | single x => x
           | concat z x => x
           end.

Inductive prechain_incr (A : Set) : mRelation A -> prechain A -> Prop :=
  | incr_single :
      forall (x : Map A) (r : mRelation A), prechain_incr A r (single A x)
  | incr_concat :
      forall (x : Map A) (r : mRelation A) (p : prechain A),
      r (prechain_last A p) x ->
      prechain_incr A r p -> prechain_incr A r (concat A p x).

Inductive chain (A : Set) :
mEnsemble A -> mRelation A -> prechain A -> Prop :=
  | chain_single :
      forall (x : Map A) (T : mEnsemble A) (r : mRelation A),
      T x -> chain A T r (single A x)
  | chain_concat_s :
      forall (x y : Map A) (T : mEnsemble A) (r : mRelation A),
      T x -> T y -> r x y -> chain A T r (concat A (single A x) y)
  | chain_concat_m :
      forall (x y : Map A) (z : prechain A) (T : mEnsemble A)
        (r : mRelation A),
      T y ->
      r x y ->
      chain A T r (concat A z x) -> chain A T r (concat A (concat A z x) y).

Lemma chain_def_ok :
 forall (A : Set) (T : mEnsemble A) (r : mRelation A) (p : prechain A),
 chain A T r p -> prechain_dom_ok A T p.

Lemma chain_incr :
 forall (A : Set) (T : mEnsemble A) (r : mRelation A) (p : prechain A),
 chain A T r p -> prechain_incr A r p.

Definition pre_domok_incr_chain_def (A : Set) (p : prechain A) :=
  forall (T : mEnsemble A) (r : mRelation A),
  prechain_dom_ok A T p /\ prechain_incr A r p -> chain A T r p.

Lemma pre_domok_incr_chain_0 :
 forall (A : Set) (m : Map A), pre_domok_incr_chain_def A (single A m).

Lemma pre_domok_incr_chain_1 :
 forall (A : Set) (p : prechain A),
 pre_domok_incr_chain_def A p ->
 forall m : Map A, pre_domok_incr_chain_def A (concat A p m).

Lemma pre_domok_incr_chain_2 :
 forall (A : Set) (p : prechain A), pre_domok_incr_chain_def A p.

Lemma pre_domok_incr_chain :
 forall (A : Set) (p : prechain A) (T : mEnsemble A) (r : mRelation A),
 prechain_dom_ok A T p /\ prechain_incr A r p -> chain A T r p.

Inductive dist_chain (A : Set) : prechain A -> Prop :=
  | dist_single : forall x : Map A, dist_chain A (single A x)
  | dist_concat_s :
      forall x y : Map A, x <> y -> dist_chain A (concat A (single A x) y)
  | dist_concat_m :
      forall (x y : Map A) (z : prechain A),
      x <> y ->
      dist_chain A (concat A z x) -> dist_chain A (concat A (concat A z x) y).

Inductive non_dist_chain (A : Set) : prechain A -> Prop :=
  | non_dist_concat_s :
      forall x : Map A, non_dist_chain A (concat A (single A x) x)
  | non_dist_concat_m_hd :
      forall (x : Map A) (z : prechain A),
      non_dist_chain A (concat A (concat A z x) x)
  | non_dist_concat_m_tl :
      forall (x y : Map A) (z : prechain A),
      non_dist_chain A (concat A z x) ->
      non_dist_chain A (concat A (concat A z x) y).

Definition sas_chain (A : Set) (T : mEnsemble A) (r : mRelation A)
  (p : prechain A) : Prop := chain A T r p /\ dist_chain A p.

Definition dist_compl_def_0 (A : Set) (p : prechain A) : Prop :=
  dist_chain A p \/ non_dist_chain A p.

Lemma dist_compl_0 :
 forall (A : Set) (m : Map A), dist_compl_def_0 A (single A m).

Definition dist_compl_def_1 (A : Set) (p : prechain A) : Prop :=
  dist_compl_def_0 A p -> forall m : Map A, dist_compl_def_0 A (concat A p m).

Lemma dist_compl_1 :
 forall (A : Set) (m : Map A), dist_compl_def_1 A (single A m).

Lemma dist_compl_2 :
 forall (A : Set) (p : prechain A),
 dist_compl_def_1 A p -> forall m : Map A, dist_compl_def_1 A (concat A p m).

Lemma dist_compl_3 :
 forall (A : Set) (p : prechain A),
 dist_compl_def_0 A p -> forall m : Map A, dist_compl_def_0 A (concat A p m).

Lemma dist_compl_4 :
 forall (A : Set) (p : prechain A), dist_chain A p \/ non_dist_chain A p.

Lemma dist_compl_5 :
 forall (A : Set) (x : Map A), ~ dist_chain A (concat A (single A x) x).

Lemma dist_compl_6 :
 forall (A : Set) (x : Map A) (z : prechain A),
 ~ dist_chain A (concat A (concat A z x) x).

Lemma dist_compl_7 :
 forall (A : Set) (x y : Map A) (z : prechain A),
 non_dist_chain A (concat A z x) ->
 ~ dist_chain A (concat A z x) -> ~ dist_chain A (concat A (concat A z x) y).

Lemma dist_compl_8 :
 forall (A : Set) (p : prechain A), non_dist_chain A p -> ~ dist_chain A p.

Lemma dist_compl :
 forall (A : Set) (p : prechain A), ~ dist_chain A p <-> non_dist_chain A p.

Definition bounded_sas_chain (A : Set) (T : mEnsemble A) 
  (r : mRelation A) (n : nat) : Prop :=
  forall p : prechain A, sas_chain A T r p -> chain_length A p <= n.

Definition def_ok_app (A : Set) (T : mEnsemble A) (f : Map A -> Map A) :
  Prop := forall x : Map A, T x -> T (f x).

Definition increasing_app (A : Set) (r : mRelation A) 
  (f : Map A -> Map A) : Prop := forall x y : Map A, r x y -> r (f x) (f y).

Definition fix_point (A : Set) (T : mEnsemble A) (f : Map A -> Map A)
  (x : Map A) : Prop := T x /\ f x = x.

Definition inf_fix_points (A : Set) (T : mEnsemble A) 
  (r : mRelation A) (f : Map A -> Map A) (x : Map A) : Prop :=
  forall y : Map A, fix_point A T f y -> r x y.

Definition lower_fix_point (A : Set) (T : mEnsemble A) 
  (r : mRelation A) (f : Map A -> Map A) (x : Map A) : Prop :=
  fix_point A T f x /\ inf_fix_points A T r f x.

Fixpoint iteres (A : Set) (f : Map A -> Map A) (x : Map A) 
 (n : nat) {struct n} : prechain A :=
  match n with
  | O => single A x
  | S p =>
      match iteres A f x p with
      | single y => concat A (single A y) (f y)
      | concat z y => concat A (concat A z y) (f y)
      end
  end.

Fixpoint power (A : Set) (f : A -> A) (x : A) (n : nat) {struct n} : A :=
  match n with
  | O => x
  | S n => f (power A f x n)
  end.

Inductive MapFlag (A : Set) : Set :=
  | flag_true : Map A -> MapFlag A
  | flag_false : Map A -> MapFlag A.

Lemma MapFlag_sum :
 forall (A : Set) (f : MapFlag A),
 exists x : Map A, f = flag_true A x \/ f = flag_false A x.

Fixpoint lazy_power_aux (A : Set) (egalite : Map A -> Map A -> bool)
 (f : Map A -> Map A) (x : Map A) (n : nat) {struct n} : 
 MapFlag A :=
  match n with
  | O => flag_false A x
  | S p =>
      match lazy_power_aux A egalite f x p with
      | flag_true y => flag_true A y
      | flag_false y =>
          match f y with
          | z => if egalite y z then flag_true A y else flag_false A z
          end
      end
  end.

Definition lazy_power (A : Set) (egalite : Map A -> Map A -> bool)
  (f : Map A -> Map A) (x : Map A) (n : nat) : Map A :=
  match lazy_power_aux A egalite f x n with
  | flag_false z => z
  | flag_true z => z
  end.
 
Lemma lazy_power_eg_power_0 :
 forall (A : Set) (egalite : Map A -> Map A -> bool) 
   (f : Map A -> Map A) (x : Map A) (n : nat),
 (forall a b : Map A, egalite a b = true <-> a = b) ->
 forall z : Map A,
 (lazy_power_aux A egalite f x n = flag_true A z ->
  z = power (Map A) f x n /\ z = f z) /\
 (lazy_power_aux A egalite f x n = flag_false A z -> z = power (Map A) f x n).

Lemma lazy_power_eg_power :
 forall (A : Set) (egalite : Map A -> Map A -> bool) 
   (f : Map A -> Map A) (x : Map A) (n : nat),
 (forall a b : Map A, egalite a b = true <-> a = b) ->
 lazy_power A egalite f x n = power (Map A) f x n.

Fixpoint iteres_0 (A : Set) (f : Map A -> Map A) (x : Map A) 
 (n : nat) {struct n} : prechain A :=
  match n with
  | O => single A x
  | S p =>
      match iteres_0 A f x p with
      | single y => concat A (single A y) (power (Map A) f x (S p))
      | concat z y => concat A (concat A z y) (power (Map A) f x (S p))
      end
  end.

Lemma iteres_eq_0 :
 forall (A : Set) (f : Map A -> Map A) (x : Map A) (n : nat),
 prechain_last A (iteres A f x n) = power (Map A) f x n.

Lemma iteres_eq :
 forall (A : Set) (f : Map A -> Map A) (x : Map A) (n : nat),
 iteres A f x n = iteres_0 A f x n.

Lemma iteres_def_ok :
 forall (A : Set) (T : mEnsemble A) (f : Map A -> Map A) 
   (x : Map A) (n k : nat),
 def_ok_app A T f -> T (power (Map A) f x n) -> T (power (Map A) f x (n + k)).

Lemma power_def_ok :
 forall (A : Set) (T : mEnsemble A) (f : Map A -> Map A) 
   (x : Map A) (n : nat), def_ok_app A T f -> T x -> T (power (Map A) f x n).

Definition iteres_ult_const_def_0 (A : Set) (p : prechain A) : Prop :=
  forall (f : Map A -> Map A) (x : Map A) (n : nat),
  p = iteres A f x n ->
  non_dist_chain A p ->
  exists q : nat, S q <= n /\ power (Map A) f x q = power (Map A) f x (S q).

Lemma iteres_ult_const_0 :
 forall (A : Set) (x : Map A),
 iteres_ult_const_def_0 A (concat A (single A x) x).

Lemma iteres_ult_const_1 :
 forall (A : Set) (x : Map A) (z : prechain A),
 iteres_ult_const_def_0 A (concat A (concat A z x) x).

Lemma iteres_ult_const_2 :
 forall (A : Set) (x y : Map A) (z : prechain A),
 non_dist_chain A (concat A z x) ->
 iteres_ult_const_def_0 A (concat A z x) ->
 iteres_ult_const_def_0 A (concat A (concat A z x) y).

Lemma iteres_ult_const_3 :
 forall (A : Set) (p : prechain A),
 non_dist_chain A p -> iteres_ult_const_def_0 A p.

Lemma iteres_ult_const_4 :
 forall (A : Set) (f : Map A -> Map A) (x : Map A) (n : nat),
 non_dist_chain A (iteres A f x n) ->
 exists p : nat, S p <= n /\ power (Map A) f x p = power (Map A) f x (S p).

Lemma iteres_last :
 forall (A : Set) (f : Map A -> Map A) (x : Map A) 
   (n : nat) (y : prechain A) (z : Map A),
 iteres A f x n = concat A y z -> z = f (prechain_last A y).

Lemma iteres_dom_ok :
 forall (A : Set) (T : mEnsemble A) (f : Map A -> Map A) 
   (x : Map A) (n : nat),
 T x -> def_ok_app A T f -> prechain_dom_ok A T (iteres A f x n).

Lemma iteres_incr :
 forall (A : Set) (r : mRelation A) (f : Map A -> Map A) 
   (x : Map A) (n : nat),
 r x (f x) -> increasing_app A r f -> prechain_incr A r (iteres A f x n).

Lemma iteres_increasing_chain :
 forall (A : Set) (T : mEnsemble A) (r : mRelation A) 
   (f : Map A -> Map A) (x : Map A) (n : nat),
 T x ->
 def_ok_app A T f ->
 increasing_app A r f -> r x (f x) -> chain A T r (iteres A f x n).

Lemma iteres_length :
 forall (A : Set) (f : Map A -> Map A) (x : Map A) (n : nat),
 chain_length A (iteres A f x n) = S n.

Lemma iteres_non_sas_chain :
 forall (A : Set) (T : mEnsemble A) (r : mRelation A) 
   (f : Map A -> Map A) (x : Map A) (n m : nat),
 T x ->
 def_ok_app A T f ->
 increasing_app A r f ->
 r x (f x) ->
 bounded_sas_chain A T r m ->
 m <= n -> chain A T r (iteres A f x n) /\ ~ dist_chain A (iteres A f x n).

Lemma iteres_non_sas_chain_fp_0 :
 forall (A : Set) (T : mEnsemble A) (r : mRelation A) 
   (f : Map A -> Map A) (x : Map A) (n m : nat),
 T x ->
 def_ok_app A T f ->
 increasing_app A r f ->
 r x (f x) ->
 bounded_sas_chain A T r m ->
 m <= n ->
 exists p : nat, S p <= n /\ power (Map A) f x p = power (Map A) f x (S p).

Lemma iteres_non_sas_chain_fp_1 :
 forall (A : Set) (T : mEnsemble A) (f : Map A -> Map A) 
   (x : Map A) (k p : nat),
 def_ok_app A T f ->
 fix_point A T f (power (Map A) f x p) ->
 fix_point A T f (power (Map A) f x (p + k)).

Lemma iteres_non_sas_chain_fp_2 :
 forall (A : Set) (T : mEnsemble A) (r : mRelation A) 
   (f : Map A -> Map A) (x : Map A) (n m : nat),
 T x ->
 def_ok_app A T f ->
 increasing_app A r f ->
 r x (f x) ->
 bounded_sas_chain A T r m -> m <= n -> fix_point A T f (power (Map A) f x n).

Lemma iteres_inf_fps :
 forall (A : Set) (T : mEnsemble A) (r : mRelation A) 
   (f : Map A -> Map A) (e x : Map A) (n : nat),
 mini A r T e ->
 fix_point A T f x -> increasing_app A r f -> r (power (Map A) f e n) x.

Lemma iteres_lower_fix_point :
 forall (A : Set) (T : mEnsemble A) (r : mRelation A) 
   (f : Map A -> Map A) (e : Map A) (n m : nat),
 mini A r T e ->
 def_ok_app A T f ->
 increasing_app A r f ->
 bounded_sas_chain A T r m ->
 m <= n -> lower_fix_point A T r f (power (Map A) f e n).

Definition leb (b0 b1 : bool) : Prop :=
  match b0, b1 with
  | false, false => True
  | false, true => True
  | true, false => False
  | true, true => True
  end.

Lemma leb_reflexive : forall b : bool, leb b b.

Lemma leb_antisymmetric : forall b c : bool, leb b c -> leb c b -> b = c.

Lemma leb_transitive : forall a b c : bool, leb a b -> leb b c -> leb a c.

Fixpoint lem (m0 m1 : Map bool) {struct m1} : Prop :=
  match m0, m1 with
  | M0, M0 => True
  | M0, M1 _ _ => False
  | M0, M2 _ _ => False
  | M1 _ _, M0 => False
  | M1 a b, M1 a' b' => if Neqb a a' then leb b b' else False
  | M1 _ _, M2 _ _ => False
  | M2 _ _, M0 => False
  | M2 _ _, M1 _ _ => False
  | M2 a b, M2 c d => lem a c /\ lem b d
  end.

Lemma lem_reflexive : r_reflexive bool lem.

Lemma lem_antisymmetric : r_antisymmetric bool lem.

Lemma lem_transitive : r_transitive bool lem.

Lemma lem_order : r_order bool lem.

Definition ensemble_base (A : Set) (m : Map A) (x : Map bool) :=
  domain_equal A bool m x.

Fixpoint map_fill (A : Set) (m : Map A) {struct m} : 
 bool -> Map bool :=
  fun b : bool =>
  match m with
  | M0 => M0 bool
  | M1 a _ => M1 bool a b
  | M2 m0 m1 => M2 bool (map_fill A m0 b) (map_fill A m1 b)
  end.

Definition map_mini (A : Set) (m : Map A) : Map bool := map_fill A m false.

Definition map_maxi (A : Set) (m : Map A) : Map bool := map_fill A m true.

Lemma map_mini_appartient :
 forall (A : Set) (x : Map A), ensemble_base A x (map_mini A x).

Lemma map_maxi_appartient :
 forall (A : Set) (x : Map A), ensemble_base A x (map_maxi A x).

Lemma map_mini_mini :
 forall (A : Set) (x : Map A),
 mini bool lem (ensemble_base A x) (map_mini A x).

Lemma map_maxi_maxi :
 forall (A : Set) (x : Map A),
 maxi bool lem (ensemble_base A x) (map_maxi A x).

Lemma map_mini_mapget_false :
 forall (A : Set) (x : Map A) (a : ad) (b : bool),
 MapGet bool (map_mini A x) a = Some b -> b = false.

Lemma map_mini_mapget_true :
 forall (A : Set) (x : Map A) (a : ad),
 MapGet bool (map_mini A x) a = Some true -> False.

Lemma mlattice :
 forall (A : Set) (x : Map A),
 mLattice bool lem (ensemble_base A x) (map_mini A x) (map_maxi A x).

Definition lattice_bounded_def_0 (p : prechain bool) : Prop :=
  forall (A : Set) (m0 m1 : Map A),
  sas_chain bool (ensemble_base A (M2 A m0 m1)) lem p ->
  exists p0 : prechain bool,
    (exists p1 : prechain bool,
       sas_chain bool (ensemble_base A m0) lem p0 /\
       sas_chain bool (ensemble_base A m1) lem p1 /\
       lem (M2 bool (prechain_last bool p0) (prechain_last bool p1))
         (prechain_last bool p) /\
       chain_length bool p0 + chain_length bool p1 = S (chain_length bool p)).

Lemma lattice_bounded_0 :
 forall m : Map bool, lattice_bounded_def_0 (single bool m).

Definition lattice_bounded_def_1 (p : prechain bool) : Prop :=
  lattice_bounded_def_0 p ->
  forall m : Map bool, lattice_bounded_def_0 (concat bool p m).

Lemma lattice_bounded_1 :
 forall m : Map bool, lattice_bounded_def_1 (single bool m).

Lemma lattice_bounded_2 :
 forall p : prechain bool,
 lattice_bounded_def_1 p ->
 forall m : Map bool, lattice_bounded_def_1 (concat bool p m).

Lemma lattice_bounded_3 :
 forall p : prechain bool,
 lattice_bounded_def_0 p ->
 forall m : Map bool, lattice_bounded_def_0 (concat bool p m).

Lemma lattice_bounded_4 : forall p : prechain bool, lattice_bounded_def_0 p.

Lemma lattice_bounded_5 :
 forall (p : prechain bool) (A : Set) (m0 m1 : Map A),
 sas_chain bool (ensemble_base A (M2 A m0 m1)) lem p ->
 exists p0 : prechain bool,
   (exists p1 : prechain bool,
      sas_chain bool (ensemble_base A m0) lem p0 /\
      sas_chain bool (ensemble_base A m1) lem p1 /\
      lem (M2 bool (prechain_last bool p0) (prechain_last bool p1))
        (prechain_last bool p) /\
      chain_length bool p0 + chain_length bool p1 = S (chain_length bool p)).

Definition lattice_bounded_def_2 (A : Set) (m : Map A) : Prop :=
  forall p : prechain bool,
  sas_chain bool (ensemble_base A m) lem p ->
  chain_length bool p <= S (MapCard A m).

Lemma lattice_bounded_6 : forall A : Set, lattice_bounded_def_2 A (M0 A).

Lemma lattice_bounded_7 :
 forall (A : Set) (a : ad) (a0 : A), lattice_bounded_def_2 A (M1 A a a0).

Lemma lattice_bounded_8 :
 forall (A : Set) (m : Map A),
 lattice_bounded_def_2 A m ->
 forall m0 : Map A,
 lattice_bounded_def_2 A m0 -> lattice_bounded_def_2 A (M2 A m m0).

Lemma lattice_bounded_9 :
 forall (A : Set) (m : Map A), lattice_bounded_def_2 A m.

Lemma lattice_bounded_10 :
 forall (A : Set) (m : Map A) (p : prechain bool),
 sas_chain bool (ensemble_base A m) lem p ->
 chain_length bool p <= S (MapCard A m).

Lemma lattice_bounded :
 forall (A : Set) (x : Map A),
 bounded_sas_chain bool (ensemble_base A x) lem (S (MapCard A x)).

Definition eq_bool (b0 b1 : bool) : bool :=
  match b0, b1 with
  | false, false => true
  | false, true => false
  | true, false => false
  | true, true => true
  end.

Lemma eq_bool_equal : forall b0 b1 : bool, eq_bool b0 b1 = true -> b0 = b1.

Lemma equal_eq_bool : forall b : bool, eq_bool b b = true.

Fixpoint eqm_bool (x y : Map bool) {struct y} : bool :=
  match x, y with
  | M0, M0 => true
  | M0, M1 _ _ => false
  | M0, M2 _ _ => false
  | M1 _ _, M0 => false
  | M1 a b, M1 c d => Neqb a c && eq_bool b d
  | M1 _ _, M2 _ _ => false
  | M2 _ _, M0 => false
  | M2 _ _, M1 _ _ => false
  | M2 a b, M2 c d => eqm_bool a c && eqm_bool b d
  end.

Lemma eqm_bool_equal : forall x y : Map bool, eqm_bool x y = true -> x = y.

Lemma equal_eqm_bool : forall x : Map bool, eqm_bool x x = true.

Lemma lem_get_leb :
 forall (m0 m1 : Map bool) (a : ad) (b0 b1 : bool),
 lem m0 m1 ->
 MapGet bool m0 a = Some b0 ->
 MapGet bool m1 a = Some b1 -> leb b0 b1.

Lemma lem_domain_equal :
 forall m0 m1 : Map bool, lem m0 m1 -> domain_equal bool bool m0 m1.

Lemma andb_inc_r :
 forall b b0 b1 : bool, leb b0 b1 -> leb (b && b0) (b && b1).

Lemma andb_inc_l :
 forall b b0 b1 : bool, leb b0 b1 -> leb (b0 && b) (b1 && b).

Lemma orb_inc_r : forall b b0 b1 : bool, leb b0 b1 -> leb (b || b0) (b || b1).

Lemma orb_inc_l : forall b b0 b1 : bool, leb b0 b1 -> leb (b0 || b) (b1 || b).

Lemma andb_incr :
 forall b0 b1 b2 b3 : bool,
 leb b0 b1 -> leb b2 b3 -> leb (b0 && b2) (b1 && b3).

Lemma orb_incr :
 forall b0 b1 b2 b3 : bool,
 leb b0 b1 -> leb b2 b3 -> leb (b0 || b2) (b1 || b3). *)
Require Import signature.
(* signature:
Require Import Bool.
Require Import NArith.
Require Import Ndec.
Require Import ZArith.
Require Import EqNat.
From IntMap Require Import Allmaps.
Require Import bases.
Require Import defs.
Require Import semantics.

Definition pl_compat (pl0 pl1 : prec_list) : Prop :=
  pl0 = prec_empty /\ pl1 = prec_empty \/
  pl0 <> prec_empty /\ pl1 <> prec_empty.

Definition mpl_compat (s0 s1 : state) : Prop :=
  forall (c : ad) (p0 p1 : prec_list),
  MapGet prec_list s0 c = Some p0 ->
  MapGet prec_list s1 c = Some p1 -> pl_compat p0 p1.

Definition dta_correct (d : preDTA) : Prop :=
  forall (s0 s1 : state) (a0 a1 : ad),
  MapGet state d a0 = Some s0 ->
  MapGet state d a1 = Some s1 -> mpl_compat s0 s1.

Definition dta_compat (d0 d1 : preDTA) : Prop :=
  forall (s0 s1 : state) (a0 a1 : ad),
  MapGet state d0 a0 = Some s0 ->
  MapGet state d1 a1 = Some s1 -> mpl_compat s0 s1.

Definition DTA_compat (d0 d1 : DTA) : Prop :=
  match d0, d1 with
  | dta p0 a0, dta p1 a1 => dta_compat p0 p1
  end.

Lemma pl_compat_sym :
 forall pl0 pl1 : prec_list, pl_compat pl0 pl1 -> pl_compat pl1 pl0.

Lemma mpl_compat_0 :
 forall (c : ad) (pl0 pl1 : prec_list),
 mpl_compat (M1 prec_list c pl0) (M1 prec_list c pl1) -> pl_compat pl0 pl1.

Lemma mpl_compat_1 :
 forall s0 s1 s2 s3 : state,
 mpl_compat (M2 prec_list s0 s1) (M2 prec_list s2 s3) -> mpl_compat s0 s2.

Lemma mpl_compat_2 :
 forall s0 s1 s2 s3 : state,
 mpl_compat (M2 prec_list s0 s1) (M2 prec_list s2 s3) -> mpl_compat s1 s3.

Lemma mpl_compat_3 :
 forall (s0 s1 : state) (pl : prec_list),
 mpl_compat (M2 prec_list s0 s1) (M1 prec_list N0 pl) ->
 mpl_compat s0 (M1 prec_list N0 pl).

Lemma mpl_compat_4 :
 forall (s0 s1 : state) (pl : prec_list),
 mpl_compat (M2 prec_list s0 s1) (M1 prec_list (Npos 1) pl) ->
 mpl_compat s1 (M1 prec_list N0 pl).

Lemma mpl_compat_5 :
 forall (s0 s1 : state) (pl : prec_list) (p : positive),
 mpl_compat (M2 prec_list s0 s1) (M1 prec_list (Npos (xO p)) pl) ->
 mpl_compat s0 (M1 prec_list (Npos p) pl).

Lemma mpl_compat_6 :
 forall (s0 s1 : state) (pl : prec_list) (p : positive),
 mpl_compat (M2 prec_list s0 s1) (M1 prec_list (Npos (xI p)) pl) ->
 mpl_compat s1 (M1 prec_list (Npos p) pl).

Lemma mpl_compat_sym :
 forall s0 s1 : state, mpl_compat s0 s1 -> mpl_compat s1 s0.

Inductive pl_tl_length : prec_list -> nat -> Prop :=
  | pl_tl_O : pl_tl_length prec_empty 0
  | pl_tl_S :
      forall (a : ad) (pl : prec_list) (n : nat),
      pl_tl_length pl n -> pl_tl_length (prec_cons a pl prec_empty) (S n)
  | pl_tl_propag :
      forall (a : ad) (la ls : prec_list) (n : nat),
      pl_tl_length la n ->
      pl_tl_length ls (S n) -> pl_tl_length (prec_cons a la ls) (S n).

Lemma pl_tl_length_pl_compat :
 forall (p0 p1 : prec_list) (n : nat),
 pl_tl_length p0 n -> pl_tl_length p1 n -> pl_compat p0 p1.

Definition pl_tl_length_rec_def_0 (n : nat) :=
  forall (d : preDTA) (pl : prec_list) (tl : term_list),
  pl_tl_length pl n -> liste_reconnait d pl tl -> n = lst_length tl.

Definition pl_tl_length_rec_def_1 (d : preDTA) (pl : prec_list)
  (tl : term_list) :=
  forall n : nat,
  pl_tl_length_rec_def_0 n ->
  pl_tl_length pl (S n) -> liste_reconnait d pl tl -> S n = lst_length tl.

Lemma pl_tl_length_rec_0 : pl_tl_length_rec_def_0 0.

Lemma pl_tl_length_rec_1 :
 forall d : preDTA, pl_tl_length_rec_def_1 d prec_empty tnil.

Lemma pl_tl_length_rec_2 :
 forall (d : preDTA) (a : ad) (la ls : prec_list) (hd : term)
   (tl : term_list),
 reconnaissance d a hd ->
 liste_reconnait d la tl ->
 pl_tl_length_rec_def_1 d la tl ->
 pl_tl_length_rec_def_1 d (prec_cons a la ls) (tcons hd tl).

Lemma pl_tl_length_rec_3 :
 forall (d : preDTA) (a : ad) (la ls : prec_list) (hd : term)
   (tl : term_list),
 liste_reconnait d ls (tcons hd tl) ->
 pl_tl_length_rec_def_1 d ls (tcons hd tl) ->
 pl_tl_length_rec_def_1 d (prec_cons a la ls) (tcons hd tl).

Lemma pl_tl_length_rec_4 :
 forall (p : preDTA) (p0 : prec_list) (t : term_list),
 liste_reconnait p p0 t -> pl_tl_length_rec_def_1 p p0 t.

Lemma pl_tl_length_rec_5 :
 forall n : nat, pl_tl_length_rec_def_0 n -> pl_tl_length_rec_def_0 (S n).

Lemma pl_tl_length_rec_6 :
 forall (d : preDTA) (pl : prec_list) (tl : term_list) (n : nat),
 pl_tl_length pl n -> liste_reconnait d pl tl -> n = lst_length tl.

Definition pl_compatible (pl0 pl1 : prec_list) : Prop :=
  exists n : nat, pl_tl_length pl0 n /\ pl_tl_length pl1 n.

Definition st_compatible (s0 s1 : state) : Prop :=
  forall (c : ad) (pl0 pl1 : prec_list),
  MapGet prec_list s0 c = Some pl0 ->
  MapGet prec_list s1 c = Some pl1 -> pl_compatible pl0 pl1.

Definition predta_compatible (d0 d1 : preDTA) : Prop :=
  forall s0 s1 : state,
  state_in_dta d0 s0 -> state_in_dta d1 s1 -> st_compatible s0 s1.

Definition dta_compatible (d0 d1 : DTA) : Prop :=
  match d0, d1 with
  | dta p0 a0, dta p1 a1 => predta_compatible p0 p1
  end.

Lemma pl_compatible_sym :
 forall pl0 pl1 : prec_list, pl_compatible pl0 pl1 -> pl_compatible pl1 pl0.

Lemma pl_compatible_empt_r :
 forall p : prec_list, pl_compatible p prec_empty -> p = prec_empty.

Lemma pl_compatible_empt_l :
 forall p : prec_list, pl_compatible prec_empty p -> p = prec_empty.

Lemma pl_compatible_cons_r :
 forall (p : prec_list) (a : ad) (la ls : prec_list),
 pl_compatible p (prec_cons a la ls) ->
 exists a0 : ad,
   (exists la0 : prec_list,
      (exists ls0 : prec_list, p = prec_cons a0 la0 ls0)).

Lemma pl_compatible_cons_l :
 forall (p : prec_list) (a : ad) (la ls : prec_list),
 pl_compatible (prec_cons a la ls) p ->
 exists a0 : ad,
   (exists la0 : prec_list,
      (exists ls0 : prec_list, p = prec_cons a0 la0 ls0)).

Lemma pl_compatible_compat :
 forall p0 p1 : prec_list, pl_compatible p0 p1 -> pl_compat p0 p1.

Definition st_compatible_compat_def (s0 : state) : Prop :=
  forall s1 : state, st_compatible s0 s1 -> mpl_compat s0 s1.

Lemma st_compatible_compat_0 : st_compatible_compat_def (M0 prec_list).

Lemma st_compatible_compat_1 :
 forall (a : ad) (a0 : prec_list),
 st_compatible_compat_def (M1 prec_list a a0).

Lemma st_compatible_compat_2 :
 forall m : Map prec_list,
 st_compatible_compat_def m ->
 forall m0 : Map prec_list,
 st_compatible_compat_def m0 -> st_compatible_compat_def (M2 prec_list m m0).

Lemma st_compatible_compat :
 forall s0 s1 : state, st_compatible s0 s1 -> mpl_compat s0 s1.

Definition predta_compatible_compat_def (d0 : preDTA) : Prop :=
  forall d1 : preDTA, predta_compatible d0 d1 -> dta_compat d0 d1.

Lemma predta_compatible_compat_0 : predta_compatible_compat_def (M0 state).

Lemma predta_compatible_compat_1 :
 forall (a : ad) (a0 : state), predta_compatible_compat_def (M1 state a a0).

Lemma predta_compatible_compat_2 :
 forall m : Map state,
 predta_compatible_compat_def m ->
 forall m0 : Map state,
 predta_compatible_compat_def m0 ->
 predta_compatible_compat_def (M2 state m m0).

Lemma predta_compatible_compat :
 forall d0 d1 : preDTA, predta_compatible d0 d1 -> dta_compat d0 d1.

Lemma dta_compatible_compat :
 forall d0 d1 : DTA, dta_compatible d0 d1 -> DTA_compat d0 d1.

Definition signature : Set := Map nat.

Definition state_correct_wrt_sign (s : state) (sigma : signature) : Prop :=
  forall (a : ad) (p : prec_list),
  MapGet prec_list s a = Some p ->
  exists n : nat, MapGet nat sigma a = Some n /\ pl_tl_length p n.

Definition predta_correct_wrt_sign (d : preDTA) (sigma : signature) : Prop :=
  forall (a : ad) (s : state),
  MapGet state d a = Some s -> state_correct_wrt_sign s sigma.

Definition dta_correct_wrt_sign (d : DTA) (sigma : signature) : Prop :=
  match d with
  | dta d a => predta_correct_wrt_sign d sigma
  end.

Lemma states_correct_wrt_sign_compatibles :
 forall (sigma : signature) (s s' : state),
 state_correct_wrt_sign s sigma ->
 state_correct_wrt_sign s' sigma -> st_compatible s s'.

Lemma predtas_correct_wrt_sign_compatibles :
 forall (sigma : signature) (d d' : preDTA),
 predta_correct_wrt_sign d sigma ->
 predta_correct_wrt_sign d' sigma -> predta_compatible d d'.

Lemma dtas_correct_wrt_sign_compatibles :
 forall (sigma : signature) (d d' : DTA),
 dta_correct_wrt_sign d sigma ->
 dta_correct_wrt_sign d' sigma -> dta_compatible d d'.

Fixpoint pl_compat_check (p : prec_list) : option nat :=
  match p with
  | prec_empty => Some 0
  | prec_cons a la ls =>
      match ls with
      | prec_empty =>
          match pl_compat_check la with
          | None => None
          | Some n => Some (S n)
          end
      | prec_cons _ _ _ =>
          match pl_compat_check la, pl_compat_check ls with
          | None, _ => None
          | _, None => None
          | Some n, Some m =>
              if beq_nat (S n) m then Some m else None
          end
      end
  end.

Lemma pl_compat_check_correct :
 forall (p : prec_list) (n : nat),
 pl_tl_length p n -> pl_compat_check p = Some n.

Lemma pl_compat_check_complete :
 forall (p : prec_list) (n : nat),
 pl_compat_check p = Some n -> pl_tl_length p n.

Inductive pre_ad : Set :=
  | pre_ad_empty : pre_ad
  | pre_ad_O : pre_ad -> pre_ad
  | pre_ad_I : pre_ad -> pre_ad.

Fixpoint pre_ad_concat (pa : pre_ad) : ad -> ad :=
  fun a : ad =>
  match pa with
  | pre_ad_empty => a
  | pre_ad_O pa' => pre_ad_concat pa' (Ndouble a)
  | pre_ad_I pa' => pre_ad_concat pa' (Ndouble_plus_one a)
  end.

Fixpoint st_compat_check_0 (pa : pre_ad) (sigma : signature) 
 (s : state) {struct s} : bool :=
  match s with
  | M0 => true
  | M1 a p =>
      match pl_compat_check p, MapGet nat sigma (pre_ad_concat pa a) with
      | None, _ => false
      | _, None => false
      | Some n, Some m => beq_nat n m
      end
  | M2 x y =>
      st_compat_check_0 (pre_ad_O pa) sigma x &&
      st_compat_check_0 (pre_ad_I pa) sigma y
  end.

Definition st_compat_check (s : state) (sigma : signature) : bool :=
  st_compat_check_0 pre_ad_empty sigma s.

Fixpoint predta_compat_check (d : preDTA) : signature -> bool :=
  fun sigma : signature =>
  match d with
  | M0 => true
  | M1 a s => st_compat_check s sigma
  | M2 x y => predta_compat_check x sigma && predta_compat_check y sigma
  end.

Definition dta_compat_check (d : DTA) (sigma : signature) : bool :=
  match d with
  | dta p a => predta_compat_check p sigma
  end.

Definition state_correct_wrt_sign_with_offset (s : state) 
  (sigma : signature) (pa : pre_ad) : Prop :=
  forall (a : ad) (p : prec_list),
  MapGet prec_list s a = Some p ->
  exists n : nat,
    MapGet nat sigma (pre_ad_concat pa a) = Some n /\ pl_tl_length p n.

Lemma state_correct_wrt_sign_with_offset_M2 :
 forall (s0 s1 : state) (sigma : signature) (pa : pre_ad),
 state_correct_wrt_sign_with_offset (M2 prec_list s0 s1) sigma pa ->
 state_correct_wrt_sign_with_offset s0 sigma (pre_ad_O pa) /\
 state_correct_wrt_sign_with_offset s1 sigma (pre_ad_I pa).

Lemma predta_correct_wrt_sign_M2 :
 forall (d0 d1 : preDTA) (sigma : signature),
 predta_correct_wrt_sign (M2 state d0 d1) sigma ->
 predta_correct_wrt_sign d0 sigma /\ predta_correct_wrt_sign d1 sigma.

Lemma st_compat_check_0_correct :
 forall (s : state) (sigma : signature) (pa : pre_ad),
 state_correct_wrt_sign_with_offset s sigma pa ->
 st_compat_check_0 pa sigma s = true.

Lemma st_compat_check_0_complete :
 forall (s : state) (sigma : signature) (pa : pre_ad),
 st_compat_check_0 pa sigma s = true ->
 state_correct_wrt_sign_with_offset s sigma pa.

Lemma st_compat_check_correct :
 forall (s : state) (sigma : signature),
 state_correct_wrt_sign s sigma -> st_compat_check s sigma = true.

Lemma st_compat_check_complete :
 forall (s : state) (sigma : signature),
 st_compat_check s sigma = true -> state_correct_wrt_sign s sigma.

Lemma predta_compat_check_correct :
 forall (d : preDTA) (sigma : signature),
 predta_correct_wrt_sign d sigma -> predta_compat_check d sigma = true.

Lemma predta_compat_check_complete :
 forall (d : preDTA) (sigma : signature),
 predta_compat_check d sigma = true -> predta_correct_wrt_sign d sigma.

Lemma dta_compat_check_correct :
 forall (d : DTA) (sigma : signature),
 dta_correct_wrt_sign d sigma -> dta_compat_check d sigma = true.

Lemma dta_compat_check_complete :
 forall (d : DTA) (sigma : signature),
 dta_compat_check d sigma = true -> dta_correct_wrt_sign d sigma. *)
Require Import pl_path.
(* pl_path:
Require Import Arith.
From IntMap Require Import Allmaps.
Require Import bases.
Require Import defs.
Require Import semantics.
Require Import signature.

Inductive pl_path : Set :=
  | pl_path_nil : pl_path
  | pl_path_cons : ad -> pl_path -> pl_path.

Inductive pl_path_incl : pl_path -> prec_list -> Prop :=
  | pl_path_incl_nil : pl_path_incl pl_path_nil prec_empty
  | pl_path_incl_cons :
      forall (plp : pl_path) (a : ad) (la ls : prec_list),
      pl_path_incl plp la ->
      pl_path_incl (pl_path_cons a plp) (prec_cons a la ls)
  | pl_path_incl_next :
      forall (plp : pl_path) (a : ad) (la ls : prec_list),
      pl_path_incl plp ls ->
      plp <> pl_path_nil -> pl_path_incl plp (prec_cons a la ls).

Inductive pl_path_recon : preDTA -> term_list -> pl_path -> Prop :=
  | pl_path_rec_nil : forall d : preDTA, pl_path_recon d tnil pl_path_nil
  | pl_path_rec_cons :
      forall (d : preDTA) (a : ad) (t : term) (plp : pl_path)
        (tl : term_list),
      reconnaissance d a t ->
      pl_path_recon d tl plp ->
      pl_path_recon d (tcons t tl) (pl_path_cons a plp).

Definition pl_path_rec_equiv_0_def (d : preDTA) (pl : prec_list)
  (tl : term_list) :=
  liste_reconnait d pl tl ->
  exists plp : pl_path, pl_path_incl plp pl /\ pl_path_recon d tl plp.

Fixpoint pl_path_length (plp : pl_path) : nat :=
  match plp with
  | pl_path_nil => 0
  | pl_path_cons _ p => S (pl_path_length p)
  end.

Lemma pl_path_exists :
 forall pl : prec_list, exists p : pl_path, pl_path_incl p pl.

Lemma non_empty_pl_path_exists :
 forall pl : prec_list,
 pl <> prec_empty ->
 exists p : pl_path, pl_path_incl p pl /\ 1 <= pl_path_length p.

Lemma pl_path_rec_equiv_0_0 :
 forall d : preDTA, pl_path_rec_equiv_0_def d prec_empty tnil.

Lemma pl_path_rec_equiv_0_1 :
 forall (d : preDTA) (a : ad) (la ls : prec_list) (hd : term)
   (tl : term_list),
 reconnaissance d a hd ->
 liste_reconnait d la tl ->
 pl_path_rec_equiv_0_def d la tl ->
 pl_path_rec_equiv_0_def d (prec_cons a la ls) (tcons hd tl).

Lemma pl_path_rec_equiv_0_2 :
 forall (d : preDTA) (a : ad) (la ls : prec_list) (hd : term)
   (tl : term_list),
 liste_reconnait d ls (tcons hd tl) ->
 pl_path_rec_equiv_0_def d ls (tcons hd tl) ->
 pl_path_rec_equiv_0_def d (prec_cons a la ls) (tcons hd tl).

Lemma pl_path_rec_equiv_0_3 :
 forall (p : preDTA) (p0 : prec_list) (t : term_list),
 liste_reconnait p p0 t -> pl_path_rec_equiv_0_def p p0 t.

Lemma pl_path_rec_equiv_0 :
 forall (d : preDTA) (pl : prec_list) (tl : term_list),
 liste_reconnait d pl tl ->
 exists plp : pl_path, pl_path_incl plp pl /\ pl_path_recon d tl plp.

Definition pl_path_rec_equiv_1_def (plp : pl_path) 
  (pl : prec_list) :=
  pl_path_incl plp pl ->
  forall (d : preDTA) (tl : term_list) (n : nat),
  pl_path_recon d tl plp -> pl_tl_length pl n -> liste_reconnait d pl tl.

Lemma pl_path_rec_equiv_1_0 : pl_path_rec_equiv_1_def pl_path_nil prec_empty.

Lemma pl_path_rec_equiv_1_1 :
 forall (plp : pl_path) (a : ad) (la ls : prec_list),
 pl_path_incl plp la ->
 pl_path_rec_equiv_1_def plp la ->
 pl_path_rec_equiv_1_def (pl_path_cons a plp) (prec_cons a la ls).

Lemma pl_path_rec_equiv_1_2 :
 forall (plp : pl_path) (a : ad) (la ls : prec_list),
 pl_path_incl plp ls ->
 pl_path_rec_equiv_1_def plp ls ->
 plp <> pl_path_nil -> pl_path_rec_equiv_1_def plp (prec_cons a la ls).

Lemma pl_path_rec_equiv_1_3 :
 forall (p : pl_path) (p0 : prec_list),
 pl_path_incl p p0 -> pl_path_rec_equiv_1_def p p0.

Lemma pl_path_rec_equiv_1 :
 forall (plp : pl_path) (pl : prec_list),
 pl_path_incl plp pl ->
 forall (d : preDTA) (tl : term_list) (n : nat),
 pl_path_recon d tl plp -> pl_tl_length pl n -> liste_reconnait d pl tl.

Lemma pl_path_rec_length :
 forall (plp : pl_path) (tl : term_list) (d : preDTA),
 pl_path_recon d tl plp -> pl_path_length plp = lst_length tl.

Definition liste_rec_length_def (d : preDTA) (pl : prec_list)
  (tl : term_list) : Prop :=
  forall n : nat,
  liste_reconnait d pl tl -> pl_tl_length pl n -> n = lst_length tl.

Lemma liste_rec_length_0 :
 forall d : preDTA, liste_rec_length_def d prec_empty tnil.

Lemma liste_rec_length_1 :
 forall (d : preDTA) (a : ad) (la ls : prec_list) (hd : term)
   (tl : term_list),
 reconnaissance d a hd ->
 liste_reconnait d la tl ->
 liste_rec_length_def d la tl ->
 liste_rec_length_def d (prec_cons a la ls) (tcons hd tl).

Lemma liste_rec_length_2 :
 forall (d : preDTA) (a : ad) (la ls : prec_list) (hd : term)
   (tl : term_list),
 liste_reconnait d ls (tcons hd tl) ->
 liste_rec_length_def d ls (tcons hd tl) ->
 liste_rec_length_def d (prec_cons a la ls) (tcons hd tl).

Lemma liste_rec_length_3 :
 forall (p : preDTA) (p0 : prec_list) (t : term_list),
 liste_reconnait p p0 t -> liste_rec_length_def p p0 t.

Lemma liste_rec_length :
 forall (pl : prec_list) (tl : term_list) (d : preDTA) (n : nat),
 liste_reconnait d pl tl -> pl_tl_length pl n -> n = lst_length tl.

Definition pl_path_incl_length_def (plp : pl_path) 
  (pl : prec_list) : Prop :=
  forall n : nat,
  pl_path_incl plp pl -> pl_tl_length pl n -> pl_path_length plp = n.

Lemma pl_path_incl_length_0 : pl_path_incl_length_def pl_path_nil prec_empty.

Lemma pl_path_incl_length_1 :
 forall (plp : pl_path) (a : ad) (la ls : prec_list),
 pl_path_incl plp la ->
 pl_path_incl_length_def plp la ->
 pl_path_incl_length_def (pl_path_cons a plp) (prec_cons a la ls).

Lemma pl_path_incl_length_2 :
 forall (plp : pl_path) (a : ad) (la ls : prec_list),
 pl_path_incl plp ls ->
 pl_path_incl_length_def plp ls ->
 plp <> pl_path_nil -> pl_path_incl_length_def plp (prec_cons a la ls).

Lemma pl_path_incl_length_3 :
 forall (p : pl_path) (p0 : prec_list),
 pl_path_incl p p0 -> pl_path_incl_length_def p p0.

Lemma pl_path_incl_length :
 forall (plp : pl_path) (pl : prec_list) (n : nat),
 pl_path_incl plp pl -> pl_tl_length pl n -> pl_path_length plp = n.

Lemma forall_incl_length :
 forall (pl : prec_list) (n : nat),
 (forall p : pl_path, pl_path_incl p pl -> pl_path_length p = n) ->
 pl_tl_length pl n. *)
Require Import empty_test.
(* empty_test:
Require Import Bool.
Require Import Arith.
Require Import NArith.
Require Import Ndec.
Require Import ZArith.
Require Import Classical_Prop.
From IntMap Require Import Allmaps.
Require Import lattice_fixpoint.
Require Import bases.
Require Import defs.
Require Import semantics.
Require Import pl_path.

Fixpoint pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool :=
  match p with
  | prec_empty => true
  | prec_cons a la ls =>
      match ls with
      | prec_empty =>
          match MapGet bool m a with
          | Some b => b && pl_non_empty m la
          | None => false
          end
      | prec_cons _ _ _ =>
          match MapGet bool m a with
          | Some b => pl_non_empty m ls || b && pl_non_empty m la
          | None => pl_non_empty m ls
          end
      end
  end.

Fixpoint st_non_empty (m : Map bool) (s : state) {struct s} : bool :=
  match s with
  | M0 => false
  | M1 _ p => pl_non_empty m p
  | M2 a b => st_non_empty m a || st_non_empty m b
  end.

Fixpoint dta_app_ne_aux (d : preDTA) (m r : Map bool) {struct r} :
 Map bool :=
  match d, r with
  | M0, _ => M0 bool
  | M1 a s, M0 => M0 bool
  | M1 a s, M1 a' b =>
      if Neqb a a' then M1 bool a (b || st_non_empty m s) else M0 bool
  | M1 a s, M2 _ _ => M0 bool
  | M2 d0 d1, M0 => M0 bool
  | M2 d0 d1, M1 _ _ => M0 bool
  | M2 d0 d1, M2 r0 r1 =>
      M2 bool (dta_app_ne_aux d0 m r0) (dta_app_ne_aux d1 m r1)
  end.

Definition dta_app_ne (d : preDTA) (m : Map bool) : 
  Map bool := dta_app_ne_aux d m m.

Definition dta_non_empty_states (d : preDTA) : Map bool :=
  power (Map bool) (dta_app_ne d) (map_mini state d) (S (MapCard state d)).

Definition dta_states_non_empty (d : DTA) : Map bool :=
  match d with
  | dta p a => dta_non_empty_states p
  end.

Definition dta_non_empty_states_lazy (d : preDTA) : 
  Map bool :=
  lazy_power bool eqm_bool (dta_app_ne d) (map_mini state d)
    (S (MapCard state d)).

Definition dta_states_non_empty_lazy (d : DTA) : Map bool :=
  match d with
  | dta p a => dta_non_empty_states_lazy p
  end.

Lemma dta_states_non_empty_lazy_eg_dta_states_non_empty :
 forall d : DTA, dta_states_non_empty_lazy d = dta_states_non_empty d.

Lemma dta_app_ne_aux_def_ok :
 forall (d : preDTA) (m : Map bool),
 def_ok_app bool (ensemble_base state d) (dta_app_ne_aux d m).

Lemma dta_app_ne_def_ok :
 forall d : preDTA, def_ok_app bool (ensemble_base state d) (dta_app_ne d).

Lemma dta_app_ne_inc_0 :
 forall (p : prec_list) (m0 m1 : Map bool),
 lem m0 m1 -> leb (pl_non_empty m0 p) (pl_non_empty m1 p).

Lemma dta_app_ne_inc_1 :
 forall (s : state) (m0 m1 : Map bool),
 lem m0 m1 -> leb (st_non_empty m0 s) (st_non_empty m1 s).

Lemma dta_app_ne_inc_2 :
 forall (d : preDTA) (m0 m1 m : Map bool),
 lem m0 m1 -> lem (dta_app_ne_aux d m0 m) (dta_app_ne_aux d m1 m).

Lemma dta_app_ne_inc_3 :
 forall (m0 m1 m : Map bool) (d : preDTA),
 lem m0 m1 -> lem (dta_app_ne_aux d m m0) (dta_app_ne_aux d m m1).

Lemma dta_app_ne_inc :
 forall d : preDTA, increasing_app bool lem (dta_app_ne d).

Inductive pl_path_true : pl_path -> Map bool -> Prop :=
  | plp_true_nil : forall m : Map bool, pl_path_true pl_path_nil m
  | plp_true_cons :
      forall (m : Map bool) (a : ad) (pl : pl_path),
      pl_path_true pl m ->
      MapGet bool m a = Some true -> pl_path_true (pl_path_cons a pl) m.

Definition pl_non_empty_path_true_def_0 (pl : pl_path) 
  (p : prec_list) : Prop :=
  forall m : Map bool,
  pl_path_incl pl p -> pl_path_true pl m -> pl_non_empty m p = true.

Lemma pl_non_empty_path_true_0 :
 pl_non_empty_path_true_def_0 pl_path_nil prec_empty.

Lemma pl_non_empty_path_true_1 :
 forall (plp : pl_path) (a : ad) (la ls : prec_list),
 pl_path_incl plp la ->
 pl_non_empty_path_true_def_0 plp la ->
 pl_non_empty_path_true_def_0 (pl_path_cons a plp) (prec_cons a la ls).

Lemma pl_non_empty_path_true_2 :
 forall (plp : pl_path) (a : ad) (la ls : prec_list),
 pl_path_incl plp ls ->
 pl_non_empty_path_true_def_0 plp ls ->
 plp <> pl_path_nil -> pl_non_empty_path_true_def_0 plp (prec_cons a la ls).

Lemma pl_non_empty_path_true :
 forall (pl : pl_path) (p : prec_list) (m : Map bool),
 pl_path_incl pl p -> pl_path_true pl m -> pl_non_empty m p = true.

Lemma pl_non_empty_path_true_rev :
 forall (p : prec_list) (m : Map bool),
 pl_non_empty m p = true ->
 exists plp : pl_path, pl_path_incl plp p /\ pl_path_true plp m.

Lemma st_non_empty_0 :
 forall (m : Map bool) (s : state) (p : prec_list) (a : ad),
 MapGet prec_list s a = Some p ->
 pl_non_empty m p = true -> st_non_empty m s = true.

Lemma st_non_empty_1 :
 forall (d : preDTA) (m r : Map bool) (a : ad) (l : state),
 MapGet state d a = Some l ->
 domain_equal state bool d r ->
 st_non_empty m l = true ->
 MapGet bool (dta_app_ne_aux d m r) a = Some true.

Definition dt_non_empty_def_0 (d : preDTA) (a : ad) 
  (t : term) (pr : reconnaissance d a t) :=
  forall n : nat,
  term_high t <= n ->
  MapGet bool (power (Map bool) (dta_app_ne d) (map_mini state d) n) a =
  Some true.

Definition dt_non_empty_def_1 (d : preDTA) (s : state) 
  (t : term) (pr : state_reconnait d s t) :=
  forall n : nat,
  term_high t <= S n ->
  st_non_empty (power (Map bool) (dta_app_ne d) (map_mini state d) n) s =
  true.

Definition dt_non_empty_def_2 (d : preDTA) (p : prec_list) 
  (t : term_list) (pr : liste_reconnait d p t) :=
  forall n : nat,
  term_high_0 t <= n ->
  pl_non_empty (power (Map bool) (dta_app_ne d) (map_mini state d) n) p =
  true.

Lemma dt_non_empty_0 :
 forall (d : preDTA) (a : ad) (t : term) (ladj : state)
   (e : MapGet state d a = Some ladj) (s : state_reconnait d ladj t),
 dt_non_empty_def_1 d ladj t s ->
 dt_non_empty_def_0 d a t (rec_dta d a t ladj e s).

Lemma dt_non_empty_1 :
 forall (d : preDTA) (s : state) (c : ad) (tl : term_list) 
   (l : prec_list) (e : MapGet prec_list s c = Some l)
   (l0 : liste_reconnait d l tl),
 dt_non_empty_def_2 d l tl l0 ->
 dt_non_empty_def_1 d s (app c tl) (rec_st d s c tl l e l0).

Lemma dt_non_empty_2 :
 forall d : preDTA, dt_non_empty_def_2 d prec_empty tnil (rec_empty d).

Lemma dt_non_empty_3 :
 forall (d : preDTA) (a : ad) (la ls : prec_list) (hd : term)
   (tl : term_list) (r : reconnaissance d a hd),
 dt_non_empty_def_0 d a hd r ->
 forall l : liste_reconnait d la tl,
 dt_non_empty_def_2 d la tl l ->
 dt_non_empty_def_2 d (prec_cons a la ls) (tcons hd tl)
   (rec_consi d a la ls hd tl r l).

Lemma dt_non_empty_4 :
 forall (d : preDTA) (a : ad) (la ls : prec_list) (hd : term)
   (tl : term_list) (l : liste_reconnait d ls (tcons hd tl)),
 dt_non_empty_def_2 d ls (tcons hd tl) l ->
 dt_non_empty_def_2 d (prec_cons a la ls) (tcons hd tl)
   (rec_consn d a la ls hd tl l).

Lemma dt_non_empty_5 :
 forall (d : preDTA) (a : ad) (t : term),
 reconnaissance d a t ->
 forall n : nat,
 term_high t <= n ->
 MapGet bool (power (Map bool) (dta_app_ne d) (map_mini state d) n) a =
 Some true.

Lemma dt_non_empty_6 :
 forall (p : preDTA) (p0 : prec_list) (t : term_list)
   (l : liste_reconnait p p0 t), dt_non_empty_def_2 p p0 t l.

Lemma dt_non_empty_d :
 forall (d : preDTA) (a : ad) (t : term),
 reconnaissance d a t ->
 exists n : nat,
   MapGet bool (power (Map bool) (dta_app_ne d) (map_mini state d) n) a =
   Some true.

Lemma dt_non_empty_7 :
 forall (d : preDTA) (p : prec_list) (t : term_list),
 liste_reconnait d p t ->
 pl_non_empty
   (power (Map bool) (dta_app_ne d) (map_mini state d) (term_high_0 t)) p =
 true.

Lemma dt_non_empty_r_0 :
 forall (d : preDTA) (m r : Map bool) (a : ad) (l : state),
 MapGet state d a = Some l ->
 domain_equal state bool d r ->
 MapGet bool (dta_app_ne_aux d m r) a = Some true ->
 MapGet bool r a = Some true \/ st_non_empty m l = true.

Lemma dt_non_empty_r_1 :
 forall (s : state) (m : Map bool),
 st_non_empty m s = true ->
 exists c : ad,
   (exists p : prec_list,
      MapGet prec_list s c = Some p /\ pl_non_empty m p = true).

Lemma dt_non_empty_r_2 :
 forall (p : prec_list) (m : Map bool),
 pl_non_empty m p = true ->
 exists pl : pl_path, pl_path_true pl m /\ pl_path_incl pl p.

Definition dt_non_empty_r_def_0 (n : nat) : Prop :=
  forall (d : preDTA) (a : ad),
  MapGet bool (power (Map bool) (dta_app_ne d) (map_mini state d) n) a =
  Some true -> exists t : term, reconnaissance d a t.

Lemma dt_non_empty_r_3 : dt_non_empty_r_def_0 0.

Lemma dt_non_empty_r_4 :
 forall (p : prec_list) (n : nat) (d : preDTA) (pl : pl_path),
 dt_non_empty_r_def_0 n ->
 pl_path_true pl (power (Map bool) (dta_app_ne d) (map_mini state d) n) ->
 pl_path_incl pl p -> exists tl : term_list, liste_reconnait d p tl.

Lemma dt_non_empty_r_5 :
 forall n : nat, dt_non_empty_r_def_0 n -> dt_non_empty_r_def_0 (S n).

Lemma dt_non_empty_r :
 forall (n : nat) (d : preDTA) (a : ad),
 MapGet bool (power (Map bool) (dta_app_ne d) (map_mini state d) n) a =
 Some true -> exists t : term, reconnaissance d a t.

Lemma dt_non_empty_fix_0 :
 forall d : preDTA,
 lower_fix_point bool (ensemble_base state d) lem (dta_app_ne d)
   (dta_non_empty_states d).

Lemma dt_non_empty_fix_1 :
 forall (d : preDTA) (a : ad) (n : nat),
 MapGet bool (power (Map bool) (dta_app_ne d) (map_mini state d) n) a =
 Some true -> MapGet bool (dta_non_empty_states d) a = Some true.

Lemma dt_non_empty_fix_2 :
 forall (d : preDTA) (a : ad),
 MapGet bool (dta_non_empty_states d) a = Some true ->
 exists n : nat,
   MapGet bool (power (Map bool) (dta_app_ne d) (map_mini state d) n) a =
   Some true.

Lemma dt_non_empty_fix :
 forall (d : preDTA) (a : ad),
 MapGet bool (dta_non_empty_states d) a = Some true <->
 (exists t : term, reconnaissance d a t).

Lemma dt_non_empty_lazy_fix :
 forall (d : preDTA) (a : ad),
 MapGet bool (dta_non_empty_states_lazy d) a = Some true <->
 (exists t : term, reconnaissance d a t). *)

Lemma pl_path_recon_true :
 forall (d : preDTA) (plp : pl_path) (tl : term_list),
 pl_path_recon d tl plp -> pl_path_true plp (dta_non_empty_states d).
Proof.
	intro. simple induction plp. intros. exact (plp_true_nil _).
	intros. inversion H0. elim (dt_non_empty_fix d a). intros.
	apply (plp_true_cons (dta_non_empty_states d) a p (H tl0 H6)). apply H8. split with t. exact H5.
Qed.

Fixpoint prec_list_kill (m : Map bool) (p : prec_list) {struct p} :
 option prec_list :=
  match p with
  | prec_empty => Some prec_empty
  | prec_cons a la ls =>
      match ls with
      | prec_empty =>
          match MapGet bool m a with
          | None => None
          | Some b =>
              if b
              then
               match prec_list_kill m la with
               | None => None
               | Some la' => Some (prec_cons a la' prec_empty)
               end
              else None
          end
      | prec_cons _ _ _ =>
          match MapGet bool m a with
          | None => prec_list_kill m ls
          | Some b =>
              if b
              then
               match prec_list_kill m la, prec_list_kill m ls with
               | None, None => None
               | None, Some ls' => Some ls'
               | Some la', None =>
                   Some (prec_cons a la' prec_empty)
               | Some la', Some ls' => Some (prec_cons a la' ls')
               end
              else prec_list_kill m ls
          end
      end
  end.

Fixpoint states_kill_aux (m : Map bool) (s : state) {struct s} : state :=
  match s with
  | M0 => M0 prec_list
  | M1 a p =>
      match prec_list_kill m p with
      | None => M0 prec_list
      | Some p' => M1 prec_list a p'
      end
  | M2 s0 s1 =>
      match states_kill_aux m s0, states_kill_aux m s1 with
      | M0, M0 => M0 prec_list
      | M0, M1 a p => M1 prec_list (Ndouble_plus_one a) p
      | M1 a p, M0 => M1 prec_list (Ndouble a) p
      | s0', s1' => M2 prec_list s0' s1'
      end
  end.

Definition states_kill (m : Map bool) (s : state) : 
  option state :=
  match states_kill_aux m s with
  | M0 => None
  | x => Some x
  end.

Fixpoint preDTA_kill (m : Map bool) (d : preDTA) {struct d} : preDTA :=
  match d with
  | M0 => M0 state
  | M1 a s =>
      match states_kill m s with
      | None => M0 state
      | Some s' => M1 state a s'
      end
  | M2 d0 d1 =>
      match preDTA_kill m d0, preDTA_kill m d1 with
      | M0, M0 => M0 state
      | M0, M1 a s' => M1 state (Ndouble_plus_one a) s'
      | M1 a s', M0 => M1 state (Ndouble a) s'
      | d0', d1' => M2 state d0' d1'
      end
  end.

Definition DTA_simpl (d : DTA) : DTA :=
  match d with
  | dta p a =>
      match MapGet state p a with
      | None => dta (M1 state N0 (M0 prec_list)) N0
      | _ => dta p a
      end
  end.

Definition DTA_kill (m : Map bool) (d : DTA) : DTA :=
  match d with
  | dta p a => DTA_simpl (dta (preDTA_kill m p) a)
  end.

Definition DTA_kill_empty_states (d : DTA) : DTA :=
  DTA_kill (dta_states_non_empty d) d.

Definition DTA_kill_empty_states_lazy (d : DTA) : DTA :=
  DTA_kill (dta_states_non_empty_lazy d) d.

Lemma kill_empty_states_lazy_eg_kill_empty_states :
 forall d : DTA, DTA_kill_empty_states_lazy d = DTA_kill_empty_states d.
Proof.
	unfold DTA_kill_empty_states_lazy, DTA_kill_empty_states in |- *. intros.
	rewrite (dta_states_non_empty_lazy_eg_dta_states_non_empty d).
	reflexivity.
Qed.

Lemma pl_kill_0 :
 forall (p : prec_list) (m : Map bool) (plp : pl_path),
 pl_path_incl plp p ->
 pl_path_true plp m ->
 exists pl : prec_list,
   prec_list_kill m p = Some pl /\ pl_path_incl plp pl.
Proof.
	simple induction p. intros. elim (pl_sum p1). intro. rewrite H3.
	simpl in |- *. inversion H2. rewrite <- H4 in H1. inversion H1.
	elim H11. reflexivity. rewrite <- H6 in H1. inversion H1.
	rewrite H11 in H5. rewrite H5. elim (H m pl H9 H4). intros.
	elim H14. intros. rewrite H15. split with (prec_cons a x prec_empty). split. reflexivity. exact (pl_path_incl_cons pl a x prec_empty H16). rewrite H3 in H11. inversion H11.
	intros. elim H3. intros. elim H4. intros. elim H5. intros.
	simpl in |- *. rewrite H6. rewrite <- H6. inversion H2. rewrite <- H7 in H1. inversion H1. elim (H14 (refl_equal _)).
	rewrite <- H9 in H1. inversion H1. rewrite H14 in H8.
	rewrite H8. elim (H _ _ H12 H7). intros. elim H17. intros.
	rewrite H18. elim (option_sum prec_list (prec_list_kill m p1)).
	intro y. elim y. intros x3 y0. rewrite y0. split with (prec_cons a x2 x3). split. reflexivity. exact (pl_path_incl_cons pl a x2 x3 H19).
	intro y. rewrite y. split with (prec_cons a x2 prec_empty).
	split. reflexivity. exact (pl_path_incl_cons pl a x2 prec_empty H19). rewrite <- H9 in H2. elim (H0 _ _ H14 H2). intros. elim H17.
	intros. rewrite H18. elim (option_sum bool (MapGet bool m a)); intro y. elim y. intros x3 y0. rewrite y0. elim (bool_is_true_or_false x3); intro; rewrite H20. elim (option_sum prec_list (prec_list_kill m p0)); intros y1. elim y1. intros x4 y2. rewrite y2. split with (prec_cons a x4 x2). split. reflexivity. apply (pl_path_incl_next (pl_path_cons a0 pl) a x4 x2 H19). intro. inversion H21.
	rewrite y1. split with x2. split. reflexivity. assumption.
	split with x2. split. reflexivity. assumption. rewrite y.
	split with x2. split. reflexivity. assumption. intros. simpl in |- *.
	split with prec_empty. split. reflexivity. inversion H.
	exact pl_path_incl_nil.
Qed.

Lemma pl_kill_1 :
 forall (p p' : prec_list) (m : Map bool) (pl : pl_path),
 prec_list_kill m p = Some p' ->
 pl_path_incl pl p' -> pl_path_incl pl p /\ pl_path_true pl m.
Proof.
	simple induction p. intros. elim (pl_sum p1); intros. rewrite H3.
	rewrite H3 in H1. simpl in H1. elim (option_sum bool (MapGet bool m a)); intro y. elim y. intros x y0. rewrite y0 in H1.
	elim (bool_is_true_or_false x); intro; rewrite H4 in H1.
	elim (option_sum prec_list (prec_list_kill m p0)); intro y1.
	elim y1. intros x0 y2. rewrite y2 in H1. inversion H1. rewrite <- H6 in H2. inversion H2. elim (H _ _ _ y2 H8). intros. split.
	apply (pl_path_incl_cons plp a p0 prec_empty). exact H11.
	rewrite H4 in y0. exact (plp_true_cons m a plp H12 y0).
	inversion H9. elim H11. symmetry  in |- *. exact H12. rewrite y1 in H1. inversion H1. inversion H1. rewrite y in H1. inversion H1.
	elim H3. intros. elim H4. intros. elim H5. intros. simpl in H1.
	rewrite H6 in H1. elim (option_sum bool (MapGet bool m a)); intro y. elim y. intros x2 y0. rewrite y0 in H1. rewrite <- H6 in H1.
	elim (bool_is_true_or_false x2); intros; rewrite H7 in H1.
	elim (option_sum prec_list (prec_list_kill m p0)); intro y1;
  elim (option_sum prec_list (prec_list_kill m p1)); 
  intro y2.
	elim y1. intros x3 y3. elim y2. intros x4 y4. rewrite y3 in H1. rewrite y4 in H1. inversion H1. rewrite <- H9 in H2. inversion H2.
	elim (H x3 m plp y3 H11). intros. split. exact (pl_path_incl_cons plp a p0 p1 H14). rewrite H7 in y0. exact (plp_true_cons _ _ _ H15 y0). elim (H0 x4 m pl y4 H12). intros.
	split. apply (pl_path_incl_next pl a p0 p1 H15). assumption.
	exact H16. elim y1. intros x3 y3. rewrite y2 in H1. rewrite y3 in H1.
	inversion H1. rewrite <- H9 in H2. inversion H2. elim (H x3 m plp y3 H11). intros. split. exact (pl_path_incl_cons plp a p0 p1 H14). rewrite H7 in y0. exact (plp_true_cons _ _ _ H15 y0).
	inversion H12. elim (H14 (sym_eq H15)). elim y2.
	intros x3 y3. rewrite y1 in H1. rewrite y3 in H1. inversion H1.
	rewrite <- H9 in H2. elim (H0 x3 m pl y3 H2). intros. split.
	apply (pl_path_incl_next pl a p0 p1 H8). intro. rewrite H11 in H8. inversion H8. rewrite H6 in H13. inversion H13. elim (H13 (refl_equal _)). exact H10. rewrite y1 in H1. 
	rewrite y2 in H1. inversion H1. elim (H0 _ _ _ H1 H2). intros.
	split. apply (pl_path_incl_next pl a p0 p1 H8). intro.
	rewrite H10 in H8. inversion H8. rewrite H6 in H12. inversion H12. elim (H12 (refl_equal _)). exact H9. rewrite y in H1. rewrite <- H6 in H1. elim (H0 _ _ _ H1 H2). intros.
	split. apply (pl_path_incl_next pl a p0 p1). exact H7.
	intro. rewrite H9 in H7. inversion H7. rewrite H6 in H11.
	inversion H11. elim H11. reflexivity. exact H8. intros.
	simpl in H. inversion H. rewrite <- H2 in H0. inversion H0.
	split. exact pl_path_incl_nil. exact (plp_true_nil m).
Qed.

Lemma pl_kill_prec_empty :
 forall (p : prec_list) (m : Map bool),
 prec_list_kill m p = Some prec_empty -> p = prec_empty.
Proof.
	simple induction p. intros. simpl in H1. elim (pl_sum p1); intros.
	rewrite H2 in H1. elim (option_sum bool (MapGet bool m a)); intro y. elim y. intros x y0. rewrite y0 in H1. elim (bool_is_true_or_false x); intros; rewrite H3 in H1.
	elim (option_sum prec_list (prec_list_kill m p0)); intro y1.
	elim y1. intros x0 y2. rewrite y2 in H1. inversion H1. rewrite y1 in H1. inversion H1. inversion H1. rewrite y in H1. inversion H1. elim H2. intros. elim H3. intros. elim H4. intros.
	rewrite H5 in H1. elim (option_sum bool (MapGet bool m a)); intro y. elim y. intros x2 y0. rewrite y0 in H1. elim (bool_is_true_or_false x2). intros. rewrite H6 in H1.
	elim (option_sum prec_list (prec_list_kill m p0)); intro y1.
	elim y1. intros x3 y2. rewrite y2 in H1. elim (option_sum prec_list (prec_list_kill m (prec_cons x x0 x1))); intro y3. elim y3.
	intros x4 y4. rewrite y4 in H1. inversion H1. rewrite y3 in H1.
	inversion H1. rewrite y1 in H1. elim (option_sum prec_list (prec_list_kill m (prec_cons x x0 x1))); intro y2. elim y2.
	intros x4 y3. rewrite y3 in H1. inversion H1. rewrite H8 in y3.
	rewrite <- H5 in y3. rewrite (H0 _ y3) in H5. inversion H5.
	rewrite y2 in H1. inversion H1. intros. rewrite H6 in H1.
	rewrite <- H5 in H1. rewrite (H0 _ H1) in H5. inversion H5.
	rewrite y in H1. rewrite <- H5 in H1. rewrite (H0 _ H1) in H5. inversion H5. intros. reflexivity.
Qed.

Lemma st_kill_0 :
 forall (s : state) (m : Map bool) (a : ad) (p p' : prec_list),
 prec_list_kill m p = Some p' ->
 MapGet prec_list s a = Some p ->
 MapGet prec_list (states_kill_aux m s) a = Some p'.
Proof.
	simple induction s. intros. inversion H0. intros. simpl in H0. elim (bool_is_true_or_false (Neqb a a1)); intros; rewrite H1 in H0.
	inversion H0. simpl in |- *. rewrite H. simpl in |- *. rewrite H1. reflexivity.
	inversion H0. intros. simpl in |- *. simpl in H2. simpl in |- *. elim (map_sum prec_list (states_kill_aux m1 m)). intro. rewrite H3. elim (map_sum prec_list (states_kill_aux m1 m0)). intro. rewrite H4.
	induction  a as [| p0]. rewrite <- (H _ _ _ _ H1 H2). rewrite H3. reflexivity.
	induction  p0 as [p0 Hrecp0| p0 Hrecp0| ]. rewrite <- (H0 _ _ _ _ H1 H2). rewrite H4.
	reflexivity. rewrite <- (H _ _ _ _ H1 H2). rewrite H3. reflexivity.
	rewrite <- (H0 _ _ _ _ H1 H2). rewrite H4. reflexivity. intro.
	elim H4. intros. elim H5. intros. elim H6. intros. rewrite H7.
	induction  a as [| p0]. cut (MapGet prec_list (states_kill_aux m1 m) N0 = Some p'). intro. rewrite H3 in H8. inversion H8.
	exact (H _ _ _ _ H1 H2). induction  p0 as [p0 Hrecp0| p0 Hrecp0| ]. rewrite <- (H0 _ _ _ _ H1 H2). rewrite H7. simpl in |- *. elim (bool_is_true_or_false (Neqb x (Npos p0))). intro. rewrite H8. rewrite (Neqb_complete _ _ H8). simpl in |- *. rewrite (aux_Neqb_1_0 p0). reflexivity. intro.
	rewrite H8. elim (bool_is_true_or_false (Neqb (Ndouble_plus_one x) (Npos (xI p0)))). intro. rewrite (Ndouble_plus_one_inv_xI _ _ (Neqb_complete _ _ H9)) in H8. rewrite (Neqb_correct (Npos p0)) in H8. inversion H8. intro. rewrite H9. reflexivity.
	rewrite <- (H _ _ _ _ H1 H2). rewrite H3. induction  x as [| p1]. simpl in |- *.
	reflexivity. simpl in |- *. reflexivity. rewrite <- (H0 _ _ _ _ H1 H2).
	simpl in |- *. rewrite H7. simpl in |- *. elim (bool_is_true_or_false (Neqb (Ndouble_plus_one x) (Npos 1))); intro;
  rewrite H8. elim (bool_is_true_or_false (Neqb x N0)); intro; rewrite H9.
	reflexivity. rewrite (Ndouble_plus_one_inv_xH _ (Neqb_complete _ _ H8)) in H9. rewrite (Neqb_correct N0) in H9. inversion H9.
	elim (bool_is_true_or_false (Neqb x N0)); intro; rewrite H9.
	rewrite (Neqb_complete _ _ H9) in H8. inversion H8. 
	reflexivity. intros. elim H5. intros. elim H6. intros.
	rewrite H7. induction  a as [| p0]. rewrite <- (H _ _ _ _ H1 H2).
	rewrite H3. simpl in |- *. reflexivity. induction  p0 as [p0 Hrecp0| p0 Hrecp0| ]. rewrite <- H7.
	simpl in |- *. exact (H0 _ _ _ _ H1 H2). rewrite <- (H _ _ _ _ H1 H2).
	rewrite H3. reflexivity. rewrite <- (H0 _ _ _ _ H1 H2). simpl in |- *.
	rewrite H7. simpl in |- *. reflexivity. intros. elim H3. intros.
	elim H4. intros. elim H5. intros. rewrite H6. elim (map_sum prec_list (states_kill_aux m1 m0)); intro. rewrite H7. induction  a as [| p0]. rewrite <- (H _ _ _ _ H1 H2). rewrite H6. simpl in |- *. elim (bool_is_true_or_false (Neqb (Ndouble x) N0)); intro; rewrite H8. elim (bool_is_true_or_false (Neqb x N0)); intro; rewrite H9. reflexivity. rewrite (Ndouble_inv_N0 _ (Neqb_complete _ _ H8)) in H9. inversion H9. elim (bool_is_true_or_false (Neqb x N0)); intro; rewrite H9.
	rewrite (Neqb_complete _ _ H9) in H8. inversion H8.
	reflexivity. induction  p0 as [p0 Hrecp0| p0 Hrecp0| ]. rewrite <- (H0 _ _ _ _ H1 H2).
	rewrite H7. induction  x as [| p1]; simpl in |- *. reflexivity. reflexivity.
	rewrite <- (H _ _ _ _ H1 H2). rewrite H6. simpl in |- *.
	elim (bool_is_true_or_false (Neqb (Ndouble x) (Npos (xO p0)))); intro;
  rewrite H8. elim (bool_is_true_or_false (Neqb x (Npos p0))); intro; rewrite H9. reflexivity. rewrite (Ndouble_inv_xO _ _ (Neqb_complete _ _ H8)) in H9. rewrite (Neqb_correct (Npos p0)) in H9. inversion H9. elim (bool_is_true_or_false (Neqb x (Npos p0))); intro; rewrite H9. rewrite (Neqb_complete _ _ H9) in H8. simpl in H8. rewrite (aux_Neqb_1_0 p0) in H8. inversion H8.
	reflexivity. rewrite <- (H0 _ _ _ _ H1 H2). rewrite H7. simpl in |- *.
	induction  x as [| p0]; reflexivity. elim H7. intros. elim H8. intros.
	elim H9. intros. rewrite H10. induction  a as [| p0]. unfold MapGet in |- *.
	rewrite <- (H _ _ _ _ H1 H2). simpl in |- *. rewrite H6. reflexivity.
	induction  p0 as [p0 Hrecp0| p0 Hrecp0| ]. simpl in |- *. rewrite <- (H0 _ _ _ _ H1 H2).
	rewrite H10. reflexivity. rewrite <- (H _ _ _ _ H1 H2).
	rewrite H6. simpl in |- *. reflexivity. rewrite <- (H0 _ _ _ _ H1 H2).
	simpl in |- *. rewrite H10. reflexivity. intros. elim H8. intros.
	elim H9. intros. rewrite H10. induction  a as [| p0]. rewrite <- (H _ _ _ _ H1 H2). rewrite H6. reflexivity. induction  p0 as [p0 Hrecp0| p0 Hrecp0| ].
	rewrite <- (H0 _ _ _ _ H1 H2). rewrite H10. reflexivity.
	rewrite <- (H _ _ _ _ H1 H2). rewrite H6. reflexivity.
	rewrite <- (H0 _ _ _ _ H1 H2). rewrite H10. reflexivity.
	intros. elim H4. intros. elim H5. intros. rewrite H6.
	rewrite <- H6. induction  a as [| p0]. simpl in |- *. exact (H _ _ _ _ H1 H2).
	induction  p0 as [p0 Hrecp0| p0 Hrecp0| ]; simpl in |- *. exact (H0 _ _ _ _ H1 H2).
	exact (H _ _ _ _ H1 H2). exact (H0 _ _ _ _ H1 H2).
Qed.

Lemma st_kill_1 :
 forall (s : state) (m : Map bool) (a : ad) (p p' : prec_list),
 prec_list_kill m p = Some p' ->
 MapGet prec_list s a = Some p ->
 exists s' : state,
   states_kill m s = Some s' /\
   MapGet prec_list s' a = Some p'.
Proof.
	intros. unfold states_kill in |- *. elim (map_sum prec_list (states_kill_aux m s)); intros. cut (MapGet prec_list (states_kill_aux m s) a = Some p'). intro.
	rewrite H1 in H2. inversion H2. exact (st_kill_0 _ _ _ _ _ H H0). elim H1. intros. elim H2. intros. elim H3.
	intros. rewrite H4. split with (states_kill_aux m s).
	rewrite <- H4. split. reflexivity. exact (st_kill_0 _ _ _ _ _ H H0). intros. elim H2. intros. elim H3.
	intros. rewrite H4. rewrite <- H4. split with (states_kill_aux m s). split. reflexivity.
	exact (st_kill_0 _ _ _ _ _ H H0).
Qed.

Lemma st_kill_2 :
 forall (s : state) (m : Map bool) (a : ad) (p : prec_list),
 MapGet prec_list (states_kill_aux m s) a = Some p ->
 exists p' : prec_list,
   MapGet prec_list s a = Some p' /\
   prec_list_kill m p' = Some p.
Proof.
	simple induction s. intros. inversion H. intros. simpl in H.
	elim (option_sum prec_list (prec_list_kill m a0)).
	intro y. elim y. intros x y0. rewrite y0 in H. simpl in H.
	elim (bool_is_true_or_false (Neqb a a1)); intros; rewrite H0 in H. simpl in |- *. rewrite H0. inversion H. split with a0.
	split. reflexivity. rewrite H2 in y0. exact y0. inversion H. intro y. rewrite y in H. inversion H. intros. simpl in H1. elim (map_sum prec_list (states_kill_aux m1 m)); intros. rewrite H2 in H1. elim (map_sum prec_list (states_kill_aux m1 m0)); intros. rewrite H3 in H1.
	inversion H1. elim H3. intros. elim H4. intros. elim H5.
	intros. rewrite H6 in H1. induction  a as [| p0]. induction  x as [| p0]; inversion H1. induction  p0 as [p0 Hrecp0| p0 Hrecp0| ]. elim (H0 m1 (Npos p0) p).
	intros. elim H7. intros. split with x1. simpl in |- *. split; assumption. simpl in H1. rewrite H6. simpl in |- *. elim (bool_is_true_or_false (Neqb (Ndouble_plus_one x) (Npos (xI p0))));
  intros; rewrite H7 in H1. inversion H1. rewrite (Ndouble_plus_one_inv_xI _ _ (Neqb_complete _ _ H7)). rewrite (Neqb_correct (Npos p0)). reflexivity.
	inversion H1. simpl in H1. induction  x as [| p1]; inversion H1.
	elim (H0 m1 N0 p). intros. elim H7. intros. split with x1. simpl in |- *. split; assumption. rewrite H6. simpl in |- *. simpl in H1. elim (bool_is_true_or_false (Neqb (Ndouble_plus_one x) (Npos 1))); intros;
  rewrite H7 in H1. inversion H1.
	elim (bool_is_true_or_false (Neqb x N0)); intros; rewrite H8. reflexivity. rewrite (Ndouble_plus_one_inv_xH _ (Neqb_complete _ _ H7)) in H8. inversion H8. inversion H1. intros. elim H4. intros. elim H5. intros. rewrite H6 in H1. induction  a as [| p0]. inversion H1. rewrite <- H6 in H1.
	induction  p0 as [p0 Hrecp0| p0 Hrecp0| ]; simpl in H1. elim (H0 _ _ _ H1). intros.
	elim H7. intros. split with x1. simpl in |- *. split; assumption.
	inversion H1. elim (H0 _ _ _ H1). intros. elim H7.
	intros. split with x1. simpl in |- *. split; assumption.
	elim H2. intros. elim H3. intros. elim H4. intros.
	rewrite H5 in H1. elim (map_sum prec_list (states_kill_aux m1 m0)); intros. rewrite H6 in H1. induction  a as [| p0]. simpl in H1.
	simpl in |- *. elim (bool_is_true_or_false (Neqb (Ndouble x) N0)); intros;
  rewrite H7 in H1. inversion H1. apply (H m1 N0 p). rewrite H5. simpl in |- *. elim (bool_is_true_or_false (Neqb x N0)); intros; rewrite H8. rewrite H9. reflexivity.
	rewrite (Ndouble_inv_N0 _ (Neqb_complete _ _ H7)) in H8.
	inversion H8. inversion H1. induction  p0 as [p0 Hrecp0| p0 Hrecp0| ]. induction  x as [| p1]; inversion H1. simpl in H1. simpl in |- *. elim (bool_is_true_or_false (Neqb (Ndouble x) (Npos (xO p0)))); intros;
  rewrite H7 in H1. inversion H1. apply (H m1 (Npos p0) p). rewrite H5.
	simpl in |- *. elim (bool_is_true_or_false (Neqb x (Npos p0))); intros; rewrite H8. rewrite H9. reflexivity. rewrite (Ndouble_inv_xO _ _ (Neqb_complete _ _ H7)) in H8.
	rewrite (Neqb_correct (Npos p0)) in H8. inversion H8.
	inversion H1. induction  x as [| p0]; inversion H1. elim H6; intros; elim H7; intros; elim H8; intros. rewrite H9 in H1.
	induction  a as [| p0]. simpl in |- *. simpl in H1. apply (H m1 N0 p).
	rewrite H5. simpl in |- *. exact H1. induction  p0 as [p0 Hrecp0| p0 Hrecp0| ]; simpl in |- *; simpl in H1. apply (H0 m1 (Npos p0) p). rewrite H9. simpl in |- *.
	exact H1. apply (H m1 (Npos p0) p). rewrite H5. simpl in |- *.
	exact H1. apply (H0 m1 N0 p). rewrite H9. exact H1.
	rewrite H9 in H1. rewrite <- H9 in H1. induction  a as [| p0].
	simpl in H1. simpl in |- *. apply (H m1 N0 p). rewrite H5.
	simpl in |- *. exact H1. induction  p0 as [p0 Hrecp0| p0 Hrecp0| ]; simpl in |- *; simpl in H1.
	apply (H0 m1 (Npos p0) p). rewrite H9. rewrite H9 in H1.
	exact H1. apply (H m1 (Npos p0) p). rewrite H5. simpl in |- *.
	exact H1. apply (H0 m1 N0 p). rewrite H9. simpl in |- *.
	rewrite H9 in H1. simpl in H1. exact H1. intros.
	elim H3. intros. elim H4. intros. rewrite H5 in H1.
	rewrite <- H5 in H1. induction  a as [| p0]. simpl in |- *. simpl in H1.
	exact (H _ _ _ H1). induction  p0 as [p0 Hrecp0| p0 Hrecp0| ]; simpl in |- *; simpl in H1.
	exact (H0 _ _ _ H1). exact (H _ _ _ H1). exact (H0 _ _ _ H1).
Qed.

Lemma st_kill_3 :
 forall (s' s : state) (m : Map bool),
 states_kill_aux m s = s' ->
 s' <> M0 prec_list ->
 exists p : prec_list,
   (exists a : ad, MapGet prec_list s' a = Some p).
Proof.
	simple induction s'. intros. elim (H0 (refl_equal _)).
	intros. elim (map_sum prec_list s); intros. rewrite H1 in H. simpl in H. inversion H. elim H1; intros; elim H2; intros; elim H3; intros; rewrite H4 in H. simpl in H.
	elim (option_sum prec_list (prec_list_kill m x0)); intro y.
	elim y. intros x1 y0; rewrite y0 in H. inversion H. split with a0.
	split with a. simpl in |- *. rewrite (Neqb_correct a). reflexivity.
	rewrite y in H. inversion H. simpl in H. elim (map_sum prec_list (states_kill_aux m x)); intros. rewrite H5 in H.
	elim (map_sum prec_list (states_kill_aux m x0)); intros.
	rewrite H6 in H. inversion H. elim H6; intros; elim H7; intros; elim H8; intros; rewrite H9 in H. inversion H.
	split with a0. split with (Ndouble_plus_one x1). simpl in |- *.
	rewrite (Neqb_correct (Ndouble_plus_one x1)). reflexivity.
	inversion H. elim H5; intros; elim H6; intros; elim H7; intros; rewrite H8 in H. elim (map_sum prec_list (states_kill_aux m x0)); intros. rewrite H9 in H. inversion H.
	split with a0. split with (Ndouble x1). simpl in |- *. rewrite (Neqb_correct (Ndouble x1)). reflexivity. elim H9; intros; elim H10; intros; elim H11; intros; rewrite H12 in H.
	inversion H. inversion H. inversion H. intros. elim (map_sum prec_list s). intros. rewrite H3 in H1. simpl in H1. inversion H1. intros. elim H3; intros; elim H4; intros; elim H5; intros; rewrite H6 in H1. simpl in H1. elim (option_sum prec_list (prec_list_kill m1 x0)); intro y. elim y. intros x1 y0. rewrite y0 in H1. inversion H1. rewrite y in H1. inversion H1. simpl in H1. elim (map_sum prec_list (states_kill_aux m1 x)); intros.
	rewrite H7 in H1. elim (map_sum prec_list (states_kill_aux m1 x0)); intros. rewrite H8 in H1. inversion H1. elim H8; intros; elim H9; intros; elim H10; intros; rewrite H11 in H1. 
	inversion H1. inversion H1. elim (H0 x0 m1). intros. elim H12.
	intros. split with x3. split with (Ndouble_plus_one x4).
	rewrite H14. induction  x4 as [| p]; simpl in |- *; exact H15. rewrite H14 in H11. exact H11. intro. rewrite <- H14 in H12. inversion H12.
	elim H7; intros; elim H8; intros; elim H9; intros; rewrite H10 in H1. elim (map_sum prec_list (states_kill_aux m1 x0)); intros.
	rewrite H11 in H1. inversion H1. elim H11; intros; elim H12; intros; elim H13; intros; rewrite H14 in H1. inversion H1.
	elim (H x m1). intros. elim H15. intros. split with x5.
	split with (Ndouble x6). rewrite <- H16 in H18. simpl in H18. induction  x6 as [| p]; simpl in |- *; exact H18. rewrite H16 in H10.
	exact H10. intro. rewrite <- H16 in H15. inversion H15.
	inversion H1. elim (H x m1); intros. elim H15. intros.
	split with x5. split with (Ndouble x6). rewrite <- H16 in H18. simpl in H18. induction  x6 as [| p]; simpl in |- *; exact H18.
	rewrite H16 in H10. exact H10. intro. rewrite <- H16 in H15. inversion H15. inversion H1. elim (H x m1). intros.
	elim H11. intros. split with x3. split with (Ndouble x4).
	rewrite <- H12 in H14. simpl in H14. induction  x4 as [| p]; simpl in |- *; exact H14. rewrite <- H12. assumption. intro. rewrite <- H12 in H11. inversion H11.
Qed.

Lemma st_kill_4 :
 forall (s s' : state) (m : Map bool),
 states_kill m s = Some s' ->
 exists p : prec_list,
   (exists a : ad, MapGet prec_list s' a = Some p).
Proof.
	unfold states_kill in |- *. intros. elim (map_sum prec_list (states_kill_aux m s)); intros. rewrite H0 in H.
	inversion H. elim H0; intros; elim H1; intros; elim H2; intros; rewrite H3 in H. inversion H. apply (st_kill_3 _ _ _ H3). intro. inversion H4. inversion H. apply (st_kill_3 _ _ _ H3). intro. inversion H4.
Qed.

Lemma dt_kill_0 :
 forall (d : preDTA) (m : Map bool) (a : ad) (s s' : state),
 states_kill m s = Some s' ->
 MapGet state d a = Some s ->
 MapGet state (preDTA_kill m d) a = Some s'.
Proof.
	simple induction d. intros. inversion H0. intros. simpl in H0.
	elim (bool_is_true_or_false (Neqb a a1)); intros; rewrite H1 in H0. simpl in |- *. inversion H0. rewrite H.
	simpl in |- *. rewrite H1. reflexivity. inversion H0. intros.
	simpl in |- *. simpl in H2. elim (map_sum state (preDTA_kill m1 m)); intros. rewrite H3. elim (map_sum state (preDTA_kill m1 m0)); intro. rewrite H4. induction  a as [| p].
	rewrite <- (H _ _ _ _ H1 H2). rewrite H3. reflexivity.
	induction  p as [p Hrecp| p Hrecp| ]. rewrite <- (H0 _ _ _ _ H1 H2). rewrite H4.
	reflexivity. rewrite <- (H _ _ _ _ H1 H2). rewrite H3.
	reflexivity. rewrite <- (H0 _ _ _ _ H1 H2). rewrite H4.
	reflexivity. elim H4. intros. elim H5. intros. elim H6.
	intros. rewrite H7. induction  a as [| p]. rewrite <- (H _ _ _ _ H1 H2). rewrite H3. simpl in |- *. induction  x as [| p]; reflexivity.
	induction  p as [p Hrecp| p Hrecp| ]. rewrite <- (H0 _ _ _ _ H1 H2). simpl in |- *.
	rewrite H7. simpl in |- *. elim (bool_is_true_or_false (Neqb (Ndouble_plus_one x) (Npos (xI p))));
  intros; rewrite H8.
	elim (bool_is_true_or_false (Neqb x (Npos p))); intros; rewrite H9. reflexivity. rewrite (Ndouble_plus_one_inv_xI _ _ (Neqb_complete _ _ H8)) in H9. rewrite (Neqb_correct (Npos p)) in H9. inversion H9. elim (bool_is_true_or_false (Neqb x (Npos p))); intros. rewrite H9. rewrite (Neqb_complete _ _ H9) in H8. simpl in H8. rewrite (aux_Neqb_1_0 p) in H8. inversion H8. rewrite H9.
	reflexivity. rewrite <- (H _ _ _ _ H1 H2). rewrite H3.
	simpl in |- *. induction  x as [| p0]; reflexivity. rewrite <- (H0 _ _ _ _ H1 H2). rewrite H7. simpl in |- *. elim (bool_is_true_or_false (Neqb (Ndouble_plus_one x) (Npos 1))); intros;
  rewrite H8. elim (bool_is_true_or_false (Neqb x N0)); intros; rewrite H9. reflexivity. rewrite (Ndouble_plus_one_inv_xH _ (Neqb_complete _ _ H8)) in H9. rewrite (Neqb_correct N0) in H9. inversion H9. elim (bool_is_true_or_false (Neqb x N0)); intro; rewrite H9. rewrite (Neqb_complete _ _ H9) in H8. simpl in H8. inversion H8. reflexivity.
	intros. elim H5. intros. elim H6. intros. rewrite H7.
	induction  a as [| p]. rewrite <- (H _ _ _ _ H1 H2). rewrite H3.
	reflexivity. induction  p as [p Hrecp| p Hrecp| ]. rewrite <- (H0 _ _ _ _ H1 H2).
	rewrite H7. reflexivity. rewrite <- (H _ _ _ _ H1 H2).
	rewrite H3. reflexivity. rewrite <- (H0 _ _ _ _ H1 H2).
	rewrite H7. reflexivity. elim H3. intros. elim H4.
	intros. elim H5. intros. rewrite H6. elim (map_sum state (preDTA_kill m1 m0)); intros. rewrite H7. induction  a as [| p].
	rewrite <- (H _ _ _ _ H1 H2). rewrite H6. simpl in |- *.
	elim (bool_is_true_or_false (Neqb (Ndouble x) N0)); intros; rewrite H8. elim (bool_is_true_or_false (Neqb x N0)); intros; rewrite H9. reflexivity. rewrite (Ndouble_inv_N0 _ (Neqb_complete _ _ H8)) in H9.
	rewrite (Neqb_correct N0) in H9. inversion H9. elim (bool_is_true_or_false (Neqb x N0)); intros; rewrite H9.
	rewrite (Neqb_complete _ _ H9) in H8. simpl in H8. inversion H8. reflexivity. induction  p as [p Hrecp| p Hrecp| ]. rewrite <- (H0 _ _ _ _ H1 H2).
	rewrite H7. induction  x as [| p0]; reflexivity. rewrite <- (H _ _ _ _ H1 H2). rewrite H6. simpl in |- *. elim (bool_is_true_or_false (Neqb (Ndouble x) (Npos (xO p)))); intros;
  rewrite H8.
	elim (bool_is_true_or_false (Neqb x (Npos p))); intros; rewrite H9. reflexivity. rewrite (Ndouble_inv_xO _ _ (Neqb_complete _ _ H8)) in H9. rewrite (Neqb_correct (Npos p)) in H9. inversion H9. elim (bool_is_true_or_false (Neqb x (Npos p))); intros; rewrite H9. rewrite (Neqb_complete _ _ H9) in H8. simpl in H8. rewrite (aux_Neqb_1_0 p) in H8. inversion H8. reflexivity.
	rewrite <- (H0 _ _ _ _ H1 H2). rewrite H7. induction  x as [| p]; reflexivity. elim H7. intros. elim H8. intros. elim H9.
	intros. rewrite H10. induction  a as [| p]. simpl in |- *. rewrite <- (H _ _ _ _ H1 H2). rewrite H6. reflexivity. induction  p as [p Hrecp| p Hrecp| ].
	rewrite <- (H0 _ _ _ _ H1 H2). rewrite H10. reflexivity.
	rewrite <- (H _ _ _ _ H1 H2). rewrite H6. reflexivity.
	rewrite <- (H0 _ _ _ _ H1 H2). rewrite H10. reflexivity.
	intros. elim H8. intros. elim H9. intros. rewrite H10.
	rewrite <- H10. induction  a as [| p]. rewrite <- (H _ _ _ _ H1 H2).
	rewrite H6. reflexivity. induction  p as [p Hrecp| p Hrecp| ]. rewrite <- (H0 _ _ _ _ H1 H2). rewrite H10. reflexivity. rewrite <- (H _ _ _ _ H1 H2). rewrite H6. reflexivity. rewrite <- (H0 _ _ _ _ H1 H2). rewrite H10. reflexivity. intros. elim H4. intros.
	elim H5. intros. rewrite H6. induction  a as [| p]. rewrite <- (H _ _ _ _ H1 H2). rewrite H6. reflexivity. induction  p as [p Hrecp| p Hrecp| ].
	exact (H0 _ _ _ _ H1 H2). rewrite <- (H _ _ _ _ H1 H2).
	rewrite H6. reflexivity. exact (H0 _ _ _ _ H1 H2).
Qed.

Lemma dt_kill_1 :
 forall (d : preDTA) (m : Map bool) (a : ad) (s : state),
 MapGet state (preDTA_kill m d) a = Some s ->
 exists s' : state,
   MapGet state d a = Some s' /\ states_kill m s' = Some s.
Proof.
	simple induction d. intros. inversion H. intros. simpl in H.
	simpl in |- *. elim (option_sum state (states_kill m a0)); intro y.
	elim y. intros x y0. rewrite y0 in H. simpl in H. elim (bool_is_true_or_false (Neqb a a1)); intros; rewrite H0 in H;
  rewrite H0. inversion H. split with a0. split. reflexivity.
	rewrite H2 in y0. exact y0. inversion H. rewrite y in H.
	inversion H. intros. simpl in H1. elim (map_sum state (preDTA_kill m1 m)); intros. rewrite H2 in H1. elim (map_sum state (preDTA_kill m1 m0)); intros. rewrite H3 in H1.
	inversion H1. elim H3. intros. elim H4. intros. elim H5.
	intros. rewrite H6 in H1. induction  a as [| p]. simpl in H1.
	induction  x as [| p]; inversion H1. induction  p as [p Hrecp| p Hrecp| ]; simpl in |- *; simpl in H1.
	apply (H0 m1 (Npos p) s). rewrite H6. simpl in |- *. elim (bool_is_true_or_false (Neqb (Ndouble_plus_one x) (Npos (xI p))));
  intros; rewrite H7 in H1. inversion H1. elim (bool_is_true_or_false (Neqb x (Npos p))); intros; rewrite H8. reflexivity. rewrite (Ndouble_plus_one_inv_xI _ _ (Neqb_complete _ _ H7)) in H8. rewrite (Neqb_correct (Npos p)) in H8. inversion H8. inversion H1. induction  x as [| p0]; inversion H1. apply (H0 m1 N0 s). rewrite H6. simpl in |- *. elim (bool_is_true_or_false (Neqb (Ndouble_plus_one x) (Npos 1))); intros;
  rewrite H7 in H1. inversion H1. elim (bool_is_true_or_false (Neqb x N0)); intros; rewrite H8.
	reflexivity. rewrite (Ndouble_plus_one_inv_xH _ (Neqb_complete _ _ H7)) in H8. inversion H8. inversion H1.
	intros. elim H4. intros. elim H5. intros. rewrite H6 in H1.
	induction  a as [| p]. inversion H1. rewrite <- H6 in H1. induction  p as [p Hrecp| p Hrecp| ]; simpl in |- *; simpl in H1. apply (H0 m1 (Npos p) s). rewrite H6.
	rewrite H6 in H1. exact H1. inversion H1. exact (H0 _ _ _ H1). elim H2. intros. elim H3. intros. elim H4. intros.
	rewrite H5 in H1. elim (map_sum state (preDTA_kill m1 m0)); intros. rewrite H6 in H1. induction  a as [| p]. simpl in |- *. simpl in H1.
	apply (H m1 N0 s). rewrite H5. simpl in |- *. elim (bool_is_true_or_false (Neqb (Ndouble x) N0)); intros;
  rewrite H7 in H1. inversion H1. elim (bool_is_true_or_false (Neqb x N0)); intros; rewrite H8. reflexivity. rewrite (Ndouble_inv_N0 _ (Neqb_complete _ _ H7)) in H8.
	inversion H8. inversion H1. induction  p as [p Hrecp| p Hrecp| ]; simpl in |- *; simpl in H1.
	induction  x as [| p0]; inversion H1. elim (bool_is_true_or_false (Neqb (Ndouble x) (Npos (xO p)))); intros;
  rewrite H7 in H1.
	inversion H1. apply (H m1 (Npos p) s). rewrite H5. simpl in |- *.
	elim (bool_is_true_or_false (Neqb x (Npos p))); intros; rewrite H8. assumption. rewrite (Ndouble_inv_xO _ _ (Neqb_complete _ _ H7)) in H8. rewrite (Neqb_correct (Npos p)) in H8. inversion H8. inversion H1. induction  x as [| p]; inversion H1. elim H6; intros; elim H7; intros; elim H8; intros; rewrite H9 in H1. rewrite <- H9 in H1. induction  a as [| p].
	simpl in |- *. rewrite <- H5 in H1. simpl in H1. exact (H _ _ _ H1).
	rewrite <- H5 in H1. induction  p as [p Hrecp| p Hrecp| ]; simpl in |- *; simpl in H1. exact (H0 _ _ _ H1). exact (H _ _ _ H1). exact (H0 _ _ _ H1).
	rewrite <- H9 in H1. rewrite <- H5 in H1. induction  a as [| p].
	simpl in |- *. simpl in H1. exact (H _ _ _ H1). induction  p as [p Hrecp| p Hrecp| ]; simpl in |- *; simpl in H1. exact (H0 _ _ _ H1). exact (H _ _ _ H1).
	exact (H0 _ _ _ H1). intros. elim H3. intros. elim H4.
	intros. rewrite H5 in H1. rewrite <- H5 in H1. induction  a as [| p].
	simpl in |- *. simpl in H1. exact (H _ _ _ H1). induction  p as [p Hrecp| p Hrecp| ]; simpl in |- *; simpl in H1. exact (H0 _ _ _ H1). exact (H _ _ _ H1).
	exact (H0 _ _ _ H1).
Qed.

Definition dt_kill_empty_def_0 (n : nat) : Prop :=
  forall (d : preDTA) (a : ad) (t : term),
  term_high t <= n ->
  reconnaissance d a t ->
  reconnaissance (preDTA_kill (dta_non_empty_states d) d) a t.

Lemma dt_kill_empty_d_0 : dt_kill_empty_def_0 0.
Proof.
	unfold dt_kill_empty_def_0 in |- *. intros. induction  t as (a0, t). simpl in H.
	elim (le_Sn_O _ H).
Qed.

Lemma dt_kill_empty_d_1 :
 forall (n : nat) (d : preDTA) (p : prec_list) (tl : term_list),
 dt_kill_empty_def_0 n ->
 term_high_0 tl <= n ->
 liste_reconnait d p tl ->
 exists p' : prec_list,
   prec_list_kill (dta_non_empty_states d) p = Some p' /\
   liste_reconnait (preDTA_kill (dta_non_empty_states d) d) p' tl.
Proof.
	simple induction p. intros. inversion H3. elim (pl_sum p1); intros.
	rewrite H11. simpl in |- *. elim (dt_non_empty_fix d a). intros.
	rewrite H13. elim (H tl0 H1). intros. elim H14. intros.
	rewrite H15. split with (prec_cons a x prec_empty). split.
	reflexivity. apply
  (rec_consi (preDTA_kill (dta_non_empty_states d) d) a x prec_empty hd tl0). rewrite <- H7 in H2. exact (H1 d a hd (le_trans _ _ _ (le_max_l _ _) H2) H9). exact H16.
	rewrite <- H7 in H2. exact
  (le_trans (term_high_0 tl0) (term_high_0 (tcons hd tl0)) n 
     (le_max_r _ _) H2). exact H10.
	split with hd. exact H9. elim H11. intros. elim H12. intros.
	elim H13. intros. simpl in |- *. rewrite H14. rewrite <- H14. elim (dt_non_empty_fix d a). intros. rewrite H16. rewrite <- H7 in H2. elim (H tl0 H1 (le_trans _ _ _ (le_max_r _ _) H2) H10).
	intros. elim H17. intros. rewrite H18. elim (option_sum prec_list (prec_list_kill (dta_non_empty_states d) p1));
  intro y. elim y.
	intros x3 y0. rewrite y0. split with (prec_cons a x2 x3). split.
	reflexivity. exact
  (rec_consi (preDTA_kill (dta_non_empty_states d) d) a x2 x3 hd tl0
     (H1 d a hd (le_trans _ _ _ (le_max_l _ _) H2) H9) H19). rewrite y. split with (prec_cons a x2 prec_empty).
	split. reflexivity. exact
  (rec_consi (preDTA_kill (dta_non_empty_states d) d) a x2 prec_empty hd tl0
     (H1 d a hd (le_trans _ _ _ (le_max_l _ _) H2) H9) H19). split with hd. exact H9. rewrite <- H6 in H2. elim (H0 (tcons hd tl0) H1 H2 H9). intros. elim H10. intros. elim (pl_sum p1); intros.
	rewrite H13 in H9. inversion H9. elim H13. intros. elim H14.
	intros. intros. elim H15. intros. simpl in |- *. rewrite H16. rewrite <- H16. rewrite H11. elim (option_sum bool (MapGet bool (dta_non_empty_states d) a)). intro y. elim y. intros x3 y0. rewrite y0. elim (bool_is_true_or_false x3); intros; rewrite H17.
	elim (option_sum prec_list (prec_list_kill (dta_non_empty_states d) p0));
  intro y1. elim y1. intros x4 y2. rewrite y2. split with (prec_cons a x4 x). split. reflexivity. exact (rec_consn (preDTA_kill (dta_non_empty_states d) d) a x4 x hd tl0 H12).
	rewrite y1. split with x. split. reflexivity. exact H12.
	split with x. split. reflexivity. exact H12. intro y.
	rewrite y. split with x. split. reflexivity. exact H12.
	intros. inversion H1. split with prec_empty. split.
	reflexivity. exact (rec_empty _).
Qed.

Lemma dt_kill_empty_d_2 :
 forall n : nat, dt_kill_empty_def_0 n -> dt_kill_empty_def_0 (S n).
Proof.
	unfold dt_kill_empty_def_0 in |- *. intros. inversion H1.
	inversion H3. rewrite <- H11 in H0. simpl in H0.
	fold term_high_0 in H0. elim (dt_kill_empty_d_1 n d l tl H (le_S_n _ _ H0) H8). intros. elim H12. intros.
	apply
  (rec_dta (preDTA_kill (dta_non_empty_states d) d) a 
     (app c tl) (states_kill_aux (dta_non_empty_states d) ladj)). elim (st_kill_1 _ _ _ _ _ H13 H7). intros.
	elim H15. intros. apply
  (dt_kill_0 d (dta_non_empty_states d) a ladj
     (states_kill_aux (dta_non_empty_states d) ladj)).
	unfold states_kill in |- *. elim (map_sum prec_list (states_kill_aux (dta_non_empty_states d) ladj));
  intros. unfold states_kill in H16. rewrite H18 in H16. inversion H16. elim H18; intros; elim H19; intros; elim H20; intros; rewrite H21;
  reflexivity. exact H2. apply
  (rec_st (preDTA_kill (dta_non_empty_states d) d)
     (states_kill_aux (dta_non_empty_states d) ladj) c tl x). exact (st_kill_0 ladj (dta_non_empty_states d) c l x H13 H7). exact H14.
Qed.

Lemma dt_kill_empty_d_3 : forall n : nat, dt_kill_empty_def_0 n.
Proof.
	exact (nat_ind dt_kill_empty_def_0 dt_kill_empty_d_0 dt_kill_empty_d_2).
Qed.

Lemma dt_kill_empty_d :
 forall (d : preDTA) (a : ad) (t : term),
 reconnaissance d a t ->
 reconnaissance (preDTA_kill (dta_non_empty_states d) d) a t.
Proof.
	intros. exact (dt_kill_empty_d_3 (term_high t) d a t (le_n_n _) H).
Qed.

Definition dt_kill_empty_def_1 (n : nat) : Prop :=
  forall (d : preDTA) (a : ad) (t : term),
  term_high t <= n ->
  reconnaissance (preDTA_kill (dta_non_empty_states d) d) a t ->
  reconnaissance d a t.

Lemma dt_kill_empty_r_0 : dt_kill_empty_def_1 0.
Proof.
	unfold dt_kill_empty_def_1 in |- *. intros. induction  t as (a0, t). simpl in H.
	elim (le_Sn_O _ H).
Qed.

Lemma dt_kill_empty_r_1 :
 forall (p' : prec_list) (n : nat) (d : preDTA) (p : prec_list)
   (tl : term_list),
 dt_kill_empty_def_1 n ->
 term_high_0 tl <= n ->
 liste_reconnait (preDTA_kill (dta_non_empty_states d) d) p tl ->
 prec_list_kill (dta_non_empty_states d) p' = Some p ->
 liste_reconnait d p' tl.
Proof.
	simple induction p'. intros. simpl in H4. elim (pl_sum p0); intros.
	rewrite H5 in H4. elim (option_sum bool (MapGet bool (dta_non_empty_states d) a)); intro y. elim y. intros x y0. 
	rewrite y0 in H4. elim (bool_is_true_or_false x); intro; rewrite H6 in H4. elim (option_sum prec_list (prec_list_kill (dta_non_empty_states d) p));
  intro y1. elim y1. intros x0 y2.
	rewrite y2 in H4. inversion H4. rewrite <- H8 in H3.
	inversion H3. apply (rec_consi d a p p0 hd tl0). rewrite <- H11 in H2. exact (H1 _ _ _ (le_trans _ _ _ (le_max_l _ _) H2) H13). rewrite <- H11 in H2. exact (H n d x0 tl0 H1 (le_trans _ _ _ (le_max_r _ _) H2) H14 y2). inversion H13.
	rewrite y1 in H4. inversion H4. inversion H4. rewrite y in H4. inversion H4. elim H5. intros. elim H6. intros. elim H7.
	intros. rewrite H8 in H4. elim (option_sum bool (MapGet bool (dta_non_empty_states d) a)); intro y. elim y. intros x2 y0.
	rewrite y0 in H4. elim (bool_is_true_or_false x2); intros; rewrite H9 in H4. elim (option_sum prec_list (prec_list_kill (dta_non_empty_states d) p));
  intro y1. elim y1. intros x3 y2. 
	rewrite y2 in H4. rewrite <- H8 in H4. elim (option_sum prec_list (prec_list_kill (dta_non_empty_states d) p0));
  intro y3. elim y3. intros x4 y4. rewrite y4 in H4. inversion H4.
	rewrite <- H11 in H3. inversion H3. apply (rec_consi d a p p0 hd tl0). rewrite <- H14 in H2. exact (H1 _ _ _ (le_trans _ _ _ (le_max_l _ _) H2) H16). rewrite <- H14 in H2. exact (H _ _ _ _ H1 (le_trans _ _ _ (le_max_r _ _) H2) H17 y2). rewrite <- H13 in H2. apply (rec_consn d a p p0 hd tl0). exact (H0 n d x4 (tcons hd tl0) H1 H2 H16 y4).
	rewrite y3 in H4. inversion H4. rewrite <- H11 in H3.
	inversion H3. apply (rec_consi d a p p0 hd tl0). rewrite <- H14 in H2. exact (H1 _ _ _ (le_trans _ _ _ (le_max_l _ _) H2) H16). rewrite <- H14 in H2. exact (H _ _ _ _ H1 (le_trans _ _ _ (le_max_r _ _) H2) H17 y2). inversion H16.
	rewrite y1 in H4. elim
  (option_sum prec_list
     (prec_list_kill (dta_non_empty_states d) (prec_cons x x0 x1))); 
  intro y2.
	elim y2. intros x3 y3. rewrite y3 in H4. inversion H4. rewrite <- H11 in H3. rewrite <- H8 in y3. induction  tl as [| t tl Hrectl]. inversion H3. rewrite <- H12 in y3. rewrite (pl_kill_prec_empty _ _ y3) in H8. inversion H8. apply (rec_consn d a p p0 t tl).
	exact (H0 _ _ _ _ H1 H2 H3 y3). rewrite y2 in H4. 
	inversion H4. rewrite <- H8 in H4. induction  tl as [| t tl Hrectl]. inversion H3. rewrite <- H11 in H4. rewrite (pl_kill_prec_empty _ _ H4) in H8. inversion H8. apply (rec_consn d a p p0 t tl).
	exact (H0 _ _ _ _ H1 H2 H3 H4). rewrite y in H4. rewrite <- H8 in H4. induction  tl as [| t tl Hrectl]. inversion H3. rewrite <- H10 in H4. rewrite (pl_kill_prec_empty _ _ H4) in H8. 
	inversion H8. exact (rec_consn d a p p0 t tl (H0 _ _ _ _ H1 H2 H3 H4)). intros. simpl in H2. inversion H2.
	rewrite <- H4 in H1. inversion H1. exact (rec_empty _).
Qed.

Lemma dt_kill_empty_r_2 :
 forall n : nat, dt_kill_empty_def_1 n -> dt_kill_empty_def_1 (S n).
Proof.
	unfold dt_kill_empty_def_1 in |- *. intros. inversion H1.
	elim (dt_kill_1 _ _ _ _ H2). intros. elim H7. intros.
	apply (rec_dta d a t x H8). rewrite <- H9 in H2. unfold states_kill in H9. cut (ladj = states_kill_aux (dta_non_empty_states d) x). intro. rewrite H10 in H3.
	inversion H3. elim (st_kill_2 _ _ _ _ H11). intros.
	elim H16. intros. apply (rec_st d x c tl x0 H17).
	rewrite <- H15 in H0. exact (dt_kill_empty_r_1 x0 n d l tl H (le_S_n _ _ H0) H12 H18). elim (map_sum prec_list (states_kill_aux (dta_non_empty_states d) x)). intros.
	rewrite H10 in H9. inversion H9. intros. elim H10; intros; elim H11; intros; elim H12; intros; rewrite H13 in H9.
	rewrite H13. inversion H9. reflexivity. rewrite H13.
	inversion H9. reflexivity.
Qed.

Lemma dt_kill_empty_r_3 : forall n : nat, dt_kill_empty_def_1 n.
Proof.
	exact (nat_ind dt_kill_empty_def_1 dt_kill_empty_r_0 dt_kill_empty_r_2).
Qed.

Lemma dt_kill_empty_r :
 forall (d : preDTA) (a : ad) (t : term),
 reconnaissance (preDTA_kill (dta_non_empty_states d) d) a t ->
 reconnaissance d a t.
Proof.
	intros. exact (dt_kill_empty_r_3 (term_high t) d a t (le_n_n _) H).
Qed.

Lemma dt_kill_empty_semantics :
 forall (d : preDTA) (a : ad) (t : term),
 reconnaissance d a t <->
 reconnaissance (preDTA_kill (dta_non_empty_states d) d) a t.
Proof.
	intros. split. exact (dt_kill_empty_d d a t).
	exact (dt_kill_empty_r d a t).
Qed.

Lemma dta_kill_empty_states_semantics :
 forall (d : DTA) (t : term),
 reconnait d t <-> reconnait (DTA_kill_empty_states d) t.
Proof.
	simple induction d. intros. unfold DTA_kill_empty_states in |- *. simpl in |- *.
	elim
  (option_sum state (MapGet state (preDTA_kill (dta_non_empty_states p) p) a)). intro y. elim y. intros x y0.
	rewrite y0. exact (dt_kill_empty_semantics p a t). intro y.
	rewrite y. split. intros. elim (dt_non_empty_fix p a). intros.
	elim (dt_kill_empty_semantics p a t). intros. cut (reconnaissance (preDTA_kill (dta_non_empty_states p) p) a t). intro. inversion H4.
	rewrite H5 in y. inversion y. exact (H2 H). intros. simpl in H.
	inversion H. inversion H1. simpl in H0. inversion H0. rewrite <- H11 in H5. inversion H5.
Qed.

Lemma dta_kill_empty_states_lazy_semantics :
 forall (d : DTA) (t : term),
 reconnait d t <-> reconnait (DTA_kill_empty_states_lazy d) t.
Proof.
	intro. rewrite (kill_empty_states_lazy_eg_kill_empty_states d).
	exact (dta_kill_empty_states_semantics d).
Qed.

Lemma kill_empty_correct_wrt_sign_invar_0 :
 forall (p p' : prec_list) (m : Map bool) (n : nat),
 pl_tl_length p n ->
 prec_list_kill m p = Some p' -> pl_tl_length p' n.
Proof.
	simple induction p. intros. simpl in H2. elim (pl_sum p1); intros.
	rewrite H3 in H2. elim (option_sum bool (MapGet bool m a)); intro y. elim y. intros x y0. rewrite y0 in H2. elim (bool_is_true_or_false x); intros; rewrite H4 in H2.
	elim (option_sum prec_list (prec_list_kill m p0)); intro y1.
	elim y1. intros x0 y2. rewrite y2 in H2. inversion H2. elim (nat_sum n); intros. rewrite H5 in H1. inversion H1. elim H5.
	intros. rewrite H7. apply (pl_tl_S a x0 x1). rewrite H7 in H1.
	inversion H1. exact (H _ _ _ H9 y2). exact (H _ _ _ H10 y2).
	rewrite y1 in H2. inversion H2. inversion H2. rewrite y in H2.
	inversion H2. elim H3. intros. elim H4. intros. elim H5.
	intros. rewrite H6 in H2. rewrite <- H6 in H2. elim (option_sum bool (MapGet bool m a)); intro y. elim y. intros x2 y0.
	rewrite y0 in H2. elim (bool_is_true_or_false x2); intros; rewrite H7 in H2. elim (option_sum prec_list (prec_list_kill m p0)); intro y1. elim y1. intros x3 y2. rewrite y2 in H2. elim (option_sum prec_list (prec_list_kill m p1)); intro y3. elim y3.
	intros x4 y4. rewrite y4 in H2. inversion H2. elim (nat_sum n); intros. rewrite H8 in H1. inversion H1. elim H8. intros.
	rewrite H10 in H1. inversion H1. rewrite <- H14 in H6. 
	inversion H6. rewrite H10. apply (pl_tl_propag a x3 x4 x5).
	exact (H _ _ _ H13 y2). exact (H0 _ _ _ H16 y4). rewrite y3 in H2. inversion H2. elim (nat_sum n); intros. rewrite H8 in H1. inversion H1. elim H8. intros. rewrite H10 in H1. rewrite H10. inversion H1. rewrite <- H14 in H6. inversion H6. apply (pl_tl_S a x3 x4). exact (H _ _ _ H13 y2). rewrite y1 in H2.
	elim (option_sum prec_list (prec_list_kill m p1)); intro y2.
	elim y2. intros x3 y3. rewrite y3 in H2. inversion H2. rewrite <- H9. inversion H1. rewrite <- H12 in H6. inversion H6. exact (H0 _ _ _ H14 y3). rewrite y2 in H2. inversion H2. inversion H1. rewrite <- H11 in H6. inversion H6. exact (H0 _ _ _ H13 H2). rewrite y in H2. inversion H1. rewrite <- H10 in H6.
	inversion H6. exact (H0 _ _ _ H12 H2). intros. inversion H.
	simpl in H0. inversion H0. exact pl_tl_O.
Qed.

Lemma kill_empty_correct_wrt_sign_invar_1 :
 forall (s : state) (sigma : signature) (m : Map bool),
 state_correct_wrt_sign s sigma ->
 state_correct_wrt_sign (states_kill_aux m s) sigma.
Proof.
	unfold state_correct_wrt_sign in |- *. intros. elim (st_kill_2 s m a p H0). intros. elim H1. intros. elim (H a x H2). intros.
	elim H4. intros. split with x0. split. exact H5.
	exact (kill_empty_correct_wrt_sign_invar_0 _ _ _ _ H6 H3).
Qed.

Lemma kill_empty_correct_wrt_sign_invar :
 forall (d : preDTA) (sigma : signature) (m : Map bool),
 predta_correct_wrt_sign d sigma ->
 predta_correct_wrt_sign (preDTA_kill m d) sigma.
Proof.
	unfold predta_correct_wrt_sign in |- *. intros. elim (dt_kill_1 _ _ _ _ H0). intros. elim H1. intros. cut (s = states_kill_aux m x). 
	intros. rewrite H4. exact (kill_empty_correct_wrt_sign_invar_1 _ _ _ (H _ _ H2)). unfold states_kill in H3. elim (map_sum prec_list (states_kill_aux m x)); intros. rewrite H4 in H3.
	inversion H3. elim H4; intros; elim H5; intros; elim H6; intros; rewrite H7 in H3;
  rewrite <- H7 in H3; inversion H3; reflexivity.
Qed.

Lemma dt_kill_empty_kill_empty_0 :
 forall (d : preDTA) (p p' : prec_list),
 prec_list_kill (dta_non_empty_states d) p = Some p' ->
 exists plp : pl_path, pl_path_incl plp p'.
Proof.
	simple induction p. intros. simpl in H1. elim (pl_sum p1); intros.
	rewrite H2 in H1. elim (option_sum bool (MapGet bool (dta_non_empty_states d) a)); intro y. elim y. intros x y0. rewrite y0 in H1. elim (bool_is_true_or_false x); intros. rewrite H3 in H1. elim (option_sum prec_list (prec_list_kill (dta_non_empty_states d) p0));
  intro y1. elim y1. intros x0 y2. rewrite y2 in H1. inversion H1.
	elim (H _ y2). intros. split with (pl_path_cons a x1). exact (pl_path_incl_cons x1 a x0 prec_empty H4). rewrite y1 in H1.
	inversion H1. rewrite H3 in H1. inversion H1. rewrite y in H1.
	inversion H1. elim H2. intros. elim H3. intros. elim H4. intros.
	rewrite H5 in H1. elim (option_sum bool (MapGet bool (dta_non_empty_states d) a)); intro y. elim y. intros x2 y0. rewrite y0 in H1. elim (bool_is_true_or_false x2); intros; rewrite H6 in H1.
	elim (option_sum prec_list (prec_list_kill (dta_non_empty_states d) p0));
  intro y1. elim y1. intros x3 y2. rewrite <- H5 in H1. elim (option_sum prec_list (prec_list_kill (dta_non_empty_states d) p0));
  intro y3. elim y3. intros x4 y4. rewrite y4 in H1. elim (option_sum prec_list (prec_list_kill (dta_non_empty_states d) p1));
  intro y5. elim y5.
	intros x5 y6. rewrite y6 in H1. inversion H1. elim (H _ y4). intros.
	split with (pl_path_cons a x6). exact (pl_path_incl_cons x6 a x4 x5 H7). rewrite y5 in H1. inversion H1. elim (H _ y4). intros.
	split with (pl_path_cons a x5). exact (pl_path_incl_cons x5 a x4 prec_empty H7). rewrite y3 in H1. elim (option_sum prec_list (prec_list_kill (dta_non_empty_states d) p1));
  intro y4. elim y4.
	intros x4 y5. rewrite y5 in H1. inversion H1. rewrite <- H8. elim (H0 _ y5). intros. split with x5. exact H7. rewrite y4 in H1.
	inversion H1. rewrite y1 in H1. elim
  (option_sum prec_list
     (prec_list_kill (dta_non_empty_states d) (prec_cons x x0 x1))).
	intro y2. elim y2. intros x3 y3. rewrite y3 in H1. inversion H1. rewrite <- H5 in y3. rewrite <- H8. exact (H0 _ y3). intro y2. rewrite y2 in H1. inversion H1. rewrite <- H5 in H1. exact (H0 _ H1).
	rewrite y in H1. rewrite <- H5 in H1. exact (H0 _ H1). intros.
	simpl in H. inversion H. split with pl_path_nil. exact pl_path_incl_nil.
Qed.

Lemma dt_kill_empty_kill_empty_1 :
 forall (d : preDTA) (plp : pl_path) (tl : term_list),
 pl_path_recon d tl plp <->
 pl_path_recon (preDTA_kill (dta_non_empty_states d) d) tl plp.
Proof.
	simple induction plp. intros. split; intros. inversion H. exact (pl_path_rec_nil (preDTA_kill (dta_non_empty_states d) d)).
	inversion H. exact (pl_path_rec_nil d). intros. split; intros.
	inversion H0. apply (pl_path_rec_cons (preDTA_kill (dta_non_empty_states d) d) a t p tl0). elim (dt_kill_empty_semantics d a t). intros. exact (H7 H5). elim (H tl0).
	intros. exact (H7 H6). inversion H0. apply (pl_path_rec_cons d a t p tl0). elim (dt_kill_empty_semantics d a t). intros. exact (H8 H5).
	elim (H tl0). intros. exact (H8 H6).
Qed.

Lemma dt_kill_empty_kill_empty_2 :
 forall (d : preDTA) (p : prec_list) (plp : pl_path),
 pl_path_incl plp p ->
 pl_path_true plp (dta_non_empty_states d) ->
 exists tl : term_list, pl_path_recon d tl plp.
Proof.
	simple induction p. intros. inversion H1. inversion H2. rewrite <- H8 in H4. inversion H4. elim (dt_non_empty_fix d a1).
	intros. elim (H12 H9). intros. rewrite <- H4 in H10.
	inversion H10. rewrite H17 in H8. elim (H _ H5 H8).
	intros. split with (tcons x x0). rewrite H3 in H16.
	rewrite <- H16. exact (pl_path_rec_cons d a1 x plp0 x0 H14 H15). inversion H2. elim (H8 (sym_eq H9)).
	elim (H0 plp H6 H2). intros. split with x. rewrite H11.
	exact H13. intros. inversion H. split with tnil.
	exact (pl_path_rec_nil d).
Qed.

Lemma dt_kill_empty_kill_empty_3 :
 forall (d : preDTA) (a : ad) (s : state) (sigma : signature),
 MapGet state (preDTA_kill (dta_non_empty_states d) d) a = Some s ->
 predta_correct_wrt_sign d sigma ->
 exists t : term, reconnaissance (preDTA_kill (dta_non_empty_states d) d) a t.
Proof.
	intros. elim (dt_kill_1 _ _ _ _ H). intros. elim H1. intros.
	elim (st_kill_4 _ _ _ H3). intros. elim H4. intros. unfold states_kill in H3. cut (states_kill_aux (dta_non_empty_states d) x = s). intro. rewrite <- H6 in H5. elim (st_kill_2 _ _ _ _ H5). intros. elim H7. intros. elim (dt_kill_empty_kill_empty_0 _ _ _ H9). intros. elim (pl_kill_1 _ _ _ _ H9 H10). intros.
	elim (dt_kill_empty_kill_empty_2 _ _ _ H11 H12). intros.
	elim (dt_kill_empty_kill_empty_1 d x3 x4). intros. split with (app x1 x4). apply (rec_dta (preDTA_kill (dta_non_empty_states d) d) a (app x1 x4) s H). rewrite <- H6. apply
  (rec_st (preDTA_kill (dta_non_empty_states d) d)
     (states_kill_aux (dta_non_empty_states d) x) x1 x4 x0 H5). elim
  (kill_empty_correct_wrt_sign_invar d sigma (dta_non_empty_states d) H0 a s
     H x1 x0). intros. elim H16. intros. exact
  (pl_path_rec_equiv_1 x3 x0 H10 (preDTA_kill (dta_non_empty_states d) d) x4
     x5 (H14 H13) H18). rewrite H6 in H5. exact H5.
	elim (map_sum prec_list (states_kill_aux (dta_non_empty_states d) x));
  intros. rewrite H6 in H3. inversion H3. elim H6; intros; elim H7; intros; elim H8; intros; rewrite H9 in H3;
  rewrite <- H9 in H3; inversion H3; reflexivity.
Qed.

Lemma dt_kill_empty_kill_empty :
 forall (d : preDTA) (a : ad) (sigma : signature),
 predta_correct_wrt_sign d sigma ->
 ((exists s : state,
     MapGet state (preDTA_kill (dta_non_empty_states d) d) a = Some s) <->
  (exists t : term, reconnaissance d a t)).
Proof.
	intros. split; intros. elim H0. intros. elim (dt_kill_empty_kill_empty_3 d a x sigma H1 H). intros.
	elim (dt_kill_empty_semantics d a x0). intros. split with x0. elim H1. intros. elim (dt_kill_empty_semantics d a x0).
	intros. exact (H6 H2). elim H0. intros. cut (reconnaissance (preDTA_kill (dta_non_empty_states d) d) a x). intro. 
	inversion H2. split with ladj. exact H3. elim (dt_kill_empty_semantics d a x). intros. exact (H2 H1).
Qed.