
Require Import Bool.
Require Import NArith Ndec Ndigits.
Require Import ZArith.
Require Import Classical_Prop.
From IntMap Require Import Allmaps.
Require Import bases.
(* bases:
Require Import Bool.
Require Import Arith.
Require Import ZArith.
Require Import NArith.
Require Import Ndec.
From IntMap Require Import Allmaps.
Require Import EqNat.
Require Export Max.

Lemma nat_sum : forall n : nat, n = 0 \/ (exists m : nat, n = S m).

Lemma le_n_n : forall n : nat, n <= n.

Lemma le_l_or_r : forall n m : nat, n <= m \/ m <= n.

Lemma plus_n_O : forall n : nat, n + 0 = n.
 
 Lemma S_plus_l : forall n m : nat, S (n + m) = S n + m.
 
 Lemma S_plus_r : forall n m : nat, S (n + m) = n + S m.

Lemma max_le_Sr_0 :
 forall n m : nat, max n m <= max n (S m) /\ max (S n) m <= max (S n) (S m).

Lemma max_le_Sr : forall n m : nat, max n m <= max n (S m).

Lemma plus_O_r : forall n : nat, n + 0 = n.

Lemma plus_O_l : forall n : nat, n + 0 = n.

Lemma le_mult_lS : forall n m : nat, n * m <= S n * m.

Lemma le_mult_rS : forall n m : nat, n * m <= n * S m.

Lemma le_disj : forall n m : nat, n <= m -> n = m \/ S n <= m.

Lemma le_mult_l : forall n m p : nat, n <= m -> n * p <= m * p.

Lemma le_mult_r : forall n m p : nat, n <= m -> p * n <= p * m.

Lemma le_mult_mult : forall n m p q : nat, n <= m -> p <= q -> n * p <= m * q.

Lemma Sn_eq_Sm_n_eq_m : forall n m : nat, S n = S m -> n = m.

Lemma bool_dec_eq : forall a b : bool, {a = b} + {a <> b}.

Lemma bool_is_false_or_true : forall a : bool, a = false \/ a = true.

Lemma bool_is_true_or_false : forall a : bool, a = true \/ a = false.

Lemma in_M0_false :
 forall (A : Set) (a : A), ~ (exists e : ad, MapGet A (M0 A) e = Some a).

Lemma in_M1_id :
 forall (A : Set) (a : A) (x : ad) (e : A),
 (exists c : ad, MapGet A (M1 A x e) c = Some a) -> a = e.

Lemma in_M2_disj :
 forall (A : Set) (a : A) (m0 m1 : Map A),
 (exists c : ad, MapGet A (M2 A m0 m1) c = Some a) ->
 (exists c : ad, MapGet A m0 c = Some a) \/
 (exists c : ad, MapGet A m1 c = Some a).

Lemma aux_Neqb_1_0 : forall p : positive, Peqb p p = true.

Lemma aux_Neqb_1_1 : forall p p0 : positive, Peqb p p0 = true -> p = p0.

Lemma aux_Neqb_trans :
 forall a b c : ad, Neqb a b = true -> Neqb b c = true -> Neqb a c = true.

Lemma indprinciple_nat_gen :
 forall P : nat -> Prop,
 (forall n : nat, (forall m : nat, m < n -> P m) -> P n) ->
 forall n m : nat, m <= n -> P m.

Lemma beq_nat_complete : forall n m : nat, beq_nat n m = true -> n = m.

Lemma beq_nat_correct : forall n : nat, beq_nat n n = true. *)
Require Import defs.
(* defs:
Require Import Bool.
Require Import Arith.
Require Import ZArith.
From IntMap Require Import Allmaps.
Require Import EqNat.
Require Import bases.

Inductive term : Set :=
    app : ad -> term_list -> term
with term_list : Set :=
  | tnil : term_list
  | tcons : term -> term_list -> term_list.

Scheme term_term_list_rec := Induction for term
  Sort Set
  with term_list_term_rec := Induction for term_list 
  Sort Set.

Scheme term_term_list_ind := Induction for term
  Sort Prop
  with term_list_term_ind := Induction for term_list 
  Sort Prop.

Lemma term_list_disj :
 forall l : term_list,
 l = tnil \/ (exists hd : term, (exists tl : term_list, l = tcons hd tl)).

Fixpoint lst_length (l : term_list) : nat :=
  match l with
  | tnil => 0
  | tcons _ l' => S (lst_length l')
  end.

Fixpoint term_high (t : term) : nat :=
  match t with
  | app a l => S (term_high_0 l)
  end
 
 with term_high_0 (l : term_list) : nat :=
  match l with
  | tnil => 0
  | tcons hd tl => max (term_high hd) (term_high_0 tl)
  end.

Lemma high_aux_0 :
 forall (a : ad) (l : term_list), S (term_high_0 l) <= term_high (app a l).

Lemma high_aux_1 :
 forall (a : ad) (l : term_list), S (term_high_0 l) = term_high (app a l).

Lemma high_aux_2 : forall (l : term_list) (c : ad), 1 <= term_high (app c l).

Lemma high_aux_3 :
 forall (t : term) (tl : term_list), term_high t <= term_high_0 (tcons t tl).

Lemma high_aux_4 :
 forall (t : term) (tl : term_list),
 term_high_0 tl <= term_high_0 (tcons t tl).

Fixpoint taille_term (t : term) : nat :=
  match t with
  | app c l => S (mtaille_term_list l)
  end
 
 with mtaille_term_list (l : term_list) : nat :=
  match l with
  | tnil => 0
  | tcons hd tl => max (taille_term hd) (mtaille_term_list tl)
  end.

Inductive prec_list : Set :=
  | prec_cons : ad -> prec_list -> prec_list -> prec_list
  | prec_empty : prec_list.

Lemma pl_sum :
 forall pl : prec_list,
 pl = prec_empty \/
 (exists a : ad,
    (exists la : prec_list, (exists ls : prec_list, pl = prec_cons a la ls))).

Definition state := Map prec_list.

Definition preDTA := Map state.

Inductive DTA : Set :=
    dta : preDTA -> ad -> DTA.

Fixpoint taille_0 (l : prec_list) : nat :=
  match l with
  | prec_empty => 0
  | prec_cons x y z => S (taille_0 y + taille_0 z)
  end.

Fixpoint taille_1 (s : state) : nat :=
  match s with
  | M0 => 0
  | M1 x y => taille_0 y
  | M2 x y => max (taille_1 x) (taille_1 y)
  end.

Fixpoint DTA_taille (d : preDTA) : nat :=
  match d with
  | M0 => 0
  | M1 x y => taille_1 y
  | M2 x y => max (DTA_taille x) (DTA_taille y)
  end.

Lemma taille_aux_0 :
 forall (a : ad) (la ls : prec_list),
 S (taille_0 la) <= taille_0 (prec_cons a la ls).

Lemma taille_aux_1 :
 forall (a : ad) (la ls : prec_list), 1 <= taille_0 (prec_cons a la ls).

Lemma taille_aux_2 :
 forall (a : ad) (la ls : prec_list),
 S (taille_0 ls) <= taille_0 (prec_cons a la ls).

Inductive prec_occur : prec_list -> ad -> Prop :=
  | prec_hd :
      forall (a : ad) (pl0 pl1 : prec_list),
      prec_occur (prec_cons a pl0 pl1) a
  | prec_int0 :
      forall (a b : ad) (pl0 pl1 : prec_list),
      prec_occur pl0 b -> prec_occur (prec_cons a pl0 pl1) b
  | prec_int1 :
      forall (a b : ad) (pl0 pl1 : prec_list),
      prec_occur pl1 b -> prec_occur (prec_cons a pl0 pl1) b.

Inductive prec_contained : prec_list -> prec_list -> Prop :=
  | prec_id : forall p : prec_list, prec_contained p p
  | prec_c_int0 :
      forall (p p0 p1 : prec_list) (a : ad),
      prec_contained p p0 -> prec_contained p (prec_cons a p0 p1)
  | prec_c_int1 :
      forall (p p0 p1 : prec_list) (a : ad),
      prec_contained p p1 -> prec_contained p (prec_cons a p0 p1).

Definition state_in_dta (d : preDTA) (s : state) : Prop :=
  exists a : ad, MapGet state d a = Some s.

Definition state_in_dta_diff (d : preDTA) (s : state) 
  (a : ad) : Prop := exists b : ad, MapGet state d b = Some s /\ a <> b.

Definition prec_in_dta (d : preDTA) (p : prec_list) : Prop :=
  exists s : state,
    (exists a : ad,
       (exists c : ad,
          MapGet state d a = Some s /\
          MapGet prec_list s c = Some p)).

Definition prec_in_dta_cont (d : preDTA) (p : prec_list) : Prop :=
  exists s : state,
    (exists b : ad,
       (exists c : ad,
          (exists p0 : prec_list,
             MapGet state d b = Some s /\
             MapGet prec_list s c = Some p0 /\ prec_contained p p0))).

Definition prec_in_dta_diff (d : preDTA) (p : prec_list) 
  (a : ad) : Prop :=
  exists s : state,
    (exists b : ad,
       (exists c : ad,
          MapGet state d b = Some s /\
          MapGet prec_list s c = Some p /\ a <> b)).

Definition prec_in_dta_diff_cont (d : preDTA) (p : prec_list) 
  (a : ad) : Prop :=
  exists s : state,
    (exists b : ad,
       (exists c : ad,
          (exists p0 : prec_list,
             MapGet state d b = Some s /\
             MapGet prec_list s c = Some p0 /\
             prec_contained p p0 /\ a <> b))).

Definition prec_in_state (s : state) (p : prec_list) : Prop :=
  exists c : ad, MapGet prec_list s c = Some p.

Lemma prec_in_state_M0_false :
 forall p : prec_list, ~ prec_in_state (M0 prec_list) p.

Lemma state_in_dta_M0_false : forall s : state, ~ state_in_dta (M0 state) s.

Lemma prec_occur_1 :
 forall (a : ad) (p0 p1 p2 : prec_list),
 prec_contained (prec_cons a p0 p1) p2 -> prec_occur p2 a.

Lemma prec_contained_0 :
 forall (a : ad) (p0 p1 p2 : prec_list),
 prec_contained (prec_cons a p0 p1) p2 -> prec_contained p0 p2.

Lemma prec_contained_1 :
 forall (a : ad) (p0 p1 p2 : prec_list),
 prec_contained (prec_cons a p0 p1) p2 -> prec_contained p1 p2.

Inductive term_occur : term -> term -> Prop :=
  | to_eq : forall t : term, term_occur t t
  | to_st :
      forall (t : term) (a : ad) (tl : term_list),
      term_list_occur t tl -> term_occur t (app a tl)
with term_list_occur : term -> term_list -> Prop :=
  | tlo_head :
      forall (t hd : term) (tl : term_list),
      term_occur t hd -> term_list_occur t (tcons hd tl)
  | tlo_tail :
      forall (t hd : term) (tl : term_list),
      term_list_occur t tl -> term_list_occur t (tcons hd tl).

Definition term_occur_def_0 (t : term) :=
  forall u : term, term_occur u t -> term_high u <= term_high t.

Definition term_occur_def_1 (t : term_list) :=
  forall u : term, term_list_occur u t -> term_high u <= term_high_0 t.

Lemma term_occur_0_0 :
 forall (a : ad) (t : term_list),
 term_occur_def_1 t -> term_occur_def_0 (app a t).

Lemma term_occur_0_1 : term_occur_def_1 tnil.

Lemma term_occur_0_2 :
 forall t : term,
 term_occur_def_0 t ->
 forall t0 : term_list, term_occur_def_1 t0 -> term_occur_def_1 (tcons t t0).

Lemma term_occur_0 :
 forall t u : term, term_occur u t -> term_high u <= term_high t.

Lemma term_occur_1 :
 forall (t : term_list) (u : term),
 term_list_occur u t -> term_high u <= term_high_0 t.

Definition indprinciple_3_aux (n : nat) :=
  forall P : term -> Prop,
  (forall (a : ad) (tl : term_list),
   (forall u : term, term_list_occur u tl -> P u) -> P (app a tl)) ->
  forall t : term, term_high t <= n -> P t.

Lemma indprinciple_3_0 : indprinciple_3_aux 0.

Lemma indprinciple_3_1 :
 forall n : nat, indprinciple_3_aux n -> indprinciple_3_aux (S n).

Lemma indprinciple_3_2 :
 forall (n : nat) (P : term -> Prop),
 (forall (a : ad) (tl : term_list),
  (forall u : term, term_list_occur u tl -> P u) -> P (app a tl)) ->
 forall t : term, term_high t <= n -> P t.

Lemma indprinciple_term :
 forall P : term -> Prop,
 (forall (a : ad) (tl : term_list),
  (forall u : term, term_list_occur u tl -> P u) -> P (app a tl)) ->
 forall t : term, P t.

Lemma Ndouble_inv_N0 : forall x : ad, Ndouble x = N0 -> x = N0.

Lemma Ndouble_inv_xO :
 forall (x : ad) (p : positive), Ndouble x = Npos (xO p) -> x = Npos p.

Lemma Ndouble_plus_one_inv_xH :
 forall x : ad, Ndouble_plus_one x = Npos 1 -> x = N0.

Lemma Ndouble_plus_one_inv_xI :
 forall (x : ad) (p : positive),
 Ndouble_plus_one x = Npos (xI p) -> x = Npos p. *)
Require Import semantics.
(* semantics:
Require Import Bool.
Require Import Arith.
Require Import Classical_Prop.
From IntMap Require Import Allmaps.
Require Import bases.
Require Import defs.

Unset Standard Proposition Elimination Names.

Fixpoint rec_term (d : preDTA) (a : ad) (t : term) 
 (n : nat) {struct n} : bool :=
  match n with
  | O => false
  | S k =>
      match t with
      | app c l =>
          match MapGet _ d a with
          | None => false
          | Some lts =>
              match MapGet _ lts c with
              | None => false
              | Some pre => rec_list_terms d pre l k
              end
          end
      end
  end
 
 with rec_list_terms (d : preDTA) (pre : prec_list) 
 (l : term_list) (n : nat) {struct n} : bool :=
  match n with
  | O => false
  | S k =>
      match pre with
      | prec_empty => match l with
                      | tnil => true
                      | _ => false
                      end
      | prec_cons st stp pre' =>
          match l with
          | tnil => false
          | tcons hd tl =>
              rec_list_terms d pre' l k
              || rec_term d st hd k && rec_list_terms d stp tl k
          end
      end
  end.

Lemma borne_0_0 :
 forall p : prec_list,
 prec_in_state (M0 prec_list) p -> taille_0 p <= taille_1 (M0 prec_list).

Lemma borne_0_1 :
 forall (a : ad) (p' p : prec_list),
 prec_in_state (M1 prec_list a p') p ->
 taille_0 p <= taille_1 (M1 prec_list a p').

Lemma borne_0_2 :
 forall (m0 m1 : Map prec_list) (p : prec_list),
 (prec_in_state m0 p -> taille_0 p <= taille_1 m0) ->
 (prec_in_state m1 p -> taille_0 p <= taille_1 m1) ->
 prec_in_state (M2 prec_list m0 m1) p ->
 taille_0 p <= taille_1 (M2 prec_list m0 m1).

Lemma borne_0 :
 forall (s : state) (p : prec_list),
 prec_in_state s p -> taille_0 p <= taille_1 s.

Lemma borne_1_0 :
 forall s : state,
 state_in_dta (M0 state) s -> taille_1 s <= DTA_taille (M0 state).

Lemma borne_1_1 :
 forall (a : ad) (s' s : state),
 state_in_dta (M1 state a s') s -> taille_1 s <= DTA_taille (M1 state a s').

Lemma borne_1_2 :
 forall (m0 m1 : Map state) (s : state),
 (state_in_dta m0 s -> taille_1 s <= DTA_taille m0) ->
 (state_in_dta m1 s -> taille_1 s <= DTA_taille m1) ->
 state_in_dta (M2 state m0 m1) s -> taille_1 s <= DTA_taille (M2 state m0 m1).

Lemma borne_1 :
 forall (d : preDTA) (s : state),
 state_in_dta d s -> taille_1 s <= DTA_taille d.

Lemma borne_2 :
 forall (d : preDTA) (p : prec_list),
 prec_in_dta d p -> taille_0 p <= DTA_taille d.

Definition essence (t : term) (d : preDTA) : nat :=
  S (term_high t) * S (DTA_taille d).

Definition essence_list (l : term_list) (d : preDTA) 
  (pl : prec_list) : nat :=
  match l, pl with
  | tnil, _ => 1
  | _, prec_empty => 1
  | _, prec_cons a la ls =>
      taille_0 pl + S (term_high_0 l) * S (DTA_taille d)
  end.

Lemma conservation_0_0 : forall n n0 : nat, S n * S n0 = S (n0 + n * S n0).

Lemma conservation_0 :
 forall (d : preDTA) (p : prec_list) (c : ad) (l : term_list),
 prec_in_dta d p -> S (essence_list l d p) <= essence (app c l) d.

Lemma conservation_1 :
 forall (d : preDTA) (l : term_list), 1 <= essence_list l d prec_empty.

Lemma conservation_2 :
 forall (d : preDTA) (p : prec_list), 1 <= essence_list tnil d p.

Lemma conservation_3 :
 forall (d : preDTA) (hd : term) (tl : term_list) (a : ad)
   (la ls : prec_list),
 S (essence_list (tcons hd tl) d ls) <=
 essence_list (tcons hd tl) d (prec_cons a la ls).

Lemma conservation_4 :
 forall (d : preDTA) (hd : term) (tl : term_list) (a : ad)
   (la ls : prec_list),
 S (essence_list tl d la) <= essence_list (tcons hd tl) d (prec_cons a la ls).

Lemma conservation_5_0 :
 forall (a : ad) (la ls : prec_list), 1 <= taille_0 (prec_cons a la ls).

Lemma conservation_5 :
 forall (d : preDTA) (hd : term) (tl : term_list) (a : ad)
   (la ls : prec_list),
 S (essence hd d) <= essence_list (tcons hd tl) d (prec_cons a la ls).

Definition dta_rec_term (d : DTA) (t : term) : bool :=
  match d with
  | dta p a => rec_term p a t (essence t p)
  end.

Inductive reconnaissance : preDTA -> ad -> term -> Prop :=
    rec_dta :
      forall (d : preDTA) (a : ad) (t : term) (ladj : state),
      MapGet state d a = Some ladj ->
      state_reconnait d ladj t -> reconnaissance d a t
with state_reconnait : preDTA -> state -> term -> Prop :=
    rec_st :
      forall (d : preDTA) (s : state) (c : ad) (tl : term_list)
        (l : prec_list),
      MapGet prec_list s c = Some l ->
      liste_reconnait d l tl -> state_reconnait d s (app c tl)
with liste_reconnait : preDTA -> prec_list -> term_list -> Prop :=
  | rec_empty : forall d : preDTA, liste_reconnait d prec_empty tnil
  | rec_consi :
      forall (d : preDTA) (a : ad) (la ls : prec_list) 
        (hd : term) (tl : term_list),
      reconnaissance d a hd ->
      liste_reconnait d la tl ->
      liste_reconnait d (prec_cons a la ls) (tcons hd tl)
  | rec_consn :
      forall (d : preDTA) (a : ad) (la ls : prec_list) 
        (hd : term) (tl : term_list),
      liste_reconnait d ls (tcons hd tl) ->
      liste_reconnait d (prec_cons a la ls) (tcons hd tl).

Definition reconnait (d : DTA) (t : term) : Prop :=
  match d with
  | dta p a => reconnaissance p a t
  end.

Scheme mreconnaissance_ind := Induction for reconnaissance
  Sort Prop
  with mstrec_ind := Induction for state_reconnait 
  Sort Prop
  with mlrec_ind := Induction for liste_reconnait Sort Prop.

Lemma sem_listes_0 :
 forall (d : preDTA) (p : prec_list) (hd : term) (tl : term_list),
 liste_reconnait d p (tcons hd tl) -> p <> prec_empty.

Lemma sem_listes_1 :
 forall (d : preDTA) (hd : term) (tl : term_list),
 ~ liste_reconnait d prec_empty (tcons hd tl).

Lemma sem_listes_2 :
 forall (d : preDTA) (pl : prec_list),
 liste_reconnait d pl tnil -> pl = prec_empty.

Definition sem_equiv_prop_t (t : term) :=
  forall (d : preDTA) (a : ad) (n : nat),
  rec_term d a t n = true -> reconnaissance d a t.
Definition sem_equiv_prop_l (l : term_list) :=
  forall (d : preDTA) (p : prec_list) (n : nat),
  rec_list_terms d p l n = true -> liste_reconnait d p l.

Lemma semantic_equiv_0_0 :
 forall (d : preDTA) (p : prec_list) (n : nat),
 rec_list_terms d p tnil n = true -> p = prec_empty.

Lemma semantic_equiv_0_1 : sem_equiv_prop_l tnil.

Lemma semantic_equiv_0_2 :
 forall (d : preDTA) (a a' : ad) (l : term_list) (n : nat) 
   (s : state) (p : prec_list),
 rec_term d a (app a' l) (S n) = true ->
 MapGet state d a = Some s ->
 MapGet prec_list s a' = Some p -> rec_list_terms d p l n = true.

Lemma semantic_equiv_0_3 :
 forall (d : preDTA) (a a' : ad) (l : term_list) (n : nat),
 rec_term d a (app a' l) (S n) = true ->
 exists s : state, MapGet state d a = Some s.

Lemma semantic_equiv_0_4 :
 forall (d : preDTA) (a a' : ad) (l : term_list) (n : nat) (s : state),
 MapGet state d a = Some s ->
 rec_term d a (app a' l) (S n) = true ->
 exists p : prec_list, MapGet prec_list s a' = Some p.

Lemma semantic_equiv_0_5 :
 forall (a : ad) (t : term_list),
 sem_equiv_prop_l t -> sem_equiv_prop_t (app a t).

Lemma semantic_equiv_0_6 :
 forall (n : nat) (t : term) (t0 : term_list),
 (forall (d : preDTA) (a : ad) (m : nat),
  rec_term d a t m = true -> reconnaissance d a t) ->
 (forall (d : preDTA) (p : prec_list) (m : nat),
  rec_list_terms d p t0 m = true -> liste_reconnait d p t0) ->
 forall (d : preDTA) (p : prec_list),
 rec_list_terms d p (tcons t t0) n = true -> liste_reconnait d p (tcons t t0).

Lemma semantic_equiv_0_7 :
 forall t : term,
 sem_equiv_prop_t t ->
 forall t0 : term_list, sem_equiv_prop_l t0 -> sem_equiv_prop_l (tcons t t0).

Lemma semantic_equiv_0 :
 forall (d : preDTA) (a : ad) (t : term) (n : nat),
 rec_term d a t n = true -> reconnaissance d a t.

Definition invar_term (t : term) : Prop :=
  forall (n m : nat) (d : preDTA) (a : ad),
  rec_term d a t n = true -> n <= m -> rec_term d a t m = true.

Definition invar_list (tl : term_list) : Prop :=
  forall (n m : nat) (d : preDTA) (p : prec_list),
  rec_list_terms d p tl n = true -> n <= m -> rec_list_terms d p tl m = true.

Lemma invar_0 : invar_list tnil.

Lemma invar_1_0 :
 forall (d : preDTA) (a c : ad) (t : term_list) (n : nat) 
   (s : state) (p : prec_list),
 MapGet state d a = Some s ->
 MapGet prec_list s c = Some p ->
 rec_list_terms d p t n = true -> rec_term d a (app c t) (S n) = true.

Lemma invar_1_1 :
 forall (d : preDTA) (a c : ad) (t : term_list) (n : nat),
 rec_term d a (app c t) (S n) = true ->
 exists p : prec_list, rec_list_terms d p t n = true.

Lemma invar_1 :
 forall (a : ad) (t : term_list), invar_list t -> invar_term (app a t).

Lemma invar_2_0 :
 forall (d : preDTA) (p : prec_list) (n : nat),
 rec_list_terms d p tnil n = true -> p = prec_empty.

Lemma invar_2_1 :
 forall (d : preDTA) (a : ad) (la ls : prec_list) (hd : term)
   (tl : term_list) (n : nat),
 rec_list_terms d (prec_cons a la ls) (tcons hd tl) (S n) = true ->
 rec_list_terms d ls (tcons hd tl) n = true \/
 rec_term d a hd n = true /\ rec_list_terms d la tl n = true.

Lemma invar_2_2 :
 forall (d : preDTA) (a : ad) (la ls : prec_list) (hd : term)
   (tl : term_list) (n : nat),
 rec_list_terms d ls (tcons hd tl) n = true \/
 rec_term d a hd n = true /\ rec_list_terms d la tl n = true ->
 rec_list_terms d (prec_cons a la ls) (tcons hd tl) (S n) = true.
 
Lemma invar_2 :
 forall t : term,
 invar_term t ->
 forall t0 : term_list, invar_list t0 -> invar_list (tcons t t0).

Lemma invar : forall t : term, invar_term t.

Lemma invarl : forall tl : term_list, invar_list tl.

Definition dta_reconnait (d : preDTA) (a : ad) (t : term)
  (pr : reconnaissance d a t) := rec_term d a t (essence t d) = true.

Definition st_reconnait (d : preDTA) (s : state) (t : term)
  (pr : state_reconnait d s t) :=
  match t with
  | app c l =>
      exists p : prec_list,
        MapGet prec_list s c = Some p /\
        rec_list_terms d p l (essence_list l d p) = true
  end.

Definition pre_reconnait (d : preDTA) (p : prec_list) 
  (t : term_list) (pr : liste_reconnait d p t) :=
  rec_list_terms d p t (essence_list t d p) = true.

Lemma semantic_equiv_1_0 :
 forall (d : preDTA) (a : ad) (t : term) (ladj : state)
   (e : MapGet state d a = Some ladj) (s : state_reconnait d ladj t),
 st_reconnait d ladj t s -> dta_reconnait d a t (rec_dta d a t ladj e s).

Lemma semantic_equiv_1_1 :
 forall (d : preDTA) (s : state) (c : ad) (tl : term_list) 
   (l : prec_list) (e : MapGet prec_list s c = Some l)
   (l0 : liste_reconnait d l tl),
 pre_reconnait d l tl l0 ->
 st_reconnait d s (app c tl) (rec_st d s c tl l e l0).

Lemma semantic_equiv_1_2 :
 forall d : preDTA, pre_reconnait d prec_empty tnil (rec_empty d).

Lemma semantic_equiv_1_3 :
 forall (d : preDTA) (a : ad) (la ls : prec_list) (hd : term)
   (tl : term_list) (r : reconnaissance d a hd),
 dta_reconnait d a hd r ->
 forall l : liste_reconnait d la tl,
 pre_reconnait d la tl l ->
 pre_reconnait d (prec_cons a la ls) (tcons hd tl)
   (rec_consi d a la ls hd tl r l).

Lemma semantic_equiv_1_4_0 :
 forall (d : preDTA) (a : ad) (la ls : prec_list) (l : term_list) (n : nat),
 l <> tnil ->
 rec_list_terms d ls l n = true ->
 rec_list_terms d (prec_cons a la ls) l (S n) = true.

Lemma semantic_equiv_1_4 :
 forall (d : preDTA) (a : ad) (la ls : prec_list) (hd : term)
   (tl : term_list) (l : liste_reconnait d ls (tcons hd tl)),
 pre_reconnait d ls (tcons hd tl) l ->
 pre_reconnait d (prec_cons a la ls) (tcons hd tl)
   (rec_consn d a la ls hd tl l).

Lemma semantic_equiv_1 :
 forall (d : preDTA) (a : ad) (t : term),
 reconnaissance d a t -> rec_term d a t (essence t d) = true. *)
Require Import signature.
(* signature:
Require Import Bool.
Require Import NArith.
Require Import Ndec.
Require Import ZArith.
Require Import EqNat.
From IntMap Require Import Allmaps.
Require Import bases.
Require Import defs.
Require Import semantics.

Definition pl_compat (pl0 pl1 : prec_list) : Prop :=
  pl0 = prec_empty /\ pl1 = prec_empty \/
  pl0 <> prec_empty /\ pl1 <> prec_empty.

Definition mpl_compat (s0 s1 : state) : Prop :=
  forall (c : ad) (p0 p1 : prec_list),
  MapGet prec_list s0 c = Some p0 ->
  MapGet prec_list s1 c = Some p1 -> pl_compat p0 p1.

Definition dta_correct (d : preDTA) : Prop :=
  forall (s0 s1 : state) (a0 a1 : ad),
  MapGet state d a0 = Some s0 ->
  MapGet state d a1 = Some s1 -> mpl_compat s0 s1.

Definition dta_compat (d0 d1 : preDTA) : Prop :=
  forall (s0 s1 : state) (a0 a1 : ad),
  MapGet state d0 a0 = Some s0 ->
  MapGet state d1 a1 = Some s1 -> mpl_compat s0 s1.

Definition DTA_compat (d0 d1 : DTA) : Prop :=
  match d0, d1 with
  | dta p0 a0, dta p1 a1 => dta_compat p0 p1
  end.

Lemma pl_compat_sym :
 forall pl0 pl1 : prec_list, pl_compat pl0 pl1 -> pl_compat pl1 pl0.

Lemma mpl_compat_0 :
 forall (c : ad) (pl0 pl1 : prec_list),
 mpl_compat (M1 prec_list c pl0) (M1 prec_list c pl1) -> pl_compat pl0 pl1.

Lemma mpl_compat_1 :
 forall s0 s1 s2 s3 : state,
 mpl_compat (M2 prec_list s0 s1) (M2 prec_list s2 s3) -> mpl_compat s0 s2.

Lemma mpl_compat_2 :
 forall s0 s1 s2 s3 : state,
 mpl_compat (M2 prec_list s0 s1) (M2 prec_list s2 s3) -> mpl_compat s1 s3.

Lemma mpl_compat_3 :
 forall (s0 s1 : state) (pl : prec_list),
 mpl_compat (M2 prec_list s0 s1) (M1 prec_list N0 pl) ->
 mpl_compat s0 (M1 prec_list N0 pl).

Lemma mpl_compat_4 :
 forall (s0 s1 : state) (pl : prec_list),
 mpl_compat (M2 prec_list s0 s1) (M1 prec_list (Npos 1) pl) ->
 mpl_compat s1 (M1 prec_list N0 pl).

Lemma mpl_compat_5 :
 forall (s0 s1 : state) (pl : prec_list) (p : positive),
 mpl_compat (M2 prec_list s0 s1) (M1 prec_list (Npos (xO p)) pl) ->
 mpl_compat s0 (M1 prec_list (Npos p) pl).

Lemma mpl_compat_6 :
 forall (s0 s1 : state) (pl : prec_list) (p : positive),
 mpl_compat (M2 prec_list s0 s1) (M1 prec_list (Npos (xI p)) pl) ->
 mpl_compat s1 (M1 prec_list (Npos p) pl).

Lemma mpl_compat_sym :
 forall s0 s1 : state, mpl_compat s0 s1 -> mpl_compat s1 s0.

Inductive pl_tl_length : prec_list -> nat -> Prop :=
  | pl_tl_O : pl_tl_length prec_empty 0
  | pl_tl_S :
      forall (a : ad) (pl : prec_list) (n : nat),
      pl_tl_length pl n -> pl_tl_length (prec_cons a pl prec_empty) (S n)
  | pl_tl_propag :
      forall (a : ad) (la ls : prec_list) (n : nat),
      pl_tl_length la n ->
      pl_tl_length ls (S n) -> pl_tl_length (prec_cons a la ls) (S n).

Lemma pl_tl_length_pl_compat :
 forall (p0 p1 : prec_list) (n : nat),
 pl_tl_length p0 n -> pl_tl_length p1 n -> pl_compat p0 p1.

Definition pl_tl_length_rec_def_0 (n : nat) :=
  forall (d : preDTA) (pl : prec_list) (tl : term_list),
  pl_tl_length pl n -> liste_reconnait d pl tl -> n = lst_length tl.

Definition pl_tl_length_rec_def_1 (d : preDTA) (pl : prec_list)
  (tl : term_list) :=
  forall n : nat,
  pl_tl_length_rec_def_0 n ->
  pl_tl_length pl (S n) -> liste_reconnait d pl tl -> S n = lst_length tl.

Lemma pl_tl_length_rec_0 : pl_tl_length_rec_def_0 0.

Lemma pl_tl_length_rec_1 :
 forall d : preDTA, pl_tl_length_rec_def_1 d prec_empty tnil.

Lemma pl_tl_length_rec_2 :
 forall (d : preDTA) (a : ad) (la ls : prec_list) (hd : term)
   (tl : term_list),
 reconnaissance d a hd ->
 liste_reconnait d la tl ->
 pl_tl_length_rec_def_1 d la tl ->
 pl_tl_length_rec_def_1 d (prec_cons a la ls) (tcons hd tl).

Lemma pl_tl_length_rec_3 :
 forall (d : preDTA) (a : ad) (la ls : prec_list) (hd : term)
   (tl : term_list),
 liste_reconnait d ls (tcons hd tl) ->
 pl_tl_length_rec_def_1 d ls (tcons hd tl) ->
 pl_tl_length_rec_def_1 d (prec_cons a la ls) (tcons hd tl).

Lemma pl_tl_length_rec_4 :
 forall (p : preDTA) (p0 : prec_list) (t : term_list),
 liste_reconnait p p0 t -> pl_tl_length_rec_def_1 p p0 t.

Lemma pl_tl_length_rec_5 :
 forall n : nat, pl_tl_length_rec_def_0 n -> pl_tl_length_rec_def_0 (S n).

Lemma pl_tl_length_rec_6 :
 forall (d : preDTA) (pl : prec_list) (tl : term_list) (n : nat),
 pl_tl_length pl n -> liste_reconnait d pl tl -> n = lst_length tl.

Definition pl_compatible (pl0 pl1 : prec_list) : Prop :=
  exists n : nat, pl_tl_length pl0 n /\ pl_tl_length pl1 n.

Definition st_compatible (s0 s1 : state) : Prop :=
  forall (c : ad) (pl0 pl1 : prec_list),
  MapGet prec_list s0 c = Some pl0 ->
  MapGet prec_list s1 c = Some pl1 -> pl_compatible pl0 pl1.

Definition predta_compatible (d0 d1 : preDTA) : Prop :=
  forall s0 s1 : state,
  state_in_dta d0 s0 -> state_in_dta d1 s1 -> st_compatible s0 s1.

Definition dta_compatible (d0 d1 : DTA) : Prop :=
  match d0, d1 with
  | dta p0 a0, dta p1 a1 => predta_compatible p0 p1
  end.

Lemma pl_compatible_sym :
 forall pl0 pl1 : prec_list, pl_compatible pl0 pl1 -> pl_compatible pl1 pl0.

Lemma pl_compatible_empt_r :
 forall p : prec_list, pl_compatible p prec_empty -> p = prec_empty.

Lemma pl_compatible_empt_l :
 forall p : prec_list, pl_compatible prec_empty p -> p = prec_empty.

Lemma pl_compatible_cons_r :
 forall (p : prec_list) (a : ad) (la ls : prec_list),
 pl_compatible p (prec_cons a la ls) ->
 exists a0 : ad,
   (exists la0 : prec_list,
      (exists ls0 : prec_list, p = prec_cons a0 la0 ls0)).

Lemma pl_compatible_cons_l :
 forall (p : prec_list) (a : ad) (la ls : prec_list),
 pl_compatible (prec_cons a la ls) p ->
 exists a0 : ad,
   (exists la0 : prec_list,
      (exists ls0 : prec_list, p = prec_cons a0 la0 ls0)).

Lemma pl_compatible_compat :
 forall p0 p1 : prec_list, pl_compatible p0 p1 -> pl_compat p0 p1.

Definition st_compatible_compat_def (s0 : state) : Prop :=
  forall s1 : state, st_compatible s0 s1 -> mpl_compat s0 s1.

Lemma st_compatible_compat_0 : st_compatible_compat_def (M0 prec_list).

Lemma st_compatible_compat_1 :
 forall (a : ad) (a0 : prec_list),
 st_compatible_compat_def (M1 prec_list a a0).

Lemma st_compatible_compat_2 :
 forall m : Map prec_list,
 st_compatible_compat_def m ->
 forall m0 : Map prec_list,
 st_compatible_compat_def m0 -> st_compatible_compat_def (M2 prec_list m m0).

Lemma st_compatible_compat :
 forall s0 s1 : state, st_compatible s0 s1 -> mpl_compat s0 s1.

Definition predta_compatible_compat_def (d0 : preDTA) : Prop :=
  forall d1 : preDTA, predta_compatible d0 d1 -> dta_compat d0 d1.

Lemma predta_compatible_compat_0 : predta_compatible_compat_def (M0 state).

Lemma predta_compatible_compat_1 :
 forall (a : ad) (a0 : state), predta_compatible_compat_def (M1 state a a0).

Lemma predta_compatible_compat_2 :
 forall m : Map state,
 predta_compatible_compat_def m ->
 forall m0 : Map state,
 predta_compatible_compat_def m0 ->
 predta_compatible_compat_def (M2 state m m0).

Lemma predta_compatible_compat :
 forall d0 d1 : preDTA, predta_compatible d0 d1 -> dta_compat d0 d1.

Lemma dta_compatible_compat :
 forall d0 d1 : DTA, dta_compatible d0 d1 -> DTA_compat d0 d1.

Definition signature : Set := Map nat.

Definition state_correct_wrt_sign (s : state) (sigma : signature) : Prop :=
  forall (a : ad) (p : prec_list),
  MapGet prec_list s a = Some p ->
  exists n : nat, MapGet nat sigma a = Some n /\ pl_tl_length p n.

Definition predta_correct_wrt_sign (d : preDTA) (sigma : signature) : Prop :=
  forall (a : ad) (s : state),
  MapGet state d a = Some s -> state_correct_wrt_sign s sigma.

Definition dta_correct_wrt_sign (d : DTA) (sigma : signature) : Prop :=
  match d with
  | dta d a => predta_correct_wrt_sign d sigma
  end.

Lemma states_correct_wrt_sign_compatibles :
 forall (sigma : signature) (s s' : state),
 state_correct_wrt_sign s sigma ->
 state_correct_wrt_sign s' sigma -> st_compatible s s'.

Lemma predtas_correct_wrt_sign_compatibles :
 forall (sigma : signature) (d d' : preDTA),
 predta_correct_wrt_sign d sigma ->
 predta_correct_wrt_sign d' sigma -> predta_compatible d d'.

Lemma dtas_correct_wrt_sign_compatibles :
 forall (sigma : signature) (d d' : DTA),
 dta_correct_wrt_sign d sigma ->
 dta_correct_wrt_sign d' sigma -> dta_compatible d d'.

Fixpoint pl_compat_check (p : prec_list) : option nat :=
  match p with
  | prec_empty => Some 0
  | prec_cons a la ls =>
      match ls with
      | prec_empty =>
          match pl_compat_check la with
          | None => None
          | Some n => Some (S n)
          end
      | prec_cons _ _ _ =>
          match pl_compat_check la, pl_compat_check ls with
          | None, _ => None
          | _, None => None
          | Some n, Some m =>
              if beq_nat (S n) m then Some m else None
          end
      end
  end.

Lemma pl_compat_check_correct :
 forall (p : prec_list) (n : nat),
 pl_tl_length p n -> pl_compat_check p = Some n.

Lemma pl_compat_check_complete :
 forall (p : prec_list) (n : nat),
 pl_compat_check p = Some n -> pl_tl_length p n.

Inductive pre_ad : Set :=
  | pre_ad_empty : pre_ad
  | pre_ad_O : pre_ad -> pre_ad
  | pre_ad_I : pre_ad -> pre_ad.

Fixpoint pre_ad_concat (pa : pre_ad) : ad -> ad :=
  fun a : ad =>
  match pa with
  | pre_ad_empty => a
  | pre_ad_O pa' => pre_ad_concat pa' (Ndouble a)
  | pre_ad_I pa' => pre_ad_concat pa' (Ndouble_plus_one a)
  end.

Fixpoint st_compat_check_0 (pa : pre_ad) (sigma : signature) 
 (s : state) {struct s} : bool :=
  match s with
  | M0 => true
  | M1 a p =>
      match pl_compat_check p, MapGet nat sigma (pre_ad_concat pa a) with
      | None, _ => false
      | _, None => false
      | Some n, Some m => beq_nat n m
      end
  | M2 x y =>
      st_compat_check_0 (pre_ad_O pa) sigma x &&
      st_compat_check_0 (pre_ad_I pa) sigma y
  end.

Definition st_compat_check (s : state) (sigma : signature) : bool :=
  st_compat_check_0 pre_ad_empty sigma s.

Fixpoint predta_compat_check (d : preDTA) : signature -> bool :=
  fun sigma : signature =>
  match d with
  | M0 => true
  | M1 a s => st_compat_check s sigma
  | M2 x y => predta_compat_check x sigma && predta_compat_check y sigma
  end.

Definition dta_compat_check (d : DTA) (sigma : signature) : bool :=
  match d with
  | dta p a => predta_compat_check p sigma
  end.

Definition state_correct_wrt_sign_with_offset (s : state) 
  (sigma : signature) (pa : pre_ad) : Prop :=
  forall (a : ad) (p : prec_list),
  MapGet prec_list s a = Some p ->
  exists n : nat,
    MapGet nat sigma (pre_ad_concat pa a) = Some n /\ pl_tl_length p n.

Lemma state_correct_wrt_sign_with_offset_M2 :
 forall (s0 s1 : state) (sigma : signature) (pa : pre_ad),
 state_correct_wrt_sign_with_offset (M2 prec_list s0 s1) sigma pa ->
 state_correct_wrt_sign_with_offset s0 sigma (pre_ad_O pa) /\
 state_correct_wrt_sign_with_offset s1 sigma (pre_ad_I pa).

Lemma predta_correct_wrt_sign_M2 :
 forall (d0 d1 : preDTA) (sigma : signature),
 predta_correct_wrt_sign (M2 state d0 d1) sigma ->
 predta_correct_wrt_sign d0 sigma /\ predta_correct_wrt_sign d1 sigma.

Lemma st_compat_check_0_correct :
 forall (s : state) (sigma : signature) (pa : pre_ad),
 state_correct_wrt_sign_with_offset s sigma pa ->
 st_compat_check_0 pa sigma s = true.

Lemma st_compat_check_0_complete :
 forall (s : state) (sigma : signature) (pa : pre_ad),
 st_compat_check_0 pa sigma s = true ->
 state_correct_wrt_sign_with_offset s sigma pa.

Lemma st_compat_check_correct :
 forall (s : state) (sigma : signature),
 state_correct_wrt_sign s sigma -> st_compat_check s sigma = true.

Lemma st_compat_check_complete :
 forall (s : state) (sigma : signature),
 st_compat_check s sigma = true -> state_correct_wrt_sign s sigma.

Lemma predta_compat_check_correct :
 forall (d : preDTA) (sigma : signature),
 predta_correct_wrt_sign d sigma -> predta_compat_check d sigma = true.

Lemma predta_compat_check_complete :
 forall (d : preDTA) (sigma : signature),
 predta_compat_check d sigma = true -> predta_correct_wrt_sign d sigma.

Lemma dta_compat_check_correct :
 forall (d : DTA) (sigma : signature),
 dta_correct_wrt_sign d sigma -> dta_compat_check d sigma = true.

Lemma dta_compat_check_complete :
 forall (d : DTA) (sigma : signature),
 dta_compat_check d sigma = true -> dta_correct_wrt_sign d sigma. *)
Require Import refcorrect.
(* refcorrect:
Require Import Bool.
Require Import NArith Ndec.
From IntMap Require Import Allmaps.
Require Import bases.
Require Import defs.

Definition prec_list_ref_ok (p : prec_list) (d : preDTA) : Prop :=
  forall a : ad,
  prec_occur p a -> exists s : state, MapGet state d a = Some s.

Definition state_ref_ok (s : state) (d : preDTA) : Prop :=
  forall (a : ad) (p : prec_list),
  MapGet prec_list s a = Some p -> prec_list_ref_ok p d.

Definition preDTA_ref_ok (d : preDTA) : Prop :=
  forall (a : ad) (s : state) (c : ad) (pl : prec_list) (b : ad),
  MapGet state d a = Some s ->
  MapGet prec_list s c = Some pl ->
  prec_occur pl b -> exists s0 : state, MapGet state d b = Some s0.

Definition preDTA_ref_ok_distinct (d d' : preDTA) : Prop :=
  forall (a : ad) (s : state),
  MapGet state d a = Some s -> state_ref_ok s d'.

Definition DTA_ref_ok (d : DTA) : Prop :=
  match d with
  | dta p a => preDTA_ref_ok p
  end.

Lemma prec_list_ref_ok_destr :
 forall (a : ad) (la ls : prec_list) (d : preDTA),
 prec_list_ref_ok (prec_cons a la ls) d ->
 prec_list_ref_ok la d /\ prec_list_ref_ok ls d.

Lemma state_ref_ok_M2_destr :
 forall (s0 s1 : state) (d : preDTA),
 state_ref_ok (M2 prec_list s0 s1) d ->
 state_ref_ok s0 d /\ state_ref_ok s1 d.

Lemma preDTA_ref_ok_def :
 forall d : preDTA,
 preDTA_ref_ok d <->
 (forall (a : ad) (s : state),
  MapGet state d a = Some s -> state_ref_ok s d).

Lemma preDTA_ref_ok_distinct_dest :
 forall d0 d1 d : preDTA,
 preDTA_ref_ok_distinct (M2 state d0 d1) d ->
 preDTA_ref_ok_distinct d0 d /\ preDTA_ref_ok_distinct d1 d.

Definition addr_in_dta_check (d : preDTA) (a : ad) : bool :=
  match MapGet state d a with
  | None => false
  | Some _ => true
  end.

Fixpoint prec_list_ref_ok_check (p : prec_list) : preDTA -> bool :=
  fun d : preDTA =>
  match p with
  | prec_empty => true
  | prec_cons a la ls =>
      addr_in_dta_check d a &&
      (prec_list_ref_ok_check la d && prec_list_ref_ok_check ls d)
  end.

Lemma prec_list_ref_ok_check_correct :
 forall (p : prec_list) (d : preDTA),
 prec_list_ref_ok p d -> prec_list_ref_ok_check p d = true.

Lemma prec_list_ref_ok_check_complete :
 forall (p : prec_list) (d : preDTA),
 prec_list_ref_ok_check p d = true -> prec_list_ref_ok p d.

Fixpoint state_ref_ok_check (s : state) : preDTA -> bool :=
  fun d : preDTA =>
  match s with
  | M0 => true
  | M1 a p => prec_list_ref_ok_check p d
  | M2 x y => state_ref_ok_check x d && state_ref_ok_check y d
  end.

Lemma state_ref_ok_check_correct :
 forall (s : state) (d : preDTA),
 state_ref_ok s d -> state_ref_ok_check s d = true.

Lemma state_ref_ok_check_complete :
 forall (s : state) (d : preDTA),
 state_ref_ok_check s d = true -> state_ref_ok s d.

Fixpoint predta_ref_ok_check_0 (d : preDTA) : preDTA -> bool :=
  fun d' : preDTA =>
  match d with
  | M0 => true
  | M1 a s => state_ref_ok_check s d'
  | M2 x y => predta_ref_ok_check_0 x d' && predta_ref_ok_check_0 y d'
  end.

Definition predta_ref_ok_check (d : preDTA) : bool :=
  predta_ref_ok_check_0 d d.

Lemma predta_ref_ok_check_correct_0 :
 forall d d' : preDTA,
 preDTA_ref_ok_distinct d d' -> predta_ref_ok_check_0 d d' = true.

Lemma predta_ref_ok_check_complete_0 :
 forall d d' : preDTA,
 predta_ref_ok_check_0 d d' = true -> preDTA_ref_ok_distinct d d'.

Lemma predta_ref_ok_check_correct :
 forall d : preDTA, preDTA_ref_ok d -> predta_ref_ok_check d = true.

Lemma predta_ref_ok_check_complete :
 forall d : preDTA, predta_ref_ok_check d = true -> preDTA_ref_ok d.

Definition dta_ref_ok_check (d : DTA) : bool :=
  match d with
  | dta p a => predta_ref_ok_check p
  end.

Lemma dta_ref_ok_check_correct :
 forall d : DTA, DTA_ref_ok d -> dta_ref_ok_check d = true.

Lemma dta_ref_ok_check_complete :
 forall d : DTA, dta_ref_ok_check d = true -> DTA_ref_ok d.

Definition addr_in_preDTA (d : preDTA) (a : ad) : Prop :=
  exists s : state, MapGet state d a = Some s.

Definition DTA_main_state_correct (d : DTA) : Prop :=
  match d with
  | dta p a => addr_in_preDTA p a
  end.

Definition DTA_main_state_correct_check (d : DTA) : bool :=
  match d with
  | dta p a =>
      match MapGet state p a with
      | None => false
      | Some _ => true
      end
  end.

Lemma DTA_main_state_correct_check_correct :
 forall d : DTA,
 DTA_main_state_correct d -> DTA_main_state_correct_check d = true.

Lemma DTA_main_state_correct_check_complete :
 forall d : DTA,
 DTA_main_state_correct_check d = true -> DTA_main_state_correct d. *)
Require Import union.
(* union:
Require Import Bool.
Require Import NArith Ndec Ndigits.
Require Import ZArith.
Require Import Classical_Prop.
From IntMap Require Import Allmaps.
Require Import bases.
Require Import defs.
Require Import semantics.
Require Import signature.
Require Import refcorrect.

Definition uad_conv_0 (a : ad) : ad :=
  match a with
  | N0 => N0
  | Npos p => Npos (xO p)
  end.

Definition uad_conv_1 (a : ad) : ad :=
  match a with
  | N0 => Npos 1
  | Npos p => Npos (xI p)
  end.

Lemma adcnv_inj0 : forall a b : ad, uad_conv_0 a = uad_conv_0 b -> a = b.

Lemma adcnv_inj1 : forall a b : ad, uad_conv_1 a = uad_conv_1 b -> a = b.

Lemma adcnv_ok : forall a b : ad, uad_conv_0 a <> uad_conv_1 b.

Lemma adcnv_disj :
 forall a : ad, exists b : ad, a = uad_conv_0 b \/ a = uad_conv_1 b.

Fixpoint upl_conv_0 (p : prec_list) : prec_list :=
  match p with
  | prec_empty => prec_empty
  | prec_cons a p0 p1 =>
      prec_cons (uad_conv_0 a) (upl_conv_0 p0) (upl_conv_0 p1)
  end.

Fixpoint upl_conv_1 (p : prec_list) : prec_list :=
  match p with
  | prec_empty => prec_empty
  | prec_cons a p0 p1 =>
      prec_cons (uad_conv_1 a) (upl_conv_1 p0) (upl_conv_1 p1)
  end.

Fixpoint umpl_conv_0 (s : state) : state :=
  match s with
  | M0 => M0 prec_list
  | M1 a p => M1 prec_list a (upl_conv_0 p)
  | M2 p0 p1 => M2 prec_list (umpl_conv_0 p0) (umpl_conv_0 p1)
  end.

Fixpoint umpl_conv_1 (s : state) : state :=
  match s with
  | M0 => M0 prec_list
  | M1 a p => M1 prec_list a (upl_conv_1 p)
  | M2 p0 p1 => M2 prec_list (umpl_conv_1 p0) (umpl_conv_1 p1)
  end.

Fixpoint udta_conv_0_aux (d : preDTA) : preDTA :=
  match d with
  | M0 => M0 state
  | M1 a s => M1 state a (umpl_conv_0 s)
  | M2 s0 s1 => M2 state (udta_conv_0_aux s0) (udta_conv_0_aux s1)
  end.

Fixpoint udta_conv_1_aux (d : preDTA) : preDTA :=
  match d with
  | M0 => M0 state
  | M1 a s => M1 state a (umpl_conv_1 s)
  | M2 s0 s1 => M2 state (udta_conv_1_aux s0) (udta_conv_1_aux s1)
  end.

Definition udta_conv_0 (d : preDTA) : preDTA :=
  M2 state (udta_conv_0_aux d) (M0 state).

Definition udta_conv_1 (d : preDTA) : preDTA :=
  M2 state (M0 state) (udta_conv_1_aux d).

Lemma upl_conv_0_inj :
 forall p0 p1 : prec_list, upl_conv_0 p0 = upl_conv_0 p1 -> p0 = p1.

Lemma upl_conv_1_inj :
 forall p0 p1 : prec_list, upl_conv_1 p0 = upl_conv_1 p1 -> p0 = p1.

Lemma umpl_conv_0_inj :
 forall s0 s1 : state, umpl_conv_0 s0 = umpl_conv_0 s1 -> s0 = s1.

Lemma umpl_conv_1_inj :
 forall s0 s1 : state, umpl_conv_1 s0 = umpl_conv_1 s1 -> s0 = s1.

Lemma upl_conv_0_img :
 forall (p : prec_list) (a : ad) (la ls : prec_list),
 upl_conv_0 p = prec_cons a la ls ->
 exists a0 : ad,
   (exists la0 : prec_list,
      (exists ls0 : prec_list, p = prec_cons a0 la0 ls0)).

Lemma upl_conv_0_img_0 :
 forall (p : prec_list) (a : ad) (la ls : prec_list),
 upl_conv_0 p = prec_cons a la ls ->
 exists a0 : ad,
   (exists la0 : prec_list,
      (exists ls0 : prec_list,
         p = prec_cons a0 la0 ls0 /\
         a = uad_conv_0 a0 /\ la = upl_conv_0 la0 /\ ls = upl_conv_0 ls0)).

Lemma upl_conv_0_img_1 :
 forall p : prec_list, upl_conv_0 p = prec_empty -> p = prec_empty.

Lemma upl_conv_1_img :
 forall (p : prec_list) (a : ad) (la ls : prec_list),
 upl_conv_1 p = prec_cons a la ls ->
 exists a0 : ad,
   (exists la0 : prec_list,
      (exists ls0 : prec_list, p = prec_cons a0 la0 ls0)).

Lemma upl_conv_1_img_0 :
 forall (p : prec_list) (a : ad) (la ls : prec_list),
 upl_conv_1 p = prec_cons a la ls ->
 exists a0 : ad,
   (exists la0 : prec_list,
      (exists ls0 : prec_list,
         p = prec_cons a0 la0 ls0 /\
         a = uad_conv_1 a0 /\ la = upl_conv_1 la0 /\ ls = upl_conv_1 ls0)).

Lemma upl_conv_1_img_1 :
 forall p : prec_list, upl_conv_1 p = prec_empty -> p = prec_empty.

Lemma u_conv_0_invar_0 :
 forall (d : preDTA) (a : ad) (ladj : state),
 MapGet state d a = Some ladj ->
 MapGet state (udta_conv_0 d) (uad_conv_0 a) = Some (umpl_conv_0 ladj).

Lemma u_conv_0_invar_1 :
 forall (s : state) (c : ad) (p : prec_list),
 MapGet prec_list s c = Some p ->
 MapGet prec_list (umpl_conv_0 s) c = Some (upl_conv_0 p).

Lemma u_conv_0_invar_2 :
 forall (d : preDTA) (a : ad) (ladj : state),
 MapGet state (udta_conv_0 d) (uad_conv_0 a) = Some (umpl_conv_0 ladj) ->
 MapGet state d a = Some ladj.

Lemma u_conv_0_invar_3 :
 forall (s : state) (c : ad) (p : prec_list),
 MapGet prec_list (umpl_conv_0 s) c = Some (upl_conv_0 p) ->
 MapGet prec_list s c = Some p.

Lemma u_conv_0_invar_4 :
 forall (d : preDTA) (a : ad) (ladj : state),
 MapGet state (udta_conv_0 d) (uad_conv_0 a) = Some ladj ->
 exists ladj0 : _, ladj = umpl_conv_0 ladj0.

Lemma u_conv_0_invar_5 :
 forall (d : preDTA) (a : ad) (ladj : state),
 MapGet state (udta_conv_0 d) (uad_conv_0 a) = Some ladj ->
 exists ladj0 : _,
   ladj = umpl_conv_0 ladj0 /\ MapGet state d a = Some ladj0.

Lemma u_conv_0_invar_6 :
 forall (s : state) (c : ad) (p : prec_list),
 MapGet prec_list (umpl_conv_0 s) c = Some p ->
 exists p0 : prec_list, p = upl_conv_0 p0.

Lemma u_conv_0_invar_7 :
 forall (s : state) (c : ad) (p : prec_list),
 MapGet prec_list (umpl_conv_0 s) c = Some p ->
 exists p0 : prec_list,
   p = upl_conv_0 p0 /\ MapGet prec_list s c = Some p0.

Lemma u_conv_0_invar_8 :
 forall (p0 : preDTA) (a0 : ad) (s0 : state),
 MapGet state (udta_conv_0 p0) a0 = Some s0 ->
 exists a1 : ad, a0 = uad_conv_0 a1.

Definition u_conv_rec_0 (p : preDTA) (a : ad) (t : term)
  (pr : reconnaissance p a t) :=
  reconnaissance (udta_conv_0 p) (uad_conv_0 a) t.

Definition u_conv_str_0 (p : preDTA) (s : state) (t : term)
  (pr : state_reconnait p s t) :=
  state_reconnait (udta_conv_0 p) (umpl_conv_0 s) t.

Definition u_conv_lr_0 (p : preDTA) (p0 : prec_list) 
  (t : term_list) (pr : liste_reconnait p p0 t) :=
  liste_reconnait (udta_conv_0 p) (upl_conv_0 p0) t.

Lemma u_conv0_0 :
 forall (d : preDTA) (a : ad) (t : term) (ladj : state)
   (e : MapGet state d a = Some ladj) (s : state_reconnait d ladj t),
 u_conv_str_0 d ladj t s -> u_conv_rec_0 d a t (rec_dta d a t ladj e s).

Lemma u_conv0_1 :
 forall (d : preDTA) (s : state) (c : ad) (tl : term_list) 
   (l : prec_list) (e : MapGet prec_list s c = Some l)
   (l0 : liste_reconnait d l tl),
 u_conv_lr_0 d l tl l0 ->
 u_conv_str_0 d s (app c tl) (rec_st d s c tl l e l0).

Lemma u_conv0_2 :
 forall d : preDTA, u_conv_lr_0 d prec_empty tnil (rec_empty d).

Lemma u_conv0_3 :
 forall (d : preDTA) (a : ad) (la ls : prec_list) (hd : term)
   (tl : term_list) (r : reconnaissance d a hd),
 u_conv_rec_0 d a hd r ->
 forall l : liste_reconnait d la tl,
 u_conv_lr_0 d la tl l ->
 u_conv_lr_0 d (prec_cons a la ls) (tcons hd tl)
   (rec_consi d a la ls hd tl r l).

Lemma u_conv0_4 :
 forall (d : preDTA) (a : ad) (la ls : prec_list) (hd : term)
   (tl : term_list) (l : liste_reconnait d ls (tcons hd tl)),
 u_conv_lr_0 d ls (tcons hd tl) l ->
 u_conv_lr_0 d (prec_cons a la ls) (tcons hd tl)
   (rec_consn d a la ls hd tl l).

Lemma u_conv0_5 :
 forall (p : preDTA) (a : ad) (t : term) (r : reconnaissance p a t),
 u_conv_rec_0 p a t r.

Lemma u_conv0 :
 forall (p : preDTA) (a : ad) (t : term),
 reconnaissance p a t -> reconnaissance (udta_conv_0 p) (uad_conv_0 a) t.

Definition u_conv_rec_0_r (p0 : preDTA) (a0 : ad) (t : term)
  (pr0 : reconnaissance p0 a0 t) :=
  forall (p : preDTA) (a : ad),
  p0 = udta_conv_0 p -> a0 = uad_conv_0 a -> reconnaissance p a t.

Definition u_conv_str_0_r (p0 : preDTA) (s0 : state) 
  (t : term) (pr : state_reconnait p0 s0 t) :=
  forall (p : preDTA) (s : state),
  p0 = udta_conv_0 p -> s0 = umpl_conv_0 s -> state_reconnait p s t.

Definition u_conv_lr_0_r (p0 : preDTA) (pl0 : prec_list) 
  (t : term_list) (pr : liste_reconnait p0 pl0 t) :=
  forall (p : preDTA) (pl : prec_list),
  p0 = udta_conv_0 p -> pl0 = upl_conv_0 pl -> liste_reconnait p pl t.

Lemma u_conv0_0r :
 forall (d : preDTA) (a : ad) (t : term) (ladj : state)
   (e : MapGet state d a = Some ladj) (s : state_reconnait d ladj t),
 u_conv_str_0_r d ladj t s -> u_conv_rec_0_r d a t (rec_dta d a t ladj e s).

Lemma u_conv0_1r :
 forall (d : preDTA) (s : state) (c : ad) (tl : term_list) 
   (l : prec_list) (e : MapGet prec_list s c = Some l)
   (l0 : liste_reconnait d l tl),
 u_conv_lr_0_r d l tl l0 ->
 u_conv_str_0_r d s (app c tl) (rec_st d s c tl l e l0).

Lemma u_conv0_2r :
 forall d : preDTA, u_conv_lr_0_r d prec_empty tnil (rec_empty d).

Lemma u_conv0_3r :
 forall (d : preDTA) (a : ad) (la ls : prec_list) (hd : term)
   (tl : term_list) (r : reconnaissance d a hd),
 u_conv_rec_0_r d a hd r ->
 forall l : liste_reconnait d la tl,
 u_conv_lr_0_r d la tl l ->
 u_conv_lr_0_r d (prec_cons a la ls) (tcons hd tl)
   (rec_consi d a la ls hd tl r l).

Lemma u_conv0_4r :
 forall (d : preDTA) (a : ad) (la ls : prec_list) (hd : term)
   (tl : term_list) (l : liste_reconnait d ls (tcons hd tl)),
 u_conv_lr_0_r d ls (tcons hd tl) l ->
 u_conv_lr_0_r d (prec_cons a la ls) (tcons hd tl)
   (rec_consn d a la ls hd tl l).

Lemma u_conv0_5r :
 forall (p : preDTA) (a : ad) (t : term) (r : reconnaissance p a t),
 u_conv_rec_0_r p a t r.

Lemma u_conv0_r :
 forall (p : preDTA) (a : ad) (t : term),
 reconnaissance (udta_conv_0 p) (uad_conv_0 a) t -> reconnaissance p a t.

Lemma u_conv_1_invar_0 :
 forall (d : preDTA) (a : ad) (ladj : state),
 MapGet state d a = Some ladj ->
 MapGet state (udta_conv_1 d) (uad_conv_1 a) = Some (umpl_conv_1 ladj).

Lemma u_conv_1_invar_1 :
 forall (s : state) (c : ad) (p : prec_list),
 MapGet prec_list s c = Some p ->
 MapGet prec_list (umpl_conv_1 s) c = Some (upl_conv_1 p).

Lemma u_conv_1_invar_2 :
 forall (d : preDTA) (a : ad) (ladj : state),
 MapGet state (udta_conv_1 d) (uad_conv_1 a) = Some (umpl_conv_1 ladj) ->
 MapGet state d a = Some ladj.

Lemma u_conv_1_invar_3 :
 forall (s : state) (c : ad) (p : prec_list),
 MapGet prec_list (umpl_conv_1 s) c = Some (upl_conv_1 p) ->
 MapGet prec_list s c = Some p.

Lemma u_conv_1_invar_4 :
 forall (d : preDTA) (a : ad) (ladj : state),
 MapGet state (udta_conv_1 d) (uad_conv_1 a) = Some ladj ->
 exists ladj0 : _, ladj = umpl_conv_1 ladj0.

Lemma u_conv_1_invar_5 :
 forall (d : preDTA) (a : ad) (ladj : state),
 MapGet state (udta_conv_1 d) (uad_conv_1 a) = Some ladj ->
 exists ladj0 : _,
   ladj = umpl_conv_1 ladj0 /\ MapGet state d a = Some ladj0.

Lemma u_conv_1_invar_6 :
 forall (s : state) (c : ad) (p : prec_list),
 MapGet prec_list (umpl_conv_1 s) c = Some p ->
 exists p0 : prec_list, p = upl_conv_1 p0.

Lemma u_conv_1_invar_7 :
 forall (s : state) (c : ad) (p : prec_list),
 MapGet prec_list (umpl_conv_1 s) c = Some p ->
 exists p0 : prec_list,
   p = upl_conv_1 p0 /\ MapGet prec_list s c = Some p0.

Lemma u_conv_1_invar_8 :
 forall (p0 : preDTA) (a0 : ad) (s0 : state),
 MapGet state (udta_conv_1 p0) a0 = Some s0 ->
 exists a1 : ad, a0 = uad_conv_1 a1.

Definition u_conv_rec_1 (p : preDTA) (a : ad) (t : term)
  (pr : reconnaissance p a t) :=
  reconnaissance (udta_conv_1 p) (uad_conv_1 a) t.

Definition u_conv_str_1 (p : preDTA) (s : state) (t : term)
  (pr : state_reconnait p s t) :=
  state_reconnait (udta_conv_1 p) (umpl_conv_1 s) t.

Definition u_conv_lr_1 (p : preDTA) (p0 : prec_list) 
  (t : term_list) (pr : liste_reconnait p p0 t) :=
  liste_reconnait (udta_conv_1 p) (upl_conv_1 p0) t.

Lemma u_conv1_0 :
 forall (d : preDTA) (a : ad) (t : term) (ladj : state)
   (e : MapGet state d a = Some ladj) (s : state_reconnait d ladj t),
 u_conv_str_1 d ladj t s -> u_conv_rec_1 d a t (rec_dta d a t ladj e s).

Lemma u_conv1_1 :
 forall (d : preDTA) (s : state) (c : ad) (tl : term_list) 
   (l : prec_list) (e : MapGet prec_list s c = Some l)
   (l0 : liste_reconnait d l tl),
 u_conv_lr_1 d l tl l0 ->
 u_conv_str_1 d s (app c tl) (rec_st d s c tl l e l0).

Lemma u_conv1_2 :
 forall d : preDTA, u_conv_lr_1 d prec_empty tnil (rec_empty d).

Lemma u_conv1_3 :
 forall (d : preDTA) (a : ad) (la ls : prec_list) (hd : term)
   (tl : term_list) (r : reconnaissance d a hd),
 u_conv_rec_1 d a hd r ->
 forall l : liste_reconnait d la tl,
 u_conv_lr_1 d la tl l ->
 u_conv_lr_1 d (prec_cons a la ls) (tcons hd tl)
   (rec_consi d a la ls hd tl r l).

Lemma u_conv1_4 :
 forall (d : preDTA) (a : ad) (la ls : prec_list) (hd : term)
   (tl : term_list) (l : liste_reconnait d ls (tcons hd tl)),
 u_conv_lr_1 d ls (tcons hd tl) l ->
 u_conv_lr_1 d (prec_cons a la ls) (tcons hd tl)
   (rec_consn d a la ls hd tl l).

Lemma u_conv1_5 :
 forall (p : preDTA) (a : ad) (t : term) (r : reconnaissance p a t),
 u_conv_rec_1 p a t r.

Lemma u_conv1 :
 forall (p : preDTA) (a : ad) (t : term),
 reconnaissance p a t -> reconnaissance (udta_conv_1 p) (uad_conv_1 a) t.

Definition u_conv_rec_1_r (p0 : preDTA) (a0 : ad) (t : term)
  (pr0 : reconnaissance p0 a0 t) :=
  forall (p : preDTA) (a : ad),
  p0 = udta_conv_1 p -> a0 = uad_conv_1 a -> reconnaissance p a t.

Definition u_conv_str_1_r (p0 : preDTA) (s0 : state) 
  (t : term) (pr : state_reconnait p0 s0 t) :=
  forall (p : preDTA) (s : state),
  p0 = udta_conv_1 p -> s0 = umpl_conv_1 s -> state_reconnait p s t.

Definition u_conv_lr_1_r (p0 : preDTA) (pl0 : prec_list) 
  (t : term_list) (pr : liste_reconnait p0 pl0 t) :=
  forall (p : preDTA) (pl : prec_list),
  p0 = udta_conv_1 p -> pl0 = upl_conv_1 pl -> liste_reconnait p pl t.

Lemma u_conv1_0r :
 forall (d : preDTA) (a : ad) (t : term) (ladj : state)
   (e : MapGet state d a = Some ladj) (s : state_reconnait d ladj t),
 u_conv_str_1_r d ladj t s -> u_conv_rec_1_r d a t (rec_dta d a t ladj e s).

Lemma u_conv1_1r :
 forall (d : preDTA) (s : state) (c : ad) (tl : term_list) 
   (l : prec_list) (e : MapGet prec_list s c = Some l)
   (l0 : liste_reconnait d l tl),
 u_conv_lr_1_r d l tl l0 ->
 u_conv_str_1_r d s (app c tl) (rec_st d s c tl l e l0).

Lemma u_conv1_2r :
 forall d : preDTA, u_conv_lr_1_r d prec_empty tnil (rec_empty d).

Lemma u_conv1_3r :
 forall (d : preDTA) (a : ad) (la ls : prec_list) (hd : term)
   (tl : term_list) (r : reconnaissance d a hd),
 u_conv_rec_1_r d a hd r ->
 forall l : liste_reconnait d la tl,
 u_conv_lr_1_r d la tl l ->
 u_conv_lr_1_r d (prec_cons a la ls) (tcons hd tl)
   (rec_consi d a la ls hd tl r l).

Lemma u_conv1_4r :
 forall (d : preDTA) (a : ad) (la ls : prec_list) (hd : term)
   (tl : term_list) (l : liste_reconnait d ls (tcons hd tl)),
 u_conv_lr_1_r d ls (tcons hd tl) l ->
 u_conv_lr_1_r d (prec_cons a la ls) (tcons hd tl)
   (rec_consn d a la ls hd tl l).

Lemma u_conv1_5r :
 forall (p : preDTA) (a : ad) (t : term) (r : reconnaissance p a t),
 u_conv_rec_1_r p a t r.

Lemma u_conv1_r :
 forall (p : preDTA) (a : ad) (t : term),
 reconnaissance (udta_conv_1 p) (uad_conv_1 a) t -> reconnaissance p a t.

Lemma u_conv_disj :
 forall (p0 p1 : preDTA) (a0 a1 : ad) (s0 s1 : state),
 MapGet state (udta_conv_0 p0) a0 = Some s0 ->
 MapGet state (udta_conv_1 p1) a1 = Some s1 -> a0 <> a1.

Definition u_merge (p0 p1 : preDTA) : preDTA :=
  MapMerge state (udta_conv_0 p0) (udta_conv_1 p1).

Lemma u_merge_0 :
 forall (p0 p1 : preDTA) (a : ad) (s : state),
 MapGet state (udta_conv_0 p0) a = Some s ->
 MapGet state (u_merge p0 p1) a = Some s.

Lemma u_merge_1 :
 forall (p0 p1 : preDTA) (a : ad) (s : state),
 MapGet state (udta_conv_1 p1) a = Some s ->
 MapGet state (u_merge p0 p1) a = Some s.

Lemma u_merge_0r :
 forall (p0 p1 : preDTA) (a : ad) (s : state),
 MapGet state (u_merge p0 p1) a = Some s ->
 forall b : ad,
 a = uad_conv_0 b -> MapGet state (udta_conv_0 p0) a = Some s.

Lemma u_merge_1r :
 forall (p0 p1 : preDTA) (a : ad) (s : state),
 MapGet state (u_merge p0 p1) a = Some s ->
 forall b : ad,
 a = uad_conv_1 b -> MapGet state (udta_conv_1 p1) a = Some s.

Definition u_merge_inv_0_dta (p0 : preDTA) (a : ad) 
  (t : term) (pr : reconnaissance p0 a t) :=
  forall p1 : preDTA, reconnaissance (u_merge p0 p1) (uad_conv_0 a) t.

Definition u_merge_inv_0_st (p0 : preDTA) (s : state) 
  (t : term) (pr : state_reconnait p0 s t) :=
  forall p1 : preDTA, state_reconnait (u_merge p0 p1) (umpl_conv_0 s) t.

Definition u_merge_inv_0_lst (p0 : preDTA) (pl : prec_list) 
  (lt : term_list) (pr : liste_reconnait p0 pl lt) :=
  forall p1 : preDTA, liste_reconnait (u_merge p0 p1) (upl_conv_0 pl) lt.

Lemma u_merge_2_0 :
 forall (d : preDTA) (a : ad) (t : term) (ladj : state)
   (e : MapGet state d a = Some ladj) (s : state_reconnait d ladj t),
 u_merge_inv_0_st d ladj t s ->
 u_merge_inv_0_dta d a t (rec_dta d a t ladj e s).

Lemma u_merge_2_1 :
 forall (d : preDTA) (s : state) (c : ad) (tl : term_list) 
   (l : prec_list) (e : MapGet prec_list s c = Some l)
   (l0 : liste_reconnait d l tl),
 u_merge_inv_0_lst d l tl l0 ->
 u_merge_inv_0_st d s (app c tl) (rec_st d s c tl l e l0).

Lemma u_merge_2_2 :
 forall d : preDTA, u_merge_inv_0_lst d prec_empty tnil (rec_empty d).

Lemma u_merge_2_3 :
 forall (d : preDTA) (a : ad) (la ls : prec_list) (hd : term)
   (tl : term_list) (r : reconnaissance d a hd),
 u_merge_inv_0_dta d a hd r ->
 forall l : liste_reconnait d la tl,
 u_merge_inv_0_lst d la tl l ->
 u_merge_inv_0_lst d (prec_cons a la ls) (tcons hd tl)
   (rec_consi d a la ls hd tl r l).

Lemma u_merge_2_4 :
 forall (d : preDTA) (a : ad) (la ls : prec_list) (hd : term)
   (tl : term_list) (l : liste_reconnait d ls (tcons hd tl)),
 u_merge_inv_0_lst d ls (tcons hd tl) l ->
 u_merge_inv_0_lst d (prec_cons a la ls) (tcons hd tl)
   (rec_consn d a la ls hd tl l).

Lemma u_merge_2_5 :
 forall (p : preDTA) (a : ad) (t : term) (r : reconnaissance p a t),
 u_merge_inv_0_dta p a t r.

Lemma u_merge_2 :
 forall (p0 p1 : preDTA) (a : ad) (t : term),
 reconnaissance p0 a t -> reconnaissance (u_merge p0 p1) (uad_conv_0 a) t.

Definition u_merge_inv_1_dta (p1 : preDTA) (a : ad) 
  (t : term) (pr : reconnaissance p1 a t) :=
  forall p0 : preDTA, reconnaissance (u_merge p0 p1) (uad_conv_1 a) t.

Definition u_merge_inv_1_st (p1 : preDTA) (s : state) 
  (t : term) (pr : state_reconnait p1 s t) :=
  forall p0 : preDTA, state_reconnait (u_merge p0 p1) (umpl_conv_1 s) t.

Definition u_merge_inv_1_lst (p1 : preDTA) (pl : prec_list) 
  (lt : term_list) (pr : liste_reconnait p1 pl lt) :=
  forall p0 : preDTA, liste_reconnait (u_merge p0 p1) (upl_conv_1 pl) lt.

Lemma u_merge_3_0 :
 forall (d : preDTA) (a : ad) (t : term) (ladj : state)
   (e : MapGet state d a = Some ladj) (s : state_reconnait d ladj t),
 u_merge_inv_1_st d ladj t s ->
 u_merge_inv_1_dta d a t (rec_dta d a t ladj e s).

Lemma u_merge_3_1 :
 forall (d : preDTA) (s : state) (c : ad) (tl : term_list) 
   (l : prec_list) (e : MapGet prec_list s c = Some l)
   (l0 : liste_reconnait d l tl),
 u_merge_inv_1_lst d l tl l0 ->
 u_merge_inv_1_st d s (app c tl) (rec_st d s c tl l e l0).

Lemma u_merge_3_2 :
 forall d : preDTA, u_merge_inv_1_lst d prec_empty tnil (rec_empty d).

Lemma u_merge_3_3 :
 forall (d : preDTA) (a : ad) (la ls : prec_list) (hd : term)
   (tl : term_list) (r : reconnaissance d a hd),
 u_merge_inv_1_dta d a hd r ->
 forall l : liste_reconnait d la tl,
 u_merge_inv_1_lst d la tl l ->
 u_merge_inv_1_lst d (prec_cons a la ls) (tcons hd tl)
   (rec_consi d a la ls hd tl r l).

Lemma u_merge_3_4 :
 forall (d : preDTA) (a : ad) (la ls : prec_list) (hd : term)
   (tl : term_list) (l : liste_reconnait d ls (tcons hd tl)),
 u_merge_inv_1_lst d ls (tcons hd tl) l ->
 u_merge_inv_1_lst d (prec_cons a la ls) (tcons hd tl)
   (rec_consn d a la ls hd tl l).

Lemma u_merge_3_5 :
 forall (p : preDTA) (a : ad) (t : term) (r : reconnaissance p a t),
 u_merge_inv_1_dta p a t r.

Lemma u_merge_3 :
 forall (p0 p1 : preDTA) (a : ad) (t : term),
 reconnaissance p1 a t -> reconnaissance (u_merge p0 p1) (uad_conv_1 a) t.

Definition u_merge_invr_0_dta (p : preDTA) (a : ad) 
  (t : term) (pr : reconnaissance p a t) :=
  forall p0 p1 : preDTA,
  p = u_merge p0 p1 ->
  forall a0 : ad, a = uad_conv_0 a0 -> reconnaissance (udta_conv_0 p0) a t.

Definition u_merge_invr_0_st (p : preDTA) (s : state) 
  (t : term) (pr : state_reconnait p s t) :=
  forall p0 p1 : preDTA,
  p = u_merge p0 p1 ->
  forall s0 : state,
  s = umpl_conv_0 s0 -> state_reconnait (udta_conv_0 p0) s t.

Definition u_merge_invr_0_lst (p : preDTA) (pl : prec_list) 
  (lt : term_list) (pr : liste_reconnait p pl lt) :=
  forall p0 p1 : preDTA,
  p = u_merge p0 p1 ->
  forall pl0 : prec_list,
  pl = upl_conv_0 pl0 -> liste_reconnait (udta_conv_0 p0) pl lt.

Lemma u_merge_4_0 :
 forall (d : preDTA) (a : ad) (t : term) (ladj : state)
   (e : MapGet state d a = Some ladj) (s : state_reconnait d ladj t),
 u_merge_invr_0_st d ladj t s ->
 u_merge_invr_0_dta d a t (rec_dta d a t ladj e s).

Lemma u_merge_4_1 :
 forall (d : preDTA) (s : state) (c : ad) (tl : term_list) 
   (l : prec_list) (e : MapGet prec_list s c = Some l)
   (l0 : liste_reconnait d l tl),
 u_merge_invr_0_lst d l tl l0 ->
 u_merge_invr_0_st d s (app c tl) (rec_st d s c tl l e l0).

Lemma u_merge_4_2 :
 forall d : preDTA, u_merge_invr_0_lst d prec_empty tnil (rec_empty d).

Lemma u_merge_4_3 :
 forall (d : preDTA) (a : ad) (la ls : prec_list) (hd : term)
   (tl : term_list) (r : reconnaissance d a hd),
 u_merge_invr_0_dta d a hd r ->
 forall l : liste_reconnait d la tl,
 u_merge_invr_0_lst d la tl l ->
 u_merge_invr_0_lst d (prec_cons a la ls) (tcons hd tl)
   (rec_consi d a la ls hd tl r l).

Lemma u_merge_4_4 :
 forall (d : preDTA) (a : ad) (la ls : prec_list) (hd : term)
   (tl : term_list) (l : liste_reconnait d ls (tcons hd tl)),
 u_merge_invr_0_lst d ls (tcons hd tl) l ->
 u_merge_invr_0_lst d (prec_cons a la ls) (tcons hd tl)
   (rec_consn d a la ls hd tl l).

Lemma u_merge_4_5 :
 forall (p : preDTA) (a : ad) (t : term) (r : reconnaissance p a t),
 u_merge_invr_0_dta p a t r.

Lemma u_merge_4 :
 forall (p0 p1 : preDTA) (a : ad) (t : term),
 reconnaissance (u_merge p0 p1) (uad_conv_0 a) t -> reconnaissance p0 a t.

Definition u_merge_invr_1_dta (p : preDTA) (a : ad) 
  (t : term) (pr : reconnaissance p a t) :=
  forall p0 p1 : preDTA,
  p = u_merge p0 p1 ->
  forall a0 : ad, a = uad_conv_1 a0 -> reconnaissance (udta_conv_1 p1) a t.

Definition u_merge_invr_1_st (p : preDTA) (s : state) 
  (t : term) (pr : state_reconnait p s t) :=
  forall p0 p1 : preDTA,
  p = u_merge p0 p1 ->
  forall s0 : state,
  s = umpl_conv_1 s0 -> state_reconnait (udta_conv_1 p1) s t.

Definition u_merge_invr_1_lst (p : preDTA) (pl : prec_list) 
  (lt : term_list) (pr : liste_reconnait p pl lt) :=
  forall p0 p1 : preDTA,
  p = u_merge p0 p1 ->
  forall pl0 : prec_list,
  pl = upl_conv_1 pl0 -> liste_reconnait (udta_conv_1 p1) pl lt.

Lemma u_merge_5_0 :
 forall (d : preDTA) (a : ad) (t : term) (ladj : state)
   (e : MapGet state d a = Some ladj) (s : state_reconnait d ladj t),
 u_merge_invr_1_st d ladj t s ->
 u_merge_invr_1_dta d a t (rec_dta d a t ladj e s).

Lemma u_merge_5_1 :
 forall (d : preDTA) (s : state) (c : ad) (tl : term_list) 
   (l : prec_list) (e : MapGet prec_list s c = Some l)
   (l0 : liste_reconnait d l tl),
 u_merge_invr_1_lst d l tl l0 ->
 u_merge_invr_1_st d s (app c tl) (rec_st d s c tl l e l0).

Lemma u_merge_5_2 :
 forall d : preDTA, u_merge_invr_1_lst d prec_empty tnil (rec_empty d).

Lemma u_merge_5_3 :
 forall (d : preDTA) (a : ad) (la ls : prec_list) (hd : term)
   (tl : term_list) (r : reconnaissance d a hd),
 u_merge_invr_1_dta d a hd r ->
 forall l : liste_reconnait d la tl,
 u_merge_invr_1_lst d la tl l ->
 u_merge_invr_1_lst d (prec_cons a la ls) (tcons hd tl)
   (rec_consi d a la ls hd tl r l).

Lemma u_merge_5_4 :
 forall (d : preDTA) (a : ad) (la ls : prec_list) (hd : term)
   (tl : term_list) (l : liste_reconnait d ls (tcons hd tl)),
 u_merge_invr_1_lst d ls (tcons hd tl) l ->
 u_merge_invr_1_lst d (prec_cons a la ls) (tcons hd tl)
   (rec_consn d a la ls hd tl l).

Lemma u_merge_5_5 :
 forall (p : preDTA) (a : ad) (t : term) (r : reconnaissance p a t),
 u_merge_invr_1_dta p a t r.

Lemma u_merge_5 :
 forall (p0 p1 : preDTA) (a : ad) (t : term),
 reconnaissance (u_merge p0 p1) (uad_conv_1 a) t -> reconnaissance p1 a t.

Fixpoint union_pl (pl0 : prec_list) : prec_list -> prec_list :=
  fun pl1 : prec_list =>
  match pl0 with
  | prec_empty => pl1
  | prec_cons a pl00 pl01 => prec_cons a pl00 (union_pl pl01 pl1)
  end.

Fixpoint union_mpl_0 (c : ad) (pl : prec_list) (s : state) {struct s} :
 state :=
  match s with
  | M0 => M1 prec_list c pl
  | M1 c0 pl0 =>
      if Neqb c c0
      then M1 prec_list c (union_pl pl pl0)
      else MapMerge prec_list (M1 prec_list c pl) (M1 prec_list c0 pl0)
  | M2 s0 s1 =>
      match c with
      | N0 => M2 prec_list (union_mpl_0 N0 pl s0) s1
      | Npos p =>
          match p with
          | xH => M2 prec_list s0 (union_mpl_0 N0 pl s1)
          | xO p' => M2 prec_list (union_mpl_0 (Npos p') pl s0) s1
          | xI p' => M2 prec_list s0 (union_mpl_0 (Npos p') pl s1)
          end
      end
  end.

Fixpoint union_mpl (s0 : state) : state -> state :=
  fun s1 : state =>
  match s0, s1 with
  | M0, M0 => M0 prec_list
  | M0, M2 s10 s11 => M2 prec_list s10 s11
  | _, M1 c1 pl1 => union_mpl_0 c1 pl1 s0
  | M1 c0 pl0, _ => union_mpl_0 c0 pl0 s1
  | M2 s00 s01, M0 => M2 prec_list s00 s01
  | M2 s00 s01, M2 s10 s11 =>
      M2 prec_list (union_mpl s00 s10) (union_mpl s01 s11)
  end.

Lemma union_pl_0 : forall pl : prec_list, union_pl pl prec_empty = pl.

Lemma union_pl_1 : forall pl : prec_list, union_pl prec_empty pl = pl.

Lemma union_pl_2 :
 forall pl0 pl1 : prec_list,
 union_pl pl0 pl1 = prec_empty -> pl0 = prec_empty.

Lemma union_pl_3 :
 forall pl0 pl1 : prec_list,
 pl0 <> prec_empty -> union_pl pl0 pl1 <> prec_empty.

Lemma union_pl_0d_0 :
 forall (d : preDTA) (pl0 : prec_list) (tl : term_list),
 liste_reconnait d pl0 tl -> liste_reconnait d (union_pl pl0 prec_empty) tl.

Lemma union_pl_0d_1 :
 forall (d : preDTA) (pl0 : prec_list) (tl : term_list) 
   (a : ad) (la ls : prec_list),
 liste_reconnait d pl0 tl ->
 pl0 <> prec_empty -> liste_reconnait d (union_pl pl0 (prec_cons a la ls)) tl.

Lemma union_pl_0d :
 forall (d : preDTA) (pl0 pl1 : prec_list) (tl : term_list),
 pl_compat pl0 pl1 ->
 liste_reconnait d pl0 tl -> liste_reconnait d (union_pl pl0 pl1) tl.

Lemma union_pl_1d_0 :
 forall (d : preDTA) (pl1 : prec_list) (tl : term_list),
 liste_reconnait d pl1 tl -> liste_reconnait d (union_pl prec_empty pl1) tl.

Lemma union_pl_1d_1 :
 forall (d : preDTA) (pl1 : prec_list) (tl : term_list) pl0,
 liste_reconnait d pl1 tl ->
 pl1 <> prec_empty -> liste_reconnait d (union_pl pl0 pl1) tl.

Lemma union_pl_1d :
 forall (d : preDTA) (pl0 pl1 : prec_list) (tl : term_list),
 pl_compat pl0 pl1 ->
 liste_reconnait d pl1 tl -> liste_reconnait d (union_pl pl0 pl1) tl.

Lemma union_pl_r_0 :
 forall (d : preDTA) (pl0 pl1 : prec_list) (hd : term) (tl : term_list),
 liste_reconnait d (union_pl pl0 pl1) (tcons hd tl) ->
 liste_reconnait d pl0 (tcons hd tl) \/ liste_reconnait d pl1 (tcons hd tl).

Lemma union_pl_r_1 :
 forall (d : preDTA) (pl0 pl1 : prec_list),
 pl_compat pl0 pl1 ->
 liste_reconnait d (union_pl pl0 pl1) tnil ->
 liste_reconnait d pl0 tnil \/ liste_reconnait d pl1 tnil.

Lemma union_pl_r :
 forall (d : preDTA) (pl0 pl1 : prec_list) (tl : term_list),
 pl_compat pl0 pl1 ->
 liste_reconnait d (union_pl pl0 pl1) tl ->
 liste_reconnait d pl0 tl \/ liste_reconnait d pl1 tl.

Definition mpl_compat_7_def (s : state) : Prop :=
  forall (c : ad) (pl l : prec_list),
  MapGet prec_list s c = Some l ->
  MapGet prec_list (union_mpl_0 c pl s) c = Some (union_pl pl l).

Lemma mpl_compat_7_0 : mpl_compat_7_def (M0 prec_list).

Lemma mpl_compat_7_1 :
 forall (a : ad) (a0 : prec_list), mpl_compat_7_def (M1 prec_list a a0).

Lemma mpl_compat_7_2 :
 forall m : Map prec_list,
 mpl_compat_7_def m ->
 forall m0 : Map prec_list,
 mpl_compat_7_def m0 -> mpl_compat_7_def (M2 prec_list m m0).

Lemma mpl_compat_7_3 : forall m : state, mpl_compat_7_def m.

Lemma mpl_compat_7 :
 forall (s : state) (c : ad) (pl l : prec_list),
 MapGet prec_list s c = Some l ->
 MapGet prec_list (union_mpl_0 c pl s) c = Some (union_pl pl l).

Definition mpl_compat_8_def (s : state) : Prop :=
  forall (a c : ad) (pl l : prec_list),
  MapGet prec_list s c = Some l ->
  a <> c -> MapGet prec_list (union_mpl_0 a pl s) c = Some l.

Lemma mpl_compat_8_0 : mpl_compat_8_def (M0 prec_list).

Lemma mpl_compat_8_1 :
 forall (a : ad) (a0 : prec_list), mpl_compat_8_def (M1 prec_list a a0).

Lemma mpl_compat_8_2 :
 forall m : state,
 mpl_compat_8_def m ->
 forall m0 : state,
 mpl_compat_8_def m0 -> mpl_compat_8_def (M2 prec_list m m0).

Lemma mpl_compat_8_3 : forall m : state, mpl_compat_8_def m.

Lemma mpl_compat_8 :
 forall (s : state) (a c : ad) (pl l : prec_list),
 MapGet prec_list s c = Some l ->
 a <> c -> MapGet prec_list (union_mpl_0 a pl s) c = Some l.

Lemma union_s0d_0 :
 forall (d : preDTA) (c : ad) (pl : prec_list) (tl : term_list),
 mpl_compat (M1 prec_list c pl) (M0 prec_list) ->
 state_reconnait d (M1 prec_list c pl) (app c tl) ->
 state_reconnait d (union_mpl_0 c pl (M0 prec_list)) (app c tl).

Lemma union_s0d_1_0 :
 forall (d : preDTA) (c : ad) (pl pl0 : prec_list) (tl : term_list),
 mpl_compat (M1 prec_list c pl) (M1 prec_list c pl0) ->
 state_reconnait d (M1 prec_list c pl) (app c tl) ->
 state_reconnait d (union_mpl_0 c pl (M1 prec_list c pl0)) (app c tl).

Lemma union_s0d_1_1 :
 forall (d : preDTA) (c : ad) (pl : prec_list) (c0 : ad) 
   (pl0 : prec_list) (tl : term_list),
 mpl_compat (M1 prec_list c pl) (M1 prec_list c0 pl0) ->
 c <> c0 ->
 state_reconnait d (M1 prec_list c pl) (app c tl) ->
 state_reconnait d (union_mpl_0 c pl (M1 prec_list c0 pl0)) (app c tl).

Lemma union_s0d_2_0 :
 forall (d : preDTA) (pl : prec_list) (s0 s1 : state) (tl : term_list),
 mpl_compat (M1 prec_list N0 pl) (M2 prec_list s0 s1) ->
 state_reconnait d (M1 prec_list N0 pl) (app N0 tl) ->
 state_reconnait d (union_mpl_0 N0 pl (M2 prec_list s0 s1)) (app N0 tl).

Lemma union_s0d_2_1 :
 forall (d : preDTA) (pl : prec_list) (s0 s1 : state) (tl : term_list),
 mpl_compat (M1 prec_list (Npos 1) pl) (M2 prec_list s0 s1) ->
 state_reconnait d (M1 prec_list (Npos 1) pl) (app (Npos 1) tl) ->
 state_reconnait d (union_mpl_0 (Npos 1) pl (M2 prec_list s0 s1))
   (app (Npos 1) tl).

Definition union_s_prd0 (s : state) : Prop :=
  forall (d : preDTA) (c : ad) (pl : prec_list) (tl : term_list),
  mpl_compat (M1 prec_list c pl) s ->
  state_reconnait d (M1 prec_list c pl) (app c tl) ->
  state_reconnait d (union_mpl_0 c pl s) (app c tl).

Lemma union_s0d_2 :
 forall m : Map prec_list,
 union_s_prd0 m ->
 forall m0 : Map prec_list,
 union_s_prd0 m0 -> union_s_prd0 (M2 prec_list m m0).

Lemma union_s0d_3 : union_s_prd0 (M0 prec_list).

Lemma union_s0d_1 :
 forall (a : ad) (a0 : prec_list), union_s_prd0 (M1 prec_list a a0).

Lemma union_s_0d : forall m : state, union_s_prd0 m.

Lemma union_s0d :
 forall (s : state) (d : preDTA) (c : ad) (pl : prec_list) (tl : term_list),
 mpl_compat (M1 prec_list c pl) s ->
 state_reconnait d (M1 prec_list c pl) (app c tl) ->
 state_reconnait d (union_mpl_0 c pl s) (app c tl).

Definition union_s_prd1 (s : state) : Prop :=
  forall (d : preDTA) (a : ad) (pl : prec_list) (c : ad) (tl : term_list),
  mpl_compat (M1 prec_list a pl) s ->
  state_reconnait d s (app c tl) ->
  state_reconnait d (union_mpl_0 a pl s) (app c tl).

Lemma union_s1d_0 : union_s_prd1 (M0 prec_list).

Lemma union_s1d_1_0 :
 forall (d : preDTA) (a : ad) (pl pl0 : prec_list) (c : ad) (tl : term_list),
 mpl_compat (M1 prec_list a pl) (M1 prec_list c pl0) ->
 a <> c ->
 state_reconnait d (M1 prec_list c pl0) (app c tl) ->
 state_reconnait d (union_mpl_0 a pl (M1 prec_list c pl0)) (app c tl).

Lemma union_s1d_1_1 :
 forall (d : preDTA) (pl pl0 : prec_list) (c : ad) (tl : term_list),
 mpl_compat (M1 prec_list c pl) (M1 prec_list c pl0) ->
 state_reconnait d (M1 prec_list c pl0) (app c tl) ->
 state_reconnait d (union_mpl_0 c pl (M1 prec_list c pl0)) (app c tl).

Lemma union_s1d_1 :
 forall (a : ad) (a0 : prec_list), union_s_prd1 (M1 prec_list a a0).

Lemma union_s1d_2 :
 forall m : state,
 union_s_prd1 m ->
 forall m0 : state, union_s_prd1 m0 -> union_s_prd1 (M2 prec_list m m0).

Lemma union_s1d_3 : forall m : state, union_s_prd1 m.

Lemma union_s1d :
 forall (s : state) (d : preDTA) (a : ad) (pl : prec_list) 
   (c : ad) (tl : term_list),
 mpl_compat (M1 prec_list a pl) s ->
 state_reconnait d s (app c tl) ->
 state_reconnait d (union_mpl_0 a pl s) (app c tl).

Definition union_std_def (s0 : state) : Prop :=
  forall (s1 : state) (d : preDTA) (c : ad) (tl : term_list),
  mpl_compat s0 s1 ->
  state_reconnait d s0 (app c tl) ->
  state_reconnait d (union_mpl s0 s1) (app c tl) /\
  state_reconnait d (union_mpl s1 s0) (app c tl).

Lemma union_std_0 : union_std_def (M0 prec_list).

Lemma union_std_1 :
 forall (a : ad) (a0 : prec_list), union_std_def (M1 prec_list a a0).

Lemma union_std_2 :
 forall m : state,
 union_std_def m ->
 forall m0 : state, union_std_def m0 -> union_std_def (M2 prec_list m m0).

Lemma union_std : forall m : state, union_std_def m.

Lemma union_sd :
 forall (s0 s1 : state) (d : preDTA) (c : ad) (tl : term_list),
 mpl_compat s0 s1 ->
 state_reconnait d s0 (app c tl) ->
 state_reconnait d (union_mpl s0 s1) (app c tl) /\
 state_reconnait d (union_mpl s1 s0) (app c tl).

Definition union_s_rpl_def (s : state) : Prop :=
  forall (d : preDTA) (a : ad) (pl : prec_list) (c : ad) (tl : term_list),
  mpl_compat (M1 prec_list a pl) s ->
  state_reconnait d (union_mpl_0 a pl s) (app c tl) ->
  state_reconnait d (M1 prec_list a pl) (app c tl) \/
  state_reconnait d s (app c tl).

Lemma union_s_rpl_0 : union_s_rpl_def (M0 prec_list).

Lemma union_s_rpl_1 :
 forall (a : ad) (a0 : prec_list), union_s_rpl_def (M1 prec_list a a0).

Lemma union_s_rpl_2 :
 forall m : state,
 union_s_rpl_def m ->
 forall m0 : state, union_s_rpl_def m0 -> union_s_rpl_def (M2 prec_list m m0).

Lemma union_s_rpl_3 : forall m : state, union_s_rpl_def m.

Lemma union_s_rpl :
 forall (s : state) (d : preDTA) (a : ad) (pl : prec_list) 
   (c : ad) (tl : term_list),
 mpl_compat (M1 prec_list a pl) s ->
 state_reconnait d (union_mpl_0 a pl s) (app c tl) ->
 state_reconnait d (M1 prec_list a pl) (app c tl) \/
 state_reconnait d s (app c tl).

Definition union_str_def (s0 : state) : Prop :=
  forall (s1 : state) (d : preDTA) (c : ad) (tl : term_list),
  mpl_compat s0 s1 ->
  state_reconnait d (union_mpl s0 s1) (app c tl) \/
  state_reconnait d (union_mpl s1 s0) (app c tl) ->
  state_reconnait d s0 (app c tl) \/ state_reconnait d s1 (app c tl).

Lemma union_str_0 : union_str_def (M0 prec_list).

Lemma union_str_1 :
 forall (a : ad) (a0 : prec_list), union_str_def (M1 prec_list a a0).

Lemma union_str_2 :
 forall m : state,
 union_str_def m ->
 forall m0 : state, union_str_def m0 -> union_str_def (M2 prec_list m m0).

Lemma union_str_3 : forall m : state, union_str_def m.

Lemma union_str :
 forall (s0 s1 : state) (d : preDTA) (c : ad) (tl : term_list),
 mpl_compat s0 s1 ->
 state_reconnait d (union_mpl s0 s1) (app c tl) \/
 state_reconnait d (union_mpl s1 s0) (app c tl) ->
 state_reconnait d s0 (app c tl) \/ state_reconnait d s1 (app c tl).

Lemma union_state :
 forall (s0 s1 : state) (d : preDTA) (t : term),
 mpl_compat s0 s1 ->
 (state_reconnait d (union_mpl s0 s1) t <->
  state_reconnait d s0 t \/ state_reconnait d s1 t).

Definition new_preDTA_ad : preDTA -> ad := ad_alloc_opt state.

Definition new_state_insd_def_dta (d : preDTA) (a0 : ad) 
  (t0 : term) (pr : reconnaissance d a0 t0) :=
  forall (a : ad) (s : state),
  MapGet state d a = None -> reconnaissance (MapPut state d a s) a0 t0.

Definition new_state_insd_def_st (d : preDTA) (s0 : state) 
  (t0 : term) (pr : state_reconnait d s0 t0) :=
  forall (a : ad) (s : state),
  MapGet state d a = None -> state_reconnait (MapPut state d a s) s0 t0.

Definition new_state_insd_def_lst (d : preDTA) (pl0 : prec_list)
  (tl0 : term_list) (pr : liste_reconnait d pl0 tl0) :=
  forall (a : ad) (s : state),
  MapGet state d a = None ->
  liste_reconnait (MapPut state d a s) pl0 tl0.

Lemma new_state_insd_0 :
 forall (d : preDTA) (a : ad) (t : term) (ladj : state)
   (e : MapGet state d a = Some ladj) (s : state_reconnait d ladj t),
 new_state_insd_def_st d ladj t s ->
 new_state_insd_def_dta d a t (rec_dta d a t ladj e s).

Lemma new_state_insd_1 :
 forall (d : preDTA) (s : state) (c : ad) (tl : term_list) 
   (l : prec_list) (e : MapGet prec_list s c = Some l)
   (l0 : liste_reconnait d l tl),
 new_state_insd_def_lst d l tl l0 ->
 new_state_insd_def_st d s (app c tl) (rec_st d s c tl l e l0).

Lemma new_state_insd_2 :
 forall d : preDTA, new_state_insd_def_lst d prec_empty tnil (rec_empty d).

Lemma new_state_insd_3 :
 forall (d : preDTA) (a : ad) (la ls : prec_list) (hd : term)
   (tl : term_list) (r : reconnaissance d a hd),
 new_state_insd_def_dta d a hd r ->
 forall l : liste_reconnait d la tl,
 new_state_insd_def_lst d la tl l ->
 new_state_insd_def_lst d (prec_cons a la ls) (tcons hd tl)
   (rec_consi d a la ls hd tl r l).

Lemma new_state_insd_4 :
 forall (d : preDTA) (a : ad) (la ls : prec_list) (hd : term)
   (tl : term_list) (l : liste_reconnait d ls (tcons hd tl)),
 new_state_insd_def_lst d ls (tcons hd tl) l ->
 new_state_insd_def_lst d (prec_cons a la ls) (tcons hd tl)
   (rec_consn d a la ls hd tl l).

Lemma new_state_insd_5 :
 forall (p : preDTA) (a : ad) (t : term) (r : reconnaissance p a t),
 new_state_insd_def_dta p a t r.

Lemma new_state_ins_d :
 forall (d : preDTA) (a : ad) (s : state) (a0 : ad) (t : term),
 reconnaissance d a0 t ->
 MapGet state d a = None -> reconnaissance (MapPut state d a s) a0 t.

Definition new_state_insr_def_dta (d0 : preDTA) (a0 : ad) 
  (t0 : term) (pr : reconnaissance d0 a0 t0) :=
  forall (d : preDTA) (a : ad) (s : state),
  preDTA_ref_ok d ->
  d0 = MapPut state d a s ->
  MapGet state d a = None -> a <> a0 -> reconnaissance d a0 t0.

Definition new_state_insr_def_st (d0 : preDTA) (s0 : state) 
  (t0 : term) (pr : state_reconnait d0 s0 t0) :=
  forall (d : preDTA) (a : ad) (s : state),
  preDTA_ref_ok d ->
  state_in_dta_diff d0 s0 a ->
  d0 = MapPut state d a s ->
  MapGet state d a = None -> state_reconnait d s0 t0.

Definition new_state_insr_def_lst (d0 : preDTA) (pl0 : prec_list)
  (tl0 : term_list) (pr : liste_reconnait d0 pl0 tl0) :=
  forall (d : preDTA) (a : ad) (s : state),
  preDTA_ref_ok d ->
  d0 = MapPut state d a s ->
  MapGet state d a = None ->
  prec_in_dta_diff_cont d0 pl0 a ->
  liste_reconnait d pl0 tl0 /\ prec_in_dta_diff_cont d pl0 a.

Lemma new_state_insr_0 :
 forall (d : preDTA) (a : ad) (t : term) (ladj : state)
   (e : MapGet state d a = Some ladj) (s : state_reconnait d ladj t),
 new_state_insr_def_st d ladj t s ->
 new_state_insr_def_dta d a t (rec_dta d a t ladj e s).

Lemma new_state_insr_1 :
 forall (d : preDTA) (s : state) (c : ad) (tl : term_list) 
   (l : prec_list) (e : MapGet prec_list s c = Some l)
   (l0 : liste_reconnait d l tl),
 new_state_insr_def_lst d l tl l0 ->
 new_state_insr_def_st d s (app c tl) (rec_st d s c tl l e l0).

Lemma new_state_insr_2 :
 forall d : preDTA, new_state_insr_def_lst d prec_empty tnil (rec_empty d).

Lemma new_state_insr_3 :
 forall (d : preDTA) (a : ad) (la ls : prec_list) (hd : term)
   (tl : term_list) (r : reconnaissance d a hd),
 new_state_insr_def_dta d a hd r ->
 forall l : liste_reconnait d la tl,
 new_state_insr_def_lst d la tl l ->
 new_state_insr_def_lst d (prec_cons a la ls) (tcons hd tl)
   (rec_consi d a la ls hd tl r l).

Lemma new_state_insr_4 :
 forall (d : preDTA) (a : ad) (la ls : prec_list) (hd : term)
   (tl : term_list) (l : liste_reconnait d ls (tcons hd tl)),
 new_state_insr_def_lst d ls (tcons hd tl) l ->
 new_state_insr_def_lst d (prec_cons a la ls) (tcons hd tl)
   (rec_consn d a la ls hd tl l).

Lemma new_state_insr_5 :
 forall (p : preDTA) (a : ad) (t : term) (r : reconnaissance p a t),
 new_state_insr_def_dta p a t r.

Lemma new_state_ins_r :
 forall (d0 : preDTA) (a0 : ad) (t0 : term) (d : preDTA) (a : ad) (s : state),
 reconnaissance d0 a0 t0 ->
 preDTA_ref_ok d ->
 d0 = MapPut state d a s ->
 MapGet state d a = None -> a <> a0 -> reconnaissance d a0 t0.

Definition insert_state (d : preDTA) (a : ad) (s : state) : preDTA :=
  MapPut state d a s.

Definition insert_main_state_0 (d : preDTA) (a : ad) 
  (s : state) : DTA := dta (insert_state d a s) a.

Definition insert_main_state (d : preDTA) (s : state) : DTA :=
  insert_main_state_0 d (new_preDTA_ad d) s.

Definition insert_ostate (d : preDTA) (a : ad) (o : option state) : preDTA :=
  match o with
  | None => d
  | Some s => MapPut state d a s
  end.

Definition insert_main_ostate_0 (d : preDTA) (a : ad) 
  (o : option state) : DTA := dta (insert_ostate d a o) a.

Lemma insert_ostate_0 :
 forall (d : preDTA) (a : ad) (s : state) (a0 : ad) (t : term),
 preDTA_ref_ok d ->
 MapGet state d a = None ->
 a <> a0 ->
 (reconnaissance d a0 t <->
  reconnaissance (insert_ostate d a (Some s)) a0 t).

Lemma insert_ostate_1 :
 forall (d0 d1 : preDTA) (a0 a1 a : ad) (s s0 s1 s0' s1' : state) (t : term),
 MapGet state d0 a0 = Some s0 ->
 MapGet state d1 a1 = Some s1 ->
 MapGet state (u_merge d0 d1) (uad_conv_0 a0) = Some s0' ->
 MapGet state (u_merge d0 d1) (uad_conv_1 a1) = Some s1' ->
 preDTA_ref_ok (u_merge d0 d1) ->
 MapGet state (u_merge d0 d1) a = None ->
 a <> uad_conv_0 a0 ->
 (reconnaissance d0 a0 t <->
  reconnaissance (insert_ostate (u_merge d0 d1) a (Some s))
    (uad_conv_0 a0) t).

Lemma insert_ostate_2 :
 forall (d0 d1 : preDTA) (a0 a1 a : ad) (s s0 s1 s0' s1' : state) (t : term),
 MapGet state d0 a0 = Some s0 ->
 MapGet state d1 a1 = Some s1 ->
 MapGet state (u_merge d0 d1) (uad_conv_0 a0) = Some s0' ->
 MapGet state (u_merge d0 d1) (uad_conv_1 a1) = Some s1' ->
 preDTA_ref_ok (u_merge d0 d1) ->
 MapGet state (u_merge d0 d1) a = None ->
 a <> uad_conv_1 a1 ->
 (reconnaissance d1 a1 t <->
  reconnaissance (insert_ostate (u_merge d0 d1) a (Some s))
    (uad_conv_1 a1) t).

Lemma insert_ostate_3 :
 forall (d0 d1 : preDTA) (a0 a1 a : ad) (s s0 s1 s0' s1' : state) (t : term),
 MapGet state d0 a0 = Some s0 ->
 MapGet state d1 a1 = Some s1 ->
 MapGet state (u_merge d0 d1) (uad_conv_0 a0) = Some s0' ->
 MapGet state (u_merge d0 d1) (uad_conv_1 a1) = Some s1' ->
 preDTA_ref_ok (u_merge d0 d1) ->
 MapGet state (u_merge d0 d1) a = None ->
 a <> uad_conv_0 a0 ->
 (reconnaissance (insert_ostate (u_merge d0 d1) a (Some s))
    (uad_conv_0 a0) t <->
  state_reconnait (insert_ostate (u_merge d0 d1) a (Some s)) s0' t).

Lemma insert_ostate_4 :
 forall (d0 d1 : preDTA) (a0 a1 a : ad) (s s0 s1 s0' s1' : state) (t : term),
 MapGet state d0 a0 = Some s0 ->
 MapGet state d1 a1 = Some s1 ->
 MapGet state (u_merge d0 d1) (uad_conv_0 a0) = Some s0' ->
 MapGet state (u_merge d0 d1) (uad_conv_1 a1) = Some s1' ->
 preDTA_ref_ok (u_merge d0 d1) ->
 MapGet state (u_merge d0 d1) a = None ->
 a <> uad_conv_1 a1 ->
 (reconnaissance (insert_ostate (u_merge d0 d1) a (Some s))
    (uad_conv_1 a1) t <->
  state_reconnait (insert_ostate (u_merge d0 d1) a (Some s)) s1' t).

Lemma insert_ostate_5 :
 forall (d0 d1 : preDTA) (a0 a1 a : ad) (s0 s1 s0' s1' : state) (t : term),
 mpl_compat s0' s1' ->
 MapGet state d0 a0 = Some s0 ->
 MapGet state d1 a1 = Some s1 ->
 MapGet state (u_merge d0 d1) (uad_conv_0 a0) = Some s0' ->
 MapGet state (u_merge d0 d1) (uad_conv_1 a1) = Some s1' ->
 preDTA_ref_ok (u_merge d0 d1) ->
 MapGet state (u_merge d0 d1) a = None ->
 a <> uad_conv_0 a0 ->
 a <> uad_conv_1 a1 ->
 (state_reconnait
    (insert_ostate (u_merge d0 d1) a (Some (union_mpl s0' s1')))
    (union_mpl s0' s1') t <->
  state_reconnait
    (insert_ostate (u_merge d0 d1) a (Some (union_mpl s0' s1'))) s0' t \/
  state_reconnait
    (insert_ostate (u_merge d0 d1) a (Some (union_mpl s0' s1'))) s1' t).

Lemma insert_ostate_6 :
 forall (d0 d1 : preDTA) (a0 a1 a : ad) (s0 s1 s0' s1' : state) (t : term),
 mpl_compat s0' s1' ->
 MapGet state d0 a0 = Some s0 ->
 MapGet state d1 a1 = Some s1 ->
 MapGet state (u_merge d0 d1) (uad_conv_0 a0) = Some s0' ->
 MapGet state (u_merge d0 d1) (uad_conv_1 a1) = Some s1' ->
 preDTA_ref_ok (u_merge d0 d1) ->
 MapGet state (u_merge d0 d1) a = None ->
 a <> uad_conv_0 a0 ->
 a <> uad_conv_1 a1 ->
 (state_reconnait
    (insert_ostate (u_merge d0 d1) a (Some (union_mpl s0' s1')))
    (union_mpl s0' s1') t <->
  reconnaissance
    (insert_ostate (u_merge d0 d1) a (Some (union_mpl s0' s1'))) a t).

Lemma insert_ostate_7 :
 forall (d0 d1 : preDTA) (a0 a1 a : ad) (s0 s1 s0' s1' : state) (t : term),
 mpl_compat s0' s1' ->
 MapGet state d0 a0 = Some s0 ->
 MapGet state d1 a1 = Some s1 ->
 MapGet state (u_merge d0 d1) (uad_conv_0 a0) = Some s0' ->
 MapGet state (u_merge d0 d1) (uad_conv_1 a1) = Some s1' ->
 preDTA_ref_ok (u_merge d0 d1) ->
 MapGet state (u_merge d0 d1) a = None ->
 a <> uad_conv_0 a0 ->
 a <> uad_conv_1 a1 ->
 (reconnaissance d0 a0 t \/ reconnaissance d1 a1 t <->
  reconnaissance
    (insert_ostate (u_merge d0 d1) a (Some (union_mpl s0' s1'))) a t).

Lemma insert_ostate_8 :
 forall (d0 d1 : preDTA) (a0 a1 a : ad) (s0 s1 s0' s1' : state) (t : term),
 mpl_compat s0' s1' ->
 MapGet state d0 a0 = Some s0 ->
 MapGet state d1 a1 = Some s1 ->
 MapGet state (u_merge d0 d1) (uad_conv_0 a0) = Some s0' ->
 MapGet state (u_merge d0 d1) (uad_conv_1 a1) = Some s1' ->
 preDTA_ref_ok (u_merge d0 d1) ->
 a = new_preDTA_ad (u_merge d0 d1) ->
 (reconnaissance d0 a0 t \/ reconnaissance d1 a1 t <->
  reconnaissance
    (insert_ostate (u_merge d0 d1) a (Some (union_mpl s0' s1'))) a t).

Lemma upl_conv_0_occur :
 forall (pl : prec_list) (a : ad),
 prec_occur (upl_conv_0 pl) (uad_conv_0 a) -> prec_occur pl a.

Lemma upl_conv_1_occur :
 forall (pl : prec_list) (a : ad),
 prec_occur (upl_conv_1 pl) (uad_conv_1 a) -> prec_occur pl a.

Lemma upl_conv_0_occur_in_img :
 forall (pl : prec_list) (a : ad),
 prec_occur (upl_conv_0 pl) a -> exists b : ad, a = uad_conv_0 b.

Lemma upl_conv_1_occur_in_img :
 forall (pl : prec_list) (a : ad),
 prec_occur (upl_conv_1 pl) a -> exists b : ad, a = uad_conv_1 b.

Lemma u_conv_0_ref_ok :
 forall d : preDTA, preDTA_ref_ok d -> preDTA_ref_ok (udta_conv_0 d).

Lemma u_conv_1_ref_ok :
 forall d : preDTA, preDTA_ref_ok d -> preDTA_ref_ok (udta_conv_1 d).

Lemma u_merge_ref_ok :
 forall d0 d1 : preDTA,
 preDTA_ref_ok d0 -> preDTA_ref_ok d1 -> preDTA_ref_ok (u_merge d0 d1).

Lemma upl_conv_compat_0_0 :
 forall p0 p1 : prec_list,
 pl_compat p0 p1 -> pl_compat (upl_conv_0 p0) (upl_conv_0 p1).

Lemma upl_conv_compat_0_1 :
 forall p0 p1 : prec_list,
 pl_compat p0 p1 -> pl_compat (upl_conv_0 p0) (upl_conv_1 p1).

Lemma upl_conv_compat_1_0 :
 forall p0 p1 : prec_list,
 pl_compat p0 p1 -> pl_compat (upl_conv_1 p0) (upl_conv_0 p1).

Lemma upl_conv_compat_1_1 :
 forall p0 p1 : prec_list,
 pl_compat p0 p1 -> pl_compat (upl_conv_1 p0) (upl_conv_1 p1).

Lemma umpl_conv_0_compat :
 forall s0 s1 : state,
 mpl_compat s0 s1 -> mpl_compat (umpl_conv_0 s0) (umpl_conv_0 s1).

Lemma umpl_conv_1_compat :
 forall s0 s1 : state,
 mpl_compat s0 s1 -> mpl_compat (umpl_conv_1 s0) (umpl_conv_1 s1).

Lemma umpl_conv_0_1_compat :
 forall s0 s1 : state,
 mpl_compat s0 s1 -> mpl_compat (umpl_conv_0 s0) (umpl_conv_1 s1).

Lemma udta_conv_0_compat :
 forall d : preDTA, dta_correct d -> dta_correct (udta_conv_0 d).

Lemma udta_conv_1_compat :
 forall d : preDTA, dta_correct d -> dta_correct (udta_conv_1 d).

Lemma udta_conv_0_1_compat :
 forall d0 d1 : preDTA,
 dta_compat d0 d1 -> dta_compat (udta_conv_0 d0) (udta_conv_1 d1).

Lemma insert_ostate_9 :
 forall (d0 d1 : preDTA) (a0 a1 a : ad) (s0' s1' : state) (t : term),
 preDTA_ref_ok d0 ->
 preDTA_ref_ok d1 ->
 dta_compat d0 d1 ->
 MapGet state (u_merge d0 d1) (uad_conv_0 a0) = Some s0' ->
 MapGet state (u_merge d0 d1) (uad_conv_1 a1) = Some s1' ->
 a = new_preDTA_ad (u_merge d0 d1) ->
 (reconnaissance d0 a0 t \/ reconnaissance d1 a1 t <->
  reconnaissance
    (insert_ostate (u_merge d0 d1) a (Some (union_mpl s0' s1'))) a t).

Definition insert_main_ostate (d : preDTA) (o : option state) : DTA :=
  insert_main_ostate_0 d (new_preDTA_ad d) o.

Definition union_opt_state (o0 o1 : option state) : 
  option state :=
  match o0, o1 with
  | None, None => None
  | None, Some s1 => Some s1
  | Some s0, None => Some s0
  | Some s0, Some s1 => Some (union_mpl s0 s1)
  end.

Definition union_0 (d : preDTA) (a0 a1 : ad) : option state :=
  union_opt_state (MapGet state d (uad_conv_0 a0))
    (MapGet state d (uad_conv_1 a1)).

Definition union_1 (d : preDTA) (a0 a1 : ad) : DTA :=
  insert_main_ostate d (union_0 d a0 a1).

Definition union (dt0 dt1 : DTA) : DTA :=
  match dt0, dt1 with
  | dta d0 a0, dta d1 a1 => union_1 (u_merge d0 d1) a0 a1
  end.

Lemma union_semantics_0 :
 forall (d0 d1 : DTA) (t : term),
 DTA_main_state_correct d0 ->
 DTA_main_state_correct d1 ->
 DTA_ref_ok d0 ->
 DTA_ref_ok d1 ->
 DTA_compat d0 d1 ->
 (reconnait d0 t \/ reconnait d1 t <-> reconnait (union d0 d1) t).

Lemma union_semantics :
 forall (d0 d1 : DTA) (sigma : signature) (t : term),
 DTA_main_state_correct d0 ->
 DTA_main_state_correct d1 ->
 DTA_ref_ok d0 ->
 DTA_ref_ok d1 ->
 dta_correct_wrt_sign d0 sigma ->
 dta_correct_wrt_sign d1 sigma ->
 (reconnait d0 t \/ reconnait d1 t <-> reconnait (union d0 d1) t). *)

Lemma upl_conv_0_correct_wrt_sign_invar :
 forall (p : prec_list) (n : nat),
 pl_tl_length p n -> pl_tl_length (upl_conv_0 p) n.
Proof.
	simple induction p; intros. simpl in |- *. inversion H1. simpl in |- *. exact (pl_tl_S (uad_conv_0 a) (upl_conv_0 p0) n0 (H _ H6)).
	exact
  (pl_tl_propag (uad_conv_0 a) (upl_conv_0 p0) (upl_conv_0 p1) n0 
     (H _ H6) (H0 _ H7)). simpl in |- *. inversion H. exact pl_tl_O.
Qed.

Lemma upl_conv_1_correct_wrt_sign_invar :
 forall (p : prec_list) (n : nat),
 pl_tl_length p n -> pl_tl_length (upl_conv_1 p) n.
Proof.
	simple induction p; intros. simpl in |- *. inversion H1. simpl in |- *. exact (pl_tl_S (uad_conv_1 a) (upl_conv_1 p0) n0 (H _ H6)).
	exact
  (pl_tl_propag (uad_conv_1 a) (upl_conv_1 p0) (upl_conv_1 p1) n0 
     (H _ H6) (H0 _ H7)). simpl in |- *. inversion H. exact pl_tl_O.
Qed.

Lemma umpl_conv_0_correct_wrt_sign_invar_0 :
 forall (s : state) (sigma : signature) (pa : pre_ad),
 state_correct_wrt_sign_with_offset s sigma pa ->
 state_correct_wrt_sign_with_offset (umpl_conv_0 s) sigma pa.
Proof.
	simple induction s. intros. simpl in |- *. exact H. intros. simpl in |- *.
	unfold state_correct_wrt_sign_with_offset in H.
	unfold state_correct_wrt_sign_with_offset in |- *. intros.
	simpl in H0. elim (H a a0). intros. split with x. elim (bool_is_true_or_false (Neqb a a1)); intros; rewrite H2 in H0. inversion H0. elim H1. intros. rewrite (Neqb_complete _ _ H2) in H3. split. exact H3. exact (upl_conv_0_correct_wrt_sign_invar _ _ H5). inversion H0. simpl in |- *. rewrite (Neqb_correct a). 
	reflexivity. intros. unfold state_correct_wrt_sign_with_offset in H1.
	unfold state_correct_wrt_sign_with_offset in |- *. intros. unfold state_correct_wrt_sign_with_offset in H. unfold state_correct_wrt_sign_with_offset in H0. induction  a as [| p0]. simpl in H2.
	elim (H sigma (pre_ad_O pa)) with (a := N0) (p := p). intros.
	split with x. simpl in H3. exact H3. intros. elim (H1 (Ndouble a) p0). intros. split with x. simpl in |- *. exact H4. induction  a as [| p1]; simpl in |- *; exact H3. exact H2. induction  p0 as [p0 Hrecp0| p0 Hrecp0| ]. elim (H0 sigma (pre_ad_I pa)) with (a := Npos p0) (p := p). intros. split with x. simpl in H3. exact H3.
	intros. elim (H1 (Ndouble_plus_one a) p1). intros. split with x.
	induction  a as [| p2]. simpl in H4. simpl in |- *. exact H4. simpl in H4. simpl in |- *.
	exact H4. induction  a as [| p2]; simpl in |- *; exact H3. simpl in H2. exact H2.
	elim (H sigma (pre_ad_O pa)) with (a := Npos p0) (p := p). intros.
	split with x. simpl in H3. exact H3. intros. elim (H1 (Ndouble a) p1). intros. split with x. induction  a as [| p2]; simpl in H4; simpl in |- *; exact H4. induction  a as [| p2]; simpl in |- *; exact H3. simpl in H2. exact H2.
	elim (H0 sigma (pre_ad_I pa)) with (a := N0) (p := p). intros. split with x. simpl in H3. exact H3. intros. elim (H1 (Ndouble_plus_one a) p0). intros. split with x. induction  a as [| p1]; simpl in |- *; simpl in H4; exact H4. induction  a as [| p1]; simpl in |- *; exact H3. simpl in H2. exact H2.
Qed.

Lemma umpl_conv_0_correct_wrt_sign_invar :
 forall (s : state) (sigma : signature),
 state_correct_wrt_sign s sigma ->
 state_correct_wrt_sign (umpl_conv_0 s) sigma.
Proof.
	unfold state_correct_wrt_sign in |- *. intros. elim
  (umpl_conv_0_correct_wrt_sign_invar_0 s sigma pre_ad_empty)
   with (a := a) (p := p). intros. split with x. simpl in H1. exact H1.
	unfold state_correct_wrt_sign_with_offset in |- *. simpl in |- *. exact H.
	exact H0.
Qed.

Lemma umpl_conv_1_correct_wrt_sign_invar_0 :
 forall (s : state) (sigma : signature) (pa : pre_ad),
 state_correct_wrt_sign_with_offset s sigma pa ->
 state_correct_wrt_sign_with_offset (umpl_conv_1 s) sigma pa.
Proof.
	simple induction s. intros. simpl in |- *. exact H. intros. simpl in |- *.
	unfold state_correct_wrt_sign_with_offset in H.
	unfold state_correct_wrt_sign_with_offset in |- *. intros.
	simpl in H0. elim (H a a0). intros. split with x. elim (bool_is_true_or_false (Neqb a a1)); intros; rewrite H2 in H0. inversion H0. elim H1. intros. rewrite (Neqb_complete _ _ H2) in H3. split. exact H3. exact (upl_conv_1_correct_wrt_sign_invar _ _ H5). inversion H0. simpl in |- *. rewrite (Neqb_correct a). 
	reflexivity. intros. unfold state_correct_wrt_sign_with_offset in H1.
	unfold state_correct_wrt_sign_with_offset in |- *. intros. unfold state_correct_wrt_sign_with_offset in H. unfold state_correct_wrt_sign_with_offset in H0. induction  a as [| p0]. simpl in H2.
	elim (H sigma (pre_ad_O pa)) with (a := N0) (p := p). intros.
	split with x. simpl in H3. exact H3. intros. elim (H1 (Ndouble a) p0). intros. split with x. simpl in |- *. exact H4. induction  a as [| p1]; simpl in |- *; exact H3. exact H2. induction  p0 as [p0 Hrecp0| p0 Hrecp0| ]. elim (H0 sigma (pre_ad_I pa)) with (a := Npos p0) (p := p). intros. split with x. simpl in H3. exact H3.
	intros. elim (H1 (Ndouble_plus_one a) p1). intros. split with x.
	induction  a as [| p2]. simpl in H4. simpl in |- *. exact H4. simpl in H4. simpl in |- *.
	exact H4. induction  a as [| p2]; simpl in |- *; exact H3. simpl in H2. exact H2.
	elim (H sigma (pre_ad_O pa)) with (a := Npos p0) (p := p). intros.
	split with x. simpl in H3. exact H3. intros. elim (H1 (Ndouble a) p1). intros. split with x. induction  a as [| p2]; simpl in H4; simpl in |- *; exact H4. induction  a as [| p2]; simpl in |- *; exact H3. simpl in H2. exact H2.
	elim (H0 sigma (pre_ad_I pa)) with (a := N0) (p := p). intros. split with x. simpl in H3. exact H3. intros. elim (H1 (Ndouble_plus_one a) p0). intros. split with x. induction  a as [| p1]; simpl in |- *; simpl in H4; exact H4. induction  a as [| p1]; simpl in |- *; exact H3. simpl in H2. exact H2.
Qed.

Lemma umpl_conv_1_correct_wrt_sign_invar :
 forall (s : state) (sigma : signature),
 state_correct_wrt_sign s sigma ->
 state_correct_wrt_sign (umpl_conv_1 s) sigma.
Proof.
	unfold state_correct_wrt_sign in |- *. intros. elim
  (umpl_conv_1_correct_wrt_sign_invar_0 s sigma pre_ad_empty)
   with (a := a) (p := p). intros. split with x. simpl in H1. exact H1.
	unfold state_correct_wrt_sign_with_offset in |- *. simpl in |- *. exact H.
	exact H0.
Qed.

Lemma udta_conv_0_correct_wrt_sign_invar_0 :
 forall (d : preDTA) (sigma : signature),
 predta_correct_wrt_sign d sigma ->
 predta_correct_wrt_sign (udta_conv_0_aux d) sigma.
Proof.
	unfold predta_correct_wrt_sign in |- *. simple induction d. intros. inversion H0.
	intros. simpl in H0. elim (bool_is_true_or_false (Neqb a a1)); intros. rewrite H1 in H0. inversion H0. apply (umpl_conv_0_correct_wrt_sign_invar a0 sigma). apply (H a a0).
	simpl in |- *. rewrite (Neqb_correct a). reflexivity. rewrite H1 in H0.
	inversion H0. intros. simpl in H2. induction  a as [| p]. apply (H sigma) with (a := N0) (s := s). intros. apply (H1 (Ndouble a) s0). 
	induction  a as [| p]; simpl in |- *; exact H3. exact H2. induction  p as [p Hrecp| p Hrecp| ]; simpl in H2.
	apply (H0 sigma) with (a := Npos p) (s := s). intros. apply (H1 (Ndouble_plus_one a) s0). induction  a as [| p0]; simpl in |- *; exact H3. exact H2.
	apply (H sigma) with (a := Npos p) (s := s). intros. apply (H1 (Ndouble a) s0). induction  a as [| p0]; simpl in |- *; exact H3. exact H2. apply (H0 sigma) with (a := N0) (s := s). intros. apply (H1 (Ndouble_plus_one a) s0).
	induction  a as [| p]; simpl in |- *; exact H3. exact H2.
Qed.

Lemma udta_conv_0_correct_wrt_sign_invar :
 forall (d : preDTA) (sigma : signature),
 predta_correct_wrt_sign d sigma ->
 predta_correct_wrt_sign (udta_conv_0 d) sigma.
Proof.
	unfold udta_conv_0 in |- *. intros. unfold predta_correct_wrt_sign in |- *. intros.
	induction  a as [| p]. simpl in H0. exact (udta_conv_0_correct_wrt_sign_invar_0 d sigma H N0 s H0). induction  p as [p Hrecp| p Hrecp| ]; simpl in H0. inversion H0.
	exact (udta_conv_0_correct_wrt_sign_invar_0 d sigma H (Npos p) s H0).
	inversion H0.
Qed.

Lemma udta_conv_1_correct_wrt_sign_invar_0 :
 forall (d : preDTA) (sigma : signature),
 predta_correct_wrt_sign d sigma ->
 predta_correct_wrt_sign (udta_conv_1_aux d) sigma.
Proof.
	unfold predta_correct_wrt_sign in |- *. simple induction d. intros. inversion H0.
	intros. simpl in H0. elim (bool_is_true_or_false (Neqb a a1)); intros. rewrite H1 in H0. inversion H0. apply (umpl_conv_1_correct_wrt_sign_invar a0 sigma). apply (H a a0).
	simpl in |- *. rewrite (Neqb_correct a). reflexivity. rewrite H1 in H0.
	inversion H0. intros. simpl in H2. induction  a as [| p]. apply (H sigma) with (a := N0) (s := s). intros. apply (H1 (Ndouble a) s0). 
	induction  a as [| p]; simpl in |- *; exact H3. exact H2. induction  p as [p Hrecp| p Hrecp| ]; simpl in H2.
	apply (H0 sigma) with (a := Npos p) (s := s). intros. apply (H1 (Ndouble_plus_one a) s0). induction  a as [| p0]; simpl in |- *; exact H3. exact H2.
	apply (H sigma) with (a := Npos p) (s := s). intros. apply (H1 (Ndouble a) s0). induction  a as [| p0]; simpl in |- *; exact H3. exact H2. apply (H0 sigma) with (a := N0) (s := s). intros. apply (H1 (Ndouble_plus_one a) s0).
	induction  a as [| p]; simpl in |- *; exact H3. exact H2.
Qed.

Lemma udta_conv_1_correct_wrt_sign_invar :
 forall (d : preDTA) (sigma : signature),
 predta_correct_wrt_sign d sigma ->
 predta_correct_wrt_sign (udta_conv_1 d) sigma.
Proof.
	unfold udta_conv_1 in |- *. intros. unfold predta_correct_wrt_sign in |- *. intros.
	induction  a as [| p]. simpl in H0. inversion H0. induction  p as [p Hrecp| p Hrecp| ]; simpl in H0.
	exact (udta_conv_1_correct_wrt_sign_invar_0 d sigma H (Npos p) s H0).
	inversion H0. exact (udta_conv_1_correct_wrt_sign_invar_0 d sigma H N0 s H0).
Qed.

Lemma umerge_correct_wrt_sign_invar :
 forall (d0 d1 : preDTA) (sigma : signature),
 predta_correct_wrt_sign d0 sigma ->
 predta_correct_wrt_sign d1 sigma ->
 predta_correct_wrt_sign (u_merge d0 d1) sigma.
Proof.
	unfold predta_correct_wrt_sign in |- *. intros. elim (adcnv_disj a).
	intros. elim H2; intros. elim (u_conv_0_invar_5 d0 x s). intros.
	elim H4. intros. apply (udta_conv_0_correct_wrt_sign_invar d0 sigma H a s). exact (u_merge_0r d0 d1 a s H1 x H3). rewrite <- H3.
	exact (u_merge_0r d0 d1 a s H1 x H3). elim (u_conv_1_invar_5 d1 x s).
	intros. elim H4. intros. apply (udta_conv_1_correct_wrt_sign_invar d1 sigma H0 a s). exact (u_merge_1r d0 d1 a s H1 x H3). rewrite <- H3. exact (u_merge_1r d0 d1 a s H1 x H3).
Qed.

Lemma union_pl_correct_wrt_sign_invar :
 forall (p0 p1 : prec_list) (n : nat),
 pl_tl_length p0 n -> pl_tl_length p1 n -> pl_tl_length (union_pl p0 p1) n.
Proof.
	simple induction p0. intros. simpl in |- *. inversion H1. simpl in |- *. rewrite <- H4 in H2. exact (pl_tl_propag a p p2 n0 H7 H2). rewrite <- H5 in H2. exact (pl_tl_propag a p (union_pl p1 p2) n0 H7 (H0 p2 (S n0) H8 H2)). intros. inversion H. rewrite <- H2 in H0. inversion H0. simpl in |- *. exact pl_tl_O.
Qed.

Lemma union_mpl_correct_wrt_sign_invar_0 :
 forall (s : state) (a : ad) (p : prec_list) (pa : pre_ad)
   (sigma : signature),
 state_correct_wrt_sign_with_offset s sigma pa ->
 state_correct_wrt_sign_with_offset (M1 prec_list a p) sigma pa ->
 state_correct_wrt_sign_with_offset (union_mpl_0 a p s) sigma pa.
Proof.
	simple induction s. unfold state_correct_wrt_sign_with_offset in |- *. intros.
	exact (H0 _ _ H1). unfold state_correct_wrt_sign_with_offset in |- *.
	intros. simpl in H1. elim (bool_is_true_or_false (Neqb a1 a)); intros; rewrite H2 in H1. elim (H a a0). intros. elim (H0 a p).
	intros. elim H3. elim H4. intros. simpl in H1. elim (bool_is_true_or_false (Neqb a1 a2)); intros; rewrite H9 in H1;
  inversion H1. rewrite H7 in H5. inversion H5. split with x.
	rewrite <- H12 in H6. split. rewrite <- (Neqb_complete _ _ H9). rewrite (Neqb_complete _ _ H2). exact H7. exact (union_pl_correct_wrt_sign_invar p a0 x H6 H8). simpl in |- *. rewrite H2. reflexivity. simpl in |- *. rewrite (Neqb_correct a). reflexivity. elim (Ndiscr (Nxor a a1)).
	intro y. elim y. intros x y0. rewrite y0 in H1. rewrite (MapPut1_semantics prec_list x a a1 a0 p y0) in H1. elim (bool_is_true_or_false (Neqb a a2)); intros; rewrite H3 in H1. inversion H1. elim (H a a0). intros.
	elim H4. intros. split with x0. rewrite <- (Neqb_complete _ _ H3).
	rewrite <- H5. exact H4. simpl in |- *. rewrite (Neqb_correct a).
	reflexivity. elim (bool_is_true_or_false (Neqb a1 a2)); intros.
	rewrite H4 in H1. inversion H1. elim (H0 a1 p). intros. split with x0. rewrite (Neqb_complete _ _ H4) in H5. rewrite H6 in H5.
	exact H5. simpl in |- *. rewrite (Neqb_correct a1). reflexivity.
	rewrite H4 in H1. inversion H1. intros y. rewrite (Neqb_comm a1 a) in H2. rewrite (Nxor_eq_true _ _ y) in H2. inversion H2.
	intros. unfold state_correct_wrt_sign_with_offset in |- *. intros.
	cut (state_correct_wrt_sign_with_offset m sigma (pre_ad_O pa)).
	cut (state_correct_wrt_sign_with_offset m0 sigma (pre_ad_I pa)).
	intros. induction  a as [| p1]. simpl in H3. cut
  (state_correct_wrt_sign_with_offset (M1 prec_list N0 p) sigma
     (pre_ad_O pa)). intros. induction  a0 as [| p1].
	elim (H _ _ _ _ H5 H6 N0 p0). intros. split with x. simpl in H7.
	exact H7. exact H3. induction  p1 as [p1 Hrecp1| p1 Hrecp1| ]. elim (H4 (Npos p1) p0). intros.
	split with x. simpl in H7. exact H7. exact H3. elim (H _ _ _ _ H5 H6 (Npos p1) p0). intros. split with x. simpl in H7. exact H7.
	exact H3. elim (H4 N0 p0). intros. split with x. simpl in H7.
	exact H7. exact H3. unfold state_correct_wrt_sign_with_offset in |- *.
	intros. elim (H2 (Ndouble a) p1). intros. split with x.
	induction  a as [| p2]; simpl in |- *; simpl in H7; exact H7. simpl in H6. 
	elim (Ndiscr a). intros y. elim y. intros x y0. rewrite y0 in H6.
	inversion H6. intros y. rewrite y in H6. rewrite y. simpl in |- *.
	exact H6. induction  p1 as [p1 Hrecp1| p1 Hrecp1| ]. cut
  (state_correct_wrt_sign_with_offset (M1 prec_list (Npos p1) p) sigma
     (pre_ad_I pa)). intro. induction  a0 as [| p2]. simpl in H3. elim (H5 N0 p0). intros. split with x. simpl in H7. exact H7. exact H3. induction  p2 as [p2 Hrecp2| p2 Hrecp2| ]; simpl in H3. elim (H0 _ _ _ _ H4 H6 (Npos p2) p0). intros. split with x. simpl in H7.
	exact H7. exact H3. elim (H5 (Npos p2) p0). intros. split with x.
	simpl in H7. exact H7. exact H3. elim (H0 _ _ _ _ H4 H6 N0 p0).
	intros. split with x. simpl in H7. exact H7. exact H3. 
	unfold state_correct_wrt_sign_with_offset in |- *. intros. elim (H2 (Ndouble_plus_one a) p2). intros. split with x. induction  a as [| p3]; simpl in |- *; simpl in H7; exact H7. induction  a as [| p3]; simpl in |- *; exact H6. cut
  (state_correct_wrt_sign_with_offset (M1 prec_list (Npos p1) p) sigma
     (pre_ad_O pa)). intros. induction  a0 as [| p2]. simpl in H3.
	elim (H _ _ _ _ H5 H6 N0 p0). intros. split with x. simpl in H7.
	exact H7. exact H3. induction  p2 as [p2 Hrecp2| p2 Hrecp2| ]; simpl in H3. elim (H4 (Npos p2) p0).
	intros. split with x. simpl in H7. exact H7. exact H3. elim (H _ _ _ _ H5 H6 (Npos p2) p0). intros. split with x. simpl in H7.
	exact H7. exact H3. elim (H4 N0 p0). intros. split with x. simpl in H7. exact H7. exact H3. unfold state_correct_wrt_sign_with_offset in |- *.
	intros. elim (H2 (Ndouble a) p2). intros. split with x. 
	induction  a as [| p3]; simpl in |- *; simpl in H7; exact H7. induction  a as [| p3]; simpl in |- *; exact H6. cut
  (state_correct_wrt_sign_with_offset (M1 prec_list N0 p) sigma
     (pre_ad_I pa)). intro. induction  a0 as [| p1]. simpl in H3.
	elim (H5 N0 p0). intros. split with x. simpl in H7. exact H7.
	exact H3. induction  p1 as [p1 Hrecp1| p1 Hrecp1| ]; simpl in H3. elim (H0 _ _ _ _ H4 H6 (Npos p1) p0). intros. split with x. simpl in H7. exact H7.
	exact H3. elim (H5 (Npos p1) p0). intros. split with x. simpl in H7. exact H7. exact H3. elim (H0 _ _ _ _ H4 H6 N0 p0).
	intros. split with x. simpl in H7. exact H7. exact H3. unfold state_correct_wrt_sign_with_offset in |- *. intros. elim (H2 (Ndouble_plus_one a) p1). intros. split with x. induction  a as [| p2]; simpl in |- *; simpl in H7; exact H7. induction  a as [| p2]; simpl in |- *. simpl in H6. exact H6. simpl in H6. inversion H6. unfold state_correct_wrt_sign_with_offset in |- *.
	intros. elim (H1 (Ndouble_plus_one a1) p1). intros. split with x.
	induction  a1 as [| p2]; simpl in H5; simpl in |- *; exact H5. induction  a1 as [| p2]; simpl in |- *; exact H4. unfold state_correct_wrt_sign_with_offset in |- *. intros.
	elim (H1 (Ndouble a1) p1). intros. split with x. induction  a1 as [| p2]; simpl in |- *; simpl in H5; exact H5. induction  a1 as [| p2]; simpl in |- *; exact H4.
Qed.

Lemma union_mpl_correct_wrt_sign_invar_1 :
 forall (s0 s1 : state) (pa : pre_ad) (sigma : signature),
 state_correct_wrt_sign_with_offset s0 sigma pa ->
 state_correct_wrt_sign_with_offset s1 sigma pa ->
 state_correct_wrt_sign_with_offset (union_mpl s0 s1) sigma pa.
Proof.
	simple induction s0. simpl in |- *. simple induction s1; intros. exact H0. exact H0. exact H2.
	simpl in |- *. simple induction s1. intros. exact (union_mpl_correct_wrt_sign_invar_0 (M0 prec_list) a a0 pa sigma H0 H). intros. elim (bool_is_true_or_false (Neqb a1 a)); intros; rewrite H1. unfold state_correct_wrt_sign_with_offset in |- *.
	intros. simpl in H2. elim (bool_is_true_or_false (Neqb a1 a3)); intros; rewrite H3 in H2. inversion H2. elim (H a a0). intros. elim (H0 a1 a2).
	intros. split with x. rewrite (Neqb_complete _ _ H1) in H6. split.
	elim H4. intros. rewrite <- (Neqb_complete _ _ H3). rewrite (Neqb_complete _ _ H1). exact H7. elim H4. elim H6. intros.
	rewrite H9 in H7. inversion H7. rewrite H12 in H10. exact (union_pl_correct_wrt_sign_invar _ _ _ H8 H10). simpl in |- *. rewrite (Neqb_correct a1). reflexivity. simpl in |- *. rewrite (Neqb_correct a).
	reflexivity. inversion H2. elim (Ndiscr (Nxor a a1)); intro y. elim y.
	intros x y0. rewrite y0. unfold state_correct_wrt_sign_with_offset in |- *. intros.
	rewrite (MapPut1_semantics prec_list x a a1 a0 a2) in H2. elim (bool_is_true_or_false (Neqb a a3)); intros. rewrite H3 in H2.
	inversion H2. elim (H a a0). intros. split with x0. rewrite (Neqb_complete _ _ H3) in H4. rewrite H5 in H4. exact H4. simpl in |- *.
	rewrite (Neqb_correct a). reflexivity. rewrite H3 in H2. elim (bool_is_true_or_false (Neqb a1 a3)); intros. rewrite H4 in H2.
	inversion H2. elim (H0 a1 a2). intros. split with x0. rewrite (Neqb_complete _ _ H4) in H5. rewrite H6 in H5. exact H5. simpl in |- *.
	rewrite (Neqb_correct a1). reflexivity. rewrite H4 in H2. inversion H2. exact y0. rewrite (Neqb_comm a1 a) in H1. rewrite (Nxor_eq_true _ _ y) in H1. inversion H1. intros. simpl in |- *. induction  a as [| p]. exact (union_mpl_correct_wrt_sign_invar_0 _ _ _ _ _ H2 H1). induction  p as [p Hrecp| p Hrecp| ].
	clear Hrecp. replace
  (state_correct_wrt_sign_with_offset
     (M2 prec_list m (union_mpl_0 (Npos p) a0 m0)) sigma pa) with
  (state_correct_wrt_sign_with_offset
     (union_mpl_0 (Npos (xI p)) a0 (M2 prec_list m m0)) sigma pa). exact
  (union_mpl_correct_wrt_sign_invar_0 (M2 prec_list m m0) 
     (Npos (xI p)) a0 pa sigma H2 H1). reflexivity.
	clear Hrecp. replace
  (state_correct_wrt_sign_with_offset
     (M2 prec_list (union_mpl_0 (Npos p) a0 m) m0) sigma pa) with
  (state_correct_wrt_sign_with_offset
     (union_mpl_0 (Npos (xO p)) a0 (M2 prec_list m m0)) sigma pa). exact
  (union_mpl_correct_wrt_sign_invar_0 (M2 prec_list m m0) 
     (Npos (xO p)) a0 pa sigma H2 H1). reflexivity.
	replace
  (state_correct_wrt_sign_with_offset
     (M2 prec_list m (union_mpl_0 N0 a0 m0)) sigma pa) with
  (state_correct_wrt_sign_with_offset
     (union_mpl_0 (Npos 1) a0 (M2 prec_list m m0)) sigma pa). exact
  (union_mpl_correct_wrt_sign_invar_0 (M2 prec_list m m0) 
     (Npos 1) a0 pa sigma H2 H1). reflexivity. simple induction s1. intros. simpl in |- *. exact H1.
	intros. simpl in |- *. induction  a as [| p]. replace
  (state_correct_wrt_sign_with_offset
     (M2 prec_list (union_mpl_0 N0 a0 m) m0) sigma pa) with
  (state_correct_wrt_sign_with_offset
     (union_mpl_0 N0 a0 (M2 prec_list m m0)) sigma pa). exact
  (union_mpl_correct_wrt_sign_invar_0 (M2 prec_list m m0) N0 a0 pa sigma H1
     H2). reflexivity. induction  p as [p Hrecp| p Hrecp| ].
	replace
  (state_correct_wrt_sign_with_offset
     (M2 prec_list m (union_mpl_0 (Npos p) a0 m0)) sigma pa) with
  (state_correct_wrt_sign_with_offset
     (union_mpl_0 (Npos (xI p)) a0 (M2 prec_list m m0)) sigma pa). exact
  (union_mpl_correct_wrt_sign_invar_0 (M2 prec_list m m0) 
     (Npos (xI p)) a0 pa sigma H1 H2). reflexivity. replace
  (state_correct_wrt_sign_with_offset
     (M2 prec_list (union_mpl_0 (Npos p) a0 m) m0) sigma pa) with
  (state_correct_wrt_sign_with_offset
     (union_mpl_0 (Npos (xO p)) a0 (M2 prec_list m m0)) sigma pa). exact
  (union_mpl_correct_wrt_sign_invar_0 (M2 prec_list m m0) 
     (Npos (xO p)) a0 pa sigma H1 H2). reflexivity.
	replace
  (state_correct_wrt_sign_with_offset
     (M2 prec_list m (union_mpl_0 N0 a0 m0)) sigma pa) with
  (state_correct_wrt_sign_with_offset
     (union_mpl_0 (Npos 1) a0 (M2 prec_list m m0)) sigma pa). exact
  (union_mpl_correct_wrt_sign_invar_0 (M2 prec_list m m0) 
     (Npos 1) a0 pa sigma H1 H2). reflexivity. intros. simpl in |- *. elim (state_correct_wrt_sign_with_offset_M2 _ _ _ _ H3). elim (state_correct_wrt_sign_with_offset_M2 _ _ _ _ H4). intros. cut
  (state_correct_wrt_sign_with_offset (union_mpl m m1) sigma (pre_ad_O pa)).
	cut
  (state_correct_wrt_sign_with_offset (union_mpl m0 m2) sigma (pre_ad_I pa)). intros. unfold state_correct_wrt_sign_with_offset in |- *. intros.
	induction  a as [| p0]. elim (H10 N0 p). intros. split with x. simpl in H12.
	exact H12. simpl in H11. exact H11. induction  p0 as [p0 Hrecp0| p0 Hrecp0| ]. elim (H9 (Npos p0) p).
	intros. split with x. simpl in H12. exact H12. simpl in H11.
	exact H11. elim (H10 (Npos p0) p). intros. split with x. simpl in H12. exact H12. simpl in H11. exact H11. elim (H9 N0 p). intros.
	simpl in H12. simpl in H11. split with x. exact H12. exact H11.
	exact (H0 _ _ _ H8 H6). exact (H _ _ _ H7 H5).
Qed.

Lemma union_mpl_correct_wrt_sign_invar :
 forall (s0 s1 : state) (sigma : signature),
 state_correct_wrt_sign s0 sigma ->
 state_correct_wrt_sign s1 sigma ->
 state_correct_wrt_sign (union_mpl s0 s1) sigma.
Proof.
	intros. replace (state_correct_wrt_sign (union_mpl s0 s1) sigma) with
  (state_correct_wrt_sign_with_offset (union_mpl s0 s1) sigma pre_ad_empty). apply (union_mpl_correct_wrt_sign_invar_1 s0 s1 pre_ad_empty sigma). unfold state_correct_wrt_sign_with_offset in |- *.
	simpl in |- *. exact H. unfold state_correct_wrt_sign_with_offset in |- *. simpl in |- *.
	exact H0. unfold state_correct_wrt_sign_with_offset in |- *. reflexivity.
Qed.

Lemma union_0_correct_wrt_sign_invar :
 forall (d : preDTA) (a0 a1 : ad) (s : state) (sigma : signature),
 predta_correct_wrt_sign d sigma ->
 union_0 d a0 a1 = Some s -> state_correct_wrt_sign s sigma.
Proof.
	unfold union_0 in |- *. unfold union_opt_state in |- *. intros. elim (option_sum state (MapGet state d (uad_conv_0 a0))); intros y. elim y. intros x y0.
	rewrite y0 in H0. elim (option_sum state (MapGet state d (uad_conv_1 a1))); intros y1. elim y1. intros x0 y2. rewrite y2 in H0. inversion H0. apply (union_mpl_correct_wrt_sign_invar x x0 sigma). unfold predta_correct_wrt_sign in H. exact (H _ _ y0). unfold predta_correct_wrt_sign in H. exact (H _ _ y2).
	rewrite y1 in H0. inversion H0. rewrite <- H2. exact (H _ _ y0).
	rewrite y in H0. elim (option_sum state (MapGet state d (uad_conv_1 a1))).
	intros y0. elim y0. intros x y1. rewrite y1 in H0. inversion H0. rewrite <- H2.
	exact (H _ _ y1). intros y0. rewrite y0 in H0. inversion H0.
Qed.

Lemma insert_ostate_correct_wrt_sign_invar :
 forall (d : preDTA) (a : ad) (s : state) (sigma : signature),
 predta_correct_wrt_sign d sigma ->
 state_correct_wrt_sign s sigma ->
 predta_correct_wrt_sign (insert_ostate d a (Some s)) sigma.
Proof.
	unfold predta_correct_wrt_sign in |- *. unfold insert_ostate in |- *. intros.
	rewrite (MapPut_semantics state d a s) in H1. elim (bool_is_true_or_false (Neqb a a0)); intros; rewrite H2 in H1.
	inversion H1. rewrite <- H4. exact H0. exact (H a0 s0 H1).
Qed.

Lemma union_correct_wrt_sign_invar :
 forall (d0 d1 : DTA) (sigma : signature),
 dta_correct_wrt_sign d0 sigma ->
 dta_correct_wrt_sign d1 sigma -> dta_correct_wrt_sign (union d0 d1) sigma.
Proof.
	unfold union in |- *. simple induction d0. simple induction d1. unfold union_1 in |- *. unfold insert_main_ostate in |- *. unfold dta_correct_wrt_sign in |- *. intros. unfold insert_main_ostate_0 in |- *. elim (option_sum state (union_0 (u_merge p p0) a a0)).
	intros y. elim y. intros x y0. rewrite y0. exact
  (insert_ostate_correct_wrt_sign_invar (u_merge p p0)
     (new_preDTA_ad (u_merge p p0)) x sigma
     (umerge_correct_wrt_sign_invar _ _ _ H H0)
     (union_0_correct_wrt_sign_invar (u_merge p p0) a a0 x sigma
        (umerge_correct_wrt_sign_invar _ _ _ H H0) y0)).
	intro y. rewrite y. simpl in |- *. exact (umerge_correct_wrt_sign_invar _ _ _ H H0).
Qed.

Lemma upl_conv_0_ref_ok_invar :
 forall (p : prec_list) (a : ad),
 prec_occur (upl_conv_0 p) a ->
 exists b : ad, a = uad_conv_0 b /\ prec_occur p b.
Proof.
	simple induction p. intros. simpl in H1. inversion H1. split with a. split.
	reflexivity. exact (prec_hd a p0 p1). elim (H a0 H6). intros. split with x. elim H7. intros. split. exact H8. exact (prec_int0 a x p0 p1 H9). elim (H0 a0 H6). intros. split with x. elim H7. intros. split.
	exact H8. exact (prec_int1 a x p0 p1 H9). intros. simpl in H.
	inversion H.
Qed.

Lemma upl_conv_1_ref_ok_invar :
 forall (p : prec_list) (a : ad),
 prec_occur (upl_conv_1 p) a ->
 exists b : ad, a = uad_conv_1 b /\ prec_occur p b.
Proof.
	simple induction p. intros. simpl in H1. inversion H1. split with a. split.
	reflexivity. exact (prec_hd a p0 p1). elim (H a0 H6). intros. split with x. elim H7. intros. split. exact H8. exact (prec_int0 a x p0 p1 H9). elim (H0 a0 H6). intros. split with x. elim H7. intros. split.
	exact H8. exact (prec_int1 a x p0 p1 H9). intros. simpl in H.
	inversion H.
Qed.

Lemma udta_conv_0_ref_ok_invar_0 :
 forall (d : preDTA) (a : ad) (s : state) (c : ad) (p : prec_list) (b : ad),
 MapGet state (udta_conv_0 d) (uad_conv_0 a) = Some s ->
 MapGet prec_list s c = Some p ->
 prec_occur p b ->
 exists s' : state,
   (exists p' : prec_list,
      (exists b' : ad,
         MapGet state d a = Some s' /\
         MapGet prec_list s' c = Some p' /\
         p = upl_conv_0 p' /\
         s = umpl_conv_0 s' /\ b = uad_conv_0 b' /\ prec_occur p' b')).
Proof.
	intros. elim (u_conv_0_invar_5 d a s H). intros. split with x. elim H2.
	intros. rewrite H3 in H0. elim (u_conv_0_invar_7 x c p H0). intros. split with x0. elim H5. intros. rewrite H6 in H1. elim (upl_conv_0_ref_ok_invar x0 b H1). intros. split with x1. elim H8. intros. split. exact H4. split.
	exact H7. split. exact H6. split. exact H3. split. exact H9. exact H10.
Qed.

Lemma udta_conv_1_ref_ok_invar_0 :
 forall (d : preDTA) (a : ad) (s : state) (c : ad) (p : prec_list) (b : ad),
 MapGet state (udta_conv_1 d) (uad_conv_1 a) = Some s ->
 MapGet prec_list s c = Some p ->
 prec_occur p b ->
 exists s' : state,
   (exists p' : prec_list,
      (exists b' : ad,
         MapGet state d a = Some s' /\
         MapGet prec_list s' c = Some p' /\
         p = upl_conv_1 p' /\
         s = umpl_conv_1 s' /\ b = uad_conv_1 b' /\ prec_occur p' b')).
Proof.
	intros. elim (u_conv_1_invar_5 d a s H). intros. split with x. elim H2.
	intros. rewrite H3 in H0. elim (u_conv_1_invar_7 x c p H0). intros. split with x0. elim H5. intros. rewrite H6 in H1. elim (upl_conv_1_ref_ok_invar x0 b H1). intros. split with x1. elim H8. intros. split. exact H4. split.
	exact H7. split. exact H6. split. exact H3. split. exact H9. exact H10.
Qed.

Lemma udta_conv_0_ref_ok_invar :
 forall d : preDTA, preDTA_ref_ok d -> preDTA_ref_ok (udta_conv_0 d).
Proof.
	unfold preDTA_ref_ok in |- *. intros. elim (u_conv_0_invar_8 _ _ _ H0). intros.
	rewrite H3 in H0. elim (udta_conv_0_ref_ok_invar_0 _ _ _ _ _ _ H0 H1 H2).
	intros. elim H4. intros. elim H5. intros. decompose [and] H6. elim (H _ _ _ _ _ H7 H9 H13). intros. split with (umpl_conv_0 x3). rewrite H11.
	exact (u_conv_0_invar_0 _ _ _ H12).
Qed.

Lemma udta_conv_1_ref_ok_invar :
 forall d : preDTA, preDTA_ref_ok d -> preDTA_ref_ok (udta_conv_1 d).
Proof.
	unfold preDTA_ref_ok in |- *. intros. elim (u_conv_1_invar_8 _ _ _ H0). intros.
	rewrite H3 in H0. elim (udta_conv_1_ref_ok_invar_0 _ _ _ _ _ _ H0 H1 H2).
	intros. elim H4. intros. elim H5. intros. decompose [and] H6. elim (H _ _ _ _ _ H7 H9 H13). intros. split with (umpl_conv_1 x3). rewrite H11.
	exact (u_conv_1_invar_0 _ _ _ H12).
Qed.

Lemma MapMerge_ref_ok_invar :
 forall d0 d1 : preDTA,
 preDTA_ref_ok d0 -> preDTA_ref_ok d1 -> preDTA_ref_ok (MapMerge state d0 d1).
Proof.
	unfold preDTA_ref_ok in |- *. intros. rewrite (MapMerge_semantics state d0 d1) in H1. rewrite (MapMerge_semantics state d0 d1). elim (option_sum state (MapGet state d1 a)); intros y. elim y. intros x y0. rewrite y0 in H1. inversion H1. rewrite <- H5 in H2. elim (H0 a x c pl b y0 H2 H3). intros. rewrite H4. split with x0. reflexivity. rewrite y in H1. elim (H a s c pl b H1 H2 H3). intros. rewrite H4. elim (option_sum state (MapGet state d1 b)).
	intros y0. elim y0. intros x0 y1. rewrite y1. split with x0. reflexivity. intro y0.
	rewrite y0. split with x. reflexivity.
Qed.

Lemma u_merge_ref_ok_invar :
 forall d0 d1 : preDTA,
 preDTA_ref_ok d0 -> preDTA_ref_ok d1 -> preDTA_ref_ok (u_merge d0 d1).
Proof.
	unfold u_merge in |- *. exact
  (fun (d0 d1 : preDTA) (p0 : preDTA_ref_ok d0) (p1 : preDTA_ref_ok d1) =>
   MapMerge_ref_ok_invar (udta_conv_0 d0) (udta_conv_1 d1)
     (udta_conv_0_ref_ok_invar d0 p0) (udta_conv_1_ref_ok_invar d1 p1)).
Qed.

Lemma union_pl_ref_ok_invar :
 forall (p p' : prec_list) (d : preDTA),
 prec_list_ref_ok p d ->
 prec_list_ref_ok p' d -> prec_list_ref_ok (union_pl p p') d.
Proof.
	simple induction p. simpl in |- *. intros. unfold prec_list_ref_ok in |- *. elim (prec_list_ref_ok_destr a p0 p1 d H1). intros. inversion H5.
	rewrite <- H6. exact (H1 a (prec_hd a p0 p1)). exact (H3 a0 H10).
	exact (H0 p' d H4 H2 a0 H10). intros. unfold prec_list_ref_ok in |- *.
	intros. simpl in H1. exact (H0 a H1).
Qed.

Lemma union_mpl_0_ref_ok_invar :
 forall (s : state) (a : ad) (p : prec_list) (d : preDTA),
 state_ref_ok (M1 prec_list a p) d ->
 state_ref_ok s d -> state_ref_ok (union_mpl_0 a p s) d.
Proof.
	simple induction s. simpl in |- *. intros. exact H. intros. simpl in |- *.  unfold state_ref_ok in |- *.
	intros. elim (bool_is_true_or_false (Neqb a1 a)); intros; rewrite H2 in H1.
	simpl in H1. elim (bool_is_true_or_false (Neqb a1 a2)); intros; rewrite H3 in H1. inversion H1. apply (union_pl_ref_ok_invar p a0 d). apply (H a1).
	simpl in |- *. rewrite (Neqb_correct a1). reflexivity. apply (H0 a). simpl in |- *.
	rewrite (Neqb_correct a). reflexivity. inversion H1. elim (Ndiscr (Nxor a a1)); intros y. elim y. intros x y0. rewrite y0 in H1. rewrite (MapPut1_semantics prec_list x a a1 a0 p) in H1. elim (bool_is_true_or_false (Neqb a a2)); intros; rewrite H3 in H1. inversion H1. rewrite <- H5.
	apply (H0 a). simpl in |- *. rewrite (Neqb_correct a). reflexivity. elim (bool_is_true_or_false (Neqb a1 a2)); intros; rewrite H4 in H1;
  inversion H1. rewrite <- H6. apply (H a1). simpl in |- *. rewrite (Neqb_correct a1). reflexivity. exact y0. rewrite (Neqb_comm a1 a) in H2. rewrite (Nxor_eq_true _ _ y) in H2. inversion H2. intros. simpl in |- *. unfold state_ref_ok in |- *. intros. cut (state_ref_ok m0 d). cut (state_ref_ok m d).
	intros. induction  a as [| p1]. induction  a0 as [| p1]. simpl in H3. exact (H _ _ _ H1 H4 N0 p0 H3). induction  p1 as [p1 Hrecp1| p1 Hrecp1| ]; simpl in H3. exact (H5 _ _ H3). exact (H _ _ _ H1 H4 _ _ H3). exact (H5 _ _ H3). induction  p1 as [p1 Hrecp1| p1 Hrecp1| ]. clear Hrecp1.
	induction  a0 as [| p2]. simpl in H3. exact (H4 _ _ H3). cut (state_ref_ok (M1 prec_list (Npos p1) p) d). intro. induction  p2 as [p2 Hrecp2| p2 Hrecp2| ]; simpl in H3. exact (H0 _ _ _ H6 H5 _ _ H3). exact (H4 _ _ H3). exact (H0 _ _ _ H6 H5 _ _ H3).
	unfold state_ref_ok in |- *. intros. apply (H1 (Ndouble_plus_one a) p3).
	induction  a as [| p4]; simpl in |- *; exact H6. cut (state_ref_ok (M1 prec_list (Npos p1) p) d). intro. induction  a0 as [| p2]. simpl in H3. exact (H _ _ _ H6 H4 _ _ H3).
	induction  p2 as [p2 Hrecp2| p2 Hrecp2| ]; simpl in H3. exact (H5 _ _ H3). exact (H _ _ _ H6 H4 _ _ H3). exact (H5 _ _ H3). unfold state_ref_ok in |- *. intros. apply (H1 (Ndouble a) p2). induction  a as [| p3]; simpl in |- *; exact H6. cut (state_ref_ok (M1 prec_list N0 p) d). intros. induction  a0 as [| p1]. simpl in H3. exact (H4 _ _ H3). induction  p1 as [p1 Hrecp1| p1 Hrecp1| ]; simpl in H3. exact (H0 _ _ _ H6 H5 _ _ H3). exact (H4 _ _ H3). exact (H0 _ _ _ H6 H5 _ _ H3). unfold state_ref_ok in |- *. intros. apply (H1 (Ndouble_plus_one a) p1). induction  a as [| p2]; exact H6. unfold state_ref_ok in |- *. intros. apply (H2 (Ndouble a1) p1).
	induction  a1 as [| p2]; exact H4. unfold state_ref_ok in |- *. intros. apply (H2 (Ndouble_plus_one a1) p1). induction  a1 as [| p2]; exact H4.
Qed.

Lemma union_mpl_correct_ref_ok_invar :
 forall (s0 s1 : state) (d : preDTA),
 state_ref_ok s0 d -> state_ref_ok s1 d -> state_ref_ok (union_mpl s0 s1) d.
Proof.
	simple induction s0. simpl in |- *. intros. induction  s1 as [| a a0| s1_1 Hrecs1_1 s1_0 Hrecs1_0]. exact H. exact H0.
	exact H0. simple induction s1. simpl in |- *. intros. exact H. intros.
	replace (union_mpl (M1 prec_list a a0) (M1 prec_list a1 a2)) with
  (union_mpl_0 a1 a2 (M1 prec_list a a0)). exact (union_mpl_0_ref_ok_invar _ _ _ _ H0 H). reflexivity. intros. replace (union_mpl (M1 prec_list a a0) (M2 prec_list m m0)) with
  (union_mpl_0 a a0 (M2 prec_list m m0)).
	exact (union_mpl_0_ref_ok_invar _ _ _ _ H1 H2). reflexivity.
	simple induction s1. intros. simpl in |- *. exact H1. intros. replace (union_mpl (M2 prec_list m m0) (M1 prec_list a a0)) with
  (union_mpl_0 a a0 (M2 prec_list m m0)). exact (union_mpl_0_ref_ok_invar _ _ _ _ H2 H1). reflexivity. intros. elim (state_ref_ok_M2_destr _ _ _ H3).
	intros. elim (state_ref_ok_M2_destr _ _ _ H4). intros. simpl in |- *.
	unfold state_ref_ok in |- *. intros. induction  a as [| p0]. simpl in H9. exact (H _ _ H5 H7 _ _ H9). induction  p0 as [p0 Hrecp0| p0 Hrecp0| ]; simpl in H9. exact (H0 _ _ H6 H8 _ _ H9). exact (H _ _ H5 H7 _ _ H9). exact (H0 _ _ H6 H8 _ _ H9).
Qed.

Lemma union_ref_ok :
 forall d0 d1 : DTA,
 DTA_ref_ok d0 -> DTA_ref_ok d1 -> DTA_ref_ok (union d0 d1).
Proof.
	simple induction d0. simple induction d1. unfold union in |- *. unfold DTA_ref_ok in |- *.
	unfold union_1 in |- *. unfold insert_main_ostate in |- *. unfold insert_main_ostate_0 in |- *. unfold insert_ostate in |- *. intros. unfold preDTA_ref_ok in |- *. unfold union_0 in |- *. unfold union_opt_state in |- *.
	elim (option_sum state (MapGet state (u_merge p p0) (uad_conv_0 a))). intro y. elim y. intro x. intro y0. rewrite y0. elim (option_sum state (MapGet state (u_merge p p0) (uad_conv_1 a0)));
  intro y1.
	elim y1. intro x0. intro y2. rewrite y2. intros. rewrite
  (MapPut_semantics state (u_merge p p0) (new_preDTA_ad (u_merge p p0))
     (union_mpl x x0)). rewrite
  (MapPut_semantics state (u_merge p p0) (new_preDTA_ad (u_merge p p0))
     (union_mpl x x0)) in H1. elim (bool_is_true_or_false (Neqb (new_preDTA_ad (u_merge p p0)) a1));
  intros; rewrite H4 in H1. inversion H1.
	elim (bool_is_true_or_false (Neqb (new_preDTA_ad (u_merge p p0)) b));
  intros; rewrite H5. split with (union_mpl x x0).
	reflexivity. cut (state_ref_ok (union_mpl x x0) (u_merge p p0)).
	intro. rewrite <- H6 in H2. exact (H7 c pl H2 b H3).
	apply (union_mpl_correct_ref_ok_invar x x0 (u_merge p p0)).
	elim (preDTA_ref_ok_def (u_merge p p0)). intros. exact (H7 (u_merge_ref_ok_invar p p0 H H0) _ _ y0). elim (preDTA_ref_ok_def (u_merge p p0)). intros. exact (H7 (u_merge_ref_ok_invar p p0 H H0) _ _ y2). elim (u_merge_ref_ok_invar p p0 H H0 a1 s c pl b H1 H2 H3). intros. elim (bool_is_true_or_false (Neqb (new_preDTA_ad (u_merge p p0)) b));
  intros; rewrite H6.
	split with (union_mpl x x0). reflexivity. split with x1.
	exact H5. rewrite y1. intros. rewrite
  (MapPut_semantics state (u_merge p p0) (new_preDTA_ad (u_merge p p0)) x)
  . rewrite
  (MapPut_semantics state (u_merge p p0) (new_preDTA_ad (u_merge p p0)) x)
   in H1. elim (bool_is_true_or_false (Neqb (new_preDTA_ad (u_merge p p0)) a1));
  intros; rewrite H4 in H1.
	inversion H1. rewrite <- H6. elim (bool_is_true_or_false (Neqb (new_preDTA_ad (u_merge p p0)) b));
  intros; rewrite H5.
	split with x. reflexivity. elim (preDTA_ref_ok_def (u_merge p p0)).
	intros. rewrite <- H6 in H2. exact (H7 (u_merge_ref_ok_invar _ _ H H0) (uad_conv_0 a) x y0 c pl H2 b H3). elim (bool_is_true_or_false (Neqb (new_preDTA_ad (u_merge p p0)) b));
  intros; rewrite H5. split with x. reflexivity. exact (u_merge_ref_ok_invar _ _ H H0 a1 s c pl b H1 H2 H3).
	intro y. rewrite y. elim (option_sum state (MapGet state (u_merge p p0) (uad_conv_1 a0)));
  intros. elim a1. intros x y1.
	rewrite y1. rewrite y1 in H1. rewrite
  (MapPut_semantics state (u_merge p p0) (new_preDTA_ad (u_merge p p0)) x)
  . rewrite
  (MapPut_semantics state (u_merge p p0) (new_preDTA_ad (u_merge p p0)) x)
   in H1. elim (bool_is_true_or_false (Neqb (new_preDTA_ad (u_merge p p0)) b));
  intros; rewrite H4.
	split with x. reflexivity. elim (bool_is_true_or_false (Neqb (new_preDTA_ad (u_merge p p0)) a2));
  intros; rewrite H5 in H1.
	inversion H1. rewrite <- H7 in H2. exact (u_merge_ref_ok_invar _ _ H H0 _ _ c pl b y1 H2 H3). exact (u_merge_ref_ok _ _ H H0 _ _ _ _ _ H1 H2 H3). rewrite b. rewrite b in H1.
	exact (u_merge_ref_ok _ _ H H0 _ _ _ _ _ H1 H2 H3).
Qed.

Lemma union_DTA_main_state_correct_invar :
 forall d0 d1 : DTA,
 DTA_main_state_correct d0 ->
 DTA_main_state_correct d1 -> DTA_main_state_correct (union d0 d1).
Proof.
	simple induction d0. simple induction d1. simpl in |- *. unfold addr_in_preDTA in |- *.
	intros. elim H. elim H0. intros. unfold union_0 in |- *.
	rewrite
  (u_merge_0 p p0 (uad_conv_0 a) (umpl_conv_0 x0)
     (u_conv_0_invar_0 p a x0 H2)). rewrite
  (u_merge_1 p p0 (uad_conv_1 a0) (umpl_conv_1 x)
     (u_conv_1_invar_0 p0 a0 x H1)). unfold insert_ostate in |- *. unfold union_opt_state in |- *.
	split with (union_mpl (umpl_conv_0 x0) (umpl_conv_1 x)).
	rewrite
  (MapPut_semantics state (u_merge p p0)
     (Nmin
        (Ndouble
           (new_preDTA_ad (MapMerge state (udta_conv_0_aux p) (M0 state))))
        (Ndouble_plus_one (new_preDTA_ad (udta_conv_1_aux p0))))
     (union_mpl (umpl_conv_0 x0) (umpl_conv_1 x))). rewrite
  (Neqb_correct
     (Nmin
        (Ndouble
           (new_preDTA_ad (MapMerge state (udta_conv_0_aux p) (M0 state))))
        (Ndouble_plus_one (new_preDTA_ad (udta_conv_1_aux p0)))))
  . reflexivity.
Qed.