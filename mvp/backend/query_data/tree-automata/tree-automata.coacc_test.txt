
Require Import Bool.
Require Import Arith.
Require Import NArith Ndec.
Require Import ZArith.
From IntMap Require Import Allmaps.
Require Import bases.
(* bases:
Require Import Bool.
Require Import Arith.
Require Import ZArith.
Require Import NArith.
Require Import Ndec.
From IntMap Require Import Allmaps.
Require Import EqNat.
Require Export Max.

Lemma nat_sum : forall n : nat, n = 0 \/ (exists m : nat, n = S m).

Lemma le_n_n : forall n : nat, n <= n.

Lemma le_l_or_r : forall n m : nat, n <= m \/ m <= n.

Lemma plus_n_O : forall n : nat, n + 0 = n.
 
 Lemma S_plus_l : forall n m : nat, S (n + m) = S n + m.
 
 Lemma S_plus_r : forall n m : nat, S (n + m) = n + S m.

Lemma max_le_Sr_0 :
 forall n m : nat, max n m <= max n (S m) /\ max (S n) m <= max (S n) (S m).

Lemma max_le_Sr : forall n m : nat, max n m <= max n (S m).

Lemma plus_O_r : forall n : nat, n + 0 = n.

Lemma plus_O_l : forall n : nat, n + 0 = n.

Lemma le_mult_lS : forall n m : nat, n * m <= S n * m.

Lemma le_mult_rS : forall n m : nat, n * m <= n * S m.

Lemma le_disj : forall n m : nat, n <= m -> n = m \/ S n <= m.

Lemma le_mult_l : forall n m p : nat, n <= m -> n * p <= m * p.

Lemma le_mult_r : forall n m p : nat, n <= m -> p * n <= p * m.

Lemma le_mult_mult : forall n m p q : nat, n <= m -> p <= q -> n * p <= m * q.

Lemma Sn_eq_Sm_n_eq_m : forall n m : nat, S n = S m -> n = m.

Lemma bool_dec_eq : forall a b : bool, {a = b} + {a <> b}.

Lemma bool_is_false_or_true : forall a : bool, a = false \/ a = true.

Lemma bool_is_true_or_false : forall a : bool, a = true \/ a = false.

Lemma in_M0_false :
 forall (A : Set) (a : A), ~ (exists e : ad, MapGet A (M0 A) e = Some a).

Lemma in_M1_id :
 forall (A : Set) (a : A) (x : ad) (e : A),
 (exists c : ad, MapGet A (M1 A x e) c = Some a) -> a = e.

Lemma in_M2_disj :
 forall (A : Set) (a : A) (m0 m1 : Map A),
 (exists c : ad, MapGet A (M2 A m0 m1) c = Some a) ->
 (exists c : ad, MapGet A m0 c = Some a) \/
 (exists c : ad, MapGet A m1 c = Some a).

Lemma aux_Neqb_1_0 : forall p : positive, Peqb p p = true.

Lemma aux_Neqb_1_1 : forall p p0 : positive, Peqb p p0 = true -> p = p0.

Lemma aux_Neqb_trans :
 forall a b c : ad, Neqb a b = true -> Neqb b c = true -> Neqb a c = true.

Lemma indprinciple_nat_gen :
 forall P : nat -> Prop,
 (forall n : nat, (forall m : nat, m < n -> P m) -> P n) ->
 forall n m : nat, m <= n -> P m.

Lemma beq_nat_complete : forall n m : nat, beq_nat n m = true -> n = m.

Lemma beq_nat_correct : forall n : nat, beq_nat n n = true. *)
Require Import defs.
(* defs:
Require Import Bool.
Require Import Arith.
Require Import ZArith.
From IntMap Require Import Allmaps.
Require Import EqNat.
Require Import bases.

Inductive term : Set :=
    app : ad -> term_list -> term
with term_list : Set :=
  | tnil : term_list
  | tcons : term -> term_list -> term_list.

Scheme term_term_list_rec := Induction for term
  Sort Set
  with term_list_term_rec := Induction for term_list 
  Sort Set.

Scheme term_term_list_ind := Induction for term
  Sort Prop
  with term_list_term_ind := Induction for term_list 
  Sort Prop.

Lemma term_list_disj :
 forall l : term_list,
 l = tnil \/ (exists hd : term, (exists tl : term_list, l = tcons hd tl)).

Fixpoint lst_length (l : term_list) : nat :=
  match l with
  | tnil => 0
  | tcons _ l' => S (lst_length l')
  end.

Fixpoint term_high (t : term) : nat :=
  match t with
  | app a l => S (term_high_0 l)
  end
 
 with term_high_0 (l : term_list) : nat :=
  match l with
  | tnil => 0
  | tcons hd tl => max (term_high hd) (term_high_0 tl)
  end.

Lemma high_aux_0 :
 forall (a : ad) (l : term_list), S (term_high_0 l) <= term_high (app a l).

Lemma high_aux_1 :
 forall (a : ad) (l : term_list), S (term_high_0 l) = term_high (app a l).

Lemma high_aux_2 : forall (l : term_list) (c : ad), 1 <= term_high (app c l).

Lemma high_aux_3 :
 forall (t : term) (tl : term_list), term_high t <= term_high_0 (tcons t tl).

Lemma high_aux_4 :
 forall (t : term) (tl : term_list),
 term_high_0 tl <= term_high_0 (tcons t tl).

Fixpoint taille_term (t : term) : nat :=
  match t with
  | app c l => S (mtaille_term_list l)
  end
 
 with mtaille_term_list (l : term_list) : nat :=
  match l with
  | tnil => 0
  | tcons hd tl => max (taille_term hd) (mtaille_term_list tl)
  end.

Inductive prec_list : Set :=
  | prec_cons : ad -> prec_list -> prec_list -> prec_list
  | prec_empty : prec_list.

Lemma pl_sum :
 forall pl : prec_list,
 pl = prec_empty \/
 (exists a : ad,
    (exists la : prec_list, (exists ls : prec_list, pl = prec_cons a la ls))).

Definition state := Map prec_list.

Definition preDTA := Map state.

Inductive DTA : Set :=
    dta : preDTA -> ad -> DTA.

Fixpoint taille_0 (l : prec_list) : nat :=
  match l with
  | prec_empty => 0
  | prec_cons x y z => S (taille_0 y + taille_0 z)
  end.

Fixpoint taille_1 (s : state) : nat :=
  match s with
  | M0 => 0
  | M1 x y => taille_0 y
  | M2 x y => max (taille_1 x) (taille_1 y)
  end.

Fixpoint DTA_taille (d : preDTA) : nat :=
  match d with
  | M0 => 0
  | M1 x y => taille_1 y
  | M2 x y => max (DTA_taille x) (DTA_taille y)
  end.

Lemma taille_aux_0 :
 forall (a : ad) (la ls : prec_list),
 S (taille_0 la) <= taille_0 (prec_cons a la ls).

Lemma taille_aux_1 :
 forall (a : ad) (la ls : prec_list), 1 <= taille_0 (prec_cons a la ls).

Lemma taille_aux_2 :
 forall (a : ad) (la ls : prec_list),
 S (taille_0 ls) <= taille_0 (prec_cons a la ls).

Inductive prec_occur : prec_list -> ad -> Prop :=
  | prec_hd :
      forall (a : ad) (pl0 pl1 : prec_list),
      prec_occur (prec_cons a pl0 pl1) a
  | prec_int0 :
      forall (a b : ad) (pl0 pl1 : prec_list),
      prec_occur pl0 b -> prec_occur (prec_cons a pl0 pl1) b
  | prec_int1 :
      forall (a b : ad) (pl0 pl1 : prec_list),
      prec_occur pl1 b -> prec_occur (prec_cons a pl0 pl1) b.

Inductive prec_contained : prec_list -> prec_list -> Prop :=
  | prec_id : forall p : prec_list, prec_contained p p
  | prec_c_int0 :
      forall (p p0 p1 : prec_list) (a : ad),
      prec_contained p p0 -> prec_contained p (prec_cons a p0 p1)
  | prec_c_int1 :
      forall (p p0 p1 : prec_list) (a : ad),
      prec_contained p p1 -> prec_contained p (prec_cons a p0 p1).

Definition state_in_dta (d : preDTA) (s : state) : Prop :=
  exists a : ad, MapGet state d a = Some s.

Definition state_in_dta_diff (d : preDTA) (s : state) 
  (a : ad) : Prop := exists b : ad, MapGet state d b = Some s /\ a <> b.

Definition prec_in_dta (d : preDTA) (p : prec_list) : Prop :=
  exists s : state,
    (exists a : ad,
       (exists c : ad,
          MapGet state d a = Some s /\
          MapGet prec_list s c = Some p)).

Definition prec_in_dta_cont (d : preDTA) (p : prec_list) : Prop :=
  exists s : state,
    (exists b : ad,
       (exists c : ad,
          (exists p0 : prec_list,
             MapGet state d b = Some s /\
             MapGet prec_list s c = Some p0 /\ prec_contained p p0))).

Definition prec_in_dta_diff (d : preDTA) (p : prec_list) 
  (a : ad) : Prop :=
  exists s : state,
    (exists b : ad,
       (exists c : ad,
          MapGet state d b = Some s /\
          MapGet prec_list s c = Some p /\ a <> b)).

Definition prec_in_dta_diff_cont (d : preDTA) (p : prec_list) 
  (a : ad) : Prop :=
  exists s : state,
    (exists b : ad,
       (exists c : ad,
          (exists p0 : prec_list,
             MapGet state d b = Some s /\
             MapGet prec_list s c = Some p0 /\
             prec_contained p p0 /\ a <> b))).

Definition prec_in_state (s : state) (p : prec_list) : Prop :=
  exists c : ad, MapGet prec_list s c = Some p.

Lemma prec_in_state_M0_false :
 forall p : prec_list, ~ prec_in_state (M0 prec_list) p.

Lemma state_in_dta_M0_false : forall s : state, ~ state_in_dta (M0 state) s.

Lemma prec_occur_1 :
 forall (a : ad) (p0 p1 p2 : prec_list),
 prec_contained (prec_cons a p0 p1) p2 -> prec_occur p2 a.

Lemma prec_contained_0 :
 forall (a : ad) (p0 p1 p2 : prec_list),
 prec_contained (prec_cons a p0 p1) p2 -> prec_contained p0 p2.

Lemma prec_contained_1 :
 forall (a : ad) (p0 p1 p2 : prec_list),
 prec_contained (prec_cons a p0 p1) p2 -> prec_contained p1 p2.

Inductive term_occur : term -> term -> Prop :=
  | to_eq : forall t : term, term_occur t t
  | to_st :
      forall (t : term) (a : ad) (tl : term_list),
      term_list_occur t tl -> term_occur t (app a tl)
with term_list_occur : term -> term_list -> Prop :=
  | tlo_head :
      forall (t hd : term) (tl : term_list),
      term_occur t hd -> term_list_occur t (tcons hd tl)
  | tlo_tail :
      forall (t hd : term) (tl : term_list),
      term_list_occur t tl -> term_list_occur t (tcons hd tl).

Definition term_occur_def_0 (t : term) :=
  forall u : term, term_occur u t -> term_high u <= term_high t.

Definition term_occur_def_1 (t : term_list) :=
  forall u : term, term_list_occur u t -> term_high u <= term_high_0 t.

Lemma term_occur_0_0 :
 forall (a : ad) (t : term_list),
 term_occur_def_1 t -> term_occur_def_0 (app a t).

Lemma term_occur_0_1 : term_occur_def_1 tnil.

Lemma term_occur_0_2 :
 forall t : term,
 term_occur_def_0 t ->
 forall t0 : term_list, term_occur_def_1 t0 -> term_occur_def_1 (tcons t t0).

Lemma term_occur_0 :
 forall t u : term, term_occur u t -> term_high u <= term_high t.

Lemma term_occur_1 :
 forall (t : term_list) (u : term),
 term_list_occur u t -> term_high u <= term_high_0 t.

Definition indprinciple_3_aux (n : nat) :=
  forall P : term -> Prop,
  (forall (a : ad) (tl : term_list),
   (forall u : term, term_list_occur u tl -> P u) -> P (app a tl)) ->
  forall t : term, term_high t <= n -> P t.

Lemma indprinciple_3_0 : indprinciple_3_aux 0.

Lemma indprinciple_3_1 :
 forall n : nat, indprinciple_3_aux n -> indprinciple_3_aux (S n).

Lemma indprinciple_3_2 :
 forall (n : nat) (P : term -> Prop),
 (forall (a : ad) (tl : term_list),
  (forall u : term, term_list_occur u tl -> P u) -> P (app a tl)) ->
 forall t : term, term_high t <= n -> P t.

Lemma indprinciple_term :
 forall P : term -> Prop,
 (forall (a : ad) (tl : term_list),
  (forall u : term, term_list_occur u tl -> P u) -> P (app a tl)) ->
 forall t : term, P t.

Lemma Ndouble_inv_N0 : forall x : ad, Ndouble x = N0 -> x = N0.

Lemma Ndouble_inv_xO :
 forall (x : ad) (p : positive), Ndouble x = Npos (xO p) -> x = Npos p.

Lemma Ndouble_plus_one_inv_xH :
 forall x : ad, Ndouble_plus_one x = Npos 1 -> x = N0.

Lemma Ndouble_plus_one_inv_xI :
 forall (x : ad) (p : positive),
 Ndouble_plus_one x = Npos (xI p) -> x = Npos p. *)
Require Import semantics.
(* semantics:
Require Import Bool.
Require Import Arith.
Require Import Classical_Prop.
From IntMap Require Import Allmaps.
Require Import bases.
Require Import defs.

Unset Standard Proposition Elimination Names.

Fixpoint rec_term (d : preDTA) (a : ad) (t : term) 
 (n : nat) {struct n} : bool :=
  match n with
  | O => false
  | S k =>
      match t with
      | app c l =>
          match MapGet _ d a with
          | None => false
          | Some lts =>
              match MapGet _ lts c with
              | None => false
              | Some pre => rec_list_terms d pre l k
              end
          end
      end
  end
 
 with rec_list_terms (d : preDTA) (pre : prec_list) 
 (l : term_list) (n : nat) {struct n} : bool :=
  match n with
  | O => false
  | S k =>
      match pre with
      | prec_empty => match l with
                      | tnil => true
                      | _ => false
                      end
      | prec_cons st stp pre' =>
          match l with
          | tnil => false
          | tcons hd tl =>
              rec_list_terms d pre' l k
              || rec_term d st hd k && rec_list_terms d stp tl k
          end
      end
  end.

Lemma borne_0_0 :
 forall p : prec_list,
 prec_in_state (M0 prec_list) p -> taille_0 p <= taille_1 (M0 prec_list).

Lemma borne_0_1 :
 forall (a : ad) (p' p : prec_list),
 prec_in_state (M1 prec_list a p') p ->
 taille_0 p <= taille_1 (M1 prec_list a p').

Lemma borne_0_2 :
 forall (m0 m1 : Map prec_list) (p : prec_list),
 (prec_in_state m0 p -> taille_0 p <= taille_1 m0) ->
 (prec_in_state m1 p -> taille_0 p <= taille_1 m1) ->
 prec_in_state (M2 prec_list m0 m1) p ->
 taille_0 p <= taille_1 (M2 prec_list m0 m1).

Lemma borne_0 :
 forall (s : state) (p : prec_list),
 prec_in_state s p -> taille_0 p <= taille_1 s.

Lemma borne_1_0 :
 forall s : state,
 state_in_dta (M0 state) s -> taille_1 s <= DTA_taille (M0 state).

Lemma borne_1_1 :
 forall (a : ad) (s' s : state),
 state_in_dta (M1 state a s') s -> taille_1 s <= DTA_taille (M1 state a s').

Lemma borne_1_2 :
 forall (m0 m1 : Map state) (s : state),
 (state_in_dta m0 s -> taille_1 s <= DTA_taille m0) ->
 (state_in_dta m1 s -> taille_1 s <= DTA_taille m1) ->
 state_in_dta (M2 state m0 m1) s -> taille_1 s <= DTA_taille (M2 state m0 m1).

Lemma borne_1 :
 forall (d : preDTA) (s : state),
 state_in_dta d s -> taille_1 s <= DTA_taille d.

Lemma borne_2 :
 forall (d : preDTA) (p : prec_list),
 prec_in_dta d p -> taille_0 p <= DTA_taille d.

Definition essence (t : term) (d : preDTA) : nat :=
  S (term_high t) * S (DTA_taille d).

Definition essence_list (l : term_list) (d : preDTA) 
  (pl : prec_list) : nat :=
  match l, pl with
  | tnil, _ => 1
  | _, prec_empty => 1
  | _, prec_cons a la ls =>
      taille_0 pl + S (term_high_0 l) * S (DTA_taille d)
  end.

Lemma conservation_0_0 : forall n n0 : nat, S n * S n0 = S (n0 + n * S n0).

Lemma conservation_0 :
 forall (d : preDTA) (p : prec_list) (c : ad) (l : term_list),
 prec_in_dta d p -> S (essence_list l d p) <= essence (app c l) d.

Lemma conservation_1 :
 forall (d : preDTA) (l : term_list), 1 <= essence_list l d prec_empty.

Lemma conservation_2 :
 forall (d : preDTA) (p : prec_list), 1 <= essence_list tnil d p.

Lemma conservation_3 :
 forall (d : preDTA) (hd : term) (tl : term_list) (a : ad)
   (la ls : prec_list),
 S (essence_list (tcons hd tl) d ls) <=
 essence_list (tcons hd tl) d (prec_cons a la ls).

Lemma conservation_4 :
 forall (d : preDTA) (hd : term) (tl : term_list) (a : ad)
   (la ls : prec_list),
 S (essence_list tl d la) <= essence_list (tcons hd tl) d (prec_cons a la ls).

Lemma conservation_5_0 :
 forall (a : ad) (la ls : prec_list), 1 <= taille_0 (prec_cons a la ls).

Lemma conservation_5 :
 forall (d : preDTA) (hd : term) (tl : term_list) (a : ad)
   (la ls : prec_list),
 S (essence hd d) <= essence_list (tcons hd tl) d (prec_cons a la ls).

Definition dta_rec_term (d : DTA) (t : term) : bool :=
  match d with
  | dta p a => rec_term p a t (essence t p)
  end.

Inductive reconnaissance : preDTA -> ad -> term -> Prop :=
    rec_dta :
      forall (d : preDTA) (a : ad) (t : term) (ladj : state),
      MapGet state d a = Some ladj ->
      state_reconnait d ladj t -> reconnaissance d a t
with state_reconnait : preDTA -> state -> term -> Prop :=
    rec_st :
      forall (d : preDTA) (s : state) (c : ad) (tl : term_list)
        (l : prec_list),
      MapGet prec_list s c = Some l ->
      liste_reconnait d l tl -> state_reconnait d s (app c tl)
with liste_reconnait : preDTA -> prec_list -> term_list -> Prop :=
  | rec_empty : forall d : preDTA, liste_reconnait d prec_empty tnil
  | rec_consi :
      forall (d : preDTA) (a : ad) (la ls : prec_list) 
        (hd : term) (tl : term_list),
      reconnaissance d a hd ->
      liste_reconnait d la tl ->
      liste_reconnait d (prec_cons a la ls) (tcons hd tl)
  | rec_consn :
      forall (d : preDTA) (a : ad) (la ls : prec_list) 
        (hd : term) (tl : term_list),
      liste_reconnait d ls (tcons hd tl) ->
      liste_reconnait d (prec_cons a la ls) (tcons hd tl).

Definition reconnait (d : DTA) (t : term) : Prop :=
  match d with
  | dta p a => reconnaissance p a t
  end.

Scheme mreconnaissance_ind := Induction for reconnaissance
  Sort Prop
  with mstrec_ind := Induction for state_reconnait 
  Sort Prop
  with mlrec_ind := Induction for liste_reconnait Sort Prop.

Lemma sem_listes_0 :
 forall (d : preDTA) (p : prec_list) (hd : term) (tl : term_list),
 liste_reconnait d p (tcons hd tl) -> p <> prec_empty.

Lemma sem_listes_1 :
 forall (d : preDTA) (hd : term) (tl : term_list),
 ~ liste_reconnait d prec_empty (tcons hd tl).

Lemma sem_listes_2 :
 forall (d : preDTA) (pl : prec_list),
 liste_reconnait d pl tnil -> pl = prec_empty.

Definition sem_equiv_prop_t (t : term) :=
  forall (d : preDTA) (a : ad) (n : nat),
  rec_term d a t n = true -> reconnaissance d a t.
Definition sem_equiv_prop_l (l : term_list) :=
  forall (d : preDTA) (p : prec_list) (n : nat),
  rec_list_terms d p l n = true -> liste_reconnait d p l.

Lemma semantic_equiv_0_0 :
 forall (d : preDTA) (p : prec_list) (n : nat),
 rec_list_terms d p tnil n = true -> p = prec_empty.

Lemma semantic_equiv_0_1 : sem_equiv_prop_l tnil.

Lemma semantic_equiv_0_2 :
 forall (d : preDTA) (a a' : ad) (l : term_list) (n : nat) 
   (s : state) (p : prec_list),
 rec_term d a (app a' l) (S n) = true ->
 MapGet state d a = Some s ->
 MapGet prec_list s a' = Some p -> rec_list_terms d p l n = true.

Lemma semantic_equiv_0_3 :
 forall (d : preDTA) (a a' : ad) (l : term_list) (n : nat),
 rec_term d a (app a' l) (S n) = true ->
 exists s : state, MapGet state d a = Some s.

Lemma semantic_equiv_0_4 :
 forall (d : preDTA) (a a' : ad) (l : term_list) (n : nat) (s : state),
 MapGet state d a = Some s ->
 rec_term d a (app a' l) (S n) = true ->
 exists p : prec_list, MapGet prec_list s a' = Some p.

Lemma semantic_equiv_0_5 :
 forall (a : ad) (t : term_list),
 sem_equiv_prop_l t -> sem_equiv_prop_t (app a t).

Lemma semantic_equiv_0_6 :
 forall (n : nat) (t : term) (t0 : term_list),
 (forall (d : preDTA) (a : ad) (m : nat),
  rec_term d a t m = true -> reconnaissance d a t) ->
 (forall (d : preDTA) (p : prec_list) (m : nat),
  rec_list_terms d p t0 m = true -> liste_reconnait d p t0) ->
 forall (d : preDTA) (p : prec_list),
 rec_list_terms d p (tcons t t0) n = true -> liste_reconnait d p (tcons t t0).

Lemma semantic_equiv_0_7 :
 forall t : term,
 sem_equiv_prop_t t ->
 forall t0 : term_list, sem_equiv_prop_l t0 -> sem_equiv_prop_l (tcons t t0).

Lemma semantic_equiv_0 :
 forall (d : preDTA) (a : ad) (t : term) (n : nat),
 rec_term d a t n = true -> reconnaissance d a t.

Definition invar_term (t : term) : Prop :=
  forall (n m : nat) (d : preDTA) (a : ad),
  rec_term d a t n = true -> n <= m -> rec_term d a t m = true.

Definition invar_list (tl : term_list) : Prop :=
  forall (n m : nat) (d : preDTA) (p : prec_list),
  rec_list_terms d p tl n = true -> n <= m -> rec_list_terms d p tl m = true.

Lemma invar_0 : invar_list tnil.

Lemma invar_1_0 :
 forall (d : preDTA) (a c : ad) (t : term_list) (n : nat) 
   (s : state) (p : prec_list),
 MapGet state d a = Some s ->
 MapGet prec_list s c = Some p ->
 rec_list_terms d p t n = true -> rec_term d a (app c t) (S n) = true.

Lemma invar_1_1 :
 forall (d : preDTA) (a c : ad) (t : term_list) (n : nat),
 rec_term d a (app c t) (S n) = true ->
 exists p : prec_list, rec_list_terms d p t n = true.

Lemma invar_1 :
 forall (a : ad) (t : term_list), invar_list t -> invar_term (app a t).

Lemma invar_2_0 :
 forall (d : preDTA) (p : prec_list) (n : nat),
 rec_list_terms d p tnil n = true -> p = prec_empty.

Lemma invar_2_1 :
 forall (d : preDTA) (a : ad) (la ls : prec_list) (hd : term)
   (tl : term_list) (n : nat),
 rec_list_terms d (prec_cons a la ls) (tcons hd tl) (S n) = true ->
 rec_list_terms d ls (tcons hd tl) n = true \/
 rec_term d a hd n = true /\ rec_list_terms d la tl n = true.

Lemma invar_2_2 :
 forall (d : preDTA) (a : ad) (la ls : prec_list) (hd : term)
   (tl : term_list) (n : nat),
 rec_list_terms d ls (tcons hd tl) n = true \/
 rec_term d a hd n = true /\ rec_list_terms d la tl n = true ->
 rec_list_terms d (prec_cons a la ls) (tcons hd tl) (S n) = true.
 
Lemma invar_2 :
 forall t : term,
 invar_term t ->
 forall t0 : term_list, invar_list t0 -> invar_list (tcons t t0).

Lemma invar : forall t : term, invar_term t.

Lemma invarl : forall tl : term_list, invar_list tl.

Definition dta_reconnait (d : preDTA) (a : ad) (t : term)
  (pr : reconnaissance d a t) := rec_term d a t (essence t d) = true.

Definition st_reconnait (d : preDTA) (s : state) (t : term)
  (pr : state_reconnait d s t) :=
  match t with
  | app c l =>
      exists p : prec_list,
        MapGet prec_list s c = Some p /\
        rec_list_terms d p l (essence_list l d p) = true
  end.

Definition pre_reconnait (d : preDTA) (p : prec_list) 
  (t : term_list) (pr : liste_reconnait d p t) :=
  rec_list_terms d p t (essence_list t d p) = true.

Lemma semantic_equiv_1_0 :
 forall (d : preDTA) (a : ad) (t : term) (ladj : state)
   (e : MapGet state d a = Some ladj) (s : state_reconnait d ladj t),
 st_reconnait d ladj t s -> dta_reconnait d a t (rec_dta d a t ladj e s).

Lemma semantic_equiv_1_1 :
 forall (d : preDTA) (s : state) (c : ad) (tl : term_list) 
   (l : prec_list) (e : MapGet prec_list s c = Some l)
   (l0 : liste_reconnait d l tl),
 pre_reconnait d l tl l0 ->
 st_reconnait d s (app c tl) (rec_st d s c tl l e l0).

Lemma semantic_equiv_1_2 :
 forall d : preDTA, pre_reconnait d prec_empty tnil (rec_empty d).

Lemma semantic_equiv_1_3 :
 forall (d : preDTA) (a : ad) (la ls : prec_list) (hd : term)
   (tl : term_list) (r : reconnaissance d a hd),
 dta_reconnait d a hd r ->
 forall l : liste_reconnait d la tl,
 pre_reconnait d la tl l ->
 pre_reconnait d (prec_cons a la ls) (tcons hd tl)
   (rec_consi d a la ls hd tl r l).

Lemma semantic_equiv_1_4_0 :
 forall (d : preDTA) (a : ad) (la ls : prec_list) (l : term_list) (n : nat),
 l <> tnil ->
 rec_list_terms d ls l n = true ->
 rec_list_terms d (prec_cons a la ls) l (S n) = true.

Lemma semantic_equiv_1_4 :
 forall (d : preDTA) (a : ad) (la ls : prec_list) (hd : term)
   (tl : term_list) (l : liste_reconnait d ls (tcons hd tl)),
 pre_reconnait d ls (tcons hd tl) l ->
 pre_reconnait d (prec_cons a la ls) (tcons hd tl)
   (rec_consn d a la ls hd tl l).

Lemma semantic_equiv_1 :
 forall (d : preDTA) (a : ad) (t : term),
 reconnaissance d a t -> rec_term d a t (essence t d) = true. *)
Require Import refcorrect.
(* refcorrect:
Require Import Bool.
Require Import NArith Ndec.
From IntMap Require Import Allmaps.
Require Import bases.
Require Import defs.

Definition prec_list_ref_ok (p : prec_list) (d : preDTA) : Prop :=
  forall a : ad,
  prec_occur p a -> exists s : state, MapGet state d a = Some s.

Definition state_ref_ok (s : state) (d : preDTA) : Prop :=
  forall (a : ad) (p : prec_list),
  MapGet prec_list s a = Some p -> prec_list_ref_ok p d.

Definition preDTA_ref_ok (d : preDTA) : Prop :=
  forall (a : ad) (s : state) (c : ad) (pl : prec_list) (b : ad),
  MapGet state d a = Some s ->
  MapGet prec_list s c = Some pl ->
  prec_occur pl b -> exists s0 : state, MapGet state d b = Some s0.

Definition preDTA_ref_ok_distinct (d d' : preDTA) : Prop :=
  forall (a : ad) (s : state),
  MapGet state d a = Some s -> state_ref_ok s d'.

Definition DTA_ref_ok (d : DTA) : Prop :=
  match d with
  | dta p a => preDTA_ref_ok p
  end.

Lemma prec_list_ref_ok_destr :
 forall (a : ad) (la ls : prec_list) (d : preDTA),
 prec_list_ref_ok (prec_cons a la ls) d ->
 prec_list_ref_ok la d /\ prec_list_ref_ok ls d.

Lemma state_ref_ok_M2_destr :
 forall (s0 s1 : state) (d : preDTA),
 state_ref_ok (M2 prec_list s0 s1) d ->
 state_ref_ok s0 d /\ state_ref_ok s1 d.

Lemma preDTA_ref_ok_def :
 forall d : preDTA,
 preDTA_ref_ok d <->
 (forall (a : ad) (s : state),
  MapGet state d a = Some s -> state_ref_ok s d).

Lemma preDTA_ref_ok_distinct_dest :
 forall d0 d1 d : preDTA,
 preDTA_ref_ok_distinct (M2 state d0 d1) d ->
 preDTA_ref_ok_distinct d0 d /\ preDTA_ref_ok_distinct d1 d.

Definition addr_in_dta_check (d : preDTA) (a : ad) : bool :=
  match MapGet state d a with
  | None => false
  | Some _ => true
  end.

Fixpoint prec_list_ref_ok_check (p : prec_list) : preDTA -> bool :=
  fun d : preDTA =>
  match p with
  | prec_empty => true
  | prec_cons a la ls =>
      addr_in_dta_check d a &&
      (prec_list_ref_ok_check la d && prec_list_ref_ok_check ls d)
  end.

Lemma prec_list_ref_ok_check_correct :
 forall (p : prec_list) (d : preDTA),
 prec_list_ref_ok p d -> prec_list_ref_ok_check p d = true.

Lemma prec_list_ref_ok_check_complete :
 forall (p : prec_list) (d : preDTA),
 prec_list_ref_ok_check p d = true -> prec_list_ref_ok p d.

Fixpoint state_ref_ok_check (s : state) : preDTA -> bool :=
  fun d : preDTA =>
  match s with
  | M0 => true
  | M1 a p => prec_list_ref_ok_check p d
  | M2 x y => state_ref_ok_check x d && state_ref_ok_check y d
  end.

Lemma state_ref_ok_check_correct :
 forall (s : state) (d : preDTA),
 state_ref_ok s d -> state_ref_ok_check s d = true.

Lemma state_ref_ok_check_complete :
 forall (s : state) (d : preDTA),
 state_ref_ok_check s d = true -> state_ref_ok s d.

Fixpoint predta_ref_ok_check_0 (d : preDTA) : preDTA -> bool :=
  fun d' : preDTA =>
  match d with
  | M0 => true
  | M1 a s => state_ref_ok_check s d'
  | M2 x y => predta_ref_ok_check_0 x d' && predta_ref_ok_check_0 y d'
  end.

Definition predta_ref_ok_check (d : preDTA) : bool :=
  predta_ref_ok_check_0 d d.

Lemma predta_ref_ok_check_correct_0 :
 forall d d' : preDTA,
 preDTA_ref_ok_distinct d d' -> predta_ref_ok_check_0 d d' = true.

Lemma predta_ref_ok_check_complete_0 :
 forall d d' : preDTA,
 predta_ref_ok_check_0 d d' = true -> preDTA_ref_ok_distinct d d'.

Lemma predta_ref_ok_check_correct :
 forall d : preDTA, preDTA_ref_ok d -> predta_ref_ok_check d = true.

Lemma predta_ref_ok_check_complete :
 forall d : preDTA, predta_ref_ok_check d = true -> preDTA_ref_ok d.

Definition dta_ref_ok_check (d : DTA) : bool :=
  match d with
  | dta p a => predta_ref_ok_check p
  end.

Lemma dta_ref_ok_check_correct :
 forall d : DTA, DTA_ref_ok d -> dta_ref_ok_check d = true.

Lemma dta_ref_ok_check_complete :
 forall d : DTA, dta_ref_ok_check d = true -> DTA_ref_ok d.

Definition addr_in_preDTA (d : preDTA) (a : ad) : Prop :=
  exists s : state, MapGet state d a = Some s.

Definition DTA_main_state_correct (d : DTA) : Prop :=
  match d with
  | dta p a => addr_in_preDTA p a
  end.

Definition DTA_main_state_correct_check (d : DTA) : bool :=
  match d with
  | dta p a =>
      match MapGet state p a with
      | None => false
      | Some _ => true
      end
  end.

Lemma DTA_main_state_correct_check_correct :
 forall d : DTA,
 DTA_main_state_correct d -> DTA_main_state_correct_check d = true.

Lemma DTA_main_state_correct_check_complete :
 forall d : DTA,
 DTA_main_state_correct_check d = true -> DTA_main_state_correct d. *)
Require Import lattice_fixpoint.
(* lattice_fixpoint:
Require Import Classical_Prop.
Require Import Bool.
Require Import Arith.
Require Import NArith.
Require Import Ndec.
From IntMap Require Import Allmaps.
Require Import bases.

Fixpoint domain_equal (A B : Set) (m0 : Map A) (m1 : Map B) {struct m1} :
 Prop :=
  match m0, m1 with
  | M0, M0 => True
  | M0, M1 _ _ => False
  | M0, M2 _ _ => False
  | M1 _ _, M0 => False
  | M1 a _, M1 b _ => a = b
  | M1 _ _, M2 _ _ => False
  | M2 _ _, M0 => False
  | M2 _ _, M1 _ _ => False
  | M2 a b, M2 c d => domain_equal A B a c /\ domain_equal A B b d
  end.

Lemma domain_equal_mapget :
 forall (A B : Set) (m0 : Map A) (m1 : Map B) (a : ad) (x : A),
 domain_equal A B m0 m1 ->
 MapGet A m0 a = Some x -> exists y : B, MapGet B m1 a = Some y.

Lemma domain_equal_reflexive :
 forall (A : Set) (m : Map A), domain_equal A A m m.

Lemma domain_equal_symmetric :
 forall (A B : Set) (m0 : Map A) (m1 : Map B),
 domain_equal A B m0 m1 -> domain_equal B A m1 m0.

Lemma domain_equal_transitive :
 forall (A0 A1 A2 : Set) (m0 : Map A0) (m1 : Map A1) (m2 : Map A2),
 domain_equal A0 A1 m0 m1 ->
 domain_equal A1 A2 m1 m2 -> domain_equal A0 A2 m0 m2.

Lemma map_sum :
 forall (A : Set) (m : Map A),
 m = M0 A \/
 (exists a : ad, (exists x : A, m = M1 A a x)) \/
 (exists x : Map A, (exists y : Map A, m = M2 A x y)).

Definition mEnsemble (A : Set) := Map A -> Prop.

Definition mRelation (A : Set) := Map A -> Map A -> Prop.

Definition r_symmetric (A : Set) (r : mRelation A) :=
  forall x y : Map A, r x y -> r y x.

Definition r_antisymmetric (A : Set) (r : mRelation A) :=
  forall x y : Map A, r x y -> r y x -> x = y.

Definition r_transitive (A : Set) (r : mRelation A) :=
  forall x y z : Map A, r x y -> r y z -> r x z.

Definition r_reflexive (A : Set) (r : mRelation A) := forall x : Map A, r x x.

Definition r_order (A : Set) (r : mRelation A) :=
  r_reflexive A r /\ r_antisymmetric A r /\ r_transitive A r.

Definition mini (A : Set) (r : mRelation A) (T : mEnsemble A) 
  (e : Map A) := T e /\ (forall x : Map A, T x -> r e x).

Definition maxi (A : Set) (r : mRelation A) (T : mEnsemble A) 
  (e : Map A) := T e /\ (forall x : Map A, T x -> r x e).

Definition mLattice (A : Set) (r : mRelation A) (T : mEnsemble A)
  (e f : Map A) := r_order A r /\ mini A r T e /\ maxi A r T f.

Inductive prechain (A : Set) : Set :=
  | single : Map A -> prechain A
  | concat : prechain A -> Map A -> prechain A.

Lemma prechain_sum :
 forall (A : Set) (p : prechain A),
 (exists x : Map A, p = single A x) \/
 (exists x : Map A, (exists y : prechain A, p = concat A y x)).

Inductive prechain_dom_ok (A : Set) : mEnsemble A -> prechain A -> Prop :=
  | domok_single :
      forall (x : Map A) (T : mEnsemble A),
      T x -> prechain_dom_ok A T (single A x)
  | domok_concat :
      forall (x : Map A) (T : mEnsemble A) (p : prechain A),
      T x -> prechain_dom_ok A T p -> prechain_dom_ok A T (concat A p x).

Fixpoint chain_length (A : Set) (p : prechain A) {struct p} : nat :=
  match p with
  | single x => 1
  | concat x y => S (chain_length A x)
  end.

Definition prechain_last (A : Set) (p : prechain A) : 
  Map A := match p with
           | single x => x
           | concat z x => x
           end.

Inductive prechain_incr (A : Set) : mRelation A -> prechain A -> Prop :=
  | incr_single :
      forall (x : Map A) (r : mRelation A), prechain_incr A r (single A x)
  | incr_concat :
      forall (x : Map A) (r : mRelation A) (p : prechain A),
      r (prechain_last A p) x ->
      prechain_incr A r p -> prechain_incr A r (concat A p x).

Inductive chain (A : Set) :
mEnsemble A -> mRelation A -> prechain A -> Prop :=
  | chain_single :
      forall (x : Map A) (T : mEnsemble A) (r : mRelation A),
      T x -> chain A T r (single A x)
  | chain_concat_s :
      forall (x y : Map A) (T : mEnsemble A) (r : mRelation A),
      T x -> T y -> r x y -> chain A T r (concat A (single A x) y)
  | chain_concat_m :
      forall (x y : Map A) (z : prechain A) (T : mEnsemble A)
        (r : mRelation A),
      T y ->
      r x y ->
      chain A T r (concat A z x) -> chain A T r (concat A (concat A z x) y).

Lemma chain_def_ok :
 forall (A : Set) (T : mEnsemble A) (r : mRelation A) (p : prechain A),
 chain A T r p -> prechain_dom_ok A T p.

Lemma chain_incr :
 forall (A : Set) (T : mEnsemble A) (r : mRelation A) (p : prechain A),
 chain A T r p -> prechain_incr A r p.

Definition pre_domok_incr_chain_def (A : Set) (p : prechain A) :=
  forall (T : mEnsemble A) (r : mRelation A),
  prechain_dom_ok A T p /\ prechain_incr A r p -> chain A T r p.

Lemma pre_domok_incr_chain_0 :
 forall (A : Set) (m : Map A), pre_domok_incr_chain_def A (single A m).

Lemma pre_domok_incr_chain_1 :
 forall (A : Set) (p : prechain A),
 pre_domok_incr_chain_def A p ->
 forall m : Map A, pre_domok_incr_chain_def A (concat A p m).

Lemma pre_domok_incr_chain_2 :
 forall (A : Set) (p : prechain A), pre_domok_incr_chain_def A p.

Lemma pre_domok_incr_chain :
 forall (A : Set) (p : prechain A) (T : mEnsemble A) (r : mRelation A),
 prechain_dom_ok A T p /\ prechain_incr A r p -> chain A T r p.

Inductive dist_chain (A : Set) : prechain A -> Prop :=
  | dist_single : forall x : Map A, dist_chain A (single A x)
  | dist_concat_s :
      forall x y : Map A, x <> y -> dist_chain A (concat A (single A x) y)
  | dist_concat_m :
      forall (x y : Map A) (z : prechain A),
      x <> y ->
      dist_chain A (concat A z x) -> dist_chain A (concat A (concat A z x) y).

Inductive non_dist_chain (A : Set) : prechain A -> Prop :=
  | non_dist_concat_s :
      forall x : Map A, non_dist_chain A (concat A (single A x) x)
  | non_dist_concat_m_hd :
      forall (x : Map A) (z : prechain A),
      non_dist_chain A (concat A (concat A z x) x)
  | non_dist_concat_m_tl :
      forall (x y : Map A) (z : prechain A),
      non_dist_chain A (concat A z x) ->
      non_dist_chain A (concat A (concat A z x) y).

Definition sas_chain (A : Set) (T : mEnsemble A) (r : mRelation A)
  (p : prechain A) : Prop := chain A T r p /\ dist_chain A p.

Definition dist_compl_def_0 (A : Set) (p : prechain A) : Prop :=
  dist_chain A p \/ non_dist_chain A p.

Lemma dist_compl_0 :
 forall (A : Set) (m : Map A), dist_compl_def_0 A (single A m).

Definition dist_compl_def_1 (A : Set) (p : prechain A) : Prop :=
  dist_compl_def_0 A p -> forall m : Map A, dist_compl_def_0 A (concat A p m).

Lemma dist_compl_1 :
 forall (A : Set) (m : Map A), dist_compl_def_1 A (single A m).

Lemma dist_compl_2 :
 forall (A : Set) (p : prechain A),
 dist_compl_def_1 A p -> forall m : Map A, dist_compl_def_1 A (concat A p m).

Lemma dist_compl_3 :
 forall (A : Set) (p : prechain A),
 dist_compl_def_0 A p -> forall m : Map A, dist_compl_def_0 A (concat A p m).

Lemma dist_compl_4 :
 forall (A : Set) (p : prechain A), dist_chain A p \/ non_dist_chain A p.

Lemma dist_compl_5 :
 forall (A : Set) (x : Map A), ~ dist_chain A (concat A (single A x) x).

Lemma dist_compl_6 :
 forall (A : Set) (x : Map A) (z : prechain A),
 ~ dist_chain A (concat A (concat A z x) x).

Lemma dist_compl_7 :
 forall (A : Set) (x y : Map A) (z : prechain A),
 non_dist_chain A (concat A z x) ->
 ~ dist_chain A (concat A z x) -> ~ dist_chain A (concat A (concat A z x) y).

Lemma dist_compl_8 :
 forall (A : Set) (p : prechain A), non_dist_chain A p -> ~ dist_chain A p.

Lemma dist_compl :
 forall (A : Set) (p : prechain A), ~ dist_chain A p <-> non_dist_chain A p.

Definition bounded_sas_chain (A : Set) (T : mEnsemble A) 
  (r : mRelation A) (n : nat) : Prop :=
  forall p : prechain A, sas_chain A T r p -> chain_length A p <= n.

Definition def_ok_app (A : Set) (T : mEnsemble A) (f : Map A -> Map A) :
  Prop := forall x : Map A, T x -> T (f x).

Definition increasing_app (A : Set) (r : mRelation A) 
  (f : Map A -> Map A) : Prop := forall x y : Map A, r x y -> r (f x) (f y).

Definition fix_point (A : Set) (T : mEnsemble A) (f : Map A -> Map A)
  (x : Map A) : Prop := T x /\ f x = x.

Definition inf_fix_points (A : Set) (T : mEnsemble A) 
  (r : mRelation A) (f : Map A -> Map A) (x : Map A) : Prop :=
  forall y : Map A, fix_point A T f y -> r x y.

Definition lower_fix_point (A : Set) (T : mEnsemble A) 
  (r : mRelation A) (f : Map A -> Map A) (x : Map A) : Prop :=
  fix_point A T f x /\ inf_fix_points A T r f x.

Fixpoint iteres (A : Set) (f : Map A -> Map A) (x : Map A) 
 (n : nat) {struct n} : prechain A :=
  match n with
  | O => single A x
  | S p =>
      match iteres A f x p with
      | single y => concat A (single A y) (f y)
      | concat z y => concat A (concat A z y) (f y)
      end
  end.

Fixpoint power (A : Set) (f : A -> A) (x : A) (n : nat) {struct n} : A :=
  match n with
  | O => x
  | S n => f (power A f x n)
  end.

Inductive MapFlag (A : Set) : Set :=
  | flag_true : Map A -> MapFlag A
  | flag_false : Map A -> MapFlag A.

Lemma MapFlag_sum :
 forall (A : Set) (f : MapFlag A),
 exists x : Map A, f = flag_true A x \/ f = flag_false A x.

Fixpoint lazy_power_aux (A : Set) (egalite : Map A -> Map A -> bool)
 (f : Map A -> Map A) (x : Map A) (n : nat) {struct n} : 
 MapFlag A :=
  match n with
  | O => flag_false A x
  | S p =>
      match lazy_power_aux A egalite f x p with
      | flag_true y => flag_true A y
      | flag_false y =>
          match f y with
          | z => if egalite y z then flag_true A y else flag_false A z
          end
      end
  end.

Definition lazy_power (A : Set) (egalite : Map A -> Map A -> bool)
  (f : Map A -> Map A) (x : Map A) (n : nat) : Map A :=
  match lazy_power_aux A egalite f x n with
  | flag_false z => z
  | flag_true z => z
  end.
 
Lemma lazy_power_eg_power_0 :
 forall (A : Set) (egalite : Map A -> Map A -> bool) 
   (f : Map A -> Map A) (x : Map A) (n : nat),
 (forall a b : Map A, egalite a b = true <-> a = b) ->
 forall z : Map A,
 (lazy_power_aux A egalite f x n = flag_true A z ->
  z = power (Map A) f x n /\ z = f z) /\
 (lazy_power_aux A egalite f x n = flag_false A z -> z = power (Map A) f x n).

Lemma lazy_power_eg_power :
 forall (A : Set) (egalite : Map A -> Map A -> bool) 
   (f : Map A -> Map A) (x : Map A) (n : nat),
 (forall a b : Map A, egalite a b = true <-> a = b) ->
 lazy_power A egalite f x n = power (Map A) f x n.

Fixpoint iteres_0 (A : Set) (f : Map A -> Map A) (x : Map A) 
 (n : nat) {struct n} : prechain A :=
  match n with
  | O => single A x
  | S p =>
      match iteres_0 A f x p with
      | single y => concat A (single A y) (power (Map A) f x (S p))
      | concat z y => concat A (concat A z y) (power (Map A) f x (S p))
      end
  end.

Lemma iteres_eq_0 :
 forall (A : Set) (f : Map A -> Map A) (x : Map A) (n : nat),
 prechain_last A (iteres A f x n) = power (Map A) f x n.

Lemma iteres_eq :
 forall (A : Set) (f : Map A -> Map A) (x : Map A) (n : nat),
 iteres A f x n = iteres_0 A f x n.

Lemma iteres_def_ok :
 forall (A : Set) (T : mEnsemble A) (f : Map A -> Map A) 
   (x : Map A) (n k : nat),
 def_ok_app A T f -> T (power (Map A) f x n) -> T (power (Map A) f x (n + k)).

Lemma power_def_ok :
 forall (A : Set) (T : mEnsemble A) (f : Map A -> Map A) 
   (x : Map A) (n : nat), def_ok_app A T f -> T x -> T (power (Map A) f x n).

Definition iteres_ult_const_def_0 (A : Set) (p : prechain A) : Prop :=
  forall (f : Map A -> Map A) (x : Map A) (n : nat),
  p = iteres A f x n ->
  non_dist_chain A p ->
  exists q : nat, S q <= n /\ power (Map A) f x q = power (Map A) f x (S q).

Lemma iteres_ult_const_0 :
 forall (A : Set) (x : Map A),
 iteres_ult_const_def_0 A (concat A (single A x) x).

Lemma iteres_ult_const_1 :
 forall (A : Set) (x : Map A) (z : prechain A),
 iteres_ult_const_def_0 A (concat A (concat A z x) x).

Lemma iteres_ult_const_2 :
 forall (A : Set) (x y : Map A) (z : prechain A),
 non_dist_chain A (concat A z x) ->
 iteres_ult_const_def_0 A (concat A z x) ->
 iteres_ult_const_def_0 A (concat A (concat A z x) y).

Lemma iteres_ult_const_3 :
 forall (A : Set) (p : prechain A),
 non_dist_chain A p -> iteres_ult_const_def_0 A p.

Lemma iteres_ult_const_4 :
 forall (A : Set) (f : Map A -> Map A) (x : Map A) (n : nat),
 non_dist_chain A (iteres A f x n) ->
 exists p : nat, S p <= n /\ power (Map A) f x p = power (Map A) f x (S p).

Lemma iteres_last :
 forall (A : Set) (f : Map A -> Map A) (x : Map A) 
   (n : nat) (y : prechain A) (z : Map A),
 iteres A f x n = concat A y z -> z = f (prechain_last A y).

Lemma iteres_dom_ok :
 forall (A : Set) (T : mEnsemble A) (f : Map A -> Map A) 
   (x : Map A) (n : nat),
 T x -> def_ok_app A T f -> prechain_dom_ok A T (iteres A f x n).

Lemma iteres_incr :
 forall (A : Set) (r : mRelation A) (f : Map A -> Map A) 
   (x : Map A) (n : nat),
 r x (f x) -> increasing_app A r f -> prechain_incr A r (iteres A f x n).

Lemma iteres_increasing_chain :
 forall (A : Set) (T : mEnsemble A) (r : mRelation A) 
   (f : Map A -> Map A) (x : Map A) (n : nat),
 T x ->
 def_ok_app A T f ->
 increasing_app A r f -> r x (f x) -> chain A T r (iteres A f x n).

Lemma iteres_length :
 forall (A : Set) (f : Map A -> Map A) (x : Map A) (n : nat),
 chain_length A (iteres A f x n) = S n.

Lemma iteres_non_sas_chain :
 forall (A : Set) (T : mEnsemble A) (r : mRelation A) 
   (f : Map A -> Map A) (x : Map A) (n m : nat),
 T x ->
 def_ok_app A T f ->
 increasing_app A r f ->
 r x (f x) ->
 bounded_sas_chain A T r m ->
 m <= n -> chain A T r (iteres A f x n) /\ ~ dist_chain A (iteres A f x n).

Lemma iteres_non_sas_chain_fp_0 :
 forall (A : Set) (T : mEnsemble A) (r : mRelation A) 
   (f : Map A -> Map A) (x : Map A) (n m : nat),
 T x ->
 def_ok_app A T f ->
 increasing_app A r f ->
 r x (f x) ->
 bounded_sas_chain A T r m ->
 m <= n ->
 exists p : nat, S p <= n /\ power (Map A) f x p = power (Map A) f x (S p).

Lemma iteres_non_sas_chain_fp_1 :
 forall (A : Set) (T : mEnsemble A) (f : Map A -> Map A) 
   (x : Map A) (k p : nat),
 def_ok_app A T f ->
 fix_point A T f (power (Map A) f x p) ->
 fix_point A T f (power (Map A) f x (p + k)).

Lemma iteres_non_sas_chain_fp_2 :
 forall (A : Set) (T : mEnsemble A) (r : mRelation A) 
   (f : Map A -> Map A) (x : Map A) (n m : nat),
 T x ->
 def_ok_app A T f ->
 increasing_app A r f ->
 r x (f x) ->
 bounded_sas_chain A T r m -> m <= n -> fix_point A T f (power (Map A) f x n).

Lemma iteres_inf_fps :
 forall (A : Set) (T : mEnsemble A) (r : mRelation A) 
   (f : Map A -> Map A) (e x : Map A) (n : nat),
 mini A r T e ->
 fix_point A T f x -> increasing_app A r f -> r (power (Map A) f e n) x.

Lemma iteres_lower_fix_point :
 forall (A : Set) (T : mEnsemble A) (r : mRelation A) 
   (f : Map A -> Map A) (e : Map A) (n m : nat),
 mini A r T e ->
 def_ok_app A T f ->
 increasing_app A r f ->
 bounded_sas_chain A T r m ->
 m <= n -> lower_fix_point A T r f (power (Map A) f e n).

Definition leb (b0 b1 : bool) : Prop :=
  match b0, b1 with
  | false, false => True
  | false, true => True
  | true, false => False
  | true, true => True
  end.

Lemma leb_reflexive : forall b : bool, leb b b.

Lemma leb_antisymmetric : forall b c : bool, leb b c -> leb c b -> b = c.

Lemma leb_transitive : forall a b c : bool, leb a b -> leb b c -> leb a c.

Fixpoint lem (m0 m1 : Map bool) {struct m1} : Prop :=
  match m0, m1 with
  | M0, M0 => True
  | M0, M1 _ _ => False
  | M0, M2 _ _ => False
  | M1 _ _, M0 => False
  | M1 a b, M1 a' b' => if Neqb a a' then leb b b' else False
  | M1 _ _, M2 _ _ => False
  | M2 _ _, M0 => False
  | M2 _ _, M1 _ _ => False
  | M2 a b, M2 c d => lem a c /\ lem b d
  end.

Lemma lem_reflexive : r_reflexive bool lem.

Lemma lem_antisymmetric : r_antisymmetric bool lem.

Lemma lem_transitive : r_transitive bool lem.

Lemma lem_order : r_order bool lem.

Definition ensemble_base (A : Set) (m : Map A) (x : Map bool) :=
  domain_equal A bool m x.

Fixpoint map_fill (A : Set) (m : Map A) {struct m} : 
 bool -> Map bool :=
  fun b : bool =>
  match m with
  | M0 => M0 bool
  | M1 a _ => M1 bool a b
  | M2 m0 m1 => M2 bool (map_fill A m0 b) (map_fill A m1 b)
  end.

Definition map_mini (A : Set) (m : Map A) : Map bool := map_fill A m false.

Definition map_maxi (A : Set) (m : Map A) : Map bool := map_fill A m true.

Lemma map_mini_appartient :
 forall (A : Set) (x : Map A), ensemble_base A x (map_mini A x).

Lemma map_maxi_appartient :
 forall (A : Set) (x : Map A), ensemble_base A x (map_maxi A x).

Lemma map_mini_mini :
 forall (A : Set) (x : Map A),
 mini bool lem (ensemble_base A x) (map_mini A x).

Lemma map_maxi_maxi :
 forall (A : Set) (x : Map A),
 maxi bool lem (ensemble_base A x) (map_maxi A x).

Lemma map_mini_mapget_false :
 forall (A : Set) (x : Map A) (a : ad) (b : bool),
 MapGet bool (map_mini A x) a = Some b -> b = false.

Lemma map_mini_mapget_true :
 forall (A : Set) (x : Map A) (a : ad),
 MapGet bool (map_mini A x) a = Some true -> False.

Lemma mlattice :
 forall (A : Set) (x : Map A),
 mLattice bool lem (ensemble_base A x) (map_mini A x) (map_maxi A x).

Definition lattice_bounded_def_0 (p : prechain bool) : Prop :=
  forall (A : Set) (m0 m1 : Map A),
  sas_chain bool (ensemble_base A (M2 A m0 m1)) lem p ->
  exists p0 : prechain bool,
    (exists p1 : prechain bool,
       sas_chain bool (ensemble_base A m0) lem p0 /\
       sas_chain bool (ensemble_base A m1) lem p1 /\
       lem (M2 bool (prechain_last bool p0) (prechain_last bool p1))
         (prechain_last bool p) /\
       chain_length bool p0 + chain_length bool p1 = S (chain_length bool p)).

Lemma lattice_bounded_0 :
 forall m : Map bool, lattice_bounded_def_0 (single bool m).

Definition lattice_bounded_def_1 (p : prechain bool) : Prop :=
  lattice_bounded_def_0 p ->
  forall m : Map bool, lattice_bounded_def_0 (concat bool p m).

Lemma lattice_bounded_1 :
 forall m : Map bool, lattice_bounded_def_1 (single bool m).

Lemma lattice_bounded_2 :
 forall p : prechain bool,
 lattice_bounded_def_1 p ->
 forall m : Map bool, lattice_bounded_def_1 (concat bool p m).

Lemma lattice_bounded_3 :
 forall p : prechain bool,
 lattice_bounded_def_0 p ->
 forall m : Map bool, lattice_bounded_def_0 (concat bool p m).

Lemma lattice_bounded_4 : forall p : prechain bool, lattice_bounded_def_0 p.

Lemma lattice_bounded_5 :
 forall (p : prechain bool) (A : Set) (m0 m1 : Map A),
 sas_chain bool (ensemble_base A (M2 A m0 m1)) lem p ->
 exists p0 : prechain bool,
   (exists p1 : prechain bool,
      sas_chain bool (ensemble_base A m0) lem p0 /\
      sas_chain bool (ensemble_base A m1) lem p1 /\
      lem (M2 bool (prechain_last bool p0) (prechain_last bool p1))
        (prechain_last bool p) /\
      chain_length bool p0 + chain_length bool p1 = S (chain_length bool p)).

Definition lattice_bounded_def_2 (A : Set) (m : Map A) : Prop :=
  forall p : prechain bool,
  sas_chain bool (ensemble_base A m) lem p ->
  chain_length bool p <= S (MapCard A m).

Lemma lattice_bounded_6 : forall A : Set, lattice_bounded_def_2 A (M0 A).

Lemma lattice_bounded_7 :
 forall (A : Set) (a : ad) (a0 : A), lattice_bounded_def_2 A (M1 A a a0).

Lemma lattice_bounded_8 :
 forall (A : Set) (m : Map A),
 lattice_bounded_def_2 A m ->
 forall m0 : Map A,
 lattice_bounded_def_2 A m0 -> lattice_bounded_def_2 A (M2 A m m0).

Lemma lattice_bounded_9 :
 forall (A : Set) (m : Map A), lattice_bounded_def_2 A m.

Lemma lattice_bounded_10 :
 forall (A : Set) (m : Map A) (p : prechain bool),
 sas_chain bool (ensemble_base A m) lem p ->
 chain_length bool p <= S (MapCard A m).

Lemma lattice_bounded :
 forall (A : Set) (x : Map A),
 bounded_sas_chain bool (ensemble_base A x) lem (S (MapCard A x)).

Definition eq_bool (b0 b1 : bool) : bool :=
  match b0, b1 with
  | false, false => true
  | false, true => false
  | true, false => false
  | true, true => true
  end.

Lemma eq_bool_equal : forall b0 b1 : bool, eq_bool b0 b1 = true -> b0 = b1.

Lemma equal_eq_bool : forall b : bool, eq_bool b b = true.

Fixpoint eqm_bool (x y : Map bool) {struct y} : bool :=
  match x, y with
  | M0, M0 => true
  | M0, M1 _ _ => false
  | M0, M2 _ _ => false
  | M1 _ _, M0 => false
  | M1 a b, M1 c d => Neqb a c && eq_bool b d
  | M1 _ _, M2 _ _ => false
  | M2 _ _, M0 => false
  | M2 _ _, M1 _ _ => false
  | M2 a b, M2 c d => eqm_bool a c && eqm_bool b d
  end.

Lemma eqm_bool_equal : forall x y : Map bool, eqm_bool x y = true -> x = y.

Lemma equal_eqm_bool : forall x : Map bool, eqm_bool x x = true.

Lemma lem_get_leb :
 forall (m0 m1 : Map bool) (a : ad) (b0 b1 : bool),
 lem m0 m1 ->
 MapGet bool m0 a = Some b0 ->
 MapGet bool m1 a = Some b1 -> leb b0 b1.

Lemma lem_domain_equal :
 forall m0 m1 : Map bool, lem m0 m1 -> domain_equal bool bool m0 m1.

Lemma andb_inc_r :
 forall b b0 b1 : bool, leb b0 b1 -> leb (b && b0) (b && b1).

Lemma andb_inc_l :
 forall b b0 b1 : bool, leb b0 b1 -> leb (b0 && b) (b1 && b).

Lemma orb_inc_r : forall b b0 b1 : bool, leb b0 b1 -> leb (b || b0) (b || b1).

Lemma orb_inc_l : forall b b0 b1 : bool, leb b0 b1 -> leb (b0 || b) (b1 || b).

Lemma andb_incr :
 forall b0 b1 b2 b3 : bool,
 leb b0 b1 -> leb b2 b3 -> leb (b0 && b2) (b1 && b3).

Lemma orb_incr :
 forall b0 b1 b2 b3 : bool,
 leb b0 b1 -> leb b2 b3 -> leb (b0 || b2) (b1 || b3). *)

Inductive coacc : preDTA -> ad -> ad -> Prop :=
  | coacc_id :
      forall (d : preDTA) (a : ad) (s : state),
      MapGet state d a = Some s -> coacc d a a
  | coacc_nxt :
      forall (d : preDTA) (a0 a1 a2 : ad) (s1 s2 : state) 
        (pl : prec_list) (c : ad),
      MapGet state d a2 = Some s2 ->
      MapGet state d a1 = Some s1 ->
      MapGet prec_list s1 c = Some pl ->
      prec_occur pl a2 -> coacc d a0 a1 -> coacc d a0 a2.

Definition coacc_transitive_def (d : preDTA) (a0 a1 : ad) : Prop :=
  forall a2 : ad, coacc d a0 a1 -> coacc d a2 a0 -> coacc d a2 a1.

Lemma coacc_transitive_0 :
 forall (d : preDTA) (a : ad) (s : state),
 MapGet state d a = Some s -> coacc_transitive_def d a a.
Proof.
	unfold coacc_transitive_def in |- *. intros. exact H1.
Qed.

Lemma coacc_transitive_1 :
 forall (d : preDTA) (a0 a1 a2 : ad) (s1 s2 : state) 
   (pl : prec_list) (c : ad),
 MapGet state d a2 = Some s2 ->
 MapGet state d a1 = Some s1 ->
 MapGet prec_list s1 c = Some pl ->
 prec_occur pl a2 ->
 coacc d a0 a1 ->
 coacc_transitive_def d a0 a1 -> coacc_transitive_def d a0 a2.
Proof.
	unfold coacc_transitive_def in |- *. intros. exact (coacc_nxt d a3 a1 a2 s1 s2 pl c H H0 H1 H2 (H4 _ H3 H6)).
Qed.

Lemma coacc_transitive :
 forall (d : preDTA) (a0 a1 a2 : ad),
 coacc d a0 a1 -> coacc d a1 a2 -> coacc d a0 a2.
Proof.
	intros. exact
  (coacc_ind coacc_transitive_def coacc_transitive_0 coacc_transitive_1 d a1
     a2 H0 a0 H0 H).
Qed.

Fixpoint map_replace (A : Set) (m : Map A) {struct m} : 
 ad -> A -> Map A :=
  fun (a : ad) (x : A) =>
  match m with
  | M0 => M0 A
  | M1 b y => if Neqb a b then M1 A b x else M1 A b y
  | M2 m n =>
      match a with
      | N0 => M2 A (map_replace A m N0 x) n
      | Npos q =>
          match q with
          | xH => M2 A m (map_replace A n N0 x)
          | xO p => M2 A (map_replace A m (Npos p) x) n
          | xI p => M2 A m (map_replace A n (Npos p) x)
          end
      end
  end.

Fixpoint map_or (m0 m1 : Map bool) {struct m1} : Map bool :=
  match m0, m1 with
  | M0, _ => M0 bool
  | _, M0 => M0 bool
  | M1 a0 b0, M1 a1 b1 =>
      if Neqb a0 a1 then M1 bool a0 (b0 || b1) else M0 bool
  | M1 _ _, M2 _ _ => M0 bool
  | M2 _ _, M1 _ _ => M0 bool
  | M2 x0 y0, M2 x1 y1 => M2 bool (map_or x0 x1) (map_or y0 y1)
  end.

Fixpoint pl_coacc (d : preDTA) (pl : prec_list) {struct pl} : 
 Map bool :=
  match pl with
  | prec_empty => map_mini state d
  | prec_cons a la ls =>
      map_replace bool (map_or (pl_coacc d la) (pl_coacc d ls)) a true
  end.

Fixpoint st_coacc (d : preDTA) (s : state) {struct s} : 
 Map bool :=
  match s with
  | M0 => map_mini state d
  | M1 a pl => pl_coacc d pl
  | M2 x y => map_or (st_coacc d x) (st_coacc d y)
  end.

Fixpoint predta_coacc_0 (d d' : preDTA) {struct d'} : 
 Map bool -> Map bool :=
  fun m : Map bool =>
  match d', m with
  | M0, M0 => map_mini state d
  | M1 a s, M1 a' b =>
      if Neqb a a' && b then st_coacc d s else map_mini state d
  | M2 x y, M2 z t => map_or (predta_coacc_0 d x z) (predta_coacc_0 d y t)
  | _, _ => map_mini state d
  end.

Definition predta_coacc (d : preDTA) (a : ad) (m : Map bool) : 
  Map bool := map_replace bool (predta_coacc_0 d d m) a true.

Definition predta_coacc_states (d : preDTA) (a : ad) : 
  Map bool :=
  power (Map bool) (predta_coacc d a) (map_mini state d)
    (S (MapCard state d)).

Definition predta_coacc_states_0 (d : preDTA) (a : ad) : 
  Map bool :=
  lazy_power bool eqm_bool (predta_coacc d a) (map_mini state d)
    (S (MapCard state d)).

Lemma map_or_mapget_true_l :
 forall (m0 m1 : Map bool) (a : ad),
 domain_equal bool bool m0 m1 ->
 MapGet bool m0 a = Some true ->
 MapGet bool (map_or m0 m1) a = Some true.
Proof.
	simple induction m0. intros. inversion H0. simple induction m1.
	intros. inversion H. intros. simpl in H. simpl in H0.
	elim (bool_is_true_or_false (Neqb a a3)); intros; rewrite H1 in H0. inversion H0. rewrite <- (Neqb_complete _ _ H1). rewrite <- H. simpl in |- *. rewrite (Neqb_correct a).
	simpl in |- *. rewrite (Neqb_correct a). reflexivity. inversion H0.
	intros. inversion H1. simple induction m2. intros. inversion H1.
	intros. inversion H1. intros. simpl in |- *. elim H3; intros.
	induction  a as [| p]. exact (H _ _ H5 H4). induction  p as [p Hrecp| p Hrecp| ]. exact (H0 _ _ H6 H4). exact (H _ _ H5 H4). exact (H0 _ _ H6 H4).
Qed.

Lemma map_or_mapget_true_ld :
 forall (d : preDTA) (m0 m1 : Map bool) (a : ad),
 ensemble_base state d m0 ->
 ensemble_base state d m1 ->
 MapGet bool m0 a = Some true ->
 MapGet bool (map_or m0 m1) a = Some true.
Proof.
	intros. exact
  (map_or_mapget_true_l m0 m1 a
     (domain_equal_transitive bool state bool m0 d m1
        (domain_equal_symmetric state bool d m0 H) H0) H1).
Qed.

Lemma map_or_mapget_true_r :
 forall (m0 m1 : Map bool) (a : ad),
 domain_equal bool bool m0 m1 ->
 MapGet bool m0 a = Some true ->
 MapGet bool (map_or m1 m0) a = Some true.
Proof.
	simple induction m0. intros. inversion H0. simple induction m1; intros.
	inversion H. simpl in H. simpl in H0. rewrite <- H.
	elim (bool_is_true_or_false (Neqb a a3)); intros; rewrite H1 in H0;
  inversion H0. rewrite <- (Neqb_complete _ _ H1). simpl in |- *. rewrite (Neqb_correct a). simpl in |- *.
	rewrite (Neqb_correct a). elim (bool_is_true_or_false a2); intros; rewrite H2; reflexivity. inversion H1. intros.
	induction  m2 as [| a0 a1| m2_1 Hrecm2_1 m2_0 Hrecm2_0]. inversion H1. inversion H1. simpl in |- *.
	elim H1; intros. induction  a as [| p]. exact (H _ _ H3 H2).
	induction  p as [p Hrecp| p Hrecp| ]. exact (H0 _ _ H4 H2). exact (H _ _ H3 H2).
	exact (H0 _ _ H4 H2).
Qed.

Lemma map_or_mapget_true_rd :
 forall (d : preDTA) (m0 m1 : Map bool) (a : ad),
 ensemble_base state d m0 ->
 ensemble_base state d m1 ->
 MapGet bool m1 a = Some true ->
 MapGet bool (map_or m0 m1) a = Some true.
Proof.
	intros. exact
  (map_or_mapget_true_r m1 m0 a
     (domain_equal_transitive bool state bool m1 d m0
        (domain_equal_symmetric state bool d m1 H0) H) H1).
Qed.

Lemma map_or_mapget_true_inv :
 forall (m0 m1 : Map bool) (a : ad),
 MapGet bool (map_or m0 m1) a = Some true ->
 MapGet bool m0 a = Some true \/ MapGet bool m1 a = Some true.
Proof.
	simple induction m0; intros. induction  m1 as [| a0 a1| m1_1 Hrecm1_1 m1_0 Hrecm1_0]. simpl in H. inversion H.
	simpl in H. inversion H. simpl in H. inversion H. induction  m1 as [| a2 a3| m1_1 Hrecm1_1 m1_0 Hrecm1_0]. simpl in H. inversion H. simpl in H. elim (bool_is_true_or_false (Neqb a a2)); intros; rewrite H0 in H.
	simpl in H. elim (bool_is_true_or_false (Neqb a a1)); intros; rewrite H1 in H;
  inversion H. rewrite H3. elim (bool_is_true_or_false a0); intros; rewrite H2 in H3; rewrite H2. left. rewrite <- (Neqb_complete _ _ H1). simpl in |- *.
	rewrite (Neqb_correct a). reflexivity. elim (bool_is_true_or_false a3); intros; rewrite H4 in H3; rewrite H4.
	right. rewrite <- (Neqb_complete _ _ H0). rewrite <- (Neqb_complete _ _ H1). simpl in |- *. rewrite (Neqb_correct a).
	reflexivity. inversion H3. inversion H. inversion H.
	induction  m2 as [| a0 a1| m2_1 Hrecm2_1 m2_0 Hrecm2_0]. inversion H1. inversion H1. simpl in H1.
	induction  a as [| p]. elim (H _ _ H1). intros. left. simpl in |- *. assumption.
	intros. right. simpl in |- *. assumption. induction  p as [p Hrecp| p Hrecp| ]. elim (H0 _ _ H1); intros; simpl in |- *. left. assumption. right. assumption.
	elim (H _ _ H1); intros; simpl in |- *. left. assumption. right.
	assumption. elim (H0 _ _ H1); intros; simpl in |- *. left. assumption.
	right. assumption.
Qed.

Lemma map_replace_mapget_ins_true_0 :
 forall (m : Map bool) (a : ad) (b : bool),
 MapGet bool m a = Some b ->
 MapGet bool (map_replace bool m a true) a = Some true.
Proof.
	simple induction m. intros. inversion H. intros. simpl in H.
	elim (bool_is_true_or_false (Neqb a a1)); intros; rewrite H0 in H;
  inversion H. simpl in |- *. rewrite <- (Neqb_complete _ _ H0). rewrite (Neqb_correct a).
	simpl in |- *. rewrite (Neqb_correct a). reflexivity. intros.
	induction  a as [| p]; simpl in H1. simpl in |- *. exact (H _ _ H1).
	induction  p as [p Hrecp| p Hrecp| ]; simpl in |- *. exact (H0 _ _ H1). exact (H _ _ H1). exact (H0 _ _ H1).
Qed.

Lemma map_replace_mapget_ins_true_1 :
 forall (m : Map bool) (a a' : ad),
 MapGet bool m a = Some true ->
 MapGet bool (map_replace bool m a' true) a = Some true.
Proof.
	simple induction m. intros. inversion H. intros. simpl in H.
	elim (bool_is_true_or_false (Neqb a a1)); intros; rewrite H0 in H. inversion H. simpl in |- *. elim (bool_is_true_or_false (Neqb a' a)); intros; rewrite H1.
	simpl in |- *. rewrite H0. reflexivity. simpl in |- *. rewrite H0.
	reflexivity. inversion H. intros. induction  a as [| p]; simpl in H1; simpl in |- *. induction  a' as [| p]. simpl in |- *. exact (H _ _ H1).
	induction  p as [p Hrecp| p Hrecp| ]. simpl in |- *. exact H1. exact (H _ _ H1). exact H1.
	induction  p as [p Hrecp| p Hrecp| ]. induction  a' as [| p0]; simpl in |- *. exact H1. induction  p0 as [p0 Hrecp0| p0 Hrecp0| ]; simpl in |- *. exact (H0 _ _ H1). exact H1. exact (H0 _ _ H1).
	induction  a' as [| p0]; simpl in |- *. exact (H _ _ H1). induction  p0 as [p0 Hrecp0| p0 Hrecp0| ]; simpl in |- *. exact H1. exact (H _ _ H1). exact H1. induction  a' as [| p]; simpl in |- *. exact H1. induction  p as [p Hrecp| p Hrecp| ]; simpl in |- *. exact (H0 _ _ H1). exact H1. exact (H0 _ _ H1).
Qed.

Lemma map_replace_mapget_true_inv :
 forall (m : Map bool) (a b : ad),
 MapGet bool (map_replace bool m a true) b = Some true ->
 b = a \/ MapGet bool m b = Some true.
Proof.
	simple induction m. intros. inversion H. simpl in |- *. intros. elim (bool_is_true_or_false (Neqb a1 a)); intros; rewrite H0 in H. simpl in H. elim (bool_is_true_or_false (Neqb a b)); intros; rewrite H1 in H. rewrite H1. left.
	rewrite (Neqb_complete _ _ H0). rewrite <- (Neqb_complete _ _ H1). reflexivity. inversion H. simpl in H. elim (bool_is_true_or_false (Neqb a b)); intros; rewrite H1 in H;
  inversion H. rewrite H1. right. reflexivity. intros.
	simpl in H1. induction  a as [| p]; simpl in H1. induction  b as [| p]; simpl in |- *; simpl in H1. exact (H _ _ H1). induction  p as [p Hrecp| p Hrecp| ]. right. exact H1.
	elim (H _ _ H1). intros. inversion H2. intros. right.
	exact H2. right. exact H1. induction  p as [p Hrecp| p Hrecp| ]. induction  b as [| p0].
	simpl in |- *. simpl in H1. right. exact H1. simpl in H1. 
	induction  p0 as [p0 Hrecp0| p0 Hrecp0| ]. elim (H0 _ _ H1). intros. inversion H2.
	left. reflexivity. intros. simpl in |- *. right. exact H2. simpl in |- *.
	right. exact H1. elim (H0 _ _ H1). intros. inversion H2.
	intros. simpl in |- *. right. exact H2. induction  b as [| p0]; simpl in |- *; simpl in H1. elim (H _ _ H1). intros. inversion H2.
	right. exact H2. induction  p0 as [p0 Hrecp0| p0 Hrecp0| ]. right. exact H1. elim (H _ _ H1). intros. inversion H2. left. reflexivity.
	intros. right. exact H2. right. exact H1. induction  b as [| p].
	simpl in H1. simpl in |- *. right. exact H1. induction  p as [p Hrecp| p Hrecp| ]; simpl in |- *; simpl in H1. elim (H0 _ _ H1). intros. inversion H2.
	intros. right. exact H2. right. exact H1. left. reflexivity.
Qed.

Lemma map_or_def_ok :
 forall m0 m1 : Map bool,
 domain_equal bool bool m0 m1 -> domain_equal bool bool m0 (map_or m0 m1).
Proof.
	simple induction m0. simple induction m1. intros. exact I. intros. inversion H.
	intros. inversion H1. simple induction m1. intros. inversion H. intros.
	simpl in H. simpl in |- *. rewrite H. rewrite (Neqb_correct a1). simpl in |- *.
	reflexivity. intros. inversion H1. simple induction m2. intros. inversion H1.
	intros. inversion H1. intros. elim H3. intros. simpl in |- *. split.
	exact (H _ H4). exact (H0 _ H5).
Qed.

Lemma map_or_def_ok_d :
 forall (d : preDTA) (m0 m1 : Map bool),
 ensemble_base state d m0 ->
 ensemble_base state d m1 -> ensemble_base state d (map_or m0 m1).
Proof.
	unfold ensemble_base in |- *. intros. apply (domain_equal_transitive state bool bool d m0 (map_or m0 m1)). exact H. apply (map_or_def_ok m0 m1). apply (domain_equal_transitive bool state bool m0 d m1).
	exact (domain_equal_symmetric state bool d m0 H). exact H0.
Qed.

Lemma map_replace_def_ok :
 forall (A : Set) (m : Map A) (a : ad) (x : A),
 domain_equal A A m (map_replace A m a x).
Proof.
	intro. simple induction m. intros. exact I. intros. simpl in |- *. elim (bool_is_true_or_false (Neqb a1 a)); intros; rewrite H.
	simpl in |- *. reflexivity. simpl in |- *. reflexivity. intros. simpl in |- *.
	induction  a as [| p]. simpl in |- *. split. exact (H N0 x). exact (domain_equal_reflexive A m1). induction  p as [p Hrecp| p Hrecp| ]. split. exact (domain_equal_reflexive A m0). exact (H0 (Npos p) x). split.
	exact (H (Npos p) x). exact (domain_equal_reflexive A m1).
	split. exact (domain_equal_reflexive A m0). exact (H0 N0 x).
Qed.

Lemma map_replace_def_ok_d :
 forall (d : preDTA) (m : Map bool) (a : ad) (x : bool),
 ensemble_base state d m -> ensemble_base state d (map_replace bool m a x).
Proof.
	unfold ensemble_base in |- *. intros. apply
  (domain_equal_transitive state bool bool d m (map_replace bool m a x) H).
	exact (map_replace_def_ok bool m a x).
Qed.

Lemma pl_coacc_def_ok :
 forall (d : preDTA) (pl : prec_list), ensemble_base state d (pl_coacc d pl).
Proof.
	simple induction pl. simpl in |- *. intros. exact
  (map_replace_def_ok_d d (map_or (pl_coacc d p) (pl_coacc d p0)) a true
     (map_or_def_ok_d _ _ _ H H0)).
	simpl in |- *. exact (map_mini_appartient state d).
Qed.

Lemma st_coacc_def_ok :
 forall (d : preDTA) (s : state), ensemble_base state d (st_coacc d s).
Proof.
	simple induction s. simpl in |- *. exact (map_mini_appartient state d). simpl in |- *.
	intros. exact (pl_coacc_def_ok d a0). intros. simpl in |- *. exact (map_or_def_ok_d _ _ _ H H0).
Qed.

Lemma predta_coacc_0_def_ok :
 forall (d d' : preDTA) (m : Map bool),
 ensemble_base state d (predta_coacc_0 d d' m).
Proof.
	simple induction d'. simpl in |- *. intros. induction  m as [| a a0| m1 Hrecm1 m0 Hrecm0];
  exact (map_mini_appartient state d). simpl in |- *. intros. induction  m as [| a1 a2| m1 Hrecm1 m0 Hrecm0].
	exact (map_mini_appartient state d). elim (bool_is_true_or_false (Neqb a a1 && a2)); intros; rewrite H. exact (st_coacc_def_ok d a0). exact (map_mini_appartient state d). exact (map_mini_appartient state d). intros. induction  m1 as [| a a0| m1_1 Hrecm1_1 m1_0 Hrecm1_0]. simpl in |- *.
	exact (map_mini_appartient state d). simpl in |- *. exact (map_mini_appartient state d). simpl in |- *. exact (map_or_def_ok_d _ _ _ (H m1_1) (H0 m1_0)).
Qed.

Lemma predta_coacc_def_ok :
 forall (d : preDTA) (a : ad) (m : Map bool),
 ensemble_base state d (predta_coacc d a m).
Proof.
	unfold predta_coacc in |- *. intros. exact (map_replace_def_ok_d d _ a true (predta_coacc_0_def_ok d d m)).
Qed.

Definition lemd (d : preDTA) : mRelation bool :=
  fun m0 m1 : Map bool =>
  ensemble_base state d m0 /\ ensemble_base state d m1 /\ lem m0 m1.

Lemma lemd_reflexive :
 forall (d : preDTA) (m : Map bool), ensemble_base state d m -> lemd d m m.
Proof.
	unfold ensemble_base in |- *. simple induction d. intros. unfold lemd in |- *.
	unfold ensemble_base in |- *. induction  m as [| a a0| m1 Hrecm1 m0 Hrecm0]. split. exact I.
	split; exact I. inversion H. inversion H. intros.
	unfold lemd in |- *. unfold ensemble_base in |- *. induction  m as [| a1 a2| m1 Hrecm1 m0 Hrecm0]. inversion H.
	simpl in H. rewrite H. simpl in |- *. split. reflexivity. split.
	reflexivity. rewrite (Neqb_correct a1). exact (leb_reflexive a2). inversion H. unfold lemd in |- *. unfold ensemble_base in |- *.
	simple induction m1. intros. inversion H1. intros. inversion H1.
 	intros. elim H3. intros. elim (H _ H4). elim (H0 _ H5).
	intros. split; split. exact H4. exact H5. split. exact H4.
	exact H5. split. elim H9. intros. exact H11. elim H7.
	intros. exact H11.
Qed.

Lemma lemd_antisymmetric :
 forall (d : preDTA) (m0 m1 : Map bool),
 lemd d m0 m1 -> lemd d m1 m0 -> m0 = m1.
Proof.
	unfold lemd in |- *. unfold ensemble_base in |- *. simple induction d. simple induction m0.
	intros. elim H. intros. elim H0. intros. elim H4. intros.
	induction  m1 as [| a a0| m1_1 Hrecm1_1 m1_0 Hrecm1_0]. reflexivity. inversion H6. inversion H6.
	intros. elim H0. intros. elim H2. intros. decompose [and] H.
	induction  m1 as [| a1 a2| m1_1 Hrecm1_1 m1_0 Hrecm1_0]. inversion H8. inversion H5. inversion H8.
	intros. decompose [and] H1.  inversion H3. intros.
	decompose [and] H. decompose [and] H0. induction  m0 as [| a1 a2| m0_1 Hrecm0_1 m0_0 Hrecm0_0].
	inversion H1. induction  m1 as [| a3 a4| m1_1 Hrecm1_1 m1_0 Hrecm1_0]. inversion H3. simpl in H1.
	simpl in H2. rewrite <- H1. rewrite <- H2. simpl in H4.
	simpl in H7. rewrite <- H2 in H4. rewrite <- H1 in H4.
	rewrite (Neqb_correct a) in H4. rewrite <- H1 in H7.
	rewrite <- H2 in H7. rewrite (Neqb_correct a) in H7.
	rewrite (leb_antisymmetric _ _ H4 H7). reflexivity.
	inversion H2. inversion H1. intros. decompose [and] H1.
	decompose [and] H2. induction  m1 as [| a a0| m1_1 Hrecm1_1 m1_0 Hrecm1_0]. inversion H3. inversion H3.
	induction  m2 as [| a a0| m2_1 Hrecm2_1 m2_0 Hrecm2_0]. inversion H4. inversion H9. elim H4. elim H3.
	elim H6. intros. rewrite (H m1_1 m2_1). rewrite (H0 m1_0 m2_0). reflexivity. split. exact H12. split. exact H14.
	exact H10. split. exact H14. split. exact H12. elim H9.
	intros. exact H16. elim H9. intros. split. exact H11.
	split. exact H13. exact H7. elim H9. intros. split.
	exact H13. split. exact H11. exact H15.
Qed.

Lemma lemd_transitive :
 forall (d : preDTA) (m0 m1 m2 : Map bool),
 lemd d m0 m1 -> lemd d m1 m2 -> lemd d m0 m2.
Proof.
	simple induction d. unfold lemd in |- *. unfold ensemble_base in |- *. intros.
	decompose [and] H. decompose [and] H0. induction  m0 as [| a a0| m0_1 Hrecm0_1 m0_0 Hrecm0_0].
	induction  m1 as [| a a0| m1_1 Hrecm1_1 m1_0 Hrecm1_0]. induction  m2 as [| a a0| m2_1 Hrecm2_1 m2_0 Hrecm2_0]. split. exact I. split; exact I.
	inversion H6. inversion H7. inversion H2. inversion H2.
	inversion H1. inversion H1. unfold lemd in |- *. unfold ensemble_base in |- *.
	intros. decompose [and] H. decompose [and] H0. induction  m0 as [| a1 a2| m0_1 Hrecm0_1 m0_0 Hrecm0_0].
	inversion H1. induction  m1 as [| a3 a4| m1_1 Hrecm1_1 m1_0 Hrecm1_0]. inversion H2. induction  m2 as [| a5 a6| m2_1 Hrecm2_1 m2_0 Hrecm2_0].
	inversion H6. simpl in H2. simpl in H1. simpl in H6.
	simpl in H4. rewrite <- H2 in H4. rewrite <- H1 in H4.
	rewrite (Neqb_correct a) in H4. simpl in H7. rewrite <- H3 in H7. rewrite <- H6 in H7. rewrite (Neqb_correct a) in H7.
	rewrite <- H1. rewrite <- H6. split. simpl in |- *. reflexivity.
	simpl in |- *. split. reflexivity. rewrite (Neqb_correct a).
	exact (leb_transitive _ _ _ H4 H7). inversion H6.
	inversion H3. inversion H1. unfold lemd in |- *. unfold ensemble_base in |- *.
	intros. decompose [and] H1. decompose [and] H2. induction  m1 as [| a a0| m1_1 Hrecm1_1 m1_0 Hrecm1_0].
        inversion H3. inversion H3. clear Hrecm1_1 Hrecm1_0.
	induction  m2 as [| a a0| m2_1 Hrecm2_1 m2_0 Hrecm2_0]. inversion H5. inversion H5. clear Hrecm2_1.
	clear Hrecm2_0. intros. induction  m3 as [| a a0| m3_1 Hrecm3_1 m3_0 Hrecm3_0]. inversion H8.
	inversion H8. clear Hrecm3_1. clear Hrecm3_0. simpl in |- *.
	elim H3. elim H8. elim H6. elim H5. elim H9. intros.
	split. split. exact H17. exact H18. split. split. exact H15.
	exact H16. split. exact (lem_transitive _ _ _ H13 H7).
	exact (lem_transitive _ _ _ H14 H10).
Qed.

Lemma map_or_inc_ld :
 forall (d : preDTA) (m m0 m1 : Map bool),
 ensemble_base state d m ->
 lemd d m0 m1 -> lemd d (map_or m0 m) (map_or m1 m).
Proof.
	unfold lemd in |- *. unfold ensemble_base in |- *. simple induction d. intros.
	decompose [and] H0. induction  m as [| a a0| m2 Hrecm1 m3 Hrecm0]. induction  m0 as [| a a0| m0_1 Hrecm0_1 m0_0 Hrecm0_0]. induction  m1 as [| a a0| m1_1 Hrecm1_1 m1_0 Hrecm1_0]. simpl in |- *. split. exact I. split; exact I. inversion H3.
	inversion H3. inversion H1. inversion H1. inversion H.
	inversion H. intros. decompose [and] H0. induction  m as [| a1 a2| m2 Hrecm1 m3 Hrecm0].
	inversion H. induction  m0 as [| a3 a4| m0_1 Hrecm0_1 m0_0 Hrecm0_0]. inversion H1. induction  m1 as [| a5 a6| m1_1 Hrecm1_1 m1_0 Hrecm1_0].
	inversion H3. simpl in |- *. simpl in H1. simpl in H3. simpl in H4. simpl in H. rewrite <- H. rewrite <- H3. rewrite <- H1. rewrite (Neqb_correct a). simpl in |- *. rewrite (Neqb_correct a). split. reflexivity. split. reflexivity. rewrite <- H3 in H4. rewrite <- H1 in H4. rewrite (Neqb_correct a) in H4. exact (orb_inc_l a2 _ _ H4). inversion H4.
	inversion H1. inversion H. intros. decompose [and] H2.
	induction  m1 as [| a a0| m1_1 Hrecm1_1 m1_0 Hrecm1_0]. inversion H1. inversion H1. induction  m2 as [| a a0| m2_1 Hrecm2_1 m2_0 Hrecm2_0].
	inversion H3. inversion H3. induction  m3 as [| a a0| m3_1 Hrecm3_1 m3_0 Hrecm3_0]. inversion H5.
	inversion H5. clear Hrecm3_1 Hrecm3_0 Hrecm2_1 Hrecm2_0 Hrecm1_1 Hrecm1_0. simpl in |- *. elim H5. elim H3. elim H6.
	intros. elim H1. intros. elim (H m1_1 m2_1 m3_1).
	elim (H0 m1_0 m2_0 m3_0). intros. split. split; assumption.
	split. split. elim H17; intros. assumption. elim H15; intros; assumption. elim H15. intros. elim H17. intros.
	split; assumption. assumption. split. assumption. split; assumption. assumption. split. assumption. split; assumption.
Qed.

Lemma map_or_inc_rd :
 forall (d : preDTA) (m m0 m1 : Map bool),
 ensemble_base state d m ->
 lemd d m0 m1 -> lemd d (map_or m m0) (map_or m m1).
Proof.
	unfold lemd in |- *. unfold ensemble_base in |- *. simple induction d. intros.
	decompose [and] H0. induction  m as [| a a0| m2 Hrecm1 m3 Hrecm0]. induction  m0 as [| a a0| m0_1 Hrecm0_1 m0_0 Hrecm0_0]. induction  m1 as [| a a0| m1_1 Hrecm1_1 m1_0 Hrecm1_0]. simpl in |- *. split. exact I. split; exact I. inversion H3.
	inversion H3. inversion H1. inversion H1. inversion H.
	inversion H. intros. decompose [and] H0. induction  m as [| a1 a2| m2 Hrecm1 m3 Hrecm0].
	inversion H. induction  m0 as [| a3 a4| m0_1 Hrecm0_1 m0_0 Hrecm0_0]. inversion H1. induction  m1 as [| a5 a6| m1_1 Hrecm1_1 m1_0 Hrecm1_0].
	inversion H3. simpl in |- *. simpl in H1. simpl in H3. simpl in H4. simpl in H. rewrite <- H. rewrite <- H3. rewrite <- H1. rewrite (Neqb_correct a). simpl in |- *. rewrite (Neqb_correct a). split. reflexivity. split. reflexivity. rewrite <- H3 in H4. rewrite <- H1 in H4. rewrite (Neqb_correct a) in H4. exact (orb_inc_r a2 _ _ H4). inversion H4.
	inversion H1. inversion H. intros. decompose [and] H2.
	induction  m1 as [| a a0| m1_1 Hrecm1_1 m1_0 Hrecm1_0]. inversion H1. inversion H1. induction  m2 as [| a a0| m2_1 Hrecm2_1 m2_0 Hrecm2_0].
	inversion H3. inversion H3. induction  m3 as [| a a0| m3_1 Hrecm3_1 m3_0 Hrecm3_0]. inversion H5.
	inversion H5. clear Hrecm3_1 Hrecm3_0 Hrecm2_1 Hrecm2_0 Hrecm1_1 Hrecm1_0. simpl in |- *. elim H5. elim H3. elim H6.
	intros. elim H1. intros. elim (H m1_1 m2_1 m3_1).
	elim (H0 m1_0 m2_0 m3_0). intros. split. split; assumption.
	split. split. elim H17; intros. assumption. elim H15; intros; assumption. elim H15. intros. elim H17. intros.
	split; assumption. assumption. split. assumption. split; assumption. assumption. split. assumption. split; assumption.
Qed.

Lemma map_or_inc_d :
 forall (d : preDTA) (m0 m1 m2 m3 : Map bool),
 lemd d m0 m1 -> lemd d m2 m3 -> lemd d (map_or m0 m2) (map_or m1 m3).
Proof.
	intros. apply (lemd_transitive d (map_or m0 m2) (map_or m1 m2) (map_or m1 m3)). apply (map_or_inc_ld d m2 m0 m1).
	unfold lemd in H0. decompose [and] H0. exact H1. exact H.
	apply (map_or_inc_rd d m1 m2 m3). unfold lemd in H.
	decompose [and] H. exact H3. exact H0.
Qed.

Lemma predta_coacc_0_incr :
 forall (d d' : preDTA) (m0 m1 : Map bool),
 lemd d' m0 m1 -> lemd d (predta_coacc_0 d d' m0) (predta_coacc_0 d d' m1).
Proof.
	unfold lemd in |- *. unfold ensemble_base in |- *. simple induction d'. intros.
	decompose [and] H. induction  m0 as [| a a0| m0_1 Hrecm0_1 m0_0 Hrecm0_0]. induction  m1 as [| a a0| m1_1 Hrecm1_1 m1_0 Hrecm1_0]. simpl in |- *.
	split. exact (map_mini_appartient state d). split.
	exact (map_mini_appartient state d). exact (lem_reflexive (map_mini state d)). inversion H2. inversion H2. induction  m1 as [| a1 a2| m1_1 Hrecm1_1 m1_0 Hrecm1_0]. inversion H0. simpl in H3. simpl in |- *. apply (lemd_reflexive d (map_mini state d)). exact (map_mini_appartient state d).
	inversion H2. simpl in |- *. induction  m1 as [| a a0| m1_1 Hrecm1_1 m1_0 Hrecm1_0];
  exact (lemd_reflexive d (map_mini state d) (map_mini_appartient state d)). intros.
	decompose [and] H. induction  m0 as [| a1 a2| m0_1 Hrecm0_1 m0_0 Hrecm0_0]. induction  m1 as [| a1 a2| m1_1 Hrecm1_1 m1_0 Hrecm1_0]. simpl in |- *.
	exact (lemd_reflexive d (map_mini state d) (map_mini_appartient state d)). inversion H0. inversion H0. induction  m1 as [| a3 a4| m1_1 Hrecm1_1 m1_0 Hrecm1_0].
	inversion H2. simpl in |- *. simpl in H0. simpl in H2.
        simpl in H3.
        rewrite <- H0; rewrite <- H2; rewrite <- H0 in H3;
         rewrite <- H2 in H3.  rewrite (Neqb_correct a); simpl in |- *.
        rewrite (Neqb_correct a) in H3. elim (bool_is_true_or_false a2); intros; rewrite H1;
  elim (bool_is_true_or_false a4); intros; rewrite H4. 
	exact (lemd_reflexive d (st_coacc d a0) (st_coacc_def_ok d a0)). rewrite H4 in H3. rewrite H1 in H3. 
	inversion H3. 
	split. exact (map_mini_appartient state d). split. exact (st_coacc_def_ok d a0). elim (map_mini_mini state d). intros. exact (H6 (st_coacc d a0) (st_coacc_def_ok d a0)). exact (lemd_reflexive d (map_mini state d) (map_mini_appartient state d)). 
        inversion H3. inversion H0. intros. decompose [and] H1.
	induction  m1 as [| a a0| m1_1 Hrecm1_1 m1_0 Hrecm1_0]. inversion H2. inversion H2. induction  m2 as [| a a0| m2_1 Hrecm2_1 m2_0 Hrecm2_0].
	inversion H4. inversion H4. clear Hrecm2_0 Hrecm2_1 Hrecm1_0 Hrecm1_1. elim H5. intros. elim H4. elim H2. intros. simpl in |- *.
	elim (H m1_1 m2_1). intros. elim H12. intros. elim (H0 m1_0 m2_0). intros. elim H16. intros. split. exact (map_or_def_ok_d d _ _ H11 H15). split. exact (map_or_def_ok_d _ _ _ H13 H17). elim
  (map_or_inc_d d (predta_coacc_0 d m m1_1) (predta_coacc_0 d m m2_1)
     (predta_coacc_0 d m0 m1_0) (predta_coacc_0 d m0 m2_0)).
	intros. elim H20. intros. exact H22. unfold lemd in |- *.
	split. assumption. split; assumption. unfold lemd in |- *.
	split. assumption. split; assumption.  split.
	assumption. split; assumption. split. assumption.
	split; assumption.
Qed.

Lemma map_replace_inc :
 forall (m0 m1 : Map bool) (a : ad) (b : bool),
 lem m0 m1 -> lem (map_replace bool m0 a b) (map_replace bool m1 a b).
Proof.
	simple induction m0. simple induction m1. intros. exact (lem_reflexive (map_replace bool (M0 bool) a b)). intros. inversion H.
	intros. inversion H1. simple induction m1. intros. inversion H.
	simpl in |- *. intros. elim (bool_is_true_or_false (Neqb a a1)); intros; rewrite H0 in H. elim (bool_is_true_or_false (Neqb a3 a)); intros; rewrite H1. rewrite (Neqb_complete _ _ H1). rewrite H0. rewrite (Neqb_complete _ _ H0).
	exact (lem_reflexive (M1 bool a1 b)). elim (bool_is_true_or_false (Neqb a3 a1)); intros; rewrite H2.
	rewrite <- (Neqb_complete _ _ H0) in H2. rewrite H2 in H1.
	inversion H1. rewrite <- (Neqb_complete _ _ H0). simpl in |- *.
	rewrite (Neqb_correct a). exact H. elim H. intros.
	inversion H1. simple induction m2. intros. inversion H1.
	intros. inversion H1. intros. simpl in |- *. elim H3; intros.
	induction  a as [| p]. simpl in |- *. split. exact (H m3 N0 b H4).
	exact H5. induction  p as [p Hrecp| p Hrecp| ]; simpl in |- *; split. exact H4. exact (H0 m4 (Npos p) b H5). exact (H m3 (Npos p) b H4). exact H5.
	exact H4. exact (H0 m4 N0 b H5).
Qed.

Lemma map_replace_inc_d :
 forall (d : preDTA) (m0 m1 : Map bool) (a : ad) (b : bool),
 lemd d m0 m1 -> lemd d (map_replace bool m0 a b) (map_replace bool m1 a b).
Proof.
	unfold lemd in |- *. intros. decompose [and] H. split.
	exact (map_replace_def_ok_d d m0 a b H0). split.
	exact (map_replace_def_ok_d d m1 a b H2). exact (map_replace_inc m0 m1 a b H3).
Qed.

Lemma predta_coacc_increasing :
 forall (d : preDTA) (a : ad),
 increasing_app bool (lemd d) (predta_coacc d a).
Proof.
	unfold increasing_app in |- *. unfold predta_coacc in |- *. intros.
	exact
  (map_replace_inc_d d (predta_coacc_0 d d x) (predta_coacc_0 d d y) a true
     (predta_coacc_0_incr d d x y H)).
Qed.

Definition lattice_lemd_bounded_0_def (p : prechain bool) : Prop :=
  forall d : preDTA,
  chain bool (ensemble_base state d) (lemd d) p ->
  chain bool (ensemble_base state d) lem p.

Lemma lattice_lemd_bounded_0 :
 forall m : Map bool, lattice_lemd_bounded_0_def (single bool m).
Proof.
	unfold lattice_lemd_bounded_0_def in |- *. intros. inversion H.
	exact (chain_single bool m (ensemble_base state d) lem H3).
Qed.

Definition lattice_lemd_bounded_1_def (p : prechain bool) : Prop :=
  lattice_lemd_bounded_0_def p ->
  forall m : Map bool, lattice_lemd_bounded_0_def (concat bool p m).

Lemma lattice_lemd_bounded_1 :
 forall m : Map bool, lattice_lemd_bounded_1_def (single bool m).
Proof.
	unfold lattice_lemd_bounded_1_def in |- *. unfold lattice_lemd_bounded_0_def in |- *. intros. inversion H0.
	inversion H7. inversion H9. exact (chain_concat_s bool m m0 (ensemble_base state d) lem H8 H10 H11).
Qed.

Lemma lattice_lemd_bounded_2 :
 forall p : prechain bool,
 lattice_lemd_bounded_1_def p ->
 forall m : Map bool, lattice_lemd_bounded_1_def (concat bool p m).
Proof.
	unfold lattice_lemd_bounded_1_def in |- *. unfold lattice_lemd_bounded_0_def in |- *.
	intros. inversion H1. inversion H8. inversion H11. exact
  (chain_concat_m bool m m0 p (ensemble_base state d) lem H12 H13 (H0 _ H9)).
Qed.

Lemma lattice_lemd_bounded_3 :
 forall (p : prechain bool) (d : preDTA),
 chain bool (ensemble_base state d) (lemd d) p ->
 chain bool (ensemble_base state d) lem p.
Proof.
	exact
  (prechain_ind bool lattice_lemd_bounded_0_def lattice_lemd_bounded_0
     (prechain_ind bool lattice_lemd_bounded_1_def lattice_lemd_bounded_1
        lattice_lemd_bounded_2)).
Qed.

Lemma lattice_lemd_bounded :
 forall (p : prechain bool) (d : preDTA),
 sas_chain bool (ensemble_base state d) (lemd d) p ->
 sas_chain bool (ensemble_base state d) lem p.
Proof.
	intros. inversion H. split. exact (lattice_lemd_bounded_3 p d H0). exact H1.
Qed.

Lemma lattice_bounded :
 forall d : preDTA,
 bounded_sas_chain bool (ensemble_base state d) (lemd d)
   (S (MapCard state d)).
Proof.
	unfold bounded_sas_chain in |- *. intros. exact (lattice_bounded state d p (lattice_lemd_bounded p d H)).
Qed.

Lemma pl_coacc_contain_coacc_ads :
 forall (d : preDTA) (p : prec_list) (a : ad),
 prec_occur p a ->
 prec_list_ref_ok p d -> MapGet bool (pl_coacc d p) a = Some true.
Proof.
	simple induction p. intros. inversion H1. simpl in |- *. elim (H2 _ H1).
	intros. elim
  (domain_equal_mapget state bool d (map_or (pl_coacc d p0) (pl_coacc d p1))
     a0 x
     (map_or_def_ok_d _ _ _ (pl_coacc_def_ok d p0) (pl_coacc_def_ok d p1)) H7).
	intros. exact (map_replace_mapget_ins_true_0 _ _ _ H8).
	simpl in |- *. apply
  (map_replace_mapget_ins_true_1 (map_or (pl_coacc d p0) (pl_coacc d p1)) a0
     a). apply
  (map_or_mapget_true_ld _ _ _ a0 (pl_coacc_def_ok d p0)
     (pl_coacc_def_ok d p1)). elim (prec_list_ref_ok_destr _ _ _ _ H2). intros. exact (H _ H7 H8). simpl in |- *. apply
  (map_replace_mapget_ins_true_1 (map_or (pl_coacc d p0) (pl_coacc d p1)) a0
     a). apply
  (map_or_mapget_true_rd _ _ _ a0 (pl_coacc_def_ok d p0)
     (pl_coacc_def_ok d p1)).
	elim (prec_list_ref_ok_destr _ _ _ _ H2). intros.
	exact (H0 _ H7 H9). simpl in |- *. intros. inversion H.
Qed.

Lemma st_coacc_contain_coacc_ads :
 forall (d : preDTA) (s : state) (c : ad) (p : prec_list) (a : ad),
 state_ref_ok s d ->
 MapGet prec_list s c = Some p ->
 prec_occur p a -> MapGet bool (st_coacc d s) a = Some true.
Proof.
	simple induction s. intros. inversion H0. intros. simpl in H0.
	elim (bool_is_true_or_false (Neqb a c)); intros; rewrite H2 in H0. simpl in |- *. apply (pl_coacc_contain_coacc_ads d a0 a1). inversion H0. exact H1. apply (H a a0). simpl in |- *.
	rewrite (Neqb_correct a). reflexivity. inversion H0.
	intros. elim (state_ref_ok_M2_destr _ _ _ H1); intros.
	simpl in |- *. induction  c as [| p0]. simpl in H2. apply
  (map_or_mapget_true_ld _ _ _ a (st_coacc_def_ok d m) (st_coacc_def_ok d m0)).
	apply (H _ _ _ H4 H2 H3). induction  p0 as [p0 Hrecp0| p0 Hrecp0| ]. apply
  (map_or_mapget_true_rd _ _ _ a (st_coacc_def_ok d m) (st_coacc_def_ok d m0)). exact (H0 _ _ _ H5 H2 H3).
	apply
  (map_or_mapget_true_ld _ _ _ a (st_coacc_def_ok d m) (st_coacc_def_ok d m0)). apply (H _ _ _ H4 H2 H3).
	apply
  (map_or_mapget_true_rd _ _ _ a (st_coacc_def_ok d m) (st_coacc_def_ok d m0)). exact (H0 _ _ _ H5 H2 H3).
Qed.

Lemma predta_coacc_0_contain_coacc_ads :
 forall (d d' : preDTA) (a : ad) (s : state) (c : ad) 
   (p : prec_list) (b : ad) (m : Map bool),
 preDTA_ref_ok_distinct d' d ->
 MapGet state d' a = Some s ->
 MapGet prec_list s c = Some p ->
 prec_occur p b ->
 ensemble_base state d' m ->
 MapGet bool m a = Some true ->
 MapGet bool (predta_coacc_0 d d' m) b = Some true.
Proof.
	simple induction d'. intros. inversion H0. simpl in |- *. intros.
	induction  m as [| a2 a3| m1 Hrecm1 m0 Hrecm0]. inversion H3. unfold ensemble_base in H3.
	simpl in H3. rewrite <- H3. rewrite (Neqb_correct a).
	simpl in H4. elim (bool_is_true_or_false (Neqb a2 a1)); intros; rewrite H5 in H4;
  inversion H4. simpl in |- *. apply (st_coacc_contain_coacc_ads d a0 c p b). elim (bool_is_true_or_false (Neqb a a1)); intros; rewrite H6 in H0;
  inversion H0. rewrite H9 in H. apply (H a s).
	simpl in |- *. rewrite (Neqb_correct a). reflexivity. elim (bool_is_true_or_false (Neqb a a1)); intros; rewrite H6 in H0. inversion H0. exact H1. inversion H0. exact H2.
	inversion H3. intros. induction  m1 as [| a0 a1| m1_1 Hrecm1_1 m1_0 Hrecm1_0]. inversion H5.
	inversion H5. elim H5. intros. elim (preDTA_ref_ok_distinct_dest _ _ _ H1). intros. simpl in |- *.
	induction  a as [| p0]. simpl in H6. simpl in H2. apply
  (map_or_mapget_true_ld _ _ _ b (predta_coacc_0_def_ok d m m1_1)
     (predta_coacc_0_def_ok d m0 m1_0)). exact (H _ _ _ _ _ _ H9 H2 H3 H4 H7 H6). induction  p0 as [p0 Hrecp0| p0 Hrecp0| ]; simpl in H2; simpl in H6. apply
  (map_or_mapget_true_rd _ _ _ b (predta_coacc_0_def_ok d m m1_1)
     (predta_coacc_0_def_ok d m0 m1_0)). exact (H0 _ _ _ _ _ _ H10 H2 H3 H4 H8 H6).
	exact
  (map_or_mapget_true_ld _ _ _ b (predta_coacc_0_def_ok d m m1_1)
     (predta_coacc_0_def_ok d m0 m1_0) (H _ _ _ _ _ _ H9 H2 H3 H4 H7 H6)). exact
  (map_or_mapget_true_rd _ _ _ b (predta_coacc_0_def_ok d m m1_1)
     (predta_coacc_0_def_ok d m0 m1_0) (H0 _ _ _ _ _ _ H10 H2 H3 H4 H8 H6)).
Qed.

Lemma predta_coacc_contain_coacc_ads_0 :
 forall (d : preDTA) (a0 a : ad) (s : state) (c : ad) 
   (p : prec_list) (b : ad) (m : Map bool),
 preDTA_ref_ok d ->
 MapGet state d a = Some s ->
 MapGet prec_list s c = Some p ->
 prec_occur p b ->
 ensemble_base state d m ->
 MapGet bool m a = Some true ->
 MapGet bool (predta_coacc d a0 m) b = Some true.
Proof.
	unfold predta_coacc in |- *. intros. apply (map_replace_mapget_ins_true_1 (predta_coacc_0 d d m) b a0). apply
  (fun hyp : preDTA_ref_ok_distinct d d =>
   predta_coacc_0_contain_coacc_ads d d a s c p b m hyp H0 H1 H2 H3 H4). elim (preDTA_ref_ok_def d). intros. exact (H5 H).
Qed.

Definition predta_coacc_contain_coacc_ads_def_0 (d : preDTA) 
  (a0 a1 : ad) : Prop :=
  coacc d a0 a1 ->
  preDTA_ref_ok d ->
  exists n : nat,
    MapGet bool (power (Map bool) (predta_coacc d a0) (map_mini state d) n)
      a1 = Some true.

Lemma predta_coacc_contain_coacc_ads_1 :
 forall (d : preDTA) (a : ad) (s : state),
 MapGet state d a = Some s ->
 predta_coacc_contain_coacc_ads_def_0 d a a.
Proof.
	unfold predta_coacc_contain_coacc_ads_def_0 in |- *. intros.
	split with 1. simpl in |- *. unfold predta_coacc in |- *. elim
  (domain_equal_mapget state bool d (predta_coacc_0 d d (map_mini state d)) a
     s (predta_coacc_0_def_ok d d (map_mini state d)) H). intros. apply
  (map_replace_mapget_ins_true_0 (predta_coacc_0 d d (map_mini state d)) a x
     H2).
Qed.

Lemma predta_coacc_contain_coacc_ads_2 :
 forall (d : preDTA) (a0 a1 a2 : ad) (s1 s2 : state) 
   (pl : prec_list) (c : ad),
 MapGet state d a2 = Some s2 ->
 MapGet state d a1 = Some s1 ->
 MapGet prec_list s1 c = Some pl ->
 prec_occur pl a2 ->
 coacc d a0 a1 ->
 predta_coacc_contain_coacc_ads_def_0 d a0 a1 ->
 predta_coacc_contain_coacc_ads_def_0 d a0 a2.
Proof.
	unfold predta_coacc_contain_coacc_ads_def_0 in |- *. intros.
	elim (H4 H3 H6). intros. split with (S x). simpl in |- *.
	apply
  (predta_coacc_contain_coacc_ads_0 d a0 a1 s1 c pl a2
     (power (Map bool) (predta_coacc d a0) (map_mini state d) x) H6 H0 H1 H2). apply
  (power_def_ok bool (ensemble_base state d) (predta_coacc d a0)
     (map_mini state d) x). unfold def_ok_app in |- *. intros. exact (predta_coacc_def_ok d a0 x0).
	exact (map_mini_appartient state d). exact H7.
Qed.

Lemma predta_coacc_contain_coacc_ads_3 :
 forall (d : preDTA) (a0 a1 : ad),
 coacc d a0 a1 ->
 preDTA_ref_ok d ->
 exists n : nat,
   MapGet bool (power (Map bool) (predta_coacc d a0) (map_mini state d) n) a1 =
   Some true.
Proof.
	intros. exact
  (coacc_ind predta_coacc_contain_coacc_ads_def_0
     predta_coacc_contain_coacc_ads_1 predta_coacc_contain_coacc_ads_2 d a0
     a1 H H H0).
Qed.

Lemma pl_coacc_rev :
 forall (d : preDTA) (pl : prec_list) (a : ad),
 MapGet bool (pl_coacc d pl) a = Some true -> prec_occur pl a.
Proof.
	simple induction pl. simpl in |- *. intros. elim
  (map_replace_mapget_true_inv (map_or (pl_coacc d p) (pl_coacc d p0)) _ _ H1). intros. rewrite <- H2.
	exact (prec_hd a0 p p0). intros. elim (map_or_mapget_true_inv (pl_coacc d p) (pl_coacc d p0) a0 H2). intros. exact (prec_int0 a a0 p p0 (H _ H3)). intros. exact (prec_int1 a a0 p p0 (H0 _ H3)). intros. simpl in H. cut (true <> false).
	intro. elim (H0 (map_mini_mapget_false _ _ _ _ H)). intro.
	inversion H0.
Qed.

Lemma st_coacc_rev :
 forall (d : preDTA) (s : state) (a : ad),
 MapGet bool (st_coacc d s) a = Some true ->
 exists c : ad,
   (exists p : prec_list,
      MapGet prec_list s c = Some p /\ prec_occur p a).
Proof.
	simple induction s. intros. simpl in H. elim (map_mini_mapget_true _ _ _ H). intros. simpl in H. split with a. split with a0.
	simpl in |- *. rewrite (Neqb_correct a). split. reflexivity.
	exact (pl_coacc_rev _ _ _ H). intros. simpl in H1.
	elim (map_or_mapget_true_inv (st_coacc d m) (st_coacc d m0) a H1). intros. elim (H _ H2). intros. elim H3. intros.
	split with (Ndouble x). split with x0. induction  x as [| p]; simpl in |- *; exact H4. intros. elim (H0 _ H2). intros. elim H3. intros.
	split with (Ndouble_plus_one x). split with x0.
	induction  x as [| p]; simpl in |- *; exact H4.
Qed.

Lemma predta_coacc_0_rev :
 forall (d d' : preDTA) (b : ad) (m : Map bool),
 MapGet bool (predta_coacc_0 d d' m) b = Some true ->
 ensemble_base state d' m ->
 exists a : ad,
   (exists s : state,
      (exists c : ad,
         (exists p : prec_list,
            MapGet state d' a = Some s /\
            MapGet prec_list s c = Some p /\
            prec_occur p b /\ MapGet bool m a = Some true))).
Proof.
	simple induction d'; intros. induction  m as [| a a0| m1 Hrecm1 m0 Hrecm0]. simpl in H. elim (map_mini_mapget_true _ _ _ H). inversion H0.
	inversion H0. induction  m as [| a1 a2| m1 Hrecm1 m0 Hrecm0]. inversion H0. unfold ensemble_base in H0. simpl in H0. rewrite <- H0 in H.
	rewrite <- H0. simpl in H. rewrite (Neqb_correct a) in H. elim (bool_is_true_or_false a2); intros; rewrite H1 in H. simpl in H. split with a. split with a0. elim (st_coacc_rev _ _ _ H). intros. elim H2. intros. split with x. split with x0. simpl in |- *. rewrite (Neqb_correct a). rewrite H1. elim H3. intros. split. reflexivity. split. assumption.
	split. assumption. reflexivity. simpl in H. elim (map_mini_mapget_true _ _ _ H). inversion H0. induction  m1 as [| a a0| m1_1 Hrecm1_1 m1_0 Hrecm1_0].
	inversion H2. inversion H2. clear Hrecm1_0 Hrecm1_1.
	unfold ensemble_base in H2. elim H2. intros. simpl in H1.
	elim (map_or_mapget_true_inv _ _ _ H1). intros. elim (H _ _ H5 H3). intros. elim H6. intros. elim H7. intros.
	elim H8. intros. decompose [and] H9. split with (Ndouble x). split with x0. split with x1. split with x2. split. induction  x as [| p]; simpl in |- *; exact H10. split. exact H12. split. exact H11. induction  x as [| p]; simpl in |- *; exact H14.
	intros. elim (H0 _ _ H5 H4). intros. elim H6. intros.
	elim H7. intros. elim H8. intros. decompose [and] H9.
	split with (Ndouble_plus_one x). split with x0.
	split with x1. split with x2. induction  x as [| p]; simpl in |- *; exact H9.
Qed.

Lemma predta_coacc_rev :
 forall (d : preDTA) (a : ad) (m : Map bool) (b : ad),
 MapGet bool (predta_coacc d a m) b = Some true ->
 ensemble_base state d m ->
 (exists a0 : ad,
    (exists s : state,
       (exists c : ad,
          (exists p : prec_list,
             MapGet state d a0 = Some s /\
             MapGet prec_list s c = Some p /\
             prec_occur p b /\ MapGet bool m a0 = Some true)))) \/ 
 a = b.
Proof.
	unfold predta_coacc in |- *. intros. elim (map_replace_mapget_true_inv _ _ _ H). intros.
	right. symmetry  in |- *. exact H1. intros. left. elim (predta_coacc_0_rev d d b m H1 H0). elim (predta_coacc_0_rev d d b m H1 H0). intros. elim H3.
	intros. elim H4. intros. elim H5. intros. decompose [and] H6. split with x0. split with x1. exact H4.
Qed.

Lemma predta_coacc_reverse :
 forall (n : nat) (d : preDTA) (a b : ad),
 MapGet bool (power (Map bool) (predta_coacc d a) (map_mini state d) n) b =
 Some true -> coacc d a b.
Proof.
	simple induction n. simpl in |- *. intros. elim (map_mini_mapget_true _ _ _ H). intros. simpl in H0. elim (predta_coacc_rev d a _ _ H0).
	intros. elim H1. intros. elim H2. intros. elim H3. intros.
	elim H4. intros. decompose [and] H5. elim
  (domain_equal_mapget bool state
     (predta_coacc d a
        (power (Map bool) (predta_coacc d a) (map_mini state d) n0)) d b true). intros. apply (coacc_nxt d a x b x0 x3 x2 x1 H9 H6 H8 H7). exact (H d a x H10). exact
  (domain_equal_symmetric state bool _ _
     (predta_coacc_def_ok d a
        (power (Map bool) (predta_coacc d a) (map_mini state d) n0))). exact H0. intros. rewrite H1. elim
  (domain_equal_mapget bool state
     (predta_coacc d a
        (power (Map bool) (predta_coacc d a) (map_mini state d) n0)) d b true). intros. exact (coacc_id d b x H2). apply
  (domain_equal_symmetric state bool d
     (predta_coacc d a
        (power (Map bool) (predta_coacc d a) (map_mini state d) n0))).
	exact
  (predta_coacc_def_ok d a
     (power (Map bool) (predta_coacc d a) (map_mini state d) n0)). exact H0.
	apply
  (power_def_ok bool (ensemble_base state d) (predta_coacc d a)
     (map_mini state d) n0). unfold def_ok_app in |- *. intros. exact (predta_coacc_def_ok d a x).
	exact (map_mini_appartient state d).
Qed.

Lemma predta_coacc_fix_0 :
 forall (d : preDTA) (a : ad),
 lower_fix_point bool (ensemble_base state d) (lemd d) 
   (predta_coacc d a) (predta_coacc_states d a).
Proof.
	intros. unfold predta_coacc_states in |- *. apply
  (iteres_lower_fix_point bool (ensemble_base state d) 
     (lemd d) (predta_coacc d a) (map_mini state d) 
     (S (MapCard state d)) (S (MapCard state d))). unfold mini in |- *.
	split. exact (map_mini_appartient state d). intros.
	split. exact (map_mini_appartient state d). split.
	exact H. elim (map_mini_mini state d). intros.
	exact (H1 x H). unfold def_ok_app in |- *. intros. exact (predta_coacc_def_ok d a x). exact (predta_coacc_increasing d a). exact (lattice_bounded d). exact (le_n_n _).
Qed.

Lemma predta_coacc_fix_1 :
 forall (d : preDTA) (a a0 : ad) (n : nat),
 MapGet bool (power (Map bool) (predta_coacc d a) (map_mini state d) n) a0 =
 Some true -> MapGet bool (predta_coacc_states d a) a0 = Some true.
Proof.
	intros. elim
  (domain_equal_mapget bool bool
     (power (Map bool) (predta_coacc d a) (map_mini state d) n)
     (predta_coacc_states d a) a0 true). intros. elim (bool_is_true_or_false x); intros; rewrite H1 in H0.
	exact H0. elim (predta_coacc_fix_0 d a); intros.
	unfold inf_fix_points in H3. elim
  (lem_get_leb (power (Map bool) (predta_coacc d a) (map_mini state d) n)
     (predta_coacc_states d a) a0 true false).
	elim
  (iteres_inf_fps bool (ensemble_base state d) (lemd d) 
     (predta_coacc d a) (map_mini state d) (predta_coacc_states d a) n). intros. elim H5. intros.
	exact H7. unfold mini in |- *. split. exact (map_mini_appartient state d). intros. split. exact (map_mini_appartient state d). split. exact H4. elim (map_mini_mini state d). intros. exact (H6 x0 H4). exact H2. exact (predta_coacc_increasing d a). exact H. exact H0.
	apply
  (domain_equal_transitive bool state bool
     (power (Map bool) (predta_coacc d a) (map_mini state d) n) d
     (predta_coacc_states d a)). apply
  (domain_equal_symmetric state bool d
     (power (Map bool) (predta_coacc d a) (map_mini state d) n)). apply
  (power_def_ok bool (ensemble_base state d) (predta_coacc d a)
     (map_mini state d) n). unfold def_ok_app in |- *. intros.
	exact (predta_coacc_def_ok d a x). exact (map_mini_appartient state d). unfold predta_coacc_states in |- *.
	apply
  (power_def_ok bool (ensemble_base state d) (predta_coacc d a)
     (map_mini state d) (S (MapCard state d))). unfold def_ok_app in |- *. intros. exact (predta_coacc_def_ok d a x). exact (map_mini_appartient state d). exact H.
Qed.

Lemma predta_coacc_fix_2 :
 forall (d : preDTA) (a a0 : ad),
 MapGet bool (predta_coacc_states d a) a0 = Some true ->
 exists n : nat,
   MapGet bool (power (Map bool) (predta_coacc d a) (map_mini state d) n) a0 =
   Some true.
Proof.
	unfold predta_coacc_states in |- *. intros. split with (S (MapCard state d)). exact H.        
Qed.

Lemma predta_coacc_fix :
 forall (d : preDTA) (a a0 : ad),
 preDTA_ref_ok d ->
 (MapGet bool (predta_coacc_states d a) a0 = Some true <-> coacc d a a0).
Proof.
	intros. split. intros. elim (predta_coacc_fix_2 _ _ _ H0). intros. exact (predta_coacc_reverse x d a a0 H1). intros. elim (predta_coacc_contain_coacc_ads_3 _ _ _ H0). intros. exact (predta_coacc_fix_1 d a a0 x H1). exact H.
Qed.

Lemma predta_coacc_0_fix :
 forall (d : preDTA) (a a0 : ad),
 preDTA_ref_ok d ->
 (MapGet bool (predta_coacc_states_0 d a) a0 = Some true <->
  coacc d a a0).
Proof.
	intros. unfold predta_coacc_states_0 in |- *. rewrite
  (lazy_power_eg_power bool eqm_bool (predta_coacc d a) 
     (map_mini state d) (S (MapCard state d))). exact (predta_coacc_fix d a a0 H). split. exact (eqm_bool_equal a1 b). intros. rewrite H0. exact (equal_eqm_bool b).
Qed.