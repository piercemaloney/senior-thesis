

Require Import Bool.

Require Import NArith Ndec Ndigits.

Require Import ZArith.

From IntMap Require Import Allmaps.

Require Import bases.
(* bases:
Require Import Bool.
Require Import Arith.
Require Import ZArith.
Require Import NArith.
Require Import Ndec.
From IntMap Require Import Allmaps.
Require Import EqNat.
Require Export Max.

Lemma nat_sum : forall n : nat, n = 0 \/ (exists m : nat, n = S m).

Lemma le_n_n : forall n : nat, n <= n.

Lemma le_l_or_r : forall n m : nat, n <= m \/ m <= n.

Lemma plus_n_O : forall n : nat, n + 0 = n.
 
 Lemma S_plus_l : forall n m : nat, S (n + m) = S n + m.
 
 Lemma S_plus_r : forall n m : nat, S (n + m) = n + S m.

Lemma max_le_Sr_0 :
 forall n m : nat, max n m <= max n (S m) /\ max (S n) m <= max (S n) (S m).

Lemma max_le_Sr : forall n m : nat, max n m <= max n (S m).

Lemma plus_O_r : forall n : nat, n + 0 = n.

Lemma plus_O_l : forall n : nat, n + 0 = n.

Lemma le_mult_lS : forall n m : nat, n * m <= S n * m.

Lemma le_mult_rS : forall n m : nat, n * m <= n * S m.

Lemma le_disj : forall n m : nat, n <= m -> n = m \/ S n <= m.

Lemma le_mult_l : forall n m p : nat, n <= m -> n * p <= m * p.

Lemma le_mult_r : forall n m p : nat, n <= m -> p * n <= p * m.

Lemma le_mult_mult : forall n m p q : nat, n <= m -> p <= q -> n * p <= m * q.

Lemma Sn_eq_Sm_n_eq_m : forall n m : nat, S n = S m -> n = m.

Lemma bool_dec_eq : forall a b : bool, {a = b} + {a <> b}.

Lemma bool_is_false_or_true : forall a : bool, a = false \/ a = true.

Lemma bool_is_true_or_false : forall a : bool, a = true \/ a = false.

Lemma in_M0_false :
 forall (A : Set) (a : A), ~ (exists e : ad, MapGet A (M0 A) e = Some a).

Lemma in_M1_id :
 forall (A : Set) (a : A) (x : ad) (e : A),
 (exists c : ad, MapGet A (M1 A x e) c = Some a) -> a = e.

Lemma in_M2_disj :
 forall (A : Set) (a : A) (m0 m1 : Map A),
 (exists c : ad, MapGet A (M2 A m0 m1) c = Some a) ->
 (exists c : ad, MapGet A m0 c = Some a) \/
 (exists c : ad, MapGet A m1 c = Some a).

Lemma aux_Neqb_1_0 : forall p : positive, Peqb p p = true.

Lemma aux_Neqb_1_1 : forall p p0 : positive, Peqb p p0 = true -> p = p0.

Lemma aux_Neqb_trans :
 forall a b c : ad, Neqb a b = true -> Neqb b c = true -> Neqb a c = true.

Lemma indprinciple_nat_gen :
 forall P : nat -> Prop,
 (forall n : nat, (forall m : nat, m < n -> P m) -> P n) ->
 forall n m : nat, m <= n -> P m.

Lemma beq_nat_complete : forall n m : nat, beq_nat n m = true -> n = m.

Lemma beq_nat_correct : forall n : nat, beq_nat n n = true. *)

Require Import defs.
(* defs:
Require Import Bool.
Require Import Arith.
Require Import ZArith.
From IntMap Require Import Allmaps.
Require Import EqNat.
Require Import bases.

Inductive term : Set :=
    app : ad -> term_list -> term
with term_list : Set :=
  | tnil : term_list
  | tcons : term -> term_list -> term_list.

Scheme term_term_list_rec := Induction for term
  Sort Set
  with term_list_term_rec := Induction for term_list 
  Sort Set.

Scheme term_term_list_ind := Induction for term
  Sort Prop
  with term_list_term_ind := Induction for term_list 
  Sort Prop.

Lemma term_list_disj :
 forall l : term_list,
 l = tnil \/ (exists hd : term, (exists tl : term_list, l = tcons hd tl)).

Fixpoint lst_length (l : term_list) : nat :=
  match l with
  | tnil => 0
  | tcons _ l' => S (lst_length l')
  end.

Fixpoint term_high (t : term) : nat :=
  match t with
  | app a l => S (term_high_0 l)
  end
 
 with term_high_0 (l : term_list) : nat :=
  match l with
  | tnil => 0
  | tcons hd tl => max (term_high hd) (term_high_0 tl)
  end.

Lemma high_aux_0 :
 forall (a : ad) (l : term_list), S (term_high_0 l) <= term_high (app a l).

Lemma high_aux_1 :
 forall (a : ad) (l : term_list), S (term_high_0 l) = term_high (app a l).

Lemma high_aux_2 : forall (l : term_list) (c : ad), 1 <= term_high (app c l).

Lemma high_aux_3 :
 forall (t : term) (tl : term_list), term_high t <= term_high_0 (tcons t tl).

Lemma high_aux_4 :
 forall (t : term) (tl : term_list),
 term_high_0 tl <= term_high_0 (tcons t tl).

Fixpoint taille_term (t : term) : nat :=
  match t with
  | app c l => S (mtaille_term_list l)
  end
 
 with mtaille_term_list (l : term_list) : nat :=
  match l with
  | tnil => 0
  | tcons hd tl => max (taille_term hd) (mtaille_term_list tl)
  end.

Inductive prec_list : Set :=
  | prec_cons : ad -> prec_list -> prec_list -> prec_list
  | prec_empty : prec_list.

Lemma pl_sum :
 forall pl : prec_list,
 pl = prec_empty \/
 (exists a : ad,
    (exists la : prec_list, (exists ls : prec_list, pl = prec_cons a la ls))).

Definition state := Map prec_list.

Definition preDTA := Map state.

Inductive DTA : Set :=
    dta : preDTA -> ad -> DTA.

Fixpoint taille_0 (l : prec_list) : nat :=
  match l with
  | prec_empty => 0
  | prec_cons x y z => S (taille_0 y + taille_0 z)
  end.

Fixpoint taille_1 (s : state) : nat :=
  match s with
  | M0 => 0
  | M1 x y => taille_0 y
  | M2 x y => max (taille_1 x) (taille_1 y)
  end.

Fixpoint DTA_taille (d : preDTA) : nat :=
  match d with
  | M0 => 0
  | M1 x y => taille_1 y
  | M2 x y => max (DTA_taille x) (DTA_taille y)
  end.

Lemma taille_aux_0 :
 forall (a : ad) (la ls : prec_list),
 S (taille_0 la) <= taille_0 (prec_cons a la ls).

Lemma taille_aux_1 :
 forall (a : ad) (la ls : prec_list), 1 <= taille_0 (prec_cons a la ls).

Lemma taille_aux_2 :
 forall (a : ad) (la ls : prec_list),
 S (taille_0 ls) <= taille_0 (prec_cons a la ls).

Inductive prec_occur : prec_list -> ad -> Prop :=
  | prec_hd :
      forall (a : ad) (pl0 pl1 : prec_list),
      prec_occur (prec_cons a pl0 pl1) a
  | prec_int0 :
      forall (a b : ad) (pl0 pl1 : prec_list),
      prec_occur pl0 b -> prec_occur (prec_cons a pl0 pl1) b
  | prec_int1 :
      forall (a b : ad) (pl0 pl1 : prec_list),
      prec_occur pl1 b -> prec_occur (prec_cons a pl0 pl1) b.

Inductive prec_contained : prec_list -> prec_list -> Prop :=
  | prec_id : forall p : prec_list, prec_contained p p
  | prec_c_int0 :
      forall (p p0 p1 : prec_list) (a : ad),
      prec_contained p p0 -> prec_contained p (prec_cons a p0 p1)
  | prec_c_int1 :
      forall (p p0 p1 : prec_list) (a : ad),
      prec_contained p p1 -> prec_contained p (prec_cons a p0 p1).

Definition state_in_dta (d : preDTA) (s : state) : Prop :=
  exists a : ad, MapGet state d a = Some s.

Definition state_in_dta_diff (d : preDTA) (s : state) 
  (a : ad) : Prop := exists b : ad, MapGet state d b = Some s /\ a <> b.

Definition prec_in_dta (d : preDTA) (p : prec_list) : Prop :=
  exists s : state,
    (exists a : ad,
       (exists c : ad,
          MapGet state d a = Some s /\
          MapGet prec_list s c = Some p)).

Definition prec_in_dta_cont (d : preDTA) (p : prec_list) : Prop :=
  exists s : state,
    (exists b : ad,
       (exists c : ad,
          (exists p0 : prec_list,
             MapGet state d b = Some s /\
             MapGet prec_list s c = Some p0 /\ prec_contained p p0))).

Definition prec_in_dta_diff (d : preDTA) (p : prec_list) 
  (a : ad) : Prop :=
  exists s : state,
    (exists b : ad,
       (exists c : ad,
          MapGet state d b = Some s /\
          MapGet prec_list s c = Some p /\ a <> b)).

Definition prec_in_dta_diff_cont (d : preDTA) (p : prec_list) 
  (a : ad) : Prop :=
  exists s : state,
    (exists b : ad,
       (exists c : ad,
          (exists p0 : prec_list,
             MapGet state d b = Some s /\
             MapGet prec_list s c = Some p0 /\
             prec_contained p p0 /\ a <> b))).

Definition prec_in_state (s : state) (p : prec_list) : Prop :=
  exists c : ad, MapGet prec_list s c = Some p.

Lemma prec_in_state_M0_false :
 forall p : prec_list, ~ prec_in_state (M0 prec_list) p.

Lemma state_in_dta_M0_false : forall s : state, ~ state_in_dta (M0 state) s.

Lemma prec_occur_1 :
 forall (a : ad) (p0 p1 p2 : prec_list),
 prec_contained (prec_cons a p0 p1) p2 -> prec_occur p2 a.

Lemma prec_contained_0 :
 forall (a : ad) (p0 p1 p2 : prec_list),
 prec_contained (prec_cons a p0 p1) p2 -> prec_contained p0 p2.

Lemma prec_contained_1 :
 forall (a : ad) (p0 p1 p2 : prec_list),
 prec_contained (prec_cons a p0 p1) p2 -> prec_contained p1 p2.

Inductive term_occur : term -> term -> Prop :=
  | to_eq : forall t : term, term_occur t t
  | to_st :
      forall (t : term) (a : ad) (tl : term_list),
      term_list_occur t tl -> term_occur t (app a tl)
with term_list_occur : term -> term_list -> Prop :=
  | tlo_head :
      forall (t hd : term) (tl : term_list),
      term_occur t hd -> term_list_occur t (tcons hd tl)
  | tlo_tail :
      forall (t hd : term) (tl : term_list),
      term_list_occur t tl -> term_list_occur t (tcons hd tl).

Definition term_occur_def_0 (t : term) :=
  forall u : term, term_occur u t -> term_high u <= term_high t.

Definition term_occur_def_1 (t : term_list) :=
  forall u : term, term_list_occur u t -> term_high u <= term_high_0 t.

Lemma term_occur_0_0 :
 forall (a : ad) (t : term_list),
 term_occur_def_1 t -> term_occur_def_0 (app a t).

Lemma term_occur_0_1 : term_occur_def_1 tnil.

Lemma term_occur_0_2 :
 forall t : term,
 term_occur_def_0 t ->
 forall t0 : term_list, term_occur_def_1 t0 -> term_occur_def_1 (tcons t t0).

Lemma term_occur_0 :
 forall t u : term, term_occur u t -> term_high u <= term_high t.

Lemma term_occur_1 :
 forall (t : term_list) (u : term),
 term_list_occur u t -> term_high u <= term_high_0 t.

Definition indprinciple_3_aux (n : nat) :=
  forall P : term -> Prop,
  (forall (a : ad) (tl : term_list),
   (forall u : term, term_list_occur u tl -> P u) -> P (app a tl)) ->
  forall t : term, term_high t <= n -> P t.

Lemma indprinciple_3_0 : indprinciple_3_aux 0.

Lemma indprinciple_3_1 :
 forall n : nat, indprinciple_3_aux n -> indprinciple_3_aux (S n).

Lemma indprinciple_3_2 :
 forall (n : nat) (P : term -> Prop),
 (forall (a : ad) (tl : term_list),
  (forall u : term, term_list_occur u tl -> P u) -> P (app a tl)) ->
 forall t : term, term_high t <= n -> P t.

Lemma indprinciple_term :
 forall P : term -> Prop,
 (forall (a : ad) (tl : term_list),
  (forall u : term, term_list_occur u tl -> P u) -> P (app a tl)) ->
 forall t : term, P t.

Lemma Ndouble_inv_N0 : forall x : ad, Ndouble x = N0 -> x = N0.

Lemma Ndouble_inv_xO :
 forall (x : ad) (p : positive), Ndouble x = Npos (xO p) -> x = Npos p.

Lemma Ndouble_plus_one_inv_xH :
 forall x : ad, Ndouble_plus_one x = Npos 1 -> x = N0.

Lemma Ndouble_plus_one_inv_xI :
 forall (x : ad) (p : positive),
 Ndouble_plus_one x = Npos (xI p) -> x = Npos p. *)

Require Import semantics.
(* semantics:
Require Import Bool.
Require Import Arith.
Require Import Classical_Prop.
From IntMap Require Import Allmaps.
Require Import bases.
Require Import defs.

Unset Standard Proposition Elimination Names.

Fixpoint rec_term (d : preDTA) (a : ad) (t : term) 
 (n : nat) {struct n} : bool :=
  match n with
  | O => false
  | S k =>
      match t with
      | app c l =>
          match MapGet _ d a with
          | None => false
          | Some lts =>
              match MapGet _ lts c with
              | None => false
              | Some pre => rec_list_terms d pre l k
              end
          end
      end
  end
 
 with rec_list_terms (d : preDTA) (pre : prec_list) 
 (l : term_list) (n : nat) {struct n} : bool :=
  match n with
  | O => false
  | S k =>
      match pre with
      | prec_empty => match l with
                      | tnil => true
                      | _ => false
                      end
      | prec_cons st stp pre' =>
          match l with
          | tnil => false
          | tcons hd tl =>
              rec_list_terms d pre' l k
              || rec_term d st hd k && rec_list_terms d stp tl k
          end
      end
  end.

Lemma borne_0_0 :
 forall p : prec_list,
 prec_in_state (M0 prec_list) p -> taille_0 p <= taille_1 (M0 prec_list).

Lemma borne_0_1 :
 forall (a : ad) (p' p : prec_list),
 prec_in_state (M1 prec_list a p') p ->
 taille_0 p <= taille_1 (M1 prec_list a p').

Lemma borne_0_2 :
 forall (m0 m1 : Map prec_list) (p : prec_list),
 (prec_in_state m0 p -> taille_0 p <= taille_1 m0) ->
 (prec_in_state m1 p -> taille_0 p <= taille_1 m1) ->
 prec_in_state (M2 prec_list m0 m1) p ->
 taille_0 p <= taille_1 (M2 prec_list m0 m1).

Lemma borne_0 :
 forall (s : state) (p : prec_list),
 prec_in_state s p -> taille_0 p <= taille_1 s.

Lemma borne_1_0 :
 forall s : state,
 state_in_dta (M0 state) s -> taille_1 s <= DTA_taille (M0 state).

Lemma borne_1_1 :
 forall (a : ad) (s' s : state),
 state_in_dta (M1 state a s') s -> taille_1 s <= DTA_taille (M1 state a s').

Lemma borne_1_2 :
 forall (m0 m1 : Map state) (s : state),
 (state_in_dta m0 s -> taille_1 s <= DTA_taille m0) ->
 (state_in_dta m1 s -> taille_1 s <= DTA_taille m1) ->
 state_in_dta (M2 state m0 m1) s -> taille_1 s <= DTA_taille (M2 state m0 m1).

Lemma borne_1 :
 forall (d : preDTA) (s : state),
 state_in_dta d s -> taille_1 s <= DTA_taille d.

Lemma borne_2 :
 forall (d : preDTA) (p : prec_list),
 prec_in_dta d p -> taille_0 p <= DTA_taille d.

Definition essence (t : term) (d : preDTA) : nat :=
  S (term_high t) * S (DTA_taille d).

Definition essence_list (l : term_list) (d : preDTA) 
  (pl : prec_list) : nat :=
  match l, pl with
  | tnil, _ => 1
  | _, prec_empty => 1
  | _, prec_cons a la ls =>
      taille_0 pl + S (term_high_0 l) * S (DTA_taille d)
  end.

Lemma conservation_0_0 : forall n n0 : nat, S n * S n0 = S (n0 + n * S n0).

Lemma conservation_0 :
 forall (d : preDTA) (p : prec_list) (c : ad) (l : term_list),
 prec_in_dta d p -> S (essence_list l d p) <= essence (app c l) d.

Lemma conservation_1 :
 forall (d : preDTA) (l : term_list), 1 <= essence_list l d prec_empty.

Lemma conservation_2 :
 forall (d : preDTA) (p : prec_list), 1 <= essence_list tnil d p.

Lemma conservation_3 :
 forall (d : preDTA) (hd : term) (tl : term_list) (a : ad)
   (la ls : prec_list),
 S (essence_list (tcons hd tl) d ls) <=
 essence_list (tcons hd tl) d (prec_cons a la ls).

Lemma conservation_4 :
 forall (d : preDTA) (hd : term) (tl : term_list) (a : ad)
   (la ls : prec_list),
 S (essence_list tl d la) <= essence_list (tcons hd tl) d (prec_cons a la ls).

Lemma conservation_5_0 :
 forall (a : ad) (la ls : prec_list), 1 <= taille_0 (prec_cons a la ls).

Lemma conservation_5 :
 forall (d : preDTA) (hd : term) (tl : term_list) (a : ad)
   (la ls : prec_list),
 S (essence hd d) <= essence_list (tcons hd tl) d (prec_cons a la ls).

Definition dta_rec_term (d : DTA) (t : term) : bool :=
  match d with
  | dta p a => rec_term p a t (essence t p)
  end.

Inductive reconnaissance : preDTA -> ad -> term -> Prop :=
    rec_dta :
      forall (d : preDTA) (a : ad) (t : term) (ladj : state),
      MapGet state d a = Some ladj ->
      state_reconnait d ladj t -> reconnaissance d a t
with state_reconnait : preDTA -> state -> term -> Prop :=
    rec_st :
      forall (d : preDTA) (s : state) (c : ad) (tl : term_list)
        (l : prec_list),
      MapGet prec_list s c = Some l ->
      liste_reconnait d l tl -> state_reconnait d s (app c tl)
with liste_reconnait : preDTA -> prec_list -> term_list -> Prop :=
  | rec_empty : forall d : preDTA, liste_reconnait d prec_empty tnil
  | rec_consi :
      forall (d : preDTA) (a : ad) (la ls : prec_list) 
        (hd : term) (tl : term_list),
      reconnaissance d a hd ->
      liste_reconnait d la tl ->
      liste_reconnait d (prec_cons a la ls) (tcons hd tl)
  | rec_consn :
      forall (d : preDTA) (a : ad) (la ls : prec_list) 
        (hd : term) (tl : term_list),
      liste_reconnait d ls (tcons hd tl) ->
      liste_reconnait d (prec_cons a la ls) (tcons hd tl).

Definition reconnait (d : DTA) (t : term) : Prop :=
  match d with
  | dta p a => reconnaissance p a t
  end.

Scheme mreconnaissance_ind := Induction for reconnaissance
  Sort Prop
  with mstrec_ind := Induction for state_reconnait 
  Sort Prop
  with mlrec_ind := Induction for liste_reconnait Sort Prop.

Lemma sem_listes_0 :
 forall (d : preDTA) (p : prec_list) (hd : term) (tl : term_list),
 liste_reconnait d p (tcons hd tl) -> p <> prec_empty.

Lemma sem_listes_1 :
 forall (d : preDTA) (hd : term) (tl : term_list),
 ~ liste_reconnait d prec_empty (tcons hd tl).

Lemma sem_listes_2 :
 forall (d : preDTA) (pl : prec_list),
 liste_reconnait d pl tnil -> pl = prec_empty.

Definition sem_equiv_prop_t (t : term) :=
  forall (d : preDTA) (a : ad) (n : nat),
  rec_term d a t n = true -> reconnaissance d a t.
Definition sem_equiv_prop_l (l : term_list) :=
  forall (d : preDTA) (p : prec_list) (n : nat),
  rec_list_terms d p l n = true -> liste_reconnait d p l.

Lemma semantic_equiv_0_0 :
 forall (d : preDTA) (p : prec_list) (n : nat),
 rec_list_terms d p tnil n = true -> p = prec_empty.

Lemma semantic_equiv_0_1 : sem_equiv_prop_l tnil.

Lemma semantic_equiv_0_2 :
 forall (d : preDTA) (a a' : ad) (l : term_list) (n : nat) 
   (s : state) (p : prec_list),
 rec_term d a (app a' l) (S n) = true ->
 MapGet state d a = Some s ->
 MapGet prec_list s a' = Some p -> rec_list_terms d p l n = true.

Lemma semantic_equiv_0_3 :
 forall (d : preDTA) (a a' : ad) (l : term_list) (n : nat),
 rec_term d a (app a' l) (S n) = true ->
 exists s : state, MapGet state d a = Some s.

Lemma semantic_equiv_0_4 :
 forall (d : preDTA) (a a' : ad) (l : term_list) (n : nat) (s : state),
 MapGet state d a = Some s ->
 rec_term d a (app a' l) (S n) = true ->
 exists p : prec_list, MapGet prec_list s a' = Some p.

Lemma semantic_equiv_0_5 :
 forall (a : ad) (t : term_list),
 sem_equiv_prop_l t -> sem_equiv_prop_t (app a t).

Lemma semantic_equiv_0_6 :
 forall (n : nat) (t : term) (t0 : term_list),
 (forall (d : preDTA) (a : ad) (m : nat),
  rec_term d a t m = true -> reconnaissance d a t) ->
 (forall (d : preDTA) (p : prec_list) (m : nat),
  rec_list_terms d p t0 m = true -> liste_reconnait d p t0) ->
 forall (d : preDTA) (p : prec_list),
 rec_list_terms d p (tcons t t0) n = true -> liste_reconnait d p (tcons t t0).

Lemma semantic_equiv_0_7 :
 forall t : term,
 sem_equiv_prop_t t ->
 forall t0 : term_list, sem_equiv_prop_l t0 -> sem_equiv_prop_l (tcons t t0).

Lemma semantic_equiv_0 :
 forall (d : preDTA) (a : ad) (t : term) (n : nat),
 rec_term d a t n = true -> reconnaissance d a t.

Definition invar_term (t : term) : Prop :=
  forall (n m : nat) (d : preDTA) (a : ad),
  rec_term d a t n = true -> n <= m -> rec_term d a t m = true.

Definition invar_list (tl : term_list) : Prop :=
  forall (n m : nat) (d : preDTA) (p : prec_list),
  rec_list_terms d p tl n = true -> n <= m -> rec_list_terms d p tl m = true.

Lemma invar_0 : invar_list tnil.

Lemma invar_1_0 :
 forall (d : preDTA) (a c : ad) (t : term_list) (n : nat) 
   (s : state) (p : prec_list),
 MapGet state d a = Some s ->
 MapGet prec_list s c = Some p ->
 rec_list_terms d p t n = true -> rec_term d a (app c t) (S n) = true.

Lemma invar_1_1 :
 forall (d : preDTA) (a c : ad) (t : term_list) (n : nat),
 rec_term d a (app c t) (S n) = true ->
 exists p : prec_list, rec_list_terms d p t n = true.

Lemma invar_1 :
 forall (a : ad) (t : term_list), invar_list t -> invar_term (app a t).

Lemma invar_2_0 :
 forall (d : preDTA) (p : prec_list) (n : nat),
 rec_list_terms d p tnil n = true -> p = prec_empty.

Lemma invar_2_1 :
 forall (d : preDTA) (a : ad) (la ls : prec_list) (hd : term)
   (tl : term_list) (n : nat),
 rec_list_terms d (prec_cons a la ls) (tcons hd tl) (S n) = true ->
 rec_list_terms d ls (tcons hd tl) n = true \/
 rec_term d a hd n = true /\ rec_list_terms d la tl n = true.

Lemma invar_2_2 :
 forall (d : preDTA) (a : ad) (la ls : prec_list) (hd : term)
   (tl : term_list) (n : nat),
 rec_list_terms d ls (tcons hd tl) n = true \/
 rec_term d a hd n = true /\ rec_list_terms d la tl n = true ->
 rec_list_terms d (prec_cons a la ls) (tcons hd tl) (S n) = true.
 
Lemma invar_2 :
 forall t : term,
 invar_term t ->
 forall t0 : term_list, invar_list t0 -> invar_list (tcons t t0).

Lemma invar : forall t : term, invar_term t.

Lemma invarl : forall tl : term_list, invar_list tl.

Definition dta_reconnait (d : preDTA) (a : ad) (t : term)
  (pr : reconnaissance d a t) := rec_term d a t (essence t d) = true.

Definition st_reconnait (d : preDTA) (s : state) (t : term)
  (pr : state_reconnait d s t) :=
  match t with
  | app c l =>
      exists p : prec_list,
        MapGet prec_list s c = Some p /\
        rec_list_terms d p l (essence_list l d p) = true
  end.

Definition pre_reconnait (d : preDTA) (p : prec_list) 
  (t : term_list) (pr : liste_reconnait d p t) :=
  rec_list_terms d p t (essence_list t d p) = true.

Lemma semantic_equiv_1_0 :
 forall (d : preDTA) (a : ad) (t : term) (ladj : state)
   (e : MapGet state d a = Some ladj) (s : state_reconnait d ladj t),
 st_reconnait d ladj t s -> dta_reconnait d a t (rec_dta d a t ladj e s).

Lemma semantic_equiv_1_1 :
 forall (d : preDTA) (s : state) (c : ad) (tl : term_list) 
   (l : prec_list) (e : MapGet prec_list s c = Some l)
   (l0 : liste_reconnait d l tl),
 pre_reconnait d l tl l0 ->
 st_reconnait d s (app c tl) (rec_st d s c tl l e l0).

Lemma semantic_equiv_1_2 :
 forall d : preDTA, pre_reconnait d prec_empty tnil (rec_empty d).

Lemma semantic_equiv_1_3 :
 forall (d : preDTA) (a : ad) (la ls : prec_list) (hd : term)
   (tl : term_list) (r : reconnaissance d a hd),
 dta_reconnait d a hd r ->
 forall l : liste_reconnait d la tl,
 pre_reconnait d la tl l ->
 pre_reconnait d (prec_cons a la ls) (tcons hd tl)
   (rec_consi d a la ls hd tl r l).

Lemma semantic_equiv_1_4_0 :
 forall (d : preDTA) (a : ad) (la ls : prec_list) (l : term_list) (n : nat),
 l <> tnil ->
 rec_list_terms d ls l n = true ->
 rec_list_terms d (prec_cons a la ls) l (S n) = true.

Lemma semantic_equiv_1_4 :
 forall (d : preDTA) (a : ad) (la ls : prec_list) (hd : term)
   (tl : term_list) (l : liste_reconnait d ls (tcons hd tl)),
 pre_reconnait d ls (tcons hd tl) l ->
 pre_reconnait d (prec_cons a la ls) (tcons hd tl)
   (rec_consn d a la ls hd tl l).

Lemma semantic_equiv_1 :
 forall (d : preDTA) (a : ad) (t : term),
 reconnaissance d a t -> rec_term d a t (essence t d) = true. *)

Require Import signature.
(* signature:
Require Import Bool.
Require Import NArith.
Require Import Ndec.
Require Import ZArith.
Require Import EqNat.
From IntMap Require Import Allmaps.
Require Import bases.
Require Import defs.
Require Import semantics.

Definition pl_compat (pl0 pl1 : prec_list) : Prop :=
  pl0 = prec_empty /\ pl1 = prec_empty \/
  pl0 <> prec_empty /\ pl1 <> prec_empty.

Definition mpl_compat (s0 s1 : state) : Prop :=
  forall (c : ad) (p0 p1 : prec_list),
  MapGet prec_list s0 c = Some p0 ->
  MapGet prec_list s1 c = Some p1 -> pl_compat p0 p1.

Definition dta_correct (d : preDTA) : Prop :=
  forall (s0 s1 : state) (a0 a1 : ad),
  MapGet state d a0 = Some s0 ->
  MapGet state d a1 = Some s1 -> mpl_compat s0 s1.

Definition dta_compat (d0 d1 : preDTA) : Prop :=
  forall (s0 s1 : state) (a0 a1 : ad),
  MapGet state d0 a0 = Some s0 ->
  MapGet state d1 a1 = Some s1 -> mpl_compat s0 s1.

Definition DTA_compat (d0 d1 : DTA) : Prop :=
  match d0, d1 with
  | dta p0 a0, dta p1 a1 => dta_compat p0 p1
  end.

Lemma pl_compat_sym :
 forall pl0 pl1 : prec_list, pl_compat pl0 pl1 -> pl_compat pl1 pl0.

Lemma mpl_compat_0 :
 forall (c : ad) (pl0 pl1 : prec_list),
 mpl_compat (M1 prec_list c pl0) (M1 prec_list c pl1) -> pl_compat pl0 pl1.

Lemma mpl_compat_1 :
 forall s0 s1 s2 s3 : state,
 mpl_compat (M2 prec_list s0 s1) (M2 prec_list s2 s3) -> mpl_compat s0 s2.

Lemma mpl_compat_2 :
 forall s0 s1 s2 s3 : state,
 mpl_compat (M2 prec_list s0 s1) (M2 prec_list s2 s3) -> mpl_compat s1 s3.

Lemma mpl_compat_3 :
 forall (s0 s1 : state) (pl : prec_list),
 mpl_compat (M2 prec_list s0 s1) (M1 prec_list N0 pl) ->
 mpl_compat s0 (M1 prec_list N0 pl).

Lemma mpl_compat_4 :
 forall (s0 s1 : state) (pl : prec_list),
 mpl_compat (M2 prec_list s0 s1) (M1 prec_list (Npos 1) pl) ->
 mpl_compat s1 (M1 prec_list N0 pl).

Lemma mpl_compat_5 :
 forall (s0 s1 : state) (pl : prec_list) (p : positive),
 mpl_compat (M2 prec_list s0 s1) (M1 prec_list (Npos (xO p)) pl) ->
 mpl_compat s0 (M1 prec_list (Npos p) pl).

Lemma mpl_compat_6 :
 forall (s0 s1 : state) (pl : prec_list) (p : positive),
 mpl_compat (M2 prec_list s0 s1) (M1 prec_list (Npos (xI p)) pl) ->
 mpl_compat s1 (M1 prec_list (Npos p) pl).

Lemma mpl_compat_sym :
 forall s0 s1 : state, mpl_compat s0 s1 -> mpl_compat s1 s0.

Inductive pl_tl_length : prec_list -> nat -> Prop :=
  | pl_tl_O : pl_tl_length prec_empty 0
  | pl_tl_S :
      forall (a : ad) (pl : prec_list) (n : nat),
      pl_tl_length pl n -> pl_tl_length (prec_cons a pl prec_empty) (S n)
  | pl_tl_propag :
      forall (a : ad) (la ls : prec_list) (n : nat),
      pl_tl_length la n ->
      pl_tl_length ls (S n) -> pl_tl_length (prec_cons a la ls) (S n).

Lemma pl_tl_length_pl_compat :
 forall (p0 p1 : prec_list) (n : nat),
 pl_tl_length p0 n -> pl_tl_length p1 n -> pl_compat p0 p1.

Definition pl_tl_length_rec_def_0 (n : nat) :=
  forall (d : preDTA) (pl : prec_list) (tl : term_list),
  pl_tl_length pl n -> liste_reconnait d pl tl -> n = lst_length tl.

Definition pl_tl_length_rec_def_1 (d : preDTA) (pl : prec_list)
  (tl : term_list) :=
  forall n : nat,
  pl_tl_length_rec_def_0 n ->
  pl_tl_length pl (S n) -> liste_reconnait d pl tl -> S n = lst_length tl.

Lemma pl_tl_length_rec_0 : pl_tl_length_rec_def_0 0.

Lemma pl_tl_length_rec_1 :
 forall d : preDTA, pl_tl_length_rec_def_1 d prec_empty tnil.

Lemma pl_tl_length_rec_2 :
 forall (d : preDTA) (a : ad) (la ls : prec_list) (hd : term)
   (tl : term_list),
 reconnaissance d a hd ->
 liste_reconnait d la tl ->
 pl_tl_length_rec_def_1 d la tl ->
 pl_tl_length_rec_def_1 d (prec_cons a la ls) (tcons hd tl).

Lemma pl_tl_length_rec_3 :
 forall (d : preDTA) (a : ad) (la ls : prec_list) (hd : term)
   (tl : term_list),
 liste_reconnait d ls (tcons hd tl) ->
 pl_tl_length_rec_def_1 d ls (tcons hd tl) ->
 pl_tl_length_rec_def_1 d (prec_cons a la ls) (tcons hd tl).

Lemma pl_tl_length_rec_4 :
 forall (p : preDTA) (p0 : prec_list) (t : term_list),
 liste_reconnait p p0 t -> pl_tl_length_rec_def_1 p p0 t.

Lemma pl_tl_length_rec_5 :
 forall n : nat, pl_tl_length_rec_def_0 n -> pl_tl_length_rec_def_0 (S n).

Lemma pl_tl_length_rec_6 :
 forall (d : preDTA) (pl : prec_list) (tl : term_list) (n : nat),
 pl_tl_length pl n -> liste_reconnait d pl tl -> n = lst_length tl.

Definition pl_compatible (pl0 pl1 : prec_list) : Prop :=
  exists n : nat, pl_tl_length pl0 n /\ pl_tl_length pl1 n.

Definition st_compatible (s0 s1 : state) : Prop :=
  forall (c : ad) (pl0 pl1 : prec_list),
  MapGet prec_list s0 c = Some pl0 ->
  MapGet prec_list s1 c = Some pl1 -> pl_compatible pl0 pl1.

Definition predta_compatible (d0 d1 : preDTA) : Prop :=
  forall s0 s1 : state,
  state_in_dta d0 s0 -> state_in_dta d1 s1 -> st_compatible s0 s1.

Definition dta_compatible (d0 d1 : DTA) : Prop :=
  match d0, d1 with
  | dta p0 a0, dta p1 a1 => predta_compatible p0 p1
  end.

Lemma pl_compatible_sym :
 forall pl0 pl1 : prec_list, pl_compatible pl0 pl1 -> pl_compatible pl1 pl0.

Lemma pl_compatible_empt_r :
 forall p : prec_list, pl_compatible p prec_empty -> p = prec_empty.

Lemma pl_compatible_empt_l :
 forall p : prec_list, pl_compatible prec_empty p -> p = prec_empty.

Lemma pl_compatible_cons_r :
 forall (p : prec_list) (a : ad) (la ls : prec_list),
 pl_compatible p (prec_cons a la ls) ->
 exists a0 : ad,
   (exists la0 : prec_list,
      (exists ls0 : prec_list, p = prec_cons a0 la0 ls0)).

Lemma pl_compatible_cons_l :
 forall (p : prec_list) (a : ad) (la ls : prec_list),
 pl_compatible (prec_cons a la ls) p ->
 exists a0 : ad,
   (exists la0 : prec_list,
      (exists ls0 : prec_list, p = prec_cons a0 la0 ls0)).

Lemma pl_compatible_compat :
 forall p0 p1 : prec_list, pl_compatible p0 p1 -> pl_compat p0 p1.

Definition st_compatible_compat_def (s0 : state) : Prop :=
  forall s1 : state, st_compatible s0 s1 -> mpl_compat s0 s1.

Lemma st_compatible_compat_0 : st_compatible_compat_def (M0 prec_list).

Lemma st_compatible_compat_1 :
 forall (a : ad) (a0 : prec_list),
 st_compatible_compat_def (M1 prec_list a a0).

Lemma st_compatible_compat_2 :
 forall m : Map prec_list,
 st_compatible_compat_def m ->
 forall m0 : Map prec_list,
 st_compatible_compat_def m0 -> st_compatible_compat_def (M2 prec_list m m0).

Lemma st_compatible_compat :
 forall s0 s1 : state, st_compatible s0 s1 -> mpl_compat s0 s1.

Definition predta_compatible_compat_def (d0 : preDTA) : Prop :=
  forall d1 : preDTA, predta_compatible d0 d1 -> dta_compat d0 d1.

Lemma predta_compatible_compat_0 : predta_compatible_compat_def (M0 state).

Lemma predta_compatible_compat_1 :
 forall (a : ad) (a0 : state), predta_compatible_compat_def (M1 state a a0).

Lemma predta_compatible_compat_2 :
 forall m : Map state,
 predta_compatible_compat_def m ->
 forall m0 : Map state,
 predta_compatible_compat_def m0 ->
 predta_compatible_compat_def (M2 state m m0).

Lemma predta_compatible_compat :
 forall d0 d1 : preDTA, predta_compatible d0 d1 -> dta_compat d0 d1.

Lemma dta_compatible_compat :
 forall d0 d1 : DTA, dta_compatible d0 d1 -> DTA_compat d0 d1.

Definition signature : Set := Map nat.

Definition state_correct_wrt_sign (s : state) (sigma : signature) : Prop :=
  forall (a : ad) (p : prec_list),
  MapGet prec_list s a = Some p ->
  exists n : nat, MapGet nat sigma a = Some n /\ pl_tl_length p n.

Definition predta_correct_wrt_sign (d : preDTA) (sigma : signature) : Prop :=
  forall (a : ad) (s : state),
  MapGet state d a = Some s -> state_correct_wrt_sign s sigma.

Definition dta_correct_wrt_sign (d : DTA) (sigma : signature) : Prop :=
  match d with
  | dta d a => predta_correct_wrt_sign d sigma
  end.

Lemma states_correct_wrt_sign_compatibles :
 forall (sigma : signature) (s s' : state),
 state_correct_wrt_sign s sigma ->
 state_correct_wrt_sign s' sigma -> st_compatible s s'.

Lemma predtas_correct_wrt_sign_compatibles :
 forall (sigma : signature) (d d' : preDTA),
 predta_correct_wrt_sign d sigma ->
 predta_correct_wrt_sign d' sigma -> predta_compatible d d'.

Lemma dtas_correct_wrt_sign_compatibles :
 forall (sigma : signature) (d d' : DTA),
 dta_correct_wrt_sign d sigma ->
 dta_correct_wrt_sign d' sigma -> dta_compatible d d'.

Fixpoint pl_compat_check (p : prec_list) : option nat :=
  match p with
  | prec_empty => Some 0
  | prec_cons a la ls =>
      match ls with
      | prec_empty =>
          match pl_compat_check la with
          | None => None
          | Some n => Some (S n)
          end
      | prec_cons _ _ _ =>
          match pl_compat_check la, pl_compat_check ls with
          | None, _ => None
          | _, None => None
          | Some n, Some m =>
              if beq_nat (S n) m then Some m else None
          end
      end
  end.

Lemma pl_compat_check_correct :
 forall (p : prec_list) (n : nat),
 pl_tl_length p n -> pl_compat_check p = Some n.

Lemma pl_compat_check_complete :
 forall (p : prec_list) (n : nat),
 pl_compat_check p = Some n -> pl_tl_length p n.

Inductive pre_ad : Set :=
  | pre_ad_empty : pre_ad
  | pre_ad_O : pre_ad -> pre_ad
  | pre_ad_I : pre_ad -> pre_ad.

Fixpoint pre_ad_concat (pa : pre_ad) : ad -> ad :=
  fun a : ad =>
  match pa with
  | pre_ad_empty => a
  | pre_ad_O pa' => pre_ad_concat pa' (Ndouble a)
  | pre_ad_I pa' => pre_ad_concat pa' (Ndouble_plus_one a)
  end.

Fixpoint st_compat_check_0 (pa : pre_ad) (sigma : signature) 
 (s : state) {struct s} : bool :=
  match s with
  | M0 => true
  | M1 a p =>
      match pl_compat_check p, MapGet nat sigma (pre_ad_concat pa a) with
      | None, _ => false
      | _, None => false
      | Some n, Some m => beq_nat n m
      end
  | M2 x y =>
      st_compat_check_0 (pre_ad_O pa) sigma x &&
      st_compat_check_0 (pre_ad_I pa) sigma y
  end.

Definition st_compat_check (s : state) (sigma : signature) : bool :=
  st_compat_check_0 pre_ad_empty sigma s.

Fixpoint predta_compat_check (d : preDTA) : signature -> bool :=
  fun sigma : signature =>
  match d with
  | M0 => true
  | M1 a s => st_compat_check s sigma
  | M2 x y => predta_compat_check x sigma && predta_compat_check y sigma
  end.

Definition dta_compat_check (d : DTA) (sigma : signature) : bool :=
  match d with
  | dta p a => predta_compat_check p sigma
  end.

Definition state_correct_wrt_sign_with_offset (s : state) 
  (sigma : signature) (pa : pre_ad) : Prop :=
  forall (a : ad) (p : prec_list),
  MapGet prec_list s a = Some p ->
  exists n : nat,
    MapGet nat sigma (pre_ad_concat pa a) = Some n /\ pl_tl_length p n.

Lemma state_correct_wrt_sign_with_offset_M2 :
 forall (s0 s1 : state) (sigma : signature) (pa : pre_ad),
 state_correct_wrt_sign_with_offset (M2 prec_list s0 s1) sigma pa ->
 state_correct_wrt_sign_with_offset s0 sigma (pre_ad_O pa) /\
 state_correct_wrt_sign_with_offset s1 sigma (pre_ad_I pa).

Lemma predta_correct_wrt_sign_M2 :
 forall (d0 d1 : preDTA) (sigma : signature),
 predta_correct_wrt_sign (M2 state d0 d1) sigma ->
 predta_correct_wrt_sign d0 sigma /\ predta_correct_wrt_sign d1 sigma.

Lemma st_compat_check_0_correct :
 forall (s : state) (sigma : signature) (pa : pre_ad),
 state_correct_wrt_sign_with_offset s sigma pa ->
 st_compat_check_0 pa sigma s = true.

Lemma st_compat_check_0_complete :
 forall (s : state) (sigma : signature) (pa : pre_ad),
 st_compat_check_0 pa sigma s = true ->
 state_correct_wrt_sign_with_offset s sigma pa.

Lemma st_compat_check_correct :
 forall (s : state) (sigma : signature),
 state_correct_wrt_sign s sigma -> st_compat_check s sigma = true.

Lemma st_compat_check_complete :
 forall (s : state) (sigma : signature),
 st_compat_check s sigma = true -> state_correct_wrt_sign s sigma.

Lemma predta_compat_check_correct :
 forall (d : preDTA) (sigma : signature),
 predta_correct_wrt_sign d sigma -> predta_compat_check d sigma = true.

Lemma predta_compat_check_complete :
 forall (d : preDTA) (sigma : signature),
 predta_compat_check d sigma = true -> predta_correct_wrt_sign d sigma.

Lemma dta_compat_check_correct :
 forall (d : DTA) (sigma : signature),
 dta_correct_wrt_sign d sigma -> dta_compat_check d sigma = true.

Lemma dta_compat_check_complete :
 forall (d : DTA) (sigma : signature),
 dta_compat_check d sigma = true -> dta_correct_wrt_sign d sigma. *)

Require Import refcorrect.
(* refcorrect:
Require Import Bool.
Require Import NArith Ndec.
From IntMap Require Import Allmaps.
Require Import bases.
Require Import defs.

Definition prec_list_ref_ok (p : prec_list) (d : preDTA) : Prop :=
  forall a : ad,
  prec_occur p a -> exists s : state, MapGet state d a = Some s.

Definition state_ref_ok (s : state) (d : preDTA) : Prop :=
  forall (a : ad) (p : prec_list),
  MapGet prec_list s a = Some p -> prec_list_ref_ok p d.

Definition preDTA_ref_ok (d : preDTA) : Prop :=
  forall (a : ad) (s : state) (c : ad) (pl : prec_list) (b : ad),
  MapGet state d a = Some s ->
  MapGet prec_list s c = Some pl ->
  prec_occur pl b -> exists s0 : state, MapGet state d b = Some s0.

Definition preDTA_ref_ok_distinct (d d' : preDTA) : Prop :=
  forall (a : ad) (s : state),
  MapGet state d a = Some s -> state_ref_ok s d'.

Definition DTA_ref_ok (d : DTA) : Prop :=
  match d with
  | dta p a => preDTA_ref_ok p
  end.

Lemma prec_list_ref_ok_destr :
 forall (a : ad) (la ls : prec_list) (d : preDTA),
 prec_list_ref_ok (prec_cons a la ls) d ->
 prec_list_ref_ok la d /\ prec_list_ref_ok ls d.

Lemma state_ref_ok_M2_destr :
 forall (s0 s1 : state) (d : preDTA),
 state_ref_ok (M2 prec_list s0 s1) d ->
 state_ref_ok s0 d /\ state_ref_ok s1 d.

Lemma preDTA_ref_ok_def :
 forall d : preDTA,
 preDTA_ref_ok d <->
 (forall (a : ad) (s : state),
  MapGet state d a = Some s -> state_ref_ok s d).

Lemma preDTA_ref_ok_distinct_dest :
 forall d0 d1 d : preDTA,
 preDTA_ref_ok_distinct (M2 state d0 d1) d ->
 preDTA_ref_ok_distinct d0 d /\ preDTA_ref_ok_distinct d1 d.

Definition addr_in_dta_check (d : preDTA) (a : ad) : bool :=
  match MapGet state d a with
  | None => false
  | Some _ => true
  end.

Fixpoint prec_list_ref_ok_check (p : prec_list) : preDTA -> bool :=
  fun d : preDTA =>
  match p with
  | prec_empty => true
  | prec_cons a la ls =>
      addr_in_dta_check d a &&
      (prec_list_ref_ok_check la d && prec_list_ref_ok_check ls d)
  end.

Lemma prec_list_ref_ok_check_correct :
 forall (p : prec_list) (d : preDTA),
 prec_list_ref_ok p d -> prec_list_ref_ok_check p d = true.

Lemma prec_list_ref_ok_check_complete :
 forall (p : prec_list) (d : preDTA),
 prec_list_ref_ok_check p d = true -> prec_list_ref_ok p d.

Fixpoint state_ref_ok_check (s : state) : preDTA -> bool :=
  fun d : preDTA =>
  match s with
  | M0 => true
  | M1 a p => prec_list_ref_ok_check p d
  | M2 x y => state_ref_ok_check x d && state_ref_ok_check y d
  end.

Lemma state_ref_ok_check_correct :
 forall (s : state) (d : preDTA),
 state_ref_ok s d -> state_ref_ok_check s d = true.

Lemma state_ref_ok_check_complete :
 forall (s : state) (d : preDTA),
 state_ref_ok_check s d = true -> state_ref_ok s d.

Fixpoint predta_ref_ok_check_0 (d : preDTA) : preDTA -> bool :=
  fun d' : preDTA =>
  match d with
  | M0 => true
  | M1 a s => state_ref_ok_check s d'
  | M2 x y => predta_ref_ok_check_0 x d' && predta_ref_ok_check_0 y d'
  end.

Definition predta_ref_ok_check (d : preDTA) : bool :=
  predta_ref_ok_check_0 d d.

Lemma predta_ref_ok_check_correct_0 :
 forall d d' : preDTA,
 preDTA_ref_ok_distinct d d' -> predta_ref_ok_check_0 d d' = true.

Lemma predta_ref_ok_check_complete_0 :
 forall d d' : preDTA,
 predta_ref_ok_check_0 d d' = true -> preDTA_ref_ok_distinct d d'.

Lemma predta_ref_ok_check_correct :
 forall d : preDTA, preDTA_ref_ok d -> predta_ref_ok_check d = true.

Lemma predta_ref_ok_check_complete :
 forall d : preDTA, predta_ref_ok_check d = true -> preDTA_ref_ok d.

Definition dta_ref_ok_check (d : DTA) : bool :=
  match d with
  | dta p a => predta_ref_ok_check p
  end.

Lemma dta_ref_ok_check_correct :
 forall d : DTA, DTA_ref_ok d -> dta_ref_ok_check d = true.

Lemma dta_ref_ok_check_complete :
 forall d : DTA, dta_ref_ok_check d = true -> DTA_ref_ok d.

Definition addr_in_preDTA (d : preDTA) (a : ad) : Prop :=
  exists s : state, MapGet state d a = Some s.

Definition DTA_main_state_correct (d : DTA) : Prop :=
  match d with
  | dta p a => addr_in_preDTA p a
  end.

Definition DTA_main_state_correct_check (d : DTA) : bool :=
  match d with
  | dta p a =>
      match MapGet state p a with
      | None => false
      | Some _ => true
      end
  end.

Lemma DTA_main_state_correct_check_correct :
 forall d : DTA,
 DTA_main_state_correct d -> DTA_main_state_correct_check d = true.

Lemma DTA_main_state_correct_check_complete :
 forall d : DTA,
 DTA_main_state_correct_check d = true -> DTA_main_state_correct d. *)

Require Import inter.
(* inter:
Require Import Arith.
Require Import NArith Ndec.
Require Import ZArith.
Require Import Bool.
From IntMap Require Import Allmaps.
Require Import bases.
Require Import defs.
Require Import semantics.
Require Import pl_path.
Require Import signature.

Fixpoint iad_conv_aux_0 (p : positive) : positive :=
  match p with
  | xH => 2%positive
  | xO p' => xO (xO (iad_conv_aux_0 p'))
  | xI p' => xO (xI (iad_conv_aux_0 p'))
  end.

Fixpoint iad_conv_aux_1 (p : positive) : positive :=
  match p with
  | xH => 1%positive
  | xO p' => xO (xO (iad_conv_aux_1 p'))
  | xI p' => xI (xO (iad_conv_aux_1 p'))
  end.

Fixpoint iad_conv_aux_2 (p0 p1 : positive) {struct p1} : positive :=
  match p0, p1 with
  | xH, xH => 3%positive
  | xH, xO p1' => xI (xO (iad_conv_aux_0 p1'))
  | xH, xI p1' => xI (xI (iad_conv_aux_0 p1'))
  | xO p0', xH => xO (xI (iad_conv_aux_1 p0'))
  | xO p0', xO p1' => xO (xO (iad_conv_aux_2 p0' p1'))
  | xO p0', xI p1' => xO (xI (iad_conv_aux_2 p0' p1'))
  | xI p0', xH => xI (xI (iad_conv_aux_1 p0'))
  | xI p0', xO p1' => xI (xO (iad_conv_aux_2 p0' p1'))
  | xI p0', xI p1' => xI (xI (iad_conv_aux_2 p0' p1'))
  end.

Definition iad_conv (a0 a1 : ad) : ad :=
  match a0, a1 with
  | N0, N0 => N0
  | N0, Npos p1 => Npos (iad_conv_aux_0 p1)
  | Npos p0, N0 => Npos (iad_conv_aux_1 p0)
  | Npos p0, Npos p1 => Npos (iad_conv_aux_2 p0 p1)
  end.

Lemma iad_conv_aux_0_inj :
 forall p0 p1 : positive, iad_conv_aux_0 p0 = iad_conv_aux_0 p1 -> p0 = p1.

Lemma iad_conv_aux_1_inj :
 forall p0 p1 : positive, iad_conv_aux_1 p0 = iad_conv_aux_1 p1 -> p0 = p1.

Lemma iad_conv_aux_0_1_img_disj :
 forall p0 p1 : positive, iad_conv_aux_0 p0 <> iad_conv_aux_1 p1.

Lemma iad_conv_aux_img_disj :
 forall p0 p1 p2 : positive,
 iad_conv_aux_0 p0 <> iad_conv_aux_2 p1 p2 /\
 iad_conv_aux_1 p0 <> iad_conv_aux_2 p1 p2.

Lemma iad_conv_aux_0_2_img_disj :
 forall p0 p1 p2 : positive, iad_conv_aux_0 p0 <> iad_conv_aux_2 p1 p2.

Lemma iad_conv_aux_1_2_img_disj :
 forall p0 p1 p2 : positive, iad_conv_aux_1 p0 <> iad_conv_aux_2 p1 p2.

Lemma iad_conv_aux_2_inj :
 forall p0 p1 p2 p3 : positive,
 iad_conv_aux_2 p0 p1 = iad_conv_aux_2 p2 p3 -> p0 = p2 /\ p1 = p3.

Lemma iad_conv_inj :
 forall a0 a1 a2 a3 : ad,
 iad_conv a0 a1 = iad_conv a2 a3 -> a0 = a2 /\ a1 = a3.

Definition iad_conv_prop (p : positive) : Prop :=
  (exists q : positive, p = iad_conv_aux_0 q) \/
  (exists q : positive, p = iad_conv_aux_1 q) \/
  (exists q : positive, (exists r : positive, p = iad_conv_aux_2 q r)).

Lemma iad_conv_surj_0 :
 forall p : positive, iad_conv_prop p -> iad_conv_prop (xO (xO p)).

Lemma iad_conv_surj_1 :
 forall p : positive, iad_conv_prop p -> iad_conv_prop (xO (xI p)).

Lemma iad_conv_surj_2 :
 forall p : positive, iad_conv_prop p -> iad_conv_prop (xI (xO p)).

Lemma iad_conv_surj_3 :
 forall p : positive, iad_conv_prop p -> iad_conv_prop (xI (xI p)).

Lemma iad_conv_surj_4 :
 forall p : positive,
 iad_conv_prop p /\ iad_conv_prop (xO p) /\ iad_conv_prop (xI p).

Lemma iad_conv_surj_5 : forall p : positive, iad_conv_prop p.

Lemma iad_conv_surj :
 forall a : ad, exists b : ad, (exists c : ad, a = iad_conv b c).

Inductive ad_couple : Set :=
    cpla : ad -> ad -> ad_couple.

Fixpoint iad_conv_inv_0 (p : positive) : ad_couple :=
  match p with
  | xH => cpla (Npos 1) N0
  | xO xH => cpla N0 (Npos 1)
  | xI xH => cpla (Npos 1) (Npos 1)
  | xO (xO p') =>
      match iad_conv_inv_0 p' with
      | cpla N0 N0 => cpla N0 N0
      | cpla N0 (Npos p1) => cpla N0 (Npos (xO p1))
      | cpla (Npos p0) N0 => cpla (Npos (xO p0)) N0
      | cpla (Npos p0) (Npos p1) => cpla (Npos (xO p0)) (Npos (xO p1))
      end
  | xO (xI p') =>
      match iad_conv_inv_0 p' with
      | cpla N0 N0 => cpla N0 (Npos 1)
      | cpla N0 (Npos p1) => cpla N0 (Npos (xI p1))
      | cpla (Npos p0) N0 => cpla (Npos (xO p0)) (Npos 1)
      | cpla (Npos p0) (Npos p1) => cpla (Npos (xO p0)) (Npos (xI p1))
      end
  | xI (xO p') =>
      match iad_conv_inv_0 p' with
      | cpla N0 N0 => cpla (Npos 1) N0
      | cpla N0 (Npos p1) => cpla (Npos 1) (Npos (xO p1))
      | cpla (Npos p0) N0 => cpla (Npos (xI p0)) N0
      | cpla (Npos p0) (Npos p1) => cpla (Npos (xI p0)) (Npos (xO p1))
      end
  | xI (xI p') =>
      match iad_conv_inv_0 p' with
      | cpla N0 N0 => cpla (Npos 1) (Npos 1)
      | cpla N0 (Npos p1) => cpla (Npos 1) (Npos (xI p1))
      | cpla (Npos p0) N0 => cpla (Npos (xI p0)) (Npos 1)
      | cpla (Npos p0) (Npos p1) => cpla (Npos (xI p0)) (Npos (xI p1))
      end
  end.

Definition iad_conv_inv (a : ad) : ad_couple :=
  match a with
  | N0 => cpla N0 N0
  | Npos p => iad_conv_inv_0 p
  end.

Lemma iad_inv_0 :
 forall p : positive, iad_conv_inv_0 (iad_conv_aux_0 p) = cpla N0 (Npos p).

Lemma iad_inv_1 :
 forall p : positive, iad_conv_inv_0 (iad_conv_aux_1 p) = cpla (Npos p) N0.

Lemma iad_inv_2 :
 forall p0 p1 : positive,
 iad_conv_inv_0 (iad_conv_aux_2 p0 p1) = cpla (Npos p0) (Npos p1).

Lemma iad_inv_inv_0 :
 forall a0 a1 : ad, iad_conv_inv (iad_conv a0 a1) = cpla a0 a1.

Lemma iad_inv_inv_1 :
 forall a a0 a1 : ad, iad_conv_inv a = cpla a0 a1 -> iad_conv a0 a1 = a.

Fixpoint pl_produit_0 (a : ad) (la pl : prec_list) 
 (n : nat) {struct n} : prec_list -> prec_list :=
  fun l : prec_list =>
  match n with
  | O => prec_empty
  | S m =>
      match pl with
      | prec_empty => l
      | prec_cons a0 la0 ls0 =>
          prec_cons (iad_conv a a0) (pl_produit_1 la m la0)
            (pl_produit_0 a la ls0 m l)
      end
  end
 
 with pl_produit_1 (pl0 : prec_list) (n : nat) {struct n} :
 prec_list -> prec_list :=
  fun pl1 : prec_list =>
  match n with
  | O => prec_empty
  | S m =>
      match pl0, pl1 with
      | prec_empty, prec_empty => prec_empty
      | prec_empty, prec_cons a1 la1 ls1 => prec_empty
      | prec_cons a0 la0 ls0, prec_empty => prec_empty
      | prec_cons a0 la0 ls0, prec_cons a1 la1 ls1 =>
          pl_produit_0 a0 la0 (prec_cons a1 la1 ls1) m
            (pl_produit_1 ls0 m (prec_cons a1 la1 ls1))
      end
  end.

Fixpoint pl_card (pl : prec_list) : nat :=
  match pl with
  | prec_empty => 1
  | prec_cons a la ls => S (pl_card la + pl_card ls)
  end.

Definition pl_essence (pl0 pl1 : prec_list) : nat :=
  pl_card pl0 + pl_card pl1.

Definition pl_produit (pl0 pl1 : prec_list) : prec_list :=
  pl_produit_1 pl0 (pl_essence pl0 pl1) pl1.

Lemma pl_card_0 : forall pl : prec_list, 1 <= pl_card pl.

Lemma pl_ess_aux_0 : forall pl : prec_list, 1 <= pl_card pl.

Lemma pl_ess_aux_1 :
 forall (a : ad) (la ls : prec_list),
 S (pl_card la) <= pl_card (prec_cons a la ls).

Lemma pl_ess_aux_2 :
 forall (a : ad) (la ls : prec_list),
 S (pl_card ls) <= pl_card (prec_cons a la ls).

Lemma pl_ess_invar_0 : forall pl0 pl1 : prec_list, 1 <= pl_essence pl0 pl1.

Lemma pl_ess_invar_1 :
 forall (a a' : ad) (la ls la' ls' : prec_list),
 S (pl_essence la (prec_cons a' la' ls')) <=
 pl_essence (prec_cons a la ls) (prec_cons a' la' ls').

Lemma pl_ess_invar_2 :
 forall (a a' : ad) (la ls la' ls' : prec_list),
 S (pl_essence ls (prec_cons a' la' ls')) <=
 pl_essence (prec_cons a la ls) (prec_cons a' la' ls').

Lemma pl_ess_invar_3 :
 forall (a' : ad) (la la' ls' : prec_list),
 S (pl_essence la la') <= pl_essence la (prec_cons a' la' ls').

Lemma pl_ess_invar_4 :
 forall (a' : ad) (la la' ls' : prec_list),
 S (pl_essence la ls') <= pl_essence la (prec_cons a' la' ls').

Lemma pl_ess_invar_5 : forall pl0 pl1 : prec_list, 2 <= pl_essence pl0 pl1.

Fixpoint pl_prof (pl : prec_list) : nat :=
  match pl with
  | prec_empty => 0
  | prec_cons a la ls => S (max (pl_prof la) (pl_prof ls))
  end.

Lemma indprinciple_0 :
 forall P0 P1 : prec_list -> prec_list -> Prop,
 (forall p : prec_list, P0 p prec_empty) ->
 (forall p : prec_list, P1 p prec_empty) ->
 (forall p : prec_list, P1 prec_empty p) ->
 (forall (a : ad) (la ls p : prec_list),
  P0 p ls -> P1 p la -> P0 p (prec_cons a la ls)) ->
 (forall (a : ad) (la ls p : prec_list),
  P0 la p -> P1 ls p -> P1 (prec_cons a la ls) p) ->
 forall n : nat,
 (forall p p' : prec_list,
  pl_prof p <= n -> pl_prof p' <= n -> P0 p p' /\ P1 p p') ->
 forall p p' : prec_list,
 pl_prof p <= S n -> pl_prof p' <= S n -> P0 p p' /\ P1 p p'.

Lemma indprinciple_1 :
 forall P0 P1 : prec_list -> prec_list -> Prop,
 (forall p : prec_list, P0 p prec_empty) ->
 (forall p : prec_list, P1 p prec_empty) ->
 (forall p : prec_list, P1 prec_empty p) ->
 (forall (a : ad) (la ls p : prec_list),
  P0 p ls -> P1 p la -> P0 p (prec_cons a la ls)) ->
 (forall (a : ad) (la ls p : prec_list),
  P0 la p -> P1 ls p -> P1 (prec_cons a la ls) p) ->
 forall p p' : prec_list,
 pl_prof p <= 0 -> pl_prof p' <= 0 -> P0 p p' /\ P1 p p'.

Lemma indprinciple_2 :
 forall P0 P1 : prec_list -> prec_list -> Prop,
 (forall p : prec_list, P0 p prec_empty) ->
 (forall p : prec_list, P1 p prec_empty) ->
 (forall p : prec_list, P1 prec_empty p) ->
 (forall (a : ad) (la ls p : prec_list),
  P0 p ls -> P1 p la -> P0 p (prec_cons a la ls)) ->
 (forall (a : ad) (la ls p : prec_list),
  P0 la p -> P1 ls p -> P1 (prec_cons a la ls) p) ->
 forall (n : nat) (p p' : prec_list),
 pl_prof p <= n -> pl_prof p' <= n -> P0 p p' /\ P1 p p'.

Lemma indprinciple_pl :
 forall P0 P1 : prec_list -> prec_list -> Prop,
 (forall p : prec_list, P0 p prec_empty) ->
 (forall p : prec_list, P1 p prec_empty) ->
 (forall p : prec_list, P1 prec_empty p) ->
 (forall (a : ad) (la ls p : prec_list),
  P0 p ls -> P1 p la -> P0 p (prec_cons a la ls)) ->
 (forall (a : ad) (la ls p : prec_list),
  P0 la p -> P1 ls p -> P1 (prec_cons a la ls) p) ->
 forall p p' : prec_list, P0 p p' /\ P1 p p'.

Definition pl_produit_0_incr (p0 p1 : prec_list) : Prop :=
  forall (a : ad) (l : prec_list) (n : nat),
  pl_essence p0 p1 <= n ->
  pl_produit_0 a p0 p1 (pl_essence p0 p1) l = pl_produit_0 a p0 p1 n l.

Definition pl_produit_1_incr (p0 p1 : prec_list) : Prop :=
  forall n : nat,
  pl_essence p0 p1 <= n ->
  pl_produit_1 p0 (pl_essence p0 p1) p1 = pl_produit_1 p0 n p1.

Lemma pl_product_0_0 : forall p : prec_list, pl_produit_0_incr p prec_empty.

Lemma pl_product_0_1 : forall p : prec_list, pl_produit_1_incr p prec_empty.

Lemma pl_product_0_2 : forall p : prec_list, pl_produit_1_incr prec_empty p.

Lemma pl_product_0_3 :
 forall (a : ad) (la ls p : prec_list),
 pl_produit_0_incr p ls ->
 pl_produit_1_incr p la -> pl_produit_0_incr p (prec_cons a la ls).

Lemma pl_product_0_4 :
 forall (a : ad) (la ls p : prec_list),
 pl_produit_0_incr la p ->
 pl_produit_1_incr ls p -> pl_produit_1_incr (prec_cons a la ls) p.

Lemma pl_product_0_5 :
 forall p p' : prec_list, pl_produit_0_incr p p' /\ pl_produit_1_incr p p'.

Lemma pl_product_0 :
 forall p0 p1 : prec_list,
 (forall (a : ad) (l : prec_list) (n : nat),
  pl_essence p0 p1 <= n ->
  pl_produit_0 a p0 p1 (pl_essence p0 p1) l = pl_produit_0 a p0 p1 n l) /\
 (forall n : nat,
  pl_essence p0 p1 <= n ->
  pl_produit_1 p0 (pl_essence p0 p1) p1 = pl_produit_1 p0 n p1).

Lemma pl_product_0_invar_essence :
 forall (p0 p1 : prec_list) (n : nat),
 pl_essence p0 p1 <= n ->
 pl_produit_1 p0 (pl_essence p0 p1) p1 = pl_produit_1 p0 n p1.

Lemma pl_product_1 :
 forall (a : ad) (la pl l : prec_list) (n : nat),
 pl_essence la pl <= n ->
 pl_produit_0 a la pl n l = prec_empty -> pl = prec_empty.

Definition pl_tl_length_prod_def_0 (pl0 pl1 : prec_list) : Prop :=
  forall (l : prec_list) (a : ad) (n m : nat),
  pl_essence pl0 pl1 <= m ->
  pl_tl_length pl0 n ->
  pl_tl_length l (S n) \/ l = prec_empty ->
  (pl_tl_length pl1 (S n) -> pl_tl_length (pl_produit_0 a pl0 pl1 m l) (S n)) /\
  (pl1 = prec_empty ->
   (pl_tl_length l (S n) -> pl_tl_length (pl_produit_0 a pl0 pl1 m l) (S n)) /\
   (l = prec_empty -> pl_produit_0 a pl0 pl1 m l = prec_empty)).

Definition pl_tl_length_prod_def_1 (pl0 pl1 : prec_list) : Prop :=
  forall n m : nat,
  pl_tl_length pl0 n ->
  pl_tl_length pl1 n ->
  pl_essence pl0 pl1 <= m -> pl_tl_length (pl_produit_1 pl0 m pl1) n.

Lemma pl_tl_length_prod_0 :
 forall p : prec_list, pl_tl_length_prod_def_0 p prec_empty.

Lemma pl_tl_length_prod_1 :
 forall p : prec_list, pl_tl_length_prod_def_1 p prec_empty.

Lemma pl_tl_length_prod_2 :
 forall p : prec_list, pl_tl_length_prod_def_1 prec_empty p.

Lemma pl_tl_length_prod_3 :
 forall (a : ad) (la ls p : prec_list),
 pl_tl_length_prod_def_0 p ls ->
 pl_tl_length_prod_def_1 p la ->
 pl_tl_length_prod_def_0 p (prec_cons a la ls).

Lemma pl_tl_length_prod_4 :
 forall (a : ad) (la ls p : prec_list),
 pl_tl_length_prod_def_0 la p ->
 pl_tl_length_prod_def_1 ls p ->
 pl_tl_length_prod_def_1 (prec_cons a la ls) p.

Lemma pl_tl_length_prod_5 :
 forall p p' : prec_list,
 pl_tl_length_prod_def_0 p p' /\ pl_tl_length_prod_def_1 p p'.

Lemma pl_tl_length_prod :
 forall (pl0 pl1 : prec_list) (n : nat),
 pl_tl_length pl0 n ->
 pl_tl_length pl1 n -> pl_tl_length (pl_produit pl0 pl1) n.

Lemma pl_produit_path_incl_0 :
 forall (n : nat) (a : ad) (la pl l : prec_list) (plp : pl_path),
 pl_path_incl plp l ->
 plp <> pl_path_nil ->
 pl_essence la pl <= n -> pl_path_incl plp (pl_produit_0 a la pl n l).

Fixpoint pl_path_product (p0 p1 : pl_path) {struct p1} : pl_path :=
  match p0, p1 with
  | pl_path_nil, pl_path_nil => pl_path_nil
  | pl_path_nil, pl_path_cons a b => pl_path_nil
  | pl_path_cons a b, pl_path_nil => pl_path_nil
  | pl_path_cons a0 b0, pl_path_cons a1 b1 =>
      pl_path_cons (iad_conv a0 a1) (pl_path_product b0 b1)
  end.

Lemma pl_path_product_n :
 forall (n : nat) (p0 p1 : pl_path),
 pl_path_length p0 = n ->
 pl_path_length p1 = n -> pl_path_length (pl_path_product p0 p1) = n.

Lemma pl_produit_path_incl_inj :
 forall (plp0 plp1 plp2 plp3 : pl_path) (n : nat),
 pl_path_length plp0 = n ->
 pl_path_length plp1 = n ->
 pl_path_length plp2 = n ->
 pl_path_length plp3 = n ->
 pl_path_product plp0 plp1 = pl_path_product plp2 plp3 ->
 plp0 = plp2 /\ plp1 = plp3.

Definition pl_produit_path_incl_def_0 (pl0 pl1 : prec_list) :=
  forall (n m : nat) (plp0 plp1 : pl_path) (a : ad) (l : prec_list),
  pl_path_incl plp0 (prec_cons a pl0 prec_empty) ->
  pl_tl_length pl0 n ->
  pl_path_incl plp1 pl1 ->
  pl_tl_length pl1 (S n) ->
  pl_essence pl0 pl1 <= m ->
  pl_path_incl (pl_path_product plp0 plp1) (pl_produit_0 a pl0 pl1 m l).

Definition pl_produit_path_incl_def_1 (pl0 pl1 : prec_list) :=
  forall (n m : nat) (plp0 plp1 : pl_path),
  pl_path_incl plp0 pl0 ->
  pl_tl_length pl0 n ->
  pl_path_incl plp1 pl1 ->
  pl_tl_length pl1 n ->
  pl_essence pl0 pl1 <= m ->
  pl_path_incl (pl_path_product plp0 plp1) (pl_produit_1 pl0 m pl1).

Lemma pl_produit_path_incl_1_0 :
 forall p : prec_list, pl_produit_path_incl_def_0 p prec_empty.

Lemma pl_produit_path_incl_1_1 :
 forall p : prec_list, pl_produit_path_incl_def_1 p prec_empty.

Lemma pl_produit_path_incl_1_2 :
 forall p : prec_list, pl_produit_path_incl_def_1 prec_empty p.

Lemma pl_produit_path_incl_1_3 :
 forall (a : ad) (la ls p : prec_list),
 pl_produit_path_incl_def_0 p ls ->
 pl_produit_path_incl_def_1 p la ->
 pl_produit_path_incl_def_0 p (prec_cons a la ls).

Lemma pl_produit_path_incl_1_4 :
 forall (a : ad) (la ls p : prec_list),
 pl_produit_path_incl_def_0 la p ->
 pl_produit_path_incl_def_1 ls p ->
 pl_produit_path_incl_def_1 (prec_cons a la ls) p.

Lemma pl_produit_path_incl_1_5 :
 forall p p' : prec_list,
 pl_produit_path_incl_def_0 p p' /\ pl_produit_path_incl_def_1 p p'.

Lemma pl_produit_path_incl_1 :
 forall (pl0 pl1 : prec_list) (n m : nat) (plp0 plp1 : pl_path),
 pl_path_incl plp0 pl0 ->
 pl_tl_length pl0 n ->
 pl_path_incl plp1 pl1 ->
 pl_tl_length pl1 n ->
 pl_essence pl0 pl1 <= m ->
 pl_path_incl (pl_path_product plp0 plp1) (pl_produit_1 pl0 m pl1).

Lemma pl_produit_path_incl_2 :
 forall (pl0 pl1 : prec_list) (n : nat) (plp0 plp1 : pl_path),
 pl_path_incl plp0 pl0 ->
 pl_tl_length pl0 n ->
 pl_path_incl plp1 pl1 ->
 pl_tl_length pl1 n ->
 pl_path_incl (pl_path_product plp0 plp1) (pl_produit pl0 pl1).

Definition pl_produit_path_incl_def_2 (pl0 pl1 : prec_list) :=
  forall (n m : nat) (plp : pl_path) (a : ad) (l : prec_list),
  pl_path_incl plp (pl_produit_0 a pl0 pl1 m l) ->
  pl_tl_length pl0 n ->
  pl_tl_length pl1 (S n) ->
  pl_essence pl0 pl1 <= m ->
  (exists plp0 : pl_path,
     (exists plp1 : pl_path,
        plp = pl_path_product plp0 plp1 /\
        pl_path_incl plp0 (prec_cons a pl0 prec_empty) /\
        pl_path_incl plp1 pl1)) \/ pl_path_incl plp l.

Definition pl_produit_path_incl_def_3 (pl0 pl1 : prec_list) :=
  forall (n m : nat) (plp : pl_path),
  pl_path_incl plp (pl_produit_1 pl0 m pl1) ->
  pl_tl_length pl0 n ->
  pl_tl_length pl1 n ->
  pl_essence pl0 pl1 <= m ->
  exists plp0 : pl_path,
    (exists plp1 : pl_path,
       plp = pl_path_product plp0 plp1 /\
       pl_path_incl plp0 pl0 /\ pl_path_incl plp1 pl1).

Lemma pl_produit_path_incl_3_0 :
 forall p : prec_list, pl_produit_path_incl_def_2 p prec_empty.

Lemma pl_produit_path_incl_3_1 :
 forall p : prec_list, pl_produit_path_incl_def_3 p prec_empty.

Lemma pl_produit_path_incl_3_2 :
 forall p : prec_list, pl_produit_path_incl_def_3 prec_empty p.

Lemma pl_produit_path_incl_3_3 :
 forall (a : ad) (la ls p : prec_list),
 pl_produit_path_incl_def_2 p ls ->
 pl_produit_path_incl_def_3 p la ->
 pl_produit_path_incl_def_2 p (prec_cons a la ls).

Lemma pl_produit_path_incl_3_4 :
 forall (a : ad) (la ls p : prec_list),
 pl_produit_path_incl_def_2 la p ->
 pl_produit_path_incl_def_3 ls p ->
 pl_produit_path_incl_def_3 (prec_cons a la ls) p.

Lemma pl_produit_path_incl_3_5 :
 forall p p' : prec_list,
 pl_produit_path_incl_def_2 p p' /\ pl_produit_path_incl_def_3 p p'.

Lemma pl_produit_path_incl_3 :
 forall (pl0 pl1 : prec_list) (n m : nat) (plp : pl_path),
 pl_path_incl plp (pl_produit_1 pl0 m pl1) ->
 pl_tl_length pl0 n ->
 pl_tl_length pl1 n ->
 pl_essence pl0 pl1 <= m ->
 exists plp0 : pl_path,
   (exists plp1 : pl_path,
      plp = pl_path_product plp0 plp1 /\
      pl_path_incl plp0 pl0 /\ pl_path_incl plp1 pl1).

Lemma pl_produit_path_incl_4 :
 forall (pl0 pl1 : prec_list) (n : nat) (plp : pl_path),
 pl_path_incl plp (pl_produit pl0 pl1) ->
 pl_tl_length pl0 n ->
 pl_tl_length pl1 n ->
 exists plp0 : pl_path,
   (exists plp1 : pl_path,
      plp = pl_path_product plp0 plp1 /\
      pl_path_incl plp0 pl0 /\ pl_path_incl plp1 pl1).

Fixpoint s_produit_l (a : ad) (p : prec_list) (s : state) {struct s} :
 state :=
  match s with
  | M0 => M0 prec_list
  | M1 a' p' =>
      if Neqb a a' then M1 prec_list a (pl_produit p p') else M0 prec_list
  | M2 s0 s1 =>
      match a with
      | N0 => M2 prec_list (s_produit_l N0 p s0) (M0 prec_list)
      | Npos q =>
          match q with
          | xH => M2 prec_list (M0 prec_list) (s_produit_l N0 p s1)
          | xO q' => M2 prec_list (s_produit_l (Npos q') p s0) (M0 prec_list)
          | xI q' => M2 prec_list (M0 prec_list) (s_produit_l (Npos q') p s1)
          end
      end
  end.

Definition sproductl_0_def (s : state) : Prop :=
  forall (a : ad) (p : prec_list) (c : ad) (r0 r1 : prec_list),
  MapGet prec_list (M1 prec_list a p) c = Some r0 ->
  MapGet prec_list s c = Some r1 ->
  MapGet prec_list (s_produit_l a p s) c = Some (pl_produit r0 r1).

Lemma sproductl_0_0 : sproductl_0_def (M0 prec_list).

Lemma sproductl_0_1 :
 forall (a : ad) (a0 : prec_list), sproductl_0_def (M1 prec_list a a0).

Lemma sproductl_0_2 :
 forall m : state,
 sproductl_0_def m ->
 forall m0 : state, sproductl_0_def m0 -> sproductl_0_def (M2 prec_list m m0).

Lemma sproductl_0_3 : forall m : state, sproductl_0_def m.

Lemma sproductl_0 :
 forall (s : state) (a : ad) (p : prec_list) (c : ad) (r0 r1 : prec_list),
 MapGet prec_list (M1 prec_list a p) c = Some r0 ->
 MapGet prec_list s c = Some r1 ->
 MapGet prec_list (s_produit_l a p s) c = Some (pl_produit r0 r1).

Definition sproductl_1_def (s : state) : Prop :=
  forall (a : ad) (p : prec_list) (c : ad) (r : prec_list),
  MapGet prec_list (s_produit_l a p s) c = Some r ->
  exists r0 : prec_list,
    (exists r1 : prec_list,
       MapGet prec_list (M1 prec_list a p) c = Some r0 /\
       MapGet prec_list s c = Some r1).

Lemma sproductl_1_0 : sproductl_1_def (M0 prec_list).

Lemma sproductl_1_1 :
 forall (a : ad) (a0 : prec_list), sproductl_1_def (M1 prec_list a a0).

Lemma sproductl_1_2 :
 forall m : state,
 sproductl_1_def m ->
 forall m0 : state, sproductl_1_def m0 -> sproductl_1_def (M2 prec_list m m0).

Lemma sproductl_1_3 : forall m : state, sproductl_1_def m.

Lemma sproductl_1 :
 forall (s : state) (a : ad) (p : prec_list) (c : ad) (r : prec_list),
 MapGet prec_list (s_produit_l a p s) c = Some r ->
 exists r0 : prec_list,
   (exists r1 : prec_list,
      MapGet prec_list (M1 prec_list a p) c = Some r0 /\
      MapGet prec_list s c = Some r1).

Fixpoint s_produit_r (a : ad) (p : prec_list) (s : state) {struct s} :
 state :=
  match s with
  | M0 => M0 prec_list
  | M1 a' p' =>
      if Neqb a a' then M1 prec_list a (pl_produit p' p) else M0 prec_list
  | M2 s0 s1 =>
      match a with
      | N0 => M2 prec_list (s_produit_r N0 p s0) (M0 prec_list)
      | Npos q =>
          match q with
          | xH => M2 prec_list (M0 prec_list) (s_produit_r N0 p s1)
          | xO q' => M2 prec_list (s_produit_r (Npos q') p s0) (M0 prec_list)
          | xI q' => M2 prec_list (M0 prec_list) (s_produit_r (Npos q') p s1)
          end
      end
  end.

Definition sproductr_0_def (s : state) : Prop :=
  forall (a : ad) (p : prec_list) (c : ad) (r0 r1 : prec_list),
  MapGet prec_list (M1 prec_list a p) c = Some r0 ->
  MapGet prec_list s c = Some r1 ->
  MapGet prec_list (s_produit_r a p s) c = Some (pl_produit r1 r0).

Lemma sproductr_0_0 : sproductr_0_def (M0 prec_list).

Lemma sproductr_0_1 :
 forall (a : ad) (a0 : prec_list), sproductr_0_def (M1 prec_list a a0).

Lemma sproductr_0_2 :
 forall m : state,
 sproductr_0_def m ->
 forall m0 : state, sproductr_0_def m0 -> sproductr_0_def (M2 prec_list m m0).

Lemma sproductr_0_3 : forall m : state, sproductr_0_def m.

Lemma sproductr_0 :
 forall (s : state) (a : ad) (p : prec_list) (c : ad) (r0 r1 : prec_list),
 MapGet prec_list (M1 prec_list a p) c = Some r0 ->
 MapGet prec_list s c = Some r1 ->
 MapGet prec_list (s_produit_r a p s) c = Some (pl_produit r1 r0).

Definition sproductr_1_def (s : state) : Prop :=
  forall (a : ad) (p : prec_list) (c : ad) (r : prec_list),
  MapGet prec_list (s_produit_r a p s) c = Some r ->
  exists r0 : prec_list,
    (exists r1 : prec_list,
       MapGet prec_list (M1 prec_list a p) c = Some r0 /\
       MapGet prec_list s c = Some r1).

Lemma sproductr_1_0 : sproductr_1_def (M0 prec_list).

Lemma sproductr_1_1 :
 forall (a : ad) (a0 : prec_list), sproductr_1_def (M1 prec_list a a0).

Lemma sproductr_1_2 :
 forall m : state,
 sproductr_1_def m ->
 forall m0 : state, sproductr_1_def m0 -> sproductr_1_def (M2 prec_list m m0).

Lemma sproductr_1_3 : forall m : state, sproductr_1_def m.

Lemma sproductr_1 :
 forall (s : state) (a : ad) (p : prec_list) (c : ad) (r : prec_list),
 MapGet prec_list (s_produit_r a p s) c = Some r ->
 exists r0 : prec_list,
   (exists r1 : prec_list,
      MapGet prec_list (M1 prec_list a p) c = Some r0 /\
      MapGet prec_list s c = Some r1).

Fixpoint s_produit (s0 s1 : state) {struct s1} : state :=
  match s0, s1 with
  | M0, M0 => M0 prec_list
  | M0, M1 a1 p1 => M0 prec_list
  | M0, M2 s10 s11 => M0 prec_list
  | M1 a0 p0, M0 => M0 prec_list
  | M1 a0 p0, M1 a1 p1 => s_produit_l a0 p0 (M1 prec_list a1 p1)
  | M1 a0 p0, M2 s10 s11 => s_produit_l a0 p0 (M2 prec_list s10 s11)
  | M2 s00 s01, M0 => M0 prec_list
  | M2 s00 s01, M1 a1 p1 => s_produit_r a1 p1 (M2 prec_list s00 s01)
  | M2 s00 s01, M2 s10 s11 =>
      M2 prec_list (s_produit s00 s10) (s_produit s01 s11)
  end.

Lemma s_produit_0 :
 forall (s0 s1 : state) (c : ad) (p0 p1 : prec_list),
 MapGet prec_list s0 c = Some p0 ->
 MapGet prec_list s1 c = Some p1 ->
 MapGet prec_list (s_produit s0 s1) c = Some (pl_produit p0 p1).

Lemma s_produit_1 :
 forall (s0 s1 : state) (c : ad) (p : prec_list),
 MapGet prec_list (s_produit s0 s1) c = Some p ->
 exists p0 : prec_list,
   (exists p1 : prec_list,
      MapGet prec_list s0 c = Some p0 /\
      MapGet prec_list s1 c = Some p1).

Fixpoint preDTA_produit_l (a : ad) (s : state) (d : preDTA) {struct d} :
 preDTA :=
  match d with
  | M0 => M0 state
  | M1 a' s' => M1 state (iad_conv a a') (s_produit s s')
  | M2 s0 s1 =>
      match a with
      | N0 =>
          M2 state
            (M2 state (preDTA_produit_l N0 s s0)
               (preDTA_produit_l N0 s s1)) (M0 state)
      | Npos p =>
          match p with
          | xH =>
              M2 state (M0 state)
                (M2 state (preDTA_produit_l N0 s s0)
                   (preDTA_produit_l N0 s s1))
          | xO p' =>
              M2 state
                (M2 state (preDTA_produit_l (Npos p') s s0)
                   (preDTA_produit_l (Npos p') s s1)) 
                (M0 state)
          | xI p' =>
              M2 state (M0 state)
                (M2 state (preDTA_produit_l (Npos p') s s0)
                   (preDTA_produit_l (Npos p') s s1))
          end
      end
  end.

Fixpoint preDTA_produit_r (a : ad) (s : state) (d : preDTA) {struct d} :
 preDTA :=
  match d with
  | M0 => M0 state
  | M1 a' s' => M1 state (iad_conv a' a) (s_produit s' s)
  | M2 s0 s1 =>
      match a with
      | N0 =>
          M2 state (M2 state (preDTA_produit_r N0 s s0) (M0 state))
            (M2 state (preDTA_produit_r N0 s s1) (M0 state))
      | Npos p =>
          match p with
          | xH =>
              M2 state (M2 state (M0 state) (preDTA_produit_r N0 s s0))
                (M2 state (M0 state) (preDTA_produit_r N0 s s1))
          | xO p' =>
              M2 state
                (M2 state (preDTA_produit_r (Npos p') s s0) (M0 state))
                (M2 state (preDTA_produit_r (Npos p') s s1) (M0 state))
          | xI p' =>
              M2 state
                (M2 state (M0 state) (preDTA_produit_r (Npos p') s s0))
                (M2 state (M0 state) (preDTA_produit_r (Npos p') s s1))
          end
      end
  end.

Fixpoint preDTA_produit (d0 d1 : preDTA) {struct d1} : preDTA :=
  match d0, d1 with
  | M0, M0 => M0 state
  | M0, M1 a1 s1 => M0 state
  | M0, M2 s10 s11 => M0 state
  | M1 a0 s0, M0 => M0 state
  | M1 a0 s0, M1 a1 s1 => preDTA_produit_l a0 s0 (M1 state a1 s1)
  | M1 a0 s0, M2 s10 s11 => preDTA_produit_l a0 s0 (M2 state s10 s11)
  | M2 s00 s01, M0 => M0 state
  | M2 s00 s01, M1 a1 s1 => preDTA_produit_r a1 s1 (M2 state s00 s01)
  | M2 s00 s01, M2 s10 s11 =>
      M2 state (M2 state (preDTA_produit s00 s10) (preDTA_produit s00 s11))
        (M2 state (preDTA_produit s01 s10) (preDTA_produit s01 s11))
  end.

Definition predta_produit_0d_def (d : preDTA) : Prop :=
  forall (a : ad) (s : state) (a0 a1 : ad) (s0 s1 : state),
  MapGet state (M1 state a s) a0 = Some s0 ->
  MapGet state d a1 = Some s1 ->
  MapGet state (preDTA_produit_l a s d) (iad_conv a0 a1) =
  Some (s_produit s0 s1).

Lemma predta_produit_0_0 : predta_produit_0d_def (M0 state).

Lemma predta_produit_0_1 :
 forall (a : ad) (a0 : state), predta_produit_0d_def (M1 state a a0).

Lemma predta_produit_0_2 :
 forall m : preDTA,
 predta_produit_0d_def m ->
 forall m0 : preDTA,
 predta_produit_0d_def m0 -> predta_produit_0d_def (M2 state m m0).

Lemma predta_produit_0_3 : forall m : preDTA, predta_produit_0d_def m.

Lemma predta_produit_0 :
 forall (a : ad) (s : state) (d : preDTA) (a0 a1 : ad) (s0 s1 : state),
 MapGet state (M1 state a s) a0 = Some s0 ->
 MapGet state d a1 = Some s1 ->
 MapGet state (preDTA_produit_l a s d) (iad_conv a0 a1) =
 Some (s_produit s0 s1).

Definition predta_produit_1_def (d : preDTA) : Prop :=
  forall (a : ad) (s : state) (a0 a1 : ad) (s0 s1 : state),
  MapGet state (M1 state a s) a0 = Some s0 ->
  MapGet state d a1 = Some s1 ->
  MapGet state (preDTA_produit_r a s d) (iad_conv a1 a0) =
  Some (s_produit s1 s0).

Lemma predta_produit_1_0 : predta_produit_1_def (M0 state).

Lemma predta_produit_1_1 :
 forall (a : ad) (a0 : state), predta_produit_1_def (M1 state a a0).

Lemma predta_produit_1_2 :
 forall m : preDTA,
 predta_produit_1_def m ->
 forall m0 : preDTA,
 predta_produit_1_def m0 -> predta_produit_1_def (M2 state m m0).

Lemma predta_produit_1_3 : forall m : preDTA, predta_produit_1_def m.

Lemma predta_produit_1 :
 forall (a : ad) (s : state) (d : preDTA) (a0 a1 : ad) (s0 s1 : state),
 MapGet state (M1 state a s) a0 = Some s0 ->
 MapGet state d a1 = Some s1 ->
 MapGet state (preDTA_produit_r a s d) (iad_conv a1 a0) =
 Some (s_produit s1 s0).

Lemma predta_produit_2 :
 forall (d0 d1 : preDTA) (a0 a1 : ad) (s0 s1 : state),
 MapGet state d0 a0 = Some s0 ->
 MapGet state d1 a1 = Some s1 ->
 MapGet state (preDTA_produit d0 d1) (iad_conv a0 a1) =
 Some (s_produit s0 s1).

Definition predta_produit_3_def (d0 : preDTA) : Prop :=
  forall (a a0 : ad) (s s0 : state),
  MapGet state (preDTA_produit_l a0 s0 d0) a = Some s ->
  exists a1 : ad,
    (exists a2 : ad,
       (exists s1 : state,
          (exists s2 : state,
             a = iad_conv a1 a2 /\
             MapGet state (M1 state a0 s0) a1 = Some s1 /\
             MapGet state d0 a2 = Some s2))).

Lemma predta_produit_3_0 : predta_produit_3_def (M0 state).

Lemma predta_produit_3_1 :
 forall (a : ad) (a0 : state), predta_produit_3_def (M1 state a a0).

Lemma predta_produit_3_2 :
 forall m : preDTA,
 predta_produit_3_def m ->
 forall m0 : preDTA,
 predta_produit_3_def m0 -> predta_produit_3_def (M2 state m m0).

Lemma predta_produit_3_3 : forall m : preDTA, predta_produit_3_def m.

Lemma predta_produit_3 :
 forall (d0 : preDTA) (a a0 : ad) (s s0 : state),
 MapGet state (preDTA_produit_l a0 s0 d0) a = Some s ->
 exists a1 : ad,
   (exists a2 : ad,
      (exists s1 : state,
         (exists s2 : state,
            a = iad_conv a1 a2 /\
            MapGet state (M1 state a0 s0) a1 = Some s1 /\
            MapGet state d0 a2 = Some s2))).

Definition predta_produit_4_def (d0 : preDTA) : Prop :=
  forall (a a0 : ad) (s s0 : state),
  MapGet state (preDTA_produit_r a0 s0 d0) a = Some s ->
  exists a1 : ad,
    (exists a2 : ad,
       (exists s1 : state,
          (exists s2 : state,
             a = iad_conv a1 a2 /\
             MapGet state (M1 state a0 s0) a2 = Some s1 /\
             MapGet state d0 a1 = Some s2))).

Lemma predta_produit_4_0 : predta_produit_4_def (M0 state).

Lemma predta_produit_4_1 :
 forall (a : ad) (a0 : state), predta_produit_4_def (M1 state a a0).

Lemma predta_produit_4_2 :
 forall m : preDTA,
 predta_produit_4_def m ->
 forall m0 : preDTA,
 predta_produit_4_def m0 -> predta_produit_4_def (M2 state m m0).

Lemma predta_produit_4_3 : forall m : preDTA, predta_produit_4_def m.

Lemma predta_produit_4 :
 forall (d0 : preDTA) (a a0 : ad) (s s0 : state),
 MapGet state (preDTA_produit_r a0 s0 d0) a = Some s ->
 exists a1 : ad,
   (exists a2 : ad,
      (exists s1 : state,
         (exists s2 : state,
            a = iad_conv a1 a2 /\
            MapGet state (M1 state a0 s0) a2 = Some s1 /\
            MapGet state d0 a1 = Some s2))).

Lemma predta_produit_5 :
 forall (d0 d1 : preDTA) (a : ad) (s : state),
 MapGet state (preDTA_produit d0 d1) a = Some s ->
 exists a0 : ad,
   (exists a1 : ad,
      (exists s0 : state,
         (exists s1 : state,
            a = iad_conv a0 a1 /\
            MapGet state d0 a0 = Some s0 /\
            MapGet state d1 a1 = Some s1))).

Lemma pl_produit_rec_0 :
 forall tl : term_list,
 (forall u : term,
  term_list_occur u tl ->
  forall (d0 d1 : preDTA) (a0 a1 : ad),
  predta_compatible d0 d1 ->
  reconnaissance d0 a0 u ->
  reconnaissance d1 a1 u ->
  reconnaissance (preDTA_produit d0 d1) (iad_conv a0 a1) u) ->
 forall (d0 d1 : preDTA) (plp0 plp1 : pl_path),
 predta_compatible d0 d1 ->
 pl_path_recon d0 tl plp0 ->
 pl_path_recon d1 tl plp1 ->
 pl_path_recon (preDTA_produit d0 d1) tl (pl_path_product plp0 plp1).

Lemma pl_produit_rec_1 :
 forall (d0 d1 : preDTA) (tl : term_list) (pl0 pl1 : prec_list),
 liste_reconnait d0 pl0 tl ->
 liste_reconnait d1 pl1 tl ->
 pl_tl_length pl0 (lst_length tl) ->
 pl_tl_length pl1 (lst_length tl) ->
 predta_compatible d0 d1 ->
 (forall u : term,
  term_list_occur u tl ->
  forall (d0 d1 : preDTA) (a0 a1 : ad),
  predta_compatible d0 d1 ->
  reconnaissance d0 a0 u ->
  reconnaissance d1 a1 u ->
  reconnaissance (preDTA_produit d0 d1) (iad_conv a0 a1) u) ->
 liste_reconnait (preDTA_produit d0 d1) (pl_produit pl0 pl1) tl.

Lemma pl_produit_rec_2 :
 forall tl : term_list,
 (forall u : term,
  term_list_occur u tl ->
  forall (d0 d1 : preDTA) (a0 a1 : ad),
  predta_compatible d0 d1 ->
  reconnaissance (preDTA_produit d0 d1) (iad_conv a0 a1) u ->
  reconnaissance d0 a0 u /\ reconnaissance d1 a1 u) ->
 forall (d0 d1 : preDTA) (plp : pl_path),
 predta_compatible d0 d1 ->
 pl_path_recon (preDTA_produit d0 d1) tl plp ->
 exists plp0 : pl_path,
   (exists plp1 : pl_path,
      plp = pl_path_product plp0 plp1 /\
      pl_path_recon d0 tl plp0 /\ pl_path_recon d1 tl plp1).

Lemma pl_produit_rec_3 :
 forall (d0 d1 : preDTA) (tl : term_list) (pl0 pl1 : prec_list) (n : nat),
 liste_reconnait (preDTA_produit d0 d1) (pl_produit pl0 pl1) tl ->
 predta_compatible d0 d1 ->
 pl_tl_length pl0 n ->
 pl_tl_length pl1 n ->
 (forall u : term,
  term_list_occur u tl ->
  forall (d0 d1 : preDTA) (a0 a1 : ad),
  predta_compatible d0 d1 ->
  reconnaissance (preDTA_produit d0 d1) (iad_conv a0 a1) u ->
  reconnaissance d0 a0 u /\ reconnaissance d1 a1 u) ->
 liste_reconnait d0 pl0 tl /\ liste_reconnait d1 pl1 tl.

Definition predta_inter_def_0 (t : term) : Prop :=
  forall (d0 d1 : preDTA) (a0 a1 : ad),
  predta_compatible d0 d1 ->
  reconnaissance d0 a0 t ->
  reconnaissance d1 a1 t ->
  reconnaissance (preDTA_produit d0 d1) (iad_conv a0 a1) t.

Definition predta_inter_def_1 (t : term) : Prop :=
  forall (d0 d1 : preDTA) (a0 a1 : ad),
  predta_compatible d0 d1 ->
  reconnaissance (preDTA_produit d0 d1) (iad_conv a0 a1) t ->
  reconnaissance d0 a0 t /\ reconnaissance d1 a1 t.

Lemma predta_inter_0 :
 forall (a : ad) (tl : term_list),
 (forall u : term, term_list_occur u tl -> predta_inter_def_0 u) ->
 predta_inter_def_0 (app a tl).

Lemma predta_inter_1 :
 forall (a : ad) (tl : term_list),
 (forall u : term, term_list_occur u tl -> predta_inter_def_1 u) ->
 predta_inter_def_1 (app a tl).

Lemma predta_inter_direct :
 forall (d0 d1 : preDTA) (a0 a1 : ad) (t : term),
 predta_compatible d0 d1 ->
 reconnaissance d0 a0 t ->
 reconnaissance d1 a1 t ->
 reconnaissance (preDTA_produit d0 d1) (iad_conv a0 a1) t.

Lemma predta_inter_reciproque :
 forall (d0 d1 : preDTA) (a0 a1 : ad) (t : term),
 predta_compatible d0 d1 ->
 reconnaissance (preDTA_produit d0 d1) (iad_conv a0 a1) t ->
 reconnaissance d0 a0 t /\ reconnaissance d1 a1 t.

Definition inter (d0 d1 : DTA) : DTA :=
  match d0, d1 with
  | dta p0 a0, dta p1 a1 => dta (preDTA_produit p0 p1) (iad_conv a0 a1)
  end.

Lemma inter_semantics_0 :
 forall (d0 d1 : DTA) (t : term),
 dta_compatible d0 d1 ->
 (reconnait d0 t /\ reconnait d1 t <-> reconnait (inter d0 d1) t).

Lemma inter_semantics :
 forall (d0 d1 : DTA) (sigma : signature) (t : term),
 dta_correct_wrt_sign d0 sigma ->
 dta_correct_wrt_sign d1 sigma ->
 (reconnait d0 t /\ reconnait d1 t <-> reconnait (inter d0 d1) t). *)



Lemma pl_produit_correct_wrt_sign_invar :

 forall (p0 p1 : prec_list) (n : nat),

 pl_tl_length p0 n -> pl_tl_length p1 n -> pl_tl_length (pl_produit p0 p1) n.

Proof.

	exact pl_tl_length_prod.

Qed.



Lemma st_produit_l_correct_wrt_sign_invar_with_offset :

 forall (s0 : state) (a : ad) (p : prec_list) (sigma : signature)

   (pa : pre_ad),

 state_correct_wrt_sign_with_offset s0 sigma pa ->

 state_correct_wrt_sign_with_offset (M1 prec_list a p) sigma pa ->

 state_correct_wrt_sign_with_offset (s_produit_l a p s0) sigma pa.

Proof.

	simple induction s0. unfold state_correct_wrt_sign_with_offset in |- *.

	intros. inversion H1. unfold state_correct_wrt_sign_with_offset in |- *.

	intros. simpl in H1. elim (bool_is_true_or_false (Neqb a1 a)); intros; rewrite H2 in H1. simpl in H1. elim (bool_is_true_or_false (Neqb a1 a2)); intros; rewrite H3 in H1. inversion H1. elim (H a a0). elim (H0 a1 p). intros. elim H4. elim H6. intros. rewrite (Neqb_complete _ _ H2) in H9. rewrite H9 in H7. inversion H7.

	split with x. rewrite <- (Neqb_complete _ _ H3). rewrite (Neqb_complete _ _ H2). split. exact H9. rewrite H12 in H7.

	rewrite <- H12 in H8. exact (pl_tl_length_prod p a0 x H10 H8).

	simpl in |- *. rewrite (Neqb_correct a1). reflexivity. simpl in |- *.

	rewrite (Neqb_correct a). reflexivity. inversion H1.

	inversion H1. intros. elim (state_correct_wrt_sign_with_offset_M2 m m0 sigma pa H1). intros. unfold state_correct_wrt_sign_with_offset in |- *.

	intros. unfold state_correct_wrt_sign_with_offset in H.

	unfold state_correct_wrt_sign_with_offset in H0. induction  a as [| p1].

	induction  a0 as [| p1]. simpl in H5. elim (H N0 p sigma (pre_ad_O pa) H3) with (a := N0) (p0 := p0). intros. split with x. elim H6. intros.

	split. induction  pa as [| pa Hrecpa| pa Hrecpa]; simpl in |- *; simpl in H7;

  exact H7.

	exact H8. intros. elim (H2 N0 p). intros. split with x.

	induction  a as [| p2]. simpl in H6. inversion H6. rewrite <- H9. simpl in |- *.

	exact H7. induction  p2 as [p2 Hrecp2| p2 Hrecp2| ]. inversion H6. inversion H6. inversion H6. reflexivity. exact H5. induction  p1 as [p1 Hrecp1| p1 Hrecp1| ]. simpl in H5.

	inversion H5. simpl in H5. elim (H N0 p sigma (pre_ad_O pa) H3) with (a := Npos p1) (p0 := p0). intros. split with x. simpl in H6.

	exact H6. intros. unfold state_correct_wrt_sign_with_offset in H2.

	induction  a as [| p3]. simpl in H6. inversion H6. elim (H2 N0 p). intros.

	split with x. rewrite <- H8. induction  pa as [| pa Hrecpa| pa Hrecpa]; exact H7. reflexivity.

	simpl in H6. inversion H6. exact H5. simpl in H5. inversion H5.

	induction  p1 as [p1 Hrecp1| p1 Hrecp1| ]. clear Hrecp1. induction  a0 as [| p2]. simpl in H5.

	inversion H5. induction  p2 as [p2 Hrecp2| p2 Hrecp2| ]; simpl in H5. elim (H0 (Npos p1) p sigma (pre_ad_I pa) H4) with (a := Npos p2) (p0 := p0).

	intros. split with x. simpl in H6. exact H6. intros.

	unfold state_correct_wrt_sign_with_offset in H2. induction  a as [| p4]. inversion H6. elim (H2 (Npos (xI p4)) p3). intros. split with x. simpl in |- *. exact H7. simpl in |- *. simpl in H6. exact H6.

	exact H5. inversion H5. elim (H0 (Npos p1) p sigma (pre_ad_I pa) H4) with (a := N0) (p0 := p0). intros. split with x. simpl in H6. exact H6. intros. induction  a as [| p3]. inversion H6. elim (H2 (Npos (xI p3)) p2). intros. split with x. simpl in |- *. 

	exact H7. simpl in |- *. simpl in H6. exact H6. exact H5. induction  a0 as [| p2]. simpl in H5. elim (H (Npos p1) p sigma (pre_ad_O pa) H3) with (a := N0) (p0 := p0). intros. split with x. simpl in H6.

	exact H6. intros. induction  a as [| p3]. inversion H6. elim (H2 (Npos (xO p3)) p2). intros. split with x. simpl in |- *. exact H7. simpl in |- *.

	simpl in H6. exact H6. exact H5. induction  p2 as [p2 Hrecp2| p2 Hrecp2| ]; simpl in H5.

	inversion H5. elim (H (Npos p1) p sigma (pre_ad_O pa) H3) with (a := Npos p2) (p0 := p0). intros. split with x. simpl in H6. exact H6. intros. induction  a as [| p4]. inversion H6. elim (H2 (Npos (xO p4)) p3). intros. split with x. simpl in |- *. exact H7.

	simpl in |- *. simpl in H6. exact H6. exact H5. inversion H5.

	induction  a0 as [| p1]. simpl in H5. inversion H5. induction  p1 as [p1 Hrecp1| p1 Hrecp1| ]; simpl in H5. elim (H0 N0 p sigma (pre_ad_I pa) H4) with (a := Npos p1) (p0 := p0). intros. split with x. simpl in H6. exact H6.

	intros. induction  a as [| p3]. elim (H2 (Npos 1) p2). intros.

	split with x. simpl in |- *. exact H7. simpl in |- *. simpl in H6. exact H6. inversion H6. exact H5. inversion H5. elim (H0 N0 p sigma (pre_ad_I pa) H4) with (a := N0) (p0 := p0). intros.

	split with x. simpl in H6. exact H6. intros. induction  a as [| p2].

	elim (H2 (Npos 1) p1). intros. split with x. simpl in |- *.

	exact H7. simpl in |- *. simpl in H6. exact H6. inversion H6.

	exact H5.

Qed.



Lemma st_produit_r_correct_wrt_sign_invar_with_offset :

 forall (s0 : state) (a : ad) (p : prec_list) (sigma : signature)

   (pa : pre_ad),

 state_correct_wrt_sign_with_offset s0 sigma pa ->

 state_correct_wrt_sign_with_offset (M1 prec_list a p) sigma pa ->

 state_correct_wrt_sign_with_offset (s_produit_r a p s0) sigma pa.

Proof.

	simple induction s0. unfold state_correct_wrt_sign_with_offset in |- *.

	intros. inversion H1. unfold state_correct_wrt_sign_with_offset in |- *.

	intros. simpl in H1. elim (bool_is_true_or_false (Neqb a1 a)); intros; rewrite H2 in H1. simpl in H1. elim (bool_is_true_or_false (Neqb a1 a2)); intros; rewrite H3 in H1. inversion H1. elim (H a a0). elim (H0 a1 p). intros.

	elim H4. elim H6. intros. rewrite (Neqb_complete _ _ H2) in H9. rewrite H9 in H7. inversion H7. split with x. 

	rewrite <- (Neqb_complete _ _ H3). rewrite (Neqb_complete _ _ H2). split. exact H9. rewrite H12 in H7. rewrite <- H12 in H8. exact (pl_tl_length_prod a0 p x H8 H10). simpl in |- *.

	rewrite (Neqb_correct a1). reflexivity. simpl in |- *. rewrite (Neqb_correct a). reflexivity. inversion H1. inversion H1.

	intros. elim (state_correct_wrt_sign_with_offset_M2 m m0 sigma pa H1). intros. unfold state_correct_wrt_sign_with_offset in |- *.

	intros. unfold state_correct_wrt_sign_with_offset in H.

	unfold state_correct_wrt_sign_with_offset in H0. induction  a as [| p1]. induction  a0 as [| p1]. simpl in H5. elim (H N0 p sigma (pre_ad_O pa) H3) with (a := N0) (p0 := p0). intros. split with x. simpl in H6. exact H6. intros. elim (H2 N0 p1). intros. split with x. simpl in |- *. induction  a as [| p2]. exact H7. inversion H6.

	induction  a as [| p2]. exact H6. inversion H6. exact H5. induction  p1 as [p1 Hrecp1| p1 Hrecp1| ]; simpl in H5. inversion H5. elim (H N0 p sigma (pre_ad_O pa) H3) with (a := Npos p1) (p0 := p0). intros. split with x. simpl in H6. exact H6. intros. induction  a as [| p3]. elim (H2 N0 p2). intros. split with x. simpl in |- *. exact H7.

	exact H6. inversion H6. exact H5. inversion H5. induction  p1 as [p1 Hrecp1| p1 Hrecp1| ]. induction  a0 as [| p2]. simpl in H5. inversion H5. induction  p2 as [p2 Hrecp2| p2 Hrecp2| ]; simpl in H5. elim (H0 (Npos p1) p sigma (pre_ad_I pa) H4) with (a := Npos p2) (p0 := p0). intros. split with x. simpl in H6. exact H6. intros. induction  a as [| p4]. inversion H6. elim (H2 (Npos (xI p4)) p3). intros. split with x. simpl in |- *.

	exact H7. simpl in |- *. simpl in H6. exact H6. exact H5.

	inversion H5. elim (H0 (Npos p1) p sigma (pre_ad_I pa) H4) with (a := N0) (p0 := p0). intros. split with x. exact H6.

	intros. induction  a as [| p3]. inversion H6. elim (H2 (Npos (xI p3)) p2). intros. split with x. simpl in |- *. exact H7. simpl in |- *. exact H6. exact H5. induction  a0 as [| p2]. simpl in H5. elim (H (Npos p1) p sigma (pre_ad_O pa) H3) with (a := N0) (p0 := p0). intros.

	split with x. simpl in H6. exact H6. intros. induction  a as [| p3].

	inversion H6. elim (H2 (Npos (xO p3)) p2). intros. split with x. simpl in |- *. exact H7. simpl in |- *. simpl in H6. exact H6.

	exact H5. induction  p2 as [p2 Hrecp2| p2 Hrecp2| ]; simpl in H5. inversion H5. elim (H (Npos p1) p sigma (pre_ad_O pa) H3) with (a := Npos p2) (p0 := p0). intros. split with x. simpl in H6. exact H6.

	intros. induction  a as [| p4]. inversion H6. elim (H2 (Npos (xO p4)) p3). intros. split with x. simpl in |- *. exact H7. simpl in |- *. simpl in H6. exact H6. exact H5. inversion H5. induction  a0 as [| p1].

	simpl in H5. inversion H5. induction  p1 as [p1 Hrecp1| p1 Hrecp1| ]; simpl in H5.

	elim (H0 N0 p sigma (pre_ad_I pa) H4) with (a := Npos p1) (p0 := p0). intros. split with x. simpl in H6. exact H6.

	intros. induction  a as [| p3]. elim (H2 (Npos 1) p2). intros.

	split with x. simpl in |- *. exact H7. simpl in |- *. simpl in H6.

	exact H6. inversion H6. exact H5. inversion H5. elim (H0 N0 p sigma (pre_ad_I pa) H4) with (a := N0) (p0 := p0).

	intros. split with x. simpl in H6. exact H6. intros.

	induction  a as [| p2]. elim (H2 (Npos 1) p1). intros. split with x. simpl in |- *. exact H7. simpl in |- *. simpl in H6. exact H6.

	inversion H6. exact H5.

Qed.



Lemma st_produit_correct_wrt_sign_invar_with_offset :

 forall (s0 s1 : state) (sigma : signature) (pa : pre_ad),

 state_correct_wrt_sign_with_offset s0 sigma pa ->

 state_correct_wrt_sign_with_offset s1 sigma pa ->

 state_correct_wrt_sign_with_offset (s_produit s0 s1) sigma pa.

Proof.

	simple induction s0. simple induction s1. intros. simpl in |- *. unfold state_correct_wrt_sign_with_offset in |- *. intros. inversion H1.

	intros. simpl in |- *. unfold state_correct_wrt_sign_with_offset in |- *.

	intros. inversion H1. intros. simpl in |- *. unfold state_correct_wrt_sign_with_offset in |- *. intros. inversion H3.

	simple induction s1. simpl in |- *. intros. unfold state_correct_wrt_sign_with_offset in |- *. intros. inversion H1.

	intros. replace (s_produit (M1 prec_list a a0) (M1 prec_list a1 a2)) with

  (s_produit_l a a0 (M1 prec_list a1 a2)).

	exact

  (st_produit_l_correct_wrt_sign_invar_with_offset 

     (M1 prec_list a1 a2) a a0 sigma pa H0 H). reflexivity. intros.

	replace (s_produit (M1 prec_list a a0) (M2 prec_list m m0)) with

  (s_produit_l a a0 (M2 prec_list m m0)). exact

  (st_produit_l_correct_wrt_sign_invar_with_offset 

     (M2 prec_list m m0) a a0 sigma pa H2 H1). reflexivity. simple induction s1.

	simpl in |- *. intros. exact H2. intros. replace (s_produit (M2 prec_list m m0) (M1 prec_list a a0)) with

  (s_produit_r a a0 (M2 prec_list m m0)). exact

  (st_produit_r_correct_wrt_sign_invar_with_offset 

     (M2 prec_list m m0) a a0 sigma pa H1 H2). reflexivity. intros. unfold state_correct_wrt_sign_with_offset in |- *. simpl in |- *. intros.

	elim (state_correct_wrt_sign_with_offset_M2 _ _ _ _ H3).

	intros. elim (state_correct_wrt_sign_with_offset_M2 _ _ _ _ H4). intros. induction  a as [| p0]. exact (H _ _ _ H6 H8 N0 p H5). induction  p0 as [p0 Hrecp0| p0 Hrecp0| ]. exact (H0 _ _ _ H7 H9 (Npos p0) p H5).

	exact (H _ _ _ H6 H8 _ _ H5). exact (H0 _ _ _ H7 H9 _ _ H5).

Qed.



Lemma st_produit_correct_wrt_sign_invar :

 forall (s0 s1 : state) (sigma : signature),

 state_correct_wrt_sign s0 sigma ->

 state_correct_wrt_sign s1 sigma ->

 state_correct_wrt_sign (s_produit s0 s1) sigma.

Proof.

	intros. replace (state_correct_wrt_sign (s_produit s0 s1) sigma) with

  (state_correct_wrt_sign_with_offset (s_produit s0 s1) sigma pre_ad_empty). apply

  (st_produit_correct_wrt_sign_invar_with_offset s0 s1 sigma pre_ad_empty).

	unfold state_correct_wrt_sign_with_offset in |- *. simpl in |- *. exact H.

	unfold state_correct_wrt_sign_with_offset in |- *. simpl in |- *.

	exact H0. reflexivity.

Qed.



Lemma positive_sum :

 forall p : positive,

 p = 1%positive \/

 (exists q : positive, p = xO q) \/ (exists q : positive, p = xI q).

Proof.

	simple induction p. intros. right. right. split with p0. reflexivity.

	intros. right. left. split with p0. reflexivity. left.

	reflexivity.

Qed.



Lemma preDTA_produit_l_correct_wrt_sign_invar :

 forall (d : preDTA) (a : ad) (s : state) (sigma : signature),

 predta_correct_wrt_sign d sigma ->

 predta_correct_wrt_sign (M1 state a s) sigma ->

 predta_correct_wrt_sign (preDTA_produit_l a s d) sigma.

Proof.

	simple induction d. intros. simpl in |- *. exact H. simpl in |- *. unfold predta_correct_wrt_sign in |- *. intros. simpl in H1. elim (bool_is_true_or_false (Neqb (iad_conv a1 a) a2)); intros;

  rewrite H2 in H1. inversion H1. apply (st_produit_correct_wrt_sign_invar s a0 sigma). apply (H0 a1 s). simpl in |- *. rewrite (Neqb_correct a1).

	reflexivity. apply (H a a0). simpl in |- *. rewrite (Neqb_correct a).

	reflexivity. inversion H1. intros. elim (predta_correct_wrt_sign_M2 m m0 sigma H1). intros. induction  a as [| p]. simpl in |- *. unfold predta_correct_wrt_sign in |- *. intros. induction  a as [| p]. 

	simpl in H5. exact (H N0 s sigma H3 H2 N0 s0 H5).

	elim (positive_sum p); intros. rewrite H6 in H5.

	simpl in H5. inversion H5. elim H6. intros. elim H7.

	intros. rewrite H8 in H5. simpl in H5. elim (positive_sum x). intros. rewrite H9 in H5. exact (H0 N0 s sigma H4 H2 N0 s0 H5). intros. elim H9. intros. elim H10. intros.

	rewrite H11 in H5. exact (H N0 s sigma H3 H2 (Npos x0) s0 H5). intros. elim H10. intros. rewrite H11 in H5.

	exact (H0 N0 s sigma H4 H2 (Npos x0) s0 H5). intros.

	elim H7. intros. rewrite H8 in H5. simpl in H5. inversion H5. induction  p as [p Hrecp| p Hrecp| ]. cut (predta_correct_wrt_sign (M1 state (Npos p) s) sigma). intros. unfold predta_correct_wrt_sign in |- *.

	intros. simpl in H6. induction  a as [| p0]. inversion H6. elim (positive_sum p0); intros. rewrite H7 in H6. exact (H (Npos p) s sigma H3 H5 N0 s0 H6). elim H7; intros; elim H8; intros; rewrite H9 in H6. inversion H6. elim (positive_sum x). intros. rewrite H10 in H6. exact (H0 (Npos p) s _ H4 H5 _ _ H6). intros. elim H10; intros; elim H11; intros; rewrite H12 in H6. exact (H _ _ _ H3 H5 _ _ H6). exact (H0 _ _ _ H4 H5 _ _ H6). unfold predta_correct_wrt_sign in |- *. simple induction a. exact (H2 (Npos 1)). intro. exact (H2 (Npos (xI p0))). cut (predta_correct_wrt_sign (M1 state (Npos p) s) sigma).

	intro. unfold predta_correct_wrt_sign in |- *. intros. simpl in H6. induction  a as [| p0]. exact (H _ _ _ H3 H5 _ _ H6). elim (positive_sum p0); intros. rewrite H7 in H6. inversion H6.

	elim H7; intros; elim H8; intros; rewrite H9 in H6.

	elim (positive_sum x); intros. rewrite H10 in H6. exact (H0 _ _ _ H4 H5 _ _ H6). elim H10; intros; elim H11; intros; rewrite H12 in H6. exact (H _ _ _ H3 H5 _ _ H6).

	exact (H0 _ _ _ H4 H5 _ _ H6). inversion H6. unfold predta_correct_wrt_sign in |- *. simple induction a. exact (H2 N0).

	intro. exact (H2 (Npos (xO p0))). cut (predta_correct_wrt_sign (M1 state N0 s) sigma). intros.

	unfold predta_correct_wrt_sign in |- *. intros. simpl in H6.

	induction  a as [| p]. inversion H6. elim (positive_sum p); intros.

	rewrite H7 in H6. exact (H _ _ _ H3 H5 _ _ H6). elim H7; intros; elim H8; intros; rewrite H9 in H6. inversion H6.

	elim (positive_sum x); intros. rewrite H10 in H6. exact (H0 _ _ _ H4 H5 _ _ H6). elim H10; intros; elim H11; intros; rewrite H12 in H6. exact (H _ _ _ H3 H5 _ _ H6).

	exact (H0 _ _ _ H4 H5 _ _ H6). unfold predta_correct_wrt_sign in |- *.

	simple induction a. exact (H2 (Npos 1)). intro. exact (H2 (Npos (xI p))).

Qed.



Lemma preDTA_produit_r_correct_wrt_sign_invar :

 forall (d : preDTA) (a : ad) (s : state) (sigma : signature),

 predta_correct_wrt_sign d sigma ->

 predta_correct_wrt_sign (M1 state a s) sigma ->

 predta_correct_wrt_sign (preDTA_produit_r a s d) sigma.

Proof.

	simple induction d. intros. simpl in |- *. exact H. unfold predta_correct_wrt_sign in |- *. intros. simpl in H1. elim (bool_is_true_or_false (Neqb (iad_conv a a1) a2)); intros;

  rewrite H2 in H1. inversion H1. apply (st_produit_correct_wrt_sign_invar a0 s sigma). apply (H a a0). simpl in |- *. rewrite (Neqb_correct a).

	reflexivity. apply (H0 a1 s). simpl in |- *. rewrite (Neqb_correct a1). reflexivity. inversion H1.

	intros. elim (predta_correct_wrt_sign_M2 m m0 sigma H1). intros. induction  a as [| p]. simpl in |- *. unfold predta_correct_wrt_sign in |- *. intros. simpl in H5.

	induction  a as [| p]. exact (H _ _ _ H3 H2 _ _ H5). elim (positive_sum p); intros. rewrite H6 in H5. exact (H0 _ _ _ H4 H2 _ _ H5). elim H6; intros; elim H7; intros; rewrite H8 in H5. elim (positive_sum x); intros. rewrite H9 in H5. inversion H5. elim H9; intros; elim H10; intros; rewrite H11 in H5. exact (H _ _ _ H3 H2 _ _ H5). inversion H5. elim (positive_sum x); intros. rewrite H9 in H5. inversion H5. elim H9; intros; elim H10; intros; rewrite H11 in H5. exact (H0 _ _ _ H4 H2 _ _ H5). inversion H5.

	induction  p as [p Hrecp| p Hrecp| ]. cut (predta_correct_wrt_sign (M1 state (Npos p) s) sigma). intros. unfold predta_correct_wrt_sign in |- *.

	intros. simpl in H6. induction  a as [| p0]. inversion H6.

	elim (positive_sum p0); intros. rewrite H7 in H6.

	inversion H6. elim H7; intros; elim H8; intros; rewrite H9 in H6. elim (positive_sum x); intros.

	rewrite H10 in H6. exact (H _ _ _ H3 H5 _ _ H6).

	elim H10; intros; elim H11; intros; rewrite H12 in H6. inversion H6. exact (H _ _ _ H3 H5 _ _ H6).

	elim (positive_sum x); intros. rewrite H10 in H6.

	exact (H0 _ _ _ H4 H5 _ _ H6). elim H10; intros; elim H11; intros; rewrite H12 in H6. inversion H6.

	exact (H0 _ _ _ H4 H5 _ _ H6). unfold predta_correct_wrt_sign in |- *. simple induction a. exact (H2 (Npos 1)). intro. exact (H2 (Npos (xI p0))). cut (predta_correct_wrt_sign (M1 state (Npos p) s) sigma).

	intro. unfold predta_correct_wrt_sign in |- *. intros.

	simpl in H6. induction  a as [| p0]. exact (H _ _ _ H3 H5 _ _ H6).

	elim (positive_sum p0); intros. rewrite H7 in H6.

	exact (H0 _ _ _ H4 H5 _ _ H6). elim H7; intros; elim H8; intros; rewrite H9 in H6. elim (positive_sum x); intros. rewrite H10 in H6. inversion H6. elim H10; intros; elim H11; intros; rewrite H12 in H6. exact (H _ _ _ H3 H5 _ _ H6). inversion H6. elim (positive_sum x); intros. rewrite H10 in H6. inversion H6.

	elim H10; intros; elim H11; intros; rewrite H12 in H6.

	exact (H0 _ _ _ H4 H5 _ _ H6). inversion H6. unfold predta_correct_wrt_sign in |- *. simple induction a. exact (H2 N0).

	intro. exact (H2 (Npos (xO p0))). cut (predta_correct_wrt_sign (M1 state N0 s) sigma).

	intro. unfold predta_correct_wrt_sign in |- *. intros.

	simpl in H6. induction  a as [| p]. inversion H6. elim (positive_sum p); intros. rewrite H7 in H6. inversion H6. elim H7; intros; elim H8; intros; rewrite H9 in H6. elim (positive_sum x); intros. rewrite H10 in H6. exact (H _ _ _ H3 H5 _ _ H6). elim H10; intros; elim H11; intros; rewrite H12 in H6.

	inversion H6. exact (H _ _ _ H3 H5 _ _ H6). elim (positive_sum x); intros. rewrite H10 in H6.

	exact (H0 _ _ _ H4 H5 _ _ H6). elim H10; intros; elim H11; intros; rewrite H12 in H6. inversion H6.

	exact (H0 _ _ _ H4 H5 _ _ H6). unfold predta_correct_wrt_sign in |- *. simple induction a. exact (H2 (Npos 1)). intro. exact (H2 (Npos (xI p))).

Qed.



Lemma preDTA_produit_correct_wrt_sign_invar :

 forall (d0 d1 : preDTA) (sigma : signature),

 predta_correct_wrt_sign d0 sigma ->

 predta_correct_wrt_sign d1 sigma ->

 predta_correct_wrt_sign (preDTA_produit d0 d1) sigma.

Proof.

	simple induction d0. simple induction d1. simpl in |- *. intros. exact H.

	simpl in |- *. intros. exact H. intros. simpl in |- *. exact H1.

	simple induction d1. simpl in |- *. intros. exact H0. intros.

	replace (preDTA_produit (M1 state a a0) (M1 state a1 a2)) with

  (preDTA_produit_l a a0 (M1 state a1 a2)).

	exact

  (preDTA_produit_l_correct_wrt_sign_invar (M1 state a1 a2) a a0 sigma H0 H). reflexivity. intros.

	replace (preDTA_produit (M1 state a a0) (M2 state m m0)) with

  (preDTA_produit_l a a0 (M2 state m m0)). exact

  (preDTA_produit_l_correct_wrt_sign_invar (M2 state m m0) a a0 sigma H2 H1). reflexivity. simple induction d1. simpl in |- *.

	intros. exact H2. intros. replace (preDTA_produit (M2 state m m0) (M1 state a a0)) with

  (preDTA_produit_r a a0 (M2 state m m0)). exact

  (preDTA_produit_r_correct_wrt_sign_invar (M2 state m m0) a a0 sigma H1 H2). reflexivity. intros. simpl in |- *.

	elim (predta_correct_wrt_sign_M2 _ _ _ H3). intros.

	elim (predta_correct_wrt_sign_M2 _ _ _ H4). intros.

	unfold predta_correct_wrt_sign in |- *. intros. simpl in H9.

	induction  a as [| p]. exact (H _ _ H5 H7 N0 s H9). elim (positive_sum p); intros. rewrite H10 in H9.

	exact (H0 _ _ H6 H7 _ _ H9). elim H10; intros; elim H11; intros; rewrite H12 in H9. elim (positive_sum x); intros. rewrite H13 in H9. exact (H _ _ H5 H8 _ _ H9). elim H13; intros; elim H14; intros; rewrite H15 in H9. exact (H _ _ H5 H7 _ _ H9). exact (H _ _ H5 H8 _ _ H9). elim (positive_sum x); intros.

	rewrite H13 in H9. exact (H0 _ _ H6 H8 _ _ H9).

	elim H13; intros; elim H14; intros; rewrite H15 in H9.

	exact (H0 _ _ H6 H7 _ _ H9). exact (H0 _ _ H6 H8 _ _ H9).

Qed.



Lemma inter_correct_wrt_sign_invar :

 forall (d0 d1 : DTA) (sigma : signature),

 dta_correct_wrt_sign d0 sigma ->

 dta_correct_wrt_sign d1 sigma -> dta_correct_wrt_sign (inter d0 d1) sigma.

Proof.

	simple induction d0. simple induction d1. simpl in |- *. intros.

	exact (preDTA_produit_correct_wrt_sign_invar p p0 sigma H H0).

Qed.



Definition pl_produit_ref_ok_0 (la pl : prec_list) : Prop :=

  forall (a b : ad) (l : prec_list) (n : nat),

  prec_occur (pl_produit_0 a la pl n l) b ->

  (exists a0 : ad,

     (exists a1 : ad,

        b = iad_conv a0 a1 /\ prec_occur la a0 /\ prec_occur pl a1)) \/

  (exists a1 : ad, b = iad_conv a a1 /\ prec_occur pl a1) \/ prec_occur l b.



Definition pl_produit_ref_ok_1 (p0 p1 : prec_list) : Prop :=

  forall (b : ad) (n : nat),

  prec_occur (pl_produit_1 p0 n p1) b ->

  exists a0 : ad,

    (exists a1 : ad,

       b = iad_conv a0 a1 /\ prec_occur p0 a0 /\ prec_occur p1 a1).



Lemma pl_produit_ref_ok_lem_0 :

 forall p : prec_list, pl_produit_ref_ok_0 p prec_empty.

Proof.

	unfold pl_produit_ref_ok_0 in |- *. intros. induction  p as [a0 p1 Hrecp1 p0 Hrecp0| ].

	induction  n as [| n Hrecn]. simpl in H. inversion H. simpl in H.

	right. right. exact H. induction  n as [| n Hrecn]. simpl in H.

	inversion H. simpl in H. right. right. exact H.

Qed.



Lemma pl_produit_ref_ok_lem_1 :

 forall p : prec_list, pl_produit_ref_ok_1 p prec_empty.

Proof.

	unfold pl_produit_ref_ok_1 in |- *. intros. induction  n as [| n Hrecn].

	simpl in H. inversion H. simpl in H. induction  p as [a p1 Hrecp1 p0 Hrecp0| ]; inversion H.

Qed.



Lemma pl_produit_ref_ok_lem_2 :

 forall p : prec_list, pl_produit_ref_ok_1 prec_empty p.

Proof.

	unfold pl_produit_ref_ok_1 in |- *. intros. induction  n as [| n Hrecn].

	inversion H. induction  p as [a p1 Hrecp1 p0 Hrecp0| ]; inversion H.

Qed.



Lemma pl_produit_ref_ok_lem_3 :

 forall (a : ad) (la ls p : prec_list),

 pl_produit_ref_ok_0 p ls ->

 pl_produit_ref_ok_1 p la -> pl_produit_ref_ok_0 p (prec_cons a la ls).

Proof.

	unfold pl_produit_ref_ok_0, pl_produit_ref_ok_1 in |- *.

	intros. elim (nat_sum n); intros. rewrite H2 in H1.

	inversion H1. elim H2. intros. rewrite H3 in H1.

	cut

  (pl_produit_0 a0 p (prec_cons a la ls) (S x) l =

   prec_cons (iad_conv a0 a) (pl_produit_1 p x la) (pl_produit_0 a0 p ls x l)). intros. rewrite H4 in H1. inversion H1. right. left. split with a. split.

	reflexivity. exact (prec_hd a la ls). left. elim (H0 b x H9). intros. elim H10. intros. elim H11. intros.

	elim H12. intros. elim H13. intros. split with x0.

	split with x1. split. exact H12. split. exact H14.

	exact (prec_int0 a x1 la ls H15). elim (H _ _ _ _ H9). intros. left. elim H10. intros. elim H11.

	intros. elim H12. intros. elim H14. intros.

	split with x0. split with x1. split. exact H13.

	split. exact H15. exact (prec_int1 a _ la _ H16).

	intros. elim H10. intros. right. left. elim H11.

	intros. elim H12. intros. split with x0. split.

	exact H13. exact (prec_int1 a _ la _ H14). intros.

	right. right. exact H11. reflexivity.

Qed.



Lemma pl_produit_ref_ok_lem_4 :

 forall (a : ad) (la ls p : prec_list),

 pl_produit_ref_ok_0 la p ->

 pl_produit_ref_ok_1 ls p -> pl_produit_ref_ok_1 (prec_cons a la ls) p.

Proof.

	unfold pl_produit_ref_ok_0, pl_produit_ref_ok_1 in |- *.

	intros. elim (nat_sum n); intros. rewrite H2 in H1.

	inversion H1. elim H2. intros. rewrite H3 in H1.

	elim (pl_sum p). intros. rewrite H4 in H1.

	inversion H1. intros. elim H4. intros. elim H5.

	intros. elim H6. intros. rewrite H7 in H1. cut

  (pl_produit_1 (prec_cons a la ls) (S x) (prec_cons x0 x1 x2) =

   pl_produit_0 a la (prec_cons x0 x1 x2) x

     (pl_produit_1 ls x (prec_cons x0 x1 x2))). intro.

	rewrite H8 in H1. rewrite <- H7 in H1. elim (H _ _ _ _ H1). intros. elim H9. intros. elim H10. intros.

	elim H11. intros. elim H13. intros. split with x3.

	split with x4. split. exact H12. split. exact (prec_int0 a x3 la ls H14). exact H15. intros.

	elim H9. intros. elim H10. intros. elim H11.

	intros. split with a. split with x3. split.

	exact H12. split. exact (prec_hd a la ls).

	exact H13. intros. elim (H0 _ _ H10). intros.

	elim H11. intros. elim H12. intros. elim H14.

	intros. split with x3. split with x4. split.

	exact H13. split. exact (prec_int1 a _ la _ H15).

	exact H16. reflexivity.

Qed.



Lemma pl_produit_ref_ok_lem_5 :

 forall p p' : prec_list,

 pl_produit_ref_ok_0 p p' /\ pl_produit_ref_ok_1 p p'.

Proof.

	exact

  (indprinciple_pl pl_produit_ref_ok_0 pl_produit_ref_ok_1

     pl_produit_ref_ok_lem_0 pl_produit_ref_ok_lem_1 pl_produit_ref_ok_lem_2

     pl_produit_ref_ok_lem_3 pl_produit_ref_ok_lem_4).

Qed.



Lemma pl_produit_ref_ok_lem_6 :

 forall (p0 p1 : prec_list) (b : ad),

 prec_occur (pl_produit p0 p1) b ->

 exists a0 : ad,

   (exists a1 : ad,

      b = iad_conv a0 a1 /\ prec_occur p0 a0 /\ prec_occur p1 a1).

Proof.

	unfold pl_produit in |- *. intro. intro. elim (pl_produit_ref_ok_lem_5 p0 p1). intros.

	exact (H0 _ _ H1).

Qed.



Lemma pl_produit_ref_ok :

 forall (p0 p1 : prec_list) (d0 d1 : preDTA),

 prec_list_ref_ok p0 d0 ->

 prec_list_ref_ok p1 d1 ->

 prec_list_ref_ok (pl_produit p0 p1) (preDTA_produit d0 d1).

Proof.

	unfold prec_list_ref_ok in |- *. intros. elim (pl_produit_ref_ok_lem_6 p0 p1 a H1). intros. elim H2.

	intros. elim H3. intros. elim H5. intros. elim (H _ H6).

	elim (H0 _ H7). intros. rewrite H4. split with (s_produit x2 x1). exact (predta_produit_2 d0 d1 x x0 x2 x1 H9 H8). 

Qed.



Lemma s_produit_l_ref_ok :

 forall (s : state) (a : ad) (p : prec_list) (d0 d1 : preDTA),

 state_ref_ok s d1 ->

 state_ref_ok (M1 prec_list a p) d0 ->

 state_ref_ok (s_produit_l a p s) (preDTA_produit d0 d1).

Proof.

	simple induction s. simpl in |- *. unfold state_ref_ok in |- *. intros. inversion H1.

	simpl in |- *. unfold state_ref_ok in |- *. intros. elim (bool_is_true_or_false (Neqb a1 a)); intros. rewrite H2 in H1. simpl in H1. elim (bool_is_true_or_false (Neqb a1 a2)); intros; rewrite H3 in H1;

  inversion H1. apply (pl_produit_ref_ok p a0 d0 d1).

	apply (H0 a1 p). simpl in |- *. rewrite (Neqb_correct a1). reflexivity.

	apply (H a a0). simpl in |- *. rewrite (Neqb_correct a). reflexivity.

	rewrite H2 in H1. inversion H1. intro. intro. intro. intro.

	unfold state_ref_ok in |- *. intros. cut (forall a : ad, state_ref_ok (M1 prec_list a p) d0). intros. elim (state_ref_ok_M2_destr _ _ _ H1). intros. simpl in H3. induction  a as [| p1]. induction  a0 as [| p1]. simpl in H3. exact (H _ _ _ _ H5 (H4 N0) _ _ H3). induction  p1 as [p1 Hrecp1| p1 Hrecp1| ].

	simpl in H3. inversion H3. simpl in H3. exact (H _ _ _ _ H5 (H4 N0) _ _ H3). simpl in H3. inversion H3. elim (positive_sum p1). intros. rewrite H7 in H3. simpl in H3.

	induction  a0 as [| p2]. inversion H3. elim (positive_sum p2); intros.

	rewrite H8 in H3. exact (H0 _ _ _ _ H6 (H4 N0) _ _ H3).

	elim H8; intros; elim H9; intros; rewrite H10 in H3.

	inversion H3. exact (H0 _ _ _ _ H6 (H4 N0) _ _ H3).

	intros. elim H7; intros; elim H8; intros; rewrite H9 in H3.

	simpl in H3. induction  a0 as [| p2]. exact (H _ _ _ _ H5 (H4 (Npos x)) _ _ H3). elim (positive_sum p2); intros. rewrite H10 in H3.

	inversion H3. elim H10; intros; elim H11; intros; rewrite H12 in H3. exact (H _ _ _ _ H5 (H4 (Npos x)) _ _ H3).

	inversion H3. simpl in H3. induction  a0 as [| p2]. inversion H3.

	elim (positive_sum p2); intros. rewrite H10 in H3. exact (H0 _ _ _ _ H6 (H4 (Npos x)) _ _ H3). elim H10; intros; elim H11; intros; rewrite H12 in H3. inversion H3. exact (H0 _ _ _ _ H6 (H4 (Npos x)) _ _ H3). intros. unfold state_ref_ok in |- *. intros. simpl in H4. elim (bool_is_true_or_false (Neqb a1 a2)); intros; rewrite H5 in H4. inversion H4.

	rewrite <- H7. apply (H2 a p). simpl in |- *. rewrite (Neqb_correct a).

	reflexivity. inversion H4.

Qed.



Lemma s_produit_r_ref_ok :

 forall (s : state) (a : ad) (p : prec_list) (d0 d1 : preDTA),

 state_ref_ok s d1 ->

 state_ref_ok (M1 prec_list a p) d0 ->

 state_ref_ok (s_produit_r a p s) (preDTA_produit d1 d0).

Proof.

	simple induction s. simpl in |- *. unfold state_ref_ok in |- *. intros. inversion H1.

	simpl in |- *. unfold state_ref_ok in |- *. intros. elim (bool_is_true_or_false (Neqb a1 a)); intros. rewrite H2 in H1. simpl in H1. elim (bool_is_true_or_false (Neqb a1 a2)); intros; rewrite H3 in H1;

  inversion H1. apply (pl_produit_ref_ok a0 p d1 d0). apply (H a a0). simpl in |- *. rewrite (Neqb_correct a). reflexivity.

	apply (H0 a1 p). simpl in |- *. rewrite (Neqb_correct a1). reflexivity.

	rewrite H2 in H1. inversion H1. intro. intro. intro. intro.

	unfold state_ref_ok in |- *. intros. cut (forall a : ad, state_ref_ok (M1 prec_list a p) d0). intro. elim (state_ref_ok_M2_destr _ _ _ H1). intros. simpl in H3. induction  a as [| p1]. simpl in H3. induction  a0 as [| p1]. exact (H _ _ _ _ H5 (H4 N0) _ _ H3). elim (positive_sum p1). intros. rewrite H7 in H3. inversion H3. intros. elim H7; intros; elim H8; intros; rewrite H9 in H3. exact (H _ _ _ _ H5 (H4 N0) _ _ H3). inversion H3. elim (positive_sum p1); intros. rewrite H7 in H3. simpl in H3. induction  a0 as [| p2]. inversion H3. elim (positive_sum p2); intros. rewrite H8 in H3. exact (H0 _ _ _ _ H6 (H4 N0) _ _ H3). elim H8; intros; elim H9; intros; rewrite H10 in H3. inversion H3. exact (H0 _ _ _ _ H6 (H4 N0) _ _ H3). elim H7; intros; elim H8; intros; rewrite H9 in H3. simpl in H3. induction  a0 as [| p2]. exact (H _ _ _ _ H5 (H4 (Npos x)) _ _ H3). elim (positive_sum p2); intros.

	rewrite H10 in H3. inversion H3. elim H10; intros; elim H11; intros; rewrite H12 in H3. exact (H _ _ _ _ H5 (H4 (Npos x)) _ _ H3). inversion H3. simpl in H3. induction  a0 as [| p2]. inversion H3. elim (positive_sum p2); intros. rewrite H10 in H3. exact (H0 _ _ _ _ H6 (H4 (Npos x)) _ _ H3).

	elim H10; intros; elim H11; intros; rewrite H12 in H3.

	inversion H3. exact (H0 _ _ _ _ H6 (H4 (Npos x)) _ _ H3).

	unfold state_ref_ok in |- *. intros. simpl in H4. elim (bool_is_true_or_false (Neqb a1 a2)); intros; rewrite H5 in H4. inversion H4. rewrite <- H7. apply (H2 a p).

	simpl in |- *. rewrite (Neqb_correct a). reflexivity.

	inversion H4.

Qed.



Lemma st_M0_ref_ok : forall d : preDTA, state_ref_ok (M0 prec_list) d.

Proof.

	unfold state_ref_ok in |- *. intros. inversion H.

Qed.



Lemma s_produit_ref_ok :

 forall (s0 s1 : state) (d0 d1 : preDTA),

 state_ref_ok s0 d0 ->

 state_ref_ok s1 d1 -> state_ref_ok (s_produit s0 s1) (preDTA_produit d0 d1).

Proof.

	simple induction s0. simple induction s1. intros. simpl in |- *. exact (st_M0_ref_ok (preDTA_produit d0 d1)). intros. simpl in |- *.

	exact (st_M0_ref_ok (preDTA_produit d0 d1)). intros.

	simpl in |- *. exact (st_M0_ref_ok (preDTA_produit d0 d1)).

	simple induction s1. intros. simpl in |- *. exact (st_M0_ref_ok (preDTA_produit d0 d1)). intros. replace (s_produit (M1 prec_list a a0) (M1 prec_list a1 a2)) with

  (s_produit_l a a0 (M1 prec_list a1 a2)). exact (s_produit_l_ref_ok _ _ _ _ _ H0 H). reflexivity.

	intros. replace (s_produit (M1 prec_list a a0) (M2 prec_list m m0)) with

  (s_produit_l a a0 (M2 prec_list m m0)). exact (s_produit_l_ref_ok _ _ _ _ _ H2 H1).

	reflexivity. simple induction s1. intros. intros. simpl in |- *.

	exact (st_M0_ref_ok (preDTA_produit d0 d1)). intros.

	replace (s_produit (M2 prec_list m m0) (M1 prec_list a a0)) with

  (s_produit_r a a0 (M2 prec_list m m0)).

	exact (s_produit_r_ref_ok _ _ _ _ _ H1 H2). reflexivity.

	intros. simpl in |- *. elim (state_ref_ok_M2_destr _ _ _ H3).

	intros. elim (state_ref_ok_M2_destr _ _ _ H4). intros.

	unfold state_ref_ok in |- *. intros. induction  a as [| p0]. simpl in H9.

	exact (H _ _ _ H5 H7 N0 p H9). induction  p0 as [p0 Hrecp0| p0 Hrecp0| ]; simpl in H9. exact (H0 _ _ _ H6 H8 (Npos p0) p H9). exact (H _ _ _ H5 H7 _ _ H9). exact (H0 _ _ _ H6 H8 _ _ H9).

Qed.



Lemma preDTA_produit_l_ref_ok :

 forall (d d0 d1 : preDTA) (s : state) (a : ad),

 preDTA_ref_ok_distinct d d1 ->

 preDTA_ref_ok_distinct (M1 state a s) d0 ->

 preDTA_ref_ok_distinct (preDTA_produit_l a s d) (preDTA_produit d0 d1).

Proof.

	unfold preDTA_ref_ok_distinct in |- *. simple induction d. intros.

	inversion H1. intros. simpl in H1. elim (bool_is_true_or_false (Neqb (iad_conv a1 a) a2)); intros;

  rewrite H2 in H1; inversion H1. apply (s_produit_ref_ok s a0 d0 d1). apply (H0 a1 s).

	simpl in |- *. rewrite (Neqb_correct a1). reflexivity.

	apply (H a a0). simpl in |- *; rewrite (Neqb_correct a).

	reflexivity. intros. elim (preDTA_ref_ok_distinct_dest m m0 d1 H1). intros. cut (forall a : ad, preDTA_ref_ok_distinct (M1 state a s) d0). intros. induction  a as [| p]. simpl in H3.

	induction  a0 as [| p]. exact (H _ _ _ _ H4 (H6 N0) _ _ H3).

	induction  p as [p Hrecp| p Hrecp| ]. inversion H3. elim (positive_sum p).

	intros. rewrite H7 in H3. exact (H0 _ _ _ _ H5 (H6 N0) _ _ H3). intros. elim H7; intros; elim H8; intros; rewrite H9 in H3. exact (H _ _ _ _ H4 (H6 N0) _ _ H3). exact (H0 _ _ _ _ H5 (H6 N0) _ _ H3).

	inversion H3. induction  p as [p Hrecp| p Hrecp| ]. induction  a0 as [| p0]. simpl in H3.

	inversion H3. clear Hrecp. induction  p0 as [p0 Hrecp0| p0 Hrecp0| ]; simpl in H3.

	elim (positive_sum p0); intros. rewrite H7 in H3.

	exact (H0 _ _ _ _ H5 (H6 (Npos p)) _ _ H3).

	elim H7; intros; elim H8; intros; rewrite H9 in H3.

	exact (H _ _ _ _ H4 (H6 (Npos p)) _ _ H3). exact (H0 _ _ _ _ H5 (H6 (Npos p)) _ _ H3). inversion H3.

	exact (H _ _ _ _ H4 (H6 (Npos p)) _ _ H3). 

	induction  a0 as [| p0]. simpl in H3. exact (H _ _ _ _ H4 (H6 (Npos p)) _ _ H3). induction  p0 as [p0 Hrecp0| p0 Hrecp0| ]; simpl in H3.

	inversion H3. elim (positive_sum p0); intros.

	rewrite H7 in H3. exact (H0 _ _ _ _ H5 (H6 (Npos p)) _ _ H3). elim H7; intros; elim H8; intros; rewrite H9 in H3. exact (H _ _ _ _ H4 (H6 (Npos p)) _ _ H3). exact (H0 _ _ _ _ H5 (H6 (Npos p)) _ _ H3). inversion H3. induction  a0 as [| p]. simpl in H3.

	inversion H3. induction  p as [p Hrecp| p Hrecp| ]. simpl in H3. elim (positive_sum p); intros. rewrite H7 in H3.

	exact (H0 _ _ _ _ H5 (H6 N0) _ _ H3). elim H7; intros; elim H8; intros; rewrite H9 in H3.

	exact (H _ _ _ _ H4 (H6 N0) _ _ H3). exact (H0 _ _ _ _ H5 (H6 N0) _ _ H3). simpl in H3. 

	inversion H3. simpl in H3. exact (H _ _ _ _ H4 (H6 N0) _ _ H3). unfold preDTA_ref_ok_distinct in |- *.

	intros. simpl in H6. elim (bool_is_true_or_false (Neqb a1 a2)); intros; rewrite H7 in H6;

  inversion H6. rewrite <- H9. apply (H2 a s).

	simpl in |- *. rewrite (Neqb_correct a). reflexivity.

Qed.



Lemma preDTA_produit_r_ref_ok :

 forall (d d0 d1 : preDTA) (s : state) (a : ad),

 preDTA_ref_ok_distinct d d0 ->

 preDTA_ref_ok_distinct (M1 state a s) d1 ->

 preDTA_ref_ok_distinct (preDTA_produit_r a s d) (preDTA_produit d0 d1).

Proof.

	unfold preDTA_ref_ok_distinct in |- *. simple induction d.

	intros. inversion H1. intros. simpl in H1.

	elim (bool_is_true_or_false (Neqb (iad_conv a a1) a2)); intros;

  rewrite H2 in H1; inversion H1.

	apply (s_produit_ref_ok a0 s d0 d1). apply (H a a0). simpl in |- *. rewrite (Neqb_correct a). reflexivity.

	apply (H0 a1 s). simpl in |- *. rewrite (Neqb_correct a1).

	reflexivity. intros. elim (preDTA_ref_ok_distinct_dest _ _ _ H1). intros. cut (forall a : ad, preDTA_ref_ok_distinct (M1 state a s) d1). intro. induction  a as [| p]. simpl in H3.

	induction  a0 as [| p]. exact (H _ _ _ _ H4 (H6 N0) _ _ H3).

	elim (positive_sum p); intros. rewrite H7 in H3.

	exact (H0 _ _ _ _ H5 (H6 N0) _ _ H3).

	elim H7; intros; elim H8; intros; rewrite H9 in H3.

	elim (positive_sum x); intros. rewrite H10 in H3.

	inversion H3. elim H10; intros; elim H11; intros; rewrite H12 in H3. exact (H _ _ _ _ H4 (H6 N0) _ _ H3). inversion H3. elim (positive_sum x); intros.

	rewrite H10 in H3. inversion H3. elim H10; intros; elim H11; intros; rewrite H12 in H3. exact (H0 _ _ _ _ H5 (H6 N0) _ _ H3). inversion H3. induction  p as [p Hrecp| p Hrecp| ]; simpl in H3. induction  a0 as [| p0]. inversion H3. elim (positive_sum p0); intros. rewrite H7 in H3.

	inversion H3. elim H7; intros; elim H8; intros; rewrite H9 in H3. elim (positive_sum p); intros.

	rewrite H10 in H3. elim (positive_sum x); intros.

	rewrite H11 in H3. exact (H _ _ _ _ H4 (H6 (Npos 1)) _ _ H3). elim H11; intros; elim H12; intros; rewrite H13 in H3. inversion H3. exact (H _ _ _ _ H4 (H6 (Npos 1)) _ _ H3). elim H10; intros; elim H11; intros; rewrite H12 in H3. elim (positive_sum x); intros. rewrite H13 in H3. exact (H _ _ _ _ H4 (H6 _) _ _ H3). elim H13; intros; elim H14; intros; rewrite H15 in H3. inversion H3. exact (H _ _ _ _ H4 (H6 _) _ _ H3). elim (positive_sum x); intros. rewrite H13 in H3. exact (H _ _ _ _ H4 (H6 _) _ _ H3). elim H13; intros; elim H14; intros; rewrite H15 in H3. inversion H3.

	exact (H _ _ _ _ H4 (H6 _) _ _ H3). elim (positive_sum x); intros. rewrite H10 in H3.

	exact (H0 _ _ _ _ H5 (H6 _) _ _ H3). elim H10; intros; elim H11; intros; rewrite H12 in H3.

	inversion H3. exact (H0 _ _ _ _ H5 (H6 _) _ _ H3).

	induction  a0 as [| p0]. exact (H _ _ _ _ H4 (H6 _) _ _ H3).

	elim (positive_sum p0); intros. rewrite H7 in H3.

	exact (H0 _ _ _ _ H5 (H6 _) _ _ H3). elim H7; intros; elim H8; intros; rewrite H9 in H3. elim (positive_sum x); intros. rewrite H10 in H3.

	inversion H3. elim H10; intros; elim H11; intros; rewrite H12 in H3. exact (H _ _ _ _ H4 (H6 _) _ _ H3). inversion H3. elim (positive_sum x); intros. rewrite H10 in H3. inversion H3.

	elim H10; intros; elim H11; intros; rewrite H12 in H3. exact (H0 _ _ _ _ H5 (H6 _) _ _ H3).

	inversion H3. induction  a0 as [| p]. inversion H3.

	elim (positive_sum p); intros. rewrite H7 in H3.

	inversion H3. elim H7; intros; elim H8; intros; rewrite H9 in H3. elim (positive_sum x); intros.

	rewrite H10 in H3. exact (H _ _ _ _ H4 (H6 _) _ _ H3). elim H10; intros; elim H11; intros; rewrite H12 in H3. inversion H3. exact (H _ _ _ _ H4 (H6 _) _ _ H3). elim (positive_sum x); intros.

	rewrite H10 in H3. exact (H0 _ _ _ _ H5 (H6 _) _ _ H3). elim H10; intros; elim H11; intros; rewrite H12 in H3. inversion H3. exact (H0 _ _ _ _ H5 (H6 _) _ _ H3). unfold preDTA_ref_ok_distinct in |- *.

	intros. simpl in H6. elim (bool_is_true_or_false (Neqb a1 a2)); intros; rewrite H7 in H6;

  inversion H6. rewrite <- H9. apply (H2 a s). simpl in |- *.

	rewrite (Neqb_correct a). reflexivity.

Qed.



Lemma preDTA_produit_ref_okd :

 forall d0 d1 d0' d1' : preDTA,

 preDTA_ref_ok_distinct d0 d0' ->

 preDTA_ref_ok_distinct d1 d1' ->

 preDTA_ref_ok_distinct (preDTA_produit d0 d1) (preDTA_produit d0' d1').

Proof.

	simple induction d0. simple induction d1. simpl in |- *. intros. unfold preDTA_ref_ok_distinct in |- *. intros. inversion H1. simpl in |- *.

	intros. unfold preDTA_ref_ok_distinct in |- *. intros. 

	inversion H1. intros. simpl in |- *. unfold preDTA_ref_ok_distinct in |- *.

	intros. inversion H3. simple induction d1. simpl in |- *. intros.

	unfold preDTA_ref_ok_distinct in |- *. intros. inversion H1.

	intros. replace (preDTA_produit (M1 state a a0) (M1 state a1 a2)) with

  (preDTA_produit_l a a0 (M1 state a1 a2)). exact (preDTA_produit_l_ref_ok _ _ _ _ _ H0 H). reflexivity. intros. replace (preDTA_produit (M1 state a a0) (M2 state m m0)) with

  (preDTA_produit_l a a0 (M2 state m m0)). exact (preDTA_produit_l_ref_ok _ _ _ _ _ H2 H1). reflexivity.

	simple induction d1. intros. simpl in |- *. unfold preDTA_ref_ok_distinct in |- *.

	intros. inversion H3. intros. replace (preDTA_produit (M2 state m m0) (M1 state a a0)) with

  (preDTA_produit_r a a0 (M2 state m m0)). exact (preDTA_produit_r_ref_ok _ _ _ _ _ H1 H2). reflexivity. intros. elim (preDTA_ref_ok_distinct_dest _ _ _ H3). elim (preDTA_ref_ok_distinct_dest _ _ _ H4). intros.

	simpl in |- *. unfold preDTA_ref_ok_distinct in |- *. intros.

	induction  a as [| p]. simpl in H9. exact (H _ _ _ H7 H5 _ _ H9). induction  p as [p Hrecp| p Hrecp| ]. simpl in H9. elim (positive_sum p); intros. rewrite H10 in H9. exact (H0 _ _ _ H8 H6 _ _ H9). elim H10; intros; elim H11; intros; rewrite H12 in H9. exact (H0 _ _ _ H8 H5 _ _ H9).

	exact (H0 _ _ _ H8 H6 _ _ H9). simpl in H9.

	elim (positive_sum p); intros. rewrite H10 in H9.

	exact (H _ _ _ H7 H6 _ _ H9). elim H10; intros; elim H11; intros; rewrite H12 in H9. exact (H _ _ _ H7 H5 _ _ H9). exact (H _ _ _ H7 H6 _ _ H9).

	simpl in H9. exact (H0 _ _ _ H8 H5 _ _ H9).

Qed.



Lemma preDTA_produit_ref_ok :

 forall d0 d1 : preDTA,

 preDTA_ref_ok d0 -> preDTA_ref_ok d1 -> preDTA_ref_ok (preDTA_produit d0 d1).

Proof.

	intros. cut (preDTA_ref_ok_distinct (preDTA_produit d0 d1) (preDTA_produit d0 d1)).

	intro. unfold preDTA_ref_ok_distinct in H1.

	elim (preDTA_ref_ok_def (preDTA_produit d0 d1)).

	intros. exact (H3 H1). apply (preDTA_produit_ref_okd d0 d1 d0 d1). unfold preDTA_ref_ok_distinct in |- *.

	elim (preDTA_ref_ok_def d0). intros. exact (H1 H _ _ H3). elim (preDTA_ref_ok_def d1); intros.

	exact (H1 H0).

Qed.



Lemma DTA_inter_ref_ok_invar :

 forall d0 d1 : DTA,

 DTA_ref_ok d0 -> DTA_ref_ok d1 -> DTA_ref_ok (inter d0 d1).

Proof.

	simple induction d0. simple induction d1. intros. simpl in H.

	simpl in H0. simpl in |- *. exact (preDTA_produit_ref_ok p p0 H H0).

Qed.



Lemma inter_DTA_main_state_correct_invar :

 forall d0 d1 : DTA,

 DTA_main_state_correct d0 ->

 DTA_main_state_correct d1 -> DTA_main_state_correct (inter d0 d1).

Proof.

	simple induction d0. simple induction d1. simpl in |- *. unfold addr_in_preDTA in |- *. intros. elim H. intros.

	elim H0. intros. split with (s_produit x x0).

	exact (predta_produit_2 _ _ _ _ _ _ H1 H2).

Qed.
