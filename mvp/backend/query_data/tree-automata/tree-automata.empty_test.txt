
Require Import Bool.
Require Import Arith.
Require Import NArith.
Require Import Ndec.
Require Import ZArith.
Require Import Classical_Prop.
From IntMap Require Import Allmaps.
Require Import lattice_fixpoint.
(* lattice_fixpoint:
Require Import Classical_Prop.
Require Import Bool.
Require Import Arith.
Require Import NArith.
Require Import Ndec.
From IntMap Require Import Allmaps.
Require Import bases.

Fixpoint domain_equal (A B : Set) (m0 : Map A) (m1 : Map B) {struct m1} :
 Prop :=
  match m0, m1 with
  | M0, M0 => True
  | M0, M1 _ _ => False
  | M0, M2 _ _ => False
  | M1 _ _, M0 => False
  | M1 a _, M1 b _ => a = b
  | M1 _ _, M2 _ _ => False
  | M2 _ _, M0 => False
  | M2 _ _, M1 _ _ => False
  | M2 a b, M2 c d => domain_equal A B a c /\ domain_equal A B b d
  end.

Lemma domain_equal_mapget :
 forall (A B : Set) (m0 : Map A) (m1 : Map B) (a : ad) (x : A),
 domain_equal A B m0 m1 ->
 MapGet A m0 a = Some x -> exists y : B, MapGet B m1 a = Some y.

Lemma domain_equal_reflexive :
 forall (A : Set) (m : Map A), domain_equal A A m m.

Lemma domain_equal_symmetric :
 forall (A B : Set) (m0 : Map A) (m1 : Map B),
 domain_equal A B m0 m1 -> domain_equal B A m1 m0.

Lemma domain_equal_transitive :
 forall (A0 A1 A2 : Set) (m0 : Map A0) (m1 : Map A1) (m2 : Map A2),
 domain_equal A0 A1 m0 m1 ->
 domain_equal A1 A2 m1 m2 -> domain_equal A0 A2 m0 m2.

Lemma map_sum :
 forall (A : Set) (m : Map A),
 m = M0 A \/
 (exists a : ad, (exists x : A, m = M1 A a x)) \/
 (exists x : Map A, (exists y : Map A, m = M2 A x y)).

Definition mEnsemble (A : Set) := Map A -> Prop.

Definition mRelation (A : Set) := Map A -> Map A -> Prop.

Definition r_symmetric (A : Set) (r : mRelation A) :=
  forall x y : Map A, r x y -> r y x.

Definition r_antisymmetric (A : Set) (r : mRelation A) :=
  forall x y : Map A, r x y -> r y x -> x = y.

Definition r_transitive (A : Set) (r : mRelation A) :=
  forall x y z : Map A, r x y -> r y z -> r x z.

Definition r_reflexive (A : Set) (r : mRelation A) := forall x : Map A, r x x.

Definition r_order (A : Set) (r : mRelation A) :=
  r_reflexive A r /\ r_antisymmetric A r /\ r_transitive A r.

Definition mini (A : Set) (r : mRelation A) (T : mEnsemble A) 
  (e : Map A) := T e /\ (forall x : Map A, T x -> r e x).

Definition maxi (A : Set) (r : mRelation A) (T : mEnsemble A) 
  (e : Map A) := T e /\ (forall x : Map A, T x -> r x e).

Definition mLattice (A : Set) (r : mRelation A) (T : mEnsemble A)
  (e f : Map A) := r_order A r /\ mini A r T e /\ maxi A r T f.

Inductive prechain (A : Set) : Set :=
  | single : Map A -> prechain A
  | concat : prechain A -> Map A -> prechain A.

Lemma prechain_sum :
 forall (A : Set) (p : prechain A),
 (exists x : Map A, p = single A x) \/
 (exists x : Map A, (exists y : prechain A, p = concat A y x)).

Inductive prechain_dom_ok (A : Set) : mEnsemble A -> prechain A -> Prop :=
  | domok_single :
      forall (x : Map A) (T : mEnsemble A),
      T x -> prechain_dom_ok A T (single A x)
  | domok_concat :
      forall (x : Map A) (T : mEnsemble A) (p : prechain A),
      T x -> prechain_dom_ok A T p -> prechain_dom_ok A T (concat A p x).

Fixpoint chain_length (A : Set) (p : prechain A) {struct p} : nat :=
  match p with
  | single x => 1
  | concat x y => S (chain_length A x)
  end.

Definition prechain_last (A : Set) (p : prechain A) : 
  Map A := match p with
           | single x => x
           | concat z x => x
           end.

Inductive prechain_incr (A : Set) : mRelation A -> prechain A -> Prop :=
  | incr_single :
      forall (x : Map A) (r : mRelation A), prechain_incr A r (single A x)
  | incr_concat :
      forall (x : Map A) (r : mRelation A) (p : prechain A),
      r (prechain_last A p) x ->
      prechain_incr A r p -> prechain_incr A r (concat A p x).

Inductive chain (A : Set) :
mEnsemble A -> mRelation A -> prechain A -> Prop :=
  | chain_single :
      forall (x : Map A) (T : mEnsemble A) (r : mRelation A),
      T x -> chain A T r (single A x)
  | chain_concat_s :
      forall (x y : Map A) (T : mEnsemble A) (r : mRelation A),
      T x -> T y -> r x y -> chain A T r (concat A (single A x) y)
  | chain_concat_m :
      forall (x y : Map A) (z : prechain A) (T : mEnsemble A)
        (r : mRelation A),
      T y ->
      r x y ->
      chain A T r (concat A z x) -> chain A T r (concat A (concat A z x) y).

Lemma chain_def_ok :
 forall (A : Set) (T : mEnsemble A) (r : mRelation A) (p : prechain A),
 chain A T r p -> prechain_dom_ok A T p.

Lemma chain_incr :
 forall (A : Set) (T : mEnsemble A) (r : mRelation A) (p : prechain A),
 chain A T r p -> prechain_incr A r p.

Definition pre_domok_incr_chain_def (A : Set) (p : prechain A) :=
  forall (T : mEnsemble A) (r : mRelation A),
  prechain_dom_ok A T p /\ prechain_incr A r p -> chain A T r p.

Lemma pre_domok_incr_chain_0 :
 forall (A : Set) (m : Map A), pre_domok_incr_chain_def A (single A m).

Lemma pre_domok_incr_chain_1 :
 forall (A : Set) (p : prechain A),
 pre_domok_incr_chain_def A p ->
 forall m : Map A, pre_domok_incr_chain_def A (concat A p m).

Lemma pre_domok_incr_chain_2 :
 forall (A : Set) (p : prechain A), pre_domok_incr_chain_def A p.

Lemma pre_domok_incr_chain :
 forall (A : Set) (p : prechain A) (T : mEnsemble A) (r : mRelation A),
 prechain_dom_ok A T p /\ prechain_incr A r p -> chain A T r p.

Inductive dist_chain (A : Set) : prechain A -> Prop :=
  | dist_single : forall x : Map A, dist_chain A (single A x)
  | dist_concat_s :
      forall x y : Map A, x <> y -> dist_chain A (concat A (single A x) y)
  | dist_concat_m :
      forall (x y : Map A) (z : prechain A),
      x <> y ->
      dist_chain A (concat A z x) -> dist_chain A (concat A (concat A z x) y).

Inductive non_dist_chain (A : Set) : prechain A -> Prop :=
  | non_dist_concat_s :
      forall x : Map A, non_dist_chain A (concat A (single A x) x)
  | non_dist_concat_m_hd :
      forall (x : Map A) (z : prechain A),
      non_dist_chain A (concat A (concat A z x) x)
  | non_dist_concat_m_tl :
      forall (x y : Map A) (z : prechain A),
      non_dist_chain A (concat A z x) ->
      non_dist_chain A (concat A (concat A z x) y).

Definition sas_chain (A : Set) (T : mEnsemble A) (r : mRelation A)
  (p : prechain A) : Prop := chain A T r p /\ dist_chain A p.

Definition dist_compl_def_0 (A : Set) (p : prechain A) : Prop :=
  dist_chain A p \/ non_dist_chain A p.

Lemma dist_compl_0 :
 forall (A : Set) (m : Map A), dist_compl_def_0 A (single A m).

Definition dist_compl_def_1 (A : Set) (p : prechain A) : Prop :=
  dist_compl_def_0 A p -> forall m : Map A, dist_compl_def_0 A (concat A p m).

Lemma dist_compl_1 :
 forall (A : Set) (m : Map A), dist_compl_def_1 A (single A m).

Lemma dist_compl_2 :
 forall (A : Set) (p : prechain A),
 dist_compl_def_1 A p -> forall m : Map A, dist_compl_def_1 A (concat A p m).

Lemma dist_compl_3 :
 forall (A : Set) (p : prechain A),
 dist_compl_def_0 A p -> forall m : Map A, dist_compl_def_0 A (concat A p m).

Lemma dist_compl_4 :
 forall (A : Set) (p : prechain A), dist_chain A p \/ non_dist_chain A p.

Lemma dist_compl_5 :
 forall (A : Set) (x : Map A), ~ dist_chain A (concat A (single A x) x).

Lemma dist_compl_6 :
 forall (A : Set) (x : Map A) (z : prechain A),
 ~ dist_chain A (concat A (concat A z x) x).

Lemma dist_compl_7 :
 forall (A : Set) (x y : Map A) (z : prechain A),
 non_dist_chain A (concat A z x) ->
 ~ dist_chain A (concat A z x) -> ~ dist_chain A (concat A (concat A z x) y).

Lemma dist_compl_8 :
 forall (A : Set) (p : prechain A), non_dist_chain A p -> ~ dist_chain A p.

Lemma dist_compl :
 forall (A : Set) (p : prechain A), ~ dist_chain A p <-> non_dist_chain A p.

Definition bounded_sas_chain (A : Set) (T : mEnsemble A) 
  (r : mRelation A) (n : nat) : Prop :=
  forall p : prechain A, sas_chain A T r p -> chain_length A p <= n.

Definition def_ok_app (A : Set) (T : mEnsemble A) (f : Map A -> Map A) :
  Prop := forall x : Map A, T x -> T (f x).

Definition increasing_app (A : Set) (r : mRelation A) 
  (f : Map A -> Map A) : Prop := forall x y : Map A, r x y -> r (f x) (f y).

Definition fix_point (A : Set) (T : mEnsemble A) (f : Map A -> Map A)
  (x : Map A) : Prop := T x /\ f x = x.

Definition inf_fix_points (A : Set) (T : mEnsemble A) 
  (r : mRelation A) (f : Map A -> Map A) (x : Map A) : Prop :=
  forall y : Map A, fix_point A T f y -> r x y.

Definition lower_fix_point (A : Set) (T : mEnsemble A) 
  (r : mRelation A) (f : Map A -> Map A) (x : Map A) : Prop :=
  fix_point A T f x /\ inf_fix_points A T r f x.

Fixpoint iteres (A : Set) (f : Map A -> Map A) (x : Map A) 
 (n : nat) {struct n} : prechain A :=
  match n with
  | O => single A x
  | S p =>
      match iteres A f x p with
      | single y => concat A (single A y) (f y)
      | concat z y => concat A (concat A z y) (f y)
      end
  end.

Fixpoint power (A : Set) (f : A -> A) (x : A) (n : nat) {struct n} : A :=
  match n with
  | O => x
  | S n => f (power A f x n)
  end.

Inductive MapFlag (A : Set) : Set :=
  | flag_true : Map A -> MapFlag A
  | flag_false : Map A -> MapFlag A.

Lemma MapFlag_sum :
 forall (A : Set) (f : MapFlag A),
 exists x : Map A, f = flag_true A x \/ f = flag_false A x.

Fixpoint lazy_power_aux (A : Set) (egalite : Map A -> Map A -> bool)
 (f : Map A -> Map A) (x : Map A) (n : nat) {struct n} : 
 MapFlag A :=
  match n with
  | O => flag_false A x
  | S p =>
      match lazy_power_aux A egalite f x p with
      | flag_true y => flag_true A y
      | flag_false y =>
          match f y with
          | z => if egalite y z then flag_true A y else flag_false A z
          end
      end
  end.

Definition lazy_power (A : Set) (egalite : Map A -> Map A -> bool)
  (f : Map A -> Map A) (x : Map A) (n : nat) : Map A :=
  match lazy_power_aux A egalite f x n with
  | flag_false z => z
  | flag_true z => z
  end.
 
Lemma lazy_power_eg_power_0 :
 forall (A : Set) (egalite : Map A -> Map A -> bool) 
   (f : Map A -> Map A) (x : Map A) (n : nat),
 (forall a b : Map A, egalite a b = true <-> a = b) ->
 forall z : Map A,
 (lazy_power_aux A egalite f x n = flag_true A z ->
  z = power (Map A) f x n /\ z = f z) /\
 (lazy_power_aux A egalite f x n = flag_false A z -> z = power (Map A) f x n).

Lemma lazy_power_eg_power :
 forall (A : Set) (egalite : Map A -> Map A -> bool) 
   (f : Map A -> Map A) (x : Map A) (n : nat),
 (forall a b : Map A, egalite a b = true <-> a = b) ->
 lazy_power A egalite f x n = power (Map A) f x n.

Fixpoint iteres_0 (A : Set) (f : Map A -> Map A) (x : Map A) 
 (n : nat) {struct n} : prechain A :=
  match n with
  | O => single A x
  | S p =>
      match iteres_0 A f x p with
      | single y => concat A (single A y) (power (Map A) f x (S p))
      | concat z y => concat A (concat A z y) (power (Map A) f x (S p))
      end
  end.

Lemma iteres_eq_0 :
 forall (A : Set) (f : Map A -> Map A) (x : Map A) (n : nat),
 prechain_last A (iteres A f x n) = power (Map A) f x n.

Lemma iteres_eq :
 forall (A : Set) (f : Map A -> Map A) (x : Map A) (n : nat),
 iteres A f x n = iteres_0 A f x n.

Lemma iteres_def_ok :
 forall (A : Set) (T : mEnsemble A) (f : Map A -> Map A) 
   (x : Map A) (n k : nat),
 def_ok_app A T f -> T (power (Map A) f x n) -> T (power (Map A) f x (n + k)).

Lemma power_def_ok :
 forall (A : Set) (T : mEnsemble A) (f : Map A -> Map A) 
   (x : Map A) (n : nat), def_ok_app A T f -> T x -> T (power (Map A) f x n).

Definition iteres_ult_const_def_0 (A : Set) (p : prechain A) : Prop :=
  forall (f : Map A -> Map A) (x : Map A) (n : nat),
  p = iteres A f x n ->
  non_dist_chain A p ->
  exists q : nat, S q <= n /\ power (Map A) f x q = power (Map A) f x (S q).

Lemma iteres_ult_const_0 :
 forall (A : Set) (x : Map A),
 iteres_ult_const_def_0 A (concat A (single A x) x).

Lemma iteres_ult_const_1 :
 forall (A : Set) (x : Map A) (z : prechain A),
 iteres_ult_const_def_0 A (concat A (concat A z x) x).

Lemma iteres_ult_const_2 :
 forall (A : Set) (x y : Map A) (z : prechain A),
 non_dist_chain A (concat A z x) ->
 iteres_ult_const_def_0 A (concat A z x) ->
 iteres_ult_const_def_0 A (concat A (concat A z x) y).

Lemma iteres_ult_const_3 :
 forall (A : Set) (p : prechain A),
 non_dist_chain A p -> iteres_ult_const_def_0 A p.

Lemma iteres_ult_const_4 :
 forall (A : Set) (f : Map A -> Map A) (x : Map A) (n : nat),
 non_dist_chain A (iteres A f x n) ->
 exists p : nat, S p <= n /\ power (Map A) f x p = power (Map A) f x (S p).

Lemma iteres_last :
 forall (A : Set) (f : Map A -> Map A) (x : Map A) 
   (n : nat) (y : prechain A) (z : Map A),
 iteres A f x n = concat A y z -> z = f (prechain_last A y).

Lemma iteres_dom_ok :
 forall (A : Set) (T : mEnsemble A) (f : Map A -> Map A) 
   (x : Map A) (n : nat),
 T x -> def_ok_app A T f -> prechain_dom_ok A T (iteres A f x n).

Lemma iteres_incr :
 forall (A : Set) (r : mRelation A) (f : Map A -> Map A) 
   (x : Map A) (n : nat),
 r x (f x) -> increasing_app A r f -> prechain_incr A r (iteres A f x n).

Lemma iteres_increasing_chain :
 forall (A : Set) (T : mEnsemble A) (r : mRelation A) 
   (f : Map A -> Map A) (x : Map A) (n : nat),
 T x ->
 def_ok_app A T f ->
 increasing_app A r f -> r x (f x) -> chain A T r (iteres A f x n).

Lemma iteres_length :
 forall (A : Set) (f : Map A -> Map A) (x : Map A) (n : nat),
 chain_length A (iteres A f x n) = S n.

Lemma iteres_non_sas_chain :
 forall (A : Set) (T : mEnsemble A) (r : mRelation A) 
   (f : Map A -> Map A) (x : Map A) (n m : nat),
 T x ->
 def_ok_app A T f ->
 increasing_app A r f ->
 r x (f x) ->
 bounded_sas_chain A T r m ->
 m <= n -> chain A T r (iteres A f x n) /\ ~ dist_chain A (iteres A f x n).

Lemma iteres_non_sas_chain_fp_0 :
 forall (A : Set) (T : mEnsemble A) (r : mRelation A) 
   (f : Map A -> Map A) (x : Map A) (n m : nat),
 T x ->
 def_ok_app A T f ->
 increasing_app A r f ->
 r x (f x) ->
 bounded_sas_chain A T r m ->
 m <= n ->
 exists p : nat, S p <= n /\ power (Map A) f x p = power (Map A) f x (S p).

Lemma iteres_non_sas_chain_fp_1 :
 forall (A : Set) (T : mEnsemble A) (f : Map A -> Map A) 
   (x : Map A) (k p : nat),
 def_ok_app A T f ->
 fix_point A T f (power (Map A) f x p) ->
 fix_point A T f (power (Map A) f x (p + k)).

Lemma iteres_non_sas_chain_fp_2 :
 forall (A : Set) (T : mEnsemble A) (r : mRelation A) 
   (f : Map A -> Map A) (x : Map A) (n m : nat),
 T x ->
 def_ok_app A T f ->
 increasing_app A r f ->
 r x (f x) ->
 bounded_sas_chain A T r m -> m <= n -> fix_point A T f (power (Map A) f x n).

Lemma iteres_inf_fps :
 forall (A : Set) (T : mEnsemble A) (r : mRelation A) 
   (f : Map A -> Map A) (e x : Map A) (n : nat),
 mini A r T e ->
 fix_point A T f x -> increasing_app A r f -> r (power (Map A) f e n) x.

Lemma iteres_lower_fix_point :
 forall (A : Set) (T : mEnsemble A) (r : mRelation A) 
   (f : Map A -> Map A) (e : Map A) (n m : nat),
 mini A r T e ->
 def_ok_app A T f ->
 increasing_app A r f ->
 bounded_sas_chain A T r m ->
 m <= n -> lower_fix_point A T r f (power (Map A) f e n).

Definition leb (b0 b1 : bool) : Prop :=
  match b0, b1 with
  | false, false => True
  | false, true => True
  | true, false => False
  | true, true => True
  end.

Lemma leb_reflexive : forall b : bool, leb b b.

Lemma leb_antisymmetric : forall b c : bool, leb b c -> leb c b -> b = c.

Lemma leb_transitive : forall a b c : bool, leb a b -> leb b c -> leb a c.

Fixpoint lem (m0 m1 : Map bool) {struct m1} : Prop :=
  match m0, m1 with
  | M0, M0 => True
  | M0, M1 _ _ => False
  | M0, M2 _ _ => False
  | M1 _ _, M0 => False
  | M1 a b, M1 a' b' => if Neqb a a' then leb b b' else False
  | M1 _ _, M2 _ _ => False
  | M2 _ _, M0 => False
  | M2 _ _, M1 _ _ => False
  | M2 a b, M2 c d => lem a c /\ lem b d
  end.

Lemma lem_reflexive : r_reflexive bool lem.

Lemma lem_antisymmetric : r_antisymmetric bool lem.

Lemma lem_transitive : r_transitive bool lem.

Lemma lem_order : r_order bool lem.

Definition ensemble_base (A : Set) (m : Map A) (x : Map bool) :=
  domain_equal A bool m x.

Fixpoint map_fill (A : Set) (m : Map A) {struct m} : 
 bool -> Map bool :=
  fun b : bool =>
  match m with
  | M0 => M0 bool
  | M1 a _ => M1 bool a b
  | M2 m0 m1 => M2 bool (map_fill A m0 b) (map_fill A m1 b)
  end.

Definition map_mini (A : Set) (m : Map A) : Map bool := map_fill A m false.

Definition map_maxi (A : Set) (m : Map A) : Map bool := map_fill A m true.

Lemma map_mini_appartient :
 forall (A : Set) (x : Map A), ensemble_base A x (map_mini A x).

Lemma map_maxi_appartient :
 forall (A : Set) (x : Map A), ensemble_base A x (map_maxi A x).

Lemma map_mini_mini :
 forall (A : Set) (x : Map A),
 mini bool lem (ensemble_base A x) (map_mini A x).

Lemma map_maxi_maxi :
 forall (A : Set) (x : Map A),
 maxi bool lem (ensemble_base A x) (map_maxi A x).

Lemma map_mini_mapget_false :
 forall (A : Set) (x : Map A) (a : ad) (b : bool),
 MapGet bool (map_mini A x) a = Some b -> b = false.

Lemma map_mini_mapget_true :
 forall (A : Set) (x : Map A) (a : ad),
 MapGet bool (map_mini A x) a = Some true -> False.

Lemma mlattice :
 forall (A : Set) (x : Map A),
 mLattice bool lem (ensemble_base A x) (map_mini A x) (map_maxi A x).

Definition lattice_bounded_def_0 (p : prechain bool) : Prop :=
  forall (A : Set) (m0 m1 : Map A),
  sas_chain bool (ensemble_base A (M2 A m0 m1)) lem p ->
  exists p0 : prechain bool,
    (exists p1 : prechain bool,
       sas_chain bool (ensemble_base A m0) lem p0 /\
       sas_chain bool (ensemble_base A m1) lem p1 /\
       lem (M2 bool (prechain_last bool p0) (prechain_last bool p1))
         (prechain_last bool p) /\
       chain_length bool p0 + chain_length bool p1 = S (chain_length bool p)).

Lemma lattice_bounded_0 :
 forall m : Map bool, lattice_bounded_def_0 (single bool m).

Definition lattice_bounded_def_1 (p : prechain bool) : Prop :=
  lattice_bounded_def_0 p ->
  forall m : Map bool, lattice_bounded_def_0 (concat bool p m).

Lemma lattice_bounded_1 :
 forall m : Map bool, lattice_bounded_def_1 (single bool m).

Lemma lattice_bounded_2 :
 forall p : prechain bool,
 lattice_bounded_def_1 p ->
 forall m : Map bool, lattice_bounded_def_1 (concat bool p m).

Lemma lattice_bounded_3 :
 forall p : prechain bool,
 lattice_bounded_def_0 p ->
 forall m : Map bool, lattice_bounded_def_0 (concat bool p m).

Lemma lattice_bounded_4 : forall p : prechain bool, lattice_bounded_def_0 p.

Lemma lattice_bounded_5 :
 forall (p : prechain bool) (A : Set) (m0 m1 : Map A),
 sas_chain bool (ensemble_base A (M2 A m0 m1)) lem p ->
 exists p0 : prechain bool,
   (exists p1 : prechain bool,
      sas_chain bool (ensemble_base A m0) lem p0 /\
      sas_chain bool (ensemble_base A m1) lem p1 /\
      lem (M2 bool (prechain_last bool p0) (prechain_last bool p1))
        (prechain_last bool p) /\
      chain_length bool p0 + chain_length bool p1 = S (chain_length bool p)).

Definition lattice_bounded_def_2 (A : Set) (m : Map A) : Prop :=
  forall p : prechain bool,
  sas_chain bool (ensemble_base A m) lem p ->
  chain_length bool p <= S (MapCard A m).

Lemma lattice_bounded_6 : forall A : Set, lattice_bounded_def_2 A (M0 A).

Lemma lattice_bounded_7 :
 forall (A : Set) (a : ad) (a0 : A), lattice_bounded_def_2 A (M1 A a a0).

Lemma lattice_bounded_8 :
 forall (A : Set) (m : Map A),
 lattice_bounded_def_2 A m ->
 forall m0 : Map A,
 lattice_bounded_def_2 A m0 -> lattice_bounded_def_2 A (M2 A m m0).

Lemma lattice_bounded_9 :
 forall (A : Set) (m : Map A), lattice_bounded_def_2 A m.

Lemma lattice_bounded_10 :
 forall (A : Set) (m : Map A) (p : prechain bool),
 sas_chain bool (ensemble_base A m) lem p ->
 chain_length bool p <= S (MapCard A m).

Lemma lattice_bounded :
 forall (A : Set) (x : Map A),
 bounded_sas_chain bool (ensemble_base A x) lem (S (MapCard A x)).

Definition eq_bool (b0 b1 : bool) : bool :=
  match b0, b1 with
  | false, false => true
  | false, true => false
  | true, false => false
  | true, true => true
  end.

Lemma eq_bool_equal : forall b0 b1 : bool, eq_bool b0 b1 = true -> b0 = b1.

Lemma equal_eq_bool : forall b : bool, eq_bool b b = true.

Fixpoint eqm_bool (x y : Map bool) {struct y} : bool :=
  match x, y with
  | M0, M0 => true
  | M0, M1 _ _ => false
  | M0, M2 _ _ => false
  | M1 _ _, M0 => false
  | M1 a b, M1 c d => Neqb a c && eq_bool b d
  | M1 _ _, M2 _ _ => false
  | M2 _ _, M0 => false
  | M2 _ _, M1 _ _ => false
  | M2 a b, M2 c d => eqm_bool a c && eqm_bool b d
  end.

Lemma eqm_bool_equal : forall x y : Map bool, eqm_bool x y = true -> x = y.

Lemma equal_eqm_bool : forall x : Map bool, eqm_bool x x = true.

Lemma lem_get_leb :
 forall (m0 m1 : Map bool) (a : ad) (b0 b1 : bool),
 lem m0 m1 ->
 MapGet bool m0 a = Some b0 ->
 MapGet bool m1 a = Some b1 -> leb b0 b1.

Lemma lem_domain_equal :
 forall m0 m1 : Map bool, lem m0 m1 -> domain_equal bool bool m0 m1.

Lemma andb_inc_r :
 forall b b0 b1 : bool, leb b0 b1 -> leb (b && b0) (b && b1).

Lemma andb_inc_l :
 forall b b0 b1 : bool, leb b0 b1 -> leb (b0 && b) (b1 && b).

Lemma orb_inc_r : forall b b0 b1 : bool, leb b0 b1 -> leb (b || b0) (b || b1).

Lemma orb_inc_l : forall b b0 b1 : bool, leb b0 b1 -> leb (b0 || b) (b1 || b).

Lemma andb_incr :
 forall b0 b1 b2 b3 : bool,
 leb b0 b1 -> leb b2 b3 -> leb (b0 && b2) (b1 && b3).

Lemma orb_incr :
 forall b0 b1 b2 b3 : bool,
 leb b0 b1 -> leb b2 b3 -> leb (b0 || b2) (b1 || b3). *)
Require Import bases.
(* bases:
Require Import Bool.
Require Import Arith.
Require Import ZArith.
Require Import NArith.
Require Import Ndec.
From IntMap Require Import Allmaps.
Require Import EqNat.
Require Export Max.

Lemma nat_sum : forall n : nat, n = 0 \/ (exists m : nat, n = S m).

Lemma le_n_n : forall n : nat, n <= n.

Lemma le_l_or_r : forall n m : nat, n <= m \/ m <= n.

Lemma plus_n_O : forall n : nat, n + 0 = n.
 
 Lemma S_plus_l : forall n m : nat, S (n + m) = S n + m.
 
 Lemma S_plus_r : forall n m : nat, S (n + m) = n + S m.

Lemma max_le_Sr_0 :
 forall n m : nat, max n m <= max n (S m) /\ max (S n) m <= max (S n) (S m).

Lemma max_le_Sr : forall n m : nat, max n m <= max n (S m).

Lemma plus_O_r : forall n : nat, n + 0 = n.

Lemma plus_O_l : forall n : nat, n + 0 = n.

Lemma le_mult_lS : forall n m : nat, n * m <= S n * m.

Lemma le_mult_rS : forall n m : nat, n * m <= n * S m.

Lemma le_disj : forall n m : nat, n <= m -> n = m \/ S n <= m.

Lemma le_mult_l : forall n m p : nat, n <= m -> n * p <= m * p.

Lemma le_mult_r : forall n m p : nat, n <= m -> p * n <= p * m.

Lemma le_mult_mult : forall n m p q : nat, n <= m -> p <= q -> n * p <= m * q.

Lemma Sn_eq_Sm_n_eq_m : forall n m : nat, S n = S m -> n = m.

Lemma bool_dec_eq : forall a b : bool, {a = b} + {a <> b}.

Lemma bool_is_false_or_true : forall a : bool, a = false \/ a = true.

Lemma bool_is_true_or_false : forall a : bool, a = true \/ a = false.

Lemma in_M0_false :
 forall (A : Set) (a : A), ~ (exists e : ad, MapGet A (M0 A) e = Some a).

Lemma in_M1_id :
 forall (A : Set) (a : A) (x : ad) (e : A),
 (exists c : ad, MapGet A (M1 A x e) c = Some a) -> a = e.

Lemma in_M2_disj :
 forall (A : Set) (a : A) (m0 m1 : Map A),
 (exists c : ad, MapGet A (M2 A m0 m1) c = Some a) ->
 (exists c : ad, MapGet A m0 c = Some a) \/
 (exists c : ad, MapGet A m1 c = Some a).

Lemma aux_Neqb_1_0 : forall p : positive, Peqb p p = true.

Lemma aux_Neqb_1_1 : forall p p0 : positive, Peqb p p0 = true -> p = p0.

Lemma aux_Neqb_trans :
 forall a b c : ad, Neqb a b = true -> Neqb b c = true -> Neqb a c = true.

Lemma indprinciple_nat_gen :
 forall P : nat -> Prop,
 (forall n : nat, (forall m : nat, m < n -> P m) -> P n) ->
 forall n m : nat, m <= n -> P m.

Lemma beq_nat_complete : forall n m : nat, beq_nat n m = true -> n = m.

Lemma beq_nat_correct : forall n : nat, beq_nat n n = true. *)
Require Import defs.
(* defs:
Require Import Bool.
Require Import Arith.
Require Import ZArith.
From IntMap Require Import Allmaps.
Require Import EqNat.
Require Import bases.

Inductive term : Set :=
    app : ad -> term_list -> term
with term_list : Set :=
  | tnil : term_list
  | tcons : term -> term_list -> term_list.

Scheme term_term_list_rec := Induction for term
  Sort Set
  with term_list_term_rec := Induction for term_list 
  Sort Set.

Scheme term_term_list_ind := Induction for term
  Sort Prop
  with term_list_term_ind := Induction for term_list 
  Sort Prop.

Lemma term_list_disj :
 forall l : term_list,
 l = tnil \/ (exists hd : term, (exists tl : term_list, l = tcons hd tl)).

Fixpoint lst_length (l : term_list) : nat :=
  match l with
  | tnil => 0
  | tcons _ l' => S (lst_length l')
  end.

Fixpoint term_high (t : term) : nat :=
  match t with
  | app a l => S (term_high_0 l)
  end
 
 with term_high_0 (l : term_list) : nat :=
  match l with
  | tnil => 0
  | tcons hd tl => max (term_high hd) (term_high_0 tl)
  end.

Lemma high_aux_0 :
 forall (a : ad) (l : term_list), S (term_high_0 l) <= term_high (app a l).

Lemma high_aux_1 :
 forall (a : ad) (l : term_list), S (term_high_0 l) = term_high (app a l).

Lemma high_aux_2 : forall (l : term_list) (c : ad), 1 <= term_high (app c l).

Lemma high_aux_3 :
 forall (t : term) (tl : term_list), term_high t <= term_high_0 (tcons t tl).

Lemma high_aux_4 :
 forall (t : term) (tl : term_list),
 term_high_0 tl <= term_high_0 (tcons t tl).

Fixpoint taille_term (t : term) : nat :=
  match t with
  | app c l => S (mtaille_term_list l)
  end
 
 with mtaille_term_list (l : term_list) : nat :=
  match l with
  | tnil => 0
  | tcons hd tl => max (taille_term hd) (mtaille_term_list tl)
  end.

Inductive prec_list : Set :=
  | prec_cons : ad -> prec_list -> prec_list -> prec_list
  | prec_empty : prec_list.

Lemma pl_sum :
 forall pl : prec_list,
 pl = prec_empty \/
 (exists a : ad,
    (exists la : prec_list, (exists ls : prec_list, pl = prec_cons a la ls))).

Definition state := Map prec_list.

Definition preDTA := Map state.

Inductive DTA : Set :=
    dta : preDTA -> ad -> DTA.

Fixpoint taille_0 (l : prec_list) : nat :=
  match l with
  | prec_empty => 0
  | prec_cons x y z => S (taille_0 y + taille_0 z)
  end.

Fixpoint taille_1 (s : state) : nat :=
  match s with
  | M0 => 0
  | M1 x y => taille_0 y
  | M2 x y => max (taille_1 x) (taille_1 y)
  end.

Fixpoint DTA_taille (d : preDTA) : nat :=
  match d with
  | M0 => 0
  | M1 x y => taille_1 y
  | M2 x y => max (DTA_taille x) (DTA_taille y)
  end.

Lemma taille_aux_0 :
 forall (a : ad) (la ls : prec_list),
 S (taille_0 la) <= taille_0 (prec_cons a la ls).

Lemma taille_aux_1 :
 forall (a : ad) (la ls : prec_list), 1 <= taille_0 (prec_cons a la ls).

Lemma taille_aux_2 :
 forall (a : ad) (la ls : prec_list),
 S (taille_0 ls) <= taille_0 (prec_cons a la ls).

Inductive prec_occur : prec_list -> ad -> Prop :=
  | prec_hd :
      forall (a : ad) (pl0 pl1 : prec_list),
      prec_occur (prec_cons a pl0 pl1) a
  | prec_int0 :
      forall (a b : ad) (pl0 pl1 : prec_list),
      prec_occur pl0 b -> prec_occur (prec_cons a pl0 pl1) b
  | prec_int1 :
      forall (a b : ad) (pl0 pl1 : prec_list),
      prec_occur pl1 b -> prec_occur (prec_cons a pl0 pl1) b.

Inductive prec_contained : prec_list -> prec_list -> Prop :=
  | prec_id : forall p : prec_list, prec_contained p p
  | prec_c_int0 :
      forall (p p0 p1 : prec_list) (a : ad),
      prec_contained p p0 -> prec_contained p (prec_cons a p0 p1)
  | prec_c_int1 :
      forall (p p0 p1 : prec_list) (a : ad),
      prec_contained p p1 -> prec_contained p (prec_cons a p0 p1).

Definition state_in_dta (d : preDTA) (s : state) : Prop :=
  exists a : ad, MapGet state d a = Some s.

Definition state_in_dta_diff (d : preDTA) (s : state) 
  (a : ad) : Prop := exists b : ad, MapGet state d b = Some s /\ a <> b.

Definition prec_in_dta (d : preDTA) (p : prec_list) : Prop :=
  exists s : state,
    (exists a : ad,
       (exists c : ad,
          MapGet state d a = Some s /\
          MapGet prec_list s c = Some p)).

Definition prec_in_dta_cont (d : preDTA) (p : prec_list) : Prop :=
  exists s : state,
    (exists b : ad,
       (exists c : ad,
          (exists p0 : prec_list,
             MapGet state d b = Some s /\
             MapGet prec_list s c = Some p0 /\ prec_contained p p0))).

Definition prec_in_dta_diff (d : preDTA) (p : prec_list) 
  (a : ad) : Prop :=
  exists s : state,
    (exists b : ad,
       (exists c : ad,
          MapGet state d b = Some s /\
          MapGet prec_list s c = Some p /\ a <> b)).

Definition prec_in_dta_diff_cont (d : preDTA) (p : prec_list) 
  (a : ad) : Prop :=
  exists s : state,
    (exists b : ad,
       (exists c : ad,
          (exists p0 : prec_list,
             MapGet state d b = Some s /\
             MapGet prec_list s c = Some p0 /\
             prec_contained p p0 /\ a <> b))).

Definition prec_in_state (s : state) (p : prec_list) : Prop :=
  exists c : ad, MapGet prec_list s c = Some p.

Lemma prec_in_state_M0_false :
 forall p : prec_list, ~ prec_in_state (M0 prec_list) p.

Lemma state_in_dta_M0_false : forall s : state, ~ state_in_dta (M0 state) s.

Lemma prec_occur_1 :
 forall (a : ad) (p0 p1 p2 : prec_list),
 prec_contained (prec_cons a p0 p1) p2 -> prec_occur p2 a.

Lemma prec_contained_0 :
 forall (a : ad) (p0 p1 p2 : prec_list),
 prec_contained (prec_cons a p0 p1) p2 -> prec_contained p0 p2.

Lemma prec_contained_1 :
 forall (a : ad) (p0 p1 p2 : prec_list),
 prec_contained (prec_cons a p0 p1) p2 -> prec_contained p1 p2.

Inductive term_occur : term -> term -> Prop :=
  | to_eq : forall t : term, term_occur t t
  | to_st :
      forall (t : term) (a : ad) (tl : term_list),
      term_list_occur t tl -> term_occur t (app a tl)
with term_list_occur : term -> term_list -> Prop :=
  | tlo_head :
      forall (t hd : term) (tl : term_list),
      term_occur t hd -> term_list_occur t (tcons hd tl)
  | tlo_tail :
      forall (t hd : term) (tl : term_list),
      term_list_occur t tl -> term_list_occur t (tcons hd tl).

Definition term_occur_def_0 (t : term) :=
  forall u : term, term_occur u t -> term_high u <= term_high t.

Definition term_occur_def_1 (t : term_list) :=
  forall u : term, term_list_occur u t -> term_high u <= term_high_0 t.

Lemma term_occur_0_0 :
 forall (a : ad) (t : term_list),
 term_occur_def_1 t -> term_occur_def_0 (app a t).

Lemma term_occur_0_1 : term_occur_def_1 tnil.

Lemma term_occur_0_2 :
 forall t : term,
 term_occur_def_0 t ->
 forall t0 : term_list, term_occur_def_1 t0 -> term_occur_def_1 (tcons t t0).

Lemma term_occur_0 :
 forall t u : term, term_occur u t -> term_high u <= term_high t.

Lemma term_occur_1 :
 forall (t : term_list) (u : term),
 term_list_occur u t -> term_high u <= term_high_0 t.

Definition indprinciple_3_aux (n : nat) :=
  forall P : term -> Prop,
  (forall (a : ad) (tl : term_list),
   (forall u : term, term_list_occur u tl -> P u) -> P (app a tl)) ->
  forall t : term, term_high t <= n -> P t.

Lemma indprinciple_3_0 : indprinciple_3_aux 0.

Lemma indprinciple_3_1 :
 forall n : nat, indprinciple_3_aux n -> indprinciple_3_aux (S n).

Lemma indprinciple_3_2 :
 forall (n : nat) (P : term -> Prop),
 (forall (a : ad) (tl : term_list),
  (forall u : term, term_list_occur u tl -> P u) -> P (app a tl)) ->
 forall t : term, term_high t <= n -> P t.

Lemma indprinciple_term :
 forall P : term -> Prop,
 (forall (a : ad) (tl : term_list),
  (forall u : term, term_list_occur u tl -> P u) -> P (app a tl)) ->
 forall t : term, P t.

Lemma Ndouble_inv_N0 : forall x : ad, Ndouble x = N0 -> x = N0.

Lemma Ndouble_inv_xO :
 forall (x : ad) (p : positive), Ndouble x = Npos (xO p) -> x = Npos p.

Lemma Ndouble_plus_one_inv_xH :
 forall x : ad, Ndouble_plus_one x = Npos 1 -> x = N0.

Lemma Ndouble_plus_one_inv_xI :
 forall (x : ad) (p : positive),
 Ndouble_plus_one x = Npos (xI p) -> x = Npos p. *)
Require Import semantics.
(* semantics:
Require Import Bool.
Require Import Arith.
Require Import Classical_Prop.
From IntMap Require Import Allmaps.
Require Import bases.
Require Import defs.

Unset Standard Proposition Elimination Names.

Fixpoint rec_term (d : preDTA) (a : ad) (t : term) 
 (n : nat) {struct n} : bool :=
  match n with
  | O => false
  | S k =>
      match t with
      | app c l =>
          match MapGet _ d a with
          | None => false
          | Some lts =>
              match MapGet _ lts c with
              | None => false
              | Some pre => rec_list_terms d pre l k
              end
          end
      end
  end
 
 with rec_list_terms (d : preDTA) (pre : prec_list) 
 (l : term_list) (n : nat) {struct n} : bool :=
  match n with
  | O => false
  | S k =>
      match pre with
      | prec_empty => match l with
                      | tnil => true
                      | _ => false
                      end
      | prec_cons st stp pre' =>
          match l with
          | tnil => false
          | tcons hd tl =>
              rec_list_terms d pre' l k
              || rec_term d st hd k && rec_list_terms d stp tl k
          end
      end
  end.

Lemma borne_0_0 :
 forall p : prec_list,
 prec_in_state (M0 prec_list) p -> taille_0 p <= taille_1 (M0 prec_list).

Lemma borne_0_1 :
 forall (a : ad) (p' p : prec_list),
 prec_in_state (M1 prec_list a p') p ->
 taille_0 p <= taille_1 (M1 prec_list a p').

Lemma borne_0_2 :
 forall (m0 m1 : Map prec_list) (p : prec_list),
 (prec_in_state m0 p -> taille_0 p <= taille_1 m0) ->
 (prec_in_state m1 p -> taille_0 p <= taille_1 m1) ->
 prec_in_state (M2 prec_list m0 m1) p ->
 taille_0 p <= taille_1 (M2 prec_list m0 m1).

Lemma borne_0 :
 forall (s : state) (p : prec_list),
 prec_in_state s p -> taille_0 p <= taille_1 s.

Lemma borne_1_0 :
 forall s : state,
 state_in_dta (M0 state) s -> taille_1 s <= DTA_taille (M0 state).

Lemma borne_1_1 :
 forall (a : ad) (s' s : state),
 state_in_dta (M1 state a s') s -> taille_1 s <= DTA_taille (M1 state a s').

Lemma borne_1_2 :
 forall (m0 m1 : Map state) (s : state),
 (state_in_dta m0 s -> taille_1 s <= DTA_taille m0) ->
 (state_in_dta m1 s -> taille_1 s <= DTA_taille m1) ->
 state_in_dta (M2 state m0 m1) s -> taille_1 s <= DTA_taille (M2 state m0 m1).

Lemma borne_1 :
 forall (d : preDTA) (s : state),
 state_in_dta d s -> taille_1 s <= DTA_taille d.

Lemma borne_2 :
 forall (d : preDTA) (p : prec_list),
 prec_in_dta d p -> taille_0 p <= DTA_taille d.

Definition essence (t : term) (d : preDTA) : nat :=
  S (term_high t) * S (DTA_taille d).

Definition essence_list (l : term_list) (d : preDTA) 
  (pl : prec_list) : nat :=
  match l, pl with
  | tnil, _ => 1
  | _, prec_empty => 1
  | _, prec_cons a la ls =>
      taille_0 pl + S (term_high_0 l) * S (DTA_taille d)
  end.

Lemma conservation_0_0 : forall n n0 : nat, S n * S n0 = S (n0 + n * S n0).

Lemma conservation_0 :
 forall (d : preDTA) (p : prec_list) (c : ad) (l : term_list),
 prec_in_dta d p -> S (essence_list l d p) <= essence (app c l) d.

Lemma conservation_1 :
 forall (d : preDTA) (l : term_list), 1 <= essence_list l d prec_empty.

Lemma conservation_2 :
 forall (d : preDTA) (p : prec_list), 1 <= essence_list tnil d p.

Lemma conservation_3 :
 forall (d : preDTA) (hd : term) (tl : term_list) (a : ad)
   (la ls : prec_list),
 S (essence_list (tcons hd tl) d ls) <=
 essence_list (tcons hd tl) d (prec_cons a la ls).

Lemma conservation_4 :
 forall (d : preDTA) (hd : term) (tl : term_list) (a : ad)
   (la ls : prec_list),
 S (essence_list tl d la) <= essence_list (tcons hd tl) d (prec_cons a la ls).

Lemma conservation_5_0 :
 forall (a : ad) (la ls : prec_list), 1 <= taille_0 (prec_cons a la ls).

Lemma conservation_5 :
 forall (d : preDTA) (hd : term) (tl : term_list) (a : ad)
   (la ls : prec_list),
 S (essence hd d) <= essence_list (tcons hd tl) d (prec_cons a la ls).

Definition dta_rec_term (d : DTA) (t : term) : bool :=
  match d with
  | dta p a => rec_term p a t (essence t p)
  end.

Inductive reconnaissance : preDTA -> ad -> term -> Prop :=
    rec_dta :
      forall (d : preDTA) (a : ad) (t : term) (ladj : state),
      MapGet state d a = Some ladj ->
      state_reconnait d ladj t -> reconnaissance d a t
with state_reconnait : preDTA -> state -> term -> Prop :=
    rec_st :
      forall (d : preDTA) (s : state) (c : ad) (tl : term_list)
        (l : prec_list),
      MapGet prec_list s c = Some l ->
      liste_reconnait d l tl -> state_reconnait d s (app c tl)
with liste_reconnait : preDTA -> prec_list -> term_list -> Prop :=
  | rec_empty : forall d : preDTA, liste_reconnait d prec_empty tnil
  | rec_consi :
      forall (d : preDTA) (a : ad) (la ls : prec_list) 
        (hd : term) (tl : term_list),
      reconnaissance d a hd ->
      liste_reconnait d la tl ->
      liste_reconnait d (prec_cons a la ls) (tcons hd tl)
  | rec_consn :
      forall (d : preDTA) (a : ad) (la ls : prec_list) 
        (hd : term) (tl : term_list),
      liste_reconnait d ls (tcons hd tl) ->
      liste_reconnait d (prec_cons a la ls) (tcons hd tl).

Definition reconnait (d : DTA) (t : term) : Prop :=
  match d with
  | dta p a => reconnaissance p a t
  end.

Scheme mreconnaissance_ind := Induction for reconnaissance
  Sort Prop
  with mstrec_ind := Induction for state_reconnait 
  Sort Prop
  with mlrec_ind := Induction for liste_reconnait Sort Prop.

Lemma sem_listes_0 :
 forall (d : preDTA) (p : prec_list) (hd : term) (tl : term_list),
 liste_reconnait d p (tcons hd tl) -> p <> prec_empty.

Lemma sem_listes_1 :
 forall (d : preDTA) (hd : term) (tl : term_list),
 ~ liste_reconnait d prec_empty (tcons hd tl).

Lemma sem_listes_2 :
 forall (d : preDTA) (pl : prec_list),
 liste_reconnait d pl tnil -> pl = prec_empty.

Definition sem_equiv_prop_t (t : term) :=
  forall (d : preDTA) (a : ad) (n : nat),
  rec_term d a t n = true -> reconnaissance d a t.
Definition sem_equiv_prop_l (l : term_list) :=
  forall (d : preDTA) (p : prec_list) (n : nat),
  rec_list_terms d p l n = true -> liste_reconnait d p l.

Lemma semantic_equiv_0_0 :
 forall (d : preDTA) (p : prec_list) (n : nat),
 rec_list_terms d p tnil n = true -> p = prec_empty.

Lemma semantic_equiv_0_1 : sem_equiv_prop_l tnil.

Lemma semantic_equiv_0_2 :
 forall (d : preDTA) (a a' : ad) (l : term_list) (n : nat) 
   (s : state) (p : prec_list),
 rec_term d a (app a' l) (S n) = true ->
 MapGet state d a = Some s ->
 MapGet prec_list s a' = Some p -> rec_list_terms d p l n = true.

Lemma semantic_equiv_0_3 :
 forall (d : preDTA) (a a' : ad) (l : term_list) (n : nat),
 rec_term d a (app a' l) (S n) = true ->
 exists s : state, MapGet state d a = Some s.

Lemma semantic_equiv_0_4 :
 forall (d : preDTA) (a a' : ad) (l : term_list) (n : nat) (s : state),
 MapGet state d a = Some s ->
 rec_term d a (app a' l) (S n) = true ->
 exists p : prec_list, MapGet prec_list s a' = Some p.

Lemma semantic_equiv_0_5 :
 forall (a : ad) (t : term_list),
 sem_equiv_prop_l t -> sem_equiv_prop_t (app a t).

Lemma semantic_equiv_0_6 :
 forall (n : nat) (t : term) (t0 : term_list),
 (forall (d : preDTA) (a : ad) (m : nat),
  rec_term d a t m = true -> reconnaissance d a t) ->
 (forall (d : preDTA) (p : prec_list) (m : nat),
  rec_list_terms d p t0 m = true -> liste_reconnait d p t0) ->
 forall (d : preDTA) (p : prec_list),
 rec_list_terms d p (tcons t t0) n = true -> liste_reconnait d p (tcons t t0).

Lemma semantic_equiv_0_7 :
 forall t : term,
 sem_equiv_prop_t t ->
 forall t0 : term_list, sem_equiv_prop_l t0 -> sem_equiv_prop_l (tcons t t0).

Lemma semantic_equiv_0 :
 forall (d : preDTA) (a : ad) (t : term) (n : nat),
 rec_term d a t n = true -> reconnaissance d a t.

Definition invar_term (t : term) : Prop :=
  forall (n m : nat) (d : preDTA) (a : ad),
  rec_term d a t n = true -> n <= m -> rec_term d a t m = true.

Definition invar_list (tl : term_list) : Prop :=
  forall (n m : nat) (d : preDTA) (p : prec_list),
  rec_list_terms d p tl n = true -> n <= m -> rec_list_terms d p tl m = true.

Lemma invar_0 : invar_list tnil.

Lemma invar_1_0 :
 forall (d : preDTA) (a c : ad) (t : term_list) (n : nat) 
   (s : state) (p : prec_list),
 MapGet state d a = Some s ->
 MapGet prec_list s c = Some p ->
 rec_list_terms d p t n = true -> rec_term d a (app c t) (S n) = true.

Lemma invar_1_1 :
 forall (d : preDTA) (a c : ad) (t : term_list) (n : nat),
 rec_term d a (app c t) (S n) = true ->
 exists p : prec_list, rec_list_terms d p t n = true.

Lemma invar_1 :
 forall (a : ad) (t : term_list), invar_list t -> invar_term (app a t).

Lemma invar_2_0 :
 forall (d : preDTA) (p : prec_list) (n : nat),
 rec_list_terms d p tnil n = true -> p = prec_empty.

Lemma invar_2_1 :
 forall (d : preDTA) (a : ad) (la ls : prec_list) (hd : term)
   (tl : term_list) (n : nat),
 rec_list_terms d (prec_cons a la ls) (tcons hd tl) (S n) = true ->
 rec_list_terms d ls (tcons hd tl) n = true \/
 rec_term d a hd n = true /\ rec_list_terms d la tl n = true.

Lemma invar_2_2 :
 forall (d : preDTA) (a : ad) (la ls : prec_list) (hd : term)
   (tl : term_list) (n : nat),
 rec_list_terms d ls (tcons hd tl) n = true \/
 rec_term d a hd n = true /\ rec_list_terms d la tl n = true ->
 rec_list_terms d (prec_cons a la ls) (tcons hd tl) (S n) = true.
 
Lemma invar_2 :
 forall t : term,
 invar_term t ->
 forall t0 : term_list, invar_list t0 -> invar_list (tcons t t0).

Lemma invar : forall t : term, invar_term t.

Lemma invarl : forall tl : term_list, invar_list tl.

Definition dta_reconnait (d : preDTA) (a : ad) (t : term)
  (pr : reconnaissance d a t) := rec_term d a t (essence t d) = true.

Definition st_reconnait (d : preDTA) (s : state) (t : term)
  (pr : state_reconnait d s t) :=
  match t with
  | app c l =>
      exists p : prec_list,
        MapGet prec_list s c = Some p /\
        rec_list_terms d p l (essence_list l d p) = true
  end.

Definition pre_reconnait (d : preDTA) (p : prec_list) 
  (t : term_list) (pr : liste_reconnait d p t) :=
  rec_list_terms d p t (essence_list t d p) = true.

Lemma semantic_equiv_1_0 :
 forall (d : preDTA) (a : ad) (t : term) (ladj : state)
   (e : MapGet state d a = Some ladj) (s : state_reconnait d ladj t),
 st_reconnait d ladj t s -> dta_reconnait d a t (rec_dta d a t ladj e s).

Lemma semantic_equiv_1_1 :
 forall (d : preDTA) (s : state) (c : ad) (tl : term_list) 
   (l : prec_list) (e : MapGet prec_list s c = Some l)
   (l0 : liste_reconnait d l tl),
 pre_reconnait d l tl l0 ->
 st_reconnait d s (app c tl) (rec_st d s c tl l e l0).

Lemma semantic_equiv_1_2 :
 forall d : preDTA, pre_reconnait d prec_empty tnil (rec_empty d).

Lemma semantic_equiv_1_3 :
 forall (d : preDTA) (a : ad) (la ls : prec_list) (hd : term)
   (tl : term_list) (r : reconnaissance d a hd),
 dta_reconnait d a hd r ->
 forall l : liste_reconnait d la tl,
 pre_reconnait d la tl l ->
 pre_reconnait d (prec_cons a la ls) (tcons hd tl)
   (rec_consi d a la ls hd tl r l).

Lemma semantic_equiv_1_4_0 :
 forall (d : preDTA) (a : ad) (la ls : prec_list) (l : term_list) (n : nat),
 l <> tnil ->
 rec_list_terms d ls l n = true ->
 rec_list_terms d (prec_cons a la ls) l (S n) = true.

Lemma semantic_equiv_1_4 :
 forall (d : preDTA) (a : ad) (la ls : prec_list) (hd : term)
   (tl : term_list) (l : liste_reconnait d ls (tcons hd tl)),
 pre_reconnait d ls (tcons hd tl) l ->
 pre_reconnait d (prec_cons a la ls) (tcons hd tl)
   (rec_consn d a la ls hd tl l).

Lemma semantic_equiv_1 :
 forall (d : preDTA) (a : ad) (t : term),
 reconnaissance d a t -> rec_term d a t (essence t d) = true. *)
Require Import pl_path.
(* pl_path:
Require Import Arith.
From IntMap Require Import Allmaps.
Require Import bases.
Require Import defs.
Require Import semantics.
Require Import signature.

Inductive pl_path : Set :=
  | pl_path_nil : pl_path
  | pl_path_cons : ad -> pl_path -> pl_path.

Inductive pl_path_incl : pl_path -> prec_list -> Prop :=
  | pl_path_incl_nil : pl_path_incl pl_path_nil prec_empty
  | pl_path_incl_cons :
      forall (plp : pl_path) (a : ad) (la ls : prec_list),
      pl_path_incl plp la ->
      pl_path_incl (pl_path_cons a plp) (prec_cons a la ls)
  | pl_path_incl_next :
      forall (plp : pl_path) (a : ad) (la ls : prec_list),
      pl_path_incl plp ls ->
      plp <> pl_path_nil -> pl_path_incl plp (prec_cons a la ls).

Inductive pl_path_recon : preDTA -> term_list -> pl_path -> Prop :=
  | pl_path_rec_nil : forall d : preDTA, pl_path_recon d tnil pl_path_nil
  | pl_path_rec_cons :
      forall (d : preDTA) (a : ad) (t : term) (plp : pl_path)
        (tl : term_list),
      reconnaissance d a t ->
      pl_path_recon d tl plp ->
      pl_path_recon d (tcons t tl) (pl_path_cons a plp).

Definition pl_path_rec_equiv_0_def (d : preDTA) (pl : prec_list)
  (tl : term_list) :=
  liste_reconnait d pl tl ->
  exists plp : pl_path, pl_path_incl plp pl /\ pl_path_recon d tl plp.

Fixpoint pl_path_length (plp : pl_path) : nat :=
  match plp with
  | pl_path_nil => 0
  | pl_path_cons _ p => S (pl_path_length p)
  end.

Lemma pl_path_exists :
 forall pl : prec_list, exists p : pl_path, pl_path_incl p pl.

Lemma non_empty_pl_path_exists :
 forall pl : prec_list,
 pl <> prec_empty ->
 exists p : pl_path, pl_path_incl p pl /\ 1 <= pl_path_length p.

Lemma pl_path_rec_equiv_0_0 :
 forall d : preDTA, pl_path_rec_equiv_0_def d prec_empty tnil.

Lemma pl_path_rec_equiv_0_1 :
 forall (d : preDTA) (a : ad) (la ls : prec_list) (hd : term)
   (tl : term_list),
 reconnaissance d a hd ->
 liste_reconnait d la tl ->
 pl_path_rec_equiv_0_def d la tl ->
 pl_path_rec_equiv_0_def d (prec_cons a la ls) (tcons hd tl).

Lemma pl_path_rec_equiv_0_2 :
 forall (d : preDTA) (a : ad) (la ls : prec_list) (hd : term)
   (tl : term_list),
 liste_reconnait d ls (tcons hd tl) ->
 pl_path_rec_equiv_0_def d ls (tcons hd tl) ->
 pl_path_rec_equiv_0_def d (prec_cons a la ls) (tcons hd tl).

Lemma pl_path_rec_equiv_0_3 :
 forall (p : preDTA) (p0 : prec_list) (t : term_list),
 liste_reconnait p p0 t -> pl_path_rec_equiv_0_def p p0 t.

Lemma pl_path_rec_equiv_0 :
 forall (d : preDTA) (pl : prec_list) (tl : term_list),
 liste_reconnait d pl tl ->
 exists plp : pl_path, pl_path_incl plp pl /\ pl_path_recon d tl plp.

Definition pl_path_rec_equiv_1_def (plp : pl_path) 
  (pl : prec_list) :=
  pl_path_incl plp pl ->
  forall (d : preDTA) (tl : term_list) (n : nat),
  pl_path_recon d tl plp -> pl_tl_length pl n -> liste_reconnait d pl tl.

Lemma pl_path_rec_equiv_1_0 : pl_path_rec_equiv_1_def pl_path_nil prec_empty.

Lemma pl_path_rec_equiv_1_1 :
 forall (plp : pl_path) (a : ad) (la ls : prec_list),
 pl_path_incl plp la ->
 pl_path_rec_equiv_1_def plp la ->
 pl_path_rec_equiv_1_def (pl_path_cons a plp) (prec_cons a la ls).

Lemma pl_path_rec_equiv_1_2 :
 forall (plp : pl_path) (a : ad) (la ls : prec_list),
 pl_path_incl plp ls ->
 pl_path_rec_equiv_1_def plp ls ->
 plp <> pl_path_nil -> pl_path_rec_equiv_1_def plp (prec_cons a la ls).

Lemma pl_path_rec_equiv_1_3 :
 forall (p : pl_path) (p0 : prec_list),
 pl_path_incl p p0 -> pl_path_rec_equiv_1_def p p0.

Lemma pl_path_rec_equiv_1 :
 forall (plp : pl_path) (pl : prec_list),
 pl_path_incl plp pl ->
 forall (d : preDTA) (tl : term_list) (n : nat),
 pl_path_recon d tl plp -> pl_tl_length pl n -> liste_reconnait d pl tl.

Lemma pl_path_rec_length :
 forall (plp : pl_path) (tl : term_list) (d : preDTA),
 pl_path_recon d tl plp -> pl_path_length plp = lst_length tl.

Definition liste_rec_length_def (d : preDTA) (pl : prec_list)
  (tl : term_list) : Prop :=
  forall n : nat,
  liste_reconnait d pl tl -> pl_tl_length pl n -> n = lst_length tl.

Lemma liste_rec_length_0 :
 forall d : preDTA, liste_rec_length_def d prec_empty tnil.

Lemma liste_rec_length_1 :
 forall (d : preDTA) (a : ad) (la ls : prec_list) (hd : term)
   (tl : term_list),
 reconnaissance d a hd ->
 liste_reconnait d la tl ->
 liste_rec_length_def d la tl ->
 liste_rec_length_def d (prec_cons a la ls) (tcons hd tl).

Lemma liste_rec_length_2 :
 forall (d : preDTA) (a : ad) (la ls : prec_list) (hd : term)
   (tl : term_list),
 liste_reconnait d ls (tcons hd tl) ->
 liste_rec_length_def d ls (tcons hd tl) ->
 liste_rec_length_def d (prec_cons a la ls) (tcons hd tl).

Lemma liste_rec_length_3 :
 forall (p : preDTA) (p0 : prec_list) (t : term_list),
 liste_reconnait p p0 t -> liste_rec_length_def p p0 t.

Lemma liste_rec_length :
 forall (pl : prec_list) (tl : term_list) (d : preDTA) (n : nat),
 liste_reconnait d pl tl -> pl_tl_length pl n -> n = lst_length tl.

Definition pl_path_incl_length_def (plp : pl_path) 
  (pl : prec_list) : Prop :=
  forall n : nat,
  pl_path_incl plp pl -> pl_tl_length pl n -> pl_path_length plp = n.

Lemma pl_path_incl_length_0 : pl_path_incl_length_def pl_path_nil prec_empty.

Lemma pl_path_incl_length_1 :
 forall (plp : pl_path) (a : ad) (la ls : prec_list),
 pl_path_incl plp la ->
 pl_path_incl_length_def plp la ->
 pl_path_incl_length_def (pl_path_cons a plp) (prec_cons a la ls).

Lemma pl_path_incl_length_2 :
 forall (plp : pl_path) (a : ad) (la ls : prec_list),
 pl_path_incl plp ls ->
 pl_path_incl_length_def plp ls ->
 plp <> pl_path_nil -> pl_path_incl_length_def plp (prec_cons a la ls).

Lemma pl_path_incl_length_3 :
 forall (p : pl_path) (p0 : prec_list),
 pl_path_incl p p0 -> pl_path_incl_length_def p p0.

Lemma pl_path_incl_length :
 forall (plp : pl_path) (pl : prec_list) (n : nat),
 pl_path_incl plp pl -> pl_tl_length pl n -> pl_path_length plp = n.

Lemma forall_incl_length :
 forall (pl : prec_list) (n : nat),
 (forall p : pl_path, pl_path_incl p pl -> pl_path_length p = n) ->
 pl_tl_length pl n. *)

Fixpoint pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool :=
  match p with
  | prec_empty => true
  | prec_cons a la ls =>
      match ls with
      | prec_empty =>
          match MapGet bool m a with
          | Some b => b && pl_non_empty m la
          | None => false
          end
      | prec_cons _ _ _ =>
          match MapGet bool m a with
          | Some b => pl_non_empty m ls || b && pl_non_empty m la
          | None => pl_non_empty m ls
          end
      end
  end.

Fixpoint st_non_empty (m : Map bool) (s : state) {struct s} : bool :=
  match s with
  | M0 => false
  | M1 _ p => pl_non_empty m p
  | M2 a b => st_non_empty m a || st_non_empty m b
  end.

Fixpoint dta_app_ne_aux (d : preDTA) (m r : Map bool) {struct r} :
 Map bool :=
  match d, r with
  | M0, _ => M0 bool
  | M1 a s, M0 => M0 bool
  | M1 a s, M1 a' b =>
      if Neqb a a' then M1 bool a (b || st_non_empty m s) else M0 bool
  | M1 a s, M2 _ _ => M0 bool
  | M2 d0 d1, M0 => M0 bool
  | M2 d0 d1, M1 _ _ => M0 bool
  | M2 d0 d1, M2 r0 r1 =>
      M2 bool (dta_app_ne_aux d0 m r0) (dta_app_ne_aux d1 m r1)
  end.

Definition dta_app_ne (d : preDTA) (m : Map bool) : 
  Map bool := dta_app_ne_aux d m m.

Definition dta_non_empty_states (d : preDTA) : Map bool :=
  power (Map bool) (dta_app_ne d) (map_mini state d) (S (MapCard state d)).

Definition dta_states_non_empty (d : DTA) : Map bool :=
  match d with
  | dta p a => dta_non_empty_states p
  end.

Definition dta_non_empty_states_lazy (d : preDTA) : 
  Map bool :=
  lazy_power bool eqm_bool (dta_app_ne d) (map_mini state d)
    (S (MapCard state d)).

Definition dta_states_non_empty_lazy (d : DTA) : Map bool :=
  match d with
  | dta p a => dta_non_empty_states_lazy p
  end.

Lemma dta_states_non_empty_lazy_eg_dta_states_non_empty :
 forall d : DTA, dta_states_non_empty_lazy d = dta_states_non_empty d.
Proof.
	simple induction d. simpl in |- *. intros. unfold dta_non_empty_states_lazy, dta_non_empty_states in |- *. apply
  (lazy_power_eg_power bool eqm_bool (dta_app_ne p) 
     (map_mini state p) (S (MapCard state p))).
	split. exact (eqm_bool_equal a0 b). intros. rewrite H.
	exact (equal_eqm_bool b).
Qed.

Lemma dta_app_ne_aux_def_ok :
 forall (d : preDTA) (m : Map bool),
 def_ok_app bool (ensemble_base state d) (dta_app_ne_aux d m).
Proof.
	simple induction d. intros. unfold def_ok_app in |- *. intros. induction  x as [| a a0| x1 Hrecx1 x0 Hrecx0].
	simpl in |- *. unfold ensemble_base in |- *. exact I. unfold ensemble_base in |- *. simpl in |- *.
	exact I. simpl in |- *. unfold ensemble_base in |- *. simpl in |- *. exact I. intros.
	unfold def_ok_app in |- *. intros. unfold ensemble_base in |- *. unfold ensemble_base in H. induction  x as [| a1 a2| x1 Hrecx1 x0 Hrecx0]. simpl in H. inversion H. simpl in H. simpl in |- *. rewrite H.
	rewrite (Neqb_correct a1). simpl in |- *. reflexivity. simpl in H. inversion H.
	intros. unfold def_ok_app in |- *. unfold ensemble_base in |- *. intros. induction  x as [| a a0| x1 Hrecx1 x0 Hrecx0].
	simpl in H1. inversion H1. simpl in H1. inversion H1. simpl in |- *. split.
	unfold def_ok_app in H. unfold ensemble_base in H. simpl in H1.
	elim H1. intros. exact (H m1 x1 H2). unfold def_ok_app in H0.
	unfold ensemble_base in H0. elim H1. intros. exact (H0 m1 x0 H3).
Qed.

Lemma dta_app_ne_def_ok :
 forall d : preDTA, def_ok_app bool (ensemble_base state d) (dta_app_ne d).
Proof.
	intros. unfold dta_app_ne in |- *. unfold def_ok_app in |- *. intros. exact (dta_app_ne_aux_def_ok d x x H).
Qed.

Lemma dta_app_ne_inc_0 :
 forall (p : prec_list) (m0 m1 : Map bool),
 lem m0 m1 -> leb (pl_non_empty m0 p) (pl_non_empty m1 p).
Proof.
	simple induction p. intros. induction  p1 as [a0 p1_1 Hrecp1_1 p1_0 Hrecp1_0| ]. elim (option_sum bool (MapGet bool m0 a)); intro y. elim y. intros x y0. elim (option_sum bool (MapGet bool m1 a)); intro y1. elim y1. intros x0 y2. replace (pl_non_empty m0 (prec_cons a p0 (prec_cons a0 p1_1 p1_0))) with
  (pl_non_empty m0 (prec_cons a0 p1_1 p1_0) || x && pl_non_empty m0 p0). replace (pl_non_empty m1 (prec_cons a p0 (prec_cons a0 p1_1 p1_0))) with
  (pl_non_empty m1 (prec_cons a0 p1_1 p1_0) || x0 && pl_non_empty m1 p0). apply
  (leb_transitive
     (pl_non_empty m0 (prec_cons a0 p1_1 p1_0) || x && pl_non_empty m0 p0)
     (pl_non_empty m0 (prec_cons a0 p1_1 p1_0) || x0 && pl_non_empty m1 p0)
     (pl_non_empty m1 (prec_cons a0 p1_1 p1_0) || x0 && pl_non_empty m1 p0)).
	apply
  (orb_incr (pl_non_empty m0 (prec_cons a0 p1_1 p1_0))
     (pl_non_empty m0 (prec_cons a0 p1_1 p1_0)) (x && pl_non_empty m0 p0)
     (x0 && pl_non_empty m1 p0)). exact (leb_reflexive _).
	apply (andb_incr x x0 (pl_non_empty m0 p0) (pl_non_empty m1 p0)).
	exact (lem_get_leb m0 m1 a x x0 H1 y0 y2). exact (H _ _ H1).
	apply
  (orb_incr (pl_non_empty m0 (prec_cons a0 p1_1 p1_0))
     (pl_non_empty m1 (prec_cons a0 p1_1 p1_0)) (x0 && pl_non_empty m1 p0)
     (x0 && pl_non_empty m1 p0)). exact (H0 _ _ H1). exact (leb_reflexive _). simpl in |- *. rewrite y2. reflexivity. simpl in |- *. rewrite y0.
	reflexivity. elim (domain_equal_mapget bool bool m0 m1 a x). intros.
	rewrite H2 in y1. inversion y1. exact (lem_domain_equal m0 m1 H1).
	exact y0. elim (option_sum bool (MapGet bool m1 a)); intro y0. elim y0; intros x y1. elim (domain_equal_mapget bool bool m1 m0 a x); intros. rewrite H2 in y. inversion y. exact (domain_equal_symmetric bool bool _ _ (lem_domain_equal _ _ H1)). exact y1. replace (pl_non_empty m0 (prec_cons a p0 (prec_cons a0 p1_1 p1_0))) with
  (pl_non_empty m0 (prec_cons a0 p1_1 p1_0)). replace (pl_non_empty m1 (prec_cons a p0 (prec_cons a0 p1_1 p1_0))) with
  (pl_non_empty m1 (prec_cons a0 p1_1 p1_0)).
	exact (H0 _ _ H1). simpl in |- *. rewrite y0. reflexivity. simpl in |- *. rewrite y.
	reflexivity. elim (option_sum bool (MapGet bool m0 a)); intro y.
	elim (option_sum bool (MapGet bool m1 a)); intro y0. elim y; intros x y1.
	elim y0; intros x0 y2. replace (pl_non_empty m0 (prec_cons a p0 prec_empty)) with
  (x && pl_non_empty m0 p0). replace (pl_non_empty m1 (prec_cons a p0 prec_empty)) with
  (x0 && pl_non_empty m1 p0). apply
  (leb_transitive (x && pl_non_empty m0 p0) (x0 && pl_non_empty m0 p0)
     (x0 && pl_non_empty m1 p0)). apply (andb_inc_l (pl_non_empty m0 p0) x x0). exact (lem_get_leb _ _ _ _ _ H1 y1 y2). apply (andb_inc_r x0 (pl_non_empty m0 p0) (pl_non_empty m1 p0)). exact (H _ _ H1). simpl in |- *.
	rewrite y2. reflexivity. simpl in |- *. rewrite y1. reflexivity. elim y. intros x y1.
	elim (domain_equal_mapget bool bool m0 m1 a x). intros. rewrite H2 in y0.
	inversion y0. exact (lem_domain_equal _ _ H1). exact y1. elim (option_sum bool (MapGet bool m1 a)); intro y0. elim y0. intros x y1. elim (domain_equal_mapget bool bool m1 m0 a x). intros. rewrite H2 in y. inversion y.
	exact (domain_equal_symmetric bool bool _ _ (lem_domain_equal _ _ H1)).
	exact y1. simpl in |- *. rewrite y. rewrite y0. exact I. simpl in |- *. intros. exact I.
Qed.

Lemma dta_app_ne_inc_1 :
 forall (s : state) (m0 m1 : Map bool),
 lem m0 m1 -> leb (st_non_empty m0 s) (st_non_empty m1 s).
Proof.
	simple induction s. intros. simpl in |- *. exact I. intros. simpl in |- *.
	exact (dta_app_ne_inc_0 a0 m0 m1 H). intros. simpl in |- *.
	exact (orb_incr _ _ _ _ (H _ _ H1) (H0 _ _ H1)).
Qed.

Lemma dta_app_ne_inc_2 :
 forall (d : preDTA) (m0 m1 m : Map bool),
 lem m0 m1 -> lem (dta_app_ne_aux d m0 m) (dta_app_ne_aux d m1 m).
Proof.
	simple induction d. simple induction m. intros. simpl in |- *. exact I. intros.
	simpl in |- *. exact I. intros. simpl in |- *. exact I. simple induction m. intros.
	simpl in |- *. exact I. simpl in |- *. intros. elim (bool_is_true_or_false (Neqb a a1)); intros; rewrite H0. simpl in |- *. rewrite (Neqb_correct a). exact (orb_inc_r _ _ _ (dta_app_ne_inc_1 a0 m0 m1 H)).
	exact I. intros. simpl in |- *. exact I. simple induction m3. intros. simpl in |- *.
	exact I. intros. simpl in |- *. exact I. intros. simpl in |- *. split.
	exact (H _ _ _ H3). exact (H0 _ _ _ H3).
Qed.

Lemma dta_app_ne_inc_3 :
 forall (m0 m1 m : Map bool) (d : preDTA),
 lem m0 m1 -> lem (dta_app_ne_aux d m m0) (dta_app_ne_aux d m m1).
Proof.
	simple induction m0. simple induction m1; intros. induction  d as [| a a0| d1 Hrecd1 d0 Hrecd0]; simpl in |- *; exact I.
	inversion H. inversion H1. simple induction m1; intros. inversion H.
	induction  d as [| a3 a4| d1 Hrecd1 d0 Hrecd0]; simpl in |- *. exact I. simpl in H. elim (bool_is_true_or_false (Neqb a a1)); intro; rewrite H0 in H. rewrite (Neqb_complete _ _ H0).
	elim (bool_is_true_or_false (Neqb a3 a1)); intro; rewrite H1. simpl in |- *.
	rewrite (Neqb_correct a3). exact (orb_inc_l _ _ _ H). exact I. elim H.
	exact I. inversion H1. simple induction m2; intros. inversion H1. inversion H1.
	elim H3; intros. induction  d as [| a a0| d1 Hrecd1 d0 Hrecd0]; simpl in |- *. exact I. exact I. split. exact (H _ _ _ H4). exact (H0 _ _ _ H5).
Qed.

Lemma dta_app_ne_inc :
 forall d : preDTA, increasing_app bool lem (dta_app_ne d).
Proof.
	intros. unfold increasing_app in |- *. unfold dta_app_ne in |- *. intros.
	exact
  (lem_transitive _ _ _ (dta_app_ne_inc_2 d x y x H)
     (dta_app_ne_inc_3 x y y d H)).
Qed.

Inductive pl_path_true : pl_path -> Map bool -> Prop :=
  | plp_true_nil : forall m : Map bool, pl_path_true pl_path_nil m
  | plp_true_cons :
      forall (m : Map bool) (a : ad) (pl : pl_path),
      pl_path_true pl m ->
      MapGet bool m a = Some true -> pl_path_true (pl_path_cons a pl) m.

Definition pl_non_empty_path_true_def_0 (pl : pl_path) 
  (p : prec_list) : Prop :=
  forall m : Map bool,
  pl_path_incl pl p -> pl_path_true pl m -> pl_non_empty m p = true.

Lemma pl_non_empty_path_true_0 :
 pl_non_empty_path_true_def_0 pl_path_nil prec_empty.
Proof.
	unfold pl_non_empty_path_true_def_0 in |- *. simpl in |- *. intros.
	reflexivity.
Qed.

Lemma pl_non_empty_path_true_1 :
 forall (plp : pl_path) (a : ad) (la ls : prec_list),
 pl_path_incl plp la ->
 pl_non_empty_path_true_def_0 plp la ->
 pl_non_empty_path_true_def_0 (pl_path_cons a plp) (prec_cons a la ls).
Proof.
	unfold pl_non_empty_path_true_def_0 in |- *. intros. inversion H2.
	simpl in |- *. rewrite H7. elim (pl_sum ls); intros. rewrite H8.
	exact (H0 m H H5). elim H8. intros. elim H9. intros. elim H10.
	intros. rewrite H11. rewrite (H0 m H H5). elim (bool_is_true_or_false (pl_non_empty m (prec_cons x x0 x1))); intro;
  rewrite H12; reflexivity.
Qed.

Lemma pl_non_empty_path_true_2 :
 forall (plp : pl_path) (a : ad) (la ls : prec_list),
 pl_path_incl plp ls ->
 pl_non_empty_path_true_def_0 plp ls ->
 plp <> pl_path_nil -> pl_non_empty_path_true_def_0 plp (prec_cons a la ls).
Proof.
	unfold pl_non_empty_path_true_def_0 in |- *. intros. induction  plp as [| a0 plp Hrecplp].
	elim (H1 (refl_equal _)). inversion H3. simpl in |- *. elim (pl_sum ls); intros. rewrite H9 in H. inversion H. elim H9.
	intros. elim H10. intros. elim H11. intros. rewrite H12.
	rewrite <- H12. rewrite (H0 m H H3). elim (option_sum bool (MapGet bool m a)); intro y. elim y. intros x2 y0. rewrite y0.
	elim (bool_is_true_or_false (x2 && pl_non_empty m la)); intro; rewrite H13;
  reflexivity. rewrite y. reflexivity.
Qed.

Lemma pl_non_empty_path_true :
 forall (pl : pl_path) (p : prec_list) (m : Map bool),
 pl_path_incl pl p -> pl_path_true pl m -> pl_non_empty m p = true.
Proof.
	intros. exact
  (pl_path_incl_ind pl_non_empty_path_true_def_0 pl_non_empty_path_true_0
     pl_non_empty_path_true_1 pl_non_empty_path_true_2 pl p H m H H0).
Qed.

Lemma pl_non_empty_path_true_rev :
 forall (p : prec_list) (m : Map bool),
 pl_non_empty m p = true ->
 exists plp : pl_path, pl_path_incl plp p /\ pl_path_true plp m.
Proof.
	simple induction p. intros. simpl in H1. elim (pl_sum p1); intros.
	rewrite H2 in H1. elim (option_sum bool (MapGet bool m a)); intro y. elim y. intros x y0. rewrite y0 in H1. elim (bool_is_true_or_false x); intro; rewrite H3 in H1. elim (bool_is_true_or_false (pl_non_empty m p0)); intros. elim (H m H4). intros. elim H5. intros. split with (pl_path_cons a x0). split. exact (pl_path_incl_cons x0 a p0 p1 H6).
	rewrite H3 in y0. exact (plp_true_cons m a x0 H7 y0).
	rewrite H4 in H1. inversion H1. elim (bool_is_true_or_false (pl_non_empty m p0)); intro; rewrite H4 in H1;
  inversion H1.
	rewrite y in H1. inversion H1. elim H2. intros. elim H3. intros.
	elim H4. intros. rewrite H5 in H1. rewrite <- H5 in H1. elim (option_sum bool (MapGet bool m a)); intro y. elim y. intros x2 y0.
	rewrite y0 in H1. elim (bool_is_true_or_false (pl_non_empty m p1)); intros. elim (H0 m H6); intros. split with x3. split.
	elim H7. intros. apply (pl_path_incl_next x3 a p0 p1 H8). intro.
	rewrite H10 in H8. rewrite H5 in H8. inversion H8. exact (H16 (refl_equal _)). elim H7; intros. assumption.
	rewrite H6 in H1. elim (bool_is_true_or_false (x2 && pl_non_empty m p0)); intros;
  rewrite H7 in H1. elim (bool_is_true_or_false x2); intros; rewrite H8 in H7. rewrite H8 in y0. elim (bool_is_true_or_false (pl_non_empty m p0)); intros.
	elim (H m H9); intros. split with (pl_path_cons a x3). split.
	elim H10. intros. exact (pl_path_incl_cons x3 a p0 p1 H11).
	elim H10. intros. exact (plp_true_cons m a x3 H12 y0). rewrite H9 in H7. inversion H7. elim (bool_is_true_or_false (pl_non_empty m p0)); intros; rewrite H9 in H7;
  inversion H7. inversion H1.
	rewrite y in H1. elim (H0 _ H1). intros. split with x2. split.
	apply (pl_path_incl_next x2 a p0 p1). elim H6. intros. assumption.
	intro. rewrite H7 in H6. elim H6. intros. inversion H8. rewrite <- H11 in H5. inversion H5. exact (H11 (refl_equal _)).
	elim H6; intros. assumption. intros. split with pl_path_nil.
	split. exact pl_path_incl_nil. exact (plp_true_nil m).
Qed.

Lemma st_non_empty_0 :
 forall (m : Map bool) (s : state) (p : prec_list) (a : ad),
 MapGet prec_list s a = Some p ->
 pl_non_empty m p = true -> st_non_empty m s = true.
Proof.
	simple induction s; intros. inversion H. simpl in |- *. simpl in H. elim (bool_is_true_or_false (Neqb a a1)); intro; rewrite H1 in H;
  inversion H. exact H0. simpl in |- *. induction  a as [| p0]. simpl in H1. rewrite (H p N0 H1 H2). simpl in |- *. reflexivity. induction  p0 as [p0 Hrecp0| p0 Hrecp0| ]; simpl in H1.
	rewrite (H0 _ _ H1 H2). elim (bool_is_true_or_false (st_non_empty m m0)); intro; rewrite H3;
  reflexivity. rewrite (H _ _ H1 H2).
	reflexivity. rewrite (H0 _ _ H1 H2). elim (bool_is_true_or_false (st_non_empty m m0)); intro; rewrite H3;
  reflexivity.
Qed.

Lemma st_non_empty_1 :
 forall (d : preDTA) (m r : Map bool) (a : ad) (l : state),
 MapGet state d a = Some l ->
 domain_equal state bool d r ->
 st_non_empty m l = true ->
 MapGet bool (dta_app_ne_aux d m r) a = Some true.
Proof.
	simple induction d. intros. inversion H. intros. induction  r as [| a2 a3| r1 Hrecr1 r0 Hrecr0]. 
	inversion H0. simpl in |- *. simpl in H0. simpl in H. rewrite H0.
	rewrite (Neqb_correct a2). simpl in |- *. rewrite H0 in H. elim (bool_is_true_or_false (Neqb a2 a1)); intro; rewrite H2 in H.
	inversion H. rewrite H2. rewrite H1. elim (bool_is_true_or_false a3); intros; rewrite H3; reflexivity. inversion H. inversion H0.
	intros. induction  r as [| a0 a1| r1 Hrecr1 r0 Hrecr0]. inversion H2. inversion H2. elim H2; intros.
	induction  a as [| p]. simpl in |- *. simpl in H1. apply (H m1 r1 N0 l H1 H4).
	exact H3. induction  p as [p Hrecp| p Hrecp| ]; simpl in |- *; simpl in H1. elim H2. intros.
	exact (H0 _ _ _ _ H1 H7 H3). exact (H _ _ _ _ H1 H4 H3).
	exact (H0 _ _ _ _ H1 H5 H3).
Qed.

Definition dt_non_empty_def_0 (d : preDTA) (a : ad) 
  (t : term) (pr : reconnaissance d a t) :=
  forall n : nat,
  term_high t <= n ->
  MapGet bool (power (Map bool) (dta_app_ne d) (map_mini state d) n) a =
  Some true.

Definition dt_non_empty_def_1 (d : preDTA) (s : state) 
  (t : term) (pr : state_reconnait d s t) :=
  forall n : nat,
  term_high t <= S n ->
  st_non_empty (power (Map bool) (dta_app_ne d) (map_mini state d) n) s =
  true.

Definition dt_non_empty_def_2 (d : preDTA) (p : prec_list) 
  (t : term_list) (pr : liste_reconnait d p t) :=
  forall n : nat,
  term_high_0 t <= n ->
  pl_non_empty (power (Map bool) (dta_app_ne d) (map_mini state d) n) p =
  true.

Lemma dt_non_empty_0 :
 forall (d : preDTA) (a : ad) (t : term) (ladj : state)
   (e : MapGet state d a = Some ladj) (s : state_reconnait d ladj t),
 dt_non_empty_def_1 d ladj t s ->
 dt_non_empty_def_0 d a t (rec_dta d a t ladj e s).
Proof.
	unfold dt_non_empty_def_1, dt_non_empty_def_0 in |- *. intros. elim (nat_sum n); intros. rewrite H1 in H0. induction  t as (a0, t). simpl in H0.
	elim (le_Sn_O _ H0). elim H1. intros. rewrite H2. simpl in |- *. rewrite H2 in H0. replace
  (dta_app_ne d (power (Map bool) (dta_app_ne d) (map_mini state d) x)) with
  (dta_app_ne_aux d (power (Map bool) (dta_app_ne d) (map_mini state d) x)
     (power (Map bool) (dta_app_ne d) (map_mini state d) x)). apply
  (st_non_empty_1 d (power (Map bool) (dta_app_ne d) (map_mini state d) x)
     (power (Map bool) (dta_app_ne d) (map_mini state d) x) a ladj e). exact
  (power_def_ok bool (ensemble_base state d) (dta_app_ne d)
     (map_mini state d) x (dta_app_ne_def_ok d) (map_mini_appartient state d)). exact (H x H0). reflexivity.
Qed.

Lemma dt_non_empty_1 :
 forall (d : preDTA) (s : state) (c : ad) (tl : term_list) 
   (l : prec_list) (e : MapGet prec_list s c = Some l)
   (l0 : liste_reconnait d l tl),
 dt_non_empty_def_2 d l tl l0 ->
 dt_non_empty_def_1 d s (app c tl) (rec_st d s c tl l e l0).
Proof.
	unfold dt_non_empty_def_1 in |- *. unfold dt_non_empty_def_2 in |- *. intros.
	simpl in H0. fold term_high_0 in H0. apply
  (st_non_empty_0 (power (Map bool) (dta_app_ne d) (map_mini state d) n) s l
     c e).
	exact (H n (le_S_n _ _ H0)).
Qed.

Lemma dt_non_empty_2 :
 forall d : preDTA, dt_non_empty_def_2 d prec_empty tnil (rec_empty d).
Proof.
	unfold dt_non_empty_def_2 in |- *. intros. simpl in |- *. reflexivity.
Qed.

Lemma dt_non_empty_3 :
 forall (d : preDTA) (a : ad) (la ls : prec_list) (hd : term)
   (tl : term_list) (r : reconnaissance d a hd),
 dt_non_empty_def_0 d a hd r ->
 forall l : liste_reconnait d la tl,
 dt_non_empty_def_2 d la tl l ->
 dt_non_empty_def_2 d (prec_cons a la ls) (tcons hd tl)
   (rec_consi d a la ls hd tl r l).
Proof.
	unfold dt_non_empty_def_0, dt_non_empty_def_2 in |- *. intros. simpl in H1.
	fold term_high in H1. elim
  (pl_non_empty_path_true_rev la
     (power (Map bool) (dta_app_ne d) (map_mini state d) n)
     (H0 n (le_trans (term_high_0 tl) _ _ (le_max_r _ _) H1))). intros. elim H2. intros.
	apply
  (pl_non_empty_path_true (pl_path_cons a x) (prec_cons a la ls)
     (power (Map bool) (dta_app_ne d) (map_mini state d) n)). exact (pl_path_incl_cons x a la ls H3). apply
  (plp_true_cons (power (Map bool) (dta_app_ne d) (map_mini state d) n) a x). exact H4. exact (H _ (le_trans _ _ _ (le_max_l _ _) H1)).
Qed.

Lemma dt_non_empty_4 :
 forall (d : preDTA) (a : ad) (la ls : prec_list) (hd : term)
   (tl : term_list) (l : liste_reconnait d ls (tcons hd tl)),
 dt_non_empty_def_2 d ls (tcons hd tl) l ->
 dt_non_empty_def_2 d (prec_cons a la ls) (tcons hd tl)
   (rec_consn d a la ls hd tl l).
Proof.
	unfold dt_non_empty_def_2 in |- *. intros. elim (pl_non_empty_path_true_rev _ _ (H n H0)). intros. elim H1. intros. apply
  (pl_non_empty_path_true x (prec_cons a la ls)
     (power (Map bool) (dta_app_ne d) (map_mini state d) n)). apply (pl_path_incl_next x a la ls H2). intro. rewrite H4 in H3.
	rewrite H4 in H2. inversion H2. rewrite <- H6 in l. inversion l.
	elim (H6 (refl_equal _)). exact H3.
Qed.

Lemma dt_non_empty_5 :
 forall (d : preDTA) (a : ad) (t : term),
 reconnaissance d a t ->
 forall n : nat,
 term_high t <= n ->
 MapGet bool (power (Map bool) (dta_app_ne d) (map_mini state d) n) a =
 Some true.
Proof.
	exact
  (mreconnaissance_ind dt_non_empty_def_0 dt_non_empty_def_1
     dt_non_empty_def_2 dt_non_empty_0 dt_non_empty_1 dt_non_empty_2
     dt_non_empty_3 dt_non_empty_4).
Qed.

Lemma dt_non_empty_6 :
 forall (p : preDTA) (p0 : prec_list) (t : term_list)
   (l : liste_reconnait p p0 t), dt_non_empty_def_2 p p0 t l.
Proof.
	exact
  (mlrec_ind dt_non_empty_def_0 dt_non_empty_def_1 dt_non_empty_def_2
     dt_non_empty_0 dt_non_empty_1 dt_non_empty_2 dt_non_empty_3
     dt_non_empty_4).
Qed.

Lemma dt_non_empty_d :
 forall (d : preDTA) (a : ad) (t : term),
 reconnaissance d a t ->
 exists n : nat,
   MapGet bool (power (Map bool) (dta_app_ne d) (map_mini state d) n) a =
   Some true.
Proof.
	intros. split with (term_high t). exact (dt_non_empty_5 d a t H (term_high t) (le_n_n _)).
Qed.

Lemma dt_non_empty_7 :
 forall (d : preDTA) (p : prec_list) (t : term_list),
 liste_reconnait d p t ->
 pl_non_empty
   (power (Map bool) (dta_app_ne d) (map_mini state d) (term_high_0 t)) p =
 true.
Proof.
	intros. exact (dt_non_empty_6 d p t H (term_high_0 t) (le_n_n _)).
Qed.

Lemma dt_non_empty_r_0 :
 forall (d : preDTA) (m r : Map bool) (a : ad) (l : state),
 MapGet state d a = Some l ->
 domain_equal state bool d r ->
 MapGet bool (dta_app_ne_aux d m r) a = Some true ->
 MapGet bool r a = Some true \/ st_non_empty m l = true.
Proof.
	simple induction d. intros. inversion H. intros. induction  r as [| a2 a3| r1 Hrecr1 r0 Hrecr0].
	inversion H0. simpl in H0. rewrite H0 in H. rewrite H0 in H1.
	simpl in H. elim (bool_is_true_or_false (Neqb a2 a1)); intro; rewrite H2 in H. inversion H. simpl in H1. rewrite (Neqb_correct a2) in H1. simpl in H1. rewrite H2 in H1. inversion H1. rewrite H5.
	simpl in |- *. rewrite H2. elim (bool_is_true_or_false a3); intros; rewrite H3. left. reflexivity. rewrite H3 in H5. simpl in H5.
	rewrite H4 in H5. right. exact H5. inversion H. inversion H0.
	intros. induction  r as [| a0 a1| r1 Hrecr1 r0 Hrecr0]. inversion H2. inversion H2. induction  a as [| p].
	simpl in H1. simpl in |- *. simpl in H3. simpl in H2. elim H2. intros.
	exact (H _ _ _ _ H1 H4 H3). elim H2. intros. induction  p as [p Hrecp| p Hrecp| ]; simpl in |- *; simpl in H1;
  simpl in H3. exact (H0 _ _ _ _ H1 H5 H3). exact (H _ _ _ _ H1 H4 H3). exact (H0 _ _ _ _ H1 H5 H3).
Qed.

Lemma dt_non_empty_r_1 :
 forall (s : state) (m : Map bool),
 st_non_empty m s = true ->
 exists c : ad,
   (exists p : prec_list,
      MapGet prec_list s c = Some p /\ pl_non_empty m p = true).
Proof.
	simple induction s; intros. simpl in H. inversion H. simpl in H.
	split with a. split with a0. split. simpl in |- *. rewrite (Neqb_correct a). reflexivity. exact H. simpl in H1.
	elim (bool_is_true_or_false (st_non_empty m1 m)); intros.
	elim (H m1 H2). intros. elim H3. intros. elim H4. intros.
	induction  x as [| p]. split with N0. split with x0. simpl in |- *. split; assumption. split with (Npos (xO p)). split with x0. simpl in |- *.
	split; assumption. rewrite H2 in H1. simpl in H1. elim (H0 _ H1). intros. elim H3. intros. elim H4. intros. induction  x as [| p].
	split with (Npos 1). simpl in |- *. split with x0. split; assumption.
	split with (Npos (xI p)). split with x0. simpl in |- *. split; assumption.
Qed.

Lemma dt_non_empty_r_2 :
 forall (p : prec_list) (m : Map bool),
 pl_non_empty m p = true ->
 exists pl : pl_path, pl_path_true pl m /\ pl_path_incl pl p.
Proof.
	simple induction p. intros. simpl in H1. elim (pl_sum p1). intros.
	rewrite H2 in H1. elim (option_sum bool (MapGet bool m a)).
	intro y. elim y. intros x y0. rewrite y0 in H1. elim (bool_is_true_or_false x); intros; rewrite H3 in H1; simpl in H1.
	elim (H m H1). intros. elim H4. intros. rewrite H3 in y0.
	split with (pl_path_cons a x0). split. exact (plp_true_cons m a x0 H5 y0). exact (pl_path_incl_cons x0 a p0 p1 H6). inversion H1. intro y. rewrite y in H1. inversion H1. intros. elim H2.
	intros. elim H3. intros. elim H4. intros. rewrite H5 in H1.
	elim (option_sum bool (MapGet bool m a)); intro y. elim y. intros x2 y0.
	rewrite y0 in H1. rewrite <- H5 in H1. elim (bool_is_true_or_false (pl_non_empty m p1)); intros. elim (H0 _ H6). intros. elim H7.
	intros. split with x3. split. exact H8. apply (pl_path_incl_next x3 a p0 p1 H9). intro. rewrite H10 in H9. inversion H9. rewrite <- H12 in H5. inversion H5. elim (H12 (refl_equal _)).
	rewrite H6 in H1. simpl in H1. elim (bool_is_true_or_false x2); intro. rewrite H7 in y0. elim (bool_is_true_or_false (pl_non_empty m p0)); intro. elim (H _ H8). intros. elim H9. intros. split with (pl_path_cons a x3). split. exact (plp_true_cons _ _ _ H10 y0).
	exact (pl_path_incl_cons x3 a p0 p1 H11). rewrite H8 in H1.
	rewrite H7 in H1. inversion H1. rewrite H7 in H1. inversion H1.
	rewrite y in H1. rewrite <- H5 in H1. elim (H0 _ H1). intros.
	elim H6. intros. split with x2. split. exact H7. apply (pl_path_incl_next x2 a p0 p1 H8). intro. rewrite H9 in H8.
	inversion H8. rewrite <- H11 in H5. inversion H5. elim H11.
	reflexivity. intros. split with pl_path_nil. split. exact (plp_true_nil m). exact pl_path_incl_nil.
Qed.

Definition dt_non_empty_r_def_0 (n : nat) : Prop :=
  forall (d : preDTA) (a : ad),
  MapGet bool (power (Map bool) (dta_app_ne d) (map_mini state d) n) a =
  Some true -> exists t : term, reconnaissance d a t.

Lemma dt_non_empty_r_3 : dt_non_empty_r_def_0 0.
Proof.
	unfold dt_non_empty_r_def_0 in |- *. simpl in |- *. intros. cut (true <> false).
	intro. elim (H0 (map_mini_mapget_false state d a true H)).
	intro. inversion H0.
Qed.

Lemma dt_non_empty_r_4 :
 forall (p : prec_list) (n : nat) (d : preDTA) (pl : pl_path),
 dt_non_empty_r_def_0 n ->
 pl_path_true pl (power (Map bool) (dta_app_ne d) (map_mini state d) n) ->
 pl_path_incl pl p -> exists tl : term_list, liste_reconnait d p tl.
Proof.
	unfold dt_non_empty_r_def_0 in |- *. simple induction p. intros.
	inversion H2. inversion H3.
        rewrite <- H4 in H7. inversion H7.
        elim H11; auto.
        elim (H1 _ _ H5). intros. inversion H3. rewrite <- H10 in H6.
        inversion H6. rewrite <- H10 in H2.
        inversion H2. elim (H n d plp H1 H18 H11).
        intros. split with (tcons x x0).
        rewrite H15 in H8. rewrite H9 in H8.
        exact (rec_consi d a p0 p1 x x0 H8 H21).
        elim (H0 n d pl H1 H2 H12). intros. induction  x0 as [| t x0 Hrecx0].
        inversion H15. rewrite <- H17 in H12. inversion H12. elim H14; auto.
        split with (tcons t x0). exact (rec_consn d a p0 p1 t x0 H15).
        intros. inversion H1. split with tnil. exact (rec_empty d).
Qed.

Lemma dt_non_empty_r_5 :
 forall n : nat, dt_non_empty_r_def_0 n -> dt_non_empty_r_def_0 (S n).
Proof.
	unfold dt_non_empty_r_def_0 in |- *. intros. elim
  (domain_equal_mapget bool state
     (power (Map bool) (dta_app_ne d) (map_mini state d) (S n)) d a true). intros. unfold dta_app_ne in H0.  simpl in H0. elim
  (dt_non_empty_r_0 d
     (power (Map bool) (fun m : Map bool => dta_app_ne_aux d m m)
        (map_mini state d) n)
     (power (Map bool) (fun m : Map bool => dta_app_ne_aux d m m)
        (map_mini state d) n) a x H1); intros. exact (H d a H2). elim (dt_non_empty_r_1 _ _ H2). intros. elim H3. intros. elim H4. intros. elim (dt_non_empty_r_2 _ _ H6). intros. elim H7. intros.
	elim (dt_non_empty_r_4 x1 n d x2 H H8 H9). intros.
	split with (app x0 x3). exact (rec_dta d a (app x0 x3) x H1 (rec_st d x x0 x3 x1 H5 H10)). apply
  (power_def_ok bool (ensemble_base state d) (dta_app_ne d)
     (map_mini state d) n).
	exact (dta_app_ne_def_ok d). exact (map_mini_appartient state d). exact H0. apply
  (domain_equal_symmetric state bool d
     (power (Map bool) (dta_app_ne d) (map_mini state d) (S n))). exact
  (power_def_ok bool (ensemble_base state d) (dta_app_ne d)
     (map_mini state d) (S n) (dta_app_ne_def_ok d)
     (map_mini_appartient state d)). exact H0.
Qed.

Lemma dt_non_empty_r :
 forall (n : nat) (d : preDTA) (a : ad),
 MapGet bool (power (Map bool) (dta_app_ne d) (map_mini state d) n) a =
 Some true -> exists t : term, reconnaissance d a t.
Proof.
	exact (nat_ind dt_non_empty_r_def_0 dt_non_empty_r_3 dt_non_empty_r_5).
Qed.

Lemma dt_non_empty_fix_0 :
 forall d : preDTA,
 lower_fix_point bool (ensemble_base state d) lem (dta_app_ne d)
   (dta_non_empty_states d).
Proof.
	unfold dta_non_empty_states in |- *.
	intros. exact
  (iteres_lower_fix_point bool (ensemble_base state d) lem 
     (dta_app_ne d) (map_mini state d) (S (MapCard state d))
     (S (MapCard state d)) (map_mini_mini state d) 
     (dta_app_ne_def_ok d) (dta_app_ne_inc d) (lattice_bounded state d)
     (le_n_n _)).
Qed.

Lemma dt_non_empty_fix_1 :
 forall (d : preDTA) (a : ad) (n : nat),
 MapGet bool (power (Map bool) (dta_app_ne d) (map_mini state d) n) a =
 Some true -> MapGet bool (dta_non_empty_states d) a = Some true.
Proof.
	intros. elim
  (domain_equal_mapget bool bool
     (power (Map bool) (dta_app_ne d) (map_mini state d) n)
     (dta_non_empty_states d) a true).
	intros. elim (bool_is_true_or_false x); intro; rewrite H1 in H0.
	exact H0. elim (dt_non_empty_fix_0 d). intros. unfold inf_fix_points in H3. elim
  (lem_get_leb _ _ _ _ _
     (iteres_inf_fps bool (ensemble_base state d) lem 
        (dta_app_ne d) (map_mini state d) (dta_non_empty_states d) n
        (map_mini_mini state d) H2 (dta_app_ne_inc d)) H H0). apply
  (domain_equal_transitive bool state bool
     (power (Map bool) (dta_app_ne d) (map_mini state d) n) d
     (dta_non_empty_states d)). exact
  (domain_equal_symmetric state bool _ _
     (power_def_ok bool (ensemble_base state d) (dta_app_ne d)
        (map_mini state d) n (dta_app_ne_def_ok d)
        (map_mini_appartient state d))). unfold dta_non_empty_states in |- *.
	exact
  (power_def_ok bool (ensemble_base state d) (dta_app_ne d)
     (map_mini state d) (S (MapCard state d)) (dta_app_ne_def_ok d)
     (map_mini_appartient state d)). exact H.
Qed.

Lemma dt_non_empty_fix_2 :
 forall (d : preDTA) (a : ad),
 MapGet bool (dta_non_empty_states d) a = Some true ->
 exists n : nat,
   MapGet bool (power (Map bool) (dta_app_ne d) (map_mini state d) n) a =
   Some true.
Proof.
	unfold dta_non_empty_states in |- *. intros. split with (S (MapCard state d)). exact H.
Qed.

Lemma dt_non_empty_fix :
 forall (d : preDTA) (a : ad),
 MapGet bool (dta_non_empty_states d) a = Some true <->
 (exists t : term, reconnaissance d a t).
Proof.
	intros. split. intros. elim (dt_non_empty_fix_2 d a H).
	intros. exact (dt_non_empty_r _ _ _ H0). intros. elim H.
	intros. elim (dt_non_empty_d d a x H0). intros. exact (dt_non_empty_fix_1 _ _ _ H1).
Qed.

Lemma dt_non_empty_lazy_fix :
 forall (d : preDTA) (a : ad),
 MapGet bool (dta_non_empty_states_lazy d) a = Some true <->
 (exists t : term, reconnaissance d a t).
Proof.
	intro. unfold dta_non_empty_states_lazy in |- *. rewrite
  (lazy_power_eg_power bool eqm_bool (dta_app_ne d) 
     (map_mini state d) (S (MapCard state d))). exact (dt_non_empty_fix d). split. exact (eqm_bool_equal a b). intro. rewrite H. exact (equal_eqm_bool b).
Qed.