
Require Import Ensembles.
Require Import Relations_1.
Require Import Partial_Order.
Require Import Cpo.
Require Import algpodefs.
(* algpodefs:
Require Import Ensembles.
Require Import Relations_1.
Require Import Partial_Order.
Require Import Cpo.
Require Import Image.
Require Import Integers.
Section Algebraic_partial_orders.
Variable U : Type.
Variable D : PO U.

Let D_C := Carrier_of U D.

Let D_R := Rel_of U D.

Definition Consistent (A : Ensemble U) : Prop :=
  Included U A D_C ->
  forall x y : U, Included U (Couple U x y) A -> Compatible U D x y.

Definition Coherent : Prop :=
  forall A : Ensemble U,
  Included U A D_C -> Consistent A -> exists bsup : U, Lub U D A bsup.

Inductive Compact (x : U) : Prop :=
    Definition_of_compact :
      In U D_C x ->
      (forall X : Ensemble U,
       Directed U D X ->
       (exists bsup : U, Lub U D X bsup /\ D_R x bsup) ->
       exists y : U, In U X y /\ D_R x y) -> Compact x.

Inductive Approximant (x c : U) : Prop :=
    Defn_of_Approximant : Compact c -> D_R c x -> Approximant x c.

Inductive Approximants (x : U) : Ensemble U :=
    Defn_of_Approximants :
      forall c : U, Compact c -> D_R c x -> In U (Approximants x) c.

Definition Algebraic : Prop :=
  forall x : U, Directed U D (Approximants x) /\ Lub U D (Approximants x) x.

Definition Denumerable (A : Ensemble U) : Prop :=
  exists f : U -> nat, injective U nat f.

Definition Omega_algebraic : Prop :=
  Algebraic /\ Denumerable (fun x : U => Compact x).

Definition Domain : Prop := Coherent /\ Omega_algebraic.
End Algebraic_partial_orders.
Hint Unfold Consistent Coherent.
Hint Resolve Definition_of_compact.
Hint Resolve Defn_of_Approximant.
Hint Resolve Defn_of_Approximants. *)
Require Import Powerset.
Require Import Constructive_sets.
Require Import Finite_sets.
Require Import lpo.
(* lpo:
Require Import Ensembles.
Require Import Relations_1.
Require Import Partial_Order.
Require Import Cpo.
Require Import algpodefs.
Require Import Powerset.
Section Lemmas_on_partial_orders.
Variable U : Type.
Variable B : Ensemble U.
Variable D : PO U.

Theorem Rel_of_reflexive : forall x : U, Rel_of U D x x.
Hint Resolve Rel_of_reflexive.

Theorem Rel_of_antisymmetric : Antisymmetric U (Rel_of U D).
Hint Resolve Rel_of_antisymmetric.

Theorem Rel_of_transitive : Transitive U (Rel_of U D).
Hint Resolve Rel_of_transitive.

Theorem Couple_included_in_carrier :
 forall x y : U,
 In U (Carrier_of U D) x ->
 In U (Carrier_of U D) y -> Included U (Couple U x y) (Carrier_of U D).
Hint Resolve Couple_included_in_carrier.

Theorem Lub_is_in_Carrier :
 forall (bsup : U) (X : Ensemble U),
 Included U X (Carrier_of U D) ->
 Lub U D X bsup -> In U (Carrier_of U D) bsup.

Theorem Singleton_has_lub :
 forall x : U, In U (Carrier_of U D) x -> Lub U D (Singleton U x) x.
Hint Resolve Singleton_has_lub.

Theorem Empty_set_has_Upper_Bound :
 exists maj : U, Upper_Bound U D (Empty_set U) maj.
Hint Resolve Empty_set_has_Upper_Bound.

Theorem Anyone_is_Upper_Bound_of_Empty_set :
 forall x : U, In U (Carrier_of U D) x -> Upper_Bound U D (Empty_set U) x.
Hint Resolve Anyone_is_Upper_Bound_of_Empty_set.

Theorem Empty_set_has_lub :
 forall C : Cpo U, exists bsup : U, Lub U (PO_of_cpo U C) (Empty_set U) bsup.
Hint Resolve Empty_set_has_lub.

Theorem Upper_downward_stable :
 forall (A B : Ensemble U) (maj : U),
 Included U A (Carrier_of U D) ->
 Included U B (Carrier_of U D) ->
 Included U A B -> Upper_Bound U D B maj -> Upper_Bound U D A maj.

Theorem Conditionally_complete_has_a_bottom :
 Conditionally_complete U D -> exists bot : U, Bottom U D bot.
Hint Resolve Conditionally_complete_has_a_bottom.

Theorem Bottom_is_compact :
 Conditionally_complete U D ->
 exists bot : U, Bottom U D bot /\ Compact U D bot.
Proof.
intro H'; lapply Conditionally_complete_has_a_bottom;
 [ intro H'0 | try assumption ].
elim H'0; intros bot E; clear H'0.
exists bot; split; auto with sets.
apply Definition_of_compact; auto with sets.
Hint Resolve Bottom_is_compact.

Theorem Compact_is_in_Carrier :
 forall x : U, Compact U D x -> In U (Carrier_of U D) x.
Hint Resolve Compact_is_in_Carrier.

Theorem Compatible_is_reflexive : forall x : U, Compatible U D x x.
Hint Resolve Compatible_is_reflexive.

Theorem Couple_is_symmetric :
 forall x y : U, Couple U x y = Couple U y x :>Ensemble U.

Theorem Compatible_is_symmetric :
 forall x y : U, Compatible U D x y -> Compatible U D y x.
Hint Immediate Compatible_is_symmetric.

Theorem Compatible_imp_consistent :
 forall x y : U, Compatible U D x y -> Consistent U D (Couple U x y).

Theorem Consistent_imp_compatible :
 forall x y : U,
 In U (Carrier_of U D) x ->
 In U (Carrier_of U D) y ->
 Consistent U D (Couple U x y) -> Compatible U D x y.

Theorem Coherent_implies_Conditionally_Complete :
 Coherent U D -> Conditionally_complete U D.
Proof.
intro H'; red in H'.
apply Definition_of_Conditionally_complete.
Hint Resolve Coherent_implies_Conditionally_Complete.

Theorem Coherent_has_a_bottom :
 Coherent U D -> exists bot : U, Bottom U D bot.
Hint Resolve Coherent_has_a_bottom.

Theorem Coherent_implies_Complete : Coherent U D -> Complete U D.
Proof.
intro H'.
apply Definition_of_Complete; auto with sets.
End Lemmas_on_partial_orders.
Hint Resolve Rel_of_reflexive.
Hint Resolve Rel_of_antisymmetric.
Hint Resolve Rel_of_transitive.
Hint Resolve Couple_included_in_carrier.
Hint Resolve Singleton_has_lub.
Hint Resolve Empty_set_has_Upper_Bound.
Hint Resolve Anyone_is_Upper_Bound_of_Empty_set.
Hint Resolve Empty_set_has_lub.
Hint Resolve Conditionally_complete_has_a_bottom.
Hint Resolve Bottom_is_compact.
Hint Resolve Compact_is_in_Carrier.
Hint Resolve Compatible_is_reflexive.
Hint Immediate Compatible_is_symmetric.
Hint Resolve Coherent_implies_Conditionally_Complete.
Hint Resolve Coherent_has_a_bottom. *)
Require Import lpo1.
(* lpo1:
Require Import Ensembles.
Require Import Relations_1.
Require Import Partial_Order.
Require Import Cpo.
Require Import algpodefs.
Require Import Powerset.
Require Import lpo.
Require Import Constructive_sets.
Require Import Finite_sets.
Section more_lemmas.
Variable U : Type.
Variable B : Ensemble U.
Variable D : PO U.

Theorem Upper_Bound_is_in_Carrier :
 forall (X : Ensemble U) (bound : U),
 Included U X (Carrier_of U D) ->
 Upper_Bound U D X bound -> In U (Carrier_of U D) bound.

Theorem Lower_Bound_is_in_Carrier :
 forall (X : Ensemble U) (bound : U),
 Included U X (Carrier_of U D) ->
 Lower_Bound U D X bound -> In U (Carrier_of U D) bound.

Theorem Lub_is_unique :
 Conditionally_complete U D ->
 forall (C : Ensemble U) (bsup1 bsup2 : U),
 Lub U D C bsup1 -> Lub U D C bsup2 -> bsup1 = bsup2.

Theorem Upper_Bound_Couple_intro :
 forall x y z : U,
 In U (Carrier_of U D) x ->
 In U (Carrier_of U D) y ->
 In U (Carrier_of U D) z ->
 Rel_of U D x z -> Rel_of U D y z -> Upper_Bound U D (Couple U x y) z.
Hint Resolve Upper_Bound_Couple_intro.

Theorem Upper_Bound_Couple_inv :
 forall x y z : U,
 Upper_Bound U D (Couple U x y) z ->
 Rel_of U D x z /\ Rel_of U D y z /\ In U (Carrier_of U D) z.

Theorem Upper_Bound_Singleton_intro :
 forall x z : U,
 In U (Carrier_of U D) x ->
 In U (Carrier_of U D) z -> x = z -> Upper_Bound U D (Singleton U x) z.
Hint Resolve Upper_Bound_Singleton_intro.

Theorem Upper_Bound_Singleton_inv :
 forall x z : U, Upper_Bound U D (Singleton U x) z -> Rel_of U D x z.
Hint Resolve Upper_Bound_Singleton_inv.

Theorem Non_empty_has_glb :
 Conditionally_complete U D ->
 forall X : Ensemble U,
 Included U X (Carrier_of U D) ->
 Inhabited U X -> exists binf : U, Glb U D X binf.

Theorem Bounded_implies_consistent :
 forall X : Ensemble U,
 Included U X (Carrier_of U D) ->
 ex (fun maj : U => Upper_Bound U D X maj) -> Consistent U D X.

Theorem Consistent_downward_stable :
 forall B : Ensemble U,
 Included U B (Carrier_of U D) ->
 Consistent U D B ->
 forall A : Ensemble U, Included U A B -> Consistent U D A.

Lemma Consistent_triple_intro :
 forall x y z : U,
 Compatible U D x y ->
 Compatible U D y z -> Compatible U D x z -> Consistent U D (Triple U x y z).
End more_lemmas.
Hint Resolve Upper_Bound_Couple_intro.
Hint Resolve Upper_Bound_Singleton_intro.
Hint Resolve Upper_Bound_Singleton_inv.
Hint Resolve Bounded_implies_consistent. *)
Require Import alpo.
(* alpo:
Require Import Ensembles.
Require Import Relations_1.
Require Import Partial_Order.
Require Import Cpo.
Require Import algpodefs.
Require Import Powerset.
Require Import Constructive_sets.
Require Import Finite_sets.
Require Import lpo.
Require Import lpo1.
Section Advanced_lemmas.
Variable U : Type.
Variable D : PO U.
Hint Resolve Lub_definition Upper_Bound_Couple_intro.

Lemma Lub_monotonic :
 forall A B : Ensemble U,
 Included U A B ->
 Included U B (Carrier_of U D) ->
 forall a b : U, Lub U D A a -> Lub U D B b -> Rel_of U D a b.

Lemma Compatible_lubs :
 forall A B C : Ensemble U,
 Included U A C ->
 Included U B C ->
 Included U C (Carrier_of U D) ->
 forall a b c : U,
 Lub U D A a -> Lub U D B b -> Lub U D C c -> Compatible U D a b.

Lemma LUaux :
 forall A B : Ensemble U,
 Included U (Union U A B) (Carrier_of U D) ->
 forall a b bsup : U,
 Lub U D A a ->
 Lub U D B b -> Lub U D (Union U A B) bsup -> Lub U D (Couple U a b) bsup.

Lemma LUaux2 :
 forall A B : Ensemble U,
 Included U (Union U A B) (Carrier_of U D) ->
 forall a b bsup : U,
 Lub U D A a ->
 Lub U D B b -> Lub U D (Couple U a b) bsup -> Lub U D (Union U A B) bsup.

Theorem Lub_of_Union :
 Conditionally_complete U D ->
 forall A B : Ensemble U,
 Included U (Union U A B) (Carrier_of U D) ->
 forall x : U,
 In U (Carrier_of U D) x ->
 Upper_Bound U D (Union U A B) x ->
 forall a b : U,
 Lub U D A a ->
 Lub U D B b ->
 exists bsup : U, Lub U D (Union U A B) bsup /\ Lub U D (Couple U a b) bsup.

Theorem Lub_of_compacts_is_compact :
 Conditionally_complete U D ->
 forall x y z : U,
 Included U (Couple U x y) (Approximants U D z) ->
 In U (Carrier_of U D) z ->
 exists bsup : U, Lub U D (Couple U x y) bsup /\ Approximant U D z bsup.
Proof.
intros H' x y z H'0 K; red in H'0.
elim (H'0 x); auto with sets.
intros c H'1 H'2.
elim (H'0 y); auto with sets.
intros c' H'3 H'4.
elim H'.
intro H'5; elim (H'5 (Couple U c c')); auto with sets.
2: elim H'1; elim H'3; exists z; auto with sets.
intros bsup H'6; elim H'6.
intros H'7 H'8; exists bsup; split; auto with sets.
apply Defn_of_Approximant; auto with sets.
apply Definition_of_compact.

Theorem approximants_closed_by_finite_lubs :
 Conditionally_complete U D ->
 forall (x : U) (C : Ensemble U),
 In U (Carrier_of U D) x ->
 Finite U C ->
 Included U C (Approximants U D x) ->
 exists bsup : U, Lub U D C bsup /\ Approximant U D x bsup.

Theorem Approximants_directed_set :
 Conditionally_complete U D ->
 forall x : U, In U (Carrier_of U D) x -> Directed U D (Approximants U D x).

Theorem Inclusion_of_Approximants :
 Domain U D ->
 forall x y : U,
 In U (Carrier_of U D) x ->
 In U (Carrier_of U D) y ->
 Included U (Approximants U D x) (Approximants U D y) -> Rel_of U D x y.
Hint Resolve Inclusion_of_Approximants.

Theorem Less_imp_Inclusion_of_Approximants :
 Domain U D ->
 forall x y : U,
 In U (Carrier_of U D) x ->
 In U (Carrier_of U D) y ->
 Rel_of U D x y -> Included U (Approximants U D x) (Approximants U D y).

Theorem Approximants_define_element :
 Domain U D ->
 forall x y : U,
 In U (Carrier_of U D) x ->
 In U (Carrier_of U D) y -> Approximants U D x = Approximants U D y -> x = y.
Hint Resolve Approximants_define_element.
Require Import Classical_sets.
Hint Unfold not.

Theorem Corollary1_1 :
 Domain U D ->
 forall x y : U,
 Compact U D x ->
 In U (Carrier_of U D) y ->
 Strict_Rel_of U D x y ->
 exists z : U, In U (Approximants U D y) z /\ Strict_Rel_of U D x z.

Theorem Corollary1_2 :
 Domain U D ->
 forall x : U,
 In U (Carrier_of U D) x ->
 ~ Compact U D x -> ~ Finite U (Approximants U D x).
End Advanced_lemmas.
Hint Resolve Inclusion_of_Approximants.
Hint Resolve Upper_Bound_Couple_intro. *)
Require Import Finite_sets_facts.
Section First_inductive_lemma.
Variable U : Type.
Variable C : Cpo U.

Let D : PO U := PO_of_cpo U C.

Theorem Pairs_are_enough_finite_case :
 (forall x y : U,
  Compatible U D x y -> ex (fun bsup : U => Lub U D (Couple U x y) bsup)) ->
 forall X : Ensemble U,
 Finite U X ->
 Included U X (Carrier_of U D) ->
 ex (fun maj : U => Upper_Bound U D X maj) ->
 ex (fun bsup : U => Lub U D X bsup).
Proof.
intros H' X H'0; elim H'0; auto with sets.
unfold D at 3 in |- *; auto with sets.
unfold Add in |- *.
intros A H'1 H'2 x H'3 H'4 H'5.
elim H'5; intros maj E; try exact E; clear H'5.
elim H'2; [ intros bsupA E0; elim E0; clear H'2 | clear H'2 | clear H'2 ];
 auto with sets.
2: exists maj;
    apply Upper_downward_stable with (B := Union U A (Singleton U x));
    auto with sets.
intros H'2 H'6.
elim (H' bsupA x); [ intros bsup E1; elim E1 | idtac ]; auto with sets.
2: red in |- *; simpl in |- *.
2: intros H'7 H'8; exists maj; elim E; auto 7 with sets.
intros H'5 H'7; try assumption.
exists bsup; try assumption.
apply LUaux2 with (a := bsupA) (b := x); auto with sets.
Qed.

Inductive Lubs_of_finite_parts (X : Ensemble U) : Ensemble U :=
    Lubs_of_finite_parts_def :
      forall (bsup : U) (Y : Ensemble U),
      Included U Y X ->
      Finite U Y -> Lub U D Y bsup -> In U (Lubs_of_finite_parts X) bsup.

Theorem LFP_directed :
 forall X : Ensemble U,
 (forall Y : Ensemble U,
  Included U Y X -> Finite U Y -> exists bsup : U, Lub U D Y bsup) ->
 Included U X (Carrier_of U D) ->
 Consistent U D X -> Directed U D (Lubs_of_finite_parts X).
intros X K H' L; apply Definition_of_Directed.
red in |- *; simpl in |- *; intros x H'0; elim H'0; auto with sets.
intros bsup Y H'1 H'2 H'3; apply Lub_is_in_Carrier with (X := Y);
 auto with sets.
elim (Empty_set_has_lub U C); intros bsup E.
apply Inhabited_intro with (x := bsup).
apply Lubs_of_finite_parts_def with (Y := Empty_set U); auto with sets.
intros x1 x2 H'4; red in H'4.
lapply (H'4 x1); [ intro H'1; elim H'1 | idtac ]; auto with sets.
intros bsup Y H'0 H'2 H'3; try assumption.
lapply (H'4 x2); [ intro H'6; elim H'6 | idtac ]; auto with sets.
intros bsup0 Y0 H'5 H'7 H'8; try assumption.
lapply (Union_preserves_Finite U Y Y0);
 [ intro H'12; lapply H'12; [ intro H'13; clear H'12 | clear H'12 ] | idtac ];
 auto with sets.
elim (K (Union U Y Y0)); [ intros bsup1 E | idtac | idtac ]; auto with sets.
exists bsup1; split.
apply Lubs_of_finite_parts_def with (Y := Union U Y Y0); auto with sets.
apply Upper_Bound_Couple_intro.
apply Lub_is_in_Carrier with (X := Y); auto with sets.
apply Lub_is_in_Carrier with (X := Y0); auto with sets.
apply Lub_is_in_Carrier with (X := Union U Y Y0); auto with sets.
elim H'3.
intros H'10 H'11; apply H'11.
elim E; intros H'12 H'14;
 apply Upper_downward_stable with (B := Union U Y Y0); 
 auto with sets.
elim H'8.
intros H'10 H'11; apply H'11.
elim E; intros H'12 H'14;
 apply Upper_downward_stable with (B := Union U Y Y0); 
 auto with sets.
Qed.

Theorem Lub_is_LFP :
 forall X : Ensemble U,
 Included U X (Carrier_of U D) ->
 forall bsup : U, Lub U D (Lubs_of_finite_parts X) bsup -> Lub U D X bsup.
intros X K bsup E0; elim E0.
intros H'4 H'5; apply Lub_definition; auto with sets.
apply Upper_Bound_definition; auto with sets.
apply Lub_is_in_Carrier with (X := Lubs_of_finite_parts X); auto with sets.
red in |- *; simpl in |- *; intros x H'8; elim H'8.
intros bsup0 Y H'9 H'10 H'11; apply Lub_is_in_Carrier with Y; auto with sets.
intros y H'8; elim H'4.
intros H'9 H'10; apply H'10.
apply Lubs_of_finite_parts_def with (Y := Singleton U y); auto with sets.
red in |- *; simpl in |- *.
intros x H'11; elim H'11; auto with sets.
apply Singleton_is_finite.
intros y H'8; apply H'5.
apply Upper_Bound_definition.
elim H'8; auto with sets.
intros y0 H'9; elim H'9.
intros bsup1 Y H'10 H'11 H'12; elim H'12.
intros H'13 H'14; apply H'14.
apply Upper_downward_stable with (B := X); auto with sets.
Qed.
Hint Resolve Lub_is_LFP.
Hint Resolve Pairs_are_enough_finite_case.

Theorem Pairs_are_enough :
 (forall x y : U,
  Compatible U D x y -> ex (fun bsup : U => Lub U D (Couple U x y) bsup)) ->
 Conditionally_complete U D.
Proof.
intro H'; apply Definition_of_Conditionally_complete.
intros X H'1 H'2.
cut (Complete U D).
2: exact (Cpo_cond U C).
intro H'3; elim H'3; intros H'6 H'7.
elim (H'7 (Lubs_of_finite_parts X)); [ intros bsup0 E0 | apply LFP_directed ];
 auto with sets.
exists bsup0; auto with sets.
auto with sets.
intros Y H'4 H'5; apply Pairs_are_enough_finite_case; auto with sets.
elim H'2; intros maj E; try exact E; clear H'2.
exists maj.
apply Upper_downward_stable with (B := X); auto with sets.
Qed.
End First_inductive_lemma.
Hint Resolve Lub_is_LFP.

