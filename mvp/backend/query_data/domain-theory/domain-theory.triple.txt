
Require Import Ensembles.
Require Import Constructive_sets.
Require Import Relations_1.
Require Import Partial_Order.
Require Import Cpo.
Require Import algpodefs.
(* algpodefs:
Require Import Ensembles.
Require Import Relations_1.
Require Import Partial_Order.
Require Import Cpo.
Require Import Image.
Require Import Integers.
Section Algebraic_partial_orders.
Variable U : Type.
Variable D : PO U.

Let D_C := Carrier_of U D.

Let D_R := Rel_of U D.

Definition Consistent (A : Ensemble U) : Prop :=
  Included U A D_C ->
  forall x y : U, Included U (Couple U x y) A -> Compatible U D x y.

Definition Coherent : Prop :=
  forall A : Ensemble U,
  Included U A D_C -> Consistent A -> exists bsup : U, Lub U D A bsup.

Inductive Compact (x : U) : Prop :=
    Definition_of_compact :
      In U D_C x ->
      (forall X : Ensemble U,
       Directed U D X ->
       (exists bsup : U, Lub U D X bsup /\ D_R x bsup) ->
       exists y : U, In U X y /\ D_R x y) -> Compact x.

Inductive Approximant (x c : U) : Prop :=
    Defn_of_Approximant : Compact c -> D_R c x -> Approximant x c.

Inductive Approximants (x : U) : Ensemble U :=
    Defn_of_Approximants :
      forall c : U, Compact c -> D_R c x -> In U (Approximants x) c.

Definition Algebraic : Prop :=
  forall x : U, Directed U D (Approximants x) /\ Lub U D (Approximants x) x.

Definition Denumerable (A : Ensemble U) : Prop :=
  exists f : U -> nat, injective U nat f.

Definition Omega_algebraic : Prop :=
  Algebraic /\ Denumerable (fun x : U => Compact x).

Definition Domain : Prop := Coherent /\ Omega_algebraic.
End Algebraic_partial_orders.
Hint Unfold Consistent Coherent.
Hint Resolve Definition_of_compact.
Hint Resolve Defn_of_Approximant.
Hint Resolve Defn_of_Approximants. *)
Require Import Powerset.
Require Import Powerset_facts.
Require Import Finite_sets.
Require Import Finite_sets_facts.
Require Import lpo.
(* lpo:
Require Import Ensembles.
Require Import Relations_1.
Require Import Partial_Order.
Require Import Cpo.
Require Import algpodefs.
Require Import Powerset.
Section Lemmas_on_partial_orders.
Variable U : Type.
Variable B : Ensemble U.
Variable D : PO U.

Theorem Rel_of_reflexive : forall x : U, Rel_of U D x x.
Hint Resolve Rel_of_reflexive.

Theorem Rel_of_antisymmetric : Antisymmetric U (Rel_of U D).
Hint Resolve Rel_of_antisymmetric.

Theorem Rel_of_transitive : Transitive U (Rel_of U D).
Hint Resolve Rel_of_transitive.

Theorem Couple_included_in_carrier :
 forall x y : U,
 In U (Carrier_of U D) x ->
 In U (Carrier_of U D) y -> Included U (Couple U x y) (Carrier_of U D).
Hint Resolve Couple_included_in_carrier.

Theorem Lub_is_in_Carrier :
 forall (bsup : U) (X : Ensemble U),
 Included U X (Carrier_of U D) ->
 Lub U D X bsup -> In U (Carrier_of U D) bsup.

Theorem Singleton_has_lub :
 forall x : U, In U (Carrier_of U D) x -> Lub U D (Singleton U x) x.
Hint Resolve Singleton_has_lub.

Theorem Empty_set_has_Upper_Bound :
 exists maj : U, Upper_Bound U D (Empty_set U) maj.
Hint Resolve Empty_set_has_Upper_Bound.

Theorem Anyone_is_Upper_Bound_of_Empty_set :
 forall x : U, In U (Carrier_of U D) x -> Upper_Bound U D (Empty_set U) x.
Hint Resolve Anyone_is_Upper_Bound_of_Empty_set.

Theorem Empty_set_has_lub :
 forall C : Cpo U, exists bsup : U, Lub U (PO_of_cpo U C) (Empty_set U) bsup.
Hint Resolve Empty_set_has_lub.

Theorem Upper_downward_stable :
 forall (A B : Ensemble U) (maj : U),
 Included U A (Carrier_of U D) ->
 Included U B (Carrier_of U D) ->
 Included U A B -> Upper_Bound U D B maj -> Upper_Bound U D A maj.

Theorem Conditionally_complete_has_a_bottom :
 Conditionally_complete U D -> exists bot : U, Bottom U D bot.
Hint Resolve Conditionally_complete_has_a_bottom.

Theorem Bottom_is_compact :
 Conditionally_complete U D ->
 exists bot : U, Bottom U D bot /\ Compact U D bot.
Proof.
intro H'; lapply Conditionally_complete_has_a_bottom;
 [ intro H'0 | try assumption ].
elim H'0; intros bot E; clear H'0.
exists bot; split; auto with sets.
apply Definition_of_compact; auto with sets.
Hint Resolve Bottom_is_compact.

Theorem Compact_is_in_Carrier :
 forall x : U, Compact U D x -> In U (Carrier_of U D) x.
Hint Resolve Compact_is_in_Carrier.

Theorem Compatible_is_reflexive : forall x : U, Compatible U D x x.
Hint Resolve Compatible_is_reflexive.

Theorem Couple_is_symmetric :
 forall x y : U, Couple U x y = Couple U y x :>Ensemble U.

Theorem Compatible_is_symmetric :
 forall x y : U, Compatible U D x y -> Compatible U D y x.
Hint Immediate Compatible_is_symmetric.

Theorem Compatible_imp_consistent :
 forall x y : U, Compatible U D x y -> Consistent U D (Couple U x y).

Theorem Consistent_imp_compatible :
 forall x y : U,
 In U (Carrier_of U D) x ->
 In U (Carrier_of U D) y ->
 Consistent U D (Couple U x y) -> Compatible U D x y.

Theorem Coherent_implies_Conditionally_Complete :
 Coherent U D -> Conditionally_complete U D.
Proof.
intro H'; red in H'.
apply Definition_of_Conditionally_complete.
Hint Resolve Coherent_implies_Conditionally_Complete.

Theorem Coherent_has_a_bottom :
 Coherent U D -> exists bot : U, Bottom U D bot.
Hint Resolve Coherent_has_a_bottom.

Theorem Coherent_implies_Complete : Coherent U D -> Complete U D.
Proof.
intro H'.
apply Definition_of_Complete; auto with sets.
End Lemmas_on_partial_orders.
Hint Resolve Rel_of_reflexive.
Hint Resolve Rel_of_antisymmetric.
Hint Resolve Rel_of_transitive.
Hint Resolve Couple_included_in_carrier.
Hint Resolve Singleton_has_lub.
Hint Resolve Empty_set_has_Upper_Bound.
Hint Resolve Anyone_is_Upper_Bound_of_Empty_set.
Hint Resolve Empty_set_has_lub.
Hint Resolve Conditionally_complete_has_a_bottom.
Hint Resolve Bottom_is_compact.
Hint Resolve Compact_is_in_Carrier.
Hint Resolve Compatible_is_reflexive.
Hint Immediate Compatible_is_symmetric.
Hint Resolve Coherent_implies_Conditionally_Complete.
Hint Resolve Coherent_has_a_bottom. *)
Require Import lpo1.
(* lpo1:
Require Import Ensembles.
Require Import Relations_1.
Require Import Partial_Order.
Require Import Cpo.
Require Import algpodefs.
Require Import Powerset.
Require Import lpo.
Require Import Constructive_sets.
Require Import Finite_sets.
Section more_lemmas.
Variable U : Type.
Variable B : Ensemble U.
Variable D : PO U.

Theorem Upper_Bound_is_in_Carrier :
 forall (X : Ensemble U) (bound : U),
 Included U X (Carrier_of U D) ->
 Upper_Bound U D X bound -> In U (Carrier_of U D) bound.

Theorem Lower_Bound_is_in_Carrier :
 forall (X : Ensemble U) (bound : U),
 Included U X (Carrier_of U D) ->
 Lower_Bound U D X bound -> In U (Carrier_of U D) bound.

Theorem Lub_is_unique :
 Conditionally_complete U D ->
 forall (C : Ensemble U) (bsup1 bsup2 : U),
 Lub U D C bsup1 -> Lub U D C bsup2 -> bsup1 = bsup2.

Theorem Upper_Bound_Couple_intro :
 forall x y z : U,
 In U (Carrier_of U D) x ->
 In U (Carrier_of U D) y ->
 In U (Carrier_of U D) z ->
 Rel_of U D x z -> Rel_of U D y z -> Upper_Bound U D (Couple U x y) z.
Hint Resolve Upper_Bound_Couple_intro.

Theorem Upper_Bound_Couple_inv :
 forall x y z : U,
 Upper_Bound U D (Couple U x y) z ->
 Rel_of U D x z /\ Rel_of U D y z /\ In U (Carrier_of U D) z.

Theorem Upper_Bound_Singleton_intro :
 forall x z : U,
 In U (Carrier_of U D) x ->
 In U (Carrier_of U D) z -> x = z -> Upper_Bound U D (Singleton U x) z.
Hint Resolve Upper_Bound_Singleton_intro.

Theorem Upper_Bound_Singleton_inv :
 forall x z : U, Upper_Bound U D (Singleton U x) z -> Rel_of U D x z.
Hint Resolve Upper_Bound_Singleton_inv.

Theorem Non_empty_has_glb :
 Conditionally_complete U D ->
 forall X : Ensemble U,
 Included U X (Carrier_of U D) ->
 Inhabited U X -> exists binf : U, Glb U D X binf.

Theorem Bounded_implies_consistent :
 forall X : Ensemble U,
 Included U X (Carrier_of U D) ->
 ex (fun maj : U => Upper_Bound U D X maj) -> Consistent U D X.

Theorem Consistent_downward_stable :
 forall B : Ensemble U,
 Included U B (Carrier_of U D) ->
 Consistent U D B ->
 forall A : Ensemble U, Included U A B -> Consistent U D A.

Lemma Consistent_triple_intro :
 forall x y z : U,
 Compatible U D x y ->
 Compatible U D y z -> Compatible U D x z -> Consistent U D (Triple U x y z).
End more_lemmas.
Hint Resolve Upper_Bound_Couple_intro.
Hint Resolve Upper_Bound_Singleton_intro.
Hint Resolve Upper_Bound_Singleton_inv.
Hint Resolve Bounded_implies_consistent. *)
Require Import alpo.
(* alpo:
Require Import Ensembles.
Require Import Relations_1.
Require Import Partial_Order.
Require Import Cpo.
Require Import algpodefs.
Require Import Powerset.
Require Import Constructive_sets.
Require Import Finite_sets.
Require Import lpo.
Require Import lpo1.
Section Advanced_lemmas.
Variable U : Type.
Variable D : PO U.
Hint Resolve Lub_definition Upper_Bound_Couple_intro.

Lemma Lub_monotonic :
 forall A B : Ensemble U,
 Included U A B ->
 Included U B (Carrier_of U D) ->
 forall a b : U, Lub U D A a -> Lub U D B b -> Rel_of U D a b.

Lemma Compatible_lubs :
 forall A B C : Ensemble U,
 Included U A C ->
 Included U B C ->
 Included U C (Carrier_of U D) ->
 forall a b c : U,
 Lub U D A a -> Lub U D B b -> Lub U D C c -> Compatible U D a b.

Lemma LUaux :
 forall A B : Ensemble U,
 Included U (Union U A B) (Carrier_of U D) ->
 forall a b bsup : U,
 Lub U D A a ->
 Lub U D B b -> Lub U D (Union U A B) bsup -> Lub U D (Couple U a b) bsup.

Lemma LUaux2 :
 forall A B : Ensemble U,
 Included U (Union U A B) (Carrier_of U D) ->
 forall a b bsup : U,
 Lub U D A a ->
 Lub U D B b -> Lub U D (Couple U a b) bsup -> Lub U D (Union U A B) bsup.

Theorem Lub_of_Union :
 Conditionally_complete U D ->
 forall A B : Ensemble U,
 Included U (Union U A B) (Carrier_of U D) ->
 forall x : U,
 In U (Carrier_of U D) x ->
 Upper_Bound U D (Union U A B) x ->
 forall a b : U,
 Lub U D A a ->
 Lub U D B b ->
 exists bsup : U, Lub U D (Union U A B) bsup /\ Lub U D (Couple U a b) bsup.

Theorem Lub_of_compacts_is_compact :
 Conditionally_complete U D ->
 forall x y z : U,
 Included U (Couple U x y) (Approximants U D z) ->
 In U (Carrier_of U D) z ->
 exists bsup : U, Lub U D (Couple U x y) bsup /\ Approximant U D z bsup.
Proof.
intros H' x y z H'0 K; red in H'0.
elim (H'0 x); auto with sets.
intros c H'1 H'2.
elim (H'0 y); auto with sets.
intros c' H'3 H'4.
elim H'.
intro H'5; elim (H'5 (Couple U c c')); auto with sets.
2: elim H'1; elim H'3; exists z; auto with sets.
intros bsup H'6; elim H'6.
intros H'7 H'8; exists bsup; split; auto with sets.
apply Defn_of_Approximant; auto with sets.
apply Definition_of_compact.

Theorem approximants_closed_by_finite_lubs :
 Conditionally_complete U D ->
 forall (x : U) (C : Ensemble U),
 In U (Carrier_of U D) x ->
 Finite U C ->
 Included U C (Approximants U D x) ->
 exists bsup : U, Lub U D C bsup /\ Approximant U D x bsup.

Theorem Approximants_directed_set :
 Conditionally_complete U D ->
 forall x : U, In U (Carrier_of U D) x -> Directed U D (Approximants U D x).

Theorem Inclusion_of_Approximants :
 Domain U D ->
 forall x y : U,
 In U (Carrier_of U D) x ->
 In U (Carrier_of U D) y ->
 Included U (Approximants U D x) (Approximants U D y) -> Rel_of U D x y.
Hint Resolve Inclusion_of_Approximants.

Theorem Less_imp_Inclusion_of_Approximants :
 Domain U D ->
 forall x y : U,
 In U (Carrier_of U D) x ->
 In U (Carrier_of U D) y ->
 Rel_of U D x y -> Included U (Approximants U D x) (Approximants U D y).

Theorem Approximants_define_element :
 Domain U D ->
 forall x y : U,
 In U (Carrier_of U D) x ->
 In U (Carrier_of U D) y -> Approximants U D x = Approximants U D y -> x = y.
Hint Resolve Approximants_define_element.
Require Import Classical_sets.
Hint Unfold not.

Theorem Corollary1_1 :
 Domain U D ->
 forall x y : U,
 Compact U D x ->
 In U (Carrier_of U D) y ->
 Strict_Rel_of U D x y ->
 exists z : U, In U (Approximants U D y) z /\ Strict_Rel_of U D x z.

Theorem Corollary1_2 :
 Domain U D ->
 forall x : U,
 In U (Carrier_of U D) x ->
 ~ Compact U D x -> ~ Finite U (Approximants U D x).
End Advanced_lemmas.
Hint Resolve Inclusion_of_Approximants.
Hint Resolve Upper_Bound_Couple_intro. *)
Require Import newfil.
(* newfil:
Require Import Ensembles.
Require Import Relations_1.
Require Import Partial_Order.
Require Import Cpo.
Require Import algpodefs.
Require Import Powerset.
Require Import Constructive_sets.
Require Import Finite_sets.
Require Import lpo.
Require Import lpo1.
Require Import alpo.
Require Import Finite_sets_facts.
Section First_inductive_lemma.
Variable U : Type.
Variable C : Cpo U.

Let D : PO U := PO_of_cpo U C.

Theorem Pairs_are_enough_finite_case :
 (forall x y : U,
  Compatible U D x y -> ex (fun bsup : U => Lub U D (Couple U x y) bsup)) ->
 forall X : Ensemble U,
 Finite U X ->
 Included U X (Carrier_of U D) ->
 ex (fun maj : U => Upper_Bound U D X maj) ->
 ex (fun bsup : U => Lub U D X bsup).

Inductive Lubs_of_finite_parts (X : Ensemble U) : Ensemble U :=
    Lubs_of_finite_parts_def :
      forall (bsup : U) (Y : Ensemble U),
      Included U Y X ->
      Finite U Y -> Lub U D Y bsup -> In U (Lubs_of_finite_parts X) bsup.

Theorem LFP_directed :
 forall X : Ensemble U,
 (forall Y : Ensemble U,
  Included U Y X -> Finite U Y -> exists bsup : U, Lub U D Y bsup) ->
 Included U X (Carrier_of U D) ->
 Consistent U D X -> Directed U D (Lubs_of_finite_parts X).
intros X K H' L; apply Definition_of_Directed.

Theorem Lub_is_LFP :
 forall X : Ensemble U,
 Included U X (Carrier_of U D) ->
 forall bsup : U, Lub U D (Lubs_of_finite_parts X) bsup -> Lub U D X bsup.
Hint Resolve Lub_is_LFP.
Hint Resolve Pairs_are_enough_finite_case.

Theorem Pairs_are_enough :
 (forall x y : U,
  Compatible U D x y -> ex (fun bsup : U => Lub U D (Couple U x y) bsup)) ->
 Conditionally_complete U D.
Proof.
intro H'; apply Definition_of_Conditionally_complete.
End First_inductive_lemma.
Hint Resolve Lub_is_LFP. *)
Section Second_inductive_lemma.
Variable U : Type.
Variable C : Cpo U.

Definition D : PO U := PO_of_cpo U C.

Theorem Triples_are_enough_finite_case :
 (forall x y z : U,
  Consistent U D (Triple U x y z) ->
  ex (fun bsup : U => Lub U D (Triple U x y z) bsup)) ->
 forall X : Ensemble U,
 Finite U X ->
 Included U X (Carrier_of U D) ->
 Consistent U D X -> ex (fun bsup : U => Lub U D X bsup).
Proof.
intro H'; try assumption.
intros X H'0; try assumption.
elim H'0 using Generalized_induction_on_finite_sets.
clear H'0.
clear X.
intros X H'0; elim H'0.
unfold D at 6 in |- *; auto with sets.
clear H'0 X.
intros A H'0; elim H'0.
intros H'1 x H'2 H'3 H'4 H'5; try assumption.
rewrite (Empty_set_zero' U x).
exists x; auto with sets.
clear H'0 A.
intros A H'0; elim H'0.
intros H'1 x H'2 H'3 x0 H'4 H'5 H'6 H'7; try assumption.
2: clear H'0 A.
2: intros A H'0 H'1 x H'2 H'3 x0 H'4 H'5 x1 H'6 H'7 H'8 H'9; try assumption.
clear H'5 H'3 H'1.
rewrite (Empty_set_zero' U x).
unfold Add at 1 in |- *.
rewrite (Couple_as_union U x x0).
rewrite (Triple_as_Couple U x x0).
apply H'.
rewrite <- (Triple_as_union U x x x0).
rewrite (Union_idempotent U (Singleton U x)).
generalize H'7.
rewrite (Empty_set_zero' U x).
unfold Add at 1 in |- *; auto with sets.
clear H'5 H'3 H'1 H'0.
cut
 (forall X : Ensemble U,
  Included U X (Add U (Add U (Add U A x) x0) x1) ->
  Included U X (Carrier_of U D)); auto with sets.
intro L1.
cut
 (forall X : Ensemble U,
  Included U X (Add U (Add U (Add U A x) x0) x1) -> Consistent U D X);
 auto with sets.
2: intros X H'0.
2: apply
    Consistent_downward_stable with (B := Add U (Add U (Add U A x) x0) x1);
    auto with sets.
intro L2.
cut (Included U (Add U A x) (Add U (Add U (Add U A x) x0) x1)); auto with sets.
intro F1.
cut (Included U (Add U A x0) (Add U (Add U (Add U A x) x0) x1));
 auto with sets.
2: apply (Inclusion_is_transitive U) with (Add U (Add U A x) x0);
    auto with sets.
intro F2.
cut (Included U (Add U A x1) (Add U (Add U (Add U A x) x0) x1));
 auto with sets.
intro F3.
cut (Included U (Add U (Add U A x) x0) (Add U (Add U (Add U A x) x0) x1));
 auto with sets.
intro F4.
cut (Included U (Add U (Add U A x) x1) (Add U (Add U (Add U A x) x0) x1));
 auto with sets.
intro F5.
cut (Included U (Add U (Add U A x0) x1) (Add U (Add U (Add U A x) x0) x1));
 auto with sets.
intro F6.
cut
 (Strict_Included U (Add U (Add U A x) x0) (Add U (Add U (Add U A x) x0) x1)).
2: split; auto with sets.
2: red in |- *; simpl in |- *; intro H'0.
2: lapply
    (Extension U (Add U (Add U A x) x0) (Add U (Add U (Add U A x) x0) x1));
    [ intro H'10; elim H'10 | idtac ]; auto with sets.
intro G1.
cut
 (Strict_Included U (Add U (Add U A x) x1) (Add U (Add U (Add U A x) x0) x1)).
2: split; auto with sets.
2: red in |- *; simpl in |- *; intro H'0.
2: lapply
    (Extension U (Add U (Add U A x) x1) (Add U (Add U (Add U A x) x0) x1));
    [ intro H'10; elim H'10 | idtac ]; auto with sets.
2: intros H'1 H'3; try assumption.
2: apply H'4.
2: lapply (incl_add_x U (Add U (Add U A x) x0) (Add U A x) x1);
    [ intro H'14; lapply H'14;
       [ intro H'15; try exact H'15; clear H'14 | clear H'14 ]
    | idtac ]; auto with sets.
intro G2.
cut
 (Strict_Included U (Add U (Add U A x0) x1) (Add U (Add U (Add U A x) x0) x1)).
2: split; auto with sets.
2: red in |- *; simpl in |- *; intro H'0.
2: lapply
    (Extension U (Add U (Add U A x0) x1) (Add U (Add U (Add U A x) x0) x1));
    [ intro H'10; elim H'10 | idtac ]; auto with sets.
2: intros H'1 H'3; try assumption.
2: apply H'2.
2: lapply (incl_add_x U (Add U (Add U A x) x0) (Add U A x0) x1);
    [ intro H'14; lapply H'14;
       [ intro H'15; try exact H'15; clear H'14 | clear H'14 ]
    | idtac ]; auto with sets.
2: lapply (incl_add_x U (Add U A x) A x0);
    [ intro H'14; lapply H'14;
       [ intro H'16; try exact H'16; clear H'14 | clear H'14 ]
    | idtac ]; auto with sets.
intro G3; try assumption.
cut (Strict_Included U (Add U A x0) (Add U (Add U (Add U A x) x0) x1)).
2: apply
    Strict_inclusion_is_transitive_with_inclusion_left
     with (y := Add U (Add U A x0) x1); auto with sets.
intro G4; try assumption.
cut (Strict_Included U (Add U A x1) (Add U (Add U (Add U A x) x0) x1)).
2: apply
    Strict_inclusion_is_transitive_with_inclusion_left
     with (y := Add U (Add U A x) x1); auto with sets.
intro G5; try assumption.
cut (Strict_Included U (Add U A x) (Add U (Add U (Add U A x) x0) x1)).
2: apply
    Strict_inclusion_is_transitive_with_inclusion_left
     with (y := Add U (Add U A x) x0); auto with sets.
intro G6; try assumption.
elim (H'7 (Add U A x));
 [ intros bsup E; try exact E | idtac | idtac | idtac ]; 
 auto with sets.
elim (H'7 (Add U A x0));
 [ intros bsup0 E0; try exact E0 | idtac | idtac | idtac ]; 
 auto with sets.
elim (H'7 (Add U A x1));
 [ intros bsup1 E1; try exact E1 | idtac | idtac | idtac ]; 
 auto with sets.
elim (H'7 (Add U (Add U A x) x0));
 [ intros bsup2 E2; try exact E2 | idtac | idtac | idtac ]; 
 auto with sets.
elim (H'7 (Add U (Add U A x) x1));
 [ intros bsup3 E3; try exact E3 | idtac | idtac | idtac ]; 
 auto with sets.
elim (H'7 (Add U (Add U A x0) x1));
 [ intros bsup4 E4; try exact E4 | idtac | idtac | idtac ]; 
 auto with sets.
elim (H' bsup bsup0 bsup1); [ intros bsup5 E5; try exact E5 | idtac ];
 auto with sets.
exists bsup5; try assumption.
2: apply Consistent_triple_intro.
2: apply
    Compatible_lubs
     with
       (A := Add U A x)
       (B := Add U A x0)
       (C := Add U (Add U A x) x0)
       (c := bsup2); auto with sets.
2: apply
    Compatible_lubs
     with
       (A := Add U A x0)
       (B := Add U A x1)
       (C := Add U (Add U A x0) x1)
       (c := bsup4); auto with sets.
2: apply
    Compatible_lubs
     with
       (A := Add U A x)
       (B := Add U A x1)
       (C := Add U (Add U A x) x1)
       (c := bsup3); auto with sets.
generalize E5.
clear E5.
rewrite (Triple_as_Couple_Singleton U bsup bsup0 bsup1). 
intro E5; try assumption.
unfold Add at 1 in |- *.
cut
 (Union U (Add U (Add U A x) x0) (Singleton U x1) =
  Union U (Add U (Add U A x) x0) (Add U A x1)).
intro H'0; rewrite H'0.
clear H'0.
apply LUaux2 with (a := bsup2) (b := bsup1); auto with sets.
apply LUaux with (A := Couple U bsup bsup0) (B := Singleton U bsup1);
 auto with sets.
3: apply Singleton_has_lub.
clear E5 E4 E3 G6 G5 G4 G3 G2 G1 H'9 H'7 bsup5 bsup4 bsup3 H'6 H'4 H'2 H'.
red in |- *; simpl in |- *.
intros x2 H'; elim H'; auto with sets.
intros x3 H'0; elim H'0; auto with sets.
apply Lub_is_in_Carrier with (X := Add U A x); auto with sets.
apply Lub_is_in_Carrier with (X := Add U A x0); auto with sets.
intros x3 H'0; elim H'0; auto with sets.
apply Lub_is_in_Carrier with (X := Add U A x1); auto with sets.
2: apply Lub_is_in_Carrier with (X := Add U A x1); auto with sets.
apply LUaux with (A := Add U A x) (B := Add U A x0); auto with sets.
cut (Add U (Add U A x) x0 = Union U (Add U A x) (Add U A x0)).
intro H'0; rewrite <- H'0; auto with sets.
cut (Add U (Add U A x) x0 = Union U (Add U A x) (Add U A x0) :>Ensemble U).
clear E5.

intro E5; try assumption.
cut (Lub U D (Couple U bsup bsup0) bsup2).
intro H'1; try assumption.
apply Add_distributes; auto with sets.
apply LUaux with (A := Add U A x) (B := Add U A x0); auto with sets.
rewrite <- (Add_distributes U A A x x0); auto with sets.
cut
 (Union U (Add U (Add U A x) x0) (Singleton U x1) =
  Add U (Add U (Add U A x) x0) x1 :>Ensemble U).
intro H'0; rewrite H'0.
rewrite (Add_distributes U (Add U A x) A x0 x1); auto with sets.
unfold Add at 3 in |- *; auto with sets.
Qed.
Hint Resolve Triples_are_enough_finite_case.

Theorem Triples_are_enough :
 (forall x y z : U,
  Consistent U D (Triple U x y z) ->
  ex (fun bsup : U => Lub U D (Triple U x y z) bsup)) -> 
 Coherent U D.
intro H'; red in |- *; simpl in |- *.
intros X H'0 K; try assumption.
cut (Complete U D).
2: exact (Cpo_cond U C).
unfold D at 1 in |- *.
intro H'3; elim H'3; intros H'6 H'7.
elim (H'7 (Lubs_of_finite_parts U C X));
 [ intros bsup0 E0 | apply LFP_directed ]; auto with sets.
exists bsup0; unfold D at 1 in |- *; auto with sets.
intros Y H'1 H'2; try assumption.
change (ex (fun bsup : U => Lub U D Y bsup)) in |- *.
apply Triples_are_enough_finite_case; auto with sets.
apply Consistent_downward_stable with (B := X); auto with sets.
Qed.
End Second_inductive_lemma.

