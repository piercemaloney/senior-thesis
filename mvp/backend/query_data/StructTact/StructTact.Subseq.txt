Require Import Omega.

Require Import List.

Import ListNotations.

Require Import StructTact.StructTactics.
(* StructTact.StructTactics:
Ltac subst_max :=
  repeat match goal with
           | [ H : ?X = _ |- _ ]  => subst X
           | [H : _ = ?X |- _] => subst X
         end.

Ltac inv H := inversion H; subst_max.
Ltac invc H := inv H; clear H.
Ltac invcs H := invc H; simpl in *.

Ltac inv_prop P :=
  match goal with
  | [ H : context[P] |- _] =>
    inv H
  end.

Ltac invc_prop P :=
  match goal with
  | [ H : context[P] |- _] =>
    invc H
  end.

Ltac invcs_prop P :=
  match goal with
  | [ H : context[P] |- _] =>
    invcs H
  end.

Ltac break_if :=
  match goal with
    | [ |- context [ if ?X then _ else _ ] ] =>
      match type of X with
        | sumbool _ _ => destruct X
        | _ => destruct X eqn:?
      end
    | [ H : context [ if ?X then _ else _ ] |- _] =>
      match type of X with
        | sumbool _ _ => destruct X
        | _ => destruct X eqn:?
      end
  end.

Ltac break_match_hyp :=
  match goal with
    | [ H : context [ match ?X with _ => _ end ] |- _] =>
      match type of X with
        | sumbool _ _ => destruct X
        | _ => destruct X eqn:?
      end
  end.

Ltac break_match_goal :=
  match goal with
    | [ |- context [ match ?X with _ => _ end ] ] =>
      match type of X with
        | sumbool _ _ => destruct X
        | _ => destruct X eqn:?
      end
  end.

Ltac break_match := break_match_goal || break_match_hyp.

Ltac break_inner_match' t :=
 match t with
   | context[match ?X with _ => _ end] =>
     break_inner_match' X || destruct X eqn:?
   | _ => destruct t eqn:?
 end.

Ltac break_inner_match_goal :=
 match goal with
   | [ |- context[match ?X with _ => _ end] ] =>
     break_inner_match' X
 end.

Ltac break_inner_match_hyp :=
 match goal with
   | [ H : context[match ?X with _ => _ end] |- _ ] =>
     break_inner_match' X
 end.

Ltac break_inner_match := break_inner_match_goal || break_inner_match_hyp.

Ltac break_exists :=
  repeat match goal with
           | [H : exists _, _ |- _ ] => destruct H
         end.

Ltac break_exists_exists :=
  repeat match goal with
           | H:exists _, _ |- _ =>
             let x := fresh "x" in
             destruct H as [x]; exists x
         end.

Ltac break_and :=
  repeat match goal with
           | [H : _ /\ _ |- _ ] => destruct H
         end.

Ltac break_and_goal :=
    repeat match goal with
             | [ |- _ /\ _ ] => split
           end.

Ltac solve_by_inversion' tac :=
  match goal with
    | [H : _ |- _] => solve [inv H; tac]
  end.

Ltac solve_by_inversion := solve_by_inversion' auto.

Ltac apply_fun f H:=
  match type of H with
    | ?X = ?Y => assert (f X = f Y)
  end.

Ltac conclude H tac :=
  (let H' := fresh in
   match type of H with
     | ?P -> _ => assert P as H' by (tac)
   end; specialize (H H'); clear H').

Ltac concludes :=
  match goal with
    | [ H : ?P -> _ |- _ ] => conclude H auto
  end.

Ltac forward H :=
  let H' := fresh in
   match type of H with
     | ?P -> _ => assert P as H'
   end.

Ltac forwards :=
  match goal with
    | [ H : ?P -> _ |- _ ] => forward H
  end.

Ltac find_elim_prop P :=
  match goal with
  | [ H : context [ P ] |- _ ] =>
    elim H
  end.

Ltac find_eelim_prop P :=
  match goal with
  | [ H : context [ P ] |- _ ] =>
    eelim H
  end.

Ltac find_contradiction :=
  match goal with
    | [ H : ?X = _, H' : ?X = _ |- _ ] => rewrite H in H'; solve_by_inversion
  end.

Ltac find_rewrite :=
  match goal with
    | [ H : ?X _ _ _ _ = _, H' : ?X _ _ _ _ = _ |- _ ] => rewrite H in H'
    | [ H : ?X = _, H' : ?X = _ |- _ ] => rewrite H in H'
    | [ H : ?X = _, H' : context [ ?X ] |- _ ] => rewrite H in H'
    | [ H : ?X = _ |- context [ ?X ] ] => rewrite H
  end.

Ltac find_rewrite_lem lem :=
  match goal with
    | [ H : _ |- _ ] =>
      rewrite lem in H; [idtac]
  end.

Ltac find_rewrite_lem_by lem t :=
  match goal with
    | [ H : _ |- _ ] =>
      rewrite lem in H by t
  end.

Ltac find_erewrite_lem lem :=
  match goal with
    | [ H : _ |- _] => erewrite lem in H by eauto
  end.

Ltac find_reverse_rewrite :=
  match goal with
    | [ H : _ = ?X _ _ _ _, H' : ?X _ _ _ _ = _ |- _ ] => rewrite <- H in H'
    | [ H : _ = ?X, H' : context [ ?X ] |- _ ] => rewrite <- H in H'
    | [ H : _ = ?X |- context [ ?X ] ] => rewrite <- H
  end.

Ltac find_inversion :=
  match goal with
    | [ H : ?X _ _ _ _ _ _ = ?X _ _ _ _ _ _ |- _ ] => invc H
    | [ H : ?X _ _ _ _ _ = ?X _ _ _ _ _ |- _ ] => invc H
    | [ H : ?X _ _ _ _ = ?X _ _ _ _ |- _ ] => invc H
    | [ H : ?X _ _ _ = ?X _ _ _ |- _ ] => invc H
    | [ H : ?X _ _ = ?X _ _ |- _ ] => invc H
    | [ H : ?X _ = ?X _ |- _ ] => invc H
  end.

Ltac prove_eq :=
  match goal with
    | [ H : ?X ?x1 ?x2 ?x3 = ?X ?y1 ?y2 ?y3 |- _ ] =>
      assert (x1 = y1) by congruence;
        assert (x2 = y2) by congruence;
        assert (x3 = y3) by congruence;
        clear H
    | [ H : ?X ?x1 ?x2 = ?X ?y1 ?y2 |- _ ] =>
      assert (x1 = y1) by congruence;
        assert (x2 = y2) by congruence;
        clear H
    | [ H : ?X ?x1 = ?X ?y1 |- _ ] =>
      assert (x1 = y1) by congruence;
        clear H
  end.

Ltac tuple_inversion :=
  match goal with
    | [ H : (_, _, _, _) = (_, _, _, _) |- _ ] => invc H
    | [ H : (_, _, _) = (_, _, _) |- _ ] => invc H
    | [ H : (_, _) = (_, _) |- _ ] => invc H
  end.

Ltac f_apply H f :=
  match type of H with
    | ?X = ?Y =>
      assert (f X = f Y) by (rewrite H; auto)
  end.

Ltac break_let :=
  match goal with
    | [ H : context [ (let (_,_) := ?X in _) ] |- _ ] => destruct X eqn:?
    | [ |- context [ (let (_,_) := ?X in _) ] ] => destruct X eqn:?
  end.

Ltac break_or_hyp :=
  match goal with
    | [ H : _ \/ _ |- _ ] => invc H
  end.

Ltac copy_apply lem H :=
  let x := fresh in
  pose proof H as x;
    apply lem in x.

Ltac copy_eapply lem H :=
  let x := fresh in
  pose proof H as x;
    eapply lem in x.

Ltac conclude_using tac :=
  match goal with
    | [ H : ?P -> _ |- _ ] => conclude H tac
  end.

Ltac find_higher_order_rewrite :=
  match goal with
    | [ H : _ = _ |- _ ] => rewrite H in *
    | [ H : forall _, _ = _ |- _ ] => rewrite H in *
    | [ H : forall _ _, _ = _ |- _ ] => rewrite H in *
  end.

Ltac find_reverse_higher_order_rewrite :=
  match goal with
    | [ H : _ = _ |- _ ] => rewrite <- H in *
    | [ H : forall _, _ = _ |- _ ] => rewrite <- H in *
    | [ H : forall _ _, _ = _ |- _ ] => rewrite <- H in *
  end.

Ltac clean :=
  match goal with
    | [ H : ?X = ?X |- _ ] => clear H
  end.

Ltac find_apply_hyp_goal :=
  match goal with
    | [ H : _ |- _ ] => solve [apply H]
  end.

Ltac find_copy_apply_lem_hyp lem :=
  match goal with
    | [ H : _ |- _ ] => copy_apply lem H
  end.

Ltac find_apply_hyp_hyp :=
  match goal with
    | [ H : forall _, _ -> _,
        H' : _ |- _ ] =>
      apply H in H'; [idtac]
    | [ H : _ -> _ , H' : _ |- _ ] =>
      apply H in H'; auto; [idtac]
  end.

Ltac find_copy_apply_hyp_hyp :=
  match goal with
    | [ H : forall _, _ -> _,
        H' : _ |- _ ] =>
      copy_apply H H'; [idtac]
    | [ H : _ -> _ , H' : _ |- _ ] =>
      copy_apply H H'; auto; [idtac]
  end.

Ltac find_apply_lem_hyp lem :=
  match goal with
    | [ H : _ |- _ ] => apply lem in H
  end.

Ltac find_eapply_lem_hyp lem :=
  match goal with
    | [ H : _ |- _ ] => eapply lem in H
  end.

Ltac insterU H :=
  match type of H with
    | forall _ : ?T, _ =>
      let x := fresh "x" in
      evar (x : T);
      let x' := (eval unfold x in x) in
        clear x; specialize (H x')
  end.

Ltac find_insterU :=
  match goal with
    | [ H : forall _, _ |- _ ] => insterU H
  end.

Ltac eapply_prop P :=
  match goal with
    | H : P _ |- _ =>
      eapply H
  end.

Ltac find_eapply_prop P :=
  match goal with
    | H : context [ P ] |- _ =>
      eapply H
  end.

Ltac isVar t :=
    match goal with
      | v : _ |- _ =>
        match t with
          | v => idtac
        end
    end.

Ltac remGen t :=
  let x := fresh in
  let H := fresh in
  remember t as x eqn:H;
    generalize dependent H.

Ltac remGenIfNotVar t := first [isVar t| remGen t].

Ltac rememberNonVars H :=
  match type of H with
    | _ ?a ?b ?c ?d ?e =>
      remGenIfNotVar a;
      remGenIfNotVar b;
      remGenIfNotVar c;
      remGenIfNotVar d;
      remGenIfNotVar e
    | _ ?a ?b ?c ?d =>
      remGenIfNotVar a;
      remGenIfNotVar b;
      remGenIfNotVar c;
      remGenIfNotVar d
    | _ ?a ?b ?c =>
      remGenIfNotVar a;
      remGenIfNotVar b;
      remGenIfNotVar c
    | _ ?a ?b =>
      remGenIfNotVar a;
      remGenIfNotVar b
    | _ ?a =>
      remGenIfNotVar a
  end.

Ltac generalizeEverythingElse H :=
  repeat match goal with
           | [ x : ?T |- _ ] =>
             first [
                 match H with
                   | x => fail 2
                 end |
                 match type of H with
                   | context [x] => fail 2
                 end |
                 revert x]
         end.

Ltac prep_induction H :=
  rememberNonVars H;
  generalizeEverythingElse H.

Ltac econcludes :=
  match goal with
    | [ H : ?P -> _ |- _ ] => conclude H eauto
  end.

Ltac find_copy_eapply_lem_hyp lem :=
  match goal with
    | [ H : _ |- _ ] => copy_eapply lem H
  end.

Ltac apply_prop_hyp P Q :=
  match goal with
  | [ H : context [ P ], H' : context [ Q ] |- _ ] =>
    apply H in H'
  end.

Ltac eapply_prop_hyp P Q :=
  match goal with
  | [ H : context [ P ], H' : context [ Q ] |- _ ] =>
    eapply H in H'
  end.

Ltac copy_eapply_prop_hyp P Q :=
  match goal with
    | [ H : context [ P ], H' : context [ Q ] |- _ ] =>
      copy_eapply H H'
  end.

Ltac eapply_lem_prop_hyp lem P :=
  match goal with
  | [ H : context [ P ] |- _ ] =>
    eapply lem in H
  end.

Ltac copy_eapply_lem_prop_hyp lem P :=
  match goal with
  | [ H : context [ P ] |- _ ] =>
    copy_eapply lem H
  end.

Ltac find_false :=
  match goal with
    | H : _ -> False |- _ => exfalso; apply H
  end.

Ltac injc H :=
  injection H; clear H; intros; subst_max.

Ltac find_injection :=
  match goal with
    | [ H : ?X _ _ _ _ _ _ = ?X _ _ _ _ _ _ |- _ ] => injc H
    | [ H : ?X _ _ _ _ _ = ?X _ _ _ _ _ |- _ ] => injc H
    | [ H : ?X _ _ _ _ = ?X _ _ _ _ |- _ ] => injc H
    | [ H : ?X _ _ _ = ?X _ _ _ |- _ ] => injc H
    | [ H : ?X _ _ = ?X _ _ |- _ ] => injc H
    | [ H : ?X _ = ?X _ |- _ ] => injc H
  end.

Ltac aggressive_rewrite_goal :=
  match goal with H : _ |- _ => rewrite H end.

Ltac break_exists_name x :=
  match goal with
  | [ H : exists _, _ |- _ ] => destruct H as [x H]
  end. *)

Require Import StructTact.ListTactics.
(* StructTact.ListTactics:
Require Import List.
Require Import StructTact.StructTactics.

Ltac do_in_map :=
  match goal with
    | [ H : In _ (map _ _) |- _ ] => apply in_map_iff in H; break_exists; break_and
  end.

Ltac do_in_app :=
  match goal with
    | [ H : In _ (_ ++ _) |- _ ] => apply in_app_iff in H
  end.

Ltac invc_NoDup :=
  repeat match goal with
  | [ H : NoDup (_ :: _) |- _ ] => invc H
  end.

Ltac map_crush :=
  repeat match goal with
                   | [ H : context [ map _ (_ ++ _) ] |- _ ] => rewrite map_app in H
                   | [ |- context [ map _ (_ ++ _) ] ] => rewrite map_app
                   | [ H : context [ map _ (map _ _) ] |- _ ] => rewrite map_map in H
                   | [ |- context [ map _ (map _ _) ] ] => rewrite map_map
         end; simpl in *.

Ltac in_crush_finish :=
  repeat match goal with
    | [ |- _ \/ _ ] => try first [solve [apply or_introl; in_crush_finish]|
                                 solve [apply or_intror; in_crush_finish]]
    | [ |- In _ (_ ++ _) ] => apply in_or_app; in_crush_finish
    | [ |- In _ (map _ _) ] => apply in_map_iff; eexists; eauto
  end.

Ltac in_crush_start :=
  intuition; simpl in *;
  repeat
    (match goal with
       | [ H : In _ (map _ _) |- _ ] => apply in_map_iff in H; break_exists; break_and
       | [ H : In _ (_ ++ _) |- _ ] => apply in_app_iff in H
     end; intuition; simpl in *); subst.

Ltac in_crush := repeat (in_crush_start; in_crush_finish).

Create HintDb struct_util.

Hint Constructors NoDup : struct_util. *)

Require Import StructTact.FilterMap.
(* StructTact.FilterMap:
Require Import List.
Import ListNotations.
Require Import StructTact.StructTactics.
Require Import StructTact.ListTactics.

Set Implicit Arguments.

Fixpoint filterMap {A B} (f : A -> option B) (l : list A) : list B :=
  match l with
    | [] => []
    | x :: xs => match f x with
                   | None => filterMap f xs
                   | Some y => y :: filterMap f xs
                 end
  end.

Section filter_map.
  Variables A B C : Type.

  Lemma map_of_filterMap :
    forall (f : A -> option B) (g : B -> C) l,
      map g (filterMap f l) = filterMap (fun x => match f x with
                                                 | Some y => Some (g y)
                                                 | None => None
                                                 end) l.

  Lemma filterMap_ext :
    forall (f g : A -> option B) l,
      (forall x, f x = g x) ->
      filterMap f l = filterMap g l.

  Lemma filterMap_defn :
    forall (f : A -> option B) x xs,
      filterMap f (x :: xs) = match f x with
                             | Some y => y :: filterMap f xs
                             | None => filterMap f xs
                             end.

  Lemma In_filterMap :
    forall (f : A -> option B) b xs,
      In b (filterMap f xs) ->
      exists a,
        In a xs /\ f a = Some b.

  Lemma filterMap_app :
    forall (f : A -> option B) xs ys,
      filterMap f (xs ++ ys) = filterMap f xs ++ filterMap f ys.

  Lemma filterMap_In :
    forall A B (f : A -> option B) a b xs,
      f a = Some b ->
      In a xs ->
      In b (filterMap f xs).

  Lemma filterMap_of_filterMap :
    forall (f : B -> option C) (g : A -> option B) xs,
      filterMap f (filterMap g xs) =
      filterMap (fun a => match g a with
                         | Some b => f b
                         | None => None
                         end) xs.

  Lemma filterMap_all_None :
    forall (f : A -> option B) xs,
      (forall x, In x xs -> f x = None) ->
      filterMap f xs = [].

  Lemma filterMap_NoDup_inj :
    forall (f : A -> option B) l,
      (forall x1 x2 y,
          f x1 = Some y ->
          f x2 = Some y ->
          x1 = x2) ->
      NoDup l ->
      NoDup (filterMap f l).
End filter_map. *)

Require Import StructTact.RemoveAll.
(* StructTact.RemoveAll:
Require Import List.
Import ListNotations.
Require Import StructTact.StructTactics.
Require Import StructTact.ListUtil.
Require Import StructTact.ListTactics.
Require Import StructTact.Before.

Set Implicit Arguments.

Section remove_all.
  Variable A : Type.
  Hypothesis A_eq_dec : forall x y : A, {x = y} + {x <> y}.

  Fixpoint remove_all (to_delete l : list A) : list A :=
    match to_delete with
    | [] => l
    | d :: ds => remove_all ds (remove A_eq_dec d l)
    end.

  Lemma in_remove_all_was_in :
    forall ds l x,
      In x (remove_all ds l) ->
      In x l.

  Lemma in_remove_all_preserve :
    forall ds l x,
      ~ In x ds ->
      In x l ->
      In x (remove_all ds l).

  Lemma in_remove_all_not_in :
    forall ds l x,
      In x (remove_all ds l) ->
      In x ds ->
      False.

  Lemma remove_all_nil :
    forall ys,
      remove_all ys [] = [].

  Lemma remove_all_cons :
    forall ys a l,
      (remove_all ys (a :: l) = remove_all ys l /\
       In a ys) \/
      (remove_all ys (a :: l) = a :: (remove_all ys l) /\
       ~In a ys).

  Lemma before_remove_all :
    forall x y l ys,
      before x y (remove_all ys l) ->
      ~ In y ys ->
      before x y l.

  Lemma before_remove_all_if :
    forall x y l xs,
      before x y l ->
      ~ In x xs ->
      before x y (remove_all xs l).

  Lemma NoDup_remove_all :
    forall l l',
    NoDup l' ->
    NoDup (remove_all l l').

  Lemma remove_all_NoDup_split :
    forall l l' l0 l1 a,
     NoDup l' ->
     remove_all l l' = l0 ++ a :: l1 ->
     remove_all l (remove A_eq_dec a l') = l0 ++ l1.

  Lemma remove_all_app_l :
    forall xs ys zs,
      remove_all (xs ++ ys) zs = remove_all xs (remove_all ys zs).

  Lemma remove_all_app_r :
    forall xs ys zs,
      remove_all xs (ys ++ zs) = remove_all xs ys ++ remove_all xs zs.

  Lemma remove_all_del_comm :
    forall xs ys zs,
      remove_all xs (remove_all ys zs) = remove_all ys (remove_all xs zs).

End remove_all.
Arguments in_remove_all_was_in : clear implicits. *)



Set Implicit Arguments.



Fixpoint subseq {A} (xs ys : list A) : Prop :=

  match xs, ys with

    | [], _ => True

    | x :: xs', y :: ys' => (x = y /\ subseq xs' ys') \/ subseq xs ys'

    | _, _ => False

  end.



Section subseq.

  Variable A B : Type.

  Hypothesis A_eq_dec : forall x y : A, {x = y} + {x <> y}.



  Lemma subseq_refl : forall (l : list A), subseq l l.

  Proof using.

    induction l; simpl; tauto.

  Qed.



  Lemma subseq_trans :

    forall (zs xs ys : list A),

      subseq xs ys ->

      subseq ys zs ->

      subseq xs zs.

  Proof using.

    induction zs; intros; simpl in *;

      repeat break_match; subst; simpl in *; intuition; subst; eauto;

        right; (eapply IHzs; [|eauto]); simpl; eauto.

  Qed.



  Lemma subseq_In :

    forall (ys xs : list A) x,

      subseq xs ys ->

      In x xs ->

      In x ys.

  Proof using.

    induction ys; intros.

    - destruct xs; simpl in *; intuition.

    - simpl in *. break_match; simpl in *; intuition; subst; intuition eauto;

                    right; (eapply IHys; [eauto| intuition]).

  Qed.



  Theorem subseq_NoDup :

    forall (ys xs : list A),

      subseq xs ys ->

      NoDup ys ->

      NoDup xs.

  Proof using.

    induction ys; intros.

    - destruct xs; simpl in *; intuition.

    - simpl in *. invc_NoDup.

      break_match.

      + constructor.

      + intuition.

        subst. constructor; eauto using subseq_In.

  Qed.



  Lemma subseq_remove :

    forall (x : A) xs,

      subseq (remove A_eq_dec x xs) xs.

  Proof using.

    induction xs; intros; simpl.

    - auto.

    - repeat break_match; auto.

      + intuition congruence.

      + find_inversion. auto.

  Qed.



  Lemma subseq_map :

    forall (f : A -> B) ys xs,

      subseq xs ys ->

      subseq (map f xs) (map f ys).

  Proof using.

    induction ys; intros; simpl in *.

    - repeat break_match; try discriminate; auto.

    - repeat break_match; try discriminate; auto.

      intuition.

      + subst. simpl in *. find_inversion. auto.

      + right. repeat find_reverse_rewrite. auto.

  Qed.



  Lemma subseq_cons_drop :

    forall xs ys (a : A),

      subseq (a :: xs) ys -> subseq xs ys.

  Proof using.

    induction ys; intros; simpl in *; intuition; break_match; eauto.

  Qed.



  Lemma subseq_length :

    forall (ys xs : list A),

      subseq xs ys ->

      length xs <= length ys.

  Proof using.

    induction ys; intros; simpl in *; break_match; intuition.

    subst. simpl in *. specialize (IHys l). concludes. auto with *.

  Qed.



  Lemma subseq_subseq_eq :

    forall (xs ys : list A),

      subseq xs ys ->

      subseq ys xs ->

      xs = ys.

  Proof using.

    induction xs; intros; destruct ys; simpl in *;

      intuition eauto using f_equal2, subseq_cons_drop.

    exfalso.

    repeat find_apply_lem_hyp subseq_length.

    simpl in *. omega.

  Qed.



  Lemma subseq_filter :

    forall (f : A -> bool) xs,

      subseq (filter f xs) xs.

  Proof using.

    induction xs; intros; simpl.

    - auto.

    - repeat break_match; intuition congruence.

  Qed.



  Lemma subseq_nil :

    forall xs,

      subseq (A:=A) [] xs.

  Proof using.

    destruct xs; simpl; auto.

  Qed.



  Lemma subseq_skip :

    forall a xs ys,

      subseq(A:=A) xs ys ->

      subseq xs (a :: ys).

  Proof using.

    induction ys; intros; simpl in *; repeat break_match; intuition.

  Qed.



  Lemma subseq_filterMap :

    forall (f : B -> option A) ys xs,

      subseq xs ys ->

      subseq (filterMap f xs) (filterMap f ys).

  Proof using.

    induction ys; intros; simpl in *; repeat break_match; auto; try discriminate; intuition; subst.

    - simpl. find_rewrite. auto.

    - auto using subseq_skip.

    - auto using subseq_nil.

    - simpl. find_rewrite. auto.

  Qed.



  Lemma subseq_app_r :

    forall xs ys,

      subseq (A:=A) ys (xs ++ ys).

  Proof using.

    induction xs; intros; simpl.

    + auto using subseq_refl.

    + break_match.

      * auto.

      * right. auto using subseq_nil.

  Qed.



  Lemma subseq_app_tail :

    forall ys xs zs,

      subseq (A:=A) xs ys ->

      subseq (xs ++ zs) (ys ++ zs).

  Proof using.

    induction ys; intros; simpl in *.

    - break_match; intuition auto using subseq_refl.

    - repeat break_match.

      + auto.

      + discriminate.

      + simpl in *. subst. right. auto using subseq_app_r.

      + simpl in *. find_inversion. intuition.

        rewrite app_comm_cons. auto.

  Qed.



  Lemma subseq_app_head :

    forall xs ys zs,

      subseq (A:=A) ys zs ->

      subseq (A:=A) (xs ++ ys) (xs ++ zs).

  Proof using.

    induction xs; intros; simpl; intuition.

  Qed.



  Lemma subseq_2_3 :

    forall xs ys zs x y,

      subseq(A:=A) (xs ++ ys ++ zs) (xs ++ x :: ys ++ y :: zs).

  Proof using.

    auto using subseq_refl, subseq_skip, subseq_app_head.

  Qed.



  Lemma subseq_middle :

    forall xs y zs,

      subseq (A:=A) (xs ++ zs) (xs ++ y :: zs).

  Proof using.

    intros.

    apply subseq_app_head.

    apply subseq_skip.

    apply subseq_refl.

  Qed.



  Lemma subseq_remove_all :

    forall (ds l l' : list A),

      subseq l l' ->

      subseq (remove_all A_eq_dec ds l) l'.

  Proof using.

    induction ds; intros; simpl.

    - auto.

    - apply IHds.

      eapply subseq_trans.

      apply subseq_remove.

      auto.

  Qed.

End subseq.

