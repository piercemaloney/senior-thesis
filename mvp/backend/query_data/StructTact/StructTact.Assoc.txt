Require Import List.

Import ListNotations.

Require Import StructTact.StructTactics.
(* StructTact.StructTactics:
Ltac subst_max :=
  repeat match goal with
           | [ H : ?X = _ |- _ ]  => subst X
           | [H : _ = ?X |- _] => subst X
         end.

Ltac inv H := inversion H; subst_max.
Ltac invc H := inv H; clear H.
Ltac invcs H := invc H; simpl in *.

Ltac inv_prop P :=
  match goal with
  | [ H : context[P] |- _] =>
    inv H
  end.

Ltac invc_prop P :=
  match goal with
  | [ H : context[P] |- _] =>
    invc H
  end.

Ltac invcs_prop P :=
  match goal with
  | [ H : context[P] |- _] =>
    invcs H
  end.

Ltac break_if :=
  match goal with
    | [ |- context [ if ?X then _ else _ ] ] =>
      match type of X with
        | sumbool _ _ => destruct X
        | _ => destruct X eqn:?
      end
    | [ H : context [ if ?X then _ else _ ] |- _] =>
      match type of X with
        | sumbool _ _ => destruct X
        | _ => destruct X eqn:?
      end
  end.

Ltac break_match_hyp :=
  match goal with
    | [ H : context [ match ?X with _ => _ end ] |- _] =>
      match type of X with
        | sumbool _ _ => destruct X
        | _ => destruct X eqn:?
      end
  end.

Ltac break_match_goal :=
  match goal with
    | [ |- context [ match ?X with _ => _ end ] ] =>
      match type of X with
        | sumbool _ _ => destruct X
        | _ => destruct X eqn:?
      end
  end.

Ltac break_match := break_match_goal || break_match_hyp.

Ltac break_inner_match' t :=
 match t with
   | context[match ?X with _ => _ end] =>
     break_inner_match' X || destruct X eqn:?
   | _ => destruct t eqn:?
 end.

Ltac break_inner_match_goal :=
 match goal with
   | [ |- context[match ?X with _ => _ end] ] =>
     break_inner_match' X
 end.

Ltac break_inner_match_hyp :=
 match goal with
   | [ H : context[match ?X with _ => _ end] |- _ ] =>
     break_inner_match' X
 end.

Ltac break_inner_match := break_inner_match_goal || break_inner_match_hyp.

Ltac break_exists :=
  repeat match goal with
           | [H : exists _, _ |- _ ] => destruct H
         end.

Ltac break_exists_exists :=
  repeat match goal with
           | H:exists _, _ |- _ =>
             let x := fresh "x" in
             destruct H as [x]; exists x
         end.

Ltac break_and :=
  repeat match goal with
           | [H : _ /\ _ |- _ ] => destruct H
         end.

Ltac break_and_goal :=
    repeat match goal with
             | [ |- _ /\ _ ] => split
           end.

Ltac solve_by_inversion' tac :=
  match goal with
    | [H : _ |- _] => solve [inv H; tac]
  end.

Ltac solve_by_inversion := solve_by_inversion' auto.

Ltac apply_fun f H:=
  match type of H with
    | ?X = ?Y => assert (f X = f Y)
  end.

Ltac conclude H tac :=
  (let H' := fresh in
   match type of H with
     | ?P -> _ => assert P as H' by (tac)
   end; specialize (H H'); clear H').

Ltac concludes :=
  match goal with
    | [ H : ?P -> _ |- _ ] => conclude H auto
  end.

Ltac forward H :=
  let H' := fresh in
   match type of H with
     | ?P -> _ => assert P as H'
   end.

Ltac forwards :=
  match goal with
    | [ H : ?P -> _ |- _ ] => forward H
  end.

Ltac find_elim_prop P :=
  match goal with
  | [ H : context [ P ] |- _ ] =>
    elim H
  end.

Ltac find_eelim_prop P :=
  match goal with
  | [ H : context [ P ] |- _ ] =>
    eelim H
  end.

Ltac find_contradiction :=
  match goal with
    | [ H : ?X = _, H' : ?X = _ |- _ ] => rewrite H in H'; solve_by_inversion
  end.

Ltac find_rewrite :=
  match goal with
    | [ H : ?X _ _ _ _ = _, H' : ?X _ _ _ _ = _ |- _ ] => rewrite H in H'
    | [ H : ?X = _, H' : ?X = _ |- _ ] => rewrite H in H'
    | [ H : ?X = _, H' : context [ ?X ] |- _ ] => rewrite H in H'
    | [ H : ?X = _ |- context [ ?X ] ] => rewrite H
  end.

Ltac find_rewrite_lem lem :=
  match goal with
    | [ H : _ |- _ ] =>
      rewrite lem in H; [idtac]
  end.

Ltac find_rewrite_lem_by lem t :=
  match goal with
    | [ H : _ |- _ ] =>
      rewrite lem in H by t
  end.

Ltac find_erewrite_lem lem :=
  match goal with
    | [ H : _ |- _] => erewrite lem in H by eauto
  end.

Ltac find_reverse_rewrite :=
  match goal with
    | [ H : _ = ?X _ _ _ _, H' : ?X _ _ _ _ = _ |- _ ] => rewrite <- H in H'
    | [ H : _ = ?X, H' : context [ ?X ] |- _ ] => rewrite <- H in H'
    | [ H : _ = ?X |- context [ ?X ] ] => rewrite <- H
  end.

Ltac find_inversion :=
  match goal with
    | [ H : ?X _ _ _ _ _ _ = ?X _ _ _ _ _ _ |- _ ] => invc H
    | [ H : ?X _ _ _ _ _ = ?X _ _ _ _ _ |- _ ] => invc H
    | [ H : ?X _ _ _ _ = ?X _ _ _ _ |- _ ] => invc H
    | [ H : ?X _ _ _ = ?X _ _ _ |- _ ] => invc H
    | [ H : ?X _ _ = ?X _ _ |- _ ] => invc H
    | [ H : ?X _ = ?X _ |- _ ] => invc H
  end.

Ltac prove_eq :=
  match goal with
    | [ H : ?X ?x1 ?x2 ?x3 = ?X ?y1 ?y2 ?y3 |- _ ] =>
      assert (x1 = y1) by congruence;
        assert (x2 = y2) by congruence;
        assert (x3 = y3) by congruence;
        clear H
    | [ H : ?X ?x1 ?x2 = ?X ?y1 ?y2 |- _ ] =>
      assert (x1 = y1) by congruence;
        assert (x2 = y2) by congruence;
        clear H
    | [ H : ?X ?x1 = ?X ?y1 |- _ ] =>
      assert (x1 = y1) by congruence;
        clear H
  end.

Ltac tuple_inversion :=
  match goal with
    | [ H : (_, _, _, _) = (_, _, _, _) |- _ ] => invc H
    | [ H : (_, _, _) = (_, _, _) |- _ ] => invc H
    | [ H : (_, _) = (_, _) |- _ ] => invc H
  end.

Ltac f_apply H f :=
  match type of H with
    | ?X = ?Y =>
      assert (f X = f Y) by (rewrite H; auto)
  end.

Ltac break_let :=
  match goal with
    | [ H : context [ (let (_,_) := ?X in _) ] |- _ ] => destruct X eqn:?
    | [ |- context [ (let (_,_) := ?X in _) ] ] => destruct X eqn:?
  end.

Ltac break_or_hyp :=
  match goal with
    | [ H : _ \/ _ |- _ ] => invc H
  end.

Ltac copy_apply lem H :=
  let x := fresh in
  pose proof H as x;
    apply lem in x.

Ltac copy_eapply lem H :=
  let x := fresh in
  pose proof H as x;
    eapply lem in x.

Ltac conclude_using tac :=
  match goal with
    | [ H : ?P -> _ |- _ ] => conclude H tac
  end.

Ltac find_higher_order_rewrite :=
  match goal with
    | [ H : _ = _ |- _ ] => rewrite H in *
    | [ H : forall _, _ = _ |- _ ] => rewrite H in *
    | [ H : forall _ _, _ = _ |- _ ] => rewrite H in *
  end.

Ltac find_reverse_higher_order_rewrite :=
  match goal with
    | [ H : _ = _ |- _ ] => rewrite <- H in *
    | [ H : forall _, _ = _ |- _ ] => rewrite <- H in *
    | [ H : forall _ _, _ = _ |- _ ] => rewrite <- H in *
  end.

Ltac clean :=
  match goal with
    | [ H : ?X = ?X |- _ ] => clear H
  end.

Ltac find_apply_hyp_goal :=
  match goal with
    | [ H : _ |- _ ] => solve [apply H]
  end.

Ltac find_copy_apply_lem_hyp lem :=
  match goal with
    | [ H : _ |- _ ] => copy_apply lem H
  end.

Ltac find_apply_hyp_hyp :=
  match goal with
    | [ H : forall _, _ -> _,
        H' : _ |- _ ] =>
      apply H in H'; [idtac]
    | [ H : _ -> _ , H' : _ |- _ ] =>
      apply H in H'; auto; [idtac]
  end.

Ltac find_copy_apply_hyp_hyp :=
  match goal with
    | [ H : forall _, _ -> _,
        H' : _ |- _ ] =>
      copy_apply H H'; [idtac]
    | [ H : _ -> _ , H' : _ |- _ ] =>
      copy_apply H H'; auto; [idtac]
  end.

Ltac find_apply_lem_hyp lem :=
  match goal with
    | [ H : _ |- _ ] => apply lem in H
  end.

Ltac find_eapply_lem_hyp lem :=
  match goal with
    | [ H : _ |- _ ] => eapply lem in H
  end.

Ltac insterU H :=
  match type of H with
    | forall _ : ?T, _ =>
      let x := fresh "x" in
      evar (x : T);
      let x' := (eval unfold x in x) in
        clear x; specialize (H x')
  end.

Ltac find_insterU :=
  match goal with
    | [ H : forall _, _ |- _ ] => insterU H
  end.

Ltac eapply_prop P :=
  match goal with
    | H : P _ |- _ =>
      eapply H
  end.

Ltac find_eapply_prop P :=
  match goal with
    | H : context [ P ] |- _ =>
      eapply H
  end.

Ltac isVar t :=
    match goal with
      | v : _ |- _ =>
        match t with
          | v => idtac
        end
    end.

Ltac remGen t :=
  let x := fresh in
  let H := fresh in
  remember t as x eqn:H;
    generalize dependent H.

Ltac remGenIfNotVar t := first [isVar t| remGen t].

Ltac rememberNonVars H :=
  match type of H with
    | _ ?a ?b ?c ?d ?e =>
      remGenIfNotVar a;
      remGenIfNotVar b;
      remGenIfNotVar c;
      remGenIfNotVar d;
      remGenIfNotVar e
    | _ ?a ?b ?c ?d =>
      remGenIfNotVar a;
      remGenIfNotVar b;
      remGenIfNotVar c;
      remGenIfNotVar d
    | _ ?a ?b ?c =>
      remGenIfNotVar a;
      remGenIfNotVar b;
      remGenIfNotVar c
    | _ ?a ?b =>
      remGenIfNotVar a;
      remGenIfNotVar b
    | _ ?a =>
      remGenIfNotVar a
  end.

Ltac generalizeEverythingElse H :=
  repeat match goal with
           | [ x : ?T |- _ ] =>
             first [
                 match H with
                   | x => fail 2
                 end |
                 match type of H with
                   | context [x] => fail 2
                 end |
                 revert x]
         end.

Ltac prep_induction H :=
  rememberNonVars H;
  generalizeEverythingElse H.

Ltac econcludes :=
  match goal with
    | [ H : ?P -> _ |- _ ] => conclude H eauto
  end.

Ltac find_copy_eapply_lem_hyp lem :=
  match goal with
    | [ H : _ |- _ ] => copy_eapply lem H
  end.

Ltac apply_prop_hyp P Q :=
  match goal with
  | [ H : context [ P ], H' : context [ Q ] |- _ ] =>
    apply H in H'
  end.

Ltac eapply_prop_hyp P Q :=
  match goal with
  | [ H : context [ P ], H' : context [ Q ] |- _ ] =>
    eapply H in H'
  end.

Ltac copy_eapply_prop_hyp P Q :=
  match goal with
    | [ H : context [ P ], H' : context [ Q ] |- _ ] =>
      copy_eapply H H'
  end.

Ltac eapply_lem_prop_hyp lem P :=
  match goal with
  | [ H : context [ P ] |- _ ] =>
    eapply lem in H
  end.

Ltac copy_eapply_lem_prop_hyp lem P :=
  match goal with
  | [ H : context [ P ] |- _ ] =>
    copy_eapply lem H
  end.

Ltac find_false :=
  match goal with
    | H : _ -> False |- _ => exfalso; apply H
  end.

Ltac injc H :=
  injection H; clear H; intros; subst_max.

Ltac find_injection :=
  match goal with
    | [ H : ?X _ _ _ _ _ _ = ?X _ _ _ _ _ _ |- _ ] => injc H
    | [ H : ?X _ _ _ _ _ = ?X _ _ _ _ _ |- _ ] => injc H
    | [ H : ?X _ _ _ _ = ?X _ _ _ _ |- _ ] => injc H
    | [ H : ?X _ _ _ = ?X _ _ _ |- _ ] => injc H
    | [ H : ?X _ _ = ?X _ _ |- _ ] => injc H
    | [ H : ?X _ = ?X _ |- _ ] => injc H
  end.

Ltac aggressive_rewrite_goal :=
  match goal with H : _ |- _ => rewrite H end.

Ltac break_exists_name x :=
  match goal with
  | [ H : exists _, _ |- _ ] => destruct H as [x H]
  end. *)



Set Implicit Arguments.



Section assoc.

  Variable K V : Type.

  Variable K_eq_dec : forall k k' : K, {k = k'} + {k <> k'}.



  Fixpoint assoc (l : list (K * V)) (k : K) : option V :=

    match l with

      | [] => None

      | (k', v) :: l' =>

        if K_eq_dec k k' then

          Some v

        else

          assoc l' k

    end.



  Definition assoc_default (l : list (K * V)) (k : K) (default : V) : V :=

    match (assoc l k) with

      | Some x => x

      | None => default

    end.



  Fixpoint assoc_set (l : list (K * V)) (k : K) (v : V) : list (K * V) :=

    match l with

      | [] => [(k, v)]

      | (k', v') :: l' =>

        if K_eq_dec k k' then

          (k, v) :: l'

        else

          (k', v') :: (assoc_set l' k v)

    end.



  Fixpoint assoc_del (l : list (K * V)) (k : K) : list (K * V) :=

    match l with

      | [] => []

      | (k', v') :: l' =>

        if K_eq_dec k k' then

          assoc_del l' k

        else

          (k', v') :: (assoc_del l' k)

    end.



  Lemma get_set_same :

    forall k v l,

      assoc (assoc_set l k v) k = Some v.

  Proof using.

    induction l; intros; simpl; repeat (break_match; simpl); subst; congruence.

  Qed.



  Lemma get_set_same' :

    forall k k' v l,

      k = k' ->

      assoc (assoc_set l k v) k' = Some v.

  Proof using.

    intros. subst. auto using get_set_same.

  Qed.



  Lemma get_set_diff :

    forall k k' v l,

      k <> k' ->

      assoc (assoc_set l k v) k' = assoc l k'.

  Proof using.

    induction l; intros; simpl; repeat (break_match; simpl); subst; try congruence; auto.

  Qed.



  Lemma not_in_assoc :

    forall k l,

      ~ In k (map (@fst _ _) l) ->

      assoc l k = None.

  Proof using.

    intros.

    induction l.

    - auto.

    - simpl in *. repeat break_match; intuition.

      subst. simpl in *. congruence.

  Qed.



  Lemma get_del_same :

    forall k l,

      assoc (assoc_del l k) k = None.

  Proof using.

    induction l; intros; simpl in *.

    - auto.

    - repeat break_match; subst; simpl in *; auto.

      break_if; try congruence.

  Qed.



  Lemma get_del_diff :

    forall k k' l,

      k <> k' ->

      assoc (assoc_del l k') k = assoc l k.

  Proof using.

    induction l; intros; simpl in *.

    - auto.

    - repeat (break_match; simpl); subst; try congruence; auto.

  Qed.



  Lemma get_set_diff_default :

    forall (k k' : K) (v : V) l d,

      k <> k' ->

      assoc_default (assoc_set l k v) k' d = assoc_default l k' d.

  Proof using.

    unfold assoc_default.

    intros.

    repeat break_match; auto;

    rewrite get_set_diff in * by auto; congruence.

  Qed.



  Lemma get_set_same_default :

    forall (k : K) (v : V) l d,

      assoc_default (assoc_set l k v) k d = v.

  Proof using.

    unfold assoc_default.

    intros.

    repeat break_match; auto;

    rewrite get_set_same in *; congruence.

  Qed.



  Lemma assoc_assoc_default:

    forall l k (v : V) d,

      assoc l k = Some v ->

      assoc_default l k d = v.

  Proof using.

    intros. unfold assoc_default.

    break_match; congruence.

  Qed.



  Lemma assoc_assoc_default_missing:

    forall (l : list (K * V)) k d,

      assoc l k = None ->

      assoc_default l k d = d.

  Proof using.

    intros. unfold assoc_default.

    break_match; congruence.

  Qed.



  Lemma assoc_set_same :

    forall (l : list (K * V)) k v,

      assoc l k = Some v ->

      assoc_set l k v = l.

  Proof using.

    intros. induction l; simpl in *; auto; try congruence.

    repeat break_match; simpl in *; intuition.

    - subst. find_inversion. auto.

    - repeat find_rewrite. auto.

  Qed.



  Lemma assoc_default_assoc_set :

    forall l (k : K) (v : V) d,

      assoc_default (assoc_set l k v) k d = v.

  Proof using.

    intros. unfold assoc_default.

    rewrite get_set_same. auto.

  Qed.



  Lemma assoc_set_assoc_set_same :

    forall l (k : K) (v : V) v',

      assoc_set (assoc_set l k v) k v' = assoc_set l k v'.

  Proof using.

    induction l; intros; simpl in *; repeat break_match; simpl in *; subst; try congruence; eauto;

break_if; congruence.

  Qed.



  Definition a_equiv (l1 : list (K * V)) l2 :=

    forall k,

      assoc l1 k = assoc l2 k.



  Lemma a_equiv_refl :

    forall l,

      a_equiv l l.

  Proof using.

    intros. unfold a_equiv. auto.

  Qed.



  Lemma a_equiv_sym :

    forall l l',

      a_equiv l l' ->

      a_equiv l' l.

  Proof using.

    unfold a_equiv. intros. auto.

  Qed.



  Lemma a_equiv_trans :

    forall l l' l'',

      a_equiv l l' ->

      a_equiv l' l'' ->

      a_equiv l l''.

  Proof using.

    unfold a_equiv in *.

    intros. repeat find_higher_order_rewrite.

    auto.

  Qed.



  Ltac assoc_destruct :=

    match goal with

    | [ |- context [assoc (assoc_set _ ?k0' _) ?k0 ] ] =>

      destruct (K_eq_dec k0 k0'); [subst k0'; rewrite get_set_same with (k := k0)|

                                   rewrite get_set_diff with (k' := k0) by auto]

    end.



  Ltac assoc_rewrite :=

    match goal with

    | [  |- context [assoc (assoc_set _ ?k0' _) ?k0 ] ] =>

      first [rewrite get_set_same with (k := k0) by auto |

             rewrite get_set_diff with (k' := k0) by auto ]

    end.



  Lemma assoc_set_assoc_set_diff :

    forall l (k : K) (v : V) k' v',

      k <> k' ->

      a_equiv (assoc_set (assoc_set l k v) k' v')

              (assoc_set (assoc_set l k' v') k v).

  Proof using.

    unfold a_equiv.

    intros.

    assoc_destruct.

    - now repeat assoc_rewrite.

    - assoc_destruct.

      + now repeat assoc_rewrite.

      + now repeat assoc_rewrite.

  Qed.



  Lemma a_equiv_nil :

    forall l,

      a_equiv l [] ->

      l = [].

  Proof using.

    intros.

    destruct l; auto.

    unfold a_equiv in *. simpl in *.

    destruct p.

    specialize (H k).

    break_if; try congruence.

  Qed.



  Lemma assoc_set_a_equiv :

    forall l l' (k : K) (v : V),

      a_equiv l l' ->

      a_equiv (assoc_set l k v) (assoc_set l' k v).

  Proof using.

    unfold a_equiv.

    intros.

    assoc_destruct; assoc_rewrite; auto.

  Qed.



  Lemma assoc_default_a_equiv :

    forall l l' (k : K) (v : V),

      a_equiv l l' ->

      assoc_default l k v = assoc_default l' k v.

  Proof using.

    intros. unfold a_equiv, assoc_default in *.

    find_higher_order_rewrite.

    auto.

  Qed.



  Lemma assoc_a_equiv :

    forall l l' (k : K),

      a_equiv l l' ->

      assoc l k = assoc l' k.

  Proof using.

    unfold a_equiv.

    auto.

  Qed.



  Lemma assoc_default_assoc_set_diff :

    forall (l : list (K * V)) k v k' d,

      k <> k' ->

      assoc_default (assoc_set l k' v) k d =

      assoc_default l k d.

  Proof using.

    intros. unfold assoc_default. rewrite get_set_diff; auto.

  Qed.

End assoc.

Arguments a_equiv {_} {_} _ _ _.

