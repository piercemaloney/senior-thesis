Require Import String.

Require Import Ascii.

Require Import Arith.

Require Import OrderedType.

Require Import OrderedTypeEx.



Require Import StructTact.StructTactics.
(* StructTact.StructTactics:
Ltac subst_max :=
  repeat match goal with
           | [ H : ?X = _ |- _ ]  => subst X
           | [H : _ = ?X |- _] => subst X
         end.

Ltac inv H := inversion H; subst_max.
Ltac invc H := inv H; clear H.
Ltac invcs H := invc H; simpl in *.

Ltac inv_prop P :=
  match goal with
  | [ H : context[P] |- _] =>
    inv H
  end.

Ltac invc_prop P :=
  match goal with
  | [ H : context[P] |- _] =>
    invc H
  end.

Ltac invcs_prop P :=
  match goal with
  | [ H : context[P] |- _] =>
    invcs H
  end.

Ltac break_if :=
  match goal with
    | [ |- context [ if ?X then _ else _ ] ] =>
      match type of X with
        | sumbool _ _ => destruct X
        | _ => destruct X eqn:?
      end
    | [ H : context [ if ?X then _ else _ ] |- _] =>
      match type of X with
        | sumbool _ _ => destruct X
        | _ => destruct X eqn:?
      end
  end.

Ltac break_match_hyp :=
  match goal with
    | [ H : context [ match ?X with _ => _ end ] |- _] =>
      match type of X with
        | sumbool _ _ => destruct X
        | _ => destruct X eqn:?
      end
  end.

Ltac break_match_goal :=
  match goal with
    | [ |- context [ match ?X with _ => _ end ] ] =>
      match type of X with
        | sumbool _ _ => destruct X
        | _ => destruct X eqn:?
      end
  end.

Ltac break_match := break_match_goal || break_match_hyp.

Ltac break_inner_match' t :=
 match t with
   | context[match ?X with _ => _ end] =>
     break_inner_match' X || destruct X eqn:?
   | _ => destruct t eqn:?
 end.

Ltac break_inner_match_goal :=
 match goal with
   | [ |- context[match ?X with _ => _ end] ] =>
     break_inner_match' X
 end.

Ltac break_inner_match_hyp :=
 match goal with
   | [ H : context[match ?X with _ => _ end] |- _ ] =>
     break_inner_match' X
 end.

Ltac break_inner_match := break_inner_match_goal || break_inner_match_hyp.

Ltac break_exists :=
  repeat match goal with
           | [H : exists _, _ |- _ ] => destruct H
         end.

Ltac break_exists_exists :=
  repeat match goal with
           | H:exists _, _ |- _ =>
             let x := fresh "x" in
             destruct H as [x]; exists x
         end.

Ltac break_and :=
  repeat match goal with
           | [H : _ /\ _ |- _ ] => destruct H
         end.

Ltac break_and_goal :=
    repeat match goal with
             | [ |- _ /\ _ ] => split
           end.

Ltac solve_by_inversion' tac :=
  match goal with
    | [H : _ |- _] => solve [inv H; tac]
  end.

Ltac solve_by_inversion := solve_by_inversion' auto.

Ltac apply_fun f H:=
  match type of H with
    | ?X = ?Y => assert (f X = f Y)
  end.

Ltac conclude H tac :=
  (let H' := fresh in
   match type of H with
     | ?P -> _ => assert P as H' by (tac)
   end; specialize (H H'); clear H').

Ltac concludes :=
  match goal with
    | [ H : ?P -> _ |- _ ] => conclude H auto
  end.

Ltac forward H :=
  let H' := fresh in
   match type of H with
     | ?P -> _ => assert P as H'
   end.

Ltac forwards :=
  match goal with
    | [ H : ?P -> _ |- _ ] => forward H
  end.

Ltac find_elim_prop P :=
  match goal with
  | [ H : context [ P ] |- _ ] =>
    elim H
  end.

Ltac find_eelim_prop P :=
  match goal with
  | [ H : context [ P ] |- _ ] =>
    eelim H
  end.

Ltac find_contradiction :=
  match goal with
    | [ H : ?X = _, H' : ?X = _ |- _ ] => rewrite H in H'; solve_by_inversion
  end.

Ltac find_rewrite :=
  match goal with
    | [ H : ?X _ _ _ _ = _, H' : ?X _ _ _ _ = _ |- _ ] => rewrite H in H'
    | [ H : ?X = _, H' : ?X = _ |- _ ] => rewrite H in H'
    | [ H : ?X = _, H' : context [ ?X ] |- _ ] => rewrite H in H'
    | [ H : ?X = _ |- context [ ?X ] ] => rewrite H
  end.

Ltac find_rewrite_lem lem :=
  match goal with
    | [ H : _ |- _ ] =>
      rewrite lem in H; [idtac]
  end.

Ltac find_rewrite_lem_by lem t :=
  match goal with
    | [ H : _ |- _ ] =>
      rewrite lem in H by t
  end.

Ltac find_erewrite_lem lem :=
  match goal with
    | [ H : _ |- _] => erewrite lem in H by eauto
  end.

Ltac find_reverse_rewrite :=
  match goal with
    | [ H : _ = ?X _ _ _ _, H' : ?X _ _ _ _ = _ |- _ ] => rewrite <- H in H'
    | [ H : _ = ?X, H' : context [ ?X ] |- _ ] => rewrite <- H in H'
    | [ H : _ = ?X |- context [ ?X ] ] => rewrite <- H
  end.

Ltac find_inversion :=
  match goal with
    | [ H : ?X _ _ _ _ _ _ = ?X _ _ _ _ _ _ |- _ ] => invc H
    | [ H : ?X _ _ _ _ _ = ?X _ _ _ _ _ |- _ ] => invc H
    | [ H : ?X _ _ _ _ = ?X _ _ _ _ |- _ ] => invc H
    | [ H : ?X _ _ _ = ?X _ _ _ |- _ ] => invc H
    | [ H : ?X _ _ = ?X _ _ |- _ ] => invc H
    | [ H : ?X _ = ?X _ |- _ ] => invc H
  end.

Ltac prove_eq :=
  match goal with
    | [ H : ?X ?x1 ?x2 ?x3 = ?X ?y1 ?y2 ?y3 |- _ ] =>
      assert (x1 = y1) by congruence;
        assert (x2 = y2) by congruence;
        assert (x3 = y3) by congruence;
        clear H
    | [ H : ?X ?x1 ?x2 = ?X ?y1 ?y2 |- _ ] =>
      assert (x1 = y1) by congruence;
        assert (x2 = y2) by congruence;
        clear H
    | [ H : ?X ?x1 = ?X ?y1 |- _ ] =>
      assert (x1 = y1) by congruence;
        clear H
  end.

Ltac tuple_inversion :=
  match goal with
    | [ H : (_, _, _, _) = (_, _, _, _) |- _ ] => invc H
    | [ H : (_, _, _) = (_, _, _) |- _ ] => invc H
    | [ H : (_, _) = (_, _) |- _ ] => invc H
  end.

Ltac f_apply H f :=
  match type of H with
    | ?X = ?Y =>
      assert (f X = f Y) by (rewrite H; auto)
  end.

Ltac break_let :=
  match goal with
    | [ H : context [ (let (_,_) := ?X in _) ] |- _ ] => destruct X eqn:?
    | [ |- context [ (let (_,_) := ?X in _) ] ] => destruct X eqn:?
  end.

Ltac break_or_hyp :=
  match goal with
    | [ H : _ \/ _ |- _ ] => invc H
  end.

Ltac copy_apply lem H :=
  let x := fresh in
  pose proof H as x;
    apply lem in x.

Ltac copy_eapply lem H :=
  let x := fresh in
  pose proof H as x;
    eapply lem in x.

Ltac conclude_using tac :=
  match goal with
    | [ H : ?P -> _ |- _ ] => conclude H tac
  end.

Ltac find_higher_order_rewrite :=
  match goal with
    | [ H : _ = _ |- _ ] => rewrite H in *
    | [ H : forall _, _ = _ |- _ ] => rewrite H in *
    | [ H : forall _ _, _ = _ |- _ ] => rewrite H in *
  end.

Ltac find_reverse_higher_order_rewrite :=
  match goal with
    | [ H : _ = _ |- _ ] => rewrite <- H in *
    | [ H : forall _, _ = _ |- _ ] => rewrite <- H in *
    | [ H : forall _ _, _ = _ |- _ ] => rewrite <- H in *
  end.

Ltac clean :=
  match goal with
    | [ H : ?X = ?X |- _ ] => clear H
  end.

Ltac find_apply_hyp_goal :=
  match goal with
    | [ H : _ |- _ ] => solve [apply H]
  end.

Ltac find_copy_apply_lem_hyp lem :=
  match goal with
    | [ H : _ |- _ ] => copy_apply lem H
  end.

Ltac find_apply_hyp_hyp :=
  match goal with
    | [ H : forall _, _ -> _,
        H' : _ |- _ ] =>
      apply H in H'; [idtac]
    | [ H : _ -> _ , H' : _ |- _ ] =>
      apply H in H'; auto; [idtac]
  end.

Ltac find_copy_apply_hyp_hyp :=
  match goal with
    | [ H : forall _, _ -> _,
        H' : _ |- _ ] =>
      copy_apply H H'; [idtac]
    | [ H : _ -> _ , H' : _ |- _ ] =>
      copy_apply H H'; auto; [idtac]
  end.

Ltac find_apply_lem_hyp lem :=
  match goal with
    | [ H : _ |- _ ] => apply lem in H
  end.

Ltac find_eapply_lem_hyp lem :=
  match goal with
    | [ H : _ |- _ ] => eapply lem in H
  end.

Ltac insterU H :=
  match type of H with
    | forall _ : ?T, _ =>
      let x := fresh "x" in
      evar (x : T);
      let x' := (eval unfold x in x) in
        clear x; specialize (H x')
  end.

Ltac find_insterU :=
  match goal with
    | [ H : forall _, _ |- _ ] => insterU H
  end.

Ltac eapply_prop P :=
  match goal with
    | H : P _ |- _ =>
      eapply H
  end.

Ltac find_eapply_prop P :=
  match goal with
    | H : context [ P ] |- _ =>
      eapply H
  end.

Ltac isVar t :=
    match goal with
      | v : _ |- _ =>
        match t with
          | v => idtac
        end
    end.

Ltac remGen t :=
  let x := fresh in
  let H := fresh in
  remember t as x eqn:H;
    generalize dependent H.

Ltac remGenIfNotVar t := first [isVar t| remGen t].

Ltac rememberNonVars H :=
  match type of H with
    | _ ?a ?b ?c ?d ?e =>
      remGenIfNotVar a;
      remGenIfNotVar b;
      remGenIfNotVar c;
      remGenIfNotVar d;
      remGenIfNotVar e
    | _ ?a ?b ?c ?d =>
      remGenIfNotVar a;
      remGenIfNotVar b;
      remGenIfNotVar c;
      remGenIfNotVar d
    | _ ?a ?b ?c =>
      remGenIfNotVar a;
      remGenIfNotVar b;
      remGenIfNotVar c
    | _ ?a ?b =>
      remGenIfNotVar a;
      remGenIfNotVar b
    | _ ?a =>
      remGenIfNotVar a
  end.

Ltac generalizeEverythingElse H :=
  repeat match goal with
           | [ x : ?T |- _ ] =>
             first [
                 match H with
                   | x => fail 2
                 end |
                 match type of H with
                   | context [x] => fail 2
                 end |
                 revert x]
         end.

Ltac prep_induction H :=
  rememberNonVars H;
  generalizeEverythingElse H.

Ltac econcludes :=
  match goal with
    | [ H : ?P -> _ |- _ ] => conclude H eauto
  end.

Ltac find_copy_eapply_lem_hyp lem :=
  match goal with
    | [ H : _ |- _ ] => copy_eapply lem H
  end.

Ltac apply_prop_hyp P Q :=
  match goal with
  | [ H : context [ P ], H' : context [ Q ] |- _ ] =>
    apply H in H'
  end.

Ltac eapply_prop_hyp P Q :=
  match goal with
  | [ H : context [ P ], H' : context [ Q ] |- _ ] =>
    eapply H in H'
  end.

Ltac copy_eapply_prop_hyp P Q :=
  match goal with
    | [ H : context [ P ], H' : context [ Q ] |- _ ] =>
      copy_eapply H H'
  end.

Ltac eapply_lem_prop_hyp lem P :=
  match goal with
  | [ H : context [ P ] |- _ ] =>
    eapply lem in H
  end.

Ltac copy_eapply_lem_prop_hyp lem P :=
  match goal with
  | [ H : context [ P ] |- _ ] =>
    copy_eapply lem H
  end.

Ltac find_false :=
  match goal with
    | H : _ -> False |- _ => exfalso; apply H
  end.

Ltac injc H :=
  injection H; clear H; intros; subst_max.

Ltac find_injection :=
  match goal with
    | [ H : ?X _ _ _ _ _ _ = ?X _ _ _ _ _ _ |- _ ] => injc H
    | [ H : ?X _ _ _ _ _ = ?X _ _ _ _ _ |- _ ] => injc H
    | [ H : ?X _ _ _ _ = ?X _ _ _ _ |- _ ] => injc H
    | [ H : ?X _ _ _ = ?X _ _ _ |- _ ] => injc H
    | [ H : ?X _ _ = ?X _ _ |- _ ] => injc H
    | [ H : ?X _ = ?X _ |- _ ] => injc H
  end.

Ltac aggressive_rewrite_goal :=
  match goal with H : _ |- _ => rewrite H end.

Ltac break_exists_name x :=
  match goal with
  | [ H : exists _, _ |- _ ] => destruct H as [x H]
  end. *)



Inductive lex_lt: string -> string -> Prop :=

| lex_lt_lt : forall (c1 c2 : ascii) (s1 s2 : string),

    nat_of_ascii c1 < nat_of_ascii c2 ->

    lex_lt (String c1 s1) (String c2 s2)

| lex_lt_eq : forall (c : ascii) (s1 s2 : string),

    lex_lt s1 s2 ->

    lex_lt (String c s1) (String c s2)

| lex_lt_empty : forall (c : ascii) (s : string),

    lex_lt EmptyString (String c s).



Inductive lex_order : string -> string -> Prop :=

| lex_order_empty :

    lex_order EmptyString EmptyString

| lex_order_char_lt :

    forall (c1 c2: ascii) (s1 s2: string),

      nat_of_ascii c1 < nat_of_ascii c2 ->

      lex_order (String c1 s1) (String c2 s2)

| lex_order_char_eq :

    forall (c: ascii) (s1 s2: string),

      lex_order s1 s2 ->

      lex_order (String c s1) (String c s2)

| lex_order_empty_string :

    forall s, lex_order EmptyString s.



Definition lex_le (s1 s2 : string) : Prop := lex_lt s1 s2 \/ s1 = s2.



Lemma lex_le_in_lex_order : forall (s1 s2 : string),

    lex_order s1 s2 -> lex_le s1 s2.

Proof.

  intros s1 s2 H.

  induction H.

  - right.

    reflexivity.

  - left.

    apply lex_lt_lt.

    assumption.

  - case IHlex_order; intro H_le.

    * left.

      apply lex_lt_eq.

      assumption.

    * rewrite H_le.

      right.

      reflexivity.

  - case s.

    * right.

      reflexivity.

    * intros c s0.

      left.

      apply lex_lt_empty.

Qed.



Lemma lex_order_refl : forall (s : string), lex_order s s.

Proof.

  induction s.

  * apply lex_order_empty_string.

  * intros.

    apply lex_order_char_eq.

    assumption.

Qed.

  

Lemma lex_order_lex_le : forall (s1 s2 : string),

    lex_le s1 s2 -> lex_order s1 s2.

intros s1 s2 H_le.

case H_le; intro H_le'.

- induction H_le'.

  * apply lex_order_char_lt.

    assumption.

  * apply lex_order_char_eq.

    apply IHH_le'.

    left.

    assumption.

  * apply lex_order_empty_string.

- rewrite <- H_le'.

  apply lex_order_refl.

Qed.



Theorem lex_lt_trans : forall s0 s1 s2,

    lex_lt s0 s1 -> lex_lt s1 s2 -> lex_lt s0 s2.

Proof.

induction s0.

- intros.  

  inversion H; subst.

  inversion H0; subst.

  * apply lex_lt_empty.

  * apply lex_lt_empty.

- intros.

  inversion H; subst; inversion H0; subst.

  * apply lex_lt_lt.

    eauto with arith.

  * apply lex_lt_lt.

    assumption.

  * apply lex_lt_lt.

    assumption.

  * apply lex_lt_eq.

    eapply IHs0; eauto.

Qed.



Theorem lex_lt_not_eq : forall s0 s1,

    lex_lt s0 s1 -> s0 <> s1.

Proof.

  induction s0.

  - intros.

    inversion H; subst.

    congruence.

  - intros.

    inversion H; subst.

    * intro H_eq.

      find_injection.

      contradict H3.

      auto with arith.

    * intro H_eq.

      find_injection.

      specialize (IHs0 s3).

      concludes.

      auto.

Qed.



Lemma nat_of_ascii_injective:

  forall c1 c2, nat_of_ascii c1 = nat_of_ascii c2 -> c1 = c2.

Proof.

  intros; simpl.

  assert (ascii_of_nat (nat_of_ascii c1) =

          ascii_of_nat (nat_of_ascii c2))

      as Hinvol. auto.

  repeat rewrite ascii_nat_embedding in Hinvol.

  trivial.

Qed.



Fixpoint string_compare_lex_compat (s0 s1 : string) : Compare lex_lt eq s0 s1.

refine

  (match s0 as ss0, s1 as ss1 return (_ = ss0 -> _ = ss1 -> _) with

   | EmptyString, EmptyString => fun H_eq H_eq' => EQ _

   | EmptyString, String c' s'1 => fun H_eq H_eq' => LT _

   | String c s'0, EmptyString => fun H_eq H_eq' => GT _

   | String c s'0, String c' s'1 => fun H_eq H_eq' =>

     match Nat.compare (nat_of_ascii c) (nat_of_ascii c') as cmp return (_ = cmp -> _) with

     | Lt => fun H_eq_cmp => LT _

     | Eq => fun H_eq_cmp =>

       match string_compare_lex_compat s'0 s'1 with

       | LT H_lt => LT _

       | EQ H_eq_lex => EQ _

       | GT H_gt => GT _

       end

     | Gt => fun H_eq_cmp => GT _

     end (refl_equal _)

   end (refl_equal _) (refl_equal _)); try (rewrite H_eq; rewrite H_eq'); auto.

- apply lex_lt_empty.

- apply lex_lt_empty.

- apply nat_compare_eq in H_eq_cmp.

  apply nat_of_ascii_injective in H_eq_cmp.

  rewrite H_eq_cmp.

  apply lex_lt_eq.

  assumption.

- apply nat_compare_eq in H_eq_cmp.

  apply nat_of_ascii_injective in H_eq_cmp.

  subst.

  reflexivity.

- apply nat_compare_eq in H_eq_cmp.

  apply nat_of_ascii_injective in H_eq_cmp.

  rewrite H_eq_cmp.

  apply lex_lt_eq.

  assumption.

- apply nat_compare_lt in H_eq_cmp.

  apply lex_lt_lt.

  assumption.

- apply nat_compare_gt in H_eq_cmp.

  apply lex_lt_lt.

  auto with arith.

Defined.



Module string_lex_as_OT_compat <: UsualOrderedType.

  Definition t := string.

  Definition eq := @eq string.

  Definition lt := lex_lt.

  Definition eq_refl := @eq_refl string.

  Definition eq_sym := @eq_sym string.

  Definition eq_trans := @eq_trans string.

  Definition lt_trans := lex_lt_trans.

  Definition lt_not_eq := lex_lt_not_eq.

  Definition compare := string_compare_lex_compat.

  Definition eq_dec := string_dec.

End string_lex_as_OT_compat.



Require Import Orders.
(* Orders:
Require Import String.
Require Import Ascii.
Require Import Arith.
Require Import OrderedType.
Require Import OrderedTypeEx.

Require Import StructTact.StructTactics.

Inductive lex_lt: string -> string -> Prop :=
| lex_lt_lt : forall (c1 c2 : ascii) (s1 s2 : string),
    nat_of_ascii c1 < nat_of_ascii c2 ->
    lex_lt (String c1 s1) (String c2 s2)
| lex_lt_eq : forall (c : ascii) (s1 s2 : string),
    lex_lt s1 s2 ->
    lex_lt (String c s1) (String c s2)
| lex_lt_empty : forall (c : ascii) (s : string),
    lex_lt EmptyString (String c s).

Inductive lex_order : string -> string -> Prop :=
| lex_order_empty :
    lex_order EmptyString EmptyString
| lex_order_char_lt :
    forall (c1 c2: ascii) (s1 s2: string),
      nat_of_ascii c1 < nat_of_ascii c2 ->
      lex_order (String c1 s1) (String c2 s2)
| lex_order_char_eq :
    forall (c: ascii) (s1 s2: string),
      lex_order s1 s2 ->
      lex_order (String c s1) (String c s2)
| lex_order_empty_string :
    forall s, lex_order EmptyString s.

Definition lex_le (s1 s2 : string) : Prop := lex_lt s1 s2 \/ s1 = s2.

Lemma lex_le_in_lex_order : forall (s1 s2 : string),
    lex_order s1 s2 -> lex_le s1 s2.

Lemma lex_order_refl : forall (s : string), lex_order s s.
  
Lemma lex_order_lex_le : forall (s1 s2 : string),
    lex_le s1 s2 -> lex_order s1 s2.

Theorem lex_lt_trans : forall s0 s1 s2,
    lex_lt s0 s1 -> lex_lt s1 s2 -> lex_lt s0 s2.

Theorem lex_lt_not_eq : forall s0 s1,
    lex_lt s0 s1 -> s0 <> s1.

Lemma nat_of_ascii_injective:
  forall c1 c2, nat_of_ascii c1 = nat_of_ascii c2 -> c1 = c2.

Fixpoint string_compare_lex_compat (s0 s1 : string) : Compare lex_lt eq s0 s1.

Module string_lex_as_OT_compat <: UsualOrderedType.
  Definition t := string.
  Definition eq := @eq string.
  Definition lt := lex_lt.
  Definition eq_refl := @eq_refl string.
  Definition eq_sym := @eq_sym string.
  Definition eq_trans := @eq_trans string.
  Definition lt_trans := lex_lt_trans.
  Definition lt_not_eq := lex_lt_not_eq.
  Definition compare := string_compare_lex_compat.
  Definition eq_dec := string_dec.
End string_lex_as_OT_compat.

Require Import Orders.

Lemma lex_lt_irrefl : Irreflexive lex_lt.

Theorem lex_lt_strorder : StrictOrder lex_lt.

Theorem lex_lt_lt_compat : Proper (eq ==> eq ==> iff) lex_lt.

Fixpoint string_compare_lex (s0 s1 : string) : { cmp : comparison | CompSpec eq lex_lt s0 s1 cmp }.

Module string_lex_as_OT <: UsualOrderedType.
  Definition t := string.
  Definition eq := @eq string.
  Definition eq_equiv := @eq_equivalence string.
  Definition lt := lex_lt.
  Definition lt_strorder := lex_lt_strorder.
  Definition lt_compat := lex_lt_lt_compat.
  Definition compare := fun x y => proj1_sig (string_compare_lex x y).
  Definition compare_spec := fun x y => proj2_sig (string_compare_lex x y).
  Definition eq_dec := string_dec.
End string_lex_as_OT. *)



Lemma lex_lt_irrefl : Irreflexive lex_lt.

Proof.

  intros s0 H_lt.

  apply lex_lt_not_eq in H_lt.

  auto.

Qed.



Theorem lex_lt_strorder : StrictOrder lex_lt.

Proof.

  exact (Build_StrictOrder _ lex_lt_irrefl lex_lt_trans).

Qed.



Theorem lex_lt_lt_compat : Proper (eq ==> eq ==> iff) lex_lt.

Proof.

intros s0 s1 H_eq s2 s3 H_eq'.

split; intro H_imp; subst; auto.

Qed.



Fixpoint string_compare_lex (s0 s1 : string) : { cmp : comparison | CompSpec eq lex_lt s0 s1 cmp }.

refine

  (match s0 as ss0, s1 as ss1 return (_ = ss0 -> _ = ss1 -> _) with

   | EmptyString, EmptyString => fun H_eq H_eq' => exist _ Eq _

   | EmptyString, String c' s'1 => fun H_eq H_eq' => exist _ Lt _

   | String c s'0, EmptyString => fun H_eq H_eq' => exist _ Gt _

   | String c s'0, String c' s'1 => fun H_eq H_eq' =>

     match Nat.compare (nat_of_ascii c) (nat_of_ascii c') as cmp0 return (_ = cmp0 -> _)  with

     | Lt => fun H_eq_cmp0 => exist _ Lt _

     | Eq => fun H_eq_cmp0 =>

       match string_compare_lex s'0 s'1 with

       | exist _ cmp H_cmp' =>

         match cmp as cmp1 return (cmp = cmp1 -> _) with

         | Lt => fun H_eq_cmp1 => exist _ Lt _

         | Eq => fun H_eq_cmp1 => exist _ Eq _

         | Gt => fun H_eq_cmp1 => exist _ Gt _

         end (refl_equal _)

       end

     | Gt => fun H_eq_cmp0 => exist _ Gt _

     end (refl_equal _)

   end (refl_equal _) (refl_equal _)); try (rewrite H_eq; rewrite H_eq').

- apply CompEq; auto.

- apply CompLt.

  apply lex_lt_empty.

- apply CompGt.

  apply lex_lt_empty.

- apply nat_compare_eq in H_eq_cmp0.

  apply nat_of_ascii_injective in H_eq_cmp0.

  rewrite H_eq_cmp1 in H_cmp'.

  inversion H_cmp'; subst.

  apply CompEq.

  reflexivity.

- apply nat_compare_eq in H_eq_cmp0.

  apply nat_of_ascii_injective in H_eq_cmp0.

  rewrite H_eq_cmp1 in H_cmp'.

  inversion H_cmp'.

  subst.

  apply CompLt.

  apply lex_lt_eq.

  assumption.

- apply nat_compare_eq in H_eq_cmp0.

  apply nat_of_ascii_injective in H_eq_cmp0.

  rewrite H_eq_cmp1 in H_cmp'.

  subst.

  inversion H_cmp'.

  apply CompGt.

  apply lex_lt_eq.

  assumption.

- apply nat_compare_lt in H_eq_cmp0.

  apply CompLt.

  apply lex_lt_lt.

  assumption.

- apply nat_compare_gt in H_eq_cmp0.

  apply CompGt.

  apply lex_lt_lt.

  auto with arith.

Defined.



Module string_lex_as_OT <: UsualOrderedType.

  Definition t := string.

  Definition eq := @eq string.

  Definition eq_equiv := @eq_equivalence string.

  Definition lt := lex_lt.

  Definition lt_strorder := lex_lt_strorder.

  Definition lt_compat := lex_lt_lt_compat.

  Definition compare := fun x y => proj1_sig (string_compare_lex x y).

  Definition compare_spec := fun x y => proj2_sig (string_compare_lex x y).

  Definition eq_dec := string_dec.

End string_lex_as_OT.

