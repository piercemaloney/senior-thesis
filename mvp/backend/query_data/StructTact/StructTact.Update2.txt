Require Import List.

Import ListNotations.

Require Import StructTact.StructTactics.
(* StructTact.StructTactics:
Ltac subst_max :=
  repeat match goal with
           | [ H : ?X = _ |- _ ]  => subst X
           | [H : _ = ?X |- _] => subst X
         end.

Ltac inv H := inversion H; subst_max.
Ltac invc H := inv H; clear H.
Ltac invcs H := invc H; simpl in *.

Ltac inv_prop P :=
  match goal with
  | [ H : context[P] |- _] =>
    inv H
  end.

Ltac invc_prop P :=
  match goal with
  | [ H : context[P] |- _] =>
    invc H
  end.

Ltac invcs_prop P :=
  match goal with
  | [ H : context[P] |- _] =>
    invcs H
  end.

Ltac break_if :=
  match goal with
    | [ |- context [ if ?X then _ else _ ] ] =>
      match type of X with
        | sumbool _ _ => destruct X
        | _ => destruct X eqn:?
      end
    | [ H : context [ if ?X then _ else _ ] |- _] =>
      match type of X with
        | sumbool _ _ => destruct X
        | _ => destruct X eqn:?
      end
  end.

Ltac break_match_hyp :=
  match goal with
    | [ H : context [ match ?X with _ => _ end ] |- _] =>
      match type of X with
        | sumbool _ _ => destruct X
        | _ => destruct X eqn:?
      end
  end.

Ltac break_match_goal :=
  match goal with
    | [ |- context [ match ?X with _ => _ end ] ] =>
      match type of X with
        | sumbool _ _ => destruct X
        | _ => destruct X eqn:?
      end
  end.

Ltac break_match := break_match_goal || break_match_hyp.

Ltac break_inner_match' t :=
 match t with
   | context[match ?X with _ => _ end] =>
     break_inner_match' X || destruct X eqn:?
   | _ => destruct t eqn:?
 end.

Ltac break_inner_match_goal :=
 match goal with
   | [ |- context[match ?X with _ => _ end] ] =>
     break_inner_match' X
 end.

Ltac break_inner_match_hyp :=
 match goal with
   | [ H : context[match ?X with _ => _ end] |- _ ] =>
     break_inner_match' X
 end.

Ltac break_inner_match := break_inner_match_goal || break_inner_match_hyp.

Ltac break_exists :=
  repeat match goal with
           | [H : exists _, _ |- _ ] => destruct H
         end.

Ltac break_exists_exists :=
  repeat match goal with
           | H:exists _, _ |- _ =>
             let x := fresh "x" in
             destruct H as [x]; exists x
         end.

Ltac break_and :=
  repeat match goal with
           | [H : _ /\ _ |- _ ] => destruct H
         end.

Ltac break_and_goal :=
    repeat match goal with
             | [ |- _ /\ _ ] => split
           end.

Ltac solve_by_inversion' tac :=
  match goal with
    | [H : _ |- _] => solve [inv H; tac]
  end.

Ltac solve_by_inversion := solve_by_inversion' auto.

Ltac apply_fun f H:=
  match type of H with
    | ?X = ?Y => assert (f X = f Y)
  end.

Ltac conclude H tac :=
  (let H' := fresh in
   match type of H with
     | ?P -> _ => assert P as H' by (tac)
   end; specialize (H H'); clear H').

Ltac concludes :=
  match goal with
    | [ H : ?P -> _ |- _ ] => conclude H auto
  end.

Ltac forward H :=
  let H' := fresh in
   match type of H with
     | ?P -> _ => assert P as H'
   end.

Ltac forwards :=
  match goal with
    | [ H : ?P -> _ |- _ ] => forward H
  end.

Ltac find_elim_prop P :=
  match goal with
  | [ H : context [ P ] |- _ ] =>
    elim H
  end.

Ltac find_eelim_prop P :=
  match goal with
  | [ H : context [ P ] |- _ ] =>
    eelim H
  end.

Ltac find_contradiction :=
  match goal with
    | [ H : ?X = _, H' : ?X = _ |- _ ] => rewrite H in H'; solve_by_inversion
  end.

Ltac find_rewrite :=
  match goal with
    | [ H : ?X _ _ _ _ = _, H' : ?X _ _ _ _ = _ |- _ ] => rewrite H in H'
    | [ H : ?X = _, H' : ?X = _ |- _ ] => rewrite H in H'
    | [ H : ?X = _, H' : context [ ?X ] |- _ ] => rewrite H in H'
    | [ H : ?X = _ |- context [ ?X ] ] => rewrite H
  end.

Ltac find_rewrite_lem lem :=
  match goal with
    | [ H : _ |- _ ] =>
      rewrite lem in H; [idtac]
  end.

Ltac find_rewrite_lem_by lem t :=
  match goal with
    | [ H : _ |- _ ] =>
      rewrite lem in H by t
  end.

Ltac find_erewrite_lem lem :=
  match goal with
    | [ H : _ |- _] => erewrite lem in H by eauto
  end.

Ltac find_reverse_rewrite :=
  match goal with
    | [ H : _ = ?X _ _ _ _, H' : ?X _ _ _ _ = _ |- _ ] => rewrite <- H in H'
    | [ H : _ = ?X, H' : context [ ?X ] |- _ ] => rewrite <- H in H'
    | [ H : _ = ?X |- context [ ?X ] ] => rewrite <- H
  end.

Ltac find_inversion :=
  match goal with
    | [ H : ?X _ _ _ _ _ _ = ?X _ _ _ _ _ _ |- _ ] => invc H
    | [ H : ?X _ _ _ _ _ = ?X _ _ _ _ _ |- _ ] => invc H
    | [ H : ?X _ _ _ _ = ?X _ _ _ _ |- _ ] => invc H
    | [ H : ?X _ _ _ = ?X _ _ _ |- _ ] => invc H
    | [ H : ?X _ _ = ?X _ _ |- _ ] => invc H
    | [ H : ?X _ = ?X _ |- _ ] => invc H
  end.

Ltac prove_eq :=
  match goal with
    | [ H : ?X ?x1 ?x2 ?x3 = ?X ?y1 ?y2 ?y3 |- _ ] =>
      assert (x1 = y1) by congruence;
        assert (x2 = y2) by congruence;
        assert (x3 = y3) by congruence;
        clear H
    | [ H : ?X ?x1 ?x2 = ?X ?y1 ?y2 |- _ ] =>
      assert (x1 = y1) by congruence;
        assert (x2 = y2) by congruence;
        clear H
    | [ H : ?X ?x1 = ?X ?y1 |- _ ] =>
      assert (x1 = y1) by congruence;
        clear H
  end.

Ltac tuple_inversion :=
  match goal with
    | [ H : (_, _, _, _) = (_, _, _, _) |- _ ] => invc H
    | [ H : (_, _, _) = (_, _, _) |- _ ] => invc H
    | [ H : (_, _) = (_, _) |- _ ] => invc H
  end.

Ltac f_apply H f :=
  match type of H with
    | ?X = ?Y =>
      assert (f X = f Y) by (rewrite H; auto)
  end.

Ltac break_let :=
  match goal with
    | [ H : context [ (let (_,_) := ?X in _) ] |- _ ] => destruct X eqn:?
    | [ |- context [ (let (_,_) := ?X in _) ] ] => destruct X eqn:?
  end.

Ltac break_or_hyp :=
  match goal with
    | [ H : _ \/ _ |- _ ] => invc H
  end.

Ltac copy_apply lem H :=
  let x := fresh in
  pose proof H as x;
    apply lem in x.

Ltac copy_eapply lem H :=
  let x := fresh in
  pose proof H as x;
    eapply lem in x.

Ltac conclude_using tac :=
  match goal with
    | [ H : ?P -> _ |- _ ] => conclude H tac
  end.

Ltac find_higher_order_rewrite :=
  match goal with
    | [ H : _ = _ |- _ ] => rewrite H in *
    | [ H : forall _, _ = _ |- _ ] => rewrite H in *
    | [ H : forall _ _, _ = _ |- _ ] => rewrite H in *
  end.

Ltac find_reverse_higher_order_rewrite :=
  match goal with
    | [ H : _ = _ |- _ ] => rewrite <- H in *
    | [ H : forall _, _ = _ |- _ ] => rewrite <- H in *
    | [ H : forall _ _, _ = _ |- _ ] => rewrite <- H in *
  end.

Ltac clean :=
  match goal with
    | [ H : ?X = ?X |- _ ] => clear H
  end.

Ltac find_apply_hyp_goal :=
  match goal with
    | [ H : _ |- _ ] => solve [apply H]
  end.

Ltac find_copy_apply_lem_hyp lem :=
  match goal with
    | [ H : _ |- _ ] => copy_apply lem H
  end.

Ltac find_apply_hyp_hyp :=
  match goal with
    | [ H : forall _, _ -> _,
        H' : _ |- _ ] =>
      apply H in H'; [idtac]
    | [ H : _ -> _ , H' : _ |- _ ] =>
      apply H in H'; auto; [idtac]
  end.

Ltac find_copy_apply_hyp_hyp :=
  match goal with
    | [ H : forall _, _ -> _,
        H' : _ |- _ ] =>
      copy_apply H H'; [idtac]
    | [ H : _ -> _ , H' : _ |- _ ] =>
      copy_apply H H'; auto; [idtac]
  end.

Ltac find_apply_lem_hyp lem :=
  match goal with
    | [ H : _ |- _ ] => apply lem in H
  end.

Ltac find_eapply_lem_hyp lem :=
  match goal with
    | [ H : _ |- _ ] => eapply lem in H
  end.

Ltac insterU H :=
  match type of H with
    | forall _ : ?T, _ =>
      let x := fresh "x" in
      evar (x : T);
      let x' := (eval unfold x in x) in
        clear x; specialize (H x')
  end.

Ltac find_insterU :=
  match goal with
    | [ H : forall _, _ |- _ ] => insterU H
  end.

Ltac eapply_prop P :=
  match goal with
    | H : P _ |- _ =>
      eapply H
  end.

Ltac find_eapply_prop P :=
  match goal with
    | H : context [ P ] |- _ =>
      eapply H
  end.

Ltac isVar t :=
    match goal with
      | v : _ |- _ =>
        match t with
          | v => idtac
        end
    end.

Ltac remGen t :=
  let x := fresh in
  let H := fresh in
  remember t as x eqn:H;
    generalize dependent H.

Ltac remGenIfNotVar t := first [isVar t| remGen t].

Ltac rememberNonVars H :=
  match type of H with
    | _ ?a ?b ?c ?d ?e =>
      remGenIfNotVar a;
      remGenIfNotVar b;
      remGenIfNotVar c;
      remGenIfNotVar d;
      remGenIfNotVar e
    | _ ?a ?b ?c ?d =>
      remGenIfNotVar a;
      remGenIfNotVar b;
      remGenIfNotVar c;
      remGenIfNotVar d
    | _ ?a ?b ?c =>
      remGenIfNotVar a;
      remGenIfNotVar b;
      remGenIfNotVar c
    | _ ?a ?b =>
      remGenIfNotVar a;
      remGenIfNotVar b
    | _ ?a =>
      remGenIfNotVar a
  end.

Ltac generalizeEverythingElse H :=
  repeat match goal with
           | [ x : ?T |- _ ] =>
             first [
                 match H with
                   | x => fail 2
                 end |
                 match type of H with
                   | context [x] => fail 2
                 end |
                 revert x]
         end.

Ltac prep_induction H :=
  rememberNonVars H;
  generalizeEverythingElse H.

Ltac econcludes :=
  match goal with
    | [ H : ?P -> _ |- _ ] => conclude H eauto
  end.

Ltac find_copy_eapply_lem_hyp lem :=
  match goal with
    | [ H : _ |- _ ] => copy_eapply lem H
  end.

Ltac apply_prop_hyp P Q :=
  match goal with
  | [ H : context [ P ], H' : context [ Q ] |- _ ] =>
    apply H in H'
  end.

Ltac eapply_prop_hyp P Q :=
  match goal with
  | [ H : context [ P ], H' : context [ Q ] |- _ ] =>
    eapply H in H'
  end.

Ltac copy_eapply_prop_hyp P Q :=
  match goal with
    | [ H : context [ P ], H' : context [ Q ] |- _ ] =>
      copy_eapply H H'
  end.

Ltac eapply_lem_prop_hyp lem P :=
  match goal with
  | [ H : context [ P ] |- _ ] =>
    eapply lem in H
  end.

Ltac copy_eapply_lem_prop_hyp lem P :=
  match goal with
  | [ H : context [ P ] |- _ ] =>
    copy_eapply lem H
  end.

Ltac find_false :=
  match goal with
    | H : _ -> False |- _ => exfalso; apply H
  end.

Ltac injc H :=
  injection H; clear H; intros; subst_max.

Ltac find_injection :=
  match goal with
    | [ H : ?X _ _ _ _ _ _ = ?X _ _ _ _ _ _ |- _ ] => injc H
    | [ H : ?X _ _ _ _ _ = ?X _ _ _ _ _ |- _ ] => injc H
    | [ H : ?X _ _ _ _ = ?X _ _ _ _ |- _ ] => injc H
    | [ H : ?X _ _ _ = ?X _ _ _ |- _ ] => injc H
    | [ H : ?X _ _ = ?X _ _ |- _ ] => injc H
    | [ H : ?X _ = ?X _ |- _ ] => injc H
  end.

Ltac aggressive_rewrite_goal :=
  match goal with H : _ |- _ => rewrite H end.

Ltac break_exists_name x :=
  match goal with
  | [ H : exists _, _ |- _ ] => destruct H as [x H]
  end. *)

Require Import StructTact.ListTactics.
(* StructTact.ListTactics:
Require Import List.
Require Import StructTact.StructTactics.

Ltac do_in_map :=
  match goal with
    | [ H : In _ (map _ _) |- _ ] => apply in_map_iff in H; break_exists; break_and
  end.

Ltac do_in_app :=
  match goal with
    | [ H : In _ (_ ++ _) |- _ ] => apply in_app_iff in H
  end.

Ltac invc_NoDup :=
  repeat match goal with
  | [ H : NoDup (_ :: _) |- _ ] => invc H
  end.

Ltac map_crush :=
  repeat match goal with
                   | [ H : context [ map _ (_ ++ _) ] |- _ ] => rewrite map_app in H
                   | [ |- context [ map _ (_ ++ _) ] ] => rewrite map_app
                   | [ H : context [ map _ (map _ _) ] |- _ ] => rewrite map_map in H
                   | [ |- context [ map _ (map _ _) ] ] => rewrite map_map
         end; simpl in *.

Ltac in_crush_finish :=
  repeat match goal with
    | [ |- _ \/ _ ] => try first [solve [apply or_introl; in_crush_finish]|
                                 solve [apply or_intror; in_crush_finish]]
    | [ |- In _ (_ ++ _) ] => apply in_or_app; in_crush_finish
    | [ |- In _ (map _ _) ] => apply in_map_iff; eexists; eauto
  end.

Ltac in_crush_start :=
  intuition; simpl in *;
  repeat
    (match goal with
       | [ H : In _ (map _ _) |- _ ] => apply in_map_iff in H; break_exists; break_and
       | [ H : In _ (_ ++ _) |- _ ] => apply in_app_iff in H
     end; intuition; simpl in *); subst.

Ltac in_crush := repeat (in_crush_start; in_crush_finish).

Create HintDb struct_util.

Hint Constructors NoDup : struct_util. *)

Require Import StructTact.ListUtil.
(* StructTact.ListUtil:
Require Import Arith.
Require Import Omega.
Require Import List.
Import ListNotations.
Require Import Sorting.Permutation.
Require Import StructTact.StructTactics.
Require Import StructTact.ListTactics.

Set Implicit Arguments.

Notation member := (in_dec eq_nat_dec).

Lemma seq_range :
  forall n a x,
    In x (seq a n) ->
    a <= x < a + n.

Lemma plus_gt_0 :
  forall a b,
    a + b > 0 ->
    a > 0 \/ b > 0.

Section list_util.
  Variables A B C : Type.
  Hypothesis A_eq_dec : forall x y : A, {x = y} + {x <> y}.

  Lemma list_neq_cons :
    forall (l : list A) x,
      x :: l <> l.

  Lemma remove_preserve :
    forall (x y : A) xs,
      x <> y ->
      In y xs ->
      In y (remove A_eq_dec x xs).

  Lemma in_remove :
    forall (x y : A) xs,
      In y (remove A_eq_dec x xs) ->
      In y xs.

  Lemma remove_partition :
    forall xs (p : A) ys,
      remove A_eq_dec p (xs ++ p :: ys) = remove A_eq_dec p (xs ++ ys).

  Lemma remove_not_in :
    forall (x : A) xs,
      ~ In x xs ->
      remove A_eq_dec x xs = xs.

  Lemma remove_app_comm :
    forall a xs ys,
      remove A_eq_dec a (xs ++ ys) = remove A_eq_dec a xs ++ remove A_eq_dec a ys.

  Lemma filter_app : forall (f : A -> bool) xs ys,
      filter f (xs ++ ys) = filter f xs ++ filter f ys.

  Lemma filter_fun_ext_eq : forall f g xs,
      (forall a : A, In a xs -> f a = g a) ->
      filter f xs = filter g xs.

  Lemma not_in_filter_false :
    forall (f : A -> bool) l x,
      In x l ->
      ~ In x (filter f l) ->
      f x = false.

  Lemma filter_length_bound :
    forall f (l : list A),
      length (filter f l) <= length l.

  Lemma NoDup_map_injective : forall (f : A -> B) xs,
      (forall x y, In x xs -> In y xs ->
              f x = f y -> x = y) ->
      NoDup xs -> NoDup (map f xs).

  Lemma NoDup_disjoint_append :
    forall (l : list A) l',
      NoDup l ->
      NoDup l' ->
      (forall a, In a l -> ~ In a l') ->
      NoDup (l ++ l').

  Lemma NoDup_map_partition :
    forall (f : A -> B) xs l y zs xs' y' zs',
      NoDup (map f l) ->
      l = xs ++ y :: zs ->
      l = xs' ++ y' :: zs' ->
      f y = f y' ->
      xs = xs'.

  Lemma filter_NoDup :
    forall p (l : list A),
      NoDup l ->
      NoDup (filter p l).

  Lemma NoDup_map_filter :
    forall (f : A -> B) g l,
      NoDup (map f l) ->
      NoDup (map f (filter g l)).

  Lemma filter_true_id : forall (f : A -> bool) xs,
      (forall x, In x xs -> f x = true) ->
      filter f xs = xs.

  Lemma map_of_map : forall (f : A -> B) (g : B -> C) xs,
      map g (map f xs) = map (fun x => g (f x)) xs.

  Lemma filter_except_one : forall (f g : A -> bool) x xs,
      (forall y, In y xs ->
            x <> y ->
            f y = g y) ->
      g x = false ->
      filter f (remove A_eq_dec x xs) = filter g xs.

  Lemma flat_map_nil : forall (f : A -> list B) l,
      flat_map f l = [] ->
      l = [] \/ (forall x, In x l -> f x = []).

  Theorem NoDup_Permutation_NoDup :
    forall (l l' : list A),
      NoDup l ->
      Permutation l l' ->
      NoDup l'.

  Theorem NoDup_append :
    forall l (a : A),
      NoDup (l ++ [a]) <-> NoDup (a :: l).

  Lemma NoDup_map_elim :
    forall (f : A -> B) xs x y,
      f x = f y ->
      NoDup (map f xs) ->
      In x xs ->
      In y xs ->
      x = y.

  Lemma remove_length_not_in : forall (x : A) xs,
      ~ In x xs ->
      length (remove A_eq_dec x xs) = length xs.

  Lemma remove_length_in : forall (x : A) xs,
      In x xs ->
      NoDup xs ->
      S (length (remove A_eq_dec x xs)) = length xs.

  Lemma subset_size_eq :
    forall xs,
      NoDup xs ->
      forall ys,
        NoDup ys ->
        (forall x : A, In x xs -> In x ys) ->
        length xs = length ys ->
        (forall x, In x ys -> In x xs).

  Lemma remove_NoDup :
    forall (x : A) xs,
      NoDup xs ->
      NoDup (remove A_eq_dec x xs).

  Lemma remove_length_ge : forall (x : A) xs,
      NoDup xs ->
      length (remove A_eq_dec x xs) >= length xs - 1.

  Lemma remove_length_le :
    forall (x : A) xs eq_dec,
      length xs >= length (remove eq_dec x xs).

  Lemma remove_length_lt :
    forall (x : A) xs eq_dec,
      In x xs ->
      length xs > length (remove eq_dec x xs).

  Lemma subset_length :
    forall xs ys,
      NoDup xs ->
      (forall x : A, In x xs -> In x ys) ->
      length ys >= length xs.

  Lemma app_cons_singleton_inv :
    forall xs (y : A) zs w,
      xs ++ y :: zs = [w] ->
      xs = [] /\ y = w /\ zs = [].

  Lemma app_cons_in :
    forall (l : list A) xs a ys,
      l = xs ++ a :: ys ->
      In a l.
  Hint Resolve app_cons_in : struct_util.

  Lemma app_cons_in_rest:
    forall (l : list A) xs a b ys,
      l = xs ++ a :: ys ->
      In b (xs ++ ys) ->
      In b l.
  Hint Resolve app_cons_in_rest : struct_util.

  Lemma in_rest_app_cons:
    forall (l xs ys : list A) a b,
      l = xs ++ a :: ys ->
      In b l ->
      a <> b ->
      In b (xs ++ ys).
  Hint Resolve in_rest_app_cons : struct_util.

  Lemma remove_filter_commute :
    forall (l : list A) A_eq_dec f x,
      remove A_eq_dec x (filter f l) = filter f (remove A_eq_dec x l).

  Lemma In_filter_In :
    forall (f : A -> bool) x l l',
      filter f l = l' ->
      In x l' -> In x l.

  Lemma filter_partition :
    forall (l1 : list A) f l2 x l1' l2',
      NoDup (l1 ++ x :: l2) ->
      filter f (l1 ++ x :: l2) = (l1' ++ x :: l2') ->
      filter f l1 = l1' /\ filter f l2 = l2'.

  Lemma map_inverses :
    forall (la : list A) (lb : list B)  (f : A -> B) g,
      (forall a, g (f a) = a) ->
      (forall b, f (g b) = b) ->
      lb = map f la ->
      la = map g lb.

  Lemma In_notIn_implies_neq :
    forall x y l,
      In(A:=A) x l ->
      ~ In(A:=A) y l ->
      x <> y.

  Lemma In_cons_neq :
    forall a x xs,
      In(A:=A) a (x :: xs) ->
      a <> x ->
      In a xs.

  Lemma NoDup_app3_not_in_1 :
    forall (xs ys zs : list A) b,
      NoDup (xs ++ ys ++ b :: zs) ->
      In b xs ->
      False.

  Lemma NoDup_app3_not_in_2 :
    forall (xs ys zs : list A) b,
      NoDup (xs ++ ys ++ b :: zs) ->
      In b ys ->
      False.

  Lemma NoDup_app3_not_in_3 :
    forall (xs ys zs : list A) b,
      NoDup (xs ++ ys ++ b :: zs) ->
      In b zs ->
      False.

  Lemma In_cons_2_3 :
    forall xs ys zs x y a,
      In (A:=A) a (xs ++ ys ++ zs) ->
      In a (xs ++ x :: ys ++ y :: zs).

  Lemma In_cons_2_3_neq :
    forall a x y xs ys zs,
      In (A:=A) a (xs ++ x :: ys ++ y :: zs) ->
      a <> x ->
      a <> y ->
      In a (xs ++ ys ++ zs).

  Lemma in_middle_reduce :
    forall a xs y zs,
      In (A:=A) a (xs ++ y :: zs) ->
      a <> y ->
      In a (xs ++ zs).

  Lemma in_middle_insert :
    forall a xs y zs,
      In (A:=A) a (xs ++ zs) ->
      In a (xs ++ y :: zs).

  Lemma NoDup_rev :
    forall l,
      NoDup (A:=A) l ->
      NoDup (rev l).

  Lemma NoDup_map_map :
    forall (f : A -> B) (g : A -> C) xs,
      (forall x y, In x xs -> In y xs -> f x = f y -> g x = g y) ->
      NoDup (map g xs) ->
      NoDup (map f xs).

  Lemma pigeon :
    forall (l : list A) sub1 sub2,
      (forall a, In a sub1 -> In a l) ->
      (forall a, In a sub2 -> In a l) ->
      NoDup l ->
      NoDup sub1 ->
      NoDup sub2 ->
      length sub1 + length sub2 > length l ->
      exists a, In a sub1 /\ In a sub2.

  Lemma snoc_assoc :
    forall (l : list A) x y,
      l ++ [x; y] = (l ++ [x]) ++ [y].

  Lemma cons_cons_app :
    forall (x y : A),
      [x; y] = [x] ++ [y].

  Lemma map_eq_inv :
    forall (f : A -> B) l xs ys,
      map f l = xs ++ ys ->
      exists l1 l2,
        l = l1 ++ l2 /\
        map f l1 = xs /\
        map f l2 = ys.

  Lemma map_partition :
    forall p l (x : B) p' (f : A -> B),
      map f l = (p ++ x :: p') ->
      exists ap a ap',
        l = ap ++ a :: ap' /\
        map f ap = p /\
        f a = x /\
        map f ap' = p'.

  Lemma map_eq_inv_eq :
    forall (f : A -> B),
      (forall a a', f a = f a' -> a = a') ->
      forall l l', map f l = map f l' -> l = l'.

  Lemma map_fst_snd_id :
    forall l, map (fun t : A * B => (fst t, snd t)) l = l.

  Lemma in_firstn : forall n (x : A) xs,
      In x (firstn n xs) -> In x xs.

  Lemma firstn_NoDup : forall n (xs : list A),
    NoDup xs ->
    NoDup (firstn n xs).

  Lemma NoDup_mid_not_in :
    forall (a : A) (l l' : list A),
    NoDup (l ++ a :: l') ->
    ~ In a (l ++ l').

  Lemma Permutation_split :
    forall (ns ns' : list A) (n : A),
      Permutation (n :: ns) ns' ->
      exists ns0, exists ns1, ns' = ns0 ++ n :: ns1.

  Lemma NoDup_app_left :
    forall (l l' : list A),
      NoDup (l ++ l') -> NoDup l.

  Lemma NoDup_app_right :
    forall (l l' : list A),
      NoDup (l ++ l') -> NoDup l'.

  Lemma NoDup_in_not_in_right :
    forall (l l' : list A) (a : A),
      NoDup (l ++ l') -> In a l -> ~ In a l'.

  Lemma NoDup_in_not_in_left :
    forall (l l' : list A) (a : A),
    NoDup (l ++ l') -> In a l' -> ~ In a l.

  Lemma count_occ_app :
    forall l l' (a : A),
      count_occ A_eq_dec (l ++ l') a = count_occ A_eq_dec l a + count_occ A_eq_dec l' a.

  Lemma Permutation_map_fst :
    forall l l' : list (A * B),
      Permutation l l' ->
      Permutation (map fst l) (map fst l').

  Lemma snd_eq_not_in_map :
    forall (l : list (A * B)) n m,
      (forall nm, In nm l -> snd nm = m) ->
      ~ In (n, m) l ->
      ~ In n (map fst l).

  Lemma NoDup_map_snd_fst :
    forall nms : list (A * B),
      NoDup nms ->
      (forall nm nm', In nm nms -> In nm' nms -> snd nm = snd nm') ->
      NoDup (map fst nms).

  Lemma in_fold_left_by_cons_in :
    forall (l : list B) (g : B -> A) x acc,
      In x (fold_left (fun a b => g b :: a) l acc) ->
      In x acc \/ exists y, In y l /\ x = g y.

  Lemma fold_left_for_each_not_in :
    forall (f : A -> B -> A) (g : A -> B -> C),
      (forall a b b',
          b <> b' ->
          g (f a b') b = g a b) ->
      forall l a b,
        ~ In b l ->
        g (fold_left f l a) b = g a b.

  Lemma fold_left_for_each_in :
    forall (f : A -> B -> A) (g : A -> B -> C) (B_eq_dec : forall x y : B, {x = y} + {x <> y}),
      (forall a b b',
          b <> b' ->
          g (f a b') b = g a b) ->
      forall l a b,
        In b l ->
        exists a',
          g (fold_left f l a) b = g (f a' b) b.

  Lemma hd_error_tl_exists :
    forall (l : list A) x,
      hd_error l = Some x ->
      exists tl,
        l = x :: tl.

  Lemma hd_error_None :
    forall (l : list A),
      hd_error l = None ->
      l = [].

End list_util.

Hint Resolve app_cons_in : struct_util.
Hint Resolve app_cons_in_rest : struct_util.
Hint Resolve in_rest_app_cons : struct_util. *)

Require Import StructTact.RemoveAll.
(* StructTact.RemoveAll:
Require Import List.
Import ListNotations.
Require Import StructTact.StructTactics.
Require Import StructTact.ListUtil.
Require Import StructTact.ListTactics.
Require Import StructTact.Before.

Set Implicit Arguments.

Section remove_all.
  Variable A : Type.
  Hypothesis A_eq_dec : forall x y : A, {x = y} + {x <> y}.

  Fixpoint remove_all (to_delete l : list A) : list A :=
    match to_delete with
    | [] => l
    | d :: ds => remove_all ds (remove A_eq_dec d l)
    end.

  Lemma in_remove_all_was_in :
    forall ds l x,
      In x (remove_all ds l) ->
      In x l.

  Lemma in_remove_all_preserve :
    forall ds l x,
      ~ In x ds ->
      In x l ->
      In x (remove_all ds l).

  Lemma in_remove_all_not_in :
    forall ds l x,
      In x (remove_all ds l) ->
      In x ds ->
      False.

  Lemma remove_all_nil :
    forall ys,
      remove_all ys [] = [].

  Lemma remove_all_cons :
    forall ys a l,
      (remove_all ys (a :: l) = remove_all ys l /\
       In a ys) \/
      (remove_all ys (a :: l) = a :: (remove_all ys l) /\
       ~In a ys).

  Lemma before_remove_all :
    forall x y l ys,
      before x y (remove_all ys l) ->
      ~ In y ys ->
      before x y l.

  Lemma before_remove_all_if :
    forall x y l xs,
      before x y l ->
      ~ In x xs ->
      before x y (remove_all xs l).

  Lemma NoDup_remove_all :
    forall l l',
    NoDup l' ->
    NoDup (remove_all l l').

  Lemma remove_all_NoDup_split :
    forall l l' l0 l1 a,
     NoDup l' ->
     remove_all l l' = l0 ++ a :: l1 ->
     remove_all l (remove A_eq_dec a l') = l0 ++ l1.

  Lemma remove_all_app_l :
    forall xs ys zs,
      remove_all (xs ++ ys) zs = remove_all xs (remove_all ys zs).

  Lemma remove_all_app_r :
    forall xs ys zs,
      remove_all xs (ys ++ zs) = remove_all xs ys ++ remove_all xs zs.

  Lemma remove_all_del_comm :
    forall xs ys zs,
      remove_all xs (remove_all ys zs) = remove_all ys (remove_all xs zs).

End remove_all.
Arguments in_remove_all_was_in : clear implicits. *)

Require Import StructTact.PropUtil.
(* StructTact.PropUtil:
Require Import StructTact.StructTactics.

Set Implicit Arguments.

Lemma or_false :
  forall P : Prop, P -> (P \/ False).

Lemma if_sum_bool_fun_comm :
  forall A B C D (b : {A}+{B}) (c1 c2 : C) (f : C -> D),
    f (if b then c1 else c2) = if b then f c1 else f c2.

Lemma if_decider_true :
  forall A B (P : A -> Prop) (dec : forall x, {P x} + {~ P x}) a (b1 b2 : B),
    P a ->
    (if dec a then b1 else b2) = b1.

Lemma if_decider_false :
  forall A B (P : A -> Prop) (dec : forall x, {P x} + {~ P x}) a (b1 b2 : B),
    ~ P a ->
    (if dec a then b1 else b2) = b2.

Definition prod_eq_dec :
  forall A B
    (A_eq_dec : forall x y : A, {x = y} + {x <> y})
    (B_eq_dec : forall x y : B, {x = y} + {x <> y})
    (x y : A * B),
    {x = y} + {x <> y}.

Section equatesLemma.
Variables
  (A0 A1 : Type)
  (A2 : forall(x1 : A1), Type)
  (A3 : forall(x1 : A1) (x2 : A2 x1), Type)
  (A4 : forall(x1 : A1) (x2 : A2 x1) (x3 : A3 x2), Type)
  (A5 : forall(x1 : A1) (x2 : A2 x1) (x3 : A3 x2) (x4 : A4 x3), Type)
  (A6 : forall(x1 : A1) (x2 : A2 x1) (x3 : A3 x2) (x4 : A4 x3) (x5 : A5 x4), Type).

Lemma equates_0 : forall(P Q:Prop),
  P -> P = Q -> Q.

Lemma equates_1 :
  forall(P:A0->Prop) x1 y1,
  P y1 -> x1 = y1 -> P x1.

Lemma equates_2 :
  forall y1 (P:A0->forall(x1:A1),Prop) x1 x2,
  P y1 x2 -> x1 = y1 -> P x1 x2.

Lemma equates_3 :
  forall y1 (P:A0->forall(x1:A1)(x2:A2 x1),Prop) x1 x2 x3,
  P y1 x2 x3 -> x1 = y1 -> P x1 x2 x3.

Lemma equates_4 :
  forall y1 (P:A0->forall(x1:A1)(x2:A2 x1)(x3:A3 x2),Prop) x1 x2 x3 x4,
  P y1 x2 x3 x4 -> x1 = y1 -> P x1 x2 x3 x4.

Lemma equates_5 :
  forall y1 (P:A0->forall(x1:A1)(x2:A2 x1)(x3:A3 x2)(x4:A4 x3),Prop) x1 x2 x3 x4 x5,
  P y1 x2 x3 x4 x5 -> x1 = y1 -> P x1 x2 x3 x4 x5.

Lemma equates_6 :
  forall y1 (P:A0->forall(x1:A1)(x2:A2 x1)(x3:A3 x2)(x4:A4 x3)(x5:A5 x4),Prop)
  x1 x2 x3 x4 x5 x6,
  P y1 x2 x3 x4 x5 x6 -> x1 = y1 -> P x1 x2 x3 x4 x5 x6.
    
End equatesLemma. *)

Require Import FunctionalExtensionality.

Require Import Sumbool.

Require Import Sorting.Permutation.

Require Import Relation_Definitions.

Require Import RelationClasses.



Definition update2 {A B : Type} (A_eq_dec : forall x y : A, {x = y} + {x <> y}) (f : A -> A -> B) (x y : A) (v : B) :=

  fun x' y' => if sumbool_and _ _ _ _ (A_eq_dec x x') (A_eq_dec y y') then v else f x' y'.



Fixpoint collate {A B : Type} (A_eq_dec : forall x y : A, {x = y} + {x <> y}) (from : A) (f : A -> A -> list B) (ms : list (A * B)) :=

  match ms with

   | [] => f

   | (to, m) :: ms' => collate A_eq_dec from (update2 A_eq_dec f from to (f from to ++ [m])) ms'

  end.



Fixpoint collate_ls {A B : Type} (A_eq_dec : forall x y : A, {x = y} + {x <> y}) (s : list A) (f : A -> A -> list B) (to : A) (m : B) :=

  match s with

   | [] => f

   | from :: s' => collate_ls A_eq_dec s' (update2 A_eq_dec f from to (f from to ++ [m])) to m

  end.



Fixpoint filter_rel {A : Type} {rel : relation A} (A_rel_dec : forall x y : A, {rel x y} + {~ rel x y}) (x : A) (l : list A) :=

  match l with

   | [] => []

   | y :: tl => if A_rel_dec x y then y :: filter_rel A_rel_dec x tl else filter_rel A_rel_dec x tl

  end.



Definition map2fst {A B : Type} (a : A) := map (fun (b : B) => (a, b)).



Definition map2snd {A B : Type} (b : B) := map (fun (a : A) => (a, b)).



Section Update2.

  Variables A B : Type.



  Hypothesis A_eq_dec : forall x y : A, {x = y} + {x <> y}.

  

  Lemma update2_diff1 :

    forall (sigma : A -> A -> B) x y v x' y',

      x <> x' ->

      update2 A_eq_dec sigma x y v x' y' = sigma x' y'.

  Proof using.

    unfold update2.

    intros.

    break_if; intuition congruence.

  Qed.



  Lemma update2_diff2 :

    forall (sigma : A -> A -> B) x y v x' y',

      y <> y' ->

      update2 A_eq_dec sigma x y v x' y' = sigma x' y'.

  Proof using.

    unfold update2.

    intros.

    break_if; intuition congruence.

  Qed.



  Lemma update2_diff_prod :

    forall (sigma : A -> A -> B) x y v x' y',

      (x, y) <> (x', y') ->

      update2 A_eq_dec sigma x y v x' y' = sigma x' y'.

  Proof using.

    unfold update2.

    intros.

    break_if; intuition congruence.

  Qed.

  

  Lemma update2_nop :

    forall (sigma : A -> A -> B) x y x' y',

      update2 A_eq_dec sigma x y (sigma x y) x' y' = sigma x' y'.

  Proof using.

    unfold update2.

    intros. break_if; intuition congruence.

  Qed.



  Lemma update2_eq :

    forall (sigma : A -> A -> B) x y x' y' v,

      x = x' ->

      y = y' ->

      update2 A_eq_dec sigma x y v x' y' = v.

  Proof using.

    intros. subst.

    unfold update2.

    break_if; intuition congruence.

  Qed.



  Lemma update2_eq_prod :

    forall (sigma : A -> A -> B) x y x' y' v,

      (x, y) = (x', y') ->

      update2 A_eq_dec sigma x y v x' y' = v.

  Proof using.

    intros. subst.

    unfold update2.

    break_if; intuition congruence.

  Qed.

  

  Lemma update2_same :

    forall (sigma : A -> A -> B) x y v,

      update2 A_eq_dec sigma x y v x y = v.

  Proof using.

    intros.

    rewrite update2_eq; auto.

  Qed.



  Lemma update2_nop_ext :

    forall (sigma : A -> A -> B) x y,

      update2 A_eq_dec sigma x y (sigma x y) = sigma.

  Proof using.

    intros.

    do 2 (apply functional_extensionality; intros).

    apply update2_nop.

  Qed.



  Lemma update2_nop_ext' :

    forall (sigma : A -> A -> B) x y v,

      sigma x y = v ->

      update2 A_eq_dec sigma x y v = sigma.

  Proof using.

    intros.

    subst.

    apply update2_nop_ext.

  Qed.



  Lemma update2_overwrite :

    forall (sigma : A -> A -> B) x y st st',

      update2 A_eq_dec (update2 A_eq_dec sigma x y st) x y st' = update2 A_eq_dec sigma x y st'.

  Proof using.

    intros.

    do 2 (apply functional_extensionality; intros).

    destruct (A_eq_dec x x0);

      destruct (A_eq_dec y x1).

    - repeat rewrite update2_eq; auto.

    - repeat rewrite update2_diff2; auto.

    - repeat rewrite update2_diff1; auto.

    - repeat rewrite update2_diff1; auto.

  Qed.



End Update2.



Lemma update2_fun_comm :

  forall A B C A_eq_dec (f : B -> C) (st : A -> A -> B) x y v x' y',

    f (update2 A_eq_dec st x y v x' y') = update2 A_eq_dec (fun x y => f (st x y)) x y (f v) x' y'.

Proof using.

  intros.

  destruct (prod_eq_dec A_eq_dec A_eq_dec (x, y) (x', y')); subst;

    repeat first [rewrite update2_diff_prod by congruence |

                  rewrite update2_eq_prod  by auto ]; auto.

Qed.



Ltac update2_destruct_goal :=

  match goal with

  | [ |- context [ update2 ?eq_dec _ ?x ?y _ ?x' ?y' ] ] =>

    destruct (prod_eq_dec eq_dec eq_dec (x, y) (x', y'))

  end.



Ltac update2_destruct_hyp :=

  match goal with

  | [ _ : context [ update2 ?eq_dec _ ?x ?y _ ?x' ?y' ] |- _ ] =>

    destruct (prod_eq_dec eq_dec eq_dec (x, y) (x', y'))

  end.



Ltac update2_destruct := update2_destruct_goal || update2_destruct_hyp.



Ltac rewrite_update2' H :=

  first [rewrite update2_diff_prod in H by congruence |

         rewrite update2_eq_prod in H by auto ].



Ltac rewrite_update2 :=

  repeat match goal with

           | [ H : context [ update2 _ _ _ _ _ _ _ ] |- _ ] =>

             rewrite_update2' H; repeat rewrite_update2' H

           | [ |- _ ] => repeat (try rewrite update2_diff_prod by congruence;

                                 try rewrite update2_eq_prod by auto)

         end.



Ltac destruct_update2 :=

  repeat (update2_destruct; subst; rewrite_update2).



Ltac destruct_update2_hyp :=

  repeat ((update2_destruct_hyp || update2_destruct_goal); subst; rewrite_update2).



Ltac update2_destruct_simplify :=

  update2_destruct; subst; rewrite_update2; simpl in *.



Ltac update2_destruct_simplify_hyp :=

  update2_destruct_hyp || update2_destruct_goal; subst; rewrite_update2; simpl in *.



Ltac update2_destruct_max_simplify :=

  update2_destruct; subst_max; rewrite_update2; simpl in *.



Section Update2Rel.

  Variables A B : Type.

  Variable R : relation A.



  Hypothesis A_eq_dec : forall x y : A, {x = y} + {x <> y}.

  Hypothesis R_dec : forall x y : A, {R x y} + {~ R x y}.



  Lemma filter_rel_related :

    forall n n' ns,

      In n' (filter_rel R_dec n ns) ->

      In n' ns /\ R n n'.

  Proof using.

    intros.

    induction ns; simpl in *; [ intuition | idtac ].

    break_if; simpl in *.

    - break_or_hyp; auto.

      concludes.

      break_and.

      auto.

    - concludes.

      break_and.

      auto.

  Qed.



  Lemma related_filter_rel : 

    forall n n' ns,

      In n' ns -> 

      R n n' ->

      In n' (filter_rel R_dec n ns).

  Proof using.

    intros.

    induction ns; simpl in *; [ intuition | idtac ].

    break_if.

    - break_or_hyp.

      * left; auto.

      * concludes.

        right; auto.

    - break_or_hyp.

      * intuition.

      * concludes.

        assumption.

  Qed.



  Lemma not_in_not_in_filter_rel :

    forall ns n h,

      ~ In n ns ->

      ~ In n (filter_rel R_dec h ns).

  Proof using.

    induction ns; intros; auto.

    assert (H_neq: a <> n).

    intro.

    subst.

    auto with datatypes.

    assert (H_not_in: ~ In n ns).

    intro.

    intuition.

    simpl.

    break_if; auto.

    simpl.

    intro.

    break_or_hyp; auto.

    intuition eauto.

  Qed.



  Lemma NoDup_filter_rel:

    forall h ns,

      NoDup ns ->

      NoDup (filter_rel R_dec h ns).

  Proof using.

    intros.

    induction ns; auto.

    invc_NoDup.

    concludes.

    simpl in *.

    break_if; auto.

    apply NoDup_cons; auto.

    apply not_in_not_in_filter_rel.

    assumption.

  Qed.



  Lemma filter_rel_self_eq {irreflexive_R : Irreflexive R} :

    forall ns0 ns1 h,

      filter_rel R_dec h (ns0 ++ h :: ns1) = filter_rel R_dec h (ns0 ++ ns1).

  Proof using.

    induction ns0; intros; simpl in *.

    - break_if; auto.

      find_apply_lem_hyp irreflexive_R.

      intuition.

    - break_if; auto.

      find_higher_order_rewrite.

      trivial.

  Qed.



  Lemma collate_f_eq :

    forall (f : A -> A -> list B) g h n n' l,

      f n n' = g n n' ->

      collate A_eq_dec h f l n n' = collate A_eq_dec h g l n n'.

  Proof using.

    intros f g h n n' l.

    generalize f g; clear f g.

    induction l; auto.

    intros.

    simpl in *.

    break_let.

    destruct a.

    find_injection.

    set (f' := update2 _ _ _ _ _).

    set (g' := update2 _ _ _ _ _).

    rewrite (IHl f' g'); auto.

    unfold f', g', update2.

    break_if; auto.

    break_and.

    subst.

    find_rewrite.

    trivial.

  Qed.



  Lemma collate_in_in :

    forall l h n n' (f : A -> A -> list B) a,

      In a (f n' n) ->

      In a ((collate A_eq_dec h f l) n' n).

  Proof using.

    induction l; intros; auto.

    destruct a.

    apply IHl.

    unfold update2.

    break_if; auto.

    break_and.

    subst.

    apply in_or_app.

    left.

    assumption.

  Qed.



  Lemma collate_head_head :

    forall l h n n' (f : A -> A -> list B) a,

      head (f n' n) = Some a ->

      head ((collate A_eq_dec h f l) n' n) = Some a.

  Proof using.

    induction l; intros; auto.

    destruct a.

    simpl.

    apply IHl.

    unfold update2.

    break_if; auto.

    break_and; subst.

    destruct (f n' n); auto.

    find_apply_lem_hyp hd_error_some_nil.

    intuition.

  Qed.



  Lemma collate_neq :

    forall h n n' ns (f : A -> A -> list B),

      h <> n ->

      collate A_eq_dec h f ns n n' = f n n'.

  Proof using.

    intros.

    revert f.

    induction ns; intros; auto.

    destruct a.

    simpl in *.

    rewrite IHns.

    unfold update2.

    break_if; auto.

    break_and; subst.

    intuition.

  Qed.



  Lemma collate_not_in_eq :

    forall h' h (f : A -> A -> list B) l,

      ~ In h (map fst l) ->

      collate A_eq_dec h' f l h' h = f h' h.

  Proof using.

    intros.

    revert f.

    induction l; intros; auto.

    simpl in *.

    break_let.

    destruct a.

    find_injection.

    rewrite IHl; unfold update2.

    - break_if.

      * break_and; subst.

        simpl in *.

        contradict H.

        left.

        trivial.

      * intros.

        trivial.

    - intro.

      contradict H.

      right.

      assumption.

  Qed.



  Lemma collate_app :

    forall h' l1 l2 (f : A -> A -> list B),

      collate A_eq_dec h' f (l1 ++ l2) = collate A_eq_dec h' (collate A_eq_dec h' f l1) l2.

  Proof using.

    induction l1; intros; auto.

    simpl.

    break_let.

    destruct a.

    find_injection.

    rewrite IHl1.

    trivial.

  Qed.



  Lemma collate_neq_update2 :

    forall h h' n (f : A -> A -> list B) l ms,

      n <> h' ->

      collate A_eq_dec h (update2 A_eq_dec f h n ms) l h h' = collate A_eq_dec h f l h h'.

  Proof using.

    intros.

    assert (H_eq: update2 A_eq_dec f h n ms h h' =  f h h').

    unfold update2.

    break_if; auto.

    break_and; subst.

    intuition.

    rewrite (collate_f_eq _ _ _ _ _ _ H_eq).

    trivial.

  Qed.



  Lemma collate_not_in :

    forall h h' l1 l2 (f : A -> A -> list B),

      ~ In h' (map fst l1) ->

      collate A_eq_dec h f (l1 ++ l2) h h' = collate A_eq_dec h f l2 h h'.

  Proof using.

    intros.

    rewrite collate_app.

    revert f.

    induction l1; intros; simpl in *; auto.

    break_let.

    rewrite IHl1.

    - destruct a.

      find_injection.

      simpl in *.

      assert (H_neq: a0 <> h').

      intro.

      contradict H.

      left.

      trivial.

      rewrite collate_neq_update2; trivial.

    - intro.

      contradict H.

      right.

      trivial.

  Qed.



  Lemma collate_not_in_rest :

    forall h h' l1 l2 (f : A -> A -> list B),

      ~ In h' (map fst l2) ->

      collate A_eq_dec h f (l1 ++ l2) h h' = collate A_eq_dec h f l1 h h'.

  Proof using.

    intros.

    rewrite collate_app.

    revert f.

    induction l2; intros; simpl in *; auto.

    break_let.

    subst_max.

    simpl in *.

    assert (H_neq: a0 <> h'); auto.

    rewrite collate_neq_update2; auto.

  Qed.



  Lemma collate_not_in_mid :

    forall h h' l1 l2 (f : A -> A -> list B) m,

      ~ In h (map fst (l1 ++ l2)) ->

      collate A_eq_dec h' (update2 A_eq_dec f h' h (f h' h ++ [m])) (l1 ++ l2) = collate A_eq_dec h' f (l1 ++ (h, m) :: l2).

  Proof using.

    intros h h' l1 l2 f m H_in.

    apply functional_extensionality; intro from.

    apply functional_extensionality; intro to.

    case (A_eq_dec h' from); intro H_dec.

    - rewrite <- H_dec.

      case (A_eq_dec h to); intro H_dec'.

      * rewrite <- H_dec'.

        rewrite collate_not_in.

      + subst.

        rewrite collate_not_in; auto.

        intro.

        contradict H_in.

        rewrite map_app.

        apply in_or_app.

        left.

        assumption.

      + intro.

        contradict H_in.

        rewrite map_app.

        apply in_or_app.

        left.

        assumption.

        * rewrite collate_neq_update2; auto.

          rewrite collate_app.

          rewrite collate_app.

          simpl.

          rewrite collate_neq_update2; auto.

    - rewrite collate_neq; auto.

      rewrite collate_neq; auto.

      unfold update2.

      break_if; auto.

      break_and; subst.

      intuition.

  Qed.



  Lemma NoDup_Permutation_collate_eq :

    forall h (f : A -> A -> list B) l l',

      NoDup (map fst l) ->

      Permutation l l' ->

      collate A_eq_dec h f l = collate A_eq_dec h f l'.

  Proof using.

    intros h f l.

    revert h f.

    induction l.

    - intros.

      find_apply_lem_hyp Permutation_nil.

      subst.

      trivial.

    - intros.

      destruct a.

      simpl in *.

      invc_NoDup.  

      assert (H_in': In (a, b) ((a, b) :: l)). 

      left.

      trivial.

      pose proof (Permutation_in _ H0 H_in') as H_pm'.

      apply in_split in H_pm'.

      break_exists; subst.

      find_apply_lem_hyp Permutation_cons_app_inv.

      pose proof (IHl h (update2 A_eq_dec f h a (f h a ++ [b])) _ H4 H0) as IHl'.

      rewrite IHl'.

      rewrite collate_not_in_mid; auto.

      intro.

      assert (H_pm': Permutation (map (fun nm : A * B => fst nm) l) (map (fun nm : A * B => fst nm) (x ++ x0))).

      apply Permutation_map_fst.

      trivial.

      contradict H3.

      revert H.

      apply Permutation_in.

      apply Permutation_sym.

      trivial.

  Qed.



  Lemma collate_map2snd_not_related :

    forall m n h ns (f : A -> A -> list B),

      ~ R h n ->

      collate A_eq_dec h f (map2snd m (filter_rel R_dec h ns)) h n = f h n.

  Proof using.

    intros m n h ns f H_adj.

    revert f.

    induction ns; intros; auto.

    simpl.

    break_if; simpl; auto.

    rewrite IHns.

    unfold update2.

    break_if; auto.

    break_and; subst.

    intuition.

  Qed.



  Lemma collate_map2snd_in_neq_in_before :

    forall from (f : A -> A -> list B) m dsts a b x,

      In x (collate A_eq_dec from f (map2snd m dsts) a b) ->

      x <> m ->

      In x (f a b).

  Proof using.

    intros.

    generalize dependent f.

    induction dsts.

    - auto.

    - simpl; intros f H_coll.

      eapply IHdsts in H_coll.

      destruct (A_eq_dec from a), (A_eq_dec a0 b); subst.

      + rewrite update2_same in *.

        find_eapply_lem_hyp in_app_or; break_or_hyp.

        * assumption.

        * exfalso;

          find_eapply_lem_hyp in_inv; break_or_hyp; exfalso; auto.

      + rewrite update2_diff2 in *; auto.

      + rewrite update2_diff1 in *; auto.

      + rewrite update2_diff1 in *; auto.

  Qed.



  Lemma collate_map2snd_not_in :

    forall m n h ns (f : A -> A -> list B),

      ~ In n ns ->

      collate A_eq_dec h f (map2snd m (filter_rel R_dec h ns)) h n = f h n.

  Proof using.

    intros m n h ns f.

    revert f.

    induction ns; intros; auto.

    simpl in *.

    break_if; simpl.

    - rewrite IHns.

      * unfold update2.

        break_if; auto.

        break_and; subst.

        contradict H.

        left.

        trivial.

      * intro.

        contradict H.

        right.

        assumption.

    - rewrite IHns; auto.

  Qed.



  Lemma collate_map2snd_not_in_remove_all :

    forall m n h ns (f : A -> A -> list B) ns',

      ~ In n ns ->

      collate A_eq_dec h f (map2snd m (filter_rel R_dec h (remove_all A_eq_dec ns' ns))) h n = f h n.

  Proof using.

    intros m n h ns f ns' H_in.

    apply collate_map2snd_not_in.

    intro.

    find_apply_lem_hyp in_remove_all_was_in.

    intuition.

  Qed.



  Lemma collate_map2snd_not_in_related :

    forall m n h ns (f : A -> A -> list B) ns',

      ~ In n ns' ->

      R h n ->

      In n ns ->

      NoDup ns ->

      collate A_eq_dec h f (map2snd m (filter_rel R_dec h (remove_all A_eq_dec ns' ns))) h n = f h n ++ [m].

  Proof using.

    intros m n h ns f ns' H_in H_adj.

    revert f.

    induction ns; intros; [ contradict H | idtac ].

    invc_NoDup.

    simpl in *.

    break_or_hyp.

    - pose proof (remove_all_cons A_eq_dec ns' n ns) as H_ra.

      break_or_hyp; break_and; intuition.

      find_rewrite.

      simpl.

      break_if; intuition.

      simpl.

      rewrite collate_map2snd_not_in_remove_all; auto.

      unfold update2.

      break_if; auto.

      intuition.

    - assert (H_neq: a <> n).

      intro.

      subst.

      intuition.  

      pose proof (remove_all_cons A_eq_dec ns' a ns) as H_ra.

      break_or_hyp; break_and. 

      * find_rewrite.

        rewrite IHns; auto.

      * find_rewrite.

        simpl.

        break_if; auto.

        simpl.

        rewrite IHns; auto.

        unfold update2.

        break_if; auto.

        break_and.

        subst.

        intuition.

  Qed.



  Lemma collate_map2snd_in :

    forall m n h ns (f : A -> A -> list B) ns',

      In n ns' ->

      collate A_eq_dec h f (map2snd m (filter_rel R_dec h (remove_all A_eq_dec ns' ns))) h n = f h n.

  Proof using.

    intros m n h ns f ns'.

    revert f.

    induction ns; intros.

    - rewrite remove_all_nil.

      trivial.

    - pose proof (remove_all_cons A_eq_dec ns' a ns) as H_ra.

      break_or_hyp; break_and; find_rewrite.

      * rewrite IHns; trivial.

      * simpl.

        break_if.

      + simpl.

        rewrite IHns; simpl; auto.

        unfold update2.

        break_if; auto.

        break_and; subst.

        intuition.

      + rewrite IHns; trivial.

  Qed.



  Lemma collate_map2snd_related_not_in :

    forall a n h ns (f : A -> A -> list B),

      R h n ->

      ~ In n ns ->

      collate A_eq_dec h f (map2snd a (filter_rel R_dec h (n :: ns))) h n = f h n ++ [a].

  Proof using.

    intros a n h ns f H_adj H_in.

    simpl.

    break_if; intuition.

    clear r.

    revert f n h H_in H_adj.

    induction ns; intros; simpl.

    - unfold update2.

      break_if; auto.

      intuition.

    - assert (H_in': ~ In n ns).

      intro.

      contradict H_in.

      right.

      trivial.

      assert (H_neq: n <> a0). 

      intro.

      subst.

      contradict H_in.

      left.

      trivial.

      simpl in *.

      break_if.

      * simpl.

        unfold update2 at 3.

        break_if; intuition eauto.

        pose proof (IHns f) as IH'.

        rewrite collate_map2snd_not_in; auto.

        unfold update2.

        break_if; intuition eauto.

        break_if; auto.

        intuition.

      * rewrite IHns; auto.

  Qed.



  Lemma in_collate_in :

    forall ns n h (f : A -> A -> list B) a,

      ~ In n ns ->

      In a (collate A_eq_dec h f (map2snd a (filter_rel R_dec h ns)) h n) ->

      In a (f h n).

  Proof using.

    induction ns; intros; auto.

    assert (H_in': ~ In n ns).

    intro.

    contradict H.

    right.

    trivial.

    assert (H_neq: n <> a). 

    intro.

    subst.

    contradict H.

    left.

    trivial.

    simpl in *.

    break_if; auto.

    simpl in *.

    assert (H_eq_f: update2 A_eq_dec f h a (f h a ++ [a0]) h n = f h n).

    unfold update2.

    break_if; auto.

    break_and; subst.

    intuition.

    rewrite (collate_f_eq _ _ _ _ _ _ H_eq_f) in H0.

    apply IHns; auto.

  Qed.



  Lemma not_in_map2snd :

    forall n h (m : B) ns,

      ~ In n ns ->

      ~ In (n, m) (map2snd m (filter_rel R_dec h ns)).

  Proof using.

    intros.

    induction ns; intros; auto.

    simpl in *.

    break_if.

    - simpl.

      intro.

      break_or_hyp.

      * find_injection.

        contradict H.

        left.

        trivial.

      * contradict H1.

        apply IHns.

        intro.

        contradict H.

        right.

        assumption.

    - apply IHns.

      intro.

      contradict H.

      right.

      assumption.

  Qed.



  Lemma NoDup_map2snd :

    forall h (m : B) ns,

      NoDup ns ->

      NoDup (map2snd m (filter_rel R_dec h ns)).

  Proof using.

    intros.

    induction ns.

    - apply NoDup_nil.

    - invc_NoDup.

      concludes.

      simpl.

      break_if; auto.

      simpl.

      apply NoDup_cons; auto.

      apply not_in_map2snd.

      assumption.

  Qed.



  Lemma in_map2snd_snd :

    forall h (m : B) ns nm,

      In nm (map2snd m (filter_rel R_dec h ns)) ->

      snd nm = m.

  Proof using.

    intros.

    induction ns; intros; simpl in *; intuition.

    break_if.

    - simpl in *.

      break_or_hyp; intuition eauto.

    - apply IHns.

      assumption.

  Qed.



  Lemma in_map2snd_related_in :

    forall (m : B) ns n h,

      In (n, m) (map2snd m (filter_rel R_dec h ns)) ->

      R h n /\ In n ns.

  Proof using.

    intros m.

    induction ns; intros; simpl in *; [ intuition | idtac ].

    break_if; simpl in *.

    - break_or_hyp.

      * find_injection; auto.

      * find_apply_hyp_hyp.

        break_and.

        auto.

    - find_apply_hyp_hyp.

      break_and.

      auto.

  Qed.



  Lemma collate_ls_not_in :

    forall ns (f : A -> A -> list B) h mg from to,

      ~ In from ns ->

      collate_ls A_eq_dec ns f h mg from to = f from to.

  Proof using.

    induction ns; intros; auto.

    assert (H_neq: a <> from).

    intro.

    subst.

    contradict H.

    left.

    trivial.

    assert (H_in': ~ In from ns).

    intro.

    contradict H.

    right.

    assumption.

    simpl.

    rewrite IHns; auto.

    unfold update2.

    break_if; auto.

    break_and; subst.

    intuition. 

  Qed.



  Lemma collate_ls_in_in :

    forall ns (f : A -> A -> list B) to m x a b,

      In x (f a b) ->

      In x (collate_ls A_eq_dec ns f to m a b).

  Proof using.

    intros.

    generalize dependent f.

    induction ns.

    - auto.

    - intros.

      simpl.

      eapply IHns; eauto.

      destruct (A_eq_dec a a0), (A_eq_dec to b); subst.

      + rewrite update2_eq; auto using in_or_app.

      + rewrite update2_diff2; auto using in_or_app.

      + rewrite update2_diff1; auto using in_or_app.

      + rewrite update2_diff1; auto using in_or_app.

  Qed.



  Lemma collate_ls_neq_to : 

    forall ns (f : A -> A -> list B) h mg from to,

      h <> to ->

      collate_ls A_eq_dec ns f h mg from to = f from to.

  Proof using.

    induction ns; intros; auto.

    simpl in *.

    rewrite IHns; auto.

    unfold update2.

    break_if; auto.

    break_and; subst.

    intuition.

  Qed.



  Lemma collate_ls_NoDup_in :

    forall ns (f : A -> A -> list B) h mg from,

      NoDup ns ->

      In from ns ->

      collate_ls A_eq_dec ns f h mg from h = f from h ++ [mg].

  Proof using.

    induction ns; intros; simpl in *; [ intuition | idtac ].

    invc_NoDup.

    break_or_hyp.

    - rewrite collate_ls_not_in; auto.

      unfold update2.

      break_if; auto.

      break_or_hyp; intuition.

    - assert (H_neq: a <> from).

      intro.

      find_rewrite.

      auto.

      rewrite IHns; auto.

      unfold update2.

      break_if; auto.

      break_and; subst.

      intuition.

  Qed.



  Lemma collate_ls_live_related : 

    forall ns (f : A -> A -> list B) ns' h mg from,

      ~ In from ns' ->

      R h from ->

      In from ns ->

      NoDup ns ->

      collate_ls A_eq_dec (filter_rel R_dec h (remove_all A_eq_dec ns' ns)) f h mg from h = f from h ++ [mg].

  Proof using.

    intros.

    rewrite collate_ls_NoDup_in; auto.

    - apply NoDup_filter_rel.

      apply NoDup_remove_all.

      assumption.

    - apply related_filter_rel.

      apply in_remove_all_preserve; auto.

      assumption.

  Qed.



  Lemma collate_ls_f_eq :

    forall ns (f : A -> A -> list B) g h mg n n',

      f n n' = g n n' ->

      collate_ls A_eq_dec ns f h mg n n' = collate_ls A_eq_dec ns g h mg n n'.

  Proof using.

    induction ns; intros; simpl in *; auto.

    set (f' := update2 _ _ _ _ _).

    set (g' := update2 _ _ _ _ _).

    rewrite (IHns f' g'); auto.

    unfold f', g', update2.

    break_if; auto.

    break_and.

    subst.

    find_rewrite.

    trivial.

  Qed.



  Lemma collate_ls_neq_update2 : 

    forall ns (f : A -> A -> list B) n h h' ms mg,

      n <> h' ->

      collate_ls A_eq_dec ns (update2 A_eq_dec f n h ms) h mg h' h = collate_ls A_eq_dec ns f h mg h' h.

  Proof using.

    intros.

    assert (H_eq: update2 A_eq_dec f n h ms h' h = f h' h).

    unfold update2.

    break_if; auto.

    break_and.

    subst.

    intuition.

    rewrite (collate_ls_f_eq _ _ _ _ _ _ _ H_eq).

    trivial.

  Qed.



  Lemma collate_ls_cases :

    forall s (f : A -> A -> list B) to m a b,

      collate_ls A_eq_dec s f to m a b = f a b \/

      exists l,

        (forall x, In x l -> x = m) /\

        collate_ls A_eq_dec s f to m a b = f a b ++ l.

  Proof using.

    intros.

    generalize dependent f.

    induction s as [|n s].

    - auto.

    - intros.

      simpl in *.

      destruct (A_eq_dec b to), (A_eq_dec n a); subst.

      + specialize (IHs (update2 A_eq_dec f a to (f a to ++ [m])));

          break_or_hyp.

        * find_rewrite.

          rewrite update2_eq; eauto.

          right; eexists; intuition.

          find_apply_lem_hyp in_inv;

            break_or_hyp;

            [|exfalso]; eauto using in_nil.

        * break_exists_name l; break_and.

          repeat find_rewrite.

          rewrite update2_same.

          right; exists (m :: l).

          split.

          -- intros;

               find_apply_lem_hyp in_inv;

               intuition.

          -- rewrite <- app_assoc; auto.

      + rewrite collate_ls_neq_update2; auto.

      + rewrite collate_ls_neq_to, update2_diff2; auto.

      + rewrite collate_ls_neq_to, update2_diff2; auto.

  Qed.



  Lemma collate_ls_in_neq_in_before :

    forall s (f : A -> A -> list B) to m a b x,

      In x (collate_ls A_eq_dec s f to m a b) ->

      x <> m ->

      In x (f a b).

  Proof using.

    intros.

    pose proof (collate_ls_cases s f to m a b); break_or_hyp.

    - now find_rewrite.

    - break_exists; break_and.

      find_rewrite.

    find_apply_lem_hyp in_app_or; break_or_hyp; auto.

    find_apply_hyp_hyp; congruence.

  Qed.



  Lemma collate_ls_not_related :

    forall ns (f : A -> A -> list B) n h mg,

      ~ R h n ->

      collate_ls A_eq_dec (filter_rel R_dec h ns) f h mg n h = f n h.

  Proof using.

    induction ns; intros; simpl in *; auto.

    case (A_eq_dec n a); intro.

    - subst.

      break_if; auto.

      intuition.

    - break_if; auto.

      simpl.

      rewrite IHns; auto.

      unfold update2.

      break_if; auto.

      break_and.

      subst.

      intuition.

  Qed.



  Lemma collate_ls_not_in_related :

    forall ns (f : A -> A -> list B) n h mg,

      ~ In n ns ->

      collate_ls A_eq_dec (filter_rel R_dec h ns) f h mg n h = f n h.

  Proof using.

    intros.

    rewrite collate_ls_not_in; auto.

    apply not_in_not_in_filter_rel.

    assumption.

  Qed.



  Lemma collate_ls_not_in_related_remove_all :

    forall ns (f : A -> A -> list B) n h mg ns',

      ~ In n ns ->

      collate_ls A_eq_dec (filter_rel R_dec h (remove_all A_eq_dec ns' ns)) f h mg n h = f n h.

  Proof using.

    intros.

    rewrite collate_ls_not_in; auto.

    apply not_in_not_in_filter_rel.

    intro.

    contradict H.

    eapply in_remove_all_was_in; eauto.

  Qed.



  Lemma collate_ls_in_remove_all :

    forall mg n h ns (f : A -> A -> list B) ns',

      In n ns' ->

      collate_ls A_eq_dec (filter_rel R_dec h (remove_all A_eq_dec ns' ns)) f h mg n h = f n h.

  Proof using.

    intros.

    revert f.

    induction ns; intros.

    - rewrite remove_all_nil.

      trivial.

    - pose proof (remove_all_cons A_eq_dec ns' a ns) as H_cn.

      break_or_hyp; break_and; find_rewrite.

      * rewrite IHns.

        trivial.

      * simpl in *.

        break_if; auto.

        simpl.

        assert (H_neq: a <> n).

        intro.

        subst.

        intuition.

        rewrite IHns.

        unfold update2.

        break_if; auto.

        break_and; subst.

        intuition.

  Qed.



  Lemma collate_ls_app :

    forall l1 l2 (f : A -> A -> list B) h m,

      collate_ls A_eq_dec (l1 ++ l2) f h m = collate_ls A_eq_dec l2 (collate_ls A_eq_dec l1 f h m) h m.

  Proof using. 

    induction l1; simpl in *; intuition eauto.

  Qed.



  Lemma collate_ls_split_eq :

    forall l1 l2 (f : A -> A -> list B) h m from to,

      h <> from -> 

      collate_ls A_eq_dec (l1 ++ h :: l2) f to m from to =

      collate_ls A_eq_dec  (l1 ++ l2) f to m from to.

  Proof using.

    induction l1; simpl in *; auto.

    intros.

    apply collate_ls_f_eq.

    unfold update2.

    break_if; auto.

    break_and.

    subst.

    intuition.

  Qed.



  Lemma collate_ls_not_in_mid :

    forall h h' l1 l2 (f : A -> A -> list B) m,

      ~ In h' (l1 ++ l2) ->

      collate_ls A_eq_dec (l1 ++ l2) (update2 A_eq_dec f h' h (f h' h ++ [m])) h m = collate_ls A_eq_dec (l1 ++ h' :: l2) f h m.

  Proof using.

    intros h h' l1 l2 f m H_in.

    apply functional_extensionality; intro from.

    apply functional_extensionality; intro to.

    case (A_eq_dec h' from); intro H_dec; case (A_eq_dec h to); intro H_dec'.

    - rewrite <- H_dec.

      rewrite <- H_dec'.

      rewrite collate_ls_not_in; auto.

      rewrite collate_ls_app; simpl.

      set (f' := collate_ls _ l1 _ _ _).

      rewrite collate_ls_not_in.

      * unfold update2 at 2.

        break_if.

      + unfold f'.

        rewrite collate_ls_not_in.

        -- unfold update2.

           break_if; auto.

           break_or_hyp; intuition.

        -- intro.

           contradict H_in.

           apply in_or_app.

           left.

           assumption.

      + break_or_hyp; intuition.

        * intro.

          contradict H_in.

          apply in_or_app.

          right.

          assumption.

    - rewrite collate_ls_neq_to; auto.

      rewrite collate_ls_neq_to; auto.

      unfold update2.

      break_if; auto.

      break_and; subst.

      intuition.

    - rewrite H_dec'. 

      rewrite collate_ls_neq_update2; auto.

      rewrite collate_ls_split_eq; auto.

    - rewrite collate_ls_neq_to; auto.

      rewrite collate_ls_neq_to; auto.

      unfold update2.

      break_if; auto.

      break_and; subst.

      intuition.

  Qed.



  Lemma NoDup_Permutation_collate_ls_eq :

    forall l (f : A -> A -> list B) h m l',

      NoDup l ->

      Permutation l l' ->

      collate_ls A_eq_dec l f h m = collate_ls A_eq_dec l' f h m.

  Proof using.

    intros l f h m l'.

    revert f l'.

    induction l.

    - intros.

      find_apply_lem_hyp Permutation_nil.

      subst.

      trivial.

    - intros.

      invc_NoDup.

      simpl in *.

      assert (H_in: In a (a :: l)).

      left.

      trivial.

      pose proof (Permutation_in _ H0 H_in) as H_pm'.

      find_apply_lem_hyp in_split.

      break_exists.

      subst_max.

      find_apply_lem_hyp Permutation_cons_app_inv.

      set (f' := update2 _ _ _ _ _).

      rewrite (IHl f' _ H4 H0); auto.

      unfold f'.

      rewrite collate_ls_not_in_mid; auto.

      intro.

      contradict H3.

      revert H.

      apply Permutation_in.

      apply Permutation_sym.

      assumption.

  Qed.



End Update2Rel.

