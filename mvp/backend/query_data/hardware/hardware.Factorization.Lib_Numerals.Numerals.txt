
Require Export Dependent_lists.
(* Dependent_lists:
Require Export Eqdep.
Require Export Arith.

Global Set Asymmetric Patterns.
Section Dependent_lists.

  Variable A : Set.

  Inductive list : nat -> Set :=
    | nil : list 0
    | cons : forall n : nat, A -> list n -> list (S n).

  Definition eq_list := eq_dep nat list.

  Definition hd (n : nat) (l : list n) : Exc A :=
    match l in (list m) return (Exc A) with
    | nil => error
    | cons p a l' => value a
    end.

  Definition head (n : nat) (l : list n) :=
    match l in (list p) return (0 < p -> A) with
    | nil =>
        	
        fun h : 0 < 0 => False_rec A (lt_irrefl 0 h)
        
    | cons p a l' => fun h : 0 < S p => a
    end.

  Definition Head (n : nat) (l : list (S n)) := head (S n) l (lt_O_Sn n).

  Definition tl (n : nat) (l : list n) : list (pred n) :=
    match l in (list m) return (list (pred m)) with
    | nil => nil
    | cons p a l' => l'
    end.

  Lemma empty_dep : forall (n : nat) (l : list n), n = 0 -> eq_list 0 nil n l.

  Hint Resolve empty_dep.

  Lemma empty : forall l : list 0, nil = l.

  Hint Resolve empty.

  Remark non_empty_dep :
   forall n m : nat,
   m = S n ->
   forall l : list (S n),
   {h : A &  {t : list n | eq_list (S n) l (S n) (cons n h t)}}.

  Lemma non_empty :
   forall (n : nat) (l : list (S n)),
   {a : A &  {t : list n | l = cons n a t}}. 

  Lemma split_list :
   forall (n : nat) (l : list (S n)),
   l = cons n (head (S n) l (lt_O_Sn n)) (tl (S n) l).

  Definition Hd (n : nat) (l : list (S n)) :=
    let (a, P) return A := non_empty n l in a.

  Lemma Non_empty_Hd :
   forall (n : nat) (a : A) (l : list n), Hd n (cons n a l) = a.

End Dependent_lists.

Hint Resolve empty_dep empty non_empty Non_empty_Hd.

Fixpoint map (A B : Set) (f : A -> B) (n : nat) (l : list A n) {struct l} :
 list B n :=
  match l in (list _ x) return (list B x) with
  | nil =>
        nil B
       
  | cons p a t => cons B p (f a) (map A B f p t)
  end. *)
Require Export Lib_Arith.
(* Lib_Arith:
Require Export Lib_Dec.
Require Export Lib_Mult.
Require Export Lib_Square.
Require Export Lib_Div_Even_Odd.
Require Export Lib_Eq_Le_Lt.
Require Export Lib_Fact. *)

Definition Inj (A : Set) (P : A -> Prop) (e : {x : A | P x}) :=
  let (a, _) return A := e in a.

Fixpoint exp (e x : nat) {struct x} : nat :=
  match x with
  | O => 1
  | S p => e * exp e p
  end.

Section Numerals.

  Definition BT := {b : nat | 0 < b}.
  Variable BASE : BT.
  Definition base := Inj nat (fun b : nat => 0 < b) BASE.
  Definition digit := {x : nat | x < base}.
  Definition val : digit -> nat := Inj nat (fun x : nat => x < base).
  Definition num := list digit.
  Definition inf (n : nat) := {x : nat | x < n}.
  Definition val_inf (n : nat) : inf n -> nat :=
    Inj nat (fun x : nat => x < n).
  Let Cons := cons digit.
  Let Nil := nil digit.

  Fixpoint Val (n : nat) (X : num n) {struct X} : nat :=
    match X with
    | nil => 0
    | cons p xp X' => val xp * exp base p + Val p X'
    end.

  Lemma Val_val : forall x : digit, Val 1 (Cons 0 x Nil) = val x.
  simpl in |- *.
  intros x.
  rewrite (mult_1_r (val x)).
  auto.
  Qed.

  Lemma upper_bound : forall (n : nat) (X : num n), Val n X < exp base n.
  intros n X; elim X.
  auto.
  intros n0 y l H_rec.
  simpl in |- *.
  apply lt_le_trans with (pred base * exp_n base n0 + exp_n base n0).
  apply le_lt_plus_mult.
  elim y.
  intros x H_y.
  simpl in |- *.
  auto. 
  trivial.
  replace (pred base) with (base - 1). 
  rewrite mult_minus_distr_r.
  simpl in |- *.
  elim plus_n_O.
  elim exp_n_plus_p1.
  elim plus_Snm_nSm; simpl in |- *; elim plus_n_O.
  elim plus_comm.
  elim le_plus_minus.
  apply le_mult_cst; auto.
  apply le_exp_n_mult.
  unfold base in |- *; case BASE; auto.
  auto.
  Qed.

  Definition val_bound (n : nat) (X : num n) : inf (exp base n) :=
    exist (fun p : nat => p < exp base n) (Val n X) (upper_bound n X).

  Lemma comp_dif :
   forall (n : nat) (x y : digit) (X Y : num n),
   val x < val y -> Val (S n) (Cons n x X) < Val (S n) (Cons n y Y).
  simpl in |- *; intros.
  elim H.
  apply same_quotient_order; auto; apply upper_bound.
  intros; apply same_quotient_order; auto; apply upper_bound.
  Qed.

  Lemma comp_eq_most :
   forall (n : nat) (x y : digit) (X Y : num n),
   val x = val y ->
   Val n X < Val n Y -> Val (S n) (Cons n x X) < Val (S n) (Cons n y Y).
  intros n x y X Y e H.
  simpl in |- *.
  rewrite e.
  apply plus_lt_compat_l; auto.
  Qed.

  Lemma com_eq :
   forall (n : nat) (x y : digit) (X Y : num n),
   val x = val y ->
   Val n X = Val n Y -> Val (S n) (Cons n x X) = Val (S n) (Cons n y Y).
  simpl in |- *.
  intros n x y X Y He HE.
  rewrite He; rewrite HE; auto.
  Qed.

End Numerals.