

Require Import Factorization_Verif.
(* Factorization_Verif:
Require Export Linear_Structures. 
Require Export Factorization.

Section Factorization_for_Verification.

  Variable A : Set.
  Variable BASE : BT.
  Let b := base BASE.
  Let Num := num BASE.
  Let Digit := digit BASE.
  Let Val_bound := val_bound BASE.
             
  Variable R : forall n : nat, A -> inf n -> inf n -> A -> Prop.

  Definition Connection := connection A Digit Digit (R b).

  Notation Factorizable := (factorizable _) (only parsing).
  Notation Proper := (proper _) (only parsing).

  Theorem factorization_for_verification :
   factorizable _ R ->
   proper _ BASE R ->
   forall (n : nat) (X Y : Num n) (a a' : A),
   Connection n a X Y a' -> R (exp b n) a (Val_bound n X) (Val_bound n Y) a'.

End Factorization_for_Verification. *)

Require Import Comparator_Relation.
(* Comparator_Relation:
Require Export Compare_Nat.
Require Export Factorization.
Require Export Compare_Num.

Section Comparator_Rel.
   
   Variable BASE : BT.
   
   Definition FR (n : nat) (o : order) (x y : inf n) : order :=
     match o return order with
     | L => L
     | E => Compare_Nat.comparison (val_inf n x) (val_inf n y)
     | G => G
     end.

   Definition R (n : nat) (o : order) (x y : inf n) 
     (o' : order) : Prop := o' = FR n o x y.
   
  Notation Proper := (proper _) (only parsing).

Lemma is_proper : proper _ BASE R.

  Notation Factorizable := (factorizable _) (only parsing).

Lemma is_factorizable : factorizable _ R.

End Comparator_Rel. *)



Parameter BASE : BT.

Definition b := base BASE.

Definition Digit := digit BASE.

Definition Num := num BASE.

Definition Val_bound := val_bound BASE.

Definition Value := Val BASE.



Definition Connection := connection order (inf b) (inf b) (R b). 

 

Theorem general_correct :

 forall (n : nat) (X Y : Num n) (o o' : order),

 Connection n o X Y o' -> R (exp b n) o (Val_bound n X) (Val_bound n Y) o'.

intros n X Y o o' C.

unfold b in |- *.

apply factorization_for_verification with (A := order) (BASE := BASE).

exact is_factorizable.

exact (is_proper BASE).

try trivial.

Qed.

 

Theorem correctness :

 forall (n : nat) (X Y : Num n) (o : order),

 Connection n E X Y o -> o = Compare_Nat.comparison (Value n X) (Value n Y).

intros n X Y o.

generalize (general_correct n X Y E o).

unfold R in |- *; simpl in |- *; auto.

Qed.



