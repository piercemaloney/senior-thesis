
Require Export Numerals.
(* Numerals:
Require Export Dependent_lists.
Require Export Lib_Arith.

Definition Inj (A : Set) (P : A -> Prop) (e : {x : A | P x}) :=
  let (a, _) return A := e in a.

Fixpoint exp (e x : nat) {struct x} : nat :=
  match x with
  | O => 1
  | S p => e * exp e p
  end.

Section Numerals.

  Definition BT := {b : nat | 0 < b}.
  Variable BASE : BT.
  Definition base := Inj nat (fun b : nat => 0 < b) BASE.
  Definition digit := {x : nat | x < base}.
  Definition val : digit -> nat := Inj nat (fun x : nat => x < base).
  Definition num := list digit.
  Definition inf (n : nat) := {x : nat | x < n}.
  Definition val_inf (n : nat) : inf n -> nat :=
    Inj nat (fun x : nat => x < n).
  Let Cons := cons digit.
  Let Nil := nil digit.

  Fixpoint Val (n : nat) (X : num n) {struct X} : nat :=
    match X with
    | nil => 0
    | cons p xp X' => val xp * exp base p + Val p X'
    end.

  Lemma Val_val : forall x : digit, Val 1 (Cons 0 x Nil) = val x.

  Lemma upper_bound : forall (n : nat) (X : num n), Val n X < exp base n.

  Definition val_bound (n : nat) (X : num n) : inf (exp base n) :=
    exist (fun p : nat => p < exp base n) (Val n X) (upper_bound n X).

  Lemma comp_dif :
   forall (n : nat) (x y : digit) (X Y : num n),
   val x < val y -> Val (S n) (Cons n x X) < Val (S n) (Cons n y Y).

  Lemma comp_eq_most :
   forall (n : nat) (x y : digit) (X Y : num n),
   val x = val y ->
   Val n X < Val n Y -> Val (S n) (Cons n x X) < Val (S n) (Cons n y Y).

  Lemma com_eq :
   forall (n : nat) (x y : digit) (X Y : num n),
   val x = val y ->
   Val n X = Val n Y -> Val (S n) (Cons n x X) = Val (S n) (Cons n y Y).

End Numerals. *)
Require Export Compare_Nat.
(* Compare_Nat:
Require Export Arith.

Global Set Asymmetric Patterns.

Inductive Or3 (A B C : Prop) : Set :=
  | First : A -> Or3 A B C
  | Second : B -> Or3 A B C
  | Third : C -> Or3 A B C.
Hint Resolve First Second Third.

Lemma Lt_eq_Gt : forall n m : nat, Or3 (n < m) (n = m) (n > m).

Inductive order : Set :=
  | L : order
  | E : order
  | G : order.

Definition comparison (v1 v2 : nat) :=
  match Lt_eq_Gt v1 v2 return order with
  | First _ => L
  | Second _ => E
  | Third _ => G
  end.

Lemma comparisonL :
 forall v1 v2 : nat, v1 < v2 -> Compare_Nat.comparison v1 v2 = L.
Hint Resolve comparisonL.

Lemma comparisonG :
 forall v1 v2 : nat, v1 > v2 -> Compare_Nat.comparison v1 v2 = G.
Hint Resolve comparisonG.

Lemma comparisonE :
 forall v1 v2 : nat, v1 = v2 -> Compare_Nat.comparison v1 v2 = E.
Hint Resolve comparisonE.

Lemma inv_comparisonL :
 forall v1 v2 : nat, Compare_Nat.comparison v1 v2 = L -> v1 < v2.
Hint Resolve inv_comparisonL.

Lemma inv_comparisonE :
 forall v1 v2 : nat, Compare_Nat.comparison v1 v2 = E -> v1 = v2.
Hint Resolve inv_comparisonE.

Lemma inv_comparisonG :
 forall v1 v2 : nat, Compare_Nat.comparison v1 v2 = G -> v1 > v2.
Hint Resolve inv_comparisonG.

Lemma inv_comparison :
 forall v1 v2 : nat,
 match Compare_Nat.comparison v1 v2 return Prop with

Lemma comp_sym_LG :
 forall v1 v2 : nat,
 Compare_Nat.comparison v1 v2 = L -> Compare_Nat.comparison v2 v1 = G.
Hint Resolve comp_sym_LG.

Lemma comp_sym_GL :
 forall v1 v2 : nat,
 Compare_Nat.comparison v1 v2 = G -> Compare_Nat.comparison v2 v1 = L.
Hint Resolve comp_sym_GL.

Lemma comp_sym_E :
 forall v1 v2 : nat,
 Compare_Nat.comparison v1 v2 = E -> Compare_Nat.comparison v2 v1 = E.
Hint Resolve comp_sym_E. *)

Section compare_num.

  Variable BASE : BT.
  Let Digit := digit BASE.
  Let valB := val BASE.
  Let ValB := Val BASE.
  Let Num := num BASE.
  Let Val_bound := val_bound BASE.
  Let Cons := cons Digit.
  Let Nil := nil Digit.

  Lemma Comp_dif :
   forall (n : nat) (x y : Digit) (X Y : Num n),
   valB x < valB y ->
   Compare_Nat.comparison (ValB (S n) (Cons n x X)) (ValB (S n) (Cons n y Y)) =
   L.
  intros n x y X Y l.
  apply comparisonL.
  unfold ValB in |- *.
  unfold Cons in |- *.
  unfold Digit in |- *.
  apply comp_dif.
  auto.
  Qed.
  Hint Resolve Comp_dif.

  Lemma Comp_eq :
   forall (n : nat) (x y : Digit) (X Y : Num n),
   valB x = valB y ->
   Compare_Nat.comparison (ValB (S n) (Cons n x X)) (ValB (S n) (Cons n y Y)) =
   Compare_Nat.comparison (ValB n X) (ValB n Y).

  intros n x y X Y e.
  cut
   (Compare_Nat.comparison (ValB n X) (ValB n Y) =
    Compare_Nat.comparison (ValB n X) (ValB n Y)); 
   auto.
  pattern (Compare_Nat.comparison (ValB n X) (ValB n Y)) at 2 3 in |- *.
  case (Compare_Nat.comparison (ValB n X) (ValB n Y)); intros c.
  unfold ValB in |- *; unfold Cons in |- *; unfold Digit in |- *.
  apply comparisonL.
  apply comp_eq_most; auto.
  simpl in |- *.
  unfold valB in e.
  rewrite e.
  rewrite (inv_comparisonE (ValB n X) (ValB n Y) c).
  apply comparisonE; auto.
  apply comparisonG.
  unfold gt in |- *.
  unfold ValB in |- *; unfold Cons in |- *; unfold Digit in |- *.
  apply comp_eq_most.
  auto.
  cut (Val BASE n X > Val BASE n Y); auto.
  Qed.

End compare_num.

Hint Resolve Comp_eq.
Hint Resolve Comp_dif.