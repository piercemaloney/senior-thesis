
Require Export Compare_Nat.
(* Compare_Nat:
Require Export Arith.

Global Set Asymmetric Patterns.

Inductive Or3 (A B C : Prop) : Set :=
  | First : A -> Or3 A B C
  | Second : B -> Or3 A B C
  | Third : C -> Or3 A B C.
Hint Resolve First Second Third.

Lemma Lt_eq_Gt : forall n m : nat, Or3 (n < m) (n = m) (n > m).

Inductive order : Set :=
  | L : order
  | E : order
  | G : order.

Definition comparison (v1 v2 : nat) :=
  match Lt_eq_Gt v1 v2 return order with
  | First _ => L
  | Second _ => E
  | Third _ => G
  end.

Lemma comparisonL :
 forall v1 v2 : nat, v1 < v2 -> Compare_Nat.comparison v1 v2 = L.
Hint Resolve comparisonL.

Lemma comparisonG :
 forall v1 v2 : nat, v1 > v2 -> Compare_Nat.comparison v1 v2 = G.
Hint Resolve comparisonG.

Lemma comparisonE :
 forall v1 v2 : nat, v1 = v2 -> Compare_Nat.comparison v1 v2 = E.
Hint Resolve comparisonE.

Lemma inv_comparisonL :
 forall v1 v2 : nat, Compare_Nat.comparison v1 v2 = L -> v1 < v2.
Hint Resolve inv_comparisonL.

Lemma inv_comparisonE :
 forall v1 v2 : nat, Compare_Nat.comparison v1 v2 = E -> v1 = v2.
Hint Resolve inv_comparisonE.

Lemma inv_comparisonG :
 forall v1 v2 : nat, Compare_Nat.comparison v1 v2 = G -> v1 > v2.
Hint Resolve inv_comparisonG.

Lemma inv_comparison :
 forall v1 v2 : nat,
 match Compare_Nat.comparison v1 v2 return Prop with

Lemma comp_sym_LG :
 forall v1 v2 : nat,
 Compare_Nat.comparison v1 v2 = L -> Compare_Nat.comparison v2 v1 = G.
Hint Resolve comp_sym_LG.

Lemma comp_sym_GL :
 forall v1 v2 : nat,
 Compare_Nat.comparison v1 v2 = G -> Compare_Nat.comparison v2 v1 = L.
Hint Resolve comp_sym_GL.

Lemma comp_sym_E :
 forall v1 v2 : nat,
 Compare_Nat.comparison v1 v2 = E -> Compare_Nat.comparison v2 v1 = E.
Hint Resolve comp_sym_E. *)
Require Export Factorization.
(* Factorization:
Require Export Numerals.

Section factorization.

   Variable A : Set.
   Variable BASE : BT.
   Let b := base BASE.
   Let Num := num BASE.
   Let Digit := digit BASE.
   Let Tl := tl Digit.

   Let Cons := cons Digit.
   Let Nil := nil Digit.
   Let Val_bound := val_bound BASE.

 Section Definitions_for_Relations.
   
   Definition Diveucl (a b q r : nat) : Prop := a = b * q + r /\ r < b.
   Definition Zero : inf 1 := Val_bound 0 Nil.

   Variable R : forall n : nat, A -> inf n -> inf n -> A -> Prop.
         
   Definition factorizable : Prop :=
     forall (m n : nat) (q q' : inf m) (r r' : inf n) 
       (a a1 a' : A) (x x' : inf (m * n)),
     Diveucl (val_inf (m * n) x) n (val_inf m q) (val_inf n r) ->
     Diveucl (val_inf (m * n) x') n (val_inf m q') (val_inf n r') ->
     R m a q q' a1 -> R n a1 r r' a' -> R (m * n) a x x' a'.

    Definition proper : Prop := forall a : A, R 1 a Zero Zero a.

 End Definitions_for_Relations.

 Section Three_inputs.

  Variable FR : forall n : nat, A -> inf n -> inf n -> A.

  Let R (n : nat) (a : A) (x y : inf n) (a' : A) : Prop := a' = FR n a x y.

  Lemma prop_Rel :
   proper R ->
   forall (X Y : Num 0) (a : A), R 1 a (Val_bound 0 X) (Val_bound 0 Y) a.

   Lemma fact_Rel :
    factorizable R ->
    forall (n : nat) (X Y : Num (S n)) (a a' : A),
    R (exp b n) (FR b a (Hd Digit n X) (Hd Digit n Y))
      (Val_bound n (Tl (S n) X)) (Val_bound n (Tl (S n) Y)) a' ->
    R (exp b (S n)) a (Val_bound (S n) X) (Val_bound (S n) Y) a'.

 End Three_inputs.

End factorization. *)
Require Export Compare_Num.
(* Compare_Num:
Require Export Numerals.
Require Export Compare_Nat.

Section compare_num.

  Variable BASE : BT.
  Let Digit := digit BASE.
  Let valB := val BASE.
  Let ValB := Val BASE.
  Let Num := num BASE.
  Let Val_bound := val_bound BASE.
  Let Cons := cons Digit.
  Let Nil := nil Digit.

  Lemma Comp_dif :
   forall (n : nat) (x y : Digit) (X Y : Num n),
   valB x < valB y ->
   Compare_Nat.comparison (ValB (S n) (Cons n x X)) (ValB (S n) (Cons n y Y)) =
  Hint Resolve Comp_dif.

  Lemma Comp_eq :
   forall (n : nat) (x y : Digit) (X Y : Num n),
   valB x = valB y ->
   Compare_Nat.comparison (ValB (S n) (Cons n x X)) (ValB (S n) (Cons n y Y)) =

End compare_num.

Hint Resolve Comp_eq.
Hint Resolve Comp_dif. *)

Section Comparator_Rel.
   
   Variable BASE : BT.
   
   Definition FR (n : nat) (o : order) (x y : inf n) : order :=
     match o return order with
     | L => L
     | E => Compare_Nat.comparison (val_inf n x) (val_inf n y)
     | G => G
     end.

   Definition R (n : nat) (o : order) (x y : inf n) 
     (o' : order) : Prop := o' = FR n o x y.
   
  Notation Proper := (proper _) (only parsing).

Lemma is_proper : proper _ BASE R.
unfold proper in |- *.
intros a; case a; unfold R in |- *; simpl in |- *; auto with arith.
Qed.

  Notation Factorizable := (factorizable _) (only parsing).

Lemma is_factorizable : factorizable _ R.
unfold factorizable in |- *; unfold R in |- *;
 intros M N q q' r r' a a1 a' x x' H1 H2; case a.

simpl in |- *; intro R1; rewrite R1; simpl in |- *; auto with arith.

case a1.
   
  intros R1 R2.
  replace a' with L; simpl in |- *; apply sym_equal; apply comparisonL.
  unfold Diveucl in H1; unfold Diveucl in H2; elim H1; elim H2; clear H1 H2;
   intros H1 H2 H3 H4; rewrite H1; rewrite H3;
   elim (mult_comm (val_inf M q) N); elim (mult_comm (val_inf M q') N);
   auto with arith.

  case a'; intros R1 R2.
  simpl in |- *; apply sym_equal; apply comparisonL.
  unfold Diveucl in H1; unfold Diveucl in H2; elim H1; elim H2; clear H1 H2;
   intros H1 H2 H3 H4; rewrite H1; rewrite H3.
  replace (val_inf M q') with (val_inf M q); auto with arith.
  simpl in |- *; apply sym_equal; apply comparisonE.
  unfold Diveucl in H1; unfold Diveucl in H2; elim H1; elim H2; clear H1 H2;
   intros H1 H2 H3 H4; rewrite H1; rewrite H3.
  replace (val_inf M q') with (val_inf M q); auto with arith.

  simpl in |- *; apply sym_equal; apply comparisonG.
  unfold Diveucl in H1; unfold Diveucl in H2; elim H1; elim H2; clear H1 H2;
   intros H1 H2 H3 H4; rewrite H1; rewrite H3.
  replace (val_inf M q') with (val_inf M q); auto with arith.

  intros R1 R2.
  replace a' with G; simpl in |- *; apply sym_equal; apply comparisonG.
  unfold Diveucl in H1; unfold Diveucl in H2; elim H1; elim H2; clear H1 H2;
   intros H1 H2 H3 H4; rewrite H1; rewrite H3; unfold gt in |- *;
   elim (mult_comm (val_inf M q) N); elim (mult_comm (val_inf M q') N);
   auto with arith. 
 
simpl in |- *; intro R1; rewrite R1; simpl in |- *; auto with arith.

Qed.

End Comparator_Rel.