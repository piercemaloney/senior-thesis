
Require Export Numerals.
(* Numerals:
Require Export Dependent_lists.
Require Export Lib_Arith.

Definition Inj (A : Set) (P : A -> Prop) (e : {x : A | P x}) :=
  let (a, _) return A := e in a.

Fixpoint exp (e x : nat) {struct x} : nat :=
  match x with
  | O => 1
  | S p => e * exp e p
  end.

Section Numerals.

  Definition BT := {b : nat | 0 < b}.
  Variable BASE : BT.
  Definition base := Inj nat (fun b : nat => 0 < b) BASE.
  Definition digit := {x : nat | x < base}.
  Definition val : digit -> nat := Inj nat (fun x : nat => x < base).
  Definition num := list digit.
  Definition inf (n : nat) := {x : nat | x < n}.
  Definition val_inf (n : nat) : inf n -> nat :=
    Inj nat (fun x : nat => x < n).
  Let Cons := cons digit.
  Let Nil := nil digit.

  Fixpoint Val (n : nat) (X : num n) {struct X} : nat :=
    match X with
    | nil => 0
    | cons p xp X' => val xp * exp base p + Val p X'
    end.

  Lemma Val_val : forall x : digit, Val 1 (Cons 0 x Nil) = val x.

  Lemma upper_bound : forall (n : nat) (X : num n), Val n X < exp base n.

  Definition val_bound (n : nat) (X : num n) : inf (exp base n) :=
    exist (fun p : nat => p < exp base n) (Val n X) (upper_bound n X).

  Lemma comp_dif :
   forall (n : nat) (x y : digit) (X Y : num n),
   val x < val y -> Val (S n) (Cons n x X) < Val (S n) (Cons n y Y).

  Lemma comp_eq_most :
   forall (n : nat) (x y : digit) (X Y : num n),
   val x = val y ->
   Val n X < Val n Y -> Val (S n) (Cons n x X) < Val (S n) (Cons n y Y).

  Lemma com_eq :
   forall (n : nat) (x y : digit) (X Y : num n),
   val x = val y ->
   Val n X = Val n Y -> Val (S n) (Cons n x X) = Val (S n) (Cons n y Y).

End Numerals. *)

Section factorization.

   Variable A : Set.
   Variable BASE : BT.
   Let b := base BASE.
   Let Num := num BASE.
   Let Digit := digit BASE.
   Let Tl := tl Digit.

   Let Cons := cons Digit.
   Let Nil := nil Digit.
   Let Val_bound := val_bound BASE.

 Section Definitions_for_Relations.
   
   Definition Diveucl (a b q r : nat) : Prop := a = b * q + r /\ r < b.
   Definition Zero : inf 1 := Val_bound 0 Nil.

   Variable R : forall n : nat, A -> inf n -> inf n -> A -> Prop.
         
   Definition factorizable : Prop :=
     forall (m n : nat) (q q' : inf m) (r r' : inf n) 
       (a a1 a' : A) (x x' : inf (m * n)),
     Diveucl (val_inf (m * n) x) n (val_inf m q) (val_inf n r) ->
     Diveucl (val_inf (m * n) x') n (val_inf m q') (val_inf n r') ->
     R m a q q' a1 -> R n a1 r r' a' -> R (m * n) a x x' a'.

    Definition proper : Prop := forall a : A, R 1 a Zero Zero a.

 End Definitions_for_Relations.

 Section Three_inputs.

  Variable FR : forall n : nat, A -> inf n -> inf n -> A.

  Let R (n : nat) (a : A) (x y : inf n) (a' : A) : Prop := a' = FR n a x y.

  Lemma prop_Rel :
   proper R ->
   forall (X Y : Num 0) (a : A), R 1 a (Val_bound 0 X) (Val_bound 0 Y) a.
  intros P X Y a.
  replace X with (nil (digit BASE)); auto with arith.
  replace Y with (nil (digit BASE)); auto with arith.
  Qed.

   Lemma fact_Rel :
    factorizable R ->
    forall (n : nat) (X Y : Num (S n)) (a a' : A),
    R (exp b n) (FR b a (Hd Digit n X) (Hd Digit n Y))
      (Val_bound n (Tl (S n) X)) (Val_bound n (Tl (S n) Y)) a' ->
    R (exp b (S n)) a (Val_bound (S n) X) (Val_bound (S n) Y) a'.

  intros F n X Y a a' H.
  simpl in |- *.
  generalize (non_empty (inf b) n X).
  generalize (non_empty (inf b) n Y).
  intros H1 H2.
  elim H1; elim H2; clear H1 H2.
  intros d D d' D'.
  elim D; elim D'; clear D D'.
  intros D' HD' D HD.
  rewrite HD; rewrite HD'.
  apply
   F
    with
      d
      d'
      (Val_bound n (Tl (S n) X))
      (Val_bound n (Tl (S n) Y))
      (FR b a (Hd Digit n X) (Hd Digit n Y)).
  unfold Diveucl in |- *; split; simpl in |- *.
  rewrite HD; simpl in |- *.
  elim (mult_comm (val_inf b d) (exp b n)); auto with arith.
  rewrite HD; simpl in |- *.
  unfold b in |- *; apply upper_bound.
  unfold Diveucl in |- *; split; simpl in |- *.
  rewrite HD'; simpl in |- *.
  elim (mult_comm (val_inf b d') (exp b n)); auto with arith.
  rewrite HD'; simpl in |- *.
  unfold b in |- *; apply upper_bound.
  unfold R in |- *.
  rewrite HD; rewrite HD'.
  rewrite Non_empty_Hd; rewrite Non_empty_Hd; auto with arith.
  try trivial with arith.
  Qed.

 End Three_inputs.

End factorization.

