
Require Export Lists_of_lists.
(* Lists_of_lists:
Require Import Dependent_lists.

Section Lists_of_lists.

  Definition list_of_heads (A : Set) (i : nat) :=
    map (list A (S i)) A (Head A i).

  Definition list_of_tails (A : Set) (i : nat) :=
    map (list A i) (list A (pred i)) (tl A i).

End Lists_of_lists. *)
Require Export Numerals.
(* Numerals:
Require Export Dependent_lists.
Require Export Lib_Arith.

Definition Inj (A : Set) (P : A -> Prop) (e : {x : A | P x}) :=
  let (a, _) return A := e in a.

Fixpoint exp (e x : nat) {struct x} : nat :=
  match x with
  | O => 1
  | S p => e * exp e p
  end.

Section Numerals.

  Definition BT := {b : nat | 0 < b}.
  Variable BASE : BT.
  Definition base := Inj nat (fun b : nat => 0 < b) BASE.
  Definition digit := {x : nat | x < base}.
  Definition val : digit -> nat := Inj nat (fun x : nat => x < base).
  Definition num := list digit.
  Definition inf (n : nat) := {x : nat | x < n}.
  Definition val_inf (n : nat) : inf n -> nat :=
    Inj nat (fun x : nat => x < n).
  Let Cons := cons digit.
  Let Nil := nil digit.

  Fixpoint Val (n : nat) (X : num n) {struct X} : nat :=
    match X with
    | nil => 0
    | cons p xp X' => val xp * exp base p + Val p X'
    end.

  Lemma Val_val : forall x : digit, Val 1 (Cons 0 x Nil) = val x.

  Lemma upper_bound : forall (n : nat) (X : num n), Val n X < exp base n.

  Definition val_bound (n : nat) (X : num n) : inf (exp base n) :=
    exist (fun p : nat => p < exp base n) (Val n X) (upper_bound n X).

  Lemma comp_dif :
   forall (n : nat) (x y : digit) (X Y : num n),
   val x < val y -> Val (S n) (Cons n x X) < Val (S n) (Cons n y Y).

  Lemma comp_eq_most :
   forall (n : nat) (x y : digit) (X Y : num n),
   val x = val y ->
   Val n X < Val n Y -> Val (S n) (Cons n x X) < Val (S n) (Cons n y Y).

  Lemma com_eq :
   forall (n : nat) (x y : digit) (X Y : num n),
   val x = val y ->
   Val n X = Val n Y -> Val (S n) (Cons n x X) = Val (S n) (Cons n y Y).

End Numerals. *)

Section lists_of_numerals.

  Variable BASE : BT.
  Let b := base BASE.
  Let Digit := digit BASE.
  Let Num := num BASE.
  Let Val_bound := val_bound BASE.

  Definition val_first_components (n i : nat)
    (X : list (list Digit (S i)) n) :=
    Val_bound n (list_of_heads Digit i n X).

  Fixpoint list_of_values (n i : nat) {struct i} :
   list (list Digit i) n -> list (inf (exp b n)) i :=
    match
      i as x return (list (list Digit x) n -> list (inf (exp b n)) x)
    with
    | O => fun l : list (list Digit 0) n => nil (inf (exp b n))
    | S p =>
        fun l : list (list Digit (S p)) n =>
        cons (inf (exp b n)) p (val_first_components n p l)
          (list_of_values n p (list_of_tails Digit (S p) n l))
    end.

End lists_of_numerals.