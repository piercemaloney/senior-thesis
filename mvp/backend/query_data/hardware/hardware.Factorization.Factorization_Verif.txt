
Require Export Linear_Structures. 
(* Linear_Structures:
Require Export Dependent_lists.

Section Linear_Structures.

  Variable A B C : Set.
  Variable cell : A -> B -> C -> A -> Prop.

  Inductive connection :
  forall n : nat, A -> list B n -> list C n -> A -> Prop :=
    | C_O : forall a : A, connection 0 a (nil B) (nil C) a
    | C_Sn :
        forall (n : nat) (a a1 a' : A) (b : B) (c : C) 
          (lb : list B n) (lc : list C n),
        cell a b c a1 ->
        connection n a1 lb lc a' ->
        connection (S n) a (cons B n b lb) (cons C n c lc) a'.

End Linear_Structures. *)
Require Export Factorization.
(* Factorization:
Require Export Numerals.

Section factorization.

   Variable A : Set.
   Variable BASE : BT.
   Let b := base BASE.
   Let Num := num BASE.
   Let Digit := digit BASE.
   Let Tl := tl Digit.

   Let Cons := cons Digit.
   Let Nil := nil Digit.
   Let Val_bound := val_bound BASE.

 Section Definitions_for_Relations.
   
   Definition Diveucl (a b q r : nat) : Prop := a = b * q + r /\ r < b.
   Definition Zero : inf 1 := Val_bound 0 Nil.

   Variable R : forall n : nat, A -> inf n -> inf n -> A -> Prop.
         
   Definition factorizable : Prop :=
     forall (m n : nat) (q q' : inf m) (r r' : inf n) 
       (a a1 a' : A) (x x' : inf (m * n)),
     Diveucl (val_inf (m * n) x) n (val_inf m q) (val_inf n r) ->
     Diveucl (val_inf (m * n) x') n (val_inf m q') (val_inf n r') ->
     R m a q q' a1 -> R n a1 r r' a' -> R (m * n) a x x' a'.

    Definition proper : Prop := forall a : A, R 1 a Zero Zero a.

 End Definitions_for_Relations.

 Section Three_inputs.

  Variable FR : forall n : nat, A -> inf n -> inf n -> A.

  Let R (n : nat) (a : A) (x y : inf n) (a' : A) : Prop := a' = FR n a x y.

  Lemma prop_Rel :
   proper R ->
   forall (X Y : Num 0) (a : A), R 1 a (Val_bound 0 X) (Val_bound 0 Y) a.

   Lemma fact_Rel :
    factorizable R ->
    forall (n : nat) (X Y : Num (S n)) (a a' : A),
    R (exp b n) (FR b a (Hd Digit n X) (Hd Digit n Y))
      (Val_bound n (Tl (S n) X)) (Val_bound n (Tl (S n) Y)) a' ->
    R (exp b (S n)) a (Val_bound (S n) X) (Val_bound (S n) Y) a'.

 End Three_inputs.

End factorization. *)

Section Factorization_for_Verification.

  Variable A : Set.
  Variable BASE : BT.
  Let b := base BASE.
  Let Num := num BASE.
  Let Digit := digit BASE.
  Let Val_bound := val_bound BASE.
             
  Variable R : forall n : nat, A -> inf n -> inf n -> A -> Prop.

  Definition Connection := connection A Digit Digit (R b).

  Notation Factorizable := (factorizable _) (only parsing).
  Notation Proper := (proper _) (only parsing).

  Theorem factorization_for_verification :
   factorizable _ R ->
   proper _ BASE R ->
   forall (n : nat) (X Y : Num n) (a a' : A),
   Connection n a X Y a' -> R (exp b n) a (Val_bound n X) (Val_bound n Y) a'.
    intros F P.
    simple induction 1.
    unfold proper in P; auto.
    clear H X Y n a a'.
    intros n a a1 a' d d' D D' H C H_rec.
    simpl in |- *.
    apply F with d d' (Val_bound n D) (Val_bound n D') a1;
     try trivial; unfold Diveucl in |- *; 
     split; simpl in |- *.
    elim (mult_comm (exp (base BASE) n) (val BASE d)); unfold val in |- *;
     unfold val_inf in |- *; auto.
    unfold b in |- *; apply upper_bound.
    elim (mult_comm (exp (base BASE) n) (val BASE d')); unfold val in |- *;
     unfold val_inf in |- *; auto.
    unfold b in |- *; apply upper_bound.
    Qed.

End Factorization_for_Verification.

