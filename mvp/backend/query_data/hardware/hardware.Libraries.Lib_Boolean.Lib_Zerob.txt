
Require Export Lib_Bool.
(* Lib_Bool:
Require Export Bool.
Require Export IfProp.

Require Export Zerob.

Lemma bool_dec : forall b : bool, {b = true} + {b = false}.
Hint Resolve bool_dec.

Lemma orb_sym : forall a b : bool, a || b = b || a.
Hint Immediate orb_sym.

Lemma orb_false : forall a b : bool, a || b = false -> a = false /\ b = false.
Hint Resolve orb_false.

Lemma orb_false_l : forall a b : bool, a || b = false -> a = false.

Lemma orb_false_r : forall a b : bool, a || b = false -> b = false.

Lemma true_orb_intro :
 forall b1 b2 : bool, b1 || b2 = true -> b1 = true \/ b2 = true.

Lemma and_sym : forall a b : bool, a && b = b && a.
Hint Immediate and_sym.

Lemma andb_false :
 forall a b : bool,
 a && b = false ->
 a = false /\ b = false \/ a = false /\ b = true \/ a = true /\ b = false.

Lemma andb_true : forall a b : bool, a && b = true -> a = true /\ b = true.

Lemma andb_true_l : forall a b : bool, a && b = true -> a = true.

Lemma andb_true_r : forall a b : bool, a && b = true -> b = true.

Lemma andb_negb_true_r : forall a b : bool, a && negb b = true -> b = false.

Lemma andb_negb_true_l : forall a b : bool, negb a && b = true -> a = false.

Lemma no_true_false : forall b : bool, b = false -> b <> true.
Hint Resolve no_true_false.

Definition if_bool (C : Set) (b : bool) (x y : C) : C :=
  match b return C with
  | true => x
  | false => y
  end.
Notation If := (if_bool _) (only parsing). *)
Require Export Lib_Prop.
(* Lib_Prop:
Inductive or3 (A B C : Prop) : Set :=
  | or3_Left : A -> or3 A B C
  | or3_Middle : B -> or3 A B C
  | or3_Right : C -> or3 A B C.

Lemma sym_and : forall A B : Prop, A /\ B -> B /\ A.
Hint Immediate sym_and.

Lemma sym_or : forall A B : Prop, A \/ B -> B \/ A.
Hint Immediate sym_or.

Lemma no_and_l : forall A B : Prop, ~ A -> ~ (A /\ B).
Hint Resolve no_and_l.

Lemma no_and_r : forall A B : Prop, ~ B -> ~ (A /\ B).
Hint Resolve no_and_r.

Lemma no_or : forall A B : Prop, ~ A -> B \/ A -> B.

Lemma no_or_inv : forall A B : Prop, ~ A -> A \/ B -> B.

Lemma no_or_and : forall A B C D : Prop, ~ C -> A /\ B \/ C /\ D -> A /\ B.

Lemma no_or_and_inv :
 forall A B C D : Prop, ~ D -> C /\ D \/ A /\ B -> A /\ B.

Lemma no_no_A : forall A : Prop, A -> ~ ~ A.
Hint Resolve no_no_A.

Lemma impl_no_no : forall A B : Prop, (A -> B) -> ~ B -> ~ A.

Lemma no_or_r : forall A B : Prop, ~ A -> A \/ B -> B.

Lemma no_or_l : forall A B : Prop, ~ B -> A \/ B -> A. *)
Require Export Lib_Set_Products.
(* Lib_Set_Products:
Lemma pair_fst_snd : forall (A B : Set) (c : A * B), (fst c, snd c) = c.

Inductive prod_3 (A B C : Set) : Set :=
    triplet : A -> B -> C -> prod_3 A B C.

Section programming_3.
        
Variable A B C : Set.

Theorem fst_3 : prod_3 A B C -> A.

Theorem snd_3 : prod_3 A B C -> B.

Theorem thd_3 : prod_3 A B C -> C.

End programming_3.

Notation Fst_3 := (fst_3 _ _ _) (only parsing).
Notation Snd_3 := (snd_3 _ _ _) (only parsing).
Notation Thd_3 := (thd_3 _ _ _) (only parsing).
Notation Triplet := (triplet _ _ _) (only parsing).

Lemma triplet_fst_snd_thd :
 forall (A B C : Set) (c : prod_3 A B C),
 triplet _ _ _ (fst_3 _ _ _ c) (snd_3 _ _ _ c) (thd_3 _ _ _ c) = c.

Definition ifProp (C : Type) (b : bool) (x y : C) : C :=
  match b return C with
  | true => x
  | false => y
  end.

Lemma ifProp_or : forall (b : bool) (P Q : Prop), ifProp Prop b P Q -> P \/ Q. *)
Require Export Lt.

Lemma zerob_If :
 forall (b : bool) (x y : nat),
 zerob (if_bool _ b x y) = true -> x <> 0 -> b = false.
simple induction b; simpl in |- *; intros; auto.
absurd (x <> 0).
apply no_no_A; apply zerob_true_elim; auto.
trivial.
Qed.

Lemma lt_no_zerob : forall n : nat, 0 < n -> zerob n <> true.
simple induction n; [ intros; inversion H | auto ]. 
Qed.
Hint Resolve lt_no_zerob.

Lemma zerob_pred_no : forall n : nat, zerob (pred n) = false -> n <> 0.
simple induction n; auto with bool.
Qed.
Hint Resolve zerob_pred_no.

Lemma zerob_lt : forall n : nat, zerob n = false -> 0 < n.
simple induction n.
simpl in |- *; intro.
absurd (true = false); auto with bool.
intros.
auto with arith.
Qed.
Hint Resolve zerob_lt.

Lemma no_zerob_true : forall n : nat, n <> 0 -> zerob n <> true.
simple induction n; auto.
Qed.
Hint Resolve no_zerob_true.

Lemma x_1_or_y_0 :
 forall x y : nat,
 zerob (pred x) || zerob y = true -> x <> 0 -> x = 1 \/ y = 0.
simple induction x; simple induction y.
intros; right; try trivial.
intros.
absurd (0 <> 0); auto with arith.
right; auto.
simpl in |- *.
elim orb_sym; simpl in |- *; intros.
left; replace n with 0.
try trivial.
apply sym_equal; apply zerob_true_elim; try trivial.
Qed.

Lemma zerob_pred_false :
 forall n : nat, zerob (pred n) = false -> zerob n = false.
simple induction n; auto.
Qed.
Hint Resolve zerob_pred_false.

