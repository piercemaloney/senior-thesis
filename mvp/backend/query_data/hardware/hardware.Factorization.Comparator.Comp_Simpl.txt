
Require Export Numerals.
(* Numerals:
Require Export Dependent_lists.
Require Export Lib_Arith.

Definition Inj (A : Set) (P : A -> Prop) (e : {x : A | P x}) :=
  let (a, _) return A := e in a.

Fixpoint exp (e x : nat) {struct x} : nat :=
  match x with
  | O => 1
  | S p => e * exp e p
  end.

Section Numerals.

  Definition BT := {b : nat | 0 < b}.
  Variable BASE : BT.
  Definition base := Inj nat (fun b : nat => 0 < b) BASE.
  Definition digit := {x : nat | x < base}.
  Definition val : digit -> nat := Inj nat (fun x : nat => x < base).
  Definition num := list digit.
  Definition inf (n : nat) := {x : nat | x < n}.
  Definition val_inf (n : nat) : inf n -> nat :=
    Inj nat (fun x : nat => x < n).
  Let Cons := cons digit.
  Let Nil := nil digit.

  Fixpoint Val (n : nat) (X : num n) {struct X} : nat :=
    match X with
    | nil => 0
    | cons p xp X' => val xp * exp base p + Val p X'
    end.

  Lemma Val_val : forall x : digit, Val 1 (Cons 0 x Nil) = val x.

  Lemma upper_bound : forall (n : nat) (X : num n), Val n X < exp base n.

  Definition val_bound (n : nat) (X : num n) : inf (exp base n) :=
    exist (fun p : nat => p < exp base n) (Val n X) (upper_bound n X).

  Lemma comp_dif :
   forall (n : nat) (x y : digit) (X Y : num n),
   val x < val y -> Val (S n) (Cons n x X) < Val (S n) (Cons n y Y).

  Lemma comp_eq_most :
   forall (n : nat) (x y : digit) (X Y : num n),
   val x = val y ->
   Val n X < Val n Y -> Val (S n) (Cons n x X) < Val (S n) (Cons n y Y).

  Lemma com_eq :
   forall (n : nat) (x y : digit) (X Y : num n),
   val x = val y ->
   Val n X = Val n Y -> Val (S n) (Cons n x X) = Val (S n) (Cons n y Y).

End Numerals. *)
Require Export Compare_Num.
(* Compare_Num:
Require Export Numerals.
Require Export Compare_Nat.

Section compare_num.

  Variable BASE : BT.
  Let Digit := digit BASE.
  Let valB := val BASE.
  Let ValB := Val BASE.
  Let Num := num BASE.
  Let Val_bound := val_bound BASE.
  Let Cons := cons Digit.
  Let Nil := nil Digit.

  Lemma Comp_dif :
   forall (n : nat) (x y : Digit) (X Y : Num n),
   valB x < valB y ->
   Compare_Nat.comparison (ValB (S n) (Cons n x X)) (ValB (S n) (Cons n y Y)) =
  Hint Resolve Comp_dif.

  Lemma Comp_eq :
   forall (n : nat) (x y : Digit) (X Y : Num n),
   valB x = valB y ->
   Compare_Nat.comparison (ValB (S n) (Cons n x X)) (ValB (S n) (Cons n y Y)) =

End compare_num.

Hint Resolve Comp_eq.
Hint Resolve Comp_dif. *)
Require Export Linear_Structures.
(* Linear_Structures:
Require Export Dependent_lists.

Section Linear_Structures.

  Variable A B C : Set.
  Variable cell : A -> B -> C -> A -> Prop.

  Inductive connection :
  forall n : nat, A -> list B n -> list C n -> A -> Prop :=
    | C_O : forall a : A, connection 0 a (nil B) (nil C) a
    | C_Sn :
        forall (n : nat) (a a1 a' : A) (b : B) (c : C) 
          (lb : list B n) (lc : list C n),
        cell a b c a1 ->
        connection n a1 lb lc a' ->
        connection (S n) a (cons B n b lb) (cons C n c lc) a'.

End Linear_Structures. *)

Section comparator.

  Variable BASE : BT.
  Let Digit := digit BASE.
  Let valB := val BASE.
  Let ValB := Val BASE.
  Let Num := num BASE.
  Let Val_bound := val_bound BASE.
  Let Cons := cons Digit.
  Let Nil := nil Digit.

  Let f_cell (o : order) (x y : Digit) : order :=
    match o return order with
    | L => L
    | E => Compare_Nat.comparison (valB x) (valB y)
    | G => G
    end.

  Inductive cell : order -> Digit -> Digit -> order -> Prop :=
      cell_constr :
        forall (o o' : order) (x y : Digit),
        o' = f_cell o x y -> cell o x y o'.

  Let f_circ (n : nat) (o : order) (X Y : Num n) : order :=
    match o return order with
    | L => L
    | E => Compare_Nat.comparison (ValB n X) (ValB n Y)
    | G => G
    end.			

  Let Connection := connection order Digit Digit cell.
  Let Comparator (n : nat) (o : order) (X Y : Num n) := Connection n E X Y o.

  Let Specif (n : nat) (X Y : inf n) : order :=
    Compare_Nat.comparison (val_inf n X) (val_inf n Y).

  Remark general_correct :
   forall (n : nat) (X Y : Num n) (o o' : order),
   Connection n o X Y o' -> o' = f_circ n o X Y.
  simple induction 1.
  clear H o' o Y X n.
  intros o; case o; simpl in |- *; auto.
  auto.

  clear H o' o Y X n.
  intros n o o1 o' x y X Y H_cell H_n H_rec.
  inversion_clear H_cell.
  rewrite H_rec; rewrite H.
  cut (o = o); auto.
  pattern o at 2 3 in |- *; case o; intros e; rewrite e;
   unfold f_cell in |- *; unfold f_circ in |- *; auto.
  cut
   (Compare_Nat.comparison (valB x) (valB y) =
    Compare_Nat.comparison (valB x) (valB y)); auto.
  pattern (Compare_Nat.comparison (valB x) (valB y)) at 2 3 in |- *;
   case (Compare_Nat.comparison (valB x) (valB y)); 
   intros C; apply sym_equal; unfold ValB in |- *; 
   unfold Digit in |- *; auto.
  Qed.

  Remark correctness :
   forall (n : nat) (X Y : Num n) (o : order),
   Comparator n o X Y ->
   o = Specif (exp (base BASE) n) (Val_bound n X) (Val_bound n Y).
  unfold Comparator in |- *; unfold Specif in |- *.
  intros n X Y o H. rewrite (general_correct n X Y E o H).
  auto.
  Qed.

End comparator.

