
Require Export Dependent_lists.
(* Dependent_lists:
Require Export Eqdep.
Require Export Arith.

Global Set Asymmetric Patterns.
Section Dependent_lists.

  Variable A : Set.

  Inductive list : nat -> Set :=
    | nil : list 0
    | cons : forall n : nat, A -> list n -> list (S n).

  Definition eq_list := eq_dep nat list.

  Definition hd (n : nat) (l : list n) : Exc A :=
    match l in (list m) return (Exc A) with
    | nil => error
    | cons p a l' => value a
    end.

  Definition head (n : nat) (l : list n) :=
    match l in (list p) return (0 < p -> A) with
    | nil =>
        	
        fun h : 0 < 0 => False_rec A (lt_irrefl 0 h)
        
    | cons p a l' => fun h : 0 < S p => a
    end.

  Definition Head (n : nat) (l : list (S n)) := head (S n) l (lt_O_Sn n).

  Definition tl (n : nat) (l : list n) : list (pred n) :=
    match l in (list m) return (list (pred m)) with
    | nil => nil
    | cons p a l' => l'
    end.

  Lemma empty_dep : forall (n : nat) (l : list n), n = 0 -> eq_list 0 nil n l.

  Hint Resolve empty_dep.

  Lemma empty : forall l : list 0, nil = l.

  Hint Resolve empty.

  Remark non_empty_dep :
   forall n m : nat,
   m = S n ->
   forall l : list (S n),
   {h : A &  {t : list n | eq_list (S n) l (S n) (cons n h t)}}.

  Lemma non_empty :
   forall (n : nat) (l : list (S n)),
   {a : A &  {t : list n | l = cons n a t}}. 

  Lemma split_list :
   forall (n : nat) (l : list (S n)),
   l = cons n (head (S n) l (lt_O_Sn n)) (tl (S n) l).

  Definition Hd (n : nat) (l : list (S n)) :=
    let (a, P) return A := non_empty n l in a.

  Lemma Non_empty_Hd :
   forall (n : nat) (a : A) (l : list n), Hd n (cons n a l) = a.

End Dependent_lists.

Hint Resolve empty_dep empty non_empty Non_empty_Hd.

Fixpoint map (A B : Set) (f : A -> B) (n : nat) (l : list A n) {struct l} :
 list B n :=
  match l in (list _ x) return (list B x) with
  | nil =>
        nil B
       
  | cons p a t => cons B p (f a) (map A B f p t)
  end. *)

Section Linear_Structures.

  Variable A B C : Set.
  Variable cell : A -> B -> C -> A -> Prop.

  Inductive connection :
  forall n : nat, A -> list B n -> list C n -> A -> Prop :=
    | C_O : forall a : A, connection 0 a (nil B) (nil C) a
    | C_Sn :
        forall (n : nat) (a a1 a' : A) (b : B) (c : C) 
          (lb : list B n) (lc : list C n),
        cell a b c a1 ->
        connection n a1 lb lc a' ->
        connection (S n) a (cons B n b lb) (cons C n c lc) a'.

End Linear_Structures.

