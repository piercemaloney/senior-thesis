

Require Import Factorization_Synth.
(* Factorization_Synth:
Require Export Factorization.

 Section Factorization_for_Synthesis.
 
   Variable A : Set.
   Variable BASE : BT.
   Let b := base BASE.
   Let Num := num BASE.
   Let Digit := digit BASE.
   Let Val_bound := val_bound BASE.
   Definition Tl := tl Digit.

   Variable FR : forall n : nat, A -> inf n -> inf n -> A.

   Let R (n : nat) (a : A) (x y : inf n) (a' : A) : Prop := a' = FR n a x y.

   Notation Factorizable := (factorizable _) (only parsing).
   Notation Proper := (proper _) (only parsing).

   Theorem factorization_for_synthesis :
    factorizable _ R ->
    proper _ BASE R ->
    forall (n : nat) (X Y : Num n) (a : A),
    {a' : A | R (exp b n) a (Val_bound n X) (Val_bound n Y) a'}.

End Factorization_for_Synthesis. *)

Require Import Comparator_Relation.
(* Comparator_Relation:
Require Export Compare_Nat.
Require Export Factorization.
Require Export Compare_Num.

Section Comparator_Rel.
   
   Variable BASE : BT.
   
   Definition FR (n : nat) (o : order) (x y : inf n) : order :=
     match o return order with
     | L => L
     | E => Compare_Nat.comparison (val_inf n x) (val_inf n y)
     | G => G
     end.

   Definition R (n : nat) (o : order) (x y : inf n) 
     (o' : order) : Prop := o' = FR n o x y.
   
  Notation Proper := (proper _) (only parsing).

Lemma is_proper : proper _ BASE R.

  Notation Factorizable := (factorizable _) (only parsing).

Lemma is_factorizable : factorizable _ R.

End Comparator_Rel. *)



Parameter BASE : BT.

Definition b := base BASE.

Definition Num := num BASE.

Definition Val_bound := val_bound BASE.

 

Lemma Comparator :

 forall (n : nat) (o : order) (X Y : Num n),

 {o' : order | R (exp b n) o (Val_bound n X) (Val_bound n Y) o'}.

intros n o X Y.

unfold R in |- *; unfold b in |- *; unfold Val_bound in |- *.

apply factorization_for_synthesis.

exact is_factorizable.

exact (is_proper BASE).

Defined.



