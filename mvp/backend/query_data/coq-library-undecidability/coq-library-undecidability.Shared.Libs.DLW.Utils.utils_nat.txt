

Require Import List Arith Max Omega Wellfounded Bool.



Require Import list_focus utils_tac utils_list.
(* list_focus:
Require Import List.
Require Import Permutation.

Require Import focus utils_tac.

Ltac focus_g x ll :=
  let rr := focus_lst x ll
  in  cutrewrite ( ll = rr );
      [ idtac | solve_list_eq ].

Ltac focus_g_2 x ll :=
  let rr := focus_lst_2 x ll
  in  cutrewrite ( ll = rr );
      [ idtac | solve_list_eq ].

Ltac focus_g_3 x ll :=
  let rr := focus_lst_3 x ll
  in  cutrewrite ( ll = rr );
      [ idtac | solve_list_eq ].

Ltac focus_h H x ll := 
  let rr := focus_lst x ll
  in  cutrewrite ( ll = rr ) in H;
      [ idtac | solve_list_eq ].

Ltac focus_h_2 H x ll := 
  let rr := focus_lst_2 x ll
  in  cutrewrite ( ll = rr ) in H;
      [ idtac | solve_list_eq ].

Ltac focus_h_3 H x ll := 
  let rr := focus_lst_3 x ll
  in  cutrewrite ( ll = rr ) in H;
      [ idtac | solve_list_eq ].

Ltac focus_goal x ll :=
  match type of x with
    | list _ => focus_g x ll
    | _      => focus_g (x::nil) ll
  end.

Ltac focus_goal_2 x ll :=
  match type of x with
    | list _ => focus_g_2 x ll
    | _      => focus_g_2 (x::nil) ll
  end.

Ltac focus_goal_3 x ll :=
  match type of x with
    | list _ => focus_g_3 x ll
    | _      => focus_g_3 (x::nil) ll
  end.

Ltac focus_hyp H x ll :=
  match type of x with
    | list _ => focus_h H x ll
    | _      => focus_h H (x::nil) ll 
  end.

Ltac focus_hyp_2 H x ll :=
  match type of x with
    | list _ => focus_h_2 H x ll
    | _      => focus_h_2 H (x::nil) ll 
  end.

Ltac focus_hyp_3 H x ll :=
  match type of x with
    | list _ => focus_h_3 H x ll
    | _      => focus_h_3 H (x::nil) ll 
  end.

Ltac chg_goal x :=
  match goal with
    | |- context[?hh] => match type of hh with list _ => focus_goal x hh end
  end.

Ltac chg_goal_2 x :=
  match goal with
    | |- context[?hh] => match type of hh with list _ => focus_goal_2 x hh end
  end.

Ltac chg_goal_3 x :=
  match goal with
    | |- context[?hh] => match type of hh with list _ => focus_goal_3 x hh end
  end.

Ltac chg_hyp H x :=
  let gg := fresh 
  in match goal with 
       |- ?G => set (gg := G)
     end;
     generalize H;
     match goal with 
       | |- context[?hh] => intros _; 
                            match type of hh with 
                              | list _ => focus_hyp H x hh 
                            end
     end; 
     unfold gg; 
     clear gg.

Ltac chg_hyp_2 H x :=
  let gg := fresh 
  in match goal with 
       |- ?G => set (gg := G)
     end;
     generalize H;
     match goal with 
       | |- context[?hh] => intros _; 
                            match type of hh with 
                              | list _ => focus_hyp_2 H x hh 
                            end
     end; 
     unfold gg; 
     clear gg.

Ltac chg_hyp_3 H x :=
  let gg := fresh 
  in match goal with 
       |- ?G => set (gg := G)
     end;
     generalize H;
     match goal with 
       | |- context[?hh] => intros _; 
                            match type of hh with 
                              | list _ => focus_hyp_3 H x hh 
                            end
     end; 
     unfold gg; 
     clear gg.

Tactic Notation "focus" constr(X) := chg_goal X.
Tactic Notation "focus" constr(X) "in" hyp(H) := chg_hyp H X. 

Tactic Notation "focus" constr(X) "at" "2" := chg_goal_2 X.
Tactic Notation "focus" constr(X) "in" hyp(H) "at" "2" := chg_hyp_2 H X. 

Tactic Notation "focus" constr(X) "at" "3" := chg_goal_3 X.
Tactic Notation "focus" constr(X) "in" hyp(H) "at" "3" := chg_hyp_3 H X. *)
(* utils_tac:
Require Import Arith List Wellfounded.

Set Implicit Arguments.

Definition eqdec X := forall x y : X, { x = y } + { x <> y }.

Definition swap {X Y} (c : X * Y) := let (x,y) := c in (y,x).

Theorem measure_rect X (m : X -> nat) (P : X -> Type) :
      (forall x, (forall y, m y < m x -> P y) -> P x) -> forall x, P x.

Tactic Notation "induction" "on" hyp(x) "as" ident(IH) "with" "measure" uconstr(f) :=
  pattern x; revert x; apply measure_rect with (m := fun x => f); intros x IH.

Tactic Notation "eq" "goal" hyp(H) := 
  match goal with 
    |- ?b => match type of H with ?t => replace b with t; auto end 
  end.

Ltac eqgoal := let H := fresh in intro H; eq goal H; clear H.

Tactic Notation "spec" "in" hyp(H) :=
  let Q := fresh 
  in match goal with G: ?h -> _ |- _ => 
       match G with 
         | H => assert (h) as Q; [ | specialize (H Q); clear Q ] 
       end 
     end.

Ltac solve_list_eq := simpl; repeat progress (try rewrite app_ass; try rewrite <- app_nil_end; simpl; auto); auto.

Tactic Notation "solve" "list" "eq" := solve_list_eq.

Tactic Notation "solve_list_eq" "in" hyp(H) := generalize H; clear H; solve_list_eq; intro H.

Tactic Notation "solve" "list" "eq" "in" hyp(H) := 
   let Q := fresh in 
   match goal with 
     |- ?t => set (Q := t); generalize H; clear H; solve_list_eq; intro H; unfold Q; clear Q
   end.

Ltac msplit n := 
  match n with 
    | 0    => idtac 
    | S ?n => split; [ | msplit n ]
   end.

Tactic Notation "define" ident(f) "of" hyp(n) hyp(m) "as" uconstr(t)  :=
  match type of n with ?N =>  
    match type of m with ?M  => pose (f (n:N) (m:M) := t) end end.

Tactic Notation "induction" "on" hyp(x) hyp(y) "as" ident(IH) "with" "measure" uconstr(f) :=
  generalize I; intro IH;
  let mes := fresh "measure" in let rel := fresh "relation" in let loop := fresh "loop" in
  let u := fresh "u" in let u' := fresh x in let Hu := fresh "Hu" in 
  let v := fresh "v" in let v' := fresh y in let Hv := fresh "Hv" 
  in clear IH; 
     define mes of x y as (f : nat);
     set (rel u v := mes (fst u) (snd u) < mes (fst v) (snd v)); unfold fst, snd in rel;
     pattern x, y; match goal with
       |- ?T _ _ => 
       refine ((fix loop u v (Hu : Acc rel (u,v)) { struct Hu } : T u v := _) x y _);
       [ assert (forall u' v', rel (u',v') (u,v) -> T u' v') as IH;
         [ intros u' v' Hv; apply (loop u' v'), (Acc_inv Hu), Hv 
         | unfold rel, mes in *; clear mes rel Hu loop x y; rename u into x; rename v into y ]
       | unfold rel; apply wf_inverse_image, lt_wf ]
     end.

Section forall_equiv.

  Variable (X : Type) (A P Q : X -> Prop) (HPQ : forall n, A n -> P n <-> Q n).

  Theorem forall_bound_equiv : (forall n, A n -> P n) <-> (forall n, A n -> Q n).

End forall_equiv.

Section exists_equiv.

  Variable (X : Type) (P Q : X -> Prop) (HPQ : forall n, P n <-> Q n).

  Theorem exists_equiv : (exists n, P n) <-> (exists n, Q n).

End exists_equiv. *)
(* utils_list:
Require Import List Arith Omega Permutation.

Require Import list_focus utils_tac.

Set Implicit Arguments.

Create HintDb length_db.

Tactic Notation "rew" "length" := autorewrite with length_db.
Tactic Notation "rew" "length" "in" hyp(H) := autorewrite with length_db in H.

Infix "~p" := (@Permutation _) (at level 70).

Section length.
   
  Variable X : Type.

  Implicit Type l : list X.

  Fact length_nil : length (@nil X) = 0.

  Fact length_cons x l : length (x::l) = S (length l).

End length.

Hint Rewrite length_nil length_cons app_length map_length rev_length : length_db.

Section list_an.

  Fixpoint list_an a n :=
    match n with 
      | 0   => nil
      | S n => a::list_an (S a) n
    end.

  Fact list_an_S a n : list_an a (S n) = a::list_an (S a) n.

  Fact list_an_plus a n m : list_an a (n+m) = list_an a n ++ list_an (n+a) m.

  Fact list_an_length a n : length (list_an a n) = n.
  
  Fact list_an_spec a n m : In m (list_an a n) <-> a <= m < a+n.

  Fact map_S_list_an a n : map S (list_an a n) = list_an (S a) n.

  Fact list_an_app_inv a n l r : list_an a n = l++r -> l = list_an a (length l) /\ r = list_an (a+length l) (length r).

End list_an.

Hint Rewrite list_an_length : length_db.

Definition list_fun_inv X (l : list X) (x : X) : { f : nat -> X | l = map f (list_an 0 (length l)) }.

Fact list_upper_bound (l : list nat) : { m | forall x, In x l -> x < m }.

Section list_injective.

  Variable X : Type.
   
  Definition list_injective (ll : list X) :=  forall l a m b r, ll = l ++ a :: m ++ b :: r -> a <> b.
  
  Fact in_list_injective_0 : list_injective nil.
  
  Fact in_list_injective_1 x ll : ~ In x ll -> list_injective ll -> list_injective (x::ll).
  
  Fact list_injective_inv x ll : list_injective (x::ll) -> ~ In x ll /\ list_injective ll.
  
  Variable P : list X -> Type.
  
  Hypothesis (HP0 : P nil).
  Hypothesis (HP1 : forall x l, ~ In x l -> P l -> P (x::l)).
  
  Theorem list_injective_rect l : list_injective l -> P l.

End list_injective.

Fact list_injective_map X Y (f : X -> Y) ll :
       (forall x y, f x = f y -> x = y) -> list_injective ll -> list_injective (map f ll).

Section iter.
  
  Variable (X : Type) (f : X -> X).

  Fixpoint iter x n :=
    match n with
      | 0   => x
      | S n => iter (f x) n
    end.

  Fact iter_plus x a b : iter x (a+b) = iter (iter x a) b.

  Fact iter_swap x n : iter (f x) n = f (iter x n).

End iter.

Fixpoint list_repeat X (x : X) n :=
  match n with
    | 0   => nil
    | S n => x::list_repeat x n
  end.
  
Fact list_repeat_plus X x a b : @list_repeat X x (a+b) = list_repeat x a ++ list_repeat x b.
  
Fact list_repeat_length X x n : length (@list_repeat X x n) = n.

Fact In_list_repeat X (x y : X) n : In y (list_repeat x n) -> x = y /\ 0 < n.

Fact map_list_repeat X Y f x n : @map X Y f (list_repeat x n) = list_repeat (f x) n.

Fact map_cst_repeat X Y (y : Y) ll : map (fun _ : X => y) ll = list_repeat y (length ll).
  
Fact map_cst_snoc X Y (y : Y) ll mm : y :: map (fun _ : X => y) ll++mm = map (fun _ => y) ll ++ y::mm.

Fact map_cst_rev  X Y (y : Y) ll : map (fun _ : X => y) (rev ll) = map (fun _ => y) ll.

Fact In_perm X (x : X) l : In x l -> exists m, x::m ~p l.

Fact list_app_eq_inv X (l1 l2 r1 r2 : list X) :
       l1++r1 = l2++r2 -> { m | l1++m = l2 /\ r1 = m++r2 } 
                        + { m | l2++m = l1 /\ r2 = m++r1 }.

Fact list_app_cons_eq_inv X (l1 l2 r1 r2 : list X) x :
       l1++r1 = l2++x::r2 -> { m | l1++m = l2 /\ r1 = m++x::r2 } 
                           + { m | l2++x::m = l1 /\ r2 = m++r1 }.

Fact list_cons_app_cons_eq_inv X (l2 r1 r2 : list X) x y :
       x::r1 = l2++y::r2 -> (l2 = nil /\ x = y /\ r1 = r2) 
                          + { m | l2 = x::m /\ r1 = m++y::r2 }.
 
Fact list_app_inj X (l1 l2 r1 r2 : list X) : length l1 = length l2 -> l1++r1 = l2++r2 -> l1 = l2 /\ r1 = r2.

Fact list_split_length X (ll : list X) k : k <= length ll -> { l : _ & { r | ll = l++r /\ length l = k } }.

Fact list_pick X (ll : list X) k : k < length ll -> { x : _ & { l : _ & { r | ll = l++x::r /\ length l = k } } }.

Fact list_split_middle X l1 (x1 : X) r1 l2 x2 r2 : 
       ~ In x1 l2 -> ~ In x2 l1 -> l1++x1::r1 = l2++x2::r2 -> l1 = l2 /\ x1 = x2 /\ r1 = r2.

Section flat_map.

  Variable (X Y : Type) (f : X -> list Y).

  Fact flat_map_app l1 l2 : flat_map f (l1++l2) = flat_map f l1 ++ flat_map f l2.

  Fact flat_map_app_inv l r1 y r2 : flat_map f l = r1++y::r2 -> exists l1 m1 x m2 l2, l = l1++x::l2 /\ f x = m1++y::m2 
                                                                  /\ r1 = flat_map f l1++m1 /\ r2 = m2++flat_map f l2. 

End flat_map.

Definition prefix X (l ll : list X) := exists r, ll = l++r.
  
Infix "<p" := (@prefix _) (at level 70, no associativity).
  
Section prefix. 
   
  Variable X : Type.
  
  Implicit Types (l ll : list X).
  
  Fact in_prefix_0 ll : nil <p ll.
  
  Fact in_prefix_1 x l ll : l <p ll -> x::l <p x::ll.

  Fact prefix_length l m : l <p m -> length l <= length m.
  
  Fact prefix_app_lft l r1 r2 : r1 <p r2 -> l++r1 <p l++r2.
  
  Fact prefix_inv x y l ll : x::l <p y::ll -> x = y /\ l <p ll.
  
  Fact prefix_list_inv l r rr : l++r <p l++rr -> r <p rr.

  Fact prefix_refl l : l <p l.

  Fact prefix_trans l1 l2 l3 : l1 <p l2 -> l2 <p l3 -> l1 <p l3.

  Section prefix_rect.

    Variables (P : list X -> list X -> Type)
              (HP0 : forall ll, P nil ll)
              (HP1 : forall x l ll, l <p ll -> P l ll -> P (x::l) (x::ll)).
              
    Definition prefix_rect l ll : prefix l ll -> P l ll.
   
  End prefix_rect.

  Fact prefix_app_inv l1 l2 r1 r2 : l1++l2 <p r1++r2 -> { l1 <p r1 } + { r1 <p l1 }.
  
End prefix.

Definition prefix_spec X (l ll : list X) : l <p ll -> { r | ll = l ++ r }.

Fact prefix_app_lft_inv X (l1 l2 m : list X) : l1++l2 <p m -> { m2 | m = l1++m2 /\ l2 <p m2 }.

Section list_assoc.

  Variables (X Y : Type) (eq_X_dec : eqdec X).

  Fixpoint list_assoc x l : option Y :=
    match l with 
      | nil  => None
      | (y,a)::l => if eq_X_dec x y then Some a else list_assoc x l
    end.

  Fact list_assoc_eq x y l x' : x = x' -> list_assoc x' ((x,y)::l) = Some y.

  Fact list_assoc_neq x y l x' : x <> x' -> list_assoc x' ((x,y)::l) = list_assoc x' l.

  Fact list_assoc_In x l : 
    match list_assoc x l with 
      | None   => ~ In x (map fst l)
      | Some y => In (x,y) l
    end.

  Fact In_list_assoc x l : In x (map fst l) -> { y | list_assoc x l = Some y /\ In (x,y) l }.
  
  Fact not_In_list_assoc x l : ~ In x (map fst l) -> list_assoc x l = None.

  Fact list_assoc_app x ll mm : list_assoc x (ll++mm) 
                              = match list_assoc x ll with
                                  | None   => list_assoc x mm
                                  | Some y => Some y
                                end.

End list_assoc.

Section list_first_dec.

  Variable (X : Type) (P : X -> Prop) (Pdec : forall x, { P x } + { ~ P x }).
  
  Theorem list_choose_dec ll : { l : _ & { x : _ & { r | ll = l++x::r /\ P x /\ forall y, In y l -> ~ P y } } }
                             + { forall x, In x ll -> ~ P x }.
  
  Theorem list_first_dec a ll : P a -> In a ll -> { l : _ & { x : _ & { r | ll = l++x::r /\ P x /\ forall y, In y l -> ~ P y } } }.
  
End list_first_dec.

Section map.

  Variable (X Y : Type) (f : X -> Y).
  
  Fact map_cons_inv ll y m : map f ll = y::m -> { x : _ & { l | ll = x::l /\ f x = y /\ map f l = m } }.

  Fact map_app_inv ll m n : map f ll = m++n -> { l : _  & { r | ll = l++r /\ m = map f l /\ n = map f r } }.
  
  Fact map_middle_inv ll m y n : map f ll = m++y::n -> { l : _ & { x : _ & { r | ll = l++x::r /\ map f l = m /\ f x = y /\ map f r = n } } }.
  
End map.

Fact Forall2_mono X Y (R S : X -> Y -> Prop) :
         (forall x y, R x y -> S x y) -> forall l m, Forall2 R l m -> Forall2 S l m.

Fact Forall2_nil_inv_l X Y R m : @Forall2 X Y R nil m -> m = nil.

Fact Forall2_nil_inv_r X Y R m : @Forall2 X Y R m nil -> m = nil.

Fact Forall2_cons_inv X Y R x l y m : @Forall2 X Y R (x::l) (y::m) <-> R x y /\ Forall2 R l m.

Fact Forall2_app_inv_l X Y R l1 l2 m : 
    @Forall2 X Y R (l1++l2) m -> { m1 : _ & { m2 | Forall2 R l1 m1 /\ Forall2 R l2 m2 /\ m = m1++m2 } }.

Fact Forall2_app_inv_r X Y R l m1 m2 : 
    @Forall2 X Y R l (m1++m2) -> { l1 : _ & { l2 | Forall2 R l1 m1 /\ Forall2 R l2 m2 /\ l = l1++l2 } }.

Fact Forall2_cons_inv_l X Y R a ll mm : 
      @Forall2 X Y R (a::ll) mm 
   -> { b : _ & { mm' | R a b /\ mm = b::mm' /\ Forall2 R ll mm' } }.

Fact Forall2_cons_inv_r X Y R b ll mm : 
      @Forall2 X Y R ll (b::mm) 
   -> { a : _ & { ll' | R a b /\ ll = a::ll' /\ Forall2 R ll' mm } }.

Fact Forall2_map_left X Y Z (R : Y -> X -> Prop) (f : Z -> Y) ll mm : Forall2 R (map f ll) mm <-> Forall2 (fun x y => R (f x) y) ll mm.

Fact Forall2_map_right X Y Z (R : Y -> X -> Prop) (f : Z -> X) mm ll : Forall2 R mm (map f ll) <-> Forall2 (fun y x => R y (f x)) mm ll.

Fact Forall2_map_both X Y X' Y' (R : X -> Y -> Prop) (f : X' -> X) (g : Y' -> Y) ll mm : Forall2 R (map f ll) (map g mm) <-> Forall2 (fun x y => R (f x) (g y)) ll mm.

Fact Forall2_Forall X (R : X -> X -> Prop) ll : Forall2 R ll ll <-> Forall (fun x => R x x) ll.

Fact Forall_app X (P : X -> Prop) ll mm : Forall P (ll++mm) <-> Forall P ll /\ Forall P mm.

Fact Forall_cons_inv X (P : X -> Prop) x ll : Forall P (x::ll) <-> P x /\ Forall P ll.

Fact Forall_rev X (P : X -> Prop) ll : Forall P ll -> Forall P (rev ll).

Fact Forall_map X Y (f : X -> Y) (P : Y -> Prop) ll : Forall P (map f ll) <-> Forall (fun x => P (f x)) ll.

Fact Forall_forall_map X (f : nat -> X) n l (P : X -> Prop) :
           l = map f (list_an 0 n) -> (forall i, i < n -> P (f i)) <-> Forall P l.

Fact Forall_impl X (P Q : X -> Prop) ll : (forall x, In x ll -> P x -> Q x) -> Forall P ll -> Forall Q ll.

Fact Forall_filter X (P : X -> Prop) (f : X -> bool) ll : Forall P ll -> Forall P (filter f ll). *)



Set Implicit Arguments.



Section fin_reif.



  Variable (X : Type) (R : nat -> X -> Prop).



  Fact fin_reif n : (forall i, i < n -> exists x, R i x)

                 -> exists s, forall i (Hi : i < n), R i (s i Hi).

  Proof.

    revert R; induction n as [ | n IHn ]; intros R HR.

    + assert (s : forall x, x < 0 -> X) by (intros; omega).

      exists s; intros; omega.

    + destruct (HR 0) as (x & Hx); try omega.

      destruct IHn with (R := fun i x => R (S i) x) as (s & Hs).

      { intros; apply HR; omega. }

      exists (fun i => match i with 0 => fun _ => x | S i => fun Hi => s i (lt_S_n i n Hi) end).

      intros [ | i ] Hi; simpl; auto.

  Qed.



End fin_reif.



Fact fin_reif_nat (R : nat -> nat -> Prop) n :

         (forall i, i < n -> ex (R i)) -> exists s, forall i, i < n -> R i (s i).

Proof.

  intros HR.

  apply fin_reif in HR.

  destruct HR as (s & Hs).

  exists (fun i => match le_lt_dec n i with left _ => 0 | right H => s _ H end).

  intros i Hi; destruct (le_lt_dec n i); auto; omega.

Qed.



Section bounded_search.



  Theorem bounded_search m (P : nat -> Type) :

        (forall n, n < m -> P n + (P n -> False))

     -> { n : nat & (n < m) * P n }%type + { forall n, n < m -> P n -> False }.

  Proof.

    revert P; induction m as [ | m IHm ]; intros P HP.

    + right; intros; omega.

    + destruct (HP 0) as [ H0 | H0 ]; try omega.

      * left; exists 0; split; auto; omega.

      * destruct IHm with (P := fun n => P (S n)) as [ (n & H1 & H2) | H1 ].

        - intros; apply HP; omega.

        - left; exists (S n); split; auto; omega.

        - right; intros [ | n ] Hn; auto.

          apply H1; omega.

  Qed.



  Lemma bounded_min (P : nat -> Prop) : 

        (forall x, P x \/ ~ P x) 

     -> forall n, (exists k, k < n /\ P k /\ forall i, i < k -> ~ P i) \/ forall k, k < n -> ~ P k.

  Proof.

    intros HP.

    induction n as [ | n IHn ].

    + right; intros; omega.

    + destruct IHn as [ (k & H1 & H2 & H3) | H ].

      * left; exists k; repeat split; auto; omega.

      * destruct (HP n).

        - left; exists n; repeat split; auto.

        - right; intros k Hk.

          destruct (eq_nat_dec k n); subst; auto. 

          apply H; omega.

  Qed.



  Lemma minimize (P : nat -> Prop) : (forall x, P x \/ ~ P x) -> (exists n, P n) -> exists n, P n /\ forall i, i < n -> ~ P i.

  Proof.

    intros HP (n & Hn).

    destruct (@bounded_min _ HP (S n)) as [ (k & H1 & H2 & H3) | H ].

    + exists k; split; auto.

    + exfalso; apply H with n; auto.

  Qed.

   

  Lemma first_non_zero (f : nat -> nat) n : f 0 = 0 -> f n <> 0 -> exists i, i < n /\ (forall k, k <= i -> f k = 0) /\ f (i+1) <> 0.

  Proof.

    intros H0 H1.

    destruct (@minimize (fun i => f i <> 0)) as (i & H2 & H3).

    + intro; destruct (eq_nat_dec (f x) 0); omega.

    + exists n; auto.

    + assert (i <> 0) as Hi by (intro; subst; destruct H2; auto).

      exists (i-1); split; [ | split ].

      * destruct (le_lt_dec i n) as [ | H4 ]; try omega.

        apply H3 in H4; destruct H4; auto.

      * intros k Hk; generalize (H3 k); intros; omega.

      * replace (i-1+1) with i by omega; auto.

  Qed.



End bounded_search.



Fact interval_dec a b i : { a <= i < b } + { i < a \/ b <= i }.

Proof.

  destruct (le_lt_dec b i).

  right; omega.

  destruct (le_lt_dec a i).

  left; omega.

  right; omega.

Qed.



Definition lsum := fold_right plus 0.

Definition lmax := fold_right max 0.



Fact lmax_spec l x : lmax l <= x <-> Forall (fun y => y <= x) l.

Proof.

  revert x; induction l as [ | y l IHl ]; simpl.

  + split; auto; try omega.

  + intros x; rewrite Forall_cons_inv, <- IHl, Nat.max_lub_iff; tauto.

Qed.



Fact lsum_app l r : lsum (l++r) = lsum l+lsum r.

Proof.

  induction l as [ | x l IHl ]; simpl; auto; rewrite IHl; omega.

Qed.



Section new.



  Definition nat_new l := S (lmax l).



  Fact nat_new_spec l : ~ In (nat_new l) l.

  Proof.

    assert (forall x, In x l -> x < nat_new l) as H.

      induction l as [ | x l IHl ].

      intros _ [].

      intros y [ [] | Hy ]; apply le_n_S;

        [ apply le_max_l | ].

      apply IHl, le_S_n in Hy.

      apply le_trans with (1 := Hy), le_max_r.

    intros C; apply H in C; omega.

  Qed.



End new.



Local Notation Zero := false.

Local Notation One  := true.



Fixpoint div2 n : nat * bool :=

  match n with

    | 0 => (0,Zero)

    | 1 => (0,One)

    | S (S n) => let (p,b) := div2 n in (S p,b)

  end.



Fact div2_spec n : match div2 n with 

                     | (p,One)  => n = 2*p+1 

                     | (p,Zero) => n = 2*p

                   end.

Proof.

  induction n as [ [ | [ | n ] ] IHn ] using (well_founded_induction lt_wf); simpl; auto.

  specialize (IHn n).

  destruct (div2 n) as (p,[]); simpl in * |- *; omega.

Qed.



Fixpoint div2_2p1 p : div2 (2*p+1) = (p,One).

Proof.

  destruct p as [ | p ].

  simpl; auto.

  replace (2*S p+1) with (S (S (2*p+1))) by omega.

  unfold div2; fold div2; rewrite div2_2p1; auto.

Qed.



Fixpoint div2_2p0 p : div2 (2*p) = (p,Zero).

Proof.

  destruct p as [ | p ].

  simpl; auto.

  replace (2*S p) with (S (S (2*p))) by omega.

  unfold div2; fold div2; rewrite div2_2p0; auto.

Qed.



Fixpoint pow2 p := 

  match p with 

    | 0   => 1

    | S p => 2*pow2 p

  end.



Section pow2_bound.



  Let loop := fix loop x n :=

    match n with 

      | 0 => 0

      | S n => match div2 x with 

                 | (0,_) => 0

                 | (p,_) => S (loop p n)

               end

    end.



  Let loop_prop n : forall x, x < n -> x < pow2 (S (loop x n)).

  Proof.

    induction n as [ | n IHn ]; intros x Hx.

    omega.

    unfold loop; fold loop.

    generalize (div2_spec x).

    destruct (div2 x) as ([ | p ],[]); intros H.

    simpl; omega.

    simpl; omega.

    specialize (IHn (S p)); spec in IHn.

    omega.

    simpl in IHn |- *; omega.

    specialize (IHn (S p)); spec in IHn.

    omega.

    simpl in IHn |- *; omega.

  Qed.



  Definition find_pow2 x := S (loop (pred x) x).



  Fact find_pow2_geq x : 1 <= find_pow2 x.

  Proof. unfold find_pow2; omega. Qed.



  Fact find_pow2_prop x : x <= pow2 (find_pow2 x).

  Proof.

    unfold find_pow2; destruct x.

    simpl; omega.

    apply loop_prop; auto. 

  Qed.



End pow2_bound.



Section nat_sorted.

   

  Definition nat_sorted ll := forall l a m b r, ll = l ++ a :: m ++ b :: r -> a < b.

  

  Fact in_nat_sorted_0 : nat_sorted nil.

  Proof. intros [] ? ? ? ? ?; discriminate. Qed.

  

  Fact in_nat_sorted_1 x : nat_sorted (x::nil).

  Proof. intros [ | ? [] ] ? [] ? ? ?; discriminate. Qed.

  

  Fact in_nat_sorted_2 x y ll : x < y -> nat_sorted (y::ll) -> nat_sorted (x::y::ll).

  Proof.

    intros H1 H2 l a m b r H3.

    destruct l as [ | u l ].

    inversion H3; subst.

    destruct m as [ | v m ].

    inversion H4; subst; auto.

    inversion H4; subst.

    apply lt_trans with (1 := H1), (H2 nil _ m _ r); auto.

    inversion H3; subst.

    apply (H2 l _ m _ r); auto.

  Qed.

  

  Fact in_nat_sorted_3 x ll : Forall (lt x) ll -> nat_sorted ll -> nat_sorted (x::ll).

  Proof.

    induction 1 as [ | y ll Hll IHl ].

    intro; apply in_nat_sorted_1.

    intros H.

    apply in_nat_sorted_2; auto.

  Qed.

  

  Fact nat_sorted_cons_inv x ll : nat_sorted (x::ll) -> nat_sorted ll.

  Proof. intros H l a m b r ?; apply (H (x::l) _ m _ r); subst; solve list eq. Qed.

  

  Fact nat_sorted_Forall x ll : nat_sorted (x::ll) -> Forall (lt x) ll.

  Proof. 

    rewrite Forall_forall; intros H y Hy.

    apply in_split in Hy.

    destruct Hy as (l & r & ?); subst.

    apply (H nil _ l _ r); auto.

  Qed.

  

  Fact nat_sorted_head_inv x y ll : nat_sorted (x::y::ll) -> x < y.

  Proof. intros H; apply (H nil _ nil _ ll); solve list eq. Qed.



  Variable P : list nat -> Type.

  

  Hypothesis (HP0 : P nil).

  Hypothesis (HP1 : forall x, P (x::nil)).

  Hypothesis (HP2 : forall x y l, x < y -> P (y::l) -> P (x::y::l)).

  

  Theorem nat_sorted_rect l : nat_sorted l -> P l.

  Proof.

    induction l as [ [ | x [ | y l ] ] IHl ] using (measure_rect (@length _)).

    intro; apply HP0.

    intro; apply HP1.

    intros H; apply HP2. 

    revert H; apply nat_sorted_head_inv.

    apply IHl.

    rew length; omega.

    revert H; apply nat_sorted_cons_inv.

  Qed.

  

End nat_sorted.



Fact nat_sorted_injective ll : nat_sorted ll -> list_injective ll.

Proof.

  intros H l a m b r E; generalize (H _ _ _ _ _  E); omega.

Qed.



Fixpoint nat_list_insert x l :=

  match l with

    | nil  => x::nil

    | y::l => if x <? y then x::y::l else

              if y <? x then y::nat_list_insert x l else y::l

  end.



Fact nat_list_insert_length x l : length (nat_list_insert x l) <= S (length l).

Proof.

  induction l as [ | y l IHl ]; simpl.

  omega.

  destruct (x <? y); simpl; try omega.

  destruct (y <? x); simpl; omega.

Qed.

  

Fact nat_list_insert_incl x l : incl (nat_list_insert x l) (x::l)

                             /\ incl (x::l) (nat_list_insert x l).

Proof.

  split. 

  

  induction l as [ | y l IHl ]; simpl.

  intro; auto.

  destruct (x <? y); destruct (y <? x).

  intro; auto.

  intro; auto.

  intros ? [ [] | H ]; simpl; auto.

  apply IHl in H; simpl in H; tauto.

  intro; simpl; tauto.



  induction l as [ | y l IHl ]; simpl.

  intro; auto.

  generalize (Nat.ltb_lt x y) (Nat.ltb_lt y x).

  destruct (x <? y); destruct (y <? x); intros H1 H2 z; auto.

  intros [ Hz | [ Hz | Hz ] ]; subst.

  right; apply IHl; left; auto.

  left; auto.

  right; apply IHl; right; auto.

  destruct (lt_eq_lt_dec x y) as [ [ H | ] | H ].

  apply H1 in H; discriminate.

  2: apply H2 in H; discriminate.

  intros [ Hz | [ Hz | Hz ] ]; subst; auto.

  left; auto.

  left; auto.

  right; auto.

Qed.

  

Fact nat_list_insert_Forall (P : nat -> Prop) x l : 

      P x -> Forall P l -> Forall P (nat_list_insert x l).

Proof.

  do 2 rewrite Forall_forall; intros H1 H2 y Hy.

  apply nat_list_insert_incl in Hy.

  destruct Hy; subst; auto.

Qed.

  

Fact nat_list_insert_sorted x l : nat_sorted l -> nat_sorted (nat_list_insert x l).

Proof.

  induction l as [ | y l IHl ]; simpl.

  intro; apply in_nat_sorted_1.

  intros H.

  generalize (Nat.ltb_lt x y) (Nat.ltb_lt y x).

  destruct (x <? y); destruct (y <? x); intros H1 H2.

  apply proj1 in H1; spec in H1; auto.

  apply proj1 in H2; spec in H2; auto.

  omega.

  apply in_nat_sorted_2; auto; tauto.

  apply in_nat_sorted_3.

  apply nat_list_insert_Forall.

  tauto.

  apply nat_sorted_Forall; auto.

  apply IHl; revert H; apply nat_sorted_cons_inv.

  auto.

Qed.



Definition nat_sort := fold_right (nat_list_insert) nil.



Fact nat_sort_length l : length (nat_sort l) <= length l.

Proof.

  induction l as [ | x l IHl ]; simpl.

  omega.

  apply le_trans with (1 := nat_list_insert_length _ _); omega.

Qed.



Fact nat_sort_eq l : incl (nat_sort l) l /\ incl l (nat_sort l).

Proof.

  induction l as [ | x l IHl ]; simpl; split; intros y Hy; auto.

  apply nat_list_insert_incl in Hy; simpl.

  destruct Hy as [ | Hy ]; auto; right; apply IHl; auto.

  apply nat_list_insert_incl.

  destruct Hy; [ left | right ]; auto.

  apply IHl; auto.

Qed.



Fact nat_sort_sorted l : nat_sorted (nat_sort l).

Proof.

  induction l as [ | x l IHl ].

  apply in_nat_sorted_0.

  simpl; apply nat_list_insert_sorted; auto.

Qed.



Fact nat_sinc (f : nat -> nat) a b : 

      (forall x, a <= x < b -> f x < f (S x)) 

   -> (forall x y, a <= x < y /\ y <= b -> f x < f y).

Proof.

  intros H1.

  assert (forall n m, n <= m <= b - a -> f (a+n) <= f (a+m)) as H2.

    intros n m (H2 & H3); revert H2 H3.

    induction 1 as [ | m Hm IH ]; auto.

    intros H. spec in IH. omega.

    apply le_trans with (1 := IH).

    replace (a+S m) with (S (a+m)) by omega.

    apply lt_le_weak, H1; omega.

  assert (forall n m, n < m <= b - a -> f (a+n) < f (a+m)) as H3.

    unfold lt at 1; intros n m H.

    specialize (H1 (a+n)).

    spec in H1.

    omega.

    apply lt_le_trans with (1 := H1).

    replace (S (a+n)) with (a+S n) by omega.

    apply H2; auto.

  intros x y H4.

  replace x with (a+(x-a)) by omega.

  replace y with (a+(y-a)) by omega.

  apply H3.

  omega.

Qed.



Fact nat_sinc_inj f a b : 

      (forall x y,  a <= x < y /\ y <= b -> f x < f y) 

   -> (forall x y,  a <= x <= b -> a <= y <= b -> f x = f y -> x = y).

Proof.

  intros H0 x y Hx Hy.

  destruct Hx; destruct Hy.

  destruct (lt_eq_lt_dec x y) as [ [ ? | ? ] | ? ]; auto.

  specialize (H0 x y).

  spec in H0; repeat split; auto; intro; omega.

  specialize (H0 y x).

  spec in H0; repeat split; auto; intro; omega.

Qed.



Theorem nat_rev_ind (P : nat -> Prop) (HP : forall n, P (S n) -> P n) x y : x <= y -> P y -> P x.

Proof. induction 1; auto. Qed.



Section nat_rev_bounded_ind.



  Variables (k : nat) (P : nat -> Prop) (HP : forall n, S n <= k -> P (S n) -> P n).

  

  Fact nat_rev_bounded_ind x y : x <= y <= k -> P y -> P x.

  Proof.

    intros H1 H2.

    refine (proj1 (@nat_rev_ind (fun n => P n /\ n <= k) _ x y _ _)).

    clear x y H1 H2; intros n (H1 & H2); split; auto;omega.

    omega.

    split; auto; omega.

  Qed.



End nat_rev_bounded_ind.



Section nat_minimize.



  Variable P : nat -> Prop.

  Hypothesis HP : forall n, { P n } + { ~ P n }.



  Local Inductive bar_min (n : nat) : Prop :=

    | in_bar_min_0 : P n -> bar_min n

    | in_bar_min_1 : bar_min (S n) -> bar_min n.



  Section nat_min.



    Let min_rec : forall n, bar_min n -> { m | P m /\ forall x, P x -> x < n \/ m <= x }.

    Proof.

      refine (fix loop n Hn := match HP n with

        | left H  => exist _ n _

        | right H => match loop (S n) _ with

          | exist _ m Hm => exist _ m _

        end

      end).

      * split; auto; intros; omega.

      * destruct Hn; auto; destruct H; auto.

      * destruct Hm as [ H1 H2 ]; split; auto.

        intros x Hx; specialize (H2 x Hx).

        destruct (eq_nat_dec x n).

        - subst; tauto.

        - omega.

    Qed.



    Definition min_dec : (exists n, P n) -> { m | P m /\ forall x, P x -> m <= x }.

    Proof.

      intros H.

      destruct (@min_rec 0) as (m & H1 & H2).

      * destruct H as (n & Hn).

        apply in_bar_min_0 in Hn.

        revert Hn; apply nat_rev_ind.

        apply in_bar_min_1.

        omega.

      * exists m; split; auto.

        intros x Hx; specialize (H2 _ Hx); omega.

    Defined.



  End nat_min.



  Fact first_which : (exists x, P x) -> { m | P m /\ forall x, x < m -> ~ P x }.

  Proof.

    intros H.

    destruct (min_dec H) as (m & H1 & H2).

    exists m; split; auto.

    intros x Hx H3.

    apply H2 in H3.

    omega.

  Qed.



End nat_minimize.



Section first_which_ni.



  Variable P : nat -> Prop.



  Fact bounded_search_ni n : (forall i, i < n -> P i \/ ~ P i) -> (forall i, i < n -> ~ P i) \/ exists i, i < n /\ P i /\ forall j, j < i -> ~ P j.

  Proof.

    revert P; induction n as [ | n IHn ]; intros P HP.

    + left; intros; omega.

    + destruct (HP 0) as [ H | H ]; try omega.

      - right; exists 0; split; try omega; split; auto; intros; omega.

      - destruct IHn with (P := fun n => P (S n)) as [ H1 | (x & H1 & H2 & H3) ].

        * intros; apply HP; omega.

        * left; intros [] ?; auto; apply H1; omega.

        * right; exists (S x); split; try omega; split; auto.

          intros [] ?; auto; apply H3; omega.

  Qed.

  

  Hypothesis HP : forall n, P n \/ ~ P n.



  Fact first_which_ni : (exists x, P x) -> exists m, P m /\ forall x, x < m -> ~ P x.

  Proof.

    intros (n & Hn).

    destruct (@bounded_search_ni (S n)) as [ H1 | (m & H1 & H2 & H3) ].

    + intros; auto.

    + contradict Hn; apply H1; omega.

    + exists m; auto.

  Qed.



End first_which_ni.

