

Require Import Arith Nat Omega.

Require Import gcd.
(* gcd:
Require Import List Arith Omega Permutation.

Require Import utils_tac utils_list.

Set Implicit Arguments.

Section Euclid.

  Definition euclid n d : d <> 0 -> { q : nat & { r | n = q*d+r /\ r < d } }.

End Euclid.

Definition arem n d q j := j <= d /\ (n = 2*q*d+j \/ q <> 0 /\ n = 2*q*d-j).

Fact division_by_even n d : d <> 0 -> { q : nat & { j | arem n d q j } }.

Fact own_multiple x p : x = p*x -> x = 0 \/ p = 1.

Fact mult_is_one p q : p*q = 1 -> p = 1 /\ q = 1.

Definition divides n k := exists p, k = p*n.

Section divides.

  Infix "div" := divides (at level 70, no associativity).

  Fact divides_refl x : x div x.

  Fact divides_anti x y : x div y -> y div x -> x = y.

  Fact divides_trans x y z : x div y -> y div z -> x div z.

  Fact divides_0 p : p div 0.

  Fact divides_0_inv p : 0 div p -> p = 0.

  Fact divides_1 p : 1 div p.

  Fact divides_1_inv p : p div 1 -> p = 1.

  Fact divides_2_inv p : p div 2 -> p = 1 \/ p = 2.

  Fact divides_mult p q k : p div q -> p div k*q.

  Fact divides_mult_r p q k : p div q -> p div q*k.

  Fact divides_mult_compat a b c d : a div b -> c div d -> a*c div b*d.

  Fact divides_minus p q1 q2 : p div q1 -> p div q2 -> p div q1 - q2.

  Fact divides_plus p q1 q2 : p div q1 -> p div q2 -> p div q1+q2.

  Fact divides_plus_inv p q1 q2 : p div q1 -> p div q1+q2 -> p div q2.

  Fact divides_le p q : q <> 0 -> p div q -> p <= q.

  Fact divides_mult_inv k p q : k <> 0 -> k*p div k*q -> p div q.

  Lemma divides_fact m p : 1 < p <= m -> p div fact m.

  Lemma divides_mult_inv_l p q r : p * q div r -> p div r /\ q div r.

End divides.

Section gcd_lcm.

  Infix "div" := divides (at level 70, no associativity).

  Hint Resolve divides_0 divides_refl divides_mult divides_1.

  Definition is_gcd p q r := r div p /\ r div q /\ forall k, k div p -> k div q -> k div r.
  Definition is_lcm p q r := p div r /\ q div r /\ forall k, p div k -> q div k -> r div k.

  Fact is_gcd_sym p q r : is_gcd p q r -> is_gcd q p r.

  Fact is_gcd_0l p : is_gcd 0 p p.

  Fact is_gcd_0r p : is_gcd p 0 p.

  Fact is_gcd_1l p : is_gcd 1 p 1.

  Fact is_gcd_1r p : is_gcd p 1 1.

  Fact is_gcd_modulus p q k r : p div k -> k <= q -> is_gcd p q r -> is_gcd p (q-k) r.

  Fact is_gcd_minus p q r : p <= q -> is_gcd p q r -> is_gcd p (q-p) r.

  Hint Resolve divides_plus.

  Fact is_gcd_moduplus p q k r : p div k -> is_gcd p q r -> is_gcd p (q+k) r.

  Fact is_gcd_plus p q r : is_gcd p q r -> is_gcd p (q+p) r.

  Fact is_gcd_mult p q r n : is_gcd p (n*p+q) r <-> is_gcd p q r.

  Fact is_gcd_div p q : p div q -> is_gcd p q p.

  Fact is_gcd_refl p : is_gcd p p p.

  Fact is_gcd_fun p q r1 r2 : is_gcd p q r1 -> is_gcd p q r2 -> r1 = r2.

  Fact is_lcm_0l p : is_lcm 0 p 0.

  Fact is_lcm_0r p : is_lcm p 0 0.

  Fact is_lcm_sym p q r : is_lcm p q r -> is_lcm q p r.

  Fact is_lcm_fun p q r1 r2 : is_lcm p q r1 -> is_lcm p q r2 -> r1 = r2.

End gcd_lcm.

Section bezout.

  Infix "div" := divides (at level 70, no associativity).

  Hint Resolve is_gcd_0l is_gcd_0r is_lcm_0l is_lcm_0r divides_refl divides_mult divides_0 is_gcd_minus.

  Section bezout_rel_prime.

    Let bezout_rec p q : 0 < p < q -> is_gcd p q 1 -> exists a b, a*p+b*q = 1+p*q /\ a <= q /\ b <= p.

    Lemma bezout_nc p q : is_gcd p q 1 -> exists a b, a*p+b*q = 1+p*q.

    Hint Resolve divides_1.

    Lemma bezout_sc p q a b m : a*p+b*q = 1 + m -> p div m \/ q div m -> is_gcd p q 1.

  End bezout_rel_prime.

  Fact is_rel_prime_div p q k : is_gcd p q 1 -> p div q*k -> p div k.

  Fact is_rel_prime_div_r p q k : is_gcd p q 1 -> p div k*q -> p div k.

  Fact is_rel_prime_lcm p q : is_gcd p q 1 -> is_lcm p q (p*q).

  Hint Resolve divides_1 divides_mult_compat is_gcd_refl.

  Fact is_gcd_0 p q : is_gcd p q 0 -> p = 0 /\ q = 0.

  Fact is_gcd_rel_prime p q g : is_gcd p q g -> exists a b, p = a*g /\ q = b*g /\ is_gcd a b 1.

  Fact is_lcm_mult p q l k : is_lcm p q l -> is_lcm (k*p) (k*q) (k*l).

  Theorem is_gcd_lcm_mult p q g l : is_gcd p q g -> is_lcm p q l -> p*q = g*l.

  Theorem is_gcd_mult_lcm p q g l : g <> 0 -> is_gcd p q g -> g*l = p*q -> is_lcm p q l.

  Lemma is_lcm_minus p q g l u : p <= q -> p = u*g -> is_gcd p q g -> is_lcm p q l -> is_lcm p (q-p) (l-u*p).

  Lemma is_lcm_modulus k p q g l u : k*p <= q -> p = u*g -> is_gcd p q g -> is_lcm p q l -> is_lcm p (q-k*p) (l-k*u*p).

  Lemma is_lcm_plus p q g l u : p = u*g -> is_gcd p q g -> is_lcm p q l -> is_lcm p (q+p) (l+u*p).

  Lemma is_lcm_moduplus k p q g l u : p = u*g -> is_gcd p q g -> is_lcm p q l -> is_lcm p (q+k*p) (l+k*u*p).

  Section bezout_generalized.

    Let bezout_rec p q : 0 < p < q 
                      -> { a : nat 
                       & { b : nat 
                       & { g : nat
                       & { l : nat 
                       & { u : nat
                       & { v : nat
                         | a*p+b*q = g + l
                        /\ is_gcd p q g
                        /\ is_lcm p q l
                        /\ p = u*g
                        /\ q = v*g
                        /\ a <= v
                        /\ b <= u } } } } } }.
  
    Hint Resolve is_gcd_sym is_lcm_sym.

    Definition bezout_generalized p q : { a : nat 
                                      & { b : nat 
                                      & { g : nat
                                      & { l : nat 
                                        | a*p+b*q = g + l
                                       /\ is_gcd p q g
                                       /\ is_lcm p q l } } } }.

  End bezout_generalized.

  Section gcd_lcm.

    Let gcd_full p q : sig (is_gcd p q).

    Definition gcd p q := proj1_sig (gcd_full p q).
    Fact gcd_spec p q : is_gcd p q (gcd p q).

    Let lcm_full p q : sig (is_lcm p q).

    Definition lcm p q := proj1_sig (lcm_full p q).
    Fact lcm_spec p q : is_lcm p q (lcm p q).

  End gcd_lcm.
     
End bezout.

Require Import Extraction.
Extraction Inline measure_rect.

Check bezout_generalized.
Print Assumptions bezout_generalized.

Section division.

  Fact div_full q p : { n : nat & { r | q = n*p+r /\ (p <> 0 -> r < p) } }.

  Definition div q p := projT1 (div_full q p).
  Definition rem q p := proj1_sig (projT2 (div_full q p)).

  Fact div_rem_spec1 q p : q = div q p * p + rem q p.

  Fact div_rem_spec2 q p : p <> 0 -> rem q p < p.

  Fact rem_0 q : rem q 0 = q.

  Fact div_rem_uniq p n1 r1 n2 r2 : 
        p <> 0 -> n1*p + r1 = n2*p + r2 -> r1 < p -> r2 < p -> n1 = n2 /\ r1 = r2.

  Fact div_prop q p n r : q = n*p+r -> r < p -> div q p = n.

  Fact rem_prop q p n r : q = n*p+r -> r < p -> rem q p = r.

  Fact rem_idem q p : q < p -> rem q p = q.

  Fact is_gcd_rem p n a : is_gcd p n a <-> is_gcd p (rem n p) a.

  Fact rem_erase q n p r : q = n*p+r -> rem q p = rem r p.

  Fact divides_div q p : divides p q -> q = div q p * p.

  Fact divides_rem_eq q p : divides p q <-> rem q p = 0.

  Fact rem_of_0 p : rem 0 p = 0.

  Hint Resolve divides_0_inv.

  Fact divides_dec q p : { k | q = k*p } + { ~ divides p q }.

End division.

Section rem.

  Variable (p : nat) (Hp : p <> 0).

  Fact rem_plus_rem a b : rem (a+rem b p) p = rem (a+b) p.

  Fact rem_mult_rem a b : rem (a*rem b p) p = rem (a*b) p.

  Fact rem_diag : rem p p = 0.

  Fact rem_lt a : a < p -> rem a p = a.

  Fact rem_plus a b : rem (a+b) p = rem (rem a p + rem b p) p.

  Fact rem_scal k a : rem (k*a) p = rem (k*rem a p) p.

  Fact rem_plus_div a b : divides p b -> rem a p = rem (a+b) p.

  Fact div_eq_0 n : n < p -> div n p = 0.

  Fact div_of_0 : div 0 p = 0.

  Fact div_ge_1 n : p <= n -> 1 <= div n p.

End rem.

Fact div_by_p_lt p n : 2 <= p -> n <> 0 -> div n p < n.

Section rem_2.

  Fact rem_2_is_0_or_1 x : rem x 2 = 0 \/ rem x 2 = 1.

  Fact rem_2_mult x y : rem (x*y) 2 = 1 <-> rem x 2 = 1 /\ rem y 2 = 1.

  Fact rem_2_fix_0 : rem 0 2 = 0.

  Fact rem_2_fix_1 n : rem (2*n) 2 = 0.

  Fact rem_2_fix_2 n : rem (1+2*n) 2 = 1.

  Fact rem_2_lt n : rem n 2 < 2.

  Fact div_2_fix_0 : div 0 2 = 0.

  Fact div_2_fix_1 n : div (2*n) 2 = n.

  Fact div_2_fix_2 n : div (1+2*n) 2 = n.

  Fact euclid_2_div n : n = rem n 2 + 2*div n 2 /\ (rem n 2 = 0 \/ rem n 2 = 1).

  Fact euclid_2 n : exists q, n = 2*q \/ n = 1+2*q.

End rem_2.

Local Hint Resolve divides_mult divides_mult_r divides_refl.

Theorem CRT u v a b : u <> 0 -> v <> 0 -> is_gcd u v 1 -> exists w, rem w u = rem a u /\ rem w v = rem b v /\ 2 < w. *)



Set Implicit Arguments.



Section diophantine_expressions.



  Inductive dio_op := do_add | do_mul.



  Definition do_eval o :=

    match o with

      | do_add => plus

      | do_mul => mult

    end.



  Inductive dio_expression : Set :=

    | de_cst  : nat -> dio_expression

    | de_var  : nat -> dio_expression

    | de_comp : dio_op -> dio_expression -> dio_expression -> dio_expression.



  Definition de_add := de_comp do_add.

  Definition de_mul := de_comp do_mul.



  Fixpoint de_size e :=

    match e with

      | de_cst n => 1

      | de_var x => 1

      | de_comp _ p q => 1 + de_size p + de_size q

    end.



  Fixpoint de_size_Z e :=

    (match e with

      | de_cst n => 1

      | de_var x => 1

      | de_comp _ p q => 1 + de_size_Z p + de_size_Z q

    end)%Z.



  Fact de_size_Z_spec e : de_size_Z e = Z.of_nat (de_size e).

  Proof.

    induction e as [ | | o f Hf g Hg ]; auto.

    simpl de_size; unfold de_size_Z; fold de_size_Z.

    rewrite Nat2Z.inj_succ, Nat2Z.inj_add; omega.

  Qed.



  Fixpoint de_eval ν e  :=

    match e with

      | de_cst n => n

      | de_var x => ν x

      | de_comp o p q => do_eval o (de_eval ν p) (de_eval ν q)

    end.



  Fact de_eval_ext e ν ω : (forall x, ν x = ω x) -> de_eval ν e = de_eval ω e.

  Proof.

    intros H; induction e as [ | | [] ]; simpl; auto.

  Qed.



  Fixpoint de_subst σ e :=

    match e with

      | de_cst n => de_cst n

      | de_var x => σ x

      | de_comp o p q => de_comp o (de_subst σ p) (de_subst σ q)

    end.



  Fact de_eval_subst σ ν e : de_eval ν (de_subst σ e) = de_eval (fun x => de_eval ν (σ x)) e.

  Proof. induction e as [ | | [] ]; simpl; auto. Qed.



  Fact de_subst_subst σ1 σ2 e : de_subst σ1 (de_subst σ2 e) = de_subst (fun x => de_subst σ1 (σ2 x)) e.

  Proof. induction e as [ | | [] ]; simpl; f_equal; auto. Qed.



  Definition de_ren ρ := de_subst (fun x => de_var (ρ x)).



  Fact de_ren_size ρ e : de_size (de_ren ρ e) = de_size e.

  Proof.

    revert ρ; induction e as [ | | o e He f Hf ]; intros rho; auto.

    unfold de_ren; simpl de_subst; unfold de_size; fold de_size. 

    f_equal; [ f_equal | ].

    * apply He.

    * apply Hf.

  Qed.



  Fact de_ren_size_Z ρ e : de_size_Z (de_ren ρ e) = de_size_Z e.

  Proof. do 2 rewrite de_size_Z_spec; f_equal; apply de_ren_size. Qed.



  Fact de_eval_ren ρ ν e : de_eval ν (de_ren ρ e)  = de_eval (fun x => ν (ρ x)) e.

  Proof. apply de_eval_subst. Qed.



  Definition de_lift := de_ren S.



  Fact de_eval_lift ν e : de_eval ν (de_lift e) = de_eval (fun x => ν (S x)) e.

  Proof. apply de_eval_ren. Qed.



End diophantine_expressions.



Definition dio_expr t := { e | forall ν, de_eval ν e = t ν }.



Notation 𝔻P := dio_expr.



Section dio_expr.



  Implicit Types r t : (nat -> nat) -> nat.



  Fact dio_expr_var i : 𝔻P (fun v => v i).

  Proof. exists (de_var i); simpl; auto. Defined.



  Fact dio_expr_cst c : 𝔻P (fun _ => c).

  Proof. exists (de_cst c); simpl; auto. Defined.



  Fact dio_expr_plus r t : 𝔻P r -> 𝔻P t -> 𝔻P (fun ν => r ν + t ν).

  Proof. intros (e1 & H1) (e2 & H2); exists (de_add e1 e2); simpl; auto. Defined.

  

  Fact dio_expr_mult r t : 𝔻P r -> 𝔻P t -> 𝔻P (fun ν => r ν * t ν).

  Proof. intros (e1 & H1) (e2 & H2); exists (de_mul e1 e2); simpl; auto. Defined.



  Fact dio_expr_ren t ρ : 𝔻P t -> 𝔻P (fun ν => t (fun i => ν (ρ i))).

  Proof. intros (e & He); exists (de_ren ρ e); intros; rewrite de_eval_ren, He; tauto. Defined.



  Fact dio_expr_subst t σ : 𝔻P t -> 𝔻P (fun ν => t (fun i => de_eval ν (σ i))).

  Proof. intros (e & He); exists (de_subst σ e); intros; rewrite de_eval_subst, He; tauto. Defined.



End dio_expr.



Hint Resolve dio_expr_var dio_expr_cst dio_expr_plus dio_expr_mult dio_expr_ren.



Section diophantine_logic.



  Inductive dio_formula : Set :=

    | df_atm  : dio_expression -> dio_expression -> dio_formula   

    | df_conj : dio_formula -> dio_formula -> dio_formula 

    | df_disj : dio_formula -> dio_formula -> dio_formula

    | df_exst : dio_formula -> dio_formula.



  Fixpoint df_size f :=

    match f with

      | df_atm a b  => 1 + de_size a + de_size b

      | df_conj f g => 1 + df_size f + df_size g  

      | df_disj f g => 1 + df_size f + df_size g  

      | df_exst f   => 1 + df_size f

    end.



  Fixpoint df_size_Z f :=

    (match f with

      | df_atm a b  => 1 + de_size_Z a + de_size_Z b

      | df_conj f g => 1 + df_size_Z f + df_size_Z g  

      | df_disj f g => 1 + df_size_Z f + df_size_Z g  

      | df_exst f   => 1 + df_size_Z f

    end)%Z.



  Fact df_size_Z_spec f : df_size_Z f = Z.of_nat (df_size f).

  Proof.

    induction f as [ a b | f Hf g Hg | f Hf g Hg | f Hf ]; simpl df_size;

      rewrite Nat2Z.inj_succ; try rewrite Nat2Z.inj_add; unfold df_size_Z; fold df_size_Z; auto; try omega.

    do 2 rewrite de_size_Z_spec; omega.

  Qed.



  Definition dv_lift X ν (x : X) n :=

     match n with 

       | 0   => x 

       | S n => ν n 

     end.



  Fixpoint df_pred f ν :=

    match f with

      | df_atm a b  => de_eval ν a  = de_eval ν b

      | df_conj f g => df_pred f ν /\ df_pred g ν

      | df_disj f g => df_pred f ν \/ df_pred g ν

      | df_exst f   => exists n, df_pred f (dv_lift ν n)

    end.



  Fact df_pred_atm a b ν : df_pred (df_atm a b) ν = (de_eval ν a = de_eval ν b).

  Proof. auto. Qed.

  

  Fact df_pred_conj f g ν : df_pred (df_conj f g) ν = (df_pred f ν /\ df_pred g ν).

  Proof. auto. Qed.



  Fact df_pred_disj f g ν : df_pred (df_disj f g) ν = (df_pred f ν \/ df_pred g ν).

  Proof. auto. Qed.



  Fact df_pred_exst f ν : df_pred (df_exst f) ν = exists n, df_pred f (dv_lift ν n).

  Proof. auto. Qed.



  Fact df_pred_ext f ν ω : (forall x, ν x = ω x) -> df_pred f ν <-> df_pred f ω.

  Proof.

    revert ν ω; induction f as [ a b | f Hf g Hg | f Hf g Hg | f Hf ]; intros ν ω H; simpl.

    + do 2 rewrite de_eval_ext with (1 := H); tauto.

    + rewrite Hf, Hg; auto; tauto.

    + rewrite Hf, Hg; auto; tauto.

    + split; intros (n & Hn); exists n; revert Hn; apply Hf;

        intros []; simpl; auto.

  Qed.



  Definition der_lift ρ x := match x with 0 => 0 | S x => S (ρ x) end.



  Fixpoint df_ren ρ f :=

    match f with

      | df_atm a b  => let σ := fun x => de_var (ρ x) in df_atm (de_subst σ a) (de_subst σ b)

      | df_conj f g => df_conj (df_ren ρ f) (df_ren ρ g)

      | df_disj f g => df_disj (df_ren ρ f) (df_ren ρ g)

      | df_exst f   => df_exst (df_ren (der_lift ρ) f)

    end.



  Fact df_ren_size ρ f : df_size (df_ren ρ f) = df_size f.

  Proof.

    revert ρ; induction f; intros; simpl; auto; do 2 f_equal; auto.

    all: apply de_ren_size.

  Qed.



  Fact df_ren_size_Z ρ f : df_size_Z (df_ren ρ f) = df_size_Z f.

  Proof.

    do 2 rewrite df_size_Z_spec; f_equal; apply df_ren_size.

  Qed.



  Fact df_pred_ren f ν ρ : df_pred (df_ren ρ f) ν <-> df_pred f (fun x => ν (ρ x)).

  Proof.

    revert ν ρ; induction f as [ a b | f Hf g Hg | f Hf g Hg | f Hf ]; intros ν ρ; simpl.

    + repeat rewrite de_eval_subst; simpl; tauto.

    + rewrite Hf, Hg; tauto.

    + rewrite Hf, Hg; tauto.

    + split; intros (n & Hn); exists n; revert Hn; rewrite Hf;

        apply df_pred_ext; intros []; simpl; auto.

  Qed.



  Definition des_lift σ x := match x with 0 => de_var 0 | S x => de_ren S (σ x) end. 

     

  Fixpoint df_subst σ f := 

    match f with

      | df_atm a b  => df_atm (de_subst σ a) (de_subst σ b)

      | df_conj f g => df_conj (df_subst σ f) (df_subst σ g)

      | df_disj f g => df_disj (df_subst σ f) (df_subst σ g)

      | df_exst f   => df_exst (df_subst (des_lift σ) f)

    end.



  Fact df_pred_subst f ν σ : df_pred (df_subst σ f) ν <-> df_pred f (fun x => de_eval ν (σ x)).

  Proof.

    revert ν σ; induction f as [ a b | f Hf g Hg | f Hf g Hg | f Hf ]; intros ν σ; simpl.

    + repeat rewrite de_eval_subst; simpl; tauto.

    + rewrite Hf, Hg; tauto.

    + rewrite Hf, Hg; tauto.

    + split; intros (n & Hn); exists n; revert Hn; rewrite Hf;

        apply df_pred_ext; intros []; simpl; auto;

        rewrite de_eval_ren; apply de_eval_ext; auto.

  Qed.



  Definition df_lift := df_ren S.



  Fact df_pred_lift f ν : df_pred (df_lift f) ν <-> df_pred f (fun x => ν (S x)).

  Proof. apply df_pred_ren. Qed. 



End diophantine_logic.



Section examples.



  Variable ν : nat -> nat.



  Definition df_true := df_atm (de_cst 0) (de_cst 0).

  Definition df_false := df_atm (de_cst 0) (de_cst 1).



  Fact df_true_spec : df_pred df_true ν <-> True.

  Proof. simpl; split; auto. Qed.



  Fact df_false_spec : df_pred df_false ν <-> False.

  Proof. simpl; split; try discriminate; tauto. Qed.



  Notation "'⟦' x '⟧'" := (de_eval ν x).



  Definition df_le x y := df_exst (df_atm (de_add (de_var 0) (de_lift x)) (de_lift y)).



  Fact df_le_spec x y : df_pred (df_le x y) ν <-> ⟦x⟧ <= ⟦y⟧.

  Proof.

    simpl.

    split.

    + intros (n & Hn); revert Hn; do 2 rewrite de_eval_lift; simpl.

      change (fun x => ν x) with ν; intros; omega.

    + exists (de_eval ν y - de_eval ν x); simpl.

      repeat rewrite de_eval_lift; simpl.

      change (fun x => ν x) with ν; omega.

  Qed.



  Definition df_lt x y := df_exst (df_atm (de_add (de_cst 1) (de_add (de_var 0) (de_lift x))) (de_lift y)).



  Fact df_lt_spec x y : df_pred (df_lt x y) ν <-> ⟦x⟧ < ⟦y⟧.

  Proof.

    simpl.

    split.

    + intros (? & Hn); revert Hn; simpl.

      do 2 rewrite de_eval_lift; simpl.

      change (fun x => ν x) with ν; intros; omega.

    + exists (de_eval ν y - de_eval ν x - 1); simpl.

      repeat rewrite de_eval_lift; simpl.

      change (fun x => ν x) with ν; omega.

  Qed.



  Definition df_eq x y := df_atm x y.



  Fact df_eq_spec x y : df_pred (df_eq x y) ν <-> ⟦x⟧ = ⟦y⟧.

  Proof. simpl; tauto. Qed.



  Definition df_neq x y := df_disj (df_lt x y) (df_lt y x).



  Fact df_neq_spec x y : df_pred (df_neq x y) ν <-> ⟦x⟧ <> ⟦y⟧.

  Proof.

    unfold df_neq.

    rewrite df_pred_disj, df_lt_spec, df_lt_spec.

    omega.

  Qed.



  Definition df_div x y := df_exst (df_atm (de_lift y) (de_mul (de_var 0) (de_lift x))).



  Fact df_div_spec x y : df_pred (df_div x y) ν <-> divides ⟦x⟧ ⟦y⟧.

  Proof. 

    simpl; unfold divides.

    split; intros (n & H); exists n; revert H; repeat rewrite de_eval_lift;

      simpl; change (fun x => ν x) with ν; auto.

  Qed.



End examples.



Definition dio_rel R := { f | forall ν, df_pred f ν <-> R ν }.

Notation 𝔻R := dio_rel.



Section dio_rel.



  Implicit Types R S : (nat -> nat) -> Prop.



  Fact dio_rel_True : 𝔻R (fun _ => True).

  Proof.

    exists df_true.

    intros; rewrite df_true_spec; tauto.

  Defined.



  Fact dio_rel_False : 𝔻R (fun _ => False).

  Proof.

    exists df_false.

    intros; rewrite df_false_spec; tauto.

  Defined.



  Fact dio_rel_eq r t : 𝔻P r -> 𝔻P t -> 𝔻R (fun ν => r ν = t ν).

  Proof.

    intros (e1 & H1) (e2 & H2); exists (df_atm e1 e2).

    intros; rewrite df_pred_atm, H1, H2; tauto.

  Defined.



  Fact dio_rel_le r t : 𝔻P r -> 𝔻P t -> 𝔻R (fun ν => r ν <= t ν).

  Proof. 

    intros (e1 & H1) (e2 & H2); exists (df_le e1 e2).

    intro; rewrite df_le_spec, H1, H2; tauto.

  Defined.



  Fact dio_rel_lt r t : 𝔻P r -> 𝔻P t -> 𝔻R (fun ν => r ν < t ν).

  Proof. 

    intros (e1 & H1) (e2 & H2); exists (df_lt e1 e2).

    intro; rewrite df_lt_spec, H1, H2; tauto.

  Defined.



  Fact dio_rel_neq r t : 𝔻P r -> 𝔻P t -> 𝔻R (fun ν => r ν <> t ν).

  Proof.

    intros (e1 & H1) (e2 & H2); exists (df_neq e1 e2).

    intros; rewrite df_neq_spec, H1, H2; tauto.

  Defined.



  Fact dio_rel_div r t : 𝔻P r -> 𝔻P t -> 𝔻R (fun ν => divides (r ν) (t ν)).

  Proof.

    intros (e1 & H1) (e2 & H2); exists (df_div e1 e2).

    intros; rewrite df_div_spec, H1, H2; tauto.

  Defined.



  Fact dio_rel_conj R S : 𝔻R R -> 𝔻R S -> 𝔻R (fun ν => R ν /\ S ν).

  Proof.

    intros (fR & H1) (fS & H2).

    exists (df_conj fR fS); intros v.

    rewrite df_pred_conj, H1, H2; tauto.

  Defined.



  Fact dio_rel_disj R S : 𝔻R R -> 𝔻R S -> 𝔻R (fun ν => R ν \/ S ν).

  Proof.

    intros (fR & H1) (fS & H2).

    exists (df_disj fR fS); intros v.

    rewrite df_pred_disj, H1, H2; tauto.

  Defined.



  Fact dio_rel_exst (K : nat -> (nat -> nat) -> Prop) : 

                   𝔻R (fun v => K (v 0) (fun n => v (S n))) 

      -> 𝔻R (fun ν => exists x, K x ν).

  Proof.

    intros (f & Hf).

    exists (df_exst f); intros v.

    rewrite df_pred_exst.

    split; intros (n & Hn); exists n; revert Hn; rewrite Hf; simpl; auto.

  Defined.



  Lemma dio_rel_equiv R S : (forall ν, S ν <-> R ν) -> 𝔻R R -> 𝔻R S.

  Proof. 

    intros H (f & Hf); exists f; intro; rewrite Hf, H; tauto.

  Defined.



  Lemma dio_rel_ren R f : 𝔻R R -> 𝔻R (fun v => R (fun n => v (f n))).

  Proof.

    intros (r & HR).

    exists (df_ren f r).

    intros; rewrite df_pred_ren, HR; tauto.

  Defined.



  Lemma dio_rel_subst R f : 𝔻R R -> 𝔻R (fun v => R (fun n => de_eval v (f n))).

  Proof.

    intros (r & HR).

    exists (df_subst f r).

    intros; rewrite df_pred_subst, HR; tauto.

  Defined.



End dio_rel.



Hint Resolve dio_rel_True dio_rel_False dio_rel_eq dio_rel_neq 

             dio_rel_le dio_rel_lt dio_rel_div 

             dio_rel_conj 

             dio_rel_disj 

             dio_rel_exst.



Ltac dio_rel_auto := repeat ((apply dio_rel_exst || apply dio_rel_conj || apply dio_rel_disj || apply dio_rel_eq); auto).



Section more_examples.



  Fact ndivides_eq x y : ~ (divides x y) <-> x = 0 /\ y <> 0 \/ exists a b, y = a*x+b /\ 0 < b < x.

  Proof.

    split.

    + intros H.

      destruct x as [ | x ].

      * left; split; auto; contradict H; subst; apply divides_0.

      * right; exists (div y (S x)), (rem y (S x)); split.

        - apply div_rem_spec1.

        - rewrite divides_rem_eq in H.

          generalize (@div_rem_spec2 y (S x)); intros; omega.

    + intros [ (H1 & H2) | (a & b & H1 & H2) ].

      * subst; contradict H2; revert H2; apply divides_0_inv.

      * rewrite divides_rem_eq.

        rewrite (div_rem_spec1 y x) in H1.

        apply div_rem_uniq in H1; try omega.

        apply div_rem_spec2; omega.

  Qed.

  

  Lemma dio_rel_ndivides x y : 𝔻P x -> 𝔻P y -> 𝔻R (fun ν => ~ divides (x ν) (y ν)).

  Proof.

    intros.

    apply dio_rel_equiv with (1 := fun v => ndivides_eq (x v) (y v)).

    dio_rel_auto.

  Qed.



  Hint Resolve dio_rel_ndivides.



  Fact rem_equiv p x r : r = rem x p <-> (p = 0 /\ x = r)

                                      \/ (p <> 0 /\ r < p /\ exists n, x = n*p + r).

  Proof.

    split.

    + intro; subst.

      destruct (eq_nat_dec p 0) as [ Hp | Hp ].

      * left; split; auto; subst; rewrite rem_0; auto.

      * right; split; auto; split.

        - apply div_rem_spec2; auto.

        - exists (div x p);apply div_rem_spec1.

    + intros [ (H1 & H2) | (H1 & H2 & n & H3) ].

      * subst; rewrite rem_0; auto.

      * symmetry; apply rem_prop with n; auto.

  Qed.

 

  Lemma dio_rel_remainder p x r : 𝔻P p -> 𝔻P x -> 𝔻P r  

                               -> 𝔻R (fun ν => r ν = rem (x ν) (p ν)).

  Proof.

    intros.

    apply dio_rel_equiv with (1 := fun v => rem_equiv (p v) (x v) (r v)).

    dio_rel_auto.

  Defined.



  Hint Resolve dio_rel_remainder.



  Fact congr_equiv x y p : rem x p = rem y p <-> (exists r, r = rem x p /\ r = rem y p).

  Proof.

    split.

    + intros H; exists (rem x p); auto.

    + intros (? & ? & ?); subst; auto.

  Qed.



  Lemma dio_rel_congruence x y p : 𝔻P x -> 𝔻P y -> 𝔻P p  

                                -> 𝔻R (fun ν => rem (x ν) (p ν) = rem (y ν) (p ν)).

  Proof.

    intros.

    apply dio_rel_equiv with (1 := fun v => congr_equiv (x v) (y v) (p v)).

    dio_rel_auto.

  Defined.



  Hint Resolve dio_rel_congruence.



  Fact not_divides_eq p x : ~ divides p x <-> exists r, r = rem x p /\ r <> 0.

  Proof.

    rewrite divides_rem_eq.

    split.

    + exists (rem x p); auto.

    + intros (? & ? & ?); subst; auto.

  Qed.



  Lemma dio_rel_not_divides x p : 𝔻P x -> 𝔻P p -> 𝔻R (fun ν => ~ divides (x ν) (p ν)).

  Proof.

    intros.

    apply dio_rel_equiv with (1 := fun v => not_divides_eq (x v) (p v)).

    dio_rel_auto.

  Defined.



End more_examples.



Hint Resolve dio_rel_congruence dio_rel_not_divides.



Section dio_rel_compose.



  Variable (f : (nat -> nat) -> nat) (R : nat -> (nat -> nat) -> Prop).

  Hypothesis (Hf : 𝔻R (fun ν => ν 0 = f (fun x => ν (S x)))) 

             (HR : 𝔻R (fun ν => R (ν 0) (fun x => ν (S x)))).



  Lemma dio_rel_compose : 𝔻R (fun ν => R (f ν) ν).

  Proof.

    apply dio_rel_equiv with (R := fun v => exists y, y = f v /\ R y v).

    + intros v; split.

      * exists (f v); auto.

      * intros (? & -> & ?); auto.

    + dio_rel_auto.

  Defined.



End dio_rel_compose.



Section multiple_exists.



  Fixpoint df_mexists n f :=

    match n with 

      | 0   => f

      | S n => df_mexists n (df_exst f)

    end.



  Fact df_mexists_size n f : df_size (df_mexists n f) = n + df_size f.

  Proof. 

    revert f; induction n as [ | n IHn ]; intros f; auto; simpl df_mexists.

    rewrite IHn; simpl; omega. 

  Qed.



  Fact df_mexists_size_Z n f : df_size_Z (df_mexists n f) = (Z.of_nat n + df_size_Z f)%Z.

  Proof.

    rewrite df_size_Z_spec, df_mexists_size, Nat2Z.inj_add, df_size_Z_spec; omega. 

  Qed.



  Lemma df_mexists_spec n f ν : 

           df_pred (df_mexists n f) ν 

       <-> exists π, df_pred f (fun i => if le_lt_dec n i then ν (i-n) else π i).

  Proof.

    revert f ν; induction n as [ | n IHn ]; intros f v.

    + simpl; split; [ intros H; exists (fun _ => 0) | intros (_ & H) ]; revert H; 

        apply df_pred_ext; intros; f_equal; omega.

    + simpl df_mexists; rewrite IHn; split; intros (pi & Hpi).

      * revert Hpi; rewrite df_pred_exst.

        intros (u & Hu).

        exists (fun i => match i with 0 => u | S i => pi i end).

        revert Hu; apply df_pred_ext.

        intros [ | i ].

        - replace (0-S n) with 0 by omega; simpl; auto.

        - replace (S i - S n) with (i-n) by omega.

          simpl dv_lift. 

          destruct (le_lt_dec (S n) (S i)); destruct (le_lt_dec n i); auto; omega.

      * exists (fun i => pi (S i)).

        rewrite df_pred_exst; exists (pi 0).

        revert Hpi; apply df_pred_ext.

        intros [ | i ].

        - replace (0-S n) with 0 by omega; simpl; auto.

        - replace (S i - S n) with (i-n) by omega.

          simpl dv_lift. 

          destruct (le_lt_dec (S n) (S i)); destruct (le_lt_dec n i); auto; omega.

  Qed.



End multiple_exists.



