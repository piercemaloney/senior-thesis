

Require Import Arith Nat Omega.

Require Import gcd.
(* gcd:
Require Import List Arith Omega Permutation.

Require Import utils_tac utils_list.

Set Implicit Arguments.

Section Euclid.

  Definition euclid n d : d <> 0 -> { q : nat & { r | n = q*d+r /\ r < d } }.

End Euclid.

Definition arem n d q j := j <= d /\ (n = 2*q*d+j \/ q <> 0 /\ n = 2*q*d-j).

Fact division_by_even n d : d <> 0 -> { q : nat & { j | arem n d q j } }.

Fact own_multiple x p : x = p*x -> x = 0 \/ p = 1.

Fact mult_is_one p q : p*q = 1 -> p = 1 /\ q = 1.

Definition divides n k := exists p, k = p*n.

Section divides.

  Infix "div" := divides (at level 70, no associativity).

  Fact divides_refl x : x div x.

  Fact divides_anti x y : x div y -> y div x -> x = y.

  Fact divides_trans x y z : x div y -> y div z -> x div z.

  Fact divides_0 p : p div 0.

  Fact divides_0_inv p : 0 div p -> p = 0.

  Fact divides_1 p : 1 div p.

  Fact divides_1_inv p : p div 1 -> p = 1.

  Fact divides_2_inv p : p div 2 -> p = 1 \/ p = 2.

  Fact divides_mult p q k : p div q -> p div k*q.

  Fact divides_mult_r p q k : p div q -> p div q*k.

  Fact divides_mult_compat a b c d : a div b -> c div d -> a*c div b*d.

  Fact divides_minus p q1 q2 : p div q1 -> p div q2 -> p div q1 - q2.

  Fact divides_plus p q1 q2 : p div q1 -> p div q2 -> p div q1+q2.

  Fact divides_plus_inv p q1 q2 : p div q1 -> p div q1+q2 -> p div q2.

  Fact divides_le p q : q <> 0 -> p div q -> p <= q.

  Fact divides_mult_inv k p q : k <> 0 -> k*p div k*q -> p div q.

  Lemma divides_fact m p : 1 < p <= m -> p div fact m.

  Lemma divides_mult_inv_l p q r : p * q div r -> p div r /\ q div r.

End divides.

Section gcd_lcm.

  Infix "div" := divides (at level 70, no associativity).

  Hint Resolve divides_0 divides_refl divides_mult divides_1.

  Definition is_gcd p q r := r div p /\ r div q /\ forall k, k div p -> k div q -> k div r.
  Definition is_lcm p q r := p div r /\ q div r /\ forall k, p div k -> q div k -> r div k.

  Fact is_gcd_sym p q r : is_gcd p q r -> is_gcd q p r.

  Fact is_gcd_0l p : is_gcd 0 p p.

  Fact is_gcd_0r p : is_gcd p 0 p.

  Fact is_gcd_1l p : is_gcd 1 p 1.

  Fact is_gcd_1r p : is_gcd p 1 1.

  Fact is_gcd_modulus p q k r : p div k -> k <= q -> is_gcd p q r -> is_gcd p (q-k) r.

  Fact is_gcd_minus p q r : p <= q -> is_gcd p q r -> is_gcd p (q-p) r.

  Hint Resolve divides_plus.

  Fact is_gcd_moduplus p q k r : p div k -> is_gcd p q r -> is_gcd p (q+k) r.

  Fact is_gcd_plus p q r : is_gcd p q r -> is_gcd p (q+p) r.

  Fact is_gcd_mult p q r n : is_gcd p (n*p+q) r <-> is_gcd p q r.

  Fact is_gcd_div p q : p div q -> is_gcd p q p.

  Fact is_gcd_refl p : is_gcd p p p.

  Fact is_gcd_fun p q r1 r2 : is_gcd p q r1 -> is_gcd p q r2 -> r1 = r2.

  Fact is_lcm_0l p : is_lcm 0 p 0.

  Fact is_lcm_0r p : is_lcm p 0 0.

  Fact is_lcm_sym p q r : is_lcm p q r -> is_lcm q p r.

  Fact is_lcm_fun p q r1 r2 : is_lcm p q r1 -> is_lcm p q r2 -> r1 = r2.

End gcd_lcm.

Section bezout.

  Infix "div" := divides (at level 70, no associativity).

  Hint Resolve is_gcd_0l is_gcd_0r is_lcm_0l is_lcm_0r divides_refl divides_mult divides_0 is_gcd_minus.

  Section bezout_rel_prime.

    Let bezout_rec p q : 0 < p < q -> is_gcd p q 1 -> exists a b, a*p+b*q = 1+p*q /\ a <= q /\ b <= p.

    Lemma bezout_nc p q : is_gcd p q 1 -> exists a b, a*p+b*q = 1+p*q.

    Hint Resolve divides_1.

    Lemma bezout_sc p q a b m : a*p+b*q = 1 + m -> p div m \/ q div m -> is_gcd p q 1.

  End bezout_rel_prime.

  Fact is_rel_prime_div p q k : is_gcd p q 1 -> p div q*k -> p div k.

  Fact is_rel_prime_div_r p q k : is_gcd p q 1 -> p div k*q -> p div k.

  Fact is_rel_prime_lcm p q : is_gcd p q 1 -> is_lcm p q (p*q).

  Hint Resolve divides_1 divides_mult_compat is_gcd_refl.

  Fact is_gcd_0 p q : is_gcd p q 0 -> p = 0 /\ q = 0.

  Fact is_gcd_rel_prime p q g : is_gcd p q g -> exists a b, p = a*g /\ q = b*g /\ is_gcd a b 1.

  Fact is_lcm_mult p q l k : is_lcm p q l -> is_lcm (k*p) (k*q) (k*l).

  Theorem is_gcd_lcm_mult p q g l : is_gcd p q g -> is_lcm p q l -> p*q = g*l.

  Theorem is_gcd_mult_lcm p q g l : g <> 0 -> is_gcd p q g -> g*l = p*q -> is_lcm p q l.

  Lemma is_lcm_minus p q g l u : p <= q -> p = u*g -> is_gcd p q g -> is_lcm p q l -> is_lcm p (q-p) (l-u*p).

  Lemma is_lcm_modulus k p q g l u : k*p <= q -> p = u*g -> is_gcd p q g -> is_lcm p q l -> is_lcm p (q-k*p) (l-k*u*p).

  Lemma is_lcm_plus p q g l u : p = u*g -> is_gcd p q g -> is_lcm p q l -> is_lcm p (q+p) (l+u*p).

  Lemma is_lcm_moduplus k p q g l u : p = u*g -> is_gcd p q g -> is_lcm p q l -> is_lcm p (q+k*p) (l+k*u*p).

  Section bezout_generalized.

    Let bezout_rec p q : 0 < p < q 
                      -> { a : nat 
                       & { b : nat 
                       & { g : nat
                       & { l : nat 
                       & { u : nat
                       & { v : nat
                         | a*p+b*q = g + l
                        /\ is_gcd p q g
                        /\ is_lcm p q l
                        /\ p = u*g
                        /\ q = v*g
                        /\ a <= v
                        /\ b <= u } } } } } }.
  
    Hint Resolve is_gcd_sym is_lcm_sym.

    Definition bezout_generalized p q : { a : nat 
                                      & { b : nat 
                                      & { g : nat
                                      & { l : nat 
                                        | a*p+b*q = g + l
                                       /\ is_gcd p q g
                                       /\ is_lcm p q l } } } }.

  End bezout_generalized.

  Section gcd_lcm.

    Let gcd_full p q : sig (is_gcd p q).

    Definition gcd p q := proj1_sig (gcd_full p q).
    Fact gcd_spec p q : is_gcd p q (gcd p q).

    Let lcm_full p q : sig (is_lcm p q).

    Definition lcm p q := proj1_sig (lcm_full p q).
    Fact lcm_spec p q : is_lcm p q (lcm p q).

  End gcd_lcm.
     
End bezout.

Require Import Extraction.
Extraction Inline measure_rect.

Check bezout_generalized.
Print Assumptions bezout_generalized.

Section division.

  Fact div_full q p : { n : nat & { r | q = n*p+r /\ (p <> 0 -> r < p) } }.

  Definition div q p := projT1 (div_full q p).
  Definition rem q p := proj1_sig (projT2 (div_full q p)).

  Fact div_rem_spec1 q p : q = div q p * p + rem q p.

  Fact div_rem_spec2 q p : p <> 0 -> rem q p < p.

  Fact rem_0 q : rem q 0 = q.

  Fact div_rem_uniq p n1 r1 n2 r2 : 
        p <> 0 -> n1*p + r1 = n2*p + r2 -> r1 < p -> r2 < p -> n1 = n2 /\ r1 = r2.

  Fact div_prop q p n r : q = n*p+r -> r < p -> div q p = n.

  Fact rem_prop q p n r : q = n*p+r -> r < p -> rem q p = r.

  Fact rem_idem q p : q < p -> rem q p = q.

  Fact is_gcd_rem p n a : is_gcd p n a <-> is_gcd p (rem n p) a.

  Fact rem_erase q n p r : q = n*p+r -> rem q p = rem r p.

  Fact divides_div q p : divides p q -> q = div q p * p.

  Fact divides_rem_eq q p : divides p q <-> rem q p = 0.

  Fact rem_of_0 p : rem 0 p = 0.

  Hint Resolve divides_0_inv.

  Fact divides_dec q p : { k | q = k*p } + { ~ divides p q }.

End division.

Section rem.

  Variable (p : nat) (Hp : p <> 0).

  Fact rem_plus_rem a b : rem (a+rem b p) p = rem (a+b) p.

  Fact rem_mult_rem a b : rem (a*rem b p) p = rem (a*b) p.

  Fact rem_diag : rem p p = 0.

  Fact rem_lt a : a < p -> rem a p = a.

  Fact rem_plus a b : rem (a+b) p = rem (rem a p + rem b p) p.

  Fact rem_scal k a : rem (k*a) p = rem (k*rem a p) p.

  Fact rem_plus_div a b : divides p b -> rem a p = rem (a+b) p.

  Fact div_eq_0 n : n < p -> div n p = 0.

  Fact div_of_0 : div 0 p = 0.

  Fact div_ge_1 n : p <= n -> 1 <= div n p.

End rem.

Fact div_by_p_lt p n : 2 <= p -> n <> 0 -> div n p < n.

Section rem_2.

  Fact rem_2_is_0_or_1 x : rem x 2 = 0 \/ rem x 2 = 1.

  Fact rem_2_mult x y : rem (x*y) 2 = 1 <-> rem x 2 = 1 /\ rem y 2 = 1.

  Fact rem_2_fix_0 : rem 0 2 = 0.

  Fact rem_2_fix_1 n : rem (2*n) 2 = 0.

  Fact rem_2_fix_2 n : rem (1+2*n) 2 = 1.

  Fact rem_2_lt n : rem n 2 < 2.

  Fact div_2_fix_0 : div 0 2 = 0.

  Fact div_2_fix_1 n : div (2*n) 2 = n.

  Fact div_2_fix_2 n : div (1+2*n) 2 = n.

  Fact euclid_2_div n : n = rem n 2 + 2*div n 2 /\ (rem n 2 = 0 \/ rem n 2 = 1).

  Fact euclid_2 n : exists q, n = 2*q \/ n = 1+2*q.

End rem_2.

Local Hint Resolve divides_mult divides_mult_r divides_refl.

Theorem CRT u v a b : u <> 0 -> v <> 0 -> is_gcd u v 1 -> exists w, rem w u = rem a u /\ rem w v = rem b v /\ 2 < w. *)



Set Implicit Arguments.



Section diophantine_expressions.



  Inductive dio_op := do_add | do_mul.



  Definition do_eval o :=

    match o with

      | do_add => plus

      | do_mul => mult

    end.



  Inductive dio_expression : Set :=

    | de_cst  : nat -> dio_expression

    | de_var  : nat -> dio_expression

    | de_comp : dio_op -> dio_expression -> dio_expression -> dio_expression.



  Definition de_add := de_comp do_add.

  Definition de_mul := de_comp do_mul.



  Fixpoint de_size e :=

    match e with

      | de_cst n => 1

      | de_var x => 1

      | de_comp _ p q => 1 + de_size p + de_size q

    end.



  Fixpoint de_size_Z e :=

    (match e with

      | de_cst n => 1

      | de_var x => 1

      | de_comp _ p q => 1 + de_size_Z p + de_size_Z q

    end)%Z.



  Fact de_size_Z_spec e : de_size_Z e = Z.of_nat (de_size e).

  Proof.

    induction e as [ | | o f Hf g Hg ]; auto.

    simpl de_size; unfold de_size_Z; fold de_size_Z.

    rewrite Nat2Z.inj_succ, Nat2Z.inj_add; omega.

  Qed.



  Fixpoint de_eval ŒΩ e  :=

    match e with

      | de_cst n => n

      | de_var x => ŒΩ x

      | de_comp o p q => do_eval o (de_eval ŒΩ p) (de_eval ŒΩ q)

    end.



  Fact de_eval_ext e ŒΩ œâ : (forall x, ŒΩ x = œâ x) -> de_eval ŒΩ e = de_eval œâ e.

  Proof.

    intros H; induction e as [ | | [] ]; simpl; auto.

  Qed.



  Fixpoint de_subst œÉ e :=

    match e with

      | de_cst n => de_cst n

      | de_var x => œÉ x

      | de_comp o p q => de_comp o (de_subst œÉ p) (de_subst œÉ q)

    end.



  Fact de_eval_subst œÉ ŒΩ e : de_eval ŒΩ (de_subst œÉ e) = de_eval (fun x => de_eval ŒΩ (œÉ x)) e.

  Proof. induction e as [ | | [] ]; simpl; auto. Qed.



  Fact de_subst_subst œÉ1 œÉ2 e : de_subst œÉ1 (de_subst œÉ2 e) = de_subst (fun x => de_subst œÉ1 (œÉ2 x)) e.

  Proof. induction e as [ | | [] ]; simpl; f_equal; auto. Qed.



  Definition de_ren œÅ := de_subst (fun x => de_var (œÅ x)).



  Fact de_ren_size œÅ e : de_size (de_ren œÅ e) = de_size e.

  Proof.

    revert œÅ; induction e as [ | | o e He f Hf ]; intros rho; auto.

    unfold de_ren; simpl de_subst; unfold de_size; fold de_size. 

    f_equal; [ f_equal | ].

    * apply He.

    * apply Hf.

  Qed.



  Fact de_ren_size_Z œÅ e : de_size_Z (de_ren œÅ e) = de_size_Z e.

  Proof. do 2 rewrite de_size_Z_spec; f_equal; apply de_ren_size. Qed.



  Fact de_eval_ren œÅ ŒΩ e : de_eval ŒΩ (de_ren œÅ e)  = de_eval (fun x => ŒΩ (œÅ x)) e.

  Proof. apply de_eval_subst. Qed.



  Definition de_lift := de_ren S.



  Fact de_eval_lift ŒΩ e : de_eval ŒΩ (de_lift e) = de_eval (fun x => ŒΩ (S x)) e.

  Proof. apply de_eval_ren. Qed.



End diophantine_expressions.



Definition dio_expr t := { e | forall ŒΩ, de_eval ŒΩ e = t ŒΩ }.



Notation ùîªP := dio_expr.



Section dio_expr.



  Implicit Types r t : (nat -> nat) -> nat.



  Fact dio_expr_var i : ùîªP (fun v => v i).

  Proof. exists (de_var i); simpl; auto. Defined.



  Fact dio_expr_cst c : ùîªP (fun _ => c).

  Proof. exists (de_cst c); simpl; auto. Defined.



  Fact dio_expr_plus r t : ùîªP r -> ùîªP t -> ùîªP (fun ŒΩ => r ŒΩ + t ŒΩ).

  Proof. intros (e1 & H1) (e2 & H2); exists (de_add e1 e2); simpl; auto. Defined.

  

  Fact dio_expr_mult r t : ùîªP r -> ùîªP t -> ùîªP (fun ŒΩ => r ŒΩ * t ŒΩ).

  Proof. intros (e1 & H1) (e2 & H2); exists (de_mul e1 e2); simpl; auto. Defined.



  Fact dio_expr_ren t œÅ : ùîªP t -> ùîªP (fun ŒΩ => t (fun i => ŒΩ (œÅ i))).

  Proof. intros (e & He); exists (de_ren œÅ e); intros; rewrite de_eval_ren, He; tauto. Defined.



  Fact dio_expr_subst t œÉ : ùîªP t -> ùîªP (fun ŒΩ => t (fun i => de_eval ŒΩ (œÉ i))).

  Proof. intros (e & He); exists (de_subst œÉ e); intros; rewrite de_eval_subst, He; tauto. Defined.



End dio_expr.



Hint Resolve dio_expr_var dio_expr_cst dio_expr_plus dio_expr_mult dio_expr_ren.



Section diophantine_logic.



  Inductive dio_formula : Set :=

    | df_atm  : dio_expression -> dio_expression -> dio_formula   

    | df_conj : dio_formula -> dio_formula -> dio_formula 

    | df_disj : dio_formula -> dio_formula -> dio_formula

    | df_exst : dio_formula -> dio_formula.



  Fixpoint df_size f :=

    match f with

      | df_atm a b  => 1 + de_size a + de_size b

      | df_conj f g => 1 + df_size f + df_size g  

      | df_disj f g => 1 + df_size f + df_size g  

      | df_exst f   => 1 + df_size f

    end.



  Fixpoint df_size_Z f :=

    (match f with

      | df_atm a b  => 1 + de_size_Z a + de_size_Z b

      | df_conj f g => 1 + df_size_Z f + df_size_Z g  

      | df_disj f g => 1 + df_size_Z f + df_size_Z g  

      | df_exst f   => 1 + df_size_Z f

    end)%Z.



  Fact df_size_Z_spec f : df_size_Z f = Z.of_nat (df_size f).

  Proof.

    induction f as [ a b | f Hf g Hg | f Hf g Hg | f Hf ]; simpl df_size;

      rewrite Nat2Z.inj_succ; try rewrite Nat2Z.inj_add; unfold df_size_Z; fold df_size_Z; auto; try omega.

    do 2 rewrite de_size_Z_spec; omega.

  Qed.



  Definition dv_lift X ŒΩ (x : X) n :=

     match n with 

       | 0   => x 

       | S n => ŒΩ n 

     end.



  Fixpoint df_pred f ŒΩ :=

    match f with

      | df_atm a b  => de_eval ŒΩ a  = de_eval ŒΩ b

      | df_conj f g => df_pred f ŒΩ /\ df_pred g ŒΩ

      | df_disj f g => df_pred f ŒΩ \/ df_pred g ŒΩ

      | df_exst f   => exists n, df_pred f (dv_lift ŒΩ n)

    end.



  Fact df_pred_atm a b ŒΩ : df_pred (df_atm a b) ŒΩ = (de_eval ŒΩ a = de_eval ŒΩ b).

  Proof. auto. Qed.

  

  Fact df_pred_conj f g ŒΩ : df_pred (df_conj f g) ŒΩ = (df_pred f ŒΩ /\ df_pred g ŒΩ).

  Proof. auto. Qed.



  Fact df_pred_disj f g ŒΩ : df_pred (df_disj f g) ŒΩ = (df_pred f ŒΩ \/ df_pred g ŒΩ).

  Proof. auto. Qed.



  Fact df_pred_exst f ŒΩ : df_pred (df_exst f) ŒΩ = exists n, df_pred f (dv_lift ŒΩ n).

  Proof. auto. Qed.



  Fact df_pred_ext f ŒΩ œâ : (forall x, ŒΩ x = œâ x) -> df_pred f ŒΩ <-> df_pred f œâ.

  Proof.

    revert ŒΩ œâ; induction f as [ a b | f Hf g Hg | f Hf g Hg | f Hf ]; intros ŒΩ œâ H; simpl.

    + do 2 rewrite de_eval_ext with (1 := H); tauto.

    + rewrite Hf, Hg; auto; tauto.

    + rewrite Hf, Hg; auto; tauto.

    + split; intros (n & Hn); exists n; revert Hn; apply Hf;

        intros []; simpl; auto.

  Qed.



  Definition der_lift œÅ x := match x with 0 => 0 | S x => S (œÅ x) end.



  Fixpoint df_ren œÅ f :=

    match f with

      | df_atm a b  => let œÉ := fun x => de_var (œÅ x) in df_atm (de_subst œÉ a) (de_subst œÉ b)

      | df_conj f g => df_conj (df_ren œÅ f) (df_ren œÅ g)

      | df_disj f g => df_disj (df_ren œÅ f) (df_ren œÅ g)

      | df_exst f   => df_exst (df_ren (der_lift œÅ) f)

    end.



  Fact df_ren_size œÅ f : df_size (df_ren œÅ f) = df_size f.

  Proof.

    revert œÅ; induction f; intros; simpl; auto; do 2 f_equal; auto.

    all: apply de_ren_size.

  Qed.



  Fact df_ren_size_Z œÅ f : df_size_Z (df_ren œÅ f) = df_size_Z f.

  Proof.

    do 2 rewrite df_size_Z_spec; f_equal; apply df_ren_size.

  Qed.



  Fact df_pred_ren f ŒΩ œÅ : df_pred (df_ren œÅ f) ŒΩ <-> df_pred f (fun x => ŒΩ (œÅ x)).

  Proof.

    revert ŒΩ œÅ; induction f as [ a b | f Hf g Hg | f Hf g Hg | f Hf ]; intros ŒΩ œÅ; simpl.

    + repeat rewrite de_eval_subst; simpl; tauto.

    + rewrite Hf, Hg; tauto.

    + rewrite Hf, Hg; tauto.

    + split; intros (n & Hn); exists n; revert Hn; rewrite Hf;

        apply df_pred_ext; intros []; simpl; auto.

  Qed.



  Definition des_lift œÉ x := match x with 0 => de_var 0 | S x => de_ren S (œÉ x) end. 

     

  Fixpoint df_subst œÉ f := 

    match f with

      | df_atm a b  => df_atm (de_subst œÉ a) (de_subst œÉ b)

      | df_conj f g => df_conj (df_subst œÉ f) (df_subst œÉ g)

      | df_disj f g => df_disj (df_subst œÉ f) (df_subst œÉ g)

      | df_exst f   => df_exst (df_subst (des_lift œÉ) f)

    end.



  Fact df_pred_subst f ŒΩ œÉ : df_pred (df_subst œÉ f) ŒΩ <-> df_pred f (fun x => de_eval ŒΩ (œÉ x)).

  Proof.

    revert ŒΩ œÉ; induction f as [ a b | f Hf g Hg | f Hf g Hg | f Hf ]; intros ŒΩ œÉ; simpl.

    + repeat rewrite de_eval_subst; simpl; tauto.

    + rewrite Hf, Hg; tauto.

    + rewrite Hf, Hg; tauto.

    + split; intros (n & Hn); exists n; revert Hn; rewrite Hf;

        apply df_pred_ext; intros []; simpl; auto;

        rewrite de_eval_ren; apply de_eval_ext; auto.

  Qed.



  Definition df_lift := df_ren S.



  Fact df_pred_lift f ŒΩ : df_pred (df_lift f) ŒΩ <-> df_pred f (fun x => ŒΩ (S x)).

  Proof. apply df_pred_ren. Qed. 



End diophantine_logic.



Section examples.



  Variable ŒΩ : nat -> nat.



  Definition df_true := df_atm (de_cst 0) (de_cst 0).

  Definition df_false := df_atm (de_cst 0) (de_cst 1).



  Fact df_true_spec : df_pred df_true ŒΩ <-> True.

  Proof. simpl; split; auto. Qed.



  Fact df_false_spec : df_pred df_false ŒΩ <-> False.

  Proof. simpl; split; try discriminate; tauto. Qed.



  Notation "'‚ü¶' x '‚üß'" := (de_eval ŒΩ x).



  Definition df_le x y := df_exst (df_atm (de_add (de_var 0) (de_lift x)) (de_lift y)).



  Fact df_le_spec x y : df_pred (df_le x y) ŒΩ <-> ‚ü¶x‚üß <= ‚ü¶y‚üß.

  Proof.

    simpl.

    split.

    + intros (n & Hn); revert Hn; do 2 rewrite de_eval_lift; simpl.

      change (fun x => ŒΩ x) with ŒΩ; intros; omega.

    + exists (de_eval ŒΩ y - de_eval ŒΩ x); simpl.

      repeat rewrite de_eval_lift; simpl.

      change (fun x => ŒΩ x) with ŒΩ; omega.

  Qed.



  Definition df_lt x y := df_exst (df_atm (de_add (de_cst 1) (de_add (de_var 0) (de_lift x))) (de_lift y)).



  Fact df_lt_spec x y : df_pred (df_lt x y) ŒΩ <-> ‚ü¶x‚üß < ‚ü¶y‚üß.

  Proof.

    simpl.

    split.

    + intros (? & Hn); revert Hn; simpl.

      do 2 rewrite de_eval_lift; simpl.

      change (fun x => ŒΩ x) with ŒΩ; intros; omega.

    + exists (de_eval ŒΩ y - de_eval ŒΩ x - 1); simpl.

      repeat rewrite de_eval_lift; simpl.

      change (fun x => ŒΩ x) with ŒΩ; omega.

  Qed.



  Definition df_eq x y := df_atm x y.



  Fact df_eq_spec x y : df_pred (df_eq x y) ŒΩ <-> ‚ü¶x‚üß = ‚ü¶y‚üß.

  Proof. simpl; tauto. Qed.



  Definition df_neq x y := df_disj (df_lt x y) (df_lt y x).



  Fact df_neq_spec x y : df_pred (df_neq x y) ŒΩ <-> ‚ü¶x‚üß <> ‚ü¶y‚üß.

  Proof.

    unfold df_neq.

    rewrite df_pred_disj, df_lt_spec, df_lt_spec.

    omega.

  Qed.



  Definition df_div x y := df_exst (df_atm (de_lift y) (de_mul (de_var 0) (de_lift x))).



  Fact df_div_spec x y : df_pred (df_div x y) ŒΩ <-> divides ‚ü¶x‚üß ‚ü¶y‚üß.

  Proof. 

    simpl; unfold divides.

    split; intros (n & H); exists n; revert H; repeat rewrite de_eval_lift;

      simpl; change (fun x => ŒΩ x) with ŒΩ; auto.

  Qed.



End examples.



Definition dio_rel R := { f | forall ŒΩ, df_pred f ŒΩ <-> R ŒΩ }.

Notation ùîªR := dio_rel.



Section dio_rel.



  Implicit Types R S : (nat -> nat) -> Prop.



  Fact dio_rel_True : ùîªR (fun _ => True).

  Proof.

    exists df_true.

    intros; rewrite df_true_spec; tauto.

  Defined.



  Fact dio_rel_False : ùîªR (fun _ => False).

  Proof.

    exists df_false.

    intros; rewrite df_false_spec; tauto.

  Defined.



  Fact dio_rel_eq r t : ùîªP r -> ùîªP t -> ùîªR (fun ŒΩ => r ŒΩ = t ŒΩ).

  Proof.

    intros (e1 & H1) (e2 & H2); exists (df_atm e1 e2).

    intros; rewrite df_pred_atm, H1, H2; tauto.

  Defined.



  Fact dio_rel_le r t : ùîªP r -> ùîªP t -> ùîªR (fun ŒΩ => r ŒΩ <= t ŒΩ).

  Proof. 

    intros (e1 & H1) (e2 & H2); exists (df_le e1 e2).

    intro; rewrite df_le_spec, H1, H2; tauto.

  Defined.



  Fact dio_rel_lt r t : ùîªP r -> ùîªP t -> ùîªR (fun ŒΩ => r ŒΩ < t ŒΩ).

  Proof. 

    intros (e1 & H1) (e2 & H2); exists (df_lt e1 e2).

    intro; rewrite df_lt_spec, H1, H2; tauto.

  Defined.



  Fact dio_rel_neq r t : ùîªP r -> ùîªP t -> ùîªR (fun ŒΩ => r ŒΩ <> t ŒΩ).

  Proof.

    intros (e1 & H1) (e2 & H2); exists (df_neq e1 e2).

    intros; rewrite df_neq_spec, H1, H2; tauto.

  Defined.



  Fact dio_rel_div r t : ùîªP r -> ùîªP t -> ùîªR (fun ŒΩ => divides (r ŒΩ) (t ŒΩ)).

  Proof.

    intros (e1 & H1) (e2 & H2); exists (df_div e1 e2).

    intros; rewrite df_div_spec, H1, H2; tauto.

  Defined.



  Fact dio_rel_conj R S : ùîªR R -> ùîªR S -> ùîªR (fun ŒΩ => R ŒΩ /\ S ŒΩ).

  Proof.

    intros (fR & H1) (fS & H2).

    exists (df_conj fR fS); intros v.

    rewrite df_pred_conj, H1, H2; tauto.

  Defined.



  Fact dio_rel_disj R S : ùîªR R -> ùîªR S -> ùîªR (fun ŒΩ => R ŒΩ \/ S ŒΩ).

  Proof.

    intros (fR & H1) (fS & H2).

    exists (df_disj fR fS); intros v.

    rewrite df_pred_disj, H1, H2; tauto.

  Defined.



  Fact dio_rel_exst (K : nat -> (nat -> nat) -> Prop) : 

                   ùîªR (fun v => K (v 0) (fun n => v (S n))) 

      -> ùîªR (fun ŒΩ => exists x, K x ŒΩ).

  Proof.

    intros (f & Hf).

    exists (df_exst f); intros v.

    rewrite df_pred_exst.

    split; intros (n & Hn); exists n; revert Hn; rewrite Hf; simpl; auto.

  Defined.



  Lemma dio_rel_equiv R S : (forall ŒΩ, S ŒΩ <-> R ŒΩ) -> ùîªR R -> ùîªR S.

  Proof. 

    intros H (f & Hf); exists f; intro; rewrite Hf, H; tauto.

  Defined.



  Lemma dio_rel_ren R f : ùîªR R -> ùîªR (fun v => R (fun n => v (f n))).

  Proof.

    intros (r & HR).

    exists (df_ren f r).

    intros; rewrite df_pred_ren, HR; tauto.

  Defined.



  Lemma dio_rel_subst R f : ùîªR R -> ùîªR (fun v => R (fun n => de_eval v (f n))).

  Proof.

    intros (r & HR).

    exists (df_subst f r).

    intros; rewrite df_pred_subst, HR; tauto.

  Defined.



End dio_rel.



Hint Resolve dio_rel_True dio_rel_False dio_rel_eq dio_rel_neq 

             dio_rel_le dio_rel_lt dio_rel_div 

             dio_rel_conj 

             dio_rel_disj 

             dio_rel_exst.



Ltac dio_rel_auto := repeat ((apply dio_rel_exst || apply dio_rel_conj || apply dio_rel_disj || apply dio_rel_eq); auto).



Section more_examples.



  Fact ndivides_eq x y : ~ (divides x y) <-> x = 0 /\ y <> 0 \/ exists a b, y = a*x+b /\ 0 < b < x.

  Proof.

    split.

    + intros H.

      destruct x as [ | x ].

      * left; split; auto; contradict H; subst; apply divides_0.

      * right; exists (div y (S x)), (rem y (S x)); split.

        - apply div_rem_spec1.

        - rewrite divides_rem_eq in H.

          generalize (@div_rem_spec2 y (S x)); intros; omega.

    + intros [ (H1 & H2) | (a & b & H1 & H2) ].

      * subst; contradict H2; revert H2; apply divides_0_inv.

      * rewrite divides_rem_eq.

        rewrite (div_rem_spec1 y x) in H1.

        apply div_rem_uniq in H1; try omega.

        apply div_rem_spec2; omega.

  Qed.

  

  Lemma dio_rel_ndivides x y : ùîªP x -> ùîªP y -> ùîªR (fun ŒΩ => ~ divides (x ŒΩ) (y ŒΩ)).

  Proof.

    intros.

    apply dio_rel_equiv with (1 := fun v => ndivides_eq (x v) (y v)).

    dio_rel_auto.

  Qed.



  Hint Resolve dio_rel_ndivides.



  Fact rem_equiv p x r : r = rem x p <-> (p = 0 /\ x = r)

                                      \/ (p <> 0 /\ r < p /\ exists n, x = n*p + r).

  Proof.

    split.

    + intro; subst.

      destruct (eq_nat_dec p 0) as [ Hp | Hp ].

      * left; split; auto; subst; rewrite rem_0; auto.

      * right; split; auto; split.

        - apply div_rem_spec2; auto.

        - exists (div x p);apply div_rem_spec1.

    + intros [ (H1 & H2) | (H1 & H2 & n & H3) ].

      * subst; rewrite rem_0; auto.

      * symmetry; apply rem_prop with n; auto.

  Qed.

 

  Lemma dio_rel_remainder p x r : ùîªP p -> ùîªP x -> ùîªP r  

                               -> ùîªR (fun ŒΩ => r ŒΩ = rem (x ŒΩ) (p ŒΩ)).

  Proof.

    intros.

    apply dio_rel_equiv with (1 := fun v => rem_equiv (p v) (x v) (r v)).

    dio_rel_auto.

  Defined.



  Hint Resolve dio_rel_remainder.



  Fact congr_equiv x y p : rem x p = rem y p <-> (exists r, r = rem x p /\ r = rem y p).

  Proof.

    split.

    + intros H; exists (rem x p); auto.

    + intros (? & ? & ?); subst; auto.

  Qed.



  Lemma dio_rel_congruence x y p : ùîªP x -> ùîªP y -> ùîªP p  

                                -> ùîªR (fun ŒΩ => rem (x ŒΩ) (p ŒΩ) = rem (y ŒΩ) (p ŒΩ)).

  Proof.

    intros.

    apply dio_rel_equiv with (1 := fun v => congr_equiv (x v) (y v) (p v)).

    dio_rel_auto.

  Defined.



  Hint Resolve dio_rel_congruence.



  Fact not_divides_eq p x : ~ divides p x <-> exists r, r = rem x p /\ r <> 0.

  Proof.

    rewrite divides_rem_eq.

    split.

    + exists (rem x p); auto.

    + intros (? & ? & ?); subst; auto.

  Qed.



  Lemma dio_rel_not_divides x p : ùîªP x -> ùîªP p -> ùîªR (fun ŒΩ => ~ divides (x ŒΩ) (p ŒΩ)).

  Proof.

    intros.

    apply dio_rel_equiv with (1 := fun v => not_divides_eq (x v) (p v)).

    dio_rel_auto.

  Defined.



End more_examples.



Hint Resolve dio_rel_congruence dio_rel_not_divides.



Section dio_rel_compose.



  Variable (f : (nat -> nat) -> nat) (R : nat -> (nat -> nat) -> Prop).

  Hypothesis (Hf : ùîªR (fun ŒΩ => ŒΩ 0 = f (fun x => ŒΩ (S x)))) 

             (HR : ùîªR (fun ŒΩ => R (ŒΩ 0) (fun x => ŒΩ (S x)))).



  Lemma dio_rel_compose : ùîªR (fun ŒΩ => R (f ŒΩ) ŒΩ).

  Proof.

    apply dio_rel_equiv with (R := fun v => exists y, y = f v /\ R y v).

    + intros v; split.

      * exists (f v); auto.

      * intros (? & -> & ?); auto.

    + dio_rel_auto.

  Defined.



End dio_rel_compose.



Section multiple_exists.



  Fixpoint df_mexists n f :=

    match n with 

      | 0   => f

      | S n => df_mexists n (df_exst f)

    end.



  Fact df_mexists_size n f : df_size (df_mexists n f) = n + df_size f.

  Proof. 

    revert f; induction n as [ | n IHn ]; intros f; auto; simpl df_mexists.

    rewrite IHn; simpl; omega. 

  Qed.



  Fact df_mexists_size_Z n f : df_size_Z (df_mexists n f) = (Z.of_nat n + df_size_Z f)%Z.

  Proof.

    rewrite df_size_Z_spec, df_mexists_size, Nat2Z.inj_add, df_size_Z_spec; omega. 

  Qed.



  Lemma df_mexists_spec n f ŒΩ : 

           df_pred (df_mexists n f) ŒΩ 

       <-> exists œÄ, df_pred f (fun i => if le_lt_dec n i then ŒΩ (i-n) else œÄ i).

  Proof.

    revert f ŒΩ; induction n as [ | n IHn ]; intros f v.

    + simpl; split; [ intros H; exists (fun _ => 0) | intros (_ & H) ]; revert H; 

        apply df_pred_ext; intros; f_equal; omega.

    + simpl df_mexists; rewrite IHn; split; intros (pi & Hpi).

      * revert Hpi; rewrite df_pred_exst.

        intros (u & Hu).

        exists (fun i => match i with 0 => u | S i => pi i end).

        revert Hu; apply df_pred_ext.

        intros [ | i ].

        - replace (0-S n) with 0 by omega; simpl; auto.

        - replace (S i - S n) with (i-n) by omega.

          simpl dv_lift. 

          destruct (le_lt_dec (S n) (S i)); destruct (le_lt_dec n i); auto; omega.

      * exists (fun i => pi (S i)).

        rewrite df_pred_exst; exists (pi 0).

        revert Hpi; apply df_pred_ext.

        intros [ | i ].

        - replace (0-S n) with 0 by omega; simpl; auto.

        - replace (S i - S n) with (i-n) by omega.

          simpl dv_lift. 

          destruct (le_lt_dec (S n) (S i)); destruct (le_lt_dec n i); auto; omega.

  Qed.



End multiple_exists.



