
Require Import ILL.Definitions.
(* ILL.Definitions:
Require Export Problems.PCP Problems.Reduction. *)
Require Import bsm_defs mm_defs eill ill.
(* bsm_defs:
Require Import List Arith Omega Bool.

Require Import utils pos vec. 
Require Import subcode sss.
Require Import list_bool.

Set Implicit Arguments.

Tactic Notation "rew" "length" := autorewrite with length_db.

Local Notation "e #> x" := (vec_pos e x).
Local Notation "e [ v / x ]" := (vec_change e x v).

Inductive bsm_instr n : Set :=
  | bsm_pop  : pos n -> nat -> nat -> bsm_instr n
  | bsm_push : pos n -> bool -> bsm_instr n
  .

Notation POP  := bsm_pop.
Notation PUSH := bsm_push.

Section Binary_Stack_Machine.

  Variable (n : nat).

  Definition bsm_state := (nat*vec (list bool) n)%type.

  Inductive bsm_sss : bsm_instr n -> bsm_state -> bsm_state -> Prop :=
    | in_bsm_sss_pop_E : forall i x p q v,    v#>x = nil      -> POP x p q // (i,v) -1> (  q,v)
    | in_bsm_sss_pop_0 : forall i x p q v ll, v#>x = Zero::ll -> POP x p q // (i,v) -1> (  p,v[ll/x])
    | in_bsm_sss_pop_1 : forall i x p q v ll, v#>x = One ::ll -> POP x p q // (i,v) -1> (1+i,v[ll/x])
    | in_bsm_sss_push  : forall i x b v,                         PUSH x b  // (i,v) -1> (1+i,v[(b::v#>x)/x])
  where "i // s -1> t" := (bsm_sss i s t).

  Ltac mydiscr := 
      match goal with H: ?x = _, G : ?x = _ |- _ => rewrite H in G; discriminate end.

  Ltac myinj := 
      match goal with H: ?x = _, G : ?x = _ |- _ => rewrite H in G; inversion G; subst; auto end.      
  
  Fact bsm_sss_fun i s t1 t2 : i // s -1> t1 -> i // s -1> t2 -> t1 = t2.

  Fact bsm_sss_total ii s : { t | ii // s -1> t }.

  Fact bsm_sss_total' ii s : exists t, ii // s -1> t.
  
  Fact bsm_sss_stall : forall P s, sss_step_stall bsm_sss P s -> out_code (fst s) P.
 
  Notation "P // s -[ k ]-> t" := (sss_steps bsm_sss P k s t).
  Notation "P // s ->> t" := (sss_compute bsm_sss P s t).

  Fact bsm_compute_POP_E P i x p q v st :
         (i,POP x p q::nil) <sc P
      -> v#>x = nil
      -> P // (q,v) ->> st
      -> P // (i,v) ->> st.

  Fact bsm_compute_POP_0 P i x p q ll v st :
         (i,POP x p q::nil) <sc P
      -> v#>x = Zero::ll
      -> P // (p,v[ll/x]) ->> st
      -> P // (i,v) ->> st.

  Fact bsm_compute_POP_1 P i x p q ll v st :
         (i,POP x p q::nil) <sc P
      -> v#>x = One::ll
      -> P // (1+i,v[ll/x]) ->> st
      -> P // (i,v) ->> st.

  Fact bsm_compute_POP_any P i x p q b ll v st :
         (i,POP x p q::nil) <sc P
      -> v#>x = b::ll
      -> p = 1+i
      -> P // (1+i,v[ll/x]) ->> st
      -> P // (i,v) ->> st.

  Fact bsm_compute_PUSH P i x b v st :
         (i,PUSH x b::nil) <sc P
      -> P // (1+i,v[(b::v#>x)/x]) ->> st
      -> P // (i,v) ->> st.

  Fact bsm_steps_POP_0_inv a P i x p q ll v st :
         (i,POP x p q::nil) <sc P
      -> v#>x = Zero::ll
      -> st <> (i,v)
      -> P // (i,v) -[a]-> st
      -> { b | b < a /\ P // (p,v[ll/x]) -[b]-> st }.

  Fact bsm_steps_POP_1_inv a P i x p q ll v st :
         (i,POP x p q::nil) <sc P
      -> v#>x = One::ll
      -> st <> (i,v)
      -> P // (i,v) -[a]-> st
      -> { b | b < a /\ P // (1+i,v[ll/x]) -[b]-> st }.

  Fact bsm_steps_POP_any_inv a P i x p q b ll v st :
         (i,POP x p q::nil) <sc P
      -> v#>x = b::ll
      -> p = 1+i
      -> st <> (i,v)
      -> P // (i,v) -[a]-> st
      -> { b | b < a /\ P // (1+i,v[ll/x]) -[b]-> st }.

  Fact bsm_steps_POP_E_inv a P i x p q v st :
         (i,POP x p q::nil) <sc P
      -> v#>x = nil
      -> st <> (i,v)
      -> P // (i,v) -[a]-> st
      -> { b | b < a /\ P // (q,v) -[b]-> st }.

  Fact bsm_steps_PUSH_inv k P i x b v st :
         (i,PUSH x b::nil) <sc P
      -> st <> (i,v)
      -> P // (i,v) -[k]-> st
      -> { a | a < k /\ P // (1+i,v[(b::v#>x)/x]) -[a]-> st }.

End Binary_Stack_Machine.

Tactic Notation "bsm" "sss" "POP" "empty" "with" uconstr(a) constr(b) constr(c) := 
     apply bsm_compute_POP_E with (x := a) (p := b) (q := c); auto.

Tactic Notation "bsm" "sss" "POP" "0" "with" uconstr(a) constr(b) constr(c) uconstr(d) := 
     apply bsm_compute_POP_0 with (x := a) (p := b) (q := c) (ll := d); auto.

Tactic Notation "bsm" "sss" "POP" "1" "with" uconstr(a) constr(b) constr(c) uconstr(d) := 
     apply bsm_compute_POP_1 with (x := a) (p := b) (q := c) (ll := d); auto.

Tactic Notation "bsm" "sss" "POP" "any" "with" uconstr(a) constr(c) constr(d) constr(e) constr(f) := 
     apply bsm_compute_POP_any with (x := a) (p := c) (q := d) (b := e) (ll := f); auto.

Tactic Notation "bsm" "sss" "PUSH" "with" uconstr(a) constr(q) := 
     apply bsm_compute_PUSH with (x := a) (b := q); auto.

Tactic Notation "bsm" "sss" "stop" := exists 0; apply sss_steps_0; auto.

Tactic Notation "bsm" "inv" "POP" "empty" "with" hyp(H) constr(a) constr(b) constr(c) constr(d) :=
     apply bsm_steps_POP_E_inv with (x := a) (p := b) (q := c) (ll := d) in H; auto.

Tactic Notation "bsm" "inv" "POP" "0" "with" hyp(H) constr(a) constr(b) constr(c) constr(d) :=
     apply bsm_steps_POP_0_inv with (x := a) (p := b) (q := c) (ll := d) in H; auto.

Tactic Notation "bsm" "inv" "POP" "1" "with" hyp(H) constr(a) constr(b) constr(c) constr(d) :=
     apply bsm_steps_POP_1_inv with (x := a) (p := b) (q := c) (ll := d) in H; auto.

Tactic Notation "bsm" "inv" "POP" "any" "with" hyp(H) constr(a) constr(c) constr(d) constr(e) constr(f) :=
     apply bsm_steps_POP_any_inv with (x := a) (p := c) (q := d) (b := e) (ll := f) in H; auto.

Tactic Notation "bsm" "inv" "PUSH" "with" hyp(H) constr(a) constr(c) :=
     apply bsm_steps_PUSH_inv with (x := a) (b := c) in H; auto.

Hint Immediate bsm_sss_fun.

Definition BSM_PROBLEM := { n : nat & { i : nat & { P : list (bsm_instr n) & vec (list bool) n } } }.

Local Notation "P // s ‚Üì" := (sss_terminates (@bsm_sss _) P s).

Definition BSM_HALTING (P : BSM_PROBLEM) := 
  match P with existT _ n (existT _ i (existT _ P v)) => (i,P) // (i,v) ‚Üì end. *)
(* mm_defs:
Require Import List Arith Omega.

Require Import utils pos vec. 
Require Import subcode sss.

Set Implicit Arguments.

Tactic Notation "rew" "length" := autorewrite with length_db.

Local Notation "e #> x" := (vec_pos e x).
Local Notation "e [ v / x ]" := (vec_change e x v).

Inductive mm_instr n : Set :=
  | mm_inc : pos n -> mm_instr n
  | mm_dec : pos n -> nat -> mm_instr n
  .

Notation INC := mm_inc.
Notation DEC := mm_dec.

Section Minsky_Machine.

  Variable (n : nat).

  Definition mm_state := (nat*vec nat n)%type.

  Inductive mm_sss : mm_instr n -> mm_state -> mm_state -> Prop :=
    | in_mm_sss_inc   : forall i x v,                   INC x   // (i,v) -1> (1+i,v[(S (v#>x))/x])
    | in_mm_sss_dec_0 : forall i x k v,   v#>x = O   -> DEC x k // (i,v) -1> (k,v)
    | in_mm_sss_dec_1 : forall i x k v u, v#>x = S u -> DEC x k // (i,v) -1> (1+i,v[u/x])
  where "i // s -1> t" := (mm_sss i s t).

  Fact mm_sss_fun i s t1 t2 : i // s -1> t1 -> i // s -1> t2 -> t1 = t2.
  
  Fact mm_sss_total ii s : { t | ii // s -1> t }.
  
  Fact mm_sss_INC_inv x i v j w : INC x // (i,v) -1> (j,w) -> j=1+i /\ w = v[(S (v#>x))/x].
  
  Fact mm_sss_DEC0_inv x k i v j w : v#>x = O -> DEC x k // (i,v) -1> (j,w) -> j = k /\ w = v.
  
  Fact mm_sss_DEC1_inv x k u i v j w : v#>x = S u -> DEC x k // (i,v) -1> (j,w) -> j=1+i /\ w = v[u/x].

  Notation "P // s -[ k ]-> t" := (sss_steps mm_sss P k s t).
  Notation "P // s -+> t" := (sss_progress mm_sss P s t).
  Notation "P // s ->> t" := (sss_compute mm_sss P s t).
  
  Fact mm_progress_INC P i x v st :
         (i,INC x::nil) <sc P
      -> P // (1+i,v[(S (v#>x))/x]) ->> st
      -> P // (i,v) -+> st.
  
  Corollary mm_compute_INC P i x v st : (i,INC x::nil) <sc P -> P // (1+i,v[(S (v#>x))/x]) ->> st -> P // (i,v) ->> st.
  
  Fact mm_progress_DEC_0 P i x k v st :
         (i,DEC x k::nil) <sc P
      -> v#>x = O 
      -> P // (k,v) ->> st
      -> P // (i,v) -+> st.
  
  Corollary mm_compute_DEC_0 P i x k v st : (i,DEC x k::nil) <sc P -> v#>x = O -> P // (k,v) ->> st -> P // (i,v) ->> st.
  
  Fact mm_progress_DEC_S P i x k v u st :
         (i,DEC x k::nil) <sc P
      -> v#>x = S u 
      -> P // (1+i,v[u/x]) ->> st
      -> P // (i,v) -+> st.
  
  Corollary mm_compute_DEC_S P i x k v u st : (i,DEC x k::nil) <sc P -> v#>x = S u -> P // (1+i,v[u/x]) ->> st -> P // (i,v) ->> st.
  
  Fact mm_steps_INC_inv k P i x v st :
         (i,INC x::nil) <sc P
      -> k <> 0
      -> P // (i,v) -[k]-> st
      -> exists k', k' < k /\ P // (1+i,v[(S (v#>x))/x]) -[k']-> st.
  
  Fact mm_steps_DEC_0_inv k P i x p v st :
         (i,DEC x p::nil) <sc P
      -> k <> 0
      -> v#>x = 0
      -> P // (i,v) -[k]-> st
      -> exists k', k' < k /\ P // (p,v) -[k']-> st.
  
  Fact mm_steps_DEC_1_inv k P i x p v u st :
         (i,DEC x p::nil) <sc P
      -> k <> 0
      -> v#>x = S u
      -> P // (i,v) -[k]-> st
      -> exists k', k' < k /\ P // (1+i,v[u/x]) -[k']-> st.
  
End Minsky_Machine.

Local Notation "P // s -[ k ]-> t" := (sss_steps (@mm_sss _) P k s t).
Local Notation "P // s -+> t" := (sss_progress (@mm_sss _) P s t).
Local Notation "P // s ->> t" := (sss_compute (@mm_sss _) P s t).

Tactic Notation "mm" "sss" "INC" "with" uconstr(a) := 
  match goal with
    | |- _ // _ -+> _ => apply mm_progress_INC with (x := a)
    | |- _ // _ ->> _ => apply mm_compute_INC with (x := a)
  end; auto.

Tactic Notation "mm" "sss" "DEC" "0" "with" uconstr(a) uconstr(b) := 
  match goal with
    | |- _ // _ -+> _ => apply mm_progress_DEC_0 with (x := a) (k := b)
    | |- _ // _ ->> _ => apply mm_compute_DEC_0 with (x := a) (k := b)
  end; auto.

Tactic Notation "mm" "sss" "DEC" "S" "with" uconstr(a) uconstr(b) uconstr(c) := 
  match goal with
    | |- _ // _ -+> _ => apply mm_progress_DEC_S with (x := a) (k := b) (u := c)
    | |- _ // _ ->> _ => apply mm_compute_DEC_S with (x := a) (k := b) (u := c)
  end; auto.
    
Tactic Notation "mm" "sss" "stop" := exists 0; apply sss_steps_0; auto.

Definition MM_PROBLEM := { n : nat & { P : list (mm_instr n) & vec nat n } }.

Local Notation "i // s -1> t" := (@mm_sss _ i s t).
Local Notation "P // s ~~> t" := (sss_output (@mm_sss _) P s t).
Local Notation "P // s ‚Üì" := (sss_terminates (@mm_sss _) P s). 

Definition MM_HALTS_ON_ZERO (P : MM_PROBLEM) := 
  match P with existT _ n (existT _ P v) => (1,P) // (1,v) ~~> (0,vec_zero) end.

Definition MM_HALTING (P : MM_PROBLEM) :=
  match P with existT _ n (existT _ P v) => (1, P) // (1, v) ‚Üì end.

Section mm_special_ind.

  Variables (n : nat) (P : nat*list (mm_instr n)) (se : nat * vec nat n)
            (Q : nat * vec nat n -> Prop).

  Hypothesis (HQ0 : Q se)
             (HQ1 : forall i œÅ v j w,   (i,œÅ::nil) <sc P
                                     -> œÅ // (i,v) -1> (j,w)
                                     -> P // (j,w) ->> se
                                     -> Q (j,w)
                                     -> Q (i,v)).

  Theorem mm_special_ind s : P // s ->> se -> Q s.

End mm_special_ind.

Section mm_term_ind.

  Variables (n : nat) (P : nat*list (mm_instr n)) (se : nat * vec nat n)
            (Q : nat * vec nat n -> Prop).

  Hypothesis (HQ0 : out_code (fst se) P -> Q se)
             (HQ1 : forall i œÅ v j w,    (i,œÅ::nil) <sc P
                                     -> œÅ // (i,v) -1> (j,w)
                                     -> P // (j,w) ~~> se
                                     -> Q (j,w)
                                     -> Q (i,v)).

  Theorem mm_term_ind s : P // s ~~> se -> Q s.

End mm_term_ind. *)
(* eill:
Require Import List Permutation Arith Omega.

Require Import utils pos vec ill.

Set Implicit Arguments.

Local Infix "~p" := (@Permutation _) (at level 70).

Definition ll_vars := nat.

Inductive eill_cmd : Set :=
  | in_ll_cmd_inc  : ll_vars -> ll_vars -> ll_vars -> eill_cmd
  | in_ll_cmd_dec  : ll_vars -> ll_vars -> ll_vars -> eill_cmd
  | in_ll_cmd_fork : ll_vars -> ll_vars -> ll_vars -> eill_cmd.

Notation LL_INC  := in_ll_cmd_inc.
Notation LL_DEC  := in_ll_cmd_dec.
Notation LL_FORK := in_ll_cmd_fork.

Definition eill_cmd_vars c := 
  match c with
    | LL_INC  a p q => a::p::q::nil
    | LL_DEC  a p q => a::p::q::nil
    | LL_FORK p q r => p::q::r::nil
  end.

Definition eill_cmd_map c :=
  match c with
    | LL_INC  a p q => (¬£a ‚ä∏ ¬£p) -o ¬£ q
    | LL_DEC  a p q => ¬£a ‚ä∏ ¬£p -o ¬£ q
    | LL_FORK p q r => (¬£p Ôπ† ¬£q) -o ¬£ r
  end. 

Notation "'[i' c ']'" := (eill_cmd_map c) (at level 0).

Reserved Notation "Si ; Ga '‚ä¶' x" (at level 70, no associativity).

Inductive G_eill (Œ£ : list eill_cmd) : list ll_vars -> ll_vars -> Prop :=
  | in_eill_ax  : forall u,                                    Œ£; u::‚àÖ ‚ä¶ u
  | in_eill_perm : forall Œì Œî p,    Œì ~p Œî                 ->  Œ£; Œì     ‚ä¶ p
                                                           ->  Œ£; Œî     ‚ä¶ p
  | in_eill_inc : forall Œì a p q,   In (LL_INC a p q) Œ£    ->  Œ£; a::Œì  ‚ä¶ p
                                                           ->  Œ£; Œì     ‚ä¶ q
  | in_eill_dec : forall Œì Œî p q r, In (LL_DEC p q r) Œ£    ->  Œ£; Œì     ‚ä¶ p
                                                           ->  Œ£; Œî     ‚ä¶ q
                                                           ->  Œ£; Œì++Œî  ‚ä¶ r
  | in_eill_fork : forall Œì p q r,  In (LL_FORK p q r) Œ£   ->  Œ£; Œì     ‚ä¶ p
                                                           ->  Œ£; Œì     ‚ä¶ q
                                                           ->  Œ£; Œì     ‚ä¶ r
where "Si ; Ga ‚ä¶ u" := (G_eill Si Ga u).

Definition EILL_SEQUENT := (list eill_cmd * list ll_vars * ll_vars)%type.

Definition EILL_PROVABILITY (c : EILL_SEQUENT) := match c with (Œ£,Œì,A) => Œ£; Œì ‚ä¶ A end. 

Theorem g_eill_mono_Si Œ£ Œ£' Œì u : incl Œ£ Œ£' -> Œ£; Œì ‚ä¶ u -> Œ£'; Œì ‚ä¶ u.

Theorem G_eill_sound Œ£ Œì p : Œ£; Œì ‚ä¶ p -> map (fun c => ![i c]) Œ£ ++ map ¬£ Œì ‚ä¢ ¬£ p.

Section TPS.

  Variables (n : nat) (s : ll_vars -> vec nat n -> Prop) (rx : pos n -> ll_vars).

  Fact ll_tps_vec_map_list_mono : 
       (forall (p : pos n), s (rx p) (vec_one p)) 
     -> forall v, ll_tps_list s (map ¬£ (vec_map_list v rx)) v.

  Fact ll_tps_vec_map_list : 
       (forall (p : pos n) (v : vec nat n), s (rx p) v <-> v = vec_one p) 
     -> forall v w, ll_tps_list s (map ¬£ (vec_map_list v rx)) w <-> v = w.

End TPS.

Section g_eill_complete_bound.
 
  Variable (Si : list eill_cmd) (Ga : list ll_vars) (n : nat).

  Notation vars := (flat_map eill_cmd_vars Si ++ Ga).

  Hypothesis (w : vec ll_vars n)
             (w_surj : forall u, In u vars -> exists p, u = vec_pos w p).

  Let rx p := vec_pos w p.

  Let Hrx l : incl l (flat_map eill_cmd_vars Si ++ Ga) -> exists v, l ~p vec_map_list v rx.

  Let s x v := Si; vec_map_list v rx ‚ä¶ x.

  Notation "‚ü¶ A ‚üß" := (ll_tps s A) (at level 65).
  Notation "'[<' Œì '|-' A '>]'" := (ll_sequent_tps s Œì A) (at level 65).

  Theorem G_eill_complete_bound x : [< map (fun c => ‚ùó[i c]) Si ++ map ¬£ Ga |- ¬£ x >] vec_zero ->
                              Si; Ga ‚ä¶ x.

End g_eill_complete_bound.

Section g_eill_complete.
 
  Variable (Si : list eill_cmd) (Ga : list ll_vars).

  Notation vars := (flat_map eill_cmd_vars Si ++ Ga).

  Let vv := nat_sort vars.

  Let Hvv1 : list_injective vv.

  Let Hvv2 : incl vv (flat_map eill_cmd_vars Si ++ Ga) 
          /\ incl (flat_map eill_cmd_vars Si ++ Ga) vv.

  Let n := length vv.
  Let w : vec ll_vars n := proj1_sig (list_vec vv).
  Let Hw : vec_list w = vv.

  Let w_surj : forall u, In u vars -> exists p, u = vec_pos w p.

  Variables (x : ll_vars)
            (Hvalid : forall n s, @ll_sequent_tps n s (map (fun c : eill_cmd => ‚ùó [ic]) Si ++ map ¬£ Ga) (¬£ x) vec_zero).

  Theorem G_eill_complete : Si; Ga ‚ä¶ x.

End g_eill_complete.

Theorem G_eill_correct Si Ga p : 
           Si; Ga ‚ä¶ p <-> map (fun c => ![i c]) Si ++ map ¬£ Ga ‚ä¢ ¬£ p. *)
(* ill:
Require Import List Permutation Arith Omega.

Require Import utils pos vec.

Set Implicit Arguments.

Local Infix "~p" := (@Permutation _) (at level 70).

Definition ll_vars := nat.

Inductive ll_conn := ll_with | ll_limp | ll_times | ll_plus.
Inductive ll_cst := ll_one | ll_bot | ll_top.

Inductive ll_form : Set :=
  | ll_var  : ll_vars -> ll_form
  | ll_zero : ll_cst  -> ll_form
  | ll_ban  : ll_form -> ll_form
  | ll_bin  : ll_conn -> ll_form -> ll_form -> ll_form.

Notation "‚üô" := (ll_zero ll_top).
Notation "‚üò" := (ll_zero ll_bot).
Notation ùùê := (ll_zero ll_one).

Infix "&" := (ll_bin ll_with) (at level 50, only parsing).
Infix "Ôπ†" := (ll_bin ll_with) (at level 50).
Infix "‚äó" := (ll_bin ll_times) (at level 50).
Infix "‚äï" := (ll_bin ll_plus) (at level 50).
Infix "-o" := (ll_bin ll_limp) (at level 51, only parsing, right associativity).
Infix "‚ä∏" := (ll_bin ll_limp) (at level 51, right associativity).

Notation "'!' x" := (ll_ban x) (at level 52, only parsing).
Notation "‚ùó x" := (ll_ban x) (at level 52).

Notation "¬£" := ll_var.

Definition ll_lbang := map (fun x => !x).

Notation "'!l' x" := (ll_lbang x) (at level 60, only parsing).
Notation "‚Äº x" := (ll_lbang x) (at level 60).

Notation "‚àÖ" := nil (only parsing).

Reserved Notation "l '‚ä¢' x" (at level 70, no associativity).

Inductive S_ill : list ll_form -> ll_form -> Prop :=

  | in_llp_ax     : forall A,                         A::‚àÖ ‚ä¢ A

  | in_llp_perm   : forall Œì Œî A,              Œì ~p Œî     ->   Œì ‚ä¢ A 
                                           
                                      ->                 Œî ‚ä¢ A

  | in_llp_limp_l : forall Œì Œî A B C,          Œì ‚ä¢ A      ->   B::Œî ‚ä¢ C
                                               
                                      ->           A ‚ä∏ B::Œì++Œî ‚ä¢ C

  | in_llp_limp_r : forall Œì A B,                    A::Œì ‚ä¢ B
                                           
                                      ->            Œì ‚ä¢ A ‚ä∏ B

  | in_llp_with_l1 : forall Œì A B C,                  A::Œì ‚ä¢ C 
                                           
                                      ->           AÔπ†B::Œì ‚ä¢ C

  | in_llp_with_l2 : forall Œì A B C,                  B::Œì ‚ä¢ C 
                                           
                                      ->           AÔπ†B::Œì ‚ä¢ C
 
  | in_llp_with_r : forall Œì A B,               Œì ‚ä¢ A     ->   Œì ‚ä¢ B
                                           
                                      ->              Œì ‚ä¢ AÔπ†B

  | in_llp_bang_l : forall Œì A B,                    A::Œì ‚ä¢ B
                                           
                                      ->            ‚ùó A::Œì ‚ä¢ B

  | in_llp_bang_r : forall Œì A,                       ‚ÄºŒì ‚ä¢ A
                                           
                                      ->              ‚ÄºŒì ‚ä¢ ‚ùó A

  | in_llp_weak : forall Œì A B,                        Œì ‚ä¢ B
                                           
                                      ->           ‚ùó A::Œì ‚ä¢ B

  | in_llp_cntr : forall Œì A B,                    ‚ùó A::‚ùó A::Œì ‚ä¢ B
                                           
                                      ->             ‚ùó A::Œì ‚ä¢ B

  | in_llp_cut : forall Œì Œî A B,                 Œì ‚ä¢ A    ->   A::Œî ‚ä¢ B
                                               
                                      ->              Œì++Œî ‚ä¢ B

  | in_llp_times_l : forall Œì A B C,               A::B::Œì ‚ä¢ C 
                                           
                                      ->            A‚äóB::Œì ‚ä¢ C
 
  | in_llp_times_r : forall Œì Œî A B,             Œì ‚ä¢ A    ->   Œî ‚ä¢ B
                                           
                                      ->              Œì++Œî ‚ä¢ A‚äóB

  | in_llp_plus_l :  forall Œì A B C,            A::Œì ‚ä¢ C  ->  B::Œì ‚ä¢ C 
                                           
                                      ->            A‚äïB::Œì ‚ä¢ C

  | in_llp_plus_r1 : forall Œì A B,                    Œì ‚ä¢ A  
                                           
                                      ->              Œì ‚ä¢ A‚äïB

  | in_llp_plus_r2 : forall Œì A B,                    Œì ‚ä¢ B  
                                           
                                      ->              Œì ‚ä¢ A‚äïB

  | in_llp_bot_l : forall Œì A,                     ‚üò::Œì ‚ä¢ A

  | in_llp_top_r : forall Œì,                          Œì ‚ä¢ ‚üô

  | in_llp_unit_l : forall Œì A,                       Œì ‚ä¢ A  
                                           
                                      ->           ùùê ::Œì ‚ä¢ A

  | in_llp_unit_r :                                   ‚àÖ ‚ä¢ ùùê

where "l ‚ä¢ x" := (S_ill l x).

Definition ILL_PROVABILITY (c : (list ll_form) * ll_form) := let (Ga,A) := c in Ga ‚ä¢ A. 

Fact S_ill_weak Œì Œî B : Œî ‚ä¢ B -> ‚ÄºŒì++Œî ‚ä¢ B.

Fact S_ill_cntr Œì Œî B : ‚ÄºŒì++‚ÄºŒì++Œî ‚ä¢ B -> ‚ÄºŒì++ Œî ‚ä¢ B.

Theorem S_ill_weak_cntr Œ£ Œì A B : In A Œ£ -> ‚ÄºŒ£++Œì ‚ä¢ B <-> ‚ùó A::‚ÄºŒ£++Œì ‚ä¢ B.

Section trivial_phase_semantics.

  Variables (n : nat) (s : ll_vars -> vec nat n -> Prop).

  Reserved Notation "'‚ü¶' A '‚üß'" (at level 65).

  Definition ll_tps_imp (X Y : _ -> Prop) (v : vec _ n) := forall x, X x -> Y (vec_plus x v).
  Definition ll_tps_mult (X Y : _ -> Prop) (x : vec _ n) := exists a b, x = vec_plus a b /\ X a /\ Y b. 
  
  Infix "**" := (ll_tps_mult) (at level 65, right associativity).
  Infix "-*" := (ll_tps_imp) (at level 65, right associativity).

  Fact ll_tps_mult_mono (X1 X2 Y1 Y2 : _ -> Prop) : 
             (forall x, X1 x -> X2 x)
          -> (forall x, Y1 x -> Y2 x)
          -> (forall x, (X1**Y1) x -> (X2**Y2) x).

  Fixpoint ll_tps A x : Prop :=
    match A with
      | ¬£ X     => s X x
      | A Ôπ† B  => ‚ü¶A‚üß x /\ ‚ü¶B‚üß x
      | ‚ùó A     => ‚ü¶A‚üß x /\ x = vec_zero
      | A ‚ä∏ B  => (‚ü¶A‚üß -* ‚ü¶B‚üß) x
      | A ‚äó B  => (‚ü¶A‚üß ** ‚ü¶B‚üß) x
      | A ‚äï B  => ‚ü¶A‚üß x \/ ‚ü¶B‚üß x
      | ‚üò             => False
      | ‚üô             => True
      | ùùê              => x = vec_zero
    end
  where "‚ü¶ A ‚üß" := (ll_tps A).

  Reserved Notation "'[[' Œì ']]'" (at level 0).

  Fixpoint ll_tps_list Œì :=
    match Œì with
      | ‚àÖ    => eq vec_zero
      | A::Œì => ‚ü¶A‚üß ** [[Œì]]
    end
  where "[[ Œì ]]" := (ll_tps_list Œì).

  Fact ll_tps_app Œì Œî x : [[Œì++Œî]] x <-> ([[Œì]]**[[Œî]]) x.

  Fact ll_tps_lbang Œì x : [[‚ÄºŒì]] x <-> [[Œì]] x /\ x = vec_zero.

  Fact ll_tps_list_bang_zero Œì : [[‚ÄºŒì]] vec_zero <-> forall A, In A Œì -> ‚ü¶A‚üß vec_zero.

  Fact ll_tps_perm Œì Œî : Œì ~p Œî -> forall x, [[Œì]] x -> [[Œî]] x.
  
  Definition ll_sequent_tps Œì A := [[Œì]] -* ‚ü¶A‚üß.

  Notation "'[<' Œì '|-' A '>]'" := (ll_sequent_tps Œì A).

  Fact ll_sequent_tps_mono Œì A B :
     (forall x, ‚ü¶A‚üß x -> ‚ü¶B‚üß x) -> forall x, [< Œì |- A >] x -> [< Œì |- B >] x.

  Fact ll_perm_tps Œì Œî : Œì ~p Œî -> forall x A, [< Œì |- A >] x -> [< Œî |- A >] x.

  Fact ll_sequent_tps_eq  Œì A : [< Œì |- A >] vec_zero <-> forall x, [[Œì]] x -> ‚ü¶A‚üß x.

  Theorem ll_tps_sound Œì A : Œì ‚ä¢ A -> [< Œì |- A >] vec_zero.

End trivial_phase_semantics. *)

Require Import PCP_BPCP BPCP_iBPCP iBPCP_BSM BSM_MM MM_EILL EILL_ILL.
(* PCP_BPCP:
Require Import ILL.Definitions.

Definition to_bitstring (n : nat) : string bool := Nat.iter n (cons true) [].

Lemma bitstring_false a : ~ false el to_bitstring a.

Fixpoint f_s (x : string nat) : string bool :=
  match x with
  | nil => nil
  | a :: x => to_bitstring a ++ [false] ++ f_s x
  end.

Lemma f_s_app x y : f_s (x ++ y) = f_s x ++ f_s y.

Definition f_c '(x,y) := (f_s x, f_s y).
Definition f (P : SRS) : BSRS :=
  map f_c P.

Lemma tau1_f A : tau1 (f A) = f_s (tau1 A).

Lemma tau2_f A : tau2 (f A) = f_s (tau2 A).

Fixpoint g_s' (x : string bool) (n : nat) : string nat :=
  match x with
  | nil => nil
  | true :: x' => g_s' x' (S n)
  | false :: x' => n :: g_s' x' 0
  end.

Lemma g_s'_app n x y :
  g_s' (f_s x ++ y) n = match x with nil => g_s' y n | m :: x => n + m :: x ++ g_s' y 0 end.

Definition g_s x := g_s' x 0.

Lemma f_g_s'_inv x : g_s (f_s x) = x.

Definition g_c '(x,y) := (g_s x, g_s y).
Definition g (P : BSRS) : SRS :=
  map g_c P.

Lemma tau1_g A B : A <<= f B -> tau1 (g A) = g_s (tau1 A).

Lemma tau2_g A B : A <<= f B -> tau2 (g A) = g_s (tau2 A).

Lemma f_subset B A : A <<= B -> f A <<= f B.

Lemma f_g_subset B A : A <<= f B -> g A <<= B.

Lemma PCP_BPCP : PCP ‚™Ø  BPCP. *)
(* BPCP_iBPCP:
Require Import ILL.Definitions.

Definition card_eq : forall x y : card bool, {x = y} + {x <> y}.

Definition f (P : BSRS) (A : stack bool) := omap (fun x => pos card_eq x P) A.

Lemma itau_tau1 P A : A <<= P -> itau1 P (f P A) = tau1 A.

Lemma itau_tau2 P A : A <<= P -> itau2 P (f P A) = tau2 A.

Definition g (P : BSRS) (A : list nat) := map (fun n => nth n P ( [] / [] )) A.

Lemma tau_itau1 P A : (forall a : nat, a el A -> a < | P |) -> tau1 (g P A) = itau1 P A.

Lemma tau_itau2 P A : (forall a : nat, a el A -> a < | P |) -> tau2 (g P A) = itau2 P A.

Lemma BPCP_iBPCP : BPCP ‚™Ø iBPCP. *)
(* iBPCP_BSM:
Require Import List Arith Omega.

Require Import ILL.Definitions.

Require Import utils pos vec. 
Require Import subcode sss. 
Require Import tiles_solvable bsm_defs bsm_pcp.

Fact tile_concat_itau ln lt : tile_concat ln lt = (itau1 lt (rev ln), itau2 lt (rev ln)).

Theorem tiles_solvable_iBPCP lt : tiles_solvable lt <-> iBPCP lt.

Local Notation "P // s ->> t" := (sss_compute (@bsm_sss _) P s t).
Local Notation "P // s ~~> t" := (sss_output (@bsm_sss _) P s t).
Local Notation "P // s ‚Üì" := (sss_terminates (@bsm_sss _) P s). 

Section iBPCP_BSM_HALTING.

  Let f (lt : list (card bool)) : BSM_PROBLEM.

  Goal forall x, | pcp_bsm x| >= 80.
  
  Theorem iBPCP_BSM_HALTING : iBPCP ‚™Ø BSM_HALTING.

End iBPCP_BSM_HALTING. *)
(* BSM_MM:
Require Import List Arith Omega.

Require Import ILL.Definitions.

Require Import utils pos vec. 
Require Import subcode sss. 
Require Import list_bool bsm_defs mm_defs mm_utils mm_comp.

Local Notation "P '/BSM/' s ‚Üì" := (sss_terminates (@bsm_sss _) P s) (at level 70, no associativity).
Local Notation "P '/MM/' s ~~> t" := (sss_output (@mm_sss _) P s t) (at level 70, no associativity).

Section BSM_MM_HALTS_ON_ZERO.

  Let f : BSM_PROBLEM -> MM_PROBLEM.

  Theorem BSM_MM_HALTS_ON_ZERO : BSM_HALTING ‚™Ø MM_HALTS_ON_ZERO.

End BSM_MM_HALTS_ON_ZERO.

Section BSM_MM_HALTING.

  Let f : BSM_PROBLEM -> MM_PROBLEM.

  Theorem BSM_MM_HALTING : BSM_HALTING ‚™Ø MM_HALTING.

End BSM_MM_HALTING. *)
(* MM_EILL:
Require Import List Arith Omega.

Require Import ILL.Definitions.

Require Import utils pos vec. 
Require Import subcode sss mm_defs.
Require Import eill eill_mm.

Local Notation "P '/MM/' s ->> t" := (sss_compute (@mm_sss _) P s t) (at level 70, no associativity).
Local Notation "P '/MM/' s ~~> t" := (sss_output (@mm_sss _) P s t) (at level 70, no associativity).

Section MM_HALTING_EILL_PROVABILITY.

  Let f : MM_PROBLEM -> EILL_SEQUENT.

  Theorem MM_HALTS_ON_ZERO_EILL_PROVABILITY : MM_HALTS_ON_ZERO ‚™Ø EILL_PROVABILITY.

End MM_HALTING_EILL_PROVABILITY. *)
(* EILL_ILL:
Require Import List Arith Omega.

Require Import ILL.Definitions.

Require Import ill eill. 

Section EILL_ILL.

  Theorem EILL_ILL_PROVABILITY : EILL_PROVABILITY ‚™Ø ILL_PROVABILITY.

End EILL_ILL. *)

Check PCP_BPCP.                           Print Assumptions PCP_BPCP.
Check BPCP_iBPCP.                         Print Assumptions BPCP_iBPCP.
Check iBPCP_BSM_HALTING.                  Print Assumptions iBPCP_BSM_HALTING.
Check BSM_MM_HALTING.                     Print Assumptions BSM_MM_HALTING.
Check BSM_MM_HALTS_ON_ZERO.               Print Assumptions BSM_MM_HALTS_ON_ZERO.
Check MM_HALTS_ON_ZERO_EILL_PROVABILITY.  Print Assumptions MM_HALTS_ON_ZERO_EILL_PROVABILITY.
Check EILL_ILL_PROVABILITY.               Print Assumptions EILL_ILL_PROVABILITY.

Theorem PCP_BSM_HALTING : PCP ‚™Ø BSM_HALTING.
Proof.
  eapply reduces_transitive. exact PCP_BPCP.
  eapply reduces_transitive. exact BPCP_iBPCP.
  exact iBPCP_BSM_HALTING.
Qed.

Theorem PCP_MM_HALTS_ON_ZERO : PCP ‚™Ø MM_HALTS_ON_ZERO.
Proof.
  eapply reduces_transitive. exact PCP_BSM_HALTING.
  exact BSM_MM_HALTS_ON_ZERO.
Qed.

Theorem PCP_MM_HALTING : PCP ‚™Ø MM_HALTING.
Proof.
  eapply reduces_transitive. exact PCP_BSM_HALTING.
  exact BSM_MM_HALTING.
Qed.

Theorem PCP_ILL : PCP ‚™Ø ILL_PROVABILITY.
Proof.
  eapply reduces_transitive. exact PCP_MM_HALTS_ON_ZERO.
  eapply reduces_transitive. exact MM_HALTS_ON_ZERO_EILL_PROVABILITY.
  exact EILL_ILL_PROVABILITY.
Qed.

Module Def_of_undec.

  Inductive dec {X} (P : X -> Prop) : Prop := is_dec (H : forall x, { P x} + {~ P x}).

  Notation compl P := (fun x => ~ P x).

  Notation "Q ‚™ØT P" := (dec (P) -> dec (Q)) (at level 20).

  Lemma red_turing X Y (P : X -> Prop) (Q : Y -> Prop) : P ‚™Ø Q -> P ‚™ØT Q.
  Proof.
    intros (f & Hf) [ H ].
    exists.
    intros x; destruct (H (f x)) as [ H1 | H1 ]; 
      rewrite <- Hf in H1; tauto.
  Qed.

  Inductive undec : forall X, (X -> Prop) -> Prop :=
    undec_seed : undec PCP
  | undec_red X (P : X -> Prop) Y (Q : Y -> Prop) : Q ‚™ØT P -> undec Q -> undec P.

  Lemma red_undec  X Y (Q : Y -> Prop) (P : X -> Prop) :
    Q ‚™Ø P -> undec Q -> undec P.
  Proof.
    intros. eapply undec_red. eapply red_turing; eauto. eauto.
  Qed.
    
  Lemma undec_compl X (P : X -> Prop) :
    undec (compl P) -> undec P.
  Proof.
    intros. eapply undec_red; try eassumption. firstorder.
  Qed.
  
  Lemma undec_PCP X (P : X -> Prop) :
    undec P <-> (PCP ‚™ØT P).
  Proof.
    split; intros.
    - induction H; eauto.
    - eauto using undec. 
  Qed.
    
End Def_of_undec.
