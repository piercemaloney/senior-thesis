
Require Export Problems.Reduction DecidableEnumerable.
(* Problems.Reduction:
Require Export Shared.Prelim.

Definition reduces X Y (p : X -> Prop) (q : Y -> Prop) := exists f : X -> Y, forall x, p x <-> q (f x).
Notation "p ⪯ q" := (reduces p q) (at level 50).

Lemma reduces_reflexive X (p : X -> Prop) : p ⪯ p.

Lemma reduces_transitive X Y Z (p : X -> Prop) (q : Y -> Prop) (r : Z -> Prop) :
  p ⪯ q -> q ⪯ r -> p ⪯ r. *)
(* DecidableEnumerable:
Require Export Shared.Prelim.

Definition compl X p := fun x : X => ~ p x.
Definition decidable {X} (p : X -> Prop) := exists f, forall x, p x <-> f x = true.
Definition enumerable {X} (p : X -> Prop) := exists f, forall x, p x <-> exists n : nat, f n = Some x.

Definition discrete X := decidable (fun '(x,y) => x = y :> X). 
Definition enumerable__T X := exists f : nat -> option X, forall x, exists n, f n = Some x.

Lemma dec_decidable' X p :
  (forall x : X, dec (p x)) -> { f : _ | forall x, p x <-> f x = true}.

Lemma decidable_iff X p :
  decidable p <-> inhabited (forall x : X, dec (p x)).

Lemma discrete_iff X :
  discrete X <-> inhabited (eq_dec X).

Lemma dec_compl X p :
  decidable p -> decidable (fun x : X => ~ p x).

Lemma dec_conj X p q :
  decidable p -> decidable q -> decidable (fun x : X => p x /\ q x).

Lemma dec_disj X p q :
  decidable p -> decidable q -> decidable (fun x : X => p x \/ q x).

Theorem dec_count_enum X (p : X -> Prop) :
  decidable p -> enumerable__T X -> enumerable p.

Theorem dec_count_enum' X (p : X -> Prop) :
  decidable p -> enumerable__T X -> enumerable (fun x => ~ p x).

Lemma enumerable_enumerable_T X :
  enumerable (fun _ : X => True) <-> enumerable__T X.

Definition cumulative {X} (L: nat -> list X) :=
  forall n, exists A, L (S n) = L n ++ A.
Hint Extern 0 (cumulative _) => intros ?; cbn; eauto.

Lemma cum_ge {X} (L: nat -> list X) n m :
  cumulative L -> m >= n -> exists A, L m = L n ++ A.

Lemma cum_ge' {X} (L: nat -> list X) x n m :
  cumulative L -> x el L n -> m >= n -> x el L m.

Definition enum {X} p (L: nat -> list X) :=
  cumulative L /\ forall x, p x <-> exists m, x el L m.

Section enumerable_enum.

  Variable X : Type.
  Variable p : X -> Prop.
  Variables (e : nat -> option X).
  
  Definition T_ (n : nat) : list X :=  match e n with Some x => [x] | None => [] end.

  Lemma count_enum' : exists L : nat -> list X, forall x, (exists n, e n = Some x) <-> (exists n, x el L n).
      
End enumerable_enum.

Lemma enum_to_cumulative X (p : X -> Prop) L :
  (forall x, p x <-> exists m : nat, x el L m) -> exists L, enum p L.

Class enumT X :=
  {
    L_T :> nat -> list X;
    cum_T : cumulative L_T ;
    el_T : forall x, exists m, x el L_T m
  }.

Arguments L_T {_ _} _, _ {_} _.
Hint Immediate cum_T.

Lemma discrete_bool : discrete bool.

Lemma discrete_nat : discrete nat.

Lemma discrete_nat_nat : discrete (nat * nat).

Lemma count_bool :
  enumerable__T bool.

Lemma count_nat :
  enumerable__T nat.

Lemma T_nat_in n m : m <= n -> m el L_T nat n.

Lemma T_nat_length n : length (L_T nat n) = S n.

Section enumerable_prod.

  Variable X Y : Type.

  Section fixLs.
    
    Variables (L_X : enumT X).
    Variables (L_Y : enumT Y).
    
    Fixpoint T_prod (n : nat) : list (X * Y) :=
      match n
      with
      | 0 => [ (x,y) | (x,y) ∈ (L_T X 0 × L_T Y 0) ]
      | S n => T_prod n ++ [ (x,y) | (x,y) ∈ (L_T X n  × L_T Y n) ]
      end.

    Lemma T_prod_cum : cumulative T_prod.

  End fixLs.
  
  Lemma T_prod_el LX LY (a : X * Y)  :
    exists n, a el T_prod LX LY n.

  Global Instance prod_enumerable (LX : enumT X) (LY : enumT Y) : enumT (X * Y). 

End enumerable_prod.

Lemma C_exhaustive n m : (n,m) el L_T (1 + n + m).

Lemma C_longenough n : length (L_T (nat * nat) n) > n.

Definition R_nat_nat n : option (nat * nat) := nthe n (L_T n).

Lemma pairs_retract :  forall p, exists n, R_nat_nat n = Some p. 

Lemma enumerable_nat_nat : enumerable__T (nat * nat).
  
Section enum_enumerable.
  
  Context X L p { enum_X : @enum X p L }.

  Definition ofNat n := match R_nat_nat n with Some (n, m) => nthe n ((L m)) | None => None end.

  Lemma enum_count : enumerable p.
  
End enum_enumerable.

Lemma discrete_prod X Y : discrete X -> discrete Y -> discrete (X * Y).

Lemma discrete_sum X Y : discrete X -> discrete Y -> discrete (X + Y).

Lemma discrete_option X : discrete X -> discrete (option X).

Lemma discrete_list X : discrete X -> discrete (list X).

Lemma enumerable_enum X p :
  (exists L, enum p L) <-> @enumerable X p.

Lemma enum_enumT X :
  enumerable__T X <-> inhabited (enumT X).

Lemma enumerable__T_prod X Y : enumerable__T X -> enumerable__T Y -> enumerable__T (X * Y).

Lemma enumerable__T_sum X Y : enumerable__T X -> enumerable__T Y -> enumerable__T (X + Y).

Lemma enumerable__T_option X : enumerable__T X -> enumerable__T (option X).

Section enumerable_list.

  Variable X : Type.

  Section fixL.
    
    Variables (LX : enumT X).

    Fixpoint T_list (n : nat) : list (list X) :=
      match n
      with
      | 0 => [ [] ]
      | S n => T_list n ++ [ x :: L | (x,L) ∈ (L_T X n × T_list n) ]
      end.

    Lemma T_list_cum : cumulative T_list. 

  End fixL.

  Lemma T_list_el LX l :
    exists n, l el T_list LX n.
  
  Global Instance enumerable_list (LX : enumT X) : enumT (list X).

End enumerable_list.

Lemma enumerable__T_list X : enumerable__T X -> enumerable__T (list X).

Lemma enumerable_disj X (p q : X -> Prop) :
  enumerable p -> enumerable q -> enumerable (fun x => p x \/ q x).

Lemma enumerable_conj X (p q : X -> Prop) :
  discrete X -> enumerable p -> enumerable q -> enumerable (fun x => p x /\ q x).

Lemma projection X Y (p : X * Y -> Prop) :
  enumerable p -> enumerable (fun x => exists y, p (x,y)).

Lemma projection' X Y (p : X * Y -> Prop) :
  enumerable p -> enumerable (fun y => exists x, p (x,y)). *)

Lemma dec_red X (p : X -> Prop) Y (q : Y -> Prop) :
  p ⪯ q -> decidable q -> decidable p.
Proof.
  intros [f] [d]. exists (fun x => d (f x)). intros x. rewrite H. eapply H0.
Qed.

Lemma red_comp X (p : X -> Prop) Y (q : Y -> Prop) :
  p ⪯ q -> (fun x => ~ p x) ⪯ (fun y => ~ q y).
Proof.
  intros [f]. exists f. intros x. now rewrite H.
Qed.

Section enum_red.

  Variables (X Y : Type) (p : X -> Prop) (q : Y -> Prop).
  Variables (f : X -> Y) (Hf : forall x, p x <-> q (f x)).

  Variables (Lq : _) (qe : enum q Lq).

  Variables (x0 : X).
  
  Variables (d : eq_dec Y).
  
  Fixpoint L (LX : enumT X) n :=
    match n with
    | 0 => []
    | S n => L LX n ++ [ x | x ∈ L_T X n , f x el Lq n ]
    end.

  Lemma enum_red LX :
    enum p (L LX).
  Proof.    
    split.
    - intros ?. cbn; eauto. 
    - split.
      + intros H.
        eapply Hf in H. eapply qe in H as [m1]. destruct (el_T x) as [m2 ?]. 
        exists (1 + m1 + m2). cbn. in_app 2.
        in_collect x; eapply cum_ge'; eauto; try omega.
        eapply qe.
      + intros [m H]. induction m.
        * inv H.
        * cbn in H. inv_collect. 
          eapply Hf. eapply qe. eauto.
  Qed.

End enum_red.

Lemma enumerable_red X Y (p : X -> Prop) (q : Y -> Prop) :
  p ⪯ q -> enumerable__T X -> discrete Y -> enumerable q -> enumerable p.
Proof.
  intros [f] [] % enum_enumT [] % discrete_iff [L] % enumerable_enum.
  eapply enum_count, enum_red with (Y := Y); eauto.
Qed.

Theorem not_decidable X Y (p : X -> Prop) (q : Y -> Prop) :
  p ⪯ q -> enumerable__T X -> ~ enumerable (compl p) ->
  ~ decidable q /\ ~ decidable (compl q).
Proof.
  intros. split; intros ?.
  - eapply H1. eapply dec_red in H2; eauto.
    eapply dec_compl in H2. eapply dec_count_enum; eauto.
  - eapply H1. eapply dec_red in H2; eauto.
    eapply dec_count_enum; eauto. now eapply red_comp.
Qed.

Theorem not_coenumerable X Y (p : X -> Prop) (q : Y -> Prop) :
  p ⪯ q -> enumerable__T X -> ~ enumerable (compl p) -> discrete Y ->
  ~ enumerable (compl q).
Proof.
  intros. intros ?. eapply H1. eapply enumerable_red in H3; eauto.
  now eapply red_comp.
Qed.

