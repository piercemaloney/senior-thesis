
Require Export FOL.Deduction.
(* FOL.Deduction:
Require Export Semantics.

Inductive nd := intu | class.
Existing Class nd.

Inductive prv : forall {s : nd} {b : logic} (A : list (form b)), form b -> Prop :=
| Ctx {b} {s : nd} (A : list (form b)) phi : In phi A -> prv A phi
| ImpI {b} {s : nd} (A : list (form b)) phi1 phi2 : prv (phi1::A) phi2 -> prv A (phi1 --> phi2)
| ImpE {b} {s : nd} (A : list (form b)) phi1 phi2 : prv A (phi1 --> phi2) -> prv A phi1 -> prv A phi2
| AllI {b} {s : nd} (A : list (form b)) x y phi : fresh y (consts phi ++ consts_l A) -> prv A (subst x (P y) phi) -> prv A (∀ x ; phi)
| AllE {b} {s : nd} (A : list (form b)) x t phi : vars_t t = [] 
                                       -> prv A (All x phi) -> prv A (subst x t phi)

| Exp A phi : @prv intu full A Fal -> @prv intu full A phi
| DN A phi : @prv class full A (¬¬ phi) -> @prv class full A phi.

Notation "A ⊢ phi" := (prv A phi) (at level 30).

Definition prv_min := @prv intu frag.
Definition prv_class := @prv class full.
Definition prv_intu := @prv intu full.

Notation "A ⊢M phi" := (prv_min A phi) (at level 30).
Notation "A ⊢I phi" := (@prv intu _ A phi) (at level 30).
Notation "A ⊢C phi" := (@prv class _ A phi) (at level 30).

Lemma prv_ind_min :
  forall p : list (form frag) -> form frag -> Prop,
       (forall  (A : list (form frag)) (phi : form frag), phi el A -> p A phi) ->
       (forall  (A : list (form frag)) (phi1 phi2 : form frag),
        (phi1 :: A) ⊢I phi2 -> p (phi1 :: A) phi2 -> p A (phi1 --> phi2)) ->
       (forall  (A : list (form frag)) (phi1 phi2 : form frag),
        A ⊢I (phi1 --> phi2) -> p A (phi1 --> phi2) -> A ⊢I phi1 -> p A phi1 -> p A phi2) ->
       (forall  (A : list (form frag)) (x y : nat) (phi : form frag),
        fresh y (consts phi ++ consts_l A) ->
        A ⊢I subst x (P y) phi -> p A (subst x (P y) phi) -> p A (∀ x; phi)) ->
       (forall  (A : list (form frag)) (x : nat) (t : term) (phi : form frag),
           vars_t t = [] ->
        A ⊢I (∀ x; phi) -> p A (∀ x; phi) -> p A (subst x t phi)) ->
       forall (A : list (form frag)) (f9 : form frag), A ⊢I f9 -> p A f9.

Definition cast {domain} (eta eta' : nat -> domain) (I : interp eta) : interp eta'.

Lemma eval_ext_p t dom rho rho' eta eta' (I : interp dom eta) :
  (forall v, v el vars_t t -> rho v = rho' v) ->
  (forall p, p el consts_t t -> eta p = eta' p) ->
  @eval _ _ I rho t = @eval _ _ (cast eta' I) rho' t.

Lemma eval_ext t dom rho rho' eta (I : interp dom eta) :
  (forall v, v el vars_t t -> rho v = rho' v) -> eval rho t = eval rho' t.

Lemma sat_ext_p b (phi : form b) dom rho rho' eta eta' (I : interp dom eta) :
  (forall v, rho v = rho' v) ->
  (forall p, p el consts phi -> eta p = eta' p) ->
  sat I rho phi <-> sat (cast eta' I) rho' phi.

Lemma sat_ext b (phi : form b) dom rho rho' eta (I : interp dom eta) :
  sat I rho phi -> (forall v, rho v = rho' v) -> sat I rho' phi.

Lemma sat_ext_p_list b (A : list (form b)) dom rho rho' eta eta' (I : interp dom eta) :
  (forall v, rho v = rho' v) ->
  (forall p, p el consts_l A -> eta p = eta' p) ->
  (forall phi, phi el A -> sat I rho phi) <-> (forall phi, phi el A -> sat (cast eta' I) rho' phi).

Lemma eval_empty t dom eta (I : interp dom eta) rho rho' :
  vars_t t = [] -> eval rho t = eval rho' t.

Lemma subst_eval dom eta (I : interp dom eta) rho x t t' :
  eval rho (subst_t x t' t) = eval (rho [[x:=eval rho t']]) t.

Lemma subst_sat b (phi : form b) dom eta (I : interp dom eta) rho x t :
  vars_t t = [] -> sat I rho (subst x t phi) <-> sat I (rho [[x:=eval rho t]]) phi.

Lemma substconst_sat b (phi : form b) dom eta rho x a d (I : interp dom eta) :
  fresh a (consts phi) ->
  sat (eta [[a := d]]) (cast _ I) rho (subst x (P a) phi) <->
  sat eta I (rho [[ x := d ]]) phi.

Lemma soundness' {b} A (phi : form b) :
  A ⊢I phi -> valid (A ==> phi).

Theorem soundness {b} (phi : form b) :
  nil ⊢I phi -> valid phi.

Fixpoint size {b} (phi : form b) :=
  match phi with
  | Pr _ _ | Q | Fal => 1
  | Impl phi1 phi2 => 1 + size phi1 + size phi2
  | All n phi => 1 + size phi
  end.

Lemma size_subst {b : logic} x t phi :
  size (subst x t phi) = size phi.

Lemma form_ind_subst :
forall P : forall f : logic, form f -> Prop,
(forall (b : logic) (t t0 : term), P b (Pr t t0)) ->
(forall b : logic, P b Q) ->
P full ⊥ ->
(forall (b : logic) (f2 : form b), P b f2 -> forall f3 : form b, P b f3 -> P b (f2 --> f3)) ->
(forall (b : logic) (n : var) (f4 : form b), (forall x, P b (subst n x f4)) -> P b (∀ n; f4)) -> forall (f5 : logic) (f6 : form f5), P f5 f6.

Lemma form_logic_ind_subst :
forall P : form frag -> Prop,
(forall t t0 : term, P (Pr t t0)) ->
P Q ->
(forall f3 : form frag, P f3 -> forall f4 : form frag, P f4 -> P (f3 --> f4)) ->
(forall (n : var) (f6 : form frag), (forall x, P (subst n x f6)) -> P (∀ n; f6)) -> forall f8 : form frag, P f8.

Lemma dec_fresh y A : dec (fresh y A).

Lemma incl_dec X (A B : list X) `{eq_dec X} : dec (A <<= B).

Fixpoint L_ded {b} {s : nd} (A : list (form b)) (n : nat) : list (form b) :=
  match n with
  | 0 => A
  | S n => L_ded A n
                ++ concat [ [ phi1 --> phi2 | phi2 ∈ L_ded (phi1 :: A) n ] | phi1 ∈ L_T (form b) n]
                ++ [ phi2 | (phi1,phi2) ∈ (L_ded A n × L_T (form b) n) , (phi1 --> phi2 el L_ded A n) ]
                ++ [ ∀ x; phi | (phi, x, y) ∈ (L_T (form b) n × L_T var n × L_T var n) ,
                               fresh y (consts phi ++ consts_l A) /\ subst x (P y) phi el L_ded A n ]
                ++ [ subst x t phi | (phi, x, t) ∈ (L_T (form b) n × L_T var n × L_T term n),
                                    vars_t t = [] /\ ∀ x; phi el L_ded A n]
                ++ match b with frag => fun _ => [] | full => fun A =>
                 match s with
                   | intu => [ phi | phi ∈ L_T (form full) n, Fal el L_ded A n ]
                   | class => [ phi | phi ∈ L_T (form full) n, (¬¬ phi) el L_ded A n ]
                   end end A
  end.

Opaque in_dec.
Opaque enumT_nat.

Hint Constructors prv.

Lemma enum_prv b s A : enum (@prv s b A) (L_ded A).

Lemma enumerable_min_prv : enumerable (prv_min []).
Lemma enumerable_intu_prv : enumerable (prv_intu []).
Lemma enumerable_class_prv : enumerable (prv_class []). *)

Section Kripke.

  Context {domain : Type}.
  Variable eta : nat -> domain.

  Structure embedding (I J : interp domain eta) :=
    {
      Hf : forall b d, @i_f _ _ I b d = @i_f _ _ J b d ;
      He : @i_e _ _ I = @i_e _ _ J ;

      HP : forall c d, @i_P _ _ I c d -> @i_P _ _ J c d ;
      HQ : @i_Q _ _ I -> @i_Q _ _ J 
    }.

  Lemma emb_refl (I : interp domain eta) :
    embedding I I.
  Proof.
    firstorder.
  Qed.
      
  Definition emb_trans (I J K : interp domain eta) :
    embedding I J -> embedding J K -> embedding I K.
  Proof.
    intros F F'. econstructor.
    - intros b d. rewrite (Hf F), (Hf F'). reflexivity. 
    - now rewrite (He F), (He F').
    - intros c d. intros. now eapply (HP F'), (HP F).
    - intros. now eapply (HQ F'), (HQ F).
  Qed.
      
  Class kmodel :=
    {
      nodes : Type ;

      reachable : nodes -> nodes -> Prop ;
      reach_refl u : reachable u u ;
      reach_tran u v w : reachable u v -> reachable v w -> reachable u w ;

      world : nodes -> interp domain eta ;

      world_f : forall u v, reachable u v -> embedding (world u) (world v)
    }.

  Variable M : kmodel.
  Implicit Type b : logic.

  Fixpoint ksat b u (rho : var -> domain) (phi : form b) : Prop :=
    match phi with
    | Pr t1 t2 => @i_P _ _ (world u) (@eval _ _ (world u) rho t1) (@eval _ _ (world u) rho t2)
    | Q => @i_Q _ _ (world u)
    | Fal => False
    | Impl phi psi => forall v, reachable u v -> ksat v rho phi -> ksat v rho psi
    | All n phi => forall v, reachable u v -> forall j : domain, ksat v (rho [[ n := j ]]) phi
    end.

  Global Arguments ksat {_} _ _ _.
  
  Notation "rho  '⊨(' u ')'  phi" := (ksat u rho phi) (at level 20).
  Notation "rho  '⊫(' u ')'  A" := (forall phi, phi el A -> rho ⊨(u) phi) (at level 20).

  Lemma eval_invar u v :
    reachable u v -> forall rho t, @eval _ _ (world u) rho t = @eval _ _ (world v)rho t.
  Proof.
    intros H rho t. induction t; cbn; try congruence.
    - now rewrite IHt, (Hf (world_f H)).
    - now rewrite (He (world_f H)).
  Qed.
  
  Lemma ksat_mon b (u : nodes) (rho : var -> domain) (phi : form b) :
    forall v (H : reachable u v), ksat u rho phi -> ksat v rho phi.
  Proof.
    revert rho. induction phi; intros rho v H; cbn.
    - intros. rewrite <- !(eval_invar H). now eapply (world_f H).
    - intros. now eapply (world_f H).
    - eauto.
    - intros H1 K H2 H3. apply H1; eauto. eapply reach_tran; eauto.
    - intros H1 K H2 k. apply (H1 K (reach_tran H H2) k).
  Qed.
  
  Lemma ksat_iff b u rho phi :
    ksat u rho phi <-> forall v (H : reachable u v), ksat v rho phi.
  Proof.
    split.
    - intros H1 v H2. eapply ksat_mon; eauto.
    - intros H. apply H. eapply reach_refl.
  Qed.

  Notation sem_imp v rho A phi :=
    ((forall psi, psi el A -> ksat v rho psi) -> ksat v rho phi).

  Lemma impl_ksat {b} u A rho (phi : form b) :
    ksat u rho (A ==> phi) <-> (forall v, reachable u v -> sem_imp v rho A phi).
  Proof.
    cbn. revert u rho. induction A; cbn; intros u rho.
    - intuition. 
      + eapply ksat_mon; eauto.
      + apply H. eapply reach_refl. tauto.
    - split; intros H v H1 H2.
      + specialize (H v H1). rewrite IHA in H.
        assert (H' : ksat v rho a) by (now apply H2; now left).
        apply (H H' v (reach_refl v)).
        intros psi H0. apply H2. now right.
      + apply IHA. intros w H3 H4.
        apply H. eapply reach_tran; eauto. intros psi [-> |H'].
        * eapply ksat_mon; eauto.
        * now apply H4.
  Qed.

  Lemma impl_ksat' {b} u A rho (phi : form b) :
    ksat u rho (A ==> phi) -> (forall v, reachable u v -> sem_imp v rho A phi).
  Proof.
    apply impl_ksat.
  Qed.

End Kripke.

Arguments ksat {_} _ _ {_} _ _ _, {_ _} _ {_} _ _ _.

Notation "rho '⊩(' u , M , eta ')' phi" := (@ksat _ eta M _ u rho phi) (at level 20).

Instance interp_kripke {domain eta} (I : interp domain eta) : kmodel  eta :=
  {| nodes := unit ; reachable u v := True |}.
Proof.
  all: try abstract tauto.
  intros. apply emb_refl.
Defined.

Lemma kripke_tarski domain eta (b : logic) (I : interp domain eta) rho phi :
  rho ⊨ phi <-> rho ⊩(tt, interp_kripke I, _) phi.
Proof.
  revert rho. induction phi; intros rho.
  - tauto.
  - tauto.
  - tauto.
  - split; intros H. cbn in *.
    + intros [] [] H'. apply IHphi2, H,  IHphi1, H'.
    + intros H'. apply IHphi2, (H tt Logic.I), IHphi1, H'.
  - split; intros H; cbn in *.
    + intros [] [] i. apply IHphi, H.
    + intros i. apply IHphi, (H tt Logic.I).
Qed.

Definition kvalid b (phi : form b) :=
  forall domain eta (M : @kmodel domain eta) u rho, rho ⊩(u,M,eta) phi.

Definition ksatis b (phi : form b) :=
  exists domain eta (M : @kmodel domain eta) u rho, ksat eta M u rho phi.

Lemma kvalid_valid b (phi : form b) :
  kvalid phi -> valid phi.
Proof.
  intros H domain I eta rho. eapply kripke_tarski, H.
Qed.

Lemma ksatis_satis b (phi : form b) :
  satis phi -> ksatis phi.
Proof.
  intros (domain & eta & I & rho & ?). eapply kripke_tarski in H.
  now exists domain, eta, (interp_kripke I), tt,  rho.
Qed.

Hint Resolve reach_refl.

Definition kcast domain (eta eta' : nat -> domain) (M : kmodel eta) : kmodel eta'.
Proof.
  unshelve econstructor.
  - exact (@nodes _ _ M).
  - exact (@reachable _ _ M).
  - intros. eapply cast. eapply (@world _ _ M). exact X.
  - eauto.
  - destruct M; eauto.
  - destruct M. abstract (
    intros; cbn; destruct (world_f0 u v H), (world0 u), (world0 v); cbn; econstructor; eauto).
Defined.

Notation "! M" := (kcast _ M) (at level 10).

Lemma ksat_ext_p dom b (phi : form b) rho rho' eta eta' (M : @kmodel dom eta ) u :
  (forall v, rho v = rho' v) ->
  (forall p, p el consts phi -> eta p = eta' p) ->
  rho ⊩(u,M,eta) phi <->
  rho' ⊩(u, !M, eta') phi.
Proof.
  intros. revert u rho rho' H; induction phi; cbn in *; intros.
  - destruct (world u). erewrite eval_ext_p with (eta' := eta').
    erewrite eval_ext_p with (eta := eta).
    cbn. reflexivity. all: cbn in *; firstorder.
  - destruct (world u); firstorder.
  - firstorder.
  - split; intros.
    + eapply IHphi2. 3: eapply H1. all: eauto.
      eapply IHphi1; try eassumption; eauto.
    + eapply IHphi2. 3: eapply H1. all: eauto.
      eapply IHphi1; try eassumption; eauto.    
  - firstorder; eapply IHphi. 6:eapply H1. 3:eapply H1. all:firstorder. all:decs.
Qed.
  
Lemma ksat_ext dom b (phi : form b) rho rho' eta (M : @kmodel dom eta ) u :
  rho ⊩(u,M,eta) phi -> (forall v, rho v = rho' v) ->  rho' ⊩(u,M,eta) phi.
Proof.
  intros H1 H2. erewrite ksat_ext_p in *; eauto.
Qed.

Lemma subst_ksat dom b eta rho (M : @kmodel dom eta ) u (phi : form b) x t :
  vars_t t = [] ->
  rho ⊩(u,M,eta) (subst x t phi) <-> rho[[x:=eval (I:=world u) rho t]] ⊩(u,M,eta) phi.
Proof.
  intros Hy. revert u rho.
  induction phi; intros u rho; cbn in *; try rewrite fresh_app in *.
  - now rewrite !subst_eval.
  - reflexivity.
  - reflexivity.
  - split; intros H w H1 H2.
    + erewrite (eval_invar H1). apply IHphi2; eauto.
      apply H, IHphi1; eauto. erewrite <- (eval_invar H1). eassumption.
    + apply IHphi2; eauto. rewrite <- (eval_invar H1).
      apply H. eassumption. rewrite (eval_invar H1). apply IHphi1; eauto.
  - cbn. split.
    + intros H v H1 j. destruct Dec as [->|H'].
      * specialize (H v H1 j). apply (ksat_ext H). intros z. decs.
      * specialize (H v H1 j). apply IHphi in H; eauto.
        rewrite eval_empty with (rho':=rho) in H; trivial.
        apply (ksat_ext H). intros. decs. now rewrite (eval_invar H1).
    + intros H v H1 j. destruct Dec as [->|H'].
      * specialize (H v H1 j). apply (ksat_ext H). intros z. decs.
      * specialize (H v H1 j). apply IHphi; eauto.
        rewrite eval_empty with (rho':=rho); trivial.
        apply (ksat_ext H). intros. decs. now rewrite (eval_invar H1).
Qed.

Lemma substconst_ksat b dom eta rho (phi : form b) x a d (M : @kmodel dom eta) u :
  fresh a (consts phi) ->
  rho ⊩(u, kcast (eta [[a := d]]) M, _) (subst x (P a) phi) <-> 
  rho [[ x := d ]] ⊩(u,M,eta) phi.
Proof.
  intros H. rewrite subst_ksat; trivial.
  symmetry. eapply ksat_ext_p; intros n; repeat decs.
Qed.

Lemma ksoundness' {b} A (phi : form b) :
  A ⊢I phi -> kvalid (A ==> phi).
Proof.
  remember intu as s.
  induction 1; intros domain eta M u rho; eapply impl_ksat; intros; subst.
  - eauto.
  - intros ? ? ?. apply (impl_ksat' (IHprv eq_refl domain eta M u rho) ). eauto using reach_tran.
    intros ? [-> | ]; eauto. eapply ksat_mon. eauto using reach_tran. eauto.
  - pose proof (impl_ksat' (IHprv1 eq_refl domain eta M u rho)). specialize (H3 v H1).  cbn in H3.
    eapply H3; eauto. eapply (impl_ksat' (IHprv2 eq_refl domain eta M u rho)); eauto.
  - intros w H3 d. specialize (IHprv eq_refl domain _ (kcast (eta [[y := d]]) M) w rho). rewrite impl_ksat in IHprv.
    specialize (IHprv w (reach_refl _)).
    rewrite <- substconst_ksat. apply IHprv. 2: firstorder.
    intros. specialize (H2 _ H4). eapply ksat_iff in H2; eauto.
    rewrite <- ksat_ext_p; eauto. intros. decs. destruct H; firstorder. 
    eapply in_app_iff. right. eapply in_flat_map. eauto.
  - eapply subst_ksat. rewrite H; eauto. pose proof (impl_ksat' (IHprv eq_refl domain eta M u rho)). cbn in H3.
    specialize (H3 v H1 H2 v (reach_refl _)). eapply H3.
  - specialize (IHprv eq_refl domain eta M v rho).
    eapply impl_ksat in IHprv as []; eauto.
  - inv Heqs. 
Qed.

Theorem ksoundness {b} (phi : form b) :
  [] ⊢I phi -> valid phi.
Proof.
  apply soundness'.
Qed.
