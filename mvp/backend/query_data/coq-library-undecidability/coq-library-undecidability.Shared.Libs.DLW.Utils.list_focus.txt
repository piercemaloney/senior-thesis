
Require Import List.
Require Import Permutation.

Require Import focus utils_tac.
(* focus:
Require Import List.

  Ltac lrev l := 
    let rec loop aa ll :=
        match ll with
          | ?x::?ll  => loop (x::aa) ll
          | nil      => constr:(aa)
        end
    in match type of l with
         | list ?t => loop (@nil t) l
       end.

  Ltac lflat l := 
    let rec loop aa ll := 
        match ll with
          | ?ss++?rr => let bb := loop aa ss in
                        let cc := loop bb rr
                        in constr:(cc)
          |  ?x::?rr => let bb := loop ((x::nil)::aa) rr
                        in constr:(bb)
          | nil      => constr:(aa)
          | ?ss      => constr:(ss::aa)
        end 
    in  match type of l with
         | list ?t => let r1 := loop (@nil (list t)) l
                      in  lrev r1
       end.

  Ltac llin l :=
    let rec loop  aa ll :=
        match ll with 
          | (?x::nil)::?ll => let bb := loop (x::aa) ll
                              in  constr:(bb)
          | ?lx::?ll       => let bb := loop (lx++aa) ll
                              in  constr:(bb)
          | nil            => constr:(aa)
        end
    in match type of l with
         | list (list ?t) =>
         match lrev l with 
          | ?lx::?rr => let bb := loop lx rr
                        in  constr:(bb)
          | nil      => constr:(@nil t)
         end
       end.

  Ltac lcut x l := 
    let rec loop aa x ll := 
        match ll with
           | x::_      => let bb := lrev aa
                          in  constr:(bb++ll)
           | ?lz::?rr  => let bb := loop (lz::aa) x rr
                          in  constr:(bb)
        end
    in  match type of l with
          | list (list ?t) => loop (@nil (list t)) x l
        end.

  Ltac lmerge l := 
    match l with
      | ?aa++?ll => let bb := llin aa in
                    let cc := llin ll 
                    in constr:(bb++cc)
    end.

  Ltac focus_lst z r0 := 
    let r1 := lflat  r0  in
    let r2 := lcut z r1  in
    let r3 := lmerge r2 
    in  constr:(r3).

  Ltac focus_lst_2 z r0 :=
    let r1 := focus_lst z r0 in
    let r2 := match r1 with 
                | ?l++?x::?r => 
                let r3 := focus_lst z r in 
                match r3 with
                  | ?m++?y::?n => constr:((l++x::m)++y::n)
                end
              end
    in constr:(r2).    

  Ltac focus_lst_3 z r0 :=
    let r1 := focus_lst_2 z r0 in
    let r2 := match r1 with 
                | ?l++?x::?r => 
                let r3 := focus_lst z r in 
                match r3 with
                  | ?m++?y::?n => constr:((l++x::m)++y::n)
                end
              end
    in constr:(r2).    
    
  Ltac focus_elt z l := focus_lst (z::nil) l.

Section test.

  Variable X : Type.

  Variable x y z : list X.
  Variable a b c : X.

  Goal True.

End test. *)
(* utils_tac:
Require Import Arith List Wellfounded.

Set Implicit Arguments.

Definition eqdec X := forall x y : X, { x = y } + { x <> y }.

Definition swap {X Y} (c : X * Y) := let (x,y) := c in (y,x).

Theorem measure_rect X (m : X -> nat) (P : X -> Type) :
      (forall x, (forall y, m y < m x -> P y) -> P x) -> forall x, P x.

Tactic Notation "induction" "on" hyp(x) "as" ident(IH) "with" "measure" uconstr(f) :=
  pattern x; revert x; apply measure_rect with (m := fun x => f); intros x IH.

Tactic Notation "eq" "goal" hyp(H) := 
  match goal with 
    |- ?b => match type of H with ?t => replace b with t; auto end 
  end.

Ltac eqgoal := let H := fresh in intro H; eq goal H; clear H.

Tactic Notation "spec" "in" hyp(H) :=
  let Q := fresh 
  in match goal with G: ?h -> _ |- _ => 
       match G with 
         | H => assert (h) as Q; [ | specialize (H Q); clear Q ] 
       end 
     end.

Ltac solve_list_eq := simpl; repeat progress (try rewrite app_ass; try rewrite <- app_nil_end; simpl; auto); auto.

Tactic Notation "solve" "list" "eq" := solve_list_eq.

Tactic Notation "solve_list_eq" "in" hyp(H) := generalize H; clear H; solve_list_eq; intro H.

Tactic Notation "solve" "list" "eq" "in" hyp(H) := 
   let Q := fresh in 
   match goal with 
     |- ?t => set (Q := t); generalize H; clear H; solve_list_eq; intro H; unfold Q; clear Q
   end.

Ltac msplit n := 
  match n with 
    | 0    => idtac 
    | S ?n => split; [ | msplit n ]
   end.

Tactic Notation "define" ident(f) "of" hyp(n) hyp(m) "as" uconstr(t)  :=
  match type of n with ?N =>  
    match type of m with ?M  => pose (f (n:N) (m:M) := t) end end.

Tactic Notation "induction" "on" hyp(x) hyp(y) "as" ident(IH) "with" "measure" uconstr(f) :=
  generalize I; intro IH;
  let mes := fresh "measure" in let rel := fresh "relation" in let loop := fresh "loop" in
  let u := fresh "u" in let u' := fresh x in let Hu := fresh "Hu" in 
  let v := fresh "v" in let v' := fresh y in let Hv := fresh "Hv" 
  in clear IH; 
     define mes of x y as (f : nat);
     set (rel u v := mes (fst u) (snd u) < mes (fst v) (snd v)); unfold fst, snd in rel;
     pattern x, y; match goal with
       |- ?T _ _ => 
       refine ((fix loop u v (Hu : Acc rel (u,v)) { struct Hu } : T u v := _) x y _);
       [ assert (forall u' v', rel (u',v') (u,v) -> T u' v') as IH;
         [ intros u' v' Hv; apply (loop u' v'), (Acc_inv Hu), Hv 
         | unfold rel, mes in *; clear mes rel Hu loop x y; rename u into x; rename v into y ]
       | unfold rel; apply wf_inverse_image, lt_wf ]
     end.

Section forall_equiv.

  Variable (X : Type) (A P Q : X -> Prop) (HPQ : forall n, A n -> P n <-> Q n).

  Theorem forall_bound_equiv : (forall n, A n -> P n) <-> (forall n, A n -> Q n).

End forall_equiv.

Section exists_equiv.

  Variable (X : Type) (P Q : X -> Prop) (HPQ : forall n, P n <-> Q n).

  Theorem exists_equiv : (exists n, P n) <-> (exists n, Q n).

End exists_equiv. *)

Ltac focus_g x ll :=
  let rr := focus_lst x ll
  in  cutrewrite ( ll = rr );
      [ idtac | solve_list_eq ].

Ltac focus_g_2 x ll :=
  let rr := focus_lst_2 x ll
  in  cutrewrite ( ll = rr );
      [ idtac | solve_list_eq ].

Ltac focus_g_3 x ll :=
  let rr := focus_lst_3 x ll
  in  cutrewrite ( ll = rr );
      [ idtac | solve_list_eq ].

Ltac focus_h H x ll := 
  let rr := focus_lst x ll
  in  cutrewrite ( ll = rr ) in H;
      [ idtac | solve_list_eq ].

Ltac focus_h_2 H x ll := 
  let rr := focus_lst_2 x ll
  in  cutrewrite ( ll = rr ) in H;
      [ idtac | solve_list_eq ].

Ltac focus_h_3 H x ll := 
  let rr := focus_lst_3 x ll
  in  cutrewrite ( ll = rr ) in H;
      [ idtac | solve_list_eq ].

Ltac focus_goal x ll :=
  match type of x with
    | list _ => focus_g x ll
    | _      => focus_g (x::nil) ll
  end.

Ltac focus_goal_2 x ll :=
  match type of x with
    | list _ => focus_g_2 x ll
    | _      => focus_g_2 (x::nil) ll
  end.

Ltac focus_goal_3 x ll :=
  match type of x with
    | list _ => focus_g_3 x ll
    | _      => focus_g_3 (x::nil) ll
  end.

Ltac focus_hyp H x ll :=
  match type of x with
    | list _ => focus_h H x ll
    | _      => focus_h H (x::nil) ll 
  end.

Ltac focus_hyp_2 H x ll :=
  match type of x with
    | list _ => focus_h_2 H x ll
    | _      => focus_h_2 H (x::nil) ll 
  end.

Ltac focus_hyp_3 H x ll :=
  match type of x with
    | list _ => focus_h_3 H x ll
    | _      => focus_h_3 H (x::nil) ll 
  end.

Ltac chg_goal x :=
  match goal with
    | |- context[?hh] => match type of hh with list _ => focus_goal x hh end
  end.

Ltac chg_goal_2 x :=
  match goal with
    | |- context[?hh] => match type of hh with list _ => focus_goal_2 x hh end
  end.

Ltac chg_goal_3 x :=
  match goal with
    | |- context[?hh] => match type of hh with list _ => focus_goal_3 x hh end
  end.

Ltac chg_hyp H x :=
  let gg := fresh 
  in match goal with 
       |- ?G => set (gg := G)
     end;
     generalize H;
     match goal with 
       | |- context[?hh] => intros _; 
                            match type of hh with 
                              | list _ => focus_hyp H x hh 
                            end
     end; 
     unfold gg; 
     clear gg.

Ltac chg_hyp_2 H x :=
  let gg := fresh 
  in match goal with 
       |- ?G => set (gg := G)
     end;
     generalize H;
     match goal with 
       | |- context[?hh] => intros _; 
                            match type of hh with 
                              | list _ => focus_hyp_2 H x hh 
                            end
     end; 
     unfold gg; 
     clear gg.

Ltac chg_hyp_3 H x :=
  let gg := fresh 
  in match goal with 
       |- ?G => set (gg := G)
     end;
     generalize H;
     match goal with 
       | |- context[?hh] => intros _; 
                            match type of hh with 
                              | list _ => focus_hyp_3 H x hh 
                            end
     end; 
     unfold gg; 
     clear gg.

Tactic Notation "focus" constr(X) := chg_goal X.
Tactic Notation "focus" constr(X) "in" hyp(H) := chg_hyp H X. 

Tactic Notation "focus" constr(X) "at" "2" := chg_goal_2 X.
Tactic Notation "focus" constr(X) "in" hyp(H) "at" "2" := chg_hyp_2 H X. 

Tactic Notation "focus" constr(X) "at" "3" := chg_goal_3 X.
Tactic Notation "focus" constr(X) "in" hyp(H) "at" "3" := chg_hyp_3 H X. 
