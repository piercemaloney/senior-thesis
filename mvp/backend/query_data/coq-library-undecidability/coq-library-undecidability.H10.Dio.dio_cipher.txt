

Require Import Arith Nat Omega List Bool Setoid.

Require Import utils_tac gcd prime binomial sums bool_nat luca.
(* utils_tac:
Require Import Arith List Wellfounded.

Set Implicit Arguments.

Definition eqdec X := forall x y : X, { x = y } + { x <> y }.

Definition swap {X Y} (c : X * Y) := let (x,y) := c in (y,x).

Theorem measure_rect X (m : X -> nat) (P : X -> Type) :
      (forall x, (forall y, m y < m x -> P y) -> P x) -> forall x, P x.

Tactic Notation "induction" "on" hyp(x) "as" ident(IH) "with" "measure" uconstr(f) :=
  pattern x; revert x; apply measure_rect with (m := fun x => f); intros x IH.

Tactic Notation "eq" "goal" hyp(H) := 
  match goal with 
    |- ?b => match type of H with ?t => replace b with t; auto end 
  end.

Ltac eqgoal := let H := fresh in intro H; eq goal H; clear H.

Tactic Notation "spec" "in" hyp(H) :=
  let Q := fresh 
  in match goal with G: ?h -> _ |- _ => 
       match G with 
         | H => assert (h) as Q; [ | specialize (H Q); clear Q ] 
       end 
     end.

Ltac solve_list_eq := simpl; repeat progress (try rewrite app_ass; try rewrite <- app_nil_end; simpl; auto); auto.

Tactic Notation "solve" "list" "eq" := solve_list_eq.

Tactic Notation "solve_list_eq" "in" hyp(H) := generalize H; clear H; solve_list_eq; intro H.

Tactic Notation "solve" "list" "eq" "in" hyp(H) := 
   let Q := fresh in 
   match goal with 
     |- ?t => set (Q := t); generalize H; clear H; solve_list_eq; intro H; unfold Q; clear Q
   end.

Ltac msplit n := 
  match n with 
    | 0    => idtac 
    | S ?n => split; [ | msplit n ]
   end.

Tactic Notation "define" ident(f) "of" hyp(n) hyp(m) "as" uconstr(t)  :=
  match type of n with ?N =>  
    match type of m with ?M  => pose (f (n:N) (m:M) := t) end end.

Tactic Notation "induction" "on" hyp(x) hyp(y) "as" ident(IH) "with" "measure" uconstr(f) :=
  generalize I; intro IH;
  let mes := fresh "measure" in let rel := fresh "relation" in let loop := fresh "loop" in
  let u := fresh "u" in let u' := fresh x in let Hu := fresh "Hu" in 
  let v := fresh "v" in let v' := fresh y in let Hv := fresh "Hv" 
  in clear IH; 
     define mes of x y as (f : nat);
     set (rel u v := mes (fst u) (snd u) < mes (fst v) (snd v)); unfold fst, snd in rel;
     pattern x, y; match goal with
       |- ?T _ _ => 
       refine ((fix loop u v (Hu : Acc rel (u,v)) { struct Hu } : T u v := _) x y _);
       [ assert (forall u' v', rel (u',v') (u,v) -> T u' v') as IH;
         [ intros u' v' Hv; apply (loop u' v'), (Acc_inv Hu), Hv 
         | unfold rel, mes in *; clear mes rel Hu loop x y; rename u into x; rename v into y ]
       | unfold rel; apply wf_inverse_image, lt_wf ]
     end.

Section forall_equiv.

  Variable (X : Type) (A P Q : X -> Prop) (HPQ : forall n, A n -> P n <-> Q n).

  Theorem forall_bound_equiv : (forall n, A n -> P n) <-> (forall n, A n -> Q n).

End forall_equiv.

Section exists_equiv.

  Variable (X : Type) (P Q : X -> Prop) (HPQ : forall n, P n <-> Q n).

  Theorem exists_equiv : (exists n, P n) <-> (exists n, Q n).

End exists_equiv. *)
(* gcd:
Require Import List Arith Omega Permutation.

Require Import utils_tac utils_list.

Set Implicit Arguments.

Section Euclid.

  Definition euclid n d : d <> 0 -> { q : nat & { r | n = q*d+r /\ r < d } }.

End Euclid.

Definition arem n d q j := j <= d /\ (n = 2*q*d+j \/ q <> 0 /\ n = 2*q*d-j).

Fact division_by_even n d : d <> 0 -> { q : nat & { j | arem n d q j } }.

Fact own_multiple x p : x = p*x -> x = 0 \/ p = 1.

Fact mult_is_one p q : p*q = 1 -> p = 1 /\ q = 1.

Definition divides n k := exists p, k = p*n.

Section divides.

  Infix "div" := divides (at level 70, no associativity).

  Fact divides_refl x : x div x.

  Fact divides_anti x y : x div y -> y div x -> x = y.

  Fact divides_trans x y z : x div y -> y div z -> x div z.

  Fact divides_0 p : p div 0.

  Fact divides_0_inv p : 0 div p -> p = 0.

  Fact divides_1 p : 1 div p.

  Fact divides_1_inv p : p div 1 -> p = 1.

  Fact divides_2_inv p : p div 2 -> p = 1 \/ p = 2.

  Fact divides_mult p q k : p div q -> p div k*q.

  Fact divides_mult_r p q k : p div q -> p div q*k.

  Fact divides_mult_compat a b c d : a div b -> c div d -> a*c div b*d.

  Fact divides_minus p q1 q2 : p div q1 -> p div q2 -> p div q1 - q2.

  Fact divides_plus p q1 q2 : p div q1 -> p div q2 -> p div q1+q2.

  Fact divides_plus_inv p q1 q2 : p div q1 -> p div q1+q2 -> p div q2.

  Fact divides_le p q : q <> 0 -> p div q -> p <= q.

  Fact divides_mult_inv k p q : k <> 0 -> k*p div k*q -> p div q.

  Lemma divides_fact m p : 1 < p <= m -> p div fact m.

  Lemma divides_mult_inv_l p q r : p * q div r -> p div r /\ q div r.

End divides.

Section gcd_lcm.

  Infix "div" := divides (at level 70, no associativity).

  Hint Resolve divides_0 divides_refl divides_mult divides_1.

  Definition is_gcd p q r := r div p /\ r div q /\ forall k, k div p -> k div q -> k div r.
  Definition is_lcm p q r := p div r /\ q div r /\ forall k, p div k -> q div k -> r div k.

  Fact is_gcd_sym p q r : is_gcd p q r -> is_gcd q p r.

  Fact is_gcd_0l p : is_gcd 0 p p.

  Fact is_gcd_0r p : is_gcd p 0 p.

  Fact is_gcd_1l p : is_gcd 1 p 1.

  Fact is_gcd_1r p : is_gcd p 1 1.

  Fact is_gcd_modulus p q k r : p div k -> k <= q -> is_gcd p q r -> is_gcd p (q-k) r.

  Fact is_gcd_minus p q r : p <= q -> is_gcd p q r -> is_gcd p (q-p) r.

  Hint Resolve divides_plus.

  Fact is_gcd_moduplus p q k r : p div k -> is_gcd p q r -> is_gcd p (q+k) r.

  Fact is_gcd_plus p q r : is_gcd p q r -> is_gcd p (q+p) r.

  Fact is_gcd_mult p q r n : is_gcd p (n*p+q) r <-> is_gcd p q r.

  Fact is_gcd_div p q : p div q -> is_gcd p q p.

  Fact is_gcd_refl p : is_gcd p p p.

  Fact is_gcd_fun p q r1 r2 : is_gcd p q r1 -> is_gcd p q r2 -> r1 = r2.

  Fact is_lcm_0l p : is_lcm 0 p 0.

  Fact is_lcm_0r p : is_lcm p 0 0.

  Fact is_lcm_sym p q r : is_lcm p q r -> is_lcm q p r.

  Fact is_lcm_fun p q r1 r2 : is_lcm p q r1 -> is_lcm p q r2 -> r1 = r2.

End gcd_lcm.

Section bezout.

  Infix "div" := divides (at level 70, no associativity).

  Hint Resolve is_gcd_0l is_gcd_0r is_lcm_0l is_lcm_0r divides_refl divides_mult divides_0 is_gcd_minus.

  Section bezout_rel_prime.

    Let bezout_rec p q : 0 < p < q -> is_gcd p q 1 -> exists a b, a*p+b*q = 1+p*q /\ a <= q /\ b <= p.

    Lemma bezout_nc p q : is_gcd p q 1 -> exists a b, a*p+b*q = 1+p*q.

    Hint Resolve divides_1.

    Lemma bezout_sc p q a b m : a*p+b*q = 1 + m -> p div m \/ q div m -> is_gcd p q 1.

  End bezout_rel_prime.

  Fact is_rel_prime_div p q k : is_gcd p q 1 -> p div q*k -> p div k.

  Fact is_rel_prime_div_r p q k : is_gcd p q 1 -> p div k*q -> p div k.

  Fact is_rel_prime_lcm p q : is_gcd p q 1 -> is_lcm p q (p*q).

  Hint Resolve divides_1 divides_mult_compat is_gcd_refl.

  Fact is_gcd_0 p q : is_gcd p q 0 -> p = 0 /\ q = 0.

  Fact is_gcd_rel_prime p q g : is_gcd p q g -> exists a b, p = a*g /\ q = b*g /\ is_gcd a b 1.

  Fact is_lcm_mult p q l k : is_lcm p q l -> is_lcm (k*p) (k*q) (k*l).

  Theorem is_gcd_lcm_mult p q g l : is_gcd p q g -> is_lcm p q l -> p*q = g*l.

  Theorem is_gcd_mult_lcm p q g l : g <> 0 -> is_gcd p q g -> g*l = p*q -> is_lcm p q l.

  Lemma is_lcm_minus p q g l u : p <= q -> p = u*g -> is_gcd p q g -> is_lcm p q l -> is_lcm p (q-p) (l-u*p).

  Lemma is_lcm_modulus k p q g l u : k*p <= q -> p = u*g -> is_gcd p q g -> is_lcm p q l -> is_lcm p (q-k*p) (l-k*u*p).

  Lemma is_lcm_plus p q g l u : p = u*g -> is_gcd p q g -> is_lcm p q l -> is_lcm p (q+p) (l+u*p).

  Lemma is_lcm_moduplus k p q g l u : p = u*g -> is_gcd p q g -> is_lcm p q l -> is_lcm p (q+k*p) (l+k*u*p).

  Section bezout_generalized.

    Let bezout_rec p q : 0 < p < q 
                      -> { a : nat 
                       & { b : nat 
                       & { g : nat
                       & { l : nat 
                       & { u : nat
                       & { v : nat
                         | a*p+b*q = g + l
                        /\ is_gcd p q g
                        /\ is_lcm p q l
                        /\ p = u*g
                        /\ q = v*g
                        /\ a <= v
                        /\ b <= u } } } } } }.
  
    Hint Resolve is_gcd_sym is_lcm_sym.

    Definition bezout_generalized p q : { a : nat 
                                      & { b : nat 
                                      & { g : nat
                                      & { l : nat 
                                        | a*p+b*q = g + l
                                       /\ is_gcd p q g
                                       /\ is_lcm p q l } } } }.

  End bezout_generalized.

  Section gcd_lcm.

    Let gcd_full p q : sig (is_gcd p q).

    Definition gcd p q := proj1_sig (gcd_full p q).
    Fact gcd_spec p q : is_gcd p q (gcd p q).

    Let lcm_full p q : sig (is_lcm p q).

    Definition lcm p q := proj1_sig (lcm_full p q).
    Fact lcm_spec p q : is_lcm p q (lcm p q).

  End gcd_lcm.
     
End bezout.

Require Import Extraction.
Extraction Inline measure_rect.

Check bezout_generalized.
Print Assumptions bezout_generalized.

Section division.

  Fact div_full q p : { n : nat & { r | q = n*p+r /\ (p <> 0 -> r < p) } }.

  Definition div q p := projT1 (div_full q p).
  Definition rem q p := proj1_sig (projT2 (div_full q p)).

  Fact div_rem_spec1 q p : q = div q p * p + rem q p.

  Fact div_rem_spec2 q p : p <> 0 -> rem q p < p.

  Fact rem_0 q : rem q 0 = q.

  Fact div_rem_uniq p n1 r1 n2 r2 : 
        p <> 0 -> n1*p + r1 = n2*p + r2 -> r1 < p -> r2 < p -> n1 = n2 /\ r1 = r2.

  Fact div_prop q p n r : q = n*p+r -> r < p -> div q p = n.

  Fact rem_prop q p n r : q = n*p+r -> r < p -> rem q p = r.

  Fact rem_idem q p : q < p -> rem q p = q.

  Fact is_gcd_rem p n a : is_gcd p n a <-> is_gcd p (rem n p) a.

  Fact rem_erase q n p r : q = n*p+r -> rem q p = rem r p.

  Fact divides_div q p : divides p q -> q = div q p * p.

  Fact divides_rem_eq q p : divides p q <-> rem q p = 0.

  Fact rem_of_0 p : rem 0 p = 0.

  Hint Resolve divides_0_inv.

  Fact divides_dec q p : { k | q = k*p } + { ~ divides p q }.

End division.

Section rem.

  Variable (p : nat) (Hp : p <> 0).

  Fact rem_plus_rem a b : rem (a+rem b p) p = rem (a+b) p.

  Fact rem_mult_rem a b : rem (a*rem b p) p = rem (a*b) p.

  Fact rem_diag : rem p p = 0.

  Fact rem_lt a : a < p -> rem a p = a.

  Fact rem_plus a b : rem (a+b) p = rem (rem a p + rem b p) p.

  Fact rem_scal k a : rem (k*a) p = rem (k*rem a p) p.

  Fact rem_plus_div a b : divides p b -> rem a p = rem (a+b) p.

  Fact div_eq_0 n : n < p -> div n p = 0.

  Fact div_of_0 : div 0 p = 0.

  Fact div_ge_1 n : p <= n -> 1 <= div n p.

End rem.

Fact div_by_p_lt p n : 2 <= p -> n <> 0 -> div n p < n.

Section rem_2.

  Fact rem_2_is_0_or_1 x : rem x 2 = 0 \/ rem x 2 = 1.

  Fact rem_2_mult x y : rem (x*y) 2 = 1 <-> rem x 2 = 1 /\ rem y 2 = 1.

  Fact rem_2_fix_0 : rem 0 2 = 0.

  Fact rem_2_fix_1 n : rem (2*n) 2 = 0.

  Fact rem_2_fix_2 n : rem (1+2*n) 2 = 1.

  Fact rem_2_lt n : rem n 2 < 2.

  Fact div_2_fix_0 : div 0 2 = 0.

  Fact div_2_fix_1 n : div (2*n) 2 = n.

  Fact div_2_fix_2 n : div (1+2*n) 2 = n.

  Fact euclid_2_div n : n = rem n 2 + 2*div n 2 /\ (rem n 2 = 0 \/ rem n 2 = 1).

  Fact euclid_2 n : exists q, n = 2*q \/ n = 1+2*q.

End rem_2.

Local Hint Resolve divides_mult divides_mult_r divides_refl.

Theorem CRT u v a b : u <> 0 -> v <> 0 -> is_gcd u v 1 -> exists w, rem w u = rem a u /\ rem w v = rem b v /\ 2 < w. *)
(* prime:
Require Import List Arith Omega Permutation.

Require Import utils_tac utils_list utils_nat gcd sums.

Set Implicit Arguments.

Section prime.

  Hint Resolve divides_0 divides_mult divides_refl divides_0_inv.

  Infix "<d" := divides (at level 70, no associativity).

  Definition prime p := p <> 1 /\ forall q, q <d p -> q = 1 \/ q = p.

  Fact prime_2 : prime 2.

  Fact prime_ge_2 p : prime p -> 2 <= p.

  Fact prime_gcd p q : prime p -> is_gcd p q 1 \/ p <d q.

  Fact prime_div_mult p x y : prime p -> p <d x*y -> p <d x \/ p <d y. 

  Definition prime_or_div p : 2 <= p -> { q | 2 <= q < p /\ q <d p } + { prime p }.

  Theorem prime_factor n : 2 <= n -> { p | prime p /\ p <d n }.

  Section prime_rect.

    Variables (P : nat -> Type)
              (HP0 : P 0)
              (HP1 : P 1)
              (HPp : forall p, prime p -> P p)
              (HPm : forall x y, P x -> P y -> P (x*y)).

    Theorem prime_rect n : P n.

  End prime_rect.

  Corollary no_common_prime_is_coprime x y : x <> 0 -> (forall p, prime p -> p <d x -> p <d y -> False) -> is_gcd x y 1.

  Fact is_rel_prime_mult p q l : is_gcd p q 1 -> is_gcd p l 1 -> is_gcd p (q*l) 1.

  Fact is_rel_prime_expo p q l : is_gcd p q 1 -> is_gcd p (mscal mult 1 l q) 1.

  Notation lprod := (fold_right mult 1).

  Fact lprod_ge_1 l : Forall prime l -> 1 <= lprod l.

  Fact lprod_app l m : lprod (l++m) = lprod l * lprod m.

  Theorem prime_decomp n : n <> 0 -> { l | n = lprod l /\ Forall prime l }.

  Hint Resolve lprod_ge_1 prime_ge_2.

  Fact prime_in_decomp p l : prime p -> Forall prime l -> p <d lprod l -> In p l.

  Theorem prime_decomp_uniq l m : Forall prime l -> Forall prime m -> lprod l = lprod m -> l ~p m.

End prime.

Section base_decomp.

  Fixpoint expand p l :=
    match l with
      | nil  => 0
      | x::l => x+p*expand p l
    end.

  Notation power := (mscal mult 1).

  Fact expand_app p l m : expand p (l++m) = expand p l + power (length l) p * expand p m.

  Fact expand_0 p l : Forall (eq 0) l -> expand p l = 0.

  Section base_p.

    Variables (p : nat) (Hp : 2 <= p).

    Let base_p_full n : { l | n = expand p l }.

    Definition base_p n := proj1_sig (base_p_full n).
    Fact base_p_spec n : n = expand p (base_p n).

    Fact base_p_uniq l1 l2 : Forall2 (fun x y => x < p /\ y < p) l1 l2 -> expand p l1 = expand p l2 -> l1 = l2.

  End base_p.

End base_decomp. *)
(* binomial:
Require Import Arith Omega.

Require Import utils_tac gcd.

Set Implicit Arguments.

Section factorial.

  Fixpoint fact n := match n with 0 => 1 | S n => (S n) * fact n end.

  Fact fact_0 : fact 0 = 1.

  Fact fact_S n : fact (S n) = (S n)*fact n.

  Fact fact_gt_0 n : 0 < fact n.

End factorial.

Section binomial.

  Infix "<d" := divides (at level 70, no associativity).

  Hint Resolve divides_refl.

  Let fact_neq_0 n : fact n <> 0.

  Fixpoint binomial n p :=
    match n, p with
      | n, 0     => 1
      | 0, S _   => 0
      | S n, S p => binomial n p + binomial n (S p)
    end.

  Fact binomial_n0 n : binomial n 0 = 1.

  Fact binomial_SS n p : binomial (S n) (S p) = binomial n p + binomial n (S p).

  Fact binomial_n1 n : 1 <= n -> binomial n 1 = n.

  Fact binomial_gt n : forall p, n < p -> binomial n p = 0.

  Fact binomial_nn n : binomial n n = 1.

  Theorem binomial_thm n p : p <= n -> fact n = binomial n p * fact p * fact (n-p).

  Fact binomial_le n p : p <= n -> binomial n p = div (fact n) (fact p * fact (n-p)).

  Fact binomial_sym n p : p <= n -> binomial n p = binomial n (n-p).

  Fact binomial_spec n p : p <= n -> fact n = binomial n p * fact p * fact (n-p).

  Fact binomial_0n n : 0 < n -> binomial 0 n = 0.

  Theorem binomial_pascal n p : binomial (S n) (S p) = binomial n p + binomial n (S p).

End binomial. *)
(* sums:
Require Import List Arith Omega Eqdep_dec ZArith.

Require Import utils_tac utils_list binomial.

Set Implicit Arguments.

Record monoid_theory (X : Type) (m : X -> X -> X) (u : X) := mk_monoid {
  monoid_unit_l : forall x, m u x = x;
  monoid_unit_r : forall x, m x u = x;
  monoid_assoc  : forall x y z, m x (m y z) = m (m x y) z;
}.

Fact Nat_plus_monoid : monoid_theory plus 0.

Fact Nat_mult_monoid : monoid_theory mult 1.

Fact Zplus_monoid : monoid_theory Zplus 0%Z.

Fact Zmult_monoid : monoid_theory Zmult 1%Z.

Hint Resolve Nat_plus_monoid Nat_mult_monoid
             Zplus_monoid Zmult_monoid.

Section msum.

  Variable (X : Type) (m : X -> X -> X) (u : X).

  Infix "‚äï" := m (at level 50, left associativity).

  Fixpoint msum n f := 
    match n with 
      | 0   => u
      | S n => f 0 ‚äï msum n (fun n => f (S n))
    end.

  Notation "‚àë" := msum.

  Fact msum_fold_map n f : ‚àë n f = fold_right m u (map f (list_an 0 n)).

  Fact msum_0 f : ‚àë 0 f = u.

  Fact msum_S n f : ‚àë (S n) f = f 0 ‚äï ‚àë n (fun n => f (S n)).

  Hypothesis Hmonoid : monoid_theory m u.

  Fact msum_1 f : ‚àë 1 f = f 0.

  Fact msum_plus a b f : ‚àë (a+b) f = ‚àë a f ‚äï ‚àë b (fun i => f (a+i)).

  Fact msum_plus1 n f : ‚àë (S n) f = ‚àë n f ‚äï f n.

  Fact msum_ext n f g : (forall i, i < n -> f i = g i) -> ‚àë n f = ‚àë n g.

  Fact msum_unit n : ‚àë n (fun _ => u) = u.

  Fact msum_comm a n f : (forall i, i < n -> f i ‚äï a = a ‚äï f i) -> ‚àë n f ‚äï a = a ‚äï ‚àë n f.

  Fact msum_sum n f g : (forall i j, i < j < n -> f j ‚äï g i = g i ‚äï f j) -> ‚àë n (fun i => f i ‚äï g i) = ‚àë n f ‚äï ‚àë n g.

  Fact msum_of_unit n f : (forall i, i < n -> f i = u) -> ‚àë n f = u.

  Fact msum_only_one n f i : i < n
                          -> (forall j, j < n -> i <> j -> f j = u)
                          -> ‚àë n f = f i.

  Fact msum_msum n k f :
          (forall i1 j1 i2 j2, i1 < n -> j1 < k -> i2 < n -> j2 < k -> f i1 j1 ‚äï f i2 j2 = f i2 j2 ‚äï f i1 j1)
       -> ‚àë n (fun i => ‚àë k (f i)) = ‚àë k (fun j => ‚àë n (fun i => f i j)).

  Fact msum_ends n f : (forall i, 0 < i <= n -> f i = u) -> ‚àë (n+2) f = f 0 ‚äï f (S n).

  Fact msum_first_two n f : 2 <= n -> (forall i, 2 <= i -> f i = u) -> ‚àë n f = f 0 ‚äï f 1.

  Definition mscal n x := msum n (fun _ => x).

  Fact mscal_0 x : mscal 0 x = u.

  Fact mscal_S n x : mscal (S n) x = x ‚äï mscal n x.

  Fact mscal_1 x : mscal 1 x = x.

  Fact mscal_of_unit n : mscal n u = u.

  Fact mscal_plus a b x : mscal (a+b) x = mscal a x ‚äï mscal b x.

  Fact mscal_plus1 n x : mscal (S n) x = mscal n x ‚äï x.

  Fact mscal_comm n x y : x ‚äï y = y ‚äï x -> mscal n x ‚äï y = y ‚äï mscal n x.

  Fact mscal_sum n x y : x ‚äï y = y ‚äï x -> mscal n (x ‚äï y) = mscal n x ‚äï mscal n y.

  Fact mscal_mult a b x : mscal (a*b) x = mscal a (mscal b x).

  Fact msum_mscal n k f : (forall i j, i < n -> j < n -> f i ‚äï f j = f j ‚äï f i) 
                       -> ‚àë n (fun i => mscal k (f i)) = mscal k (‚àë n f).

End msum.

Section msum_morphism.

  Variable (X Y : Type) (m1 : X -> X -> X) (u1 : X) 
                        (m2 : Y -> Y -> Y) (u2 : Y)
           (H1 : monoid_theory m1 u1)
           (H2 : monoid_theory m2 u2)
           (phi : X -> Y)
           (Hphi1 : phi u1 = u2)
           (Hphi2 : forall x y, phi (m1 x y) = m2 (phi x) (phi y)).

  Fact msum_morph n f : phi (msum m1 u1 n f) = msum m2 u2 n (fun x => phi (f x)).

  Fact mscal_morph n x : phi (mscal m1 u1 n x) = mscal m2 u2 n (phi x).

End msum_morphism.

Section binomial_Newton.

  Variable (X : Type) (sum times : X -> X -> X) (zero one : X).

  Infix "‚äï" := sum (at level 50, left associativity).
  Infix "‚äó" := times (at level 40, left associativity).
  
  Notation z := zero.
  Notation o := one.

  Notation scal := (mscal sum zero).
  Notation expo := (mscal times one).

  Hypothesis (M_sum : monoid_theory sum zero) 
             (sum_comm : forall x y, x ‚äï y = y ‚äï x)
             (sum_cancel : forall x u v, x ‚äï u = x ‚äï v -> u = v)
             (M_times : monoid_theory times one)
             (distr_l : forall x y z, x ‚äó (y‚äïz) = x‚äóy ‚äï x‚äóz)
             (distr_r : forall x y z, (y‚äïz) ‚äó x = y‚äóx ‚äï z‚äóx).

  Fact times_zero_l x : z ‚äó x = z.

  Fact times_zero_r x : x ‚äó z = z.

  Notation "‚àë" := (msum sum zero).

  Fact sum_0n_scal n k f : ‚àë n (fun i => scal k (f i)) = scal k (‚àë n f).

  Fact scal_times k x y : scal k (x‚äóy) = x‚äóscal k y.

  Fact scal_one_comm k x : scal k o ‚äó x = x ‚äó scal k o.

  Corollary scal_one k x : scal k x = scal k o ‚äó x.

  Fact sum_0n_distr_l b n f : ‚àë n (fun i => b‚äóf i) = b‚äó‚àë n f.

  Fact sum_0n_distr_r b n f : ‚àë n (fun i => f i‚äób) = ‚àë n f ‚äó b.

  Theorem binomial_Newton n a b :
        a ‚äó b = b ‚äó a
     -> expo n (a ‚äï b) = ‚àë (S n) (fun i => scal (binomial n i) (expo (n - i) a ‚äó expo i b)).

End binomial_Newton.

Section Newton_nat.

  Notation power := (mscal mult 1).
  Notation "‚àë" := (msum plus 0).

  Fact sum_fold_map n f : ‚àë n f = fold_right plus 0 (map f (list_an 0 n)).

  Fact power_0 x : power 0 x = 1.

  Fact power_S n x : power (S n) x = x * power n x.

  Fact power_1 x : power 1 x = x.

  Fact power_of_0 n : 0 < n -> power n 0 = 0.

  Fact power_of_1 n : power n 1 = 1.

  Fact power_plus p a b : power (a+b) p = power a p * power b p.

  Fact power_mult p a b : power (a*b) p = power a (power b p).
  
  Fact power_ge_1 k p : p <> 0 -> 1 <= power k p.

  Fact power2_gt_0 n : 0 < power n 2.

  Fact power_sinc k p : 2 <= p -> power k p < power (S k) p.

  Fact power_ge_n k p : 2 <= p -> k <= power k p.

  Fact power_mono_l p q x : 1 <= x -> p <= q -> power p x <= power q x.

  Definition power_mono := power_mono_l.
  
  Fact power_smono_l p q x : 2 <= x -> p < q -> power p x < power q x.

  Fact power_mono_r n p q : p <= q -> power n p <= power n q.

  Fact power_0_inv p n : power p n = 0 <-> n = 0 /\ 0 < p.

  Fact plus_cancel_l : forall a b c, a + b = a + c -> b = c.

  Let plus_cancel_l':= plus_cancel_l.

  Fact sum_0n_scal_l n k f : ‚àë n (fun i => k*f i) = k*‚àë n f.

  Fact sum_0n_scal_r n k f : ‚àë n (fun i => (f i)*k) = (‚àë n f)*k.

  Fact sum_0n_mono n f g : (forall i, i < n -> f i <= g i) -> ‚àë n f <= ‚àë n g.

  Fact sum_0n_le_one n f i : i < n -> f i <= ‚àë n f.

  Fact sum_power_lt k n f : k <> 0 -> (forall i, i < n -> f i < k) -> ‚àë n (fun i => f i * power i k) < power n k.

  Theorem Newton_nat a b n :
       power n (a + b) = ‚àë (S n) (fun i => binomial n i * power (n - i) a * power i b).

  Theorem Newton_nat_S a n :
       power n (1 + a) = ‚àë (S n) (fun i => binomial n i * power i a).

  Lemma binomial_le_power n i : binomial n i <= power n 2.

  Corollary binomial_lt_power n i : binomial n i < power (S n) 2.

End Newton_nat. *)
(* bool_nat:
Require Import Arith Nat Omega List Bool Setoid.
Require Import utils_tac utils_list utils_nat bool_list gcd sums power_decomp.

Set Implicit Arguments.

Local Notation power := (mscal mult 1).
Local Notation "‚àë" := (msum plus 0).

Local Reserved Notation "x ‚â≤ y" (at level 70, no associativity).

Inductive binary_le : nat -> nat -> Prop :=
 | in_ble_0 : forall n, 0 ‚â≤ n
 | in_ble_1 : forall n m, rem n 2 <= rem m 2 -> div n 2 ‚â≤ div m 2 -> n ‚â≤ m
where "x ‚â≤ y" := (binary_le x y).

Local Infix "‚â≤" := binary_le (at level 70, no associativity).

Fact binary_le_inv n m : n ‚â≤ m -> n = 0 \/ div n 2 ‚â≤ div m 2 /\ rem n 2 <= rem m 2.

Fact binary_le_refl x : x ‚â≤ x.

Fact binary_le_le x y : x ‚â≤ y -> x <= y.

Fact binary_le_zero_inv n : n ‚â≤ 0 -> n = 0.

Fact binary_le_zero n : 0 ‚â≤ n.

Hint Resolve binary_le_zero binary_le_refl.

Local Notation "‚üò" := false.
Local Notation "‚üô" := true.

Definition bool2nat x := 
  match x with 
    | ‚üò => 0 
    | ‚üô => 1 
  end.
 
Fact rem_2_bool2nat b n : rem (bool2nat b+2*n) 2 = bool2nat b.

Fact div_2_bool2nat b n : div (bool2nat b+2*n) 2 = n.

Definition nat2bool x := 
  match x with 
    | 0 => ‚üò 
    | _ => ‚üô 
  end.

Fact bool2nat2bool : forall x, x < 2 -> bool2nat (nat2bool x) = x.

Fact nat2bool2nat : forall x, nat2bool (bool2nat x) = x.

Local Hint Resolve power2_gt_0.

Local Notation lb := (list bool).

Local Infix "‚™¶" := leb (at level 70, no associativity).
Local Infix "‚™Ø" := lb_mask (at level 70, no associativity).
Local Infix "‚âÇ" := lb_mask_equiv (at level 70, no associativity).
Local Infix "‚üÇ" := lb_ortho (at level 70, no associativity).
Local Infix "‚Üì" := lb_meet (at level 40, left associativity).
Local Infix "‚Üë" := lb_join (at level 41, left associativity).

Local Reserved Notation "'‚ü¶' l '‚üß'".
Local Reserved Notation "'‚ü¨' x '‚ü≠'".

  Fixpoint lb_nat (l : lb) :=
    match l with
      | nil    => 0
      | x :: l => bool2nat x + 2*‚ü¶l‚üß
    end
  where "‚ü¶ l ‚üß" := (lb_nat l).

  Fact lb_nat_fix_0 : ‚ü¶nil‚üß = 0.                      Proof. trivial. Qed.
  Fact lb_nat_fix_2 l : ‚ü¶‚üô::l‚üß = 1+2*‚ü¶l‚üß.             Proof. trivial. Qed.

  Fact lb_nat_app l m : lb_nat (l++m) = lb_nat l + (power (length l) 2)*(lb_nat m).

  Fact lb_mask_binary_le l m : l ‚™Ø m -> ‚ü¶l‚üß ‚â≤ ‚ü¶m‚üß.

  Section nat_lb_def.

    Inductive g_nlb : nat -> lb -> Prop :=
      | in_gnlb_0 : g_nlb 0 nil
      | in_gnlb_1 : forall n l, n <> 0 -> rem n 2 = 0 -> g_nlb (div n 2) l -> g_nlb n (‚üò::l)
      | in_gnlb_2 : forall n l, n <> 0 -> rem n 2 = 1 -> g_nlb (div n 2) l -> g_nlb n (‚üô::l).
   
    Fact g_nlb_fun n l1 l2 : g_nlb n l1 -> g_nlb n l2 -> l1 = l2.

    Let nat_lb_full n : { l | g_nlb n l }.

    Definition nat_lb n := proj1_sig (nat_lb_full n).
  
    Fact nat_lb_spec n : g_nlb n (nat_lb n).

  End nat_lb_def.

  Local Notation "‚ü¨ n ‚ü≠" := (nat_lb n).

  Hint Resolve nat_lb_spec.

  Fact nat_lb_fix_0 : ‚ü¨ 0‚ü≠ = nil.

  Fact nat_lb_fix_1 n : n <> 0 -> ‚ü¨ 2*n‚ü≠ = ‚üò::‚ü¨ n‚ü≠ .

  Fact nat_lb_fix_2 n : ‚ü¨1+2*n‚ü≠ = ‚üô::‚ü¨ n‚ü≠ .

  Fact nat_lb_1 : ‚ü¨ 1‚ü≠ = ‚üô::nil.

  Fact lb_nat_lb n : ‚ü¶‚ü¨ n ‚ü≠‚üß = n.

  Fact nat_lb_length x n : x < power n 2 -> length ‚ü¨ x ‚ü≠ <= n.

  Fact binary_le_lb_mask x y : x ‚â≤ y -> ‚ü¨ x ‚ü≠ ‚™Ø ‚ü¨ y ‚ü≠ . 

  Hint Resolve lb_mask_binary_le binary_le_lb_mask.

  Section lb_mask_nat.

    Let lb_mask_nat_1 l : ‚ü¨ ‚ü¶l‚üß‚ü≠  ‚™Ø  l.

    Let lb_mask_nat_2 l : l ‚™Ø  ‚ü¨ ‚ü¶l‚üß‚ü≠  .

    Fact lb_mask_nat l : ‚ü¨ ‚ü¶l‚üß‚ü≠ ‚âÇ l.

  End lb_mask_nat.

  Definition nat_lb_nat := lb_mask_nat.

  Lemma lb_mask_eq_binary_le l m : l ‚™Ø m <-> ‚ü¶l‚üß ‚â≤ ‚ü¶m‚üß.

  Lemma binary_le_eq_lb_mask x y : x ‚â≤ y <-> ‚ü¨ x‚ü≠  ‚™Ø ‚ü¨ y‚ü≠ .

  Hint Resolve lb_mask_eq_binary_le binary_le_eq_lb_mask.

  Fact binary_le_trans x y z : x ‚â≤ y -> y ‚â≤ z -> x ‚â≤ z.

  Fact lb_mask_equiv_equal l m : l ‚âÇ m <-> ‚ü¶l‚üß = ‚ü¶m‚üß.

  Fact equal_lb_mask_equiv x y : x = y <-> ‚ü¨ x‚ü≠ ‚âÇ‚ü¨ y‚ü≠.

  Definition bool_add_with_rem a b c : bool * bool :=
    match a, b, c with 
     | ‚üò, ‚üò, ‚üò => (‚üò,‚üò)
     | ‚üò, ‚üò, ‚üô => (‚üò,‚üô)
     | ‚üò, ‚üô, ‚üò => (‚üò,‚üô)
     | ‚üò, ‚üô, ‚üô => (‚üô,‚üò)
     | ‚üô, ‚üò, ‚üò => (‚üò,‚üô)
     | ‚üô, ‚üò, ‚üô => (‚üô,‚üò)
     | ‚üô, ‚üô, ‚üò => (‚üô,‚üò)
     | ‚üô, ‚üô, ‚üô => (‚üô,‚üô)
    end.

  Notation bin_add := bool_add_with_rem.
  
  Fact bin_add_eq_00x x : bin_add ‚üò ‚üò  x = (‚üò,x).

  Fact bin_add_eq_0x0 x : bin_add ‚üò x ‚üò  = (‚üò,x).

  Fixpoint lb_succ a l :=
    match l with
      | nil  => a::nil
      | x::l => let (r,z) := bin_add ‚üò a x in z::lb_succ r l
    end.

  Fact lb_succ_spec_0 l : ‚ü¶lb_succ ‚üò l‚üß = ‚ü¶l‚üß.

  Fact lb_succ_spec_1 l : ‚ü¶lb_succ ‚üô l‚üß = S ‚ü¶l‚üß.

  Fact lb_succ_spec a l : ‚ü¶lb_succ a l‚üß = bool2nat a + ‚ü¶l‚üß.

  Fact lb_succ_bot l : lb_succ ‚üò l ‚âÇ l.

  Fixpoint lb_plus a l m :=
    match l, m with
      | nil,   m   => lb_succ a m
      | l,    nil  => lb_succ a l
      | x::l, y::m => let (r,z) := bin_add a x y in z::lb_plus r l m
    end.

  Fact lb_plus_fix_0 a l : lb_plus a nil l = lb_succ a l.

  Fact lb_plus_fix_1 a l : lb_plus a l nil = lb_succ a l.

  Fact lb_plus_fix_2 a x y l m : lb_plus a (x::l) (y::m) = let (r,z) := bin_add a x y in z::lb_plus r l m.

  Fact lb_plus_spec a l m : ‚ü¶lb_plus a l m‚üß = bool2nat a + ‚ü¶l‚üß + ‚ü¶m‚üß.

  Local Infix "‚äï" := (lb_plus ‚üò ) (at level 41, left associativity). 

  Fact lb_plus_spec_0 l m : ‚ü¶l‚äïm‚üß = ‚ü¶l‚üß + ‚ü¶m‚üß.

  Fact lb_ortho_plus l m : l ‚üÇ m <-> l ‚™Ø l‚äïm.

  Fact lb_ortho_plus_join x y : x ‚üÇ y -> x‚äïy ‚âÇ x‚Üëy.

  Fact lb_ortho_plus_id a x y : a ‚üÇ x -> a ‚üÇ y -> x ‚üÇ y <-> (a‚äïx)‚Üì(a‚äïy) ‚âÇ a.

  Fact lb_minus_plus a b : a ‚™Ø b -> exists x, b ‚âÇ a‚äïx /\ a ‚™Ø  a‚äïx.

  Theorem lb_meet_dio a b c : a ‚âÇ b‚Üìc <-> exists x y, b ‚âÇ a‚äïx /\ c ‚âÇ a‚äïy /\ a ‚™Ø  a‚äïx /\ a ‚™Ø  a‚äïy /\ x ‚™Ø  x‚äïy.

  Fact lb_join_dio a b c : a ‚âÇ b‚Üëc <-> exists x, a ‚âÇ b‚äïx /\ b ‚™Ø  b‚äïx /\ x ‚™Ø c /\ c ‚™Ø a.

  Fixpoint lb_bots n :=
    match n with 
      | 0   => nil
      | S n => ‚üò :: lb_bots n
    end.
      
  Definition lb_shift n l := lb_bots n ++ l.

  Fact lb_shift_0 l : lb_shift 0 l = l.

  Fact lb_shift_S n l : lb_shift (S n) l = ‚üò :: lb_shift n l.

  Fact lb_nat_shift n l : ‚ü¶lb_shift n l‚üß = ‚ü¶l‚üß*power n 2.

  Fact lb_shift_meet n l m : lb_shift n (l‚Üìm) = (lb_shift n l)‚Üì(lb_shift n m).

  Fact lb_shift_join n l m : lb_shift n (l‚Üëm) = (lb_shift n l)‚Üë(lb_shift n m).

  Fact lb_shift_ortho n l m : length l <= n -> l ‚üÇ lb_shift n m.

  Fact lb_shift_ortho_meet n l m : length l <= n -> l ‚Üì lb_shift n m ‚âÇ nil.

  Fact nat_pow2_lb_shift n q : ‚ü¨q*power n 2‚ü≠ ‚âÇ lb_shift n ‚ü¨q‚ü≠ .

  Fact nat_euclid_pow2_lb n r q : r < power n 2 -> ‚ü¨r+q*power n 2‚ü≠ ‚âÇ ‚ü¨r‚ü≠ ‚Üëlb_shift n ‚ü¨q‚ü≠ .

  Definition nat_meet n m := ‚ü¶ ‚ü¨n‚ü≠‚Üì‚ü¨m‚ü≠ ‚üß.
  Local Infix "‚á£" := nat_meet (at level 40, left associativity).

  Fact nat_meet_comm n m : n‚á£m = m‚á£n.

  Fact nat_meet_left n m : n‚á£m ‚â≤ n.

  Fact nat_meet_right n m : n‚á£m ‚â≤ m.

  Hint Resolve nat_meet_left nat_meet_right.

  Fact binary_le_nat_meet n m : n ‚â≤ m <-> n‚á£m = n.
  
  Theorem nat_meet_dio a b c : a = b‚á£c <-> exists x y,  b = a+x
                                                     /\ c = a+y
                                                     /\ a ‚â≤ a+x
                                                     /\ a ‚â≤ a+y
                                                     /\ x ‚â≤ x+y.

  Lemma nat_meet_mult_power2 q x y : (x*power q 2) ‚á£ (y*power q 2) 
                                    = (x‚á£y)*power q 2.

  Lemma nat_meet_euclid_power_2 q r1 d1 r2 d2 : 
           r1 < power q 2 
        -> r2 < power q 2 
        -> (r1+d1*power q 2) ‚á£ (r2+d2*power q 2) 
         = (r1‚á£r2) + (d1‚á£d2)*power q 2.

  Lemma nat_meet_euclid_2 r1 d1 r2 d2 : 
           r1 < 2 
        -> r2 < 2 
        -> (r1+2*d1) ‚á£ (r2+2*d2) 
         = (r1‚á£r2) + 2*(d1‚á£d2).
  
  Fact nat_meet_0n n : 0‚á£n = 0.

  Fact nat_meet_n0 n : n‚á£0 = 0.

  Fact nat_meet_idem n : n‚á£n = n.

  Hint Resolve nat_meet_0n nat_meet_n0 nat_meet_idem.

  Fact nat_meet_assoc n m k : n‚á£(m‚á£k) = n‚á£m‚á£k.

  Section nat_meet_power2_neq.

    Let nat_meet_power2_lt x y : x < y -> (power x 2) ‚á£ (power y 2) = 0. 

    Fact nat_meet_power2_neq x y : x <> y -> (power x 2) ‚á£ (power y 2) = 0. 

  End nat_meet_power2_neq.

  Fact nat_meet_12n n : 1‚á£(2*n) = 0.

  Fact nat_meet_12 : 1‚á£2 = 0.

  Fact power_2_minus_1 n : power (S n) 2 - 1 = 1 + 2*(power n 2 - 1).

  Fact power_2_minus_1_gt n x : x < power n 2 <-> x ‚â≤ power n 2 - 1.

  Definition nat_join n m := ‚ü¶ ‚ü¨n‚ü≠‚Üë‚ü¨m‚ü≠ ‚üß.
  Local Infix "‚á°" := nat_join (at level 50, left associativity).

  Fact nat_join_comm n m : n‚á°m = m‚á°n.

  Fact nat_join_left n m : n ‚â≤ n‚á°m.

  Fact nat_join_right n m : m ‚â≤ n‚á°m.

  Hint Resolve nat_join_left nat_join_right.

  Fact nat_join_0n n : 0‚á°n = n.

  Fact nat_join_n0 n : n‚á°0 = n.

  Fact nat_join_idem n : n‚á°n = n.

  Fact nat_join_mono a b u v : a ‚â≤ b -> u ‚â≤ v -> a‚á°u ‚â≤ b‚á°v.

  Fact nat_join_assoc n m k : n‚á°(m‚á°k) = n‚á°m‚á°k.

  Fact nat_join_meet_distr_l n m k : n‚á°(m‚á£k) = (n‚á°m)‚á£(n‚á°k).

  Fact nat_meet_join_distr_l n m k : n‚á£(m‚á°k) = (n‚á£m)‚á°(n‚á£k).
  
  Hint Resolve nat_join_0n nat_join_n0 nat_join_assoc.

  Lemma nat_join_monoid : monoid_theory nat_join 0.
 
  Hint Resolve nat_join_monoid nat_join_mono.

  Fact nat_meet_joins_distr_l m n f : m ‚á£ msum nat_join 0 n f = msum nat_join 0 n (fun i => m ‚á£ f i).

  Fact nat_join_binary_le n m k : n‚á°m ‚â≤ k <-> n ‚â≤ k /\ m ‚â≤ k.

  Fact nat_joins_binary_le_left n f m : msum nat_join 0 n f ‚â≤ m <-> forall i, i < n -> f i ‚â≤ m.

  Fact nat_joins_binary_le_right m n f : (exists i, i < n /\ m ‚â≤ f i) -> m ‚â≤ msum nat_join 0 n f.

  Fact nat_joins_binary_le n m f g :
           (forall i, i < n -> exists j, j < m /\ f i ‚â≤ g j)
        -> msum nat_join 0 n f ‚â≤ msum nat_join 0 m g.

  Fact nat_double_joins_binary_le n m f g : 
           (forall i j, j < i < n -> exists k, k < m /\ f i j ‚â≤ g k)
        -> msum nat_join 0 n (fun i => msum nat_join 0 i (f i)) ‚â≤ msum nat_join 0 m g.

  Fact binary_le_join_inv m a b : m ‚â≤ a‚á°b -> m = (m‚á£a)‚á°(m‚á£b).

  Fact binary_le_joins_inv m n f : m ‚â≤ msum nat_join 0 n f
                              -> { k : nat & { g : nat -> nat & { h | m = msum nat_join 0 k g
                                                                   /\ k <= n 
                                                                   /\ (forall i, i < k -> g i <> 0 /\ g i ‚â≤ f (h i))  
                                                                   /\ (forall i, i < k -> h i < n)
                                                                   /\ (forall i j, i < j < k -> h i < h j) } } }.

  Fact binary_le_joins_inv' m n f : m ‚â≤ msum nat_join 0 n f
                              -> { g | m = msum nat_join 0 n g /\ forall i, i < n -> g i ‚â≤ f i }.  

  Lemma nat_join_mult_power2 q x y : (x*power q 2) ‚á° (y*power q 2) 
                                    = (x‚á°y)*power q 2.

  Lemma binary_le_mult_power2_inv m x q : m ‚â≤ x * power q 2 -> m <> 0 -> { y | m = y * power q 2 /\ y <> 0 /\ y ‚â≤ x }.
 
  Lemma nat_join_euclid2 q r1 d1 r2 d2 : 
           r1 < power q 2 
        -> r2 < power q 2 
        -> (r1+d1*power q 2) ‚á° (r2+d2*power q 2) 
         = (r1‚á°r2) + (d1‚á°d2)*power q 2.

  Fact nat_lb_plus n m : ‚ü¨n+m‚ü≠ ‚âÇ ‚ü¨n‚ü≠‚äï‚ü¨m‚ü≠.

  Fact nat_ortho_plus_join n m : n‚á£m = 0 -> n+m = n‚á°m.

  Local Notation sum_powers := (fun r n f e => ‚àë n (fun i => f i * power (e i) r)).

  Fact sum_powers_bound r n f e :
                 r <> 0
              -> (forall i, i < n -> f i < r) 
              -> (forall i j, i < j -> e i < e j)
              -> sum_powers r n f e < power (e n) r.

  Fact sum_powers_euclid r n f e : (forall j, j < n -> e 1 <= e (S j))
        -> sum_powers r (S n) f e = f 0 * power (e 0) r 
                                  + sum_powers r n (fun i => f (S i)) (fun i => e (S i) - e 1) * power (e 1) r.

  Fact nat_meet_joins m n f : m‚á£msum nat_join 0 n f = msum nat_join 0 n (fun i => m‚á£f i).

  Fact nat_join_eq_0 n m : n‚á°m = 0 <-> n = 0 /\ m = 0.

  Fact nat_ortho_joins_left m n f : m‚á£msum nat_join 0 n f = 0 
                           <-> forall i, i < n -> m‚á£f i = 0.

  Fact nat_ortho_sum_join n f : (forall i j, i <> j -> i < n -> j < n -> f i ‚á£ f j = 0)
                             -> ‚àë n f = msum nat_join 0 n f.

  Fact nat_ortho_joins m n f g : msum nat_join 0 m f ‚á£ msum nat_join 0 n g = 0 
                             <-> forall i j, i < m -> j < n -> f i ‚á£ g j = 0.

  Local Notation "‚áß" := (fun r n f e => msum nat_join 0 n (fun i => f i * power (e i) r)).

  Section nat_meet_digits.

    Variable (q : nat) (Hq : 0 < q) (r : nat) (Hr : r = power q 2).
          
    Implicit Types (f g : nat -> nat).

    Let Hr' : 2 <= r.

    Fact nat_meet_powers_eq i a b : (a*power i r)‚á£(b*power i r) = (a‚á£b)*power i r.

    Fact binary_power_split i a : { u : nat & { v | a = u‚á°(v*power i r) /\ forall k, u‚á£(k*power i r) = 0 } }.
        
    Fact binary_le_power_inv i a b : a ‚â≤ b * power i r -> { a' | a = a' * power i r /\ a' ‚â≤ b }.
  
    Section nat_meet_powers_neq.

      Let nat_meet_neq_powers i j a b : i < j -> a < r -> b < r -> (a*power i r)‚á£(b*power j r) = 0.

      Fact nat_meet_powers_neq i j a b : i <> j -> a < r -> b < r -> (a*power i r)‚á£(b*power j r) = 0.
 
    End nat_meet_powers_neq.

    Fact sum_powers_ortho n f e : 
                 (forall i, i < n -> f i < r) 
              -> (forall i j, i < n -> j < n -> e i = e j -> i = j)
              -> sum_powers r n f e = ‚áß r n f e.

    Section double_sum_powers_ortho.
 
      Variable (n : nat) (f e : nat -> nat -> nat)
               (Hf : forall i j, j < i < n -> f i j < r)
               (He : forall i1 j1 i2 j2, j1 < i1 < n -> j2 < i2 < n -> e i1 j1 = e i2 j2 -> i1 = i2 /\ j1 = j2).

      Let dsmpo_1 i : i < n -> sum_powers r i (f i) (e i) = ‚áß r i (f i) (e i).

      Fact double_sum_powers_ortho : ‚àë n (fun i => sum_powers r i (f i) (e i)) = msum nat_join 0 n (fun i => ‚áß r i (f i) (e i)).

    End double_sum_powers_ortho.

    Fact sinc_injective n f : (forall i j, i < j < n -> f i < f j) -> forall i j, i < n -> j < n -> f i = f j -> i = j.

    Hint Resolve sinc_injective.

    Section binary_le_meet_sum_powers.

      Variable (n : nat) (f g e : nat -> nat)
               (Hf : forall i, i < n -> f i < r) 
               (Hg : forall i, i < n -> g i < r)
               (He : forall i j, i < j < n -> e i < e j).

      Fact meet_sum_powers : (sum_powers r n f e)‚á£(sum_powers r n g e) 
                           = sum_powers r n (fun i => f i ‚á£ g i) e.

      Fact binary_le_sum_powers : sum_powers r n f e ‚â≤ sum_powers r n g e <-> forall i, i < n -> f i ‚â≤ g i.
          
    End binary_le_meet_sum_powers.

    Fact sum_power_binary_lt p n f a : 
            0 < p <= q
         -> (forall i j, i < j < n -> f i < f j)
         -> (forall i, i < n -> a i < power p 2)  -> ‚àë n (fun i => a i * power (f i) r) 
                                                   ‚â≤ (power p 2-1) * ‚àë n (fun i => power (f i) r).

    Fact sum_powers_binary_le_inv n f e m :
                 (forall i, i < n -> f i < r) 
              -> (forall i j, i < j < n -> e i < e j)
              -> m ‚â≤ sum_powers r n f e
              -> { k : nat &
                 { g : nat -> nat & 
                 { h |  m = sum_powers r k g (fun i => e (h i)) 
                     /\ k <= n
                     /\ (forall i, i < k -> g i <> 0 /\ g i ‚â≤ f (h i))
                     /\ (forall i, i < k -> h i < n)
                     /\ (forall i j, i < j < k -> h i < h j) } } }.

    Fact binary_le_sum_powers_inv n f e m :
                 (forall i, i < n -> f i < r) 
              -> (forall i j, i < j < n -> e i < e j)
              -> m ‚â≤ sum_powers r n f e
              -> { g | m = sum_powers r n g e /\ forall i, i < n -> g i ‚â≤ f i }.

    Fact sum_power_binary_lt_inv p n f e m :
            0 < p <= q
         -> (forall i j, i < j < n -> f i < f j)
         -> (forall i j, i < j < n -> e i < e j)
         -> m ‚â≤ (power p 2-1) * ‚àë n (fun i => power (f i) r)
         -> exists a, m = ‚àë n (fun i => a i * power (f i) r) 
                   /\ forall i, i < n -> a i < power p 2.

  End nat_meet_digits. *)
(* luca:
Require Import Arith Nat Omega Lia List.
Require Import utils_tac gcd prime binomial sums Zp rel_iter.

Set Implicit Arguments.

Local Notation power := (mscal mult 1).
Local Notation expo := (mscal mult 1).

Section fact.

  Let factorial_cancel n a b : fact n * a = fact n * b -> a = b.
  
  Notation Œ† := (msum mult 1).

  Notation mprod_an := (fun a n => Œ† n (fun i => i+a)).

  Fact mprod_factorial n : fact n = mprod_an 1 n.

  Variable (p : nat) (Hp : p <> 0).

  Notation "„Äö x „Äõ" := (nat2Zp Hp x).

  Let expo_p_cancel n a b : expo n p * a = expo n p * b -> a = b.

  Fact mprod_factorial_Zp i n :„Äömprod_an (i*p+1) n„Äõ=„Äöfact n„Äõ.

  Notation œÜ := (fun n r => mprod_an (n*p+1) r).
  Notation Œ® := (fun n => Œ† n (fun i => mprod_an (i*p+1) (p-1))).

  Let phi_Zp_eq n r :„ÄöœÜ n r„Äõ=„Äöfact r„Äõ.

  Fact mprod_factorial_mult n : fact (n*p) = expo n p * fact n * Œ® n.
 
  Lemma mprod_factorial_euclid n r : fact (n*p+r) = expo n p * fact n * œÜ n r * Œ® n.

  Notation Zp := (Zp_zero Hp).
  Notation Op := (Zp_one Hp).
  Notation "‚à∏" := (Zp_opp Hp).
  Infix "‚äó" := (Zp_mult Hp) (at level 40, left associativity).
  Notation expoZp := (mscal (Zp_mult Hp) (Zp_one Hp)).

  Hint Resolve Nat_mult_monoid.

  Let Psi_Zp_eq n :„ÄöŒ® n„Äõ= expoZp n„Äöfact (p-1)„Äõ.

  Hypothesis (Hprime : prime p).

  Let phi_Zp_invertible n r : r < p -> Zp_invertible Hp „ÄöœÜ n r„Äõ.

  Let Psi_Zp_invertible n : Zp_invertible Hp „ÄöŒ® n„Äõ.

  Section binomial_without_p_not_zero.

    Variable (n N n0 k K k0 : nat) (Hn : n = N*p+n0) (Hk : k = K*p+k0) (H1 : K <= N) (H2 : k0 <= n0).

    Let Hkn : k <= n.
   
    Let Hnk : n - k = (N-K)*p+(n0-k0).
  
    Fact binomial_wo_p : œÜ K k0 * Œ® K * œÜ (N-K) (n0-k0) * Œ® (N-K) * binomial n k 
                       = binomial N K * œÜ N n0 * Œ® N.

    Hypothesis (Hn0 : n0 < p).

    Hint Resolve Zp_mult_monoid.

    Fact binomial_Zp_prod :„Äöbinomial n k„Äõ=„Äöbinomial N K„Äõ‚äó„Äöbinomial n0 k0„Äõ.
    Let H4 : S (N-1) = N.        Proof. omega. Qed.
    Let H6 : N = K+1+(N-(K+1)).  Proof. omega. Qed.

    Let Hkn : k <= n.
   
    Let Hnk : n - k = (N-(K+1))*p+(p-(k0-n0)).

    Fact binomial_with_p : fact K * fact (N-(K+1)) * œÜ K k0 * Œ® K * œÜ (N-(K+1)) (p-(k0-n0)) * Œ® (N-(K+1)) * binomial n k 
                         = p * fact N * œÜ N n0 * Œ® N.

    Fact binomial_with_p' : œÜ K k0 * Œ® K * œÜ (N-(K+1)) (p-(k0-n0)) * Œ® (N-(K+1)) * binomial n k 
                          = p * binomial N K * (N-K) * œÜ N n0 * Œ® N.
 
    Fact binomial_Zp_zero :„Äöbinomial n k„Äõ= Zp.

  End binomial_without_p_zero.

End fact.

Section lucas_lemma.

  Variables (p : nat) (Hprime : prime p).

  Let Hp : p <> 0.

  Variables (n N n0 k K k0 : nat)
            (G1 : n = N*p+n0)  (G2 : n0 < p)
            (G3 : k = K*p+k0)  (G4 : k0 < p).

  Let choice : (K <= N  /\ k0 <= n0)
            \/ (n0 < k0 /\ K < N)
            \/ ((n0 < k0 \/ N < K) /\ n < k).

  Theorem lucas_lemma : rem (binomial n k) p = rem (binomial N K * binomial n0 k0) p.

End lucas_lemma.

Check lucas_lemma.
Print Assumptions lucas_lemma. *)

Require Import cipher dio_logic dio_expo dio_binary.
(* cipher:
Require Import Arith Nat Omega List Bool Setoid.
Require Import utils_tac gcd prime binomial sums bool_nat luca.
Require Import cipher dio_logic dio_expo dio_binary.

Set Implicit Arguments.

Local Infix "‚â≤" := binary_le (at level 70, no associativity).
Local Notation power := (mscal mult 1).
Local Notation "‚àë" := (msum plus 0).
Local Infix "‚á£" := nat_meet (at level 40, left associativity).
Local Infix "‚á°" := nat_join (at level 50, left associativity).

Theorem seqs_of_ones_diophantine l q u u1 : ùîªP l -> ùîªP q -> ùîªP u -> ùîªP u1
          -> ùîªR (fun v => seqs_of_ones (l v) (q v) (u v) (u1 v)).

Hint Resolve seqs_of_ones_diophantine.

Theorem Code_diophantine l q a : ùîªP l -> ùîªP q -> ùîªP a
                              -> ùîªR (fun v => Code (l v) (q v) (a v)).

Hint Resolve Code_diophantine.

Theorem Const_diophantine l q c x : ùîªP l -> ùîªP q -> ùîªP c -> ùîªP x
                                 -> ùîªR (fun v => Const (l v) (q v) (c v) (x v)).

Hint Resolve Const_diophantine.

Theorem CodeNat_diophantine l q a : ùîªP l -> ùîªP q -> ùîªP a -> ùîªR (fun v => CodeNat (l v) (q v) (a v)).

Hint Resolve CodeNat_diophantine.

Theorem Code_plus_diophantine a b c : ùîªP a -> ùîªP b -> ùîªP c
                                   -> ùîªR (fun v => Code_plus (a v) (b v) (c v)).

Theorem Code_mult_diophantine l q a b c : ùîªP l -> ùîªP q -> ùîªP a -> ùîªP b -> ùîªP c
                                       -> ùîªR (fun v => Code_mult (l v) (q v) (a v) (b v) (c v)).

Hint Resolve Code_plus_diophantine Code_mult_diophantine. *)
(* dio_logic:
Require Import Arith Nat Omega.
Require Import gcd.

Set Implicit Arguments.

Section diophantine_expressions.

  Inductive dio_op := do_add | do_mul.

  Definition do_eval o :=
    match o with
      | do_add => plus
      | do_mul => mult
    end.

  Inductive dio_expression : Set :=
    | de_cst  : nat -> dio_expression
    | de_var  : nat -> dio_expression
    | de_comp : dio_op -> dio_expression -> dio_expression -> dio_expression.

  Definition de_add := de_comp do_add.
  Definition de_mul := de_comp do_mul.

  Fixpoint de_size e :=
    match e with
      | de_cst n => 1
      | de_var x => 1
      | de_comp _ p q => 1 + de_size p + de_size q
    end.

  Fixpoint de_size_Z e :=
    (match e with
      | de_cst n => 1
      | de_var x => 1
      | de_comp _ p q => 1 + de_size_Z p + de_size_Z q
    end)%Z.

  Fact de_size_Z_spec e : de_size_Z e = Z.of_nat (de_size e).

  Fixpoint de_eval ŒΩ e  :=
    match e with
      | de_cst n => n
      | de_var x => ŒΩ x
      | de_comp o p q => do_eval o (de_eval ŒΩ p) (de_eval ŒΩ q)
    end.

  Fact de_eval_ext e ŒΩ œâ : (forall x, ŒΩ x = œâ x) -> de_eval ŒΩ e = de_eval œâ e.

  Fixpoint de_subst œÉ e :=
    match e with
      | de_cst n => de_cst n
      | de_var x => œÉ x
      | de_comp o p q => de_comp o (de_subst œÉ p) (de_subst œÉ q)
    end.

  Fact de_eval_subst œÉ ŒΩ e : de_eval ŒΩ (de_subst œÉ e) = de_eval (fun x => de_eval ŒΩ (œÉ x)) e.

  Fact de_subst_subst œÉ1 œÉ2 e : de_subst œÉ1 (de_subst œÉ2 e) = de_subst (fun x => de_subst œÉ1 (œÉ2 x)) e.

  Definition de_ren œÅ := de_subst (fun x => de_var (œÅ x)).

  Fact de_ren_size œÅ e : de_size (de_ren œÅ e) = de_size e.

  Fact de_ren_size_Z œÅ e : de_size_Z (de_ren œÅ e) = de_size_Z e.

  Fact de_eval_ren œÅ ŒΩ e : de_eval ŒΩ (de_ren œÅ e)  = de_eval (fun x => ŒΩ (œÅ x)) e.

  Definition de_lift := de_ren S.

  Fact de_eval_lift ŒΩ e : de_eval ŒΩ (de_lift e) = de_eval (fun x => ŒΩ (S x)) e.

End diophantine_expressions.

Definition dio_expr t := { e | forall ŒΩ, de_eval ŒΩ e = t ŒΩ }.

Notation ùîªP := dio_expr.

Section dio_expr.

  Implicit Types r t : (nat -> nat) -> nat.

  Fact dio_expr_var i : ùîªP (fun v => v i).

  Fact dio_expr_cst c : ùîªP (fun _ => c).

  Fact dio_expr_plus r t : ùîªP r -> ùîªP t -> ùîªP (fun ŒΩ => r ŒΩ + t ŒΩ).
  
  Fact dio_expr_mult r t : ùîªP r -> ùîªP t -> ùîªP (fun ŒΩ => r ŒΩ * t ŒΩ).

  Fact dio_expr_ren t œÅ : ùîªP t -> ùîªP (fun ŒΩ => t (fun i => ŒΩ (œÅ i))).

  Fact dio_expr_subst t œÉ : ùîªP t -> ùîªP (fun ŒΩ => t (fun i => de_eval ŒΩ (œÉ i))).

End dio_expr.

Hint Resolve dio_expr_var dio_expr_cst dio_expr_plus dio_expr_mult dio_expr_ren.

Section diophantine_logic.

  Inductive dio_formula : Set :=
    | df_atm  : dio_expression -> dio_expression -> dio_formula   
    | df_conj : dio_formula -> dio_formula -> dio_formula 
    | df_disj : dio_formula -> dio_formula -> dio_formula
    | df_exst : dio_formula -> dio_formula.

  Fixpoint df_size f :=
    match f with
      | df_atm a b  => 1 + de_size a + de_size b
      | df_conj f g => 1 + df_size f + df_size g  
      | df_disj f g => 1 + df_size f + df_size g  
      | df_exst f   => 1 + df_size f
    end.

  Fixpoint df_size_Z f :=
    (match f with
      | df_atm a b  => 1 + de_size_Z a + de_size_Z b
      | df_conj f g => 1 + df_size_Z f + df_size_Z g  
      | df_disj f g => 1 + df_size_Z f + df_size_Z g  
      | df_exst f   => 1 + df_size_Z f
    end)%Z.

  Fact df_size_Z_spec f : df_size_Z f = Z.of_nat (df_size f).

  Definition dv_lift X ŒΩ (x : X) n :=
     match n with 
       | 0   => x 
       | S n => ŒΩ n 
     end.

  Fixpoint df_pred f ŒΩ :=
    match f with
      | df_atm a b  => de_eval ŒΩ a  = de_eval ŒΩ b
      | df_conj f g => df_pred f ŒΩ /\ df_pred g ŒΩ
      | df_disj f g => df_pred f ŒΩ \/ df_pred g ŒΩ
      | df_exst f   => exists n, df_pred f (dv_lift ŒΩ n)
    end.

  Fact df_pred_atm a b ŒΩ : df_pred (df_atm a b) ŒΩ = (de_eval ŒΩ a = de_eval ŒΩ b).
  
  Fact df_pred_conj f g ŒΩ : df_pred (df_conj f g) ŒΩ = (df_pred f ŒΩ /\ df_pred g ŒΩ).

  Fact df_pred_disj f g ŒΩ : df_pred (df_disj f g) ŒΩ = (df_pred f ŒΩ \/ df_pred g ŒΩ).

  Fact df_pred_exst f ŒΩ : df_pred (df_exst f) ŒΩ = exists n, df_pred f (dv_lift ŒΩ n).

  Fact df_pred_ext f ŒΩ œâ : (forall x, ŒΩ x = œâ x) -> df_pred f ŒΩ <-> df_pred f œâ.

  Definition der_lift œÅ x := match x with 0 => 0 | S x => S (œÅ x) end.

  Fixpoint df_ren œÅ f :=
    match f with
      | df_atm a b  => let œÉ := fun x => de_var (œÅ x) in df_atm (de_subst œÉ a) (de_subst œÉ b)
      | df_conj f g => df_conj (df_ren œÅ f) (df_ren œÅ g)
      | df_disj f g => df_disj (df_ren œÅ f) (df_ren œÅ g)
      | df_exst f   => df_exst (df_ren (der_lift œÅ) f)
    end.

  Fact df_ren_size œÅ f : df_size (df_ren œÅ f) = df_size f.

  Fact df_ren_size_Z œÅ f : df_size_Z (df_ren œÅ f) = df_size_Z f.

  Fact df_pred_ren f ŒΩ œÅ : df_pred (df_ren œÅ f) ŒΩ <-> df_pred f (fun x => ŒΩ (œÅ x)).

  Definition des_lift œÉ x := match x with 0 => de_var 0 | S x => de_ren S (œÉ x) end. 
     
  Fixpoint df_subst œÉ f := 
    match f with
      | df_atm a b  => df_atm (de_subst œÉ a) (de_subst œÉ b)
      | df_conj f g => df_conj (df_subst œÉ f) (df_subst œÉ g)
      | df_disj f g => df_disj (df_subst œÉ f) (df_subst œÉ g)
      | df_exst f   => df_exst (df_subst (des_lift œÉ) f)
    end.

  Fact df_pred_subst f ŒΩ œÉ : df_pred (df_subst œÉ f) ŒΩ <-> df_pred f (fun x => de_eval ŒΩ (œÉ x)).

  Definition df_lift := df_ren S.

  Fact df_pred_lift f ŒΩ : df_pred (df_lift f) ŒΩ <-> df_pred f (fun x => ŒΩ (S x)).

End diophantine_logic.

Section examples.

  Variable ŒΩ : nat -> nat.

  Definition df_true := df_atm (de_cst 0) (de_cst 0).
  Definition df_false := df_atm (de_cst 0) (de_cst 1).

  Fact df_true_spec : df_pred df_true ŒΩ <-> True.

  Fact df_false_spec : df_pred df_false ŒΩ <-> False.

  Notation "'‚ü¶' x '‚üß'" := (de_eval ŒΩ x).

  Definition df_le x y := df_exst (df_atm (de_add (de_var 0) (de_lift x)) (de_lift y)).

  Fact df_le_spec x y : df_pred (df_le x y) ŒΩ <-> ‚ü¶x‚üß <= ‚ü¶y‚üß.

  Definition df_lt x y := df_exst (df_atm (de_add (de_cst 1) (de_add (de_var 0) (de_lift x))) (de_lift y)).

  Fact df_lt_spec x y : df_pred (df_lt x y) ŒΩ <-> ‚ü¶x‚üß < ‚ü¶y‚üß.

  Definition df_eq x y := df_atm x y.

  Fact df_eq_spec x y : df_pred (df_eq x y) ŒΩ <-> ‚ü¶x‚üß = ‚ü¶y‚üß.

  Definition df_neq x y := df_disj (df_lt x y) (df_lt y x).

  Fact df_neq_spec x y : df_pred (df_neq x y) ŒΩ <-> ‚ü¶x‚üß <> ‚ü¶y‚üß.

  Definition df_div x y := df_exst (df_atm (de_lift y) (de_mul (de_var 0) (de_lift x))).

  Fact df_div_spec x y : df_pred (df_div x y) ŒΩ <-> divides ‚ü¶x‚üß ‚ü¶y‚üß.

End examples.

Definition dio_rel R := { f | forall ŒΩ, df_pred f ŒΩ <-> R ŒΩ }.
Notation ùîªR := dio_rel.

Section dio_rel.

  Implicit Types R S : (nat -> nat) -> Prop.

  Fact dio_rel_True : ùîªR (fun _ => True).

  Fact dio_rel_False : ùîªR (fun _ => False).

  Fact dio_rel_eq r t : ùîªP r -> ùîªP t -> ùîªR (fun ŒΩ => r ŒΩ = t ŒΩ).

  Fact dio_rel_le r t : ùîªP r -> ùîªP t -> ùîªR (fun ŒΩ => r ŒΩ <= t ŒΩ).

  Fact dio_rel_lt r t : ùîªP r -> ùîªP t -> ùîªR (fun ŒΩ => r ŒΩ < t ŒΩ).

  Fact dio_rel_neq r t : ùîªP r -> ùîªP t -> ùîªR (fun ŒΩ => r ŒΩ <> t ŒΩ).

  Fact dio_rel_div r t : ùîªP r -> ùîªP t -> ùîªR (fun ŒΩ => divides (r ŒΩ) (t ŒΩ)).

  Fact dio_rel_conj R S : ùîªR R -> ùîªR S -> ùîªR (fun ŒΩ => R ŒΩ /\ S ŒΩ).

  Fact dio_rel_disj R S : ùîªR R -> ùîªR S -> ùîªR (fun ŒΩ => R ŒΩ \/ S ŒΩ).

  Fact dio_rel_exst (K : nat -> (nat -> nat) -> Prop) : 
                   ùîªR (fun v => K (v 0) (fun n => v (S n))) 
      -> ùîªR (fun ŒΩ => exists x, K x ŒΩ).

  Lemma dio_rel_equiv R S : (forall ŒΩ, S ŒΩ <-> R ŒΩ) -> ùîªR R -> ùîªR S.

  Lemma dio_rel_ren R f : ùîªR R -> ùîªR (fun v => R (fun n => v (f n))).

  Lemma dio_rel_subst R f : ùîªR R -> ùîªR (fun v => R (fun n => de_eval v (f n))).

End dio_rel.

Hint Resolve dio_rel_True dio_rel_False dio_rel_eq dio_rel_neq 
             dio_rel_le dio_rel_lt dio_rel_div 
             dio_rel_conj 
             dio_rel_disj 
             dio_rel_exst.

Ltac dio_rel_auto := repeat ((apply dio_rel_exst || apply dio_rel_conj || apply dio_rel_disj || apply dio_rel_eq); auto).

Section more_examples.

  Fact ndivides_eq x y : ~ (divides x y) <-> x = 0 /\ y <> 0 \/ exists a b, y = a*x+b /\ 0 < b < x.
  
  Lemma dio_rel_ndivides x y : ùîªP x -> ùîªP y -> ùîªR (fun ŒΩ => ~ divides (x ŒΩ) (y ŒΩ)).

  Hint Resolve dio_rel_ndivides.

  Fact rem_equiv p x r : r = rem x p <-> (p = 0 /\ x = r)
                                      \/ (p <> 0 /\ r < p /\ exists n, x = n*p + r).
 
  Lemma dio_rel_remainder p x r : ùîªP p -> ùîªP x -> ùîªP r  
                               -> ùîªR (fun ŒΩ => r ŒΩ = rem (x ŒΩ) (p ŒΩ)).

  Hint Resolve dio_rel_remainder.

  Fact congr_equiv x y p : rem x p = rem y p <-> (exists r, r = rem x p /\ r = rem y p).

  Lemma dio_rel_congruence x y p : ùîªP x -> ùîªP y -> ùîªP p  
                                -> ùîªR (fun ŒΩ => rem (x ŒΩ) (p ŒΩ) = rem (y ŒΩ) (p ŒΩ)).

  Hint Resolve dio_rel_congruence.

  Fact not_divides_eq p x : ~ divides p x <-> exists r, r = rem x p /\ r <> 0.

  Lemma dio_rel_not_divides x p : ùîªP x -> ùîªP p -> ùîªR (fun ŒΩ => ~ divides (x ŒΩ) (p ŒΩ)).

End more_examples.

Hint Resolve dio_rel_congruence dio_rel_not_divides.

Section dio_rel_compose.

  Variable (f : (nat -> nat) -> nat) (R : nat -> (nat -> nat) -> Prop).
  Hypothesis (Hf : ùîªR (fun ŒΩ => ŒΩ 0 = f (fun x => ŒΩ (S x)))) 
             (HR : ùîªR (fun ŒΩ => R (ŒΩ 0) (fun x => ŒΩ (S x)))).

  Lemma dio_rel_compose : ùîªR (fun ŒΩ => R (f ŒΩ) ŒΩ).

End dio_rel_compose.

Section multiple_exists.

  Fixpoint df_mexists n f :=
    match n with 
      | 0   => f
      | S n => df_mexists n (df_exst f)
    end.

  Fact df_mexists_size n f : df_size (df_mexists n f) = n + df_size f.

  Fact df_mexists_size_Z n f : df_size_Z (df_mexists n f) = (Z.of_nat n + df_size_Z f)%Z.

  Lemma df_mexists_spec n f ŒΩ : 
           df_pred (df_mexists n f) ŒΩ 
       <-> exists œÄ, df_pred f (fun i => if le_lt_dec n i then ŒΩ (i-n) else œÄ i).

End multiple_exists. *)
(* dio_expo:
Require Import Arith Nat Omega List.
Require Import utils_tac sums rel_iter binomial. 
Require Import alpha expo_diophantine dio_logic.

Set Implicit Arguments.

Local Notation power := (mscal mult 1).
Local Notation expo := (mscal mult 1).

Theorem dio_rel_alpha a b c : ùîªP a -> ùîªP b -> ùîªP c
                           -> ùîªR (fun ŒΩ => 3 < b ŒΩ /\ a ŒΩ = alpha_nat (b ŒΩ) (c ŒΩ)).

Hint Resolve dio_rel_alpha.

Fact dio_rel_alpha_size : df_size (proj1_sig (dio_rel_alpha (dio_expr_var 0) (dio_expr_var 1) (dio_expr_var 2))) = 490.

Theorem dio_rel_expo p q r : ùîªP p -> ùîªP q -> ùîªP r -> ùîªR (fun ŒΩ => p ŒΩ = expo (r ŒΩ) (q ŒΩ)).

Hint Resolve dio_rel_expo.
 
Check dio_rel_expo.
Print Assumptions dio_rel_expo.

Fact dio_rel_expo_size : df_size (proj1_sig (dio_rel_expo (dio_expr_var 0) (dio_expr_var 1) (dio_expr_var 2))) = 1689.

Section df_digit.

  Let is_digit_eq c q i y : is_digit c q i y 
                        <-> y < q
                        /\ exists a b p, c = (a*q+y)*p+b 
                                      /\ b < p
                                      /\ p = power i q.

  Lemma dio_rel_is_digit c q i y : ùîªP c -> ùîªP q -> ùîªP i -> ùîªP y
                                -> ùîªR (fun ŒΩ => is_digit (c ŒΩ) (q ŒΩ) (i ŒΩ) (y ŒΩ)).

End df_digit.

Hint Resolve dio_rel_is_digit.

Check dio_rel_is_digit.
Eval compute in df_size (proj1_sig (dio_rel_is_digit (dio_expr_var 0) (dio_expr_var 1) (dio_expr_var 2) (dio_expr_var 3))).

Section df_binomial.

  Notation "‚àë" := (msum plus 0).

  Let plus_cancel_l : forall a b c, a + b = a + c -> b = c.

  Hint Resolve Nat.mul_add_distr_r.

  Let is_binomial_eq b n k :  b = binomial n k
                          <-> exists q c, q = power (1+n) 2
                                       /\ c = power n (1+q) 
                                       /\ is_digit c q k b.

  Lemma dio_rel_binomial b n k : ùîªP b -> ùîªP n -> ùîªP k
                              -> ùîªR (fun ŒΩ => b ŒΩ = binomial (n ŒΩ) (k ŒΩ)).

End df_binomial.

Check dio_rel_binomial.
Eval compute in df_size (proj1_sig (dio_rel_binomial (dio_expr_var 0) (dio_expr_var 1) (dio_expr_var 2))). *)
(* dio_binary:
Require Import Arith Nat Omega List Bool Setoid.
Require Import utils_tac gcd prime binomial sums bool_nat luca.
Require Import cipher dio_logic dio_expo.

Set Implicit Arguments.

Local Infix "‚â≤" := binary_le (at level 70, no associativity).
Local Notation power := (mscal mult 1).
Local Notation "‚àë" := (msum plus 0).
Local Infix "‚á£" := nat_meet (at level 40, left associativity).
Local Infix "‚á°" := nat_join (at level 50, left associativity).

Theorem binary_le_binomial n m : n ‚â≤ m <-> rem (binomial m n) 2 = 1.

Hint Resolve dio_rel_binomial dio_rel_remainder.

Section binary_le_dio.

  Let ble_equiv x y : x ‚â≤ y <-> exists b, b = binomial y x /\ 1 = rem b 2.

  Theorem binary_le_diophantine x y : ùîªP x -> ùîªP y -> ùîªR (fun v => x v ‚â≤ y v).

End binary_le_dio.

Hint Resolve binary_le_diophantine.

Theorem nat_meet_diophantine a b c : ùîªP a -> ùîªP b -> ùîªP c
                                  -> ùîªR (fun v => a v = b v ‚á£ c v).

Hint Resolve nat_meet_diophantine. *)



Set Implicit Arguments.



Local Infix "‚â≤" := binary_le (at level 70, no associativity).

Local Notation power := (mscal mult 1).

Local Notation "‚àë" := (msum plus 0).

Local Infix "‚á£" := nat_meet (at level 40, left associativity).

Local Infix "‚á°" := nat_join (at level 50, left associativity).



Theorem seqs_of_ones_diophantine l q u u1 : ùîªP l -> ùîªP q -> ùîªP u -> ùîªP u1

          -> ùîªR (fun v => seqs_of_ones (l v) (q v) (u v) (u1 v)).

Proof.

  intros.

  apply dio_rel_equiv with (1 := fun v => seqs_of_ones_dio (l v) (q v) (u v) (u1 v)).

  dio_rel_auto.

Defined.



Hint Resolve seqs_of_ones_diophantine.



Theorem Code_diophantine l q a : ùîªP l -> ùîªP q -> ùîªP a

                              -> ùîªR (fun v => Code (l v) (q v) (a v)).

Proof.

  intros.

  apply dio_rel_equiv with (1 := fun v => Code_dio (l v) (q v) (a v)).

  dio_rel_auto.

Defined.



Hint Resolve Code_diophantine.



Theorem Const_diophantine l q c x : ùîªP l -> ùîªP q -> ùîªP c -> ùîªP x

                                 -> ùîªR (fun v => Const (l v) (q v) (c v) (x v)).

Proof.

  intros.

  apply dio_rel_equiv with (1 := fun v => Const_dio (l v) (q v) (c v) (x v)).

  dio_rel_auto.

Defined.



Hint Resolve Const_diophantine.



Theorem CodeNat_diophantine l q a : ùîªP l -> ùîªP q -> ùîªP a -> ùîªR (fun v => CodeNat (l v) (q v) (a v)).

Proof.

  intros.

  apply dio_rel_equiv with (1 := fun v => CodeNat_dio (l v) (q v) (a v)).

  dio_rel_auto.

Defined.



Hint Resolve CodeNat_diophantine.



Theorem Code_plus_diophantine a b c : ùîªP a -> ùîªP b -> ùîªP c

                                   -> ùîªR (fun v => Code_plus (a v) (b v) (c v)).

Proof. intros; unfold Code_plus; dio_rel_auto. Defined.



Theorem Code_mult_diophantine l q a b c : ùîªP l -> ùîªP q -> ùîªP a -> ùîªP b -> ùîªP c

                                       -> ùîªR (fun v => Code_mult (l v) (q v) (a v) (b v) (c v)).

Proof. intros; unfold Code_mult; dio_rel_auto. Defined.



Hint Resolve Code_plus_diophantine Code_mult_diophantine.



