
Require Import List Arith Nat Omega.
Require Import utils_list gcd prime dio_logic.
(* utils_list:
Require Import List Arith Omega Permutation.

Require Import list_focus utils_tac.

Set Implicit Arguments.

Create HintDb length_db.

Tactic Notation "rew" "length" := autorewrite with length_db.
Tactic Notation "rew" "length" "in" hyp(H) := autorewrite with length_db in H.

Infix "~p" := (@Permutation _) (at level 70).

Section length.
   
  Variable X : Type.

  Implicit Type l : list X.

  Fact length_nil : length (@nil X) = 0.

  Fact length_cons x l : length (x::l) = S (length l).

End length.

Hint Rewrite length_nil length_cons app_length map_length rev_length : length_db.

Section list_an.

  Fixpoint list_an a n :=
    match n with 
      | 0   => nil
      | S n => a::list_an (S a) n
    end.

  Fact list_an_S a n : list_an a (S n) = a::list_an (S a) n.

  Fact list_an_plus a n m : list_an a (n+m) = list_an a n ++ list_an (n+a) m.

  Fact list_an_length a n : length (list_an a n) = n.
  
  Fact list_an_spec a n m : In m (list_an a n) <-> a <= m < a+n.

  Fact map_S_list_an a n : map S (list_an a n) = list_an (S a) n.

  Fact list_an_app_inv a n l r : list_an a n = l++r -> l = list_an a (length l) /\ r = list_an (a+length l) (length r).

End list_an.

Hint Rewrite list_an_length : length_db.

Definition list_fun_inv X (l : list X) (x : X) : { f : nat -> X | l = map f (list_an 0 (length l)) }.

Fact list_upper_bound (l : list nat) : { m | forall x, In x l -> x < m }.

Section list_injective.

  Variable X : Type.
   
  Definition list_injective (ll : list X) :=  forall l a m b r, ll = l ++ a :: m ++ b :: r -> a <> b.
  
  Fact in_list_injective_0 : list_injective nil.
  
  Fact in_list_injective_1 x ll : ~ In x ll -> list_injective ll -> list_injective (x::ll).
  
  Fact list_injective_inv x ll : list_injective (x::ll) -> ~ In x ll /\ list_injective ll.
  
  Variable P : list X -> Type.
  
  Hypothesis (HP0 : P nil).
  Hypothesis (HP1 : forall x l, ~ In x l -> P l -> P (x::l)).
  
  Theorem list_injective_rect l : list_injective l -> P l.

End list_injective.

Fact list_injective_map X Y (f : X -> Y) ll :
       (forall x y, f x = f y -> x = y) -> list_injective ll -> list_injective (map f ll).

Section iter.
  
  Variable (X : Type) (f : X -> X).

  Fixpoint iter x n :=
    match n with
      | 0   => x
      | S n => iter (f x) n
    end.

  Fact iter_plus x a b : iter x (a+b) = iter (iter x a) b.

  Fact iter_swap x n : iter (f x) n = f (iter x n).

End iter.

Fixpoint list_repeat X (x : X) n :=
  match n with
    | 0   => nil
    | S n => x::list_repeat x n
  end.
  
Fact list_repeat_plus X x a b : @list_repeat X x (a+b) = list_repeat x a ++ list_repeat x b.
  
Fact list_repeat_length X x n : length (@list_repeat X x n) = n.

Fact In_list_repeat X (x y : X) n : In y (list_repeat x n) -> x = y /\ 0 < n.

Fact map_list_repeat X Y f x n : @map X Y f (list_repeat x n) = list_repeat (f x) n.

Fact map_cst_repeat X Y (y : Y) ll : map (fun _ : X => y) ll = list_repeat y (length ll).
  
Fact map_cst_snoc X Y (y : Y) ll mm : y :: map (fun _ : X => y) ll++mm = map (fun _ => y) ll ++ y::mm.

Fact map_cst_rev  X Y (y : Y) ll : map (fun _ : X => y) (rev ll) = map (fun _ => y) ll.

Fact In_perm X (x : X) l : In x l -> exists m, x::m ~p l.

Fact list_app_eq_inv X (l1 l2 r1 r2 : list X) :
       l1++r1 = l2++r2 -> { m | l1++m = l2 /\ r1 = m++r2 } 
                        + { m | l2++m = l1 /\ r2 = m++r1 }.

Fact list_app_cons_eq_inv X (l1 l2 r1 r2 : list X) x :
       l1++r1 = l2++x::r2 -> { m | l1++m = l2 /\ r1 = m++x::r2 } 
                           + { m | l2++x::m = l1 /\ r2 = m++r1 }.

Fact list_cons_app_cons_eq_inv X (l2 r1 r2 : list X) x y :
       x::r1 = l2++y::r2 -> (l2 = nil /\ x = y /\ r1 = r2) 
                          + { m | l2 = x::m /\ r1 = m++y::r2 }.
 
Fact list_app_inj X (l1 l2 r1 r2 : list X) : length l1 = length l2 -> l1++r1 = l2++r2 -> l1 = l2 /\ r1 = r2.

Fact list_split_length X (ll : list X) k : k <= length ll -> { l : _ & { r | ll = l++r /\ length l = k } }.

Fact list_pick X (ll : list X) k : k < length ll -> { x : _ & { l : _ & { r | ll = l++x::r /\ length l = k } } }.

Fact list_split_middle X l1 (x1 : X) r1 l2 x2 r2 : 
       ~ In x1 l2 -> ~ In x2 l1 -> l1++x1::r1 = l2++x2::r2 -> l1 = l2 /\ x1 = x2 /\ r1 = r2.

Section flat_map.

  Variable (X Y : Type) (f : X -> list Y).

  Fact flat_map_app l1 l2 : flat_map f (l1++l2) = flat_map f l1 ++ flat_map f l2.

  Fact flat_map_app_inv l r1 y r2 : flat_map f l = r1++y::r2 -> exists l1 m1 x m2 l2, l = l1++x::l2 /\ f x = m1++y::m2 
                                                                  /\ r1 = flat_map f l1++m1 /\ r2 = m2++flat_map f l2. 

End flat_map.

Definition prefix X (l ll : list X) := exists r, ll = l++r.
  
Infix "<p" := (@prefix _) (at level 70, no associativity).
  
Section prefix. 
   
  Variable X : Type.
  
  Implicit Types (l ll : list X).
  
  Fact in_prefix_0 ll : nil <p ll.
  
  Fact in_prefix_1 x l ll : l <p ll -> x::l <p x::ll.

  Fact prefix_length l m : l <p m -> length l <= length m.
  
  Fact prefix_app_lft l r1 r2 : r1 <p r2 -> l++r1 <p l++r2.
  
  Fact prefix_inv x y l ll : x::l <p y::ll -> x = y /\ l <p ll.
  
  Fact prefix_list_inv l r rr : l++r <p l++rr -> r <p rr.

  Fact prefix_refl l : l <p l.

  Fact prefix_trans l1 l2 l3 : l1 <p l2 -> l2 <p l3 -> l1 <p l3.

  Section prefix_rect.

    Variables (P : list X -> list X -> Type)
              (HP0 : forall ll, P nil ll)
              (HP1 : forall x l ll, l <p ll -> P l ll -> P (x::l) (x::ll)).
              
    Definition prefix_rect l ll : prefix l ll -> P l ll.
   
  End prefix_rect.

  Fact prefix_app_inv l1 l2 r1 r2 : l1++l2 <p r1++r2 -> { l1 <p r1 } + { r1 <p l1 }.
  
End prefix.

Definition prefix_spec X (l ll : list X) : l <p ll -> { r | ll = l ++ r }.

Fact prefix_app_lft_inv X (l1 l2 m : list X) : l1++l2 <p m -> { m2 | m = l1++m2 /\ l2 <p m2 }.

Section list_assoc.

  Variables (X Y : Type) (eq_X_dec : eqdec X).

  Fixpoint list_assoc x l : option Y :=
    match l with 
      | nil  => None
      | (y,a)::l => if eq_X_dec x y then Some a else list_assoc x l
    end.

  Fact list_assoc_eq x y l x' : x = x' -> list_assoc x' ((x,y)::l) = Some y.

  Fact list_assoc_neq x y l x' : x <> x' -> list_assoc x' ((x,y)::l) = list_assoc x' l.

  Fact list_assoc_In x l : 
    match list_assoc x l with 
      | None   => ~ In x (map fst l)
      | Some y => In (x,y) l
    end.

  Fact In_list_assoc x l : In x (map fst l) -> { y | list_assoc x l = Some y /\ In (x,y) l }.
  
  Fact not_In_list_assoc x l : ~ In x (map fst l) -> list_assoc x l = None.

  Fact list_assoc_app x ll mm : list_assoc x (ll++mm) 
                              = match list_assoc x ll with
                                  | None   => list_assoc x mm
                                  | Some y => Some y
                                end.

End list_assoc.

Section list_first_dec.

  Variable (X : Type) (P : X -> Prop) (Pdec : forall x, { P x } + { ~ P x }).
  
  Theorem list_choose_dec ll : { l : _ & { x : _ & { r | ll = l++x::r /\ P x /\ forall y, In y l -> ~ P y } } }
                             + { forall x, In x ll -> ~ P x }.
  
  Theorem list_first_dec a ll : P a -> In a ll -> { l : _ & { x : _ & { r | ll = l++x::r /\ P x /\ forall y, In y l -> ~ P y } } }.
  
End list_first_dec.

Section map.

  Variable (X Y : Type) (f : X -> Y).
  
  Fact map_cons_inv ll y m : map f ll = y::m -> { x : _ & { l | ll = x::l /\ f x = y /\ map f l = m } }.

  Fact map_app_inv ll m n : map f ll = m++n -> { l : _  & { r | ll = l++r /\ m = map f l /\ n = map f r } }.
  
  Fact map_middle_inv ll m y n : map f ll = m++y::n -> { l : _ & { x : _ & { r | ll = l++x::r /\ map f l = m /\ f x = y /\ map f r = n } } }.
  
End map.

Fact Forall2_mono X Y (R S : X -> Y -> Prop) :
         (forall x y, R x y -> S x y) -> forall l m, Forall2 R l m -> Forall2 S l m.

Fact Forall2_nil_inv_l X Y R m : @Forall2 X Y R nil m -> m = nil.

Fact Forall2_nil_inv_r X Y R m : @Forall2 X Y R m nil -> m = nil.

Fact Forall2_cons_inv X Y R x l y m : @Forall2 X Y R (x::l) (y::m) <-> R x y /\ Forall2 R l m.

Fact Forall2_app_inv_l X Y R l1 l2 m : 
    @Forall2 X Y R (l1++l2) m -> { m1 : _ & { m2 | Forall2 R l1 m1 /\ Forall2 R l2 m2 /\ m = m1++m2 } }.

Fact Forall2_app_inv_r X Y R l m1 m2 : 
    @Forall2 X Y R l (m1++m2) -> { l1 : _ & { l2 | Forall2 R l1 m1 /\ Forall2 R l2 m2 /\ l = l1++l2 } }.

Fact Forall2_cons_inv_l X Y R a ll mm : 
      @Forall2 X Y R (a::ll) mm 
   -> { b : _ & { mm' | R a b /\ mm = b::mm' /\ Forall2 R ll mm' } }.

Fact Forall2_cons_inv_r X Y R b ll mm : 
      @Forall2 X Y R ll (b::mm) 
   -> { a : _ & { ll' | R a b /\ ll = a::ll' /\ Forall2 R ll' mm } }.

Fact Forall2_map_left X Y Z (R : Y -> X -> Prop) (f : Z -> Y) ll mm : Forall2 R (map f ll) mm <-> Forall2 (fun x y => R (f x) y) ll mm.

Fact Forall2_map_right X Y Z (R : Y -> X -> Prop) (f : Z -> X) mm ll : Forall2 R mm (map f ll) <-> Forall2 (fun y x => R y (f x)) mm ll.

Fact Forall2_map_both X Y X' Y' (R : X -> Y -> Prop) (f : X' -> X) (g : Y' -> Y) ll mm : Forall2 R (map f ll) (map g mm) <-> Forall2 (fun x y => R (f x) (g y)) ll mm.

Fact Forall2_Forall X (R : X -> X -> Prop) ll : Forall2 R ll ll <-> Forall (fun x => R x x) ll.

Fact Forall_app X (P : X -> Prop) ll mm : Forall P (ll++mm) <-> Forall P ll /\ Forall P mm.

Fact Forall_cons_inv X (P : X -> Prop) x ll : Forall P (x::ll) <-> P x /\ Forall P ll.

Fact Forall_rev X (P : X -> Prop) ll : Forall P ll -> Forall P (rev ll).

Fact Forall_map X Y (f : X -> Y) (P : Y -> Prop) ll : Forall P (map f ll) <-> Forall (fun x => P (f x)) ll.

Fact Forall_forall_map X (f : nat -> X) n l (P : X -> Prop) :
           l = map f (list_an 0 n) -> (forall i, i < n -> P (f i)) <-> Forall P l.

Fact Forall_impl X (P Q : X -> Prop) ll : (forall x, In x ll -> P x -> Q x) -> Forall P ll -> Forall Q ll.

Fact Forall_filter X (P : X -> Prop) (f : X -> bool) ll : Forall P ll -> Forall P (filter f ll). *)
(* gcd:
Require Import List Arith Omega Permutation.

Require Import utils_tac utils_list.

Set Implicit Arguments.

Section Euclid.

  Definition euclid n d : d <> 0 -> { q : nat & { r | n = q*d+r /\ r < d } }.

End Euclid.

Definition arem n d q j := j <= d /\ (n = 2*q*d+j \/ q <> 0 /\ n = 2*q*d-j).

Fact division_by_even n d : d <> 0 -> { q : nat & { j | arem n d q j } }.

Fact own_multiple x p : x = p*x -> x = 0 \/ p = 1.

Fact mult_is_one p q : p*q = 1 -> p = 1 /\ q = 1.

Definition divides n k := exists p, k = p*n.

Section divides.

  Infix "div" := divides (at level 70, no associativity).

  Fact divides_refl x : x div x.

  Fact divides_anti x y : x div y -> y div x -> x = y.

  Fact divides_trans x y z : x div y -> y div z -> x div z.

  Fact divides_0 p : p div 0.

  Fact divides_0_inv p : 0 div p -> p = 0.

  Fact divides_1 p : 1 div p.

  Fact divides_1_inv p : p div 1 -> p = 1.

  Fact divides_2_inv p : p div 2 -> p = 1 \/ p = 2.

  Fact divides_mult p q k : p div q -> p div k*q.

  Fact divides_mult_r p q k : p div q -> p div q*k.

  Fact divides_mult_compat a b c d : a div b -> c div d -> a*c div b*d.

  Fact divides_minus p q1 q2 : p div q1 -> p div q2 -> p div q1 - q2.

  Fact divides_plus p q1 q2 : p div q1 -> p div q2 -> p div q1+q2.

  Fact divides_plus_inv p q1 q2 : p div q1 -> p div q1+q2 -> p div q2.

  Fact divides_le p q : q <> 0 -> p div q -> p <= q.

  Fact divides_mult_inv k p q : k <> 0 -> k*p div k*q -> p div q.

  Lemma divides_fact m p : 1 < p <= m -> p div fact m.

  Lemma divides_mult_inv_l p q r : p * q div r -> p div r /\ q div r.

End divides.

Section gcd_lcm.

  Infix "div" := divides (at level 70, no associativity).

  Hint Resolve divides_0 divides_refl divides_mult divides_1.

  Definition is_gcd p q r := r div p /\ r div q /\ forall k, k div p -> k div q -> k div r.
  Definition is_lcm p q r := p div r /\ q div r /\ forall k, p div k -> q div k -> r div k.

  Fact is_gcd_sym p q r : is_gcd p q r -> is_gcd q p r.

  Fact is_gcd_0l p : is_gcd 0 p p.

  Fact is_gcd_0r p : is_gcd p 0 p.

  Fact is_gcd_1l p : is_gcd 1 p 1.

  Fact is_gcd_1r p : is_gcd p 1 1.

  Fact is_gcd_modulus p q k r : p div k -> k <= q -> is_gcd p q r -> is_gcd p (q-k) r.

  Fact is_gcd_minus p q r : p <= q -> is_gcd p q r -> is_gcd p (q-p) r.

  Hint Resolve divides_plus.

  Fact is_gcd_moduplus p q k r : p div k -> is_gcd p q r -> is_gcd p (q+k) r.

  Fact is_gcd_plus p q r : is_gcd p q r -> is_gcd p (q+p) r.

  Fact is_gcd_mult p q r n : is_gcd p (n*p+q) r <-> is_gcd p q r.

  Fact is_gcd_div p q : p div q -> is_gcd p q p.

  Fact is_gcd_refl p : is_gcd p p p.

  Fact is_gcd_fun p q r1 r2 : is_gcd p q r1 -> is_gcd p q r2 -> r1 = r2.

  Fact is_lcm_0l p : is_lcm 0 p 0.

  Fact is_lcm_0r p : is_lcm p 0 0.

  Fact is_lcm_sym p q r : is_lcm p q r -> is_lcm q p r.

  Fact is_lcm_fun p q r1 r2 : is_lcm p q r1 -> is_lcm p q r2 -> r1 = r2.

End gcd_lcm.

Section bezout.

  Infix "div" := divides (at level 70, no associativity).

  Hint Resolve is_gcd_0l is_gcd_0r is_lcm_0l is_lcm_0r divides_refl divides_mult divides_0 is_gcd_minus.

  Section bezout_rel_prime.

    Let bezout_rec p q : 0 < p < q -> is_gcd p q 1 -> exists a b, a*p+b*q = 1+p*q /\ a <= q /\ b <= p.

    Lemma bezout_nc p q : is_gcd p q 1 -> exists a b, a*p+b*q = 1+p*q.

    Hint Resolve divides_1.

    Lemma bezout_sc p q a b m : a*p+b*q = 1 + m -> p div m \/ q div m -> is_gcd p q 1.

  End bezout_rel_prime.

  Fact is_rel_prime_div p q k : is_gcd p q 1 -> p div q*k -> p div k.

  Fact is_rel_prime_div_r p q k : is_gcd p q 1 -> p div k*q -> p div k.

  Fact is_rel_prime_lcm p q : is_gcd p q 1 -> is_lcm p q (p*q).

  Hint Resolve divides_1 divides_mult_compat is_gcd_refl.

  Fact is_gcd_0 p q : is_gcd p q 0 -> p = 0 /\ q = 0.

  Fact is_gcd_rel_prime p q g : is_gcd p q g -> exists a b, p = a*g /\ q = b*g /\ is_gcd a b 1.

  Fact is_lcm_mult p q l k : is_lcm p q l -> is_lcm (k*p) (k*q) (k*l).

  Theorem is_gcd_lcm_mult p q g l : is_gcd p q g -> is_lcm p q l -> p*q = g*l.

  Theorem is_gcd_mult_lcm p q g l : g <> 0 -> is_gcd p q g -> g*l = p*q -> is_lcm p q l.

  Lemma is_lcm_minus p q g l u : p <= q -> p = u*g -> is_gcd p q g -> is_lcm p q l -> is_lcm p (q-p) (l-u*p).

  Lemma is_lcm_modulus k p q g l u : k*p <= q -> p = u*g -> is_gcd p q g -> is_lcm p q l -> is_lcm p (q-k*p) (l-k*u*p).

  Lemma is_lcm_plus p q g l u : p = u*g -> is_gcd p q g -> is_lcm p q l -> is_lcm p (q+p) (l+u*p).

  Lemma is_lcm_moduplus k p q g l u : p = u*g -> is_gcd p q g -> is_lcm p q l -> is_lcm p (q+k*p) (l+k*u*p).

  Section bezout_generalized.

    Let bezout_rec p q : 0 < p < q 
                      -> { a : nat 
                       & { b : nat 
                       & { g : nat
                       & { l : nat 
                       & { u : nat
                       & { v : nat
                         | a*p+b*q = g + l
                        /\ is_gcd p q g
                        /\ is_lcm p q l
                        /\ p = u*g
                        /\ q = v*g
                        /\ a <= v
                        /\ b <= u } } } } } }.
  
    Hint Resolve is_gcd_sym is_lcm_sym.

    Definition bezout_generalized p q : { a : nat 
                                      & { b : nat 
                                      & { g : nat
                                      & { l : nat 
                                        | a*p+b*q = g + l
                                       /\ is_gcd p q g
                                       /\ is_lcm p q l } } } }.

  End bezout_generalized.

  Section gcd_lcm.

    Let gcd_full p q : sig (is_gcd p q).

    Definition gcd p q := proj1_sig (gcd_full p q).
    Fact gcd_spec p q : is_gcd p q (gcd p q).

    Let lcm_full p q : sig (is_lcm p q).

    Definition lcm p q := proj1_sig (lcm_full p q).
    Fact lcm_spec p q : is_lcm p q (lcm p q).

  End gcd_lcm.
     
End bezout.

Require Import Extraction.
Extraction Inline measure_rect.

Check bezout_generalized.
Print Assumptions bezout_generalized.

Section division.

  Fact div_full q p : { n : nat & { r | q = n*p+r /\ (p <> 0 -> r < p) } }.

  Definition div q p := projT1 (div_full q p).
  Definition rem q p := proj1_sig (projT2 (div_full q p)).

  Fact div_rem_spec1 q p : q = div q p * p + rem q p.

  Fact div_rem_spec2 q p : p <> 0 -> rem q p < p.

  Fact rem_0 q : rem q 0 = q.

  Fact div_rem_uniq p n1 r1 n2 r2 : 
        p <> 0 -> n1*p + r1 = n2*p + r2 -> r1 < p -> r2 < p -> n1 = n2 /\ r1 = r2.

  Fact div_prop q p n r : q = n*p+r -> r < p -> div q p = n.

  Fact rem_prop q p n r : q = n*p+r -> r < p -> rem q p = r.

  Fact rem_idem q p : q < p -> rem q p = q.

  Fact is_gcd_rem p n a : is_gcd p n a <-> is_gcd p (rem n p) a.

  Fact rem_erase q n p r : q = n*p+r -> rem q p = rem r p.

  Fact divides_div q p : divides p q -> q = div q p * p.

  Fact divides_rem_eq q p : divides p q <-> rem q p = 0.

  Fact rem_of_0 p : rem 0 p = 0.

  Hint Resolve divides_0_inv.

  Fact divides_dec q p : { k | q = k*p } + { ~ divides p q }.

End division.

Section rem.

  Variable (p : nat) (Hp : p <> 0).

  Fact rem_plus_rem a b : rem (a+rem b p) p = rem (a+b) p.

  Fact rem_mult_rem a b : rem (a*rem b p) p = rem (a*b) p.

  Fact rem_diag : rem p p = 0.

  Fact rem_lt a : a < p -> rem a p = a.

  Fact rem_plus a b : rem (a+b) p = rem (rem a p + rem b p) p.

  Fact rem_scal k a : rem (k*a) p = rem (k*rem a p) p.

  Fact rem_plus_div a b : divides p b -> rem a p = rem (a+b) p.

  Fact div_eq_0 n : n < p -> div n p = 0.

  Fact div_of_0 : div 0 p = 0.

  Fact div_ge_1 n : p <= n -> 1 <= div n p.

End rem.

Fact div_by_p_lt p n : 2 <= p -> n <> 0 -> div n p < n.

Section rem_2.

  Fact rem_2_is_0_or_1 x : rem x 2 = 0 \/ rem x 2 = 1.

  Fact rem_2_mult x y : rem (x*y) 2 = 1 <-> rem x 2 = 1 /\ rem y 2 = 1.

  Fact rem_2_fix_0 : rem 0 2 = 0.

  Fact rem_2_fix_1 n : rem (2*n) 2 = 0.

  Fact rem_2_fix_2 n : rem (1+2*n) 2 = 1.

  Fact rem_2_lt n : rem n 2 < 2.

  Fact div_2_fix_0 : div 0 2 = 0.

  Fact div_2_fix_1 n : div (2*n) 2 = n.

  Fact div_2_fix_2 n : div (1+2*n) 2 = n.

  Fact euclid_2_div n : n = rem n 2 + 2*div n 2 /\ (rem n 2 = 0 \/ rem n 2 = 1).

  Fact euclid_2 n : exists q, n = 2*q \/ n = 1+2*q.

End rem_2.

Local Hint Resolve divides_mult divides_mult_r divides_refl.

Theorem CRT u v a b : u <> 0 -> v <> 0 -> is_gcd u v 1 -> exists w, rem w u = rem a u /\ rem w v = rem b v /\ 2 < w. *)
(* prime:
Require Import List Arith Omega Permutation.

Require Import utils_tac utils_list utils_nat gcd sums.

Set Implicit Arguments.

Section prime.

  Hint Resolve divides_0 divides_mult divides_refl divides_0_inv.

  Infix "<d" := divides (at level 70, no associativity).

  Definition prime p := p <> 1 /\ forall q, q <d p -> q = 1 \/ q = p.

  Fact prime_2 : prime 2.

  Fact prime_ge_2 p : prime p -> 2 <= p.

  Fact prime_gcd p q : prime p -> is_gcd p q 1 \/ p <d q.

  Fact prime_div_mult p x y : prime p -> p <d x*y -> p <d x \/ p <d y. 

  Definition prime_or_div p : 2 <= p -> { q | 2 <= q < p /\ q <d p } + { prime p }.

  Theorem prime_factor n : 2 <= n -> { p | prime p /\ p <d n }.

  Section prime_rect.

    Variables (P : nat -> Type)
              (HP0 : P 0)
              (HP1 : P 1)
              (HPp : forall p, prime p -> P p)
              (HPm : forall x y, P x -> P y -> P (x*y)).

    Theorem prime_rect n : P n.

  End prime_rect.

  Corollary no_common_prime_is_coprime x y : x <> 0 -> (forall p, prime p -> p <d x -> p <d y -> False) -> is_gcd x y 1.

  Fact is_rel_prime_mult p q l : is_gcd p q 1 -> is_gcd p l 1 -> is_gcd p (q*l) 1.

  Fact is_rel_prime_expo p q l : is_gcd p q 1 -> is_gcd p (mscal mult 1 l q) 1.

  Notation lprod := (fold_right mult 1).

  Fact lprod_ge_1 l : Forall prime l -> 1 <= lprod l.

  Fact lprod_app l m : lprod (l++m) = lprod l * lprod m.

  Theorem prime_decomp n : n <> 0 -> { l | n = lprod l /\ Forall prime l }.

  Hint Resolve lprod_ge_1 prime_ge_2.

  Fact prime_in_decomp p l : prime p -> Forall prime l -> p <d lprod l -> In p l.

  Theorem prime_decomp_uniq l m : Forall prime l -> Forall prime m -> lprod l = lprod m -> l ~p m.

End prime.

Section base_decomp.

  Fixpoint expand p l :=
    match l with
      | nil  => 0
      | x::l => x+p*expand p l
    end.

  Notation power := (mscal mult 1).

  Fact expand_app p l m : expand p (l++m) = expand p l + power (length l) p * expand p m.

  Fact expand_0 p l : Forall (eq 0) l -> expand p l = 0.

  Section base_p.

    Variables (p : nat) (Hp : 2 <= p).

    Let base_p_full n : { l | n = expand p l }.

    Definition base_p n := proj1_sig (base_p_full n).
    Fact base_p_spec n : n = expand p (base_p n).

    Fact base_p_uniq l1 l2 : Forall2 (fun x y => x < p /\ y < p) l1 l2 -> expand p l1 = expand p l2 -> l1 = l2.

  End base_p.

End base_decomp. *)
(* dio_logic:
Require Import Arith Nat Omega.
Require Import gcd.

Set Implicit Arguments.

Section diophantine_expressions.

  Inductive dio_op := do_add | do_mul.

  Definition do_eval o :=
    match o with
      | do_add => plus
      | do_mul => mult
    end.

  Inductive dio_expression : Set :=
    | de_cst  : nat -> dio_expression
    | de_var  : nat -> dio_expression
    | de_comp : dio_op -> dio_expression -> dio_expression -> dio_expression.

  Definition de_add := de_comp do_add.
  Definition de_mul := de_comp do_mul.

  Fixpoint de_size e :=
    match e with
      | de_cst n => 1
      | de_var x => 1
      | de_comp _ p q => 1 + de_size p + de_size q
    end.

  Fixpoint de_size_Z e :=
    (match e with
      | de_cst n => 1
      | de_var x => 1
      | de_comp _ p q => 1 + de_size_Z p + de_size_Z q
    end)%Z.

  Fact de_size_Z_spec e : de_size_Z e = Z.of_nat (de_size e).

  Fixpoint de_eval ŒΩ e  :=
    match e with
      | de_cst n => n
      | de_var x => ŒΩ x
      | de_comp o p q => do_eval o (de_eval ŒΩ p) (de_eval ŒΩ q)
    end.

  Fact de_eval_ext e ŒΩ œâ : (forall x, ŒΩ x = œâ x) -> de_eval ŒΩ e = de_eval œâ e.

  Fixpoint de_subst œÉ e :=
    match e with
      | de_cst n => de_cst n
      | de_var x => œÉ x
      | de_comp o p q => de_comp o (de_subst œÉ p) (de_subst œÉ q)
    end.

  Fact de_eval_subst œÉ ŒΩ e : de_eval ŒΩ (de_subst œÉ e) = de_eval (fun x => de_eval ŒΩ (œÉ x)) e.

  Fact de_subst_subst œÉ1 œÉ2 e : de_subst œÉ1 (de_subst œÉ2 e) = de_subst (fun x => de_subst œÉ1 (œÉ2 x)) e.

  Definition de_ren œÅ := de_subst (fun x => de_var (œÅ x)).

  Fact de_ren_size œÅ e : de_size (de_ren œÅ e) = de_size e.

  Fact de_ren_size_Z œÅ e : de_size_Z (de_ren œÅ e) = de_size_Z e.

  Fact de_eval_ren œÅ ŒΩ e : de_eval ŒΩ (de_ren œÅ e)  = de_eval (fun x => ŒΩ (œÅ x)) e.

  Definition de_lift := de_ren S.

  Fact de_eval_lift ŒΩ e : de_eval ŒΩ (de_lift e) = de_eval (fun x => ŒΩ (S x)) e.

End diophantine_expressions.

Definition dio_expr t := { e | forall ŒΩ, de_eval ŒΩ e = t ŒΩ }.

Notation ùîªP := dio_expr.

Section dio_expr.

  Implicit Types r t : (nat -> nat) -> nat.

  Fact dio_expr_var i : ùîªP (fun v => v i).

  Fact dio_expr_cst c : ùîªP (fun _ => c).

  Fact dio_expr_plus r t : ùîªP r -> ùîªP t -> ùîªP (fun ŒΩ => r ŒΩ + t ŒΩ).
  
  Fact dio_expr_mult r t : ùîªP r -> ùîªP t -> ùîªP (fun ŒΩ => r ŒΩ * t ŒΩ).

  Fact dio_expr_ren t œÅ : ùîªP t -> ùîªP (fun ŒΩ => t (fun i => ŒΩ (œÅ i))).

  Fact dio_expr_subst t œÉ : ùîªP t -> ùîªP (fun ŒΩ => t (fun i => de_eval ŒΩ (œÉ i))).

End dio_expr.

Hint Resolve dio_expr_var dio_expr_cst dio_expr_plus dio_expr_mult dio_expr_ren.

Section diophantine_logic.

  Inductive dio_formula : Set :=
    | df_atm  : dio_expression -> dio_expression -> dio_formula   
    | df_conj : dio_formula -> dio_formula -> dio_formula 
    | df_disj : dio_formula -> dio_formula -> dio_formula
    | df_exst : dio_formula -> dio_formula.

  Fixpoint df_size f :=
    match f with
      | df_atm a b  => 1 + de_size a + de_size b
      | df_conj f g => 1 + df_size f + df_size g  
      | df_disj f g => 1 + df_size f + df_size g  
      | df_exst f   => 1 + df_size f
    end.

  Fixpoint df_size_Z f :=
    (match f with
      | df_atm a b  => 1 + de_size_Z a + de_size_Z b
      | df_conj f g => 1 + df_size_Z f + df_size_Z g  
      | df_disj f g => 1 + df_size_Z f + df_size_Z g  
      | df_exst f   => 1 + df_size_Z f
    end)%Z.

  Fact df_size_Z_spec f : df_size_Z f = Z.of_nat (df_size f).

  Definition dv_lift X ŒΩ (x : X) n :=
     match n with 
       | 0   => x 
       | S n => ŒΩ n 
     end.

  Fixpoint df_pred f ŒΩ :=
    match f with
      | df_atm a b  => de_eval ŒΩ a  = de_eval ŒΩ b
      | df_conj f g => df_pred f ŒΩ /\ df_pred g ŒΩ
      | df_disj f g => df_pred f ŒΩ \/ df_pred g ŒΩ
      | df_exst f   => exists n, df_pred f (dv_lift ŒΩ n)
    end.

  Fact df_pred_atm a b ŒΩ : df_pred (df_atm a b) ŒΩ = (de_eval ŒΩ a = de_eval ŒΩ b).
  
  Fact df_pred_conj f g ŒΩ : df_pred (df_conj f g) ŒΩ = (df_pred f ŒΩ /\ df_pred g ŒΩ).

  Fact df_pred_disj f g ŒΩ : df_pred (df_disj f g) ŒΩ = (df_pred f ŒΩ \/ df_pred g ŒΩ).

  Fact df_pred_exst f ŒΩ : df_pred (df_exst f) ŒΩ = exists n, df_pred f (dv_lift ŒΩ n).

  Fact df_pred_ext f ŒΩ œâ : (forall x, ŒΩ x = œâ x) -> df_pred f ŒΩ <-> df_pred f œâ.

  Definition der_lift œÅ x := match x with 0 => 0 | S x => S (œÅ x) end.

  Fixpoint df_ren œÅ f :=
    match f with
      | df_atm a b  => let œÉ := fun x => de_var (œÅ x) in df_atm (de_subst œÉ a) (de_subst œÉ b)
      | df_conj f g => df_conj (df_ren œÅ f) (df_ren œÅ g)
      | df_disj f g => df_disj (df_ren œÅ f) (df_ren œÅ g)
      | df_exst f   => df_exst (df_ren (der_lift œÅ) f)
    end.

  Fact df_ren_size œÅ f : df_size (df_ren œÅ f) = df_size f.

  Fact df_ren_size_Z œÅ f : df_size_Z (df_ren œÅ f) = df_size_Z f.

  Fact df_pred_ren f ŒΩ œÅ : df_pred (df_ren œÅ f) ŒΩ <-> df_pred f (fun x => ŒΩ (œÅ x)).

  Definition des_lift œÉ x := match x with 0 => de_var 0 | S x => de_ren S (œÉ x) end. 
     
  Fixpoint df_subst œÉ f := 
    match f with
      | df_atm a b  => df_atm (de_subst œÉ a) (de_subst œÉ b)
      | df_conj f g => df_conj (df_subst œÉ f) (df_subst œÉ g)
      | df_disj f g => df_disj (df_subst œÉ f) (df_subst œÉ g)
      | df_exst f   => df_exst (df_subst (des_lift œÉ) f)
    end.

  Fact df_pred_subst f ŒΩ œÉ : df_pred (df_subst œÉ f) ŒΩ <-> df_pred f (fun x => de_eval ŒΩ (œÉ x)).

  Definition df_lift := df_ren S.

  Fact df_pred_lift f ŒΩ : df_pred (df_lift f) ŒΩ <-> df_pred f (fun x => ŒΩ (S x)).

End diophantine_logic.

Section examples.

  Variable ŒΩ : nat -> nat.

  Definition df_true := df_atm (de_cst 0) (de_cst 0).
  Definition df_false := df_atm (de_cst 0) (de_cst 1).

  Fact df_true_spec : df_pred df_true ŒΩ <-> True.

  Fact df_false_spec : df_pred df_false ŒΩ <-> False.

  Notation "'‚ü¶' x '‚üß'" := (de_eval ŒΩ x).

  Definition df_le x y := df_exst (df_atm (de_add (de_var 0) (de_lift x)) (de_lift y)).

  Fact df_le_spec x y : df_pred (df_le x y) ŒΩ <-> ‚ü¶x‚üß <= ‚ü¶y‚üß.

  Definition df_lt x y := df_exst (df_atm (de_add (de_cst 1) (de_add (de_var 0) (de_lift x))) (de_lift y)).

  Fact df_lt_spec x y : df_pred (df_lt x y) ŒΩ <-> ‚ü¶x‚üß < ‚ü¶y‚üß.

  Definition df_eq x y := df_atm x y.

  Fact df_eq_spec x y : df_pred (df_eq x y) ŒΩ <-> ‚ü¶x‚üß = ‚ü¶y‚üß.

  Definition df_neq x y := df_disj (df_lt x y) (df_lt y x).

  Fact df_neq_spec x y : df_pred (df_neq x y) ŒΩ <-> ‚ü¶x‚üß <> ‚ü¶y‚üß.

  Definition df_div x y := df_exst (df_atm (de_lift y) (de_mul (de_var 0) (de_lift x))).

  Fact df_div_spec x y : df_pred (df_div x y) ŒΩ <-> divides ‚ü¶x‚üß ‚ü¶y‚üß.

End examples.

Definition dio_rel R := { f | forall ŒΩ, df_pred f ŒΩ <-> R ŒΩ }.
Notation ùîªR := dio_rel.

Section dio_rel.

  Implicit Types R S : (nat -> nat) -> Prop.

  Fact dio_rel_True : ùîªR (fun _ => True).

  Fact dio_rel_False : ùîªR (fun _ => False).

  Fact dio_rel_eq r t : ùîªP r -> ùîªP t -> ùîªR (fun ŒΩ => r ŒΩ = t ŒΩ).

  Fact dio_rel_le r t : ùîªP r -> ùîªP t -> ùîªR (fun ŒΩ => r ŒΩ <= t ŒΩ).

  Fact dio_rel_lt r t : ùîªP r -> ùîªP t -> ùîªR (fun ŒΩ => r ŒΩ < t ŒΩ).

  Fact dio_rel_neq r t : ùîªP r -> ùîªP t -> ùîªR (fun ŒΩ => r ŒΩ <> t ŒΩ).

  Fact dio_rel_div r t : ùîªP r -> ùîªP t -> ùîªR (fun ŒΩ => divides (r ŒΩ) (t ŒΩ)).

  Fact dio_rel_conj R S : ùîªR R -> ùîªR S -> ùîªR (fun ŒΩ => R ŒΩ /\ S ŒΩ).

  Fact dio_rel_disj R S : ùîªR R -> ùîªR S -> ùîªR (fun ŒΩ => R ŒΩ \/ S ŒΩ).

  Fact dio_rel_exst (K : nat -> (nat -> nat) -> Prop) : 
                   ùîªR (fun v => K (v 0) (fun n => v (S n))) 
      -> ùîªR (fun ŒΩ => exists x, K x ŒΩ).

  Lemma dio_rel_equiv R S : (forall ŒΩ, S ŒΩ <-> R ŒΩ) -> ùîªR R -> ùîªR S.

  Lemma dio_rel_ren R f : ùîªR R -> ùîªR (fun v => R (fun n => v (f n))).

  Lemma dio_rel_subst R f : ùîªR R -> ùîªR (fun v => R (fun n => de_eval v (f n))).

End dio_rel.

Hint Resolve dio_rel_True dio_rel_False dio_rel_eq dio_rel_neq 
             dio_rel_le dio_rel_lt dio_rel_div 
             dio_rel_conj 
             dio_rel_disj 
             dio_rel_exst.

Ltac dio_rel_auto := repeat ((apply dio_rel_exst || apply dio_rel_conj || apply dio_rel_disj || apply dio_rel_eq); auto).

Section more_examples.

  Fact ndivides_eq x y : ~ (divides x y) <-> x = 0 /\ y <> 0 \/ exists a b, y = a*x+b /\ 0 < b < x.
  
  Lemma dio_rel_ndivides x y : ùîªP x -> ùîªP y -> ùîªR (fun ŒΩ => ~ divides (x ŒΩ) (y ŒΩ)).

  Hint Resolve dio_rel_ndivides.

  Fact rem_equiv p x r : r = rem x p <-> (p = 0 /\ x = r)
                                      \/ (p <> 0 /\ r < p /\ exists n, x = n*p + r).
 
  Lemma dio_rel_remainder p x r : ùîªP p -> ùîªP x -> ùîªP r  
                               -> ùîªR (fun ŒΩ => r ŒΩ = rem (x ŒΩ) (p ŒΩ)).

  Hint Resolve dio_rel_remainder.

  Fact congr_equiv x y p : rem x p = rem y p <-> (exists r, r = rem x p /\ r = rem y p).

  Lemma dio_rel_congruence x y p : ùîªP x -> ùîªP y -> ùîªP p  
                                -> ùîªR (fun ŒΩ => rem (x ŒΩ) (p ŒΩ) = rem (y ŒΩ) (p ŒΩ)).

  Hint Resolve dio_rel_congruence.

  Fact not_divides_eq p x : ~ divides p x <-> exists r, r = rem x p /\ r <> 0.

  Lemma dio_rel_not_divides x p : ùîªP x -> ùîªP p -> ùîªR (fun ŒΩ => ~ divides (x ŒΩ) (p ŒΩ)).

End more_examples.

Hint Resolve dio_rel_congruence dio_rel_not_divides.

Section dio_rel_compose.

  Variable (f : (nat -> nat) -> nat) (R : nat -> (nat -> nat) -> Prop).
  Hypothesis (Hf : ùîªR (fun ŒΩ => ŒΩ 0 = f (fun x => ŒΩ (S x)))) 
             (HR : ùîªR (fun ŒΩ => R (ŒΩ 0) (fun x => ŒΩ (S x)))).

  Lemma dio_rel_compose : ùîªR (fun ŒΩ => R (f ŒΩ) ŒΩ).

End dio_rel_compose.

Section multiple_exists.

  Fixpoint df_mexists n f :=
    match n with 
      | 0   => f
      | S n => df_mexists n (df_exst f)
    end.

  Fact df_mexists_size n f : df_size (df_mexists n f) = n + df_size f.

  Fact df_mexists_size_Z n f : df_size_Z (df_mexists n f) = (Z.of_nat n + df_size_Z f)%Z.

  Lemma df_mexists_spec n f ŒΩ : 
           df_pred (df_mexists n f) ŒΩ 
       <-> exists œÄ, df_pred f (fun i => if le_lt_dec n i then ŒΩ (i-n) else œÄ i).

End multiple_exists. *)

Set Implicit Arguments.

Section interval.

  Definition interval := (nat * nat)%type. 

  Implicit Types (i j : interval).

  Definition in_interval i x := let (a,b) := i in a <= x < b.
  Definition out_interval i x := let (a,b) := i in x < a \/ b <= x.
  Definition interval_disjoint i j := forall x, in_interval i x -> in_interval j x -> False.

  Definition interval_union (i j : interval) :=
    match i, j with (a1,b1),(a2,b2) => (min a1 a2, max b1 b2) end.

  Fact in_out_interval i x : in_interval i x -> out_interval i x -> False.
  Proof. destruct i; simpl; omega. Qed.

  Fact in_out_interval_dec i x : { in_interval i x } + { out_interval i x }.
  Proof. 
    destruct i as (a,b); simpl.
    destruct (le_lt_dec a x); destruct (le_lt_dec b x); try (left; omega);right; omega.
  Qed. 

  Fact interval_union_left i j x : in_interval i x -> in_interval (interval_union i j) x.
  Proof.
    revert i j; intros (a,b) (u,v); simpl.
    generalize (Nat.le_min_l a u) (Nat.le_max_l b v); omega.
  Qed.

  Fact interval_union_right i j x : in_interval j x -> in_interval (interval_union i j) x.
  Proof.
    revert i j; intros (a,b) (u,v); simpl.
    generalize (Nat.le_min_r a u) (Nat.le_max_r b v); omega.
  Qed.

  Definition valuation_union i1 (g1 : nat -> nat) i2 g2 : 
               interval_disjoint i1 i2 
            -> { g | (forall x, in_interval i1 x -> g x = g1 x)
                  /\ (forall x, in_interval i2 x -> g x = g2 x) }.
  Proof.
    intros H2.
    exists (fun x => if in_out_interval_dec i1 x then g1 x else g2 x).
    split; intros x Hx.
    + destruct (in_out_interval_dec i1 x) as [ | H3 ]; auto.
      exfalso; revert Hx H3; apply in_out_interval.
    + destruct (in_out_interval_dec i1 x) as [ H3 | ]; auto.
      exfalso; revert H3 Hx; apply H2.
  Qed.

  Definition valuation_one_union k v i1 (g1 : nat -> nat) i2 g2 : 
               ~ in_interval (interval_union i1 i2) k 
            -> interval_disjoint i1 i2 
            -> { g | g k = v /\ (forall x, in_interval i1 x -> g x = g1 x)
                             /\ (forall x, in_interval i2 x -> g x = g2 x) }.
  Proof.
    intros H1 H2.
    exists (fun x => if eq_nat_dec x k then v 
                     else if in_out_interval_dec i1 x then g1 x 
                     else g2 x).
    split; [ | split ].
    + destruct (eq_nat_dec k k) as [ | [] ]; auto.
    + intros x Hx.
      destruct (eq_nat_dec x k) as [ | ].
      * subst; destruct H1; apply interval_union_left; auto.
      * destruct (in_out_interval_dec i1 x) as [ | H3 ]; auto.
        exfalso; revert Hx H3; apply in_out_interval.
    + intros x Hx.
      destruct (eq_nat_dec x k) as [ | ].
      * subst; destruct H1; apply interval_union_right; auto.
      * destruct (in_out_interval_dec i1 x) as [ H3 | ]; auto.
        exfalso; revert H3 Hx; apply H2.
  Qed.

End interval.

Section diophantine_system.

  Inductive dio_elem_expr : Set :=
    | dee_nat  : nat -> dio_elem_expr   
    | dee_var  : nat -> dio_elem_expr   
    | dee_par  : nat -> dio_elem_expr   
    | dee_comp : dio_op -> nat -> nat -> dio_elem_expr. 

  Notation dee_add := (dee_comp do_add).
  Notation dee_mul := (dee_comp do_mul).

  Definition dee_eval œÜ ŒΩ e := 
    match e with
      | dee_nat n => n
      | dee_var v => œÜ v
      | dee_par i => ŒΩ i
      | dee_comp o v w => do_eval o (œÜ v) (œÜ w) 
    end.

  Definition dee_vars e x  :=
    match e with
      | dee_nat _ => False
      | dee_var v => x = v
      | dee_par _ => False
      | dee_comp _ v w => x = v \/ x = w
    end.

  Fact dee_eval_ext e œÜ1 ŒΩ1 œÜ2 ŒΩ2  : 
        (forall x, dee_vars e x -> œÜ1 x = œÜ2 x) 
     -> (forall x, ŒΩ1 x = ŒΩ2 x)
     -> dee_eval œÜ1 ŒΩ1 e = dee_eval œÜ2 ŒΩ2 e.
  Proof. destruct e as [ | | | [] ]; simpl; auto. Qed.

  Definition dee_move k p :=
    match p with
      | dee_nat n      => dee_nat n
      | dee_var v      => dee_var (k+v)
      | dee_par i      => dee_par i
      | dee_comp o v w => dee_comp o (k+v) (k+w)
    end.

  Fact dee_eval_move k œÜ ŒΩ e : dee_eval œÜ ŒΩ (dee_move k e) = dee_eval (fun x => œÜ (k+x)) ŒΩ e.
  Proof. destruct e as [ | | | [] ]; simpl; auto. Qed.

  Fact dee_vars_move k e x : dee_vars (dee_move k e) x <-> exists y, dee_vars e y /\ x = k+y.
  Proof. destruct e as [ | | | [] ]; simpl; firstorder. Qed.

  Definition dee_dec k e :=
    match e with
      | dee_nat n      => dee_nat n
      | dee_var v      => dee_var v
      | dee_par 0      => dee_var k 
      | dee_par (S i)  => dee_par i
      | dee_comp o v w => dee_comp o v w
    end.

  Fact dee_eval_dec œÜ ŒΩ k e : dee_eval œÜ ŒΩ (dee_dec k e) = dee_eval œÜ (fun x => match x with 0 => œÜ k | S x => ŒΩ x end) e.
  Proof. destruct e as [ | | [] | [] ]; simpl; auto. Qed.

  Fact dee_vars_dec k e x : dee_vars (dee_dec k e) x -> x = k \/ dee_vars e x.
  Proof. destruct e as [ | | [] | [] ]; simpl; firstorder. Qed.

  Definition dio_constraint := (nat * dio_elem_expr)%type.

  Implicit Type (c : dio_constraint).

  Definition dc_eval œÜ ŒΩ c := œÜ (fst c) = dee_eval œÜ ŒΩ (snd c).

  Arguments dc_eval œÜ ŒΩ c /.
  
  Definition dc_vars c x := x = fst c \/ dee_vars (snd c) x.

  Arguments dc_vars c x /.

  Fact dc_eval_ext c œÜ1 ŒΩ1 œÜ2 ŒΩ2  : 
        (forall x, dc_vars c x -> œÜ1 x = œÜ2 x) 
     -> (forall x, ŒΩ1 x = ŒΩ2 x)
     -> dc_eval œÜ1 ŒΩ1 c <-> dc_eval œÜ2 ŒΩ2 c.
  Proof.
    intros H1 H2.
    destruct c as (v,e); unfold dc_eval; simpl.
    rewrite H1; simpl; auto.
    rewrite dee_eval_ext with e œÜ1 ŒΩ1 œÜ2 ŒΩ2; try tauto.
    intros; apply H1; simpl; auto.
  Qed.

  Definition dc_move k c := (k+fst c, dee_move k (snd c)).

  Fact dc_eval_move k œÜ ŒΩ c : dc_eval œÜ ŒΩ (dc_move k c) <-> dc_eval (fun x => œÜ (k+x)) ŒΩ c.
  Proof.
    destruct c as (v,e); simpl.
    rewrite dee_eval_move; tauto.
  Qed.

  Fact dc_vars_move k c x : dc_vars (dc_move k c) x <-> exists y, x = k + y /\ dc_vars c y.
  Proof.
    destruct c as (v,e); simpl.
    rewrite dee_vars_move.
    split.
    + intros [ ? | (y & Hy & ?) ]; subst x; firstorder; exists v; auto.
    + intros (y & ? & [ | ]); subst; firstorder.
  Qed.

  Definition dc_dec k c := (fst c, dee_dec k (snd c)).

  Fact dc_eval_dec œÜ ŒΩ k c : dc_eval œÜ ŒΩ (dc_dec k c) <-> dc_eval œÜ  (fun x => match x with 0 => œÜ k | S x => ŒΩ x end) c.
  Proof. destruct c; simpl; rewrite dee_eval_dec; tauto. Qed.

  Fact dc_vars_dec k c x : dc_vars (dc_dec k c) x -> x = k \/ dc_vars c x.
  Proof. destruct c; simpl; intros [ | H ]; auto; apply dee_vars_dec in H; tauto. Qed.

  Implicit Type (R : (nat -> nat) -> Prop).

  Record dio_repr_at R a n l := {
    ds_eqns : list dio_constraint;
    ds_ref  : nat;
    ds_H0   : length ds_eqns = l;
    ds_H1   : forall x c, In c ds_eqns -> dc_vars c x -> a <= x < a+n;
    ds_H2   : a <= ds_ref < a+n;
    ds_H3   : forall ŒΩ, exists œÜ, Forall (dc_eval œÜ ŒΩ) ds_eqns;
    ds_H4   : forall ŒΩ, R ŒΩ <-> exists œÜ, Forall (dc_eval œÜ ŒΩ) ds_eqns /\ œÜ ds_ref = 0;
  }.

  Section diophantine_sys_expr.

    Fixpoint de_eqns e x :=
      match e with
        | de_cst n      => (x,dee_nat n)::nil 
        | de_var p      => (x,dee_par p)::nil
        | de_comp o p q => (x,dee_comp o (x+1) (x+1+de_size p)) :: de_eqns p (x+1) ++ de_eqns q (x+1+de_size p)
      end.

    Fact de_eqns_length e x : length (de_eqns e x) = de_size e.
    Proof.
      revert x; induction e as [ | | o p Hp q Hq ]; intros x; simpl; auto.
      rewrite app_length, Hp, Hq; auto.
    Qed.

    Fact de_size_ge_1 e : 1 <= de_size e.
    Proof. destruct e; simpl; omega. Qed.

    Fact de_eqns_vars e x : forall c, In c (de_eqns e x) -> forall y, dc_vars c y -> x <= y < x+de_size e.
    Proof.
      revert x; induction e as [ | | o p Hp q Hq ]; intros x; simpl; auto.
      + intros ? [ [] | [] ]; simpl; intros; omega.
      + intros ? [ [] | [] ]; simpl; intros; omega.
      + intros c [ Hc | Hc ]; [ | apply in_app_or in Hc; destruct Hc as [ Hc | Hc ] ]; subst; simpl.
        * intros; generalize (de_size_ge_1 q); intros; omega.
        * intros y Hy; apply Hp with (y := y) in Hc; simpl in *; auto; omega.
        * intros y Hy; apply Hq with (y := y) in Hc; simpl in *; auto; omega.
    Qed.

    Fact dc_Forall_eval œÜ ŒΩ e x : Forall (dc_eval œÜ ŒΩ) (de_eqns e x) -> de_eval ŒΩ e = œÜ x.
    Proof.
      rewrite Forall_forall.
      revert x; induction e as [ | v| [] p Hp q Hq ]; simpl; intros x Hx; simpl; auto.
      * specialize (Hx (x,dee_nat n)); simpl in Hx; rewrite Hx; auto.
      * specialize (Hx (x,dee_par v)); simpl in Hx; rewrite Hx; auto.
      * rewrite Hp with (x+1), Hq with (x+1+de_size p).
        - symmetry; apply (Hx (_, dee_add _ _)); auto.
        - intros; apply Hx; right; apply in_or_app; auto.
        - intros; apply Hx; right; apply in_or_app; auto.
      * rewrite Hp with (x+1), Hq with (x+1+de_size p).
        - symmetry; apply (Hx (_, dee_mul _ _)); auto.
        - intros; apply Hx; right; apply in_or_app; auto.
        - intros; apply Hx; right; apply in_or_app; auto.
    Qed.

    Fact dc_eval_exists_Forall ŒΩ e x : { œÜ | Forall (dc_eval œÜ ŒΩ) (de_eqns e x) }. 
    Proof.
      revert x; induction e as [ | v | o p Hp q Hq ]; simpl; intros x.
      + exists (fun  _ => n); constructor; simpl; auto.
      + exists (fun  _ => ŒΩ v); constructor; simpl; auto.
      + destruct (Hp (x+1)) as (g1 & H2).
        destruct (Hq (x+1+de_size p)) as (g2 & H4).
        generalize (dc_Forall_eval _ _ H2) (dc_Forall_eval _ _ H4); intros H1 H3.
        destruct (@valuation_one_union x (do_eval o (de_eval ŒΩ p) (de_eval ŒΩ q)) (x+1,x+1+de_size p) g1 (x+1+de_size p, x+1+de_size p+de_size q) g2)
           as (g & H5 & H6 & H7).
        * simpl; rewrite Min.min_l; omega.
        * intros y; simpl; omega.
        * exists g; constructor.
          - red; unfold fst, snd; rewrite H5, H1, H3; simpl; f_equal; symmetry.
            ++ apply H6; simpl; generalize (de_size_ge_1 p); intros; omega.
            ++ apply H7; simpl; generalize (de_size_ge_1 q); intros; omega.
          - apply Forall_app; split.
            ++ revert H2; do 2 rewrite Forall_forall.
               intros H c Hc.
               generalize (H _ Hc); apply dc_eval_ext; auto.
               intros y Hy; apply H6.
               apply de_eqns_vars with (1 := Hc); auto.
            ++ revert H4; do 2 rewrite Forall_forall.
               intros H c Hc.
               generalize (H _ Hc); apply dc_eval_ext; auto.
               intros y Hy; apply H7.
               apply de_eqns_vars with (1 := Hc); auto.
    Qed.

    Let compare_lemma x y : { u : nat & { v | u+x = v+y } }.
    Proof.
      destruct (le_lt_dec x y).
      + exists (y-x), 0; omega.
      + exists 0, (x-y); omega.
    Qed.

    Let g0 (n x0 x1 x2 x3 m : nat) := if le_lt_dec n m then 
                                match m - n with
                                  | 0 => x0
                                  | 1 => x1
                                  | 2 => x2
                                  | _ => x3
                                end
                              else x3.

    Let g0_0 (n x0 x1 x2 x3 : nat) : g0 n x0 x1 x2 x3 n = x0.
    Proof. 
      unfold g0; destruct (le_lt_dec n n); try omega.
      replace (n-n) with 0 by omega; auto.
    Qed.

    Let g0_1 (n x0 x1 x2 x3 : nat) : g0 n x0 x1 x2 x3 (n+1) = x1.
    Proof. 
      unfold g0; destruct (le_lt_dec n (n+1)); try omega.
      replace (n+1-n) with 1 by omega; auto.
    Qed.

    Let g0_2 (n x0 x1 x2 x3 : nat) : g0 n x0 x1 x2 x3 (n+2) = x2.
    Proof. 
      unfold g0; destruct (le_lt_dec n (n+2)); try omega.
      replace (n+2-n) with 2 by omega; auto.
    Qed.

    Let g0_3 (n x0 x1 x2 x3 : nat) : g0 n x0 x1 x2 x3 (n+3) = x3.
    Proof. 
      unfold g0; destruct (le_lt_dec n (n+3)); try omega.
      replace (n+3-n) with 3 by omega; auto.
    Qed.

    Lemma dio_repr_at_eq n e1 e2 : dio_repr_at (fun ŒΩ => de_eval ŒΩ e1 = de_eval ŒΩ e2) n (4+de_size e1+de_size e2) (3+de_size e1+de_size e2).
    Proof.
      exists ((n+3, dee_add (n+1) (n+4)) ::
              (n+3, dee_add (n+2) (n+4+de_size e1)) ::
              (n,   dee_add (n+1) (n+2)) ::
              (de_eqns e1 (n+4) ++ de_eqns e2 (n+4+de_size e1))) n.
      + simpl; rewrite app_length; do 2 rewrite de_eqns_length; auto.
      + intros x c [ Hc | [ Hc | [ Hc | Hc ] ] ].
        * subst; simpl; generalize (de_size_ge_1 e2); omega.
        * subst; simpl; generalize (de_size_ge_1 e2); omega.
        * subst; simpl; generalize (de_size_ge_1 e2); omega.
        * intros Hx; apply in_app_or in Hc.
          destruct Hc as [ Hc | Hc ]; apply de_eqns_vars with (2 := Hx) in Hc;
             simpl in *; omega.
      + simpl; omega.
      + intros f.
        destruct (@dc_eval_exists_Forall f e1 (n+4)) as (g1 & H2).
        destruct (@dc_eval_exists_Forall f e2 (n+4+de_size e1)) as (g2 & H4).
        destruct (compare_lemma (g1 (n+4)) (g2 (n+4+de_size e1))) as (u & v & Huv).
        set (g3 := g0 n (u+v) u v (u+g1 (n+4))).
        destruct (@valuation_union (n+4, n+4+de_size e1) g1 (n+4+de_size e1, n+4+de_size e1+de_size e2) g2)
           as (g4 & H5 & H6).
        { intro; simpl; omega. }
        destruct (@valuation_union (n,n+4) g3 (n+4,n+4+de_size e1+de_size e2) g4) 
           as (g & H7 & H8).
        { intro; simpl; omega. }
        generalize (de_size_ge_1 e1) (de_size_ge_1 e2); intros E1 E2.
        exists g; repeat constructor; simpl.
        * rewrite H7, H7; simpl; auto; try omega.
          rewrite H8; simpl; try omega.
          rewrite H5; simpl; try omega.
          unfold g3; rewrite g0_1, g0_3; omega.
        * rewrite H7, H7; simpl; auto; try omega.
          rewrite H8; simpl; try omega.
          rewrite H6; simpl; auto; try omega.
          unfold g3; rewrite g0_2, g0_3; omega.
        * rewrite H7, H7, H7; simpl; try omega.
          unfold g3; rewrite g0_0, g0_1, g0_2; auto.
        * apply Forall_app; split.
          - revert H2; do 2 rewrite Forall_forall.
            intros H c Hc; generalize (H _ Hc).
            apply dc_eval_ext; auto.
            intros x Hx; rewrite H8.
            ++ apply H5, de_eqns_vars with (1 := Hc); auto.
            ++ apply de_eqns_vars with (1 := Hc) in Hx.
               simpl in *; omega.
          - revert H4; do 2 rewrite Forall_forall.
            intros H c Hc; generalize (H _ Hc).
            apply dc_eval_ext; auto.
            intros x Hx; rewrite H8.
            ++ apply H6, de_eqns_vars with (1 := Hc); auto.
            ++ apply de_eqns_vars with (1 := Hc) in Hx.
               simpl in *; omega.
      + intros f; split.
        * intros Hf.
          destruct (@dc_eval_exists_Forall f e1 (n+4)) as (g1 & H2).
          destruct (@dc_eval_exists_Forall f e2 (n+4+de_size e1)) as (g2 & H4).
          generalize (dc_Forall_eval _ _ H2) (dc_Forall_eval _ _ H4); intros H1 H3.
          set (g3 := g0 n 0 0 0 (de_eval f e1)).
          destruct (@valuation_union (n+4, n+4+de_size e1) g1 (n+4+de_size e1, n+4+de_size e1+de_size e2) g2)
             as (g4 & H5 & H6).
          { intro; simpl; omega. }
          destruct (@valuation_union (n, n+4) g3 (n+4, n+4+de_size e1+de_size e2) g4) 
            as (g & H7 & H8).
          { intro; simpl; omega. }
          generalize (de_size_ge_1 e1) (de_size_ge_1 e2); intros E1 E2.
          exists g; repeat constructor; simpl.
          - rewrite H7, H7; simpl; auto; try omega.
            rewrite H8; simpl; try omega.
            rewrite H5; simpl; try omega.
            unfold g3; rewrite g0_3, g0_1; omega.
          - rewrite H7, H7; simpl; auto; try omega.
            rewrite H8; simpl; try omega.
            unfold g3; rewrite g0_3, g0_2.
            rewrite Hf, H6; simpl; auto; omega.
          - rewrite H7, H7, H7; simpl; try omega.
            unfold g3; rewrite g0_0, g0_1, g0_2; auto.
          - apply Forall_app; split.
            ++ revert H2; do 2 rewrite Forall_forall.
               intros H c Hc; generalize (H _ Hc).
               apply dc_eval_ext; auto.
               intros x Hx; rewrite H8.
               ** apply H5, de_eqns_vars with (1 := Hc); auto.
               ** apply de_eqns_vars with (1 := Hc) in Hx.
                  simpl in *; omega.
            ++ revert H4; do 2 rewrite Forall_forall.
               intros H c Hc; generalize (H _ Hc).
               apply dc_eval_ext; auto.
               intros x Hx; rewrite H8.
               ** apply H6, de_eqns_vars with (1 := Hc); auto.
               ** apply de_eqns_vars with (1 := Hc) in Hx.
                  simpl in *; omega.
          - rewrite H7; simpl; try omega.
            unfold g3; rewrite g0_0; auto.
        * intros (g & H1 & H0).
          do 3 rewrite Forall_cons_inv in H1.
          rewrite Forall_app in H1.
          destruct H1 as (H1 & H2 & H3 & H4 & H5).
          simpl in *.
          rewrite dc_Forall_eval with (1 := H4).
          rewrite dc_Forall_eval with (1 := H5).
          omega.
    Defined.

  End diophantine_sys_expr.

  Let not_interval_union a1 n1 a2 n2 : 
           a1+n1 <= a2
        -> ~ in_interval (interval_union (a1, a1 + n1) (a2, a2 + n2)) (a2 + n2).
  Proof.
    simpl; intros H1 (_ & H3).
    rewrite Nat.max_r in H3; omega.
  Qed.

  Lemma dio_repr_at_conj R1 a1 n1 p1 R2 a2 n2 p2 n : 
          dio_repr_at R1 a1 n1 p1
       -> dio_repr_at R2 a2 n2 p2
       -> a1+n1 <= a2
       -> n = 1+a2+n2-a1
       -> dio_repr_at (fun ŒΩ => R1 ŒΩ /\ R2 ŒΩ) a1 n (1+p1+p2).
  Proof.
    intros [ l1 r1 F0 F1 F2 F3 F4 ] [ l2 r2 G0 G1 G2 G3 G4 ] H12 ?; subst n.
    exists ((a2+n2,dee_add r1 r2)::l1++l2) (a2+n2).
    + simpl; rewrite app_length, F0, G0; omega.
    + replace (a1+(1+a2+n2-a1)) with (1+a2+n2) by omega.
      intros x c [ Hc | Hc ].
      * subst; simpl; omega.
      * intros H1; apply in_app_or in Hc; destruct Hc as [ Hc | Hc ].
        - specialize (F1 _ _ Hc H1); omega.
        - specialize (G1 _ _ Hc H1); omega.
    + omega.
    + intros f.
      destruct (F3 f) as (g1 & H1).
      destruct (G3 f) as (g2 & H2).
      destruct (@valuation_one_union (a2+n2) (g1 r1+g2 r2) (a1,a1+n1) g1 (a2,a2+n2) g2) 
        as (g & Hg1 & Hg2 & Hg3); auto.
      { red; simpl; intros; omega. }
      exists g; constructor; [ | apply Forall_app; split ].
      * simpl; rewrite (Hg2 r1), (Hg3 r2); auto.
      * apply Forall_impl with (2 := H1).
        intros c Hc; apply dc_eval_ext; auto.
        intros x Hx; apply Hg2, F1 with c; auto.
      * apply Forall_impl with (2 := H2).
        intros c Hc; apply dc_eval_ext; auto.
        intros x Hx; apply Hg3, G1 with c; auto.
    + intros f; rewrite F4, G4; split.
      * intros ((g1 & H1 & H2) & (g2 & H3 & H4)).
        destruct (@valuation_one_union (a2+n2) 0 (a1,a1+n1) g1 (a2,a2+n2) g2) 
          as (g & Hg1 & Hg2 & Hg3); auto.
        { red; simpl; intros; omega. }
        exists g; split; auto; constructor; simpl.
        ++ rewrite Hg1, Hg2, Hg3; auto; omega.
        ++ apply Forall_app; split.
           ** apply Forall_impl with (2 := H1).
              intros c Hc; apply dc_eval_ext; auto.
              intros x Hx; apply Hg2, F1 with c; auto.
           ** apply Forall_impl with (2 := H3).
              intros c Hc; apply dc_eval_ext; auto.
              intros x Hx; apply Hg3, G1 with c; auto.
      * intros (g & Hg1 & Hg2).
        inversion Hg1 as [ | ? ? Hg3 Hg4 ].
        apply Forall_app in Hg4; destruct Hg4 as (Hg4 & Hg5).
        simpl in Hg3; split; exists g; split; auto; omega.
  Defined.

  Lemma dio_repr_at_disj R1 a1 n1 p1 R2 a2 n2 p2 n : 
          dio_repr_at R1 a1 n1 p1
       -> dio_repr_at R2 a2 n2 p2
       -> a1+n1 <= a2
       -> n = 1+a2+n2-a1
       -> dio_repr_at (fun ŒΩ => R1 ŒΩ \/ R2 ŒΩ) a1 n (1+p1+p2). 
  Proof.
    intros [ l1 r1 F0 F1 F2 F3 F4 ] [ l2 r2 G0 G1 G2 G3 G4 ] H12 ?; subst n.
    exists ((a2+n2,dee_mul r1 r2)::l1++l2) (a2+n2).
    + simpl; rewrite app_length, F0, G0; omega.
    + replace (a1+(1+a2+n2-a1)) with (1+a2+n2) by omega.
      intros x c [ Hc | Hc ].
      * subst; simpl; omega.
      * intros H1; apply in_app_or in Hc; destruct Hc as [ Hc | Hc ].
        - specialize (F1 _ _ Hc H1); omega.
        - specialize (G1 _ _ Hc H1); omega.
    + omega.
    + intros f.
      destruct (F3 f) as (g1 & H1).
      destruct (G3 f) as (g2 & H2).
      destruct (@valuation_one_union (a2+n2) (g1 r1*g2 r2) (a1,a1+n1) g1 (a2,a2+n2) g2) 
        as (g & Hg1 & Hg2 & Hg3); auto.
      { red; simpl; intros; omega. }
      exists g; constructor; [ | apply Forall_app; split ].
      * simpl; rewrite (Hg2 r1), (Hg3 r2); auto.
      * apply Forall_impl with (2 := H1).
        intros c Hc; apply dc_eval_ext; auto.
        intros x Hx; apply Hg2, F1 with c; auto.
      * apply Forall_impl with (2 := H2).
        intros c Hc; apply dc_eval_ext; auto.
        intros x Hx; apply Hg3, G1 with c; auto.
    + intros f; rewrite F4, G4; split.
      * intros [ (g1 & H1 & H2) | (g2 & H1 & H2) ].
        - destruct (G3 f) as (g2 & H3).
          destruct (@valuation_one_union (a2+n2) 0 (a1,a1+n1) g1 (a2,a2+n2) g2) 
            as (g & Hg1 & Hg2 & Hg3); auto.
          { red; simpl; intros; omega. }
          exists g; split; auto.
          constructor; simpl; [ | apply Forall_app; split ].
          ++ rewrite Hg1, Hg2, H2; auto.
          ++ apply Forall_impl with (2 := H1).
             intros c Hc; apply dc_eval_ext; auto.
             intros x Hx; apply Hg2, F1 with c; auto.
          ++ apply Forall_impl with (2 := H3).
             intros c Hc; apply dc_eval_ext; auto.
             intros x Hx; apply Hg3, G1 with c; auto.
        - destruct (F3 f) as (g1 & H3).
          destruct (@valuation_one_union (a2+n2) 0 (a1,a1+n1) g1 (a2,a2+n2) g2) 
            as (g & Hg1 & Hg2 & Hg3); auto.
          { red; simpl; intros; omega. }
          exists g; split; auto.
          constructor; simpl; [ | apply Forall_app; split ].
          ++ rewrite Hg1, (Hg3 r2), H2, mult_comm; auto.
          ++ apply Forall_impl with (2 := H3).
             intros c Hc; apply dc_eval_ext; auto.
             intros x Hx; apply Hg2, F1 with c; auto.
          ++ apply Forall_impl with (2 := H1).
             intros c Hc; apply dc_eval_ext; auto.
             intros x Hx; apply Hg3, G1 with c; auto.
      * intros (g & Hg1 & Hg2).
        inversion Hg1 as [ | ? ? Hg3 Hg4 ].
        apply Forall_app in Hg4; destruct Hg4 as (Hg4 & Hg5).
        simpl in Hg3; rewrite Hg2 in Hg3.
        symmetry in Hg3; apply mult_is_O in Hg3.
        destruct Hg3 as [ Hg3 | Hg3 ]; [ left | right ]; exists g; auto.
  Defined.

  Lemma dio_repr_at_exst R a n m p : 
          dio_repr_at R a n p
       -> m = n+1
       -> dio_repr_at (fun ŒΩ => exists n, R (dv_lift ŒΩ n)) a m p. 
  Proof.
    intros [ l r F0 F1 F2 F3 F4 ] ?; subst m.
    exists (map (dc_dec (a+n)) l) r.
    + rewrite map_length; auto.
    + intros x c'; rewrite in_map_iff.
      intros (c & E & Hc) H; subst.
      apply dc_vars_dec in H.
      destruct H as [ | H ]; subst; simpl; try omega.
      apply F1 in H; simpl in *; auto; omega.
    + omega.
    + intros f.
      destruct (F3 (fun x => match x with 0 => 0 | S x => f x end)) as (g & Hg).
      exists (fun x => if eq_nat_dec x (a+n) then 0 else g x).
      rewrite Forall_map.
      apply Forall_impl with (2 := Hg). 
      intros c Hc; rewrite dc_eval_dec; apply dc_eval_ext; auto.
      * intros x Hx.
        destruct (eq_nat_dec x (a+n)); subst; auto.
        apply F1 in Hx; auto; omega.
      * intros [ | x ]; auto.
        destruct (eq_nat_dec (a+n) (a+n)); tauto.
    + intros f; split.
      * intros (u & Hu).
        apply F4 in Hu.
        destruct Hu as (g & H1 & H2).
        exists (fun x => if eq_nat_dec x (a+n) then u else g x); simpl; split.
        - rewrite Forall_map.
          apply Forall_impl with (2 := H1).
          intros c Hc; rewrite dc_eval_dec; apply dc_eval_ext; auto.
          ++ intros x Hx.
             destruct (eq_nat_dec x (a+n)); auto.
             subst x; apply F1 in Hx; auto; omega.
          ++ intros [ | x ]; auto.
             destruct (eq_nat_dec (a+n) (a+n)); tauto.
        - destruct (eq_nat_dec r (a+n)); auto.
          subst; omega.
      * intros (g & H1 & H2).
        exists (g (a+n)); rewrite F4.
        exists g; split; auto.
        revert H1; do 2 rewrite Forall_forall.
        intros H c Hc.
        apply in_map with (f := dc_dec _), H in Hc.
        revert Hc; rewrite dc_eval_dec; apply dc_eval_ext; auto.
  Defined.

  Fixpoint df_weight_1 f :=
    match f with
      | df_atm a b  => 4 + de_size a + de_size b
      | df_conj f g => 1 + df_weight_1 f + df_weight_1 g  
      | df_disj f g => 1 + df_weight_1 f + df_weight_1 g  
      | df_exst f   => 1 + df_weight_1 f
    end.

  Fact df_weigth_1_size f : df_weight_1 f <= 4*df_size f.
  Proof. induction f; simpl; omega. Qed.

  Fixpoint df_weight_2 f :=
    match f with
      | df_atm a b  => 3 + de_size a + de_size b
      | df_conj f g => 1 + df_weight_2 f + df_weight_2 g  
      | df_disj f g => 1 + df_weight_2 f + df_weight_2 g  
      | df_exst f   => df_weight_2 f
    end.

  Fact df_weigth_2_size f : df_weight_2 f <= 3*df_size f.
  Proof. induction f; simpl in *; omega. Qed.

  Lemma dio_repr_at_form n f : dio_repr_at (df_pred f) n (df_weight_1 f) (df_weight_2 f).
  Proof.
    revert n;
    induction f as [ a b | f IHf g IHg | f IHf g IHg | f IHf ]; intros n; simpl df_pred; simpl df_weight_1; simpl df_weight_2.
    + apply dio_repr_at_eq.
    + apply dio_repr_at_conj with (n1 := df_weight_1 f) (a2 := n+df_weight_1 f) (n2 := df_weight_1 g); auto; omega.
    + apply dio_repr_at_disj with (n1 := df_weight_1 f) (a2 := n+df_weight_1 f) (n2 := df_weight_1 g); auto; omega.
    + apply dio_repr_at_exst with (n := df_weight_1 f); auto; omega.
  Defined.

  Theorem dio_formula_elem f : { l | length l <= 1+3*df_size f
                                 /\ (forall c x, In c l -> dc_vars c x -> x < 4*df_size f)  
                                 /\  forall ŒΩ, df_pred f ŒΩ <-> exists œÜ, Forall (dc_eval œÜ ŒΩ) l }.
  Proof.
    destruct (dio_repr_at_form 0 f) as [l r H0 H1 H2 H3 H4].
    exists ((r,dee_nat 0) :: l); split; [ | split ]; simpl length; try omega.
    + rewrite H0; apply le_n_S, df_weigth_2_size.
    + intros c x [ [] | H ].
      * simpl dc_vars; intros [ | [] ]; subst.
        generalize (df_weigth_1_size f); intros; omega.
      * intros G; apply H1 in G; auto.
        generalize (df_weigth_1_size f); intros; omega.
    + intros ŒΩ; rewrite H4.
      split; intros (œÜ & H); exists œÜ; revert H; rewrite Forall_cons_inv; simpl; tauto.
  Defined.

  Definition dio_fs f := proj1_sig (dio_formula_elem f).
                 
End diophantine_system.

