

Require Import Deduction.
(* Deduction:
Require Export Semantics.

Inductive nd := intu | class.
Existing Class nd.

Inductive prv : forall {s : nd} {b : logic} (A : list (form b)), form b -> Prop :=
| Ctx {b} {s : nd} (A : list (form b)) phi : In phi A -> prv A phi
| ImpI {b} {s : nd} (A : list (form b)) phi1 phi2 : prv (phi1::A) phi2 -> prv A (phi1 --> phi2)
| ImpE {b} {s : nd} (A : list (form b)) phi1 phi2 : prv A (phi1 --> phi2) -> prv A phi1 -> prv A phi2
| AllI {b} {s : nd} (A : list (form b)) x y phi : fresh y (consts phi ++ consts_l A) -> prv A (subst x (P y) phi) -> prv A (∀ x ; phi)
| AllE {b} {s : nd} (A : list (form b)) x t phi : vars_t t = [] 
                                       -> prv A (All x phi) -> prv A (subst x t phi)

| Exp A phi : @prv intu full A Fal -> @prv intu full A phi
| DN A phi : @prv class full A (¬¬ phi) -> @prv class full A phi.

Notation "A ⊢ phi" := (prv A phi) (at level 30).

Definition prv_min := @prv intu frag.
Definition prv_class := @prv class full.
Definition prv_intu := @prv intu full.

Notation "A ⊢M phi" := (prv_min A phi) (at level 30).
Notation "A ⊢I phi" := (@prv intu _ A phi) (at level 30).
Notation "A ⊢C phi" := (@prv class _ A phi) (at level 30).

Lemma prv_ind_min :
  forall p : list (form frag) -> form frag -> Prop,
       (forall  (A : list (form frag)) (phi : form frag), phi el A -> p A phi) ->
       (forall  (A : list (form frag)) (phi1 phi2 : form frag),
        (phi1 :: A) ⊢I phi2 -> p (phi1 :: A) phi2 -> p A (phi1 --> phi2)) ->
       (forall  (A : list (form frag)) (phi1 phi2 : form frag),
        A ⊢I (phi1 --> phi2) -> p A (phi1 --> phi2) -> A ⊢I phi1 -> p A phi1 -> p A phi2) ->
       (forall  (A : list (form frag)) (x y : nat) (phi : form frag),
        fresh y (consts phi ++ consts_l A) ->
        A ⊢I subst x (P y) phi -> p A (subst x (P y) phi) -> p A (∀ x; phi)) ->
       (forall  (A : list (form frag)) (x : nat) (t : term) (phi : form frag),
           vars_t t = [] ->
        A ⊢I (∀ x; phi) -> p A (∀ x; phi) -> p A (subst x t phi)) ->
       forall (A : list (form frag)) (f9 : form frag), A ⊢I f9 -> p A f9.

Definition cast {domain} (eta eta' : nat -> domain) (I : interp eta) : interp eta'.

Lemma eval_ext_p t dom rho rho' eta eta' (I : interp dom eta) :
  (forall v, v el vars_t t -> rho v = rho' v) ->
  (forall p, p el consts_t t -> eta p = eta' p) ->
  @eval _ _ I rho t = @eval _ _ (cast eta' I) rho' t.

Lemma eval_ext t dom rho rho' eta (I : interp dom eta) :
  (forall v, v el vars_t t -> rho v = rho' v) -> eval rho t = eval rho' t.

Lemma sat_ext_p b (phi : form b) dom rho rho' eta eta' (I : interp dom eta) :
  (forall v, rho v = rho' v) ->
  (forall p, p el consts phi -> eta p = eta' p) ->
  sat I rho phi <-> sat (cast eta' I) rho' phi.

Lemma sat_ext b (phi : form b) dom rho rho' eta (I : interp dom eta) :
  sat I rho phi -> (forall v, rho v = rho' v) -> sat I rho' phi.

Lemma sat_ext_p_list b (A : list (form b)) dom rho rho' eta eta' (I : interp dom eta) :
  (forall v, rho v = rho' v) ->
  (forall p, p el consts_l A -> eta p = eta' p) ->
  (forall phi, phi el A -> sat I rho phi) <-> (forall phi, phi el A -> sat (cast eta' I) rho' phi).

Lemma eval_empty t dom eta (I : interp dom eta) rho rho' :
  vars_t t = [] -> eval rho t = eval rho' t.

Lemma subst_eval dom eta (I : interp dom eta) rho x t t' :
  eval rho (subst_t x t' t) = eval (rho [[x:=eval rho t']]) t.

Lemma subst_sat b (phi : form b) dom eta (I : interp dom eta) rho x t :
  vars_t t = [] -> sat I rho (subst x t phi) <-> sat I (rho [[x:=eval rho t]]) phi.

Lemma substconst_sat b (phi : form b) dom eta rho x a d (I : interp dom eta) :
  fresh a (consts phi) ->
  sat (eta [[a := d]]) (cast _ I) rho (subst x (P a) phi) <->
  sat eta I (rho [[ x := d ]]) phi.

Lemma soundness' {b} A (phi : form b) :
  A ⊢I phi -> valid (A ==> phi).

Theorem soundness {b} (phi : form b) :
  nil ⊢I phi -> valid phi.

Fixpoint size {b} (phi : form b) :=
  match phi with
  | Pr _ _ | Q | Fal => 1
  | Impl phi1 phi2 => 1 + size phi1 + size phi2
  | All n phi => 1 + size phi
  end.

Lemma size_subst {b : logic} x t phi :
  size (subst x t phi) = size phi.

Lemma form_ind_subst :
forall P : forall f : logic, form f -> Prop,
(forall (b : logic) (t t0 : term), P b (Pr t t0)) ->
(forall b : logic, P b Q) ->
P full ⊥ ->
(forall (b : logic) (f2 : form b), P b f2 -> forall f3 : form b, P b f3 -> P b (f2 --> f3)) ->
(forall (b : logic) (n : var) (f4 : form b), (forall x, P b (subst n x f4)) -> P b (∀ n; f4)) -> forall (f5 : logic) (f6 : form f5), P f5 f6.

Lemma form_logic_ind_subst :
forall P : form frag -> Prop,
(forall t t0 : term, P (Pr t t0)) ->
P Q ->
(forall f3 : form frag, P f3 -> forall f4 : form frag, P f4 -> P (f3 --> f4)) ->
(forall (n : var) (f6 : form frag), (forall x, P (subst n x f6)) -> P (∀ n; f6)) -> forall f8 : form frag, P f8.

Lemma dec_fresh y A : dec (fresh y A).

Lemma incl_dec X (A B : list X) `{eq_dec X} : dec (A <<= B).

Fixpoint L_ded {b} {s : nd} (A : list (form b)) (n : nat) : list (form b) :=
  match n with
  | 0 => A
  | S n => L_ded A n
                ++ concat [ [ phi1 --> phi2 | phi2 ∈ L_ded (phi1 :: A) n ] | phi1 ∈ L_T (form b) n]
                ++ [ phi2 | (phi1,phi2) ∈ (L_ded A n × L_T (form b) n) , (phi1 --> phi2 el L_ded A n) ]
                ++ [ ∀ x; phi | (phi, x, y) ∈ (L_T (form b) n × L_T var n × L_T var n) ,
                               fresh y (consts phi ++ consts_l A) /\ subst x (P y) phi el L_ded A n ]
                ++ [ subst x t phi | (phi, x, t) ∈ (L_T (form b) n × L_T var n × L_T term n),
                                    vars_t t = [] /\ ∀ x; phi el L_ded A n]
                ++ match b with frag => fun _ => [] | full => fun A =>
                 match s with
                   | intu => [ phi | phi ∈ L_T (form full) n, Fal el L_ded A n ]
                   | class => [ phi | phi ∈ L_T (form full) n, (¬¬ phi) el L_ded A n ]
                   end end A
  end.

Opaque in_dec.
Opaque enumT_nat.

Hint Constructors prv.

Lemma enum_prv b s A : enum (@prv s b A) (L_ded A).

Lemma enumerable_min_prv : enumerable (prv_min []).
Lemma enumerable_intu_prv : enumerable (prv_intu []).
Lemma enumerable_class_prv : enumerable (prv_class []). *)



Fixpoint ren_t (rho : nat -> nat) t :=

  match t with

  | V n => V n

  | P p => P (rho p)           

  | t_f b t => t_f b (ren_t rho t)

  | t_e => t_e

  end.



Fixpoint ren {b : logic} (rho : nat -> nat) phi :=

  match phi with

  | Pr s t => Pr (ren_t rho s) (ren_t rho t)

  | Q => Q

  | Fal => Fal

  | Impl phi1 phi2 => Impl (ren rho phi1) (ren rho phi2)

  | All x phi => All x (ren rho phi)

  end.



Lemma vars_t_ren rho t :

  vars_t (ren_t rho t) = vars_t t.

Proof.

  induction t; cbn; congruence.

Qed.



Definition singles (y z x : nat) := if Dec (x = y) then z else x.

Notation "x :-> y" := (singles x y) (at level 20).



Definition ren_ctx {b : logic} f := map (ren f).



Definition fun_comp {X Y Z} (f : Y -> Z) (g : X -> Y) x := f (g x).

Notation "f ∘ g" := (fun_comp f g) (at level 20).



Arguments fun_comp : simpl nomatch.



Lemma ren_id_t t :

  ren_t (fun x => x) t = t.

Proof.

  induction t; cbn; try congruence.

Qed.



Lemma ren_id {b : logic} t :

  ren (fun x => x) t = t.

Proof.

  induction t; cbn; try congruence.

  now rewrite !ren_id_t.

Qed.



Lemma ren_ctx_id {b : logic} A :

  ren_ctx (fun x => x) A = A.

Proof.

  induction A; cbn; trivial. now rewrite IHA, ren_id.

Qed.



Lemma ren_comp_t rho1 rho2 t :

  ren_t rho1 (ren_t rho2 t) = ren_t (rho1 ∘ rho2) t.

Proof.

  induction t; cbn; now try congruence.

Qed.



Lemma ren_comp {b : logic} rho1 rho2 phi :

  ren rho1 (ren rho2 phi) = ren (rho1 ∘ rho2) phi.

Proof.

  induction phi; cbn; try congruence.

  now rewrite !ren_comp_t.

Qed.



Lemma ren_comp_ctx {b : logic}  rho1 rho2 A :

  ren_ctx rho1 (ren_ctx rho2 A) = ren_ctx (rho1 ∘ rho2) A.

Proof.

  induction A; cbn; try rewrite ren_comp; congruence.

Qed.



Lemma ren_ext_t t rho1 rho2 :

  (forall p, p el consts_t t -> rho1 p = rho2 p) ->

  ren_t rho1 t = ren_t rho2 t.

Proof.

  intros; induction t; cbn in *; try congruence.

  - rewrite H; eauto.

  - rewrite IHt; eauto.

Qed.



Lemma ren_ext {b : logic} phi rho1 rho2 :

  (forall p, p el consts phi -> rho1 p = rho2 p) ->

  ren rho1 phi = ren rho2 phi.

Proof.

  intros; induction phi; cbn in *; try congruence.

  - f_equal; erewrite ren_ext_t; eauto.

  - rewrite IHphi1, IHphi2; eauto.

  - rewrite IHphi; eauto.

Qed.



Lemma ren_ext_ctx {b : logic} B rho1 rho2 :

  (forall p, p el consts_l B -> rho1 p = rho2 p) ->

  ren_ctx rho1 B = ren_ctx rho2 B.

Proof.

  intros. eapply map_ext_in; intros. eapply ren_ext.

  intros. eapply H. eapply in_flat_map. eauto.

Qed.



Lemma ren_subst_t {b : logic} rho x t s :

  ren_t rho (subst_t x t s) = subst_t x (ren_t rho t) (ren_t rho s).

Proof.

  intros. induction s; cbn in *; try congruence.

  - dec; cbn.

    + reflexivity.

    + firstorder.

Qed.



Lemma ren_subst {b : logic} rho x t phi : vars_t t = [] ->

  ren rho (subst x t phi) = subst x (ren_t rho t) (ren rho phi).

Proof.

  intros H. induction phi; cbn; intros; try congruence.

  - erewrite <- !ren_subst_t. reflexivity. all:eauto.

  - f_equal. decs.

Qed.



Lemma ren_swap_ctx {b : logic} x y rho B : fresh x (consts_l B) ->

  ren_ctx (rho[[x := rho y]] ∘ (y :-> x)) B = ren_ctx rho B.

Proof.

  intros. eapply ren_ext_ctx. intros.

  unfold singles, update, fun_comp. decs. 

Qed.



Theorem gen_weakening {s : nd} {b : logic} A phi : 

  A ⊢ phi -> forall rho B, A <<= B -> ren_ctx rho B ⊢ ren rho phi.

Proof.

  induction 1; cbn in *; intros.

  - eapply Ctx. eapply in_map_iff. eauto.

  - eapply ImpI. eapply (IHprv rho (phi1 :: B)); eauto. 

  - eapply ImpE; eauto.

  - destruct (make_fresh (rho y :: y :: x :: consts phi ++ consts_l B ++ consts (ren rho phi) ++ consts_l (ren_ctx rho B))) as [z Hz].

    eapply AllI with (y0 := z). intros [] % in_app_iff; eapply Hz; eauto 10.

    rewrite <- ren_swap_ctx with (x0 := z) (y0 := y). 2: intros ?; eapply Hz; eauto 10.

    pose ( B0 := ren_ctx (y :-> z) B).

    pose (rho0 := rho[[z := rho y]][[y := z]]).

    assert (ren_ctx ((rho [[z := rho y]]) ∘ (y :-> z)) B = ren_ctx rho0 B0) as ->. {

     unfold rho0, B0.  rewrite ren_comp_ctx. eapply ren_ext_ctx. unfold update, singles, fun_comp. intros ?. decs. all:firstorder.

    }

    assert (subst x (P z) (ren rho phi) = ren rho0 (subst x (P y) phi)) as ->. {

      rewrite ren_subst. 2: now cbn. unfold rho0. cbn.

      unfold update at 1. dec; try tauto; subst.

      f_equal. eapply ren_ext; eauto. intros ? ?. decs. destruct H. firstorder. destruct Hz. firstorder.

    }

    eapply IHprv.

    intros ? ?. eapply in_map_iff. exists a. split; eauto.

    rewrite <- ren_id. eapply ren_ext. intros. unfold singles; decs.

    destruct H. eapply in_app_iff. right. eapply in_flat_map. eauto.

  - rewrite ren_subst. eapply AllE; eauto. 2:eauto. now rewrite vars_t_ren.

  - eapply Exp; eauto.

  - eapply DN; eauto.

Qed.



Corollary Weak {s : nd} {b : logic} A B phi :

  A ⊢ phi -> A <<= B -> B ⊢ phi.

Proof.

  intros H1 H2. specialize (gen_weakening H1 (fun n => n) H2).

  now rewrite ren_id, ren_ctx_id.

Qed.



Lemma ND_CND A (phi : form frag) :

  A ⊢M phi -> A ⊢C phi.

Proof.

  induction 1; eauto.

  eapply DN. eapply ImpI. eapply Weak; eauto.

Qed.

