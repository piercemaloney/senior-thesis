
Require Import List Arith Omega.

Require Import ILL.Definitions.
(* ILL.Definitions:
Require Export Problems.PCP Problems.Reduction. *)

Require Import ill eill. 
(* ill:
Require Import List Permutation Arith Omega.

Require Import utils pos vec.

Set Implicit Arguments.

Local Infix "~p" := (@Permutation _) (at level 70).

Definition ll_vars := nat.

Inductive ll_conn := ll_with | ll_limp | ll_times | ll_plus.
Inductive ll_cst := ll_one | ll_bot | ll_top.

Inductive ll_form : Set :=
  | ll_var  : ll_vars -> ll_form
  | ll_zero : ll_cst  -> ll_form
  | ll_ban  : ll_form -> ll_form
  | ll_bin  : ll_conn -> ll_form -> ll_form -> ll_form.

Notation "âŸ™" := (ll_zero ll_top).
Notation "âŸ˜" := (ll_zero ll_bot).
Notation ğ := (ll_zero ll_one).

Infix "&" := (ll_bin ll_with) (at level 50, only parsing).
Infix "ï¹ " := (ll_bin ll_with) (at level 50).
Infix "âŠ—" := (ll_bin ll_times) (at level 50).
Infix "âŠ•" := (ll_bin ll_plus) (at level 50).
Infix "-o" := (ll_bin ll_limp) (at level 51, only parsing, right associativity).
Infix "âŠ¸" := (ll_bin ll_limp) (at level 51, right associativity).

Notation "'!' x" := (ll_ban x) (at level 52, only parsing).
Notation "â— x" := (ll_ban x) (at level 52).

Notation "Â£" := ll_var.

Definition ll_lbang := map (fun x => !x).

Notation "'!l' x" := (ll_lbang x) (at level 60, only parsing).
Notation "â€¼ x" := (ll_lbang x) (at level 60).

Notation "âˆ…" := nil (only parsing).

Reserved Notation "l 'âŠ¢' x" (at level 70, no associativity).

Inductive S_ill : list ll_form -> ll_form -> Prop :=

  | in_llp_ax     : forall A,                         A::âˆ… âŠ¢ A

  | in_llp_perm   : forall Î“ Î” A,              Î“ ~p Î”     ->   Î“ âŠ¢ A 
                                           
                                      ->                 Î” âŠ¢ A

  | in_llp_limp_l : forall Î“ Î” A B C,          Î“ âŠ¢ A      ->   B::Î” âŠ¢ C
                                               
                                      ->           A âŠ¸ B::Î“++Î” âŠ¢ C

  | in_llp_limp_r : forall Î“ A B,                    A::Î“ âŠ¢ B
                                           
                                      ->            Î“ âŠ¢ A âŠ¸ B

  | in_llp_with_l1 : forall Î“ A B C,                  A::Î“ âŠ¢ C 
                                           
                                      ->           Aï¹ B::Î“ âŠ¢ C

  | in_llp_with_l2 : forall Î“ A B C,                  B::Î“ âŠ¢ C 
                                           
                                      ->           Aï¹ B::Î“ âŠ¢ C
 
  | in_llp_with_r : forall Î“ A B,               Î“ âŠ¢ A     ->   Î“ âŠ¢ B
                                           
                                      ->              Î“ âŠ¢ Aï¹ B

  | in_llp_bang_l : forall Î“ A B,                    A::Î“ âŠ¢ B
                                           
                                      ->            â— A::Î“ âŠ¢ B

  | in_llp_bang_r : forall Î“ A,                       â€¼Î“ âŠ¢ A
                                           
                                      ->              â€¼Î“ âŠ¢ â— A

  | in_llp_weak : forall Î“ A B,                        Î“ âŠ¢ B
                                           
                                      ->           â— A::Î“ âŠ¢ B

  | in_llp_cntr : forall Î“ A B,                    â— A::â— A::Î“ âŠ¢ B
                                           
                                      ->             â— A::Î“ âŠ¢ B

  | in_llp_cut : forall Î“ Î” A B,                 Î“ âŠ¢ A    ->   A::Î” âŠ¢ B
                                               
                                      ->              Î“++Î” âŠ¢ B

  | in_llp_times_l : forall Î“ A B C,               A::B::Î“ âŠ¢ C 
                                           
                                      ->            AâŠ—B::Î“ âŠ¢ C
 
  | in_llp_times_r : forall Î“ Î” A B,             Î“ âŠ¢ A    ->   Î” âŠ¢ B
                                           
                                      ->              Î“++Î” âŠ¢ AâŠ—B

  | in_llp_plus_l :  forall Î“ A B C,            A::Î“ âŠ¢ C  ->  B::Î“ âŠ¢ C 
                                           
                                      ->            AâŠ•B::Î“ âŠ¢ C

  | in_llp_plus_r1 : forall Î“ A B,                    Î“ âŠ¢ A  
                                           
                                      ->              Î“ âŠ¢ AâŠ•B

  | in_llp_plus_r2 : forall Î“ A B,                    Î“ âŠ¢ B  
                                           
                                      ->              Î“ âŠ¢ AâŠ•B

  | in_llp_bot_l : forall Î“ A,                     âŸ˜::Î“ âŠ¢ A

  | in_llp_top_r : forall Î“,                          Î“ âŠ¢ âŸ™

  | in_llp_unit_l : forall Î“ A,                       Î“ âŠ¢ A  
                                           
                                      ->           ğ ::Î“ âŠ¢ A

  | in_llp_unit_r :                                   âˆ… âŠ¢ ğ

where "l âŠ¢ x" := (S_ill l x).

Definition ILL_PROVABILITY (c : (list ll_form) * ll_form) := let (Ga,A) := c in Ga âŠ¢ A. 

Fact S_ill_weak Î“ Î” B : Î” âŠ¢ B -> â€¼Î“++Î” âŠ¢ B.

Fact S_ill_cntr Î“ Î” B : â€¼Î“++â€¼Î“++Î” âŠ¢ B -> â€¼Î“++ Î” âŠ¢ B.

Theorem S_ill_weak_cntr Î£ Î“ A B : In A Î£ -> â€¼Î£++Î“ âŠ¢ B <-> â— A::â€¼Î£++Î“ âŠ¢ B.

Section trivial_phase_semantics.

  Variables (n : nat) (s : ll_vars -> vec nat n -> Prop).

  Reserved Notation "'âŸ¦' A 'âŸ§'" (at level 65).

  Definition ll_tps_imp (X Y : _ -> Prop) (v : vec _ n) := forall x, X x -> Y (vec_plus x v).
  Definition ll_tps_mult (X Y : _ -> Prop) (x : vec _ n) := exists a b, x = vec_plus a b /\ X a /\ Y b. 
  
  Infix "**" := (ll_tps_mult) (at level 65, right associativity).
  Infix "-*" := (ll_tps_imp) (at level 65, right associativity).

  Fact ll_tps_mult_mono (X1 X2 Y1 Y2 : _ -> Prop) : 
             (forall x, X1 x -> X2 x)
          -> (forall x, Y1 x -> Y2 x)
          -> (forall x, (X1**Y1) x -> (X2**Y2) x).

  Fixpoint ll_tps A x : Prop :=
    match A with
      | Â£ X     => s X x
      | A ï¹  B  => âŸ¦AâŸ§ x /\ âŸ¦BâŸ§ x
      | â— A     => âŸ¦AâŸ§ x /\ x = vec_zero
      | A âŠ¸ B  => (âŸ¦AâŸ§ -* âŸ¦BâŸ§) x
      | A âŠ— B  => (âŸ¦AâŸ§ ** âŸ¦BâŸ§) x
      | A âŠ• B  => âŸ¦AâŸ§ x \/ âŸ¦BâŸ§ x
      | âŸ˜             => False
      | âŸ™             => True
      | ğ              => x = vec_zero
    end
  where "âŸ¦ A âŸ§" := (ll_tps A).

  Reserved Notation "'[[' Î“ ']]'" (at level 0).

  Fixpoint ll_tps_list Î“ :=
    match Î“ with
      | âˆ…    => eq vec_zero
      | A::Î“ => âŸ¦AâŸ§ ** [[Î“]]
    end
  where "[[ Î“ ]]" := (ll_tps_list Î“).

  Fact ll_tps_app Î“ Î” x : [[Î“++Î”]] x <-> ([[Î“]]**[[Î”]]) x.

  Fact ll_tps_lbang Î“ x : [[â€¼Î“]] x <-> [[Î“]] x /\ x = vec_zero.

  Fact ll_tps_list_bang_zero Î“ : [[â€¼Î“]] vec_zero <-> forall A, In A Î“ -> âŸ¦AâŸ§ vec_zero.

  Fact ll_tps_perm Î“ Î” : Î“ ~p Î” -> forall x, [[Î“]] x -> [[Î”]] x.
  
  Definition ll_sequent_tps Î“ A := [[Î“]] -* âŸ¦AâŸ§.

  Notation "'[<' Î“ '|-' A '>]'" := (ll_sequent_tps Î“ A).

  Fact ll_sequent_tps_mono Î“ A B :
     (forall x, âŸ¦AâŸ§ x -> âŸ¦BâŸ§ x) -> forall x, [< Î“ |- A >] x -> [< Î“ |- B >] x.

  Fact ll_perm_tps Î“ Î” : Î“ ~p Î” -> forall x A, [< Î“ |- A >] x -> [< Î” |- A >] x.

  Fact ll_sequent_tps_eq  Î“ A : [< Î“ |- A >] vec_zero <-> forall x, [[Î“]] x -> âŸ¦AâŸ§ x.

  Theorem ll_tps_sound Î“ A : Î“ âŠ¢ A -> [< Î“ |- A >] vec_zero.

End trivial_phase_semantics. *)
(* eill:
Require Import List Permutation Arith Omega.

Require Import utils pos vec ill.

Set Implicit Arguments.

Local Infix "~p" := (@Permutation _) (at level 70).

Definition ll_vars := nat.

Inductive eill_cmd : Set :=
  | in_ll_cmd_inc  : ll_vars -> ll_vars -> ll_vars -> eill_cmd
  | in_ll_cmd_dec  : ll_vars -> ll_vars -> ll_vars -> eill_cmd
  | in_ll_cmd_fork : ll_vars -> ll_vars -> ll_vars -> eill_cmd.

Notation LL_INC  := in_ll_cmd_inc.
Notation LL_DEC  := in_ll_cmd_dec.
Notation LL_FORK := in_ll_cmd_fork.

Definition eill_cmd_vars c := 
  match c with
    | LL_INC  a p q => a::p::q::nil
    | LL_DEC  a p q => a::p::q::nil
    | LL_FORK p q r => p::q::r::nil
  end.

Definition eill_cmd_map c :=
  match c with
    | LL_INC  a p q => (Â£a âŠ¸ Â£p) -o Â£ q
    | LL_DEC  a p q => Â£a âŠ¸ Â£p -o Â£ q
    | LL_FORK p q r => (Â£p ï¹  Â£q) -o Â£ r
  end. 

Notation "'[i' c ']'" := (eill_cmd_map c) (at level 0).

Reserved Notation "Si ; Ga 'âŠ¦' x" (at level 70, no associativity).

Inductive G_eill (Î£ : list eill_cmd) : list ll_vars -> ll_vars -> Prop :=
  | in_eill_ax  : forall u,                                    Î£; u::âˆ… âŠ¦ u
  | in_eill_perm : forall Î“ Î” p,    Î“ ~p Î”                 ->  Î£; Î“     âŠ¦ p
                                                           ->  Î£; Î”     âŠ¦ p
  | in_eill_inc : forall Î“ a p q,   In (LL_INC a p q) Î£    ->  Î£; a::Î“  âŠ¦ p
                                                           ->  Î£; Î“     âŠ¦ q
  | in_eill_dec : forall Î“ Î” p q r, In (LL_DEC p q r) Î£    ->  Î£; Î“     âŠ¦ p
                                                           ->  Î£; Î”     âŠ¦ q
                                                           ->  Î£; Î“++Î”  âŠ¦ r
  | in_eill_fork : forall Î“ p q r,  In (LL_FORK p q r) Î£   ->  Î£; Î“     âŠ¦ p
                                                           ->  Î£; Î“     âŠ¦ q
                                                           ->  Î£; Î“     âŠ¦ r
where "Si ; Ga âŠ¦ u" := (G_eill Si Ga u).

Definition EILL_SEQUENT := (list eill_cmd * list ll_vars * ll_vars)%type.

Definition EILL_PROVABILITY (c : EILL_SEQUENT) := match c with (Î£,Î“,A) => Î£; Î“ âŠ¦ A end. 

Theorem g_eill_mono_Si Î£ Î£' Î“ u : incl Î£ Î£' -> Î£; Î“ âŠ¦ u -> Î£'; Î“ âŠ¦ u.

Theorem G_eill_sound Î£ Î“ p : Î£; Î“ âŠ¦ p -> map (fun c => ![i c]) Î£ ++ map Â£ Î“ âŠ¢ Â£ p.

Section TPS.

  Variables (n : nat) (s : ll_vars -> vec nat n -> Prop) (rx : pos n -> ll_vars).

  Fact ll_tps_vec_map_list_mono : 
       (forall (p : pos n), s (rx p) (vec_one p)) 
     -> forall v, ll_tps_list s (map Â£ (vec_map_list v rx)) v.

  Fact ll_tps_vec_map_list : 
       (forall (p : pos n) (v : vec nat n), s (rx p) v <-> v = vec_one p) 
     -> forall v w, ll_tps_list s (map Â£ (vec_map_list v rx)) w <-> v = w.

End TPS.

Section g_eill_complete_bound.
 
  Variable (Si : list eill_cmd) (Ga : list ll_vars) (n : nat).

  Notation vars := (flat_map eill_cmd_vars Si ++ Ga).

  Hypothesis (w : vec ll_vars n)
             (w_surj : forall u, In u vars -> exists p, u = vec_pos w p).

  Let rx p := vec_pos w p.

  Let Hrx l : incl l (flat_map eill_cmd_vars Si ++ Ga) -> exists v, l ~p vec_map_list v rx.

  Let s x v := Si; vec_map_list v rx âŠ¦ x.

  Notation "âŸ¦ A âŸ§" := (ll_tps s A) (at level 65).
  Notation "'[<' Î“ '|-' A '>]'" := (ll_sequent_tps s Î“ A) (at level 65).

  Theorem G_eill_complete_bound x : [< map (fun c => â—[i c]) Si ++ map Â£ Ga |- Â£ x >] vec_zero ->
                              Si; Ga âŠ¦ x.

End g_eill_complete_bound.

Section g_eill_complete.
 
  Variable (Si : list eill_cmd) (Ga : list ll_vars).

  Notation vars := (flat_map eill_cmd_vars Si ++ Ga).

  Let vv := nat_sort vars.

  Let Hvv1 : list_injective vv.

  Let Hvv2 : incl vv (flat_map eill_cmd_vars Si ++ Ga) 
          /\ incl (flat_map eill_cmd_vars Si ++ Ga) vv.

  Let n := length vv.
  Let w : vec ll_vars n := proj1_sig (list_vec vv).
  Let Hw : vec_list w = vv.

  Let w_surj : forall u, In u vars -> exists p, u = vec_pos w p.

  Variables (x : ll_vars)
            (Hvalid : forall n s, @ll_sequent_tps n s (map (fun c : eill_cmd => â— [ic]) Si ++ map Â£ Ga) (Â£ x) vec_zero).

  Theorem G_eill_complete : Si; Ga âŠ¦ x.

End g_eill_complete.

Theorem G_eill_correct Si Ga p : 
           Si; Ga âŠ¦ p <-> map (fun c => ![i c]) Si ++ map Â£ Ga âŠ¢ Â£ p. *)

Section EILL_ILL.

  Theorem EILL_ILL_PROVABILITY : EILL_PROVABILITY âª¯ ILL_PROVABILITY.
  Proof.
    exists (fun p => match p with (Si,Ga,p) => (map (fun c => ![i c]) Si ++ map Â£ Ga,Â£ p) end).
    intros ((Si,Ga),p); apply G_eill_correct.
  Qed.

End EILL_ILL.
