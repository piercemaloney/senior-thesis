
Require Import Kripke FOL.BPCP_FOL.
(* Kripke:
Require Export FOL.Deduction.

Section Kripke.

  Context {domain : Type}.
  Variable eta : nat -> domain.

  Structure embedding (I J : interp domain eta) :=
    {
      Hf : forall b d, @i_f _ _ I b d = @i_f _ _ J b d ;
      He : @i_e _ _ I = @i_e _ _ J ;

      HP : forall c d, @i_P _ _ I c d -> @i_P _ _ J c d ;
      HQ : @i_Q _ _ I -> @i_Q _ _ J 
    }.

  Lemma emb_refl (I : interp domain eta) :
    embedding I I.
      
  Definition emb_trans (I J K : interp domain eta) :
    embedding I J -> embedding J K -> embedding I K.
      
  Class kmodel :=
    {
      nodes : Type ;

      reachable : nodes -> nodes -> Prop ;
      reach_refl u : reachable u u ;
      reach_tran u v w : reachable u v -> reachable v w -> reachable u w ;

      world : nodes -> interp domain eta ;

      world_f : forall u v, reachable u v -> embedding (world u) (world v)
    }.

  Variable M : kmodel.
  Implicit Type b : logic.

  Fixpoint ksat b u (rho : var -> domain) (phi : form b) : Prop :=
    match phi with
    | Pr t1 t2 => @i_P _ _ (world u) (@eval _ _ (world u) rho t1) (@eval _ _ (world u) rho t2)
    | Q => @i_Q _ _ (world u)
    | Fal => False
    | Impl phi psi => forall v, reachable u v -> ksat v rho phi -> ksat v rho psi
    | All n phi => forall v, reachable u v -> forall j : domain, ksat v (rho [[ n := j ]]) phi
    end.

  Global Arguments ksat {_} _ _ _.
  
  Notation "rho  '⊨(' u ')'  phi" := (ksat u rho phi) (at level 20).
  Notation "rho  '⊫(' u ')'  A" := (forall phi, phi el A -> rho ⊨(u) phi) (at level 20).

  Lemma eval_invar u v :
    reachable u v -> forall rho t, @eval _ _ (world u) rho t = @eval _ _ (world v)rho t.
  
  Lemma ksat_mon b (u : nodes) (rho : var -> domain) (phi : form b) :
    forall v (H : reachable u v), ksat u rho phi -> ksat v rho phi.
  
  Lemma ksat_iff b u rho phi :
    ksat u rho phi <-> forall v (H : reachable u v), ksat v rho phi.

  Notation sem_imp v rho A phi :=
    ((forall psi, psi el A -> ksat v rho psi) -> ksat v rho phi).

  Lemma impl_ksat {b} u A rho (phi : form b) :
    ksat u rho (A ==> phi) <-> (forall v, reachable u v -> sem_imp v rho A phi).

  Lemma impl_ksat' {b} u A rho (phi : form b) :
    ksat u rho (A ==> phi) -> (forall v, reachable u v -> sem_imp v rho A phi).

Lemma kripke_tarski domain eta (b : logic) (I : interp domain eta) rho phi :
  rho ⊨ phi <-> rho ⊩(tt, interp_kripke I, _) phi.

Definition kvalid b (phi : form b) :=
  forall domain eta (M : @kmodel domain eta) u rho, rho ⊩(u,M,eta) phi.

Definition ksatis b (phi : form b) :=
  exists domain eta (M : @kmodel domain eta) u rho, ksat eta M u rho phi.

Lemma kvalid_valid b (phi : form b) :
  kvalid phi -> valid phi.

Lemma ksatis_satis b (phi : form b) :
  satis phi -> ksatis phi.

Hint Resolve reach_refl.

Definition kcast domain (eta eta' : nat -> domain) (M : kmodel eta) : kmodel eta'.

Notation "! M" := (kcast _ M) (at level 10).

Lemma ksat_ext_p dom b (phi : form b) rho rho' eta eta' (M : @kmodel dom eta ) u :
  (forall v, rho v = rho' v) ->
  (forall p, p el consts phi -> eta p = eta' p) ->
  rho ⊩(u,M,eta) phi <->
  rho' ⊩(u, !M, eta') phi.
  
Lemma ksat_ext dom b (phi : form b) rho rho' eta (M : @kmodel dom eta ) u :
  rho ⊩(u,M,eta) phi -> (forall v, rho v = rho' v) ->  rho' ⊩(u,M,eta) phi.

Lemma subst_ksat dom b eta rho (M : @kmodel dom eta ) u (phi : form b) x t :
  vars_t t = [] ->
  rho ⊩(u,M,eta) (subst x t phi) <-> rho[[x:=eval (I:=world u) rho t]] ⊩(u,M,eta) phi.

Lemma substconst_ksat b dom eta rho (phi : form b) x a d (M : @kmodel dom eta) u :
  fresh a (consts phi) ->
  rho ⊩(u, kcast (eta [[a := d]]) M, _) (subst x (P a) phi) <-> 
  rho [[ x := d ]] ⊩(u,M,eta) phi.

Lemma ksoundness' {b} A (phi : form b) :
  A ⊢I phi -> kvalid (A ==> phi).

Theorem ksoundness {b} (phi : form b) :
  [] ⊢I phi -> valid phi. *)
(* FOL.BPCP_FOL:
Require Export FOL.PCP Deduction.

Section validity.

  Notation u := 0. Notation v := 1.
  Context {b : logic}.
  Variable R : BSRS.

  Definition prep (x : string bool) (t : term) : term := fold_right t_f t x.
  Definition iprep domain eta {I : interp domain eta} (x : list bool) (y : domain) := fold_right i_f y x.
  Definition enc s := (prep s t_e).

  Definition F1 := map (fun '(x,y) => Pr (enc x) (enc y)) R.
  Definition F2 := map (fun '(x, y) => ∀ u; ∀ v; Pr u v --> Pr (prep x u) (prep y v)) R.
  Definition F3 := (∀ u; Pr u u --> Q).

  Definition F : form b := F1 ==> F2 ==> F3 --> Q.

  Lemma enc_vars x :
    vars_t (enc x) = [].

  Lemma prep_subst y t1 x t :
    subst_t y t1 (prep x t) = prep x (subst_t y t1 t).

  Lemma prep_vars x t :
    vars_t (prep x t) = vars_t t.

  Lemma iprep_eval domain eta (I : interp domain eta) rho x s :
    eval rho (prep x s) = iprep x (eval rho s).

  Lemma iprep_app domain eta (I : interp domain eta) x y d :
    iprep (x ++ y) d = iprep x (iprep y d).
  
  Global Instance IB : interp (string bool) (fun _ => []) :=
    {|
      i_f b s := b :: s ;
      i_e := nil;
      i_P u v := derivable R u v ;
      i_Q := BPCP' R
    |}.

  Lemma IB_prep rho s t :
    eval rho (prep s t) = s ++ eval rho t.

  Lemma IB_enc rho s :
    eval rho (enc s) = s.

  Lemma IB_drv rho t1 t2 :
    rho ⊨ (Pr t1 t2) <-> derivable R (eval rho t1) (eval rho t2).

  Lemma IB_F1 rho :
    rho ⊫ F1.

  Lemma IB_F2 rho :
    rho ⊫ F2.

  Lemma IB_F3 rho :
    rho ⊨ F3.

  Lemma IB_F rho :
    rho ⊨ F -> BPCP' R.

  Lemma drv_val domain eta (I : interp domain eta) rho u v :
    derivable R u v -> rho ⊨ (F1 ==> F2 ==> Pr (enc u) (enc v)).

  Theorem BPCP_valid :
    BPCP R <-> valid F.

  Hint Resolve enc_vars.

  Definition ctx_S :=
    F3 :: rev F2 ++ rev F1.

  Lemma drv_prv s u v :
    derivable R u v -> (@prv s b ctx_S (Pr (enc u) (enc v))).

  Lemma impl_prv s A B phi :
    @prv s b (rev B ++ A) phi -> @ prv s b A (B ==> phi).

  Lemma BPCP_prv' s :
    BPCP' R -> @prv s b nil F.

End validity.

Theorem BPCP_prv R :
  BPCP R <-> nil ⊢M (F R).

Lemma valid_satis phi :
  valid phi -> ~ satis (¬ phi).

Theorem BPCP_satis R :
  ~ BPCP R <-> satis (¬ F R).

Lemma form_discrete {b : logic} :
  discrete (form b).

Hint Resolve stack_enum form_discrete.

Definition UA :=
  ~ enumerable (compl BPCP).

Corollary valid_red :
  BPCP ⪯ @valid frag.

Corollary valid_undec :
  UA -> ~ decidable (@valid frag).

Corollary valid_unenum :
  UA -> ~ enumerable (compl (@valid frag)).

Corollary prv_red :
  BPCP ⪯ @prv intu frag nil.

Corollary prv_undec :
  UA -> ~ decidable (@prv intu frag nil).

Corollary prv_unenum :
  UA -> ~ enumerable (compl (@prv intu frag nil)).

Corollary satis_red :
  compl BPCP ⪯ @satis full.

Corollary satis_undec :
  UA -> ~ decidable (@satis full).

Corollary satis_enum :
  UA -> ~ enumerable (@satis full).

Module NonStan. Section Nonstan.

  Variable R : BSRS.

  Instance IB : interp (option (string bool)) (fun _ => Some nil) :=
    {|
      i_f b x := match x with Some u => Some (b :: u) | None => None end ;
      i_e := Some nil;
      i_P x y := match x, y with Some u, Some v => derivable R u v | _, _ => True end ;
      i_Q := False
    |}.

  Lemma IB_eval_Some rho t u v :
    eval rho t = Some v -> eval rho (prep u t) = Some (u ++ v).

  Lemma IB_eval_None rho t u :
    eval rho t = None -> eval rho (prep u t) = None.

  Lemma IB_enc rho u :
    eval rho (enc u) = Some u.

  Lemma IB_deriv rho u v :
    rho ⊨ (Pr (enc u) (enc v)) <-> derivable R u v.

  Lemma IB_deriv' rho t1 t2 u v :
    eval rho t1 = Some u -> eval rho t2 = Some v ->
    rho ⊨ (Pr t1 t2) <-> derivable R u v.

  Lemma IB_F1 rho :
    rho ⊫ F1 R.

  Lemma IB_F2 rho :
    rho ⊫ F2 R.

  Lemma IB_F rho :
    rho ⊨ F R.

  Lemma IB_nonstandard rho :
    rho ⊨ ¬ ∀ 0; ¬ Pr 0 0.

End Nonstan. End NonStan. *)

Section kvalidity.

  Variable R : BSRS.
  Context {b : logic}.
    
  Set Printing Implicit.

  Theorem BPCP_kprv :
    BPCP R <-> nil ⊢I (F R).
  Proof.
    rewrite BPCP_BPCP'. split.
    - apply BPCP_prv'.
    - intros H % ksoundness'. rewrite <- BPCP_BPCP'. now apply (BPCP_valid R), kvalid_valid.
  Qed.

  Theorem BPCP_kvalid :
    BPCP R <-> kvalid (F R).
  Proof.
    split.
    - now intros H % BPCP_kprv % ksoundness'.
    - intros H % kvalid_valid. now apply (BPCP_valid R).
  Qed.

End kvalidity.

Theorem BPCP_ksatis R :
  ~ BPCP R <-> ksatis (¬ F R).
Proof.
  split.
  - intros H % (BPCP_satis R). now apply ksatis_satis.
  - intros (D & eta & M & u & rho & H) H' % (BPCP_kvalid R (b:=full)).
    now apply (H u), (H' D eta M u).
Qed.

Corollary kvalid_red :
  BPCP ⪯ @kvalid full.
Proof.
  exists (fun R => F R). intros R. apply (BPCP_kvalid R).
Qed.

Corollary kvalid_undec :
  UA -> ~ decidable (@kvalid full).
Proof.
  intros H. now apply (not_decidable kvalid_red).
Qed.

Corollary kvalid_unenum :
  UA -> ~ enumerable (compl (@kvalid full)).
Proof.
  intros H. now apply (not_coenumerable kvalid_red).
Qed.

Corollary kprv_red :
  BPCP ⪯ @prv intu full nil.
Proof.
  exists (fun R => F R). intros R. apply (BPCP_kprv R).
Qed.

Corollary kprv_undec :
  UA -> ~ decidable (@prv intu full nil).
Proof.
  intros H. now apply (not_decidable kprv_red).
Qed.

Corollary kprv_unenum :
  UA -> ~ enumerable (compl (@prv intu full nil)).
Proof.
  intros H. apply (not_coenumerable kprv_red); trivial.
Qed.

Corollary ksatis_red :
  compl BPCP ⪯ @ksatis full.
Proof.
  exists (fun R => ¬ F R). intros R. apply (BPCP_ksatis R).
Qed.

Corollary ksatis_undec :
  UA -> ~ decidable (@ksatis full).
Proof.
  intros H1 H2 % (dec_red ksatis_red).
  now apply H1, dec_count_enum.
Qed.

Corollary ksatis_enum :
  UA -> ~ enumerable (@ksatis full).
Proof.
  intros H1 H2 % (enumerable_red ksatis_red); auto.
Qed.

