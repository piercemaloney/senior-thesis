

Require Import List Arith Omega.

Require Import utils_tac utils_list sums php.
(* utils_tac:
Require Import Arith List Wellfounded.

Set Implicit Arguments.

Definition eqdec X := forall x y : X, { x = y } + { x <> y }.

Definition swap {X Y} (c : X * Y) := let (x,y) := c in (y,x).

Theorem measure_rect X (m : X -> nat) (P : X -> Type) :
      (forall x, (forall y, m y < m x -> P y) -> P x) -> forall x, P x.

Tactic Notation "induction" "on" hyp(x) "as" ident(IH) "with" "measure" uconstr(f) :=
  pattern x; revert x; apply measure_rect with (m := fun x => f); intros x IH.

Tactic Notation "eq" "goal" hyp(H) := 
  match goal with 
    |- ?b => match type of H with ?t => replace b with t; auto end 
  end.

Ltac eqgoal := let H := fresh in intro H; eq goal H; clear H.

Tactic Notation "spec" "in" hyp(H) :=
  let Q := fresh 
  in match goal with G: ?h -> _ |- _ => 
       match G with 
         | H => assert (h) as Q; [ | specialize (H Q); clear Q ] 
       end 
     end.

Ltac solve_list_eq := simpl; repeat progress (try rewrite app_ass; try rewrite <- app_nil_end; simpl; auto); auto.

Tactic Notation "solve" "list" "eq" := solve_list_eq.

Tactic Notation "solve_list_eq" "in" hyp(H) := generalize H; clear H; solve_list_eq; intro H.

Tactic Notation "solve" "list" "eq" "in" hyp(H) := 
   let Q := fresh in 
   match goal with 
     |- ?t => set (Q := t); generalize H; clear H; solve_list_eq; intro H; unfold Q; clear Q
   end.

Ltac msplit n := 
  match n with 
    | 0    => idtac 
    | S ?n => split; [ | msplit n ]
   end.

Tactic Notation "define" ident(f) "of" hyp(n) hyp(m) "as" uconstr(t)  :=
  match type of n with ?N =>  
    match type of m with ?M  => pose (f (n:N) (m:M) := t) end end.

Tactic Notation "induction" "on" hyp(x) hyp(y) "as" ident(IH) "with" "measure" uconstr(f) :=
  generalize I; intro IH;
  let mes := fresh "measure" in let rel := fresh "relation" in let loop := fresh "loop" in
  let u := fresh "u" in let u' := fresh x in let Hu := fresh "Hu" in 
  let v := fresh "v" in let v' := fresh y in let Hv := fresh "Hv" 
  in clear IH; 
     define mes of x y as (f : nat);
     set (rel u v := mes (fst u) (snd u) < mes (fst v) (snd v)); unfold fst, snd in rel;
     pattern x, y; match goal with
       |- ?T _ _ => 
       refine ((fix loop u v (Hu : Acc rel (u,v)) { struct Hu } : T u v := _) x y _);
       [ assert (forall u' v', rel (u',v') (u,v) -> T u' v') as IH;
         [ intros u' v' Hv; apply (loop u' v'), (Acc_inv Hu), Hv 
         | unfold rel, mes in *; clear mes rel Hu loop x y; rename u into x; rename v into y ]
       | unfold rel; apply wf_inverse_image, lt_wf ]
     end.

Section forall_equiv.

  Variable (X : Type) (A P Q : X -> Prop) (HPQ : forall n, A n -> P n <-> Q n).

  Theorem forall_bound_equiv : (forall n, A n -> P n) <-> (forall n, A n -> Q n).

End forall_equiv.

Section exists_equiv.

  Variable (X : Type) (P Q : X -> Prop) (HPQ : forall n, P n <-> Q n).

  Theorem exists_equiv : (exists n, P n) <-> (exists n, Q n).

End exists_equiv. *)
(* utils_list:
Require Import List Arith Omega Permutation.

Require Import list_focus utils_tac.

Set Implicit Arguments.

Create HintDb length_db.

Tactic Notation "rew" "length" := autorewrite with length_db.
Tactic Notation "rew" "length" "in" hyp(H) := autorewrite with length_db in H.

Infix "~p" := (@Permutation _) (at level 70).

Section length.
   
  Variable X : Type.

  Implicit Type l : list X.

  Fact length_nil : length (@nil X) = 0.

  Fact length_cons x l : length (x::l) = S (length l).

End length.

Hint Rewrite length_nil length_cons app_length map_length rev_length : length_db.

Section list_an.

  Fixpoint list_an a n :=
    match n with 
      | 0   => nil
      | S n => a::list_an (S a) n
    end.

  Fact list_an_S a n : list_an a (S n) = a::list_an (S a) n.

  Fact list_an_plus a n m : list_an a (n+m) = list_an a n ++ list_an (n+a) m.

  Fact list_an_length a n : length (list_an a n) = n.
  
  Fact list_an_spec a n m : In m (list_an a n) <-> a <= m < a+n.

  Fact map_S_list_an a n : map S (list_an a n) = list_an (S a) n.

  Fact list_an_app_inv a n l r : list_an a n = l++r -> l = list_an a (length l) /\ r = list_an (a+length l) (length r).

End list_an.

Hint Rewrite list_an_length : length_db.

Definition list_fun_inv X (l : list X) (x : X) : { f : nat -> X | l = map f (list_an 0 (length l)) }.

Fact list_upper_bound (l : list nat) : { m | forall x, In x l -> x < m }.

Section list_injective.

  Variable X : Type.
   
  Definition list_injective (ll : list X) :=  forall l a m b r, ll = l ++ a :: m ++ b :: r -> a <> b.
  
  Fact in_list_injective_0 : list_injective nil.
  
  Fact in_list_injective_1 x ll : ~ In x ll -> list_injective ll -> list_injective (x::ll).
  
  Fact list_injective_inv x ll : list_injective (x::ll) -> ~ In x ll /\ list_injective ll.
  
  Variable P : list X -> Type.
  
  Hypothesis (HP0 : P nil).
  Hypothesis (HP1 : forall x l, ~ In x l -> P l -> P (x::l)).
  
  Theorem list_injective_rect l : list_injective l -> P l.

End list_injective.

Fact list_injective_map X Y (f : X -> Y) ll :
       (forall x y, f x = f y -> x = y) -> list_injective ll -> list_injective (map f ll).

Section iter.
  
  Variable (X : Type) (f : X -> X).

  Fixpoint iter x n :=
    match n with
      | 0   => x
      | S n => iter (f x) n
    end.

  Fact iter_plus x a b : iter x (a+b) = iter (iter x a) b.

  Fact iter_swap x n : iter (f x) n = f (iter x n).

End iter.

Fixpoint list_repeat X (x : X) n :=
  match n with
    | 0   => nil
    | S n => x::list_repeat x n
  end.
  
Fact list_repeat_plus X x a b : @list_repeat X x (a+b) = list_repeat x a ++ list_repeat x b.
  
Fact list_repeat_length X x n : length (@list_repeat X x n) = n.

Fact In_list_repeat X (x y : X) n : In y (list_repeat x n) -> x = y /\ 0 < n.

Fact map_list_repeat X Y f x n : @map X Y f (list_repeat x n) = list_repeat (f x) n.

Fact map_cst_repeat X Y (y : Y) ll : map (fun _ : X => y) ll = list_repeat y (length ll).
  
Fact map_cst_snoc X Y (y : Y) ll mm : y :: map (fun _ : X => y) ll++mm = map (fun _ => y) ll ++ y::mm.

Fact map_cst_rev  X Y (y : Y) ll : map (fun _ : X => y) (rev ll) = map (fun _ => y) ll.

Fact In_perm X (x : X) l : In x l -> exists m, x::m ~p l.

Fact list_app_eq_inv X (l1 l2 r1 r2 : list X) :
       l1++r1 = l2++r2 -> { m | l1++m = l2 /\ r1 = m++r2 } 
                        + { m | l2++m = l1 /\ r2 = m++r1 }.

Fact list_app_cons_eq_inv X (l1 l2 r1 r2 : list X) x :
       l1++r1 = l2++x::r2 -> { m | l1++m = l2 /\ r1 = m++x::r2 } 
                           + { m | l2++x::m = l1 /\ r2 = m++r1 }.

Fact list_cons_app_cons_eq_inv X (l2 r1 r2 : list X) x y :
       x::r1 = l2++y::r2 -> (l2 = nil /\ x = y /\ r1 = r2) 
                          + { m | l2 = x::m /\ r1 = m++y::r2 }.
 
Fact list_app_inj X (l1 l2 r1 r2 : list X) : length l1 = length l2 -> l1++r1 = l2++r2 -> l1 = l2 /\ r1 = r2.

Fact list_split_length X (ll : list X) k : k <= length ll -> { l : _ & { r | ll = l++r /\ length l = k } }.

Fact list_pick X (ll : list X) k : k < length ll -> { x : _ & { l : _ & { r | ll = l++x::r /\ length l = k } } }.

Fact list_split_middle X l1 (x1 : X) r1 l2 x2 r2 : 
       ~ In x1 l2 -> ~ In x2 l1 -> l1++x1::r1 = l2++x2::r2 -> l1 = l2 /\ x1 = x2 /\ r1 = r2.

Section flat_map.

  Variable (X Y : Type) (f : X -> list Y).

  Fact flat_map_app l1 l2 : flat_map f (l1++l2) = flat_map f l1 ++ flat_map f l2.

  Fact flat_map_app_inv l r1 y r2 : flat_map f l = r1++y::r2 -> exists l1 m1 x m2 l2, l = l1++x::l2 /\ f x = m1++y::m2 
                                                                  /\ r1 = flat_map f l1++m1 /\ r2 = m2++flat_map f l2. 

End flat_map.

Definition prefix X (l ll : list X) := exists r, ll = l++r.
  
Infix "<p" := (@prefix _) (at level 70, no associativity).
  
Section prefix. 
   
  Variable X : Type.
  
  Implicit Types (l ll : list X).
  
  Fact in_prefix_0 ll : nil <p ll.
  
  Fact in_prefix_1 x l ll : l <p ll -> x::l <p x::ll.

  Fact prefix_length l m : l <p m -> length l <= length m.
  
  Fact prefix_app_lft l r1 r2 : r1 <p r2 -> l++r1 <p l++r2.
  
  Fact prefix_inv x y l ll : x::l <p y::ll -> x = y /\ l <p ll.
  
  Fact prefix_list_inv l r rr : l++r <p l++rr -> r <p rr.

  Fact prefix_refl l : l <p l.

  Fact prefix_trans l1 l2 l3 : l1 <p l2 -> l2 <p l3 -> l1 <p l3.

  Section prefix_rect.

    Variables (P : list X -> list X -> Type)
              (HP0 : forall ll, P nil ll)
              (HP1 : forall x l ll, l <p ll -> P l ll -> P (x::l) (x::ll)).
              
    Definition prefix_rect l ll : prefix l ll -> P l ll.
   
  End prefix_rect.

  Fact prefix_app_inv l1 l2 r1 r2 : l1++l2 <p r1++r2 -> { l1 <p r1 } + { r1 <p l1 }.
  
End prefix.

Definition prefix_spec X (l ll : list X) : l <p ll -> { r | ll = l ++ r }.

Fact prefix_app_lft_inv X (l1 l2 m : list X) : l1++l2 <p m -> { m2 | m = l1++m2 /\ l2 <p m2 }.

Section list_assoc.

  Variables (X Y : Type) (eq_X_dec : eqdec X).

  Fixpoint list_assoc x l : option Y :=
    match l with 
      | nil  => None
      | (y,a)::l => if eq_X_dec x y then Some a else list_assoc x l
    end.

  Fact list_assoc_eq x y l x' : x = x' -> list_assoc x' ((x,y)::l) = Some y.

  Fact list_assoc_neq x y l x' : x <> x' -> list_assoc x' ((x,y)::l) = list_assoc x' l.

  Fact list_assoc_In x l : 
    match list_assoc x l with 
      | None   => ~ In x (map fst l)
      | Some y => In (x,y) l
    end.

  Fact In_list_assoc x l : In x (map fst l) -> { y | list_assoc x l = Some y /\ In (x,y) l }.
  
  Fact not_In_list_assoc x l : ~ In x (map fst l) -> list_assoc x l = None.

  Fact list_assoc_app x ll mm : list_assoc x (ll++mm) 
                              = match list_assoc x ll with
                                  | None   => list_assoc x mm
                                  | Some y => Some y
                                end.

End list_assoc.

Section list_first_dec.

  Variable (X : Type) (P : X -> Prop) (Pdec : forall x, { P x } + { ~ P x }).
  
  Theorem list_choose_dec ll : { l : _ & { x : _ & { r | ll = l++x::r /\ P x /\ forall y, In y l -> ~ P y } } }
                             + { forall x, In x ll -> ~ P x }.
  
  Theorem list_first_dec a ll : P a -> In a ll -> { l : _ & { x : _ & { r | ll = l++x::r /\ P x /\ forall y, In y l -> ~ P y } } }.
  
End list_first_dec.

Section map.

  Variable (X Y : Type) (f : X -> Y).
  
  Fact map_cons_inv ll y m : map f ll = y::m -> { x : _ & { l | ll = x::l /\ f x = y /\ map f l = m } }.

  Fact map_app_inv ll m n : map f ll = m++n -> { l : _  & { r | ll = l++r /\ m = map f l /\ n = map f r } }.
  
  Fact map_middle_inv ll m y n : map f ll = m++y::n -> { l : _ & { x : _ & { r | ll = l++x::r /\ map f l = m /\ f x = y /\ map f r = n } } }.
  
End map.

Fact Forall2_mono X Y (R S : X -> Y -> Prop) :
         (forall x y, R x y -> S x y) -> forall l m, Forall2 R l m -> Forall2 S l m.

Fact Forall2_nil_inv_l X Y R m : @Forall2 X Y R nil m -> m = nil.

Fact Forall2_nil_inv_r X Y R m : @Forall2 X Y R m nil -> m = nil.

Fact Forall2_cons_inv X Y R x l y m : @Forall2 X Y R (x::l) (y::m) <-> R x y /\ Forall2 R l m.

Fact Forall2_app_inv_l X Y R l1 l2 m : 
    @Forall2 X Y R (l1++l2) m -> { m1 : _ & { m2 | Forall2 R l1 m1 /\ Forall2 R l2 m2 /\ m = m1++m2 } }.

Fact Forall2_app_inv_r X Y R l m1 m2 : 
    @Forall2 X Y R l (m1++m2) -> { l1 : _ & { l2 | Forall2 R l1 m1 /\ Forall2 R l2 m2 /\ l = l1++l2 } }.

Fact Forall2_cons_inv_l X Y R a ll mm : 
      @Forall2 X Y R (a::ll) mm 
   -> { b : _ & { mm' | R a b /\ mm = b::mm' /\ Forall2 R ll mm' } }.

Fact Forall2_cons_inv_r X Y R b ll mm : 
      @Forall2 X Y R ll (b::mm) 
   -> { a : _ & { ll' | R a b /\ ll = a::ll' /\ Forall2 R ll' mm } }.

Fact Forall2_map_left X Y Z (R : Y -> X -> Prop) (f : Z -> Y) ll mm : Forall2 R (map f ll) mm <-> Forall2 (fun x y => R (f x) y) ll mm.

Fact Forall2_map_right X Y Z (R : Y -> X -> Prop) (f : Z -> X) mm ll : Forall2 R mm (map f ll) <-> Forall2 (fun y x => R y (f x)) mm ll.

Fact Forall2_map_both X Y X' Y' (R : X -> Y -> Prop) (f : X' -> X) (g : Y' -> Y) ll mm : Forall2 R (map f ll) (map g mm) <-> Forall2 (fun x y => R (f x) (g y)) ll mm.

Fact Forall2_Forall X (R : X -> X -> Prop) ll : Forall2 R ll ll <-> Forall (fun x => R x x) ll.

Fact Forall_app X (P : X -> Prop) ll mm : Forall P (ll++mm) <-> Forall P ll /\ Forall P mm.

Fact Forall_cons_inv X (P : X -> Prop) x ll : Forall P (x::ll) <-> P x /\ Forall P ll.

Fact Forall_rev X (P : X -> Prop) ll : Forall P ll -> Forall P (rev ll).

Fact Forall_map X Y (f : X -> Y) (P : Y -> Prop) ll : Forall P (map f ll) <-> Forall (fun x => P (f x)) ll.

Fact Forall_forall_map X (f : nat -> X) n l (P : X -> Prop) :
           l = map f (list_an 0 n) -> (forall i, i < n -> P (f i)) <-> Forall P l.

Fact Forall_impl X (P Q : X -> Prop) ll : (forall x, In x ll -> P x -> Q x) -> Forall P ll -> Forall Q ll.

Fact Forall_filter X (P : X -> Prop) (f : X -> bool) ll : Forall P ll -> Forall P (filter f ll). *)
(* sums:
Require Import List Arith Omega Eqdep_dec ZArith.

Require Import utils_tac utils_list binomial.

Set Implicit Arguments.

Record monoid_theory (X : Type) (m : X -> X -> X) (u : X) := mk_monoid {
  monoid_unit_l : forall x, m u x = x;
  monoid_unit_r : forall x, m x u = x;
  monoid_assoc  : forall x y z, m x (m y z) = m (m x y) z;
}.

Fact Nat_plus_monoid : monoid_theory plus 0.

Fact Nat_mult_monoid : monoid_theory mult 1.

Fact Zplus_monoid : monoid_theory Zplus 0%Z.

Fact Zmult_monoid : monoid_theory Zmult 1%Z.

Hint Resolve Nat_plus_monoid Nat_mult_monoid
             Zplus_monoid Zmult_monoid.

Section msum.

  Variable (X : Type) (m : X -> X -> X) (u : X).

  Infix "⊕" := m (at level 50, left associativity).

  Fixpoint msum n f := 
    match n with 
      | 0   => u
      | S n => f 0 ⊕ msum n (fun n => f (S n))
    end.

  Notation "∑" := msum.

  Fact msum_fold_map n f : ∑ n f = fold_right m u (map f (list_an 0 n)).

  Fact msum_0 f : ∑ 0 f = u.

  Fact msum_S n f : ∑ (S n) f = f 0 ⊕ ∑ n (fun n => f (S n)).

  Hypothesis Hmonoid : monoid_theory m u.

  Fact msum_1 f : ∑ 1 f = f 0.

  Fact msum_plus a b f : ∑ (a+b) f = ∑ a f ⊕ ∑ b (fun i => f (a+i)).

  Fact msum_plus1 n f : ∑ (S n) f = ∑ n f ⊕ f n.

  Fact msum_ext n f g : (forall i, i < n -> f i = g i) -> ∑ n f = ∑ n g.

  Fact msum_unit n : ∑ n (fun _ => u) = u.

  Fact msum_comm a n f : (forall i, i < n -> f i ⊕ a = a ⊕ f i) -> ∑ n f ⊕ a = a ⊕ ∑ n f.

  Fact msum_sum n f g : (forall i j, i < j < n -> f j ⊕ g i = g i ⊕ f j) -> ∑ n (fun i => f i ⊕ g i) = ∑ n f ⊕ ∑ n g.

  Fact msum_of_unit n f : (forall i, i < n -> f i = u) -> ∑ n f = u.

  Fact msum_only_one n f i : i < n
                          -> (forall j, j < n -> i <> j -> f j = u)
                          -> ∑ n f = f i.

  Fact msum_msum n k f :
          (forall i1 j1 i2 j2, i1 < n -> j1 < k -> i2 < n -> j2 < k -> f i1 j1 ⊕ f i2 j2 = f i2 j2 ⊕ f i1 j1)
       -> ∑ n (fun i => ∑ k (f i)) = ∑ k (fun j => ∑ n (fun i => f i j)).

  Fact msum_ends n f : (forall i, 0 < i <= n -> f i = u) -> ∑ (n+2) f = f 0 ⊕ f (S n).

  Fact msum_first_two n f : 2 <= n -> (forall i, 2 <= i -> f i = u) -> ∑ n f = f 0 ⊕ f 1.

  Definition mscal n x := msum n (fun _ => x).

  Fact mscal_0 x : mscal 0 x = u.

  Fact mscal_S n x : mscal (S n) x = x ⊕ mscal n x.

  Fact mscal_1 x : mscal 1 x = x.

  Fact mscal_of_unit n : mscal n u = u.

  Fact mscal_plus a b x : mscal (a+b) x = mscal a x ⊕ mscal b x.

  Fact mscal_plus1 n x : mscal (S n) x = mscal n x ⊕ x.

  Fact mscal_comm n x y : x ⊕ y = y ⊕ x -> mscal n x ⊕ y = y ⊕ mscal n x.

  Fact mscal_sum n x y : x ⊕ y = y ⊕ x -> mscal n (x ⊕ y) = mscal n x ⊕ mscal n y.

  Fact mscal_mult a b x : mscal (a*b) x = mscal a (mscal b x).

  Fact msum_mscal n k f : (forall i j, i < n -> j < n -> f i ⊕ f j = f j ⊕ f i) 
                       -> ∑ n (fun i => mscal k (f i)) = mscal k (∑ n f).

End msum.

Section msum_morphism.

  Variable (X Y : Type) (m1 : X -> X -> X) (u1 : X) 
                        (m2 : Y -> Y -> Y) (u2 : Y)
           (H1 : monoid_theory m1 u1)
           (H2 : monoid_theory m2 u2)
           (phi : X -> Y)
           (Hphi1 : phi u1 = u2)
           (Hphi2 : forall x y, phi (m1 x y) = m2 (phi x) (phi y)).

  Fact msum_morph n f : phi (msum m1 u1 n f) = msum m2 u2 n (fun x => phi (f x)).

  Fact mscal_morph n x : phi (mscal m1 u1 n x) = mscal m2 u2 n (phi x).

End msum_morphism.

Section binomial_Newton.

  Variable (X : Type) (sum times : X -> X -> X) (zero one : X).

  Infix "⊕" := sum (at level 50, left associativity).
  Infix "⊗" := times (at level 40, left associativity).
  
  Notation z := zero.
  Notation o := one.

  Notation scal := (mscal sum zero).
  Notation expo := (mscal times one).

  Hypothesis (M_sum : monoid_theory sum zero) 
             (sum_comm : forall x y, x ⊕ y = y ⊕ x)
             (sum_cancel : forall x u v, x ⊕ u = x ⊕ v -> u = v)
             (M_times : monoid_theory times one)
             (distr_l : forall x y z, x ⊗ (y⊕z) = x⊗y ⊕ x⊗z)
             (distr_r : forall x y z, (y⊕z) ⊗ x = y⊗x ⊕ z⊗x).

  Fact times_zero_l x : z ⊗ x = z.

  Fact times_zero_r x : x ⊗ z = z.

  Notation "∑" := (msum sum zero).

  Fact sum_0n_scal n k f : ∑ n (fun i => scal k (f i)) = scal k (∑ n f).

  Fact scal_times k x y : scal k (x⊗y) = x⊗scal k y.

  Fact scal_one_comm k x : scal k o ⊗ x = x ⊗ scal k o.

  Corollary scal_one k x : scal k x = scal k o ⊗ x.

  Fact sum_0n_distr_l b n f : ∑ n (fun i => b⊗f i) = b⊗∑ n f.

  Fact sum_0n_distr_r b n f : ∑ n (fun i => f i⊗b) = ∑ n f ⊗ b.

  Theorem binomial_Newton n a b :
        a ⊗ b = b ⊗ a
     -> expo n (a ⊕ b) = ∑ (S n) (fun i => scal (binomial n i) (expo (n - i) a ⊗ expo i b)).

End binomial_Newton.

Section Newton_nat.

  Notation power := (mscal mult 1).
  Notation "∑" := (msum plus 0).

  Fact sum_fold_map n f : ∑ n f = fold_right plus 0 (map f (list_an 0 n)).

  Fact power_0 x : power 0 x = 1.

  Fact power_S n x : power (S n) x = x * power n x.

  Fact power_1 x : power 1 x = x.

  Fact power_of_0 n : 0 < n -> power n 0 = 0.

  Fact power_of_1 n : power n 1 = 1.

  Fact power_plus p a b : power (a+b) p = power a p * power b p.

  Fact power_mult p a b : power (a*b) p = power a (power b p).
  
  Fact power_ge_1 k p : p <> 0 -> 1 <= power k p.

  Fact power2_gt_0 n : 0 < power n 2.

  Fact power_sinc k p : 2 <= p -> power k p < power (S k) p.

  Fact power_ge_n k p : 2 <= p -> k <= power k p.

  Fact power_mono_l p q x : 1 <= x -> p <= q -> power p x <= power q x.

  Definition power_mono := power_mono_l.
  
  Fact power_smono_l p q x : 2 <= x -> p < q -> power p x < power q x.

  Fact power_mono_r n p q : p <= q -> power n p <= power n q.

  Fact power_0_inv p n : power p n = 0 <-> n = 0 /\ 0 < p.

  Fact plus_cancel_l : forall a b c, a + b = a + c -> b = c.

  Let plus_cancel_l':= plus_cancel_l.

  Fact sum_0n_scal_l n k f : ∑ n (fun i => k*f i) = k*∑ n f.

  Fact sum_0n_scal_r n k f : ∑ n (fun i => (f i)*k) = (∑ n f)*k.

  Fact sum_0n_mono n f g : (forall i, i < n -> f i <= g i) -> ∑ n f <= ∑ n g.

  Fact sum_0n_le_one n f i : i < n -> f i <= ∑ n f.

  Fact sum_power_lt k n f : k <> 0 -> (forall i, i < n -> f i < k) -> ∑ n (fun i => f i * power i k) < power n k.

  Theorem Newton_nat a b n :
       power n (a + b) = ∑ (S n) (fun i => binomial n i * power (n - i) a * power i b).

  Theorem Newton_nat_S a n :
       power n (1 + a) = ∑ (S n) (fun i => binomial n i * power i a).

  Lemma binomial_le_power n i : binomial n i <= power n 2.

  Corollary binomial_lt_power n i : binomial n i < power (S n) 2.

End Newton_nat. *)
(* php:
Require Import Arith Omega List Permutation.

Require Import utils_tac utils_list.

Set Implicit Arguments.

Local Infix "~p" := (@Permutation _) (at level 70, no associativity).

Section incl.

  Variable X : Type.
  
  Implicit Type l : list X.
  
  Fact incl_cons_linv l m x : incl (x::m) l -> In x l /\ incl m l.

  Fact incl_app_rinv l m p : incl m (l++p) -> exists m1 m2, m ~p m1++m2 /\ incl m1 l /\ incl m2 p.
  
  Fact incl_cons_rinv x l m : incl m (x::l) -> exists m1 m2, m ~p m1 ++ m2 /\ Forall (eq x) m1 /\ incl m2 l.

  Fact incl_right_cons_choose x l m : incl m (x::l) -> In x m \/ incl m l.

  Fact incl_left_right_cons x l y m : incl (x::l) (y::m) -> y = x  /\ In y l 
                                                         \/ y = x  /\ incl l m
                                                         \/ In x m /\ incl l (y::m).

  Fact perm_incl_left m1 m2 l: m1 ~p m2 -> incl m2 l -> incl m1 l.

  Fact perm_incl_right m l1 l2: l1 ~p l2 -> incl m l1 -> incl m l2.
  
End incl.

Section Permutation_tools.

  Variable X : Type.
  
  Implicit Types (l : list X).
  
  Theorem Permutation_In_inv l1 l2: l1 ~p l2 -> forall x, In x l1 -> exists l, exists r, l2 = l++x::r.
  
  Fact perm_in_head x l : In x l -> exists m, l ~p x::m.

End Permutation_tools.

Section pigeon_list.

  Variable (X : Type).

  Implicit Types (l m : list X).
  
  Inductive list_has_dup : list X -> Prop :=
    | in_list_hd0 : forall l x, In x l -> list_has_dup (x::l)
    | in_list_hd1 : forall l x, list_has_dup l -> list_has_dup (x::l).
  
  Fact list_hd_cons_inv x l : list_has_dup (x::l) -> In x l \/ list_has_dup l.
  
  Fact list_has_dup_app_left l m : list_has_dup m -> list_has_dup (l++m).
  
  Fact list_has_dup_app_right l m : list_has_dup l -> list_has_dup (l++m).

  Fact perm_list_has_dup l m : l ~p m -> list_has_dup l -> list_has_dup m.

  Fact list_has_dup_app_inv l m : list_has_dup (l++m) -> list_has_dup l 
                                                      \/ list_has_dup m 
                                                      \/ exists x, In x l /\ In x m. 

  Fact list_has_dup_eq_duplicates m: list_has_dup m <-> exists x aa bb cc, m = aa++x::bb++x::cc.

  Fact repeat_choice_two x m : Forall (eq x) m -> (exists m', m = x::x::m') \/ m = nil \/ m = x::nil.

  Fact incl_right_cons_incl_or_lhd_or_perm m x l : 
       incl m (x::l) -> incl m l 
                     \/ list_has_dup m 
                     \/ exists m', m ~p x::m' /\ incl m' l.

  Fact incl_left_right_php x l y m : incl (y::m) (x::l) -> list_has_dup (y::m)
                                                        \/ x = y  /\ incl m l
                                                        \/ In y l /\ incl m l
                                                        \/ In y l /\ exists m', m ~p x::m' /\ incl m' l.

  Lemma length_le_and_incl_implies_dup_or_perm l m :  
            length l <= length m 
         -> incl m l 
         -> list_has_dup m \/ m ~p l.

  Theorem finite_pigeon_hole l m : 
         length l < length m 
      -> incl m l 
      -> exists x aa bb cc, m = aa++x::bb++x::cc.

  Theorem partition_intersection l m k : 
           length k < length (l++m)
        -> incl (l++m) k
        -> list_has_dup l 
        \/ list_has_dup m 
        \/ exists x, In x l /\ In x m. 

End pigeon_list.

Fact not_list_has_dup_an a n : ~ list_has_dup (list_an a n).

Fact list_has_dup_map_inv X Y (f : X -> Y) l : 
           (forall x y, In x l -> In y l -> f x = f y -> x = y) 
        -> list_has_dup (map f l) 
        -> list_has_dup l.

Fact not_list_an_has_dup a n : ~ list_has_dup (list_an a n).

Fact list_exists X Y (R : X -> Y -> Prop) l : (forall x, In x l -> exists y, R x y) -> exists ll, Forall2 R l ll.

Fact Forall2_conj X Y (R S : X -> Y -> Prop) ll mm : Forall2 (fun x y => R x y /\ S x y) ll mm <-> Forall2 R ll mm /\ Forall2 S ll mm.

Fact Forall2_length X Y (R : X -> Y -> Prop) l m : Forall2 R l m -> length l = length m.

Fact Forall2_impl X Y (R S : X -> Y -> Prop) : 
     (forall x y, R x y -> S x y) -> forall l m, Forall2 R l m -> Forall2 S l m.

Fact Forall2_right_Forall X Y (P : Y -> Prop) lx ly : Forall2 (fun (_ : X) y => P y) lx ly <-> Forall P ly /\ length lx = length ly.

Fact Forall2_app_inv_r X Y R l m1 m2 : 
       @Forall2 X Y R l (m1++m2) 
    -> { l1 : _ & { l2 | Forall2 R l1 m1 /\ Forall2 R l2 m2 /\ l = l1++l2 } }.

Section PHP_rel.
  
  Variable (U V : Type) (S : U -> V -> Prop) (l : list U) (m : list V) 
                        (HS : forall x, In x l -> exists y, In y m /\ S x y).
                          
  Let sigma : exists Sm, incl Sm m /\ Forall2 S l Sm.

  Hypothesis (Hlm : length m < length l).
                          
  Theorem PHP_rel : exists a x b y c v, l = a++x::b++y::c
                                       /\ In v m /\ S x v /\ S y v.

End PHP_rel.

Check PHP_rel. *)



Set Implicit Arguments.



Local Notation "∑" := (msum plus 0).



Section nat_swap.



  Variables (i j : nat).



  Definition swap n := if eq_nat_dec n i then j else

                       if eq_nat_dec n j then i else n.



  Fact swap_spec_i : swap i = j.

  Proof. unfold swap; destruct (eq_nat_dec i i); auto; omega. Qed.



  Fact swap_spec_j : swap j = i.

  Proof. 

    unfold swap. 

    destruct (eq_nat_dec j i); auto.

    destruct (eq_nat_dec j j); auto; omega. 

  Qed.



  Fact swap_spec n : n <> i -> n <> j -> swap n = n.

  Proof. 

    unfold swap; intros.

    destruct (eq_nat_dec n i); try omega.

    destruct (eq_nat_dec n j); omega. 

  Qed.



  Fact swap_involutive n : swap (swap n) = n.

  Proof.

    destruct (eq_nat_dec n i).

    { subst n; rewrite swap_spec_i, swap_spec_j; auto. }

    destruct (eq_nat_dec n j).

    { subst n; rewrite swap_spec_j, swap_spec_i; auto. }

    { do 2 (rewrite swap_spec; auto). }

  Qed.



  Fact swap_inj n m : swap n = swap m -> n = m.

  Proof.

    intros; rewrite <- (swap_involutive n), H.

    apply swap_involutive.

  Qed.

  

End nat_swap.



Opaque swap.



Section php_fun.



  Variable (n : nat) (f : nat -> nat) (Hf : forall i, i <= n -> f i < n).



  Theorem php_fun : exists i j, i < j <= n /\ f i = f j.

  Proof.

    destruct PHP_rel with (S := fun x y => y = f x) (l := list_an 0 (S n)) (m := list_an 0 n)

      as (a & i & b & j & c & v & H1 & H2 & H3 & H4).

    + intros x; rewrite list_an_spec; simpl; intros [ _ H ].

      exists (f x); split; auto; rewrite list_an_spec; simpl; split; try omega.

      apply Hf; omega.

    + do 2 rewrite list_an_length; auto.

    + exists i, j; split; try omega.

      generalize H1; intros G1.

      apply list_an_app_inv in G1.

      destruct G1 as (G0 & G1); simpl in G1.

      injection G1; clear G1; intros G1 G2.

      symmetry in G1; apply list_an_app_inv in G1.

      destruct G1 as (G3 & G1); simpl in G1.

      injection G1; clear G1; intros G4 G1.

      apply f_equal with (f := @length _) in H1.

      revert H1; rew length; intros H1.

      omega.

  Qed.



End php_fun.



Section split_interval.



  Variables (n i : nat) (Hi : i <= n).



  Let g j := if le_lt_dec (S n) j then j else     

             if le_lt_dec i j then                  

             if le_lt_dec j i then n              

             else j-1                             

             else j.                              



  Let h j := if le_lt_dec (S n) j then j else     

             if le_lt_dec n j then i else          

             if le_lt_dec i j then j+1            

             else j.                              



  Let Hg1 : forall j, j <= n -> g j <= n.

  Proof.

    intros j Hj; unfold g.

    destruct (le_lt_dec (S n) j); try omega.

    destruct (le_lt_dec i j); try omega.

    destruct (le_lt_dec j i); omega.

  Qed.



  Let Hg2 j : n < j -> g j = j.

  Proof.

    unfold g; destruct (le_lt_dec (S n) j); intros; omega.

  Qed.



  Let Hh1 : forall j, j <= n -> h j <= n.

  Proof.

    intros j Hj; unfold h.

    destruct (le_lt_dec (S n) j); try omega.

    destruct (le_lt_dec n j); try omega.

    destruct (le_lt_dec i j); omega.

  Qed.



  Let Hh2 j : n < j -> h j = j.

  Proof.

    unfold h; destruct (le_lt_dec (S n) j); intros; omega.

  Qed.



  Ltac mydestruct H := 

    match goal with

      |- if ?c then _ else _ = _ => destruct c as [ H | H ]; try omega; auto

    end.



  Theorem split_interval : { g : nat -> nat & { h | (forall j, j <= n -> g j <= n)

                                                 /\ (forall j, j <= n -> h j <= n)

                                                 /\ (forall j, g (h j) = j)

                                                 /\ (forall j, h (g j) = j) 

                                                 /\ g i = n } }.

  Proof.

    exists g, h.

    split; [ | split; [ | split; [ | split ] ] ]; auto.

    + intros j; unfold h. 

      destruct (le_lt_dec (S n) j) as [ | H1 ]; auto.

      destruct (le_lt_dec n j) as [ H2 | H2 ].

      { unfold g.

        destruct (le_lt_dec (S n) i); try omega.

        destruct (le_lt_dec i i); omega. }

      destruct (le_lt_dec i j) as [ H3 | H3 ].

      { unfold g.

        destruct (le_lt_dec (S n) (j+1)); try omega.

        destruct (le_lt_dec i (j+1)); try omega.

        destruct (le_lt_dec (j+1) i); omega. }

      { unfold g.

        destruct (le_lt_dec (S n) j); try omega.

        destruct (le_lt_dec i j); try omega. }

    + intros j; unfold g. 

      destruct (le_lt_dec (S n) j) as [ | H1 ]; auto.

      destruct (le_lt_dec i j) as [ H2 | H2 ].

      destruct (le_lt_dec j i) as [ H3 | H3 ].

      { unfold h.

        destruct (le_lt_dec (S n) n); try omega.

        destruct (le_lt_dec n n); omega. }

      { unfold h.

        destruct (le_lt_dec (S n) (j-1)); try omega.

        destruct (le_lt_dec n (j-1)); try omega.

        destruct (le_lt_dec i (j-1)); omega. }

      { unfold h.

        destruct (le_lt_dec (S n) j); try omega.

        destruct (le_lt_dec n j); try omega.

        destruct (le_lt_dec i j); omega. }

    + unfold g.

      destruct (le_lt_dec (S n) i); try omega.

      destruct (le_lt_dec i i); omega.

  Qed.



End split_interval.



Definition find_max_fun n f : { i | i <= n /\ forall j, j <= n -> f j <= f i }.

Proof.

  revert f; induction n as [ | n IHn ]; intros f.

  + exists 0; split; auto.

    intros [ | ]; auto; omega.

  + destruct (IHn f) as (i & H1 & H2).

    destruct (le_lt_dec (f i) (f (S n))) as [ H | H ].

    * exists (S n); split; auto.

      intros j Hj.

      destruct (le_lt_dec j n) as [ H0 | H0 ].

      - apply le_trans with (2 := H); auto.

      - cutrewrite (j = S n); auto; omega.

    * exists i; split; auto.

      intros j Hj.

      destruct (le_lt_dec j n) as [ H0 | H0 ]; auto.

      cutrewrite (j = S n); auto; omega.

Qed.



Section sum_bounded_permutation.



  Let sigma_sum_split i n f : i < n -> ∑ (S n) f = f i + f n + ∑ i f + ∑ (n-S i) (fun j => f (S i+j)).

  Proof.

    intros Hi.

    replace (S n) with (i+1+(n- S i)+1) by omega.

    repeat (rewrite msum_plus; auto).

    do 2 rewrite msum_S, msum_0.

    repeat rewrite <- plus_assoc.

    rewrite (plus_comm). 

    repeat rewrite <- plus_assoc.

    f_equal.

    { f_equal; omega. }

    simpl.

    rewrite (plus_comm).

    repeat rewrite <- plus_assoc.

    f_equal.

    { f_equal; omega. }

    f_equal.

    apply msum_ext.

    intros; f_equal; omega.

  Qed.



  Let sum_permutation_1 n i j g f : 

            i < j < n 

         -> g i = j 

         -> g j = i

         -> (forall k, k <> i -> k <> j -> k < n -> g k = k)

         -> ∑ n f = ∑ n (fun i => f (g i)).

  Proof.

    revert i j g; induction n as [ | n IHn ]; intros i j g (H1 & H2) H3 H4 H5.

    + do 2 rewrite msum_0; auto.

    + destruct (eq_nat_dec j n) as [ H7 | H7 ].

      * rewrite H7 in *; clear j H7 H2.

        do 2 rewrite sigma_sum_split with (1 := H1).

        rewrite H3, H4; f_equal; [ f_equal | ]; try omega;

          apply msum_ext; intros; symmetry; f_equal; apply H5; omega.

      * do 2 (rewrite msum_plus1; auto); f_equal.

        - apply IHn with i j; auto; split; auto; omega.

        - symmetry; f_equal; apply H5; omega.

  Qed.



  Inductive bounded_permut n (i j : nat) g : Prop :=

    | in_nat_perm : 

          i < n -> j < n -> g i = j -> g j = i

       -> (forall k, k <> i -> k <> j -> k < n -> g k = k)

       -> bounded_permut n i j g.



  Hint Resolve swap_spec_i swap_spec_j swap_spec.



  Fact swap_bounded_permut n i j : i < n -> j < n -> bounded_permut n i j (swap i j).

  Proof. constructor; auto. Qed.

 

  Inductive composed_permutation n g : Prop :=

    | in_cp_0 : (forall i, i < n -> g i = i) -> composed_permutation n g

    | in_cp_1 : forall i j f h, 

                                bounded_permut n i j f 

                             -> composed_permutation n h 

                             -> (forall i, i < n -> g i = h (f i))

                             -> composed_permutation n g.



  Fact composed_permutation_ext n f g : 

       (forall i, i < n -> f i = g i) -> composed_permutation n f -> composed_permutation n g.

  Proof.

    intros H1 H2; revert H2 g H1.

    induction 1 as [ f Hg | f i j p q H1 H2 IH2 H3 ]; intros g H4.

    + constructor 1; intros; rewrite <- H4; auto.

    + constructor 2 with i j p q; auto.

      intros; rewrite <- H4; auto.

  Qed.



  Let flat n f i := if le_lt_dec n i then n else f i.



  Let flat_left n f i : i < n -> flat n f i = f i.

  Proof. unfold flat; intro; destruct (le_lt_dec n i); auto; omega. Qed.



  Let flat_right n f i : n <= i -> flat n f i = n.

  Proof. unfold flat; intro; destruct (le_lt_dec n i); auto; omega. Qed.



  Fact composed_permutation_extends n f g : 

         (forall i, i < n -> f i = g i) -> g n = n -> composed_permutation n f -> composed_permutation (S n) g.

  Proof.

    intros H1 H2 H3; revert H3 g H1 H2.

    induction 1 as [ f Hg | f i j p q H1 H2 IH2 H3 ]; intros g H4 H5.

    + constructor 1; intros j Hj.

      destruct (eq_nat_dec j n); subst; auto.

      rewrite <- H4, Hg; auto; omega.

    + constructor 2 with i j (flat n p) (flat n q).

      * destruct H1 as [ G1 G2 G3 G4 G5 ]; constructor; try omega.

        - rewrite flat_left; auto; omega.

        - rewrite flat_left; auto; omega.

        - intros k ? ? ?.

          destruct (eq_nat_dec k n); subst.

          ++ rewrite flat_right; auto.

          ++ rewrite flat_left, G5; omega.

      * apply IH2.

        - intros l Hl; rewrite flat_left; auto.

        - rewrite flat_right; omega.

      * intros k Hk.

        destruct (eq_nat_dec k n); subst.

        - rewrite (flat_right p), flat_right; omega.

        - rewrite (flat_left p); try omega.

          rewrite flat_left, <- H4; try omega.

          ++ apply H3; omega.

          ++ destruct H1 as [ G1 G2 G3 G4 G5 ].

             destruct (eq_nat_dec k i). 

             { subst; auto. }

             destruct (eq_nat_dec k j).

             { subst k; omega. }

             rewrite G5; omega.

  Qed.



  Fact composed_permutation_S n g : g n = n -> composed_permutation n g -> composed_permutation (S n) g.

  Proof. intro; apply  composed_permutation_extends; auto. Qed.



  Inductive bounded_injective n f : Prop :=

    | in_bounded_inj : (forall i, i < n -> f i < n)

                    -> (forall i j, i < n -> j < n -> f i = f j -> i = j)

                    -> bounded_injective n f.



  Fact injective_composed_permutation n f : bounded_injective n f

                                         -> composed_permutation n f.

  Proof.

    intros [ H1 H2 ].

    revert f H1 H2; induction n as [ | n IHn ]; intros f H1 H2.

    + constructor 1; intros; omega.

    + destruct (find_max_fun n f) as (i & H3 & H4).

      destruct (le_lt_dec n (f i)) as [ C | C ].

      - assert (f i = n) as Hf1.

        { apply le_antisym; auto; apply le_S_n, H1; omega. }

        assert (forall j, j <= n -> j <> i -> f j < n) as Hf2.

        { intros j G1 G2.

          destruct (eq_nat_dec (f j) n).

          + contradict G2; apply H2; omega.

          + specialize (H1 j); omega. }

        specialize (IHn (fun x => f (swap i n x))).

        spec in IHn.

        { intros j Hj.

          destruct (eq_nat_dec j i).

          + subst j; rewrite swap_spec_i; apply Hf2; omega.

          + rewrite swap_spec; try omega; apply Hf2; omega. }

        spec in IHn.

        { intros u v G1 G2 G3.

          apply H2 in G3.

          + revert G3; apply swap_inj.

          + destruct (eq_nat_dec u i).

            - subst; rewrite swap_spec_i; omega.

            - rewrite swap_spec; omega.

          + destruct (eq_nat_dec v i).

            - subst; rewrite swap_spec_i; omega.

            - rewrite swap_spec; omega. }

        apply composed_permutation_S in IHn.

        2: rewrite swap_spec_j, Hf1; auto.

        generalize (@swap_bounded_permut (S n) i n); intros G.

        do 2 (spec in G; try omega).

        constructor 2 with (1 := G) (2 := IHn).

        intros; rewrite swap_involutive; auto.

      - destruct (@php_fun n f) as (u & v & G1 & G2).

        { intros; apply le_lt_trans with (2 := C); auto. }

        apply H2 in G2; omega.

  Qed.



  Theorem sum_bounded_permutation n i j g f : bounded_permut n i j g -> ∑ n f = ∑ n (fun i => f (g i)).

  Proof.

    intros [ H1 H2 H3 H4 H5 ].

    destruct (lt_eq_lt_dec i j) as [ [ G1 | G1 ] | G1 ].

    + apply sum_permutation_1 with i j; auto; split; auto.

    + apply msum_ext; rewrite <- G1 in *; clear j G1.

      intros j Hj; f_equal.

      destruct (eq_nat_dec j i); subst; auto.

      rewrite H5; auto.

    + apply sum_permutation_1 with j i; auto; split; auto.

  Qed.



  Theorem sum_composed_permutation n f g : composed_permutation n g -> ∑ n f = ∑ n (fun i => f (g i)).

  Proof.

    induction 1 as [ g Hg | g i j p q H1 H2 IH2 H3 ].

    + symmetry; apply msum_ext; intros; f_equal; apply Hg; auto.

    + rewrite IH2, sum_bounded_permutation with (1 := H1).

      symmetry; apply msum_ext; intros; f_equal; auto.

  Qed.



  Theorem sum_injective n f g : bounded_injective n g -> ∑ n f = ∑ n (fun i => f (g i)).

  Proof.

    intros; apply sum_composed_permutation, injective_composed_permutation; trivial.

  Qed.



End sum_bounded_permutation.



Section sum_bijection.



  Inductive bijection n g h : Type :=

    | in_bij : (forall i, i < n -> g i < n)

            -> (forall i, i < n -> h i < n) 

            -> (forall i, i < n -> g (h i) = i)

            -> (forall i, i < n -> h (g i) = i)

           -> bijection n g h.



  Theorem sum_bijection n f g h : bijection n g h -> ∑ n f = ∑ n (fun i => f (g i)).

  Proof.

    intros [ H1 H2 H3 H4 ].

    apply sum_injective.

    constructor; auto.

    intros i j G1 G2 G3; rewrite <- (H4 i), G3; auto.

  Qed.



  Inductive triangle_bijection n k g h : Prop :=

    | in_tb : (forall i j, j < i < n -> h (i,j) < k /\ g (h (i,j)) = (i,j))

           -> (forall q, q < k -> snd (g q) < fst (g q) < n /\ h (g q) = q) 

           -> triangle_bijection n k g h.



  Fact sum_triangle_bijection n f k g h :

         triangle_bijection n k g h 

      -> ∑ n (fun i => ∑ i (fun j => f i j)) = ∑ k (fun i => f (fst (g i)) (snd (g i))).

  Proof.

  Admitted.

 

End sum_bijection.
