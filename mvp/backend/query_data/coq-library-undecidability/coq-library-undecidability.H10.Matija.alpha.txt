
Require Import Arith Omega Eqdep_dec ZArith.

Require Import utils_tac gcd prime binomial sums matrix Zp.
(* utils_tac:
Require Import Arith List Wellfounded.

Set Implicit Arguments.

Definition eqdec X := forall x y : X, { x = y } + { x <> y }.

Definition swap {X Y} (c : X * Y) := let (x,y) := c in (y,x).

Theorem measure_rect X (m : X -> nat) (P : X -> Type) :
      (forall x, (forall y, m y < m x -> P y) -> P x) -> forall x, P x.

Tactic Notation "induction" "on" hyp(x) "as" ident(IH) "with" "measure" uconstr(f) :=
  pattern x; revert x; apply measure_rect with (m := fun x => f); intros x IH.

Tactic Notation "eq" "goal" hyp(H) := 
  match goal with 
    |- ?b => match type of H with ?t => replace b with t; auto end 
  end.

Ltac eqgoal := let H := fresh in intro H; eq goal H; clear H.

Tactic Notation "spec" "in" hyp(H) :=
  let Q := fresh 
  in match goal with G: ?h -> _ |- _ => 
       match G with 
         | H => assert (h) as Q; [ | specialize (H Q); clear Q ] 
       end 
     end.

Ltac solve_list_eq := simpl; repeat progress (try rewrite app_ass; try rewrite <- app_nil_end; simpl; auto); auto.

Tactic Notation "solve" "list" "eq" := solve_list_eq.

Tactic Notation "solve_list_eq" "in" hyp(H) := generalize H; clear H; solve_list_eq; intro H.

Tactic Notation "solve" "list" "eq" "in" hyp(H) := 
   let Q := fresh in 
   match goal with 
     |- ?t => set (Q := t); generalize H; clear H; solve_list_eq; intro H; unfold Q; clear Q
   end.

Ltac msplit n := 
  match n with 
    | 0    => idtac 
    | S ?n => split; [ | msplit n ]
   end.

Tactic Notation "define" ident(f) "of" hyp(n) hyp(m) "as" uconstr(t)  :=
  match type of n with ?N =>  
    match type of m with ?M  => pose (f (n:N) (m:M) := t) end end.

Tactic Notation "induction" "on" hyp(x) hyp(y) "as" ident(IH) "with" "measure" uconstr(f) :=
  generalize I; intro IH;
  let mes := fresh "measure" in let rel := fresh "relation" in let loop := fresh "loop" in
  let u := fresh "u" in let u' := fresh x in let Hu := fresh "Hu" in 
  let v := fresh "v" in let v' := fresh y in let Hv := fresh "Hv" 
  in clear IH; 
     define mes of x y as (f : nat);
     set (rel u v := mes (fst u) (snd u) < mes (fst v) (snd v)); unfold fst, snd in rel;
     pattern x, y; match goal with
       |- ?T _ _ => 
       refine ((fix loop u v (Hu : Acc rel (u,v)) { struct Hu } : T u v := _) x y _);
       [ assert (forall u' v', rel (u',v') (u,v) -> T u' v') as IH;
         [ intros u' v' Hv; apply (loop u' v'), (Acc_inv Hu), Hv 
         | unfold rel, mes in *; clear mes rel Hu loop x y; rename u into x; rename v into y ]
       | unfold rel; apply wf_inverse_image, lt_wf ]
     end.

Section forall_equiv.

  Variable (X : Type) (A P Q : X -> Prop) (HPQ : forall n, A n -> P n <-> Q n).

  Theorem forall_bound_equiv : (forall n, A n -> P n) <-> (forall n, A n -> Q n).

End forall_equiv.

Section exists_equiv.

  Variable (X : Type) (P Q : X -> Prop) (HPQ : forall n, P n <-> Q n).

  Theorem exists_equiv : (exists n, P n) <-> (exists n, Q n).

End exists_equiv. *)
(* gcd:
Require Import List Arith Omega Permutation.

Require Import utils_tac utils_list.

Set Implicit Arguments.

Section Euclid.

  Definition euclid n d : d <> 0 -> { q : nat & { r | n = q*d+r /\ r < d } }.

End Euclid.

Definition arem n d q j := j <= d /\ (n = 2*q*d+j \/ q <> 0 /\ n = 2*q*d-j).

Fact division_by_even n d : d <> 0 -> { q : nat & { j | arem n d q j } }.

Fact own_multiple x p : x = p*x -> x = 0 \/ p = 1.

Fact mult_is_one p q : p*q = 1 -> p = 1 /\ q = 1.

Definition divides n k := exists p, k = p*n.

Section divides.

  Infix "div" := divides (at level 70, no associativity).

  Fact divides_refl x : x div x.

  Fact divides_anti x y : x div y -> y div x -> x = y.

  Fact divides_trans x y z : x div y -> y div z -> x div z.

  Fact divides_0 p : p div 0.

  Fact divides_0_inv p : 0 div p -> p = 0.

  Fact divides_1 p : 1 div p.

  Fact divides_1_inv p : p div 1 -> p = 1.

  Fact divides_2_inv p : p div 2 -> p = 1 \/ p = 2.

  Fact divides_mult p q k : p div q -> p div k*q.

  Fact divides_mult_r p q k : p div q -> p div q*k.

  Fact divides_mult_compat a b c d : a div b -> c div d -> a*c div b*d.

  Fact divides_minus p q1 q2 : p div q1 -> p div q2 -> p div q1 - q2.

  Fact divides_plus p q1 q2 : p div q1 -> p div q2 -> p div q1+q2.

  Fact divides_plus_inv p q1 q2 : p div q1 -> p div q1+q2 -> p div q2.

  Fact divides_le p q : q <> 0 -> p div q -> p <= q.

  Fact divides_mult_inv k p q : k <> 0 -> k*p div k*q -> p div q.

  Lemma divides_fact m p : 1 < p <= m -> p div fact m.

  Lemma divides_mult_inv_l p q r : p * q div r -> p div r /\ q div r.

End divides.

Section gcd_lcm.

  Infix "div" := divides (at level 70, no associativity).

  Hint Resolve divides_0 divides_refl divides_mult divides_1.

  Definition is_gcd p q r := r div p /\ r div q /\ forall k, k div p -> k div q -> k div r.
  Definition is_lcm p q r := p div r /\ q div r /\ forall k, p div k -> q div k -> r div k.

  Fact is_gcd_sym p q r : is_gcd p q r -> is_gcd q p r.

  Fact is_gcd_0l p : is_gcd 0 p p.

  Fact is_gcd_0r p : is_gcd p 0 p.

  Fact is_gcd_1l p : is_gcd 1 p 1.

  Fact is_gcd_1r p : is_gcd p 1 1.

  Fact is_gcd_modulus p q k r : p div k -> k <= q -> is_gcd p q r -> is_gcd p (q-k) r.

  Fact is_gcd_minus p q r : p <= q -> is_gcd p q r -> is_gcd p (q-p) r.

  Hint Resolve divides_plus.

  Fact is_gcd_moduplus p q k r : p div k -> is_gcd p q r -> is_gcd p (q+k) r.

  Fact is_gcd_plus p q r : is_gcd p q r -> is_gcd p (q+p) r.

  Fact is_gcd_mult p q r n : is_gcd p (n*p+q) r <-> is_gcd p q r.

  Fact is_gcd_div p q : p div q -> is_gcd p q p.

  Fact is_gcd_refl p : is_gcd p p p.

  Fact is_gcd_fun p q r1 r2 : is_gcd p q r1 -> is_gcd p q r2 -> r1 = r2.

  Fact is_lcm_0l p : is_lcm 0 p 0.

  Fact is_lcm_0r p : is_lcm p 0 0.

  Fact is_lcm_sym p q r : is_lcm p q r -> is_lcm q p r.

  Fact is_lcm_fun p q r1 r2 : is_lcm p q r1 -> is_lcm p q r2 -> r1 = r2.

End gcd_lcm.

Section bezout.

  Infix "div" := divides (at level 70, no associativity).

  Hint Resolve is_gcd_0l is_gcd_0r is_lcm_0l is_lcm_0r divides_refl divides_mult divides_0 is_gcd_minus.

  Section bezout_rel_prime.

    Let bezout_rec p q : 0 < p < q -> is_gcd p q 1 -> exists a b, a*p+b*q = 1+p*q /\ a <= q /\ b <= p.

    Lemma bezout_nc p q : is_gcd p q 1 -> exists a b, a*p+b*q = 1+p*q.

    Hint Resolve divides_1.

    Lemma bezout_sc p q a b m : a*p+b*q = 1 + m -> p div m \/ q div m -> is_gcd p q 1.

  End bezout_rel_prime.

  Fact is_rel_prime_div p q k : is_gcd p q 1 -> p div q*k -> p div k.

  Fact is_rel_prime_div_r p q k : is_gcd p q 1 -> p div k*q -> p div k.

  Fact is_rel_prime_lcm p q : is_gcd p q 1 -> is_lcm p q (p*q).

  Hint Resolve divides_1 divides_mult_compat is_gcd_refl.

  Fact is_gcd_0 p q : is_gcd p q 0 -> p = 0 /\ q = 0.

  Fact is_gcd_rel_prime p q g : is_gcd p q g -> exists a b, p = a*g /\ q = b*g /\ is_gcd a b 1.

  Fact is_lcm_mult p q l k : is_lcm p q l -> is_lcm (k*p) (k*q) (k*l).

  Theorem is_gcd_lcm_mult p q g l : is_gcd p q g -> is_lcm p q l -> p*q = g*l.

  Theorem is_gcd_mult_lcm p q g l : g <> 0 -> is_gcd p q g -> g*l = p*q -> is_lcm p q l.

  Lemma is_lcm_minus p q g l u : p <= q -> p = u*g -> is_gcd p q g -> is_lcm p q l -> is_lcm p (q-p) (l-u*p).

  Lemma is_lcm_modulus k p q g l u : k*p <= q -> p = u*g -> is_gcd p q g -> is_lcm p q l -> is_lcm p (q-k*p) (l-k*u*p).

  Lemma is_lcm_plus p q g l u : p = u*g -> is_gcd p q g -> is_lcm p q l -> is_lcm p (q+p) (l+u*p).

  Lemma is_lcm_moduplus k p q g l u : p = u*g -> is_gcd p q g -> is_lcm p q l -> is_lcm p (q+k*p) (l+k*u*p).

  Section bezout_generalized.

    Let bezout_rec p q : 0 < p < q 
                      -> { a : nat 
                       & { b : nat 
                       & { g : nat
                       & { l : nat 
                       & { u : nat
                       & { v : nat
                         | a*p+b*q = g + l
                        /\ is_gcd p q g
                        /\ is_lcm p q l
                        /\ p = u*g
                        /\ q = v*g
                        /\ a <= v
                        /\ b <= u } } } } } }.
  
    Hint Resolve is_gcd_sym is_lcm_sym.

    Definition bezout_generalized p q : { a : nat 
                                      & { b : nat 
                                      & { g : nat
                                      & { l : nat 
                                        | a*p+b*q = g + l
                                       /\ is_gcd p q g
                                       /\ is_lcm p q l } } } }.

  End bezout_generalized.

  Section gcd_lcm.

    Let gcd_full p q : sig (is_gcd p q).

    Definition gcd p q := proj1_sig (gcd_full p q).
    Fact gcd_spec p q : is_gcd p q (gcd p q).

    Let lcm_full p q : sig (is_lcm p q).

    Definition lcm p q := proj1_sig (lcm_full p q).
    Fact lcm_spec p q : is_lcm p q (lcm p q).

  End gcd_lcm.
     
End bezout.

Require Import Extraction.
Extraction Inline measure_rect.

Check bezout_generalized.
Print Assumptions bezout_generalized.

Section division.

  Fact div_full q p : { n : nat & { r | q = n*p+r /\ (p <> 0 -> r < p) } }.

  Definition div q p := projT1 (div_full q p).
  Definition rem q p := proj1_sig (projT2 (div_full q p)).

  Fact div_rem_spec1 q p : q = div q p * p + rem q p.

  Fact div_rem_spec2 q p : p <> 0 -> rem q p < p.

  Fact rem_0 q : rem q 0 = q.

  Fact div_rem_uniq p n1 r1 n2 r2 : 
        p <> 0 -> n1*p + r1 = n2*p + r2 -> r1 < p -> r2 < p -> n1 = n2 /\ r1 = r2.

  Fact div_prop q p n r : q = n*p+r -> r < p -> div q p = n.

  Fact rem_prop q p n r : q = n*p+r -> r < p -> rem q p = r.

  Fact rem_idem q p : q < p -> rem q p = q.

  Fact is_gcd_rem p n a : is_gcd p n a <-> is_gcd p (rem n p) a.

  Fact rem_erase q n p r : q = n*p+r -> rem q p = rem r p.

  Fact divides_div q p : divides p q -> q = div q p * p.

  Fact divides_rem_eq q p : divides p q <-> rem q p = 0.

  Fact rem_of_0 p : rem 0 p = 0.

  Hint Resolve divides_0_inv.

  Fact divides_dec q p : { k | q = k*p } + { ~ divides p q }.

End division.

Section rem.

  Variable (p : nat) (Hp : p <> 0).

  Fact rem_plus_rem a b : rem (a+rem b p) p = rem (a+b) p.

  Fact rem_mult_rem a b : rem (a*rem b p) p = rem (a*b) p.

  Fact rem_diag : rem p p = 0.

  Fact rem_lt a : a < p -> rem a p = a.

  Fact rem_plus a b : rem (a+b) p = rem (rem a p + rem b p) p.

  Fact rem_scal k a : rem (k*a) p = rem (k*rem a p) p.

  Fact rem_plus_div a b : divides p b -> rem a p = rem (a+b) p.

  Fact div_eq_0 n : n < p -> div n p = 0.

  Fact div_of_0 : div 0 p = 0.

  Fact div_ge_1 n : p <= n -> 1 <= div n p.

End rem.

Fact div_by_p_lt p n : 2 <= p -> n <> 0 -> div n p < n.

Section rem_2.

  Fact rem_2_is_0_or_1 x : rem x 2 = 0 \/ rem x 2 = 1.

  Fact rem_2_mult x y : rem (x*y) 2 = 1 <-> rem x 2 = 1 /\ rem y 2 = 1.

  Fact rem_2_fix_0 : rem 0 2 = 0.

  Fact rem_2_fix_1 n : rem (2*n) 2 = 0.

  Fact rem_2_fix_2 n : rem (1+2*n) 2 = 1.

  Fact rem_2_lt n : rem n 2 < 2.

  Fact div_2_fix_0 : div 0 2 = 0.

  Fact div_2_fix_1 n : div (2*n) 2 = n.

  Fact div_2_fix_2 n : div (1+2*n) 2 = n.

  Fact euclid_2_div n : n = rem n 2 + 2*div n 2 /\ (rem n 2 = 0 \/ rem n 2 = 1).

  Fact euclid_2 n : exists q, n = 2*q \/ n = 1+2*q.

End rem_2.

Local Hint Resolve divides_mult divides_mult_r divides_refl.

Theorem CRT u v a b : u <> 0 -> v <> 0 -> is_gcd u v 1 -> exists w, rem w u = rem a u /\ rem w v = rem b v /\ 2 < w. *)
(* prime:
Require Import List Arith Omega Permutation.

Require Import utils_tac utils_list utils_nat gcd sums.

Set Implicit Arguments.

Section prime.

  Hint Resolve divides_0 divides_mult divides_refl divides_0_inv.

  Infix "<d" := divides (at level 70, no associativity).

  Definition prime p := p <> 1 /\ forall q, q <d p -> q = 1 \/ q = p.

  Fact prime_2 : prime 2.

  Fact prime_ge_2 p : prime p -> 2 <= p.

  Fact prime_gcd p q : prime p -> is_gcd p q 1 \/ p <d q.

  Fact prime_div_mult p x y : prime p -> p <d x*y -> p <d x \/ p <d y. 

  Definition prime_or_div p : 2 <= p -> { q | 2 <= q < p /\ q <d p } + { prime p }.

  Theorem prime_factor n : 2 <= n -> { p | prime p /\ p <d n }.

  Section prime_rect.

    Variables (P : nat -> Type)
              (HP0 : P 0)
              (HP1 : P 1)
              (HPp : forall p, prime p -> P p)
              (HPm : forall x y, P x -> P y -> P (x*y)).

    Theorem prime_rect n : P n.

  End prime_rect.

  Corollary no_common_prime_is_coprime x y : x <> 0 -> (forall p, prime p -> p <d x -> p <d y -> False) -> is_gcd x y 1.

  Fact is_rel_prime_mult p q l : is_gcd p q 1 -> is_gcd p l 1 -> is_gcd p (q*l) 1.

  Fact is_rel_prime_expo p q l : is_gcd p q 1 -> is_gcd p (mscal mult 1 l q) 1.

  Notation lprod := (fold_right mult 1).

  Fact lprod_ge_1 l : Forall prime l -> 1 <= lprod l.

  Fact lprod_app l m : lprod (l++m) = lprod l * lprod m.

  Theorem prime_decomp n : n <> 0 -> { l | n = lprod l /\ Forall prime l }.

  Hint Resolve lprod_ge_1 prime_ge_2.

  Fact prime_in_decomp p l : prime p -> Forall prime l -> p <d lprod l -> In p l.

  Theorem prime_decomp_uniq l m : Forall prime l -> Forall prime m -> lprod l = lprod m -> l ~p m.

End prime.

Section base_decomp.

  Fixpoint expand p l :=
    match l with
      | nil  => 0
      | x::l => x+p*expand p l
    end.

  Notation power := (mscal mult 1).

  Fact expand_app p l m : expand p (l++m) = expand p l + power (length l) p * expand p m.

  Fact expand_0 p l : Forall (eq 0) l -> expand p l = 0.

  Section base_p.

    Variables (p : nat) (Hp : 2 <= p).

    Let base_p_full n : { l | n = expand p l }.

    Definition base_p n := proj1_sig (base_p_full n).
    Fact base_p_spec n : n = expand p (base_p n).

    Fact base_p_uniq l1 l2 : Forall2 (fun x y => x < p /\ y < p) l1 l2 -> expand p l1 = expand p l2 -> l1 = l2.

  End base_p.

End base_decomp. *)
(* binomial:
Require Import Arith Omega.

Require Import utils_tac gcd.

Set Implicit Arguments.

Section factorial.

  Fixpoint fact n := match n with 0 => 1 | S n => (S n) * fact n end.

  Fact fact_0 : fact 0 = 1.

  Fact fact_S n : fact (S n) = (S n)*fact n.

  Fact fact_gt_0 n : 0 < fact n.

End factorial.

Section binomial.

  Infix "<d" := divides (at level 70, no associativity).

  Hint Resolve divides_refl.

  Let fact_neq_0 n : fact n <> 0.

  Fixpoint binomial n p :=
    match n, p with
      | n, 0     => 1
      | 0, S _   => 0
      | S n, S p => binomial n p + binomial n (S p)
    end.

  Fact binomial_n0 n : binomial n 0 = 1.

  Fact binomial_SS n p : binomial (S n) (S p) = binomial n p + binomial n (S p).

  Fact binomial_n1 n : 1 <= n -> binomial n 1 = n.

  Fact binomial_gt n : forall p, n < p -> binomial n p = 0.

  Fact binomial_nn n : binomial n n = 1.

  Theorem binomial_thm n p : p <= n -> fact n = binomial n p * fact p * fact (n-p).

  Fact binomial_le n p : p <= n -> binomial n p = div (fact n) (fact p * fact (n-p)).

  Fact binomial_sym n p : p <= n -> binomial n p = binomial n (n-p).

  Fact binomial_spec n p : p <= n -> fact n = binomial n p * fact p * fact (n-p).

  Fact binomial_0n n : 0 < n -> binomial 0 n = 0.

  Theorem binomial_pascal n p : binomial (S n) (S p) = binomial n p + binomial n (S p).

End binomial. *)
(* sums:
Require Import List Arith Omega Eqdep_dec ZArith.

Require Import utils_tac utils_list binomial.

Set Implicit Arguments.

Record monoid_theory (X : Type) (m : X -> X -> X) (u : X) := mk_monoid {
  monoid_unit_l : forall x, m u x = x;
  monoid_unit_r : forall x, m x u = x;
  monoid_assoc  : forall x y z, m x (m y z) = m (m x y) z;
}.

Fact Nat_plus_monoid : monoid_theory plus 0.

Fact Nat_mult_monoid : monoid_theory mult 1.

Fact Zplus_monoid : monoid_theory Zplus 0%Z.

Fact Zmult_monoid : monoid_theory Zmult 1%Z.

Hint Resolve Nat_plus_monoid Nat_mult_monoid
             Zplus_monoid Zmult_monoid.

Section msum.

  Variable (X : Type) (m : X -> X -> X) (u : X).

  Infix "⊕" := m (at level 50, left associativity).

  Fixpoint msum n f := 
    match n with 
      | 0   => u
      | S n => f 0 ⊕ msum n (fun n => f (S n))
    end.

  Notation "∑" := msum.

  Fact msum_fold_map n f : ∑ n f = fold_right m u (map f (list_an 0 n)).

  Fact msum_0 f : ∑ 0 f = u.

  Fact msum_S n f : ∑ (S n) f = f 0 ⊕ ∑ n (fun n => f (S n)).

  Hypothesis Hmonoid : monoid_theory m u.

  Fact msum_1 f : ∑ 1 f = f 0.

  Fact msum_plus a b f : ∑ (a+b) f = ∑ a f ⊕ ∑ b (fun i => f (a+i)).

  Fact msum_plus1 n f : ∑ (S n) f = ∑ n f ⊕ f n.

  Fact msum_ext n f g : (forall i, i < n -> f i = g i) -> ∑ n f = ∑ n g.

  Fact msum_unit n : ∑ n (fun _ => u) = u.

  Fact msum_comm a n f : (forall i, i < n -> f i ⊕ a = a ⊕ f i) -> ∑ n f ⊕ a = a ⊕ ∑ n f.

  Fact msum_sum n f g : (forall i j, i < j < n -> f j ⊕ g i = g i ⊕ f j) -> ∑ n (fun i => f i ⊕ g i) = ∑ n f ⊕ ∑ n g.

  Fact msum_of_unit n f : (forall i, i < n -> f i = u) -> ∑ n f = u.

  Fact msum_only_one n f i : i < n
                          -> (forall j, j < n -> i <> j -> f j = u)
                          -> ∑ n f = f i.

  Fact msum_msum n k f :
          (forall i1 j1 i2 j2, i1 < n -> j1 < k -> i2 < n -> j2 < k -> f i1 j1 ⊕ f i2 j2 = f i2 j2 ⊕ f i1 j1)
       -> ∑ n (fun i => ∑ k (f i)) = ∑ k (fun j => ∑ n (fun i => f i j)).

  Fact msum_ends n f : (forall i, 0 < i <= n -> f i = u) -> ∑ (n+2) f = f 0 ⊕ f (S n).

  Fact msum_first_two n f : 2 <= n -> (forall i, 2 <= i -> f i = u) -> ∑ n f = f 0 ⊕ f 1.

  Definition mscal n x := msum n (fun _ => x).

  Fact mscal_0 x : mscal 0 x = u.

  Fact mscal_S n x : mscal (S n) x = x ⊕ mscal n x.

  Fact mscal_1 x : mscal 1 x = x.

  Fact mscal_of_unit n : mscal n u = u.

  Fact mscal_plus a b x : mscal (a+b) x = mscal a x ⊕ mscal b x.

  Fact mscal_plus1 n x : mscal (S n) x = mscal n x ⊕ x.

  Fact mscal_comm n x y : x ⊕ y = y ⊕ x -> mscal n x ⊕ y = y ⊕ mscal n x.

  Fact mscal_sum n x y : x ⊕ y = y ⊕ x -> mscal n (x ⊕ y) = mscal n x ⊕ mscal n y.

  Fact mscal_mult a b x : mscal (a*b) x = mscal a (mscal b x).

  Fact msum_mscal n k f : (forall i j, i < n -> j < n -> f i ⊕ f j = f j ⊕ f i) 
                       -> ∑ n (fun i => mscal k (f i)) = mscal k (∑ n f).

End msum.

Section msum_morphism.

  Variable (X Y : Type) (m1 : X -> X -> X) (u1 : X) 
                        (m2 : Y -> Y -> Y) (u2 : Y)
           (H1 : monoid_theory m1 u1)
           (H2 : monoid_theory m2 u2)
           (phi : X -> Y)
           (Hphi1 : phi u1 = u2)
           (Hphi2 : forall x y, phi (m1 x y) = m2 (phi x) (phi y)).

  Fact msum_morph n f : phi (msum m1 u1 n f) = msum m2 u2 n (fun x => phi (f x)).

  Fact mscal_morph n x : phi (mscal m1 u1 n x) = mscal m2 u2 n (phi x).

End msum_morphism.

Section binomial_Newton.

  Variable (X : Type) (sum times : X -> X -> X) (zero one : X).

  Infix "⊕" := sum (at level 50, left associativity).
  Infix "⊗" := times (at level 40, left associativity).
  
  Notation z := zero.
  Notation o := one.

  Notation scal := (mscal sum zero).
  Notation expo := (mscal times one).

  Hypothesis (M_sum : monoid_theory sum zero) 
             (sum_comm : forall x y, x ⊕ y = y ⊕ x)
             (sum_cancel : forall x u v, x ⊕ u = x ⊕ v -> u = v)
             (M_times : monoid_theory times one)
             (distr_l : forall x y z, x ⊗ (y⊕z) = x⊗y ⊕ x⊗z)
             (distr_r : forall x y z, (y⊕z) ⊗ x = y⊗x ⊕ z⊗x).

  Fact times_zero_l x : z ⊗ x = z.

  Fact times_zero_r x : x ⊗ z = z.

  Notation "∑" := (msum sum zero).

  Fact sum_0n_scal n k f : ∑ n (fun i => scal k (f i)) = scal k (∑ n f).

  Fact scal_times k x y : scal k (x⊗y) = x⊗scal k y.

  Fact scal_one_comm k x : scal k o ⊗ x = x ⊗ scal k o.

  Corollary scal_one k x : scal k x = scal k o ⊗ x.

  Fact sum_0n_distr_l b n f : ∑ n (fun i => b⊗f i) = b⊗∑ n f.

  Fact sum_0n_distr_r b n f : ∑ n (fun i => f i⊗b) = ∑ n f ⊗ b.

  Theorem binomial_Newton n a b :
        a ⊗ b = b ⊗ a
     -> expo n (a ⊕ b) = ∑ (S n) (fun i => scal (binomial n i) (expo (n - i) a ⊗ expo i b)).

End binomial_Newton.

Section Newton_nat.

  Notation power := (mscal mult 1).
  Notation "∑" := (msum plus 0).

  Fact sum_fold_map n f : ∑ n f = fold_right plus 0 (map f (list_an 0 n)).

  Fact power_0 x : power 0 x = 1.

  Fact power_S n x : power (S n) x = x * power n x.

  Fact power_1 x : power 1 x = x.

  Fact power_of_0 n : 0 < n -> power n 0 = 0.

  Fact power_of_1 n : power n 1 = 1.

  Fact power_plus p a b : power (a+b) p = power a p * power b p.

  Fact power_mult p a b : power (a*b) p = power a (power b p).
  
  Fact power_ge_1 k p : p <> 0 -> 1 <= power k p.

  Fact power2_gt_0 n : 0 < power n 2.

  Fact power_sinc k p : 2 <= p -> power k p < power (S k) p.

  Fact power_ge_n k p : 2 <= p -> k <= power k p.

  Fact power_mono_l p q x : 1 <= x -> p <= q -> power p x <= power q x.

  Definition power_mono := power_mono_l.
  
  Fact power_smono_l p q x : 2 <= x -> p < q -> power p x < power q x.

  Fact power_mono_r n p q : p <= q -> power n p <= power n q.

  Fact power_0_inv p n : power p n = 0 <-> n = 0 /\ 0 < p.

  Fact plus_cancel_l : forall a b c, a + b = a + c -> b = c.

  Let plus_cancel_l':= plus_cancel_l.

  Fact sum_0n_scal_l n k f : ∑ n (fun i => k*f i) = k*∑ n f.

  Fact sum_0n_scal_r n k f : ∑ n (fun i => (f i)*k) = (∑ n f)*k.

  Fact sum_0n_mono n f g : (forall i, i < n -> f i <= g i) -> ∑ n f <= ∑ n g.

  Fact sum_0n_le_one n f i : i < n -> f i <= ∑ n f.

  Fact sum_power_lt k n f : k <> 0 -> (forall i, i < n -> f i < k) -> ∑ n (fun i => f i * power i k) < power n k.

  Theorem Newton_nat a b n :
       power n (a + b) = ∑ (S n) (fun i => binomial n i * power (n - i) a * power i b).

  Theorem Newton_nat_S a n :
       power n (1 + a) = ∑ (S n) (fun i => binomial n i * power i a).

  Lemma binomial_le_power n i : binomial n i <= power n 2.

  Corollary binomial_lt_power n i : binomial n i < power (S n) 2.

End Newton_nat. *)
(* matrix:
Require Import Arith Omega Eqdep_dec ZArith.

Require Import utils_tac gcd prime binomial sums.

Set Implicit Arguments.

Section rings.

  Variable (R : Type) (Rzero Rone : R) (Rplus Rmult Rminus : R -> R -> R) (Ropp : R -> R)
           (R_is_ring : ring_theory Rzero Rone Rplus Rmult Rminus Ropp eq). 

  Infix "⊕" := Rplus (at level 50, left associativity).
  Infix "⊗" := Rmult (at level 40, left associativity).

  Notation z := Rzero.
  Notation o := Rone.
  Notation "∸" := Ropp.

  Add Ring Rring : R_is_ring.

  Definition M22 := (R * R * R * R)%type.
  Definition ID_22 : M22 := (o,z,z,o).
  Definition ZE_22 : M22 := (z,z,z,z).

  Definition PL22 : M22 -> M22 -> M22.

  Infix "⊞" := PL22 (at level 50, left associativity).
 
  Definition MI22 : M22 -> M22.

  Notation "⊟" := MI22.

  Fact M22_equal (a b c d a' b' c' d' : R) : a = a' -> b = b' -> c = c' -> d = d' -> (a,b,c,d) = (a',b',c',d').

  Fact M22plus_zero : forall m, ZE_22 ⊞ m = m.

  Fact M22plus_comm  : forall x y, x ⊞ y = y ⊞ x.

  Fact M22plus_assoc  : forall x y u, x ⊞ (y ⊞ u) = x ⊞ y ⊞ u.

  Fact M22minus : forall x, x ⊞ ⊟ x = ZE_22.

  Fact M22plus_cancel : forall x a b, x ⊞ a = x ⊞ b -> a = b.

  Theorem M22plus_monoid : monoid_theory PL22 ZE_22.

  Definition MU22 : M22 -> M22 -> M22.

  Infix "⊠" := MU22 (at level 40, left associativity).

  Tactic Notation "myauto" integer(n) := do n intros (((?&?)&?)&?); apply M22_equal; ring.

  Fact M22mult_one_l : forall x, ID_22 ⊠ x = x.

  Fact M22mult_one_r : forall x, x ⊠ ID_22 = x.

  Fact M22mult_assoc : forall x y u, x ⊠ (y ⊠ u) = x ⊠ y ⊠ u.

  Fact M22_mult_distr_l : forall x y u, x ⊠ (y⊞u) = x⊠y ⊞ x⊠u.
 
  Fact M22_mult_distr_r : forall x y u, (y⊞u) ⊠ x = y⊠x ⊞ u⊠x.

  Theorem M22mult_monoid : monoid_theory MU22 ID_22.

  Fact M22_opp_mult_l : forall x y, (⊟ x) ⊠ y = ⊟ (x ⊠ y).

  Fact M22_opp_mult_r : forall x y, x ⊠ (⊟y) = ⊟ (x ⊠ y).

  Definition M22scal (k : R) : M22 -> M22.

  Fact M22scal_mult k1 k2 : forall x, M22scal k1 (M22scal k2 x) = M22scal (k1⊗k2) x.

  Fact M22scal_PL22 k : forall x y, M22scal k (x ⊞ y) = M22scal k x ⊞ M22scal k y.

  Fact M22scal_MI22 : forall x, M22scal (∸o) x = ⊟x.

  Fact M22scal_zero : forall x, M22scal z x = ZE_22.

  Fact M22scal_MU22_l k : forall x y, M22scal k (x ⊠ y) = M22scal k x ⊠ y.

  Fact M22scal_MU22_r k : forall x y, M22scal k (x ⊠ y) = x ⊠ M22scal k y.

  Fact mscal_M22scal n x : mscal PL22 ZE_22 n x = M22scal (mscal Rplus Rzero n Rone) x.

  Definition Det22 : M22 -> R.

  Fact Det22_scal k : forall x, Det22 (M22scal k x) = (k ⊗ k) ⊗ Det22 x.

  Fact Det22_mult : forall x y, Det22 (x⊠y) = Det22 x ⊗ Det22 y.

  Notation expo22 := (mscal MU22 ID_22).
  Notation expoR := (mscal Rmult o).

  Fact expo22_scal k n U : expo22 n (M22scal k U) = M22scal (expoR n k) (expo22 n U).

  Fact Det22_expo n x : Det22 (expo22 n x) = expoR n (Det22 x).

  Fact Diag22_expo n x y : expo22 n (x,z,z,y) = (expoR n x,Rzero,Rzero,expoR n y).

  Fact MU22_Diag22 a b c d x y : (a,b,c,d) ⊠ (x,z,z,y) = (a⊗x,b⊗y,c⊗x,d⊗y).
 
  Fact M22_proj12 a1 b1 c1 d1 a2 b2 c2 d2 : (a1,b1,c1,d1) = (a2,b2,c2,d2) :> M22 -> c1 = c2.

End rings.

Section ring_morphism.

  Variable (X : Type) (zX oX : X) (pX mX : X -> X -> X) (oppX : X -> X)
           (Y : Type) (zY oY : Y) (pY mY : Y -> Y -> Y) (oppY : Y -> Y).

  Variable phi : X -> Y.

  Notation "〚 x 〛" := (phi x).

  Record ring_morphism : Prop := mk_ring_morph {
    morph_z : 〚 zX 〛= zY;
    morph_o : 〚 oX 〛= oY;
    morph_plus : forall x y, 〚 pX x y 〛= pY 〚 x 〛〚 y 〛;
    morph_mult : forall x y, 〚 mX x y 〛= mY 〚 x 〛〚 y 〛;
    morph_opp : forall x, 〚 oppX x 〛= oppY 〚 x 〛;
  }.

  Hypothesis Hphi : ring_morphism.

  Definition morph22 : M22 X -> M22 Y.

  Tactic Notation "myauto" integer(n) := do n intros (((?&?)&?)&?); apply M22_equal; ring.

  Fact PL22_morph : forall x y, morph22 (PL22 pX x y) = PL22 pY (morph22 x) (morph22 y).

  Fact MU22_morph : forall x y, morph22 (MU22 pX mX x y) = MU22 pY mY (morph22 x) (morph22 y).

  Fact MI22_morph : forall x, morph22 (MI22 oppX x) = MI22 oppY (morph22 x).

  Fact M22scal_morph : forall k x, morph22 (M22scal mX k x) = M22scal mY 〚 k 〛 (morph22 x).

  Fact Det22_morph : forall x, 〚 Det22 pX mX oppX x 〛= Det22 pY mY oppY (morph22 x).

  Fact expo22_morph n x : morph22 (mscal (MU22 pX mX) (ID_22 zX oX) n x)
                        = mscal (MU22 pY mY) (ID_22 zY oY) n (morph22 x).

End ring_morphism. *)
(* Zp:
Require Import Arith Omega Eqdep_dec ZArith List Permutation.

Require Import utils_tac utils_list gcd prime binomial sums matrix php.

Set Implicit Arguments.

Section le_pirr.

  Scheme le_indd := Induction for le Sort Prop.

  Fact le_pirr : forall x y (H1 H2 : x <= y), H1 = H2.

End le_pirr.

Fact lt_pirr x y (H1 H2 : x < y) : H1 = H2.

Fact Zring : ring_theory 0%Z 1%Z Zplus Zmult Zminus Z.opp eq.

Hint Resolve Zring Zplus_monoid Zmult_monoid.

Section Z_coprime.

  Open Scope Z_scope.

  Definition Z_pos_or_neg u : { 0 <= u } + { u < 0 }.

  Fact Z_coprime u v : (exists a b, a * Z.of_nat u + b*Z.of_nat v = 1) -> is_gcd u v 1%nat.

End Z_coprime.

Section Zp.

  Variable (p : nat) (Hp : p <> 0).
 
  Definition Z_Zp := { x | x < p }.

  Implicit Type x y : Z_Zp.

  Fact Zp_inj : forall x y, proj1_sig x = proj1_sig y -> x = y.

  Definition Zp_plus : Z_Zp -> Z_Zp -> Z_Zp.

  Infix "⊕" := Zp_plus (at level 50, left associativity).
  
  Definition Zp_zero : Z_Zp.

  Definition Zp_opp : Z_Zp -> Z_Zp.

  Notation "∸" := Zp_opp.

  Definition Zp_mult : Z_Zp -> Z_Zp -> Z_Zp.

  Infix "⊗" := Zp_mult (at level 40, left associativity).

  Definition Zp_one : Z_Zp.

  Notation Zp := Zp_zero.
  Notation Op := Zp_one.

  Fact Zp_plus_zero : forall x, Zp ⊕ x = x.

  Fact Zp_plus_comm : forall x y,  x ⊕ y = y ⊕ x.

  Fact Zp_plus_assoc : forall x y z, x ⊕ (y ⊕ z) = x ⊕ y ⊕ z.

  Fact Zp_minus : forall x, x ⊕ ∸ x = Zp.

  Fact Zp_mult_one : forall x, Op ⊗ x = x.

  Fact Zp_mult_comm : forall x y, x ⊗ y = y ⊗ x.

  Fact Zp_mult_one_r x : x ⊗ Op = x.

  Fact Zp_mult_assoc : forall x y z, x ⊗ (y ⊗ z) = x ⊗ y ⊗ z.

  Fact Zp_mult_plus_distr_l : forall x y z, x ⊗ (y ⊕ z) = x ⊗ y ⊕ x ⊗ z.

  Fact Zp_mult_plus_distr_r x y z : (y ⊕ z) ⊗ x = y ⊗ x ⊕ z ⊗ x.

  Definition Zp_is_ring : @ring_theory _ Zp Op Zp_plus Zp_mult (fun x y => x ⊕ ∸ y) Zp_opp eq.

  Fact Zp_mult_invert : forall x, is_gcd p (proj1_sig x) 1 -> { i | i ⊗ x = Op }.

  Fact Zp_mult_revert : forall x i, i ⊗ x = Op -> is_gcd p (proj1_sig x) 1.

  Definition Zp_invertible x := exists i, i ⊗ x = Op.

  Fact Zp_invertible_spec x : Zp_invertible x <-> is_gcd p (proj1_sig x) 1.

  Fact Zp_prime_invert : prime p -> forall x, x <> Zp -> { i | i ⊗ x = Op }.

  Add Ring Zp_ring : Zp_is_ring.

  Fact Zp_plus_monoid : monoid_theory Zp_plus Zp_zero.

  Fact Zp_mult_monoid : monoid_theory Zp_mult Zp_one.

  Fact Zp_one_invertible : Zp_invertible Op.

  Fact Zp_opp_invertible x : Zp_invertible x <-> Zp_invertible (∸ x).

  Fact Zp_mult_invertible x y : Zp_invertible x -> Zp_invertible y -> Zp_invertible (x ⊗ y).

  Hint Resolve Zp_one_invertible Zp_opp_invertible Zp_mult_invertible.

  Fact Zp_expo_invertible n x : Zp_invertible x -> Zp_invertible (mscal Zp_mult Op n x).

  Fact Zp_invertible_cancel_l x y z : Zp_invertible x -> x⊗y = x⊗z -> y = z.

  Fact Zp_opp_zero : ∸ Zp = Zp.

  Fact Zp_plus_inj_l x y z : x ⊕ y = x ⊕ z -> y = z.

  Fact Zp_plus_zero_r x : x ⊕ Zp = x.

  Fact Zp_opp_inv x : ∸ (∸ x) = x.

  Fact Zp_opp_inj x y : ∸ x = ∸ y -> x = y.

  Fact Zp_opp_plus x y : ∸ (x ⊕ y) = ∸ x ⊕ ∸ y.
 
  Fact Zp_opp_plus_eq x y z : x ⊕ y = z <-> x = z ⊕ ∸ y.

  Fact Zp_mult_zero x : Zp ⊗ x = Zp.

  Fact Zp_mult_minus_one x : (∸ Op) ⊗ x = ∸ x.

  Fact Zp_opp_mult x y : (∸ x) ⊗ y = ∸ (x ⊗ y).

  Fact Zp_invertible_eq_zero x y : Zp_invertible x -> x ⊗ y = Zp -> y = Zp.

  Fact Zp_zero_is_one : Zp = Op <-> p = 1.

  Fact Zp_eq_dec : forall x y : Z_Zp, { x = y } + { x <> y }.

  Section nat2Zp.

    Definition nat2Zp (u : nat) : Z_Zp.

    Arguments nat2Zp u /.

    Notation "〚 x 〛" := (nat2Zp x).

    Fact nat2Zp_zero : 〚0〛= Zp.

    Fact nat2Zp_one : 〚1〛= Op.

    Fact nat2Zp_invertible n : Zp_invertible 〚n〛 <-> is_gcd p n 1.

    Fact nat2Zp_p :〚p〛= Zp.

    Fact nat2Zp_inj u v : 〚u〛=〚v〛 <-> rem u p = rem v p.

    Fact nat2Zp_surj u : { x | x < p /\ u = 〚x〛 }.

    Fact nat2Zp_plus u v : 〚u+v〛=〚u〛⊕〚v〛.

    Fact nat2Zp_minus u v : v <= u -> 〚u-v〛=〚u〛⊕ ∸〚v〛.

    Fact nat2Zp_minus_one : 〚p-1〛= ∸Op.

    Fact nat2Zp_mult u v :〚u*v〛=〚u〛⊗〚v〛.

    Fact nat2Zp_expo n u : 〚mscal mult 1%nat n u〛 = mscal Zp_mult Zp_one n 〚u〛.

    Fact nat2Zp_divides u v :〚u〛=〚v〛-> divides p u -> divides p v.

    Fact divides_nat2Zp u : divides p u <-> 〚u〛= Zp.

  End nat2Zp.

  Arguments nat2Zp u /.

  Definition Zp_list := map nat2Zp (list_an 0 p).
  
  Fact Zp_list_spec x : In x Zp_list.

  Fact Zp_list_length : length Zp_list = p.

  Fact Zp_invertible_prime x : prime p -> Zp_invertible x <-> x <> Zp.
 
  Fact Zp_prime_integral x y : prime p -> x ⊗ y = Zp -> x = Zp \/ y = Zp.

  Fact Zp_prime_square_eq_square x y : prime p -> x⊗x = y⊗y <-> x = y \/ x = ∸y.

  Fact Zp_prime_square_one x : prime p -> x⊗x = Op <-> x = Op \/ x = ∸Op.

  Section Z2Zp.

    Open Scope Z_scope.

    Implicit Types u v w : Z.

    Definition Z2Zp u : Z_Zp.

    Arguments Z2Zp u /.

    Notation "〘 x 〙" := (Z2Zp x).
    Notation "〚 x 〛" := (nat2Zp x).

    Fact Z2Zp_pos u : 0 <= u -> 〘u〙= 〚Z.to_nat u〛.

    Fact Z2Zp_of_nat n : 〘Z.of_nat n〙 = 〚n〛.

    Fact Z2Zp_zero : 〘0〙= Zp.

    Fact Z2Zp_neg u : u <= 0 -> 〘u〙 = ∸〘-u〙.

    Section Z2Zp_plus.

      Let Z2Zp_plus_loc u v : u <= 0 -> 0 <= v -> -u <= v -> 〘u+v〙=〘u〙⊕〘v〙.

      Let Z2Zp_plus_loc' u v : u <= 0 -> 0 <= v -> v <= -u -> 〘u+v〙=〘u〙⊕〘v〙.

      Fact Z2Zp_plus u v : 〘u+v〙=〘u〙⊕〘v〙.

    End Z2Zp_plus.

    Fact Z2Zp_opp u :〘-u〙= ∸〘u〙.

    Fact Z2Zp_minus u v : 〘u-v〙 = 〘u〙⊕ ∸〘v〙.

    Section Z2Zp_mult.
  
      Let Z2Zp_mult_loc u v : 0 <= u -> 0 <= v -> 〘u*v〙=〘u〙⊗〘v〙.

      Fact Z2Zp_mult u v : 〘u*v〙=〘u〙⊗〘v〙.

    End Z2Zp_mult.

    Fact Z2Zp_one : 〘1〙 = Op.

    Section Z2Zp_inj.

      Let Z2Zp_inj_loc u v : v <= u ->〘u〙=〘v〙-> exists i, u-v = i*Z.of_nat p.
      
      Fact Z2Zp_inj u v :〘u〙=〘v〙<-> exists i, u-v = i*Z.of_nat p.

    End Z2Zp_inj.

    Fact nat2Zp_choose : forall x, x = Zp \/ x = Op \/ x = ∸ Op \/ exists m,  (1 < m < p-1)%nat /\〚m〛= x.

    Section prime.

      Hypothesis Hp' : prime p.

      Fact nat2Zp_invertible_prime n : (0 < n < p)%nat -> Zp_invertible 〚n〛.

      Let Hp'' : (2 <= p)%nat.

      Let Hzero_one : Zp <> Op.

      Fact Zp_invertible_factorial n : (n < p)%nat -> Zp_invertible 〚fact n〛.

      Section inv.

        Let Zp_invert_full x : { i | (x = Zp -> i = Zp) /\ (x <> Zp -> i ⊗ x = Op) }.

        Definition Zp_invert x := proj1_sig (Zp_invert_full x).

        Fact Zp_invert_spec1 : Zp_invert Zp = Zp.

        Fact Zp_invert_spec2 x : x <> Zp -> Zp_invert x ⊗ x = Op.

      End inv.

      Notation inv := Zp_invert.

      Fact Zp_invert_eq_not_zero x y : x <> Zp -> inv x = y <-> y ⊗ x = Op.

      Fact Zp_invert_opp x : inv (∸x) = ∸(inv x).

      Fact Zp_invert_one : inv Op = Op.
  
      Fact Zp_invert_minus_one : inv (∸ Op) = ∸ Op.

      Fact Zp_invert_fix x : inv x = x <-> x = Zp \/ x = Op \/ x = ∸ Op.

      Fact Zp_invert_involutive x : inv (inv x) = x.

      Fact Zp_invert_not_fix n : (1 < n < p-1)%nat -> inv〚n〛<>〚n〛.

      Fact Zp_invert_stable n : (1 < n < p-1)%nat -> exists m, (1 < m < p-1)%nat /\〚m〛= inv〚n〛.

      Definition Zp_lprod := fold_right Zp_mult Zp_one.

      Fact Zp_lprod_nil : Zp_lprod nil = Op.

      Fact Zp_lprod_cons x l : Zp_lprod (x::l) = x ⊗ Zp_lprod l.
   
      Fact Zp_lprod_app l m : Zp_lprod (l++m) = Zp_lprod l ⊗  Zp_lprod m.

      Theorem Zp_mult_autoinv l : ~ list_has_dup l -> (forall x, In x l -> x <> Zp /\ inv x <> x /\ In (inv x) l) -> Zp_lprod l = Op.

      Fact Zp_lprod_fact n : 〚fact (S n)〛= Zp_lprod (map nat2Zp (list_an 2 n)).

      Theorem Wilson_thm_1 :〚fact (p-1)〛= ∸Op.

    End prime.

    Fact Zp_divides_and_invertible d k n i : (d * k = n)%nat ->〚i〛⊗〚d〛= Op ->〚k〛=〚i〛⊗〚n〛.

  End Z2Zp.

End Zp.

Fact divides_not_0_interval p q : q <> 0 -> divides p q -> 1 <= p <= q.

Fact divides_fact_lt q n : 1 <= q <= n -> divides q (fact n).

Theorem Wilson_theorem p : 2 <= p -> prime p <-> divides p (fact (p-1)+1).

Check Wilson_theorem.
Print Assumptions Wilson_theorem.

Section Z2Zp_morphishm.

  Variable (p : nat) (Hp : p <> 0).

  Fact Z2Zp_morphishm : ring_morphism 0%Z 1%Z Zplus Zmult Z.opp 

End Z2Zp_morphishm. *)

Set Implicit Arguments.

Section Zp_alpha_2.

  Variable (ak am k l m : nat)
           (H1 : m = (l*k)%nat)
           (H2 : (ak*ak <> 0)%nat).

  Notation "〚 u 〛" := (nat2Zp H2 u).
  Infix "⊗" := (Zp_mult H2) (at level 40, left associativity).

  Hypothesis (H3 : (m <> 0)%nat)
             (H4 : exists q, Zp_invertible H2 q /\〚am〛 = q⊗〚l〛⊗〚ak〛). 

  Let Hak : ak <> 0.  Proof. intro; subst; destruct H2; auto. Qed.
  Let Hl : l <> 0.    Proof. contradict H3; subst; ring. Qed.
  Let Hk : k <> 0.    Proof. contradict H3; subst; ring. Qed.

  Lemma Zp_alpha_congruence_2 : divides (ak*ak) am <-> divides (k*ak) m.
  Proof.
    rewrite mult_comm in H1.
    destruct H4 as (q & Hq1 & Hq2).
    split; intros H.
    + rewrite (proj1 (divides_nat2Zp _ _)) in Hq2; auto.
      symmetry in Hq2.
      rewrite <- Zp_mult_assoc in Hq2.
      apply Zp_invertible_eq_zero in Hq2; auto.
      rewrite <- nat2Zp_mult, <- divides_nat2Zp in Hq2.
      destruct Hq2 as (d & Hd); exists d; subst m.
      rewrite <- Nat.mul_cancel_r with (1 := Hak).
      rewrite <- mult_assoc, Hd; ring.
    + subst m.
      apply divides_mult_inv in H; auto.
      destruct H as (g & Hg); subst l.
      rewrite divides_nat2Zp with (Hp := H2).
      rewrite Hq2, nat2Zp_mult. 
      do 2 rewrite <- Zp_mult_assoc.
      rewrite <- nat2Zp_mult, nat2Zp_p.
      do 2 rewrite (Zp_mult_comm _ _ (Zp_zero H2)), Zp_mult_zero.
      trivial.
  Qed.

End Zp_alpha_2.

Local Infix "│" := divides (at level 70, no associativity).

Section Pell.

  Variable (b_nat : nat) (Hb_nat : 2 <= b_nat).

  Fixpoint alpha_nat n := 
    match n with
      | 0   => 0
      | S p => match p with
        | 0   => 1
        | S r => b_nat * alpha_nat p - alpha_nat r
      end
    end.

  Fact alpha_nat_fix_0 : alpha_nat 0 = 0.    Proof. auto. Qed.
  Fact alpha_nat_fix_1 : alpha_nat 1 = 1.    Proof. auto. Qed.

  Fact alpha_nat_fix_2 n : alpha_nat (S (S n)) = b_nat *alpha_nat (S n) - alpha_nat n.
  Proof. auto. Qed.

  Fact alpha_nat_2 n : b_nat = 2 -> alpha_nat n = n.
  Proof.
    intros Hb.
    induction on n as IHn with measure n.
    destruct n as [ | [ | n ] ]; auto.
    rewrite alpha_nat_fix_2, Hb, IHn, IHn; omega.
  Qed.

  Fact alpha_nat_inc n : alpha_nat n < alpha_nat (S n).
  Proof.
    induction n as [ | n IHn ]; try (simpl; omega).
    rewrite alpha_nat_fix_2.
    replace b_nat with (2+(b_nat-2)) by omega.
    rewrite Nat.mul_add_distr_r.
    generalize ((b_nat -2)*alpha_nat (S n)); intro; omega.
  Qed.

  Corollary alpha_nat_mono i j : i <= j -> alpha_nat i <= alpha_nat j.
  Proof.
    induction 1 as [ | j H1 H2 ]; auto.
    apply le_trans with (1 := H2), lt_le_weak, alpha_nat_inc.
  Qed.

  Corollary alpha_nat_smono i j : i < j -> alpha_nat i < alpha_nat j.
  Proof.
    intros; apply lt_le_trans with (1 := alpha_nat_inc _), alpha_nat_mono; auto.
  Qed.

  Fact alpha_nat_ge_n n : n <= alpha_nat n.
  Proof.
    induction n as [ | n IHn ].
    + simpl; auto.
    + apply le_n_S in IHn.
      apply le_trans with (1 := IHn), alpha_nat_inc.
  Qed.

  Fact alpha_nat_gt_0 : forall n, n <> 0 -> alpha_nat n <> 0.
  Proof.
    intros [ | n ] H; try omega.
    generalize (alpha_nat_ge_n (S n)); omega.
  Qed.

  Fact alpha_nat_le n : alpha_nat n <= b_nat * alpha_nat (S n).
  Proof.
    apply le_trans with (1*alpha_nat (S n)).
    + apply lt_le_weak, lt_le_trans with (1 := alpha_nat_inc _); omega.
    + apply mult_le_compat; omega.
  Qed.

  Notation power := (mscal mult 1).

  Fact alpha_nat_power n : 2 < b_nat -> power n (b_nat-1) <= alpha_nat (S n) <= power n b_nat.
  Proof.
    intros Hb.
    induction on n as IHn with measure n.
    destruct n as [ | [ | n ] ].
    + do 2 rewrite power_0; simpl; omega.
    + do 2 rewrite power_1; simpl; omega.
    + rewrite alpha_nat_fix_2.
      destruct (IHn n) as (H1 & H2); try omega.
      destruct (IHn (S n)) as (H3 & H4); try omega.
      split.
      * replace b_nat with (b_nat-1+1) at 2 by omega.
        rewrite Nat.mul_add_distr_r.
        rewrite <- (Nat.add_sub_assoc (_*_)).
        - apply le_trans with (2 := le_plus_l _ _).
          rewrite power_S; apply mult_le_compat; auto.
        - rewrite Nat.mul_1_l; apply alpha_nat_mono; omega.
      * rewrite power_S.
        apply le_trans with (1 := Nat.le_sub_l _ _).
        apply mult_le_compat_l; auto.
  Qed.

  Open Scope Z.

  Let b := Z.of_nat b_nat.
  Let Hb : 2 <= b.
  Proof. apply inj_le with (n:= 2%nat); omega. Qed. 

  Definition alpha_Z n := 
    match n with 
      | 0%nat => -1
      | S n   => Z.of_nat (alpha_nat n)
    end.

  Notation α := alpha_Z.

  Hint Resolve alpha_nat_le.

  Fact alpha_Z_S n : α (S n) = Z.of_nat (alpha_nat n). Proof. auto. Qed.

  Fact alpha_fix_0 : α (0%nat) = -1.     Proof. auto. Qed.
  Fact alpha_fix_1 : α 1%nat = 0.        Proof. auto. Qed.
  Fact alpha_fix_2 : α 2%nat = 1.        Proof. auto. Qed.
  Fact alpha_fix_3 n : α (S (S n)) = b*α (S n) - α n.
  Proof.
    destruct n as [ | n ].
    1: simpl; ring.
    unfold α at 1.
    rewrite alpha_nat_fix_2.
    rewrite Nat2Z.inj_sub; auto.
    rewrite Nat2Z.inj_mul; auto.
  Qed.
 
  Fact alpha_inc n : α n < α (S n).
  Proof. 
    destruct n; simpl; try omega.
    apply inj_lt, alpha_nat_inc. 
  Qed.

  Fact alpha_ge_0 n : 0 <= α (S n).
  Proof.
    induction n as [ | n IHn ].
    + rewrite alpha_fix_1; omega.
    + apply Zlt_le_weak, Z.le_lt_trans with (2 := alpha_inc _); trivial.
  Qed.

  Opaque α.

  Create HintDb alpha_db.

  Hint Rewrite alpha_fix_0 alpha_fix_1 alpha_fix_2 alpha_fix_3 : alpha_db.

  Ltac alpha := autorewrite with alpha_db.

  Fact alpha_2 : b = 2 -> forall n, α n = Z.of_nat n - 1.
  Proof.
    intros H n.
    induction on n as IHn with measure n.
    destruct n as [ | [ | n ] ]; alpha; auto.
    do 2 (rewrite IHn; try omega).
    repeat rewrite Nat2Z.inj_succ.
    rewrite H; omega.
  Qed.

  Notation MZ := (M22 Z).

  Notation MZ_opp := (MI22 Z.opp).
  Notation MZ_plus := (PL22 Zplus).
  Notation MZ_mult := (MU22 Zplus Zmult).
  Notation MZ_zero := (ZE_22 0).
  Notation MZ_one := (ID_22 0 1).
  Notation MZ_scal := (M22scal Zmult).
  Notation MZ_expo := (mscal MZ_mult MZ_one).
  Notation MZ_det := (Det22 Zplus Zmult Z.opp).

  Local Fact MZ_plus_monoid : monoid_theory MZ_plus MZ_zero.
  Proof. apply M22plus_monoid with (1 := Zring). Qed.
 
  Local Fact MZ_mult_monoid : monoid_theory MZ_mult MZ_one.
  Proof. apply M22mult_monoid with (1 := Zring). Qed.

  Hint Resolve MZ_plus_monoid MZ_mult_monoid.
 
  Notation "⊟" := MZ_opp.
  Infix "⊞" := MZ_plus (at level 50, left associativity).
  Infix "⊠" := MZ_mult (at level 40, left associativity).

  Definition B  : MZ := (b,-1,1,0).
  Definition iB : MZ := (0,1,-1,b).

  Definition A n := (α (2+n),-α(1+n),α(1+n),-α n).
  Definition iA n := (-α n,α(1+n),-α(1+n),α (2+n)).

  Notation mI := (-1,0,0,-1).

  Fact B_iB : B ⊠ iB = MZ_one.
  Proof. apply M22_equal; ring. Qed.

  Fact iB_i : iB ⊠ B = MZ_one.
  Proof. apply M22_equal; ring. Qed.

  Fact A_is_sum k : A k = MZ_scal (-α k) MZ_one ⊞ MZ_scal (α (S k)) B.
  Proof.
    simpl; apply M22_equal; simpl; alpha; ring.
  Qed.

  Lemma MZ_expo_A n : MZ_expo n B = A n.
  Proof.
    induction n as [ | n IHn ].
    + rewrite mscal_0.
      unfold B, A; simpl.
      rewrite alpha_fix_2, alpha_fix_1, alpha_fix_0.
      apply M22_equal; ring.
    + rewrite mscal_S, IHn.
      apply M22_equal; simpl plus; try ring.
      - rewrite alpha_fix_3 with (n := S _); ring.
      - alpha; ring.
  Qed.

  Hint Resolve MZ_expo_A.

  Fact A_plus u v : A (u+v)%nat = A u ⊠ A v.
  Proof.
    rewrite <- MZ_expo_A, mscal_plus; auto.
    f_equal; auto.
  Qed.

  Fact A_mult u v : A (u*v)%nat = MZ_expo u (A v).
  Proof.
    rewrite <- MZ_expo_A, mscal_mult; auto.
    f_equal; auto.
  Qed.

  Fact A_plus_mult m n k l : 
          (m = n + l * k)%nat 
       -> A m = A n ⊠ MZ_expo l (A k).
  Proof.
    intro; subst; rewrite A_plus, A_mult; auto.
  Qed.

  Fact MZ_det_B : MZ_det B = 1.
  Proof. simpl; ring. Qed.

  Lemma MZ_det_A n : MZ_det (A n) = 1.
  Proof. 
    rewrite <- MZ_expo_A.
    rewrite Det22_expo with (Rminus := Z.sub); auto. 
    rewrite MZ_det_B.
    rewrite mscal_of_unit; auto.
  Qed.

  Definition Pell x y := x*x -b*x*y+y*y=1.

  Theorem alpha_Pell n : Pell (α (S n)) (α n).
  Proof.
    unfold Pell.
    generalize (MZ_det_A n).
    unfold A; simpl; intros H.
    rewrite <- H.
    rewrite alpha_fix_3; ring.
  Qed.

  Fact A_iA n : A n ⊠ iA n = MZ_one.
  Proof.
    generalize (alpha_Pell n); unfold Pell; intros H. 
    apply M22_equal; try ring; simpl; rewrite alpha_fix_3, <- H; ring.
  Qed.

  Fact iA_A n : iA n ⊠ A n = MZ_one.
  Proof.
    generalize (alpha_Pell n); unfold Pell; intros H. 
    apply M22_equal; try ring; simpl; rewrite alpha_fix_3, <- H; ring.
  Qed.

  Fact A_minus u v : (v <= u)%nat -> A (u-v)%nat = A u ⊠ iA v.
  Proof.
    intros H.
    rewrite <- (MZ_expo_A u).
    replace u with (u-v+v)%nat at 2 by omega.
    rewrite mscal_plus; auto.
    do 2 rewrite MZ_expo_A.
    rewrite <- M22mult_assoc with (1 := Zring).
    rewrite A_iA.
    rewrite M22mult_one_r with (1 := Zring).
    trivial.
  Qed.

  Section alpha_nat_coprime. 

    Let A_eq_3_12 n : exists u v, u*α (S n) + v*α n = 1.
    Proof.
      generalize (alpha_Pell n); unfold Pell; intros H. 
      exists (α (S n)-b*α n), (α n).
      rewrite <- H; ring.
    Qed.

    Lemma alpha_nat_coprime n : is_gcd (alpha_nat (S n)) (alpha_nat n) 1.
    Proof. apply Z_coprime, (A_eq_3_12 (S n)). Qed.

    Corollary alpha_nat_odd n : (rem (alpha_nat (S n)) 2 = 1 \/ rem (alpha_nat n) 2 = 1)%nat.
    Proof.
      destruct rem_2_is_0_or_1 with (x := alpha_nat (S n)) as [ H1 | ]; auto.
      destruct rem_2_is_0_or_1 with (x := alpha_nat n) as [ H2 | ]; auto.
      exfalso; generalize (alpha_nat_coprime n); intros (_ & _ & H3).
      destruct (H3 2%nat) as (? & ?); try omega; apply divides_rem_eq; auto.
    Qed.  

  End alpha_nat_coprime.

  Theorem find_odd_alpha u : exists n, (u <= alpha_nat (S n) /\ rem (alpha_nat (S n)) 2 = 1)%nat.
  Proof.
    destruct (alpha_nat_odd (S u)) as [ H | H ]; [ exists (S u) | exists u ]; split; auto;
      apply le_trans with (1 := alpha_nat_ge_n _), alpha_nat_mono; omega.
  Qed.

  Theorem find_odd_alpha' u : exists n, (u <= alpha_nat n /\ rem (alpha_nat n) 2 = 1)%nat.
  Proof.
    destruct (find_odd_alpha u) as (n & ?); exists (S n); auto.
  Qed.

  Notation expoZ := (mscal Zmult 1).

  Fact expoZ_power n x : expoZ n (Z.of_nat x) = Z.of_nat (power n x).
  Proof. 
    symmetry; apply mscal_morph; auto.
    intros; apply Nat2Z.inj_mul.
  Qed.

  Fact mscal_Zplus n : mscal Zplus 0 n 1 = Z.of_nat n.
  Proof.
    induction n as [ | n IHn ].
    + rewrite mscal_0; auto.
    + rewrite mscal_S, IHn.
      rewrite Nat2Z.inj_succ; ring.
  Qed.

  Notation "∑" := (msum MZ_plus MZ_zero).

  Theorem MA_expo_A_binomial m k l :
          (m = l * k)%nat 
       -> A m = ∑ (S l) (fun i => MZ_scal ( expoZ (l-i) (-1)
                                          * Z.of_nat (binomial l i) 
                                          * expoZ i (α (S k)) 
                                          * expoZ (l-i) (α k) ) 
                                     (MZ_expo i B)).
  Proof.
    intro; subst m.
    rewrite <- MZ_expo_A, mscal_mult, MZ_expo_A, A_is_sum; auto.
    rewrite binomial_Newton with (zero := MZ_zero); auto.
    2: apply M22plus_comm with (1 := Zring).
    2: apply M22plus_cancel with (1 := Zring).
    2: apply M22_mult_distr_l with (1 := Zring).
    2: apply M22_mult_distr_r with (1 := Zring).
    2: apply M22_equal; ring.
    apply msum_ext; intros i Hi.
    repeat rewrite expo22_scal with (1 := Zring).
    rewrite  mscal_of_unit; auto.
    rewrite <- M22scal_MU22_l with (1 := Zring).
    rewrite <- M22scal_MU22_r with (1 := Zring).
    rewrite M22mult_one_l with (1 := Zring).
    rewrite M22scal_mult with (1 := Zring).
    rewrite mscal_M22scal with (1 := Zring).
    rewrite M22scal_mult with (1 := Zring).
    f_equal.
    rewrite mscal_Zplus.
    replace (- α k) with ((-1)*α k) by ring.
    rewrite mscal_sum; auto; ring.
  Qed.

  Section A2m.

    Variable (l m v : nat) (Hv : Z.of_nat v = α (2+m) - α m).

    Fact alpha_SSm_m_neq_0 : v <> 0%nat.
    Proof. 
      intros H; subst; simpl in Hv.
      generalize (alpha_inc m) (alpha_inc (S m)); omega.
    Qed.

    Notation Hv' := alpha_SSm_m_neq_0.

    Let Z2Zp_morph := Z2Zp_morphishm Hv'.

    Notation f := (Z2Zp Hv').
    Notation "〚 x 〛" :=  (f x).
    Notation "〘 x 〙" := (morph22 f x).
    Notation "⊟" := (MI22 (Zp_opp Hv')).
    Infix "⊠" := (MU22 (Zp_plus Hv') (Zp_mult Hv')) (at level 40, left associativity).

    Let Am_iAm_mod :〘A m〙= ⊟〘iA m〙.
    Proof.
      apply M22_equal.
      + rewrite Z2Zp_opp, Zp_opp_inv.
        apply Z2Zp_inj.
        exists 1; rewrite Hv; ring.
      + rewrite Z2Zp_opp; auto.
      + rewrite Z2Zp_opp, Zp_opp_inv; auto.
      + rewrite <- Z2Zp_opp.
        apply Z2Zp_inj.
        exists 1; rewrite Hv; ring.
    Qed.
    
    Fact A2m_mod : 〘A (2*m)〙= ⊟〘MZ_one〙.
    Proof.
      rewrite <- MZ_expo_A, mscal_mult, MZ_expo_A; auto.
      rewrite mscal_S, mscal_1; auto.
      rewrite MU22_morph with (1 := Z2Zp_morph).
      rewrite Am_iAm_mod at 1.
      do 2 rewrite <- MI22_morph with (1 := Z2Zp_morph).
      rewrite <- MU22_morph with (1 := Z2Zp_morph).
      f_equal.
      rewrite M22_opp_mult_l with (1 := Zring); f_equal.
      apply iA_A.
    Qed.

    Fact A2lm_mod : 〘A (2*l*m)〙= 〘MZ_scal (mscal Zmult 1 l (-1)) MZ_one〙.
    Proof.
      replace (2*l*m)%nat with (l*(2*m))%nat by ring.
      rewrite <- MZ_expo_A, mscal_mult, MZ_expo_A; auto.
      rewrite expo22_morph with (1 := Z2Zp_morph).
      rewrite A2m_mod.
      rewrite <- MI22_morph with (1 := Z2Zp_morph).
      rewrite <- expo22_morph with (1 := Z2Zp_morph).
      f_equal.
      rewrite <- M22scal_MI22 with (1 := Zring).
      change (-(1)) with (-1).
      rewrite expo22_scal with (1 := Zring); f_equal.
      rewrite mscal_of_unit; auto.
    Qed.

    Let expoZ_opp1 i : expoZ i (-1) = 1 \/ expoZ i (-1) = -1.
    Proof.
      induction i as [ | i IHi ].
      + rewrite mscal_0; auto.
      + rewrite mscal_S; omega.
    Qed. 

    Variable (j : nat) (Hl : (l <> 0)%nat) (Hj : (j <= m)%nat).

    Fact alpha_2lm_plus_j :〚α (S (2*l*m+j))〛=〚expoZ l (-1)*α (S j)〛.
    Proof.
      generalize (A_plus (2*l*m) j); intros H.
      apply f_equal with (f := morph22 f) in H.
      rewrite MU22_morph with (1 := Z2Zp_morph) in H.
      rewrite A2lm_mod in H.
      rewrite <- MU22_morph with (1 := Z2Zp_morph) in H.
      apply M22_proj12 in H.
      rewrite Z.mul_0_r, Z.mul_0_l, Z.mul_1_r, Z.add_0_l in H.
      apply H.
    Qed.

    Let Hj' : (j <= 2*l*m)%nat.
    Proof.
      apply le_trans with (1*m)%nat; try omega.
      apply mult_le_compat; omega.
    Qed.

    Fact alpha_2lm_minus_j :〚α (S (2*l*m-j))〛=〚expoZ (S l) (-1)*α (S j)〛.
    Proof.
      generalize (A_minus Hj'); intros H.
      apply f_equal with (f := morph22 f) in H.
      rewrite MU22_morph with (1 := Z2Zp_morph) in H.
      rewrite A2lm_mod in H.
      rewrite <- MU22_morph with (1 := Z2Zp_morph) in H.
      apply M22_proj12 in H.
      rewrite Z.mul_0_r, Z.mul_0_l, Z.mul_1_r, Z.add_0_l in H.
      unfold plus in H; rewrite H; f_equal.
      rewrite mscal_S; ring.
    Qed.
  
    Theorem alpha_nat_2lm_plus_j : nat2Zp Hv' (alpha_nat (2*l*m+j)) = nat2Zp Hv' (alpha_nat j)
                                \/ nat2Zp Hv' (alpha_nat (2*l*m+j)) = Zp_opp Hv' (nat2Zp Hv' (alpha_nat j)).
    Proof.
      generalize (alpha_2lm_plus_j).
      destruct (expoZ_opp1 l) as [ E | E ]; rewrite E; intros H; [ left | right ].
      + repeat rewrite alpha_Z_S in H.
        rewrite Z2Zp_of_nat, Z.mul_1_l, Z2Zp_of_nat in H; auto.
      + repeat rewrite alpha_Z_S in H.
        change (-1) with (-(1)) in H.
        rewrite Z.mul_opp_l, Z.mul_1_l, Z2Zp_opp in H.
        repeat rewrite Z2Zp_of_nat in H; auto.
    Qed.

    Theorem alpha_nat_2lm_minus_j : nat2Zp Hv' (alpha_nat (2*l*m-j)) = nat2Zp Hv' (alpha_nat j)
                                 \/ nat2Zp Hv' (alpha_nat (2*l*m-j)) = Zp_opp Hv' (nat2Zp Hv' (alpha_nat j)).
    Proof.
      generalize (alpha_2lm_minus_j).
      destruct (expoZ_opp1 (S l)) as [ E | E ]; rewrite E; intros H; [ left | right ].
      + repeat rewrite alpha_Z_S in H.
        rewrite Z2Zp_of_nat, Z.mul_1_l, Z2Zp_of_nat in H; auto.
      + repeat rewrite alpha_Z_S in H.
        change (-1) with (-(1)) in H.
        rewrite Z.mul_opp_l, Z.mul_1_l, Z2Zp_opp in H.
        repeat rewrite Z2Zp_of_nat in H; auto.
    Qed.

  End A2m.

  Section expo_congruence.

    Variable (q : nat). 
   
    Notation m := (b_nat*q-q*q-1)%nat.

    Hypothesis Hm : m <> 0%nat.

    Let Hq : (1+q*q < b_nat*q)%nat.
    Proof. omega. Qed.

    Let VP : MZ := (Z.of_nat q,0,1,0).

    Notation Zm_ring := (Zp_is_ring Hm).

    Local Add Ring m_ring : Zm_ring.

    Notation qz := (Z.of_nat q).

    Let Z2Zp_morph := Z2Zp_morphishm Hm.

    Infix "⊕" := (Zp_plus Hm) (at level 50, left associativity).
    Infix "⊗" := (Zp_mult Hm) (at level 40, left associativity).
    Notation "∸" := (Zp_opp Hm).
    Notation f := (Z2Zp Hm).
    Notation "〚 x 〛" :=  (f x).
 
    Let qz_eq :〚b〛⊗〚qz〛 ⊕ ∸ (〚qz〛⊗〚qz〛 ⊕〚1〛) = Zp_zero Hm.
    Proof.
      do 2 rewrite <- Z2Zp_mult.
      rewrite <- Z2Zp_plus, <- Z2Zp_opp, <- Z2Zp_plus.
      unfold b.
      do 2 rewrite <- Nat2Z.inj_mul.
      change 1 with (Z.of_nat 1%nat).
      rewrite Z.add_opp_r, <- Nat2Z.inj_add, <- Nat2Z.inj_sub; try omega.
      rewrite Nat.sub_add_distr; fold m.
      rewrite Z2Zp_of_nat, nat2Zp_p; auto.
    Qed.

    Notation "〘 x 〙" := (morph22 f x).
    Infix "⊠" := (MU22 (Zp_plus Hm) (Zp_mult Hm)) (at level 40, left associativity).
    Notation scal := (M22scal (Zp_mult Hm)).

    Let BVP : 〘 B 〙 ⊠ 〘 VP 〙= scal〚qz〛〘 VP 〙.
    Proof.
      apply M22_equal; try rewrite Z2Zp_zero; try ring.
      change (-1) with (-(1)).
      rewrite Z2Zp_opp, Zp_opp_mult, <- (Z2Zp_mult _ 1).
      rewrite Z.mul_1_l, <- (Zp_plus_zero Hm), <- qz_eq.
      ring.
    Qed.    

    Let AnVP n :〘 A n 〙 ⊠ 〘 VP 〙= scal〚expoZ n qz〛〘 VP 〙.
    Proof.
      rewrite <- MZ_expo_A.
      induction n as [ | n IHn ].
      + do 2 rewrite mscal_0.
        apply M22_equal; try rewrite Z2Zp_zero; try rewrite Z2Zp_one; ring.
      + rewrite mscal_plus1; auto.
        rewrite MU22_morph with (1 := Z2Zp_morph).
        rewrite <- M22mult_assoc with (1 := Zm_ring).
        rewrite BVP.
        rewrite <- M22scal_MU22_r with (1 := Zm_ring).
        rewrite IHn, mscal_S, M22scal_mult with (1 := Zm_ring).
        f_equal.
        rewrite Z2Zp_mult; auto.
    Qed.

    Theorem expo_congruence_Z n : nat2Zp Hm q ⊗〚α (S n)〛=〚α n〛⊕ nat2Zp Hm (power n q).
    Proof.
      destruct Z2Zp_morph as [ G1 G2 G3 G4 G5 ].
      generalize (AnVP n); intros H.
      apply  M22_proj12 in H.
      rewrite Z2Zp_one in H. 
      do 2 rewrite Zp_mult_one_r in H.
      rewrite expoZ_power in H. 
      rewrite (Z2Zp_of_nat _ (power _ _)) in H.
      rewrite <- H, Z2Zp_of_nat. 
      simpl plus; rewrite Z2Zp_opp; ring.
    Qed.

    Theorem expo_congruence n : (0 < n)%nat -> nat2Zp Hm (q * alpha_nat n) = nat2Zp Hm (alpha_nat (n-1) + power n q).
    Proof.
      destruct n as [ | n ]; try omega.
      replace (S n-1)%nat with n by omega.
      rewrite nat2Zp_mult.
      generalize (expo_congruence_Z (S n)); intros H.
      do 2 rewrite alpha_Z_S in H.
      do 2 rewrite Z2Zp_of_nat in H.
      rewrite H, nat2Zp_plus; auto.
    Qed.

  End expo_congruence.

  Fact Pell_sym x y : Pell x y <-> Pell y x.
  Proof.
    unfold Pell; split; intros H; rewrite <- H; ring.
  Qed.

  Theorem Pell_zero_left y : Pell 0 y <-> y = 1 \/ y = -1.
  Proof.
    unfold Pell; split.
    + intros H.
      assert ((y-1)*(y+1) = 0) as H1.
      { ring_simplify in H.
        ring_simplify; omega. }
      apply  Zmult_integral in H1; omega.
    + intros [ | ]; subst; ring.
  Qed.

  Theorem Pell_zero_right x : Pell x 0 <-> x = 1 \/ x = -1.
  Proof.
    rewrite Pell_sym; apply Pell_zero_left.
  Qed.

  Theorem Pell_not_diag x : ~ Pell x x.
  Proof.   
    unfold Pell.
    intros H.
    assert (x*((2-b)*x) = 1) as H1.
    { rewrite <- H; ring. }
    generalize H1; intros H2.
    apply Z.eq_mul_1 in H1.
    destruct H1; subst; omega.
  Qed.

  Theorem Pell_opposite_not x y : y < 0 -> 0 < x -> ~ Pell x y.
  Proof.
    intros H1 H2 H3.
    red in H3.
    assert (0 <= - (b *x*y)) as H4.
    { replace (-(b*x*y)) with (b*x*-y) by ring.
      apply Z.mul_nonneg_nonneg; try omega.
      apply Z.mul_nonneg_nonneg; omega. }
    assert (0 < x*x) as H5.
    { apply Z.mul_pos_pos; auto. }
    assert (0 < y*y) as H6.
    { apply Z.mul_neg_neg; auto. }
    revert H3 H4 H5 H6.
    generalize (x*x) (y*y) (b*x*y); intros; omega.
  Qed.

  Theorem Pell_alpha x y : 0 <= y < x -> Pell x y -> { n | x = α (S (S n)) /\ y = α (S n) }.
  Proof.
    induction on x y as IH with measure (Z.to_nat y); intros Hxy HP.
    destruct (Z.eq_dec y 0) as [ Hy | Hy ].
    + exists 0%nat.
      rewrite alpha_fix_1, alpha_fix_2; split; auto.
      subst y; rewrite Pell_zero_right in HP; omega.
    + red in HP.
      assert (x*x = 1 + (b*y)*x - y*y) as H1.
      { rewrite <- HP; ring. }
      assert (0 < y*y) as H2.
      { apply Z.mul_pos_pos; omega. }
      assert (x <= (b*y)) as H3.
      { apply Zmult_le_reg_r with x; [ | rewrite H1 ]; omega. }
      assert (-(y*x) <= - (y*y)) as H4.
      { rewrite <- Z.opp_le_mono.
        apply Zmult_le_compat; omega. }
      assert (x > b*y-y) as H5.
      { apply Zmult_gt_reg_r with x; try omega.
        rewrite H1; rewrite Z.mul_sub_distr_r; omega. }
      destruct (IH y (b*y-x)) as (m & G1 & G2); try omega.
      - apply Z2Nat.inj_lt; omega.
      - red; rewrite <- HP; ring.
      - exists (S m); split; auto.
        rewrite alpha_fix_3, <- G2, <- G1; ring.
  Qed.

End Pell.

Theorem alpha_nat_Pell b n : 
    2 <= b -> alpha_nat b (S n)*alpha_nat b (S n) +  alpha_nat b n * alpha_nat b n  
            = 1 + b*(alpha_nat b (S n) * alpha_nat b n).
Proof.
  intros Hb.
  generalize (alpha_Pell Hb (S n)); intros H; red in H.
  unfold alpha_Z in H.
  apply Nat2Z.inj.
  repeat rewrite Nat2Z.inj_add.
  repeat rewrite Nat2Z.inj_mul.
  change (Z.of_nat 1) with (1%Z).
  rewrite <- H; ring.
Qed.

Theorem alpha_nat_Pell' b n : 
    2 <= b -> alpha_nat b n*alpha_nat b n +  alpha_nat b (S n) * alpha_nat b (S n)  
            = 1 + b*(alpha_nat b n * alpha_nat b (S n)).
Proof.
  rewrite plus_comm, (mult_comm (alpha_nat b n) (alpha_nat b (S n))).
  apply alpha_nat_Pell.
Qed.

Theorem Pell_alpha_nat b x y : 2 <= b -> y <= x -> x*x+y*y = 1+b*(x*y) -> { n | x = alpha_nat b (S n) /\ y = alpha_nat b n }.
Proof.
  intros Hb H2 H1.
  apply f_equal with (f := Z.of_nat) in H1.
  do 2 rewrite Nat2Z.inj_add in H1.
  do 4 rewrite Nat2Z.inj_mul in H1.
  simpl Z.of_nat in H1.
  apply Z.sub_move_r in H1.
  destruct (le_lt_dec x y) as [ H3 | H3 ].
  + revert H1; replace y with x by omega; clear y H2 H3; intros H1.
    exfalso.
    apply (@Pell_not_diag _ Hb (Z.of_nat x)); red.
    rewrite <- H1; ring.
  + destruct (@Pell_alpha _ Hb (Z.of_nat x) (Z.of_nat y)) as (n & P1 & P2).
    * split.
      - apply Zle_0_nat. 
      - apply inj_lt; trivial.
    * red; rewrite <- H1; ring.
    * unfold alpha_Z in P1, P2.
      apply Nat2Z.inj in P1.
      apply Nat2Z.inj in P2.
      exists n; auto.
Qed.

Corollary Pell_alpha_nat' b x y : 2 <= b -> x*x+y*y = 1+b*(x*y) -> { n | x = alpha_nat b n }.
Proof.
  intros H1 H2.
  destruct (le_lt_dec y x) as [ H3 | H3 ].
  + destruct Pell_alpha_nat with (3 := H2) as (n & ? & ?); auto.
    exists (S n); auto.
  + rewrite plus_comm, (mult_comm x y) in H2.
    destruct Pell_alpha_nat with (3 := H2) as (n & ? & ?); auto; try omega.
    exists n; auto.
Qed.

Theorem alpha_nat_2lm b n m l j v : 
          2 <= b 
       -> v = alpha_nat b (S (S m)) - alpha_nat b m
       -> arem n (S m) l j 
       -> rem (alpha_nat b n) v = rem (alpha_nat b j) v
       \/ rem (alpha_nat b n + alpha_nat b j) v = 0.
Proof.
  intros Hb Hv.
  assert (Hv' : Z.of_nat v = (alpha_Z b (S(2 + m)) - alpha_Z b (S m))%Z).
  { rewrite Hv.
    rewrite Nat2Z.inj_sub; auto.
    apply lt_le_weak, alpha_nat_smono; omega. }
  intros (Hk & [ Hl | (Hl1 & Hl2) ] ).
  + destruct alpha_nat_2lm_plus_j with (Hb_nat := Hb) (Hv := Hv') (l := l) (j := j) as [ H | H ].
    - rewrite nat2Zp_inj in H; subst; auto.
    - right; rewrite <- rem_of_0 with v.
      rewrite <- nat2Zp_inj with (Hp := alpha_SSm_m_neq_0 Hb (S m) Hv').
      rewrite nat2Zp_plus, Hl, H, Zp_plus_comm, Zp_minus, nat2Zp_zero; auto.
  + destruct alpha_nat_2lm_minus_j with (Hb_nat := Hb) (Hv := Hv') (l := l) (j := j) as [ H | H ]; auto.
    - rewrite nat2Zp_inj in H; subst; auto.
    - right; rewrite <- rem_of_0 with v.
      rewrite <- nat2Zp_inj with (Hp := alpha_SSm_m_neq_0 Hb (S m) Hv').
      rewrite nat2Zp_plus, Hl2, H, Zp_plus_comm, Zp_minus, nat2Zp_zero; auto.
Qed.

Section divisibility_1.

  Variable (b : nat) (Hb : 2 <= b) (k : nat) (Hk : k <> 0).

  Let Hak : alpha_nat b k <> 0.
  Proof. apply alpha_nat_gt_0; auto. Qed.

  Section equation.

    Variable (m n l : nat) (Hm : m = n+l*k).

    Infix "⊗" := (Zp_mult Hak) (at level 40, left associativity).
    Notation expo := (mscal (Zp_mult Hak) (Zp_one Hak)).

    Hint Resolve Zle_0_nat.

    Section in_Z.

      Notation "〚 x 〛" := (Z2Zp Hak x).  

      Let Z2ZP_morph := Z2Zp_morphishm Hak.

      Open Scope Z_scope.

      Fact A_k_morph22 : morph22 (Z2Zp Hak) (A b k) = (〚alpha_Z b (2+k)〛,Zp_zero Hak,Zp_zero Hak,〚-alpha_Z b k〛).
      Proof.
        destruct k as [ | k' ]; try omega.
        unfold A; apply M22_equal; auto;
        simpl plus; unfold alpha_Z.
        + rewrite Z2Zp_opp, Z2Zp_pos, Nat2Z.id, nat2Zp_p, Zp_opp_zero; auto.
        + rewrite Z2Zp_pos, Nat2Z.id, nat2Zp_p; auto.
      Qed.

      Lemma alpha_Z_mnlk_eq : 〚 alpha_Z b (1+m) 〛 = 〚 alpha_Z b (1+n) 〛⊗ expo l〚 alpha_Z b (2+k) 〛.
      Proof.
        generalize (A_plus_mult Hb _ _ _ Hm); intros H. 
        apply f_equal with (f := morph22 (Z2Zp Hak)) in H.
        rewrite MU22_morph with (1 := Z2ZP_morph) in H.
        rewrite expo22_morph with (1 := Z2ZP_morph) in H.
        rewrite A_k_morph22 in H.
        rewrite Diag22_expo with (1 := Zp_is_ring Hak) in H.
        unfold A, morph22 in H.
        rewrite MU22_Diag22 with (1 := Zp_is_ring Hak) in H.
        inversion H; auto.
      Qed.

    End in_Z.

    Section in_nat.

      Notation "〚 x 〛" := (nat2Zp Hak x).  

      Theorem alpha_nat_mnlk_eq : 〚 alpha_nat b m 〛 = 〚 alpha_nat b n 〛⊗ expo l〚 alpha_nat b (1+k) 〛.
      Proof.
        generalize alpha_Z_mnlk_eq.
        simpl plus.
        unfold alpha_Z.
        do 3 (rewrite Z2Zp_pos; auto).
        do 3 rewrite Nat2Z.id; auto.
      Qed.

    End in_nat.

  End equation.

  Theorem alpha_nat_divides_k_ge_1 m : alpha_nat b k │ alpha_nat b m <-> k │ m.
  Proof.
    split.
    + intros H1.
      destruct (euclid m Hk) as (l & [ | n ] & E1 & E2).
      { exists l; omega. }
      rewrite plus_comm in E1.
      generalize (alpha_nat_mnlk_eq _ _ E1); intros H2.
      rewrite <- nat2Zp_expo, <- nat2Zp_mult in H2.
      apply nat2Zp_divides in H2; auto.
      apply is_rel_prime_div_r in H2.
      2: apply is_rel_prime_expo, is_gcd_sym, alpha_nat_coprime; auto.
      apply divides_le in H2.
      * apply alpha_nat_smono with (1 := Hb) in E2; omega.
      * apply alpha_nat_gt_0; omega.
    + intros (l & Hl).
      generalize (alpha_nat_mnlk_eq 0 _ Hl); intros H2.
      rewrite <- nat2Zp_expo, <- nat2Zp_mult in H2.
      simpl in H2.
      rewrite nat2Zp_inj in H2.
      rewrite rem_of_0 in H2.
      generalize (div_rem_spec1 (alpha_nat b m) (alpha_nat b k)).
      exists (div (alpha_nat b m) (alpha_nat b k)); omega.
  Qed.

End divisibility_1.

Theorem alpha_nat_divisibility_1 b k m : 2 <= b -> alpha_nat b k │ alpha_nat b m <-> k │ m.
Proof.
  intros Hb.
  destruct (eq_nat_dec k 0) as [ | Hk ]; subst.
  + simpl; split; intros H; apply divides_0_inv in H.
    - destruct (eq_nat_dec m 0) as [ | Hm ]; subst.
      * apply divides_0.
      * generalize (alpha_nat_gt_0 Hb Hm); omega.
    - subst; apply divides_0.
  + apply alpha_nat_divides_k_ge_1; auto.
Qed.

Check alpha_nat_divisibility_1.
Print Assumptions alpha_nat_divisibility_1.

Section divisibility_2.

  Variable (b : nat) (Hb : 2 <= b) (k : nat) (Hk : k <> 0).

  Let Hak : alpha_nat b k <> 0.
  Proof. apply alpha_nat_gt_0; auto. Qed.

  Let ak2 := alpha_nat b k * alpha_nat b k.

  Let Hak2 : ak2 <> 0.
  Proof.
    unfold ak2; intros H.
    apply mult_is_O in H; destruct H as [ H | H ];
     revert H; apply alpha_nat_gt_0; auto. 
  Qed.

  Section equation.

    Variable (m l : nat) (Hm : m = l*k) (Hl : l <> 0).

    Infix "⊕" := (Zp_plus Hak2) (at level 50, left associativity).
    Infix "⊗" := (Zp_mult Hak2) (at level 40, left associativity).
    Notation expoZp := (mscal (Zp_mult Hak2) (Zp_one Hak2)).

    Hint Resolve Zle_0_nat.

    Section in_Zp.

      Notation "〚 x 〛" := (Z2Zp Hak2 x).  

      Let Z2Zp_morph := Z2Zp_morphishm Hak2.

      Open Scope Z_scope.

      Let Zmult_monoid : monoid_theory Zmult 1.
      Proof. exists; intros; ring. Qed.

      Notation MZp := (M22 ak2).
      Infix "⊞" := (PL22 (Zp_plus Hak2)) (at level 50, left associativity).
      Infix "⊠" := (MU22 (Zp_plus Hak2) (Zp_mult Hak2)) (at level 40, left associativity).
      Notation MZp_Z := (ZE_22 (Zp_zero Hak2)).
      Notation MZp_I := (ID_22 (Zp_zero Hak2) (Zp_one Hak2)).
      Notation MZp_expo := (mscal (fun u v => u⊠v) MZp_I).
      Notation MZp_scal := (M22scal (Zp_mult Hak2)).

      Fact A_m_morph22 : morph22 (Z2Zp Hak2) (A b m) 
                       = MZp_scal (expoZp l〚-1〛⊗ expoZp l〚alpha_Z b k〛) MZp_I
                       ⊞ MZp_scal (expoZp (l-1)〚-1〛⊗ nat2Zp Hak2 l ⊗ 〚alpha_Z b (S k)〛⊗ expoZp (l-1)〚alpha_Z b k〛) (morph22 (Z2Zp Hak2) (B b)).
      Proof.
        generalize (MA_expo_A_binomial Hb _ _ Hm); intros H.
        apply f_equal with (f := morph22 (Z2Zp Hak2)) in H.

        rewrite msum_morph with (m2 := fun u v => u⊞v) (u2 := MZp_Z) in H.
        2: simpl; apply M22_equal; apply Z2Zp_zero.
        2: intros (((?&?)&?)&?) (((?&?)&?)&?); apply M22_equal; apply Z2Zp_plus.

        rewrite msum_first_two in H; try omega.
        2: apply M22plus_monoid with (1 := Zp_is_ring Hak2).
        2: { intros i Hi.
             rewrite M22scal_morph with (1 := Z2Zp_morph).
             repeat rewrite Z2Zp_mult.
             replace i with (2+(i-2))%nat at 3 by omega.
             rewrite mscal_plus, Z2Zp_mult; auto.
             rewrite mscal_S, mscal_1; auto.
             unfold alpha_Z at 1 2.
             rewrite <- Nat2Z.inj_mul. 
             fold ak2.
             rewrite (@Z2Zp_pos _ Hak2 (Z.of_nat ak2)); auto.
             rewrite Nat2Z.id, nat2Zp_p. 
             repeat rewrite Zp_mult_zero.
             rewrite (Zp_mult_comm _ _ (Zp_zero _)).
             repeat rewrite Zp_mult_zero.
             apply M22scal_zero with (1 := Zp_is_ring Hak2). }

        rewrite H.
        repeat rewrite M22scal_morph with (1 := Z2Zp_morph).
        repeat rewrite Z2Zp_mult.
        rewrite binomial_n1; try omega.
        rewrite binomial_n0.
        rewrite Nat.sub_0_r.
        repeat rewrite mscal_0.
        repeat rewrite Z2Zp_one.
        f_equal.
        + f_equal; auto.
          2: apply M22_equal; try rewrite Z2Zp_one; auto; rewrite Z2Zp_zero; auto.
          rewrite <- mscal_morph with (m1 := Zmult) (u1 := 1).
          2: rewrite Z2Zp_one; auto.
          2: apply Z2Zp_mult.
          rewrite <- mscal_morph with (m1 := Zmult) (u1 := 1).
          2: rewrite Z2Zp_one; auto.
          2: apply Z2Zp_mult.
          repeat rewrite <- Zp_mult_assoc.
          repeat rewrite Zp_mult_one; auto.
        + repeat (rewrite mscal_1; auto).
          2: apply  M22mult_monoid with (1 := Zring).
          rewrite <- mscal_morph with (m1 := Zmult) (u1 := 1).
          2: rewrite Z2Zp_one; auto.
          2: apply Z2Zp_mult.
          rewrite <- mscal_morph with (m1 := Zmult) (u1 := 1).
          2: rewrite Z2Zp_one; auto.
          2: apply Z2Zp_mult.
          do 4 f_equal.
          rewrite Z2Zp_pos, Nat2Z.id; auto.
      Qed.

      Lemma alpha_Z_ml_eq : 〚 alpha_Z b (S m) 〛 
                          = expoZp (l-1) 〚-1〛
                          ⊗ nat2Zp Hak2 l
                          ⊗〚 alpha_Z b (S k) 〛
                          ⊗ expoZp (l-1)〚 alpha_Z b k 〛.
      Proof.
        generalize A_m_morph22; intros H.
        unfold morph22, A, B in H.
        unfold M22scal, PL22, MZp_I in H.
        apply M22_proj12 in H.
        unfold plus in H; rewrite H; clear H.
        rewrite Zp_mult_comm, Zp_mult_zero, Zp_plus_zero.
        rewrite Z2Zp_one, Zp_mult_comm, Zp_mult_one; auto.
      Qed.

    End in_Zp.

    Local Add Ring myring2 : (Zp_is_ring Hak2).

    Corollary alpha_square_nat : exists q, Zp_invertible Hak2 q /\ nat2Zp Hak2 (alpha_nat b m) = q ⊗ nat2Zp Hak2 l  ⊗ nat2Zp Hak2 (alpha_nat b k).
    Proof.
      exists (expoZp (l-1) (Z2Zp Hak2 (-1)) ⊗ expoZp (l-1) (Z2Zp Hak2 (alpha_Z b k))); split.
      + apply Zp_mult_invertible; apply Zp_expo_invertible.
        * apply Zp_opp_invertible. 
          rewrite <- Z2Zp_opp.
          replace (- (-1))%Z with 1%Z by omega.
          rewrite Z2Zp_one.
          apply Zp_one_invertible.
        * destruct k; try omega; simpl.
          rewrite Z2Zp_of_nat.
          apply nat2Zp_invertible.
          unfold ak2.
          apply is_gcd_sym, is_rel_prime_mult; 
            apply is_gcd_sym, alpha_nat_coprime; auto.
      + generalize alpha_Z_ml_eq; intros H.
        unfold alpha_Z in H at 1 2.
        do 2 rewrite Z2Zp_of_nat in H.
        rewrite H; ring.
    Qed.
  
  End equation.

  Theorem alpha_nat_divides_2_pos m : alpha_nat b k * alpha_nat b k │ alpha_nat b m <-> k*alpha_nat b k │ m.
  Proof.
    destruct m as [ | m ].
    + simpl; split; intros; apply divides_0.
    + destruct (divides_dec (S m) k) as [ (l & Hl) | C ].
      * apply Zp_alpha_congruence_2 with (1 := Hl) (H2 := Hak2); try omega.
        apply alpha_square_nat; auto.
        intro; subst; discriminate.
      * split; intros H; exfalso; apply C.
        - rewrite <- alpha_nat_divisibility_1 with (1 := Hb).
          apply divides_trans with (2 := H), divides_mult, divides_refl.
        - apply divides_trans with (2 := H).
          rewrite mult_comm.
          apply divides_mult, divides_refl.
  Qed.

End divisibility_2.

Theorem alpha_nat_divisibility_2 b k m : 
    2 <= b -> alpha_nat b k * alpha_nat b k │ alpha_nat b m <-> k*alpha_nat b k │ m.
Proof.
  intros Hb.
  destruct k as [ | k ].
  * simpl.
    destruct m as [ | m ]; try (simpl; tauto).
    split; intros H; apply divides_0_inv in H; try discriminate.
    contradict H; apply alpha_nat_gt_0; omega.
  * apply alpha_nat_divides_2_pos; omega.
Qed.

Check alpha_nat_divisibility_2.
Print Assumptions alpha_nat_divisibility_2.

Section congruence_1.

  Variable (b1 b2 : nat) (Hb1 : 2 <= b1) (Hb2 : 2 <= b2)
           (q : nat) (Hq : q <> 0) (Hb : nat2Zp Hq b1 = nat2Zp Hq b2).

  Hint Resolve Zle_0_nat.

  Theorem alpha_Z_congr n : Z2Zp Hq (alpha_Z b1 n) = Z2Zp Hq (alpha_Z b2 n).
  Proof.
    induction on n as IHn with measure n.
    destruct n as [ | [ | n ] ]; try reflexivity.
    do 2 (rewrite alpha_fix_3; auto).
    do 2 rewrite Z2Zp_minus, Z2Zp_mult.
    do 2 f_equal; try (apply IHn; omega).
    do 2 (rewrite Z2Zp_pos; auto).
    do 2 rewrite Nat2Z.id; auto.
  Qed.

End congruence_1.

Theorem alpha_nat_congruence_0 b1 b2 q n : 
           2 <= b1 
        -> 2 <= b2
        -> rem b1 q = rem b2 q 
        -> rem (alpha_nat b1 n) q = rem (alpha_nat b2 n) q.
Proof.
  intros H1 H2 H3.
  destruct (eq_nat_dec q 0) as [ H4 | H4 ].
  + subst; do 2 rewrite rem_0 in H3; subst; auto.
  + rewrite <- nat2Zp_inj with (Hp := H4) in H3.
    apply alpha_Z_congr with (n := S n) in H3; auto.
    simpl in H3.
    do 2 rewrite Z2Zp_of_nat in H3.
    rewrite nat2Zp_inj in H3.
    trivial.
Qed.

Corollary alpha_nat_congruence_1 b n : b-2 <> 0 -> rem (alpha_nat b n) (b-2) = rem n (b-2).
Proof.
  intros Hb.
  rewrite <- alpha_nat_2 with (b_nat := 2) (n := n) at 2; auto.
  apply alpha_nat_congruence_0; try omega.
  replace b with ((b-2)+2) at 1 by omega.
  apply rem_erase with 1; omega.
Qed.

Check alpha_nat_congruence_0.
Check alpha_nat_congruence_1.

Section congruence_2.

  Variable (b : nat) (Hb : b - 2 <> 0).

  Notation "〚 x 〛" := (Z2Zp Hb x).  

  Hint Resolve Zle_0_nat.

  Open Scope Z_scope.

  Theorem alpha_Z_b_2 n : 〚 alpha_Z b n 〛 = Zp_plus Hb 〚 Z.of_nat n 〛〚 -1 〛.
  Proof.
    rewrite <- Z2Zp_plus.
    replace (Z.of_nat n + -1) with (Z.of_nat n -1) by omega.
    rewrite <- (@alpha_2 2); auto.
    apply alpha_Z_congr; try omega.
    replace b with (2+(b-2))%nat at 3 by omega.
    rewrite nat2Zp_plus.
    rewrite nat2Zp_p, Zp_plus_comm, Zp_plus_zero; auto.
  Qed.

End congruence_2.

Lemma rem_eq_eq a b v : 2*a < v -> 2*b < v -> rem a v = rem b v -> a = b.
Proof.
  intros H1 H2 H3.
  do 2 (rewrite rem_lt in H3; try omega).
Qed.

Lemma rem_eq_diff_eq a b v : 2*a < v -> 2*b < v -> (rem a v = rem b v) \/ (rem (a+b) v = 0) -> a = b.
Proof.
  intros H1 H2 [ H3 | H3 ].
  + do 2 (rewrite rem_lt in H3; try omega).
  + rewrite rem_lt in H3; omega.
Qed.

Section diophantine_sufficiency.

  Variables (a b c : nat) (u t r s v w x y : nat).

  Definition alpha_conditions :=
                    3 < b
                 /\ u*u+t*t = 1+b*(u*t)
                 /\ s*s+r*r = 1+b*(s*r)
                 /\ r < s
                 /\ u*u │ s
                 /\ v+2*r = b*s
                 /\ rem w v = rem b v
                 /\ rem w u = rem 2 u
                 /\ 2 < w
                 /\ x*x+y*y = 1+w*(x*y)
                 /\ 2*a < u
                 /\ 2*a < v
                 /\ rem a v = rem x v
                 /\ 2*c < u
                 /\ rem c u = rem x u.

  Theorem alpha_sufficiency : alpha_conditions -> 3 < b /\ a = alpha_nat b c.
  Proof.
    intros (H41 & H42 & H43 & H44 & H45 & H46 & H47 & H48 & H49 & H50 &
            H51 & H52 & H53 & H54 & H55).
    split; auto.
    destruct Pell_alpha_nat' with (2 := H42) as (k & Hu); try omega.
    destruct Pell_alpha_nat with (3 := H43) as (m & Hs & Hr); try omega.
    destruct Pell_alpha_nat' with (2 := H50) as (n & Hx); try omega.
    destruct (@division_by_even n (S m)) as (l & j & Hlj); try omega.
    assert (divides (k*u) (S m)) as H60'.
    { subst u s; apply alpha_nat_divisibility_2; try omega; auto. }
    assert (divides u (S m)) as H60.
    { apply divides_trans with (2 := H60'), divides_mult, divides_refl. }
    assert (v = alpha_nat b (S (S m)) - alpha_nat b m) as H61.
    { rewrite alpha_nat_fix_2, <- Hs, <- Hr; omega. }
    assert (rem x v = rem (alpha_nat b n) v) as H62_1.
    { rewrite Hx; apply alpha_nat_congruence_0; omega. }
    assert (rem x u = rem n u) as H65.
    { rewrite Hx, alpha_nat_congruence_0 with (3 := H48); try omega.
      f_equal; apply alpha_nat_2; auto. }
    assert (2 <= b) as Hb by omega.
    generalize (alpha_nat_2lm Hb H61 Hlj); intros H62_2.
    assert (2*alpha_nat b j < v) as H63.
    { apply le_lt_trans with ((b-2)*alpha_nat b (S m)).
      { apply mult_le_compat; try omega.
        red in Hlj; apply alpha_nat_mono; tauto. }
      apply plus_lt_reg_l with (2*r).
      rewrite (plus_comm _ v), H46, Hr, Hs.
      replace b with (2+(b-2)) at 4 by omega.
      rewrite Nat.mul_add_distr_r.
      apply plus_lt_le_compat; auto.
      apply mult_lt_compat_l; auto.
      apply alpha_nat_inc; auto. }
    rewrite plus_comm, <- rem_plus_rem, <- H62_1, <- H53, rem_plus_rem, plus_comm in H62_2.
    apply rem_eq_diff_eq in H62_2; auto.
    assert (2*j < u) as H66.
    { apply le_lt_trans with (2 := H51), mult_le_compat; auto.
      subst; apply alpha_nat_ge_n; auto. }
    rewrite <- H55 in H65.
    assert (c = j) as H67.
    { destruct H60 as (q & Hq).
      destruct Hlj as (G1 & [ G2 | (G2 & G3) ]).
      + apply rem_eq_diff_eq with u; auto.
        left.
        rewrite H65, rem_erase with (n := 2*l*q) (r := j); auto.
        rewrite G2, Hq; ring.
      + apply rem_eq_diff_eq with u; auto.
        right.
        rewrite plus_comm, <- rem_plus_rem, H65, rem_plus_rem, G3.
        apply rem_prop with (2*l*q); try omega.
        rewrite Hq, mult_assoc.
        assert (2*l*q <> 0) as G4.
        { intros H.
          apply mult_is_O in H; destruct H as [ H | H ]; try (subst; discriminate).
          apply mult_is_O in H; destruct H; omega. }
        assert (1*u <= 2*l*q*u).
        { apply mult_le_compat; auto.
          revert G4; generalize (2*l*q); intros; omega. }
        rewrite Nat.mul_1_l in H.
        revert H; generalize (2*l*q*u); intros; omega. }
    subst; auto.
  Qed.

End diophantine_sufficiency.

Section diophantine_necessity.

  Variables (a b c : nat).

  Theorem alpha_necessity : 3 < b /\ a = alpha_nat b c -> exists u t r s v w x y, alpha_conditions a b c u t r s v w x y.
  Proof.
    intros (H1 & H2).
    assert (2 <= b) as Hb by omega.
    destruct find_odd_alpha' with (b_nat := b) (u := 1+2*a+2*c) as (k & Hk1 & Hk2); try omega.
    remember (alpha_nat b k) as u.
    remember (alpha_nat b (S k)) as t.
    remember (u*k) as m.
    destruct m as [ | m ].
    { symmetry in Heqm.
      apply mult_is_O in Heqm.
      destruct Heqm; subst; try omega.
       rewrite alpha_nat_fix_0, rem_of_0 in Hk2; discriminate. }
    remember (alpha_nat b m) as r.
    remember (alpha_nat b (S m)) as s.
    assert (s*s+r*r = 1+b*(s*r)) as Hrs.
    { rewrite Heqr, Heqs; apply alpha_nat_Pell; auto. }
    assert (k <> 0) as Hk.
    { intro; subst; discriminate. }
    assert (divides (u*u) s) as Hus.
    { rewrite Hequ, Heqs.
      apply alpha_nat_divisibility_2; auto.
      rewrite <- Hequ, Heqm, mult_comm.
      apply divides_refl. }
    assert (2*a < b*s - 2*r) as H3.
    { apply lt_le_trans with (2*u).
      { apply mult_lt_compat_l; omega. }
      apply le_trans with (2*(S m)).
      { apply mult_le_compat_l; rewrite Heqm.
        rewrite <- (Nat.mul_1_r u) at 1.
        apply mult_le_compat; omega. }
      apply le_trans with (2*alpha_nat b (S m)).
      { apply mult_le_compat_l.
        apply le_trans with (1 := alpha_nat_ge_n Hb _).
        apply alpha_nat_mono; omega. }
      apply le_trans with (4*s - 2*r).
      { rewrite Heqs, Heqr.
        generalize (alpha_nat_inc Hb m); intros; omega. }
      apply Nat.sub_le_mono_r, mult_le_compat_r; omega. }
    remember (b*s-2*r) as v.
    assert (is_gcd u v 1) as Huv.
    { split; [ | split ]; try apply divides_1.
      intros d Hd1 Hd2.
      assert (divides d s) as F1.
      { apply divides_trans with (2 := Hus).
        apply divides_trans with (1 := Hd1).
        apply divides_mult, divides_refl. }
      assert (divides d (2*r)) as F2.
      { apply divides_plus_inv with (1 := Hd2).
        replace (v+2*r) with (b*s) by omega.
        apply divides_mult; auto. }
      apply is_rel_prime_div in F2.
      + apply divides_plus_inv with (b*(s*r)).
        * do 2 apply divides_mult; auto.
        * rewrite plus_comm, <- Hrs.
          apply divides_plus; apply divides_mult; auto.
      + apply is_gcd_sym, no_common_prime_is_coprime; try discriminate.
        intros z G0 G1 G2.
        apply divides_2_inv in G1; destruct G1; subst z.
        destruct G0; omega.
        replace (rem u 2) with 0 in Hk2; try discriminate.
        symmetry; apply divides_rem_eq; try discriminate.
        apply divides_trans with (1 := G2); auto. }
    assert (exists w, rem w u = rem 2 u /\ rem w v = rem b v /\ 2 < w) as Hw.
    { apply CRT; auto; try omega. }
    destruct Hw as (w & Hw1 & Hw2 & Hw3).
    remember (alpha_nat w c) as x.
    remember (alpha_nat w (S c)) as y.
    exists u, t, r, s, v, w, x, y; repeat (split; auto); 
      try (subst; (apply alpha_nat_Pell || apply alpha_nat_Pell' || apply alpha_nat_inc)); try omega; auto.
    + rewrite Heqx, alpha_nat_congruence_0 with (3 := Hw2), H2; try omega.
    + rewrite Heqx; symmetry.
      rewrite alpha_nat_congruence_0 with (3 := Hw1); try omega.
      f_equal; apply alpha_nat_2; omega.
  Qed.

End diophantine_necessity.

Theorem alpha_diophantine a b c : 3 < b /\ a = alpha_nat b c 
                              <-> exists u t r s v w x y, alpha_conditions a b c u t r s v w x y.
Proof.
  split.
  + apply alpha_necessity.
  + intros (u & t & r & s & v & w & x & y & H); revert H.
    apply alpha_sufficiency.
Qed.

