

Require Import Arith Nat Omega List.

Require Import utils_tac sums rel_iter binomial. 
(* utils_tac:
Require Import Arith List Wellfounded.

Set Implicit Arguments.

Definition eqdec X := forall x y : X, { x = y } + { x <> y }.

Definition swap {X Y} (c : X * Y) := let (x,y) := c in (y,x).

Theorem measure_rect X (m : X -> nat) (P : X -> Type) :
      (forall x, (forall y, m y < m x -> P y) -> P x) -> forall x, P x.

Tactic Notation "induction" "on" hyp(x) "as" ident(IH) "with" "measure" uconstr(f) :=
  pattern x; revert x; apply measure_rect with (m := fun x => f); intros x IH.

Tactic Notation "eq" "goal" hyp(H) := 
  match goal with 
    |- ?b => match type of H with ?t => replace b with t; auto end 
  end.

Ltac eqgoal := let H := fresh in intro H; eq goal H; clear H.

Tactic Notation "spec" "in" hyp(H) :=
  let Q := fresh 
  in match goal with G: ?h -> _ |- _ => 
       match G with 
         | H => assert (h) as Q; [ | specialize (H Q); clear Q ] 
       end 
     end.

Ltac solve_list_eq := simpl; repeat progress (try rewrite app_ass; try rewrite <- app_nil_end; simpl; auto); auto.

Tactic Notation "solve" "list" "eq" := solve_list_eq.

Tactic Notation "solve_list_eq" "in" hyp(H) := generalize H; clear H; solve_list_eq; intro H.

Tactic Notation "solve" "list" "eq" "in" hyp(H) := 
   let Q := fresh in 
   match goal with 
     |- ?t => set (Q := t); generalize H; clear H; solve_list_eq; intro H; unfold Q; clear Q
   end.

Ltac msplit n := 
  match n with 
    | 0    => idtac 
    | S ?n => split; [ | msplit n ]
   end.

Tactic Notation "define" ident(f) "of" hyp(n) hyp(m) "as" uconstr(t)  :=
  match type of n with ?N =>  
    match type of m with ?M  => pose (f (n:N) (m:M) := t) end end.

Tactic Notation "induction" "on" hyp(x) hyp(y) "as" ident(IH) "with" "measure" uconstr(f) :=
  generalize I; intro IH;
  let mes := fresh "measure" in let rel := fresh "relation" in let loop := fresh "loop" in
  let u := fresh "u" in let u' := fresh x in let Hu := fresh "Hu" in 
  let v := fresh "v" in let v' := fresh y in let Hv := fresh "Hv" 
  in clear IH; 
     define mes of x y as (f : nat);
     set (rel u v := mes (fst u) (snd u) < mes (fst v) (snd v)); unfold fst, snd in rel;
     pattern x, y; match goal with
       |- ?T _ _ => 
       refine ((fix loop u v (Hu : Acc rel (u,v)) { struct Hu } : T u v := _) x y _);
       [ assert (forall u' v', rel (u',v') (u,v) -> T u' v') as IH;
         [ intros u' v' Hv; apply (loop u' v'), (Acc_inv Hu), Hv 
         | unfold rel, mes in *; clear mes rel Hu loop x y; rename u into x; rename v into y ]
       | unfold rel; apply wf_inverse_image, lt_wf ]
     end.

Section forall_equiv.

  Variable (X : Type) (A P Q : X -> Prop) (HPQ : forall n, A n -> P n <-> Q n).

  Theorem forall_bound_equiv : (forall n, A n -> P n) <-> (forall n, A n -> Q n).

End forall_equiv.

Section exists_equiv.

  Variable (X : Type) (P Q : X -> Prop) (HPQ : forall n, P n <-> Q n).

  Theorem exists_equiv : (exists n, P n) <-> (exists n, Q n).

End exists_equiv. *)
(* sums:
Require Import List Arith Omega Eqdep_dec ZArith.

Require Import utils_tac utils_list binomial.

Set Implicit Arguments.

Record monoid_theory (X : Type) (m : X -> X -> X) (u : X) := mk_monoid {
  monoid_unit_l : forall x, m u x = x;
  monoid_unit_r : forall x, m x u = x;
  monoid_assoc  : forall x y z, m x (m y z) = m (m x y) z;
}.

Fact Nat_plus_monoid : monoid_theory plus 0.

Fact Nat_mult_monoid : monoid_theory mult 1.

Fact Zplus_monoid : monoid_theory Zplus 0%Z.

Fact Zmult_monoid : monoid_theory Zmult 1%Z.

Hint Resolve Nat_plus_monoid Nat_mult_monoid
             Zplus_monoid Zmult_monoid.

Section msum.

  Variable (X : Type) (m : X -> X -> X) (u : X).

  Infix "‚äï" := m (at level 50, left associativity).

  Fixpoint msum n f := 
    match n with 
      | 0   => u
      | S n => f 0 ‚äï msum n (fun n => f (S n))
    end.

  Notation "‚àë" := msum.

  Fact msum_fold_map n f : ‚àë n f = fold_right m u (map f (list_an 0 n)).

  Fact msum_0 f : ‚àë 0 f = u.

  Fact msum_S n f : ‚àë (S n) f = f 0 ‚äï ‚àë n (fun n => f (S n)).

  Hypothesis Hmonoid : monoid_theory m u.

  Fact msum_1 f : ‚àë 1 f = f 0.

  Fact msum_plus a b f : ‚àë (a+b) f = ‚àë a f ‚äï ‚àë b (fun i => f (a+i)).

  Fact msum_plus1 n f : ‚àë (S n) f = ‚àë n f ‚äï f n.

  Fact msum_ext n f g : (forall i, i < n -> f i = g i) -> ‚àë n f = ‚àë n g.

  Fact msum_unit n : ‚àë n (fun _ => u) = u.

  Fact msum_comm a n f : (forall i, i < n -> f i ‚äï a = a ‚äï f i) -> ‚àë n f ‚äï a = a ‚äï ‚àë n f.

  Fact msum_sum n f g : (forall i j, i < j < n -> f j ‚äï g i = g i ‚äï f j) -> ‚àë n (fun i => f i ‚äï g i) = ‚àë n f ‚äï ‚àë n g.

  Fact msum_of_unit n f : (forall i, i < n -> f i = u) -> ‚àë n f = u.

  Fact msum_only_one n f i : i < n
                          -> (forall j, j < n -> i <> j -> f j = u)
                          -> ‚àë n f = f i.

  Fact msum_msum n k f :
          (forall i1 j1 i2 j2, i1 < n -> j1 < k -> i2 < n -> j2 < k -> f i1 j1 ‚äï f i2 j2 = f i2 j2 ‚äï f i1 j1)
       -> ‚àë n (fun i => ‚àë k (f i)) = ‚àë k (fun j => ‚àë n (fun i => f i j)).

  Fact msum_ends n f : (forall i, 0 < i <= n -> f i = u) -> ‚àë (n+2) f = f 0 ‚äï f (S n).

  Fact msum_first_two n f : 2 <= n -> (forall i, 2 <= i -> f i = u) -> ‚àë n f = f 0 ‚äï f 1.

  Definition mscal n x := msum n (fun _ => x).

  Fact mscal_0 x : mscal 0 x = u.

  Fact mscal_S n x : mscal (S n) x = x ‚äï mscal n x.

  Fact mscal_1 x : mscal 1 x = x.

  Fact mscal_of_unit n : mscal n u = u.

  Fact mscal_plus a b x : mscal (a+b) x = mscal a x ‚äï mscal b x.

  Fact mscal_plus1 n x : mscal (S n) x = mscal n x ‚äï x.

  Fact mscal_comm n x y : x ‚äï y = y ‚äï x -> mscal n x ‚äï y = y ‚äï mscal n x.

  Fact mscal_sum n x y : x ‚äï y = y ‚äï x -> mscal n (x ‚äï y) = mscal n x ‚äï mscal n y.

  Fact mscal_mult a b x : mscal (a*b) x = mscal a (mscal b x).

  Fact msum_mscal n k f : (forall i j, i < n -> j < n -> f i ‚äï f j = f j ‚äï f i) 
                       -> ‚àë n (fun i => mscal k (f i)) = mscal k (‚àë n f).

End msum.

Section msum_morphism.

  Variable (X Y : Type) (m1 : X -> X -> X) (u1 : X) 
                        (m2 : Y -> Y -> Y) (u2 : Y)
           (H1 : monoid_theory m1 u1)
           (H2 : monoid_theory m2 u2)
           (phi : X -> Y)
           (Hphi1 : phi u1 = u2)
           (Hphi2 : forall x y, phi (m1 x y) = m2 (phi x) (phi y)).

  Fact msum_morph n f : phi (msum m1 u1 n f) = msum m2 u2 n (fun x => phi (f x)).

  Fact mscal_morph n x : phi (mscal m1 u1 n x) = mscal m2 u2 n (phi x).

End msum_morphism.

Section binomial_Newton.

  Variable (X : Type) (sum times : X -> X -> X) (zero one : X).

  Infix "‚äï" := sum (at level 50, left associativity).
  Infix "‚äó" := times (at level 40, left associativity).
  
  Notation z := zero.
  Notation o := one.

  Notation scal := (mscal sum zero).
  Notation expo := (mscal times one).

  Hypothesis (M_sum : monoid_theory sum zero) 
             (sum_comm : forall x y, x ‚äï y = y ‚äï x)
             (sum_cancel : forall x u v, x ‚äï u = x ‚äï v -> u = v)
             (M_times : monoid_theory times one)
             (distr_l : forall x y z, x ‚äó (y‚äïz) = x‚äóy ‚äï x‚äóz)
             (distr_r : forall x y z, (y‚äïz) ‚äó x = y‚äóx ‚äï z‚äóx).

  Fact times_zero_l x : z ‚äó x = z.

  Fact times_zero_r x : x ‚äó z = z.

  Notation "‚àë" := (msum sum zero).

  Fact sum_0n_scal n k f : ‚àë n (fun i => scal k (f i)) = scal k (‚àë n f).

  Fact scal_times k x y : scal k (x‚äóy) = x‚äóscal k y.

  Fact scal_one_comm k x : scal k o ‚äó x = x ‚äó scal k o.

  Corollary scal_one k x : scal k x = scal k o ‚äó x.

  Fact sum_0n_distr_l b n f : ‚àë n (fun i => b‚äóf i) = b‚äó‚àë n f.

  Fact sum_0n_distr_r b n f : ‚àë n (fun i => f i‚äób) = ‚àë n f ‚äó b.

  Theorem binomial_Newton n a b :
        a ‚äó b = b ‚äó a
     -> expo n (a ‚äï b) = ‚àë (S n) (fun i => scal (binomial n i) (expo (n - i) a ‚äó expo i b)).

End binomial_Newton.

Section Newton_nat.

  Notation power := (mscal mult 1).
  Notation "‚àë" := (msum plus 0).

  Fact sum_fold_map n f : ‚àë n f = fold_right plus 0 (map f (list_an 0 n)).

  Fact power_0 x : power 0 x = 1.

  Fact power_S n x : power (S n) x = x * power n x.

  Fact power_1 x : power 1 x = x.

  Fact power_of_0 n : 0 < n -> power n 0 = 0.

  Fact power_of_1 n : power n 1 = 1.

  Fact power_plus p a b : power (a+b) p = power a p * power b p.

  Fact power_mult p a b : power (a*b) p = power a (power b p).
  
  Fact power_ge_1 k p : p <> 0 -> 1 <= power k p.

  Fact power2_gt_0 n : 0 < power n 2.

  Fact power_sinc k p : 2 <= p -> power k p < power (S k) p.

  Fact power_ge_n k p : 2 <= p -> k <= power k p.

  Fact power_mono_l p q x : 1 <= x -> p <= q -> power p x <= power q x.

  Definition power_mono := power_mono_l.
  
  Fact power_smono_l p q x : 2 <= x -> p < q -> power p x < power q x.

  Fact power_mono_r n p q : p <= q -> power n p <= power n q.

  Fact power_0_inv p n : power p n = 0 <-> n = 0 /\ 0 < p.

  Fact plus_cancel_l : forall a b c, a + b = a + c -> b = c.

  Let plus_cancel_l':= plus_cancel_l.

  Fact sum_0n_scal_l n k f : ‚àë n (fun i => k*f i) = k*‚àë n f.

  Fact sum_0n_scal_r n k f : ‚àë n (fun i => (f i)*k) = (‚àë n f)*k.

  Fact sum_0n_mono n f g : (forall i, i < n -> f i <= g i) -> ‚àë n f <= ‚àë n g.

  Fact sum_0n_le_one n f i : i < n -> f i <= ‚àë n f.

  Fact sum_power_lt k n f : k <> 0 -> (forall i, i < n -> f i < k) -> ‚àë n (fun i => f i * power i k) < power n k.

  Theorem Newton_nat a b n :
       power n (a + b) = ‚àë (S n) (fun i => binomial n i * power (n - i) a * power i b).

  Theorem Newton_nat_S a n :
       power n (1 + a) = ‚àë (S n) (fun i => binomial n i * power i a).

  Lemma binomial_le_power n i : binomial n i <= power n 2.

  Corollary binomial_lt_power n i : binomial n i < power (S n) 2.

End Newton_nat. *)
(* rel_iter:
Require Import Arith Nat Omega.
Require Import utils_tac gcd prime binomial sums.

Set Implicit Arguments.

Section rel_iter.

  Variable (X : Type) (R : X -> X -> Prop).

  Fixpoint rel_iter n :=
    match n with
      | 0   => eq
      | S n => fun x z => exists y, R x y /\ rel_iter n y z
    end.

  Fact rel_iter_plus n m x y : rel_iter (n+m) x y <-> exists a, rel_iter n x a /\ rel_iter m a y.

  Fact rel_iter_1 x y : rel_iter 1 x y <-> R x y.

  Fact rel_iter_S n x y : rel_iter (S n) x y <-> exists a, rel_iter n x a /\ R a y.

  Fact rel_iter_sequence n x y : rel_iter n x y <-> exists f, f 0 = x /\ f n = y /\ forall i, i < n -> R (f i) (f (S i)).

End rel_iter.

Local Notation power := (mscal mult 1).

Definition is_digit c q i y := y < q /\ exists a b, c = (a*q+y)*power i q+b /\ b < power i q.

Fact is_digit_fun c q i x y : is_digit c q i x -> is_digit c q i y -> x = y.

Definition is_seq (R : nat -> nat -> Prop) c q n := forall i, i < n -> exists y y', is_digit c q i y /\ is_digit c q (1+i) y' /\ R y y'.

Section rel_iter_bound.

  Variable (R : nat -> nat -> Prop) (k : nat) (Hk1 : forall x y, R x y -> y <= k*x).

  Let Hk' : forall x y, R x y -> y <= (S k)*x.

  Definition rel_iter_bound n x y := exists q c, x*power n (S k) < q /\ is_seq R c q n /\ is_digit c q 0 x /\ is_digit c q n y.

  Lemma rel_iter_bound_iter n x y : rel_iter_bound n x y -> rel_iter R n x y.

  Notation power := (mscal mult 1).
  Notation "‚àë" := (msum plus 0).

  Lemma rel_iter_iter_bound n x y : rel_iter R n x y -> rel_iter_bound n x y.

  Hint Resolve rel_iter_bound_iter rel_iter_iter_bound.

  Theorem rel_iter_bound_equiv n x y : rel_iter R n x y <-> rel_iter_bound n x y.

End rel_iter_bound.

Section rel_iter_seq.

  Variable (R : nat -> nat -> Prop).

  Definition rel_iter_seq n x y := exists q c, is_seq R c q n /\ is_digit c q 0 x /\ is_digit c q n y.

  Lemma rel_iter_seq_iter n x y : rel_iter_seq n x y -> rel_iter R n x y.

  Notation power := (mscal mult 1).
  Notation "‚àë" := (msum plus 0).

  Lemma rel_iter_iter_seq n x y : rel_iter R n x y -> rel_iter_seq n x y.

  Hint Resolve rel_iter_seq_iter rel_iter_iter_seq.

  Theorem rel_iter_seq_equiv n x y : rel_iter R n x y <-> rel_iter_seq n x y.

End rel_iter_seq. *)
(* binomial:
Require Import Arith Omega.

Require Import utils_tac gcd.

Set Implicit Arguments.

Section factorial.

  Fixpoint fact n := match n with 0 => 1 | S n => (S n) * fact n end.

  Fact fact_0 : fact 0 = 1.

  Fact fact_S n : fact (S n) = (S n)*fact n.

  Fact fact_gt_0 n : 0 < fact n.

End factorial.

Section binomial.

  Infix "<d" := divides (at level 70, no associativity).

  Hint Resolve divides_refl.

  Let fact_neq_0 n : fact n <> 0.

  Fixpoint binomial n p :=
    match n, p with
      | n, 0     => 1
      | 0, S _   => 0
      | S n, S p => binomial n p + binomial n (S p)
    end.

  Fact binomial_n0 n : binomial n 0 = 1.

  Fact binomial_SS n p : binomial (S n) (S p) = binomial n p + binomial n (S p).

  Fact binomial_n1 n : 1 <= n -> binomial n 1 = n.

  Fact binomial_gt n : forall p, n < p -> binomial n p = 0.

  Fact binomial_nn n : binomial n n = 1.

  Theorem binomial_thm n p : p <= n -> fact n = binomial n p * fact p * fact (n-p).

  Fact binomial_le n p : p <= n -> binomial n p = div (fact n) (fact p * fact (n-p)).

  Fact binomial_sym n p : p <= n -> binomial n p = binomial n (n-p).

  Fact binomial_spec n p : p <= n -> fact n = binomial n p * fact p * fact (n-p).

  Fact binomial_0n n : 0 < n -> binomial 0 n = 0.

  Theorem binomial_pascal n p : binomial (S n) (S p) = binomial n p + binomial n (S p).

End binomial. *)

Require Import alpha expo_diophantine dio_logic.
(* alpha:
Let Hl : l <> 0.    Proof. contradict H3; subst; ring. Qed.

  Lemma Zp_alpha_congruence_2 : divides (ak*ak) am <-> divides (k*ak) m.

End Zp_alpha_2.

Local Infix "‚îÇ" := divides (at level 70, no associativity).

Section Pell.

  Variable (b_nat : nat) (Hb_nat : 2 <= b_nat).

  Fixpoint alpha_nat n := 
    match n with
      | 0   => 0
      | S p => match p with
        | 0   => 1
        | S r => b_nat * alpha_nat p - alpha_nat r
      end
    end.

  Fact alpha_nat_fix_0 : alpha_nat 0 = 0.    Proof. auto. Qed.

  Fact alpha_nat_fix_2 n : alpha_nat (S (S n)) = b_nat *alpha_nat (S n) - alpha_nat n.

  Fact alpha_nat_2 n : b_nat = 2 -> alpha_nat n = n.

  Fact alpha_nat_inc n : alpha_nat n < alpha_nat (S n).

  Corollary alpha_nat_mono i j : i <= j -> alpha_nat i <= alpha_nat j.

  Corollary alpha_nat_smono i j : i < j -> alpha_nat i < alpha_nat j.

  Fact alpha_nat_ge_n n : n <= alpha_nat n.

  Fact alpha_nat_gt_0 : forall n, n <> 0 -> alpha_nat n <> 0.

  Fact alpha_nat_le n : alpha_nat n <= b_nat * alpha_nat (S n).

  Notation power := (mscal mult 1).

  Fact alpha_nat_power n : 2 < b_nat -> power n (b_nat-1) <= alpha_nat (S n) <= power n b_nat.

  Open Scope Z.

  Let b := Z.of_nat b_nat.
  Let Hb : 2 <= b.

  Definition alpha_Z n := 
    match n with 
      | 0%nat => -1
      | S n   => Z.of_nat (alpha_nat n)
    end.

  Notation Œ± := alpha_Z.

  Hint Resolve alpha_nat_le.

  Fact alpha_Z_S n : Œ± (S n) = Z.of_nat (alpha_nat n). Proof. auto. Qed.
  Fact alpha_fix_1 : Œ± 1%nat = 0.        Proof. auto. Qed.
  Fact alpha_fix_3 n : Œ± (S (S n)) = b*Œ± (S n) - Œ± n.
 
  Fact alpha_inc n : Œ± n < Œ± (S n).

  Fact alpha_ge_0 n : 0 <= Œ± (S n).

  Opaque Œ±.

  Create HintDb alpha_db.

  Hint Rewrite alpha_fix_0 alpha_fix_1 alpha_fix_2 alpha_fix_3 : alpha_db.

  Ltac alpha := autorewrite with alpha_db.

  Fact alpha_2 : b = 2 -> forall n, Œ± n = Z.of_nat n - 1.

  Notation MZ := (M22 Z).

  Notation MZ_opp := (MI22 Z.opp).
  Notation MZ_plus := (PL22 Zplus).
  Notation MZ_mult := (MU22 Zplus Zmult).
  Notation MZ_zero := (ZE_22 0).
  Notation MZ_one := (ID_22 0 1).
  Notation MZ_scal := (M22scal Zmult).
  Notation MZ_expo := (mscal MZ_mult MZ_one).
  Notation MZ_det := (Det22 Zplus Zmult Z.opp).

  Local Fact MZ_plus_monoid : monoid_theory MZ_plus MZ_zero.
 
  Local Fact MZ_mult_monoid : monoid_theory MZ_mult MZ_one.

  Hint Resolve MZ_plus_monoid MZ_mult_monoid.
 
  Notation "‚äü" := MZ_opp.
  Infix "‚äû" := MZ_plus (at level 50, left associativity).
  Infix "‚ä†" := MZ_mult (at level 40, left associativity).

  Definition B  : MZ := (b,-1,1,0).
  Definition iB : MZ := (0,1,-1,b).

  Definition A n := (Œ± (2+n),-Œ±(1+n),Œ±(1+n),-Œ± n).
  Definition iA n := (-Œ± n,Œ±(1+n),-Œ±(1+n),Œ± (2+n)).

  Notation mI := (-1,0,0,-1).

  Fact B_iB : B ‚ä† iB = MZ_one.

  Fact iB_i : iB ‚ä† B = MZ_one.

  Fact A_is_sum k : A k = MZ_scal (-Œ± k) MZ_one ‚äû MZ_scal (Œ± (S k)) B.

  Lemma MZ_expo_A n : MZ_expo n B = A n.

  Hint Resolve MZ_expo_A.

  Fact A_plus u v : A (u+v)%nat = A u ‚ä† A v.

  Fact A_mult u v : A (u*v)%nat = MZ_expo u (A v).

  Fact A_plus_mult m n k l : 
          (m = n + l * k)%nat 
       -> A m = A n ‚ä† MZ_expo l (A k).

  Fact MZ_det_B : MZ_det B = 1.

  Lemma MZ_det_A n : MZ_det (A n) = 1.

  Definition Pell x y := x*x -b*x*y+y*y=1.

  Theorem alpha_Pell n : Pell (Œ± (S n)) (Œ± n).

  Fact A_iA n : A n ‚ä† iA n = MZ_one.

  Fact iA_A n : iA n ‚ä† A n = MZ_one.

  Fact A_minus u v : (v <= u)%nat -> A (u-v)%nat = A u ‚ä† iA v.

  Section alpha_nat_coprime. 

    Let A_eq_3_12 n : exists u v, u*Œ± (S n) + v*Œ± n = 1.

    Lemma alpha_nat_coprime n : is_gcd (alpha_nat (S n)) (alpha_nat n) 1.

    Corollary alpha_nat_odd n : (rem (alpha_nat (S n)) 2 = 1 \/ rem (alpha_nat n) 2 = 1)%nat.

  End alpha_nat_coprime.

  Theorem find_odd_alpha u : exists n, (u <= alpha_nat (S n) /\ rem (alpha_nat (S n)) 2 = 1)%nat.

  Theorem find_odd_alpha' u : exists n, (u <= alpha_nat n /\ rem (alpha_nat n) 2 = 1)%nat.

  Notation expoZ := (mscal Zmult 1).

  Fact expoZ_power n x : expoZ n (Z.of_nat x) = Z.of_nat (power n x).

  Fact mscal_Zplus n : mscal Zplus 0 n 1 = Z.of_nat n.

  Notation "‚àë" := (msum MZ_plus MZ_zero).

  Theorem MA_expo_A_binomial m k l :
          (m = l * k)%nat 
       -> A m = ‚àë (S l) (fun i => MZ_scal ( expoZ (l-i) (-1)
                                          * Z.of_nat (binomial l i) 

  Section A2m.

    Variable (l m v : nat) (Hv : Z.of_nat v = Œ± (2+m) - Œ± m).

    Fact alpha_SSm_m_neq_0 : v <> 0%nat.

    Notation Hv' := alpha_SSm_m_neq_0.

    Let Z2Zp_morph := Z2Zp_morphishm Hv'.

    Notation f := (Z2Zp Hv').
    Notation "„Äö x „Äõ" :=  (f x).
    Notation "„Äò x „Äô" := (morph22 f x).
    Notation "‚äü" := (MI22 (Zp_opp Hv')).
    Infix "‚ä†" := (MU22 (Zp_plus Hv') (Zp_mult Hv')) (at level 40, left associativity).

    Let Am_iAm_mod :„ÄòA m„Äô= ‚äü„ÄòiA m„Äô.
    
    Fact A2m_mod : „ÄòA (2*m)„Äô= ‚äü„ÄòMZ_one„Äô.

    Fact A2lm_mod : „ÄòA (2*l*m)„Äô= „ÄòMZ_scal (mscal Zmult 1 l (-1)) MZ_one„Äô.

    Let expoZ_opp1 i : expoZ i (-1) = 1 \/ expoZ i (-1) = -1.

    Variable (j : nat) (Hl : (l <> 0)%nat) (Hj : (j <= m)%nat).

    Fact alpha_2lm_plus_j :„ÄöŒ± (S (2*l*m+j))„Äõ=„ÄöexpoZ l (-1)*Œ± (S j)„Äõ.

    Let Hj' : (j <= 2*l*m)%nat.

    Fact alpha_2lm_minus_j :„ÄöŒ± (S (2*l*m-j))„Äõ=„ÄöexpoZ (S l) (-1)*Œ± (S j)„Äõ.
  
    Theorem alpha_nat_2lm_plus_j : nat2Zp Hv' (alpha_nat (2*l*m+j)) = nat2Zp Hv' (alpha_nat j)
                                \/ nat2Zp Hv' (alpha_nat (2*l*m+j)) = Zp_opp Hv' (nat2Zp Hv' (alpha_nat j)).

    Theorem alpha_nat_2lm_minus_j : nat2Zp Hv' (alpha_nat (2*l*m-j)) = nat2Zp Hv' (alpha_nat j)
                                 \/ nat2Zp Hv' (alpha_nat (2*l*m-j)) = Zp_opp Hv' (nat2Zp Hv' (alpha_nat j)).

  End A2m.

  Section expo_congruence.

    Variable (q : nat). 
   
    Notation m := (b_nat*q-q*q-1)%nat.

    Hypothesis Hm : m <> 0%nat.

    Let Hq : (1+q*q < b_nat*q)%nat.

    Let VP : MZ := (Z.of_nat q,0,1,0).

    Notation Zm_ring := (Zp_is_ring Hm).

    Local Add Ring m_ring : Zm_ring.

    Notation qz := (Z.of_nat q).

    Let Z2Zp_morph := Z2Zp_morphishm Hm.

    Infix "‚äï" := (Zp_plus Hm) (at level 50, left associativity).
    Infix "‚äó" := (Zp_mult Hm) (at level 40, left associativity).
    Notation "‚à∏" := (Zp_opp Hm).
    Notation f := (Z2Zp Hm).
    Notation "„Äö x „Äõ" :=  (f x).
 
    Let qz_eq :„Äöb„Äõ‚äó„Äöqz„Äõ ‚äï ‚à∏ („Äöqz„Äõ‚äó„Äöqz„Äõ ‚äï„Äö1„Äõ) = Zp_zero Hm.

    Notation "„Äò x „Äô" := (morph22 f x).
    Infix "‚ä†" := (MU22 (Zp_plus Hm) (Zp_mult Hm)) (at level 40, left associativity).
    Notation scal := (M22scal (Zp_mult Hm)).

    Let BVP : „Äò B „Äô ‚ä† „Äò VP „Äô= scal„Äöqz„Äõ„Äò VP „Äô.

    Let AnVP n :„Äò A n „Äô ‚ä† „Äò VP „Äô= scal„ÄöexpoZ n qz„Äõ„Äò VP „Äô.

    Theorem expo_congruence_Z n : nat2Zp Hm q ‚äó„ÄöŒ± (S n)„Äõ=„ÄöŒ± n„Äõ‚äï nat2Zp Hm (power n q).

    Theorem expo_congruence n : (0 < n)%nat -> nat2Zp Hm (q * alpha_nat n) = nat2Zp Hm (alpha_nat (n-1) + power n q).

  End expo_congruence.

  Fact Pell_sym x y : Pell x y <-> Pell y x.

  Theorem Pell_zero_left y : Pell 0 y <-> y = 1 \/ y = -1.

  Theorem Pell_zero_right x : Pell x 0 <-> x = 1 \/ x = -1.

  Theorem Pell_not_diag x : ~ Pell x x.

  Theorem Pell_opposite_not x y : y < 0 -> 0 < x -> ~ Pell x y.

  Theorem Pell_alpha x y : 0 <= y < x -> Pell x y -> { n | x = Œ± (S (S n)) /\ y = Œ± (S n) }.

End Pell.

Theorem alpha_nat_Pell b n : 
    2 <= b -> alpha_nat b (S n)*alpha_nat b (S n) +  alpha_nat b n * alpha_nat b n  
            = 1 + b*(alpha_nat b (S n) * alpha_nat b n).

Theorem alpha_nat_Pell' b n : 
    2 <= b -> alpha_nat b n*alpha_nat b n +  alpha_nat b (S n) * alpha_nat b (S n)  
            = 1 + b*(alpha_nat b n * alpha_nat b (S n)).

Theorem Pell_alpha_nat b x y : 2 <= b -> y <= x -> x*x+y*y = 1+b*(x*y) -> { n | x = alpha_nat b (S n) /\ y = alpha_nat b n }.

Corollary Pell_alpha_nat' b x y : 2 <= b -> x*x+y*y = 1+b*(x*y) -> { n | x = alpha_nat b n }.

Theorem alpha_nat_2lm b n m l j v : 
          2 <= b 
       -> v = alpha_nat b (S (S m)) - alpha_nat b m
       -> arem n (S m) l j 
       -> rem (alpha_nat b n) v = rem (alpha_nat b j) v
       \/ rem (alpha_nat b n + alpha_nat b j) v = 0.

Section divisibility_1.

  Variable (b : nat) (Hb : 2 <= b) (k : nat) (Hk : k <> 0).

  Let Hak : alpha_nat b k <> 0.

  Section equation.

    Variable (m n l : nat) (Hm : m = n+l*k).

    Infix "‚äó" := (Zp_mult Hak) (at level 40, left associativity).
    Notation expo := (mscal (Zp_mult Hak) (Zp_one Hak)).

    Hint Resolve Zle_0_nat.

    Section in_Z.

      Notation "„Äö x „Äõ" := (Z2Zp Hak x).  

      Let Z2ZP_morph := Z2Zp_morphishm Hak.

      Open Scope Z_scope.

      Fact A_k_morph22 : morph22 (Z2Zp Hak) (A b k) = („Äöalpha_Z b (2+k)„Äõ,Zp_zero Hak,Zp_zero Hak,„Äö-alpha_Z b k„Äõ).

      Lemma alpha_Z_mnlk_eq : „Äö alpha_Z b (1+m) „Äõ = „Äö alpha_Z b (1+n) „Äõ‚äó expo l„Äö alpha_Z b (2+k) „Äõ.

    End in_Z.

    Section in_nat.

      Notation "„Äö x „Äõ" := (nat2Zp Hak x).  

      Theorem alpha_nat_mnlk_eq : „Äö alpha_nat b m „Äõ = „Äö alpha_nat b n „Äõ‚äó expo l„Äö alpha_nat b (1+k) „Äõ.

    End in_nat.

  End equation.

  Theorem alpha_nat_divides_k_ge_1 m : alpha_nat b k ‚îÇ alpha_nat b m <-> k ‚îÇ m.

End divisibility_1.

Theorem alpha_nat_divisibility_1 b k m : 2 <= b -> alpha_nat b k ‚îÇ alpha_nat b m <-> k ‚îÇ m.

Check alpha_nat_divisibility_1.
Print Assumptions alpha_nat_divisibility_1.

Section divisibility_2.

  Variable (b : nat) (Hb : 2 <= b) (k : nat) (Hk : k <> 0).

  Let Hak : alpha_nat b k <> 0.

  Let ak2 := alpha_nat b k * alpha_nat b k.

  Let Hak2 : ak2 <> 0.

  Section equation.

    Variable (m l : nat) (Hm : m = l*k) (Hl : l <> 0).

    Infix "‚äï" := (Zp_plus Hak2) (at level 50, left associativity).
    Infix "‚äó" := (Zp_mult Hak2) (at level 40, left associativity).
    Notation expoZp := (mscal (Zp_mult Hak2) (Zp_one Hak2)).

    Hint Resolve Zle_0_nat.

    Section in_Zp.

      Notation "„Äö x „Äõ" := (Z2Zp Hak2 x).  

      Let Z2Zp_morph := Z2Zp_morphishm Hak2.

      Open Scope Z_scope.

      Let Zmult_monoid : monoid_theory Zmult 1.

      Notation MZp := (M22 ak2).
      Infix "‚äû" := (PL22 (Zp_plus Hak2)) (at level 50, left associativity).
      Infix "‚ä†" := (MU22 (Zp_plus Hak2) (Zp_mult Hak2)) (at level 40, left associativity).
      Notation MZp_Z := (ZE_22 (Zp_zero Hak2)).
      Notation MZp_I := (ID_22 (Zp_zero Hak2) (Zp_one Hak2)).
      Notation MZp_expo := (mscal (fun u v => u‚ä†v) MZp_I).
      Notation MZp_scal := (M22scal (Zp_mult Hak2)).

      Fact A_m_morph22 : morph22 (Z2Zp Hak2) (A b m) 
                       = MZp_scal (expoZp l„Äö-1„Äõ‚äó expoZp l„Äöalpha_Z b k„Äõ) MZp_I
                       ‚äû MZp_scal (expoZp (l-1)„Äö-1„Äõ‚äó nat2Zp Hak2 l ‚äó „Äöalpha_Z b (S k)„Äõ‚äó expoZp (l-1)„Äöalpha_Z b k„Äõ) (morph22 (Z2Zp Hak2) (B b)).

      Lemma alpha_Z_ml_eq : „Äö alpha_Z b (S m) „Äõ 
                          = expoZp (l-1) „Äö-1„Äõ
                          ‚äó nat2Zp Hak2 l
                          ‚äó„Äö alpha_Z b (S k) „Äõ
                          ‚äó expoZp (l-1)„Äö alpha_Z b k „Äõ.

    End in_Zp.

    Local Add Ring myring2 : (Zp_is_ring Hak2).

    Corollary alpha_square_nat : exists q, Zp_invertible Hak2 q /\ nat2Zp Hak2 (alpha_nat b m) = q ‚äó nat2Zp Hak2 l  ‚äó nat2Zp Hak2 (alpha_nat b k).
  
  End equation.

  Theorem alpha_nat_divides_2_pos m : alpha_nat b k * alpha_nat b k ‚îÇ alpha_nat b m <-> k*alpha_nat b k ‚îÇ m.

End divisibility_2.

Theorem alpha_nat_divisibility_2 b k m : 
    2 <= b -> alpha_nat b k * alpha_nat b k ‚îÇ alpha_nat b m <-> k*alpha_nat b k ‚îÇ m.

Check alpha_nat_divisibility_2.
Print Assumptions alpha_nat_divisibility_2.

Section congruence_1.

  Variable (b1 b2 : nat) (Hb1 : 2 <= b1) (Hb2 : 2 <= b2)
           (q : nat) (Hq : q <> 0) (Hb : nat2Zp Hq b1 = nat2Zp Hq b2).

  Hint Resolve Zle_0_nat.

  Theorem alpha_Z_congr n : Z2Zp Hq (alpha_Z b1 n) = Z2Zp Hq (alpha_Z b2 n).

End congruence_1.

Theorem alpha_nat_congruence_0 b1 b2 q n : 
           2 <= b1 
        -> 2 <= b2
        -> rem b1 q = rem b2 q 
        -> rem (alpha_nat b1 n) q = rem (alpha_nat b2 n) q.

Corollary alpha_nat_congruence_1 b n : b-2 <> 0 -> rem (alpha_nat b n) (b-2) = rem n (b-2).

Check alpha_nat_congruence_0.
Check alpha_nat_congruence_1.

Section congruence_2.

  Variable (b : nat) (Hb : b - 2 <> 0).

  Notation "„Äö x „Äõ" := (Z2Zp Hb x).  

  Hint Resolve Zle_0_nat.

  Open Scope Z_scope.

  Theorem alpha_Z_b_2 n : „Äö alpha_Z b n „Äõ = Zp_plus Hb „Äö Z.of_nat n „Äõ„Äö -1 „Äõ.

End congruence_2.

Lemma rem_eq_eq a b v : 2*a < v -> 2*b < v -> rem a v = rem b v -> a = b.

Lemma rem_eq_diff_eq a b v : 2*a < v -> 2*b < v -> (rem a v = rem b v) \/ (rem (a+b) v = 0) -> a = b.

Section diophantine_sufficiency.

  Variables (a b c : nat) (u t r s v w x y : nat).

  Definition alpha_conditions :=
                    3 < b
                 /\ u*u+t*t = 1+b*(u*t)
                 /\ s*s+r*r = 1+b*(s*r)
                 /\ r < s
                 /\ u*u ‚îÇ s
                 /\ v+2*r = b*s
                 /\ rem w v = rem b v
                 /\ rem w u = rem 2 u
                 /\ 2 < w
                 /\ x*x+y*y = 1+w*(x*y)
                 /\ 2*a < u
                 /\ 2*a < v
                 /\ rem a v = rem x v
                 /\ 2*c < u
                 /\ rem c u = rem x u.

  Theorem alpha_sufficiency : alpha_conditions -> 3 < b /\ a = alpha_nat b c.

End diophantine_sufficiency.

Section diophantine_necessity.

  Variables (a b c : nat).

  Theorem alpha_necessity : 3 < b /\ a = alpha_nat b c -> exists u t r s v w x y, alpha_conditions a b c u t r s v w x y.

End diophantine_necessity.

Theorem alpha_diophantine a b c : 3 < b /\ a = alpha_nat b c 
                              <-> exists u t r s v w x y, alpha_conditions a b c u t r s v w x y. *)
(* expo_diophantine:
Require Import Arith Omega Eqdep_dec ZArith.

Require Import utils_tac gcd sums Zp alpha.

Set Implicit Arguments.

Local Notation expo := (mscal mult 1).

Section expo_diophantine.

  Variables (p q r : nat).

  Definition expo_conditions :=       
      r = 0 /\ p = 1
   \/ q = 0 /\ 0 < r /\ p = 0
   \/ (0 < r /\ q <> 0) /\ exists b m a1 a2 a3, 
             (3 < q+4 /\ a1 = alpha_nat (q+4) (1+r)) 
          /\ (3 < b   /\ a2 = alpha_nat b r)
          /\ (3 < b   /\ a3 = alpha_nat b (1+r))
          /\ b = a1+q*q+2
          /\ m + q*q + 1 = b*q
          /\ p < m
          /\ rem (p+b*a2) m = rem (q*a2+a3) m.

  Let H_q3_q : 0 < q -> q*q+2 <= q*q*q+2*q.

  Lemma expo_sufficiency : p = expo r q -> expo_conditions.

  Infix "‚äï" := (Zp_plus _) (at level 50, left associativity).
  Infix "‚äó" := (Zp_mult _) (at level 40, left associativity).
  Notation "‚à∏" := (Zp_opp _).
  Notation f := (nat2Zp _).
  Notation "„Äö x „Äõ" :=  (f x).

  Ltac fold_nat2Zp := 
    repeat match goal with 
      | |- context[nat2Zp _ ?x ‚äï nat2Zp _ ?y] => rewrite <- nat2Zp_plus
      | |- context[nat2Zp _ ?x ‚äó nat2Zp _ ?y] => rewrite <- nat2Zp_mult
      | |- context[‚à∏ nat2Zp _ ?x] => fail
    end.

  Lemma expo_necessity : expo_conditions -> p = expo r q.

End expo_diophantine.

Local Hint Resolve expo_sufficiency expo_necessity.

Theorem expo_diophantine p q r : p = expo r q <-> expo_conditions p q r. *)
(* dio_logic:
Require Import Arith Nat Omega.
Require Import gcd.

Set Implicit Arguments.

Section diophantine_expressions.

  Inductive dio_op := do_add | do_mul.

  Definition do_eval o :=
    match o with
      | do_add => plus
      | do_mul => mult
    end.

  Inductive dio_expression : Set :=
    | de_cst  : nat -> dio_expression
    | de_var  : nat -> dio_expression
    | de_comp : dio_op -> dio_expression -> dio_expression -> dio_expression.

  Definition de_add := de_comp do_add.
  Definition de_mul := de_comp do_mul.

  Fixpoint de_size e :=
    match e with
      | de_cst n => 1
      | de_var x => 1
      | de_comp _ p q => 1 + de_size p + de_size q
    end.

  Fixpoint de_size_Z e :=
    (match e with
      | de_cst n => 1
      | de_var x => 1
      | de_comp _ p q => 1 + de_size_Z p + de_size_Z q
    end)%Z.

  Fact de_size_Z_spec e : de_size_Z e = Z.of_nat (de_size e).

  Fixpoint de_eval ŒΩ e  :=
    match e with
      | de_cst n => n
      | de_var x => ŒΩ x
      | de_comp o p q => do_eval o (de_eval ŒΩ p) (de_eval ŒΩ q)
    end.

  Fact de_eval_ext e ŒΩ œâ : (forall x, ŒΩ x = œâ x) -> de_eval ŒΩ e = de_eval œâ e.

  Fixpoint de_subst œÉ e :=
    match e with
      | de_cst n => de_cst n
      | de_var x => œÉ x
      | de_comp o p q => de_comp o (de_subst œÉ p) (de_subst œÉ q)
    end.

  Fact de_eval_subst œÉ ŒΩ e : de_eval ŒΩ (de_subst œÉ e) = de_eval (fun x => de_eval ŒΩ (œÉ x)) e.

  Fact de_subst_subst œÉ1 œÉ2 e : de_subst œÉ1 (de_subst œÉ2 e) = de_subst (fun x => de_subst œÉ1 (œÉ2 x)) e.

  Definition de_ren œÅ := de_subst (fun x => de_var (œÅ x)).

  Fact de_ren_size œÅ e : de_size (de_ren œÅ e) = de_size e.

  Fact de_ren_size_Z œÅ e : de_size_Z (de_ren œÅ e) = de_size_Z e.

  Fact de_eval_ren œÅ ŒΩ e : de_eval ŒΩ (de_ren œÅ e)  = de_eval (fun x => ŒΩ (œÅ x)) e.

  Definition de_lift := de_ren S.

  Fact de_eval_lift ŒΩ e : de_eval ŒΩ (de_lift e) = de_eval (fun x => ŒΩ (S x)) e.

End diophantine_expressions.

Definition dio_expr t := { e | forall ŒΩ, de_eval ŒΩ e = t ŒΩ }.

Notation ùîªP := dio_expr.

Section dio_expr.

  Implicit Types r t : (nat -> nat) -> nat.

  Fact dio_expr_var i : ùîªP (fun v => v i).

  Fact dio_expr_cst c : ùîªP (fun _ => c).

  Fact dio_expr_plus r t : ùîªP r -> ùîªP t -> ùîªP (fun ŒΩ => r ŒΩ + t ŒΩ).
  
  Fact dio_expr_mult r t : ùîªP r -> ùîªP t -> ùîªP (fun ŒΩ => r ŒΩ * t ŒΩ).

  Fact dio_expr_ren t œÅ : ùîªP t -> ùîªP (fun ŒΩ => t (fun i => ŒΩ (œÅ i))).

  Fact dio_expr_subst t œÉ : ùîªP t -> ùîªP (fun ŒΩ => t (fun i => de_eval ŒΩ (œÉ i))).

End dio_expr.

Hint Resolve dio_expr_var dio_expr_cst dio_expr_plus dio_expr_mult dio_expr_ren.

Section diophantine_logic.

  Inductive dio_formula : Set :=
    | df_atm  : dio_expression -> dio_expression -> dio_formula   
    | df_conj : dio_formula -> dio_formula -> dio_formula 
    | df_disj : dio_formula -> dio_formula -> dio_formula
    | df_exst : dio_formula -> dio_formula.

  Fixpoint df_size f :=
    match f with
      | df_atm a b  => 1 + de_size a + de_size b
      | df_conj f g => 1 + df_size f + df_size g  
      | df_disj f g => 1 + df_size f + df_size g  
      | df_exst f   => 1 + df_size f
    end.

  Fixpoint df_size_Z f :=
    (match f with
      | df_atm a b  => 1 + de_size_Z a + de_size_Z b
      | df_conj f g => 1 + df_size_Z f + df_size_Z g  
      | df_disj f g => 1 + df_size_Z f + df_size_Z g  
      | df_exst f   => 1 + df_size_Z f
    end)%Z.

  Fact df_size_Z_spec f : df_size_Z f = Z.of_nat (df_size f).

  Definition dv_lift X ŒΩ (x : X) n :=
     match n with 
       | 0   => x 
       | S n => ŒΩ n 
     end.

  Fixpoint df_pred f ŒΩ :=
    match f with
      | df_atm a b  => de_eval ŒΩ a  = de_eval ŒΩ b
      | df_conj f g => df_pred f ŒΩ /\ df_pred g ŒΩ
      | df_disj f g => df_pred f ŒΩ \/ df_pred g ŒΩ
      | df_exst f   => exists n, df_pred f (dv_lift ŒΩ n)
    end.

  Fact df_pred_atm a b ŒΩ : df_pred (df_atm a b) ŒΩ = (de_eval ŒΩ a = de_eval ŒΩ b).
  
  Fact df_pred_conj f g ŒΩ : df_pred (df_conj f g) ŒΩ = (df_pred f ŒΩ /\ df_pred g ŒΩ).

  Fact df_pred_disj f g ŒΩ : df_pred (df_disj f g) ŒΩ = (df_pred f ŒΩ \/ df_pred g ŒΩ).

  Fact df_pred_exst f ŒΩ : df_pred (df_exst f) ŒΩ = exists n, df_pred f (dv_lift ŒΩ n).

  Fact df_pred_ext f ŒΩ œâ : (forall x, ŒΩ x = œâ x) -> df_pred f ŒΩ <-> df_pred f œâ.

  Definition der_lift œÅ x := match x with 0 => 0 | S x => S (œÅ x) end.

  Fixpoint df_ren œÅ f :=
    match f with
      | df_atm a b  => let œÉ := fun x => de_var (œÅ x) in df_atm (de_subst œÉ a) (de_subst œÉ b)
      | df_conj f g => df_conj (df_ren œÅ f) (df_ren œÅ g)
      | df_disj f g => df_disj (df_ren œÅ f) (df_ren œÅ g)
      | df_exst f   => df_exst (df_ren (der_lift œÅ) f)
    end.

  Fact df_ren_size œÅ f : df_size (df_ren œÅ f) = df_size f.

  Fact df_ren_size_Z œÅ f : df_size_Z (df_ren œÅ f) = df_size_Z f.

  Fact df_pred_ren f ŒΩ œÅ : df_pred (df_ren œÅ f) ŒΩ <-> df_pred f (fun x => ŒΩ (œÅ x)).

  Definition des_lift œÉ x := match x with 0 => de_var 0 | S x => de_ren S (œÉ x) end. 
     
  Fixpoint df_subst œÉ f := 
    match f with
      | df_atm a b  => df_atm (de_subst œÉ a) (de_subst œÉ b)
      | df_conj f g => df_conj (df_subst œÉ f) (df_subst œÉ g)
      | df_disj f g => df_disj (df_subst œÉ f) (df_subst œÉ g)
      | df_exst f   => df_exst (df_subst (des_lift œÉ) f)
    end.

  Fact df_pred_subst f ŒΩ œÉ : df_pred (df_subst œÉ f) ŒΩ <-> df_pred f (fun x => de_eval ŒΩ (œÉ x)).

  Definition df_lift := df_ren S.

  Fact df_pred_lift f ŒΩ : df_pred (df_lift f) ŒΩ <-> df_pred f (fun x => ŒΩ (S x)).

End diophantine_logic.

Section examples.

  Variable ŒΩ : nat -> nat.

  Definition df_true := df_atm (de_cst 0) (de_cst 0).
  Definition df_false := df_atm (de_cst 0) (de_cst 1).

  Fact df_true_spec : df_pred df_true ŒΩ <-> True.

  Fact df_false_spec : df_pred df_false ŒΩ <-> False.

  Notation "'‚ü¶' x '‚üß'" := (de_eval ŒΩ x).

  Definition df_le x y := df_exst (df_atm (de_add (de_var 0) (de_lift x)) (de_lift y)).

  Fact df_le_spec x y : df_pred (df_le x y) ŒΩ <-> ‚ü¶x‚üß <= ‚ü¶y‚üß.

  Definition df_lt x y := df_exst (df_atm (de_add (de_cst 1) (de_add (de_var 0) (de_lift x))) (de_lift y)).

  Fact df_lt_spec x y : df_pred (df_lt x y) ŒΩ <-> ‚ü¶x‚üß < ‚ü¶y‚üß.

  Definition df_eq x y := df_atm x y.

  Fact df_eq_spec x y : df_pred (df_eq x y) ŒΩ <-> ‚ü¶x‚üß = ‚ü¶y‚üß.

  Definition df_neq x y := df_disj (df_lt x y) (df_lt y x).

  Fact df_neq_spec x y : df_pred (df_neq x y) ŒΩ <-> ‚ü¶x‚üß <> ‚ü¶y‚üß.

  Definition df_div x y := df_exst (df_atm (de_lift y) (de_mul (de_var 0) (de_lift x))).

  Fact df_div_spec x y : df_pred (df_div x y) ŒΩ <-> divides ‚ü¶x‚üß ‚ü¶y‚üß.

End examples.

Definition dio_rel R := { f | forall ŒΩ, df_pred f ŒΩ <-> R ŒΩ }.
Notation ùîªR := dio_rel.

Section dio_rel.

  Implicit Types R S : (nat -> nat) -> Prop.

  Fact dio_rel_True : ùîªR (fun _ => True).

  Fact dio_rel_False : ùîªR (fun _ => False).

  Fact dio_rel_eq r t : ùîªP r -> ùîªP t -> ùîªR (fun ŒΩ => r ŒΩ = t ŒΩ).

  Fact dio_rel_le r t : ùîªP r -> ùîªP t -> ùîªR (fun ŒΩ => r ŒΩ <= t ŒΩ).

  Fact dio_rel_lt r t : ùîªP r -> ùîªP t -> ùîªR (fun ŒΩ => r ŒΩ < t ŒΩ).

  Fact dio_rel_neq r t : ùîªP r -> ùîªP t -> ùîªR (fun ŒΩ => r ŒΩ <> t ŒΩ).

  Fact dio_rel_div r t : ùîªP r -> ùîªP t -> ùîªR (fun ŒΩ => divides (r ŒΩ) (t ŒΩ)).

  Fact dio_rel_conj R S : ùîªR R -> ùîªR S -> ùîªR (fun ŒΩ => R ŒΩ /\ S ŒΩ).

  Fact dio_rel_disj R S : ùîªR R -> ùîªR S -> ùîªR (fun ŒΩ => R ŒΩ \/ S ŒΩ).

  Fact dio_rel_exst (K : nat -> (nat -> nat) -> Prop) : 
                   ùîªR (fun v => K (v 0) (fun n => v (S n))) 
      -> ùîªR (fun ŒΩ => exists x, K x ŒΩ).

  Lemma dio_rel_equiv R S : (forall ŒΩ, S ŒΩ <-> R ŒΩ) -> ùîªR R -> ùîªR S.

  Lemma dio_rel_ren R f : ùîªR R -> ùîªR (fun v => R (fun n => v (f n))).

  Lemma dio_rel_subst R f : ùîªR R -> ùîªR (fun v => R (fun n => de_eval v (f n))).

End dio_rel.

Hint Resolve dio_rel_True dio_rel_False dio_rel_eq dio_rel_neq 
             dio_rel_le dio_rel_lt dio_rel_div 
             dio_rel_conj 
             dio_rel_disj 
             dio_rel_exst.

Ltac dio_rel_auto := repeat ((apply dio_rel_exst || apply dio_rel_conj || apply dio_rel_disj || apply dio_rel_eq); auto).

Section more_examples.

  Fact ndivides_eq x y : ~ (divides x y) <-> x = 0 /\ y <> 0 \/ exists a b, y = a*x+b /\ 0 < b < x.
  
  Lemma dio_rel_ndivides x y : ùîªP x -> ùîªP y -> ùîªR (fun ŒΩ => ~ divides (x ŒΩ) (y ŒΩ)).

  Hint Resolve dio_rel_ndivides.

  Fact rem_equiv p x r : r = rem x p <-> (p = 0 /\ x = r)
                                      \/ (p <> 0 /\ r < p /\ exists n, x = n*p + r).
 
  Lemma dio_rel_remainder p x r : ùîªP p -> ùîªP x -> ùîªP r  
                               -> ùîªR (fun ŒΩ => r ŒΩ = rem (x ŒΩ) (p ŒΩ)).

  Hint Resolve dio_rel_remainder.

  Fact congr_equiv x y p : rem x p = rem y p <-> (exists r, r = rem x p /\ r = rem y p).

  Lemma dio_rel_congruence x y p : ùîªP x -> ùîªP y -> ùîªP p  
                                -> ùîªR (fun ŒΩ => rem (x ŒΩ) (p ŒΩ) = rem (y ŒΩ) (p ŒΩ)).

  Hint Resolve dio_rel_congruence.

  Fact not_divides_eq p x : ~ divides p x <-> exists r, r = rem x p /\ r <> 0.

  Lemma dio_rel_not_divides x p : ùîªP x -> ùîªP p -> ùîªR (fun ŒΩ => ~ divides (x ŒΩ) (p ŒΩ)).

End more_examples.

Hint Resolve dio_rel_congruence dio_rel_not_divides.

Section dio_rel_compose.

  Variable (f : (nat -> nat) -> nat) (R : nat -> (nat -> nat) -> Prop).
  Hypothesis (Hf : ùîªR (fun ŒΩ => ŒΩ 0 = f (fun x => ŒΩ (S x)))) 
             (HR : ùîªR (fun ŒΩ => R (ŒΩ 0) (fun x => ŒΩ (S x)))).

  Lemma dio_rel_compose : ùîªR (fun ŒΩ => R (f ŒΩ) ŒΩ).

End dio_rel_compose.

Section multiple_exists.

  Fixpoint df_mexists n f :=
    match n with 
      | 0   => f
      | S n => df_mexists n (df_exst f)
    end.

  Fact df_mexists_size n f : df_size (df_mexists n f) = n + df_size f.

  Fact df_mexists_size_Z n f : df_size_Z (df_mexists n f) = (Z.of_nat n + df_size_Z f)%Z.

  Lemma df_mexists_spec n f ŒΩ : 
           df_pred (df_mexists n f) ŒΩ 
       <-> exists œÄ, df_pred f (fun i => if le_lt_dec n i then ŒΩ (i-n) else œÄ i).

End multiple_exists. *)



Set Implicit Arguments.



Local Notation power := (mscal mult 1).

Local Notation expo := (mscal mult 1).



Theorem dio_rel_alpha a b c : ùîªP a -> ùîªP b -> ùîªP c

                           -> ùîªR (fun ŒΩ => 3 < b ŒΩ /\ a ŒΩ = alpha_nat (b ŒΩ) (c ŒΩ)).

Proof.

  intros.

  apply dio_rel_equiv with (1 := fun v => alpha_diophantine (a v) (b v) (c v)).

  unfold alpha_conditions. 

  dio_rel_auto.

Defined.



Hint Resolve dio_rel_alpha.



Fact dio_rel_alpha_size : df_size (proj1_sig (dio_rel_alpha (dio_expr_var 0) (dio_expr_var 1) (dio_expr_var 2))) = 490.

Proof. reflexivity. Qed.



Theorem dio_rel_expo p q r : ùîªP p -> ùîªP q -> ùîªP r -> ùîªR (fun ŒΩ => p ŒΩ = expo (r ŒΩ) (q ŒΩ)).

Proof.

  intros.

  apply dio_rel_equiv with (1 := fun v => expo_diophantine (p v) (q v) (r v)).

  unfold expo_conditions. 

  dio_rel_auto.

Defined.



Hint Resolve dio_rel_expo.

 

Check dio_rel_expo.

Print Assumptions dio_rel_expo.



Fact dio_rel_expo_size : df_size (proj1_sig (dio_rel_expo (dio_expr_var 0) (dio_expr_var 1) (dio_expr_var 2))) = 1689.

Proof. reflexivity. Qed.



Section df_digit.



  Let is_digit_eq c q i y : is_digit c q i y 

                        <-> y < q

                        /\ exists a b p, c = (a*q+y)*p+b 

                                      /\ b < p

                                      /\ p = power i q.

  Proof.

    split; intros (H1 & a & b & H2).

    + split; auto; exists a, b, (power i q); repeat split; tauto.

    + destruct H2 as (p & H2 & H3 & H4).

      split; auto; exists a, b; subst; auto.

  Qed.



  Lemma dio_rel_is_digit c q i y : ùîªP c -> ùîªP q -> ùîªP i -> ùîªP y

                                -> ùîªR (fun ŒΩ => is_digit (c ŒΩ) (q ŒΩ) (i ŒΩ) (y ŒΩ)).

  Proof.

    intros H1 H2 H3 H4.

    apply dio_rel_equiv with (1 := fun ŒΩ => is_digit_eq (c ŒΩ) (q ŒΩ) (i ŒΩ) (y ŒΩ)).

    dio_rel_auto; apply dio_expr_plus; auto.

  Defined.



End df_digit.



Hint Resolve dio_rel_is_digit.



Check dio_rel_is_digit.

Eval compute in df_size (proj1_sig (dio_rel_is_digit (dio_expr_var 0) (dio_expr_var 1) (dio_expr_var 2) (dio_expr_var 3))).



Section df_binomial.



  Notation "‚àë" := (msum plus 0).



  Let plus_cancel_l : forall a b c, a + b = a + c -> b = c.

  Proof. intros; omega. Qed.



  Hint Resolve Nat.mul_add_distr_r.



  Let is_binomial_eq b n k :  b = binomial n k

                          <-> exists q c, q = power (1+n) 2

                                       /\ c = power n (1+q) 

                                       /\ is_digit c q k b.

  Proof.

    split.

    + intros ?; subst.

      set (q := power (1+n) 2).

      assert (Hq : q <> 0).

      { unfold q; generalize (@power_ge_1 (S n) 2); intros; simpl; omega. }

      set (c := power n (1+q)).

      exists q, c; split; auto.

      split; auto.

      split. 

      * apply binomial_lt_power.

      * destruct (le_lt_dec k n) as [ Hk | Hk ].

        - exists (‚àë (n-k) (fun i => binomial n (S k+i) * power i q)),

                 (‚àë k (fun i => binomial n i * power i q)); split; auto.

          2: { apply sum_power_lt; auto; intros; apply binomial_lt_power. }

          rewrite Nat.mul_add_distr_r, <- mult_assoc, <- power_S.

          rewrite <- sum_0n_distr_r with (1 := Nat_plus_monoid) (3 := Nat_mult_monoid); auto.

          rewrite <- plus_assoc, (plus_comm _ (‚àë _ _)).

          rewrite <- msum_plus1 with (f := fun i => binomial n i * power i q); auto.

          rewrite plus_comm.

          unfold c.

          rewrite Newton_nat_S.

          replace (S n) with (S k + (n-k)) by omega.

          rewrite msum_plus; auto; f_equal; apply msum_ext.

          intros; rewrite power_plus; ring.

        - exists 0, c.

          rewrite binomial_gt; auto.

          rewrite Nat.mul_0_l; split; auto.

          unfold c.

          apply lt_le_trans with (power (S n) q).

          ++ rewrite Newton_nat_S.

             apply sum_power_lt; auto.

             intros; apply binomial_lt_power.

          ++ apply power_mono; omega.

    + intros (q & c & H1 & H2 & H3).

      assert (Hq : q <> 0).

      { rewrite H1; generalize (@power_ge_1 (S n) 2); intros; simpl; omega. }

      rewrite Newton_nat_S in H2.

      apply is_digit_fun with (1 := H3).

      destruct (le_lt_dec k n) as [ Hk | Hk ].

      * red; split.

        - subst; apply binomial_lt_power.

        - exists (‚àë (n-k) (fun i => binomial n (S k+i) * power i q)),

                 (‚àë k (fun i => binomial n i * power i q)); split.

          2: {  apply sum_power_lt; auto; intros; subst; apply binomial_lt_power. }

          rewrite Nat.mul_add_distr_r, <- mult_assoc, <- power_S.

          rewrite <- sum_0n_distr_r with (1 := Nat_plus_monoid) (3 := Nat_mult_monoid); auto.

          rewrite <- plus_assoc, (plus_comm _ (‚àë _ _)).

          rewrite <- msum_plus1 with (f := fun i => binomial n i * power i q); auto.

          rewrite plus_comm, H2.

          replace (S n) with (S k + (n-k)) by omega.

          rewrite msum_plus; auto; f_equal.

          apply msum_ext.

          intros; rewrite power_plus; ring.

      * rewrite binomial_gt; auto.

        split; try omega. 

        exists 0, c.

        rewrite Nat.mul_0_l; split; auto.

        rewrite H2.

        apply lt_le_trans with (power (S n) q).

        - apply sum_power_lt; auto.

          subst; intros; apply binomial_lt_power.

        - apply power_mono; omega.

  Qed.



  Lemma dio_rel_binomial b n k : ùîªP b -> ùîªP n -> ùîªP k

                              -> ùîªR (fun ŒΩ => b ŒΩ = binomial (n ŒΩ) (k ŒΩ)).

  Proof.

    intros H1 H2 H3.

    apply dio_rel_equiv with (1 := fun ŒΩ => is_binomial_eq (b ŒΩ) (n ŒΩ) (k ŒΩ)).

    dio_rel_auto; apply dio_expr_plus; auto.

  Defined.



End df_binomial.



Check dio_rel_binomial.

Eval compute in df_size (proj1_sig (dio_rel_binomial (dio_expr_var 0) (dio_expr_var 1) (dio_expr_var 2))).

