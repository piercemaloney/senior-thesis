

Require Import Arith Nat Omega List Bool Setoid.

Require Import utils_tac utils_list utils_nat bool_list gcd sums power_decomp.
(* utils_tac:
Require Import Arith List Wellfounded.

Set Implicit Arguments.

Definition eqdec X := forall x y : X, { x = y } + { x <> y }.

Definition swap {X Y} (c : X * Y) := let (x,y) := c in (y,x).

Theorem measure_rect X (m : X -> nat) (P : X -> Type) :
      (forall x, (forall y, m y < m x -> P y) -> P x) -> forall x, P x.

Tactic Notation "induction" "on" hyp(x) "as" ident(IH) "with" "measure" uconstr(f) :=
  pattern x; revert x; apply measure_rect with (m := fun x => f); intros x IH.

Tactic Notation "eq" "goal" hyp(H) := 
  match goal with 
    |- ?b => match type of H with ?t => replace b with t; auto end 
  end.

Ltac eqgoal := let H := fresh in intro H; eq goal H; clear H.

Tactic Notation "spec" "in" hyp(H) :=
  let Q := fresh 
  in match goal with G: ?h -> _ |- _ => 
       match G with 
         | H => assert (h) as Q; [ | specialize (H Q); clear Q ] 
       end 
     end.

Ltac solve_list_eq := simpl; repeat progress (try rewrite app_ass; try rewrite <- app_nil_end; simpl; auto); auto.

Tactic Notation "solve" "list" "eq" := solve_list_eq.

Tactic Notation "solve_list_eq" "in" hyp(H) := generalize H; clear H; solve_list_eq; intro H.

Tactic Notation "solve" "list" "eq" "in" hyp(H) := 
   let Q := fresh in 
   match goal with 
     |- ?t => set (Q := t); generalize H; clear H; solve_list_eq; intro H; unfold Q; clear Q
   end.

Ltac msplit n := 
  match n with 
    | 0    => idtac 
    | S ?n => split; [ | msplit n ]
   end.

Tactic Notation "define" ident(f) "of" hyp(n) hyp(m) "as" uconstr(t)  :=
  match type of n with ?N =>  
    match type of m with ?M  => pose (f (n:N) (m:M) := t) end end.

Tactic Notation "induction" "on" hyp(x) hyp(y) "as" ident(IH) "with" "measure" uconstr(f) :=
  generalize I; intro IH;
  let mes := fresh "measure" in let rel := fresh "relation" in let loop := fresh "loop" in
  let u := fresh "u" in let u' := fresh x in let Hu := fresh "Hu" in 
  let v := fresh "v" in let v' := fresh y in let Hv := fresh "Hv" 
  in clear IH; 
     define mes of x y as (f : nat);
     set (rel u v := mes (fst u) (snd u) < mes (fst v) (snd v)); unfold fst, snd in rel;
     pattern x, y; match goal with
       |- ?T _ _ => 
       refine ((fix loop u v (Hu : Acc rel (u,v)) { struct Hu } : T u v := _) x y _);
       [ assert (forall u' v', rel (u',v') (u,v) -> T u' v') as IH;
         [ intros u' v' Hv; apply (loop u' v'), (Acc_inv Hu), Hv 
         | unfold rel, mes in *; clear mes rel Hu loop x y; rename u into x; rename v into y ]
       | unfold rel; apply wf_inverse_image, lt_wf ]
     end.

Section forall_equiv.

  Variable (X : Type) (A P Q : X -> Prop) (HPQ : forall n, A n -> P n <-> Q n).

  Theorem forall_bound_equiv : (forall n, A n -> P n) <-> (forall n, A n -> Q n).

End forall_equiv.

Section exists_equiv.

  Variable (X : Type) (P Q : X -> Prop) (HPQ : forall n, P n <-> Q n).

  Theorem exists_equiv : (exists n, P n) <-> (exists n, Q n).

End exists_equiv. *)
(* utils_list:
Require Import List Arith Omega Permutation.

Require Import list_focus utils_tac.

Set Implicit Arguments.

Create HintDb length_db.

Tactic Notation "rew" "length" := autorewrite with length_db.
Tactic Notation "rew" "length" "in" hyp(H) := autorewrite with length_db in H.

Infix "~p" := (@Permutation _) (at level 70).

Section length.
   
  Variable X : Type.

  Implicit Type l : list X.

  Fact length_nil : length (@nil X) = 0.

  Fact length_cons x l : length (x::l) = S (length l).

End length.

Hint Rewrite length_nil length_cons app_length map_length rev_length : length_db.

Section list_an.

  Fixpoint list_an a n :=
    match n with 
      | 0   => nil
      | S n => a::list_an (S a) n
    end.

  Fact list_an_S a n : list_an a (S n) = a::list_an (S a) n.

  Fact list_an_plus a n m : list_an a (n+m) = list_an a n ++ list_an (n+a) m.

  Fact list_an_length a n : length (list_an a n) = n.
  
  Fact list_an_spec a n m : In m (list_an a n) <-> a <= m < a+n.

  Fact map_S_list_an a n : map S (list_an a n) = list_an (S a) n.

  Fact list_an_app_inv a n l r : list_an a n = l++r -> l = list_an a (length l) /\ r = list_an (a+length l) (length r).

End list_an.

Hint Rewrite list_an_length : length_db.

Definition list_fun_inv X (l : list X) (x : X) : { f : nat -> X | l = map f (list_an 0 (length l)) }.

Fact list_upper_bound (l : list nat) : { m | forall x, In x l -> x < m }.

Section list_injective.

  Variable X : Type.
   
  Definition list_injective (ll : list X) :=  forall l a m b r, ll = l ++ a :: m ++ b :: r -> a <> b.
  
  Fact in_list_injective_0 : list_injective nil.
  
  Fact in_list_injective_1 x ll : ~ In x ll -> list_injective ll -> list_injective (x::ll).
  
  Fact list_injective_inv x ll : list_injective (x::ll) -> ~ In x ll /\ list_injective ll.
  
  Variable P : list X -> Type.
  
  Hypothesis (HP0 : P nil).
  Hypothesis (HP1 : forall x l, ~ In x l -> P l -> P (x::l)).
  
  Theorem list_injective_rect l : list_injective l -> P l.

End list_injective.

Fact list_injective_map X Y (f : X -> Y) ll :
       (forall x y, f x = f y -> x = y) -> list_injective ll -> list_injective (map f ll).

Section iter.
  
  Variable (X : Type) (f : X -> X).

  Fixpoint iter x n :=
    match n with
      | 0   => x
      | S n => iter (f x) n
    end.

  Fact iter_plus x a b : iter x (a+b) = iter (iter x a) b.

  Fact iter_swap x n : iter (f x) n = f (iter x n).

End iter.

Fixpoint list_repeat X (x : X) n :=
  match n with
    | 0   => nil
    | S n => x::list_repeat x n
  end.
  
Fact list_repeat_plus X x a b : @list_repeat X x (a+b) = list_repeat x a ++ list_repeat x b.
  
Fact list_repeat_length X x n : length (@list_repeat X x n) = n.

Fact In_list_repeat X (x y : X) n : In y (list_repeat x n) -> x = y /\ 0 < n.

Fact map_list_repeat X Y f x n : @map X Y f (list_repeat x n) = list_repeat (f x) n.

Fact map_cst_repeat X Y (y : Y) ll : map (fun _ : X => y) ll = list_repeat y (length ll).
  
Fact map_cst_snoc X Y (y : Y) ll mm : y :: map (fun _ : X => y) ll++mm = map (fun _ => y) ll ++ y::mm.

Fact map_cst_rev  X Y (y : Y) ll : map (fun _ : X => y) (rev ll) = map (fun _ => y) ll.

Fact In_perm X (x : X) l : In x l -> exists m, x::m ~p l.

Fact list_app_eq_inv X (l1 l2 r1 r2 : list X) :
       l1++r1 = l2++r2 -> { m | l1++m = l2 /\ r1 = m++r2 } 
                        + { m | l2++m = l1 /\ r2 = m++r1 }.

Fact list_app_cons_eq_inv X (l1 l2 r1 r2 : list X) x :
       l1++r1 = l2++x::r2 -> { m | l1++m = l2 /\ r1 = m++x::r2 } 
                           + { m | l2++x::m = l1 /\ r2 = m++r1 }.

Fact list_cons_app_cons_eq_inv X (l2 r1 r2 : list X) x y :
       x::r1 = l2++y::r2 -> (l2 = nil /\ x = y /\ r1 = r2) 
                          + { m | l2 = x::m /\ r1 = m++y::r2 }.
 
Fact list_app_inj X (l1 l2 r1 r2 : list X) : length l1 = length l2 -> l1++r1 = l2++r2 -> l1 = l2 /\ r1 = r2.

Fact list_split_length X (ll : list X) k : k <= length ll -> { l : _ & { r | ll = l++r /\ length l = k } }.

Fact list_pick X (ll : list X) k : k < length ll -> { x : _ & { l : _ & { r | ll = l++x::r /\ length l = k } } }.

Fact list_split_middle X l1 (x1 : X) r1 l2 x2 r2 : 
       ~ In x1 l2 -> ~ In x2 l1 -> l1++x1::r1 = l2++x2::r2 -> l1 = l2 /\ x1 = x2 /\ r1 = r2.

Section flat_map.

  Variable (X Y : Type) (f : X -> list Y).

  Fact flat_map_app l1 l2 : flat_map f (l1++l2) = flat_map f l1 ++ flat_map f l2.

  Fact flat_map_app_inv l r1 y r2 : flat_map f l = r1++y::r2 -> exists l1 m1 x m2 l2, l = l1++x::l2 /\ f x = m1++y::m2 
                                                                  /\ r1 = flat_map f l1++m1 /\ r2 = m2++flat_map f l2. 

End flat_map.

Definition prefix X (l ll : list X) := exists r, ll = l++r.
  
Infix "<p" := (@prefix _) (at level 70, no associativity).
  
Section prefix. 
   
  Variable X : Type.
  
  Implicit Types (l ll : list X).
  
  Fact in_prefix_0 ll : nil <p ll.
  
  Fact in_prefix_1 x l ll : l <p ll -> x::l <p x::ll.

  Fact prefix_length l m : l <p m -> length l <= length m.
  
  Fact prefix_app_lft l r1 r2 : r1 <p r2 -> l++r1 <p l++r2.
  
  Fact prefix_inv x y l ll : x::l <p y::ll -> x = y /\ l <p ll.
  
  Fact prefix_list_inv l r rr : l++r <p l++rr -> r <p rr.

  Fact prefix_refl l : l <p l.

  Fact prefix_trans l1 l2 l3 : l1 <p l2 -> l2 <p l3 -> l1 <p l3.

  Section prefix_rect.

    Variables (P : list X -> list X -> Type)
              (HP0 : forall ll, P nil ll)
              (HP1 : forall x l ll, l <p ll -> P l ll -> P (x::l) (x::ll)).
              
    Definition prefix_rect l ll : prefix l ll -> P l ll.
   
  End prefix_rect.

  Fact prefix_app_inv l1 l2 r1 r2 : l1++l2 <p r1++r2 -> { l1 <p r1 } + { r1 <p l1 }.
  
End prefix.

Definition prefix_spec X (l ll : list X) : l <p ll -> { r | ll = l ++ r }.

Fact prefix_app_lft_inv X (l1 l2 m : list X) : l1++l2 <p m -> { m2 | m = l1++m2 /\ l2 <p m2 }.

Section list_assoc.

  Variables (X Y : Type) (eq_X_dec : eqdec X).

  Fixpoint list_assoc x l : option Y :=
    match l with 
      | nil  => None
      | (y,a)::l => if eq_X_dec x y then Some a else list_assoc x l
    end.

  Fact list_assoc_eq x y l x' : x = x' -> list_assoc x' ((x,y)::l) = Some y.

  Fact list_assoc_neq x y l x' : x <> x' -> list_assoc x' ((x,y)::l) = list_assoc x' l.

  Fact list_assoc_In x l : 
    match list_assoc x l with 
      | None   => ~ In x (map fst l)
      | Some y => In (x,y) l
    end.

  Fact In_list_assoc x l : In x (map fst l) -> { y | list_assoc x l = Some y /\ In (x,y) l }.
  
  Fact not_In_list_assoc x l : ~ In x (map fst l) -> list_assoc x l = None.

  Fact list_assoc_app x ll mm : list_assoc x (ll++mm) 
                              = match list_assoc x ll with
                                  | None   => list_assoc x mm
                                  | Some y => Some y
                                end.

End list_assoc.

Section list_first_dec.

  Variable (X : Type) (P : X -> Prop) (Pdec : forall x, { P x } + { ~ P x }).
  
  Theorem list_choose_dec ll : { l : _ & { x : _ & { r | ll = l++x::r /\ P x /\ forall y, In y l -> ~ P y } } }
                             + { forall x, In x ll -> ~ P x }.
  
  Theorem list_first_dec a ll : P a -> In a ll -> { l : _ & { x : _ & { r | ll = l++x::r /\ P x /\ forall y, In y l -> ~ P y } } }.
  
End list_first_dec.

Section map.

  Variable (X Y : Type) (f : X -> Y).
  
  Fact map_cons_inv ll y m : map f ll = y::m -> { x : _ & { l | ll = x::l /\ f x = y /\ map f l = m } }.

  Fact map_app_inv ll m n : map f ll = m++n -> { l : _  & { r | ll = l++r /\ m = map f l /\ n = map f r } }.
  
  Fact map_middle_inv ll m y n : map f ll = m++y::n -> { l : _ & { x : _ & { r | ll = l++x::r /\ map f l = m /\ f x = y /\ map f r = n } } }.
  
End map.

Fact Forall2_mono X Y (R S : X -> Y -> Prop) :
         (forall x y, R x y -> S x y) -> forall l m, Forall2 R l m -> Forall2 S l m.

Fact Forall2_nil_inv_l X Y R m : @Forall2 X Y R nil m -> m = nil.

Fact Forall2_nil_inv_r X Y R m : @Forall2 X Y R m nil -> m = nil.

Fact Forall2_cons_inv X Y R x l y m : @Forall2 X Y R (x::l) (y::m) <-> R x y /\ Forall2 R l m.

Fact Forall2_app_inv_l X Y R l1 l2 m : 
    @Forall2 X Y R (l1++l2) m -> { m1 : _ & { m2 | Forall2 R l1 m1 /\ Forall2 R l2 m2 /\ m = m1++m2 } }.

Fact Forall2_app_inv_r X Y R l m1 m2 : 
    @Forall2 X Y R l (m1++m2) -> { l1 : _ & { l2 | Forall2 R l1 m1 /\ Forall2 R l2 m2 /\ l = l1++l2 } }.

Fact Forall2_cons_inv_l X Y R a ll mm : 
      @Forall2 X Y R (a::ll) mm 
   -> { b : _ & { mm' | R a b /\ mm = b::mm' /\ Forall2 R ll mm' } }.

Fact Forall2_cons_inv_r X Y R b ll mm : 
      @Forall2 X Y R ll (b::mm) 
   -> { a : _ & { ll' | R a b /\ ll = a::ll' /\ Forall2 R ll' mm } }.

Fact Forall2_map_left X Y Z (R : Y -> X -> Prop) (f : Z -> Y) ll mm : Forall2 R (map f ll) mm <-> Forall2 (fun x y => R (f x) y) ll mm.

Fact Forall2_map_right X Y Z (R : Y -> X -> Prop) (f : Z -> X) mm ll : Forall2 R mm (map f ll) <-> Forall2 (fun y x => R y (f x)) mm ll.

Fact Forall2_map_both X Y X' Y' (R : X -> Y -> Prop) (f : X' -> X) (g : Y' -> Y) ll mm : Forall2 R (map f ll) (map g mm) <-> Forall2 (fun x y => R (f x) (g y)) ll mm.

Fact Forall2_Forall X (R : X -> X -> Prop) ll : Forall2 R ll ll <-> Forall (fun x => R x x) ll.

Fact Forall_app X (P : X -> Prop) ll mm : Forall P (ll++mm) <-> Forall P ll /\ Forall P mm.

Fact Forall_cons_inv X (P : X -> Prop) x ll : Forall P (x::ll) <-> P x /\ Forall P ll.

Fact Forall_rev X (P : X -> Prop) ll : Forall P ll -> Forall P (rev ll).

Fact Forall_map X Y (f : X -> Y) (P : Y -> Prop) ll : Forall P (map f ll) <-> Forall (fun x => P (f x)) ll.

Fact Forall_forall_map X (f : nat -> X) n l (P : X -> Prop) :
           l = map f (list_an 0 n) -> (forall i, i < n -> P (f i)) <-> Forall P l.

Fact Forall_impl X (P Q : X -> Prop) ll : (forall x, In x ll -> P x -> Q x) -> Forall P ll -> Forall Q ll.

Fact Forall_filter X (P : X -> Prop) (f : X -> bool) ll : Forall P ll -> Forall P (filter f ll). *)
(* utils_nat:
Require Import List Arith Max Omega Wellfounded Bool.

Require Import list_focus utils_tac utils_list.

Set Implicit Arguments.

Section fin_reif.

  Variable (X : Type) (R : nat -> X -> Prop).

  Fact fin_reif n : (forall i, i < n -> exists x, R i x)
                 -> exists s, forall i (Hi : i < n), R i (s i Hi).

End fin_reif.

Fact fin_reif_nat (R : nat -> nat -> Prop) n :
         (forall i, i < n -> ex (R i)) -> exists s, forall i, i < n -> R i (s i).

Section bounded_search.

  Theorem bounded_search m (P : nat -> Type) :
        (forall n, n < m -> P n + (P n -> False))
     -> { n : nat & (n < m) * P n }%type + { forall n, n < m -> P n -> False }.

  Lemma bounded_min (P : nat -> Prop) : 
        (forall x, P x \/ ~ P x) 
     -> forall n, (exists k, k < n /\ P k /\ forall i, i < k -> ~ P i) \/ forall k, k < n -> ~ P k.

  Lemma minimize (P : nat -> Prop) : (forall x, P x \/ ~ P x) -> (exists n, P n) -> exists n, P n /\ forall i, i < n -> ~ P i.
   
  Lemma first_non_zero (f : nat -> nat) n : f 0 = 0 -> f n <> 0 -> exists i, i < n /\ (forall k, k <= i -> f k = 0) /\ f (i+1) <> 0.

End bounded_search.

Fact interval_dec a b i : { a <= i < b } + { i < a \/ b <= i }.

Definition lsum := fold_right plus 0.
Definition lmax := fold_right max 0.

Fact lmax_spec l x : lmax l <= x <-> Forall (fun y => y <= x) l.

Fact lsum_app l r : lsum (l++r) = lsum l+lsum r.

Section new.

  Definition nat_new l := S (lmax l).

  Fact nat_new_spec l : ~ In (nat_new l) l.

End new.

Local Notation Zero := false.
Local Notation One  := true.

Fixpoint div2 n : nat * bool :=
  match n with
    | 0 => (0,Zero)
    | 1 => (0,One)
    | S (S n) => let (p,b) := div2 n in (S p,b)
  end.

Fact div2_spec n : match div2 n with 
                     | (p,One)  => n = 2*p+1 
                     | (p,Zero) => n = 2*p
                   end.

Fixpoint div2_2p1 p : div2 (2*p+1) = (p,One).

Fixpoint div2_2p0 p : div2 (2*p) = (p,Zero).

Fixpoint pow2 p := 
  match p with 
    | 0   => 1
    | S p => 2*pow2 p
  end.

Section pow2_bound.

  Let loop := fix loop x n :=
    match n with 
      | 0 => 0
      | S n => match div2 x with 
                 | (0,_) => 0
                 | (p,_) => S (loop p n)
               end
    end.

  Let loop_prop n : forall x, x < n -> x < pow2 (S (loop x n)).

  Definition find_pow2 x := S (loop (pred x) x).

  Fact find_pow2_geq x : 1 <= find_pow2 x.

  Fact find_pow2_prop x : x <= pow2 (find_pow2 x).

End pow2_bound.

Section nat_sorted.
   
  Definition nat_sorted ll := forall l a m b r, ll = l ++ a :: m ++ b :: r -> a < b.
  
  Fact in_nat_sorted_0 : nat_sorted nil.
  
  Fact in_nat_sorted_1 x : nat_sorted (x::nil).
  
  Fact in_nat_sorted_2 x y ll : x < y -> nat_sorted (y::ll) -> nat_sorted (x::y::ll).
  
  Fact in_nat_sorted_3 x ll : Forall (lt x) ll -> nat_sorted ll -> nat_sorted (x::ll).
  
  Fact nat_sorted_cons_inv x ll : nat_sorted (x::ll) -> nat_sorted ll.
  
  Fact nat_sorted_Forall x ll : nat_sorted (x::ll) -> Forall (lt x) ll.
  
  Fact nat_sorted_head_inv x y ll : nat_sorted (x::y::ll) -> x < y.

  Variable P : list nat -> Type.
  
  Hypothesis (HP0 : P nil).
  Hypothesis (HP1 : forall x, P (x::nil)).
  Hypothesis (HP2 : forall x y l, x < y -> P (y::l) -> P (x::y::l)).
  
  Theorem nat_sorted_rect l : nat_sorted l -> P l.
  
End nat_sorted.

Fact nat_sorted_injective ll : nat_sorted ll -> list_injective ll.

Fixpoint nat_list_insert x l :=
  match l with
    | nil  => x::nil
    | y::l => if x <? y then x::y::l else
              if y <? x then y::nat_list_insert x l else y::l
  end.

Fact nat_list_insert_length x l : length (nat_list_insert x l) <= S (length l).
  
Fact nat_list_insert_incl x l : incl (nat_list_insert x l) (x::l)
                             /\ incl (x::l) (nat_list_insert x l).
  
Fact nat_list_insert_Forall (P : nat -> Prop) x l : 
      P x -> Forall P l -> Forall P (nat_list_insert x l).
  
Fact nat_list_insert_sorted x l : nat_sorted l -> nat_sorted (nat_list_insert x l).

Definition nat_sort := fold_right (nat_list_insert) nil.

Fact nat_sort_length l : length (nat_sort l) <= length l.

Fact nat_sort_eq l : incl (nat_sort l) l /\ incl l (nat_sort l).

Fact nat_sort_sorted l : nat_sorted (nat_sort l).

Fact nat_sinc (f : nat -> nat) a b : 
      (forall x, a <= x < b -> f x < f (S x)) 
   -> (forall x y, a <= x < y /\ y <= b -> f x < f y).

Fact nat_sinc_inj f a b : 
      (forall x y,  a <= x < y /\ y <= b -> f x < f y) 
   -> (forall x y,  a <= x <= b -> a <= y <= b -> f x = f y -> x = y).

Theorem nat_rev_ind (P : nat -> Prop) (HP : forall n, P (S n) -> P n) x y : x <= y -> P y -> P x.

Section nat_rev_bounded_ind.

  Variables (k : nat) (P : nat -> Prop) (HP : forall n, S n <= k -> P (S n) -> P n).
  
  Fact nat_rev_bounded_ind x y : x <= y <= k -> P y -> P x.

End nat_rev_bounded_ind.

Section nat_minimize.

  Variable P : nat -> Prop.
  Hypothesis HP : forall n, { P n } + { ~ P n }.

  Local Inductive bar_min (n : nat) : Prop :=
    | in_bar_min_0 : P n -> bar_min n
    | in_bar_min_1 : bar_min (S n) -> bar_min n.

  Section nat_min.

    Let min_rec : forall n, bar_min n -> { m | P m /\ forall x, P x -> x < n \/ m <= x }.

    Definition min_dec : (exists n, P n) -> { m | P m /\ forall x, P x -> m <= x }.

  End nat_min.

  Fact first_which : (exists x, P x) -> { m | P m /\ forall x, x < m -> ~ P x }.

End nat_minimize.

Section first_which_ni.

  Variable P : nat -> Prop.

  Fact bounded_search_ni n : (forall i, i < n -> P i \/ ~ P i) -> (forall i, i < n -> ~ P i) \/ exists i, i < n /\ P i /\ forall j, j < i -> ~ P j.
  
  Hypothesis HP : forall n, P n \/ ~ P n.

  Fact first_which_ni : (exists x, P x) -> exists m, P m /\ forall x, x < m -> ~ P x.

End first_which_ni. *)
(* bool_list:
Require Import List Omega Bool Setoid.
Require Import utils_tac.

Set Implicit Arguments.

  Local Reserved Notation "x ⪯ y" (at level 70, no associativity).
  Local Reserved Notation "x ⟂ y" (at level 70, no associativity).
  Local Reserved Notation "x ↓ y" (at level 40, left associativity).
  Local Reserved Notation "x ↑ y" (at level 41, left associativity).

  Local Notation lb := (list bool).
  Local Notation "⟘" := false.
  Local Notation "⟙" := true.
  Local Infix "⪦" := leb (at level 70, no associativity).

  Fact leb_refl : forall x, x ⪦ x.

  Fact leb_trans : forall x y z, x ⪦ y -> y ⪦ z -> x ⪦ z.

  Fact leb_strict : ⟘ ⪦ ⟙.

  Hint Resolve leb_refl leb_trans leb_strict.

  Inductive lb_mask : lb -> lb -> Prop :=
    | in_lb_mask_0 : forall l,                            nil ⪯ l
    | in_lb_mask_1 : forall l,                l ⪯ nil -> ⟘::l ⪯  nil 
    | in_lb_mask_2 : forall x y l m, x ⪦ y -> l ⪯ m   -> x::l ⪯  y::m
  where "l ⪯ m" := (lb_mask l m).

  Fact lb_mask_inv_nil l : ⟘::l ⪯  nil -> l ⪯  nil.

  Fact lb_mask_inv_left x l : x::l ⪯  nil -> x = ⟘ /\ l ⪯  nil.

  Fact lb_mask_inv_cons x y l m : x::l ⪯ y::m -> leb x y /\ l ⪯  m.

  Fact lb_mask_inv_cons_nil l : ⟙::l ⪯ nil -> False.

  Fact lb_mask_inv_cons_cons l m : ⟙::l ⪯ ⟘::m -> False.
 
  Definition lb_mask_leb := in_lb_mask_2.

  Fact lb_mask_refl l : l ⪯ l.

  Fact lb_mask_trans l m k : l ⪯ m -> m ⪯ k -> l ⪯ k.

  Hint Resolve lb_mask_refl lb_mask_trans.

  Definition lb_mask_equiv l m := l ⪯ m /\ m ⪯ l.

  Local Infix "≂" := lb_mask_equiv (at level 70, no associativity).

  Fact lb_mask_equiv_refl l : l ≂ l.

  Fact lb_mask_equiv_sym l m : l ≂ m -> m ≂ l.

  Fact lb_mask_equiv_trans l m k : l ≂ m -> m ≂ k -> l ≂ k.

  Fact lb_mask_app l m a b : length l = length m -> l ⪯ m -> a ⪯ b -> l++a ⪯ m++b.

  Fact lb_mask_equiv_app l m a b : length l = length m -> l ≂ m -> a ≂ b -> l++a ≂ m++b.

  Inductive lb_ortho : lb -> lb -> Prop :=
    | in_lb_ortho_0 : forall l, nil ⟂ l
    | in_lb_ortho_1 : forall l, l ⟂ nil
    | in_lb_ortho_2 : forall x y l m, (x = ⟘ \/ y = ⟘) -> l ⟂ m -> x::l ⟂ y::m
  where "x ⟂ y" := (lb_ortho x y).

  Hint Constructors lb_ortho.

  Fact lb_ortho_cons_inv x y l m : x::l ⟂ y::m -> (x = ⟘ \/ y = ⟘) /\ l ⟂ m.

  Fact lb_ortho_anti_left a b x : a ⪯ b -> b ⟂ x -> a ⟂ x.

  Fact lb_ortho_sym a b : a ⟂ b -> b ⟂ a.

  Fact lb_ortho_anti a b x y : a ⪯ b -> x ⪯ y -> b ⟂ y -> a ⟂ x.

  Section lb_pointwise.

    Variable (f : bool -> bool -> bool).

    Fixpoint lb_pointwise l m := 
      match l, m with
        | nil,   nil  => nil
        |  _,    nil  => map (fun x => f x ⟘) l
        | nil,     _  => map (f ⟘) m
        | x::l, y::m  => f x y :: lb_pointwise l m
      end.

    Fact lb_pointwise_nil : lb_pointwise nil nil = nil.

    Fact lb_pointwise_left l : lb_pointwise l nil = map (fun x => f x ⟘) l.

    Fact lb_pointwise_right l : lb_pointwise nil l = map (f ⟘) l.
 
    Fact lb_pointwise_cons x l y m : lb_pointwise (x::l) (y::m) = f x y :: lb_pointwise l m.

    Fact lb_pointwise_length n l m : length l <= n -> length m <= n -> length (lb_pointwise l m) <= n.

    Fact lb_pointwise_sym l m : (forall x y, f x y = f y x) -> lb_pointwise l m = lb_pointwise m l.

    Variable (Hf1 : forall x a b, leb a b -> leb (f x a) (f x b)) 
             (Hf2 : f ⟘ ⟘ = ⟘).

    Let lbpw_mono_1 l m :  lb_pointwise l nil ⪯   lb_pointwise l m.

    Let lbpw_mono_f_0 g l m : g ⟘ = ⟘ -> leb (g ⟘) (g ⟙) -> l ⪯ m -> map g l ⪯  map g m.

    Let lbpw_mono_2 l m : m ⪯ nil -> lb_pointwise l m ⪯   lb_pointwise l nil.

    Fact lb_pointwise_mono_left l m k : l ⪯  m -> lb_pointwise k l ⪯   lb_pointwise k m.
  
  End lb_pointwise.

  Definition lb_meet := (lb_pointwise andb).
  Definition lb_join := (lb_pointwise orb).

  Local Infix "↓" := lb_meet.
  Local Infix "↑" := lb_join.

  Fact lb_meet_left x : x↓nil ≂ nil.

  Fact lb_meet_comm l m : l↓m = m↓l.

  Fact lb_meet_right x : nil↓x ≂ nil.

  Fact lb_meet_cons x y l m : (x::l) ↓ (y::m) = x && y :: l↓m.

  Fact lb_meet_mono l m a b : l ⪯ m -> a ⪯ b -> l↓a ⪯  m↓b.

  Fact lb_meet_length_le n l m : length l <= n -> length m <= n -> length (l↓m) <= n.

  Fact lb_meet_length a b : length a = length b -> length (a↓b) = length a.

  Fact lb_meet_app l m a b : length l = length m -> (l++a)↓(m++b) = l↓m++a↓b.   

  Fact lb_join_left x : x↑nil = x.

  Fact lb_join_comm l m : l↑m = m↑l.

  Fact lb_join_right x : nil↑x = x.
 
  Fact lb_join_cons x y l m : (x::l) ↑ (y::m) = x || y :: l↑m.

  Fact lb_join_length_le n l m : length l <= n -> length m <= n -> length (l↑m) <= n.

  Fact lb_join_mono l m a b : l ⪯ m -> a ⪯ b -> l↑a ⪯  m↑b.

  Fact lb_ortho_meet_nil x y : x ⟂ y <-> x↓y ≂ nil.

  Hint Resolve lb_mask_equiv_refl.

  Fact lb_join_inc_left a b : a ⪯  a↑b.

  Fact lb_meet_dec_left a b : a↓b ⪯  a.

  Fact lb_join_inc_right a b : b ⪯  a↑b.

  Fact lb_meet_dec_right a b : a↓b ⪯  b.
  
  Hint Resolve lb_join_inc_left lb_join_inc_right lb_meet_dec_left lb_meet_dec_right.

  Fact lb_mask_join a b : a ⪯  b <-> a↑b ≂ b.

  Fact lb_mask_meet a b : a ⪯  b <-> a↓b ≂ a.

  Fact lb_meet_idem a : a↓a = a.

  Fact lb_join_idem a : a↑a = a.

  Tactic Notation "rew" "lb"  :=
       repeat (  rewrite lb_meet_left || rewrite lb_meet_right
              || rewrite lb_join_left || rewrite lb_join_right); auto.

  Fact lb_join_meet_distr a b c : a↑(b↓c) ≂ (a↑b)↓(a↑c).

  Fact lb_meet_join_distr a b c : a↓(b↑c) ≂ (a↓b)↑(a↓c).

  Fact lb_meet_assoc a b c : a↓(b↓c) ≂ a↓b↓c.

  Fact lb_join_assoc a b c : a↑(b↑c) ≂ a↑b↑c.

  Hint Resolve lb_meet_mono lb_join_mono.
  
  Fact lb_join_spec a b c : a ⪯  c -> b ⪯  c -> a↑b ⪯  c.

  Fact lb_meet_spec a b c : c ⪯  a -> c ⪯  b -> c ⪯  a↓b.

  Fact lb_meet_join_idem a b : a↓(a↑b) ≂ a.

  Fact lb_join_meet_idem a b : a↑(a↓b) ≂ a.

  Fact lb_join_nil_eq a b : a↑b ≂ nil -> a ≂ nil /\ b ≂ nil.

  Fact lb_ortho_join a x y : a ⟂ x↑y <-> a ⟂ x /\ a ⟂ y.

  Fact lb_ortho_mask_nil a x : a ⟂ x -> x ⪯  a -> x ≂ nil.

  Section lb_complement.

    Let bin_comp a b :=
      match a, b with
        | ⟘, ⟘  => ⟘ 
        | ⟘, ⟙  => ⟘
        | ⟙, ⟘  => ⟙
        | ⟙, ⟙  => ⟘ 
    end.

    Definition lb_complement a b : { c | b ⟂ c /\ a↑b ≂ c↑b }.

  End lb_complement.

  Definition lb_minus a b : a ⪯ b -> { c | a ⟂ c /\ b ≂ a↑c }. *)
(* gcd:
Require Import List Arith Omega Permutation.

Require Import utils_tac utils_list.

Set Implicit Arguments.

Section Euclid.

  Definition euclid n d : d <> 0 -> { q : nat & { r | n = q*d+r /\ r < d } }.

End Euclid.

Definition arem n d q j := j <= d /\ (n = 2*q*d+j \/ q <> 0 /\ n = 2*q*d-j).

Fact division_by_even n d : d <> 0 -> { q : nat & { j | arem n d q j } }.

Fact own_multiple x p : x = p*x -> x = 0 \/ p = 1.

Fact mult_is_one p q : p*q = 1 -> p = 1 /\ q = 1.

Definition divides n k := exists p, k = p*n.

Section divides.

  Infix "div" := divides (at level 70, no associativity).

  Fact divides_refl x : x div x.

  Fact divides_anti x y : x div y -> y div x -> x = y.

  Fact divides_trans x y z : x div y -> y div z -> x div z.

  Fact divides_0 p : p div 0.

  Fact divides_0_inv p : 0 div p -> p = 0.

  Fact divides_1 p : 1 div p.

  Fact divides_1_inv p : p div 1 -> p = 1.

  Fact divides_2_inv p : p div 2 -> p = 1 \/ p = 2.

  Fact divides_mult p q k : p div q -> p div k*q.

  Fact divides_mult_r p q k : p div q -> p div q*k.

  Fact divides_mult_compat a b c d : a div b -> c div d -> a*c div b*d.

  Fact divides_minus p q1 q2 : p div q1 -> p div q2 -> p div q1 - q2.

  Fact divides_plus p q1 q2 : p div q1 -> p div q2 -> p div q1+q2.

  Fact divides_plus_inv p q1 q2 : p div q1 -> p div q1+q2 -> p div q2.

  Fact divides_le p q : q <> 0 -> p div q -> p <= q.

  Fact divides_mult_inv k p q : k <> 0 -> k*p div k*q -> p div q.

  Lemma divides_fact m p : 1 < p <= m -> p div fact m.

  Lemma divides_mult_inv_l p q r : p * q div r -> p div r /\ q div r.

End divides.

Section gcd_lcm.

  Infix "div" := divides (at level 70, no associativity).

  Hint Resolve divides_0 divides_refl divides_mult divides_1.

  Definition is_gcd p q r := r div p /\ r div q /\ forall k, k div p -> k div q -> k div r.
  Definition is_lcm p q r := p div r /\ q div r /\ forall k, p div k -> q div k -> r div k.

  Fact is_gcd_sym p q r : is_gcd p q r -> is_gcd q p r.

  Fact is_gcd_0l p : is_gcd 0 p p.

  Fact is_gcd_0r p : is_gcd p 0 p.

  Fact is_gcd_1l p : is_gcd 1 p 1.

  Fact is_gcd_1r p : is_gcd p 1 1.

  Fact is_gcd_modulus p q k r : p div k -> k <= q -> is_gcd p q r -> is_gcd p (q-k) r.

  Fact is_gcd_minus p q r : p <= q -> is_gcd p q r -> is_gcd p (q-p) r.

  Hint Resolve divides_plus.

  Fact is_gcd_moduplus p q k r : p div k -> is_gcd p q r -> is_gcd p (q+k) r.

  Fact is_gcd_plus p q r : is_gcd p q r -> is_gcd p (q+p) r.

  Fact is_gcd_mult p q r n : is_gcd p (n*p+q) r <-> is_gcd p q r.

  Fact is_gcd_div p q : p div q -> is_gcd p q p.

  Fact is_gcd_refl p : is_gcd p p p.

  Fact is_gcd_fun p q r1 r2 : is_gcd p q r1 -> is_gcd p q r2 -> r1 = r2.

  Fact is_lcm_0l p : is_lcm 0 p 0.

  Fact is_lcm_0r p : is_lcm p 0 0.

  Fact is_lcm_sym p q r : is_lcm p q r -> is_lcm q p r.

  Fact is_lcm_fun p q r1 r2 : is_lcm p q r1 -> is_lcm p q r2 -> r1 = r2.

End gcd_lcm.

Section bezout.

  Infix "div" := divides (at level 70, no associativity).

  Hint Resolve is_gcd_0l is_gcd_0r is_lcm_0l is_lcm_0r divides_refl divides_mult divides_0 is_gcd_minus.

  Section bezout_rel_prime.

    Let bezout_rec p q : 0 < p < q -> is_gcd p q 1 -> exists a b, a*p+b*q = 1+p*q /\ a <= q /\ b <= p.

    Lemma bezout_nc p q : is_gcd p q 1 -> exists a b, a*p+b*q = 1+p*q.

    Hint Resolve divides_1.

    Lemma bezout_sc p q a b m : a*p+b*q = 1 + m -> p div m \/ q div m -> is_gcd p q 1.

  End bezout_rel_prime.

  Fact is_rel_prime_div p q k : is_gcd p q 1 -> p div q*k -> p div k.

  Fact is_rel_prime_div_r p q k : is_gcd p q 1 -> p div k*q -> p div k.

  Fact is_rel_prime_lcm p q : is_gcd p q 1 -> is_lcm p q (p*q).

  Hint Resolve divides_1 divides_mult_compat is_gcd_refl.

  Fact is_gcd_0 p q : is_gcd p q 0 -> p = 0 /\ q = 0.

  Fact is_gcd_rel_prime p q g : is_gcd p q g -> exists a b, p = a*g /\ q = b*g /\ is_gcd a b 1.

  Fact is_lcm_mult p q l k : is_lcm p q l -> is_lcm (k*p) (k*q) (k*l).

  Theorem is_gcd_lcm_mult p q g l : is_gcd p q g -> is_lcm p q l -> p*q = g*l.

  Theorem is_gcd_mult_lcm p q g l : g <> 0 -> is_gcd p q g -> g*l = p*q -> is_lcm p q l.

  Lemma is_lcm_minus p q g l u : p <= q -> p = u*g -> is_gcd p q g -> is_lcm p q l -> is_lcm p (q-p) (l-u*p).

  Lemma is_lcm_modulus k p q g l u : k*p <= q -> p = u*g -> is_gcd p q g -> is_lcm p q l -> is_lcm p (q-k*p) (l-k*u*p).

  Lemma is_lcm_plus p q g l u : p = u*g -> is_gcd p q g -> is_lcm p q l -> is_lcm p (q+p) (l+u*p).

  Lemma is_lcm_moduplus k p q g l u : p = u*g -> is_gcd p q g -> is_lcm p q l -> is_lcm p (q+k*p) (l+k*u*p).

  Section bezout_generalized.

    Let bezout_rec p q : 0 < p < q 
                      -> { a : nat 
                       & { b : nat 
                       & { g : nat
                       & { l : nat 
                       & { u : nat
                       & { v : nat
                         | a*p+b*q = g + l
                        /\ is_gcd p q g
                        /\ is_lcm p q l
                        /\ p = u*g
                        /\ q = v*g
                        /\ a <= v
                        /\ b <= u } } } } } }.
  
    Hint Resolve is_gcd_sym is_lcm_sym.

    Definition bezout_generalized p q : { a : nat 
                                      & { b : nat 
                                      & { g : nat
                                      & { l : nat 
                                        | a*p+b*q = g + l
                                       /\ is_gcd p q g
                                       /\ is_lcm p q l } } } }.

  End bezout_generalized.

  Section gcd_lcm.

    Let gcd_full p q : sig (is_gcd p q).

    Definition gcd p q := proj1_sig (gcd_full p q).
    Fact gcd_spec p q : is_gcd p q (gcd p q).

    Let lcm_full p q : sig (is_lcm p q).

    Definition lcm p q := proj1_sig (lcm_full p q).
    Fact lcm_spec p q : is_lcm p q (lcm p q).

  End gcd_lcm.
     
End bezout.

Require Import Extraction.
Extraction Inline measure_rect.

Check bezout_generalized.
Print Assumptions bezout_generalized.

Section division.

  Fact div_full q p : { n : nat & { r | q = n*p+r /\ (p <> 0 -> r < p) } }.

  Definition div q p := projT1 (div_full q p).
  Definition rem q p := proj1_sig (projT2 (div_full q p)).

  Fact div_rem_spec1 q p : q = div q p * p + rem q p.

  Fact div_rem_spec2 q p : p <> 0 -> rem q p < p.

  Fact rem_0 q : rem q 0 = q.

  Fact div_rem_uniq p n1 r1 n2 r2 : 
        p <> 0 -> n1*p + r1 = n2*p + r2 -> r1 < p -> r2 < p -> n1 = n2 /\ r1 = r2.

  Fact div_prop q p n r : q = n*p+r -> r < p -> div q p = n.

  Fact rem_prop q p n r : q = n*p+r -> r < p -> rem q p = r.

  Fact rem_idem q p : q < p -> rem q p = q.

  Fact is_gcd_rem p n a : is_gcd p n a <-> is_gcd p (rem n p) a.

  Fact rem_erase q n p r : q = n*p+r -> rem q p = rem r p.

  Fact divides_div q p : divides p q -> q = div q p * p.

  Fact divides_rem_eq q p : divides p q <-> rem q p = 0.

  Fact rem_of_0 p : rem 0 p = 0.

  Hint Resolve divides_0_inv.

  Fact divides_dec q p : { k | q = k*p } + { ~ divides p q }.

End division.

Section rem.

  Variable (p : nat) (Hp : p <> 0).

  Fact rem_plus_rem a b : rem (a+rem b p) p = rem (a+b) p.

  Fact rem_mult_rem a b : rem (a*rem b p) p = rem (a*b) p.

  Fact rem_diag : rem p p = 0.

  Fact rem_lt a : a < p -> rem a p = a.

  Fact rem_plus a b : rem (a+b) p = rem (rem a p + rem b p) p.

  Fact rem_scal k a : rem (k*a) p = rem (k*rem a p) p.

  Fact rem_plus_div a b : divides p b -> rem a p = rem (a+b) p.

  Fact div_eq_0 n : n < p -> div n p = 0.

  Fact div_of_0 : div 0 p = 0.

  Fact div_ge_1 n : p <= n -> 1 <= div n p.

End rem.

Fact div_by_p_lt p n : 2 <= p -> n <> 0 -> div n p < n.

Section rem_2.

  Fact rem_2_is_0_or_1 x : rem x 2 = 0 \/ rem x 2 = 1.

  Fact rem_2_mult x y : rem (x*y) 2 = 1 <-> rem x 2 = 1 /\ rem y 2 = 1.

  Fact rem_2_fix_0 : rem 0 2 = 0.

  Fact rem_2_fix_1 n : rem (2*n) 2 = 0.

  Fact rem_2_fix_2 n : rem (1+2*n) 2 = 1.

  Fact rem_2_lt n : rem n 2 < 2.

  Fact div_2_fix_0 : div 0 2 = 0.

  Fact div_2_fix_1 n : div (2*n) 2 = n.

  Fact div_2_fix_2 n : div (1+2*n) 2 = n.

  Fact euclid_2_div n : n = rem n 2 + 2*div n 2 /\ (rem n 2 = 0 \/ rem n 2 = 1).

  Fact euclid_2 n : exists q, n = 2*q \/ n = 1+2*q.

End rem_2.

Local Hint Resolve divides_mult divides_mult_r divides_refl.

Theorem CRT u v a b : u <> 0 -> v <> 0 -> is_gcd u v 1 -> exists w, rem w u = rem a u /\ rem w v = rem b v /\ 2 < w. *)
(* sums:
Require Import List Arith Omega Eqdep_dec ZArith.

Require Import utils_tac utils_list binomial.

Set Implicit Arguments.

Record monoid_theory (X : Type) (m : X -> X -> X) (u : X) := mk_monoid {
  monoid_unit_l : forall x, m u x = x;
  monoid_unit_r : forall x, m x u = x;
  monoid_assoc  : forall x y z, m x (m y z) = m (m x y) z;
}.

Fact Nat_plus_monoid : monoid_theory plus 0.

Fact Nat_mult_monoid : monoid_theory mult 1.

Fact Zplus_monoid : monoid_theory Zplus 0%Z.

Fact Zmult_monoid : monoid_theory Zmult 1%Z.

Hint Resolve Nat_plus_monoid Nat_mult_monoid
             Zplus_monoid Zmult_monoid.

Section msum.

  Variable (X : Type) (m : X -> X -> X) (u : X).

  Infix "⊕" := m (at level 50, left associativity).

  Fixpoint msum n f := 
    match n with 
      | 0   => u
      | S n => f 0 ⊕ msum n (fun n => f (S n))
    end.

  Notation "∑" := msum.

  Fact msum_fold_map n f : ∑ n f = fold_right m u (map f (list_an 0 n)).

  Fact msum_0 f : ∑ 0 f = u.

  Fact msum_S n f : ∑ (S n) f = f 0 ⊕ ∑ n (fun n => f (S n)).

  Hypothesis Hmonoid : monoid_theory m u.

  Fact msum_1 f : ∑ 1 f = f 0.

  Fact msum_plus a b f : ∑ (a+b) f = ∑ a f ⊕ ∑ b (fun i => f (a+i)).

  Fact msum_plus1 n f : ∑ (S n) f = ∑ n f ⊕ f n.

  Fact msum_ext n f g : (forall i, i < n -> f i = g i) -> ∑ n f = ∑ n g.

  Fact msum_unit n : ∑ n (fun _ => u) = u.

  Fact msum_comm a n f : (forall i, i < n -> f i ⊕ a = a ⊕ f i) -> ∑ n f ⊕ a = a ⊕ ∑ n f.

  Fact msum_sum n f g : (forall i j, i < j < n -> f j ⊕ g i = g i ⊕ f j) -> ∑ n (fun i => f i ⊕ g i) = ∑ n f ⊕ ∑ n g.

  Fact msum_of_unit n f : (forall i, i < n -> f i = u) -> ∑ n f = u.

  Fact msum_only_one n f i : i < n
                          -> (forall j, j < n -> i <> j -> f j = u)
                          -> ∑ n f = f i.

  Fact msum_msum n k f :
          (forall i1 j1 i2 j2, i1 < n -> j1 < k -> i2 < n -> j2 < k -> f i1 j1 ⊕ f i2 j2 = f i2 j2 ⊕ f i1 j1)
       -> ∑ n (fun i => ∑ k (f i)) = ∑ k (fun j => ∑ n (fun i => f i j)).

  Fact msum_ends n f : (forall i, 0 < i <= n -> f i = u) -> ∑ (n+2) f = f 0 ⊕ f (S n).

  Fact msum_first_two n f : 2 <= n -> (forall i, 2 <= i -> f i = u) -> ∑ n f = f 0 ⊕ f 1.

  Definition mscal n x := msum n (fun _ => x).

  Fact mscal_0 x : mscal 0 x = u.

  Fact mscal_S n x : mscal (S n) x = x ⊕ mscal n x.

  Fact mscal_1 x : mscal 1 x = x.

  Fact mscal_of_unit n : mscal n u = u.

  Fact mscal_plus a b x : mscal (a+b) x = mscal a x ⊕ mscal b x.

  Fact mscal_plus1 n x : mscal (S n) x = mscal n x ⊕ x.

  Fact mscal_comm n x y : x ⊕ y = y ⊕ x -> mscal n x ⊕ y = y ⊕ mscal n x.

  Fact mscal_sum n x y : x ⊕ y = y ⊕ x -> mscal n (x ⊕ y) = mscal n x ⊕ mscal n y.

  Fact mscal_mult a b x : mscal (a*b) x = mscal a (mscal b x).

  Fact msum_mscal n k f : (forall i j, i < n -> j < n -> f i ⊕ f j = f j ⊕ f i) 
                       -> ∑ n (fun i => mscal k (f i)) = mscal k (∑ n f).

End msum.

Section msum_morphism.

  Variable (X Y : Type) (m1 : X -> X -> X) (u1 : X) 
                        (m2 : Y -> Y -> Y) (u2 : Y)
           (H1 : monoid_theory m1 u1)
           (H2 : monoid_theory m2 u2)
           (phi : X -> Y)
           (Hphi1 : phi u1 = u2)
           (Hphi2 : forall x y, phi (m1 x y) = m2 (phi x) (phi y)).

  Fact msum_morph n f : phi (msum m1 u1 n f) = msum m2 u2 n (fun x => phi (f x)).

  Fact mscal_morph n x : phi (mscal m1 u1 n x) = mscal m2 u2 n (phi x).

End msum_morphism.

Section binomial_Newton.

  Variable (X : Type) (sum times : X -> X -> X) (zero one : X).

  Infix "⊕" := sum (at level 50, left associativity).
  Infix "⊗" := times (at level 40, left associativity).
  
  Notation z := zero.
  Notation o := one.

  Notation scal := (mscal sum zero).
  Notation expo := (mscal times one).

  Hypothesis (M_sum : monoid_theory sum zero) 
             (sum_comm : forall x y, x ⊕ y = y ⊕ x)
             (sum_cancel : forall x u v, x ⊕ u = x ⊕ v -> u = v)
             (M_times : monoid_theory times one)
             (distr_l : forall x y z, x ⊗ (y⊕z) = x⊗y ⊕ x⊗z)
             (distr_r : forall x y z, (y⊕z) ⊗ x = y⊗x ⊕ z⊗x).

  Fact times_zero_l x : z ⊗ x = z.

  Fact times_zero_r x : x ⊗ z = z.

  Notation "∑" := (msum sum zero).

  Fact sum_0n_scal n k f : ∑ n (fun i => scal k (f i)) = scal k (∑ n f).

  Fact scal_times k x y : scal k (x⊗y) = x⊗scal k y.

  Fact scal_one_comm k x : scal k o ⊗ x = x ⊗ scal k o.

  Corollary scal_one k x : scal k x = scal k o ⊗ x.

  Fact sum_0n_distr_l b n f : ∑ n (fun i => b⊗f i) = b⊗∑ n f.

  Fact sum_0n_distr_r b n f : ∑ n (fun i => f i⊗b) = ∑ n f ⊗ b.

  Theorem binomial_Newton n a b :
        a ⊗ b = b ⊗ a
     -> expo n (a ⊕ b) = ∑ (S n) (fun i => scal (binomial n i) (expo (n - i) a ⊗ expo i b)).

End binomial_Newton.

Section Newton_nat.

  Notation power := (mscal mult 1).
  Notation "∑" := (msum plus 0).

  Fact sum_fold_map n f : ∑ n f = fold_right plus 0 (map f (list_an 0 n)).

  Fact power_0 x : power 0 x = 1.

  Fact power_S n x : power (S n) x = x * power n x.

  Fact power_1 x : power 1 x = x.

  Fact power_of_0 n : 0 < n -> power n 0 = 0.

  Fact power_of_1 n : power n 1 = 1.

  Fact power_plus p a b : power (a+b) p = power a p * power b p.

  Fact power_mult p a b : power (a*b) p = power a (power b p).
  
  Fact power_ge_1 k p : p <> 0 -> 1 <= power k p.

  Fact power2_gt_0 n : 0 < power n 2.

  Fact power_sinc k p : 2 <= p -> power k p < power (S k) p.

  Fact power_ge_n k p : 2 <= p -> k <= power k p.

  Fact power_mono_l p q x : 1 <= x -> p <= q -> power p x <= power q x.

  Definition power_mono := power_mono_l.
  
  Fact power_smono_l p q x : 2 <= x -> p < q -> power p x < power q x.

  Fact power_mono_r n p q : p <= q -> power n p <= power n q.

  Fact power_0_inv p n : power p n = 0 <-> n = 0 /\ 0 < p.

  Fact plus_cancel_l : forall a b c, a + b = a + c -> b = c.

  Let plus_cancel_l':= plus_cancel_l.

  Fact sum_0n_scal_l n k f : ∑ n (fun i => k*f i) = k*∑ n f.

  Fact sum_0n_scal_r n k f : ∑ n (fun i => (f i)*k) = (∑ n f)*k.

  Fact sum_0n_mono n f g : (forall i, i < n -> f i <= g i) -> ∑ n f <= ∑ n g.

  Fact sum_0n_le_one n f i : i < n -> f i <= ∑ n f.

  Fact sum_power_lt k n f : k <> 0 -> (forall i, i < n -> f i < k) -> ∑ n (fun i => f i * power i k) < power n k.

  Theorem Newton_nat a b n :
       power n (a + b) = ∑ (S n) (fun i => binomial n i * power (n - i) a * power i b).

  Theorem Newton_nat_S a n :
       power n (1 + a) = ∑ (S n) (fun i => binomial n i * power i a).

  Lemma binomial_le_power n i : binomial n i <= power n 2.

  Corollary binomial_lt_power n i : binomial n i < power (S n) 2.

End Newton_nat. *)
(* power_decomp:
Require Import Arith Nat Omega.
Require Import utils_tac gcd rel_iter sums.

Set Implicit Arguments.

Local Notation power := (mscal mult 1).
Local Notation "∑" := (msum plus 0).

Fact sum_0n_distr_in_out n a b f :
      ∑ n (fun i => (a i+b i) * f i) 
    = ∑ n (fun i => a i * f i) 
    + ∑ n (fun i => b i * f i).

Section power_decomp.

  Variable (p : nat) (Hp : 2 <= p).

  Let power_nzero x : power x p <> 0.

  Fact power_decomp_lt n f a q :  
           (forall i j, i < j < n -> f i < f j)
        -> (forall i, i < n -> f i < q)
        -> (forall i, i < n -> a i < p)
        -> ∑ n (fun i => a i * power (f i) p) < power q p.

  Lemma power_decomp_is_digit n a f : 
           (forall i j, i < j < n -> f i < f j)
        -> (forall i, i < n -> a i < p)
        ->  forall i, i < n -> is_digit (∑ n (fun i => a i * power (f i) p)) p (f i) (a i).

  Theorem power_decomp_unique n f a b :
            (forall i j, i < j < n -> f i < f j)
         -> (forall i, i < n -> a i < p)
         -> (forall i, i < n -> b i < p)
         -> ∑ n (fun i => a i * power (f i) p)
          = ∑ n (fun i => b i * power (f i) p)
         -> forall i, i < n -> a i = b i.

End power_decomp.

Section power_decomp_uniq.

  Variable (p : nat) (Hp : 2 <= p).

  Theorem power_decomp_factor n f a : 
           (forall i, 0 < i < S n -> f 0 < f i)
        -> ∑ (S n) (fun i => a i * power (f i) p) 
         = ∑ n (fun i => a (S i) * power (f (S i) - f 0 - 1) p) * power (S (f 0)) p
         + a 0 * power (f 0) p.

  Let power_nzero x : power x p <> 0.

  Let lt_minus_cancel a b c : a < b < c -> b - a - 1 < c - a - 1.

  Theorem power_decomp_unique' n f a b :
            (forall i j, i < j < n -> f i < f j)
         -> (forall i, i < n -> a i < p)
         -> (forall i, i < n -> b i < p)
         -> ∑ n (fun i => a i * power (f i) p)
          = ∑ n (fun i => b i * power (f i) p)
         -> forall i, i < n -> a i = b i.

End power_decomp_uniq.

Fact mult_2_eq_plus x : x + x = 2 *x.

Section power_injective.

  Let power_2_inj_1 i j n : j < i -> 2* power n 2 <> power i 2 + power j 2.

  Fact power_2_inj i j : power i 2 = power j 2 -> i = j.

  Let power_plus_lt a b c : a < b < c -> power a 2 + power b 2 < power c 2.

  Let power_inj_2 i1 j1 i2 j2 : 
             j1 < i1 
          -> j2 < i2 
          -> power i1 2 + power j1 2 = power i2 2 + power j2 2
          -> i1 = i2 /\ j1 = j2.

  Theorem sum_2_power_2_injective i1 j1 i2 j2 :
              j1 <= i1 
           -> j2 <= i2 
           -> power i1 2 + power j1 2 = power i2 2 + power j2 2 
           -> i1 = i2 /\ j1 = j2.
 
End power_injective. *)



Set Implicit Arguments.



Local Notation power := (mscal mult 1).

Local Notation "∑" := (msum plus 0).



Local Reserved Notation "x ≲ y" (at level 70, no associativity).



Inductive binary_le : nat -> nat -> Prop :=

 | in_ble_0 : forall n, 0 ≲ n

 | in_ble_1 : forall n m, rem n 2 <= rem m 2 -> div n 2 ≲ div m 2 -> n ≲ m

where "x ≲ y" := (binary_le x y).



Local Infix "≲" := binary_le (at level 70, no associativity).



Fact binary_le_inv n m : n ≲ m -> n = 0 \/ div n 2 ≲ div m 2 /\ rem n 2 <= rem m 2.

Proof. inversion 1; auto. Qed.



Fact binary_le_refl x : x ≲ x.

Proof.

  induction on x as IH with measure x.

  destruct (eq_nat_dec x 0).

  + subst; constructor.

  + constructor 2; auto.

    apply IH, div_by_p_lt; auto.

Qed.



Fact binary_le_le x y : x ≲ y -> x <= y.

Proof.

  induction 1 as [ n | n m H1 H2 IH2 ]; try omega.

  rewrite (div_rem_spec1 n 2), (div_rem_spec1 m 2); omega.

Qed.



Fact binary_le_zero_inv n : n ≲ 0 -> n = 0.

Proof. intros H; apply binary_le_le in H; omega. Qed.



Fact binary_le_zero n : 0 ≲ n.

Proof. constructor. Qed.



Hint Resolve binary_le_zero binary_le_refl.



Local Notation "⟘" := false.

Local Notation "⟙" := true.



Definition bool2nat x := 

  match x with 

    | ⟘ => 0 

    | ⟙ => 1 

  end.

 

Fact rem_2_bool2nat b n : rem (bool2nat b+2*n) 2 = bool2nat b.

Proof. 

  destruct b; unfold bool2nat.

  + apply rem_2_fix_2.

  + apply rem_2_fix_1.

Qed.



Fact div_2_bool2nat b n : div (bool2nat b+2*n) 2 = n.

Proof. 

  destruct b; unfold bool2nat.

  + apply div_2_fix_2.

  + apply div_2_fix_1.

Qed.



Definition nat2bool x := 

  match x with 

    | 0 => ⟘ 

    | _ => ⟙ 

  end.



Fact bool2nat2bool : forall x, x < 2 -> bool2nat (nat2bool x) = x.

Proof. intros [ | [ | ] ] ?; simpl; omega. Qed.



Fact nat2bool2nat : forall x, nat2bool (bool2nat x) = x.

Proof. intros []; auto. Qed.



Local Hint Resolve power2_gt_0.



Local Notation lb := (list bool).



Local Infix "⪦" := leb (at level 70, no associativity).

Local Infix "⪯" := lb_mask (at level 70, no associativity).

Local Infix "≂" := lb_mask_equiv (at level 70, no associativity).

Local Infix "⟂" := lb_ortho (at level 70, no associativity).

Local Infix "↓" := lb_meet (at level 40, left associativity).

Local Infix "↑" := lb_join (at level 41, left associativity).



Local Reserved Notation "'⟦' l '⟧'".

Local Reserved Notation "'⟬' x '⟭'".



  Fixpoint lb_nat (l : lb) :=

    match l with

      | nil    => 0

      | x :: l => bool2nat x + 2*⟦l⟧

    end

  where "⟦ l ⟧" := (lb_nat l).



  Fact lb_nat_fix_0 : ⟦nil⟧ = 0.                      Proof. trivial. Qed.

  Fact lb_nat_fix_1 l : ⟦⟘::l⟧ = 2*⟦l⟧.               Proof. trivial. Qed.

  Fact lb_nat_fix_2 l : ⟦⟙::l⟧ = 1+2*⟦l⟧.             Proof. trivial. Qed.

  Fact lb_nat_fix_3 x l : ⟦x::l⟧ = bool2nat x+2*⟦l⟧.  Proof. trivial. Qed.



  Fact lb_nat_app l m : lb_nat (l++m) = lb_nat l + (power (length l) 2)*(lb_nat m).

  Proof.

    induction l as [ | x l IHl ].

    + rewrite lb_nat_fix_0; simpl; omega.

    + simpl app; do 2 rewrite lb_nat_fix_3.

      simpl length; rewrite power_S.

      rewrite IHl; ring.

  Qed.



  Fact lb_mask_binary_le l m : l ⪯ m -> ⟦l⟧ ≲ ⟦m⟧.

  Proof.

    induction 1 as [ l | l H1 IH1 | x y l m H1 H2 IH2 ].

    - constructor 1.

    - apply binary_le_zero_inv in IH1.

      simpl; rewrite IH1; constructor.

    - do 2 rewrite lb_nat_fix_3.

      constructor 2.

      * do 2 rewrite rem_2_bool2nat.

        revert x y H1; intros [] []; simpl; auto; discriminate.

      * do 2 rewrite div_2_bool2nat; auto.

  Qed.



  Section nat_lb_def.



    Inductive g_nlb : nat -> lb -> Prop :=

      | in_gnlb_0 : g_nlb 0 nil

      | in_gnlb_1 : forall n l, n <> 0 -> rem n 2 = 0 -> g_nlb (div n 2) l -> g_nlb n (⟘::l)

      | in_gnlb_2 : forall n l, n <> 0 -> rem n 2 = 1 -> g_nlb (div n 2) l -> g_nlb n (⟙::l).

   

    Fact g_nlb_fun n l1 l2 : g_nlb n l1 -> g_nlb n l2 -> l1 = l2.

    Proof.

      intros H1 H2; revert H1 l2 H2.

      induction 1; inversion 1; auto; try omega; f_equal; auto.

    Qed.



    Let nat_lb_full n : { l | g_nlb n l }.

    Proof.

      induction on n as IHn with measure n.

      destruct (eq_nat_dec n 0) as [ | Hn ].

      + exists nil; subst; constructor.

      + destruct (IHn (div n 2)) as (l & Hl).

        * apply div_by_p_lt; omega.

        * case_eq (rem n 2).

          - intro; exists (⟘::l); constructor; auto.

          - intro; exists (⟙::l); constructor; auto.

            generalize (rem_2_lt n); omega.

    Qed.



    Definition nat_lb n := proj1_sig (nat_lb_full n).

  

    Fact nat_lb_spec n : g_nlb n (nat_lb n).

    Proof. apply (proj2_sig (nat_lb_full _)). Qed.



  End nat_lb_def.



  Local Notation "⟬ n ⟭" := (nat_lb n).



  Hint Resolve nat_lb_spec.



  Fact nat_lb_fix_0 : ⟬ 0⟭ = nil.

  Proof. apply g_nlb_fun with 0; auto; constructor. Qed.



  Fact nat_lb_fix_1 n : n <> 0 -> ⟬ 2*n⟭ = ⟘::⟬ n⟭ .

  Proof.

    intros Hn. 

    apply g_nlb_fun with (2*n); auto.

    constructor; auto; try omega.

    + apply rem_2_fix_1.

    + rewrite div_2_fix_1; auto.

  Qed.



  Fact nat_lb_fix_2 n : ⟬1+2*n⟭ = ⟙::⟬ n⟭ .

  Proof.

    apply g_nlb_fun with (1+2*n); auto.

    constructor; auto; try omega.

    + apply rem_2_fix_2.

    + rewrite div_2_fix_2; auto.

  Qed.



  Fact nat_lb_1 : ⟬ 1⟭ = ⟙::nil.

  Proof.

    change 1 with (1+2*0).

    rewrite nat_lb_fix_2, nat_lb_fix_0.

    trivial.

  Qed.



  Fact lb_nat_lb n : ⟦⟬ n ⟭⟧ = n.

  Proof.

    induction on n as IHn with measure n.

    destruct (eq_nat_dec n 0) as [ | Hn ].

    + subst; rewrite nat_lb_fix_0; auto.

    + destruct (euclid_2 n) as (q & [ Hq | Hq ]); subst n.

      * rewrite nat_lb_fix_1; try omega.

        rewrite lb_nat_fix_1; f_equal.

        apply IHn; omega.

      * rewrite nat_lb_fix_2; try omega.

        rewrite lb_nat_fix_2; do 2 f_equal.

        apply IHn; omega.

  Qed.



  Fact nat_lb_length x n : x < power n 2 -> length ⟬ x ⟭ <= n.

  Proof.

    revert x; induction n as [ | n IHn ]; intros x.

    + rewrite power_0; intro; cutrewrite (x=0); try omega.

      rewrite nat_lb_fix_0; simpl; omega.

    + rewrite power_S.

      destruct (euclid_2 x) as (y & [ H | H ]); intros Hx; subst.

      * destruct y.

        - simpl; rewrite nat_lb_fix_0;simpl; omega.

        - rewrite nat_lb_fix_1; try omega.

          simpl; apply le_n_S, IHn; omega.

      * rewrite nat_lb_fix_2; simpl.

        apply le_n_S, IHn; omega.

  Qed.



  Fact binary_le_lb_mask x y : x ≲ y -> ⟬ x ⟭ ⪯ ⟬ y ⟭ . 

  Proof.

    induction 1 as [ n | n m H1 H2 IH2 ].

    + rewrite nat_lb_fix_0; constructor.

    + destruct (eq_nat_dec n 0) as [ Hn | Hn ].

      - subst; rewrite nat_lb_fix_0; constructor.

      - assert (n <= m) as Hmn.

        { apply binary_le_le; constructor; auto. }

        destruct (euclid_2_div n) as (G1 & [ G2 | G2 ] );

        destruct (euclid_2_div m) as (G3 & [ G4 | G4 ] ); try omega.

        * rewrite G1, G2, G3, G4, Nat.add_0_l, Nat.add_0_l.

          do 2 (rewrite nat_lb_fix_1; [ | omega ]).

          constructor; auto.

        * rewrite G1, G2, G3, G4, Nat.add_0_l, nat_lb_fix_2.

          rewrite nat_lb_fix_1; [ | omega ].

          constructor; auto.

        * rewrite G1, G2, G3, G4.

          do 2 rewrite nat_lb_fix_2.

          constructor; auto.

  Qed.



  Hint Resolve lb_mask_binary_le binary_le_lb_mask.



  Section lb_mask_nat.



    Let lb_mask_nat_1 l : ⟬ ⟦l⟧⟭  ⪯  l.

    Proof.

      induction l as [ | [|] l IHl ].

      + rewrite lb_nat_fix_0, nat_lb_fix_0; constructor.

      + rewrite lb_nat_fix_2, nat_lb_fix_2; constructor; auto.

      + rewrite lb_nat_fix_1.

        destruct (eq_nat_dec ⟦l⟧ 0) as [ Hl | Hl ]. 

        - rewrite Hl; simpl; rewrite nat_lb_fix_0; constructor.

        - rewrite nat_lb_fix_1; auto; constructor; auto.

    Qed.



    Let lb_mask_nat_2 l : l ⪯  ⟬ ⟦l⟧⟭  .

    Proof.

      induction l as [ | [|] l IHl ].

      + constructor.

      + rewrite lb_nat_fix_2, nat_lb_fix_2; constructor; auto.

      + rewrite lb_nat_fix_1.

        destruct (eq_nat_dec ⟦l⟧ 0) as [ Hl | Hl ]. 

        - rewrite Hl; simpl; rewrite nat_lb_fix_0; constructor.

          rewrite Hl, nat_lb_fix_0 in IHl; auto.

        - rewrite nat_lb_fix_1; auto; constructor; auto.

    Qed.



    Fact lb_mask_nat l : ⟬ ⟦l⟧⟭ ≂ l.

    Proof. split; auto. Qed.



  End lb_mask_nat.



  Definition nat_lb_nat := lb_mask_nat.



  Lemma lb_mask_eq_binary_le l m : l ⪯ m <-> ⟦l⟧ ≲ ⟦m⟧.

  Proof.

    split; auto; intro.

    rewrite <- (lb_mask_nat l), <- (lb_mask_nat m); auto.

  Qed.



  Lemma binary_le_eq_lb_mask x y : x ≲ y <-> ⟬ x⟭  ⪯ ⟬ y⟭ .

  Proof.

    split; auto.

    intro; rewrite <- (lb_nat_lb x), <- (lb_nat_lb y); auto.

  Qed.



  Hint Resolve lb_mask_eq_binary_le binary_le_eq_lb_mask.



  Fact binary_le_trans x y z : x ≲ y -> y ≲ z -> x ≲ z.

  Proof.

    do 3 rewrite binary_le_eq_lb_mask; apply lb_mask_trans.

  Qed.



  Fact lb_mask_equiv_equal l m : l ≂ m <-> ⟦l⟧ = ⟦m⟧.

  Proof.

    unfold lb_mask_equiv.

    do 2 rewrite lb_mask_eq_binary_le; split.

    + intros (? & ?); apply le_antisym; apply binary_le_le; auto.

    + intros H; rewrite H; split; auto. 

  Qed.



  Fact equal_lb_mask_equiv x y : x = y <-> ⟬ x⟭ ≂⟬ y⟭.

  Proof.

    rewrite lb_mask_equiv_equal, lb_nat_lb, lb_nat_lb; tauto.

  Qed.



  Local Notation lbeq := lb_mask_equiv (only parsing).



  Add Parametric Morphism: (lb_nat) with signature (lbeq) ==> (eq) as lb_nat_eq.

  Proof. apply lb_mask_equiv_equal. Qed.



  Definition bool_add_with_rem a b c : bool * bool :=

    match a, b, c with 

     | ⟘, ⟘, ⟘ => (⟘,⟘)

     | ⟘, ⟘, ⟙ => (⟘,⟙)

     | ⟘, ⟙, ⟘ => (⟘,⟙)

     | ⟘, ⟙, ⟙ => (⟙,⟘)

     | ⟙, ⟘, ⟘ => (⟘,⟙)

     | ⟙, ⟘, ⟙ => (⟙,⟘)

     | ⟙, ⟙, ⟘ => (⟙,⟘)

     | ⟙, ⟙, ⟙ => (⟙,⟙)

    end.



  Notation bin_add := bool_add_with_rem.

  

  Fact bin_add_eq_00x x : bin_add ⟘ ⟘  x = (⟘,x).

  Proof. destruct x; auto. Qed.



  Fact bin_add_eq_0x0 x : bin_add ⟘ x ⟘  = (⟘,x).

  Proof. destruct x; auto. Qed.



  Fixpoint lb_succ a l :=

    match l with

      | nil  => a::nil

      | x::l => let (r,z) := bin_add ⟘ a x in z::lb_succ r l

    end.



  Fact lb_succ_spec_0 l : ⟦lb_succ ⟘ l⟧ = ⟦l⟧.

  Proof.

    induction l as [ | [] ]; simpl; auto.

  Qed.



  Fact lb_succ_spec_1 l : ⟦lb_succ ⟙ l⟧ = S ⟦l⟧.

  Proof.

    induction l as [ | [] ]; auto.

    + simpl lb_succ; rewrite lb_nat_fix_2.

      rewrite lb_nat_fix_1, IHl; omega.

    + simpl lb_succ; rewrite lb_nat_fix_2.

      rewrite lb_nat_fix_1, lb_succ_spec_0; omega.

  Qed.



  Fact lb_succ_spec a l : ⟦lb_succ a l⟧ = bool2nat a + ⟦l⟧.

  Proof.

    destruct a.

    + rewrite lb_succ_spec_1; auto.

    + rewrite lb_succ_spec_0; auto.

  Qed.



  Fact lb_succ_bot l : lb_succ ⟘ l ≂ l.

  Proof.

    induction l as [ | x ]; simpl; auto.

    + split; repeat constructor.

    + destruct x; rewrite IHl; auto.

  Qed.



  Fixpoint lb_plus a l m :=

    match l, m with

      | nil,   m   => lb_succ a m

      | l,    nil  => lb_succ a l

      | x::l, y::m => let (r,z) := bin_add a x y in z::lb_plus r l m

    end.



  Fact lb_plus_fix_0 a l : lb_plus a nil l = lb_succ a l.

  Proof. auto. Qed.



  Fact lb_plus_fix_1 a l : lb_plus a l nil = lb_succ a l.

  Proof. destruct l; auto. Qed.



  Fact lb_plus_fix_2 a x y l m : lb_plus a (x::l) (y::m) = let (r,z) := bin_add a x y in z::lb_plus r l m.

  Proof. auto. Qed.



  Fact lb_plus_spec a l m : ⟦lb_plus a l m⟧ = bool2nat a + ⟦l⟧ + ⟦m⟧.

  Proof.

    revert a m; induction l as [ | x l IHl ]; intros a m.

    + rewrite lb_plus_fix_0, lb_succ_spec, lb_nat_fix_0; omega.

    + destruct m as [ | y m ].

      * rewrite lb_plus_fix_1, lb_succ_spec, lb_nat_fix_0; omega.

      * rewrite lb_plus_fix_2, lb_nat_fix_3, lb_nat_fix_3.

        destruct a; destruct x; destruct y; simpl; rewrite IHl; simpl; omega.

  Qed.



  Local Infix "⊕" := (lb_plus ⟘ ) (at level 41, left associativity). 



  Fact lb_plus_spec_0 l m : ⟦l⊕m⟧ = ⟦l⟧ + ⟦m⟧.

  Proof. rewrite lb_plus_spec; simpl; auto. Qed.



  Add Parametric Morphism a: (lb_plus a) with signature (lbeq) ==> (lbeq) ==> (lbeq) as lb_plus_eq.

  Proof.

    intros x1 y1 E1 x2 y2 E2; revert E1 E2.

    do 3 rewrite lb_mask_equiv_equal.

    do 2 rewrite lb_plus_spec.

    intros; f_equal; auto.

  Qed.



  Fact lb_ortho_plus l m : l ⟂ m <-> l ⪯ l⊕m.

  Proof.

    split.

    + induction 1 as [ l | l | x y l m [ H1 | H1 ] H2 IH2 ].

      * constructor. 

      * rewrite lb_plus_fix_1.

        rewrite lb_mask_eq_binary_le, lb_succ_spec; simpl.

        rewrite <- lb_mask_eq_binary_le; apply lb_mask_refl.

      * rewrite lb_plus_fix_2.

        subst x; rewrite bin_add_eq_00x.

        destruct y; constructor; auto.

      * rewrite lb_plus_fix_2.

        subst y; rewrite bin_add_eq_0x0.

        destruct x; constructor; auto.

    + revert m; induction l as [ | x l IHl ].

      * intros; constructor.

      * intros [ | y m ] H.

        - constructor.

        - rewrite lb_plus_fix_2 in H.

          destruct x; destruct y; simpl in H; try (apply lb_mask_inv_cons_cons in H; tauto);

            apply lb_mask_inv_cons, proj2 in H; constructor; auto.

  Qed.



  Fact lb_ortho_plus_join x y : x ⟂ y -> x⊕y ≂ x↑y.

  Proof.

    induction 1 as [ m | l | x y l m H1 H2 IH2 ].

    + rewrite lb_plus_fix_0, lb_join_right; apply lb_succ_bot.

    + rewrite lb_plus_fix_1, lb_join_left; apply lb_succ_bot.

    + rewrite lb_join_cons.

      apply lb_mask_equiv_equal.

      rewrite lb_plus_spec_0.

      do 3 rewrite lb_nat_fix_3.

      rewrite lb_mask_equiv_equal in IH2.

      rewrite <- IH2.

      rewrite lb_plus_spec_0.

      destruct x; destruct y; simpl; try ring.

      destruct H1; discriminate.

  Qed.



  Fact lb_ortho_plus_id a x y : a ⟂ x -> a ⟂ y -> x ⟂ y <-> (a⊕x)↓(a⊕y) ≂ a.

  Proof.

    intros H1 H2. 

    do 2 (rewrite lb_ortho_plus_join; auto). 

    rewrite <- lb_join_meet_distr, lb_ortho_meet_nil.

    split.

    + intros H3; rewrite H3, lb_join_left; auto.

    + intros H3; apply lb_ortho_mask_nil with a.

      * revert H1; apply lb_ortho_anti; auto.

      * rewrite <- H3, lb_join_comm; auto.

  Qed.



  Fact lb_minus_plus a b : a ⪯ b -> exists x, b ≂ a⊕x /\ a ⪯  a⊕x.

  Proof.

    intros H.

    destruct lb_minus with (1 := H) as (x & H1 & H2).

    exists x; rewrite lb_ortho_plus_join; auto.

  Qed.



  Theorem lb_meet_dio a b c : a ≂ b↓c <-> exists x y, b ≂ a⊕x /\ c ≂ a⊕y /\ a ⪯  a⊕x /\ a ⪯  a⊕y /\ x ⪯  x⊕y.

  Proof.

    split.

    + intros H.

      destruct (@lb_minus_plus a b) as (x & H1 & H2).

      { rewrite H; auto. }

      destruct (@lb_minus_plus a c) as (y & H3 & H4).

      { rewrite H; auto. }

      exists x, y; repeat (split; auto).

      rewrite <- lb_ortho_plus in H2, H4 |- *.

      rewrite lb_ortho_plus_join in H1, H3; auto.

      apply lb_ortho_meet_nil. 

      apply lb_ortho_mask_nil with (a := a).

      - revert H4; apply lb_ortho_anti; auto.

      - rewrite H, H1, H3.

        apply lb_meet_mono; auto.

    + intros (x & y & H1 & H2 & H3 & H4 & H5).

      rewrite <- lb_ortho_plus in H3, H4, H5.

      rewrite H1, H2.

      do 2 (rewrite lb_ortho_plus_join; auto).

      rewrite <- lb_join_meet_distr. 

      rewrite lb_ortho_meet_nil in H5.

      rewrite H5; rew lb.

  Qed.



  Fact lb_join_dio a b c : a ≂ b↑c <-> exists x, a ≂ b⊕x /\ b ⪯  b⊕x /\ x ⪯ c /\ c ⪯ a.

  Proof.

    split. 

    + intros H. 

      destruct (@lb_minus_plus b a) as (x & H1 & H2).

      { rewrite H; auto. }

      exists x; repeat (split; auto).

      2: rewrite H; auto.

      rewrite <- lb_ortho_plus in H2.

      rewrite  lb_ortho_plus_join in H1; auto.

      rewrite lb_ortho_meet_nil in H2.

      rewrite <- (lb_meet_join_idem x b), lb_join_comm.

      rewrite <- H1, H, lb_meet_join_distr, (lb_meet_comm _ b), H2.

      rew lb.

    + intros (x & H1 & H2 & H3 & H4).

      rewrite <- lb_ortho_plus in H2.

      rewrite lb_ortho_plus_join in H1; auto.

      rewrite lb_ortho_meet_nil in H2.

      split.

      * rewrite H1; apply lb_join_mono; auto.

      * apply lb_join_spec; auto; rewrite H1; auto.

  Qed.



  Fixpoint lb_bots n :=

    match n with 

      | 0   => nil

      | S n => ⟘ :: lb_bots n

    end.

      

  Definition lb_shift n l := lb_bots n ++ l.



  Fact lb_shift_0 l : lb_shift 0 l = l.

  Proof. auto. Qed.



  Fact lb_shift_S n l : lb_shift (S n) l = ⟘ :: lb_shift n l.

  Proof. auto. Qed.



  Fact lb_nat_shift n l : ⟦lb_shift n l⟧ = ⟦l⟧*power n 2.

  Proof.

    unfold lb_shift.

    induction n as [ | n IHn ]; simpl lb_bots.

    + rewrite power_0; simpl; ring.

    + simpl app; rewrite lb_nat_fix_1, IHn, power_S; ring.

  Qed.



  Fact lb_shift_meet n l m : lb_shift n (l↓m) = (lb_shift n l)↓(lb_shift n m).

  Proof.

    induction n as [ | n IHn ].

    + repeat rewrite lb_shift_0; auto.

    + do 3 rewrite lb_shift_S.

      rewrite lb_meet_cons; f_equal; auto.

  Qed.



  Fact lb_shift_join n l m : lb_shift n (l↑m) = (lb_shift n l)↑(lb_shift n m).

  Proof.

    induction n as [ | n IHn ].

    + repeat rewrite lb_shift_0; auto.

    + do 3 rewrite lb_shift_S.

      rewrite lb_join_cons; f_equal; auto.

  Qed.



  Fact lb_shift_ortho n l m : length l <= n -> l ⟂ lb_shift n m.

  Proof.

    revert n.

    induction l as [ | x l IHl ]; intros [ | n ]; simpl; auto; try omega.

    intro; rewrite lb_shift_S; constructor; auto; apply IHl; omega.

  Qed.



  Fact lb_shift_ortho_meet n l m : length l <= n -> l ↓ lb_shift n m ≂ nil.

  Proof.

    intros; apply lb_ortho_meet_nil, lb_shift_ortho; auto.

  Qed.



  Fact nat_pow2_lb_shift n q : ⟬q*power n 2⟭ ≂ lb_shift n ⟬q⟭ .

  Proof.  

    apply lb_mask_equiv_equal.

    rewrite lb_nat_lb, lb_nat_shift, lb_nat_lb; auto.

  Qed.



  Fact nat_euclid_pow2_lb n r q : r < power n 2 -> ⟬r+q*power n 2⟭ ≂ ⟬r⟭ ↑lb_shift n ⟬q⟭ .

  Proof.

    intros H.

    apply lb_mask_equiv_equal.

    rewrite lb_nat_lb.

    rewrite <- lb_ortho_plus_join.

    2: apply lb_shift_ortho, nat_lb_length; auto.

    rewrite lb_plus_spec_0; f_equal.

    + rewrite lb_nat_lb; auto.

    + rewrite lb_nat_shift, lb_nat_lb; auto.

  Qed.



  Definition nat_meet n m := ⟦ ⟬n⟭↓⟬m⟭ ⟧.

  Local Infix "⇣" := nat_meet (at level 40, left associativity).



  Fact nat_meet_comm n m : n⇣m = m⇣n.

  Proof.

    apply lb_mask_equiv_equal.

    rewrite lb_meet_comm; auto.

  Qed.



  Fact nat_meet_left n m : n⇣m ≲ n.

  Proof.

    apply binary_le_eq_lb_mask.

    unfold nat_meet.

    rewrite lb_mask_nat; auto.

  Qed.



  Fact nat_meet_right n m : n⇣m ≲ m.

  Proof.

    apply binary_le_eq_lb_mask.

    unfold nat_meet.

    rewrite lb_mask_nat; auto.

  Qed.



  Hint Resolve nat_meet_left nat_meet_right.



  Fact binary_le_nat_meet n m : n ≲ m <-> n⇣m = n.

  Proof.

    rewrite equal_lb_mask_equiv.

    rewrite binary_le_eq_lb_mask.

    unfold nat_meet.

    rewrite nat_lb_nat.

    apply lb_mask_meet.

  Qed.

  

  Theorem nat_meet_dio a b c : a = b⇣c <-> exists x y,  b = a+x

                                                     /\ c = a+y

                                                     /\ a ≲ a+x

                                                     /\ a ≲ a+y

                                                     /\ x ≲ x+y.

  Proof.

    unfold nat_meet.

    rewrite equal_lb_mask_equiv, nat_lb_nat.

    rewrite lb_meet_dio.

    split; intros (x & y & H1 & H2 & H3 & H4 & H5).

    + exists ⟦x⟧, ⟦y⟧.

      revert H1 H2 H3 H4 H5.

      repeat rewrite lb_mask_equiv_equal.

      repeat rewrite lb_mask_eq_binary_le.

      repeat rewrite lb_plus_spec_0.

      repeat rewrite lb_nat_lb; auto.

    + exists ⟬ x⟭, ⟬ y⟭ .

      repeat rewrite lb_mask_equiv_equal.

      repeat rewrite lb_mask_eq_binary_le.

      rewrite H1, H2.

      repeat rewrite lb_plus_spec_0.

      repeat rewrite lb_nat_lb.

      auto.

  Qed.



  Lemma nat_meet_mult_power2 q x y : (x*power q 2) ⇣ (y*power q 2) 

                                    = (x⇣y)*power q 2.

  Proof.

    unfold nat_meet.

    rewrite <- lb_nat_shift, lb_shift_meet.

    apply lb_mask_equiv_equal.

    do 2 rewrite nat_pow2_lb_shift; auto.

  Qed.



  Lemma nat_meet_euclid_power_2 q r1 d1 r2 d2 : 

           r1 < power q 2 

        -> r2 < power q 2 

        -> (r1+d1*power q 2) ⇣ (r2+d2*power q 2) 

         = (r1⇣r2) + (d1⇣d2)*power q 2.

  Proof.

    unfold nat_meet.

    intros H1 H2.

    do 2 (rewrite nat_euclid_pow2_lb; auto).

    rewrite <- lb_nat_shift, <- lb_plus_spec_0.

    apply lb_mask_equiv_equal.

    rewrite lb_ortho_plus_join.

    2: apply lb_shift_ortho, lb_meet_length_le; apply nat_lb_length; auto.

    rewrite lb_shift_meet.

    rewrite lb_meet_join_distr.

    do 2 rewrite (lb_meet_comm (_↑_)).

    do 2 rewrite lb_meet_join_distr.

    rewrite lb_shift_ortho_meet; try (apply nat_lb_length; auto; fail).

    rew lb. 

    rewrite (lb_meet_comm (lb_shift _ _)).

    rewrite lb_shift_ortho_meet; try (apply nat_lb_length; auto; fail).

    rew lb.

    rewrite lb_meet_comm.

    rewrite (lb_meet_comm (lb_shift _ _)); auto.

  Qed.



  Lemma nat_meet_euclid_2 r1 d1 r2 d2 : 

           r1 < 2 

        -> r2 < 2 

        -> (r1+2*d1) ⇣ (r2+2*d2) 

         = (r1⇣r2) + 2*(d1⇣d2).

  Proof.

    intros H1 H2.

    do 3 rewrite (mult_comm 2).

    apply nat_meet_euclid_power_2 with (q := 1); auto.

  Qed.

  

  Fact nat_meet_0n n : 0⇣n = 0.

  Proof.

    apply equal_lb_mask_equiv.

    unfold nat_meet.

    rewrite nat_lb_fix_0; rew lb.

    apply nat_lb_nat.

  Qed.



  Fact nat_meet_n0 n : n⇣0 = 0.

  Proof. rewrite nat_meet_comm, nat_meet_0n; auto. Qed.



  Fact nat_meet_idem n : n⇣n = n.

  Proof. 

    apply equal_lb_mask_equiv.

    unfold nat_meet.

    rewrite nat_lb_nat, lb_meet_idem; auto.

  Qed.



  Hint Resolve nat_meet_0n nat_meet_n0 nat_meet_idem.



  Fact nat_meet_assoc n m k : n⇣(m⇣k) = n⇣m⇣k.

  Proof.

    apply equal_lb_mask_equiv; unfold nat_meet.

    repeat rewrite nat_lb_nat.

    rewrite lb_meet_assoc; auto.

  Qed.



  Section nat_meet_power2_neq.



    Let nat_meet_power2_lt x y : x < y -> (power x 2) ⇣ (power y 2) = 0. 

    Proof.

      intros H.

      replace (power x 2) with (power x 2 + 0*power y 2) by ring.

      replace (power y 2) with (0 + 1*power y 2) at 2 by ring.

      rewrite nat_meet_euclid_power_2.

      + rewrite nat_meet_n0, nat_meet_0n; ring.

      + apply power_smono_l; omega.

      + apply power_ge_1; omega.

    Qed.



    Fact nat_meet_power2_neq x y : x <> y -> (power x 2) ⇣ (power y 2) = 0. 

    Proof.

      intros H.

      destruct (lt_eq_lt_dec x y) as [[]|]; try omega.

      + apply nat_meet_power2_lt; auto.

      + rewrite nat_meet_comm; apply nat_meet_power2_lt; auto.

    Qed.



  End nat_meet_power2_neq.



  Fact nat_meet_12n n : 1⇣(2*n) = 0.

  Proof.

    replace 1 with (1+0*power 1 2) at 1 by auto.

    replace (2*n) with (0+n*power 1 2) by (rewrite power_1; ring).

    rewrite nat_meet_euclid_power_2; rewrite power_1; try omega.

    rewrite nat_meet_0n, nat_meet_n0; auto.

  Qed.



  Fact nat_meet_12 : 1⇣2 = 0.

  Proof. apply (nat_meet_12n 1). Qed.



  Fact power_2_minus_1 n : power (S n) 2 - 1 = 1 + 2*(power n 2 - 1).

  Proof.

    rewrite power_S.

    generalize (@power_ge_1 n 2); intros; omega.

  Qed.



  Fact power_2_minus_1_gt n x : x < power n 2 <-> x ≲ power n 2 - 1.

  Proof.

    split.

    2: { intro Hx.

         apply binary_le_le in Hx.

         generalize (@power_ge_1 n 2); intros; omega. }

    intros H1.

    assert (x <= power n 2 -1) as H by omega; clear H1. 

    rewrite binary_le_nat_meet.

    revert x H; induction n as [ | n IHn ]; intros x Hx.

    + rewrite power_0 in Hx; cutrewrite (x=0); auto; omega.

    + destruct (eq_nat_dec x 0) as [ H | H ].

      - rewrite H; auto.

      - destruct (euclid_2_div x) as (H1 & H2).

        rewrite H1, power_2_minus_1.

        rewrite nat_meet_euclid_2; try omega.

        rewrite IHn.

        * f_equal; destruct H2 as [ H2 | H2 ]; rewrite H2; auto.

        * rewrite power_2_minus_1 in Hx; omega.

  Qed.



  Definition nat_join n m := ⟦ ⟬n⟭↑⟬m⟭ ⟧.

  Local Infix "⇡" := nat_join (at level 50, left associativity).



  Fact nat_join_comm n m : n⇡m = m⇡n.

  Proof.

    apply lb_mask_equiv_equal.

    rewrite lb_join_comm; auto.

  Qed.



  Fact nat_join_left n m : n ≲ n⇡m.

  Proof.

    apply binary_le_eq_lb_mask.

    unfold nat_join.

    rewrite lb_mask_nat; auto.

  Qed.



  Fact nat_join_right n m : m ≲ n⇡m.

  Proof.

    apply binary_le_eq_lb_mask.

    unfold nat_join.

    rewrite lb_mask_nat; auto.

  Qed.



  Hint Resolve nat_join_left nat_join_right.



  Fact nat_join_0n n : 0⇡n = n.

  Proof.

    apply equal_lb_mask_equiv.

    unfold nat_join.

    rewrite nat_lb_fix_0; rew lb.

    apply nat_lb_nat.

  Qed.



  Fact nat_join_n0 n : n⇡0 = n.

  Proof. rewrite nat_join_comm, nat_join_0n; auto. Qed.



  Fact nat_join_idem n : n⇡n = n.

  Proof. 

    apply equal_lb_mask_equiv.

    unfold nat_join.

    rewrite nat_lb_nat, lb_join_idem; auto.

  Qed.



  Fact nat_join_mono a b u v : a ≲ b -> u ≲ v -> a⇡u ≲ b⇡v.

  Proof.

    do 3 rewrite binary_le_eq_lb_mask; unfold nat_join.

    do 2 rewrite nat_lb_nat.

    apply lb_join_mono.

  Qed.



  Fact nat_join_assoc n m k : n⇡(m⇡k) = n⇡m⇡k.

  Proof.

    apply equal_lb_mask_equiv; unfold nat_join.

    repeat rewrite nat_lb_nat.

    rewrite lb_join_assoc; auto.

  Qed.



  Fact nat_join_meet_distr_l n m k : n⇡(m⇣k) = (n⇡m)⇣(n⇡k).

  Proof.

    apply equal_lb_mask_equiv.

    unfold nat_join, nat_meet.

    repeat rewrite nat_lb_nat.

    rewrite lb_join_meet_distr; auto.

  Qed.



  Fact nat_meet_join_distr_l n m k : n⇣(m⇡k) = (n⇣m)⇡(n⇣k).

  Proof.

    apply equal_lb_mask_equiv.

    unfold nat_join, nat_meet.

    repeat rewrite nat_lb_nat.

    rewrite lb_meet_join_distr; auto.

  Qed.

  

  Hint Resolve nat_join_0n nat_join_n0 nat_join_assoc.



  Lemma nat_join_monoid : monoid_theory nat_join 0.

  Proof. split; auto. Qed.

 

  Hint Resolve nat_join_monoid nat_join_mono.



  Fact nat_meet_joins_distr_l m n f : m ⇣ msum nat_join 0 n f = msum nat_join 0 n (fun i => m ⇣ f i).

  Proof.

    revert m f; induction n as [ | n IHn ]; intros m f.

    + do 2 rewrite msum_0; auto.

    + do 2 rewrite msum_S.

      rewrite nat_meet_join_distr_l, IHn; auto.

  Qed.



  Fact nat_join_binary_le n m k : n⇡m ≲ k <-> n ≲ k /\ m ≲ k.

  Proof.

    split.

    + intros H; split; apply binary_le_trans with (2 := H); auto.

    + intros (H1 & H2). rewrite <- (nat_join_idem k); auto.

  Qed. 



  Fact nat_joins_binary_le_left n f m : msum nat_join 0 n f ≲ m <-> forall i, i < n -> f i ≲ m.

  Proof.

    revert f; induction n as [ | n IHn ]; intros f.

    + rewrite msum_0; split; auto; intros; omega.

    + rewrite msum_S, nat_join_binary_le, IHn.

      split.

      * intros [H1 H2] [] ?; auto; apply H2; omega.

      * intros H; split; intros; apply H; omega.

  Qed.



  Fact nat_joins_binary_le_right m n f : (exists i, i < n /\ m ≲ f i) -> m ≲ msum nat_join 0 n f.

  Proof.

    intros (i & H1 & H2).

    apply binary_le_trans with (1 := H2).

    clear m H2.

    revert f i H1; induction n as [ | n IHn ]; intros f [ | i ] Hi; try omega; rewrite msum_S; auto.

    apply binary_le_trans with (2 := nat_join_right _ _).

    apply (IHn (fun i => f (S i))); omega.

  Qed.



  Fact nat_joins_binary_le n m f g :

           (forall i, i < n -> exists j, j < m /\ f i ≲ g j)

        -> msum nat_join 0 n f ≲ msum nat_join 0 m g.

  Proof.

    intros H.

    rewrite nat_joins_binary_le_left.

    intros i Hi; apply nat_joins_binary_le_right; auto.

  Qed.



  Fact nat_double_joins_binary_le n m f g : 

           (forall i j, j < i < n -> exists k, k < m /\ f i j ≲ g k)

        -> msum nat_join 0 n (fun i => msum nat_join 0 i (f i)) ≲ msum nat_join 0 m g.

  Proof.

    intros H.

    rewrite nat_joins_binary_le_left.

    intros; apply nat_joins_binary_le; auto.

  Qed.



  Fact binary_le_join_inv m a b : m ≲ a⇡b -> m = (m⇣a)⇡(m⇣b).

  Proof.

    rewrite binary_le_nat_meet, nat_meet_join_distr_l; auto.

  Qed.



  Fact binary_le_joins_inv m n f : m ≲ msum nat_join 0 n f

                              -> { k : nat & { g : nat -> nat & { h | m = msum nat_join 0 k g

                                                                   /\ k <= n 

                                                                   /\ (forall i, i < k -> g i <> 0 /\ g i ≲ f (h i))  

                                                                   /\ (forall i, i < k -> h i < n)

                                                                   /\ (forall i j, i < j < k -> h i < h j) } } }.

  Proof.

    revert m f; induction n as [ | n IHn ]; intros m f H.

    + rewrite msum_0 in H; apply binary_le_zero_inv in H.

      subst; exists 0, (fun _ => 0), (fun _ => 0); split.

      - rewrite msum_0; auto.

      - split; [ | split; [ | split ] ]; intros; omega.

    + rewrite msum_S in H.

      apply binary_le_join_inv in H.

      destruct (@IHn (m ⇣ msum nat_join 0 n (fun n => f (S n))) (fun n => f (S n)))

        as (k & g & h & H1 & H0 & H2 & H3 & H4); auto.

      rewrite H1 in H.

      case_eq (m ⇣ f 0).

      * intros E.

        rewrite E, nat_join_0n in H.

        exists k, g, (fun i => S (h i)); repeat (split; auto).

        - intros i Hi; specialize (H3 _ Hi); omega.

        - intros i j Hij; specialize (H4 _ _ Hij); omega.

      * intros u Hu.

        exists (S k), (fun i => match i with 0 => S u | S i => g i end),

                      (fun i => match i with 0 => 0   | S i => S (h i) end); split; [  | split; [ | split; [ | split ] ] ].

        - rewrite H, msum_S, <- Hu; auto.

        - omega.

        - intros [ | i ]; split; try omega. 

          ++ rewrite <- Hu; auto.

          ++ apply H2; omega.

          ++ apply H2; omega.

        - intros [ | i ] Hi; try omega.

          apply lt_S_n, H3 in Hi; omega.

        - intros [ | i ] [ | j ] (G1 & G2); simpl; try omega.

          apply lt_n_S, H4; omega.

  Qed.



  Fact binary_le_joins_inv' m n f : m ≲ msum nat_join 0 n f

                              -> { g | m = msum nat_join 0 n g /\ forall i, i < n -> g i ≲ f i }.  

  Proof.

    intros H; exists (fun i => m⇣f i); split.

    2: intros; auto.

    apply binary_le_nat_meet in H.

    rewrite <- H at 1.

    apply nat_meet_joins_distr_l.

  Qed.



  Lemma nat_join_mult_power2 q x y : (x*power q 2) ⇡ (y*power q 2) 

                                    = (x⇡y)*power q 2.

  Proof.

    unfold nat_join.

    rewrite <- lb_nat_shift, lb_shift_join.

    apply lb_mask_equiv_equal.

    do 2 rewrite nat_pow2_lb_shift; auto.

  Qed.



  Lemma binary_le_mult_power2_inv m x q : m ≲ x * power q 2 -> m <> 0 -> { y | m = y * power q 2 /\ y <> 0 /\ y ≲ x }.

  Proof.

    intros H1 H2.

    destruct (@euclid m (power q 2)) as (d & r & H3 & H4).

    + generalize (@power_ge_1 q 2); intros; omega.

    + apply binary_le_nat_meet in H1.

      rewrite plus_comm in H3.

      rewrite H3, <- (Nat.add_0_l (x*_)) in H1.

      rewrite nat_meet_euclid_power_2 in H1; auto.

      rewrite nat_meet_n0 in H1.

      rewrite (plus_comm r), (plus_comm 0) in H1.

      apply div_rem_uniq in H1; auto.

      2: generalize (@power_ge_1 q 2); intros; omega.

      destruct H1 as (H0 & H1).

      subst r; simpl in H3.

      exists d; split; auto.

      split.

      - contradict H2; subst; auto.

      - rewrite <- H0; auto.

  Qed.

 

  Lemma nat_join_euclid2 q r1 d1 r2 d2 : 

           r1 < power q 2 

        -> r2 < power q 2 

        -> (r1+d1*power q 2) ⇡ (r2+d2*power q 2) 

         = (r1⇡r2) + (d1⇡d2)*power q 2.

  Proof.

    unfold nat_join.

    intros H1 H2.

    do 2 (rewrite nat_euclid_pow2_lb; auto).

    rewrite <- lb_nat_shift, <- lb_plus_spec_0.

    apply lb_mask_equiv_equal.

    rewrite lb_ortho_plus_join.

    2: apply lb_shift_ortho, lb_join_length_le; apply nat_lb_length; auto.

    rewrite lb_shift_join.

    rewrite  lb_join_assoc, <- (lb_join_assoc ⟬ r1 ⟭).

    rewrite (lb_join_comm _ ⟬ r2 ⟭).

    repeat rewrite lb_join_assoc; auto.

  Qed.



  Fact nat_lb_plus n m : ⟬n+m⟭ ≂ ⟬n⟭⊕⟬m⟭.

  Proof.

    rewrite lb_mask_equiv_equal, lb_nat_lb, lb_plus_spec_0. 

    f_equal; symmetry; apply lb_nat_lb.

  Qed.



  Fact nat_ortho_plus_join n m : n⇣m = 0 -> n+m = n⇡m.

  Proof.

    do 2 rewrite equal_lb_mask_equiv.

    unfold nat_meet, nat_join.

    do 2 rewrite nat_lb_nat.

    rewrite nat_lb_plus, nat_lb_fix_0.

    rewrite <- lb_ortho_meet_nil.

    apply lb_ortho_plus_join.

  Qed.



  Local Notation sum_powers := (fun r n f e => ∑ n (fun i => f i * power (e i) r)).



  Fact sum_powers_bound r n f e :

                 r <> 0

              -> (forall i, i < n -> f i < r) 

              -> (forall i j, i < j -> e i < e j)

              -> sum_powers r n f e < power (e n) r.

  Proof.

    intros Hr; revert f e.

    induction n as [ | n IHn ]; intros f e Hf He.

    + rewrite msum_0; apply power_ge_1; auto.

    + rewrite msum_plus1; auto.

      apply lt_le_trans with (power (S (e n)) r).

      2: apply power_mono_l; try omega; apply He; auto.

      rewrite power_S.

      apply lt_le_trans with (1*power (e n) r + f n * power (e n) r).

      * rewrite Nat.mul_1_l; apply plus_lt_le_compat; auto.

      * rewrite <- Nat.mul_add_distr_r; apply mult_le_compat; auto.

        apply Hf; auto.

  Qed.



  Fact sum_powers_euclid r n f e : (forall j, j < n -> e 1 <= e (S j))

        -> sum_powers r (S n) f e = f 0 * power (e 0) r 

                                  + sum_powers r n (fun i => f (S i)) (fun i => e (S i) - e 1) * power (e 1) r.

  Proof.

    intros Hf; simpl; f_equal.

    rewrite <- sum_0n_scal_r.

    apply msum_ext.

    intros i Hi.

    rewrite <- mult_assoc; f_equal.

    rewrite <- power_plus; f_equal.

    generalize (Hf _ Hi); omega.

  Qed.



  Fact nat_meet_joins m n f : m⇣msum nat_join 0 n f = msum nat_join 0 n (fun i => m⇣f i).

  Proof.

    revert f; induction n as [ | n IHn ]; intros f.

    + rewrite msum_0, msum_0, nat_meet_n0; auto.

    + do 2 rewrite msum_S.

      rewrite nat_meet_join_distr_l, IHn; auto.

  Qed.



  Fact nat_join_eq_0 n m : n⇡m = 0 <-> n = 0 /\ m = 0.

  Proof.

    split.

    + do 3 rewrite equal_lb_mask_equiv. 

      unfold nat_join; rewrite nat_lb_nat.

      repeat rewrite nat_lb_fix_0.

      apply lb_join_nil_eq.

    + intros []; subst; apply nat_join_0n.

  Qed.



  Fact nat_ortho_joins_left m n f : m⇣msum nat_join 0 n f = 0 

                           <-> forall i, i < n -> m⇣f i = 0.

  Proof.

    rewrite nat_meet_joins.

    revert f; induction n as [ | n IHn ]; intros f.

    + rewrite msum_0; split; auto; intros; omega.

    + rewrite msum_S, nat_join_eq_0, IHn.

      split.

      * intros [ H1 H2 ] [ | i ] ?; auto; apply H2; omega.

      * intros H; split; intros; apply H; omega.

  Qed.



  Fact nat_ortho_sum_join n f : (forall i j, i <> j -> i < n -> j < n -> f i ⇣ f j = 0)

                             -> ∑ n f = msum nat_join 0 n f.

  Proof.

    revert f; induction n as [ | n IHn ]; intros f Hf.

    + do 2 rewrite msum_0; auto.

    + do 2 rewrite msum_S.

      rewrite IHn.

      apply nat_ortho_plus_join, nat_ortho_joins_left.

      * intros; apply Hf; omega.

      * intros; apply Hf; omega.

  Qed.



  Fact nat_ortho_joins m n f g : msum nat_join 0 m f ⇣ msum nat_join 0 n g = 0 

                             <-> forall i j, i < m -> j < n -> f i ⇣ g j = 0.

  Proof.

    rewrite nat_ortho_joins_left.

    split; intros H.

    + intros i j H1 H2; specialize (H _ H2).

      rewrite nat_meet_comm in H |- *.

      rewrite nat_ortho_joins_left in H; auto.

    + intros i Hi; rewrite nat_meet_comm, nat_ortho_joins_left.

      intros j Hj; rewrite nat_meet_comm; auto.

  Qed.



  Local Notation "⇧" := (fun r n f e => msum nat_join 0 n (fun i => f i * power (e i) r)).



  Section nat_meet_digits.



    Variable (q : nat) (Hq : 0 < q) (r : nat) (Hr : r = power q 2).

          

    Implicit Types (f g : nat -> nat).



    Let Hr' : 2 <= r.

    Proof. rewrite Hr; apply (@power_mono_l 1 _ 2); omega. Qed.



    Fact nat_meet_powers_eq i a b : (a*power i r)⇣(b*power i r) = (a⇣b)*power i r.

    Proof. rewrite Hr, <- power_mult, nat_meet_mult_power2; auto. Qed.



    Fact binary_power_split i a : { u : nat & { v | a = u⇡(v*power i r) /\ forall k, u⇣(k*power i r) = 0 } }.

    Proof.

      destruct (@euclid a (power i r)) as (u & v & H1 & H2).

      + generalize (@power_ge_1 i r); intros; omega.

      + exists v, u.

        assert (forall k, v ⇣ (k*power i r) = 0) as E.

        { intros k; replace v with (v+0*power i r) by ring.

          replace (k*power i r) with (0+k*power i r) by ring.

          rewrite Hr, <- power_mult.

          rewrite nat_meet_euclid_power_2, nat_meet_0n, nat_meet_n0; auto.

          rewrite power_mult, <- Hr; auto. }

        split; auto.

        rewrite H1, plus_comm, nat_ortho_plus_join; auto.

    Qed.

        

    Fact binary_le_power_inv i a b : a ≲ b * power i r -> { a' | a = a' * power i r /\ a' ≲ b }.

    Proof.

      intros H.

      destruct (binary_power_split i a) as (u & v & H1 & H2).

      exists (v⇣b).

      rewrite binary_le_nat_meet in H.

      rewrite H1 in H at 1.

      rewrite nat_meet_comm, nat_meet_join_distr_l in H.

      rewrite (nat_meet_comm _ u), H2, nat_join_0n, nat_meet_comm in H.

      rewrite Hr, <- power_mult,  nat_meet_mult_power2, power_mult, <- Hr in H.

      split; auto.

    Qed.

  

    Section nat_meet_powers_neq.



      Let nat_meet_neq_powers i j a b : i < j -> a < r -> b < r -> (a*power i r)⇣(b*power j r) = 0.

      Proof.

        intros H1 Ha Hb.

        replace (a*power i r) with (a*power i r + 0*power j r) by ring.

        replace (b*power j r) with (0+b*power j r) by ring.

        rewrite Hr, <- power_mult, <- power_mult.

        rewrite  nat_meet_euclid_power_2.

        + rewrite nat_meet_n0, nat_meet_0n; ring.

        + do 2 rewrite power_mult; rewrite <- Hr.

          apply lt_le_trans with (power (S i) r).

          - rewrite power_S; apply mult_lt_compat_r; auto.

            apply power_ge_1; omega.

          - apply power_mono_l; omega.

        + rewrite power_mult, <- Hr.

          apply power_ge_1; omega.

      Qed.



      Fact nat_meet_powers_neq i j a b : i <> j -> a < r -> b < r -> (a*power i r)⇣(b*power j r) = 0.

      Proof.

        intros Hij Ha Hb.

        destruct (lt_eq_lt_dec i j) as [ [] | ]; try omega.

        + apply nat_meet_neq_powers; auto.

        + rewrite nat_meet_comm.

          apply nat_meet_neq_powers; auto.

      Qed.

 

    End nat_meet_powers_neq.



    Fact sum_powers_ortho n f e : 

                 (forall i, i < n -> f i < r) 

              -> (forall i j, i < n -> j < n -> e i = e j -> i = j)

              -> sum_powers r n f e = ⇧ r n f e.

    Proof.

      revert f e; induction n as [ | n IHn ]; intros f e H1 H2.

      + do 2 rewrite msum_0; auto.

      + rewrite msum_S.

        rewrite IHn.

        2: intros; apply H1; omega.

        2: intros i j Hi Hj E; apply H2 in E; omega.

        rewrite nat_ortho_plus_join.

        * rewrite msum_S; auto.

        * apply nat_ortho_joins_left.

          intros i Hi.

          apply nat_meet_powers_neq.

          - intros E; apply H2 in E; omega.

          - apply H1; omega.

          - apply H1; omega.

    Qed.



    Section double_sum_powers_ortho.

 

      Variable (n : nat) (f e : nat -> nat -> nat)

               (Hf : forall i j, j < i < n -> f i j < r)

               (He : forall i1 j1 i2 j2, j1 < i1 < n -> j2 < i2 < n -> e i1 j1 = e i2 j2 -> i1 = i2 /\ j1 = j2).



      Let dsmpo_1 i : i < n -> sum_powers r i (f i) (e i) = ⇧ r i (f i) (e i).

      Proof.

        intros Hi; apply sum_powers_ortho.

        + intros; apply Hf; omega.

        + intros ? ? ? ?; apply He; omega.

      Qed.



      Fact double_sum_powers_ortho : ∑ n (fun i => sum_powers r i (f i) (e i)) = msum nat_join 0 n (fun i => ⇧ r i (f i) (e i)).

      Proof.

        rewrite nat_ortho_sum_join.

        + apply msum_ext; intros; apply dsmpo_1; auto.

        + intros; do 2 (rewrite dsmpo_1; auto).

          apply nat_ortho_joins.

          intros; apply nat_meet_powers_neq; auto.

          intros E; apply He in E; omega.

      Qed.



    End double_sum_powers_ortho.



    Fact sinc_injective n f : (forall i j, i < j < n -> f i < f j) -> forall i j, i < n -> j < n -> f i = f j -> i = j.

    Proof.

      intros Hf i j Hi Hj E.

      destruct (lt_eq_lt_dec i j) as [ [] | ]; auto.

      + generalize (Hf i j); intros; omega.

      + generalize (Hf j i); intros; omega.

    Qed.



    Hint Resolve sinc_injective.



    Section binary_le_meet_sum_powers.



      Variable (n : nat) (f g e : nat -> nat)

               (Hf : forall i, i < n -> f i < r) 

               (Hg : forall i, i < n -> g i < r)

               (He : forall i j, i < j < n -> e i < e j).



      Fact meet_sum_powers : (sum_powers r n f e)⇣(sum_powers r n g e) 

                           = sum_powers r n (fun i => f i ⇣ g i) e.

      Proof.

        generalize (sinc_injective _ He); intros H0.

        simpl; do 3 (rewrite sum_powers_ortho; auto).

        rewrite nat_meet_joins.

        + apply msum_ext.

          intros i Hi; rewrite nat_meet_comm.

          rewrite nat_meet_joins.

          rewrite msum_only_one with (i := i); auto.

          * rewrite nat_meet_comm, Hr, <- power_mult.

            apply nat_meet_mult_power2.

          * intros j G1 G2; apply nat_meet_powers_neq; auto.

        + intros i Hi.

          apply le_lt_trans with (2 := Hf Hi).

          apply binary_le_le; auto.

      Qed.



      Fact binary_le_sum_powers : sum_powers r n f e ≲ sum_powers r n g e <-> forall i, i < n -> f i ≲ g i.

      Proof.

        rewrite binary_le_nat_meet, meet_sum_powers.

        split. 

        + intros E i Hi.

          apply binary_le_nat_meet.

          apply power_decomp_unique with (5 := E); auto.

          intros j Hj; apply le_lt_trans with (2 := Hf Hj).

          apply binary_le_le; auto.

        + intros H; apply msum_ext.

          intros; f_equal; apply binary_le_nat_meet; auto.

      Qed.

          

    End binary_le_meet_sum_powers.



    Fact sum_power_binary_lt p n f a : 

            0 < p <= q

         -> (forall i j, i < j < n -> f i < f j)

         -> (forall i, i < n -> a i < power p 2)  -> ∑ n (fun i => a i * power (f i) r) 

                                                   ≲ (power p 2-1) * ∑ n (fun i => power (f i) r).

    Proof.

      intros H1 H2 H3.

      generalize (sinc_injective _ H2); intros H4.

      rewrite <- sum_0n_scal_l.

      apply binary_le_nat_meet.

      rewrite meet_sum_powers; auto.

      2: intros i Hi; rewrite Hr; apply lt_le_trans with (1 := H3 _ Hi), power_mono_l; omega. 

      2: { rewrite Hr.

           intros i Hi. 

           generalize (@power_ge_1 p 2); intro.

           unfold lt.

           cutrewrite (S (power p 2 -1) = power p 2); try omega. 

           apply power_mono_l; omega. }

      apply msum_ext; intros i Hi; f_equal.

      apply binary_le_nat_meet, power_2_minus_1_gt.

      assert (a i < power p 2); try omega.

      apply lt_le_trans with (1 := H3 _ Hi), power_mono_l; omega.

    Qed.



    Fact sum_powers_binary_le_inv n f e m :

                 (forall i, i < n -> f i < r) 

              -> (forall i j, i < j < n -> e i < e j)

              -> m ≲ sum_powers r n f e

              -> { k : nat &

                 { g : nat -> nat & 

                 { h |  m = sum_powers r k g (fun i => e (h i)) 

                     /\ k <= n

                     /\ (forall i, i < k -> g i <> 0 /\ g i ≲ f (h i))

                     /\ (forall i, i < k -> h i < n)

                     /\ (forall i j, i < j < k -> h i < h j) } } }.

    Proof.

      intros H1 H2 H3.

      generalize (sinc_injective _ H2); intros H0.

      simpl in H3; rewrite sum_powers_ortho in H3; auto.

      apply binary_le_joins_inv in H3.

      destruct H3 as (k & g & h & H4 & H10 & H5 & H6 & H7).

      generalize (sinc_injective _ H7); intros H8.

      assert (forall i, { a | i < k -> g i = a * power (e (h i)) r /\ a <> 0 /\ a ≲ f (h i) }) as H.

      { intros i.

        destruct (le_lt_dec k i) as [ H | H ].

        * exists 0; intros; omega.

        * destruct (H5 _ H) as (G1 & G2).

          rewrite Hr, <- power_mult in G2.

          apply binary_le_mult_power2_inv in G2; auto.

          destruct G2 as (a & G2 & G3 & G4).

          rewrite power_mult, <- Hr in G2.

          exists a; auto. }

      set (g' := fun i => proj1_sig (H i)).

      assert (Hg' : forall i, i < k -> g i = g' i * power (e (h i)) r /\ g' i <> 0 /\ g' i ≲ f (h i)).

      { intro i; apply (proj2_sig (H i)). }

      generalize g' Hg'; clear H g' Hg'; intros g' Hg'.



      exists k, g', h; split; [ | split; [ | split ] ]; auto.

      - rewrite sum_powers_ortho, H4.

        * apply msum_ext. intros; apply Hg'; auto.

        * intros i Hi; apply le_lt_trans with (f (h i)).

          + apply binary_le_le, Hg'; auto.

          + apply H1, H6; auto.

        * intros ? ? ? ? E; apply H0 in E; auto.

      - intros; apply Hg'; auto.

    Qed.



    Fact binary_le_sum_powers_inv n f e m :

                 (forall i, i < n -> f i < r) 

              -> (forall i j, i < j < n -> e i < e j)

              -> m ≲ sum_powers r n f e

              -> { g | m = sum_powers r n g e /\ forall i, i < n -> g i ≲ f i }.

    Proof.

      intros H1 H2 H3.

      generalize (sinc_injective _ H2); intros H0.

      simpl in H3; rewrite sum_powers_ortho in H3; auto.

      apply binary_le_joins_inv' in H3.

      destruct H3 as (g & H3 & H4).

      assert (forall i, i < n -> { h | g i = h * power (e i) r /\ h ≲ f i }) as h_full.

      { intros i Hi; apply binary_le_power_inv; auto. }

      set (h := fun i => match le_lt_dec n i with left _ => 0 | right H => proj1_sig (h_full _ H) end).

      assert (Hh : forall i, i < n ->  g i = h i * power (e i) r /\ h i ≲ f i).

      { intros i Hi; unfold h; destruct (le_lt_dec n i) as [ | H' ]; try omega.

        apply (proj2_sig (h_full _ H')). }

      generalize h Hh; clear h_full h Hh; intros h Hh.

      exists h; split; auto.

      + rewrite H3.

        rewrite sum_powers_ortho; auto.

        * apply msum_ext; intros; apply Hh; auto.

        * intros i Hi; apply le_lt_trans with (2 := H1 _ Hi), binary_le_le, Hh; auto.

      + intros; apply Hh; auto.

    Qed.



    Fact sum_power_binary_lt_inv p n f e m :

            0 < p <= q

         -> (forall i j, i < j < n -> f i < f j)

         -> (forall i j, i < j < n -> e i < e j)

         -> m ≲ (power p 2-1) * ∑ n (fun i => power (f i) r)

         -> exists a, m = ∑ n (fun i => a i * power (f i) r) 

                   /\ forall i, i < n -> a i < power p 2.

    Proof.

      intros H1 H2 H3 H4.

      rewrite <- sum_0n_scal_l in H4.

      apply binary_le_sum_powers_inv in H4; auto.

      + destruct H4 as (a & H5 & H6).

        exists a; split; auto.

        intros i Hi; apply power_2_minus_1_gt; auto.

      + intros i Hi.

        apply lt_le_trans with (power p 2).

        - generalize (@power_ge_1 p 2); intros; omega.

        - rewrite Hr; apply power_mono_l; omega.

    Qed.



  End nat_meet_digits.



