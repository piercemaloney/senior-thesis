
Require Import Arith Nat Omega List Bool.

Require Import utils_tac utils_list sums bounded_quantification.
(* utils_tac:
Require Import Arith List Wellfounded.

Set Implicit Arguments.

Definition eqdec X := forall x y : X, { x = y } + { x <> y }.

Definition swap {X Y} (c : X * Y) := let (x,y) := c in (y,x).

Theorem measure_rect X (m : X -> nat) (P : X -> Type) :
      (forall x, (forall y, m y < m x -> P y) -> P x) -> forall x, P x.

Tactic Notation "induction" "on" hyp(x) "as" ident(IH) "with" "measure" uconstr(f) :=
  pattern x; revert x; apply measure_rect with (m := fun x => f); intros x IH.

Tactic Notation "eq" "goal" hyp(H) := 
  match goal with 
    |- ?b => match type of H with ?t => replace b with t; auto end 
  end.

Ltac eqgoal := let H := fresh in intro H; eq goal H; clear H.

Tactic Notation "spec" "in" hyp(H) :=
  let Q := fresh 
  in match goal with G: ?h -> _ |- _ => 
       match G with 
         | H => assert (h) as Q; [ | specialize (H Q); clear Q ] 
       end 
     end.

Ltac solve_list_eq := simpl; repeat progress (try rewrite app_ass; try rewrite <- app_nil_end; simpl; auto); auto.

Tactic Notation "solve" "list" "eq" := solve_list_eq.

Tactic Notation "solve_list_eq" "in" hyp(H) := generalize H; clear H; solve_list_eq; intro H.

Tactic Notation "solve" "list" "eq" "in" hyp(H) := 
   let Q := fresh in 
   match goal with 
     |- ?t => set (Q := t); generalize H; clear H; solve_list_eq; intro H; unfold Q; clear Q
   end.

Ltac msplit n := 
  match n with 
    | 0    => idtac 
    | S ?n => split; [ | msplit n ]
   end.

Tactic Notation "define" ident(f) "of" hyp(n) hyp(m) "as" uconstr(t)  :=
  match type of n with ?N =>  
    match type of m with ?M  => pose (f (n:N) (m:M) := t) end end.

Tactic Notation "induction" "on" hyp(x) hyp(y) "as" ident(IH) "with" "measure" uconstr(f) :=
  generalize I; intro IH;
  let mes := fresh "measure" in let rel := fresh "relation" in let loop := fresh "loop" in
  let u := fresh "u" in let u' := fresh x in let Hu := fresh "Hu" in 
  let v := fresh "v" in let v' := fresh y in let Hv := fresh "Hv" 
  in clear IH; 
     define mes of x y as (f : nat);
     set (rel u v := mes (fst u) (snd u) < mes (fst v) (snd v)); unfold fst, snd in rel;
     pattern x, y; match goal with
       |- ?T _ _ => 
       refine ((fix loop u v (Hu : Acc rel (u,v)) { struct Hu } : T u v := _) x y _);
       [ assert (forall u' v', rel (u',v') (u,v) -> T u' v') as IH;
         [ intros u' v' Hv; apply (loop u' v'), (Acc_inv Hu), Hv 
         | unfold rel, mes in *; clear mes rel Hu loop x y; rename u into x; rename v into y ]
       | unfold rel; apply wf_inverse_image, lt_wf ]
     end.

Section forall_equiv.

  Variable (X : Type) (A P Q : X -> Prop) (HPQ : forall n, A n -> P n <-> Q n).

  Theorem forall_bound_equiv : (forall n, A n -> P n) <-> (forall n, A n -> Q n).

End forall_equiv.

Section exists_equiv.

  Variable (X : Type) (P Q : X -> Prop) (HPQ : forall n, P n <-> Q n).

  Theorem exists_equiv : (exists n, P n) <-> (exists n, Q n).

End exists_equiv. *)
(* utils_list:
Require Import List Arith Omega Permutation.

Require Import list_focus utils_tac.

Set Implicit Arguments.

Create HintDb length_db.

Tactic Notation "rew" "length" := autorewrite with length_db.
Tactic Notation "rew" "length" "in" hyp(H) := autorewrite with length_db in H.

Infix "~p" := (@Permutation _) (at level 70).

Section length.
   
  Variable X : Type.

  Implicit Type l : list X.

  Fact length_nil : length (@nil X) = 0.

  Fact length_cons x l : length (x::l) = S (length l).

End length.

Hint Rewrite length_nil length_cons app_length map_length rev_length : length_db.

Section list_an.

  Fixpoint list_an a n :=
    match n with 
      | 0   => nil
      | S n => a::list_an (S a) n
    end.

  Fact list_an_S a n : list_an a (S n) = a::list_an (S a) n.

  Fact list_an_plus a n m : list_an a (n+m) = list_an a n ++ list_an (n+a) m.

  Fact list_an_length a n : length (list_an a n) = n.
  
  Fact list_an_spec a n m : In m (list_an a n) <-> a <= m < a+n.

  Fact map_S_list_an a n : map S (list_an a n) = list_an (S a) n.

  Fact list_an_app_inv a n l r : list_an a n = l++r -> l = list_an a (length l) /\ r = list_an (a+length l) (length r).

End list_an.

Hint Rewrite list_an_length : length_db.

Definition list_fun_inv X (l : list X) (x : X) : { f : nat -> X | l = map f (list_an 0 (length l)) }.

Fact list_upper_bound (l : list nat) : { m | forall x, In x l -> x < m }.

Section list_injective.

  Variable X : Type.
   
  Definition list_injective (ll : list X) :=  forall l a m b r, ll = l ++ a :: m ++ b :: r -> a <> b.
  
  Fact in_list_injective_0 : list_injective nil.
  
  Fact in_list_injective_1 x ll : ~ In x ll -> list_injective ll -> list_injective (x::ll).
  
  Fact list_injective_inv x ll : list_injective (x::ll) -> ~ In x ll /\ list_injective ll.
  
  Variable P : list X -> Type.
  
  Hypothesis (HP0 : P nil).
  Hypothesis (HP1 : forall x l, ~ In x l -> P l -> P (x::l)).
  
  Theorem list_injective_rect l : list_injective l -> P l.

End list_injective.

Fact list_injective_map X Y (f : X -> Y) ll :
       (forall x y, f x = f y -> x = y) -> list_injective ll -> list_injective (map f ll).

Section iter.
  
  Variable (X : Type) (f : X -> X).

  Fixpoint iter x n :=
    match n with
      | 0   => x
      | S n => iter (f x) n
    end.

  Fact iter_plus x a b : iter x (a+b) = iter (iter x a) b.

  Fact iter_swap x n : iter (f x) n = f (iter x n).

End iter.

Fixpoint list_repeat X (x : X) n :=
  match n with
    | 0   => nil
    | S n => x::list_repeat x n
  end.
  
Fact list_repeat_plus X x a b : @list_repeat X x (a+b) = list_repeat x a ++ list_repeat x b.
  
Fact list_repeat_length X x n : length (@list_repeat X x n) = n.

Fact In_list_repeat X (x y : X) n : In y (list_repeat x n) -> x = y /\ 0 < n.

Fact map_list_repeat X Y f x n : @map X Y f (list_repeat x n) = list_repeat (f x) n.

Fact map_cst_repeat X Y (y : Y) ll : map (fun _ : X => y) ll = list_repeat y (length ll).
  
Fact map_cst_snoc X Y (y : Y) ll mm : y :: map (fun _ : X => y) ll++mm = map (fun _ => y) ll ++ y::mm.

Fact map_cst_rev  X Y (y : Y) ll : map (fun _ : X => y) (rev ll) = map (fun _ => y) ll.

Fact In_perm X (x : X) l : In x l -> exists m, x::m ~p l.

Fact list_app_eq_inv X (l1 l2 r1 r2 : list X) :
       l1++r1 = l2++r2 -> { m | l1++m = l2 /\ r1 = m++r2 } 
                        + { m | l2++m = l1 /\ r2 = m++r1 }.

Fact list_app_cons_eq_inv X (l1 l2 r1 r2 : list X) x :
       l1++r1 = l2++x::r2 -> { m | l1++m = l2 /\ r1 = m++x::r2 } 
                           + { m | l2++x::m = l1 /\ r2 = m++r1 }.

Fact list_cons_app_cons_eq_inv X (l2 r1 r2 : list X) x y :
       x::r1 = l2++y::r2 -> (l2 = nil /\ x = y /\ r1 = r2) 
                          + { m | l2 = x::m /\ r1 = m++y::r2 }.
 
Fact list_app_inj X (l1 l2 r1 r2 : list X) : length l1 = length l2 -> l1++r1 = l2++r2 -> l1 = l2 /\ r1 = r2.

Fact list_split_length X (ll : list X) k : k <= length ll -> { l : _ & { r | ll = l++r /\ length l = k } }.

Fact list_pick X (ll : list X) k : k < length ll -> { x : _ & { l : _ & { r | ll = l++x::r /\ length l = k } } }.

Fact list_split_middle X l1 (x1 : X) r1 l2 x2 r2 : 
       ~ In x1 l2 -> ~ In x2 l1 -> l1++x1::r1 = l2++x2::r2 -> l1 = l2 /\ x1 = x2 /\ r1 = r2.

Section flat_map.

  Variable (X Y : Type) (f : X -> list Y).

  Fact flat_map_app l1 l2 : flat_map f (l1++l2) = flat_map f l1 ++ flat_map f l2.

  Fact flat_map_app_inv l r1 y r2 : flat_map f l = r1++y::r2 -> exists l1 m1 x m2 l2, l = l1++x::l2 /\ f x = m1++y::m2 
                                                                  /\ r1 = flat_map f l1++m1 /\ r2 = m2++flat_map f l2. 

End flat_map.

Definition prefix X (l ll : list X) := exists r, ll = l++r.
  
Infix "<p" := (@prefix _) (at level 70, no associativity).
  
Section prefix. 
   
  Variable X : Type.
  
  Implicit Types (l ll : list X).
  
  Fact in_prefix_0 ll : nil <p ll.
  
  Fact in_prefix_1 x l ll : l <p ll -> x::l <p x::ll.

  Fact prefix_length l m : l <p m -> length l <= length m.
  
  Fact prefix_app_lft l r1 r2 : r1 <p r2 -> l++r1 <p l++r2.
  
  Fact prefix_inv x y l ll : x::l <p y::ll -> x = y /\ l <p ll.
  
  Fact prefix_list_inv l r rr : l++r <p l++rr -> r <p rr.

  Fact prefix_refl l : l <p l.

  Fact prefix_trans l1 l2 l3 : l1 <p l2 -> l2 <p l3 -> l1 <p l3.

  Section prefix_rect.

    Variables (P : list X -> list X -> Type)
              (HP0 : forall ll, P nil ll)
              (HP1 : forall x l ll, l <p ll -> P l ll -> P (x::l) (x::ll)).
              
    Definition prefix_rect l ll : prefix l ll -> P l ll.
   
  End prefix_rect.

  Fact prefix_app_inv l1 l2 r1 r2 : l1++l2 <p r1++r2 -> { l1 <p r1 } + { r1 <p l1 }.
  
End prefix.

Definition prefix_spec X (l ll : list X) : l <p ll -> { r | ll = l ++ r }.

Fact prefix_app_lft_inv X (l1 l2 m : list X) : l1++l2 <p m -> { m2 | m = l1++m2 /\ l2 <p m2 }.

Section list_assoc.

  Variables (X Y : Type) (eq_X_dec : eqdec X).

  Fixpoint list_assoc x l : option Y :=
    match l with 
      | nil  => None
      | (y,a)::l => if eq_X_dec x y then Some a else list_assoc x l
    end.

  Fact list_assoc_eq x y l x' : x = x' -> list_assoc x' ((x,y)::l) = Some y.

  Fact list_assoc_neq x y l x' : x <> x' -> list_assoc x' ((x,y)::l) = list_assoc x' l.

  Fact list_assoc_In x l : 
    match list_assoc x l with 
      | None   => ~ In x (map fst l)
      | Some y => In (x,y) l
    end.

  Fact In_list_assoc x l : In x (map fst l) -> { y | list_assoc x l = Some y /\ In (x,y) l }.
  
  Fact not_In_list_assoc x l : ~ In x (map fst l) -> list_assoc x l = None.

  Fact list_assoc_app x ll mm : list_assoc x (ll++mm) 
                              = match list_assoc x ll with
                                  | None   => list_assoc x mm
                                  | Some y => Some y
                                end.

End list_assoc.

Section list_first_dec.

  Variable (X : Type) (P : X -> Prop) (Pdec : forall x, { P x } + { ~ P x }).
  
  Theorem list_choose_dec ll : { l : _ & { x : _ & { r | ll = l++x::r /\ P x /\ forall y, In y l -> ~ P y } } }
                             + { forall x, In x ll -> ~ P x }.
  
  Theorem list_first_dec a ll : P a -> In a ll -> { l : _ & { x : _ & { r | ll = l++x::r /\ P x /\ forall y, In y l -> ~ P y } } }.
  
End list_first_dec.

Section map.

  Variable (X Y : Type) (f : X -> Y).
  
  Fact map_cons_inv ll y m : map f ll = y::m -> { x : _ & { l | ll = x::l /\ f x = y /\ map f l = m } }.

  Fact map_app_inv ll m n : map f ll = m++n -> { l : _  & { r | ll = l++r /\ m = map f l /\ n = map f r } }.
  
  Fact map_middle_inv ll m y n : map f ll = m++y::n -> { l : _ & { x : _ & { r | ll = l++x::r /\ map f l = m /\ f x = y /\ map f r = n } } }.
  
End map.

Fact Forall2_mono X Y (R S : X -> Y -> Prop) :
         (forall x y, R x y -> S x y) -> forall l m, Forall2 R l m -> Forall2 S l m.

Fact Forall2_nil_inv_l X Y R m : @Forall2 X Y R nil m -> m = nil.

Fact Forall2_nil_inv_r X Y R m : @Forall2 X Y R m nil -> m = nil.

Fact Forall2_cons_inv X Y R x l y m : @Forall2 X Y R (x::l) (y::m) <-> R x y /\ Forall2 R l m.

Fact Forall2_app_inv_l X Y R l1 l2 m : 
    @Forall2 X Y R (l1++l2) m -> { m1 : _ & { m2 | Forall2 R l1 m1 /\ Forall2 R l2 m2 /\ m = m1++m2 } }.

Fact Forall2_app_inv_r X Y R l m1 m2 : 
    @Forall2 X Y R l (m1++m2) -> { l1 : _ & { l2 | Forall2 R l1 m1 /\ Forall2 R l2 m2 /\ l = l1++l2 } }.

Fact Forall2_cons_inv_l X Y R a ll mm : 
      @Forall2 X Y R (a::ll) mm 
   -> { b : _ & { mm' | R a b /\ mm = b::mm' /\ Forall2 R ll mm' } }.

Fact Forall2_cons_inv_r X Y R b ll mm : 
      @Forall2 X Y R ll (b::mm) 
   -> { a : _ & { ll' | R a b /\ ll = a::ll' /\ Forall2 R ll' mm } }.

Fact Forall2_map_left X Y Z (R : Y -> X -> Prop) (f : Z -> Y) ll mm : Forall2 R (map f ll) mm <-> Forall2 (fun x y => R (f x) y) ll mm.

Fact Forall2_map_right X Y Z (R : Y -> X -> Prop) (f : Z -> X) mm ll : Forall2 R mm (map f ll) <-> Forall2 (fun y x => R y (f x)) mm ll.

Fact Forall2_map_both X Y X' Y' (R : X -> Y -> Prop) (f : X' -> X) (g : Y' -> Y) ll mm : Forall2 R (map f ll) (map g mm) <-> Forall2 (fun x y => R (f x) (g y)) ll mm.

Fact Forall2_Forall X (R : X -> X -> Prop) ll : Forall2 R ll ll <-> Forall (fun x => R x x) ll.

Fact Forall_app X (P : X -> Prop) ll mm : Forall P (ll++mm) <-> Forall P ll /\ Forall P mm.

Fact Forall_cons_inv X (P : X -> Prop) x ll : Forall P (x::ll) <-> P x /\ Forall P ll.

Fact Forall_rev X (P : X -> Prop) ll : Forall P ll -> Forall P (rev ll).

Fact Forall_map X Y (f : X -> Y) (P : Y -> Prop) ll : Forall P (map f ll) <-> Forall (fun x => P (f x)) ll.

Fact Forall_forall_map X (f : nat -> X) n l (P : X -> Prop) :
           l = map f (list_an 0 n) -> (forall i, i < n -> P (f i)) <-> Forall P l.

Fact Forall_impl X (P Q : X -> Prop) ll : (forall x, In x ll -> P x -> Q x) -> Forall P ll -> Forall Q ll.

Fact Forall_filter X (P : X -> Prop) (f : X -> bool) ll : Forall P ll -> Forall P (filter f ll). *)
(* sums:
Require Import List Arith Omega Eqdep_dec ZArith.

Require Import utils_tac utils_list binomial.

Set Implicit Arguments.

Record monoid_theory (X : Type) (m : X -> X -> X) (u : X) := mk_monoid {
  monoid_unit_l : forall x, m u x = x;
  monoid_unit_r : forall x, m x u = x;
  monoid_assoc  : forall x y z, m x (m y z) = m (m x y) z;
}.

Fact Nat_plus_monoid : monoid_theory plus 0.

Fact Nat_mult_monoid : monoid_theory mult 1.

Fact Zplus_monoid : monoid_theory Zplus 0%Z.

Fact Zmult_monoid : monoid_theory Zmult 1%Z.

Hint Resolve Nat_plus_monoid Nat_mult_monoid
             Zplus_monoid Zmult_monoid.

Section msum.

  Variable (X : Type) (m : X -> X -> X) (u : X).

  Infix "⊕" := m (at level 50, left associativity).

  Fixpoint msum n f := 
    match n with 
      | 0   => u
      | S n => f 0 ⊕ msum n (fun n => f (S n))
    end.

  Notation "∑" := msum.

  Fact msum_fold_map n f : ∑ n f = fold_right m u (map f (list_an 0 n)).

  Fact msum_0 f : ∑ 0 f = u.

  Fact msum_S n f : ∑ (S n) f = f 0 ⊕ ∑ n (fun n => f (S n)).

  Hypothesis Hmonoid : monoid_theory m u.

  Fact msum_1 f : ∑ 1 f = f 0.

  Fact msum_plus a b f : ∑ (a+b) f = ∑ a f ⊕ ∑ b (fun i => f (a+i)).

  Fact msum_plus1 n f : ∑ (S n) f = ∑ n f ⊕ f n.

  Fact msum_ext n f g : (forall i, i < n -> f i = g i) -> ∑ n f = ∑ n g.

  Fact msum_unit n : ∑ n (fun _ => u) = u.

  Fact msum_comm a n f : (forall i, i < n -> f i ⊕ a = a ⊕ f i) -> ∑ n f ⊕ a = a ⊕ ∑ n f.

  Fact msum_sum n f g : (forall i j, i < j < n -> f j ⊕ g i = g i ⊕ f j) -> ∑ n (fun i => f i ⊕ g i) = ∑ n f ⊕ ∑ n g.

  Fact msum_of_unit n f : (forall i, i < n -> f i = u) -> ∑ n f = u.

  Fact msum_only_one n f i : i < n
                          -> (forall j, j < n -> i <> j -> f j = u)
                          -> ∑ n f = f i.

  Fact msum_msum n k f :
          (forall i1 j1 i2 j2, i1 < n -> j1 < k -> i2 < n -> j2 < k -> f i1 j1 ⊕ f i2 j2 = f i2 j2 ⊕ f i1 j1)
       -> ∑ n (fun i => ∑ k (f i)) = ∑ k (fun j => ∑ n (fun i => f i j)).

  Fact msum_ends n f : (forall i, 0 < i <= n -> f i = u) -> ∑ (n+2) f = f 0 ⊕ f (S n).

  Fact msum_first_two n f : 2 <= n -> (forall i, 2 <= i -> f i = u) -> ∑ n f = f 0 ⊕ f 1.

  Definition mscal n x := msum n (fun _ => x).

  Fact mscal_0 x : mscal 0 x = u.

  Fact mscal_S n x : mscal (S n) x = x ⊕ mscal n x.

  Fact mscal_1 x : mscal 1 x = x.

  Fact mscal_of_unit n : mscal n u = u.

  Fact mscal_plus a b x : mscal (a+b) x = mscal a x ⊕ mscal b x.

  Fact mscal_plus1 n x : mscal (S n) x = mscal n x ⊕ x.

  Fact mscal_comm n x y : x ⊕ y = y ⊕ x -> mscal n x ⊕ y = y ⊕ mscal n x.

  Fact mscal_sum n x y : x ⊕ y = y ⊕ x -> mscal n (x ⊕ y) = mscal n x ⊕ mscal n y.

  Fact mscal_mult a b x : mscal (a*b) x = mscal a (mscal b x).

  Fact msum_mscal n k f : (forall i j, i < n -> j < n -> f i ⊕ f j = f j ⊕ f i) 
                       -> ∑ n (fun i => mscal k (f i)) = mscal k (∑ n f).

End msum.

Section msum_morphism.

  Variable (X Y : Type) (m1 : X -> X -> X) (u1 : X) 
                        (m2 : Y -> Y -> Y) (u2 : Y)
           (H1 : monoid_theory m1 u1)
           (H2 : monoid_theory m2 u2)
           (phi : X -> Y)
           (Hphi1 : phi u1 = u2)
           (Hphi2 : forall x y, phi (m1 x y) = m2 (phi x) (phi y)).

  Fact msum_morph n f : phi (msum m1 u1 n f) = msum m2 u2 n (fun x => phi (f x)).

  Fact mscal_morph n x : phi (mscal m1 u1 n x) = mscal m2 u2 n (phi x).

End msum_morphism.

Section binomial_Newton.

  Variable (X : Type) (sum times : X -> X -> X) (zero one : X).

  Infix "⊕" := sum (at level 50, left associativity).
  Infix "⊗" := times (at level 40, left associativity).
  
  Notation z := zero.
  Notation o := one.

  Notation scal := (mscal sum zero).
  Notation expo := (mscal times one).

  Hypothesis (M_sum : monoid_theory sum zero) 
             (sum_comm : forall x y, x ⊕ y = y ⊕ x)
             (sum_cancel : forall x u v, x ⊕ u = x ⊕ v -> u = v)
             (M_times : monoid_theory times one)
             (distr_l : forall x y z, x ⊗ (y⊕z) = x⊗y ⊕ x⊗z)
             (distr_r : forall x y z, (y⊕z) ⊗ x = y⊗x ⊕ z⊗x).

  Fact times_zero_l x : z ⊗ x = z.

  Fact times_zero_r x : x ⊗ z = z.

  Notation "∑" := (msum sum zero).

  Fact sum_0n_scal n k f : ∑ n (fun i => scal k (f i)) = scal k (∑ n f).

  Fact scal_times k x y : scal k (x⊗y) = x⊗scal k y.

  Fact scal_one_comm k x : scal k o ⊗ x = x ⊗ scal k o.

  Corollary scal_one k x : scal k x = scal k o ⊗ x.

  Fact sum_0n_distr_l b n f : ∑ n (fun i => b⊗f i) = b⊗∑ n f.

  Fact sum_0n_distr_r b n f : ∑ n (fun i => f i⊗b) = ∑ n f ⊗ b.

  Theorem binomial_Newton n a b :
        a ⊗ b = b ⊗ a
     -> expo n (a ⊕ b) = ∑ (S n) (fun i => scal (binomial n i) (expo (n - i) a ⊗ expo i b)).

End binomial_Newton.

Section Newton_nat.

  Notation power := (mscal mult 1).
  Notation "∑" := (msum plus 0).

  Fact sum_fold_map n f : ∑ n f = fold_right plus 0 (map f (list_an 0 n)).

  Fact power_0 x : power 0 x = 1.

  Fact power_S n x : power (S n) x = x * power n x.

  Fact power_1 x : power 1 x = x.

  Fact power_of_0 n : 0 < n -> power n 0 = 0.

  Fact power_of_1 n : power n 1 = 1.

  Fact power_plus p a b : power (a+b) p = power a p * power b p.

  Fact power_mult p a b : power (a*b) p = power a (power b p).
  
  Fact power_ge_1 k p : p <> 0 -> 1 <= power k p.

  Fact power2_gt_0 n : 0 < power n 2.

  Fact power_sinc k p : 2 <= p -> power k p < power (S k) p.

  Fact power_ge_n k p : 2 <= p -> k <= power k p.

  Fact power_mono_l p q x : 1 <= x -> p <= q -> power p x <= power q x.

  Definition power_mono := power_mono_l.
  
  Fact power_smono_l p q x : 2 <= x -> p < q -> power p x < power q x.

  Fact power_mono_r n p q : p <= q -> power n p <= power n q.

  Fact power_0_inv p n : power p n = 0 <-> n = 0 /\ 0 < p.

  Fact plus_cancel_l : forall a b c, a + b = a + c -> b = c.

  Let plus_cancel_l':= plus_cancel_l.

  Fact sum_0n_scal_l n k f : ∑ n (fun i => k*f i) = k*∑ n f.

  Fact sum_0n_scal_r n k f : ∑ n (fun i => (f i)*k) = (∑ n f)*k.

  Fact sum_0n_mono n f g : (forall i, i < n -> f i <= g i) -> ∑ n f <= ∑ n g.

  Fact sum_0n_le_one n f i : i < n -> f i <= ∑ n f.

  Fact sum_power_lt k n f : k <> 0 -> (forall i, i < n -> f i < k) -> ∑ n (fun i => f i * power i k) < power n k.

  Theorem Newton_nat a b n :
       power n (a + b) = ∑ (S n) (fun i => binomial n i * power (n - i) a * power i b).

  Theorem Newton_nat_S a n :
       power n (1 + a) = ∑ (S n) (fun i => binomial n i * power i a).

  Lemma binomial_le_power n i : binomial n i <= power n 2.

  Corollary binomial_lt_power n i : binomial n i < power (S n) 2.

End Newton_nat. *)
(* bounded_quantification:
Require Import Arith Omega.

Set Implicit Arguments.

Definition fmap_reifier_t X (Q : nat -> X -> Prop) k : 
             (forall i, i < k -> sig (Q i))
          -> { f : forall i, i < k -> X | forall i Hi, Q i (f i Hi) }.

Definition fmap_reifier_t_default X (Q : nat -> X -> Prop) k (x : X) : 
             (forall i, i < k -> sig (Q i))
          -> { f : nat -> X | forall i, i < k -> Q i (f i) }.

Theorem fmap_bound n P : 
           (forall x, x < n -> ex (P x)) 
        -> exists m, forall x, x < n -> exists y, y < m /\ P x y.

Theorem fmap_reifier_default X n (P : nat -> X -> Prop) : 
           inhabited X 
        -> (forall x, x < n -> ex (P x)) 
        -> exists f, forall x, x < n -> P x (f x).

Theorem fmap_reifer_bound n P : 
           (forall x, x < n -> ex (P x)) 
        -> exists m f, forall x, x < n -> f x < m /\ P x (f x).

Local Notation equal_upto := (fun m (f g : nat -> nat) => forall n, n < m -> f n = g n).

Theorem fmmap_bound p n (P : nat -> (nat -> nat) -> Prop) :
             (forall x f g, equal_upto p f g -> P x f -> P x g)       
          -> (forall x, x < n -> exists f, P x f) 
          -> exists m, forall x, x < n -> exists f, (forall i, i < p -> f i < m) /\ P x f.

Theorem fmmap_reifer_bound p n (P : nat -> (nat -> nat) -> Prop) :
             (forall x f g, equal_upto p f g -> P x f -> P x g)       
          -> (forall x, x < n -> exists f, P x f) 
          -> exists m f, forall x, x < n -> (forall j, j < p -> f x j < m) /\ P x (f x). *)
Require Import cipher.
(* cipher:
Require Import Arith Nat Omega List Bool Setoid.
Require Import utils_tac gcd sums rel_iter bool_nat power_decomp.

Set Implicit Arguments.

Local Notation power := (mscal mult 1).
Local Notation "∑" := (msum plus 0).
Local Infix "≲" := binary_le (at level 70, no associativity).
Local Infix "⇣" := nat_meet (at level 40, left associativity).
Local Infix "⇡" := nat_join (at level 50, left associativity).

Hint Resolve power2_gt_0.

Section stability_of_power.

  Fact mult_lt_power_2 u v k : u < power k 2 -> v < power k 2 -> u*v < power (2*k) 2.

  Fact mult_lt_power_2_4 u v k : u < power k 2 -> v < power k 2 -> u*v < power (4*k) 2.

  Fact mult_lt_power_2_4' u1 v1 u2 v2 k : 
               u1 < power k 2 
            -> v1 < power k 2
            -> u2 < power k 2
            -> v2 < power k 2
            -> u1*v1+v2*u2 < power (4*k) 2.

End stability_of_power.

Section power_decomp.

  Variable (p : nat) (Hp : 2 <= p).

  Let power_nzero x : power x p <> 0.

  Fact power_decomp_lt n f a q :  
           (forall i j, i < j < n -> f i < f j)
        -> (forall i, i < n -> f i < q)
        -> (forall i, i < n -> a i < p)
        -> ∑ n (fun i => a i * power (f i) p) < power q p.

  Lemma power_decomp_is_digit n a f : 
           (forall i j, i < j < n -> f i < f j)
        -> (forall i, i < n -> a i < p)
        ->  forall i, i < n -> is_digit (∑ n (fun i => a i * power (f i) p)) p (f i) (a i).

  Theorem power_decomp_unique n f a b :
            (forall i j, i < j < n -> f i < f j)
         -> (forall i, i < n -> a i < p)
         -> (forall i, i < n -> b i < p)
         -> ∑ n (fun i => a i * power (f i) p)
          = ∑ n (fun i => b i * power (f i) p)
         -> forall i, i < n -> a i = b i.

End power_decomp.

Section power_decomp_uniq.

  Variable (p : nat) (Hp : 2 <= p).

  Theorem power_decomp_factor n f a : 
           (forall i, 0 < i < S n -> f 0 < f i)
        -> ∑ (S n) (fun i => a i * power (f i) p) 
         = ∑ n (fun i => a (S i) * power (f (S i) - f 0 - 1) p) * power (S (f 0)) p
         + a 0 * power (f 0) p.

  Let power_nzero x : power x p <> 0.

  Let lt_minus_cancel a b c : a < b < c -> b - a - 1 < c - a - 1.

  Theorem power_decomp_unique' n f a b :
            (forall i j, i < j < n -> f i < f j)
         -> (forall i, i < n -> a i < p)
         -> (forall i, i < n -> b i < p)
         -> ∑ n (fun i => a i * power (f i) p)
          = ∑ n (fun i => b i * power (f i) p)
         -> forall i, i < n -> a i = b i.

End power_decomp_uniq.

Fact mult_2_eq_plus x : x + x = 2 *x.

Section power_injective.

  Let power_2_inj_1 i j n : j < i -> 2* power n 2 <> power i 2 + power j 2.

  Fact power_2_n_ij_neq i j n : i <> j -> power (S n) 2 <> power i 2 + power j 2.

  Fact power_2_inj i j : power i 2 = power j 2 -> i = j.

  Let power_plus_lt a b c : a < b < c -> power a 2 + power b 2 < power c 2.

  Let power_inj_2 i1 j1 i2 j2 : 
             j1 < i1 
          -> j2 < i2 
          -> power i1 2 + power j1 2 = power i2 2 + power j2 2
          -> i1 = i2 /\ j1 = j2.

  Theorem sum_2_power_2_injective i1 j1 i2 j2 :
              j1 <= i1 
           -> j2 <= i2 
           -> power i1 2 + power j1 2 = power i2 2 + power j2 2 
           -> i1 = i2 /\ j1 = j2.
 
End power_injective.

Fact divides_power p a b : a <= b -> divides (power a p) (power b p).

Fact divides_msum k n f : (forall i, i < n -> divides k (f i)) -> divides k (∑ n f).

Fact inc_seq_split_lt n f k : 
         (forall i j, i < j < n -> f i < f j) 
      -> { p | p <= n /\ (forall i, i < p -> f i < k) /\ forall i, p <= i < n -> k <= f i }.

Fact inc_seq_split_le n f h : (forall i j, i < j < n -> f i < f j) 
                   -> { q | q <= n 
                         /\ (forall i, i < q      -> f i <= h)
                         /\ (forall i, q <= i < n -> h < f i) }.

Fact divides_lt p q : q < p -> divides p q -> q = 0.

Fact sum_powers_inc_lt_last n f r : 
        2 <= r
     -> (forall i j, i < j <= n -> f i < f j)
     -> ∑ (S n) (fun i => power (f i) r) < power (S (f n)) r.

Fact sum_powers_inc_lt n f p r : 
        2 <= r
     -> (forall i, i < n -> f i < p)
     -> (forall i j, i < j < n -> f i < f j)
     -> ∑ n (fun i => power (f i) r) < power p r.

Fact sum_powers_injective r n f m g :
       2 <= r
    -> (forall i j, i < j < n -> f i < f j)
    -> (forall i j, i < j < m -> g i < g j)
    -> ∑ n (fun i => power (f i) r) = ∑ m (fun i => power (g i) r)
    -> n = m /\ forall i, i < n -> f i = g i.

Fact power_divides_sum_power r p n f :
         2 <= r 
      -> 0 < n
      -> (forall i j, i < j < n -> f i < f j) 
      -> divides (power p r) (∑ n (fun i => power (f i) r)) <-> p <= f 0.

Fact smono_upto_injective n f :
       (forall i j, i < j < n -> f i < f j)
    -> (forall i j, i < n -> j < n -> f i = f j -> i = j).

Fact product_sums n f g : (∑ n f)*(∑ n g) 
                         = ∑ n (fun i => f i*g i) 
                         + ∑ n (fun i => ∑ i (fun j => f i*g j + f j*g i)).

Section sums.

  Fact square_sum n f : (∑ n f)*(∑ n f) = ∑ n (fun i => f i*f i) + 2*∑ n (fun i => ∑ i (fun j => f i*f j)).

  Fact sum_regroup r k n f :
          (forall i, i < n -> f i < k) 
       -> (forall i j, i < j < n -> f i < f j)
       -> { g | ∑ n (fun i => power (f i) r) 
              = ∑ k (fun i => g i * power i r) 
             /\ (forall i, i < k  -> g i <= 1) 
             /\ (forall i, k <= i -> g i = 0) }.
 
  Section sum_sum_regroup.

    Variable (r n k : nat) (f : nat -> nat)
             (Hf1 : forall i, i < n -> f i <= k) 
             (Hf2 : forall i j, i < j < n -> f i < f j).

    Theorem sum_sum_regroup : { g | ∑ n (fun i => ∑ i (fun j => power (f i + f j) r))
                                  = ∑ (2*k) (fun i => g i * power i r) 
                                  /\ forall i, g i <= n }.

  End sum_sum_regroup.

  Section all_ones.

    Let equation_inj x y a b : 1 <= x -> 1+x*a = y -> 1+x*b = y -> a = b.

    Variables (r : nat) (Hr : 2 <= r).

    Fact all_ones_equation l : 1+(r-1)*∑ l (fun i => power i r) = power l r.

    Fact all_ones_dio l w : w = ∑ l (fun i => power i r) <-> 1+(r-1)*w = power l r.

  End all_ones.

  Section const_1.

    Variable (l q : nat) (Hl : 0 < l) (Hlq : l+1 < q).

    Let Hq : 1 <= q.     Proof. omega. Qed. 
    
    Let r := (power (4*q) 2).

    Let Hr' : 4 <= r.    Proof. apply (@power_mono_l 2 (4*q) 2); omega. Qed.

    Section all_ones.

      Variable (n w : nat) (Hw : w = ∑ n (fun i => power i r)).

      Let Hw_0 : w = ∑ n (fun i => 1*power i r).

      Fact all_ones_joins : w = msum nat_join 0 n (fun i => 1*power i r).

      Let Hw_1 : 2*w = ∑ n (fun i => 2*power i r).

      Fact all_ones_2_joins : 2*w = msum nat_join 0 n (fun i => 2*power i r).

    End all_ones.

    Section increase.
   
      Variable (m k k' u w : nat) (f : nat -> nat) 
               (Hm : 2*m < r) 
               (Hf1 : forall i, i < m -> f i <= k)
               (Hf2 : forall i j, i < j < m  -> f i < f j)
               (Hw : w = ∑ k' (fun i => power i r))
               (Hu : u = ∑ m (fun i => power (f i) r)).

      Let Hf4 : forall i j, i < m -> j < m -> f i = f j -> i = j.

      Let u1 := ∑ m (fun i => power (2*f i) r).
      Let u2 := ∑ m (fun i => ∑ i (fun j => 2*power (f i + f j) r)).

      Fact const_u_square : u * u = u1 + u2.

      Let Hu1_0 : u1 = ∑ m (fun i => 1*power (2*f i) r).

      Let Hseq_u a : a <= m -> ∑ a (fun i => 1*power (2*f i) r) = msum nat_join 0 a (fun i => 1*power (2*f i) r).

      Let Hu1 : u1 = msum nat_join 0 m (fun i => 1*power (2*f i) r).

      Let Hu2_0 : u2 = 2 * ∑ m (fun i => ∑ i (fun j => power (f i + f j) r)).

      Let g_full : { g | ∑ m (fun i => ∑ i (fun j => power (f i + f j) r))
                      = ∑ (2*k) (fun i : nat => g i * power i r) 
                      /\ forall i : nat, g i <= m }.
 
      Let g := proj1_sig g_full.
      Let Hg1 : u2 = ∑ (2*k) (fun i => (2*g i) * power i r).

      Let Hg2 i : 2*g i <= 2*m.

      Let Hg3 i : 2*g i < r.

      Let Hu2 : u2 = msum nat_join 0 (2*k) (fun i => (2*g i) * power i r).  
  
      Let Hu1_u2_1 : u1 ⇣ u2 = 0.

      Let Hu1_u2 : u*u = u1 ⇡ u2.
   
      Let Hw_1 : w = msum nat_join 0 k' (fun i => 1*power i r).

      Let H2w_1 : 2*w = msum nat_join 0 k' (fun i => 2*power i r).

      Let Hu2_w : u2 ⇣ w = 0.

      Fact const_u1_prefix : { q | q <= m /\ u*u ⇣ w = ∑ q (fun i => 1*power (2*f i) r) }.
         
      Hypothesis (Hk : 2*k < k').

      Let Hu1_w : u1 ⇣ w = u1.

      Let Hu1_2w : u1 ⇣ (2*w) = 0.

      Fact const_u1_meet p : p = (u*u) ⇣ w <-> p = u1.

      Fact const_u1_eq : (u*u) ⇣ w = u1.

      Hypothesis Hf : forall i, i < m -> f i = power (S i) 2.

      Let Hu2_1 : u2 = msum nat_join 0 m (fun i => msum nat_join 0 i (fun j => 2*power (f i + f j) r)).

      Let Hu2_2w : u2 ⇣ (2*w) = u2.

      Fact const_u2_meet p : p = (u*u) ⇣ (2*w) <-> p = u2.

    End increase.

    Let Hl'' : 2*l < r.

    Section const_1_cn.

      Variable (u u1 : nat) (Hu  : u = ∑ l (fun i => power (power (S i) 2) r))
                            (Hu1 : u1 = ∑ l (fun i => power (power (S (S i)) 2) r)).
 
      Let w  := ∑ (S (power (S l) 2)) (fun i => power i r).
 
      Let u2 := ∑ l (fun i => ∑ i (fun j => 2*power (power (S i) 2 + power (S j) 2) r)).
 
      Let H18 : 1+(r-1)*w = power (S (power (S l) 2)) r.

      Let H19 : u*u = u1 + u2.

      Let k := S (power (S l) 2).
      Let f i := power (S i) 2.

      Let Hf1 i : i < l -> 2*f i < k.

      Let Hf2 i j : i < j < l -> f i < f j.

      Let Hf3 i1 j1 i2 j2 : j1 <= i1 < l -> j2 <= i2 < l -> f i1 + f j1 = f i2 + f j2 -> i1 = i2 /\ j1 = j2.

      Let H20 : u1 = (u*u) ⇣ w.

      Let H21 : u2 = (u*u) ⇣ (2*w).
 
      Let H22 : power 2 r + u1 = u + power (power (S l) 2) r.
  
      Let H23 : divides (power 4 r) u1.

      Lemma const1_cn : exists w u2,    1+(r-1)*w = power (S (power (S l) 2)) r
                                     /\ u*u = u1 + u2
                                     /\ u1 = (u*u) ⇣ w
                                     /\ u2 = (u*u) ⇣ (2*w)
                                     /\ power 2 r + u1 = u + power (power (S l) 2) r
                                     /\ divides (power 4 r) u1.

    End const_1_cn.

    Section const_1_cs.

      Variable (w u u1 u2 : nat).

      Hypothesis (H18 : 1+(r-1)*w = power (S (power (S l) 2)) r)
                 (H19 : u*u = u1 + u2)
                 (H20 : u1 = (u*u) ⇣ w)
                 (H21 : u2 = (u*u) ⇣ (2*w))
                 (H22 : power 2 r + u1 = u + power (power (S l) 2) r)
                 (H23 : divides (power 4 r) u1).

      Let Hw_0 : w = ∑ (S (power (S l) 2)) (fun i => power i r).

      Let Hw_1 : w = ∑ (S (power (S l) 2)) (fun i => 1*power i r).

      Let Hw : w = msum nat_join 0 (S (power (S l) 2)) (fun i => 1*power i r).

      Let H2w : 2*w = msum nat_join 0 (S (power (S l) 2)) (fun i => 2*power i r).
    
      Let Hu1_0 : u1 ≲ ∑ (S (power (S l) 2)) (fun i => 1*power i r).

      Let mk_full : { m : nat & { k | u1 = ∑ (S m) (fun i => power (k i) r) 
                                /\ m <= power (S l) 2
                                /\ (forall i, i < S m -> k i <= power (S l) 2) 
                                /\ forall i j, i < j < S m -> k i < k j } }.

      Let m := projT1 mk_full.
      Let k := proj1_sig (projT2 mk_full).

      Let Hu1 : u1 = ∑ (S m) (fun i => power (k i) r).        Proof. apply (proj2_sig (projT2 mk_full)). Qed.
      Let Hk1 : forall i, i < S m -> k i <= power (S l) 2.    Proof. apply (proj2_sig (projT2 mk_full)). Qed.

      Let Hh_0 : 4 <= k 0.

      Let f1 i := match i with 0 => 2 | S i => k i end.
      Let f2 i := if le_lt_dec i m then power (S l) 2 else k i.

      Let Hf1_0 : forall i, i <= S m -> f1 i < S (power (S l) 2).

      Let Hf1_1 : forall i j, i < j <= S m -> f1 i < f1 j.

      Let Hf1_2 : ∑ (S (S m)) (fun i => power (f1 i) r) = u + power (power (S l) 2) r.

      Let Hh_1 : k m = power (S l) 2.
 
      Let Hu : u = ∑ (S m) (fun i => power (f1 i) r).
        
      Let Huu : u*u = ∑ (S m) (fun i => power (2*f1 i) r)
                    + ∑ (S m) (fun i => ∑ i (fun j => 2*power (f1 i + f1 j) r)).

      Let HSl_q : 2 * S (power (S l) 2) < power (2 * q) 2.
  
      Let Hu1_1 : { d | d <= S m /\ u1 = ∑ d (fun i => power (2*f1 i) r) }.

      Let Hk_final : k 0 = 4 /\ forall i, i < m -> k (S i) = 2*k i.

      Let Hk_is_power i : i <= m -> k i = power (S (S i)) 2.

      Let Hm_is_l : S m = l.
        
      Fact obtain_u_u1_value :  u  = ∑ l (fun i => power (power (S i) 2) r)
                             /\ u1 = ∑ l (fun i => power (power (S (S i)) 2) r).

    End const_1_cs.

  End const_1.

  Variable (l q : nat).

  Notation r := (power (4*q) 2).

  Definition seqs_of_ones u u1 :=
                   l+1 < q 
                /\ u  = ∑ l (fun i => power (power (S i) 2) r)
                /\ u1 = ∑ l (fun i => power (power (S (S i)) 2) r).

  Lemma seqs_of_ones_dio u u1 :
            seqs_of_ones u u1 
        <-> l = 0 /\ u = 0 /\ u1 = 0 /\ 2 <= q
         \/ 0 < l /\ l+1 < q
         /\ exists u2 w r0 r1 p1 p2,
                r0 = r 
             /\ r1+1 = r0
             /\ p1 = power (1+l) 2
             /\ p2 = power p1 r0
             /\ 1+r1*w = r0*p2
             /\ u*u = u1 + u2
             /\ u1 = (u*u) ⇣ w
             /\ u2 = (u*u) ⇣ (2*w)
             /\ r0*r0 + u1 = u + p2
             /\ divides (r0*r0*r0*r0) u1. 

  Definition is_cipher_of f a :=
                 l+1 < q
              /\ (forall i, i < l -> f i < power q 2)
              /\ a = ∑ l (fun i => f i * power (power (S i) 2) r).

  Fact is_cipher_of_0 f a : l = 0 -> is_cipher_of f a <-> 1 < q /\ a = 0.

  Fact is_cipher_of_inj f1 f2 a : is_cipher_of f1 a -> is_cipher_of f2 a -> forall i, i < l -> f1 i = f2 i.

  Fact is_cipher_of_fun f1 f2 a b : 
          (forall i, i < l -> f1 i = f2 i)
        -> is_cipher_of f1 a 
        -> is_cipher_of f2 b
        -> a = b.

  Lemma is_cipher_of_equiv f1 f2 a b : 
           is_cipher_of f1 a 
        -> is_cipher_of f2 b
        -> a = b <-> forall i, i < l -> f1 i = f2 i.

  Lemma is_cipher_of_const_1 u : 0 < l -> is_cipher_of (fun _ => 1) u
                                     <-> l+1 < q /\ exists u1, seqs_of_ones u u1.

  Fact is_cipher_of_u : l+1 < q -> is_cipher_of (fun _ => 1) (∑ l (fun i => power (power (S i) 2) r)).
   Definition the_cipher f : l+1 < q -> (forall i, i < l -> f i < power q 2) -> { c | is_cipher_of f c }.

  Definition Code a := exists f, is_cipher_of f a.

  Lemma Code_dio a : Code a <-> l = 0 /\ 1 < q /\ a = 0
                             \/ 0 < l /\ l+1 < q /\ exists p u u1, p+1 = power q 2 /\ seqs_of_ones u u1 /\ a ≲ p*u.

  Definition Const c v := exists f, is_cipher_of f v /\ forall i, i < l -> f i = c.

  Lemma Const_dio c v : Const c v <-> l = 0 /\ 1 < q /\ v = 0
                                   \/ 0 < l /\ l+1 < q /\
                                      exists p u u1, p = power q 2 /\ c < p /\ seqs_of_ones u u1 /\ v = c*u.

  Let Hr : 1 < q -> 4 <= r. 

  Section plus.

    Variable (a b c : nat-> nat) (ca cb cc : nat) 
             (Ha : is_cipher_of a ca)
             (Hb : is_cipher_of b cb) 
             (Hc : is_cipher_of c cc).

    Definition Code_plus := ca = cb + cc.
 
    Lemma Code_plus_spec : Code_plus <-> forall i, i < l -> a i = b i + c i.

  End plus.

  Notation u := (∑ l (fun i => power (power (S i) 2) r)).
  Notation u1 := (∑ l (fun i => power (power (S (S i)) 2) r)).

  Section mult_utils.
 
    Variable (b c : nat-> nat) (cb cc : nat) 
             (Hb : is_cipher_of b cb) 
             (Hc : is_cipher_of c cc).

    Let eq1 :    cb*cc = ∑ l (fun i => (b i*c i)*power (power (S (S i)) 2) r)
                       + ∑ l (fun i => ∑ i (fun j => (b i*c j + b j*c i)*power (power (S i) 2 + power (S j) 2) r)).

    Let Hbc_1 i : i < l -> b i * c i < r.
  
    Let Hbc_2 i j : i < l -> j < l -> b i * c j + b j * c i < r.

    Let Hbc_3 : ∑ l (fun i => (b i*c i)*power (power (S (S i)) 2) r) 
              = msum nat_join 0 l (fun i => (b i*c i)*power (power (S (S i)) 2) r).

    Let Hbc_4 : ∑ l (fun i => ∑ i (fun j => (b i*c j + b j*c i)*power (power (S i) 2 + power (S j) 2) r))
              = msum nat_join 0 l (fun i => 
                           msum nat_join 0 i (fun j => (b i*c j + b j*c i)*power (power (S i) 2 + power (S j) 2) r)).
    
    Let eq2 :   cb*cc = msum nat_join 0 l (fun i => (b i*c i)*power (power (S (S i)) 2) r)
                      ⇡ msum nat_join 0 l (fun i => 
                           msum nat_join 0 i (fun j => (b i*c j + b j*c i)*power (power (S i) 2 + power (S j) 2) r)).

    Let Hr_1 : (r-1)*u1 = ∑ l (fun i => (r-1)*power (power (S (S i)) 2) r).

    Let Hr_2 : (r-1)*u1 = msum nat_join 0 l (fun i => (r-1)*power (power (S (S i)) 2) r).
   
    Fact cipher_mult_eq : (cb*cc)⇣((r-1)*u1) = ∑ l (fun i => (b i*c i)*power (power (S (S i)) 2) r).

  End mult_utils.
  
  Section mult.

    Variable (a b c : nat-> nat) (ca cb cc : nat) 
             (Ha : is_cipher_of a ca)
             (Hb : is_cipher_of b cb) 
             (Hc : is_cipher_of c cc).

    Definition Code_mult := 
                l = 0 
             \/ l <> 0 
             /\ exists v v1 r' r'' p, 
                        r'' = r 
                     /\ r'' = r'+1 
                     /\ seqs_of_ones v v1 
                     /\ p = (ca*v)⇣(r'*v1) 
                     /\ p = (cb*cc)⇣(r'*v1).

    Lemma Code_mult_spec : Code_mult <-> forall i, i < l -> a i = b i * c i. 

  End mult.

  Section inc_seq.

    Definition CodeNat c := is_cipher_of (fun i => i) c.

    Let IncSeq_dio_priv y : CodeNat y <-> l = 0 /\ 1 < q /\ y = 0 
                                  \/ 0 < l 
                                  /\ exists z v v1, 
                                        seqs_of_ones v v1 
                                     /\ Code y
                                     /\ Code z
                                     /\ y + l*(power (power (S l) 2) r) = (z*v)⇣((r-1) * v1)
                                     /\ y+v1+power (power 1 2) r = z + power (power (S l) 2) r.

    Lemma CodeNat_dio y : CodeNat y <-> l = 0 /\ 1 < q /\ y = 0 
                                  \/ 0 < l 
                                  /\ exists z v v1 p0 p1 p2 r1,
                                        p0 = r
                                     /\ r1+1 = p0 
                                     /\ p1 = power (1+l) 2
                                     /\ p2 = power p1 p0 
                                     /\ seqs_of_ones v v1 
                                     /\ Code y
                                     /\ Code z
                                     /\ y + l*p2 = (z*v) ⇣ (r1 * v1)
                                     /\ y + v1 + p0*p0 = z + p2.
      
  End inc_seq.

End sums.  

Check Code_plus_spec.
Check Code_mult_spec.
Check CodeNat_dio. *)
Require Import dio_logic dio_cipher dio_elem.
(* dio_logic:
Require Import Arith Nat Omega.
Require Import gcd.

Set Implicit Arguments.

Section diophantine_expressions.

  Inductive dio_op := do_add | do_mul.

  Definition do_eval o :=
    match o with
      | do_add => plus
      | do_mul => mult
    end.

  Inductive dio_expression : Set :=
    | de_cst  : nat -> dio_expression
    | de_var  : nat -> dio_expression
    | de_comp : dio_op -> dio_expression -> dio_expression -> dio_expression.

  Definition de_add := de_comp do_add.
  Definition de_mul := de_comp do_mul.

  Fixpoint de_size e :=
    match e with
      | de_cst n => 1
      | de_var x => 1
      | de_comp _ p q => 1 + de_size p + de_size q
    end.

  Fixpoint de_size_Z e :=
    (match e with
      | de_cst n => 1
      | de_var x => 1
      | de_comp _ p q => 1 + de_size_Z p + de_size_Z q
    end)%Z.

  Fact de_size_Z_spec e : de_size_Z e = Z.of_nat (de_size e).

  Fixpoint de_eval ν e  :=
    match e with
      | de_cst n => n
      | de_var x => ν x
      | de_comp o p q => do_eval o (de_eval ν p) (de_eval ν q)
    end.

  Fact de_eval_ext e ν ω : (forall x, ν x = ω x) -> de_eval ν e = de_eval ω e.

  Fixpoint de_subst σ e :=
    match e with
      | de_cst n => de_cst n
      | de_var x => σ x
      | de_comp o p q => de_comp o (de_subst σ p) (de_subst σ q)
    end.

  Fact de_eval_subst σ ν e : de_eval ν (de_subst σ e) = de_eval (fun x => de_eval ν (σ x)) e.

  Fact de_subst_subst σ1 σ2 e : de_subst σ1 (de_subst σ2 e) = de_subst (fun x => de_subst σ1 (σ2 x)) e.

  Definition de_ren ρ := de_subst (fun x => de_var (ρ x)).

  Fact de_ren_size ρ e : de_size (de_ren ρ e) = de_size e.

  Fact de_ren_size_Z ρ e : de_size_Z (de_ren ρ e) = de_size_Z e.

  Fact de_eval_ren ρ ν e : de_eval ν (de_ren ρ e)  = de_eval (fun x => ν (ρ x)) e.

  Definition de_lift := de_ren S.

  Fact de_eval_lift ν e : de_eval ν (de_lift e) = de_eval (fun x => ν (S x)) e.

End diophantine_expressions.

Definition dio_expr t := { e | forall ν, de_eval ν e = t ν }.

Notation 𝔻P := dio_expr.

Section dio_expr.

  Implicit Types r t : (nat -> nat) -> nat.

  Fact dio_expr_var i : 𝔻P (fun v => v i).

  Fact dio_expr_cst c : 𝔻P (fun _ => c).

  Fact dio_expr_plus r t : 𝔻P r -> 𝔻P t -> 𝔻P (fun ν => r ν + t ν).
  
  Fact dio_expr_mult r t : 𝔻P r -> 𝔻P t -> 𝔻P (fun ν => r ν * t ν).

  Fact dio_expr_ren t ρ : 𝔻P t -> 𝔻P (fun ν => t (fun i => ν (ρ i))).

  Fact dio_expr_subst t σ : 𝔻P t -> 𝔻P (fun ν => t (fun i => de_eval ν (σ i))).

End dio_expr.

Hint Resolve dio_expr_var dio_expr_cst dio_expr_plus dio_expr_mult dio_expr_ren.

Section diophantine_logic.

  Inductive dio_formula : Set :=
    | df_atm  : dio_expression -> dio_expression -> dio_formula   
    | df_conj : dio_formula -> dio_formula -> dio_formula 
    | df_disj : dio_formula -> dio_formula -> dio_formula
    | df_exst : dio_formula -> dio_formula.

  Fixpoint df_size f :=
    match f with
      | df_atm a b  => 1 + de_size a + de_size b
      | df_conj f g => 1 + df_size f + df_size g  
      | df_disj f g => 1 + df_size f + df_size g  
      | df_exst f   => 1 + df_size f
    end.

  Fixpoint df_size_Z f :=
    (match f with
      | df_atm a b  => 1 + de_size_Z a + de_size_Z b
      | df_conj f g => 1 + df_size_Z f + df_size_Z g  
      | df_disj f g => 1 + df_size_Z f + df_size_Z g  
      | df_exst f   => 1 + df_size_Z f
    end)%Z.

  Fact df_size_Z_spec f : df_size_Z f = Z.of_nat (df_size f).

  Definition dv_lift X ν (x : X) n :=
     match n with 
       | 0   => x 
       | S n => ν n 
     end.

  Fixpoint df_pred f ν :=
    match f with
      | df_atm a b  => de_eval ν a  = de_eval ν b
      | df_conj f g => df_pred f ν /\ df_pred g ν
      | df_disj f g => df_pred f ν \/ df_pred g ν
      | df_exst f   => exists n, df_pred f (dv_lift ν n)
    end.

  Fact df_pred_atm a b ν : df_pred (df_atm a b) ν = (de_eval ν a = de_eval ν b).
  
  Fact df_pred_conj f g ν : df_pred (df_conj f g) ν = (df_pred f ν /\ df_pred g ν).

  Fact df_pred_disj f g ν : df_pred (df_disj f g) ν = (df_pred f ν \/ df_pred g ν).

  Fact df_pred_exst f ν : df_pred (df_exst f) ν = exists n, df_pred f (dv_lift ν n).

  Fact df_pred_ext f ν ω : (forall x, ν x = ω x) -> df_pred f ν <-> df_pred f ω.

  Definition der_lift ρ x := match x with 0 => 0 | S x => S (ρ x) end.

  Fixpoint df_ren ρ f :=
    match f with
      | df_atm a b  => let σ := fun x => de_var (ρ x) in df_atm (de_subst σ a) (de_subst σ b)
      | df_conj f g => df_conj (df_ren ρ f) (df_ren ρ g)
      | df_disj f g => df_disj (df_ren ρ f) (df_ren ρ g)
      | df_exst f   => df_exst (df_ren (der_lift ρ) f)
    end.

  Fact df_ren_size ρ f : df_size (df_ren ρ f) = df_size f.

  Fact df_ren_size_Z ρ f : df_size_Z (df_ren ρ f) = df_size_Z f.

  Fact df_pred_ren f ν ρ : df_pred (df_ren ρ f) ν <-> df_pred f (fun x => ν (ρ x)).

  Definition des_lift σ x := match x with 0 => de_var 0 | S x => de_ren S (σ x) end. 
     
  Fixpoint df_subst σ f := 
    match f with
      | df_atm a b  => df_atm (de_subst σ a) (de_subst σ b)
      | df_conj f g => df_conj (df_subst σ f) (df_subst σ g)
      | df_disj f g => df_disj (df_subst σ f) (df_subst σ g)
      | df_exst f   => df_exst (df_subst (des_lift σ) f)
    end.

  Fact df_pred_subst f ν σ : df_pred (df_subst σ f) ν <-> df_pred f (fun x => de_eval ν (σ x)).

  Definition df_lift := df_ren S.

  Fact df_pred_lift f ν : df_pred (df_lift f) ν <-> df_pred f (fun x => ν (S x)).

End diophantine_logic.

Section examples.

  Variable ν : nat -> nat.

  Definition df_true := df_atm (de_cst 0) (de_cst 0).
  Definition df_false := df_atm (de_cst 0) (de_cst 1).

  Fact df_true_spec : df_pred df_true ν <-> True.

  Fact df_false_spec : df_pred df_false ν <-> False.

  Notation "'⟦' x '⟧'" := (de_eval ν x).

  Definition df_le x y := df_exst (df_atm (de_add (de_var 0) (de_lift x)) (de_lift y)).

  Fact df_le_spec x y : df_pred (df_le x y) ν <-> ⟦x⟧ <= ⟦y⟧.

  Definition df_lt x y := df_exst (df_atm (de_add (de_cst 1) (de_add (de_var 0) (de_lift x))) (de_lift y)).

  Fact df_lt_spec x y : df_pred (df_lt x y) ν <-> ⟦x⟧ < ⟦y⟧.

  Definition df_eq x y := df_atm x y.

  Fact df_eq_spec x y : df_pred (df_eq x y) ν <-> ⟦x⟧ = ⟦y⟧.

  Definition df_neq x y := df_disj (df_lt x y) (df_lt y x).

  Fact df_neq_spec x y : df_pred (df_neq x y) ν <-> ⟦x⟧ <> ⟦y⟧.

  Definition df_div x y := df_exst (df_atm (de_lift y) (de_mul (de_var 0) (de_lift x))).

  Fact df_div_spec x y : df_pred (df_div x y) ν <-> divides ⟦x⟧ ⟦y⟧.

End examples.

Definition dio_rel R := { f | forall ν, df_pred f ν <-> R ν }.
Notation 𝔻R := dio_rel.

Section dio_rel.

  Implicit Types R S : (nat -> nat) -> Prop.

  Fact dio_rel_True : 𝔻R (fun _ => True).

  Fact dio_rel_False : 𝔻R (fun _ => False).

  Fact dio_rel_eq r t : 𝔻P r -> 𝔻P t -> 𝔻R (fun ν => r ν = t ν).

  Fact dio_rel_le r t : 𝔻P r -> 𝔻P t -> 𝔻R (fun ν => r ν <= t ν).

  Fact dio_rel_lt r t : 𝔻P r -> 𝔻P t -> 𝔻R (fun ν => r ν < t ν).

  Fact dio_rel_neq r t : 𝔻P r -> 𝔻P t -> 𝔻R (fun ν => r ν <> t ν).

  Fact dio_rel_div r t : 𝔻P r -> 𝔻P t -> 𝔻R (fun ν => divides (r ν) (t ν)).

  Fact dio_rel_conj R S : 𝔻R R -> 𝔻R S -> 𝔻R (fun ν => R ν /\ S ν).

  Fact dio_rel_disj R S : 𝔻R R -> 𝔻R S -> 𝔻R (fun ν => R ν \/ S ν).

  Fact dio_rel_exst (K : nat -> (nat -> nat) -> Prop) : 
                   𝔻R (fun v => K (v 0) (fun n => v (S n))) 
      -> 𝔻R (fun ν => exists x, K x ν).

  Lemma dio_rel_equiv R S : (forall ν, S ν <-> R ν) -> 𝔻R R -> 𝔻R S.

  Lemma dio_rel_ren R f : 𝔻R R -> 𝔻R (fun v => R (fun n => v (f n))).

  Lemma dio_rel_subst R f : 𝔻R R -> 𝔻R (fun v => R (fun n => de_eval v (f n))).

End dio_rel.

Hint Resolve dio_rel_True dio_rel_False dio_rel_eq dio_rel_neq 
             dio_rel_le dio_rel_lt dio_rel_div 
             dio_rel_conj 
             dio_rel_disj 
             dio_rel_exst.

Ltac dio_rel_auto := repeat ((apply dio_rel_exst || apply dio_rel_conj || apply dio_rel_disj || apply dio_rel_eq); auto).

Section more_examples.

  Fact ndivides_eq x y : ~ (divides x y) <-> x = 0 /\ y <> 0 \/ exists a b, y = a*x+b /\ 0 < b < x.
  
  Lemma dio_rel_ndivides x y : 𝔻P x -> 𝔻P y -> 𝔻R (fun ν => ~ divides (x ν) (y ν)).

  Hint Resolve dio_rel_ndivides.

  Fact rem_equiv p x r : r = rem x p <-> (p = 0 /\ x = r)
                                      \/ (p <> 0 /\ r < p /\ exists n, x = n*p + r).
 
  Lemma dio_rel_remainder p x r : 𝔻P p -> 𝔻P x -> 𝔻P r  
                               -> 𝔻R (fun ν => r ν = rem (x ν) (p ν)).

  Hint Resolve dio_rel_remainder.

  Fact congr_equiv x y p : rem x p = rem y p <-> (exists r, r = rem x p /\ r = rem y p).

  Lemma dio_rel_congruence x y p : 𝔻P x -> 𝔻P y -> 𝔻P p  
                                -> 𝔻R (fun ν => rem (x ν) (p ν) = rem (y ν) (p ν)).

  Hint Resolve dio_rel_congruence.

  Fact not_divides_eq p x : ~ divides p x <-> exists r, r = rem x p /\ r <> 0.

  Lemma dio_rel_not_divides x p : 𝔻P x -> 𝔻P p -> 𝔻R (fun ν => ~ divides (x ν) (p ν)).

End more_examples.

Hint Resolve dio_rel_congruence dio_rel_not_divides.

Section dio_rel_compose.

  Variable (f : (nat -> nat) -> nat) (R : nat -> (nat -> nat) -> Prop).
  Hypothesis (Hf : 𝔻R (fun ν => ν 0 = f (fun x => ν (S x)))) 
             (HR : 𝔻R (fun ν => R (ν 0) (fun x => ν (S x)))).

  Lemma dio_rel_compose : 𝔻R (fun ν => R (f ν) ν).

End dio_rel_compose.

Section multiple_exists.

  Fixpoint df_mexists n f :=
    match n with 
      | 0   => f
      | S n => df_mexists n (df_exst f)
    end.

  Fact df_mexists_size n f : df_size (df_mexists n f) = n + df_size f.

  Fact df_mexists_size_Z n f : df_size_Z (df_mexists n f) = (Z.of_nat n + df_size_Z f)%Z.

  Lemma df_mexists_spec n f ν : 
           df_pred (df_mexists n f) ν 
       <-> exists π, df_pred f (fun i => if le_lt_dec n i then ν (i-n) else π i).

End multiple_exists. *)
(* dio_cipher:
Require Import Arith Nat Omega List Bool Setoid.
Require Import utils_tac gcd prime binomial sums bool_nat luca.
Require Import cipher dio_logic dio_expo dio_binary.

Set Implicit Arguments.

Local Infix "≲" := binary_le (at level 70, no associativity).
Local Notation power := (mscal mult 1).
Local Notation "∑" := (msum plus 0).
Local Infix "⇣" := nat_meet (at level 40, left associativity).
Local Infix "⇡" := nat_join (at level 50, left associativity).

Theorem seqs_of_ones_diophantine l q u u1 : 𝔻P l -> 𝔻P q -> 𝔻P u -> 𝔻P u1
          -> 𝔻R (fun v => seqs_of_ones (l v) (q v) (u v) (u1 v)).

Hint Resolve seqs_of_ones_diophantine.

Theorem Code_diophantine l q a : 𝔻P l -> 𝔻P q -> 𝔻P a
                              -> 𝔻R (fun v => Code (l v) (q v) (a v)).

Hint Resolve Code_diophantine.

Theorem Const_diophantine l q c x : 𝔻P l -> 𝔻P q -> 𝔻P c -> 𝔻P x
                                 -> 𝔻R (fun v => Const (l v) (q v) (c v) (x v)).

Hint Resolve Const_diophantine.

Theorem CodeNat_diophantine l q a : 𝔻P l -> 𝔻P q -> 𝔻P a -> 𝔻R (fun v => CodeNat (l v) (q v) (a v)).

Hint Resolve CodeNat_diophantine.

Theorem Code_plus_diophantine a b c : 𝔻P a -> 𝔻P b -> 𝔻P c
                                   -> 𝔻R (fun v => Code_plus (a v) (b v) (c v)).

Theorem Code_mult_diophantine l q a b c : 𝔻P l -> 𝔻P q -> 𝔻P a -> 𝔻P b -> 𝔻P c
                                       -> 𝔻R (fun v => Code_mult (l v) (q v) (a v) (b v) (c v)).

Hint Resolve Code_plus_diophantine Code_mult_diophantine. *)
(* dio_elem:
Require Import List Arith Nat Omega.
Require Import utils_list gcd prime dio_logic.

Set Implicit Arguments.

Section interval.

  Definition interval := (nat * nat)%type. 

  Implicit Types (i j : interval).

  Definition in_interval i x := let (a,b) := i in a <= x < b.
  Definition out_interval i x := let (a,b) := i in x < a \/ b <= x.
  Definition interval_disjoint i j := forall x, in_interval i x -> in_interval j x -> False.

  Definition interval_union (i j : interval) :=
    match i, j with (a1,b1),(a2,b2) => (min a1 a2, max b1 b2) end.

  Fact in_out_interval i x : in_interval i x -> out_interval i x -> False.

  Fact in_out_interval_dec i x : { in_interval i x } + { out_interval i x }.

  Fact interval_union_left i j x : in_interval i x -> in_interval (interval_union i j) x.

  Fact interval_union_right i j x : in_interval j x -> in_interval (interval_union i j) x.

  Definition valuation_union i1 (g1 : nat -> nat) i2 g2 : 
               interval_disjoint i1 i2 
            -> { g | (forall x, in_interval i1 x -> g x = g1 x)
                  /\ (forall x, in_interval i2 x -> g x = g2 x) }.

  Definition valuation_one_union k v i1 (g1 : nat -> nat) i2 g2 : 
               ~ in_interval (interval_union i1 i2) k 
            -> interval_disjoint i1 i2 
            -> { g | g k = v /\ (forall x, in_interval i1 x -> g x = g1 x)
                             /\ (forall x, in_interval i2 x -> g x = g2 x) }.

End interval.

Section diophantine_system.

  Inductive dio_elem_expr : Set :=
    | dee_nat  : nat -> dio_elem_expr   
    | dee_var  : nat -> dio_elem_expr   
    | dee_par  : nat -> dio_elem_expr   
    | dee_comp : dio_op -> nat -> nat -> dio_elem_expr. 

  Notation dee_add := (dee_comp do_add).
  Notation dee_mul := (dee_comp do_mul).

  Definition dee_eval φ ν e := 
    match e with
      | dee_nat n => n
      | dee_var v => φ v
      | dee_par i => ν i
      | dee_comp o v w => do_eval o (φ v) (φ w) 
    end.

  Definition dee_vars e x  :=
    match e with
      | dee_nat _ => False
      | dee_var v => x = v
      | dee_par _ => False
      | dee_comp _ v w => x = v \/ x = w
    end.

  Fact dee_eval_ext e φ1 ν1 φ2 ν2  : 
        (forall x, dee_vars e x -> φ1 x = φ2 x) 
     -> (forall x, ν1 x = ν2 x)
     -> dee_eval φ1 ν1 e = dee_eval φ2 ν2 e.

  Definition dee_move k p :=
    match p with
      | dee_nat n      => dee_nat n
      | dee_var v      => dee_var (k+v)
      | dee_par i      => dee_par i
      | dee_comp o v w => dee_comp o (k+v) (k+w)
    end.

  Fact dee_eval_move k φ ν e : dee_eval φ ν (dee_move k e) = dee_eval (fun x => φ (k+x)) ν e.

  Fact dee_vars_move k e x : dee_vars (dee_move k e) x <-> exists y, dee_vars e y /\ x = k+y.

  Definition dee_dec k e :=
    match e with
      | dee_nat n      => dee_nat n
      | dee_var v      => dee_var v
      | dee_par 0      => dee_var k 
      | dee_par (S i)  => dee_par i
      | dee_comp o v w => dee_comp o v w
    end.

  Fact dee_eval_dec φ ν k e : dee_eval φ ν (dee_dec k e) = dee_eval φ (fun x => match x with 0 => φ k | S x => ν x end) e.

  Fact dee_vars_dec k e x : dee_vars (dee_dec k e) x -> x = k \/ dee_vars e x.

  Definition dio_constraint := (nat * dio_elem_expr)%type.

  Implicit Type (c : dio_constraint).

  Definition dc_eval φ ν c := φ (fst c) = dee_eval φ ν (snd c).

  Arguments dc_eval φ ν c /.
  
  Definition dc_vars c x := x = fst c \/ dee_vars (snd c) x.

  Arguments dc_vars c x /.

  Fact dc_eval_ext c φ1 ν1 φ2 ν2  : 
        (forall x, dc_vars c x -> φ1 x = φ2 x) 
     -> (forall x, ν1 x = ν2 x)
     -> dc_eval φ1 ν1 c <-> dc_eval φ2 ν2 c.

  Definition dc_move k c := (k+fst c, dee_move k (snd c)).

  Fact dc_eval_move k φ ν c : dc_eval φ ν (dc_move k c) <-> dc_eval (fun x => φ (k+x)) ν c.

  Fact dc_vars_move k c x : dc_vars (dc_move k c) x <-> exists y, x = k + y /\ dc_vars c y.

  Definition dc_dec k c := (fst c, dee_dec k (snd c)).

  Fact dc_eval_dec φ ν k c : dc_eval φ ν (dc_dec k c) <-> dc_eval φ  (fun x => match x with 0 => φ k | S x => ν x end) c.

  Fact dc_vars_dec k c x : dc_vars (dc_dec k c) x -> x = k \/ dc_vars c x.

  Implicit Type (R : (nat -> nat) -> Prop).

  Record dio_repr_at R a n l := {
    ds_eqns : list dio_constraint;
    ds_ref  : nat;
    ds_H0   : length ds_eqns = l;
    ds_H1   : forall x c, In c ds_eqns -> dc_vars c x -> a <= x < a+n;
    ds_H2   : a <= ds_ref < a+n;
    ds_H3   : forall ν, exists φ, Forall (dc_eval φ ν) ds_eqns;
    ds_H4   : forall ν, R ν <-> exists φ, Forall (dc_eval φ ν) ds_eqns /\ φ ds_ref = 0;
  }.

  Section diophantine_sys_expr.

    Fixpoint de_eqns e x :=
      match e with
        | de_cst n      => (x,dee_nat n)::nil 
        | de_var p      => (x,dee_par p)::nil
        | de_comp o p q => (x,dee_comp o (x+1) (x+1+de_size p)) :: de_eqns p (x+1) ++ de_eqns q (x+1+de_size p)
      end.

    Fact de_eqns_length e x : length (de_eqns e x) = de_size e.

    Fact de_size_ge_1 e : 1 <= de_size e.

    Fact de_eqns_vars e x : forall c, In c (de_eqns e x) -> forall y, dc_vars c y -> x <= y < x+de_size e.

    Fact dc_Forall_eval φ ν e x : Forall (dc_eval φ ν) (de_eqns e x) -> de_eval ν e = φ x.

    Fact dc_eval_exists_Forall ν e x : { φ | Forall (dc_eval φ ν) (de_eqns e x) }. 

    Let compare_lemma x y : { u : nat & { v | u+x = v+y } }.

    Let g0 (n x0 x1 x2 x3 m : nat) := if le_lt_dec n m then 
                                match m - n with
                                  | 0 => x0
                                  | 1 => x1
                                  | 2 => x2
                                  | _ => x3
                                end
                              else x3.

    Let g0_0 (n x0 x1 x2 x3 : nat) : g0 n x0 x1 x2 x3 n = x0.

    Let g0_1 (n x0 x1 x2 x3 : nat) : g0 n x0 x1 x2 x3 (n+1) = x1.

    Let g0_2 (n x0 x1 x2 x3 : nat) : g0 n x0 x1 x2 x3 (n+2) = x2.

    Let g0_3 (n x0 x1 x2 x3 : nat) : g0 n x0 x1 x2 x3 (n+3) = x3.

    Lemma dio_repr_at_eq n e1 e2 : dio_repr_at (fun ν => de_eval ν e1 = de_eval ν e2) n (4+de_size e1+de_size e2) (3+de_size e1+de_size e2).

  End diophantine_sys_expr.

  Let not_interval_union a1 n1 a2 n2 : 
           a1+n1 <= a2
        -> ~ in_interval (interval_union (a1, a1 + n1) (a2, a2 + n2)) (a2 + n2).

  Lemma dio_repr_at_conj R1 a1 n1 p1 R2 a2 n2 p2 n : 
          dio_repr_at R1 a1 n1 p1
       -> dio_repr_at R2 a2 n2 p2
       -> a1+n1 <= a2
       -> n = 1+a2+n2-a1
       -> dio_repr_at (fun ν => R1 ν /\ R2 ν) a1 n (1+p1+p2).

  Lemma dio_repr_at_disj R1 a1 n1 p1 R2 a2 n2 p2 n : 
          dio_repr_at R1 a1 n1 p1
       -> dio_repr_at R2 a2 n2 p2
       -> a1+n1 <= a2
       -> n = 1+a2+n2-a1
       -> dio_repr_at (fun ν => R1 ν \/ R2 ν) a1 n (1+p1+p2). 

  Lemma dio_repr_at_exst R a n m p : 
          dio_repr_at R a n p
       -> m = n+1
       -> dio_repr_at (fun ν => exists n, R (dv_lift ν n)) a m p. 

  Fixpoint df_weight_1 f :=
    match f with
      | df_atm a b  => 4 + de_size a + de_size b
      | df_conj f g => 1 + df_weight_1 f + df_weight_1 g  
      | df_disj f g => 1 + df_weight_1 f + df_weight_1 g  
      | df_exst f   => 1 + df_weight_1 f
    end.

  Fact df_weigth_1_size f : df_weight_1 f <= 4*df_size f.

  Fixpoint df_weight_2 f :=
    match f with
      | df_atm a b  => 3 + de_size a + de_size b
      | df_conj f g => 1 + df_weight_2 f + df_weight_2 g  
      | df_disj f g => 1 + df_weight_2 f + df_weight_2 g  
      | df_exst f   => df_weight_2 f
    end.

  Fact df_weigth_2_size f : df_weight_2 f <= 3*df_size f.

  Lemma dio_repr_at_form n f : dio_repr_at (df_pred f) n (df_weight_1 f) (df_weight_2 f).

  Theorem dio_formula_elem f : { l | length l <= 1+3*df_size f
                                 /\ (forall c x, In c l -> dc_vars c x -> x < 4*df_size f)  
                                 /\  forall ν, df_pred f ν <-> exists φ, Forall (dc_eval φ ν) l }.

  Definition dio_fs f := proj1_sig (dio_formula_elem f).
                 
End diophantine_system. *)

Set Implicit Arguments.

Local Notation power := (mscal mult 1).
Local Notation "∑" := (msum plus 0).

Section df_mconj.

  Fixpoint df_mconj k f :=
    match k with 
      | 0   => df_true
      | S k => df_conj (f 0) (df_mconj k (fun i => f (S i)))
    end.

  Fact df_mconj_size k f : df_size (df_mconj k f) = 3+k+∑ k (fun i => df_size (f i)).
  Proof.
    revert f; induction k as [ | k IHk ]; intros f; simpl; auto.
    rewrite IHk; ring.
  Qed.

  Fact df_mconj_spec k f ν : df_pred (df_mconj k f) ν <-> forall i, i < k -> df_pred (f i) ν.
  Proof.
    revert f ν; induction k as [ | k IHk ]; intros f phi; simpl.
    + split; auto; intros; omega.
    + rewrite IHk; split.
      * intros (? & H2) [ | i ] ?; auto; apply H2; omega.
      * intros H; split; intros; apply H; omega.
  Qed.

  Lemma dio_rel_mconj k (P : nat -> (nat -> nat) -> Prop) :
         (forall i, i < k -> dio_rel (P i))
      -> dio_rel (fun ν => forall i, i < k -> P i ν).
  Proof.
    intros H.
    apply fmap_reifier_t_default with (1 := df_true) in H.
    destruct H as (f & Hf).
    exists (df_mconj k f).
    intros v; rewrite df_mconj_spec; split;
      intros E i Hi; generalize (E _ Hi); apply Hf; trivial. 
  Defined.

End df_mconj.

Section dio_bounded_fall.

  Section dio_bounded_elem.

    Variable (k : nat).

    Notation iq := (k+1).  
    Notation il := (k+2).  

    Let dc_Code (c : dio_constraint) ω :=
      match c with
       | (u, dee_nat n)           => Const (ω il) (ω iq) n (ω u)
       | (u, dee_var v)           => ω u = ω v
       | (u, dee_par 0)           => ω u = ω k
       | (u, dee_par (S p))       => Const (ω il) (ω iq) (ω (k+2+p)) (ω u)
       | (u, dee_comp do_add v w) => Code_plus (ω u) (ω v) (ω w)  
       | (u, dee_comp do_mul v w) => Code_mult (ω il) (ω iq) (ω u) (ω v) (ω w)
      end.

    Let dio_rel_dc_Code c : dio_rel (dc_Code c).
    Proof. 
      destruct c as (u & [ n | v | [] | [] v w ]); unfold dc_Code; auto.
    Defined.

    Let dc_Code_size_Z c : (df_size_Z (proj1_sig (dio_rel_dc_Code c)) <= 70074)%Z.
    Proof.
      destruct c as (u & [ n | v | [] | [] v w ]); compute; discriminate.
    Qed.

    Let dc_Code_spec c φ π ν ω : (forall i, i < k -> is_cipher_of (ν 0) (π iq) (φ i) (π i))
                              -> (is_cipher_of (ν 0) (π iq) (fun n => n) (π k))
                              -> (forall x, dc_vars c x -> x < k)
                              -> (forall i, i < il -> ω i = π i)
                              -> (forall i, il <= i -> ω i = ν (i-il))
                             -> dc_Code c ω <-> forall j, j < ν 0 -> dc_eval (fun i => φ i j) (dv_lift ν j) c.
    Proof.
      intros G1 G2 G3 G4 G5.
      assert (ω il = ν 0) as G0.
      { rewrite G5; try omega; f_equal; omega. }
      destruct c as (u & [ n | v | [ | p ] | [] v w ]); simpl.
      + assert (u < k) as Hu. { apply G3; left; auto. }
        rewrite G0, G4, G4; try omega.
        specialize (G1 _ Hu).
        unfold dc_eval; simpl; split.
        * intros (g & Hg1 & Hg4).
          generalize (is_cipher_of_inj G1 Hg1); intros G6.
          intros; rewrite G6, Hg4; auto; omega.
        * intros; exists (φ u); split; auto.
      + assert (u < k) as Hu. { apply G3; cbv; auto. }
        assert (v < k) as Hv. { apply G3; cbv; auto. }
        do 2 (rewrite G4; try omega).
        unfold dc_eval; simpl.
        apply G1 in Hu.
        apply G1 in Hv.
        apply (is_cipher_of_equiv Hu Hv). 
      + assert (u < k) as Hu. { apply G3; cbv; auto. }
        do 2 (rewrite G4; try omega).
        unfold dc_eval; simpl.
        apply G1 in Hu.
        apply (is_cipher_of_equiv Hu G2).
      + rewrite G0, G4; try omega.
        rewrite G5; try omega.
        replace (il+p-il) with p by omega.
        assert (u < k) as Hu. { apply G3; cbv; auto. }
        rewrite G4; try omega.
        apply G1 in Hu.
        unfold dc_eval; simpl; split.
        * intros (g & Hg1 & Hg2).
          generalize (proj1 (is_cipher_of_equiv Hu Hg1) eq_refl); intros G6.
          intros; rewrite G6, Hg2; auto.
        * intro; exists (φ u); auto.
      + assert (Hu : u < k). { apply G3; cbv; auto. }
        assert (Hv : v < k). { apply G3; cbv; auto. }
        assert (Hw : w < k). { apply G3; cbv; auto. }
        do 3 (rewrite G4; try omega).
        apply G1 in Hu; apply G1 in Hv; apply G1 in Hw.
        rewrite Code_plus_spec with (1 := Hu) (2 := Hv) (3 := Hw).
        unfold dc_eval; simpl; tauto.
      + assert (Hu : u < k). { apply G3; cbv; auto. }
        assert (Hv : v < k). { apply G3; cbv; auto. }
        assert (Hw : w < k). { apply G3; cbv; auto. }
        rewrite G0; do 4 (rewrite G4; try omega).
        apply G1 in Hu; apply G1 in Hv; apply G1 in Hw.
        rewrite Code_mult_spec with (1 := Hu) (2 := Hv) (3 := Hw).
        unfold dc_eval; simpl; tauto.
    Qed.

    Let dc_list_Code ll ν := fold_right (fun c P => dc_Code c ν /\ P) True ll.

    Let dio_rel_dc_list_Code ll : dio_rel (dc_list_Code ll).
    Proof. induction ll; unfold dc_list_Code; simpl; auto. Qed.

    Let dc_list_Code_spec ll φ π ν ω : (forall i, i < k -> is_cipher_of (ν 0) (π iq) (φ i) (π i))
                                    -> (is_cipher_of (ν 0) (π iq) (fun n => n) (π k))
                                    -> (forall c, In c ll -> forall x, dc_vars c x -> x < k)
                                    -> (forall i, i < il  -> ω i = π i)
                                    -> (forall i, il <= i -> ω i = ν (i-il))
                                    -> dc_list_Code ll ω 
                                   <-> forall j, j < ν 0 -> Forall (dc_eval (fun i => φ i j) (dv_lift ν j)) ll.
    Proof.
      intros G1 G2 G3 G4 G5; revert G3.
      rewrite <- Forall_forall.
      induction 1 as [ | c ll F1 F2 IF2 ]; simpl.
      + split; auto.
      + rewrite IF2, dc_Code_spec; auto. 
        split.
        * intros (E1 & E2) j Hj; constructor; auto.
        * intros E1; split; intros j Hj; specialize (E1 _ Hj);
            rewrite Forall_cons_inv in E1; tauto.
    Qed.

    Let ciphers ν := CodeNat (ν il) (ν iq) (ν k) /\ forall i, i < k -> Code (ν il) (ν iq) (ν i).

    Let dio_rel_ciphers : dio_rel ciphers.
    Proof. 
      apply dio_rel_conj.
      + auto.
      + apply dio_rel_mconj; intros; auto. 
    Defined.

    Let ciphers_spec ν : ciphers ν <-> is_cipher_of (ν il) (ν iq) (fun n => n) (ν k) 
                                    /\ exists φ, forall i, i < k -> is_cipher_of (ν il) (ν iq) (φ i) (ν i).
    Proof. 
      unfold ciphers, Code, CodeNat.
      split; intros (H1 & H2); split; auto; clear H1.
      + apply fmap_reifier_default in H2; auto.
      + destruct H2 as (phi & Hphi).
        intros i Hi; exists (phi i); auto.
    Qed.

    Variables (ll : list dio_constraint) 
              (Hll : forall c x, In c ll -> dc_vars c x -> x < k).

    Let Hll' : forall c, In c ll -> forall x, dc_vars c x -> x < k.
    Proof. intros c ? x ?; apply (@Hll c x); auto. Qed.

    Let pre_quant ν := ν il+1 < ν iq /\ ciphers ν /\ dc_list_Code ll ν.

    Let dio_rel_pre_quant : dio_rel pre_quant.
    Proof. unfold pre_quant; auto. Defined.

    Definition dc_list_bfall ν := exists π, pre_quant (fun i => if le_lt_dec il i then ν (i-il) else π i).

    Let dc_list_bfall_spec_1 ν :
          dc_list_bfall ν <-> exists q φ, ν 0+1 < q 
                                      /\ (forall i j, i < k -> j < ν 0 -> φ i j < power q 2) 
                                      /\ forall j, j < ν 0 -> Forall (dc_eval (fun i => φ i j) (dv_lift ν j)) ll.
    Proof.
      split.
      + intros (pi & G0 & G1 & G4).
        rewrite ciphers_spec in G1.
        destruct (le_lt_dec il k) as [ ? | _ ]; try omega.
        destruct (le_lt_dec il il) as [ _  | ? ]; try omega.
        destruct (le_lt_dec il iq) as [ ? | _ ]; try omega.
        replace (il-il) with 0 in * by omega.
        destruct G1 as (G1 & phi & G3).
        assert (forall i, i < k -> is_cipher_of (ν 0) (pi iq) (phi i) (pi i)) as G2.
        { intros i Hi; generalize (G3 _ Hi); destruct (le_lt_dec il i); auto; omega. }
        clear G3.
        rewrite dc_list_Code_spec with (π := pi) (φ := phi) (ν := ν) in G4; auto.
        2,3: intros i Hi; destruct (le_lt_dec il i) as [ H | H ]; auto; try omega.
        exists (pi iq), phi; repeat (split; auto). 
        intros i j Hi Hj; destruct (G2 _ Hi) as (_ & G3 & _); auto.
      + intros (q & phi & Hq & Hphi1 & Hphi2).
        assert (q <= power q 2) as Hq' by (apply power_ge_n; auto).
        destruct (the_cipher (fun i => i) Hq) as (u & Hu). { intros; omega. }

        set (pi i := match lt_eq_lt_dec i k with
                     | inleft (left H)  => proj1_sig (the_cipher (phi i) Hq (fun j Hj => Hphi1 _ _ H Hj)) 
                     | inleft (right H) => u
                     | inright H        => q
                   end).
        assert (Hpi_k : pi k = u).
        { unfold pi; destruct (lt_eq_lt_dec k k) as [ [] | ]; auto; try omega. }
        assert (forall i, i < k -> is_cipher_of (ν 0) q (phi i) (pi i)) as Hpi.
        { unfold pi; intros i Hi.
          destruct (lt_eq_lt_dec i k) as [ [H | ] | ]; try omega.
          apply (proj2_sig (the_cipher (phi i) Hq (fun j Hj => Hphi1 _ _ H Hj))). }
        assert (Hpi_q : pi iq = q).
        { unfold pi; destruct (lt_eq_lt_dec iq k) as [ [H | ] | ]; try omega. }
        generalize pi Hpi_k Hpi_q Hpi; clear pi Hpi_k Hpi Hpi_q.
        intros pi Hpi_k Hpi_q Hpi; subst u.

        exists pi; red.
        rewrite ciphers_spec.
        destruct (le_lt_dec il k) as [ ? | _ ]; try omega.
        destruct (le_lt_dec il il) as [ _ | ? ]; try omega.
        destruct (le_lt_dec il iq) as [ ? | _ ]; try omega.
        rewrite Nat.sub_diag. 
        subst q; repeat (split; auto).
        * exists phi; intros i Hi.
          destruct (le_lt_dec il i); try omega; auto.
        * rewrite dc_list_Code_spec with (π := pi) (φ := phi); auto;
            intros i Hi; destruct (le_lt_dec il i); auto; omega.
    Qed.

    Let dc_list_bfall_spec ν : (forall i, i < ν 0 -> exists φ, Forall (dc_eval φ (dv_lift ν i)) ll) <-> dc_list_bfall ν .
    Proof.
      rewrite dc_list_bfall_spec_1; split.
      + intros H.
        apply fmmap_reifer_bound  with (p := k) in H.
        - destruct H as (m & phi & Hf).
          set (q := power (ν 0+2+m) 2).
          assert (ν 0+1 < q) as Hlq.
          { apply lt_le_trans with (ν 0+2+m); try omega.
            apply power_ge_n; auto. }
          assert (m <= power q 2) as Hmq.
          { apply le_trans with q.
            apply le_trans with (ν 0+2+m); try omega.
            apply power_ge_n; auto.
            apply power_ge_n; auto. }
          exists q, (fun i j => phi j i); split; [ | split ]; auto.
          * intros i j Hi Hj; apply lt_le_trans with m; auto; apply Hf; auto.
          * intros; apply Hf; auto.
        - intros x f g Hfg.
          apply Forall_impl.
          intros c Hc; apply dc_eval_ext; auto.
          intros z Hz; symmetry; apply Hfg, Hll with c; auto.
      + intros (q & phi & Hq & H1 & H2) j Hj.
        exists (fun i => phi i j); auto.
    Qed.

    Theorem dio_rel_dc_list_bfall : dio_rel (fun ν => forall i, i < ν 0 -> exists φ, Forall (dc_eval φ (dv_lift ν i)) ll).
    Proof.
      apply dio_rel_equiv with (1 := dc_list_bfall_spec).
      unfold dc_list_bfall.
      destruct dio_rel_pre_quant as (f & Hf).
      eexists (df_mexists il f).
      intros; rewrite df_mexists_spec; split;
      intros (phi & H); exists phi; revert H; rewrite <- Hf; auto.
    Defined.

  End dio_bounded_elem.

  Theorem dio_bounded_fall P : dio_rel P -> dio_rel (fun ν => forall i, i < ν 0 -> P (dv_lift ν i)).
  Proof.
    intros (f & Hf).
    destruct (dio_formula_elem f) as (ll & H1 & H2 & H3).
    revert H2; generalize (4*df_size f); intros k H2.
    generalize (dio_rel_dc_list_bfall _ H2).
    apply dio_rel_equiv; intros v.
    split; intros H i Hi; generalize (H _ Hi); rewrite <- Hf, H3; auto.
  Defined.

End dio_bounded_fall.

Definition dv_change (ν : nat -> nat) x n := match n with 0 => x | _ => ν n end.

Section dfbfall.
 
  Variable (f : dio_formula).

  Let rho i := match i with 0 => 0 | S i => S (S i) end. 

  Let dfbfall_full : dio_rel (fun ν => forall i, i < ν 0 -> df_pred f (dv_change ν i)).
  Proof.
    assert (dio_rel (df_pred (df_ren rho f))) as H.
    { exists (df_ren rho f); tauto. }
    destruct (dio_bounded_fall H) as (g & Hg).
    exists g.
    intros v.
    rewrite Hg. 
    split; intros G i Hi; generalize (G _ Hi);  
      rewrite df_pred_ren; apply df_pred_ext;
      intros [ | [ | x ] ]; simpl; auto.
  Qed.

  Definition dfbfall := proj1_sig dfbfall_full.

  Fact dfbfall_spec : forall ν, df_pred dfbfall ν <-> forall i, i < ν 0 -> df_pred f (dv_change ν i).
  Proof. apply (proj2_sig dfbfall_full). Qed.

End dfbfall.

Section df_fall_lt.

  Variable (f : dio_formula) (x : dio_expression).

  Definition df_fall_lt := df_subst (fun n => match n with 0 => x | S n => de_var (S n) end) (dfbfall f).

  Fact df_fall_lt_spec ν : df_pred df_fall_lt ν <-> forall n, n < de_eval ν x -> df_pred f (dv_change ν n).
  Proof.
    unfold df_fall_lt.
    rewrite df_pred_subst, dfbfall_spec.
    split; intros H n Hn; generalize (H _ Hn);
      apply df_pred_ext;
      intros [ | ]; simpl; auto.
  Qed.

End df_fall_lt.

Corollary dio_rel_fall_lt_0 (K : nat -> (nat -> nat) -> Prop) : 
            𝔻R (fun ν => K (ν 0) (fun n => ν (S n))) 
   -> 𝔻R (fun ν => forall x, x < ν 0 -> K x (fun n => ν (S n))).
Proof.
  intros (fK & HK).
  exists (df_fall_lt fK (de_var 0)).
  intros; rewrite df_fall_lt_spec.
  simpl. 
  split; intros H n Hn; generalize (H _ Hn); rewrite HK; auto.
Defined.

Theorem dio_rel_fall_lt a (K : nat -> (nat -> nat) -> Prop) : 
            𝔻P a
   -> 𝔻R (fun ν => K (ν 0) (fun n => ν (S n))) 
   -> 𝔻R (fun ν => forall x, x < a ν -> K x ν).
Proof.
  intros (ea & Ha) H.
  apply dio_rel_fall_lt_0 in H.
  destruct H as (f & Hf).
  exists (df_subst (fun n => match n with 0 => ea | S n => de_var n end) f).
  intro; rewrite df_pred_subst, Hf.
  simpl; split; intros H n Hn; apply H; revert Hn; rewrite Ha; auto.
Defined.

Check dio_rel_fall_lt.
Print Assumptions dio_rel_fall_lt.

Hint Resolve dio_rel_fall_lt.

Theorem dio_rel_fall_lt_bound a (K : nat -> nat -> (nat -> nat) -> Prop) : 
            𝔻P a
   -> 𝔻R (fun ν => K (ν 0) (a (fun n => ν (S n))) (fun n => ν (S n))) 
   -> 𝔻R (fun ν => forall x, x < a ν -> K x (a ν) ν).
Proof.
  intros; apply dio_rel_fall_lt; auto.
Qed.

Hint Resolve dio_rel_fall_lt_bound.

Theorem dio_rel_fall_le a (K : nat -> (nat -> nat) -> Prop) : 
            𝔻P a
   -> 𝔻R (fun ν => K (ν 0) (fun n => ν (S n))) 
   -> 𝔻R (fun ν => forall x, x <= a ν -> K x ν).
Proof.
  intros Ha HK.
  apply dio_rel_equiv with (fun v => forall x, x < 1+a v -> K x v); auto.
  intros v; split; intros H x Hx; apply H; omega.
Defined.

Hint Resolve dio_rel_fall_le.
