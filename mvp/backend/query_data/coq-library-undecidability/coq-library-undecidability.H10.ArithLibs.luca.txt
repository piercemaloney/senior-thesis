

Require Import Arith Nat Omega Lia List.

Require Import utils_tac gcd prime binomial sums Zp rel_iter.
(* utils_tac:
Require Import Arith List Wellfounded.

Set Implicit Arguments.

Definition eqdec X := forall x y : X, { x = y } + { x <> y }.

Definition swap {X Y} (c : X * Y) := let (x,y) := c in (y,x).

Theorem measure_rect X (m : X -> nat) (P : X -> Type) :
      (forall x, (forall y, m y < m x -> P y) -> P x) -> forall x, P x.

Tactic Notation "induction" "on" hyp(x) "as" ident(IH) "with" "measure" uconstr(f) :=
  pattern x; revert x; apply measure_rect with (m := fun x => f); intros x IH.

Tactic Notation "eq" "goal" hyp(H) := 
  match goal with 
    |- ?b => match type of H with ?t => replace b with t; auto end 
  end.

Ltac eqgoal := let H := fresh in intro H; eq goal H; clear H.

Tactic Notation "spec" "in" hyp(H) :=
  let Q := fresh 
  in match goal with G: ?h -> _ |- _ => 
       match G with 
         | H => assert (h) as Q; [ | specialize (H Q); clear Q ] 
       end 
     end.

Ltac solve_list_eq := simpl; repeat progress (try rewrite app_ass; try rewrite <- app_nil_end; simpl; auto); auto.

Tactic Notation "solve" "list" "eq" := solve_list_eq.

Tactic Notation "solve_list_eq" "in" hyp(H) := generalize H; clear H; solve_list_eq; intro H.

Tactic Notation "solve" "list" "eq" "in" hyp(H) := 
   let Q := fresh in 
   match goal with 
     |- ?t => set (Q := t); generalize H; clear H; solve_list_eq; intro H; unfold Q; clear Q
   end.

Ltac msplit n := 
  match n with 
    | 0    => idtac 
    | S ?n => split; [ | msplit n ]
   end.

Tactic Notation "define" ident(f) "of" hyp(n) hyp(m) "as" uconstr(t)  :=
  match type of n with ?N =>  
    match type of m with ?M  => pose (f (n:N) (m:M) := t) end end.

Tactic Notation "induction" "on" hyp(x) hyp(y) "as" ident(IH) "with" "measure" uconstr(f) :=
  generalize I; intro IH;
  let mes := fresh "measure" in let rel := fresh "relation" in let loop := fresh "loop" in
  let u := fresh "u" in let u' := fresh x in let Hu := fresh "Hu" in 
  let v := fresh "v" in let v' := fresh y in let Hv := fresh "Hv" 
  in clear IH; 
     define mes of x y as (f : nat);
     set (rel u v := mes (fst u) (snd u) < mes (fst v) (snd v)); unfold fst, snd in rel;
     pattern x, y; match goal with
       |- ?T _ _ => 
       refine ((fix loop u v (Hu : Acc rel (u,v)) { struct Hu } : T u v := _) x y _);
       [ assert (forall u' v', rel (u',v') (u,v) -> T u' v') as IH;
         [ intros u' v' Hv; apply (loop u' v'), (Acc_inv Hu), Hv 
         | unfold rel, mes in *; clear mes rel Hu loop x y; rename u into x; rename v into y ]
       | unfold rel; apply wf_inverse_image, lt_wf ]
     end.

Section forall_equiv.

  Variable (X : Type) (A P Q : X -> Prop) (HPQ : forall n, A n -> P n <-> Q n).

  Theorem forall_bound_equiv : (forall n, A n -> P n) <-> (forall n, A n -> Q n).

End forall_equiv.

Section exists_equiv.

  Variable (X : Type) (P Q : X -> Prop) (HPQ : forall n, P n <-> Q n).

  Theorem exists_equiv : (exists n, P n) <-> (exists n, Q n).

End exists_equiv. *)
(* gcd:
Require Import List Arith Omega Permutation.

Require Import utils_tac utils_list.

Set Implicit Arguments.

Section Euclid.

  Definition euclid n d : d <> 0 -> { q : nat & { r | n = q*d+r /\ r < d } }.

End Euclid.

Definition arem n d q j := j <= d /\ (n = 2*q*d+j \/ q <> 0 /\ n = 2*q*d-j).

Fact division_by_even n d : d <> 0 -> { q : nat & { j | arem n d q j } }.

Fact own_multiple x p : x = p*x -> x = 0 \/ p = 1.

Fact mult_is_one p q : p*q = 1 -> p = 1 /\ q = 1.

Definition divides n k := exists p, k = p*n.

Section divides.

  Infix "div" := divides (at level 70, no associativity).

  Fact divides_refl x : x div x.

  Fact divides_anti x y : x div y -> y div x -> x = y.

  Fact divides_trans x y z : x div y -> y div z -> x div z.

  Fact divides_0 p : p div 0.

  Fact divides_0_inv p : 0 div p -> p = 0.

  Fact divides_1 p : 1 div p.

  Fact divides_1_inv p : p div 1 -> p = 1.

  Fact divides_2_inv p : p div 2 -> p = 1 \/ p = 2.

  Fact divides_mult p q k : p div q -> p div k*q.

  Fact divides_mult_r p q k : p div q -> p div q*k.

  Fact divides_mult_compat a b c d : a div b -> c div d -> a*c div b*d.

  Fact divides_minus p q1 q2 : p div q1 -> p div q2 -> p div q1 - q2.

  Fact divides_plus p q1 q2 : p div q1 -> p div q2 -> p div q1+q2.

  Fact divides_plus_inv p q1 q2 : p div q1 -> p div q1+q2 -> p div q2.

  Fact divides_le p q : q <> 0 -> p div q -> p <= q.

  Fact divides_mult_inv k p q : k <> 0 -> k*p div k*q -> p div q.

  Lemma divides_fact m p : 1 < p <= m -> p div fact m.

  Lemma divides_mult_inv_l p q r : p * q div r -> p div r /\ q div r.

End divides.

Section gcd_lcm.

  Infix "div" := divides (at level 70, no associativity).

  Hint Resolve divides_0 divides_refl divides_mult divides_1.

  Definition is_gcd p q r := r div p /\ r div q /\ forall k, k div p -> k div q -> k div r.
  Definition is_lcm p q r := p div r /\ q div r /\ forall k, p div k -> q div k -> r div k.

  Fact is_gcd_sym p q r : is_gcd p q r -> is_gcd q p r.

  Fact is_gcd_0l p : is_gcd 0 p p.

  Fact is_gcd_0r p : is_gcd p 0 p.

  Fact is_gcd_1l p : is_gcd 1 p 1.

  Fact is_gcd_1r p : is_gcd p 1 1.

  Fact is_gcd_modulus p q k r : p div k -> k <= q -> is_gcd p q r -> is_gcd p (q-k) r.

  Fact is_gcd_minus p q r : p <= q -> is_gcd p q r -> is_gcd p (q-p) r.

  Hint Resolve divides_plus.

  Fact is_gcd_moduplus p q k r : p div k -> is_gcd p q r -> is_gcd p (q+k) r.

  Fact is_gcd_plus p q r : is_gcd p q r -> is_gcd p (q+p) r.

  Fact is_gcd_mult p q r n : is_gcd p (n*p+q) r <-> is_gcd p q r.

  Fact is_gcd_div p q : p div q -> is_gcd p q p.

  Fact is_gcd_refl p : is_gcd p p p.

  Fact is_gcd_fun p q r1 r2 : is_gcd p q r1 -> is_gcd p q r2 -> r1 = r2.

  Fact is_lcm_0l p : is_lcm 0 p 0.

  Fact is_lcm_0r p : is_lcm p 0 0.

  Fact is_lcm_sym p q r : is_lcm p q r -> is_lcm q p r.

  Fact is_lcm_fun p q r1 r2 : is_lcm p q r1 -> is_lcm p q r2 -> r1 = r2.

End gcd_lcm.

Section bezout.

  Infix "div" := divides (at level 70, no associativity).

  Hint Resolve is_gcd_0l is_gcd_0r is_lcm_0l is_lcm_0r divides_refl divides_mult divides_0 is_gcd_minus.

  Section bezout_rel_prime.

    Let bezout_rec p q : 0 < p < q -> is_gcd p q 1 -> exists a b, a*p+b*q = 1+p*q /\ a <= q /\ b <= p.

    Lemma bezout_nc p q : is_gcd p q 1 -> exists a b, a*p+b*q = 1+p*q.

    Hint Resolve divides_1.

    Lemma bezout_sc p q a b m : a*p+b*q = 1 + m -> p div m \/ q div m -> is_gcd p q 1.

  End bezout_rel_prime.

  Fact is_rel_prime_div p q k : is_gcd p q 1 -> p div q*k -> p div k.

  Fact is_rel_prime_div_r p q k : is_gcd p q 1 -> p div k*q -> p div k.

  Fact is_rel_prime_lcm p q : is_gcd p q 1 -> is_lcm p q (p*q).

  Hint Resolve divides_1 divides_mult_compat is_gcd_refl.

  Fact is_gcd_0 p q : is_gcd p q 0 -> p = 0 /\ q = 0.

  Fact is_gcd_rel_prime p q g : is_gcd p q g -> exists a b, p = a*g /\ q = b*g /\ is_gcd a b 1.

  Fact is_lcm_mult p q l k : is_lcm p q l -> is_lcm (k*p) (k*q) (k*l).

  Theorem is_gcd_lcm_mult p q g l : is_gcd p q g -> is_lcm p q l -> p*q = g*l.

  Theorem is_gcd_mult_lcm p q g l : g <> 0 -> is_gcd p q g -> g*l = p*q -> is_lcm p q l.

  Lemma is_lcm_minus p q g l u : p <= q -> p = u*g -> is_gcd p q g -> is_lcm p q l -> is_lcm p (q-p) (l-u*p).

  Lemma is_lcm_modulus k p q g l u : k*p <= q -> p = u*g -> is_gcd p q g -> is_lcm p q l -> is_lcm p (q-k*p) (l-k*u*p).

  Lemma is_lcm_plus p q g l u : p = u*g -> is_gcd p q g -> is_lcm p q l -> is_lcm p (q+p) (l+u*p).

  Lemma is_lcm_moduplus k p q g l u : p = u*g -> is_gcd p q g -> is_lcm p q l -> is_lcm p (q+k*p) (l+k*u*p).

  Section bezout_generalized.

    Let bezout_rec p q : 0 < p < q 
                      -> { a : nat 
                       & { b : nat 
                       & { g : nat
                       & { l : nat 
                       & { u : nat
                       & { v : nat
                         | a*p+b*q = g + l
                        /\ is_gcd p q g
                        /\ is_lcm p q l
                        /\ p = u*g
                        /\ q = v*g
                        /\ a <= v
                        /\ b <= u } } } } } }.
  
    Hint Resolve is_gcd_sym is_lcm_sym.

    Definition bezout_generalized p q : { a : nat 
                                      & { b : nat 
                                      & { g : nat
                                      & { l : nat 
                                        | a*p+b*q = g + l
                                       /\ is_gcd p q g
                                       /\ is_lcm p q l } } } }.

  End bezout_generalized.

  Section gcd_lcm.

    Let gcd_full p q : sig (is_gcd p q).

    Definition gcd p q := proj1_sig (gcd_full p q).
    Fact gcd_spec p q : is_gcd p q (gcd p q).

    Let lcm_full p q : sig (is_lcm p q).

    Definition lcm p q := proj1_sig (lcm_full p q).
    Fact lcm_spec p q : is_lcm p q (lcm p q).

  End gcd_lcm.
     
End bezout.

Require Import Extraction.
Extraction Inline measure_rect.

Check bezout_generalized.
Print Assumptions bezout_generalized.

Section division.

  Fact div_full q p : { n : nat & { r | q = n*p+r /\ (p <> 0 -> r < p) } }.

  Definition div q p := projT1 (div_full q p).
  Definition rem q p := proj1_sig (projT2 (div_full q p)).

  Fact div_rem_spec1 q p : q = div q p * p + rem q p.

  Fact div_rem_spec2 q p : p <> 0 -> rem q p < p.

  Fact rem_0 q : rem q 0 = q.

  Fact div_rem_uniq p n1 r1 n2 r2 : 
        p <> 0 -> n1*p + r1 = n2*p + r2 -> r1 < p -> r2 < p -> n1 = n2 /\ r1 = r2.

  Fact div_prop q p n r : q = n*p+r -> r < p -> div q p = n.

  Fact rem_prop q p n r : q = n*p+r -> r < p -> rem q p = r.

  Fact rem_idem q p : q < p -> rem q p = q.

  Fact is_gcd_rem p n a : is_gcd p n a <-> is_gcd p (rem n p) a.

  Fact rem_erase q n p r : q = n*p+r -> rem q p = rem r p.

  Fact divides_div q p : divides p q -> q = div q p * p.

  Fact divides_rem_eq q p : divides p q <-> rem q p = 0.

  Fact rem_of_0 p : rem 0 p = 0.

  Hint Resolve divides_0_inv.

  Fact divides_dec q p : { k | q = k*p } + { ~ divides p q }.

End division.

Section rem.

  Variable (p : nat) (Hp : p <> 0).

  Fact rem_plus_rem a b : rem (a+rem b p) p = rem (a+b) p.

  Fact rem_mult_rem a b : rem (a*rem b p) p = rem (a*b) p.

  Fact rem_diag : rem p p = 0.

  Fact rem_lt a : a < p -> rem a p = a.

  Fact rem_plus a b : rem (a+b) p = rem (rem a p + rem b p) p.

  Fact rem_scal k a : rem (k*a) p = rem (k*rem a p) p.

  Fact rem_plus_div a b : divides p b -> rem a p = rem (a+b) p.

  Fact div_eq_0 n : n < p -> div n p = 0.

  Fact div_of_0 : div 0 p = 0.

  Fact div_ge_1 n : p <= n -> 1 <= div n p.

End rem.

Fact div_by_p_lt p n : 2 <= p -> n <> 0 -> div n p < n.

Section rem_2.

  Fact rem_2_is_0_or_1 x : rem x 2 = 0 \/ rem x 2 = 1.

  Fact rem_2_mult x y : rem (x*y) 2 = 1 <-> rem x 2 = 1 /\ rem y 2 = 1.

  Fact rem_2_fix_0 : rem 0 2 = 0.

  Fact rem_2_fix_1 n : rem (2*n) 2 = 0.

  Fact rem_2_fix_2 n : rem (1+2*n) 2 = 1.

  Fact rem_2_lt n : rem n 2 < 2.

  Fact div_2_fix_0 : div 0 2 = 0.

  Fact div_2_fix_1 n : div (2*n) 2 = n.

  Fact div_2_fix_2 n : div (1+2*n) 2 = n.

  Fact euclid_2_div n : n = rem n 2 + 2*div n 2 /\ (rem n 2 = 0 \/ rem n 2 = 1).

  Fact euclid_2 n : exists q, n = 2*q \/ n = 1+2*q.

End rem_2.

Local Hint Resolve divides_mult divides_mult_r divides_refl.

Theorem CRT u v a b : u <> 0 -> v <> 0 -> is_gcd u v 1 -> exists w, rem w u = rem a u /\ rem w v = rem b v /\ 2 < w. *)
(* prime:
Require Import List Arith Omega Permutation.

Require Import utils_tac utils_list utils_nat gcd sums.

Set Implicit Arguments.

Section prime.

  Hint Resolve divides_0 divides_mult divides_refl divides_0_inv.

  Infix "<d" := divides (at level 70, no associativity).

  Definition prime p := p <> 1 /\ forall q, q <d p -> q = 1 \/ q = p.

  Fact prime_2 : prime 2.

  Fact prime_ge_2 p : prime p -> 2 <= p.

  Fact prime_gcd p q : prime p -> is_gcd p q 1 \/ p <d q.

  Fact prime_div_mult p x y : prime p -> p <d x*y -> p <d x \/ p <d y. 

  Definition prime_or_div p : 2 <= p -> { q | 2 <= q < p /\ q <d p } + { prime p }.

  Theorem prime_factor n : 2 <= n -> { p | prime p /\ p <d n }.

  Section prime_rect.

    Variables (P : nat -> Type)
              (HP0 : P 0)
              (HP1 : P 1)
              (HPp : forall p, prime p -> P p)
              (HPm : forall x y, P x -> P y -> P (x*y)).

    Theorem prime_rect n : P n.

  End prime_rect.

  Corollary no_common_prime_is_coprime x y : x <> 0 -> (forall p, prime p -> p <d x -> p <d y -> False) -> is_gcd x y 1.

  Fact is_rel_prime_mult p q l : is_gcd p q 1 -> is_gcd p l 1 -> is_gcd p (q*l) 1.

  Fact is_rel_prime_expo p q l : is_gcd p q 1 -> is_gcd p (mscal mult 1 l q) 1.

  Notation lprod := (fold_right mult 1).

  Fact lprod_ge_1 l : Forall prime l -> 1 <= lprod l.

  Fact lprod_app l m : lprod (l++m) = lprod l * lprod m.

  Theorem prime_decomp n : n <> 0 -> { l | n = lprod l /\ Forall prime l }.

  Hint Resolve lprod_ge_1 prime_ge_2.

  Fact prime_in_decomp p l : prime p -> Forall prime l -> p <d lprod l -> In p l.

  Theorem prime_decomp_uniq l m : Forall prime l -> Forall prime m -> lprod l = lprod m -> l ~p m.

End prime.

Section base_decomp.

  Fixpoint expand p l :=
    match l with
      | nil  => 0
      | x::l => x+p*expand p l
    end.

  Notation power := (mscal mult 1).

  Fact expand_app p l m : expand p (l++m) = expand p l + power (length l) p * expand p m.

  Fact expand_0 p l : Forall (eq 0) l -> expand p l = 0.

  Section base_p.

    Variables (p : nat) (Hp : 2 <= p).

    Let base_p_full n : { l | n = expand p l }.

    Definition base_p n := proj1_sig (base_p_full n).
    Fact base_p_spec n : n = expand p (base_p n).

    Fact base_p_uniq l1 l2 : Forall2 (fun x y => x < p /\ y < p) l1 l2 -> expand p l1 = expand p l2 -> l1 = l2.

  End base_p.

End base_decomp. *)
(* binomial:
Require Import Arith Omega.

Require Import utils_tac gcd.

Set Implicit Arguments.

Section factorial.

  Fixpoint fact n := match n with 0 => 1 | S n => (S n) * fact n end.

  Fact fact_0 : fact 0 = 1.

  Fact fact_S n : fact (S n) = (S n)*fact n.

  Fact fact_gt_0 n : 0 < fact n.

End factorial.

Section binomial.

  Infix "<d" := divides (at level 70, no associativity).

  Hint Resolve divides_refl.

  Let fact_neq_0 n : fact n <> 0.

  Fixpoint binomial n p :=
    match n, p with
      | n, 0     => 1
      | 0, S _   => 0
      | S n, S p => binomial n p + binomial n (S p)
    end.

  Fact binomial_n0 n : binomial n 0 = 1.

  Fact binomial_SS n p : binomial (S n) (S p) = binomial n p + binomial n (S p).

  Fact binomial_n1 n : 1 <= n -> binomial n 1 = n.

  Fact binomial_gt n : forall p, n < p -> binomial n p = 0.

  Fact binomial_nn n : binomial n n = 1.

  Theorem binomial_thm n p : p <= n -> fact n = binomial n p * fact p * fact (n-p).

  Fact binomial_le n p : p <= n -> binomial n p = div (fact n) (fact p * fact (n-p)).

  Fact binomial_sym n p : p <= n -> binomial n p = binomial n (n-p).

  Fact binomial_spec n p : p <= n -> fact n = binomial n p * fact p * fact (n-p).

  Fact binomial_0n n : 0 < n -> binomial 0 n = 0.

  Theorem binomial_pascal n p : binomial (S n) (S p) = binomial n p + binomial n (S p).

End binomial. *)
(* sums:
Require Import List Arith Omega Eqdep_dec ZArith.

Require Import utils_tac utils_list binomial.

Set Implicit Arguments.

Record monoid_theory (X : Type) (m : X -> X -> X) (u : X) := mk_monoid {
  monoid_unit_l : forall x, m u x = x;
  monoid_unit_r : forall x, m x u = x;
  monoid_assoc  : forall x y z, m x (m y z) = m (m x y) z;
}.

Fact Nat_plus_monoid : monoid_theory plus 0.

Fact Nat_mult_monoid : monoid_theory mult 1.

Fact Zplus_monoid : monoid_theory Zplus 0%Z.

Fact Zmult_monoid : monoid_theory Zmult 1%Z.

Hint Resolve Nat_plus_monoid Nat_mult_monoid
             Zplus_monoid Zmult_monoid.

Section msum.

  Variable (X : Type) (m : X -> X -> X) (u : X).

  Infix "⊕" := m (at level 50, left associativity).

  Fixpoint msum n f := 
    match n with 
      | 0   => u
      | S n => f 0 ⊕ msum n (fun n => f (S n))
    end.

  Notation "∑" := msum.

  Fact msum_fold_map n f : ∑ n f = fold_right m u (map f (list_an 0 n)).

  Fact msum_0 f : ∑ 0 f = u.

  Fact msum_S n f : ∑ (S n) f = f 0 ⊕ ∑ n (fun n => f (S n)).

  Hypothesis Hmonoid : monoid_theory m u.

  Fact msum_1 f : ∑ 1 f = f 0.

  Fact msum_plus a b f : ∑ (a+b) f = ∑ a f ⊕ ∑ b (fun i => f (a+i)).

  Fact msum_plus1 n f : ∑ (S n) f = ∑ n f ⊕ f n.

  Fact msum_ext n f g : (forall i, i < n -> f i = g i) -> ∑ n f = ∑ n g.

  Fact msum_unit n : ∑ n (fun _ => u) = u.

  Fact msum_comm a n f : (forall i, i < n -> f i ⊕ a = a ⊕ f i) -> ∑ n f ⊕ a = a ⊕ ∑ n f.

  Fact msum_sum n f g : (forall i j, i < j < n -> f j ⊕ g i = g i ⊕ f j) -> ∑ n (fun i => f i ⊕ g i) = ∑ n f ⊕ ∑ n g.

  Fact msum_of_unit n f : (forall i, i < n -> f i = u) -> ∑ n f = u.

  Fact msum_only_one n f i : i < n
                          -> (forall j, j < n -> i <> j -> f j = u)
                          -> ∑ n f = f i.

  Fact msum_msum n k f :
          (forall i1 j1 i2 j2, i1 < n -> j1 < k -> i2 < n -> j2 < k -> f i1 j1 ⊕ f i2 j2 = f i2 j2 ⊕ f i1 j1)
       -> ∑ n (fun i => ∑ k (f i)) = ∑ k (fun j => ∑ n (fun i => f i j)).

  Fact msum_ends n f : (forall i, 0 < i <= n -> f i = u) -> ∑ (n+2) f = f 0 ⊕ f (S n).

  Fact msum_first_two n f : 2 <= n -> (forall i, 2 <= i -> f i = u) -> ∑ n f = f 0 ⊕ f 1.

  Definition mscal n x := msum n (fun _ => x).

  Fact mscal_0 x : mscal 0 x = u.

  Fact mscal_S n x : mscal (S n) x = x ⊕ mscal n x.

  Fact mscal_1 x : mscal 1 x = x.

  Fact mscal_of_unit n : mscal n u = u.

  Fact mscal_plus a b x : mscal (a+b) x = mscal a x ⊕ mscal b x.

  Fact mscal_plus1 n x : mscal (S n) x = mscal n x ⊕ x.

  Fact mscal_comm n x y : x ⊕ y = y ⊕ x -> mscal n x ⊕ y = y ⊕ mscal n x.

  Fact mscal_sum n x y : x ⊕ y = y ⊕ x -> mscal n (x ⊕ y) = mscal n x ⊕ mscal n y.

  Fact mscal_mult a b x : mscal (a*b) x = mscal a (mscal b x).

  Fact msum_mscal n k f : (forall i j, i < n -> j < n -> f i ⊕ f j = f j ⊕ f i) 
                       -> ∑ n (fun i => mscal k (f i)) = mscal k (∑ n f).

End msum.

Section msum_morphism.

  Variable (X Y : Type) (m1 : X -> X -> X) (u1 : X) 
                        (m2 : Y -> Y -> Y) (u2 : Y)
           (H1 : monoid_theory m1 u1)
           (H2 : monoid_theory m2 u2)
           (phi : X -> Y)
           (Hphi1 : phi u1 = u2)
           (Hphi2 : forall x y, phi (m1 x y) = m2 (phi x) (phi y)).

  Fact msum_morph n f : phi (msum m1 u1 n f) = msum m2 u2 n (fun x => phi (f x)).

  Fact mscal_morph n x : phi (mscal m1 u1 n x) = mscal m2 u2 n (phi x).

End msum_morphism.

Section binomial_Newton.

  Variable (X : Type) (sum times : X -> X -> X) (zero one : X).

  Infix "⊕" := sum (at level 50, left associativity).
  Infix "⊗" := times (at level 40, left associativity).
  
  Notation z := zero.
  Notation o := one.

  Notation scal := (mscal sum zero).
  Notation expo := (mscal times one).

  Hypothesis (M_sum : monoid_theory sum zero) 
             (sum_comm : forall x y, x ⊕ y = y ⊕ x)
             (sum_cancel : forall x u v, x ⊕ u = x ⊕ v -> u = v)
             (M_times : monoid_theory times one)
             (distr_l : forall x y z, x ⊗ (y⊕z) = x⊗y ⊕ x⊗z)
             (distr_r : forall x y z, (y⊕z) ⊗ x = y⊗x ⊕ z⊗x).

  Fact times_zero_l x : z ⊗ x = z.

  Fact times_zero_r x : x ⊗ z = z.

  Notation "∑" := (msum sum zero).

  Fact sum_0n_scal n k f : ∑ n (fun i => scal k (f i)) = scal k (∑ n f).

  Fact scal_times k x y : scal k (x⊗y) = x⊗scal k y.

  Fact scal_one_comm k x : scal k o ⊗ x = x ⊗ scal k o.

  Corollary scal_one k x : scal k x = scal k o ⊗ x.

  Fact sum_0n_distr_l b n f : ∑ n (fun i => b⊗f i) = b⊗∑ n f.

  Fact sum_0n_distr_r b n f : ∑ n (fun i => f i⊗b) = ∑ n f ⊗ b.

  Theorem binomial_Newton n a b :
        a ⊗ b = b ⊗ a
     -> expo n (a ⊕ b) = ∑ (S n) (fun i => scal (binomial n i) (expo (n - i) a ⊗ expo i b)).

End binomial_Newton.

Section Newton_nat.

  Notation power := (mscal mult 1).
  Notation "∑" := (msum plus 0).

  Fact sum_fold_map n f : ∑ n f = fold_right plus 0 (map f (list_an 0 n)).

  Fact power_0 x : power 0 x = 1.

  Fact power_S n x : power (S n) x = x * power n x.

  Fact power_1 x : power 1 x = x.

  Fact power_of_0 n : 0 < n -> power n 0 = 0.

  Fact power_of_1 n : power n 1 = 1.

  Fact power_plus p a b : power (a+b) p = power a p * power b p.

  Fact power_mult p a b : power (a*b) p = power a (power b p).
  
  Fact power_ge_1 k p : p <> 0 -> 1 <= power k p.

  Fact power2_gt_0 n : 0 < power n 2.

  Fact power_sinc k p : 2 <= p -> power k p < power (S k) p.

  Fact power_ge_n k p : 2 <= p -> k <= power k p.

  Fact power_mono_l p q x : 1 <= x -> p <= q -> power p x <= power q x.

  Definition power_mono := power_mono_l.
  
  Fact power_smono_l p q x : 2 <= x -> p < q -> power p x < power q x.

  Fact power_mono_r n p q : p <= q -> power n p <= power n q.

  Fact power_0_inv p n : power p n = 0 <-> n = 0 /\ 0 < p.

  Fact plus_cancel_l : forall a b c, a + b = a + c -> b = c.

  Let plus_cancel_l':= plus_cancel_l.

  Fact sum_0n_scal_l n k f : ∑ n (fun i => k*f i) = k*∑ n f.

  Fact sum_0n_scal_r n k f : ∑ n (fun i => (f i)*k) = (∑ n f)*k.

  Fact sum_0n_mono n f g : (forall i, i < n -> f i <= g i) -> ∑ n f <= ∑ n g.

  Fact sum_0n_le_one n f i : i < n -> f i <= ∑ n f.

  Fact sum_power_lt k n f : k <> 0 -> (forall i, i < n -> f i < k) -> ∑ n (fun i => f i * power i k) < power n k.

  Theorem Newton_nat a b n :
       power n (a + b) = ∑ (S n) (fun i => binomial n i * power (n - i) a * power i b).

  Theorem Newton_nat_S a n :
       power n (1 + a) = ∑ (S n) (fun i => binomial n i * power i a).

  Lemma binomial_le_power n i : binomial n i <= power n 2.

  Corollary binomial_lt_power n i : binomial n i < power (S n) 2.

End Newton_nat. *)
(* Zp:
Require Import Arith Omega Eqdep_dec ZArith List Permutation.

Require Import utils_tac utils_list gcd prime binomial sums matrix php.

Set Implicit Arguments.

Section le_pirr.

  Scheme le_indd := Induction for le Sort Prop.

  Fact le_pirr : forall x y (H1 H2 : x <= y), H1 = H2.

End le_pirr.

Fact lt_pirr x y (H1 H2 : x < y) : H1 = H2.

Fact Zring : ring_theory 0%Z 1%Z Zplus Zmult Zminus Z.opp eq.

Hint Resolve Zring Zplus_monoid Zmult_monoid.

Section Z_coprime.

  Open Scope Z_scope.

  Definition Z_pos_or_neg u : { 0 <= u } + { u < 0 }.

  Fact Z_coprime u v : (exists a b, a * Z.of_nat u + b*Z.of_nat v = 1) -> is_gcd u v 1%nat.

End Z_coprime.

Section Zp.

  Variable (p : nat) (Hp : p <> 0).
 
  Definition Z_Zp := { x | x < p }.

  Implicit Type x y : Z_Zp.

  Fact Zp_inj : forall x y, proj1_sig x = proj1_sig y -> x = y.

  Definition Zp_plus : Z_Zp -> Z_Zp -> Z_Zp.

  Infix "⊕" := Zp_plus (at level 50, left associativity).
  
  Definition Zp_zero : Z_Zp.

  Definition Zp_opp : Z_Zp -> Z_Zp.

  Notation "∸" := Zp_opp.

  Definition Zp_mult : Z_Zp -> Z_Zp -> Z_Zp.

  Infix "⊗" := Zp_mult (at level 40, left associativity).

  Definition Zp_one : Z_Zp.

  Notation Zp := Zp_zero.
  Notation Op := Zp_one.

  Fact Zp_plus_zero : forall x, Zp ⊕ x = x.

  Fact Zp_plus_comm : forall x y,  x ⊕ y = y ⊕ x.

  Fact Zp_plus_assoc : forall x y z, x ⊕ (y ⊕ z) = x ⊕ y ⊕ z.

  Fact Zp_minus : forall x, x ⊕ ∸ x = Zp.

  Fact Zp_mult_one : forall x, Op ⊗ x = x.

  Fact Zp_mult_comm : forall x y, x ⊗ y = y ⊗ x.

  Fact Zp_mult_one_r x : x ⊗ Op = x.

  Fact Zp_mult_assoc : forall x y z, x ⊗ (y ⊗ z) = x ⊗ y ⊗ z.

  Fact Zp_mult_plus_distr_l : forall x y z, x ⊗ (y ⊕ z) = x ⊗ y ⊕ x ⊗ z.

  Fact Zp_mult_plus_distr_r x y z : (y ⊕ z) ⊗ x = y ⊗ x ⊕ z ⊗ x.

  Definition Zp_is_ring : @ring_theory _ Zp Op Zp_plus Zp_mult (fun x y => x ⊕ ∸ y) Zp_opp eq.

  Fact Zp_mult_invert : forall x, is_gcd p (proj1_sig x) 1 -> { i | i ⊗ x = Op }.

  Fact Zp_mult_revert : forall x i, i ⊗ x = Op -> is_gcd p (proj1_sig x) 1.

  Definition Zp_invertible x := exists i, i ⊗ x = Op.

  Fact Zp_invertible_spec x : Zp_invertible x <-> is_gcd p (proj1_sig x) 1.

  Fact Zp_prime_invert : prime p -> forall x, x <> Zp -> { i | i ⊗ x = Op }.

  Add Ring Zp_ring : Zp_is_ring.

  Fact Zp_plus_monoid : monoid_theory Zp_plus Zp_zero.

  Fact Zp_mult_monoid : monoid_theory Zp_mult Zp_one.

  Fact Zp_one_invertible : Zp_invertible Op.

  Fact Zp_opp_invertible x : Zp_invertible x <-> Zp_invertible (∸ x).

  Fact Zp_mult_invertible x y : Zp_invertible x -> Zp_invertible y -> Zp_invertible (x ⊗ y).

  Hint Resolve Zp_one_invertible Zp_opp_invertible Zp_mult_invertible.

  Fact Zp_expo_invertible n x : Zp_invertible x -> Zp_invertible (mscal Zp_mult Op n x).

  Fact Zp_invertible_cancel_l x y z : Zp_invertible x -> x⊗y = x⊗z -> y = z.

  Fact Zp_opp_zero : ∸ Zp = Zp.

  Fact Zp_plus_inj_l x y z : x ⊕ y = x ⊕ z -> y = z.

  Fact Zp_plus_zero_r x : x ⊕ Zp = x.

  Fact Zp_opp_inv x : ∸ (∸ x) = x.

  Fact Zp_opp_inj x y : ∸ x = ∸ y -> x = y.

  Fact Zp_opp_plus x y : ∸ (x ⊕ y) = ∸ x ⊕ ∸ y.
 
  Fact Zp_opp_plus_eq x y z : x ⊕ y = z <-> x = z ⊕ ∸ y.

  Fact Zp_mult_zero x : Zp ⊗ x = Zp.

  Fact Zp_mult_minus_one x : (∸ Op) ⊗ x = ∸ x.

  Fact Zp_opp_mult x y : (∸ x) ⊗ y = ∸ (x ⊗ y).

  Fact Zp_invertible_eq_zero x y : Zp_invertible x -> x ⊗ y = Zp -> y = Zp.

  Fact Zp_zero_is_one : Zp = Op <-> p = 1.

  Fact Zp_eq_dec : forall x y : Z_Zp, { x = y } + { x <> y }.

  Section nat2Zp.

    Definition nat2Zp (u : nat) : Z_Zp.

    Arguments nat2Zp u /.

    Notation "〚 x 〛" := (nat2Zp x).

    Fact nat2Zp_zero : 〚0〛= Zp.

    Fact nat2Zp_one : 〚1〛= Op.

    Fact nat2Zp_invertible n : Zp_invertible 〚n〛 <-> is_gcd p n 1.

    Fact nat2Zp_p :〚p〛= Zp.

    Fact nat2Zp_inj u v : 〚u〛=〚v〛 <-> rem u p = rem v p.

    Fact nat2Zp_surj u : { x | x < p /\ u = 〚x〛 }.

    Fact nat2Zp_plus u v : 〚u+v〛=〚u〛⊕〚v〛.

    Fact nat2Zp_minus u v : v <= u -> 〚u-v〛=〚u〛⊕ ∸〚v〛.

    Fact nat2Zp_minus_one : 〚p-1〛= ∸Op.

    Fact nat2Zp_mult u v :〚u*v〛=〚u〛⊗〚v〛.

    Fact nat2Zp_expo n u : 〚mscal mult 1%nat n u〛 = mscal Zp_mult Zp_one n 〚u〛.

    Fact nat2Zp_divides u v :〚u〛=〚v〛-> divides p u -> divides p v.

    Fact divides_nat2Zp u : divides p u <-> 〚u〛= Zp.

  End nat2Zp.

  Arguments nat2Zp u /.

  Definition Zp_list := map nat2Zp (list_an 0 p).
  
  Fact Zp_list_spec x : In x Zp_list.

  Fact Zp_list_length : length Zp_list = p.

  Fact Zp_invertible_prime x : prime p -> Zp_invertible x <-> x <> Zp.
 
  Fact Zp_prime_integral x y : prime p -> x ⊗ y = Zp -> x = Zp \/ y = Zp.

  Fact Zp_prime_square_eq_square x y : prime p -> x⊗x = y⊗y <-> x = y \/ x = ∸y.

  Fact Zp_prime_square_one x : prime p -> x⊗x = Op <-> x = Op \/ x = ∸Op.

  Section Z2Zp.

    Open Scope Z_scope.

    Implicit Types u v w : Z.

    Definition Z2Zp u : Z_Zp.

    Arguments Z2Zp u /.

    Notation "〘 x 〙" := (Z2Zp x).
    Notation "〚 x 〛" := (nat2Zp x).

    Fact Z2Zp_pos u : 0 <= u -> 〘u〙= 〚Z.to_nat u〛.

    Fact Z2Zp_of_nat n : 〘Z.of_nat n〙 = 〚n〛.

    Fact Z2Zp_zero : 〘0〙= Zp.

    Fact Z2Zp_neg u : u <= 0 -> 〘u〙 = ∸〘-u〙.

    Section Z2Zp_plus.

      Let Z2Zp_plus_loc u v : u <= 0 -> 0 <= v -> -u <= v -> 〘u+v〙=〘u〙⊕〘v〙.

      Let Z2Zp_plus_loc' u v : u <= 0 -> 0 <= v -> v <= -u -> 〘u+v〙=〘u〙⊕〘v〙.

      Fact Z2Zp_plus u v : 〘u+v〙=〘u〙⊕〘v〙.

    End Z2Zp_plus.

    Fact Z2Zp_opp u :〘-u〙= ∸〘u〙.

    Fact Z2Zp_minus u v : 〘u-v〙 = 〘u〙⊕ ∸〘v〙.

    Section Z2Zp_mult.
  
      Let Z2Zp_mult_loc u v : 0 <= u -> 0 <= v -> 〘u*v〙=〘u〙⊗〘v〙.

      Fact Z2Zp_mult u v : 〘u*v〙=〘u〙⊗〘v〙.

    End Z2Zp_mult.

    Fact Z2Zp_one : 〘1〙 = Op.

    Section Z2Zp_inj.

      Let Z2Zp_inj_loc u v : v <= u ->〘u〙=〘v〙-> exists i, u-v = i*Z.of_nat p.
      
      Fact Z2Zp_inj u v :〘u〙=〘v〙<-> exists i, u-v = i*Z.of_nat p.

    End Z2Zp_inj.

    Fact nat2Zp_choose : forall x, x = Zp \/ x = Op \/ x = ∸ Op \/ exists m,  (1 < m < p-1)%nat /\〚m〛= x.

    Section prime.

      Hypothesis Hp' : prime p.

      Fact nat2Zp_invertible_prime n : (0 < n < p)%nat -> Zp_invertible 〚n〛.

      Let Hp'' : (2 <= p)%nat.

      Let Hzero_one : Zp <> Op.

      Fact Zp_invertible_factorial n : (n < p)%nat -> Zp_invertible 〚fact n〛.

      Section inv.

        Let Zp_invert_full x : { i | (x = Zp -> i = Zp) /\ (x <> Zp -> i ⊗ x = Op) }.

        Definition Zp_invert x := proj1_sig (Zp_invert_full x).

        Fact Zp_invert_spec1 : Zp_invert Zp = Zp.

        Fact Zp_invert_spec2 x : x <> Zp -> Zp_invert x ⊗ x = Op.

      End inv.

      Notation inv := Zp_invert.

      Fact Zp_invert_eq_not_zero x y : x <> Zp -> inv x = y <-> y ⊗ x = Op.

      Fact Zp_invert_opp x : inv (∸x) = ∸(inv x).

      Fact Zp_invert_one : inv Op = Op.
  
      Fact Zp_invert_minus_one : inv (∸ Op) = ∸ Op.

      Fact Zp_invert_fix x : inv x = x <-> x = Zp \/ x = Op \/ x = ∸ Op.

      Fact Zp_invert_involutive x : inv (inv x) = x.

      Fact Zp_invert_not_fix n : (1 < n < p-1)%nat -> inv〚n〛<>〚n〛.

      Fact Zp_invert_stable n : (1 < n < p-1)%nat -> exists m, (1 < m < p-1)%nat /\〚m〛= inv〚n〛.

      Definition Zp_lprod := fold_right Zp_mult Zp_one.

      Fact Zp_lprod_nil : Zp_lprod nil = Op.

      Fact Zp_lprod_cons x l : Zp_lprod (x::l) = x ⊗ Zp_lprod l.
   
      Fact Zp_lprod_app l m : Zp_lprod (l++m) = Zp_lprod l ⊗  Zp_lprod m.

      Theorem Zp_mult_autoinv l : ~ list_has_dup l -> (forall x, In x l -> x <> Zp /\ inv x <> x /\ In (inv x) l) -> Zp_lprod l = Op.

      Fact Zp_lprod_fact n : 〚fact (S n)〛= Zp_lprod (map nat2Zp (list_an 2 n)).

      Theorem Wilson_thm_1 :〚fact (p-1)〛= ∸Op.

    End prime.

    Fact Zp_divides_and_invertible d k n i : (d * k = n)%nat ->〚i〛⊗〚d〛= Op ->〚k〛=〚i〛⊗〚n〛.

  End Z2Zp.

End Zp.

Fact divides_not_0_interval p q : q <> 0 -> divides p q -> 1 <= p <= q.

Fact divides_fact_lt q n : 1 <= q <= n -> divides q (fact n).

Theorem Wilson_theorem p : 2 <= p -> prime p <-> divides p (fact (p-1)+1).

Check Wilson_theorem.
Print Assumptions Wilson_theorem.

Section Z2Zp_morphishm.

  Variable (p : nat) (Hp : p <> 0).

  Fact Z2Zp_morphishm : ring_morphism 0%Z 1%Z Zplus Zmult Z.opp 

End Z2Zp_morphishm. *)
(* rel_iter:
Require Import Arith Nat Omega.
Require Import utils_tac gcd prime binomial sums.

Set Implicit Arguments.

Section rel_iter.

  Variable (X : Type) (R : X -> X -> Prop).

  Fixpoint rel_iter n :=
    match n with
      | 0   => eq
      | S n => fun x z => exists y, R x y /\ rel_iter n y z
    end.

  Fact rel_iter_plus n m x y : rel_iter (n+m) x y <-> exists a, rel_iter n x a /\ rel_iter m a y.

  Fact rel_iter_1 x y : rel_iter 1 x y <-> R x y.

  Fact rel_iter_S n x y : rel_iter (S n) x y <-> exists a, rel_iter n x a /\ R a y.

  Fact rel_iter_sequence n x y : rel_iter n x y <-> exists f, f 0 = x /\ f n = y /\ forall i, i < n -> R (f i) (f (S i)).

End rel_iter.

Local Notation power := (mscal mult 1).

Definition is_digit c q i y := y < q /\ exists a b, c = (a*q+y)*power i q+b /\ b < power i q.

Fact is_digit_fun c q i x y : is_digit c q i x -> is_digit c q i y -> x = y.

Definition is_seq (R : nat -> nat -> Prop) c q n := forall i, i < n -> exists y y', is_digit c q i y /\ is_digit c q (1+i) y' /\ R y y'.

Section rel_iter_bound.

  Variable (R : nat -> nat -> Prop) (k : nat) (Hk1 : forall x y, R x y -> y <= k*x).

  Let Hk' : forall x y, R x y -> y <= (S k)*x.

  Definition rel_iter_bound n x y := exists q c, x*power n (S k) < q /\ is_seq R c q n /\ is_digit c q 0 x /\ is_digit c q n y.

  Lemma rel_iter_bound_iter n x y : rel_iter_bound n x y -> rel_iter R n x y.

  Notation power := (mscal mult 1).
  Notation "∑" := (msum plus 0).

  Lemma rel_iter_iter_bound n x y : rel_iter R n x y -> rel_iter_bound n x y.

  Hint Resolve rel_iter_bound_iter rel_iter_iter_bound.

  Theorem rel_iter_bound_equiv n x y : rel_iter R n x y <-> rel_iter_bound n x y.

End rel_iter_bound.

Section rel_iter_seq.

  Variable (R : nat -> nat -> Prop).

  Definition rel_iter_seq n x y := exists q c, is_seq R c q n /\ is_digit c q 0 x /\ is_digit c q n y.

  Lemma rel_iter_seq_iter n x y : rel_iter_seq n x y -> rel_iter R n x y.

  Notation power := (mscal mult 1).
  Notation "∑" := (msum plus 0).

  Lemma rel_iter_iter_seq n x y : rel_iter R n x y -> rel_iter_seq n x y.

  Hint Resolve rel_iter_seq_iter rel_iter_iter_seq.

  Theorem rel_iter_seq_equiv n x y : rel_iter R n x y <-> rel_iter_seq n x y.

End rel_iter_seq. *)



Set Implicit Arguments.



Local Notation power := (mscal mult 1).

Local Notation expo := (mscal mult 1).



Section fact.



  Let factorial_cancel n a b : fact n * a = fact n * b -> a = b.

  Proof.

    apply Nat.mul_cancel_l.

    generalize (fact_gt_0 n); intro; lia.

  Qed.

  

  Notation Π := (msum mult 1).



  Notation mprod_an := (fun a n => Π n (fun i => i+a)).



  Fact mprod_factorial n : fact n = mprod_an 1 n.

  Proof.

    induction n as [ | n IHn ].

    + rewrite msum_0; auto.

    + rewrite msum_plus1; auto.

      rewrite mult_comm, <- IHn, fact_S.

      f_equal; lia.

  Qed.



  Variable (p : nat) (Hp : p <> 0).



  Notation "〚 x 〛" := (nat2Zp Hp x).



  Let expo_p_cancel n a b : expo n p * a = expo n p * b -> a = b.

  Proof.

    apply Nat.mul_cancel_l.

    generalize (power_ge_1 n Hp); intros; lia.

  Qed.



  Fact mprod_factorial_Zp i n :〚mprod_an (i*p+1) n〛=〚fact n〛.

  Proof.

    rewrite mprod_factorial.

    induction n as [ | n IHn ].

    + do 2 rewrite msum_0; auto.

    + do 2 (rewrite msum_plus1; auto).

      do 2 rewrite nat2Zp_mult; f_equal; auto.

      apply nat2Zp_inj.

      rewrite (plus_comm n), <- plus_assoc, plus_comm.

      rewrite <- rem_plus_div; auto.

      * f_equal; lia.

      * apply divides_mult, divides_refl.

  Qed.



  Notation φ := (fun n r => mprod_an (n*p+1) r).

  Notation Ψ := (fun n => Π n (fun i => mprod_an (i*p+1) (p-1))).



  Let phi_Zp_eq n r :〚φ n r〛=〚fact r〛.

  Proof. apply mprod_factorial_Zp. Qed.



  Fact mprod_factorial_mult n : fact (n*p) = expo n p * fact n * Ψ n.

  Proof.

    induction n as [ | n IHn ].

    + rewrite Nat.mul_0_l, msum_0, mscal_0, fact_0; auto.

    + replace (S n*p) with (n*p+p) by ring.

      rewrite mprod_factorial, msum_plus, <- mprod_factorial; auto.

      replace p with (S (p-1)) at 2 by omega.

      rewrite msum_plus1; auto.

      rewrite <- plus_assoc.

      replace (p-1+1) with p by omega.

      replace (n*p+p) with ((S n)*p) by ring.

      rewrite mscal_S, fact_S, msum_S.

      rewrite IHn.

      repeat rewrite mult_assoc.

      rewrite (mult_comm _ p).

      repeat rewrite <- mult_assoc.

      do 2 f_equal.

      rewrite (mult_comm (S n)).

      repeat rewrite <- mult_assoc; f_equal.

      repeat rewrite mult_assoc; f_equal.

      rewrite msum_ext with (f := fun i => n*p+i+1)

                            (g := fun i => i+(n*p+1)).

      2: intros; ring. 

      rewrite <- msum_plus1; auto.

  Qed.

 

  Lemma mprod_factorial_euclid n r : fact (n*p+r) = expo n p * fact n * φ n r * Ψ n.

  Proof.

    rewrite mprod_factorial, msum_plus; auto.

    rewrite <- mprod_factorial.

    rewrite msum_ext with (f := fun i => n*p+i+1)

                          (g := fun i => i+(n*p+1)).

    2: intros; ring. 

    rewrite mprod_factorial_mult; auto; ring.

  Qed.



  Notation Zp := (Zp_zero Hp).

  Notation Op := (Zp_one Hp).

  Notation "∸" := (Zp_opp Hp).

  Infix "⊗" := (Zp_mult Hp) (at level 40, left associativity).

  Notation expoZp := (mscal (Zp_mult Hp) (Zp_one Hp)).



  Hint Resolve Nat_mult_monoid.



  Let Psi_Zp_eq n :〚Ψ n〛= expoZp n〚fact (p-1)〛.

  Proof.

    induction n as [ | n IHn ].

    + rewrite msum_0, mscal_0; auto.

    + rewrite msum_plus1, nat2Zp_mult.

      rewrite mscal_plus1; auto.

      2: apply Zp_mult_monoid.

      2: apply Nat_mult_monoid.

      f_equal; auto.

  Qed.



  Hypothesis (Hprime : prime p).



  Let phi_Zp_invertible n r : r < p -> Zp_invertible Hp 〚φ n r〛.

  Proof.

    intros H; simpl; rewrite phi_Zp_eq.

    apply Zp_invertible_factorial; auto.

  Qed.



  Let Psi_Zp_invertible n : Zp_invertible Hp 〚Ψ n〛.

  Proof.

    simpl; rewrite (Psi_Zp_eq n).

    apply Zp_expo_invertible, Zp_invertible_factorial; auto; omega.

  Qed.



  Section binomial_without_p_not_zero.



    Variable (n N n0 k K k0 : nat) (Hn : n = N*p+n0) (Hk : k = K*p+k0) (H1 : K <= N) (H2 : k0 <= n0).



    Let Hkn : k <= n.

    Proof.

      rewrite Hn, Hk.

      replace N with (K+(N-K)) by omega.

      rewrite Nat.mul_add_distr_r.

      generalize ((N-K)*p); intros; omega.

    Qed.

   

    Let Hnk : n - k = (N-K)*p+(n0-k0).

    Proof.

      rewrite Hn, Hk, Nat.mul_sub_distr_r.

      cut (K*p <= N*p).

      + generalize (K*p) (N*p); intros; omega.

      + apply mult_le_compat; auto.

    Qed.

  

    Fact binomial_wo_p : φ K k0 * Ψ K * φ (N-K) (n0-k0) * Ψ (N-K) * binomial n k 

                       = binomial N K * φ N n0 * Ψ N.

    Proof.

      apply (factorial_cancel (N-K)); repeat rewrite mult_assoc.

      rewrite (mult_comm (fact _) (binomial _ _)).

      apply (factorial_cancel K); repeat rewrite mult_assoc.

      rewrite (mult_comm (fact _) (binomial _ _)).

      rewrite <- binomial_thm; auto.

      apply expo_p_cancel with N.

      repeat rewrite mult_assoc.

      rewrite <- mprod_factorial_euclid, <- Hn.

      rewrite binomial_thm with (1 := Hkn).

      rewrite Hnk. 

      rewrite Hk at 3.

      replace N with (K+(N-K)) at 1 by omega.

      rewrite power_plus.

      do 2 rewrite mprod_factorial_euclid.

      ring.

    Qed.



    Hypothesis (Hn0 : n0 < p).



    Hint Resolve Zp_mult_monoid.



    Fact binomial_Zp_prod :〚binomial n k〛=〚binomial N K〛⊗〚binomial n0 k0〛.

    Proof.

      generalize binomial_wo_p; intros G.

      apply f_equal with (f := nat2Zp Hp) in G.

      repeat rewrite nat2Zp_mult in G.

      repeat rewrite Psi_Zp_eq in G.

      repeat rewrite phi_Zp_eq in G.

      rewrite binomial_thm with (1 := H2) in G.

      repeat rewrite nat2Zp_mult in G.

      rewrite (Zp_mult_comm _ _〚 fact k0 〛) in G.

      repeat rewrite Zp_mult_assoc in G.

      rewrite (Zp_mult_comm _ _〚 fact k0 〛) in G.

      repeat rewrite <- Zp_mult_assoc in G.

      apply Zp_invertible_cancel_l in G.

      2: apply Zp_invertible_factorial; auto; omega.

      repeat rewrite Zp_mult_assoc in G.

      do 2 rewrite (Zp_mult_comm _ _〚 fact _ 〛) in G.

      repeat rewrite <- Zp_mult_assoc in G.

      apply Zp_invertible_cancel_l in G.

      2: apply Zp_invertible_factorial; auto; omega.

      repeat rewrite Zp_mult_assoc in G.

      rewrite <- mscal_plus in G; auto.

      replace (K+(N-K)) with N in G by omega.

      rewrite (Zp_mult_comm _ _ (expoZp _ _)) in G.

      apply Zp_invertible_cancel_l in G; trivial.

      apply Zp_expo_invertible, Zp_invertible_factorial; auto; omega.

    Qed.



  End binomial_without_p_not_zero.



  Section binomial_without_p_zero.



    Variable (n N n0 k K k0 : nat) (Hn : n = N*p+n0) (Hk : k = K*p+k0) 

             (H1 : K < N) (H2 : n0 < k0) (Hk0 : k0 < p).



    Let H3 : p - (k0-n0) < p.    Proof. omega. Qed.

    Let H4 : S (N-1) = N.        Proof. omega. Qed.

    Let H5 : N-1 = K+(N-(K+1)).  Proof. omega. Qed.

    Let H6 : N = K+1+(N-(K+1)).  Proof. omega. Qed.

    Let HNK : N-K = S (N-(K+1)). Proof. omega. Qed.



    Let Hkn : k <= n.

    Proof.

      rewrite Hn, Hk, H6.

      do 2 rewrite Nat.mul_add_distr_r.

      generalize ((N-(K+1))*p); clear H3 H4 H5 H6 HNK; intros; omega.

    Qed.

   

    Let Hnk : n - k = (N-(K+1))*p+(p-(k0-n0)).

    Proof.

      rewrite Hn, Hk, Nat.mul_sub_distr_r.

      cut ((K+1)*p <= N*p).

      + rewrite Nat.mul_add_distr_r.

        generalize (K*p) (N*p); clear H3 H4 H5 H6 HNK Hkn; intros; omega.

      + apply mult_le_compat; auto; clear H3 H4 H5 H6 HNK Hkn; omega.

    Qed.



    Fact binomial_with_p : fact K * fact (N-(K+1)) * φ K k0 * Ψ K * φ (N-(K+1)) (p-(k0-n0)) * Ψ (N-(K+1)) * binomial n k 

                         = p * fact N * φ N n0 * Ψ N.

    Proof.

      apply expo_p_cancel with (N-1).

      repeat rewrite mult_assoc.

      rewrite (mult_comm (expo _ _) p).

      rewrite <- mscal_S.

      rewrite H4, <- mprod_factorial_euclid, <- Hn.

      rewrite binomial_thm with (1 := Hkn).

      rewrite Hnk.

      rewrite Hk at 3.

      do 2 rewrite mprod_factorial_euclid.

      rewrite H5 at 1.

      rewrite power_plus.

      ring.

    Qed.



    Fact binomial_with_p' : φ K k0 * Ψ K * φ (N-(K+1)) (p-(k0-n0)) * Ψ (N-(K+1)) * binomial n k 

                          = p * binomial N K * (N-K) * φ N n0 * Ψ N.

    Proof.

      apply (factorial_cancel (N-(K+1))); repeat rewrite mult_assoc.

      apply (factorial_cancel K); repeat rewrite mult_assoc.

      rewrite binomial_with_p.

      rewrite binomial_thm with (n := N) (p := K).

      2: { apply lt_le_weak; auto. }

      rewrite HNK at 1.

      rewrite fact_S.

      rewrite <- HNK.

      ring.

    Qed.

 

    Fact binomial_Zp_zero :〚binomial n k〛= Zp.

    Proof.

      generalize binomial_with_p'; intros G.

      apply f_equal with (f := nat2Zp Hp) in G.

      repeat rewrite nat2Zp_mult in G.

      rewrite nat2Zp_p in G.

      repeat rewrite Zp_mult_zero in G.

      apply Zp_invertible_eq_zero in G; auto.

      repeat (apply Zp_mult_invertible; auto).

    Qed.



  End binomial_without_p_zero.



End fact.



Section lucas_lemma.



  Variables (p : nat) (Hprime : prime p).



  Let Hp : p <> 0.

  Proof.

    generalize (prime_ge_2 Hprime); intro; omega.

  Qed.



  Variables (n N n0 k K k0 : nat)

            (G1 : n = N*p+n0)  (G2 : n0 < p)

            (G3 : k = K*p+k0)  (G4 : k0 < p).



  Let choice : (K <= N  /\ k0 <= n0)

            \/ (n0 < k0 /\ K < N)

            \/ ((n0 < k0 \/ N < K) /\ n < k).

  Proof.

    destruct (le_lt_dec k n) as [ H0 | H0 ];

    destruct (le_lt_dec k0 n0) as [ H1 | H1 ];

    destruct (le_lt_dec K N) as [ H2 | H2 ]; try omega.

    + do 2 right; split; auto.

      rewrite G1, G3.

      replace K with (N+1+(K-N-1)) by omega.

      do 2 rewrite Nat.mul_add_distr_r.

      generalize ((K-N-1)*p); intros; omega.

    + destruct (eq_nat_dec N K); try omega.

      do 2 right; split; auto.

      rewrite G1, G3; subst N; omega.

    + do 2 right; split; auto.

      rewrite G1, G3.

      replace K with (N+1+(K-N-1)) by omega.

      do 2 rewrite Nat.mul_add_distr_r.

      generalize ((K-N-1)*p); intros; omega.

  Qed.



  Theorem lucas_lemma : rem (binomial n k) p = rem (binomial N K * binomial n0 k0) p.

  Proof.

    destruct choice as [ (H1 & H2) 

                     | [ (H1 & H2)

                       | (H1 & H2) ] ]; clear choice.

    3: { rewrite binomial_gt with (1 := H2).

         f_equal.

         destruct H1 as [ H1 | H1 ]; 

           rewrite binomial_gt with (1 := H1); ring. }

    + apply nat2Zp_inj with (Hp := Hp).

      rewrite nat2Zp_mult.

      apply binomial_Zp_prod; auto.

    + rewrite binomial_gt with (1 := H1).

      rewrite Nat.mul_0_r.

      apply nat2Zp_inj with (Hp := Hp).

      rewrite nat2Zp_zero.

      apply binomial_Zp_zero with (2 := G1) (3 := G3); auto.

  Qed.



End lucas_lemma.



Check lucas_lemma.

Print Assumptions lucas_lemma.

