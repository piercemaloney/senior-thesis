Require Import L Encodings DecidableRecognisable Markov Enumerable.
(* Encodings:
From Undecidability.L Require Export Tactics.

Fixpoint enc (n : nat) :=
  match n with
  | 0   => lambda(lambda (1))
  | S n => lambda(lambda ( 0 (enc n)))
  end.

Lemma enc_proc m :
  proc (enc m).

Hint Resolve enc_proc : cbv.

Lemma enc_injective m n : enc m = enc n -> m = n.

Lemma enc_inj m n : enc m ≡ enc n -> m = n.

Definition Zero : term := .\"z","s"; "z".
Definition Succ : term := .\"n","z","s"; "s" "n".

Hint Unfold Zero Succ : cbv.

Lemma Succ_correct n : Succ (enc n) ≻* enc (S n).

Definition Add  := Eval cbn in rho (.\ "a", "n", "m"; "n" "m" (.\"n"; !Succ ("a" "n" "m"))).

Hint Unfold Add : cbv.

Lemma Add_correct n m :
  Add (enc n) (enc m) ≡ enc (n + m).

Fixpoint tenc t :=
  lambda (  lambda (  lambda ( 
     match t with
       | var n => (var 2) (enc n)
       | app s t => (var 1) (tenc s) (tenc t)
       | lambda s => (var 0) (tenc s)
     end
  ))).

Lemma tenc_proc s : proc (tenc s).

Hint Resolve tenc_proc : cbv.

Lemma tenc_injective s t : tenc s = tenc t -> s = t.

Lemma tenc_inj s t : tenc s ≡ tenc t -> s = t.

Definition Var : term := .\"n";     .\"v","a","l"; "v" "n".
Definition App : term := .\"s","t"; .\"v","a","l"; "a" "s" "t".
Definition Lam : term := .\"s";     .\"v","a","l"; "l" "s".

Lemma Var_correct n : Var (enc n) ≡ tenc (n).

Lemma App_correct s t : App (tenc s) (tenc t) ≡ tenc (s t).

Lemma Lam_correct s : Lam (tenc s) ≡ tenc (lambda s).

Definition N := rho ( .\"N", "n"; "n"
   !(tenc Zero)
   (.\"n"; !Lam (!Lam (!App !(tenc 0) ("N" "n"))))).

Lemma N_correct n : N (enc n) ≡ tenc(enc n).

Definition Q := Eval cbn in rho ( .\"Q", "s"; "s"
   (.\"n";     !Lam (!Lam (!Lam (!App !(tenc 2) (!N "n")))))
   (.\"s","t"; !Lam (!Lam (!Lam (!App (!App !(tenc 1) ("Q" "s")) ("Q" "t")))))
   (.\"s";     !Lam (!Lam (!Lam (!App !(tenc 0) ("Q" "s"))))) ).

Lemma Q_correct s : Q (tenc s) ≡ tenc(tenc s).

Definition benc (b:bool) : term := if b then T else F.
Hint Unfold T F : cbv.

Lemma benc_proc b : proc (benc b).
Hint Resolve benc_proc : cbv.

Lemma T_equiv_F : ~ T ≡ F. *)
(* DecidableRecognisable:
From Undecidability.L Require Import Encodings.

Implicit Types s t u v : term.
Implicit Types p q : term -> Prop.

Definition decides u p := forall s, (p s /\ u (tenc s) ▷ T) \/ (~ p s /\ u (tenc s) ▷ F).
Definition decidable p := 
  exists u, proc u /\ decides u p.

Lemma decidable_spec u p : decides u p -> forall s, (p s <-> u (tenc s) ▷ T) /\ (~ p s <-> u (tenc s) ▷ F).

Definition pi s t := eva (s (tenc t)).

Definition recognisable p := 
  exists u, proc u /\ forall s, p s <-> eva (u (tenc s)).

Definition complement p := fun t => ~ p t.
Definition intersection p q := fun t => p t /\ q t.
Definition union p q := fun t => p t \/ q t.

Definition tcompl (u : term) : term := .\"x"; (!u "x") !F !T.

Definition tintersection u v : term := .\"x"; (!u "x") (!v "x") !F.

Definition tunion u v : term := .\"x"; (!u "x") !T (!v "x").

Lemma decidable_intersection p q : decidable p -> decidable q -> decidable (intersection p q).

Lemma decidable_union p q : decidable p -> decidable q -> decidable (union p q).

Lemma decidable_complement p : decidable p -> decidable (complement p).

Lemma undecidable_russell : ~ decidable (fun s => ~ s (tenc s) ▷ T).

Definition recinter u v : term := .\"x"; !F (!u "x") (!v "x").
Hint Unfold recinter : cbv.

Lemma recinter_correct u v s : closed u -> closed v -> eva (recinter u v (tenc s)) <-> eva ( u (tenc s)) /\ eva (v (tenc s)).

Lemma recognisable_intersection p q : recognisable p -> recognisable q -> recognisable (intersection p q).

Lemma dec_recognisable p : decidable p -> recognisable p.

Lemma dec_rec p : decidable p -> recognisable p /\ recognisable (complement p).

Theorem SecondFixedPoint (s : term) : closed s -> exists t, closed t /\ s (tenc t) ≡ t.

Theorem Scott p : 
  (forall s t, closed s -> p s -> closed t -> t ≡ s -> p t) ->
  (exists t1, closed t1 /\ p t1) -> (exists t2, closed t2 /\ ~ p t2) ->
  ~ decidable p.                                                                 

Lemma eva_dec : ~ decidable eva.

Lemma equiv_spec_decidable : forall t, closed t -> ~ decidable (fun x => x ≡ t). *)
(* Markov:
From Undecidability.L Require Export Enumerable InterpreterResults DecidableRecognisable Rice Por.

Lemma re_exists p : enumerable p -> enumerable (fun t => exists s : term, p (s t)).

Lemma DA p : recognisable p -> recognisable (fun _ => exists t, p t).
  
Definition Markov_Post:= forall p, recognisable p -> recognisable (complement p) -> decidable p.
Definition Markov_Sat := forall p, decidable p -> (~~ exists t, p t) -> exists t, p t.
Definition Markov_Eva := forall s, closed s -> ~~ eva s -> eva s.

Lemma Markov_Post_to_Sat : Markov_Post -> Markov_Sat.

Lemma Markov_Sat_to_Eva : Markov_Sat -> Markov_Eva.

Lemma Markov_Eva_to_Post : Markov_Eva -> Markov_Post. *)



Implicit Types P Q : term -> Prop.



Definition computable_gen X Y (xenc : X -> term) (yenc : Y -> term) f :=

  exists u, proc u /\ forall s, u (xenc s) ▷ (yenc (f s)).



Definition computable_fun f := computable_gen tenc tenc f.



Record mreducible P Q : Prop :=

  { f : term -> term ;

    f_red : forall s, P s <-> Q (f s) ;

    f_comp : computable_fun f ;

  }.

Notation "P ⪯ Q" := (mreducible P Q) (at level 40, no associativity).



Lemma mreducible_sane P Q :

  mreducible P Q <-> exists u, proc u /\ forall s, exists t, u (tenc s) ▷ tenc t /\ (P s <-> Q t).

Proof.

  split.

  - intros [f ? (u & ? & ?)].

    exists u. split; value.

    intros. exists (f s). split; eauto.

  - intros (u & ? & ?). assert (forall s, exists t, u (tenc s) ▷ tenc t) as [f ?] %  L_computable_computable by firstorder.

    exists f.

    + intros. destruct (H0 s) as (t & ? & ?).

      enough (f s = t) as ->. eassumption.

      specialize (e s). eapply tenc_inj. now rewrite <- e, <- H1. 

    + firstorder.

Qed.  



Instance mreducible_preorder : PreOrder mreducible.

Proof.

  econstructor.

  - exists (fun s => s).

    + firstorder.

    + exists I. split; value. intros. solveeq.

  - intros P Q R [f1 H1 [u1 []]] [f2 H3 [u2 []]].

    exists (fun s => f2 (f1 s)).

    + firstorder.

    + exists (lambda (u2 (u1 0))). split; value.

      intros. eapply evaluates_equiv. split; value.

      specialize (H0 s). specialize (H4 (f1 s)).

      solveeq.

Qed.



Lemma mreducible_ext P Q P' Q' :

  (forall s, P s <-> P' s) -> (forall s, Q s <-> Q' s) -> P ⪯ Q -> P' ⪯ Q'.

Proof.

  intros ? ? [f ? ?]. exists f; firstorder.

Qed.



Lemma mreducible_comp P Q :

  P ⪯ Q -> (fun s => ~ P s) ⪯ (fun s => ~ Q s).

Proof.

  intros [f ? ?]. exists f; firstorder.

Qed.



Lemma mreducible_comp_conv :

  (forall P Q, (fun s => ~ P s) ⪯ (fun s => ~ Q s) -> P ⪯ Q) ->

  Markov_Eva.

Proof.

  intros ? ? ? ?. specialize (H eva (fun s => ~~ eva s)).

  destruct H.

  - eapply mreducible_ext with (P :=  (fun s0 : term => ~ eva s0)) (Q :=  (fun s0 : term => ~ eva s0)); try reflexivity.

    firstorder.      

  - eapply f_red. intros ?. eapply H1. intros ?. now eapply f_red in H2.

Qed.



Lemma mreducible_dec P Q :

  decidable Q -> P ⪯ Q -> decidable P.

Proof.

  intros (u & Hp & H) [f ? (v & ? & ?)].

  exists (lambda (u (v 0))). split; value.

  intros s. assert (lambda (u (v 0)) (tenc s) ≡ u (v (tenc s))) as -> by solveeq.

  rewrite H1. firstorder.

Qed.



Lemma mreducible_red P Q s t :

  Q s -> ~ Q t -> decidable P -> P ⪯ Q.

Proof.

  intros ? ? ?. pose proof (decidable_dec H1) as [f ?].

  destruct H1 as (u & ? & ?).

  exists (fun x => if f x then s else t).

  - intros x. specialize (H2 x). destruct (f x); firstorder congruence.

  - exists (lambda (u 0 (tenc s) (tenc t))). split; value.

    intros x. assert ((lambda (((u 0) (tenc s)) (tenc t))) (tenc x) ≡ u (tenc x) (tenc s) (tenc t)) as -> by solveeq.

    destruct (H3 x) as [ [-> % H2 ->] | [? ->] ].

    + solveeq.

    + rewrite <- H2 in H4. destruct (f x); try congruence. solveeq.

Qed.



Lemma mreducible_recognisable P Q :

  recognisable Q -> P ⪯ Q -> recognisable P.

Proof.

  intros (u & ? & ?) [f ? (v & ? & ?)].

  exists (lambda (u (v 0))). split; value.

  intros s. assert (lambda (u (v 0)) (tenc s) ≡ u (v (tenc s))) as -> by solveeq.

  now rewrite H2, f_red, H0.

Qed.



Lemma mreducible_full P :

  P ⪯ (fun s => True) <-> (forall s, P s).

Proof.

  split. 

  - firstorder.

  - intros. eapply mreducible_ext with (P := fun _ => True) (Q := fun _ => True); firstorder.

Qed.



Lemma mreducible_empty P :

  P ⪯ (fun s => False) <-> (forall s, ~ P s).

Proof.

  split. 

  - firstorder.

  - intros. eapply mreducible_ext with (P := fun _ => False) (Q := fun _ => False); firstorder. exact 0.

Qed.



Lemma eva_red :

  (fun s => eva (s (tenc s))) ⪯ eva.

Proof.

  exists (fun s => app s (tenc s)).

  - firstorder.

  - exists (lambda (App 0 (Q 0))). split; value.

    intros. eapply evaluates_equiv. split; value.

    transitivity (App (tenc s) (Q (tenc s))). solveeq.

    now rewrite Q_correct, App_correct.

Qed.



Lemma recognisable_iff P :

  recognisable P <-> P ⪯ eva.

Proof.

  split.

  - intros (u & ? & ?).

    exists (fun x => u (tenc x)).

    + eassumption. 

    + exists (lambda (App (tenc u) (Q 0))). split; value.

      intros. eapply evaluates_equiv; split; value.

      redL. now rewrite Q_correct, App_correct.

  - intros ?. eapply mreducible_recognisable.

    eapply recognisable_eva. eassumption.

Qed.



Lemma preceq_lub P Q : exists R,

    P ⪯ R /\ Q ⪯ R /\ forall R', P ⪯ R' -> Q ⪯ R' -> R ⪯ R'.

Proof.

  exists (fun s => match s with

             app 0 s => P s

           | app _ s => Q s

           | s => Q s

           end).

  repeat split.

  - {

      exists (fun s => app 0 s).

      - cbn. firstorder.

      - exists (lambda (App (tenc 0) 0)). split; value. intros.

        eapply evaluates_equiv; split; value.

        transitivity (App (tenc 0) (tenc s)). solveeq.

        now rewrite App_correct.

    }

  - {

      exists (fun s => app 1 s).

      - cbn. firstorder.

      - exists (lambda (App (tenc 1) 0)). split; value. intros.

        eapply evaluates_equiv; split; value.

        transitivity (App (tenc 1) (tenc s)). solveeq.

        now rewrite App_correct.

    }

  - intros D [f] [g].

    exists (fun s => match s with

             | app 0 s => f s

             | app _ s => g s

             | _ => g s

             end).

    cbn. intros. destruct s as [ | [[] | | ] |]; cbn; firstorder.

    destruct f_comp as (u & ? & ?), f_comp0 as (v & ? & ?).

    exists (lambda (0 (lambda (v 1)) (lambda (lambda (1 (lambda (0 (u 1) (lambda (v 2)))) (lambda (lambda (v 2))) (lambda (v 1))))) (lambda (v 1)))).

    split; value. intros. eapply evaluates_equiv; split; value.

    destruct s as [ | [ [] | | ] | ] eqn:E.

    + specialize (H2 s). subst. solveeq.

    + specialize (H0 t1). subst. solveeq.

    + specialize (H2 t1). specialize (H0 t1). subst. solveeq.

    + specialize (H2 t2). specialize (H0 t2). solveeq.

    + specialize (H2 t1). solveeq.

    + specialize (H2 s). subst. solveeq.

Qed.



