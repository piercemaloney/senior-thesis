

Require Import Shared.Prelim MarkovPost.
(* Shared.Prelim:
Require Export Bool Omega List Setoid Morphisms.

Global Set Implicit Arguments. 
Global Unset Strict Implicit.
Global Unset Printing Records.
Global Unset Printing Implicit Defensive.
Global Set Regular Subst Tactic.

Hint Extern 4 => exact _.

Export ListNotations.
Notation "x 'el' A" := (In x A) (at level 70).
Notation "A <<= B" := (incl A B) (at level 70).
Notation "| A |" := (length A) (at level 65).

Hint Extern 4 => 
match goal with
|[ H: ?x el nil |- _ ] => destruct H
end.

Lemma incl_nil X (A : list X) :
  nil <<= A.

Hint Rewrite <- app_assoc : list.
Hint Rewrite rev_app_distr map_app prod_length : list.
Hint Resolve in_eq in_nil in_cons in_or_app.
Hint Resolve incl_refl incl_tl incl_cons incl_appl incl_appr incl_app incl_nil.

Ltac inv H := inversion H; subst; try clear H.

Tactic Notation "destruct" "_":=
  match goal with
  | [ |- context[match ?X with _ => _ end] ] => destruct X
  | [ H : context[match ?X with _ => _ end] |- _ ] => destruct X 
  end.

Hint Extern 4 => 
match goal with
|[ H: False |- _ ] => destruct H
|[ H: true=false |- _ ] => discriminate H
|[ H: false=true |- _ ] => discriminate H
end.

Lemma size_induction X (f : X -> nat) (p : X -> Type) :
  (forall x, (forall y, f y < f x -> p y) -> p x) -> 
  forall x, p x.

Definition Injective {A B} (f : A->B) :=
 forall x y, f x = f y -> x = y.

Lemma size_induction_dep L (X : L -> Type) (f : forall l, X l -> nat) (p : forall l, X l -> Type) :
  (forall l x, (forall l' y, f l' y < f l x -> p l' y) -> p l x) -> 
  forall l x, p l x.

Section fix_X.
  Variable X:Type.
  Implicit Types (A B: list X) (a b c: X). 

  Lemma last_app_eq A B a b :
    A++[a] = B++[b] -> A = B /\ a = b.
  
  Lemma rev_eq A B:
    List.rev A = List.rev B <-> A = B.

  Lemma rev_nil A:
    rev A = [] -> A = [].

  Lemma map_inj (Y:Type) A B (f: X -> Y) :
    Injective f -> map f A = map f B <-> A = B.
End fix_X.

Lemma app_incl_l X (A B C : list X) :
  A ++ B <<= C -> A <<= C.

Lemma app_incl_R X (A B C : list X) :
  A ++ B <<= C -> B <<= C.

Lemma cons_incl X (a : X) (A B : list X) : a :: A <<= B -> A <<= B.

Lemma incl_sing X (a : X) A : a el A -> [a] <<= A.

Hint Resolve app_incl_l app_incl_R cons_incl incl_sing.

Hint Extern 4 (_ el map _ _) => eapply in_map_iff.
Hint Extern 4 (_ el filter _ _) => eapply filter_In.

Fixpoint count (l : list nat) (n : nat)  :=
  match l with
  | [] => 0
  | m :: l => if Nat.eqb n m then S (count l n) else count l n
  end.

Lemma countSplit (A B: list nat) (x: nat)  : count A x + count B x = count (A ++ B) x. 

Lemma notInZero (x: nat) A :
  not (x el A) <-> count A x = 0.

Section Positions.
  Variables (X: Type) (d: forall x y : X, {x = y} + {x <> y}).
  Implicit Types (x y: X) (A B : list X).

  Fixpoint pos x A : option nat :=
    match A with
    | nil => None
    | y :: A' => if d x y then Some 0
                else match pos x A' with
                     | Some n => Some (S n)
                     | None => None
                     end
    end.

  Lemma el_pos x A :
    x el A -> { n | pos x A = Some n }.

  Notation nthe n A := (nth_error A n).
  
  Lemma nthe_length A n :
    length A > n -> { x | nthe n A = Some x }.
  
 Lemma pos_nthe x A n :
    pos x A = Some n -> nthe n A = Some x.
  
  Lemma nthe_app_l x n A B :
    nthe n A = Some x -> nthe n (A ++ B) = Some x.

End Positions.

Notation nthe n A := (nth_error A n).

Lemma pos_nth X d (x : X) l n def : pos d x l = Some n -> nth n l def = x.

Lemma pos_length X d (x : X) l n : pos d x l = Some n -> n < | l |.

Fixpoint omap X Y (f : X -> option Y) l :=
  match l with
  | nil => nil
  | x :: l => match f x with Some y => y :: omap f l | None => omap f l end
  end.

Lemma in_omap_iff X Y (f : X -> option Y) l y : y el omap f l <-> exists x, x el l /\ f x = Some y.

Section neList.

  Variable X : Type.
  Variable P : list X -> Prop.

  Hypothesis B : (forall x : X, P [x]).
  Hypothesis S : (forall x A, P A -> P (x :: A)).
  
  Lemma list_ind_ne A : A <> [] -> P A.

End neList.

Coercion bool2Prop (b : bool) := if b then True else False.

Lemma bool_Prop_true b :
  b = true -> b.

Lemma bool_Prop_false b :
  b = false -> ~ b.

Hint Resolve bool_Prop_true bool_Prop_false.

Hint Extern 4 => 
match goal with
|[ H: False |- _ ] => destruct H
|[ H: ~ bool2Prop true |- _ ] => destruct H
|[ H: bool2Prop false |- _ ] => destruct H
|[ H: true=false |- _ ] => discriminate H
|[ H: false=true |- _ ] => discriminate H
|[ H: ?b=false, H': bool2Prop(?b) |- _ ] => rewrite H in H'; destruct H'

end.

Definition dec (X: Prop) : Type := {X} + {~ X}.

Coercion dec2bool P (d: dec P) := if d then true else false.

Existing Class dec.

Definition Dec (X: Prop) (d: dec X) : dec X := d.
Arguments Dec X {d}.

Ltac dec := repeat match goal with
                  | [ |- context [ Dec ?x ] ] => let E := fresh "E" in destruct (Dec x) as [E | ]; [ try (rewrite E in *; clear E)| ]
                  | [H : context [ Dec ?x ]  |- _ ] => let E := fresh "E" in destruct (Dec x) as [E | ];
                                                                      [ try (rewrite E in *; clear E)| ]
                  end; cbn [dec2bool].

Lemma Dec_reflect (X: Prop) (d: dec X) :
  Dec X <-> X.

Notation Decb X := (dec2bool (Dec X)).

Lemma Dec_reflect_eq (X Y: Prop) (d: dec X) (e: dec Y) :
 Decb X = Decb Y <->  (X <-> Y).

Lemma Dec_auto (X: Prop) (d: dec X) :
  X -> Dec X.

Lemma Dec_auto_not (X: Prop) (d: dec X) :
  ~ X -> ~ Dec X.

Hint Resolve Dec_auto Dec_auto_not.
Hint Extern 4 =>  
match goal with
  | [  |- dec ((fun _ => _) _) ] => cbn
end : typeclass_instances.

Tactic Notation "decide" constr(p) := 
  destruct (Dec p).
Tactic Notation "decide" constr(p) "as" simple_intropattern(i) := 
  destruct (Dec p) as i.
Tactic Notation "decide" "_" :=
  destruct (Dec _).
Tactic Notation "have" constr(E) := let X := fresh "E" in decide E as [X|X]; subst; try congruence; try omega; clear X.

Lemma Dec_true P {H : dec P} : dec2bool (Dec P) = true -> P.

Lemma Dec_false P {H : dec P} : dec2bool (Dec P) = false -> ~P.

Hint Extern 4 =>
match goal with
  [ H : dec2bool (Dec ?P) = true  |- _ ] => apply Dec_true in  H
| [ H : dec2bool (Dec ?P) = false |- _ ] => apply Dec_false in H
end.

Lemma dec_DN X : 
  dec X -> ~~ X -> X.

Lemma dec_DM_and X Y :  
  dec X -> dec Y -> ~ (X /\ Y) -> ~ X \/ ~ Y.

Lemma dec_DM_impl X Y :  
  dec X -> dec Y -> ~ (X -> Y) -> X /\ ~ Y.

Fact dec_transfer P Q :
  P <-> Q -> dec P -> dec Q.

Export ListNotations.
Notation "x 'el' A" := (In x A) (at level 70).
Notation "A <<= B" := (incl A B) (at level 70).
Notation "| A |" := (length A) (at level 65).
Definition equi X (A B : list X) : Prop := incl A B /\ incl B A.
Notation "A === B" := (equi A B) (at level 70).
Hint Unfold equi.

Hint Extern 4 => 
match goal with
|[ H: ?x el nil |- _ ] => destruct H
end.

Hint Rewrite <- app_assoc : list.
Hint Rewrite rev_app_distr map_app prod_length : list.

Lemma list_cycle  (X : Type) (A : list X) x :
  x::A <> A.

Lemma cfind X A (p: X -> Prop) (p_dec: forall x, dec (p x)) :
  {x | x el A /\ p x} + {forall x, x el A -> ~ p x}.

Lemma list_exists_DM X A  (p : X -> Prop) : 
  (forall x, dec (p x)) ->
  ~ (forall x, x el A -> ~ p x) -> exists x, x el A /\ p x.

Lemma list_exists_not_incl (X: eqType) (A B : list X) :
  ~ A <<= B -> exists x, x el A /\ ~ x el B.

Lemma list_cc X (p : X -> Prop) A : 
  (forall x, dec (p x)) -> 
  (exists x, x el A /\ p x) -> {x | x el A /\ p x}.

Hint Resolve in_eq in_nil in_cons in_or_app.

Section Membership.
  Variable X : Type.
  Implicit Types (x y: X) (A B: list X).

  Lemma in_sing x y :
    x el [y] -> x = y.

  Lemma in_cons_neq x y A :
    x el y::A -> x <> y -> x el A.

  Lemma not_in_cons x y A :
    ~ x el y :: A -> x <> y /\ ~ x el A.

  Definition disjoint A B :=
    ~ exists x, x el A /\ x el B.

  Lemma disjoint_forall A B :
    disjoint A B <-> forall x, x el A -> ~ x el B.

  Lemma disjoint_symm A B :
    disjoint A B -> disjoint B A.

  Lemma disjoint_incl A B B' :
    B' <<= B -> disjoint A B -> disjoint A B'.

  Lemma disjoint_nil B :
    disjoint nil B.

  Lemma disjoint_nil' A :
    disjoint A nil.
  
  Lemma disjoint_cons x A B :
    disjoint (x::A) B <-> ~ x el B /\ disjoint A B.

  Lemma disjoint_app A B C :
    disjoint (A ++ B) C <-> disjoint A C /\ disjoint B C.

End Membership.

Hint Resolve disjoint_nil disjoint_nil'.

Hint Resolve incl_refl incl_tl incl_cons incl_appl incl_appr incl_app.

Hint Resolve incl_nil.

Lemma incl_map X Y A B (f : X -> Y) :
  A <<= B -> map f A <<= map f B.

Section Inclusion.
  Variable X : Type.
  Implicit Types A B : list X.

  Lemma incl_nil_eq A :
    A <<= nil -> A=nil.

  Lemma incl_shift x A B :
    A <<= B -> x::A <<= x::B.

  Lemma incl_lcons x A B :
    x::A <<= B <-> x el B /\ A <<= B.

  Lemma incl_rcons x A B :
    A <<= x::B -> ~ x el A -> A <<= B.

  Lemma incl_lrcons x A B :
    x::A <<= x::B -> ~ x el A -> A <<= B.

  Lemma incl_app_left A B C :
    A ++ B <<= C -> A <<= C /\ B <<= C.

End Inclusion.

Definition inclp (X : Type) (A : list X) (p : X -> Prop) : Prop :=
  forall x, x el A -> p x.

Section Equi.
  Variable X : Type.
  Implicit Types A B : list X.

  Lemma equi_push x A :
    x el A -> A === x::A.

  Lemma equi_dup x A :
    x::A === x::x::A.

  Lemma equi_swap x y A:
    x::y::A === y::x::A.

  Lemma equi_shift x A B :
    x::A++B === A++x::B.

  Lemma equi_rotate x A :
    x::A === A++[x]. 
  
End Equi.

Lemma in_concat_iff A l (a:A) : a el concat l <-> exists l', a el l' /\ l' el l.

Section Filter.
  Variable X : Type.
  Implicit Types (x y: X) (A B C: list X) (p q: X -> bool).
  
  Lemma in_filter_iff x p A :
    x el filter p A <-> x el A /\ p x.

  Lemma filter_incl p A :
    filter p A <<= A.  

  Lemma filter_mono p A B :
    A <<= B -> filter p A <<= filter p B.

  Lemma filter_id p A :
    (forall x, x el A -> p x) -> filter p A = A.

  Lemma filter_app p A B :
    filter p (A ++ B) = filter p A ++ filter p B.

  Lemma filter_fst p x A :
    p x -> filter p (x::A) = x::filter p A.

  Lemma filter_fst' p x A :
    ~ p x -> filter p (x::A) = filter p A.

  Lemma filter_pq_mono p q A :
    (forall x, x el A -> p x -> q x) -> filter p A <<= filter q A.

  Lemma filter_pq_eq p q A :
    (forall x, x el A -> p x = q x) -> filter p A = filter q A.

  Lemma filter_and p q A :
    filter p (filter q A) = filter (fun x => p x && q x) A.

  Lemma filter_comm p q A :
    filter p (filter q A) = filter q (filter p A).
  
End Filter.

Section Removal.
  Variable X : eqType.
  Implicit Types (x y: X) (A B: list X).

  Definition rem A x : list X :=
    filter (fun z => Dec (z <> x)) A.

  Lemma in_rem_iff x A y :
    x el rem A y <-> x el A /\ x <> y.

  Lemma rem_not_in x y A :
    x = y \/ ~ x el A -> ~ x el rem A y.

  Lemma rem_incl A x :
    rem A x <<= A.

  Lemma rem_mono A B x :
    A <<= B -> rem A x <<= rem B x.

  Lemma rem_cons A B x :
    A <<= B -> rem (x::A) x <<= B.

  Lemma rem_cons' A B x y :
    x el B -> rem A y <<= B -> rem (x::A) y <<= B.

  Lemma rem_in x y A :
    x el rem A y -> x el A.

  Lemma rem_neq x y A :
    x <> y -> x el A -> x el rem A y.

  Lemma rem_app x A B :
    x el A -> B <<= A ++ rem B x.

  Lemma rem_app' x A B C :
    rem A x <<= C -> rem B x <<= C -> rem (A ++ B) x <<= C.

  Lemma rem_equi x A :
    x::A === x::rem A x.

  Lemma rem_comm A x y :
    rem (rem A x) y = rem (rem A y) x.

  Lemma rem_fst x A :
    rem (x::A) x = rem A x.

  Lemma rem_fst' x y A :
    x <> y -> rem (x::A) y = x::rem A y.

  Lemma rem_id x A :
    ~ x el A -> rem A x = A.

  Lemma rem_reorder x A :
    x el A -> A === x :: rem A x.

  Lemma rem_inclr A B x :
    A <<= B -> ~ x el A -> A <<= rem B x.

End Removal.

Hint Resolve rem_not_in rem_incl rem_mono rem_cons rem_cons' rem_app rem_app' rem_in rem_neq rem_inclr.

Notation "( A × B × .. × C )" := (list_prod .. (list_prod A B) .. C) (at level 0, left associativity).

Notation "[ s | p ∈ A ',' P ]" :=
  (map (fun p => s) (filter (fun p => Dec P) A)) (p pattern).
Notation "[ s | p ∈ A ]" :=
  (map (fun p => s) A) (p pattern).

Ltac in_app n :=
  (match goal with
  | [ |- _ el _ ++ _ ] => 
    match n with
    | 0 => idtac
    | 1 => eapply in_app_iff; left
    | S ?n => eapply in_app_iff; right; in_app n
    end
  | [ |- _ el _ :: _ ] => match n with 0 => idtac | 1 => left | S ?n => right; in_app n end
  end) || (repeat (try right; eapply in_app_iff; right)).

Lemma to_dec (P : Prop) `{dec P} : P <-> Dec P.

Ltac in_collect a :=
  eapply in_map_iff; exists a; split; [ eauto | match goal with [ |- _ el filter _ _ ] =>  eapply in_filter_iff; split; [ try (rewrite !in_prod_iff; repeat split) | rewrite <- to_dec; repeat split; eauto ] | _ => try (rewrite !in_prod_iff; repeat split) end ].
Ltac inv_collect :=
  repeat
    (match goal with
    | [ H : ?x el concat _ |- _ ] => eapply in_concat_iff in H as (? & ? & ?)
    | [ H : ?x el map _ _ |- _ ] => let x := fresh "x" in eapply in_map_iff in H as (x & ? & ?)
    | [ x : ?A * ?B |- _ ] => destruct x; subst
    | [ H : ?x el filter _ _ |- _ ] => let H' := fresh "H" in eapply in_filter_iff in H as (? & H' % to_dec)
    | [ H : ?x el list_prod _ _ |- _ ] => eapply in_prod_iff in H
    | [ H : _ el _ ++ _ |- _ ] => try eapply in_app_iff in H as []
    | [H : _ el _ :: _ |- _ ] => destruct H
     end; intuition; subst). *)
(* MarkovPost:
Require Export DecidableEnumerable.
Require Import ConstructiveEpsilon.

Definition stable P := ~~ P -> P.

Definition MP := forall f : nat -> bool, stable (exists n, f n = true).

Definition mu (p : nat -> Prop) :
  (forall x, dec (p x)) -> ex p -> sig p.

Local Notation R p :=
  (fun x y : nat => x = S y /\ ~ p y).

Lemma Acc_ind_dep (A : Type) (R : A -> A -> Prop) (P : forall a, Acc R a -> Prop) :
  (forall x (F : (forall y, R y x -> Acc R y)), (forall y (Hy : R y x), P y (F y Hy)) -> P x (Acc_intro x F))
  -> forall x (h : Acc R x), P x h.

Notation mu' d H := (proj1_sig (mu d H)).

Lemma mu_least (p : nat -> Prop) (d : forall x, dec (p x)) (H : ex p) :
  forall n, p n -> mu' d H <= n.

Definition ldecidable X (p : X -> Prop) :=
  forall x, p x \/ ~ p x.

Lemma weakPost X (p : X -> Prop) : discrete X ->
  ldecidable p -> enumerable p -> enumerable (compl p) -> decidable p.

Lemma MP_to_decMP :
  MP -> (forall p : nat -> Prop, decidable p -> stable (exists n, p n)).

Lemma decMP_to_eMP :
  (forall p : nat -> Prop, decidable p -> stable (exists n, p n)) -> (forall X (p : X -> Prop), enumerable p -> stable (exists n, p n)).

Lemma eMP_to_MP :
  (forall X (p : X -> Prop), enumerable p -> stable (exists n, p n)) -> MP.

Lemma MP_enum_stable X (p : X -> Prop) :
  MP -> enumerable p -> discrete X -> forall x, stable (p x).

Definition POST' :=
  forall X (p : X -> Prop), discrete X -> enumerable p -> enumerable (fun x => ~ p x) -> ldecidable p.

Theorem MP_Post :
  MP -> POST'.

Lemma Post_to' :
   POST' -> MP.

Definition POST :=
  forall X (p : X -> Prop), discrete X -> enumerable p -> enumerable (fun x => ~ p x) -> decidable p.

Lemma Post_MP :
  POST <-> MP. *)



Definition generating X :=

  forall (A : list X), exists x, ~ x el A.



Definition injective X Y (f : X -> Y) :=

  forall x x', f x = f x' -> x = x'.



Definition infinite X :=

  exists (f : nat -> X), injective f.



Section Inf.

  

  Variables (X : Type) (f' : nat -> option X).

  Hypothesis Hf' : forall x, exists n, f' n = Some x.

  Hypothesis HX : eq_dec X.

  

  Section Gen.

    

    Variable f : nat -> X.

    Hypothesis Hf : injective f.



    Fixpoint LX n :=

      match n with 

      | 0 => [f 0]

      | S n => f (S n) :: LX n

      end.



    Lemma LX_len n :

      | LX n | = S n.

    Proof.

      induction n; cbn; eauto.

    Qed.



    Lemma LX_el n x :

      x el LX n -> exists n', n' <= n /\ f n' = x.

    Proof.

      induction n.

      - intros [H|[] ]. exists 0. split; auto.

      - intros [H|H]; eauto.

        destruct (IHn H) as [n'[H1 H2] ].

        exists n'. split; auto.

    Qed.



    Lemma LX_NoDup n :

      NoDup (LX n).

    Proof.

      induction n; cbn; repeat constructor; auto.

      intros (n'&H1&H2) % LX_el.

      apply Hf in H2. omega.

    Qed.



    Lemma sub_dec (A B : list X) :

      (A <<= B) + {x | x el A /\ ~ x el B}.

    Proof.

      revert B. induction A; intros B; cbn; auto.

      destruct (IHA B); decide (a el B); auto.

      - right. exists a. split; auto.

      - destruct s as (x&H1&H2). right.

        exists x. split; auto.

      - right. exists a. split; auto.

    Qed.



    Lemma X_gen :

      generating X.

    Proof.

      intros A. destruct (sub_dec (LX (|A|)) A) as [H|H].

      - apply NoDup_incl_length in H; try apply LX_NoDup.

        rewrite LX_len in H. omega.

      - destruct H as [x [_ H] ]. now exists x.

    Qed.



  End Gen.



  Hypothesis Hg : generating X.



  Instance el_dec :

    forall (A : list X) x, dec (x el A).

  Proof.

    intros A x. induction A; cbn; auto.

  Qed.



  Definition dummy : X.

  Proof.

    pose (p := fun n => exists x, f' n = Some x).

    destruct (@mu p) as [n Hn].

    - intros n. destruct (f' n) eqn : H.

      + left. now exists x.

      + right. intros [x H']. congruence.

    - destruct (Hg nil) as [x Hx]. destruct (Hf' x) as [n Hn]. now exists n, x.

    - destruct (f' n) eqn : H; trivial.

      exfalso. destruct Hn as [x Hx]. congruence.

  Qed.



  Definition f n :=

    match (f' n) with Some x => x | None => dummy end.



  Lemma f_sur :

    forall x, exists n, f n = x.

  Proof.

    intros x. destruct (Hf' x) as [n Hn]. exists n.

    unfold f. now rewrite Hn.

  Qed.



  Definition le_f x y :=

    exists n, f n = x /\ forall n', f n' = y -> n <= n'.



  Lemma gen (A : list X) :

    { x | ~ x el A /\ forall y, ~ y el A -> le_f x y}.

  Proof.

    pose (p := fun n => ~ f n el A).

    assert (H1 : forall x, dec (p x)).

    { intros n. destruct (el_dec A (f n)) as [H|H].

      - right. intros H'. contradiction.

      - left. assumption. }

    assert (H2 : exists x, p x).

    { destruct (Hg A) as [x Hx]. destruct (f_sur x) as [n <-]. now exists n. }

    exists (f (mu' H1 H2)). split; try apply proj2_sig.

    intros y Hy. exists (mu' H1 H2). split; trivial.

    intros n <-. apply mu_least, Hy.

  Defined.



  Definition gen' A :=

    proj1_sig (gen A).



  Lemma gen_spec A :

    ~ gen' A el A.

  Proof.

    unfold gen'. destruct (gen A); cbn. apply a.

  Qed.



  Lemma gen_le_f A :

    forall x, ~ x el A -> le_f (gen' A) x.

  Proof.

    unfold gen'. destruct (gen A); cbn. apply a.

  Qed.



  Fixpoint LL n :=

    match n with 0 => nil | S n => LL n ++ [gen' (LL n)] end.



  Definition F n :=

    gen' (LL n).



  Lemma LL_cum :

    cumulative LL.

  Proof.

    intros n. now exists [(F n)].

  Qed.



  Lemma F_nel n :

    ~ F n el LL n.

  Proof.

    apply gen_spec.

  Qed.



  Lemma F_el n :

    F n el LL (S n).

  Proof.

    cbn. apply in_app_iff. now right.

  Qed.



  Lemma F_lt n m :

    n < m -> F n el LL m.

  Proof.

    intros H. apply cum_ge' with (n0:=S n).

    - apply LL_cum.

    - apply F_el.

    - omega.

  Qed.



  Lemma F_inj' n m :

    F n = F m -> ~ n < m.

  Proof.

    intros H1 H2 % F_lt. rewrite H1 in H2. apply (F_nel H2).

  Qed.



  Lemma F_inj :

    injective F.

  Proof.

    intros n m Hnm. destruct (Nat.lt_total n m) as [H|[H|H] ]; trivial.

    - contradiction (F_inj' Hnm H).

    - symmetry in Hnm. contradiction (F_inj' Hnm H).

  Qed.



  Lemma lt_acc n :

    Acc lt n.

  Proof.

    induction n.

    - constructor. intros m H. omega.

    - constructor. intros m H.

      destruct (Nat.lt_total n m) as [H'|[->|H'] ].

      + omega.

      + assumption.

      + now apply IHn.

  Qed.



  Lemma LL_f n :

    f n el LL (S n).

  Proof.

    induction (lt_acc n) as [n _ IH].

    decide _; try eassumption. exfalso.

    assert (H : ~ f n el LL n).

    { intros H. apply n0. apply (cum_ge' LL_cum H). auto. }

    apply gen_le_f in H as [n'[H1 H2] ].

    specialize (H2 n eq_refl).

    destruct (Nat.lt_total n' n) as [H3|[->|H3] ].

    - apply (gen_spec (A:=LL n)). rewrite <- H1.

      now apply (cum_ge' LL_cum (IH n' H3)).

    - apply n0. rewrite H1. apply in_app_iff; fold LL.

      right. left. reflexivity.

    - omega.

  Qed.



  Lemma LL_F x n :

    x el LL n -> exists m, F m = x.

  Proof.

    induction n; cbn; auto.

    intros [H|[H|H]] % in_app_iff; auto.

    now exists n.

  Qed.



  Lemma F_sur :

    forall x, exists n, F n = x.

  Proof.

    intros x. destruct (f_sur x) as [n H].

    destruct (LL_F (LL_f n)) as [m H'].

    exists m. congruence.

  Qed.



  Definition G x :=

    mu' _ (F_sur x).



  Lemma FG n :

    F (G n) = n.

  Proof.

    unfold G. apply proj2_sig.

  Qed.

  

  Lemma GF n :

    G (F n) = n.

  Proof.

    apply F_inj. now rewrite FG.

  Qed.



End Inf.

