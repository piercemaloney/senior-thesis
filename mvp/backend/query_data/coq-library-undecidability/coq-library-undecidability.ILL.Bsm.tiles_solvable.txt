
Require Import List Arith Max Omega Wellfounded Bool.

Require Import utils list_bool.
(* utils:
Require Export focus.
Require Export utils_tac.
Require Export list_focus.
Require Export utils_list.
Require Export utils_nat.
Require Export utils_string. *)
(* list_bool:
Require Import List Arith Max Omega Wellfounded Bool.

Require Import utils.

Set Implicit Arguments.

Notation Zero := false.
Notation One  := true.

Fact list_bool_dec (l m : list bool) : { l = m } + { l <> m }.

Fact list_bool_choose lb : { k : _ & { tl | lb = list_repeat Zero k ++ One :: tl } }
                         + { k            | lb = list_repeat Zero k }.

Fact list_bool_choose_sym lb : { k : _ & { tl | lb = list_repeat One k ++ Zero :: tl } }
                             + { k            | lb = list_repeat One k }.

Fixpoint list_nat_bool ln :=
  match ln with
    | nil   => nil
    | x::ll => list_repeat Zero x ++ One :: list_nat_bool ll
  end.

Lemma list_bool_decomp k lb : { ln : _ & { lc | lb = list_nat_bool ln ++ lc 
                                             /\ Exists (fun x => k <= x) ln } }
                            + { ln : _ & { r  | lb = list_nat_bool ln ++ list_repeat Zero r 
                                             /\ Forall (fun x => x < k) ln } }.

Definition list_bool_valid   k lb ln := lb = list_nat_bool ln /\ Forall (fun x => x < k) ln.
Definition list_bool_invalid k lb ln := exists lc, lb = list_nat_bool ln ++ lc
                                            /\ (   Exists (fun x => k <= x) ln
                                               \/  Forall (fun x => x < k) ln 
                                                /\ exists p, lc = list_repeat Zero (S p)).

Fact list_bool_valid_dec k lb : { ln | list_bool_valid k lb ln } + { ln | list_bool_invalid k lb ln }.

Fixpoint list_bool_nat l :=
  match l with 
    | nil     => 1
    | Zero::l => 0 + 2*list_bool_nat l
    | One::l  => 1 + 2*list_bool_nat l
  end.

Fact list_bool_nat_ge_1 l : 1 <= list_bool_nat l.

Unset Elimination Schemes.

Inductive list_bool_succ : list bool -> list bool -> Prop :=
  | in_lbs_0 : forall k l, list_bool_succ (list_repeat One k ++ Zero :: l) (list_repeat Zero k ++ One :: l)
  | in_lbs_1 : forall k,   list_bool_succ (list_repeat One k)              (list_repeat Zero (S k)).

Set Elimination Schemes.

Section list_bool_succ_props.

  Fact list_One_Zero_inj a b l m : list_repeat One a ++ Zero :: l = list_repeat One b ++ Zero :: m -> a = b /\ l = m.

  Fact list_One_Zero_not a b l : list_repeat One a ++ Zero :: l <> list_repeat One b.

  Fact list_One_inj a b : list_repeat One a = list_repeat One b -> a = b.

  Fact list_bool_succ_fun l m1 m2 : list_bool_succ l m1 -> list_bool_succ l m2 -> m1 = m2.

  Fact list_bool_succ_nil l : list_bool_succ nil l -> l = Zero::nil.

  Fact list_bool_succ_neq : forall l m, list_bool_succ l m -> l <> m.

  Fact list_bool_succ_neq_nil l : ~ list_bool_succ l nil.

End list_bool_succ_props.

Section list_bool_next.

  Let list_bool_next_def l : { m | list_bool_succ l m }.

  Definition list_bool_next l := proj1_sig (list_bool_next_def l).
  Definition list_bool_next_spec l : list_bool_succ l (list_bool_next l). 

  Fact list_bool_next_neq_nil l : list_bool_next l <> nil.

  Fact iter_list_bool_next_nil l n : iter list_bool_next l n = nil -> n = 0 /\ l = nil.

End list_bool_next.

Fact list_bool_succ_nat l m : list_bool_succ l m -> 1 + list_bool_nat l = list_bool_nat m.
 
Section list_bool_succ_rect.

  Variable (P : list bool -> Type)
           (HP0 : P nil)
           (HPS : forall l m, list_bool_succ l m -> P l -> P m).

  Let list_bool_succ_rec n : forall l, list_bool_nat l = n -> P l.

  Theorem list_bool_succ_rect : forall l, P l.

End list_bool_succ_rect.

Theorem list_bool_next_total l : l <> nil -> { n | l = iter list_bool_next (Zero::nil) n }. *)

Set Implicit Arguments.

Fixpoint tile_concat ln lt : (list bool) * list bool:=
  match ln with
    | nil   => (nil,nil)
    | x::ln => match nth x lt (nil,nil), tile_concat ln lt with
                 | (th,tl), (hh,ll) => (hh++th,ll++tl)
               end
  end.

Definition tiles_solvable lt := 
   exists ln, ln <> nil 
           /\ Forall (fun x => x < length lt) ln 
           /\ let (hh,ll) := tile_concat ln lt in hh = ll.

