
Require Import basis.
(* basis:
Definition Relation (U : Set) := U -> U -> Prop.

Definition Reflexive (U : Set) (R : Relation U) : Prop := forall x : U, R x x.

Definition Transitive (U : Set) (R : Relation U) : Prop :=
  forall x y z : U, R x y -> R y z -> R x z.

Definition Symmetric (U : Set) (R : Relation U) : Prop :=
  forall x y : U, R x y -> R y x.

Inductive Equivalence (U : Set) (R : Relation U) : Prop :=
    Definition_of_equivalence :
      Reflexive U R -> Symmetric U R -> Transitive U R -> Equivalence U R.

Definition Negation (U : Set) (R : Relation U) : Relation U :=
  fun x y : U => ~ R x y.
Hint Unfold Negation.

Theorem Sym_imp_NegSym :
 forall (U : Set) (R : Relation U),
 Symmetric U R -> Symmetric U (Negation U R).
Hint Resolve Sym_imp_NegSym.

Definition Irreflexive (U : Set) (R : Relation U) : Prop :=
  forall x : U, ~ R x x.

Definition Separating (U : Set) (R : Relation U) : Prop :=
  forall x y z : U, R x y -> R x z \/ R y z.

Inductive Apartness (U : Set) (R : Relation U) : Prop :=
    Definition_of_apartness :
      Irreflexive U R -> Separating U R -> Apartness U R.
Hint Unfold Reflexive Irreflexive Symmetric Transitive.
Hint Resolve Definition_of_equivalence Definition_of_apartness.

Parameter Point : Set.
Parameter Line : Set.
Parameter DiPt : Point -> Point -> Prop.
Parameter DiLn : Line -> Line -> Prop.
Parameter ConLn : Line -> Line -> Prop.

Axiom apart_dipt : Apartness Point DiPt.

Axiom apart_diln : Apartness Line DiLn.

Axiom apart_con : Apartness Line ConLn.

Hint Resolve apart_dipt apart_diln apart_con.

Theorem Apart_imp_Sym :
 forall (U : Set) (R : Relation U), Apartness U R -> Symmetric U R.
Hint Resolve Apart_imp_Sym.

Theorem sym_DiPt : forall x y : Point, DiPt x y -> DiPt y x.

Theorem sym_DiLn : forall x y : Line, DiLn x y -> DiLn y x.

Theorem sym_ConLn : forall x y : Line, ConLn x y -> ConLn y x.
Hint Immediate sym_DiPt sym_DiLn sym_ConLn.

Theorem Neg_apart_equiv :
 forall (U : Set) (R : Relation U),
 Apartness U R -> Equivalence U (Negation U R).
Hint Resolve Neg_apart_equiv.

Definition EqPt := Negation Point DiPt.

Definition EqLn := Negation Line DiLn.

Definition Par := Negation Line ConLn.

Theorem equiv_EqPt : Equivalence Point EqPt.
Hint Resolve equiv_EqPt.

Theorem equiv_EqLn : Equivalence Line EqLn.
Hint Resolve equiv_EqLn.

Theorem equiv_Par : Equivalence Line Par.
Hint Resolve equiv_Par.

Theorem sym_EqPt : forall x y : Point, EqPt x y -> EqPt y x.

Theorem sym_EqLn : forall x y : Line, EqLn x y -> EqLn y x.

Theorem sym_Par : forall x y : Line, Par x y -> Par y x.
Hint Immediate sym_EqPt sym_EqLn sym_Par.

Parameter Apart : Point -> Line -> Prop.

Definition Incident (a : Point) (l : Line) := ~ Apart a l.

Record Segment : Set := Seg
  {origin : Point; extremity : Point; Seg_cond : DiPt origin extremity}.

Record Twolines : Set := Twol
  {line1 : Line; line2 : Line; Twol_cond : ConLn line1 line2}.

Axiom
  line :
    forall x : Segment,
    {l : Line | Incident (origin x) l /\ Incident (extremity x) l}.

Axiom
  point :
    forall x : Twolines,
    {a : Point | Incident a (line1 x) /\ Incident a (line2 x)}.

Definition ln : Segment -> Line.

Definition pt : Twolines -> Point.

Theorem inc_ln1 : forall x : Segment, Incident (origin x) (ln x).

Theorem inc_ln2 : forall x : Segment, Incident (extremity x) (ln x).

Theorem inc_pt1 : forall x : Twolines, Incident (pt x) (line1 x).

Theorem inc_pt2 : forall x : Twolines, Incident (pt x) (line2 x).
Hint Resolve inc_ln1 inc_ln2 inc_pt1 inc_pt2.

Axiom
  el_ax :
    forall (x : Segment) (l m : Line),
    DiLn l m ->
    (Apart (origin x) l \/ Apart (extremity x) l) \/
    Apart (origin x) m \/ Apart (extremity x) m.

Axiom
  cmp_apt_dipt :
    forall (a b : Point) (l : Line), Apart a l -> DiPt a b \/ Apart b l.

Axiom
  cmp_apt_diln :
    forall (a : Point) (l m : Line), Apart a l -> DiLn l m \/ Apart a m.

Axiom cmp_con_diln : forall l m n : Line, ConLn l m -> DiLn m n \/ ConLn l n.

Record Triangle : Set := Tri
  {summit : Point; base : Segment; Tri_cond : Apart summit (ln base)}.

Theorem Triangle_def : forall t : Triangle, Apart (summit t) (ln (base t)).
Hint Resolve Triangle_def.

Definition SPar : Relation Line := fun l m : Line => Par l m /\ DiLn l m.

Record Parallelogram : Set := Pgram
  {side1 : Segment;
   side2 : Segment;
   side3 : Segment;
   side4 : Segment;
   connect1 : origin side3 = origin side1 /\ extremity side3 = origin side2;
   connect2 :
    origin side4 = extremity side1 /\ extremity side4 = extremity side2;
   parsides_i : SPar (ln side1) (ln side2);
   parsides_ii : SPar (ln side3) (ln side4)}. *)
Require Import part1.
(* part1:
Require Import basis.

Theorem Uniqueness_of_constructed_lines :
 forall (x : Segment) (l : Line),
 Incident (origin x) l -> Incident (extremity x) l -> EqLn l (ln x).

Theorem Convergent_imp_distinct : forall l m : Line, ConLn l m -> DiLn l m.
Hint Resolve Convergent_imp_distinct.

Theorem Uniqueness_of_constructed_points :
 forall (x : Twolines) (a : Point),
 Incident a (line1 x) -> Incident a (line2 x) -> EqPt a (pt x).

Theorem cong_eqpt_apt :
 forall (a b : Point) (l : Line), Apart a l -> EqPt a b -> Apart b l.

Theorem cong_eqln_apt :
 forall (a : Point) (l m : Line), Apart a l -> EqLn l m -> Apart a m.

Theorem cong_eqpt_inc :
 forall (a b : Point) (l : Line), Incident a l -> EqPt a b -> Incident b l.

Theorem cong_eqln_inc :
 forall (a : Point) (l m : Line), Incident a l -> EqLn l m -> Incident a m.

Theorem cong_eqln_con :
 forall l m n : Line, ConLn l m -> EqLn m n -> ConLn l n.

Theorem cong_eqln_par : forall l m n : Line, Par l m -> EqLn m n -> Par l n.

Theorem cong_eqpt_dipt :
 forall a b c : Point, DiPt a b -> EqPt b c -> DiPt a c.

Theorem cong_eqln_diln :
 forall l m n : Line, DiLn l m -> EqLn m n -> DiLn l n.

Theorem eqln_imp_par : forall l m : Line, EqLn l m -> Par l m.

Theorem cong_par_con : forall l m n : Line, ConLn l m -> Par m n -> ConLn l n.

Theorem sym_SPar : forall x y : Line, SPar x y -> SPar y x.
Hint Resolve sym_SPar.

Theorem cong_eqln_spar :
 forall l m n : Line, SPar l m -> EqLn m n -> SPar l n.

Definition reverse : Segment -> Segment.

Theorem orig_rev : forall x : Segment, origin x = extremity (reverse x).

Theorem ext_rev : forall x : Segment, extremity x = origin (reverse x).

Theorem rev_defines_sameln : forall x : Segment, EqLn (ln x) (ln (reverse x)).
Hint Resolve rev_defines_sameln.

Definition flip : Twolines -> Twolines.

Theorem line1_flip : forall x : Twolines, line1 x = line2 (flip x).

Theorem line2_flip : forall x : Twolines, line2 x = line1 (flip x).

Theorem flip_defines_samept : forall x : Twolines, EqPt (pt x) (pt (flip x)).
Hint Resolve rev_defines_sameln flip_defines_samept.

Definition colinear (x y : Segment) : Prop := EqLn (ln x) (ln y).

Theorem Colinearity_is_equivalence : Equivalence Segment colinear.
Proof.
cut (Equivalence Line EqLn); auto.
intro H'; elim H'.
intros H'0 H'1 H'2; apply Definition_of_equivalence; unfold colinear in |- *;
 auto. *)
Require Import part2.
(* part2:
Require Import basis.
Require Import part1.

Theorem thm4_1a :
 forall (x : Segment) (l : Line),
 DiLn l (ln x) -> Apart (origin x) l \/ Apart (extremity x) l.

Theorem thm4_1b :
 forall (x : Segment) (l : Line),
 Apart (origin x) l \/ Apart (extremity x) l -> DiLn l (ln x).
Hint Resolve thm4_1a thm4_1b.

Theorem thm4_1c :
 forall (x : Twolines) (a : Point),
 DiPt a (pt x) -> Apart a (line1 x) \/ Apart a (line2 x).

Theorem thm4_1d :
 forall (x : Twolines) (a : Point),
 Apart a (line1 x) \/ Apart a (line2 x) -> DiPt a (pt x).

Theorem Symmetry_of_Apart :
 forall x y : Segment,
 Apart (origin x) (ln y) \/ Apart (extremity x) (ln y) ->
 Apart (origin y) (ln x) \/ Apart (extremity y) (ln x).

Theorem thm4_3a :
 forall (x : Segment) (c : Point), Apart c (ln x) -> DiPt c (origin x).

Theorem thm4_3b :
 forall (x : Segment) (c : Point), Apart c (ln x) -> DiPt c (extremity x).

Definition Side1 : Triangle -> Segment.

Definition Side2 : Triangle -> Segment.

Theorem auxs1 : forall t : Triangle, origin (base t) = extremity (Side1 t).

Theorem auxs2 : forall t : Triangle, extremity (base t) = extremity (Side2 t).

Theorem auxs3 : forall t : Triangle, summit t = origin (Side1 t).

Theorem auxs4 : forall t : Triangle, summit t = origin (Side2 t).

Theorem thm4_3c : forall t : Triangle, DiLn (ln (base t)) (ln (Side1 t)).

Theorem thm4_3d : forall t : Triangle, DiLn (ln (base t)) (ln (Side2 t)).

Hint Resolve thm4_3c thm4_3d. *)
Require Import part3.
(* part3:
Require Import basis.
Require Import part1.
Require Import part2.

Theorem Triangle_axioms_i :
 forall t : Triangle, Apart (origin (base t)) (ln (Side2 t)).

Theorem Triangle_axioms_ii :
 forall t : Triangle, Apart (extremity (base t)) (ln (reverse (Side1 t))).

Theorem Triangle_axioms_iii :
 forall t : Triangle, Apart (summit t) (ln (reverse (base t))).
Hint Resolve Triangle_axioms_i Triangle_axioms_ii Triangle_axioms_iii.

Theorem thm4_5ia :
 forall (x : Segment) (l : Line),
 EqLn l (ln x) -> Incident (origin x) l /\ Incident (extremity x) l.

Theorem thm4_5ib :
 forall (x : Segment) (l : Line),
 Incident (origin x) l /\ Incident (extremity x) l -> EqLn l (ln x).
Hint Resolve thm4_1c thm4_1d.

Theorem thm4_5iia :
 forall (x : Twolines) (a : Point),
 EqPt a (pt x) -> Incident a (line1 x) /\ Incident a (line2 x).

Theorem thm4_5iib :
 forall (x : Twolines) (a : Point),
 Incident a (line1 x) /\ Incident a (line2 x) -> EqPt a (pt x).

Theorem thm4_6 :
 forall x y : Segment,
 Incident (origin x) (ln y) /\ Incident (extremity x) (ln y) ->
 Incident (origin y) (ln x) /\ Incident (extremity y) (ln x).

Theorem thm4_7i :
 forall (a b c : Point) (H1 : DiPt a b) (H2 : DiPt b c),
 Incident c (ln (Seg a b H1)) -> Incident a (ln (reverse (Seg b c H2))).

Theorem thm4_7ii :
 forall (a b c : Point) (H1 : DiPt a b) (H2 : DiPt a c),
 Incident c (ln (Seg a b H1)) -> Incident b (ln (Seg a c H2)).

Theorem thm4_7iii :
 forall (x : Segment) (c : Point),
 Incident c (ln x) -> Incident c (ln (reverse x)).

Theorem Symmetry_of_Apart' :
 forall x y : Twolines,
 Apart (pt y) (line1 x) \/ Apart (pt y) (line2 x) ->
 Apart (pt x) (line1 y) \/ Apart (pt x) (line2 y).

Theorem thm4_9a :
 forall (x : Twolines) (c : Line), Apart (pt x) c -> DiLn c (line1 x).

Theorem thm4_9b :
 forall (x : Twolines) (c : Line), Apart (pt x) c -> DiLn c (line2 x).

Theorem thm5_3 :
 forall (x y : Segment) (z : Twolines),
 origin x = origin y ->
 line1 z = ln x -> line2 z = ln y -> EqPt (pt z) (origin x).

Theorem thm5_4 :
 forall (x y : Twolines) (z : Segment),
 line1 x = line1 y ->
 origin z = pt x -> extremity z = pt y -> EqLn (ln z) (line1 x).

Theorem thm5_5 :
 forall (a b c : Point) (H1 : DiPt a b) (H2 : EqPt b c),
 EqLn (ln (Seg a b H1)) (ln (Seg a c (cong_eqpt_dipt a b c H1 H2))).

Theorem thm5_6 :
 forall (l m n : Line) (H1 : ConLn l m) (H2 : EqLn m n),
 EqPt (pt (Twol l m H1)) (pt (Twol l n (cong_eqln_con l m n H1 H2))). *)
Require Import affinity.
(* affinity:
Require Import basis.
Require Import part1.
Require Import part2.
Require Import part3.

Axiom
  constructed_parallel :
    forall (l : Line) (a : Point), {l' : Line | Par l' l /\ Incident a l'}.

Definition par : Line -> Point -> Line.

Axiom
  constructive_uniqueness_for_parallels :
    forall (l m : Line) (a : Point),
    DiLn l m -> (Apart a l \/ Apart a m) \/ ConLn l m.

Theorem Ax1_i : forall (l : Line) (a : Point), Par (par l a) l.

Theorem Ax1_ii : forall (l : Line) (a : Point), Incident a (par l a).
Hint Resolve Ax1_i Ax1_ii.

Theorem thm7_1 :
 forall (l m : Line) (a : Point), Incident a l /\ Par l m -> EqLn l (par m a).
Hint Resolve thm7_1.

Theorem thm7_3 :
 forall (l m : Line) (a : Point),
 Incident a l -> Incident a m -> Par l m -> EqLn l m.

Theorem thm7_4 :
 forall (l m n : Line) (a : Point),
 Apart a l -> Incident a m -> Incident a n -> Par n l -> Par m l -> EqLn m n.

Theorem DiLn_qimp_con :
 forall l m : Line,
 DiLn l m -> ex (fun b : Point => Incident b l /\ Incident b m) -> ConLn l m.

Theorem strict_parallel :
 forall (a : Point) (l : Line), Apart a l -> DiLn l (par l a).
Hint Resolve strict_parallel.

Theorem spar : forall (a : Point) (l : Line), Apart a l -> SPar l (par l a).
Hint Resolve spar. *)

Parameter Unort : Line -> Line -> Prop.

Axiom O1 : forall l m : Line, ConLn l m \/ Unort l m.

Axiom O2 : Separating Line (fun l m : Line => ConLn l m /\ Unort l m).

Definition Ort := Negation Line Unort.

Axiom
  constructed_orthogonal :
    forall (l : Line) (a : Point), {l' : Line | Ort l' l /\ Incident a l'}.

Definition ort : Line -> Point -> Line.
Proof.
intros l a; elim (constructed_orthogonal l a).
intros x H'; exact x.
Defined.

Axiom
  constructive_uniqueness_for_orthogonals :
    forall (l m n : Line) (a : Point),
    DiLn l m -> (Apart a l \/ Apart a m) \/ Unort l n \/ Unort m n.

Theorem O3_i : forall (l : Line) (a : Point), Ort (ort l a) l.
Proof.
intros l a.
unfold ort at 1 in |- *.
elim (constructed_orthogonal l a).
simpl in |- *; tauto.
Qed.

Theorem O3_ii : forall (l : Line) (a : Point), Incident a (ort l a).
Proof.
intros l a.
unfold ort at 1 in |- *.
elim (constructed_orthogonal l a).
simpl in |- *; tauto.
Qed.
Hint Resolve O3_i O3_ii.

Theorem O4' :
 forall (l m n : Line) (a : Point),
 (Incident a l /\ Incident a m) /\ Ort l n /\ Ort m n -> EqLn l m.
Proof.
unfold Incident, Ort, EqLn, Negation in |- *.
intros l m n a.
generalize (constructive_uniqueness_for_orthogonals l m n a).
tauto.
Qed.

Theorem Uniqueness_of_orthogonality :
 forall (l m : Line) (a : Point), Incident a l /\ Ort l m -> EqLn l (ort m a).
Proof.
intros l m a H'; elim H'; intros H'0 H'1; clear H'.
apply O4' with (n := m) (a := a); auto.
Qed.

Theorem Unort_reflexive : Reflexive Line Unort.
Proof.
red in |- *.
intro l.
generalize (O1 l l); intro H'.
elim H'; [ intro H'0; clear H' | trivial ].
elim apart_con.
intro H'; elim (H' l); auto.
Qed.

Theorem cmp_unort_con :
 forall l m n : Line, Unort l m -> ConLn l n \/ Unort m n.
Proof.
intros l m n H'.
generalize (O1 m n); intro H'1.
elim H'1; [ intro H'0; clear H'1 | auto ].
elim apart_con.
intros H'1 H'2; red in H'2.
lapply (H'2 m n l); [ intro H'6 | assumption ].
elim H'6; [ intro H'3; clear H'6 | auto ].
generalize O2.
intro H'4; red in H'4.
lapply (H'4 l m n); intuition.
Qed.

Theorem cmp_unort_diln :
 forall l m n : Line, Unort l m -> DiLn l n \/ Unort m n.
Proof.
intros l m n H'.
lapply (cmp_unort_con l m n); [ intro H'3 | assumption ]; auto.
intuition.
Qed.

Theorem Unort_symmetric : Symmetric Line Unort.
Proof.
unfold Symmetric at 1 in |- *.
intros l m H'.
lapply (cmp_unort_con l m l);
 [ intro H'3; elim H'3; [ intro H'4; clear H'3 | trivial ] | idtac ];
 auto.
cut (Irreflexive Line ConLn); auto.
intro H'0; red in H'0.
elim (H'0 l); auto.
elim apart_con; auto.
Qed.

Theorem thm8_6 : forall l m n : Line, ConLn l m -> Unort l n \/ Unort m n.
Proof.
intros l m n H'.
lapply (Convergent_imp_distinct l m); [ intro H'2 | assumption ].
lapply (constructive_uniqueness_for_orthogonals l m n (pt (Twol l m H')));
 [ intro H'5 | assumption ].
elim H'5; [ intro H'0; clear H'5 | trivial ].
generalize (inc_pt1 (Twol l m H')); generalize (inc_pt2 (Twol l m H')).
simpl in |- *; unfold Incident, Negation in |- *; tauto.
Qed.

Definition Oblique : Relation Line :=
  fun l m : Line => ConLn l m /\ Unort l m.

Theorem apart_obl : Apartness Line Oblique.
Proof.
apply Definition_of_apartness.
unfold Irreflexive, Negation, Oblique in |- *.
intro l; red in |- *; intro H'; elim H'; intros H'0 H'1; clear H'.
elim apart_con.
intros H' H'2; apply (H' l); assumption.
unfold Oblique in |- *; exact O2.
Qed.

Theorem ort_ort_like_par_i :
 forall (l : Line) (a : Point), Incident a (ort (ort l a) a).
Proof.
auto.
Qed.

Theorem thm8_8 :
 forall (l : Line) (a b : Point),
 Incident b (ort l a) -> EqLn (ort l a) (ort l b).
Proof.
intros l a b H'.
apply O4' with (n := l) (a := b); auto.
Qed.

Section delicate.
Variable a : Point.
Variable l : Line.
Variable H : ConLn l (ort (ort l a) a).

Let t : Twolines := Twol l (ort (ort l a) a) H.

Let b : Point := pt t.

Theorem thm8_9_aux : False.
Proof.
generalize (inc_pt1 t); intro H'0; simpl in H'0.
generalize (inc_pt2 t); intro H'1; simpl in H'1.
lapply (Convergent_imp_distinct l (ort (ort l a) a));
 [ intro H'4 | assumption ].
lapply (thm8_8 (ort l a) a b); [ intro H'6 | assumption ].
lapply (cong_eqln_diln l (ort (ort l a) a) (ort (ort l a) b));
 [ intro H'7; lapply H'7; [ intro H'8; clear H'7 | clear H'7 ] | idtac ];
 auto.
lapply
 (constructive_uniqueness_for_orthogonals l (ort (ort l a) b) (ort l a) b);
 [ intro H'9 | assumption ].
elim H'9;
 [ intro H'2; elim H'2;
    [ intro H'3; clear H'2 H'9 | intro H'3; clear H'2 H'9 ]
 | intro H'2; clear H'9 ].
unfold b at 1 in H'3; elim H'0; auto.
elim (O3_ii (ort l a) b); auto.
generalize Unort_symmetric.
intro H'; red in H'.
elim H'2; (intro H'3; clear H'2).
elim (O3_i l a); auto.
elim (O3_i (ort l a) b); auto.
Qed.

End delicate.

Theorem thm8_9 : forall (l : Line) (a : Point), Par l (ort (ort l a) a).
Proof.
intros l a; unfold Par, Negation in |- *.
red in |- *; intro H'; apply (thm8_9_aux a l); trivial.
Qed.
Hint Resolve thm8_9.

Theorem thm8_10 :
 forall (l : Line) (a : Point), EqLn (par l a) (ort (ort l a) a).
Proof.
intros l a; apply sym_EqLn; auto.
Qed.

