

Require Import basis.
(* basis:
Definition Relation (U : Set) := U -> U -> Prop.

Definition Reflexive (U : Set) (R : Relation U) : Prop := forall x : U, R x x.

Definition Transitive (U : Set) (R : Relation U) : Prop :=
  forall x y z : U, R x y -> R y z -> R x z.

Definition Symmetric (U : Set) (R : Relation U) : Prop :=
  forall x y : U, R x y -> R y x.

Inductive Equivalence (U : Set) (R : Relation U) : Prop :=
    Definition_of_equivalence :
      Reflexive U R -> Symmetric U R -> Transitive U R -> Equivalence U R.

Definition Negation (U : Set) (R : Relation U) : Relation U :=
  fun x y : U => ~ R x y.
Hint Unfold Negation.

Theorem Sym_imp_NegSym :
 forall (U : Set) (R : Relation U),
 Symmetric U R -> Symmetric U (Negation U R).
Hint Resolve Sym_imp_NegSym.

Definition Irreflexive (U : Set) (R : Relation U) : Prop :=
  forall x : U, ~ R x x.

Definition Separating (U : Set) (R : Relation U) : Prop :=
  forall x y z : U, R x y -> R x z \/ R y z.

Inductive Apartness (U : Set) (R : Relation U) : Prop :=
    Definition_of_apartness :
      Irreflexive U R -> Separating U R -> Apartness U R.
Hint Unfold Reflexive Irreflexive Symmetric Transitive.
Hint Resolve Definition_of_equivalence Definition_of_apartness.

Parameter Point : Set.
Parameter Line : Set.
Parameter DiPt : Point -> Point -> Prop.
Parameter DiLn : Line -> Line -> Prop.
Parameter ConLn : Line -> Line -> Prop.

Axiom apart_dipt : Apartness Point DiPt.

Axiom apart_diln : Apartness Line DiLn.

Axiom apart_con : Apartness Line ConLn.

Hint Resolve apart_dipt apart_diln apart_con.

Theorem Apart_imp_Sym :
 forall (U : Set) (R : Relation U), Apartness U R -> Symmetric U R.
Hint Resolve Apart_imp_Sym.

Theorem sym_DiPt : forall x y : Point, DiPt x y -> DiPt y x.

Theorem sym_DiLn : forall x y : Line, DiLn x y -> DiLn y x.

Theorem sym_ConLn : forall x y : Line, ConLn x y -> ConLn y x.
Hint Immediate sym_DiPt sym_DiLn sym_ConLn.

Theorem Neg_apart_equiv :
 forall (U : Set) (R : Relation U),
 Apartness U R -> Equivalence U (Negation U R).
Hint Resolve Neg_apart_equiv.

Definition EqPt := Negation Point DiPt.

Definition EqLn := Negation Line DiLn.

Definition Par := Negation Line ConLn.

Theorem equiv_EqPt : Equivalence Point EqPt.
Hint Resolve equiv_EqPt.

Theorem equiv_EqLn : Equivalence Line EqLn.
Hint Resolve equiv_EqLn.

Theorem equiv_Par : Equivalence Line Par.
Hint Resolve equiv_Par.

Theorem sym_EqPt : forall x y : Point, EqPt x y -> EqPt y x.

Theorem sym_EqLn : forall x y : Line, EqLn x y -> EqLn y x.

Theorem sym_Par : forall x y : Line, Par x y -> Par y x.
Hint Immediate sym_EqPt sym_EqLn sym_Par.

Parameter Apart : Point -> Line -> Prop.

Definition Incident (a : Point) (l : Line) := ~ Apart a l.

Record Segment : Set := Seg
  {origin : Point; extremity : Point; Seg_cond : DiPt origin extremity}.

Record Twolines : Set := Twol
  {line1 : Line; line2 : Line; Twol_cond : ConLn line1 line2}.

Axiom
  line :
    forall x : Segment,
    {l : Line | Incident (origin x) l /\ Incident (extremity x) l}.

Axiom
  point :
    forall x : Twolines,
    {a : Point | Incident a (line1 x) /\ Incident a (line2 x)}.

Definition ln : Segment -> Line.

Definition pt : Twolines -> Point.

Theorem inc_ln1 : forall x : Segment, Incident (origin x) (ln x).

Theorem inc_ln2 : forall x : Segment, Incident (extremity x) (ln x).

Theorem inc_pt1 : forall x : Twolines, Incident (pt x) (line1 x).

Theorem inc_pt2 : forall x : Twolines, Incident (pt x) (line2 x).
Hint Resolve inc_ln1 inc_ln2 inc_pt1 inc_pt2.

Axiom
  el_ax :
    forall (x : Segment) (l m : Line),
    DiLn l m ->
    (Apart (origin x) l \/ Apart (extremity x) l) \/
    Apart (origin x) m \/ Apart (extremity x) m.

Axiom
  cmp_apt_dipt :
    forall (a b : Point) (l : Line), Apart a l -> DiPt a b \/ Apart b l.

Axiom
  cmp_apt_diln :
    forall (a : Point) (l m : Line), Apart a l -> DiLn l m \/ Apart a m.

Axiom cmp_con_diln : forall l m n : Line, ConLn l m -> DiLn m n \/ ConLn l n.

Record Triangle : Set := Tri
  {summit : Point; base : Segment; Tri_cond : Apart summit (ln base)}.

Theorem Triangle_def : forall t : Triangle, Apart (summit t) (ln (base t)).
Hint Resolve Triangle_def.

Definition SPar : Relation Line := fun l m : Line => Par l m /\ DiLn l m.

Record Parallelogram : Set := Pgram
  {side1 : Segment;
   side2 : Segment;
   side3 : Segment;
   side4 : Segment;
   connect1 : origin side3 = origin side1 /\ extremity side3 = origin side2;
   connect2 :
    origin side4 = extremity side1 /\ extremity side4 = extremity side2;
   parsides_i : SPar (ln side1) (ln side2);
   parsides_ii : SPar (ln side3) (ln side4)}. *)



Theorem Uniqueness_of_constructed_lines :

 forall (x : Segment) (l : Line),

 Incident (origin x) l -> Incident (extremity x) l -> EqLn l (ln x).

Proof.

intros x l.

generalize (inc_ln2 x); generalize (inc_ln1 x).

unfold Incident, EqLn, Negation in |- *.

intros H' H'0 H'1 H'2; red in |- *; intro H'3.

lapply (el_ax x l (ln x)); trivial.

tauto.

Qed.



Theorem Convergent_imp_distinct : forall l m : Line, ConLn l m -> DiLn l m.

Proof.

intros l m H'.

lapply (cmp_con_diln l m l); trivial.

intro H'0; elim H'0; auto.

intro H'1; elim apart_con.

intro H'2; elim (H'2 l); trivial.

Qed.

Hint Resolve Convergent_imp_distinct.



Theorem Uniqueness_of_constructed_points :

 forall (x : Twolines) (a : Point),

 Incident a (line1 x) -> Incident a (line2 x) -> EqPt a (pt x).

Proof.

intro x.

generalize (inc_pt2 x); generalize (inc_pt1 x).

unfold Incident, EqPt, Negation in |- *.

intros H' H'0 a H'1 H'2; red in |- *; intro H'3.

lapply (el_ax (Seg a (pt x) H'3) (line1 x) (line2 x)); simpl in |- *.

tauto.

elim x; auto.

Qed.



Theorem cong_eqpt_apt :

 forall (a b : Point) (l : Line), Apart a l -> EqPt a b -> Apart b l.

Proof.

intros a b l H' H'0.

elim (cmp_apt_dipt a b l); auto.

intro H'1; elim H'0; trivial.

Qed.



Theorem cong_eqln_apt :

 forall (a : Point) (l m : Line), Apart a l -> EqLn l m -> Apart a m.

Proof.

intros a l m H' H'0.

elim (cmp_apt_diln a l m); auto.

intro H'1; elim H'0; trivial.

Qed.



Theorem cong_eqpt_inc :

 forall (a b : Point) (l : Line), Incident a l -> EqPt a b -> Incident b l.

Proof.

unfold Incident in |- *.

intros a b l H' H'0; red in |- *; intro H'1; apply H'.

apply cong_eqpt_apt with (a := b); auto.

Qed.



Theorem cong_eqln_inc :

 forall (a : Point) (l m : Line), Incident a l -> EqLn l m -> Incident a m.

Proof.

unfold Incident in |- *.

intros a l m H' H'0; red in |- *; intro H'1; apply H'.

apply cong_eqln_apt with (l := m); auto.

Qed.



Theorem cong_eqln_con :

 forall l m n : Line, ConLn l m -> EqLn m n -> ConLn l n.

Proof.

intros l m n H' H'0.

elim (cmp_con_diln l m n); auto.

intro H'1; elim H'0; trivial.

Qed.



Theorem cong_eqln_par : forall l m n : Line, Par l m -> EqLn m n -> Par l n.

Proof.

unfold Par, Negation in |- *.

intros l m n H' H'0; red in |- *; intro H'1; apply H'.

apply cong_eqln_con with (m := n); auto.

Qed.



Theorem cong_eqpt_dipt :

 forall a b c : Point, DiPt a b -> EqPt b c -> DiPt a c.

Proof.

intros a b c H' H'0; elim apart_dipt.

unfold Separating at 1 in |- *.

intros H'1 H'2; elim (H'2 a b c); trivial.

intro H'3; elim H'0; trivial.

Qed.



Theorem cong_eqln_diln :

 forall l m n : Line, DiLn l m -> EqLn m n -> DiLn l n.

Proof.

intros l m n H' H'0; elim apart_diln.

unfold Separating at 1 in |- *.

intros H'1 H'2; elim (H'2 l m n); trivial.

intro H'3; elim H'0; trivial.

Qed.



Theorem eqln_imp_par : forall l m : Line, EqLn l m -> Par l m.

Proof.

unfold Par, EqLn, Negation in |- *; red in |- *; auto.

Qed.



Theorem cong_par_con : forall l m n : Line, ConLn l m -> Par m n -> ConLn l n.

Proof.

intros l m n H' H'0.

elim apart_con.

unfold Separating at 1 in |- *.

intros H'1 H'2; elim (H'2 l m n); trivial.

intro H'3; elim H'0; trivial.

Qed.



Theorem sym_SPar : forall x y : Line, SPar x y -> SPar y x.

Proof.

unfold SPar in |- *.

intuition.

Qed.

Hint Resolve sym_SPar.



Theorem cong_eqln_spar :

 forall l m n : Line, SPar l m -> EqLn m n -> SPar l n.

Proof.

unfold SPar in |- *.

intros l m n H'; elim H'; intros H'0 H'1; try exact H'0; clear H'.

intro H'; split.

apply cong_eqln_par with (m := m); trivial.

apply cong_eqln_diln with (m := m); trivial.

Qed.



Definition reverse : Segment -> Segment.

Proof.

intro H'; elim H'.

intros a b H'0.

apply (Seg b a); auto.

Defined.



Theorem orig_rev : forall x : Segment, origin x = extremity (reverse x).

Proof.

intro x; elim x; simpl in |- *; auto.

Qed.



Theorem ext_rev : forall x : Segment, extremity x = origin (reverse x).

Proof.

intro x; elim x; simpl in |- *; auto.

Qed.



Theorem rev_defines_sameln : forall x : Segment, EqLn (ln x) (ln (reverse x)).

Proof.

intro x; apply Uniqueness_of_constructed_lines.

rewrite <- (ext_rev x); auto.

rewrite <- (orig_rev x); auto.

Qed.

Hint Resolve rev_defines_sameln.



Definition flip : Twolines -> Twolines.

Proof.

intro H'; elim H'.

intros l m H'0.

apply (Twol m l); auto.

Defined.



Theorem line1_flip : forall x : Twolines, line1 x = line2 (flip x).

Proof.

intro x; elim x; simpl in |- *; auto.

Qed.



Theorem line2_flip : forall x : Twolines, line2 x = line1 (flip x).

Proof.

intro x; elim x; simpl in |- *; auto.

Qed.



Theorem flip_defines_samept : forall x : Twolines, EqPt (pt x) (pt (flip x)).

Proof.

intro x; apply Uniqueness_of_constructed_points.

rewrite <- (line2_flip x); auto.

rewrite <- (line1_flip x); auto.

Qed.

Hint Resolve rev_defines_sameln flip_defines_samept.



Definition colinear (x y : Segment) : Prop := EqLn (ln x) (ln y).



Theorem Colinearity_is_equivalence : Equivalence Segment colinear.

Proof.

cut (Equivalence Line EqLn); auto.

intro H'; elim H'.

intros H'0 H'1 H'2; apply Definition_of_equivalence; unfold colinear in |- *;

 auto.

red in |- *.

intros x y z H'3 H'4.

red in H'2.

apply H'2 with (y := ln y); auto.

Qed.



