Require Export c_completeness.
(* c_completeness:
Require Export b_soundness.
Require Export Decidable.
Set Implicit Arguments.

Module Type complete_mod (X: base_mod) (Y: sound_mod X).
Import X Y.

Inductive NNF : Set :=
 | NPos : PropVars -> NNF
 | NNeg : PropVars -> NNF
 | NBot : NNF
 | NTop : NNF
 | NConj : NNF -> NNF -> NNF
 | NDisj : NNF -> NNF -> NNF
.

Fixpoint MakeNNF (A:PropF) : NNF := match A with
 | # P   => NPos P
 | ⊥     => NBot
 | B ∨ C => NDisj (MakeNNF B) (MakeNNF C)
 | B ∧ C => NConj (MakeNNF B) (MakeNNF C)
 | B → C => NDisj (MakeNNFN B) (MakeNNF C)
 end
with MakeNNFN (A:PropF) : NNF := match A with
 | # P   => NNeg P
 | ⊥     => NTop
 | B ∨ C => NConj (MakeNNFN B) (MakeNNFN C)
 | B ∧ C => NDisj (MakeNNFN B) (MakeNNFN C)
 | B → C => NConj (MakeNNF B) (MakeNNFN C)
 end.

Fixpoint NNFtoPropF (A:NNF) : PropF := match A with
 | NPos P    => #P
 | NNeg P    => ¬ #P
 | NBot      => ⊥
 | NTop      => ¬⊥
 | NConj B C => NNFtoPropF B ∧ NNFtoPropF C
 | NDisj B C => NNFtoPropF B ∨ NNFtoPropF C
end.

Inductive Literal :=
| LPos : PropVars -> Literal
| LNeg : PropVars -> Literal
| LBot : Literal
| LTop : Literal
.
Fixpoint Bar P := match P with
| LPos Q => LNeg Q
| LNeg Q => LPos Q
| LBot   => LTop
| LTop   => LBot
end.

Fixpoint LiteraltoPropF (P:Literal) : PropF := match P with
| LPos Q => #Q
| LNeg Q => ¬#Q
| LBot   => ⊥
| LTop   => ¬⊥
end.

Definition Clause := list Literal.

Definition ClausetoPropF := map_fold_right LiteraltoPropF Disj ⊥.

Definition CNF := list Clause.

Definition CNFtoPropF := map_fold_right ClausetoPropF Conj ⊤.

Definition AddClause (l:Clause) (ll:CNF) : CNF := map (fun l2 => l++l2) ll.
Definition Disjunct (ll ll2:CNF) : CNF := flat_map (fun l => AddClause l ll2) ll.

Fixpoint MakeCNF (A:NNF) : CNF := match A with
 | NPos P    => [[LPos P]]
 | NNeg P    => [[LNeg P]]
 | NBot      => [[LBot]]
 | NTop      => [[LTop]]
 | NConj B C => MakeCNF B ++ MakeCNF C
 | NDisj B C => Disjunct (MakeCNF B) (MakeCNF C)
 end.

Definition Valid_Clause (l:Clause) := In LTop l\/exists A,(In (LPos A) l/\In (LNeg A) l).
Definition Valid_CNF ll := forall l, In l ll->Valid_Clause l.

Lemma Literal_eqdec : forall x y : Literal, {x = y} + {x <> y}.

Lemma NNF_equiv_valid : forall v A, TrueQ v (NNFtoPropF (MakeNNF  A))=TrueQ v  A /\
                                    TrueQ v (NNFtoPropF (MakeNNFN A))=TrueQ v ¬A.

Lemma CNF_and_valid : forall v ll1 ll2, TrueQ v (CNFtoPropF (ll1 ++ ll2)) = 
                                        TrueQ v (CNFtoPropF ll1) && TrueQ v (CNFtoPropF ll2).

Lemma CNF_or_clause_valid : forall v l1 l2, TrueQ v (ClausetoPropF (l1++l2)) = 
                                            TrueQ v (ClausetoPropF l1) || TrueQ v (ClausetoPropF l2).

Lemma CNF_add_clause_valid : forall v l ll, TrueQ v (CNFtoPropF (AddClause l ll)) = 
                                            TrueQ v (ClausetoPropF l) || TrueQ v (CNFtoPropF ll).

Lemma CNF_or_valid : forall v ll1 ll2, TrueQ v (CNFtoPropF (Disjunct ll1 ll2)) = 
                                       TrueQ v (CNFtoPropF ll1) || TrueQ v (CNFtoPropF ll2).

Theorem CNF_equiv_valid : forall v A, TrueQ v (CNFtoPropF (MakeCNF A)) = TrueQ v (NNFtoPropF A).

Definition Countervaluation l P := if (in_dec Literal_eqdec (LNeg P) l) then true else false.
Definition Validates v Δ := exists A, In A Δ /\ Is_true (TrueQ v A).

Lemma TrueQ_impl_Validates : forall v m, Is_true (TrueQ v (ClausetoPropF m)) -> Validates v (map LiteraltoPropF m).

Lemma Validated_valid : forall l, Validates (Countervaluation l) (map LiteraltoPropF l) -> Valid_Clause l.

Theorem Clause_valid : forall l, Valid (ClausetoPropF l) -> Valid_Clause l.

Theorem CNF_valid : forall ll, Valid (CNFtoPropF ll) -> Valid_CNF ll.

Lemma Clause_provable_3 : forall a l1 l2 Γ, In (LiteraltoPropF a) Γ -> Γ ⊢ ClausetoPropF (l1++a::l2).

Lemma Clause_provable_2 : forall a l1 l2 l3, Provable (ClausetoPropF (l1++(Bar a)::l2++a::l3)).

Theorem Clause_provable : forall l, Valid_Clause l -> Provable (ClausetoPropF l).

Theorem CNF_provable : forall ll, Valid_CNF ll -> Provable (CNFtoPropF ll).

Lemma prov_or : forall A1 A2 B1 B2 Γ, Provable (A1 → A2) -> Provable (B1 → B2) -> In (A1∨B1) Γ -> Γ ⊢ A2∨B2.

Lemma CNF_and_prov : forall ll1 ll2, Provable (CNFtoPropF (ll1 ++ ll2) → CNFtoPropF ll1 ∧ CNFtoPropF ll2).

Lemma CNF_or_clause_prov : forall l1 l2, Provable (ClausetoPropF (l1++l2) → ClausetoPropF l1 ∨ ClausetoPropF l2).

Lemma CNF_add_clause_prov : forall l ll, Provable (CNFtoPropF (AddClause l ll) → ClausetoPropF l ∨ CNFtoPropF ll).

Lemma CNF_or_prov : forall ll1 ll2, Provable (CNFtoPropF (Disjunct ll1 ll2) → CNFtoPropF ll1 ∨ CNFtoPropF ll2).

Theorem CNF_impl_prov : forall A, Provable (CNFtoPropF (MakeCNF A) → NNFtoPropF A).

Lemma prov_and : forall A1 A2 B1 B2 Γ, Provable (A1 → A2) -> Provable (B1 → B2) -> In (A1∧B1) Γ -> Γ ⊢ A2∧B2.

Lemma NNF_impl_prov : forall A, Provable (NNFtoPropF (MakeNNF  A) →  A) /\
                                Provable (NNFtoPropF (MakeNNFN A) → ¬A).

Theorem Completeness : Prop_Completeness.

Theorem prov_equiv_models : forall Γ A, Γ ⊢ A <-> Γ ⊨ A.

Print Assumptions prov_equiv_models.

End complete_mod. *)
Set Implicit Arguments.

Module Type hilbert_mod (B: base_mod) (S: sound_mod B) (C: complete_mod B S).
Import B S C.

Reserved Notation "Γ ⊢H A" (at level 80).

Inductive AxiomH : PropF -> Prop :=
| HOrI1  : forall A B  , AxiomH (A → A∨B)
| HOrI2  : forall A B  , AxiomH (B → A∨B)
| HAndI  : forall A B  , AxiomH (A → B → A∧B)
| HOrE   : forall A B C, AxiomH (A∨B → (A → C) → (B → C) → C)
| HAndE1 : forall A B  , AxiomH (A∧B → A)
| HAndE2 : forall A B  , AxiomH (A∧B → B)
| HS      : forall A B C, AxiomH ((A → B → C) → (A → B) → A → C)
| HK      : forall A B  , AxiomH (A → B → A)
| HClas  : forall A    , AxiomH (¬(¬A) → A)
.

Inductive Hc : list PropF-> PropF->Prop :=
| Hass  : forall A Γ,   In A Γ               -> Γ ⊢H A
| Hax   : forall A Γ,   AxiomH A             -> Γ ⊢H A
| HImpE : forall Γ A B, Γ ⊢H A → B -> Γ ⊢H A -> Γ ⊢H B
where "Γ ⊢H A" := (Hc Γ A) : My_scope.

Definition ProvH A := [] ⊢H A.

Ltac Hmp := eapply HImpE. 
Ltac aK := constructor 2;apply HK.
Ltac aS := constructor 2;apply HS.
Ltac aC := constructor 2;apply HClas.
Ltac is_ax := constructor 2;constructor||assumption.

Lemma Nc_AxiomH : forall A, AxiomH A -> Provable A.
induction 1;repeat apply ImpI.
 apply OrI1;is_ass.
 apply OrI2;is_ass.
 apply AndI;is_ass.
 eapply OrE;[|eapply ImpE with A|mp]; is_ass.
 eapply AndE1;is_ass.
 eapply AndE2;is_ass.
 mp;mp;is_ass.
 is_ass.
 apply BotC;apply ImpE with ¬A;is_ass.
Qed.

Theorem Hc_to_Nc : forall Γ A, Γ ⊢H A -> Γ ⊢ A.
induction 1. 
 is_ass.
 AddnilL;eapply weakening;apply Nc_AxiomH;assumption.
 mp;eassumption.
Qed.

Lemma H_weakening : forall Γ Δ A, (forall B, In B Γ -> In B Δ) -> Γ ⊢H A -> Δ ⊢H A.
induction 2.
 constructor;auto.
 is_ax.
 Hmp;auto.
Qed.

Theorem H_Deduction_Theorem : forall Γ A B, A::Γ ⊢H B <-> Γ ⊢H A → B.
split;intro.
 remember (A::Γ). revert Γ Heql. induction H;intros;subst.
  destruct H.
    subst. do 2 (Hmp;[|aK]). instantiate (2:=⊥). aS.
    Hmp;[aK|is_ass].
  Hmp;[aK|is_ax].
  Hmp;[Hmp;[aS|]|];auto.
 Hmp;[|is_ass]. eapply H_weakening;[|eassumption].
  intros;in_solve.
Qed.
Ltac HImpI := apply H_Deduction_Theorem.

Theorem Nc_to_Hc : forall Γ A, Γ ⊢ A -> Γ ⊢H A.
induction 1;try (Hmp;[|eassumption];is_ax;fail).
 is_ass.
 HImpI;assumption.
 Hmp;eassumption.
 Hmp;[aC|HImpI;assumption]. 
 Hmp;[Hmp;[is_ax|]|];assumption.
 Hmp;[Hmp;[Hmp|]|]. 
   is_ax.
   eassumption.
   HImpI;assumption.
   HImpI;assumption.
Qed.

Theorem Nc_equiv_Hc : forall Γ A, Γ ⊢ A <-> Γ ⊢H A.
split;[apply Nc_to_Hc|apply Hc_to_Nc]. 
Qed.

End hilbert_mod.