Require Export Classical.

Require Import ClassicalChoice.

Require Export Relation_Definitions.

Require Import Relation_Definitions_Implicit.
(* Relation_Definitions_Implicit:
Require Export Relation_Definitions.

Arguments reflexive {A}.
Arguments transitive {A}.
Arguments symmetric {A}.
Arguments antisymmetric {A}.
Arguments equiv {A}.
Arguments preorder {A}.
Arguments Build_preorder {A}.
Arguments preord_refl {A} {R}.
Arguments preord_trans {A} {R}.
Arguments order {A}.
Arguments Build_order {A}.
Arguments ord_refl {A} {R}.
Arguments ord_trans {A} {R}.
Arguments ord_antisym {A} {R}.
Arguments equivalence {A}.
Arguments Build_equivalence {A}.
Arguments equiv_refl {A} {R}.
Arguments equiv_trans {A} {R}.
Arguments equiv_sym {A} {R}.
Arguments PER {A}.
Arguments Build_PER {A}.
Arguments per_sym {A} {R}.
Arguments per_trans {A} {R}.
Arguments inclusion {A}.
Arguments same_relation {A}.
Arguments commut {A}. *)

Require Export Ensembles.

Require Import EnsemblesImplicit.
(* EnsemblesImplicit:
Require Export Ensembles.

Arguments In {U}.
Arguments Included {U}.
Arguments Singleton {U}.
Arguments Union {U}.
Arguments Add {U}.
Arguments Intersection {U}.
Arguments Couple {U}.
Arguments Triple {U}.
Arguments Complement {U}.
Arguments Setminus {U}.
Arguments Subtract {U}.
Arguments Disjoint {U}.
Arguments Inhabited {U}.
Arguments Strict_Included {U}.
Arguments Same_set {U}.
Arguments Extensionality_Ensembles {U}.
Arguments Empty_set {U}.
Arguments Full_set {U}. *)

Require Import Proj1SigInjective.
(* Proj1SigInjective:
Require Import ProofIrrelevance.

Lemma subset_eq_compatT: forall (U:Type) (P:U->Prop) (x y:U)
  (p:P x) (q:P y), x = y -> exist P x p = exist P y q.

Lemma proj1_sig_injective: forall {A:Type} (P:A->Prop)
  (a1 a2:{x:A | P x}), proj1_sig a1 = proj1_sig a2 -> a1 = a2. *)

Require Import InverseImage.
(* InverseImage:
Require Export Ensembles.
Require Import EnsemblesImplicit.
Require Export EnsemblesSpec.

Definition inverse_image {X Y:Type} (f:X->Y) (T:Ensemble Y) : Ensemble X :=
  [ x:X | In T (f x) ].
Hint Unfold inverse_image : sets.

Lemma inverse_image_increasing: forall {X Y:Type} (f:X->Y)
  (T1 T2:Ensemble Y), Included T1 T2 ->
  Included (inverse_image f T1) (inverse_image f T2).

Lemma inverse_image_empty: forall {X Y:Type} (f:X->Y),
  inverse_image f Empty_set = Empty_set.

Lemma inverse_image_full: forall {X Y:Type} (f:X->Y),
  inverse_image f Full_set = Full_set.

Lemma inverse_image_intersection: forall {X Y:Type} (f:X->Y)
  (T1 T2:Ensemble Y), inverse_image f (Intersection T1 T2) =
  Intersection (inverse_image f T1) (inverse_image f T2).

Lemma inverse_image_union: forall {X Y:Type} (f:X->Y)
  (T1 T2:Ensemble Y), inverse_image f (Union T1 T2) =
  Union (inverse_image f T1) (inverse_image f T2).

Lemma inverse_image_complement: forall {X Y:Type} (f:X->Y)
  (T:Ensemble Y), inverse_image f (Complement T) =
  Complement (inverse_image f T).

Lemma inverse_image_composition: forall {X Y Z:Type} (f:Y->Z) (g:X->Y)
  (U:Ensemble Z), inverse_image (fun x:X => f (g x)) U =
  inverse_image g (inverse_image f U).

Hint Resolve @inverse_image_increasing : sets.
Hint Rewrite @inverse_image_empty @inverse_image_full
  @inverse_image_intersection @inverse_image_union
  @inverse_image_complement @inverse_image_composition : sets. *)



Section ZL'.



Variable T:Type.

Variable R:relation T.

Hypothesis ord:order R.

Definition chain (S: Ensemble T) : Prop :=

  forall x y:T, In S x -> In S y -> (R x y \/ R y x).

Definition maximal (x:T) : Prop :=

  forall y:T, R x y -> x = y.

Variable chain_sup: forall S: Ensemble T, chain S ->

  { x:T | (forall y:T, In S y -> R y x) /\

    (forall z:T, (forall y:T, In S y -> R y z) -> R x z) }.

Variable inflation: forall x:T,

  { y:T | R x y /\ x <> y /\ forall z:T, R x z -> R z y ->

                                     z = x \/ z = y }.



Inductive tower : Ensemble T :=

  | sup_intro: forall (S: Ensemble T), Included S tower ->

      forall c:chain S,

      In tower (proj1_sig (chain_sup S c))

  | inflation_intro: forall x:T, In tower x ->

      In tower (proj1_sig (inflation x)).



Lemma tower_is_chain: chain tower.

Proof.

unfold chain.

intros.

revert x H.

induction H0.

intros.

case (classic (forall y:T, In S y -> R y x)).

right.

apply (proj2_sig (chain_sup S c)).

assumption.



intro.

apply not_all_ex_not in H2.

destruct H2.

apply imply_to_and in H2.

destruct H2.

left.

apply (ord_trans ord) with x0.

pose proof (H0 x0 H2 x H1).

tauto.

apply (proj2_sig (chain_sup S c)).

assumption.



pose proof (proj2_sig (inflation x)).

simpl in H0.

destruct H0.

destruct H1.

remember (proj1_sig (inflation x)) as x'.



assert (forall y:T, In tower y -> R y x \/ R x' y).

intros.

induction H3.

case (classic (forall x0:T, In S x0 -> R x0 x)).

left.

apply (proj2_sig (chain_sup S c)).

assumption.



right.

apply not_all_ex_not in H5.

destruct H5.

apply imply_to_and in H5.

destruct H5.

apply (ord_trans ord) with x0.

pose proof (H4 x0).

tauto.

apply (proj2_sig (chain_sup S c)).

assumption.



assert (In tower x').

rewrite Heqx'.

apply inflation_intro.

assumption.



destruct IHtower0.

assert (In tower (proj1_sig (inflation x0))).

apply inflation_intro.

assumption.

case (IHtower (proj1_sig (inflation x0)) H6).

left.

assumption.

intro.

pose proof (proj2_sig (inflation x0)).

simpl in H8.

assert (x = x0 \/ x = proj1_sig (inflation x0)).

apply H8.

assumption.

assumption.

case H9.

right.

rewrite Heqx'.

rewrite H10.

apply (ord_refl ord).

left.

rewrite H10.

apply (ord_refl ord).

right.

apply (ord_trans ord) with x0.

assumption.

apply (proj2_sig (inflation x0)).



intros.

case (H3 x0 H4).

left.

apply (ord_trans ord) with x.

assumption.

assumption.

right.

assumption.

Qed.



Lemma ZL': False.

Proof.

pose proof (proj2_sig (chain_sup tower tower_is_chain)).

simpl in H.

remember (proj1_sig (chain_sup tower tower_is_chain)) as x0.

assert (In tower x0).

rewrite Heqx0.

constructor 1.

auto with sets.



pose (x' := proj1_sig (inflation x0)).

assert (In tower x').

constructor 2.

assumption.



pose proof (proj2_sig (inflation x0)).

simpl in H2.

destruct H2.

destruct H3.

contradict H3.

apply (ord_antisym ord).

assumption.

destruct H.

apply H.

assumption.

Qed.



End ZL'.



Arguments chain {T}.

Arguments maximal {T}.



Section ZL.



Variable T:Type.

Variable R:relation T.

Hypothesis ord: order R.

Hypothesis ub_of_chain: forall S:Ensemble T, chain R S ->

  exists x:T, forall y:T, In S y -> R y x.



Definition chains := {S:Ensemble T | chain R S}.

Definition chains_ord := (fun S1 S2:chains =>

  Included (proj1_sig S1) (proj1_sig S2)).



Lemma chains_order: order chains_ord.

Proof.

constructor.

unfold reflexive.

unfold chains_ord.

auto with sets.



unfold transitive.

unfold chains_ord.

auto with sets.



unfold antisymmetric.

unfold chains_ord.

intros.

apply proj1_sig_injective.

auto with sets.

Qed.



Require Export EnsemblesSpec.



Definition chains_sup_def : forall F: Ensemble chains,

  chain chains_ord F -> chains.

refine (fun F H => exist _ [ x:T | exists S:chains, In F S /\

                             In (proj1_sig S) x ] _).

red; intros.

destruct H0.

destruct H1.

destruct H0.

destruct H1.

pose proof (H x0 x1).

destruct x0.

destruct x1.

simpl in H0.

destruct H0.

simpl in H1.

destruct H1.

apply H2 in H0.

unfold chains_ord in H0.

simpl in H0.

destruct H0.

apply c0.

apply H0.

exact H3.

exact H4.



apply c.

exact H3.

apply H0.

exact H4.

assumption.

Defined.



Lemma chains_sup_correct: forall (F:Ensemble chains)

  (P:chain chains_ord F), let U := chains_sup_def F P in

    (forall S:chains, In F S -> chains_ord S U) /\

    (forall T:chains, (forall S:chains, In F S -> chains_ord S T) ->

      chains_ord U T).

Proof.

intros.

split.

intros.

unfold chains_ord.

unfold Included.

intros.

unfold U.

simpl.

constructor.

exists S.

auto.

intros.

unfold chains_ord.

unfold Included.

intros.

unfold U in H0.

simpl in H0.

destruct H0.

destruct H0.

destruct H0.

apply H in H0.

apply H0.

assumption.

Qed.



Definition chains_sup (F:Ensemble chains) (P:chain chains_ord F) :=

  let U := chains_sup_def F P in

  exist (fun U:chains => 

    (forall S:chains, In F S -> chains_ord S U) /\

    (forall T:chains, (forall S:chains, In F S -> chains_ord S T) ->

      chains_ord U T))

  (chains_sup_def F P) (chains_sup_correct F P).



Theorem ZornsLemma: exists x:T, maximal R x.

Proof.

pose proof (ZL' chains chains_ord chains_order chains_sup).



apply NNPP.

unfold maximal.

dintuition.

assert (forall x:T, ~ forall y:T, R x y -> x = y).

apply not_ex_all_not.

exact H0.

assert (forall x:T, exists y:T, ~ (R x y -> x = y)).

intro.

apply not_all_ex_not.

apply H1.

assert (forall x:T, exists y:T, R x y /\ x <> y).

intro.

pose proof (H2 x).

destruct H3.

apply imply_to_and in H3.

exists x0.

assumption.

clear H0 H1 H2.



assert (forall x:chains, exists y:chains,

  chains_ord x y /\ x <> y /\ forall z:chains, chains_ord x z ->

  chains_ord z y -> z = x \/ z = y).

intro.

destruct x.

pose proof (ub_of_chain x c).

destruct H0.

pose proof (H3 x0).

destruct H1.



pose (x' := Add x x1).

assert (chain R x').

unfold chain.

intros.

case H2.

case H4.

intros.

apply c.

assumption.

assumption.

intros.

destruct H5.

left.

apply ord_trans with x0.

apply H0.

assumption.

apply H1.

intros.

destruct H5.

case H4.

right.

apply ord_trans with x0.

apply H0.

assumption.

apply H1.

intros.

destruct H5.

left.

apply ord_refl.



exists (exist _ x' H2).

split.

unfold chains_ord.

simpl.

unfold Included.

intros.

constructor.

assumption.



split.

intuition.

injection H4.

intro.

assert (In x x1).

rewrite H1.

constructor 2.

auto with sets.

contradict H6.

apply ord_antisym.

assumption.

apply H0.

assumption.



intros.

destruct z.

unfold chains_ord in H4.

simpl in H4.

unfold chains_ord in H5.

simpl in H5.



case (classic (In x2 x1)).

right.

apply subset_eq_compatT.

apply Extensionality_Ensembles.

split.

assumption.

unfold Included.

intros.

case H7.

exact H4.

intros.

destruct H8.

assumption.



left.

apply subset_eq_compatT.

apply Extensionality_Ensembles.

split.

unfold Included.

intros.

assert (In x' x3).

apply H5.

assumption.

inversion H8.

assumption.

destruct H9.

contradiction H6.

assumption.



apply choice in H0.

destruct H0 as [f].

apply H.

intro.

apply exist with (f x).

apply H0.

Qed.



End ZL.



Arguments ZornsLemma {T}.



Require Import Quotients.
(* Quotients:
Require Export Ensembles.
Require Import EnsemblesImplicit.
Require Export Image.
Require Import ImageImplicit.
Require Export Relation_Definitions.
Require Import Relation_Definitions_Implicit.
Require Import Description.
Require Import ProofIrrelevance.
Require Import Proj1SigInjective.
Require Export EnsemblesSpec.

Set Implicit Arguments.
Section Quotient.
Variable A:Type.
Variable R:relation A.
Hypothesis equivR:equivalence R.

Definition equiv_class (x:A) : Ensemble A :=
  [ y:A | R x y ].

Lemma R_impl_equality_of_equiv_class:
  forall x y:A, R x y -> equiv_class x = equiv_class y.

Lemma equality_of_equiv_class_impl_R:
  forall x y:A, equiv_class x = equiv_class y -> R x y.

Definition equiv_classes : Ensemble (Ensemble A) :=
  Im Full_set equiv_class.
Definition quotient : Type :=
  { S:Ensemble A | In equiv_classes S }.

Lemma equiv_class_in_quotient: forall x:A,
  In equiv_classes (equiv_class x).

Definition quotient_projection (x:A) : quotient :=
  exist _ (equiv_class x) (equiv_class_in_quotient x).

Lemma quotient_projection_correct: forall x:A,
  proj1_sig (quotient_projection x) = equiv_class x.

Lemma quotient_projection_surjective: forall xbar:quotient,
  exists x:A, quotient_projection x = xbar.

Lemma quotient_projection_collapses_R: forall x1 x2:A,
  R x1 x2 -> quotient_projection x1 = quotient_projection x2.

Lemma quotient_projection_minimally_collapses_R: forall x1 x2:A,
  quotient_projection x1 = quotient_projection x2 -> R x1 x2.

End Quotient.

Section InducedFunction.

Variable A B:Type.
Variable R:Relation A.
Variable f:A->B.
Hypothesis equiv:equivalence R.
Hypothesis well_defined: forall x y:A, R x y -> f x = f y.

Lemma description_of_fbar: forall xbar:quotient R, exists! y:B,
  exists x:A, quotient_projection R x = xbar /\ f x = y.

Definition induced_function (xbar:quotient R) : B :=
  proj1_sig (constructive_definite_description _
               (description_of_fbar xbar)).

Lemma induced_function_correct: forall x:A,
  induced_function (quotient_projection R x) = f x.

Lemma induced_function_unique: forall fbar:quotient R->B,
  (forall x:A, fbar (quotient_projection R x) = f x) ->
  (forall xbar:quotient R, fbar xbar = induced_function xbar).

End InducedFunction.

Section InducedFunction2.

Variable A B:Type.
Variable R:relation A.
Variable S:relation B.
Variable f:A->B.
Hypothesis equivR: equivalence R.
Hypothesis equivS: equivalence S.
Hypothesis well_defined2: forall a1 a2:A, R a1 a2 -> S (f a1) (f a2).

Definition projf (a:A) : quotient S :=
  quotient_projection S (f a).
Lemma projf_well_defined: forall a1 a2:A,
  R a1 a2 -> projf a1 = projf a2.

Definition induced_function2: quotient R -> quotient S :=
  induced_function projf equivR projf_well_defined.

Lemma induced_function2_correct: forall a:A,
  induced_function2 (quotient_projection R a) =
  quotient_projection S (f a).

End InducedFunction2.

Section InducedFunction2arg.

Variable A B C:Type.
Variable R:relation A.
Variable S:relation B.
Variable f:A->B->C.
Hypothesis equivR:equivalence R.
Hypothesis equivS:equivalence S.
Hypothesis well_defined_2arg: forall (a1 a2:A) (b1 b2:B),
  R a1 a2 -> S b1 b2 -> f a1 b1 = f a2 b2.

Lemma slices_well_defined: forall (a:A) (b1 b2:B),
  S b1 b2 -> f a b1 = f a b2.

Definition induced1 (a:A) : quotient S -> C :=
   induced_function (f a) equivS (slices_well_defined a).

Definition eq_fn (f g:quotient S->C) :=
  forall b:quotient S, f b = g b.
Lemma eq_fn_equiv: equivalence eq_fn.

Lemma well_defined_induced1: forall a1 a2:A, R a1 a2 ->
  eq_fn (induced1 a1) (induced1 a2).

Definition induced2 :=
  induced_function2 induced1 equivR eq_fn_equiv well_defined_induced1.

Definition eval (b:quotient S) (f:quotient S->C): C := f b.
Lemma well_defined_eval: forall (b:quotient S) (f g:quotient S->C),
  eq_fn f g -> eval b f = eval b g.

Definition induced_eval (b:quotient S) :=
  induced_function (eval b) eq_fn_equiv (well_defined_eval b).

Definition induced_function2arg (a:quotient R) (b:quotient S) : C :=
  induced_eval b (induced2 a).

Lemma induced_function2arg_correct: forall (a:A) (b:B),
  induced_function2arg (quotient_projection R a) (quotient_projection S b) =
  f a b.

End InducedFunction2arg.

Section InducedFunction3.

Variable A B C:Type.
Variable R:relation A.
Variable S:relation B.
Variable T:relation C.
Variable f:A->B->C.
Hypothesis equivR:equivalence R.
Hypothesis equivS:equivalence S.
Hypothesis equivT:equivalence T.
Hypothesis well_defined3: forall (a1 a2:A) (b1 b2:B),
  R a1 a2 -> S b1 b2 -> T (f a1 b1) (f a2 b2).

Definition projf2 (a:A) (b:B) :=
  quotient_projection T (f a b).

Lemma projf2_well_defined: forall (a1 a2:A) (b1 b2:B),
  R a1 a2 -> S b1 b2 -> projf2 a1 b1 = projf2 a2 b2.

Definition induced_function3 : quotient R -> quotient S -> quotient T :=
  induced_function2arg projf2 equivR equivS projf2_well_defined.

Lemma induced_function3_correct: forall (a:A) (b:B),
  induced_function3 (quotient_projection R a)
                    (quotient_projection S b) =
  quotient_projection T (f a b).

End InducedFunction3. *)



Section ZL_preorder.



Variable T:Type.

Variable R:relation T.

Hypothesis Rpreord: preorder R.

Hypothesis ub_of_chain: forall S:Ensemble T, chain R S ->

  exists x:T, forall y:T, In S y -> R y x.



Definition premaximal (x:T) : Prop :=

  forall y:T, R x y -> R y x.



Lemma ZornsLemmaForPreorders: exists x:T, premaximal x.

Proof.

pose (Requiv (x y:T) := R x y /\ R y x).

assert (equivalence Requiv).

constructor.

red; intros.

split; apply preord_refl; trivial.

red; intros.

destruct H.

destruct H0.

split; apply preord_trans with y; trivial.

red; intros.

destruct H.

split; trivial.



pose (Rquo := quotient Requiv).

let Hnew:=fresh"_H" in

  unshelve refine (let Hnew:=_ in

     let inducedR := induced_function2arg R H H Hnew in

     let inducedR_prop := induced_function2arg_correct R H H Hnew in _).

intros.

assert (True_rect (R a1 b1) = True_rect (R a2 b2)).

apply Extensionality_Ensembles; split; red; intros.

destruct x.

red in H2.

simpl in H2.

red; simpl.

apply preord_trans with a1; trivial.

apply H0.

apply preord_trans with b1; trivial.

apply H1.

destruct x.

red in H2; simpl in H2.

red; simpl.

apply preord_trans with a2; trivial.

apply H0.

apply preord_trans with b2; trivial.

apply H1.

assert (True_rect (R a1 b1) I = True_rect (R a2 b2) I).

rewrite H2; trivial.

simpl in H3.

assumption.

clearbody inducedR_prop.

fold inducedR in inducedR_prop.



assert (exists x:Rquo, maximal inducedR x).

apply ZornsLemma.

constructor.

red; intros xbar.

destruct (quotient_projection_surjective xbar) as [x []].

rewrite inducedR_prop.

apply preord_refl; trivial.

red; intros xbar ybar zbar ? ?.

destruct (quotient_projection_surjective xbar) as [x].

destruct H2.

destruct (quotient_projection_surjective ybar) as [y].

destruct H2.

destruct (quotient_projection_surjective zbar) as [z].

destruct H2.

rewrite inducedR_prop in H0, H1.

rewrite inducedR_prop.

apply preord_trans with y; trivial.

red; intros xbar ybar ? ?.

destruct (quotient_projection_surjective xbar) as [x].

destruct H2.

destruct (quotient_projection_surjective ybar) as [y].

destruct H2.

rewrite inducedR_prop in H0, H1.

unfold quotient_projection.

apply subset_eq_compatT.

apply R_impl_equality_of_equiv_class; trivial.

split; trivial.



intros Sbar ?.

pose (S := inverse_image (quotient_projection _) Sbar).

unshelve refine (let H1:=ub_of_chain S _ in _).

red; intros.

pose proof (H0 (quotient_projection _ x) (quotient_projection _ y)).

rewrite 2 inducedR_prop in H3.

destruct H1.

destruct H2.

apply H3; trivial.



destruct H1.

exists (quotient_projection _ x).

intros ybar ?.

destruct (quotient_projection_surjective ybar) as [y].

destruct H3.

rewrite inducedR_prop.

apply H1.

constructor; exact H2.



destruct H0 as [xbar].

destruct (quotient_projection_surjective xbar) as [x].

destruct H1.

exists x.

red; intros.

red in H0.

unshelve refine (let H2:=H0 (quotient_projection Requiv y) _ in _).

rewrite inducedR_prop.

assumption.

unfold quotient_projection in H2.

injection H2; intros.

assert (In (equiv_class Requiv x) y).

rewrite H3.

constructor; apply equiv_refl; trivial.

destruct H4.

apply H4.

Qed.



End ZL_preorder.



Arguments premaximal {T}.

