Require Export EnsemblesImplicit.
(* EnsemblesImplicit:
Require Export Ensembles.

Arguments In {U}.
Arguments Included {U}.
Arguments Singleton {U}.
Arguments Union {U}.
Arguments Add {U}.
Arguments Intersection {U}.
Arguments Couple {U}.
Arguments Triple {U}.
Arguments Complement {U}.
Arguments Setminus {U}.
Arguments Subtract {U}.
Arguments Disjoint {U}.
Arguments Inhabited {U}.
Arguments Strict_Included {U}.
Arguments Same_set {U}.
Arguments Extensionality_Ensembles {U}.
Arguments Empty_set {U}.
Arguments Full_set {U}. *)
Require Export Utf8.
Require Export Families.
(* Families:
Require Export Ensembles.
Require Import EnsemblesImplicit.

Set Implicit Arguments.

Section Families.

Variable T:Type.
Definition Family := Ensemble (Ensemble T).
Variable F:Family.

Inductive FamilyUnion: Ensemble T :=
  | family_union_intro: forall (S:Ensemble T) (x:T),
    In F S -> In S x -> In FamilyUnion x.

Inductive FamilyIntersection: Ensemble T :=
  | family_intersection_intro: forall x:T,
    (forall S:Ensemble T, In F S -> In S x) ->
    In FamilyIntersection x.

End Families.

Section FamilyFacts.

Variable T:Type.

Lemma empty_family_union: FamilyUnion (@Empty_set (Ensemble T)) =
                          Empty_set.

Lemma empty_family_intersection:
  FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.

Lemma subfamily_union: forall F G:Family T, Included F G ->
  Included (FamilyUnion F) (FamilyUnion G).

Lemma subfamily_intersection: forall F G:Family T, Included F G ->
  Included (FamilyIntersection G) (FamilyIntersection F).

End FamilyFacts. *)
Require Export IndexedFamilies.
(* IndexedFamilies:
Require Export Families.
Require Export Image.
Require Import ImageImplicit.

Set Implicit Arguments.

Section IndexedFamilies.

Variable A T:Type.
Definition IndexedFamily := A -> Ensemble T.
Variable F:IndexedFamily.

Inductive IndexedUnion : Ensemble T :=
  | indexed_union_intro: forall (a:A) (x:T),
    In (F a) x -> In IndexedUnion x.

Inductive IndexedIntersection : Ensemble T :=
  | indexed_intersection_intro: forall (x:T),
    (forall a:A, In (F a) x) -> In IndexedIntersection x.

End IndexedFamilies.

Section IndexedFamilyFacts.

Lemma sub_indexed_union: forall {A B T:Type} (f:A->B)
  (F:IndexedFamily B T),
  let subF := (fun a:A => F (f a)) in
    Included (IndexedUnion subF) (IndexedUnion F).

Lemma sub_indexed_intersection: forall {A B T:Type} (f:A->B)
  (F:IndexedFamily B T),
  let subF := (fun a:A => F (f a)) in
    Included (IndexedIntersection F) (IndexedIntersection subF).

Lemma empty_indexed_intersection: forall {T:Type}
  (F:IndexedFamily False T),
  IndexedIntersection F = Full_set.

Lemma empty_indexed_union: forall {T:Type}
  (F:IndexedFamily False T),
  IndexedUnion F = Empty_set.

End IndexedFamilyFacts.

Section IndexedFamilyToFamily.

Variable T:Type.
Variable A:Type.
Variable F:IndexedFamily A T.

Definition ImageFamily : Family T :=
  Im Full_set F.

Lemma indexed_to_family_union: IndexedUnion F = FamilyUnion ImageFamily.

Lemma indexed_to_family_intersection:
  IndexedIntersection F = FamilyIntersection ImageFamily.

End IndexedFamilyToFamily. *)

Require Import EnsemblesSpec.
(* EnsemblesSpec:
Require Export Ensembles.
Require Import EnsemblesImplicit.

Inductive characteristic_function_abstraction {X:Type} (P:X->Prop) (x:X) : Prop :=
  | intro_characteristic_sat: P x ->
    In (characteristic_function_abstraction P) x.

Definition characteristic_function_to_ensemble {X:Type} (P:X->Prop) : Ensemble X :=
  characteristic_function_abstraction P.

Notation "[ x : X | P ]" :=
  (characteristic_function_to_ensemble (fun x:X => P))
  (x ident).

Lemma characteristic_function_to_ensemble_is_identity:
  forall {X:Type} (P:X->Prop),
    [ x:X | P x ] = P. *)
Notation "x ∈ S" := (In S x) (at level 75).
Notation "S ∩ T" := (Intersection S T)
  (right associativity, at level 55).
Notation "S //\\ T" := (Intersection S T)
  (only parsing, right associativity, at level 55).
Notation "S ∪ T" := (Union S T)
  (right associativity, at level 65).
Notation "S \\// T" := (Union S T)
  (only parsing, right associativity, at level 65).
Notation "S ∖ T" := (Setminus S T)
  (no associativity, at level 65).
Notation "S \ T" := (Setminus S T)
  (only parsing, no associativity, at level 65).
Notation "S ⊆ T" := (Included S T) (at level 70).
Notation "S <= T" := (Included S T)
  (only parsing, at level 70).
Notation "S ⊊ T" := (Strict_Included S T) (at level 70).
Notation "S < T" := (Strict_Included S T)
  (only parsing, at level 70).
Notation "[[ x ]]" := (Singleton x) (at level 0).
Notation "[[ x , y ]]" := (Couple x y) (at level 0).
Notation "[[ x , y , z ]]" := (Triple x y z) (at level 0).
Notation "∅" := Empty_set (at level 0).

Notation "⋃ F" := (FamilyUnion F) (at level 0).
Notation "⋃ [ x : X ] S" :=
  (IndexedUnion (fun x:X => S)) (at level 0, x ident).
Notation "\\// [ x : X ] S" :=
  (IndexedUnion (fun x:X => S)) (only parsing, x ident, at level 0).
Notation "⋂ F" := (FamilyIntersection F) (at level 0).
Notation "⋂ [ x : X ] S" :=
  (IndexedIntersection (fun x:X => S)) (at level 0, x ident).
Notation "//\\ [ x : X ] S" :=
  (IndexedIntersection (fun x:X => S))
  (only parsing, x ident, at level 0).

