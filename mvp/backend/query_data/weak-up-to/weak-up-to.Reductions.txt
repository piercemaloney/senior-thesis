
Require Export Diagrams.
(* Diagrams:
Require Export Relations.
Set Implicit Arguments.

Section Def1.
  Variables X X' Y Y': Type.
  Variable RX: relation2 X X'.
  Variable R:  relation2 X Y.
  Variable RY: relation2 Y Y'.
  Variable R': relation2 X' Y'.
  Definition diagram := forall x x' y, RX x x' -> R x y -> exists2 y', RY y y' & R' x' y'.
End Def1.
Section Def2.
  Variable X: Type.
  Variables R S: relation X.
  Definition strong_commute := diagram R S R S.
  Definition local_commute  := diagram R S (star R) (star S).
  Definition semi_commute   := diagram R S (star R) S.
  Definition commute        := diagram (star R) (star S) (star R) (star S).
  Definition confluent      := diagram (star R) (star R) (star R) (star R).
End Def2.

Section Incl.
  Variables X X' Y Y': Type.
  Variable RX: relation2 X X'.
  Variable R R':  relation2 X Y.
  Variable RY: relation2 Y Y'.
  Variables S S': relation2 X' Y'.
  Hypothesis H: diagram RX R RY S.
  Hypothesis HR: forall x y, R' x y -> R x y.
  Hypothesis HS: forall x y, S x y -> S' x y.
  Theorem diagram_incl: diagram RX R' RY S'.
End Incl.

Section Reverse.
  Variables X X' Y Y': Type.
  Variable RX: relation2 X X'.
  Variable R:  relation2 X Y.
  Variable RY: relation2 Y Y'.
  Variable R': relation2 X' Y'.
  Hypothesis H: diagram RX R RY R'.
  Theorem diagram_reverse: diagram R RX R' RY.
End Reverse.

Section Compose.
  Variables X Y Z X' Y' Z': Type.
  Variable RY: relation2 Y Y'.
  Variable RX: relation2 X X'.
  Variable R1: relation2 X Y.
  Variable R2: relation2 Y Z.
  Variable RZ: relation2 Z Z'.
  Variable S1: relation2 X' Y'.
  Variable S2: relation2 Y' Z'.
  Hypothesis H1: diagram RX R1 RY S1.
  Hypothesis H2: diagram RY R2 RZ S2.
  Theorem diagram_comp: diagram RX (comp R1 R2) RZ (comp S1 S2).
End Compose.

Section Union.
  Variables X Y X' Y' I: Type.
  Variable  RX: relation2 X X'.
  Variables R: I -> relation2 X Y.
  Variable  RY: relation2 Y Y'.
  Variable  S: relation2 X' Y'.
  Hypothesis H: forall i, diagram RX (R i) RY S.
  Theorem diagram_union: diagram RX (union R) RY S.
End Union.

Section Star.
  Variables X X': Type.
  Variable RX: relation2 X X'.
  Variable R: relation X.
  Variable S: relation X'.
  Hypothesis H: diagram RX R RX (star S).
  Theorem diagram_star: diagram RX (star R) RX (star S).
End Star.

Section Plus.
  Variables X X': Type.
  Variable RX: relation2 X X'.
  Variable R: relation X.
  Variable S: relation X'.
  Hypothesis HR: diagram RX R RX (plus S).
  Theorem diagram_plus: diagram RX (plus R) RX (plus S).
End Plus.

Section PlusWf.

  Variable X: Set.
  Variable S: relation X.
  Variable TX: relation X.

  Hypothesis HS: diagram TX S (star TX) (plus S).
  Hypothesis Hwf: well_founded (trans S).
  Let Hpwf: well_founded (trans (plus S)) := plus_wf Hwf.

  Lemma diagram_plus_wf: diagram (star TX) (plus S) (star TX) (plus S).

  Variable TX': relation X.
  
  Hypothesis HS': diagram TX' S (comp (star TX) TX') (plus S).

  Lemma diagram_plus_wf_1: strong_commute (comp (star TX) TX') (plus S).

  Variable Y: Type.
  Variables R R': relation2 X Y.
  Variable TY TY': relation Y.

  Hypothesis HR: diagram TX R (star TY) (comp (star S) R).
  Hypothesis HR': diagram TX' R (comp (star TY) TY') (comp (star S) R').

  Theorem diagram_plus_wf_2: diagram (comp (star TX) TX') (comp (star S) R) (comp (star TY) TY') (comp (star S) R').

End PlusWf.

Section StarWf.

  Variable X: Set.
  Variable S: relation X.
  Variable TX: relation X.
 
  Hypothesis HS: local_commute TX S.
  Hypothesis Hwf: well_founded (trans (comp (plus S) (plus TX))). 

  Section Gen.
    Variable Y: Type.
    Variable R: relation2 X Y.
    Variable TY: relation Y.
  
    Let SR := comp (star S) R.
    Hypothesis HR: diagram TX R (star TY) SR.
  
    Lemma diagram_star_wf_1: diagram (star TX) SR (star TY) SR.

    Variables X' Y': Type.
    Variable TaX: relation2 X X'.
    Variable TaY: relation2 Y Y'.
    Variable S' : relation2 X' X'.
    Variable R' : relation2 X' Y'.
  
    Let SR' := comp (star S') R'.
    Let TAX := comp (star TX) TaX.
    Let TAY := comp (star TY) TaY.

    Hypothesis HT:  diagram TaX S TAX (star S').
    Hypothesis HRT: diagram TaX R TAY SR'.

    Theorem diagram_star_wf_2: diagram TAX SR TAY SR'.
 
  End Gen.

  Lemma diagram_star_wf: commute TX S.
  
End StarWf. *)
Set Implicit Arguments.

Ltac cgen H := generalize H; clear H.

Section Reductions.

  Section R.
    Variables A X: Type.
    Definition reduction := A -> relation X.
    Definition incl_r: relation reduction := fun R1 R2 => forall a, incl (R1 a) (R2 a).
    Definition eeq_r: relation reduction := fun R1 R2 => forall a, eeq (R1 a) (R2 a).
  End R.

  Variable A: Type.

  Section Diagram.
    Variables X Y: Type.
    Definition diagram_r(RX: reduction A X) R (RY: reduction A Y) S := forall a, diagram (RX a) R (RY a) S.
  End Diagram. 

  Section Weak.
  
    Inductive Lbl: Type := T | L(a: A).
    Definition reduction_t := reduction Lbl.
  
    Variable X: Type.
    Variable Red: reduction_t X.

    Definition Weak: reduction_t X := fun l => 
      match l with 
	| T => star (Red T)
	| L a => comp (star (Red T)) (comp (Red (L a)) (star (Red T)))
      end.

    Definition EWeak: reduction_t X := fun l => 
      match l with 
	| T => union2 (eq (A:=X)) (Red T)
	| L a => Red (L a)
      end.

    Definition REWeak: reduction_t X := fun l => 
      match l with 
	| T => union2 (eq (A:=X)) (Red T)
	| L a => comp (Red (L a)) (star (Red T))
      end.

    Lemma weak_refl: forall x, Weak T x x.
    Proof. intro x; simpl; auto. Qed.
    Hint Immediate weak_refl.

    Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.
    Proof. 
      intros y l; destruct l; simpl; intros x z XY YZ.
      apply S_star with y; assumption.
      destruct YZ as [ w YW WZ ].
      exists w; auto.
      apply S_star with y; assumption.
    Qed.

    Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.
    Proof.
      intros y l; destruct l; simpl; intros x z XY YZ.
      apply S_star with y; assumption.
      exists x; auto.
      exists y; auto.
    Qed.

    Lemma red_weak: forall l x y, Red l x y -> Weak l x y.
    Proof.
      intros l x y H.
      apply weak_tau with y; auto.
    Qed.

    Lemma taus_weak: forall y l x z, Weak T x y -> Weak l y z -> Weak l x z.
    Proof. 
      intros y l; destruct l; simpl; intros x z XY YZ.
      apply star_trans with y; assumption.
      destruct YZ as [ w YW WZ ].
      exists w; auto.
      apply star_trans with y; assumption.
    Qed.

    Lemma weak_taus: forall y l x z, Weak l x y -> Weak T y z -> Weak l x z.
    Proof.
      intros y l; destruct l; simpl; intros x z XY YZ.
      apply star_trans with y; assumption.
      destruct XY as [ w XW WY ].
      destruct WY as [ t WT TY ].
      exists w; auto.
      exists t; auto.
      apply star_trans with y; assumption.
    Qed.

    Theorem Weak_ind:
       forall P: Lbl -> X -> X -> Prop,
       (forall x, P T x x) ->
       (forall y l x z ,
        Red T x y -> Weak l y z -> P l y z -> P l x z) ->
       (forall y a x z,
        Red (L a) x y -> Weak T y z -> P T y z -> P (L a) x z) ->
       forall l x x', Weak l x x' -> P l x x'.
    Proof.
      intros P Hrefl Htau Ha l x x' Hxx'.
      destruct l.
      induction Hxx' as [ x | x1 x x' Hxx1 Hx1x' IH ]; [ apply Hrefl | apply Htau with x1; assumption ].
      destruct Hxx' as [ x1 Hxx1 Hx1x' ].
      destruct Hx1x' as [ x2 Hx1x2 Hx2x' ].
      induction Hxx1 as [ x | w x x1 Hxw Hwx1 IH ].
      apply Ha with x2; simpl; auto.
      clear Hx1x2.
      induction Hx2x' as [ x2 | u x2 x' Hux1 Hx1x' IH ]; [ apply Hrefl | apply Htau with u; assumption ].
      apply Htau with w; auto.
      exists x1; auto; exists x2; assumption.
    Qed.

  End Weak.

End Reductions.

Hint Immediate weak_refl.
Hint Resolve red_weak.

