
Require Export Settings.
(* Settings:
Require Export Functions.
Require Export Reductions.
Set Implicit Arguments.

Section Global.

  Variable A: Type.

  Section Sim.

    Variables X Y: Type.
    Variable TX: reduction_t A X.
    Variable TY: reduction_t A Y.
    
    Definition evolve_1 l R S := diagram (TX l) R (Weak TY l) S.
    Definition evolve_t   R S := evolve_1 (T A) R S.
    Definition evolve_a   R S := forall a, evolve_1 (L a) R S .
    Definition evolve     R S := forall l, evolve_1 l R S.

    Definition simulation_t R := evolve_t R R.
    Definition simulation   R := evolve   R R.

    Definition expansion1   R := diagram_r TX R (EWeak TY) R.
    Definition wexpansion1  R := diagram_r TX R (REWeak TY) R.
    
    Variable F: function X Y.

    Record monotonic: Prop := mkmon {
      mon_m:> increasing F;
      mon_t:  forall R S, evolve_t R S -> incl R S -> evolve_t (F R) (F S);
      mon_a:  forall R S, evolve   R S -> incl R S -> evolve_a (F R) (F S)
    }.
    
    Record wmonotonic: Prop := mkwmon {
      wmon_m:> increasing F;
      wmon_t:  forall R, simulation_t R -> simulation_t (F R);
      wmon_a:  forall R S, simulation_t R -> simulation_t S -> evolve_a R S -> incl R S -> evolve_a (F R) (F S)
    }.

    Variable B: relation X.
    Record controlled: Prop := mkctrl {
      ctrl_t:  forall R, evolve_t R (comp (star B) R) -> simulation_t (comp (star B) R);
      ctrl_a:  forall R S, evolve_t R (comp (star B) R) -> simulation_t S -> 
	                  evolve_a R S -> incl R S -> evolve_a (comp (star B) R) (comp (star B) S)
    }.
    
    Lemma weak_strong_t: forall R, simulation_t R -> diagram (Weak TX (T A)) R (Weak TY (T A)) R.
    Lemma weak_strong: forall R, simulation R -> diagram_r (Weak TX) R (Weak TY) R.

    Lemma union2_evolve: forall l R R' S, evolve_1 l R S -> evolve_1 l R' S -> evolve_1 l (union2 R R') S.
    Lemma union2_evolve_left: forall l R S S', evolve_1 l R S -> evolve_1 l R (union2 S S').
    Lemma union2_evolve_right: forall l R S S', evolve_1 l R S' -> evolve_1 l R (union2 S S').
    Lemma union_evolve: forall l I R S, 
      (forall i:I, evolve_1 l (R i) S) -> evolve_1 l (union R) S.
    Lemma evolve_union: forall l J R S, 
      (exists j:J, evolve_1 l R (S j)) -> evolve_1 l R (union S).

    Lemma incl_evolve: forall l R R' S, incl R R' -> evolve_1 l R' S -> evolve_1 l R S.
    Lemma evolve_incl: forall l S R S', incl S S' -> evolve_1 l R S -> evolve_1 l R S'.
      
    Lemma simulation_eeq: forall R S, eeq R S -> simulation R -> simulation S.
    Lemma simulation_t_eeq: forall R S, eeq R S -> simulation_t R -> simulation_t S.

  End Sim.

  Section Bi.

    Variables X Y: Type.
    Variable TX: reduction_t A X.
    Variable TY: reduction_t A Y.

    Definition bisimulation R := simulation  TX TY R /\ simulation TY TX (trans R).
    Definition expansion    R := expansion1  TX TY R /\ simulation TY TX (trans R).
    Definition wexpansion   R := wexpansion1 TX TY R /\ simulation TY TX (trans R).

    Definition bisim   := union_st bisimulation.
    Definition expand  := union_st expansion.
    Definition wexpand := union_st wexpansion.

    Lemma bisimulation_bisim: bisimulation bisim.
    Lemma expansion_expand: expansion expand.
    Lemma wexpansion_wexpand: wexpansion wexpand.

    Lemma expand_wexpand: incl expand wexpand.
    Lemma wexpand_bisim: incl wexpand bisim.

  End Bi.

  Section Composition.
   
    Variables X Y Z: Type.
    Variable TX: reduction_t A X.
    Variable TY: reduction_t A Y.
    Variable TZ: reduction_t A Z.
    
    Variable R: relation2 X Y.
    Variable S: relation2 Y Z.
    
    Lemma simulation_comp: simulation TX TY R -> simulation TY TZ S -> simulation TX TZ (comp R S).

    Lemma expansion1_comp: expansion1 TX TY R -> expansion1 TY TZ S -> expansion1 TX TZ (comp R S).

    Let wexpansion1_t: wexpansion1 TY TZ S -> 
      forall x x' y, star (TY (T _)) x x' -> S x y -> exists2 y', star (TZ (T _)) y y' & S x' y'.

    Lemma wexpansion1_comp: wexpansion1 TX TY R -> wexpansion1 TY TZ S -> wexpansion1 TX TZ (comp R S).

  End Composition.

  Section BiComposition.
   
    Variables X Y Z: Type.
    Variable TX: reduction_t A X.
    Variable TY: reduction_t A Y.
    Variable TZ: reduction_t A Z.
    
    Variable R: relation2 X Y.
    Variable S: relation2 Y Z.
    
    Lemma bisimulation_comp: bisimulation TX TY R -> bisimulation TY TZ S -> bisimulation TX TZ (comp R S).

    Lemma expansion_comp: expansion TX TY R -> expansion TY TZ S -> expansion TX TZ (comp R S).

    Lemma wexpansion_comp: wexpansion TX TY R -> wexpansion TY TZ S -> wexpansion TX TZ (comp R S).

  End BiComposition.

  Section Properties.

    Variable X: Type.
    Variable TX: reduction_t A X.

    Lemma bisim_sym: symmetric (bisim TX TX).

    Lemma bisim_refl: reflexive (bisim TX TX).

    Lemma bisim_trans: transitive (bisim TX TX).

    Definition bicontrolled R := controlled TX TX R /\ incl R (bisim TX TX).

    Lemma expand_refl: reflexive (expand TX TX).

    Lemma expand_trans: transitive (expand TX TX).

    Lemma wexpand_refl: reflexive (wexpand TX TX).

    Lemma wexpand_trans: transitive (wexpand TX TX).

  End Properties.

End Global.

Ltac union_evolve n := unfold UIter, simulation_t, evolve_t; apply union_evolve; intro n; apply evolve_union. *)
Require Import Theory.
(* Theory:
Require Export WeakMonotonic.
Set Implicit Arguments.

Section Global.

  Variables A X Y: Type.
  Variable TX: reduction_t A X.
  Variable TY: reduction_t A Y.
  
  Section MonotonicCorrect.

    Variable F: function X Y.
    Hypothesis HF: monotonic TX TY F.

    Variable R: relation2 X Y.
    Hypothesis HR: evolve TX TY R (F R).

    Let phi: forall n, evolve TX TY (UExp F R n) (UExp F R (S n)).

    Theorem monotonic_correct: simulation TX TY (UIter F R).

  End MonotonicCorrect.

  Section WeakMonotonicCorrect.

    Variable F: function X Y.
    Hypothesis HF: wmonotonic TX TY F.

    Variable R: relation2 X Y.
    Hypothesis HRt: simulation_t TX TY R.
    Hypothesis HRa: evolve_a TX TY R (F R).
    
    Let silent: forall n, simulation_t TX TY (UExp F R n).

    Lemma wmonotonic_correct_t: simulation_t TX TY (UIter F R).

    Let visible: forall n, evolve_a TX TY (UExp F R n) (UExp F R (S n)).

    Theorem wmonotonic_correct: simulation TX TY (UIter F R).

  End WeakMonotonicCorrect.

  Section UnifiedCorrect.

    Variables F G: function X Y.
    Hypothesis HF : monotonic TX TY F.
    Hypothesis HG : wmonotonic TX TY G.

    Variable R: relation2 X Y.

    Hypothesis HFG: contains F G.  

    Hypothesis HRt: evolve_t TX TY R (F R).
    Hypothesis HRa: evolve_a TX TY R (G R).

    Let pre_silent: forall n, evolve_t TX TY (UExp F R n) (UExp F R (S n)).
    Let silent: simulation_t TX TY (UIter F R).

    Let HFGn: forall n, incl (UExp F R n) (UExp G R n).

    Let pre_visible: forall n, evolve TX TY (UExp F R n) (UExp G R (S n)).
    Let visible: evolve_a TX TY (UIter F R) (UIter G R).
   
    Let HGFGn: forall n, incl (UExp (UIter G) (UIter G R) n) (UExp (UIter G) R (S n)).
    Let HGFG: eeq (UIter (UIter G) (UIter F R)) (UIter (UIter G) R).

    Theorem unified_correct: simulation TX TY (UIter (UIter G) R).

  End UnifiedCorrect.

  Section ControlledCorrect.

    Variable B: relation X.
    Hypothesis HB: controlled TX TY B.

    Variables F G: function X Y.
    Hypothesis HF : monotonic TX TY F.
    Hypothesis HG : wmonotonic TX TY G.

    Hypothesis HBF: transparent B F.
    Hypothesis HFG: contains F G. 
    Hypothesis HBG: contains (chaining_l (star B)) G.

    Variable R: relation2 X Y.
    Hypothesis HRt: evolve_t TX TY R (comp (star B) (F R)).
    Hypothesis HRa: evolve_a TX TY R (G R).

    Let pre_silent: forall n, evolve_t TX TY (UExp F R n) (comp (star B) (UExp F R (S n))).
    Let silent: simulation_t TX TY (comp (star B) (UIter F R)).
    
    Let HFGn: forall n, incl (UExp F R n) (UExp G R n).
    Let HBGGn: forall R n, incl (comp (star B) (UExp G R n)) (UExp G R (S n)).

    Let pre_visible: forall n, evolve TX TY (UExp F R n) (UExp G R (2+n)).
    Let visible: evolve_a TX TY (comp (star B) (UIter F R)) (UIter G (comp (star B) (UIter F R))).
    
    Let HGGBF: eeq (UIter (UIter G) (comp (star B) (UIter F R))) (UIter (UIter G) R).

    Theorem controlled_correct: simulation TX TY (UIter (UIter G) R).

  End ControlledCorrect.

End Global. *)
Set Implicit Arguments.

Section Modular.

  Variables A X: Type.
  Variable TX: reduction_t A X.

  Let F  := Comp (chaining_l (expand TX TX)) (chaining_r (bisim TX TX)).
  Let G  := Comp (star (X:=X)) (Union2 (identity (X:=X) (Y:=X)) (constant (bisim TX TX))).

  Lemma F_mon: monotonic TX TX F.
  Proof.
    unfold F; apply Comp_mon.
    apply chaining_r_mon.
    apply (proj1 (bisimulation_bisim TX TX)).
    apply chaining_l_mon.
    apply (proj1 (expansion_expand TX TX)).
  Qed.
  Lemma G_wmon: wmonotonic TX TX G.
  Proof.
    unfold G; apply Comp_wmon.
    apply Union2_wmon.
    apply monotonic_wmonotonic; apply identity_mon.
    apply monotonic_wmonotonic; apply constant_mon.
    apply (proj1 (bisimulation_bisim TX TX)).
    apply star_wmon.
  Qed.

  Lemma FG: contains F G.
  Proof.
    intros R x y XY; destruct XY as [ x' XX' X'Y ]; destruct X'Y as [ y' X'Y' Y'Y ].
    unfold G, Comp, Union2; simpl; apply S_star with x'; auto.
    right; unfold constant; apply wexpand_bisim; apply expand_wexpand; auto.
    apply S_star with y'.
    left; auto.
    apply star1; right; auto.
  Qed.

  Lemma G_reverse: forall R, eeq (trans (G R)) (G (trans R)).
    intros R; unfold G, Comp, Union2, identity, constant.
    eapply eeq_trans; [ apply inv_star | apply star_eeq ].
    eapply eeq_trans; [ apply inv_union2 | apply union2_eeq; auto ].
    split; intros x y H; apply (bisim_sym H).
  Qed.

  Variable R: relation X.
  Hypothesis HRt: evolve_t TX TX R (F R).
  Hypothesis HRa: evolve_a TX TX R (G R).
  Hypothesis HRt': evolve_t TX TX (trans R) (F (trans R)).
  Hypothesis HRa': evolve_a TX TX (trans R) (G (trans R)).

  Theorem upto: incl R (bisim TX TX).
  Proof.
    intros x y H; exists (UIter (UIter G) R).
    split.
    apply unified_correct with F; auto.
    exact F_mon.
    exact G_wmon.
    exact FG.
    apply simulation_eeq with (UIter (UIter G) (trans R)). 
    apply eeq_sym; repeat apply UIter_trans; repeat apply UIter_inc; try apply (wmon_m G_wmon). 
    apply G_reverse.
    apply unified_correct with F; auto.
    exact F_mon.
    exact G_wmon.
    exact FG.
    exists 0; exact H.
  Qed.

End Modular.

Section Controlled.

  Variables A X: Type.
  Variable TX: reduction_t A X.

  Variables B B': relation X.
  Hypothesis HB: bicontrolled TX B.
  Hypothesis HB': bicontrolled TX B'.

  Let F  := chaining_r (X:=X) (bisim TX TX).
  Let G  := Comp (star (X:=X)) (Union2 (identity (X:=X) (Y:=X)) (constant (bisim TX TX))).

  Let F_mon: monotonic TX TX F.
  Proof.
    unfold F; apply chaining_r_mon; apply (proj1 (bisimulation_bisim TX TX)).
  Qed.

  Let FG: contains F G.
  Proof.
    intros R x y XY; destruct XY as [ w XW WY ].
    unfold G, Comp, Union2; simpl; apply S_star with w; auto.
    left; auto.
    apply star1; right; auto.
  Qed.

  Let BG: contains (chaining_l (star B)) G.
  Proof.
    intros R x y XY; destruct XY as [ w XW WY ].
    unfold G, Comp, Union2, constant; simpl; apply S_star with w; auto.
    right; induction XW as [ w | z x w ZX XW  IH ]. 
    apply bisim_refl.
    apply bisim_trans with z; auto.
    apply (proj2 HB _ _ ZX).
    apply star1; left; auto.
  Qed.

  Let B'G: contains (chaining_l (star B')) G.
  Proof.
    intros R x y XY; destruct XY as [ w XW WY ].
    unfold G, Comp, Union2, constant; simpl; apply S_star with w; auto.
    right; induction XW as [ w | z x w ZX XW  IH ]. 
    apply bisim_refl.
    apply bisim_trans with z; auto.
    apply (proj2 HB' _ _ ZX).
    apply star1; left; auto.
  Qed.

  Variable R: relation X.
  Hypothesis HRt: evolve_t TX TX R (comp (star B) (F R)).
  Hypothesis HRa: evolve_a TX TX R (G R).
  Hypothesis HRt': evolve_t TX TX (trans R) (comp (star B') (F (trans R))).
  Hypothesis HRa': evolve_a TX TX (trans R) (G (trans R)).

  Theorem upto_ctrl: incl R (bisim TX TX).
  Proof.
    intros x y H; exists (UIter (UIter G) R).
    split.
    apply controlled_correct with B F; auto.
    exact (proj1 HB).
    unfold G; apply G_wmon.
    unfold transparent, F, chaining_r; intro U;
      apply (proj1 (comp_assoc (star B) U (bisim TX TX))).
    apply simulation_eeq with (UIter (UIter G) (trans R)). 
    unfold G; apply eeq_sym; repeat apply UIter_trans; repeat apply UIter_inc; try apply (wmon_m (G_wmon TX)). 
    apply G_reverse.
    apply controlled_correct with B' F; auto.
    exact (proj1 HB').
    unfold G; apply G_wmon.
    unfold transparent, F, chaining_r; intro U;
      apply (proj1 (comp_assoc (star B') U (bisim TX TX))).
    exists 0; exact H.
  Qed.

End Controlled.
