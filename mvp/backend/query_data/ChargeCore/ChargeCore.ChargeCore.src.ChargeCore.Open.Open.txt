Require Import ChargeCore.Open.Stack.
(* ChargeCore.Open.Stack:
Require Import Coq.Logic.FunctionalExtensionality.

Require Import ExtLib.Core.RelDec.
Require Import ExtLib.Tactics.Consider.

Set Implicit Arguments.
Unset Strict Implicit.
Set Primitive Projections.

Set Maximal Implicit Insertion.
Set Universe Polymorphism.

Class ValNull (val : Type) := {
  null : val
}.

Section Defs.
  Context {A val : Type}.
  Context {HA : RelDec (@eq A)} {HR : RelDec_Correct HA}.
  Context {VNB : ValNull val}.

  Definition stack := A -> val.

  Definition stack_empty : stack := fun x => null.

  Definition stack_get (x : A) : stack -> val  := fun s => s x.

  Definition stack_add x v s : stack :=
    fun x' => if x' ?[ eq ] x then v else s x'.

  Lemma stack_lookup_add (s : stack) (x : A) (v : val) :
      ((stack_add x v s) : stack) x = v.

  Lemma stack_lookup_add2 (x y : A) (v : val) (s : stack) (Hneq: x <> y) :
    (stack_add x v s) y = s y.

  Lemma stack_add_same (s: stack) x:
    stack_add x (s x) s = s.

  Lemma stack_add_overwrite (s: stack) x v v':
    stack_add x v (stack_add x v' s) = stack_add x v s.

  Lemma stack_add_val_eq (s : stack) (x : A) v1 v2 (Hs : stack_add x v1 s = stack_add x v2 s) :
  	v1 = v2.

End Defs.

Arguments stack _ _ : clear implicits, assert.
Arguments stack_empty A val {_}.

Hint Rewrite @stack_lookup_add
             @stack_add_same
             @stack_add_overwrite : stack.

Hint Rewrite @stack_lookup_add2 using solve [auto] : stack. *)

Require Import Coq.Lists.List Coq.Logic.FunctionalExtensionality.
Require Import Coq.Classes.RelationClasses.

Require Import ExtLib.Core.RelDec.

Set Implicit Arguments.
Unset Strict Implicit.
Set Maximal Implicit Insertion.

Section Expr.
  Polymorphic Definition OpenType := Type. 

  Polymorphic Context {A val : OpenType} {HR : RelDec (@eq A)} {HROk : RelDec_Correct HR}.
  Polymorphic Context {V : ValNull val}.

  Polymorphic Definition open B : Type := stack A val -> B.

  Polymorphic Program Definition lift {A B} (f : A -> B) (a : open A) : open B := 
    fun x => f (a x).

  Polymorphic Definition expr := open val.

  Polymorphic Definition rel_open {X} :  open X -> open X -> Prop := fun e1 e2 => forall s, e1 s = e2 s.
  Polymorphic Instance OpenEquivalence {X} : Equivalence (@rel_open X).
  Proof.
    split; intuition congruence.
  Qed.
  
  Polymorphic Definition open_const {B : Type} (b : B) : open B := fun s => b.
  
  Polymorphic Definition V_expr (v : val) : expr := fun s => v.
  Polymorphic Definition var_expr (x : A) : expr := fun s => s x.
  Polymorphic Definition empty_open : expr := fun x => null.

  Polymorphic Definition uncurry {A B C} (f : A -> B -> C) : (A * B) -> C := 
    fun x => f (fst x) (snd x).
  Polymorphic Definition curry {A B C} (f : A * B -> C) : A -> B -> C :=
    fun x y => f (x, y).
  Polymorphic Program Definition opair {B C} (b : open B) (c : open C) : open ((B * C)%type) :=
    fun x => (b x, c x).

End Expr.

Section SimultAdd.
  Context {A val} {HR : RelDec (@eq A)} {V: ValNull val}.

End SimultAdd.
