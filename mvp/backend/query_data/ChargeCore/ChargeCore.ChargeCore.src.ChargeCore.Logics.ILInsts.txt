Require Import Coq.Classes.RelationClasses.
Require Import Coq.Setoids.Setoid.
Require Import Coq.Classes.Morphisms.
From ChargeCore.Logics Require Import ILogic ILEmbed.
(* ChargeCore.Logics.ILogic:
Require Import Setoid Morphisms RelationClasses Program.Basics Omega.

Set Implicit Arguments.
Unset Strict Implicit.
Set Maximal Implicit Insertion.

Global Instance ge_Pre: PreOrder ge.

Class ILogicOps (A : Type) : Type := {
  lentails: A -> A -> Prop;
  ltrue: A;
  lfalse: A;
  limpl: A -> A -> A;
  land: A -> A -> A;
  lor: A -> A -> A;
  lforall: forall {T : Type}, (T -> A) -> A;
  lexists: forall {T : Type}, (T -> A) -> A
}.

Infix "|--"  := lentails (at level 80, no associativity).
Infix "//\\"   := land (at level 75, right associativity).
Infix "\\//"   := lor (at level 76, right associativity).
Infix "-->>"   := limpl (at level 77, right associativity).
Notation "'Forall' x : T , p" :=
  (lforall (fun x : T => p)) (at level 78, x ident, right associativity).
Notation "'Forall' x , p" :=
  (lforall (fun x => p)) (at level 78, x ident, right associativity, only parsing).
Notation "'Exists' x : T , p" :=
  (lexists (fun x : T => p)) (at level 78, x ident, right associativity).
Notation "'Exists' x , p" :=
  (lexists (fun x => p)) (at level 78, x ident, right associativity, only parsing).

Section ILogicEquiv.
  Context {A : Type} `{IL: ILogicOps A}.

  Definition lequiv P Q := P |-- Q /\ Q |-- P.
End ILogicEquiv.

Infix "-|-"  := lequiv (at level 85, no associativity).

Class ILogic {A : Type} {ILOps: ILogicOps A} : Type := {
  lentailsPre:> PreOrder lentails;
  ltrueR: forall (C : A), C |-- ltrue;
  lfalseL: forall (C : A), lfalse |-- C;
  lforallL: forall (T : Type) x (P: T -> A) C, P x |-- C -> lforall P |-- C;
  lforallR: forall (T : Type) (P: T -> A) C, (forall x, C |-- P x) -> C |-- lforall P;
  lexistsL: forall (T : Type) (P: T -> A) C, (forall x, P x |-- C) -> lexists P |-- C;
  lexistsR: forall (T : Type) (x : T) (P: T -> A) C, C |-- P x -> C |-- lexists P;
  landL1: forall (P Q C : A), P |-- C  ->  P //\\ Q |-- C;
  landL2: forall (P Q C : A), Q |-- C  ->  P //\\ Q |-- C;
  lorR1:  forall (P Q C : A), C |-- P  ->  C |-- P \\// Q;
  lorR2:  forall (P Q C : A), C |-- Q  ->  C |-- P \\// Q;
  landR:  forall (P Q C : A), C |-- P  ->  C |-- Q  ->  C |-- P //\\ Q;
  lorL:   forall (P Q C : A), P |-- C  ->  Q |-- C  ->  P \\// Q |-- C;
  landAdj: forall (P Q C : A), C |-- (P -->> Q) -> C //\\ P |-- Q;
  limplAdj: forall (P Q C : A), C //\\ P |-- Q -> C |-- (P -->> Q)
}.

Arguments ILogic _ {ILOps}.
Arguments lforallL {A ILOps ILogic} [T] x P C _.
Arguments lexistsR {A ILOps ILogic} [T] x P C _.

Notation "|--  P" := (ltrue |-- P) (at level 85, no associativity).
Hint Extern 0 (?x |-- ?x) => reflexivity.
Hint Extern 0 (_ |-- ltrue) => apply ltrueR.
Hint Extern 0 (lfalse |-- _) => apply lfalseL.
Hint Extern 0 (?P |-- ?Q) => (is_evar P; reflexivity) || (is_evar Q; reflexivity).

Section ILogicEquiv2.
  Context {A : Type} `{IL: ILogic A}.

  Global Instance lequivEquivalence : Equivalence lequiv.

End ILogicEquiv2.

Section ILogicEquivOps.
  Context {A : Type} `{IL: ILogic A}.

  Lemma land_is_forall P Q :
    P //\\ Q -|- Forall b : bool, if b then P else Q.

  Lemma lor_is_exists P Q:
    P \\// Q -|- Exists b : bool, if b then P else Q.

  Lemma ltrue_is_forall:
    ltrue -|- Forall x: Empty_set, Empty_set_rect _ x.

  Lemma lfalse_is_exists:
    lfalse -|- Exists x: Empty_set, Empty_set_rect _ x.

End ILogicEquivOps.

Section ILogicMorphisms.
  Context {A T : Type} `{IL: ILogic A}.

  Global Instance lequiv_lentails : subrelation lequiv lentails.
  Global Instance lequiv_flip_lentails: subrelation lequiv (flip lentails).

  Global Instance lforall_lentails_m:
    Proper (pointwise_relation T lentails ++> lentails) lforall.

  Global Instance lforall_lequiv_m:
    Proper (pointwise_relation T lequiv ++> lequiv) lforall.

  Global Instance lexists_lentails_m:
    Proper (pointwise_relation T lentails ++> lentails) lexists.

  Global Instance lexists_lequiv_m:
    Proper (pointwise_relation T lequiv ++> lequiv) lexists.

  Global Instance : Proper (lequiv ==> lequiv ==> iff) lequiv.

  Global Instance lequiv_lentails_m : Proper (lequiv ==> lequiv ==> iff) lentails.

  Global Instance lentails_lentails_m: Proper (lentails --> lentails ++> impl) lentails.

  Global Instance land_lentails_m:
    Proper (lentails ++> lentails ++> lentails) land.

  Global Instance land_lequiv_m:
    Proper (lequiv ==> lequiv ==> lequiv) land.

  Global Instance lor_lentails_m:
    Proper (lentails ++> lentails ++> lentails) lor.

  Global Instance lor_lequiv_m:
    Proper (lequiv ==> lequiv ==> lequiv) lor.

  Global Instance limpl_lentails_m:
    Proper (lentails --> lentails ++> lentails) limpl.

  Global Instance limpl_lequiv_m:
    Proper (lequiv ==> lequiv ==> lequiv) limpl.

End ILogicMorphisms.

Hint Extern 0 (?x -|- ?x) => reflexivity.
Hint Extern 0 (?P -|- ?Q) => (is_evar P; reflexivity) || (is_evar Q; reflexivity).

Lemma lforwardL {A} `{IL: ILogic A} {Q R}:
    Q |-- R -> forall P G,
    P |-- Q ->
    (P |-- R -> G) ->
    G.

Tactic Notation "lforwardL" hyp(H) :=
  eapply (lforwardL H); clear H; [|intros H].

Section ILogicFacts.
  Context {A T : Type} `{IL: ILogic A}.

  Ltac landR :=
    repeat match goal with
    | |- _ |-- _ //\\ _ => apply landR
    end.

  Ltac landL :=
    repeat match goal with
    | |- ?L1 //\\ ?L2 |-- ?R =>
        match L1 with
        | context [R] => apply landL1
        | _ =>
          match L2 with
          | context [R] => apply landL2
          end
        end
    end.
    
  Lemma lentails_refl P : P |-- P.

  Lemma landC P Q: P //\\ Q -|- Q //\\ P.

  Lemma landA P Q R: (P //\\ Q) //\\ R -|- P //\\ (Q //\\ R).

  Lemma lorC P Q : P \\// Q -|- Q \\// P.

  Lemma lorA P Q R : (P \\// Q) \\// R -|- P \\// (Q \\// R).

  Lemma limplValid P Q:
    |-- P -->> Q <->
    P |-- Q.

  Lemma limplL P Q CL CR (HP: CL |-- P) (HR: Q //\\ CL |-- CR) :
    (P -->> Q) //\\ CL |-- CR.

  Lemma limplAdj2 P Q R : P -->> Q -->> R -|- P //\\ Q -->> R.

  Lemma landexistsDL1 (f : T -> A) (P : A) :
    lexists f //\\ P |-- Exists a, (f a //\\ P).

  Lemma landexistsDL2 (f : T -> A) (P : A) :
    P //\\ lexists f |-- Exists a, (P //\\ f a).
  
  Lemma landexistsDR1 (f : T -> A) (P : A) :
     Exists a, (f a //\\ P) |-- lexists f //\\ P.

  Lemma landexistsDR2 (f : T -> A) (P : A) :
     Exists a, (P //\\ f a) |-- P //\\ lexists f.
  
  Lemma landexistsD1 (f : T -> A) (P : A) :
    (Exists a, f a) //\\ P -|- Exists a, (f a //\\ P).

  Lemma lorexistsDL (f : T -> A) (P : A) {H : Inhabited T} :
    (Exists a, f a) \\// P |-- Exists a, (f a \\// P).

  Lemma lorexistsDR (f : T -> A) (P : A) :
     Exists a, (f a \\// P) |-- (Exists a, f a) \\// P.

  Lemma lorexistsD (f : T -> A) (P : A) {H : Inhabited T} :
    (Exists a, f a) \\// P -|- Exists a, (f a \\// P).

  Lemma landforallDL (f : T -> A) (P : A) :
    (Forall a, f a) //\\ P |-- Forall a, (f a //\\ P).

  Lemma landforallDR {H: Inhabited T} (f : T -> A) (P : A) :
    Forall a, (f a //\\ P) |-- (Forall a, f a) //\\ P.

  Lemma landforallD (f : T -> A) (P : A) {H : Inhabited T} :
    (Forall a, f a) //\\ P -|- Forall a, (f a //\\ P).

  Lemma lorforallDL (f : T -> A) (P : A) :
    (Forall a, f a) \\// P |-- Forall a, (f a \\// P).

  Lemma limplTrue P : ltrue -->> P -|- P.

  Lemma limplexistsE (P : T -> A) (Q : A) :
    (Exists x, P x) -->> Q -|- Forall x, (P x -->> Q).

  Lemma limplforallER (P : T -> A) (Q : A) :
    Exists x, (P x -->> Q) |-- (Forall x, P x) -->> Q.

  Lemma lforallR2 (P : A) (Q : T -> A) (H : P |-- lforall Q) :
  	forall x, P |-- Q x.

  Lemma lexistsL2 (P : T -> A) (Q : A) (H : lexists P |-- Q) :
  	forall x, P x |-- Q.

  Lemma landtrueL : forall a, ltrue //\\ a -|- a.

  Lemma landtrueR : forall a, a //\\ ltrue -|- a.

  Lemma curry : forall a b c, (a //\\ b) -->> c -|- a -->> (b -->> c).

End ILogicFacts.

Global Instance ILogicOps_Prop : ILogicOps Prop := {|
  lentails P Q := (P : Prop) -> Q;
  ltrue        := True;
  lfalse       := False;
  limpl    P Q := P -> Q;
  land     P Q := P /\ Q;
  lor      P Q := P \/ Q;
  lforall  T F := forall x:T, F x;
  lexists  T F := exists x:T, F x
 |}.

Global Instance ILogic_Prop : ILogic Prop. *)
(* ChargeCore.Logics.ILEmbed:
Require Import ChargeCore.Logics.ILogic.
Require Import Setoid Morphisms RelationClasses Program.Basics Omega.

Set Implicit Arguments.
Unset Strict Implicit.
Set Maximal Implicit Insertion.

Section ILogicEmbed.
  Context {A} `{ILOpsA: ILogicOps A}.
  Context {B} `{ILOpsB: ILogicOps B}.

  Class EmbedOp : Type := { embed : A -> B }.

  Class Embed {EmbOp: EmbedOp} : Type := {
     embed_sound p q : p |-- q -> embed p |-- embed q;

     embedlforall T f : Forall x : T, embed (f x) -|- embed (Forall x : T, f x);
     embedlexists T f : Exists x : T, embed (f x) -|- embed (Exists x : T, f x);
     embedImpl a b : (embed a) -->> (embed b) -|- embed (a -->> b)
  }.
End ILogicEmbed.

Arguments EmbedOp _ _ : clear implicits.
Arguments Embed _ {ILOpsA} _ {ILOpsB EmbOp} : rename.

Section ILogicEmbedOps.
  Context {A B} `{HAB: Embed A B} {ILA: ILogic A} {ILB: ILogic B}.

  Definition lembedand (a : A) (b : B) := (embed a) //\\ b.
  Definition lembedimpl (a : A) (b : B) := (embed a) -->> b.

End ILogicEmbedOps.

Section ILEmbedId.

  Context {A : Type} `{ILA : ILogic A}.

  Instance EmbedOpId : EmbedOp A A := { embed := id }.
  Global Instance EmbedId : Embed A A.

End ILogicEmbedCompose.

Infix "/\\" := lembedand (at level 75, right associativity).
Infix "->>" := lembedimpl (at level 77, right associativity).

Section ILogicEmbedFacts.
  Context {A B} `{HAB: Embed A B} {ILA: ILogic A} {ILB: ILogic B}.

  Global Instance embed_lentails_m :
    Proper (lentails ==> lentails) embed.

  Global Instance embed_lequiv_m :
    Proper (lequiv ==> lequiv) embed.

  Global Instance lembedimpl_lentails_m:
    Proper (lentails --> lentails ++> lentails) lembedimpl.

  Global Instance lembedimpl_lequiv_m:
    Proper (lequiv ==> lequiv ==> lequiv) lembedimpl.

  Global Instance lembedand_lentails_m:
    Proper (lentails ==> lentails ==> lentails) lembedand.

  Global Instance lembedand_lequiv_m:
    Proper (lequiv ==> lequiv ==> lequiv) lembedand.

  Lemma embedland a b : embed a //\\ embed b -|- embed (a //\\ b).

  Lemma embedlor a b : embed a \\// embed b -|- embed (a \\// b).

  Lemma embedlfalse : embed lfalse -|- lfalse.

  Lemma embedltrue : embed ltrue -|- ltrue.

  Lemma embedlandC (P R : B) (Q : A) : P //\\ Q /\\ R -|- Q /\\ P //\\ R.

  Lemma embedlimplC (P R : B) (Q : A) : P -->> Q ->> R -|- Q ->> P -->> R.

  Lemma limpllandC (P Q R : B) : P //\\ (Q -->> R) |-- Q -->> P //\\ R.

  Lemma embed_existsL (P : A) : Exists x : |-- P, ltrue |-- embed P.

End ILogicEmbedFacts.

Section EmbedProp.
  Context {A : Type} `{HIL: ILogic A} {HPropOp: EmbedOp Prop A} {HProp: Embed Prop A}.

  Lemma embedPropExists (p : Prop) : embed p |-- Exists x : p, ltrue.

  Lemma embedPropExistsL (p : Prop) (P : A) : Exists x : p, P |-- embed p.

  Lemma embedPropExists' (p : Prop) : Exists x : p, ltrue -|- embed p.

  Lemma embedPropL (p : Prop) C (H: p -> |-- C) :
    embed p |-- C.

  Lemma embedPropR (p : Prop) (P : A) (H : p) : P |-- embed p.

  Lemma lpropandL (p: Prop) Q C (H: p -> Q |-- C) :
    p /\\ Q |-- C.

  Lemma lpropandR C (p: Prop) Q (Hp: p) (HQ: C |-- Q) :
    C |-- p /\\ Q.

  Lemma lpropimplL (p: Prop) (Q C: A) (Hp: p) (HQ: Q |-- C) :
    p ->> Q |-- C.

  Lemma lpropimplR C (p: Prop) Q (H: p -> C |-- Q) :
    C |-- p ->> Q.

  Lemma lpropandTrue P : True /\\ P -|- P.

  Lemma lpropandFalse P : False /\\ P -|- lfalse.

End EmbedProp.

Section EmbedProp'.
  Context {A : Type} `{HILA: ILogic A} {HPropOpA: EmbedOp Prop A} {HPropA: Embed Prop A}.
  Context {B : Type} `{HILB: ILogic B} {HPropOpB: EmbedOp Prop B} {HPropB: Embed Prop B}.
  Context {HEmbOp : EmbedOp B A} {Hemb: Embed B A}.

  Lemma lpropandAL (p : B) (q : A) (P : Prop) : P /\\ p /\\ q |-- (P /\\ p) /\\ q.

  Lemma lpropandAC (p : B) (q : A) (P : Prop) : p /\\ P /\\ q -|- P /\\ p /\\ q.

  Lemma lpropandAR (p : B) (q : A) (P : Prop) : (P /\\ p) /\\ q |-- P /\\ p /\\ q.

 Lemma lpropimplAL (p : B) (q : A) (P : Prop) : (P ->> p) /\\ q |-- P ->> (p /\\ q).

 Lemma lpropimplAR (p : B) (q : A) (P : Prop) : p /\\ (P ->> q) |-- P ->> (p /\\ q).

  Lemma embedPropR2 (p : Prop) (P : A) (H : p) : P |-- embed (embed p).

  Lemma embedPropL2 (p : Prop) (C : A) (H: p -> |-- C) :
    embed (embed p) |-- C.

End EmbedPropProp.

Section EmbedPropInj.
  Context {A : Type} `{ILA : ILogic A}.
  Context {EmbOp1 : EmbedOp Prop A} {Emb1 : Embed Prop A}.
  Context {EmbOp2 : EmbedOp Prop A} {Emb2 : Embed Prop A}.

  Lemma emb_prop_eq (P : Prop) : @embed _ _ EmbOp1 P -|- @embed _ _ EmbOp2 P.

End EmbedPropInj. *)

Set Implicit Arguments.
Unset Strict Implicit.
Set Maximal Implicit Insertion.

Definition Fun (A B : Type) := A -> B.

Section ILogic_Pre.
  Context T (ord: relation T) {HPre : PreOrder ord}.
  Context {A : Type} `{IL: ILogic A}.

  Record ILPreFrm := mkILPreFrm {
    ILPreFrm_pred :> T -> A;
    ILPreFrm_closed: forall t t': T, ord t t' ->
      ILPreFrm_pred t |-- ILPreFrm_pred t'
  }.

  Notation "'mk'" := @mkILPreFrm.

  Global Instance ILPreFrm_m (P: ILPreFrm): Proper (ord ++> lentails) (ILPreFrm_pred P).
  Proof.
    intros t t' Ht. apply ILPreFrm_closed; assumption.
  Qed.

  Program Definition ILPreFrm_atom (a : A) := mk (fun t => a) _.

  Local Obligation Tactic :=
    repeat match goal with
    | |- ord _ _ -> _ => intros Hord; try setoid_rewrite Hord; reflexivity
    | |- _ => intro
    end.

  Global Program Instance ILPre_Ops : ILogicOps ILPreFrm := {|
    lentails P Q := forall t:T, (ILPreFrm_pred P) t |-- (ILPreFrm_pred Q) t;
    ltrue        := mk (fun t => ltrue) _;
    lfalse       := mk (fun t => lfalse) _;
    limpl    P Q := mk (fun t => Forall t', Forall Ht' : ord t t', (ILPreFrm_pred P) t' -->> (ILPreFrm_pred Q) t') _;
    land     P Q := mk (fun t => (ILPreFrm_pred P) t //\\ (ILPreFrm_pred Q) t) _;
    lor      P Q := mk (fun t => (ILPreFrm_pred P) t \\// (ILPreFrm_pred Q) t) _;
    lforall  A P := mk (fun t => Forall a, (ILPreFrm_pred (P a)) t) _;
    lexists  A P := mk (fun t => Exists a, (ILPreFrm_pred (P a)) t) _
  |}.
  Next Obligation.
    apply lforallR; intro t''.
    apply lforallR; intro Ht'.
    apply lforallL with t''.
    assert (ord t t'') as Ht'' by (transitivity t'; assumption).
    apply lforallL with Ht''; reflexivity.
  Defined.
  Next Obligation.
    simpl; rewrite H; reflexivity.
  Defined.
  Next Obligation.
    simpl; rewrite H; reflexivity.
  Defined.
  Next Obligation.
    simpl; setoid_rewrite H; reflexivity.
  Defined.
  Next Obligation.
    simpl; setoid_rewrite H; reflexivity.
  Defined.

  Program Definition ILPre_ILogic : ILogic ILPreFrm.
  Proof.
   split; unfold lentails; simpl; intros.
    - split; red; [reflexivity|].
      intros P Q R HPQ HQR t.
      transitivity ((ILPreFrm_pred Q) t); [apply HPQ | apply HQR].
    - apply ltrueR.
    - apply lfalseL.
    - apply lforallL with x; apply H.
    - apply lforallR; intro x; apply H.
    - apply lexistsL; intro x; apply H.
    - apply lexistsR with x; apply H.
    - apply landL1; eapply H; assumption.
    - apply landL2; eapply H; assumption.
    - apply lorR1; eapply H; assumption.
    - apply lorR2; eapply H; assumption.
    - apply landR; [eapply H | eapply H0]; assumption.
    - apply lorL; [eapply H | eapply H0]; assumption.
    - apply landAdj.
      etransitivity; [apply H|]. apply lforallL with t.
      apply lforallL; reflexivity.
    - apply lforallR; intro t'; apply lforallR; intro Hord. apply limplAdj.
      rewrite ->Hord; eapply H; assumption.
  Qed.

  Global Existing Instance ILPre_ILogic.

  Global Instance ILPreFrm_pred_m {H : PreOrder ord}:
    Proper (lentails ++> ord ++> lentails) ILPreFrm_pred.
  Proof.
    intros P P' HPt t t' Ht. rewrite ->Ht. apply HPt.
  Qed.

  Global Instance ILPreFrm_pred_equiv_m:
    Equivalence ord ->
    Proper (lequiv ==> ord ==> lequiv) ILPreFrm_pred.
  Proof.
    intros Hord P P' HPt t t' Ht. split.
    - rewrite ->Ht. apply HPt.
    - symmetry in Ht. rewrite <-Ht. apply HPt.
  Qed.

  Global Instance ILPreFrm_pred_entails_eq_m:
    Proper (lentails ++> eq ++> lentails) ILPreFrm_pred.
  Proof.
    intros P P' HPt t t' Ht. subst; apply HPt.
  Qed.

  Global Instance ILPreFrm_pred_equiv_eq_m:
    Proper (lequiv ==> eq ==> lequiv) ILPreFrm_pred.
  Proof.
    intros P P' HPt t t' Ht. split; subst; apply HPt.
  Qed.

  Program Definition ILPreAtom {HPre : PreOrder ord} (t: T) :=
    mk (fun t' => Exists x : ord t t', ltrue) _.
  Next Obligation.
    apply lexistsL; intro H1.
    apply lexistsR; [transitivity t0; assumption | apply ltrueR].
  Qed.

End ILogic_Pre.

Arguments ILPreFrm [T] _ _ {ILOps} : rename.
Arguments mkILPreFrm {T} [ord] [A] {ILOps} _ _ : rename.

Section Embed_ILogic_Pre.
  Context T (ord: relation T) {HPre : PreOrder ord}.
  Context {A : Type} `{ILA: ILogic A}.
  Context {B : Type} `{ILB: ILogic B}.
  Context {HEmbOp : EmbedOp A B} {HEmb : Embed A B}.

   Global Program Instance EmbedILPreDropOp : EmbedOp A (ILPreFrm ord B) := {
     embed := fun a => mkILPreFrm (fun x => embed a) _
  }.

  Global Instance EmbedILPreDrop : Embed A (ILPreFrm ord B).
  Proof.
    split; intros.
    + simpl; intros. apply embed_sound; assumption.
    + split; intros t; simpl; apply embedlforall.
    + split; intros t; simpl; apply embedlexists.
    + split; intros t; simpl.
      * apply lforallL with t. apply lforallL; [reflexivity | apply embedImpl].
      * apply lforallR; intro x; apply lforallR; intro H. apply embedImpl.
  Qed.

  Global Program Instance EmbedILPreOp : EmbedOp (ILPreFrm ord A) (ILPreFrm ord B) := {
     embed := fun a => mkILPreFrm (fun x => embed ((ILPreFrm_pred a) x)) _
  }.
  Next Obligation.
  	rewrite H. reflexivity.
  Defined.

  Global Instance EmbedILPre : Embed (ILPreFrm ord A) (ILPreFrm ord B).
  Proof.
    split; intros.
    + simpl; intros. apply embed_sound; apply H.
    + split; intros t; simpl; apply embedlforall.
    + split; intros t; simpl; apply embedlexists.
    + split; intros t; simpl;
      do 2 setoid_rewrite <- embedlforall;
      apply lforallR; intro t'; apply lforallR; intro H;
      apply lforallL with t'; apply lforallL with H; apply embedImpl.
  Qed.

End Embed_ILogic_Pre.

Section ILogic_Fun.
  Context (T: Type).
  Context {A : Type} `{IL: ILogic A}.

  Global Program Instance ILFun_Ops : ILogicOps ((fun x y => x -> y) T A) := {|
    lentails P Q := forall t:T, P t |-- Q t;
    ltrue        := fun t => ltrue;
    lfalse       := fun t => lfalse;
    limpl    P Q := fun t => P t -->> Q t;
    land     P Q := fun t => P t //\\ Q t;
    lor      P Q := fun t => P t \\// Q t;
    lforall  A P := fun t => Forall a, P a t;
    lexists  A P := fun t => Exists a, P a t
  |}.

  Program Definition ILFun_ILogic : @ILogic _ ILFun_Ops.
  Proof.
    split; unfold lentails; simpl; intros.
    - split; red; [reflexivity|].
      intros P Q R HPQ HQR t. transitivity (Q t); [apply HPQ | apply HQR].
    - apply ltrueR.
    - apply lfalseL.
    - apply lforallL with x; apply H.
    - apply lforallR; intros; apply H.
    - apply lexistsL; intros; apply H.
    - apply lexistsR with x; apply H.
    - apply landL1; intuition.
    - apply landL2; intuition.
    - apply lorR1; intuition.
    - apply lorR2; intuition.
    - apply landR; intuition.
    - apply lorL; intuition.
    - apply landAdj; intuition.
    - apply limplAdj; intuition.
  Qed.

  Global Existing Instance ILFun_ILogic.

End ILogic_Fun.

Section ILogic_Option.
  Context {A : Type} `{IL: ILogic A}.

  Definition toProp (P : option A) :=
    match P with
    | Some P => P
    | None => lfalse
    end.

  Global Program Instance ILOption_Ops : ILogicOps (option A) :=
  {| lentails P Q := toProp P |-- toProp Q
   ; ltrue        := Some ltrue
   ; lfalse       := Some lfalse
   ; limpl    P Q := Some (toProp P -->> toProp Q)
   ; land     P Q := Some (toProp P //\\ toProp Q)
   ; lor      P Q := Some (toProp P \\// toProp Q)
   ; lforall  A P := Some (Forall a, toProp (P a))
   ; lexists  A P := Some (Exists a, toProp (P a))
   |}.

  Program Definition ILOption_ILogic : ILogic (option A).
  Proof.
    split; unfold lentails; simpl; intros.
    - split; red; [reflexivity|].
      intros P Q R HPQ HQR. transitivity (toProp Q); [apply HPQ | apply HQR].
    - apply ltrueR.
    - apply lfalseL.
    - apply lforallL with x; apply H.
    - apply lforallR; intros; apply H.
    - apply lexistsL; intros; apply H.
    - apply lexistsR with x; apply H.
    - apply landL1; intuition.
    - apply landL2; intuition.
    - apply lorR1; intuition.
    - apply lorR2; intuition.
    - apply landR; intuition.
    - apply lorL; intuition.
    - apply landAdj; intuition.
    - apply limplAdj; intuition.
  Qed.

End ILogic_Option.

Section Embed_ILogic_Fun.
  Context {A : Type} `{ILA: ILogic A}.
  Context {B : Type} `{ILB: ILogic B}.
  Context {HEmbOp : EmbedOp A B} {HEmb : Embed A B}.

  Program Instance EmbedILFunDropOp {T} : EmbedOp A (T -> B) :=
  { embed := fun a t => embed a }.

  Local Existing Instance ILFun_Ops.

  Instance EmbedILFunDrop {T} : Embed A (T -> B).
  Proof.
    split; intros.
    + simpl; intros. apply embed_sound; assumption.
    + split; intros t; simpl; apply embedlforall.
    + split; intros t; simpl; apply embedlexists.
    + split; intros t; simpl; apply embedImpl.
  Qed.

  Program Instance EmbedILFunOp {T} : EmbedOp (T -> A) (T -> B) :=
  { embed := fun a x => embed (a x) }.

  Instance EmbedILFun {T} : Embed (T -> A) (T -> B).
  Proof.
    split; intros.
    + simpl; intros. apply embed_sound; apply H.
    + split; intros t; simpl; apply embedlforall.
    + split; intros t; simpl; apply embedlexists.
    + split; intros t; simpl; apply embedImpl.
  Qed.

End Embed_ILogic_Fun.

Global Opaque ILOption_Ops.
Global Opaque ILFun_Ops.
Global Opaque ILPre_Ops.
