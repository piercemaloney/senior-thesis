Require Import ChargeCore.SepAlg.SepAlg.
(* ChargeCore.SepAlg.SepAlg:
Require Import Setoid Morphisms RelationClasses Program.Basics Omega.

Set Implicit Arguments.
Unset Strict Implicit.
Set Maximal Implicit Insertion.

Section SepAlgSect.
  Class SepAlgOps T:= {
    sa_unit : T -> Prop;
    sa_mul : T -> T -> T -> Prop
  }.

  Class SepAlg T `{rel : T -> T -> Prop} `{SAOps: SepAlgOps T} : Type := {
    sa_type            :> Equivalence rel;
    sa_mulC a b c      : sa_mul a b c -> sa_mul b a c;
    sa_mulA a b c      : forall ab abc, sa_mul a b ab -> sa_mul ab c abc ->
                                        exists bc, sa_mul b c bc /\ sa_mul a bc abc;
    sa_unit_ex a       : exists e, sa_unit e /\ sa_mul a e a;
    sa_unit_eq a a' e  : sa_unit e -> sa_mul a e a' -> rel a' a;
    sa_unit_proper     : Proper (rel ==> iff) sa_unit;
    sa_mul_mon a b c d : rel a b -> sa_mul a c d -> sa_mul b c d
  }.

End SepAlgSect.

Arguments SepAlg {T} {rel} {SAOps} : rename.

Section SepAlgCompat.
  Context A `{SA: SepAlg A}.

  Definition compat (a b : A) := exists s, sa_mul a b s.
  Definition subheap (a b : A) := exists c, sa_mul a c b.

  Lemma sa_mul_monR (a b c d : A) (Habc : sa_mul a b c) (Hcd: rel c d) : sa_mul a b d.

  Lemma sa_mulC2 a b c : sa_mul a b c <-> sa_mul b a c.

  Global Instance sa_mul_proper : Proper (rel ==> rel ==> rel ==> iff) sa_mul.

Existing Instance sa_unit_proper.

Lemma join_sub_units_eq A `{SepAlg A} (a b ea eb a': A):
  sa_mul a a' b ->
  sa_mul a ea a -> sa_unit ea ->
  sa_mul b eb b -> sa_unit eb ->
  rel ea eb.

Section Properties.
  Context A `{sa : SepAlg A}.
  Open Scope sa_scope.

  Global Instance sa_subheap_equiv_proper :
    Proper (rel ==> rel ==> iff) (subheap (A := A)).

  Global Instance sa_subheap_subheap_proper :
     Proper (subheap --> subheap ++> impl) (subheap (A := A)).

  Global Instance sa_compat_equiv_proper :
    Proper (rel ==> rel ==> iff) (compat (A := A)).

  Lemma compat_subheap {r t : A} (s : A) (Hsr: r <= s) (Hst: s # t) : r # t.

  Lemma subheapT (a b c : A) (Hab: a <= b) (Hbc: b <= c) : a <= c.

 Close Scope sa_scope.

End Properties.

Arguments SepAlg _ {rel SAOps} : rename.
Arguments subheap {A} {SAOps}.
Arguments subheapT {A rel SAOps SA} [_ _ _] : rename.
Arguments compat_subheap {A rel SAOps SA} [_ _ _] _ _ : rename. *)



Set Implicit Arguments.

Unset Strict Implicit.

Set Maximal Implicit Insertion.



Section UUSepAlg.

  Context {A : Type} `{SA : SepAlg A}.



  Class UUSepAlg :=

  { uusa          :> SepAlg (rel := rel) A

  ; uusa_unit a u : sa_unit u -> sa_mul a u a

  }.



End UUSepAlg.



Section SepAlgUniqueUnit.

  Context {A : Type} `{SA : UUSepAlg A}.



  Lemma sep_alg_unique_unit u1 u2 (Hu1 : sa_unit u1) (Hu2 : sa_unit u2)

  : rel u1 u2.

  Proof.

    pose proof (uusa_unit u1 Hu2) as H.

    apply sa_mulC in H. apply sa_unit_eq in H; eassumption.

  Qed.



End SepAlgUniqueUnit.



Arguments UUSepAlg _ {rel SAOps} : rename.
