Require Import Setoid Morphisms RelationClasses Program.Basics.

From ChargeCore.Logics Require Import ILogic BILogic ILInsts Pure.
(* ChargeCore.Logics.ILogic:
Require Import Setoid Morphisms RelationClasses Program.Basics Omega.

Set Implicit Arguments.
Unset Strict Implicit.
Set Maximal Implicit Insertion.

Global Instance ge_Pre: PreOrder ge.

Class ILogicOps (A : Type) : Type := {
  lentails: A -> A -> Prop;
  ltrue: A;
  lfalse: A;
  limpl: A -> A -> A;
  land: A -> A -> A;
  lor: A -> A -> A;
  lforall: forall {T : Type}, (T -> A) -> A;
  lexists: forall {T : Type}, (T -> A) -> A
}.

Infix "|--"  := lentails (at level 80, no associativity).
Infix "//\\"   := land (at level 75, right associativity).
Infix "\\//"   := lor (at level 76, right associativity).
Infix "-->>"   := limpl (at level 77, right associativity).
Notation "'Forall' x : T , p" :=
  (lforall (fun x : T => p)) (at level 78, x ident, right associativity).
Notation "'Forall' x , p" :=
  (lforall (fun x => p)) (at level 78, x ident, right associativity, only parsing).
Notation "'Exists' x : T , p" :=
  (lexists (fun x : T => p)) (at level 78, x ident, right associativity).
Notation "'Exists' x , p" :=
  (lexists (fun x => p)) (at level 78, x ident, right associativity, only parsing).

Section ILogicEquiv.
  Context {A : Type} `{IL: ILogicOps A}.

  Definition lequiv P Q := P |-- Q /\ Q |-- P.
End ILogicEquiv.

Infix "-|-"  := lequiv (at level 85, no associativity).

Class ILogic {A : Type} {ILOps: ILogicOps A} : Type := {
  lentailsPre:> PreOrder lentails;
  ltrueR: forall (C : A), C |-- ltrue;
  lfalseL: forall (C : A), lfalse |-- C;
  lforallL: forall (T : Type) x (P: T -> A) C, P x |-- C -> lforall P |-- C;
  lforallR: forall (T : Type) (P: T -> A) C, (forall x, C |-- P x) -> C |-- lforall P;
  lexistsL: forall (T : Type) (P: T -> A) C, (forall x, P x |-- C) -> lexists P |-- C;
  lexistsR: forall (T : Type) (x : T) (P: T -> A) C, C |-- P x -> C |-- lexists P;
  landL1: forall (P Q C : A), P |-- C  ->  P //\\ Q |-- C;
  landL2: forall (P Q C : A), Q |-- C  ->  P //\\ Q |-- C;
  lorR1:  forall (P Q C : A), C |-- P  ->  C |-- P \\// Q;
  lorR2:  forall (P Q C : A), C |-- Q  ->  C |-- P \\// Q;
  landR:  forall (P Q C : A), C |-- P  ->  C |-- Q  ->  C |-- P //\\ Q;
  lorL:   forall (P Q C : A), P |-- C  ->  Q |-- C  ->  P \\// Q |-- C;
  landAdj: forall (P Q C : A), C |-- (P -->> Q) -> C //\\ P |-- Q;
  limplAdj: forall (P Q C : A), C //\\ P |-- Q -> C |-- (P -->> Q)
}.

Arguments ILogic _ {ILOps}.
Arguments lforallL {A ILOps ILogic} [T] x P C _.
Arguments lexistsR {A ILOps ILogic} [T] x P C _.

Notation "|--  P" := (ltrue |-- P) (at level 85, no associativity).
Hint Extern 0 (?x |-- ?x) => reflexivity.
Hint Extern 0 (_ |-- ltrue) => apply ltrueR.
Hint Extern 0 (lfalse |-- _) => apply lfalseL.
Hint Extern 0 (?P |-- ?Q) => (is_evar P; reflexivity) || (is_evar Q; reflexivity).

Section ILogicEquiv2.
  Context {A : Type} `{IL: ILogic A}.

  Global Instance lequivEquivalence : Equivalence lequiv.

End ILogicEquiv2.

Section ILogicEquivOps.
  Context {A : Type} `{IL: ILogic A}.

  Lemma land_is_forall P Q :
    P //\\ Q -|- Forall b : bool, if b then P else Q.

  Lemma lor_is_exists P Q:
    P \\// Q -|- Exists b : bool, if b then P else Q.

  Lemma ltrue_is_forall:
    ltrue -|- Forall x: Empty_set, Empty_set_rect _ x.

  Lemma lfalse_is_exists:
    lfalse -|- Exists x: Empty_set, Empty_set_rect _ x.

End ILogicEquivOps.

Section ILogicMorphisms.
  Context {A T : Type} `{IL: ILogic A}.

  Global Instance lequiv_lentails : subrelation lequiv lentails.
  Global Instance lequiv_flip_lentails: subrelation lequiv (flip lentails).

  Global Instance lforall_lentails_m:
    Proper (pointwise_relation T lentails ++> lentails) lforall.

  Global Instance lforall_lequiv_m:
    Proper (pointwise_relation T lequiv ++> lequiv) lforall.

  Global Instance lexists_lentails_m:
    Proper (pointwise_relation T lentails ++> lentails) lexists.

  Global Instance lexists_lequiv_m:
    Proper (pointwise_relation T lequiv ++> lequiv) lexists.

  Global Instance : Proper (lequiv ==> lequiv ==> iff) lequiv.

  Global Instance lequiv_lentails_m : Proper (lequiv ==> lequiv ==> iff) lentails.

  Global Instance lentails_lentails_m: Proper (lentails --> lentails ++> impl) lentails.

  Global Instance land_lentails_m:
    Proper (lentails ++> lentails ++> lentails) land.

  Global Instance land_lequiv_m:
    Proper (lequiv ==> lequiv ==> lequiv) land.

  Global Instance lor_lentails_m:
    Proper (lentails ++> lentails ++> lentails) lor.

  Global Instance lor_lequiv_m:
    Proper (lequiv ==> lequiv ==> lequiv) lor.

  Global Instance limpl_lentails_m:
    Proper (lentails --> lentails ++> lentails) limpl.

  Global Instance limpl_lequiv_m:
    Proper (lequiv ==> lequiv ==> lequiv) limpl.

End ILogicMorphisms.

Hint Extern 0 (?x -|- ?x) => reflexivity.
Hint Extern 0 (?P -|- ?Q) => (is_evar P; reflexivity) || (is_evar Q; reflexivity).

Lemma lforwardL {A} `{IL: ILogic A} {Q R}:
    Q |-- R -> forall P G,
    P |-- Q ->
    (P |-- R -> G) ->
    G.

Tactic Notation "lforwardL" hyp(H) :=
  eapply (lforwardL H); clear H; [|intros H].

Section ILogicFacts.
  Context {A T : Type} `{IL: ILogic A}.

  Ltac landR :=
    repeat match goal with
    | |- _ |-- _ //\\ _ => apply landR
    end.

  Ltac landL :=
    repeat match goal with
    | |- ?L1 //\\ ?L2 |-- ?R =>
        match L1 with
        | context [R] => apply landL1
        | _ =>
          match L2 with
          | context [R] => apply landL2
          end
        end
    end.
    
  Lemma lentails_refl P : P |-- P.

  Lemma landC P Q: P //\\ Q -|- Q //\\ P.

  Lemma landA P Q R: (P //\\ Q) //\\ R -|- P //\\ (Q //\\ R).

  Lemma lorC P Q : P \\// Q -|- Q \\// P.

  Lemma lorA P Q R : (P \\// Q) \\// R -|- P \\// (Q \\// R).

  Lemma limplValid P Q:
    |-- P -->> Q <->
    P |-- Q.

  Lemma limplL P Q CL CR (HP: CL |-- P) (HR: Q //\\ CL |-- CR) :
    (P -->> Q) //\\ CL |-- CR.

  Lemma limplAdj2 P Q R : P -->> Q -->> R -|- P //\\ Q -->> R.

  Lemma landexistsDL1 (f : T -> A) (P : A) :
    lexists f //\\ P |-- Exists a, (f a //\\ P).

  Lemma landexistsDL2 (f : T -> A) (P : A) :
    P //\\ lexists f |-- Exists a, (P //\\ f a).
  
  Lemma landexistsDR1 (f : T -> A) (P : A) :
     Exists a, (f a //\\ P) |-- lexists f //\\ P.

  Lemma landexistsDR2 (f : T -> A) (P : A) :
     Exists a, (P //\\ f a) |-- P //\\ lexists f.
  
  Lemma landexistsD1 (f : T -> A) (P : A) :
    (Exists a, f a) //\\ P -|- Exists a, (f a //\\ P).

  Lemma lorexistsDL (f : T -> A) (P : A) {H : Inhabited T} :
    (Exists a, f a) \\// P |-- Exists a, (f a \\// P).

  Lemma lorexistsDR (f : T -> A) (P : A) :
     Exists a, (f a \\// P) |-- (Exists a, f a) \\// P.

  Lemma lorexistsD (f : T -> A) (P : A) {H : Inhabited T} :
    (Exists a, f a) \\// P -|- Exists a, (f a \\// P).

  Lemma landforallDL (f : T -> A) (P : A) :
    (Forall a, f a) //\\ P |-- Forall a, (f a //\\ P).

  Lemma landforallDR {H: Inhabited T} (f : T -> A) (P : A) :
    Forall a, (f a //\\ P) |-- (Forall a, f a) //\\ P.

  Lemma landforallD (f : T -> A) (P : A) {H : Inhabited T} :
    (Forall a, f a) //\\ P -|- Forall a, (f a //\\ P).

  Lemma lorforallDL (f : T -> A) (P : A) :
    (Forall a, f a) \\// P |-- Forall a, (f a \\// P).

  Lemma limplTrue P : ltrue -->> P -|- P.

  Lemma limplexistsE (P : T -> A) (Q : A) :
    (Exists x, P x) -->> Q -|- Forall x, (P x -->> Q).

  Lemma limplforallER (P : T -> A) (Q : A) :
    Exists x, (P x -->> Q) |-- (Forall x, P x) -->> Q.

  Lemma lforallR2 (P : A) (Q : T -> A) (H : P |-- lforall Q) :
  	forall x, P |-- Q x.

  Lemma lexistsL2 (P : T -> A) (Q : A) (H : lexists P |-- Q) :
  	forall x, P x |-- Q.

  Lemma landtrueL : forall a, ltrue //\\ a -|- a.

  Lemma landtrueR : forall a, a //\\ ltrue -|- a.

  Lemma curry : forall a b c, (a //\\ b) -->> c -|- a -->> (b -->> c).

End ILogicFacts.

Global Instance ILogicOps_Prop : ILogicOps Prop := {|
  lentails P Q := (P : Prop) -> Q;
  ltrue        := True;
  lfalse       := False;
  limpl    P Q := P -> Q;
  land     P Q := P /\ Q;
  lor      P Q := P \/ Q;
  lforall  T F := forall x:T, F x;
  lexists  T F := exists x:T, F x
 |}.

Global Instance ILogic_Prop : ILogic Prop. *)
(* ChargeCore.Logics.BILogic:
Require Import Coq.Setoids.Setoid.
Require Import Coq.Classes.Morphisms.
Require Import Coq.Classes.RelationClasses.
From ChargeCore.Logics Require Import ILogic ILEmbed.

Set Implicit Arguments.
Unset Strict Implicit.
Set Maximal Implicit Insertion.

Section BILogic.
  Definition BILogicType := Type.

  Context {A : BILogicType}.
  Context {HILOp: ILogicOps A}.

  Class BILogicOps (A : BILogicType) : Type := {
    empSP  : A;
    sepSP  : A -> A -> A;
    wandSP : A -> A -> A
  }.

  Class BILogic {BILOp: BILogicOps A} : Type := {
    bilil :> ILogic A;
    sepSPC1 P Q : sepSP P Q |-- sepSP Q P;
    sepSPA1 P Q R : sepSP (sepSP P Q) R |-- sepSP P (sepSP Q R);
    wandSepSPAdj P Q R : sepSP P Q |-- R <-> P |-- wandSP Q R;
    bilsep P Q R : P |-- Q -> sepSP P R |-- sepSP Q R;
    empSPR P : sepSP P empSP -|- P
  }.

End BILogic.

Arguments BILogic _ {BILOp HILOp} : rename.

Notation "a '**' b"  := (sepSP a b)
  (at level 58, right associativity).
Notation "a '-*' b"  := (wandSP a b)
  (at level 60, right associativity).

Section CoreInferenceRules.

  Context {A T : Type} `{HBIL: BILogic A}.

  Lemma wandSPAdj P Q C (HSep: C ** P |-- Q) : C |-- P -* Q.

  Lemma wandSPAdj' P Q C (HSep: P ** C |-- Q) : C |-- P -* Q.

  Lemma sepSPAdj P Q C (HWand: C |-- P -* Q) : C ** P |-- Q.

  Lemma sepSPAdj' P Q C (HWand: C |-- P -* Q) : P ** C |-- Q.

  Lemma sepSPC (P Q : A) : P ** Q -|- Q ** P.

  Lemma sepSPA2 (P Q R : A) : P ** (Q ** R) |-- (P ** Q) ** R.

  Lemma sepSPA (P Q R : A) : (P ** Q) ** R -|- P ** (Q ** R).

  Lemma wandSPI (P Q R : A) (HQ : P ** Q |-- R) : (P |-- Q -* R).

  Lemma wandSPE (P Q R S : A) (HQR: Q |-- S -* R) (HP : P |-- Q ** S) : P |-- R.

  Lemma empSPL P : empSP ** P -|- P.

  Lemma bilexistsscR1 (P : A) (f : T -> A):
    Exists x : T, P ** f x |-- P ** lexists f.

  Lemma bilexistsscR2 (P : A) (f : T -> A):
    Exists x : T, f x ** P |-- lexists f ** P.

    Lemma bilexistsscL1 (P : A) (f : T -> A) :
    P ** lexists f |-- Exists x : T, P ** f x.

  Lemma bilexistsscL2 (P : A) (f : T -> A) :
    lexists f ** P |-- Exists x : T, f x ** P.

    Lemma bilexistssc (P : A) (Q : T -> A) :
    Exists x : T, P ** Q x -|- P ** lexists Q.

  Lemma bilforallscR (P : A) (Q : T -> A) :
    P ** lforall Q |-- Forall x : T, P ** Q x.

  Lemma bilandscDL (P Q R : A) : (P //\\ Q) ** R |-- (P ** R) //\\ (Q ** R).

  Lemma bilorscDL (P Q R : A) : (P \\// Q) ** R -|- (P ** R) \\// (Q ** R).

End CoreInferenceRules.

Section BILogicMorphisms.
  Context {A : BILogicType} `{BIL: BILogic A}.

  Global Instance sepSP_lentails_m:
    Proper (lentails ++> lentails ++> lentails) sepSP.

  Global Instance sepSP_lequiv_m:
    Proper (lequiv ==> lequiv ==> lequiv) sepSP.

  Global Instance wandSP_lentails_m:
    Proper (lentails --> lentails ++> lentails) wandSP.

  Global Instance wandSP_lequiv_m:
    Proper (lequiv ==> lequiv ==> lequiv) wandSP.

End BILogicMorphisms.

Section DerivedInferenceRules.

  Context {A : BILogicType} `{BILogic A}.

  Lemma sepSP_falseR P : P ** lfalse -|- lfalse.

  Lemma sepSP_falseL P : lfalse ** P -|- lfalse.

  Lemma scME (P Q R S : A) (HPR: P |-- R) (HQS: Q |-- S) :
    P ** Q |-- R ** S.

  Lemma wandSPL P Q CL CR (HP: CL |-- P) (HR: Q |-- CR) :
    (P -* Q) ** CL |-- CR.

  Lemma siexistsE {T : Type} (P : T -> A) (Q : A) :
    lexists P -* Q -|- Forall x, (P x -* Q).

  Lemma septrue : forall p, p |-- p ** ltrue.

  Lemma wand_curry : forall a b c, (a ** b) -* c -|- a -* (b -* c).

End DerivedInferenceRules. *)
(* ChargeCore.Logics.ILInsts:
Require Import Coq.Classes.RelationClasses.
Require Import Coq.Setoids.Setoid.
Require Import Coq.Classes.Morphisms.
From ChargeCore.Logics Require Import ILogic ILEmbed.

Set Implicit Arguments.
Unset Strict Implicit.
Set Maximal Implicit Insertion.

Definition Fun (A B : Type) := A -> B.

Section ILogic_Pre.
  Context T (ord: relation T) {HPre : PreOrder ord}.
  Context {A : Type} `{IL: ILogic A}.

  Record ILPreFrm := mkILPreFrm {
    ILPreFrm_pred :> T -> A;
    ILPreFrm_closed: forall t t': T, ord t t' ->
      ILPreFrm_pred t |-- ILPreFrm_pred t'
  }.

  Notation "'mk'" := @mkILPreFrm.

  Global Instance ILPreFrm_m (P: ILPreFrm): Proper (ord ++> lentails) (ILPreFrm_pred P).

  Program Definition ILPreFrm_atom (a : A) := mk (fun t => a) _.

  Program Definition ILPre_ILogic : ILogic ILPreFrm.

  Global Existing Instance ILPre_ILogic.

  Global Instance ILPreFrm_pred_m {H : PreOrder ord}:
    Proper (lentails ++> ord ++> lentails) ILPreFrm_pred.

  Global Instance ILPreFrm_pred_equiv_m:
    Equivalence ord ->
    Proper (lequiv ==> ord ==> lequiv) ILPreFrm_pred.

  Global Instance ILPreFrm_pred_entails_eq_m:
    Proper (lentails ++> eq ++> lentails) ILPreFrm_pred.

  Global Instance ILPreFrm_pred_equiv_eq_m:
    Proper (lequiv ==> eq ==> lequiv) ILPreFrm_pred.

  Program Definition ILPreAtom {HPre : PreOrder ord} (t: T) :=
    mk (fun t' => Exists x : ord t t', ltrue) _.

End ILogic_Pre.

Arguments ILPreFrm [T] _ _ {ILOps} : rename.
Arguments mkILPreFrm {T} [ord] [A] {ILOps} _ _ : rename.

Section Embed_ILogic_Pre.
  Context T (ord: relation T) {HPre : PreOrder ord}.
  Context {A : Type} `{ILA: ILogic A}.
  Context {B : Type} `{ILB: ILogic B}.
  Context {HEmbOp : EmbedOp A B} {HEmb : Embed A B}.

   Global Program Instance EmbedILPreDropOp : EmbedOp A (ILPreFrm ord B) := {
     embed := fun a => mkILPreFrm (fun x => embed a) _
  }.

  Global Instance EmbedILPreDrop : Embed A (ILPreFrm ord B).

  Global Instance EmbedILPre : Embed (ILPreFrm ord A) (ILPreFrm ord B).

End Embed_ILogic_Pre.

Section ILogic_Fun.
  Context (T: Type).
  Context {A : Type} `{IL: ILogic A}.

  Global Program Instance ILFun_Ops : ILogicOps ((fun x y => x -> y) T A) := {|
    lentails P Q := forall t:T, P t |-- Q t;
    ltrue        := fun t => ltrue;
    lfalse       := fun t => lfalse;
    limpl    P Q := fun t => P t -->> Q t;
    land     P Q := fun t => P t //\\ Q t;
    lor      P Q := fun t => P t \\// Q t;
    lforall  A P := fun t => Forall a, P a t;
    lexists  A P := fun t => Exists a, P a t
  |}.

  Program Definition ILFun_ILogic : @ILogic _ ILFun_Ops.

  Global Existing Instance ILFun_ILogic.

End ILogic_Fun.

Section ILogic_Option.
  Context {A : Type} `{IL: ILogic A}.

  Definition toProp (P : option A) :=
    match P with
    | Some P => P
    | None => lfalse
    end.

  Global Program Instance ILOption_Ops : ILogicOps (option A) :=
  {| lentails P Q := toProp P |-- toProp Q
   ; ltrue        := Some ltrue
   ; lfalse       := Some lfalse
   ; limpl    P Q := Some (toProp P -->> toProp Q)
   ; land     P Q := Some (toProp P //\\ toProp Q)
   ; lor      P Q := Some (toProp P \\// toProp Q)
   ; lforall  A P := Some (Forall a, toProp (P a))
   ; lexists  A P := Some (Exists a, toProp (P a))
   |}.

  Program Definition ILOption_ILogic : ILogic (option A).

End Embed_ILogic_Fun.

Global Opaque ILOption_Ops.
Global Opaque ILFun_Ops.
Global Opaque ILPre_Ops. *)
(* ChargeCore.Logics.Pure:
From ChargeCore.Logics Require Import ILogic ILInsts BILogic ILEmbed.
Require Import Coq.Setoids.Setoid.
Require Import Coq.Classes.Morphisms.

Set Implicit Arguments.
Unset Strict Implicit.
Set Maximal Implicit Insertion.

Section Pure.

  Context {A : Type} {ILOPs : ILogicOps A} {BILOps : BILogicOps A}.

  Class PureOp := {
    pure : A -> Prop
  }.

  Definition parameter_pure (pure : A -> Prop) (P : A) : Prop :=
    (forall Q, P //\\ Q |-- P ** Q) /\
    (forall Q, pure Q -> P ** Q |-- P //\\ Q) /\
    (forall Q R, (P //\\ Q) ** R -|- P //\\ (Q ** R)) /\
    (forall Q, P -* Q |-- P -->> Q) /\
    (forall Q, pure Q -> P -->> Q |-- P -* Q).

  Class Pure {HP : PureOp} :=
  { pure_axiom : forall p, pure p -> parameter_pure pure p
  ; pure_proper : Proper (lequiv ==> iff) pure
  }.

  Existing Class pure.

  Context (IL : ILogic A) (BIL : BILogic A) (po : PureOp) (p : @Pure po).

  Lemma pureandsc P Q : pure P -> P //\\ Q |-- P ** Q.

  Lemma purescand  P Q : pure P -> pure Q -> P ** Q |-- P //\\ Q.

  Lemma pureandscD P Q R : pure P -> (P //\\ Q) ** R -|- P //\\ (Q ** R).

  Lemma puresiimpl P Q : pure P -> P -* Q |-- P -->> Q.

  Lemma pureimplsi P Q : pure P -> pure Q -> P -->> Q |-- P -* Q.

End Pure.

Arguments Pure {A ILOPs BILOps} HP : rename.
Arguments PureOp _ : rename, clear implicits. *)

From ChargeCore.SepAlg Require Import SepAlg.
(* ChargeCore.SepAlg.SepAlg:
Require Import Setoid Morphisms RelationClasses Program.Basics Omega.

Set Implicit Arguments.
Unset Strict Implicit.
Set Maximal Implicit Insertion.

Section SepAlgSect.
  Class SepAlgOps T:= {
    sa_unit : T -> Prop;
    sa_mul : T -> T -> T -> Prop
  }.

  Class SepAlg T `{rel : T -> T -> Prop} `{SAOps: SepAlgOps T} : Type := {
    sa_type            :> Equivalence rel;
    sa_mulC a b c      : sa_mul a b c -> sa_mul b a c;
    sa_mulA a b c      : forall ab abc, sa_mul a b ab -> sa_mul ab c abc ->
                                        exists bc, sa_mul b c bc /\ sa_mul a bc abc;
    sa_unit_ex a       : exists e, sa_unit e /\ sa_mul a e a;
    sa_unit_eq a a' e  : sa_unit e -> sa_mul a e a' -> rel a' a;
    sa_unit_proper     : Proper (rel ==> iff) sa_unit;
    sa_mul_mon a b c d : rel a b -> sa_mul a c d -> sa_mul b c d
  }.

End SepAlgSect.

Arguments SepAlg {T} {rel} {SAOps} : rename.

Section SepAlgCompat.
  Context A `{SA: SepAlg A}.

  Definition compat (a b : A) := exists s, sa_mul a b s.
  Definition subheap (a b : A) := exists c, sa_mul a c b.

  Lemma sa_mul_monR (a b c d : A) (Habc : sa_mul a b c) (Hcd: rel c d) : sa_mul a b d.

  Lemma sa_mulC2 a b c : sa_mul a b c <-> sa_mul b a c.

  Global Instance sa_mul_proper : Proper (rel ==> rel ==> rel ==> iff) sa_mul.

Existing Instance sa_unit_proper.

Lemma join_sub_units_eq A `{SepAlg A} (a b ea eb a': A):
  sa_mul a a' b ->
  sa_mul a ea a -> sa_unit ea ->
  sa_mul b eb b -> sa_unit eb ->
  rel ea eb.

Section Properties.
  Context A `{sa : SepAlg A}.
  Open Scope sa_scope.

  Global Instance sa_subheap_equiv_proper :
    Proper (rel ==> rel ==> iff) (subheap (A := A)).

  Global Instance sa_subheap_subheap_proper :
     Proper (subheap --> subheap ++> impl) (subheap (A := A)).

  Global Instance sa_compat_equiv_proper :
    Proper (rel ==> rel ==> iff) (compat (A := A)).

  Lemma compat_subheap {r t : A} (s : A) (Hsr: r <= s) (Hst: s # t) : r # t.

  Lemma subheapT (a b c : A) (Hab: a <= b) (Hbc: b <= c) : a <= c.

 Close Scope sa_scope.

End Properties.

Arguments SepAlg _ {rel SAOps} : rename.
Arguments subheap {A} {SAOps}.
Arguments subheapT {A rel SAOps SA} [_ _ _] : rename.
Arguments compat_subheap {A rel SAOps SA} [_ _ _] _ _ : rename. *)



Set Implicit Arguments.

Unset Strict Implicit.

Set Maximal Implicit Insertion.



Section BISepAlg.

  Context {A} `{sa : SepAlg A}.

  Context {B : Type} `{IL: ILogic B}.

  Context {HPre : PreOrder rel}.



  Open Scope sa_scope.



  Local Transparent ILPre_Ops.



  Global Program Instance SABIOps: BILogicOps (ILPreFrm rel B) := {

    empSP := mkILPreFrm (fun x => Exists a : (sa_unit x), ltrue) _;

    sepSP P Q :=  mkILPreFrm (fun x => Exists x1, Exists x2, Exists H : sa_mul x1 x2 x,

                                                (ILPreFrm_pred P) x1 //\\ (ILPreFrm_pred Q) x2) _;

    wandSP P Q := mkILPreFrm (fun x => Forall x1, Forall x2, Forall H : sa_mul x x1 x2,

                                                 (ILPreFrm_pred P) x1 -->> (ILPreFrm_pred Q) x2) _

  }.

  Next Obligation.

  	apply lexistsL; intro H1. eapply lexistsR. rewrite <- H. assumption. apply ltrueR.

  Qed.

  Next Obligation.

  	apply lexistsL; intro a; apply lexistsL; intro b; apply lexistsL; intro Hab.

  	apply lexistsR with a; apply lexistsR with b. eapply lexistsR. eapply sa_mul_monR; eassumption. reflexivity.

  Qed.

  Next Obligation.

	apply lforallR; intro a; apply lforallR; intro b; apply lforallR; intro Hab.

	apply lforallL with a; apply lforallL with b. apply lforallL. eapply sa_mul_mon; [symmetry|]; eassumption.

	reflexivity.

  Qed.



  Instance SABILogic : BILogic (ILPreFrm rel B).

    split.

    + apply _.

    + intros P Q x; simpl.

      apply lexistsL; intro x1; apply lexistsL; intro x2; apply lexistsL; intro H'; apply sa_mulC in H'.

      apply lexistsR with x2; apply lexistsR with x1; apply lexistsR with H'; apply landC.

    + intros P Q R x; simpl.

      apply lexistsL; intro x1; apply lexistsL; intro x2; apply lexistsL; intro Hx.

      repeat setoid_rewrite landexistsD1.

      apply lexistsL; intro x3. apply lexistsL; intro x4; apply lexistsL; intro Hx1.

      destruct (sa_mulA Hx1 Hx) as [x5 [Hx2 Hx5]].

      apply lexistsR with x3; apply lexistsR with x5; apply lexistsR with Hx5.

      rewrite landA. apply landR; [apply landL1; reflexivity| apply landL2].

      apply lexistsR with x4. apply lexistsR with x2; apply lexistsR with Hx2.

      reflexivity.

    + intros P Q R; split; intros H x; simpl.

      - apply lforallR; intro x1; apply lforallR; intro x2; apply lforallR; intro Hx1.

        apply limplAdj.

        specialize (H x2); simpl in H.

        rewrite <- H.

        apply lexistsR with x; apply lexistsR with x1; apply lexistsR with Hx1. reflexivity.

      - apply lexistsL; intro x1; apply lexistsL; intro x2; apply lexistsL; intro Hx.

        specialize (H x1); simpl in H.

        rewrite H.

		apply landAdj.

        apply lforallL with x2; apply lforallL with x; apply lforallL with Hx.

        reflexivity.

    + intros P Q R H x; simpl.

      apply lexistsL; intro x1; apply lexistsL; intro x2; apply lexistsL; intro Hx.

      repeat eapply lexistsR; [eassumption|].

      rewrite H. reflexivity.

    + intros P; split; intros x; simpl.

      - apply lexistsL; intro x1; apply lexistsL; intro x2; apply lexistsL; intro Hx.

        rewrite landC, landexistsD1. apply lexistsL; intro Horg.

        apply landL2.

        apply sa_unit_eq in Hx. rewrite <- Hx. reflexivity. assumption.

      - destruct (sa_unit_ex x) as [u [H1 H2]].

        apply lexistsR with x; apply lexistsR with u; apply lexistsR with H2.

        apply landR; [reflexivity| apply lexistsR; [assumption | apply ltrueR]].

  Qed.



  Global Instance pureop_bi_sepalg : PureOp _ := {

    pure := fun (P : ILPreFrm rel B) => forall h h', (ILPreFrm_pred P) h |-- (ILPreFrm_pred P) h'

  }.



  Global Instance pure_bi_sepalg : Pure pureop_bi_sepalg.

  Proof.

    constructor.

    { unfold pure; simpl; constructor.

      { unfold sepSP; simpl; intros.

        destruct (sa_unit_ex t).

        apply lexistsR with x.

        apply lexistsR with t.

        destruct H0.

        apply sa_mulC in H1.

        eapply lexistsR; eauto.

        rewrite H. reflexivity. }

      constructor.

      { unfold sepSP; simpl; intros.

        repeat (eapply lexistsL; intros).

        rewrite H. rewrite H0. reflexivity. }

      constructor.

      { split; intros; unfold sepSP; simpl; intros.

        { repeat (eapply lexistsL; intros).

          apply landR. do 2 apply landL1. auto.

          eapply lexistsR.

          eapply lexistsR.

          eapply lexistsR. eassumption.

          eapply landR. apply landL1. apply landL2. reflexivity.

          apply landL2. reflexivity. }

        { rewrite landC.

          rewrite landexistsDL1.

          repeat (eapply lexistsL; intros).

          rewrite landexistsDL1.

          repeat (eapply lexistsL; intros).

          rewrite landexistsDL1.

          repeat (eapply lexistsL; intros).

          do 3 eapply lexistsR.

          eassumption.

          rewrite H.

          rewrite landC. rewrite landA. reflexivity. } }

      constructor.

      { unfold wandSP; simpl; intros.

        repeat (eapply lforallR; intros).

        destruct (sa_unit_ex x).

        destruct H0.

        eapply lforallL with x1.

        apply lforallL with x.

        eapply lforallL.

        rewrite x0. auto.

        apply limplAdj. apply limplL. apply H. apply landL1. reflexivity. }

      { unfold wandSP; simpl; intros.

        repeat (eapply lforallR; intros).

        eapply lforallL. eapply lforallL. reflexivity.

        apply limplAdj. apply limplL; auto. apply landL1. auto. } }

    { red. red. unfold pure; simpl.

      intros. setoid_rewrite H.

      reflexivity. }

  Qed.



End BISepAlg.



Section BISepAlg2.

  Context {A} `{sa : SepAlg A}.

  Context {B} `{BIL: BILogic B}.

  Context {HPre : PreOrder rel}.

  Context {HIL : ILogic B}.



  Open Scope sa_scope.



  Local Transparent ILPre_Ops.



  Global Program Instance SABIOps2: BILogicOps (ILPreFrm rel B) :=

  { empSP := mkILPreFrm (fun x => Exists a : (sa_unit x), empSP) _

  ; sepSP P Q :=  mkILPreFrm (fun x => Exists x1, Exists x2, Exists H : sa_mul x1 x2 x,

                                                (ILPreFrm_pred P) x1 ** (ILPreFrm_pred Q) x2) _

  ; wandSP P Q := mkILPreFrm (fun x => Forall x1, Forall x2, Forall H : sa_mul x x1 x2,

                                                 (ILPreFrm_pred P) x1 -* (ILPreFrm_pred Q) x2) _

  }.

  Next Obligation.

  	apply lexistsL; intro H1. eapply lexistsR. rewrite <- H. assumption. reflexivity.

  Qed.

  Next Obligation.

  	apply lexistsL; intro a; apply lexistsL; intro b; apply lexistsL; intro Hab.

  	apply lexistsR with a; apply lexistsR with b. eapply lexistsR. eapply sa_mul_monR; eassumption. reflexivity.

  Qed.

  Next Obligation.

	apply lforallR; intro a; apply lforallR; intro b; apply lforallR; intro Hab.

	apply lforallL with a; apply lforallL with b. apply lforallL. eapply sa_mul_mon; [symmetry|]; eassumption.

	reflexivity.

  Qed.



  Global Instance SABILogic2 : BILogic (ILPreFrm rel B).

    split.

    + apply _.

    + intros P Q x; simpl.

      apply lexistsL; intro x1; apply lexistsL; intro x2; apply lexistsL; intro H'; apply sa_mulC in H'.

      apply lexistsR with x2; apply lexistsR with x1; apply lexistsR with H'. apply sepSPC.

    + intros P Q R x; simpl.

      apply lexistsL; intro x1; apply lexistsL; intro x2; apply lexistsL; intro Hx.

      rewrite sepSPC. do 3 setoid_rewrite <- bilexistssc.

      apply lexistsL; intro x3; apply lexistsL; intro x4; apply lexistsL; intro Hx1.

      destruct (sa_mulA Hx1 Hx) as [x5 [Hx2 Hx5]].

      apply lexistsR with x3; apply lexistsR with x5; apply lexistsR with Hx5; apply lexistsR with x4;

      apply lexistsR with x2; apply lexistsR with Hx2.

      rewrite sepSPC, sepSPA. reflexivity.

    + intros P Q R; split; intros H x; simpl.

      - apply lforallR; intro x1; apply lforallR; intro x2; apply lforallR; intro Hx1.

        apply wandSepSPAdj.

        specialize (H x2); simpl in H.

        rewrite <- H.

        apply lexistsR with x; apply lexistsR with x1; apply lexistsR with Hx1. reflexivity.

      - apply lexistsL; intro x1. apply lexistsL; intro x2; apply lexistsL; intro Hx.

        specialize (H x1); simpl in H.

        setoid_rewrite H.

        rewrite sepSPC. do 3 setoid_rewrite bilforallscR.

        apply lforallL with x2; apply lforallL with x; apply lforallL with Hx.

        rewrite sepSPC.

        apply wandSepSPAdj. reflexivity.

    + intros P Q R H x; simpl.

      apply lexistsL; intro x1; apply lexistsL; intro x2; apply lexistsL; intro Hx.

      apply lexistsR with x1; apply lexistsR with x2; apply lexistsR with Hx.

      rewrite H. reflexivity.

    + intros P; split; intros x; simpl.

      - setoid_rewrite <- bilexistssc.

        apply lexistsL; intro x1; apply lexistsL; intro x2; apply lexistsL; intro Hx; apply lexistsL; intro H2.

        rewrite empSPR.

        apply sa_unit_eq in Hx. rewrite <- Hx. reflexivity. assumption.

      - destruct (sa_unit_ex x) as [u [H1 H2]].

        setoid_rewrite <- bilexistssc.

        apply lexistsR with x; apply lexistsR with u; apply lexistsR with H2; apply lexistsR with H1.

        rewrite empSPR. reflexivity.

  Qed.



  Context {POB : @PureOp B}.

  Context {PureB : Pure POB}.



  Global Instance pureop_bi_sepalg2 : PureOp (ILPreFrm rel B) := {

    pure := fun (P : ILPreFrm rel B) =>

        (forall h, pure ((ILPreFrm_pred P) h)) /\

    	(forall h h', (ILPreFrm_pred P) h |-- (ILPreFrm_pred P) h')

  }.



  Global Instance pure_bi_sepalg2 : Pure pureop_bi_sepalg2.

  Proof.

    constructor.

    { unfold pure; simpl; intros; constructor.

      { unfold sepSP; simpl; intros.

        destruct H as [H H1].

        pose proof (@pure_axiom B _ _ _ PureB _ (H t)) as H2.

        destruct H2 as [H2 _].

        destruct (sa_unit_ex t) as [x [Hx Htx]].

        apply lexistsR with x.

        apply lexistsR with t.

        apply sa_mulC in Htx.

        eapply lexistsR with Htx.

        rewrite H2, (H1 t x); reflexivity. }

      constructor.

      { unfold sepSP; simpl; intros.

        repeat (eapply lexistsL; intros).

        destruct H as [H1 H2]; destruct H0 as [H3 H4].

        rewrite (H2 x t), (H4 x0 t).

        specialize (H1 t). specialize (H3 t).

        pose proof (@pure_axiom B _ _ _ PureB _ H1).

        destruct H as [_ [H _]].

        rewrite H. reflexivity. assumption. }

      constructor.

      { split; intros; unfold sepSP; simpl; intros.

        { repeat (eapply lexistsL; intros).

          destruct H as [H H1].

          pose proof (@pure_axiom B _ _ _ PureB) _ (H x) as H2.

          destruct H2 as [_ [_ [H2 _]]].

          rewrite H2.

          apply landR; [apply landL1; auto | apply landL2].

          do 3 eapply lexistsR; [eassumption|reflexivity]. }

        { rewrite landC.

          rewrite landexistsDL1.

          repeat (eapply lexistsL; intros).

          rewrite landexistsDL1.

          repeat (eapply lexistsL; intros).

          rewrite landexistsDL1.

          repeat (eapply lexistsL; intros).

          do 3 eapply lexistsR.

          eassumption. destruct H as [H H1].

          rewrite (H1 t x).

          pose proof (@pure_axiom B _ _ _ PureB) _ (H x) as H2.

          destruct H2 as [_ [_ [H2 _]]].

          destruct (H2 (Q x) (R x0)) as [_ H3].

          rewrite landC. assumption.

	   } }

      constructor.

      { unfold wandSP; simpl; intros.

        repeat (eapply lforallR; intros).

        destruct (sa_unit_ex x).

        destruct H0.

        eapply lforallL with x1.

        apply lforallL with x.

        eapply lforallL.

        rewrite x0. auto.

        destruct H as [H H2].

        pose proof (@pure_axiom B _ _ _ PureB) _ (H x1) as H3.

        destruct H3 as [_ [_ [_ [H3 _]]]].

        rewrite H3.

        apply limplAdj. apply limplL. apply H2. apply landL1. reflexivity. }

      { unfold wandSP; simpl; intros.

        repeat (eapply lforallR; intros).

        eapply lforallL. eapply lforallL. reflexivity.

        destruct H as [H H2].

        pose proof (@pure_axiom B _ _ _ PureB) _ (H x) as H3.

        destruct H3 as [_ [_ [_ [_ H3]]]].

        destruct H0 as [H4 H5].

        rewrite <- H3; [|auto].

        apply limplAdj. apply limplL; auto. apply landL1; auto. } }

    { red. red. unfold pure; simpl; intros.

      destruct PureB. repeat setoid_rewrite H; reflexivity. }

  Qed.



End BISepAlg2.



Section BILPre.

  Context T (ord: relation T) {HPre: PreOrder ord}.

  Context {A : Type} `{HBI: BILogic A}.

  Context {HIL : ILogic A}.



  Program Instance BILPre_Ops : BILogicOps (ILPreFrm ord A) := {|

    empSP      := mkILPreFrm (fun t => empSP) _;

    sepSP  P Q := mkILPreFrm (fun t => (ILPreFrm_pred P) t ** (ILPreFrm_pred Q) t) _;

    wandSP P Q := mkILPreFrm (fun t => Forall t', Forall H : ord t t', (ILPreFrm_pred P) t' -* (ILPreFrm_pred Q) t') _

  |}.

  Next Obligation.

    intros; rewrite H; reflexivity.

  Qed.

  Next Obligation.

    intros.

    apply lforallR; intro x; apply lforallR; intro Hx. rewrite <- H in Hx.

    apply lforallL with x; apply lforallL with Hx; reflexivity.

  Qed.



  Local Existing Instance ILPre_Ops.

  Local Existing Instance ILPre_ILogic.



  Local Transparent ILPre_Ops.



  Instance BILPreLogic : BILogic (ILPreFrm ord A).

  Proof.

    split.

    + apply _.

    + intros P Q x; simpl; apply sepSPC.

    + intros P Q R x; simpl; apply sepSPA.

    + intros P Q R; split; intros H t; simpl.

      * apply lforallR; intro t'; apply lforallR; intro H1.

        transitivity ((ILPreFrm_pred P) t'); [apply ILPreFrm_closed; assumption|].

        apply wandSepSPAdj; apply H.

      *  apply wandSepSPAdj; specialize (H t); unfold wandSP in H; simpl in H.

         rewrite H. apply lforallL with t; apply lforallL; reflexivity.

    + intros P Q R H x; simpl; apply bilsep; apply H.

    + intros P; split; intros x; simpl; apply empSPR.

  Qed.



  Context {POA : @PureOp A} {PA : Pure POA}.



  Instance PureBILPreOp : @PureOp (ILPreFrm ord A) := {

    pure := fun a => forall t, pure ((ILPreFrm_pred a) t)

  }.



  Instance PureBILPre : Pure (PureBILPreOp).

  Proof.

    constructor.

    { repeat split; intros; intro t; simpl.

      * eapply pureandsc; eauto.

      * eapply purescand; eauto.

      * eapply pureandscD; eauto.

      * eapply pureandscD; eauto.

      * apply lforallR; intro t'; apply lforallR; intro Ht.

        apply lforallL with t'; apply lforallL with Ht.

        eapply puresiimpl; eauto.

      * apply lforallR; intro t'; apply lforallR; intro Ht.

        apply lforallL with t'; apply lforallL with Ht.

        eapply pureimplsi; eauto. }

    { do 2 red. unfold pure; simpl. intros.

      split.

      { intros. eapply pure_proper. 2: eapply H0. symmetry.

        instantiate (1 := t).

        red in H. red. unfold lentails in H. simpl in H.

        intuition. }

      { intros. eapply pure_proper. 2: eapply H0. symmetry.

        instantiate (1 := t).

        red in H. red. unfold lentails in H. simpl in H.

        intuition. } }

  Qed.



  Instance pureBILPre (a : ILPreFrm ord A) (H : forall t, pure ((ILPreFrm_pred a) t)) : pure a.

  Proof.

    simpl; apply H.

  Qed.



End BILPre.



Section BILogic_Fun.

  Context (T: Type).

  Context {A : Type} `{BIL: BILogic A}.

  Context {HIL : ILogic A}.



  Local Transparent ILFun_Ops.



  Program Definition BILFun_Ops : BILogicOps ((fun x y => x -> y) T A) := {|

    empSP         := fun t => empSP;

    sepSP     P Q := fun t => P t ** Q t;

    wandSP    P Q := fun t => P t -* Q t

  |}.



  Local Existing Instance ILFun_Ops.

  Local Existing Instance ILFun_ILogic.

  Local Existing Instance BILFun_Ops.



  Program Definition BILFunLogic : @BILogic ((fun x y => x -> y) T A) (@ILFun_Ops T A _) BILFun_Ops.

  Proof.

    split.

    + apply _.

    + intros P Q x; simpl; apply sepSPC1.

    + intros P Q R x; simpl; apply sepSPA.

    + intros P Q R; split; intros H x; simpl;

      apply wandSepSPAdj; apply H.

    + intros P Q R H x; simpl; apply bilsep; apply H.

    + intros P; split; intros x; simpl; apply empSPR.

  Qed.



  Context {POA : @PureOp A} {PA : Pure POA}.



  Instance PureBILFunOp : @PureOp ((fun x y => x -> y) T A) := {

    pure := fun a => forall t, pure (a t)

  }.



  Instance PureBILFun : Pure (PureBILFunOp).

  Proof.

    constructor.

    { intros. repeat split; intros; intro t; simpl.

      * eapply pureandsc; eauto.

      * eapply purescand; eauto.

      * eapply pureandscD; eauto.

      * eapply pureandscD; eauto.

      * eapply puresiimpl; eauto.

      * eapply pureimplsi; eauto. }

    { do 2 red; simpl; intros.

      red in H. simpl in H.

      split.

      { intros. eapply pure_proper.

        2: eapply H0. split. intuition. intuition. }

      { intros. eapply pure_proper.

        2: eapply H0. split. intuition. intuition. } }

  Qed.



  Instance pureBILFun (a : (fun x y => x -> y) T A) (H : forall t, pure (a t)) : @pure _ PureBILFunOp a.

  Proof.

    simpl; apply H.

  Qed.



End BILogic_Fun.



Global Opaque BILPre_Ops.

Global Opaque BILFun_Ops.

Global Opaque SABIOps.

Global Opaque SABIOps2.

