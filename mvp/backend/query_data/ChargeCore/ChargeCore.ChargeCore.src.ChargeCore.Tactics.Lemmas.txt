
Require Export ChargeCore.Logics.ILogic.
(* ChargeCore.Logics.ILogic:
Require Import Setoid Morphisms RelationClasses Program.Basics Omega.

Set Implicit Arguments.
Unset Strict Implicit.
Set Maximal Implicit Insertion.

Global Instance ge_Pre: PreOrder ge.

Class ILogicOps (A : Type) : Type := {
  lentails: A -> A -> Prop;
  ltrue: A;
  lfalse: A;
  limpl: A -> A -> A;
  land: A -> A -> A;
  lor: A -> A -> A;
  lforall: forall {T : Type}, (T -> A) -> A;
  lexists: forall {T : Type}, (T -> A) -> A
}.

Infix "|--"  := lentails (at level 80, no associativity).
Infix "//\\"   := land (at level 75, right associativity).
Infix "\\//"   := lor (at level 76, right associativity).
Infix "-->>"   := limpl (at level 77, right associativity).
Notation "'Forall' x : T , p" :=
  (lforall (fun x : T => p)) (at level 78, x ident, right associativity).
Notation "'Forall' x , p" :=
  (lforall (fun x => p)) (at level 78, x ident, right associativity, only parsing).
Notation "'Exists' x : T , p" :=
  (lexists (fun x : T => p)) (at level 78, x ident, right associativity).
Notation "'Exists' x , p" :=
  (lexists (fun x => p)) (at level 78, x ident, right associativity, only parsing).

Section ILogicEquiv.
  Context {A : Type} `{IL: ILogicOps A}.

  Definition lequiv P Q := P |-- Q /\ Q |-- P.
End ILogicEquiv.

Infix "-|-"  := lequiv (at level 85, no associativity).

Class ILogic {A : Type} {ILOps: ILogicOps A} : Type := {
  lentailsPre:> PreOrder lentails;
  ltrueR: forall (C : A), C |-- ltrue;
  lfalseL: forall (C : A), lfalse |-- C;
  lforallL: forall (T : Type) x (P: T -> A) C, P x |-- C -> lforall P |-- C;
  lforallR: forall (T : Type) (P: T -> A) C, (forall x, C |-- P x) -> C |-- lforall P;
  lexistsL: forall (T : Type) (P: T -> A) C, (forall x, P x |-- C) -> lexists P |-- C;
  lexistsR: forall (T : Type) (x : T) (P: T -> A) C, C |-- P x -> C |-- lexists P;
  landL1: forall (P Q C : A), P |-- C  ->  P //\\ Q |-- C;
  landL2: forall (P Q C : A), Q |-- C  ->  P //\\ Q |-- C;
  lorR1:  forall (P Q C : A), C |-- P  ->  C |-- P \\// Q;
  lorR2:  forall (P Q C : A), C |-- Q  ->  C |-- P \\// Q;
  landR:  forall (P Q C : A), C |-- P  ->  C |-- Q  ->  C |-- P //\\ Q;
  lorL:   forall (P Q C : A), P |-- C  ->  Q |-- C  ->  P \\// Q |-- C;
  landAdj: forall (P Q C : A), C |-- (P -->> Q) -> C //\\ P |-- Q;
  limplAdj: forall (P Q C : A), C //\\ P |-- Q -> C |-- (P -->> Q)
}.

Arguments ILogic _ {ILOps}.
Arguments lforallL {A ILOps ILogic} [T] x P C _.
Arguments lexistsR {A ILOps ILogic} [T] x P C _.

Notation "|--  P" := (ltrue |-- P) (at level 85, no associativity).
Hint Extern 0 (?x |-- ?x) => reflexivity.
Hint Extern 0 (_ |-- ltrue) => apply ltrueR.
Hint Extern 0 (lfalse |-- _) => apply lfalseL.
Hint Extern 0 (?P |-- ?Q) => (is_evar P; reflexivity) || (is_evar Q; reflexivity).

Section ILogicEquiv2.
  Context {A : Type} `{IL: ILogic A}.

  Global Instance lequivEquivalence : Equivalence lequiv.

End ILogicEquiv2.

Section ILogicEquivOps.
  Context {A : Type} `{IL: ILogic A}.

  Lemma land_is_forall P Q :
    P //\\ Q -|- Forall b : bool, if b then P else Q.

  Lemma lor_is_exists P Q:
    P \\// Q -|- Exists b : bool, if b then P else Q.

  Lemma ltrue_is_forall:
    ltrue -|- Forall x: Empty_set, Empty_set_rect _ x.

  Lemma lfalse_is_exists:
    lfalse -|- Exists x: Empty_set, Empty_set_rect _ x.

End ILogicEquivOps.

Section ILogicMorphisms.
  Context {A T : Type} `{IL: ILogic A}.

  Global Instance lequiv_lentails : subrelation lequiv lentails.
  Global Instance lequiv_flip_lentails: subrelation lequiv (flip lentails).

  Global Instance lforall_lentails_m:
    Proper (pointwise_relation T lentails ++> lentails) lforall.

  Global Instance lforall_lequiv_m:
    Proper (pointwise_relation T lequiv ++> lequiv) lforall.

  Global Instance lexists_lentails_m:
    Proper (pointwise_relation T lentails ++> lentails) lexists.

  Global Instance lexists_lequiv_m:
    Proper (pointwise_relation T lequiv ++> lequiv) lexists.

  Global Instance : Proper (lequiv ==> lequiv ==> iff) lequiv.

  Global Instance lequiv_lentails_m : Proper (lequiv ==> lequiv ==> iff) lentails.

  Global Instance lentails_lentails_m: Proper (lentails --> lentails ++> impl) lentails.

  Global Instance land_lentails_m:
    Proper (lentails ++> lentails ++> lentails) land.

  Global Instance land_lequiv_m:
    Proper (lequiv ==> lequiv ==> lequiv) land.

  Global Instance lor_lentails_m:
    Proper (lentails ++> lentails ++> lentails) lor.

  Global Instance lor_lequiv_m:
    Proper (lequiv ==> lequiv ==> lequiv) lor.

  Global Instance limpl_lentails_m:
    Proper (lentails --> lentails ++> lentails) limpl.

  Global Instance limpl_lequiv_m:
    Proper (lequiv ==> lequiv ==> lequiv) limpl.

End ILogicMorphisms.

Hint Extern 0 (?x -|- ?x) => reflexivity.
Hint Extern 0 (?P -|- ?Q) => (is_evar P; reflexivity) || (is_evar Q; reflexivity).

Lemma lforwardL {A} `{IL: ILogic A} {Q R}:
    Q |-- R -> forall P G,
    P |-- Q ->
    (P |-- R -> G) ->
    G.

Tactic Notation "lforwardL" hyp(H) :=
  eapply (lforwardL H); clear H; [|intros H].

Section ILogicFacts.
  Context {A T : Type} `{IL: ILogic A}.

  Ltac landR :=
    repeat match goal with
    | |- _ |-- _ //\\ _ => apply landR
    end.

  Ltac landL :=
    repeat match goal with
    | |- ?L1 //\\ ?L2 |-- ?R =>
        match L1 with
        | context [R] => apply landL1
        | _ =>
          match L2 with
          | context [R] => apply landL2
          end
        end
    end.
    
  Lemma lentails_refl P : P |-- P.

  Lemma landC P Q: P //\\ Q -|- Q //\\ P.

  Lemma landA P Q R: (P //\\ Q) //\\ R -|- P //\\ (Q //\\ R).

  Lemma lorC P Q : P \\// Q -|- Q \\// P.

  Lemma lorA P Q R : (P \\// Q) \\// R -|- P \\// (Q \\// R).

  Lemma limplValid P Q:
    |-- P -->> Q <->
    P |-- Q.

  Lemma limplL P Q CL CR (HP: CL |-- P) (HR: Q //\\ CL |-- CR) :
    (P -->> Q) //\\ CL |-- CR.

  Lemma limplAdj2 P Q R : P -->> Q -->> R -|- P //\\ Q -->> R.

  Lemma landexistsDL1 (f : T -> A) (P : A) :
    lexists f //\\ P |-- Exists a, (f a //\\ P).

  Lemma landexistsDL2 (f : T -> A) (P : A) :
    P //\\ lexists f |-- Exists a, (P //\\ f a).
  
  Lemma landexistsDR1 (f : T -> A) (P : A) :
     Exists a, (f a //\\ P) |-- lexists f //\\ P.

  Lemma landexistsDR2 (f : T -> A) (P : A) :
     Exists a, (P //\\ f a) |-- P //\\ lexists f.
  
  Lemma landexistsD1 (f : T -> A) (P : A) :
    (Exists a, f a) //\\ P -|- Exists a, (f a //\\ P).

  Lemma lorexistsDL (f : T -> A) (P : A) {H : Inhabited T} :
    (Exists a, f a) \\// P |-- Exists a, (f a \\// P).

  Lemma lorexistsDR (f : T -> A) (P : A) :
     Exists a, (f a \\// P) |-- (Exists a, f a) \\// P.

  Lemma lorexistsD (f : T -> A) (P : A) {H : Inhabited T} :
    (Exists a, f a) \\// P -|- Exists a, (f a \\// P).

  Lemma landforallDL (f : T -> A) (P : A) :
    (Forall a, f a) //\\ P |-- Forall a, (f a //\\ P).

  Lemma landforallDR {H: Inhabited T} (f : T -> A) (P : A) :
    Forall a, (f a //\\ P) |-- (Forall a, f a) //\\ P.

  Lemma landforallD (f : T -> A) (P : A) {H : Inhabited T} :
    (Forall a, f a) //\\ P -|- Forall a, (f a //\\ P).

  Lemma lorforallDL (f : T -> A) (P : A) :
    (Forall a, f a) \\// P |-- Forall a, (f a \\// P).

  Lemma limplTrue P : ltrue -->> P -|- P.

  Lemma limplexistsE (P : T -> A) (Q : A) :
    (Exists x, P x) -->> Q -|- Forall x, (P x -->> Q).

  Lemma limplforallER (P : T -> A) (Q : A) :
    Exists x, (P x -->> Q) |-- (Forall x, P x) -->> Q.

  Lemma lforallR2 (P : A) (Q : T -> A) (H : P |-- lforall Q) :
  	forall x, P |-- Q x.

  Lemma lexistsL2 (P : T -> A) (Q : A) (H : lexists P |-- Q) :
  	forall x, P x |-- Q.

  Lemma landtrueL : forall a, ltrue //\\ a -|- a.

  Lemma landtrueR : forall a, a //\\ ltrue -|- a.

  Lemma curry : forall a b c, (a //\\ b) -->> c -|- a -->> (b -->> c).

End ILogicFacts.

Global Instance ILogicOps_Prop : ILogicOps Prop := {|
  lentails P Q := (P : Prop) -> Q;
  ltrue        := True;
  lfalse       := False;
  limpl    P Q := P -> Q;
  land     P Q := P /\ Q;
  lor      P Q := P \/ Q;
  lforall  T F := forall x:T, F x;
  lexists  T F := exists x:T, F x
 |}.

Global Instance ILogic_Prop : ILogic Prop. *)

Section logic.
  Context {L : Type}.
  Context {ILO : ILogicOps L}.
  Context {IL : ILogic L}.

  Theorem lcut : forall P Q R : L,
      P |-- R ->
      P |-- R -->> Q ->
      P |-- Q.
  Proof.
    intros.
    eapply landAdj in H0.
    etransitivity; [ | eassumption ].
    eapply landR. reflexivity. assumption.
  Qed.

  Theorem limplAdj_true : forall P Q,
      P |-- Q ->
      ltrue |-- P -->> Q.
  Proof.
    intros. apply limplAdj. apply landL2. assumption.
  Qed.

  Theorem landAdj_true : forall P Q,
      ltrue |-- P -->> Q ->
      P |-- Q.
  Proof.
    intros. apply landAdj in H. rewrite <- H.
    apply landR. apply ltrueR. reflexivity.
  Qed.

  Lemma lapply : forall P Q R,
      P |-- Q -->> R ->
      P |-- Q ->
      P |-- R.
  Proof. intros; eapply lcut; eauto. Qed.

  Lemma lapply2 : forall P Q R S,
      P |-- Q -->> R -->> S ->
      P |-- Q ->
      P |-- R ->
      P |-- S.
  Proof. intros; eapply lcut; eauto using lapply. Qed.

  Lemma lapply3 : forall P Q R S T,
      P |-- Q -->> R -->> S -->> T ->
      P |-- Q ->
      P |-- R ->
      P |-- S ->
      P |-- T.
  Proof. intros; eapply lcut; eauto using lapply2. Qed.

  Lemma lapply4 : forall P Q R S T U,
      P |-- Q -->> R -->> S -->> T -->> U ->
      P |-- Q ->
      P |-- R ->
      P |-- S ->
      P |-- T ->
      P |-- U.
  Proof. intros; eapply lcut; eauto using lapply3. Qed.

  Lemma lapply5 : forall P Q R S T U V,
      P |-- Q -->> R -->> S -->> T -->> U -->> V ->
      P |-- Q ->
      P |-- R ->
      P |-- S ->
      P |-- T ->
      P |-- U ->
      P |-- V.
  Proof. intros; eapply lcut; eauto using lapply4. Qed.

  Lemma land_lor_distr_L : forall P Q R,
      P //\\ (Q \\// R) -|- (P //\\ Q) \\// (P //\\ R).
  Proof.
    intros. split.
    { rewrite landC. apply landAdj.
      apply lorL; apply limplAdj.
      { apply lorR1. rewrite landC. reflexivity. }
      { apply lorR2. rewrite landC. reflexivity. } }
    { apply lorL; apply landR; try solve [ apply landL1 ; reflexivity ].
      { apply lorR1. apply landL2. reflexivity. }
      { apply lorR2. apply landL2. reflexivity. } }
  Qed.

  Lemma land_lor_distr_R : forall P Q R,
      (Q \\// R) //\\ P -|- (P //\\ Q) \\// (P //\\ R).
  Proof.
    intros. split.
    { apply landAdj.
      apply lorL; apply limplAdj.
      { apply lorR1. rewrite landC. reflexivity. }
      { apply lorR2. rewrite landC. reflexivity. } }
    { apply lorL; apply landR; try solve [ apply landL1 ; reflexivity ].
      { apply lorR1. apply landL2. reflexivity. }
      { apply lorR2. apply landL2. reflexivity. } }
  Qed.

End logic.

Local Ltac charge_split := apply landR.

Local Ltac charge_search_prems found :=
  match goal with
  | |- ?X |-- ?Y =>
    solve [ found
          | apply landL1 ; charge_search_prems found
          | apply landL2 ; charge_search_prems found ]
  end.

Local Ltac charge_assumption :=
  charge_search_prems reflexivity.

Local Ltac charge_intro :=
  first [ apply lforallR; intro
        | apply limplAdj_true
        | apply limplAdj ].

Local Ltac charge_intros :=
  repeat match goal with
         | |- _ |-- _ -->> _ =>
           charge_intro
         | |- _ |-- @lforall _ _ _ _ =>
           charge_intro
         end.

Local Ltac charge_trivial := apply ltrueR.

Local Ltac charge_use :=
  first [ eapply lapply; [ charge_assumption | ]
        | eapply lapply2; [ charge_assumption | | ]
        | eapply lapply3; [ charge_assumption | | | ]
        | eapply lapply4; [ charge_assumption | | | | ]
        | eapply lapply5; [ charge_assumption | | | | | ] ].

Local Ltac ends_with H ABC C :=
  let rec go k ABC :=
      match ABC with
      | C => k
      | _ -->> ?BC =>
        let k' := (k; first [ apply landAdj_true in H | apply landAdj in H ]) in
        go k' BC
      end
  in
  go ltac:(idtac) ABC.

Local Ltac charge_apply H :=
  match type of H with
  | _ |-- ?X =>
    match goal with
    | |- _ |-- ?Y =>
      ends_with H X Y ; etransitivity ; [ | eapply H ]
    end
  end.

Local Ltac charge_tauto :=
  repeat charge_split ;
  solve [ charge_assumption
        | charge_trivial
        | charge_intro; repeat charge_intro; charge_tauto
        | charge_split; solve [ charge_tauto ]
        | match goal with
          | H : _ |-- _ |- _ =>
            charge_apply H ; charge_tauto
          end
        | charge_use ; charge_tauto ].

Section logic2.
  Context {L : Type}.
  Context {ILO : ILogicOps L}.
  Context {IL : ILogic L}.

  Definition liff (A B : L) : L :=
    (A -->> B) //\\ (B -->> A).

  Local Notation "x <<-->> y" := (liff x y) (at level 78).

  Lemma ltrue_liff : forall A B,
      |-- A <<-->> B <-> A -|- B.
  Proof.
    unfold liff. split.
    { intros. split.
      { apply landAdj_true.
        rewrite H. apply landL1. reflexivity. }
      { apply landAdj_true.
        rewrite H. apply landL2. reflexivity. } }
    { intro. rewrite H.
      apply landR; apply limplAdj_true; reflexivity. }
  Qed.

  Lemma land_cancel : forall A B C,
      A |-- B <<-->> C ->
      A //\\ B -|- A //\\ C.
  Proof.
    intros. split.
    { charge_split; try charge_tauto.
      rewrite H. charge_tauto. }
    { charge_split; try charge_tauto.
      rewrite H. charge_tauto. }
  Qed.

  Lemma uncurry : forall P Q R,
      (P //\\ Q -->> R) -|- (P -->> Q -->> R).
  Proof.
    intros. split.
    { charge_tauto. }
    { charge_intro.
      eapply lapply. eapply lapply. charge_assumption.
      charge_tauto. charge_tauto. }
  Qed.

  Lemma forget_prem : forall P Q,
      |-- P -> Q |-- P.
  Proof. intros; charge_tauto. Qed.

  Lemma lrevert : forall P Q,
      |-- P -->> Q ->
      P |-- Q.
  Proof. intros; charge_tauto. Qed.

  Lemma charge_and_use : forall P Q C,
      C |-- P ->
      C //\\ P |-- Q ->
      C |-- P //\\ Q.
  Proof.
    intros. charge_tauto.
  Qed.

  Lemma land_limpl_specialize_ap : forall P Q L R G,
      L //\\ R |-- P ->
      L //\\ Q //\\ R |-- G ->
      L //\\ (P -->> Q) //\\ R |-- G.
  Proof.
    intros. charge_tauto.
  Qed.

  Lemma land_limpl_specializeR_ap : forall P Q R G,
      R |-- P ->
      Q //\\ R |-- G ->
      (P -->> Q) //\\ R |-- G.
  Proof.
    intros; charge_tauto.
  Qed.

  Lemma land_limpl_specializeL_ap : forall P Q R G,
      R |-- P ->
      Q //\\ R |-- G ->
      R //\\ (P -->> Q) |-- G.
  Proof.
    intros; charge_tauto.
  Qed.

  Lemma landA_ap : forall P Q R G,
      (P //\\ Q) //\\ R |-- G ->
      P //\\ Q //\\ R |-- G.
  Proof.
    intros. charge_tauto.
  Qed.

  Lemma land_lexists_ap : forall T (P : T -> L) Q R S,
      (forall x, S //\\ P x //\\ Q |-- R) ->
      S //\\ (lexists P) //\\ Q |-- R.
  Proof.
    intros. rewrite landC. rewrite landA.
    eapply landAdj.
    apply lexistsL.
    intro. specialize (H x).
    charge_tauto.
  Qed.

  Lemma land_lexistsL_ap : forall T (P : T -> L) R S,
      (forall x, S //\\ P x |-- R) ->
      S //\\ (lexists P) |-- R.
  Proof.
    intros. rewrite landC.
    eapply landAdj.
    apply lexistsL.
    intro. specialize (H x).
    charge_tauto.
  Qed.

  Lemma land_lexistsR_ap : forall T (P : T -> L) R S,
      (forall x, P x //\\ S |-- R) ->
      lexists P //\\ S |-- R.
  Proof.
    intros.
    eapply landAdj.
    apply lexistsL.
    intro. specialize (H x).
    charge_tauto.
  Qed.

End logic2.

Notation "x <<-->> y" := (liff x y) (at level 78).
