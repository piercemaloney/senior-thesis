
Require Import List.
Require Import ML_Int.
(* ML_Int:
Axiom Int : Set.
Axiom Less : Int -> Int -> Prop.
Axiom Equal : Int -> Int -> Prop.
Axiom int_succ : forall x : Int, {y : Int | Less x y}.
Axiom int_null : Int.

Axiom equal_dec : forall x y : Int, {Equal x y} + {~ Equal x y}.
Axiom less_dec : forall x y : Int, {Less x y} + {~ Less x y}.

Axiom
  notequal_notless_greater :
    forall x y : Int, ~ Equal x y -> ~ Less x y -> Less y x.

Axiom less_trans : forall x y z : Int, Less x y -> Less y z -> Less x z.
Axiom equal_less_less : forall x y z : Int, Equal x y -> Less y z -> Less x z.
Axiom less_equal_less : forall x y z : Int, Less x y -> Equal y z -> Less x z.
Axiom equal_sym : forall x y : Int, Equal x y -> Equal y x.
Axiom equal_trans : forall x y z : Int, Equal x y -> Equal y z -> Equal x z.
Axiom equal_refl : forall x : Int, Equal x x.
Axiom equal_eq : forall x y : Int, Equal x y -> x = y.

Axiom less_irrefl : forall x : Int, Less x x -> False.

Lemma equal_dec_refl :
 forall (i : Int) (A : Set) (a b : A),
 match equal_dec i i with
 | left _ => a
 | right _ => b
 end = a.

Inductive max_int_spec (i0 i1 : Int) : Set :=
    Max_Int_Intro :
      forall j : Int,
      Less i0 j \/ Equal i0 j ->
      Less i1 j \/ Equal i1 j -> max_int_spec i0 i1.

Lemma max_int : forall i0 i1 : Int, max_int_spec i0 i1. *)
Require Import AvlTrees.
(* AvlTrees:
Require Import ML_Int.
Require Import My_Arith.
Require Import List.

Global Set Asymmetric Patterns.

Section avl_trees.

Variable B : Set.

Inductive bal : Set :=
  | Left_Balanced : bal
  | Balanced : bal
  | Right_Balanced : bal.

Inductive avl_tree : Set :=
  | Avl_Nil : avl_tree
  | Avl_Node : Int -> B -> avl_tree -> avl_tree -> bal -> avl_tree.

Inductive is_below : avl_tree -> Int -> Prop :=
  | Below_Nil : forall k0 : Int, is_below Avl_Nil k0
  | Below_Node :
      forall (k : Int) (d : B) (l r : avl_tree) (b : bal) (k0 : Int),
      Less k k0 ->
      is_below l k0 -> is_below r k0 -> is_below (Avl_Node k d l r b) k0.

Lemma inv_below_key :
 forall (k : Int) (d : B) (l r : avl_tree) (b : bal) (k0 : Int),
 is_below (Avl_Node k d l r b) k0 -> Less k k0.

Lemma inv_below_left :
 forall (k : Int) (d : B) (l r : avl_tree) (b : bal) (k0 : Int),
 is_below (Avl_Node k d l r b) k0 -> is_below l k0.

Lemma inv_below_right :
 forall (k : Int) (d : B) (l r : avl_tree) (b : bal) (k0 : Int),
 is_below (Avl_Node k d l r b) k0 -> is_below r k0.

Lemma below_trans :
 forall (t : avl_tree) (k0 k1 : Int),
 is_below t k0 -> Less k0 k1 -> is_below t k1.

Inductive is_above : avl_tree -> Int -> Prop :=
  | Above_Nil : forall k0 : Int, is_above Avl_Nil k0
  | Above_Node :
      forall (k : Int) (d : B) (l r : avl_tree) (b : bal) (k0 : Int),
      Less k0 k ->
      is_above l k0 -> is_above r k0 -> is_above (Avl_Node k d l r b) k0.

Lemma inv_above_key :
 forall (k : Int) (d : B) (l r : avl_tree) (b : bal) (k0 : Int),
 is_above (Avl_Node k d l r b) k0 -> Less k0 k.

Lemma inv_above_left :
 forall (k : Int) (d : B) (l r : avl_tree) (b : bal) (k0 : Int),
 is_above (Avl_Node k d l r b) k0 -> is_above l k0.

Lemma inv_above_right :
 forall (k : Int) (d : B) (l r : avl_tree) (b : bal) (k0 : Int),
 is_above (Avl_Node k d l r b) k0 -> is_above r k0.

Lemma above_trans :
 forall (t : avl_tree) (k0 k1 : Int),
 is_above t k0 -> Less k1 k0 -> is_above t k1.

Fixpoint height (t : avl_tree) : nat :=
  match t with
  | Avl_Nil => 0
  | Avl_Node _ _ l r _ => S (max (height l) (height r))
  end.

Lemma height_O_nil : forall t : avl_tree, height t = 0 -> t = Avl_Nil.

Inductive is_balanced (l r : avl_tree) : bal -> Prop :=
  | Is_Left_Balanced :
      height l = S (height r) -> is_balanced l r Left_Balanced
  | Is_Fully_Balanced : height l = height r -> is_balanced l r Balanced
  | Is_Right_Balanced :
      S (height l) = height r -> is_balanced l r Right_Balanced.

Lemma inv_left_balanced :
 forall l r : avl_tree,
 is_balanced l r Left_Balanced -> height l = S (height r).

Lemma inv_fully_balanced :
 forall l r : avl_tree, is_balanced l r Balanced -> height l = height r.

Lemma inv_right_balanced :
 forall l r : avl_tree,
 is_balanced l r Right_Balanced -> S (height l) = height r.

Inductive lookup (key : Int) : avl_tree -> B -> Prop :=
  | Lookup_Equal :
      forall (d : B) (l r : avl_tree) (b : bal),
      lookup key (Avl_Node key d l r b) d
  | Lookup_Left :
      forall (k : Int) (d : B) (l r : avl_tree) (b : bal) (data : B),
      lookup key l data -> lookup key (Avl_Node k d l r b) data
  | Lookup_Right :
      forall (k : Int) (d : B) (l r : avl_tree) (b : bal) (data : B),
      lookup key r data -> lookup key (Avl_Node k d l r b) data.

Lemma inv_lookup_nil :
 forall (key : Int) (data : B), lookup key Avl_Nil data -> False.

Lemma inv_lookup :
 forall (key k : Int) (d : B) (l r : avl_tree) (b : bal) (data : B),
 lookup key (Avl_Node k d l r b) data ->
 k = key /\ d = data \/ lookup key l data \/ lookup key r data.

Lemma lookup_below_less :
 forall (key : Int) (t : avl_tree) (data : B) (k0 : Int),
 lookup key t data -> is_below t k0 -> Less key k0.

Lemma lookup_above_greater :
 forall (key : Int) (t : avl_tree) (data : B) (k0 : Int),
 lookup key t data -> is_above t k0 -> Less k0 key.

Lemma lookup_less_below :
 forall (t : avl_tree) (k0 : Int),
 (forall (k : Int) (d : B), lookup k t d -> Less k k0) -> is_below t k0.

Lemma lookup_greater_above :
 forall (t : avl_tree) (k0 : Int),
 (forall (k : Int) (d : B), lookup k t d -> Less k0 k) -> is_above t k0.

Lemma lookup_above_lookup :
 forall (key k : Int) (d : B) (l r : avl_tree) (b : bal) (data : B),
 lookup key (Avl_Node k d l r b) data ->
 Less key k -> is_above r key -> lookup key l data.

Lemma lookup_below_lookup :
 forall (key k : Int) (d : B) (l r : avl_tree) (b : bal) (data : B),
 lookup key (Avl_Node k d l r b) data ->
 Less k key -> is_below l key -> lookup key r data.

Lemma lookup_below_false :
 forall (key : Int) (t : avl_tree) (data : B),
 lookup key t data -> is_below t key -> False.

Lemma lookup_above_false :
 forall (key : Int) (t : avl_tree) (data : B),
 lookup key t data -> is_above t key -> False.

Inductive is_below_avl : avl_tree -> Int -> Prop :=
  | Below_Avl_Nil : forall k0 : Int, is_below_avl Avl_Nil k0
  | Below_Avl_Node :
      forall (k : Int) (d : B) (l r : avl_tree) (b : bal) (k0 : Int),
      Less k k0 -> is_below_avl r k0 -> is_below_avl (Avl_Node k d l r b) k0.

Lemma inv_below_avl_key :
 forall (k : Int) (d : B) (l r : avl_tree) (b : bal) (k0 : Int),
 is_below_avl (Avl_Node k d l r b) k0 -> Less k k0.

Lemma inv_below_avl_right :
 forall (k : Int) (d : B) (l r : avl_tree) (b : bal) (k0 : Int),
 is_below_avl (Avl_Node k d l r b) k0 -> is_below_avl r k0.

Lemma below_avl_trans :
 forall (t : avl_tree) (k0 k1 : Int),
 is_below_avl t k0 -> Less k0 k1 -> is_below_avl t k1.

Lemma below_below_avl :
 forall (t : avl_tree) (key : Int), is_below t key -> is_below_avl t key.

Inductive is_above_avl : avl_tree -> Int -> Prop :=
  | Above_Avl_Nil : forall k0 : Int, is_above_avl Avl_Nil k0
  | Above_Avl_Node :
      forall (k : Int) (d : B) (l r : avl_tree) (b : bal) (k0 : Int),
      Less k0 k -> is_above_avl l k0 -> is_above_avl (Avl_Node k d l r b) k0.

Lemma inv_above_avl_key :
 forall (k : Int) (d : B) (l r : avl_tree) (b : bal) (k0 : Int),
 is_above_avl (Avl_Node k d l r b) k0 -> Less k0 k.

Lemma inv_above_avl_left :
 forall (k : Int) (d : B) (l r : avl_tree) (b : bal) (k0 : Int),
 is_above_avl (Avl_Node k d l r b) k0 -> is_above_avl l k0.

Lemma above_avl_trans :
 forall (t : avl_tree) (k0 k1 : Int),
 is_above_avl t k0 -> Less k1 k0 -> is_above_avl t k1.

Lemma above_above_avl :
 forall (t : avl_tree) (key : Int), is_above t key -> is_above_avl t key.

Fixpoint height_avl (t : avl_tree) : nat :=
  match t with
  | Avl_Nil => 0
  | Avl_Node _ _ l _ Left_Balanced => S (height_avl l)
  | Avl_Node _ _ l _ Balanced => S (height_avl l)
  | Avl_Node _ _ _ r Right_Balanced => S (height_avl r)
  end.

Lemma height_avl_O_nil : forall t : avl_tree, height_avl t = 0 -> t = Avl_Nil.

Inductive is_balanced_avl (l r : avl_tree) : bal -> Prop :=
  | Is_Left_Balanced_Avl :
      height_avl l = S (height_avl r) -> is_balanced_avl l r Left_Balanced
  | Is_Fully_Balanced_Avl :
      height_avl l = height_avl r -> is_balanced_avl l r Balanced
  | Is_Right_Balanced_Avl :
      S (height_avl l) = height_avl r -> is_balanced_avl l r Right_Balanced.

Lemma inv_left_balanced_avl :
 forall l r : avl_tree,
 is_balanced_avl l r Left_Balanced -> height_avl l = S (height_avl r).

Lemma inv_fully_balanced_avl :
 forall l r : avl_tree,
 is_balanced_avl l r Balanced -> height_avl l = height_avl r.

Lemma inv_right_balanced_avl :
 forall l r : avl_tree,
 is_balanced_avl l r Right_Balanced -> S (height_avl l) = height_avl r.

Lemma hasnot_grown_left__preserves_is_balanced_avl :
 forall (l l0 r0 : avl_tree) (b0 : bal),
 is_balanced_avl l0 r0 b0 ->
 height_avl l = height_avl l0 -> is_balanced_avl l r0 b0.

Lemma hasnot_grown_right__preserves_is_balanced_avl :
 forall (l0 r r0 : avl_tree) (b0 : bal),
 is_balanced_avl l0 r0 b0 ->
 height_avl r = height_avl r0 -> is_balanced_avl l0 r b0.

Inductive is_avl : avl_tree -> Prop :=
  | Nil_Is_Avl : is_avl Avl_Nil
  | Node_Is_Avl :
      forall (k : Int) (d : B) (l r : avl_tree) (b : bal),
      is_avl l ->
      is_avl r ->
      is_balanced_avl l r b ->
      is_below_avl l k -> is_above_avl r k -> is_avl (Avl_Node k d l r b).

Lemma is_avl_rec :
 forall P : avl_tree -> Set,
 P Avl_Nil ->
 (forall (k : Int) (d : B) (l r : avl_tree) (b : bal),
  is_avl l ->
  P l ->
  is_avl r ->
  P r ->
  is_balanced_avl l r b ->
  is_below_avl l k -> is_above_avl r k -> P (Avl_Node k d l r b)) ->
 forall t : avl_tree, is_avl t -> P t.

Lemma inv_is_avl_left :
 forall (k : Int) (d : B) (l r : avl_tree) (b : bal),
 is_avl (Avl_Node k d l r b) -> is_avl l.

Lemma inv_is_avl_right :
 forall (k : Int) (d : B) (l r : avl_tree) (b : bal),
 is_avl (Avl_Node k d l r b) -> is_avl r.

Lemma inv_is_avl_is_balanced_avl :
 forall (k : Int) (d : B) (l r : avl_tree) (b : bal),
 is_avl (Avl_Node k d l r b) -> is_balanced_avl l r b.

Lemma inv_is_avl_is_is_below_avl :
 forall (k : Int) (d : B) (l r : avl_tree) (b : bal),
 is_avl (Avl_Node k d l r b) -> is_below_avl l k.

Lemma inv_is_avl_is_is_above_avl :
 forall (k : Int) (d : B) (l r : avl_tree) (b : bal),
 is_avl (Avl_Node k d l r b) -> is_above_avl r k.

Lemma avl_height_avl_height :
 forall t : avl_tree, is_avl t -> height_avl t = height t.

Lemma is_balanced_avl_is_balanced :
 forall l r : avl_tree,
 is_avl l ->
 is_avl r -> forall b : bal, is_balanced_avl l r b -> is_balanced l r b.

Lemma is_avl_is_balanced :
 forall (l r : avl_tree) (k : Int) (d : B) (b : bal),
 is_avl (Avl_Node k d l r b) -> is_balanced l r b.

Lemma is_below_avl_is_below :
 forall t : avl_tree,
 is_avl t -> forall k0 : Int, is_below_avl t k0 -> is_below t k0.

Lemma is_above_avl_is_above :
 forall t : avl_tree,
 is_avl t -> forall k0 : Int, is_above_avl t k0 -> is_above t k0.

Lemma lookup_avl_inv_equal :
 forall (key k : Int) (d : B) (l r : avl_tree) (b : bal) (data : B),
 is_avl (Avl_Node k d l r b) ->
 Equal key k -> lookup key (Avl_Node k d l r b) data -> d = data.

Lemma lookup_avl_inv_less :
 forall (key k : Int) (d : B) (l r : avl_tree) (b : bal) (data : B),
 is_avl (Avl_Node k d l r b) ->
 Less key k -> lookup key (Avl_Node k d l r b) data -> lookup key l data.

Lemma lookup_avl_inv_greater :
 forall (key k : Int) (d : B) (l r : avl_tree) (b : bal) (data : B),
 is_avl (Avl_Node k d l r b) ->
 Less k key -> lookup key (Avl_Node k d l r b) data -> lookup key r data.

Lemma lookup_avl_equal :
 forall (k1 k : Int) (t : avl_tree) (d1 d : B),
 is_avl t -> lookup k1 t d1 -> lookup k t d -> Equal k1 k -> d1 = d.

Inductive lookup_dec_spec (key : Int) (t : avl_tree) : Set :=
  | Lookup : forall d : B, lookup key t d -> lookup_dec_spec key t
  | Not_Lookup : (forall d : B, ~ lookup key t d) -> lookup_dec_spec key t.

Lemma lookup_dec :
 forall (key : Int) (t : avl_tree), is_avl t -> lookup_dec_spec key t.

Fixpoint lin_avl (t : avl_tree) : list (Int * B) :=
  match t with
  | Avl_Nil => nil (A:=Int * B)
  | Avl_Node k d l r _ => lin_avl l ++ (k, d) :: lin_avl r
  end.

Inductive equiv : avl_tree -> avl_tree -> Prop :=
    equiv_intro :
      forall t0 t1 : avl_tree,
      (forall (key : Int) (data : B),
       lookup key t0 data -> lookup key t1 data) ->
      (forall (key : Int) (data : B),
       lookup key t1 data -> lookup key t0 data) -> 
      equiv t0 t1.

Lemma inv_equiv_t0_t1 :
 forall (t0 t1 : avl_tree) (key : Int) (data : B),
 equiv t0 t1 -> lookup key t0 data -> lookup key t1 data.

Lemma inv_equiv_t1_t0 :
 forall (t0 t1 : avl_tree) (key : Int) (data : B),
 equiv t0 t1 -> lookup key t1 data -> lookup key t0 data.

Lemma equiv_sym : forall t t0 : avl_tree, equiv t t0 -> equiv t0 t.

Lemma equiv_refl :
 forall (k : Int) (d : B) (l r : avl_tree) (b b' : bal),
 equiv (Avl_Node k d l r b) (Avl_Node k d l r b').

Definition rebalance_left_spec (k : Int) (d : B) (l r : avl_tree) 
(b : bal) : Set :=
  { t : avl_tree | 
      is_avl t /\
      lin_avl t = lin_avl (Avl_Node k d l r b) /\
      equiv t (Avl_Node k d l r b) /\
      match l with
      | Avl_Nil => True
      | Avl_Node _ _ _ _ Left_Balanced => height_avl t = height_avl l
      | Avl_Node _ _ _ _ Balanced => height_avl t = S (height_avl l)
      | Avl_Node _ _ _ _ Right_Balanced => height_avl t = height_avl l
      end }.

Lemma rebalance_left :
 forall (k : Int) (d : B) (l r : avl_tree) (b : bal),
 is_avl l ->
 is_below_avl l k ->
 is_avl r ->
 is_above_avl r k ->
 height_avl l = S (S (height_avl r)) -> rebalance_left_spec k d l r b.

Definition rebalance_right_spec (k : Int) (d : B) (l r : avl_tree) 
(b : bal) : Set :=
  { t : avl_tree | 
      is_avl t /\
      lin_avl t = lin_avl (Avl_Node k d l r b) /\
      equiv t (Avl_Node k d l r b) /\
      match r with
      | Avl_Nil => True
      | Avl_Node _ _ _ _ Left_Balanced => height_avl t = height_avl r
      | Avl_Node _ _ _ _ Balanced => height_avl t = S (height_avl r)
      | Avl_Node _ _ _ _ Right_Balanced => height_avl t = height_avl r
      end }.

Lemma rebalance_right :
 forall (k : Int) (d : B) (l r : avl_tree) (b : bal),
 is_avl l ->
 is_below_avl l k ->
 is_avl r ->
 is_above_avl r k ->
 S (S (height_avl l)) = height_avl r -> rebalance_right_spec k d l r b.

Inductive is_balanced_avl_left_shift (l r : avl_tree) : bal -> Prop :=
  | Is_Left_Balanced_Avl_Left_Shift :
      height_avl l = S (S (height_avl r)) ->
      is_balanced_avl_left_shift l r Left_Balanced
  | Is_Fully_Balanced_Avl_Left_Shift :
      height_avl l = S (height_avl r) ->
      is_balanced_avl_left_shift l r Balanced
  | Is_Right_Balanced_Avl_Left_Shift :
      height_avl l = height_avl r ->
      is_balanced_avl_left_shift l r Right_Balanced.

Lemma is_left_balanced_is_left_balanced_left_shift :
 forall (l0 l r0 : avl_tree) (b0 : bal),
 is_balanced_avl l0 r0 b0 ->
 height_avl l = S (height_avl l0) -> is_balanced_avl_left_shift l r0 b0.

Lemma is_balanced_is_balanced_left_shift_false :
 forall (l r : avl_tree) (b : bal),
 is_balanced_avl l r b -> is_balanced_avl_left_shift l r b -> False.

Inductive is_balanced_avl_right_shift (l r : avl_tree) : bal -> Prop :=
  | Is_Left_Balanced_Avl_Right_Shift :
      height_avl l = height_avl r ->
      is_balanced_avl_right_shift l r Left_Balanced
  | Is_Fully_Balanced_Avl_Right_Shift :
      S (height_avl l) = height_avl r ->
      is_balanced_avl_right_shift l r Balanced
  | Is_Right_Balanced_Avl_Right_Shift :
      S (S (height_avl l)) = height_avl r ->
      is_balanced_avl_right_shift l r Right_Balanced.

Lemma is_balanced_avl_is_balanced_avl_right_shift :
 forall (l0 r r0 : avl_tree) (b0 : bal),
 is_balanced_avl l0 r0 b0 ->
 height_avl r = S (height_avl r0) -> is_balanced_avl_right_shift l0 r b0.

Lemma is_balanced_avl_is_balanced_avl_right_shift_false :
 forall (l r : avl_tree) (b : bal),
 is_balanced_avl l r b -> is_balanced_avl_right_shift l r b -> False.

Inductive hasnot_grown_left (t : avl_tree) (k : Int) 
(d : B) (l r : avl_tree) : bal -> Prop :=
  | Hasnot_Grown_Left_Bal :
      forall b : bal,
      is_balanced_avl l r b ->
      height_avl t = height_avl (Avl_Node k d l r b) ->
      hasnot_grown_left t k d l r b
  | Hasnot_Grown_Left_Shift_Left :
      is_balanced_avl_left_shift l r Left_Balanced ->
      height_avl t = height_avl l ->
      hasnot_grown_left t k d l r Left_Balanced
  | Hasnot_Grown_Left_Shift_Right :
      is_balanced_avl_left_shift l r Right_Balanced ->
      height_avl t = S (height_avl l) ->
      hasnot_grown_left t k d l r Right_Balanced.

Inductive has_grown_left (t : avl_tree) (k : Int) (d : B) 
(l r : avl_tree) : bal -> Prop :=
  | Has_Grown_Left_Shift_Left :
      is_balanced_avl_left_shift l r Left_Balanced ->
      height_avl t = S (height_avl l) ->
      has_grown_left t k d l r Left_Balanced
  | Has_Grown_Left_Shift_Balanced :
      is_balanced_avl_left_shift l r Balanced ->
      height_avl t = S (height_avl l) -> has_grown_left t k d l r Balanced.

Inductive bal_grow_left_spec (k : Int) (d : B) (l r : avl_tree) 
(b : bal) : Set :=
    Balance_Grow_Left_Spec_Intro :
      forall t : avl_tree,
      is_avl t ->
      lin_avl t = lin_avl (Avl_Node k d l r b) ->
      equiv t (Avl_Node k d l r b) ->
      {hasnot_grown_left t k d l r b} + {has_grown_left t k d l r b} ->
      bal_grow_left_spec k d l r b.

Lemma balance_left :
 forall (k : Int) (d : B) (l r : avl_tree) (b : bal),
 is_avl l ->
 is_below_avl l k ->
 is_avl r ->
 is_above_avl r k ->
 {is_balanced_avl l r b} + {is_balanced_avl_left_shift l r b} ->
 bal_grow_left_spec k d l r b.

Inductive hasnot_grown_right (t : avl_tree) (k : Int) 
(d : B) (l r : avl_tree) : bal -> Prop :=
  | Hasnot_Grown_Right_Bal :
      forall b : bal,
      is_balanced_avl l r b ->
      height_avl t = height_avl (Avl_Node k d l r b) ->
      hasnot_grown_right t k d l r b
  | Hasnot_Grown_Right_Shift_Left :
      is_balanced_avl_right_shift l r Left_Balanced ->
      height_avl t = S (height_avl r) ->
      hasnot_grown_right t k d l r Left_Balanced
  | Hasnot_Grown_Right_Shift_Right :
      is_balanced_avl_right_shift l r Right_Balanced ->
      height_avl t = height_avl r ->
      hasnot_grown_right t k d l r Right_Balanced.

Inductive has_grown_right (t : avl_tree) (k : Int) 
(d : B) (l r : avl_tree) : bal -> Prop :=
  | Has_Grown_Right_Shift_Balanced :
      is_balanced_avl_right_shift l r Balanced ->
      height_avl t = S (height_avl r) -> has_grown_right t k d l r Balanced
  | Has_Grown_Right_Shift_Right :
      is_balanced_avl_right_shift l r Right_Balanced ->
      height_avl t = S (height_avl r) ->
      has_grown_right t k d l r Right_Balanced.

Inductive bal_grow_right_spec (k : Int) (d : B) (l r : avl_tree) 
(b : bal) : Set :=
    Balance_Grow_Right_Spec_Intro :
      forall t : avl_tree,
      is_avl t ->
      lin_avl t = lin_avl (Avl_Node k d l r b) ->
      equiv t (Avl_Node k d l r b) ->
      {hasnot_grown_right t k d l r b} + {has_grown_right t k d l r b} ->
      bal_grow_right_spec k d l r b.

Lemma balance_right :
 forall (k : Int) (d : B) (l r : avl_tree) (b : bal),
 is_avl l ->
 is_below_avl l k ->
 is_avl r ->
 is_above_avl r k ->
 {is_balanced_avl l r b} + {is_balanced_avl_right_shift l r b} ->
 bal_grow_right_spec k d l r b.

Inductive equiv_ins (key : Int) (update : B -> B) (init : B)
(t0 t : avl_tree) : Prop :=
    equiv_ins_intro :
      (forall (k : Int) (data : B),
       Equal k key -> lookup k t0 data -> lookup k t (update data)) ->
      (forall k : Int,
       Equal k key ->
       (forall data : B, lookup k t0 data -> False) ->
       lookup k t (update init)) ->
      (forall (k : Int) (data : B),
       ~ Equal k key -> lookup k t0 data -> lookup k t data) ->
      (forall (k : Int) (data : B),
       ~ Equal k key -> lookup k t data -> lookup k t0 data) ->
      equiv_ins key update init t0 t.

Lemma inv_equiv_ins_equal0 :
 forall (key : Int) (update : B -> B) (init : B) (t0 t : avl_tree) 
   (k : Int) (data : B),
 equiv_ins key update init t0 t ->
 Equal k key -> lookup k t0 data -> lookup k t (update data).

Lemma inv_equiv_ins_equal1 :
 forall (key : Int) (update : B -> B) (init : B) (t0 t : avl_tree) (k : Int),
 equiv_ins key update init t0 t ->
 Equal k key ->
 (forall data : B, lookup k t0 data -> False) -> lookup k t (update init).

Lemma inv_equiv_ins_notequal0 :
 forall (key : Int) (update : B -> B) (init : B) (t0 t : avl_tree) 
   (k : Int) (data : B),
 equiv_ins key update init t0 t ->
 ~ Equal k key -> lookup k t0 data -> lookup k t data.

Lemma inv_equiv_ins_notequal1 :
 forall (key : Int) (update : B -> B) (init : B) (t0 t : avl_tree) 
   (k : Int) (data : B),
 equiv_ins key update init t0 t ->
 ~ Equal k key -> lookup k t data -> lookup k t0 data.

Lemma equiv_ins_equiv_equiv_ins :
 forall (key : Int) (update : B -> B) (init : B) (t0 t1 t2 : avl_tree),
 equiv_ins key update init t0 t1 ->
 equiv t1 t2 -> equiv_ins key update init t0 t2.

Lemma equiv_ins_below :
 forall (key : Int) (update : B -> B) (init : B) (t0 t : avl_tree) (k0 : Int),
 equiv_ins key update init t0 t ->
 Less key k0 -> is_below t0 k0 -> is_below t k0.

Lemma equiv_ins_above :
 forall (key : Int) (update : B -> B) (init : B) (t0 t : avl_tree) (k0 : Int),
 equiv_ins key update init t0 t ->
 Less k0 key -> is_above t0 k0 -> is_above t k0.

Lemma leave_is_avl :
 forall (k : Int) (d : B), is_avl (Avl_Node k d Avl_Nil Avl_Nil Balanced).

Lemma equiv_ins_nil :
 forall (key : Int) (update : B -> B) (init : B),
 equiv_ins key update init Avl_Nil
   (Avl_Node key (update init) Avl_Nil Avl_Nil Balanced).

Lemma avl_ins_eq :
 forall (k : Int) (d : B) (l r : avl_tree) (b : bal) (d' : B),
 is_avl (Avl_Node k d l r b) -> is_avl (Avl_Node k d' l r b).

Lemma equiv_ins_eq :
 forall (key : Int) (update : B -> B) (init : B) (k : Int) 
   (d : B) (l0 r0 : avl_tree) (b : bal),
 is_avl (Avl_Node k d l0 r0 b) ->
 Equal key k ->
 equiv_ins key update init (Avl_Node k d l0 r0 b)
   (Avl_Node k (update d) l0 r0 b).

Lemma equiv_ins_left :
 forall (key : Int) (update : B -> B) (init : B) (k0 : Int) 
   (d0 : B) (l0 r0 : avl_tree) (b0 : bal) (l : avl_tree) 
   (b : bal),
 is_avl (Avl_Node k0 d0 l0 r0 b0) ->
 Less key k0 ->
 equiv_ins key update init l0 l ->
 equiv_ins key update init (Avl_Node k0 d0 l0 r0 b0) (Avl_Node k0 d0 l r0 b).

Lemma equiv_ins_right :
 forall (key : Int) (update : B -> B) (init : B) (k0 : Int) 
   (d0 : B) (l0 r0 : avl_tree) (b0 : bal) (r : avl_tree) 
   (b : bal),
 is_avl (Avl_Node k0 d0 l0 r0 b0) ->
 Less k0 key ->
 equiv_ins key update init r0 r ->
 equiv_ins key update init (Avl_Node k0 d0 l0 r0 b0) (Avl_Node k0 d0 l0 r b).

Inductive lin_ins_spec (key : Int) (update : B -> B) 
(init : B) (t0 t : avl_tree) : Prop :=
  | Lin_Ins_New :
      forall l0 l1 : list (Int * B),
      lin_avl t0 = l0 ++ l1 ->
      lin_avl t = l0 ++ (key, update init) :: l1 ->
      lin_ins_spec key update init t0 t
  | Lin_Ins_Update :
      forall (d : B) (l0 l1 : list (Int * B)),
      lin_avl t0 = l0 ++ (key, d) :: l1 ->
      lin_avl t = l0 ++ (key, update d) :: l1 ->
      lin_ins_spec key update init t0 t.

Inductive avl_ins_spec (key : Int) (update : B -> B) 
(init : B) (t0 : avl_tree) : Set :=
    Avl_Ins_Spec_Intro :
      forall t : avl_tree,
      lookup_dec_spec key t0 ->
      is_avl t ->
      lin_ins_spec key update init t0 t ->
      equiv_ins key update init t0 t ->
      {height_avl t = height_avl t0} + {height_avl t = S (height_avl t0)} ->
      avl_ins_spec key update init t0.

Lemma insert_avl :
 forall (key : Int) (update : B -> B) (init : B) (t0 : avl_tree),
 is_avl t0 -> avl_ins_spec key update init t0.

Inductive equiv_del (key : Int) (t0 t : avl_tree) : Prop :=
    equiv_del_intro :
      (forall k : Int, Equal k key -> forall d : B, lookup k t d -> False) ->
      (forall (k : Int) (data : B),
       ~ Equal k key -> lookup k t0 data -> lookup k t data) ->
      (forall (k : Int) (data : B),
       ~ Equal k key -> lookup k t data -> lookup k t0 data) ->
      equiv_del key t0 t.

Lemma inv_equiv_del_equal :
 forall (key : Int) (t0 t : avl_tree) (k : Int) (d : B),
 equiv_del key t0 t -> Equal k key -> lookup k t d -> False.

Lemma inv_equiv_del_notequal0 :
 forall (key : Int) (t0 t : avl_tree) (k : Int) (d : B),
 equiv_del key t0 t -> ~ Equal k key -> lookup k t0 d -> lookup k t d.

Lemma inv_equiv_del_notequal1 :
 forall (key : Int) (t0 t : avl_tree) (k : Int) (d : B),
 equiv_del key t0 t -> ~ Equal k key -> lookup k t d -> lookup k t0 d.

Lemma equiv_del_equiv_equiv_del :
 forall (key : Int) (t0 t1 t2 : avl_tree),
 equiv_del key t0 t1 -> equiv t1 t2 -> equiv_del key t0 t2.

Lemma equiv_del_semi_leave :
 forall (k : Int) (d : B) (l : avl_tree) (b : bal),
 is_avl (Avl_Node k d l Avl_Nil b) ->
 equiv_del k (Avl_Node k d l Avl_Nil b) l.

Lemma equiv_del_above :
 forall (key : Int) (t0 t : avl_tree) (k0 : Int),
 equiv_del key t0 t -> Less k0 key -> is_above t0 k0 -> is_above t k0.

Lemma equiv_del_right :
 forall (key k0 : Int) (d0 : B) (l0 r0 : avl_tree) 
   (b0 : bal) (r : avl_tree) (b : bal),
 is_avl (Avl_Node k0 d0 l0 r0 b0) ->
 Less k0 key ->
 equiv_del key r0 r ->
 equiv_del key (Avl_Node k0 d0 l0 r0 b0) (Avl_Node k0 d0 l0 r b).

Lemma below_equiv_below :
 forall (k : Int) (t0 t : avl_tree),
 is_below t0 k -> equiv t t0 -> is_below t k.

Lemma Balanced_shrunk_left_balanced_shift :
 forall (l0 r r0 : avl_tree) (b0 : bal),
 is_balanced_avl l0 r0 b0 ->
 height_avl r0 = S (height_avl r) -> is_balanced_avl_left_shift l0 r b0.

Lemma below_equiv_del_below :
 forall (t0 t : avl_tree) (k key : Int),
 is_below t0 k -> equiv_del key t0 t -> is_below t k.

Lemma above_equiv_del_above :
 forall (t0 t : avl_tree) (k key : Int),
 is_above t0 k -> equiv_del key t0 t -> is_above t k.

Inductive hasnot_shrunk_left (t : avl_tree) (k : Int) 
(d : B) (l r : avl_tree) : bal -> Prop :=
  | Hasnot_Shrunk_Left_Bal :
      forall b : bal,
      is_balanced_avl l r b ->
      height_avl t = height_avl (Avl_Node k d l r b) ->
      hasnot_shrunk_left t k d l r b
  | Hasnot_Shrunk_Left_Shift_Left :
      is_balanced_avl_left_shift l r Left_Balanced ->
      height_avl t = S (height_avl l) ->
      hasnot_shrunk_left t k d l r Left_Balanced
  | Hasnot_Shrunk_Left_Shift_Balanced :
      is_balanced_avl_left_shift l r Balanced ->
      height_avl t = S (height_avl l) ->
      hasnot_shrunk_left t k d l r Balanced.

Inductive has_shrunk_left (t : avl_tree) (k : Int) 
(d : B) (l r : avl_tree) : bal -> Prop :=
  | Has_Shrunk_Left_Shift_Left :
      is_balanced_avl_left_shift l r Left_Balanced ->
      height_avl t = height_avl l -> has_shrunk_left t k d l r Left_Balanced
  | Has_Shrunk_Left_Shift_Right :
      is_balanced_avl_left_shift l r Right_Balanced ->
      height_avl t = S (height_avl l) ->
      has_shrunk_left t k d l r Right_Balanced.

Inductive bal_shrunk_left_spec (k : Int) (d : B) (l r : avl_tree) 
(b : bal) : Set :=
    Balance_Shrunk_Left_Spec_Intro :
      forall t : avl_tree,
      is_avl t ->
      lin_avl t = lin_avl (Avl_Node k d l r b) ->
      equiv t (Avl_Node k d l r b) ->
      {hasnot_shrunk_left t k d l r b} + {has_shrunk_left t k d l r b} ->
      bal_shrunk_left_spec k d l r b.

Lemma balance_shrunk_left :
 forall (k : Int) (d : B) (l r : avl_tree) (b : bal),
 is_avl l ->
 is_below_avl l k ->
 is_avl r ->
 is_above_avl r k ->
 {is_balanced_avl l r b} + {is_balanced_avl_left_shift l r b} ->
 bal_shrunk_left_spec k d l r b.

Inductive delete_max_spec (t0 : avl_tree) : Set :=
    Del_Max_Spec_Intro :
      forall (k : Int) (d : B) (t : avl_tree),
      lookup k t0 d ->
      is_avl t ->
      is_below_avl t k ->
      lin_avl t0 = lin_avl t ++ (k, d) :: nil ->
      equiv_del k t0 t ->
      {height_avl t0 = height_avl t} + {height_avl t0 = S (height_avl t)} ->
      delete_max_spec t0.

Lemma delete_max :
 forall (k0 : Int) (d0 : B) (l0 r0 : avl_tree) (b0 : bal),
 is_avl (Avl_Node k0 d0 l0 r0 b0) ->
 delete_max_spec (Avl_Node k0 d0 l0 r0 b0).

Inductive hasnot_shrunk_right (t : avl_tree) (k : Int) 
(d : B) (l r : avl_tree) : bal -> Prop :=
  | Hasnot_Shrunk_Right_Bal :
      forall b : bal,
      is_balanced_avl l r b ->
      height_avl t = height_avl (Avl_Node k d l r b) ->
      hasnot_shrunk_right t k d l r b
  | Hasnot_Shrunk_Right_Shift_Balanced :
      is_balanced_avl_right_shift l r Balanced ->
      height_avl t = S (height_avl r) ->
      hasnot_shrunk_right t k d l r Balanced
  | Hasnot_Shrunk_Right_Shift_Right :
      is_balanced_avl_right_shift l r Right_Balanced ->
      height_avl t = S (height_avl r) ->
      hasnot_shrunk_right t k d l r Right_Balanced.

Inductive has_shrunk_right (t : avl_tree) (k : Int) 
(d : B) (l r : avl_tree) : bal -> Prop :=
  | Has_Shrunk_Right_Shift_Left :
      is_balanced_avl_right_shift l r Left_Balanced ->
      height_avl t = S (height_avl r) ->
      has_shrunk_right t k d l r Left_Balanced
  | Has_Shrunk_Right_Shift_Right :
      is_balanced_avl_right_shift l r Right_Balanced ->
      height_avl t = height_avl r ->
      has_shrunk_right t k d l r Right_Balanced.

Inductive bal_shrunk_right_spec (k : Int) (d : B) (l r : avl_tree) 
(b : bal) : Set :=
    Balance_Shrunk_Right_Spec_Intro :
      forall t : avl_tree,
      is_avl t ->
      lin_avl t = lin_avl (Avl_Node k d l r b) ->
      equiv t (Avl_Node k d l r b) ->
      {hasnot_shrunk_right t k d l r b} + {has_shrunk_right t k d l r b} ->
      bal_shrunk_right_spec k d l r b.

Lemma balance_shrunk_right :
 forall (k : Int) (d : B) (l r : avl_tree) (b : bal),
 is_avl l ->
 is_below_avl l k ->
 is_avl r ->
 is_above_avl r k ->
 {is_balanced_avl l r b} + {is_balanced_avl_right_shift l r b} ->
 bal_shrunk_right_spec k d l r b.

Inductive lin_del_spec (key : Int) (d : B) (t0 t : avl_tree) : Prop :=
    Lin_Del_Spec_Intro :
      forall l0 l1 : list (Int * B),
      lin_avl t0 = l0 ++ (key, d) :: l1 ->
      lin_avl t = l0 ++ l1 -> lin_del_spec key d t0 t.

Inductive delete_spec (key : Int) (t0 : avl_tree) : Set :=
    Delete_Spec_Intro :
      forall t : avl_tree,
      lookup_dec_spec key t0 ->
      is_avl t ->
      (forall d : B, lookup key t0 d -> lin_del_spec key d t0 t) ->
      equiv_del key t0 t ->
      {height_avl t0 = height_avl t} + {height_avl t0 = S (height_avl t)} ->
      delete_spec key t0.

Lemma equiv_del_nil : forall key : Int, equiv_del key Avl_Nil Avl_Nil.

Lemma equiv_del_right_semi_leave :
 forall (k : Int) (d : B) (r : avl_tree) (b : bal),
 is_avl (Avl_Node k d Avl_Nil r b) ->
 equiv_del k (Avl_Node k d Avl_Nil r b) r.

Lemma equiv_del_equal :
 forall (key k0 k : Int) (l0 l r0 : avl_tree) (b0 : bal) (d d0 : B),
 Equal key k0 ->
 equiv_del k l0 l ->
 lookup k l0 d ->
 is_below l0 k0 ->
 is_above r0 k0 ->
 is_avl l0 -> equiv_del key (Avl_Node k0 d0 l0 r0 b0) (Avl_Node k d l r0 b0).

Lemma is_balanced_avl_is_balanced_avl_right_shift_left :
 forall (l l0 r0 : avl_tree) (b0 : bal),
 is_balanced_avl l0 r0 b0 ->
 S (height_avl l) = height_avl l0 -> is_balanced_avl_right_shift l r0 b0.

Lemma is_balanced_is_balanced_right_shift :
 forall (l l0 r0 : avl_tree) (b0 : bal),
 is_balanced_avl l0 r0 b0 ->
 height_avl l0 = S (height_avl l) -> is_balanced_avl_right_shift l r0 b0.

Lemma equiv_del_trans_left :
 forall (k k0 : Int) (d0 : B) (l0 r0 l : avl_tree) (b0 : bal),
 Less k k0 ->
 is_above r0 k0 ->
 equiv_del k l0 l ->
 equiv_del k (Avl_Node k0 d0 l0 r0 b0) (Avl_Node k0 d0 l r0 b0).

Lemma equiv_del_trans_right :
 forall (k k0 : Int) (d0 : B) (l0 r r0 : avl_tree) (b0 : bal),
 Less k0 k ->
 is_below l0 k0 ->
 equiv_del k r0 r ->
 equiv_del k (Avl_Node k0 d0 l0 r0 b0) (Avl_Node k0 d0 l0 r b0).

Lemma delete_avl :
 forall (key : Int) (t0 : avl_tree), is_avl t0 -> delete_spec key t0.

Inductive AVL : Set :=
    AVL_intro : forall t : avl_tree, is_avl t -> AVL.

Definition AVL_NIL := AVL_intro Avl_Nil Nil_Is_Avl.

Definition LOOKUP (key : Int) (T : AVL) (data : B) :=
  match T with
  | AVL_intro t _ => lookup key t data
  end.

Definition LOOKUP_Dec_Spec (key : Int) (T : AVL) :=
  match T with
  | AVL_intro t _ => lookup_dec_spec key t
  end.

Theorem LOOKUP_DEC : forall (key : Int) (T : AVL), LOOKUP_Dec_Spec key T.

Definition LIN_AVL (T : AVL) := match T with
                                | AVL_intro t _ => lin_avl t
                                end.

Definition LIN_INS (key : Int) (update : B -> B) (init : B) 
  (T0 T : AVL) :=
  match T0 with
  | AVL_intro t0 _ =>
      match T with
      | AVL_intro t _ => lin_ins_spec key update init t0 t
      end
  end.

Definition EQUIV_INS (key : Int) (update : B -> B) 
  (init : B) (T0 T : AVL) :=
  match T0 with
  | AVL_intro t0 _ =>
      match T with
      | AVL_intro t _ => equiv_ins key update init t0 t
      end
  end.

Definition INSRT_Spec (key : Int) (update : B -> B) 
  (init : B) (T0 : AVL) :=
  match T0 with
  | AVL_intro t0 _ => avl_ins_spec key update init t0
  end.

Theorem INSRT_AVL :
 forall (key : Int) (update : B -> B) (init : B) (T0 : AVL),
 INSRT_Spec key update init T0.

Definition LIN_DEL (key : Int) (d : B) (T0 T : AVL) :=
  match T0 with
  | AVL_intro t0 _ =>
      match T with
      | AVL_intro t _ => lin_del_spec key d t0 t
      end
  end.

Definition EQUIV_DEL (key : Int) (T0 T : AVL) :=
  match T0 with
  | AVL_intro t0 _ => match T with
                      | AVL_intro t _ => equiv_del key t0 t
                      end
  end.

Definition DELETE_Spec (key : Int) (T0 : AVL) :=
  match T0 with
  | AVL_intro t0 _ => delete_spec key t0
  end.

Theorem DELETE_AVL : forall (key : Int) (T0 : AVL), DELETE_Spec key T0.

End avl_trees. *)

Section Regular_Avl.

Variable A : Set.

Definition Regular (t : avl_tree (list A)) :=
  forall (k : Int) (d : list A), lookup (list A) k t d -> d = nil -> False.

Remark regular_nil : Regular (Avl_Nil (list A)).
unfold Regular in |- *.
intros k d lookup eq_d.
inversion_clear lookup.
Qed.

Remark regular_equiv_del :
 forall (key : Int) (t t' : avl_tree (list A)),
 Regular t -> equiv_del (list A) key t t' -> Regular t'.
intros key t t' reg_t equiv_del.
unfold Regular in |- *.
intros k d lookup eq_d.
elim (equal_dec k key).
intros eq_k.
inversion_clear equiv_del.
apply H with k d; assumption.
intros not_eq_k.
apply reg_t with k d.
inversion_clear equiv_del.
apply H1; assumption.
assumption.
Qed.

Remark regular_equiv_ins :
 forall (key : Int) (data : A) (t t' : avl_tree (list A)),
 is_avl (list A) t ->
 is_avl (list A) t' ->
 Regular t -> equiv_ins (list A) key (cons data) nil t t' -> Regular t'.
intros key data t t' avl_t avl_t' reg_t equiv_ins.
unfold Regular in |- *.
intros k d lookup eq_d.
elim (equal_dec k key).
intros eq_k.
inversion_clear equiv_ins.
clear H1 H2.
elim (lookup_dec (list A) k t avl_t).
intros d0 lookup0.
cut (d = data :: d0).
 rewrite eq_d.
intro x;  discriminate x.
apply (lookup_avl_equal (list A) k k t').
assumption.
assumption.
apply H; assumption.
apply equal_refl.
intros not_lookup0.
cut (d = data :: nil).
 rewrite eq_d.
intro x;  discriminate x.
apply (lookup_avl_equal (list A) k k t').
assumption.
assumption.
apply H0; assumption.
apply equal_refl.

intros not_equal_k.
apply reg_t with k d.
inversion_clear equiv_ins.
clear H H0.
apply H2; assumption.
assumption.
Qed.

Definition REGULAR (t : AVL (list A)) :=
  match t with
  | AVL_intro t _ => Regular t
  end.

Lemma regular_AVL_NIL : REGULAR (AVL_NIL (list A)).
simpl in |- *.
exact regular_nil.
Qed.

Lemma regular_EQUIV_DEL :
 forall (key : Int) (T T' : AVL (list A)),
 REGULAR T -> EQUIV_DEL (list A) key T T' -> REGULAR T'.
intros key T T'.
elim T; clear T; intros t avl_t.
elim T'; clear T'; intros t' avl_t'.
simpl in |- *.
intros reg_t equiv_del.
apply regular_equiv_del with key t; assumption.
Qed.

Lemma regular_EQUIV_INS :
 forall (key : Int) (data : A) (T T' : AVL (list A)),
 REGULAR T -> EQUIV_INS (list A) key (cons data) nil T T' -> REGULAR T'.
intros key data T T'.
elim T; clear T; intros t avl_t.
elim T'; clear T'; intros t' avl_t'.
simpl in |- *.
intros reg_t equiv_ins.
apply regular_equiv_ins with key data t; assumption.
Qed.

End Regular_Avl.