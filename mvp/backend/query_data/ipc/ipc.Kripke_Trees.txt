
Require Export AvlTrees.
(* AvlTrees:
Require Import ML_Int.
Require Import My_Arith.
Require Import List.

Global Set Asymmetric Patterns.

Section avl_trees.

Variable B : Set.

Inductive bal : Set :=
  | Left_Balanced : bal
  | Balanced : bal
  | Right_Balanced : bal.

Inductive avl_tree : Set :=
  | Avl_Nil : avl_tree
  | Avl_Node : Int -> B -> avl_tree -> avl_tree -> bal -> avl_tree.

Inductive is_below : avl_tree -> Int -> Prop :=
  | Below_Nil : forall k0 : Int, is_below Avl_Nil k0
  | Below_Node :
      forall (k : Int) (d : B) (l r : avl_tree) (b : bal) (k0 : Int),
      Less k k0 ->
      is_below l k0 -> is_below r k0 -> is_below (Avl_Node k d l r b) k0.

Lemma inv_below_key :
 forall (k : Int) (d : B) (l r : avl_tree) (b : bal) (k0 : Int),
 is_below (Avl_Node k d l r b) k0 -> Less k k0.

Lemma inv_below_left :
 forall (k : Int) (d : B) (l r : avl_tree) (b : bal) (k0 : Int),
 is_below (Avl_Node k d l r b) k0 -> is_below l k0.

Lemma inv_below_right :
 forall (k : Int) (d : B) (l r : avl_tree) (b : bal) (k0 : Int),
 is_below (Avl_Node k d l r b) k0 -> is_below r k0.

Lemma below_trans :
 forall (t : avl_tree) (k0 k1 : Int),
 is_below t k0 -> Less k0 k1 -> is_below t k1.

Inductive is_above : avl_tree -> Int -> Prop :=
  | Above_Nil : forall k0 : Int, is_above Avl_Nil k0
  | Above_Node :
      forall (k : Int) (d : B) (l r : avl_tree) (b : bal) (k0 : Int),
      Less k0 k ->
      is_above l k0 -> is_above r k0 -> is_above (Avl_Node k d l r b) k0.

Lemma inv_above_key :
 forall (k : Int) (d : B) (l r : avl_tree) (b : bal) (k0 : Int),
 is_above (Avl_Node k d l r b) k0 -> Less k0 k.

Lemma inv_above_left :
 forall (k : Int) (d : B) (l r : avl_tree) (b : bal) (k0 : Int),
 is_above (Avl_Node k d l r b) k0 -> is_above l k0.

Lemma inv_above_right :
 forall (k : Int) (d : B) (l r : avl_tree) (b : bal) (k0 : Int),
 is_above (Avl_Node k d l r b) k0 -> is_above r k0.

Lemma above_trans :
 forall (t : avl_tree) (k0 k1 : Int),
 is_above t k0 -> Less k1 k0 -> is_above t k1.

Fixpoint height (t : avl_tree) : nat :=
  match t with
  | Avl_Nil => 0
  | Avl_Node _ _ l r _ => S (max (height l) (height r))
  end.

Lemma height_O_nil : forall t : avl_tree, height t = 0 -> t = Avl_Nil.

Inductive is_balanced (l r : avl_tree) : bal -> Prop :=
  | Is_Left_Balanced :
      height l = S (height r) -> is_balanced l r Left_Balanced
  | Is_Fully_Balanced : height l = height r -> is_balanced l r Balanced
  | Is_Right_Balanced :
      S (height l) = height r -> is_balanced l r Right_Balanced.

Lemma inv_left_balanced :
 forall l r : avl_tree,
 is_balanced l r Left_Balanced -> height l = S (height r).

Lemma inv_fully_balanced :
 forall l r : avl_tree, is_balanced l r Balanced -> height l = height r.

Lemma inv_right_balanced :
 forall l r : avl_tree,
 is_balanced l r Right_Balanced -> S (height l) = height r.

Inductive lookup (key : Int) : avl_tree -> B -> Prop :=
  | Lookup_Equal :
      forall (d : B) (l r : avl_tree) (b : bal),
      lookup key (Avl_Node key d l r b) d
  | Lookup_Left :
      forall (k : Int) (d : B) (l r : avl_tree) (b : bal) (data : B),
      lookup key l data -> lookup key (Avl_Node k d l r b) data
  | Lookup_Right :
      forall (k : Int) (d : B) (l r : avl_tree) (b : bal) (data : B),
      lookup key r data -> lookup key (Avl_Node k d l r b) data.

Lemma inv_lookup_nil :
 forall (key : Int) (data : B), lookup key Avl_Nil data -> False.

Lemma inv_lookup :
 forall (key k : Int) (d : B) (l r : avl_tree) (b : bal) (data : B),
 lookup key (Avl_Node k d l r b) data ->
 k = key /\ d = data \/ lookup key l data \/ lookup key r data.

Lemma lookup_below_less :
 forall (key : Int) (t : avl_tree) (data : B) (k0 : Int),
 lookup key t data -> is_below t k0 -> Less key k0.

Lemma lookup_above_greater :
 forall (key : Int) (t : avl_tree) (data : B) (k0 : Int),
 lookup key t data -> is_above t k0 -> Less k0 key.

Lemma lookup_less_below :
 forall (t : avl_tree) (k0 : Int),
 (forall (k : Int) (d : B), lookup k t d -> Less k k0) -> is_below t k0.

Lemma lookup_greater_above :
 forall (t : avl_tree) (k0 : Int),
 (forall (k : Int) (d : B), lookup k t d -> Less k0 k) -> is_above t k0.

Lemma lookup_above_lookup :
 forall (key k : Int) (d : B) (l r : avl_tree) (b : bal) (data : B),
 lookup key (Avl_Node k d l r b) data ->
 Less key k -> is_above r key -> lookup key l data.

Lemma lookup_below_lookup :
 forall (key k : Int) (d : B) (l r : avl_tree) (b : bal) (data : B),
 lookup key (Avl_Node k d l r b) data ->
 Less k key -> is_below l key -> lookup key r data.

Lemma lookup_below_false :
 forall (key : Int) (t : avl_tree) (data : B),
 lookup key t data -> is_below t key -> False.

Lemma lookup_above_false :
 forall (key : Int) (t : avl_tree) (data : B),
 lookup key t data -> is_above t key -> False.

Inductive is_below_avl : avl_tree -> Int -> Prop :=
  | Below_Avl_Nil : forall k0 : Int, is_below_avl Avl_Nil k0
  | Below_Avl_Node :
      forall (k : Int) (d : B) (l r : avl_tree) (b : bal) (k0 : Int),
      Less k k0 -> is_below_avl r k0 -> is_below_avl (Avl_Node k d l r b) k0.

Lemma inv_below_avl_key :
 forall (k : Int) (d : B) (l r : avl_tree) (b : bal) (k0 : Int),
 is_below_avl (Avl_Node k d l r b) k0 -> Less k k0.

Lemma inv_below_avl_right :
 forall (k : Int) (d : B) (l r : avl_tree) (b : bal) (k0 : Int),
 is_below_avl (Avl_Node k d l r b) k0 -> is_below_avl r k0.

Lemma below_avl_trans :
 forall (t : avl_tree) (k0 k1 : Int),
 is_below_avl t k0 -> Less k0 k1 -> is_below_avl t k1.

Lemma below_below_avl :
 forall (t : avl_tree) (key : Int), is_below t key -> is_below_avl t key.

Inductive is_above_avl : avl_tree -> Int -> Prop :=
  | Above_Avl_Nil : forall k0 : Int, is_above_avl Avl_Nil k0
  | Above_Avl_Node :
      forall (k : Int) (d : B) (l r : avl_tree) (b : bal) (k0 : Int),
      Less k0 k -> is_above_avl l k0 -> is_above_avl (Avl_Node k d l r b) k0.

Lemma inv_above_avl_key :
 forall (k : Int) (d : B) (l r : avl_tree) (b : bal) (k0 : Int),
 is_above_avl (Avl_Node k d l r b) k0 -> Less k0 k.

Lemma inv_above_avl_left :
 forall (k : Int) (d : B) (l r : avl_tree) (b : bal) (k0 : Int),
 is_above_avl (Avl_Node k d l r b) k0 -> is_above_avl l k0.

Lemma above_avl_trans :
 forall (t : avl_tree) (k0 k1 : Int),
 is_above_avl t k0 -> Less k1 k0 -> is_above_avl t k1.

Lemma above_above_avl :
 forall (t : avl_tree) (key : Int), is_above t key -> is_above_avl t key.

Fixpoint height_avl (t : avl_tree) : nat :=
  match t with
  | Avl_Nil => 0
  | Avl_Node _ _ l _ Left_Balanced => S (height_avl l)
  | Avl_Node _ _ l _ Balanced => S (height_avl l)
  | Avl_Node _ _ _ r Right_Balanced => S (height_avl r)
  end.

Lemma height_avl_O_nil : forall t : avl_tree, height_avl t = 0 -> t = Avl_Nil.

Inductive is_balanced_avl (l r : avl_tree) : bal -> Prop :=
  | Is_Left_Balanced_Avl :
      height_avl l = S (height_avl r) -> is_balanced_avl l r Left_Balanced
  | Is_Fully_Balanced_Avl :
      height_avl l = height_avl r -> is_balanced_avl l r Balanced
  | Is_Right_Balanced_Avl :
      S (height_avl l) = height_avl r -> is_balanced_avl l r Right_Balanced.

Lemma inv_left_balanced_avl :
 forall l r : avl_tree,
 is_balanced_avl l r Left_Balanced -> height_avl l = S (height_avl r).

Lemma inv_fully_balanced_avl :
 forall l r : avl_tree,
 is_balanced_avl l r Balanced -> height_avl l = height_avl r.

Lemma inv_right_balanced_avl :
 forall l r : avl_tree,
 is_balanced_avl l r Right_Balanced -> S (height_avl l) = height_avl r.

Lemma hasnot_grown_left__preserves_is_balanced_avl :
 forall (l l0 r0 : avl_tree) (b0 : bal),
 is_balanced_avl l0 r0 b0 ->
 height_avl l = height_avl l0 -> is_balanced_avl l r0 b0.

Lemma hasnot_grown_right__preserves_is_balanced_avl :
 forall (l0 r r0 : avl_tree) (b0 : bal),
 is_balanced_avl l0 r0 b0 ->
 height_avl r = height_avl r0 -> is_balanced_avl l0 r b0.

Inductive is_avl : avl_tree -> Prop :=
  | Nil_Is_Avl : is_avl Avl_Nil
  | Node_Is_Avl :
      forall (k : Int) (d : B) (l r : avl_tree) (b : bal),
      is_avl l ->
      is_avl r ->
      is_balanced_avl l r b ->
      is_below_avl l k -> is_above_avl r k -> is_avl (Avl_Node k d l r b).

Lemma is_avl_rec :
 forall P : avl_tree -> Set,
 P Avl_Nil ->
 (forall (k : Int) (d : B) (l r : avl_tree) (b : bal),
  is_avl l ->
  P l ->
  is_avl r ->
  P r ->
  is_balanced_avl l r b ->
  is_below_avl l k -> is_above_avl r k -> P (Avl_Node k d l r b)) ->
 forall t : avl_tree, is_avl t -> P t.

Lemma inv_is_avl_left :
 forall (k : Int) (d : B) (l r : avl_tree) (b : bal),
 is_avl (Avl_Node k d l r b) -> is_avl l.

Lemma inv_is_avl_right :
 forall (k : Int) (d : B) (l r : avl_tree) (b : bal),
 is_avl (Avl_Node k d l r b) -> is_avl r.

Lemma inv_is_avl_is_balanced_avl :
 forall (k : Int) (d : B) (l r : avl_tree) (b : bal),
 is_avl (Avl_Node k d l r b) -> is_balanced_avl l r b.

Lemma inv_is_avl_is_is_below_avl :
 forall (k : Int) (d : B) (l r : avl_tree) (b : bal),
 is_avl (Avl_Node k d l r b) -> is_below_avl l k.

Lemma inv_is_avl_is_is_above_avl :
 forall (k : Int) (d : B) (l r : avl_tree) (b : bal),
 is_avl (Avl_Node k d l r b) -> is_above_avl r k.

Lemma avl_height_avl_height :
 forall t : avl_tree, is_avl t -> height_avl t = height t.

Lemma is_balanced_avl_is_balanced :
 forall l r : avl_tree,
 is_avl l ->
 is_avl r -> forall b : bal, is_balanced_avl l r b -> is_balanced l r b.

Lemma is_avl_is_balanced :
 forall (l r : avl_tree) (k : Int) (d : B) (b : bal),
 is_avl (Avl_Node k d l r b) -> is_balanced l r b.

Lemma is_below_avl_is_below :
 forall t : avl_tree,
 is_avl t -> forall k0 : Int, is_below_avl t k0 -> is_below t k0.

Lemma is_above_avl_is_above :
 forall t : avl_tree,
 is_avl t -> forall k0 : Int, is_above_avl t k0 -> is_above t k0.

Lemma lookup_avl_inv_equal :
 forall (key k : Int) (d : B) (l r : avl_tree) (b : bal) (data : B),
 is_avl (Avl_Node k d l r b) ->
 Equal key k -> lookup key (Avl_Node k d l r b) data -> d = data.

Lemma lookup_avl_inv_less :
 forall (key k : Int) (d : B) (l r : avl_tree) (b : bal) (data : B),
 is_avl (Avl_Node k d l r b) ->
 Less key k -> lookup key (Avl_Node k d l r b) data -> lookup key l data.

Lemma lookup_avl_inv_greater :
 forall (key k : Int) (d : B) (l r : avl_tree) (b : bal) (data : B),
 is_avl (Avl_Node k d l r b) ->
 Less k key -> lookup key (Avl_Node k d l r b) data -> lookup key r data.

Lemma lookup_avl_equal :
 forall (k1 k : Int) (t : avl_tree) (d1 d : B),
 is_avl t -> lookup k1 t d1 -> lookup k t d -> Equal k1 k -> d1 = d.

Inductive lookup_dec_spec (key : Int) (t : avl_tree) : Set :=
  | Lookup : forall d : B, lookup key t d -> lookup_dec_spec key t
  | Not_Lookup : (forall d : B, ~ lookup key t d) -> lookup_dec_spec key t.

Lemma lookup_dec :
 forall (key : Int) (t : avl_tree), is_avl t -> lookup_dec_spec key t.

Fixpoint lin_avl (t : avl_tree) : list (Int * B) :=
  match t with
  | Avl_Nil => nil (A:=Int * B)
  | Avl_Node k d l r _ => lin_avl l ++ (k, d) :: lin_avl r
  end.

Inductive equiv : avl_tree -> avl_tree -> Prop :=
    equiv_intro :
      forall t0 t1 : avl_tree,
      (forall (key : Int) (data : B),
       lookup key t0 data -> lookup key t1 data) ->
      (forall (key : Int) (data : B),
       lookup key t1 data -> lookup key t0 data) -> 
      equiv t0 t1.

Lemma inv_equiv_t0_t1 :
 forall (t0 t1 : avl_tree) (key : Int) (data : B),
 equiv t0 t1 -> lookup key t0 data -> lookup key t1 data.

Lemma inv_equiv_t1_t0 :
 forall (t0 t1 : avl_tree) (key : Int) (data : B),
 equiv t0 t1 -> lookup key t1 data -> lookup key t0 data.

Lemma equiv_sym : forall t t0 : avl_tree, equiv t t0 -> equiv t0 t.

Lemma equiv_refl :
 forall (k : Int) (d : B) (l r : avl_tree) (b b' : bal),
 equiv (Avl_Node k d l r b) (Avl_Node k d l r b').

Definition rebalance_left_spec (k : Int) (d : B) (l r : avl_tree) 
(b : bal) : Set :=
  { t : avl_tree | 
      is_avl t /\
      lin_avl t = lin_avl (Avl_Node k d l r b) /\
      equiv t (Avl_Node k d l r b) /\
      match l with
      | Avl_Nil => True
      | Avl_Node _ _ _ _ Left_Balanced => height_avl t = height_avl l
      | Avl_Node _ _ _ _ Balanced => height_avl t = S (height_avl l)
      | Avl_Node _ _ _ _ Right_Balanced => height_avl t = height_avl l
      end }.

Lemma rebalance_left :
 forall (k : Int) (d : B) (l r : avl_tree) (b : bal),
 is_avl l ->
 is_below_avl l k ->
 is_avl r ->
 is_above_avl r k ->
 height_avl l = S (S (height_avl r)) -> rebalance_left_spec k d l r b.

Definition rebalance_right_spec (k : Int) (d : B) (l r : avl_tree) 
(b : bal) : Set :=
  { t : avl_tree | 
      is_avl t /\
      lin_avl t = lin_avl (Avl_Node k d l r b) /\
      equiv t (Avl_Node k d l r b) /\
      match r with
      | Avl_Nil => True
      | Avl_Node _ _ _ _ Left_Balanced => height_avl t = height_avl r
      | Avl_Node _ _ _ _ Balanced => height_avl t = S (height_avl r)
      | Avl_Node _ _ _ _ Right_Balanced => height_avl t = height_avl r
      end }.

Lemma rebalance_right :
 forall (k : Int) (d : B) (l r : avl_tree) (b : bal),
 is_avl l ->
 is_below_avl l k ->
 is_avl r ->
 is_above_avl r k ->
 S (S (height_avl l)) = height_avl r -> rebalance_right_spec k d l r b.

Inductive is_balanced_avl_left_shift (l r : avl_tree) : bal -> Prop :=
  | Is_Left_Balanced_Avl_Left_Shift :
      height_avl l = S (S (height_avl r)) ->
      is_balanced_avl_left_shift l r Left_Balanced
  | Is_Fully_Balanced_Avl_Left_Shift :
      height_avl l = S (height_avl r) ->
      is_balanced_avl_left_shift l r Balanced
  | Is_Right_Balanced_Avl_Left_Shift :
      height_avl l = height_avl r ->
      is_balanced_avl_left_shift l r Right_Balanced.

Lemma is_left_balanced_is_left_balanced_left_shift :
 forall (l0 l r0 : avl_tree) (b0 : bal),
 is_balanced_avl l0 r0 b0 ->
 height_avl l = S (height_avl l0) -> is_balanced_avl_left_shift l r0 b0.

Lemma is_balanced_is_balanced_left_shift_false :
 forall (l r : avl_tree) (b : bal),
 is_balanced_avl l r b -> is_balanced_avl_left_shift l r b -> False.

Inductive is_balanced_avl_right_shift (l r : avl_tree) : bal -> Prop :=
  | Is_Left_Balanced_Avl_Right_Shift :
      height_avl l = height_avl r ->
      is_balanced_avl_right_shift l r Left_Balanced
  | Is_Fully_Balanced_Avl_Right_Shift :
      S (height_avl l) = height_avl r ->
      is_balanced_avl_right_shift l r Balanced
  | Is_Right_Balanced_Avl_Right_Shift :
      S (S (height_avl l)) = height_avl r ->
      is_balanced_avl_right_shift l r Right_Balanced.

Lemma is_balanced_avl_is_balanced_avl_right_shift :
 forall (l0 r r0 : avl_tree) (b0 : bal),
 is_balanced_avl l0 r0 b0 ->
 height_avl r = S (height_avl r0) -> is_balanced_avl_right_shift l0 r b0.

Lemma is_balanced_avl_is_balanced_avl_right_shift_false :
 forall (l r : avl_tree) (b : bal),
 is_balanced_avl l r b -> is_balanced_avl_right_shift l r b -> False.

Inductive hasnot_grown_left (t : avl_tree) (k : Int) 
(d : B) (l r : avl_tree) : bal -> Prop :=
  | Hasnot_Grown_Left_Bal :
      forall b : bal,
      is_balanced_avl l r b ->
      height_avl t = height_avl (Avl_Node k d l r b) ->
      hasnot_grown_left t k d l r b
  | Hasnot_Grown_Left_Shift_Left :
      is_balanced_avl_left_shift l r Left_Balanced ->
      height_avl t = height_avl l ->
      hasnot_grown_left t k d l r Left_Balanced
  | Hasnot_Grown_Left_Shift_Right :
      is_balanced_avl_left_shift l r Right_Balanced ->
      height_avl t = S (height_avl l) ->
      hasnot_grown_left t k d l r Right_Balanced.

Inductive has_grown_left (t : avl_tree) (k : Int) (d : B) 
(l r : avl_tree) : bal -> Prop :=
  | Has_Grown_Left_Shift_Left :
      is_balanced_avl_left_shift l r Left_Balanced ->
      height_avl t = S (height_avl l) ->
      has_grown_left t k d l r Left_Balanced
  | Has_Grown_Left_Shift_Balanced :
      is_balanced_avl_left_shift l r Balanced ->
      height_avl t = S (height_avl l) -> has_grown_left t k d l r Balanced.

Inductive bal_grow_left_spec (k : Int) (d : B) (l r : avl_tree) 
(b : bal) : Set :=
    Balance_Grow_Left_Spec_Intro :
      forall t : avl_tree,
      is_avl t ->
      lin_avl t = lin_avl (Avl_Node k d l r b) ->
      equiv t (Avl_Node k d l r b) ->
      {hasnot_grown_left t k d l r b} + {has_grown_left t k d l r b} ->
      bal_grow_left_spec k d l r b.

Lemma balance_left :
 forall (k : Int) (d : B) (l r : avl_tree) (b : bal),
 is_avl l ->
 is_below_avl l k ->
 is_avl r ->
 is_above_avl r k ->
 {is_balanced_avl l r b} + {is_balanced_avl_left_shift l r b} ->
 bal_grow_left_spec k d l r b.

Inductive hasnot_grown_right (t : avl_tree) (k : Int) 
(d : B) (l r : avl_tree) : bal -> Prop :=
  | Hasnot_Grown_Right_Bal :
      forall b : bal,
      is_balanced_avl l r b ->
      height_avl t = height_avl (Avl_Node k d l r b) ->
      hasnot_grown_right t k d l r b
  | Hasnot_Grown_Right_Shift_Left :
      is_balanced_avl_right_shift l r Left_Balanced ->
      height_avl t = S (height_avl r) ->
      hasnot_grown_right t k d l r Left_Balanced
  | Hasnot_Grown_Right_Shift_Right :
      is_balanced_avl_right_shift l r Right_Balanced ->
      height_avl t = height_avl r ->
      hasnot_grown_right t k d l r Right_Balanced.

Inductive has_grown_right (t : avl_tree) (k : Int) 
(d : B) (l r : avl_tree) : bal -> Prop :=
  | Has_Grown_Right_Shift_Balanced :
      is_balanced_avl_right_shift l r Balanced ->
      height_avl t = S (height_avl r) -> has_grown_right t k d l r Balanced
  | Has_Grown_Right_Shift_Right :
      is_balanced_avl_right_shift l r Right_Balanced ->
      height_avl t = S (height_avl r) ->
      has_grown_right t k d l r Right_Balanced.

Inductive bal_grow_right_spec (k : Int) (d : B) (l r : avl_tree) 
(b : bal) : Set :=
    Balance_Grow_Right_Spec_Intro :
      forall t : avl_tree,
      is_avl t ->
      lin_avl t = lin_avl (Avl_Node k d l r b) ->
      equiv t (Avl_Node k d l r b) ->
      {hasnot_grown_right t k d l r b} + {has_grown_right t k d l r b} ->
      bal_grow_right_spec k d l r b.

Lemma balance_right :
 forall (k : Int) (d : B) (l r : avl_tree) (b : bal),
 is_avl l ->
 is_below_avl l k ->
 is_avl r ->
 is_above_avl r k ->
 {is_balanced_avl l r b} + {is_balanced_avl_right_shift l r b} ->
 bal_grow_right_spec k d l r b.

Inductive equiv_ins (key : Int) (update : B -> B) (init : B)
(t0 t : avl_tree) : Prop :=
    equiv_ins_intro :
      (forall (k : Int) (data : B),
       Equal k key -> lookup k t0 data -> lookup k t (update data)) ->
      (forall k : Int,
       Equal k key ->
       (forall data : B, lookup k t0 data -> False) ->
       lookup k t (update init)) ->
      (forall (k : Int) (data : B),
       ~ Equal k key -> lookup k t0 data -> lookup k t data) ->
      (forall (k : Int) (data : B),
       ~ Equal k key -> lookup k t data -> lookup k t0 data) ->
      equiv_ins key update init t0 t.

Lemma inv_equiv_ins_equal0 :
 forall (key : Int) (update : B -> B) (init : B) (t0 t : avl_tree) 
   (k : Int) (data : B),
 equiv_ins key update init t0 t ->
 Equal k key -> lookup k t0 data -> lookup k t (update data).

Lemma inv_equiv_ins_equal1 :
 forall (key : Int) (update : B -> B) (init : B) (t0 t : avl_tree) (k : Int),
 equiv_ins key update init t0 t ->
 Equal k key ->
 (forall data : B, lookup k t0 data -> False) -> lookup k t (update init).

Lemma inv_equiv_ins_notequal0 :
 forall (key : Int) (update : B -> B) (init : B) (t0 t : avl_tree) 
   (k : Int) (data : B),
 equiv_ins key update init t0 t ->
 ~ Equal k key -> lookup k t0 data -> lookup k t data.

Lemma inv_equiv_ins_notequal1 :
 forall (key : Int) (update : B -> B) (init : B) (t0 t : avl_tree) 
   (k : Int) (data : B),
 equiv_ins key update init t0 t ->
 ~ Equal k key -> lookup k t data -> lookup k t0 data.

Lemma equiv_ins_equiv_equiv_ins :
 forall (key : Int) (update : B -> B) (init : B) (t0 t1 t2 : avl_tree),
 equiv_ins key update init t0 t1 ->
 equiv t1 t2 -> equiv_ins key update init t0 t2.

Lemma equiv_ins_below :
 forall (key : Int) (update : B -> B) (init : B) (t0 t : avl_tree) (k0 : Int),
 equiv_ins key update init t0 t ->
 Less key k0 -> is_below t0 k0 -> is_below t k0.

Lemma equiv_ins_above :
 forall (key : Int) (update : B -> B) (init : B) (t0 t : avl_tree) (k0 : Int),
 equiv_ins key update init t0 t ->
 Less k0 key -> is_above t0 k0 -> is_above t k0.

Lemma leave_is_avl :
 forall (k : Int) (d : B), is_avl (Avl_Node k d Avl_Nil Avl_Nil Balanced).

Lemma equiv_ins_nil :
 forall (key : Int) (update : B -> B) (init : B),
 equiv_ins key update init Avl_Nil
   (Avl_Node key (update init) Avl_Nil Avl_Nil Balanced).

Lemma avl_ins_eq :
 forall (k : Int) (d : B) (l r : avl_tree) (b : bal) (d' : B),
 is_avl (Avl_Node k d l r b) -> is_avl (Avl_Node k d' l r b).

Lemma equiv_ins_eq :
 forall (key : Int) (update : B -> B) (init : B) (k : Int) 
   (d : B) (l0 r0 : avl_tree) (b : bal),
 is_avl (Avl_Node k d l0 r0 b) ->
 Equal key k ->
 equiv_ins key update init (Avl_Node k d l0 r0 b)
   (Avl_Node k (update d) l0 r0 b).

Lemma equiv_ins_left :
 forall (key : Int) (update : B -> B) (init : B) (k0 : Int) 
   (d0 : B) (l0 r0 : avl_tree) (b0 : bal) (l : avl_tree) 
   (b : bal),
 is_avl (Avl_Node k0 d0 l0 r0 b0) ->
 Less key k0 ->
 equiv_ins key update init l0 l ->
 equiv_ins key update init (Avl_Node k0 d0 l0 r0 b0) (Avl_Node k0 d0 l r0 b).

Lemma equiv_ins_right :
 forall (key : Int) (update : B -> B) (init : B) (k0 : Int) 
   (d0 : B) (l0 r0 : avl_tree) (b0 : bal) (r : avl_tree) 
   (b : bal),
 is_avl (Avl_Node k0 d0 l0 r0 b0) ->
 Less k0 key ->
 equiv_ins key update init r0 r ->
 equiv_ins key update init (Avl_Node k0 d0 l0 r0 b0) (Avl_Node k0 d0 l0 r b).

Inductive lin_ins_spec (key : Int) (update : B -> B) 
(init : B) (t0 t : avl_tree) : Prop :=
  | Lin_Ins_New :
      forall l0 l1 : list (Int * B),
      lin_avl t0 = l0 ++ l1 ->
      lin_avl t = l0 ++ (key, update init) :: l1 ->
      lin_ins_spec key update init t0 t
  | Lin_Ins_Update :
      forall (d : B) (l0 l1 : list (Int * B)),
      lin_avl t0 = l0 ++ (key, d) :: l1 ->
      lin_avl t = l0 ++ (key, update d) :: l1 ->
      lin_ins_spec key update init t0 t.

Inductive avl_ins_spec (key : Int) (update : B -> B) 
(init : B) (t0 : avl_tree) : Set :=
    Avl_Ins_Spec_Intro :
      forall t : avl_tree,
      lookup_dec_spec key t0 ->
      is_avl t ->
      lin_ins_spec key update init t0 t ->
      equiv_ins key update init t0 t ->
      {height_avl t = height_avl t0} + {height_avl t = S (height_avl t0)} ->
      avl_ins_spec key update init t0.

Lemma insert_avl :
 forall (key : Int) (update : B -> B) (init : B) (t0 : avl_tree),
 is_avl t0 -> avl_ins_spec key update init t0.

Inductive equiv_del (key : Int) (t0 t : avl_tree) : Prop :=
    equiv_del_intro :
      (forall k : Int, Equal k key -> forall d : B, lookup k t d -> False) ->
      (forall (k : Int) (data : B),
       ~ Equal k key -> lookup k t0 data -> lookup k t data) ->
      (forall (k : Int) (data : B),
       ~ Equal k key -> lookup k t data -> lookup k t0 data) ->
      equiv_del key t0 t.

Lemma inv_equiv_del_equal :
 forall (key : Int) (t0 t : avl_tree) (k : Int) (d : B),
 equiv_del key t0 t -> Equal k key -> lookup k t d -> False.

Lemma inv_equiv_del_notequal0 :
 forall (key : Int) (t0 t : avl_tree) (k : Int) (d : B),
 equiv_del key t0 t -> ~ Equal k key -> lookup k t0 d -> lookup k t d.

Lemma inv_equiv_del_notequal1 :
 forall (key : Int) (t0 t : avl_tree) (k : Int) (d : B),
 equiv_del key t0 t -> ~ Equal k key -> lookup k t d -> lookup k t0 d.

Lemma equiv_del_equiv_equiv_del :
 forall (key : Int) (t0 t1 t2 : avl_tree),
 equiv_del key t0 t1 -> equiv t1 t2 -> equiv_del key t0 t2.

Lemma equiv_del_semi_leave :
 forall (k : Int) (d : B) (l : avl_tree) (b : bal),
 is_avl (Avl_Node k d l Avl_Nil b) ->
 equiv_del k (Avl_Node k d l Avl_Nil b) l.

Lemma equiv_del_above :
 forall (key : Int) (t0 t : avl_tree) (k0 : Int),
 equiv_del key t0 t -> Less k0 key -> is_above t0 k0 -> is_above t k0.

Lemma equiv_del_right :
 forall (key k0 : Int) (d0 : B) (l0 r0 : avl_tree) 
   (b0 : bal) (r : avl_tree) (b : bal),
 is_avl (Avl_Node k0 d0 l0 r0 b0) ->
 Less k0 key ->
 equiv_del key r0 r ->
 equiv_del key (Avl_Node k0 d0 l0 r0 b0) (Avl_Node k0 d0 l0 r b).

Lemma below_equiv_below :
 forall (k : Int) (t0 t : avl_tree),
 is_below t0 k -> equiv t t0 -> is_below t k.

Lemma Balanced_shrunk_left_balanced_shift :
 forall (l0 r r0 : avl_tree) (b0 : bal),
 is_balanced_avl l0 r0 b0 ->
 height_avl r0 = S (height_avl r) -> is_balanced_avl_left_shift l0 r b0.

Lemma below_equiv_del_below :
 forall (t0 t : avl_tree) (k key : Int),
 is_below t0 k -> equiv_del key t0 t -> is_below t k.

Lemma above_equiv_del_above :
 forall (t0 t : avl_tree) (k key : Int),
 is_above t0 k -> equiv_del key t0 t -> is_above t k.

Inductive hasnot_shrunk_left (t : avl_tree) (k : Int) 
(d : B) (l r : avl_tree) : bal -> Prop :=
  | Hasnot_Shrunk_Left_Bal :
      forall b : bal,
      is_balanced_avl l r b ->
      height_avl t = height_avl (Avl_Node k d l r b) ->
      hasnot_shrunk_left t k d l r b
  | Hasnot_Shrunk_Left_Shift_Left :
      is_balanced_avl_left_shift l r Left_Balanced ->
      height_avl t = S (height_avl l) ->
      hasnot_shrunk_left t k d l r Left_Balanced
  | Hasnot_Shrunk_Left_Shift_Balanced :
      is_balanced_avl_left_shift l r Balanced ->
      height_avl t = S (height_avl l) ->
      hasnot_shrunk_left t k d l r Balanced.

Inductive has_shrunk_left (t : avl_tree) (k : Int) 
(d : B) (l r : avl_tree) : bal -> Prop :=
  | Has_Shrunk_Left_Shift_Left :
      is_balanced_avl_left_shift l r Left_Balanced ->
      height_avl t = height_avl l -> has_shrunk_left t k d l r Left_Balanced
  | Has_Shrunk_Left_Shift_Right :
      is_balanced_avl_left_shift l r Right_Balanced ->
      height_avl t = S (height_avl l) ->
      has_shrunk_left t k d l r Right_Balanced.

Inductive bal_shrunk_left_spec (k : Int) (d : B) (l r : avl_tree) 
(b : bal) : Set :=
    Balance_Shrunk_Left_Spec_Intro :
      forall t : avl_tree,
      is_avl t ->
      lin_avl t = lin_avl (Avl_Node k d l r b) ->
      equiv t (Avl_Node k d l r b) ->
      {hasnot_shrunk_left t k d l r b} + {has_shrunk_left t k d l r b} ->
      bal_shrunk_left_spec k d l r b.

Lemma balance_shrunk_left :
 forall (k : Int) (d : B) (l r : avl_tree) (b : bal),
 is_avl l ->
 is_below_avl l k ->
 is_avl r ->
 is_above_avl r k ->
 {is_balanced_avl l r b} + {is_balanced_avl_left_shift l r b} ->
 bal_shrunk_left_spec k d l r b.

Inductive delete_max_spec (t0 : avl_tree) : Set :=
    Del_Max_Spec_Intro :
      forall (k : Int) (d : B) (t : avl_tree),
      lookup k t0 d ->
      is_avl t ->
      is_below_avl t k ->
      lin_avl t0 = lin_avl t ++ (k, d) :: nil ->
      equiv_del k t0 t ->
      {height_avl t0 = height_avl t} + {height_avl t0 = S (height_avl t)} ->
      delete_max_spec t0.

Lemma delete_max :
 forall (k0 : Int) (d0 : B) (l0 r0 : avl_tree) (b0 : bal),
 is_avl (Avl_Node k0 d0 l0 r0 b0) ->
 delete_max_spec (Avl_Node k0 d0 l0 r0 b0).

Inductive hasnot_shrunk_right (t : avl_tree) (k : Int) 
(d : B) (l r : avl_tree) : bal -> Prop :=
  | Hasnot_Shrunk_Right_Bal :
      forall b : bal,
      is_balanced_avl l r b ->
      height_avl t = height_avl (Avl_Node k d l r b) ->
      hasnot_shrunk_right t k d l r b
  | Hasnot_Shrunk_Right_Shift_Balanced :
      is_balanced_avl_right_shift l r Balanced ->
      height_avl t = S (height_avl r) ->
      hasnot_shrunk_right t k d l r Balanced
  | Hasnot_Shrunk_Right_Shift_Right :
      is_balanced_avl_right_shift l r Right_Balanced ->
      height_avl t = S (height_avl r) ->
      hasnot_shrunk_right t k d l r Right_Balanced.

Inductive has_shrunk_right (t : avl_tree) (k : Int) 
(d : B) (l r : avl_tree) : bal -> Prop :=
  | Has_Shrunk_Right_Shift_Left :
      is_balanced_avl_right_shift l r Left_Balanced ->
      height_avl t = S (height_avl r) ->
      has_shrunk_right t k d l r Left_Balanced
  | Has_Shrunk_Right_Shift_Right :
      is_balanced_avl_right_shift l r Right_Balanced ->
      height_avl t = height_avl r ->
      has_shrunk_right t k d l r Right_Balanced.

Inductive bal_shrunk_right_spec (k : Int) (d : B) (l r : avl_tree) 
(b : bal) : Set :=
    Balance_Shrunk_Right_Spec_Intro :
      forall t : avl_tree,
      is_avl t ->
      lin_avl t = lin_avl (Avl_Node k d l r b) ->
      equiv t (Avl_Node k d l r b) ->
      {hasnot_shrunk_right t k d l r b} + {has_shrunk_right t k d l r b} ->
      bal_shrunk_right_spec k d l r b.

Lemma balance_shrunk_right :
 forall (k : Int) (d : B) (l r : avl_tree) (b : bal),
 is_avl l ->
 is_below_avl l k ->
 is_avl r ->
 is_above_avl r k ->
 {is_balanced_avl l r b} + {is_balanced_avl_right_shift l r b} ->
 bal_shrunk_right_spec k d l r b.

Inductive lin_del_spec (key : Int) (d : B) (t0 t : avl_tree) : Prop :=
    Lin_Del_Spec_Intro :
      forall l0 l1 : list (Int * B),
      lin_avl t0 = l0 ++ (key, d) :: l1 ->
      lin_avl t = l0 ++ l1 -> lin_del_spec key d t0 t.

Inductive delete_spec (key : Int) (t0 : avl_tree) : Set :=
    Delete_Spec_Intro :
      forall t : avl_tree,
      lookup_dec_spec key t0 ->
      is_avl t ->
      (forall d : B, lookup key t0 d -> lin_del_spec key d t0 t) ->
      equiv_del key t0 t ->
      {height_avl t0 = height_avl t} + {height_avl t0 = S (height_avl t)} ->
      delete_spec key t0.

Lemma equiv_del_nil : forall key : Int, equiv_del key Avl_Nil Avl_Nil.

Lemma equiv_del_right_semi_leave :
 forall (k : Int) (d : B) (r : avl_tree) (b : bal),
 is_avl (Avl_Node k d Avl_Nil r b) ->
 equiv_del k (Avl_Node k d Avl_Nil r b) r.

Lemma equiv_del_equal :
 forall (key k0 k : Int) (l0 l r0 : avl_tree) (b0 : bal) (d d0 : B),
 Equal key k0 ->
 equiv_del k l0 l ->
 lookup k l0 d ->
 is_below l0 k0 ->
 is_above r0 k0 ->
 is_avl l0 -> equiv_del key (Avl_Node k0 d0 l0 r0 b0) (Avl_Node k d l r0 b0).

Lemma is_balanced_avl_is_balanced_avl_right_shift_left :
 forall (l l0 r0 : avl_tree) (b0 : bal),
 is_balanced_avl l0 r0 b0 ->
 S (height_avl l) = height_avl l0 -> is_balanced_avl_right_shift l r0 b0.

Lemma is_balanced_is_balanced_right_shift :
 forall (l l0 r0 : avl_tree) (b0 : bal),
 is_balanced_avl l0 r0 b0 ->
 height_avl l0 = S (height_avl l) -> is_balanced_avl_right_shift l r0 b0.

Lemma equiv_del_trans_left :
 forall (k k0 : Int) (d0 : B) (l0 r0 l : avl_tree) (b0 : bal),
 Less k k0 ->
 is_above r0 k0 ->
 equiv_del k l0 l ->
 equiv_del k (Avl_Node k0 d0 l0 r0 b0) (Avl_Node k0 d0 l r0 b0).

Lemma equiv_del_trans_right :
 forall (k k0 : Int) (d0 : B) (l0 r r0 : avl_tree) (b0 : bal),
 Less k0 k ->
 is_below l0 k0 ->
 equiv_del k r0 r ->
 equiv_del k (Avl_Node k0 d0 l0 r0 b0) (Avl_Node k0 d0 l0 r b0).

Lemma delete_avl :
 forall (key : Int) (t0 : avl_tree), is_avl t0 -> delete_spec key t0.

Inductive AVL : Set :=
    AVL_intro : forall t : avl_tree, is_avl t -> AVL.

Definition AVL_NIL := AVL_intro Avl_Nil Nil_Is_Avl.

Definition LOOKUP (key : Int) (T : AVL) (data : B) :=
  match T with
  | AVL_intro t _ => lookup key t data
  end.

Definition LOOKUP_Dec_Spec (key : Int) (T : AVL) :=
  match T with
  | AVL_intro t _ => lookup_dec_spec key t
  end.

Theorem LOOKUP_DEC : forall (key : Int) (T : AVL), LOOKUP_Dec_Spec key T.

Definition LIN_AVL (T : AVL) := match T with
                                | AVL_intro t _ => lin_avl t
                                end.

Definition LIN_INS (key : Int) (update : B -> B) (init : B) 
  (T0 T : AVL) :=
  match T0 with
  | AVL_intro t0 _ =>
      match T with
      | AVL_intro t _ => lin_ins_spec key update init t0 t
      end
  end.

Definition EQUIV_INS (key : Int) (update : B -> B) 
  (init : B) (T0 T : AVL) :=
  match T0 with
  | AVL_intro t0 _ =>
      match T with
      | AVL_intro t _ => equiv_ins key update init t0 t
      end
  end.

Definition INSRT_Spec (key : Int) (update : B -> B) 
  (init : B) (T0 : AVL) :=
  match T0 with
  | AVL_intro t0 _ => avl_ins_spec key update init t0
  end.

Theorem INSRT_AVL :
 forall (key : Int) (update : B -> B) (init : B) (T0 : AVL),
 INSRT_Spec key update init T0.

Definition LIN_DEL (key : Int) (d : B) (T0 T : AVL) :=
  match T0 with
  | AVL_intro t0 _ =>
      match T with
      | AVL_intro t _ => lin_del_spec key d t0 t
      end
  end.

Definition EQUIV_DEL (key : Int) (T0 T : AVL) :=
  match T0 with
  | AVL_intro t0 _ => match T with
                      | AVL_intro t _ => equiv_del key t0 t
                      end
  end.

Definition DELETE_Spec (key : Int) (T0 : AVL) :=
  match T0 with
  | AVL_intro t0 _ => delete_spec key t0
  end.

Theorem DELETE_AVL : forall (key : Int) (T0 : AVL), DELETE_Spec key T0.

End avl_trees. *)
Require Export Trees.
(* Trees:
Require Export My_Arith.
Require Import Le.

Section Trees.

Variable A : Set.

Inductive Tree : Set :=
    node : A -> Forest -> Tree
with Forest : Set :=
  | Nil_Forest : Forest
  | Cons_Forest : Tree -> Forest -> Forest.

Fixpoint height_tree (t : Tree) : nat :=
  match t with
  | node a succs => S (height_forest succs)
  end
 
 with height_forest (succs : Forest) : nat :=
  match succs with
  | Nil_Forest => 0
  | Cons_Forest t0 succs => max (height_tree t0) (height_forest succs)
  end.

Definition root (t : Tree) := match t with
                              | node a _ => a
                              end.
Definition successors (t : Tree) := match t with
                                    | node _ succs => succs
                                    end.

Inductive In_Forest (t0 : Tree) : Forest -> Prop :=
  | in_forest_head :
      forall succs : Forest, In_Forest t0 (Cons_Forest t0 succs)
  | in_forest_tail :
      forall (t1 : Tree) (succs : Forest),
      In_Forest t0 succs -> In_Forest t0 (Cons_Forest t1 succs).

Lemma height_in_le :
 forall (t : Tree) (succs : Forest),
 In_Forest t succs -> height_tree t <= height_forest succs.                    

Lemma My_Tree_ind :
 forall P : Tree -> Prop,
 (forall (a : A) (succs : Forest),
  (forall t : Tree, In_Forest t succs -> P t) -> P (node a succs)) ->
 forall t : Tree, P t.

Lemma My_Tree_rec :
 forall P : Tree -> Set,
 (forall (a : A) (succs : Forest),
  (forall t : Tree, In_Forest t succs -> P t) -> P (node a succs)) ->
 forall t : Tree, P t.

Inductive Successor : Tree -> Tree -> Prop :=
  | successor_refl : forall t : Tree, Successor t t
  | successor_trans :
      forall t0 t1 : Tree,
      In_Forest t1 (successors t0) ->
      forall t2 : Tree, Successor t2 t1 -> Successor t2 t0.

Lemma succs_trans :
 forall t1 t2 : Tree,
 Successor t2 t1 -> forall t0 : Tree, Successor t1 t0 -> Successor t2 t0.

Lemma succs_refl : forall t : Tree, Successor t t.

Lemma Succs_Tree_ind :
 forall P : Tree -> Prop,
 (forall a : A, P (node a Nil_Forest)) ->
 (forall t0 t1 : Tree, Successor t0 t1 -> P t0 -> P t1) ->
 forall t : Tree, P t.

Inductive In_tree : A -> Tree -> Prop :=
  | in_leave : forall (a : A) (succs : Forest), In_tree a (node a succs)
  | in_succs :
      forall (succs : Forest) (t : Tree),
      In_Forest t succs ->
      forall a : A, In_tree a t -> forall a' : A, In_tree a (node a' succs).

Lemma in_successor_in :
 forall (a : A) (t : Tree),
 In_tree a t -> forall t' : Tree, Successor t t' -> In_tree a t'.

Variable I : Set.
Variable P : A -> I -> Prop.

Inductive Is_Monotone_Tree : Tree -> Prop :=
    is_monotone_tree_intro :
      forall (a : A) (succs : Forest),
      Is_Monotone_Forest a succs -> Is_Monotone_Tree (node a succs)
with Is_Monotone_Forest : A -> Forest -> Prop :=
  | is_monotone_forest_nil : forall a : A, Is_Monotone_Forest a Nil_Forest
  | is_monotone_forest_cons :
      forall (a : A) (t : Tree) (succs : Forest),
      (forall i : I, P a i -> P (root t) i) ->
      Is_Monotone_Tree t ->
      Is_Monotone_Forest a succs ->
      Is_Monotone_Forest a (Cons_Forest t succs).

Lemma is_monotone_tree_successor :
 forall t : Tree,
 Is_Monotone_Tree t ->
 forall t0 : Tree, Successor t0 t -> Is_Monotone_Tree t0.

Inductive Is_Monotone (t : Tree) : Prop :=
    is_monotone_intro :
      (forall t0 : Tree,
       Successor t0 t ->
       forall i : I,
       P (root t0) i -> forall t1 : Tree, Successor t1 t0 -> P (root t1) i) ->
      Is_Monotone t.

Lemma is_monotone_successor :
 forall T : Tree,
 Is_Monotone T -> forall t : Tree, Successor t T -> Is_Monotone t.

Lemma is_monotone_tree_is_monotone :
 forall t : Tree, Is_Monotone_Tree t -> Is_Monotone t.

End Trees. *)
Require Export Derivations.
(* Derivations:
Require Export Forms.

Inductive proof_term : Set :=
  | Var : nat -> proof_term
  | Efq : proof_term -> form -> proof_term
  | Abs : form -> proof_term -> proof_term
  | App : form -> proof_term -> proof_term -> proof_term
  | Pair : proof_term -> proof_term -> proof_term
  | PrL : form -> proof_term -> proof_term
  | PrR : form -> proof_term -> proof_term
  | OrFL : proof_term -> form -> proof_term
  | OrFR : proof_term -> form -> proof_term
  | Cas :
      form -> form -> proof_term -> proof_term -> proof_term -> proof_term
  | Shift : proof_term -> proof_term.

Inductive derives : flist -> proof_term -> form -> Prop :=
  | ByAssumption :
      forall (context : flist) (n : nat) (a : form),
      my_nth form n context a -> derives context (Var n) a
  | ByAbsurdity :
      forall (context : flist) (t : proof_term) (a : form),
      derives context t Falsum -> derives context (Efq t a) a
  | ImpIntro :
      forall (context : flist) (a : form) (r : proof_term) (b : form),
      derives (a :: context) r b -> derives context (Abs a r) (Imp a b)
  | ImpElim :
      forall (context : flist) (r s : proof_term) (a b : form),
      derives context r (Imp a b) ->
      derives context s a -> derives context (App a r s) b
  | AndFIntro :
      forall (context : flist) (r s : proof_term) (a b : form),
      derives context r a ->
      derives context s b -> derives context (Pair r s) (AndF a b)
  | AndFElimL :
      forall (context : flist) (r : proof_term) (a b : form),
      derives context r (AndF a b) -> derives context (PrL b r) a
  | AndFElimR :
      forall (context : flist) (r : proof_term) (a b : form),
      derives context r (AndF a b) -> derives context (PrR a r) b
  | OrFIntroL :
      forall (context : flist) (r : proof_term) (a b : form),
      derives context r a -> derives context (OrFL r b) (OrF a b)
  | OrFIntroR :
      forall (context : flist) (r : proof_term) (a b : form),
      derives context r b -> derives context (OrFR r a) (OrF a b)
  | OrFElim :
      forall (context : flist) (r s t : proof_term) (a b c : form),
      derives context r (OrF a b) ->
      derives (a :: context) s c ->
      derives (b :: context) t c -> derives context (Cas a b r s t) c
  | ShiftIntro :
      forall (context : flist) (r : proof_term) (a b : form),
      derives context r b -> derives (a :: context) (Shift r) b.

Lemma derives_rec :
 forall P : flist -> proof_term -> form -> Set,
 (forall (context : flist) (n : nat) (a : form),
  my_nth form n context a -> P context (Var n) a) ->
 (forall (context : flist) (t : proof_term) (a : form),
  derives context t Falsum -> P context t Falsum -> P context (Efq t a) a) ->
 (forall (context : flist) (a : form) (r : proof_term) (b : form),
  derives (a :: context) r b ->
  P (a :: context) r b -> P context (Abs a r) (Imp a b)) ->
 (forall (context : flist) (r s : proof_term) (a b : form),
  derives context r (Imp a b) ->
  P context r (Imp a b) ->
  derives context s a -> P context s a -> P context (App a r s) b) ->
 (forall (context : flist) (r s : proof_term) (a b : form),
  derives context r a ->
  P context r a ->
  derives context s b -> P context s b -> P context (Pair r s) (AndF a b)) ->
 (forall (context : flist) (r : proof_term) (a b : form),
  derives context r (AndF a b) ->
  P context r (AndF a b) -> P context (PrL b r) a) ->
 (forall (context : flist) (r : proof_term) (a b : form),
  derives context r (AndF a b) ->
  P context r (AndF a b) -> P context (PrR a r) b) ->
 (forall (context : flist) (r : proof_term) (a b : form),
  derives context r a -> P context r a -> P context (OrFL r b) (OrF a b)) ->
 (forall (context : flist) (r : proof_term) (a b : form),
  derives context r b -> P context r b -> P context (OrFR r a) (OrF a b)) ->
 (forall (context : flist) (r s t : proof_term) (a b c : form),
  derives context r (OrF a b) ->
  P context r (OrF a b) ->
  derives (a :: context) s c ->
  P (a :: context) s c ->
  derives (b :: context) t c ->
  P (b :: context) t c -> P context (Cas a b r s t) c) ->
 (forall (context : flist) (r : proof_term) (a b : form),
  derives context r b -> P context r b -> P (a :: context) (Shift r) b) ->
 forall (context : flist) (t : proof_term) (a : form),
 derives context t a -> P context t a. *)

Inductive Kripke_Model (A : Set) (World : A -> Type) 
(le : A -> A -> Type) (forces0 : A -> Int -> Prop) : Type :=
    kripke_model :
      (forall k : A, World k -> le k k) ->
      (forall k0 k1 k2 : A,
       World k0 -> World k1 -> World k2 -> le k0 k1 -> le k1 k2 -> le k0 k2) ->
      (forall k0 k1 : A,
       World k0 ->
       World k1 -> le k0 k1 -> forall i : Int, forces0 k0 i -> forces0 k1 i) ->
      Kripke_Model A World le forces0.

Fixpoint forces (A : Set) (World : A -> Type) 
 (le : A -> A -> Type) (forces0 : A -> Int -> Prop) 
 (k : A) (a : form) {struct a} : Prop :=
  match a with
  | Falsum => False
  | Atom i => forces0 k i
  | AndF a0 a1 =>
      forces A World le forces0 k a0 /\ forces A World le forces0 k a1
  | OrF a0 a1 =>
      forces A World le forces0 k a0 \/ forces A World le forces0 k a1
  | Imp a0 a1 =>
      forall k' : A,
      World k' ->
      le k k' ->
      forces A World le forces0 k' a0 -> forces A World le forces0 k' a1
  end.

Lemma forces_mon :
 forall (A : Set) (World : A -> Type) (le : A -> A -> Type)
   (forces0 : A -> Int -> Prop),
 Kripke_Model A World le forces0 ->
 forall (k : A) (a : form),
 World k ->
 forces A World le forces0 k a ->
 forall k' : A, World k' -> le k k' -> forces A World le forces0 k' a.
intros A World le forces0 kripke k a w; elim a; clear a.

simpl in |- *.
trivial.

intros.
elim kripke.
intros refl trans mon.
simpl in |- *; apply (mon k k'); assumption.

intros a ih_a b ih_b.
simpl in |- *.
intros u0; elim u0; clear u0; intros u0 u1.
intros; split.
apply ih_a; assumption.
apply ih_b; assumption.

intros a ih_a b ih_b.
simpl in |- *.
intros u0; elim u0; clear u0; intros u0.
intros; left.
apply ih_a; assumption.
intros; right.
apply ih_b; assumption.

intros a ih_a b ih_b.
simpl in |- *.
intros.
apply H.
assumption.
elim kripke.
intros refl trans mon.
apply (trans k k' k'0); assumption.
assumption.
Qed.

Lemma soundness :
 forall (t : proof_term) (context : flist) (a : form),
 derives context t a ->
 forall (A : Set) (World : A -> Type) (le : A -> A -> Type)
   (forces0 : A -> Int -> Prop),
 Kripke_Model A World le forces0 ->
 forall k : A,
 World k ->
 (forall c : form, In c context -> forces A World le forces0 k c) ->
 forces A World le forces0 k a.
intros t context a der_t A World le forces0 kripke_model0.
elim der_t; clear der_t t a context.

intros context n a nth k world forces_context.
apply forces_context.
apply nth_in with n; assumption.

intros context r a der_t ih k world forces_context.
elimtype False.
apply (ih k world forces_context).

intros context a r b der_t ih k world forces_context.
simpl in |- *.
intros k' world_k' le_k' forces_a0.
apply (ih k' world_k').
intros c in_c.
inversion_clear in_c.
 rewrite <- H.
assumption.
apply forces_mon with k; try assumption.
apply forces_context; assumption.

intros context r s a b der_r ih_r der_s ih_s k world forces_context.
apply (ih_r k world forces_context k).
assumption.
elim kripke_model0; auto.
apply (ih_s k world forces_context).

intros context r s a b der_r ih_r der_s ih_s k world forces_context.
split.
apply (ih_r k world forces_context).
apply (ih_s k world forces_context).

intros context r a b der_r ih k world forces_context.
generalize (ih k world forces_context).
intros u0; elim u0; intros; assumption.

intros context r a b der_r ih k world forces_context.
generalize (ih k world forces_context).
intros u0; elim u0; intros; assumption.

intros context r a b der_r ih k world forces_context.
left.
apply (ih k world forces_context).

intros context r a b der_r ih k world forces_context.
right.
apply ih; assumption.

intros context r s t a b c der_r ih_r der_s ih_s der_t ih_t k world
 forces_context.
generalize (ih_r k world forces_context); clear ih_r.
intro u0; elim u0; clear u0.
intro forces_a0.
apply ih_s; clear ih_s ih_t.
assumption.
intros c0 in_c0.
inversion_clear in_c0.
 rewrite <- H; assumption.
apply forces_context; assumption.
intros forces_b.
apply ih_t; clear ih_s ih_t.
assumption.
intros c0 in_c0; inversion_clear in_c0.
 rewrite <- H; assumption.
apply forces_context; assumption.

intros context r a b der_r ih k world forces_context.
apply ih.
assumption.
intros c in_c.
apply forces_context.
right; assumption.
Qed.

Lemma forces_b__forces_a_imp_b :
 forall (A : Set) (World : A -> Type) (le : A -> A -> Type)
   (forces0 : A -> Int -> Prop),
 Kripke_Model A World le forces0 ->
 forall k : A,
 World k ->
 forall b : form,
 forces A World le forces0 k b ->
 forall a : form, forces A World le forces0 k (Imp a b).
intros A World le forces0 kripke k w b forces_b.
intros a.
simpl in |- *.
intros k' w' le_k_k' forces_a.
apply forces_mon with (k := k); assumption.
Qed.

Lemma forces_a0_imp_a1_imp_b__forces_a0_and_a1_imp_b :
 forall (A : Set) (World : A -> Type) (le : A -> A -> Type)
   (forces0 : A -> Int -> Prop),
 Kripke_Model A World le forces0 ->
 forall k : A,
 World k ->
 forall a0 a1 b : form,
 forces A World le forces0 k (Imp a0 (Imp a1 b)) ->
 forces A World le forces0 k (Imp (AndF a0 a1) b).
intros A World le forces0 kripke k world a0 a1 b forces_a0_a1_b.
simpl in |- *.
intros k' u0 u1 forces_a0_and_a1.
elim forces_a0_and_a1; clear forces_a0_and_a1.
intros forces_a0 forces_a1.
apply (forces_a0_a1_b k' u0 u1).
apply forces_a0.
apply u0.
elim kripke.
intros refl trans mon.
apply refl.
apply u0.
apply forces_a1.
Qed.

Lemma forces_a0_imp_c_and_a1_imp_c_and_c_imp_b__forces_a0_or_a1_imp_b :
 forall (A : Set) (World : A -> Type) (le : A -> A -> Type)
   (forces0 : A -> Int -> Prop) (k : A) (a0 a1 c b : form),
 forces A World le forces0 k (Imp a0 c) ->
 forces A World le forces0 k (Imp a1 c) ->
 forces A World le forces0 k (Imp c b) ->
 forces A World le forces0 k (Imp (OrF a0 a1) b).
intros A World le forces0 k a0 a1 c b forces_a0_c forces_a1_c forces_c_b.
simpl in |- *.
intros k' u0 u1 forces_a0_or_a1.
elim forces_a0_or_a1; clear forces_a0_or_a1.
intro forces_a0.
apply (forces_c_b k' u0 u1).
apply (forces_a0_c k' u0 u1 forces_a0).
intro forces_a1.
apply (forces_c_b k' u0 u1).
apply (forces_a1_c k' u0 u1 forces_a1).
Qed.

Lemma forces_a0_imp_b_and_a1_imp_b__forces_a0_or_a1_imp_b :
 forall (A : Set) (World : A -> Type) (le : A -> A -> Type)
   (forces0 : A -> Int -> Prop) (k : A) (a0 a1 b : form),
 forces A World le forces0 k (Imp a0 b) ->
 forces A World le forces0 k (Imp a1 b) ->
 forces A World le forces0 k (Imp (OrF a0 a1) b).
intros A World le forces0 k a0 a1 b forces_a0_b forces_a1_b.
simpl in |- *.
intros k' u0 u1 forces_a0_or_a1.
elim forces_a0_or_a1; clear forces_a0_or_a1.
intro forces_a0.
apply (forces_a0_b k' u0 u1 forces_a0).
intro forces_a1.
apply (forces_a1_b k' u0 u1 forces_a1).
Qed.

Lemma forces_a1_imp_b__forces_a0_imp_a1_imp_b :
 forall (A : Set) (World : A -> Type) (le : A -> A -> Type)
   (forces0 : A -> Int -> Prop),
 Kripke_Model A World le forces0 ->
 forall k : A,
 World k ->
 forall a0 : form,
 forces A World le forces0 k a0 ->
 forall a1 b : form,
 forces A World le forces0 k (Imp a1 b) ->
 forces A World le forces0 k (Imp (Imp a0 a1) b).
intros A World le forces0 kripke k w a0 forces_a0 a1 b forces_a1_b.
simpl in |- *.
intros k' w' le_k_k' forces_a0_a1.
apply (forces_a1_b k').
assumption.
assumption.
change (forces A World le forces0 k' a1) in |- *.
apply (forces_a0_a1 k').
assumption.
elim kripke.
intros refl trans mon.
apply refl.
assumption.
apply forces_mon with (k := k); assumption.
Qed.

Lemma forces_a0_imp_a1_imp_b__forces_a1_imp_b :
 forall (A : Set) (World : A -> Type) (le : A -> A -> Type)
   (forces0 : A -> Int -> Prop),
 Kripke_Model A World le forces0 ->
 forall k : A,
 World k ->
 forall a0 : form,
 forces A World le forces0 k a0 ->
 forall a1 b : form,
 forces A World le forces0 k (Imp (Imp a0 a1) b) ->
 forces A World le forces0 k (Imp a1 b).
intros A World le forces0 kripke k w a0 forces_a0 a1 b forces_a0a1_b.
simpl in |- *.
intros k' w' le_k_k' forces_a1.
apply (forces_a0a1_b k').
assumption.
assumption.
change (forces A World le forces0 k' (Imp a0 a1)) in |- *.
simpl in |- *.
intros k'' w'' le'' forces_a0''.
elim kripke.
intros refl trans mon.
apply forces_mon with (k := k'); assumption.
Qed.

Lemma forces_a0_imp_b__forces_a0_and_a1_imp_b :
 forall (A : Set) (World : A -> Type) (le : A -> A -> Type)
   (forces0 : A -> Int -> Prop) (k : A) (a0 b : form),
 forces A World le forces0 k (Imp a0 b) ->
 forall a1 : form, forces A World le forces0 k (Imp (AndF a0 a1) b).
intros A World le forces0 k a0 b forces_a0_b a1.
simpl in |- *.
intros k' w' le_k_k' forces_a0_a1.
apply (forces_a0_b k').
assumption.
assumption.
change (forces A World le forces0 k' a0) in |- *.
elim forces_a0_a1; trivial.
Qed.

Lemma forces_a1_imp_b__forces_a0_and_a1_imp_b :
 forall (A : Set) (World : A -> Type) (le : A -> A -> Type)
   (forces0 : A -> Int -> Prop) (k : A) (a1 b : form),
 forces A World le forces0 k (Imp a1 b) ->
 forall a0 : form, forces A World le forces0 k (Imp (AndF a0 a1) b).
intros A World le forces0 k a1 b forces_a1_b a0.
simpl in |- *.
intros k' w' le_k_k' forces_a0_a1.
apply (forces_a1_b k').
assumption.
assumption.
change (forces A World le forces0 k' a1) in |- *.
elim forces_a0_a1; trivial.
Qed.

Definition atoms := AVL unit.
Definition ANil := AVL_NIL unit.

Definition kripke_tree := Tree atoms.
Definition Kripke_Forest := Forest atoms.
Definition forces0_t (A : atoms) (i : Int) := LOOKUP unit i A tt.

Definition Is_Monotone_kripke_tree := Is_Monotone_Tree atoms Int forces0_t.
Definition Is_Monotone_Kripke_Forest :=
  Is_Monotone_Forest atoms Int forces0_t.

Definition Suc (k0 k1 : kripke_tree) := Successor atoms k0 k1.
Definition Atms (k : kripke_tree) := root atoms k.
Definition Succs (k0 : kripke_tree) := successors atoms k0.

Lemma kripke_tree_kripke_model :
 forall k : kripke_tree,
 Is_Monotone_kripke_tree k ->
 Kripke_Model kripke_tree (fun k0 : kripke_tree => Suc k0 k)
   (fun k0 k1 : kripke_tree => Suc k1 k0)
   (fun (k0 : kripke_tree) (i : Int) => forces0_t (Atms k0) i).
intros.
apply kripke_model.

unfold Suc in |- *.
intros.
apply succs_refl.

unfold Suc in |- *.
intros.
apply succs_trans with (t1 := k1); assumption.

unfold Suc in |- *.
unfold Atms in |- *.
intros k0 k1 suc0 suc1 suc1' i forces_k1.
cut (Is_Monotone atoms Int forces0_t k).
intro is_mon_k.
inversion_clear is_mon_k.
apply H0 with (t0 := k0); assumption.
apply is_monotone_tree_is_monotone.
assumption.
Qed.

Lemma kripke_tree_succ :
 forall K : kripke_tree,
 Is_Monotone_kripke_tree K ->
 forall k : kripke_tree, Suc k K -> Is_Monotone_kripke_tree k.
unfold Is_Monotone_kripke_tree in |- *.
intros K mon k suc.
apply is_monotone_tree_successor with K; assumption.
Qed.

Definition forces_t2 (K k : kripke_tree) (a : form) :=
  forces kripke_tree (fun k0 : kripke_tree => Suc k0 K)
    (fun k0 k1 : kripke_tree => Suc k1 k0)
    (fun (k0 : kripke_tree) (i : Int) => forces0_t (Atms k0) i) k a.

Lemma forces_t2_is_local :
 forall (a : form) (k : kripke_tree),
 Is_Monotone_kripke_tree k ->
 forall k' : kripke_tree,
 Suc k' k ->
 forces_t2 k k' a ->
 forall K : kripke_tree,
 Is_Monotone_kripke_tree K -> Suc k' K -> forces_t2 K k' a.
intros a; elim a; clear a.

unfold forces_t2 in |- *.
simpl in |- *; trivial.

unfold forces_t2 in |- *; simpl in |- *.
trivial.

intros a ih_a b ih_b k mon_k k' suc_k'_k forces_k_k'_ab K mon_K suc_k'_K.
elim forces_k_k'_ab.
fold (forces_t2 k k' a) in |- *.
fold (forces_t2 k k' b) in |- *.
clear forces_k_k'_ab.
intros u0 u1.
split.
change (forces_t2 K k' a) in |- *.
apply ih_a with (k := k); assumption.
change (forces_t2 K k' b) in |- *.
apply ih_b with (k := k); assumption.

intros a ih_a b ih_b k mon_k k' suc_k'_k forces_k_k'_ab K mon_K suc_k'_K.
elim forces_k_k'_ab; clear forces_k_k'_ab.
fold (forces_t2 k k' a) in |- *.
intro u0.
left.
change (forces_t2 K k' a) in |- *.
apply ih_a with (k := k); assumption.
fold (forces_t2 k k' b) in |- *.
intros u0.
right.
change (forces_t2 K k' b) in |- *.
apply ih_b with (k := k); assumption.

intros a ih_a b ih_b.
intros k mon_k k' suc_k'_k forces_k_k'_ab K mon_K suc_k_K. 
unfold forces_t2 in |- *; simpl in |- *.
intros k''.
fold (forces_t2 K k'' a) in |- *.
fold (forces_t2 K k'' b) in |- *.
intros.
apply ih_b with (k := k); clear ih_b.
assumption.
unfold Suc in |- *; apply succs_trans with k'; assumption.
apply (forces_k_k'_ab k''); clear forces_k_k'_ab.
unfold Suc in |- *; apply succs_trans with k'; assumption.
assumption.
change (forces_t2 k k'' a) in |- *.
apply ih_a with (k := K); clear ih_a.
assumption.
assumption.
assumption.
assumption.
unfold Suc in |- *; apply succs_trans with k'; assumption.
assumption.
assumption.
Qed.

Definition forces_t (k : kripke_tree) := forces_t2 k k.

Lemma forces_t_imp :
 forall k : kripke_tree,
 Is_Monotone_kripke_tree k ->
 forall a b : form,
 (forces_t k a -> forces_t k b) ->
 (forall k' : kripke_tree,
  In_Forest atoms k' (Succs k) -> forces_t k' (Imp a b)) ->
 forces_t k (Imp a b).
intros k mon a b forces_a_b foreach_succs.
unfold forces_t in |- *.
unfold forces_t2 in |- *.
simpl in |- *.
intro k'.
fold (forces_t2 k k' a) in |- *.
fold (forces_t2 k k' b) in |- *.
intros suc_k'_k; clear suc_k'_k.
intros suc_k'_k.
inversion_clear suc_k'_k.
assumption.
intro forces_a.
apply forces_t2_is_local with (k := t1).
unfold Is_Monotone_kripke_tree in |- *.
apply is_monotone_tree_successor with k. 
assumption.
apply successor_trans with t1.
assumption.
apply succs_refl.
assumption.
apply (foreach_succs t1 H k').
assumption.
assumption.
change (forces_t2 t1 k' a) in |- *.
apply forces_t2_is_local with (k := k).
assumption.
unfold Suc in |- *; apply successor_trans with t1.
assumption.
assumption.
assumption.
unfold Is_Monotone_kripke_tree in |- *.
apply is_monotone_tree_successor with k.
assumption.
apply successor_trans with t1.
assumption.
apply succs_refl.
assumption.
assumption.
unfold Suc in |- *; apply successor_trans with t1.
assumption.
assumption.
Qed.

Lemma forces_t_mon :
 forall k : kripke_tree,
 Is_Monotone_kripke_tree k ->
 forall a : form,
 forces_t k a -> forall k' : kripke_tree, Suc k' k -> forces_t k' a.
intros k mon a forces_a k' suc.
unfold forces_t in |- *.
apply forces_t2_is_local with (k := k).
assumption.
assumption.
unfold forces_t2 in |- *.
apply forces_mon with (k := k).
apply (kripke_tree_kripke_model k mon).
unfold Suc in |- *; apply succs_refl.
assumption.
assumption.
assumption.
unfold Is_Monotone_kripke_tree in |- *.
apply is_monotone_tree_successor with k.
assumption.
assumption.
unfold Suc in |- *; apply succs_refl.
Qed.

Lemma soundness_t :
 forall (t : proof_term) (context : flist) (a : form),
 derives context t a ->
 forall k : kripke_tree,
 Is_Monotone_kripke_tree k ->
 (forall c : form, In c context -> forces_t k c) -> forces_t k a.
intros t context a der_t k mon forces_context.
unfold forces_t in |- *.
unfold forces_t2 in |- *.
apply soundness with t context.
assumption.
apply (kripke_tree_kripke_model k mon).
unfold Suc in |- *; apply succs_refl.
exact forces_context.
Qed.

Lemma forces_b__forces_a_imp_b_t :
 forall k : kripke_tree,
 Is_Monotone_kripke_tree k ->
 forall b : form, forces_t k b -> forall a : form, forces_t k (Imp a b).
intros k mon b forces_b a.
unfold forces_t in |- *.
unfold forces_t2 in |- *.
apply forces_b__forces_a_imp_b.
apply (kripke_tree_kripke_model k mon).
unfold Suc in |- *; apply succs_refl.
assumption.
Qed.

Lemma forces_a0_imp_a1_imp_b__forces_a0_and_a1_imp_b_t :
 forall k : kripke_tree,
 Is_Monotone_kripke_tree k ->
 forall a0 a1 b : form,
 forces_t k (Imp a0 (Imp a1 b)) -> forces_t k (Imp (AndF a0 a1) b).
intros k mon a0 a1 b forces_a0_a1_b.
unfold forces_t in |- *.
unfold forces_t2 in |- *.
apply forces_a0_imp_a1_imp_b__forces_a0_and_a1_imp_b.
apply (kripke_tree_kripke_model k mon).
unfold Suc in |- *; apply succs_refl.
assumption.
Qed.

Lemma forces_a0_imp_c_and_a1_imp_c_and_c_imp_b__forces_a0_or_a1_imp_b_t :
 forall (k : kripke_tree) (a0 a1 c b : form),
 forces_t k (Imp a0 c) ->
 forces_t k (Imp a1 c) ->
 forces_t k (Imp c b) -> forces_t k (Imp (OrF a0 a1) b).
intros k a0 a1 c b forces_a0_c forces_a1_c forces_c_b.
unfold forces_t in |- *.
unfold forces_t2 in |- *.
apply forces_a0_imp_c_and_a1_imp_c_and_c_imp_b__forces_a0_or_a1_imp_b with c;
 assumption.
Qed.

Lemma forces_a1_imp_b__forces_a0_imp_a1_imp_b_t :
 forall k : kripke_tree,
 Is_Monotone_kripke_tree k ->
 forall a0 : form,
 forces_t k a0 ->
 forall a1 b : form, forces_t k (Imp a1 b) -> forces_t k (Imp (Imp a0 a1) b).
intros k mon a0 forces_a0 a1 b forces_a1_b.
unfold forces_t in |- *.
unfold forces_t2 in |- *.
apply forces_a1_imp_b__forces_a0_imp_a1_imp_b.
apply (kripke_tree_kripke_model k mon).
unfold Suc in |- *; apply succs_refl.
assumption.
assumption.
Qed.

Lemma forces_a0_imp_a1_imp_b__forces_a1_imp_b_t :
 forall k : kripke_tree,
 Is_Monotone_kripke_tree k ->
 forall a0 : form,
 forces_t k a0 ->
 forall a1 b : form, forces_t k (Imp (Imp a0 a1) b) -> forces_t k (Imp a1 b).
intros k mon a0 forces_a0 a1 b forces_a0a1_b.
unfold forces_t in |- *.
unfold forces_t2 in |- *.
apply forces_a0_imp_a1_imp_b__forces_a1_imp_b with a0.
apply (kripke_tree_kripke_model k mon).
unfold Suc in |- *; apply succs_refl.
assumption.
assumption.
Qed.

Lemma forces_a0_imp_b__forces_a0_and_a1_imp_b_t :
 forall (k : kripke_tree) (a0 b : form),
 forces_t k (Imp a0 b) -> forall a1 : form, forces_t k (Imp (AndF a0 a1) b).
intros k a0 b forces_a0_b a1.
unfold forces_t in |- *.
unfold forces_t2 in |- *.
apply forces_a0_imp_b__forces_a0_and_a1_imp_b.
assumption.
Qed.

Lemma forces_a1_imp_b__forces_a0_and_a1_imp_b_t :
 forall (k : kripke_tree) (a1 b : form),
 forces_t k (Imp a1 b) -> forall a0 : form, forces_t k (Imp (AndF a0 a1) b).
intros k a1 b forces_a1_b a0.
unfold forces_t in |- *.
unfold forces_t2 in |- *.
apply forces_a1_imp_b__forces_a0_and_a1_imp_b.
assumption.
Qed.

Lemma forces_a_a_imp_b__forces_b_t :
 forall (k : kripke_tree) (a b : form),
 forces_t k a -> forces_t k (Imp a b) -> forces_t k b.
intros k a b forces_a forces_ab.
apply (forces_ab k).
unfold Suc in |- *; apply successor_refl.
unfold Suc in |- *; apply successor_refl.
assumption.
Qed.

Lemma forces_a_imp_b0_a_imp_b1__forces_a_imp_a0_and_a1 :
 forall (a b0 b1 : form) (k : kripke_tree),
 forces_t k (Imp a b0) ->
 forces_t k (Imp a b1) -> forces_t k (Imp a (AndF b0 b1)).
intros a b0 b1 k forces_ab0 forces_ab1.
unfold forces_t in |- *; unfold forces_t2 in |- *; simpl in |- *.
intros k' suc_k' suc_k''.
change (forces_t2 k k' a -> forces_t2 k k' b0 /\ forces_t2 k k' b1) in |- *.
intros forces_a.
split.
apply (forces_ab0 k'); assumption.
apply (forces_ab1 k'); assumption.
Qed.

Lemma forces_a_imp_b__forces_a_imp_falsum_or_b :
 forall (k : kripke_tree) (a b : form),
 forces_t k (Imp a b) -> forces_t k (Imp a (OrF Falsum b)).
intros k a b forces_ab.
unfold forces_t in |- *; unfold forces_t2 in |- *; simpl in |- *.
intros k' suc_k' suc_k''.
change (forces_t2 k k' a -> False \/ forces_t2 k k' b) in |- *.
intros forces_a; right.
apply (forces_ab k'); assumption.
Qed.

Lemma forces_a_imp_b__forces_a_imp_b_or_falsum :
 forall (k : kripke_tree) (a b : form),
 forces_t k (Imp a b) -> forces_t k (Imp a (OrF b Falsum)).
intros k a b forces_ab.
unfold forces_t in |- *; unfold forces_t2 in |- *; simpl in |- *.
intros k' suc_k' suc_k''.
change (forces_t2 k k' a -> forces_t2 k k' b \/ False) in |- *.
intros forces_a; left.
apply (forces_ab k'); assumption.
Qed.

Lemma forces_a_imp_falsum_imp_b1_t :
 forall (k : kripke_tree) (a b1 : form), forces_t k (Imp a (Imp Falsum b1)).
unfold forces_t in |- *; unfold forces_t2 in |- *; simpl in |- *.
intros; elimtype False; assumption.
Qed.

Lemma forces_a_imp_b_imp_c__forces_a_imp_falsum_imp_c :
 forall (k : kripke_tree) (a b c : form),
 forces_t k (Imp (Imp a b) c) -> forces_t k (Imp (Imp a Falsum) c).
intros k a b c forces_abc.
unfold forces_t in |- *; unfold forces_t2 in |- *; simpl in |- *.
intros k' suc_k' suc_k''.
change (forces_t2 k k' (Imp a Falsum) -> forces_t2 k k' c) in |- *.
intros forces1.
apply (forces_abc k'); try assumption.
intros k'' suc3 suc4 forces_a.
elimtype False.
apply (forces1 k''); assumption.
Qed.

Lemma forces_vimp :
 forall (k : kripke_tree) (l : list Int) (a b : form),
 (forall k' : kripke_tree, Suc k' k -> forces_t2 k k' a -> forces_t2 k k' b) ->
 forces_t k (vimp l a) -> forces_t k (vimp l b).
intros k l.
elim l; clear l.
intros a b forces_ab forces_a.
apply forces_ab with (k' := k); try assumption.
unfold Suc in |- *; apply successor_refl.
simpl in |- *; intros i l ih a b forces_ab forces_a.
apply ih with (a := Imp (Atom i) a); try assumption.
intros k' suc1 forces_ia.
unfold forces_t in |- *; unfold forces_t2 in |- *; simpl in |- *.
intros k'' suc2 suc3 forces_i.
change (forces_t2 k k'' b) in |- *.
apply forces_ab.
assumption.
apply (forces_ia k''); assumption.
Qed.

Lemma forces_vimp2 :
 forall (k : kripke_tree) (l : list Int) (a b c : form),
 (forall k' : kripke_tree,
  Suc k' k -> forces_t2 k k' a -> forces_t2 k k' b -> forces_t2 k k' c) ->
 forces_t k (vimp l a) -> forces_t k (vimp l b) -> forces_t k (vimp l c).
intros k l.
elim l; clear l.
intros a b c forces_abc forces_a forces_b.
apply forces_abc with (k' := k); try assumption.
unfold Suc in |- *; apply successor_refl.
simpl in |- *; intros i l ih a b c forces_abc forces_a forces_b.
apply ih with (a := Imp (Atom i) a) (b := Imp (Atom i) b); try assumption.
intros k' suc1 forces_ia forces_ib.
unfold forces_t in |- *; unfold forces_t2 in |- *; simpl in |- *.
intros k'' suc2 suc3 forces_i.
change (forces_t2 k k'' c) in |- *.
apply forces_abc.
assumption.
apply (forces_ia k''); assumption.
apply (forces_ib k''); assumption.
Qed.

Lemma forces_vimp0 :
 forall (k : kripke_tree) (l : list Int) (b : form),
 (forall k' : kripke_tree, Suc k' k -> forces_t2 k k' b) ->
 forces_t k (vimp l b).
intros k l.
elim l; clear l.
intros b forces_ab.
apply forces_ab with (k' := k); try assumption.
unfold Suc in |- *; apply successor_refl.
simpl in |- *; intros i l ih b forces_ab.
apply ih.
intros k' suc1.
unfold forces_t in |- *; unfold forces_t2 in |- *; simpl in |- *.
intros k'' suc2 suc3 forces_i.
change (forces_t2 k k'' b) in |- *.
apply forces_ab.
assumption.
Qed.

Lemma forces_a_imp_b_imp_c__forces_a_imp_falsum_imp_c_t2 :
 forall (k k' : kripke_tree) (a b c : form),
 Suc k' k ->
 forces_t2 k k' (Imp (Imp a b) c) -> forces_t2 k k' (Imp (Imp a Falsum) c).
intros k k' a b c suc1 forces_abc.
unfold forces_t in |- *; unfold forces_t2 in |- *; simpl in |- *.
intros k'' suc_k' suc_k''.
change (forces_t2 k k'' (Imp a Falsum) -> forces_t2 k k'' c) in |- *.
intros forces1.
apply (forces_abc k''); try assumption.
intros k''' suc3 suc4 forces_a.
elimtype False.
apply (forces1 k'''); assumption.
Qed.
