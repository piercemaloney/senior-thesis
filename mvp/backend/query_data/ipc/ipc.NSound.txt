
Require Export Le_Ks.
(* Le_Ks:
Require Export Rev_App.

Inductive le_ni : nested_imps -> nested_imps -> Prop :=
  | Le_NI_Nil : le_ni NNil NNil
  | Le_NI_Cons_NN :
      forall (x : nimp) (ni1 ni2 : nested_imps),
      le_ni ni1 ni2 -> le_ni (Undecorated x :: ni1) (Undecorated x :: ni2)
  | Le_NI_Cons_DN :
      forall (x : nimp) (k : kripke_tree) (ni1 ni2 : nested_imps),
      le_ni ni1 ni2 -> le_ni (Decorated x k :: ni1) (Undecorated x :: ni2)
  | Le_NI_Cons_DD :
      forall (x : nimp) (k : kripke_tree) (ni1 ni2 : nested_imps),
      le_ni ni1 ni2 -> le_ni (Decorated x k :: ni1) (Decorated x k :: ni2).

Lemma in_k_le :
 forall (ni1 ni2 : nested_imps) (x : nimp) (k : kripke_tree),
 le_ni ni1 ni2 -> In (Decorated x k) ni2 -> In (Decorated x k) ni1.

Lemma le_ni_refl : forall ni : nested_imps, le_ni ni ni.

Lemma le_ni_trans :
 forall ni1 ni2 ni3 : nested_imps,
 le_ni ni1 ni2 -> le_ni ni2 ni3 -> le_ni ni1 ni3.

Inductive filter_deco_spec (i : Int) (N : nested_imps) : Set :=
    Filter_Deco_Spec_Intro :
      forall ni1 : nested_imps,
      le_ni N ni1 ->
      (forall (x : nimp) (k : kripke_tree),
       In (Decorated x k) ni1 -> forces_t k (Atom i)) -> 
      filter_deco_spec i N.

Lemma filter_deco :
 forall (i : Int) (ni : nested_imps), filter_deco_spec i ni.

Inductive eqv_ni : nested_imps -> nested_imps -> Prop :=
  | Eqv_NI_Nil : eqv_ni NNil NNil
  | Eqv_NI_Cons_NN :
      forall (x : nimp) (ni1 ni2 : nested_imps),
      eqv_ni ni1 ni2 -> eqv_ni (Undecorated x :: ni1) (Undecorated x :: ni2)
  | Eqv_NI_Cons_DN :
      forall (x : nimp) (k : kripke_tree) (ni1 ni2 : nested_imps),
      eqv_ni ni1 ni2 -> eqv_ni (Decorated x k :: ni1) (Undecorated x :: ni2)
  | Eqv_NI_Cons_DD :
      forall (x : nimp) (k k' : kripke_tree) (ni1 ni2 : nested_imps),
      eqv_ni ni1 ni2 -> eqv_ni (Decorated x k :: ni1) (Decorated x k' :: ni2)
  | Eqv_NI_Cons_ND :
      forall (x : nimp) (k : kripke_tree) (ni1 ni2 : nested_imps),
      eqv_ni ni1 ni2 -> eqv_ni (Undecorated x :: ni1) (Decorated x k :: ni2).

Lemma eqv_ni_trans :
 forall ni1 ni2 ni3 : nested_imps,
 eqv_ni ni1 ni2 -> eqv_ni ni2 ni3 -> eqv_ni ni1 ni3.

Lemma le_eqv : forall ni1 ni2 : nested_imps, le_ni ni1 ni2 -> eqv_ni ni1 ni2.

Lemma eqv_sym :
 forall ni1 ni2 : nested_imps, eqv_ni ni1 ni2 -> eqv_ni ni2 ni1.

Lemma ge_eqv : forall ni1 ni2 : nested_imps, le_ni ni2 ni1 -> eqv_ni ni1 ni2.

Lemma eqv_ni_rec :
 forall P : nested_imps -> nested_imps -> Set,
 P NNil NNil ->
 (forall (x : nimp) (ni1 ni2 : nested_imps),
  eqv_ni ni1 ni2 ->
  P ni1 ni2 -> P (Undecorated x :: ni1) (Undecorated x :: ni2)) ->
 (forall (x : nimp) (k : kripke_tree) (ni1 ni2 : nested_imps),
  eqv_ni ni1 ni2 ->
  P ni1 ni2 -> P (Decorated x k :: ni1) (Undecorated x :: ni2)) ->
 (forall (x : nimp) (k k' : kripke_tree) (ni1 ni2 : nested_imps),
  eqv_ni ni1 ni2 ->
  P ni1 ni2 -> P (Decorated x k :: ni1) (Decorated x k' :: ni2)) ->
 (forall (x : nimp) (k : kripke_tree) (ni1 ni2 : nested_imps),
  eqv_ni ni1 ni2 ->
  P ni1 ni2 -> P (Undecorated x :: ni1) (Decorated x k :: ni2)) ->
 forall ni1 ni2 : nested_imps, eqv_ni ni1 ni2 -> P ni1 ni2.

Inductive inf_deco_spec (ni1 ni2 : nested_imps) : Set :=
    Inf_Deco_Spec_Intro :
      forall ni : nested_imps,
      le_ni ni ni1 ->
      eqv_ni ni ni2 ->
      (forall (x : nimp) (k : kripke_tree),
       In (Decorated x k) ni ->
       In (Decorated x k) ni1 \/ In (Decorated x k) ni2) ->
      inf_deco_spec ni1 ni2.

Lemma inf_deco :
 forall ni1 ni2 : nested_imps, eqv_ni ni1 ni2 -> inf_deco_spec ni1 ni2.

Remark eqv_nimps_eq :
 forall ni1 ni2 : nested_imps,
 eqv_ni ni1 ni2 -> nested_imps2nimps ni1 = nested_imps2nimps ni2.

Lemma in_ngamma_eqv :
 forall (work : nf_list) (ds : disjs) (ni1 ni2 : nested_imps)
   (ai : atomic_imps) (a : atoms) (c : normal_form),
 eqv_ni ni1 ni2 ->
 in_ngamma work ds ni1 ai a c -> in_ngamma work ds ni2 ai a c.

Lemma in_ngamma_le :
 forall (work : nf_list) (ds : disjs) (ni1 ni2 : nested_imps)
   (ai : atomic_imps) (a : atoms) (c : normal_form),
 le_ni ni1 ni2 ->
 in_ngamma work ds ni1 ai a c -> in_ngamma work ds ni2 ai a c.

Lemma in_ngamma_ge :
 forall (work : nf_list) (ds : disjs) (ni1 ni2 : nested_imps)
   (ai : atomic_imps) (a : atoms) (c : normal_form),
 le_ni ni2 ni1 ->
 in_ngamma work ds ni1 ai a c -> in_ngamma work ds ni2 ai a c.

Inductive le_app_spec (ni1 : nested_imps) (n : nat) : Set :=
    Le_App_Spec_Intro :
      forall ni11 ni12 : nested_imps,
      ni1 = ni11 ++ ni12 -> length ni11 = n -> le_app_spec ni1 n.

Lemma le_app0 :
 forall ni1 ni21 ni22 : nested_imps,
 le_ni ni1 (ni21 ++ ni22) -> le_app_spec ni1 (length ni21).

Lemma le_ni_app_nn :
 forall (ni1 ni2 ni3 ni4 : nested_imps) (x : nimp),
 length ni1 = length ni3 ->
 le_ni (ni1 ++ ni2) (ni3 ++ ni4) ->
 le_ni (ni1 ++ Undecorated x :: ni2) (ni3 ++ Undecorated x :: ni4).

Lemma le_ni_app_dn :
 forall (ni1 ni2 ni3 ni4 : nested_imps) (x : nimp) (k : kripke_tree),
 length ni1 = length ni3 ->
 le_ni (ni1 ++ ni2) (ni3 ++ ni4) ->
 le_ni (ni1 ++ Decorated x k :: ni2) (ni3 ++ Undecorated x :: ni4).

Lemma le_ni_app_dd :
 forall (ni1 ni2 ni3 ni4 : nested_imps) (x : nimp) (k : kripke_tree),
 length ni1 = length ni3 ->
 le_ni (ni1 ++ ni2) (ni3 ++ ni4) ->
 le_ni (ni1 ++ Decorated x k :: ni2) (ni3 ++ Decorated x k :: ni4). *)
Require Export Derivable_Tools.
(* Derivable_Tools:
Require Export Derivable_Def.

Lemma derivable_eq :
 forall (context context' : flist) (a a' : form),
 context = context' -> a = a' -> Derivable context a -> Derivable context' a'.

Lemma derivable_subst :
 forall (i : Int) (g : form) (context : flist) (a : form),
 Derivable context a -> Derivable (subst_list i g context) (subst_form i g a).

Lemma snd_order_inst :
 forall (context : flist) (i : Int),
 Derivable context (Atom i) ->
 below_list context i -> forall b : form, Derivable context b.

Lemma derivable_weak :
 forall (context : flist) (a b : form),
 Derivable context a -> Derivable (b :: context) a.

Lemma derivable_weak_list :
 forall (context1 context2 : flist) (a : form),
 Derivable context1 a -> Derivable (context2 ++ context1) a.

Lemma derivable_cut_aux :
 forall (context : flist) (t : proof_term) (b : form),
 derives context t b ->
 forall (a : form) (l1 l2 : flist),
 context = l1 ++ a :: l2 -> Derivable fnil a -> Derivable (l1 ++ l2) b.

Lemma derivable_cut :
 forall (context : flist) (a b : form),
 Derivable fnil a -> Derivable (a :: context) b -> Derivable context b.

Lemma derivable_cut_merge :
 forall (context : flist) (a b : form),
 Derivable context a -> Derivable (a :: context) b -> Derivable context b.

Lemma derivable_a_imp_a : forall a : form, Derivable fnil (Imp a a).

Lemma derivable_a_and_b__derivable_a :
 forall (a b : form) (context : flist),
 Derivable context (AndF a b) -> Derivable context a.

Lemma derivable_a_and_b__derivable_b :
 forall (a b : form) (context : flist),
 Derivable context (AndF a b) -> Derivable context b.

Lemma derivable_falsum_or_a__derivable_a :
 forall (a : form) (context : flist),
 Derivable context (OrF Falsum a) -> Derivable context a.

Lemma derivable_a_or_falsum__derivable_a :
 forall (a : form) (context : flist),
 Derivable context (OrF a Falsum) -> Derivable context a.

Lemma derivable_a_imp_falsum_or_b__derivable_a_imp_b :
 forall (context : flist) (a b : form),
 Derivable context (Imp a (OrF Falsum b)) -> Derivable context (Imp a b).

Lemma derivable_a_imp_b_or_falsum__derivable_a_imp_b :
 forall (context : flist) (a b : form),
 Derivable context (Imp a (OrF b Falsum)) -> Derivable context (Imp a b).

Lemma derivable_a0_and_a1_imp_b__derivable_a0_imp_a1_imp_b :
 forall (a0 a1 b : form) (context : flist),
 Derivable context (Imp (AndF a0 a1) b) ->
 Derivable context (Imp a0 (Imp a1 b)).

Lemma derivable_a0_or_a1_imp_b__derivable_a0_imp_b :
 forall (context : flist) (a0 a1 b : form),
 Derivable context (Imp (OrF a0 a1) b) -> Derivable context (Imp a0 b).

Lemma derivable_a0_or_a1_imp_b__derivable_a1_imp_b :
 forall (context : flist) (a0 a1 b : form),
 Derivable context (Imp (OrF a0 a1) b) -> Derivable context (Imp a1 b).

Lemma derivable_falsum_imp_b_imp_c__derivable_c :
 forall (context : flist) (b c : form),
 Derivable context (Imp (Imp Falsum b) c) -> Derivable context c.

Lemma derivable_b__derivable_a_imp_b :
 forall (a b : form) (context : flist),
 Derivable context b -> Derivable context (Imp a b).

Lemma derivable_a_a_imp_b__derivable_b :
 forall (a b : form) (context : flist),
 Derivable context a -> Derivable context (Imp a b) -> Derivable context b.

Lemma derivable_a_context_b__derivable_a_imp_b :
 forall (a b : form) (context : flist),
 Derivable (a :: context) b -> Derivable context (Imp a b).

Lemma derivable_vimp :
 forall (context : flist) (l : list Int) (a b : form),
 (forall context : flist, Derivable context a -> Derivable context b) ->
 Derivable context (vimp l a) -> Derivable context (vimp l b).

Lemma derivable_vimp2 :
 forall (context : flist) (l : list Int) (a b c : form),
 (forall context : flist,
  Derivable context a -> Derivable context b -> Derivable context c) ->
 Derivable context (vimp l a) ->
 Derivable context (vimp l b) -> Derivable context (vimp l c).

Lemma derivable_vimp0 :
 forall (context : flist) (l : list Int) (a : form),
 (forall context : flist, Derivable context a) ->
 Derivable context (vimp l a). *)

Definition nsound (work : nf_list) (ds : disjs) (ni : nested_imps)
  (ai : atomic_imps) (a : atoms) (context : flist) :=
  forall c : normal_form,
  in_ngamma work ds ni ai a c -> Derivable context (nf2form c).

Lemma nsound_eqv :
 forall (work : nf_list) (ds : disjs) (ni1 ni2 : nested_imps)
   (ai : atomic_imps) (a : atoms) (context : flist),
 eqv_ni ni1 ni2 ->
 nsound work ds ni1 ai a context -> nsound work ds ni2 ai a context.
intros work ds ni1 ni2 ai a context eq12 sound.
unfold nsound in |- *.
intros c in_ngamma.
apply sound.
apply in_ngamma_eqv with ni2. 
apply eqv_sym; assumption.
assumption.
Qed.

Lemma nsound_le :
 forall (work : nf_list) (ds : disjs) (ni1 ni2 : nested_imps)
   (ai : atomic_imps) (a : atoms) (context : flist),
 le_ni ni1 ni2 ->
 nsound work ds ni1 ai a context -> nsound work ds ni2 ai a context.
intros work ds ni1 ni2 ai a context le sound.
unfold nsound in |- *.
intros c in_ngamma.
apply sound.
apply in_ngamma_ge with ni2; assumption.
Qed.

Lemma nsound_ge :
 forall (work : nf_list) (ds : disjs) (ni1 ni2 : nested_imps)
   (ai : atomic_imps) (a : atoms) (context : flist),
 le_ni ni2 ni1 ->
 nsound work ds ni1 ai a context -> nsound work ds ni2 ai a context.
intros work ds ni1 ni2 ai a context le sound.
unfold nsound in |- *.
intros c in_ngamma.
apply sound.
apply in_ngamma_le with ni2; assumption.
Qed.

Lemma nsound_shift_work_ds :
 forall (i j : Int) (work : nf_list) (ds : disjs) (ni : nested_imps)
   (ai : atomic_imps) (a : atoms) (context : flist),
 nsound (NDisj i j :: work) ds ni ai a context ->
 nsound work ((i, j) :: ds) ni ai a context.
intros i j work ds ni ai a context sound.
unfold nsound in |- *.
intros c in_ngamma.
apply sound.
apply in_ngamma_shift_ds_work; assumption.
Qed.

Lemma nsound_shift_work_ni :
 forall (x : nested_imp) (work : nf_list) (ds : disjs) 
   (ni : nested_imps) (ai : atomic_imps) (a : atoms) 
   (context : flist),
 nsound (NImp_NF (nested_imp2nimp x) :: work) ds ni ai a context ->
 nsound work ds (x :: ni) ai a context.
intros x work ds ni ai a context sound.
unfold nsound in |- *.
intros c in_ngamma.
apply sound.
apply in_ngamma_shift_ni_work; assumption.
Qed.

Lemma nsound_shift_work_ai :
 forall (i : Int) (b : normal_form) (work : nf_list) 
   (ds : disjs) (ni : nested_imps) (ai ai' : atomic_imps) 
   (a : atoms) (context : flist),
 EQUIV_INS nf_list i (cons b) nf_nil ai ai' ->
 nsound (AImp i b :: work) ds ni ai a context ->
 nsound work ds ni ai' a context.
intros i b work ds ni ai ai' a context equiv_ins sound.
unfold nsound in |- *.
intros c in_ngamma.
apply sound.
apply in_ngamma_shift_ai_work with ai'; assumption.
Qed.

Lemma nsound_shift_work_a :
 forall (i : Int) (work : nf_list) (ds : disjs) (ni : nested_imps)
   (ai : atomic_imps) (a a' : atoms) (context : flist),
 EQUIV_INS unit i (fun _ : unit => tt) tt a a' ->
 nsound (NAtom i :: work) ds ni ai a context ->
 nsound work ds ni ai a' context.
intros i work ds ni ai a a' context equiv_ins sound.
unfold nsound in |- *.
intros c in_ngamma.
apply sound.
apply in_ngamma_shift_a_work with a'; assumption.
Qed.

Lemma nsound_shift_work_ni_x_ni :
 forall (x : nested_imp) (work : nf_list) (ds : disjs)
   (ni1 ni2 : nested_imps) (ai : atomic_imps) (a : atoms) 
   (context : flist),
 nsound (NImp_NF (nested_imp2nimp x) :: work) ds (ni1 ++ ni2) ai a context ->
 nsound work ds (ni1 ++ x :: ni2) ai a context.
intros x work ds ni1 ni2 ai a context sound.
unfold nsound in |- *.
intros c in_ngamma.
apply sound.
apply in_ngamma_shift_ni_x_ni_work; assumption.
Qed.

Lemma nsound_shift_ni_x_ni_work :
 forall (x : nested_imp) (work : nf_list) (ds : disjs)
   (ni1 ni2 : nested_imps) (ai : atomic_imps) (a : atoms) 
   (context : flist),
 nsound work ds (ni1 ++ x :: ni2) ai a context ->
 nsound (NImp_NF (nested_imp2nimp x) :: work) ds (ni1 ++ ni2) ai a context.
intros x work ds ni1 ni2 ai a context sound.
unfold nsound in |- *.
intros c in_ngamma.
apply sound.
apply in_ngamma_shift_work_ni_x_ni; assumption.
Qed.

Remark nsound_app_work :
 forall (bs work : nf_list) (ds : disjs) (ni : nested_imps)
   (ai : atomic_imps) (a : atoms) (context : flist),
 (forall (n : nat) (b : normal_form),
  my_nth normal_form n bs b -> Derivable context (nf2form b)) ->
 nsound work ds ni ai a context -> nsound (bs ++ work) ds ni ai a context.
intros bs work ds ni ai a context der_bs sound.
unfold nsound in |- *.
intros c in_ngamma.
elim (in_ngamma_work_app_rev bs work ds ni ai a c in_ngamma); clear in_ngamma.
intros in_ngamma.
apply sound; assumption.
intros nth; elim nth; clear nth.
intros n nth.
apply der_bs with n; assumption.
Qed.

Lemma nsound_cons_ds_tail :
 forall (work : nf_list) (i j : Int) (ds : disjs) (ni : nested_imps)
   (ai : atomic_imps) (a : atoms) (context : flist),
 nsound work ((i, j) :: ds) ni ai a context -> nsound work ds ni ai a context.
intros work i j ds ni ai a context sound.
unfold nsound in |- *.
intros c in_ngamma.
apply sound.
apply in_ngamma_cons_ds_tail; assumption.
Qed.

Remark nsound_del_ai :
 forall (i : Int) (work : nf_list) (ds : disjs) (ni : nested_imps)
   (ai ai' : atomic_imps) (a : atoms) (context : flist),
 EQUIV_DEL nf_list i ai ai' ->
 nsound work ds ni ai a context -> nsound work ds ni ai' a context.
intros i work ds ni ai ai' a context equiv_del sound.
unfold nsound in |- *.
intros c in_ngamma.
apply sound.
apply in_ngamma_del_ai_tail with i ai'; assumption.
Qed.

Lemma nsound_cons_work_cons_context :
 forall (c : normal_form) (work : nf_list) (ds : disjs) 
   (ni : nested_imps) (ai : atomic_imps) (a : atoms) 
   (context : flist),
 nsound work ds ni ai a context ->
 nsound (c :: work) ds ni ai a (nf2form c :: context).
intros c work ds ni ai a context sound.
unfold nsound in |- *.
intros c0 in_gamma.
elim (in_ngamma_cons_work_rev c work ds ni ai a c0 in_gamma); clear in_gamma.
intros in_gamma.
apply derivable_weak.
apply sound; assumption.
intros eq;  rewrite eq; clear eq.
apply Derivable_Intro with (Var 0).
apply ByAssumption.
apply My_NthO.
Qed.

Lemma nsound_cons_work_weak :
 forall (b c : normal_form) (work : nf_list) (ds : disjs) 
   (ni : nested_imps) (ai : atomic_imps) (a : atoms) 
   (context : flist),
 (Derivable context (nf2form b) -> Derivable context (nf2form c)) ->
 nsound (b :: work) ds ni ai a context ->
 nsound (c :: work) ds ni ai a context.
intros b c work ds ni ai a context der_ab sound.
unfold nsound in |- *.
intros c0 in_ngamma.
elim (in_ngamma_cons_work_rev c work ds ni ai a c0 in_ngamma);
 clear in_ngamma.
intros in_ngamma.
apply sound.
apply in_ngamma_cons_work_tail; assumption.
intros eq;  rewrite eq; clear eq c0.
apply der_ab.
apply sound.
apply in_ngamma_cons_work_head.
Qed.

Lemma nsound_shift_work_ai_strength :
 forall (i : Int) (bs work : nf_list) (ds : disjs) 
   (ni : nested_imps) (ai ai' : atomic_imps) (a a' : atoms) 
   (context : flist),
 EQUIV_INS unit i (fun _ : unit => tt) tt a a' ->
 LOOKUP nf_list i ai bs ->
 EQUIV_DEL nf_list i ai ai' ->
 nsound work ds ni ai a' context -> nsound (bs ++ work) ds ni ai' a' context.
intros i bs work ds ni ai ai' a a' context equiv_ins lookup equiv_del sound.
apply nsound_app_work; try assumption.
intros n b nth.
apply derivable_a_a_imp_b__derivable_b with (Atom i).
apply sound with (c := NAtom i).
apply in_ngamma_ins_a_head with a; assumption.
apply sound with (c := AImp i b).
apply In_Atomic_Imps with (i := i) (b := b) (n := n) (bs := bs); assumption.
apply nsound_del_ai with i ai; assumption.
Qed.

