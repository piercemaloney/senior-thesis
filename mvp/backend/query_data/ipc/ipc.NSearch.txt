
Require Export Disjunct.
(* Disjunct:
Require Export In_NGamma.

Definition a_ai_disj (a : atoms) (ai : atomic_imps) :=
  forall i : Int,
  LOOKUP unit i a tt -> forall bs : nf_list, LOOKUP nf_list i ai bs -> False.

Definition a_goal_disj (a : atoms) (goal : Int) :=
  LOOKUP unit goal a tt -> False.

Lemma disjs_insert_ai :
 forall (i : Int) (b : normal_form) (a : atoms) (ai ai' : atomic_imps),
 a_ai_disj a ai ->
 (forall d : unit, ~ LOOKUP unit i a d) ->
 EQUIV_INS nf_list i (cons b) nf_nil ai ai' -> a_ai_disj a ai'.

Lemma disjs_delete_ai :
 forall (i : Int) (a a' : atoms) (ai ai' : atomic_imps),
 a_ai_disj a ai ->
 EQUIV_INS unit i (fun _ : unit => tt) tt a a' ->
 EQUIV_DEL nf_list i ai ai' -> a_ai_disj a' ai'.

Lemma goal_disj_insert_a :
 forall (i goal : Int) (a a' : atoms),
 a_goal_disj a goal ->
 (Equal goal i -> False) ->
 EQUIV_INS unit i (fun _ : unit => tt) tt a a' -> a_goal_disj a' goal.

Lemma disjs_insert_a :
 forall (i : Int) (a a' : atoms) (ai : atomic_imps),
 a_ai_disj a ai ->
 EQUIV_INS unit i (fun _ : unit => tt) tt a a' ->
 (forall bs : nf_list, ~ LOOKUP nf_list i ai bs) -> a_ai_disj a' ai. *)
Require Export NWeight.
(* NWeight:
Require Export Lt.
Require Export Le.
Require Export Regular_Avl.
Require Export Le_Ks.

Fixpoint nweight (a : form) : nat :=
  match a with
  | Atom _ => 0
  | Falsum => 0
  | AndF a0 a1 => S (nweight a0 + nweight a1)
  | OrF a0 a1 => S (nweight a0 + nweight a1)
  | Imp a0 a1 => S (nweight a0 + nweight a1)
  end.

Definition nweight_work :=
  fold_right (fun (a : normal_form) (n : nat) => nweight (nf2form a) + n) 0.

Remark nweight_work_app :
 forall bs work : nf_list,
 nweight_work (bs ++ work) = nweight_work bs + nweight_work work.

Definition nweight_disj (d : disj) := nweight (disj2form d).
Definition nweight_ds :=
  fold_right (fun (d : disj) (n : nat) => nweight_disj d + n) 0.

Definition nweight_nestedimp (x : nested_imp) := nweight (nested_imp2form x).
Definition nweight_ni :=
  fold_right (fun (x : nested_imp) (n : nat) => nweight_nestedimp x + n) 0.

Definition nweight_decoratednestedimp (x : decorated_nested_imp) :=
  match x with
  | (x0, _) => nweight (nimp2form x0)
  end.

Definition nweight_dni :=
  fold_right
    (fun (x : decorated_nested_imp) (n : nat) =>
     nweight_decoratednestedimp x + n) 0.

Definition nweight_atomicimp (a : normal_form) := S (nweight (nf2form a)).
Definition nweight_bs :=
  fold_right (fun (b : normal_form) (n : nat) => nweight_atomicimp b + n) 0.
Definition nweight_ibs (x : Int * nf_list) :=
  match x with
  | (_, bs) => nweight_bs bs
  end.

Definition nweight_ai (ai : atomic_imps) :=
  fold_right (fun (x : Int * nf_list) (n : nat) => nweight_ibs x + n) 0
    (LIN_AVL nf_list ai).

Remark nweight_ai_perm :
 forall (l0 l1 : list (Int * nf_list)) (x : Int * nf_list),
 fold_right (fun (x : Int * nf_list) (n : nat) => nweight_ibs x + n) 0
   (l0 ++ x :: l1) =
 fold_right (fun (x : Int * nf_list) (n : nat) => nweight_ibs x + n) 0
   (x :: l0 ++ l1).

Remark nweight_ai_ins :
 forall (i : Int) (b : normal_form) (ai ai' : atomic_imps),
 LIN_INS nf_list i (cons b) nf_nil ai ai' ->
 nweight (nf2form (AImp i b)) + nweight_ai ai = nweight_ai ai'.

Remark nweight_ai_del :
 forall (i : Int) (bs : nf_list) (ai ai' : atomic_imps),
 REGULAR normal_form ai ->
 LOOKUP nf_list i ai bs ->
 LIN_DEL nf_list i bs ai ai' ->
 nweight_work bs + nweight_ai ai' < nweight_ai ai.

Remark nweight_eqv_ni :
 forall ni1 ni2 : nested_imps,
 eqv_ni ni1 ni2 -> nweight_ni ni1 = nweight_ni ni2.

Remark nweight_rev_app :
 forall (dni : decorated_nested_imps) (ni : nested_imps),
 nweight_ni ni + nweight_dni dni = nweight_ni (rev_app dni ni).

Definition nweight_Sequent (work : nf_list) (ds : disjs) 
  (ni : nested_imps) (ai : atomic_imps) :=
  nweight_work work + (nweight_ds ds + (nweight_ni ni + nweight_ai ai)).

Lemma nweight_shift_work_ni0 :
 forall (x : nimp) (work : nf_list) (ds : disjs) (ni : nested_imps)
   (ai : atomic_imps),
 nweight_Sequent (NImp_NF x :: work) ds ni ai =
 nweight_Sequent work ds (Undecorated x :: ni) ai.

Lemma nweight_shift_work_ds :
 forall (i j : Int) (work : nf_list) (ds : disjs) (ni : nested_imps)
   (ai : atomic_imps),
 nweight_Sequent (NDisj i j :: work) ds ni ai =
 nweight_Sequent work ((i, j) :: ds) ni ai.

Lemma nweight_shift_work_ai :
 forall (i : Int) (b : normal_form) (work : nf_list) 
   (ds : disjs) (ni : nested_imps) (ai ai' : atomic_imps),
 LIN_INS nf_list i (cons b) nf_nil ai ai' ->
 nweight_Sequent (AImp i b :: work) ds ni ai = nweight_Sequent work ds ni ai'.

Lemma nweight_shift_ai_work :
 forall (i : Int) (bs work : nf_list) (ds : disjs) 
   (ni : nested_imps) (ai ai' : atomic_imps),
 LOOKUP nf_list i ai bs ->
 REGULAR normal_form ai ->
 LIN_DEL nf_list i bs ai ai' ->
 nweight_Sequent (bs ++ work) ds ni ai' < nweight_Sequent work ds ni ai.

Lemma nweight_sequent_eqv :
 forall (work : nf_list) (ds : disjs) (ni1 ni2 : nested_imps)
   (ai : atomic_imps),
 eqv_ni ni1 ni2 ->
 nweight_Sequent work ds ni1 ai = nweight_Sequent work ds ni2 ai.

Lemma nweight_sequent_nimp_left :
 forall (a0 a1 : Int) (b : normal_form) (work : nf_list) 
   (ds : disjs) (ni1 ni2 : nested_imps) (dni1 : decorated_nested_imps)
   (ai : atomic_imps) (n : nat),
 eqv_ni (rev_app dni1 ni1) ni2 ->
 nweight_Sequent work ds (rev_app dni1 (Undecorated (NImp a0 a1 b) :: ni1))
   ai < S n -> nweight_Sequent (AImp a1 b :: NAtom a0 :: work) ds ni2 ai < n.

Lemma nweight_sequent_nimp_right :
 forall (a0 a1 : Int) (b : normal_form) (work : nf_list) 
   (ds : disjs) (ni1 ni2 : nested_imps) (dni1 : decorated_nested_imps)
   (ai : atomic_imps) (n : nat),
 eqv_ni (rev_app dni1 ni1) ni2 ->
 nweight_Sequent work ds (rev_app dni1 (Undecorated (NImp a0 a1 b) :: ni1))
   ai < S n -> nweight_Sequent (b :: work) ds ni2 ai < n.

Lemma nweight_sequent_left_disj_left :
 forall (i j : Int) (work : nf_list) (ds : disjs) (ni1 ni2 : nested_imps)
   (ai : atomic_imps) (n : nat),
 eqv_ni ni1 ni2 ->
 nweight_Sequent work ((i, j) :: ds) ni1 ai < S n ->
 nweight_Sequent (NAtom i :: work) ds ni2 ai < n.

Lemma nweight_sequent_left_disj_right :
 forall (i j : Int) (work : nf_list) (ds : disjs) (ni1 ni2 : nested_imps)
   (ai : atomic_imps) (n : nat),
 eqv_ni ni1 ni2 ->
 nweight_Sequent work ((i, j) :: ds) ni1 ai < S n ->
 nweight_Sequent (NAtom j :: work) ds ni2 ai < n. *)
Require Export Lt_Ks.
(* Lt_Ks:
Require Export Le.
Require Export Lt.
Require Export Le_Ks.

Fixpoint count_undecs (n : nested_imps) : nat :=
  match n with
  | nil => 0
  | Undecorated _ :: n => S (count_undecs n)
  | Decorated _ _ :: n => count_undecs n
  end.

Inductive Lt_Ks (ni1 : nested_imps) (dni1 : decorated_nested_imps)
(ni2 : nested_imps) (dni2 : decorated_nested_imps) : Set :=
  | lt_ks_count_undecs :
      le_ni (rev_app dni1 ni1) (rev_app dni2 ni2) ->
      count_undecs ni1 < count_undecs ni2 -> Lt_Ks ni1 dni1 ni2 dni2
  | lt_ks_length :
      le_ni (rev_app dni1 ni1) (rev_app dni2 ni2) ->
      length ni1 < length ni2 -> Lt_Ks ni1 dni1 ni2 dni2.

Lemma le_ni_le_count_undecs :
 forall ni1 ni2 : nested_imps,
 le_ni ni1 ni2 -> count_undecs ni1 <= count_undecs ni2.

Lemma count_undecs_rev_app :
 forall (dni : decorated_nested_imps) (ni : nested_imps),
 count_undecs (rev_app dni ni) = count_undecs ni.

Lemma le_ks_le_count_undecs :
 forall (ni1 : nested_imps) (dni1 : decorated_nested_imps)
   (ni2 : nested_imps) (dni2 : decorated_nested_imps),
 le_ni (rev_app dni1 ni1) (rev_app dni2 ni2) ->
 count_undecs ni1 <= count_undecs ni2.

Lemma My_Lt_Ks_rec :
 forall P : nested_imps -> Set,
 (forall (ni2 : nested_imps) (dni2 : decorated_nested_imps),
  (forall (ni1 : nested_imps) (dni1 : decorated_nested_imps),
   Lt_Ks ni1 dni1 ni2 dni2 -> P (rev_app dni1 ni1)) -> 
  P (rev_app dni2 ni2)) -> forall ni : nested_imps, P ni.

Lemma lt_ks_shift_nd :
 forall (ni ni1 : nested_imps) (dni dni1 : decorated_nested_imps) 
   (x : nimp) (k : kripke_tree),
 le_ni (rev_app dni1 ni1) (rev_app ((x, k) :: dni) ni) ->
 Lt_Ks ni1 dni1 (Undecorated x :: ni) dni.

Lemma lt_ks_shift_dd :
 forall (ni : nested_imps) (dni : decorated_nested_imps) 
   (x : nimp) (k : kripke_tree),
 Lt_Ks ni ((x, k) :: dni) (Decorated x k :: ni) dni. *)
Require Export NRules.
(* NRules:
Require Export Cons_Counter_Model.
Require Export NSound.

Inductive nsearch_spec_result_aux (goal : Int) (work : nf_list) 
(ds : disjs) (ni : nested_imps) (ai : atomic_imps) 
(a : atoms) (context : flist) : Set :=
  | NDerivable :
      Derivable context (Atom goal) ->
      nsearch_spec_result_aux goal work ds ni ai a context
  | NRefutable :
      forall k : kripke_tree,
      Is_Monotone_kripke_tree k ->
      forces_ngamma work ds ni ai a k ->
      (forces_t k (Atom goal) -> False) ->
      nsearch_spec_result_aux goal work ds ni ai a context.

Inductive nsearch_spec_result (goal : Int) (work : nf_list) 
(ds : disjs) (ni : nested_imps) (ai : atomic_imps) 
(a : atoms) (context : flist) : Set :=
    NSearch_Res :
      forall ni1 : nested_imps,
      le_ni ni1 ni ->
      deco_sound work ds ni1 ai a ->
      nsearch_spec_result_aux goal work ds ni1 ai a context ->
      nsearch_spec_result goal work ds ni ai a context.

Definition nsearch_spec (goal : Int) (work : nf_list) 
  (ds : disjs) (ni : nested_imps) (ai : atomic_imps) 
  (a : atoms) (context : flist) :=
  deco_sound work ds ni ai a ->
  nsound work ds ni ai a context ->
  nminimal work ds ni ai a context ->
  nsearch_spec_result goal work ds ni ai a context.

Lemma fail :
 forall (i : Int) (dni : decorated_nested_imps) (ai : atomic_imps)
   (a : atoms) (context : flist),
 a_ai_disj a ai ->
 a_goal_disj a i ->
 nsearch_spec i nf_nil DNil (rev_app dni NNil) ai a context.

Lemma rule_shift_work_ds :
 forall (goal i j : Int) (work : nf_list) (ds : disjs) 
   (ni : nested_imps) (ai : atomic_imps) (a : atoms) 
   (context : flist),
 nsearch_spec goal work ((i, j) :: ds) ni ai a context ->
 nsearch_spec goal (NDisj i j :: work) ds ni ai a context.

Lemma rule_shift_work_ni0 :
 forall (goal : Int) (x : nimp) (work : nf_list) (ds : disjs)
   (ni : nested_imps) (ai : atomic_imps) (a : atoms) 
   (context : flist),
 nsearch_spec goal work ds (Undecorated x :: ni) ai a context ->
 nsearch_spec goal (NImp_NF x :: work) ds ni ai a context.

Lemma rule_shift_work_ai_new :
 forall (goal i : Int) (b : normal_form) (work : nf_list) 
   (ds : disjs) (ni : nested_imps) (ai ai' : atomic_imps) 
   (a : atoms) (context : flist),
 (forall x : unit, LOOKUP unit i a x -> False) ->
 (forall bs : nf_list, LOOKUP nf_list i ai bs -> False) ->
 EQUIV_INS nf_list i (cons b) nf_nil ai ai' ->
 nsearch_spec goal work ds ni ai' a context ->
 nsearch_spec goal (AImp i b :: work) ds ni ai a context.

Lemma rule_shift_work_ai_old :
 forall (goal i : Int) (b : normal_form) (work : nf_list) 
   (ds : disjs) (ni : nested_imps) (bs : nf_list) (ai ai' : atomic_imps)
   (a : atoms) (context : flist),
 (forall x : unit, LOOKUP unit i a x -> False) ->
 LOOKUP nf_list i ai bs ->
 EQUIV_INS nf_list i (cons b) nf_nil ai ai' ->
 nsearch_spec goal work ds ni ai' a context ->
 nsearch_spec goal (AImp i b :: work) ds ni ai a context.

Lemma rule_shift_work_a :
 forall (goal i : Int) (work : nf_list) (ds : disjs) 
   (ni : nested_imps) (ai : atomic_imps) (a a' : atoms) 
   (context : flist),
 (forall bs : nf_list, LOOKUP nf_list i ai bs -> False) ->
 (forall d : unit, LOOKUP unit i a d -> False) ->
 EQUIV_INS unit i (fun _ : unit => tt) tt a a' ->
 nsearch_spec goal work ds ni ai a' context ->
 nsearch_spec goal (NAtom i :: work) ds ni ai a context.

Lemma shift_ni_dni :
 forall (goal : Int) (work : nf_list) (ds : disjs) 
   (x : nimp) (k : kripke_tree) (ni : nested_imps)
   (dni : decorated_nested_imps) (ai : atomic_imps) 
   (a : atoms) (context : flist),
 nsearch_spec goal work ds (rev_app ((x, k) :: dni) ni) ai a context ->
 nsearch_spec goal work ds (rev_app dni (Decorated x k :: ni)) ai a context.

Lemma nax :
 forall (goal : Int) (work : nf_list) (ds : disjs) 
   (ni : nested_imps) (ai : atomic_imps) (a : atoms) 
   (context : flist),
 in_ngamma work ds ni ai a (NAtom goal) ->
 nsearch_spec goal work ds ni ai a context.

Lemma nefq :
 forall (goal : Int) (work : nf_list) (ds : disjs) 
   (ni : nested_imps) (ai : atomic_imps) (a : atoms) 
   (context : flist), nsearch_spec goal (NFalsum :: work) ds ni ai a context.

Lemma contradiction_atoms :
 forall (goal i : Int) (work : nf_list) (ds : disjs) 
   (ni : nested_imps) (ai : atomic_imps) (a : atoms) 
   (context : flist),
 LOOKUP unit i a tt ->
 nsearch_spec goal work ds ni ai a context ->
 nsearch_spec goal (NAtom i :: work) ds ni ai a context.

Lemma left_p_imp_work :
 forall (goal i : Int) (b : normal_form) (work : nf_list) 
   (ds : disjs) (ni : nested_imps) (ai : atomic_imps) 
   (a : atoms) (context : flist),
 forces0_t a i ->
 nsearch_spec goal (b :: work) ds ni ai a context ->
 nsearch_spec goal (AImp i b :: work) ds ni ai a context.

Lemma left_p_imp_ai :
 forall (goal i : Int) (work : nf_list) (ds : disjs) 
   (ni : nested_imps) (bs : nf_list) (ai ai' : atomic_imps) 
   (a a' : atoms) (context : flist),
 LOOKUP nf_list i ai bs ->
 EQUIV_DEL nf_list i ai ai' ->
 (forall d : unit, LOOKUP unit i a d -> False) ->
 EQUIV_INS unit i (fun _ : unit => tt) tt a a' ->
 nsearch_spec goal (bs ++ work) ds ni ai' a' context ->
 nsearch_spec goal (NAtom i :: work) ds ni ai a context.

Lemma left_disj :
 forall (goal : Int) (work : nf_list) (i j : Int) (ds : disjs)
   (ni : nested_imps) (ai : atomic_imps) (a : atoms) 
   (context : flist),
 (forall ni1 : nested_imps,
  le_ni ni ni1 ->
  nsearch_spec goal (NAtom i :: work) ds ni1 ai a (Atom i :: context)) ->
 (forall ni2 : nested_imps,
  eqv_ni ni2 ni ->
  nsearch_spec goal (NAtom j :: work) ds ni2 ai a (Atom j :: context)) ->
 nsearch_spec goal work ((i, j) :: ds) ni ai a context.

Lemma left_nimp :
 forall (goal : Int) (work : nf_list) (ds : disjs) 
   (a0 a1 : Int) (b : normal_form) (ni : nested_imps)
   (dni : decorated_nested_imps) (ai : atomic_imps) 
   (a : atoms) (context : flist),
 (forall ni1 : nested_imps,
  le_ni (rev_app dni ni) ni1 ->
  nsearch_spec a1 (AImp a1 b :: NAtom a0 :: work) ds ni1 ai a
    (Atom a0 :: context)) ->
 (forall ni1 : nested_imps,
  le_ni ni1 (rev_app dni ni) ->
  nsearch_spec goal (b :: work) ds ni1 ai a context) ->
 (forall (ni1 : nested_imps) (k : kripke_tree),
  le_ni ni1 (rev_app ((NImp a0 a1 b, k) :: dni) ni) ->
  nsearch_spec goal work ds ni1 ai a context) ->
 nsearch_spec goal work ds (rev_app dni (Undecorated (NImp a0 a1 b) :: ni))
   ai a context. *)

Definition nsearch_invariant (n : nat) :=
  forall (goal : Int) (work : nf_list) (ds : disjs) 
    (ni : nested_imps) (ai : atomic_imps) (a : atoms) 
    (context : flist),
  nweight_Sequent work ds ni ai < n ->
  REGULAR normal_form ai ->
  a_ai_disj a ai ->
  a_goal_disj a goal -> nsearch_spec goal work ds ni ai a context.

Lemma nsearch_aux : forall n : nat, nsearch_invariant n.

intros n; elim n; clear n.

unfold nsearch_invariant in |- *.
intros goal work ds ni ai a context lt_nweight ai_reg a_ai_disj a_goal_disj.
elimtype False.
apply (lt_n_O (nweight_Sequent work ds ni ai)); assumption.

intros n ih_n.
unfold nsearch_invariant in |- *.
intros goal work ds ni ai a.
elim ai; clear ai.
intros ai avl_ai.
elim a; clear a.
intros a avl_a.
intros context lt_nweight ai_reg a_ai_disj a_goal_disj.
generalize ds ni ai avl_ai a avl_a ai_reg a_goal_disj a_ai_disj lt_nweight;
 clear lt_nweight ai_reg a_ai_disj a_goal_disj avl_ai avl_a ds ni ai a.

elim work; clear work.

fold nf_nil in |- *.
intros ds; case ds; clear ds.

fold DNil in |- *.
intros ni ai avl_ai a avl_a ai_reg a_goal_disj a_ai_disj.
pattern ni in |- *.
apply My_Lt_Ks_rec; clear ni.
intros ni dni.
case ni; clear ni.
fold NNil in |- *.
intros ih lt_nweight.
apply fail; assumption.

intros x; case x; clear x.
intros x; case x; clear x.
intros a0 a1 b ni ih lt_nweight.
apply left_nimp; try assumption.

intros ni1 le1; clear ih.
elim (lookup_dec unit a1 a avl_a).
intros d; case d; clear d.
intros lookup.
apply nax; try assumption.
apply In_Atoms; assumption.
intros not_lookup.
apply ih_n; try assumption.
apply nweight_sequent_nimp_left with ni dni; try assumption.
apply le_eqv; assumption.
exact (not_lookup tt).

intros ni1 le1; clear ih.
apply ih_n; try assumption.
apply nweight_sequent_nimp_right with a0 a1 ni dni; try assumption.
apply ge_eqv; assumption.

intros ni1 k le1.
apply ih with (ni1 := ni1) (dni1 := DNI_NIL); clear ih; try assumption.
apply lt_ks_shift_nd with k; assumption.
simpl in |- *.
 rewrite
 (nweight_sequent_eqv nf_nil DNil ni1
    (rev_app dni (Undecorated (NImp a0 a1 b) :: ni))
    (AVL_intro nf_list ai avl_ai)).
assumption.
apply eqv_ni_trans with (rev_app dni (Decorated (NImp a0 a1 b) k :: ni)).
apply le_eqv; assumption.
apply le_eqv.
 rewrite (rev_app_app dni (Decorated (NImp a0 a1 b) k :: ni)).
 rewrite (rev_app_app dni (Undecorated (NImp a0 a1 b) :: ni)).
apply le_ni_app_dn.
trivial.
apply le_ni_refl.

intros x k ni ih lt_nweight.
apply shift_ni_dni; try assumption.
apply ih; try assumption.
apply lt_ks_shift_dd.

intros d; case d; clear d.
intros i j ds ni ai avl_ai a avl_a ai_reg a_goal_disj a_ai_disj lt_nweight.
apply left_disj; try assumption.
intros ni1 le1.
apply ih_n; try assumption.
apply nweight_sequent_left_disj_left with j ni.
apply le_eqv; assumption.
assumption.

intros ni1 le1.
apply ih_n; try assumption.
apply nweight_sequent_left_disj_right with i ni.
apply eqv_sym; assumption.
assumption.

intros c work ih_work ds ni ai avl_ai a avl_a ai_reg a_goal_disj a_ai_disj.
case c; clear c.

intros lt_nweight.
clear ih_work ih_n.
apply nefq; assumption.

intros i lt_nweight.
elim (equal_dec goal i).
clear ih_work ih_n.
intros equal_goal.
apply nax; try assumption.
 rewrite (equal_eq goal i equal_goal).
apply in_ngamma_cons_work_head.

intros not_equal_goal.
elim (insert_avl unit i (fun x : unit => tt) tt a avl_a).
intros a' lookup_dec_a avl_a' lin_ins equiv_ins height_dec; clear height_dec.
elim lookup_dec_a; clear lookup_dec_a lin_ins.
clear ih_n.
intros d; case d; clear d.
intros lookup.
apply contradiction_atoms; try assumption.
apply ih_work; clear ih_work; assumption.

intros not_lookup.
elim (delete_avl nf_list i ai avl_ai).
intros ai' lookup_dec_ai' avl_ai' lin_del equiv_del height_dec;
 clear height_dec.
elim lookup_dec_ai'; clear lookup_dec_ai'.
intros bs lookup_bs; clear ih_work.
apply
 left_p_imp_ai
  with bs (AVL_intro nf_list ai' avl_ai') (AVL_intro unit a' avl_a');
 try assumption.
apply ih_n; try assumption.
apply
 lt_le_trans with (nweight_Sequent work ds ni (AVL_intro nf_list ai avl_ai)).
apply nweight_shift_ai_work with i; try assumption.
unfold LIN_DEL in |- *.
apply lin_del; assumption.
inversion_clear lt_nweight.
apply le_n.
apply le_Sn_le.
assumption.

apply regular_EQUIV_DEL with i (AVL_intro nf_list ai avl_ai); assumption.
apply
 disjs_delete_ai
  with i (AVL_intro unit a avl_a) (AVL_intro nf_list ai avl_ai); 
 assumption.
apply goal_disj_insert_a with i (AVL_intro unit a avl_a); assumption.

intros not_lookup_bs.
apply rule_shift_work_a with (AVL_intro unit a' avl_a'); try assumption.
apply ih_work; clear ih_work; try assumption.

apply goal_disj_insert_a with i (AVL_intro unit a avl_a); assumption.
apply disjs_insert_a with i (AVL_intro unit a avl_a); assumption.

intros i j lt_nweight.
apply rule_shift_work_ds; try assumption.
apply ih_work; clear ih_work; try assumption.
 rewrite <-
 (nweight_shift_work_ds i j work ds ni (AVL_intro nf_list ai avl_ai))
 ; assumption.

intros i b lt_nweight.
elim (lookup_dec unit i a avl_a).
intros d; case d; clear d.
intros lookup_i.
clear ih_work.
apply left_p_imp_work; try assumption.
apply ih_n; clear ih_n; try assumption.
apply lt_S_n.
assumption.

intros not_lookup_i.
elim (insert_avl nf_list i (cons b) nf_nil ai avl_ai).
intros ai' lookup_dec avl_ai' lin_ins equiv_ins height_dec; clear height_dec.
elim lookup_dec; clear lookup_dec.
intros bs lookup_bs.
apply rule_shift_work_ai_old with bs (AVL_intro nf_list ai' avl_ai');
 try assumption.
apply ih_work; clear ih_work; try assumption.
apply regular_EQUIV_INS with i b (AVL_intro nf_list ai avl_ai); assumption.
apply disjs_insert_ai with i b (AVL_intro nf_list ai avl_ai); assumption.
 rewrite <-
 (nweight_shift_work_ai i b work ds ni (AVL_intro nf_list ai avl_ai)
    (AVL_intro nf_list ai' avl_ai')); assumption.
intros notlookup_bs.
apply rule_shift_work_ai_new with (AVL_intro nf_list ai' avl_ai');
 try assumption.
apply ih_work; clear ih_work; try assumption.
apply regular_EQUIV_INS with i b (AVL_intro nf_list ai avl_ai); assumption.
apply disjs_insert_ai with i b (AVL_intro nf_list ai avl_ai); assumption.
 rewrite <-
 (nweight_shift_work_ai i b work ds ni (AVL_intro nf_list ai avl_ai)
    (AVL_intro nf_list ai' avl_ai')); assumption.

intros x lt_nweight.
apply rule_shift_work_ni0; try assumption.
apply ih_work; clear ih_work; try assumption.
 rewrite <-
 (nweight_shift_work_ni0 x work ds ni (AVL_intro nf_list ai avl_ai))
 ; assumption.
Qed.

Theorem nsearch :
 forall (goal : Int) (work : nf_list) (context : flist),
 (forall (n : nat) (a : normal_form),
  my_nth normal_form n work a -> Derivable context (nf2form a)) ->
 (forall (a : form) (k : kripke_tree),
  Is_Monotone_kripke_tree k ->
  (forall b : normal_form, In b work -> forces_t k (nf2form b)) ->
  In a context -> forces_t k a) ->
 nsearch_spec_result_aux goal work DNil NNil AI_Nil ANil context.
intros goal work context sound minimal.
elim
 (nsearch_aux (S (nweight_Sequent work DNil NNil AI_Nil)) goal work DNil NNil
    AI_Nil ANil context).
intros ni1 le1.
cut (ni1 = NNil).
intros claim.
 rewrite claim.
intros; assumption.
inversion_clear le1.
trivial.
apply lt_n_Sn.

unfold AI_Nil in |- *.
unfold nf_list in |- *.
apply regular_AVL_NIL.

unfold a_ai_disj in |- *.
intros i lookup_i bs lookup_bs.
inversion_clear lookup_i.

unfold a_goal_disj in |- *.
intros lookup_goal.
inversion_clear lookup_goal.

unfold deco_sound in |- *.
intros k i0 i1 b in_k.
inversion_clear in_k.

unfold nsound in |- *.
intros a in_ngamma.
elim in_ngamma; clear in_ngamma a.

intros n a nth.
apply sound with n; assumption.

intros n i j nth; elimtype False; inversion_clear nth.
intros n x nth; elimtype False; inversion_clear nth.
intros i b n bs lookup_i nth; elimtype False; inversion_clear lookup_i.
intros i lookup; elimtype False; inversion_clear lookup.

unfold nminimal in |- *.
intros a k k_is_mon k_forces_gamma in_a.
apply minimal; try assumption.
intros b in_b.
elim (in_nth normal_form b work in_b).
intros n nth.
apply k_forces_gamma.
apply In_Work with n; assumption.
Qed.