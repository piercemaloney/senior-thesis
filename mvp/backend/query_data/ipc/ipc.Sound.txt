
Require Export NSound.
(* NSound:
Require Export Le_Ks.
Require Export Derivable_Tools.

Definition nsound (work : nf_list) (ds : disjs) (ni : nested_imps)
  (ai : atomic_imps) (a : atoms) (context : flist) :=
  forall c : normal_form,
  in_ngamma work ds ni ai a c -> Derivable context (nf2form c).

Lemma nsound_eqv :
 forall (work : nf_list) (ds : disjs) (ni1 ni2 : nested_imps)
   (ai : atomic_imps) (a : atoms) (context : flist),
 eqv_ni ni1 ni2 ->
 nsound work ds ni1 ai a context -> nsound work ds ni2 ai a context.

Lemma nsound_le :
 forall (work : nf_list) (ds : disjs) (ni1 ni2 : nested_imps)
   (ai : atomic_imps) (a : atoms) (context : flist),
 le_ni ni1 ni2 ->
 nsound work ds ni1 ai a context -> nsound work ds ni2 ai a context.

Lemma nsound_ge :
 forall (work : nf_list) (ds : disjs) (ni1 ni2 : nested_imps)
   (ai : atomic_imps) (a : atoms) (context : flist),
 le_ni ni2 ni1 ->
 nsound work ds ni1 ai a context -> nsound work ds ni2 ai a context.

Lemma nsound_shift_work_ds :
 forall (i j : Int) (work : nf_list) (ds : disjs) (ni : nested_imps)
   (ai : atomic_imps) (a : atoms) (context : flist),
 nsound (NDisj i j :: work) ds ni ai a context ->
 nsound work ((i, j) :: ds) ni ai a context.

Lemma nsound_shift_work_ni :
 forall (x : nested_imp) (work : nf_list) (ds : disjs) 
   (ni : nested_imps) (ai : atomic_imps) (a : atoms) 
   (context : flist),
 nsound (NImp_NF (nested_imp2nimp x) :: work) ds ni ai a context ->
 nsound work ds (x :: ni) ai a context.

Lemma nsound_shift_work_ai :
 forall (i : Int) (b : normal_form) (work : nf_list) 
   (ds : disjs) (ni : nested_imps) (ai ai' : atomic_imps) 
   (a : atoms) (context : flist),
 EQUIV_INS nf_list i (cons b) nf_nil ai ai' ->
 nsound (AImp i b :: work) ds ni ai a context ->
 nsound work ds ni ai' a context.

Lemma nsound_shift_work_a :
 forall (i : Int) (work : nf_list) (ds : disjs) (ni : nested_imps)
   (ai : atomic_imps) (a a' : atoms) (context : flist),
 EQUIV_INS unit i (fun _ : unit => tt) tt a a' ->
 nsound (NAtom i :: work) ds ni ai a context ->
 nsound work ds ni ai a' context.

Lemma nsound_shift_work_ni_x_ni :
 forall (x : nested_imp) (work : nf_list) (ds : disjs)
   (ni1 ni2 : nested_imps) (ai : atomic_imps) (a : atoms) 
   (context : flist),
 nsound (NImp_NF (nested_imp2nimp x) :: work) ds (ni1 ++ ni2) ai a context ->
 nsound work ds (ni1 ++ x :: ni2) ai a context.

Lemma nsound_shift_ni_x_ni_work :
 forall (x : nested_imp) (work : nf_list) (ds : disjs)
   (ni1 ni2 : nested_imps) (ai : atomic_imps) (a : atoms) 
   (context : flist),
 nsound work ds (ni1 ++ x :: ni2) ai a context ->
 nsound (NImp_NF (nested_imp2nimp x) :: work) ds (ni1 ++ ni2) ai a context.

Remark nsound_app_work :
 forall (bs work : nf_list) (ds : disjs) (ni : nested_imps)
   (ai : atomic_imps) (a : atoms) (context : flist),
 (forall (n : nat) (b : normal_form),
  my_nth normal_form n bs b -> Derivable context (nf2form b)) ->
 nsound work ds ni ai a context -> nsound (bs ++ work) ds ni ai a context.

Lemma nsound_cons_ds_tail :
 forall (work : nf_list) (i j : Int) (ds : disjs) (ni : nested_imps)
   (ai : atomic_imps) (a : atoms) (context : flist),
 nsound work ((i, j) :: ds) ni ai a context -> nsound work ds ni ai a context.

Remark nsound_del_ai :
 forall (i : Int) (work : nf_list) (ds : disjs) (ni : nested_imps)
   (ai ai' : atomic_imps) (a : atoms) (context : flist),
 EQUIV_DEL nf_list i ai ai' ->
 nsound work ds ni ai a context -> nsound work ds ni ai' a context.

Lemma nsound_cons_work_cons_context :
 forall (c : normal_form) (work : nf_list) (ds : disjs) 
   (ni : nested_imps) (ai : atomic_imps) (a : atoms) 
   (context : flist),
 nsound work ds ni ai a context ->
 nsound (c :: work) ds ni ai a (nf2form c :: context).

Lemma nsound_cons_work_weak :
 forall (b c : normal_form) (work : nf_list) (ds : disjs) 
   (ni : nested_imps) (ai : atomic_imps) (a : atoms) 
   (context : flist),
 (Derivable context (nf2form b) -> Derivable context (nf2form c)) ->
 nsound (b :: work) ds ni ai a context ->
 nsound (c :: work) ds ni ai a context.

Lemma nsound_shift_work_ai_strength :
 forall (i : Int) (bs work : nf_list) (ds : disjs) 
   (ni : nested_imps) (ai ai' : atomic_imps) (a a' : atoms) 
   (context : flist),
 EQUIV_INS unit i (fun _ : unit => tt) tt a a' ->
 LOOKUP nf_list i ai bs ->
 EQUIV_DEL nf_list i ai ai' ->
 nsound work ds ni ai a' context -> nsound (bs ++ work) ds ni ai' a' context. *)
Require Export In_Gamma.
(* In_Gamma:
Require Export In_NGamma.

Inductive in_gamma (gamma : flist) (work : nf_list) : form -> Set :=
  | In_Gamma :
      forall (n : nat) (a : form),
      my_nth form n gamma a -> in_gamma gamma work a
  | In_Work1 :
      forall (n : nat) (a : normal_form),
      my_nth normal_form n work a -> in_gamma gamma work (nf2form a).

Lemma in_gamma_cons_gamma_tail :
 forall (a : form) (gamma : flist) (work : nf_list) (c : form),
 in_gamma gamma work c -> in_gamma (a :: gamma) work c.

Lemma in_gamma_cons_gamma_head :
 forall (a : form) (gamma : flist) (work : nf_list),
 in_gamma (a :: gamma) work a.

Lemma in_gamma_cons_gamma_rev :
 forall (a : form) (gamma : flist) (work : nf_list) (c : form),
 in_gamma (a :: gamma) work c -> in_gamma gamma work c + {c = a}.

Lemma in_gamma_cons_work_tail :
 forall (a : normal_form) (gamma : flist) (work : nf_list) (c : form),
 in_gamma gamma work c -> in_gamma gamma (a :: work) c.

Lemma in_gamma_cons_work_head :
 forall (a : normal_form) (gamma : flist) (work : nf_list),
 in_gamma gamma (a :: work) (nf2form a).

Lemma in_gamma_cons_work_rev :
 forall (a : normal_form) (gamma : flist) (work : nf_list) (c : form),
 in_gamma gamma (a :: work) c -> in_gamma gamma work c + {c = nf2form a}.

Lemma in_gamma_shift_gamma_work :
 forall (a : normal_form) (gamma : flist) (work : nf_list) (c : form),
 in_gamma (nf2form a :: gamma) work c -> in_gamma gamma (a :: work) c.

Lemma in_gamma_shift_work_gamma :
 forall (a : normal_form) (gamma : flist) (work : nf_list) (c : form),
 in_gamma gamma (a :: work) c -> in_gamma (nf2form a :: gamma) work c. *)

Definition sound (Gamma : flist) (work : nf_list) (context : flist) :=
  forall a : form, in_gamma Gamma work a -> Derivable context a.

Lemma sound_cons_gamma :
 forall (gamma : flist) (work : nf_list) (context : flist) (a : form),
 Derivable context a ->
 sound gamma work context -> sound (a :: gamma) work context.
intros gamma work context a der_a sound0.
unfold sound in |- *.
intros c in_gamma0.
elim (in_gamma_cons_gamma_rev a gamma work c in_gamma0); clear in_gamma0.
intros in_gamma0.
apply sound0; assumption.
intros eq_c;  rewrite eq_c; assumption.
Qed.

Lemma sound_cons_gamma_tail :
 forall (gamma : flist) (work : nf_list) (context : flist) (a : form),
 sound (a :: gamma) work context -> sound gamma work context.
intros gamma work context a sound0.
unfold sound in |- *.
intros c in_gamma0.
apply sound0.
apply in_gamma_cons_gamma_tail; assumption.
Qed.

Lemma sound_cons_gamma_head :
 forall (gamma : flist) (work : nf_list) (context : flist) (a : form),
 sound (a :: gamma) work context -> Derivable context a.
intros gamma work context a sound0.
apply sound0.
apply in_gamma_cons_gamma_head; assumption.
Qed.

Lemma sound_shift_gamma_work :
 forall (a : normal_form) (gamma : flist) (work : nf_list) (context : flist),
 sound (nf2form a :: gamma) work context -> sound gamma (a :: work) context.
intros a gamma work context sound0.
unfold sound in |- *.
intros c in_gamma.
apply sound0.
apply in_gamma_shift_work_gamma; assumption.
Qed.

Lemma sound_shift_work_gamma :
 forall (a : normal_form) (gamma : flist) (work : nf_list) (context : flist),
 sound gamma (a :: work) context -> sound (nf2form a :: gamma) work context.
intros a gamma work context sound0.
unfold sound in |- *.
intros c in_gamma.
apply sound0.
apply in_gamma_shift_gamma_work; assumption.
Qed.

Lemma sound_cons_gamma_cons_context :
 forall (gamma : flist) (work : nf_list) (context : flist) (a : form),
 sound gamma work context -> sound (a :: gamma) work (a :: context).
intros gamma work context a sound0.
apply sound_cons_gamma.
apply Derivable_Intro with (Var 0).
apply ByAssumption.
apply My_NthO.
unfold sound in |- *.
intros c in_gamma0.
elim (sound0 c in_gamma0).
intros t der_t.
apply Derivable_Intro with (Shift t).
apply ShiftIntro; assumption.
Qed.

Lemma sound_cons_gamma_weak :
 forall (gamma : flist) (work : nf_list) (context : flist) (a b : form),
 (Derivable context a -> Derivable context b) ->
 sound (a :: gamma) work context -> sound (b :: gamma) work context.
intros gamma work context a b der_ab sound0.
apply sound_cons_gamma.
apply der_ab.
apply sound_cons_gamma_head with gamma work; assumption.
apply sound_cons_gamma_tail with a; assumption.
Qed.

Lemma sound_cons_gamma_weak2 :
 forall (gamma : flist) (work : nf_list) (context : flist) (a b c : form),
 (Derivable context a -> Derivable2 context b c) ->
 sound (a :: gamma) work context -> sound (b :: c :: gamma) work context.
intros gamma work context a b c der_abc sound0.
elim der_abc; clear der_abc.
intros der_b der_c.
apply sound_cons_gamma.
assumption.
apply sound_cons_gamma.
assumption.
apply sound_cons_gamma_tail with a; assumption.
apply sound_cons_gamma_head with gamma work; assumption.
Qed.

