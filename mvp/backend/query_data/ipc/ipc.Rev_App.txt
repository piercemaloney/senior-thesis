
Require Export In_NGamma.
(* In_NGamma:
Require Export Kripke_Trees.
Require Export Normal_Forms.

Definition disj := (Int * Int)%type.
Definition disjs := list disj.
Definition DNil := nil (A:=disj).

Definition disj2form (x : disj) :=
  match x with
  | (i, j) => OrF (Atom i) (Atom j)
  end.

Definition disj2nform (x : disj) := match x with
                                    | (i, j) => NDisj i j
                                    end.

Definition disjs2forms (ds : disjs) := map disj2form ds.
Definition disjs2nforms (ds : disjs) := map disj2nform ds.

Inductive nested_imp : Set :=
  | Undecorated : nimp -> nested_imp
  | Decorated : nimp -> kripke_tree -> nested_imp.

Definition nested_imp2nimp (ni : nested_imp) :=
  match ni with
  | Undecorated ni => ni
  | Decorated ni _ => ni
  end.

Definition nested_imp2form (x : nested_imp) := nimp2form (nested_imp2nimp x).
Definition nested_imp2nform (x : nested_imp) := NImp_NF (nested_imp2nimp x).

Definition nested_imps := list nested_imp.
Definition NNil := nil (A:=nested_imp).

Definition nested_imps2forms (ni : nested_imps) := map nested_imp2form ni.
Definition nested_imps2nforms (ni : nested_imps) := map nested_imp2nform ni.
Definition nested_imps2nimps (ni : nested_imps) := map nested_imp2nimp ni.

Lemma nested_imps2nimps_app :
 forall ni1 ni2 : nested_imps,
 nested_imps2nimps (ni1 ++ ni2) =
 nested_imps2nimps ni1 ++ nested_imps2nimps ni2.

Lemma nested_imps2nimps_length :
 forall ni : nested_imps, length ni = length (nested_imps2nimps ni).

Definition atomic_imps := AVL nf_list.
Definition AI_Nil := AVL_NIL nf_list.

Inductive in_ngamma (work : nf_list) (ds : disjs) (ni : nested_imps)
(ai : atomic_imps) (a : atoms) : normal_form -> Set :=
  | In_Work :
      forall (n : nat) (c : normal_form),
      my_nth normal_form n work c -> in_ngamma work ds ni ai a c
  | In_Disjs :
      forall (n : nat) (i j : Int),
      my_nth disj n ds (i, j) -> in_ngamma work ds ni ai a (NDisj i j)
  | In_Nested_Imps :
      forall (n : nat) (x : nimp),
      my_nth nimp n (nested_imps2nimps ni) x ->
      in_ngamma work ds ni ai a (NImp_NF x)
  | In_Atomic_Imps :
      forall (i : Int) (b : normal_form) (n : nat) (bs : nf_list),
      LOOKUP nf_list i ai bs ->
      my_nth normal_form n bs b -> in_ngamma work ds ni ai a (AImp i b)
  | In_Atoms :
      forall i : Int,
      LOOKUP unit i a tt -> in_ngamma work ds ni ai a (NAtom i).

Lemma in_ngamma_cons_work_tail :
 forall (c0 : normal_form) (work : nf_list) (ds : disjs) 
   (ni : nested_imps) (ai : atomic_imps) (a : atoms) 
   (c : normal_form),
 in_ngamma work ds ni ai a c -> in_ngamma (c0 :: work) ds ni ai a c.

Lemma in_ngamma_cons_work_head :
 forall (c : normal_form) (work : nf_list) (ds : disjs) 
   (ni : nested_imps) (ai : atomic_imps) (a : atoms),
 in_ngamma (c :: work) ds ni ai a c.

Lemma in_ngamma_work_app1 :
 forall (bs work : nf_list) (ds : disjs) (ni : nested_imps)
   (ai : atomic_imps) (a : atoms) (c : normal_form),
 in_ngamma work ds ni ai a c -> in_ngamma (bs ++ work) ds ni ai a c.

Lemma in_ngamma_work_app_rev :
 forall (bs work : nf_list) (ds : disjs) (ni : nested_imps)
   (ai : atomic_imps) (a : atoms) (c : normal_form),
 in_ngamma (bs ++ work) ds ni ai a c ->
 in_ngamma work ds ni ai a c + {n : nat | my_nth normal_form n bs c}.

Lemma in_ngamma_cons_work_rev :
 forall (c0 : normal_form) (work : nf_list) (ds : disjs) 
   (ni : nested_imps) (ai : atomic_imps) (a : atoms) 
   (c : normal_form),
 in_ngamma (c0 :: work) ds ni ai a c ->
 in_ngamma work ds ni ai a c + {c = c0}.

Lemma in_ngamma_cons_ds_tail :
 forall (work : nf_list) (i j : Int) (ds : disjs) (ni : nested_imps)
   (ai : atomic_imps) (a : atoms) (c : normal_form),
 in_ngamma work ds ni ai a c -> in_ngamma work ((i, j) :: ds) ni ai a c.

Lemma in_ngamma_cons_ds_head :
 forall (work : nf_list) (i j : Int) (ds : disjs) (ni : nested_imps)
   (ai : atomic_imps) (a : atoms),
 in_ngamma work ((i, j) :: ds) ni ai a (NDisj i j).

Lemma in_ngamma_cons_ds_rev :
 forall (work : nf_list) (i j : Int) (ds : disjs) (ni : nested_imps)
   (ai : atomic_imps) (a : atoms) (c : normal_form),
 in_ngamma work ((i, j) :: ds) ni ai a c ->
 in_ngamma work ds ni ai a c + {c = NDisj i j}.

Lemma in_ngamma_cons_ni_tail :
 forall (work : nf_list) (ds : disjs) (x : nested_imp) 
   (ni : nested_imps) (ai : atomic_imps) (a : atoms) 
   (c : normal_form),
 in_ngamma work ds ni ai a c -> in_ngamma work ds (x :: ni) ai a c.

Lemma in_ngamma_cons_ni_head :
 forall (work : nf_list) (ds : disjs) (x : nested_imp) 
   (ni : nested_imps) (ai : atomic_imps) (a : atoms),
 in_ngamma work ds (x :: ni) ai a (NImp_NF (nested_imp2nimp x)).

Lemma in_ngamma_cons_ni_rev :
 forall (work : nf_list) (ds : disjs) (x : nested_imp) 
   (ni : nested_imps) (ai : atomic_imps) (a : atoms) 
   (c : normal_form),
 in_ngamma work ds (x :: ni) ai a c ->
 in_ngamma work ds ni ai a c + {c = NImp_NF (nested_imp2nimp x)}.

Lemma in_ngamma_ni_x_ni_head :
 forall (work : nf_list) (ds : disjs) (x : nested_imp)
   (ni1 ni2 : nested_imps) (ai : atomic_imps) (a : atoms),
 in_ngamma work ds (ni1 ++ x :: ni2) ai a (NImp_NF (nested_imp2nimp x)).

Lemma in_ngamma_ni_x_ni_tail :
 forall (work : nf_list) (ds : disjs) (x : nested_imp)
   (ni1 ni2 : nested_imps) (ai : atomic_imps) (a : atoms) 
   (c : normal_form),
 in_ngamma work ds (ni1 ++ ni2) ai a c ->
 in_ngamma work ds (ni1 ++ x :: ni2) ai a c.

Lemma in_ngamma_ni_x_ni_rev :
 forall (work : nf_list) (ds : disjs) (x : nested_imp)
   (ni1 ni2 : nested_imps) (ai : atomic_imps) (a : atoms) 
   (c : normal_form),
 in_ngamma work ds (ni1 ++ x :: ni2) ai a c ->
 in_ngamma work ds (ni1 ++ ni2) ai a c + {c = NImp_NF (nested_imp2nimp x)}.

Lemma in_ngamma_ni_eq :
 forall (work : nf_list) (ds : disjs) (ni ni' : nested_imps)
   (ai : atomic_imps) (a : atoms) (c : normal_form),
 nested_imps2nimps ni = nested_imps2nimps ni' ->
 in_ngamma work ds ni ai a c -> in_ngamma work ds ni' ai a c.

Lemma in_ngamma_ins_ai_tail :
 forall (work : nf_list) (ds : disjs) (ni : nested_imps) 
   (i : Int) (b : normal_form) (ai ai' : atomic_imps) 
   (a : atoms) (c : normal_form),
 EQUIV_INS nf_list i (cons b) nf_nil ai ai' ->
 in_ngamma work ds ni ai a c -> in_ngamma work ds ni ai' a c.

Lemma in_ngamma_ins_ai_head_new :
 forall (work : nf_list) (ds : disjs) (ni : nested_imps) 
   (i : Int) (b : normal_form) (ai ai' : atomic_imps) 
   (a : atoms),
 (forall bs : nf_list, LOOKUP nf_list i ai bs -> False) ->
 EQUIV_INS nf_list i (cons b) nf_nil ai ai' ->
 in_ngamma work ds ni ai' a (AImp i b).

Lemma in_ngamma_ins_ai_head_old :
 forall (work : nf_list) (ds : disjs) (ni : nested_imps) 
   (i : Int) (b : normal_form) (bs : nf_list) (ai ai' : atomic_imps)
   (a : atoms),
 LOOKUP nf_list i ai bs ->
 EQUIV_INS nf_list i (cons b) nf_nil ai ai' ->
 in_ngamma work ds ni ai' a (AImp i b).

Lemma in_ngamma_ins_ai_rev :
 forall (work : nf_list) (ds : disjs) (ni : nested_imps) 
   (i : Int) (b : normal_form) (ai ai' : atomic_imps) 
   (a : atoms) (c : normal_form),
 EQUIV_INS nf_list i (cons b) nf_nil ai ai' ->
 in_ngamma work ds ni ai' a c -> in_ngamma work ds ni ai a c + {c = AImp i b}.

Lemma in_ngamma_del_ai_tail :
 forall (work : nf_list) (ds : disjs) (ni : nested_imps) 
   (i : Int) (ai ai' : atomic_imps) (a : atoms) (c : normal_form),
 EQUIV_DEL nf_list i ai' ai ->
 in_ngamma work ds ni ai a c -> in_ngamma work ds ni ai' a c.

Inductive in_ngamma_del_ai_rev_spec (i : Int) (bs : nf_list)
(c : normal_form) : Set :=
    In_NGamma_Del_AI_Rev_Spec_Intro :
      forall (b : normal_form) (n : nat),
      my_nth normal_form n bs b ->
      c = AImp i b -> in_ngamma_del_ai_rev_spec i bs c.

Lemma in_ngamma_del_ai_rev :
 forall (work : nf_list) (ds : disjs) (ni : nested_imps) 
   (i : Int) (bs : nf_list) (ai ai' : atomic_imps) 
   (a : atoms) (c : normal_form),
 LOOKUP nf_list i ai' bs ->
 EQUIV_DEL nf_list i ai' ai ->
 in_ngamma work ds ni ai' a c ->
 in_ngamma work ds ni ai a c + in_ngamma_del_ai_rev_spec i bs c.

Lemma in_ngamma_ins_a_tail :
 forall (work : nf_list) (ds : disjs) (ni : nested_imps) 
   (ai : atomic_imps) (i : Int) (a a' : atoms) (c : normal_form),
 EQUIV_INS unit i (fun _ : unit => tt) tt a a' ->
 in_ngamma work ds ni ai a c -> in_ngamma work ds ni ai a' c.

Lemma in_ngamma_ins_a_head :
 forall (work : nf_list) (ds : disjs) (ni : nested_imps) 
   (ai : atomic_imps) (i : Int) (a a' : atoms),
 EQUIV_INS unit i (fun _ : unit => tt) tt a a' ->
 in_ngamma work ds ni ai a' (NAtom i).

Lemma in_ngamma_ins_a_rev :
 forall (work : nf_list) (ds : disjs) (ni : nested_imps) 
   (ai : atomic_imps) (i : Int) (a a' : atoms) (c : normal_form),
 EQUIV_INS unit i (fun _ : unit => tt) tt a a' ->
 in_ngamma work ds ni ai a' c -> in_ngamma work ds ni ai a c + {c = NAtom i}.

Lemma in_ngamma_shift_work_ds :
 forall (i j : Int) (work : nf_list) (ds : disjs) (ni : nested_imps)
   (ai : atomic_imps) (a : atoms) (c : normal_form),
 in_ngamma (NDisj i j :: work) ds ni ai a c ->
 in_ngamma work ((i, j) :: ds) ni ai a c.

Lemma in_ngamma_shift_ds_work :
 forall (i j : Int) (work : nf_list) (ds : disjs) (ni : nested_imps)
   (ai : atomic_imps) (a : atoms) (c : normal_form),
 in_ngamma work ((i, j) :: ds) ni ai a c ->
 in_ngamma (NDisj i j :: work) ds ni ai a c.

Lemma in_ngamma_shift_work_ni :
 forall (x : nested_imp) (work : nf_list) (ds : disjs) 
   (ni : nested_imps) (ai : atomic_imps) (a : atoms) 
   (c : normal_form),
 in_ngamma (NImp_NF (nested_imp2nimp x) :: work) ds ni ai a c ->
 in_ngamma work ds (x :: ni) ai a c.

Lemma in_ngamma_shift_ni_work :
 forall (x : nested_imp) (work : nf_list) (ds : disjs) 
   (ni : nested_imps) (ai : atomic_imps) (a : atoms) 
   (c : normal_form),
 in_ngamma work ds (x :: ni) ai a c ->
 in_ngamma (NImp_NF (nested_imp2nimp x) :: work) ds ni ai a c.

Lemma in_ngamma_shift_work_ni_x_ni :
 forall (x : nested_imp) (work : nf_list) (ds : disjs)
   (ni1 ni2 : nested_imps) (ai : atomic_imps) (a : atoms) 
   (c : normal_form),
 in_ngamma (NImp_NF (nested_imp2nimp x) :: work) ds (ni1 ++ ni2) ai a c ->
 in_ngamma work ds (ni1 ++ x :: ni2) ai a c.

Lemma in_ngamma_shift_ni_x_ni_work :
 forall (x : nested_imp) (work : nf_list) (ds : disjs)
   (ni1 ni2 : nested_imps) (ai : atomic_imps) (a : atoms) 
   (c : normal_form),
 in_ngamma work ds (ni1 ++ x :: ni2) ai a c ->
 in_ngamma (NImp_NF (nested_imp2nimp x) :: work) ds (ni1 ++ ni2) ai a c.

Lemma in_ngamma_shift_work_ai_new :
 forall (work : nf_list) (ds : disjs) (ni : nested_imps) 
   (i : Int) (b : normal_form) (ai ai' : atomic_imps) 
   (a : atoms) (c : normal_form),
 (forall bs : nf_list, LOOKUP nf_list i ai bs -> False) ->
 EQUIV_INS nf_list i (cons b) nf_nil ai ai' ->
 in_ngamma (AImp i b :: work) ds ni ai a c -> in_ngamma work ds ni ai' a c.

Lemma in_ngamma_shift_work_ai_old :
 forall (work : nf_list) (ds : disjs) (ni : nested_imps) 
   (i : Int) (b : normal_form) (bs : nf_list) (ai ai' : atomic_imps)
   (a : atoms) (c : normal_form),
 LOOKUP nf_list i ai bs ->
 EQUIV_INS nf_list i (cons b) nf_nil ai ai' ->
 in_ngamma (AImp i b :: work) ds ni ai a c -> in_ngamma work ds ni ai' a c.

Lemma in_ngamma_shift_ai_work :
 forall (work : nf_list) (ds : disjs) (ni : nested_imps) 
   (i : Int) (b : normal_form) (ai ai' : atomic_imps) 
   (a : atoms) (c : normal_form),
 EQUIV_INS nf_list i (cons b) nf_nil ai ai' ->
 in_ngamma work ds ni ai' a c -> in_ngamma (AImp i b :: work) ds ni ai a c.

Lemma in_ngamma_shift_work_a :
 forall (work : nf_list) (ds : disjs) (ni : nested_imps) 
   (ai : atomic_imps) (i : Int) (a a' : atoms) (c : normal_form),
 EQUIV_INS unit i (fun _ : unit => tt) tt a a' ->
 in_ngamma (NAtom i :: work) ds ni ai a c -> in_ngamma work ds ni ai a' c.

Lemma in_ngamma_shift_a_work :
 forall (work : nf_list) (ds : disjs) (ni : nested_imps) 
   (ai : atomic_imps) (i : Int) (a a' : atoms) (c : normal_form),
 EQUIV_INS unit i (fun _ : unit => tt) tt a a' ->
 in_ngamma work ds ni ai a' c -> in_ngamma (NAtom i :: work) ds ni ai a c. *)

Definition decorated_nested_imp := (nimp * kripke_tree)%type.
Definition decorated_nested_imps := list decorated_nested_imp.
Definition DNI_NIL := nil (A:=decorated_nested_imp).

Definition decorated_nested_imp2nimp (x : decorated_nested_imp) :=
  match x with
  | (x0, _) => x0
  end.

Definition decorated_nested_imp2k (x : decorated_nested_imp) :=
  match x with
  | (_, k) => k
  end.

Definition decorated_nested_imp2form (x : decorated_nested_imp) :=
  nimp2form (decorated_nested_imp2nimp x).

Fixpoint rev_app (ds : decorated_nested_imps) :
 nested_imps -> nested_imps :=
  match ds with
  | nil => fun ni : nested_imps => ni
  | (x, k) :: ds => fun ni : nested_imps => rev_app ds (Decorated x k :: ni)
  end.

Lemma rev_app_app :
 forall (dni : decorated_nested_imps) (ni : nested_imps),
 rev_app dni ni = rev_app dni NNil ++ ni.
intros dni; elim dni; clear dni.
intros ni; simpl in |- *.
trivial.
intros a; case a; clear a.
intros x k dni ih ni.
simpl in |- *.
 rewrite (ih (Decorated x k :: ni)).
 rewrite (ih (Decorated x k :: NNil)).
symmetry  in |- *.
apply (app_ass (rev_app dni NNil) (Decorated x k :: NNil) ni).
Qed.

Lemma in_app_or_ni :
 forall (x : nested_imp) (ni1 ni2 : nested_imps),
 In x (ni1 ++ ni2) -> In x ni1 \/ In x ni2.
intros x ni1 ni2 in_x.
apply in_app_or.
assumption.
Qed.

Lemma in_ni0_in_nini :
 forall (x : nested_imp) (ni1 ni2 : nested_imps),
 In x ni1 -> In x (ni1 ++ ni2).
intros x ni1 ni2 in_x.
apply in_or_app.
left; assumption.
Qed.

Lemma in_ni1_in_nini :
 forall (x : nested_imp) (ni1 ni2 : nested_imps),
 In x ni2 -> In x (ni1 ++ ni2).
intros x ni1 ni2 in_x.
apply in_or_app.
right; assumption.
Qed.

Lemma in_ni_x_ni_rev :
 forall (x x' : nested_imp) (ni1 ni2 : nested_imps),
 In x (ni1 ++ x' :: ni2) -> In x (ni1 ++ ni2) \/ x = x'.
intros x x' ni1 ni2 in_ni_x_ni.
elim (in_app_or_ni x ni1 (x' :: ni2) in_ni_x_ni); clear in_ni_x_ni.
intros in_ni1; left; apply in_ni0_in_nini; assumption.
intros in_ni2; inversion_clear in_ni2.
right. 
symmetry  in |- *; assumption.
left; apply in_ni1_in_nini; assumption.
Qed.

Lemma in_ni_x_ni_tail :
 forall (x x' : nested_imp) (ni1 ni2 : nested_imps),
 In x (ni1 ++ ni2) -> In x (ni1 ++ x' :: ni2).
intros x x' ni1 ni2 in_nini.
elim (in_app_or_ni x ni1 ni2 in_nini); clear in_nini.
intros in_ni1; apply in_ni0_in_nini; assumption.
intros in_ni2; apply in_ni1_in_nini; right; assumption.
Qed.

Lemma rev_app_lemma0 :
 forall (dni : decorated_nested_imps) (ni : nested_imps),
 {dni_ni : nested_imps | dni_ni = rev_app dni ni}.
intros dni; elim dni; clear dni.
intros ni; exists ni; trivial.
intros x; case x; clear x.
intros n k dni ih ni.
apply (ih (Decorated n k :: ni)).
Qed.

Inductive rev_app_spec (dni : decorated_nested_imps) 
(ni : nested_imps) : Set :=
    Rev_App_Spec_Intro :
      forall dni_ni : nested_imps,
      dni_ni = rev_app dni ni -> rev_app_spec dni ni.

Lemma rev_app_lemma1 :
 forall (dni : decorated_nested_imps) (ni : nested_imps), rev_app_spec dni ni.
intros dni; elim dni; clear dni.
intros ni; exists ni; trivial.
intros x; case x; clear x.
intros n k dni ih ni.
elim (ih (Decorated n k :: ni)).
intros dni_ni eq.
exists dni_ni; assumption.
Qed.

Lemma rev_app_lemma2 :
 forall (A : Set) (dni : decorated_nested_imps) (ni : nested_imps),
 (forall dni_ni : nested_imps, dni_ni = rev_app dni ni -> A) -> A.
intros A dni; elim dni; clear dni.
intros ni sk; apply (sk ni); trivial.
intros x; case x; clear x.
intros n k dni ih ni.
intros sk.
apply (ih (Decorated n k :: ni)).
assumption.

Qed.