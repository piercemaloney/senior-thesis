
Require Export Forms.
(* Forms:
Require Export ML_Int.
Require Export My_Nth.

Inductive form : Set :=
  | Falsum : form
  | Atom : Int -> form
  | AndF : form -> form -> form
  | OrF : form -> form -> form
  | Imp : form -> form -> form.

Definition flist := list form.
Definition fnil := nil (A:=form).

Fixpoint vimp (qs : list Int) : form -> form :=
  match qs with
  | nil => fun a : form => a
  | q :: qs => fun a : form => vimp qs (Imp (Atom q) a)
  end.

Fixpoint subst_form (i : Int) (a b : form) {struct b} : form :=
  match b with
  | Falsum => Falsum
  | Atom j => match equal_dec i j with
              | left _ => a
              | right _ => Atom j
              end
  | OrF b0 b1 => OrF (subst_form i a b0) (subst_form i a b1)
  | AndF b0 b1 => AndF (subst_form i a b0) (subst_form i a b1)
  | Imp b0 b1 => Imp (subst_form i a b0) (subst_form i a b1)
  end.

Definition subst_list (i : Int) (a : form) (l : flist) :=
  map (subst_form i a) l.

Lemma subst_nth :
 forall (i : Int) (g : form) (n : nat) (l : flist) (a : form),
 my_nth form n l a -> my_nth form n (subst_list i g l) (subst_form i g a).

Fixpoint below_form (a : form) (i : Int) {struct a} : Prop :=
  match a with
  | Falsum => True
  | Atom j => Less j i
  | AndF a0 a1 => below_form a0 i /\ below_form a1 i
  | OrF a0 a1 => below_form a0 i /\ below_form a1 i
  | Imp a0 a1 => below_form a0 i /\ below_form a1 i
  end.

Definition below_list (L : flist) (i : Int) :=
  forall a : form, In a L -> below_form a i.

Lemma below_form_less_below_form :
 forall (a : form) (i j : Int), below_form a i -> Less i j -> below_form a j.

Lemma below_list_less_below_list :
 forall (l : flist) (i j : Int), below_list l i -> Less i j -> below_list l j.

Lemma below_cons_list_head :
 forall (a : form) (l : flist) (i : Int),
 below_list (a :: l) i -> below_form a i.

Lemma below_cons_list_tail :
 forall (a : form) (l : flist) (i : Int),
 below_list (a :: l) i -> below_list l i.

Lemma below_cons_list :
 forall (a : form) (l : flist) (i : Int),
 below_form a i -> below_list l i -> below_list (a :: l) i.

Lemma below_list_weak :
 forall (l : flist) (a b : form) (i : Int),
 (below_form a i -> below_form b i) ->
 below_list (a :: l) i -> below_list (b :: l) i.

Lemma below_list_weak2 :
 forall (l : flist) (a b c : form) (i : Int),
 (below_form a i -> below_form b i /\ below_form c i) ->
 below_list (a :: l) i -> below_list (b :: c :: l) i.

Lemma subst_form_below :
 forall (i : Int) (g a : form), below_form a i -> subst_form i g a = a.

Lemma subst_list_below :
 forall (i : Int) (g : form) (l : flist),
 below_list l i -> subst_list i g l = l.

Lemma below_vimp :
 forall (j : Int) (l : list Int) (a b : form),
 (forall j : Int, below_form a j -> below_form b j) ->
 below_form (vimp l a) j -> below_form (vimp l b) j.

Lemma below_vimp2 :
 forall (j : Int) (l : list Int) (a b c : form),
 (forall j : Int, below_form a j -> below_form b j -> below_form c j) ->
 below_form (vimp l a) j ->
 below_form (vimp l b) j -> below_form (vimp l c) j.

Lemma below_vimp_head :
 forall (j : Int) (l : list Int) (a : form),
 below_form (vimp l a) j -> below_form a j.

Lemma below_vimp_split :
 forall (j : Int) (l : list Int) (a : form),
 (forall i : Int, In i l -> Less i j) ->
 below_form a j -> below_form (vimp l a) j.

Lemma below_vimp_tail :
 forall (j : Int) (l : list Int) (a : form),
 below_form (vimp l a) j -> forall i : Int, In i l -> Less i j.

Lemma subst_vimp_head :
 forall (j : Int) (a : form) (l : list Int) (b : form),
 (forall i : Int, In i l -> Less i j) ->
 subst_form j a (vimp l b) = vimp l (subst_form j a b).

Lemma max_int_of_form : forall a : form, {j : Int | below_form a j}.

Lemma max_int_of_list : forall Gamma : flist, {j : Int | below_list Gamma j}. *)

Inductive proof_term : Set :=
  | Var : nat -> proof_term
  | Efq : proof_term -> form -> proof_term
  | Abs : form -> proof_term -> proof_term
  | App : form -> proof_term -> proof_term -> proof_term
  | Pair : proof_term -> proof_term -> proof_term
  | PrL : form -> proof_term -> proof_term
  | PrR : form -> proof_term -> proof_term
  | OrFL : proof_term -> form -> proof_term
  | OrFR : proof_term -> form -> proof_term
  | Cas :
      form -> form -> proof_term -> proof_term -> proof_term -> proof_term
  | Shift : proof_term -> proof_term.

Inductive derives : flist -> proof_term -> form -> Prop :=
  | ByAssumption :
      forall (context : flist) (n : nat) (a : form),
      my_nth form n context a -> derives context (Var n) a
  | ByAbsurdity :
      forall (context : flist) (t : proof_term) (a : form),
      derives context t Falsum -> derives context (Efq t a) a
  | ImpIntro :
      forall (context : flist) (a : form) (r : proof_term) (b : form),
      derives (a :: context) r b -> derives context (Abs a r) (Imp a b)
  | ImpElim :
      forall (context : flist) (r s : proof_term) (a b : form),
      derives context r (Imp a b) ->
      derives context s a -> derives context (App a r s) b
  | AndFIntro :
      forall (context : flist) (r s : proof_term) (a b : form),
      derives context r a ->
      derives context s b -> derives context (Pair r s) (AndF a b)
  | AndFElimL :
      forall (context : flist) (r : proof_term) (a b : form),
      derives context r (AndF a b) -> derives context (PrL b r) a
  | AndFElimR :
      forall (context : flist) (r : proof_term) (a b : form),
      derives context r (AndF a b) -> derives context (PrR a r) b
  | OrFIntroL :
      forall (context : flist) (r : proof_term) (a b : form),
      derives context r a -> derives context (OrFL r b) (OrF a b)
  | OrFIntroR :
      forall (context : flist) (r : proof_term) (a b : form),
      derives context r b -> derives context (OrFR r a) (OrF a b)
  | OrFElim :
      forall (context : flist) (r s t : proof_term) (a b c : form),
      derives context r (OrF a b) ->
      derives (a :: context) s c ->
      derives (b :: context) t c -> derives context (Cas a b r s t) c
  | ShiftIntro :
      forall (context : flist) (r : proof_term) (a b : form),
      derives context r b -> derives (a :: context) (Shift r) b.

Lemma derives_rec :
 forall P : flist -> proof_term -> form -> Set,
 (forall (context : flist) (n : nat) (a : form),
  my_nth form n context a -> P context (Var n) a) ->
 (forall (context : flist) (t : proof_term) (a : form),
  derives context t Falsum -> P context t Falsum -> P context (Efq t a) a) ->
 (forall (context : flist) (a : form) (r : proof_term) (b : form),
  derives (a :: context) r b ->
  P (a :: context) r b -> P context (Abs a r) (Imp a b)) ->
 (forall (context : flist) (r s : proof_term) (a b : form),
  derives context r (Imp a b) ->
  P context r (Imp a b) ->
  derives context s a -> P context s a -> P context (App a r s) b) ->
 (forall (context : flist) (r s : proof_term) (a b : form),
  derives context r a ->
  P context r a ->
  derives context s b -> P context s b -> P context (Pair r s) (AndF a b)) ->
 (forall (context : flist) (r : proof_term) (a b : form),
  derives context r (AndF a b) ->
  P context r (AndF a b) -> P context (PrL b r) a) ->
 (forall (context : flist) (r : proof_term) (a b : form),
  derives context r (AndF a b) ->
  P context r (AndF a b) -> P context (PrR a r) b) ->
 (forall (context : flist) (r : proof_term) (a b : form),
  derives context r a -> P context r a -> P context (OrFL r b) (OrF a b)) ->
 (forall (context : flist) (r : proof_term) (a b : form),
  derives context r b -> P context r b -> P context (OrFR r a) (OrF a b)) ->
 (forall (context : flist) (r s t : proof_term) (a b c : form),
  derives context r (OrF a b) ->
  P context r (OrF a b) ->
  derives (a :: context) s c ->
  P (a :: context) s c ->
  derives (b :: context) t c ->
  P (b :: context) t c -> P context (Cas a b r s t) c) ->
 (forall (context : flist) (r : proof_term) (a b : form),
  derives context r b -> P context r b -> P (a :: context) (Shift r) b) ->
 forall (context : flist) (t : proof_term) (a : form),
 derives context t a -> P context t a.
intros P var efq abs app pari prl prr orl orr cas shift context t.
generalize context; clear context.
elim t; clear t.

intros n context a der.
apply var.
inversion_clear der; assumption.

intros t ih a context b der.
cut (a = b).
intros eq_a;  rewrite eq_a.
apply efq.
inversion_clear der; assumption.
apply ih.
inversion_clear der; assumption.
inversion_clear der; trivial.

intros a t ih context b. 
case b; clear b.
intros der_t; elimtype False; inversion_clear der_t.
intros i der_t; elimtype False; inversion_clear der_t.
intros b0 b1 der_t; elimtype False; inversion_clear der_t.
intros b0 b1 der_t; elimtype False; inversion_clear der_t.
intros b0 b1 der_t.
cut (a = b0).
intros eq_a;  rewrite eq_a.
apply abs.
inversion_clear der_t; assumption.
apply ih.
inversion_clear der_t; assumption.
inversion_clear der_t; trivial.

intros a s ih_s t ih_t context b der.
apply app.
inversion_clear der; assumption.
apply ih_s.
inversion_clear der; assumption.
inversion_clear der; assumption.
apply ih_t.
inversion_clear der; assumption.

intros s ih_s t ih_t context a.
case a; clear a.
intros der; elimtype False; inversion_clear der.
intros i der; elimtype False; inversion_clear der.
intros a0 a1 der.
apply pari.
inversion_clear der; assumption.
apply ih_s.
inversion_clear der; assumption.
inversion_clear der; assumption.
apply ih_t.
inversion_clear der; assumption.
intros a0 a1 der; elimtype False; inversion_clear der.
intros a0 a1 der; elimtype False; inversion_clear der.

intros a s ih context b der.
apply prl.
inversion_clear der; assumption.
apply ih.
inversion_clear der; assumption.

intros a s ih context b der.
apply prr.
inversion_clear der; assumption.
apply ih.
inversion_clear der; assumption.

intros s ih a context b.
case b; clear b.
intros der; elimtype False; inversion_clear der.
intros i der; elimtype False; inversion_clear der.
intros b0 b1 der; elimtype False; inversion_clear der.
intros b0 b1 der.
cut (a = b1).
intros eq_a;  rewrite eq_a.
apply orl.
inversion_clear der; assumption.
apply ih.
inversion_clear der; assumption.
inversion_clear der; trivial.
intros b0 b1 der; elimtype False; inversion_clear der.

intros s ih a context b.
case b; clear b.
intros der; elimtype False; inversion_clear der.
intros i der; elimtype False; inversion_clear der.
intros b0 b1 der; elimtype False; inversion_clear der.
intros b0 b1 der.
cut (a = b0).
intros eq_a;  rewrite eq_a.
apply orr.
inversion_clear der; assumption.
apply ih.
inversion_clear der; assumption.
inversion_clear der; trivial.
intros b0 b1 der; elimtype False; inversion_clear der.

intros a b r ih_r s ih_s t ih_t context c der.
apply cas.
inversion_clear der; assumption.
apply ih_r.
inversion_clear der; assumption.
inversion_clear der; assumption.
apply ih_s.
inversion_clear der; assumption.
inversion_clear der; assumption.
apply ih_t.
inversion_clear der; assumption.

intros t ih context a.
case context; clear context.
intros der; elimtype False; inversion_clear der.
intros b context der.
apply shift.
inversion_clear der; assumption.
apply ih.
inversion_clear der; assumption.
Qed.

