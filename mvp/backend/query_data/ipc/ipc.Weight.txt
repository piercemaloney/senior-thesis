
Require Import Rules.
(* Rules:
Require Export Minimal.
Require Export Sound.
Require Export NSearch.

Inductive search_spec_aux (goal : form) (gamma : flist) 
(work : nf_list) (context : flist) : Set :=
  | derivable :
      Derivable context goal -> search_spec_aux goal gamma work context
  | refutable :
      forall k : kripke_tree,
      Is_Monotone_kripke_tree k ->
      forces_gamma gamma work k ->
      (forces_t k goal -> False) -> search_spec_aux goal gamma work context.

Definition search_spec (goal : form) (gamma : flist) 
  (work : nf_list) (context : flist) (i : Int) :=
  below_form goal i ->
  below_list gamma i ->
  below_list context i ->
  sound gamma work context ->
  minimal gamma work context -> search_spec_aux goal gamma work context.

Lemma rule_shift_gamma_work :
 forall (goal : form) (l : list Int) (a : normal_form) 
   (gamma : flist) (work : nf_list) (context : flist) 
   (j : Int),
 search_spec goal gamma (nvimp l a :: work) context j ->
 search_spec goal (vimp l (nf2form a) :: gamma) work context j.

Lemma search_spec_subst_gamma_pos :
 forall (goal : form) (gamma : flist) (work : nf_list) 
   (context : flist) (j j1 : Int) (a b c : form),
 Less j j1 ->
 (below_form c j -> below_form a j /\ below_form b j1 /\ subst_form j a b = c) ->
 (forall k : kripke_tree,
  Is_Monotone_kripke_tree k ->
  forces_t k b -> forces_t k (Imp (Atom j) a) -> forces_t k c) ->
 search_spec goal (b :: Imp (Atom j) a :: gamma) work
   (b :: Imp (Atom j) a :: context) j1 ->
 search_spec goal (c :: gamma) work context j.

Lemma rule_vimp_a_gamma :
 forall (goal : form) (l : list Int) (a : form) (gamma : flist)
   (work : nf_list) (context : flist) (j j1 : Int),
 Less j j1 ->
 search_spec goal (vimp (j :: nil) a :: gamma) (nvimp l (NAtom j) :: work)
   (vimp l (Atom j) :: Imp (Atom j) a :: context) j1 ->
 search_spec goal (vimp l a :: gamma) work context j.

Lemma rule_vimp_imp_gamma :
 forall (goal : form) (l : list Int) (a b : form) (gamma : flist)
   (work : nf_list) (context : flist) (j j1 : Int),
 Less j j1 ->
 search_spec goal (vimp l (Imp a (Atom j)) :: vimp (j :: nil) b :: gamma)
   work (vimp l (Imp a (Atom j)) :: Imp (Atom j) b :: context) j1 ->
 search_spec goal (vimp l (Imp a b) :: gamma) work context j.

Lemma rule_gamma_falsum :
 forall (gamma : flist) (work : nf_list) (context : flist) (i j : Int),
 Less i j ->
 search_spec (Atom i) gamma work context j ->
 search_spec Falsum gamma work context i.

Lemma rule_gamma_a_imp_b :
 forall (a b : form) (gamma : flist) (work : nf_list) 
   (context : flist) (j : Int),
 search_spec b (a :: gamma) work (a :: context) j ->
 search_spec (Imp a b) gamma work context j.

Lemma rule_gamma_a :
 forall (a : form) (gamma : flist) (work : nf_list) 
   (context : flist) (j j1 : Int),
 Less j j1 ->
 search_spec (Atom j) (Imp a (Atom j) :: gamma) work
   (Imp a (Atom j) :: context) j1 -> search_spec a gamma work context j.

Lemma rule_vimp_conj_gamma :
 forall (goal : form) (l : list Int) (b0 b1 : form) 
   (gamma : flist) (work : nf_list) (context : flist) 
   (j : Int),
 search_spec goal (vimp l b0 :: vimp l b1 :: gamma) work context j ->
 search_spec goal (vimp l (AndF b0 b1) :: gamma) work context j.

Lemma rule_vimp_conj_gamma_new :
 forall (goal : form) (l : list Int) (b0 b1 : form) 
   (gamma : flist) (work : nf_list) (context : flist) 
   (j j1 : Int),
 Less j j1 ->
 search_spec goal (vimp (j :: nil) b0 :: vimp (j :: nil) b1 :: gamma)
   (nvimp l (NAtom j) :: work)
   (vimp l (Atom j) :: Imp (Atom j) (AndF b0 b1) :: context) j1 ->
 search_spec goal (vimp l (AndF b0 b1) :: gamma) work context j.

Lemma rule_vimp_falsum_or_a_gamma :
 forall (goal : form) (l : list Int) (a : form) (gamma : flist)
   (work : nf_list) (context : flist) (j : Int),
 search_spec goal (vimp l a :: gamma) work context j ->
 search_spec goal (vimp l (OrF Falsum a) :: gamma) work context j.

Lemma rule_vimp_a_or_falsum_gamma :
 forall (goal : form) (l : list Int) (a : form) (gamma : flist)
   (work : nf_list) (context : flist) (j : Int),
 search_spec goal (vimp l a :: gamma) work context j ->
 search_spec goal (vimp l (OrF a Falsum) :: gamma) work context j.

Lemma rule_vimp_atom_or_a_gamma :
 forall (goal : form) (l : list Int) (i : Int) (a : form) 
   (gamma : flist) (work : nf_list) (context : flist) 
   (j j1 : Int),
 Less j j1 ->
 search_spec goal (Imp (Atom j) a :: gamma) (nvimp l (NDisj i j) :: work)
   (vimp l (OrF (Atom i) (Atom j)) :: Imp (Atom j) a :: context) j1 ->
 search_spec goal (vimp l (OrF (Atom i) a) :: gamma) work context j.

Lemma rule_vimp_a_or_b_gamma :
 forall (goal : form) (l : list Int) (a b : form) (gamma : flist)
   (work : nf_list) (context : flist) (j j1 : Int),
 Less j j1 ->
 search_spec goal (vimp l (OrF (Atom j) b) :: vimp (j :: nil) a :: gamma)
   work (vimp l (OrF (Atom j) b) :: Imp (Atom j) a :: context) j1 ->
 search_spec goal (vimp l (OrF a b) :: gamma) work context j.

Lemma rule_vimp_falsum_imp_b_gamma :
 forall (goal : form) (l : list Int) (b : form) (gamma : flist)
   (work : nf_list) (context : flist) (j : Int),
 search_spec goal gamma work context j ->
 search_spec goal (vimp l (Imp Falsum b) :: gamma) work context j.

Lemma rule_vimp_atom_imp_b_gamma :
 forall (goal : form) (l : list Int) (i : Int) (b : form) 
   (gamma : flist) (work : nf_list) (context : flist) 
   (j : Int),
 search_spec goal (vimp (i :: l) b :: gamma) work context j ->
 search_spec goal (vimp l (Imp (Atom i) b) :: gamma) work context j.

Lemma rule_vimp_and_imp_gamma :
 forall (goal : form) (l : list Int) (a0 a1 b : form) 
   (gamma : flist) (work : nf_list) (context : flist) 
   (j : Int),
 search_spec goal (vimp l (Imp a0 (Imp a1 b)) :: gamma) work context j ->
 search_spec goal (vimp l (Imp (AndF a0 a1) b) :: gamma) work context j.

Lemma rule_vimp_or_imp_gamma :
 forall (goal : form) (l : list Int) (a0 a1 b : form) 
   (gamma : flist) (work : nf_list) (context : flist) 
   (j : Int),
 search_spec goal (vimp l (Imp a0 b) :: vimp l (Imp a1 b) :: gamma) work
   context j ->
 search_spec goal (vimp l (Imp (OrF a0 a1) b) :: gamma) work context j.

Lemma rule_vimp_or_imp_gamma_new :
 forall (goal : form) (l : list Int) (a0 a1 b : form) 
   (gamma : flist) (work : nf_list) (context : flist) 
   (j j1 : Int),
 Less j j1 ->
 search_spec goal
   (vimp l (Imp a0 (Atom j))
    :: vimp l (Imp a1 (Atom j)) :: vimp (j :: nil) b :: gamma) work
   (vimp l (Imp (OrF a0 a1) (Atom j)) :: Imp (Atom j) b :: context) j1 ->
 search_spec goal (vimp l (Imp (OrF a0 a1) b) :: gamma) work context j.

Lemma rule_vimp_falsum_imp_imp_gamma :
 forall (goal : form) (l : list Int) (b c : form) (gamma : flist)
   (work : nf_list) (context : flist) (j : Int),
 search_spec goal (vimp l c :: gamma) work context j ->
 search_spec goal (vimp l (Imp (Imp Falsum b) c) :: gamma) work context j.

Lemma rule_vimp_imp_falsum_imp_gamma :
 forall (goal : form) (l : list Int) (a c : form) (gamma : flist)
   (work : nf_list) (context : flist) (j j1 : Int),
 Less j j1 ->
 search_spec goal (vimp l (Imp (Imp a (Atom j)) c) :: gamma) work
   (vimp l (Imp (Imp a (Atom j)) c) :: context) j1 ->
 search_spec goal (vimp l (Imp (Imp a Falsum) c) :: gamma) work context j.

Lemma rule_atom_imp_atom_imp_c_gamma :
 forall (goal : form) (l : list Int) (a b : Int) (c : form) 
   (gamma : flist) (work : nf_list) (context : flist) 
   (j j1 : Int),
 Less j j1 ->
 search_spec goal (Imp (Atom j) c :: gamma)
   (nvimp l (NImp_NF (NImp a b (NAtom j))) :: work)
   (vimp l (Imp (Imp (Atom a) (Atom b)) (Atom j))
    :: Imp (Atom j) c :: context) j1 ->
 search_spec goal (vimp l (Imp (Imp (Atom a) (Atom b)) c) :: gamma) work
   context j.

Lemma rule_atom_imp_b_imp_c_gamma :
 forall (goal : form) (l : list Int) (a : Int) (b c : form) 
   (gamma : flist) (work : nf_list) (context : flist) 
   (j j1 : Int),
 Less j j1 ->
 search_spec goal
   (vimp l (Imp (Imp (Atom a) (Atom j)) c)
    :: vimp (a :: l) (Imp b (Atom j)) :: gamma) work
   (vimp l (Imp (Imp (Atom a) (Atom j)) c)
    :: vimp (a :: l) (Imp b (Atom j)) :: context) j1 ->
 search_spec goal (vimp l (Imp (Imp (Atom a) b) c) :: gamma) work context j.

Lemma rule_a_imp_b_imp_c_gamma :
 forall (goal : form) (l : list Int) (a b c : form) 
   (gamma : flist) (work : nf_list) (context : flist) 
   (j j1 : Int),
 Less j j1 ->
 search_spec goal
   (vimp l (Imp (Imp (Atom j) b) c) :: Imp (Atom j) a :: gamma) work
   (vimp l (Imp (Imp (Atom j) b) c) :: Imp (Atom j) a :: context) j1 ->
 search_spec goal (vimp l (Imp (Imp a b) c) :: gamma) work context j. *)

Fixpoint weight (a : form) : nat :=
  match a with
  | Falsum => 1
  | Atom _ => 1
  | AndF a b => S (weight a + weight b)
  | OrF Falsum b => S (weight b)
  | OrF (Atom _) b => S (weight b)
  | OrF a b => S (S (weight b + weight a))
  | Imp a b => weight_neg a + weight b
  end
 
 with weight_neg (a : form) : nat :=
  match a with
  | Falsum => 0
  | Atom _ => 0
  | AndF a b => S (weight_neg a + weight_neg b)
  | OrF a b => S (S (S (weight_neg a + weight_neg b)))
  | Imp Falsum b => 1
  | Imp (Atom _) Falsum => 2
  | Imp (Atom _) (Atom _) => 1
  | Imp (Atom _) b => S (S (S (weight_neg b)))
  | Imp a b => S (S (S (S (weight_neg b + weight a))))
  end.

Fixpoint weight_goal (a : form) : nat :=
  match a with
  | Falsum => 0
  | Atom _ => 0
  | AndF _ _ => 1
  | OrF _ _ => 1
  | Imp _ b => S (weight_goal b)
  end.

Definition weight_gamma :=
  fold_right (fun (a : form) (n : nat) => weight a + n) 0.

Lemma weight_ge_1 : forall a : form, 1 <= weight a.
intros a; elim a; clear a.
trivial.
trivial.
intros; simpl in |- *.
apply le_n_S.
apply le_O_n.
intros a ih_a b ih_b.
clear ih_a ih_b.
case a; clear a; intros; simpl in |- *; apply le_n_S; apply le_O_n.
intros a ih_a b ih_b.
simpl in |- *.
fold weight_neg in |- *.
apply le_trans with (weight b); try assumption.
apply (plus_le_compat_r 0 (weight_neg a) (weight b)).
apply le_O_n.
Qed.

Lemma weight_neg_le :
 forall (j : Int) (a : form),
 weight_neg (Imp (Atom j) a) <= S (S (S (weight_neg a))).
intros j a; case a; clear a.
apply le_n_Sn.
intros; apply le_trans with 2; apply le_n_Sn.
intros; apply le_n.
intros; apply le_n.
intros; apply le_n.
Qed.

Lemma weight_vimp :
 forall (l : list Int) (a : form), weight (vimp l a) = weight a.
intros l.
elim l; clear l.
intro a; trivial.
intros i l ih a.
simpl in |- *.
apply ih with (a := Imp (Atom i) a).
Qed.

Lemma weight_gamma_weak :
 forall (a b : form) (gamma : flist) (n : nat),
 weight a < weight b ->
 weight_gamma (b :: gamma) < S n -> weight_gamma (a :: gamma) < n.
intros.
simpl in |- *.
apply lt_S_n.
apply le_lt_trans with (weight_gamma (b :: gamma)); try assumption.
simpl in |- *.
apply lt_le_S.
apply plus_lt_compat_r.
assumption.
Qed.

Lemma weight_gamma_weak' :
 forall (a b : form) (gamma : flist) (n : nat),
 weight a < weight b ->
 weight b + weight_gamma gamma < S n -> weight a + weight_gamma gamma < n.
intros.
apply (weight_gamma_weak a b gamma n); assumption.
Qed.

Lemma weight_gamma_weak2 :
 forall (a b c : form) (gamma : flist) (n : nat),
 weight a + weight b < weight c ->
 weight_gamma (c :: gamma) < S n -> weight_gamma (a :: b :: gamma) < n.
intros.
simpl in |- *.
apply lt_plus_assoc_l.
apply lt_S_n.
apply le_lt_trans with (weight_gamma (c :: gamma)); try assumption.
simpl in |- *.
apply lt_le_S.
apply plus_lt_compat_r.
assumption.
Qed.

Lemma weight_gamma_weak2' :
 forall (a b c : form) (gamma : flist) (n : nat),
 weight a + weight b < weight c ->
 weight c + weight_gamma gamma < S n ->
 weight a + (weight b + weight_gamma gamma) < n.
intros.
apply (weight_gamma_weak2 a b c gamma n); assumption.
Qed.

Lemma weight_gamma_weak3 :
 forall (a b c d : form) (gamma : flist) (n : nat),
 weight a + weight b + weight c < weight d ->
 weight_gamma (d :: gamma) < S n -> weight_gamma (a :: b :: c :: gamma) < n.
intros.
simpl in |- *.
apply lt_plus_assoc_l.
apply lt_plus_assoc_l.
apply lt_S_n.
apply le_lt_trans with (weight_gamma (d :: gamma)); try assumption.
simpl in |- *.
apply lt_le_S.
apply plus_lt_compat_r.
assumption.
Qed.

Lemma weight_gamma_weak3' :
 forall (a b c d : form) (gamma : flist) (n : nat),
 weight a + weight b + weight c < weight d ->
 weight d + weight_gamma gamma < S n ->
 weight a + (weight b + (weight c + weight_gamma gamma)) < n.
intros.
apply (weight_gamma_weak3 a b c d gamma n); assumption.
Qed.
