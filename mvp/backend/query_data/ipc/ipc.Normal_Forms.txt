
Require Export Forms.
(* Forms:
Require Export ML_Int.
Require Export My_Nth.

Inductive form : Set :=
  | Falsum : form
  | Atom : Int -> form
  | AndF : form -> form -> form
  | OrF : form -> form -> form
  | Imp : form -> form -> form.

Definition flist := list form.
Definition fnil := nil (A:=form).

Fixpoint vimp (qs : list Int) : form -> form :=
  match qs with
  | nil => fun a : form => a
  | q :: qs => fun a : form => vimp qs (Imp (Atom q) a)
  end.

Fixpoint subst_form (i : Int) (a b : form) {struct b} : form :=
  match b with
  | Falsum => Falsum
  | Atom j => match equal_dec i j with
              | left _ => a
              | right _ => Atom j
              end
  | OrF b0 b1 => OrF (subst_form i a b0) (subst_form i a b1)
  | AndF b0 b1 => AndF (subst_form i a b0) (subst_form i a b1)
  | Imp b0 b1 => Imp (subst_form i a b0) (subst_form i a b1)
  end.

Definition subst_list (i : Int) (a : form) (l : flist) :=
  map (subst_form i a) l.

Lemma subst_nth :
 forall (i : Int) (g : form) (n : nat) (l : flist) (a : form),
 my_nth form n l a -> my_nth form n (subst_list i g l) (subst_form i g a).

Fixpoint below_form (a : form) (i : Int) {struct a} : Prop :=
  match a with
  | Falsum => True
  | Atom j => Less j i
  | AndF a0 a1 => below_form a0 i /\ below_form a1 i
  | OrF a0 a1 => below_form a0 i /\ below_form a1 i
  | Imp a0 a1 => below_form a0 i /\ below_form a1 i
  end.

Definition below_list (L : flist) (i : Int) :=
  forall a : form, In a L -> below_form a i.

Lemma below_form_less_below_form :
 forall (a : form) (i j : Int), below_form a i -> Less i j -> below_form a j.

Lemma below_list_less_below_list :
 forall (l : flist) (i j : Int), below_list l i -> Less i j -> below_list l j.

Lemma below_cons_list_head :
 forall (a : form) (l : flist) (i : Int),
 below_list (a :: l) i -> below_form a i.

Lemma below_cons_list_tail :
 forall (a : form) (l : flist) (i : Int),
 below_list (a :: l) i -> below_list l i.

Lemma below_cons_list :
 forall (a : form) (l : flist) (i : Int),
 below_form a i -> below_list l i -> below_list (a :: l) i.

Lemma below_list_weak :
 forall (l : flist) (a b : form) (i : Int),
 (below_form a i -> below_form b i) ->
 below_list (a :: l) i -> below_list (b :: l) i.

Lemma below_list_weak2 :
 forall (l : flist) (a b c : form) (i : Int),
 (below_form a i -> below_form b i /\ below_form c i) ->
 below_list (a :: l) i -> below_list (b :: c :: l) i.

Lemma subst_form_below :
 forall (i : Int) (g a : form), below_form a i -> subst_form i g a = a.

Lemma subst_list_below :
 forall (i : Int) (g : form) (l : flist),
 below_list l i -> subst_list i g l = l.

Lemma below_vimp :
 forall (j : Int) (l : list Int) (a b : form),
 (forall j : Int, below_form a j -> below_form b j) ->
 below_form (vimp l a) j -> below_form (vimp l b) j.

Lemma below_vimp2 :
 forall (j : Int) (l : list Int) (a b c : form),
 (forall j : Int, below_form a j -> below_form b j -> below_form c j) ->
 below_form (vimp l a) j ->
 below_form (vimp l b) j -> below_form (vimp l c) j.

Lemma below_vimp_head :
 forall (j : Int) (l : list Int) (a : form),
 below_form (vimp l a) j -> below_form a j.

Lemma below_vimp_split :
 forall (j : Int) (l : list Int) (a : form),
 (forall i : Int, In i l -> Less i j) ->
 below_form a j -> below_form (vimp l a) j.

Lemma below_vimp_tail :
 forall (j : Int) (l : list Int) (a : form),
 below_form (vimp l a) j -> forall i : Int, In i l -> Less i j.

Lemma subst_vimp_head :
 forall (j : Int) (a : form) (l : list Int) (b : form),
 (forall i : Int, In i l -> Less i j) ->
 subst_form j a (vimp l b) = vimp l (subst_form j a b).

Lemma max_int_of_form : forall a : form, {j : Int | below_form a j}.

Lemma max_int_of_list : forall Gamma : flist, {j : Int | below_list Gamma j}. *)

Inductive normal_form : Set :=
  | NFalsum : normal_form
  | NAtom : Int -> normal_form
  | NDisj : Int -> Int -> normal_form
  | AImp : Int -> normal_form -> normal_form
  | NImp_NF : nimp -> normal_form
with nimp : Set :=
    NImp : Int -> Int -> normal_form -> nimp.

Fixpoint nf2form (x : normal_form) : form :=
  match x with
  | NFalsum => Falsum
  | NAtom i => Atom i
  | NDisj i j => OrF (Atom i) (Atom j)
  | AImp i b => Imp (Atom i) (nf2form b)
  | NImp_NF x => nimp2form x
  end
 
 with nimp2form (x : nimp) : form :=
  match x with
  | NImp i j b => Imp (Imp (Atom i) (Atom j)) (nf2form b)
  end.

Definition nf_list := list normal_form.
Definition nf_nil := nil (A:=normal_form).

Fixpoint nvimp (l : list Int) : normal_form -> normal_form :=
  match l with
  | nil => fun a : normal_form => a
  | i :: l => fun a : normal_form => nvimp l (AImp i a)
  end.

Lemma vimp2nform :
 forall (l : list Int) (a : normal_form),
 {b : normal_form | nf2form b = vimp l (nf2form a)}.
intros l; elim l; clear l.
intros a; exists a; trivial.
intros i l ih a.
elim (ih (AImp i a)); clear ih.
intros b nf_b.
exists b; assumption.
Qed.

Lemma vimp2nvimp :
 forall (l : list Int) (a : normal_form), {b : normal_form | b = nvimp l a}.
intros l; elim l; clear l.
intros a; exists a; trivial.
intros i l ih a.
elim (ih (AImp i a)); clear ih.
intros b nf_b.
exists b; assumption.
Qed.

Lemma vimp_eq_nvimp :
 forall (l : list Int) (a : normal_form),
 vimp l (nf2form a) = nf2form (nvimp l a).
intros l; elim l; clear l.
intros a; trivial.
intros i l ih a.
apply (ih (AImp i a)).
Qed.
