Require Export List. 
Require Export ListSet. 
(* ListSet:
Require Import List.

Set Implicit Arguments.
Unset Strict Implicit.
Section first_definitions.

Variable A : Set.
Hypothesis Aeq_dec : forall x y : A, {x = y} + {x <> y}.

Definition set := list A.

Definition empty_set := nil (A:=A). 
 
  Fixpoint set_add (a : A) (x : set) {struct x} : set :=
    match x with
    | nil => a :: nil
    | a1 :: x1 =>
        match Aeq_dec a a1 with
        | left _ => a1 :: x1
        | right _ => a1 :: set_add a x1
        end
    end. 
 
  Fixpoint set_mem (a : A) (x : set) {struct x} : bool :=
    match x with
    | nil => false
    | a1 :: x1 =>
        match Aeq_dec a a1 with
        | left _ => true
        | right _ => set_mem a x1
        end
    end. 
  
  Fixpoint set_remove (a : A) (x : set) {struct x} : set :=
    match x with
    | nil => empty_set
    | a1 :: x1 =>
        match Aeq_dec a a1 with
        | left _ => set_remove a x1
        | right _ => a1 :: set_remove a x1
        end
    end.
 
  Fixpoint set_inter (x : set) : set -> set :=
    match x with
    | nil => fun y => nil (A:=A)
    | a1 :: x1 =>
        fun y =>
        if set_mem a1 y then a1 :: set_inter x1 y else set_inter x1 y
    end. 
 
  Fixpoint set_union (x y : set) {struct y} : set :=
    match y with
    | nil => x
    | a1 :: y1 => set_add a1 (set_union x y1)
    end. 
         
  Fixpoint set_diff (x : set) : set -> set :=
    fun y =>
    match x with
    | nil => nil (A:=A)
    | a1 :: x1 =>
        if set_mem a1 y then set_diff x1 y else set_add a1 (set_diff x1 y)
    end. 
    
  Definition set_In : A -> set -> Prop := In (A:=A). 
 
Lemma Set_remove1 : forall (B : set) (x : A), ~ set_In x (set_remove x B). 
 
Lemma set_In_dec : forall (a : A) (x : set), {set_In a x} + {~ set_In a x}. 

  Lemma set_mem_ind :
   forall (B : Set) (P : B -> Prop) (y z : B) (a : A) (x : set),
   (set_In a x -> P y) -> P z -> P (if set_mem a x then y else z). 
 
  Lemma set_mem_correct1 :
   forall (a : A) (x : set), set_mem a x = true -> set_In a x. 
 
  Lemma set_mem_correct2 :
   forall (a : A) (x : set), set_In a x -> set_mem a x = true. 
 
  Lemma set_mem_complete1 :
   forall (a : A) (x : set), set_mem a x = false -> ~ set_In a x. 
 
  Lemma set_mem_complete2 :
   forall (a : A) (x : set), ~ set_In a x -> set_mem a x = false. 
 
  Lemma set_add_intro1 :
   forall (a b : A) (x : set), set_In a x -> set_In a (set_add b x). 
 
  Lemma set_add_intro2 :
   forall (a b : A) (x : set), a = b -> set_In a (set_add b x). 
 
  Hint Resolve set_add_intro1 set_add_intro2 Set_remove1. 
 
  Lemma set_add_intro :
   forall (a b : A) (x : set), a = b \/ set_In a x -> set_In a (set_add b x). 
  
  Lemma set_add_elim :
   forall (a b : A) (x : set), set_In a (set_add b x) -> a = b \/ set_In a x. 
 
  Hint Resolve set_add_intro set_add_elim. 
 
  Lemma set_add_not_empty :
   forall (a : A) (x : set), set_add a x <> empty_set. 
 
  Lemma set_union_intro1 :
   forall (a : A) (x y : set), set_In a x -> set_In a (set_union x y). 
 
  Lemma set_union_intro2 :
   forall (a : A) (x y : set), set_In a y -> set_In a (set_union x y). 
 
  Hint Resolve set_union_intro2 set_union_intro1. 
 
  Lemma set_union_intro :
   forall (a : A) (x y : set),
   set_In a x \/ set_In a y -> set_In a (set_union x y). 
 
  Lemma set_union_elim :
   forall (a : A) (x y : set),
   set_In a (set_union x y) -> set_In a x \/ set_In a y. 
 
  Lemma set_inter_intro :
   forall (a : A) (x y : set),
   set_In a x -> set_In a y -> set_In a (set_inter x y). 
 
  Lemma set_inter_elim1 :
   forall (a : A) (x y : set), set_In a (set_inter x y) -> set_In a x. 

  Lemma set_inter_elim2 :
   forall (a : A) (x y : set), set_In a (set_inter x y) -> set_In a y. 
 
  Hint Resolve set_inter_elim1 set_inter_elim2. 
 
  Lemma set_inter_elim :
   forall (a : A) (x y : set),
   set_In a (set_inter x y) -> set_In a x /\ set_In a y. 
 
  Lemma set_diff_intro :
   forall (a : A) (x y : set),
   set_In a x -> ~ set_In a y -> set_In a (set_diff x y). 
 
  Lemma set_diff_elim1 :
   forall (a : A) (x y : set), set_In a (set_diff x y) -> set_In a x. 
 
End first_definitions. 
 
Section other_definitions. 
 
  Variable A B : Set. 
 
  Definition set_prod : set A -> set B -> set (A * B) :=
    list_prod (A:=A) (B:=B). 
 
  Definition set_power : set A -> set B -> set (set (A * B)) :=
    list_power (A:=A) (B:=B). 
 
  Definition set_map : (A -> B) -> set A -> set B := map (A:=A) (B:=B). 
 
  Definition set_fold_left : (B -> A -> B) -> set A -> B -> B :=
    fold_left (A:=B) (B:=A). 
 
  Definition set_fold_right (f : A -> B -> B) (x : set A) 
    (b : B) : B := fold_right f b x. 
 
End other_definitions. 
 
Set Strict Implicit.
Unset Implicit Arguments. *)
Set Implicit Arguments.
Unset Strict Implicit. 
 
Definition front (A : Set) (l : list A) : list A := rev (tail (rev l)). 
 
Definition last (A : Set) (l : list A) := head (rev l). 
 
Fixpoint take (A : Set) (n : nat) (l : list A) {struct l} : 
 list A :=
  match l with
  | nil => nil (A:=A)
  | a :: l' => match n with
               | O => nil (A:=A)
               | S m => a :: take m l'
               end
  end. 

Fixpoint allunique (A : Set) (l : list A) {struct l} : Prop :=
  match l with
  | nil => True
  | x :: l' => IF In x l' then False else allunique l'
  end. 
 
Definition IsEmpty (A : Set) (B : set A) := forall x : A, ~ set_In x B. 
 
Definition Included (A : Set) (B C : set A) :=
  forall x : A, set_In x B -> set_In x C. 
 
Lemma AllWaysIncluded : forall (A : Set) (B : set A), Included B B. 
intros. 
unfold Included in |- *. 
auto. 
 
Qed. 
 
Section ListSetLemmas. 
 
Variable A : Set. 
 
Hypothesis Aeq_dec : forall x y : A, {x = y} + {x <> y}. 
 
Lemma Set_union1 :
 forall (B C : set A) (x : A),
 set_In x (set_union Aeq_dec B C) -> ~ set_In x B -> set_In x C. 
intros. 
cut (set_In x B \/ set_In x C). 
intro H1; elim H1. 
tauto. 
 
auto. 
 
eapply (set_union_elim (Aeq_dec:=Aeq_dec)); auto. 
 
Qed. 
 
Lemma Set_union2 :
 forall (B C : set A) (x : A),
 set_In x (set_union Aeq_dec B C) -> set_In x (set_union Aeq_dec C B). 
intros. 
cut (set_In x C \/ set_In x B). 
intro; apply set_union_intro. 
auto. 
 
cut (set_In x B \/ set_In x C). 
tauto. 
 
eapply (set_union_elim (Aeq_dec:=Aeq_dec)). 
auto. 
 
Qed. 
 
Lemma Set_remove2 :
 forall (B : set A) (x y : A),
 set_In x (set_remove Aeq_dec y B) -> set_In x B. 
intro; intro; intro. 
induction  B as [| a B HrecB]. 
auto. 
 
simpl in |- *. 
elim (Aeq_dec y a). 
intros. 
right. 
auto. 
 
simpl in |- *. 
intro. 
intro. 
elim H. 
intro. 
left; auto. 
 
intro. 
right. 
auto. 
Qed. 
 
Lemma Set_add1 :
 forall (B : set A) (x y : A),
 set_In x (set_add Aeq_dec y B) -> x <> y -> set_In x B. 
intros. 
cut (x = y \/ set_In x B). 
intro. 
elim H1. 
intro. 
absurd (x = y). 
auto. 
 
auto. 
 
intro. 
auto. 
 
eapply (set_add_elim (A:=A) (Aeq_dec:=Aeq_dec) (a:=x) (b:=y) (x:=B)). 
auto. 
 
Qed. 
 
Lemma Set_add2 :
 forall (B : set A) (x y : A),
 x <> y -> ~ set_In x B -> ~ set_In x (set_add Aeq_dec y B). 
intros. 
intro. 
apply H0. 
eapply (Set_add1 (B:=B) (x:=x) (y:=y)); auto. 
 
Qed. 
 
End ListSetLemmas. 
 
Hint Unfold IsEmpty Included. 
Hint Resolve Set_remove2 Set_add1 AllWaysIncluded Set_union1 Set_union2
  Set_add2. 
 
Lemma Listeq_dec :
 forall A : Set,
 (forall a b : A, {a = b} + {a <> b}) ->
 forall x y : list A, {x = y} + {x <> y}. 
simple induction x. 
simple induction y. 
auto. 
 
intros. 
right. 
unfold not in |- *; intro D; discriminate D. 
 
intros. 
induction  y as [| a0 y Hrecy]. 
right; unfold not in |- *; intro D; discriminate D. 
 
elim (H0 y). 
intro. 
rewrite a1. 
elim (H a a0). 
intro. 
rewrite a2. 
left; auto. 
 
intro. 
right. 
unfold not in |- *. 
unfold not in b. 
intro; apply b. 
injection H1. 
auto. 
 
unfold not in |- *; intro. 
right. 
intro; apply b. 
injection H1. 
auto. 
 
Qed. 
 
Hint Resolve Listeq_dec. 
 
Lemma Prodeq_dec :
 forall A B : Set,
 (forall x y : A, {x = y} + {x <> y}) ->
 (forall v w : B, {v = w} + {v <> w}) ->
 forall c d : A * B, {c = d} + {c <> d}. 
intros. 
elim c. 
elim d. 
intros. 
elim (H a a0); intro. 
rewrite a1. 
elim (H0 b b0); intro. 
rewrite a2. 
left; auto. 
 
right. 
intro. 
apply b1. 
injection H1; auto. 
 
right; intro; apply b1. 
injection H1; auto. 
 
Qed. 
 
Hint Resolve Prodeq_dec.