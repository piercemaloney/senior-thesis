Require Export aclstat. 
(* aclstat:
Require Export DACandMAC. 
 
Set Implicit Arguments.
Unset Strict Implicit. 
 
Section Aclstat. 
 
Variable s : SFSstate. 
 
Inductive aclstat (u : SUBJECT) (o : OBJECT) :
SFSstate -> Exc AccessCtrlListData -> Prop :=
    AclstatOK :
      PreDACRead s u o ->
      aclstat u o s
        match facl (acl s) o with
        | None => None (A:=AccessCtrlListData)
        | Some y =>
            Some
              (acldata (owner y) (group y) (UsersReaders y) 
                 (GroupReaders y) (UsersWriters y) 
                 (GroupWriters y) (UsersOwners y) (GroupOwners y))
        end. 
 
End Aclstat. *)
Require Export chmod. 
(* chmod:
Require Export DACandMAC. 
Require Export setACLdata. 
 
Section Chmod. 
 
Variable s : SFSstate. 
 
Let ChangeGAR (o : OBJECT) (oct : RIGHTS) : Exc (set GRPNAME) :=
  match facl (acl s) o with
  | None => None (A:=set GRPNAME)
  | Some y =>
      Some
        (ChangeGroupR (AllGrp s) oct
           (ChangeGroupR (group y) oct (GroupReaders y)))
  end. 
 
Let ChangeGAW (o : OBJECT) (oct : RIGHTS) : Exc (set GRPNAME) :=
  match facl (acl s) o with
  | None => None (A:=set GRPNAME)
  | Some y =>
      Some
        (ChangeGroupW (AllGrp s) oct
           (ChangeGroupW (group y) oct (GroupWriters y)))
  end. 
 
Let NEW (u : SUBJECT) (o : OBJECT) (perms : PERMS) :
  Exc AccessCtrlListData :=
  match
    facl (acl s) o, ChangeGAR o (groupp perms), ChangeGAW o (groupp perms)
  with
  | None, _, _ => None (A:=AccessCtrlListData)
  | _, None, _ => None (A:=AccessCtrlListData)
  | _, _, None => None (A:=AccessCtrlListData)
  | Some y, Some gar, Some gaw =>
      Some
        (acldata (owner y) (group y)
           (ChangeUserR u (UsersReaders y) (ownerp perms)) gar
           (ChangeUserW u (UsersWriters y) (ownerp perms)) gaw
           (UsersOwners y) (GroupOwners y))
  end. 
 
Definition chmod_acl (u : SUBJECT) (o : OBJECT) (perms : PERMS) :
  set (OBJECT * AccessCtrlListData) :=
  match facl (acl s) o, NEW u o perms with
  | None, _ => acl s
  | _, None => acl s
  | Some y, Some z =>
      set_add ACLeq_dec (o, z) (set_remove ACLeq_dec (o, y) (acl s))
  end. 
 
Let t (u : SUBJECT) (o : OBJECT) (perms : PERMS) : SFSstate :=
  mkSFS (groups s) (primaryGrp s) (subjectSC s) (AllGrp s) 
    (RootGrp s) (SecAdmGrp s) (objectSC s) (chmod_acl u o perms) 
    (secmat s) (files s) (directories s). 
 
Inductive chmod (u : SUBJECT) (o : OBJECT) (perms : PERMS) :
SFSstate -> Prop :=
    ChmodOK :
      ExecuterIsOwner s u o ->
      ~ set_In o (domsecmat (secmat s)) -> chmod u o perms (t u o perms). 
 
Hint Resolve ChangeGAR ChangeGAW chmod_acl t. 

End Chmod. *)
Require Export create. 
(* create:
Require Export DACandMAC. 
Require Export setACLdata. 
 
Section Create. 
 
Variable s : SFSstate. 
 
Definition NEWFILE (p : OBJNAME) : OBJECT := (p, File). 
 
Definition create_oSC (u : SUBJECT) (p : OBJNAME) :
  set (OBJECT * SecClass) :=
  match fSSC (subjectSC s) u, fsecmat (secmat s) (MyDir p) with
  | None, _ => objectSC s
  | _, None => objectSC s
  | Some y, Some z => set_add OSCeq_dec (NEWFILE p, y) (objectSC s)
  end. 
 
Let ChangeGAR (u : SUBJECT) (oct : RIGHTS) : set GRPNAME :=
  ChangeGroupR (AllGrp s) oct
    (ChangeGroupR (primaryGrp s u) oct (empty_set GRPNAME)). 
 
Let ChangeGAW (u : SUBJECT) (oct : RIGHTS) : set GRPNAME :=
  ChangeGroupW (AllGrp s) oct
    (ChangeGroupW (primaryGrp s u) oct (empty_set GRPNAME)). 
 
Let NEW (u : SUBJECT) (p : OBJNAME) (perms : PERMS) : AccessCtrlListData :=
  acldata u (primaryGrp s u)
    (ChangeUserR u (empty_set SUBJECT) (ownerp perms))
    (ChangeGAR u (groupp perms))
    (ChangeUserW u (empty_set SUBJECT) (ownerp perms))
    (ChangeGAW u (groupp perms)) (set_add SUBeq_dec u (empty_set SUBJECT))
    (ChangeGroupO (RootGrp s) (empty_set GRPNAME)). 
 
Definition create_acl (u : SUBJECT) (p : OBJNAME) (perms : PERMS) :
  set (OBJECT * AccessCtrlListData) :=
  match fSSC (subjectSC s) u, fsecmat (secmat s) (MyDir p) with
  | None, _ => acl s
  | _, None => acl s
  | Some y, Some z => set_add ACLeq_dec (NEWFILE p, NEW u p perms) (acl s)
  end. 
 
Let t (u : SUBJECT) (p : OBJNAME) (perms : PERMS) : SFSstate :=
  mkSFS (groups s) (primaryGrp s) (subjectSC s) (AllGrp s) 
    (RootGrp s) (SecAdmGrp s) (create_oSC u p) (create_acl u p perms)
    (secmat s) (create_files u p) (create_directories u p). 
 
Inductive create (u : SUBJECT) (p : OBJNAME) (perms : PERMS) :
SFSstate -> Prop :=
    CreateOK :
      ~ set_In (p, File) (domf (files s)) ->
      ~ set_In (p, Directory) (domd (directories s)) ->
      set_In (MyDir p) (domd (directories s)) ->
      match fsecmat (secmat s) (MyDir p) with
      | None => False
      | Some y => set_In u (ActWriters y)
      end -> create u p perms (t u p perms). 
 
End Create. 
 
Hint Unfold create_oSC create_acl. *)
Require Export mkdir. 
(* mkdir:
Require Export DACandMAC. 
Require Export setACLdata. 
 
Set Implicit Arguments.
Unset Strict Implicit. 
 
Section Mkdir. 
 
Variable s : SFSstate. 
 
Definition NEWDIR (p : OBJNAME) : OBJECT := (p, Directory). 
 
Definition mkdir_oSC (u : SUBJECT) (p : OBJNAME) : 
  set (OBJECT * SecClass) :=
  match fSSC (subjectSC s) u, fsecmat (secmat s) (MyDir p) with
  | None, _ => objectSC s
  | _, None => objectSC s
  | Some y, Some z => set_add OSCeq_dec (NEWDIR p, y) (objectSC s)
  end. 
 
Let ChangeGAR (u : SUBJECT) (oct : RIGHTS) : set GRPNAME :=
  ChangeGroupR (AllGrp s) oct
    (ChangeGroupR (primaryGrp s u) oct (empty_set GRPNAME)). 
 
Let ChangeGAW (u : SUBJECT) (oct : RIGHTS) : set GRPNAME :=
  ChangeGroupW (AllGrp s) oct
    (ChangeGroupW (primaryGrp s u) oct (empty_set GRPNAME)). 
 
Let NEW (u : SUBJECT) (p : OBJNAME) (perms : PERMS) : AccessCtrlListData :=
  acldata u (primaryGrp s u)
    (ChangeUserR u (empty_set SUBJECT) (ownerp perms))
    (ChangeGAR u (groupp perms))
    (ChangeUserW u (empty_set SUBJECT) (ownerp perms))
    (ChangeGAW u (groupp perms)) (set_add SUBeq_dec u (empty_set SUBJECT))
    (ChangeGroupO (RootGrp s) (empty_set GRPNAME)). 
 
Definition mkdir_acl (u : SUBJECT) (p : OBJNAME) (perms : PERMS) :
  set (OBJECT * AccessCtrlListData) :=
  match fSSC (subjectSC s) u, fsecmat (secmat s) (MyDir p) with
  | None, _ => acl s
  | _, None => acl s
  | Some y, Some z => set_add ACLeq_dec (NEWDIR p, NEW u p perms) (acl s)
  end. 
 
Let t (u : SUBJECT) (p : OBJNAME) (perms : PERMS) : SFSstate :=
  mkSFS (groups s) (primaryGrp s) (subjectSC s) (AllGrp s) 
    (RootGrp s) (SecAdmGrp s) (mkdir_oSC u p) (mkdir_acl u p perms)
    (secmat s) (files s) (mkdir_directories u p). 
 
Inductive mkdir (u : SUBJECT) (p : OBJNAME) (perms : PERMS) :
SFSstate -> Prop :=
    MkdirOK :
      ~ set_In (p, File) (domf (files s)) ->
      ~ set_In (p, Directory) (domd (directories s)) ->
      set_In (MyDir p) (domd (directories s)) ->
      match fsecmat (secmat s) (MyDir p) with
      | None => False
      | Some y => set_In u (ActWriters y)
      end -> mkdir u p perms (t u p perms). 
 
End Mkdir. 
 
Hint Unfold mkdir_oSC mkdir_acl. *)
Require Export open. 
(* open:
Require Export DACandMAC. 
 
Section Open. 
 
Variable s : SFSstate. 
 
Definition open_sm (u : SUBJECT) (o : OBJECT) (m : MODE) :
  set (OBJECT * ReadersWriters) :=
  match fsecmat (secmat s) o with
  | None =>
      match m with
      | READ =>
          set_add SECMATeq_dec
            (o,
            mkRW (set_add SUBeq_dec u (empty_set SUBJECT))
              (empty_set SUBJECT)) (secmat s)
      | WRITE =>
          set_add SECMATeq_dec
            (o,
            mkRW (empty_set SUBJECT)
              (set_add SUBeq_dec u (empty_set SUBJECT))) 
            (secmat s)
      end
  | Some y =>
      match m with
      | READ =>
          set_add SECMATeq_dec
            (o, mkRW (set_add SUBeq_dec u (ActReaders y)) (ActWriters y))
            (set_remove SECMATeq_dec (o, y) (secmat s))
      | WRITE =>
          set_add SECMATeq_dec
            (o, mkRW (ActReaders y) (set_add SUBeq_dec u (ActWriters y)))
            (set_remove SECMATeq_dec (o, y) (secmat s))
      end
  end. 
 
Let t (u : SUBJECT) (o : OBJECT) (m : MODE) : SFSstate :=
  mkSFS (groups s) (primaryGrp s) (subjectSC s) (AllGrp s) 
    (RootGrp s) (SecAdmGrp s) (objectSC s) (acl s) 
    (open_sm u o m) (files s) (directories s). 
 
Inductive open (u : SUBJECT) (o : OBJECT) : MODE -> SFSstate -> Prop :=
  | OpenRead :
      InFileSystem s o ->
      PreDACRead s u o ->
      PreMAC s u o -> PreStarPropRead s u o -> open u o READ (t u o READ)
  | OpenWrite :
      InFileSystem s o ->
      PreDACWrite s u o ->
      PreMAC s u o -> PreStarPropWrite s u o -> open u o WRITE (t u o WRITE). 
 
Hint Unfold open_sm t. 
 
End Open. *)
Require Export addUsrGrpToAcl. 
(* addUsrGrpToAcl:
Require Export DACandMAC. 
 
Set Implicit Arguments.
Unset Strict Implicit. 
 
Section AddUsrGrpToAcl. 
 
Variable s : SFSstate. 
 
Let NEW (o : OBJECT) (ru wu pu : SUBJECT) (rg wg pg : GRPNAME) :
  Exc AccessCtrlListData :=
  match facl (acl s) o with
  | None => None (A:=AccessCtrlListData)
  | Some y =>
      Some
        (acldata (owner y) (group y) (set_add SUBeq_dec ru (UsersReaders y))
           (set_add GRPeq_dec rg (GroupReaders y))
           (set_add SUBeq_dec wu (UsersWriters y))
           (set_add GRPeq_dec wg (GroupWriters y))
           (set_add SUBeq_dec pu (UsersOwners y))
           (set_add GRPeq_dec pg (GroupOwners y)))
  end. 
 
Definition addUsrGrpToAcl_acl (o : OBJECT) (ru wu pu : SUBJECT)
  (rg wg pg : GRPNAME) : set (OBJECT * AccessCtrlListData) :=
  match facl (acl s) o, NEW o ru wu pu rg wg pg with
  | None, _ => acl s
  | _, None => acl s
  | Some y, Some z =>
      set_add ACLeq_dec (o, z) (set_remove ACLeq_dec (o, y) (acl s))
  end. 
 
Let t (o : OBJECT) (ru wu pu : SUBJECT) (rg wg pg : GRPNAME) : SFSstate :=
  mkSFS (groups s) (primaryGrp s) (subjectSC s) (AllGrp s) 
    (RootGrp s) (SecAdmGrp s) (objectSC s)
    (addUsrGrpToAcl_acl o ru wu pu rg wg pg) (secmat s) 
    (files s) (directories s). 
 
Inductive addUsrGrpToAcl (u : SUBJECT) (o : OBJECT) 
(ru wu pu : SUBJECT) (rg wg pg : GRPNAME) : SFSstate -> Prop :=
    addUsrGrpToAclOK :
      ExecuterIsOwner s u o ->
      ~ set_In o (domsecmat (secmat s)) ->
      addUsrGrpToAcl u o ru wu pu rg wg pg (t o ru wu pu rg wg pg). 
 
Hint Unfold addUsrGrpToAcl_acl t. 
 
End AddUsrGrpToAcl. *)
Require Export chobjsc. 
(* chobjsc:
Require Export DACandMAC. 
 
Section Chobjsc. 
 
Variable s : SFSstate. 
 
Definition chobjsc_SC (o : OBJECT) (sc : SecClass) :
  set (OBJECT * SecClass) :=
  match fOSC (objectSC s) o with
  | None => objectSC s
  | Some y =>
      set_add OSCeq_dec (o, sc) (set_remove OSCeq_dec (o, y) (objectSC s))
  end. 
 
Let t (o : OBJECT) (sc : SecClass) : SFSstate :=
  mkSFS (groups s) (primaryGrp s) (subjectSC s) (AllGrp s) 
    (RootGrp s) (SecAdmGrp s) (chobjsc_SC o sc) (acl s) 
    (secmat s) (files s) (directories s). 
 
Inductive chobjsc (secadm : SUBJECT) (o : OBJECT) (sc : SecClass) :
SFSstate -> Prop :=
    chsobjscOK :
      set_In secadm (groups s (SecAdmGrp s)) ->
      ~ set_In o (domsecmat (secmat s)) -> chobjsc secadm o sc (t o sc). 
 
End Chobjsc. 
 
Hint Unfold chobjsc_SC. *)
Require Export chown. 
(* chown:
Require Export DACandMAC. 
 
Section Chown. 
 
Variable s : SFSstate. 
 
Let NEW_GRP (old new : GRPNAME) (gs : set GRPNAME) : 
  set GRPNAME :=
  match set_In_dec GRPeq_dec old gs with
  | left _ => set_add GRPeq_dec new (set_remove GRPeq_dec old gs)
  | right _ => gs
  end. 
 
Let NEW_UO (old new : SUBJECT) (us : set SUBJECT) : 
  set SUBJECT := set_add SUBeq_dec new (set_remove SUBeq_dec old us). 
 
Let NEW (o : OBJECT) (p : SUBJECT) (g : GRPNAME) : 
  Exc AccessCtrlListData :=
  match facl (acl s) o with
  | None => None (A:=AccessCtrlListData)
  | Some y =>
      Some
        (acldata p g (UsersReaders y) (NEW_GRP (group y) g (GroupReaders y))
           (UsersWriters y) (NEW_GRP (group y) g (GroupWriters y))
           (NEW_UO (owner y) p (UsersOwners y)) (GroupOwners y))
  end. 
 
Definition chown_acl (o : OBJECT) (p : SUBJECT) (g : GRPNAME) :
  set (OBJECT * AccessCtrlListData) :=
  match facl (acl s) o, NEW o p g with
  | None, _ => acl s
  | _, None => acl s
  | Some y, Some z =>
      set_add ACLeq_dec (o, z) (set_remove ACLeq_dec (o, y) (acl s))
  end. 
 
Let t (o : OBJECT) (p : SUBJECT) (g : GRPNAME) : SFSstate :=
  mkSFS (groups s) (primaryGrp s) (subjectSC s) (AllGrp s) 
    (RootGrp s) (SecAdmGrp s) (objectSC s) (chown_acl o p g) 
    (secmat s) (files s) (directories s). 
 
Inductive chown (u : SUBJECT) (o : OBJECT) (p : SUBJECT) 
(g : GRPNAME) : SFSstate -> Prop :=
    ChownOK :
      ExecuterIsOwner s u o ->
      ~ set_In o (domsecmat (secmat s)) -> chown u o p g (t o p g). 
 
Hint Unfold chown_acl t. 
 
End Chown. *)
Require Export chsubsc. 
(* chsubsc:
Require Export DACandMAC. 
 
Section Chsubsc. 
 
Variable s : SFSstate. 
 
Definition chsubsc_SC (v : SUBJECT) (sc : SecClass) :
  set (SUBJECT * SecClass) :=
  match fSSC (subjectSC s) v with
  | None => subjectSC s
  | Some y =>
      set_add SSCeq_dec (v, sc) (set_remove SSCeq_dec (v, y) (subjectSC s))
  end. 
 
Let t (u : SUBJECT) (sc : SecClass) : SFSstate :=
  mkSFS (groups s) (primaryGrp s) (chsubsc_SC u sc) 
    (AllGrp s) (RootGrp s) (SecAdmGrp s) (objectSC s) 
    (acl s) (secmat s) (files s) (directories s). 
 
Inductive chsubsc (secadm u : SUBJECT) (sc : SecClass) : SFSstate -> Prop :=
    chsubscOK :
      set_In secadm (groups s (SecAdmGrp s)) ->
      (forall rw : ReadersWriters,
       ~ set_In u (ActReaders rw) /\ ~ set_In u (ActWriters rw)) ->
      chsubsc secadm u sc (t u sc). 
 
End Chsubsc. 
 
Hint Unfold chsubsc_SC. *)
Require Export close. 
(* close:
Require Import DACandMAC. 
 
Section Close. 
 
Variable s : SFSstate. 
 
Definition NEWRW (u : SUBJECT) (o : OBJECT) (y : ReadersWriters) :
  ReadersWriters :=
  mkRW (set_remove SUBeq_dec u (ActReaders y))
    (set_remove SUBeq_dec u (ActWriters y)). 
 
Let NEWSET (u : SUBJECT) (o : OBJECT) (y : ReadersWriters) :
  set (OBJECT * ReadersWriters) :=
  match
    set_remove SUBeq_dec u (ActReaders y),
    set_remove SUBeq_dec u (ActWriters y)
  with
  | nil, nil => set_remove SECMATeq_dec (o, y) (secmat s)
  | _, _ =>
      set_add SECMATeq_dec (o, NEWRW u o y)
        (set_remove SECMATeq_dec (o, y) (secmat s))
  end. 
 
Definition close_sm (u : SUBJECT) (o : OBJECT) :
  set (OBJECT * ReadersWriters) :=
  match fsecmat (secmat s) o with
  | None => secmat s
  | Some y => NEWSET u o y
  end. 
 
Let t (u : SUBJECT) (o : OBJECT) : SFSstate :=
  mkSFS (groups s) (primaryGrp s) (subjectSC s) (AllGrp s) 
    (RootGrp s) (SecAdmGrp s) (objectSC s) (acl s) 
    (close_sm u o) (files s) (directories s). 
 
Inductive close (u : SUBJECT) (o : OBJECT) : SFSstate -> Prop :=
    CloseOK :
      match fsecmat (secmat s) o with
      | None => False
      | Some y =>
          set_In u (set_union SUBeq_dec (ActReaders y) (ActWriters y))
      end -> close u o (t u o). 
 
Hint Unfold close_sm t. 
 
End Close. *)
Require Export delUsrGrpFromAcl. 
(* delUsrGrpFromAcl:
Require Export DACandMAC. 
 
Section DelUsrGrpFromAcl. 
 
Variable s : SFSstate. 
 
Let NEWOWNER (owner pu : SUBJECT) : SUBJECT :=
  match SUBeq_dec owner pu with
  | left _ => root
  | right _ => owner
  end. 
 
Let NEW_UO (owner pu : SUBJECT) (us : set SUBJECT) : 
  set SUBJECT :=
  match SUBeq_dec owner pu with
  | left _ => set_add SUBeq_dec root (set_remove SUBeq_dec pu us)
  | right _ => set_remove SUBeq_dec pu us
  end. 
 
Let NEW (o : OBJECT) (ru wu pu : SUBJECT) (rg wg pg : GRPNAME) :
  Exc AccessCtrlListData :=
  match facl (acl s) o with
  | None => None (A:=AccessCtrlListData)
  | Some y =>
      Some
        (acldata (NEWOWNER (owner y) pu) (group y)
           (set_remove SUBeq_dec ru (UsersReaders y))
           (set_remove GRPeq_dec rg (GroupReaders y))
           (set_remove SUBeq_dec wu (UsersWriters y))
           (set_remove GRPeq_dec wg (GroupWriters y))
           (NEW_UO (owner y) pu (UsersOwners y))
           (set_remove GRPeq_dec pg (GroupOwners y)))
  end. 
 
Definition delUsrGrpFromAcl_acl (o : OBJECT) (ru wu pu : SUBJECT)
  (rg wg pg : GRPNAME) : set (OBJECT * AccessCtrlListData) :=
  match facl (acl s) o, NEW o ru wu pu rg wg pg with
  | None, _ => acl s
  | _, None => acl s
  | Some y, Some z =>
      set_add ACLeq_dec (o, z) (set_remove ACLeq_dec (o, y) (acl s))
  end. 
 
Let t (o : OBJECT) (ru wu pu : SUBJECT) (rg wg pg : GRPNAME) : SFSstate :=
  mkSFS (groups s) (primaryGrp s) (subjectSC s) (AllGrp s) 
    (RootGrp s) (SecAdmGrp s) (objectSC s)
    (delUsrGrpFromAcl_acl o ru wu pu rg wg pg) (secmat s) 
    (files s) (directories s). 
 
Inductive delUsrGrpFromAcl (u : SUBJECT) (o : OBJECT) 
(ru wu pu : SUBJECT) (rg wg pg : GRPNAME) : SFSstate -> Prop :=
    delUsrGrpFromAclOK :
      ExecuterIsOwner s u o ->
      ~ set_In o (domsecmat (secmat s)) ->
      pg <> RootGrp s ->
      delUsrGrpFromAcl u o ru wu pu rg wg pg (t o ru wu pu rg wg pg). 
          
Hint Unfold delUsrGrpFromAcl_acl t. 
 
End DelUsrGrpFromAcl. *)
Require Export oscstat. 
(* oscstat:
Require Export DACandMAC. 
 
Section Oscstat. 
 
Variable s : SFSstate. 
 
Inductive oscstat (u : SUBJECT) (o : OBJECT) :
SFSstate -> Exc SecClass -> Prop :=
    OscstatOK : PreMAC s u o -> oscstat u o s (fOSC (objectSC s) o). 
 
End Oscstat. *)
Require Export owner_close. 
(* owner_close:
Require Import DACandMAC. 
 
Section Owner_Close. 
 
Variable s : SFSstate. 
 
Definition NEWRWOC (u : SUBJECT) (o : OBJECT) (y : ReadersWriters) :
  ReadersWriters :=
  mkRW (set_remove SUBeq_dec u (ActReaders y))
    (set_remove SUBeq_dec u (ActWriters y)). 
 
Let NEWSET (u : SUBJECT) (o : OBJECT) (y : ReadersWriters) :
  set (OBJECT * ReadersWriters) :=
  match
    set_remove SUBeq_dec u (ActReaders y),
    set_remove SUBeq_dec u (ActWriters y)
  with
  | nil, nil => set_remove SECMATeq_dec (o, y) (secmat s)
  | _, _ =>
      set_add SECMATeq_dec (o, NEWRWOC u o y)
        (set_remove SECMATeq_dec (o, y) (secmat s))
  end. 
 
Definition ownerclose_sm (u : SUBJECT) (o : OBJECT) :
  set (OBJECT * ReadersWriters) :=
  match fsecmat (secmat s) o with
  | None => secmat s
  | Some y => NEWSET u o y
  end. 
 
Let t (u : SUBJECT) (o : OBJECT) : SFSstate :=
  mkSFS (groups s) (primaryGrp s) (subjectSC s) (AllGrp s) 
    (RootGrp s) (SecAdmGrp s) (objectSC s) (acl s) 
    (ownerclose_sm u o) (files s) (directories s). 
 
Inductive owner_close (owner u : SUBJECT) (o : OBJECT) : SFSstate -> Prop :=
    Owner_CloseOK :
      match fsecmat (secmat s) o with
      | None => False
      | Some y =>
          set_In u (set_union SUBeq_dec (ActReaders y) (ActWriters y))
      end -> ExecuterIsOwner s owner o -> owner_close owner u o (t u o). 
 
End Owner_Close. 
 
Hint Unfold ownerclose_sm. *)
Require Export read. 
(* read:
Require Export DACandMAC. 
Require Export open. 
Set Implicit Arguments.
Unset Strict Implicit. 
 
Section Read. 
 
Variable s : SFSstate. 
 
Inductive read (u : SUBJECT) (o : OBJECT) (n : nat) :
SFSstate -> Exc FILECONT -> Prop :=
    ReadOK :
      ObjType o = File ->
      match fsecmat (secmat s) o with
      | None => False
      | Some y => set_In u (ActReaders y)
      end ->
      read u o n s
        match fsecmat (secmat s) o, ffiles (files s) o with
        | None, _ => None (A:=FILECONT)
        | _, None => None (A:=FILECONT)
        | Some y, Some z => Some (take n z)
        end. 
 
End Read. *)
Require Export readdir. 
(* readdir:
Require Export DACandMAC. 
 
Section Readdir. 
 
Variable s : SFSstate. 
 
Inductive readdir (u : SUBJECT) (o : OBJECT) (n : nat) :
SFSstate -> Exc DIRCONT -> Prop :=
    ReaddirOK :
      ObjType o = Directory ->
      match fsecmat (secmat s) o with
      | None => False
      | Some y => set_In u (ActReaders y)
      end ->
      readdir u o n s
        match fsecmat (secmat s) o, fdirs (directories s) o with
        | None, _ => None (A:=DIRCONT)
        | _, None => None (A:=DIRCONT)
        | Some y, Some z => Some (take n z)
        end. 
 
End Readdir. *)
Require Export rmdir. 
(* rmdir:
Require Export DACandMAC. 
 
Section Rmdir. 
 
Variable s : SFSstate. 
 
Definition rmdir_oSC (o : OBJECT) : set (OBJECT * SecClass) :=
  match fOSC (objectSC s) o with
  | None => objectSC s
  | Some y => set_remove OSCeq_dec (o, y) (objectSC s)
  end. 
 
Definition rmdir_acl (o : OBJECT) : set (OBJECT * AccessCtrlListData) :=
  match facl (acl s) o with
  | None => acl s
  | Some y => set_remove ACLeq_dec (o, y) (acl s)
  end. 
 
Let t (o : OBJECT) : SFSstate :=
  mkSFS (groups s) (primaryGrp s) (subjectSC s) (AllGrp s) 
    (RootGrp s) (SecAdmGrp s) (rmdir_oSC o) (rmdir_acl o) 
    (secmat s) (files s) (rmdir_directories o). 
 
Inductive rmdir (u : SUBJECT) (o : OBJECT) : SFSstate -> Prop :=
    RmdirOK :
      ObjType o = Directory ->
      set_In (MyDir (ObjName o)) (domd (directories s)) ->
      match fsecmat (secmat s) (MyDir (ObjName o)) with
      | None => False
      | Some y => set_In u (ActWriters y)
      end -> ~ set_In o (domsecmat (secmat s)) -> rmdir u o (t o). 
 
End Rmdir. 
 
Hint Unfold rmdir_oSC rmdir_acl. *)
Require Export sscstat. 
(* sscstat:
Require Export SFSstate. 
Set Implicit Arguments.
Unset Strict Implicit. 
 
Section Sscstat. 
 
Variable s : SFSstate. 
 
Inductive sscstat (u user : SUBJECT) : SFSstate -> Exc SecClass -> Prop :=
    SscstatOK :
      match fSSC (subjectSC s) user, fSSC (subjectSC s) u with
      | None, _ => True
      | _, None => True
      | Some y, Some z => le_sc y z
      end -> sscstat u user s (fSSC (subjectSC s) user). 
 
End Sscstat. *)
Require Export stat. 
(* stat:
Require Export DACandMAC. 
Set Implicit Arguments.
Unset Strict Implicit. 
 
Section Stat. 
 
Variable s : SFSstate. 
 
Parameter comp_mode : AccessCtrlListData -> PERMS. 
 
Record stat_struct : Set := stat_fields
  {st_mode : PERMS; st_uid : SUBJECT; st_gid : GRPNAME}. 
 
Inductive stat (u : SUBJECT) (o : OBJECT) :
SFSstate -> Exc stat_struct -> Prop :=
    StatOK :
      PreDACRead s u o ->
      stat u o s
        match facl (acl s) o with
        | None => None (A:=stat_struct)
        | Some y => Some (stat_fields (comp_mode y) (owner y) (group y))
        end. 
 
End Stat. *)
Require Export unlink. 
(* unlink:
Require Export DACandMAC. 
 
Section Unlink. 
 
Variable s : SFSstate. 
 
Definition unlink_oSC (o : OBJECT) : set (OBJECT * SecClass) :=
  match fOSC (objectSC s) o with
  | None => objectSC s
  | Some y => set_remove OSCeq_dec (o, y) (objectSC s)
  end. 
 
Definition unlink_acl (o : OBJECT) : set (OBJECT * AccessCtrlListData) :=
  match facl (acl s) o with
  | None => acl s
  | Some y => set_remove ACLeq_dec (o, y) (acl s)
  end. 
 
Let t (o : OBJECT) : SFSstate :=
  mkSFS (groups s) (primaryGrp s) (subjectSC s) (AllGrp s) 
    (RootGrp s) (SecAdmGrp s) (unlink_oSC o) (unlink_acl o) 
    (secmat s) (unlink_files o) (unlink_directories o). 
 
Inductive unlink (u : SUBJECT) (o : OBJECT) : SFSstate -> Prop :=
    UnlinkOK :
      ObjType o = File ->
      set_In (MyDir (ObjName o)) (domd (directories s)) ->
      match fsecmat (secmat s) (MyDir (fst o)) with
      | None => False
      | Some y => set_In u (ActWriters y)
      end -> ~ set_In o (domsecmat (secmat s)) -> unlink u o (t o).              
 
End Unlink. 
 
Hint Unfold unlink_oSC unlink_acl. *)
Require Export write. 
(* write:
Require Export DACandMAC. 
 
Set Strict Implicit.
Unset Implicit Arguments. 
 
Section Write. 
 
Variable s : SFSstate. 
 
Let t (o : OBJECT) (n : nat) (buf : FILECONT) : SFSstate :=
  mkSFS (groups s) (primaryGrp s) (subjectSC s) (AllGrp s) 
    (RootGrp s) (SecAdmGrp s) (objectSC s) (acl s) 
    (secmat s) (write_files o n buf) (directories s). 
 
Inductive write (u : SUBJECT) (o : OBJECT) (n : nat) 
(buf : FILECONT) : SFSstate -> Prop :=
    WriteOK :
      ObjType o = File ->
      match fsecmat (secmat s) o with
      | None => False
      | Some y => set_In u (ActWriters y)
      end -> write u o n buf (t o n buf). 
 
End Write. *)
 
Section TransitionFunction. 
 
Inductive TransFunc : SUBJECT -> SFSstate -> Operation -> SFSstate -> Prop :=
  | DoAclstat :
      forall (u : SUBJECT) (o : OBJECT) (out : Exc AccessCtrlListData)
        (s : SFSstate), aclstat s u o s out -> TransFunc u s Aclstat s
  | DoChmod :
      forall (u : SUBJECT) (o : OBJECT) (perms : PERMS) (s t : SFSstate),
      chmod s u o perms t -> TransFunc u s Chmod t
  | DoCreate :
      forall (u : SUBJECT) (p : OBJNAME) (perms : PERMS) (s t : SFSstate),
      create s u p perms t -> TransFunc u s Create t
  | DoMkdir :
      forall (u : SUBJECT) (p : OBJNAME) (perms : PERMS) (s t : SFSstate),
      mkdir s u p perms t -> TransFunc u s Mkdir t
  | DoOpen :
      forall (u : SUBJECT) (o : OBJECT) (m : MODE) (s t : SFSstate),
      open s u o m t -> TransFunc u s Open t
  | DoAddUsrGrpToAcl :
      forall (u : SUBJECT) (o : OBJECT) (ru wu pu : SUBJECT)
        (rg wg pg : GRPNAME) (s t : SFSstate),
      addUsrGrpToAcl s u o ru wu pu rg wg pg t ->
      TransFunc u s AddUsrGrpToAcl t
  | DoChobjsc :
      forall (secadm : SUBJECT) (o : OBJECT) (sc : SecClass) (s t : SFSstate),
      chobjsc s secadm o sc t -> TransFunc secadm s Chobjsc t
  | DoChown :
      forall (u : SUBJECT) (o : OBJECT) (p : SUBJECT) 
        (g : GRPNAME) (s t : SFSstate),
      chown s u o p g t -> TransFunc u s Chown t
  | DoChsubsc :
      forall (secadm u : SUBJECT) (sc : SecClass) (s t : SFSstate),
      chsubsc s secadm u sc t -> TransFunc secadm s Chsubsc t
  | DoClose :
      forall (u : SUBJECT) (o : OBJECT) (s t : SFSstate),
      close s u o t -> TransFunc u s Close t
  | DoDelUsrGrpFromAcl :
      forall (u : SUBJECT) (o : OBJECT) (ru wu pu : SUBJECT)
        (rg wg pg : GRPNAME) (s t : SFSstate),
      delUsrGrpFromAcl s u o ru wu pu rg wg pg t ->
      TransFunc u s DelUsrGrpFromAcl t
  | DoOscstat :
      forall (u : SUBJECT) (o : OBJECT) (out : Exc SecClass) (s : SFSstate),
      oscstat s u o s out -> TransFunc u s Oscstat s
  | DoOwner_Close :
      forall (owner u : SUBJECT) (o : OBJECT) (s t : SFSstate),
      owner_close s owner u o t -> TransFunc owner s Owner_Close t
  | DoRead :
      forall (u : SUBJECT) (o : OBJECT) (n : nat) (out : Exc FILECONT)
        (s : SFSstate), read s u o n s out -> TransFunc u s Read s
  | DoReaddir :
      forall (u : SUBJECT) (o : OBJECT) (n : nat) (out : Exc DIRCONT)
        (s : SFSstate), readdir s u o n s out -> TransFunc u s Readdir s
  | DoRmdir :
      forall (u : SUBJECT) (o : OBJECT) (s t : SFSstate),
      rmdir s u o t -> TransFunc u s Rmdir t
  | DoSscstat :
      forall (u user : SUBJECT) (out : Exc SecClass) (s : SFSstate),
      sscstat s u user s out -> TransFunc u s Sscstat s
  | DoStat :
      forall (u : SUBJECT) (o : OBJECT) (out : Exc stat_struct)
        (s : SFSstate), stat s u o s out -> TransFunc u s Stat s
  | DoUnlink :
      forall (u : SUBJECT) (o : OBJECT) (s t : SFSstate),
      unlink s u o t -> TransFunc u s Unlink t
  | DoWrite :
      forall (u : SUBJECT) (o : OBJECT) (n : nat) (buf : FILECONT)
        (s t : SFSstate), write s u o n buf t -> TransFunc u s Write t. 
 
End TransitionFunction. 