From Categories Require Import Essentials.Notations.
(* Categories.Essentials.Notations:
Notation "∀ x .. y , P" := (forall x, .. (forall y, P) ..)
                             (at level 200, x binder, y binder, right associativity) : type_scope.

Notation "∃ x .. y , P" := (exists x, .. (exists y, P) ..)
  (at level 200, x binder, y binder, right associativity) : type_scope.

Notation "x ∨ y" := (x \/ y) (at level 85, right associativity) : type_scope.

Notation "x ∧ y" := (x /\ y) (at level 80, right associativity) : type_scope.

Notation "x → y" := (x -> y)
  (at level 90, y at level 200, right associativity): type_scope.

Notation "x ↔ y" := (x <-> y) (at level 95, no associativity): type_scope.

Notation "¬ x" := (~x) (at level 75, right associativity) : type_scope.

Notation "x ≠ y" := (x <> y) (at level 70) : type_scope.

Notation "x ≤ y" := (le x y) (at level 70, no associativity).

Notation "x ≥ y" := (ge x y) (at level 70, no associativity).

Reserved Notation "C '^op'" (at level 50, no associativity).

Reserved Notation "a –≻ b" (at level 90, b at level 200, right associativity).

Reserved Notation "f '⁻¹'" (at level 50, no associativity).

Reserved Notation "a ≃ b" (at level 70, no associativity).

Reserved Notation "a ≃≃ b ::> C" (at level 70, no associativity).

Reserved Notation "f ∘ g" (at level 51, right associativity).

Reserved Notation "f '∘_h' g" (at level 51, right associativity).

Reserved Notation "a ≫–> b" (at level 100, no associativity).

Reserved Notation "a –≫ b" (at level 100, no associativity).

Reserved Notation "F '_o'" (at level 50, no associativity).

Reserved Notation "F '_a'" (at level 50, no associativity).

Reserved Notation "F '@_a'" (at level 50, no associativity).

Reserved Notation "F ⊣ G" (at level 100, no associativity).

Reserved Notation "F ⊣_hom G" (at level 100, no associativity).

Reserved Notation "F ⊣_ucu G" (at level 100, no associativity).

Reserved Notation "a × b" (at level 80, no associativity).

Reserved Notation "a ⇑ b" (at level 79, no associativity).

Reserved Notation "'Π' m" (at level 50, no associativity).

Reserved Notation "'Σ' m" (at level 50, no associativity).

Reserved Notation "'Π_' C ↓ m" (at level 50, no associativity).

Reserved Notation "'Σ_' C ↓ m" (at level 50, no associativity).

Delimit Scope category_scope with category.

Delimit Scope morphism_scope with morphism.

Delimit Scope object_scope with object.

Delimit Scope functor_scope with functor.

Delimit Scope nattrans_scope with nattrans.

Delimit Scope nattrans_scope with nattrans.

Delimit Scope natiso_scope with natiso.

Delimit Scope isomorphism_scope with isomorphism.

Delimit Scope preorder_scope with preorder. *)

From Categories Require Import Essentials.Types.
(* Categories.Essentials.Types:
Global Set Primitive Projections.

Global Set Universe Polymorphism.

Global Unset Universe Minimization ToSet.

Inductive Empty : Type :=.

Hint Extern 1 =>
let tac := (repeat intros ?); match goal with [H : Empty |- _] => contradict H end in
match goal with
  | [|- context[Empty]] => tac
  | [H : context[Empty] |- _] => tac
end
.

Record prod (A B : Type) := {fst : A; snd : B}.

Arguments fst {_ _ } _.
Arguments snd {_ _ } _.
Arguments Build_prod {_ _ } _ _.

Notation "( X , Y )" := (Build_prod X Y).
Notation "X * Y" := (prod X Y) : type_scope. *)

From Categories Require Import Essentials.Facts_Tactics.
(* Categories.Essentials.Facts_Tactics:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.

Require Export Coq.Program.Tactics.
Require Export Coq.Program.Equality.
Require Export Coq.Logic.FunctionalExtensionality.
Require Export Coq.Logic.ProofIrrelevance.

Definition equal_f : ∀ {A B : Type} {f g : A → B}, f = g → ∀ x : A, f x = g x.

Definition f_equal : ∀ (A B : Type) (f : A → B) (x y : A), x = y → f x = f y.

Arguments f_equal [_ _] _ [_ _] _.

Ltac basic_simpl :=
  let simpl_prod _ :=
      match goal with
        [H : prod _ _ |- _] =>
        let H1 := fresh H "1" in
        let H2 := fresh H "2" in
        destruct H as [H1 H2]
      end
  in
  let simpl_sig _ :=
      match goal with
        [H : @sig _ _ |- _] =>
        let H1 := fresh H "1" in
        let H2 := fresh H "2" in
        destruct H as [H1 H2]
      end
  in
  let basic_simpl_helper _ :=
      cbn in *; intros;
        repeat simpl_prod tt;
        repeat simpl_sig tt
  in
  repeat basic_simpl_helper tt
.

Global Obligation Tactic := basic_simpl; auto.

Ltac PIR :=
  let pir_helper _ :=
      match goal with
      |[H : ?A, H' : ?A|- _] =>
       match type of A with
       | Prop =>
         destruct (proof_irrelevance _ H H')
       end
      end
  in
  repeat pir_helper tt
.

Ltac ElimEq := repeat match goal with [H : _ = _|- _] => destruct H end.

Hint Extern 1 => progress ElimEq.

Ltac cbn_rewrite W :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite H; clear H
.

Ltac cbn_rewrite_in W V :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite H in V; clear H
.

Ltac cbn_rewrite_back W :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite <- H; clear H
.

Ltac cbn_rewrite_back_in W V :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite <- H in V; clear H
.

Tactic Notation "cbn_rewrite" constr(W) := cbn_rewrite W.
Tactic Notation "cbn_rewrite" constr(W) "in" hyp_list(V) := cbn_rewrite_in W V.
Tactic Notation "cbn_rewrite" "<-" constr(W) := cbn_rewrite_back W.
Tactic Notation "cbn_rewrite" "<-" constr(W) "in" hyp_list(V) := cbn_rewrite_back_in W V.

Lemma sig_proof_irrelevance {A : Type} (P : A → Prop) (X Y : sig P) : proj1_sig X = proj1_sig Y → X = Y.

Hint Extern 2 (exist ?A _ _ = exist ?A _ _) => apply sig_proof_irrelevance.

Ltac FunExt :=
progress (
    repeat (
        match goal with
          [|- _ = _] =>
          let x := fresh "x" in
          extensionality x
        end
      )
  )
.

Hint Extern 1 => FunExt.

Lemma pair_eq (A B : Type) (a b : A * B) : fst a = fst b → snd a = snd b → a = b.

Hint Resolve pair_eq.

Ltac revert_clearbody_all :=
 repeat lazymatch goal with H:_ |- _ => try clearbody H; revert H end.

Ltac hyp_stack :=
 constr:(ltac:(revert_clearbody_all;constructor) : True).

Ltac next_hyp hs step last :=
 lazymatch hs with (?hs' ?H) => step H hs' | _ => last end.

Tactic Notation "dohyps" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := tac H; next_hyp hs step idtac in
 next_hyp hs step idtac.

Tactic Notation "dohyps" "reverse" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := next_hyp hs step idtac; tac H in
 next_hyp hs step idtac.

Tactic Notation "do1hyp" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := tac H + next_hyp hs step fail in
 next_hyp hs step fail.

Tactic Notation "do1hyp" "reverse" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := next_hyp hs step fail + tac H in
 next_hyp hs step fail. *)

From Categories Require Import Category.Main.
(* Categories.Category.Main:
From Categories Require Export Category.Category.
From Categories Require Export Category.Morph.
From Categories Require Export Category.Opposite.
From Categories Require Export Category.SubCategory.
From Categories Require Export Category.Composable_Chain. *)

From Categories Require Import Functor.Functor Functor.Functor_Ops.
(* Categories.Functor.Functor:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.

Record Functor (C C' : Category) : Type :=
{
  
  FO : C → C';

  FA : ∀ {a b}, (a –≻ b)%morphism → ((FO a) –≻ (FO b))%morphism;

  F_id : ∀ c, FA (id c) = id (FO c);

  F_compose : ∀ {a b c} (f : (a –≻ b)%morphism) (g : (b –≻ c)%morphism),
      (FA (g ∘ f) = (FA g) ∘ (FA f))%morphism

}.

Arguments FO {_ _} _ _.
Arguments FA {_ _} _ {_ _} _, {_ _} _ _ _ _.
Arguments F_id {_ _} _ _.
Arguments F_compose {_ _} _ {_ _ _} _ _.

Notation "C –≻ D" := (Functor C D) : functor_scope.

Bind Scope functor_scope with Functor.

Notation "F '_o'" := (FO F) : object_scope.

Notation "F '@_a'" := (@FA _ _ F) : morphism_scope.

Notation "F '_a'" := (FA F) : morphism_scope.

Hint Extern 2 => (apply F_id).

Local Open Scope morphism_scope.
Local Open Scope object_scope.

Ltac Functor_Simplify :=
  progress
    (
      repeat rewrite F_id;
      (
        repeat
          match goal with
          | [|- ?F _a ?A = id (?F _o ?x)] =>
            (rewrite <- F_id; (cbn+idtac))
          | [|- (id (?F _o ?x)) = ?F _a ?A] =>
            (rewrite <- F_id; (cbn+idtac))
          | [|- ?F _a ?A ∘ ?F _a ?B = ?F _a ?C ∘ ?F _a ?D] =>
            (repeat rewrite <- F_compose; (cbn+idtac))
          | [|- ?F _a ?A ∘ ?F _a ?B = ?F _a ?C] =>
            (rewrite <- F_compose; (cbn+idtac))
          | [|- ?F _a ?C = ?F _a ?A ∘ ?F _a ?B] =>
            (rewrite <- F_compose; (cbn+idtac))
          | [|- context [?F _a ?A ∘ ?F _a ?B]] =>
            (rewrite <- F_compose; (cbn+idtac))
          end
      )
    )
.

Hint Extern 2 => Functor_Simplify.

Section Functor_eq_simplification.

  Context {C C' : Category} (F G : (C –≻ C')%functor).

  Lemma Functor_eq_simplify (Oeq : F _o = G _o) :
    ((fun x y =>
        match Oeq in _ = V return ((x –≻ y) → ((V x) –≻ (V y)))%morphism with
          eq_refl => F  @_a x y
        end) = G @_a) -> F = G.

  Theorem FA_extensionality (Oeq : F _o = G _o) :
    (
      ∀ (a b : Obj)
        (h : (a –≻ b)%morphism),
        (
          fun x y =>
            match Oeq in _ = V return
                  ((x –≻ y) → ((V x) –≻ (V y)))%morphism
            with
              eq_refl => F  @_a x y
            end
        ) _ _ h = G _a h
    )
    →
    (
      fun x y =>
        match Oeq in _ = V return
              ((x –≻ y) → ((V x) –≻ (V y)))%morphism
        with
          eq_refl => F  @_a x y
        end
    ) = G @_a.

  Lemma Functor_extensionality (Oeq : F _o = G _o) :
    (
      ∀ (a b : Obj) (h : (a –≻ b)%morphism),
        (
          fun x y =>
            match Oeq in _ = V return
                  ((x –≻ y) → ((V x) –≻ (V y)))%morphism
            with
              eq_refl => F  @_a x y
            end
        ) _ _ h = G _a h
    ) → F = G.

End Functor_eq_simplification.

Hint Extern 2 => Functor_Simplify.

Ltac Func_eq_simpl :=
  match goal with
    [|- ?A = ?B :> Functor _ _] =>
    (apply (Functor_eq_simplify A B (eq_refl : A _o = B _o)%object)) +
    (cut (A _o = B _o)%object; [
       let u := fresh "H" in
       intros H;
         apply (Functor_eq_simplify A B H)
         |
    ])
  end.

Hint Extern 3 => Func_eq_simpl.

Section Functor_eq.
  Context {C C' : Category} (F G : (C –≻ C')%functor).

  Lemma Functor_eq_morph (H : F = G) :
    ∃ (H : ∀ x, F _o x = G _o x),
    ∀ x y (h : (x –≻ y)%morphism),
      match H x in _ = V return (V –≻ _)%morphism with
         eq_refl =>
         match H y in _ = V return (_ –≻ V)%morphism with
           eq_refl => F _a h
         end
       end = G _a h.

End Functor_eq. *)
(* Categories.Functor.Functor_Ops:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Functor.

Section Opposite_Functor.
  Context {C D : Category} (F : (C –≻ D)%functor).
  
  Local Open Scope morphism_scope.
  Local Open Scope object_scope.
    
  Program Definition Opposite_Functor : (C^op –≻ D^op)%functor :=
    {|
      FO := F _o;
      FA := fun _ _ h => F @_a _ _ h;
      F_id := fun a => F_id F a;
      F_compose := fun _ _ _ f g => F_compose F g f
    |}.

End Opposite_Functor.

Notation "F '^op'" := (Opposite_Functor F) : functor_scope.

Section Functor_Compose.
  Context {C C' C'' : Category} (F : (C –≻ C')%functor) (F' : (C' –≻ C'')%functor).

  Local Open Scope morphism_scope.
  Local Open Scope object_scope.
  
  Program Definition Functor_compose : (C –≻ C'')%functor :=
    {|
      FO := fun c => F' _o (F _o c);
      FA := fun c d f => F' _a (F _a f)
    |}.
  
End Functor_Compose.

Notation "F ∘ G" := (Functor_compose G F) : functor_scope. 

Section Functor_Assoc.
  Context {C1 C2 C3 C4 : Category}
          (F : (C1 –≻ C2)%functor)
          (G : (C2 –≻ C3)%functor)
          (H : (C3 –≻ C4)%functor).

  Local Open Scope functor_scope.
    
  Theorem Functor_assoc : (H ∘ G) ∘ F = H ∘ (G ∘ F).

End Functor_Assoc.

Program Definition Functor_id (C : Category) : (C –≻ C)%functor :=
  {|
    FO := fun x => x;
    FA := fun c d f => f
  |}.

Section Functor_Identity_Unit.
  Context  (C C' : Category) (F : (C –≻ C')%functor).

  Theorem Functor_id_unit_left : ((Functor_id C') ∘ F)%functor = F.

  Theorem Functor_id_unit_right : (Functor_compose (Functor_id _) F) = F.

End Functor_Identity_Unit. *)

From Categories Require Import Cat.Cat.
(* Categories.Cat.Cat:
From Categories Require Import Category.Main.
From Categories Require Import Functor.Functor Functor.Functor_Ops.

Local Open Scope functor_scope.

Definition Cat : Category :=
{|
  Obj := Category;

  Hom := Functor;

  compose := fun C D E => Functor_compose;
  
  assoc := fun C D E F (G : C –≻ D) (H : D –≻ E) (I : E –≻ F) =>
            @Functor_assoc _ _ _ _ G H I;

  assoc_sym := fun C D E F (G : C –≻ D) (H : D –≻ E) (I : E –≻ F) =>
            eq_sym (@Functor_assoc _ _ _ _ G H I);

  id := fun C => Functor_id C;

  id_unit_left := fun C D => @Functor_id_unit_left C D;

  id_unit_right := fun C D => @Functor_id_unit_right C D          
|}. *)

From Categories Require Import NatTrans.NatTrans.
(* Categories.NatTrans.NatTrans:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Functor.
From Categories Require Import Cat.Cat.

Section NatTrans.
  Context {C C' : Category}.

  Record NatTrans (F F' : (C –≻ C')%functor) :=
    {
      Trans (c : C) : ((F _o c) –≻ (F' _o c))%object%morphism;
      Trans_com {c c' : C} (h : (c –≻ c')%morphism) :
        ((Trans c') ∘ F _a h = F' _a h ∘ (Trans c))%morphism;
      Trans_com_sym {c c' : C} (h : (c –≻ c')%morphism) :
        (F' _a h ∘ (Trans c) = (Trans c') ∘ F _a h)%morphism
    }.

  Notation "F –≻ F'" := (NatTrans F F') : nattrans_scope.

  Lemma NatTrans_eq_simplify {F F' : (C –≻ C')%functor}
        (N N' : (F –≻ F')%nattrans) : (@Trans _ _ N) = (@Trans _ _ N') -> N = N'.

End NatTrans.

Arguments Trans {_ _ _ _} _ _.
Arguments Trans_com {_ _ _ _} _ {_ _} _.
Arguments Trans_com_sym {_ _ _ _} _ {_ _} _.

Bind Scope nattrans_scope with NatTrans.

Notation "F –≻ F'" := (NatTrans F F') : nattrans_scope.

Local Open Scope nattrans_scope.

Section NatTrans_Compose.
  Context {C C' : Category}.
  
  Program Definition NatTrans_compose {F F' F'' : (C –≻ C')%functor}
          (tr : F –≻ F') (tr' : F' –≻ F'') : (F –≻ F'')%nattrans :=
    {|
      Trans := fun c : Obj => ((Trans tr' c) ∘ (Trans tr c)) % morphism
    |}.

End NatTrans_Compose.

Notation "N ∘ N'" := (NatTrans_compose N' N) : nattrans_scope.

Section NatTrans_Props.
  Context {C C' : Category}.
  
  Theorem NatTrans_compose_assoc {F G H I : (C –≻ C')%functor} (N : F –≻ G)
          (N' : G –≻ H) (N'' : H –≻ I)
    : ((N'' ∘ N') ∘ N = N'' ∘ (N' ∘ N))%nattrans
  .

  Program Definition NatTrans_id (F : (C –≻ C')%functor) : F –≻ F :=
    {|
      Trans := fun x : Obj => id
    |}.

  Theorem NatTrans_id_unit_left {F G : (C –≻ C')%functor} (N : F –≻ G)
    : (NatTrans_id G) ∘ N = N.

  Theorem NatTrans_id_unit_right {F G : (C –≻ C')%functor} (N : F –≻ G)
    : N ∘ (NatTrans_id F) = N.
  
End NatTrans_Props.

Hint Resolve NatTrans_eq_simplify. *)



Local Open Scope nattrans_scope.



Section Opposite_NatTrans.

  Context {C D : Category} {F F' : (C –≻ D)%functor} (N : (F –≻ F')%nattrans).



  Program Definition Opposite_NatTrans : F'^op –≻ F^op :=

    {|

      Trans := Trans N;

      Trans_com := fun c c' h => (Trans_com_sym N h);

      Trans_com_sym := fun c c' h => (Trans_com N h)

    |}.

  

End Opposite_NatTrans.



Notation "N '^op'" := (Opposite_NatTrans N) : nattrans_scope.



Section Compose_NOP.

  Context {C D : Category} {F F' F'' : (C –≻ D)%functor}

          (N : F –≻ F') (N' : F' –≻ F'').



  Theorem NatTrans_compose_Op : ((N' ∘ N)^op = N^op ∘ (N'^op))%nattrans.

  Proof.

    apply NatTrans_eq_simplify.

    trivial.

  Qed.



End Compose_NOP.



Section NatTrans_id_Op.

  Context {C D : Category} (F : (C –≻ D)%functor).



  Theorem NatTrans_id_Op

    : ((NatTrans_id F)^op)%nattrans = NatTrans_id (F^op)%functor.

  Proof.

    apply NatTrans_eq_simplify.

    trivial.

  Qed.



End NatTrans_id_Op.



Program Definition NatTrans_hor_comp {C D E : Category} {F G : (C –≻ D)%functor}

        {F' G' : (D –≻ E)%functor} (tr : F –≻ G) (tr' : F' –≻ G')

  : (F' ∘ F) –≻ (G' ∘ G) :=

{|

  Trans := fun c : Obj => ((G' _a (Trans tr c)) ∘ (Trans tr' (F _o c)))%morphism

|}.



Next Obligation. 

Proof.

  rewrite assoc.

  rewrite Trans_com.

  rewrite assoc_sym.

  rewrite <- F_compose.

  rewrite Trans_com.

  rewrite F_compose.

  auto.

Qed.



Next Obligation. 

Proof.

  symmetry.

  apply NatTrans_hor_comp_obligation_1.

Qed.



Notation "N ∘_h N'" := (NatTrans_hor_comp N' N) : nattrans_scope.



Section Hor_Compose_ids.

  Context {C D E : Category} (F : (C –≻ D)%functor) (G : (D –≻ E)%functor).



  Theorem NatTrans_hor_comp_ids

    : ((NatTrans_id G) ∘_h (NatTrans_id F))%nattrans = NatTrans_id  (G ∘ F).

  Proof.

    apply NatTrans_eq_simplify.

    cbn.

    extensionality c.

    rewrite F_id; simpl_ids; trivial.

  Qed.



End Hor_Compose_ids.



Section Hor_Compose_NOP.

  Context {C D E : Category} {F G : (C –≻ D)%functor} {F' G' : (D –≻ E)%functor}

          (N : F –≻ G) (N' : F' –≻ G').

  

  Theorem NatTrans_hor_comp_Op : ((N' ∘_h N)^op = N'^op ∘_h N^op)%nattrans.

  Proof.

    apply NatTrans_eq_simplify.

    cbn.

    extensionality c.

    rewrite Trans_com.

    trivial.

  Qed.



End Hor_Compose_NOP.



Section NatTransCompID.

  Context {C D : Category} (F : (C –≻ D)%functor).

  

  Program Definition NatTrans_to_compose_id : F –≻ ((Functor_id D) ∘ F) :=

    {|

      Trans := fun c => id

    |}.



  Program Definition NatTrans_from_compose_id : ((Functor_id _) ∘ F) –≻ F :=

    {|

      Trans := fun c => id

    |}.



  Program Definition NatTrans_to_id_compose : F –≻ (F ∘ (Functor_id _)) :=

    {|

      Trans := fun c => id

    |}.



  Program Definition NatTrans_from_id_compose : (F ∘ (Functor_id _)) –≻ F :=

    {|

      Trans := fun c => id

    |}.



End NatTransCompID.



Section NatTransAssoc.

  Context {C1 C2 C3 C4 : Category}

          (F : (C1 –≻ C2)%functor)

          (G : (C2 –≻ C3)%functor)

          (H : (C3 –≻ C4)%functor)

  .

  

  Program Definition NatTrans_Functor_assoc

    : ((H ∘ G) ∘ F) –≻ (H ∘ (G ∘ F)) :=

    {|

      Trans := fun c => id

    |}.



  Program Definition NatTrans_Functor_assoc_sym

    : (H ∘ (G ∘ F)) –≻ ((H ∘ G) ∘ F) :=

    {|

      Trans := fun c => id

    |}.



End NatTransAssoc.



Section NatTrans_comp_hor_comp.

  Context {C D E  : Category}

          {F F' F'' : (C –≻ D)%functor}

          {G G' G'' : (D –≻ E)%functor}

          (N1 : F –≻ F')

          (N2 : G –≻ G')

          (N3 : F' –≻ F'')

          (N4 : G' –≻ G'')

  .



  Theorem NatTrans_comp_hor_comp

    : ((N4 ∘_h N3) ∘ (N2 ∘_h N1) = (N4 ∘ N2) ∘_h (N3 ∘ N1))%nattrans.

  Proof.

    apply NatTrans_eq_simplify.

    extensionality c.

    cbn.

    rewrite F_compose.

    repeat rewrite assoc.

    match goal with

      [|- (?A ∘ ?B = ?A ∘ ?C)%morphism] =>

      let H := fresh in

      cut (B = C); [intros H; rewrite H; trivial|]

    end.

    repeat rewrite assoc_sym.

    match goal with

      [|- (?A ∘ ?B = ?C ∘ ?B)%morphism] =>

      let H := fresh in

      cut (A = C); [intros H; rewrite H; trivial|]

    end.

    apply Trans_com.

  Qed.    



End NatTrans_comp_hor_comp.



Section IsoCat_NatTrans.

  Context {C D : Category} (I : (C ≃≃ D ::> Cat)%isomorphism)

          {E : Category} (F : (D –≻ E)%functor).



  Local Obligation Tactic := idtac.

  

  Program Definition IsoCat_NatTrans :

    (F ∘ ((iso_morphism I) ∘ (I⁻¹)%morphism)) –≻ F

    :=

      {|

        Trans :=

          fun c =>

            match eq_sym (f_equal (fun x => (x _o)%object c) (right_inverse I))

                  in _ = y return ((F _o y) –≻ (F _o c))%object%morphism

            with

              eq_refl => id

            end

      |}

  .



  Next Obligation.

  Proof.

    intros c c' h; cbn.

    match goal with

      [|- (match ?e with _ => _ end ∘ ?A)%morphism

         = (?B ∘ match ?e' with _ => _ end)%morphism] =>

      generalize e; generalize e';

      set (U := A); set (V := B)

    end.

    intros H H'.

    cut (JMeq U V); [intros HUV|].

    {

      apply JMeq_eq.

      destruct H.

      set (z' := ((iso_morphism I)

                    _o ((inverse_morphism I) _o c'))%object) in *.

      clearbody U.

      clearbody z'.

      destruct H'.

      auto.

    }

    {

      unfold U, V; clear.

      match goal with

        [|- JMeq (F @_a ?A ?B ?C)%morphism (F _a ?D)%morphism] =>

        set (V := C);

        set (M := A) in *;

        set (N := B) in *;

        set (U := D)

      end.

      cut (M = c); [intros Hc|].

      {

        cut (N = c'); [intros Hc'|].

        {

          cut (JMeq V U); [intros HVU|].

          {

            clearbody U V M N.

            destruct Hc.

            destruct Hc'.

            apply JMeq_eq in HVU.

            destruct HVU.

            trivial.

          }

          {

            unfold U, V, M, N; clear.

            change ((iso_morphism I) _o ((I⁻¹)%morphism _o c))%object

            with (((iso_morphism I) ∘ (I⁻¹)%morphism) _o c)%object.

            change ((iso_morphism I) _o ((I⁻¹)%morphism _o c'))%object

            with (((iso_morphism I) ∘ (I⁻¹)%morphism) _o c')%object.

            change ((iso_morphism I) _a (I⁻¹ _a h))%morphism

            with (((iso_morphism I) ∘ I⁻¹) _a h)%morphism.

            cbn_rewrite (right_inverse I).

            trivial.            

          }

        }

        {

          unfold N; clear.

          change ((iso_morphism I) _o ((I⁻¹)%morphism _o c'))%object

          with (((iso_morphism I) ∘ (I⁻¹)%morphism) _o c')%object.        

          cbn_rewrite (right_inverse I); trivial.

        }

      }

      {

        unfold M; clear.

        change ((iso_morphism I) _o ((I⁻¹)%morphism _o c))%object

        with (((iso_morphism I) ∘ (I⁻¹)%morphism) _o c)%object.        

        cbn_rewrite (right_inverse I); trivial.

      }

    }

  Qed.



  Next Obligation.

  Proof.

    symmetry.

    apply IsoCat_NatTrans_obligation_1.

  Qed.



  Program Definition IsoCat_NatTrans_back :

    F –≻ (F ∘ ((iso_morphism I) ∘ (I⁻¹)%morphism))

    :=

      {|

        Trans :=

          fun c =>

            match eq_sym (f_equal (fun x => (x _o)%object c) (right_inverse I))

                  in _ = y return ((F _o c) –≻ (F _o y))%object%morphism

            with

              eq_refl => id

            end

      |}

  .

    

  Next Obligation.

  Proof.

    intros c c' h; cbn.

    match goal with

      [|- (match ?e with _ => _ end ∘ ?A)%morphism

         = (?B ∘ match ?e' with _ => _ end)%morphism] =>

      generalize e; generalize e';

      set (U := A); set (V := B)

    end.

    intros H H'.

    cut (JMeq U V); [intros HUV|].

    {

      apply JMeq_eq.

      destruct H'.

      set (z := ((iso_morphism I) _o ((inverse_morphism I) _o c))%object) in *.

      clearbody V.

      clearbody z.

      destruct H.

      auto.

    }

    {

      unfold U, V; clear.

      match goal with

        [|- JMeq (F _a ?D)%morphism (F @_a ?A ?B ?C)%morphism] =>

        set (V := C);

        set (M := A) in *;

        set (N := B) in *;

        set (U := D)

      end.

      cut (M = c); [intros Hc|].

      {

        cut (N = c'); [intros Hc'|].

        {

          cut (JMeq U V); [intros HUV|].

          {

            clearbody U V M N.

            destruct Hc.

            destruct Hc'.

            apply JMeq_eq in HUV.

            destruct HUV.

            trivial.

          }

          {

            unfold U, V, M, N; clear.

            change ((iso_morphism I) _o ((I⁻¹)%morphism _o c))%object

            with (((iso_morphism I) ∘ (I⁻¹)%morphism) _o c)%object.

            change ((iso_morphism I) _o ((I⁻¹)%morphism _o c'))%object

            with (((iso_morphism I) ∘ (I⁻¹)%morphism) _o c')%object.

            change ((iso_morphism I) _a (I⁻¹ _a h))%morphism

            with (((iso_morphism I) ∘ I⁻¹) _a h)%morphism.

            cbn_rewrite (right_inverse I).

            trivial.            

          }

        }

        {

          unfold N; clear.

          change ((iso_morphism I) _o ((I⁻¹)%morphism _o c'))%object

          with (((iso_morphism I) ∘ (I⁻¹)%morphism) _o c')%object.        

          cbn_rewrite (right_inverse I); trivial.

        }

      }

      {

        unfold M; clear.

        change ((iso_morphism I) _o ((I⁻¹)%morphism _o c))%object

        with (((iso_morphism I) ∘ (I⁻¹)%morphism) _o c)%object.        

        cbn_rewrite (right_inverse I); trivial.

      }

    }

  Qed.



  Next Obligation.

  Proof.

    symmetry.

    apply IsoCat_NatTrans_back_obligation_1.

  Qed.



End IsoCat_NatTrans.

