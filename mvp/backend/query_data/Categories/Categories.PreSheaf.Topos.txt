From Categories Require Import Category.Main.
(* Categories.Category.Main:
From Categories Require Export Category.Category.
From Categories Require Export Category.Morph.
From Categories Require Export Category.Opposite.
From Categories Require Export Category.SubCategory.
From Categories Require Export Category.Composable_Chain. *)

From Categories Require Import Topos.Topos.
(* Categories.Topos.Topos:
From Categories Require Import Category.Main.
From Categories Require Import Limits.Limit.
From Categories Require Import Coq_Cats.Type_Cat.Card_Restriction.
From Categories Require Import Basic_Cons.CCC.
From Categories Require Import Topos.SubObject_Classifier.

Class Topos : Type :=
  {
    Topos_Cat : Category;
    Topos_Cat_CCC : CCC Topos_Cat;
    Topos_Cat_Fin_Limit : Has_Restr_Limits Topos_Cat Finite;
    Topos_Cat_SOC : SubObject_Classifier Topos_Cat
  }.

Coercion Topos_Cat : Topos >-> Category. *)

From Categories Require Import Limits.Limit.
(* Categories.Limits.Limit:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Main.
From Categories Require Import Basic_Cons.Terminal.
From Categories Require Import Ext_Cons.Arrow.
From Categories Require Import Coq_Cats.Type_Cat.Card_Restriction.
From Categories Require Export NatTrans.NatTrans NatTrans.Operations.
From Categories Require Export KanExt.Local KanExt.Global KanExt.GlobalDuality
        KanExt.GlobaltoLocal KanExt.LocaltoGlobal KanExt.LocalFacts.Main.
From Categories Require Export Cat.Terminal.

Local Open Scope functor_scope.

Section Limit.
  Context {J C : Category} (D : J –≻ C).

  Definition Cone := LoKan_Cone (Functor_To_1_Cat J) D.

  Definition Cone_Morph Cn Cn' :=
    @LoKan_Cone_Morph _ _ (Functor_To_1_Cat J) _ D Cn Cn'.
  
  Definition Limit : Type := Local_Right_KanExt (Functor_To_1_Cat J) D.

  Definition limit_to_cone (l : Limit) : Cone := (LRKE l).

  Coercion limit_to_cone : Limit >-> Cone.
  
  Definition cone_to_obj (cn : Cone) : C := (cone_apex cn) _o tt.

  Coercion cone_to_obj : Cone >-> Obj.

  Definition is_Limit (Cn : Cone) :=
    is_Cone_Local_Right_KanExt (Functor_To_1_Cat J) D Cn.

  Definition is_Limit_Limit {Cn : Cone} (il : is_Limit Cn) : Limit :=
    is_Cone_Local_Right_KanExt_Local_Right_KanExt (Functor_To_1_Cat J) D il.

  Definition Limit_is_Limit {L : Limit} : is_Limit L :=
    Local_Right_KanExt_is_Cone_Local_Right_KanExt (Functor_To_1_Cat J) D L.
  
End Limit.

Program Definition Limit_Iso {J C : Category} {D : J –≻ C} (l l' : Limit D) :
  (l ≃≃ l' ::> C)%isomorphism :=
  {|
    iso_morphism :=
      Trans
        (cone_morph (iso_morphism (Local_Right_KanExt_unique _ _ l l')))
        tt;
    inverse_morphism :=
      Trans
        (cone_morph (inverse_morphism (Local_Right_KanExt_unique _ _ l l')))
        tt
  |}.

Next Obligation.
Proof (
    f_equal
      (fun x : LoKan_Cone_Morph l l => Trans (cone_morph x) tt)
      (left_inverse (Local_Right_KanExt_unique _ _ l l'))
  ).

Next Obligation.
Proof (
    f_equal
      (fun x : LoKan_Cone_Morph l' l' => Trans (cone_morph x) tt)
      (right_inverse (Local_Right_KanExt_unique _ _ l l'))
  ).

Definition Has_Restr_Limits (C : Category) (P : Card_Restriction) :=
  ∀ {J : Category} (D : J –≻ C), P J → P (Arrow J) → Limit D.

Definition Complete (C : Category) :=
  ∀ J : Category, Right_KanExt (Functor_To_1_Cat J) C.

Existing Class Complete.

Definition LimitOf {C D : Category} {H : Complete D} (F : C –≻ D) : Limit F :=
  Global_to_Local_Right _ _ (H _) F.

Section Restricted_Limits_to_Complete.
  Context {C : Category} {P : Card_Restriction} (HRL : Has_Restr_Limits C P).

  Definition No_Restriction_Complete : (∀ t, P t) → Complete C :=
    fun All_Ps J => Local_to_Global_Right
                   _ _ (fun D => HRL _ D (All_Ps J) (All_Ps (Arrow J))).

End Restricted_Limits_to_Complete.

Section Complete_to_Restricted_Limits.
  Context (C : Category) {CC : Complete C} (P : Card_Restriction).
  
  Definition Complete_Has_Restricted_Limits : Has_Restr_Limits C P :=
    fun J D _ _ => Global_to_Local_Right _ _ (CC _) D.

End Complete_to_Restricted_Limits.

Section Continuous.
  Context
    {C D : Category}
    (CC : Complete C)
    (G : (C –≻ D)%functor)
  .

  Section Cone_Conv.
    Context
      {J : Category}
      {F : (J –≻ C)%functor}
      (Cn : Cone F)
    .
    
    Program Definition Cone_Conv : Cone (G ∘ F)%functor
      :=
        {|
          cone_apex :=
            (G ∘ (cone_apex Cn))%functor;
          cone_edge :=
            (((NatTrans_id G)
                ∘_h (cone_edge Cn)) ∘ (NatTrans_Functor_assoc _ _ _))%nattrans
        |}
    .

  End Cone_Conv.

  Definition Continuous :=
    ∀ (J : Category) (F : (J –≻ C)%functor),
      is_Cone_Local_Right_KanExt _ _ (Cone_Conv (LRKE (LimitOf F)))
  .

End Continuous.

Section CoLimit.
  Context {J C : Category} (D : J –≻ C).

  Definition CoCone :=
    LoKan_Cone (Functor_To_1_Cat J^op) (D^op).

  Definition CoCone_Morph Cn Cn' :=
    @LoKan_Cone_Morph _ _ (Functor_To_1_Cat J^op) _ (D^op) Cn Cn'.

  Definition CoLimit := Local_Left_KanExt (Functor_To_1_Cat J) D.

  Definition is_CoLimit (Cn : CoCone) :=
    is_Cone_Local_Right_KanExt (Functor_To_1_Cat (J^op)) (D^op) Cn.

  Definition is_CoLimit_CoLimit {Cn : CoCone} (il : is_CoLimit Cn) : CoLimit :=
    is_Cone_Local_Right_KanExt_Local_Right_KanExt
      (Functor_To_1_Cat (J^op)) (D^op) il.

  Definition CoLimit_is_CoLimit {L : CoLimit} : is_CoLimit L :=
    Local_Right_KanExt_is_Cone_Local_Right_KanExt
      (Functor_To_1_Cat (J^op)) (D^op) L.

End CoLimit.

Definition Has_Restr_CoLimits (C : Category) (P : Card_Restriction) :=
  ∀ {J : Category} (D : J –≻ C), P J → P (Arrow J) → CoLimit D.

Definition CoComplete (C : Category) :=
  ∀ J : Category, Left_KanExt (Functor_To_1_Cat J) C.

Existing Class CoComplete.

Definition CoLimitOf {C D : Category} {H : CoComplete D} (F : C –≻ D) :
  CoLimit F := Global_to_Local_Left _ _ (H _) F.

Definition Complete_to_CoComplete_Op {C : Category} {CC : Complete C}
  : CoComplete (C ^op) :=
fun D => KanExt_Right_to_Left (Functor_To_1_Cat D ^op) C (CC (D ^op)%category).

Definition CoComplete_to_Complete_Op {C : Category} {CC : CoComplete C}
  : Complete (C ^op) :=
    fun D => KanExt_Left_to_Right (Functor_To_1_Cat D ^op) C (CC (D ^op)%category).

Section Restricted_CoLimits_to_CoComplete.
  Context {C : Category} {P : Card_Restriction} (HRL : Has_Restr_CoLimits C P).

  Definition No_Restriction_CoComplete : (∀ t, P t) → CoComplete C :=
    fun All_Ps J =>
      Local_to_Global_Left _ _ (fun D => HRL _ D (All_Ps J) (All_Ps (Arrow J))).

End Restricted_CoLimits_to_CoComplete.

Section CoComplete_to_Restricted_CoLimits.
  Context (C : Category) {CC : CoComplete C} (P : Card_Restriction).
  
  Definition CoComplete_Has_Restricted_CoLimits : Has_Restr_CoLimits C P :=
    fun J D _ _ => Global_to_Local_Left _ _ (CC _) D.

End CoComplete_to_Restricted_CoLimits.

Definition Has_Restr_Limits_to_Has_Restr_CoLimits_Op
        {C : Category} {P : Card_Restriction}
        (HRL : Has_Restr_Limits C P) :
  Has_Restr_CoLimits (C ^op) P :=
  (fun (D : Category)
       (F : D –≻ C ^op)
       (H1 : P D)
       (H2 : P (Arrow D)) =>
     HRL
       (D ^op)%category
       (F ^op)%functor H1
       (Card_Rest_Respect P (Arrow D) (Arrow (D^op)) (Arrow_OP_Iso D) H2)
  ).

Definition Has_Restr_CoLimits_to_Has_Restr_Limits_Op
        {C : Category}
        {P : Card_Restriction}
        (HRL : Has_Restr_CoLimits C P) :
  Has_Restr_Limits (C ^op) P :=
  (fun (D : Category)
       (F : D –≻ C ^op)
       (H1 : P D)
       (H2 : P (Arrow D)) =>
     HRL
       (D ^op)%category
       (F ^op)%functor
       H1
       (Card_Rest_Respect P (Arrow D) (Arrow (D^op)) (Arrow_OP_Iso D) H2)
  ).

Section CoContinuous.
  Context
    {C D : Category}
    (CC : CoComplete C)
    (G : (C –≻ D)%functor)
  .

  Section CoCone_Conv.
    Context
      {J : Category}
      {F : (J –≻ C)%functor}
      (Cn : CoCone F)
    .
    
    Program Definition CoCone_Conv : CoCone (G ∘ F)%functor
      :=
        {|
          cone_apex :=
            ((G ^op) ∘ (cone_apex Cn))%functor;
          cone_edge := _
                         (((NatTrans_id (G ^op)) ∘_h (cone_edge Cn))
                            ∘ (NatTrans_Functor_assoc _ _ _))%nattrans
        |}
    .

  End CoCone_Conv.

  Definition CoContinuous :=
    ∀ (J : Category) (F : (J –≻ C)%functor),
      is_Cone_Local_Right_KanExt _ _ (CoCone_Conv (LRKE (CoLimitOf F)))
  .

End CoContinuous. *)

From Categories Require Import Coq_Cats.Type_Cat.Card_Restriction.
(* Categories.Coq_Cats.Type_Cat.Card_Restriction:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Coq_Cats.Type_Cat.Type_Cat.

Record Card_Restriction : Type :=
{
  Card_Rest : Type → Prop;

  Card_Rest_Respect : ∀ (A B : Type),
      (A ≃≃ B ::> Type_Cat)%isomorphism → Card_Rest A → Card_Rest B
}.

Coercion Card_Rest : Card_Restriction >-> Funclass.

Program Definition Finite : Card_Restriction :=
  {|
    Card_Rest :=
      fun A => inhabited {n : nat & (A ≃≃ {x : nat | x < n} ::> Type_Cat)%isomorphism}
  |}. *)

From Categories Require Import PreSheaf.PreSheaf.
(* Categories.PreSheaf.PreSheaf:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Main.
From Categories Require Import Coq_Cats.Type_Cat.Type_Cat.
From Categories Require Import NatTrans.NatTrans NatTrans.Func_Cat.

Definition PreSheaf (C : Category) := Functor (C^op) Type_Cat.

Definition PShCat (C : Category) := Func_Cat (C^op) Type_Cat. *)

From Categories Require Import PreSheaf.CCC.
(* Categories.PreSheaf.CCC:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Basic_Cons.CCC.
From Categories Require Import PreSheaf.PreSheaf.
From Categories Require Export PreSheaf.Terminal.
From Categories Require Export PreSheaf.Product.
From Categories Require Export PreSheaf.Exponential.

Program Instance PShCat_CCC (C : Category) : CCC (PShCat C)
  :=
    {|
      CCC_term := PSh_Terminal C;
      CCC_HP := PSh_Has_Products C;
      CCC_HEXP := PSh_Has_Exponentials C
    |}. *)

From Categories Require Import PreSheaf.Complete.
(* Categories.PreSheaf.Complete:
From Categories Require Import Category.Main.
From Categories Require Import Coq_Cats.Type_Cat.Type_Cat.
From Categories Require Import Type_Cat.GenProd Type_Cat.GenSum Type_Cat.Equalizer.
From Categories Require Import Limits.Limit Limits.GenProd_Eq_Limits.
From Categories Require Import PreSheaf.PreSheaf.
From Categories Require Import
        PreSheaf.Equalizer
        PreSheaf.GenProd
        PreSheaf.GenSum
.

Instance PShCat_Complete (C: Category) : Complete (PShCat C) :=
  @GenProd_Eq_Complete (PShCat C) (PSh_GenProd C) (@PSh_Has_Equalizers C).

Instance PShCat_CoComplete (C: Category) : CoComplete (PShCat C) :=
  @GenSum_CoEq_CoComplete (PShCat C) (PSh_GenSum C) (@PSh_Has_CoEqualizers C). *)

From Categories Require Import PreSheaf.SubObject_Classifier. 
(* Categories.PreSheaf.SubObject_Classifier:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Main.
From Categories Require Import Topos.SubObject_Classifier.
From Categories Require Import Basic_Cons.Terminal Basic_Cons.PullBack.
From Categories Require Import NatTrans.NatTrans NatTrans.Func_Cat.
From Categories Require Import Coq_Cats.Type_Cat.CCC Coq_Cats.Type_Cat.Morphisms.
From Categories Require Import
        PreSheaf.PreSheaf
        PreSheaf.Terminal
        PreSheaf.PullBack
        PreSheaf.Morphisms
.

Require Import Coq.Logic.ChoiceFacts.

Local Axiom ConstructiveIndefiniteDescription_Type :
  forall T : Type, ConstructiveIndefiniteDescription_on T.

Require Coq.Logic.ClassicalFacts.

Local Axiom PropExt : ClassicalFacts.prop_extensionality.

Section Sieve.
  Context {C : Category} (c : C).

  Local Open Scope morphism_scope.

  Definition Sieve :=
    {S : ∀ (x : C) (h : x –≻ c), Prop |
     ∀ (x : C) (h : x –≻ c), S x h → ∀ (y : C) (h' : y –≻ x), S y (h ∘ h')
    }.

  Definition TotalSieve : Sieve :=
    exist
      (fun S : ∀ x : C, (x –≻ c) → Prop =>
         ∀ (x : C) (h : x –≻ c), S x h → ∀ (y : C) (h' : y –≻ x), S y (h ∘ h'))
      (fun _ _ => True)
      (fun _ _ _ _ _ => I)
  .

End Sieve.

Section Sieve_PreSheaf.
  Context (C : Category).

  Local Open Scope morphism_scope.

  Program Definition Sieve_PreSheaf : PreSheaf C :=
    {|
      FO := fun c => @Sieve C c;
      FA :=
        fun c c' h S =>
          exist _ (fun y (h' : y –≻ c') => (proj1_sig S) _ (h ∘ h')) _
    |}
  .

  Program Definition True_PreSheaf_morphism :
    ((PSh_Term_PreSheaf C) –≻ Sieve_PreSheaf)%nattrans
    :=
      {|
        Trans := fun c _ => @TotalSieve C c
      |}.

End Sieve_PreSheaf.

Section PShCat_char_morph.
  Context
    {C : Category}
    {F G : PreSheaf C}
    (N : @Monic (PShCat C) F G)
  .

  Local Obligation Tactic := idtac.

  Program Definition PShCat_char_morph : (G –≻ (Sieve_PreSheaf C))%nattrans :=
    {|
      Trans :=
        fun c x =>
          exist
            _
            (fun y h => ∃ u, Trans (mono_morphism N) y u = (G _a h)%morphism x)
            _
    |}
  .

  Section PShCat_char_morph_forms_pullback_morph_ex.
    Context
      (p : PreSheaf C)
      (pm1 : (p –≻ G)%nattrans)
      (pm2 : (p –≻ PSh_Term_PreSheaf C)%nattrans)
      (H : (PShCat_char_morph ∘ pm1)%nattrans =
           (True_PreSheaf_morphism C ∘ pm2)%nattrans)
    .

    Definition PShCat_char_morph_forms_pullback_morph_ex_Trans
               (c : C)
               (x : (p _o c)%object)
      :
        (F _o c)%object
      :=
        proj1_sig
          (
            ConstructiveIndefiniteDescription_Type
              _
              _
              (
                match
                  eq_sym
                    (
                      f_equal
                        (
                          fun w : (p –≻ Sieve_PreSheaf C)%nattrans =>
                            proj1_sig (Trans w c x) c id
                        ) H
                    )
                  in _ = W return W
                with
                  eq_refl => I
                end
              )
          )
    .

    Program Definition PShCat_char_morph_forms_pullback_morph_ex :
      (p –≻ F)%nattrans
      :=
        {|
          Trans := PShCat_char_morph_forms_pullback_morph_ex_Trans
        |}.

  End PShCat_char_morph_forms_pullback_morph_ex.

  Local Hint Extern 1 => match goal with
                          [|- context [(?F _a id)%morphism]] => rewrite (F_id F)
                        end.

  Local Hint Extern 1 => apply PropExt; intuition.

  Local Hint Extern 1 =>
  match goal with
    [ f : (?d –≻ ?c)%morphism,
          x : (?F _o)%object ?c |- ∃ _ : (?F _o)%object ?d, _] =>
    exists (F _a f x)%morphism
  end.

  Local Hint Extern 1 =>
  match goal with
    [|- context [Trans ?f _ ((?F _a)%morphism ?h _)]] =>
    cbn_rewrite (equal_f (Trans_com f h))
  end.

  Local Hint Extern 1 => apply sig_proof_irrelevance.

  Local Hint Extern 1 => progress cbn in *.

  Local Hint Extern 1 =>
  match goal with
    [|- context [proj1_sig ?A]] =>
    let x := fresh "x" in
    let H := fresh "H" in
    destruct A as [x H]; cbn;
    try rewrite H
  end
  .

  Local Hint Extern 1 => unfold PShCat_char_morph_forms_pullback_morph_ex_Trans.

  Local Hint Extern 1 => match goal with
                          [|- ?A = ?B :> unit] => try destruct A;
                            try destruct B; trivial; fail
                        end.

  Local Obligation Tactic := basic_simpl; auto 7.

  Program Definition PShCat_char_morph_forms_pullback :
    is_PullBack
      (mono_morphism N) (t_morph (PSh_Terminal C) F)
      PShCat_char_morph (True_PreSheaf_morphism C)
    :=
      {|
        is_pullback_morph_ex := PShCat_char_morph_forms_pullback_morph_ex
      |}
  .

End PShCat_char_morph.

Section PShCat_char_morph_unique.
  Context
    {C : Category}
    {F G : PreSheaf C}
    (N : @Monic (PShCat C) F G)
    (M : (G –≻ (Sieve_PreSheaf C))%nattrans)
    (hpb : is_PullBack
      (mono_morphism N) (t_morph (PSh_Terminal C) F)
      M (True_PreSheaf_morphism C)
    ).

  Theorem PShCat_char_morph_unique : M = (PShCat_char_morph N).

End PShCat_char_morph_unique.

Program Definition PSh_SubObject_Classifier (C : Category) :
  SubObject_Classifier (PShCat C) :=
  {|
    SOC := (Sieve_PreSheaf C);
    SOC_morph := (True_PreSheaf_morphism C :
                    ((terminal (PSh_Terminal C)) –≻ _)%nattrans);
    SOC_char := @PShCat_char_morph C;
    SO_pulback := @PShCat_char_morph_forms_pullback C
  |}. *)



Instance Type_Cat_Topos (C : Category) : Topos :=

  {

    Topos_Cat := PShCat C;

    Topos_Cat_CCC := PShCat_CCC C;

    Topos_Cat_SOC := PSh_SubObject_Classifier C;

    Topos_Cat_Fin_Limit := Complete_Has_Restricted_Limits (PShCat C) Finite

  }.

