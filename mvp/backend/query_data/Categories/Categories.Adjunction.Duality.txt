From Categories Require Import Category.Main.
(* Categories.Category.Main:
From Categories Require Export Category.Category.
From Categories Require Export Category.Morph.
From Categories Require Export Category.Opposite.
From Categories Require Export Category.SubCategory.
From Categories Require Export Category.Composable_Chain. *)

From Categories Require Import Ext_Cons.Prod_Cat.Prod_Cat Ext_Cons.Prod_Cat.Operations.
(* Categories.Ext_Cons.Prod_Cat.Prod_Cat:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Main.
From Categories Require Import Cat.Cat.

Local Open Scope morphism_scope.

Local Obligation Tactic := idtac.

Program Definition Prod_Cat (C C' : Category) : Category :=
{|
  Obj := C * C';
              
  Hom :=
    fun a b =>
      (((fst a) –≻ (fst b)) * ((snd a) –≻ (snd b)))%type;

  compose :=
    fun a b c f g =>
      (((fst g) ∘ (fst f)), ((snd g) ∘ (snd f)))%morphism;

  id := fun c => (id, id)
|}.

Notation "C × D" := (Prod_Cat C D) : category_scope.

Local Obligation Tactic := basic_simpl; auto.

Theorem Prod_compose_id
        (C D : Category)
        (a b c : C) (d : D)
        (f : a –≻ b) (g : b –≻ c)
  : (g ∘ f, id d)%morphism =
    @compose (_ × _) (_, _) (_, _) (_, _) (f, id d) (g, id d).

Theorem Prod_id_compose
        (C D : Category)
        (a : C) (b c d : D)
        (f : b –≻ c) (g : c –≻ d)
  : (id a, g ∘ f)%morphism =
    @compose (_ × _) (_, _) (_, _) (_, _) (id a, f) (id a, g).

Theorem Prod_cross_compose
        (C D : Category)
        (a b : C) (c d : D)
        (f : a –≻ b) (g : c –≻ d)
  : @compose
      (_ × _) (_, _) (_, _) (_, _)
      (@id _ a, g) (f, @id _ d)
    = @compose
        (_ × _) (_, _) (_, _) (_, _)
        (f, @id _ c) (@id _ b, g)
.

Program Definition Cat_Proj1
        (C C' : Category) :
  ((C × C') –≻ C)%functor
  :=
    {|FO := fst; FA := fun _ _ f => fst f|}
.

Program Definition Cat_Proj2
        (C C' : Category) :
  ((C × C') –≻ C')%functor
  :=
    {|FO := snd; FA := fun _ _ f => snd f|}
. *)
(* Categories.Ext_Cons.Prod_Cat.Operations:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Main.
From Categories Require Import Cat.Cat.
From Categories Require Import Ext_Cons.Prod_Cat.Prod_Cat.

Local Obligation Tactic := idtac.

Local Open Scope functor_scope.

Program Definition Prod_Functor
        {C1 C2 C1' C2' : Category} (F : C1 –≻ C2) (F' : C1' –≻ C2')
  : (C1 × C1') –≻ (C2 × C2') :=
{|
  FO := fun a => (F _o (fst a), F' _o (snd a))%object;
  FA := fun _ _ f => (F _a (fst f), F' _a (snd f))%morphism
|}.

Definition Bi_Func_1 {Cx C1 C1' Cy : Category} (F : Cx –≻ C1)
           (F' : (C1 × C1') –≻ Cy)
  : (Cx × C1') –≻ Cy :=
  F' ∘ (Prod_Functor F (@Functor_id C1')).

Definition Bi_Func_2 {Cx C1 C1' Cy : Category} (F : Cx –≻ C1')
           (F' : (C1 × C1') –≻ Cy) : (C1 × Cx) –≻ Cy :=
  Functor_compose (Prod_Functor (@Functor_id C1) F) F'.

Local Hint Extern 2 => cbn.

Local Obligation Tactic := basic_simpl; do 2 auto.

Program Definition Fix_Bi_Func_1 {C1 C1' Cy : Category} (x : C1)
        (F : (C1 × C1') –≻ Cy)
  : C1' –≻ Cy :=
{|
  FO := fun a => (F _o (x, a))%object;
  FA := fun _ _ f => (F @_a (_, _) (_, _) (@id _ x, f))%morphism
|}.

Program Definition Fix_Bi_Func_2 {C1 C1' Cy : Category} (x : C1')
        (F : (C1 × C1') –≻ Cy)
  : C1 –≻ Cy :=
{|
  FO := fun a => (F _o (a, x))%object;
  FA := fun _ _ f => (F @_a (_, _) (_, _) (f, @id _ x))%morphism
|}.

Program Definition Diag_Func (C : Category) : C –≻ (C × C) :=
{|
  FO := fun a => (a, a);
  FA := fun _ _ f => (f, f);
  F_id := fun _ => eq_refl;
  F_compose := fun _ _ _ _ _ => eq_refl
|}.

Theorem Prod_Functor_Cat_Proj {C D D' : Category} (F : C –≻ (D × D')) :
  ((Prod_Functor ((Cat_Proj1 _ _) ∘ F) ((Cat_Proj2 _ _) ∘ F))
     ∘ (Diag_Func C))%functor = F.

Program Definition Twist_Func (C C' : Category) : (C × C') –≻ (C' × C) :=
{|
  FO := fun a => (snd a, fst a);
  FA := fun _ _ f => (snd f, fst f);
  F_id := fun _ => eq_refl;
  F_compose := fun _ _ _ _ _ => eq_refl
|}.

Section Twist_Prod_Func_Twist.
  Context {C C' : Category} (F : C –≻ C') {D D' : Category} (G : D –≻ D').

  Theorem Twist_Prod_Func_Twist :
    (((Twist_Func _ _) ∘ (Prod_Functor F G)) ∘ (Twist_Func _ _))%functor =
    Prod_Functor G F.

End Twist_Prod_Func_Twist.

Section Prod_Functor_compose.
  Context {C D E: Category} (F : C –≻ D) (G : D –≻ E)
          {C' D' E': Category} (F' : C' –≻ D') (G' : D' –≻ E').

  Theorem Prod_Functor_compose :
    ((Prod_Functor G G') ∘ (Prod_Functor F F') =
     Prod_Functor (G ∘ F) (G' ∘ F'))%functor.
                                   
End Prod_Functor_compose. *)

From Categories Require Import Functor.Main.
(* Categories.Functor.Main:
From Categories Require Export Functor.Functor.
From Categories Require Export Functor.Functor_Extender.
From Categories Require Export Functor.Functor_Image.
From Categories Require Export Functor.Functor_Ops.
From Categories Require Export Functor.Functor_Properties.
From Categories Require Export Functor.Const_Func.
From Categories Require Export Functor.Const_Func_Functor. *)

From Categories Require Import Functor.Representable.Hom_Func Functor.Representable.Hom_Func_Prop.
(* Categories.Functor.Representable.Hom_Func:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Functor.
From Categories Require Import Coq_Cats.Type_Cat.Type_Cat.
From Categories Require Import Ext_Cons.Prod_Cat.Prod_Cat.

Program Definition Hom_Func (C : Category) : ((C^op × C) –≻ Type_Cat)%functor :=
{|
  FO := fun x => Hom C (fst x) (snd x);
  FA := fun x y f => fun g => compose C (fst f) ((@compose (C^op) _ _ _) (snd f) g)
|}. *)
(* Categories.Functor.Representable.Hom_Func_Prop:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Functor Functor.Functor_Ops.
From Categories Require Import Coq_Cats.Type_Cat.Type_Cat.
From Categories Require Import Ext_Cons.Prod_Cat.Prod_Cat Ext_Cons.Prod_Cat.Operations.
From Categories Require Import Functor.Representable.Hom_Func.
From Categories Require Import Cat.Cat Cat.Cat_Iso.
From Categories Require Import NatTrans.NatTrans NatTrans.Func_Cat NatTrans.NatIso.

Local Open Scope functor_scope.

Section Hom_Func_Twist.
  Context (C : Category).

  Theorem Hom_Func_Twist : (Hom_Func (C^op)) = (Hom_Func C) ∘ (Twist_Func C (C^op)).

End Hom_Func_Twist.

Section Prod_Func_Hom_Func_NT.
  Context {A B C D : Category}
          {F : A –≻ C^op}
          {F' : A –≻ D^op}
          {G : B –≻ C}
          {G' : B –≻ D}
          (N : (((Hom_Func C) ∘ (Prod_Functor F G))
                –≻ ((Hom_Func D) ∘ (Prod_Functor F' G')))%nattrans
          )
  .

  Local Obligation Tactic := idtac.
  
  Program Definition Prod_Func_Hom_Func_NT :
    (((Hom_Func (C^op)) ∘ (Prod_Functor G F))
       –≻ ((Hom_Func (D^op)) ∘ (Prod_Functor G' F')))%nattrans :=
    {|
      Trans := fun c h => Trans N (snd c, fst c) h
    |}.

End Prod_Func_Hom_Func_NT.
  
Section Prod_Func_Hom_Func.
  Context {A B C D : Category}
          {F : A –≻ C^op}
          {F' : A –≻ D^op}
          {G : B –≻ C}
          {G' : B –≻ D}
          (N : (
                 ((Hom_Func C) ∘ (Prod_Functor F G))%functor
                   ≃ ((Hom_Func D) ∘ (Prod_Functor F' G'))%functor
               )%natiso
          )
  .
  
  Local Ltac TRC :=
  match goal with
    [|- ?W = _] =>
    match W with
      Trans ?A ?X (Trans ?B ?X ?Z) =>
      change W with (Trans (NatTrans_compose B A) X Z)
    end
  end.

  Local Obligation Tactic :=
    apply NatTrans_eq_simplify; FunExt; basic_simpl; TRC;
    solve [(cbn_rewrite (right_inverse N); trivial) |
           (cbn_rewrite (left_inverse N); trivial)].

  Program Definition Prod_Func_Hom_Func :
    ((((Hom_Func (C^op)) ∘ (Prod_Functor G F))%functor)
       ≃ ((Hom_Func (D^op)) ∘ (Prod_Functor G' F'))%functor)%natiso
    :=
      {|
        iso_morphism := Prod_Func_Hom_Func_NT (iso_morphism N);
        inverse_morphism := Prod_Func_Hom_Func_NT (inverse_morphism N)
      |}
  .
  
End Prod_Func_Hom_Func.

Section Prod_Func_Hom_Func_invl.
  Context {A B C D : Category}
          {F : A –≻ C^op}
          {F' : A –≻ D^op}
          {G : B –≻ C}
          {G' : B –≻ D}
          (N :
             (
               ((Hom_Func C) ∘ (Prod_Functor F G))%functor
                 ≃ ((Hom_Func D) ∘ (Prod_Functor F' G'))%functor
             )%natiso
          )
  .

  Theorem Prod_Func_Hom_Func_invl :
    N = Prod_Func_Hom_Func (Prod_Func_Hom_Func N).

End Prod_Func_Hom_Func_invl.

Section Hom_Func_to_Iso_Hom_Func.
  Context {C D : Category} (I : (C ≃≃ D ::> Cat)%isomorphism).

  Local Obligation Tactic := idtac.
  
  Program Definition Hom_Func_to_Iso_Hom_Func :
    (
      (Hom_Func C)
        –≻ ((Hom_Func D)
              ∘
              (Prod_Functor ((iso_morphism I)^op) (iso_morphism I)))
    )%nattrans :=
    {|
      Trans := fun c h => ((iso_morphism I) _a h)%morphism
    |}.

  Program Definition Iso_Hom_Func_to_Hom_Func :
    (((Hom_Func D) ∘ (Prod_Functor ((iso_morphism I)^op) (iso_morphism I)))
       –≻ (Hom_Func C))%nattrans
    :=
    {|
      Trans := fun c h => Cat_Iso_conv_inv I ((inverse_morphism I) _a h)
    |}.

  Program Definition Hom_Func_Cat_Iso :
    (
      (Hom_Func C)
        ≃ ((Hom_Func D)
             ∘ (Prod_Functor ((iso_morphism I)^op) (iso_morphism I)))%functor
    )%natiso :=
    {|
      iso_morphism := Hom_Func_to_Iso_Hom_Func;
      inverse_morphism := Iso_Hom_Func_to_Hom_Func
    |}.
  
End Hom_Func_to_Iso_Hom_Func. *)

From Categories Require Import NatTrans.NatTrans NatTrans.NatIso.
(* Categories.NatTrans.NatTrans:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Functor.
From Categories Require Import Cat.Cat.

Section NatTrans.
  Context {C C' : Category}.

  Record NatTrans (F F' : (C –≻ C')%functor) :=
    {
      Trans (c : C) : ((F _o c) –≻ (F' _o c))%object%morphism;
      Trans_com {c c' : C} (h : (c –≻ c')%morphism) :
        ((Trans c') ∘ F _a h = F' _a h ∘ (Trans c))%morphism;
      Trans_com_sym {c c' : C} (h : (c –≻ c')%morphism) :
        (F' _a h ∘ (Trans c) = (Trans c') ∘ F _a h)%morphism
    }.

  Notation "F –≻ F'" := (NatTrans F F') : nattrans_scope.

  Lemma NatTrans_eq_simplify {F F' : (C –≻ C')%functor}
        (N N' : (F –≻ F')%nattrans) : (@Trans _ _ N) = (@Trans _ _ N') -> N = N'.

End NatTrans.

Arguments Trans {_ _ _ _} _ _.
Arguments Trans_com {_ _ _ _} _ {_ _} _.
Arguments Trans_com_sym {_ _ _ _} _ {_ _} _.

Bind Scope nattrans_scope with NatTrans.

Notation "F –≻ F'" := (NatTrans F F') : nattrans_scope.

Local Open Scope nattrans_scope.

Section NatTrans_Compose.
  Context {C C' : Category}.
  
  Program Definition NatTrans_compose {F F' F'' : (C –≻ C')%functor}
          (tr : F –≻ F') (tr' : F' –≻ F'') : (F –≻ F'')%nattrans :=
    {|
      Trans := fun c : Obj => ((Trans tr' c) ∘ (Trans tr c)) % morphism
    |}.

End NatTrans_Compose.

Notation "N ∘ N'" := (NatTrans_compose N' N) : nattrans_scope.

Section NatTrans_Props.
  Context {C C' : Category}.
  
  Theorem NatTrans_compose_assoc {F G H I : (C –≻ C')%functor} (N : F –≻ G)
          (N' : G –≻ H) (N'' : H –≻ I)
    : ((N'' ∘ N') ∘ N = N'' ∘ (N' ∘ N))%nattrans
  .

  Program Definition NatTrans_id (F : (C –≻ C')%functor) : F –≻ F :=
    {|
      Trans := fun x : Obj => id
    |}.

  Theorem NatTrans_id_unit_left {F G : (C –≻ C')%functor} (N : F –≻ G)
    : (NatTrans_id G) ∘ N = N.

  Theorem NatTrans_id_unit_right {F G : (C –≻ C')%functor} (N : F –≻ G)
    : N ∘ (NatTrans_id F) = N.
  
End NatTrans_Props.

Hint Resolve NatTrans_eq_simplify. *)
(* Categories.NatTrans.NatIso:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Functor Functor.Functor_Ops Functor.Functor_Properties.
From Categories Require Import Cat.Cat.
From Categories Require Import NatTrans.NatTrans NatTrans.Func_Cat NatTrans.Operations.

Local Hint Extern 1 => apply NatTrans_eq_simplify; cbn.

Local Open Scope nattrans_scope.

Notation "a ≃ b" := (a ≃≃ b ::> Func_Cat _ _)%isomorphism : natiso_scope.

Section NatIso.
  Context {C C' : Category} (F G : (C –≻ C')%functor)
          (n : F –≻ G) (n' : G –≻ F).

  Program Definition NatIso
          (H : (∀ (c : Obj), (Trans n c) ∘ (Trans n' c)
                             = (id (G _o c)))%morphism)
          (H' : (∀ (c : Obj), (Trans n' c) ∘ (Trans n c)
                              = (id (F _o c)))%morphism)
    : (F ≃ G)%natiso
    := (Build_Isomorphism (Func_Cat _ _) _ _ n n' _ _).

End NatIso.

Section NatTrans_id_Iso.
  Context {C D : Category} (F : (C –≻ D)%functor).

  Definition NatTrans_id_Iso :
    (F ≃ F)%natiso := @Isomorphism_id (Func_Cat _ _) F.

End NatTrans_id_Iso.

Section NatIso_hor_comp.
  Context {C D E : Category} {F F' : (C –≻ D)%functor}
          {G G' : (D –≻ E)%functor} (N : (F ≃ F')%natiso)
          (N' : (G ≃ G')%natiso).

  Local Obligation Tactic := idtac.

  Program Definition NatIso_hor_comp
    : ((G ∘ F)%functor ≃ (G' ∘ F')%functor)%natiso :=
    {|
      iso_morphism := ((iso_morphism N') ∘_h (iso_morphism N))%nattrans;
      inverse_morphism :=
        ((inverse_morphism N') ∘_h (inverse_morphism N))%nattrans
    |}.

End NatIso_hor_comp.

Notation "f ∘_h g" := (NatIso_hor_comp g f) : natiso_scope.

Section Opposite_NatIso.
  Context {C D : Category} {F G : (C –≻ D)%functor} (N : (F ≃ G)%natiso).

  Program Definition Opposite_NatIso : (F^op%functor ≃ G^op%functor)%natiso :=
    {|
      iso_morphism := (inverse_morphism N)^op%nattrans;
      inverse_morphism := (iso_morphism N)^op%nattrans
    |}.

End Opposite_NatIso.

Notation "f ^op" := (Opposite_NatIso f) : natiso_scope.

Section Embedding_mono.
  Context {C C' : Category} (F : Embedding C C') {B : Category}.

  Local Obligation Tactic := idtac.

  Section Embedding_mono_NT.
    Context {G G' : (B –≻ C)%functor}
            (H : ((F ∘ G)%functor ≃ (F ∘ G')%functor)%natiso).
    
    Program Definition Embedding_mono_NT :  G –≻ G' :=
      {|
        Trans := fun c => proj1_sig (Emb_Full _ (Trans (iso_morphism H) c))
      |}.

  End Embedding_mono_NT.

  Context {G G' : (B –≻ C)%functor}
          (H : ((F ∘ G)%functor ≃ (F ∘ G')%functor)%natiso).
  
  Program Definition Embedding_mono : (G ≃ G')%natiso  :=
    {|
      iso_morphism := Embedding_mono_NT H;
      inverse_morphism := Embedding_mono_NT (H⁻¹)
    |}.

End Embedding_mono.

Section NatIso_Functor_assoc.
  Context {C1 C2 C3 C4 : Category}
          (F : (C1 –≻ C2)%functor)
          (G : (C2 –≻ C3)%functor)
          (H : (C3 –≻ C4)%functor).
  
  Program Definition NatIso_Functor_assoc
    : (((H ∘ G) ∘ F)%functor ≃ (H ∘ (G ∘ F))%functor)%natiso :=
    {|
      iso_morphism := NatTrans_Functor_assoc F G H;
      inverse_morphism := NatTrans_Functor_assoc_sym F G H
    |}.

End NatIso_Functor_assoc.

Section NatIso_Image.
  Context {C C' : Category} {F G : (C –≻ C')%functor} (N : (F ≃ G)%natiso).
  
  Program Definition NatIso_Image (c : C) : ((F _o c) ≃ (G _o c))%isomorphism :=
    {|
      iso_morphism := Trans (iso_morphism N) c;
      inverse_morphism := Trans (inverse_morphism N) c
    |}.
  
End NatIso_Image. *)

From Categories Require Import Adjunction.Adjunction.
(* Categories.Adjunction.Adjunction:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Ext_Cons.Prod_Cat.Prod_Cat Ext_Cons.Prod_Cat.Operations.
From Categories Require Import Functor.Main.
From Categories Require Import Functor.Representable.Hom_Func
        Functor.Representable.Hom_Func_Prop.
From Categories Require Import NatTrans.Main.

Local Open Scope functor_scope.

Local Notation NID := NatTrans_id (only parsing).
Local Notation FCAT := Func_Cat (only parsing).

Notation Hom_Adj_Left C D F G :=
  ((Hom_Func D) ∘ (Prod_Functor (F^op) (@Functor_id D)))%functor (only parsing).

Notation Hom_Adj_Right C D F G :=
  ((Hom_Func C) ∘ (Prod_Functor (@Functor_id (C^op)) G))%functor (only parsing).

Local Obligation Tactic := idtac.

Section Adjunction.
  Context {C D : Category} (F : C –≻ D) (G : D –≻ C).

  Record Adjunct : Type :=
  {
    adj_unit : ((Functor_id C) –≻ (G ∘ F))%nattrans;
    
    adj_morph_ex {c : C} {d : D} (f : (c –≻ (G _o d)%object)%morphism) :
      ((F _o c)%object –≻ d)%morphism;
    
    adj_morph_com {c : C} {d : D} (f : (c –≻ (G _o d))%morphism%object) :
      f = ((G _a (adj_morph_ex f)) ∘ (Trans adj_unit c))%morphism;
    
    adj_morph_unique {c : C} {d : D} (f : (c –≻ (G _o d))%object%morphism)
                     (g h : ((F _o c) –≻ d)%morphism%object) :
      f = ((G _a g) ∘ (Trans adj_unit c))%morphism →
      f = ((G _a h) ∘ (Trans adj_unit c))%morphism →
      g = h
  }.

  Arguments adj_unit : clear implicits.
  Arguments adj_morph_ex _ {_ _} _.
  Arguments adj_morph_com _ {_ _} _.
  Arguments adj_morph_unique _ {_ _} _ _ _ _ _.

  Theorem Adjunct_eq_simplify (adj adj' : Adjunct) :
    adj_unit adj = @adj_unit adj' →
    @adj_morph_ex adj = @adj_morph_ex adj' → adj = adj'.

  Definition Hom_Adjunct :=
    (Hom_Adj_Left _ _ F G ≃ Hom_Adj_Right _ _ F G)%natiso.

  Record UCU_Adjunct :=
    {
      ucu_adj_unit : ((Functor_id C) –≻ (G ∘ F))%nattrans;
      
      ucu_adj_counit : ((F ∘ G) –≻ (Functor_id D))%nattrans;

      ucu_adj_left_id : ((NatTrans_from_compose_id _)
                           ∘ ((((ucu_adj_counit ∘_h (NID F))
                                  ∘ (NatTrans_Functor_assoc_sym _ _ _))
                                 ∘ ((NID F) ∘_h ucu_adj_unit))
                                ∘ (NatTrans_to_id_compose _)))%nattrans
                        = (NID F);
      
      ucu_adj_right_id : ((NatTrans_from_id_compose _)
                            ∘ (((((NID G) ∘_h ucu_adj_counit)
                                   ∘ (NatTrans_Functor_assoc _ _ _))
                                  ∘ (ucu_adj_unit ∘_h (NID G)))
                                 ∘ (NatTrans_to_compose_id _)))%nattrans
                         = (NID G)
    }.

  Arguments ucu_adj_unit : clear implicits.
  Arguments ucu_adj_counit : clear implicits.
  Arguments ucu_adj_left_id : clear implicits.
  Arguments ucu_adj_right_id : clear implicits.

  Local Notation "F ⊣ G" := (Adjunct) : functor_scope.
  Local Notation "F ⊣_hom G" := (Hom_Adjunct) : functor_scope.
  Local Notation "F ⊣_ucu G" := (UCU_Adjunct) : functor_scope.
  
  Section UCU_Adj_Adj.
    Context (Adj : (F ⊣_ucu G)%functor).

    Program Definition UCU_Adj_to_Adj : (F ⊣ G)%functor :=
      {|
        adj_unit := ucu_adj_unit Adj;
        adj_morph_ex :=
          fun _ _ h => ((Trans (ucu_adj_counit Adj) _) ∘ (F _a h))%morphism
      |}.

  End UCU_Adj_Adj.

  Section Adj_UCU_Adj.
    Context (Adj : (F ⊣ G)%functor).
    
    Program Definition Adj_to_UCU_Adj : (F ⊣_ucu G)%functor :=
      {|
        ucu_adj_unit := adj_unit Adj;
        ucu_adj_counit :=
          {|
            Trans := fun d => @adj_morph_ex Adj (G _o d) d id
          |}
      |}.

  End Adj_UCU_Adj.
  
  Section Adj_Hom_Adj.
    Context (Adj : (F ⊣ G)%functor).

    Program Definition Adj_to_Hom_Adj_LR :
      ((Hom_Adj_Left _ _ F G) –≻ (Hom_Adj_Right _ _ F G))%nattrans :=
    {|
      Trans := fun c h => ((G _a h) ∘ (Trans (adj_unit Adj) _))%morphism
    |}.

    Program Definition Adj_to_Hom_Adj_RL :
      ((Hom_Adj_Right _ _ F G) –≻ (Hom_Adj_Left _ _ F G))%nattrans :=
    {|
      Trans := fun c h => adj_morph_ex Adj h
    |}.

    Program Definition Adj_to_Hom_Adj : (F ⊣_hom G)%functor :=
      NatIso _ _ Adj_to_Hom_Adj_LR Adj_to_Hom_Adj_RL _ _.

  End Adj_Hom_Adj.

  Section Hom_Adj_Adj.
    Context (Adj : (F ⊣_hom G)%functor).

    Program Definition Hom_Adj_to_Adj : (F ⊣ G)%functor :=
      {|
        adj_unit :=
          {| Trans := fun c => Trans (iso_morphism Adj) (c, F _o c)%object id |};
        adj_morph_ex := fun _ _ f => Trans (inverse_morphism Adj) (_, _) f
      |}.

  End Hom_Adj_Adj.

End Adjunction.

Arguments adj_unit {_ _ _ _} _ : assert.
Arguments adj_morph_ex {_ _ _ _} _ {_ _} _.
Arguments adj_morph_com {_ _ _ _} _ {_ _} _.
Arguments adj_morph_unique {_ _ _ _} _ {_ _} _ _ _ _ _.

Arguments ucu_adj_unit {_ _ _ _} _.
Arguments ucu_adj_counit {_ _ _ _} _.
Arguments ucu_adj_left_id {_ _ _ _} _.
Arguments ucu_adj_right_id {_ _ _ _} _.

Arguments Adj_to_Hom_Adj {_ _ _ _} _.

Arguments Hom_Adj_to_Adj {_ _ _ _} _.

Notation "F ⊣ G" := (Adjunct F G) : functor_scope.
Notation "F ⊣_hom G" := (Hom_Adjunct F G) : functor_scope.
Notation "F ⊣_ucu G" := (UCU_Adjunct F G) : functor_scope. *)



Local Open Scope functor_scope.



Section Hom_Adj_Duality.

  Context {C D : Category} {F : C –≻ D} {G : D –≻ C} (adj : F ⊣_hom G).



  Definition Hom_Adjunct_Duality : G^op ⊣_hom F^op :=

    (Prod_Func_Hom_Func (adj⁻¹))

  .



End Hom_Adj_Duality.



Section Adj_Duality.

  Context {C D : Category} {F : C –≻ D} {G : D –≻ C} (adj : F ⊣ G).



  Definition Adjunct_Duality : G^op ⊣ F^op :=

    (Hom_Adj_to_Adj (Hom_Adjunct_Duality (Adj_to_Hom_Adj adj)))

  .



End Adj_Duality.

