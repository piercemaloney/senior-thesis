From Categories Require Import Essentials.Notations.
(* Categories.Essentials.Notations:
Notation "∀ x .. y , P" := (forall x, .. (forall y, P) ..)
                             (at level 200, x binder, y binder, right associativity) : type_scope.

Notation "∃ x .. y , P" := (exists x, .. (exists y, P) ..)
  (at level 200, x binder, y binder, right associativity) : type_scope.

Notation "x ∨ y" := (x \/ y) (at level 85, right associativity) : type_scope.

Notation "x ∧ y" := (x /\ y) (at level 80, right associativity) : type_scope.

Notation "x → y" := (x -> y)
  (at level 90, y at level 200, right associativity): type_scope.

Notation "x ↔ y" := (x <-> y) (at level 95, no associativity): type_scope.

Notation "¬ x" := (~x) (at level 75, right associativity) : type_scope.

Notation "x ≠ y" := (x <> y) (at level 70) : type_scope.

Notation "x ≤ y" := (le x y) (at level 70, no associativity).

Notation "x ≥ y" := (ge x y) (at level 70, no associativity).

Reserved Notation "C '^op'" (at level 50, no associativity).

Reserved Notation "a –≻ b" (at level 90, b at level 200, right associativity).

Reserved Notation "f '⁻¹'" (at level 50, no associativity).

Reserved Notation "a ≃ b" (at level 70, no associativity).

Reserved Notation "a ≃≃ b ::> C" (at level 70, no associativity).

Reserved Notation "f ∘ g" (at level 51, right associativity).

Reserved Notation "f '∘_h' g" (at level 51, right associativity).

Reserved Notation "a ≫–> b" (at level 100, no associativity).

Reserved Notation "a –≫ b" (at level 100, no associativity).

Reserved Notation "F '_o'" (at level 50, no associativity).

Reserved Notation "F '_a'" (at level 50, no associativity).

Reserved Notation "F '@_a'" (at level 50, no associativity).

Reserved Notation "F ⊣ G" (at level 100, no associativity).

Reserved Notation "F ⊣_hom G" (at level 100, no associativity).

Reserved Notation "F ⊣_ucu G" (at level 100, no associativity).

Reserved Notation "a × b" (at level 80, no associativity).

Reserved Notation "a ⇑ b" (at level 79, no associativity).

Reserved Notation "'Π' m" (at level 50, no associativity).

Reserved Notation "'Σ' m" (at level 50, no associativity).

Reserved Notation "'Π_' C ↓ m" (at level 50, no associativity).

Reserved Notation "'Σ_' C ↓ m" (at level 50, no associativity).

Delimit Scope category_scope with category.

Delimit Scope morphism_scope with morphism.

Delimit Scope object_scope with object.

Delimit Scope functor_scope with functor.

Delimit Scope nattrans_scope with nattrans.

Delimit Scope nattrans_scope with nattrans.

Delimit Scope natiso_scope with natiso.

Delimit Scope isomorphism_scope with isomorphism.

Delimit Scope preorder_scope with preorder. *)

From Categories Require Import Essentials.Types.
(* Categories.Essentials.Types:
Global Set Primitive Projections.

Global Set Universe Polymorphism.

Global Unset Universe Minimization ToSet.

Inductive Empty : Type :=.

Hint Extern 1 =>
let tac := (repeat intros ?); match goal with [H : Empty |- _] => contradict H end in
match goal with
  | [|- context[Empty]] => tac
  | [H : context[Empty] |- _] => tac
end
.

Record prod (A B : Type) := {fst : A; snd : B}.

Arguments fst {_ _ } _.
Arguments snd {_ _ } _.
Arguments Build_prod {_ _ } _ _.

Notation "( X , Y )" := (Build_prod X Y).
Notation "X * Y" := (prod X Y) : type_scope. *)

From Categories Require Import Essentials.Facts_Tactics.
(* Categories.Essentials.Facts_Tactics:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.

Require Export Coq.Program.Tactics.
Require Export Coq.Program.Equality.
Require Export Coq.Logic.FunctionalExtensionality.
Require Export Coq.Logic.ProofIrrelevance.

Definition equal_f : ∀ {A B : Type} {f g : A → B}, f = g → ∀ x : A, f x = g x.

Definition f_equal : ∀ (A B : Type) (f : A → B) (x y : A), x = y → f x = f y.

Arguments f_equal [_ _] _ [_ _] _.

Ltac basic_simpl :=
  let simpl_prod _ :=
      match goal with
        [H : prod _ _ |- _] =>
        let H1 := fresh H "1" in
        let H2 := fresh H "2" in
        destruct H as [H1 H2]
      end
  in
  let simpl_sig _ :=
      match goal with
        [H : @sig _ _ |- _] =>
        let H1 := fresh H "1" in
        let H2 := fresh H "2" in
        destruct H as [H1 H2]
      end
  in
  let basic_simpl_helper _ :=
      cbn in *; intros;
        repeat simpl_prod tt;
        repeat simpl_sig tt
  in
  repeat basic_simpl_helper tt
.

Global Obligation Tactic := basic_simpl; auto.

Ltac PIR :=
  let pir_helper _ :=
      match goal with
      |[H : ?A, H' : ?A|- _] =>
       match type of A with
       | Prop =>
         destruct (proof_irrelevance _ H H')
       end
      end
  in
  repeat pir_helper tt
.

Ltac ElimEq := repeat match goal with [H : _ = _|- _] => destruct H end.

Hint Extern 1 => progress ElimEq.

Ltac cbn_rewrite W :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite H; clear H
.

Ltac cbn_rewrite_in W V :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite H in V; clear H
.

Ltac cbn_rewrite_back W :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite <- H; clear H
.

Ltac cbn_rewrite_back_in W V :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite <- H in V; clear H
.

Tactic Notation "cbn_rewrite" constr(W) := cbn_rewrite W.
Tactic Notation "cbn_rewrite" constr(W) "in" hyp_list(V) := cbn_rewrite_in W V.
Tactic Notation "cbn_rewrite" "<-" constr(W) := cbn_rewrite_back W.
Tactic Notation "cbn_rewrite" "<-" constr(W) "in" hyp_list(V) := cbn_rewrite_back_in W V.

Lemma sig_proof_irrelevance {A : Type} (P : A → Prop) (X Y : sig P) : proj1_sig X = proj1_sig Y → X = Y.

Hint Extern 2 (exist ?A _ _ = exist ?A _ _) => apply sig_proof_irrelevance.

Ltac FunExt :=
progress (
    repeat (
        match goal with
          [|- _ = _] =>
          let x := fresh "x" in
          extensionality x
        end
      )
  )
.

Hint Extern 1 => FunExt.

Lemma pair_eq (A B : Type) (a b : A * B) : fst a = fst b → snd a = snd b → a = b.

Hint Resolve pair_eq.

Ltac revert_clearbody_all :=
 repeat lazymatch goal with H:_ |- _ => try clearbody H; revert H end.

Ltac hyp_stack :=
 constr:(ltac:(revert_clearbody_all;constructor) : True).

Ltac next_hyp hs step last :=
 lazymatch hs with (?hs' ?H) => step H hs' | _ => last end.

Tactic Notation "dohyps" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := tac H; next_hyp hs step idtac in
 next_hyp hs step idtac.

Tactic Notation "dohyps" "reverse" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := next_hyp hs step idtac; tac H in
 next_hyp hs step idtac.

Tactic Notation "do1hyp" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := tac H + next_hyp hs step fail in
 next_hyp hs step fail.

Tactic Notation "do1hyp" "reverse" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := next_hyp hs step fail + tac H in
 next_hyp hs step fail. *)

From Categories Require Import Category.Main.
(* Categories.Category.Main:
From Categories Require Export Category.Category.
From Categories Require Export Category.Morph.
From Categories Require Export Category.Opposite.
From Categories Require Export Category.SubCategory.
From Categories Require Export Category.Composable_Chain. *)

From Categories Require Import Functor.Main.
(* Categories.Functor.Main:
From Categories Require Export Functor.Functor.
From Categories Require Export Functor.Functor_Extender.
From Categories Require Export Functor.Functor_Image.
From Categories Require Export Functor.Functor_Ops.
From Categories Require Export Functor.Functor_Properties.
From Categories Require Export Functor.Const_Func.
From Categories Require Export Functor.Const_Func_Functor. *)

From Categories Require Import Topos.SubObject_Classifier.
(* Categories.Topos.SubObject_Classifier:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Basic_Cons.PullBack Basic_Cons.Terminal.

Section SubObject_Classifier.
  Context (C : Category) {term : (𝟙_ C)%object}.

  Local Notation "1" := term.
  
  Record SubObject_Classifier : Type :=
    {
      SOC : C;
      SOC_morph : (1 –≻ SOC)%morphism;
      SOC_char {a b : C} (m : (a ≫–> b)%morphism) : (b –≻ SOC)%morphism;
      SO_pulback {a b : C} (m : (a ≫–> b)%morphism) :
        is_PullBack
          (mono_morphism m)
          (t_morph 1 a)
          (SOC_char m)
          SOC_morph;
      SOC_char_unique {a b : C} (m : (a ≫–> b)%morphism)
                      (h h' : (b –≻ SOC)%morphism) :
        is_PullBack
          (mono_morphism m)
          (t_morph 1 a)
          h
          SOC_morph
        →
        is_PullBack
          (mono_morphism m)
          (t_morph 1 a)
          h'
          SOC_morph
        →
        h = h'
    }.

End SubObject_Classifier. *)

From Categories Require Import Basic_Cons.Terminal Basic_Cons.PullBack.
(* Categories.Basic_Cons.Terminal:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Main.

Class Terminal (C : Category) : Type :=
{
  terminal : C;
  t_morph : ∀ (d : Obj), (d –≻ terminal)%morphism;
  t_morph_unique : ∀ (d : Obj) (f g : (d –≻ terminal)%morphism), f = g
}.

Arguments terminal {_} _.
Arguments t_morph {_} _ _.
Arguments t_morph_unique {_} _ _ _ _.

Coercion terminal : Terminal >-> Obj.

Notation "𝟙_ C" := (Terminal C) (at level 75) : object_scope.

Theorem Terminal_iso {C : Category} (T T' : (𝟙_ C)%object) :
  (T ≃ T')%isomorphism.

Definition Initial (C : Category) := (𝟙_ (C ^op))%object.
Existing Class Initial.

Notation "𝟘_ C" := (Initial C) (at level 75) : object_scope. *)
(* Categories.Basic_Cons.PullBack:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.

Local Open Scope morphism_scope.

Section PullBack.
  Context {C : Category} {a b x : C} (f : a –≻ x) (g : b –≻ x).

  Record PullBack : Type :=
    {
      pullback : C;

      pullback_morph_1 : pullback –≻ a;

      pullback_morph_2 : pullback –≻ b;

      pullback_morph_com : f ∘ pullback_morph_1 = g ∘ pullback_morph_2;

      pullback_morph_ex (p' : Obj) (pm1 : p' –≻ a) (pm2 : p' –≻ b) :
        f ∘ pm1 = g ∘ pm2 → p' –≻ pullback;

      pullback_morph_ex_com_1 (p' : Obj) (pm1 : p' –≻ a) (pm2 : p' –≻ b)
                              (pmc : f ∘ pm1 = g ∘ pm2)
      :
        pullback_morph_1 ∘ (pullback_morph_ex p' pm1 pm2 pmc) = pm1;

      pullback_morph_ex_com_2 (p' : Obj) (pm1 : p' –≻ a) (pm2 : p' –≻ b)
                              (pmc : f ∘ pm1 = g ∘ pm2)
      :
        pullback_morph_2 ∘ (pullback_morph_ex p' pm1 pm2 pmc) = pm2;

      pullback_morph_ex_unique
        (p' : Obj) (pm1 : p' –≻ a) (pm2 : p' –≻ b)
        (pmc : f ∘ pm1 = g ∘ pm2) (u u' : p' –≻ pullback) :
        pullback_morph_1 ∘ u = pm1 →
        pullback_morph_2 ∘ u = pm2 →
        pullback_morph_1 ∘ u' = pm1 →
        pullback_morph_2 ∘ u' = pm2 → u = u'
    }.

  Coercion pullback : PullBack >-> Obj.

  Theorem PullBack_iso (p1 p2 : PullBack) : (p1 ≃ p2)%isomorphism.

End PullBack.

Section is_PullBack.
  Context {C : Category} {a b x pb : C} (p1 : pb –≻ a)
          (p2 : pb –≻ b) (f : a –≻ x) (g : b –≻ x).

  Local Open Scope morphism_scope.
  
  Record is_PullBack : Type :=
    {
      is_pullback_morph_com : f ∘ p1 = g ∘ p2;

      is_pullback_morph_ex (p' : Obj) (pm1 : p' –≻ a) (pm2 : p' –≻ b) :
        f ∘ pm1 = g ∘ pm2 → p' –≻ pb;

      is_pullback_morph_ex_com_1 (p' : Obj) (pm1 : p' –≻ a) (pm2 : p' –≻ b)
                                 (pmc : f ∘ pm1 = g ∘ pm2)
      :
        p1 ∘ (is_pullback_morph_ex p' pm1 pm2 pmc) = pm1;

      is_pullback_morph_ex_com_2 (p' : Obj) (pm1 : p' –≻ a) (pm2 : p' –≻ b)
                                 (pmc : f ∘ pm1 = g ∘ pm2)
      :
        p2 ∘ (is_pullback_morph_ex p' pm1 pm2 pmc) = pm2;

      is_pullback_morph_ex_unique
        (p' : Obj) (pm1 : p' –≻ a) (pm2 : p' –≻ b)
        (pmc : f ∘ pm1 = g ∘ pm2) (u u' : p' –≻ pb) :
        p1 ∘ u = pm1 →
        p2 ∘ u = pm2 →
        p1 ∘ u' = pm1 →
        p2 ∘ u' = pm2 → u = u'
    }.

End is_PullBack.

Definition Has_PullBacks (C : Category) : Type :=
  ∀ (a b c : C) (f : a –≻ c) (g : b –≻ c), PullBack f g.

Existing Class Has_PullBacks.

Arguments PullBack _ {_ _ _} _ _, {_ _ _ _} _ _.
Arguments pullback {_ _ _ _ _ _} _.
Arguments pullback_morph_1 {_ _ _ _ _ _} _.
Arguments pullback_morph_2 {_ _ _ _ _ _} _.
Arguments pullback_morph_com {_ _ _ _ _ _} _.
Arguments pullback_morph_ex {_ _ _ _ _ _} _ _ _ _ _.
Arguments pullback_morph_ex_com_1 {_ _ _ _ _ _} _ _ _ _ _.
Arguments pullback_morph_ex_com_2 {_ _ _ _ _ _} _ _ _ _ _.
Arguments pullback_morph_ex_unique {_ _ _ _ _ _} _ _ _ _ _ _ _ _ _ _ _.

Arguments is_PullBack _ { _ _ _ _} _ _ _ _, {_ _ _ _ _ } _ _ _ _.

Arguments is_pullback_morph_com {_ _ _ _ _ _ _ _ _} _.
Arguments is_pullback_morph_ex {_ _ _ _ _ _ _ _ _} _ _ _ _ _.
Arguments is_pullback_morph_ex_com_1 {_ _ _ _ _ _ _ _ _} _ _ _ _ _.
Arguments is_pullback_morph_ex_com_2 {_ _ _ _ _ _ _ _ _} _ _ _ _ _.
Arguments is_pullback_morph_ex_unique {_ _ _ _ _ _ _ _ _} _ _ _ _ _ _ _ _ _ _ _.

Section is_PullBack_PullBack.
  Context {C : Category} {a b x pb : C} {p1 : pb –≻ a} {p2 : pb –≻ b} {f : a –≻ x}
          {g : b –≻ x} (iPB : is_PullBack p1 p2 f g).

  Definition is_PullBack_PullBack : PullBack f g :=
    {|
      pullback := pb;
      pullback_morph_1 := p1;
      pullback_morph_2 := p2;
      pullback_morph_com := is_pullback_morph_com iPB;
      pullback_morph_ex := fun p' pm1 pm2 => is_pullback_morph_ex iPB p' pm1 pm2;
      pullback_morph_ex_com_1 :=
        fun p' pm1 pm2 pmc => is_pullback_morph_ex_com_1 iPB p' pm1 pm2 pmc;
      pullback_morph_ex_com_2 :=
        fun p' pm1 pm2 pmc => is_pullback_morph_ex_com_2 iPB p' pm1 pm2 pmc;
      pullback_morph_ex_unique :=
        fun p' pm1 pm2 pmc u u' => is_pullback_morph_ex_unique iPB p' pm1 pm2 pmc u u'
    |}.

End is_PullBack_PullBack.

Section PullBack_is_PullBack.
  Context {C : Category} {a b x : C} {f : a –≻ x}
          {g : b –≻ x} (PB : PullBack f g).

  Definition PullBack_is_PullBack :
    is_PullBack (pullback_morph_1 PB) (pullback_morph_2 PB) f g :=
    {|
      is_pullback_morph_com := pullback_morph_com PB;
      is_pullback_morph_ex := fun p' pm1 pm2 => pullback_morph_ex PB p' pm1 pm2;
      is_pullback_morph_ex_com_1 :=
        fun p' pm1 pm2 pmc => pullback_morph_ex_com_1 PB p' pm1 pm2 pmc;
      is_pullback_morph_ex_com_2 :=
        fun p' pm1 pm2 pmc => pullback_morph_ex_com_2 PB p' pm1 pm2 pmc;
      is_pullback_morph_ex_unique :=
        fun p' pm1 pm2 pmc u u' => pullback_morph_ex_unique PB p' pm1 pm2 pmc u u'
    |}.

End PullBack_is_PullBack.
  
Definition PushOut (C : Category) := @PullBack (C^op).

Arguments PushOut _ {_ _ _} _ _, {_ _ _ _} _ _.

Definition Has_PushOuts (C : Category) : Type :=
  ∀ (a b c : C) (f : c –≻ a) (g : c –≻ b), PushOut f g.

Existing Class Has_PushOuts. *)

From Categories Require Import NatTrans.NatTrans NatTrans.Func_Cat.
(* Categories.NatTrans.NatTrans:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Functor.
From Categories Require Import Cat.Cat.

Section NatTrans.
  Context {C C' : Category}.

  Record NatTrans (F F' : (C –≻ C')%functor) :=
    {
      Trans (c : C) : ((F _o c) –≻ (F' _o c))%object%morphism;
      Trans_com {c c' : C} (h : (c –≻ c')%morphism) :
        ((Trans c') ∘ F _a h = F' _a h ∘ (Trans c))%morphism;
      Trans_com_sym {c c' : C} (h : (c –≻ c')%morphism) :
        (F' _a h ∘ (Trans c) = (Trans c') ∘ F _a h)%morphism
    }.

  Notation "F –≻ F'" := (NatTrans F F') : nattrans_scope.

  Lemma NatTrans_eq_simplify {F F' : (C –≻ C')%functor}
        (N N' : (F –≻ F')%nattrans) : (@Trans _ _ N) = (@Trans _ _ N') -> N = N'.

End NatTrans.

Arguments Trans {_ _ _ _} _ _.
Arguments Trans_com {_ _ _ _} _ {_ _} _.
Arguments Trans_com_sym {_ _ _ _} _ {_ _} _.

Bind Scope nattrans_scope with NatTrans.

Notation "F –≻ F'" := (NatTrans F F') : nattrans_scope.

Local Open Scope nattrans_scope.

Section NatTrans_Compose.
  Context {C C' : Category}.
  
  Program Definition NatTrans_compose {F F' F'' : (C –≻ C')%functor}
          (tr : F –≻ F') (tr' : F' –≻ F'') : (F –≻ F'')%nattrans :=
    {|
      Trans := fun c : Obj => ((Trans tr' c) ∘ (Trans tr c)) % morphism
    |}.

End NatTrans_Compose.

Notation "N ∘ N'" := (NatTrans_compose N' N) : nattrans_scope.

Section NatTrans_Props.
  Context {C C' : Category}.
  
  Theorem NatTrans_compose_assoc {F G H I : (C –≻ C')%functor} (N : F –≻ G)
          (N' : G –≻ H) (N'' : H –≻ I)
    : ((N'' ∘ N') ∘ N = N'' ∘ (N' ∘ N))%nattrans
  .

  Program Definition NatTrans_id (F : (C –≻ C')%functor) : F –≻ F :=
    {|
      Trans := fun x : Obj => id
    |}.

  Theorem NatTrans_id_unit_left {F G : (C –≻ C')%functor} (N : F –≻ G)
    : (NatTrans_id G) ∘ N = N.

  Theorem NatTrans_id_unit_right {F G : (C –≻ C')%functor} (N : F –≻ G)
    : N ∘ (NatTrans_id F) = N.
  
End NatTrans_Props.

Hint Resolve NatTrans_eq_simplify. *)
(* Categories.NatTrans.Func_Cat:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Functor Functor.Functor_Ops.
From Categories Require Import Cat.Cat.
From Categories Require Import NatTrans.NatTrans NatTrans.Operations.

Program Definition Func_Cat (C C' : Category) : Category :=
{|
  Obj := (C –≻ C')%functor;

  Hom := NatTrans;

  compose := @NatTrans_compose _ _;

  id := @NatTrans_id _ _;

  assoc := fun _ _ _ _ _ _ _ => @NatTrans_compose_assoc _ _ _ _ _ _ _ _ _;
             
  assoc_sym :=
    fun _ _ _ _ _ _ _ => eq_sym (@NatTrans_compose_assoc _ _ _ _ _ _ _ _ _);

  id_unit_right := @NatTrans_id_unit_right _ _;
  
  id_unit_left := @NatTrans_id_unit_left _ _
|}.

Section Opposite_Func_Cat.
  Context (C D : Category).

  Program Definition Op_Func_Cat_to_Func_Cat_Op
    : ((Func_Cat C D)^op –≻ (Func_Cat (C^op) (D^op)))%functor :=
    {|
      FO := Opposite_Functor;
      FA := fun _ _ => Opposite_NatTrans;
      F_id := fun _ => NatTrans_id_Op _;
      F_compose := fun _ _ _ _ _ => NatTrans_compose_Op _ _ 
    |}.

  Program Definition Func_Cat_Op_to_Op_Func_Cat
    : ((Func_Cat (C^op) (D^op)) –≻ (Func_Cat C D)^op)%functor :=
    {|
      FO := Opposite_Functor;
      FA := fun _ _ => Opposite_NatTrans;
      F_id := fun F => NatTrans_id_Op F;
      F_compose := fun _ _ _ N N' => NatTrans_compose_Op N N'
    |}.
  
  Program Definition Func_Cat_Op_Iso
    : ((((Func_Cat C D)^op)%category)
         ≃≃ (Func_Cat (C^op) (D^op)) ::> Cat) %isomorphism :=
    {|
      iso_morphism := Op_Func_Cat_to_Func_Cat_Op;
      inverse_morphism := Func_Cat_Op_to_Op_Func_Cat
    |}.

End Opposite_Func_Cat. *)

From Categories Require Import Coq_Cats.Type_Cat.CCC Coq_Cats.Type_Cat.Morphisms.
(* Categories.Coq_Cats.Type_Cat.CCC:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.

Local Notation "A × B" := (@Product Type_Cat A B) : object_scope.

Program Definition prod_Product (A B : Type) : (A × B)%object :=
{|
  product := (A * B)%type;
  Pi_1 := fst;
  Pi_2 := snd;
  Prod_morph_ex := fun p x y z => (x z, y z)
|}.

Program Instance Type_Cat_Has_Products : Has_Products Type_Cat := prod_Product.

Program Definition fun_exp (A B : Type_Cat) : (A ⇑ B)%object :=
{|
  exponential := A -> B;
  eval := fun x => (fst x) (snd x);
  Exp_morph_ex := fun h z u v=>  z (u, v)
|}.

Program Instance Type_Cat_Has_Exponentials : Has_Exponentials Type_Cat := fun_exp.

Program Instance Type_Cat_CCC : CCC Type_Cat. *)
(* Categories.Coq_Cats.Type_Cat.Morphisms:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Coq_Cats.Type_Cat.Type_Cat.

Section Monic_Iso_Monic_Factorization.
  Context
    {A B : Type}
    {f : A → B}
    (fm : @is_Monic Type_Cat _ _ f)
  .

  Definition Monic_Image_of : Type := {x : B & {a : A | f a = x}}.

  Definition Monic_From_Image_forward : Monic_Image_of → B := fun x => projT1 x.

  Program Definition Monic_Iso_Monic_Factor_Monic :
    @Monic Type_Cat Monic_Image_of B :=
    {|
      mono_morphism := Monic_From_Image_forward;
      mono_morphism_monomorphic := fun T g h => _
    |}
  .

  Definition Monic_To_Image : A → Monic_Image_of :=
    fun a => existT _ (f a) (exist _ a eq_refl).

  Definition Monic_From_Image_back : Monic_Image_of → A :=
    fun x => proj1_sig (projT2 x).

  Theorem Monic_From_Image_back_is_Monic :
    @is_Monic Type_Cat _ _ Monic_To_Image.

  Theorem Monic_To_Image_form_split_epic :
    (
      fun (x : Monic_Image_of) =>
        Monic_To_Image (Monic_From_Image_back x)
    ) = (fun x => x).

  Program Definition Monic_Iso_Monic_Factor_Iso :
    (A ≃≃ Monic_Image_of ::> Type_Cat)%isomorphism
    :=
      Monic_is_split_Epic_Iso
        _
        _
        (is_Monic_Monic Monic_From_Image_back_is_Monic)
        (
          @Build_is_split_Monic
            (Type_Cat ^op)
            _
            _
            Monic_To_Image
            _
            Monic_To_Image_form_split_epic
        )
  .

  Theorem Monic_Iso_Monic_Factorization :
    f = fun x =>  Monic_From_Image_forward (Monic_To_Image x).

End Monic_Iso_Monic_Factorization.

Require Import Coq.Logic.ChoiceFacts.

Local Axiom ConstructiveIndefiniteDescription_Type :
  forall T : Type, ConstructiveIndefiniteDescription_on T.

Section split_Epic_Monic_Factorization.
  Context {A B : Type} (f : A → B).

  Definition Image_of : Type := {x : B | ∃ a, f a = x}.

  Definition From_Image_forward : Image_of → B := fun x => proj1_sig x.

  Program Definition Epic_Monic_Factor_Monic : @Monic Type_Cat Image_of B :=
    {|
      mono_morphism := From_Image_forward;
      mono_morphism_monomorphic := fun T g h => _
    |}
  .

  Definition To_Image : A → Image_of :=
    fun a => exist _ (f a) (ex_intro _ a eq_refl).

  Definition From_Image_back : Image_of → A :=
    fun x => proj1_sig (ConstructiveIndefiniteDescription_Type _ _ (proj2_sig x)).

  Theorem From_Image_back_form_split_epic :
    ∀ (x : Image_of), To_Image (From_Image_back x) = x.

  Program Definition Epic_Monic_Factor_split_Epic :
    @is_split_Epic Type_Cat _ _ To_Image :=
    {|
      is_split_monic_left_inverse := From_Image_back
    |}.

  Theorem split_Epic_Monic_Factorization :
    f = fun x =>  From_Image_forward (To_Image x).

End split_Epic_Monic_Factorization. *)

From Categories Require Import

        PreSheaf.PreSheaf

        PreSheaf.Terminal

        PreSheaf.PullBack

        PreSheaf.Morphisms

.



Require Import Coq.Logic.ChoiceFacts.



Local Axiom ConstructiveIndefiniteDescription_Type :

  forall T : Type, ConstructiveIndefiniteDescription_on T.



Require Coq.Logic.ClassicalFacts.



Local Axiom PropExt : ClassicalFacts.prop_extensionality.



Section Sieve.

  Context {C : Category} (c : C).



  Local Open Scope morphism_scope.



  Definition Sieve :=

    {S : ∀ (x : C) (h : x –≻ c), Prop |

     ∀ (x : C) (h : x –≻ c), S x h → ∀ (y : C) (h' : y –≻ x), S y (h ∘ h')

    }.



  Definition TotalSieve : Sieve :=

    exist

      (fun S : ∀ x : C, (x –≻ c) → Prop =>

         ∀ (x : C) (h : x –≻ c), S x h → ∀ (y : C) (h' : y –≻ x), S y (h ∘ h'))

      (fun _ _ => True)

      (fun _ _ _ _ _ => I)

  .



End Sieve.



Section Sieve_PreSheaf.

  Context (C : Category).



  Local Open Scope morphism_scope.



  Program Definition Sieve_PreSheaf : PreSheaf C :=

    {|

      FO := fun c => @Sieve C c;

      FA :=

        fun c c' h S =>

          exist _ (fun y (h' : y –≻ c') => (proj1_sig S) _ (h ∘ h')) _

    |}

  .



  Local Obligation Tactic := idtac.



  Next Obligation.

  Proof.

    intros c c' h S x f H y g.

    rewrite assoc_sym.

    apply (proj2_sig S); trivial.

  Qed.



  Next Obligation.

  Proof.

    intros c.

    extensionality S.

    apply sig_proof_irrelevance.

    extensionality z.

    extensionality f.

    cbn in *; auto.

  Qed.



  Next Obligation.

  Proof.

    intros a b c f g.

    extensionality S.

    apply sig_proof_irrelevance.

    extensionality z.

    extensionality h.

    cbn in *.

    rewrite assoc; trivial.

  Qed.



  Program Definition True_PreSheaf_morphism :

    ((PSh_Term_PreSheaf C) –≻ Sieve_PreSheaf)%nattrans

    :=

      {|

        Trans := fun c _ => @TotalSieve C c

      |}.



  Local Hint Extern 1 => progress cbn.



  Next Obligation.

  Proof.

    intros c c' h.

    extensionality x.

    apply sig_proof_irrelevance.

    FunExt; cbn; trivial.

  Qed.



  Next Obligation.

  Proof.

    symmetry.

    apply True_PreSheaf_morphism_obligation_1.

  Qed.



End Sieve_PreSheaf.



Section PShCat_char_morph.

  Context

    {C : Category}

    {F G : PreSheaf C}

    (N : @Monic (PShCat C) F G)

  .



  Local Obligation Tactic := idtac.



  Program Definition PShCat_char_morph : (G –≻ (Sieve_PreSheaf C))%nattrans :=

    {|

      Trans :=

        fun c x =>

          exist

            _

            (fun y h => ∃ u, Trans (mono_morphism N) y u = (G _a h)%morphism x)

            _

    |}

  .



  Next Obligation.

  Proof.

    intros c x y h [u H1] z g.

    cbn in *.

    exists ((F _a g)%morphism u).

    cbn_rewrite (F_compose G h g).

    cbn_rewrite (equal_f (Trans_com (mono_morphism N) g)).

    rewrite H1.

    trivial.

  Qed.



  Next Obligation.

  Proof.

    intros c c' h.

    extensionality x.

    apply sig_proof_irrelevance.

    extensionality d.

    extensionality g.

    cbn in *.

    cbn_rewrite (F_compose G h g).

    trivial.

  Qed.



  Next Obligation.

  Proof.

    symmetry.

    apply PShCat_char_morph_obligation_2.

  Qed.



  Section PShCat_char_morph_forms_pullback_morph_ex.

    Context

      (p : PreSheaf C)

      (pm1 : (p –≻ G)%nattrans)

      (pm2 : (p –≻ PSh_Term_PreSheaf C)%nattrans)

      (H : (PShCat_char_morph ∘ pm1)%nattrans =

           (True_PreSheaf_morphism C ∘ pm2)%nattrans)

    .



    Definition PShCat_char_morph_forms_pullback_morph_ex_Trans

               (c : C)

               (x : (p _o c)%object)

      :

        (F _o c)%object

      :=

        proj1_sig

          (

            ConstructiveIndefiniteDescription_Type

              _

              _

              (

                match

                  eq_sym

                    (

                      f_equal

                        (

                          fun w : (p –≻ Sieve_PreSheaf C)%nattrans =>

                            proj1_sig (Trans w c x) c id

                        ) H

                    )

                  in _ = W return W

                with

                  eq_refl => I

                end

              )

          )

    .



    Program Definition PShCat_char_morph_forms_pullback_morph_ex :

      (p –≻ F)%nattrans

      :=

        {|

          Trans := PShCat_char_morph_forms_pullback_morph_ex_Trans

        |}.



    Next Obligation.

    Proof.

    intros c c' h.

    extensionality x.

    unfold PShCat_char_morph_forms_pullback_morph_ex_Trans.

    cbn in *.

    match goal with

      [|- proj1_sig ?A = (F _a h)%morphism (proj1_sig ?B)] =>

      destruct A as [y H2];

        destruct B as [z H3];

        cbn in *

    end.

    cbn_rewrite (F_id G) in H2 H3.

    cbn_rewrite (equal_f (Trans_com pm1 h)) in H2.

    apply (f_equal ((G _a)%morphism h)) in H3.

    cbn_rewrite <- (equal_f (Trans_com (mono_morphism N) h) z) in H3.

    rewrite <- H3 in H2.

    eapply (equal_f (PreSheaf_Monic_components_is_Monic

                       N c' (unit : Type) (fun _ => y)

                       (fun _ => (F _a h z)%morphism) _) tt).

    Unshelve.

    + auto.

    Qed.



    Next Obligation.

    Proof.

      symmetry.

      apply PShCat_char_morph_forms_pullback_morph_ex_obligation_1.

    Qed.



  End PShCat_char_morph_forms_pullback_morph_ex.



  Local Hint Extern 1 => match goal with

                          [|- context [(?F _a id)%morphism]] => rewrite (F_id F)

                        end.



  Local Hint Extern 1 => apply PropExt; intuition.



  Local Hint Extern 1 =>

  match goal with

    [ f : (?d –≻ ?c)%morphism,

          x : (?F _o)%object ?c |- ∃ _ : (?F _o)%object ?d, _] =>

    exists (F _a f x)%morphism

  end.



  Local Hint Extern 1 =>

  match goal with

    [|- context [Trans ?f _ ((?F _a)%morphism ?h _)]] =>

    cbn_rewrite (equal_f (Trans_com f h))

  end.



  Local Hint Extern 1 => apply sig_proof_irrelevance.



  Local Hint Extern 1 => progress cbn in *.



  Local Hint Extern 1 =>

  match goal with

    [|- context [proj1_sig ?A]] =>

    let x := fresh "x" in

    let H := fresh "H" in

    destruct A as [x H]; cbn;

    try rewrite H

  end

  .



  Local Hint Extern 1 => unfold PShCat_char_morph_forms_pullback_morph_ex_Trans.



  Local Hint Extern 1 => match goal with

                          [|- ?A = ?B :> unit] => try destruct A;

                            try destruct B; trivial; fail

                        end.



  Local Obligation Tactic := basic_simpl; auto 7.



  Program Definition PShCat_char_morph_forms_pullback :

    is_PullBack

      (mono_morphism N) (t_morph (PSh_Terminal C) F)

      PShCat_char_morph (True_PreSheaf_morphism C)

    :=

      {|

        is_pullback_morph_ex := PShCat_char_morph_forms_pullback_morph_ex

      |}

  .



  Local Obligation Tactic := idtac.



  Next Obligation.

  Proof.

    intros p' pm1 pm2 H1 g h H2 _ H4 _.

    rewrite <- H4 in H2; clear H4.

    apply NatTrans_eq_simplify.

    extensionality x.

    extensionality y.

    assert (H2' := f_equal (fun w : (p' –≻ G)%nattrans => Trans w x y) H2);

      clear H2.

    cbn in*.

    match goal with

      [|- ?A = ?B] =>

      eapply

        (

          equal_f

            (PreSheaf_Monic_components_is_Monic

               N

               x

               (unit : Type)

               (fun _ => A)

               (fun _ => B) _)

            tt

        )

    end.

    Unshelve.

    auto.

  Qed.



End PShCat_char_morph.



Section PShCat_char_morph_unique.

  Context

    {C : Category}

    {F G : PreSheaf C}

    (N : @Monic (PShCat C) F G)

    (M : (G –≻ (Sieve_PreSheaf C))%nattrans)

    (hpb : is_PullBack

      (mono_morphism N) (t_morph (PSh_Terminal C) F)

      M (True_PreSheaf_morphism C)

    ).



  Theorem PShCat_char_morph_unique : M = (PShCat_char_morph N).

  Proof.

    unfold PShCat_char_morph.

    apply NatTrans_eq_simplify.

    extensionality x.

    extensionality y.

    cbn in *.

    apply sig_proof_irrelevance.

    cbn.

    extensionality z.

    extensionality h.

    apply PropExt; split.

    {

      intros Hx.

      assert

        (H1 :=

           is_pullback_morph_ex_com_1

             hpb

             (PMCM_PreSheaf_representing_d z unit)

             (PMCM_PreSheaf_morph_of_function

                z unit (fun _ => (G _a)%morphism h y))

             (

               @PMCM_PreSheaf_morph_of_function

                 C

                 (PSh_Term_PreSheaf C)

                 z

                 unit

                 (fun _ => tt)

             )

        ).

      match type of H1 with

        ∀ _ : ?A, _ =>

        cut (A);

          [intros H2;

            assert (H3 :=

                      f_equal

                        (fun w : (PMCM_PreSheaf_representing_d

                                  z unit –≻ G)%nattrans =>

                           Trans w z (id, tt))

                        (H1 H2)

                   )

          |]

      end.

      {

        cbn in H3.

        match type of H3 with

          Trans (mono_morphism N) _ ?A = ?B => exists A

        end.

        rewrite H3.

        cbn_rewrite (F_id G); trivial.

      }

      {

        clear H1.

        apply NatTrans_eq_simplify.

        extensionality w.

        extensionality v.

        cbn in *.

        cbn_rewrite (equal_f (Trans_com M (fst v)) ((G _a)%morphism h y)).

        apply sig_proof_irrelevance.

        cbn.

        extensionality d.

        extensionality u.

        cbn_rewrite (equal_f (Trans_com M h) y).

        cbn.

        apply PropExt; split; intros _; trivial.

        apply (proj2_sig (Trans M x y) z h Hx d ((fst v) ∘ u)%morphism).

      }

    }

    {

      intros [v Hv].

      assert (proj1_sig (Trans M z (Trans (mono_morphism N) z v)) z id).

      {

        exact

          (

            match

              eq_sym

                (

                  f_equal

                    (fun w : (F –≻ Sieve_PreSheaf C)%nattrans =>

                       proj1_sig (Trans w z v) z id)

                    (is_pullback_morph_com hpb)

                )

              in _ = u return u

            with

              eq_refl => I

            end

          ).

      }

      {

        rewrite Hv in H.

        cbn_rewrite (equal_f (Trans_com M h) y) in H.

        cbn in H.

        auto.

      }

    }

  Qed.



End PShCat_char_morph_unique.



Program Definition PSh_SubObject_Classifier (C : Category) :

  SubObject_Classifier (PShCat C) :=

  {|

    SOC := (Sieve_PreSheaf C);

    SOC_morph := (True_PreSheaf_morphism C :

                    ((terminal (PSh_Terminal C)) –≻ _)%nattrans);

    SOC_char := @PShCat_char_morph C;

    SO_pulback := @PShCat_char_morph_forms_pullback C

  |}.



Local Obligation Tactic := idtac.



Next Obligation.

Proof.

  intros C a b m h h' pb1 pb2.

  transitivity (PShCat_char_morph m).

  + apply PShCat_char_morph_unique; trivial.

  + symmetry.

    apply PShCat_char_morph_unique; trivial.

Qed.

