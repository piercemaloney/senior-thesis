From Categories Require Import Category.Main.
(* Categories.Category.Main:
From Categories Require Export Category.Category.
From Categories Require Export Category.Morph.
From Categories Require Export Category.Opposite.
From Categories Require Export Category.SubCategory.
From Categories Require Export Category.Composable_Chain. *)

From Categories Require Import Coq_Cats.Type_Cat.Type_Cat.
(* Categories.Coq_Cats.Type_Cat.Type_Cat:
From Categories Require Import Category.Main.
From Categories Require Import Coq_Cats.Coq_Cat.

Program Definition Type_Cat : Category := Coq_Cat Type. *)

From Categories Require Import Type_Cat.GenProd Type_Cat.GenSum Type_Cat.Equalizer.

From Categories Require Import Limits.Limit Limits.GenProd_Eq_Limits.
(* Categories.Limits.Limit:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Main.
From Categories Require Import Basic_Cons.Terminal.
From Categories Require Import Ext_Cons.Arrow.
From Categories Require Import Coq_Cats.Type_Cat.Card_Restriction.
From Categories Require Export NatTrans.NatTrans NatTrans.Operations.
From Categories Require Export KanExt.Local KanExt.Global KanExt.GlobalDuality
        KanExt.GlobaltoLocal KanExt.LocaltoGlobal KanExt.LocalFacts.Main.
From Categories Require Export Cat.Terminal.

Local Open Scope functor_scope.

Section Limit.
  Context {J C : Category} (D : J –≻ C).

  Definition Cone := LoKan_Cone (Functor_To_1_Cat J) D.

  Definition Cone_Morph Cn Cn' :=
    @LoKan_Cone_Morph _ _ (Functor_To_1_Cat J) _ D Cn Cn'.
  
  Definition Limit : Type := Local_Right_KanExt (Functor_To_1_Cat J) D.

  Definition limit_to_cone (l : Limit) : Cone := (LRKE l).

  Coercion limit_to_cone : Limit >-> Cone.
  
  Definition cone_to_obj (cn : Cone) : C := (cone_apex cn) _o tt.

  Coercion cone_to_obj : Cone >-> Obj.

  Definition is_Limit (Cn : Cone) :=
    is_Cone_Local_Right_KanExt (Functor_To_1_Cat J) D Cn.

  Definition is_Limit_Limit {Cn : Cone} (il : is_Limit Cn) : Limit :=
    is_Cone_Local_Right_KanExt_Local_Right_KanExt (Functor_To_1_Cat J) D il.

  Definition Limit_is_Limit {L : Limit} : is_Limit L :=
    Local_Right_KanExt_is_Cone_Local_Right_KanExt (Functor_To_1_Cat J) D L.
  
End Limit.

Program Definition Limit_Iso {J C : Category} {D : J –≻ C} (l l' : Limit D) :
  (l ≃≃ l' ::> C)%isomorphism :=
  {|
    iso_morphism :=
      Trans
        (cone_morph (iso_morphism (Local_Right_KanExt_unique _ _ l l')))
        tt;
    inverse_morphism :=
      Trans
        (cone_morph (inverse_morphism (Local_Right_KanExt_unique _ _ l l')))
        tt
  |}.

Next Obligation.
Proof (
    f_equal
      (fun x : LoKan_Cone_Morph l l => Trans (cone_morph x) tt)
      (left_inverse (Local_Right_KanExt_unique _ _ l l'))
  ).

Next Obligation.
Proof (
    f_equal
      (fun x : LoKan_Cone_Morph l' l' => Trans (cone_morph x) tt)
      (right_inverse (Local_Right_KanExt_unique _ _ l l'))
  ).

Definition Has_Restr_Limits (C : Category) (P : Card_Restriction) :=
  ∀ {J : Category} (D : J –≻ C), P J → P (Arrow J) → Limit D.

Definition Complete (C : Category) :=
  ∀ J : Category, Right_KanExt (Functor_To_1_Cat J) C.

Existing Class Complete.

Definition LimitOf {C D : Category} {H : Complete D} (F : C –≻ D) : Limit F :=
  Global_to_Local_Right _ _ (H _) F.

Section Restricted_Limits_to_Complete.
  Context {C : Category} {P : Card_Restriction} (HRL : Has_Restr_Limits C P).

  Definition No_Restriction_Complete : (∀ t, P t) → Complete C :=
    fun All_Ps J => Local_to_Global_Right
                   _ _ (fun D => HRL _ D (All_Ps J) (All_Ps (Arrow J))).

End Restricted_Limits_to_Complete.

Section Complete_to_Restricted_Limits.
  Context (C : Category) {CC : Complete C} (P : Card_Restriction).
  
  Definition Complete_Has_Restricted_Limits : Has_Restr_Limits C P :=
    fun J D _ _ => Global_to_Local_Right _ _ (CC _) D.

End Complete_to_Restricted_Limits.

Section Continuous.
  Context
    {C D : Category}
    (CC : Complete C)
    (G : (C –≻ D)%functor)
  .

  Section Cone_Conv.
    Context
      {J : Category}
      {F : (J –≻ C)%functor}
      (Cn : Cone F)
    .
    
    Program Definition Cone_Conv : Cone (G ∘ F)%functor
      :=
        {|
          cone_apex :=
            (G ∘ (cone_apex Cn))%functor;
          cone_edge :=
            (((NatTrans_id G)
                ∘_h (cone_edge Cn)) ∘ (NatTrans_Functor_assoc _ _ _))%nattrans
        |}
    .

  End Cone_Conv.

  Definition Continuous :=
    ∀ (J : Category) (F : (J –≻ C)%functor),
      is_Cone_Local_Right_KanExt _ _ (Cone_Conv (LRKE (LimitOf F)))
  .

End Continuous.

Section CoLimit.
  Context {J C : Category} (D : J –≻ C).

  Definition CoCone :=
    LoKan_Cone (Functor_To_1_Cat J^op) (D^op).

  Definition CoCone_Morph Cn Cn' :=
    @LoKan_Cone_Morph _ _ (Functor_To_1_Cat J^op) _ (D^op) Cn Cn'.

  Definition CoLimit := Local_Left_KanExt (Functor_To_1_Cat J) D.

  Definition is_CoLimit (Cn : CoCone) :=
    is_Cone_Local_Right_KanExt (Functor_To_1_Cat (J^op)) (D^op) Cn.

  Definition is_CoLimit_CoLimit {Cn : CoCone} (il : is_CoLimit Cn) : CoLimit :=
    is_Cone_Local_Right_KanExt_Local_Right_KanExt
      (Functor_To_1_Cat (J^op)) (D^op) il.

  Definition CoLimit_is_CoLimit {L : CoLimit} : is_CoLimit L :=
    Local_Right_KanExt_is_Cone_Local_Right_KanExt
      (Functor_To_1_Cat (J^op)) (D^op) L.

End CoLimit.

Definition Has_Restr_CoLimits (C : Category) (P : Card_Restriction) :=
  ∀ {J : Category} (D : J –≻ C), P J → P (Arrow J) → CoLimit D.

Definition CoComplete (C : Category) :=
  ∀ J : Category, Left_KanExt (Functor_To_1_Cat J) C.

Existing Class CoComplete.

Definition CoLimitOf {C D : Category} {H : CoComplete D} (F : C –≻ D) :
  CoLimit F := Global_to_Local_Left _ _ (H _) F.

Definition Complete_to_CoComplete_Op {C : Category} {CC : Complete C}
  : CoComplete (C ^op) :=
fun D => KanExt_Right_to_Left (Functor_To_1_Cat D ^op) C (CC (D ^op)%category).

Definition CoComplete_to_Complete_Op {C : Category} {CC : CoComplete C}
  : Complete (C ^op) :=
    fun D => KanExt_Left_to_Right (Functor_To_1_Cat D ^op) C (CC (D ^op)%category).

Section Restricted_CoLimits_to_CoComplete.
  Context {C : Category} {P : Card_Restriction} (HRL : Has_Restr_CoLimits C P).

  Definition No_Restriction_CoComplete : (∀ t, P t) → CoComplete C :=
    fun All_Ps J =>
      Local_to_Global_Left _ _ (fun D => HRL _ D (All_Ps J) (All_Ps (Arrow J))).

End Restricted_CoLimits_to_CoComplete.

Section CoComplete_to_Restricted_CoLimits.
  Context (C : Category) {CC : CoComplete C} (P : Card_Restriction).
  
  Definition CoComplete_Has_Restricted_CoLimits : Has_Restr_CoLimits C P :=
    fun J D _ _ => Global_to_Local_Left _ _ (CC _) D.

End CoComplete_to_Restricted_CoLimits.

Definition Has_Restr_Limits_to_Has_Restr_CoLimits_Op
        {C : Category} {P : Card_Restriction}
        (HRL : Has_Restr_Limits C P) :
  Has_Restr_CoLimits (C ^op) P :=
  (fun (D : Category)
       (F : D –≻ C ^op)
       (H1 : P D)
       (H2 : P (Arrow D)) =>
     HRL
       (D ^op)%category
       (F ^op)%functor H1
       (Card_Rest_Respect P (Arrow D) (Arrow (D^op)) (Arrow_OP_Iso D) H2)
  ).

Definition Has_Restr_CoLimits_to_Has_Restr_Limits_Op
        {C : Category}
        {P : Card_Restriction}
        (HRL : Has_Restr_CoLimits C P) :
  Has_Restr_Limits (C ^op) P :=
  (fun (D : Category)
       (F : D –≻ C ^op)
       (H1 : P D)
       (H2 : P (Arrow D)) =>
     HRL
       (D ^op)%category
       (F ^op)%functor
       H1
       (Card_Rest_Respect P (Arrow D) (Arrow (D^op)) (Arrow_OP_Iso D) H2)
  ).

Section CoContinuous.
  Context
    {C D : Category}
    (CC : CoComplete C)
    (G : (C –≻ D)%functor)
  .

  Section CoCone_Conv.
    Context
      {J : Category}
      {F : (J –≻ C)%functor}
      (Cn : CoCone F)
    .
    
    Program Definition CoCone_Conv : CoCone (G ∘ F)%functor
      :=
        {|
          cone_apex :=
            ((G ^op) ∘ (cone_apex Cn))%functor;
          cone_edge := _
                         (((NatTrans_id (G ^op)) ∘_h (cone_edge Cn))
                            ∘ (NatTrans_Functor_assoc _ _ _))%nattrans
        |}
    .

  End CoCone_Conv.

  Definition CoContinuous :=
    ∀ (J : Category) (F : (J –≻ C)%functor),
      is_Cone_Local_Right_KanExt _ _ (CoCone_Conv (LRKE (CoLimitOf F)))
  .

End CoContinuous. *)
(* Categories.Limits.GenProd_Eq_Limits:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Main.
From Categories Require Import Ext_Cons.Arrow.
From Categories Require Import Basic_Cons.Terminal.
From Categories Require Import Basic_Cons.Equalizer.
From Categories Require Import Basic_Cons.Facts.Equalizer_Monic.
From Categories Require Import Coq_Cats.Type_Cat.Card_Restriction.
From Categories Require Import Archetypal.Discr.Discr Archetypal.Discr.NatFacts.

From Categories Require Import Limits.GenProd_GenSum.
From Categories Require Import Limits.Limit.

Local Open Scope functor_scope.

Section GenProd_Eq_Complete.
  Context {C : Category}.

  Local Ltac ElimUnit := repeat match goal with [H : unit |- _] => destruct H end.

  Section GenProd_Eq_Limits.
    Context {J : Category}.

    Context {OProd : ∀ (map : J → C), (Π map)%object}
            {HProd : ∀ (map : (Arrow J) → C), (Π map)%object}
            {Eqs : Has_Equalizers C}
    .

    Section Limits_Exist.
      Context (D : J –≻ C).

      Local Notation DTarg := (fun f => (D _o (Targ f))%object) (only parsing).
      Local Notation DF := Discr_Func (only parsing).
      Local Notation OPR := (OProd (D _o)%object) (only parsing).
      Local Notation HPR := (HProd DTarg) (only parsing).

      Program Definition Projs_Cone : Cone (DF DTarg) :=
        {|
          cone_apex := Const_Func 1 (OPR _o tt);
          cone_edge := {|Trans := fun f => Trans (cone_edge OPR) (Targ f)|}
        |}.

      Definition Projs : (OPR –≻ HPR)%morphism :=
        Trans (LRKE_morph_ex HPR Projs_Cone) tt.

      Program Definition D_imgs_Cone : Cone (DF DTarg) :=
        {|
          cone_apex := Const_Func 1 (OPR _o tt);
          cone_edge :=
            {|
              Trans :=
                fun f =>
                  (D _a (Arr f) ∘ (Trans (cone_edge OPR) (Orig f)))%morphism
            |}
        |}.

      Definition D_imgs : (OPR –≻ HPR)%morphism :=
        Trans (LRKE_morph_ex HPR D_imgs_Cone) tt.

      Program Definition Lim_Cone : Cone D :=
        {|
          cone_apex := Const_Func 1 (Eqs _ _ Projs D_imgs);
          cone_edge :=
            {|Trans :=
                fun d => ((Trans (cone_edge OPR) d)
                         ∘ (equalizer_morph (Eqs _ _ Projs D_imgs)))%morphism
            |}
        |}.

      Section Every_Cone_Equalizes.
        Context (Cn : Cone D).

        Local Hint Extern 1 => progress cbn.

        Program Definition Cone_to_DF_DCone : Cone (DF (D _o)%object) :=
          {|
            cone_apex := Cn;
            cone_edge :=
              @NatTrans_compose
                _ _
                (Cn ∘ (Functor_To_1_Cat (Discr_Cat J)))
                (Discr_Func ((Cn ∘ (Functor_To_1_Cat J))%functor _o)%object) _
                {|Trans := fun _ => id |} (Discretize (cone_edge Cn))
          |}.

        Definition From_Cone_to_OPR : (Cn –≻ OPR)%morphism :=
          Trans (LRKE_morph_ex OPR Cone_to_DF_DCone) tt.

        Program Definition Cone_to_DF_DTrag_Cone : Cone (DF DTarg) :=
          {|
            cone_apex := Cn;
            cone_edge := {|Trans :=
                             fun c => Trans (Discretize (cone_edge Cn)) (Targ c)|}
          |}.

        Program Definition Cone_Morph_From_Cone_to_DF_DTrag_Cone_to_HPR_1 :
          Cone_Morph _ Cone_to_DF_DTrag_Cone HPR :=
          {|
            cone_morph :=
              {|Trans :=
                  fun f =>
                    match f as u return (((Cn _o) u)%object –≻ (_ u))%morphism
                    with
                    | tt => (Projs ∘ From_Cone_to_OPR)%morphism
                    end
              |}
          |}.

        Program Definition Cone_Morph_From_Cone_to_DF_DTrag_Cone_to_HPR_2 :
          Cone_Morph _ Cone_to_DF_DTrag_Cone HPR :=
          {|
            cone_morph :=
              {|Trans :=
                  fun f =>
                    match f as u return (((Cn _o)%object u) –≻ (_ u))%morphism
                    with
                    | tt => (D_imgs ∘ From_Cone_to_OPR)%morphism
                    end
              |}
          |}.

        Lemma From_Cone_to_Obj_Prod_Equalizes :
          (Projs ∘ From_Cone_to_OPR = D_imgs ∘ From_Cone_to_OPR)%morphism.

        Definition From_Cone_to_Lim_Cone : (Cn –≻ Lim_Cone)%morphism :=
          equalizer_morph_ex _  From_Cone_to_Obj_Prod_Equalizes.

        Program Definition Cone_Morph_to_Lim_Cone : Cone_Morph D Cn Lim_Cone :=
          {|
            cone_morph :=
              {|
                Trans :=
                  fun c =>
                    match c as u return ((Cn _o u)%object –≻ _)%morphism with
                      tt => From_Cone_to_Lim_Cone
                    end
              |}
          |}.

      End Every_Cone_Equalizes.

      Section Cone_Morph_to_Lim_Cone_Cone_Morph_to_OPR.
        Context {Cn : Cone D} (h : Cone_Morph _ Cn Lim_Cone).

        Program Definition Cone_Morph_to_Lim_Cone_Cone_Morph_to_OPR :
          Cone_Morph _ (Cone_to_DF_DCone Cn) OPR :=
          {|
            cone_morph :=
              {|
                Trans :=
                  fun c =>
                    match c as u return
                          (((Cn _o) u)
                             –≻ (((OProd (D _o)) _o) u))%object%morphism
                    with
                    | tt => (equalizer_morph (Eqs _ _ Projs D_imgs)
                                            ∘ Trans h tt)%morphism
                    end
              |}
          |}.

      End Cone_Morph_to_Lim_Cone_Cone_Morph_to_OPR.

      Local Notation CMCOPR :=
        Cone_Morph_to_Lim_Cone_Cone_Morph_to_OPR (only parsing).

      Program Definition Lim_Cone_is_Limit : Limit D :=
        {|
          LRKE := Lim_Cone;
          LRKE_morph_ex := Cone_Morph_to_Lim_Cone
        |}.

    End Limits_Exist.
  End GenProd_Eq_Limits.

  Section Restricted_Limits.
    Context (P : Card_Restriction)
            {CHRP : ∀ (A : Type) (map : A → C), (P A) → (Π map)%object}
            {HE : Has_Equalizers C}
    .

    Definition Restr_GenProd_Eq_Restr_Limits : Has_Restr_Limits C P :=
      fun J D PJ PA =>
        @Lim_Cone_is_Limit
          J
          (fun map => CHRP J map PJ)
          (fun map => CHRP (Arrow J) map PA)
          HE
          D
    .

  End Restricted_Limits.

  Section Complete.
    Context {CHAP : ∀ (A : Type) (map : A → C), (Π map)%object}
            {HE : Has_Equalizers C}.

    Definition GenProd_Eq_Complete : Complete C :=
      fun J =>
        Local_to_Global_Right
          _
          _
          (fun D => @Lim_Cone_is_Limit J (CHAP J) (CHAP (Arrow J)) HE D)
    .

  End Complete.

End GenProd_Eq_Complete.

Section GenSum_CoEq_Complete.
  Context {C : Category}.

  Section GenSum_CoEq_CoLimits.
    Context {J : Category}
            {OSum : ∀ (map : J → C), (Σ map)%object}
            {HSum : ∀ (map : (Arrow J) → C), (Σ map)%object}
            {Eqs : Has_CoEqualizers C}
    .

    Section Limits_Exist.
      Context (D : J –≻ C).

      Program Definition CoLim_CoCone_is_CoLimit : CoLimit D :=
        @Lim_Cone_is_Limit
          (C^op)
          (J^op)
          (fun map => GenSum_to_GenProd (OSum map))
          (fun map => GenSum_to_GenProd (GenSum_IsoType (Arrow_OP_Iso J) HSum map))
          Eqs
          (Opposite_Functor D)
      .

    End Limits_Exist.
  End GenSum_CoEq_CoLimits.

  Section Restricted_CoLimits.
    Context (P : Card_Restriction)
            {CHRP : ∀ (A : Type) (map : A → C), (P A) → (Σ map)%object}
            {HE : Has_CoEqualizers C}
    .

    Definition Restr_GenSum_CoEq_Restr_CoLimits : Has_Restr_CoLimits C P :=
      fun J D PJ PA =>
        @CoLim_CoCone_is_CoLimit
          J
          (fun map => CHRP J map PJ)
          (fun map => CHRP (Arrow J) map PA)
          HE
          D
    .

  End Restricted_CoLimits.

  Section CoComplete.
    Context {CHAP : ∀ (A : Type) (map : A → C), (Σ map)%object}
            {HE : Has_CoEqualizers C}
    .

    Definition GenSum_CoEq_CoComplete : CoComplete C :=
      fun J =>
        Local_to_Global_Left
          _
          _
          (fun D => @CoLim_CoCone_is_CoLimit J (CHAP J) (CHAP (Arrow J)) HE D)
    .

  End CoComplete.

End GenSum_CoEq_Complete. *)

From Categories Require Import PreSheaf.PreSheaf.
(* Categories.PreSheaf.PreSheaf:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Main.
From Categories Require Import Coq_Cats.Type_Cat.Type_Cat.
From Categories Require Import NatTrans.NatTrans NatTrans.Func_Cat.

Definition PreSheaf (C : Category) := Functor (C^op) Type_Cat.

Definition PShCat (C : Category) := Func_Cat (C^op) Type_Cat. *)

From Categories Require Import

        PreSheaf.Equalizer

        PreSheaf.GenProd

        PreSheaf.GenSum

.



Instance PShCat_Complete (C: Category) : Complete (PShCat C) :=

  @GenProd_Eq_Complete (PShCat C) (PSh_GenProd C) (@PSh_Has_Equalizers C).



Instance PShCat_CoComplete (C: Category) : CoComplete (PShCat C) :=

  @GenSum_CoEq_CoComplete (PShCat C) (PSh_GenSum C) (@PSh_Has_CoEqualizers C).

