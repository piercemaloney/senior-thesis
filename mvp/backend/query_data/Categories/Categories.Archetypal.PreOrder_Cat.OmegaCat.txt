From Categories Require Import Essentials.Notations.
(* Categories.Essentials.Notations:
Notation "∀ x .. y , P" := (forall x, .. (forall y, P) ..)
                             (at level 200, x binder, y binder, right associativity) : type_scope.

Notation "∃ x .. y , P" := (exists x, .. (exists y, P) ..)
  (at level 200, x binder, y binder, right associativity) : type_scope.

Notation "x ∨ y" := (x \/ y) (at level 85, right associativity) : type_scope.

Notation "x ∧ y" := (x /\ y) (at level 80, right associativity) : type_scope.

Notation "x → y" := (x -> y)
  (at level 90, y at level 200, right associativity): type_scope.

Notation "x ↔ y" := (x <-> y) (at level 95, no associativity): type_scope.

Notation "¬ x" := (~x) (at level 75, right associativity) : type_scope.

Notation "x ≠ y" := (x <> y) (at level 70) : type_scope.

Notation "x ≤ y" := (le x y) (at level 70, no associativity).

Notation "x ≥ y" := (ge x y) (at level 70, no associativity).

Reserved Notation "C '^op'" (at level 50, no associativity).

Reserved Notation "a –≻ b" (at level 90, b at level 200, right associativity).

Reserved Notation "f '⁻¹'" (at level 50, no associativity).

Reserved Notation "a ≃ b" (at level 70, no associativity).

Reserved Notation "a ≃≃ b ::> C" (at level 70, no associativity).

Reserved Notation "f ∘ g" (at level 51, right associativity).

Reserved Notation "f '∘_h' g" (at level 51, right associativity).

Reserved Notation "a ≫–> b" (at level 100, no associativity).

Reserved Notation "a –≫ b" (at level 100, no associativity).

Reserved Notation "F '_o'" (at level 50, no associativity).

Reserved Notation "F '_a'" (at level 50, no associativity).

Reserved Notation "F '@_a'" (at level 50, no associativity).

Reserved Notation "F ⊣ G" (at level 100, no associativity).

Reserved Notation "F ⊣_hom G" (at level 100, no associativity).

Reserved Notation "F ⊣_ucu G" (at level 100, no associativity).

Reserved Notation "a × b" (at level 80, no associativity).

Reserved Notation "a ⇑ b" (at level 79, no associativity).

Reserved Notation "'Π' m" (at level 50, no associativity).

Reserved Notation "'Σ' m" (at level 50, no associativity).

Reserved Notation "'Π_' C ↓ m" (at level 50, no associativity).

Reserved Notation "'Σ_' C ↓ m" (at level 50, no associativity).

Delimit Scope category_scope with category.

Delimit Scope morphism_scope with morphism.

Delimit Scope object_scope with object.

Delimit Scope functor_scope with functor.

Delimit Scope nattrans_scope with nattrans.

Delimit Scope nattrans_scope with nattrans.

Delimit Scope natiso_scope with natiso.

Delimit Scope isomorphism_scope with isomorphism.

Delimit Scope preorder_scope with preorder. *)

From Categories Require Import Essentials.Types.
(* Categories.Essentials.Types:
Global Set Primitive Projections.

Global Set Universe Polymorphism.

Global Unset Universe Minimization ToSet.

Inductive Empty : Type :=.

Hint Extern 1 =>
let tac := (repeat intros ?); match goal with [H : Empty |- _] => contradict H end in
match goal with
  | [|- context[Empty]] => tac
  | [H : context[Empty] |- _] => tac
end
.

Record prod (A B : Type) := {fst : A; snd : B}.

Arguments fst {_ _ } _.
Arguments snd {_ _ } _.
Arguments Build_prod {_ _ } _ _.

Notation "( X , Y )" := (Build_prod X Y).
Notation "X * Y" := (prod X Y) : type_scope. *)

From Categories Require Import Essentials.Facts_Tactics.
(* Categories.Essentials.Facts_Tactics:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.

Require Export Coq.Program.Tactics.
Require Export Coq.Program.Equality.
Require Export Coq.Logic.FunctionalExtensionality.
Require Export Coq.Logic.ProofIrrelevance.

Definition equal_f : ∀ {A B : Type} {f g : A → B}, f = g → ∀ x : A, f x = g x.

Definition f_equal : ∀ (A B : Type) (f : A → B) (x y : A), x = y → f x = f y.

Arguments f_equal [_ _] _ [_ _] _.

Ltac basic_simpl :=
  let simpl_prod _ :=
      match goal with
        [H : prod _ _ |- _] =>
        let H1 := fresh H "1" in
        let H2 := fresh H "2" in
        destruct H as [H1 H2]
      end
  in
  let simpl_sig _ :=
      match goal with
        [H : @sig _ _ |- _] =>
        let H1 := fresh H "1" in
        let H2 := fresh H "2" in
        destruct H as [H1 H2]
      end
  in
  let basic_simpl_helper _ :=
      cbn in *; intros;
        repeat simpl_prod tt;
        repeat simpl_sig tt
  in
  repeat basic_simpl_helper tt
.

Global Obligation Tactic := basic_simpl; auto.

Ltac PIR :=
  let pir_helper _ :=
      match goal with
      |[H : ?A, H' : ?A|- _] =>
       match type of A with
       | Prop =>
         destruct (proof_irrelevance _ H H')
       end
      end
  in
  repeat pir_helper tt
.

Ltac ElimEq := repeat match goal with [H : _ = _|- _] => destruct H end.

Hint Extern 1 => progress ElimEq.

Ltac cbn_rewrite W :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite H; clear H
.

Ltac cbn_rewrite_in W V :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite H in V; clear H
.

Ltac cbn_rewrite_back W :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite <- H; clear H
.

Ltac cbn_rewrite_back_in W V :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite <- H in V; clear H
.

Tactic Notation "cbn_rewrite" constr(W) := cbn_rewrite W.
Tactic Notation "cbn_rewrite" constr(W) "in" hyp_list(V) := cbn_rewrite_in W V.
Tactic Notation "cbn_rewrite" "<-" constr(W) := cbn_rewrite_back W.
Tactic Notation "cbn_rewrite" "<-" constr(W) "in" hyp_list(V) := cbn_rewrite_back_in W V.

Lemma sig_proof_irrelevance {A : Type} (P : A → Prop) (X Y : sig P) : proj1_sig X = proj1_sig Y → X = Y.

Hint Extern 2 (exist ?A _ _ = exist ?A _ _) => apply sig_proof_irrelevance.

Ltac FunExt :=
progress (
    repeat (
        match goal with
          [|- _ = _] =>
          let x := fresh "x" in
          extensionality x
        end
      )
  )
.

Hint Extern 1 => FunExt.

Lemma pair_eq (A B : Type) (a b : A * B) : fst a = fst b → snd a = snd b → a = b.

Hint Resolve pair_eq.

Ltac revert_clearbody_all :=
 repeat lazymatch goal with H:_ |- _ => try clearbody H; revert H end.

Ltac hyp_stack :=
 constr:(ltac:(revert_clearbody_all;constructor) : True).

Ltac next_hyp hs step last :=
 lazymatch hs with (?hs' ?H) => step H hs' | _ => last end.

Tactic Notation "dohyps" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := tac H; next_hyp hs step idtac in
 next_hyp hs step idtac.

Tactic Notation "dohyps" "reverse" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := next_hyp hs step idtac; tac H in
 next_hyp hs step idtac.

Tactic Notation "do1hyp" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := tac H + next_hyp hs step fail in
 next_hyp hs step fail.

Tactic Notation "do1hyp" "reverse" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := next_hyp hs step fail + tac H in
 next_hyp hs step fail. *)

From Categories Require Import Category.Main.
(* Categories.Category.Main:
From Categories Require Export Category.Category.
From Categories Require Export Category.Morph.
From Categories Require Export Category.Opposite.
From Categories Require Export Category.SubCategory.
From Categories Require Export Category.Composable_Chain. *)

From Categories Require Import Functor.Main.
(* Categories.Functor.Main:
From Categories Require Export Functor.Functor.
From Categories Require Export Functor.Functor_Extender.
From Categories Require Export Functor.Functor_Image.
From Categories Require Export Functor.Functor_Ops.
From Categories Require Export Functor.Functor_Properties.
From Categories Require Export Functor.Const_Func.
From Categories Require Export Functor.Const_Func_Functor. *)

From Categories Require Import Archetypal.PreOrder_Cat.PreOrder_Cat.
(* Categories.Archetypal.PreOrder_Cat.PreOrder_Cat:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.

Record PreOrder : Type :=
{
  PreOrder_car :> Type;
  
  PreOrder_rel :> PreOrder_car → PreOrder_car → Type
  where "a ≤ b" := (PreOrder_rel a b);

  PreOrder_rel_isProp : ∀ x y (h h' : PreOrder_rel x y), h = h'; 

  PreOrder_refl : ∀ a, a ≤ a;

  PreOrder_trans : ∀ a b c, a ≤ b → b ≤ c → a ≤ c
}.

Arguments PreOrder_rel {_} _ _.
Arguments PreOrder_refl {_} _.
Arguments PreOrder_trans {_ _ _ _} _ _.

Notation "a ≤ b" := (PreOrder_rel a b) : preorder_scope.

Section PreOrder_Cat.
  Context (P : PreOrder).

  Local Hint Resolve PreOrder_rel_isProp.

  Program Definition PreOrder_Cat : Category :=
    {|
      Obj := P;
      Hom := fun a b => (a ≤ b)%preorder;
      compose := @PreOrder_trans P;
      id := @PreOrder_refl P
    |}
  .
  
End PreOrder_Cat. *)



Require Import Coq.Arith.Arith.



Delimit Scope omegacat_scope with omegacat.



Local Open Scope omegacat_scope.



Inductive Tle (n : nat) : nat → Type :=

| Tle_n : Tle n n

| Tle_S : ∀ m, Tle n m → Tle n (S m)

.



Hint Constructors Tle.



Notation "n ≤ m" := (Tle n m) : omegacat_scope.



Definition Tle_addS (n m : nat) : n ≤ m → S n ≤ S m.

Proof.

  intros H.

  induction H; auto.

Qed.



Definition Tle_trans (n m t : nat) : n ≤ m → m ≤ t → n ≤ t.

Proof.

  intros H1 H2.

  induction H2; auto.

Defined.



Definition Tle_remS (n m : nat) : S n ≤ S m → n ≤ m.

Proof.

  revert n.

  induction m.

  intros n H.

  induction n; auto.

  inversion H as [Hx | m H1 H2]; inversion H1.

  intros n H.

  inversion H; auto.

Qed.



Theorem Not_S_Tle (n : nat) : Tle (S n) n → False.

Proof.

  intros H.

  induction n; inversion H; auto.

  apply IHn.

  apply Tle_remS; trivial.

Qed.



Definition Tle_dec (n m : nat) : (n ≤ m) + ((n ≤ m) → False).

Proof.

  revert m.

  induction n.

  - left; induction m; auto.

  - induction m.

    + right; intros H; inversion H.

    + destruct IHm as [H1|H1].

      left; auto.

      destruct (IHn m) as [H2|H2].

      * left; apply Tle_addS; trivial.

      * right.

        intros H3.

        contradict H2.

        apply Tle_remS; trivial.

Qed.



Definition Tle_le {n m : nat} : n ≤ m → le n m.

Proof.

  intros H.

  induction H; auto.

Qed.



Definition NTle_Nle {n m : nat} : (n ≤ m → False) → (le n m → False).

Proof.

  intros H1 H2.

  induction H2.

  + apply H1; trivial.

  + apply IHle.

    intros H3.

    apply H1; auto.

Qed.



Definition le_Tle {n m : nat} : le n m → n ≤ m.

Proof.

  intros H.

  destruct (Tle_dec n m) as [H1|H1]; auto.

  contradict H.

  unfold not; apply NTle_Nle; trivial.

Qed.



Theorem Tle_is_HProp {n m : nat} (H H' : Tle n m) : H = H'.

Proof.

  dependent induction H.

  dependent induction H'; trivial.

  {

    inversion H' as [H1| m' H1 H2].

    {

      contradict H1; clear.

      induction m; auto.

    }

    {

      subst.

      contradict H1; clear.

      induction m'.

      + intros H; inversion H.

      + intros H.

        apply IHm'.

        apply Tle_remS; trivial.

    }

  }

  {

    inversion H'.

    + subst.

      clear IHTle.

      contradict H; clear.

      intros H.

      induction m.

      * inversion H.

      * apply IHm.

        apply Tle_remS; trivial.

    + subst.

      dependent destruction H'.

      {

        clear IHTle.

        contradict H; clear.

        intros H.

        induction m.

        * inversion H.

        * apply IHm.

          apply Tle_remS; trivial.

      }

      {

        apply f_equal.

        apply IHTle.

      }

  }

Qed.



Definition OmegaPreOrder :=

  {|

    PreOrder_car := nat : Type;

    PreOrder_rel := Tle : _ → _ → Type;

    PreOrder_rel_isProp :=

      fun _ _ h h' => Tle_is_HProp h h';

    PreOrder_refl := Tle_n;

    PreOrder_trans := Tle_trans

  |}.



Definition OmegaCat : Category := PreOrder_Cat OmegaPreOrder.



Notation "'ω'" := (OmegaCat) : omegacat_scope.



Lemma le_Tle_n (n : nat) : le_Tle (le_n n) = Tle_n n.

Proof.

  apply Tle_is_HProp.

Qed.



Lemma le_Tle_S (n m : nat) (H : le n m) :

  le_Tle (le_S _ _ H) = Tle_S _ _ (le_Tle H).

Proof.

  apply Tle_is_HProp.

Qed.



Lemma le_Tle_trans (n m k : nat) (H : le n m) (H' : le m k) :

  le_Tle (le_trans _ _ _ H H') = Tle_trans _ _ _ (le_Tle H) (le_Tle H').

Proof.

  apply Tle_is_HProp.

Qed.



Local Fixpoint FA_fx {C : Category}

      (OOF_O : nat → C)

      (OOF_A : ∀ n, ((OOF_O (S n)) –≻ (OOF_O n))%morphism)

      (n m : nat) (h : Tle n m)

      {struct h} : (OOF_O m –≻ OOF_O n)%morphism

  :=

    match h in _ ≤ w return

          (OOF_O w –≻ OOF_O n)%morphism

    with

    | Tle_n _ =>

      id (OOF_O n)

    | Tle_S _ m' H' =>

      ((FA_fx OOF_O OOF_A _ _ H') ∘ (OOF_A m'))%morphism

    end

.



Program Definition OmegaCat_Op_Func {C : Category}

      (OOF_O : nat → C)

      (OOF_A : ∀ n, ((OOF_O (S n)) –≻ (OOF_O n))%morphism)

  : ((ω^op) –≻ C)%functor :=

  {|

    FO := OOF_O;

    FA := fun m n h => FA_fx OOF_O OOF_A _ _ h

  |}

.



Next Obligation.

Proof.

  induction f as [|m t IHt].

  + cbn; auto.

  + replace (Tle_trans _ _ _ g (Tle_S _ _ t))

    with (Tle_S _ _ (Tle_trans _ _ _ g t)).

    cbn.

    rewrite IHt.

    auto.

    apply Tle_is_HProp.

Qed.



Definition OmegaCat_Func {C : Category}

           (OMF_O : nat → C)

           (OMF_A : ∀ n, ((OMF_O n) –≻ (OMF_O (S n)))%morphism)

  : (OmegaCat –≻ C)%functor

  := (@OmegaCat_Op_Func (C^op) OMF_O OMF_A)^op.



Lemma OmegaCat_Op_Func_unique {C : Category} (F : ((ω^op) –≻ C)%functor) :

  F = OmegaCat_Op_Func (FO F) (fun n => FA F (Tle_S _ _ (Tle_n n))).

Proof.

  Func_eq_simpl.

  extensionality y.

  extensionality x.

  extensionality h.

  cbn in *.

  revert x y h.

  induction x.

  {

    intros y h.

    induction y.

    + dependent destruction h.

      rewrite (F_id F).

      trivial.

    + dependent destruction h.

      cbn in *.

      rewrite <- (IHy h).

      rewrite <- F_compose.

      match goal with

        [|- (F _a)%morphism ?A = (F _a)%morphism ?B] =>

        set (l := A); set (l' := B); cbn in l, l'; PIR

      end.

      trivial.

  }

  {

    intros y h.

    induction y.

    + inversion h.

    + dependent destruction h.

      * rewrite (F_id F).

        trivial.

      * cbn.

        rewrite <- (IHy h).

        rewrite <- F_compose.

        match goal with

          [|- (F _a)%morphism ?A = (F _a)%morphism ?B] =>

          set (l := A); set (l' := B); cbn in l, l'; PIR

        end.

        trivial.

  }

Qed.



Lemma OmegaCat_Func_unique {C : Category} (F : (ω –≻ C)%functor) :

  F = OmegaCat_Func (FO F) (fun n => FA F (Tle_S _ _ (Tle_n n))).

Proof.

  unfold OmegaCat_Func.

  cbn_rewrite <- ((OmegaCat_Op_Func_unique (F^op))).

  trivial.

Qed.

