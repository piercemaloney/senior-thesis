From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Category.
From Categories Require Import Category.Opposite.

Local Open Scope morphism_scope.

Record Isomorphism {C : Category} (a b : C) : Type := 
{
  iso_morphism : a –≻ b;
  
  inverse_morphism : b –≻ a;
  
  left_inverse : (inverse_morphism ∘ iso_morphism)%morphism = id;
  
  right_inverse : (iso_morphism ∘ inverse_morphism)%morphism = id
}.

Bind Scope morphism_scope with Isomorphism.
Bind Scope isomorphism_scope with Isomorphism.

Hint Resolve left_inverse.

Hint Resolve right_inverse.

Coercion iso_morphism : Isomorphism >-> Hom.

Arguments iso_morphism {_ _ _} _.
Arguments inverse_morphism {_ _ _} _.
Arguments left_inverse {_ _ _} _.
Arguments right_inverse {_ _ _} _.

Notation "f '⁻¹'" := (inverse_morphism f) : morphism_scope.

Notation "a ≃ b" := (Isomorphism a b) : isomorphism_scope.

Notation "a ≃≃ b ::> C" := (@Isomorphism C a b) : isomorphism_scope.

Local Open Scope isomorphism_scope.

Ltac simpl_isos_in_goal :=
  repeat(
      match goal with
      | [|- context[(iso_morphism ?A ∘ inverse_morphism ?A)%morphism]] =>
        rewrite (right_inverse A); simpl_ids
      | [|- context[(inverse_morphism ?A ∘ iso_morphism ?A)%morphism] ] =>
        rewrite (left_inverse A); simpl_ids

      end
    )
.

Ltac simpl_isos_in_I I :=
  repeat(
      match type of I with
      | context[(iso_morphism ?A ∘ inverse_morphism ?A)%morphism] =>
        rewrite (right_inverse A) in I; simpl_ids in I
      | context[(inverse_morphism ?A ∘ iso_morphism ?A)%morphism] =>
        rewrite (left_inverse A) in I; simpl_ids in I

      end
    )
.

Tactic Notation "simpl_isos" := simpl_isos_in_goal.

Tactic Notation "simpl_isos" "in" hyp(I) := simpl_isos_in_I I.

Hint Extern 3 => progress simpl_isos.

Hint Extern 3 => progress (dohyps (fun H => simpl_isos in H)).

Theorem Isomorphism_eq_simplify {C : Category} {a b : C} (I I' : a ≃ b) :
  (iso_morphism I = iso_morphism I') →
  (inverse_morphism I = inverse_morphism I') → I = I'.
Proof.
  intros H1 H2.
  destruct I as [iI inI Il Ir]; destruct I' as [iI' inI' Il' Ir'].
  cbn in *.
  destruct H1; destruct H2.
  destruct (proof_irrelevance _ Il Il').
  destruct (proof_irrelevance _ Ir Ir').
  trivial.  
Qed.  

Program Definition Isomorphism_id {C : Category} {a : C} : a ≃ a :=
{|
  iso_morphism := id;
  inverse_morphism := id
|}.

Definition Inverse_Isomorphism {C : Category} {a b : C} (I : a ≃ b) : b ≃ a :=
{|
  iso_morphism := I⁻¹;
  inverse_morphism := I;
  left_inverse := right_inverse I;
  right_inverse := left_inverse I
|}.

Notation "f '⁻¹'" := (Inverse_Isomorphism f) : isomorphism_scope.

Program Definition Isomorphism_Compose
        {C : Category} {a b c : C} (I : a ≃ b) (I' : b ≃ c) : a ≃ c
  :=
{|
  iso_morphism := I' ∘ I;
  inverse_morphism := I⁻¹ ∘ I'⁻¹
|}.

Next Obligation.
Proof.
  rewrite assoc.
  rewrite (assoc_sym I).
  auto.
Qed.

Next Obligation.
Proof.
  rewrite assoc.
  rewrite (assoc_sym (I'⁻¹)).
  auto.
Qed.

Notation "f ∘ g" := (Isomorphism_Compose g f) : isomorphism_scope.

Local Close Scope isomorphism_scope.

Record Monic {C : Category} (a b : Obj) :=
{
  mono_morphism : a –≻ b;
  mono_morphism_monomorphic : ∀ (c : Obj) (g h : c –≻ a),
      (mono_morphism ∘ g = mono_morphism ∘ h) → g = h
}.

Coercion mono_morphism : Monic >-> Hom.

Arguments mono_morphism {_ _ _} _.
Arguments mono_morphism_monomorphic {_ _ _} _ _ _ _ _.

Notation "a ≫–> b" := (Monic a b) : morphism_scope.

Bind Scope morphism_scope with Monic.

Definition Epic {C : Category} (a b : C) := @Monic (C^op) b a.

Notation "a –≫ b" := (Epic a b) : morphism_scope.

Bind Scope morphism_scope with Epic.

Definition is_Monic {C : Category} {a b : Obj} (f : a –≻ b) :=
  ∀ (c : Obj) (g h : c –≻ a), (f ∘ g = f ∘ h) → g = h.

Definition is_Monic_Monic
           {C : Category}
           {a b : Obj}
           {f : a –≻ b}
           (H : is_Monic f)
  : Monic a b
  :=
    {|
      mono_morphism := f;
      mono_morphism_monomorphic := H
    |}
.

Definition is_Epic {C : Category} {a b : C} (f : a –≻ b) :=
  @is_Monic (C^op) b a f.

Record is_split_Monic {C : Category} {a b : Obj} (f : a –≻ b) :=
  {
    is_split_monic_left_inverse : b –≻ a;
    is_split_monic_left_inverse_is_left_inverse :
      (is_split_monic_left_inverse ∘ f) = id
  }
.

Arguments is_split_monic_left_inverse {_ _ _ _} _.
Arguments is_split_monic_left_inverse_is_left_inverse {_ _ _ _} _.

Definition is_split_Epic {C : Category} {a b : C} (f : a –≻ b) :=
  @is_split_Monic (C^op) b a f.

Program Definition is_split_Monic_Monic
           {C : Category}
           {a b : Obj}
           {f : a –≻ b}
           (H : is_split_Monic f)
  : Monic a b
  :=
    {|
      mono_morphism := f;
      mono_morphism_monomorphic := fun c g h H1 => _
    |}
.

Next Obligation.
Proof.
  assert (H2 := f_equal (fun w : c –≻ b => (is_split_monic_left_inverse H) ∘ w) H1).
  cbn in H2.
  repeat rewrite assoc_sym in H2.
  rewrite is_split_monic_left_inverse_is_left_inverse in H2.
  auto.
Qed.

Program Definition Monic_is_split_Epic_Iso
        {C : Category}
        (a b : Obj)
        (f : a ≫–> b)
        (H : is_split_Epic f)
  :
    (a ≃ b)%isomorphism
  :=
    {|
      iso_morphism := f;
      inverse_morphism := is_split_monic_left_inverse H;
      right_inverse := is_split_monic_left_inverse_is_left_inverse H
    |}
.

Next Obligation.
Proof.
  apply (mono_morphism_monomorphic f).
  rewrite assoc_sym.
  cbn_rewrite (is_split_monic_left_inverse_is_left_inverse H).
  auto.
Qed.

Program Definition Compose_Monic_is_Monic_then_Monic
           {C : Category}
           {a b c : C}
           (M : a –≻ b)
           (M' : b ≫–> c)
           (H : is_Monic (M' ∘ M))
  :
    Monic a b
  :=
    {|
      mono_morphism := M;
      mono_morphism_monomorphic := fun d g h H1 => _
    |}
.

Next Obligation.
Proof.
  assert (H2 := f_equal (fun w : d –≻ b => M' ∘ w) H1).
  cbn in H2.
  repeat rewrite assoc_sym in H2.
  apply H; trivial.
Qed.

Section Mono_compose.
  Context {C : Category} {a b c : C} (M : a ≫–> b) (M' : b ≫–> c).

  Local Hint Resolve mono_morphism_monomorphic.

  Local Obligation Tactic := eauto.
  
  Program Definition Mono_compose : a ≫–> c :=
    {|
      mono_morphism := M' ∘ M
    |}.
    
End Mono_compose.

Local Open Scope isomorphism_scope.

Section Iso_Mono_Epi.
  Context {C : Category} {a b : Obj} (I : a ≃ b).

  Program Definition Ismorphism_Monic : a ≫–> b :=
    {|
      mono_morphism := I
    |}.

  Next Obligation. 
  Proof.
    match goal with
        [ H : (_ ∘ ?f = _ ∘ ?f')%morphism |- ?f = ?f'] =>
        match type of H with
            ?A = ?B =>
            let H' := fresh "H" in
            cut (I⁻¹ ∘ A = I⁻¹ ∘ B)%morphism; [auto | rewrite H; trivial]
        end
    end.
    repeat rewrite assoc_sym.
    auto.
  Qed.

  Program Definition Ismorphism_Epic : b –≫ a :=
    {|
      mono_morphism := inverse_morphism I
    |}.
  Next Obligation. 
  Proof.
    match goal with
        [ H : (?f ∘ _ = ?f' ∘ _)%morphism |- ?f = ?f'] =>
        match type of H with
            ?A = ?B =>
            let H' := fresh "H" in
            cut (A ∘ I = B ∘ I)%morphism; [auto | rewrite H; trivial]
        end
    end.
    repeat rewrite assoc.
    auto.
  Qed.

End Iso_Mono_Epi.

Theorem CoIso {C : Category} (a b : C) : a ≃≃ b ::> C → a ≃≃ b ::> C^op. 
Proof.
  intros I.
  eapply (Build_Isomorphism (C^op)%category _ _ (I⁻¹) I);
    unfold compose; simpl; auto.
Qed.
