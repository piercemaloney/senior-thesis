From Categories Require Import Essentials.Notations.
(* Categories.Essentials.Notations:
Notation "∀ x .. y , P" := (forall x, .. (forall y, P) ..)
                             (at level 200, x binder, y binder, right associativity) : type_scope.

Notation "∃ x .. y , P" := (exists x, .. (exists y, P) ..)
  (at level 200, x binder, y binder, right associativity) : type_scope.

Notation "x ∨ y" := (x \/ y) (at level 85, right associativity) : type_scope.

Notation "x ∧ y" := (x /\ y) (at level 80, right associativity) : type_scope.

Notation "x → y" := (x -> y)
  (at level 90, y at level 200, right associativity): type_scope.

Notation "x ↔ y" := (x <-> y) (at level 95, no associativity): type_scope.

Notation "¬ x" := (~x) (at level 75, right associativity) : type_scope.

Notation "x ≠ y" := (x <> y) (at level 70) : type_scope.

Notation "x ≤ y" := (le x y) (at level 70, no associativity).

Notation "x ≥ y" := (ge x y) (at level 70, no associativity).

Reserved Notation "C '^op'" (at level 50, no associativity).

Reserved Notation "a –≻ b" (at level 90, b at level 200, right associativity).

Reserved Notation "f '⁻¹'" (at level 50, no associativity).

Reserved Notation "a ≃ b" (at level 70, no associativity).

Reserved Notation "a ≃≃ b ::> C" (at level 70, no associativity).

Reserved Notation "f ∘ g" (at level 51, right associativity).

Reserved Notation "f '∘_h' g" (at level 51, right associativity).

Reserved Notation "a ≫–> b" (at level 100, no associativity).

Reserved Notation "a –≫ b" (at level 100, no associativity).

Reserved Notation "F '_o'" (at level 50, no associativity).

Reserved Notation "F '_a'" (at level 50, no associativity).

Reserved Notation "F '@_a'" (at level 50, no associativity).

Reserved Notation "F ⊣ G" (at level 100, no associativity).

Reserved Notation "F ⊣_hom G" (at level 100, no associativity).

Reserved Notation "F ⊣_ucu G" (at level 100, no associativity).

Reserved Notation "a × b" (at level 80, no associativity).

Reserved Notation "a ⇑ b" (at level 79, no associativity).

Reserved Notation "'Π' m" (at level 50, no associativity).

Reserved Notation "'Σ' m" (at level 50, no associativity).

Reserved Notation "'Π_' C ↓ m" (at level 50, no associativity).

Reserved Notation "'Σ_' C ↓ m" (at level 50, no associativity).

Delimit Scope category_scope with category.

Delimit Scope morphism_scope with morphism.

Delimit Scope object_scope with object.

Delimit Scope functor_scope with functor.

Delimit Scope nattrans_scope with nattrans.

Delimit Scope nattrans_scope with nattrans.

Delimit Scope natiso_scope with natiso.

Delimit Scope isomorphism_scope with isomorphism.

Delimit Scope preorder_scope with preorder. *)

From Categories Require Import Essentials.Types.
(* Categories.Essentials.Types:
Global Set Primitive Projections.

Global Set Universe Polymorphism.

Global Unset Universe Minimization ToSet.

Inductive Empty : Type :=.

Hint Extern 1 =>
let tac := (repeat intros ?); match goal with [H : Empty |- _] => contradict H end in
match goal with
  | [|- context[Empty]] => tac
  | [H : context[Empty] |- _] => tac
end
.

Record prod (A B : Type) := {fst : A; snd : B}.

Arguments fst {_ _ } _.
Arguments snd {_ _ } _.
Arguments Build_prod {_ _ } _ _.

Notation "( X , Y )" := (Build_prod X Y).
Notation "X * Y" := (prod X Y) : type_scope. *)

From Categories Require Import Essentials.Facts_Tactics.
(* Categories.Essentials.Facts_Tactics:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.

Require Export Coq.Program.Tactics.
Require Export Coq.Program.Equality.
Require Export Coq.Logic.FunctionalExtensionality.
Require Export Coq.Logic.ProofIrrelevance.

Definition equal_f : ∀ {A B : Type} {f g : A → B}, f = g → ∀ x : A, f x = g x.

Definition f_equal : ∀ (A B : Type) (f : A → B) (x y : A), x = y → f x = f y.

Arguments f_equal [_ _] _ [_ _] _.

Ltac basic_simpl :=
  let simpl_prod _ :=
      match goal with
        [H : prod _ _ |- _] =>
        let H1 := fresh H "1" in
        let H2 := fresh H "2" in
        destruct H as [H1 H2]
      end
  in
  let simpl_sig _ :=
      match goal with
        [H : @sig _ _ |- _] =>
        let H1 := fresh H "1" in
        let H2 := fresh H "2" in
        destruct H as [H1 H2]
      end
  in
  let basic_simpl_helper _ :=
      cbn in *; intros;
        repeat simpl_prod tt;
        repeat simpl_sig tt
  in
  repeat basic_simpl_helper tt
.

Global Obligation Tactic := basic_simpl; auto.

Ltac PIR :=
  let pir_helper _ :=
      match goal with
      |[H : ?A, H' : ?A|- _] =>
       match type of A with
       | Prop =>
         destruct (proof_irrelevance _ H H')
       end
      end
  in
  repeat pir_helper tt
.

Ltac ElimEq := repeat match goal with [H : _ = _|- _] => destruct H end.

Hint Extern 1 => progress ElimEq.

Ltac cbn_rewrite W :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite H; clear H
.

Ltac cbn_rewrite_in W V :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite H in V; clear H
.

Ltac cbn_rewrite_back W :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite <- H; clear H
.

Ltac cbn_rewrite_back_in W V :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite <- H in V; clear H
.

Tactic Notation "cbn_rewrite" constr(W) := cbn_rewrite W.
Tactic Notation "cbn_rewrite" constr(W) "in" hyp_list(V) := cbn_rewrite_in W V.
Tactic Notation "cbn_rewrite" "<-" constr(W) := cbn_rewrite_back W.
Tactic Notation "cbn_rewrite" "<-" constr(W) "in" hyp_list(V) := cbn_rewrite_back_in W V.

Lemma sig_proof_irrelevance {A : Type} (P : A → Prop) (X Y : sig P) : proj1_sig X = proj1_sig Y → X = Y.

Hint Extern 2 (exist ?A _ _ = exist ?A _ _) => apply sig_proof_irrelevance.

Ltac FunExt :=
progress (
    repeat (
        match goal with
          [|- _ = _] =>
          let x := fresh "x" in
          extensionality x
        end
      )
  )
.

Hint Extern 1 => FunExt.

Lemma pair_eq (A B : Type) (a b : A * B) : fst a = fst b → snd a = snd b → a = b.

Hint Resolve pair_eq.

Ltac revert_clearbody_all :=
 repeat lazymatch goal with H:_ |- _ => try clearbody H; revert H end.

Ltac hyp_stack :=
 constr:(ltac:(revert_clearbody_all;constructor) : True).

Ltac next_hyp hs step last :=
 lazymatch hs with (?hs' ?H) => step H hs' | _ => last end.

Tactic Notation "dohyps" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := tac H; next_hyp hs step idtac in
 next_hyp hs step idtac.

Tactic Notation "dohyps" "reverse" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := next_hyp hs step idtac; tac H in
 next_hyp hs step idtac.

Tactic Notation "do1hyp" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := tac H + next_hyp hs step fail in
 next_hyp hs step fail.

Tactic Notation "do1hyp" "reverse" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := next_hyp hs step fail + tac H in
 next_hyp hs step fail. *)

From Categories Require Import Category.Category.
(* Categories.Category.Category:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.

Cumulative Class Category : Type :=
{
  
  Obj : Type;

  Hom : Obj → Obj → Type where "a –≻ b" := (Hom a b);

  compose : ∀ {a b c : Obj}, (a –≻ b) → (b –≻ c) → (a –≻ c) where "f ∘ g" := (compose g f);

  assoc : ∀ {a b c d : Obj} (f : a –≻ b) (g : b –≻ c) (h : c –≻ d),
            ((h ∘ g) ∘ f) = (h ∘ (g ∘ f));

  assoc_sym : ∀ {a b c d : Obj} (f : a –≻ b) (g : b –≻ c) (h : c –≻ d),
                ((h ∘ (g ∘ f) = (h ∘ g) ∘ f));

  id : ∀ {a : Obj}, a –≻ a;

  id_unit_left : ∀ (a b : Obj) (h : a –≻ b), id ∘ h = h;

  id_unit_right : ∀ (a b : Obj) (h : a –≻ b), h ∘ id = h
}.

Arguments Obj {_}, _.
Arguments id {_ _}, {_} _, _ _.
Arguments Hom {_} _ _, _ _ _.
Arguments compose {_} {_ _ _} _ _, _ {_ _ _} _ _, _ _ _ _ _ _.
Arguments assoc {_ _ _ _ _} _ _ _.
Arguments assoc_sym {_ _ _ _ _} _ _ _.

Notation "f ∘ g" := (compose g f) : morphism_scope.
Notation "a –≻ b" := (Hom a b) : morphism_scope.

Bind Scope category_scope with Category.

Bind Scope morphism_scope with Hom.

Bind Scope object_scope with Obj.

Coercion Obj : Category >-> Sortclass.

Hint Resolve id_unit_left id_unit_right.

Ltac simpl_ids :=
  let id_detected B :=
      let J := fresh "H" in
      cut (B = id); [intros J; rewrite J; clear J | trivial]
  in
  repeat(
      match goal with
        | [|- context[(?A ∘ id)%morphism] ] => rewrite id_unit_right
        | [|- context[(id ∘ ?A)%morphism] ] => rewrite id_unit_left
        | [|- (?A ∘ ?B)%morphism = ?A] => id_detected B
        | [|- (?A = ?A ∘ ?B) %morphism] => id_detected B
        | [|- (?B ∘ ?A = ?A)%morphism] => id_detected B
        | [|- (?A = ?B ∘ ?A)%morphism] => id_detected B
      end
    )
.

Ltac simpl_ids_in_I I :=
  repeat(
      match type of I with
        | context[(?A ∘ id)%morphism] => rewrite id_unit_right in I
        | context[(id ∘ ?A)%morphism] => rewrite id_unit_left in I
      end
    )
.

Tactic Notation "simpl_ids" := simpl_ids.

Tactic Notation "simpl_ids" "in" hyp(I) := simpl_ids_in_I I.

Hint Extern 1 => progress simpl_ids.

Hint Extern 3 => progress (dohyps (fun H => simpl_ids in H)).

Hint Extern 2 =>
match goal with
    [|- ?A = ?B :> Hom _ _ _] =>
    repeat rewrite assoc; trivial; fail
end.

Hint Extern 2 =>
match goal with
  [H : _ = _ :> Hom _ _ _ |- _ = _ :> Hom _ _ _] =>
  repeat rewrite assoc in H;
    repeat rewrite assoc;
    (idtac + symmetry); apply H
end. *)

From Categories Require Import Category.Opposite.
(* Categories.Category.Opposite:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Category.

Definition Opposite (C : Category) : Category :=
{|

  Obj := Obj C;
           
  Hom := fun a b => (b –≻ a)%morphism;

  compose :=
    fun a b c (f : (b –≻ a)%morphism) (g : (c –≻ b)%morphism) => compose C c b a g f;

  id := fun c => id C c;
  
  assoc := fun _ _ _ _ f g h => assoc_sym h g f;

  assoc_sym := fun _ _ _ _ f g h => assoc h g f;

  id_unit_left := fun _ _ h => @id_unit_right C _ _ h;
  
  id_unit_right := fun _ _ h => @id_unit_left C _ _ h
                   
|}.

Notation "C '^op'" := (Opposite C) : category_scope. *)



Local Open Scope morphism_scope.



Record Isomorphism {C : Category} (a b : C) : Type := 

{

  iso_morphism : a –≻ b;

  

  inverse_morphism : b –≻ a;

  

  left_inverse : (inverse_morphism ∘ iso_morphism)%morphism = id;

  

  right_inverse : (iso_morphism ∘ inverse_morphism)%morphism = id

}.



Bind Scope morphism_scope with Isomorphism.

Bind Scope isomorphism_scope with Isomorphism.



Hint Resolve left_inverse.



Hint Resolve right_inverse.



Coercion iso_morphism : Isomorphism >-> Hom.



Arguments iso_morphism {_ _ _} _.

Arguments inverse_morphism {_ _ _} _.

Arguments left_inverse {_ _ _} _.

Arguments right_inverse {_ _ _} _.



Notation "f '⁻¹'" := (inverse_morphism f) : morphism_scope.



Notation "a ≃ b" := (Isomorphism a b) : isomorphism_scope.



Notation "a ≃≃ b ::> C" := (@Isomorphism C a b) : isomorphism_scope.



Local Open Scope isomorphism_scope.



Ltac simpl_isos_in_goal :=

  repeat(

      match goal with

      | [|- context[(iso_morphism ?A ∘ inverse_morphism ?A)%morphism]] =>

        rewrite (right_inverse A); simpl_ids

      | [|- context[(inverse_morphism ?A ∘ iso_morphism ?A)%morphism] ] =>

        rewrite (left_inverse A); simpl_ids



      end

    )

.



Ltac simpl_isos_in_I I :=

  repeat(

      match type of I with

      | context[(iso_morphism ?A ∘ inverse_morphism ?A)%morphism] =>

        rewrite (right_inverse A) in I; simpl_ids in I

      | context[(inverse_morphism ?A ∘ iso_morphism ?A)%morphism] =>

        rewrite (left_inverse A) in I; simpl_ids in I



      end

    )

.



Tactic Notation "simpl_isos" := simpl_isos_in_goal.



Tactic Notation "simpl_isos" "in" hyp(I) := simpl_isos_in_I I.



Hint Extern 3 => progress simpl_isos.



Hint Extern 3 => progress (dohyps (fun H => simpl_isos in H)).



Theorem Isomorphism_eq_simplify {C : Category} {a b : C} (I I' : a ≃ b) :

  (iso_morphism I = iso_morphism I') →

  (inverse_morphism I = inverse_morphism I') → I = I'.

Proof.

  intros H1 H2.

  destruct I as [iI inI Il Ir]; destruct I' as [iI' inI' Il' Ir'].

  cbn in *.

  destruct H1; destruct H2.

  destruct (proof_irrelevance _ Il Il').

  destruct (proof_irrelevance _ Ir Ir').

  trivial.  

Qed.  



Program Definition Isomorphism_id {C : Category} {a : C} : a ≃ a :=

{|

  iso_morphism := id;

  inverse_morphism := id

|}.



Definition Inverse_Isomorphism {C : Category} {a b : C} (I : a ≃ b) : b ≃ a :=

{|

  iso_morphism := I⁻¹;

  inverse_morphism := I;

  left_inverse := right_inverse I;

  right_inverse := left_inverse I

|}.



Notation "f '⁻¹'" := (Inverse_Isomorphism f) : isomorphism_scope.



Program Definition Isomorphism_Compose

        {C : Category} {a b c : C} (I : a ≃ b) (I' : b ≃ c) : a ≃ c

  :=

{|

  iso_morphism := I' ∘ I;

  inverse_morphism := I⁻¹ ∘ I'⁻¹

|}.



Next Obligation.

Proof.

  rewrite assoc.

  rewrite (assoc_sym I).

  auto.

Qed.



Next Obligation.

Proof.

  rewrite assoc.

  rewrite (assoc_sym (I'⁻¹)).

  auto.

Qed.



Notation "f ∘ g" := (Isomorphism_Compose g f) : isomorphism_scope.



Local Close Scope isomorphism_scope.



Record Monic {C : Category} (a b : Obj) :=

{

  mono_morphism : a –≻ b;

  mono_morphism_monomorphic : ∀ (c : Obj) (g h : c –≻ a),

      (mono_morphism ∘ g = mono_morphism ∘ h) → g = h

}.



Coercion mono_morphism : Monic >-> Hom.



Arguments mono_morphism {_ _ _} _.

Arguments mono_morphism_monomorphic {_ _ _} _ _ _ _ _.



Notation "a ≫–> b" := (Monic a b) : morphism_scope.



Bind Scope morphism_scope with Monic.



Definition Epic {C : Category} (a b : C) := @Monic (C^op) b a.



Notation "a –≫ b" := (Epic a b) : morphism_scope.



Bind Scope morphism_scope with Epic.



Definition is_Monic {C : Category} {a b : Obj} (f : a –≻ b) :=

  ∀ (c : Obj) (g h : c –≻ a), (f ∘ g = f ∘ h) → g = h.



Definition is_Monic_Monic

           {C : Category}

           {a b : Obj}

           {f : a –≻ b}

           (H : is_Monic f)

  : Monic a b

  :=

    {|

      mono_morphism := f;

      mono_morphism_monomorphic := H

    |}

.



Definition is_Epic {C : Category} {a b : C} (f : a –≻ b) :=

  @is_Monic (C^op) b a f.



Record is_split_Monic {C : Category} {a b : Obj} (f : a –≻ b) :=

  {

    is_split_monic_left_inverse : b –≻ a;

    is_split_monic_left_inverse_is_left_inverse :

      (is_split_monic_left_inverse ∘ f) = id

  }

.



Arguments is_split_monic_left_inverse {_ _ _ _} _.

Arguments is_split_monic_left_inverse_is_left_inverse {_ _ _ _} _.



Definition is_split_Epic {C : Category} {a b : C} (f : a –≻ b) :=

  @is_split_Monic (C^op) b a f.



Program Definition is_split_Monic_Monic

           {C : Category}

           {a b : Obj}

           {f : a –≻ b}

           (H : is_split_Monic f)

  : Monic a b

  :=

    {|

      mono_morphism := f;

      mono_morphism_monomorphic := fun c g h H1 => _

    |}

.



Next Obligation.

Proof.

  assert (H2 := f_equal (fun w : c –≻ b => (is_split_monic_left_inverse H) ∘ w) H1).

  cbn in H2.

  repeat rewrite assoc_sym in H2.

  rewrite is_split_monic_left_inverse_is_left_inverse in H2.

  auto.

Qed.



Program Definition Monic_is_split_Epic_Iso

        {C : Category}

        (a b : Obj)

        (f : a ≫–> b)

        (H : is_split_Epic f)

  :

    (a ≃ b)%isomorphism

  :=

    {|

      iso_morphism := f;

      inverse_morphism := is_split_monic_left_inverse H;

      right_inverse := is_split_monic_left_inverse_is_left_inverse H

    |}

.



Next Obligation.

Proof.

  apply (mono_morphism_monomorphic f).

  rewrite assoc_sym.

  cbn_rewrite (is_split_monic_left_inverse_is_left_inverse H).

  auto.

Qed.



Program Definition Compose_Monic_is_Monic_then_Monic

           {C : Category}

           {a b c : C}

           (M : a –≻ b)

           (M' : b ≫–> c)

           (H : is_Monic (M' ∘ M))

  :

    Monic a b

  :=

    {|

      mono_morphism := M;

      mono_morphism_monomorphic := fun d g h H1 => _

    |}

.



Next Obligation.

Proof.

  assert (H2 := f_equal (fun w : d –≻ b => M' ∘ w) H1).

  cbn in H2.

  repeat rewrite assoc_sym in H2.

  apply H; trivial.

Qed.



Section Mono_compose.

  Context {C : Category} {a b c : C} (M : a ≫–> b) (M' : b ≫–> c).



  Local Hint Resolve mono_morphism_monomorphic.



  Local Obligation Tactic := eauto.

  

  Program Definition Mono_compose : a ≫–> c :=

    {|

      mono_morphism := M' ∘ M

    |}.

    

End Mono_compose.



Local Open Scope isomorphism_scope.



Section Iso_Mono_Epi.

  Context {C : Category} {a b : Obj} (I : a ≃ b).



  Program Definition Ismorphism_Monic : a ≫–> b :=

    {|

      mono_morphism := I

    |}.



  Next Obligation. 

  Proof.

    match goal with

        [ H : (_ ∘ ?f = _ ∘ ?f')%morphism |- ?f = ?f'] =>

        match type of H with

            ?A = ?B =>

            let H' := fresh "H" in

            cut (I⁻¹ ∘ A = I⁻¹ ∘ B)%morphism; [auto | rewrite H; trivial]

        end

    end.

    repeat rewrite assoc_sym.

    auto.

  Qed.



  Program Definition Ismorphism_Epic : b –≫ a :=

    {|

      mono_morphism := inverse_morphism I

    |}.

  Next Obligation. 

  Proof.

    match goal with

        [ H : (?f ∘ _ = ?f' ∘ _)%morphism |- ?f = ?f'] =>

        match type of H with

            ?A = ?B =>

            let H' := fresh "H" in

            cut (A ∘ I = B ∘ I)%morphism; [auto | rewrite H; trivial]

        end

    end.

    repeat rewrite assoc.

    auto.

  Qed.



End Iso_Mono_Epi.



Theorem CoIso {C : Category} (a b : C) : a ≃≃ b ::> C → a ≃≃ b ::> C^op. 

Proof.

  intros I.

  eapply (Build_Isomorphism (C^op)%category _ _ (I⁻¹) I);

    unfold compose; simpl; auto.

Qed.

