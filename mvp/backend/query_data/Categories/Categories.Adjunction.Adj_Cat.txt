From Categories Require Import Essentials.Notations.
(* Categories.Essentials.Notations:
Notation "∀ x .. y , P" := (forall x, .. (forall y, P) ..)
                             (at level 200, x binder, y binder, right associativity) : type_scope.

Notation "∃ x .. y , P" := (exists x, .. (exists y, P) ..)
  (at level 200, x binder, y binder, right associativity) : type_scope.

Notation "x ∨ y" := (x \/ y) (at level 85, right associativity) : type_scope.

Notation "x ∧ y" := (x /\ y) (at level 80, right associativity) : type_scope.

Notation "x → y" := (x -> y)
  (at level 90, y at level 200, right associativity): type_scope.

Notation "x ↔ y" := (x <-> y) (at level 95, no associativity): type_scope.

Notation "¬ x" := (~x) (at level 75, right associativity) : type_scope.

Notation "x ≠ y" := (x <> y) (at level 70) : type_scope.

Notation "x ≤ y" := (le x y) (at level 70, no associativity).

Notation "x ≥ y" := (ge x y) (at level 70, no associativity).

Reserved Notation "C '^op'" (at level 50, no associativity).

Reserved Notation "a –≻ b" (at level 90, b at level 200, right associativity).

Reserved Notation "f '⁻¹'" (at level 50, no associativity).

Reserved Notation "a ≃ b" (at level 70, no associativity).

Reserved Notation "a ≃≃ b ::> C" (at level 70, no associativity).

Reserved Notation "f ∘ g" (at level 51, right associativity).

Reserved Notation "f '∘_h' g" (at level 51, right associativity).

Reserved Notation "a ≫–> b" (at level 100, no associativity).

Reserved Notation "a –≫ b" (at level 100, no associativity).

Reserved Notation "F '_o'" (at level 50, no associativity).

Reserved Notation "F '_a'" (at level 50, no associativity).

Reserved Notation "F '@_a'" (at level 50, no associativity).

Reserved Notation "F ⊣ G" (at level 100, no associativity).

Reserved Notation "F ⊣_hom G" (at level 100, no associativity).

Reserved Notation "F ⊣_ucu G" (at level 100, no associativity).

Reserved Notation "a × b" (at level 80, no associativity).

Reserved Notation "a ⇑ b" (at level 79, no associativity).

Reserved Notation "'Π' m" (at level 50, no associativity).

Reserved Notation "'Σ' m" (at level 50, no associativity).

Reserved Notation "'Π_' C ↓ m" (at level 50, no associativity).

Reserved Notation "'Σ_' C ↓ m" (at level 50, no associativity).

Delimit Scope category_scope with category.

Delimit Scope morphism_scope with morphism.

Delimit Scope object_scope with object.

Delimit Scope functor_scope with functor.

Delimit Scope nattrans_scope with nattrans.

Delimit Scope nattrans_scope with nattrans.

Delimit Scope natiso_scope with natiso.

Delimit Scope isomorphism_scope with isomorphism.

Delimit Scope preorder_scope with preorder. *)

From Categories Require Import Essentials.Types.
(* Categories.Essentials.Types:
Global Set Primitive Projections.

Global Set Universe Polymorphism.

Global Unset Universe Minimization ToSet.

Inductive Empty : Type :=.

Hint Extern 1 =>
let tac := (repeat intros ?); match goal with [H : Empty |- _] => contradict H end in
match goal with
  | [|- context[Empty]] => tac
  | [H : context[Empty] |- _] => tac
end
.

Record prod (A B : Type) := {fst : A; snd : B}.

Arguments fst {_ _ } _.
Arguments snd {_ _ } _.
Arguments Build_prod {_ _ } _ _.

Notation "( X , Y )" := (Build_prod X Y).
Notation "X * Y" := (prod X Y) : type_scope. *)

From Categories Require Import Essentials.Facts_Tactics.
(* Categories.Essentials.Facts_Tactics:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.

Require Export Coq.Program.Tactics.
Require Export Coq.Program.Equality.
Require Export Coq.Logic.FunctionalExtensionality.
Require Export Coq.Logic.ProofIrrelevance.

Definition equal_f : ∀ {A B : Type} {f g : A → B}, f = g → ∀ x : A, f x = g x.

Definition f_equal : ∀ (A B : Type) (f : A → B) (x y : A), x = y → f x = f y.

Arguments f_equal [_ _] _ [_ _] _.

Ltac basic_simpl :=
  let simpl_prod _ :=
      match goal with
        [H : prod _ _ |- _] =>
        let H1 := fresh H "1" in
        let H2 := fresh H "2" in
        destruct H as [H1 H2]
      end
  in
  let simpl_sig _ :=
      match goal with
        [H : @sig _ _ |- _] =>
        let H1 := fresh H "1" in
        let H2 := fresh H "2" in
        destruct H as [H1 H2]
      end
  in
  let basic_simpl_helper _ :=
      cbn in *; intros;
        repeat simpl_prod tt;
        repeat simpl_sig tt
  in
  repeat basic_simpl_helper tt
.

Global Obligation Tactic := basic_simpl; auto.

Ltac PIR :=
  let pir_helper _ :=
      match goal with
      |[H : ?A, H' : ?A|- _] =>
       match type of A with
       | Prop =>
         destruct (proof_irrelevance _ H H')
       end
      end
  in
  repeat pir_helper tt
.

Ltac ElimEq := repeat match goal with [H : _ = _|- _] => destruct H end.

Hint Extern 1 => progress ElimEq.

Ltac cbn_rewrite W :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite H; clear H
.

Ltac cbn_rewrite_in W V :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite H in V; clear H
.

Ltac cbn_rewrite_back W :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite <- H; clear H
.

Ltac cbn_rewrite_back_in W V :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite <- H in V; clear H
.

Tactic Notation "cbn_rewrite" constr(W) := cbn_rewrite W.
Tactic Notation "cbn_rewrite" constr(W) "in" hyp_list(V) := cbn_rewrite_in W V.
Tactic Notation "cbn_rewrite" "<-" constr(W) := cbn_rewrite_back W.
Tactic Notation "cbn_rewrite" "<-" constr(W) "in" hyp_list(V) := cbn_rewrite_back_in W V.

Lemma sig_proof_irrelevance {A : Type} (P : A → Prop) (X Y : sig P) : proj1_sig X = proj1_sig Y → X = Y.

Hint Extern 2 (exist ?A _ _ = exist ?A _ _) => apply sig_proof_irrelevance.

Ltac FunExt :=
progress (
    repeat (
        match goal with
          [|- _ = _] =>
          let x := fresh "x" in
          extensionality x
        end
      )
  )
.

Hint Extern 1 => FunExt.

Lemma pair_eq (A B : Type) (a b : A * B) : fst a = fst b → snd a = snd b → a = b.

Hint Resolve pair_eq.

Ltac revert_clearbody_all :=
 repeat lazymatch goal with H:_ |- _ => try clearbody H; revert H end.

Ltac hyp_stack :=
 constr:(ltac:(revert_clearbody_all;constructor) : True).

Ltac next_hyp hs step last :=
 lazymatch hs with (?hs' ?H) => step H hs' | _ => last end.

Tactic Notation "dohyps" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := tac H; next_hyp hs step idtac in
 next_hyp hs step idtac.

Tactic Notation "dohyps" "reverse" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := next_hyp hs step idtac; tac H in
 next_hyp hs step idtac.

Tactic Notation "do1hyp" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := tac H + next_hyp hs step fail in
 next_hyp hs step fail.

Tactic Notation "do1hyp" "reverse" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := next_hyp hs step fail + tac H in
 next_hyp hs step fail. *)

From Categories Require Import Category.Main.
(* Categories.Category.Main:
From Categories Require Export Category.Category.
From Categories Require Export Category.Morph.
From Categories Require Export Category.Opposite.
From Categories Require Export Category.SubCategory.
From Categories Require Export Category.Composable_Chain. *)

From Categories Require Import Functor.Main.
(* Categories.Functor.Main:
From Categories Require Export Functor.Functor.
From Categories Require Export Functor.Functor_Extender.
From Categories Require Export Functor.Functor_Image.
From Categories Require Export Functor.Functor_Ops.
From Categories Require Export Functor.Functor_Properties.
From Categories Require Export Functor.Const_Func.
From Categories Require Export Functor.Const_Func_Functor. *)

From Categories Require Import Adjunction.Adjunction Adjunction.Duality.
(* Categories.Adjunction.Adjunction:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Ext_Cons.Prod_Cat.Prod_Cat Ext_Cons.Prod_Cat.Operations.
From Categories Require Import Functor.Main.
From Categories Require Import Functor.Representable.Hom_Func
        Functor.Representable.Hom_Func_Prop.
From Categories Require Import NatTrans.Main.

Local Open Scope functor_scope.

Local Notation NID := NatTrans_id (only parsing).
Local Notation FCAT := Func_Cat (only parsing).

Notation Hom_Adj_Left C D F G :=
  ((Hom_Func D) ∘ (Prod_Functor (F^op) (@Functor_id D)))%functor (only parsing).

Notation Hom_Adj_Right C D F G :=
  ((Hom_Func C) ∘ (Prod_Functor (@Functor_id (C^op)) G))%functor (only parsing).

Local Obligation Tactic := idtac.

Section Adjunction.
  Context {C D : Category} (F : C –≻ D) (G : D –≻ C).

  Record Adjunct : Type :=
  {
    adj_unit : ((Functor_id C) –≻ (G ∘ F))%nattrans;
    
    adj_morph_ex {c : C} {d : D} (f : (c –≻ (G _o d)%object)%morphism) :
      ((F _o c)%object –≻ d)%morphism;
    
    adj_morph_com {c : C} {d : D} (f : (c –≻ (G _o d))%morphism%object) :
      f = ((G _a (adj_morph_ex f)) ∘ (Trans adj_unit c))%morphism;
    
    adj_morph_unique {c : C} {d : D} (f : (c –≻ (G _o d))%object%morphism)
                     (g h : ((F _o c) –≻ d)%morphism%object) :
      f = ((G _a g) ∘ (Trans adj_unit c))%morphism →
      f = ((G _a h) ∘ (Trans adj_unit c))%morphism →
      g = h
  }.

  Arguments adj_unit : clear implicits.
  Arguments adj_morph_ex _ {_ _} _.
  Arguments adj_morph_com _ {_ _} _.
  Arguments adj_morph_unique _ {_ _} _ _ _ _ _.

  Theorem Adjunct_eq_simplify (adj adj' : Adjunct) :
    adj_unit adj = @adj_unit adj' →
    @adj_morph_ex adj = @adj_morph_ex adj' → adj = adj'.

  Definition Hom_Adjunct :=
    (Hom_Adj_Left _ _ F G ≃ Hom_Adj_Right _ _ F G)%natiso.

  Record UCU_Adjunct :=
    {
      ucu_adj_unit : ((Functor_id C) –≻ (G ∘ F))%nattrans;
      
      ucu_adj_counit : ((F ∘ G) –≻ (Functor_id D))%nattrans;

      ucu_adj_left_id : ((NatTrans_from_compose_id _)
                           ∘ ((((ucu_adj_counit ∘_h (NID F))
                                  ∘ (NatTrans_Functor_assoc_sym _ _ _))
                                 ∘ ((NID F) ∘_h ucu_adj_unit))
                                ∘ (NatTrans_to_id_compose _)))%nattrans
                        = (NID F);
      
      ucu_adj_right_id : ((NatTrans_from_id_compose _)
                            ∘ (((((NID G) ∘_h ucu_adj_counit)
                                   ∘ (NatTrans_Functor_assoc _ _ _))
                                  ∘ (ucu_adj_unit ∘_h (NID G)))
                                 ∘ (NatTrans_to_compose_id _)))%nattrans
                         = (NID G)
    }.

  Arguments ucu_adj_unit : clear implicits.
  Arguments ucu_adj_counit : clear implicits.
  Arguments ucu_adj_left_id : clear implicits.
  Arguments ucu_adj_right_id : clear implicits.

  Local Notation "F ⊣ G" := (Adjunct) : functor_scope.
  Local Notation "F ⊣_hom G" := (Hom_Adjunct) : functor_scope.
  Local Notation "F ⊣_ucu G" := (UCU_Adjunct) : functor_scope.
  
  Section UCU_Adj_Adj.
    Context (Adj : (F ⊣_ucu G)%functor).

    Program Definition UCU_Adj_to_Adj : (F ⊣ G)%functor :=
      {|
        adj_unit := ucu_adj_unit Adj;
        adj_morph_ex :=
          fun _ _ h => ((Trans (ucu_adj_counit Adj) _) ∘ (F _a h))%morphism
      |}.

  End UCU_Adj_Adj.

  Section Adj_UCU_Adj.
    Context (Adj : (F ⊣ G)%functor).
    
    Program Definition Adj_to_UCU_Adj : (F ⊣_ucu G)%functor :=
      {|
        ucu_adj_unit := adj_unit Adj;
        ucu_adj_counit :=
          {|
            Trans := fun d => @adj_morph_ex Adj (G _o d) d id
          |}
      |}.

  End Adj_UCU_Adj.
  
  Section Adj_Hom_Adj.
    Context (Adj : (F ⊣ G)%functor).

    Program Definition Adj_to_Hom_Adj_LR :
      ((Hom_Adj_Left _ _ F G) –≻ (Hom_Adj_Right _ _ F G))%nattrans :=
    {|
      Trans := fun c h => ((G _a h) ∘ (Trans (adj_unit Adj) _))%morphism
    |}.

    Program Definition Adj_to_Hom_Adj_RL :
      ((Hom_Adj_Right _ _ F G) –≻ (Hom_Adj_Left _ _ F G))%nattrans :=
    {|
      Trans := fun c h => adj_morph_ex Adj h
    |}.

    Program Definition Adj_to_Hom_Adj : (F ⊣_hom G)%functor :=
      NatIso _ _ Adj_to_Hom_Adj_LR Adj_to_Hom_Adj_RL _ _.

  End Adj_Hom_Adj.

  Section Hom_Adj_Adj.
    Context (Adj : (F ⊣_hom G)%functor).

    Program Definition Hom_Adj_to_Adj : (F ⊣ G)%functor :=
      {|
        adj_unit :=
          {| Trans := fun c => Trans (iso_morphism Adj) (c, F _o c)%object id |};
        adj_morph_ex := fun _ _ f => Trans (inverse_morphism Adj) (_, _) f
      |}.

  End Hom_Adj_Adj.

End Adjunction.

Arguments adj_unit {_ _ _ _} _ : assert.
Arguments adj_morph_ex {_ _ _ _} _ {_ _} _.
Arguments adj_morph_com {_ _ _ _} _ {_ _} _.
Arguments adj_morph_unique {_ _ _ _} _ {_ _} _ _ _ _ _.

Arguments ucu_adj_unit {_ _ _ _} _.
Arguments ucu_adj_counit {_ _ _ _} _.
Arguments ucu_adj_left_id {_ _ _ _} _.
Arguments ucu_adj_right_id {_ _ _ _} _.

Arguments Adj_to_Hom_Adj {_ _ _ _} _.

Arguments Hom_Adj_to_Adj {_ _ _ _} _.

Notation "F ⊣ G" := (Adjunct F G) : functor_scope.
Notation "F ⊣_hom G" := (Hom_Adjunct F G) : functor_scope.
Notation "F ⊣_ucu G" := (UCU_Adjunct F G) : functor_scope. *)
(* Categories.Adjunction.Duality:
From Categories Require Import Category.Main.
From Categories Require Import Ext_Cons.Prod_Cat.Prod_Cat Ext_Cons.Prod_Cat.Operations.
From Categories Require Import Functor.Main.
From Categories Require Import Functor.Representable.Hom_Func Functor.Representable.Hom_Func_Prop.
From Categories Require Import NatTrans.NatTrans NatTrans.NatIso.
From Categories Require Import Adjunction.Adjunction.

Local Open Scope functor_scope.

Section Hom_Adj_Duality.
  Context {C D : Category} {F : C –≻ D} {G : D –≻ C} (adj : F ⊣_hom G).

  Definition Hom_Adjunct_Duality : G^op ⊣_hom F^op :=
    (Prod_Func_Hom_Func (adj⁻¹))
  .

End Hom_Adj_Duality.

Section Adj_Duality.
  Context {C D : Category} {F : C –≻ D} {G : D –≻ C} (adj : F ⊣ G).

  Definition Adjunct_Duality : G^op ⊣ F^op :=
    (Hom_Adj_to_Adj (Hom_Adjunct_Duality (Adj_to_Hom_Adj adj)))
  .

End Adj_Duality. *)

From Categories Require Import NatTrans.NatTrans.
(* Categories.NatTrans.NatTrans:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Functor.
From Categories Require Import Cat.Cat.

Section NatTrans.
  Context {C C' : Category}.

  Record NatTrans (F F' : (C –≻ C')%functor) :=
    {
      Trans (c : C) : ((F _o c) –≻ (F' _o c))%object%morphism;
      Trans_com {c c' : C} (h : (c –≻ c')%morphism) :
        ((Trans c') ∘ F _a h = F' _a h ∘ (Trans c))%morphism;
      Trans_com_sym {c c' : C} (h : (c –≻ c')%morphism) :
        (F' _a h ∘ (Trans c) = (Trans c') ∘ F _a h)%morphism
    }.

  Notation "F –≻ F'" := (NatTrans F F') : nattrans_scope.

  Lemma NatTrans_eq_simplify {F F' : (C –≻ C')%functor}
        (N N' : (F –≻ F')%nattrans) : (@Trans _ _ N) = (@Trans _ _ N') -> N = N'.

End NatTrans.

Arguments Trans {_ _ _ _} _ _.
Arguments Trans_com {_ _ _ _} _ {_ _} _.
Arguments Trans_com_sym {_ _ _ _} _ {_ _} _.

Bind Scope nattrans_scope with NatTrans.

Notation "F –≻ F'" := (NatTrans F F') : nattrans_scope.

Local Open Scope nattrans_scope.

Section NatTrans_Compose.
  Context {C C' : Category}.
  
  Program Definition NatTrans_compose {F F' F'' : (C –≻ C')%functor}
          (tr : F –≻ F') (tr' : F' –≻ F'') : (F –≻ F'')%nattrans :=
    {|
      Trans := fun c : Obj => ((Trans tr' c) ∘ (Trans tr c)) % morphism
    |}.

End NatTrans_Compose.

Notation "N ∘ N'" := (NatTrans_compose N' N) : nattrans_scope.

Section NatTrans_Props.
  Context {C C' : Category}.
  
  Theorem NatTrans_compose_assoc {F G H I : (C –≻ C')%functor} (N : F –≻ G)
          (N' : G –≻ H) (N'' : H –≻ I)
    : ((N'' ∘ N') ∘ N = N'' ∘ (N' ∘ N))%nattrans
  .

  Program Definition NatTrans_id (F : (C –≻ C')%functor) : F –≻ F :=
    {|
      Trans := fun x : Obj => id
    |}.

  Theorem NatTrans_id_unit_left {F G : (C –≻ C')%functor} (N : F –≻ G)
    : (NatTrans_id G) ∘ N = N.

  Theorem NatTrans_id_unit_right {F G : (C –≻ C')%functor} (N : F –≻ G)
    : N ∘ (NatTrans_id F) = N.
  
End NatTrans_Props.

Hint Resolve NatTrans_eq_simplify. *)



Local Open Scope functor_scope.



Section Adjunct_Id.

  Context (C : Category).



  Program Definition Adjunct_Id : (Functor_id C) ⊣ (Functor_id C) :=

    {|

      adj_unit := NatTrans_id _

    |}.



End Adjunct_Id.

  

Section Adjunct_Compose.

  Context {C D E : Category}

          {F : C –≻ D} {G : D –≻ C} (adj : F ⊣ G)

          {F' : D –≻ E} {G' : E –≻ D} (adj' : F' ⊣ G').

  

  Program Definition Adjunct_Compose : ((F' ∘ F) ⊣ (G ∘ G')) :=

    {|

      adj_unit :=

        {|Trans := fun c => (G _a ((Trans (adj_unit adj') (F _o c)))

                            ∘ (Trans (adj_unit adj) c))%morphism |};

      adj_morph_ex := fun _ _ f => adj_morph_ex adj' (adj_morph_ex adj f)

    |}.



  Next Obligation.

  Proof.

    rewrite assoc.

    set (W := (Trans_com (adj_unit adj) h)); cbn in W; rewrite W; clear W.

    rewrite assoc_sym.

    set (W := f_equal (G _a)%morphism

                      (Trans_com (adj_unit adj') ((F _a) h)%morphism));

      cbn in W; rewrite F_compose in W; rewrite W.

    repeat rewrite F_compose.

    auto.

  Qed.    



  Next Obligation.

  Proof.

    symmetry.

    apply Adjunct_Compose_obligation_1.

  Qed.    



  Next Obligation.

  Proof.

    rewrite assoc_sym.

    set (W := f_equal (G _a)%morphism

                      (adj_morph_com adj' (adj_morph_ex adj f)));

      rewrite F_compose in W; cbn in W; rewrite <- W; clear W.

    apply (adj_morph_com adj f).

  Qed.    



  Local Obligation Tactic := idtac.

  

  Next Obligation.

  Proof.

    intros c d f g h H1 H2.

    cbn in *.

    rewrite assoc_sym in H1, H2.

    rewrite <- F_compose in H1, H2.

    set (W := @adj_morph_unique _ _ _ _ adj _ _ f _ _ H1 H2).

    cbn in W.

    match type of W with

      ?A = ?B =>

      apply (@adj_morph_unique _ _ _ _ adj' _ _ A _ _ eq_refl W)

    end.

  Qed.



End Adjunct_Compose.



Section Adjunct_Compose_assoc.

  Context {B C D E : Category}

          {F : B –≻ C} {G : C –≻ B} (adj : F ⊣ G)

          {F' : C –≻ D} {G' : D –≻ C} (adj' : F' ⊣ G')

          {F'' : D –≻ E} {G'' : E –≻ D} (adj'' : F'' ⊣ G'').

  

  Theorem Adjunct_Compose_assoc :

    match (Functor_assoc F F' F'') in _ = Y return Adjunct Y _ with

      eq_refl =>

      match eq_sym (Functor_assoc G'' G' G) in _ = Y return Adjunct _ Y with

        eq_refl =>

        Adjunct_Compose adj (Adjunct_Compose adj' adj'')

      end

    end

    = Adjunct_Compose (Adjunct_Compose adj adj') adj''.

  Proof.

    apply Adjunct_eq_simplify.

    {

      apply NatTrans_eq_simplify.

      extensionality x.

      apply JMeq_eq.

      destruct (Functor_assoc F F' F'').

      destruct (eq_sym (Functor_assoc G'' G' G)).

      cbn.

      rewrite F_compose.

      repeat rewrite assoc_sym.

      trivial.

    }

    {

      extensionality x.

      extensionality y.

      apply JMeq_eq.

      destruct (Functor_assoc F F' F'').

      destruct (eq_sym (Functor_assoc G'' G' G)).

      trivial.

    }

  Qed.



End Adjunct_Compose_assoc.



Section Adjunct_Id_unit_left.

  Context {B C: Category}

          {F : B –≻ C} {G : C –≻ B} (adj : F ⊣ G).

  

  Theorem Adjunct_Id_unit_left :

    match (Functor_id_unit_left _ _ F) in _ = Y return Adjunct Y _ with

      eq_refl =>

      match (Functor_id_unit_right _ _ G) in _ = Y return Adjunct _ Y with

        eq_refl =>

        Adjunct_Compose adj (Adjunct_Id C)

      end

    end 

    = adj.

  Proof.

    apply Adjunct_eq_simplify.

    {

      apply NatTrans_eq_simplify.

      extensionality x.

      apply JMeq_eq.

      destruct (Functor_id_unit_left _ _ F).

      destruct (Functor_id_unit_right _ _ G).

      cbn.

      auto.

    }

    {

      extensionality x.

      extensionality y.

      apply JMeq_eq.

      destruct (Functor_id_unit_left _ _ F).

      destruct (Functor_id_unit_right _ _ G).

      trivial.

    }

  Qed.



End Adjunct_Id_unit_left.



Section Adjunct_Id_unit_right.

  Context {B C: Category}

          {F : B –≻ C} {G : C –≻ B} (adj : F ⊣ G).

  

  Theorem Adjunct_Id_unit_right :

    match (Functor_id_unit_right _ _ F) in _ = Y return Adjunct Y _ with

      eq_refl =>

      match (Functor_id_unit_left _ _ G) in _ = Y return Adjunct _ Y with

        eq_refl =>

        Adjunct_Compose (Adjunct_Id B) adj

      end

    end 

    = adj.

  Proof.

    apply Adjunct_eq_simplify.

    {

      apply NatTrans_eq_simplify.

      extensionality x.

      apply JMeq_eq.

      destruct (Functor_id_unit_right _ _ F).

      destruct (Functor_id_unit_left _ _ G).

      cbn.

      auto.

    }

    {

      extensionality x.

      extensionality y.

      apply JMeq_eq.

      destruct (Functor_id_unit_right _ _ F).

      destruct (Functor_id_unit_left _ _ G).

      trivial.

    }

  Qed.



End Adjunct_Id_unit_right.



Definition Adjunct_Between (C D : Category) : Type :=

  {F : (C –≻ D) * (D –≻ C) & (fst F) ⊣ (snd F)}

.



Definition Adjunct_Between_Id (C : Category) : Adjunct_Between C C :=

  existT _ (Functor_id C, Functor_id C) (Adjunct_Id C).

  

Section Adjunct_Between_Compose.

  Context {C D E : Category}

          (adj : Adjunct_Between C D)

          (adj' : Adjunct_Between D E).



  Definition Adjunct_Between_Compose : Adjunct_Between C E :=

    existT _

           ((fst (projT1 adj') ∘ (fst (projT1 adj))),

            ((snd (projT1 adj)) ∘ (snd (projT1 adj'))))

           (Adjunct_Compose (projT2 adj) (projT2 adj')).



End Adjunct_Between_Compose.



Theorem sigT_eq_simplify {A : Type} {P : A → Type} (s s' : sigT P)

        (H : projT1 s = projT1 s')

  : match H in _ = Y return P Y with

      eq_refl => projT2 s

    end = projT2 s' → s = s'.

Proof.

  intros H'.

  destruct s as [s Ps]; destruct s' as [s' Ps'].

  change (existT P s Ps)

  with (existT _ (projT1 (existT P s Ps)) (projT2 (existT P s Ps))).

  change (existT P s' Ps')

  with (existT _ (projT1 (existT P s' Ps')) (projT2 (existT P s' Ps'))).

  rewrite <- H'.

  clear H'.

  destruct H.

  trivial.

Qed.  

                      

Section Adjunct_Between_Compose_assoc.

  Context {B C D E : Category}

           (adj : Adjunct_Between B C)

           (adj' : Adjunct_Between C D)

           (adj'' : Adjunct_Between D E).

  

  Theorem Adjunct_Between_Compose_assoc :

    Adjunct_Between_Compose adj (Adjunct_Between_Compose adj' adj'') =

    Adjunct_Between_Compose (Adjunct_Between_Compose adj adj') adj''.

  Proof.

    destruct adj as [[F G] adjb]; destruct adj' as [[F' G'] adjb'];

    destruct adj'' as [[F'' G''] adjb''].

    set (W := Functor_assoc (fst (F, G)) (fst (F', G')) (fst (F'', G''))).

    set (W' := eq_sym (Functor_assoc

                         (snd (F'', G'')) (snd (F', G')) (snd (F, G)))).

    match type of W with

      ?A = ?B =>

      match type of W' with

        ?A' = ?B' =>

        match goal with

          [|- ?X = ?Z] =>

          set (H :=

                 match W in _ = Y return (A, _) = (Y, _) with

                   eq_refl =>

                   match W' in _ = Y return (_, A') = (_, Y) with

                     eq_refl => eq_refl (A, A')

                   end

                 end : projT1 X = projT1 Z)

        end

      end

    end.

    apply (sigT_eq_simplify _ _ H).

    etransitivity; [|apply Adjunct_Compose_assoc].

    unfold W, W' in H; clear W W'; unfold H; clear H.

    cbn.

    destruct (Functor_assoc F F' F'').

    destruct (eq_sym (Functor_assoc G'' G' G)).

    trivial.

  Qed.



End Adjunct_Between_Compose_assoc.



Section Adjunct_Between_Id_unit_left.

  Context {B C: Category}

          (adj : Adjunct_Between B C).

  

  Theorem Adjunct_Between_Id_unit_left :

    Adjunct_Between_Compose adj (Adjunct_Between_Id C) = adj.

  Proof.

    destruct adj as [[F G] adjb].

    set (W := (Functor_id_unit_left _ _ (fst (F, G)))).

    set (W' := (Functor_id_unit_right _ _ (snd (F, G)))).

    match type of W with

      ?A = ?B =>

      match type of W' with

        ?A' = ?B' =>

        match goal with

          [|- ?X = ?Z] =>

          set (H :=

                 match W in _ = Y return (A, _) = (Y, _) with

                   eq_refl =>

                   match W' in _ = Y return (_, A') = (_, Y) with

                     eq_refl => eq_refl (A, A')

                   end

                 end : projT1 X = projT1 Z)

        end

      end

    end.

    apply (sigT_eq_simplify _ _ H).

    match type of (@Adjunct_Id_unit_left _ _ _ _ adjb) with

      ?A = ?B => transitivity A; [|apply (@Adjunct_Id_unit_left _ _ _ _ adjb)]

    end.

    unfold W, W' in H; clear W W'; unfold H; clear H.

    cbn.

    destruct (Functor_id_unit_left _ _ F).

    destruct (Functor_id_unit_right _ _ G).

    trivial.

  Qed.



End Adjunct_Between_Id_unit_left.



Section Adjunct_Between_Id_unit_right.

  Context {B C: Category}

          (adj : Adjunct_Between B C).

  

  Theorem Adjunct_Between_Id_unit_right :

    Adjunct_Between_Compose (Adjunct_Between_Id B) adj = adj.

  Proof.

    destruct adj as [[F G] adjb].

    set (W := (Functor_id_unit_right _ _ (fst (F, G)))).

    set (W' := (Functor_id_unit_left _ _ (snd (F, G)))).

    match type of W with

      ?A = ?B =>

      match type of W' with

        ?A' = ?B' =>

        match goal with

          [|- ?X = ?Z] =>

          set (H :=

                 match W in _ = Y return (A, _) = (Y, _) with

                   eq_refl =>

                   match W' in _ = Y return (_, A') = (_, Y) with

                     eq_refl => eq_refl (A, A')

                   end

                 end : projT1 X = projT1 Z)

        end

      end

    end.

    apply (sigT_eq_simplify _ _ H).

    match type of (@Adjunct_Id_unit_right _ _ _ _ adjb) with

      ?A = ?B => transitivity A; [|apply (@Adjunct_Id_unit_right _ _ _ _ adjb)]

    end.

    unfold W, W' in H; clear W W'; unfold H; clear H.

    cbn.

    destruct (Functor_id_unit_right _ _ F).

    destruct (Functor_id_unit_left _ _ G).

    trivial.

  Qed.



End Adjunct_Between_Id_unit_right.



Definition Adjunct_Cat : Category :=

  {|

    Obj := Category;

    Hom := Adjunct_Between;

    compose := @Adjunct_Between_Compose;

    assoc := @Adjunct_Between_Compose_assoc;

    assoc_sym :=

      fun A B C D adj adj' adj'' =>

        eq_sym (@Adjunct_Between_Compose_assoc A B C D adj adj' adj'');

    id := Adjunct_Between_Id;

    id_unit_right := @Adjunct_Between_Id_unit_right;

    id_unit_left := @Adjunct_Between_Id_unit_left

  |}.

