From Categories Require Import Essentials.Notations.
(* Categories.Essentials.Notations:
Notation "âˆ€ x .. y , P" := (forall x, .. (forall y, P) ..)
                             (at level 200, x binder, y binder, right associativity) : type_scope.

Notation "âˆƒ x .. y , P" := (exists x, .. (exists y, P) ..)
  (at level 200, x binder, y binder, right associativity) : type_scope.

Notation "x âˆ¨ y" := (x \/ y) (at level 85, right associativity) : type_scope.

Notation "x âˆ§ y" := (x /\ y) (at level 80, right associativity) : type_scope.

Notation "x â†’ y" := (x -> y)
  (at level 90, y at level 200, right associativity): type_scope.

Notation "x â†” y" := (x <-> y) (at level 95, no associativity): type_scope.

Notation "Â¬ x" := (~x) (at level 75, right associativity) : type_scope.

Notation "x â‰  y" := (x <> y) (at level 70) : type_scope.

Notation "x â‰¤ y" := (le x y) (at level 70, no associativity).

Notation "x â‰¥ y" := (ge x y) (at level 70, no associativity).

Reserved Notation "C '^op'" (at level 50, no associativity).

Reserved Notation "a â€“â‰» b" (at level 90, b at level 200, right associativity).

Reserved Notation "f 'â»Â¹'" (at level 50, no associativity).

Reserved Notation "a â‰ƒ b" (at level 70, no associativity).

Reserved Notation "a â‰ƒâ‰ƒ b ::> C" (at level 70, no associativity).

Reserved Notation "f âˆ˜ g" (at level 51, right associativity).

Reserved Notation "f 'âˆ˜_h' g" (at level 51, right associativity).

Reserved Notation "a â‰«â€“> b" (at level 100, no associativity).

Reserved Notation "a â€“â‰« b" (at level 100, no associativity).

Reserved Notation "F '_o'" (at level 50, no associativity).

Reserved Notation "F '_a'" (at level 50, no associativity).

Reserved Notation "F '@_a'" (at level 50, no associativity).

Reserved Notation "F âŠ£ G" (at level 100, no associativity).

Reserved Notation "F âŠ£_hom G" (at level 100, no associativity).

Reserved Notation "F âŠ£_ucu G" (at level 100, no associativity).

Reserved Notation "a Ã— b" (at level 80, no associativity).

Reserved Notation "a â‡‘ b" (at level 79, no associativity).

Reserved Notation "'Î ' m" (at level 50, no associativity).

Reserved Notation "'Î£' m" (at level 50, no associativity).

Reserved Notation "'Î _' C â†“ m" (at level 50, no associativity).

Reserved Notation "'Î£_' C â†“ m" (at level 50, no associativity).

Delimit Scope category_scope with category.

Delimit Scope morphism_scope with morphism.

Delimit Scope object_scope with object.

Delimit Scope functor_scope with functor.

Delimit Scope nattrans_scope with nattrans.

Delimit Scope nattrans_scope with nattrans.

Delimit Scope natiso_scope with natiso.

Delimit Scope isomorphism_scope with isomorphism.

Delimit Scope preorder_scope with preorder. *)

From Categories Require Import Essentials.Types.
(* Categories.Essentials.Types:
Global Set Primitive Projections.

Global Set Universe Polymorphism.

Global Unset Universe Minimization ToSet.

Inductive Empty : Type :=.

Hint Extern 1 =>
let tac := (repeat intros ?); match goal with [H : Empty |- _] => contradict H end in
match goal with
  | [|- context[Empty]] => tac
  | [H : context[Empty] |- _] => tac
end
.

Record prod (A B : Type) := {fst : A; snd : B}.

Arguments fst {_ _ } _.
Arguments snd {_ _ } _.
Arguments Build_prod {_ _ } _ _.

Notation "( X , Y )" := (Build_prod X Y).
Notation "X * Y" := (prod X Y) : type_scope. *)

From Categories Require Import Essentials.Facts_Tactics.
(* Categories.Essentials.Facts_Tactics:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.

Require Export Coq.Program.Tactics.
Require Export Coq.Program.Equality.
Require Export Coq.Logic.FunctionalExtensionality.
Require Export Coq.Logic.ProofIrrelevance.

Definition equal_f : âˆ€ {A B : Type} {f g : A â†’ B}, f = g â†’ âˆ€ x : A, f x = g x.

Definition f_equal : âˆ€ (A B : Type) (f : A â†’ B) (x y : A), x = y â†’ f x = f y.

Arguments f_equal [_ _] _ [_ _] _.

Ltac basic_simpl :=
  let simpl_prod _ :=
      match goal with
        [H : prod _ _ |- _] =>
        let H1 := fresh H "1" in
        let H2 := fresh H "2" in
        destruct H as [H1 H2]
      end
  in
  let simpl_sig _ :=
      match goal with
        [H : @sig _ _ |- _] =>
        let H1 := fresh H "1" in
        let H2 := fresh H "2" in
        destruct H as [H1 H2]
      end
  in
  let basic_simpl_helper _ :=
      cbn in *; intros;
        repeat simpl_prod tt;
        repeat simpl_sig tt
  in
  repeat basic_simpl_helper tt
.

Global Obligation Tactic := basic_simpl; auto.

Ltac PIR :=
  let pir_helper _ :=
      match goal with
      |[H : ?A, H' : ?A|- _] =>
       match type of A with
       | Prop =>
         destruct (proof_irrelevance _ H H')
       end
      end
  in
  repeat pir_helper tt
.

Ltac ElimEq := repeat match goal with [H : _ = _|- _] => destruct H end.

Hint Extern 1 => progress ElimEq.

Ltac cbn_rewrite W :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite H; clear H
.

Ltac cbn_rewrite_in W V :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite H in V; clear H
.

Ltac cbn_rewrite_back W :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite <- H; clear H
.

Ltac cbn_rewrite_back_in W V :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite <- H in V; clear H
.

Tactic Notation "cbn_rewrite" constr(W) := cbn_rewrite W.
Tactic Notation "cbn_rewrite" constr(W) "in" hyp_list(V) := cbn_rewrite_in W V.
Tactic Notation "cbn_rewrite" "<-" constr(W) := cbn_rewrite_back W.
Tactic Notation "cbn_rewrite" "<-" constr(W) "in" hyp_list(V) := cbn_rewrite_back_in W V.

Lemma sig_proof_irrelevance {A : Type} (P : A â†’ Prop) (X Y : sig P) : proj1_sig X = proj1_sig Y â†’ X = Y.

Hint Extern 2 (exist ?A _ _ = exist ?A _ _) => apply sig_proof_irrelevance.

Ltac FunExt :=
progress (
    repeat (
        match goal with
          [|- _ = _] =>
          let x := fresh "x" in
          extensionality x
        end
      )
  )
.

Hint Extern 1 => FunExt.

Lemma pair_eq (A B : Type) (a b : A * B) : fst a = fst b â†’ snd a = snd b â†’ a = b.

Hint Resolve pair_eq.

Ltac revert_clearbody_all :=
 repeat lazymatch goal with H:_ |- _ => try clearbody H; revert H end.

Ltac hyp_stack :=
 constr:(ltac:(revert_clearbody_all;constructor) : True).

Ltac next_hyp hs step last :=
 lazymatch hs with (?hs' ?H) => step H hs' | _ => last end.

Tactic Notation "dohyps" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := tac H; next_hyp hs step idtac in
 next_hyp hs step idtac.

Tactic Notation "dohyps" "reverse" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := next_hyp hs step idtac; tac H in
 next_hyp hs step idtac.

Tactic Notation "do1hyp" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := tac H + next_hyp hs step fail in
 next_hyp hs step fail.

Tactic Notation "do1hyp" "reverse" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := next_hyp hs step fail + tac H in
 next_hyp hs step fail. *)

From Categories Require Import Category.Main.
(* Categories.Category.Main:
From Categories Require Export Category.Category.
From Categories Require Export Category.Morph.
From Categories Require Export Category.Opposite.
From Categories Require Export Category.SubCategory.
From Categories Require Export Category.Composable_Chain. *)

From Categories Require Import Functor.Functor Functor.Functor_Ops.
(* Categories.Functor.Functor:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.

Record Functor (C C' : Category) : Type :=
{
  
  FO : C â†’ C';

  FA : âˆ€ {a b}, (a â€“â‰» b)%morphism â†’ ((FO a) â€“â‰» (FO b))%morphism;

  F_id : âˆ€ c, FA (id c) = id (FO c);

  F_compose : âˆ€ {a b c} (f : (a â€“â‰» b)%morphism) (g : (b â€“â‰» c)%morphism),
      (FA (g âˆ˜ f) = (FA g) âˆ˜ (FA f))%morphism

}.

Arguments FO {_ _} _ _.
Arguments FA {_ _} _ {_ _} _, {_ _} _ _ _ _.
Arguments F_id {_ _} _ _.
Arguments F_compose {_ _} _ {_ _ _} _ _.

Notation "C â€“â‰» D" := (Functor C D) : functor_scope.

Bind Scope functor_scope with Functor.

Notation "F '_o'" := (FO F) : object_scope.

Notation "F '@_a'" := (@FA _ _ F) : morphism_scope.

Notation "F '_a'" := (FA F) : morphism_scope.

Hint Extern 2 => (apply F_id).

Local Open Scope morphism_scope.
Local Open Scope object_scope.

Ltac Functor_Simplify :=
  progress
    (
      repeat rewrite F_id;
      (
        repeat
          match goal with
          | [|- ?F _a ?A = id (?F _o ?x)] =>
            (rewrite <- F_id; (cbn+idtac))
          | [|- (id (?F _o ?x)) = ?F _a ?A] =>
            (rewrite <- F_id; (cbn+idtac))
          | [|- ?F _a ?A âˆ˜ ?F _a ?B = ?F _a ?C âˆ˜ ?F _a ?D] =>
            (repeat rewrite <- F_compose; (cbn+idtac))
          | [|- ?F _a ?A âˆ˜ ?F _a ?B = ?F _a ?C] =>
            (rewrite <- F_compose; (cbn+idtac))
          | [|- ?F _a ?C = ?F _a ?A âˆ˜ ?F _a ?B] =>
            (rewrite <- F_compose; (cbn+idtac))
          | [|- context [?F _a ?A âˆ˜ ?F _a ?B]] =>
            (rewrite <- F_compose; (cbn+idtac))
          end
      )
    )
.

Hint Extern 2 => Functor_Simplify.

Section Functor_eq_simplification.

  Context {C C' : Category} (F G : (C â€“â‰» C')%functor).

  Lemma Functor_eq_simplify (Oeq : F _o = G _o) :
    ((fun x y =>
        match Oeq in _ = V return ((x â€“â‰» y) â†’ ((V x) â€“â‰» (V y)))%morphism with
          eq_refl => F  @_a x y
        end) = G @_a) -> F = G.

  Theorem FA_extensionality (Oeq : F _o = G _o) :
    (
      âˆ€ (a b : Obj)
        (h : (a â€“â‰» b)%morphism),
        (
          fun x y =>
            match Oeq in _ = V return
                  ((x â€“â‰» y) â†’ ((V x) â€“â‰» (V y)))%morphism
            with
              eq_refl => F  @_a x y
            end
        ) _ _ h = G _a h
    )
    â†’
    (
      fun x y =>
        match Oeq in _ = V return
              ((x â€“â‰» y) â†’ ((V x) â€“â‰» (V y)))%morphism
        with
          eq_refl => F  @_a x y
        end
    ) = G @_a.

  Lemma Functor_extensionality (Oeq : F _o = G _o) :
    (
      âˆ€ (a b : Obj) (h : (a â€“â‰» b)%morphism),
        (
          fun x y =>
            match Oeq in _ = V return
                  ((x â€“â‰» y) â†’ ((V x) â€“â‰» (V y)))%morphism
            with
              eq_refl => F  @_a x y
            end
        ) _ _ h = G _a h
    ) â†’ F = G.

End Functor_eq_simplification.

Hint Extern 2 => Functor_Simplify.

Ltac Func_eq_simpl :=
  match goal with
    [|- ?A = ?B :> Functor _ _] =>
    (apply (Functor_eq_simplify A B (eq_refl : A _o = B _o)%object)) +
    (cut (A _o = B _o)%object; [
       let u := fresh "H" in
       intros H;
         apply (Functor_eq_simplify A B H)
         |
    ])
  end.

Hint Extern 3 => Func_eq_simpl.

Section Functor_eq.
  Context {C C' : Category} (F G : (C â€“â‰» C')%functor).

  Lemma Functor_eq_morph (H : F = G) :
    âˆƒ (H : âˆ€ x, F _o x = G _o x),
    âˆ€ x y (h : (x â€“â‰» y)%morphism),
      match H x in _ = V return (V â€“â‰» _)%morphism with
         eq_refl =>
         match H y in _ = V return (_ â€“â‰» V)%morphism with
           eq_refl => F _a h
         end
       end = G _a h.

End Functor_eq. *)
(* Categories.Functor.Functor_Ops:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Functor.

Section Opposite_Functor.
  Context {C D : Category} (F : (C â€“â‰» D)%functor).
  
  Local Open Scope morphism_scope.
  Local Open Scope object_scope.
    
  Program Definition Opposite_Functor : (C^op â€“â‰» D^op)%functor :=
    {|
      FO := F _o;
      FA := fun _ _ h => F @_a _ _ h;
      F_id := fun a => F_id F a;
      F_compose := fun _ _ _ f g => F_compose F g f
    |}.

End Opposite_Functor.

Notation "F '^op'" := (Opposite_Functor F) : functor_scope.

Section Functor_Compose.
  Context {C C' C'' : Category} (F : (C â€“â‰» C')%functor) (F' : (C' â€“â‰» C'')%functor).

  Local Open Scope morphism_scope.
  Local Open Scope object_scope.
  
  Program Definition Functor_compose : (C â€“â‰» C'')%functor :=
    {|
      FO := fun c => F' _o (F _o c);
      FA := fun c d f => F' _a (F _a f)
    |}.
  
End Functor_Compose.

Notation "F âˆ˜ G" := (Functor_compose G F) : functor_scope. 

Section Functor_Assoc.
  Context {C1 C2 C3 C4 : Category}
          (F : (C1 â€“â‰» C2)%functor)
          (G : (C2 â€“â‰» C3)%functor)
          (H : (C3 â€“â‰» C4)%functor).

  Local Open Scope functor_scope.
    
  Theorem Functor_assoc : (H âˆ˜ G) âˆ˜ F = H âˆ˜ (G âˆ˜ F).

End Functor_Assoc.

Program Definition Functor_id (C : Category) : (C â€“â‰» C)%functor :=
  {|
    FO := fun x => x;
    FA := fun c d f => f
  |}.

Section Functor_Identity_Unit.
  Context  (C C' : Category) (F : (C â€“â‰» C')%functor).

  Theorem Functor_id_unit_left : ((Functor_id C') âˆ˜ F)%functor = F.

  Theorem Functor_id_unit_right : (Functor_compose (Functor_id _) F) = F.

End Functor_Identity_Unit. *)

From Categories Require Import Basic_Cons.Terminal.
(* Categories.Basic_Cons.Terminal:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Main.

Class Terminal (C : Category) : Type :=
{
  terminal : C;
  t_morph : âˆ€ (d : Obj), (d â€“â‰» terminal)%morphism;
  t_morph_unique : âˆ€ (d : Obj) (f g : (d â€“â‰» terminal)%morphism), f = g
}.

Arguments terminal {_} _.
Arguments t_morph {_} _ _.
Arguments t_morph_unique {_} _ _ _ _.

Coercion terminal : Terminal >-> Obj.

Notation "ðŸ™_ C" := (Terminal C) (at level 75) : object_scope.

Theorem Terminal_iso {C : Category} (T T' : (ðŸ™_ C)%object) :
  (T â‰ƒ T')%isomorphism.

Definition Initial (C : Category) := (ðŸ™_ (C ^op))%object.
Existing Class Initial.

Notation "ðŸ˜_ C" := (Initial C) (at level 75) : object_scope. *)

From Categories Require Import Cat.Cat Cat.Cat_Iso.
(* Categories.Cat.Cat:
From Categories Require Import Category.Main.
From Categories Require Import Functor.Functor Functor.Functor_Ops.

Local Open Scope functor_scope.

Definition Cat : Category :=
{|
  Obj := Category;

  Hom := Functor;

  compose := fun C D E => Functor_compose;
  
  assoc := fun C D E F (G : C â€“â‰» D) (H : D â€“â‰» E) (I : E â€“â‰» F) =>
            @Functor_assoc _ _ _ _ G H I;

  assoc_sym := fun C D E F (G : C â€“â‰» D) (H : D â€“â‰» E) (I : E â€“â‰» F) =>
            eq_sym (@Functor_assoc _ _ _ _ G H I);

  id := fun C => Functor_id C;

  id_unit_left := fun C D => @Functor_id_unit_left C D;

  id_unit_right := fun C D => @Functor_id_unit_right C D          
|}. *)
(* Categories.Cat.Cat_Iso:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Functor Functor.Functor_Ops.
From Categories Require Import Coq_Cats.Type_Cat.Type_Cat.
From Categories Require Import Ext_Cons.Prod_Cat.Prod_Cat.
From Categories Require Import Cat.Cat.
From Categories Require Import NatTrans.NatTrans NatTrans.Operations NatTrans.Func_Cat
        NatTrans.NatIso.

Local Open Scope isomorphism_scope.
Local Open Scope morphism_scope.
Local Open Scope object_scope.

Section Opposite_Cat_Iso.
  Context {C D : Category} (I : C â‰ƒâ‰ƒ D ::> Cat).

  Program Definition Opposite_Cat_Iso :
    (C^op)%category â‰ƒâ‰ƒ (D^op)%category ::> Cat
    :=
      {|
        iso_morphism := ((iso_morphism I)^op)%functor;
        inverse_morphism := ((inverse_morphism I)^op)%functor
      |}.

End Opposite_Cat_Iso.
  
Section Cat_IConv.
  Context {C D : Category} (I : C â‰ƒâ‰ƒ D ::> Cat).

  Definition Cat_Iso_Obj_conv (c : C) :
    c = (((inverse_morphism I) _o) (((iso_morphism I) _o) c))%object.

  Definition Cat_Iso_Hom_conv (c c' : C) :
    ((((inverse_morphism I) _o) (((iso_morphism I) _o) c))
      â€“â‰»
      (((inverse_morphism I) _o) (((iso_morphism I) _o) c')))%morphism
    = (c â€“â‰» c').

  Definition Cat_Iso_conv_inv {c c' : C}
             (h :
                (((inverse_morphism I) _o) (((iso_morphism I) _o) c))
                  â€“â‰» (((inverse_morphism I) _o) (((iso_morphism I) _o) c')))
    : c â€“â‰» c' :=
    match Cat_Iso_Hom_conv c c' in _ = Y return Y with
      eq_refl => h
    end.

  Theorem Cat_Iso_conv_inv_JMeq {c c' : C}
          (h :
             (((inverse_morphism I) _o) (((iso_morphism I) _o) c))
               â€“â‰» (((inverse_morphism I) _o) (((iso_morphism I) _o) c')))
    : Cat_Iso_conv_inv h ~= h.

  Definition Cat_Iso_conv {c c' : C} (h : c â€“â‰» c') :
    (((inverse_morphism I) _o) (((iso_morphism I) _o) c))
      â€“â‰» (((inverse_morphism I) _o) (((iso_morphism I) _o) c'))
    :=
    match eq_sym (Cat_Iso_Hom_conv c c') in _ = Y return Y with
      eq_refl => h
    end.
  
  Theorem Cat_Iso_conv_JMeq {c c' : C} (h : c â€“â‰» c') : Cat_Iso_conv h ~= h.

  Theorem Cat_Iso_conv_inv_Cat_Iso_conv {c c' : C} (h : c â€“â‰» c')
    : Cat_Iso_conv_inv (Cat_Iso_conv h) = h.

  Theorem Cat_Iso_conv_Cat_Iso_conv_inv {c c' : C}
          (h :
             (((inverse_morphism I) _o) (((iso_morphism I) _o) c))
               â€“â‰» (((inverse_morphism I) _o) (((iso_morphism I) _o) c')))
    :
      Cat_Iso_conv (Cat_Iso_conv_inv h) = h.

  Theorem Cat_Iso_conv_inv_I_inv_I {c c' : C} (h : c â€“â‰» c') :
    Cat_Iso_conv_inv (((inverse_morphism I) _a) (((iso_morphism I) _a) h)) = h.

  Theorem Cat_Iso_conv_inv_compose {c c' c'' : C}
          (h :
             (((inverse_morphism I) _o) (((iso_morphism I) _o) c))
               â€“â‰» (((inverse_morphism I) _o) (((iso_morphism I) _o) c'))
          )
          (h' :
             (((inverse_morphism I) _o) (((iso_morphism I) _o) c'))
               â€“â‰» (((inverse_morphism I) _o) (((iso_morphism I) _o) c''))
          )
    :
      Cat_Iso_conv_inv (compose C h h')
      = compose C (Cat_Iso_conv_inv h) (Cat_Iso_conv_inv h').

End Cat_IConv.

Section Cat_Iso_inv.
  Context {C D : Category} (I : C â‰ƒâ‰ƒ D ::> Cat).

  Theorem Cat_Iso_inv
          {c c' : C} (h : ((iso_morphism I) _o c) â€“â‰» ((iso_morphism I) _o c'))
    : {g : c â€“â‰» c' | h = ((iso_morphism I) _a g)}.

End Cat_Iso_inv.

Section IsoCat_NatIso.
  Context {C D : Category} (I : (C â‰ƒâ‰ƒ D ::> Cat)%morphism)
          {E : Category} (F : (D â€“â‰» E)%functor).

  Program Definition IsoCat_NatIso :
    ((F âˆ˜ ((iso_morphism I) âˆ˜ (Iâ»Â¹)%morphism))%functor â‰ƒ F)%natiso :=
    {|
      iso_morphism := IsoCat_NatTrans I F;
      inverse_morphism := IsoCat_NatTrans_back I F
    |}
  .

End IsoCat_NatIso. *)



Section Term_IsoCat.

  Context {C D : Category}

          (I : (C â‰ƒâ‰ƒ D ::> Cat)%isomorphism) (trm : (ðŸ™_ C)%object).



  Program Definition Term_IsoCat : (ðŸ™_ D)%object

    :=

      {|

        terminal := ((iso_morphism I) _o)%object trm;

        t_morph :=

          fun c =>

            match

              f_equal (fun w : (D â€“â‰» D)%functor => (w _o)%object c)

                      (right_inverse I)

              in _ = u return

              (u â€“â‰» _)%morphism

            with

              eq_refl => ((iso_morphism I) _a ((t_morph

                                                 trm ((Iâ»Â¹)%morphism _o c)))

                        )%morphism

            end;

        t_morph_unique :=

          fun c f g => _

      |}

  .



  Next Obligation.

  Proof.

    assert (H := f_equal

                   (fun w : (C â€“â‰» C)%functor => (w _o)%object (terminal trm))

                   (left_inverse I)).

    cbn in H.

    cut (

        match H in _ = u return

              (_ â€“â‰» u)%morphism

        with

        | eq_refl => ((I â»Â¹) _a f)%morphism

        end

        =

        match H in _ = u return

              (_ â€“â‰» u)%morphism

        with

        | eq_refl => ((I â»Â¹) _a g)%morphism

        end

    ).

    {

      intros H2.

      destruct H.

      match type of H2 with

        ?A = ?B =>

        assert (((iso_morphism I) _a A) = ((iso_morphism I) _a B))%morphism

          by (rewrite H2; trivial)

      end.

      rewrite <- (Cat_Iso_conv_inv_I_inv_I (Inverse_Isomorphism I) f).

      rewrite <- (Cat_Iso_conv_inv_I_inv_I (Inverse_Isomorphism I) g).

      apply f_equal.

      trivial.

    }

    {

      apply t_morph_unique.

    }

  Qed.



End Term_IsoCat.

