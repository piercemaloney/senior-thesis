From Categories Require Import Essentials.Notations.
(* Categories.Essentials.Notations:
Notation "âˆ€ x .. y , P" := (forall x, .. (forall y, P) ..)
                             (at level 200, x binder, y binder, right associativity) : type_scope.

Notation "âˆƒ x .. y , P" := (exists x, .. (exists y, P) ..)
  (at level 200, x binder, y binder, right associativity) : type_scope.

Notation "x âˆ¨ y" := (x \/ y) (at level 85, right associativity) : type_scope.

Notation "x âˆ§ y" := (x /\ y) (at level 80, right associativity) : type_scope.

Notation "x â†’ y" := (x -> y)
  (at level 90, y at level 200, right associativity): type_scope.

Notation "x â†” y" := (x <-> y) (at level 95, no associativity): type_scope.

Notation "Â¬ x" := (~x) (at level 75, right associativity) : type_scope.

Notation "x â‰  y" := (x <> y) (at level 70) : type_scope.

Notation "x â‰¤ y" := (le x y) (at level 70, no associativity).

Notation "x â‰¥ y" := (ge x y) (at level 70, no associativity).

Reserved Notation "C '^op'" (at level 50, no associativity).

Reserved Notation "a â€“â‰» b" (at level 90, b at level 200, right associativity).

Reserved Notation "f 'â»Â¹'" (at level 50, no associativity).

Reserved Notation "a â‰ƒ b" (at level 70, no associativity).

Reserved Notation "a â‰ƒâ‰ƒ b ::> C" (at level 70, no associativity).

Reserved Notation "f âˆ˜ g" (at level 51, right associativity).

Reserved Notation "f 'âˆ˜_h' g" (at level 51, right associativity).

Reserved Notation "a â‰«â€“> b" (at level 100, no associativity).

Reserved Notation "a â€“â‰« b" (at level 100, no associativity).

Reserved Notation "F '_o'" (at level 50, no associativity).

Reserved Notation "F '_a'" (at level 50, no associativity).

Reserved Notation "F '@_a'" (at level 50, no associativity).

Reserved Notation "F âŠ£ G" (at level 100, no associativity).

Reserved Notation "F âŠ£_hom G" (at level 100, no associativity).

Reserved Notation "F âŠ£_ucu G" (at level 100, no associativity).

Reserved Notation "a Ã— b" (at level 80, no associativity).

Reserved Notation "a â‡‘ b" (at level 79, no associativity).

Reserved Notation "'Î ' m" (at level 50, no associativity).

Reserved Notation "'Î£' m" (at level 50, no associativity).

Reserved Notation "'Î _' C â†“ m" (at level 50, no associativity).

Reserved Notation "'Î£_' C â†“ m" (at level 50, no associativity).

Delimit Scope category_scope with category.

Delimit Scope morphism_scope with morphism.

Delimit Scope object_scope with object.

Delimit Scope functor_scope with functor.

Delimit Scope nattrans_scope with nattrans.

Delimit Scope nattrans_scope with nattrans.

Delimit Scope natiso_scope with natiso.

Delimit Scope isomorphism_scope with isomorphism.

Delimit Scope preorder_scope with preorder. *)

From Categories Require Import Essentials.Types.
(* Categories.Essentials.Types:
Global Set Primitive Projections.

Global Set Universe Polymorphism.

Global Unset Universe Minimization ToSet.

Inductive Empty : Type :=.

Hint Extern 1 =>
let tac := (repeat intros ?); match goal with [H : Empty |- _] => contradict H end in
match goal with
  | [|- context[Empty]] => tac
  | [H : context[Empty] |- _] => tac
end
.

Record prod (A B : Type) := {fst : A; snd : B}.

Arguments fst {_ _ } _.
Arguments snd {_ _ } _.
Arguments Build_prod {_ _ } _ _.

Notation "( X , Y )" := (Build_prod X Y).
Notation "X * Y" := (prod X Y) : type_scope. *)

From Categories Require Import Essentials.Facts_Tactics.
(* Categories.Essentials.Facts_Tactics:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.

Require Export Coq.Program.Tactics.
Require Export Coq.Program.Equality.
Require Export Coq.Logic.FunctionalExtensionality.
Require Export Coq.Logic.ProofIrrelevance.

Definition equal_f : âˆ€ {A B : Type} {f g : A â†’ B}, f = g â†’ âˆ€ x : A, f x = g x.

Definition f_equal : âˆ€ (A B : Type) (f : A â†’ B) (x y : A), x = y â†’ f x = f y.

Arguments f_equal [_ _] _ [_ _] _.

Ltac basic_simpl :=
  let simpl_prod _ :=
      match goal with
        [H : prod _ _ |- _] =>
        let H1 := fresh H "1" in
        let H2 := fresh H "2" in
        destruct H as [H1 H2]
      end
  in
  let simpl_sig _ :=
      match goal with
        [H : @sig _ _ |- _] =>
        let H1 := fresh H "1" in
        let H2 := fresh H "2" in
        destruct H as [H1 H2]
      end
  in
  let basic_simpl_helper _ :=
      cbn in *; intros;
        repeat simpl_prod tt;
        repeat simpl_sig tt
  in
  repeat basic_simpl_helper tt
.

Global Obligation Tactic := basic_simpl; auto.

Ltac PIR :=
  let pir_helper _ :=
      match goal with
      |[H : ?A, H' : ?A|- _] =>
       match type of A with
       | Prop =>
         destruct (proof_irrelevance _ H H')
       end
      end
  in
  repeat pir_helper tt
.

Ltac ElimEq := repeat match goal with [H : _ = _|- _] => destruct H end.

Hint Extern 1 => progress ElimEq.

Ltac cbn_rewrite W :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite H; clear H
.

Ltac cbn_rewrite_in W V :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite H in V; clear H
.

Ltac cbn_rewrite_back W :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite <- H; clear H
.

Ltac cbn_rewrite_back_in W V :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite <- H in V; clear H
.

Tactic Notation "cbn_rewrite" constr(W) := cbn_rewrite W.
Tactic Notation "cbn_rewrite" constr(W) "in" hyp_list(V) := cbn_rewrite_in W V.
Tactic Notation "cbn_rewrite" "<-" constr(W) := cbn_rewrite_back W.
Tactic Notation "cbn_rewrite" "<-" constr(W) "in" hyp_list(V) := cbn_rewrite_back_in W V.

Lemma sig_proof_irrelevance {A : Type} (P : A â†’ Prop) (X Y : sig P) : proj1_sig X = proj1_sig Y â†’ X = Y.

Hint Extern 2 (exist ?A _ _ = exist ?A _ _) => apply sig_proof_irrelevance.

Ltac FunExt :=
progress (
    repeat (
        match goal with
          [|- _ = _] =>
          let x := fresh "x" in
          extensionality x
        end
      )
  )
.

Hint Extern 1 => FunExt.

Lemma pair_eq (A B : Type) (a b : A * B) : fst a = fst b â†’ snd a = snd b â†’ a = b.

Hint Resolve pair_eq.

Ltac revert_clearbody_all :=
 repeat lazymatch goal with H:_ |- _ => try clearbody H; revert H end.

Ltac hyp_stack :=
 constr:(ltac:(revert_clearbody_all;constructor) : True).

Ltac next_hyp hs step last :=
 lazymatch hs with (?hs' ?H) => step H hs' | _ => last end.

Tactic Notation "dohyps" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := tac H; next_hyp hs step idtac in
 next_hyp hs step idtac.

Tactic Notation "dohyps" "reverse" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := next_hyp hs step idtac; tac H in
 next_hyp hs step idtac.

Tactic Notation "do1hyp" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := tac H + next_hyp hs step fail in
 next_hyp hs step fail.

Tactic Notation "do1hyp" "reverse" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := next_hyp hs step fail + tac H in
 next_hyp hs step fail. *)

From Categories Require Import Category.Main.
(* Categories.Category.Main:
From Categories Require Export Category.Category.
From Categories Require Export Category.Morph.
From Categories Require Export Category.Opposite.
From Categories Require Export Category.SubCategory.
From Categories Require Export Category.Composable_Chain. *)

From Categories Require Import Basic_Cons.CCC.
(* Categories.Basic_Cons.CCC:
From Categories Require Import Essentials.Notations.
From Categories Require Import Category.Main.
From Categories Require Export Basic_Cons.Terminal.
From Categories Require Export Basic_Cons.Product.
From Categories Require Export Basic_Cons.Exponential.
From Categories Require Export Basic_Cons.Exponential_Functor.

Class CCC (C : Category) : Type :=
{
  CCC_term : (ðŸ™_ C)%object;
  CCC_HP : Has_Products C;
  CCC_HEXP : Has_Exponentials C
}.

Arguments CCC_term _ {_}, {_ _}.
Arguments CCC_HP _ {_} _ _, {_ _} _ _.
Arguments CCC_HEXP _ {_} _ _, {_ _} _ _.

Existing Instances CCC_term CCC_HP CCC_HEXP. *)

From Categories Require Import Coq_Cats.Type_Cat.Type_Cat.
(* Categories.Coq_Cats.Type_Cat.Type_Cat:
From Categories Require Import Category.Main.
From Categories Require Import Coq_Cats.Coq_Cat.

Program Definition Type_Cat : Category := Coq_Cat Type. *)



Program Instance unit_Type_term : (ðŸ™_ Type_Cat)%object :=

{

  terminal := unit;

  t_morph := fun _ _=> tt

}.



Next Obligation. 

Proof.

  extensionality x.

  destruct (f x); destruct (g x); reflexivity.

Qed.



Local Notation "A Ã— B" := (@Product Type_Cat A B) : object_scope.



Program Definition prod_Product (A B : Type) : (A Ã— B)%object :=

{|

  product := (A * B)%type;

  Pi_1 := fst;

  Pi_2 := snd;

  Prod_morph_ex := fun p x y z => (x z, y z)

|}.



Next Obligation. 

Proof.

  extensionality x.

  repeat

    match goal with

      [H : _ = _ |- _] =>

      apply (fun p => equal_f p x) in H

    end.

  basic_simpl.  

  destruct (f x); destruct (g x); cbn in *; subst; trivial.

Qed.



Program Instance Type_Cat_Has_Products : Has_Products Type_Cat := prod_Product.



Program Definition fun_exp (A B : Type_Cat) : (A â‡‘ B)%object :=

{|

  exponential := A -> B;

  eval := fun x => (fst x) (snd x);

  Exp_morph_ex := fun h z u v=>  z (u, v)

|}.



Next Obligation. 

Proof.

  extensionality a; extensionality x.

  repeat

    match goal with

      [H : _ = _ |- _] =>

      apply (fun p => equal_f p (a, x)) in H

    end.

  transitivity (f (a, x)); auto.

Qed.



Program Instance Type_Cat_Has_Exponentials : Has_Exponentials Type_Cat := fun_exp.



Program Instance Type_Cat_CCC : CCC Type_Cat.

