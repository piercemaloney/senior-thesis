From Categories Require Import Essentials.Notations.
(* Categories.Essentials.Notations:
Notation "∀ x .. y , P" := (forall x, .. (forall y, P) ..)
                             (at level 200, x binder, y binder, right associativity) : type_scope.

Notation "∃ x .. y , P" := (exists x, .. (exists y, P) ..)
  (at level 200, x binder, y binder, right associativity) : type_scope.

Notation "x ∨ y" := (x \/ y) (at level 85, right associativity) : type_scope.

Notation "x ∧ y" := (x /\ y) (at level 80, right associativity) : type_scope.

Notation "x → y" := (x -> y)
  (at level 90, y at level 200, right associativity): type_scope.

Notation "x ↔ y" := (x <-> y) (at level 95, no associativity): type_scope.

Notation "¬ x" := (~x) (at level 75, right associativity) : type_scope.

Notation "x ≠ y" := (x <> y) (at level 70) : type_scope.

Notation "x ≤ y" := (le x y) (at level 70, no associativity).

Notation "x ≥ y" := (ge x y) (at level 70, no associativity).

Reserved Notation "C '^op'" (at level 50, no associativity).

Reserved Notation "a –≻ b" (at level 90, b at level 200, right associativity).

Reserved Notation "f '⁻¹'" (at level 50, no associativity).

Reserved Notation "a ≃ b" (at level 70, no associativity).

Reserved Notation "a ≃≃ b ::> C" (at level 70, no associativity).

Reserved Notation "f ∘ g" (at level 51, right associativity).

Reserved Notation "f '∘_h' g" (at level 51, right associativity).

Reserved Notation "a ≫–> b" (at level 100, no associativity).

Reserved Notation "a –≫ b" (at level 100, no associativity).

Reserved Notation "F '_o'" (at level 50, no associativity).

Reserved Notation "F '_a'" (at level 50, no associativity).

Reserved Notation "F '@_a'" (at level 50, no associativity).

Reserved Notation "F ⊣ G" (at level 100, no associativity).

Reserved Notation "F ⊣_hom G" (at level 100, no associativity).

Reserved Notation "F ⊣_ucu G" (at level 100, no associativity).

Reserved Notation "a × b" (at level 80, no associativity).

Reserved Notation "a ⇑ b" (at level 79, no associativity).

Reserved Notation "'Π' m" (at level 50, no associativity).

Reserved Notation "'Σ' m" (at level 50, no associativity).

Reserved Notation "'Π_' C ↓ m" (at level 50, no associativity).

Reserved Notation "'Σ_' C ↓ m" (at level 50, no associativity).

Delimit Scope category_scope with category.

Delimit Scope morphism_scope with morphism.

Delimit Scope object_scope with object.

Delimit Scope functor_scope with functor.

Delimit Scope nattrans_scope with nattrans.

Delimit Scope nattrans_scope with nattrans.

Delimit Scope natiso_scope with natiso.

Delimit Scope isomorphism_scope with isomorphism.

Delimit Scope preorder_scope with preorder. *)

From Categories Require Import Essentials.Types.
(* Categories.Essentials.Types:
Global Set Primitive Projections.

Global Set Universe Polymorphism.

Global Unset Universe Minimization ToSet.

Inductive Empty : Type :=.

Hint Extern 1 =>
let tac := (repeat intros ?); match goal with [H : Empty |- _] => contradict H end in
match goal with
  | [|- context[Empty]] => tac
  | [H : context[Empty] |- _] => tac
end
.

Record prod (A B : Type) := {fst : A; snd : B}.

Arguments fst {_ _ } _.
Arguments snd {_ _ } _.
Arguments Build_prod {_ _ } _ _.

Notation "( X , Y )" := (Build_prod X Y).
Notation "X * Y" := (prod X Y) : type_scope. *)

From Categories Require Import Essentials.Facts_Tactics.
(* Categories.Essentials.Facts_Tactics:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.

Require Export Coq.Program.Tactics.
Require Export Coq.Program.Equality.
Require Export Coq.Logic.FunctionalExtensionality.
Require Export Coq.Logic.ProofIrrelevance.

Definition equal_f : ∀ {A B : Type} {f g : A → B}, f = g → ∀ x : A, f x = g x.

Definition f_equal : ∀ (A B : Type) (f : A → B) (x y : A), x = y → f x = f y.

Arguments f_equal [_ _] _ [_ _] _.

Ltac basic_simpl :=
  let simpl_prod _ :=
      match goal with
        [H : prod _ _ |- _] =>
        let H1 := fresh H "1" in
        let H2 := fresh H "2" in
        destruct H as [H1 H2]
      end
  in
  let simpl_sig _ :=
      match goal with
        [H : @sig _ _ |- _] =>
        let H1 := fresh H "1" in
        let H2 := fresh H "2" in
        destruct H as [H1 H2]
      end
  in
  let basic_simpl_helper _ :=
      cbn in *; intros;
        repeat simpl_prod tt;
        repeat simpl_sig tt
  in
  repeat basic_simpl_helper tt
.

Global Obligation Tactic := basic_simpl; auto.

Ltac PIR :=
  let pir_helper _ :=
      match goal with
      |[H : ?A, H' : ?A|- _] =>
       match type of A with
       | Prop =>
         destruct (proof_irrelevance _ H H')
       end
      end
  in
  repeat pir_helper tt
.

Ltac ElimEq := repeat match goal with [H : _ = _|- _] => destruct H end.

Hint Extern 1 => progress ElimEq.

Ltac cbn_rewrite W :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite H; clear H
.

Ltac cbn_rewrite_in W V :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite H in V; clear H
.

Ltac cbn_rewrite_back W :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite <- H; clear H
.

Ltac cbn_rewrite_back_in W V :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite <- H in V; clear H
.

Tactic Notation "cbn_rewrite" constr(W) := cbn_rewrite W.
Tactic Notation "cbn_rewrite" constr(W) "in" hyp_list(V) := cbn_rewrite_in W V.
Tactic Notation "cbn_rewrite" "<-" constr(W) := cbn_rewrite_back W.
Tactic Notation "cbn_rewrite" "<-" constr(W) "in" hyp_list(V) := cbn_rewrite_back_in W V.

Lemma sig_proof_irrelevance {A : Type} (P : A → Prop) (X Y : sig P) : proj1_sig X = proj1_sig Y → X = Y.

Hint Extern 2 (exist ?A _ _ = exist ?A _ _) => apply sig_proof_irrelevance.

Ltac FunExt :=
progress (
    repeat (
        match goal with
          [|- _ = _] =>
          let x := fresh "x" in
          extensionality x
        end
      )
  )
.

Hint Extern 1 => FunExt.

Lemma pair_eq (A B : Type) (a b : A * B) : fst a = fst b → snd a = snd b → a = b.

Hint Resolve pair_eq.

Ltac revert_clearbody_all :=
 repeat lazymatch goal with H:_ |- _ => try clearbody H; revert H end.

Ltac hyp_stack :=
 constr:(ltac:(revert_clearbody_all;constructor) : True).

Ltac next_hyp hs step last :=
 lazymatch hs with (?hs' ?H) => step H hs' | _ => last end.

Tactic Notation "dohyps" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := tac H; next_hyp hs step idtac in
 next_hyp hs step idtac.

Tactic Notation "dohyps" "reverse" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := next_hyp hs step idtac; tac H in
 next_hyp hs step idtac.

Tactic Notation "do1hyp" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := tac H + next_hyp hs step fail in
 next_hyp hs step fail.

Tactic Notation "do1hyp" "reverse" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := next_hyp hs step fail + tac H in
 next_hyp hs step fail. *)

From Categories Require Import Category.Main.
(* Categories.Category.Main:
From Categories Require Export Category.Category.
From Categories Require Export Category.Morph.
From Categories Require Export Category.Opposite.
From Categories Require Export Category.SubCategory.
From Categories Require Export Category.Composable_Chain. *)

From Categories Require Import Ext_Cons.Prod_Cat.Prod_Cat Ext_Cons.Prod_Cat.Operations.
(* Categories.Ext_Cons.Prod_Cat.Prod_Cat:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Main.
From Categories Require Import Cat.Cat.

Local Open Scope morphism_scope.

Local Obligation Tactic := idtac.

Program Definition Prod_Cat (C C' : Category) : Category :=
{|
  Obj := C * C';
              
  Hom :=
    fun a b =>
      (((fst a) –≻ (fst b)) * ((snd a) –≻ (snd b)))%type;

  compose :=
    fun a b c f g =>
      (((fst g) ∘ (fst f)), ((snd g) ∘ (snd f)))%morphism;

  id := fun c => (id, id)
|}.

Notation "C × D" := (Prod_Cat C D) : category_scope.

Local Obligation Tactic := basic_simpl; auto.

Theorem Prod_compose_id
        (C D : Category)
        (a b c : C) (d : D)
        (f : a –≻ b) (g : b –≻ c)
  : (g ∘ f, id d)%morphism =
    @compose (_ × _) (_, _) (_, _) (_, _) (f, id d) (g, id d).

Theorem Prod_id_compose
        (C D : Category)
        (a : C) (b c d : D)
        (f : b –≻ c) (g : c –≻ d)
  : (id a, g ∘ f)%morphism =
    @compose (_ × _) (_, _) (_, _) (_, _) (id a, f) (id a, g).

Theorem Prod_cross_compose
        (C D : Category)
        (a b : C) (c d : D)
        (f : a –≻ b) (g : c –≻ d)
  : @compose
      (_ × _) (_, _) (_, _) (_, _)
      (@id _ a, g) (f, @id _ d)
    = @compose
        (_ × _) (_, _) (_, _) (_, _)
        (f, @id _ c) (@id _ b, g)
.

Program Definition Cat_Proj1
        (C C' : Category) :
  ((C × C') –≻ C)%functor
  :=
    {|FO := fst; FA := fun _ _ f => fst f|}
.

Program Definition Cat_Proj2
        (C C' : Category) :
  ((C × C') –≻ C')%functor
  :=
    {|FO := snd; FA := fun _ _ f => snd f|}
. *)
(* Categories.Ext_Cons.Prod_Cat.Operations:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Main.
From Categories Require Import Cat.Cat.
From Categories Require Import Ext_Cons.Prod_Cat.Prod_Cat.

Local Obligation Tactic := idtac.

Local Open Scope functor_scope.

Program Definition Prod_Functor
        {C1 C2 C1' C2' : Category} (F : C1 –≻ C2) (F' : C1' –≻ C2')
  : (C1 × C1') –≻ (C2 × C2') :=
{|
  FO := fun a => (F _o (fst a), F' _o (snd a))%object;
  FA := fun _ _ f => (F _a (fst f), F' _a (snd f))%morphism
|}.

Definition Bi_Func_1 {Cx C1 C1' Cy : Category} (F : Cx –≻ C1)
           (F' : (C1 × C1') –≻ Cy)
  : (Cx × C1') –≻ Cy :=
  F' ∘ (Prod_Functor F (@Functor_id C1')).

Definition Bi_Func_2 {Cx C1 C1' Cy : Category} (F : Cx –≻ C1')
           (F' : (C1 × C1') –≻ Cy) : (C1 × Cx) –≻ Cy :=
  Functor_compose (Prod_Functor (@Functor_id C1) F) F'.

Local Hint Extern 2 => cbn.

Local Obligation Tactic := basic_simpl; do 2 auto.

Program Definition Fix_Bi_Func_1 {C1 C1' Cy : Category} (x : C1)
        (F : (C1 × C1') –≻ Cy)
  : C1' –≻ Cy :=
{|
  FO := fun a => (F _o (x, a))%object;
  FA := fun _ _ f => (F @_a (_, _) (_, _) (@id _ x, f))%morphism
|}.

Program Definition Fix_Bi_Func_2 {C1 C1' Cy : Category} (x : C1')
        (F : (C1 × C1') –≻ Cy)
  : C1 –≻ Cy :=
{|
  FO := fun a => (F _o (a, x))%object;
  FA := fun _ _ f => (F @_a (_, _) (_, _) (f, @id _ x))%morphism
|}.

Program Definition Diag_Func (C : Category) : C –≻ (C × C) :=
{|
  FO := fun a => (a, a);
  FA := fun _ _ f => (f, f);
  F_id := fun _ => eq_refl;
  F_compose := fun _ _ _ _ _ => eq_refl
|}.

Theorem Prod_Functor_Cat_Proj {C D D' : Category} (F : C –≻ (D × D')) :
  ((Prod_Functor ((Cat_Proj1 _ _) ∘ F) ((Cat_Proj2 _ _) ∘ F))
     ∘ (Diag_Func C))%functor = F.

Program Definition Twist_Func (C C' : Category) : (C × C') –≻ (C' × C) :=
{|
  FO := fun a => (snd a, fst a);
  FA := fun _ _ f => (snd f, fst f);
  F_id := fun _ => eq_refl;
  F_compose := fun _ _ _ _ _ => eq_refl
|}.

Section Twist_Prod_Func_Twist.
  Context {C C' : Category} (F : C –≻ C') {D D' : Category} (G : D –≻ D').

  Theorem Twist_Prod_Func_Twist :
    (((Twist_Func _ _) ∘ (Prod_Functor F G)) ∘ (Twist_Func _ _))%functor =
    Prod_Functor G F.

End Twist_Prod_Func_Twist.

Section Prod_Functor_compose.
  Context {C D E: Category} (F : C –≻ D) (G : D –≻ E)
          {C' D' E': Category} (F' : C' –≻ D') (G' : D' –≻ E').

  Theorem Prod_Functor_compose :
    ((Prod_Functor G G') ∘ (Prod_Functor F F') =
     Prod_Functor (G ∘ F) (G' ∘ F'))%functor.
                                   
End Prod_Functor_compose. *)

From Categories Require Import Functor.Main.
(* Categories.Functor.Main:
From Categories Require Export Functor.Functor.
From Categories Require Export Functor.Functor_Extender.
From Categories Require Export Functor.Functor_Image.
From Categories Require Export Functor.Functor_Ops.
From Categories Require Export Functor.Functor_Properties.
From Categories Require Export Functor.Const_Func.
From Categories Require Export Functor.Const_Func_Functor. *)

From Categories Require Import Functor.Representable.Hom_Func
(* Categories.Functor.Representable.Hom_Func:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Functor.
From Categories Require Import Coq_Cats.Type_Cat.Type_Cat.
From Categories Require Import Ext_Cons.Prod_Cat.Prod_Cat.

Program Definition Hom_Func (C : Category) : ((C^op × C) –≻ Type_Cat)%functor :=
{|
  FO := fun x => Hom C (fst x) (snd x);
  FA := fun x y f => fun g => compose C (fst f) ((@compose (C^op) _ _ _) (snd f) g)
|}. *)

        Functor.Representable.Hom_Func_Prop.

From Categories Require Import NatTrans.Main.
(* Categories.NatTrans.Main:
From Categories Require Export NatTrans.NatTrans.
From Categories Require Export NatTrans.Func_Cat.
From Categories Require Export NatTrans.NatIso.
From Categories Require Export NatTrans.Operations.
From Categories Require Export NatTrans.Morphisms. *)



Local Open Scope functor_scope.



Local Notation NID := NatTrans_id (only parsing).

Local Notation FCAT := Func_Cat (only parsing).



Notation Hom_Adj_Left C D F G :=

  ((Hom_Func D) ∘ (Prod_Functor (F^op) (@Functor_id D)))%functor (only parsing).



Notation Hom_Adj_Right C D F G :=

  ((Hom_Func C) ∘ (Prod_Functor (@Functor_id (C^op)) G))%functor (only parsing).



Local Obligation Tactic := idtac.



Section Adjunction.

  Context {C D : Category} (F : C –≻ D) (G : D –≻ C).



  Record Adjunct : Type :=

  {

    adj_unit : ((Functor_id C) –≻ (G ∘ F))%nattrans;

    

    adj_morph_ex {c : C} {d : D} (f : (c –≻ (G _o d)%object)%morphism) :

      ((F _o c)%object –≻ d)%morphism;

    

    adj_morph_com {c : C} {d : D} (f : (c –≻ (G _o d))%morphism%object) :

      f = ((G _a (adj_morph_ex f)) ∘ (Trans adj_unit c))%morphism;

    

    adj_morph_unique {c : C} {d : D} (f : (c –≻ (G _o d))%object%morphism)

                     (g h : ((F _o c) –≻ d)%morphism%object) :

      f = ((G _a g) ∘ (Trans adj_unit c))%morphism →

      f = ((G _a h) ∘ (Trans adj_unit c))%morphism →

      g = h

  }.



  Arguments adj_unit : clear implicits.

  Arguments adj_morph_ex _ {_ _} _.

  Arguments adj_morph_com _ {_ _} _.

  Arguments adj_morph_unique _ {_ _} _ _ _ _ _.



  Theorem Adjunct_eq_simplify (adj adj' : Adjunct) :

    adj_unit adj = @adj_unit adj' →

    @adj_morph_ex adj = @adj_morph_ex adj' → adj = adj'.

  Proof.

    destruct adj; destruct adj'; basic_simpl.

    ElimEq.

    PIR.

    reflexivity.

  Qed.



  Definition Hom_Adjunct :=

    (Hom_Adj_Left _ _ F G ≃ Hom_Adj_Right _ _ F G)%natiso.



  Record UCU_Adjunct :=

    {

      ucu_adj_unit : ((Functor_id C) –≻ (G ∘ F))%nattrans;

      

      ucu_adj_counit : ((F ∘ G) –≻ (Functor_id D))%nattrans;



      ucu_adj_left_id : ((NatTrans_from_compose_id _)

                           ∘ ((((ucu_adj_counit ∘_h (NID F))

                                  ∘ (NatTrans_Functor_assoc_sym _ _ _))

                                 ∘ ((NID F) ∘_h ucu_adj_unit))

                                ∘ (NatTrans_to_id_compose _)))%nattrans

                        = (NID F);

      

      ucu_adj_right_id : ((NatTrans_from_id_compose _)

                            ∘ (((((NID G) ∘_h ucu_adj_counit)

                                   ∘ (NatTrans_Functor_assoc _ _ _))

                                  ∘ (ucu_adj_unit ∘_h (NID G)))

                                 ∘ (NatTrans_to_compose_id _)))%nattrans

                         = (NID G)

    }.



  Arguments ucu_adj_unit : clear implicits.

  Arguments ucu_adj_counit : clear implicits.

  Arguments ucu_adj_left_id : clear implicits.

  Arguments ucu_adj_right_id : clear implicits.



  Local Notation "F ⊣ G" := (Adjunct) : functor_scope.

  Local Notation "F ⊣_hom G" := (Hom_Adjunct) : functor_scope.

  Local Notation "F ⊣_ucu G" := (UCU_Adjunct) : functor_scope.

  

  Section UCU_Adj_Adj.

    Context (Adj : (F ⊣_ucu G)%functor).



    Program Definition UCU_Adj_to_Adj : (F ⊣ G)%functor :=

      {|

        adj_unit := ucu_adj_unit Adj;

        adj_morph_ex :=

          fun _ _ h => ((Trans (ucu_adj_counit Adj) _) ∘ (F _a h))%morphism

      |}.



    Next Obligation.

    Proof.

      intros c d f; cbn.

      rewrite F_compose; rewrite assoc.

      cbn_rewrite <- (Trans_com (ucu_adj_unit Adj) f).

      rewrite assoc_sym.

      set (W := f_equal (fun w => Trans w d) (ucu_adj_right_id Adj));

        cbn in W; repeat rewrite F_id in W; simpl_ids in W; rewrite W.

      auto.

    Qed.      



    Next Obligation.

    Proof.

      intros c d f g h H1 H2; cbn in *.

      rewrite H1 in H2; clear H1.

      apply (f_equal (F _a)%morphism) in H2.

      do 2 rewrite F_compose in H2.

      apply (f_equal (fun w => compose w (Trans (ucu_adj_counit Adj) _))) in H2;

        cbn in H2.

      repeat rewrite assoc_sym in H2.

     cbn_rewrite (@Trans_com _ _ _ _ (ucu_adj_counit Adj) _ _ g) in H2.

      cbn_rewrite (@Trans_com _ _ _ _ (ucu_adj_counit Adj) _ _ h) in H2.

      repeat rewrite assoc in H2.

      set (W := f_equal (fun w => Trans w c) (ucu_adj_left_id Adj));

        cbn in W; repeat rewrite F_id in W; simpl_ids in W; rewrite W in H2;

        clear W.

      auto.

    Qed.



  End UCU_Adj_Adj.



  Section Adj_UCU_Adj.

    Context (Adj : (F ⊣ G)%functor).

    

    Program Definition Adj_to_UCU_Adj : (F ⊣_ucu G)%functor :=

      {|

        ucu_adj_unit := adj_unit Adj;

        ucu_adj_counit :=

          {|

            Trans := fun d => @adj_morph_ex Adj (G _o d) d id

          |}

      |}.



    Next Obligation.

    Proof.    

      intros d d' h; cbn.

      eapply (@adj_morph_unique Adj); [reflexivity|]; cbn.

      repeat rewrite F_compose.

      repeat rewrite assoc.

      cbn_rewrite <- (@Trans_com _ _ _ _ (adj_unit Adj) _ _ ((G @_a) d d' h)).

      cbn_rewrite <- (@adj_morph_com Adj (G _o d) d id).

      rewrite assoc_sym.

      cbn_rewrite <- (@adj_morph_com Adj (G _o d') d' id).

      auto.

    Qed.



    Next Obligation.

    Proof.

      symmetry.

      apply Adj_to_UCU_Adj_obligation_1.

    Qed.      



    Next Obligation.

    Proof.

      apply NatTrans_eq_simplify; extensionality x.

      cbn; simpl_ids.

      eapply (@adj_morph_unique Adj); [reflexivity|]; cbn.

      rewrite F_compose.

      rewrite F_id.

      rewrite assoc.

      cbn_rewrite <- (@Trans_com

                       _ _ _ _ (adj_unit Adj) _ _ (Trans (adj_unit Adj) x)). 

      rewrite assoc_sym.

      simpl_ids; trivial.

      symmetry.

      apply adj_morph_com.

    Qed.



    Next Obligation.

    Proof.

      apply NatTrans_eq_simplify; FunExt; cbn.

      repeat rewrite F_id; simpl_ids.

      symmetry.

      apply adj_morph_com.

    Qed.



  End Adj_UCU_Adj.

  

  Section Adj_Hom_Adj.

    Context (Adj : (F ⊣ G)%functor).



    Program Definition Adj_to_Hom_Adj_LR :

      ((Hom_Adj_Left _ _ F G) –≻ (Hom_Adj_Right _ _ F G))%nattrans :=

    {|

      Trans := fun c h => ((G _a h) ∘ (Trans (adj_unit Adj) _))%morphism

    |}.



    Next Obligation. 

      intros [c1 d1] [c2 d2] [h1 h2].

      extensionality x; cbn in *.

      repeat rewrite F_compose.

      change (G _a (F _a h1))%morphism with ((G ∘ F) _a h1)%morphism.

      repeat rewrite assoc.

      repeat refine (@f_equal _ _ (fun x => @compose _ _ _ _ x _) _ _ _).

      symmetry.

      apply (Trans_com (adj_unit Adj)). 

    Qed.



    Next Obligation. 

    Proof.

      symmetry.

      apply Adj_to_Hom_Adj_LR_obligation_1.

    Qed.



    Program Definition Adj_to_Hom_Adj_RL :

      ((Hom_Adj_Right _ _ F G) –≻ (Hom_Adj_Left _ _ F G))%nattrans :=

    {|

      Trans := fun c h => adj_morph_ex Adj h

    |}.



    Next Obligation.

      intros [c1 d1] [c2 d2] [h1 h2].

      extensionality x; cbn in *.

      eapply adj_morph_unique; eauto.

      simpl_ids.

      rewrite <- adj_morph_com.

      repeat rewrite F_compose.

      repeat rewrite assoc.

      refine (@f_equal _ _ (fun x => @compose _ _ _ _ x _) _ _ _).

      change (G _a (F _a h1))%morphism with ((G ∘ F) _a h1)%morphism.

      refine (eq_trans _ (@f_equal

                            _ _ (fun x => @compose _ _ _ _ x _)

                            _ _ (Trans_com (adj_unit Adj) h1))).

      rewrite assoc_sym.

      rewrite <- adj_morph_com; trivial.

    Qed.



    Next Obligation. 

    Proof.

      symmetry.

      apply Adj_to_Hom_Adj_RL_obligation_1.

    Qed.



    Program Definition Adj_to_Hom_Adj : (F ⊣_hom G)%functor :=

      NatIso _ _ Adj_to_Hom_Adj_LR Adj_to_Hom_Adj_RL _ _.

    

    Next Obligation.

      basic_simpl; FunExt.

      etransitivity; [symmetry; apply adj_morph_com| trivial].

    Qed.



    Next Obligation.

      basic_simpl; FunExt.

      eapply adj_morph_unique; eauto.

      rewrite <- adj_morph_com; trivial.

    Qed.



  End Adj_Hom_Adj.



  Section Hom_Adj_Adj.

    Context (Adj : (F ⊣_hom G)%functor).



    Program Definition Hom_Adj_to_Adj : (F ⊣ G)%functor :=

      {|

        adj_unit :=

          {| Trans := fun c => Trans (iso_morphism Adj) (c, F _o c)%object id |};

        adj_morph_ex := fun _ _ f => Trans (inverse_morphism Adj) (_, _) f

      |}.

    

    Next Obligation.

      intros c c' h.

      set (H := @equal_f

                  _ _ _ _ (@Trans_com

                             _ _ _ _ (iso_morphism Adj) (c', F _o c')%object

                             (c, F _o c')%object (h, id)) id).

      set (H' := (@equal_f

                    _ _ _ _ (@Trans_com

                               _ _ _ _ (iso_morphism Adj) (c, F _o c)%object

                               (c, F _o c')%object (id c, F _a h)%morphism) id)

          ).

      cbn in *.

      rewrite F_id in H.

      rewrite F_id in H'.

      simpl_ids in H.

      simpl_ids in H'.

      rewrite <- H; trivial.

    Qed.



    Next Obligation.

    Proof.

      symmetry.

      apply Hom_Adj_to_Adj_obligation_1.

    Qed.



    Next Obligation.

      intros c d f; cbn.

      set (H := @equal_f

                  _ _ _ _ (@Trans_com

                             _ _ _ _ (iso_morphism Adj)

                             (c, F _o c)%object (c, d)

                             (id, Trans (inverse_morphism Adj) (c, d) f)) id);

        cbn in H.

      rewrite F_id in H.

      simpl_ids in H.

      etransitivity; [|eassumption].

      change (f = Trans (NatTrans_compose

                           (inverse_morphism Adj) (iso_morphism Adj)) (_, _) f).

      set (H' := right_inverse Adj); cbn in H'.

      rewrite H'.

      cbn; auto.

    Qed.



    Next Obligation.

      intros c d f g h H1 H2.

      cbn in *.

      cut (Trans (NatTrans_compose

                    (iso_morphism Adj) (inverse_morphism Adj)) (_, _) g

           = Trans (NatTrans_compose

                      (iso_morphism Adj) (inverse_morphism Adj)) (_, _) h);

        [intros H'|].

      + set (H'' := left_inverse Adj); cbn in H''.

        rewrite H'' in H'.

        cbn in H'; auto.

      + set (Hg := @equal_f

                     _ _ _ _ (@Trans_com

                                _ _ _ _ (iso_morphism Adj) (c, F _o c)%object

                                (c, d) (id, g)) id); cbn in Hg;

        rewrite F_id in Hg; simpl_ids in Hg.

        set (Hh := @equal_f

                     _ _ _ _ (@Trans_com

                                _ _ _ _ (iso_morphism Adj) (c, F _o c)%object

                                (c, d) (id, h)) id); cbn in Hh;

        rewrite F_id in Hh; simpl_ids in Hh.

        cbn.

        rewrite Hg, Hh; rewrite <- H1, <- H2; trivial.

    Qed.        



  End Hom_Adj_Adj.



End Adjunction.



Arguments adj_unit {_ _ _ _} _ : assert.

Arguments adj_morph_ex {_ _ _ _} _ {_ _} _.

Arguments adj_morph_com {_ _ _ _} _ {_ _} _.

Arguments adj_morph_unique {_ _ _ _} _ {_ _} _ _ _ _ _.



Arguments ucu_adj_unit {_ _ _ _} _.

Arguments ucu_adj_counit {_ _ _ _} _.

Arguments ucu_adj_left_id {_ _ _ _} _.

Arguments ucu_adj_right_id {_ _ _ _} _.



Arguments Adj_to_Hom_Adj {_ _ _ _} _.



Arguments Hom_Adj_to_Adj {_ _ _ _} _.



Notation "F ⊣ G" := (Adjunct F G) : functor_scope.

Notation "F ⊣_hom G" := (Hom_Adjunct F G) : functor_scope.

Notation "F ⊣_ucu G" := (UCU_Adjunct F G) : functor_scope.

