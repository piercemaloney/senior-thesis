From Categories Require Import Essentials.Notations.
(* Categories.Essentials.Notations:
Notation "∀ x .. y , P" := (forall x, .. (forall y, P) ..)
                             (at level 200, x binder, y binder, right associativity) : type_scope.

Notation "∃ x .. y , P" := (exists x, .. (exists y, P) ..)
  (at level 200, x binder, y binder, right associativity) : type_scope.

Notation "x ∨ y" := (x \/ y) (at level 85, right associativity) : type_scope.

Notation "x ∧ y" := (x /\ y) (at level 80, right associativity) : type_scope.

Notation "x → y" := (x -> y)
  (at level 90, y at level 200, right associativity): type_scope.

Notation "x ↔ y" := (x <-> y) (at level 95, no associativity): type_scope.

Notation "¬ x" := (~x) (at level 75, right associativity) : type_scope.

Notation "x ≠ y" := (x <> y) (at level 70) : type_scope.

Notation "x ≤ y" := (le x y) (at level 70, no associativity).

Notation "x ≥ y" := (ge x y) (at level 70, no associativity).

Reserved Notation "C '^op'" (at level 50, no associativity).

Reserved Notation "a –≻ b" (at level 90, b at level 200, right associativity).

Reserved Notation "f '⁻¹'" (at level 50, no associativity).

Reserved Notation "a ≃ b" (at level 70, no associativity).

Reserved Notation "a ≃≃ b ::> C" (at level 70, no associativity).

Reserved Notation "f ∘ g" (at level 51, right associativity).

Reserved Notation "f '∘_h' g" (at level 51, right associativity).

Reserved Notation "a ≫–> b" (at level 100, no associativity).

Reserved Notation "a –≫ b" (at level 100, no associativity).

Reserved Notation "F '_o'" (at level 50, no associativity).

Reserved Notation "F '_a'" (at level 50, no associativity).

Reserved Notation "F '@_a'" (at level 50, no associativity).

Reserved Notation "F ⊣ G" (at level 100, no associativity).

Reserved Notation "F ⊣_hom G" (at level 100, no associativity).

Reserved Notation "F ⊣_ucu G" (at level 100, no associativity).

Reserved Notation "a × b" (at level 80, no associativity).

Reserved Notation "a ⇑ b" (at level 79, no associativity).

Reserved Notation "'Π' m" (at level 50, no associativity).

Reserved Notation "'Σ' m" (at level 50, no associativity).

Reserved Notation "'Π_' C ↓ m" (at level 50, no associativity).

Reserved Notation "'Σ_' C ↓ m" (at level 50, no associativity).

Delimit Scope category_scope with category.

Delimit Scope morphism_scope with morphism.

Delimit Scope object_scope with object.

Delimit Scope functor_scope with functor.

Delimit Scope nattrans_scope with nattrans.

Delimit Scope nattrans_scope with nattrans.

Delimit Scope natiso_scope with natiso.

Delimit Scope isomorphism_scope with isomorphism.

Delimit Scope preorder_scope with preorder. *)

From Categories Require Import Essentials.Types.
(* Categories.Essentials.Types:
Global Set Primitive Projections.

Global Set Universe Polymorphism.

Global Unset Universe Minimization ToSet.

Inductive Empty : Type :=.

Hint Extern 1 =>
let tac := (repeat intros ?); match goal with [H : Empty |- _] => contradict H end in
match goal with
  | [|- context[Empty]] => tac
  | [H : context[Empty] |- _] => tac
end
.

Record prod (A B : Type) := {fst : A; snd : B}.

Arguments fst {_ _ } _.
Arguments snd {_ _ } _.
Arguments Build_prod {_ _ } _ _.

Notation "( X , Y )" := (Build_prod X Y).
Notation "X * Y" := (prod X Y) : type_scope. *)

From Categories Require Import Essentials.Facts_Tactics.
(* Categories.Essentials.Facts_Tactics:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.

Require Export Coq.Program.Tactics.
Require Export Coq.Program.Equality.
Require Export Coq.Logic.FunctionalExtensionality.
Require Export Coq.Logic.ProofIrrelevance.

Definition equal_f : ∀ {A B : Type} {f g : A → B}, f = g → ∀ x : A, f x = g x.

Definition f_equal : ∀ (A B : Type) (f : A → B) (x y : A), x = y → f x = f y.

Arguments f_equal [_ _] _ [_ _] _.

Ltac basic_simpl :=
  let simpl_prod _ :=
      match goal with
        [H : prod _ _ |- _] =>
        let H1 := fresh H "1" in
        let H2 := fresh H "2" in
        destruct H as [H1 H2]
      end
  in
  let simpl_sig _ :=
      match goal with
        [H : @sig _ _ |- _] =>
        let H1 := fresh H "1" in
        let H2 := fresh H "2" in
        destruct H as [H1 H2]
      end
  in
  let basic_simpl_helper _ :=
      cbn in *; intros;
        repeat simpl_prod tt;
        repeat simpl_sig tt
  in
  repeat basic_simpl_helper tt
.

Global Obligation Tactic := basic_simpl; auto.

Ltac PIR :=
  let pir_helper _ :=
      match goal with
      |[H : ?A, H' : ?A|- _] =>
       match type of A with
       | Prop =>
         destruct (proof_irrelevance _ H H')
       end
      end
  in
  repeat pir_helper tt
.

Ltac ElimEq := repeat match goal with [H : _ = _|- _] => destruct H end.

Hint Extern 1 => progress ElimEq.

Ltac cbn_rewrite W :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite H; clear H
.

Ltac cbn_rewrite_in W V :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite H in V; clear H
.

Ltac cbn_rewrite_back W :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite <- H; clear H
.

Ltac cbn_rewrite_back_in W V :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite <- H in V; clear H
.

Tactic Notation "cbn_rewrite" constr(W) := cbn_rewrite W.
Tactic Notation "cbn_rewrite" constr(W) "in" hyp_list(V) := cbn_rewrite_in W V.
Tactic Notation "cbn_rewrite" "<-" constr(W) := cbn_rewrite_back W.
Tactic Notation "cbn_rewrite" "<-" constr(W) "in" hyp_list(V) := cbn_rewrite_back_in W V.

Lemma sig_proof_irrelevance {A : Type} (P : A → Prop) (X Y : sig P) : proj1_sig X = proj1_sig Y → X = Y.

Hint Extern 2 (exist ?A _ _ = exist ?A _ _) => apply sig_proof_irrelevance.

Ltac FunExt :=
progress (
    repeat (
        match goal with
          [|- _ = _] =>
          let x := fresh "x" in
          extensionality x
        end
      )
  )
.

Hint Extern 1 => FunExt.

Lemma pair_eq (A B : Type) (a b : A * B) : fst a = fst b → snd a = snd b → a = b.

Hint Resolve pair_eq.

Ltac revert_clearbody_all :=
 repeat lazymatch goal with H:_ |- _ => try clearbody H; revert H end.

Ltac hyp_stack :=
 constr:(ltac:(revert_clearbody_all;constructor) : True).

Ltac next_hyp hs step last :=
 lazymatch hs with (?hs' ?H) => step H hs' | _ => last end.

Tactic Notation "dohyps" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := tac H; next_hyp hs step idtac in
 next_hyp hs step idtac.

Tactic Notation "dohyps" "reverse" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := next_hyp hs step idtac; tac H in
 next_hyp hs step idtac.

Tactic Notation "do1hyp" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := tac H + next_hyp hs step fail in
 next_hyp hs step fail.

Tactic Notation "do1hyp" "reverse" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := next_hyp hs step fail + tac H in
 next_hyp hs step fail. *)

From Categories Require Import Category.Main.
(* Categories.Category.Main:
From Categories Require Export Category.Category.
From Categories Require Export Category.Morph.
From Categories Require Export Category.Opposite.
From Categories Require Export Category.SubCategory.
From Categories Require Export Category.Composable_Chain. *)

From Categories Require Import Functor.Main.
(* Categories.Functor.Main:
From Categories Require Export Functor.Functor.
From Categories Require Export Functor.Functor_Extender.
From Categories Require Export Functor.Functor_Image.
From Categories Require Export Functor.Functor_Ops.
From Categories Require Export Functor.Functor_Properties.
From Categories Require Export Functor.Const_Func.
From Categories Require Export Functor.Const_Func_Functor. *)

From Categories Require Import Coq_Cats.Type_Cat.Type_Cat Coq_Cats.Type_Cat.CCC.
(* Categories.Coq_Cats.Type_Cat.Type_Cat:
From Categories Require Import Category.Main.
From Categories Require Import Coq_Cats.Coq_Cat.

Program Definition Type_Cat : Category := Coq_Cat Type. *)
(* Categories.Coq_Cats.Type_Cat.CCC:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.

Local Notation "A × B" := (@Product Type_Cat A B) : object_scope.

Program Definition prod_Product (A B : Type) : (A × B)%object :=
{|
  product := (A * B)%type;
  Pi_1 := fst;
  Pi_2 := snd;
  Prod_morph_ex := fun p x y z => (x z, y z)
|}.

Program Instance Type_Cat_Has_Products : Has_Products Type_Cat := prod_Product.

Program Definition fun_exp (A B : Type_Cat) : (A ⇑ B)%object :=
{|
  exponential := A -> B;
  eval := fun x => (fst x) (snd x);
  Exp_morph_ex := fun h z u v=>  z (u, v)
|}.

Program Instance Type_Cat_Has_Exponentials : Has_Exponentials Type_Cat := fun_exp.

Program Instance Type_Cat_CCC : CCC Type_Cat. *)

From Categories Require Import NatTrans.NatTrans NatTrans.Func_Cat.
(* Categories.NatTrans.NatTrans:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Functor.
From Categories Require Import Cat.Cat.

Section NatTrans.
  Context {C C' : Category}.

  Record NatTrans (F F' : (C –≻ C')%functor) :=
    {
      Trans (c : C) : ((F _o c) –≻ (F' _o c))%object%morphism;
      Trans_com {c c' : C} (h : (c –≻ c')%morphism) :
        ((Trans c') ∘ F _a h = F' _a h ∘ (Trans c))%morphism;
      Trans_com_sym {c c' : C} (h : (c –≻ c')%morphism) :
        (F' _a h ∘ (Trans c) = (Trans c') ∘ F _a h)%morphism
    }.

  Notation "F –≻ F'" := (NatTrans F F') : nattrans_scope.

  Lemma NatTrans_eq_simplify {F F' : (C –≻ C')%functor}
        (N N' : (F –≻ F')%nattrans) : (@Trans _ _ N) = (@Trans _ _ N') -> N = N'.

End NatTrans.

Arguments Trans {_ _ _ _} _ _.
Arguments Trans_com {_ _ _ _} _ {_ _} _.
Arguments Trans_com_sym {_ _ _ _} _ {_ _} _.

Bind Scope nattrans_scope with NatTrans.

Notation "F –≻ F'" := (NatTrans F F') : nattrans_scope.

Local Open Scope nattrans_scope.

Section NatTrans_Compose.
  Context {C C' : Category}.
  
  Program Definition NatTrans_compose {F F' F'' : (C –≻ C')%functor}
          (tr : F –≻ F') (tr' : F' –≻ F'') : (F –≻ F'')%nattrans :=
    {|
      Trans := fun c : Obj => ((Trans tr' c) ∘ (Trans tr c)) % morphism
    |}.

End NatTrans_Compose.

Notation "N ∘ N'" := (NatTrans_compose N' N) : nattrans_scope.

Section NatTrans_Props.
  Context {C C' : Category}.
  
  Theorem NatTrans_compose_assoc {F G H I : (C –≻ C')%functor} (N : F –≻ G)
          (N' : G –≻ H) (N'' : H –≻ I)
    : ((N'' ∘ N') ∘ N = N'' ∘ (N' ∘ N))%nattrans
  .

  Program Definition NatTrans_id (F : (C –≻ C')%functor) : F –≻ F :=
    {|
      Trans := fun x : Obj => id
    |}.

  Theorem NatTrans_id_unit_left {F G : (C –≻ C')%functor} (N : F –≻ G)
    : (NatTrans_id G) ∘ N = N.

  Theorem NatTrans_id_unit_right {F G : (C –≻ C')%functor} (N : F –≻ G)
    : N ∘ (NatTrans_id F) = N.
  
End NatTrans_Props.

Hint Resolve NatTrans_eq_simplify. *)
(* Categories.NatTrans.Func_Cat:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Functor Functor.Functor_Ops.
From Categories Require Import Cat.Cat.
From Categories Require Import NatTrans.NatTrans NatTrans.Operations.

Program Definition Func_Cat (C C' : Category) : Category :=
{|
  Obj := (C –≻ C')%functor;

  Hom := NatTrans;

  compose := @NatTrans_compose _ _;

  id := @NatTrans_id _ _;

  assoc := fun _ _ _ _ _ _ _ => @NatTrans_compose_assoc _ _ _ _ _ _ _ _ _;
             
  assoc_sym :=
    fun _ _ _ _ _ _ _ => eq_sym (@NatTrans_compose_assoc _ _ _ _ _ _ _ _ _);

  id_unit_right := @NatTrans_id_unit_right _ _;
  
  id_unit_left := @NatTrans_id_unit_left _ _
|}.

Section Opposite_Func_Cat.
  Context (C D : Category).

  Program Definition Op_Func_Cat_to_Func_Cat_Op
    : ((Func_Cat C D)^op –≻ (Func_Cat (C^op) (D^op)))%functor :=
    {|
      FO := Opposite_Functor;
      FA := fun _ _ => Opposite_NatTrans;
      F_id := fun _ => NatTrans_id_Op _;
      F_compose := fun _ _ _ _ _ => NatTrans_compose_Op _ _ 
    |}.

  Program Definition Func_Cat_Op_to_Op_Func_Cat
    : ((Func_Cat (C^op) (D^op)) –≻ (Func_Cat C D)^op)%functor :=
    {|
      FO := Opposite_Functor;
      FA := fun _ _ => Opposite_NatTrans;
      F_id := fun F => NatTrans_id_Op F;
      F_compose := fun _ _ _ N N' => NatTrans_compose_Op N N'
    |}.
  
  Program Definition Func_Cat_Op_Iso
    : ((((Func_Cat C D)^op)%category)
         ≃≃ (Func_Cat (C^op) (D^op)) ::> Cat) %isomorphism :=
    {|
      iso_morphism := Op_Func_Cat_to_Func_Cat_Op;
      inverse_morphism := Func_Cat_Op_to_Op_Func_Cat
    |}.

End Opposite_Func_Cat. *)

From Categories Require Import Basic_Cons.Exponential.
(* Categories.Basic_Cons.Exponential:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Ext_Cons.Prod_Cat.Prod_Cat.
From Categories Require Import Functor.Main.
From Categories Require Import Basic_Cons.Product.

Local Open Scope morphism_scope.

Record Exponential {C : Category} {HP : Has_Products C} (c d : Obj) : Type :=
{
  exponential : C;

  eval : ((×ᶠⁿᶜ C) _o (exponential, c))%object –≻ d;

  Exp_morph_ex : ∀ (z : C), (((×ᶠⁿᶜ C) _o (z, c))%object –≻ d) → (z –≻ exponential);

  Exp_morph_com : ∀ (z : C) (f : ((×ᶠⁿᶜ C) _o (z, c))%object –≻ d),
      f = (eval ∘ ((×ᶠⁿᶜ C) @_a (_, _) (_, _) (Exp_morph_ex z f, id c)))%morphism;

  Exp_morph_unique : ∀ (z : C) (f : ((×ᶠⁿᶜ C) _o (z, c))%object –≻ d)
                       (u u' : z –≻ exponential),
      f = (eval ∘ ((×ᶠⁿᶜ C) @_a (_, _) (_, _) (u, id c)))%morphism →
      f = (eval ∘ ((×ᶠⁿᶜ C) @_a (_, _) (_, _) (u', id c)))%morphism →
      u = u'
}.

Coercion exponential : Exponential >-> Obj.

Arguments Exponential _ {_} _ _, {_ _} _ _.

Arguments exponential {_ _ _ _} _, {_ _} _ _ {_}.
Arguments eval {_ _ _ _} _, {_ _} _ _ {_}.
Arguments Exp_morph_ex {_ _ _ _} _ _ _, {_ _} _ _ {_} _ _.
Arguments Exp_morph_com {_ _ _ _} _ _ _, {_ _} _ _ {_} _ _.
Arguments Exp_morph_unique {_ _ _ _} _ _ _ _ _ _ _, {_ _} _ _ {_} _ _ _ _ _ _.

Notation "a ⇑ b" := (Exponential a b) : object_scope.

Theorem Exponential_iso {C : Category} {HP : Has_Products C} (c d : C)
        (E E' : (c ⇑ d)%object) : (E ≃ E')%isomorphism.

Definition Has_Exponentials (C : Category) {HP : Has_Products C} :=
  ∀ a b, (a ⇑ b)%object.

Existing Class Has_Exponentials.

Section Curry_UnCurry.
  Context (C : Category) {HP : Has_Products C} {HE : Has_Exponentials C}.

  Definition curry :
    forall {a b c : C},
      (((×ᶠⁿᶜ C) _o (a, b))%object –≻ c) → (a –≻ (HE b c)) :=
    fun {a b c : C} (f : ((×ᶠⁿᶜ C) _o (a, b))%object –≻ c) =>
      Exp_morph_ex (HE b c) _ f.

  Definition uncurry : forall {a b c : C},
      (a –≻ (HE b c)) → (((×ᶠⁿᶜ C) _o (a, b))%object –≻ c) :=
    fun {a b c : C} (f : a –≻ (HE b c)) =>
      ((eval (HE b c)) ∘ ((×ᶠⁿᶜ C) @_a (_, _) (_, _) (f, id C b)))%morphism.

  Section inversion.
    Context {a b c : C}.

    Theorem curry_uncurry (f : a –≻ (HE b c)) : curry (uncurry f) = f.

    Theorem uncurry_curry (f : ((×ᶠⁿᶜ C) _o (a, b))%object –≻ c) :
      uncurry (curry f) = f.

  End inversion.

  Section injectivity.
    Context {a b c : C}.

    Theorem curry_injective (f g : ((×ᶠⁿᶜ C) _o (a, b))%object –≻ c) :
      curry f = curry g → f = g.

    Theorem uncurry_injective (f g : a –≻ (HE b c)) :
      uncurry f = uncurry g → f = g.

  End injectivity.

  Section curry_compose.
    Context {a b c : C}.

    Lemma curry_compose (f : ((×ᶠⁿᶜ C) _o (a, b))%object –≻ c)
          {z : C} (g : z –≻ a)
      : (curry f) ∘ g = curry (f ∘ (Prod_morph_ex _ _ (g ∘ Pi_1) Pi_2)).

  End curry_compose.

End Curry_UnCurry. *)

From Categories Require Import PreSheaf.PreSheaf PreSheaf.Product.
(* Categories.PreSheaf.PreSheaf:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Main.
From Categories Require Import Coq_Cats.Type_Cat.Type_Cat.
From Categories Require Import NatTrans.NatTrans NatTrans.Func_Cat.

Definition PreSheaf (C : Category) := Functor (C^op) Type_Cat.

Definition PShCat (C : Category) := Func_Cat (C^op) Type_Cat. *)
(* Categories.PreSheaf.Product:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Main.
From Categories Require Import Coq_Cats.Type_Cat.Type_Cat Coq_Cats.Type_Cat.CCC.
From Categories Require Import NatTrans.NatTrans NatTrans.Func_Cat.
From Categories Require Import Basic_Cons.Product.
From Categories Require Import PreSheaf.PreSheaf.

Section Product.
  Context (C : Category) (F G : PShCat C).

  Local Hint Extern 1 =>
  match goal with
    [F : (_ ^op –≻ Type_Cat)%functor |- _] => rewrite (F_id F)
  end.
  Local Hint Extern 1 =>
  match goal with
    [F : (_ ^op –≻ Type_Cat)%functor |- context [(F _a (?f ∘ ?g))%morphism]] =>
    cbn_rewrite (F_compose F f g)
  end.

  Program Definition pointwise_product_psh : PShCat C :=
    {|
      FO := fun x => ((F _o x) * (G _o x))%object%type;
      FA := fun _ _ f u => (F _a f (fst u), G _a f (snd u))%morphism%object
    |}.
    
  Local Hint Extern 1 =>
  repeat
    match goal with
      [f : (?p –≻ _)%nattrans,
           h : (_ –≻ _)%morphism, c : _, x : (?p _o)%object _ |- _] =>
      cbn_rewrite (equal_f (Trans_com f h) x)
    end.
  
  Program Definition PSh_Product : (F × G)%object :=
    {|
      product := pointwise_product_psh;
      Pi_1 := {| Trans := fun _ => fst |};
      Pi_2 := {| Trans := fun _ => snd |};
      Prod_morph_ex :=
        fun p' f g => {|Trans := fun x u => (Trans f x u, Trans g x u) |}
    |}.

End Product.

Instance PSh_Has_Products (C : Category) : Has_Products (PShCat C) :=
  PSh_Product C. *)

From Categories Require Import Yoneda.Yoneda.
(* Categories.Yoneda.Yoneda:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Cat.Facts.
From Categories Require Import Functor.Main.
From Categories Require Import Coq_Cats.Type_Cat.Type_Cat.
From Categories Require Import Functor.Representable.Hom_Func.
From Categories Require Import Ext_Cons.Prod_Cat.Prod_Cat Ext_Cons.Prod_Cat.Operations.
From Categories Require Import NatTrans.NatTrans NatTrans.Func_Cat NatTrans.NatIso.

Local Open Scope nattrans_scope.

Section Y_emb.
  Context (C : Category).

  Definition CoYoneda : (C^op –≻ (Func_Cat C Type_Cat))%functor :=
    Exp_Cat_morph_ex (Hom_Func C).

  Definition Yoneda : (C –≻ (Func_Cat (C^op) Type_Cat))%functor :=
    Exp_Cat_morph_ex (Hom_Func (C^op)).

End Y_emb.

Section Y_Left_Right.
  Context (C : Category).

  Definition Y_left :
    ((C^op × (Func_Cat (C^op) Type_Cat)) –≻ Type_Cat)%functor
    :=
      ((Hom_Func _)
         ∘ (Prod_Functor
              ((Yoneda C)^op) (Functor_id (Func_Cat (C^op) Type_Cat))))%functor.
  
  Definition Y_right
    : ((C^op × (Func_Cat (C^op) Type_Cat)) –≻ Type_Cat)%functor :=
    ((Exp_Cat_Eval (C^op) Type_Cat) ∘ (Twist_Func _ _))%functor.

End Y_Left_Right.

Local Obligation Tactic := idtac.

Program Definition Y_left_to_right (C : Category) : (Y_left C) –≻ (Y_right C) :=
{|
  Trans := fun c_F => fun N => ((Trans N (fst c_F))) (id (fst c_F))
|}.

Program Definition Y_right_to_left_NT (C : Category) (c : Obj)
        (F : (C^op –≻ Type_Cat)%functor) (h : (F _o c)%object)
  :
    ((Yoneda _) _o c)%object –≻ F :=
{|
  Trans := fun c' => fun g => (F _a g)%morphism h
|}.

Program Definition Y_right_to_left (C : Category) : (Y_right C) –≻ (Y_left C) :=
{|
  Trans := fun c_F => fun h => Y_right_to_left_NT C (fst c_F) (snd c_F) h
|}.

Program Definition Yoneda_Lemma (C : Category) :
  ((Y_left C) ≃ (Y_right C))%natiso :=
  NatIso _ _ (Y_left_to_right C) (Y_right_to_left C) _ _.

Lemma Yoneda_Faithful (C : Category) : Faithful_Func (Yoneda C).

Lemma Yoneda_Full (C : Category) : Full_Func (Yoneda C).

Definition Yoneda_Emb (C : Category) : Embedding C (Func_Cat (C^op) Type_Cat) :=
{|
  Emb_Func := Yoneda C;
  Emb_Faithful := Yoneda_Faithful C;
  Emb_Full := Yoneda_Full C
|}.

Theorem Yoneda_Iso (C : Category) : forall (c c' : Obj),
    ((Yoneda C) _o c ≃ (Yoneda C) _o c')%isomorphism → (c ≃ c')%isomorphism.

Ltac Yoneda := apply Yoneda_Iso.

Theorem CoYoneda_Iso (C : Category) : forall (c c' : Obj),
    ((CoYoneda C) _o c ≃ (CoYoneda C) _o c')%isomorphism → (c ≃ c')%isomorphism.

Ltac CoYoneda := apply CoYoneda_Iso. *)



Section Exponential.

  Context (C : Category) (F G : PShCat C).



  Local Obligation Tactic := idtac.



  Program Definition funspace_psh : Functor (C^op) Type_Cat :=

    {|

      FO :=

        fun x =>

          NatTrans

            (pointwise_product_psh _ ((Yoneda C _o) x)%object F)

            G;

      FA :=

        fun _ _ f u =>

          {|

            Trans :=

              fun x v => Trans u x (((fst v) ∘ f)%morphism, (snd v))

          |}

    |}.



  Next Obligation.

  Proof.

    basic_simpl.

    extensionality v.

    simpl_ids.

    set (W := equal_f (Trans_com u h) (f ∘ (fst v), snd v)%morphism).

    cbn in W.

    simpl_ids in W.

    rewrite assoc_sym.

    trivial.

  Qed.



  Next Obligation.

  Proof.

    symmetry.

    apply funspace_psh_obligation_1.

  Qed.



  Next Obligation.

  Proof.

    intros x.

    FunExt.

    apply NatTrans_eq_simplify; cbn; auto.

  Qed.



  Next Obligation.

  Proof.    

    intros a b c f g.

    FunExt.

    apply NatTrans_eq_simplify; cbn.

    FunExt.

    rewrite assoc.

    trivial.

  Qed.



  Program Definition PSh_Exponential_Eval :

    (pointwise_product_psh C funspace_psh F –≻ G)%nattrans

    :=

      {|

        Trans := fun x u => Trans (fst u) x (id, snd u)

      |}.



  Next Obligation.

  Proof.

    basic_simpl.

    extensionality u.

    set (W := equal_f (Trans_com (fst u) h) (id, snd u)).

    cbn in W.

    auto.

  Qed.



  Next Obligation.

  Proof.

    symmetry.

    apply PSh_Exponential_Eval_obligation_1.

  Qed.



  Program Definition PSh_Exponential_Curry

          (x : (C ^op –≻ Type_Cat)%functor)

          (u : (pointwise_product_psh C x F –≻ G)%nattrans)

    :

      (x –≻ funspace_psh)%nattrans

  :=

    {|

      Trans :=

        fun v m =>

          {|

            Trans :=

              fun p q =>

                Trans u p (x _a (fst q) m, snd q)%morphism

          |}

    |}.



  Next Obligation.

  Proof.

    intros x u v m c c' h.

    cbn in *.

    extensionality p.

    simpl_ids.

    cbn_rewrite (F_compose x (fst p) h).

    set (W := equal_f (Trans_com u h) ((x _a (fst p) m)%morphism, snd p)).

    cbn in W.

    trivial.

  Qed.



  Next Obligation.

  Proof.

    symmetry; simpl.

    apply PSh_Exponential_Curry_obligation_1.

  Qed.



  Next Obligation.

  Proof.

    intros x u c c' h.

    cbn in *.

    extensionality v.

    apply NatTrans_eq_simplify.

    extensionality z; extensionality y.

    cbn in *.

    cbn_rewrite (F_compose x h (fst y)).

    trivial.

  Qed.



  Next Obligation.

  Proof.

    symmetry; simpl.

    apply PSh_Exponential_Curry_obligation_3.

  Qed.



  Program Definition PSh_Exponential : (F ⇑ G)%object :=

    {|

      exponential := funspace_psh;

      eval := PSh_Exponential_Eval;

      Exp_morph_ex := PSh_Exponential_Curry

    |}.



  Next Obligation.

  Proof.

    intros z f.

    apply NatTrans_eq_simplify.

    extensionality x; extensionality y.

    cbn in *.

    rewrite (F_id z).

    trivial.

  Qed.



  Next Obligation.

  Proof.

    intros z f u u' H1 H2.

    rewrite H2 in H1; clear H2.

    assert (H1' := f_equal Trans H1); clear H1.

    symmetry in H1'.

    apply NatTrans_eq_simplify.

    extensionality x; extensionality y.

    apply NatTrans_eq_simplify.

    extensionality p.

    extensionality q.

    cbn in *.

    assert (H1 := f_equal (fun w => w p (z _a (fst q) y, snd q)%morphism) H1');

      clear H1'.

    cbn in H1.

    cbn_rewrite (equal_f (Trans_com u (fst q)) y) in H1.

    cbn_rewrite (equal_f (Trans_com u' (fst q)) y) in H1.

    cbn in H1.

    auto.

  Qed.



End Exponential.



Instance PSh_Has_Exponentials (C : Category) : Has_Exponentials (PShCat C) :=

  PSh_Exponential C.

