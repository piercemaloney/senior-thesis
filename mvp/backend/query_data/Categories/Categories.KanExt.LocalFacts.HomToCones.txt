From Categories Require Import Essentials.Notations.
(* Categories.Essentials.Notations:
Notation "âˆ€ x .. y , P" := (forall x, .. (forall y, P) ..)
                             (at level 200, x binder, y binder, right associativity) : type_scope.

Notation "âˆƒ x .. y , P" := (exists x, .. (exists y, P) ..)
  (at level 200, x binder, y binder, right associativity) : type_scope.

Notation "x âˆ¨ y" := (x \/ y) (at level 85, right associativity) : type_scope.

Notation "x âˆ§ y" := (x /\ y) (at level 80, right associativity) : type_scope.

Notation "x â†’ y" := (x -> y)
  (at level 90, y at level 200, right associativity): type_scope.

Notation "x â†” y" := (x <-> y) (at level 95, no associativity): type_scope.

Notation "Â¬ x" := (~x) (at level 75, right associativity) : type_scope.

Notation "x â‰  y" := (x <> y) (at level 70) : type_scope.

Notation "x â‰¤ y" := (le x y) (at level 70, no associativity).

Notation "x â‰¥ y" := (ge x y) (at level 70, no associativity).

Reserved Notation "C '^op'" (at level 50, no associativity).

Reserved Notation "a â€“â‰» b" (at level 90, b at level 200, right associativity).

Reserved Notation "f 'â»Â¹'" (at level 50, no associativity).

Reserved Notation "a â‰ƒ b" (at level 70, no associativity).

Reserved Notation "a â‰ƒâ‰ƒ b ::> C" (at level 70, no associativity).

Reserved Notation "f âˆ˜ g" (at level 51, right associativity).

Reserved Notation "f 'âˆ˜_h' g" (at level 51, right associativity).

Reserved Notation "a â‰«â€“> b" (at level 100, no associativity).

Reserved Notation "a â€“â‰« b" (at level 100, no associativity).

Reserved Notation "F '_o'" (at level 50, no associativity).

Reserved Notation "F '_a'" (at level 50, no associativity).

Reserved Notation "F '@_a'" (at level 50, no associativity).

Reserved Notation "F âŠ£ G" (at level 100, no associativity).

Reserved Notation "F âŠ£_hom G" (at level 100, no associativity).

Reserved Notation "F âŠ£_ucu G" (at level 100, no associativity).

Reserved Notation "a Ã— b" (at level 80, no associativity).

Reserved Notation "a â‡‘ b" (at level 79, no associativity).

Reserved Notation "'Î ' m" (at level 50, no associativity).

Reserved Notation "'Î£' m" (at level 50, no associativity).

Reserved Notation "'Î _' C â†“ m" (at level 50, no associativity).

Reserved Notation "'Î£_' C â†“ m" (at level 50, no associativity).

Delimit Scope category_scope with category.

Delimit Scope morphism_scope with morphism.

Delimit Scope object_scope with object.

Delimit Scope functor_scope with functor.

Delimit Scope nattrans_scope with nattrans.

Delimit Scope nattrans_scope with nattrans.

Delimit Scope natiso_scope with natiso.

Delimit Scope isomorphism_scope with isomorphism.

Delimit Scope preorder_scope with preorder. *)

From Categories Require Import Essentials.Types.
(* Categories.Essentials.Types:
Global Set Primitive Projections.

Global Set Universe Polymorphism.

Global Unset Universe Minimization ToSet.

Inductive Empty : Type :=.

Hint Extern 1 =>
let tac := (repeat intros ?); match goal with [H : Empty |- _] => contradict H end in
match goal with
  | [|- context[Empty]] => tac
  | [H : context[Empty] |- _] => tac
end
.

Record prod (A B : Type) := {fst : A; snd : B}.

Arguments fst {_ _ } _.
Arguments snd {_ _ } _.
Arguments Build_prod {_ _ } _ _.

Notation "( X , Y )" := (Build_prod X Y).
Notation "X * Y" := (prod X Y) : type_scope. *)

From Categories Require Import Essentials.Facts_Tactics.
(* Categories.Essentials.Facts_Tactics:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.

Require Export Coq.Program.Tactics.
Require Export Coq.Program.Equality.
Require Export Coq.Logic.FunctionalExtensionality.
Require Export Coq.Logic.ProofIrrelevance.

Definition equal_f : âˆ€ {A B : Type} {f g : A â†’ B}, f = g â†’ âˆ€ x : A, f x = g x.

Definition f_equal : âˆ€ (A B : Type) (f : A â†’ B) (x y : A), x = y â†’ f x = f y.

Arguments f_equal [_ _] _ [_ _] _.

Ltac basic_simpl :=
  let simpl_prod _ :=
      match goal with
        [H : prod _ _ |- _] =>
        let H1 := fresh H "1" in
        let H2 := fresh H "2" in
        destruct H as [H1 H2]
      end
  in
  let simpl_sig _ :=
      match goal with
        [H : @sig _ _ |- _] =>
        let H1 := fresh H "1" in
        let H2 := fresh H "2" in
        destruct H as [H1 H2]
      end
  in
  let basic_simpl_helper _ :=
      cbn in *; intros;
        repeat simpl_prod tt;
        repeat simpl_sig tt
  in
  repeat basic_simpl_helper tt
.

Global Obligation Tactic := basic_simpl; auto.

Ltac PIR :=
  let pir_helper _ :=
      match goal with
      |[H : ?A, H' : ?A|- _] =>
       match type of A with
       | Prop =>
         destruct (proof_irrelevance _ H H')
       end
      end
  in
  repeat pir_helper tt
.

Ltac ElimEq := repeat match goal with [H : _ = _|- _] => destruct H end.

Hint Extern 1 => progress ElimEq.

Ltac cbn_rewrite W :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite H; clear H
.

Ltac cbn_rewrite_in W V :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite H in V; clear H
.

Ltac cbn_rewrite_back W :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite <- H; clear H
.

Ltac cbn_rewrite_back_in W V :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite <- H in V; clear H
.

Tactic Notation "cbn_rewrite" constr(W) := cbn_rewrite W.
Tactic Notation "cbn_rewrite" constr(W) "in" hyp_list(V) := cbn_rewrite_in W V.
Tactic Notation "cbn_rewrite" "<-" constr(W) := cbn_rewrite_back W.
Tactic Notation "cbn_rewrite" "<-" constr(W) "in" hyp_list(V) := cbn_rewrite_back_in W V.

Lemma sig_proof_irrelevance {A : Type} (P : A â†’ Prop) (X Y : sig P) : proj1_sig X = proj1_sig Y â†’ X = Y.

Hint Extern 2 (exist ?A _ _ = exist ?A _ _) => apply sig_proof_irrelevance.

Ltac FunExt :=
progress (
    repeat (
        match goal with
          [|- _ = _] =>
          let x := fresh "x" in
          extensionality x
        end
      )
  )
.

Hint Extern 1 => FunExt.

Lemma pair_eq (A B : Type) (a b : A * B) : fst a = fst b â†’ snd a = snd b â†’ a = b.

Hint Resolve pair_eq.

Ltac revert_clearbody_all :=
 repeat lazymatch goal with H:_ |- _ => try clearbody H; revert H end.

Ltac hyp_stack :=
 constr:(ltac:(revert_clearbody_all;constructor) : True).

Ltac next_hyp hs step last :=
 lazymatch hs with (?hs' ?H) => step H hs' | _ => last end.

Tactic Notation "dohyps" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := tac H; next_hyp hs step idtac in
 next_hyp hs step idtac.

Tactic Notation "dohyps" "reverse" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := next_hyp hs step idtac; tac H in
 next_hyp hs step idtac.

Tactic Notation "do1hyp" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := tac H + next_hyp hs step fail in
 next_hyp hs step fail.

Tactic Notation "do1hyp" "reverse" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := next_hyp hs step fail + tac H in
 next_hyp hs step fail. *)

From Categories Require Import Category.Main.
(* Categories.Category.Main:
From Categories Require Export Category.Category.
From Categories Require Export Category.Morph.
From Categories Require Export Category.Opposite.
From Categories Require Export Category.SubCategory.
From Categories Require Export Category.Composable_Chain. *)

From Categories Require Import Functor.Functor Functor.Functor_Ops
(* Categories.Functor.Functor:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.

Record Functor (C C' : Category) : Type :=
{
  
  FO : C â†’ C';

  FA : âˆ€ {a b}, (a â€“â‰» b)%morphism â†’ ((FO a) â€“â‰» (FO b))%morphism;

  F_id : âˆ€ c, FA (id c) = id (FO c);

  F_compose : âˆ€ {a b c} (f : (a â€“â‰» b)%morphism) (g : (b â€“â‰» c)%morphism),
      (FA (g âˆ˜ f) = (FA g) âˆ˜ (FA f))%morphism

}.

Arguments FO {_ _} _ _.
Arguments FA {_ _} _ {_ _} _, {_ _} _ _ _ _.
Arguments F_id {_ _} _ _.
Arguments F_compose {_ _} _ {_ _ _} _ _.

Notation "C â€“â‰» D" := (Functor C D) : functor_scope.

Bind Scope functor_scope with Functor.

Notation "F '_o'" := (FO F) : object_scope.

Notation "F '@_a'" := (@FA _ _ F) : morphism_scope.

Notation "F '_a'" := (FA F) : morphism_scope.

Hint Extern 2 => (apply F_id).

Local Open Scope morphism_scope.
Local Open Scope object_scope.

Ltac Functor_Simplify :=
  progress
    (
      repeat rewrite F_id;
      (
        repeat
          match goal with
          | [|- ?F _a ?A = id (?F _o ?x)] =>
            (rewrite <- F_id; (cbn+idtac))
          | [|- (id (?F _o ?x)) = ?F _a ?A] =>
            (rewrite <- F_id; (cbn+idtac))
          | [|- ?F _a ?A âˆ˜ ?F _a ?B = ?F _a ?C âˆ˜ ?F _a ?D] =>
            (repeat rewrite <- F_compose; (cbn+idtac))
          | [|- ?F _a ?A âˆ˜ ?F _a ?B = ?F _a ?C] =>
            (rewrite <- F_compose; (cbn+idtac))
          | [|- ?F _a ?C = ?F _a ?A âˆ˜ ?F _a ?B] =>
            (rewrite <- F_compose; (cbn+idtac))
          | [|- context [?F _a ?A âˆ˜ ?F _a ?B]] =>
            (rewrite <- F_compose; (cbn+idtac))
          end
      )
    )
.

Hint Extern 2 => Functor_Simplify.

Section Functor_eq_simplification.

  Context {C C' : Category} (F G : (C â€“â‰» C')%functor).

  Lemma Functor_eq_simplify (Oeq : F _o = G _o) :
    ((fun x y =>
        match Oeq in _ = V return ((x â€“â‰» y) â†’ ((V x) â€“â‰» (V y)))%morphism with
          eq_refl => F  @_a x y
        end) = G @_a) -> F = G.

  Theorem FA_extensionality (Oeq : F _o = G _o) :
    (
      âˆ€ (a b : Obj)
        (h : (a â€“â‰» b)%morphism),
        (
          fun x y =>
            match Oeq in _ = V return
                  ((x â€“â‰» y) â†’ ((V x) â€“â‰» (V y)))%morphism
            with
              eq_refl => F  @_a x y
            end
        ) _ _ h = G _a h
    )
    â†’
    (
      fun x y =>
        match Oeq in _ = V return
              ((x â€“â‰» y) â†’ ((V x) â€“â‰» (V y)))%morphism
        with
          eq_refl => F  @_a x y
        end
    ) = G @_a.

  Lemma Functor_extensionality (Oeq : F _o = G _o) :
    (
      âˆ€ (a b : Obj) (h : (a â€“â‰» b)%morphism),
        (
          fun x y =>
            match Oeq in _ = V return
                  ((x â€“â‰» y) â†’ ((V x) â€“â‰» (V y)))%morphism
            with
              eq_refl => F  @_a x y
            end
        ) _ _ h = G _a h
    ) â†’ F = G.

End Functor_eq_simplification.

Hint Extern 2 => Functor_Simplify.

Ltac Func_eq_simpl :=
  match goal with
    [|- ?A = ?B :> Functor _ _] =>
    (apply (Functor_eq_simplify A B (eq_refl : A _o = B _o)%object)) +
    (cut (A _o = B _o)%object; [
       let u := fresh "H" in
       intros H;
         apply (Functor_eq_simplify A B H)
         |
    ])
  end.

Hint Extern 3 => Func_eq_simpl.

Section Functor_eq.
  Context {C C' : Category} (F G : (C â€“â‰» C')%functor).

  Lemma Functor_eq_morph (H : F = G) :
    âˆƒ (H : âˆ€ x, F _o x = G _o x),
    âˆ€ x y (h : (x â€“â‰» y)%morphism),
      match H x in _ = V return (V â€“â‰» _)%morphism with
         eq_refl =>
         match H y in _ = V return (_ â€“â‰» V)%morphism with
           eq_refl => F _a h
         end
       end = G _a h.

End Functor_eq. *)
(* Categories.Functor.Functor_Ops:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Functor.

Section Opposite_Functor.
  Context {C D : Category} (F : (C â€“â‰» D)%functor).
  
  Local Open Scope morphism_scope.
  Local Open Scope object_scope.
    
  Program Definition Opposite_Functor : (C^op â€“â‰» D^op)%functor :=
    {|
      FO := F _o;
      FA := fun _ _ h => F @_a _ _ h;
      F_id := fun a => F_id F a;
      F_compose := fun _ _ _ f g => F_compose F g f
    |}.

End Opposite_Functor.

Notation "F '^op'" := (Opposite_Functor F) : functor_scope.

Section Functor_Compose.
  Context {C C' C'' : Category} (F : (C â€“â‰» C')%functor) (F' : (C' â€“â‰» C'')%functor).

  Local Open Scope morphism_scope.
  Local Open Scope object_scope.
  
  Program Definition Functor_compose : (C â€“â‰» C'')%functor :=
    {|
      FO := fun c => F' _o (F _o c);
      FA := fun c d f => F' _a (F _a f)
    |}.
  
End Functor_Compose.

Notation "F âˆ˜ G" := (Functor_compose G F) : functor_scope. 

Section Functor_Assoc.
  Context {C1 C2 C3 C4 : Category}
          (F : (C1 â€“â‰» C2)%functor)
          (G : (C2 â€“â‰» C3)%functor)
          (H : (C3 â€“â‰» C4)%functor).

  Local Open Scope functor_scope.
    
  Theorem Functor_assoc : (H âˆ˜ G) âˆ˜ F = H âˆ˜ (G âˆ˜ F).

End Functor_Assoc.

Program Definition Functor_id (C : Category) : (C â€“â‰» C)%functor :=
  {|
    FO := fun x => x;
    FA := fun c d f => f
  |}.

Section Functor_Identity_Unit.
  Context  (C C' : Category) (F : (C â€“â‰» C')%functor).

  Theorem Functor_id_unit_left : ((Functor_id C') âˆ˜ F)%functor = F.

  Theorem Functor_id_unit_right : (Functor_compose (Functor_id _) F) = F.

End Functor_Identity_Unit. *)

        Functor.Representable.Hom_Func.

From Categories Require Import Functor.Functor_Extender.
(* Categories.Functor.Functor_Extender:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Functor Functor.Functor_Ops.
From Categories Require Import NatTrans.Main.

Local Notation NID := NatTrans_id (only parsing).

Local Hint Extern 1 => progress
                        (repeat (apply NatTrans_eq_simplify; FunExt); cbn in *).

Section Left_Functor_Extender.
  Context {C C' : Category} (p : (C â€“â‰» C')%functor) (D : Category).

    Program Definition Left_Functor_Extender :
      ((Func_Cat C' D) â€“â‰» (Func_Cat C D))%functor :=
      {|
        FO := fun F => (F âˆ˜ p)%functor;
        FA := fun F F' N => (N âˆ˜_h (NID p))%nattrans
      |}.

End Left_Functor_Extender.

Section Right_Functor_Extender.
  Context {C C' : Category} (p : (C â€“â‰» C')%functor) (D : Category).

    Program Definition Right_Functor_Extender :
      ((Func_Cat D C) â€“â‰» (Func_Cat D C'))%functor :=
      {|
        FO := fun F => (p âˆ˜ F)%functor;
        FA := fun F F' N => ((NID p) âˆ˜_h N)%nattrans
      |}.

End Right_Functor_Extender.

Section Left_Functor_Extender_Iso.
  Context {C C' : Category} {p p' : (C â€“â‰» C')%functor}
          (N : (p â‰ƒ p')%natiso) (D : Category).

  Local Hint Extern 1 => (rewrite Trans_com); trivial; fail.
  Local Hint Extern 1 => rewrite <- F_compose.
  Local Hint Extern 1 =>
  match goal with
    [w : @Obj C |- _] =>
    cbn_rewrite (f_equal (fun u => Trans u w) (left_inverse N))
  end.
  Local Hint Extern 1 =>
  match goal with
    [w : @Obj C |- _] =>
    cbn_rewrite (f_equal (fun u => Trans u w) (right_inverse N))
  end.

  Program Definition Left_Functor_Extender_Iso :
    ((Left_Functor_Extender p D) â‰ƒ (Left_Functor_Extender p' D))%natiso
    :=
      {|
        iso_morphism :=
          {|
            Trans :=
              fun e =>
                ((NatTrans_id_Iso e) âˆ˜_h N)%natiso
          |};
        inverse_morphism :=
          {|
            Trans :=
              fun e =>
                ((NatTrans_id_Iso e) âˆ˜_h (Nâ»Â¹))%natiso
          |}
      |}
  .
      
End Left_Functor_Extender_Iso.

Section Right_Functor_Extender_Iso.
  Context {C C' : Category} {p p' : (C â€“â‰» C')%functor}
          (N : (p â‰ƒ p')%natiso) (D : Category).
  
  Local Hint Extern 1 => (rewrite Trans_com); trivial; fail.
  Local Hint Extern 1 => rewrite <- F_compose.
  Local Hint Extern 1 =>
  match goal with
    [w : @Obj D, F : (D â€“â‰» C)%functor |- _] =>
    cbn_rewrite (f_equal (fun u => Trans u (F _o w)%object) (left_inverse N))
    end.
  Local Hint Extern 1 =>
  match goal with
    [w : @Obj D, F : (D â€“â‰» C)%functor |- _] =>
    cbn_rewrite (f_equal (fun u => Trans u (F _o w)%object) (right_inverse N))
    end.

  Program Definition Right_Functor_Extender_Iso :
    ((Right_Functor_Extender p D) â‰ƒ (Right_Functor_Extender p' D))%natiso
    :=
      {|
        iso_morphism :=
          {|
            Trans :=
              fun e =>
                (N âˆ˜_h (NatTrans_id_Iso e))%natiso
          |};
        inverse_morphism :=
          {|
            Trans :=
              fun e =>
                ((Nâ»Â¹) âˆ˜_h (NatTrans_id_Iso e))%natiso
          |}
      |}
  .
 
End Right_Functor_Extender_Iso.

Section Right_Left_Functor_Extension_Iso.
  Context {B C D E : Category} (F : (B â€“â‰» C)%functor) (G : (D â€“â‰» E)%functor).
  
  Program Definition Right_Left_Functor_Extension_Iso :
    (
      (((Right_Functor_Extender G B) âˆ˜ (Left_Functor_Extender F D))%functor)
        â‰ƒ ((Left_Functor_Extender F E) âˆ˜ (Right_Functor_Extender G C))%functor
    )%natiso :=
    {|
      iso_morphism := {|Trans := fun h => NatTrans_Functor_assoc_sym F h G |};
      inverse_morphism := {|Trans := fun h => NatTrans_Functor_assoc F h G |}
    |}.

End Right_Left_Functor_Extension_Iso. *)

From Categories Require Import NatTrans.NatTrans NatTrans.Operations
(* Categories.NatTrans.NatTrans:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Functor.
From Categories Require Import Cat.Cat.

Section NatTrans.
  Context {C C' : Category}.

  Record NatTrans (F F' : (C â€“â‰» C')%functor) :=
    {
      Trans (c : C) : ((F _o c) â€“â‰» (F' _o c))%object%morphism;
      Trans_com {c c' : C} (h : (c â€“â‰» c')%morphism) :
        ((Trans c') âˆ˜ F _a h = F' _a h âˆ˜ (Trans c))%morphism;
      Trans_com_sym {c c' : C} (h : (c â€“â‰» c')%morphism) :
        (F' _a h âˆ˜ (Trans c) = (Trans c') âˆ˜ F _a h)%morphism
    }.

  Notation "F â€“â‰» F'" := (NatTrans F F') : nattrans_scope.

  Lemma NatTrans_eq_simplify {F F' : (C â€“â‰» C')%functor}
        (N N' : (F â€“â‰» F')%nattrans) : (@Trans _ _ N) = (@Trans _ _ N') -> N = N'.

End NatTrans.

Arguments Trans {_ _ _ _} _ _.
Arguments Trans_com {_ _ _ _} _ {_ _} _.
Arguments Trans_com_sym {_ _ _ _} _ {_ _} _.

Bind Scope nattrans_scope with NatTrans.

Notation "F â€“â‰» F'" := (NatTrans F F') : nattrans_scope.

Local Open Scope nattrans_scope.

Section NatTrans_Compose.
  Context {C C' : Category}.
  
  Program Definition NatTrans_compose {F F' F'' : (C â€“â‰» C')%functor}
          (tr : F â€“â‰» F') (tr' : F' â€“â‰» F'') : (F â€“â‰» F'')%nattrans :=
    {|
      Trans := fun c : Obj => ((Trans tr' c) âˆ˜ (Trans tr c)) % morphism
    |}.

End NatTrans_Compose.

Notation "N âˆ˜ N'" := (NatTrans_compose N' N) : nattrans_scope.

Section NatTrans_Props.
  Context {C C' : Category}.
  
  Theorem NatTrans_compose_assoc {F G H I : (C â€“â‰» C')%functor} (N : F â€“â‰» G)
          (N' : G â€“â‰» H) (N'' : H â€“â‰» I)
    : ((N'' âˆ˜ N') âˆ˜ N = N'' âˆ˜ (N' âˆ˜ N))%nattrans
  .

  Program Definition NatTrans_id (F : (C â€“â‰» C')%functor) : F â€“â‰» F :=
    {|
      Trans := fun x : Obj => id
    |}.

  Theorem NatTrans_id_unit_left {F G : (C â€“â‰» C')%functor} (N : F â€“â‰» G)
    : (NatTrans_id G) âˆ˜ N = N.

  Theorem NatTrans_id_unit_right {F G : (C â€“â‰» C')%functor} (N : F â€“â‰» G)
    : N âˆ˜ (NatTrans_id F) = N.
  
End NatTrans_Props.

Hint Resolve NatTrans_eq_simplify. *)
(* Categories.NatTrans.Operations:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Functor Functor.Functor_Ops.
From Categories Require Import Cat.Cat.
From Categories Require Import NatTrans.NatTrans.

Local Open Scope nattrans_scope.

Section Opposite_NatTrans.
  Context {C D : Category} {F F' : (C â€“â‰» D)%functor} (N : (F â€“â‰» F')%nattrans).

  Program Definition Opposite_NatTrans : F'^op â€“â‰» F^op :=
    {|
      Trans := Trans N;
      Trans_com := fun c c' h => (Trans_com_sym N h);
      Trans_com_sym := fun c c' h => (Trans_com N h)
    |}.
  
End Opposite_NatTrans.

Notation "N '^op'" := (Opposite_NatTrans N) : nattrans_scope.

Section Compose_NOP.
  Context {C D : Category} {F F' F'' : (C â€“â‰» D)%functor}
          (N : F â€“â‰» F') (N' : F' â€“â‰» F'').

  Theorem NatTrans_compose_Op : ((N' âˆ˜ N)^op = N^op âˆ˜ (N'^op))%nattrans.

End Compose_NOP.

Section NatTrans_id_Op.
  Context {C D : Category} (F : (C â€“â‰» D)%functor).

  Theorem NatTrans_id_Op
    : ((NatTrans_id F)^op)%nattrans = NatTrans_id (F^op)%functor.

End NatTrans_id_Op.

Program Definition NatTrans_hor_comp {C D E : Category} {F G : (C â€“â‰» D)%functor}
        {F' G' : (D â€“â‰» E)%functor} (tr : F â€“â‰» G) (tr' : F' â€“â‰» G')
  : (F' âˆ˜ F) â€“â‰» (G' âˆ˜ G) :=
{|
  Trans := fun c : Obj => ((G' _a (Trans tr c)) âˆ˜ (Trans tr' (F _o c)))%morphism
|}.

Notation "N âˆ˜_h N'" := (NatTrans_hor_comp N' N) : nattrans_scope.

Section Hor_Compose_ids.
  Context {C D E : Category} (F : (C â€“â‰» D)%functor) (G : (D â€“â‰» E)%functor).

  Theorem NatTrans_hor_comp_ids
    : ((NatTrans_id G) âˆ˜_h (NatTrans_id F))%nattrans = NatTrans_id  (G âˆ˜ F).

End Hor_Compose_ids.

Section Hor_Compose_NOP.
  Context {C D E : Category} {F G : (C â€“â‰» D)%functor} {F' G' : (D â€“â‰» E)%functor}
          (N : F â€“â‰» G) (N' : F' â€“â‰» G').
  
  Theorem NatTrans_hor_comp_Op : ((N' âˆ˜_h N)^op = N'^op âˆ˜_h N^op)%nattrans.

End Hor_Compose_NOP.

Section NatTransCompID.
  Context {C D : Category} (F : (C â€“â‰» D)%functor).
  
  Program Definition NatTrans_to_compose_id : F â€“â‰» ((Functor_id D) âˆ˜ F) :=
    {|
      Trans := fun c => id
    |}.

  Program Definition NatTrans_from_compose_id : ((Functor_id _) âˆ˜ F) â€“â‰» F :=
    {|
      Trans := fun c => id
    |}.

  Program Definition NatTrans_to_id_compose : F â€“â‰» (F âˆ˜ (Functor_id _)) :=
    {|
      Trans := fun c => id
    |}.

  Program Definition NatTrans_from_id_compose : (F âˆ˜ (Functor_id _)) â€“â‰» F :=
    {|
      Trans := fun c => id
    |}.

End NatTransCompID.

Section NatTransAssoc.
  Context {C1 C2 C3 C4 : Category}
          (F : (C1 â€“â‰» C2)%functor)
          (G : (C2 â€“â‰» C3)%functor)
          (H : (C3 â€“â‰» C4)%functor)
  .
  
  Program Definition NatTrans_Functor_assoc
    : ((H âˆ˜ G) âˆ˜ F) â€“â‰» (H âˆ˜ (G âˆ˜ F)) :=
    {|
      Trans := fun c => id
    |}.

  Program Definition NatTrans_Functor_assoc_sym
    : (H âˆ˜ (G âˆ˜ F)) â€“â‰» ((H âˆ˜ G) âˆ˜ F) :=
    {|
      Trans := fun c => id
    |}.

End NatTransAssoc.

Section NatTrans_comp_hor_comp.
  Context {C D E  : Category}
          {F F' F'' : (C â€“â‰» D)%functor}
          {G G' G'' : (D â€“â‰» E)%functor}
          (N1 : F â€“â‰» F')
          (N2 : G â€“â‰» G')
          (N3 : F' â€“â‰» F'')
          (N4 : G' â€“â‰» G'')
  .

  Theorem NatTrans_comp_hor_comp
    : ((N4 âˆ˜_h N3) âˆ˜ (N2 âˆ˜_h N1) = (N4 âˆ˜ N2) âˆ˜_h (N3 âˆ˜ N1))%nattrans.

End NatTrans_comp_hor_comp.

Section IsoCat_NatTrans.
  Context {C D : Category} (I : (C â‰ƒâ‰ƒ D ::> Cat)%isomorphism)
          {E : Category} (F : (D â€“â‰» E)%functor).

  Local Obligation Tactic := idtac.
  
  Program Definition IsoCat_NatTrans :
    (F âˆ˜ ((iso_morphism I) âˆ˜ (Iâ»Â¹)%morphism)) â€“â‰» F
    :=
      {|
        Trans :=
          fun c =>
            match eq_sym (f_equal (fun x => (x _o)%object c) (right_inverse I))
                  in _ = y return ((F _o y) â€“â‰» (F _o c))%object%morphism
            with
              eq_refl => id
            end
      |}
  .

  Program Definition IsoCat_NatTrans_back :
    F â€“â‰» (F âˆ˜ ((iso_morphism I) âˆ˜ (Iâ»Â¹)%morphism))
    :=
      {|
        Trans :=
          fun c =>
            match eq_sym (f_equal (fun x => (x _o)%object c) (right_inverse I))
                  in _ = y return ((F _o c) â€“â‰» (F _o y))%object%morphism
            with
              eq_refl => id
            end
      |}
  .

End IsoCat_NatTrans. *)

        NatTrans.Func_Cat NatTrans.NatIso.

From Categories Require Import Ext_Cons.Prod_Cat.Prod_Cat Ext_Cons.Prod_Cat.Operations
(* Categories.Ext_Cons.Prod_Cat.Prod_Cat:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Main.
From Categories Require Import Cat.Cat.

Local Open Scope morphism_scope.

Local Obligation Tactic := idtac.

Program Definition Prod_Cat (C C' : Category) : Category :=
{|
  Obj := C * C';
              
  Hom :=
    fun a b =>
      (((fst a) â€“â‰» (fst b)) * ((snd a) â€“â‰» (snd b)))%type;

  compose :=
    fun a b c f g =>
      (((fst g) âˆ˜ (fst f)), ((snd g) âˆ˜ (snd f)))%morphism;

  id := fun c => (id, id)
|}.

Notation "C Ã— D" := (Prod_Cat C D) : category_scope.

Local Obligation Tactic := basic_simpl; auto.

Theorem Prod_compose_id
        (C D : Category)
        (a b c : C) (d : D)
        (f : a â€“â‰» b) (g : b â€“â‰» c)
  : (g âˆ˜ f, id d)%morphism =
    @compose (_ Ã— _) (_, _) (_, _) (_, _) (f, id d) (g, id d).

Theorem Prod_id_compose
        (C D : Category)
        (a : C) (b c d : D)
        (f : b â€“â‰» c) (g : c â€“â‰» d)
  : (id a, g âˆ˜ f)%morphism =
    @compose (_ Ã— _) (_, _) (_, _) (_, _) (id a, f) (id a, g).

Theorem Prod_cross_compose
        (C D : Category)
        (a b : C) (c d : D)
        (f : a â€“â‰» b) (g : c â€“â‰» d)
  : @compose
      (_ Ã— _) (_, _) (_, _) (_, _)
      (@id _ a, g) (f, @id _ d)
    = @compose
        (_ Ã— _) (_, _) (_, _) (_, _)
        (f, @id _ c) (@id _ b, g)
.

Program Definition Cat_Proj1
        (C C' : Category) :
  ((C Ã— C') â€“â‰» C)%functor
  :=
    {|FO := fst; FA := fun _ _ f => fst f|}
.

Program Definition Cat_Proj2
        (C C' : Category) :
  ((C Ã— C') â€“â‰» C')%functor
  :=
    {|FO := snd; FA := fun _ _ f => snd f|}
. *)
(* Categories.Ext_Cons.Prod_Cat.Operations:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Main.
From Categories Require Import Cat.Cat.
From Categories Require Import Ext_Cons.Prod_Cat.Prod_Cat.

Local Obligation Tactic := idtac.

Local Open Scope functor_scope.

Program Definition Prod_Functor
        {C1 C2 C1' C2' : Category} (F : C1 â€“â‰» C2) (F' : C1' â€“â‰» C2')
  : (C1 Ã— C1') â€“â‰» (C2 Ã— C2') :=
{|
  FO := fun a => (F _o (fst a), F' _o (snd a))%object;
  FA := fun _ _ f => (F _a (fst f), F' _a (snd f))%morphism
|}.

Definition Bi_Func_1 {Cx C1 C1' Cy : Category} (F : Cx â€“â‰» C1)
           (F' : (C1 Ã— C1') â€“â‰» Cy)
  : (Cx Ã— C1') â€“â‰» Cy :=
  F' âˆ˜ (Prod_Functor F (@Functor_id C1')).

Definition Bi_Func_2 {Cx C1 C1' Cy : Category} (F : Cx â€“â‰» C1')
           (F' : (C1 Ã— C1') â€“â‰» Cy) : (C1 Ã— Cx) â€“â‰» Cy :=
  Functor_compose (Prod_Functor (@Functor_id C1) F) F'.

Local Hint Extern 2 => cbn.

Local Obligation Tactic := basic_simpl; do 2 auto.

Program Definition Fix_Bi_Func_1 {C1 C1' Cy : Category} (x : C1)
        (F : (C1 Ã— C1') â€“â‰» Cy)
  : C1' â€“â‰» Cy :=
{|
  FO := fun a => (F _o (x, a))%object;
  FA := fun _ _ f => (F @_a (_, _) (_, _) (@id _ x, f))%morphism
|}.

Program Definition Fix_Bi_Func_2 {C1 C1' Cy : Category} (x : C1')
        (F : (C1 Ã— C1') â€“â‰» Cy)
  : C1 â€“â‰» Cy :=
{|
  FO := fun a => (F _o (a, x))%object;
  FA := fun _ _ f => (F @_a (_, _) (_, _) (f, @id _ x))%morphism
|}.

Program Definition Diag_Func (C : Category) : C â€“â‰» (C Ã— C) :=
{|
  FO := fun a => (a, a);
  FA := fun _ _ f => (f, f);
  F_id := fun _ => eq_refl;
  F_compose := fun _ _ _ _ _ => eq_refl
|}.

Theorem Prod_Functor_Cat_Proj {C D D' : Category} (F : C â€“â‰» (D Ã— D')) :
  ((Prod_Functor ((Cat_Proj1 _ _) âˆ˜ F) ((Cat_Proj2 _ _) âˆ˜ F))
     âˆ˜ (Diag_Func C))%functor = F.

Program Definition Twist_Func (C C' : Category) : (C Ã— C') â€“â‰» (C' Ã— C) :=
{|
  FO := fun a => (snd a, fst a);
  FA := fun _ _ f => (snd f, fst f);
  F_id := fun _ => eq_refl;
  F_compose := fun _ _ _ _ _ => eq_refl
|}.

Section Twist_Prod_Func_Twist.
  Context {C C' : Category} (F : C â€“â‰» C') {D D' : Category} (G : D â€“â‰» D').

  Theorem Twist_Prod_Func_Twist :
    (((Twist_Func _ _) âˆ˜ (Prod_Functor F G)) âˆ˜ (Twist_Func _ _))%functor =
    Prod_Functor G F.

End Twist_Prod_Func_Twist.

Section Prod_Functor_compose.
  Context {C D E: Category} (F : C â€“â‰» D) (G : D â€“â‰» E)
          {C' D' E': Category} (F' : C' â€“â‰» D') (G' : D' â€“â‰» E').

  Theorem Prod_Functor_compose :
    ((Prod_Functor G G') âˆ˜ (Prod_Functor F F') =
     Prod_Functor (G âˆ˜ F) (G' âˆ˜ F'))%functor.
                                   
End Prod_Functor_compose. *)

        Ext_Cons.Prod_Cat.Nat_Facts.

From Categories Require Import Adjunction.Adjunction.
(* Categories.Adjunction.Adjunction:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Ext_Cons.Prod_Cat.Prod_Cat Ext_Cons.Prod_Cat.Operations.
From Categories Require Import Functor.Main.
From Categories Require Import Functor.Representable.Hom_Func
        Functor.Representable.Hom_Func_Prop.
From Categories Require Import NatTrans.Main.

Local Open Scope functor_scope.

Local Notation NID := NatTrans_id (only parsing).
Local Notation FCAT := Func_Cat (only parsing).

Notation Hom_Adj_Left C D F G :=
  ((Hom_Func D) âˆ˜ (Prod_Functor (F^op) (@Functor_id D)))%functor (only parsing).

Notation Hom_Adj_Right C D F G :=
  ((Hom_Func C) âˆ˜ (Prod_Functor (@Functor_id (C^op)) G))%functor (only parsing).

Local Obligation Tactic := idtac.

Section Adjunction.
  Context {C D : Category} (F : C â€“â‰» D) (G : D â€“â‰» C).

  Record Adjunct : Type :=
  {
    adj_unit : ((Functor_id C) â€“â‰» (G âˆ˜ F))%nattrans;
    
    adj_morph_ex {c : C} {d : D} (f : (c â€“â‰» (G _o d)%object)%morphism) :
      ((F _o c)%object â€“â‰» d)%morphism;
    
    adj_morph_com {c : C} {d : D} (f : (c â€“â‰» (G _o d))%morphism%object) :
      f = ((G _a (adj_morph_ex f)) âˆ˜ (Trans adj_unit c))%morphism;
    
    adj_morph_unique {c : C} {d : D} (f : (c â€“â‰» (G _o d))%object%morphism)
                     (g h : ((F _o c) â€“â‰» d)%morphism%object) :
      f = ((G _a g) âˆ˜ (Trans adj_unit c))%morphism â†’
      f = ((G _a h) âˆ˜ (Trans adj_unit c))%morphism â†’
      g = h
  }.

  Arguments adj_unit : clear implicits.
  Arguments adj_morph_ex _ {_ _} _.
  Arguments adj_morph_com _ {_ _} _.
  Arguments adj_morph_unique _ {_ _} _ _ _ _ _.

  Theorem Adjunct_eq_simplify (adj adj' : Adjunct) :
    adj_unit adj = @adj_unit adj' â†’
    @adj_morph_ex adj = @adj_morph_ex adj' â†’ adj = adj'.

  Definition Hom_Adjunct :=
    (Hom_Adj_Left _ _ F G â‰ƒ Hom_Adj_Right _ _ F G)%natiso.

  Record UCU_Adjunct :=
    {
      ucu_adj_unit : ((Functor_id C) â€“â‰» (G âˆ˜ F))%nattrans;
      
      ucu_adj_counit : ((F âˆ˜ G) â€“â‰» (Functor_id D))%nattrans;

      ucu_adj_left_id : ((NatTrans_from_compose_id _)
                           âˆ˜ ((((ucu_adj_counit âˆ˜_h (NID F))
                                  âˆ˜ (NatTrans_Functor_assoc_sym _ _ _))
                                 âˆ˜ ((NID F) âˆ˜_h ucu_adj_unit))
                                âˆ˜ (NatTrans_to_id_compose _)))%nattrans
                        = (NID F);
      
      ucu_adj_right_id : ((NatTrans_from_id_compose _)
                            âˆ˜ (((((NID G) âˆ˜_h ucu_adj_counit)
                                   âˆ˜ (NatTrans_Functor_assoc _ _ _))
                                  âˆ˜ (ucu_adj_unit âˆ˜_h (NID G)))
                                 âˆ˜ (NatTrans_to_compose_id _)))%nattrans
                         = (NID G)
    }.

  Arguments ucu_adj_unit : clear implicits.
  Arguments ucu_adj_counit : clear implicits.
  Arguments ucu_adj_left_id : clear implicits.
  Arguments ucu_adj_right_id : clear implicits.

  Local Notation "F âŠ£ G" := (Adjunct) : functor_scope.
  Local Notation "F âŠ£_hom G" := (Hom_Adjunct) : functor_scope.
  Local Notation "F âŠ£_ucu G" := (UCU_Adjunct) : functor_scope.
  
  Section UCU_Adj_Adj.
    Context (Adj : (F âŠ£_ucu G)%functor).

    Program Definition UCU_Adj_to_Adj : (F âŠ£ G)%functor :=
      {|
        adj_unit := ucu_adj_unit Adj;
        adj_morph_ex :=
          fun _ _ h => ((Trans (ucu_adj_counit Adj) _) âˆ˜ (F _a h))%morphism
      |}.

  End UCU_Adj_Adj.

  Section Adj_UCU_Adj.
    Context (Adj : (F âŠ£ G)%functor).
    
    Program Definition Adj_to_UCU_Adj : (F âŠ£_ucu G)%functor :=
      {|
        ucu_adj_unit := adj_unit Adj;
        ucu_adj_counit :=
          {|
            Trans := fun d => @adj_morph_ex Adj (G _o d) d id
          |}
      |}.

  End Adj_UCU_Adj.
  
  Section Adj_Hom_Adj.
    Context (Adj : (F âŠ£ G)%functor).

    Program Definition Adj_to_Hom_Adj_LR :
      ((Hom_Adj_Left _ _ F G) â€“â‰» (Hom_Adj_Right _ _ F G))%nattrans :=
    {|
      Trans := fun c h => ((G _a h) âˆ˜ (Trans (adj_unit Adj) _))%morphism
    |}.

    Program Definition Adj_to_Hom_Adj_RL :
      ((Hom_Adj_Right _ _ F G) â€“â‰» (Hom_Adj_Left _ _ F G))%nattrans :=
    {|
      Trans := fun c h => adj_morph_ex Adj h
    |}.

    Program Definition Adj_to_Hom_Adj : (F âŠ£_hom G)%functor :=
      NatIso _ _ Adj_to_Hom_Adj_LR Adj_to_Hom_Adj_RL _ _.

  End Adj_Hom_Adj.

  Section Hom_Adj_Adj.
    Context (Adj : (F âŠ£_hom G)%functor).

    Program Definition Hom_Adj_to_Adj : (F âŠ£ G)%functor :=
      {|
        adj_unit :=
          {| Trans := fun c => Trans (iso_morphism Adj) (c, F _o c)%object id |};
        adj_morph_ex := fun _ _ f => Trans (inverse_morphism Adj) (_, _) f
      |}.

  End Hom_Adj_Adj.

End Adjunction.

Arguments adj_unit {_ _ _ _} _ : assert.
Arguments adj_morph_ex {_ _ _ _} _ {_ _} _.
Arguments adj_morph_com {_ _ _ _} _ {_ _} _.
Arguments adj_morph_unique {_ _ _ _} _ {_ _} _ _ _ _ _.

Arguments ucu_adj_unit {_ _ _ _} _.
Arguments ucu_adj_counit {_ _ _ _} _.
Arguments ucu_adj_left_id {_ _ _ _} _.
Arguments ucu_adj_right_id {_ _ _ _} _.

Arguments Adj_to_Hom_Adj {_ _ _ _} _.

Arguments Hom_Adj_to_Adj {_ _ _ _} _.

Notation "F âŠ£ G" := (Adjunct F G) : functor_scope.
Notation "F âŠ£_hom G" := (Hom_Adjunct F G) : functor_scope.
Notation "F âŠ£_ucu G" := (UCU_Adjunct F G) : functor_scope. *)

From Categories Require Import KanExt.Local.
(* Categories.KanExt.Local:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Functor Functor.Functor_Ops Functor.Representable.Hom_Func.
From Categories Require Import Ext_Cons.Prod_Cat.Prod_Cat Ext_Cons.Prod_Cat.Operations.
From Categories Require Import NatTrans.NatTrans NatTrans.Operations NatTrans.Func_Cat NatTrans.NatIso.
From Categories Require Import Functor.Functor_Extender.

Section KanExtension.
  Context {C C' : Category} (p : (C â€“â‰» C')%functor).

  Section Right.
    Context {D : Category} (F : (C â€“â‰» D)%functor).

    Record LoKan_Cone : Type :=
      {
        cone_apex : (C' â€“â‰» D)%functor;
        cone_edge : ((cone_apex âˆ˜ p) â€“â‰» F)%nattrans
      }.

    Coercion cone_apex : LoKan_Cone >-> Functor.
    Coercion cone_edge : LoKan_Cone >-> NatTrans.

    Section LoKan_Cone_Morph.
      Context (Cn Cn' : LoKan_Cone).

      Record LoKan_Cone_Morph : Type :=
        {
          cone_morph : (Cn â€“â‰» Cn')%nattrans;
          cone_morph_com :
            Cn = (Cn' âˆ˜ (cone_morph
                           âˆ˜_h (NatTrans_id p)))%nattrans :> (_ â€“â‰» _)%nattrans
        }.

      Coercion cone_morph : LoKan_Cone_Morph >-> NatTrans.

    End LoKan_Cone_Morph.

    Record Local_Right_KanExt :=
      {
        LRKE : LoKan_Cone;
        LRKE_morph_ex : âˆ€ (Cn : LoKan_Cone), LoKan_Cone_Morph Cn LRKE;
        LRKE_morph_unique :
          âˆ€ (Cn : LoKan_Cone)
            (h h' : LoKan_Cone_Morph Cn LRKE), h = h' :> (_ â€“â‰» _)%nattrans
      }.

    Coercion LRKE : Local_Right_KanExt >-> LoKan_Cone.

    Record is_Local_Right_KanExt (Cn_apex : (C' â€“â‰» D)%functor) :=
      {
        isLRKE_Cn_edge : ((Cn_apex âˆ˜ p) â€“â‰» F)%nattrans;
        isLRKE_morph_ex : âˆ€ (Cn : LoKan_Cone), LoKan_Cone_Morph
                                                 Cn
                                                 {|cone_apex :=
                                                     Cn_apex;
                                                   cone_edge := isLRKE_Cn_edge
                                                 |};
        isLRKE_morph_unique : âˆ€ (Cn : LoKan_Cone)
                                (h h' : LoKan_Cone_Morph
                                          Cn
                                          {|cone_apex := Cn_apex;
                                            cone_edge := isLRKE_Cn_edge
                                          |}),
            h = h' :> (_ â€“â‰» _)%nattrans
      }.

    Definition is_Local_Right_KanExt_Local_Right_KanExt
               {Cn_apex : (C' â€“â‰» D)%functor}
               (ilrke : is_Local_Right_KanExt Cn_apex) : Local_Right_KanExt :=
      {|
        LRKE := {|cone_apex := Cn_apex; cone_edge := @isLRKE_Cn_edge _ ilrke|};
        LRKE_morph_ex := @isLRKE_morph_ex _ ilrke;
        LRKE_morph_unique := @isLRKE_morph_unique _ ilrke
      |}.

    Definition Local_Right_KanExt_is_Local_Right_KanExt
               (lrke : Local_Right_KanExt)
      : is_Local_Right_KanExt lrke :=
      {|
        isLRKE_Cn_edge := lrke;
        isLRKE_morph_ex := @LRKE_morph_ex lrke;
        isLRKE_morph_unique := @LRKE_morph_unique lrke
      |}.

    Record is_Cone_Local_Right_KanExt (Cn : LoKan_Cone) :=
      {
        isCLRKE_morph_ex : âˆ€ (Cn' : LoKan_Cone), LoKan_Cone_Morph Cn' Cn;
        isCLRKE_morph_unique :
          âˆ€ (Cn' : LoKan_Cone) (h h' : LoKan_Cone_Morph Cn' Cn),
            h = h' :> (_ â€“â‰» _)%nattrans
      }.

    Definition is_Cone_Local_Right_KanExt_Local_Right_KanExt {Cn : LoKan_Cone}
               (ilrke : is_Cone_Local_Right_KanExt Cn) : Local_Right_KanExt :=
      {|
        LRKE := Cn;
        LRKE_morph_ex := @isCLRKE_morph_ex _ ilrke;
        LRKE_morph_unique := @isCLRKE_morph_unique _ ilrke
      |}.

    Definition Local_Right_KanExt_is_Cone_Local_Right_KanExt
               (lrke : Local_Right_KanExt)
      : is_Cone_Local_Right_KanExt lrke :=
      {|
        isCLRKE_morph_ex := @LRKE_morph_ex lrke;
        isCLRKE_morph_unique := @LRKE_morph_unique lrke
      |}.
    
  End Right.
  
End KanExtension.

Section Left.
  Context {C C' : Category} (p : (C â€“â‰» C')%functor)
          {D : Category} (F : (C â€“â‰» D)%functor).

  Definition Local_Left_KanExt := Local_Right_KanExt (p^op) (F^op).

  Definition is_Local_Left_KanExt (Cn_apex : (C' â€“â‰» D)%functor) :=
    is_Local_Right_KanExt (p^op) (F^op) (Cn_apex^op)
  .
  
End Left.
  
Arguments cone_apex {_ _ _ _ _} _.
Arguments cone_edge {_ _ _ _ _} _.
Arguments LoKan_Cone_Morph {_ _ _ _ _} _ _.
Arguments cone_morph {_ _ _ _ _ _ _} _.
Arguments cone_morph_com {_ _ _ _ _ _ _} _.
Arguments LRKE {_ _ _ _ _} _.
Arguments LRKE_morph_ex {_ _ _ _ _} _ _.
Arguments LRKE_morph_unique {_ _ _ _ _} _ _ _ _.

Section Hom_Local_Right_KanExt.
  Context {C C' : Category} (p : (C â€“â‰» C')%functor)
          {D : Category} (F : (C â€“â‰» D)%functor).

  Definition Hom_Local_Right_KanExt_Isomorphism (HLRKE : (C' â€“â‰» D)%functor) :=
    (
      (
        (@Fix_Bi_Func_2 _ (Func_Cat _ _) _ F (Hom_Func (Func_Cat C D)))
          âˆ˜ (Left_Functor_Extender p D)^op
      )%functor
       â‰ƒ
       (
         @Fix_Bi_Func_2 _ (Func_Cat _ _) _ HLRKE (Hom_Func (Func_Cat C' D))
       )
    )%natiso
  .
  
  Record Hom_Local_Right_KanExt := 
    {
      HLRKE : (C' â€“â‰» D)%functor;
      HLRKE_Iso : Hom_Local_Right_KanExt_Isomorphism HLRKE
    }.
  
  Coercion HLRKE : Hom_Local_Right_KanExt >-> Functor.
  
End Hom_Local_Right_KanExt.

Section Hom_Local_Left_KanExt.
  Context {C C' : Category} (p : (C â€“â‰» C')%functor)
          {D : Category} (F : (C â€“â‰» D)%functor).

  Definition Hom_Local_Left_KanExt :=
    Hom_Local_Right_KanExt (p^op) (F^op).
  
End Hom_Local_Left_KanExt.

Arguments HLRKE {_ _ _ _ _} _.
Arguments HLRKE_Iso {_ _ _ _ _} _. *)

From Categories Require Import Basic_Cons.Terminal.
(* Categories.Basic_Cons.Terminal:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Main.

Class Terminal (C : Category) : Type :=
{
  terminal : C;
  t_morph : âˆ€ (d : Obj), (d â€“â‰» terminal)%morphism;
  t_morph_unique : âˆ€ (d : Obj) (f g : (d â€“â‰» terminal)%morphism), f = g
}.

Arguments terminal {_} _.
Arguments t_morph {_} _ _.
Arguments t_morph_unique {_} _ _ _ _.

Coercion terminal : Terminal >-> Obj.

Notation "ðŸ™_ C" := (Terminal C) (at level 75) : object_scope.

Theorem Terminal_iso {C : Category} (T T' : (ðŸ™_ C)%object) :
  (T â‰ƒ T')%isomorphism.

Definition Initial (C : Category) := (ðŸ™_ (C ^op))%object.
Existing Class Initial.

Notation "ðŸ˜_ C" := (Initial C) (at level 75) : object_scope. *)



Local Open Scope functor_scope.



Section Hom_Local_Right_KanExt_to_Local_Right_KanExt.

  Context {C C' : Category} {p : C â€“â‰» C'}

          {D : Category} {F : C â€“â‰» D}

          (hlrke : Hom_Local_Right_KanExt p F).



  Definition Hom_Local_Right_KanExt_to_Local_Right_KanExt_Terminal_Cone :

    LoKan_Cone p F :=

    {|

      cone_apex := hlrke;

      cone_edge :=

        Trans (inverse_morphism (HLRKE_Iso hlrke)) hlrke (NatTrans_id hlrke)

    |}.



  Local Notation TCONE :=

    Hom_Local_Right_KanExt_to_Local_Right_KanExt_Terminal_Cone (only parsing).



  Section Hom_Local_Right_KanExt_to_Local_Right_KanExt_Morph_to_Terminal_Cone.

    Context (Cn : LoKan_Cone p F).



    Program Definition

            Hom_Local_Right_KanExt_to_Local_Right_KanExt_Morph_to_Terminal_Cone :

      LoKan_Cone_Morph Cn TCONE :=

      {|

        cone_morph := Trans (iso_morphism (HLRKE_Iso hlrke)) Cn Cn

      |}.



    Next Obligation.

    Proof.

      set (W :=

             f_equal (

                 fun w :

                       (((@Fix_Bi_Func_2 _ (Func_Cat _ _) _ F (Hom_Func _))

                             âˆ˜ (Left_Functor_Extender p D)^op)

                         â€“â‰» ((@Fix_Bi_Func_2 _ (Func_Cat _ _) _ F (Hom_Func _))

                            âˆ˜ (Left_Functor_Extender p D)^op

                         ))%nattrans =>

                   Trans w Cn

               ) (left_inverse (HLRKE_Iso hlrke))).

      cbn in W.

      match goal with

        [|- ?A = ?B] =>

        match type of W with

          ?X = _ =>

          cut (X A = X B); simpl;

            [rewrite (equal_f W A); rewrite (equal_f W B); trivial|clear W]

        end

      end.

      apply f_equal.

      set (M :=

             equal_f

               (@Trans_com _ _ _ _

                           (iso_morphism (HLRKE_Iso hlrke))

                           hlrke

                           Cn

                           (Trans (iso_morphism (HLRKE_Iso hlrke)) Cn Cn)

               )

               (Trans (inverse_morphism (HLRKE_Iso hlrke))

                      hlrke (NatTrans_id hlrke))).

      cbn in M.

      repeat rewrite NatTrans_id_unit_left in M.

      rewrite M; clear M.

      apply NatTrans_eq_simplify; extensionality x; cbn.

      cbn_rewrite (

          f_equal

            (fun w :

                   ((@Fix_Bi_Func_2 _ (Func_Cat _ _) _ hlrke (Hom_Func _))

                      â€“â‰» (@Fix_Bi_Func_2 _ (Func_Cat _ _) _ hlrke (Hom_Func _))

                   )%nattrans

             => Trans w hlrke (NatTrans_id _)

            )

            (right_inverse (HLRKE_Iso hlrke))

        ).

      cbn; auto.

    Qed.



  End Hom_Local_Right_KanExt_to_Local_Right_KanExt_Morph_to_Terminal_Cone.



  Section

    Hom_Local_Right_KanExt_to_Local_Right_KanExt_Morph_to_Terminal_Cone_unique.

    Context {Cn : LoKan_Cone p F} (h h' : LoKan_Cone_Morph Cn TCONE).



    Theorem

      Hom_Local_Right_KanExt_to_Local_Right_KanExt_Morph_to_Terminal_Cone_unique

      : h = h' :> (_ â€“â‰» _)%nattrans.

    Proof.

      set (Mh :=

             equal_f

               (@Trans_com _ _ _ _ (iso_morphism (HLRKE_Iso hlrke)) hlrke Cn h)

               (Trans (inverse_morphism (HLRKE_Iso hlrke))

                      hlrke (NatTrans_id hlrke))

          ).

      set (Mh' :=

             equal_f

               (@Trans_com _ _ _ _ (iso_morphism (HLRKE_Iso hlrke)) hlrke Cn h')

               (Trans (inverse_morphism

                         (HLRKE_Iso hlrke)) hlrke (NatTrans_id hlrke))

          ).

      cbn in Mh, Mh'.

      cbn_rewrite ((f_equal

                      (fun w :

                           ((@Fix_Bi_Func_2

                               _ (Func_Cat _ _) _ hlrke (Hom_Func _))

                              â€“â‰» (@Fix_Bi_Func_2

                                    _ (Func_Cat _ _) _ hlrke (Hom_Func _))

                           )%nattrans

                       => Trans w hlrke (NatTrans_id _))

                      (right_inverse (HLRKE_Iso hlrke)))) in Mh Mh'.

      repeat rewrite NatTrans_id_unit_left in Mh, Mh'.

      destruct Mh; destruct Mh'.

      apply f_equal.

      etransitivity;

        [symmetry; apply (cone_morph_com h) | apply (cone_morph_com h')].

    Qed.



  End

    Hom_Local_Right_KanExt_to_Local_Right_KanExt_Morph_to_Terminal_Cone_unique.



  Definition Hom_Local_Right_KanExt_to_Local_Right_KanExt :

    Local_Right_KanExt p F :=

    {|

      LRKE := TCONE;

      LRKE_morph_ex :=

        Hom_Local_Right_KanExt_to_Local_Right_KanExt_Morph_to_Terminal_Cone;

      LRKE_morph_unique :=

        @Hom_Local_Right_KanExt_to_Local_Right_KanExt_Morph_to_Terminal_Cone_unique

    |}.



End Hom_Local_Right_KanExt_to_Local_Right_KanExt.

