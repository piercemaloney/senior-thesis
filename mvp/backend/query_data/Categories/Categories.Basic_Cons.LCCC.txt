From Categories Require Import Essentials.Notations.
(* Categories.Essentials.Notations:
Notation "∀ x .. y , P" := (forall x, .. (forall y, P) ..)
                             (at level 200, x binder, y binder, right associativity) : type_scope.

Notation "∃ x .. y , P" := (exists x, .. (exists y, P) ..)
  (at level 200, x binder, y binder, right associativity) : type_scope.

Notation "x ∨ y" := (x \/ y) (at level 85, right associativity) : type_scope.

Notation "x ∧ y" := (x /\ y) (at level 80, right associativity) : type_scope.

Notation "x → y" := (x -> y)
  (at level 90, y at level 200, right associativity): type_scope.

Notation "x ↔ y" := (x <-> y) (at level 95, no associativity): type_scope.

Notation "¬ x" := (~x) (at level 75, right associativity) : type_scope.

Notation "x ≠ y" := (x <> y) (at level 70) : type_scope.

Notation "x ≤ y" := (le x y) (at level 70, no associativity).

Notation "x ≥ y" := (ge x y) (at level 70, no associativity).

Reserved Notation "C '^op'" (at level 50, no associativity).

Reserved Notation "a –≻ b" (at level 90, b at level 200, right associativity).

Reserved Notation "f '⁻¹'" (at level 50, no associativity).

Reserved Notation "a ≃ b" (at level 70, no associativity).

Reserved Notation "a ≃≃ b ::> C" (at level 70, no associativity).

Reserved Notation "f ∘ g" (at level 51, right associativity).

Reserved Notation "f '∘_h' g" (at level 51, right associativity).

Reserved Notation "a ≫–> b" (at level 100, no associativity).

Reserved Notation "a –≫ b" (at level 100, no associativity).

Reserved Notation "F '_o'" (at level 50, no associativity).

Reserved Notation "F '_a'" (at level 50, no associativity).

Reserved Notation "F '@_a'" (at level 50, no associativity).

Reserved Notation "F ⊣ G" (at level 100, no associativity).

Reserved Notation "F ⊣_hom G" (at level 100, no associativity).

Reserved Notation "F ⊣_ucu G" (at level 100, no associativity).

Reserved Notation "a × b" (at level 80, no associativity).

Reserved Notation "a ⇑ b" (at level 79, no associativity).

Reserved Notation "'Π' m" (at level 50, no associativity).

Reserved Notation "'Σ' m" (at level 50, no associativity).

Reserved Notation "'Π_' C ↓ m" (at level 50, no associativity).

Reserved Notation "'Σ_' C ↓ m" (at level 50, no associativity).

Delimit Scope category_scope with category.

Delimit Scope morphism_scope with morphism.

Delimit Scope object_scope with object.

Delimit Scope functor_scope with functor.

Delimit Scope nattrans_scope with nattrans.

Delimit Scope nattrans_scope with nattrans.

Delimit Scope natiso_scope with natiso.

Delimit Scope isomorphism_scope with isomorphism.

Delimit Scope preorder_scope with preorder. *)

From Categories Require Import Essentials.Types.
(* Categories.Essentials.Types:
Global Set Primitive Projections.

Global Set Universe Polymorphism.

Global Unset Universe Minimization ToSet.

Inductive Empty : Type :=.

Hint Extern 1 =>
let tac := (repeat intros ?); match goal with [H : Empty |- _] => contradict H end in
match goal with
  | [|- context[Empty]] => tac
  | [H : context[Empty] |- _] => tac
end
.

Record prod (A B : Type) := {fst : A; snd : B}.

Arguments fst {_ _ } _.
Arguments snd {_ _ } _.
Arguments Build_prod {_ _ } _ _.

Notation "( X , Y )" := (Build_prod X Y).
Notation "X * Y" := (prod X Y) : type_scope. *)

From Categories Require Import Essentials.Facts_Tactics.
(* Categories.Essentials.Facts_Tactics:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.

Require Export Coq.Program.Tactics.
Require Export Coq.Program.Equality.
Require Export Coq.Logic.FunctionalExtensionality.
Require Export Coq.Logic.ProofIrrelevance.

Definition equal_f : ∀ {A B : Type} {f g : A → B}, f = g → ∀ x : A, f x = g x.

Definition f_equal : ∀ (A B : Type) (f : A → B) (x y : A), x = y → f x = f y.

Arguments f_equal [_ _] _ [_ _] _.

Ltac basic_simpl :=
  let simpl_prod _ :=
      match goal with
        [H : prod _ _ |- _] =>
        let H1 := fresh H "1" in
        let H2 := fresh H "2" in
        destruct H as [H1 H2]
      end
  in
  let simpl_sig _ :=
      match goal with
        [H : @sig _ _ |- _] =>
        let H1 := fresh H "1" in
        let H2 := fresh H "2" in
        destruct H as [H1 H2]
      end
  in
  let basic_simpl_helper _ :=
      cbn in *; intros;
        repeat simpl_prod tt;
        repeat simpl_sig tt
  in
  repeat basic_simpl_helper tt
.

Global Obligation Tactic := basic_simpl; auto.

Ltac PIR :=
  let pir_helper _ :=
      match goal with
      |[H : ?A, H' : ?A|- _] =>
       match type of A with
       | Prop =>
         destruct (proof_irrelevance _ H H')
       end
      end
  in
  repeat pir_helper tt
.

Ltac ElimEq := repeat match goal with [H : _ = _|- _] => destruct H end.

Hint Extern 1 => progress ElimEq.

Ltac cbn_rewrite W :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite H; clear H
.

Ltac cbn_rewrite_in W V :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite H in V; clear H
.

Ltac cbn_rewrite_back W :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite <- H; clear H
.

Ltac cbn_rewrite_back_in W V :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite <- H in V; clear H
.

Tactic Notation "cbn_rewrite" constr(W) := cbn_rewrite W.
Tactic Notation "cbn_rewrite" constr(W) "in" hyp_list(V) := cbn_rewrite_in W V.
Tactic Notation "cbn_rewrite" "<-" constr(W) := cbn_rewrite_back W.
Tactic Notation "cbn_rewrite" "<-" constr(W) "in" hyp_list(V) := cbn_rewrite_back_in W V.

Lemma sig_proof_irrelevance {A : Type} (P : A → Prop) (X Y : sig P) : proj1_sig X = proj1_sig Y → X = Y.

Hint Extern 2 (exist ?A _ _ = exist ?A _ _) => apply sig_proof_irrelevance.

Ltac FunExt :=
progress (
    repeat (
        match goal with
          [|- _ = _] =>
          let x := fresh "x" in
          extensionality x
        end
      )
  )
.

Hint Extern 1 => FunExt.

Lemma pair_eq (A B : Type) (a b : A * B) : fst a = fst b → snd a = snd b → a = b.

Hint Resolve pair_eq.

Ltac revert_clearbody_all :=
 repeat lazymatch goal with H:_ |- _ => try clearbody H; revert H end.

Ltac hyp_stack :=
 constr:(ltac:(revert_clearbody_all;constructor) : True).

Ltac next_hyp hs step last :=
 lazymatch hs with (?hs' ?H) => step H hs' | _ => last end.

Tactic Notation "dohyps" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := tac H; next_hyp hs step idtac in
 next_hyp hs step idtac.

Tactic Notation "dohyps" "reverse" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := next_hyp hs step idtac; tac H in
 next_hyp hs step idtac.

Tactic Notation "do1hyp" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := tac H + next_hyp hs step fail in
 next_hyp hs step fail.

Tactic Notation "do1hyp" "reverse" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := next_hyp hs step fail + tac H in
 next_hyp hs step fail. *)

From Categories Require Import Category.Main.
(* Categories.Category.Main:
From Categories Require Export Category.Category.
From Categories Require Export Category.Morph.
From Categories Require Export Category.Opposite.
From Categories Require Export Category.SubCategory.
From Categories Require Export Category.Composable_Chain. *)

From Categories Require Import Basic_Cons.CCC Basic_Cons.PullBack.
(* Categories.Basic_Cons.CCC:
From Categories Require Import Essentials.Notations.
From Categories Require Import Category.Main.
From Categories Require Export Basic_Cons.Terminal.
From Categories Require Export Basic_Cons.Product.
From Categories Require Export Basic_Cons.Exponential.
From Categories Require Export Basic_Cons.Exponential_Functor.

Class CCC (C : Category) : Type :=
{
  CCC_term : (𝟙_ C)%object;
  CCC_HP : Has_Products C;
  CCC_HEXP : Has_Exponentials C
}.

Arguments CCC_term _ {_}, {_ _}.
Arguments CCC_HP _ {_} _ _, {_ _} _ _.
Arguments CCC_HEXP _ {_} _ _, {_ _} _ _.

Existing Instances CCC_term CCC_HP CCC_HEXP. *)
(* Categories.Basic_Cons.PullBack:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.

Local Open Scope morphism_scope.

Section PullBack.
  Context {C : Category} {a b x : C} (f : a –≻ x) (g : b –≻ x).

  Record PullBack : Type :=
    {
      pullback : C;

      pullback_morph_1 : pullback –≻ a;

      pullback_morph_2 : pullback –≻ b;

      pullback_morph_com : f ∘ pullback_morph_1 = g ∘ pullback_morph_2;

      pullback_morph_ex (p' : Obj) (pm1 : p' –≻ a) (pm2 : p' –≻ b) :
        f ∘ pm1 = g ∘ pm2 → p' –≻ pullback;

      pullback_morph_ex_com_1 (p' : Obj) (pm1 : p' –≻ a) (pm2 : p' –≻ b)
                              (pmc : f ∘ pm1 = g ∘ pm2)
      :
        pullback_morph_1 ∘ (pullback_morph_ex p' pm1 pm2 pmc) = pm1;

      pullback_morph_ex_com_2 (p' : Obj) (pm1 : p' –≻ a) (pm2 : p' –≻ b)
                              (pmc : f ∘ pm1 = g ∘ pm2)
      :
        pullback_morph_2 ∘ (pullback_morph_ex p' pm1 pm2 pmc) = pm2;

      pullback_morph_ex_unique
        (p' : Obj) (pm1 : p' –≻ a) (pm2 : p' –≻ b)
        (pmc : f ∘ pm1 = g ∘ pm2) (u u' : p' –≻ pullback) :
        pullback_morph_1 ∘ u = pm1 →
        pullback_morph_2 ∘ u = pm2 →
        pullback_morph_1 ∘ u' = pm1 →
        pullback_morph_2 ∘ u' = pm2 → u = u'
    }.

  Coercion pullback : PullBack >-> Obj.

  Theorem PullBack_iso (p1 p2 : PullBack) : (p1 ≃ p2)%isomorphism.

End PullBack.

Section is_PullBack.
  Context {C : Category} {a b x pb : C} (p1 : pb –≻ a)
          (p2 : pb –≻ b) (f : a –≻ x) (g : b –≻ x).

  Local Open Scope morphism_scope.
  
  Record is_PullBack : Type :=
    {
      is_pullback_morph_com : f ∘ p1 = g ∘ p2;

      is_pullback_morph_ex (p' : Obj) (pm1 : p' –≻ a) (pm2 : p' –≻ b) :
        f ∘ pm1 = g ∘ pm2 → p' –≻ pb;

      is_pullback_morph_ex_com_1 (p' : Obj) (pm1 : p' –≻ a) (pm2 : p' –≻ b)
                                 (pmc : f ∘ pm1 = g ∘ pm2)
      :
        p1 ∘ (is_pullback_morph_ex p' pm1 pm2 pmc) = pm1;

      is_pullback_morph_ex_com_2 (p' : Obj) (pm1 : p' –≻ a) (pm2 : p' –≻ b)
                                 (pmc : f ∘ pm1 = g ∘ pm2)
      :
        p2 ∘ (is_pullback_morph_ex p' pm1 pm2 pmc) = pm2;

      is_pullback_morph_ex_unique
        (p' : Obj) (pm1 : p' –≻ a) (pm2 : p' –≻ b)
        (pmc : f ∘ pm1 = g ∘ pm2) (u u' : p' –≻ pb) :
        p1 ∘ u = pm1 →
        p2 ∘ u = pm2 →
        p1 ∘ u' = pm1 →
        p2 ∘ u' = pm2 → u = u'
    }.

End is_PullBack.

Definition Has_PullBacks (C : Category) : Type :=
  ∀ (a b c : C) (f : a –≻ c) (g : b –≻ c), PullBack f g.

Existing Class Has_PullBacks.

Arguments PullBack _ {_ _ _} _ _, {_ _ _ _} _ _.
Arguments pullback {_ _ _ _ _ _} _.
Arguments pullback_morph_1 {_ _ _ _ _ _} _.
Arguments pullback_morph_2 {_ _ _ _ _ _} _.
Arguments pullback_morph_com {_ _ _ _ _ _} _.
Arguments pullback_morph_ex {_ _ _ _ _ _} _ _ _ _ _.
Arguments pullback_morph_ex_com_1 {_ _ _ _ _ _} _ _ _ _ _.
Arguments pullback_morph_ex_com_2 {_ _ _ _ _ _} _ _ _ _ _.
Arguments pullback_morph_ex_unique {_ _ _ _ _ _} _ _ _ _ _ _ _ _ _ _ _.

Arguments is_PullBack _ { _ _ _ _} _ _ _ _, {_ _ _ _ _ } _ _ _ _.

Arguments is_pullback_morph_com {_ _ _ _ _ _ _ _ _} _.
Arguments is_pullback_morph_ex {_ _ _ _ _ _ _ _ _} _ _ _ _ _.
Arguments is_pullback_morph_ex_com_1 {_ _ _ _ _ _ _ _ _} _ _ _ _ _.
Arguments is_pullback_morph_ex_com_2 {_ _ _ _ _ _ _ _ _} _ _ _ _ _.
Arguments is_pullback_morph_ex_unique {_ _ _ _ _ _ _ _ _} _ _ _ _ _ _ _ _ _ _ _.

Section is_PullBack_PullBack.
  Context {C : Category} {a b x pb : C} {p1 : pb –≻ a} {p2 : pb –≻ b} {f : a –≻ x}
          {g : b –≻ x} (iPB : is_PullBack p1 p2 f g).

  Definition is_PullBack_PullBack : PullBack f g :=
    {|
      pullback := pb;
      pullback_morph_1 := p1;
      pullback_morph_2 := p2;
      pullback_morph_com := is_pullback_morph_com iPB;
      pullback_morph_ex := fun p' pm1 pm2 => is_pullback_morph_ex iPB p' pm1 pm2;
      pullback_morph_ex_com_1 :=
        fun p' pm1 pm2 pmc => is_pullback_morph_ex_com_1 iPB p' pm1 pm2 pmc;
      pullback_morph_ex_com_2 :=
        fun p' pm1 pm2 pmc => is_pullback_morph_ex_com_2 iPB p' pm1 pm2 pmc;
      pullback_morph_ex_unique :=
        fun p' pm1 pm2 pmc u u' => is_pullback_morph_ex_unique iPB p' pm1 pm2 pmc u u'
    |}.

End is_PullBack_PullBack.

Section PullBack_is_PullBack.
  Context {C : Category} {a b x : C} {f : a –≻ x}
          {g : b –≻ x} (PB : PullBack f g).

  Definition PullBack_is_PullBack :
    is_PullBack (pullback_morph_1 PB) (pullback_morph_2 PB) f g :=
    {|
      is_pullback_morph_com := pullback_morph_com PB;
      is_pullback_morph_ex := fun p' pm1 pm2 => pullback_morph_ex PB p' pm1 pm2;
      is_pullback_morph_ex_com_1 :=
        fun p' pm1 pm2 pmc => pullback_morph_ex_com_1 PB p' pm1 pm2 pmc;
      is_pullback_morph_ex_com_2 :=
        fun p' pm1 pm2 pmc => pullback_morph_ex_com_2 PB p' pm1 pm2 pmc;
      is_pullback_morph_ex_unique :=
        fun p' pm1 pm2 pmc u u' => pullback_morph_ex_unique PB p' pm1 pm2 pmc u u'
    |}.

End PullBack_is_PullBack.
  
Definition PushOut (C : Category) := @PullBack (C^op).

Arguments PushOut _ {_ _ _} _ _, {_ _ _ _} _ _.

Definition Has_PushOuts (C : Category) : Type :=
  ∀ (a b c : C) (f : c –≻ a) (g : c –≻ b), PushOut f g.

Existing Class Has_PushOuts. *)

From Categories Require Import Ext_Cons.Comma.
(* Categories.Ext_Cons.Comma:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Category Category.Morph Category.Opposite.
From Categories Require Import Ext_Cons.Arrow.
From Categories Require Import Functor.Functor Functor.Functor_Ops Const_Func.
From Categories Require Import Archetypal.Discr.Discr.
From Categories Require Import Cat.Cat Cat.Cat_Iso.
From Categories Require Import NatTrans.NatTrans NatTrans.NatIso.

Local Open Scope morphism_scope.

Section Comma.
  Context {B C D : Category} (F : (B –≻ C)%functor) (G : (D –≻ C)%functor).

  Record Comma_Obj : Type :=
    {
      CMO_src : B;
      CMO_trg : D;
      CMO_hom : ((F _o CMO_src) –≻ (G _o CMO_trg))%object
    }.

  Record Comma_Hom (a b : Comma_Obj) : Type :=
    {
      CMH_left : (CMO_src a) –≻ (CMO_src b);
      CMH_right : (CMO_trg a) –≻ (CMO_trg b);
      CMH_com :  ((G _a CMH_right) ∘ (@CMO_hom a) =
                  (@CMO_hom b) ∘ (F _a CMH_left))%morphism
    }.

  Arguments CMH_left {_ _} _.
  Arguments CMH_right {_ _} _.
  Arguments CMH_com {_ _} _.

  Theorem Comma_Hom_eq_simplify {a b : Comma_Obj} (h h' : Comma_Hom a b) :
    (@CMH_left _ _ h) = (@CMH_left _ _ h') →
    (@CMH_right _ _ h) = (@CMH_right _ _ h') → h = h'.

  Program Definition Comma_Hom_compose
          {a b c : Comma_Obj} (h : Comma_Hom a b) (h' : Comma_Hom b c) :
    Comma_Hom a c :=
    {|
      CMH_left := (CMH_left h') ∘ (CMH_left h);
      CMH_right := (CMH_right h') ∘ (CMH_right h)
    |}.

  Theorem Comma_Hom_compose_assoc {a b c d : Comma_Obj} (h : Comma_Hom a b)
          (h' : Comma_Hom b c) (h'' : Comma_Hom c d) :
    Comma_Hom_compose h (Comma_Hom_compose h' h'') =
    Comma_Hom_compose (Comma_Hom_compose h h') h''.

  Program Definition Comma_Hom_id (a : Comma_Obj) : Comma_Hom a a :=
    {|
      CMH_left := id;
      CMH_right := id
    |}.

  Theorem Comma_Hom_id_unit_left {a b : Comma_Obj} (h : Comma_Hom a b) :
    Comma_Hom_compose h (Comma_Hom_id b) = h.

  Theorem Comma_Hom_id_unit_right {a b : Comma_Obj} (h : Comma_Hom a b) :
    Comma_Hom_compose (Comma_Hom_id a) h = h.

  Definition Comma : Category :=
    {|
      Obj := Comma_Obj;

      Hom := Comma_Hom;

      compose := @Comma_Hom_compose;

      assoc := @Comma_Hom_compose_assoc;

      assoc_sym := fun _ _ _ _ f g h => eq_sym (Comma_Hom_compose_assoc f g h);
      
      id := Comma_Hom_id;

      id_unit_right := @Comma_Hom_id_unit_right;

      id_unit_left := @Comma_Hom_id_unit_left
    |}.

End Comma.

Arguments CMO_src {_ _ _ _ _} _.
Arguments CMO_trg {_ _ _ _ _} _.
Arguments CMO_hom {_ _ _ _ _} _.
Arguments CMH_left {_ _ _ _ _ _ _} _.
Arguments CMH_right {_ _ _ _ _ _ _} _.
Arguments CMH_com {_ _ _ _ _ _ _} _.

Section Comma_Opposite_Iso.
  Context {B C D : Category} (F : (B –≻ C)%functor) (G : (D –≻ C)%functor).

  Local Hint Extern 1 => progress cbn.

  Local Hint Extern 1 => apply Comma_Hom_eq_simplify.
  
  Program Definition Comma_Opposite_Iso_LR :
    Functor ((Comma F G)^op) (Comma (G ^op) (F ^op))
    :=
      {|
        FO :=
          fun x =>
            {|
              CMO_src := CMO_trg x;
              CMO_trg := CMO_src x;
              CMO_hom := CMO_hom x
            |};
        FA :=
          fun c c' h =>
            {|
              CMH_left := CMH_right h;
              CMH_right := CMH_left h;
              CMH_com := eq_sym (CMH_com h)
            |}
      |}.

  Program Definition Comma_Opposite_Iso_RL :
    Functor (Comma (G ^op) (F ^op)) ((Comma F G)^op)
    :=
      {|
        FO :=
          fun x =>
            {|
              CMO_src := CMO_trg x;
              CMO_trg := CMO_src x;
              CMO_hom := CMO_hom x
            |};
        FA :=
          fun c c' h =>
            {|
              CMH_left := CMH_right h;
              CMH_right := CMH_left h;
              CMH_com := eq_sym (CMH_com h)
            |}
      |}.
    
  Program Definition Comma_Opposite_Iso :
    (((Comma F G)^op)%category ≃≃ Comma (G ^op) (F ^op) ::> Cat)%isomorphism
    :=
      {|
        iso_morphism := Comma_Opposite_Iso_LR;
        inverse_morphism := Comma_Opposite_Iso_RL
      |}
  .

End Comma_Opposite_Iso.

Section Comma_Left_Func_Iso.
  Context {B C D : Category}.

  Local Hint Extern 1 => progress cbn.

  Local Hint Extern 1 => apply Comma_Hom_eq_simplify.

  Section Comma_Left_Func_Iso_FC.
    Context
      {F F' : (B –≻ C)%functor}
      (I : (F ≃ F')%natiso)
      (G : (D –≻ C)%functor)
    .

    Program Definition Comma_Left_Func_Iso_FC :
      Functor (Comma F G) (Comma F' G)
      :=
        {|
          FO :=
            fun x =>
              {|
                CMO_src := CMO_src x;
                CMO_trg := CMO_trg x;
                CMO_hom := (CMO_hom x) ∘ (Trans (inverse_morphism I) (CMO_src x))
              |};
          FA :=
            fun c c' h =>
              {|
                CMH_left := CMH_left h;
                CMH_right := CMH_right h;
              CMH_com := _
              |}
        |}.
    
  End Comma_Left_Func_Iso_FC.

  Section Comma_Left_Func_Iso_FC_Iso.
    Context
      {F F' : (B –≻ C)%functor}
      (I : (F ≃ F')%natiso)
      (G : (D –≻ C)%functor)
    .

    Lemma Comma_Left_Func_Iso_FC_Iso :
      ((Comma_Left_Func_Iso_FC I G)
         ∘
         (Comma_Left_Func_Iso_FC (Inverse_Isomorphism I) G))%functor
      =
      Functor_id _
    .
    
  End Comma_Left_Func_Iso_FC_Iso.

  Context
    {F F' : (B –≻ C)%functor}
    (I : (F ≃ F')%natiso)
    (G : (D –≻ C)%functor)
  .

  Local Hint Extern 1 => apply Comma_Left_Func_Iso_FC_Iso.
  
  Program Definition Comma_Left_Func_Iso :
    ((Comma F G) ≃≃ (Comma F' G) ::> Cat)%isomorphism
    :=
      {|
        iso_morphism := Comma_Left_Func_Iso_FC I G;
        inverse_morphism := Comma_Left_Func_Iso_FC (Inverse_Isomorphism I) G
      |}
  . 
    
End Comma_Left_Func_Iso.

Section Comma_Right_Func_Iso.
  Context
    {B C D : Category}
    (F : (B –≻ C)%functor)
    {G G' : (D –≻ C)%functor}
    (I : (G ≃ G')%natiso)
  .

  Definition Comma_Right_Func_Iso :
    ((Comma F G) ≃≃ (Comma F G') ::> Cat)%isomorphism :=
    Isomorphism_Compose
      (
        Isomorphism_Compose
          (Inverse_Isomorphism (Comma_Opposite_Iso (G ^op) (F ^op)))
          (Opposite_Cat_Iso (Comma_Left_Func_Iso (Opposite_NatIso I) (F^op)))
      )
      (Comma_Opposite_Iso (G' ^op) (F ^op))
  .
    
End Comma_Right_Func_Iso.

Section Slice_CoSlice.
  Context (C : Category) (c : Obj).
  
  Definition Slice : Category := Comma (Functor_id _) (Const_Func 1 c).

  Definition CoSlice : Category := Comma (Const_Func 1 c) (Functor_id _).

End Slice_CoSlice.

Section Arrow_Cat.
  Context (C : Category).

  Definition Arrow_Cat : Category := Comma (Functor_id C) (Functor_id C).

End Arrow_Cat. *)

From Categories Require Import Ext_Cons.Arrow.
(* Categories.Ext_Cons.Arrow:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Coq_Cats.Type_Cat.Type_Cat.

Section Arrow.
  Local Open Scope morphism_scope.

  Record Arrow (C : Category) :=
    {
      Orig : Obj;
      Targ : Obj;
      Arr : Orig –≻ Targ
    }.

  Arguments Orig {_} _.
  Arguments Targ {_} _.
  Arguments Arr {_} _.

  Coercion Arr : Arrow >-> Hom.

  Record Arrow_Hom {C : Category} (a b : Arrow C) :=
    {
      Arr_H : (Orig a) –≻ (Orig b);
      Arr_H' : (Targ a) –≻ (Targ b);
      Arr_Hom_com : Arr_H' ∘ (Arr a) = (Arr b) ∘ Arr_H
    }.
  Arguments Arr_H {_ _ _} _.
  Arguments Arr_H' {_ _ _} _.
  Arguments Arr_Hom_com {_ _ _} _.

  Context (C : Category).

  Section Arrow_Hom_eq_simplify.
    Context {a b : Arrow C} (f g : Arrow_Hom a b).

    Lemma Arrow_Hom_eq_simplify : Arr_H f = Arr_H g → Arr_H' f = Arr_H' g → f = g.

  End Arrow_Hom_eq_simplify.

  Section Compose_id.
    Context {x y z} (h : Arrow_Hom x y) (h' : Arrow_Hom y z).

    Program Definition Arrow_Hom_compose : Arrow_Hom x z :=
      {|
        Arr_H := (Arr_H h') ∘ (Arr_H h);
        Arr_H' := (Arr_H' h') ∘ (Arr_H' h)
      |}.

    Program Definition Arrow_id : Arrow_Hom x x :=
      {|
        Arr_H := id;
        Arr_H' := id
      |}.

  End Compose_id.

End Arrow.

Hint Extern 1 (?A = ?B :> Arrow_Hom _ _) => apply Arrow_Hom_eq_simplify; simpl.

Arguments Orig {_} _.
Arguments Targ {_} _.
Arguments Arr {_} _.

Arguments Arr_H {_ _ _} _.
Arguments Arr_H' {_ _ _} _.
Arguments Arr_Hom_com {_ _ _} _.

Program Definition Arrow_to_Arrow_OP (C : Category) (ar : Arrow C) :
  Arrow (C ^op) :=
  {|
    Arr := ar
  |}.

Program Definition Arrow_OP_Iso (C : Category) :
  ((Arrow C) ≃≃ (Arrow (C ^op)) ::> Type_Cat)%isomorphism :=
  {|
    iso_morphism := Arrow_to_Arrow_OP C;
    inverse_morphism := Arrow_to_Arrow_OP (C ^op)
  |}. *)

From Categories Require Import Archetypal.Discr.Discr.
(* Categories.Archetypal.Discr.Discr:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Functor.
From Categories Require Import Cat.Cat.
From Categories Require Import Coq_Cats.Type_Cat.Type_Cat.

Definition EmptyCat : Category :=
  {|
    Obj := (Empty : Type);
    Hom := fun _ _ => (unit : Type);
    compose := fun _ _ _ _ _ => tt;
    assoc := fun _ _ _ _ _ _ _ => eq_refl;
    assoc_sym := fun _ _ _ _ _ _ _ => eq_refl;
    id := fun _ => tt;
    id_unit_left :=
      fun _ _ h =>
        match h as u return (tt = u) with
        | tt => eq_refl
        end;
    id_unit_right :=
      fun _ _ h =>
        match h as u return (tt = u) with
        | tt => eq_refl
        end
  |}.

Definition SingletonCat : Category :=
  {|
    Obj := (unit : Type);
    Hom := fun _ _ => (unit : Type);
    compose := fun _ _ _ _ _ => tt;
    assoc := fun _ _ _ _ _ _ _ => eq_refl;
    assoc_sym := fun _ _ _ _ _ _ _ => eq_refl;
    id := fun _ => tt;
    id_unit_left :=
      fun _ _ h =>
        match h as u return (tt = u) with
        | tt => eq_refl
        end;
    id_unit_right :=
      fun _ _ h =>
        match h as u return (tt = u) with
        | tt => eq_refl
        end
  |}.

Notation "0" := (EmptyCat) : category_scope.
Notation "1" := (SingletonCat) : category_scope.

Section Discr.
  Context (obj : Type).

  Program Definition Discr_Cat : Category :=
    {|
      Obj := obj;
      Hom := fun a b => a = b;
      compose := @eq_trans _;
      id := fun a => eq_refl
    |}.
    
End Discr.

Definition Type_n (n : nat) : Type := {x : nat| x < n}.

Notation "'Discr_n' n" :=
  (Discr_Cat (Type_n n)) (at level 200, n bigint) : category_scope.

Section Discr_Cat_Dual_Iso.
  Context (obj : Type).

  Local Hint Extern 1 => progress cbn.
  
  Program Definition Discr_Cat_Dual_Iso :
    (Discr_Cat obj ≃≃ (Discr_Cat obj)^op ::> Cat)%isomorphism%category
    :=
      {|
        iso_morphism := {|FO := fun x => x; FA := fun _ _ h => eq_sym h|};
        inverse_morphism := {|FO := fun x => x; FA := fun _ _ h => eq_sym h|}
      |}.

End Discr_Cat_Dual_Iso.

Section Discr_Cat_Iso.
  Context {obj obj' : Type} (I : (obj ≃≃ obj' ::> Type_Cat)%isomorphism).

  Program Definition Discr_Cat_Iso :
    ((Discr_Cat obj) ≃≃ (Discr_Cat obj') ::> Cat)%isomorphism
    :=
      {|
        iso_morphism :=
          {|
            FO := iso_morphism I;
            FA :=
              fun c d h =>
                match h in _ = y return
                      (iso_morphism I c) = (iso_morphism I y)
                with
                  eq_refl => eq_refl
                end
          |};
        inverse_morphism :=
          {|
            FO := inverse_morphism I;
            FA :=
              fun c d h =>
                match h in _ = y return
                      (inverse_morphism I c) = (inverse_morphism I y)
                with
                  eq_refl => eq_refl
                end
          |}
      |}.
  
End Discr_Cat_Iso.

Section Func_From_SingletonCat.
  Context {C : Category} (Cobj : C).

  Program Definition Func_From_SingletonCat : (SingletonCat –≻ C)%functor :=
    {|
      FO := fun _ => Cobj;
      FA := fun _ _ _ => id
    |}.

End Func_From_SingletonCat.

Section Discr_Func.
  Context {C : Category} {A : Type} (Omap : A → C).

  Program Definition Discr_Func : ((Discr_Cat A) –≻ C)%functor :=
    {|
      FO := Omap;
      
      FA := fun (a b : A) (h : a = b) =>
              match h in _ = y return ((Omap a) –≻ (Omap y))%morphism with
              | eq_refl => id
              end
    |}.

  Program Definition Discr_Func_op : ((Discr_Cat A)^op –≻ C)%functor :=
    {|
      FO := Omap;
      FA := fun (a b : A) (h : b = a) =>
              match h in _ = y return ((Omap y) –≻ (Omap b))%morphism with
              | eq_refl => id
              end
    |}.
    
End Discr_Func.
  
Arguments Discr_Func {_ _} _, _ {_} _.
Arguments Discr_Func_op {_ _} _, _ {_} _. *)

From Categories Require Import Functor.Const_Func Functor.Functor_Ops.
(* Categories.Functor.Const_Func:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Functor.

Section Const_Func.
  Context (C : Category) {D : Category} (a : @Obj D).

  Program Definition Const_Func : (C –≻ D)%functor :=
    {|
      FO := fun _ => a;
      FA := fun _ _ _ => id a
    |}.

End Const_Func. *)
(* Categories.Functor.Functor_Ops:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Functor.

Section Opposite_Functor.
  Context {C D : Category} (F : (C –≻ D)%functor).
  
  Local Open Scope morphism_scope.
  Local Open Scope object_scope.
    
  Program Definition Opposite_Functor : (C^op –≻ D^op)%functor :=
    {|
      FO := F _o;
      FA := fun _ _ h => F @_a _ _ h;
      F_id := fun a => F_id F a;
      F_compose := fun _ _ _ f g => F_compose F g f
    |}.

End Opposite_Functor.

Notation "F '^op'" := (Opposite_Functor F) : functor_scope.

Section Functor_Compose.
  Context {C C' C'' : Category} (F : (C –≻ C')%functor) (F' : (C' –≻ C'')%functor).

  Local Open Scope morphism_scope.
  Local Open Scope object_scope.
  
  Program Definition Functor_compose : (C –≻ C'')%functor :=
    {|
      FO := fun c => F' _o (F _o c);
      FA := fun c d f => F' _a (F _a f)
    |}.
  
End Functor_Compose.

Notation "F ∘ G" := (Functor_compose G F) : functor_scope. 

Section Functor_Assoc.
  Context {C1 C2 C3 C4 : Category}
          (F : (C1 –≻ C2)%functor)
          (G : (C2 –≻ C3)%functor)
          (H : (C3 –≻ C4)%functor).

  Local Open Scope functor_scope.
    
  Theorem Functor_assoc : (H ∘ G) ∘ F = H ∘ (G ∘ F).

End Functor_Assoc.

Program Definition Functor_id (C : Category) : (C –≻ C)%functor :=
  {|
    FO := fun x => x;
    FA := fun c d f => f
  |}.

Section Functor_Identity_Unit.
  Context  (C C' : Category) (F : (C –≻ C')%functor).

  Theorem Functor_id_unit_left : ((Functor_id C') ∘ F)%functor = F.

  Theorem Functor_id_unit_right : (Functor_compose (Functor_id _) F) = F.

End Functor_Identity_Unit. *)



Section Slice_Terminal.

  Context (C : Category) (c : C).



  Local Notation CA z :=

    (Build_Comma_Obj (Functor_id C) (Const_Func 1 c) _ tt z) (only parsing).



  Program Instance Slice_Terminal : (𝟙_ (Slice C c))%object :=

    {

      terminal := CA id;

      t_morph :=

        fun d =>

          {|

            CMH_left := (CMO_hom d);

            CMH_right :=

              match (CMO_trg d) as u return

                    Hom 1 u tt

              with

                tt => id

              end

          |}

    }.



  Next Obligation.

  Proof.

    apply Comma_Hom_eq_simplify.

    set (W := eq_trans (eq_sym (CMH_com f)) (CMH_com g)); cbn in W; auto.

    match goal with [|- ?A = ?B] => destruct A; destruct B; trivial end.

  Qed.    



End Slice_Terminal.

  

Section PullBack_Slice_Prod.

  Context {C : Category} {c : C} {f g : Slice C c}

          (PB : PullBack (CMO_hom f) (CMO_hom g)).



  Local Notation CA z :=

    (Build_Comma_Obj (Functor_id C) (Const_Func 1 c) _ tt z) (only parsing).



  Program Definition PullBack_Slice_Prod : (f × g)%object :=

    {|

      product := CA ((CMO_hom f) ∘ (pullback_morph_1 PB));

      Pi_1 :=

        {|

          CMH_left := pullback_morph_1 PB;

          CMH_right :=

            match (CMO_trg f) as u return

                  Hom 1 u tt

            with

              tt => id

            end

        |};

      Pi_2 :=

        {|

          CMH_left := pullback_morph_2 PB;

          CMH_right :=

            match (CMO_trg g) as u return

                  Hom 1 u tt

            with

              tt => id

            end

        |};

      Prod_morph_ex :=

        fun _ r1 r2 =>

          Build_Comma_Hom

            _

            _

            _

            (CA ((CMO_hom f) ∘ pullback_morph_1 PB))

            (pullback_morph_ex PB _ (CMH_left r1) (CMH_left r2) _)

            tt

            _

    |}.

  

  Local Obligation Tactic := idtac.  

  

  Next Obligation.

  Proof.

    cbn; simpl_ids; apply pullback_morph_com.

  Qed.    



  Next Obligation.

  Proof.

    intros p r1 r2.

    exact (eq_trans (eq_sym (CMH_com r1)) (CMH_com r2)).

  Qed.



  Next Obligation.

  Proof.  

    intros p r1 r2.

    cbn.

    etransitivity; [apply (CMH_com r1)|].

    symmetry.

    etransitivity;

      [|(apply

           (

             f_equal

               (fun x => compose x (CMO_hom f))

               (

                 pullback_morph_ex_com_1

                   PB

                   _

                   (CMH_left r1)

                   (CMH_left r2)

                   (PullBack_Slice_Prod_obligation_3 p r1 r2)

               )

           )

        )

      ].

    auto.

  Qed.

  

  Next Obligation.

  Proof.

    intros p r1 r2.

    apply Comma_Hom_eq_simplify.

    apply pullback_morph_ex_com_1.

    match goal with [|- _ = ?A] => destruct A; trivial end.

  Qed.    



  Next Obligation.

  Proof.

    intros p r1 r2.

    apply Comma_Hom_eq_simplify.

    apply pullback_morph_ex_com_2.

    match goal with [|- _ = ?A] => destruct A; trivial end.

  Qed.



  Next Obligation.

  Proof.

    intros p r1 r2 h h' H1 H2 H3 H4.

    destruct H3; destruct H4.

    set (H1' := f_equal CMH_left H1); clearbody H1'; clear H1.

    set (H2' := f_equal CMH_left H2); clearbody H2'; clear H2.

    cbn in H1', H2'.

    apply Comma_Hom_eq_simplify; cbn in *.

    {

      apply (pullback_morph_ex_unique

               PB _ (pullback_morph_1 PB ∘ CMH_left h)

               (pullback_morph_2 PB ∘ CMH_left h)); auto.

      repeat rewrite assoc_sym.

      apply (f_equal (fun x => compose _ x)).

      apply (pullback_morph_com PB).

    }    

    {

      match goal with [|- ?A = ?B] => destruct A; destruct B; trivial end.

    }    

  Qed.



End PullBack_Slice_Prod.



Section Slice_Prod_PullBack.

  Context {C : Category} {c : C} {f g : Slice C c}.



  Local Notation CA z :=

    (Build_Comma_Obj (Functor_id C) (Const_Func 1 c) _ tt z) (only parsing).



  Context (PR : (f × g)%object).

  

  Program Definition Slice_Prod_PullBack : PullBack (CMO_hom f) (CMO_hom g) :=

    {|

      pullback := (CMO_src (@product _ _ _ PR));

      pullback_morph_1 := CMH_left (Pi_1 PR);

      pullback_morph_2 := CMH_left (Pi_2 PR);

      pullback_morph_ex :=

        fun p r1 r2 H => CMH_left (Prod_morph_ex

                                  PR (CA ((CMO_hom f) ∘ r1))

                                  (Build_Comma_Hom _ _ (CA ((CMO_hom f) ∘ r1))

                                                   f r1 tt _)

                                  (Build_Comma_Hom _ _ (CA ((CMO_hom f) ∘ r1))

                                                   g r2 tt _))

    |}.



  Local Obligation Tactic := idtac.  

  

  Next Obligation.

  Proof.

    cbn.

    cbn_rewrite <- (CMH_com (Pi_1 PR)).

    cbn_rewrite <- (CMH_com (Pi_2 PR)).

    trivial.

  Qed.



  Next Obligation.

  Proof.

    intros p r1 r2 H.

    cbn in *.

    exact (f_equal

             CMH_left

             (Prod_morph_com_1 PR (CA ((CMO_hom f) ∘ r1))

                               (Build_Comma_Hom _ _ (CA ((CMO_hom f) ∘ r1))

                                                f r1 tt _)

                               (Build_Comma_Hom _ _ (CA ((CMO_hom f) ∘ r1))

                                                g r2 tt _))).

  Qed.

  

  Next Obligation.

  Proof.

    intros p r1 r2 H.

    cbn in *.

    exact (f_equal

             CMH_left

             (Prod_morph_com_2 PR (CA ((CMO_hom f) ∘ r1))

                               (Build_Comma_Hom _ _ (CA ((CMO_hom f) ∘ r1))

                                                f r1 tt _)

                               (Build_Comma_Hom _ _ (CA ((CMO_hom f) ∘ r1))

                                                g r2 tt _))).

  Qed.



  Next Obligation.

  Proof.

    intros p r1 r2 H h1 h2 H1 H2 H3 H4.

    destruct H3; destruct H4.

    evar (V1T : Type); evar (V1 : V1T).

    change h1 with

    (CMH_left

       (

         Build_Comma_Hom

           _

           _

           (CA (CMO_hom f ∘ CMH_left (Pi_1 PR) ∘ h2))

           (@product _ _ _ PR)

           h1

           tt

           V1

       )

    )%morphism.

    evar (V2T : Type); evar (V2 : V2T).

    change h2 with

    (CMH_left

       (

         Build_Comma_Hom

           _

           _

           (CA (CMO_hom f ∘ CMH_left (Pi_1 PR) ∘ h2))

           (@product _ _ _ PR)

           h2

           tt

           V2

       )

    )%morphism.

    apply f_equal.

    eapply (Prod_morph_unique

              PR (CA (CMO_hom f ∘ CMH_left (Pi_1 PR) ∘ h2)%morphism));

      eauto; apply Comma_Hom_eq_simplify; auto.

    Unshelve.

    {

      unfold V1T; clear V1T; cbn.

      set (W := f_equal (compose h1) (CMH_com (Pi_1 PR))).

      cbn in W.

      repeat rewrite assoc in W.

      set (N :=

             (eq_trans

                (id_unit_left _ _ _)

                (f_equal (fun x => compose x (CMO_hom f)) (eq_sym H1))

             )

          ).

      cbn in N.

      rewrite N.

      symmetry.

      auto.

    }

    {

      cbn in *.

      unfold V2T; clear V1 V1T V2T; cbn.

      set (W := f_equal (compose h2) (CMH_com (Pi_1 PR))).

      cbn in W.

      repeat rewrite assoc in W.

      set (N :=

             (eq_trans

                (id_unit_left _ _ _)

                (f_equal (fun x => compose x (CMO_hom f)) (eq_sym H1))

             )

          ).

      cbn in N.

      rewrite N.

      symmetry.

      rewrite H1.

      auto.

    }

  Qed.



End Slice_Prod_PullBack.



Section Has_PullBack_Slice_Has_Prod.

  Context {C : Category} (HPB : Has_PullBacks C) (c : C).



  Definition Has_PullBack_Slice_Has_Prod :

    Has_Products (Slice C c)

    :=

      fun f g =>

        PullBack_Slice_Prod (HPB _ _ _ (CMO_hom f) (CMO_hom g))

  .



End Has_PullBack_Slice_Has_Prod.



Section Slice_Has_Prod_Has_PullBack.

  Context {C : Category} (HPR : ∀ c : C, Has_Products (Slice C c)).



  Definition Slice_Has_Prod_Has_PullBack :

    Has_PullBacks C

    :=

      fun a b c f g =>

        Slice_Prod_PullBack

          (HPR

             _

             (Build_Comma_Obj (Functor_id C) (Const_Func 1 c) _ tt f)

             (Build_Comma_Obj (Functor_id C) (Const_Func 1 c) _ tt g)

          )

  .

  

End Slice_Has_Prod_Has_PullBack.

    

Definition LCCC (C : Category) : Type := ∀ (c : C), CCC (Slice C c).

Existing Class LCCC.

