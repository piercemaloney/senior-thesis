From Categories Require Import Essentials.Notations.
(* Categories.Essentials.Notations:
Notation "∀ x .. y , P" := (forall x, .. (forall y, P) ..)
                             (at level 200, x binder, y binder, right associativity) : type_scope.

Notation "∃ x .. y , P" := (exists x, .. (exists y, P) ..)
  (at level 200, x binder, y binder, right associativity) : type_scope.

Notation "x ∨ y" := (x \/ y) (at level 85, right associativity) : type_scope.

Notation "x ∧ y" := (x /\ y) (at level 80, right associativity) : type_scope.

Notation "x → y" := (x -> y)
  (at level 90, y at level 200, right associativity): type_scope.

Notation "x ↔ y" := (x <-> y) (at level 95, no associativity): type_scope.

Notation "¬ x" := (~x) (at level 75, right associativity) : type_scope.

Notation "x ≠ y" := (x <> y) (at level 70) : type_scope.

Notation "x ≤ y" := (le x y) (at level 70, no associativity).

Notation "x ≥ y" := (ge x y) (at level 70, no associativity).

Reserved Notation "C '^op'" (at level 50, no associativity).

Reserved Notation "a –≻ b" (at level 90, b at level 200, right associativity).

Reserved Notation "f '⁻¹'" (at level 50, no associativity).

Reserved Notation "a ≃ b" (at level 70, no associativity).

Reserved Notation "a ≃≃ b ::> C" (at level 70, no associativity).

Reserved Notation "f ∘ g" (at level 51, right associativity).

Reserved Notation "f '∘_h' g" (at level 51, right associativity).

Reserved Notation "a ≫–> b" (at level 100, no associativity).

Reserved Notation "a –≫ b" (at level 100, no associativity).

Reserved Notation "F '_o'" (at level 50, no associativity).

Reserved Notation "F '_a'" (at level 50, no associativity).

Reserved Notation "F '@_a'" (at level 50, no associativity).

Reserved Notation "F ⊣ G" (at level 100, no associativity).

Reserved Notation "F ⊣_hom G" (at level 100, no associativity).

Reserved Notation "F ⊣_ucu G" (at level 100, no associativity).

Reserved Notation "a × b" (at level 80, no associativity).

Reserved Notation "a ⇑ b" (at level 79, no associativity).

Reserved Notation "'Π' m" (at level 50, no associativity).

Reserved Notation "'Σ' m" (at level 50, no associativity).

Reserved Notation "'Π_' C ↓ m" (at level 50, no associativity).

Reserved Notation "'Σ_' C ↓ m" (at level 50, no associativity).

Delimit Scope category_scope with category.

Delimit Scope morphism_scope with morphism.

Delimit Scope object_scope with object.

Delimit Scope functor_scope with functor.

Delimit Scope nattrans_scope with nattrans.

Delimit Scope nattrans_scope with nattrans.

Delimit Scope natiso_scope with natiso.

Delimit Scope isomorphism_scope with isomorphism.

Delimit Scope preorder_scope with preorder. *)

From Categories Require Import Essentials.Types.
(* Categories.Essentials.Types:
Global Set Primitive Projections.

Global Set Universe Polymorphism.

Global Unset Universe Minimization ToSet.

Inductive Empty : Type :=.

Hint Extern 1 =>
let tac := (repeat intros ?); match goal with [H : Empty |- _] => contradict H end in
match goal with
  | [|- context[Empty]] => tac
  | [H : context[Empty] |- _] => tac
end
.

Record prod (A B : Type) := {fst : A; snd : B}.

Arguments fst {_ _ } _.
Arguments snd {_ _ } _.
Arguments Build_prod {_ _ } _ _.

Notation "( X , Y )" := (Build_prod X Y).
Notation "X * Y" := (prod X Y) : type_scope. *)

From Categories Require Import Essentials.Facts_Tactics.
(* Categories.Essentials.Facts_Tactics:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.

Require Export Coq.Program.Tactics.
Require Export Coq.Program.Equality.
Require Export Coq.Logic.FunctionalExtensionality.
Require Export Coq.Logic.ProofIrrelevance.

Definition equal_f : ∀ {A B : Type} {f g : A → B}, f = g → ∀ x : A, f x = g x.

Definition f_equal : ∀ (A B : Type) (f : A → B) (x y : A), x = y → f x = f y.

Arguments f_equal [_ _] _ [_ _] _.

Ltac basic_simpl :=
  let simpl_prod _ :=
      match goal with
        [H : prod _ _ |- _] =>
        let H1 := fresh H "1" in
        let H2 := fresh H "2" in
        destruct H as [H1 H2]
      end
  in
  let simpl_sig _ :=
      match goal with
        [H : @sig _ _ |- _] =>
        let H1 := fresh H "1" in
        let H2 := fresh H "2" in
        destruct H as [H1 H2]
      end
  in
  let basic_simpl_helper _ :=
      cbn in *; intros;
        repeat simpl_prod tt;
        repeat simpl_sig tt
  in
  repeat basic_simpl_helper tt
.

Global Obligation Tactic := basic_simpl; auto.

Ltac PIR :=
  let pir_helper _ :=
      match goal with
      |[H : ?A, H' : ?A|- _] =>
       match type of A with
       | Prop =>
         destruct (proof_irrelevance _ H H')
       end
      end
  in
  repeat pir_helper tt
.

Ltac ElimEq := repeat match goal with [H : _ = _|- _] => destruct H end.

Hint Extern 1 => progress ElimEq.

Ltac cbn_rewrite W :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite H; clear H
.

Ltac cbn_rewrite_in W V :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite H in V; clear H
.

Ltac cbn_rewrite_back W :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite <- H; clear H
.

Ltac cbn_rewrite_back_in W V :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite <- H in V; clear H
.

Tactic Notation "cbn_rewrite" constr(W) := cbn_rewrite W.
Tactic Notation "cbn_rewrite" constr(W) "in" hyp_list(V) := cbn_rewrite_in W V.
Tactic Notation "cbn_rewrite" "<-" constr(W) := cbn_rewrite_back W.
Tactic Notation "cbn_rewrite" "<-" constr(W) "in" hyp_list(V) := cbn_rewrite_back_in W V.

Lemma sig_proof_irrelevance {A : Type} (P : A → Prop) (X Y : sig P) : proj1_sig X = proj1_sig Y → X = Y.

Hint Extern 2 (exist ?A _ _ = exist ?A _ _) => apply sig_proof_irrelevance.

Ltac FunExt :=
progress (
    repeat (
        match goal with
          [|- _ = _] =>
          let x := fresh "x" in
          extensionality x
        end
      )
  )
.

Hint Extern 1 => FunExt.

Lemma pair_eq (A B : Type) (a b : A * B) : fst a = fst b → snd a = snd b → a = b.

Hint Resolve pair_eq.

Ltac revert_clearbody_all :=
 repeat lazymatch goal with H:_ |- _ => try clearbody H; revert H end.

Ltac hyp_stack :=
 constr:(ltac:(revert_clearbody_all;constructor) : True).

Ltac next_hyp hs step last :=
 lazymatch hs with (?hs' ?H) => step H hs' | _ => last end.

Tactic Notation "dohyps" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := tac H; next_hyp hs step idtac in
 next_hyp hs step idtac.

Tactic Notation "dohyps" "reverse" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := next_hyp hs step idtac; tac H in
 next_hyp hs step idtac.

Tactic Notation "do1hyp" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := tac H + next_hyp hs step fail in
 next_hyp hs step fail.

Tactic Notation "do1hyp" "reverse" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := next_hyp hs step fail + tac H in
 next_hyp hs step fail. *)

From Categories Require Import Category.Main.
(* Categories.Category.Main:
From Categories Require Export Category.Category.
From Categories Require Export Category.Morph.
From Categories Require Export Category.Opposite.
From Categories Require Export Category.SubCategory.
From Categories Require Export Category.Composable_Chain. *)

From Categories Require Import Functor.Main.
(* Categories.Functor.Main:
From Categories Require Export Functor.Functor.
From Categories Require Export Functor.Functor_Extender.
From Categories Require Export Functor.Functor_Image.
From Categories Require Export Functor.Functor_Ops.
From Categories Require Export Functor.Functor_Properties.
From Categories Require Export Functor.Const_Func.
From Categories Require Export Functor.Const_Func_Functor. *)

From Categories Require Import Ext_Cons.Arrow.
(* Categories.Ext_Cons.Arrow:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Coq_Cats.Type_Cat.Type_Cat.

Section Arrow.
  Local Open Scope morphism_scope.

  Record Arrow (C : Category) :=
    {
      Orig : Obj;
      Targ : Obj;
      Arr : Orig –≻ Targ
    }.

  Arguments Orig {_} _.
  Arguments Targ {_} _.
  Arguments Arr {_} _.

  Coercion Arr : Arrow >-> Hom.

  Record Arrow_Hom {C : Category} (a b : Arrow C) :=
    {
      Arr_H : (Orig a) –≻ (Orig b);
      Arr_H' : (Targ a) –≻ (Targ b);
      Arr_Hom_com : Arr_H' ∘ (Arr a) = (Arr b) ∘ Arr_H
    }.
  Arguments Arr_H {_ _ _} _.
  Arguments Arr_H' {_ _ _} _.
  Arguments Arr_Hom_com {_ _ _} _.

  Context (C : Category).

  Section Arrow_Hom_eq_simplify.
    Context {a b : Arrow C} (f g : Arrow_Hom a b).

    Lemma Arrow_Hom_eq_simplify : Arr_H f = Arr_H g → Arr_H' f = Arr_H' g → f = g.

  End Arrow_Hom_eq_simplify.

  Section Compose_id.
    Context {x y z} (h : Arrow_Hom x y) (h' : Arrow_Hom y z).

    Program Definition Arrow_Hom_compose : Arrow_Hom x z :=
      {|
        Arr_H := (Arr_H h') ∘ (Arr_H h);
        Arr_H' := (Arr_H' h') ∘ (Arr_H' h)
      |}.

    Program Definition Arrow_id : Arrow_Hom x x :=
      {|
        Arr_H := id;
        Arr_H' := id
      |}.

  End Compose_id.

End Arrow.

Hint Extern 1 (?A = ?B :> Arrow_Hom _ _) => apply Arrow_Hom_eq_simplify; simpl.

Arguments Orig {_} _.
Arguments Targ {_} _.
Arguments Arr {_} _.

Arguments Arr_H {_ _ _} _.
Arguments Arr_H' {_ _ _} _.
Arguments Arr_Hom_com {_ _ _} _.

Program Definition Arrow_to_Arrow_OP (C : Category) (ar : Arrow C) :
  Arrow (C ^op) :=
  {|
    Arr := ar
  |}.

Program Definition Arrow_OP_Iso (C : Category) :
  ((Arrow C) ≃≃ (Arrow (C ^op)) ::> Type_Cat)%isomorphism :=
  {|
    iso_morphism := Arrow_to_Arrow_OP C;
    inverse_morphism := Arrow_to_Arrow_OP (C ^op)
  |}. *)

From Categories Require Import Basic_Cons.Terminal.
(* Categories.Basic_Cons.Terminal:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Main.

Class Terminal (C : Category) : Type :=
{
  terminal : C;
  t_morph : ∀ (d : Obj), (d –≻ terminal)%morphism;
  t_morph_unique : ∀ (d : Obj) (f g : (d –≻ terminal)%morphism), f = g
}.

Arguments terminal {_} _.
Arguments t_morph {_} _ _.
Arguments t_morph_unique {_} _ _ _ _.

Coercion terminal : Terminal >-> Obj.

Notation "𝟙_ C" := (Terminal C) (at level 75) : object_scope.

Theorem Terminal_iso {C : Category} (T T' : (𝟙_ C)%object) :
  (T ≃ T')%isomorphism.

Definition Initial (C : Category) := (𝟙_ (C ^op))%object.
Existing Class Initial.

Notation "𝟘_ C" := (Initial C) (at level 75) : object_scope. *)

From Categories Require Import Basic_Cons.Equalizer.
(* Categories.Basic_Cons.Equalizer:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.

Local Open Scope morphism_scope.

Section Equalizer.
  Context {C : Category} {a b : Obj} (f g : a –≻ b).

  Local Open Scope morphism_scope.
  
  Record Equalizer : Type :=
    {
      equalizer : C;

      equalizer_morph : equalizer –≻ a;

      equalizer_morph_com : f ∘ equalizer_morph = g ∘ equalizer_morph;

      equalizer_morph_ex (e' : Obj) (eqm : e' –≻ a) :
        f ∘ eqm = g ∘ eqm → e' –≻ equalizer;

      equalizer_morph_ex_com (e' : Obj) (eqm : e' –≻ a)
                             (eqmc : f ∘ eqm = g ∘ eqm)
      : equalizer_morph ∘ (equalizer_morph_ex e' eqm eqmc) = eqm;

      equalizer_morph_unique (e' : Obj) (eqm : e' –≻ a)
                             (com : f ∘ eqm = g ∘ eqm) (u u' : e' –≻ equalizer)
      : equalizer_morph ∘ u = eqm → equalizer_morph ∘ u' = eqm → u = u'
    }.

  Coercion equalizer : Equalizer >-> Obj.
  
  Theorem Equalizer_iso (e1 e2 : Equalizer) : (e1 ≃ e2)%isomorphism.

End Equalizer.

Arguments equalizer_morph {_ _ _ _ _} _.
Arguments equalizer_morph_com {_ _ _ _ _} _.
Arguments equalizer_morph_ex {_ _ _ _ _} _ {_ _} _.
Arguments equalizer_morph_ex_com {_ _ _ _ _} _ {_ _} _.
Arguments equalizer_morph_unique {_ _ _ _ _} _ {_ _ _} _ _ _ _.

Arguments Equalizer _ {_ _} _ _, {_ _ _} _ _.

Definition Has_Equalizers (C : Category) : Type :=
  ∀ (a b : C) (f g : a –≻ b), Equalizer f g.

Existing Class Has_Equalizers.

Definition CoEqualizer {C : Category} := @Equalizer (C^op).

Arguments CoEqualizer _ {_ _} _ _, {_ _ _} _ _.

Definition Has_CoEqualizers (C : Category) : Type := Has_Equalizers (C^op).

Existing Class Has_CoEqualizers. *)

From Categories Require Import Basic_Cons.Facts.Equalizer_Monic.
(* Categories.Basic_Cons.Facts.Equalizer_Monic:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.

From Categories Require Import Basic_Cons.Equalizer.

Section Equalizer_Monic.
  Context {C : Category} {a b} (f g : (a –≻ b)%morphism) {e : Equalizer f g}.

  Program Definition Equalizer_Monic : (e ≫–> a)%morphism :=
    {|
      mono_morphism := equalizer_morph e
    |}.

End Equalizer_Monic. *)

From Categories Require Import Coq_Cats.Type_Cat.Card_Restriction.
(* Categories.Coq_Cats.Type_Cat.Card_Restriction:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Coq_Cats.Type_Cat.Type_Cat.

Record Card_Restriction : Type :=
{
  Card_Rest : Type → Prop;

  Card_Rest_Respect : ∀ (A B : Type),
      (A ≃≃ B ::> Type_Cat)%isomorphism → Card_Rest A → Card_Rest B
}.

Coercion Card_Rest : Card_Restriction >-> Funclass.

Program Definition Finite : Card_Restriction :=
  {|
    Card_Rest :=
      fun A => inhabited {n : nat & (A ≃≃ {x : nat | x < n} ::> Type_Cat)%isomorphism}
  |}. *)

From Categories Require Import Archetypal.Discr.Discr Archetypal.Discr.NatFacts.
(* Categories.Archetypal.Discr.Discr:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Functor.
From Categories Require Import Cat.Cat.
From Categories Require Import Coq_Cats.Type_Cat.Type_Cat.

Definition EmptyCat : Category :=
  {|
    Obj := (Empty : Type);
    Hom := fun _ _ => (unit : Type);
    compose := fun _ _ _ _ _ => tt;
    assoc := fun _ _ _ _ _ _ _ => eq_refl;
    assoc_sym := fun _ _ _ _ _ _ _ => eq_refl;
    id := fun _ => tt;
    id_unit_left :=
      fun _ _ h =>
        match h as u return (tt = u) with
        | tt => eq_refl
        end;
    id_unit_right :=
      fun _ _ h =>
        match h as u return (tt = u) with
        | tt => eq_refl
        end
  |}.

Definition SingletonCat : Category :=
  {|
    Obj := (unit : Type);
    Hom := fun _ _ => (unit : Type);
    compose := fun _ _ _ _ _ => tt;
    assoc := fun _ _ _ _ _ _ _ => eq_refl;
    assoc_sym := fun _ _ _ _ _ _ _ => eq_refl;
    id := fun _ => tt;
    id_unit_left :=
      fun _ _ h =>
        match h as u return (tt = u) with
        | tt => eq_refl
        end;
    id_unit_right :=
      fun _ _ h =>
        match h as u return (tt = u) with
        | tt => eq_refl
        end
  |}.

Notation "0" := (EmptyCat) : category_scope.
Notation "1" := (SingletonCat) : category_scope.

Section Discr.
  Context (obj : Type).

  Program Definition Discr_Cat : Category :=
    {|
      Obj := obj;
      Hom := fun a b => a = b;
      compose := @eq_trans _;
      id := fun a => eq_refl
    |}.
    
End Discr.

Definition Type_n (n : nat) : Type := {x : nat| x < n}.

Notation "'Discr_n' n" :=
  (Discr_Cat (Type_n n)) (at level 200, n bigint) : category_scope.

Section Discr_Cat_Dual_Iso.
  Context (obj : Type).

  Local Hint Extern 1 => progress cbn.
  
  Program Definition Discr_Cat_Dual_Iso :
    (Discr_Cat obj ≃≃ (Discr_Cat obj)^op ::> Cat)%isomorphism%category
    :=
      {|
        iso_morphism := {|FO := fun x => x; FA := fun _ _ h => eq_sym h|};
        inverse_morphism := {|FO := fun x => x; FA := fun _ _ h => eq_sym h|}
      |}.

End Discr_Cat_Dual_Iso.

Section Discr_Cat_Iso.
  Context {obj obj' : Type} (I : (obj ≃≃ obj' ::> Type_Cat)%isomorphism).

  Program Definition Discr_Cat_Iso :
    ((Discr_Cat obj) ≃≃ (Discr_Cat obj') ::> Cat)%isomorphism
    :=
      {|
        iso_morphism :=
          {|
            FO := iso_morphism I;
            FA :=
              fun c d h =>
                match h in _ = y return
                      (iso_morphism I c) = (iso_morphism I y)
                with
                  eq_refl => eq_refl
                end
          |};
        inverse_morphism :=
          {|
            FO := inverse_morphism I;
            FA :=
              fun c d h =>
                match h in _ = y return
                      (inverse_morphism I c) = (inverse_morphism I y)
                with
                  eq_refl => eq_refl
                end
          |}
      |}.
  
End Discr_Cat_Iso.

Section Func_From_SingletonCat.
  Context {C : Category} (Cobj : C).

  Program Definition Func_From_SingletonCat : (SingletonCat –≻ C)%functor :=
    {|
      FO := fun _ => Cobj;
      FA := fun _ _ _ => id
    |}.

End Func_From_SingletonCat.

Section Discr_Func.
  Context {C : Category} {A : Type} (Omap : A → C).

  Program Definition Discr_Func : ((Discr_Cat A) –≻ C)%functor :=
    {|
      FO := Omap;
      
      FA := fun (a b : A) (h : a = b) =>
              match h in _ = y return ((Omap a) –≻ (Omap y))%morphism with
              | eq_refl => id
              end
    |}.

  Program Definition Discr_Func_op : ((Discr_Cat A)^op –≻ C)%functor :=
    {|
      FO := Omap;
      FA := fun (a b : A) (h : b = a) =>
              match h in _ = y return ((Omap y) –≻ (Omap b))%morphism with
              | eq_refl => id
              end
    |}.
    
End Discr_Func.
  
Arguments Discr_Func {_ _} _, _ {_} _.
Arguments Discr_Func_op {_ _} _, _ {_} _. *)
(* Categories.Archetypal.Discr.NatFacts:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Main.
From Categories Require Import Ext_Cons.Arrow.
From Categories Require Import Coq_Cats.Type_Cat.Type_Cat.
From Categories Require Import Cat.Cat Cat.Cat_Iso.
From Categories Require Import NatTrans.NatTrans NatTrans.NatIso.
From Categories Require Import Archetypal.Discr.Discr.

Section Discr_Func_Iso.
  Context {C : Category} {A : Type} (Omap : A → C).

  Local Hint Extern 1 => apply NatTrans_eq_simplify; cbn.
  
  Program Definition Discr_Func_Iso :
    (
      (@Discr_Func (C^op) A Omap) ≃ ((@Discr_Func_op C A Omap)^op)%functor
    )%natiso
    :=
      {|
        iso_morphism :=
          {|
            Trans := fun _ => id
          |};
        inverse_morphism :=
          {|
            Trans := fun _ => id
          |}
      |}
  .
    
End Discr_Func_Iso.

Section Func_From_SingletonCat_Opposite.
  Context {C : Category} (x : C).

  Local Hint Extern 1 => apply NatTrans_eq_simplify; cbn.
  
  Program Definition Func_From_SingletonCat_Opposite :
    (
      (((@Func_From_SingletonCat C x)^op)
         ≃ (@Func_From_SingletonCat (C ^op) x))%functor
    )%natiso
    :=
      {|
        iso_morphism :=
          {|
            Trans := fun _ => id
          |};
        inverse_morphism :=
          {|
            Trans := fun _ => id
          |}
      |}
  .
    
End Func_From_SingletonCat_Opposite.

Section Discr_Func_Arrow_Iso.
  Context {C D : Category} (arrmap : (Arrow (C^op)) → D).

  Definition Discr_Cat_ArrowOp_Discr_Cat_Arrow_Op :
    ((((Discr_Cat (Arrow (C^op)))^op)%category)
       ≃≃ ((Discr_Cat (Arrow C))^op)%category ::> Cat)%isomorphism
    :=
      Opposite_Cat_Iso (Discr_Cat_Iso ((Arrow_OP_Iso C)⁻¹))
  .

  Local Hint Extern 1 => apply NatTrans_eq_simplify; cbn.

  Program Definition Discr_Func_Arrow_Iso :
    (
      (
        (Discr_Func_op (fun x : Arrow C => arrmap (Arrow_to_Arrow_OP C x)))
          ∘ (iso_morphism Discr_Cat_ArrowOp_Discr_Cat_Arrow_Op)
      )%functor
        ≃ ((@Discr_Func_op D (Arrow (C^op)) arrmap))%functor
    )%natiso
    :=
      {|
        iso_morphism :=
          {|
            Trans := fun c => id
          |};
        inverse_morphism :=
          {|
            Trans := fun c => id
          |}
      |}
  .
    
End Discr_Func_Arrow_Iso.

Local Hint Extern 1 =>
match goal with [z : Arrow (Discr_Cat _) |- _] => destruct z as [? ? []] end.

Program Definition Discr_Hom_Iso (A : Type) :
  (A ≃≃ Arrow (Discr_Cat A) ::> Type_Cat)%isomorphism :=
  (Build_Isomorphism
     Type_Cat
     _
     _
     (fun a => (Build_Arrow (Discr_Cat A) _ _ (eq_refl a)))
     (fun a : (Arrow (Discr_Cat _)) => Orig a)
     _
     _
  ).

Section Discretize.
  Context {C D : Category} {F G : (C –≻ D)%functor} (N : (F –≻ G)%nattrans).

  Program Definition Discretize :
    ((Discr_Func (F _o)%object) –≻ (Discr_Func (G _o)%object))%nattrans
    :=
    {|
      Trans := Trans N
    |}.
  
End Discretize. *)



From Categories Require Import Limits.GenProd_GenSum.
(* Categories.Limits.GenProd_GenSum:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Main.
From Categories Require Import Archetypal.Discr.Discr Archetypal.Discr.NatFacts.
From Categories Require Import Coq_Cats.Type_Cat.Type_Cat.
From Categories Require Import Cat.Cat_Iso.
From Categories Require Import NatTrans.NatTrans NatTrans.Func_Cat.
From Categories Require Import KanExt.LocalFacts.NatIso.

From Categories Require Import Limits.Limit.
From Categories Require Import Limits.Isomorphic_Cat.

Section GenProd_Sum.
  Context {A : Type} {C : Category} (map : A → C).

  Definition GenProd := Limit (Discr_Func map).

  Identity Coercion GenProd_Limit : GenProd >-> Limit.
  
  Definition GenSum := CoLimit (Discr_Func_op map).

  Identity Coercion GenSum_CoLimit : GenSum >-> CoLimit.

End GenProd_Sum.

Arguments GenProd {_}%type {_}%category _, {_} _ _.
Arguments GenSum {_}%type {_}%category _, {_} _ _.

Notation "'Π' m" := (GenProd m) : object_scope.

Notation "'Σ' m" := (GenSum m) : object_scope.

Notation "'Π_' C ↓ m" := (GenProd C m) : object_scope.

Notation "'Σ_' C ↓ m" := (GenSum C m) : object_scope.

Section GenProd_to_GenSum.
  Context {A : Type} {C : Category} {map : A → C} (L : (Π map)%object).
  
  Definition GenProd_to_GenSum : (Σ_ (C^op) ↓ map)%object :=
    Local_Right_KanExt_Iso ((@Discr_Func_Iso (C^op) A map)⁻¹) L.

End GenProd_to_GenSum.

Section GenSum_to_GenProd.
  Context {A : Type} {C : Category} {map : A → C} (L : (Σ map)%object).
  
  Definition GenSum_to_GenProd : (Π_ (C^op) ↓ map)%object :=
    Local_Right_KanExt_Iso (Discr_Func_Iso map) L.

End GenSum_to_GenProd.

Section GenSum_IsoType.
  Context {A B : Type} (Iso : (A ≃≃ B ::> Type_Cat)%isomorphism) {C : Category}
          (SM : forall f : A → C, (Σ f)%object).

  Program Definition GenSum_IsoType_map_Iso (map : B → C):
    (
      ((((Discr_Func_op map)^op)%functor)
         ≃≃ ((Discr_Func_op
                (fun x : A => map ((iso_morphism Iso) x))
                ∘ (iso_morphism (Opposite_Cat_Iso
                                   (Inverse_Isomorphism
                                      (Discr_Cat_Iso Iso)))))^op
            )%functor
        ::> Func_Cat _ _)%isomorphism
    )%morphism
    :=
      {|
        iso_morphism :=
          {|
            Trans :=
              Trans
                (iso_morphism
                   (IsoCat_NatIso (Opposite_Cat_Iso
                                     (Discr_Cat_Iso Iso)) (Discr_Func_op map))
                )
          |};
        inverse_morphism :=
          {|
            Trans :=
              Trans
                (inverse_morphism
                   (IsoCat_NatIso (Opposite_Cat_Iso
                                     (Discr_Cat_Iso Iso)) (Discr_Func_op map))
                )
          |}
      |}
  .
  
  Definition  GenSum_IsoType (map : B → C) : (Σ map)%object :=
    Local_Right_KanExt_Iso
      (GenSum_IsoType_map_Iso map)
      (
        CoLimit_From_Isomorphic_Cat
          (Opposite_Cat_Iso (Inverse_Isomorphism (Discr_Cat_Iso Iso)))
          (SM (fun x : A => map ((iso_morphism Iso) x)))
      ).

End GenSum_IsoType. *)

From Categories Require Import Limits.Limit.
(* Categories.Limits.Limit:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Main.
From Categories Require Import Basic_Cons.Terminal.
From Categories Require Import Ext_Cons.Arrow.
From Categories Require Import Coq_Cats.Type_Cat.Card_Restriction.
From Categories Require Export NatTrans.NatTrans NatTrans.Operations.
From Categories Require Export KanExt.Local KanExt.Global KanExt.GlobalDuality
        KanExt.GlobaltoLocal KanExt.LocaltoGlobal KanExt.LocalFacts.Main.
From Categories Require Export Cat.Terminal.

Local Open Scope functor_scope.

Section Limit.
  Context {J C : Category} (D : J –≻ C).

  Definition Cone := LoKan_Cone (Functor_To_1_Cat J) D.

  Definition Cone_Morph Cn Cn' :=
    @LoKan_Cone_Morph _ _ (Functor_To_1_Cat J) _ D Cn Cn'.
  
  Definition Limit : Type := Local_Right_KanExt (Functor_To_1_Cat J) D.

  Definition limit_to_cone (l : Limit) : Cone := (LRKE l).

  Coercion limit_to_cone : Limit >-> Cone.
  
  Definition cone_to_obj (cn : Cone) : C := (cone_apex cn) _o tt.

  Coercion cone_to_obj : Cone >-> Obj.

  Definition is_Limit (Cn : Cone) :=
    is_Cone_Local_Right_KanExt (Functor_To_1_Cat J) D Cn.

  Definition is_Limit_Limit {Cn : Cone} (il : is_Limit Cn) : Limit :=
    is_Cone_Local_Right_KanExt_Local_Right_KanExt (Functor_To_1_Cat J) D il.

  Definition Limit_is_Limit {L : Limit} : is_Limit L :=
    Local_Right_KanExt_is_Cone_Local_Right_KanExt (Functor_To_1_Cat J) D L.
  
End Limit.

Program Definition Limit_Iso {J C : Category} {D : J –≻ C} (l l' : Limit D) :
  (l ≃≃ l' ::> C)%isomorphism :=
  {|
    iso_morphism :=
      Trans
        (cone_morph (iso_morphism (Local_Right_KanExt_unique _ _ l l')))
        tt;
    inverse_morphism :=
      Trans
        (cone_morph (inverse_morphism (Local_Right_KanExt_unique _ _ l l')))
        tt
  |}.

Next Obligation.
Proof (
    f_equal
      (fun x : LoKan_Cone_Morph l l => Trans (cone_morph x) tt)
      (left_inverse (Local_Right_KanExt_unique _ _ l l'))
  ).

Next Obligation.
Proof (
    f_equal
      (fun x : LoKan_Cone_Morph l' l' => Trans (cone_morph x) tt)
      (right_inverse (Local_Right_KanExt_unique _ _ l l'))
  ).

Definition Has_Restr_Limits (C : Category) (P : Card_Restriction) :=
  ∀ {J : Category} (D : J –≻ C), P J → P (Arrow J) → Limit D.

Definition Complete (C : Category) :=
  ∀ J : Category, Right_KanExt (Functor_To_1_Cat J) C.

Existing Class Complete.

Definition LimitOf {C D : Category} {H : Complete D} (F : C –≻ D) : Limit F :=
  Global_to_Local_Right _ _ (H _) F.

Section Restricted_Limits_to_Complete.
  Context {C : Category} {P : Card_Restriction} (HRL : Has_Restr_Limits C P).

  Definition No_Restriction_Complete : (∀ t, P t) → Complete C :=
    fun All_Ps J => Local_to_Global_Right
                   _ _ (fun D => HRL _ D (All_Ps J) (All_Ps (Arrow J))).

End Restricted_Limits_to_Complete.

Section Complete_to_Restricted_Limits.
  Context (C : Category) {CC : Complete C} (P : Card_Restriction).
  
  Definition Complete_Has_Restricted_Limits : Has_Restr_Limits C P :=
    fun J D _ _ => Global_to_Local_Right _ _ (CC _) D.

End Complete_to_Restricted_Limits.

Section Continuous.
  Context
    {C D : Category}
    (CC : Complete C)
    (G : (C –≻ D)%functor)
  .

  Section Cone_Conv.
    Context
      {J : Category}
      {F : (J –≻ C)%functor}
      (Cn : Cone F)
    .
    
    Program Definition Cone_Conv : Cone (G ∘ F)%functor
      :=
        {|
          cone_apex :=
            (G ∘ (cone_apex Cn))%functor;
          cone_edge :=
            (((NatTrans_id G)
                ∘_h (cone_edge Cn)) ∘ (NatTrans_Functor_assoc _ _ _))%nattrans
        |}
    .

  End Cone_Conv.

  Definition Continuous :=
    ∀ (J : Category) (F : (J –≻ C)%functor),
      is_Cone_Local_Right_KanExt _ _ (Cone_Conv (LRKE (LimitOf F)))
  .

End Continuous.

Section CoLimit.
  Context {J C : Category} (D : J –≻ C).

  Definition CoCone :=
    LoKan_Cone (Functor_To_1_Cat J^op) (D^op).

  Definition CoCone_Morph Cn Cn' :=
    @LoKan_Cone_Morph _ _ (Functor_To_1_Cat J^op) _ (D^op) Cn Cn'.

  Definition CoLimit := Local_Left_KanExt (Functor_To_1_Cat J) D.

  Definition is_CoLimit (Cn : CoCone) :=
    is_Cone_Local_Right_KanExt (Functor_To_1_Cat (J^op)) (D^op) Cn.

  Definition is_CoLimit_CoLimit {Cn : CoCone} (il : is_CoLimit Cn) : CoLimit :=
    is_Cone_Local_Right_KanExt_Local_Right_KanExt
      (Functor_To_1_Cat (J^op)) (D^op) il.

  Definition CoLimit_is_CoLimit {L : CoLimit} : is_CoLimit L :=
    Local_Right_KanExt_is_Cone_Local_Right_KanExt
      (Functor_To_1_Cat (J^op)) (D^op) L.

End CoLimit.

Definition Has_Restr_CoLimits (C : Category) (P : Card_Restriction) :=
  ∀ {J : Category} (D : J –≻ C), P J → P (Arrow J) → CoLimit D.

Definition CoComplete (C : Category) :=
  ∀ J : Category, Left_KanExt (Functor_To_1_Cat J) C.

Existing Class CoComplete.

Definition CoLimitOf {C D : Category} {H : CoComplete D} (F : C –≻ D) :
  CoLimit F := Global_to_Local_Left _ _ (H _) F.

Definition Complete_to_CoComplete_Op {C : Category} {CC : Complete C}
  : CoComplete (C ^op) :=
fun D => KanExt_Right_to_Left (Functor_To_1_Cat D ^op) C (CC (D ^op)%category).

Definition CoComplete_to_Complete_Op {C : Category} {CC : CoComplete C}
  : Complete (C ^op) :=
    fun D => KanExt_Left_to_Right (Functor_To_1_Cat D ^op) C (CC (D ^op)%category).

Section Restricted_CoLimits_to_CoComplete.
  Context {C : Category} {P : Card_Restriction} (HRL : Has_Restr_CoLimits C P).

  Definition No_Restriction_CoComplete : (∀ t, P t) → CoComplete C :=
    fun All_Ps J =>
      Local_to_Global_Left _ _ (fun D => HRL _ D (All_Ps J) (All_Ps (Arrow J))).

End Restricted_CoLimits_to_CoComplete.

Section CoComplete_to_Restricted_CoLimits.
  Context (C : Category) {CC : CoComplete C} (P : Card_Restriction).
  
  Definition CoComplete_Has_Restricted_CoLimits : Has_Restr_CoLimits C P :=
    fun J D _ _ => Global_to_Local_Left _ _ (CC _) D.

End CoComplete_to_Restricted_CoLimits.

Definition Has_Restr_Limits_to_Has_Restr_CoLimits_Op
        {C : Category} {P : Card_Restriction}
        (HRL : Has_Restr_Limits C P) :
  Has_Restr_CoLimits (C ^op) P :=
  (fun (D : Category)
       (F : D –≻ C ^op)
       (H1 : P D)
       (H2 : P (Arrow D)) =>
     HRL
       (D ^op)%category
       (F ^op)%functor H1
       (Card_Rest_Respect P (Arrow D) (Arrow (D^op)) (Arrow_OP_Iso D) H2)
  ).

Definition Has_Restr_CoLimits_to_Has_Restr_Limits_Op
        {C : Category}
        {P : Card_Restriction}
        (HRL : Has_Restr_CoLimits C P) :
  Has_Restr_Limits (C ^op) P :=
  (fun (D : Category)
       (F : D –≻ C ^op)
       (H1 : P D)
       (H2 : P (Arrow D)) =>
     HRL
       (D ^op)%category
       (F ^op)%functor
       H1
       (Card_Rest_Respect P (Arrow D) (Arrow (D^op)) (Arrow_OP_Iso D) H2)
  ).

Section CoContinuous.
  Context
    {C D : Category}
    (CC : CoComplete C)
    (G : (C –≻ D)%functor)
  .

  Section CoCone_Conv.
    Context
      {J : Category}
      {F : (J –≻ C)%functor}
      (Cn : CoCone F)
    .
    
    Program Definition CoCone_Conv : CoCone (G ∘ F)%functor
      :=
        {|
          cone_apex :=
            ((G ^op) ∘ (cone_apex Cn))%functor;
          cone_edge := _
                         (((NatTrans_id (G ^op)) ∘_h (cone_edge Cn))
                            ∘ (NatTrans_Functor_assoc _ _ _))%nattrans
        |}
    .

  End CoCone_Conv.

  Definition CoContinuous :=
    ∀ (J : Category) (F : (J –≻ C)%functor),
      is_Cone_Local_Right_KanExt _ _ (CoCone_Conv (LRKE (CoLimitOf F)))
  .

End CoContinuous. *)



Local Open Scope functor_scope.



Section GenProd_Eq_Complete.

  Context {C : Category}.



  Local Ltac ElimUnit := repeat match goal with [H : unit |- _] => destruct H end.



  Section GenProd_Eq_Limits.

    Context {J : Category}.



    Context {OProd : ∀ (map : J → C), (Π map)%object}

            {HProd : ∀ (map : (Arrow J) → C), (Π map)%object}

            {Eqs : Has_Equalizers C}

    .



    Section Limits_Exist.

      Context (D : J –≻ C).



      Local Notation DTarg := (fun f => (D _o (Targ f))%object) (only parsing).

      Local Notation DF := Discr_Func (only parsing).

      Local Notation OPR := (OProd (D _o)%object) (only parsing).

      Local Notation HPR := (HProd DTarg) (only parsing).



      Program Definition Projs_Cone : Cone (DF DTarg) :=

        {|

          cone_apex := Const_Func 1 (OPR _o tt);

          cone_edge := {|Trans := fun f => Trans (cone_edge OPR) (Targ f)|}

        |}.



      Definition Projs : (OPR –≻ HPR)%morphism :=

        Trans (LRKE_morph_ex HPR Projs_Cone) tt.



      Program Definition D_imgs_Cone : Cone (DF DTarg) :=

        {|

          cone_apex := Const_Func 1 (OPR _o tt);

          cone_edge :=

            {|

              Trans :=

                fun f =>

                  (D _a (Arr f) ∘ (Trans (cone_edge OPR) (Orig f)))%morphism

            |}

        |}.



      Definition D_imgs : (OPR –≻ HPR)%morphism :=

        Trans (LRKE_morph_ex HPR D_imgs_Cone) tt.



      Program Definition Lim_Cone : Cone D :=

        {|

          cone_apex := Const_Func 1 (Eqs _ _ Projs D_imgs);

          cone_edge :=

            {|Trans :=

                fun d => ((Trans (cone_edge OPR) d)

                         ∘ (equalizer_morph (Eqs _ _ Projs D_imgs)))%morphism

            |}

        |}.



      Next Obligation.

      Proof.

        simpl_ids.

        set (W :=

               f_equal

                 (fun t :

                        (((Const_Func 1 (((OProd (D _o)) _o) tt)%object)

                             ∘ (Functor_To_1_Cat (Discr_Cat (Arrow J))))

                          –≻ (DF DTarg))%nattrans

                  =>

                    ((Trans t {|Arr := h|})

                       ∘ (equalizer_morph (Eqs _ _ Projs D_imgs)))%morphism

                 )

                 (cone_morph_com (LRKE_morph_ex HPR D_imgs_Cone))

            ).

        set (W' :=

               f_equal

                 (fun t :

                        (((Const_Func 1 (((OProd (D _o)) _o) tt)%object)

                             ∘ (Functor_To_1_Cat (Discr_Cat (Arrow J))))

                          –≻ (DF DTarg))%nattrans

                  =>

                    (Trans t {|Arr := h|}

                           ∘ (equalizer_morph (Eqs _ _ Projs D_imgs)))%morphism

                 )

                 (cone_morph_com (LRKE_morph_ex HPR Projs_Cone))

            ).

        clearbody W W'.

        rewrite (assoc_sym _ _ ((D _a) h)).

        cbn in *.

        fold D_imgs in W.

        fold Projs in W'.

        rewrite W'.

        etransitivity; [|symmetry; apply W].

        clear W W'.

        repeat rewrite assoc.

        apply (

            f_equal

              (fun f =>

                 compose f

                         (Trans

                            (HProd (fun f : Arrow J => (D _o)%object (Targ f)))

                            {| Arr := h |}

                         )

              )

          ).

        apply (

            f_equal (

                fun f =>

                  compose f

                          (((HProd (fun f : Arrow J =>

                                      (D _o)%object (Targ f))) _a) tt)

              )

          ).

        apply equalizer_morph_com.

      Qed.        



      Next Obligation.

      Proof.

        symmetry.

        apply Lim_Cone_obligation_1.

      Qed.



      Section Every_Cone_Equalizes.

        Context (Cn : Cone D).



        Local Hint Extern 1 => progress cbn.



        Program Definition Cone_to_DF_DCone : Cone (DF (D _o)%object) :=

          {|

            cone_apex := Cn;

            cone_edge :=

              @NatTrans_compose

                _ _

                (Cn ∘ (Functor_To_1_Cat (Discr_Cat J)))

                (Discr_Func ((Cn ∘ (Functor_To_1_Cat J))%functor _o)%object) _

                {|Trans := fun _ => id |} (Discretize (cone_edge Cn))

          |}.



        Definition From_Cone_to_OPR : (Cn –≻ OPR)%morphism :=

          Trans (LRKE_morph_ex OPR Cone_to_DF_DCone) tt.



        Program Definition Cone_to_DF_DTrag_Cone : Cone (DF DTarg) :=

          {|

            cone_apex := Cn;

            cone_edge := {|Trans :=

                             fun c => Trans (Discretize (cone_edge Cn)) (Targ c)|}

          |}.



        Program Definition Cone_Morph_From_Cone_to_DF_DTrag_Cone_to_HPR_1 :

          Cone_Morph _ Cone_to_DF_DTrag_Cone HPR :=

          {|

            cone_morph :=

              {|Trans :=

                  fun f =>

                    match f as u return (((Cn _o) u)%object –≻ (_ u))%morphism

                    with

                    | tt => (Projs ∘ From_Cone_to_OPR)%morphism

                    end

              |}

          |}.



        Next Obligation.

        Proof.

          ElimUnit.

          do 2 rewrite From_Term_Cat.

          auto.

        Qed.



        Next Obligation.

        Proof.

          symmetry.

          apply Cone_Morph_From_Cone_to_DF_DTrag_Cone_to_HPR_1_obligation_1.

        Qed.



        Next Obligation.

        Proof.

          apply NatTrans_eq_simplify.

          extensionality x; cbn.

          unfold Projs, From_Cone_to_OPR.

          set (H :=

                 f_equal

                   (fun w :

                        ((Projs_Cone

                            ∘ (Functor_To_1_Cat (Discr_Cat (Arrow J)))

                         ) –≻ (DF DTarg))%nattrans

                    =>

                      (

                        (Trans w x)

                          ∘ (Trans

                               (LRKE_morph_ex

                                  (OProd (D _o)%object) Cone_to_DF_DCone) tt)

                      )%morphism

                   )

                   (

                     cone_morph_com

                       (

                         LRKE_morph_ex

                           (HProd (fun f : Arrow J => (D _o)%object (Targ f)))

                           Projs_Cone

                       )

                   )

              );

            clearbody H; cbn in H.

          repeat rewrite assoc_sym in H.

          repeat rewrite assoc_sym.

          etransitivity; [|apply H]; clear H.

          set (H :=

                 f_equal

                   (

                     fun w :

                         ((Cone_to_DF_DCone

                             ∘ (Functor_To_1_Cat (Discr_Cat J))

                          ) –≻ (DF (D _o)%object))%nattrans

                     =>

                       Trans w (Targ x)

                   )

                   (cone_morph_com (LRKE_morph_ex

                                      (OProd (D _o)%object) Cone_to_DF_DCone))

              ).

          cbn in *.

          rewrite From_Term_Cat in H; simpl_ids in H.

          trivial.

        Qed.



        Program Definition Cone_Morph_From_Cone_to_DF_DTrag_Cone_to_HPR_2 :

          Cone_Morph _ Cone_to_DF_DTrag_Cone HPR :=

          {|

            cone_morph :=

              {|Trans :=

                  fun f =>

                    match f as u return (((Cn _o)%object u) –≻ (_ u))%morphism

                    with

                    | tt => (D_imgs ∘ From_Cone_to_OPR)%morphism

                    end

              |}

          |}.



        Next Obligation.

        Proof.

          ElimUnit.

          do 2 rewrite From_Term_Cat; simpl_ids; trivial.

        Qed.



        Next Obligation.

        Proof.

          symmetry.

          apply Cone_Morph_From_Cone_to_DF_DTrag_Cone_to_HPR_2_obligation_1.

        Qed.



        Next Obligation.

        Proof.

          apply NatTrans_eq_simplify.

          extensionality x.

          cbn.

          unfold D_imgs, From_Cone_to_OPR.

          set (H :=

                 f_equal

                   (

                     fun w :

                         ((D_imgs_Cone

                             ∘ (Functor_To_1_Cat (Discr_Cat (Arrow J)))

                          ) –≻ (DF DTarg))%nattrans

                     =>

                       (

                         (Trans w x)

                           ∘ (Trans

                                (LRKE_morph_ex

                                   (OProd (D _o)%object) Cone_to_DF_DCone)tt)

                       )%morphism

                   )

                   (

                     cone_morph_com

                       (LRKE_morph_ex

                          (HProd (fun f : Arrow J =>

                                    (D _o)%object (Targ f))) D_imgs_Cone )

                   )

              );

            clearbody H; cbn in H.

          repeat rewrite assoc_sym in H.

          repeat rewrite assoc_sym.

          etransitivity; [|apply H]; clear H.

          set (H :=

                 f_equal

                   (

                     fun w :

                         ((Cone_to_DF_DCone

                             ∘ (Functor_To_1_Cat (Discr_Cat J))

                          ) –≻ (DF (D _o)%object))%nattrans

                     =>

                       (((D _a) (Arr x)) ∘ (Trans w (Orig x)))%morphism

                   )

                   (cone_morph_com

                      (LRKE_morph_ex (OProd (D _o)%object) Cone_to_DF_DCone))

              );

            clearbody H; cbn in H.

          rewrite From_Term_Cat in H; simpl_ids in H.

          repeat rewrite assoc_sym in H.

          repeat rewrite assoc_sym.

          etransitivity; [|apply H]; clear H.

          cbn_rewrite <- (@Trans_com _ _ _ _ Cn).

          rewrite From_Term_Cat; auto.

        Qed.



        Lemma From_Cone_to_Obj_Prod_Equalizes :

          (Projs ∘ From_Cone_to_OPR = D_imgs ∘ From_Cone_to_OPR)%morphism.

        Proof.

          match goal with

            [|- ?A = ?B] =>

            change A with

            (Trans Cone_Morph_From_Cone_to_DF_DTrag_Cone_to_HPR_1 tt);

              change B with

              (Trans Cone_Morph_From_Cone_to_DF_DTrag_Cone_to_HPR_2 tt)

          end.

          match goal with

            [|- Trans ?A tt = Trans ?B tt] =>

            assert (A = B) as Heq; [|rewrite Heq]; trivial

          end.

          apply (LRKE_morph_unique HPR).

        Qed.



        Definition From_Cone_to_Lim_Cone : (Cn –≻ Lim_Cone)%morphism :=

          equalizer_morph_ex _  From_Cone_to_Obj_Prod_Equalizes.



        Program Definition Cone_Morph_to_Lim_Cone : Cone_Morph D Cn Lim_Cone :=

          {|

            cone_morph :=

              {|

                Trans :=

                  fun c =>

                    match c as u return ((Cn _o u)%object –≻ _)%morphism with

                      tt => From_Cone_to_Lim_Cone

                    end

              |}

          |}.



        Next Obligation.

        Proof.

          ElimUnit.

          rewrite From_Term_Cat; auto.

        Qed.



        Next Obligation.

          symmetry.

          apply Cone_Morph_to_Lim_Cone_obligation_1.

        Qed.



        Next Obligation.

        Proof.

          apply NatTrans_eq_simplify.

          extensionality x.

          unfold From_Cone_to_Lim_Cone.

          cbn in *.

          set (H :=

                 equalizer_morph_ex_com

                   (Eqs _ _ Projs D_imgs)

                   From_Cone_to_Obj_Prod_Equalizes

              );

            clearbody H; cbn in H.

          simpl_ids.

          rewrite assoc.

          match goal with

            [|- _ = (?A ∘ ?B)%morphism] =>

            replace B with From_Cone_to_OPR

          end.

          clear H.

          unfold From_Cone_to_OPR.

          set (H :=

                 f_equal

                   (

                     fun w :

                         ((Cone_to_DF_DCone ∘ (Functor_To_1_Cat (Discr_Cat J))

                          ) –≻ (DF (D _o)%object))%nattrans

                     =>

                       Trans w x

                   )

                   (cone_morph_com (LRKE_morph_ex

                                      (OProd (D _o)%object) Cone_to_DF_DCone))

              ).

          cbn in H.

          rewrite From_Term_Cat in H; simpl_ids in H.

          trivial.

        Qed.



      End Every_Cone_Equalizes.



      Section Cone_Morph_to_Lim_Cone_Cone_Morph_to_OPR.

        Context {Cn : Cone D} (h : Cone_Morph _ Cn Lim_Cone).



        Program Definition Cone_Morph_to_Lim_Cone_Cone_Morph_to_OPR :

          Cone_Morph _ (Cone_to_DF_DCone Cn) OPR :=

          {|

            cone_morph :=

              {|

                Trans :=

                  fun c =>

                    match c as u return

                          (((Cn _o) u)

                             –≻ (((OProd (D _o)) _o) u))%object%morphism

                    with

                    | tt => (equalizer_morph (Eqs _ _ Projs D_imgs)

                                            ∘ Trans h tt)%morphism

                    end

              |}

          |}.



        Next Obligation.

        Proof.

          ElimUnit.

          rewrite From_Term_Cat; auto.

        Qed.



        Next Obligation.

        Proof.

          symmetry.

          apply Cone_Morph_to_Lim_Cone_Cone_Morph_to_OPR_obligation_1.

        Qed.



        Next Obligation.

        Proof.

          apply NatTrans_eq_simplify.

          extensionality x.

          cbn.

          set (H :=

                 f_equal

                   (fun w : ((Cn ∘ (Functor_To_1_Cat J)) –≻ D)%nattrans =>

                      Trans w x)

                   (cone_morph_com h)

              ).

          cbn in H.

          simpl_ids in H.

          rewrite From_Term_Cat; simpl_ids.

          rewrite assoc in H.

          trivial.

        Qed.



      End Cone_Morph_to_Lim_Cone_Cone_Morph_to_OPR.



      Local Notation CMCOPR :=

        Cone_Morph_to_Lim_Cone_Cone_Morph_to_OPR (only parsing).



      Program Definition Lim_Cone_is_Limit : Limit D :=

        {|

          LRKE := Lim_Cone;

          LRKE_morph_ex := Cone_Morph_to_Lim_Cone

        |}.



      Next Obligation.

      Proof.

        set (H := LRKE_morph_unique

                    (OProd (D _o)%object) _ (CMCOPR h) (CMCOPR h')).

        apply (

            f_equal

              (fun w : ((Cone_to_DF_DCone Cn) –≻ (OProd (D _o)%object))%nattrans =>

                 Trans w tt)

          ) in H.

        cbn in H.

        apply NatTrans_eq_simplify.

        extensionality x; destruct x.

        apply (@mono_morphism_monomorphic

                 _ _ _ (@Equalizer_Monic _ _ _ _ _ (Eqs _ _ Projs D_imgs))).

        trivial.

      Qed.



    End Limits_Exist.

  End GenProd_Eq_Limits.



  Section Restricted_Limits.

    Context (P : Card_Restriction)

            {CHRP : ∀ (A : Type) (map : A → C), (P A) → (Π map)%object}

            {HE : Has_Equalizers C}

    .



    Definition Restr_GenProd_Eq_Restr_Limits : Has_Restr_Limits C P :=

      fun J D PJ PA =>

        @Lim_Cone_is_Limit

          J

          (fun map => CHRP J map PJ)

          (fun map => CHRP (Arrow J) map PA)

          HE

          D

    .



  End Restricted_Limits.



  Section Complete.

    Context {CHAP : ∀ (A : Type) (map : A → C), (Π map)%object}

            {HE : Has_Equalizers C}.



    Definition GenProd_Eq_Complete : Complete C :=

      fun J =>

        Local_to_Global_Right

          _

          _

          (fun D => @Lim_Cone_is_Limit J (CHAP J) (CHAP (Arrow J)) HE D)

    .



  End Complete.



End GenProd_Eq_Complete.



Section GenSum_CoEq_Complete.

  Context {C : Category}.



  Section GenSum_CoEq_CoLimits.

    Context {J : Category}

            {OSum : ∀ (map : J → C), (Σ map)%object}

            {HSum : ∀ (map : (Arrow J) → C), (Σ map)%object}

            {Eqs : Has_CoEqualizers C}

    .



    Section Limits_Exist.

      Context (D : J –≻ C).



      Program Definition CoLim_CoCone_is_CoLimit : CoLimit D :=

        @Lim_Cone_is_Limit

          (C^op)

          (J^op)

          (fun map => GenSum_to_GenProd (OSum map))

          (fun map => GenSum_to_GenProd (GenSum_IsoType (Arrow_OP_Iso J) HSum map))

          Eqs

          (Opposite_Functor D)

      .



    End Limits_Exist.

  End GenSum_CoEq_CoLimits.



  Section Restricted_CoLimits.

    Context (P : Card_Restriction)

            {CHRP : ∀ (A : Type) (map : A → C), (P A) → (Σ map)%object}

            {HE : Has_CoEqualizers C}

    .



    Definition Restr_GenSum_CoEq_Restr_CoLimits : Has_Restr_CoLimits C P :=

      fun J D PJ PA =>

        @CoLim_CoCone_is_CoLimit

          J

          (fun map => CHRP J map PJ)

          (fun map => CHRP (Arrow J) map PA)

          HE

          D

    .



  End Restricted_CoLimits.



  Section CoComplete.

    Context {CHAP : ∀ (A : Type) (map : A → C), (Σ map)%object}

            {HE : Has_CoEqualizers C}

    .



    Definition GenSum_CoEq_CoComplete : CoComplete C :=

      fun J =>

        Local_to_Global_Left

          _

          _

          (fun D => @CoLim_CoCone_is_CoLimit J (CHAP J) (CHAP (Arrow J)) HE D)

    .



  End CoComplete.



End GenSum_CoEq_Complete.

