From Categories Require Import Essentials.Notations.
(* Categories.Essentials.Notations:
Notation "∀ x .. y , P" := (forall x, .. (forall y, P) ..)
                             (at level 200, x binder, y binder, right associativity) : type_scope.

Notation "∃ x .. y , P" := (exists x, .. (exists y, P) ..)
  (at level 200, x binder, y binder, right associativity) : type_scope.

Notation "x ∨ y" := (x \/ y) (at level 85, right associativity) : type_scope.

Notation "x ∧ y" := (x /\ y) (at level 80, right associativity) : type_scope.

Notation "x → y" := (x -> y)
  (at level 90, y at level 200, right associativity): type_scope.

Notation "x ↔ y" := (x <-> y) (at level 95, no associativity): type_scope.

Notation "¬ x" := (~x) (at level 75, right associativity) : type_scope.

Notation "x ≠ y" := (x <> y) (at level 70) : type_scope.

Notation "x ≤ y" := (le x y) (at level 70, no associativity).

Notation "x ≥ y" := (ge x y) (at level 70, no associativity).

Reserved Notation "C '^op'" (at level 50, no associativity).

Reserved Notation "a –≻ b" (at level 90, b at level 200, right associativity).

Reserved Notation "f '⁻¹'" (at level 50, no associativity).

Reserved Notation "a ≃ b" (at level 70, no associativity).

Reserved Notation "a ≃≃ b ::> C" (at level 70, no associativity).

Reserved Notation "f ∘ g" (at level 51, right associativity).

Reserved Notation "f '∘_h' g" (at level 51, right associativity).

Reserved Notation "a ≫–> b" (at level 100, no associativity).

Reserved Notation "a –≫ b" (at level 100, no associativity).

Reserved Notation "F '_o'" (at level 50, no associativity).

Reserved Notation "F '_a'" (at level 50, no associativity).

Reserved Notation "F '@_a'" (at level 50, no associativity).

Reserved Notation "F ⊣ G" (at level 100, no associativity).

Reserved Notation "F ⊣_hom G" (at level 100, no associativity).

Reserved Notation "F ⊣_ucu G" (at level 100, no associativity).

Reserved Notation "a × b" (at level 80, no associativity).

Reserved Notation "a ⇑ b" (at level 79, no associativity).

Reserved Notation "'Π' m" (at level 50, no associativity).

Reserved Notation "'Σ' m" (at level 50, no associativity).

Reserved Notation "'Π_' C ↓ m" (at level 50, no associativity).

Reserved Notation "'Σ_' C ↓ m" (at level 50, no associativity).

Delimit Scope category_scope with category.

Delimit Scope morphism_scope with morphism.

Delimit Scope object_scope with object.

Delimit Scope functor_scope with functor.

Delimit Scope nattrans_scope with nattrans.

Delimit Scope nattrans_scope with nattrans.

Delimit Scope natiso_scope with natiso.

Delimit Scope isomorphism_scope with isomorphism.

Delimit Scope preorder_scope with preorder. *)

From Categories Require Import Essentials.Types.
(* Categories.Essentials.Types:
Global Set Primitive Projections.

Global Set Universe Polymorphism.

Global Unset Universe Minimization ToSet.

Inductive Empty : Type :=.

Hint Extern 1 =>
let tac := (repeat intros ?); match goal with [H : Empty |- _] => contradict H end in
match goal with
  | [|- context[Empty]] => tac
  | [H : context[Empty] |- _] => tac
end
.

Record prod (A B : Type) := {fst : A; snd : B}.

Arguments fst {_ _ } _.
Arguments snd {_ _ } _.
Arguments Build_prod {_ _ } _ _.

Notation "( X , Y )" := (Build_prod X Y).
Notation "X * Y" := (prod X Y) : type_scope. *)

From Categories Require Import Essentials.Facts_Tactics.
(* Categories.Essentials.Facts_Tactics:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.

Require Export Coq.Program.Tactics.
Require Export Coq.Program.Equality.
Require Export Coq.Logic.FunctionalExtensionality.
Require Export Coq.Logic.ProofIrrelevance.

Definition equal_f : ∀ {A B : Type} {f g : A → B}, f = g → ∀ x : A, f x = g x.

Definition f_equal : ∀ (A B : Type) (f : A → B) (x y : A), x = y → f x = f y.

Arguments f_equal [_ _] _ [_ _] _.

Ltac basic_simpl :=
  let simpl_prod _ :=
      match goal with
        [H : prod _ _ |- _] =>
        let H1 := fresh H "1" in
        let H2 := fresh H "2" in
        destruct H as [H1 H2]
      end
  in
  let simpl_sig _ :=
      match goal with
        [H : @sig _ _ |- _] =>
        let H1 := fresh H "1" in
        let H2 := fresh H "2" in
        destruct H as [H1 H2]
      end
  in
  let basic_simpl_helper _ :=
      cbn in *; intros;
        repeat simpl_prod tt;
        repeat simpl_sig tt
  in
  repeat basic_simpl_helper tt
.

Global Obligation Tactic := basic_simpl; auto.

Ltac PIR :=
  let pir_helper _ :=
      match goal with
      |[H : ?A, H' : ?A|- _] =>
       match type of A with
       | Prop =>
         destruct (proof_irrelevance _ H H')
       end
      end
  in
  repeat pir_helper tt
.

Ltac ElimEq := repeat match goal with [H : _ = _|- _] => destruct H end.

Hint Extern 1 => progress ElimEq.

Ltac cbn_rewrite W :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite H; clear H
.

Ltac cbn_rewrite_in W V :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite H in V; clear H
.

Ltac cbn_rewrite_back W :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite <- H; clear H
.

Ltac cbn_rewrite_back_in W V :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite <- H in V; clear H
.

Tactic Notation "cbn_rewrite" constr(W) := cbn_rewrite W.
Tactic Notation "cbn_rewrite" constr(W) "in" hyp_list(V) := cbn_rewrite_in W V.
Tactic Notation "cbn_rewrite" "<-" constr(W) := cbn_rewrite_back W.
Tactic Notation "cbn_rewrite" "<-" constr(W) "in" hyp_list(V) := cbn_rewrite_back_in W V.

Lemma sig_proof_irrelevance {A : Type} (P : A → Prop) (X Y : sig P) : proj1_sig X = proj1_sig Y → X = Y.

Hint Extern 2 (exist ?A _ _ = exist ?A _ _) => apply sig_proof_irrelevance.

Ltac FunExt :=
progress (
    repeat (
        match goal with
          [|- _ = _] =>
          let x := fresh "x" in
          extensionality x
        end
      )
  )
.

Hint Extern 1 => FunExt.

Lemma pair_eq (A B : Type) (a b : A * B) : fst a = fst b → snd a = snd b → a = b.

Hint Resolve pair_eq.

Ltac revert_clearbody_all :=
 repeat lazymatch goal with H:_ |- _ => try clearbody H; revert H end.

Ltac hyp_stack :=
 constr:(ltac:(revert_clearbody_all;constructor) : True).

Ltac next_hyp hs step last :=
 lazymatch hs with (?hs' ?H) => step H hs' | _ => last end.

Tactic Notation "dohyps" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := tac H; next_hyp hs step idtac in
 next_hyp hs step idtac.

Tactic Notation "dohyps" "reverse" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := next_hyp hs step idtac; tac H in
 next_hyp hs step idtac.

Tactic Notation "do1hyp" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := tac H + next_hyp hs step fail in
 next_hyp hs step fail.

Tactic Notation "do1hyp" "reverse" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := next_hyp hs step fail + tac H in
 next_hyp hs step fail. *)

From Categories Require Import Category.Main.
(* Categories.Category.Main:
From Categories Require Export Category.Category.
From Categories Require Export Category.Morph.
From Categories Require Export Category.Opposite.
From Categories Require Export Category.SubCategory.
From Categories Require Export Category.Composable_Chain. *)

From Categories Require Import Functor.Main.
(* Categories.Functor.Main:
From Categories Require Export Functor.Functor.
From Categories Require Export Functor.Functor_Extender.
From Categories Require Export Functor.Functor_Image.
From Categories Require Export Functor.Functor_Ops.
From Categories Require Export Functor.Functor_Properties.
From Categories Require Export Functor.Const_Func.
From Categories Require Export Functor.Const_Func_Functor. *)

From Categories Require Import Limits.Limit.
(* Categories.Limits.Limit:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Main.
From Categories Require Import Basic_Cons.Terminal.
From Categories Require Import Ext_Cons.Arrow.
From Categories Require Import Coq_Cats.Type_Cat.Card_Restriction.
From Categories Require Export NatTrans.NatTrans NatTrans.Operations.
From Categories Require Export KanExt.Local KanExt.Global KanExt.GlobalDuality
        KanExt.GlobaltoLocal KanExt.LocaltoGlobal KanExt.LocalFacts.Main.
From Categories Require Export Cat.Terminal.

Local Open Scope functor_scope.

Section Limit.
  Context {J C : Category} (D : J –≻ C).

  Definition Cone := LoKan_Cone (Functor_To_1_Cat J) D.

  Definition Cone_Morph Cn Cn' :=
    @LoKan_Cone_Morph _ _ (Functor_To_1_Cat J) _ D Cn Cn'.
  
  Definition Limit : Type := Local_Right_KanExt (Functor_To_1_Cat J) D.

  Definition limit_to_cone (l : Limit) : Cone := (LRKE l).

  Coercion limit_to_cone : Limit >-> Cone.
  
  Definition cone_to_obj (cn : Cone) : C := (cone_apex cn) _o tt.

  Coercion cone_to_obj : Cone >-> Obj.

  Definition is_Limit (Cn : Cone) :=
    is_Cone_Local_Right_KanExt (Functor_To_1_Cat J) D Cn.

  Definition is_Limit_Limit {Cn : Cone} (il : is_Limit Cn) : Limit :=
    is_Cone_Local_Right_KanExt_Local_Right_KanExt (Functor_To_1_Cat J) D il.

  Definition Limit_is_Limit {L : Limit} : is_Limit L :=
    Local_Right_KanExt_is_Cone_Local_Right_KanExt (Functor_To_1_Cat J) D L.
  
End Limit.

Program Definition Limit_Iso {J C : Category} {D : J –≻ C} (l l' : Limit D) :
  (l ≃≃ l' ::> C)%isomorphism :=
  {|
    iso_morphism :=
      Trans
        (cone_morph (iso_morphism (Local_Right_KanExt_unique _ _ l l')))
        tt;
    inverse_morphism :=
      Trans
        (cone_morph (inverse_morphism (Local_Right_KanExt_unique _ _ l l')))
        tt
  |}.

Next Obligation.
Proof (
    f_equal
      (fun x : LoKan_Cone_Morph l l => Trans (cone_morph x) tt)
      (left_inverse (Local_Right_KanExt_unique _ _ l l'))
  ).

Next Obligation.
Proof (
    f_equal
      (fun x : LoKan_Cone_Morph l' l' => Trans (cone_morph x) tt)
      (right_inverse (Local_Right_KanExt_unique _ _ l l'))
  ).

Definition Has_Restr_Limits (C : Category) (P : Card_Restriction) :=
  ∀ {J : Category} (D : J –≻ C), P J → P (Arrow J) → Limit D.

Definition Complete (C : Category) :=
  ∀ J : Category, Right_KanExt (Functor_To_1_Cat J) C.

Existing Class Complete.

Definition LimitOf {C D : Category} {H : Complete D} (F : C –≻ D) : Limit F :=
  Global_to_Local_Right _ _ (H _) F.

Section Restricted_Limits_to_Complete.
  Context {C : Category} {P : Card_Restriction} (HRL : Has_Restr_Limits C P).

  Definition No_Restriction_Complete : (∀ t, P t) → Complete C :=
    fun All_Ps J => Local_to_Global_Right
                   _ _ (fun D => HRL _ D (All_Ps J) (All_Ps (Arrow J))).

End Restricted_Limits_to_Complete.

Section Complete_to_Restricted_Limits.
  Context (C : Category) {CC : Complete C} (P : Card_Restriction).
  
  Definition Complete_Has_Restricted_Limits : Has_Restr_Limits C P :=
    fun J D _ _ => Global_to_Local_Right _ _ (CC _) D.

End Complete_to_Restricted_Limits.

Section Continuous.
  Context
    {C D : Category}
    (CC : Complete C)
    (G : (C –≻ D)%functor)
  .

  Section Cone_Conv.
    Context
      {J : Category}
      {F : (J –≻ C)%functor}
      (Cn : Cone F)
    .
    
    Program Definition Cone_Conv : Cone (G ∘ F)%functor
      :=
        {|
          cone_apex :=
            (G ∘ (cone_apex Cn))%functor;
          cone_edge :=
            (((NatTrans_id G)
                ∘_h (cone_edge Cn)) ∘ (NatTrans_Functor_assoc _ _ _))%nattrans
        |}
    .

  End Cone_Conv.

  Definition Continuous :=
    ∀ (J : Category) (F : (J –≻ C)%functor),
      is_Cone_Local_Right_KanExt _ _ (Cone_Conv (LRKE (LimitOf F)))
  .

End Continuous.

Section CoLimit.
  Context {J C : Category} (D : J –≻ C).

  Definition CoCone :=
    LoKan_Cone (Functor_To_1_Cat J^op) (D^op).

  Definition CoCone_Morph Cn Cn' :=
    @LoKan_Cone_Morph _ _ (Functor_To_1_Cat J^op) _ (D^op) Cn Cn'.

  Definition CoLimit := Local_Left_KanExt (Functor_To_1_Cat J) D.

  Definition is_CoLimit (Cn : CoCone) :=
    is_Cone_Local_Right_KanExt (Functor_To_1_Cat (J^op)) (D^op) Cn.

  Definition is_CoLimit_CoLimit {Cn : CoCone} (il : is_CoLimit Cn) : CoLimit :=
    is_Cone_Local_Right_KanExt_Local_Right_KanExt
      (Functor_To_1_Cat (J^op)) (D^op) il.

  Definition CoLimit_is_CoLimit {L : CoLimit} : is_CoLimit L :=
    Local_Right_KanExt_is_Cone_Local_Right_KanExt
      (Functor_To_1_Cat (J^op)) (D^op) L.

End CoLimit.

Definition Has_Restr_CoLimits (C : Category) (P : Card_Restriction) :=
  ∀ {J : Category} (D : J –≻ C), P J → P (Arrow J) → CoLimit D.

Definition CoComplete (C : Category) :=
  ∀ J : Category, Left_KanExt (Functor_To_1_Cat J) C.

Existing Class CoComplete.

Definition CoLimitOf {C D : Category} {H : CoComplete D} (F : C –≻ D) :
  CoLimit F := Global_to_Local_Left _ _ (H _) F.

Definition Complete_to_CoComplete_Op {C : Category} {CC : Complete C}
  : CoComplete (C ^op) :=
fun D => KanExt_Right_to_Left (Functor_To_1_Cat D ^op) C (CC (D ^op)%category).

Definition CoComplete_to_Complete_Op {C : Category} {CC : CoComplete C}
  : Complete (C ^op) :=
    fun D => KanExt_Left_to_Right (Functor_To_1_Cat D ^op) C (CC (D ^op)%category).

Section Restricted_CoLimits_to_CoComplete.
  Context {C : Category} {P : Card_Restriction} (HRL : Has_Restr_CoLimits C P).

  Definition No_Restriction_CoComplete : (∀ t, P t) → CoComplete C :=
    fun All_Ps J =>
      Local_to_Global_Left _ _ (fun D => HRL _ D (All_Ps J) (All_Ps (Arrow J))).

End Restricted_CoLimits_to_CoComplete.

Section CoComplete_to_Restricted_CoLimits.
  Context (C : Category) {CC : CoComplete C} (P : Card_Restriction).
  
  Definition CoComplete_Has_Restricted_CoLimits : Has_Restr_CoLimits C P :=
    fun J D _ _ => Global_to_Local_Left _ _ (CC _) D.

End CoComplete_to_Restricted_CoLimits.

Definition Has_Restr_Limits_to_Has_Restr_CoLimits_Op
        {C : Category} {P : Card_Restriction}
        (HRL : Has_Restr_Limits C P) :
  Has_Restr_CoLimits (C ^op) P :=
  (fun (D : Category)
       (F : D –≻ C ^op)
       (H1 : P D)
       (H2 : P (Arrow D)) =>
     HRL
       (D ^op)%category
       (F ^op)%functor H1
       (Card_Rest_Respect P (Arrow D) (Arrow (D^op)) (Arrow_OP_Iso D) H2)
  ).

Definition Has_Restr_CoLimits_to_Has_Restr_Limits_Op
        {C : Category}
        {P : Card_Restriction}
        (HRL : Has_Restr_CoLimits C P) :
  Has_Restr_Limits (C ^op) P :=
  (fun (D : Category)
       (F : D –≻ C ^op)
       (H1 : P D)
       (H2 : P (Arrow D)) =>
     HRL
       (D ^op)%category
       (F ^op)%functor
       H1
       (Card_Rest_Respect P (Arrow D) (Arrow (D^op)) (Arrow_OP_Iso D) H2)
  ).

Section CoContinuous.
  Context
    {C D : Category}
    (CC : CoComplete C)
    (G : (C –≻ D)%functor)
  .

  Section CoCone_Conv.
    Context
      {J : Category}
      {F : (J –≻ C)%functor}
      (Cn : CoCone F)
    .
    
    Program Definition CoCone_Conv : CoCone (G ∘ F)%functor
      :=
        {|
          cone_apex :=
            ((G ^op) ∘ (cone_apex Cn))%functor;
          cone_edge := _
                         (((NatTrans_id (G ^op)) ∘_h (cone_edge Cn))
                            ∘ (NatTrans_Functor_assoc _ _ _))%nattrans
        |}
    .

  End CoCone_Conv.

  Definition CoContinuous :=
    ∀ (J : Category) (F : (J –≻ C)%functor),
      is_Cone_Local_Right_KanExt _ _ (CoCone_Conv (LRKE (CoLimitOf F)))
  .

End CoContinuous. *)

From Categories Require Import Archetypal.Discr.Discr.
(* Categories.Archetypal.Discr.Discr:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Functor.
From Categories Require Import Cat.Cat.
From Categories Require Import Coq_Cats.Type_Cat.Type_Cat.

Definition EmptyCat : Category :=
  {|
    Obj := (Empty : Type);
    Hom := fun _ _ => (unit : Type);
    compose := fun _ _ _ _ _ => tt;
    assoc := fun _ _ _ _ _ _ _ => eq_refl;
    assoc_sym := fun _ _ _ _ _ _ _ => eq_refl;
    id := fun _ => tt;
    id_unit_left :=
      fun _ _ h =>
        match h as u return (tt = u) with
        | tt => eq_refl
        end;
    id_unit_right :=
      fun _ _ h =>
        match h as u return (tt = u) with
        | tt => eq_refl
        end
  |}.

Definition SingletonCat : Category :=
  {|
    Obj := (unit : Type);
    Hom := fun _ _ => (unit : Type);
    compose := fun _ _ _ _ _ => tt;
    assoc := fun _ _ _ _ _ _ _ => eq_refl;
    assoc_sym := fun _ _ _ _ _ _ _ => eq_refl;
    id := fun _ => tt;
    id_unit_left :=
      fun _ _ h =>
        match h as u return (tt = u) with
        | tt => eq_refl
        end;
    id_unit_right :=
      fun _ _ h =>
        match h as u return (tt = u) with
        | tt => eq_refl
        end
  |}.

Notation "0" := (EmptyCat) : category_scope.
Notation "1" := (SingletonCat) : category_scope.

Section Discr.
  Context (obj : Type).

  Program Definition Discr_Cat : Category :=
    {|
      Obj := obj;
      Hom := fun a b => a = b;
      compose := @eq_trans _;
      id := fun a => eq_refl
    |}.
    
End Discr.

Definition Type_n (n : nat) : Type := {x : nat| x < n}.

Notation "'Discr_n' n" :=
  (Discr_Cat (Type_n n)) (at level 200, n bigint) : category_scope.

Section Discr_Cat_Dual_Iso.
  Context (obj : Type).

  Local Hint Extern 1 => progress cbn.
  
  Program Definition Discr_Cat_Dual_Iso :
    (Discr_Cat obj ≃≃ (Discr_Cat obj)^op ::> Cat)%isomorphism%category
    :=
      {|
        iso_morphism := {|FO := fun x => x; FA := fun _ _ h => eq_sym h|};
        inverse_morphism := {|FO := fun x => x; FA := fun _ _ h => eq_sym h|}
      |}.

End Discr_Cat_Dual_Iso.

Section Discr_Cat_Iso.
  Context {obj obj' : Type} (I : (obj ≃≃ obj' ::> Type_Cat)%isomorphism).

  Program Definition Discr_Cat_Iso :
    ((Discr_Cat obj) ≃≃ (Discr_Cat obj') ::> Cat)%isomorphism
    :=
      {|
        iso_morphism :=
          {|
            FO := iso_morphism I;
            FA :=
              fun c d h =>
                match h in _ = y return
                      (iso_morphism I c) = (iso_morphism I y)
                with
                  eq_refl => eq_refl
                end
          |};
        inverse_morphism :=
          {|
            FO := inverse_morphism I;
            FA :=
              fun c d h =>
                match h in _ = y return
                      (inverse_morphism I c) = (inverse_morphism I y)
                with
                  eq_refl => eq_refl
                end
          |}
      |}.
  
End Discr_Cat_Iso.

Section Func_From_SingletonCat.
  Context {C : Category} (Cobj : C).

  Program Definition Func_From_SingletonCat : (SingletonCat –≻ C)%functor :=
    {|
      FO := fun _ => Cobj;
      FA := fun _ _ _ => id
    |}.

End Func_From_SingletonCat.

Section Discr_Func.
  Context {C : Category} {A : Type} (Omap : A → C).

  Program Definition Discr_Func : ((Discr_Cat A) –≻ C)%functor :=
    {|
      FO := Omap;
      
      FA := fun (a b : A) (h : a = b) =>
              match h in _ = y return ((Omap a) –≻ (Omap y))%morphism with
              | eq_refl => id
              end
    |}.

  Program Definition Discr_Func_op : ((Discr_Cat A)^op –≻ C)%functor :=
    {|
      FO := Omap;
      FA := fun (a b : A) (h : b = a) =>
              match h in _ = y return ((Omap y) –≻ (Omap b))%morphism with
              | eq_refl => id
              end
    |}.
    
End Discr_Func.
  
Arguments Discr_Func {_ _} _, _ {_} _.
Arguments Discr_Func_op {_ _} _, _ {_} _. *)

From Categories Require Import Cat.Terminal.
(* Categories.Cat.Terminal:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Main.
From Categories Require Import Cat.Cat.
From Categories Require Import Basic_Cons.Terminal.
From Categories Require Import Archetypal.Discr.Discr.
From Categories Require Import NatTrans.NatTrans NatTrans.NatIso.

Program Definition Functor_To_1_Cat (C' : Category) : (C' –≻ 1)%functor :=
{|
  FO := fun x => tt;
  FA := fun a b f => tt;
  F_id := fun _ => eq_refl;
  F_compose := fun _ _ _ _ _ => eq_refl
|}.

Section From_Term_Cat.
  Context {C : Category} (F : (1 –≻ C)%functor).

  Theorem From_Term_Cat : ∀ h, (F @_a tt tt h)%morphism = id.

End From_Term_Cat.

Program Definition Functor_To_1_Cat_Iso
        {C : Category}
        (F F' : (C –≻ 1)%functor)
  : (F ≃ F')%natiso :=
{|
  iso_morphism :=
    {|
      Trans := fun _ => tt
    |};
  inverse_morphism :=
    {|
      Trans := fun _ => tt
    |}
|}. *)

From Categories Require Import

        Basic_Cons.Terminal

        Basic_Cons.Product

        Basic_Cons.Equalizer

        Basic_Cons.PullBack

.

        

Section Limits.

  Context {C : Category}.



  Section Terminal.



    Definition Terminal_Producing_Func_fun (x : Empty) : C

      :=

        match x with

        end

    .

    

    Context (L : Limit (Discr_Func Terminal_Producing_Func_fun)).



    Program Definition Terminal_as_Limit_Cone

            (c : C)

      :

        Cone (Discr_Func Terminal_Producing_Func_fun)

      :=

        {|

          cone_apex :=

            {|

              FO := fun _ => c;

              FA := fun _ _ _ => id

            |};

          cone_edge :=

            {|

              Trans :=

                fun x =>

                  match x with

                  end

            |}

        |}

    .



    Local Hint Extern 1 => match goal with [x : unit |- _] => destruct x end.

    Local Hint Extern 1 => rewrite From_Term_Cat.

    Local Hint Extern 1 => apply NatTrans_eq_simplify.

    Local Hint Extern 1 => progress cbn.

    

    Local Obligation Tactic := basic_simpl; auto 10.



    Program Definition Terminal_as_Limit_Cone_morph

            {c : C}

            (f : (c –≻ L)%morphism)

      :

        Cone_Morph _ (Terminal_as_Limit_Cone c) (LRKE L)

      :=

        {|

          cone_morph :=

            {|

              Trans :=

                fun c =>

                  match c as u return ( _ –≻ L _o u)%object%morphism with

                    tt => f

                  end

            |}

        |}

    .      

      

    Program Definition Terminal_as_Limit : (𝟙_ C)%object :=

      {|

        terminal := L;

        t_morph :=

          fun c =>

            Trans (LRKE_morph_ex L (Terminal_as_Limit_Cone c)) tt

      |}

    .



    Local Obligation Tactic := idtac.

    

    Next Obligation.

    Proof.    

      intros c f g.

      apply (

          f_equal

            (fun w : (Terminal_as_Limit_Cone c –≻ L)%nattrans => Trans w tt)

            (

              LRKE_morph_unique

                L

                _

                (Terminal_as_Limit_Cone_morph f)

                (Terminal_as_Limit_Cone_morph g)

            )

        ).

    Qed.



  End Terminal.

  

  Section Product.

    Context (a b : C).



    Definition Product_Producing_Func_fun (x : bool) : C

      :=

        match x with

        | true => a

        | false => b

        end

    .

    

    Context (L : Limit (Discr_Func Product_Producing_Func_fun)).



    Program Definition Product_as_Limit_Cone

            {p : C}

            (h : (p –≻ a)%morphism)

            (h' : (p –≻ b)%morphism)

      :

        Cone (Discr_Func Product_Producing_Func_fun)

      :=

        {|

          cone_apex :=

            {|

              FO := fun _ => p;

              FA := fun _ _ _ => id

            |};

          cone_edge :=

            {|

              Trans :=

                fun x =>

                  match x with

                  | true => h

                  | false => h'

                  end

            |}

        |}

    .



    Local Hint Extern 1 => match goal with [x : unit |- _] => destruct x end.

    Local Hint Extern 1 => match goal with [x : bool |- _] => destruct x end.

    Local Hint Extern 1 => rewrite From_Term_Cat.

    Local Hint Extern 1 => apply NatTrans_eq_simplify.

    Local Hint Extern 1 => progress cbn.

    

    Local Obligation Tactic := basic_simpl; auto 10.

    

    Program Definition Product_as_Limit_Cone_morph

            {p : C}

            (h : (p –≻ a)%morphism)

            (h' : (p –≻ b)%morphism)

            (f : (p –≻ L)%morphism)

            (H1 : (Trans L true ∘ f)%morphism = h)

            (H2 : (Trans L false ∘ f)%morphism = h')

      :

        Cone_Morph _ (Product_as_Limit_Cone h h') (LRKE L)

      :=

        {|

          cone_morph :=

            {|

              Trans :=

                fun c =>

                  match c as u return ( _ –≻ L _o u)%object%morphism with

                    tt => f

                  end

            |}

        |}

    .

    

    Program Definition Product_as_Limit : (a × b)%object :=

      {|

        product := L;

        Pi_1 := Trans (cone_edge L) true;

        Pi_2 := Trans (cone_edge L) false;

        Prod_morph_ex :=

          fun p h h' =>

            Trans (LRKE_morph_ex L (Product_as_Limit_Cone h h')) tt

      |}

    .



    Local Obligation Tactic := idtac.



    Next Obligation.

    Proof.

      intros p h h'.

      cbn.

      set (H :=

             f_equal

               (fun w

                    :

                      (Product_as_Limit_Cone h h'

                 ∘ Functor_To_1_Cat (Discr_Cat Datatypes.bool)

                 –≻ Discr_Func Product_Producing_Func_fun)%nattrans

                => Trans w true)

               (cone_morph_com (LRKE_morph_ex L (Product_as_Limit_Cone h h')))

          ).

      cbn in H.

      rewrite From_Term_Cat in H.

      auto.

    Qed.



    Next Obligation.

    Proof.

      intros p h h'.

      set (H :=

             f_equal

               (fun w

                    :

                      ((Product_as_Limit_Cone h h')

                         ∘ Functor_To_1_Cat (Discr_Cat Datatypes.bool)

                         –≻ Discr_Func Product_Producing_Func_fun)%nattrans

                => Trans w false)

               (cone_morph_com (LRKE_morph_ex L (Product_as_Limit_Cone h h')))

          ).

      cbn in H.

      rewrite From_Term_Cat in H.

      auto.

    Qed.

    

    Next Obligation.

    Proof.    

      intros p h h' f g H1 H2 H3 H4.

      apply (

          f_equal

            (fun w : (Product_as_Limit_Cone h h' –≻ L)%nattrans => Trans w tt)

            (

              LRKE_morph_unique

                L

                _

                (Product_as_Limit_Cone_morph _ _ _ H1 H2)

                (Product_as_Limit_Cone_morph _ _ _ H3 H4)

            )

        ).

    Qed.



  End Product.



  Section Equalizer.

    Context {a b : C} (f g : (a –≻ b)%morphism).



    Local Hint Extern 1 => match goal with [x : unit |- _] => destruct x end.

    Local Hint Extern 1 => match goal with [x : Empty |- _] => destruct x end.

    Local Hint Extern 1 => match goal with [x : bool |- _] => destruct x end.

    Local Hint Extern 1 => rewrite From_Term_Cat.

    Local Hint Extern 1 => apply NatTrans_eq_simplify.

    Local Hint Extern 1 => progress cbn.

    

    Local Obligation Tactic := basic_simpl; auto 10.

    

    Program Definition Equalizer_Producing_Cat : Category

      :=

        {|

          Obj := bool;

          Hom :=

            fun x y =>

              match (x, y) with

              | (true, true) => unit

              | (true, false) => bool

              | (false, true) => Empty

              | (false, false) => unit

              end;

          compose :=

            fun x y z h h'=> _;

          id := fun x => _

        |}

    .



    Next Obligation.

    Proof.

      destruct x; destruct y; destruct z; auto.

    Defined.



    Next Obligation.

    Proof.    

      destruct x; constructor.

    Defined.



    Program Definition Equalizer_Producing_Func :

      (Equalizer_Producing_Cat –≻ C)%functor

      :=

        {|

          FO :=

            fun x =>

              match x with

              | true => a

              | false => b

              end;

          FA := fun x y h => _

        |}

    .



    Next Obligation.

    Proof.

      destruct x; destruct y.

      exact id.

      destruct h.

      {

        exact f.

      }

      {

        exact g.

      }

      destruct h.

      exact id.

    Defined.

    

    Context (L : Limit Equalizer_Producing_Func).

    

    Program Definition Equalizer_as_Limit_Cone

            {p : C}

            {h : (p –≻ a)%morphism}

            (H : (f ∘ h)%morphism = (g ∘ h)%morphism)

      :

        Cone Equalizer_Producing_Func

      :=

        {|

          cone_apex :=

            {|

              FO := fun _ => p;

              FA := fun _ _ _ => id

            |};

          cone_edge :=

            {|

              Trans :=

                fun x =>

                  match x with

                  | true => h

                  | false => (f ∘ h)%morphism

                  end

            |}

        |}

    .



    Local Obligation Tactic := idtac.



    Program Definition Equalizer_as_Limit_Cone_morph

            {p : C}

            {h : (p –≻ a)%morphism}

            (H1 : (f ∘ h)%morphism = (g ∘ h)%morphism)

            (k : (p –≻ L)%morphism)

            (H2 : (Trans L true ∘ k)%morphism = h)

      :

        Cone_Morph _ (Equalizer_as_Limit_Cone H1) (LRKE L)

      :=

        {|

          cone_morph :=

            {|

              Trans :=

                fun c =>

                  match c as u return ( _ –≻ L _o u)%object%morphism with

                    tt => k

                  end

            |}

        |}

    .      



    Next Obligation.

    Proof.

      basic_simpl; auto 10.

    Qed.



    Next Obligation.

    Proof.

      basic_simpl; auto 10.

    Qed.

      

    Next Obligation.

    Proof.

      intros p h H1 k H2.

      apply NatTrans_eq_simplify.

      extensionality x.

      cbn in *.

      destruct x; auto.

      rewrite assoc_sym.

      cbn_rewrite (@Trans_com _ _ _ _ L true false false).

      rewrite assoc.

      rewrite H1; rewrite <- H2.

      trivial.

    Qed.

      

    Program Definition Equalizer_as_Limit : Equalizer f g :=

      {|

        equalizer := L;

        equalizer_morph := Trans L true;

        equalizer_morph_ex :=

          fun e eqm H =>

            Trans (LRKE_morph_ex L (Equalizer_as_Limit_Cone H)) tt

      |}

    .



    Local Obligation Tactic := idtac.



    Next Obligation.

    Proof.

      set (H := @Trans_com _ _ _ _ L true false false).

      cbn in H.

      cbn_rewrite (@Trans_com _ _ _ _ L true false true) in H.

      trivial.

    Qed.



    Next Obligation.

    Proof.

      intros e eqm eqmc; cbn.

      cbn_rewrite (

          f_equal

            (fun w :

                   ((Equalizer_as_Limit_Cone eqmc)

                      ∘ Functor_To_1_Cat Equalizer_Producing_Cat

                      –≻ Equalizer_Producing_Func)%nattrans

             => Trans w true)

            (cone_morph_com (LRKE_morph_ex L (Equalizer_as_Limit_Cone eqmc)))

        ).

      auto.

    Qed.



    Next Obligation.

    Proof.

      intros e eqm H1 h h' H2 H3.

      apply (

          f_equal

            (fun w : (Equalizer_as_Limit_Cone H1 –≻ L)%nattrans => Trans w tt)

            (

              LRKE_morph_unique

                L

                _

                (Equalizer_as_Limit_Cone_morph _ _ H2)

                (Equalizer_as_Limit_Cone_morph _ _ H3)

            )

        ).

    Qed.



  End Equalizer.



  Section PullBack.

    Context

      {a b c : C}

      (f : (a –≻ c)%morphism)

      (g : (b –≻ c)%morphism)

    .

    

    Inductive PBType :=

    | PB_A

    | PB_B

    | PB_C

    .

      

    Local Hint Extern 1 => match goal with [x : unit |- _] => destruct x end.

    Local Hint Extern 1 => match goal with [x : PBType |- _] => destruct x end.

    Local Hint Extern 1 => match goal with [x : Empty |- _] => destruct x end.

    Local Hint Extern 1 => match goal with [x : bool |- _] => destruct x end.

    Local Hint Extern 1 => match goal with [|- unit] => constructor end.

    Local Hint Extern 1 => rewrite From_Term_Cat.

    Local Hint Extern 1 => apply NatTrans_eq_simplify.

    Local Hint Extern 1 => progress cbn.

    

    Local Obligation Tactic := basic_simpl; auto 10.

    

    Program Definition PullBack_Producing_Cat : Category

      :=

        {|

          Obj := PBType;

          Hom :=

            fun x y =>

              match (x, y) with

              | (PB_A, PB_A) => unit

              | (PB_A, PB_B) => Empty

              | (PB_A, PB_C) => unit

              | (PB_B, PB_A) => Empty

              | (PB_B, PB_B) => unit

              | (PB_B, PB_C) => unit

              | (PB_C, PB_A) => Empty

              | (PB_C, PB_B) => Empty

              | (PB_C, PB_C) => unit

              end;

          compose :=

            fun x y z h h'=> _;

          id := fun x => _

        |}

    .



    Program Definition PullBack_Producing_Func :

      (PullBack_Producing_Cat –≻ C)%functor

      :=

        {|

          FO :=

            fun x =>

              match x with

              | PB_A => a

              | PB_B => b

              | PB_C => c

              end;

          FA := fun x y h => _

        |}

    .



    Next Obligation.

    Proof.

      destruct x; destruct y; auto; try exact id.

    Defined.

    

    Context (L : Limit PullBack_Producing_Func).

    

    Program Definition PullBack_as_Limit_Cone

            {p : C}

            {h : (p –≻ a)%morphism}

            {h' : (p –≻ b)%morphism}

            (H : (f ∘ h)%morphism = (g ∘ h')%morphism)

      :

        Cone PullBack_Producing_Func

      :=

        {|

          cone_apex :=

            {|

              FO := fun _ => p;

              FA := fun _ _ _ => id

            |};

          cone_edge :=

            {|

              Trans :=

                fun x =>

                  match x with

                  | PB_A => h

                  | PB_B => h'

                  | PB_C => (f ∘ h)%morphism

                  end

            |}

        |}

    .



    Local Obligation Tactic := idtac.



    Program Definition PullBack_as_Limit_Cone_morph

            {p : C}

            {h : (p –≻ a)%morphism}

            {h' : (p –≻ b)%morphism}

            (H1 : (f ∘ h)%morphism = (g ∘ h')%morphism)

            (k : (p –≻ L)%morphism)

            (H2 : (Trans L PB_A ∘ k)%morphism = h)

            (H3 : (Trans L PB_B ∘ k)%morphism = h')

      :

        Cone_Morph _ (PullBack_as_Limit_Cone H1) (LRKE L)

      :=

        {|

          cone_morph :=

            {|

              Trans :=

                fun c =>

                  match c as u return ( _ –≻ L _o u)%object%morphism with

                    tt => k

                  end

            |}

        |}

    .      



    Next Obligation.

    Proof.

      basic_simpl; auto 10.

    Qed.



    Next Obligation.

    Proof.

      basic_simpl; auto 10.

    Qed.

      

    Next Obligation.

    Proof.

      intros p h h' H1 k H2 H3.

      apply NatTrans_eq_simplify.

      extensionality x.

      cbn in *.

      destruct x; auto.

      rewrite assoc_sym.

      cbn_rewrite (@Trans_com _ _ _ _ L PB_B PB_C tt).

      rewrite assoc.

      rewrite H1; rewrite <- H3.

      trivial.

    Qed.

    

    Program Definition PullBack_as_Limit : PullBack f g :=

      {|

        pullback := L;

        pullback_morph_1 := Trans L PB_A;

        pullback_morph_2 := Trans L PB_B;

        pullback_morph_ex :=

          fun e pm1 pm2 pmc =>

            Trans (LRKE_morph_ex L (PullBack_as_Limit_Cone pmc)) tt

      |}

    .



    Local Obligation Tactic := idtac.



    Next Obligation.

    Proof.

      set (H := @Trans_com _ _ _ _ L PB_B PB_C tt).

      cbn in H.

      cbn_rewrite (@Trans_com _ _ _ _ L PB_A PB_C tt) in H.

      trivial.

    Qed.



    Next Obligation.

    Proof.

      intros e pm1 pm2 pmc; cbn.

      cbn_rewrite (

          f_equal

            (fun w :

                   ((PullBack_as_Limit_Cone pmc)

                      ∘ Functor_To_1_Cat PullBack_Producing_Cat

                      –≻ PullBack_Producing_Func)%nattrans

             => Trans w PB_A)

            (cone_morph_com (LRKE_morph_ex L (PullBack_as_Limit_Cone pmc)))

        ).

      auto.

    Qed.



    Next Obligation.

    Proof.

      intros e pm1 pm2 pmc; cbn.

      cbn_rewrite (

          f_equal

            (fun w :

                   ((PullBack_as_Limit_Cone pmc)

                      ∘ Functor_To_1_Cat PullBack_Producing_Cat

                      –≻ PullBack_Producing_Func)%nattrans

             => Trans w PB_B)

            (cone_morph_com (LRKE_morph_ex L (PullBack_as_Limit_Cone pmc)))

        ).

      auto.

    Qed.

    

    Next Obligation.

    Proof.

      intros e pm1 pm2 H1 h h' H2 H3 H4 H5.

      apply (

          f_equal

            (fun w : (PullBack_as_Limit_Cone H1 –≻ L)%nattrans => Trans w tt)

            (

              LRKE_morph_unique

                L

                _

                (PullBack_as_Limit_Cone_morph _ _ H2 H3)

                (PullBack_as_Limit_Cone_morph _ _ H4 H5)

            )

        ).

    Qed.



  End PullBack.



End Limits.

