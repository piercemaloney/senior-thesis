From Categories Require Import Essentials.Notations.
(* Categories.Essentials.Notations:
Notation "∀ x .. y , P" := (forall x, .. (forall y, P) ..)
                             (at level 200, x binder, y binder, right associativity) : type_scope.

Notation "∃ x .. y , P" := (exists x, .. (exists y, P) ..)
  (at level 200, x binder, y binder, right associativity) : type_scope.

Notation "x ∨ y" := (x \/ y) (at level 85, right associativity) : type_scope.

Notation "x ∧ y" := (x /\ y) (at level 80, right associativity) : type_scope.

Notation "x → y" := (x -> y)
  (at level 90, y at level 200, right associativity): type_scope.

Notation "x ↔ y" := (x <-> y) (at level 95, no associativity): type_scope.

Notation "¬ x" := (~x) (at level 75, right associativity) : type_scope.

Notation "x ≠ y" := (x <> y) (at level 70) : type_scope.

Notation "x ≤ y" := (le x y) (at level 70, no associativity).

Notation "x ≥ y" := (ge x y) (at level 70, no associativity).

Reserved Notation "C '^op'" (at level 50, no associativity).

Reserved Notation "a –≻ b" (at level 90, b at level 200, right associativity).

Reserved Notation "f '⁻¹'" (at level 50, no associativity).

Reserved Notation "a ≃ b" (at level 70, no associativity).

Reserved Notation "a ≃≃ b ::> C" (at level 70, no associativity).

Reserved Notation "f ∘ g" (at level 51, right associativity).

Reserved Notation "f '∘_h' g" (at level 51, right associativity).

Reserved Notation "a ≫–> b" (at level 100, no associativity).

Reserved Notation "a –≫ b" (at level 100, no associativity).

Reserved Notation "F '_o'" (at level 50, no associativity).

Reserved Notation "F '_a'" (at level 50, no associativity).

Reserved Notation "F '@_a'" (at level 50, no associativity).

Reserved Notation "F ⊣ G" (at level 100, no associativity).

Reserved Notation "F ⊣_hom G" (at level 100, no associativity).

Reserved Notation "F ⊣_ucu G" (at level 100, no associativity).

Reserved Notation "a × b" (at level 80, no associativity).

Reserved Notation "a ⇑ b" (at level 79, no associativity).

Reserved Notation "'Π' m" (at level 50, no associativity).

Reserved Notation "'Σ' m" (at level 50, no associativity).

Reserved Notation "'Π_' C ↓ m" (at level 50, no associativity).

Reserved Notation "'Σ_' C ↓ m" (at level 50, no associativity).

Delimit Scope category_scope with category.

Delimit Scope morphism_scope with morphism.

Delimit Scope object_scope with object.

Delimit Scope functor_scope with functor.

Delimit Scope nattrans_scope with nattrans.

Delimit Scope nattrans_scope with nattrans.

Delimit Scope natiso_scope with natiso.

Delimit Scope isomorphism_scope with isomorphism.

Delimit Scope preorder_scope with preorder. *)

From Categories Require Import Essentials.Types.
(* Categories.Essentials.Types:
Global Set Primitive Projections.

Global Set Universe Polymorphism.

Global Unset Universe Minimization ToSet.

Inductive Empty : Type :=.

Hint Extern 1 =>
let tac := (repeat intros ?); match goal with [H : Empty |- _] => contradict H end in
match goal with
  | [|- context[Empty]] => tac
  | [H : context[Empty] |- _] => tac
end
.

Record prod (A B : Type) := {fst : A; snd : B}.

Arguments fst {_ _ } _.
Arguments snd {_ _ } _.
Arguments Build_prod {_ _ } _ _.

Notation "( X , Y )" := (Build_prod X Y).
Notation "X * Y" := (prod X Y) : type_scope. *)

From Categories Require Import Essentials.Facts_Tactics.
(* Categories.Essentials.Facts_Tactics:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.

Require Export Coq.Program.Tactics.
Require Export Coq.Program.Equality.
Require Export Coq.Logic.FunctionalExtensionality.
Require Export Coq.Logic.ProofIrrelevance.

Definition equal_f : ∀ {A B : Type} {f g : A → B}, f = g → ∀ x : A, f x = g x.

Definition f_equal : ∀ (A B : Type) (f : A → B) (x y : A), x = y → f x = f y.

Arguments f_equal [_ _] _ [_ _] _.

Ltac basic_simpl :=
  let simpl_prod _ :=
      match goal with
        [H : prod _ _ |- _] =>
        let H1 := fresh H "1" in
        let H2 := fresh H "2" in
        destruct H as [H1 H2]
      end
  in
  let simpl_sig _ :=
      match goal with
        [H : @sig _ _ |- _] =>
        let H1 := fresh H "1" in
        let H2 := fresh H "2" in
        destruct H as [H1 H2]
      end
  in
  let basic_simpl_helper _ :=
      cbn in *; intros;
        repeat simpl_prod tt;
        repeat simpl_sig tt
  in
  repeat basic_simpl_helper tt
.

Global Obligation Tactic := basic_simpl; auto.

Ltac PIR :=
  let pir_helper _ :=
      match goal with
      |[H : ?A, H' : ?A|- _] =>
       match type of A with
       | Prop =>
         destruct (proof_irrelevance _ H H')
       end
      end
  in
  repeat pir_helper tt
.

Ltac ElimEq := repeat match goal with [H : _ = _|- _] => destruct H end.

Hint Extern 1 => progress ElimEq.

Ltac cbn_rewrite W :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite H; clear H
.

Ltac cbn_rewrite_in W V :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite H in V; clear H
.

Ltac cbn_rewrite_back W :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite <- H; clear H
.

Ltac cbn_rewrite_back_in W V :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite <- H in V; clear H
.

Tactic Notation "cbn_rewrite" constr(W) := cbn_rewrite W.
Tactic Notation "cbn_rewrite" constr(W) "in" hyp_list(V) := cbn_rewrite_in W V.
Tactic Notation "cbn_rewrite" "<-" constr(W) := cbn_rewrite_back W.
Tactic Notation "cbn_rewrite" "<-" constr(W) "in" hyp_list(V) := cbn_rewrite_back_in W V.

Lemma sig_proof_irrelevance {A : Type} (P : A → Prop) (X Y : sig P) : proj1_sig X = proj1_sig Y → X = Y.

Hint Extern 2 (exist ?A _ _ = exist ?A _ _) => apply sig_proof_irrelevance.

Ltac FunExt :=
progress (
    repeat (
        match goal with
          [|- _ = _] =>
          let x := fresh "x" in
          extensionality x
        end
      )
  )
.

Hint Extern 1 => FunExt.

Lemma pair_eq (A B : Type) (a b : A * B) : fst a = fst b → snd a = snd b → a = b.

Hint Resolve pair_eq.

Ltac revert_clearbody_all :=
 repeat lazymatch goal with H:_ |- _ => try clearbody H; revert H end.

Ltac hyp_stack :=
 constr:(ltac:(revert_clearbody_all;constructor) : True).

Ltac next_hyp hs step last :=
 lazymatch hs with (?hs' ?H) => step H hs' | _ => last end.

Tactic Notation "dohyps" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := tac H; next_hyp hs step idtac in
 next_hyp hs step idtac.

Tactic Notation "dohyps" "reverse" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := next_hyp hs step idtac; tac H in
 next_hyp hs step idtac.

Tactic Notation "do1hyp" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := tac H + next_hyp hs step fail in
 next_hyp hs step fail.

Tactic Notation "do1hyp" "reverse" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := next_hyp hs step fail + tac H in
 next_hyp hs step fail. *)

From Categories Require Import Category.Category Category.Morph Category.Opposite.
(* Categories.Category.Category:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.

Cumulative Class Category : Type :=
{
  
  Obj : Type;

  Hom : Obj → Obj → Type where "a –≻ b" := (Hom a b);

  compose : ∀ {a b c : Obj}, (a –≻ b) → (b –≻ c) → (a –≻ c) where "f ∘ g" := (compose g f);

  assoc : ∀ {a b c d : Obj} (f : a –≻ b) (g : b –≻ c) (h : c –≻ d),
            ((h ∘ g) ∘ f) = (h ∘ (g ∘ f));

  assoc_sym : ∀ {a b c d : Obj} (f : a –≻ b) (g : b –≻ c) (h : c –≻ d),
                ((h ∘ (g ∘ f) = (h ∘ g) ∘ f));

  id : ∀ {a : Obj}, a –≻ a;

  id_unit_left : ∀ (a b : Obj) (h : a –≻ b), id ∘ h = h;

  id_unit_right : ∀ (a b : Obj) (h : a –≻ b), h ∘ id = h
}.

Arguments Obj {_}, _.
Arguments id {_ _}, {_} _, _ _.
Arguments Hom {_} _ _, _ _ _.
Arguments compose {_} {_ _ _} _ _, _ {_ _ _} _ _, _ _ _ _ _ _.
Arguments assoc {_ _ _ _ _} _ _ _.
Arguments assoc_sym {_ _ _ _ _} _ _ _.

Notation "f ∘ g" := (compose g f) : morphism_scope.
Notation "a –≻ b" := (Hom a b) : morphism_scope.

Bind Scope category_scope with Category.

Bind Scope morphism_scope with Hom.

Bind Scope object_scope with Obj.

Coercion Obj : Category >-> Sortclass.

Hint Resolve id_unit_left id_unit_right.

Ltac simpl_ids :=
  let id_detected B :=
      let J := fresh "H" in
      cut (B = id); [intros J; rewrite J; clear J | trivial]
  in
  repeat(
      match goal with
        | [|- context[(?A ∘ id)%morphism] ] => rewrite id_unit_right
        | [|- context[(id ∘ ?A)%morphism] ] => rewrite id_unit_left
        | [|- (?A ∘ ?B)%morphism = ?A] => id_detected B
        | [|- (?A = ?A ∘ ?B) %morphism] => id_detected B
        | [|- (?B ∘ ?A = ?A)%morphism] => id_detected B
        | [|- (?A = ?B ∘ ?A)%morphism] => id_detected B
      end
    )
.

Ltac simpl_ids_in_I I :=
  repeat(
      match type of I with
        | context[(?A ∘ id)%morphism] => rewrite id_unit_right in I
        | context[(id ∘ ?A)%morphism] => rewrite id_unit_left in I
      end
    )
.

Tactic Notation "simpl_ids" := simpl_ids.

Tactic Notation "simpl_ids" "in" hyp(I) := simpl_ids_in_I I.

Hint Extern 1 => progress simpl_ids.

Hint Extern 3 => progress (dohyps (fun H => simpl_ids in H)).

Hint Extern 2 =>
match goal with
    [|- ?A = ?B :> Hom _ _ _] =>
    repeat rewrite assoc; trivial; fail
end.

Hint Extern 2 =>
match goal with
  [H : _ = _ :> Hom _ _ _ |- _ = _ :> Hom _ _ _] =>
  repeat rewrite assoc in H;
    repeat rewrite assoc;
    (idtac + symmetry); apply H
end. *)
(* Categories.Category.Morph:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Category.
From Categories Require Import Category.Opposite.

Local Open Scope morphism_scope.

Record Isomorphism {C : Category} (a b : C) : Type := 
{
  iso_morphism : a –≻ b;
  
  inverse_morphism : b –≻ a;
  
  left_inverse : (inverse_morphism ∘ iso_morphism)%morphism = id;
  
  right_inverse : (iso_morphism ∘ inverse_morphism)%morphism = id
}.

Bind Scope morphism_scope with Isomorphism.
Bind Scope isomorphism_scope with Isomorphism.

Hint Resolve left_inverse.

Hint Resolve right_inverse.

Coercion iso_morphism : Isomorphism >-> Hom.

Arguments iso_morphism {_ _ _} _.
Arguments inverse_morphism {_ _ _} _.
Arguments left_inverse {_ _ _} _.
Arguments right_inverse {_ _ _} _.

Notation "f '⁻¹'" := (inverse_morphism f) : morphism_scope.

Notation "a ≃ b" := (Isomorphism a b) : isomorphism_scope.

Notation "a ≃≃ b ::> C" := (@Isomorphism C a b) : isomorphism_scope.

Local Open Scope isomorphism_scope.

Ltac simpl_isos_in_goal :=
  repeat(
      match goal with
      | [|- context[(iso_morphism ?A ∘ inverse_morphism ?A)%morphism]] =>
        rewrite (right_inverse A); simpl_ids
      | [|- context[(inverse_morphism ?A ∘ iso_morphism ?A)%morphism] ] =>
        rewrite (left_inverse A); simpl_ids

      end
    )
.

Ltac simpl_isos_in_I I :=
  repeat(
      match type of I with
      | context[(iso_morphism ?A ∘ inverse_morphism ?A)%morphism] =>
        rewrite (right_inverse A) in I; simpl_ids in I
      | context[(inverse_morphism ?A ∘ iso_morphism ?A)%morphism] =>
        rewrite (left_inverse A) in I; simpl_ids in I

      end
    )
.

Tactic Notation "simpl_isos" := simpl_isos_in_goal.

Tactic Notation "simpl_isos" "in" hyp(I) := simpl_isos_in_I I.

Hint Extern 3 => progress simpl_isos.

Hint Extern 3 => progress (dohyps (fun H => simpl_isos in H)).

Theorem Isomorphism_eq_simplify {C : Category} {a b : C} (I I' : a ≃ b) :
  (iso_morphism I = iso_morphism I') →
  (inverse_morphism I = inverse_morphism I') → I = I'.

Program Definition Isomorphism_id {C : Category} {a : C} : a ≃ a :=
{|
  iso_morphism := id;
  inverse_morphism := id
|}.

Definition Inverse_Isomorphism {C : Category} {a b : C} (I : a ≃ b) : b ≃ a :=
{|
  iso_morphism := I⁻¹;
  inverse_morphism := I;
  left_inverse := right_inverse I;
  right_inverse := left_inverse I
|}.

Notation "f '⁻¹'" := (Inverse_Isomorphism f) : isomorphism_scope.

Program Definition Isomorphism_Compose
        {C : Category} {a b c : C} (I : a ≃ b) (I' : b ≃ c) : a ≃ c
  :=
{|
  iso_morphism := I' ∘ I;
  inverse_morphism := I⁻¹ ∘ I'⁻¹
|}.

Notation "f ∘ g" := (Isomorphism_Compose g f) : isomorphism_scope.

Local Close Scope isomorphism_scope.

Record Monic {C : Category} (a b : Obj) :=
{
  mono_morphism : a –≻ b;
  mono_morphism_monomorphic : ∀ (c : Obj) (g h : c –≻ a),
      (mono_morphism ∘ g = mono_morphism ∘ h) → g = h
}.

Coercion mono_morphism : Monic >-> Hom.

Arguments mono_morphism {_ _ _} _.
Arguments mono_morphism_monomorphic {_ _ _} _ _ _ _ _.

Notation "a ≫–> b" := (Monic a b) : morphism_scope.

Bind Scope morphism_scope with Monic.

Definition Epic {C : Category} (a b : C) := @Monic (C^op) b a.

Notation "a –≫ b" := (Epic a b) : morphism_scope.

Bind Scope morphism_scope with Epic.

Definition is_Monic {C : Category} {a b : Obj} (f : a –≻ b) :=
  ∀ (c : Obj) (g h : c –≻ a), (f ∘ g = f ∘ h) → g = h.

Definition is_Monic_Monic
           {C : Category}
           {a b : Obj}
           {f : a –≻ b}
           (H : is_Monic f)
  : Monic a b
  :=
    {|
      mono_morphism := f;
      mono_morphism_monomorphic := H
    |}
.

Definition is_Epic {C : Category} {a b : C} (f : a –≻ b) :=
  @is_Monic (C^op) b a f.

Record is_split_Monic {C : Category} {a b : Obj} (f : a –≻ b) :=
  {
    is_split_monic_left_inverse : b –≻ a;
    is_split_monic_left_inverse_is_left_inverse :
      (is_split_monic_left_inverse ∘ f) = id
  }
.

Arguments is_split_monic_left_inverse {_ _ _ _} _.
Arguments is_split_monic_left_inverse_is_left_inverse {_ _ _ _} _.

Definition is_split_Epic {C : Category} {a b : C} (f : a –≻ b) :=
  @is_split_Monic (C^op) b a f.

Program Definition is_split_Monic_Monic
           {C : Category}
           {a b : Obj}
           {f : a –≻ b}
           (H : is_split_Monic f)
  : Monic a b
  :=
    {|
      mono_morphism := f;
      mono_morphism_monomorphic := fun c g h H1 => _
    |}
.

Program Definition Monic_is_split_Epic_Iso
        {C : Category}
        (a b : Obj)
        (f : a ≫–> b)
        (H : is_split_Epic f)
  :
    (a ≃ b)%isomorphism
  :=
    {|
      iso_morphism := f;
      inverse_morphism := is_split_monic_left_inverse H;
      right_inverse := is_split_monic_left_inverse_is_left_inverse H
    |}
.

Program Definition Compose_Monic_is_Monic_then_Monic
           {C : Category}
           {a b c : C}
           (M : a –≻ b)
           (M' : b ≫–> c)
           (H : is_Monic (M' ∘ M))
  :
    Monic a b
  :=
    {|
      mono_morphism := M;
      mono_morphism_monomorphic := fun d g h H1 => _
    |}
.

Section Mono_compose.
  Context {C : Category} {a b c : C} (M : a ≫–> b) (M' : b ≫–> c).

  Local Hint Resolve mono_morphism_monomorphic.

  Local Obligation Tactic := eauto.
  
  Program Definition Mono_compose : a ≫–> c :=
    {|
      mono_morphism := M' ∘ M
    |}.
    
End Mono_compose.

Local Open Scope isomorphism_scope.

Section Iso_Mono_Epi.
  Context {C : Category} {a b : Obj} (I : a ≃ b).

  Program Definition Ismorphism_Monic : a ≫–> b :=
    {|
      mono_morphism := I
    |}.

  Program Definition Ismorphism_Epic : b –≫ a :=
    {|
      mono_morphism := inverse_morphism I
    |}.

End Iso_Mono_Epi.

Theorem CoIso {C : Category} (a b : C) : a ≃≃ b ::> C → a ≃≃ b ::> C^op. *)
(* Categories.Category.Opposite:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Category.

Definition Opposite (C : Category) : Category :=
{|

  Obj := Obj C;
           
  Hom := fun a b => (b –≻ a)%morphism;

  compose :=
    fun a b c (f : (b –≻ a)%morphism) (g : (c –≻ b)%morphism) => compose C c b a g f;

  id := fun c => id C c;
  
  assoc := fun _ _ _ _ f g h => assoc_sym h g f;

  assoc_sym := fun _ _ _ _ f g h => assoc h g f;

  id_unit_left := fun _ _ h => @id_unit_right C _ _ h;
  
  id_unit_right := fun _ _ h => @id_unit_left C _ _ h
                   
|}.

Notation "C '^op'" := (Opposite C) : category_scope. *)

From Categories Require Import Ext_Cons.Arrow.
(* Categories.Ext_Cons.Arrow:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Coq_Cats.Type_Cat.Type_Cat.

Section Arrow.
  Local Open Scope morphism_scope.

  Record Arrow (C : Category) :=
    {
      Orig : Obj;
      Targ : Obj;
      Arr : Orig –≻ Targ
    }.

  Arguments Orig {_} _.
  Arguments Targ {_} _.
  Arguments Arr {_} _.

  Coercion Arr : Arrow >-> Hom.

  Record Arrow_Hom {C : Category} (a b : Arrow C) :=
    {
      Arr_H : (Orig a) –≻ (Orig b);
      Arr_H' : (Targ a) –≻ (Targ b);
      Arr_Hom_com : Arr_H' ∘ (Arr a) = (Arr b) ∘ Arr_H
    }.
  Arguments Arr_H {_ _ _} _.
  Arguments Arr_H' {_ _ _} _.
  Arguments Arr_Hom_com {_ _ _} _.

  Context (C : Category).

  Section Arrow_Hom_eq_simplify.
    Context {a b : Arrow C} (f g : Arrow_Hom a b).

    Lemma Arrow_Hom_eq_simplify : Arr_H f = Arr_H g → Arr_H' f = Arr_H' g → f = g.

  End Arrow_Hom_eq_simplify.

  Section Compose_id.
    Context {x y z} (h : Arrow_Hom x y) (h' : Arrow_Hom y z).

    Program Definition Arrow_Hom_compose : Arrow_Hom x z :=
      {|
        Arr_H := (Arr_H h') ∘ (Arr_H h);
        Arr_H' := (Arr_H' h') ∘ (Arr_H' h)
      |}.

    Program Definition Arrow_id : Arrow_Hom x x :=
      {|
        Arr_H := id;
        Arr_H' := id
      |}.

  End Compose_id.

End Arrow.

Hint Extern 1 (?A = ?B :> Arrow_Hom _ _) => apply Arrow_Hom_eq_simplify; simpl.

Arguments Orig {_} _.
Arguments Targ {_} _.
Arguments Arr {_} _.

Arguments Arr_H {_ _ _} _.
Arguments Arr_H' {_ _ _} _.
Arguments Arr_Hom_com {_ _ _} _.

Program Definition Arrow_to_Arrow_OP (C : Category) (ar : Arrow C) :
  Arrow (C ^op) :=
  {|
    Arr := ar
  |}.

Program Definition Arrow_OP_Iso (C : Category) :
  ((Arrow C) ≃≃ (Arrow (C ^op)) ::> Type_Cat)%isomorphism :=
  {|
    iso_morphism := Arrow_to_Arrow_OP C;
    inverse_morphism := Arrow_to_Arrow_OP (C ^op)
  |}. *)

From Categories Require Import Functor.Functor Functor.Functor_Ops Const_Func.
(* Categories.Functor.Functor:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.

Record Functor (C C' : Category) : Type :=
{
  
  FO : C → C';

  FA : ∀ {a b}, (a –≻ b)%morphism → ((FO a) –≻ (FO b))%morphism;

  F_id : ∀ c, FA (id c) = id (FO c);

  F_compose : ∀ {a b c} (f : (a –≻ b)%morphism) (g : (b –≻ c)%morphism),
      (FA (g ∘ f) = (FA g) ∘ (FA f))%morphism

}.

Arguments FO {_ _} _ _.
Arguments FA {_ _} _ {_ _} _, {_ _} _ _ _ _.
Arguments F_id {_ _} _ _.
Arguments F_compose {_ _} _ {_ _ _} _ _.

Notation "C –≻ D" := (Functor C D) : functor_scope.

Bind Scope functor_scope with Functor.

Notation "F '_o'" := (FO F) : object_scope.

Notation "F '@_a'" := (@FA _ _ F) : morphism_scope.

Notation "F '_a'" := (FA F) : morphism_scope.

Hint Extern 2 => (apply F_id).

Local Open Scope morphism_scope.
Local Open Scope object_scope.

Ltac Functor_Simplify :=
  progress
    (
      repeat rewrite F_id;
      (
        repeat
          match goal with
          | [|- ?F _a ?A = id (?F _o ?x)] =>
            (rewrite <- F_id; (cbn+idtac))
          | [|- (id (?F _o ?x)) = ?F _a ?A] =>
            (rewrite <- F_id; (cbn+idtac))
          | [|- ?F _a ?A ∘ ?F _a ?B = ?F _a ?C ∘ ?F _a ?D] =>
            (repeat rewrite <- F_compose; (cbn+idtac))
          | [|- ?F _a ?A ∘ ?F _a ?B = ?F _a ?C] =>
            (rewrite <- F_compose; (cbn+idtac))
          | [|- ?F _a ?C = ?F _a ?A ∘ ?F _a ?B] =>
            (rewrite <- F_compose; (cbn+idtac))
          | [|- context [?F _a ?A ∘ ?F _a ?B]] =>
            (rewrite <- F_compose; (cbn+idtac))
          end
      )
    )
.

Hint Extern 2 => Functor_Simplify.

Section Functor_eq_simplification.

  Context {C C' : Category} (F G : (C –≻ C')%functor).

  Lemma Functor_eq_simplify (Oeq : F _o = G _o) :
    ((fun x y =>
        match Oeq in _ = V return ((x –≻ y) → ((V x) –≻ (V y)))%morphism with
          eq_refl => F  @_a x y
        end) = G @_a) -> F = G.

  Theorem FA_extensionality (Oeq : F _o = G _o) :
    (
      ∀ (a b : Obj)
        (h : (a –≻ b)%morphism),
        (
          fun x y =>
            match Oeq in _ = V return
                  ((x –≻ y) → ((V x) –≻ (V y)))%morphism
            with
              eq_refl => F  @_a x y
            end
        ) _ _ h = G _a h
    )
    →
    (
      fun x y =>
        match Oeq in _ = V return
              ((x –≻ y) → ((V x) –≻ (V y)))%morphism
        with
          eq_refl => F  @_a x y
        end
    ) = G @_a.

  Lemma Functor_extensionality (Oeq : F _o = G _o) :
    (
      ∀ (a b : Obj) (h : (a –≻ b)%morphism),
        (
          fun x y =>
            match Oeq in _ = V return
                  ((x –≻ y) → ((V x) –≻ (V y)))%morphism
            with
              eq_refl => F  @_a x y
            end
        ) _ _ h = G _a h
    ) → F = G.

End Functor_eq_simplification.

Hint Extern 2 => Functor_Simplify.

Ltac Func_eq_simpl :=
  match goal with
    [|- ?A = ?B :> Functor _ _] =>
    (apply (Functor_eq_simplify A B (eq_refl : A _o = B _o)%object)) +
    (cut (A _o = B _o)%object; [
       let u := fresh "H" in
       intros H;
         apply (Functor_eq_simplify A B H)
         |
    ])
  end.

Hint Extern 3 => Func_eq_simpl.

Section Functor_eq.
  Context {C C' : Category} (F G : (C –≻ C')%functor).

  Lemma Functor_eq_morph (H : F = G) :
    ∃ (H : ∀ x, F _o x = G _o x),
    ∀ x y (h : (x –≻ y)%morphism),
      match H x in _ = V return (V –≻ _)%morphism with
         eq_refl =>
         match H y in _ = V return (_ –≻ V)%morphism with
           eq_refl => F _a h
         end
       end = G _a h.

End Functor_eq. *)
(* Categories.Functor.Functor_Ops:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Functor.

Section Opposite_Functor.
  Context {C D : Category} (F : (C –≻ D)%functor).
  
  Local Open Scope morphism_scope.
  Local Open Scope object_scope.
    
  Program Definition Opposite_Functor : (C^op –≻ D^op)%functor :=
    {|
      FO := F _o;
      FA := fun _ _ h => F @_a _ _ h;
      F_id := fun a => F_id F a;
      F_compose := fun _ _ _ f g => F_compose F g f
    |}.

End Opposite_Functor.

Notation "F '^op'" := (Opposite_Functor F) : functor_scope.

Section Functor_Compose.
  Context {C C' C'' : Category} (F : (C –≻ C')%functor) (F' : (C' –≻ C'')%functor).

  Local Open Scope morphism_scope.
  Local Open Scope object_scope.
  
  Program Definition Functor_compose : (C –≻ C'')%functor :=
    {|
      FO := fun c => F' _o (F _o c);
      FA := fun c d f => F' _a (F _a f)
    |}.
  
End Functor_Compose.

Notation "F ∘ G" := (Functor_compose G F) : functor_scope. 

Section Functor_Assoc.
  Context {C1 C2 C3 C4 : Category}
          (F : (C1 –≻ C2)%functor)
          (G : (C2 –≻ C3)%functor)
          (H : (C3 –≻ C4)%functor).

  Local Open Scope functor_scope.
    
  Theorem Functor_assoc : (H ∘ G) ∘ F = H ∘ (G ∘ F).

End Functor_Assoc.

Program Definition Functor_id (C : Category) : (C –≻ C)%functor :=
  {|
    FO := fun x => x;
    FA := fun c d f => f
  |}.

Section Functor_Identity_Unit.
  Context  (C C' : Category) (F : (C –≻ C')%functor).

  Theorem Functor_id_unit_left : ((Functor_id C') ∘ F)%functor = F.

  Theorem Functor_id_unit_right : (Functor_compose (Functor_id _) F) = F.

End Functor_Identity_Unit. *)

From Categories Require Import Archetypal.Discr.Discr.
(* Categories.Archetypal.Discr.Discr:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Functor.
From Categories Require Import Cat.Cat.
From Categories Require Import Coq_Cats.Type_Cat.Type_Cat.

Definition EmptyCat : Category :=
  {|
    Obj := (Empty : Type);
    Hom := fun _ _ => (unit : Type);
    compose := fun _ _ _ _ _ => tt;
    assoc := fun _ _ _ _ _ _ _ => eq_refl;
    assoc_sym := fun _ _ _ _ _ _ _ => eq_refl;
    id := fun _ => tt;
    id_unit_left :=
      fun _ _ h =>
        match h as u return (tt = u) with
        | tt => eq_refl
        end;
    id_unit_right :=
      fun _ _ h =>
        match h as u return (tt = u) with
        | tt => eq_refl
        end
  |}.

Definition SingletonCat : Category :=
  {|
    Obj := (unit : Type);
    Hom := fun _ _ => (unit : Type);
    compose := fun _ _ _ _ _ => tt;
    assoc := fun _ _ _ _ _ _ _ => eq_refl;
    assoc_sym := fun _ _ _ _ _ _ _ => eq_refl;
    id := fun _ => tt;
    id_unit_left :=
      fun _ _ h =>
        match h as u return (tt = u) with
        | tt => eq_refl
        end;
    id_unit_right :=
      fun _ _ h =>
        match h as u return (tt = u) with
        | tt => eq_refl
        end
  |}.

Notation "0" := (EmptyCat) : category_scope.
Notation "1" := (SingletonCat) : category_scope.

Section Discr.
  Context (obj : Type).

  Program Definition Discr_Cat : Category :=
    {|
      Obj := obj;
      Hom := fun a b => a = b;
      compose := @eq_trans _;
      id := fun a => eq_refl
    |}.
    
End Discr.

Definition Type_n (n : nat) : Type := {x : nat| x < n}.

Notation "'Discr_n' n" :=
  (Discr_Cat (Type_n n)) (at level 200, n bigint) : category_scope.

Section Discr_Cat_Dual_Iso.
  Context (obj : Type).

  Local Hint Extern 1 => progress cbn.
  
  Program Definition Discr_Cat_Dual_Iso :
    (Discr_Cat obj ≃≃ (Discr_Cat obj)^op ::> Cat)%isomorphism%category
    :=
      {|
        iso_morphism := {|FO := fun x => x; FA := fun _ _ h => eq_sym h|};
        inverse_morphism := {|FO := fun x => x; FA := fun _ _ h => eq_sym h|}
      |}.

End Discr_Cat_Dual_Iso.

Section Discr_Cat_Iso.
  Context {obj obj' : Type} (I : (obj ≃≃ obj' ::> Type_Cat)%isomorphism).

  Program Definition Discr_Cat_Iso :
    ((Discr_Cat obj) ≃≃ (Discr_Cat obj') ::> Cat)%isomorphism
    :=
      {|
        iso_morphism :=
          {|
            FO := iso_morphism I;
            FA :=
              fun c d h =>
                match h in _ = y return
                      (iso_morphism I c) = (iso_morphism I y)
                with
                  eq_refl => eq_refl
                end
          |};
        inverse_morphism :=
          {|
            FO := inverse_morphism I;
            FA :=
              fun c d h =>
                match h in _ = y return
                      (inverse_morphism I c) = (inverse_morphism I y)
                with
                  eq_refl => eq_refl
                end
          |}
      |}.
  
End Discr_Cat_Iso.

Section Func_From_SingletonCat.
  Context {C : Category} (Cobj : C).

  Program Definition Func_From_SingletonCat : (SingletonCat –≻ C)%functor :=
    {|
      FO := fun _ => Cobj;
      FA := fun _ _ _ => id
    |}.

End Func_From_SingletonCat.

Section Discr_Func.
  Context {C : Category} {A : Type} (Omap : A → C).

  Program Definition Discr_Func : ((Discr_Cat A) –≻ C)%functor :=
    {|
      FO := Omap;
      
      FA := fun (a b : A) (h : a = b) =>
              match h in _ = y return ((Omap a) –≻ (Omap y))%morphism with
              | eq_refl => id
              end
    |}.

  Program Definition Discr_Func_op : ((Discr_Cat A)^op –≻ C)%functor :=
    {|
      FO := Omap;
      FA := fun (a b : A) (h : b = a) =>
              match h in _ = y return ((Omap y) –≻ (Omap b))%morphism with
              | eq_refl => id
              end
    |}.
    
End Discr_Func.
  
Arguments Discr_Func {_ _} _, _ {_} _.
Arguments Discr_Func_op {_ _} _, _ {_} _. *)

From Categories Require Import Cat.Cat Cat.Cat_Iso.
(* Categories.Cat.Cat:
From Categories Require Import Category.Main.
From Categories Require Import Functor.Functor Functor.Functor_Ops.

Local Open Scope functor_scope.

Definition Cat : Category :=
{|
  Obj := Category;

  Hom := Functor;

  compose := fun C D E => Functor_compose;
  
  assoc := fun C D E F (G : C –≻ D) (H : D –≻ E) (I : E –≻ F) =>
            @Functor_assoc _ _ _ _ G H I;

  assoc_sym := fun C D E F (G : C –≻ D) (H : D –≻ E) (I : E –≻ F) =>
            eq_sym (@Functor_assoc _ _ _ _ G H I);

  id := fun C => Functor_id C;

  id_unit_left := fun C D => @Functor_id_unit_left C D;

  id_unit_right := fun C D => @Functor_id_unit_right C D          
|}. *)
(* Categories.Cat.Cat_Iso:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Functor Functor.Functor_Ops.
From Categories Require Import Coq_Cats.Type_Cat.Type_Cat.
From Categories Require Import Ext_Cons.Prod_Cat.Prod_Cat.
From Categories Require Import Cat.Cat.
From Categories Require Import NatTrans.NatTrans NatTrans.Operations NatTrans.Func_Cat
        NatTrans.NatIso.

Local Open Scope isomorphism_scope.
Local Open Scope morphism_scope.
Local Open Scope object_scope.

Section Opposite_Cat_Iso.
  Context {C D : Category} (I : C ≃≃ D ::> Cat).

  Program Definition Opposite_Cat_Iso :
    (C^op)%category ≃≃ (D^op)%category ::> Cat
    :=
      {|
        iso_morphism := ((iso_morphism I)^op)%functor;
        inverse_morphism := ((inverse_morphism I)^op)%functor
      |}.

End Opposite_Cat_Iso.
  
Section Cat_IConv.
  Context {C D : Category} (I : C ≃≃ D ::> Cat).

  Definition Cat_Iso_Obj_conv (c : C) :
    c = (((inverse_morphism I) _o) (((iso_morphism I) _o) c))%object.

  Definition Cat_Iso_Hom_conv (c c' : C) :
    ((((inverse_morphism I) _o) (((iso_morphism I) _o) c))
      –≻
      (((inverse_morphism I) _o) (((iso_morphism I) _o) c')))%morphism
    = (c –≻ c').

  Definition Cat_Iso_conv_inv {c c' : C}
             (h :
                (((inverse_morphism I) _o) (((iso_morphism I) _o) c))
                  –≻ (((inverse_morphism I) _o) (((iso_morphism I) _o) c')))
    : c –≻ c' :=
    match Cat_Iso_Hom_conv c c' in _ = Y return Y with
      eq_refl => h
    end.

  Theorem Cat_Iso_conv_inv_JMeq {c c' : C}
          (h :
             (((inverse_morphism I) _o) (((iso_morphism I) _o) c))
               –≻ (((inverse_morphism I) _o) (((iso_morphism I) _o) c')))
    : Cat_Iso_conv_inv h ~= h.

  Definition Cat_Iso_conv {c c' : C} (h : c –≻ c') :
    (((inverse_morphism I) _o) (((iso_morphism I) _o) c))
      –≻ (((inverse_morphism I) _o) (((iso_morphism I) _o) c'))
    :=
    match eq_sym (Cat_Iso_Hom_conv c c') in _ = Y return Y with
      eq_refl => h
    end.
  
  Theorem Cat_Iso_conv_JMeq {c c' : C} (h : c –≻ c') : Cat_Iso_conv h ~= h.

  Theorem Cat_Iso_conv_inv_Cat_Iso_conv {c c' : C} (h : c –≻ c')
    : Cat_Iso_conv_inv (Cat_Iso_conv h) = h.

  Theorem Cat_Iso_conv_Cat_Iso_conv_inv {c c' : C}
          (h :
             (((inverse_morphism I) _o) (((iso_morphism I) _o) c))
               –≻ (((inverse_morphism I) _o) (((iso_morphism I) _o) c')))
    :
      Cat_Iso_conv (Cat_Iso_conv_inv h) = h.

  Theorem Cat_Iso_conv_inv_I_inv_I {c c' : C} (h : c –≻ c') :
    Cat_Iso_conv_inv (((inverse_morphism I) _a) (((iso_morphism I) _a) h)) = h.

  Theorem Cat_Iso_conv_inv_compose {c c' c'' : C}
          (h :
             (((inverse_morphism I) _o) (((iso_morphism I) _o) c))
               –≻ (((inverse_morphism I) _o) (((iso_morphism I) _o) c'))
          )
          (h' :
             (((inverse_morphism I) _o) (((iso_morphism I) _o) c'))
               –≻ (((inverse_morphism I) _o) (((iso_morphism I) _o) c''))
          )
    :
      Cat_Iso_conv_inv (compose C h h')
      = compose C (Cat_Iso_conv_inv h) (Cat_Iso_conv_inv h').

End Cat_IConv.

Section Cat_Iso_inv.
  Context {C D : Category} (I : C ≃≃ D ::> Cat).

  Theorem Cat_Iso_inv
          {c c' : C} (h : ((iso_morphism I) _o c) –≻ ((iso_morphism I) _o c'))
    : {g : c –≻ c' | h = ((iso_morphism I) _a g)}.

End Cat_Iso_inv.

Section IsoCat_NatIso.
  Context {C D : Category} (I : (C ≃≃ D ::> Cat)%morphism)
          {E : Category} (F : (D –≻ E)%functor).

  Program Definition IsoCat_NatIso :
    ((F ∘ ((iso_morphism I) ∘ (I⁻¹)%morphism))%functor ≃ F)%natiso :=
    {|
      iso_morphism := IsoCat_NatTrans I F;
      inverse_morphism := IsoCat_NatTrans_back I F
    |}
  .

End IsoCat_NatIso. *)

From Categories Require Import NatTrans.NatTrans NatTrans.NatIso.
(* Categories.NatTrans.NatTrans:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Functor.
From Categories Require Import Cat.Cat.

Section NatTrans.
  Context {C C' : Category}.

  Record NatTrans (F F' : (C –≻ C')%functor) :=
    {
      Trans (c : C) : ((F _o c) –≻ (F' _o c))%object%morphism;
      Trans_com {c c' : C} (h : (c –≻ c')%morphism) :
        ((Trans c') ∘ F _a h = F' _a h ∘ (Trans c))%morphism;
      Trans_com_sym {c c' : C} (h : (c –≻ c')%morphism) :
        (F' _a h ∘ (Trans c) = (Trans c') ∘ F _a h)%morphism
    }.

  Notation "F –≻ F'" := (NatTrans F F') : nattrans_scope.

  Lemma NatTrans_eq_simplify {F F' : (C –≻ C')%functor}
        (N N' : (F –≻ F')%nattrans) : (@Trans _ _ N) = (@Trans _ _ N') -> N = N'.

End NatTrans.

Arguments Trans {_ _ _ _} _ _.
Arguments Trans_com {_ _ _ _} _ {_ _} _.
Arguments Trans_com_sym {_ _ _ _} _ {_ _} _.

Bind Scope nattrans_scope with NatTrans.

Notation "F –≻ F'" := (NatTrans F F') : nattrans_scope.

Local Open Scope nattrans_scope.

Section NatTrans_Compose.
  Context {C C' : Category}.
  
  Program Definition NatTrans_compose {F F' F'' : (C –≻ C')%functor}
          (tr : F –≻ F') (tr' : F' –≻ F'') : (F –≻ F'')%nattrans :=
    {|
      Trans := fun c : Obj => ((Trans tr' c) ∘ (Trans tr c)) % morphism
    |}.

End NatTrans_Compose.

Notation "N ∘ N'" := (NatTrans_compose N' N) : nattrans_scope.

Section NatTrans_Props.
  Context {C C' : Category}.
  
  Theorem NatTrans_compose_assoc {F G H I : (C –≻ C')%functor} (N : F –≻ G)
          (N' : G –≻ H) (N'' : H –≻ I)
    : ((N'' ∘ N') ∘ N = N'' ∘ (N' ∘ N))%nattrans
  .

  Program Definition NatTrans_id (F : (C –≻ C')%functor) : F –≻ F :=
    {|
      Trans := fun x : Obj => id
    |}.

  Theorem NatTrans_id_unit_left {F G : (C –≻ C')%functor} (N : F –≻ G)
    : (NatTrans_id G) ∘ N = N.

  Theorem NatTrans_id_unit_right {F G : (C –≻ C')%functor} (N : F –≻ G)
    : N ∘ (NatTrans_id F) = N.
  
End NatTrans_Props.

Hint Resolve NatTrans_eq_simplify. *)
(* Categories.NatTrans.NatIso:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Functor Functor.Functor_Ops Functor.Functor_Properties.
From Categories Require Import Cat.Cat.
From Categories Require Import NatTrans.NatTrans NatTrans.Func_Cat NatTrans.Operations.

Local Hint Extern 1 => apply NatTrans_eq_simplify; cbn.

Local Open Scope nattrans_scope.

Notation "a ≃ b" := (a ≃≃ b ::> Func_Cat _ _)%isomorphism : natiso_scope.

Section NatIso.
  Context {C C' : Category} (F G : (C –≻ C')%functor)
          (n : F –≻ G) (n' : G –≻ F).

  Program Definition NatIso
          (H : (∀ (c : Obj), (Trans n c) ∘ (Trans n' c)
                             = (id (G _o c)))%morphism)
          (H' : (∀ (c : Obj), (Trans n' c) ∘ (Trans n c)
                              = (id (F _o c)))%morphism)
    : (F ≃ G)%natiso
    := (Build_Isomorphism (Func_Cat _ _) _ _ n n' _ _).

End NatIso.

Section NatTrans_id_Iso.
  Context {C D : Category} (F : (C –≻ D)%functor).

  Definition NatTrans_id_Iso :
    (F ≃ F)%natiso := @Isomorphism_id (Func_Cat _ _) F.

End NatTrans_id_Iso.

Section NatIso_hor_comp.
  Context {C D E : Category} {F F' : (C –≻ D)%functor}
          {G G' : (D –≻ E)%functor} (N : (F ≃ F')%natiso)
          (N' : (G ≃ G')%natiso).

  Local Obligation Tactic := idtac.

  Program Definition NatIso_hor_comp
    : ((G ∘ F)%functor ≃ (G' ∘ F')%functor)%natiso :=
    {|
      iso_morphism := ((iso_morphism N') ∘_h (iso_morphism N))%nattrans;
      inverse_morphism :=
        ((inverse_morphism N') ∘_h (inverse_morphism N))%nattrans
    |}.

End NatIso_hor_comp.

Notation "f ∘_h g" := (NatIso_hor_comp g f) : natiso_scope.

Section Opposite_NatIso.
  Context {C D : Category} {F G : (C –≻ D)%functor} (N : (F ≃ G)%natiso).

  Program Definition Opposite_NatIso : (F^op%functor ≃ G^op%functor)%natiso :=
    {|
      iso_morphism := (inverse_morphism N)^op%nattrans;
      inverse_morphism := (iso_morphism N)^op%nattrans
    |}.

End Opposite_NatIso.

Notation "f ^op" := (Opposite_NatIso f) : natiso_scope.

Section Embedding_mono.
  Context {C C' : Category} (F : Embedding C C') {B : Category}.

  Local Obligation Tactic := idtac.

  Section Embedding_mono_NT.
    Context {G G' : (B –≻ C)%functor}
            (H : ((F ∘ G)%functor ≃ (F ∘ G')%functor)%natiso).
    
    Program Definition Embedding_mono_NT :  G –≻ G' :=
      {|
        Trans := fun c => proj1_sig (Emb_Full _ (Trans (iso_morphism H) c))
      |}.

  End Embedding_mono_NT.

  Context {G G' : (B –≻ C)%functor}
          (H : ((F ∘ G)%functor ≃ (F ∘ G')%functor)%natiso).
  
  Program Definition Embedding_mono : (G ≃ G')%natiso  :=
    {|
      iso_morphism := Embedding_mono_NT H;
      inverse_morphism := Embedding_mono_NT (H⁻¹)
    |}.

End Embedding_mono.

Section NatIso_Functor_assoc.
  Context {C1 C2 C3 C4 : Category}
          (F : (C1 –≻ C2)%functor)
          (G : (C2 –≻ C3)%functor)
          (H : (C3 –≻ C4)%functor).
  
  Program Definition NatIso_Functor_assoc
    : (((H ∘ G) ∘ F)%functor ≃ (H ∘ (G ∘ F))%functor)%natiso :=
    {|
      iso_morphism := NatTrans_Functor_assoc F G H;
      inverse_morphism := NatTrans_Functor_assoc_sym F G H
    |}.

End NatIso_Functor_assoc.

Section NatIso_Image.
  Context {C C' : Category} {F G : (C –≻ C')%functor} (N : (F ≃ G)%natiso).
  
  Program Definition NatIso_Image (c : C) : ((F _o c) ≃ (G _o c))%isomorphism :=
    {|
      iso_morphism := Trans (iso_morphism N) c;
      inverse_morphism := Trans (inverse_morphism N) c
    |}.
  
End NatIso_Image. *)



Local Open Scope morphism_scope.



Section Comma.

  Context {B C D : Category} (F : (B –≻ C)%functor) (G : (D –≻ C)%functor).



  Record Comma_Obj : Type :=

    {

      CMO_src : B;

      CMO_trg : D;

      CMO_hom : ((F _o CMO_src) –≻ (G _o CMO_trg))%object

    }.



  Record Comma_Hom (a b : Comma_Obj) : Type :=

    {

      CMH_left : (CMO_src a) –≻ (CMO_src b);

      CMH_right : (CMO_trg a) –≻ (CMO_trg b);

      CMH_com :  ((G _a CMH_right) ∘ (@CMO_hom a) =

                  (@CMO_hom b) ∘ (F _a CMH_left))%morphism

    }.



  Arguments CMH_left {_ _} _.

  Arguments CMH_right {_ _} _.

  Arguments CMH_com {_ _} _.



  Theorem Comma_Hom_eq_simplify {a b : Comma_Obj} (h h' : Comma_Hom a b) :

    (@CMH_left _ _ h) = (@CMH_left _ _ h') →

    (@CMH_right _ _ h) = (@CMH_right _ _ h') → h = h'.

  Proof.

    intros H1 H2.

    destruct h; destruct h'.

    cbn in *.

    ElimEq.

    PIR.

    trivial.

  Qed.



  Program Definition Comma_Hom_compose

          {a b c : Comma_Obj} (h : Comma_Hom a b) (h' : Comma_Hom b c) :

    Comma_Hom a c :=

    {|

      CMH_left := (CMH_left h') ∘ (CMH_left h);

      CMH_right := (CMH_right h') ∘ (CMH_right h)

    |}.



  Next Obligation.

  Proof.

    repeat rewrite F_compose.

    rewrite assoc.

    rewrite CMH_com.

    rewrite assoc_sym.

    rewrite CMH_com.

    auto.

  Qed.



  Theorem Comma_Hom_compose_assoc {a b c d : Comma_Obj} (h : Comma_Hom a b)

          (h' : Comma_Hom b c) (h'' : Comma_Hom c d) :

    Comma_Hom_compose h (Comma_Hom_compose h' h'') =

    Comma_Hom_compose (Comma_Hom_compose h h') h''.

  Proof.                    

    apply Comma_Hom_eq_simplify; cbn; auto.

  Qed.    



  Program Definition Comma_Hom_id (a : Comma_Obj) : Comma_Hom a a :=

    {|

      CMH_left := id;

      CMH_right := id

    |}.



  Theorem Comma_Hom_id_unit_left {a b : Comma_Obj} (h : Comma_Hom a b) :

    Comma_Hom_compose h (Comma_Hom_id b) = h.

  Proof.

    apply Comma_Hom_eq_simplify; cbn; auto.

  Qed.



  Theorem Comma_Hom_id_unit_right {a b : Comma_Obj} (h : Comma_Hom a b) :

    Comma_Hom_compose (Comma_Hom_id a) h = h.

  Proof.

    apply Comma_Hom_eq_simplify; cbn; auto.

  Qed.



  Definition Comma : Category :=

    {|

      Obj := Comma_Obj;



      Hom := Comma_Hom;



      compose := @Comma_Hom_compose;



      assoc := @Comma_Hom_compose_assoc;



      assoc_sym := fun _ _ _ _ f g h => eq_sym (Comma_Hom_compose_assoc f g h);

      

      id := Comma_Hom_id;



      id_unit_right := @Comma_Hom_id_unit_right;



      id_unit_left := @Comma_Hom_id_unit_left

    |}.



End Comma.



Arguments CMO_src {_ _ _ _ _} _.

Arguments CMO_trg {_ _ _ _ _} _.

Arguments CMO_hom {_ _ _ _ _} _.

Arguments CMH_left {_ _ _ _ _ _ _} _.

Arguments CMH_right {_ _ _ _ _ _ _} _.

Arguments CMH_com {_ _ _ _ _ _ _} _.



Section Comma_Opposite_Iso.

  Context {B C D : Category} (F : (B –≻ C)%functor) (G : (D –≻ C)%functor).



  Local Hint Extern 1 => progress cbn.



  Local Hint Extern 1 => apply Comma_Hom_eq_simplify.

  

  Program Definition Comma_Opposite_Iso_LR :

    Functor ((Comma F G)^op) (Comma (G ^op) (F ^op))

    :=

      {|

        FO :=

          fun x =>

            {|

              CMO_src := CMO_trg x;

              CMO_trg := CMO_src x;

              CMO_hom := CMO_hom x

            |};

        FA :=

          fun c c' h =>

            {|

              CMH_left := CMH_right h;

              CMH_right := CMH_left h;

              CMH_com := eq_sym (CMH_com h)

            |}

      |}.



  Program Definition Comma_Opposite_Iso_RL :

    Functor (Comma (G ^op) (F ^op)) ((Comma F G)^op)

    :=

      {|

        FO :=

          fun x =>

            {|

              CMO_src := CMO_trg x;

              CMO_trg := CMO_src x;

              CMO_hom := CMO_hom x

            |};

        FA :=

          fun c c' h =>

            {|

              CMH_left := CMH_right h;

              CMH_right := CMH_left h;

              CMH_com := eq_sym (CMH_com h)

            |}

      |}.

    

  Program Definition Comma_Opposite_Iso :

    (((Comma F G)^op)%category ≃≃ Comma (G ^op) (F ^op) ::> Cat)%isomorphism

    :=

      {|

        iso_morphism := Comma_Opposite_Iso_LR;

        inverse_morphism := Comma_Opposite_Iso_RL

      |}

  .



End Comma_Opposite_Iso.



Section Comma_Left_Func_Iso.

  Context {B C D : Category}.



  Local Hint Extern 1 => progress cbn.



  Local Hint Extern 1 => apply Comma_Hom_eq_simplify.



  Section Comma_Left_Func_Iso_FC.

    Context

      {F F' : (B –≻ C)%functor}

      (I : (F ≃ F')%natiso)

      (G : (D –≻ C)%functor)

    .



    Program Definition Comma_Left_Func_Iso_FC :

      Functor (Comma F G) (Comma F' G)

      :=

        {|

          FO :=

            fun x =>

              {|

                CMO_src := CMO_src x;

                CMO_trg := CMO_trg x;

                CMO_hom := (CMO_hom x) ∘ (Trans (inverse_morphism I) (CMO_src x))

              |};

          FA :=

            fun c c' h =>

              {|

                CMH_left := CMH_left h;

                CMH_right := CMH_right h;

              CMH_com := _

              |}

        |}.

    

    Next Obligation.

    Proof.

      rewrite assoc_sym.

      rewrite (CMH_com h).

      rewrite assoc.

      rewrite <- (Trans_com (inverse_morphism I) (CMH_left h)).

      auto.    

    Qed.

    

  End Comma_Left_Func_Iso_FC.



  Section Comma_Left_Func_Iso_FC_Iso.

    Context

      {F F' : (B –≻ C)%functor}

      (I : (F ≃ F')%natiso)

      (G : (D –≻ C)%functor)

    .



    Lemma Comma_Left_Func_Iso_FC_Iso :

      ((Comma_Left_Func_Iso_FC I G)

         ∘

         (Comma_Left_Func_Iso_FC (Inverse_Isomorphism I) G))%functor

      =

      Functor_id _

    .

    Proof.

      Func_eq_simpl.

      {

        extensionality x.

        extensionality y.

        extensionality f.

        match type of H with

          ?A = ?B =>

          set (H' :=

                 fun x =>

                   match H in _ = y return

                         A x = y x

                   with

                     eq_refl => eq_refl

                   end

              )

        end.

        transitivity (

            match H' x in _ = u return

                  u –≻ _

            with

              eq_refl =>

              match H' y in _ = v return

                    _ –≻ v

              with

                eq_refl =>

                ((Comma_Left_Func_Iso_FC I G ∘ Comma_Left_Func_Iso_FC (I ⁻¹) G) _a f)

              end

            end

          ).

        {

          destruct H; trivial.

        }

        {

          apply Comma_Hom_eq_simplify.

          {

            apply JMeq_eq.

            destruct H; trivial.

          }

          {

            apply JMeq_eq.

            destruct H; trivial.

          }

        }

      }

      {

        extensionality x.

        destruct x as [s t h]; cbn.

        rewrite assoc.

        change ((Trans (iso_morphism I) s) ∘ Trans (I ⁻¹)%morphism s) with

        (Trans ((iso_morphism I) ∘ (I ⁻¹)%morphism) s).

        cbn_rewrite (right_inverse I).

        cbn; auto.

      }

    Qed.

    

  End Comma_Left_Func_Iso_FC_Iso.



  Context

    {F F' : (B –≻ C)%functor}

    (I : (F ≃ F')%natiso)

    (G : (D –≻ C)%functor)

  .



  Local Hint Extern 1 => apply Comma_Left_Func_Iso_FC_Iso.

  

  Program Definition Comma_Left_Func_Iso :

    ((Comma F G) ≃≃ (Comma F' G) ::> Cat)%isomorphism

    :=

      {|

        iso_morphism := Comma_Left_Func_Iso_FC I G;

        inverse_morphism := Comma_Left_Func_Iso_FC (Inverse_Isomorphism I) G

      |}

  . 

    

End Comma_Left_Func_Iso.



Section Comma_Right_Func_Iso.

  Context

    {B C D : Category}

    (F : (B –≻ C)%functor)

    {G G' : (D –≻ C)%functor}

    (I : (G ≃ G')%natiso)

  .



  Definition Comma_Right_Func_Iso :

    ((Comma F G) ≃≃ (Comma F G') ::> Cat)%isomorphism :=

    Isomorphism_Compose

      (

        Isomorphism_Compose

          (Inverse_Isomorphism (Comma_Opposite_Iso (G ^op) (F ^op)))

          (Opposite_Cat_Iso (Comma_Left_Func_Iso (Opposite_NatIso I) (F^op)))

      )

      (Comma_Opposite_Iso (G' ^op) (F ^op))

  .

    

End Comma_Right_Func_Iso.



Section Slice_CoSlice.

  Context (C : Category) (c : Obj).

  

  Definition Slice : Category := Comma (Functor_id _) (Const_Func 1 c).



  Definition CoSlice : Category := Comma (Const_Func 1 c) (Functor_id _).



End Slice_CoSlice.



Section Arrow_Cat.

  Context (C : Category).



  Definition Arrow_Cat : Category := Comma (Functor_id C) (Functor_id C).



End Arrow_Cat.

