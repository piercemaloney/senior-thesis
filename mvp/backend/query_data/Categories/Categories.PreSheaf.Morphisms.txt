From Categories Require Import Essentials.Notations.
(* Categories.Essentials.Notations:
Notation "∀ x .. y , P" := (forall x, .. (forall y, P) ..)
                             (at level 200, x binder, y binder, right associativity) : type_scope.

Notation "∃ x .. y , P" := (exists x, .. (exists y, P) ..)
  (at level 200, x binder, y binder, right associativity) : type_scope.

Notation "x ∨ y" := (x \/ y) (at level 85, right associativity) : type_scope.

Notation "x ∧ y" := (x /\ y) (at level 80, right associativity) : type_scope.

Notation "x → y" := (x -> y)
  (at level 90, y at level 200, right associativity): type_scope.

Notation "x ↔ y" := (x <-> y) (at level 95, no associativity): type_scope.

Notation "¬ x" := (~x) (at level 75, right associativity) : type_scope.

Notation "x ≠ y" := (x <> y) (at level 70) : type_scope.

Notation "x ≤ y" := (le x y) (at level 70, no associativity).

Notation "x ≥ y" := (ge x y) (at level 70, no associativity).

Reserved Notation "C '^op'" (at level 50, no associativity).

Reserved Notation "a –≻ b" (at level 90, b at level 200, right associativity).

Reserved Notation "f '⁻¹'" (at level 50, no associativity).

Reserved Notation "a ≃ b" (at level 70, no associativity).

Reserved Notation "a ≃≃ b ::> C" (at level 70, no associativity).

Reserved Notation "f ∘ g" (at level 51, right associativity).

Reserved Notation "f '∘_h' g" (at level 51, right associativity).

Reserved Notation "a ≫–> b" (at level 100, no associativity).

Reserved Notation "a –≫ b" (at level 100, no associativity).

Reserved Notation "F '_o'" (at level 50, no associativity).

Reserved Notation "F '_a'" (at level 50, no associativity).

Reserved Notation "F '@_a'" (at level 50, no associativity).

Reserved Notation "F ⊣ G" (at level 100, no associativity).

Reserved Notation "F ⊣_hom G" (at level 100, no associativity).

Reserved Notation "F ⊣_ucu G" (at level 100, no associativity).

Reserved Notation "a × b" (at level 80, no associativity).

Reserved Notation "a ⇑ b" (at level 79, no associativity).

Reserved Notation "'Π' m" (at level 50, no associativity).

Reserved Notation "'Σ' m" (at level 50, no associativity).

Reserved Notation "'Π_' C ↓ m" (at level 50, no associativity).

Reserved Notation "'Σ_' C ↓ m" (at level 50, no associativity).

Delimit Scope category_scope with category.

Delimit Scope morphism_scope with morphism.

Delimit Scope object_scope with object.

Delimit Scope functor_scope with functor.

Delimit Scope nattrans_scope with nattrans.

Delimit Scope nattrans_scope with nattrans.

Delimit Scope natiso_scope with natiso.

Delimit Scope isomorphism_scope with isomorphism.

Delimit Scope preorder_scope with preorder. *)

From Categories Require Import Essentials.Types.
(* Categories.Essentials.Types:
Global Set Primitive Projections.

Global Set Universe Polymorphism.

Global Unset Universe Minimization ToSet.

Inductive Empty : Type :=.

Hint Extern 1 =>
let tac := (repeat intros ?); match goal with [H : Empty |- _] => contradict H end in
match goal with
  | [|- context[Empty]] => tac
  | [H : context[Empty] |- _] => tac
end
.

Record prod (A B : Type) := {fst : A; snd : B}.

Arguments fst {_ _ } _.
Arguments snd {_ _ } _.
Arguments Build_prod {_ _ } _ _.

Notation "( X , Y )" := (Build_prod X Y).
Notation "X * Y" := (prod X Y) : type_scope. *)

From Categories Require Import Essentials.Facts_Tactics.
(* Categories.Essentials.Facts_Tactics:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.

Require Export Coq.Program.Tactics.
Require Export Coq.Program.Equality.
Require Export Coq.Logic.FunctionalExtensionality.
Require Export Coq.Logic.ProofIrrelevance.

Definition equal_f : ∀ {A B : Type} {f g : A → B}, f = g → ∀ x : A, f x = g x.

Definition f_equal : ∀ (A B : Type) (f : A → B) (x y : A), x = y → f x = f y.

Arguments f_equal [_ _] _ [_ _] _.

Ltac basic_simpl :=
  let simpl_prod _ :=
      match goal with
        [H : prod _ _ |- _] =>
        let H1 := fresh H "1" in
        let H2 := fresh H "2" in
        destruct H as [H1 H2]
      end
  in
  let simpl_sig _ :=
      match goal with
        [H : @sig _ _ |- _] =>
        let H1 := fresh H "1" in
        let H2 := fresh H "2" in
        destruct H as [H1 H2]
      end
  in
  let basic_simpl_helper _ :=
      cbn in *; intros;
        repeat simpl_prod tt;
        repeat simpl_sig tt
  in
  repeat basic_simpl_helper tt
.

Global Obligation Tactic := basic_simpl; auto.

Ltac PIR :=
  let pir_helper _ :=
      match goal with
      |[H : ?A, H' : ?A|- _] =>
       match type of A with
       | Prop =>
         destruct (proof_irrelevance _ H H')
       end
      end
  in
  repeat pir_helper tt
.

Ltac ElimEq := repeat match goal with [H : _ = _|- _] => destruct H end.

Hint Extern 1 => progress ElimEq.

Ltac cbn_rewrite W :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite H; clear H
.

Ltac cbn_rewrite_in W V :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite H in V; clear H
.

Ltac cbn_rewrite_back W :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite <- H; clear H
.

Ltac cbn_rewrite_back_in W V :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite <- H in V; clear H
.

Tactic Notation "cbn_rewrite" constr(W) := cbn_rewrite W.
Tactic Notation "cbn_rewrite" constr(W) "in" hyp_list(V) := cbn_rewrite_in W V.
Tactic Notation "cbn_rewrite" "<-" constr(W) := cbn_rewrite_back W.
Tactic Notation "cbn_rewrite" "<-" constr(W) "in" hyp_list(V) := cbn_rewrite_back_in W V.

Lemma sig_proof_irrelevance {A : Type} (P : A → Prop) (X Y : sig P) : proj1_sig X = proj1_sig Y → X = Y.

Hint Extern 2 (exist ?A _ _ = exist ?A _ _) => apply sig_proof_irrelevance.

Ltac FunExt :=
progress (
    repeat (
        match goal with
          [|- _ = _] =>
          let x := fresh "x" in
          extensionality x
        end
      )
  )
.

Hint Extern 1 => FunExt.

Lemma pair_eq (A B : Type) (a b : A * B) : fst a = fst b → snd a = snd b → a = b.

Hint Resolve pair_eq.

Ltac revert_clearbody_all :=
 repeat lazymatch goal with H:_ |- _ => try clearbody H; revert H end.

Ltac hyp_stack :=
 constr:(ltac:(revert_clearbody_all;constructor) : True).

Ltac next_hyp hs step last :=
 lazymatch hs with (?hs' ?H) => step H hs' | _ => last end.

Tactic Notation "dohyps" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := tac H; next_hyp hs step idtac in
 next_hyp hs step idtac.

Tactic Notation "dohyps" "reverse" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := next_hyp hs step idtac; tac H in
 next_hyp hs step idtac.

Tactic Notation "do1hyp" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := tac H + next_hyp hs step fail in
 next_hyp hs step fail.

Tactic Notation "do1hyp" "reverse" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := next_hyp hs step fail + tac H in
 next_hyp hs step fail. *)

From Categories Require Import Category.Main.
(* Categories.Category.Main:
From Categories Require Export Category.Category.
From Categories Require Export Category.Morph.
From Categories Require Export Category.Opposite.
From Categories Require Export Category.SubCategory.
From Categories Require Export Category.Composable_Chain. *)

From Categories Require Import Functor.Main.
(* Categories.Functor.Main:
From Categories Require Export Functor.Functor.
From Categories Require Export Functor.Functor_Extender.
From Categories Require Export Functor.Functor_Image.
From Categories Require Export Functor.Functor_Ops.
From Categories Require Export Functor.Functor_Properties.
From Categories Require Export Functor.Const_Func.
From Categories Require Export Functor.Const_Func_Functor. *)

From Categories Require Import Coq_Cats.Type_Cat.Type_Cat Coq_Cats.Type_Cat.Morphisms.
(* Categories.Coq_Cats.Type_Cat.Type_Cat:
From Categories Require Import Category.Main.
From Categories Require Import Coq_Cats.Coq_Cat.

Program Definition Type_Cat : Category := Coq_Cat Type. *)
(* Categories.Coq_Cats.Type_Cat.Morphisms:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Coq_Cats.Type_Cat.Type_Cat.

Section Monic_Iso_Monic_Factorization.
  Context
    {A B : Type}
    {f : A → B}
    (fm : @is_Monic Type_Cat _ _ f)
  .

  Definition Monic_Image_of : Type := {x : B & {a : A | f a = x}}.

  Definition Monic_From_Image_forward : Monic_Image_of → B := fun x => projT1 x.

  Program Definition Monic_Iso_Monic_Factor_Monic :
    @Monic Type_Cat Monic_Image_of B :=
    {|
      mono_morphism := Monic_From_Image_forward;
      mono_morphism_monomorphic := fun T g h => _
    |}
  .

  Definition Monic_To_Image : A → Monic_Image_of :=
    fun a => existT _ (f a) (exist _ a eq_refl).

  Definition Monic_From_Image_back : Monic_Image_of → A :=
    fun x => proj1_sig (projT2 x).

  Theorem Monic_From_Image_back_is_Monic :
    @is_Monic Type_Cat _ _ Monic_To_Image.

  Theorem Monic_To_Image_form_split_epic :
    (
      fun (x : Monic_Image_of) =>
        Monic_To_Image (Monic_From_Image_back x)
    ) = (fun x => x).

  Program Definition Monic_Iso_Monic_Factor_Iso :
    (A ≃≃ Monic_Image_of ::> Type_Cat)%isomorphism
    :=
      Monic_is_split_Epic_Iso
        _
        _
        (is_Monic_Monic Monic_From_Image_back_is_Monic)
        (
          @Build_is_split_Monic
            (Type_Cat ^op)
            _
            _
            Monic_To_Image
            _
            Monic_To_Image_form_split_epic
        )
  .

  Theorem Monic_Iso_Monic_Factorization :
    f = fun x =>  Monic_From_Image_forward (Monic_To_Image x).

End Monic_Iso_Monic_Factorization.

Require Import Coq.Logic.ChoiceFacts.

Local Axiom ConstructiveIndefiniteDescription_Type :
  forall T : Type, ConstructiveIndefiniteDescription_on T.

Section split_Epic_Monic_Factorization.
  Context {A B : Type} (f : A → B).

  Definition Image_of : Type := {x : B | ∃ a, f a = x}.

  Definition From_Image_forward : Image_of → B := fun x => proj1_sig x.

  Program Definition Epic_Monic_Factor_Monic : @Monic Type_Cat Image_of B :=
    {|
      mono_morphism := From_Image_forward;
      mono_morphism_monomorphic := fun T g h => _
    |}
  .

  Definition To_Image : A → Image_of :=
    fun a => exist _ (f a) (ex_intro _ a eq_refl).

  Definition From_Image_back : Image_of → A :=
    fun x => proj1_sig (ConstructiveIndefiniteDescription_Type _ _ (proj2_sig x)).

  Theorem From_Image_back_form_split_epic :
    ∀ (x : Image_of), To_Image (From_Image_back x) = x.

  Program Definition Epic_Monic_Factor_split_Epic :
    @is_split_Epic Type_Cat _ _ To_Image :=
    {|
      is_split_monic_left_inverse := From_Image_back
    |}.

  Theorem split_Epic_Monic_Factorization :
    f = fun x =>  From_Image_forward (To_Image x).

End split_Epic_Monic_Factorization. *)

From Categories Require Import NatTrans.NatTrans
(* Categories.NatTrans.NatTrans:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Functor.
From Categories Require Import Cat.Cat.

Section NatTrans.
  Context {C C' : Category}.

  Record NatTrans (F F' : (C –≻ C')%functor) :=
    {
      Trans (c : C) : ((F _o c) –≻ (F' _o c))%object%morphism;
      Trans_com {c c' : C} (h : (c –≻ c')%morphism) :
        ((Trans c') ∘ F _a h = F' _a h ∘ (Trans c))%morphism;
      Trans_com_sym {c c' : C} (h : (c –≻ c')%morphism) :
        (F' _a h ∘ (Trans c) = (Trans c') ∘ F _a h)%morphism
    }.

  Notation "F –≻ F'" := (NatTrans F F') : nattrans_scope.

  Lemma NatTrans_eq_simplify {F F' : (C –≻ C')%functor}
        (N N' : (F –≻ F')%nattrans) : (@Trans _ _ N) = (@Trans _ _ N') -> N = N'.

End NatTrans.

Arguments Trans {_ _ _ _} _ _.
Arguments Trans_com {_ _ _ _} _ {_ _} _.
Arguments Trans_com_sym {_ _ _ _} _ {_ _} _.

Bind Scope nattrans_scope with NatTrans.

Notation "F –≻ F'" := (NatTrans F F') : nattrans_scope.

Local Open Scope nattrans_scope.

Section NatTrans_Compose.
  Context {C C' : Category}.
  
  Program Definition NatTrans_compose {F F' F'' : (C –≻ C')%functor}
          (tr : F –≻ F') (tr' : F' –≻ F'') : (F –≻ F'')%nattrans :=
    {|
      Trans := fun c : Obj => ((Trans tr' c) ∘ (Trans tr c)) % morphism
    |}.

End NatTrans_Compose.

Notation "N ∘ N'" := (NatTrans_compose N' N) : nattrans_scope.

Section NatTrans_Props.
  Context {C C' : Category}.
  
  Theorem NatTrans_compose_assoc {F G H I : (C –≻ C')%functor} (N : F –≻ G)
          (N' : G –≻ H) (N'' : H –≻ I)
    : ((N'' ∘ N') ∘ N = N'' ∘ (N' ∘ N))%nattrans
  .

  Program Definition NatTrans_id (F : (C –≻ C')%functor) : F –≻ F :=
    {|
      Trans := fun x : Obj => id
    |}.

  Theorem NatTrans_id_unit_left {F G : (C –≻ C')%functor} (N : F –≻ G)
    : (NatTrans_id G) ∘ N = N.

  Theorem NatTrans_id_unit_right {F G : (C –≻ C')%functor} (N : F –≻ G)
    : N ∘ (NatTrans_id F) = N.
  
End NatTrans_Props.

Hint Resolve NatTrans_eq_simplify. *)

        NatTrans.Operations

        NatTrans.Func_Cat

        NatTrans.Morphisms

        NatTrans.NatIso.

From Categories Require Import Basic_Cons.Terminal.
(* Categories.Basic_Cons.Terminal:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Main.

Class Terminal (C : Category) : Type :=
{
  terminal : C;
  t_morph : ∀ (d : Obj), (d –≻ terminal)%morphism;
  t_morph_unique : ∀ (d : Obj) (f g : (d –≻ terminal)%morphism), f = g
}.

Arguments terminal {_} _.
Arguments t_morph {_} _ _.
Arguments t_morph_unique {_} _ _ _ _.

Coercion terminal : Terminal >-> Obj.

Notation "𝟙_ C" := (Terminal C) (at level 75) : object_scope.

Theorem Terminal_iso {C : Category} (T T' : (𝟙_ C)%object) :
  (T ≃ T')%isomorphism.

Definition Initial (C : Category) := (𝟙_ (C ^op))%object.
Existing Class Initial.

Notation "𝟘_ C" := (Initial C) (at level 75) : object_scope. *)

From Categories Require Import PreSheaf.PreSheaf PreSheaf.Terminal.
(* Categories.PreSheaf.PreSheaf:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Main.
From Categories Require Import Coq_Cats.Type_Cat.Type_Cat.
From Categories Require Import NatTrans.NatTrans NatTrans.Func_Cat.

Definition PreSheaf (C : Category) := Functor (C^op) Type_Cat.

Definition PShCat (C : Category) := Func_Cat (C^op) Type_Cat. *)
(* Categories.PreSheaf.Terminal:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Main.
From Categories Require Import Coq_Cats.Type_Cat.Type_Cat Coq_Cats.Type_Cat.CCC.
From Categories Require Import NatTrans.NatTrans NatTrans.Func_Cat.
From Categories Require Import Basic_Cons.Terminal.
From Categories Require Import PreSheaf.PreSheaf.

Section Terminal.
  Context (C : Category).

  Program Definition PSh_Term_PreSheaf : Functor (C^op) Type_Cat :=
    {|
      FO := fun _ => unit
    |}.

  Local Hint Resolve NatTrans_eq_simplify.
  Local Hint Extern 1 =>
  match goal with
    [|- ?A = ?B] => try destruct A; try destruct B; trivial; fail
  end.  

  Program Instance PSh_Terminal : (𝟙_ (PShCat C))%object :=
    {
      terminal := PSh_Term_PreSheaf;
      t_morph := fun _ => {|Trans := fun _ _ => tt|}
    }.

End Terminal. *)

From Categories Require Import Archetypal.Discr.Discr.
(* Categories.Archetypal.Discr.Discr:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Functor.
From Categories Require Import Cat.Cat.
From Categories Require Import Coq_Cats.Type_Cat.Type_Cat.

Definition EmptyCat : Category :=
  {|
    Obj := (Empty : Type);
    Hom := fun _ _ => (unit : Type);
    compose := fun _ _ _ _ _ => tt;
    assoc := fun _ _ _ _ _ _ _ => eq_refl;
    assoc_sym := fun _ _ _ _ _ _ _ => eq_refl;
    id := fun _ => tt;
    id_unit_left :=
      fun _ _ h =>
        match h as u return (tt = u) with
        | tt => eq_refl
        end;
    id_unit_right :=
      fun _ _ h =>
        match h as u return (tt = u) with
        | tt => eq_refl
        end
  |}.

Definition SingletonCat : Category :=
  {|
    Obj := (unit : Type);
    Hom := fun _ _ => (unit : Type);
    compose := fun _ _ _ _ _ => tt;
    assoc := fun _ _ _ _ _ _ _ => eq_refl;
    assoc_sym := fun _ _ _ _ _ _ _ => eq_refl;
    id := fun _ => tt;
    id_unit_left :=
      fun _ _ h =>
        match h as u return (tt = u) with
        | tt => eq_refl
        end;
    id_unit_right :=
      fun _ _ h =>
        match h as u return (tt = u) with
        | tt => eq_refl
        end
  |}.

Notation "0" := (EmptyCat) : category_scope.
Notation "1" := (SingletonCat) : category_scope.

Section Discr.
  Context (obj : Type).

  Program Definition Discr_Cat : Category :=
    {|
      Obj := obj;
      Hom := fun a b => a = b;
      compose := @eq_trans _;
      id := fun a => eq_refl
    |}.
    
End Discr.

Definition Type_n (n : nat) : Type := {x : nat| x < n}.

Notation "'Discr_n' n" :=
  (Discr_Cat (Type_n n)) (at level 200, n bigint) : category_scope.

Section Discr_Cat_Dual_Iso.
  Context (obj : Type).

  Local Hint Extern 1 => progress cbn.
  
  Program Definition Discr_Cat_Dual_Iso :
    (Discr_Cat obj ≃≃ (Discr_Cat obj)^op ::> Cat)%isomorphism%category
    :=
      {|
        iso_morphism := {|FO := fun x => x; FA := fun _ _ h => eq_sym h|};
        inverse_morphism := {|FO := fun x => x; FA := fun _ _ h => eq_sym h|}
      |}.

End Discr_Cat_Dual_Iso.

Section Discr_Cat_Iso.
  Context {obj obj' : Type} (I : (obj ≃≃ obj' ::> Type_Cat)%isomorphism).

  Program Definition Discr_Cat_Iso :
    ((Discr_Cat obj) ≃≃ (Discr_Cat obj') ::> Cat)%isomorphism
    :=
      {|
        iso_morphism :=
          {|
            FO := iso_morphism I;
            FA :=
              fun c d h =>
                match h in _ = y return
                      (iso_morphism I c) = (iso_morphism I y)
                with
                  eq_refl => eq_refl
                end
          |};
        inverse_morphism :=
          {|
            FO := inverse_morphism I;
            FA :=
              fun c d h =>
                match h in _ = y return
                      (inverse_morphism I c) = (inverse_morphism I y)
                with
                  eq_refl => eq_refl
                end
          |}
      |}.
  
End Discr_Cat_Iso.

Section Func_From_SingletonCat.
  Context {C : Category} (Cobj : C).

  Program Definition Func_From_SingletonCat : (SingletonCat –≻ C)%functor :=
    {|
      FO := fun _ => Cobj;
      FA := fun _ _ _ => id
    |}.

End Func_From_SingletonCat.

Section Discr_Func.
  Context {C : Category} {A : Type} (Omap : A → C).

  Program Definition Discr_Func : ((Discr_Cat A) –≻ C)%functor :=
    {|
      FO := Omap;
      
      FA := fun (a b : A) (h : a = b) =>
              match h in _ = y return ((Omap a) –≻ (Omap y))%morphism with
              | eq_refl => id
              end
    |}.

  Program Definition Discr_Func_op : ((Discr_Cat A)^op –≻ C)%functor :=
    {|
      FO := Omap;
      FA := fun (a b : A) (h : b = a) =>
              match h in _ = y return ((Omap y) –≻ (Omap b))%morphism with
              | eq_refl => id
              end
    |}.
    
End Discr_Func.
  
Arguments Discr_Func {_ _} _, _ {_} _.
Arguments Discr_Func_op {_ _} _, _ {_} _. *)



Section PreSheaf_Monic_components_Monic.

  Context

    {C : Category}

    {F : PreSheaf C}

  .



  Section PMCM_PreSheaf_representing_d.

    Context (c : C) (d : Type).



    Local Hint Extern 1 => progress cbn.



    Program Definition PMCM_PreSheaf_representing_d : PreSheaf C

      :=

        {|

          FO := fun c' => ((Hom C c' c) * d)%type;

          FA := fun o o' u x => (compose C u (fst x), snd x)

        |}

    .



  End PMCM_PreSheaf_representing_d.



  Context

    {G : PreSheaf C}

    (N : @Monic (PShCat C) F G)

    (c : C)

  .

    

  Section PreSheaf_Monic_components_Monic_is_Monic.

    Context

      (d : Type)

      (g h : d → (F _o)%object c)

      (H : (fun x => Trans (mono_morphism N) c (g x))

           = (fun x => Trans (mono_morphism N) c (h x)))

    .



    Local Hint Extern 1 =>

    match goal with

      [|- context [(F _a)%morphism (?A ∘ ?B)%morphism] ] =>

      cbn_rewrite (F_compose F A B)

    end.

    

    Program Definition PMCM_PreSheaf_morph_of_function

            (f : d → (F _o)%object c)

      : (PMCM_PreSheaf_representing_d c d –≻ F)%nattrans

      :=

        {|

          Trans := fun o x => (F _a (fst x))%morphism (f (snd x))

        |}

    .



    Theorem PMCM_N_co_equalizes :

      ((mono_morphism N) ∘ (PMCM_PreSheaf_morph_of_function g))%nattrans

      = ((mono_morphism N) ∘ (PMCM_PreSheaf_morph_of_function h))%nattrans.

    Proof.

      apply NatTrans_eq_simplify.

      extensionality x.

      extensionality y.

      destruct y as [y1 y2].

      cbn in *.

      set (W := equal_f (Trans_com (mono_morphism N) y1)).

      cbn in W.

      do 2 rewrite W.

      rewrite (equal_f H).

      trivial.

    Qed.    



    Theorem PreSheaf_Monic_components_is_Monic : g = h.

    Proof.

      extensionality m.

      assert (W :=

                f_equal

                  (fun w : (PMCM_PreSheaf_representing_d c d –≻ F)%nattrans =>

                     Trans w c (id, m))

                  (mono_morphism_monomorphic N _ _ _ PMCM_N_co_equalizes)

             ).

      cbn in W.

      rewrite (F_id F) in W.

      trivial.

    Qed.



  End PreSheaf_Monic_components_Monic_is_Monic.



  Definition PreSheaf_Monic_components_Monic_Monic :

    Monic (F _o c)%object (G _o c)%object

    :=

      {|

        mono_morphism := Trans (mono_morphism N) c;

        mono_morphism_monomorphic :=

          PreSheaf_Monic_components_is_Monic

      |}.

  

End PreSheaf_Monic_components_Monic.



Section PreSheaf_Epic_components_Epic.

  Context

    {C : Category}

    {F G : PreSheaf C}

    (N : @Epic (PShCat C) F G)

    (c : C)

  .

  

  Section PreSheaf_Epic_components_is_Epic.

    Context

      (d : Type)

      (g h : (G _o)%object c → d)

      (H : (fun x => g (Trans (mono_morphism N) c x)) =

           (fun x => h (Trans (mono_morphism N) c x)))

    .



    Local Hint Extern 1 => progress cbn.



    Local Hint Extern 1 => rewrite assoc.



    Program Definition PECE_PreSheaf_representing_d : PreSheaf C

      :=

        {|

          FO := fun c' => (((Hom C c c') → d))%object%morphism%type;

          FA := fun o o' u x y => (x (compose C y u))

        |}

    .



    Local Hint Extern 1 =>

    match goal with

      [|- context [(G _a)%morphism (?A ∘ ?B)%morphism] ] =>

      cbn_rewrite (F_compose G A B)

    end.

    

    Program Definition PECE_PreSheaf_morph_of_function

            (f : (G _o)%object c → d)

      : (G –≻ PECE_PreSheaf_representing_d)%nattrans

      :=

        {|

          Trans := fun o x y => f ((G _a y)%morphism x)

        |}

    .

    

    Theorem PECE_N_co_equalizes :

      ((PECE_PreSheaf_morph_of_function g) ∘ (mono_morphism N))%nattrans =

      ((PECE_PreSheaf_morph_of_function h) ∘ (mono_morphism N))%nattrans.

    Proof.

      apply NatTrans_eq_simplify.

      extensionality x.

      extensionality y.

      extensionality z.

      cbn in *.

      set (W := equal_f (Trans_com (mono_morphism N) z)).

      cbn in W.

      rewrite <- W.

      rewrite (equal_f H).

      trivial.

    Qed.    



    Theorem PreSheaf_Epic_components_is_Epic : g = h.

    Proof.

      extensionality m.

      assert (W :=

                f_equal

                  (fun w : (G –≻ PECE_PreSheaf_representing_d)%nattrans =>

                     Trans w c m id)

                  (mono_morphism_monomorphic N _ _ _ PECE_N_co_equalizes)

             ).

      cbn in W.

      rewrite (F_id G) in W.

      trivial.

    Qed.



End PreSheaf_Epic_components_is_Epic.



  Program Definition PreSheaf_Epic_components_Epic :

    Epic (F _o c)%object (G _o c)%object

    :=

      {|

        mono_morphism := Trans (mono_morphism N) c;

        mono_morphism_monomorphic :=

          PreSheaf_Epic_components_is_Epic

      |}.

  

End PreSheaf_Epic_components_Epic.



Local Hint Extern 1 => match goal with

                        [|- context [(?F _a id)%morphism]] => rewrite (F_id F)

                      end.

Local Hint Extern 1 =>

match goal with

  [|- context [(?F _a (?f ∘ ?g))%morphism]] =>

  cbn_rewrite (F_compose F f g)

end.



Local Hint Extern 1 =>

match goal with

  [|- context [Trans ?f _ ((?F _a)%morphism ?h _)]] =>

  cbn_rewrite (equal_f (Trans_com f h))

end.



Local Hint Extern 1 => progress cbn in *.



Section Monic_PreSheaf_Iso_Monic_Factorization.

  Context

    {C : Category}

    {F G : PreSheaf C}

    (N : @Monic (PShCat C) F G)

  .



  Lemma sigT_sig_proof_irrelevance

        {T : Type}

        {P : T → Type}

        {Q : ∀ x, (P x) → Prop}

        (A B : sigT (fun y => sig (Q y)))

        (H : projT1 A = projT1 B)

        (H' :

           (

             proj1_sig

               (

                 match H in _ = u return

                       {x : P u | Q u x}

                 with

                   eq_refl => projT2 A

                 end

               )

           )

           =

           (proj1_sig (projT2 B)))

    :

      A = B

  .

  Proof.

    destruct A as [Ax [Ay HA]].

    destruct B as [Bx [By HB]].

    cbn in *.

    transitivity

      (

        existT

          (fun y : T => {x : P y | Q y x})

          Bx

          match H in _ = u return

                {x : P u | Q u x}

          with

            eq_refl => (exist (Q Ax) Ay HA)

          end

      ).

    {

      destruct H; trivial.

    }    

    {

      match goal with

        [|- existT _ ?A ?B = existT _ ?A ?B'] =>

        cutrewrite (B = B');trivial

      end.

      apply sig_proof_irrelevance; trivial.

    }

  Qed.



  Local Hint Extern 1 =>

  match goal with

    [x : {_ : _ & {_ : _ | _}} |- _] =>

    let H :=

        fresh "H"

    in

    let x1 :=

        fresh x "1"

    in

    let x2 :=

        fresh x "2"

    in

    destruct x as [x1 [x2 H]]

  end.



  Local Hint Extern 1 =>

  match goal with

    [x : Monic_Image_of |- _] =>

    let H :=

        fresh "H"

    in

    let x1 :=

        fresh x "1"

    in

    let x2 :=

        fresh x "2"

    in

    destruct x as [x1 [x2 H]]

  end.



  Local Hint Extern 1 =>

  match goal with

    [|- ?A = ?B] =>

    assert (H : (projT1 A) = (projT1 B));

      [|

       apply (sigT_sig_proof_irrelevance _ _ H);

         destruct H

      ]

  end.

  

  Program Definition Monic_PreSheaf_Image_of : PreSheaf C

    :=

      {|

        FO := fun x => @Monic_Image_of _ _ (Trans (mono_morphism N) x);

        FA := fun c c' h x =>

                existT _ (G _a h (projT1 x))%morphism

                       (exist _ (F _a h (proj1_sig (projT2 x)))%morphism _)

      |}

  .

  

  Program Definition Monic_PreSheaf_Morph_From_Monic_PreSheaf_Image_of_forward :

    (Monic_PreSheaf_Image_of –≻ G)%nattrans

    :=

      {|

        Trans := fun x => @Monic_From_Image_forward _ _ (Trans (mono_morphism N) x)

      |}.

  

  Program Definition Monic_PreSheaf_From_Monic_PreSheaf_Image_of_back :

    (Monic_PreSheaf_Image_of –≻ F)%nattrans

    :=

      {|

        Trans := fun x => @Monic_From_Image_back _ _ (Trans (mono_morphism N) x)

      |}.



  Program Definition Monic_PreSheaf_To_Monic_PreSheaf_Image_of :

    (F –≻ Monic_PreSheaf_Image_of)%nattrans

    :=

      {|

        Trans := fun x => @Monic_To_Image _ _ (Trans (mono_morphism N) x)

      |}.



  Definition Monic_PreSheaf_Iso_Monic_Factor_Monic :

    @Monic (PShCat C) Monic_PreSheaf_Image_of G.

  Proof.

    eapply (@is_Monic_Monic

              (PShCat C)

              _

              _

              Monic_PreSheaf_Morph_From_Monic_PreSheaf_Image_of_forward

           )

    .

    apply is_Monic_components_is_Monic.

    intros c.

    set (W := fun A B f H => mono_morphism_monomorphic

                            (@Monic_Iso_Monic_Factor_Monic A B f H)).

    unfold is_Monic in *.

    cbn in *.

    apply W.

    apply PreSheaf_Monic_components_is_Monic.

  Defined.



  Program Definition Monic_PreSheaf_Iso_Monic_Factor_Monic_Iso :

    @Isomorphism (PShCat C) F Monic_PreSheaf_Image_of

    :=

      {|

        iso_morphism := Monic_PreSheaf_To_Monic_PreSheaf_Image_of;

        inverse_morphism := Monic_PreSheaf_From_Monic_PreSheaf_Image_of_back

      |}

  .



  Next Obligation.

  Proof.

    apply NatTrans_eq_simplify.

    extensionality x.

    extensionality y.

    cbn in *.

    apply (equal_f Monic_To_Image_form_split_epic).

  Qed.



  Theorem split_Epic_Monic_Factorization :

    (mono_morphism N) =

    (

      (mono_morphism Monic_PreSheaf_Iso_Monic_Factor_Monic)

        ∘

        (iso_morphism Monic_PreSheaf_Iso_Monic_Factor_Monic_Iso)

    )%nattrans.

  Proof.

    apply NatTrans_eq_simplify; trivial.

  Qed.

  

End Monic_PreSheaf_Iso_Monic_Factorization.



Section PreSheaf_Epic_Monic_Factorization.

  Context

    {C : Category}

    {F G : PreSheaf C}

    (N : (F –≻ G)%nattrans)

  .



  Local Hint Extern 1 =>

  match goal with

    [x : {_ : _ | ∃ _, _} |- _] =>

    let H :=

        fresh "H"

    in

    let x1 :=

        fresh x "1"

    in

    let x2 :=

        fresh x "2"

    in

    destruct x as [x1 [x2 H]]

  end.



  Local Hint Extern 1 =>

  match goal with

    [x : Image_of _ |- _] =>

    let H :=

        fresh "H"

    in

    let x1 :=

        fresh x "1"

    in

    let x2 :=

        fresh x "2"

    in

    destruct x as [x1 [x2 H]]

  end.



  Local Obligation Tactic := basic_simpl; auto 10.

  

  Program Definition PreSheaf_Image_of : PreSheaf C

    :=

      {|

        FO := fun x => @Image_of _ _ (Trans N x);

        FA := fun c c' h x => exist _ (G _a h (proj1_sig x))%morphism _

      |}

  .



  Next Obligation.

  Proof.

    destruct x as [x [y []]].

    exists (F _a h y)%morphism; auto.

  Qed.



  Program Definition PreSheaf_From_Image_Forward :

    (PreSheaf_Image_of –≻ G)%nattrans

    :=

      {|

        Trans := fun x => @From_Image_forward _ _ (Trans N x)

      |}.

  

  Definition PreSheaf_Epic_Monic_Factor_Monic :

    @Monic (PShCat C) PreSheaf_Image_of G.

  Proof.

    eapply (@is_Monic_Monic

              (PShCat C)

              _

              _

              PreSheaf_From_Image_Forward

           )

    .

    apply is_Monic_components_is_Monic.

    intros c.

    set (W := fun A B f => mono_morphism_monomorphic

                          (@Epic_Monic_Factor_Monic A B f)).

    unfold is_Monic in *; cbn in *.

    apply W.

  Defined.



  Local Hint Extern 1 => apply sig_proof_irrelevance.

  

  Program Definition PreSheaf_To_Image :

    (F –≻ PreSheaf_Image_of)%nattrans

    :=

      {|

        Trans := fun x => To_Image (Trans N x)

      |}.



  Definition PreSheaf_Epic_Monic_Factor_Epic :

    @Epic (PShCat C) F PreSheaf_Image_of.

  Proof.

    eapply (@is_Monic_Monic

              ((PShCat C) ^op)

              _

              _

              PreSheaf_To_Image

           )

    .

    apply is_Epic_components_is_Epic.

    set (W := fun A B f => mono_morphism_monomorphic

                          (is_split_Monic_Monic

                             (@Epic_Monic_Factor_split_Epic A B f))).

    unfold is_Epic, is_Monic in *; cbn in *.

    intros c.

    apply W.

  Defined.



End PreSheaf_Epic_Monic_Factorization.

