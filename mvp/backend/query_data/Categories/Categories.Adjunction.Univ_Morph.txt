From Categories Require Import Essentials.Notations.
(* Categories.Essentials.Notations:
Notation "∀ x .. y , P" := (forall x, .. (forall y, P) ..)
                             (at level 200, x binder, y binder, right associativity) : type_scope.

Notation "∃ x .. y , P" := (exists x, .. (exists y, P) ..)
  (at level 200, x binder, y binder, right associativity) : type_scope.

Notation "x ∨ y" := (x \/ y) (at level 85, right associativity) : type_scope.

Notation "x ∧ y" := (x /\ y) (at level 80, right associativity) : type_scope.

Notation "x → y" := (x -> y)
  (at level 90, y at level 200, right associativity): type_scope.

Notation "x ↔ y" := (x <-> y) (at level 95, no associativity): type_scope.

Notation "¬ x" := (~x) (at level 75, right associativity) : type_scope.

Notation "x ≠ y" := (x <> y) (at level 70) : type_scope.

Notation "x ≤ y" := (le x y) (at level 70, no associativity).

Notation "x ≥ y" := (ge x y) (at level 70, no associativity).

Reserved Notation "C '^op'" (at level 50, no associativity).

Reserved Notation "a –≻ b" (at level 90, b at level 200, right associativity).

Reserved Notation "f '⁻¹'" (at level 50, no associativity).

Reserved Notation "a ≃ b" (at level 70, no associativity).

Reserved Notation "a ≃≃ b ::> C" (at level 70, no associativity).

Reserved Notation "f ∘ g" (at level 51, right associativity).

Reserved Notation "f '∘_h' g" (at level 51, right associativity).

Reserved Notation "a ≫–> b" (at level 100, no associativity).

Reserved Notation "a –≫ b" (at level 100, no associativity).

Reserved Notation "F '_o'" (at level 50, no associativity).

Reserved Notation "F '_a'" (at level 50, no associativity).

Reserved Notation "F '@_a'" (at level 50, no associativity).

Reserved Notation "F ⊣ G" (at level 100, no associativity).

Reserved Notation "F ⊣_hom G" (at level 100, no associativity).

Reserved Notation "F ⊣_ucu G" (at level 100, no associativity).

Reserved Notation "a × b" (at level 80, no associativity).

Reserved Notation "a ⇑ b" (at level 79, no associativity).

Reserved Notation "'Π' m" (at level 50, no associativity).

Reserved Notation "'Σ' m" (at level 50, no associativity).

Reserved Notation "'Π_' C ↓ m" (at level 50, no associativity).

Reserved Notation "'Σ_' C ↓ m" (at level 50, no associativity).

Delimit Scope category_scope with category.

Delimit Scope morphism_scope with morphism.

Delimit Scope object_scope with object.

Delimit Scope functor_scope with functor.

Delimit Scope nattrans_scope with nattrans.

Delimit Scope nattrans_scope with nattrans.

Delimit Scope natiso_scope with natiso.

Delimit Scope isomorphism_scope with isomorphism.

Delimit Scope preorder_scope with preorder. *)

From Categories Require Import Essentials.Types.
(* Categories.Essentials.Types:
Global Set Primitive Projections.

Global Set Universe Polymorphism.

Global Unset Universe Minimization ToSet.

Inductive Empty : Type :=.

Hint Extern 1 =>
let tac := (repeat intros ?); match goal with [H : Empty |- _] => contradict H end in
match goal with
  | [|- context[Empty]] => tac
  | [H : context[Empty] |- _] => tac
end
.

Record prod (A B : Type) := {fst : A; snd : B}.

Arguments fst {_ _ } _.
Arguments snd {_ _ } _.
Arguments Build_prod {_ _ } _ _.

Notation "( X , Y )" := (Build_prod X Y).
Notation "X * Y" := (prod X Y) : type_scope. *)

From Categories Require Import Essentials.Facts_Tactics.
(* Categories.Essentials.Facts_Tactics:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.

Require Export Coq.Program.Tactics.
Require Export Coq.Program.Equality.
Require Export Coq.Logic.FunctionalExtensionality.
Require Export Coq.Logic.ProofIrrelevance.

Definition equal_f : ∀ {A B : Type} {f g : A → B}, f = g → ∀ x : A, f x = g x.

Definition f_equal : ∀ (A B : Type) (f : A → B) (x y : A), x = y → f x = f y.

Arguments f_equal [_ _] _ [_ _] _.

Ltac basic_simpl :=
  let simpl_prod _ :=
      match goal with
        [H : prod _ _ |- _] =>
        let H1 := fresh H "1" in
        let H2 := fresh H "2" in
        destruct H as [H1 H2]
      end
  in
  let simpl_sig _ :=
      match goal with
        [H : @sig _ _ |- _] =>
        let H1 := fresh H "1" in
        let H2 := fresh H "2" in
        destruct H as [H1 H2]
      end
  in
  let basic_simpl_helper _ :=
      cbn in *; intros;
        repeat simpl_prod tt;
        repeat simpl_sig tt
  in
  repeat basic_simpl_helper tt
.

Global Obligation Tactic := basic_simpl; auto.

Ltac PIR :=
  let pir_helper _ :=
      match goal with
      |[H : ?A, H' : ?A|- _] =>
       match type of A with
       | Prop =>
         destruct (proof_irrelevance _ H H')
       end
      end
  in
  repeat pir_helper tt
.

Ltac ElimEq := repeat match goal with [H : _ = _|- _] => destruct H end.

Hint Extern 1 => progress ElimEq.

Ltac cbn_rewrite W :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite H; clear H
.

Ltac cbn_rewrite_in W V :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite H in V; clear H
.

Ltac cbn_rewrite_back W :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite <- H; clear H
.

Ltac cbn_rewrite_back_in W V :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite <- H in V; clear H
.

Tactic Notation "cbn_rewrite" constr(W) := cbn_rewrite W.
Tactic Notation "cbn_rewrite" constr(W) "in" hyp_list(V) := cbn_rewrite_in W V.
Tactic Notation "cbn_rewrite" "<-" constr(W) := cbn_rewrite_back W.
Tactic Notation "cbn_rewrite" "<-" constr(W) "in" hyp_list(V) := cbn_rewrite_back_in W V.

Lemma sig_proof_irrelevance {A : Type} (P : A → Prop) (X Y : sig P) : proj1_sig X = proj1_sig Y → X = Y.

Hint Extern 2 (exist ?A _ _ = exist ?A _ _) => apply sig_proof_irrelevance.

Ltac FunExt :=
progress (
    repeat (
        match goal with
          [|- _ = _] =>
          let x := fresh "x" in
          extensionality x
        end
      )
  )
.

Hint Extern 1 => FunExt.

Lemma pair_eq (A B : Type) (a b : A * B) : fst a = fst b → snd a = snd b → a = b.

Hint Resolve pair_eq.

Ltac revert_clearbody_all :=
 repeat lazymatch goal with H:_ |- _ => try clearbody H; revert H end.

Ltac hyp_stack :=
 constr:(ltac:(revert_clearbody_all;constructor) : True).

Ltac next_hyp hs step last :=
 lazymatch hs with (?hs' ?H) => step H hs' | _ => last end.

Tactic Notation "dohyps" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := tac H; next_hyp hs step idtac in
 next_hyp hs step idtac.

Tactic Notation "dohyps" "reverse" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := next_hyp hs step idtac; tac H in
 next_hyp hs step idtac.

Tactic Notation "do1hyp" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := tac H + next_hyp hs step fail in
 next_hyp hs step fail.

Tactic Notation "do1hyp" "reverse" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := next_hyp hs step fail + tac H in
 next_hyp hs step fail. *)

From Categories Require Import Category.Main.
(* Categories.Category.Main:
From Categories Require Export Category.Category.
From Categories Require Export Category.Morph.
From Categories Require Export Category.Opposite.
From Categories Require Export Category.SubCategory.
From Categories Require Export Category.Composable_Chain. *)

From Categories Require Import Functor.Main.
(* Categories.Functor.Main:
From Categories Require Export Functor.Functor.
From Categories Require Export Functor.Functor_Extender.
From Categories Require Export Functor.Functor_Image.
From Categories Require Export Functor.Functor_Ops.
From Categories Require Export Functor.Functor_Properties.
From Categories Require Export Functor.Const_Func.
From Categories Require Export Functor.Const_Func_Functor. *)

From Categories Require Import NatTrans.Main.
(* Categories.NatTrans.Main:
From Categories Require Export NatTrans.NatTrans.
From Categories Require Export NatTrans.Func_Cat.
From Categories Require Export NatTrans.NatIso.
From Categories Require Export NatTrans.Operations.
From Categories Require Export NatTrans.Morphisms. *)

From Categories Require Import Adjunction.Adjunction Adjunction.Duality.
(* Categories.Adjunction.Adjunction:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Ext_Cons.Prod_Cat.Prod_Cat Ext_Cons.Prod_Cat.Operations.
From Categories Require Import Functor.Main.
From Categories Require Import Functor.Representable.Hom_Func
        Functor.Representable.Hom_Func_Prop.
From Categories Require Import NatTrans.Main.

Local Open Scope functor_scope.

Local Notation NID := NatTrans_id (only parsing).
Local Notation FCAT := Func_Cat (only parsing).

Notation Hom_Adj_Left C D F G :=
  ((Hom_Func D) ∘ (Prod_Functor (F^op) (@Functor_id D)))%functor (only parsing).

Notation Hom_Adj_Right C D F G :=
  ((Hom_Func C) ∘ (Prod_Functor (@Functor_id (C^op)) G))%functor (only parsing).

Local Obligation Tactic := idtac.

Section Adjunction.
  Context {C D : Category} (F : C –≻ D) (G : D –≻ C).

  Record Adjunct : Type :=
  {
    adj_unit : ((Functor_id C) –≻ (G ∘ F))%nattrans;
    
    adj_morph_ex {c : C} {d : D} (f : (c –≻ (G _o d)%object)%morphism) :
      ((F _o c)%object –≻ d)%morphism;
    
    adj_morph_com {c : C} {d : D} (f : (c –≻ (G _o d))%morphism%object) :
      f = ((G _a (adj_morph_ex f)) ∘ (Trans adj_unit c))%morphism;
    
    adj_morph_unique {c : C} {d : D} (f : (c –≻ (G _o d))%object%morphism)
                     (g h : ((F _o c) –≻ d)%morphism%object) :
      f = ((G _a g) ∘ (Trans adj_unit c))%morphism →
      f = ((G _a h) ∘ (Trans adj_unit c))%morphism →
      g = h
  }.

  Arguments adj_unit : clear implicits.
  Arguments adj_morph_ex _ {_ _} _.
  Arguments adj_morph_com _ {_ _} _.
  Arguments adj_morph_unique _ {_ _} _ _ _ _ _.

  Theorem Adjunct_eq_simplify (adj adj' : Adjunct) :
    adj_unit adj = @adj_unit adj' →
    @adj_morph_ex adj = @adj_morph_ex adj' → adj = adj'.

  Definition Hom_Adjunct :=
    (Hom_Adj_Left _ _ F G ≃ Hom_Adj_Right _ _ F G)%natiso.

  Record UCU_Adjunct :=
    {
      ucu_adj_unit : ((Functor_id C) –≻ (G ∘ F))%nattrans;
      
      ucu_adj_counit : ((F ∘ G) –≻ (Functor_id D))%nattrans;

      ucu_adj_left_id : ((NatTrans_from_compose_id _)
                           ∘ ((((ucu_adj_counit ∘_h (NID F))
                                  ∘ (NatTrans_Functor_assoc_sym _ _ _))
                                 ∘ ((NID F) ∘_h ucu_adj_unit))
                                ∘ (NatTrans_to_id_compose _)))%nattrans
                        = (NID F);
      
      ucu_adj_right_id : ((NatTrans_from_id_compose _)
                            ∘ (((((NID G) ∘_h ucu_adj_counit)
                                   ∘ (NatTrans_Functor_assoc _ _ _))
                                  ∘ (ucu_adj_unit ∘_h (NID G)))
                                 ∘ (NatTrans_to_compose_id _)))%nattrans
                         = (NID G)
    }.

  Arguments ucu_adj_unit : clear implicits.
  Arguments ucu_adj_counit : clear implicits.
  Arguments ucu_adj_left_id : clear implicits.
  Arguments ucu_adj_right_id : clear implicits.

  Local Notation "F ⊣ G" := (Adjunct) : functor_scope.
  Local Notation "F ⊣_hom G" := (Hom_Adjunct) : functor_scope.
  Local Notation "F ⊣_ucu G" := (UCU_Adjunct) : functor_scope.
  
  Section UCU_Adj_Adj.
    Context (Adj : (F ⊣_ucu G)%functor).

    Program Definition UCU_Adj_to_Adj : (F ⊣ G)%functor :=
      {|
        adj_unit := ucu_adj_unit Adj;
        adj_morph_ex :=
          fun _ _ h => ((Trans (ucu_adj_counit Adj) _) ∘ (F _a h))%morphism
      |}.

  End UCU_Adj_Adj.

  Section Adj_UCU_Adj.
    Context (Adj : (F ⊣ G)%functor).
    
    Program Definition Adj_to_UCU_Adj : (F ⊣_ucu G)%functor :=
      {|
        ucu_adj_unit := adj_unit Adj;
        ucu_adj_counit :=
          {|
            Trans := fun d => @adj_morph_ex Adj (G _o d) d id
          |}
      |}.

  End Adj_UCU_Adj.
  
  Section Adj_Hom_Adj.
    Context (Adj : (F ⊣ G)%functor).

    Program Definition Adj_to_Hom_Adj_LR :
      ((Hom_Adj_Left _ _ F G) –≻ (Hom_Adj_Right _ _ F G))%nattrans :=
    {|
      Trans := fun c h => ((G _a h) ∘ (Trans (adj_unit Adj) _))%morphism
    |}.

    Program Definition Adj_to_Hom_Adj_RL :
      ((Hom_Adj_Right _ _ F G) –≻ (Hom_Adj_Left _ _ F G))%nattrans :=
    {|
      Trans := fun c h => adj_morph_ex Adj h
    |}.

    Program Definition Adj_to_Hom_Adj : (F ⊣_hom G)%functor :=
      NatIso _ _ Adj_to_Hom_Adj_LR Adj_to_Hom_Adj_RL _ _.

  End Adj_Hom_Adj.

  Section Hom_Adj_Adj.
    Context (Adj : (F ⊣_hom G)%functor).

    Program Definition Hom_Adj_to_Adj : (F ⊣ G)%functor :=
      {|
        adj_unit :=
          {| Trans := fun c => Trans (iso_morphism Adj) (c, F _o c)%object id |};
        adj_morph_ex := fun _ _ f => Trans (inverse_morphism Adj) (_, _) f
      |}.

  End Hom_Adj_Adj.

End Adjunction.

Arguments adj_unit {_ _ _ _} _ : assert.
Arguments adj_morph_ex {_ _ _ _} _ {_ _} _.
Arguments adj_morph_com {_ _ _ _} _ {_ _} _.
Arguments adj_morph_unique {_ _ _ _} _ {_ _} _ _ _ _ _.

Arguments ucu_adj_unit {_ _ _ _} _.
Arguments ucu_adj_counit {_ _ _ _} _.
Arguments ucu_adj_left_id {_ _ _ _} _.
Arguments ucu_adj_right_id {_ _ _ _} _.

Arguments Adj_to_Hom_Adj {_ _ _ _} _.

Arguments Hom_Adj_to_Adj {_ _ _ _} _.

Notation "F ⊣ G" := (Adjunct F G) : functor_scope.
Notation "F ⊣_hom G" := (Hom_Adjunct F G) : functor_scope.
Notation "F ⊣_ucu G" := (UCU_Adjunct F G) : functor_scope. *)
(* Categories.Adjunction.Duality:
From Categories Require Import Category.Main.
From Categories Require Import Ext_Cons.Prod_Cat.Prod_Cat Ext_Cons.Prod_Cat.Operations.
From Categories Require Import Functor.Main.
From Categories Require Import Functor.Representable.Hom_Func Functor.Representable.Hom_Func_Prop.
From Categories Require Import NatTrans.NatTrans NatTrans.NatIso.
From Categories Require Import Adjunction.Adjunction.

Local Open Scope functor_scope.

Section Hom_Adj_Duality.
  Context {C D : Category} {F : C –≻ D} {G : D –≻ C} (adj : F ⊣_hom G).

  Definition Hom_Adjunct_Duality : G^op ⊣_hom F^op :=
    (Prod_Func_Hom_Func (adj⁻¹))
  .

End Hom_Adj_Duality.

Section Adj_Duality.
  Context {C D : Category} {F : C –≻ D} {G : D –≻ C} (adj : F ⊣ G).

  Definition Adjunct_Duality : G^op ⊣ F^op :=
    (Hom_Adj_to_Adj (Hom_Adjunct_Duality (Adj_to_Hom_Adj adj)))
  .

End Adj_Duality. *)

From Categories Require Import Ext_Cons.Comma.
(* Categories.Ext_Cons.Comma:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Category Category.Morph Category.Opposite.
From Categories Require Import Ext_Cons.Arrow.
From Categories Require Import Functor.Functor Functor.Functor_Ops Const_Func.
From Categories Require Import Archetypal.Discr.Discr.
From Categories Require Import Cat.Cat Cat.Cat_Iso.
From Categories Require Import NatTrans.NatTrans NatTrans.NatIso.

Local Open Scope morphism_scope.

Section Comma.
  Context {B C D : Category} (F : (B –≻ C)%functor) (G : (D –≻ C)%functor).

  Record Comma_Obj : Type :=
    {
      CMO_src : B;
      CMO_trg : D;
      CMO_hom : ((F _o CMO_src) –≻ (G _o CMO_trg))%object
    }.

  Record Comma_Hom (a b : Comma_Obj) : Type :=
    {
      CMH_left : (CMO_src a) –≻ (CMO_src b);
      CMH_right : (CMO_trg a) –≻ (CMO_trg b);
      CMH_com :  ((G _a CMH_right) ∘ (@CMO_hom a) =
                  (@CMO_hom b) ∘ (F _a CMH_left))%morphism
    }.

  Arguments CMH_left {_ _} _.
  Arguments CMH_right {_ _} _.
  Arguments CMH_com {_ _} _.

  Theorem Comma_Hom_eq_simplify {a b : Comma_Obj} (h h' : Comma_Hom a b) :
    (@CMH_left _ _ h) = (@CMH_left _ _ h') →
    (@CMH_right _ _ h) = (@CMH_right _ _ h') → h = h'.

  Program Definition Comma_Hom_compose
          {a b c : Comma_Obj} (h : Comma_Hom a b) (h' : Comma_Hom b c) :
    Comma_Hom a c :=
    {|
      CMH_left := (CMH_left h') ∘ (CMH_left h);
      CMH_right := (CMH_right h') ∘ (CMH_right h)
    |}.

  Theorem Comma_Hom_compose_assoc {a b c d : Comma_Obj} (h : Comma_Hom a b)
          (h' : Comma_Hom b c) (h'' : Comma_Hom c d) :
    Comma_Hom_compose h (Comma_Hom_compose h' h'') =
    Comma_Hom_compose (Comma_Hom_compose h h') h''.

  Program Definition Comma_Hom_id (a : Comma_Obj) : Comma_Hom a a :=
    {|
      CMH_left := id;
      CMH_right := id
    |}.

  Theorem Comma_Hom_id_unit_left {a b : Comma_Obj} (h : Comma_Hom a b) :
    Comma_Hom_compose h (Comma_Hom_id b) = h.

  Theorem Comma_Hom_id_unit_right {a b : Comma_Obj} (h : Comma_Hom a b) :
    Comma_Hom_compose (Comma_Hom_id a) h = h.

  Definition Comma : Category :=
    {|
      Obj := Comma_Obj;

      Hom := Comma_Hom;

      compose := @Comma_Hom_compose;

      assoc := @Comma_Hom_compose_assoc;

      assoc_sym := fun _ _ _ _ f g h => eq_sym (Comma_Hom_compose_assoc f g h);
      
      id := Comma_Hom_id;

      id_unit_right := @Comma_Hom_id_unit_right;

      id_unit_left := @Comma_Hom_id_unit_left
    |}.

End Comma.

Arguments CMO_src {_ _ _ _ _} _.
Arguments CMO_trg {_ _ _ _ _} _.
Arguments CMO_hom {_ _ _ _ _} _.
Arguments CMH_left {_ _ _ _ _ _ _} _.
Arguments CMH_right {_ _ _ _ _ _ _} _.
Arguments CMH_com {_ _ _ _ _ _ _} _.

Section Comma_Opposite_Iso.
  Context {B C D : Category} (F : (B –≻ C)%functor) (G : (D –≻ C)%functor).

  Local Hint Extern 1 => progress cbn.

  Local Hint Extern 1 => apply Comma_Hom_eq_simplify.
  
  Program Definition Comma_Opposite_Iso_LR :
    Functor ((Comma F G)^op) (Comma (G ^op) (F ^op))
    :=
      {|
        FO :=
          fun x =>
            {|
              CMO_src := CMO_trg x;
              CMO_trg := CMO_src x;
              CMO_hom := CMO_hom x
            |};
        FA :=
          fun c c' h =>
            {|
              CMH_left := CMH_right h;
              CMH_right := CMH_left h;
              CMH_com := eq_sym (CMH_com h)
            |}
      |}.

  Program Definition Comma_Opposite_Iso_RL :
    Functor (Comma (G ^op) (F ^op)) ((Comma F G)^op)
    :=
      {|
        FO :=
          fun x =>
            {|
              CMO_src := CMO_trg x;
              CMO_trg := CMO_src x;
              CMO_hom := CMO_hom x
            |};
        FA :=
          fun c c' h =>
            {|
              CMH_left := CMH_right h;
              CMH_right := CMH_left h;
              CMH_com := eq_sym (CMH_com h)
            |}
      |}.
    
  Program Definition Comma_Opposite_Iso :
    (((Comma F G)^op)%category ≃≃ Comma (G ^op) (F ^op) ::> Cat)%isomorphism
    :=
      {|
        iso_morphism := Comma_Opposite_Iso_LR;
        inverse_morphism := Comma_Opposite_Iso_RL
      |}
  .

End Comma_Opposite_Iso.

Section Comma_Left_Func_Iso.
  Context {B C D : Category}.

  Local Hint Extern 1 => progress cbn.

  Local Hint Extern 1 => apply Comma_Hom_eq_simplify.

  Section Comma_Left_Func_Iso_FC.
    Context
      {F F' : (B –≻ C)%functor}
      (I : (F ≃ F')%natiso)
      (G : (D –≻ C)%functor)
    .

    Program Definition Comma_Left_Func_Iso_FC :
      Functor (Comma F G) (Comma F' G)
      :=
        {|
          FO :=
            fun x =>
              {|
                CMO_src := CMO_src x;
                CMO_trg := CMO_trg x;
                CMO_hom := (CMO_hom x) ∘ (Trans (inverse_morphism I) (CMO_src x))
              |};
          FA :=
            fun c c' h =>
              {|
                CMH_left := CMH_left h;
                CMH_right := CMH_right h;
              CMH_com := _
              |}
        |}.
    
  End Comma_Left_Func_Iso_FC.

  Section Comma_Left_Func_Iso_FC_Iso.
    Context
      {F F' : (B –≻ C)%functor}
      (I : (F ≃ F')%natiso)
      (G : (D –≻ C)%functor)
    .

    Lemma Comma_Left_Func_Iso_FC_Iso :
      ((Comma_Left_Func_Iso_FC I G)
         ∘
         (Comma_Left_Func_Iso_FC (Inverse_Isomorphism I) G))%functor
      =
      Functor_id _
    .
    
  End Comma_Left_Func_Iso_FC_Iso.

  Context
    {F F' : (B –≻ C)%functor}
    (I : (F ≃ F')%natiso)
    (G : (D –≻ C)%functor)
  .

  Local Hint Extern 1 => apply Comma_Left_Func_Iso_FC_Iso.
  
  Program Definition Comma_Left_Func_Iso :
    ((Comma F G) ≃≃ (Comma F' G) ::> Cat)%isomorphism
    :=
      {|
        iso_morphism := Comma_Left_Func_Iso_FC I G;
        inverse_morphism := Comma_Left_Func_Iso_FC (Inverse_Isomorphism I) G
      |}
  . 
    
End Comma_Left_Func_Iso.

Section Comma_Right_Func_Iso.
  Context
    {B C D : Category}
    (F : (B –≻ C)%functor)
    {G G' : (D –≻ C)%functor}
    (I : (G ≃ G')%natiso)
  .

  Definition Comma_Right_Func_Iso :
    ((Comma F G) ≃≃ (Comma F G') ::> Cat)%isomorphism :=
    Isomorphism_Compose
      (
        Isomorphism_Compose
          (Inverse_Isomorphism (Comma_Opposite_Iso (G ^op) (F ^op)))
          (Opposite_Cat_Iso (Comma_Left_Func_Iso (Opposite_NatIso I) (F^op)))
      )
      (Comma_Opposite_Iso (G' ^op) (F ^op))
  .
    
End Comma_Right_Func_Iso.

Section Slice_CoSlice.
  Context (C : Category) (c : Obj).
  
  Definition Slice : Category := Comma (Functor_id _) (Const_Func 1 c).

  Definition CoSlice : Category := Comma (Const_Func 1 c) (Functor_id _).

End Slice_CoSlice.

Section Arrow_Cat.
  Context (C : Category).

  Definition Arrow_Cat : Category := Comma (Functor_id C) (Functor_id C).

End Arrow_Cat. *)

From Categories Require Import Basic_Cons.Terminal Basic_Cons.Facts.Term_IsoCat.
(* Categories.Basic_Cons.Terminal:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Main.

Class Terminal (C : Category) : Type :=
{
  terminal : C;
  t_morph : ∀ (d : Obj), (d –≻ terminal)%morphism;
  t_morph_unique : ∀ (d : Obj) (f g : (d –≻ terminal)%morphism), f = g
}.

Arguments terminal {_} _.
Arguments t_morph {_} _ _.
Arguments t_morph_unique {_} _ _ _ _.

Coercion terminal : Terminal >-> Obj.

Notation "𝟙_ C" := (Terminal C) (at level 75) : object_scope.

Theorem Terminal_iso {C : Category} (T T' : (𝟙_ C)%object) :
  (T ≃ T')%isomorphism.

Definition Initial (C : Category) := (𝟙_ (C ^op))%object.
Existing Class Initial.

Notation "𝟘_ C" := (Initial C) (at level 75) : object_scope. *)
(* Categories.Basic_Cons.Facts.Term_IsoCat:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Functor Functor.Functor_Ops.
From Categories Require Import Basic_Cons.Terminal.
From Categories Require Import Cat.Cat Cat.Cat_Iso.

Section Term_IsoCat.
  Context {C D : Category}
          (I : (C ≃≃ D ::> Cat)%isomorphism) (trm : (𝟙_ C)%object).

  Program Definition Term_IsoCat : (𝟙_ D)%object
    :=
      {|
        terminal := ((iso_morphism I) _o)%object trm;
        t_morph :=
          fun c =>
            match
              f_equal (fun w : (D –≻ D)%functor => (w _o)%object c)
                      (right_inverse I)
              in _ = u return
              (u –≻ _)%morphism
            with
              eq_refl => ((iso_morphism I) _a ((t_morph
                                                 trm ((I⁻¹)%morphism _o c)))
                        )%morphism
            end;
        t_morph_unique :=
          fun c f g => _
      |}
  .

End Term_IsoCat. *)

From Categories Require Import Cat.Cat_Iso.
(* Categories.Cat.Cat_Iso:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Functor Functor.Functor_Ops.
From Categories Require Import Coq_Cats.Type_Cat.Type_Cat.
From Categories Require Import Ext_Cons.Prod_Cat.Prod_Cat.
From Categories Require Import Cat.Cat.
From Categories Require Import NatTrans.NatTrans NatTrans.Operations NatTrans.Func_Cat
        NatTrans.NatIso.

Local Open Scope isomorphism_scope.
Local Open Scope morphism_scope.
Local Open Scope object_scope.

Section Opposite_Cat_Iso.
  Context {C D : Category} (I : C ≃≃ D ::> Cat).

  Program Definition Opposite_Cat_Iso :
    (C^op)%category ≃≃ (D^op)%category ::> Cat
    :=
      {|
        iso_morphism := ((iso_morphism I)^op)%functor;
        inverse_morphism := ((inverse_morphism I)^op)%functor
      |}.

End Opposite_Cat_Iso.
  
Section Cat_IConv.
  Context {C D : Category} (I : C ≃≃ D ::> Cat).

  Definition Cat_Iso_Obj_conv (c : C) :
    c = (((inverse_morphism I) _o) (((iso_morphism I) _o) c))%object.

  Definition Cat_Iso_Hom_conv (c c' : C) :
    ((((inverse_morphism I) _o) (((iso_morphism I) _o) c))
      –≻
      (((inverse_morphism I) _o) (((iso_morphism I) _o) c')))%morphism
    = (c –≻ c').

  Definition Cat_Iso_conv_inv {c c' : C}
             (h :
                (((inverse_morphism I) _o) (((iso_morphism I) _o) c))
                  –≻ (((inverse_morphism I) _o) (((iso_morphism I) _o) c')))
    : c –≻ c' :=
    match Cat_Iso_Hom_conv c c' in _ = Y return Y with
      eq_refl => h
    end.

  Theorem Cat_Iso_conv_inv_JMeq {c c' : C}
          (h :
             (((inverse_morphism I) _o) (((iso_morphism I) _o) c))
               –≻ (((inverse_morphism I) _o) (((iso_morphism I) _o) c')))
    : Cat_Iso_conv_inv h ~= h.

  Definition Cat_Iso_conv {c c' : C} (h : c –≻ c') :
    (((inverse_morphism I) _o) (((iso_morphism I) _o) c))
      –≻ (((inverse_morphism I) _o) (((iso_morphism I) _o) c'))
    :=
    match eq_sym (Cat_Iso_Hom_conv c c') in _ = Y return Y with
      eq_refl => h
    end.
  
  Theorem Cat_Iso_conv_JMeq {c c' : C} (h : c –≻ c') : Cat_Iso_conv h ~= h.

  Theorem Cat_Iso_conv_inv_Cat_Iso_conv {c c' : C} (h : c –≻ c')
    : Cat_Iso_conv_inv (Cat_Iso_conv h) = h.

  Theorem Cat_Iso_conv_Cat_Iso_conv_inv {c c' : C}
          (h :
             (((inverse_morphism I) _o) (((iso_morphism I) _o) c))
               –≻ (((inverse_morphism I) _o) (((iso_morphism I) _o) c')))
    :
      Cat_Iso_conv (Cat_Iso_conv_inv h) = h.

  Theorem Cat_Iso_conv_inv_I_inv_I {c c' : C} (h : c –≻ c') :
    Cat_Iso_conv_inv (((inverse_morphism I) _a) (((iso_morphism I) _a) h)) = h.

  Theorem Cat_Iso_conv_inv_compose {c c' c'' : C}
          (h :
             (((inverse_morphism I) _o) (((iso_morphism I) _o) c))
               –≻ (((inverse_morphism I) _o) (((iso_morphism I) _o) c'))
          )
          (h' :
             (((inverse_morphism I) _o) (((iso_morphism I) _o) c'))
               –≻ (((inverse_morphism I) _o) (((iso_morphism I) _o) c''))
          )
    :
      Cat_Iso_conv_inv (compose C h h')
      = compose C (Cat_Iso_conv_inv h) (Cat_Iso_conv_inv h').

End Cat_IConv.

Section Cat_Iso_inv.
  Context {C D : Category} (I : C ≃≃ D ::> Cat).

  Theorem Cat_Iso_inv
          {c c' : C} (h : ((iso_morphism I) _o c) –≻ ((iso_morphism I) _o c'))
    : {g : c –≻ c' | h = ((iso_morphism I) _a g)}.

End Cat_Iso_inv.

Section IsoCat_NatIso.
  Context {C D : Category} (I : (C ≃≃ D ::> Cat)%morphism)
          {E : Category} (F : (D –≻ E)%functor).

  Program Definition IsoCat_NatIso :
    ((F ∘ ((iso_morphism I) ∘ (I⁻¹)%morphism))%functor ≃ F)%natiso :=
    {|
      iso_morphism := IsoCat_NatTrans I F;
      inverse_morphism := IsoCat_NatTrans_back I F
    |}
  .

End IsoCat_NatIso. *)

From Categories Require Import Archetypal.Discr.Discr Archetypal.Discr.NatFacts.
(* Categories.Archetypal.Discr.Discr:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Functor.
From Categories Require Import Cat.Cat.
From Categories Require Import Coq_Cats.Type_Cat.Type_Cat.

Definition EmptyCat : Category :=
  {|
    Obj := (Empty : Type);
    Hom := fun _ _ => (unit : Type);
    compose := fun _ _ _ _ _ => tt;
    assoc := fun _ _ _ _ _ _ _ => eq_refl;
    assoc_sym := fun _ _ _ _ _ _ _ => eq_refl;
    id := fun _ => tt;
    id_unit_left :=
      fun _ _ h =>
        match h as u return (tt = u) with
        | tt => eq_refl
        end;
    id_unit_right :=
      fun _ _ h =>
        match h as u return (tt = u) with
        | tt => eq_refl
        end
  |}.

Definition SingletonCat : Category :=
  {|
    Obj := (unit : Type);
    Hom := fun _ _ => (unit : Type);
    compose := fun _ _ _ _ _ => tt;
    assoc := fun _ _ _ _ _ _ _ => eq_refl;
    assoc_sym := fun _ _ _ _ _ _ _ => eq_refl;
    id := fun _ => tt;
    id_unit_left :=
      fun _ _ h =>
        match h as u return (tt = u) with
        | tt => eq_refl
        end;
    id_unit_right :=
      fun _ _ h =>
        match h as u return (tt = u) with
        | tt => eq_refl
        end
  |}.

Notation "0" := (EmptyCat) : category_scope.
Notation "1" := (SingletonCat) : category_scope.

Section Discr.
  Context (obj : Type).

  Program Definition Discr_Cat : Category :=
    {|
      Obj := obj;
      Hom := fun a b => a = b;
      compose := @eq_trans _;
      id := fun a => eq_refl
    |}.
    
End Discr.

Definition Type_n (n : nat) : Type := {x : nat| x < n}.

Notation "'Discr_n' n" :=
  (Discr_Cat (Type_n n)) (at level 200, n bigint) : category_scope.

Section Discr_Cat_Dual_Iso.
  Context (obj : Type).

  Local Hint Extern 1 => progress cbn.
  
  Program Definition Discr_Cat_Dual_Iso :
    (Discr_Cat obj ≃≃ (Discr_Cat obj)^op ::> Cat)%isomorphism%category
    :=
      {|
        iso_morphism := {|FO := fun x => x; FA := fun _ _ h => eq_sym h|};
        inverse_morphism := {|FO := fun x => x; FA := fun _ _ h => eq_sym h|}
      |}.

End Discr_Cat_Dual_Iso.

Section Discr_Cat_Iso.
  Context {obj obj' : Type} (I : (obj ≃≃ obj' ::> Type_Cat)%isomorphism).

  Program Definition Discr_Cat_Iso :
    ((Discr_Cat obj) ≃≃ (Discr_Cat obj') ::> Cat)%isomorphism
    :=
      {|
        iso_morphism :=
          {|
            FO := iso_morphism I;
            FA :=
              fun c d h =>
                match h in _ = y return
                      (iso_morphism I c) = (iso_morphism I y)
                with
                  eq_refl => eq_refl
                end
          |};
        inverse_morphism :=
          {|
            FO := inverse_morphism I;
            FA :=
              fun c d h =>
                match h in _ = y return
                      (inverse_morphism I c) = (inverse_morphism I y)
                with
                  eq_refl => eq_refl
                end
          |}
      |}.
  
End Discr_Cat_Iso.

Section Func_From_SingletonCat.
  Context {C : Category} (Cobj : C).

  Program Definition Func_From_SingletonCat : (SingletonCat –≻ C)%functor :=
    {|
      FO := fun _ => Cobj;
      FA := fun _ _ _ => id
    |}.

End Func_From_SingletonCat.

Section Discr_Func.
  Context {C : Category} {A : Type} (Omap : A → C).

  Program Definition Discr_Func : ((Discr_Cat A) –≻ C)%functor :=
    {|
      FO := Omap;
      
      FA := fun (a b : A) (h : a = b) =>
              match h in _ = y return ((Omap a) –≻ (Omap y))%morphism with
              | eq_refl => id
              end
    |}.

  Program Definition Discr_Func_op : ((Discr_Cat A)^op –≻ C)%functor :=
    {|
      FO := Omap;
      FA := fun (a b : A) (h : b = a) =>
              match h in _ = y return ((Omap y) –≻ (Omap b))%morphism with
              | eq_refl => id
              end
    |}.
    
End Discr_Func.
  
Arguments Discr_Func {_ _} _, _ {_} _.
Arguments Discr_Func_op {_ _} _, _ {_} _. *)
(* Categories.Archetypal.Discr.NatFacts:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Main.
From Categories Require Import Ext_Cons.Arrow.
From Categories Require Import Coq_Cats.Type_Cat.Type_Cat.
From Categories Require Import Cat.Cat Cat.Cat_Iso.
From Categories Require Import NatTrans.NatTrans NatTrans.NatIso.
From Categories Require Import Archetypal.Discr.Discr.

Section Discr_Func_Iso.
  Context {C : Category} {A : Type} (Omap : A → C).

  Local Hint Extern 1 => apply NatTrans_eq_simplify; cbn.
  
  Program Definition Discr_Func_Iso :
    (
      (@Discr_Func (C^op) A Omap) ≃ ((@Discr_Func_op C A Omap)^op)%functor
    )%natiso
    :=
      {|
        iso_morphism :=
          {|
            Trans := fun _ => id
          |};
        inverse_morphism :=
          {|
            Trans := fun _ => id
          |}
      |}
  .
    
End Discr_Func_Iso.

Section Func_From_SingletonCat_Opposite.
  Context {C : Category} (x : C).

  Local Hint Extern 1 => apply NatTrans_eq_simplify; cbn.
  
  Program Definition Func_From_SingletonCat_Opposite :
    (
      (((@Func_From_SingletonCat C x)^op)
         ≃ (@Func_From_SingletonCat (C ^op) x))%functor
    )%natiso
    :=
      {|
        iso_morphism :=
          {|
            Trans := fun _ => id
          |};
        inverse_morphism :=
          {|
            Trans := fun _ => id
          |}
      |}
  .
    
End Func_From_SingletonCat_Opposite.

Section Discr_Func_Arrow_Iso.
  Context {C D : Category} (arrmap : (Arrow (C^op)) → D).

  Definition Discr_Cat_ArrowOp_Discr_Cat_Arrow_Op :
    ((((Discr_Cat (Arrow (C^op)))^op)%category)
       ≃≃ ((Discr_Cat (Arrow C))^op)%category ::> Cat)%isomorphism
    :=
      Opposite_Cat_Iso (Discr_Cat_Iso ((Arrow_OP_Iso C)⁻¹))
  .

  Local Hint Extern 1 => apply NatTrans_eq_simplify; cbn.

  Program Definition Discr_Func_Arrow_Iso :
    (
      (
        (Discr_Func_op (fun x : Arrow C => arrmap (Arrow_to_Arrow_OP C x)))
          ∘ (iso_morphism Discr_Cat_ArrowOp_Discr_Cat_Arrow_Op)
      )%functor
        ≃ ((@Discr_Func_op D (Arrow (C^op)) arrmap))%functor
    )%natiso
    :=
      {|
        iso_morphism :=
          {|
            Trans := fun c => id
          |};
        inverse_morphism :=
          {|
            Trans := fun c => id
          |}
      |}
  .
    
End Discr_Func_Arrow_Iso.

Local Hint Extern 1 =>
match goal with [z : Arrow (Discr_Cat _) |- _] => destruct z as [? ? []] end.

Program Definition Discr_Hom_Iso (A : Type) :
  (A ≃≃ Arrow (Discr_Cat A) ::> Type_Cat)%isomorphism :=
  (Build_Isomorphism
     Type_Cat
     _
     _
     (fun a => (Build_Arrow (Discr_Cat A) _ _ (eq_refl a)))
     (fun a : (Arrow (Discr_Cat _)) => Orig a)
     _
     _
  ).

Section Discretize.
  Context {C D : Category} {F G : (C –≻ D)%functor} (N : (F –≻ G)%nattrans).

  Program Definition Discretize :
    ((Discr_Func (F _o)%object) –≻ (Discr_Func (G _o)%object))%nattrans
    :=
    {|
      Trans := Trans N
    |}.
  
End Discretize. *)



Section Universal_Morphism_Right_Adjonit.

  Context

    {C D : Category}

    (G : (D –≻ C)%functor)

    (HU_init : ∀ (x : C), (𝟘_ (Comma (Func_From_SingletonCat x) G))%object )

  .



  Local Definition Universal_Morphism_Lem :

    ∀ c a h,

      CMH_right (t_morph (HU_init c) a) = CMH_right h

  .

  Proof.          

    intros c a h.

    apply f_equal.

    apply (t_morph_unique (HU_init c)).

  Qed.



  Local Ltac smart_apply_Universal_Morphism_Lem :=

    match goal with

      [|- CMH_right ?A = ?B] =>

      match type of A with

        ?W =>

        let M :=

            (eval cbn in W)

        in

        match M with

          Comma_Hom _ _ ?X ?Y =>

          evar (U : Comma_Hom _ _ X Y);

            replace B with (CMH_right ?U);

            [

              eapply

                (

                  Universal_Morphism_Lem

                    _

                    Y

                    (

                      Build_Comma_Hom

                        _

                        _

                        X

                        Y

                        tt

                        B

                        _

                    )

                )

            |

            reflexivity

            ]

        end

      end

    end.

    

  Program Definition Universal_Morphism_Right_Adjonit_Func : (C –≻ D)%functor

    :=

      {|

        FO :=

          fun c =>

            CMO_trg (terminal (HU_init c));

        FA :=

          fun c c' h =>

            CMH_right

              (t_morph

                 (HU_init c)

                 (@Build_Comma_Obj

                    _

                    _

                    _

                    (Const_Func 1 c)

                    G

                    tt

                    (CMO_trg (terminal (HU_init c')))

                    ((CMO_hom (terminal (HU_init c'))) ∘ h)%morphism

                 )

              )

      |}

  .



  Next Obligation.

  Proof.

    smart_apply_Universal_Morphism_Lem.

    Unshelve.

    cbn; auto.

  Qed.



  Next Obligation.

  Proof.

    smart_apply_Universal_Morphism_Lem.

    Unshelve.

    {

      cbn.

      rewrite F_compose.

      rewrite assoc.

      simpl_ids;

      match goal with

        [|- ((G _a) ((CMH_right ?A)) ∘ ((G _a) (CMH_right ?B)) ∘ _)%morphism = _] =>

        cbn_rewrite (CMH_com B);

          do 2 rewrite assoc_sym;

          cbn_rewrite (CMH_com A); auto

      end.

    }

  Qed.



  Local Obligation Tactic := idtac.



  Program Definition Universal_Morphism_Right_Adjonit_unit :

    (Functor_id C –≻ G ∘ Universal_Morphism_Right_Adjonit_Func)%nattrans

    :=

      {|

        Trans := fun c => CMO_hom (terminal (HU_init c))

      |}

  .



  Next Obligation.

  Proof.

    intros c c' h.

    cbn.

    match goal with

      [|- _ = (G _a (CMH_right ?A) ∘ _)%morphism] =>

      cbn_rewrite (CMH_com A)

    end.

    auto.

  Qed.



  Next Obligation.

  Proof.

    symmetry.

    apply Universal_Morphism_Right_Adjonit_unit_obligation_1.

  Qed.



  Program Definition Universal_Morphism_Right_Adjonit :

    (Universal_Morphism_Right_Adjonit_Func ⊣ G)%functor

    :=

      {|

        adj_unit := Universal_Morphism_Right_Adjonit_unit;

        adj_morph_ex :=

          fun c d f =>

            CMH_right

              (t_morph

                 (HU_init c)

                 (@Build_Comma_Obj

                    _

                    _

                    _

                    (Const_Func 1 c)

                    G

                    tt

                    d

                    f

                 )

              )

      |}

  .



  Next Obligation.

  Proof.

    intros c d f.

    cbn in *.

    match goal with

      [|- _ = (G _a (CMH_right ?A) ∘ _)%morphism] =>

      cbn_rewrite (CMH_com A)

    end.

    auto.

  Qed.



  Next Obligation.

  Proof.

    intros c d f g h H1 H2.

    cbn in *.

    rewrite <- (id_unit_right _ _ f) in H1, H2.

    symmetry in H1, H2.

    set (W :=

           @Build_Comma_Obj

             _

             _

             _

             (Const_Func 1 c)

             G

             tt

             d

             f

        )

    .

    let tac u H

        :=

        (

          change u with

          (

            CMH_right

              (  

                Build_Comma_Hom

                  _

                  _

                  (terminal (HU_init c))

                  W

                  tt

                  u

                  H

              )

          )

        )

    in

    tac g H1;

      tac h H2

    .

    transitivity (CMH_right (t_morph (HU_init c) W));

      [symmetry|];

      apply (Universal_Morphism_Lem c W)

    .

  Qed.



End Universal_Morphism_Right_Adjonit.



Section Right_Adjoint_Universal_Morphism.

  Context

    {C D : Category}

    {F : (C –≻ D)%functor}

    {G : (D –≻ C)%functor}

    (Adj : (F ⊣ G)%functor)

    (x : C)

  .



  Program Definition Right_Adjoint_Universal_Morphism_terminal :

    (Comma (Func_From_SingletonCat x) G)

    :=

      {|

        CMO_src := tt;

        CMO_trg := (F _o x)%object;

        CMO_hom := Trans (adj_unit Adj) x

      |}

  .



  Program Definition Right_Adjoint_Universal_Morphism_t_morph

          (u : (Comma (Func_From_SingletonCat x) G))

    :

      Comma_Hom _ _ Right_Adjoint_Universal_Morphism_terminal u

    :=

      {|

        CMH_left := tt;

        CMH_right :=

          @adj_morph_ex

            _

            _

            _

            _

            Adj

            x

            (CMO_trg u)

            (CMO_hom u)

      |}

  .



  Next Obligation.

  Proof.  

    simpl_ids.

    symmetry.

    apply (@adj_morph_com _ _ _ _ Adj).

  Qed.

  

  Program Definition Right_Adjoint_Universal_Morphism :

    (𝟘_ (Comma (Func_From_SingletonCat x) G))%object

    :=

      {|

        terminal := Right_Adjoint_Universal_Morphism_terminal;

        t_morph := Right_Adjoint_Universal_Morphism_t_morph

      |}

  .



  Next Obligation.

  Proof.

    assert (Hf := CMH_com f).

    assert (Hg := CMH_com g).

    cbn in *.

    simpl_ids in Hf; simpl_ids in Hg.

    symmetry in Hf, Hg.

    apply Comma_Hom_eq_simplify.

    match goal with

      [|- ?A = ?B] =>

      destruct A; destruct B; trivial

    end.

    eapply (@adj_morph_unique _ _ _ _ Adj); eauto.

  Qed.



End Right_Adjoint_Universal_Morphism.



Section Universal_Morphism_Left_Adjonit.

  Context

    {C D : Category}

    (F : (C –≻ D)%functor)

    (HU_term : ∀ (x : D), (𝟙_ (Comma F (@Func_From_SingletonCat D x)))%object)

  .



  Definition Universal_Morphism_Left_Adjonit_HU_init

             (x : (D^op)%category)

    :

      (𝟘_ (Comma ((@Func_From_SingletonCat (D ^op) x)) (F^op)))%object

    :=

      Term_IsoCat

        (

          Opposite_Cat_Iso

            (

              Isomorphism_Compose

                (Comma_Opposite_Iso F (@Func_From_SingletonCat D x))

                (Comma_Left_Func_Iso

                   (@Func_From_SingletonCat_Opposite D x) (F ^op))

            )

        )

        (HU_term x)

  .



  Definition Universal_Morphism_Left_Adjonit

    :

      (F ⊣ (

               Universal_Morphism_Right_Adjonit_Func

                 (F ^op)

                 Universal_Morphism_Left_Adjonit_HU_init

             )^op

      )%functor

    :=

      Adjunct_Duality

        (

          @Universal_Morphism_Right_Adjonit

            (D^op)

            (C^op)

            (F^op)

            Universal_Morphism_Left_Adjonit_HU_init

        )

  .



End Universal_Morphism_Left_Adjonit.



Section Left_Adjoint_Universal_Morphism.

  Context

    {C D : Category}

    {F : (C –≻ D)%functor}

    {G : (D –≻ C)%functor}

    (Adj : (F ⊣ G)%functor)

    (x : D)

  .



  Definition Left_Adjoint_Universal_Morphism

    : (𝟙_ (Comma F (Const_Func 1 x)))%object

    :=

      Term_IsoCat

        (

          Opposite_Cat_Iso

            (

              Isomorphism_Compose

                (

                  Comma_Left_Func_Iso

                    (Inverse_Isomorphism (@Func_From_SingletonCat_Opposite D x))

                    (F ^op)

                )

                (Inverse_Isomorphism

                   (Comma_Opposite_Iso F (@Func_From_SingletonCat D x)))

            )

        )

        (Right_Adjoint_Universal_Morphism (Adjunct_Duality Adj) x)

  .



End Left_Adjoint_Universal_Morphism.

