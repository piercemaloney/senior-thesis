From Categories Require Import Essentials.Notations.
(* Categories.Essentials.Notations:
Notation "∀ x .. y , P" := (forall x, .. (forall y, P) ..)
                             (at level 200, x binder, y binder, right associativity) : type_scope.

Notation "∃ x .. y , P" := (exists x, .. (exists y, P) ..)
  (at level 200, x binder, y binder, right associativity) : type_scope.

Notation "x ∨ y" := (x \/ y) (at level 85, right associativity) : type_scope.

Notation "x ∧ y" := (x /\ y) (at level 80, right associativity) : type_scope.

Notation "x → y" := (x -> y)
  (at level 90, y at level 200, right associativity): type_scope.

Notation "x ↔ y" := (x <-> y) (at level 95, no associativity): type_scope.

Notation "¬ x" := (~x) (at level 75, right associativity) : type_scope.

Notation "x ≠ y" := (x <> y) (at level 70) : type_scope.

Notation "x ≤ y" := (le x y) (at level 70, no associativity).

Notation "x ≥ y" := (ge x y) (at level 70, no associativity).

Reserved Notation "C '^op'" (at level 50, no associativity).

Reserved Notation "a –≻ b" (at level 90, b at level 200, right associativity).

Reserved Notation "f '⁻¹'" (at level 50, no associativity).

Reserved Notation "a ≃ b" (at level 70, no associativity).

Reserved Notation "a ≃≃ b ::> C" (at level 70, no associativity).

Reserved Notation "f ∘ g" (at level 51, right associativity).

Reserved Notation "f '∘_h' g" (at level 51, right associativity).

Reserved Notation "a ≫–> b" (at level 100, no associativity).

Reserved Notation "a –≫ b" (at level 100, no associativity).

Reserved Notation "F '_o'" (at level 50, no associativity).

Reserved Notation "F '_a'" (at level 50, no associativity).

Reserved Notation "F '@_a'" (at level 50, no associativity).

Reserved Notation "F ⊣ G" (at level 100, no associativity).

Reserved Notation "F ⊣_hom G" (at level 100, no associativity).

Reserved Notation "F ⊣_ucu G" (at level 100, no associativity).

Reserved Notation "a × b" (at level 80, no associativity).

Reserved Notation "a ⇑ b" (at level 79, no associativity).

Reserved Notation "'Π' m" (at level 50, no associativity).

Reserved Notation "'Σ' m" (at level 50, no associativity).

Reserved Notation "'Π_' C ↓ m" (at level 50, no associativity).

Reserved Notation "'Σ_' C ↓ m" (at level 50, no associativity).

Delimit Scope category_scope with category.

Delimit Scope morphism_scope with morphism.

Delimit Scope object_scope with object.

Delimit Scope functor_scope with functor.

Delimit Scope nattrans_scope with nattrans.

Delimit Scope nattrans_scope with nattrans.

Delimit Scope natiso_scope with natiso.

Delimit Scope isomorphism_scope with isomorphism.

Delimit Scope preorder_scope with preorder. *)

From Categories Require Import Essentials.Types.
(* Categories.Essentials.Types:
Global Set Primitive Projections.

Global Set Universe Polymorphism.

Global Unset Universe Minimization ToSet.

Inductive Empty : Type :=.

Hint Extern 1 =>
let tac := (repeat intros ?); match goal with [H : Empty |- _] => contradict H end in
match goal with
  | [|- context[Empty]] => tac
  | [H : context[Empty] |- _] => tac
end
.

Record prod (A B : Type) := {fst : A; snd : B}.

Arguments fst {_ _ } _.
Arguments snd {_ _ } _.
Arguments Build_prod {_ _ } _ _.

Notation "( X , Y )" := (Build_prod X Y).
Notation "X * Y" := (prod X Y) : type_scope. *)

From Categories Require Import Essentials.Facts_Tactics.
(* Categories.Essentials.Facts_Tactics:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.

Require Export Coq.Program.Tactics.
Require Export Coq.Program.Equality.
Require Export Coq.Logic.FunctionalExtensionality.
Require Export Coq.Logic.ProofIrrelevance.

Definition equal_f : ∀ {A B : Type} {f g : A → B}, f = g → ∀ x : A, f x = g x.

Definition f_equal : ∀ (A B : Type) (f : A → B) (x y : A), x = y → f x = f y.

Arguments f_equal [_ _] _ [_ _] _.

Ltac basic_simpl :=
  let simpl_prod _ :=
      match goal with
        [H : prod _ _ |- _] =>
        let H1 := fresh H "1" in
        let H2 := fresh H "2" in
        destruct H as [H1 H2]
      end
  in
  let simpl_sig _ :=
      match goal with
        [H : @sig _ _ |- _] =>
        let H1 := fresh H "1" in
        let H2 := fresh H "2" in
        destruct H as [H1 H2]
      end
  in
  let basic_simpl_helper _ :=
      cbn in *; intros;
        repeat simpl_prod tt;
        repeat simpl_sig tt
  in
  repeat basic_simpl_helper tt
.

Global Obligation Tactic := basic_simpl; auto.

Ltac PIR :=
  let pir_helper _ :=
      match goal with
      |[H : ?A, H' : ?A|- _] =>
       match type of A with
       | Prop =>
         destruct (proof_irrelevance _ H H')
       end
      end
  in
  repeat pir_helper tt
.

Ltac ElimEq := repeat match goal with [H : _ = _|- _] => destruct H end.

Hint Extern 1 => progress ElimEq.

Ltac cbn_rewrite W :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite H; clear H
.

Ltac cbn_rewrite_in W V :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite H in V; clear H
.

Ltac cbn_rewrite_back W :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite <- H; clear H
.

Ltac cbn_rewrite_back_in W V :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite <- H in V; clear H
.

Tactic Notation "cbn_rewrite" constr(W) := cbn_rewrite W.
Tactic Notation "cbn_rewrite" constr(W) "in" hyp_list(V) := cbn_rewrite_in W V.
Tactic Notation "cbn_rewrite" "<-" constr(W) := cbn_rewrite_back W.
Tactic Notation "cbn_rewrite" "<-" constr(W) "in" hyp_list(V) := cbn_rewrite_back_in W V.

Lemma sig_proof_irrelevance {A : Type} (P : A → Prop) (X Y : sig P) : proj1_sig X = proj1_sig Y → X = Y.

Hint Extern 2 (exist ?A _ _ = exist ?A _ _) => apply sig_proof_irrelevance.

Ltac FunExt :=
progress (
    repeat (
        match goal with
          [|- _ = _] =>
          let x := fresh "x" in
          extensionality x
        end
      )
  )
.

Hint Extern 1 => FunExt.

Lemma pair_eq (A B : Type) (a b : A * B) : fst a = fst b → snd a = snd b → a = b.

Hint Resolve pair_eq.

Ltac revert_clearbody_all :=
 repeat lazymatch goal with H:_ |- _ => try clearbody H; revert H end.

Ltac hyp_stack :=
 constr:(ltac:(revert_clearbody_all;constructor) : True).

Ltac next_hyp hs step last :=
 lazymatch hs with (?hs' ?H) => step H hs' | _ => last end.

Tactic Notation "dohyps" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := tac H; next_hyp hs step idtac in
 next_hyp hs step idtac.

Tactic Notation "dohyps" "reverse" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := next_hyp hs step idtac; tac H in
 next_hyp hs step idtac.

Tactic Notation "do1hyp" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := tac H + next_hyp hs step fail in
 next_hyp hs step fail.

Tactic Notation "do1hyp" "reverse" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := next_hyp hs step fail + tac H in
 next_hyp hs step fail. *)

From Categories Require Import Category.Main.
(* Categories.Category.Main:
From Categories Require Export Category.Category.
From Categories Require Export Category.Morph.
From Categories Require Export Category.Opposite.
From Categories Require Export Category.SubCategory.
From Categories Require Export Category.Composable_Chain. *)

From Categories Require Import Basic_Cons.CCC Basic_Cons.LCCC Basic_Cons.PullBack.
(* Categories.Basic_Cons.CCC:
From Categories Require Import Essentials.Notations.
From Categories Require Import Category.Main.
From Categories Require Export Basic_Cons.Terminal.
From Categories Require Export Basic_Cons.Product.
From Categories Require Export Basic_Cons.Exponential.
From Categories Require Export Basic_Cons.Exponential_Functor.

Class CCC (C : Category) : Type :=
{
  CCC_term : (𝟙_ C)%object;
  CCC_HP : Has_Products C;
  CCC_HEXP : Has_Exponentials C
}.

Arguments CCC_term _ {_}, {_ _}.
Arguments CCC_HP _ {_} _ _, {_ _} _ _.
Arguments CCC_HEXP _ {_} _ _, {_ _} _ _.

Existing Instances CCC_term CCC_HP CCC_HEXP. *)
(* Categories.Basic_Cons.LCCC:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.

End Slice_Terminal.
  
Section PullBack_Slice_Prod.
  Context {C : Category} {c : C} {f g : Slice C c}
          (PB : PullBack (CMO_hom f) (CMO_hom g)).

  Local Notation CA z :=
    (Build_Comma_Obj (Functor_id C) (Const_Func 1 c) _ tt z) (only parsing).

  Program Definition PullBack_Slice_Prod : (f × g)%object :=
    {|
      product := CA ((CMO_hom f) ∘ (pullback_morph_1 PB));
      Pi_1 :=
        {|
          CMH_left := pullback_morph_1 PB;
          CMH_right :=
            match (CMO_trg f) as u return
                  Hom 1 u tt
            with
              tt => id
            end
        |};
      Pi_2 :=
        {|
          CMH_left := pullback_morph_2 PB;
          CMH_right :=
            match (CMO_trg g) as u return
                  Hom 1 u tt
            with
              tt => id
            end
        |};
      Prod_morph_ex :=
        fun _ r1 r2 =>
          Build_Comma_Hom
            _
            _
            _
            (CA ((CMO_hom f) ∘ pullback_morph_1 PB))
            (pullback_morph_ex PB _ (CMH_left r1) (CMH_left r2) _)
            tt
            _
    |}.

End PullBack_Slice_Prod.

Section Slice_Prod_PullBack.
  Context {C : Category} {c : C} {f g : Slice C c}.

  Local Notation CA z :=
    (Build_Comma_Obj (Functor_id C) (Const_Func 1 c) _ tt z) (only parsing).

  Context (PR : (f × g)%object).
  
  Program Definition Slice_Prod_PullBack : PullBack (CMO_hom f) (CMO_hom g) :=
    {|
      pullback := (CMO_src (@product _ _ _ PR));
      pullback_morph_1 := CMH_left (Pi_1 PR);
      pullback_morph_2 := CMH_left (Pi_2 PR);
      pullback_morph_ex :=
        fun p r1 r2 H => CMH_left (Prod_morph_ex
                                  PR (CA ((CMO_hom f) ∘ r1))
                                  (Build_Comma_Hom _ _ (CA ((CMO_hom f) ∘ r1))
                                                   f r1 tt _)
                                  (Build_Comma_Hom _ _ (CA ((CMO_hom f) ∘ r1))
                                                   g r2 tt _))
    |}.

End Slice_Prod_PullBack.

Section Has_PullBack_Slice_Has_Prod.
  Context {C : Category} (HPB : Has_PullBacks C) (c : C).

  Definition Has_PullBack_Slice_Has_Prod :
    Has_Products (Slice C c)
    :=
      fun f g =>
        PullBack_Slice_Prod (HPB _ _ _ (CMO_hom f) (CMO_hom g))
  .

End Has_PullBack_Slice_Has_Prod.

Section Slice_Has_Prod_Has_PullBack.
  Context {C : Category} (HPR : ∀ c : C, Has_Products (Slice C c)).

  Definition Slice_Has_Prod_Has_PullBack :
    Has_PullBacks C
    :=
      fun a b c f g =>
        Slice_Prod_PullBack
          (HPR
             _
             (Build_Comma_Obj (Functor_id C) (Const_Func 1 c) _ tt f)
             (Build_Comma_Obj (Functor_id C) (Const_Func 1 c) _ tt g)
          )
  .
  
End Slice_Has_Prod_Has_PullBack.
    
Definition LCCC (C : Category) : Type := ∀ (c : C), CCC (Slice C c).
Existing Class LCCC. *)
(* Categories.Basic_Cons.PullBack:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.

Local Open Scope morphism_scope.

Section PullBack.
  Context {C : Category} {a b x : C} (f : a –≻ x) (g : b –≻ x).

  Record PullBack : Type :=
    {
      pullback : C;

      pullback_morph_1 : pullback –≻ a;

      pullback_morph_2 : pullback –≻ b;

      pullback_morph_com : f ∘ pullback_morph_1 = g ∘ pullback_morph_2;

      pullback_morph_ex (p' : Obj) (pm1 : p' –≻ a) (pm2 : p' –≻ b) :
        f ∘ pm1 = g ∘ pm2 → p' –≻ pullback;

      pullback_morph_ex_com_1 (p' : Obj) (pm1 : p' –≻ a) (pm2 : p' –≻ b)
                              (pmc : f ∘ pm1 = g ∘ pm2)
      :
        pullback_morph_1 ∘ (pullback_morph_ex p' pm1 pm2 pmc) = pm1;

      pullback_morph_ex_com_2 (p' : Obj) (pm1 : p' –≻ a) (pm2 : p' –≻ b)
                              (pmc : f ∘ pm1 = g ∘ pm2)
      :
        pullback_morph_2 ∘ (pullback_morph_ex p' pm1 pm2 pmc) = pm2;

      pullback_morph_ex_unique
        (p' : Obj) (pm1 : p' –≻ a) (pm2 : p' –≻ b)
        (pmc : f ∘ pm1 = g ∘ pm2) (u u' : p' –≻ pullback) :
        pullback_morph_1 ∘ u = pm1 →
        pullback_morph_2 ∘ u = pm2 →
        pullback_morph_1 ∘ u' = pm1 →
        pullback_morph_2 ∘ u' = pm2 → u = u'
    }.

  Coercion pullback : PullBack >-> Obj.

  Theorem PullBack_iso (p1 p2 : PullBack) : (p1 ≃ p2)%isomorphism.

End PullBack.

Section is_PullBack.
  Context {C : Category} {a b x pb : C} (p1 : pb –≻ a)
          (p2 : pb –≻ b) (f : a –≻ x) (g : b –≻ x).

  Local Open Scope morphism_scope.
  
  Record is_PullBack : Type :=
    {
      is_pullback_morph_com : f ∘ p1 = g ∘ p2;

      is_pullback_morph_ex (p' : Obj) (pm1 : p' –≻ a) (pm2 : p' –≻ b) :
        f ∘ pm1 = g ∘ pm2 → p' –≻ pb;

      is_pullback_morph_ex_com_1 (p' : Obj) (pm1 : p' –≻ a) (pm2 : p' –≻ b)
                                 (pmc : f ∘ pm1 = g ∘ pm2)
      :
        p1 ∘ (is_pullback_morph_ex p' pm1 pm2 pmc) = pm1;

      is_pullback_morph_ex_com_2 (p' : Obj) (pm1 : p' –≻ a) (pm2 : p' –≻ b)
                                 (pmc : f ∘ pm1 = g ∘ pm2)
      :
        p2 ∘ (is_pullback_morph_ex p' pm1 pm2 pmc) = pm2;

      is_pullback_morph_ex_unique
        (p' : Obj) (pm1 : p' –≻ a) (pm2 : p' –≻ b)
        (pmc : f ∘ pm1 = g ∘ pm2) (u u' : p' –≻ pb) :
        p1 ∘ u = pm1 →
        p2 ∘ u = pm2 →
        p1 ∘ u' = pm1 →
        p2 ∘ u' = pm2 → u = u'
    }.

End is_PullBack.

Definition Has_PullBacks (C : Category) : Type :=
  ∀ (a b c : C) (f : a –≻ c) (g : b –≻ c), PullBack f g.

Existing Class Has_PullBacks.

Arguments PullBack _ {_ _ _} _ _, {_ _ _ _} _ _.
Arguments pullback {_ _ _ _ _ _} _.
Arguments pullback_morph_1 {_ _ _ _ _ _} _.
Arguments pullback_morph_2 {_ _ _ _ _ _} _.
Arguments pullback_morph_com {_ _ _ _ _ _} _.
Arguments pullback_morph_ex {_ _ _ _ _ _} _ _ _ _ _.
Arguments pullback_morph_ex_com_1 {_ _ _ _ _ _} _ _ _ _ _.
Arguments pullback_morph_ex_com_2 {_ _ _ _ _ _} _ _ _ _ _.
Arguments pullback_morph_ex_unique {_ _ _ _ _ _} _ _ _ _ _ _ _ _ _ _ _.

Arguments is_PullBack _ { _ _ _ _} _ _ _ _, {_ _ _ _ _ } _ _ _ _.

Arguments is_pullback_morph_com {_ _ _ _ _ _ _ _ _} _.
Arguments is_pullback_morph_ex {_ _ _ _ _ _ _ _ _} _ _ _ _ _.
Arguments is_pullback_morph_ex_com_1 {_ _ _ _ _ _ _ _ _} _ _ _ _ _.
Arguments is_pullback_morph_ex_com_2 {_ _ _ _ _ _ _ _ _} _ _ _ _ _.
Arguments is_pullback_morph_ex_unique {_ _ _ _ _ _ _ _ _} _ _ _ _ _ _ _ _ _ _ _.

Section is_PullBack_PullBack.
  Context {C : Category} {a b x pb : C} {p1 : pb –≻ a} {p2 : pb –≻ b} {f : a –≻ x}
          {g : b –≻ x} (iPB : is_PullBack p1 p2 f g).

  Definition is_PullBack_PullBack : PullBack f g :=
    {|
      pullback := pb;
      pullback_morph_1 := p1;
      pullback_morph_2 := p2;
      pullback_morph_com := is_pullback_morph_com iPB;
      pullback_morph_ex := fun p' pm1 pm2 => is_pullback_morph_ex iPB p' pm1 pm2;
      pullback_morph_ex_com_1 :=
        fun p' pm1 pm2 pmc => is_pullback_morph_ex_com_1 iPB p' pm1 pm2 pmc;
      pullback_morph_ex_com_2 :=
        fun p' pm1 pm2 pmc => is_pullback_morph_ex_com_2 iPB p' pm1 pm2 pmc;
      pullback_morph_ex_unique :=
        fun p' pm1 pm2 pmc u u' => is_pullback_morph_ex_unique iPB p' pm1 pm2 pmc u u'
    |}.

End is_PullBack_PullBack.

Section PullBack_is_PullBack.
  Context {C : Category} {a b x : C} {f : a –≻ x}
          {g : b –≻ x} (PB : PullBack f g).

  Definition PullBack_is_PullBack :
    is_PullBack (pullback_morph_1 PB) (pullback_morph_2 PB) f g :=
    {|
      is_pullback_morph_com := pullback_morph_com PB;
      is_pullback_morph_ex := fun p' pm1 pm2 => pullback_morph_ex PB p' pm1 pm2;
      is_pullback_morph_ex_com_1 :=
        fun p' pm1 pm2 pmc => pullback_morph_ex_com_1 PB p' pm1 pm2 pmc;
      is_pullback_morph_ex_com_2 :=
        fun p' pm1 pm2 pmc => pullback_morph_ex_com_2 PB p' pm1 pm2 pmc;
      is_pullback_morph_ex_unique :=
        fun p' pm1 pm2 pmc u u' => pullback_morph_ex_unique PB p' pm1 pm2 pmc u u'
    |}.

End PullBack_is_PullBack.
  
Definition PushOut (C : Category) := @PullBack (C^op).

Arguments PushOut _ {_ _ _} _ _, {_ _ _ _} _ _.

Definition Has_PushOuts (C : Category) : Type :=
  ∀ (a b c : C) (f : c –≻ a) (g : c –≻ b), PushOut f g.

Existing Class Has_PushOuts. *)

From Categories Require Import Ext_Cons.Comma.
(* Categories.Ext_Cons.Comma:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Category Category.Morph Category.Opposite.
From Categories Require Import Ext_Cons.Arrow.
From Categories Require Import Functor.Functor Functor.Functor_Ops Const_Func.
From Categories Require Import Archetypal.Discr.Discr.
From Categories Require Import Cat.Cat Cat.Cat_Iso.
From Categories Require Import NatTrans.NatTrans NatTrans.NatIso.

Local Open Scope morphism_scope.

Section Comma.
  Context {B C D : Category} (F : (B –≻ C)%functor) (G : (D –≻ C)%functor).

  Record Comma_Obj : Type :=
    {
      CMO_src : B;
      CMO_trg : D;
      CMO_hom : ((F _o CMO_src) –≻ (G _o CMO_trg))%object
    }.

  Record Comma_Hom (a b : Comma_Obj) : Type :=
    {
      CMH_left : (CMO_src a) –≻ (CMO_src b);
      CMH_right : (CMO_trg a) –≻ (CMO_trg b);
      CMH_com :  ((G _a CMH_right) ∘ (@CMO_hom a) =
                  (@CMO_hom b) ∘ (F _a CMH_left))%morphism
    }.

  Arguments CMH_left {_ _} _.
  Arguments CMH_right {_ _} _.
  Arguments CMH_com {_ _} _.

  Theorem Comma_Hom_eq_simplify {a b : Comma_Obj} (h h' : Comma_Hom a b) :
    (@CMH_left _ _ h) = (@CMH_left _ _ h') →
    (@CMH_right _ _ h) = (@CMH_right _ _ h') → h = h'.

  Program Definition Comma_Hom_compose
          {a b c : Comma_Obj} (h : Comma_Hom a b) (h' : Comma_Hom b c) :
    Comma_Hom a c :=
    {|
      CMH_left := (CMH_left h') ∘ (CMH_left h);
      CMH_right := (CMH_right h') ∘ (CMH_right h)
    |}.

  Theorem Comma_Hom_compose_assoc {a b c d : Comma_Obj} (h : Comma_Hom a b)
          (h' : Comma_Hom b c) (h'' : Comma_Hom c d) :
    Comma_Hom_compose h (Comma_Hom_compose h' h'') =
    Comma_Hom_compose (Comma_Hom_compose h h') h''.

  Program Definition Comma_Hom_id (a : Comma_Obj) : Comma_Hom a a :=
    {|
      CMH_left := id;
      CMH_right := id
    |}.

  Theorem Comma_Hom_id_unit_left {a b : Comma_Obj} (h : Comma_Hom a b) :
    Comma_Hom_compose h (Comma_Hom_id b) = h.

  Theorem Comma_Hom_id_unit_right {a b : Comma_Obj} (h : Comma_Hom a b) :
    Comma_Hom_compose (Comma_Hom_id a) h = h.

  Definition Comma : Category :=
    {|
      Obj := Comma_Obj;

      Hom := Comma_Hom;

      compose := @Comma_Hom_compose;

      assoc := @Comma_Hom_compose_assoc;

      assoc_sym := fun _ _ _ _ f g h => eq_sym (Comma_Hom_compose_assoc f g h);
      
      id := Comma_Hom_id;

      id_unit_right := @Comma_Hom_id_unit_right;

      id_unit_left := @Comma_Hom_id_unit_left
    |}.

End Comma.

Arguments CMO_src {_ _ _ _ _} _.
Arguments CMO_trg {_ _ _ _ _} _.
Arguments CMO_hom {_ _ _ _ _} _.
Arguments CMH_left {_ _ _ _ _ _ _} _.
Arguments CMH_right {_ _ _ _ _ _ _} _.
Arguments CMH_com {_ _ _ _ _ _ _} _.

Section Comma_Opposite_Iso.
  Context {B C D : Category} (F : (B –≻ C)%functor) (G : (D –≻ C)%functor).

  Local Hint Extern 1 => progress cbn.

  Local Hint Extern 1 => apply Comma_Hom_eq_simplify.
  
  Program Definition Comma_Opposite_Iso_LR :
    Functor ((Comma F G)^op) (Comma (G ^op) (F ^op))
    :=
      {|
        FO :=
          fun x =>
            {|
              CMO_src := CMO_trg x;
              CMO_trg := CMO_src x;
              CMO_hom := CMO_hom x
            |};
        FA :=
          fun c c' h =>
            {|
              CMH_left := CMH_right h;
              CMH_right := CMH_left h;
              CMH_com := eq_sym (CMH_com h)
            |}
      |}.

  Program Definition Comma_Opposite_Iso_RL :
    Functor (Comma (G ^op) (F ^op)) ((Comma F G)^op)
    :=
      {|
        FO :=
          fun x =>
            {|
              CMO_src := CMO_trg x;
              CMO_trg := CMO_src x;
              CMO_hom := CMO_hom x
            |};
        FA :=
          fun c c' h =>
            {|
              CMH_left := CMH_right h;
              CMH_right := CMH_left h;
              CMH_com := eq_sym (CMH_com h)
            |}
      |}.
    
  Program Definition Comma_Opposite_Iso :
    (((Comma F G)^op)%category ≃≃ Comma (G ^op) (F ^op) ::> Cat)%isomorphism
    :=
      {|
        iso_morphism := Comma_Opposite_Iso_LR;
        inverse_morphism := Comma_Opposite_Iso_RL
      |}
  .

End Comma_Opposite_Iso.

Section Comma_Left_Func_Iso.
  Context {B C D : Category}.

  Local Hint Extern 1 => progress cbn.

  Local Hint Extern 1 => apply Comma_Hom_eq_simplify.

  Section Comma_Left_Func_Iso_FC.
    Context
      {F F' : (B –≻ C)%functor}
      (I : (F ≃ F')%natiso)
      (G : (D –≻ C)%functor)
    .

    Program Definition Comma_Left_Func_Iso_FC :
      Functor (Comma F G) (Comma F' G)
      :=
        {|
          FO :=
            fun x =>
              {|
                CMO_src := CMO_src x;
                CMO_trg := CMO_trg x;
                CMO_hom := (CMO_hom x) ∘ (Trans (inverse_morphism I) (CMO_src x))
              |};
          FA :=
            fun c c' h =>
              {|
                CMH_left := CMH_left h;
                CMH_right := CMH_right h;
              CMH_com := _
              |}
        |}.
    
  End Comma_Left_Func_Iso_FC.

  Section Comma_Left_Func_Iso_FC_Iso.
    Context
      {F F' : (B –≻ C)%functor}
      (I : (F ≃ F')%natiso)
      (G : (D –≻ C)%functor)
    .

    Lemma Comma_Left_Func_Iso_FC_Iso :
      ((Comma_Left_Func_Iso_FC I G)
         ∘
         (Comma_Left_Func_Iso_FC (Inverse_Isomorphism I) G))%functor
      =
      Functor_id _
    .
    
  End Comma_Left_Func_Iso_FC_Iso.

  Context
    {F F' : (B –≻ C)%functor}
    (I : (F ≃ F')%natiso)
    (G : (D –≻ C)%functor)
  .

  Local Hint Extern 1 => apply Comma_Left_Func_Iso_FC_Iso.
  
  Program Definition Comma_Left_Func_Iso :
    ((Comma F G) ≃≃ (Comma F' G) ::> Cat)%isomorphism
    :=
      {|
        iso_morphism := Comma_Left_Func_Iso_FC I G;
        inverse_morphism := Comma_Left_Func_Iso_FC (Inverse_Isomorphism I) G
      |}
  . 
    
End Comma_Left_Func_Iso.

Section Comma_Right_Func_Iso.
  Context
    {B C D : Category}
    (F : (B –≻ C)%functor)
    {G G' : (D –≻ C)%functor}
    (I : (G ≃ G')%natiso)
  .

  Definition Comma_Right_Func_Iso :
    ((Comma F G) ≃≃ (Comma F G') ::> Cat)%isomorphism :=
    Isomorphism_Compose
      (
        Isomorphism_Compose
          (Inverse_Isomorphism (Comma_Opposite_Iso (G ^op) (F ^op)))
          (Opposite_Cat_Iso (Comma_Left_Func_Iso (Opposite_NatIso I) (F^op)))
      )
      (Comma_Opposite_Iso (G' ^op) (F ^op))
  .
    
End Comma_Right_Func_Iso.

Section Slice_CoSlice.
  Context (C : Category) (c : Obj).
  
  Definition Slice : Category := Comma (Functor_id _) (Const_Func 1 c).

  Definition CoSlice : Category := Comma (Const_Func 1 c) (Functor_id _).

End Slice_CoSlice.

Section Arrow_Cat.
  Context (C : Category).

  Definition Arrow_Cat : Category := Comma (Functor_id C) (Functor_id C).

End Arrow_Cat. *)

From Categories Require Import Coq_Cats.Type_Cat.Type_Cat Coq_Cats.Type_Cat.PullBack.
(* Categories.Coq_Cats.Type_Cat.Type_Cat:
From Categories Require Import Category.Main.
From Categories Require Import Coq_Cats.Coq_Cat.

Program Definition Type_Cat : Category := Coq_Cat Type. *)
(* Categories.Coq_Cats.Type_Cat.PullBack:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Basic_Cons.CCC Basic_Cons.PullBack.
From Categories Require Import Coq_Cats.Type_Cat.Type_Cat.

Section PullBack.
  Context {A B C : Type} (f : A → C) (g : B → C).

  Local Hint Extern 1 =>
  match goal with
    [x : sig _ |- _ ] =>
    let H := fresh "H" in
    destruct x as [x H]
  end.
  
  Program Definition Type_Cat_PullBack : @PullBack Type_Cat _ _ _ f g :=
    {|
      pullback := {x : A * B| f (fst x) = g (snd x)};
      pullback_morph_1 := fun z => (fst (proj1_sig z));
      pullback_morph_2 := fun z => (snd (proj1_sig z));
      pullback_morph_ex := fun x p1 p2 H x' => (exist _ (p1 x', p2 x') _)
    |}.

End PullBack.

Instance Type_Cat_Has_PullBacks : Has_PullBacks Type_Cat :=
  fun a b c f g => Type_Cat_PullBack f g. *)

From Categories Require Import Archetypal.Discr.Discr.
(* Categories.Archetypal.Discr.Discr:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Functor.
From Categories Require Import Cat.Cat.
From Categories Require Import Coq_Cats.Type_Cat.Type_Cat.

Definition EmptyCat : Category :=
  {|
    Obj := (Empty : Type);
    Hom := fun _ _ => (unit : Type);
    compose := fun _ _ _ _ _ => tt;
    assoc := fun _ _ _ _ _ _ _ => eq_refl;
    assoc_sym := fun _ _ _ _ _ _ _ => eq_refl;
    id := fun _ => tt;
    id_unit_left :=
      fun _ _ h =>
        match h as u return (tt = u) with
        | tt => eq_refl
        end;
    id_unit_right :=
      fun _ _ h =>
        match h as u return (tt = u) with
        | tt => eq_refl
        end
  |}.

Definition SingletonCat : Category :=
  {|
    Obj := (unit : Type);
    Hom := fun _ _ => (unit : Type);
    compose := fun _ _ _ _ _ => tt;
    assoc := fun _ _ _ _ _ _ _ => eq_refl;
    assoc_sym := fun _ _ _ _ _ _ _ => eq_refl;
    id := fun _ => tt;
    id_unit_left :=
      fun _ _ h =>
        match h as u return (tt = u) with
        | tt => eq_refl
        end;
    id_unit_right :=
      fun _ _ h =>
        match h as u return (tt = u) with
        | tt => eq_refl
        end
  |}.

Notation "0" := (EmptyCat) : category_scope.
Notation "1" := (SingletonCat) : category_scope.

Section Discr.
  Context (obj : Type).

  Program Definition Discr_Cat : Category :=
    {|
      Obj := obj;
      Hom := fun a b => a = b;
      compose := @eq_trans _;
      id := fun a => eq_refl
    |}.
    
End Discr.

Definition Type_n (n : nat) : Type := {x : nat| x < n}.

Notation "'Discr_n' n" :=
  (Discr_Cat (Type_n n)) (at level 200, n bigint) : category_scope.

Section Discr_Cat_Dual_Iso.
  Context (obj : Type).

  Local Hint Extern 1 => progress cbn.
  
  Program Definition Discr_Cat_Dual_Iso :
    (Discr_Cat obj ≃≃ (Discr_Cat obj)^op ::> Cat)%isomorphism%category
    :=
      {|
        iso_morphism := {|FO := fun x => x; FA := fun _ _ h => eq_sym h|};
        inverse_morphism := {|FO := fun x => x; FA := fun _ _ h => eq_sym h|}
      |}.

End Discr_Cat_Dual_Iso.

Section Discr_Cat_Iso.
  Context {obj obj' : Type} (I : (obj ≃≃ obj' ::> Type_Cat)%isomorphism).

  Program Definition Discr_Cat_Iso :
    ((Discr_Cat obj) ≃≃ (Discr_Cat obj') ::> Cat)%isomorphism
    :=
      {|
        iso_morphism :=
          {|
            FO := iso_morphism I;
            FA :=
              fun c d h =>
                match h in _ = y return
                      (iso_morphism I c) = (iso_morphism I y)
                with
                  eq_refl => eq_refl
                end
          |};
        inverse_morphism :=
          {|
            FO := inverse_morphism I;
            FA :=
              fun c d h =>
                match h in _ = y return
                      (inverse_morphism I c) = (inverse_morphism I y)
                with
                  eq_refl => eq_refl
                end
          |}
      |}.
  
End Discr_Cat_Iso.

Section Func_From_SingletonCat.
  Context {C : Category} (Cobj : C).

  Program Definition Func_From_SingletonCat : (SingletonCat –≻ C)%functor :=
    {|
      FO := fun _ => Cobj;
      FA := fun _ _ _ => id
    |}.

End Func_From_SingletonCat.

Section Discr_Func.
  Context {C : Category} {A : Type} (Omap : A → C).

  Program Definition Discr_Func : ((Discr_Cat A) –≻ C)%functor :=
    {|
      FO := Omap;
      
      FA := fun (a b : A) (h : a = b) =>
              match h in _ = y return ((Omap a) –≻ (Omap y))%morphism with
              | eq_refl => id
              end
    |}.

  Program Definition Discr_Func_op : ((Discr_Cat A)^op –≻ C)%functor :=
    {|
      FO := Omap;
      FA := fun (a b : A) (h : b = a) =>
              match h in _ = y return ((Omap y) –≻ (Omap b))%morphism with
              | eq_refl => id
              end
    |}.
    
End Discr_Func.
  
Arguments Discr_Func {_ _} _, _ {_} _.
Arguments Discr_Func_op {_ _} _, _ {_} _. *)

From Categories Require Import Functor.Functor_Ops Functor.Const_Func.
(* Categories.Functor.Functor_Ops:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Functor.

Section Opposite_Functor.
  Context {C D : Category} (F : (C –≻ D)%functor).
  
  Local Open Scope morphism_scope.
  Local Open Scope object_scope.
    
  Program Definition Opposite_Functor : (C^op –≻ D^op)%functor :=
    {|
      FO := F _o;
      FA := fun _ _ h => F @_a _ _ h;
      F_id := fun a => F_id F a;
      F_compose := fun _ _ _ f g => F_compose F g f
    |}.

End Opposite_Functor.

Notation "F '^op'" := (Opposite_Functor F) : functor_scope.

Section Functor_Compose.
  Context {C C' C'' : Category} (F : (C –≻ C')%functor) (F' : (C' –≻ C'')%functor).

  Local Open Scope morphism_scope.
  Local Open Scope object_scope.
  
  Program Definition Functor_compose : (C –≻ C'')%functor :=
    {|
      FO := fun c => F' _o (F _o c);
      FA := fun c d f => F' _a (F _a f)
    |}.
  
End Functor_Compose.

Notation "F ∘ G" := (Functor_compose G F) : functor_scope. 

Section Functor_Assoc.
  Context {C1 C2 C3 C4 : Category}
          (F : (C1 –≻ C2)%functor)
          (G : (C2 –≻ C3)%functor)
          (H : (C3 –≻ C4)%functor).

  Local Open Scope functor_scope.
    
  Theorem Functor_assoc : (H ∘ G) ∘ F = H ∘ (G ∘ F).

End Functor_Assoc.

Program Definition Functor_id (C : Category) : (C –≻ C)%functor :=
  {|
    FO := fun x => x;
    FA := fun c d f => f
  |}.

Section Functor_Identity_Unit.
  Context  (C C' : Category) (F : (C –≻ C')%functor).

  Theorem Functor_id_unit_left : ((Functor_id C') ∘ F)%functor = F.

  Theorem Functor_id_unit_right : (Functor_compose (Functor_id _) F) = F.

End Functor_Identity_Unit. *)
(* Categories.Functor.Const_Func:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Functor.

Section Const_Func.
  Context (C : Category) {D : Category} (a : @Obj D).

  Program Definition Const_Func : (C –≻ D)%functor :=
    {|
      FO := fun _ => a;
      FA := fun _ _ _ => id a
    |}.

End Const_Func. *)



Section CCC_Slice_A.

  Context {A : Type}.



  Local Notation CO z :=

    (

      @Build_Comma_Obj

        Type_Cat

        Type_Cat

        1

        (Functor_id Type_Cat)

        (@Const_Func 1 Type_Cat A)

        _

        tt

        z

    ) (only parsing).



  Definition Type_Cat_Slice_Prod :

    Has_Products (Slice Type_Cat A) :=

    @Has_PullBack_Slice_Has_Prod Type_Cat Type_Cat_Has_PullBacks A

  .



  Context (f g : Slice Type_Cat A).



  Definition Pre_Image {X : Type} (f : X → A) (z : A) := {y : X| f y = z}.



  Local Notation EXP :=

    (

      CO

        (

          fun m : {x : A & (Pre_Image (CMO_hom f) x) → (Pre_Image (CMO_hom g) x)}

          => projT1 m

        )

    ) (only parsing).



  Local Obligation Tactic := idtac.



  Program Definition Type_Cat_LExp :

    @Exponential (Slice Type_Cat A) Type_Cat_Slice_Prod f g :=

    {|

      exponential := EXP;

      eval :=

        @Build_Comma_Hom

          Type_Cat

          Type_Cat

          1

          (Functor_id Type_Cat)

          (@Const_Func 1 Type_Cat A)

          _

          _

          (fun w =>

             proj1_sig

               ((projT2 (fst (proj1_sig w))) (exist _ (snd (proj1_sig w)) _)))

          tt

          _

      ;

      Exp_morph_ex :=

        fun z h =>

          @Build_Comma_Hom

            Type_Cat

            Type_Cat

            1

            (Functor_id Type_Cat)

            (@Const_Func 1 Type_Cat A)

            z

            EXP

            (fun w =>

               existT

                 _

                 (CMO_hom z w)

                 (fun v => exist _ (CMH_left h (exist _ (w, proj1_sig v) _)) _)

            )

            tt

            _

    |}.



  Next Obligation.

  Proof.

    intros w.

    exact (eq_sym (proj2_sig w)).

  Qed.



  Next Obligation.

  Proof.

    extensionality w.

    destruct w as [[[x h] z] H]; cbn in *.

    match goal with

      [|- _ = CMO_hom g (proj1_sig ?A)] =>

      destruct A as [a H1]; cbn; auto

    end.

  Qed.



  Next Obligation.

  Proof.

    intros z h w v.

    symmetry.

    apply (proj2_sig v).

  Qed.



  Next Obligation.

  Proof.

    intros z h w v.

    symmetry.

    exact (equal_f

             (CMH_com h)

             (exist _ (w, proj1_sig v) (Type_Cat_LExp_obligation_3 z h w v))).

  Qed.



  Next Obligation.

  Proof.

    trivial.

  Qed.



  Next Obligation.

  Proof.

    intros z h; simpl.

    apply Comma_Hom_eq_simplify;

      [

        extensionality x |

        match goal with

          [|- ?A = ?B] =>

          destruct A; destruct B; trivial

        end

      ].

    cbn in *.

    apply f_equal.

    destruct x as [x H].

    apply sig_proof_irrelevance; trivial.

  Qed.



  Next Obligation.

  Proof.

    intros z h u u' H1 H2; simpl.

    rewrite H1 in H2; clear H1.

    apply Comma_Hom_eq_simplify;

      [extensionality x|

       match goal with

         [|- ?A = ?B] =>

         destruct A; destruct B; trivial

       end

      ].

    set (Hp1 :=

           equal_f

             (eq_trans (eq_sym (CMH_com u)) (CMH_com u'))

             x

        ); clearbody Hp1; cbn in Hp1.

    match goal with

      [|- ?A = ?B] =>

      cut (match Hp1 in _ = y return

                 Pre_Image (CMO_hom f) y → Pre_Image (CMO_hom g) y

           with

             eq_refl => projT2 A

           end = projT2 B

          );

        [intros Hp2; destruct A as [za Fa]; destruct B as [zb Fb]|]

    end.

    {

      cbn in Hp1, Hp2.

      destruct Hp1; destruct Hp2; trivial.

    }

    {

      extensionality v.

      transitivity

        (match Hp1 in _ = y return

               Pre_Image (CMO_hom g) y

         with

           eq_refl =>

           projT2

             (CMH_left u x)

             (match eq_sym Hp1 in _ = y return

                    Pre_Image (CMO_hom f) y

              with

                eq_refl => v

              end)

         end

        ).

      {

        destruct Hp1; trivial.

      }

      set (M :=

             exist

               (fun w => CMO_hom z (fst w) = CMO_hom f (snd w))

               (x, proj1_sig v)

               (eq_trans

                  (equal_f (CMH_com u') x)

                  (eq_sym (proj2_sig v))

               )

          ).

      set (H2' := (equal_f (f_equal CMH_left H2) M));clearbody H2'; clear H2.

      cbn in H2'.

      match type of H2' with

        proj1_sig (projT2 (CMH_left u x) ?w) =

        proj1_sig (projT2 (CMH_left u' x) ?w') =>

        cutrewrite

          (w =

           (

             match eq_sym Hp1 in _ = y return

                   Pre_Image (CMO_hom f) y

             with

               eq_refl => v

             end

           )

          ) in H2'; [cutrewrite (w' = v) in H2' |]

      end.

      {

        apply sig_proof_irrelevance.

        etransitivity; [|apply H2'].

        generalize (

            (

              match eq_sym Hp1 in (_ = y) return

                    (Pre_Image (CMO_hom f) y)

              with

                eq_refl => v

              end

            )

          ) as p.

        intros p.

        clear.

        destruct Hp1.

        trivial.

      }

      {

        clear.

        apply sig_proof_irrelevance; trivial.

      }

      {

        clear.

        apply sig_proof_irrelevance; cbn.

        destruct (eq_sym Hp1); trivial.

      }

    }

  Qed.



End CCC_Slice_A.



Instance Type_Cat_LCCC : LCCC Type_Cat :=

  fun A =>

    {|

      CCC_term := Slice_Terminal Type_Cat A;

      CCC_HP := Type_Cat_Slice_Prod;

      CCC_HEXP := Type_Cat_LExp

    |}.

