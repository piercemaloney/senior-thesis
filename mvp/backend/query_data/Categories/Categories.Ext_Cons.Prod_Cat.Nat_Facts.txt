From Categories Require Import Essentials.Notations.
(* Categories.Essentials.Notations:
Notation "∀ x .. y , P" := (forall x, .. (forall y, P) ..)
                             (at level 200, x binder, y binder, right associativity) : type_scope.

Notation "∃ x .. y , P" := (exists x, .. (exists y, P) ..)
  (at level 200, x binder, y binder, right associativity) : type_scope.

Notation "x ∨ y" := (x \/ y) (at level 85, right associativity) : type_scope.

Notation "x ∧ y" := (x /\ y) (at level 80, right associativity) : type_scope.

Notation "x → y" := (x -> y)
  (at level 90, y at level 200, right associativity): type_scope.

Notation "x ↔ y" := (x <-> y) (at level 95, no associativity): type_scope.

Notation "¬ x" := (~x) (at level 75, right associativity) : type_scope.

Notation "x ≠ y" := (x <> y) (at level 70) : type_scope.

Notation "x ≤ y" := (le x y) (at level 70, no associativity).

Notation "x ≥ y" := (ge x y) (at level 70, no associativity).

Reserved Notation "C '^op'" (at level 50, no associativity).

Reserved Notation "a –≻ b" (at level 90, b at level 200, right associativity).

Reserved Notation "f '⁻¹'" (at level 50, no associativity).

Reserved Notation "a ≃ b" (at level 70, no associativity).

Reserved Notation "a ≃≃ b ::> C" (at level 70, no associativity).

Reserved Notation "f ∘ g" (at level 51, right associativity).

Reserved Notation "f '∘_h' g" (at level 51, right associativity).

Reserved Notation "a ≫–> b" (at level 100, no associativity).

Reserved Notation "a –≫ b" (at level 100, no associativity).

Reserved Notation "F '_o'" (at level 50, no associativity).

Reserved Notation "F '_a'" (at level 50, no associativity).

Reserved Notation "F '@_a'" (at level 50, no associativity).

Reserved Notation "F ⊣ G" (at level 100, no associativity).

Reserved Notation "F ⊣_hom G" (at level 100, no associativity).

Reserved Notation "F ⊣_ucu G" (at level 100, no associativity).

Reserved Notation "a × b" (at level 80, no associativity).

Reserved Notation "a ⇑ b" (at level 79, no associativity).

Reserved Notation "'Π' m" (at level 50, no associativity).

Reserved Notation "'Σ' m" (at level 50, no associativity).

Reserved Notation "'Π_' C ↓ m" (at level 50, no associativity).

Reserved Notation "'Σ_' C ↓ m" (at level 50, no associativity).

Delimit Scope category_scope with category.

Delimit Scope morphism_scope with morphism.

Delimit Scope object_scope with object.

Delimit Scope functor_scope with functor.

Delimit Scope nattrans_scope with nattrans.

Delimit Scope nattrans_scope with nattrans.

Delimit Scope natiso_scope with natiso.

Delimit Scope isomorphism_scope with isomorphism.

Delimit Scope preorder_scope with preorder. *)

From Categories Require Import Essentials.Types.
(* Categories.Essentials.Types:
Global Set Primitive Projections.

Global Set Universe Polymorphism.

Global Unset Universe Minimization ToSet.

Inductive Empty : Type :=.

Hint Extern 1 =>
let tac := (repeat intros ?); match goal with [H : Empty |- _] => contradict H end in
match goal with
  | [|- context[Empty]] => tac
  | [H : context[Empty] |- _] => tac
end
.

Record prod (A B : Type) := {fst : A; snd : B}.

Arguments fst {_ _ } _.
Arguments snd {_ _ } _.
Arguments Build_prod {_ _ } _ _.

Notation "( X , Y )" := (Build_prod X Y).
Notation "X * Y" := (prod X Y) : type_scope. *)

From Categories Require Import Essentials.Facts_Tactics.
(* Categories.Essentials.Facts_Tactics:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.

Require Export Coq.Program.Tactics.
Require Export Coq.Program.Equality.
Require Export Coq.Logic.FunctionalExtensionality.
Require Export Coq.Logic.ProofIrrelevance.

Definition equal_f : ∀ {A B : Type} {f g : A → B}, f = g → ∀ x : A, f x = g x.

Definition f_equal : ∀ (A B : Type) (f : A → B) (x y : A), x = y → f x = f y.

Arguments f_equal [_ _] _ [_ _] _.

Ltac basic_simpl :=
  let simpl_prod _ :=
      match goal with
        [H : prod _ _ |- _] =>
        let H1 := fresh H "1" in
        let H2 := fresh H "2" in
        destruct H as [H1 H2]
      end
  in
  let simpl_sig _ :=
      match goal with
        [H : @sig _ _ |- _] =>
        let H1 := fresh H "1" in
        let H2 := fresh H "2" in
        destruct H as [H1 H2]
      end
  in
  let basic_simpl_helper _ :=
      cbn in *; intros;
        repeat simpl_prod tt;
        repeat simpl_sig tt
  in
  repeat basic_simpl_helper tt
.

Global Obligation Tactic := basic_simpl; auto.

Ltac PIR :=
  let pir_helper _ :=
      match goal with
      |[H : ?A, H' : ?A|- _] =>
       match type of A with
       | Prop =>
         destruct (proof_irrelevance _ H H')
       end
      end
  in
  repeat pir_helper tt
.

Ltac ElimEq := repeat match goal with [H : _ = _|- _] => destruct H end.

Hint Extern 1 => progress ElimEq.

Ltac cbn_rewrite W :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite H; clear H
.

Ltac cbn_rewrite_in W V :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite H in V; clear H
.

Ltac cbn_rewrite_back W :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite <- H; clear H
.

Ltac cbn_rewrite_back_in W V :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite <- H in V; clear H
.

Tactic Notation "cbn_rewrite" constr(W) := cbn_rewrite W.
Tactic Notation "cbn_rewrite" constr(W) "in" hyp_list(V) := cbn_rewrite_in W V.
Tactic Notation "cbn_rewrite" "<-" constr(W) := cbn_rewrite_back W.
Tactic Notation "cbn_rewrite" "<-" constr(W) "in" hyp_list(V) := cbn_rewrite_back_in W V.

Lemma sig_proof_irrelevance {A : Type} (P : A → Prop) (X Y : sig P) : proj1_sig X = proj1_sig Y → X = Y.

Hint Extern 2 (exist ?A _ _ = exist ?A _ _) => apply sig_proof_irrelevance.

Ltac FunExt :=
progress (
    repeat (
        match goal with
          [|- _ = _] =>
          let x := fresh "x" in
          extensionality x
        end
      )
  )
.

Hint Extern 1 => FunExt.

Lemma pair_eq (A B : Type) (a b : A * B) : fst a = fst b → snd a = snd b → a = b.

Hint Resolve pair_eq.

Ltac revert_clearbody_all :=
 repeat lazymatch goal with H:_ |- _ => try clearbody H; revert H end.

Ltac hyp_stack :=
 constr:(ltac:(revert_clearbody_all;constructor) : True).

Ltac next_hyp hs step last :=
 lazymatch hs with (?hs' ?H) => step H hs' | _ => last end.

Tactic Notation "dohyps" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := tac H; next_hyp hs step idtac in
 next_hyp hs step idtac.

Tactic Notation "dohyps" "reverse" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := next_hyp hs step idtac; tac H in
 next_hyp hs step idtac.

Tactic Notation "do1hyp" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := tac H + next_hyp hs step fail in
 next_hyp hs step fail.

Tactic Notation "do1hyp" "reverse" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := next_hyp hs step fail + tac H in
 next_hyp hs step fail. *)

From Categories Require Import Category.Main.
(* Categories.Category.Main:
From Categories Require Export Category.Category.
From Categories Require Export Category.Morph.
From Categories Require Export Category.Opposite.
From Categories Require Export Category.SubCategory.
From Categories Require Export Category.Composable_Chain. *)

From Categories Require Import Functor.Main.
(* Categories.Functor.Main:
From Categories Require Export Functor.Functor.
From Categories Require Export Functor.Functor_Extender.
From Categories Require Export Functor.Functor_Image.
From Categories Require Export Functor.Functor_Ops.
From Categories Require Export Functor.Functor_Properties.
From Categories Require Export Functor.Const_Func.
From Categories Require Export Functor.Const_Func_Functor. *)

From Categories Require Import Cat.Cat.
(* Categories.Cat.Cat:
From Categories Require Import Category.Main.
From Categories Require Import Functor.Functor Functor.Functor_Ops.

Local Open Scope functor_scope.

Definition Cat : Category :=
{|
  Obj := Category;

  Hom := Functor;

  compose := fun C D E => Functor_compose;
  
  assoc := fun C D E F (G : C –≻ D) (H : D –≻ E) (I : E –≻ F) =>
            @Functor_assoc _ _ _ _ G H I;

  assoc_sym := fun C D E F (G : C –≻ D) (H : D –≻ E) (I : E –≻ F) =>
            eq_sym (@Functor_assoc _ _ _ _ G H I);

  id := fun C => Functor_id C;

  id_unit_left := fun C D => @Functor_id_unit_left C D;

  id_unit_right := fun C D => @Functor_id_unit_right C D          
|}. *)

From Categories Require Import Ext_Cons.Prod_Cat.Prod_Cat Ext_Cons.Prod_Cat.Operations.
(* Categories.Ext_Cons.Prod_Cat.Prod_Cat:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Main.
From Categories Require Import Cat.Cat.

Local Open Scope morphism_scope.

Local Obligation Tactic := idtac.

Program Definition Prod_Cat (C C' : Category) : Category :=
{|
  Obj := C * C';
              
  Hom :=
    fun a b =>
      (((fst a) –≻ (fst b)) * ((snd a) –≻ (snd b)))%type;

  compose :=
    fun a b c f g =>
      (((fst g) ∘ (fst f)), ((snd g) ∘ (snd f)))%morphism;

  id := fun c => (id, id)
|}.

Notation "C × D" := (Prod_Cat C D) : category_scope.

Local Obligation Tactic := basic_simpl; auto.

Theorem Prod_compose_id
        (C D : Category)
        (a b c : C) (d : D)
        (f : a –≻ b) (g : b –≻ c)
  : (g ∘ f, id d)%morphism =
    @compose (_ × _) (_, _) (_, _) (_, _) (f, id d) (g, id d).

Theorem Prod_id_compose
        (C D : Category)
        (a : C) (b c d : D)
        (f : b –≻ c) (g : c –≻ d)
  : (id a, g ∘ f)%morphism =
    @compose (_ × _) (_, _) (_, _) (_, _) (id a, f) (id a, g).

Theorem Prod_cross_compose
        (C D : Category)
        (a b : C) (c d : D)
        (f : a –≻ b) (g : c –≻ d)
  : @compose
      (_ × _) (_, _) (_, _) (_, _)
      (@id _ a, g) (f, @id _ d)
    = @compose
        (_ × _) (_, _) (_, _) (_, _)
        (f, @id _ c) (@id _ b, g)
.

Program Definition Cat_Proj1
        (C C' : Category) :
  ((C × C') –≻ C)%functor
  :=
    {|FO := fst; FA := fun _ _ f => fst f|}
.

Program Definition Cat_Proj2
        (C C' : Category) :
  ((C × C') –≻ C')%functor
  :=
    {|FO := snd; FA := fun _ _ f => snd f|}
. *)
(* Categories.Ext_Cons.Prod_Cat.Operations:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Main.
From Categories Require Import Cat.Cat.
From Categories Require Import Ext_Cons.Prod_Cat.Prod_Cat.

Local Obligation Tactic := idtac.

Local Open Scope functor_scope.

Program Definition Prod_Functor
        {C1 C2 C1' C2' : Category} (F : C1 –≻ C2) (F' : C1' –≻ C2')
  : (C1 × C1') –≻ (C2 × C2') :=
{|
  FO := fun a => (F _o (fst a), F' _o (snd a))%object;
  FA := fun _ _ f => (F _a (fst f), F' _a (snd f))%morphism
|}.

Definition Bi_Func_1 {Cx C1 C1' Cy : Category} (F : Cx –≻ C1)
           (F' : (C1 × C1') –≻ Cy)
  : (Cx × C1') –≻ Cy :=
  F' ∘ (Prod_Functor F (@Functor_id C1')).

Definition Bi_Func_2 {Cx C1 C1' Cy : Category} (F : Cx –≻ C1')
           (F' : (C1 × C1') –≻ Cy) : (C1 × Cx) –≻ Cy :=
  Functor_compose (Prod_Functor (@Functor_id C1) F) F'.

Local Hint Extern 2 => cbn.

Local Obligation Tactic := basic_simpl; do 2 auto.

Program Definition Fix_Bi_Func_1 {C1 C1' Cy : Category} (x : C1)
        (F : (C1 × C1') –≻ Cy)
  : C1' –≻ Cy :=
{|
  FO := fun a => (F _o (x, a))%object;
  FA := fun _ _ f => (F @_a (_, _) (_, _) (@id _ x, f))%morphism
|}.

Program Definition Fix_Bi_Func_2 {C1 C1' Cy : Category} (x : C1')
        (F : (C1 × C1') –≻ Cy)
  : C1 –≻ Cy :=
{|
  FO := fun a => (F _o (a, x))%object;
  FA := fun _ _ f => (F @_a (_, _) (_, _) (f, @id _ x))%morphism
|}.

Program Definition Diag_Func (C : Category) : C –≻ (C × C) :=
{|
  FO := fun a => (a, a);
  FA := fun _ _ f => (f, f);
  F_id := fun _ => eq_refl;
  F_compose := fun _ _ _ _ _ => eq_refl
|}.

Theorem Prod_Functor_Cat_Proj {C D D' : Category} (F : C –≻ (D × D')) :
  ((Prod_Functor ((Cat_Proj1 _ _) ∘ F) ((Cat_Proj2 _ _) ∘ F))
     ∘ (Diag_Func C))%functor = F.

Program Definition Twist_Func (C C' : Category) : (C × C') –≻ (C' × C) :=
{|
  FO := fun a => (snd a, fst a);
  FA := fun _ _ f => (snd f, fst f);
  F_id := fun _ => eq_refl;
  F_compose := fun _ _ _ _ _ => eq_refl
|}.

Section Twist_Prod_Func_Twist.
  Context {C C' : Category} (F : C –≻ C') {D D' : Category} (G : D –≻ D').

  Theorem Twist_Prod_Func_Twist :
    (((Twist_Func _ _) ∘ (Prod_Functor F G)) ∘ (Twist_Func _ _))%functor =
    Prod_Functor G F.

End Twist_Prod_Func_Twist.

Section Prod_Functor_compose.
  Context {C D E: Category} (F : C –≻ D) (G : D –≻ E)
          {C' D' E': Category} (F' : C' –≻ D') (G' : D' –≻ E').

  Theorem Prod_Functor_compose :
    ((Prod_Functor G G') ∘ (Prod_Functor F F') =
     Prod_Functor (G ∘ F) (G' ∘ F'))%functor.
                                   
End Prod_Functor_compose. *)

From Categories Require Import NatTrans.NatTrans NatTrans.Operations NatTrans.Func_Cat
(* Categories.NatTrans.NatTrans:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Functor.
From Categories Require Import Cat.Cat.

Section NatTrans.
  Context {C C' : Category}.

  Record NatTrans (F F' : (C –≻ C')%functor) :=
    {
      Trans (c : C) : ((F _o c) –≻ (F' _o c))%object%morphism;
      Trans_com {c c' : C} (h : (c –≻ c')%morphism) :
        ((Trans c') ∘ F _a h = F' _a h ∘ (Trans c))%morphism;
      Trans_com_sym {c c' : C} (h : (c –≻ c')%morphism) :
        (F' _a h ∘ (Trans c) = (Trans c') ∘ F _a h)%morphism
    }.

  Notation "F –≻ F'" := (NatTrans F F') : nattrans_scope.

  Lemma NatTrans_eq_simplify {F F' : (C –≻ C')%functor}
        (N N' : (F –≻ F')%nattrans) : (@Trans _ _ N) = (@Trans _ _ N') -> N = N'.

End NatTrans.

Arguments Trans {_ _ _ _} _ _.
Arguments Trans_com {_ _ _ _} _ {_ _} _.
Arguments Trans_com_sym {_ _ _ _} _ {_ _} _.

Bind Scope nattrans_scope with NatTrans.

Notation "F –≻ F'" := (NatTrans F F') : nattrans_scope.

Local Open Scope nattrans_scope.

Section NatTrans_Compose.
  Context {C C' : Category}.
  
  Program Definition NatTrans_compose {F F' F'' : (C –≻ C')%functor}
          (tr : F –≻ F') (tr' : F' –≻ F'') : (F –≻ F'')%nattrans :=
    {|
      Trans := fun c : Obj => ((Trans tr' c) ∘ (Trans tr c)) % morphism
    |}.

End NatTrans_Compose.

Notation "N ∘ N'" := (NatTrans_compose N' N) : nattrans_scope.

Section NatTrans_Props.
  Context {C C' : Category}.
  
  Theorem NatTrans_compose_assoc {F G H I : (C –≻ C')%functor} (N : F –≻ G)
          (N' : G –≻ H) (N'' : H –≻ I)
    : ((N'' ∘ N') ∘ N = N'' ∘ (N' ∘ N))%nattrans
  .

  Program Definition NatTrans_id (F : (C –≻ C')%functor) : F –≻ F :=
    {|
      Trans := fun x : Obj => id
    |}.

  Theorem NatTrans_id_unit_left {F G : (C –≻ C')%functor} (N : F –≻ G)
    : (NatTrans_id G) ∘ N = N.

  Theorem NatTrans_id_unit_right {F G : (C –≻ C')%functor} (N : F –≻ G)
    : N ∘ (NatTrans_id F) = N.
  
End NatTrans_Props.

Hint Resolve NatTrans_eq_simplify. *)
(* Categories.NatTrans.Operations:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Functor Functor.Functor_Ops.
From Categories Require Import Cat.Cat.
From Categories Require Import NatTrans.NatTrans.

Local Open Scope nattrans_scope.

Section Opposite_NatTrans.
  Context {C D : Category} {F F' : (C –≻ D)%functor} (N : (F –≻ F')%nattrans).

  Program Definition Opposite_NatTrans : F'^op –≻ F^op :=
    {|
      Trans := Trans N;
      Trans_com := fun c c' h => (Trans_com_sym N h);
      Trans_com_sym := fun c c' h => (Trans_com N h)
    |}.
  
End Opposite_NatTrans.

Notation "N '^op'" := (Opposite_NatTrans N) : nattrans_scope.

Section Compose_NOP.
  Context {C D : Category} {F F' F'' : (C –≻ D)%functor}
          (N : F –≻ F') (N' : F' –≻ F'').

  Theorem NatTrans_compose_Op : ((N' ∘ N)^op = N^op ∘ (N'^op))%nattrans.

End Compose_NOP.

Section NatTrans_id_Op.
  Context {C D : Category} (F : (C –≻ D)%functor).

  Theorem NatTrans_id_Op
    : ((NatTrans_id F)^op)%nattrans = NatTrans_id (F^op)%functor.

End NatTrans_id_Op.

Program Definition NatTrans_hor_comp {C D E : Category} {F G : (C –≻ D)%functor}
        {F' G' : (D –≻ E)%functor} (tr : F –≻ G) (tr' : F' –≻ G')
  : (F' ∘ F) –≻ (G' ∘ G) :=
{|
  Trans := fun c : Obj => ((G' _a (Trans tr c)) ∘ (Trans tr' (F _o c)))%morphism
|}.

Notation "N ∘_h N'" := (NatTrans_hor_comp N' N) : nattrans_scope.

Section Hor_Compose_ids.
  Context {C D E : Category} (F : (C –≻ D)%functor) (G : (D –≻ E)%functor).

  Theorem NatTrans_hor_comp_ids
    : ((NatTrans_id G) ∘_h (NatTrans_id F))%nattrans = NatTrans_id  (G ∘ F).

End Hor_Compose_ids.

Section Hor_Compose_NOP.
  Context {C D E : Category} {F G : (C –≻ D)%functor} {F' G' : (D –≻ E)%functor}
          (N : F –≻ G) (N' : F' –≻ G').
  
  Theorem NatTrans_hor_comp_Op : ((N' ∘_h N)^op = N'^op ∘_h N^op)%nattrans.

End Hor_Compose_NOP.

Section NatTransCompID.
  Context {C D : Category} (F : (C –≻ D)%functor).
  
  Program Definition NatTrans_to_compose_id : F –≻ ((Functor_id D) ∘ F) :=
    {|
      Trans := fun c => id
    |}.

  Program Definition NatTrans_from_compose_id : ((Functor_id _) ∘ F) –≻ F :=
    {|
      Trans := fun c => id
    |}.

  Program Definition NatTrans_to_id_compose : F –≻ (F ∘ (Functor_id _)) :=
    {|
      Trans := fun c => id
    |}.

  Program Definition NatTrans_from_id_compose : (F ∘ (Functor_id _)) –≻ F :=
    {|
      Trans := fun c => id
    |}.

End NatTransCompID.

Section NatTransAssoc.
  Context {C1 C2 C3 C4 : Category}
          (F : (C1 –≻ C2)%functor)
          (G : (C2 –≻ C3)%functor)
          (H : (C3 –≻ C4)%functor)
  .
  
  Program Definition NatTrans_Functor_assoc
    : ((H ∘ G) ∘ F) –≻ (H ∘ (G ∘ F)) :=
    {|
      Trans := fun c => id
    |}.

  Program Definition NatTrans_Functor_assoc_sym
    : (H ∘ (G ∘ F)) –≻ ((H ∘ G) ∘ F) :=
    {|
      Trans := fun c => id
    |}.

End NatTransAssoc.

Section NatTrans_comp_hor_comp.
  Context {C D E  : Category}
          {F F' F'' : (C –≻ D)%functor}
          {G G' G'' : (D –≻ E)%functor}
          (N1 : F –≻ F')
          (N2 : G –≻ G')
          (N3 : F' –≻ F'')
          (N4 : G' –≻ G'')
  .

  Theorem NatTrans_comp_hor_comp
    : ((N4 ∘_h N3) ∘ (N2 ∘_h N1) = (N4 ∘ N2) ∘_h (N3 ∘ N1))%nattrans.

End NatTrans_comp_hor_comp.

Section IsoCat_NatTrans.
  Context {C D : Category} (I : (C ≃≃ D ::> Cat)%isomorphism)
          {E : Category} (F : (D –≻ E)%functor).

  Local Obligation Tactic := idtac.
  
  Program Definition IsoCat_NatTrans :
    (F ∘ ((iso_morphism I) ∘ (I⁻¹)%morphism)) –≻ F
    :=
      {|
        Trans :=
          fun c =>
            match eq_sym (f_equal (fun x => (x _o)%object c) (right_inverse I))
                  in _ = y return ((F _o y) –≻ (F _o c))%object%morphism
            with
              eq_refl => id
            end
      |}
  .

  Program Definition IsoCat_NatTrans_back :
    F –≻ (F ∘ ((iso_morphism I) ∘ (I⁻¹)%morphism))
    :=
      {|
        Trans :=
          fun c =>
            match eq_sym (f_equal (fun x => (x _o)%object c) (right_inverse I))
                  in _ = y return ((F _o c) –≻ (F _o y))%object%morphism
            with
              eq_refl => id
            end
      |}
  .

End IsoCat_NatTrans. *)
(* Categories.NatTrans.Func_Cat:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Functor Functor.Functor_Ops.
From Categories Require Import Cat.Cat.
From Categories Require Import NatTrans.NatTrans NatTrans.Operations.

Program Definition Func_Cat (C C' : Category) : Category :=
{|
  Obj := (C –≻ C')%functor;

  Hom := NatTrans;

  compose := @NatTrans_compose _ _;

  id := @NatTrans_id _ _;

  assoc := fun _ _ _ _ _ _ _ => @NatTrans_compose_assoc _ _ _ _ _ _ _ _ _;
             
  assoc_sym :=
    fun _ _ _ _ _ _ _ => eq_sym (@NatTrans_compose_assoc _ _ _ _ _ _ _ _ _);

  id_unit_right := @NatTrans_id_unit_right _ _;
  
  id_unit_left := @NatTrans_id_unit_left _ _
|}.

Section Opposite_Func_Cat.
  Context (C D : Category).

  Program Definition Op_Func_Cat_to_Func_Cat_Op
    : ((Func_Cat C D)^op –≻ (Func_Cat (C^op) (D^op)))%functor :=
    {|
      FO := Opposite_Functor;
      FA := fun _ _ => Opposite_NatTrans;
      F_id := fun _ => NatTrans_id_Op _;
      F_compose := fun _ _ _ _ _ => NatTrans_compose_Op _ _ 
    |}.

  Program Definition Func_Cat_Op_to_Op_Func_Cat
    : ((Func_Cat (C^op) (D^op)) –≻ (Func_Cat C D)^op)%functor :=
    {|
      FO := Opposite_Functor;
      FA := fun _ _ => Opposite_NatTrans;
      F_id := fun F => NatTrans_id_Op F;
      F_compose := fun _ _ _ N N' => NatTrans_compose_Op N N'
    |}.
  
  Program Definition Func_Cat_Op_Iso
    : ((((Func_Cat C D)^op)%category)
         ≃≃ (Func_Cat (C^op) (D^op)) ::> Cat) %isomorphism :=
    {|
      iso_morphism := Op_Func_Cat_to_Func_Cat_Op;
      inverse_morphism := Func_Cat_Op_to_Op_Func_Cat
    |}.

End Opposite_Func_Cat. *)

        NatTrans.NatIso.



Local Obligation Tactic := idtac.



Section Prod_Functor_NatTrans.

  Context {C D : Category}

          {F G : (C –≻ D)%functor}

          (N : (F –≻ G)%nattrans)

          {C' D' : Category}

          {F' G' : (C' –≻ D')%functor}

          (N' : (F' –≻ G')%nattrans).



  Program Definition Prod_Functor_NatTrans :

    ((Prod_Functor F F') –≻ (Prod_Functor G G'))%nattrans :=

    {|

      Trans := fun c => (Trans N (fst c), Trans N' (snd c))

    |}.



  Next Obligation.

    basic_simpl.

    do 2 rewrite Trans_com; trivial.

  Qed.



  Next Obligation.

    symmetry.

    apply Prod_Functor_NatTrans_obligation_1.

  Qed.



End Prod_Functor_NatTrans.



Section Prod_Functor_NatTrans_id.

  Context {C D : Category} (F : (C –≻ D)%functor)

          {C' D' : Category} {F' : (C' –≻ D')%functor}.



  Theorem Prod_Functor_NatTrans_id :

    Prod_Functor_NatTrans (NatTrans_id F) (NatTrans_id F') =

    NatTrans_id (Prod_Functor F F').

  Proof.

    apply NatTrans_eq_simplify; trivial.

  Qed.    



End Prod_Functor_NatTrans_id.



Section Prod_Functor_NatTrans_compose.

  Context {C D : Category}

          {F G H : (C –≻ D)%functor}

          (N1 : (F –≻ G)%nattrans)

          (N2 : (G –≻ H)%nattrans)

          {C' D' : Category}

          {F' G' H' : (C' –≻ D')%functor}

          (N1' : (F' –≻ G')%nattrans)

          (N2' : (G' –≻ H')%nattrans).



  Theorem Prod_Functor_NatTrans_compose :

    ((Prod_Functor_NatTrans N2 N2') ∘ (Prod_Functor_NatTrans N1 N1') =

     Prod_Functor_NatTrans (N2 ∘ N1) (N2' ∘ N1'))%nattrans.

  Proof.

    apply NatTrans_eq_simplify; trivial.

  Qed.



End Prod_Functor_NatTrans_compose.



Section Prod_Functor_NatIso.

  Context {C D : Category}

          {F G : (C –≻ D)%functor}

          (N : (F ≃ G)%natiso)

          {C' D' : Category}

          {F' G' : (C' –≻ D')%functor}

          (N' : (F' ≃ G')%natiso)

  .



  Program Definition Prod_Functor_NatIso :

    ((Prod_Functor F F') ≃ (Prod_Functor G G'))%natiso :=

    {|

      iso_morphism := Prod_Functor_NatTrans (iso_morphism N) (iso_morphism N');

      inverse_morphism :=

        Prod_Functor_NatTrans (inverse_morphism N) (inverse_morphism N')

    |}.



  Next Obligation.

    cbn.

    rewrite Prod_Functor_NatTrans_compose.

    change ((N ⁻¹)%morphism ∘ (iso_morphism N))%nattrans with (N⁻¹ ∘ N)%morphism.

    change ((N' ⁻¹)%morphism ∘ (iso_morphism N'))%nattrans with (N'⁻¹ ∘ N')%morphism.

    do 2 rewrite (left_inverse).

    apply Prod_Functor_NatTrans_id.

  Qed.



  Next Obligation.

    cbn.

    rewrite Prod_Functor_NatTrans_compose.

    change ((iso_morphism N) ∘ (N ⁻¹)%morphism)%nattrans with (N ∘ N⁻¹)%morphism.

    change ((iso_morphism N') ∘ (N' ⁻¹)%morphism)%nattrans with (N' ∘ N'⁻¹)%morphism.

    do 2 rewrite (right_inverse).

    apply Prod_Functor_NatTrans_id.

  Qed.



End Prod_Functor_NatIso.



Section Fix_Bi_Func_1_NatTrans.

  Context {B C D E : Category}

          {F F' : (((Func_Cat C D) × B) –≻ E)%functor}

          (N : (F –≻ F')%nattrans)

          (G : (C –≻ D)%functor)

  .



  Program Definition Fix_Bi_Func_1_NatTrans :

    ((@Fix_Bi_Func_1 (Func_Cat _ _) _ _ G F) –≻ (@Fix_Bi_Func_1 (Func_Cat _ _) _ _ G F'))%nattrans

    :=

    {|

      Trans := fun c => Trans N (G, c)

    |}.



  Next Obligation.

  Proof.

    intros c c' h.

    apply (@Trans_com _ _ _ _ N (G, c) (G, c') (NatTrans_id _, h)).

  Qed.



  Next Obligation.

  Proof.

    intros c c' h.

    apply (@Trans_com_sym _ _ _ _ N (G, c) (G, c') (NatTrans_id _, h)).

  Qed.



End Fix_Bi_Func_1_NatTrans.



Section Fix_Bi_Func_1_NatIso.

  Context {B C D E : Category}

          {F F' : (((Func_Cat C D) × B) –≻ E)%functor}

          (N : (F ≃ F')%natiso)

          (G : (C –≻ D)%functor)

  .



  Program Definition Fix_Bi_Func_1_NatIso :

    ((@Fix_Bi_Func_1 (Func_Cat _ _) _ _ G F)

       ≃ (@Fix_Bi_Func_1 (Func_Cat _ _) _ _ G F'))%natiso

    :=

    {|

      iso_morphism := Fix_Bi_Func_1_NatTrans (iso_morphism N) G;

      inverse_morphism := Fix_Bi_Func_1_NatTrans (inverse_morphism N) G

    |}.



  Next Obligation.

  Proof.

    apply NatTrans_eq_simplify; extensionality c.

    cbn.

    change (Trans (inverse_morphism N) (G, c) ∘ Trans (iso_morphism N) (G, c))%morphism with (Trans ((inverse_morphism N) ∘ (iso_morphism N)) (G, c)).

    cbn_rewrite (left_inverse N); trivial.

  Qed.



  Next Obligation.

  Proof.

    apply NatTrans_eq_simplify; extensionality c; cbn.

    change (Trans (iso_morphism N) (G, c) ∘ Trans (inverse_morphism N) (G, c))%morphism with (Trans ((iso_morphism N) ∘ (inverse_morphism N)) (G, c)).

    cbn_rewrite (right_inverse N); trivial.

  Qed.



End Fix_Bi_Func_1_NatIso.



Section Fix_Bi_Func_2_NatTrans.

  Context {B C D E : Category}

          {F F' : ((B × (Func_Cat C D)) –≻ E)%functor}

          (N : (F –≻ F')%nattrans)

          (G : (C –≻ D)%functor)

  .



  Program Definition Fix_Bi_Func_2_NatTrans :

    ((@Fix_Bi_Func_2 _ (Func_Cat _ _) _ G F) –≻ (@Fix_Bi_Func_2 _ (Func_Cat _ _) _ G F'))%nattrans

    :=

    {|

      Trans := fun c => Trans N (c, G)

    |}.



  Next Obligation.

  Proof.

    intros; apply (@Trans_com _ _ _ _ N).

  Qed.



  Next Obligation.

  Proof.

    intros; apply (@Trans_com_sym _ _ _ _ N).

  Qed.



End Fix_Bi_Func_2_NatTrans.



Section Fix_Bi_Func_2_NatIso.

  Context {B C D E : Category}

          {F F' : ((B × (Func_Cat C D)) –≻ E)%functor}

          (N : (F ≃ F')%natiso)

          (G : (C –≻ D)%functor)

  .



  Program Definition Fix_Bi_Func_2_NatIso :

    (

      (@Fix_Bi_Func_2 _ (Func_Cat _ _) _ G F)

        ≃ (@Fix_Bi_Func_2 _ (Func_Cat _ _) _ G F'))%natiso

    :=

      {|

        iso_morphism := Fix_Bi_Func_2_NatTrans (iso_morphism N) G;

        inverse_morphism := Fix_Bi_Func_2_NatTrans (inverse_morphism N) G

      |}

  .

  

  Next Obligation.

  Proof.

    apply NatTrans_eq_simplify; extensionality c.

    cbn.

    change (Trans (inverse_morphism N) (c, G) ∘

                  Trans (iso_morphism N) (c, G))%morphism

    with (Trans ((inverse_morphism N) ∘ (iso_morphism N)) (c, G)).

    cbn_rewrite (left_inverse N); trivial.

  Qed.



  Next Obligation.

  Proof.

    apply NatTrans_eq_simplify; extensionality c.

    cbn.

    change (Trans (iso_morphism N) (c, G) ∘

                  Trans (inverse_morphism N) (c, G))%morphism

    with (Trans ((iso_morphism N) ∘ (inverse_morphism N)) (c, G)).

    cbn_rewrite (right_inverse N); trivial.

  Qed.



End Fix_Bi_Func_2_NatIso.



Section Fix_Bi_Func_1_Functor_id_swap_NatIso.

  Context {B B' C D E E' : Category}

          (F : (B –≻ B')%functor)

          (F' : (((Func_Cat C D) × B') –≻ E)%functor)

          (G : (C –≻ D)%functor)

  .



  Local Obligation Tactic := cbn; auto.



  Local Hint Extern 1 => apply NatTrans_eq_simplify; cbn.

  

  Program Definition Fix_Bi_Func_1_Functor_id_swap_NatIso :

    (

      (@Fix_Bi_Func_1 (Func_Cat _ _) _ _ G

                      ( F' ∘ (Prod_Functor (Functor_id _) F)))%functor

        ≃ ((@Fix_Bi_Func_1 (Func_Cat _ _) _ _ G F') ∘ F)%functor)%natiso :=

    {|

      iso_morphism :=

        {|

          Trans := fun c => id

        |};

      inverse_morphism :=

        {|

          Trans := fun c => id

        |}

    |}.



End Fix_Bi_Func_1_Functor_id_swap_NatIso.



Section Fix_Bi_Func_2_Functor_id_swap_NatIso.

  Context {B B' C D E E' : Category}

          (F : (B –≻ B')%functor)

          (F' : ((B' × (Func_Cat C D)) –≻ E)%functor)

          (G : (C –≻ D)%functor)

  .



  Local Obligation Tactic := cbn; auto.



  Local Hint Extern 1 => apply NatTrans_eq_simplify; cbn.

  

  Program Definition Fix_Bi_Func_2_Functor_id_swap_NatIso :

    (

      ((@Fix_Bi_Func_2 _ (Func_Cat _ _) _ G

                       (F' ∘ (Prod_Functor F (Functor_id _))))%functor)

        ≃((@Fix_Bi_Func_2 _ (Func_Cat _ _) _ G F') ∘ F)%functor)%natiso :=

    {|

      iso_morphism :=

        {|

          Trans := fun c => id

        |};

      inverse_morphism :=

        {|

          Trans := fun c => id

        |}

    |}.



End Fix_Bi_Func_2_Functor_id_swap_NatIso.



Section Fix_Bi_1_Func_Prod_Func_NatIso.

  Context {A B C D E : Category}

          (F : (A –≻ C)%functor)

          (F' : (B –≻ D)%functor)

          (G : ((C × D) –≻ E)%functor)

          (x : A)

  .



  Local Obligation Tactic := cbn; auto.



  Local Hint Extern 1 => apply NatTrans_eq_simplify; cbn.

  

  Program Definition Fix_Bi_1_Func_Prod_Func_NatIso :

    (

      ((Fix_Bi_Func_1 x (G ∘ (Prod_Functor F F')))%functor)

        ≃ ((Fix_Bi_Func_1 (F _o x)

                          (G ∘ (Prod_Functor (Functor_id C) F')))

          )%functor

    )%natiso :=

    {|

      iso_morphism := {|Trans := fun c => id|};

      inverse_morphism := {|Trans := fun c => id|}

    |}.



End Fix_Bi_1_Func_Prod_Func_NatIso.



Section Fix_Bi_2_Func_Prod_Func_NatIso.

  Context {A B C D E : Category}

          (F : (A –≻ C)%functor)

          (F' : (B –≻ D)%functor)

          (G : ((C × D) –≻ E)%functor)

          (x : B)

  .



  Local Obligation Tactic := cbn; auto.



  Local Hint Extern 1 => apply NatTrans_eq_simplify; cbn.

  

  Program Definition Fix_Bi_2_Func_Prod_Func_NatIso :

    (

      ((Fix_Bi_Func_2 x (G ∘ (Prod_Functor F F')))%functor)

        ≃ (Fix_Bi_Func_2 (F' _o x)

                         (G ∘  (Prod_Functor F (Functor_id D)))

          )%functor

    )%natiso :=

    {|

      iso_morphism := {|Trans := fun c => id|};

      inverse_morphism := {|Trans := fun c => id|}

    |}.



End Fix_Bi_2_Func_Prod_Func_NatIso.



Section Func_Prod_of_ids_NatIso.

  Context {C D E : Category} (F : ((C × D) –≻ E)%functor).



  Local Obligation Tactic := cbn; auto.



  Local Hint Extern 1 => apply NatTrans_eq_simplify; cbn.

  

  Program Definition Func_Prod_of_ids_NatIso :

    ((F ∘ (Prod_Functor (Functor_id C) (Functor_id D)))%functor ≃ F )%natiso :=

    {|

      iso_morphism := {|Trans := fun c => id|};

      inverse_morphism := {|Trans := fun c => id|}

    |}.



End Func_Prod_of_ids_NatIso.



Section Fix_Bi_Func_1_object_NatTrans.

  Context {B C D E : Category}

          (F : (((Func_Cat C D) × B) –≻ E)%functor)

          {G G' : (C –≻ D)%functor}

          (N : (G –≻ G')%nattrans)

  .



  Program Definition Fix_Bi_Func_1_object_NatTrans :

    ((@Fix_Bi_Func_1 (Func_Cat _ _) _ _ G F)

       –≻ (@Fix_Bi_Func_1 (Func_Cat _ _) _ _ G' F))%nattrans

     :=

    {|

      Trans := fun c => (F @_a (G, c) (G', c) (N, id))%morphism

    |}.



  Next Obligation.

  Proof.

    intros c c' h.

    cbn.

    repeat rewrite <- F_compose.

    cbn.

    rewrite NatTrans_id_unit_left, NatTrans_id_unit_right.

    auto.

  Qed.



  Next Obligation.

  Proof.

    symmetry.

    apply Fix_Bi_Func_1_object_NatTrans_obligation_1.

  Qed.



End Fix_Bi_Func_1_object_NatTrans.



Section Fix_Bi_Func_1_object_NatIso.

  Context {B C D E : Category}

          (F : (((Func_Cat C D) × B) –≻ E)%functor)

          {G G' : (C –≻ D)%functor}

          (N : (G ≃ G')%natiso)

  .



  Program Definition Fix_Bi_Func_1_object_NatIso :

    (

      ((@Fix_Bi_Func_1 (Func_Cat _ _) _ _ G F)%functor)

        ≃ (@Fix_Bi_Func_1 (Func_Cat _ _) _ _ G' F)%functor)%natiso :=

    {|

      iso_morphism := Fix_Bi_Func_1_object_NatTrans F (iso_morphism N);

      inverse_morphism := Fix_Bi_Func_1_object_NatTrans F (inverse_morphism N)

    |}.



  Next Obligation.

  Proof.

    apply NatTrans_eq_simplify; extensionality c; cbn.

    rewrite <- F_compose; cbn.

    cbn_rewrite (left_inverse N).

    simpl_ids.

    change (NatTrans_id G, id) with (id ((Func_Cat _ _) × B) (G, c)).

    auto.

  Qed.



  Next Obligation.

  Proof.

    apply NatTrans_eq_simplify; extensionality c; cbn.

    rewrite <- F_compose; cbn.

    cbn_rewrite (right_inverse N).

    simpl_ids.

    change (NatTrans_id G', id) with (id ((Func_Cat _ _) × B) (G', c)).

    auto.

  Qed.



End Fix_Bi_Func_1_object_NatIso.



Section Fix_Bi_Func_2_object_NatTrans.

  Context {B C D E : Category} (F : ((B × (Func_Cat C D)) –≻ E)%functor)

          {G G' : (C –≻ D)%functor}

          (N : (G –≻ G')%nattrans)

  .



  Program Definition Fix_Bi_Func_2_object_NatTrans :

    ((@Fix_Bi_Func_2 _ (Func_Cat _ _) _ G F)

       –≻ (@Fix_Bi_Func_2 _ (Func_Cat _ _) _ G' F))%nattrans

    :=

    {|

      Trans := fun c => (F @_a (c, G) (c, G') (id, N))%morphism

    |}.



  Next Obligation.

  Proof.

    intros c c' h; cbn.

    repeat rewrite <- F_compose; cbn.

    rewrite NatTrans_id_unit_left, NatTrans_id_unit_right.

    auto.

  Qed.



  Next Obligation.

  Proof.

    symmetry.

    apply Fix_Bi_Func_2_object_NatTrans_obligation_1.

  Qed.



End Fix_Bi_Func_2_object_NatTrans.



Section Fix_Bi_Func_2_object_NatIso.

  Context {B C D E : Category}

          (F : ((B × (Func_Cat C D)) –≻ E)%functor)

          {G G' : (C –≻ D)%functor}

          (N : (G ≃ G')%natiso).



  Program Definition Fix_Bi_Func_2_object_NatIso :

    (((@Fix_Bi_Func_2 _ (Func_Cat _ _) _ G F)%functor)

       ≃ (@Fix_Bi_Func_2 _ (Func_Cat _ _) _ G' F)%functor)%natiso :=

    {|

      iso_morphism := Fix_Bi_Func_2_object_NatTrans F (iso_morphism N);

      inverse_morphism := Fix_Bi_Func_2_object_NatTrans F (inverse_morphism N)

    |}.



  Next Obligation.

  Proof.

    apply NatTrans_eq_simplify; extensionality c; cbn.

    rewrite <- F_compose; cbn.

    simpl_ids.

    cbn_rewrite (left_inverse N).

    change (id, NatTrans_id G) with (id (B × (Func_Cat _ _)) (c, G)).

    auto.

  Qed.



  Next Obligation.

  Proof.

    apply NatTrans_eq_simplify; extensionality c; cbn.

    rewrite <- F_compose; cbn.

    simpl_ids.

    cbn_rewrite (right_inverse N).

    change (id, NatTrans_id G') with (id (B × (Func_Cat _ _)) (c, G')).

    auto.

  Qed.



End Fix_Bi_Func_2_object_NatIso.

