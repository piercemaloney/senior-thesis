From Categories Require Import Essentials.Notations.
(* Categories.Essentials.Notations:
Notation "∀ x .. y , P" := (forall x, .. (forall y, P) ..)
                             (at level 200, x binder, y binder, right associativity) : type_scope.

Notation "∃ x .. y , P" := (exists x, .. (exists y, P) ..)
  (at level 200, x binder, y binder, right associativity) : type_scope.

Notation "x ∨ y" := (x \/ y) (at level 85, right associativity) : type_scope.

Notation "x ∧ y" := (x /\ y) (at level 80, right associativity) : type_scope.

Notation "x → y" := (x -> y)
  (at level 90, y at level 200, right associativity): type_scope.

Notation "x ↔ y" := (x <-> y) (at level 95, no associativity): type_scope.

Notation "¬ x" := (~x) (at level 75, right associativity) : type_scope.

Notation "x ≠ y" := (x <> y) (at level 70) : type_scope.

Notation "x ≤ y" := (le x y) (at level 70, no associativity).

Notation "x ≥ y" := (ge x y) (at level 70, no associativity).

Reserved Notation "C '^op'" (at level 50, no associativity).

Reserved Notation "a –≻ b" (at level 90, b at level 200, right associativity).

Reserved Notation "f '⁻¹'" (at level 50, no associativity).

Reserved Notation "a ≃ b" (at level 70, no associativity).

Reserved Notation "a ≃≃ b ::> C" (at level 70, no associativity).

Reserved Notation "f ∘ g" (at level 51, right associativity).

Reserved Notation "f '∘_h' g" (at level 51, right associativity).

Reserved Notation "a ≫–> b" (at level 100, no associativity).

Reserved Notation "a –≫ b" (at level 100, no associativity).

Reserved Notation "F '_o'" (at level 50, no associativity).

Reserved Notation "F '_a'" (at level 50, no associativity).

Reserved Notation "F '@_a'" (at level 50, no associativity).

Reserved Notation "F ⊣ G" (at level 100, no associativity).

Reserved Notation "F ⊣_hom G" (at level 100, no associativity).

Reserved Notation "F ⊣_ucu G" (at level 100, no associativity).

Reserved Notation "a × b" (at level 80, no associativity).

Reserved Notation "a ⇑ b" (at level 79, no associativity).

Reserved Notation "'Π' m" (at level 50, no associativity).

Reserved Notation "'Σ' m" (at level 50, no associativity).

Reserved Notation "'Π_' C ↓ m" (at level 50, no associativity).

Reserved Notation "'Σ_' C ↓ m" (at level 50, no associativity).

Delimit Scope category_scope with category.

Delimit Scope morphism_scope with morphism.

Delimit Scope object_scope with object.

Delimit Scope functor_scope with functor.

Delimit Scope nattrans_scope with nattrans.

Delimit Scope nattrans_scope with nattrans.

Delimit Scope natiso_scope with natiso.

Delimit Scope isomorphism_scope with isomorphism.

Delimit Scope preorder_scope with preorder. *)

From Categories Require Import Essentials.Types.
(* Categories.Essentials.Types:
Global Set Primitive Projections.

Global Set Universe Polymorphism.

Global Unset Universe Minimization ToSet.

Inductive Empty : Type :=.

Hint Extern 1 =>
let tac := (repeat intros ?); match goal with [H : Empty |- _] => contradict H end in
match goal with
  | [|- context[Empty]] => tac
  | [H : context[Empty] |- _] => tac
end
.

Record prod (A B : Type) := {fst : A; snd : B}.

Arguments fst {_ _ } _.
Arguments snd {_ _ } _.
Arguments Build_prod {_ _ } _ _.

Notation "( X , Y )" := (Build_prod X Y).
Notation "X * Y" := (prod X Y) : type_scope. *)

From Categories Require Import Essentials.Facts_Tactics.
(* Categories.Essentials.Facts_Tactics:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.

Require Export Coq.Program.Tactics.
Require Export Coq.Program.Equality.
Require Export Coq.Logic.FunctionalExtensionality.
Require Export Coq.Logic.ProofIrrelevance.

Definition equal_f : ∀ {A B : Type} {f g : A → B}, f = g → ∀ x : A, f x = g x.

Definition f_equal : ∀ (A B : Type) (f : A → B) (x y : A), x = y → f x = f y.

Arguments f_equal [_ _] _ [_ _] _.

Ltac basic_simpl :=
  let simpl_prod _ :=
      match goal with
        [H : prod _ _ |- _] =>
        let H1 := fresh H "1" in
        let H2 := fresh H "2" in
        destruct H as [H1 H2]
      end
  in
  let simpl_sig _ :=
      match goal with
        [H : @sig _ _ |- _] =>
        let H1 := fresh H "1" in
        let H2 := fresh H "2" in
        destruct H as [H1 H2]
      end
  in
  let basic_simpl_helper _ :=
      cbn in *; intros;
        repeat simpl_prod tt;
        repeat simpl_sig tt
  in
  repeat basic_simpl_helper tt
.

Global Obligation Tactic := basic_simpl; auto.

Ltac PIR :=
  let pir_helper _ :=
      match goal with
      |[H : ?A, H' : ?A|- _] =>
       match type of A with
       | Prop =>
         destruct (proof_irrelevance _ H H')
       end
      end
  in
  repeat pir_helper tt
.

Ltac ElimEq := repeat match goal with [H : _ = _|- _] => destruct H end.

Hint Extern 1 => progress ElimEq.

Ltac cbn_rewrite W :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite H; clear H
.

Ltac cbn_rewrite_in W V :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite H in V; clear H
.

Ltac cbn_rewrite_back W :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite <- H; clear H
.

Ltac cbn_rewrite_back_in W V :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite <- H in V; clear H
.

Tactic Notation "cbn_rewrite" constr(W) := cbn_rewrite W.
Tactic Notation "cbn_rewrite" constr(W) "in" hyp_list(V) := cbn_rewrite_in W V.
Tactic Notation "cbn_rewrite" "<-" constr(W) := cbn_rewrite_back W.
Tactic Notation "cbn_rewrite" "<-" constr(W) "in" hyp_list(V) := cbn_rewrite_back_in W V.

Lemma sig_proof_irrelevance {A : Type} (P : A → Prop) (X Y : sig P) : proj1_sig X = proj1_sig Y → X = Y.

Hint Extern 2 (exist ?A _ _ = exist ?A _ _) => apply sig_proof_irrelevance.

Ltac FunExt :=
progress (
    repeat (
        match goal with
          [|- _ = _] =>
          let x := fresh "x" in
          extensionality x
        end
      )
  )
.

Hint Extern 1 => FunExt.

Lemma pair_eq (A B : Type) (a b : A * B) : fst a = fst b → snd a = snd b → a = b.

Hint Resolve pair_eq.

Ltac revert_clearbody_all :=
 repeat lazymatch goal with H:_ |- _ => try clearbody H; revert H end.

Ltac hyp_stack :=
 constr:(ltac:(revert_clearbody_all;constructor) : True).

Ltac next_hyp hs step last :=
 lazymatch hs with (?hs' ?H) => step H hs' | _ => last end.

Tactic Notation "dohyps" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := tac H; next_hyp hs step idtac in
 next_hyp hs step idtac.

Tactic Notation "dohyps" "reverse" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := next_hyp hs step idtac; tac H in
 next_hyp hs step idtac.

Tactic Notation "do1hyp" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := tac H + next_hyp hs step fail in
 next_hyp hs step fail.

Tactic Notation "do1hyp" "reverse" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := next_hyp hs step fail + tac H in
 next_hyp hs step fail. *)

From Categories Require Import Category.Main.
(* Categories.Category.Main:
From Categories Require Export Category.Category.
From Categories Require Export Category.Morph.
From Categories Require Export Category.Opposite.
From Categories Require Export Category.SubCategory.
From Categories Require Export Category.Composable_Chain. *)

From Categories Require Import Ext_Cons.Prod_Cat.Prod_Cat Ext_Cons.Prod_Cat.Nat_Facts
(* Categories.Ext_Cons.Prod_Cat.Prod_Cat:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Main.
From Categories Require Import Cat.Cat.

Local Open Scope morphism_scope.

Local Obligation Tactic := idtac.

Program Definition Prod_Cat (C C' : Category) : Category :=
{|
  Obj := C * C';
              
  Hom :=
    fun a b =>
      (((fst a) –≻ (fst b)) * ((snd a) –≻ (snd b)))%type;

  compose :=
    fun a b c f g =>
      (((fst g) ∘ (fst f)), ((snd g) ∘ (snd f)))%morphism;

  id := fun c => (id, id)
|}.

Notation "C × D" := (Prod_Cat C D) : category_scope.

Local Obligation Tactic := basic_simpl; auto.

Theorem Prod_compose_id
        (C D : Category)
        (a b c : C) (d : D)
        (f : a –≻ b) (g : b –≻ c)
  : (g ∘ f, id d)%morphism =
    @compose (_ × _) (_, _) (_, _) (_, _) (f, id d) (g, id d).

Theorem Prod_id_compose
        (C D : Category)
        (a : C) (b c d : D)
        (f : b –≻ c) (g : c –≻ d)
  : (id a, g ∘ f)%morphism =
    @compose (_ × _) (_, _) (_, _) (_, _) (id a, f) (id a, g).

Theorem Prod_cross_compose
        (C D : Category)
        (a b : C) (c d : D)
        (f : a –≻ b) (g : c –≻ d)
  : @compose
      (_ × _) (_, _) (_, _) (_, _)
      (@id _ a, g) (f, @id _ d)
    = @compose
        (_ × _) (_, _) (_, _) (_, _)
        (f, @id _ c) (@id _ b, g)
.

Program Definition Cat_Proj1
        (C C' : Category) :
  ((C × C') –≻ C)%functor
  :=
    {|FO := fst; FA := fun _ _ f => fst f|}
.

Program Definition Cat_Proj2
        (C C' : Category) :
  ((C × C') –≻ C')%functor
  :=
    {|FO := snd; FA := fun _ _ f => snd f|}
. *)
(* Categories.Ext_Cons.Prod_Cat.Nat_Facts:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Main.
From Categories Require Import Cat.Cat.
From Categories Require Import Ext_Cons.Prod_Cat.Prod_Cat Ext_Cons.Prod_Cat.Operations.
From Categories Require Import NatTrans.NatTrans NatTrans.Operations NatTrans.Func_Cat
        NatTrans.NatIso.

Local Obligation Tactic := idtac.

Section Prod_Functor_NatTrans.
  Context {C D : Category}
          {F G : (C –≻ D)%functor}
          (N : (F –≻ G)%nattrans)
          {C' D' : Category}
          {F' G' : (C' –≻ D')%functor}
          (N' : (F' –≻ G')%nattrans).

  Program Definition Prod_Functor_NatTrans :
    ((Prod_Functor F F') –≻ (Prod_Functor G G'))%nattrans :=
    {|
      Trans := fun c => (Trans N (fst c), Trans N' (snd c))
    |}.

End Prod_Functor_NatTrans.

Section Prod_Functor_NatTrans_id.
  Context {C D : Category} (F : (C –≻ D)%functor)
          {C' D' : Category} {F' : (C' –≻ D')%functor}.

  Theorem Prod_Functor_NatTrans_id :
    Prod_Functor_NatTrans (NatTrans_id F) (NatTrans_id F') =
    NatTrans_id (Prod_Functor F F').

End Prod_Functor_NatTrans_id.

Section Prod_Functor_NatTrans_compose.
  Context {C D : Category}
          {F G H : (C –≻ D)%functor}
          (N1 : (F –≻ G)%nattrans)
          (N2 : (G –≻ H)%nattrans)
          {C' D' : Category}
          {F' G' H' : (C' –≻ D')%functor}
          (N1' : (F' –≻ G')%nattrans)
          (N2' : (G' –≻ H')%nattrans).

  Theorem Prod_Functor_NatTrans_compose :
    ((Prod_Functor_NatTrans N2 N2') ∘ (Prod_Functor_NatTrans N1 N1') =
     Prod_Functor_NatTrans (N2 ∘ N1) (N2' ∘ N1'))%nattrans.

End Prod_Functor_NatTrans_compose.

Section Prod_Functor_NatIso.
  Context {C D : Category}
          {F G : (C –≻ D)%functor}
          (N : (F ≃ G)%natiso)
          {C' D' : Category}
          {F' G' : (C' –≻ D')%functor}
          (N' : (F' ≃ G')%natiso)
  .

  Program Definition Prod_Functor_NatIso :
    ((Prod_Functor F F') ≃ (Prod_Functor G G'))%natiso :=
    {|
      iso_morphism := Prod_Functor_NatTrans (iso_morphism N) (iso_morphism N');
      inverse_morphism :=
        Prod_Functor_NatTrans (inverse_morphism N) (inverse_morphism N')
    |}.

End Prod_Functor_NatIso.

Section Fix_Bi_Func_1_NatTrans.
  Context {B C D E : Category}
          {F F' : (((Func_Cat C D) × B) –≻ E)%functor}
          (N : (F –≻ F')%nattrans)
          (G : (C –≻ D)%functor)
  .

  Program Definition Fix_Bi_Func_1_NatTrans :
    ((@Fix_Bi_Func_1 (Func_Cat _ _) _ _ G F) –≻ (@Fix_Bi_Func_1 (Func_Cat _ _) _ _ G F'))%nattrans
    :=
    {|
      Trans := fun c => Trans N (G, c)
    |}.

End Fix_Bi_Func_1_NatTrans.

Section Fix_Bi_Func_1_NatIso.
  Context {B C D E : Category}
          {F F' : (((Func_Cat C D) × B) –≻ E)%functor}
          (N : (F ≃ F')%natiso)
          (G : (C –≻ D)%functor)
  .

  Program Definition Fix_Bi_Func_1_NatIso :
    ((@Fix_Bi_Func_1 (Func_Cat _ _) _ _ G F)
       ≃ (@Fix_Bi_Func_1 (Func_Cat _ _) _ _ G F'))%natiso
    :=
    {|
      iso_morphism := Fix_Bi_Func_1_NatTrans (iso_morphism N) G;
      inverse_morphism := Fix_Bi_Func_1_NatTrans (inverse_morphism N) G
    |}.

End Fix_Bi_Func_1_NatIso.

Section Fix_Bi_Func_2_NatTrans.
  Context {B C D E : Category}
          {F F' : ((B × (Func_Cat C D)) –≻ E)%functor}
          (N : (F –≻ F')%nattrans)
          (G : (C –≻ D)%functor)
  .

  Program Definition Fix_Bi_Func_2_NatTrans :
    ((@Fix_Bi_Func_2 _ (Func_Cat _ _) _ G F) –≻ (@Fix_Bi_Func_2 _ (Func_Cat _ _) _ G F'))%nattrans
    :=
    {|
      Trans := fun c => Trans N (c, G)
    |}.

End Fix_Bi_Func_2_NatTrans.

Section Fix_Bi_Func_2_NatIso.
  Context {B C D E : Category}
          {F F' : ((B × (Func_Cat C D)) –≻ E)%functor}
          (N : (F ≃ F')%natiso)
          (G : (C –≻ D)%functor)
  .

  Program Definition Fix_Bi_Func_2_NatIso :
    (
      (@Fix_Bi_Func_2 _ (Func_Cat _ _) _ G F)
        ≃ (@Fix_Bi_Func_2 _ (Func_Cat _ _) _ G F'))%natiso
    :=
      {|
        iso_morphism := Fix_Bi_Func_2_NatTrans (iso_morphism N) G;
        inverse_morphism := Fix_Bi_Func_2_NatTrans (inverse_morphism N) G
      |}
  .

End Fix_Bi_Func_2_NatIso.

Section Fix_Bi_Func_1_Functor_id_swap_NatIso.
  Context {B B' C D E E' : Category}
          (F : (B –≻ B')%functor)
          (F' : (((Func_Cat C D) × B') –≻ E)%functor)
          (G : (C –≻ D)%functor)
  .

  Local Obligation Tactic := cbn; auto.

  Local Hint Extern 1 => apply NatTrans_eq_simplify; cbn.
  
  Program Definition Fix_Bi_Func_1_Functor_id_swap_NatIso :
    (
      (@Fix_Bi_Func_1 (Func_Cat _ _) _ _ G
                      ( F' ∘ (Prod_Functor (Functor_id _) F)))%functor
        ≃ ((@Fix_Bi_Func_1 (Func_Cat _ _) _ _ G F') ∘ F)%functor)%natiso :=
    {|
      iso_morphism :=
        {|
          Trans := fun c => id
        |};
      inverse_morphism :=
        {|
          Trans := fun c => id
        |}
    |}.

End Fix_Bi_Func_1_Functor_id_swap_NatIso.

Section Fix_Bi_Func_2_Functor_id_swap_NatIso.
  Context {B B' C D E E' : Category}
          (F : (B –≻ B')%functor)
          (F' : ((B' × (Func_Cat C D)) –≻ E)%functor)
          (G : (C –≻ D)%functor)
  .

  Local Obligation Tactic := cbn; auto.

  Local Hint Extern 1 => apply NatTrans_eq_simplify; cbn.
  
  Program Definition Fix_Bi_Func_2_Functor_id_swap_NatIso :
    (
      ((@Fix_Bi_Func_2 _ (Func_Cat _ _) _ G
                       (F' ∘ (Prod_Functor F (Functor_id _))))%functor)
        ≃((@Fix_Bi_Func_2 _ (Func_Cat _ _) _ G F') ∘ F)%functor)%natiso :=
    {|
      iso_morphism :=
        {|
          Trans := fun c => id
        |};
      inverse_morphism :=
        {|
          Trans := fun c => id
        |}
    |}.

End Fix_Bi_Func_2_Functor_id_swap_NatIso.

Section Fix_Bi_1_Func_Prod_Func_NatIso.
  Context {A B C D E : Category}
          (F : (A –≻ C)%functor)
          (F' : (B –≻ D)%functor)
          (G : ((C × D) –≻ E)%functor)
          (x : A)
  .

  Local Obligation Tactic := cbn; auto.

  Local Hint Extern 1 => apply NatTrans_eq_simplify; cbn.
  
  Program Definition Fix_Bi_1_Func_Prod_Func_NatIso :
    (
      ((Fix_Bi_Func_1 x (G ∘ (Prod_Functor F F')))%functor)
        ≃ ((Fix_Bi_Func_1 (F _o x)
                          (G ∘ (Prod_Functor (Functor_id C) F')))
          )%functor
    )%natiso :=
    {|
      iso_morphism := {|Trans := fun c => id|};
      inverse_morphism := {|Trans := fun c => id|}
    |}.

End Fix_Bi_1_Func_Prod_Func_NatIso.

Section Fix_Bi_2_Func_Prod_Func_NatIso.
  Context {A B C D E : Category}
          (F : (A –≻ C)%functor)
          (F' : (B –≻ D)%functor)
          (G : ((C × D) –≻ E)%functor)
          (x : B)
  .

  Local Obligation Tactic := cbn; auto.

  Local Hint Extern 1 => apply NatTrans_eq_simplify; cbn.
  
  Program Definition Fix_Bi_2_Func_Prod_Func_NatIso :
    (
      ((Fix_Bi_Func_2 x (G ∘ (Prod_Functor F F')))%functor)
        ≃ (Fix_Bi_Func_2 (F' _o x)
                         (G ∘  (Prod_Functor F (Functor_id D)))
          )%functor
    )%natiso :=
    {|
      iso_morphism := {|Trans := fun c => id|};
      inverse_morphism := {|Trans := fun c => id|}
    |}.

End Fix_Bi_2_Func_Prod_Func_NatIso.

Section Func_Prod_of_ids_NatIso.
  Context {C D E : Category} (F : ((C × D) –≻ E)%functor).

  Local Obligation Tactic := cbn; auto.

  Local Hint Extern 1 => apply NatTrans_eq_simplify; cbn.
  
  Program Definition Func_Prod_of_ids_NatIso :
    ((F ∘ (Prod_Functor (Functor_id C) (Functor_id D)))%functor ≃ F )%natiso :=
    {|
      iso_morphism := {|Trans := fun c => id|};
      inverse_morphism := {|Trans := fun c => id|}
    |}.

End Func_Prod_of_ids_NatIso.

Section Fix_Bi_Func_1_object_NatTrans.
  Context {B C D E : Category}
          (F : (((Func_Cat C D) × B) –≻ E)%functor)
          {G G' : (C –≻ D)%functor}
          (N : (G –≻ G')%nattrans)
  .

  Program Definition Fix_Bi_Func_1_object_NatTrans :
    ((@Fix_Bi_Func_1 (Func_Cat _ _) _ _ G F)
       –≻ (@Fix_Bi_Func_1 (Func_Cat _ _) _ _ G' F))%nattrans
     :=
    {|
      Trans := fun c => (F @_a (G, c) (G', c) (N, id))%morphism
    |}.

End Fix_Bi_Func_1_object_NatTrans.

Section Fix_Bi_Func_1_object_NatIso.
  Context {B C D E : Category}
          (F : (((Func_Cat C D) × B) –≻ E)%functor)
          {G G' : (C –≻ D)%functor}
          (N : (G ≃ G')%natiso)
  .

  Program Definition Fix_Bi_Func_1_object_NatIso :
    (
      ((@Fix_Bi_Func_1 (Func_Cat _ _) _ _ G F)%functor)
        ≃ (@Fix_Bi_Func_1 (Func_Cat _ _) _ _ G' F)%functor)%natiso :=
    {|
      iso_morphism := Fix_Bi_Func_1_object_NatTrans F (iso_morphism N);
      inverse_morphism := Fix_Bi_Func_1_object_NatTrans F (inverse_morphism N)
    |}.

End Fix_Bi_Func_1_object_NatIso.

Section Fix_Bi_Func_2_object_NatTrans.
  Context {B C D E : Category} (F : ((B × (Func_Cat C D)) –≻ E)%functor)
          {G G' : (C –≻ D)%functor}
          (N : (G –≻ G')%nattrans)
  .

  Program Definition Fix_Bi_Func_2_object_NatTrans :
    ((@Fix_Bi_Func_2 _ (Func_Cat _ _) _ G F)
       –≻ (@Fix_Bi_Func_2 _ (Func_Cat _ _) _ G' F))%nattrans
    :=
    {|
      Trans := fun c => (F @_a (c, G) (c, G') (id, N))%morphism
    |}.

End Fix_Bi_Func_2_object_NatTrans.

Section Fix_Bi_Func_2_object_NatIso.
  Context {B C D E : Category}
          (F : ((B × (Func_Cat C D)) –≻ E)%functor)
          {G G' : (C –≻ D)%functor}
          (N : (G ≃ G')%natiso).

  Program Definition Fix_Bi_Func_2_object_NatIso :
    (((@Fix_Bi_Func_2 _ (Func_Cat _ _) _ G F)%functor)
       ≃ (@Fix_Bi_Func_2 _ (Func_Cat _ _) _ G' F)%functor)%natiso :=
    {|
      iso_morphism := Fix_Bi_Func_2_object_NatTrans F (iso_morphism N);
      inverse_morphism := Fix_Bi_Func_2_object_NatTrans F (inverse_morphism N)
    |}.

End Fix_Bi_Func_2_object_NatIso. *)

        Ext_Cons.Prod_Cat.Operations.

From Categories Require Import Functor.Main.
(* Categories.Functor.Main:
From Categories Require Export Functor.Functor.
From Categories Require Export Functor.Functor_Extender.
From Categories Require Export Functor.Functor_Image.
From Categories Require Export Functor.Functor_Ops.
From Categories Require Export Functor.Functor_Properties.
From Categories Require Export Functor.Const_Func.
From Categories Require Export Functor.Const_Func_Functor. *)

From Categories Require Import Functor.Representable.Hom_Func
(* Categories.Functor.Representable.Hom_Func:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Functor.
From Categories Require Import Coq_Cats.Type_Cat.Type_Cat.
From Categories Require Import Ext_Cons.Prod_Cat.Prod_Cat.

Program Definition Hom_Func (C : Category) : ((C^op × C) –≻ Type_Cat)%functor :=
{|
  FO := fun x => Hom C (fst x) (snd x);
  FA := fun x y f => fun g => compose C (fst f) ((@compose (C^op) _ _ _) (snd f) g)
|}. *)

        Functor.Representable.Hom_Func_Prop.

From Categories Require Import NatTrans.Main.
(* Categories.NatTrans.Main:
From Categories Require Export NatTrans.NatTrans.
From Categories Require Export NatTrans.Func_Cat.
From Categories Require Export NatTrans.NatIso.
From Categories Require Export NatTrans.Operations.
From Categories Require Export NatTrans.Morphisms. *)

From Categories Require Import Adjunction.Adjunction Adjunction.Duality.
(* Categories.Adjunction.Adjunction:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Ext_Cons.Prod_Cat.Prod_Cat Ext_Cons.Prod_Cat.Operations.
From Categories Require Import Functor.Main.
From Categories Require Import Functor.Representable.Hom_Func
        Functor.Representable.Hom_Func_Prop.
From Categories Require Import NatTrans.Main.

Local Open Scope functor_scope.

Local Notation NID := NatTrans_id (only parsing).
Local Notation FCAT := Func_Cat (only parsing).

Notation Hom_Adj_Left C D F G :=
  ((Hom_Func D) ∘ (Prod_Functor (F^op) (@Functor_id D)))%functor (only parsing).

Notation Hom_Adj_Right C D F G :=
  ((Hom_Func C) ∘ (Prod_Functor (@Functor_id (C^op)) G))%functor (only parsing).

Local Obligation Tactic := idtac.

Section Adjunction.
  Context {C D : Category} (F : C –≻ D) (G : D –≻ C).

  Record Adjunct : Type :=
  {
    adj_unit : ((Functor_id C) –≻ (G ∘ F))%nattrans;
    
    adj_morph_ex {c : C} {d : D} (f : (c –≻ (G _o d)%object)%morphism) :
      ((F _o c)%object –≻ d)%morphism;
    
    adj_morph_com {c : C} {d : D} (f : (c –≻ (G _o d))%morphism%object) :
      f = ((G _a (adj_morph_ex f)) ∘ (Trans adj_unit c))%morphism;
    
    adj_morph_unique {c : C} {d : D} (f : (c –≻ (G _o d))%object%morphism)
                     (g h : ((F _o c) –≻ d)%morphism%object) :
      f = ((G _a g) ∘ (Trans adj_unit c))%morphism →
      f = ((G _a h) ∘ (Trans adj_unit c))%morphism →
      g = h
  }.

  Arguments adj_unit : clear implicits.
  Arguments adj_morph_ex _ {_ _} _.
  Arguments adj_morph_com _ {_ _} _.
  Arguments adj_morph_unique _ {_ _} _ _ _ _ _.

  Theorem Adjunct_eq_simplify (adj adj' : Adjunct) :
    adj_unit adj = @adj_unit adj' →
    @adj_morph_ex adj = @adj_morph_ex adj' → adj = adj'.

  Definition Hom_Adjunct :=
    (Hom_Adj_Left _ _ F G ≃ Hom_Adj_Right _ _ F G)%natiso.

  Record UCU_Adjunct :=
    {
      ucu_adj_unit : ((Functor_id C) –≻ (G ∘ F))%nattrans;
      
      ucu_adj_counit : ((F ∘ G) –≻ (Functor_id D))%nattrans;

      ucu_adj_left_id : ((NatTrans_from_compose_id _)
                           ∘ ((((ucu_adj_counit ∘_h (NID F))
                                  ∘ (NatTrans_Functor_assoc_sym _ _ _))
                                 ∘ ((NID F) ∘_h ucu_adj_unit))
                                ∘ (NatTrans_to_id_compose _)))%nattrans
                        = (NID F);
      
      ucu_adj_right_id : ((NatTrans_from_id_compose _)
                            ∘ (((((NID G) ∘_h ucu_adj_counit)
                                   ∘ (NatTrans_Functor_assoc _ _ _))
                                  ∘ (ucu_adj_unit ∘_h (NID G)))
                                 ∘ (NatTrans_to_compose_id _)))%nattrans
                         = (NID G)
    }.

  Arguments ucu_adj_unit : clear implicits.
  Arguments ucu_adj_counit : clear implicits.
  Arguments ucu_adj_left_id : clear implicits.
  Arguments ucu_adj_right_id : clear implicits.

  Local Notation "F ⊣ G" := (Adjunct) : functor_scope.
  Local Notation "F ⊣_hom G" := (Hom_Adjunct) : functor_scope.
  Local Notation "F ⊣_ucu G" := (UCU_Adjunct) : functor_scope.
  
  Section UCU_Adj_Adj.
    Context (Adj : (F ⊣_ucu G)%functor).

    Program Definition UCU_Adj_to_Adj : (F ⊣ G)%functor :=
      {|
        adj_unit := ucu_adj_unit Adj;
        adj_morph_ex :=
          fun _ _ h => ((Trans (ucu_adj_counit Adj) _) ∘ (F _a h))%morphism
      |}.

  End UCU_Adj_Adj.

  Section Adj_UCU_Adj.
    Context (Adj : (F ⊣ G)%functor).
    
    Program Definition Adj_to_UCU_Adj : (F ⊣_ucu G)%functor :=
      {|
        ucu_adj_unit := adj_unit Adj;
        ucu_adj_counit :=
          {|
            Trans := fun d => @adj_morph_ex Adj (G _o d) d id
          |}
      |}.

  End Adj_UCU_Adj.
  
  Section Adj_Hom_Adj.
    Context (Adj : (F ⊣ G)%functor).

    Program Definition Adj_to_Hom_Adj_LR :
      ((Hom_Adj_Left _ _ F G) –≻ (Hom_Adj_Right _ _ F G))%nattrans :=
    {|
      Trans := fun c h => ((G _a h) ∘ (Trans (adj_unit Adj) _))%morphism
    |}.

    Program Definition Adj_to_Hom_Adj_RL :
      ((Hom_Adj_Right _ _ F G) –≻ (Hom_Adj_Left _ _ F G))%nattrans :=
    {|
      Trans := fun c h => adj_morph_ex Adj h
    |}.

    Program Definition Adj_to_Hom_Adj : (F ⊣_hom G)%functor :=
      NatIso _ _ Adj_to_Hom_Adj_LR Adj_to_Hom_Adj_RL _ _.

  End Adj_Hom_Adj.

  Section Hom_Adj_Adj.
    Context (Adj : (F ⊣_hom G)%functor).

    Program Definition Hom_Adj_to_Adj : (F ⊣ G)%functor :=
      {|
        adj_unit :=
          {| Trans := fun c => Trans (iso_morphism Adj) (c, F _o c)%object id |};
        adj_morph_ex := fun _ _ f => Trans (inverse_morphism Adj) (_, _) f
      |}.

  End Hom_Adj_Adj.

End Adjunction.

Arguments adj_unit {_ _ _ _} _ : assert.
Arguments adj_morph_ex {_ _ _ _} _ {_ _} _.
Arguments adj_morph_com {_ _ _ _} _ {_ _} _.
Arguments adj_morph_unique {_ _ _ _} _ {_ _} _ _ _ _ _.

Arguments ucu_adj_unit {_ _ _ _} _.
Arguments ucu_adj_counit {_ _ _ _} _.
Arguments ucu_adj_left_id {_ _ _ _} _.
Arguments ucu_adj_right_id {_ _ _ _} _.

Arguments Adj_to_Hom_Adj {_ _ _ _} _.

Arguments Hom_Adj_to_Adj {_ _ _ _} _.

Notation "F ⊣ G" := (Adjunct F G) : functor_scope.
Notation "F ⊣_hom G" := (Hom_Adjunct F G) : functor_scope.
Notation "F ⊣_ucu G" := (UCU_Adjunct F G) : functor_scope. *)
(* Categories.Adjunction.Duality:
From Categories Require Import Category.Main.
From Categories Require Import Ext_Cons.Prod_Cat.Prod_Cat Ext_Cons.Prod_Cat.Operations.
From Categories Require Import Functor.Main.
From Categories Require Import Functor.Representable.Hom_Func Functor.Representable.Hom_Func_Prop.
From Categories Require Import NatTrans.NatTrans NatTrans.NatIso.
From Categories Require Import Adjunction.Adjunction.

Local Open Scope functor_scope.

Section Hom_Adj_Duality.
  Context {C D : Category} {F : C –≻ D} {G : D –≻ C} (adj : F ⊣_hom G).

  Definition Hom_Adjunct_Duality : G^op ⊣_hom F^op :=
    (Prod_Func_Hom_Func (adj⁻¹))
  .

End Hom_Adj_Duality.

Section Adj_Duality.
  Context {C D : Category} {F : C –≻ D} {G : D –≻ C} (adj : F ⊣ G).

  Definition Adjunct_Duality : G^op ⊣ F^op :=
    (Hom_Adj_to_Adj (Hom_Adjunct_Duality (Adj_to_Hom_Adj adj)))
  .

End Adj_Duality. *)

From Categories Require Import Cat.Cat Cat.Exponential Cat.Exponential_Facts.
(* Categories.Cat.Cat:
From Categories Require Import Category.Main.
From Categories Require Import Functor.Functor Functor.Functor_Ops.

Local Open Scope functor_scope.

Definition Cat : Category :=
{|
  Obj := Category;

  Hom := Functor;

  compose := fun C D E => Functor_compose;
  
  assoc := fun C D E F (G : C –≻ D) (H : D –≻ E) (I : E –≻ F) =>
            @Functor_assoc _ _ _ _ G H I;

  assoc_sym := fun C D E F (G : C –≻ D) (H : D –≻ E) (I : E –≻ F) =>
            eq_sym (@Functor_assoc _ _ _ _ G H I);

  id := fun C => Functor_id C;

  id_unit_left := fun C D => @Functor_id_unit_left C D;

  id_unit_right := fun C D => @Functor_id_unit_right C D          
|}. *)
(* Categories.Cat.Exponential:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Main.
From Categories Require Import Cat.Cat.
From Categories Require Import Ext_Cons.Prod_Cat.Prod_Cat Ext_Cons.Prod_Cat.Operations.
From Categories Require Import Basic_Cons.Product.
From Categories Require Import Basic_Cons.Exponential.
From Categories Require Import NatTrans.NatTrans NatTrans.Func_Cat.
From Categories Require Import Cat.Product.

Local Open Scope functor_scope.

Program Definition Exp_Cat_Eval (C C' : Category) :
  ((Func_Cat C C') × C) –≻ C' :=
{|
  FO := fun x => ((fst x) _o (snd x))%object;
  FA := fun A B f => (((fst B) _a (snd f)) ∘ (@Trans _ _ _ _ (fst f) _))%morphism
|}.

Program Definition Exp_Cat_morph_ex_A
        {C C' C'' : Category} (F : (C'' × C) –≻  C')
        (a b : C'') (h : (a –≻ b)%morphism)
  :
    ((Fix_Bi_Func_1 a F) –≻ (Fix_Bi_Func_1 b F))%nattrans :=
{|
  Trans := fun c => (F _a (h, id _ c))%morphism
|}.

Local Hint Extern 1 => apply NatTrans_eq_simplify; cbn.

Program Definition Exp_Cat_morph_ex
        {C C' C'' : Category}
        (F : (C'' × C) –≻ C')
  :
    C'' –≻ (Func_Cat C C') :=
{|
  FO := fun a => Fix_Bi_Func_1 a F;
  FA := Exp_Cat_morph_ex_A F
|}.

Lemma Exp_cat_morph_ex_eval_id
      {C C' C'' : Category}
      (u : C'' –≻ (Func_Cat C C'))
  :
    (u =
     Exp_Cat_morph_ex
       (
         (Exp_Cat_Eval C C')
           ∘ ((×ᶠⁿᶜ _ Cat_Has_Products) @_a (_, _) (_, _) (u, id Cat C))
       )
    )%morphism.

Program Definition Cat_Exponential (C C' : Cat) : (C ⇑ C')%object :=
{|
  exponential := Func_Cat C C';
  eval := Exp_Cat_Eval C C';
  Exp_morph_ex := fun C'' F => @Exp_Cat_morph_ex C C' C'' F
|}.

Program Instance Cat_Has_Exponentials : Has_Exponentials Cat := Cat_Exponential. *)
(* Categories.Cat.Exponential_Facts:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Main.
From Categories Require Import Cat.Cat.
From Categories Require Import Ext_Cons.Prod_Cat.Prod_Cat Ext_Cons.Prod_Cat.Operations.
From Categories Require Import Basic_Cons.Product.
From Categories Require Import Basic_Cons.Exponential.
From Categories Require Import NatTrans.NatTrans NatTrans.Func_Cat NatTrans.NatIso.
From Categories Require Import Cat.Product Cat.Exponential.

Local Open Scope functor_scope.

Section Exp_Cat_morph_ex_compose.
  Context {C C' C'' : Category}
          (F : (C'' × C) –≻  C')
          {B : Category}
          (G : B –≻ C'')
  .

  Theorem Exp_Cat_morph_ex_compose :
    Exp_Cat_morph_ex (F ∘ (Prod_Functor G (Functor_id C)))
    = (Exp_Cat_morph_ex F) ∘ G.

End Exp_Cat_morph_ex_compose.

Section Exp_Cat_morph_ex_compose_Iso.
  Context {C C' C'' : Category}
          (F : (C'' × C) –≻  C')
          {B : Category}
          (G : B –≻ C'').

  Local Hint Extern 1 => apply NatTrans_eq_simplify; cbn.
  
  Program Definition Exp_Cat_morph_ex_compose_Iso_RL :
    ((Exp_Cat_morph_ex (F ∘ (Prod_Functor G (Functor_id C))))
       –≻ ((Exp_Cat_morph_ex F) ∘ G))%nattrans :=
    {|
      Trans :=
        fun c =>
          {|
            Trans := fun d => id
          |}
    |}.

  Program Definition Exp_Cat_morph_ex_compose_Iso_LR :
    (((Exp_Cat_morph_ex F) ∘ G)
       –≻ (Exp_Cat_morph_ex (F ∘ (Prod_Functor G (Functor_id C)))))%nattrans
    :=
    {|
      Trans :=
        fun c =>
          {|
            Trans := fun d => id
          |}
    |}.
    
  Program Definition Exp_Cat_morph_ex_compose_Iso :
    (((Exp_Cat_morph_ex (F ∘ (Prod_Functor G (Functor_id C))))%functor)
       ≃ ((Exp_Cat_morph_ex F) ∘ G)%functor)%natiso :=
    {|
      iso_morphism := Exp_Cat_morph_ex_compose_Iso_RL;
      inverse_morphism := Exp_Cat_morph_ex_compose_Iso_LR
    |}.

End Exp_Cat_morph_ex_compose_Iso.

Section Exp_Cat_morph_ex_NT.
  Context {C C' C'' : Category}
          {F F' : (C'' × C) –≻  C'}
          (N : (F –≻ F')%nattrans).
    Program Definition Exp_Cat_morph_ex_NT :
    ((Exp_Cat_morph_ex F) –≻ (Exp_Cat_morph_ex F'))%nattrans :=
    {|
      Trans := fun d =>
                 {|
                   Trans := fun c => Trans N (d, c);
                   Trans_com :=
                     fun c c' h => @Trans_com _ _ _ _ N (d, c) (d ,c') (id,  h);
                   Trans_com_sym :=
                     fun c c' h => @Trans_com_sym _ _ _ _ N (d, c) (d ,c') (id,  h)
                 |}
    |}.

End Exp_Cat_morph_ex_NT.

Section Exp_Cat_morph_ex_Iso.
  Context {C C' C'' : Category}
          {F F' : (C'' × C) –≻ C'}
          (N : (F ≃ F')%natiso)
  .

  Program Definition Exp_Cat_morph_ex_Iso :
    (Exp_Cat_morph_ex F ≃ Exp_Cat_morph_ex F')%natiso :=
    {|
      iso_morphism := Exp_Cat_morph_ex_NT (iso_morphism N);
      inverse_morphism := Exp_Cat_morph_ex_NT (inverse_morphism N)
    |}.

End Exp_Cat_morph_ex_Iso.

Section Exp_Cat_morph_ex_inverse_NT.
  Context {C C' C'' : Category}
          {F F' : (C'' × C) –≻  C'}
          (N : ((Exp_Cat_morph_ex F) –≻ (Exp_Cat_morph_ex F'))%nattrans).

  Program Definition Exp_Cat_morph_ex_inverse_NT : (F –≻ F')%nattrans :=
    {|
      Trans := fun d => Trans (Trans N (fst d)) (snd d)
    |}.

End Exp_Cat_morph_ex_inverse_NT.

Section Exp_Cat_morph_ex_inverse_Iso.
  Context {C C' C'' : Category}
          {F F' : (C'' × C) –≻  C'}
          (N : (Exp_Cat_morph_ex F ≃ Exp_Cat_morph_ex F')%natiso)
  .

  Program Definition Exp_Cat_morph_ex_inverse_Iso :  (F ≃ F')%natiso :=
    {|
      iso_morphism := Exp_Cat_morph_ex_inverse_NT (iso_morphism N);
      inverse_morphism := Exp_Cat_morph_ex_inverse_NT (inverse_morphism N)
    |}.

End Exp_Cat_morph_ex_inverse_Iso. *)

From Categories Require Import Yoneda.Yoneda.
(* Categories.Yoneda.Yoneda:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Cat.Facts.
From Categories Require Import Functor.Main.
From Categories Require Import Coq_Cats.Type_Cat.Type_Cat.
From Categories Require Import Functor.Representable.Hom_Func.
From Categories Require Import Ext_Cons.Prod_Cat.Prod_Cat Ext_Cons.Prod_Cat.Operations.
From Categories Require Import NatTrans.NatTrans NatTrans.Func_Cat NatTrans.NatIso.

Local Open Scope nattrans_scope.

Section Y_emb.
  Context (C : Category).

  Definition CoYoneda : (C^op –≻ (Func_Cat C Type_Cat))%functor :=
    Exp_Cat_morph_ex (Hom_Func C).

  Definition Yoneda : (C –≻ (Func_Cat (C^op) Type_Cat))%functor :=
    Exp_Cat_morph_ex (Hom_Func (C^op)).

End Y_emb.

Section Y_Left_Right.
  Context (C : Category).

  Definition Y_left :
    ((C^op × (Func_Cat (C^op) Type_Cat)) –≻ Type_Cat)%functor
    :=
      ((Hom_Func _)
         ∘ (Prod_Functor
              ((Yoneda C)^op) (Functor_id (Func_Cat (C^op) Type_Cat))))%functor.
  
  Definition Y_right
    : ((C^op × (Func_Cat (C^op) Type_Cat)) –≻ Type_Cat)%functor :=
    ((Exp_Cat_Eval (C^op) Type_Cat) ∘ (Twist_Func _ _))%functor.

End Y_Left_Right.

Local Obligation Tactic := idtac.

Program Definition Y_left_to_right (C : Category) : (Y_left C) –≻ (Y_right C) :=
{|
  Trans := fun c_F => fun N => ((Trans N (fst c_F))) (id (fst c_F))
|}.

Program Definition Y_right_to_left_NT (C : Category) (c : Obj)
        (F : (C^op –≻ Type_Cat)%functor) (h : (F _o c)%object)
  :
    ((Yoneda _) _o c)%object –≻ F :=
{|
  Trans := fun c' => fun g => (F _a g)%morphism h
|}.

Program Definition Y_right_to_left (C : Category) : (Y_right C) –≻ (Y_left C) :=
{|
  Trans := fun c_F => fun h => Y_right_to_left_NT C (fst c_F) (snd c_F) h
|}.

Program Definition Yoneda_Lemma (C : Category) :
  ((Y_left C) ≃ (Y_right C))%natiso :=
  NatIso _ _ (Y_left_to_right C) (Y_right_to_left C) _ _.

Lemma Yoneda_Faithful (C : Category) : Faithful_Func (Yoneda C).

Lemma Yoneda_Full (C : Category) : Full_Func (Yoneda C).

Definition Yoneda_Emb (C : Category) : Embedding C (Func_Cat (C^op) Type_Cat) :=
{|
  Emb_Func := Yoneda C;
  Emb_Faithful := Yoneda_Faithful C;
  Emb_Full := Yoneda_Full C
|}.

Theorem Yoneda_Iso (C : Category) : forall (c c' : Obj),
    ((Yoneda C) _o c ≃ (Yoneda C) _o c')%isomorphism → (c ≃ c')%isomorphism.

Ltac Yoneda := apply Yoneda_Iso.

Theorem CoYoneda_Iso (C : Category) : forall (c c' : Obj),
    ((CoYoneda C) _o c ≃ (CoYoneda C) _o c')%isomorphism → (c ≃ c')%isomorphism.

Ltac CoYoneda := apply CoYoneda_Iso. *)

From Categories Require Import Functor.Functor_Extender.
(* Categories.Functor.Functor_Extender:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Functor Functor.Functor_Ops.
From Categories Require Import NatTrans.Main.

Local Notation NID := NatTrans_id (only parsing).

Local Hint Extern 1 => progress
                        (repeat (apply NatTrans_eq_simplify; FunExt); cbn in *).

Section Left_Functor_Extender.
  Context {C C' : Category} (p : (C –≻ C')%functor) (D : Category).

    Program Definition Left_Functor_Extender :
      ((Func_Cat C' D) –≻ (Func_Cat C D))%functor :=
      {|
        FO := fun F => (F ∘ p)%functor;
        FA := fun F F' N => (N ∘_h (NID p))%nattrans
      |}.

End Left_Functor_Extender.

Section Right_Functor_Extender.
  Context {C C' : Category} (p : (C –≻ C')%functor) (D : Category).

    Program Definition Right_Functor_Extender :
      ((Func_Cat D C) –≻ (Func_Cat D C'))%functor :=
      {|
        FO := fun F => (p ∘ F)%functor;
        FA := fun F F' N => ((NID p) ∘_h N)%nattrans
      |}.

End Right_Functor_Extender.

Section Left_Functor_Extender_Iso.
  Context {C C' : Category} {p p' : (C –≻ C')%functor}
          (N : (p ≃ p')%natiso) (D : Category).

  Local Hint Extern 1 => (rewrite Trans_com); trivial; fail.
  Local Hint Extern 1 => rewrite <- F_compose.
  Local Hint Extern 1 =>
  match goal with
    [w : @Obj C |- _] =>
    cbn_rewrite (f_equal (fun u => Trans u w) (left_inverse N))
  end.
  Local Hint Extern 1 =>
  match goal with
    [w : @Obj C |- _] =>
    cbn_rewrite (f_equal (fun u => Trans u w) (right_inverse N))
  end.

  Program Definition Left_Functor_Extender_Iso :
    ((Left_Functor_Extender p D) ≃ (Left_Functor_Extender p' D))%natiso
    :=
      {|
        iso_morphism :=
          {|
            Trans :=
              fun e =>
                ((NatTrans_id_Iso e) ∘_h N)%natiso
          |};
        inverse_morphism :=
          {|
            Trans :=
              fun e =>
                ((NatTrans_id_Iso e) ∘_h (N⁻¹))%natiso
          |}
      |}
  .
      
End Left_Functor_Extender_Iso.

Section Right_Functor_Extender_Iso.
  Context {C C' : Category} {p p' : (C –≻ C')%functor}
          (N : (p ≃ p')%natiso) (D : Category).
  
  Local Hint Extern 1 => (rewrite Trans_com); trivial; fail.
  Local Hint Extern 1 => rewrite <- F_compose.
  Local Hint Extern 1 =>
  match goal with
    [w : @Obj D, F : (D –≻ C)%functor |- _] =>
    cbn_rewrite (f_equal (fun u => Trans u (F _o w)%object) (left_inverse N))
    end.
  Local Hint Extern 1 =>
  match goal with
    [w : @Obj D, F : (D –≻ C)%functor |- _] =>
    cbn_rewrite (f_equal (fun u => Trans u (F _o w)%object) (right_inverse N))
    end.

  Program Definition Right_Functor_Extender_Iso :
    ((Right_Functor_Extender p D) ≃ (Right_Functor_Extender p' D))%natiso
    :=
      {|
        iso_morphism :=
          {|
            Trans :=
              fun e =>
                (N ∘_h (NatTrans_id_Iso e))%natiso
          |};
        inverse_morphism :=
          {|
            Trans :=
              fun e =>
                ((N⁻¹) ∘_h (NatTrans_id_Iso e))%natiso
          |}
      |}
  .
 
End Right_Functor_Extender_Iso.

Section Right_Left_Functor_Extension_Iso.
  Context {B C D E : Category} (F : (B –≻ C)%functor) (G : (D –≻ E)%functor).
  
  Program Definition Right_Left_Functor_Extension_Iso :
    (
      (((Right_Functor_Extender G B) ∘ (Left_Functor_Extender F D))%functor)
        ≃ ((Left_Functor_Extender F E) ∘ (Right_Functor_Extender G C))%functor
    )%natiso :=
    {|
      iso_morphism := {|Trans := fun h => NatTrans_Functor_assoc_sym F h G |};
      inverse_morphism := {|Trans := fun h => NatTrans_Functor_assoc F h G |}
    |}.

End Right_Left_Functor_Extension_Iso. *)



Local Open Scope functor_scope.



Section Hom_Adjunct_left_iso.

  Context {C D : Category}

          {F F' : C –≻ D}

          (N : (F' ≃ F)%natiso)

          {G : D –≻ C}

          (adj : F ⊣_hom G)

  .



  Definition Hom_Adjunct_left_iso : F' ⊣_hom G :=

    (adj ∘ ((NatTrans_id_Iso (Hom_Func D))

              ∘_h (Prod_Functor_NatIso

                     (N^op) (NatTrans_id_Iso (Functor_id D))))

    )%isomorphism%natiso.



End Hom_Adjunct_left_iso.



Section Hom_Adjunct_right_iso.

  Context {C D : Category}

          {F : C –≻ D}

          {G G' : D –≻ C}

          (N : (G ≃ G')%natiso)

          (adj : F ⊣_hom G)

  .



  Definition Hom_Adjunct_right_iso : F ⊣_hom G' :=

    Hom_Adjunct_Duality

      (Hom_Adjunct_left_iso

         ((N^op)⁻¹)%isomorphism%natiso (Hom_Adjunct_Duality adj)).



End Hom_Adjunct_right_iso.



Section Adjunct_left_iso.

  Context {C D : Category}

          (F F' : C –≻ D)

          (N : (F' ≃ F)%natiso)

          (G : D –≻ C)

          (adj : F ⊣ G)

  .



  Definition Adjunct_left_iso : F' ⊣ G :=

    Hom_Adj_to_Adj (Hom_Adjunct_left_iso N (Adj_to_Hom_Adj adj)).



End Adjunct_left_iso.



Section Adjunct_right_iso.

  Context {C D : Category}

          (F : C –≻ D)

          (G G' : D –≻ C)

          (N : (G ≃ G')%natiso)

          (adj : F ⊣ G)

  .



  Definition Adjunct_right_iso : F ⊣ G' :=

    Hom_Adj_to_Adj (Hom_Adjunct_right_iso N (Adj_to_Hom_Adj adj)).



End Adjunct_right_iso.



Section Hom_Adjunct_left_unique.

  Context {C D : Category}

          {F F' : C –≻ D}

          {G : D –≻ C}

          (adj : F ⊣_hom G)

          (adj' : F' ⊣_hom G)

  .



  Definition Hom_Adjunct_left_unique : (F ≃ F')%natiso.

  Proof.

    apply (@Opposite_NatIso _ _ (F^op) (F'^op)).

    eapply (Embedding_mono (Yoneda_Emb (D^op))).

    eapply Isomorphism_Compose;

      [eapply Inverse_Isomorphism; apply Exp_Cat_morph_ex_compose_Iso |].

    eapply Isomorphism_Compose; [|apply Exp_Cat_morph_ex_compose_Iso].

    apply Exp_Cat_morph_ex_Iso.

    eapply Isomorphism_Compose.

    apply adj.

    eapply Inverse_Isomorphism.

    apply adj'.

  Defined.



End Hom_Adjunct_left_unique.



Section Hom_Adjunct_right_unique.

  Context {C D : Category}

          {F : C –≻ D}

          {G G' : D –≻ C}

          (adj : F ⊣_hom G)

          (adj' : F ⊣_hom G')

  .



  Theorem Hom_Adjunct_right_unique : (G ≃ G')%natiso.

  Proof.

    apply Hom_Adjunct_Duality in adj.

    apply Hom_Adjunct_Duality in adj'.

    apply (@Opposite_NatIso _ _ (G^op) (G'^op)).

    apply (Hom_Adjunct_left_unique adj adj').

  Defined.



End Hom_Adjunct_right_unique.



Section Adjunct_left_unique.

  Context {C D : Category}

          {F F' : C –≻ D}

          {G : D –≻ C}

          (adj : F ⊣ G)

          (adj' : F' ⊣ G)

  .



  Theorem Adjunct_left_unique : (F ≃ F' )%natiso.

  Proof.

    apply Adj_to_Hom_Adj in adj.

    apply Adj_to_Hom_Adj in adj'.

    eapply Hom_Adjunct_left_unique; eassumption.

  Defined.



End Adjunct_left_unique.



Section Adjunct_right_unique.

  Context {C D : Category}

          {F : C –≻ D}

          {G G' : D –≻ C}

          (adj : F ⊣ G)

          (adj' : F ⊣ G')

  .



  Theorem Adjunct_right_unique : (G ≃ G')%natiso.

  Proof.

    apply Adj_to_Hom_Adj in adj.

    apply Adj_to_Hom_Adj in adj'.

    eapply Hom_Adjunct_right_unique; eassumption.

  Defined.



End Adjunct_right_unique.



Section Hom_Adjunct_Lifted.

  Context {C D : Category}

          {F : C –≻ D}

          {G : D –≻ C}

          (adj : F ⊣_ucu G)

          (B : Category)

  .



  Local Notation NID := NatTrans_id (only parsing).

  Local Notation FCAT := Func_Cat (only parsing).



  Local Notation LEFT :=

    (

      (Hom_Func (Func_Cat B D))

        ∘ (Prod_Functor

             ((Right_Functor_Extender F B)^op)

             (Functor_id (Func_Cat B D))

          )

    )

      (only parsing).



  Local Notation RIGHT :=

    (

      (Hom_Func (Func_Cat B C))

        ∘ (Prod_Functor

             (Functor_id ((Func_Cat B C)^op)%category)

             (Right_Functor_Extender G B)

          )

    )

      (only parsing).



  Local Obligation Tactic := idtac.

  

  Program Definition Hom_Adjunct_Lifted_LR : (LEFT –≻ RIGHT)%nattrans :=

    {|

      Trans := fun c h =>

                 ((((NatTrans_id G) ∘_h h)

                     ∘ ((NatTrans_Functor_assoc (fst c) F G)

                          ∘ ((ucu_adj_unit adj) ∘_h (NatTrans_id (fst c)))))

                    ∘ (NatTrans_to_compose_id _))%nattrans

    |}.



  Next Obligation.

    intros [c1 c2] [c1' c2'] [h1 h2].

    extensionality w.

    apply NatTrans_eq_simplify.

    extensionality x.

    cbn in *.

    repeat rewrite F_id; simpl_ids.

    repeat rewrite F_compose.

    repeat rewrite assoc.

    cbn_rewrite (@Trans_com _ _ _ _ (ucu_adj_unit adj) _ _ (Trans h1 x)).

    trivial.

  Qed.    



  Next Obligation.

    symmetry.

    apply Hom_Adjunct_Lifted_LR_obligation_1.

  Qed.



  Program Definition Hom_Adjunct_Lifted_RL : (RIGHT –≻ LEFT)%nattrans :=

    {|

      Trans := fun c h =>

                 ((NatTrans_from_compose_id _)

                    ∘ ((((ucu_adj_counit adj)

                           ∘_h (NatTrans_id (snd c)))

                          ∘ (NatTrans_Functor_assoc_sym (snd c) G F))

                         ∘ ((NatTrans_id F) ∘_h h)))%nattrans

    |}.

    

  Next Obligation.

    intros [c1 c2] [c1' c2'] [h1 h2].

    extensionality w.

    apply NatTrans_eq_simplify.

    extensionality x.

    cbn in *.

    repeat rewrite F_id; simpl_ids.

    repeat rewrite F_compose.

    repeat rewrite assoc_sym.

    cbn_rewrite (@Trans_com _ _ _ _ (ucu_adj_counit adj) _ _ (Trans h2 x)).

    trivial.

  Qed.    



  Next Obligation.

    symmetry.

    apply Hom_Adjunct_Lifted_RL_obligation_1.

  Qed.



  Program Definition Hom_Adjunct_Lifted : (LEFT ≃ RIGHT)%natiso :=

    {|

      iso_morphism := Hom_Adjunct_Lifted_LR;

      inverse_morphism := Hom_Adjunct_Lifted_RL

    |}.



  Next Obligation.

  Proof.

    apply NatTrans_eq_simplify;

    extensionality c; extensionality h.

    destruct c as [c1 c2].

    apply NatTrans_eq_simplify; extensionality y.

    cbn in *.

    repeat rewrite F_id.

    simpl_ids.

    rewrite F_compose.

    rewrite assoc_sym.

    cbn_rewrite (Trans_com (ucu_adj_counit adj) (Trans h y)). 

    rewrite assoc.

    simpl_ids; trivial.

    set (W := f_equal (fun w => Trans w (c1 _o y)) (ucu_adj_left_id adj));

      cbn in W; simpl_ids in W; apply W.

  Qed.



  Next Obligation.

  Proof.

    apply NatTrans_eq_simplify;

    extensionality c; extensionality h.

    destruct c as [c1 c2].

    apply NatTrans_eq_simplify; extensionality y.

    cbn in *.

    repeat rewrite F_id.

    simpl_ids.

    rewrite F_compose.

    rewrite assoc.

    cbn_rewrite <- (Trans_com (ucu_adj_unit adj) (Trans h y)).

    rewrite assoc_sym.

    simpl_ids; trivial.

    set (W := f_equal (fun w => Trans w (c2 _o y)) (ucu_adj_right_id adj));

      cbn in W;

      repeat rewrite F_compose in W; repeat rewrite F_id in W; simpl_ids in W;

      apply W.

  Qed.



End Hom_Adjunct_Lifted.

