From Categories Require Import Essentials.Notations.
(* Categories.Essentials.Notations:
Notation "∀ x .. y , P" := (forall x, .. (forall y, P) ..)
                             (at level 200, x binder, y binder, right associativity) : type_scope.

Notation "∃ x .. y , P" := (exists x, .. (exists y, P) ..)
  (at level 200, x binder, y binder, right associativity) : type_scope.

Notation "x ∨ y" := (x \/ y) (at level 85, right associativity) : type_scope.

Notation "x ∧ y" := (x /\ y) (at level 80, right associativity) : type_scope.

Notation "x → y" := (x -> y)
  (at level 90, y at level 200, right associativity): type_scope.

Notation "x ↔ y" := (x <-> y) (at level 95, no associativity): type_scope.

Notation "¬ x" := (~x) (at level 75, right associativity) : type_scope.

Notation "x ≠ y" := (x <> y) (at level 70) : type_scope.

Notation "x ≤ y" := (le x y) (at level 70, no associativity).

Notation "x ≥ y" := (ge x y) (at level 70, no associativity).

Reserved Notation "C '^op'" (at level 50, no associativity).

Reserved Notation "a –≻ b" (at level 90, b at level 200, right associativity).

Reserved Notation "f '⁻¹'" (at level 50, no associativity).

Reserved Notation "a ≃ b" (at level 70, no associativity).

Reserved Notation "a ≃≃ b ::> C" (at level 70, no associativity).

Reserved Notation "f ∘ g" (at level 51, right associativity).

Reserved Notation "f '∘_h' g" (at level 51, right associativity).

Reserved Notation "a ≫–> b" (at level 100, no associativity).

Reserved Notation "a –≫ b" (at level 100, no associativity).

Reserved Notation "F '_o'" (at level 50, no associativity).

Reserved Notation "F '_a'" (at level 50, no associativity).

Reserved Notation "F '@_a'" (at level 50, no associativity).

Reserved Notation "F ⊣ G" (at level 100, no associativity).

Reserved Notation "F ⊣_hom G" (at level 100, no associativity).

Reserved Notation "F ⊣_ucu G" (at level 100, no associativity).

Reserved Notation "a × b" (at level 80, no associativity).

Reserved Notation "a ⇑ b" (at level 79, no associativity).

Reserved Notation "'Π' m" (at level 50, no associativity).

Reserved Notation "'Σ' m" (at level 50, no associativity).

Reserved Notation "'Π_' C ↓ m" (at level 50, no associativity).

Reserved Notation "'Σ_' C ↓ m" (at level 50, no associativity).

Delimit Scope category_scope with category.

Delimit Scope morphism_scope with morphism.

Delimit Scope object_scope with object.

Delimit Scope functor_scope with functor.

Delimit Scope nattrans_scope with nattrans.

Delimit Scope nattrans_scope with nattrans.

Delimit Scope natiso_scope with natiso.

Delimit Scope isomorphism_scope with isomorphism.

Delimit Scope preorder_scope with preorder. *)

From Categories Require Import Essentials.Types.
(* Categories.Essentials.Types:
Global Set Primitive Projections.

Global Set Universe Polymorphism.

Global Unset Universe Minimization ToSet.

Inductive Empty : Type :=.

Hint Extern 1 =>
let tac := (repeat intros ?); match goal with [H : Empty |- _] => contradict H end in
match goal with
  | [|- context[Empty]] => tac
  | [H : context[Empty] |- _] => tac
end
.

Record prod (A B : Type) := {fst : A; snd : B}.

Arguments fst {_ _ } _.
Arguments snd {_ _ } _.
Arguments Build_prod {_ _ } _ _.

Notation "( X , Y )" := (Build_prod X Y).
Notation "X * Y" := (prod X Y) : type_scope. *)

From Categories Require Import Essentials.Facts_Tactics.
(* Categories.Essentials.Facts_Tactics:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.

Require Export Coq.Program.Tactics.
Require Export Coq.Program.Equality.
Require Export Coq.Logic.FunctionalExtensionality.
Require Export Coq.Logic.ProofIrrelevance.

Definition equal_f : ∀ {A B : Type} {f g : A → B}, f = g → ∀ x : A, f x = g x.

Definition f_equal : ∀ (A B : Type) (f : A → B) (x y : A), x = y → f x = f y.

Arguments f_equal [_ _] _ [_ _] _.

Ltac basic_simpl :=
  let simpl_prod _ :=
      match goal with
        [H : prod _ _ |- _] =>
        let H1 := fresh H "1" in
        let H2 := fresh H "2" in
        destruct H as [H1 H2]
      end
  in
  let simpl_sig _ :=
      match goal with
        [H : @sig _ _ |- _] =>
        let H1 := fresh H "1" in
        let H2 := fresh H "2" in
        destruct H as [H1 H2]
      end
  in
  let basic_simpl_helper _ :=
      cbn in *; intros;
        repeat simpl_prod tt;
        repeat simpl_sig tt
  in
  repeat basic_simpl_helper tt
.

Global Obligation Tactic := basic_simpl; auto.

Ltac PIR :=
  let pir_helper _ :=
      match goal with
      |[H : ?A, H' : ?A|- _] =>
       match type of A with
       | Prop =>
         destruct (proof_irrelevance _ H H')
       end
      end
  in
  repeat pir_helper tt
.

Ltac ElimEq := repeat match goal with [H : _ = _|- _] => destruct H end.

Hint Extern 1 => progress ElimEq.

Ltac cbn_rewrite W :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite H; clear H
.

Ltac cbn_rewrite_in W V :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite H in V; clear H
.

Ltac cbn_rewrite_back W :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite <- H; clear H
.

Ltac cbn_rewrite_back_in W V :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite <- H in V; clear H
.

Tactic Notation "cbn_rewrite" constr(W) := cbn_rewrite W.
Tactic Notation "cbn_rewrite" constr(W) "in" hyp_list(V) := cbn_rewrite_in W V.
Tactic Notation "cbn_rewrite" "<-" constr(W) := cbn_rewrite_back W.
Tactic Notation "cbn_rewrite" "<-" constr(W) "in" hyp_list(V) := cbn_rewrite_back_in W V.

Lemma sig_proof_irrelevance {A : Type} (P : A → Prop) (X Y : sig P) : proj1_sig X = proj1_sig Y → X = Y.

Hint Extern 2 (exist ?A _ _ = exist ?A _ _) => apply sig_proof_irrelevance.

Ltac FunExt :=
progress (
    repeat (
        match goal with
          [|- _ = _] =>
          let x := fresh "x" in
          extensionality x
        end
      )
  )
.

Hint Extern 1 => FunExt.

Lemma pair_eq (A B : Type) (a b : A * B) : fst a = fst b → snd a = snd b → a = b.

Hint Resolve pair_eq.

Ltac revert_clearbody_all :=
 repeat lazymatch goal with H:_ |- _ => try clearbody H; revert H end.

Ltac hyp_stack :=
 constr:(ltac:(revert_clearbody_all;constructor) : True).

Ltac next_hyp hs step last :=
 lazymatch hs with (?hs' ?H) => step H hs' | _ => last end.

Tactic Notation "dohyps" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := tac H; next_hyp hs step idtac in
 next_hyp hs step idtac.

Tactic Notation "dohyps" "reverse" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := next_hyp hs step idtac; tac H in
 next_hyp hs step idtac.

Tactic Notation "do1hyp" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := tac H + next_hyp hs step fail in
 next_hyp hs step fail.

Tactic Notation "do1hyp" "reverse" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := next_hyp hs step fail + tac H in
 next_hyp hs step fail. *)

From Categories Require Import Category.Main.
(* Categories.Category.Main:
From Categories Require Export Category.Category.
From Categories Require Export Category.Morph.
From Categories Require Export Category.Opposite.
From Categories Require Export Category.SubCategory.
From Categories Require Export Category.Composable_Chain. *)

From Categories Require Import Functor.Main.
(* Categories.Functor.Main:
From Categories Require Export Functor.Functor.
From Categories Require Export Functor.Functor_Extender.
From Categories Require Export Functor.Functor_Image.
From Categories Require Export Functor.Functor_Ops.
From Categories Require Export Functor.Functor_Properties.
From Categories Require Export Functor.Const_Func.
From Categories Require Export Functor.Const_Func_Functor. *)

From Categories Require Import Basic_Cons.Terminal.
(* Categories.Basic_Cons.Terminal:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Main.

Class Terminal (C : Category) : Type :=
{
  terminal : C;
  t_morph : ∀ (d : Obj), (d –≻ terminal)%morphism;
  t_morph_unique : ∀ (d : Obj) (f g : (d –≻ terminal)%morphism), f = g
}.

Arguments terminal {_} _.
Arguments t_morph {_} _ _.
Arguments t_morph_unique {_} _ _ _ _.

Coercion terminal : Terminal >-> Obj.

Notation "𝟙_ C" := (Terminal C) (at level 75) : object_scope.

Theorem Terminal_iso {C : Category} (T T' : (𝟙_ C)%object) :
  (T ≃ T')%isomorphism.

Definition Initial (C : Category) := (𝟙_ (C ^op))%object.
Existing Class Initial.

Notation "𝟘_ C" := (Initial C) (at level 75) : object_scope. *)

From Categories Require Import Ext_Cons.Arrow.
(* Categories.Ext_Cons.Arrow:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Coq_Cats.Type_Cat.Type_Cat.

Section Arrow.
  Local Open Scope morphism_scope.

  Record Arrow (C : Category) :=
    {
      Orig : Obj;
      Targ : Obj;
      Arr : Orig –≻ Targ
    }.

  Arguments Orig {_} _.
  Arguments Targ {_} _.
  Arguments Arr {_} _.

  Coercion Arr : Arrow >-> Hom.

  Record Arrow_Hom {C : Category} (a b : Arrow C) :=
    {
      Arr_H : (Orig a) –≻ (Orig b);
      Arr_H' : (Targ a) –≻ (Targ b);
      Arr_Hom_com : Arr_H' ∘ (Arr a) = (Arr b) ∘ Arr_H
    }.
  Arguments Arr_H {_ _ _} _.
  Arguments Arr_H' {_ _ _} _.
  Arguments Arr_Hom_com {_ _ _} _.

  Context (C : Category).

  Section Arrow_Hom_eq_simplify.
    Context {a b : Arrow C} (f g : Arrow_Hom a b).

    Lemma Arrow_Hom_eq_simplify : Arr_H f = Arr_H g → Arr_H' f = Arr_H' g → f = g.

  End Arrow_Hom_eq_simplify.

  Section Compose_id.
    Context {x y z} (h : Arrow_Hom x y) (h' : Arrow_Hom y z).

    Program Definition Arrow_Hom_compose : Arrow_Hom x z :=
      {|
        Arr_H := (Arr_H h') ∘ (Arr_H h);
        Arr_H' := (Arr_H' h') ∘ (Arr_H' h)
      |}.

    Program Definition Arrow_id : Arrow_Hom x x :=
      {|
        Arr_H := id;
        Arr_H' := id
      |}.

  End Compose_id.

End Arrow.

Hint Extern 1 (?A = ?B :> Arrow_Hom _ _) => apply Arrow_Hom_eq_simplify; simpl.

Arguments Orig {_} _.
Arguments Targ {_} _.
Arguments Arr {_} _.

Arguments Arr_H {_ _ _} _.
Arguments Arr_H' {_ _ _} _.
Arguments Arr_Hom_com {_ _ _} _.

Program Definition Arrow_to_Arrow_OP (C : Category) (ar : Arrow C) :
  Arrow (C ^op) :=
  {|
    Arr := ar
  |}.

Program Definition Arrow_OP_Iso (C : Category) :
  ((Arrow C) ≃≃ (Arrow (C ^op)) ::> Type_Cat)%isomorphism :=
  {|
    iso_morphism := Arrow_to_Arrow_OP C;
    inverse_morphism := Arrow_to_Arrow_OP (C ^op)
  |}. *)

From Categories Require Import Coq_Cats.Type_Cat.Card_Restriction.
(* Categories.Coq_Cats.Type_Cat.Card_Restriction:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Coq_Cats.Type_Cat.Type_Cat.

Record Card_Restriction : Type :=
{
  Card_Rest : Type → Prop;

  Card_Rest_Respect : ∀ (A B : Type),
      (A ≃≃ B ::> Type_Cat)%isomorphism → Card_Rest A → Card_Rest B
}.

Coercion Card_Rest : Card_Restriction >-> Funclass.

Program Definition Finite : Card_Restriction :=
  {|
    Card_Rest :=
      fun A => inhabited {n : nat & (A ≃≃ {x : nat | x < n} ::> Type_Cat)%isomorphism}
  |}. *)

From Categories Require Export NatTrans.NatTrans NatTrans.Operations.

From Categories Require Export KanExt.Local KanExt.Global KanExt.GlobalDuality

        KanExt.GlobaltoLocal KanExt.LocaltoGlobal KanExt.LocalFacts.Main.

From Categories Require Export Cat.Terminal.



Local Open Scope functor_scope.



Section Limit.

  Context {J C : Category} (D : J –≻ C).



  Definition Cone := LoKan_Cone (Functor_To_1_Cat J) D.



  Definition Cone_Morph Cn Cn' :=

    @LoKan_Cone_Morph _ _ (Functor_To_1_Cat J) _ D Cn Cn'.

  

  Definition Limit : Type := Local_Right_KanExt (Functor_To_1_Cat J) D.



  Definition limit_to_cone (l : Limit) : Cone := (LRKE l).



  Coercion limit_to_cone : Limit >-> Cone.

  

  Definition cone_to_obj (cn : Cone) : C := (cone_apex cn) _o tt.



  Coercion cone_to_obj : Cone >-> Obj.



  Definition is_Limit (Cn : Cone) :=

    is_Cone_Local_Right_KanExt (Functor_To_1_Cat J) D Cn.



  Definition is_Limit_Limit {Cn : Cone} (il : is_Limit Cn) : Limit :=

    is_Cone_Local_Right_KanExt_Local_Right_KanExt (Functor_To_1_Cat J) D il.



  Definition Limit_is_Limit {L : Limit} : is_Limit L :=

    Local_Right_KanExt_is_Cone_Local_Right_KanExt (Functor_To_1_Cat J) D L.

  

End Limit.



Program Definition Limit_Iso {J C : Category} {D : J –≻ C} (l l' : Limit D) :

  (l ≃≃ l' ::> C)%isomorphism :=

  {|

    iso_morphism :=

      Trans

        (cone_morph (iso_morphism (Local_Right_KanExt_unique _ _ l l')))

        tt;

    inverse_morphism :=

      Trans

        (cone_morph (inverse_morphism (Local_Right_KanExt_unique _ _ l l')))

        tt

  |}.



Next Obligation.

Proof (

    f_equal

      (fun x : LoKan_Cone_Morph l l => Trans (cone_morph x) tt)

      (left_inverse (Local_Right_KanExt_unique _ _ l l'))

  ).



Next Obligation.

Proof (

    f_equal

      (fun x : LoKan_Cone_Morph l' l' => Trans (cone_morph x) tt)

      (right_inverse (Local_Right_KanExt_unique _ _ l l'))

  ).



Definition Has_Restr_Limits (C : Category) (P : Card_Restriction) :=

  ∀ {J : Category} (D : J –≻ C), P J → P (Arrow J) → Limit D.



Definition Complete (C : Category) :=

  ∀ J : Category, Right_KanExt (Functor_To_1_Cat J) C.



Existing Class Complete.



Definition LimitOf {C D : Category} {H : Complete D} (F : C –≻ D) : Limit F :=

  Global_to_Local_Right _ _ (H _) F.



Section Restricted_Limits_to_Complete.

  Context {C : Category} {P : Card_Restriction} (HRL : Has_Restr_Limits C P).



  Definition No_Restriction_Complete : (∀ t, P t) → Complete C :=

    fun All_Ps J => Local_to_Global_Right

                   _ _ (fun D => HRL _ D (All_Ps J) (All_Ps (Arrow J))).



End Restricted_Limits_to_Complete.



Section Complete_to_Restricted_Limits.

  Context (C : Category) {CC : Complete C} (P : Card_Restriction).

  

  Definition Complete_Has_Restricted_Limits : Has_Restr_Limits C P :=

    fun J D _ _ => Global_to_Local_Right _ _ (CC _) D.



End Complete_to_Restricted_Limits.



Section Continuous.

  Context

    {C D : Category}

    (CC : Complete C)

    (G : (C –≻ D)%functor)

  .



  Section Cone_Conv.

    Context

      {J : Category}

      {F : (J –≻ C)%functor}

      (Cn : Cone F)

    .

    

    Program Definition Cone_Conv : Cone (G ∘ F)%functor

      :=

        {|

          cone_apex :=

            (G ∘ (cone_apex Cn))%functor;

          cone_edge :=

            (((NatTrans_id G)

                ∘_h (cone_edge Cn)) ∘ (NatTrans_Functor_assoc _ _ _))%nattrans

        |}

    .



  End Cone_Conv.



  Definition Continuous :=

    ∀ (J : Category) (F : (J –≻ C)%functor),

      is_Cone_Local_Right_KanExt _ _ (Cone_Conv (LRKE (LimitOf F)))

  .



End Continuous.



Section CoLimit.

  Context {J C : Category} (D : J –≻ C).



  Definition CoCone :=

    LoKan_Cone (Functor_To_1_Cat J^op) (D^op).



  Definition CoCone_Morph Cn Cn' :=

    @LoKan_Cone_Morph _ _ (Functor_To_1_Cat J^op) _ (D^op) Cn Cn'.



  Definition CoLimit := Local_Left_KanExt (Functor_To_1_Cat J) D.



  Definition is_CoLimit (Cn : CoCone) :=

    is_Cone_Local_Right_KanExt (Functor_To_1_Cat (J^op)) (D^op) Cn.



  Definition is_CoLimit_CoLimit {Cn : CoCone} (il : is_CoLimit Cn) : CoLimit :=

    is_Cone_Local_Right_KanExt_Local_Right_KanExt

      (Functor_To_1_Cat (J^op)) (D^op) il.



  Definition CoLimit_is_CoLimit {L : CoLimit} : is_CoLimit L :=

    Local_Right_KanExt_is_Cone_Local_Right_KanExt

      (Functor_To_1_Cat (J^op)) (D^op) L.



End CoLimit.



Definition Has_Restr_CoLimits (C : Category) (P : Card_Restriction) :=

  ∀ {J : Category} (D : J –≻ C), P J → P (Arrow J) → CoLimit D.



Definition CoComplete (C : Category) :=

  ∀ J : Category, Left_KanExt (Functor_To_1_Cat J) C.



Existing Class CoComplete.



Definition CoLimitOf {C D : Category} {H : CoComplete D} (F : C –≻ D) :

  CoLimit F := Global_to_Local_Left _ _ (H _) F.



Definition Complete_to_CoComplete_Op {C : Category} {CC : Complete C}

  : CoComplete (C ^op) :=

fun D => KanExt_Right_to_Left (Functor_To_1_Cat D ^op) C (CC (D ^op)%category).



Definition CoComplete_to_Complete_Op {C : Category} {CC : CoComplete C}

  : Complete (C ^op) :=

    fun D => KanExt_Left_to_Right (Functor_To_1_Cat D ^op) C (CC (D ^op)%category).



Section Restricted_CoLimits_to_CoComplete.

  Context {C : Category} {P : Card_Restriction} (HRL : Has_Restr_CoLimits C P).



  Definition No_Restriction_CoComplete : (∀ t, P t) → CoComplete C :=

    fun All_Ps J =>

      Local_to_Global_Left _ _ (fun D => HRL _ D (All_Ps J) (All_Ps (Arrow J))).



End Restricted_CoLimits_to_CoComplete.



Section CoComplete_to_Restricted_CoLimits.

  Context (C : Category) {CC : CoComplete C} (P : Card_Restriction).

  

  Definition CoComplete_Has_Restricted_CoLimits : Has_Restr_CoLimits C P :=

    fun J D _ _ => Global_to_Local_Left _ _ (CC _) D.



End CoComplete_to_Restricted_CoLimits.



Definition Has_Restr_Limits_to_Has_Restr_CoLimits_Op

        {C : Category} {P : Card_Restriction}

        (HRL : Has_Restr_Limits C P) :

  Has_Restr_CoLimits (C ^op) P :=

  (fun (D : Category)

       (F : D –≻ C ^op)

       (H1 : P D)

       (H2 : P (Arrow D)) =>

     HRL

       (D ^op)%category

       (F ^op)%functor H1

       (Card_Rest_Respect P (Arrow D) (Arrow (D^op)) (Arrow_OP_Iso D) H2)

  ).



Definition Has_Restr_CoLimits_to_Has_Restr_Limits_Op

        {C : Category}

        {P : Card_Restriction}

        (HRL : Has_Restr_CoLimits C P) :

  Has_Restr_Limits (C ^op) P :=

  (fun (D : Category)

       (F : D –≻ C ^op)

       (H1 : P D)

       (H2 : P (Arrow D)) =>

     HRL

       (D ^op)%category

       (F ^op)%functor

       H1

       (Card_Rest_Respect P (Arrow D) (Arrow (D^op)) (Arrow_OP_Iso D) H2)

  ).



Section CoContinuous.

  Context

    {C D : Category}

    (CC : CoComplete C)

    (G : (C –≻ D)%functor)

  .



  Section CoCone_Conv.

    Context

      {J : Category}

      {F : (J –≻ C)%functor}

      (Cn : CoCone F)

    .

    

    Program Definition CoCone_Conv : CoCone (G ∘ F)%functor

      :=

        {|

          cone_apex :=

            ((G ^op) ∘ (cone_apex Cn))%functor;

          cone_edge := _

                         (((NatTrans_id (G ^op)) ∘_h (cone_edge Cn))

                            ∘ (NatTrans_Functor_assoc _ _ _))%nattrans

        |}

    .



  End CoCone_Conv.



  Definition CoContinuous :=

    ∀ (J : Category) (F : (J –≻ C)%functor),

      is_Cone_Local_Right_KanExt _ _ (CoCone_Conv (LRKE (CoLimitOf F)))

  .



End CoContinuous.

