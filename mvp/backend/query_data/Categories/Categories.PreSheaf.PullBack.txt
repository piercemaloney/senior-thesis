From Categories Require Import Essentials.Notations.
(* Categories.Essentials.Notations:
Notation "‚àÄ x .. y , P" := (forall x, .. (forall y, P) ..)
                             (at level 200, x binder, y binder, right associativity) : type_scope.

Notation "‚àÉ x .. y , P" := (exists x, .. (exists y, P) ..)
  (at level 200, x binder, y binder, right associativity) : type_scope.

Notation "x ‚à® y" := (x \/ y) (at level 85, right associativity) : type_scope.

Notation "x ‚àß y" := (x /\ y) (at level 80, right associativity) : type_scope.

Notation "x ‚Üí y" := (x -> y)
  (at level 90, y at level 200, right associativity): type_scope.

Notation "x ‚Üî y" := (x <-> y) (at level 95, no associativity): type_scope.

Notation "¬¨ x" := (~x) (at level 75, right associativity) : type_scope.

Notation "x ‚â† y" := (x <> y) (at level 70) : type_scope.

Notation "x ‚â§ y" := (le x y) (at level 70, no associativity).

Notation "x ‚â• y" := (ge x y) (at level 70, no associativity).

Reserved Notation "C '^op'" (at level 50, no associativity).

Reserved Notation "a ‚Äì‚âª b" (at level 90, b at level 200, right associativity).

Reserved Notation "f '‚Åª¬π'" (at level 50, no associativity).

Reserved Notation "a ‚âÉ b" (at level 70, no associativity).

Reserved Notation "a ‚âÉ‚âÉ b ::> C" (at level 70, no associativity).

Reserved Notation "f ‚àò g" (at level 51, right associativity).

Reserved Notation "f '‚àò_h' g" (at level 51, right associativity).

Reserved Notation "a ‚â´‚Äì> b" (at level 100, no associativity).

Reserved Notation "a ‚Äì‚â´ b" (at level 100, no associativity).

Reserved Notation "F '_o'" (at level 50, no associativity).

Reserved Notation "F '_a'" (at level 50, no associativity).

Reserved Notation "F '@_a'" (at level 50, no associativity).

Reserved Notation "F ‚ä£ G" (at level 100, no associativity).

Reserved Notation "F ‚ä£_hom G" (at level 100, no associativity).

Reserved Notation "F ‚ä£_ucu G" (at level 100, no associativity).

Reserved Notation "a √ó b" (at level 80, no associativity).

Reserved Notation "a ‚áë b" (at level 79, no associativity).

Reserved Notation "'Œ†' m" (at level 50, no associativity).

Reserved Notation "'Œ£' m" (at level 50, no associativity).

Reserved Notation "'Œ†_' C ‚Üì m" (at level 50, no associativity).

Reserved Notation "'Œ£_' C ‚Üì m" (at level 50, no associativity).

Delimit Scope category_scope with category.

Delimit Scope morphism_scope with morphism.

Delimit Scope object_scope with object.

Delimit Scope functor_scope with functor.

Delimit Scope nattrans_scope with nattrans.

Delimit Scope nattrans_scope with nattrans.

Delimit Scope natiso_scope with natiso.

Delimit Scope isomorphism_scope with isomorphism.

Delimit Scope preorder_scope with preorder. *)

From Categories Require Import Essentials.Types.
(* Categories.Essentials.Types:
Global Set Primitive Projections.

Global Set Universe Polymorphism.

Global Unset Universe Minimization ToSet.

Inductive Empty : Type :=.

Hint Extern 1 =>
let tac := (repeat intros ?); match goal with [H : Empty |- _] => contradict H end in
match goal with
  | [|- context[Empty]] => tac
  | [H : context[Empty] |- _] => tac
end
.

Record prod (A B : Type) := {fst : A; snd : B}.

Arguments fst {_ _ } _.
Arguments snd {_ _ } _.
Arguments Build_prod {_ _ } _ _.

Notation "( X , Y )" := (Build_prod X Y).
Notation "X * Y" := (prod X Y) : type_scope. *)

From Categories Require Import Essentials.Facts_Tactics.
(* Categories.Essentials.Facts_Tactics:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.

Require Export Coq.Program.Tactics.
Require Export Coq.Program.Equality.
Require Export Coq.Logic.FunctionalExtensionality.
Require Export Coq.Logic.ProofIrrelevance.

Definition equal_f : ‚àÄ {A B : Type} {f g : A ‚Üí B}, f = g ‚Üí ‚àÄ x : A, f x = g x.

Definition f_equal : ‚àÄ (A B : Type) (f : A ‚Üí B) (x y : A), x = y ‚Üí f x = f y.

Arguments f_equal [_ _] _ [_ _] _.

Ltac basic_simpl :=
  let simpl_prod _ :=
      match goal with
        [H : prod _ _ |- _] =>
        let H1 := fresh H "1" in
        let H2 := fresh H "2" in
        destruct H as [H1 H2]
      end
  in
  let simpl_sig _ :=
      match goal with
        [H : @sig _ _ |- _] =>
        let H1 := fresh H "1" in
        let H2 := fresh H "2" in
        destruct H as [H1 H2]
      end
  in
  let basic_simpl_helper _ :=
      cbn in *; intros;
        repeat simpl_prod tt;
        repeat simpl_sig tt
  in
  repeat basic_simpl_helper tt
.

Global Obligation Tactic := basic_simpl; auto.

Ltac PIR :=
  let pir_helper _ :=
      match goal with
      |[H : ?A, H' : ?A|- _] =>
       match type of A with
       | Prop =>
         destruct (proof_irrelevance _ H H')
       end
      end
  in
  repeat pir_helper tt
.

Ltac ElimEq := repeat match goal with [H : _ = _|- _] => destruct H end.

Hint Extern 1 => progress ElimEq.

Ltac cbn_rewrite W :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite H; clear H
.

Ltac cbn_rewrite_in W V :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite H in V; clear H
.

Ltac cbn_rewrite_back W :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite <- H; clear H
.

Ltac cbn_rewrite_back_in W V :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite <- H in V; clear H
.

Tactic Notation "cbn_rewrite" constr(W) := cbn_rewrite W.
Tactic Notation "cbn_rewrite" constr(W) "in" hyp_list(V) := cbn_rewrite_in W V.
Tactic Notation "cbn_rewrite" "<-" constr(W) := cbn_rewrite_back W.
Tactic Notation "cbn_rewrite" "<-" constr(W) "in" hyp_list(V) := cbn_rewrite_back_in W V.

Lemma sig_proof_irrelevance {A : Type} (P : A ‚Üí Prop) (X Y : sig P) : proj1_sig X = proj1_sig Y ‚Üí X = Y.

Hint Extern 2 (exist ?A _ _ = exist ?A _ _) => apply sig_proof_irrelevance.

Ltac FunExt :=
progress (
    repeat (
        match goal with
          [|- _ = _] =>
          let x := fresh "x" in
          extensionality x
        end
      )
  )
.

Hint Extern 1 => FunExt.

Lemma pair_eq (A B : Type) (a b : A * B) : fst a = fst b ‚Üí snd a = snd b ‚Üí a = b.

Hint Resolve pair_eq.

Ltac revert_clearbody_all :=
 repeat lazymatch goal with H:_ |- _ => try clearbody H; revert H end.

Ltac hyp_stack :=
 constr:(ltac:(revert_clearbody_all;constructor) : True).

Ltac next_hyp hs step last :=
 lazymatch hs with (?hs' ?H) => step H hs' | _ => last end.

Tactic Notation "dohyps" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := tac H; next_hyp hs step idtac in
 next_hyp hs step idtac.

Tactic Notation "dohyps" "reverse" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := next_hyp hs step idtac; tac H in
 next_hyp hs step idtac.

Tactic Notation "do1hyp" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := tac H + next_hyp hs step fail in
 next_hyp hs step fail.

Tactic Notation "do1hyp" "reverse" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := next_hyp hs step fail + tac H in
 next_hyp hs step fail. *)

From Categories Require Import Category.Main.
(* Categories.Category.Main:
From Categories Require Export Category.Category.
From Categories Require Export Category.Morph.
From Categories Require Export Category.Opposite.
From Categories Require Export Category.SubCategory.
From Categories Require Export Category.Composable_Chain. *)

From Categories Require Import Functor.Main.
(* Categories.Functor.Main:
From Categories Require Export Functor.Functor.
From Categories Require Export Functor.Functor_Extender.
From Categories Require Export Functor.Functor_Image.
From Categories Require Export Functor.Functor_Ops.
From Categories Require Export Functor.Functor_Properties.
From Categories Require Export Functor.Const_Func.
From Categories Require Export Functor.Const_Func_Functor. *)

From Categories Require Import Basic_Cons.CCC Basic_Cons.PullBack.
(* Categories.Basic_Cons.CCC:
From Categories Require Import Essentials.Notations.
From Categories Require Import Category.Main.
From Categories Require Export Basic_Cons.Terminal.
From Categories Require Export Basic_Cons.Product.
From Categories Require Export Basic_Cons.Exponential.
From Categories Require Export Basic_Cons.Exponential_Functor.

Class CCC (C : Category) : Type :=
{
  CCC_term : (ùüô_ C)%object;
  CCC_HP : Has_Products C;
  CCC_HEXP : Has_Exponentials C
}.

Arguments CCC_term _ {_}, {_ _}.
Arguments CCC_HP _ {_} _ _, {_ _} _ _.
Arguments CCC_HEXP _ {_} _ _, {_ _} _ _.

Existing Instances CCC_term CCC_HP CCC_HEXP. *)
(* Categories.Basic_Cons.PullBack:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.

Local Open Scope morphism_scope.

Section PullBack.
  Context {C : Category} {a b x : C} (f : a ‚Äì‚âª x) (g : b ‚Äì‚âª x).

  Record PullBack : Type :=
    {
      pullback : C;

      pullback_morph_1 : pullback ‚Äì‚âª a;

      pullback_morph_2 : pullback ‚Äì‚âª b;

      pullback_morph_com : f ‚àò pullback_morph_1 = g ‚àò pullback_morph_2;

      pullback_morph_ex (p' : Obj) (pm1 : p' ‚Äì‚âª a) (pm2 : p' ‚Äì‚âª b) :
        f ‚àò pm1 = g ‚àò pm2 ‚Üí p' ‚Äì‚âª pullback;

      pullback_morph_ex_com_1 (p' : Obj) (pm1 : p' ‚Äì‚âª a) (pm2 : p' ‚Äì‚âª b)
                              (pmc : f ‚àò pm1 = g ‚àò pm2)
      :
        pullback_morph_1 ‚àò (pullback_morph_ex p' pm1 pm2 pmc) = pm1;

      pullback_morph_ex_com_2 (p' : Obj) (pm1 : p' ‚Äì‚âª a) (pm2 : p' ‚Äì‚âª b)
                              (pmc : f ‚àò pm1 = g ‚àò pm2)
      :
        pullback_morph_2 ‚àò (pullback_morph_ex p' pm1 pm2 pmc) = pm2;

      pullback_morph_ex_unique
        (p' : Obj) (pm1 : p' ‚Äì‚âª a) (pm2 : p' ‚Äì‚âª b)
        (pmc : f ‚àò pm1 = g ‚àò pm2) (u u' : p' ‚Äì‚âª pullback) :
        pullback_morph_1 ‚àò u = pm1 ‚Üí
        pullback_morph_2 ‚àò u = pm2 ‚Üí
        pullback_morph_1 ‚àò u' = pm1 ‚Üí
        pullback_morph_2 ‚àò u' = pm2 ‚Üí u = u'
    }.

  Coercion pullback : PullBack >-> Obj.

  Theorem PullBack_iso (p1 p2 : PullBack) : (p1 ‚âÉ p2)%isomorphism.

End PullBack.

Section is_PullBack.
  Context {C : Category} {a b x pb : C} (p1 : pb ‚Äì‚âª a)
          (p2 : pb ‚Äì‚âª b) (f : a ‚Äì‚âª x) (g : b ‚Äì‚âª x).

  Local Open Scope morphism_scope.
  
  Record is_PullBack : Type :=
    {
      is_pullback_morph_com : f ‚àò p1 = g ‚àò p2;

      is_pullback_morph_ex (p' : Obj) (pm1 : p' ‚Äì‚âª a) (pm2 : p' ‚Äì‚âª b) :
        f ‚àò pm1 = g ‚àò pm2 ‚Üí p' ‚Äì‚âª pb;

      is_pullback_morph_ex_com_1 (p' : Obj) (pm1 : p' ‚Äì‚âª a) (pm2 : p' ‚Äì‚âª b)
                                 (pmc : f ‚àò pm1 = g ‚àò pm2)
      :
        p1 ‚àò (is_pullback_morph_ex p' pm1 pm2 pmc) = pm1;

      is_pullback_morph_ex_com_2 (p' : Obj) (pm1 : p' ‚Äì‚âª a) (pm2 : p' ‚Äì‚âª b)
                                 (pmc : f ‚àò pm1 = g ‚àò pm2)
      :
        p2 ‚àò (is_pullback_morph_ex p' pm1 pm2 pmc) = pm2;

      is_pullback_morph_ex_unique
        (p' : Obj) (pm1 : p' ‚Äì‚âª a) (pm2 : p' ‚Äì‚âª b)
        (pmc : f ‚àò pm1 = g ‚àò pm2) (u u' : p' ‚Äì‚âª pb) :
        p1 ‚àò u = pm1 ‚Üí
        p2 ‚àò u = pm2 ‚Üí
        p1 ‚àò u' = pm1 ‚Üí
        p2 ‚àò u' = pm2 ‚Üí u = u'
    }.

End is_PullBack.

Definition Has_PullBacks (C : Category) : Type :=
  ‚àÄ (a b c : C) (f : a ‚Äì‚âª c) (g : b ‚Äì‚âª c), PullBack f g.

Existing Class Has_PullBacks.

Arguments PullBack _ {_ _ _} _ _, {_ _ _ _} _ _.
Arguments pullback {_ _ _ _ _ _} _.
Arguments pullback_morph_1 {_ _ _ _ _ _} _.
Arguments pullback_morph_2 {_ _ _ _ _ _} _.
Arguments pullback_morph_com {_ _ _ _ _ _} _.
Arguments pullback_morph_ex {_ _ _ _ _ _} _ _ _ _ _.
Arguments pullback_morph_ex_com_1 {_ _ _ _ _ _} _ _ _ _ _.
Arguments pullback_morph_ex_com_2 {_ _ _ _ _ _} _ _ _ _ _.
Arguments pullback_morph_ex_unique {_ _ _ _ _ _} _ _ _ _ _ _ _ _ _ _ _.

Arguments is_PullBack _ { _ _ _ _} _ _ _ _, {_ _ _ _ _ } _ _ _ _.

Arguments is_pullback_morph_com {_ _ _ _ _ _ _ _ _} _.
Arguments is_pullback_morph_ex {_ _ _ _ _ _ _ _ _} _ _ _ _ _.
Arguments is_pullback_morph_ex_com_1 {_ _ _ _ _ _ _ _ _} _ _ _ _ _.
Arguments is_pullback_morph_ex_com_2 {_ _ _ _ _ _ _ _ _} _ _ _ _ _.
Arguments is_pullback_morph_ex_unique {_ _ _ _ _ _ _ _ _} _ _ _ _ _ _ _ _ _ _ _.

Section is_PullBack_PullBack.
  Context {C : Category} {a b x pb : C} {p1 : pb ‚Äì‚âª a} {p2 : pb ‚Äì‚âª b} {f : a ‚Äì‚âª x}
          {g : b ‚Äì‚âª x} (iPB : is_PullBack p1 p2 f g).

  Definition is_PullBack_PullBack : PullBack f g :=
    {|
      pullback := pb;
      pullback_morph_1 := p1;
      pullback_morph_2 := p2;
      pullback_morph_com := is_pullback_morph_com iPB;
      pullback_morph_ex := fun p' pm1 pm2 => is_pullback_morph_ex iPB p' pm1 pm2;
      pullback_morph_ex_com_1 :=
        fun p' pm1 pm2 pmc => is_pullback_morph_ex_com_1 iPB p' pm1 pm2 pmc;
      pullback_morph_ex_com_2 :=
        fun p' pm1 pm2 pmc => is_pullback_morph_ex_com_2 iPB p' pm1 pm2 pmc;
      pullback_morph_ex_unique :=
        fun p' pm1 pm2 pmc u u' => is_pullback_morph_ex_unique iPB p' pm1 pm2 pmc u u'
    |}.

End is_PullBack_PullBack.

Section PullBack_is_PullBack.
  Context {C : Category} {a b x : C} {f : a ‚Äì‚âª x}
          {g : b ‚Äì‚âª x} (PB : PullBack f g).

  Definition PullBack_is_PullBack :
    is_PullBack (pullback_morph_1 PB) (pullback_morph_2 PB) f g :=
    {|
      is_pullback_morph_com := pullback_morph_com PB;
      is_pullback_morph_ex := fun p' pm1 pm2 => pullback_morph_ex PB p' pm1 pm2;
      is_pullback_morph_ex_com_1 :=
        fun p' pm1 pm2 pmc => pullback_morph_ex_com_1 PB p' pm1 pm2 pmc;
      is_pullback_morph_ex_com_2 :=
        fun p' pm1 pm2 pmc => pullback_morph_ex_com_2 PB p' pm1 pm2 pmc;
      is_pullback_morph_ex_unique :=
        fun p' pm1 pm2 pmc u u' => pullback_morph_ex_unique PB p' pm1 pm2 pmc u u'
    |}.

End PullBack_is_PullBack.
  
Definition PushOut (C : Category) := @PullBack (C^op).

Arguments PushOut _ {_ _ _} _ _, {_ _ _ _} _ _.

Definition Has_PushOuts (C : Category) : Type :=
  ‚àÄ (a b c : C) (f : c ‚Äì‚âª a) (g : c ‚Äì‚âª b), PushOut f g.

Existing Class Has_PushOuts. *)

From Categories Require Import NatTrans.NatTrans NatTrans.Func_Cat.
(* Categories.NatTrans.NatTrans:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Functor.
From Categories Require Import Cat.Cat.

Section NatTrans.
  Context {C C' : Category}.

  Record NatTrans (F F' : (C ‚Äì‚âª C')%functor) :=
    {
      Trans (c : C) : ((F _o c) ‚Äì‚âª (F' _o c))%object%morphism;
      Trans_com {c c' : C} (h : (c ‚Äì‚âª c')%morphism) :
        ((Trans c') ‚àò F _a h = F' _a h ‚àò (Trans c))%morphism;
      Trans_com_sym {c c' : C} (h : (c ‚Äì‚âª c')%morphism) :
        (F' _a h ‚àò (Trans c) = (Trans c') ‚àò F _a h)%morphism
    }.

  Notation "F ‚Äì‚âª F'" := (NatTrans F F') : nattrans_scope.

  Lemma NatTrans_eq_simplify {F F' : (C ‚Äì‚âª C')%functor}
        (N N' : (F ‚Äì‚âª F')%nattrans) : (@Trans _ _ N) = (@Trans _ _ N') -> N = N'.

End NatTrans.

Arguments Trans {_ _ _ _} _ _.
Arguments Trans_com {_ _ _ _} _ {_ _} _.
Arguments Trans_com_sym {_ _ _ _} _ {_ _} _.

Bind Scope nattrans_scope with NatTrans.

Notation "F ‚Äì‚âª F'" := (NatTrans F F') : nattrans_scope.

Local Open Scope nattrans_scope.

Section NatTrans_Compose.
  Context {C C' : Category}.
  
  Program Definition NatTrans_compose {F F' F'' : (C ‚Äì‚âª C')%functor}
          (tr : F ‚Äì‚âª F') (tr' : F' ‚Äì‚âª F'') : (F ‚Äì‚âª F'')%nattrans :=
    {|
      Trans := fun c : Obj => ((Trans tr' c) ‚àò (Trans tr c)) % morphism
    |}.

End NatTrans_Compose.

Notation "N ‚àò N'" := (NatTrans_compose N' N) : nattrans_scope.

Section NatTrans_Props.
  Context {C C' : Category}.
  
  Theorem NatTrans_compose_assoc {F G H I : (C ‚Äì‚âª C')%functor} (N : F ‚Äì‚âª G)
          (N' : G ‚Äì‚âª H) (N'' : H ‚Äì‚âª I)
    : ((N'' ‚àò N') ‚àò N = N'' ‚àò (N' ‚àò N))%nattrans
  .

  Program Definition NatTrans_id (F : (C ‚Äì‚âª C')%functor) : F ‚Äì‚âª F :=
    {|
      Trans := fun x : Obj => id
    |}.

  Theorem NatTrans_id_unit_left {F G : (C ‚Äì‚âª C')%functor} (N : F ‚Äì‚âª G)
    : (NatTrans_id G) ‚àò N = N.

  Theorem NatTrans_id_unit_right {F G : (C ‚Äì‚âª C')%functor} (N : F ‚Äì‚âª G)
    : N ‚àò (NatTrans_id F) = N.
  
End NatTrans_Props.

Hint Resolve NatTrans_eq_simplify. *)
(* Categories.NatTrans.Func_Cat:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Functor Functor.Functor_Ops.
From Categories Require Import Cat.Cat.
From Categories Require Import NatTrans.NatTrans NatTrans.Operations.

Program Definition Func_Cat (C C' : Category) : Category :=
{|
  Obj := (C ‚Äì‚âª C')%functor;

  Hom := NatTrans;

  compose := @NatTrans_compose _ _;

  id := @NatTrans_id _ _;

  assoc := fun _ _ _ _ _ _ _ => @NatTrans_compose_assoc _ _ _ _ _ _ _ _ _;
             
  assoc_sym :=
    fun _ _ _ _ _ _ _ => eq_sym (@NatTrans_compose_assoc _ _ _ _ _ _ _ _ _);

  id_unit_right := @NatTrans_id_unit_right _ _;
  
  id_unit_left := @NatTrans_id_unit_left _ _
|}.

Section Opposite_Func_Cat.
  Context (C D : Category).

  Program Definition Op_Func_Cat_to_Func_Cat_Op
    : ((Func_Cat C D)^op ‚Äì‚âª (Func_Cat (C^op) (D^op)))%functor :=
    {|
      FO := Opposite_Functor;
      FA := fun _ _ => Opposite_NatTrans;
      F_id := fun _ => NatTrans_id_Op _;
      F_compose := fun _ _ _ _ _ => NatTrans_compose_Op _ _ 
    |}.

  Program Definition Func_Cat_Op_to_Op_Func_Cat
    : ((Func_Cat (C^op) (D^op)) ‚Äì‚âª (Func_Cat C D)^op)%functor :=
    {|
      FO := Opposite_Functor;
      FA := fun _ _ => Opposite_NatTrans;
      F_id := fun F => NatTrans_id_Op F;
      F_compose := fun _ _ _ N N' => NatTrans_compose_Op N N'
    |}.
  
  Program Definition Func_Cat_Op_Iso
    : ((((Func_Cat C D)^op)%category)
         ‚âÉ‚âÉ (Func_Cat (C^op) (D^op)) ::> Cat) %isomorphism :=
    {|
      iso_morphism := Op_Func_Cat_to_Func_Cat_Op;
      inverse_morphism := Func_Cat_Op_to_Op_Func_Cat
    |}.

End Opposite_Func_Cat. *)

From Categories Require Import Coq_Cats.Type_Cat.Type_Cat.
(* Categories.Coq_Cats.Type_Cat.Type_Cat:
From Categories Require Import Category.Main.
From Categories Require Import Coq_Cats.Coq_Cat.

Program Definition Type_Cat : Category := Coq_Cat Type. *)

From Categories Require Import PreSheaf.PreSheaf.
(* Categories.PreSheaf.PreSheaf:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Main.
From Categories Require Import Coq_Cats.Type_Cat.Type_Cat.
From Categories Require Import NatTrans.NatTrans NatTrans.Func_Cat.

Definition PreSheaf (C : Category) := Functor (C^op) Type_Cat.

Definition PShCat (C : Category) := Func_Cat (C^op) Type_Cat. *)



Section PSh_PullBack.

  Context (C : Category) {F G I : PreSheaf C}

          (f : (F ‚Äì‚âª I)%nattrans) (g : (G ‚Äì‚âª I)%nattrans).



  Local Hint Extern 1 =>

  match goal with

    [x : sig _ |- _ ] =>

    let H := fresh "H" in

    destruct x as [x H]

  end.



  Local Hint Extern 1 => match goal with

                          [|- context [(?F _a id)%morphism]] => rewrite (F_id F)

                        end.

  Local Hint Extern 1 =>

  match goal with

    [|- context [(?F _a (?f ‚àò ?g))%morphism]] =>

    cbn_rewrite (F_compose F f g)

  end.



  Local Hint Extern 1 =>

  match goal with

    [|- context [Trans ?f _ ((?F _a)%morphism ?h _)]] =>

    cbn_rewrite (equal_f (Trans_com f h))

  end.



  Local Hint Extern 1 => progress cbn in *.



  Local Obligation Tactic := basic_simpl; auto 10.



  Program Definition PSh_PullBack_Func : PreSheaf C :=

    {|

      FO :=

        fun c =>

          {x : ((F _o c) * (G _o c))%object%type |

           Trans f c (fst x) = Trans g c (snd x)

          };

      FA :=

        fun c c' h x =>

          exist

            _

            ((F _a h (fst (proj1_sig x)))%morphism,

             (G _a h (snd (proj1_sig x)))%morphism)

            _

    |}.



  Program Definition PSh_PullBack_morph_1 : (PSh_PullBack_Func ‚Äì‚âª F)%nattrans :=

    {|

      Trans := fun c x => fst (proj1_sig x)

    |}.



  Program Definition PSh_PullBack_morph_2 : (PSh_PullBack_Func ‚Äì‚âª G)%nattrans :=

    {|

      Trans := fun c x => snd (proj1_sig x)

    |}.



  Program Definition PSh_PullBack_morph_ex

          (p' : (C ^op ‚Äì‚âª Type_Cat)%functor)

          (pm1 : (p' ‚Äì‚âª F)%nattrans)

          (pm2 : (p' ‚Äì‚âª G)%nattrans)

          (H : (f ‚àò pm1)%nattrans = (g ‚àò pm2)%nattrans)

    :

      (p' ‚Äì‚âª PSh_PullBack_Func)%nattrans

    :=

      {|

        Trans :=

          fun c x =>

            exist

              _

              (Trans pm1 c x, Trans pm2 c x)

              (f_equal (fun w : (p' ‚Äì‚âª I)%nattrans => Trans w c x) H)

      |}.



  Program Definition PSh_PullBack : @PullBack (PShCat C) _ _ _ f g :=

    {|

      pullback := PSh_PullBack_Func;

      pullback_morph_1 := PSh_PullBack_morph_1;

      pullback_morph_2 := PSh_PullBack_morph_2;

      pullback_morph_ex := PSh_PullBack_morph_ex

    |}.



  Local Obligation Tactic := idtac.

  

  Next Obligation.

  Proof.

    intros p' pm1 pm2 H u u' H1 H2 H3 H4.

    rewrite <- H3 in H1; clear H3.

    rewrite <- H4 in H2; clear H4.

    apply NatTrans_eq_simplify.

    extensionality c.

    extensionality x.

    assert (H1' := f_equal (fun w : (p' ‚Äì‚âª F)%nattrans => Trans w c x) H1);

      clear H1.

    assert (H2' := f_equal (fun w : (p' ‚Äì‚âª G)%nattrans => Trans w c x) H2);

      clear H2.

    cbn in *.

    match goal with

      [|- ?A = ?B] => destruct A as [[? ?] ?]; destruct B as [[? ?] ?]

    end.

    apply sig_proof_irrelevance.

    cbn in *; subst; trivial.

  Qed.    



End PSh_PullBack.



Instance PSh_Has_PullBacks (C : Category) : Has_PullBacks (PShCat C) :=

  @PSh_PullBack C.

