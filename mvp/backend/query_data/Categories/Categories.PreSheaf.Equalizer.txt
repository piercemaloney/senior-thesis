From Categories Require Import Essentials.Notations.
(* Categories.Essentials.Notations:
Notation "∀ x .. y , P" := (forall x, .. (forall y, P) ..)
                             (at level 200, x binder, y binder, right associativity) : type_scope.

Notation "∃ x .. y , P" := (exists x, .. (exists y, P) ..)
  (at level 200, x binder, y binder, right associativity) : type_scope.

Notation "x ∨ y" := (x \/ y) (at level 85, right associativity) : type_scope.

Notation "x ∧ y" := (x /\ y) (at level 80, right associativity) : type_scope.

Notation "x → y" := (x -> y)
  (at level 90, y at level 200, right associativity): type_scope.

Notation "x ↔ y" := (x <-> y) (at level 95, no associativity): type_scope.

Notation "¬ x" := (~x) (at level 75, right associativity) : type_scope.

Notation "x ≠ y" := (x <> y) (at level 70) : type_scope.

Notation "x ≤ y" := (le x y) (at level 70, no associativity).

Notation "x ≥ y" := (ge x y) (at level 70, no associativity).

Reserved Notation "C '^op'" (at level 50, no associativity).

Reserved Notation "a –≻ b" (at level 90, b at level 200, right associativity).

Reserved Notation "f '⁻¹'" (at level 50, no associativity).

Reserved Notation "a ≃ b" (at level 70, no associativity).

Reserved Notation "a ≃≃ b ::> C" (at level 70, no associativity).

Reserved Notation "f ∘ g" (at level 51, right associativity).

Reserved Notation "f '∘_h' g" (at level 51, right associativity).

Reserved Notation "a ≫–> b" (at level 100, no associativity).

Reserved Notation "a –≫ b" (at level 100, no associativity).

Reserved Notation "F '_o'" (at level 50, no associativity).

Reserved Notation "F '_a'" (at level 50, no associativity).

Reserved Notation "F '@_a'" (at level 50, no associativity).

Reserved Notation "F ⊣ G" (at level 100, no associativity).

Reserved Notation "F ⊣_hom G" (at level 100, no associativity).

Reserved Notation "F ⊣_ucu G" (at level 100, no associativity).

Reserved Notation "a × b" (at level 80, no associativity).

Reserved Notation "a ⇑ b" (at level 79, no associativity).

Reserved Notation "'Π' m" (at level 50, no associativity).

Reserved Notation "'Σ' m" (at level 50, no associativity).

Reserved Notation "'Π_' C ↓ m" (at level 50, no associativity).

Reserved Notation "'Σ_' C ↓ m" (at level 50, no associativity).

Delimit Scope category_scope with category.

Delimit Scope morphism_scope with morphism.

Delimit Scope object_scope with object.

Delimit Scope functor_scope with functor.

Delimit Scope nattrans_scope with nattrans.

Delimit Scope nattrans_scope with nattrans.

Delimit Scope natiso_scope with natiso.

Delimit Scope isomorphism_scope with isomorphism.

Delimit Scope preorder_scope with preorder. *)

From Categories Require Import Essentials.Types.
(* Categories.Essentials.Types:
Global Set Primitive Projections.

Global Set Universe Polymorphism.

Global Unset Universe Minimization ToSet.

Inductive Empty : Type :=.

Hint Extern 1 =>
let tac := (repeat intros ?); match goal with [H : Empty |- _] => contradict H end in
match goal with
  | [|- context[Empty]] => tac
  | [H : context[Empty] |- _] => tac
end
.

Record prod (A B : Type) := {fst : A; snd : B}.

Arguments fst {_ _ } _.
Arguments snd {_ _ } _.
Arguments Build_prod {_ _ } _ _.

Notation "( X , Y )" := (Build_prod X Y).
Notation "X * Y" := (prod X Y) : type_scope. *)

From Categories Require Import Essentials.Facts_Tactics.
(* Categories.Essentials.Facts_Tactics:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.

Require Export Coq.Program.Tactics.
Require Export Coq.Program.Equality.
Require Export Coq.Logic.FunctionalExtensionality.
Require Export Coq.Logic.ProofIrrelevance.

Definition equal_f : ∀ {A B : Type} {f g : A → B}, f = g → ∀ x : A, f x = g x.

Definition f_equal : ∀ (A B : Type) (f : A → B) (x y : A), x = y → f x = f y.

Arguments f_equal [_ _] _ [_ _] _.

Ltac basic_simpl :=
  let simpl_prod _ :=
      match goal with
        [H : prod _ _ |- _] =>
        let H1 := fresh H "1" in
        let H2 := fresh H "2" in
        destruct H as [H1 H2]
      end
  in
  let simpl_sig _ :=
      match goal with
        [H : @sig _ _ |- _] =>
        let H1 := fresh H "1" in
        let H2 := fresh H "2" in
        destruct H as [H1 H2]
      end
  in
  let basic_simpl_helper _ :=
      cbn in *; intros;
        repeat simpl_prod tt;
        repeat simpl_sig tt
  in
  repeat basic_simpl_helper tt
.

Global Obligation Tactic := basic_simpl; auto.

Ltac PIR :=
  let pir_helper _ :=
      match goal with
      |[H : ?A, H' : ?A|- _] =>
       match type of A with
       | Prop =>
         destruct (proof_irrelevance _ H H')
       end
      end
  in
  repeat pir_helper tt
.

Ltac ElimEq := repeat match goal with [H : _ = _|- _] => destruct H end.

Hint Extern 1 => progress ElimEq.

Ltac cbn_rewrite W :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite H; clear H
.

Ltac cbn_rewrite_in W V :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite H in V; clear H
.

Ltac cbn_rewrite_back W :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite <- H; clear H
.

Ltac cbn_rewrite_back_in W V :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite <- H in V; clear H
.

Tactic Notation "cbn_rewrite" constr(W) := cbn_rewrite W.
Tactic Notation "cbn_rewrite" constr(W) "in" hyp_list(V) := cbn_rewrite_in W V.
Tactic Notation "cbn_rewrite" "<-" constr(W) := cbn_rewrite_back W.
Tactic Notation "cbn_rewrite" "<-" constr(W) "in" hyp_list(V) := cbn_rewrite_back_in W V.

Lemma sig_proof_irrelevance {A : Type} (P : A → Prop) (X Y : sig P) : proj1_sig X = proj1_sig Y → X = Y.

Hint Extern 2 (exist ?A _ _ = exist ?A _ _) => apply sig_proof_irrelevance.

Ltac FunExt :=
progress (
    repeat (
        match goal with
          [|- _ = _] =>
          let x := fresh "x" in
          extensionality x
        end
      )
  )
.

Hint Extern 1 => FunExt.

Lemma pair_eq (A B : Type) (a b : A * B) : fst a = fst b → snd a = snd b → a = b.

Hint Resolve pair_eq.

Ltac revert_clearbody_all :=
 repeat lazymatch goal with H:_ |- _ => try clearbody H; revert H end.

Ltac hyp_stack :=
 constr:(ltac:(revert_clearbody_all;constructor) : True).

Ltac next_hyp hs step last :=
 lazymatch hs with (?hs' ?H) => step H hs' | _ => last end.

Tactic Notation "dohyps" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := tac H; next_hyp hs step idtac in
 next_hyp hs step idtac.

Tactic Notation "dohyps" "reverse" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := next_hyp hs step idtac; tac H in
 next_hyp hs step idtac.

Tactic Notation "do1hyp" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := tac H + next_hyp hs step fail in
 next_hyp hs step fail.

Tactic Notation "do1hyp" "reverse" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := next_hyp hs step fail + tac H in
 next_hyp hs step fail. *)

From Categories Require Import Category.Main.
(* Categories.Category.Main:
From Categories Require Export Category.Category.
From Categories Require Export Category.Morph.
From Categories Require Export Category.Opposite.
From Categories Require Export Category.SubCategory.
From Categories Require Export Category.Composable_Chain. *)

From Categories Require Import Functor.Main.
(* Categories.Functor.Main:
From Categories Require Export Functor.Functor.
From Categories Require Export Functor.Functor_Extender.
From Categories Require Export Functor.Functor_Image.
From Categories Require Export Functor.Functor_Ops.
From Categories Require Export Functor.Functor_Properties.
From Categories Require Export Functor.Const_Func.
From Categories Require Export Functor.Const_Func_Functor. *)

From Categories Require Import Basic_Cons.Equalizer.
(* Categories.Basic_Cons.Equalizer:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.

Local Open Scope morphism_scope.

Section Equalizer.
  Context {C : Category} {a b : Obj} (f g : a –≻ b).

  Local Open Scope morphism_scope.
  
  Record Equalizer : Type :=
    {
      equalizer : C;

      equalizer_morph : equalizer –≻ a;

      equalizer_morph_com : f ∘ equalizer_morph = g ∘ equalizer_morph;

      equalizer_morph_ex (e' : Obj) (eqm : e' –≻ a) :
        f ∘ eqm = g ∘ eqm → e' –≻ equalizer;

      equalizer_morph_ex_com (e' : Obj) (eqm : e' –≻ a)
                             (eqmc : f ∘ eqm = g ∘ eqm)
      : equalizer_morph ∘ (equalizer_morph_ex e' eqm eqmc) = eqm;

      equalizer_morph_unique (e' : Obj) (eqm : e' –≻ a)
                             (com : f ∘ eqm = g ∘ eqm) (u u' : e' –≻ equalizer)
      : equalizer_morph ∘ u = eqm → equalizer_morph ∘ u' = eqm → u = u'
    }.

  Coercion equalizer : Equalizer >-> Obj.
  
  Theorem Equalizer_iso (e1 e2 : Equalizer) : (e1 ≃ e2)%isomorphism.

End Equalizer.

Arguments equalizer_morph {_ _ _ _ _} _.
Arguments equalizer_morph_com {_ _ _ _ _} _.
Arguments equalizer_morph_ex {_ _ _ _ _} _ {_ _} _.
Arguments equalizer_morph_ex_com {_ _ _ _ _} _ {_ _} _.
Arguments equalizer_morph_unique {_ _ _ _ _} _ {_ _ _} _ _ _ _.

Arguments Equalizer _ {_ _} _ _, {_ _ _} _ _.

Definition Has_Equalizers (C : Category) : Type :=
  ∀ (a b : C) (f g : a –≻ b), Equalizer f g.

Existing Class Has_Equalizers.

Definition CoEqualizer {C : Category} := @Equalizer (C^op).

Arguments CoEqualizer _ {_ _} _ _, {_ _ _} _ _.

Definition Has_CoEqualizers (C : Category) : Type := Has_Equalizers (C^op).

Existing Class Has_CoEqualizers. *)

From Categories Require Import Coq_Cats.Type_Cat.Type_Cat Coq_Cats.Type_Cat.Equalizer.
(* Categories.Coq_Cats.Type_Cat.Type_Cat:
From Categories Require Import Category.Main.
From Categories Require Import Coq_Cats.Coq_Cat.

Program Definition Type_Cat : Category := Coq_Cat Type. *)
(* Categories.Coq_Cats.Type_Cat.Equalizer:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Basic_Cons.Equalizer.
From Categories Require Import Coq_Cats.Type_Cat.Type_Cat.

Local Obligation Tactic := idtac.

Section Equalizer.
  Context {A B : Type} (f g : A → B).

  Program Definition Type_Cat_Eq : Equalizer Type_Cat f g :=
    {|
      equalizer := {x : A | f x = g x};
      equalizer_morph := @proj1_sig _ _;
      equalizer_morph_ex :=
        fun T eqm H x =>
          exist _ (eqm x) _
    |}.

End Equalizer.

Program Instance Type_Cat_Has_Equalizers : Has_Equalizers Type_Cat :=
  fun _ _ => Type_Cat_Eq.

Require Import Coq.Relations.Relations Coq.Relations.Relation_Definitions.
Require Import Coq.Logic.ClassicalChoice Coq.Logic.ChoiceFacts.
Require Coq.Logic.ClassicalFacts.

Section CoEqualizer.
  Context {A B : Type} (f g : A → B).

  Local Obligation Tactic := idtac.

  Definition CoEq_rel_base : relation B := fun x y => exists z, f z = x ∧ g z = y.

  Definition CoEq_rel : relation B := clos_refl_sym_trans _ CoEq_rel_base.

  Definition CoEq_rel_refl :=
    equiv_refl _ _ (clos_rst_is_equiv _ CoEq_rel_base).
  Definition CoEq_rel_sym :=
    equiv_sym _ _ (clos_rst_is_equiv _ CoEq_rel_base).
  Definition CoEq_rel_trans :=
    equiv_trans _ _ (clos_rst_is_equiv _ CoEq_rel_base).

  Definition CoEq_Type :=
    {P : B → Prop | exists z : B, P z ∧ (∀ (y : B), (P y ↔ CoEq_rel z y))}.

  Local Axiom ConstructiveIndefiniteDescription_B :
    ConstructiveIndefiniteDescription_on B.

  Definition CoEq_Choice (ct : CoEq_Type) : {x : B | (proj1_sig ct) x}.

  Local Axiom PropExt : ClassicalFacts.prop_extensionality.

  Theorem CoEq_rel_Ext : ∀ (x : A) (y : B), CoEq_rel (f x) y = CoEq_rel (g x) y.

  Program Definition Type_Cat_CoEq  : CoEqualizer Type_Cat f g :=
    {|
      equalizer := CoEq_Type
    |}.

End CoEqualizer.

Program Instance Type_Cat_Has_CoEqualizers : Has_CoEqualizers Type_Cat :=
  fun _ _ => Type_Cat_CoEq. *)

From Categories Require Import NatTrans.NatTrans NatTrans.Func_Cat.
(* Categories.NatTrans.NatTrans:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Functor.
From Categories Require Import Cat.Cat.

Section NatTrans.
  Context {C C' : Category}.

  Record NatTrans (F F' : (C –≻ C')%functor) :=
    {
      Trans (c : C) : ((F _o c) –≻ (F' _o c))%object%morphism;
      Trans_com {c c' : C} (h : (c –≻ c')%morphism) :
        ((Trans c') ∘ F _a h = F' _a h ∘ (Trans c))%morphism;
      Trans_com_sym {c c' : C} (h : (c –≻ c')%morphism) :
        (F' _a h ∘ (Trans c) = (Trans c') ∘ F _a h)%morphism
    }.

  Notation "F –≻ F'" := (NatTrans F F') : nattrans_scope.

  Lemma NatTrans_eq_simplify {F F' : (C –≻ C')%functor}
        (N N' : (F –≻ F')%nattrans) : (@Trans _ _ N) = (@Trans _ _ N') -> N = N'.

End NatTrans.

Arguments Trans {_ _ _ _} _ _.
Arguments Trans_com {_ _ _ _} _ {_ _} _.
Arguments Trans_com_sym {_ _ _ _} _ {_ _} _.

Bind Scope nattrans_scope with NatTrans.

Notation "F –≻ F'" := (NatTrans F F') : nattrans_scope.

Local Open Scope nattrans_scope.

Section NatTrans_Compose.
  Context {C C' : Category}.
  
  Program Definition NatTrans_compose {F F' F'' : (C –≻ C')%functor}
          (tr : F –≻ F') (tr' : F' –≻ F'') : (F –≻ F'')%nattrans :=
    {|
      Trans := fun c : Obj => ((Trans tr' c) ∘ (Trans tr c)) % morphism
    |}.

End NatTrans_Compose.

Notation "N ∘ N'" := (NatTrans_compose N' N) : nattrans_scope.

Section NatTrans_Props.
  Context {C C' : Category}.
  
  Theorem NatTrans_compose_assoc {F G H I : (C –≻ C')%functor} (N : F –≻ G)
          (N' : G –≻ H) (N'' : H –≻ I)
    : ((N'' ∘ N') ∘ N = N'' ∘ (N' ∘ N))%nattrans
  .

  Program Definition NatTrans_id (F : (C –≻ C')%functor) : F –≻ F :=
    {|
      Trans := fun x : Obj => id
    |}.

  Theorem NatTrans_id_unit_left {F G : (C –≻ C')%functor} (N : F –≻ G)
    : (NatTrans_id G) ∘ N = N.

  Theorem NatTrans_id_unit_right {F G : (C –≻ C')%functor} (N : F –≻ G)
    : N ∘ (NatTrans_id F) = N.
  
End NatTrans_Props.

Hint Resolve NatTrans_eq_simplify. *)
(* Categories.NatTrans.Func_Cat:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Functor Functor.Functor_Ops.
From Categories Require Import Cat.Cat.
From Categories Require Import NatTrans.NatTrans NatTrans.Operations.

Program Definition Func_Cat (C C' : Category) : Category :=
{|
  Obj := (C –≻ C')%functor;

  Hom := NatTrans;

  compose := @NatTrans_compose _ _;

  id := @NatTrans_id _ _;

  assoc := fun _ _ _ _ _ _ _ => @NatTrans_compose_assoc _ _ _ _ _ _ _ _ _;
             
  assoc_sym :=
    fun _ _ _ _ _ _ _ => eq_sym (@NatTrans_compose_assoc _ _ _ _ _ _ _ _ _);

  id_unit_right := @NatTrans_id_unit_right _ _;
  
  id_unit_left := @NatTrans_id_unit_left _ _
|}.

Section Opposite_Func_Cat.
  Context (C D : Category).

  Program Definition Op_Func_Cat_to_Func_Cat_Op
    : ((Func_Cat C D)^op –≻ (Func_Cat (C^op) (D^op)))%functor :=
    {|
      FO := Opposite_Functor;
      FA := fun _ _ => Opposite_NatTrans;
      F_id := fun _ => NatTrans_id_Op _;
      F_compose := fun _ _ _ _ _ => NatTrans_compose_Op _ _ 
    |}.

  Program Definition Func_Cat_Op_to_Op_Func_Cat
    : ((Func_Cat (C^op) (D^op)) –≻ (Func_Cat C D)^op)%functor :=
    {|
      FO := Opposite_Functor;
      FA := fun _ _ => Opposite_NatTrans;
      F_id := fun F => NatTrans_id_Op F;
      F_compose := fun _ _ _ N N' => NatTrans_compose_Op N N'
    |}.
  
  Program Definition Func_Cat_Op_Iso
    : ((((Func_Cat C D)^op)%category)
         ≃≃ (Func_Cat (C^op) (D^op)) ::> Cat) %isomorphism :=
    {|
      iso_morphism := Op_Func_Cat_to_Func_Cat_Op;
      inverse_morphism := Func_Cat_Op_to_Op_Func_Cat
    |}.

End Opposite_Func_Cat. *)

From Categories Require Import PreSheaf.PreSheaf.
(* Categories.PreSheaf.PreSheaf:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Main.
From Categories Require Import Coq_Cats.Type_Cat.Type_Cat.
From Categories Require Import NatTrans.NatTrans NatTrans.Func_Cat.

Definition PreSheaf (C : Category) := Functor (C^op) Type_Cat.

Definition PShCat (C : Category) := Func_Cat (C^op) Type_Cat. *)



Local Obligation Tactic := idtac.



Section Equalizer.

  Context (C : Category) {A B : PreSheaf C} (f g : (A –≻ B)%nattrans).



  Program Definition PSh_ptw_eq_Func : PreSheaf C :=

    {|

      FO := fun c => Type_Cat_Has_Equalizers _ _ (Trans f c) (Trans g c);

      FA := fun c c' h x => exist _ (A _a h (proj1_sig x))%morphism _

    |}.



  Next Obligation.

  Proof.

    intros c c' h x.

    basic_simpl.

    cbn_rewrite (equal_f (Trans_com f h) x1).

    cbn_rewrite (equal_f (Trans_com g h) x1).

    rewrite x2.

    trivial.

  Qed.    



  Next Obligation.

  Proof.  

    basic_simpl; FunExt; basic_simpl.

    apply sig_proof_irrelevance; cbn.

    rewrite (F_id A).

    trivial.

  Qed.



  Next Obligation.

  Proof.

    intros a b c f' g'.

    FunExt; basic_simpl.

    apply sig_proof_irrelevance; cbn.

    cbn_rewrite (F_compose A f' g').

    trivial.

  Qed.



  Local Obligation Tactic := basic_simpl; auto.



  Program Definition PSh_ptw_eq_morph_NatTrans : NatTrans PSh_ptw_eq_Func A :=

    {|

      Trans :=

        fun c =>

          equalizer_morph

            (Type_Cat_Has_Equalizers _ _ (Trans f c) (Trans g c))

    |}.



  Local Hint Extern 1 => apply NatTrans_eq_simplify; FunExt; basic_simpl.



  Program Definition PSh_Eq : Equalizer (PShCat C) f g :=

    {|

      equalizer := PSh_ptw_eq_Func;

      equalizer_morph := PSh_ptw_eq_morph_NatTrans;

      equalizer_morph_ex :=

        fun u v H =>

          {|

            Trans := fun c x => exist _ (Trans v c x) _

          |}

    |}.



  Next Obligation.

  Proof.

    apply (f_equal (fun w :(u –≻ B)%nattrans => Trans w c x) H).

  Qed.



  Next Obligation.

  Proof.  

    FunExt.

    apply sig_proof_irrelevance; cbn.

    apply (equal_f (Trans_com v h)).

  Qed.  



  Next Obligation.

  Proof.

    symmetry.

    apply PSh_Eq_obligation_3.

  Qed.



  Local Obligation Tactic := idtac.

  

  Next Obligation.

    intros e' eqm H1 u u' H4 H5.

    rewrite <- H5 in H4; clear H5.

    assert (H4' := f_equal Trans H4); clear H4.

    apply NatTrans_eq_simplify.

    extensionality x; extensionality y.

    apply sig_proof_irrelevance.

    apply (f_equal (fun w => w x y) H4').

  Qed.

  

End Equalizer.



Instance PSh_Has_Equalizers (C : Category) : Has_Equalizers (PShCat C)

  := fun _ _ => PSh_Eq C.



Section CoEqualizer.

  Context (C : Category) {A B : PreSheaf C} (f g : (A –≻ B)%nattrans).



  Lemma another_coequalizer

        (c c' : C)

        (h : (c' –≻ c)%morphism)

    :

      ((equalizer_morph (Type_Cat_Has_CoEqualizers _ _ (Trans f c') (Trans g c'))) ∘ (B _a h) ∘ (Trans f c))%morphism

      =

      ((equalizer_morph (Type_Cat_Has_CoEqualizers _ _ (Trans f c') (Trans g c'))) ∘ (B _a h) ∘ (Trans g c))%morphism

  .

  Proof.

    FunExt; cbn.

    cbn_rewrite <- (equal_f (Trans_com f h)).

    cbn_rewrite <- (equal_f (Trans_com g h)).

    apply (equal_f (equalizer_morph_com (Type_Cat_Has_CoEqualizers _ _ (Trans f c') (Trans g c')))).

  Qed.



  Lemma CoEq_rel_natural

        (a b : C)

        (h : (b –≻ a)%morphism)

        (x y : (B _o)%object a)

        (H : CoEq_rel (Trans f a) (Trans g a) x y)

    :

      CoEq_rel (Trans f b) (Trans g b) (B _a h x)%morphism (B _a h y)%morphism

  .

  Proof.

    cbn in *.

    induction H.

    {

      destruct H as [z [H1 H2]].

      rewrite <- H1, <- H2.

      constructor 1.

      exists ((A _a)%morphism h z); split.

      apply (equal_f (Trans_com f h)).

      apply (equal_f (Trans_com g h)).

    }

    {

      constructor 2.

    }

    {      

      constructor 3; auto.

    }      

    {

      econstructor 4; eauto.

    }

  Qed.



  Lemma equalizer_morph_com_simplified

        (a : C)

        (x y : (B _o)%object a)

        (H : CoEq_rel (Trans f a) (Trans g a) x y)

    :

      Equalizer.Type_Cat_CoEq_obligation_1 (Trans f a) (Trans g a) y =

      Equalizer.Type_Cat_CoEq_obligation_1 (Trans f a) (Trans g a) x

  .

  Proof.

    induction H; auto.

    destruct H as [z [H1 H2]].

    rewrite <- H1, <- H2.

    symmetry.

    apply (equal_f (@equalizer_morph_com _ _ _ _ _ (Type_Cat_Has_CoEqualizers _ _ (Trans f a) (Trans g a)))).

  Qed.    



  Program Definition PSh_ptw_coeq_Func : PreSheaf C :=

    {|

      FO := fun c => Type_Cat_Has_CoEqualizers _ _ (Trans f c) (Trans g c);

      FA :=

        fun c c' h x =>

          @equalizer_morph_ex

            _

            _

            _

            _

            _

            (Type_Cat_Has_CoEqualizers _ _ (Trans f c) (Trans g c))

            _

            (

              (equalizer_morph (Type_Cat_Has_CoEqualizers _ _ (Trans f c') (Trans g c')))

                ∘ (B _a h)

            )%morphism (another_coequalizer _ _ _) x

    |}.



  Next Obligation.

  Proof.

    basic_simpl.

    eapply

      (

        @equalizer_morph_unique

          _

          _

          _

          _

          _

          (Type_Cat_Has_CoEqualizers _ _ (Trans f c) (Trans g c))

          _

          (equalizer_morph (Type_Cat_Has_CoEqualizers _ _ (Trans f c) (Trans g c)))

      );

      cbn; trivial.

    + apply (@equalizer_morph_com _ _ _ _ _ (Type_Cat_Has_CoEqualizers _ _ (Trans f c) (Trans g c))).

    + extensionality x.

      destruct (

          (

            CoEq_Choice

              (Trans f c)

              (Trans g c)

              (

                Equalizer.Type_Cat_CoEq_obligation_1 

                  (Trans f c)

                  (Trans g c)

                  x

              )

          )

        ) as [y H].

      rewrite (F_id B).

      apply equalizer_morph_com_simplified; assumption.

  Qed.



  Next Obligation.

  Proof.

    intros a b c f' g'.

    cbn in *.

    apply

      (

        @equalizer_morph_unique

          _

          _

          _

          _

          _

          (Type_Cat_Has_CoEqualizers _ _ (Trans f a) (Trans g a))

          _

          (

            (equalizer_morph (Type_Cat_Has_CoEqualizers _ _ (Trans f c) (Trans g c)))

              ∘ (B _a (f' ∘ g'))

          )%morphism

      );

      cbn.

    {

      extensionality x.

      cbn_rewrite (F_compose B f' g').

      cbn_rewrite <- (equal_f (Trans_com f f')).

      cbn_rewrite <- (equal_f (Trans_com f g')).

      cbn_rewrite <- (equal_f (Trans_com g f')).

      cbn_rewrite <- (equal_f (Trans_com g g')).

      apply (equal_f

               (@equalizer_morph_com

                  _

                  _

                  _

                  _

                  _

                  (Type_Cat_Has_CoEqualizers _ _ (Trans f c) (Trans g c))

               )

            ).

    }

    {

      extensionality x.

      destruct (

          (

            CoEq_Choice

              _

              _

              (

                Equalizer.Type_Cat_CoEq_obligation_1

                  _

                  _

                  x

              )

          )

        ) as [y H].

      cbn in *.

      apply equalizer_morph_com_simplified.

      apply CoEq_rel_natural; trivial.

    }

    {

      extensionality x.

      cbn_rewrite (F_compose B f' g').

      destruct (

          (

            CoEq_Choice

              _

              _

              (

                Equalizer.Type_Cat_CoEq_obligation_1

                  _

                  _

                  x

              )

          )

        ) as [y H].

      cbn in *.

      destruct (

          (

            CoEq_Choice

              _

              _

              (

                Equalizer.Type_Cat_CoEq_obligation_1

                  _

                  _

                  ((B _a)%morphism f' y)

              )

          )

        ) as [z H'].

      cbn in *.

      apply equalizer_morph_com_simplified.

      apply CoEq_rel_natural; trivial.

      econstructor 4; [|exact H'].

      apply CoEq_rel_natural; trivial.

    }

  Qed.



  Program Definition PSh_ptw_coeq_morph_NatTrans : NatTrans B PSh_ptw_coeq_Func :=

    {|

      Trans :=

        fun c =>

          equalizer_morph

            (Type_Cat_Has_CoEqualizers _ _ (Trans f c) (Trans g c))

    |}.



  Next Obligation.

  Proof.

    intros c c' h.

    extensionality x.

    cbn.

    destruct (

          (

            CoEq_Choice

              _

              _

              (

                Equalizer.Type_Cat_CoEq_obligation_1

                  _

                  _

                  x

              )

          )

        ) as [z H'].

      cbn in *.

      apply equalizer_morph_com_simplified.

      apply CoEq_rel_natural; trivial.

      constructor 3; trivial.

  Qed.



  Next Obligation.

  Proof.

    symmetry.

    apply PSh_ptw_coeq_morph_NatTrans_obligation_1.

  Qed.

    

  Program Definition PSh_CoEq : CoEqualizer (PShCat C) f g :=

    {|

      equalizer := PSh_ptw_coeq_Func;

      equalizer_morph := PSh_ptw_coeq_morph_NatTrans;

      equalizer_morph_ex :=

        fun u v H =>

          {|

            Trans := fun x w => _

          |}

    |}.



  Next Obligation.

  Proof.

    apply NatTrans_eq_simplify.

    extensionality c; extensionality x.

    cbn.

    apply (equal_f

             (@equalizer_morph_com

                _

                _

                _

                _

                _

                (Type_Cat_Has_CoEqualizers _ _ (Trans f c) (Trans g c))

               )

          ).

  Qed.



  Next Obligation.

  Proof.

    intros.

    destruct (CoEq_Choice _ _ w) as [z H'].

    exact (Trans v x z).

  Defined.



  Next Obligation.

  Proof.  

    intros u v H c c' h.

    extensionality w.

    unfold PSh_CoEq_obligation_2.

    cbn in *.

    destruct (CoEq_Choice _ _ w) as [z H'].

    cbn in *.

    cbn_rewrite <- (equal_f (Trans_com v h)).

    destruct (

        CoEq_Choice

          _

          _

          (

            Equalizer.Type_Cat_CoEq_obligation_1

              _

              _

              ((B _a)%morphism h z)

          )

      ) as [y H''].

    cbn in *.

    induction H'' as [l l' H''| | |]; auto.

    destruct H'' as [q [H''1 H''2]].

    rewrite <- H''1, <- H''2.

    symmetry.

    apply (f_equal (fun w : (A –≻ u)%nattrans => Trans w c' q) H).

  Qed.



  Next Obligation.

  Proof.

    symmetry.

    apply PSh_CoEq_obligation_3.

  Qed.



  Next Obligation.

  Proof.

    intros e' eqm eqmc.

    apply NatTrans_eq_simplify.

    unfold PSh_CoEq_obligation_2.

    extensionality c; extensionality x.

    cbn in *.

    destruct (

        CoEq_Choice

          _

          _

          (

            Equalizer.Type_Cat_CoEq_obligation_1

              _

              _

              x

          )

      ) as [y H''].

    cbn in *.

    induction H'' as [l l' H''| | |]; auto.

    destruct H'' as [q [H''1 H''2]].

    rewrite <- H''1, <- H''2.

    symmetry.

    apply (f_equal (fun w : (A –≻ e')%nattrans => Trans w c q) eqmc).

  Qed.

    

  Next Obligation.

    intros e' eqm eqmc u u' H4 H5.

    apply NatTrans_eq_simplify.

    extensionality c.

    assert (eqmc' := f_equal (fun w : (A –≻ e')%nattrans => Trans w c) eqmc); clear eqmc.

    assert (H4' := f_equal (fun w : (B –≻ e')%nattrans=> Trans w c) H4); clear H4.

    assert (H5' := f_equal (fun w : (B –≻ e')%nattrans => Trans w c) H5); clear H5.

    apply (

        @equalizer_morph_unique

          _

          _

          _

          _

          _

          (Type_Cat_Has_CoEqualizers _ _ (Trans f c) (Trans g c))

          _

          (Trans eqm c)

      ); assumption.

  Qed.

  

End CoEqualizer.



Instance PSh_Has_CoEqualizers (C : Category) : Has_CoEqualizers (PShCat C)

  := fun _ _ => PSh_CoEq C.

