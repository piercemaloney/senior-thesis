From Categories Require Import Essentials.Notations.
(* Categories.Essentials.Notations:
Notation "∀ x .. y , P" := (forall x, .. (forall y, P) ..)
                             (at level 200, x binder, y binder, right associativity) : type_scope.

Notation "∃ x .. y , P" := (exists x, .. (exists y, P) ..)
  (at level 200, x binder, y binder, right associativity) : type_scope.

Notation "x ∨ y" := (x \/ y) (at level 85, right associativity) : type_scope.

Notation "x ∧ y" := (x /\ y) (at level 80, right associativity) : type_scope.

Notation "x → y" := (x -> y)
  (at level 90, y at level 200, right associativity): type_scope.

Notation "x ↔ y" := (x <-> y) (at level 95, no associativity): type_scope.

Notation "¬ x" := (~x) (at level 75, right associativity) : type_scope.

Notation "x ≠ y" := (x <> y) (at level 70) : type_scope.

Notation "x ≤ y" := (le x y) (at level 70, no associativity).

Notation "x ≥ y" := (ge x y) (at level 70, no associativity).

Reserved Notation "C '^op'" (at level 50, no associativity).

Reserved Notation "a –≻ b" (at level 90, b at level 200, right associativity).

Reserved Notation "f '⁻¹'" (at level 50, no associativity).

Reserved Notation "a ≃ b" (at level 70, no associativity).

Reserved Notation "a ≃≃ b ::> C" (at level 70, no associativity).

Reserved Notation "f ∘ g" (at level 51, right associativity).

Reserved Notation "f '∘_h' g" (at level 51, right associativity).

Reserved Notation "a ≫–> b" (at level 100, no associativity).

Reserved Notation "a –≫ b" (at level 100, no associativity).

Reserved Notation "F '_o'" (at level 50, no associativity).

Reserved Notation "F '_a'" (at level 50, no associativity).

Reserved Notation "F '@_a'" (at level 50, no associativity).

Reserved Notation "F ⊣ G" (at level 100, no associativity).

Reserved Notation "F ⊣_hom G" (at level 100, no associativity).

Reserved Notation "F ⊣_ucu G" (at level 100, no associativity).

Reserved Notation "a × b" (at level 80, no associativity).

Reserved Notation "a ⇑ b" (at level 79, no associativity).

Reserved Notation "'Π' m" (at level 50, no associativity).

Reserved Notation "'Σ' m" (at level 50, no associativity).

Reserved Notation "'Π_' C ↓ m" (at level 50, no associativity).

Reserved Notation "'Σ_' C ↓ m" (at level 50, no associativity).

Delimit Scope category_scope with category.

Delimit Scope morphism_scope with morphism.

Delimit Scope object_scope with object.

Delimit Scope functor_scope with functor.

Delimit Scope nattrans_scope with nattrans.

Delimit Scope nattrans_scope with nattrans.

Delimit Scope natiso_scope with natiso.

Delimit Scope isomorphism_scope with isomorphism.

Delimit Scope preorder_scope with preorder. *)

From Categories Require Import Essentials.Types.
(* Categories.Essentials.Types:
Global Set Primitive Projections.

Global Set Universe Polymorphism.

Global Unset Universe Minimization ToSet.

Inductive Empty : Type :=.

Hint Extern 1 =>
let tac := (repeat intros ?); match goal with [H : Empty |- _] => contradict H end in
match goal with
  | [|- context[Empty]] => tac
  | [H : context[Empty] |- _] => tac
end
.

Record prod (A B : Type) := {fst : A; snd : B}.

Arguments fst {_ _ } _.
Arguments snd {_ _ } _.
Arguments Build_prod {_ _ } _ _.

Notation "( X , Y )" := (Build_prod X Y).
Notation "X * Y" := (prod X Y) : type_scope. *)

From Categories Require Import Essentials.Facts_Tactics.
(* Categories.Essentials.Facts_Tactics:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.

Require Export Coq.Program.Tactics.
Require Export Coq.Program.Equality.
Require Export Coq.Logic.FunctionalExtensionality.
Require Export Coq.Logic.ProofIrrelevance.

Definition equal_f : ∀ {A B : Type} {f g : A → B}, f = g → ∀ x : A, f x = g x.

Definition f_equal : ∀ (A B : Type) (f : A → B) (x y : A), x = y → f x = f y.

Arguments f_equal [_ _] _ [_ _] _.

Ltac basic_simpl :=
  let simpl_prod _ :=
      match goal with
        [H : prod _ _ |- _] =>
        let H1 := fresh H "1" in
        let H2 := fresh H "2" in
        destruct H as [H1 H2]
      end
  in
  let simpl_sig _ :=
      match goal with
        [H : @sig _ _ |- _] =>
        let H1 := fresh H "1" in
        let H2 := fresh H "2" in
        destruct H as [H1 H2]
      end
  in
  let basic_simpl_helper _ :=
      cbn in *; intros;
        repeat simpl_prod tt;
        repeat simpl_sig tt
  in
  repeat basic_simpl_helper tt
.

Global Obligation Tactic := basic_simpl; auto.

Ltac PIR :=
  let pir_helper _ :=
      match goal with
      |[H : ?A, H' : ?A|- _] =>
       match type of A with
       | Prop =>
         destruct (proof_irrelevance _ H H')
       end
      end
  in
  repeat pir_helper tt
.

Ltac ElimEq := repeat match goal with [H : _ = _|- _] => destruct H end.

Hint Extern 1 => progress ElimEq.

Ltac cbn_rewrite W :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite H; clear H
.

Ltac cbn_rewrite_in W V :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite H in V; clear H
.

Ltac cbn_rewrite_back W :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite <- H; clear H
.

Ltac cbn_rewrite_back_in W V :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite <- H in V; clear H
.

Tactic Notation "cbn_rewrite" constr(W) := cbn_rewrite W.
Tactic Notation "cbn_rewrite" constr(W) "in" hyp_list(V) := cbn_rewrite_in W V.
Tactic Notation "cbn_rewrite" "<-" constr(W) := cbn_rewrite_back W.
Tactic Notation "cbn_rewrite" "<-" constr(W) "in" hyp_list(V) := cbn_rewrite_back_in W V.

Lemma sig_proof_irrelevance {A : Type} (P : A → Prop) (X Y : sig P) : proj1_sig X = proj1_sig Y → X = Y.

Hint Extern 2 (exist ?A _ _ = exist ?A _ _) => apply sig_proof_irrelevance.

Ltac FunExt :=
progress (
    repeat (
        match goal with
          [|- _ = _] =>
          let x := fresh "x" in
          extensionality x
        end
      )
  )
.

Hint Extern 1 => FunExt.

Lemma pair_eq (A B : Type) (a b : A * B) : fst a = fst b → snd a = snd b → a = b.

Hint Resolve pair_eq.

Ltac revert_clearbody_all :=
 repeat lazymatch goal with H:_ |- _ => try clearbody H; revert H end.

Ltac hyp_stack :=
 constr:(ltac:(revert_clearbody_all;constructor) : True).

Ltac next_hyp hs step last :=
 lazymatch hs with (?hs' ?H) => step H hs' | _ => last end.

Tactic Notation "dohyps" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := tac H; next_hyp hs step idtac in
 next_hyp hs step idtac.

Tactic Notation "dohyps" "reverse" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := next_hyp hs step idtac; tac H in
 next_hyp hs step idtac.

Tactic Notation "do1hyp" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := tac H + next_hyp hs step fail in
 next_hyp hs step fail.

Tactic Notation "do1hyp" "reverse" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := next_hyp hs step fail + tac H in
 next_hyp hs step fail. *)

From Categories Require Import Category.Main.
(* Categories.Category.Main:
From Categories Require Export Category.Category.
From Categories Require Export Category.Morph.
From Categories Require Export Category.Opposite.
From Categories Require Export Category.SubCategory.
From Categories Require Export Category.Composable_Chain. *)

From Categories Require Import Functor.Main.
(* Categories.Functor.Main:
From Categories Require Export Functor.Functor.
From Categories Require Export Functor.Functor_Extender.
From Categories Require Export Functor.Functor_Image.
From Categories Require Export Functor.Functor_Ops.
From Categories Require Export Functor.Functor_Properties.
From Categories Require Export Functor.Const_Func.
From Categories Require Export Functor.Const_Func_Functor. *)

From Categories Require Import Basic_Cons.Product.
(* Categories.Basic_Cons.Product:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Ext_Cons.Prod_Cat.Prod_Cat Ext_Cons.Prod_Cat.Operations.
From Categories Require Import Functor.Main.

Local Open Scope morphism_scope.

Record Product {C : Category} (c d : C) : Type :=
{
  product : C;

  Pi_1 : product –≻ c;

  Pi_2 : product –≻ d;

  Prod_morph_ex : ∀ (p' : Obj) (r1 : p' –≻ c) (r2 : p' –≻ d), p' –≻ product;

  Prod_morph_com_1 : ∀ (p' : Obj) (r1 : p' –≻ c) (r2 : p' –≻ d),
      (Pi_1 ∘ (Prod_morph_ex p' r1 r2))%morphism = r1;
  
  Prod_morph_com_2 : ∀ (p' : Obj) (r1 : p' –≻ c) (r2 : p' –≻ d),
      (Pi_2 ∘ (Prod_morph_ex p' r1 r2))%morphism = r2;
  
  Prod_morph_unique :
    ∀ (p' : Obj) (r1 : p' –≻ c) (r2 : p' –≻ d) (f g : p' –≻ product),
      Pi_1 ∘ f = r1
      → Pi_2 ∘ f = r2
      → Pi_1 ∘ g = r1
      → Pi_2 ∘ g = r2
      → f = g
}.

Arguments Product _ _ _, {_} _ _.

Arguments Pi_1 {_ _ _ _}, {_ _ _} _.
Arguments Pi_2 {_ _ _ _}, {_ _ _} _.
Arguments Prod_morph_ex {_ _ _} _ _ _ _.
Arguments Prod_morph_com_1 {_ _ _} _ _ _ _.
Arguments Prod_morph_com_2 {_ _ _} _ _ _ _.
Arguments Prod_morph_unique {_ _ _} _ _ _ _ _ _ _ _ _ _.

Coercion product : Product >-> Obj.

Notation "a × b" := (Product a b) : object_scope.

Local Open Scope object_scope.

Theorem Product_iso {C : Category} (c d : Obj) (P : c × d) (P' : c × d)
  : (P ≃ P')%isomorphism.

Definition Has_Products (C : Category) : Type := ∀ a b, a × b.

Existing Class Has_Products.

Program Definition Prod_Func (C : Category) {HP : Has_Products C}
  : ((C × C) –≻ C)%functor :=
{|
  FO := fun x => HP (fst x) (snd x); 
  FA := fun a b f => Prod_morph_ex _ _ ((fst f) ∘ Pi_1) ((snd f) ∘ Pi_2)
|}.

Arguments Prod_Func _ _, _ {_}.

Notation "×ᶠⁿᶜ" := Prod_Func : functor_scope.

Definition Sum (C : Category) := @Product (C^op).

Arguments Sum _ _ _, {_} _ _.

Notation "a + b" := (Sum a b) : object_scope.

Definition Has_Sums (C : Category) : Type :=  ∀ (a b : C), (a + b)%object.

Existing Class Has_Sums.

Definition Sum_Func {C : Category} {HS : Has_Sums C} : ((C × C) –≻ C)%functor :=
  (×ᶠⁿᶜ (C^op) HS)^op.

Arguments Sum_Func _ _, _ {_}.

Notation "+ᶠⁿᶜ" := Sum_Func : functor_scope. *)

From Categories Require Import Basic_Cons.Exponential Basic_Cons.Exponential_Functor.
(* Categories.Basic_Cons.Exponential:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Ext_Cons.Prod_Cat.Prod_Cat.
From Categories Require Import Functor.Main.
From Categories Require Import Basic_Cons.Product.

Local Open Scope morphism_scope.

Record Exponential {C : Category} {HP : Has_Products C} (c d : Obj) : Type :=
{
  exponential : C;

  eval : ((×ᶠⁿᶜ C) _o (exponential, c))%object –≻ d;

  Exp_morph_ex : ∀ (z : C), (((×ᶠⁿᶜ C) _o (z, c))%object –≻ d) → (z –≻ exponential);

  Exp_morph_com : ∀ (z : C) (f : ((×ᶠⁿᶜ C) _o (z, c))%object –≻ d),
      f = (eval ∘ ((×ᶠⁿᶜ C) @_a (_, _) (_, _) (Exp_morph_ex z f, id c)))%morphism;

  Exp_morph_unique : ∀ (z : C) (f : ((×ᶠⁿᶜ C) _o (z, c))%object –≻ d)
                       (u u' : z –≻ exponential),
      f = (eval ∘ ((×ᶠⁿᶜ C) @_a (_, _) (_, _) (u, id c)))%morphism →
      f = (eval ∘ ((×ᶠⁿᶜ C) @_a (_, _) (_, _) (u', id c)))%morphism →
      u = u'
}.

Coercion exponential : Exponential >-> Obj.

Arguments Exponential _ {_} _ _, {_ _} _ _.

Arguments exponential {_ _ _ _} _, {_ _} _ _ {_}.
Arguments eval {_ _ _ _} _, {_ _} _ _ {_}.
Arguments Exp_morph_ex {_ _ _ _} _ _ _, {_ _} _ _ {_} _ _.
Arguments Exp_morph_com {_ _ _ _} _ _ _, {_ _} _ _ {_} _ _.
Arguments Exp_morph_unique {_ _ _ _} _ _ _ _ _ _ _, {_ _} _ _ {_} _ _ _ _ _ _.

Notation "a ⇑ b" := (Exponential a b) : object_scope.

Theorem Exponential_iso {C : Category} {HP : Has_Products C} (c d : C)
        (E E' : (c ⇑ d)%object) : (E ≃ E')%isomorphism.

Definition Has_Exponentials (C : Category) {HP : Has_Products C} :=
  ∀ a b, (a ⇑ b)%object.

Existing Class Has_Exponentials.

Section Curry_UnCurry.
  Context (C : Category) {HP : Has_Products C} {HE : Has_Exponentials C}.

  Definition curry :
    forall {a b c : C},
      (((×ᶠⁿᶜ C) _o (a, b))%object –≻ c) → (a –≻ (HE b c)) :=
    fun {a b c : C} (f : ((×ᶠⁿᶜ C) _o (a, b))%object –≻ c) =>
      Exp_morph_ex (HE b c) _ f.

  Definition uncurry : forall {a b c : C},
      (a –≻ (HE b c)) → (((×ᶠⁿᶜ C) _o (a, b))%object –≻ c) :=
    fun {a b c : C} (f : a –≻ (HE b c)) =>
      ((eval (HE b c)) ∘ ((×ᶠⁿᶜ C) @_a (_, _) (_, _) (f, id C b)))%morphism.

  Section inversion.
    Context {a b c : C}.

    Theorem curry_uncurry (f : a –≻ (HE b c)) : curry (uncurry f) = f.

    Theorem uncurry_curry (f : ((×ᶠⁿᶜ C) _o (a, b))%object –≻ c) :
      uncurry (curry f) = f.

  End inversion.

  Section injectivity.
    Context {a b c : C}.

    Theorem curry_injective (f g : ((×ᶠⁿᶜ C) _o (a, b))%object –≻ c) :
      curry f = curry g → f = g.

    Theorem uncurry_injective (f g : a –≻ (HE b c)) :
      uncurry f = uncurry g → f = g.

  End injectivity.

  Section curry_compose.
    Context {a b c : C}.

    Lemma curry_compose (f : ((×ᶠⁿᶜ C) _o (a, b))%object –≻ c)
          {z : C} (g : z –≻ a)
      : (curry f) ∘ g = curry (f ∘ (Prod_morph_ex _ _ (g ∘ Pi_1) Pi_2)).

  End curry_compose.

End Curry_UnCurry. *)
(* Categories.Basic_Cons.Exponential_Functor:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Ext_Cons.Prod_Cat.Prod_Cat.
From Categories Require Import Functor.Main.
From Categories Require Import Basic_Cons.Product.
From Categories Require Import Basic_Cons.Exponential.

Local Obligation Tactic := idtac.

Program Definition Exp_Func {C : Category}
        {hp : Has_Products C}
        (exps : ∀ a b, (a ⇑ b)%object)
: ((C^op × C) –≻ C)%functor :=
{|
  FO := fun x => exps (fst x) (snd x);
  FA := fun a b f => 
          Exp_morph_ex
            _ _
            ((snd f) ∘ (eval _)
                     ∘ ((×ᶠⁿᶜ C) @_a
                                 (_, fst b) (_, fst a)
                                 (id (exps (fst a) (snd a)), fst f)))%morphism
|}.

Arguments Exp_Func {_ _} _, {_} _ _, _ _ _.

Notation "⇑ᶠⁿᶜ" := Exp_Func : functor_scope. *)

From Categories Require Import Adjunction.Adjunction.
(* Categories.Adjunction.Adjunction:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Ext_Cons.Prod_Cat.Prod_Cat Ext_Cons.Prod_Cat.Operations.
From Categories Require Import Functor.Main.
From Categories Require Import Functor.Representable.Hom_Func
        Functor.Representable.Hom_Func_Prop.
From Categories Require Import NatTrans.Main.

Local Open Scope functor_scope.

Local Notation NID := NatTrans_id (only parsing).
Local Notation FCAT := Func_Cat (only parsing).

Notation Hom_Adj_Left C D F G :=
  ((Hom_Func D) ∘ (Prod_Functor (F^op) (@Functor_id D)))%functor (only parsing).

Notation Hom_Adj_Right C D F G :=
  ((Hom_Func C) ∘ (Prod_Functor (@Functor_id (C^op)) G))%functor (only parsing).

Local Obligation Tactic := idtac.

Section Adjunction.
  Context {C D : Category} (F : C –≻ D) (G : D –≻ C).

  Record Adjunct : Type :=
  {
    adj_unit : ((Functor_id C) –≻ (G ∘ F))%nattrans;
    
    adj_morph_ex {c : C} {d : D} (f : (c –≻ (G _o d)%object)%morphism) :
      ((F _o c)%object –≻ d)%morphism;
    
    adj_morph_com {c : C} {d : D} (f : (c –≻ (G _o d))%morphism%object) :
      f = ((G _a (adj_morph_ex f)) ∘ (Trans adj_unit c))%morphism;
    
    adj_morph_unique {c : C} {d : D} (f : (c –≻ (G _o d))%object%morphism)
                     (g h : ((F _o c) –≻ d)%morphism%object) :
      f = ((G _a g) ∘ (Trans adj_unit c))%morphism →
      f = ((G _a h) ∘ (Trans adj_unit c))%morphism →
      g = h
  }.

  Arguments adj_unit : clear implicits.
  Arguments adj_morph_ex _ {_ _} _.
  Arguments adj_morph_com _ {_ _} _.
  Arguments adj_morph_unique _ {_ _} _ _ _ _ _.

  Theorem Adjunct_eq_simplify (adj adj' : Adjunct) :
    adj_unit adj = @adj_unit adj' →
    @adj_morph_ex adj = @adj_morph_ex adj' → adj = adj'.

  Definition Hom_Adjunct :=
    (Hom_Adj_Left _ _ F G ≃ Hom_Adj_Right _ _ F G)%natiso.

  Record UCU_Adjunct :=
    {
      ucu_adj_unit : ((Functor_id C) –≻ (G ∘ F))%nattrans;
      
      ucu_adj_counit : ((F ∘ G) –≻ (Functor_id D))%nattrans;

      ucu_adj_left_id : ((NatTrans_from_compose_id _)
                           ∘ ((((ucu_adj_counit ∘_h (NID F))
                                  ∘ (NatTrans_Functor_assoc_sym _ _ _))
                                 ∘ ((NID F) ∘_h ucu_adj_unit))
                                ∘ (NatTrans_to_id_compose _)))%nattrans
                        = (NID F);
      
      ucu_adj_right_id : ((NatTrans_from_id_compose _)
                            ∘ (((((NID G) ∘_h ucu_adj_counit)
                                   ∘ (NatTrans_Functor_assoc _ _ _))
                                  ∘ (ucu_adj_unit ∘_h (NID G)))
                                 ∘ (NatTrans_to_compose_id _)))%nattrans
                         = (NID G)
    }.

  Arguments ucu_adj_unit : clear implicits.
  Arguments ucu_adj_counit : clear implicits.
  Arguments ucu_adj_left_id : clear implicits.
  Arguments ucu_adj_right_id : clear implicits.

  Local Notation "F ⊣ G" := (Adjunct) : functor_scope.
  Local Notation "F ⊣_hom G" := (Hom_Adjunct) : functor_scope.
  Local Notation "F ⊣_ucu G" := (UCU_Adjunct) : functor_scope.
  
  Section UCU_Adj_Adj.
    Context (Adj : (F ⊣_ucu G)%functor).

    Program Definition UCU_Adj_to_Adj : (F ⊣ G)%functor :=
      {|
        adj_unit := ucu_adj_unit Adj;
        adj_morph_ex :=
          fun _ _ h => ((Trans (ucu_adj_counit Adj) _) ∘ (F _a h))%morphism
      |}.

  End UCU_Adj_Adj.

  Section Adj_UCU_Adj.
    Context (Adj : (F ⊣ G)%functor).
    
    Program Definition Adj_to_UCU_Adj : (F ⊣_ucu G)%functor :=
      {|
        ucu_adj_unit := adj_unit Adj;
        ucu_adj_counit :=
          {|
            Trans := fun d => @adj_morph_ex Adj (G _o d) d id
          |}
      |}.

  End Adj_UCU_Adj.
  
  Section Adj_Hom_Adj.
    Context (Adj : (F ⊣ G)%functor).

    Program Definition Adj_to_Hom_Adj_LR :
      ((Hom_Adj_Left _ _ F G) –≻ (Hom_Adj_Right _ _ F G))%nattrans :=
    {|
      Trans := fun c h => ((G _a h) ∘ (Trans (adj_unit Adj) _))%morphism
    |}.

    Program Definition Adj_to_Hom_Adj_RL :
      ((Hom_Adj_Right _ _ F G) –≻ (Hom_Adj_Left _ _ F G))%nattrans :=
    {|
      Trans := fun c h => adj_morph_ex Adj h
    |}.

    Program Definition Adj_to_Hom_Adj : (F ⊣_hom G)%functor :=
      NatIso _ _ Adj_to_Hom_Adj_LR Adj_to_Hom_Adj_RL _ _.

  End Adj_Hom_Adj.

  Section Hom_Adj_Adj.
    Context (Adj : (F ⊣_hom G)%functor).

    Program Definition Hom_Adj_to_Adj : (F ⊣ G)%functor :=
      {|
        adj_unit :=
          {| Trans := fun c => Trans (iso_morphism Adj) (c, F _o c)%object id |};
        adj_morph_ex := fun _ _ f => Trans (inverse_morphism Adj) (_, _) f
      |}.

  End Hom_Adj_Adj.

End Adjunction.

Arguments adj_unit {_ _ _ _} _ : assert.
Arguments adj_morph_ex {_ _ _ _} _ {_ _} _.
Arguments adj_morph_com {_ _ _ _} _ {_ _} _.
Arguments adj_morph_unique {_ _ _ _} _ {_ _} _ _ _ _ _.

Arguments ucu_adj_unit {_ _ _ _} _.
Arguments ucu_adj_counit {_ _ _ _} _.
Arguments ucu_adj_left_id {_ _ _ _} _.
Arguments ucu_adj_right_id {_ _ _ _} _.

Arguments Adj_to_Hom_Adj {_ _ _ _} _.

Arguments Hom_Adj_to_Adj {_ _ _ _} _.

Notation "F ⊣ G" := (Adjunct F G) : functor_scope.
Notation "F ⊣_hom G" := (Hom_Adjunct F G) : functor_scope.
Notation "F ⊣_ucu G" := (UCU_Adjunct F G) : functor_scope. *)

From Categories Require Import Ext_Cons.Prod_Cat.Operations.
(* Categories.Ext_Cons.Prod_Cat.Operations:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Main.
From Categories Require Import Cat.Cat.
From Categories Require Import Ext_Cons.Prod_Cat.Prod_Cat.

Local Obligation Tactic := idtac.

Local Open Scope functor_scope.

Program Definition Prod_Functor
        {C1 C2 C1' C2' : Category} (F : C1 –≻ C2) (F' : C1' –≻ C2')
  : (C1 × C1') –≻ (C2 × C2') :=
{|
  FO := fun a => (F _o (fst a), F' _o (snd a))%object;
  FA := fun _ _ f => (F _a (fst f), F' _a (snd f))%morphism
|}.

Definition Bi_Func_1 {Cx C1 C1' Cy : Category} (F : Cx –≻ C1)
           (F' : (C1 × C1') –≻ Cy)
  : (Cx × C1') –≻ Cy :=
  F' ∘ (Prod_Functor F (@Functor_id C1')).

Definition Bi_Func_2 {Cx C1 C1' Cy : Category} (F : Cx –≻ C1')
           (F' : (C1 × C1') –≻ Cy) : (C1 × Cx) –≻ Cy :=
  Functor_compose (Prod_Functor (@Functor_id C1) F) F'.

Local Hint Extern 2 => cbn.

Local Obligation Tactic := basic_simpl; do 2 auto.

Program Definition Fix_Bi_Func_1 {C1 C1' Cy : Category} (x : C1)
        (F : (C1 × C1') –≻ Cy)
  : C1' –≻ Cy :=
{|
  FO := fun a => (F _o (x, a))%object;
  FA := fun _ _ f => (F @_a (_, _) (_, _) (@id _ x, f))%morphism
|}.

Program Definition Fix_Bi_Func_2 {C1 C1' Cy : Category} (x : C1')
        (F : (C1 × C1') –≻ Cy)
  : C1 –≻ Cy :=
{|
  FO := fun a => (F _o (a, x))%object;
  FA := fun _ _ f => (F @_a (_, _) (_, _) (f, @id _ x))%morphism
|}.

Program Definition Diag_Func (C : Category) : C –≻ (C × C) :=
{|
  FO := fun a => (a, a);
  FA := fun _ _ f => (f, f);
  F_id := fun _ => eq_refl;
  F_compose := fun _ _ _ _ _ => eq_refl
|}.

Theorem Prod_Functor_Cat_Proj {C D D' : Category} (F : C –≻ (D × D')) :
  ((Prod_Functor ((Cat_Proj1 _ _) ∘ F) ((Cat_Proj2 _ _) ∘ F))
     ∘ (Diag_Func C))%functor = F.

Program Definition Twist_Func (C C' : Category) : (C × C') –≻ (C' × C) :=
{|
  FO := fun a => (snd a, fst a);
  FA := fun _ _ f => (snd f, fst f);
  F_id := fun _ => eq_refl;
  F_compose := fun _ _ _ _ _ => eq_refl
|}.

Section Twist_Prod_Func_Twist.
  Context {C C' : Category} (F : C –≻ C') {D D' : Category} (G : D –≻ D').

  Theorem Twist_Prod_Func_Twist :
    (((Twist_Func _ _) ∘ (Prod_Functor F G)) ∘ (Twist_Func _ _))%functor =
    Prod_Functor G F.

End Twist_Prod_Func_Twist.

Section Prod_Functor_compose.
  Context {C D E: Category} (F : C –≻ D) (G : D –≻ E)
          {C' D' E': Category} (F' : C' –≻ D') (G' : D' –≻ E').

  Theorem Prod_Functor_compose :
    ((Prod_Functor G G') ∘ (Prod_Functor F F') =
     Prod_Functor (G ∘ F) (G' ∘ F'))%functor.
                                   
End Prod_Functor_compose. *)

From Categories Require Import NatTrans.NatTrans.
(* Categories.NatTrans.NatTrans:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Functor.
From Categories Require Import Cat.Cat.

Section NatTrans.
  Context {C C' : Category}.

  Record NatTrans (F F' : (C –≻ C')%functor) :=
    {
      Trans (c : C) : ((F _o c) –≻ (F' _o c))%object%morphism;
      Trans_com {c c' : C} (h : (c –≻ c')%morphism) :
        ((Trans c') ∘ F _a h = F' _a h ∘ (Trans c))%morphism;
      Trans_com_sym {c c' : C} (h : (c –≻ c')%morphism) :
        (F' _a h ∘ (Trans c) = (Trans c') ∘ F _a h)%morphism
    }.

  Notation "F –≻ F'" := (NatTrans F F') : nattrans_scope.

  Lemma NatTrans_eq_simplify {F F' : (C –≻ C')%functor}
        (N N' : (F –≻ F')%nattrans) : (@Trans _ _ N) = (@Trans _ _ N') -> N = N'.

End NatTrans.

Arguments Trans {_ _ _ _} _ _.
Arguments Trans_com {_ _ _ _} _ {_ _} _.
Arguments Trans_com_sym {_ _ _ _} _ {_ _} _.

Bind Scope nattrans_scope with NatTrans.

Notation "F –≻ F'" := (NatTrans F F') : nattrans_scope.

Local Open Scope nattrans_scope.

Section NatTrans_Compose.
  Context {C C' : Category}.
  
  Program Definition NatTrans_compose {F F' F'' : (C –≻ C')%functor}
          (tr : F –≻ F') (tr' : F' –≻ F'') : (F –≻ F'')%nattrans :=
    {|
      Trans := fun c : Obj => ((Trans tr' c) ∘ (Trans tr c)) % morphism
    |}.

End NatTrans_Compose.

Notation "N ∘ N'" := (NatTrans_compose N' N) : nattrans_scope.

Section NatTrans_Props.
  Context {C C' : Category}.
  
  Theorem NatTrans_compose_assoc {F G H I : (C –≻ C')%functor} (N : F –≻ G)
          (N' : G –≻ H) (N'' : H –≻ I)
    : ((N'' ∘ N') ∘ N = N'' ∘ (N' ∘ N))%nattrans
  .

  Program Definition NatTrans_id (F : (C –≻ C')%functor) : F –≻ F :=
    {|
      Trans := fun x : Obj => id
    |}.

  Theorem NatTrans_id_unit_left {F G : (C –≻ C')%functor} (N : F –≻ G)
    : (NatTrans_id G) ∘ N = N.

  Theorem NatTrans_id_unit_right {F G : (C –≻ C')%functor} (N : F –≻ G)
    : N ∘ (NatTrans_id F) = N.
  
End NatTrans_Props.

Hint Resolve NatTrans_eq_simplify. *)



Section Prod_Adj.

  Context (C : Category) (HP : Has_Products C).



  Hint Extern 1 =>

  eapply Prod_morph_unique;

    eauto;

    repeat rewrite assoc_sym;

    repeat rewrite Prod_morph_com_1;

    repeat rewrite Prod_morph_com_2;

    repeat rewrite assoc;

    repeat rewrite Prod_morph_com_1;

    repeat rewrite Prod_morph_com_2

  .

  

  Program Definition Prod_Adj : ((Diag_Func C) ⊣ (×ᶠⁿᶜ C HP))%functor :=

    {|

      adj_unit := {|Trans := fun c => @Prod_morph_ex _ _ _ (HP c c) c id id |};

      adj_morph_ex := fun c c' h => (Pi_1 ∘ h, Pi_2 ∘ h)%morphism

    |}.



  Local Obligation Tactic := idtac.

  

  Next Obligation.

  Proof.

    intros c d f [g1 g2] [h1 h2] H1 H2.

    cbn in *.

    replace g1 with (Pi_1 ∘ f)%morphism;

      [|rewrite H1; rewrite assoc_sym; rewrite Prod_morph_com_1;

        rewrite assoc; rewrite Prod_morph_com_1; auto].

    replace g2 with (Pi_2 ∘ f)%morphism;

      [|rewrite H1; rewrite assoc_sym; rewrite Prod_morph_com_2;

        rewrite assoc; rewrite Prod_morph_com_2; auto].

    replace h1 with (Pi_1 ∘ f)%morphism;

      [|rewrite H2; rewrite assoc_sym; rewrite Prod_morph_com_1;

        rewrite assoc; rewrite Prod_morph_com_1; auto].

    replace h2 with (Pi_2 ∘ f)%morphism;

      [|rewrite H2; rewrite assoc_sym; rewrite Prod_morph_com_2;

        rewrite assoc; rewrite Prod_morph_com_2; auto]; trivial.

  Qed.



End Prod_Adj.



Section Sum_Adj.

  Context (C : Category) (HS : Has_Sums C).



  Hint Extern 1 =>

  eapply Prod_morph_unique; eauto; repeat rewrite assoc_sym;

  repeat rewrite Prod_morph_com_1; repeat rewrite Prod_morph_com_2;

  repeat rewrite assoc; repeat rewrite Prod_morph_com_1;

  repeat rewrite Prod_morph_com_2.

  

  Program Definition Sum_Adj : ((+ᶠⁿᶜ C HS) ⊣ (Diag_Func C))%functor :=

    {|

      adj_unit :=

        {|

          Trans :=

            fun c =>

              (@Pi_1 _ _ _ (HS (fst c) (snd c)), @Pi_2 _ _ _ (HS (fst c) (snd c)))

        |};

      adj_morph_ex :=

        fun c c' h =>

          @Prod_morph_ex _ _ _ (HS (fst c) (snd c)) c' (fst h) (snd h)

    |}.



  Next Obligation.

  Proof.

    match goal with

      [|- (?A, ?B) = (?C, ?D)] => cutrewrite(C = A); [cutrewrite (D = B)|]; trivial

    end.

    apply (@Prod_morph_com_2 (C^op)).

    apply (@Prod_morph_com_1 (C^op)).

  Qed.



  Next Obligation.

  Proof.

    match goal with

      [|- (?A, ?B) = (?C, ?D)] => cutrewrite(A = C); [cutrewrite (B = D)|]; trivial

    end.

    apply (@Prod_morph_com_2 (C^op)).

    apply (@Prod_morph_com_1 (C^op)).

  Qed.



  Next Obligation.

  Proof.

    match goal with

      [|- (?A, ?B) = (?C, ?D)] => cutrewrite(C = A); [cutrewrite (D = B)|]; trivial

    end.

    apply (@Prod_morph_com_2 (C^op)).

    apply (@Prod_morph_com_1 (C^op)).

  Qed.    

  

  Local Obligation Tactic := idtac.

  

  Next Obligation.

  Proof.

    intros [c1 c2] d [f1 f2] g h H1 H2.

    cbn in *.

    apply (@Prod_morph_unique _ _ _ (HS c1 c2) d f1 f2); symmetry.

    apply (f_equal fst H1).

    apply (f_equal snd H1).

    apply (f_equal fst H2).

    apply (f_equal snd H2).

  Qed.



End Sum_Adj.



Section Prod_Exp_Adj.

  Context (C : Category) (HP : Has_Products C) (HE : Has_Exponentials C) (x : C).



  Program Definition Prod_Exp_Adj :

    (

      (Fix_Bi_Func_2 x (×ᶠⁿᶜ C HP)) ⊣ (@Fix_Bi_Func_1 (C^op) _ _ x (⇑ᶠⁿᶜ HE))

    )%functor

    :=

    {|

      adj_unit := {|Trans := fun c => Exp_morph_ex (HE x (HP c x)) c id|};

      adj_morph_ex := fun c c' h => uncurry _ h

    |}.



  Next Obligation.

  Proof.

    eapply Exp_morph_unique; eauto; cbn.

    set (M := curry_compose); unfold curry in M; cbn in M; rewrite M.

    cbn_rewrite <- (@Exp_morph_com C HP _ _ (HE x (HP c' x))).

    rewrite M.

    cbn_rewrite <- (@Exp_morph_com C HP _ _ (HE x (HP c' x))).

    replace

      (Prod_morph_ex

         (HP (HE x (HP c x)) x)

         (HP (HE x (HP c x)) x)

         (id ∘ Pi_1)

         (id ∘ Pi_2)

      )

    with (id (HP (HE x (HP c x)) x)).

    {

      repeat rewrite id_unit_right.

      rewrite assoc.

      rewrite <- (id_unit_left _ _ Pi_2).

      cbn_rewrite <- (@Exp_morph_com C HP _ _ (HE x (HP c x))).

      auto.

    }

    {

      eapply Prod_morph_unique; eauto;

      try rewrite Prod_morph_com_1;

      try rewrite Prod_morph_com_2;

      auto.

    }

  Qed.



  Next Obligation.

  Proof.  

    symmetry.

    apply Prod_Exp_Adj_obligation_1.

  Qed.



  Next Obligation.

  Proof.

    set (M := curry_compose); unfold curry in M; cbn in M; rewrite M.

    eapply Exp_morph_unique; eauto; cbn.

    cbn_rewrite <- (@Exp_morph_com C HP _ _ (HE x d)).

    replace (

        Prod_morph_ex

          (HP (HE x (HP c x)) x)

          (HP (HE x (HP c x)) x)

          (id ∘ Pi_1)

          (id ∘ Pi_2)

      )

    with (id (HP (HE x (HP c x)) x)).

    {

      repeat rewrite id_unit_right.

      repeat rewrite assoc.

      rewrite <- (id_unit_left _ _ Pi_2).

      cbn_rewrite <- (@Exp_morph_com C HP _ _ (HE x (HP c x))).

      unfold uncurry; cbn.

      auto.

    }

    {

      eapply Prod_morph_unique;

      eauto;

      try rewrite Prod_morph_com_1;

      try rewrite Prod_morph_com_2;

      auto.

    }

  Qed.    



  Local Obligation Tactic := idtac.

  

  Next Obligation.

  Proof.

    intros c c' f g h H1 H2.

    rewrite H1 in H2; clear H1.

    cbn in *.

    replace (Prod_morph_ex

               (HP (HE x (HP c x)) x) (HP (HE x (HP c x)) x)

               (id ∘ Pi_1) (id ∘ Pi_2)) with (id (HP (HE x (HP c x)) x)) in H2.

    {

      rewrite id_unit_right in H2.

      set (M := curry_compose); unfold curry in M; cbn in M; rewrite M in H2.

      rewrite assoc in H2.

      rewrite <- (id_unit_left _ _ Pi_2) in H2.

      cbn_rewrite <- (@Exp_morph_com C HP) in H2.

      rewrite M in H2.

      rewrite assoc in H2.

      rewrite <- (id_unit_left _ _ Pi_2) in H2.

      cbn_rewrite <- (@Exp_morph_com C HP) in H2.

      simpl_ids in H2.

      eapply curry_injective.

      trivial.

    }    

    {

      eapply Prod_morph_unique;

      eauto;

      try rewrite Prod_morph_com_1;

      try rewrite Prod_morph_com_2;

      auto.

    }

  Qed.



End Prod_Exp_Adj.

