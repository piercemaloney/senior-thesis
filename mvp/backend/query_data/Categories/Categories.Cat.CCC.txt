From Categories Require Import Category.Category.
(* Categories.Category.Category:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.

Cumulative Class Category : Type :=
{
  
  Obj : Type;

  Hom : Obj ‚Üí Obj ‚Üí Type where "a ‚Äì‚âª b" := (Hom a b);

  compose : ‚àÄ {a b c : Obj}, (a ‚Äì‚âª b) ‚Üí (b ‚Äì‚âª c) ‚Üí (a ‚Äì‚âª c) where "f ‚àò g" := (compose g f);

  assoc : ‚àÄ {a b c d : Obj} (f : a ‚Äì‚âª b) (g : b ‚Äì‚âª c) (h : c ‚Äì‚âª d),
            ((h ‚àò g) ‚àò f) = (h ‚àò (g ‚àò f));

  assoc_sym : ‚àÄ {a b c d : Obj} (f : a ‚Äì‚âª b) (g : b ‚Äì‚âª c) (h : c ‚Äì‚âª d),
                ((h ‚àò (g ‚àò f) = (h ‚àò g) ‚àò f));

  id : ‚àÄ {a : Obj}, a ‚Äì‚âª a;

  id_unit_left : ‚àÄ (a b : Obj) (h : a ‚Äì‚âª b), id ‚àò h = h;

  id_unit_right : ‚àÄ (a b : Obj) (h : a ‚Äì‚âª b), h ‚àò id = h
}.

Arguments Obj {_}, _.
Arguments id {_ _}, {_} _, _ _.
Arguments Hom {_} _ _, _ _ _.
Arguments compose {_} {_ _ _} _ _, _ {_ _ _} _ _, _ _ _ _ _ _.
Arguments assoc {_ _ _ _ _} _ _ _.
Arguments assoc_sym {_ _ _ _ _} _ _ _.

Notation "f ‚àò g" := (compose g f) : morphism_scope.
Notation "a ‚Äì‚âª b" := (Hom a b) : morphism_scope.

Bind Scope category_scope with Category.

Bind Scope morphism_scope with Hom.

Bind Scope object_scope with Obj.

Coercion Obj : Category >-> Sortclass.

Hint Resolve id_unit_left id_unit_right.

Ltac simpl_ids :=
  let id_detected B :=
      let J := fresh "H" in
      cut (B = id); [intros J; rewrite J; clear J | trivial]
  in
  repeat(
      match goal with
        | [|- context[(?A ‚àò id)%morphism] ] => rewrite id_unit_right
        | [|- context[(id ‚àò ?A)%morphism] ] => rewrite id_unit_left
        | [|- (?A ‚àò ?B)%morphism = ?A] => id_detected B
        | [|- (?A = ?A ‚àò ?B) %morphism] => id_detected B
        | [|- (?B ‚àò ?A = ?A)%morphism] => id_detected B
        | [|- (?A = ?B ‚àò ?A)%morphism] => id_detected B
      end
    )
.

Ltac simpl_ids_in_I I :=
  repeat(
      match type of I with
        | context[(?A ‚àò id)%morphism] => rewrite id_unit_right in I
        | context[(id ‚àò ?A)%morphism] => rewrite id_unit_left in I
      end
    )
.

Tactic Notation "simpl_ids" := simpl_ids.

Tactic Notation "simpl_ids" "in" hyp(I) := simpl_ids_in_I I.

Hint Extern 1 => progress simpl_ids.

Hint Extern 3 => progress (dohyps (fun H => simpl_ids in H)).

Hint Extern 2 =>
match goal with
    [|- ?A = ?B :> Hom _ _ _] =>
    repeat rewrite assoc; trivial; fail
end.

Hint Extern 2 =>
match goal with
  [H : _ = _ :> Hom _ _ _ |- _ = _ :> Hom _ _ _] =>
  repeat rewrite assoc in H;
    repeat rewrite assoc;
    (idtac + symmetry); apply H
end. *)



From Categories Require Import Basic_Cons.CCC.
(* Categories.Basic_Cons.CCC:
From Categories Require Import Essentials.Notations.
From Categories Require Import Category.Main.
From Categories Require Export Basic_Cons.Terminal.
From Categories Require Export Basic_Cons.Product.
From Categories Require Export Basic_Cons.Exponential.
From Categories Require Export Basic_Cons.Exponential_Functor.

Class CCC (C : Category) : Type :=
{
  CCC_term : (ùüô_ C)%object;
  CCC_HP : Has_Products C;
  CCC_HEXP : Has_Exponentials C
}.

Arguments CCC_term _ {_}, {_ _}.
Arguments CCC_HP _ {_} _ _, {_ _} _ _.
Arguments CCC_HEXP _ {_} _ _, {_ _} _ _.

Existing Instances CCC_term CCC_HP CCC_HEXP. *)



From Categories Require Export Cat.Cat.



From Categories Require Export Cat.Terminal.

From Categories Require Export Cat.Product.

From Categories Require Export Cat.Exponential.



Program Instance Cat_CCC : CCC Cat.



