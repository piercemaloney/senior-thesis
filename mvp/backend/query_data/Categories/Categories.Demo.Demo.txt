From Categories Require Import Essentials.Notations.
(* Categories.Essentials.Notations:
Notation "∀ x .. y , P" := (forall x, .. (forall y, P) ..)
                             (at level 200, x binder, y binder, right associativity) : type_scope.

Notation "∃ x .. y , P" := (exists x, .. (exists y, P) ..)
  (at level 200, x binder, y binder, right associativity) : type_scope.

Notation "x ∨ y" := (x \/ y) (at level 85, right associativity) : type_scope.

Notation "x ∧ y" := (x /\ y) (at level 80, right associativity) : type_scope.

Notation "x → y" := (x -> y)
  (at level 90, y at level 200, right associativity): type_scope.

Notation "x ↔ y" := (x <-> y) (at level 95, no associativity): type_scope.

Notation "¬ x" := (~x) (at level 75, right associativity) : type_scope.

Notation "x ≠ y" := (x <> y) (at level 70) : type_scope.

Notation "x ≤ y" := (le x y) (at level 70, no associativity).

Notation "x ≥ y" := (ge x y) (at level 70, no associativity).

Reserved Notation "C '^op'" (at level 50, no associativity).

Reserved Notation "a –≻ b" (at level 90, b at level 200, right associativity).

Reserved Notation "f '⁻¹'" (at level 50, no associativity).

Reserved Notation "a ≃ b" (at level 70, no associativity).

Reserved Notation "a ≃≃ b ::> C" (at level 70, no associativity).

Reserved Notation "f ∘ g" (at level 51, right associativity).

Reserved Notation "f '∘_h' g" (at level 51, right associativity).

Reserved Notation "a ≫–> b" (at level 100, no associativity).

Reserved Notation "a –≫ b" (at level 100, no associativity).

Reserved Notation "F '_o'" (at level 50, no associativity).

Reserved Notation "F '_a'" (at level 50, no associativity).

Reserved Notation "F '@_a'" (at level 50, no associativity).

Reserved Notation "F ⊣ G" (at level 100, no associativity).

Reserved Notation "F ⊣_hom G" (at level 100, no associativity).

Reserved Notation "F ⊣_ucu G" (at level 100, no associativity).

Reserved Notation "a × b" (at level 80, no associativity).

Reserved Notation "a ⇑ b" (at level 79, no associativity).

Reserved Notation "'Π' m" (at level 50, no associativity).

Reserved Notation "'Σ' m" (at level 50, no associativity).

Reserved Notation "'Π_' C ↓ m" (at level 50, no associativity).

Reserved Notation "'Σ_' C ↓ m" (at level 50, no associativity).

Delimit Scope category_scope with category.

Delimit Scope morphism_scope with morphism.

Delimit Scope object_scope with object.

Delimit Scope functor_scope with functor.

Delimit Scope nattrans_scope with nattrans.

Delimit Scope nattrans_scope with nattrans.

Delimit Scope natiso_scope with natiso.

Delimit Scope isomorphism_scope with isomorphism.

Delimit Scope preorder_scope with preorder. *)

From Categories Require Import Essentials.Types.
(* Categories.Essentials.Types:
Global Set Primitive Projections.

Global Set Universe Polymorphism.

Global Unset Universe Minimization ToSet.

Inductive Empty : Type :=.

Hint Extern 1 =>
let tac := (repeat intros ?); match goal with [H : Empty |- _] => contradict H end in
match goal with
  | [|- context[Empty]] => tac
  | [H : context[Empty] |- _] => tac
end
.

Record prod (A B : Type) := {fst : A; snd : B}.

Arguments fst {_ _ } _.
Arguments snd {_ _ } _.
Arguments Build_prod {_ _ } _ _.

Notation "( X , Y )" := (Build_prod X Y).
Notation "X * Y" := (prod X Y) : type_scope. *)

From Categories Require Import Essentials.Facts_Tactics.
(* Categories.Essentials.Facts_Tactics:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.

Require Export Coq.Program.Tactics.
Require Export Coq.Program.Equality.
Require Export Coq.Logic.FunctionalExtensionality.
Require Export Coq.Logic.ProofIrrelevance.

Definition equal_f : ∀ {A B : Type} {f g : A → B}, f = g → ∀ x : A, f x = g x.

Definition f_equal : ∀ (A B : Type) (f : A → B) (x y : A), x = y → f x = f y.

Arguments f_equal [_ _] _ [_ _] _.

Ltac basic_simpl :=
  let simpl_prod _ :=
      match goal with
        [H : prod _ _ |- _] =>
        let H1 := fresh H "1" in
        let H2 := fresh H "2" in
        destruct H as [H1 H2]
      end
  in
  let simpl_sig _ :=
      match goal with
        [H : @sig _ _ |- _] =>
        let H1 := fresh H "1" in
        let H2 := fresh H "2" in
        destruct H as [H1 H2]
      end
  in
  let basic_simpl_helper _ :=
      cbn in *; intros;
        repeat simpl_prod tt;
        repeat simpl_sig tt
  in
  repeat basic_simpl_helper tt
.

Global Obligation Tactic := basic_simpl; auto.

Ltac PIR :=
  let pir_helper _ :=
      match goal with
      |[H : ?A, H' : ?A|- _] =>
       match type of A with
       | Prop =>
         destruct (proof_irrelevance _ H H')
       end
      end
  in
  repeat pir_helper tt
.

Ltac ElimEq := repeat match goal with [H : _ = _|- _] => destruct H end.

Hint Extern 1 => progress ElimEq.

Ltac cbn_rewrite W :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite H; clear H
.

Ltac cbn_rewrite_in W V :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite H in V; clear H
.

Ltac cbn_rewrite_back W :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite <- H; clear H
.

Ltac cbn_rewrite_back_in W V :=
  let H := fresh "H" in
  set (H := W); cbn in H; rewrite <- H in V; clear H
.

Tactic Notation "cbn_rewrite" constr(W) := cbn_rewrite W.
Tactic Notation "cbn_rewrite" constr(W) "in" hyp_list(V) := cbn_rewrite_in W V.
Tactic Notation "cbn_rewrite" "<-" constr(W) := cbn_rewrite_back W.
Tactic Notation "cbn_rewrite" "<-" constr(W) "in" hyp_list(V) := cbn_rewrite_back_in W V.

Lemma sig_proof_irrelevance {A : Type} (P : A → Prop) (X Y : sig P) : proj1_sig X = proj1_sig Y → X = Y.

Hint Extern 2 (exist ?A _ _ = exist ?A _ _) => apply sig_proof_irrelevance.

Ltac FunExt :=
progress (
    repeat (
        match goal with
          [|- _ = _] =>
          let x := fresh "x" in
          extensionality x
        end
      )
  )
.

Hint Extern 1 => FunExt.

Lemma pair_eq (A B : Type) (a b : A * B) : fst a = fst b → snd a = snd b → a = b.

Hint Resolve pair_eq.

Ltac revert_clearbody_all :=
 repeat lazymatch goal with H:_ |- _ => try clearbody H; revert H end.

Ltac hyp_stack :=
 constr:(ltac:(revert_clearbody_all;constructor) : True).

Ltac next_hyp hs step last :=
 lazymatch hs with (?hs' ?H) => step H hs' | _ => last end.

Tactic Notation "dohyps" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := tac H; next_hyp hs step idtac in
 next_hyp hs step idtac.

Tactic Notation "dohyps" "reverse" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := next_hyp hs step idtac; tac H in
 next_hyp hs step idtac.

Tactic Notation "do1hyp" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := tac H + next_hyp hs step fail in
 next_hyp hs step fail.

Tactic Notation "do1hyp" "reverse" tactic3(tac) :=
 let hs := hyp_stack in
 let rec step H hs := next_hyp hs step fail + tac H in
 next_hyp hs step fail. *)

From Categories Require Import Category.Main.
(* Categories.Category.Main:
From Categories Require Export Category.Category.
From Categories Require Export Category.Morph.
From Categories Require Export Category.Opposite.
From Categories Require Export Category.SubCategory.
From Categories Require Export Category.Composable_Chain. *)

From Categories Require Import Functor.Main.
(* Categories.Functor.Main:
From Categories Require Export Functor.Functor.
From Categories Require Export Functor.Functor_Extender.
From Categories Require Export Functor.Functor_Image.
From Categories Require Export Functor.Functor_Ops.
From Categories Require Export Functor.Functor_Properties.
From Categories Require Export Functor.Const_Func.
From Categories Require Export Functor.Const_Func_Functor. *)

From Categories Require Import Basic_Cons.Main.
(* Categories.Basic_Cons.Main:
From Categories Require Export Basic_Cons.CCC.
From Categories Require Export Basic_Cons.Equalizer.
From Categories Require Export Basic_Cons.PullBack.
From Categories Require Export Basic_Cons.LCCC. *)

From Categories Require Import Coq_Cats.Type_Cat.Type_Cat.
(* Categories.Coq_Cats.Type_Cat.Type_Cat:
From Categories Require Import Category.Main.
From Categories Require Import Coq_Cats.Coq_Cat.

Program Definition Type_Cat : Category := Coq_Cat Type. *)

From Categories Require Import Coq_Cats.Type_Cat.Facts.
(* Categories.Coq_Cats.Type_Cat.Facts:
From Categories Require Export Coq_Cats.Type_Cat.Initial.
From Categories Require Export Coq_Cats.Type_Cat.CCC.
From Categories Require Export Coq_Cats.Type_Cat.Sum.
From Categories Require Export Coq_Cats.Type_Cat.GenSum.
From Categories Require Export Coq_Cats.Type_Cat.GenProd.
From Categories Require Export Coq_Cats.Type_Cat.Equalizer.
From Categories Require Export Coq_Cats.Type_Cat.Complete.
From Categories Require Export Coq_Cats.Type_Cat.SubObject_Classifier.
From Categories Require Export Coq_Cats.Type_Cat.Topos. *)

From Categories Require Import Algebras.Main.
(* Categories.Algebras.Main:
From Categories Require Export Algebras.Algebras. *)

From Categories Require Import Ext_Cons.Prod_Cat.Prod_Cat.
(* Categories.Ext_Cons.Prod_Cat.Prod_Cat:
From Categories Require Import Essentials.Notations.
From Categories Require Import Essentials.Types.
From Categories Require Import Essentials.Facts_Tactics.
From Categories Require Import Category.Main.
From Categories Require Import Functor.Main.
From Categories Require Import Cat.Cat.

Local Open Scope morphism_scope.

Local Obligation Tactic := idtac.

Program Definition Prod_Cat (C C' : Category) : Category :=
{|
  Obj := C * C';
              
  Hom :=
    fun a b =>
      (((fst a) –≻ (fst b)) * ((snd a) –≻ (snd b)))%type;

  compose :=
    fun a b c f g =>
      (((fst g) ∘ (fst f)), ((snd g) ∘ (snd f)))%morphism;

  id := fun c => (id, id)
|}.

Notation "C × D" := (Prod_Cat C D) : category_scope.

Local Obligation Tactic := basic_simpl; auto.

Theorem Prod_compose_id
        (C D : Category)
        (a b c : C) (d : D)
        (f : a –≻ b) (g : b –≻ c)
  : (g ∘ f, id d)%morphism =
    @compose (_ × _) (_, _) (_, _) (_, _) (f, id d) (g, id d).

Theorem Prod_id_compose
        (C D : Category)
        (a : C) (b c d : D)
        (f : b –≻ c) (g : c –≻ d)
  : (id a, g ∘ f)%morphism =
    @compose (_ × _) (_, _) (_, _) (_, _) (id a, f) (id a, g).

Theorem Prod_cross_compose
        (C D : Category)
        (a b : C) (c d : D)
        (f : a –≻ b) (g : c –≻ d)
  : @compose
      (_ × _) (_, _) (_, _) (_, _)
      (@id _ a, g) (f, @id _ d)
    = @compose
        (_ × _) (_, _) (_, _) (_, _)
        (f, @id _ c) (@id _ b, g)
.

Program Definition Cat_Proj1
        (C C' : Category) :
  ((C × C') –≻ C)%functor
  :=
    {|FO := fst; FA := fun _ _ f => fst f|}
.

Program Definition Cat_Proj2
        (C C' : Category) :
  ((C × C') –≻ C')%functor
  :=
    {|FO := snd; FA := fun _ _ f => snd f|}
. *)

From Categories Require Import Cat.Facts.
(* Categories.Cat.Facts:
From Categories Require Export Cat.Initial.
From Categories Require Export Cat.Terminal.
From Categories Require Export Cat.Product.
From Categories Require Export Cat.Exponential.
From Categories Require Export Cat.CCC. *)



Program Definition term_id : (Type_Cat –≻ (Type_Cat × Type_Cat))%functor :=

{|

  FO := fun a => (@CCC_term Type_Cat _, a);

  FA := fun a b f => (@id _ (@CCC_term Type_Cat _), f)

|}.



Definition S_nat_func : (Type_Cat –≻ Type_Cat)%functor :=

  ((+ᶠⁿᶜ Type_Cat _) ∘ term_id)%functor.



Definition S_nat_alg_cat := Algebra_Cat S_nat_func.



Program Definition nat_alg : Algebra S_nat_func :=

{|

  Alg_Carrier := nat;

  Constructors :=

    fun x =>

      match x with

        | inl a => 0

        | inr n => S n

      end

|}.



Program Definition nat_alg_morph alg' : Algebra_Hom nat_alg alg' :=

  {|

    Alg_map :=

      fun x =>

        (fix f (n : nat) :=

        match n with

        | O => (Constructors alg') (inl tt)

        | S n' => (Constructors alg') (inr (f n'))

        end) x

  |}.



Next Obligation. 

Proof.

  extensionality x.

  destruct x as [|[]]; cbn; trivial.

  repeat apply f_equal.

  match goal with [A : unit |- _] => destruct A; trivial end.

Qed.



Program Definition nat_alg_init : (𝟘_ S_nat_alg_cat)%object :=

  {|

    terminal := nat_alg;

    t_morph := nat_alg_morph

  |}.



Next Obligation.

Proof.

  destruct d as [algc algcons].

  destruct f as [f_morph f_com].

  destruct g as [g_morph g_com].

  apply Algebra_Hom_eq_simplify.

  extensionality x.

  simpl.

  induction x.

  {

    assert(H1 := equal_f f_com (inl tt)); cbv in H1; rewrite <- H1.

    assert(H2 := equal_f g_com (inl tt)); cbv in H2; rewrite <- H2.

    trivial.

  }

  {

    assert(H1 := equal_f f_com (inr x)); cbv in H1; rewrite <- H1.

    assert(H2 := equal_f g_com (inr x)); cbv in H2; rewrite <- H2.

    rewrite IHx.

    trivial.

  }

Qed.



CoInductive CoNat : Set :=

  | CoO : CoNat

  | CoS : CoNat -> CoNat

.



CoInductive CoNat_eq : CoNat -> CoNat -> Prop :=

  | CNOeq : CoNat_eq CoO CoO

  | CNSeq : forall (n n' : CoNat), CoNat_eq n n' -> CoNat_eq (CoS n) (CoS n')

.



Axiom CoNat_eq_eq : forall (n n' : CoNat), CoNat_eq n n' -> n = n'.



Definition S_nat_coalg_cat := @CoAlgebra_Cat Type_Cat S_nat_func.



Program Definition CoNat_coalg : @CoAlgebra Type_Cat S_nat_func :=

{|

  Alg_Carrier := CoNat;

  Constructors :=

    fun x : CoNat =>

       match x return unit + CoNat  with

       | CoO => inl tt

       | CoS x' => inr x'

       end

|}.



Program Definition CoNat_coalg_morph coalg' : CoAlgebra_Hom CoNat_coalg coalg'

  :=

{|

  Alg_map :=

    cofix f (x : Alg_Carrier coalg') : CoNat :=

      match Constructors coalg' x return CoNat with

      | inl _ => CoO

      | inr s => CoS (f s)

      end

|}.



Next Obligation. 

Proof.

  extensionality x; cbn.

  destruct (Constructors coalg' x) as [x'|x']; cbn; trivial.

  replace x' with tt; trivial.

  cbn in *.

  match goal with [A : unit |- _] => destruct A; trivial end.

Qed.



Lemma inl_inr A B (x : A) (y : B) : inl x = inr y → False.

Proof.

  inversion 1.

Qed.



Lemma inr_inl A B (x : A) (y : B) : inr x = inl y → False.

Proof.

  inversion 1.

Qed.



Program Definition CoNat_alg_term : (𝟘_ S_nat_coalg_cat)%object :=

{|

  terminal := CoNat_coalg;

  t_morph := CoNat_coalg_morph

|}.



Next Obligation.

Proof.

  apply Algebra_Hom_eq_simplify.

  extensionality x; simpl.

  apply CoNat_eq_eq; revert x.

  cofix H.

  intros x.

  assert(H1 := equal_f (@Alg_map_com _ _ _ _ f) x); cbn in H1.

  assert(H2 := equal_f (@Alg_map_com _ _ _ _ g) x); cbn in H2.

  destruct (Constructors d x); destruct ((Alg_map f) x);

    destruct ((Alg_map g) x); try constructor;

      repeat match goal with

               H : _ = _ |- _ =>

               try (apply inl_inr in H || apply inr_inl in H); tauto

             end.

  inversion H1; inversion H2.

  trivial.

Qed.



