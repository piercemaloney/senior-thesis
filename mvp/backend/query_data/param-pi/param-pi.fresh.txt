

Require Import processus.
(* processus:
Inductive capa : Set :=
  | Read : capa
  | Write : capa
  | Both : capa
  | Nil : capa.

Inductive capst : capa -> capa -> Prop :=
  | capst_refl : forall c : capa, capst c c
  | capst_nil : forall c : capa, capst c Nil
  | capst_both : forall c : capa, capst Both c.

Parameter type : Set.

Parameter getcap : type -> capa.

Parameter getobj : type -> type.

Parameter typest : type -> type -> Prop.

Axiom typest_refl : forall t : type, typest t t.

Axiom
  typest_trans :
    forall t t' : type,
    typest t t' -> forall t'' : type, typest t' t'' -> typest t t''.

Theorem capst_trans :
 forall c c' c'' : capa, capst c c' -> capst c' c'' -> capst c c''.

Parameter PP : Set.
Parameter VV : Set.

Axiom PP_decidable : forall p q : PP, {p = q} + {p <> q}.
Axiom VV_decidable : forall x y : VV, {x = y} + {x <> y}.

Inductive name : Set :=
  | pname : PP -> name
  | vname : VV -> name.

Inductive proc : Set :=
  | nil : proc
  | inp : name -> VV -> proc -> proc
  | out : name -> name -> proc -> proc
  | par : proc -> proc -> proc
  | res : VV -> type -> proc -> proc
  | ban : proc -> proc
  | sum : proc -> proc -> proc
  | mat : name -> name -> proc -> proc.

Definition subs_var_name (n m : name) (x : VV) : name :=
  match n with
  | pname p => n
  | vname v => match VV_decidable x v with
               | left _ => m
               | right _ => n
               end
  end.

Fixpoint subs_var_proc (P : proc) : name -> VV -> proc :=
  fun (n : name) (x : VV) =>
  match P with
  | nil => nil
  | inp m v qq =>
      inp (subs_var_name m n x) v
        match VV_decidable x v with
        | left _ => qq
        | right _ => subs_var_proc qq n x
        end
  | out m1 m2 qq =>
      out (subs_var_name m1 n x) (subs_var_name m2 n x)
        (subs_var_proc qq n x)
  | par qq rr => par (subs_var_proc qq n x) (subs_var_proc rr n x)
  | res v t qq =>
      res v t
        match VV_decidable x v with
        | left _ => qq
        | right _ => subs_var_proc qq n x
        end
  | ban qq => ban (subs_var_proc qq n x)
  | sum qq rr => sum (subs_var_proc qq n x) (subs_var_proc rr n x)
  | mat m1 m2 qq =>
      mat (subs_var_name m1 n x) (subs_var_name m2 n x)
        (subs_var_proc qq n x)
  end.

Definition subs_par_name (n m : name) (p : PP) : name :=
  match n with
  | pname q => match PP_decidable p q with
               | left _ => m
               | right _ => n
               end
  | vname v => n
  end.

Fixpoint subs_par_proc (P : proc) : name -> PP -> proc :=
  fun (n : name) (p : PP) =>
  match P with
  | nil => nil
  | inp m v qq => inp (subs_par_name m n p) v (subs_par_proc qq n p)
  | out m1 m2 qq =>
      out (subs_par_name m1 n p) (subs_par_name m2 n p)
        (subs_par_proc qq n p)
  | par qq rr => par (subs_par_proc qq n p) (subs_par_proc rr n p)
  | res v t qq => res v t (subs_par_proc qq n p)
  | ban qq => ban (subs_par_proc qq n p)
  | sum qq rr => sum (subs_par_proc qq n p) (subs_par_proc rr n p)
  | mat m1 m2 qq =>
      mat (subs_par_name m1 n p) (subs_par_name m2 n p)
        (subs_par_proc qq n p)
  end.

Inductive freshname (p : PP) : name -> Prop :=
  | freshp : forall q : PP, p <> q -> freshname p (pname q)
  | freshv : forall v : VV, freshname p (vname v).

Inductive fresh (p : PP) : proc -> Prop :=
  | frnil : fresh p nil
  | frinp :
      forall (m : name) (v : VV) (Q : proc),
      freshname p m -> fresh p Q -> fresh p (inp m v Q)
  | frout :
      forall (m1 m2 : name) (Q : proc),
      freshname p m1 -> freshname p m2 -> fresh p Q -> fresh p (out m1 m2 Q)
  | frpar : forall P Q : proc, fresh p P -> fresh p Q -> fresh p (par P Q)
  | frres :
      forall (v : VV) (t : type) (Q : proc), fresh p Q -> fresh p (res v t Q)
  | frban : forall Q : proc, fresh p Q -> fresh p (ban Q)
  | frsum : forall P Q : proc, fresh p P -> fresh p Q -> fresh p (sum P Q)
  | frmat :
      forall (m1 m2 : name) (Q : proc),
      freshname p m1 -> freshname p m2 -> fresh p Q -> fresh p (mat m1 m2 Q).

Inductive freshvarname (v : VV) : name -> Prop :=
  | freshvp : forall p : PP, freshvarname v (pname p)
  | freshvv : forall x : VV, v <> x -> freshvarname v (vname x).

Inductive freshvar (v : VV) : proc -> Prop :=
  | fvnil : freshvar v nil
  | fvinp :
      forall (m : name) (x : VV) (Q : proc),
      freshvarname v m -> v <> x -> freshvar v Q -> freshvar v (inp m x Q)
  | fvout :
      forall (m1 m2 : name) (Q : proc),
      freshvarname v m1 ->
      freshvarname v m2 -> freshvar v Q -> freshvar v (out m1 m2 Q)
  | fvpar :
      forall P Q : proc, freshvar v P -> freshvar v Q -> freshvar v (par P Q)
  | fvres :
      forall (x : VV) (t : type) (Q : proc),
      v <> x -> freshvar v Q -> freshvar v (res x t Q)
  | fvban : forall Q : proc, freshvar v Q -> freshvar v (ban Q)
  | fvsum :
      forall P Q : proc, freshvar v P -> freshvar v Q -> freshvar v (sum P Q)
  | fvmat :
      forall (m1 m2 : name) (Q : proc),
      freshvarname v m1 ->
      freshvarname v m2 -> freshvar v Q -> freshvar v (mat m1 m2 Q).

Inductive act : Set :=
  | aout : PP -> PP -> act
  | ainp : PP -> PP -> act
  | about : PP -> PP -> type -> act
  | tau : act.

Inductive freshact (p : PP) : act -> Prop :=
  | faout : forall q1 q2 : PP, p <> q1 -> p <> q2 -> freshact p (aout q1 q2)
  | fainp : forall q1 q2 : PP, p <> q1 -> p <> q2 -> freshact p (ainp q1 q2)
  | fabout :
      forall (q1 q2 : PP) (t : type),
      p <> q1 -> p <> q2 -> freshact p (about q1 q2 t)
  | ftau : freshact p tau.

Inductive sem : proc -> act -> proc -> Prop :=
  | sinp :
      forall (p q : PP) (x : VV) (Q : proc),
      sem (inp (pname p) x Q) (ainp p q) (subs_var_proc Q (pname q) x)
  | sout :
      forall (p q : PP) (Q : proc),
      sem (out (pname p) (pname q) Q) (aout p q) Q
  | scoml :
      forall (P P' Q Q' : proc) (p q : PP),
      sem P (ainp p q) P' ->
      sem Q (aout p q) Q' -> sem (par P Q) tau (par P' Q')
  | scomr :
      forall (P P' Q Q' : proc) (p q : PP),
      sem P (aout p q) P' ->
      sem Q (ainp p q) Q' -> sem (par P Q) tau (par P' Q')
  | sopen :
      forall (P P' : proc) (p q : PP) (x : VV) (t : type),
      fresh q P ->
      p <> q ->
      sem (subs_var_proc P (pname q) x) (aout p q) P' ->
      sem (res x t P) (about p q t) P'
  | sclosel :
      forall (P P' Q Q' : proc) (p q r : PP) (t : type) (x : VV),
      fresh q P ->
      freshvar x P' ->
      freshvar x Q' ->
      sem P (ainp p q) P' ->
      sem Q (about p r t) Q' ->
      sem (par P Q) tau
        (res x t
           (par (subs_par_proc P' (vname x) q) (subs_par_proc Q' (vname x) r)))
  | scloser :
      forall (P P' Q Q' : proc) (p q r : PP) (t : type) (x : VV),
      fresh q P ->
      freshvar x P' ->
      freshvar x Q' ->
      sem P (ainp p q) P' ->
      sem Q (about p r t) Q' ->
      sem (par Q P) tau
        (res x t
           (par (subs_par_proc Q' (vname x) r) (subs_par_proc P' (vname x) q)))
  | sres :
      forall (P P' : proc) (mu : act) (x y : VV) (t : type),
      (forall q : PP,
       sem (subs_var_proc P (pname q) x) mu (subs_var_proc P' (pname q) y)) ->
      sem (res x t P) mu (res y t P')
  | sban :
      forall (P P' : proc) (mu : act),
      sem (par (ban P) P) mu P' -> sem (ban P) mu P'
  | sparl :
      forall (P P' Q : proc) (mu : act),
      (forall (p q : PP) (t : type), mu = about p q t -> fresh q Q) ->
      sem P mu P' -> sem (par P Q) mu (par P' Q)
  | sparr :
      forall (P P' Q : proc) (mu : act),
      (forall (p q : PP) (t : type), mu = about p q t -> fresh q Q) ->
      sem P mu P' -> sem (par Q P) mu (par Q P')
  | ssuml :
      forall (P P' Q : proc) (mu : act), sem P mu P' -> sem (sum P Q) mu P'
  | ssumr :
      forall (P P' Q : proc) (mu : act), sem P mu P' -> sem (sum Q P) mu P'
  | smat :
      forall (P P' : proc) (p : PP) (mu : act),
      sem P mu P' -> sem (mat (pname p) (pname p) P) mu P'.

Definition env : Type := PP -> type.

Definition addenv (G : env) (p : PP) (t : type) : env :=
  fun q : PP =>
  match PP_decidable p q with
  | left _ => t
  | right _ => G q
  end.

Definition envst (G D : env) : Prop := forall p : PP, typest (G p) (D p).

Definition eqvenv (G D : env) : Prop := forall p : PP, G p = D p.

Inductive typing : env -> proc -> Prop :=
  | tnil : forall G : env, typing G nil
  | tinp :
      forall (G : env) (p : PP) (x : VV) (P : proc),
      capst (getcap (G p)) Read ->
      (forall q : PP,
       fresh q P ->
       typing (addenv G q (getobj (G p))) (subs_var_proc P (pname q) x)) ->
      typing G (inp (pname p) x P)
  | tout :
      forall (G : env) (p q : PP) (P : proc),
      capst (getcap (G p)) Write ->
      typest (G q) (getobj (G p)) ->
      typing G P -> typing G (out (pname p) (pname q) P)
  | tpar :
      forall (G : env) (P Q : proc),
      typing G P -> typing G Q -> typing G (par P Q)
  | tres :
      forall (G : env) (x : VV) (t : type) (P : proc),
      (forall q : PP,
       fresh q P -> typing (addenv G q t) (subs_var_proc P (pname q) x)) ->
      typing G (res x t P)
  | tban : forall (G : env) (P : proc), typing G P -> typing G (ban P)
  | tsum :
      forall (G : env) (P Q : proc),
      typing G P -> typing G Q -> typing G (sum P Q)
  | tmat :
      forall (G : env) (p q : PP) (P : proc),
      getcap (G p) = Both ->
      getcap (G q) = Both ->
      typing G P -> typing G (mat (pname p) (pname q) P).

Definition swap_par (r p q : PP) : PP :=
  match PP_decidable r p with
  | left _ => q
  | right _ => match PP_decidable r q with
               | left _ => p
               | right _ => r
               end
  end.

Definition swap_name (n : name) (p q : PP) : name :=
  match n with
  | pname r =>
      match PP_decidable r p with
      | left _ => pname q
      | right _ =>
          match PP_decidable r q with
          | left _ => pname p
          | right _ => pname r
          end
      end
  | vname x => vname x
  end.

Fixpoint swap_proc (P : proc) : PP -> PP -> proc :=
  fun p q : PP =>
  match P with
  | inp n x p1 => inp (swap_name n p q) x (swap_proc p1 p q)
  | out n1 n2 p1 =>
      out (swap_name n1 p q) (swap_name n2 p q) (swap_proc p1 p q)
  | res x t p1 => res x t (swap_proc p1 p q)
  | par p1 p2 => par (swap_proc p1 p q) (swap_proc p2 p q)
  | ban p1 => ban (swap_proc p1 p q)
  | sum p1 p2 => sum (swap_proc p1 p q) (swap_proc p2 p q)
  | mat n1 n2 p1 =>
      mat (swap_name n1 p q) (swap_name n2 p q) (swap_proc p1 p q)
  | nil => nil
  end.

Definition swap_env (G : env) (p q : PP) : env :=
  fun r : PP =>
  match PP_decidable p r with
  | left _ => G q
  | right _ =>
      match PP_decidable q r with
      | left _ => G p
      | right _ => G r
      end
  end.
         
Axiom different : forall p : PP, exists s : PP, p <> s.

Axiom
  fresh_and_different :
    forall (p : PP) (P : proc), exists r : PP, fresh r P /\ p <> r.

Axiom
  fresh_and_two_different :
    forall (p q : PP) (P : proc),
    exists r : PP, fresh r P /\ p <> r /\ q <> r.

Axiom
  fresh_and_three_different :
    forall (p q r : PP) (P : proc),
    exists s : PP, fresh s P /\ p <> s /\ q <> s /\ r <> s. *)

Require Import induc.
(* induc:
Require Import processus.

Theorem inp_ind :
 forall Pr : proc -> proc -> PP -> PP -> Prop,
 (forall (p q : PP) (x : VV) (P : proc),
  Pr (inp (pname p) x P) (subs_var_proc P (pname q) x) p q) ->
 (forall (P P' : proc) (p q : PP) (x y : VV) (t : type),
  (forall r : PP,
   sem (subs_var_proc P (pname r) x) (ainp p q)
     (subs_var_proc P' (pname r) y)) ->
  (forall r : PP,
   Pr (subs_var_proc P (pname r) x) (subs_var_proc P' (pname r) y) p q) ->
  Pr (res x t P) (res y t P') p q) ->
 (forall (P P' : proc) (p q : PP),
  sem (par (ban P) P) (ainp p q) P' ->
  Pr (par (ban P) P) P' p q -> Pr (ban P) P' p q) ->
 (forall (P P' Q : proc) (p q : PP),
  sem P (ainp p q) P' -> Pr P P' p q -> Pr (par P Q) (par P' Q) p q) ->
 (forall (P P' Q : proc) (p q : PP),
  sem P (ainp p q) P' -> Pr P P' p q -> Pr (par Q P) (par Q P') p q) ->
 (forall (P P' Q : proc) (p q : PP),
  sem P (ainp p q) P' -> Pr P P' p q -> Pr (sum P Q) P' p q) ->
 (forall (P P' Q : proc) (p q : PP),
  sem P (ainp p q) P' -> Pr P P' p q -> Pr (sum Q P) P' p q) ->
 (forall (P P' : proc) (p q r : PP),
  sem P (ainp p q) P' -> Pr P P' p q -> Pr (mat (pname r) (pname r) P) P' p q) ->
 forall (P P' : proc) (p q : PP), sem P (ainp p q) P' -> Pr P P' p q.

Theorem out_ind :
 forall Pr : proc -> proc -> PP -> PP -> Prop,
 (forall (p q : PP) (P : proc), Pr (out (pname p) (pname q) P) P p q) ->
 (forall (P P' : proc) (p q : PP) (x y : VV) (t : type),
  (forall r : PP,
   sem (subs_var_proc P (pname r) x) (aout p q)
     (subs_var_proc P' (pname r) y)) ->
  (forall r : PP,
   Pr (subs_var_proc P (pname r) x) (subs_var_proc P' (pname r) y) p q) ->
  Pr (res x t P) (res y t P') p q) ->
 (forall (P P' : proc) (p q : PP),
  sem (par (ban P) P) (aout p q) P' ->
  Pr (par (ban P) P) P' p q -> Pr (ban P) P' p q) ->
 (forall (P P' Q : proc) (p q : PP),
  sem P (aout p q) P' -> Pr P P' p q -> Pr (par P Q) (par P' Q) p q) ->
 (forall (P P' Q : proc) (p q : PP),
  sem P (aout p q) P' -> Pr P P' p q -> Pr (par Q P) (par Q P') p q) ->
 (forall (P P' Q : proc) (p q : PP),
  sem P (aout p q) P' -> Pr P P' p q -> Pr (sum P Q) P' p q) ->
 (forall (P P' Q : proc) (p q : PP),
  sem P (aout p q) P' -> Pr P P' p q -> Pr (sum Q P) P' p q) ->
 (forall (P P' : proc) (p q r : PP),
  sem P (aout p q) P' -> Pr P P' p q -> Pr (mat (pname r) (pname r) P) P' p q) ->
 forall (P P' : proc) (p q : PP), sem P (aout p q) P' -> Pr P P' p q.

Theorem bout_ind :
 forall Pr : proc -> proc -> PP -> PP -> type -> Prop,
 (forall (p q : PP) (x : VV) (t : type) (P P' : proc),
  fresh q P ->
  q <> p ->
  sem (subs_var_proc P (pname q) x) (aout p q) P' -> Pr (res x t P) P' p q t) ->
 (forall (p q : PP) (x y : VV) (t t' : type) (P P' : proc),
  (forall r : PP,
   sem (subs_var_proc P (pname r) x) (about p q t)
     (subs_var_proc P' (pname r) y)) ->
  (forall r : PP,
   Pr (subs_var_proc P (pname r) x) (subs_var_proc P' (pname r) y) p q t) ->
  Pr (res x t' P) (res y t' P') p q t) ->
 (forall (P P' : proc) (p q : PP) (t : type),
  sem (par (ban P) P) (about p q t) P' ->
  Pr (par (ban P) P) P' p q t -> Pr (ban P) P' p q t) ->
 (forall (P P' Q : proc) (p q : PP) (t : type),
  fresh q Q ->
  sem P (about p q t) P' -> Pr P P' p q t -> Pr (par P Q) (par P' Q) p q t) ->
 (forall (P P' Q : proc) (p q : PP) (t : type),
  fresh q Q ->
  sem P (about p q t) P' -> Pr P P' p q t -> Pr (par Q P) (par Q P') p q t) ->
 (forall (P P' Q : proc) (p q : PP) (t : type),
  sem P (about p q t) P' -> Pr P P' p q t -> Pr (sum P Q) P' p q t) ->
 (forall (P P' Q : proc) (p q : PP) (t : type),
  sem P (about p q t) P' -> Pr P P' p q t -> Pr (sum Q P) P' p q t) ->
 (forall (P P' : proc) (p q r : PP) (t : type),
  sem P (about p q t) P' ->
  Pr P P' p q t -> Pr (mat (pname r) (pname r) P) P' p q t) ->
 forall (P P' : proc) (p q : PP) (t : type),
 sem P (about p q t) P' -> Pr P P' p q t.

Theorem tau_ind :
 forall Pr : proc -> proc -> Prop,
 (forall (P P' Q Q' : proc) (p q : PP),
  sem P (ainp p q) P' -> sem Q (aout p q) Q' -> Pr (par P Q) (par P' Q')) ->
 (forall (P P' Q Q' : proc) (p q : PP),
  sem P (ainp p q) P' -> sem Q (aout p q) Q' -> Pr (par Q P) (par Q' P')) ->
 (forall (P P' Q Q' : proc) (p q r : PP) (t : type) (x : VV),
  fresh q P ->
  freshvar x P' ->
  freshvar x Q' ->
  sem P (ainp p q) P' ->
  sem Q (about p r t) Q' ->
  Pr (par P Q)
    (res x t
       (par (subs_par_proc P' (vname x) q) (subs_par_proc Q' (vname x) r)))) ->
 (forall (P P' Q Q' : proc) (p q r : PP) (t : type) (x : VV),
  fresh q P ->
  freshvar x P' ->
  freshvar x Q' ->
  sem P (ainp p q) P' ->
  sem Q (about p r t) Q' ->
  Pr (par Q P)
    (res x t
       (par (subs_par_proc Q' (vname x) r) (subs_par_proc P' (vname x) q)))) ->
 (forall (x y : VV) (t' : type) (P P' : proc),
  (forall r : PP,
   sem (subs_var_proc P (pname r) x) tau (subs_var_proc P' (pname r) y)) ->
  (forall r : PP,
   Pr (subs_var_proc P (pname r) x) (subs_var_proc P' (pname r) y)) ->
  Pr (res x t' P) (res y t' P')) ->
 (forall P P' : proc,
  sem (par (ban P) P) tau P' -> Pr (par (ban P) P) P' -> Pr (ban P) P') ->
 (forall P P' Q : proc, sem P tau P' -> Pr P P' -> Pr (par P Q) (par P' Q)) ->
 (forall P P' Q : proc, sem P tau P' -> Pr P P' -> Pr (par Q P) (par Q P')) ->
 (forall P P' Q : proc, sem P tau P' -> Pr P P' -> Pr (sum P Q) P') ->
 (forall P P' Q : proc, sem P tau P' -> Pr P P' -> Pr (sum Q P) P') ->
 (forall (P P' : proc) (r : PP),
  sem P tau P' -> Pr P P' -> Pr (mat (pname r) (pname r) P) P') ->
 forall P P' : proc, sem P tau P' -> Pr P P'. *)



Theorem freshname_is :

 forall (p : PP) (n : name), freshname p n -> n <> pname p.

Proof.

intros.

elim H.

intros.

red in |- *; intro.

injection H1.

intro; elim H0.

symmetry  in |- *; assumption.

intro; red in |- *; intro.

discriminate H0.

Qed.



Theorem freshvarname_is :

 forall (x : VV) (n : name), freshvarname x n -> n <> vname x.

Proof.

intros x n; case n.

intros.

red in |- *; intro foo; discriminate foo.

intros v foo; inversion_clear foo.

red in |- *; intro foo; injection foo.

intro; elim H; symmetry  in |- *; assumption.

Qed.



Theorem fresh_after_subs_name :

 forall (p q : PP) (x : VV) (n : name),

 p <> q -> freshname p n -> freshname p (subs_var_name n (pname q) x).

Proof.

intros p q x n; case n.

intros.

inversion_clear H0.

simpl in |- *.

apply freshp.

assumption.

intros.

inversion_clear H0.

simpl in |- *.

case (VV_decidable x v).

intro; apply freshp.

assumption.

intros; apply freshv.

Qed.



Theorem fresh_after_subs :

 forall (p q : PP) (x : VV) (P : proc),

 p <> q -> fresh p P -> fresh p (subs_var_proc P (pname q) x).

Proof.

intros p q x; simple induction P.

intros; simpl in |- *; apply frnil.

intros n v p' hyprec p_not_q fresh_p; inversion_clear fresh_p.

simpl in |- *; apply frinp.

apply fresh_after_subs_name.

assumption.

assumption.

case (VV_decidable x v).

intro eq; assumption.

intro neq; apply hyprec; assumption.

intros n1 n2 Q hyprec p_not_q fresh_p; inversion_clear fresh_p.

simpl in |- *; apply frout.

apply fresh_after_subs_name; assumption.

apply fresh_after_subs_name; assumption.

apply hyprec; assumption.

intros Q hypQ R hypR p_not_q fresh_p; inversion_clear fresh_p; simpl in |- *;

 apply frpar.

apply hypQ; assumption.

apply hypR; assumption.

intros v t Q hyprec p_not_q fresh_p; inversion_clear fresh_p; simpl in |- *.

apply frres.

case (VV_decidable x v).

intro eq; assumption.

intro neq; apply hyprec; assumption.

intros Q hyprec p_not_q fresh_p; inversion_clear fresh_p.

simpl in |- *; apply frban.

apply hyprec; assumption.

intros Q hypQ R hypR p_not_q fresh_p; inversion_clear fresh_p.

simpl in |- *; apply frsum.

apply hypQ; assumption.

apply hypR; assumption.

intros n1 n2 Q hyprec p_not_q fresh_p; inversion_clear fresh_p.

simpl in |- *; apply frmat.

apply fresh_after_subs_name; assumption.

apply fresh_after_subs_name; assumption.

apply hyprec; assumption.

Qed.



Theorem fresh_after_subs_par_name :

 forall (p q r : PP) (n : name),

 r <> p -> freshname r n -> freshname r (subs_par_name n (pname p) q).

Proof.

intros p q r n.

case n.

intros s r_not_p fresh_r.

simpl in |- *.

case (PP_decidable q s).

intro same.

apply freshp.

assumption.

intros; assumption.

intros v r_not_p fresh.

simpl in |- *.

apply freshv.

Qed.



Theorem fresh_after_subs_par :

 forall (p q r : PP) (P : proc),

 r <> p -> fresh r P -> fresh r (subs_par_proc P (pname p) q).

Proof.

simple induction P.

intros; simpl in |- *; apply frnil.

intros n v Q hyprec r_not_p fresh_r.

simpl in |- *.

inversion_clear fresh_r.

apply frinp.

apply fresh_after_subs_par_name.

assumption.

assumption.

apply hyprec; assumption.

intros n1 n2 Q hyprec r_not_p fresh_r.

simpl in |- *.

inversion_clear fresh_r.

apply frout.

apply fresh_after_subs_par_name.

assumption.

assumption.

apply fresh_after_subs_par_name.

assumption.

assumption.

apply hyprec; assumption.

intros Q hrQ R hrR r_not_p fresh_r.

inversion_clear fresh_r.

simpl in |- *.

apply frpar.

apply hrQ; assumption.

apply hrR; assumption.

intros v t Q hr r_not_p fresh_r.

inversion_clear fresh_r.

simpl in |- *.

apply frres.

apply hr; assumption.

intros PP hr r_not_p fresh_r.

inversion_clear fresh_r.

simpl in |- *; apply frban.

apply hr; assumption.

intros Q hrQ R hrR r_not_p fresh_r.

inversion_clear fresh_r.

simpl in |- *; apply frsum.

apply hrQ; assumption.

apply hrR; assumption.

intros n1 n2 Q hr r_not_p fresh_r.

inversion_clear fresh_r.

simpl in |- *.

apply frmat.

apply fresh_after_subs_par_name.

assumption.

assumption.

apply fresh_after_subs_par_name; assumption.

apply hr; assumption.

Qed.



Theorem fresh_after_subs_by_var_name :

 forall (n : name) (p q : PP) (x : VV),

 freshname p n -> freshname p (subs_par_name n (vname x) q).

Proof.

intros n p q x.

case n.

intros r fresh.

simpl in |- *.

case (PP_decidable q r).

intro same.

apply freshv.

intro notsame.

apply freshp.

red in |- *; intro.

rewrite H in fresh.

inversion_clear fresh.

elim H0; reflexivity.

intros.

inversion_clear H.

simpl in |- *.

apply freshv.

Qed.



Theorem fresh_after_subs_by_var :

 forall (P : proc) (p q : PP) (x : VV),

 fresh p P -> fresh p (subs_par_proc P (vname x) q).

Proof.

simple induction P.

intros; simpl in |- *; apply frnil.

intros; simpl in |- *.

inversion_clear H0.

apply frinp.

apply fresh_after_subs_by_var_name.

assumption.

apply H; assumption.

intros; simpl in |- *.

inversion_clear H0.

apply frout.

apply fresh_after_subs_by_var_name.

assumption.

apply fresh_after_subs_by_var_name.

assumption.

apply H; assumption.

intros.

simpl in |- *.

inversion_clear H1.

apply frpar.

apply H; assumption.

apply H0; assumption.

intros.

inversion_clear H0; simpl in |- *; apply frres.

apply H; assumption.

intros Q hyprec p q x fresh_p.

simpl in |- *.

inversion_clear fresh_p.

apply frban.

apply hyprec; assumption.

intros Q hyprecQ R hyprecR p q x fresh_; simpl in |- *;

 inversion_clear fresh_.

apply frsum.

apply hyprecQ; assumption.

apply hyprecR; assumption.

intros n1 n2 Q hyprec p q x fresh_; inversion_clear fresh_; simpl in |- *.

apply frmat.

apply fresh_after_subs_by_var_name.

assumption.

apply fresh_after_subs_by_var_name; assumption.

apply hyprec; assumption.

Qed.

 

Theorem fresh_before_subs_name :

 forall (p q : PP) (x : VV) (n : name),

 freshname p (subs_var_name n (pname q) x) -> freshname p n.

Proof.

intros p q x n; case n.

intros q0 fresh_p; inversion_clear fresh_p.

apply freshp.

simpl in H.

assumption.

intros v fresh_p.

inversion_clear fresh_p.

apply freshv.

apply freshv.

Qed.



Theorem fresh_before_subs :

 forall (p q : PP) (x : VV) (P : proc),

 fresh p (subs_var_proc P (pname q) x) -> fresh p P.

Proof.

simple induction P.

intro; apply frnil.

intros n v Q hyprec.

simpl in |- *.

case (VV_decidable x v).

intros prot fresh_p.

inversion_clear fresh_p.

apply frinp.

apply fresh_before_subs_name with (x := x) (q := q).

assumption.

assumption.

intros not_prot fresh_p.

inversion_clear fresh_p.

apply frinp.

apply fresh_before_subs_name with (x := x) (q := q).

assumption.

apply hyprec; assumption.

intros n1 n2 Q.

simpl in |- *.

intros hyprec fresh_p; inversion_clear fresh_p.

apply frout.

apply fresh_before_subs_name with (x := x) (q := q).

assumption.

apply fresh_before_subs_name with (x := x) (q := q).

assumption.

apply hyprec.

assumption.

intros Q hyprecQ R hyprecR; simpl in |- *.

intro fresh_p; inversion_clear fresh_p.

apply frpar.

apply hyprecQ; assumption.

apply hyprecR; assumption.

intros v t Q hyprec; simpl in |- *.

case (VV_decidable x v).

intros prot fresh_p; assumption.

intros not_prot fresh_p; inversion_clear fresh_p; apply frres.

apply hyprec; assumption.

intros Q hyprec; simpl in |- *.

intro fresh_p; inversion_clear fresh_p.

apply frban; apply hyprec; assumption.

intros Q hyprecQ R hyprecR; simpl in |- *.

intro fresh_p; inversion_clear fresh_p; apply frsum.

apply hyprecQ; assumption.

apply hyprecR; assumption.

intros n1 n2 Q hyprec; simpl in |- *; intro fresh_p; inversion_clear fresh_p.

apply frmat.

apply fresh_before_subs_name with (x := x) (q := q).

assumption.

apply fresh_before_subs_name with (x := x) (q := q); assumption.

apply hyprec; assumption.

Qed.



Theorem out_known_name :

 forall (P P' : proc) (p q : PP), sem P (aout p q) P' -> ~ fresh q P.

Proof.

intros P P' p q red.

apply

 out_ind

  with

    (Pr := fun (P P' : proc) (p q : PP) => ~ fresh q P)

    (P' := P')

    (p := p).

intros p0 q0 PP; red in |- *; intro.

inversion_clear H.

inversion_clear H1.

elim H; reflexivity.

intros Q Q' p0 q0 x y t hyprec.

intro not_fresh.

red in |- *; intro.

inversion_clear H.

cut (exists s : PP, fresh s Q /\ q0 <> s).

intro exists_; elim exists_.

intros s s_props.

elim s_props; intros fresh_s q0_not_s.

cut (fresh q0 (subs_var_proc Q (pname s) x)).

intro.

cut (~ fresh q0 (subs_var_proc Q (pname s) x)).

intro absurd; elim absurd.

assumption.

apply not_fresh.

apply fresh_after_subs.

assumption.

assumption.

apply fresh_and_different.

intros Q Q' p0 q0 red0 not_fresh; red in |- *; intro.

inversion_clear H.

cut (fresh q0 (par (ban Q) Q)).

intro; elim not_fresh; assumption.

apply frpar.

apply frban.

assumption.

assumption.

intros Q Q' R p0 q0 red0 not_fresh; red in |- *; intro.

inversion_clear H.

elim not_fresh.

assumption.

intros Q Q' R p0 q0 red0 not_fresh.

red in |- *; intros.

inversion_clear H.

elim not_fresh; assumption.

intros Q Q' R p0 q0 red0 not_fresh; red in |- *; intro.

inversion_clear H.

elim not_fresh; assumption.

intros Q Q' R p0 q0 red0 not_fresh; red in |- *; intro.

inversion_clear H.

elim not_fresh; assumption.

intros Q Q' p0 q0 r red0 not_fresh; red in |- *; intro.

inversion_clear H.

elim not_fresh; assumption.

assumption.

Qed.



Theorem inp_on_known_name :

 forall (P P' : proc) (p q : PP), sem P (ainp p q) P' -> ~ fresh p P.

Proof.

intros P P' p q reduction.

apply

 inp_ind

  with

    (Pr := fun (P P' : proc) (p q : PP) => ~ fresh p P)

    (P' := P')

    (q := q).

intros; red in |- *; intro.

inversion_clear H.

inversion_clear H0.

elim H; reflexivity.

intros Q Q' p0 q0 x y t hyprec.

intro fresh_p0.

red in |- *; intro.

inversion_clear H.

cut (exists s : PP, fresh s Q /\ p0 <> s).

intro exists_; elim exists_.

intros s s_props; elim s_props.

intros fresh_s p0_not_s.

cut (fresh p0 (subs_var_proc Q (pname s) x)).

intro fresh_2.

cut (~ fresh p0 (subs_var_proc Q (pname s) x)).

intro absurd; elim absurd.

assumption.

apply fresh_p0.

apply fresh_after_subs.

assumption.

assumption.

apply fresh_and_different.

intros Q Q' p0 q0 red not_fresh.

red in |- *; intro.

inversion_clear H.

cut (fresh p0 (par (ban Q) Q)).

intro; elim not_fresh.

assumption.

apply frpar.

apply frban; assumption.

assumption.

intros Q Q' R p0 q0 red not_fresh; red in |- *; intro.

inversion_clear H.

elim not_fresh; assumption.

intros Q Q' R p0 q0 red not_fresh; red in |- *; intro.

inversion_clear H.

elim not_fresh; assumption.

intros Q Q' R p0 q0 red not_fresh; red in |- *; intro.

inversion_clear H.

elim not_fresh; assumption.

intros Q Q' R p0 q0 red not_fresh; red in |- *; intro.

inversion_clear H.

elim not_fresh; assumption.

intros Q Q' p0 q0 r red not_fresh; red in |- *; intro.

inversion_clear H.

elim not_fresh; assumption.

assumption.

Qed.



Theorem fresh_masked_by_var_name :

 forall (n : name) (p : PP) (x : VV),

 freshname p (subs_par_name n (vname x) p).

Proof.

intro n; case n.

intros p q x.

simpl in |- *.

case (PP_decidable q p).

intro; apply freshv.

intro; apply freshp; assumption.

intros v p x; simpl in |- *.

apply freshv.

Qed.



Theorem fresh_masked_by_var :

 forall (P : proc) (p : PP) (x : VV), fresh p (subs_par_proc P (vname x) p).

Proof.

simple induction P.

intros; simpl in |- *; apply frnil.

intros n v Q hyprec p x.

simpl in |- *.

apply frinp.

apply fresh_masked_by_var_name.

apply hyprec.

intros n1 n2 Q hyprec p x; simpl in |- *.

apply frout.

apply fresh_masked_by_var_name.

apply fresh_masked_by_var_name.

apply hyprec.

intros Q hyprecQ R hyprecR p x; simpl in |- *.

apply frpar.

apply hyprecQ; assumption.

apply hyprecR; assumption.

intros v t Q hyprec p x; simpl in |- *.

apply frres.

apply hyprec.

intros Q hyprec p x; simpl in |- *.

apply frban; apply hyprec; assumption.

intros Q hyprecQ R hyprecR p x; simpl in |- *; apply frsum.

apply hyprecQ; assumption.

apply hyprecR; assumption.

intros n1 n2 Q hyprec p x; simpl in |- *; apply frmat.

apply fresh_masked_by_var_name.

apply fresh_masked_by_var_name.

apply hyprec; assumption.

Qed.



Theorem fresh_after_trans :

 forall (P P' : proc) (mu : act),

 sem P mu P' -> forall q : PP, fresh q P -> freshact q mu -> fresh q P'.

Proof.

intros P P' mu red.

elim red.

intros p q x Q q0 fresh_init fresh_act.

inversion_clear fresh_init; inversion_clear fresh_act.

apply fresh_after_subs.

assumption.

assumption.

intros p q Q q0 fresh_init fresh_act.

inversion_clear fresh_init; assumption.

intros Q Q' R R' p q reduction.

intro hyprec.

intros reductrionR hyprecR.

intros q0 fresh_init fresh_act.

inversion_clear fresh_init.

apply frpar.

apply hyprec.

assumption.

apply fainp.

cut (~ fresh p Q).

intro.

red in |- *; intro.

rewrite <- H2 in H1.

elim H1; assumption.

apply inp_on_known_name with (P' := Q') (q := q).

assumption.

cut (~ fresh q R).

intro.

red in |- *; intro inepte.

rewrite <- inepte in H1.

elim H1; assumption.

apply out_known_name with (P' := R') (p := p).

assumption.

apply hyprecR.

assumption.

apply faout.

cut (~ fresh p Q).

intro; red in |- *; intro absurd.

rewrite absurd in H; elim H1; assumption.

apply inp_on_known_name with (P' := Q') (q := q).

assumption.

cut (~ fresh q R).

intro; red in |- *; intro.

rewrite H2 in H0; elim H1; assumption.

apply out_known_name with (P' := R') (p := p); assumption.

intros.

inversion_clear H3.

apply frpar.

apply H0.

assumption.

apply faout.

cut (~ fresh p Q).

intro; red in |- *; intro.

rewrite H7 in H6; elim H3; assumption.

apply inp_on_known_name with (P' := Q') (q := q).

assumption.

cut (~ fresh q P0).

intro; red in |- *; intro.

rewrite H7 in H5; elim H3; assumption.

apply out_known_name with (P' := P'0) (p := p).

assumption.

apply H2.

assumption.

apply fainp.

cut (~ fresh p Q).

intro; red in |- *; intro.

rewrite H7 in H6.

elim H3; assumption.

apply inp_on_known_name with (P' := Q') (q := q).

assumption.

cut (~ fresh q P0).

intro; red in |- *; intro.

rewrite H7 in H5; elim H3; assumption.

apply out_known_name with (P' := P'0) (p := p).

assumption.

intros PP PP' p q x t fresh_q p_not_q.

intros.

apply H0.

inversion_clear H2.

inversion_clear H1.

apply fresh_after_subs.

assumption.

assumption.

inversion_clear H2.

apply faout.

assumption.

assumption.

intros Q Q' R R' p q r t x inp_unknown freshvar_1 freshvar_2.

intros input hyprec_inp output hyprec_out.

intros q' fresh_q' fresh_act_q'.

inversion_clear fresh_q'.

apply frres.

apply frpar.

case (PP_decidable q' q).

intro same; rewrite same.

apply fresh_masked_by_var.

intro not_same.

apply fresh_after_subs_by_var.

apply hyprec_inp.

assumption.

apply fainp.

red in |- *; intro.

cut (~ fresh p Q).

intro; rewrite H1 in H.

elim H2; assumption.

apply inp_on_known_name with (P' := Q') (q := q).

assumption.

assumption.

case (PP_decidable q' r).

intro same; rewrite same.

apply fresh_masked_by_var.

intro not_same.

apply fresh_after_subs_by_var.

apply hyprec_out.

assumption.

apply fabout.

cut (~ fresh p Q).

intro; red in |- *; intro same.

rewrite same in H.

elim H1; assumption.

apply inp_on_known_name with (P' := Q') (q := q).

assumption.

assumption.

intros Q Q' R R' p q r t x fresh_q_P fv1 fv2 input hr_inp output hr_out.

intros s fresh_s fresh_act.

inversion_clear fresh_s.

cut (s <> p).

intro s_not_p.

apply frres.

apply frpar.

case (PP_decidable s r).

intro same; rewrite same; apply fresh_masked_by_var.

intro not_same.

apply fresh_after_subs_by_var.

apply hr_out.

assumption.

apply fabout.

assumption.

assumption.

case (PP_decidable s q).

intro same; rewrite same; apply fresh_masked_by_var.

intro s_not_q; apply fresh_after_subs_by_var.

apply hr_inp.

assumption.

apply fainp; assumption.

red in |- *; intro; cut (~ fresh p Q).

intro absurd; rewrite H1 in H0; elim absurd; assumption.

apply inp_on_known_name with (P' := Q') (q := q).

assumption.

intros Q Q' mu0 x y t hyp hyprec s fresh_s.

inversion_clear fresh_s; intro fresh_act; apply frres.

cut (exists r : PP, fresh r Q /\ s <> r).

intro exists_; elim exists_.

intros s0 s0_props; elim s0_props.

intros fresh_s0 s_not_s0.

apply fresh_before_subs with (q := s0) (x := y).

apply hyprec.

apply fresh_after_subs.

assumption.

assumption.

assumption.

apply fresh_and_different.

intros Q Q' nu red0 hyprec s fresh_s fresh_act.

inversion_clear fresh_s.

apply hyprec.

apply frpar.

apply frban; assumption.

assumption.

assumption.

intros Q Q' R nu hyp red0 hyprec s fresh_s.

intro fresh_act.

inversion_clear fresh_s.

apply frpar.

apply hyprec.

assumption.

assumption.

assumption.

intros Q Q' R nu hyp red0 hyprec s fresh_s fresh_act.

inversion_clear fresh_s.

apply frpar.

assumption.

apply hyprec; assumption.

intros Q Q' R nu red0 hyprec s fresh_s fresh_act.

inversion_clear fresh_s.

apply hyprec; assumption.

intros Q Q' R nu red0 hyprec s fresh_s fresh_act.

inversion_clear fresh_s.

apply hyprec; assumption.

intros Q Q' p nu red0 hyprec s fresh_s fresh_act.

inversion_clear fresh_s.

apply hyprec; assumption.

Qed.



Theorem fresh_mask_name :

 forall (n : name) (p q : PP),

 p <> q -> freshname q (subs_par_name n (pname p) q).

Proof.

intro n; case n.

intros p q r q_not_r.

simpl in |- *.

case (PP_decidable r p).

intros same.

apply freshp.

red in |- *; intro; elim q_not_r; symmetry  in |- *; assumption.

intro not_same; apply freshp.

assumption.

intros v p q p_not_q.

simpl in |- *.

apply freshv.

Qed.



Theorem fresh_mask :

 forall (P : proc) (p q : PP),

 p <> q -> fresh q (subs_par_proc P (pname p) q).

Proof.

simple induction P.

intros; simpl in |- *; apply frnil.

intros n v Q hr p q p_not_q.

simpl in |- *.

apply frinp.

apply fresh_mask_name; assumption.

apply hr; assumption.

intros n1 n2 Q hr p q p_not_q.

simpl in |- *.

apply frout.

apply fresh_mask_name; assumption.

apply fresh_mask_name; assumption.

apply hr; assumption.

intros Q hrQ R hrR p q p_not_q.

simpl in |- *.

apply frpar.

apply hrQ; assumption.

apply hrR; assumption.

intros v t Q hr p q p_not_q.

simpl in |- *.

apply frres.

apply hr; assumption.

intros PP hr p q p_not_q.

simpl in |- *.

apply frban.

apply hr; assumption.

intros PP hrP Q hrQ p q p_not_q.

simpl in |- *.

apply frsum.

apply hrP; assumption.

apply hrQ; assumption.

intros n1 n2 Q hr p q p_not_q.

simpl in |- *.

apply frmat.

apply fresh_mask_name; assumption.

apply fresh_mask_name; assumption.

apply hr; assumption.

Qed.
