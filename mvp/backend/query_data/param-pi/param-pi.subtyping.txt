

Require Import processus.
(* processus:
Inductive capa : Set :=
  | Read : capa
  | Write : capa
  | Both : capa
  | Nil : capa.

Inductive capst : capa -> capa -> Prop :=
  | capst_refl : forall c : capa, capst c c
  | capst_nil : forall c : capa, capst c Nil
  | capst_both : forall c : capa, capst Both c.

Parameter type : Set.

Parameter getcap : type -> capa.

Parameter getobj : type -> type.

Parameter typest : type -> type -> Prop.

Axiom typest_refl : forall t : type, typest t t.

Axiom
  typest_trans :
    forall t t' : type,
    typest t t' -> forall t'' : type, typest t' t'' -> typest t t''.

Theorem capst_trans :
 forall c c' c'' : capa, capst c c' -> capst c' c'' -> capst c c''.

Parameter PP : Set.
Parameter VV : Set.

Axiom PP_decidable : forall p q : PP, {p = q} + {p <> q}.
Axiom VV_decidable : forall x y : VV, {x = y} + {x <> y}.

Inductive name : Set :=
  | pname : PP -> name
  | vname : VV -> name.

Inductive proc : Set :=
  | nil : proc
  | inp : name -> VV -> proc -> proc
  | out : name -> name -> proc -> proc
  | par : proc -> proc -> proc
  | res : VV -> type -> proc -> proc
  | ban : proc -> proc
  | sum : proc -> proc -> proc
  | mat : name -> name -> proc -> proc.

Definition subs_var_name (n m : name) (x : VV) : name :=
  match n with
  | pname p => n
  | vname v => match VV_decidable x v with
               | left _ => m
               | right _ => n
               end
  end.

Fixpoint subs_var_proc (P : proc) : name -> VV -> proc :=
  fun (n : name) (x : VV) =>
  match P with
  | nil => nil
  | inp m v qq =>
      inp (subs_var_name m n x) v
        match VV_decidable x v with
        | left _ => qq
        | right _ => subs_var_proc qq n x
        end
  | out m1 m2 qq =>
      out (subs_var_name m1 n x) (subs_var_name m2 n x)
        (subs_var_proc qq n x)
  | par qq rr => par (subs_var_proc qq n x) (subs_var_proc rr n x)
  | res v t qq =>
      res v t
        match VV_decidable x v with
        | left _ => qq
        | right _ => subs_var_proc qq n x
        end
  | ban qq => ban (subs_var_proc qq n x)
  | sum qq rr => sum (subs_var_proc qq n x) (subs_var_proc rr n x)
  | mat m1 m2 qq =>
      mat (subs_var_name m1 n x) (subs_var_name m2 n x)
        (subs_var_proc qq n x)
  end.

Definition subs_par_name (n m : name) (p : PP) : name :=
  match n with
  | pname q => match PP_decidable p q with
               | left _ => m
               | right _ => n
               end
  | vname v => n
  end.

Fixpoint subs_par_proc (P : proc) : name -> PP -> proc :=
  fun (n : name) (p : PP) =>
  match P with
  | nil => nil
  | inp m v qq => inp (subs_par_name m n p) v (subs_par_proc qq n p)
  | out m1 m2 qq =>
      out (subs_par_name m1 n p) (subs_par_name m2 n p)
        (subs_par_proc qq n p)
  | par qq rr => par (subs_par_proc qq n p) (subs_par_proc rr n p)
  | res v t qq => res v t (subs_par_proc qq n p)
  | ban qq => ban (subs_par_proc qq n p)
  | sum qq rr => sum (subs_par_proc qq n p) (subs_par_proc rr n p)
  | mat m1 m2 qq =>
      mat (subs_par_name m1 n p) (subs_par_name m2 n p)
        (subs_par_proc qq n p)
  end.

Inductive freshname (p : PP) : name -> Prop :=
  | freshp : forall q : PP, p <> q -> freshname p (pname q)
  | freshv : forall v : VV, freshname p (vname v).

Inductive fresh (p : PP) : proc -> Prop :=
  | frnil : fresh p nil
  | frinp :
      forall (m : name) (v : VV) (Q : proc),
      freshname p m -> fresh p Q -> fresh p (inp m v Q)
  | frout :
      forall (m1 m2 : name) (Q : proc),
      freshname p m1 -> freshname p m2 -> fresh p Q -> fresh p (out m1 m2 Q)
  | frpar : forall P Q : proc, fresh p P -> fresh p Q -> fresh p (par P Q)
  | frres :
      forall (v : VV) (t : type) (Q : proc), fresh p Q -> fresh p (res v t Q)
  | frban : forall Q : proc, fresh p Q -> fresh p (ban Q)
  | frsum : forall P Q : proc, fresh p P -> fresh p Q -> fresh p (sum P Q)
  | frmat :
      forall (m1 m2 : name) (Q : proc),
      freshname p m1 -> freshname p m2 -> fresh p Q -> fresh p (mat m1 m2 Q).

Inductive freshvarname (v : VV) : name -> Prop :=
  | freshvp : forall p : PP, freshvarname v (pname p)
  | freshvv : forall x : VV, v <> x -> freshvarname v (vname x).

Inductive freshvar (v : VV) : proc -> Prop :=
  | fvnil : freshvar v nil
  | fvinp :
      forall (m : name) (x : VV) (Q : proc),
      freshvarname v m -> v <> x -> freshvar v Q -> freshvar v (inp m x Q)
  | fvout :
      forall (m1 m2 : name) (Q : proc),
      freshvarname v m1 ->
      freshvarname v m2 -> freshvar v Q -> freshvar v (out m1 m2 Q)
  | fvpar :
      forall P Q : proc, freshvar v P -> freshvar v Q -> freshvar v (par P Q)
  | fvres :
      forall (x : VV) (t : type) (Q : proc),
      v <> x -> freshvar v Q -> freshvar v (res x t Q)
  | fvban : forall Q : proc, freshvar v Q -> freshvar v (ban Q)
  | fvsum :
      forall P Q : proc, freshvar v P -> freshvar v Q -> freshvar v (sum P Q)
  | fvmat :
      forall (m1 m2 : name) (Q : proc),
      freshvarname v m1 ->
      freshvarname v m2 -> freshvar v Q -> freshvar v (mat m1 m2 Q).

Inductive act : Set :=
  | aout : PP -> PP -> act
  | ainp : PP -> PP -> act
  | about : PP -> PP -> type -> act
  | tau : act.

Inductive freshact (p : PP) : act -> Prop :=
  | faout : forall q1 q2 : PP, p <> q1 -> p <> q2 -> freshact p (aout q1 q2)
  | fainp : forall q1 q2 : PP, p <> q1 -> p <> q2 -> freshact p (ainp q1 q2)
  | fabout :
      forall (q1 q2 : PP) (t : type),
      p <> q1 -> p <> q2 -> freshact p (about q1 q2 t)
  | ftau : freshact p tau.

Inductive sem : proc -> act -> proc -> Prop :=
  | sinp :
      forall (p q : PP) (x : VV) (Q : proc),
      sem (inp (pname p) x Q) (ainp p q) (subs_var_proc Q (pname q) x)
  | sout :
      forall (p q : PP) (Q : proc),
      sem (out (pname p) (pname q) Q) (aout p q) Q
  | scoml :
      forall (P P' Q Q' : proc) (p q : PP),
      sem P (ainp p q) P' ->
      sem Q (aout p q) Q' -> sem (par P Q) tau (par P' Q')
  | scomr :
      forall (P P' Q Q' : proc) (p q : PP),
      sem P (aout p q) P' ->
      sem Q (ainp p q) Q' -> sem (par P Q) tau (par P' Q')
  | sopen :
      forall (P P' : proc) (p q : PP) (x : VV) (t : type),
      fresh q P ->
      p <> q ->
      sem (subs_var_proc P (pname q) x) (aout p q) P' ->
      sem (res x t P) (about p q t) P'
  | sclosel :
      forall (P P' Q Q' : proc) (p q r : PP) (t : type) (x : VV),
      fresh q P ->
      freshvar x P' ->
      freshvar x Q' ->
      sem P (ainp p q) P' ->
      sem Q (about p r t) Q' ->
      sem (par P Q) tau
        (res x t
           (par (subs_par_proc P' (vname x) q) (subs_par_proc Q' (vname x) r)))
  | scloser :
      forall (P P' Q Q' : proc) (p q r : PP) (t : type) (x : VV),
      fresh q P ->
      freshvar x P' ->
      freshvar x Q' ->
      sem P (ainp p q) P' ->
      sem Q (about p r t) Q' ->
      sem (par Q P) tau
        (res x t
           (par (subs_par_proc Q' (vname x) r) (subs_par_proc P' (vname x) q)))
  | sres :
      forall (P P' : proc) (mu : act) (x y : VV) (t : type),
      (forall q : PP,
       sem (subs_var_proc P (pname q) x) mu (subs_var_proc P' (pname q) y)) ->
      sem (res x t P) mu (res y t P')
  | sban :
      forall (P P' : proc) (mu : act),
      sem (par (ban P) P) mu P' -> sem (ban P) mu P'
  | sparl :
      forall (P P' Q : proc) (mu : act),
      (forall (p q : PP) (t : type), mu = about p q t -> fresh q Q) ->
      sem P mu P' -> sem (par P Q) mu (par P' Q)
  | sparr :
      forall (P P' Q : proc) (mu : act),
      (forall (p q : PP) (t : type), mu = about p q t -> fresh q Q) ->
      sem P mu P' -> sem (par Q P) mu (par Q P')
  | ssuml :
      forall (P P' Q : proc) (mu : act), sem P mu P' -> sem (sum P Q) mu P'
  | ssumr :
      forall (P P' Q : proc) (mu : act), sem P mu P' -> sem (sum Q P) mu P'
  | smat :
      forall (P P' : proc) (p : PP) (mu : act),
      sem P mu P' -> sem (mat (pname p) (pname p) P) mu P'.

Definition env : Type := PP -> type.

Definition addenv (G : env) (p : PP) (t : type) : env :=
  fun q : PP =>
  match PP_decidable p q with
  | left _ => t
  | right _ => G q
  end.

Definition envst (G D : env) : Prop := forall p : PP, typest (G p) (D p).

Definition eqvenv (G D : env) : Prop := forall p : PP, G p = D p.

Inductive typing : env -> proc -> Prop :=
  | tnil : forall G : env, typing G nil
  | tinp :
      forall (G : env) (p : PP) (x : VV) (P : proc),
      capst (getcap (G p)) Read ->
      (forall q : PP,
       fresh q P ->
       typing (addenv G q (getobj (G p))) (subs_var_proc P (pname q) x)) ->
      typing G (inp (pname p) x P)
  | tout :
      forall (G : env) (p q : PP) (P : proc),
      capst (getcap (G p)) Write ->
      typest (G q) (getobj (G p)) ->
      typing G P -> typing G (out (pname p) (pname q) P)
  | tpar :
      forall (G : env) (P Q : proc),
      typing G P -> typing G Q -> typing G (par P Q)
  | tres :
      forall (G : env) (x : VV) (t : type) (P : proc),
      (forall q : PP,
       fresh q P -> typing (addenv G q t) (subs_var_proc P (pname q) x)) ->
      typing G (res x t P)
  | tban : forall (G : env) (P : proc), typing G P -> typing G (ban P)
  | tsum :
      forall (G : env) (P Q : proc),
      typing G P -> typing G Q -> typing G (sum P Q)
  | tmat :
      forall (G : env) (p q : PP) (P : proc),
      getcap (G p) = Both ->
      getcap (G q) = Both ->
      typing G P -> typing G (mat (pname p) (pname q) P).

Definition swap_par (r p q : PP) : PP :=
  match PP_decidable r p with
  | left _ => q
  | right _ => match PP_decidable r q with
               | left _ => p
               | right _ => r
               end
  end.

Definition swap_name (n : name) (p q : PP) : name :=
  match n with
  | pname r =>
      match PP_decidable r p with
      | left _ => pname q
      | right _ =>
          match PP_decidable r q with
          | left _ => pname p
          | right _ => pname r
          end
      end
  | vname x => vname x
  end.

Fixpoint swap_proc (P : proc) : PP -> PP -> proc :=
  fun p q : PP =>
  match P with
  | inp n x p1 => inp (swap_name n p q) x (swap_proc p1 p q)
  | out n1 n2 p1 =>
      out (swap_name n1 p q) (swap_name n2 p q) (swap_proc p1 p q)
  | res x t p1 => res x t (swap_proc p1 p q)
  | par p1 p2 => par (swap_proc p1 p q) (swap_proc p2 p q)
  | ban p1 => ban (swap_proc p1 p q)
  | sum p1 p2 => sum (swap_proc p1 p q) (swap_proc p2 p q)
  | mat n1 n2 p1 =>
      mat (swap_name n1 p q) (swap_name n2 p q) (swap_proc p1 p q)
  | nil => nil
  end.

Definition swap_env (G : env) (p q : PP) : env :=
  fun r : PP =>
  match PP_decidable p r with
  | left _ => G q
  | right _ =>
      match PP_decidable q r with
      | left _ => G p
      | right _ => G r
      end
  end.
         
Axiom different : forall p : PP, exists s : PP, p <> s.

Axiom
  fresh_and_different :
    forall (p : PP) (P : proc), exists r : PP, fresh r P /\ p <> r.

Axiom
  fresh_and_two_different :
    forall (p q : PP) (P : proc),
    exists r : PP, fresh r P /\ p <> r /\ q <> r.

Axiom
  fresh_and_three_different :
    forall (p q r : PP) (P : proc),
    exists s : PP, fresh s P /\ p <> s /\ q <> s /\ r <> s. *)

Require Import typing_proofs.
(* typing_proofs:
Require Import processus.
Require Import fresh.

Unset Standard Proposition Elimination Names.

Theorem gettype_not_added_name :
 forall (G : env) (p q : PP) (t : type), p <> q -> addenv G p t q = G q.

Theorem gettype_added_name :
 forall (G : env) (p : PP) (t : type), addenv G p t p = t.

Theorem eqv_addenv :
 forall (G D : env) (p : PP) (t : type),
 eqvenv G D -> eqvenv (addenv G p t) (addenv D p t).

Theorem eqv_trans :
 forall G G' G'' : env, eqvenv G G' -> eqvenv G' G'' -> eqvenv G G''.

Theorem eqv_typing :
 forall G D : env, eqvenv G D -> forall P : proc, typing G P -> typing D P.

Theorem switch_addenv :
 forall (G : env) (p q : PP) (t1 t2 : type),
 p <> q -> eqvenv (addenv (addenv G p t1) q t2) (addenv (addenv G q t2) p t1). 

Theorem trivial_addenv :
 forall (G : env) (p : PP), eqvenv G (addenv G p (G p)).

Theorem redundant_addenv :
 forall (G : env) (P : proc),
 typing G P ->
 forall (D : env) (p : PP) (t : type),
 fresh p P -> eqvenv G (addenv D p t) -> typing D P.

Theorem addenv_unused_name :
 forall (G : env) (P : proc),
 typing G P ->
 forall (q : PP) (t : type), fresh q P -> typing (addenv G q t) P.

Theorem eqe_refl : forall G : env, eqvenv G G.

Theorem eqe_sym : forall G D : env, eqvenv G D -> eqvenv D G.

Theorem eqe_mask :
 forall (G : env) (p : PP) (t1 t2 : type),
 eqvenv (addenv (addenv G p t1) p t2) (addenv G p t2). *)

Require Import swaps_proofs.
(* swaps_proofs:
Require Import processus.
Require Import fresh.
Require Import typing_proofs.

Unset Standard Proposition Elimination Names.

Theorem swap_par_or_name :
 forall r p q : PP, pname (swap_par r p q) = swap_name (pname r) p q.

Theorem swap_is_subs_on_names :
 forall (n : name) (p q : PP),
 n <> pname p -> subs_par_name n (pname p) q = swap_name n p q.

Theorem swap_under_inp :
 forall (P : proc) (n : name) (p q : PP) (x : VV),
 swap_proc (inp n x P) p q = inp (swap_name n p q) x (swap_proc P p q).

Theorem swap_under_out :
 forall (P : proc) (n1 n2 : name) (p q : PP),
 swap_proc (out n1 n2 P) p q =
 out (swap_name n1 p q) (swap_name n2 p q) (swap_proc P p q).

Theorem swap_name_inefficient :
 forall (n : name) (p q : PP),
 n <> pname p -> n <> pname q -> swap_name n p q = n.

Theorem swap_proc_inefficient :
 forall (P : proc) (p q : PP), fresh p P -> fresh q P -> swap_proc P p q = P.

Theorem swap_under_subs_name :
 forall (n : name) (p q : PP) (m : name) (x : VV),
 swap_name (subs_var_name n m x) p q =
 subs_var_name (swap_name n p q) (swap_name m p q) x.

Theorem swap_under_subs :
 forall (P : proc) (p q : PP) (n : name) (x : VV),
 swap_proc (subs_var_proc P n x) p q =
 subs_var_proc (swap_proc P p q) (swap_name n p q) x.

Theorem swap_env_by_addenv :
 forall (G : env) (p q : PP),
 eqvenv (swap_env G p q) (addenv (addenv G p (G q)) q (G p)).

Theorem swap_on_gettype :
 forall (G : env) (r p q : PP), swap_env G p q r = G (swap_par r p q).

Theorem swap_par_twice : forall r p q : PP, swap_par (swap_par r p q) p q = r.

Theorem swap_on_addenv :
 forall (G : env) (r p q : PP) (t : type),
 eqvenv (swap_env (addenv G r t) p q)
   (addenv (swap_env G p q) (swap_par r p q) t).

Theorem fresh_after_swap_name :
 forall (n : name) (r p q : PP),
 freshname r (swap_name n p q) -> freshname (swap_par r p q) n.

Theorem fresh_after_swap :
 forall (P : proc) (r p q : PP),
 fresh r (swap_proc P p q) -> fresh (swap_par r p q) P.

Theorem swap_name_twice :
 forall (n : name) (p q : PP), swap_name (swap_name n p q) p q = n.

Theorem typing_after_swap :
 forall (G : env) (P : proc),
 typing G P -> forall p q : PP, typing (swap_env G p q) (swap_proc P p q). *)

Require Import fresh.
(* fresh:
Require Import processus.
Require Import induc.

Theorem freshname_is :
 forall (p : PP) (n : name), freshname p n -> n <> pname p.

Theorem freshvarname_is :
 forall (x : VV) (n : name), freshvarname x n -> n <> vname x.

Theorem fresh_after_subs_name :
 forall (p q : PP) (x : VV) (n : name),
 p <> q -> freshname p n -> freshname p (subs_var_name n (pname q) x).

Theorem fresh_after_subs :
 forall (p q : PP) (x : VV) (P : proc),
 p <> q -> fresh p P -> fresh p (subs_var_proc P (pname q) x).

Theorem fresh_after_subs_par_name :
 forall (p q r : PP) (n : name),
 r <> p -> freshname r n -> freshname r (subs_par_name n (pname p) q).

Theorem fresh_after_subs_par :
 forall (p q r : PP) (P : proc),
 r <> p -> fresh r P -> fresh r (subs_par_proc P (pname p) q).

Theorem fresh_after_subs_by_var_name :
 forall (n : name) (p q : PP) (x : VV),
 freshname p n -> freshname p (subs_par_name n (vname x) q).

Theorem fresh_after_subs_by_var :
 forall (P : proc) (p q : PP) (x : VV),
 fresh p P -> fresh p (subs_par_proc P (vname x) q).
 
Theorem fresh_before_subs_name :
 forall (p q : PP) (x : VV) (n : name),
 freshname p (subs_var_name n (pname q) x) -> freshname p n.

Theorem fresh_before_subs :
 forall (p q : PP) (x : VV) (P : proc),
 fresh p (subs_var_proc P (pname q) x) -> fresh p P.

Theorem out_known_name :
 forall (P P' : proc) (p q : PP), sem P (aout p q) P' -> ~ fresh q P.

Theorem inp_on_known_name :
 forall (P P' : proc) (p q : PP), sem P (ainp p q) P' -> ~ fresh p P.

Theorem fresh_masked_by_var_name :
 forall (n : name) (p : PP) (x : VV),
 freshname p (subs_par_name n (vname x) p).

Theorem fresh_masked_by_var :
 forall (P : proc) (p : PP) (x : VV), fresh p (subs_par_proc P (vname x) p).

Theorem fresh_after_trans :
 forall (P P' : proc) (mu : act),
 sem P mu P' -> forall q : PP, fresh q P -> freshact q mu -> fresh q P'.

Theorem fresh_mask_name :
 forall (n : name) (p q : PP),
 p <> q -> freshname q (subs_par_name n (pname p) q).

Theorem fresh_mask :
 forall (P : proc) (p q : PP),
 p <> q -> fresh q (subs_par_proc P (pname p) q). *)

Require Import substitutions.
(* substitutions:
Require Import processus.
Require Import fresh.

Theorem subs_fresh_par_name :
 forall (n m : name) (p : PP), n <> pname p -> subs_par_name n m p = n.

Theorem subs_fresh_par :
 forall (P : proc) (n : name) (p : PP), fresh p P -> subs_par_proc P n p = P.

Theorem subs_par_after_subs_var_name :
 forall (n : name) (p q : PP) (x : VV),
 n <> pname q ->
 subs_par_name (subs_var_name n (pname q) x) (pname p) q =
 subs_var_name n (pname p) x.

Theorem subs_par_after_subs_var :
 forall (P : proc) (p q : PP) (x : VV),
 fresh q P ->
 subs_par_proc (subs_var_proc P (pname q) x) (pname p) q =
 subs_var_proc P (pname p) x.

Theorem subs_var_after_subs_par_name :
 forall (n : name) (p q : PP) (x : VV),
 n <> vname x ->
 subs_var_name (subs_par_name n (vname x) p) (pname q) x =
 subs_par_name n (pname q) p.

Theorem subs_var_after_subs_par :
 forall (P : proc) (p q : PP) (x : VV),
 freshvar x P ->
 subs_var_proc (subs_par_proc P (vname x) p) (pname q) x =
 subs_par_proc P (pname q) p.

Theorem inefficient_subs_par_name :
 forall (n : name) (p : PP), subs_par_name n (pname p) p = n.

Theorem inefficient_subs_par :
 forall (P : proc) (p : PP), subs_par_proc P (pname p) p = P.

Theorem switch_subs_name :
 forall (n n1 n2 : name) (p : PP) (x : VV),
 pname p <> n1 ->
 vname x <> n2 ->
 subs_var_name (subs_par_name n n2 p) n1 x =
 subs_par_name (subs_var_name n n1 x) n2 p.

Theorem switch_subs :
 forall (P : proc) (n1 n2 : name) (p : PP) (x : VV),
 pname p <> n1 ->
 vname x <> n2 ->
 subs_var_proc (subs_par_proc P n2 p) n1 x =
 subs_par_proc (subs_var_proc P n1 x) n2 p. *)



Axiom

  typest_writing :

    forall t t' : type,

    typest t t' -> capst (getcap t') Write -> typest (getobj t') (getobj t).



Axiom

  typest_reading :

    forall t t' : type,

    typest t t' -> capst (getcap t') Read -> typest (getobj t) (getobj t').



Axiom

  typest_tail :

    forall t t' : type, typest t t' -> capst (getcap t) (getcap t').



Theorem subtyping_extension :

 forall (G D : env) (p : PP) (t1 t2 : type),

 envst D G -> typest t1 t2 -> envst (addenv D p t1) (addenv G p t2).

Proof.

intros G D p t1 t2 est tst.

unfold envst in |- *.

intro s.

case (PP_decidable p s).

intro same; rewrite same.

cut (addenv D s t1 s = t1).

intro foo; rewrite foo.

cut (addenv G s t2 s = t2).

intro bar; rewrite bar.

assumption.

apply gettype_added_name.

apply gettype_added_name.

intro not_same.

cut (addenv D p t1 s = D s).

intro foo; rewrite foo.

cut (addenv G p t2 s = G s).

intro bar; rewrite bar.

apply est.

apply gettype_not_added_name; assumption.

apply gettype_not_added_name; assumption.

Qed.



Theorem subtyping :

 forall (G : env) (P : proc),

 typing G P -> forall D : env, envst D G -> typing D P.

Proof.

intros Gamma Processus typed.

elim typed.

intros; apply tnil.

intros G p x P p_reads tail_correct hyprec D est.

apply tinp.

apply capst_trans with (c' := getcap (G p)).

apply typest_tail.

apply est.

assumption.

intros s fresh_s.

apply hyprec.

assumption.

apply subtyping_extension.

assumption.

apply typest_reading.

apply est.

assumption.

intros G p q P p_writes q_correct tail_typed hyprec D est.

apply tout.

apply capst_trans with (c' := getcap (G p)).

apply typest_tail.

apply est.

assumption.

apply typest_trans with (G q).

apply est.

apply typest_trans with (t' := getobj (G p)).

assumption.

apply typest_writing.

apply est.

assumption.

apply hyprec; assumption.

intros G P Q typed_P hyprecP typed_Q hyprecQ D est.

apply tpar.

apply hyprecP; assumption.

apply hyprecQ; assumption.

intros G x t P tail_typed hyprec D est.

apply tres.

intros s fresh_s.

apply hyprec.

assumption.

apply subtyping_extension.

assumption.

apply typest_refl.

intros G P tail_typed hyprec D est.

apply tban.

apply hyprec; assumption.

intros G P Q tP hyprecP tQ hyprecQ D est; apply tsum.

apply hyprecP; assumption.

apply hyprecQ; assumption.

intros G p q P p_both q_both tail_typed hyprec D est.

apply tmat.

transitivity (getcap (G p)).

cut (capst (getcap (D p)) (getcap (G p))).

intro cst.

rewrite p_both in cst.

inversion cst.

rewrite H1; symmetry  in |- *; assumption.

symmetry  in |- *; assumption.

apply typest_tail.

apply est.

assumption.

cut (capst (getcap (D q)) (getcap (G q))).

intro cst; rewrite q_both in cst; inversion cst.

reflexivity.

reflexivity.

apply typest_tail.

apply est.

apply hyprec; assumption.

Qed.



Theorem weaken_env :

 forall (G : env) (P : proc) (q : PP) (t : type),

 typest t (G q) -> typing G P -> typing (addenv G q t) P.

Proof.

intros G P q t tst typed.

apply subtyping with (G := G).

assumption.

unfold envst in |- *.

intro p.

case (PP_decidable q p).

intro same; rewrite same.

cut (addenv G p t p = t).

intro same2; rewrite same2.

rewrite <- same.

assumption.

apply gettype_added_name.

intro not_same; cut (addenv G q t p = G p).

intro foo; rewrite foo.

apply typest_refl.

apply gettype_not_added_name.

assumption.

Qed.



Theorem est_refl : forall G : env, envst G G.

Proof.

intro; unfold envst in |- *.

intro; apply typest_refl.

Qed.



Theorem type_with_other_subs :

 forall (G : env) (P : proc) (p q : PP) (x : VV) (t : type),

 fresh p P ->

 fresh q P ->

 typing (addenv G p t) (subs_var_proc P (pname p) x) ->

 typing (addenv G q t) (subs_var_proc P (pname q) x).

Proof.

intros G P p q.

case (PP_decidable p q).

intro trivial; rewrite trivial; intros; assumption.

intro not_trivial.

intros x t fresh_p fresh_q type_with_p.

apply

 redundant_addenv with (p := p) (t := G q) (G := swap_env (addenv G p t) q p).

cut

 (subs_var_proc P (pname q) x = swap_proc (subs_var_proc P (pname p) x) q p).

intro same; rewrite same.

apply typing_after_swap.

assumption.

symmetry  in |- *.

cut

 (subs_var_proc P (pname q) x =

  subs_var_proc (swap_proc P q p) (swap_name (pname p) q p) x).

intro same; rewrite same.

apply swap_under_subs.

cut (swap_proc P q p = P).

intro same; rewrite same.

cut (swap_name (pname p) q p = pname q).

intro same2; rewrite same2.

reflexivity.

simpl in |- *.

case (PP_decidable p p).

intro ok.

case (PP_decidable p q).

intro absurd; elim not_trivial; assumption.

intro ok2; reflexivity.

intro absurd; elim absurd; reflexivity.

apply swap_proc_inefficient.

assumption.

assumption.

apply fresh_after_subs.

assumption.

assumption.

apply

 eqv_trans

  with

    (G' := addenv (addenv (addenv G p t) q (addenv G p t p)) p

             (addenv G p t q)).

apply swap_env_by_addenv.

cut (addenv G p t p = t).

intro same; rewrite same.

cut (addenv G p t q = G q).

intro same2; rewrite same2.

apply eqv_trans with (G' := addenv (addenv (addenv G q t) p t) p (G q)).

apply eqv_addenv.

apply switch_addenv.

assumption.

apply eqe_mask.

apply gettype_not_added_name.

assumption.

apply gettype_added_name.

Qed.



Theorem subs_typing :

 forall (G : env) (P : proc),

 typing G P ->

 forall p q : PP,

 typest (G p) (G q) -> typing G (subs_par_proc P (pname p) q).

Proof.

intros Gamma Processus typed.

elim typed.

intros; simpl in |- *; apply tnil.



intros G r x P r_reads tail_correct hyprec p q tst.

cut

 (forall s : PP,

  fresh s (subs_par_proc P (pname p) q) ->

  typing (addenv G s (getobj (G r)))

    (subs_var_proc (subs_par_proc P (pname p) q) (pname s) x)).

intro tail_ok.

simpl in |- *.

case (PP_decidable q r).

intro same.

apply tinp.

apply capst_trans with (c' := getcap (G q)).

apply typest_tail; apply tst.

rewrite same; assumption.

intros s fresh_s_in_subs_tail.

apply subtyping with (G := addenv G s (getobj (G r))).

apply tail_ok.

assumption.

apply subtyping_extension.

apply est_refl.

apply typest_reading.

rewrite <- same; apply tst.

assumption.

intro not_same.

apply tinp.

assumption.

assumption.

intros s fresh_s_in_subs_tail.

cut (exists ss : PP, fresh ss P /\ p <> ss /\ q <> ss /\ s <> ss).

intro exists_ss; elim exists_ss.

intros ss ss_props; elim ss_props.

intros fresh_ss ss_props2; elim ss_props2.

intros p_not_ss ss_props3; elim ss_props3.

intros q_not_ss s_not_ss.

apply type_with_other_subs with (p := ss).

apply fresh_after_subs_par.

red in |- *; intro; elim p_not_ss.

symmetry  in |- *; assumption.

assumption.

assumption.

cut

 (subs_var_proc (subs_par_proc P (pname p) q) (pname ss) x =

  subs_par_proc (subs_var_proc P (pname ss) x) (pname p) q).

intro same; rewrite same.

apply hyprec.

assumption.

cut (addenv G ss (getobj (G r)) p = G p).

intro foo; rewrite foo.

cut (addenv G ss (getobj (G r)) q = G q).

intro bar; rewrite bar.

assumption.

apply gettype_not_added_name.

red in |- *; intro; elim q_not_ss; symmetry  in |- *; assumption.

apply gettype_not_added_name.

red in |- *; intro; elim p_not_ss; symmetry  in |- *; assumption.

apply switch_subs.

red in |- *; intro absurd; injection absurd.

intro; elim q_not_ss; assumption.

red in |- *; intro absurd; discriminate absurd.

apply fresh_and_three_different.



intros G can obj P can_writes obj_correct tail_typed hyprec p q tst.

cut (typing G (subs_par_proc P (pname p) q)).

intro tail_ok.

simpl in |- *.

case (PP_decidable q can); case (PP_decidable q obj).

intros q_is_obj q_is_can.

apply tout.

apply capst_trans with (getcap (G q)).

apply typest_tail; assumption.

rewrite q_is_can; assumption.

apply typest_trans with (G q).

assumption.

apply typest_trans with (t' := getobj (G q)).

rewrite <- q_is_obj in obj_correct; rewrite <- q_is_can in obj_correct.

assumption.

apply typest_writing.

assumption.

rewrite q_is_can; assumption.

assumption.

intros q_not_obj q_is_can.

apply tout.

apply capst_trans with (c' := getcap (G q)).

apply typest_tail.

assumption.

rewrite q_is_can; assumption.

apply typest_trans with (t' := getobj (G q)).

rewrite q_is_can; assumption.

apply typest_writing.

assumption.

rewrite q_is_can; assumption.

assumption.

intros q_is_obj q_not_can; apply tout.

assumption.

apply typest_trans with (t' := G q).

assumption.

rewrite q_is_obj; assumption.

assumption.

intros q_not_obj q_not_can.

apply tout. assumption.

assumption.

assumption.

apply hyprec; assumption.



intros G P Q tP hyprecP tQ hyprecQ p q tst.

simpl in |- *.

apply tpar.

apply hyprecP; assumption.

apply hyprecQ; assumption.



intros G x t P tail_typed hyprec p q tst.

simpl in |- *.

apply tres.

intros r fresh_r.

cut (exists s : PP, fresh s P /\ p <> s /\ q <> s /\ r <> s).

intro exists_; elim exists_.

intros s s_props; elim s_props.

intros fresh_s s_props2; elim s_props2.

intros p_not_s s_props3; elim s_props3.

intros q_not_s r_not_s.

apply type_with_other_subs with (p := s).

apply fresh_after_subs_par.

red in |- *; intro; elim p_not_s; symmetry  in |- *; assumption.

assumption.

assumption.

cut

 (subs_var_proc (subs_par_proc P (pname p) q) (pname s) x =

  subs_par_proc (subs_var_proc P (pname s) x) (pname p) q).

intro same; rewrite same.

apply hyprec.

assumption.

cut (addenv G s t p = G p).

intro sameagain; rewrite sameagain.

cut (addenv G s t q = G q).

intro sameagain2; rewrite sameagain2.

assumption.

apply gettype_not_added_name.

red in |- *; intro; elim q_not_s; symmetry  in |- *; assumption.

apply gettype_not_added_name.

red in |- *; intro; elim p_not_s; symmetry  in |- *; assumption.

apply switch_subs.

red in |- *; intro absurd; injection absurd.

intro; elim q_not_s; assumption.

red in |- *; intro absurd; discriminate absurd.

apply fresh_and_three_different.



intros G P tP hyprec p q tst.

simpl in |- *.

apply tban.

apply hyprec; assumption.



intros G P Q tP hyprecP tQ hyprecQ p q tst.

simpl in |- *.

apply tsum.

apply hyprecP; assumption.

apply hyprecQ; assumption.



intros G a b P a_both b_both tail_typed hyprec p q tst.

simpl in |- *.

case (PP_decidable q a); case (PP_decidable q b).

intros q_is_b q_is_a.

cut (getcap (G p) = Both).

intro same.

apply tmat.

assumption.

assumption.

apply hyprec; assumption.

cut (capst (getcap (G p)) (getcap (G q))).

intro cst.

rewrite q_is_a in cst.

rewrite a_both in cst.

inversion cst.

reflexivity.

reflexivity.

apply typest_tail.

assumption.

intros q_not_b q_a.

apply tmat.

cut (capst (getcap (G p)) (getcap (G q))).

intro cst.

rewrite q_a in cst; rewrite a_both in cst.

inversion cst.

reflexivity.

reflexivity.

apply typest_tail; assumption.

assumption.

apply hyprec; assumption.

intros q_is_b q_not_a.

apply tmat.

assumption.

cut (capst (getcap (G p)) (getcap (G q))).

intro cst; rewrite q_is_b in cst; rewrite b_both in cst.

inversion cst; reflexivity.

apply typest_tail; assumption.

apply hyprec; assumption.

intros q_not_b q_not_a; apply tmat.

assumption.

assumption.

apply hyprec; assumption.

Qed.
