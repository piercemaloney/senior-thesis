Require Import Ensembles.

Require Import Coq.Lists.List.

Require Import ListExt.
(* ListExt:
Require Import Coq.Lists.List.

Section List_Remove.

Variable A : Set.
Hypothesis Aeq_dec : forall a b : A, {a = b} + {a <> b}.

Definition list_remove (x : A) (l : list A) : list A :=
  list_rec (fun _ => list A) nil
    (fun (a : A) _ (recl : list A) =>
     match Aeq_dec a x with
     | left _ => recl
     | right _ => a :: recl
     end) l.

Lemma In_list_remove1 :
 forall (a b : A) (l : list A), In a (list_remove b l) -> In a l.

Lemma In_list_remove2 :
 forall (a b : A) (l : list A), In a (list_remove b l) -> a <> b.

Lemma In_list_remove3 :
 forall (a b : A) (l : list A), In a l -> a <> b -> In a (list_remove b l).

End List_Remove.

Section No_Duplicate.

Variable A : Set.
Hypothesis Aeq_dec : forall a b : A, {a = b} + {a <> b}.

Definition no_dup (l : list A) : list A :=
  list_rec (fun _ => list A) nil
    (fun (a : A) _ (rec : list A) =>
     match In_dec Aeq_dec a rec with
     | left _ => rec
     | right _ => a :: rec
     end) l.

Lemma no_dup1 : forall (a : A) (l : list A), In a l -> In a (no_dup l).

Lemma no_dup2 : forall (a : A) (l : list A), In a (no_dup l) -> In a l.

Lemma no_dup3 : forall (k l : list A) (a : A), no_dup k = a :: l -> ~ In a l.

End No_Duplicate. *)



Require Import folProp.
(* folProp:
Require Import Wf_nat.
Require Import Max.
Require Import Arith.
Require Import Coq.Lists.List.
Require Import ListExt.
Require Import Peano_dec.

Require Export fol.

Section Fol_Properties.

Variable L : Language.

Notation Formula := (Formula L) (only parsing).
Notation Formulas := (Formulas L) (only parsing).
Notation System := (System L) (only parsing).
Notation Term := (Term L) (only parsing).
Notation Terms := (Terms L) (only parsing).
Let var := var L.
Let apply := apply L.
Let equal := equal L.
Let atomic := atomic L.
Let impH := impH L.
Let notH := notH L.
Let forallH := forallH L.
Let lt_depth := lt_depth L.

Section Free_Variables.

Fixpoint freeVarTerm (s : fol.Term L) : list nat :=
  match s with
  | fol.var v => v :: nil
  | fol.apply f ts => freeVarTerms (arity L (inr _ f)) ts
  end
 
 with freeVarTerms (n : nat) (ss : fol.Terms L n) {struct ss} : 
 list nat :=
  match ss with
  | Tnil => nil (A:=nat)
  | Tcons m t ts => freeVarTerm t ++ freeVarTerms m ts
  end.

Lemma freeVarTermApply :
 forall (f : Functions L) (ts : fol.Terms L _),

Fixpoint freeVarFormula (A : fol.Formula L) : list nat :=
  match A with
  | fol.equal t s => freeVarTerm t ++ freeVarTerm s
  | fol.atomic r ts => freeVarTerms _ ts
  | fol.impH A B => freeVarFormula A ++ freeVarFormula B
  | fol.notH A => freeVarFormula A
  | fol.forallH v A => list_remove _ eq_nat_dec v (freeVarFormula A)
  end.

Definition ClosedSystem (T : fol.System L) :=
  forall (v : nat) (f : fol.Formula L),
  mem _ T f -> ~ In v (freeVarFormula f).

Definition closeList (l : list nat) (x : fol.Formula L) : 
  fol.Formula L :=
  list_rec (fun _ => fol.Formula L) x
    (fun (a : nat) _ (rec : fol.Formula L) => forallH a rec) l.

Definition close (x : fol.Formula L) : fol.Formula L :=
  closeList (no_dup _ eq_nat_dec (freeVarFormula x)) x.

Lemma freeVarClosedList1 :
 forall (l : list nat) (v : nat) (x : fol.Formula L),

Lemma freeVarClosedList2 :
 forall (l : list nat) (v : nat) (x : fol.Formula L),

Lemma freeVarClosed :
 forall (x : fol.Formula L) (v : nat), ~ In v (freeVarFormula (close x)).

Fixpoint freeVarListFormula (l : fol.Formulas L) : 
 list nat :=
  match l with
  | nil => nil (A:=nat)
  | f :: l => freeVarFormula f ++ freeVarListFormula l
  end.

Lemma freeVarListFormulaApp :
 forall a b : fol.Formulas L,

Lemma In_freeVarListFormula :
 forall (v : nat) (f : fol.Formula L) (F : fol.Formulas L),

Lemma In_freeVarListFormulaE :
 forall (v : nat) (F : fol.Formulas L),

Definition In_freeVarSys (v : nat) (T : fol.System L) :=
  exists f : fol.Formula L, In v (freeVarFormula f) /\ mem _ T f.

Lemma notInFreeVarSys :
 forall x, ~ In_freeVarSys x (Ensembles.Empty_set (fol.Formula L)).

End Free_Variables.

Section Substitution.

Fixpoint substituteTerm (s : fol.Term L) (x : nat) 
 (t : fol.Term L) {struct s} : fol.Term L :=
  match s with
  | fol.var v =>
      match eq_nat_dec x v with
      | left _ => t
      | right _ => var v
      end
  | fol.apply f ts => apply f (substituteTerms _ ts x t)
  end
 
 with substituteTerms (n : nat) (ss : fol.Terms L n) 
 (x : nat) (t : fol.Term L) {struct ss} : fol.Terms L n :=
  match ss in (fol.Terms _ n0) return (fol.Terms L n0) with
  | Tnil => Tnil L
  | Tcons m s ts =>
      Tcons L m (substituteTerm s x t) (substituteTerms m ts x t)
  end.

Lemma subTermVar1 :
 forall (v : nat) (s : fol.Term L), substituteTerm (var v) v s = s.

Lemma subTermVar2 :
 forall (v x : nat) (s : fol.Term L),

Lemma subTermFunction :
 forall (f : Functions L) (ts : fol.Terms L (arity L (inr _ f))) 

Definition newVar (l : list nat) : nat := fold_right max 0 (map S l).

Lemma newVar2 : forall (l : list nat) (n : nat), In n l -> n < newVar l.

Lemma newVar1 : forall l : list nat, ~ In (newVar l) l.

Definition substituteFormulaImp (f : fol.Formula L)
  (frec : nat * fol.Term L -> {y : fol.Formula L | depth L y = depth L f})
  (g : fol.Formula L)
  (grec : nat * fol.Term L -> {y : fol.Formula L | depth L y = depth L g})
  (p : nat * fol.Term L) :
  {y : fol.Formula L | depth L y = depth L (impH f g)} :=
  match frec p with
  | exist f' prf1 =>
      match grec p with
      | exist g' prf2 =>
          exist
            (fun y : fol.Formula L =>
             depth L y = S (max (depth L f) (depth L g))) 
            (impH f' g')
            (eq_ind_r
               (fun n : nat =>
                S (max n (depth L g')) = S (max (depth L f) (depth L g)))
               (eq_ind_r
                  (fun n : nat =>
                   S (max (depth L f) n) = S (max (depth L f) (depth L g)))
                  (refl_equal (S (max (depth L f) (depth L g)))) prf2) prf1)
      end
  end.

Remark substituteFormulaImpNice :
 forall (f g : fol.Formula L)

Definition substituteFormulaNot (f : fol.Formula L)
  (frec : nat * fol.Term L -> {y : fol.Formula L | depth L y = depth L f})
  (p : nat * fol.Term L) :
  {y : fol.Formula L | depth L y = depth L (notH f)} :=
  match frec p with
  | exist f' prf1 =>
      exist (fun y : fol.Formula L => depth L y = S (depth L f)) 
        (notH f')
        (eq_ind_r (fun n : nat => S n = S (depth L f))
           (refl_equal (S (depth L f))) prf1)
  end.

Remark substituteFormulaNotNice :
 forall (f : fol.Formula L)

Definition substituteFormulaForall (n : nat) (f : fol.Formula L)
  (frec : forall b : fol.Formula L,
          lt_depth b (forallH n f) ->
          nat * fol.Term L -> {y : fol.Formula L | depth L y = depth L b})
  (p : nat * fol.Term L) :
  {y : fol.Formula L | depth L y = depth L (forallH n f)} :=
  match p with
  | (v, s) =>
      match eq_nat_dec n v with
      | left _ =>
          exist (fun y : fol.Formula L => depth L y = S (depth L f))
            (forallH n f) (refl_equal (depth L (forallH n f)))
      | right _ =>
          match In_dec eq_nat_dec n (freeVarTerm s) with
          | left _ =>
              let nv := newVar (v :: freeVarTerm s ++ freeVarFormula f) in
              match frec f (depthForall L f n) (n, var nv) with
              | exist f' prf1 =>
                  match
                    frec f'
                      (eqDepth L f' f (forallH n f) 
                         (sym_eq prf1) (depthForall L f n)) p
                  with
                  | exist f'' prf2 =>
                      exist
                        (fun y : fol.Formula L => depth L y = S (depth L f))
                        (forallH nv f'')
                        (eq_ind_r (fun n : nat => S n = S (depth L f))
                           (refl_equal (S (depth L f))) 
                           (trans_eq prf2 prf1))
                  end
              end
          | right _ =>
              match frec f (depthForall L f n) p with
              | exist f' prf1 =>
                  exist (fun y : fol.Formula L => depth L y = S (depth L f))
                    (forallH n f')
                    (eq_ind_r (fun n : nat => S n = S (depth L f))
                       (refl_equal (S (depth L f))) prf1)
              end
          end
      end
  end.

Remark substituteFormulaForallNice :
 forall (v : nat) (a : fol.Formula L)

Definition substituteFormulaHelp (f : fol.Formula L) 

Definition substituteFormula (f : fol.Formula L) (v : nat) 
  (s : fol.Term L) : fol.Formula L := proj1_sig (substituteFormulaHelp f v s).

Lemma subFormulaEqual :
 forall (t1 t2 : fol.Term L) (v : nat) (s : fol.Term L),

Lemma subFormulaRelation :
 forall (r : Relations L) (ts : fol.Terms L (arity L (inl _ r))) 

Lemma subFormulaImp :
 forall (f1 f2 : fol.Formula L) (v : nat) (s : fol.Term L),

Lemma subFormulaNot :
 forall (f : fol.Formula L) (v : nat) (s : fol.Term L),

Lemma subFormulaForall :
 forall (f : fol.Formula L) (x v : nat) (s : fol.Term L),

Section Extensions.

Let orH := orH L.
Let andH := andH L.
Let existH := existH L.
Let iffH := iffH L.
Let ifThenElseH := ifThenElseH L.

Lemma subFormulaOr :
 forall (f1 f2 : fol.Formula L) (v : nat) (s : fol.Term L),

Lemma subFormulaAnd :
 forall (f1 f2 : fol.Formula L) (v : nat) (s : fol.Term L),

Lemma subFormulaExist :
 forall (f : fol.Formula L) (x v : nat) (s : fol.Term L),

Lemma subFormulaIff :
 forall (f1 f2 : fol.Formula L) (v : nat) (s : fol.Term L),

Lemma subFormulaIfThenElse :
 forall (f1 f2 f3 : fol.Formula L) (v : nat) (s : fol.Term L),

End Extensions.

Lemma subFormulaDepth :
 forall (f : fol.Formula L) (v : nat) (s : fol.Term L),

Section Substitution_Properties.

Lemma subTermId :
 forall (t : fol.Term L) (v : nat), substituteTerm t v (var v) = t.

Lemma subTermsId :
 forall (n : nat) (ts : fol.Terms L n) (v : nat),

Lemma subFormulaId :
 forall (f : fol.Formula L) (v : nat), substituteFormula f v (var v) = f.

Lemma subFormulaForall2 :
 forall (f : fol.Formula L) (x v : nat) (s : fol.Term L),

Let existH := existH L.

Lemma subFormulaExist2 :
 forall (f : fol.Formula L) (x v : nat) (s : fol.Term L),

End Substitution_Properties.

End Substitution.
 
Definition Sentence (f:Formula) := (forall v : nat, ~ In v (freeVarFormula f)).

End Fol_Properties. *)

Require Import folProof.
(* folProof:
Require Import Ensembles.
Require Import Coq.Lists.List.
Require Import Arith.

Require Export fol.
Require Import folProp.

Section ProofH.

Variable L : Language.

Let Formula := Formula L.
Let Formulas := Formulas L.
Let System := System L.
Let Term := Term L.
Let Terms := Terms L.
Let var := var L.
Let apply := apply L.
Let equal := equal L.
Let atomic := atomic L.
Let impH := impH L.
Let notH := notH L.
Let iffH := iffH L.
Let forallH := forallH L.

Definition nVars (n : nat) : Terms n * Terms n.

Definition AxmEq4 (R : Relations L) : Formula.

Definition AxmEq5 (f : Functions L) : Formula.

Inductive Prf : Formulas -> Formula -> Set :=
  | AXM : forall A : Formula, Prf (A :: nil) A
  | MP :
      forall (Axm1 Axm2 : Formulas) (A B : Formula),
      Prf Axm1 (impH A B) -> Prf Axm2 A -> Prf (Axm1 ++ Axm2) B
  | GEN :
      forall (Axm : Formulas) (A : Formula) (v : nat),
      ~ In v (freeVarListFormula L Axm) -> Prf Axm A -> Prf Axm (forallH v A)
  | IMP1 : forall A B : Formula, Prf nil (impH A (impH B A))
  | IMP2 :
      forall A B C : Formula,
      Prf nil (impH (impH A (impH B C)) (impH (impH A B) (impH A C)))
  | CP :
      forall A B : Formula,
      Prf nil (impH (impH (notH A) (notH B)) (impH B A))
  | FA1 :
      forall (A : Formula) (v : nat) (t : Term),
      Prf nil (impH (forallH v A) (substituteFormula L A v t))
  | FA2 :
      forall (A : Formula) (v : nat),
      ~ In v (freeVarFormula L A) -> Prf nil (impH A (forallH v A))
  | FA3 :
      forall (A B : Formula) (v : nat),
      Prf nil
        (impH (forallH v (impH A B)) (impH (forallH v A) (forallH v B)))
  | EQ1 : Prf nil (equal (var 0) (var 0))
  | EQ2 : Prf nil (impH (equal (var 0) (var 1)) (equal (var 1) (var 0)))
  | EQ3 :
      Prf nil
        (impH (equal (var 0) (var 1))
           (impH (equal (var 1) (var 2)) (equal (var 0) (var 2))))
  | EQ4 : forall R : Relations L, Prf nil (AxmEq4 R)
  | EQ5 : forall f : Functions L, Prf nil (AxmEq5 f).

Definition SysPrf (T : System) (f : Formula) :=
  exists Axm : Formulas,
    (exists prf : Prf Axm f,
       (forall g : Formula, In g Axm -> mem _ T g)).

Definition Inconsistent (T : System) := forall f : Formula, SysPrf T f.

Definition Consistent (T : System) := exists f : Formula, ~ SysPrf T f.

End ProofH. *)

Require Export folLogic2.

Require Import subProp.
(* subProp:
Require Import Ensembles.
Require Import Coq.Lists.List.
Require Import Peano_dec.
Require Import ListExt.
Require Import Arith.

Require Import folProof.
Require Import folLogic.
Require Import folProp.
Require Import folReplace.

Section Substitution_Properties.

Variable L : Language.
Let Formula := Formula L.
Let Formulas := Formulas L.
Let System := System L.
Let Term := Term L.
Let Terms := Terms L.
Let var := var L.
Let apply := apply L.
Let equal := equal L.
Let atomic := atomic L.
Let impH := impH L.
Let notH := notH L.
Let forallH := forallH L.
Let orH := orH L.
Let andH := andH L.
Let existH := existH L.
Let iffH := iffH L.
Let SysPrf := SysPrf L.

Lemma freeVarSubTerm1 :
 forall (t : Term) (v : nat) (s : Term) (x : nat),
 In x (freeVarTerm L t) ->
 v <> x -> In x (freeVarTerm L (substituteTerm L t v s)).

Lemma freeVarSubTerms1 :
 forall (n : nat) (ts : Terms n) (v : nat) (s : Term) (x : nat),
 In x (freeVarTerms L n ts) ->
 v <> x -> In x (freeVarTerms L n (substituteTerms L n ts v s)).

Lemma freeVarSubFormula1 :
 forall (f : Formula) (v : nat) (s : Term) (x : nat),
 v <> x ->
 In x (freeVarFormula L f) ->
 In x (freeVarFormula L (substituteFormula L f v s)).

Lemma freeVarSubTerm2 :
 forall (t : Term) (v : nat) (s : Term) (x : nat),
 In x (freeVarTerm L s) ->
 In v (freeVarTerm L t) -> In x (freeVarTerm L (substituteTerm L t v s)).

Lemma freeVarSubTerms2 :
 forall (n : nat) (ts : Terms n) (v : nat) (s : Term) (x : nat),
 In x (freeVarTerm L s) ->
 In v (freeVarTerms L n ts) ->
 In x (freeVarTerms L n (substituteTerms L n ts v s)).

Lemma freeVarSubFormula2 :
 forall (f : Formula) (v : nat) (s : Term) (x : nat),
 In x (freeVarTerm L s) ->
 In v (freeVarFormula L f) ->
 In x (freeVarFormula L (substituteFormula L f v s)).

Lemma freeVarSubTerm3 :
 forall (t : Term) (v : nat) (s : Term) (x : nat),
 In x (freeVarTerm L (substituteTerm L t v s)) ->
 In x (list_remove _ eq_nat_dec v (freeVarTerm L t)) \/
 In x (freeVarTerm L s).

Lemma freeVarSubTerms3 :
 forall (n : nat) (ts : fol.Terms L n) (v : nat) (s : Term) (x : nat),

Lemma freeVarSubFormula3 :
 forall (f : Formula) (v : nat) (s : Term) (x : nat),
 In x (freeVarFormula L (substituteFormula L f v s)) ->
 In x (list_remove _ eq_nat_dec v (freeVarFormula L f)) \/
 In x (freeVarTerm L s).

Lemma freeVarSubTerm4 :
 forall (t : Term) (v : nat) (s : Term) (x : nat),
 In x (freeVarTerm L (substituteTerm L t v s)) ->
 ~ In v (freeVarTerm L t) -> In x (freeVarTerm L t).

Lemma freeVarSubTerms4 :
 forall (n : nat) (ts : Terms n) (v : nat) (s : Term) (x : nat),
 In x (freeVarTerms L n (substituteTerms L n ts v s)) ->
 ~ In v (freeVarTerms L n ts) -> In x (freeVarTerms L n ts).

Lemma freeVarSubFormula4 :
 forall (f : Formula) (v : nat) (s : Term) (x : nat),
 In x (freeVarFormula L (substituteFormula L f v s)) ->
 ~ In v (freeVarFormula L f) -> In x (freeVarFormula L f).

Lemma subTermNil :
 forall (t : Term) (v : nat) (s : Term),
 ~ In v (freeVarTerm L t) -> substituteTerm L t v s = t.

Lemma subTermTrans :
 forall (t : Term) (v1 v2 : nat) (s : Term),
 ~ In v2 (list_remove _ eq_nat_dec v1 (freeVarTerm L t)) ->
 substituteTerm L (substituteTerm L t v1 (var v2)) v2 s =
 substituteTerm L t v1 s.

Lemma subTermExch :
 forall (t : Term) (v1 v2 : nat) (s1 s2 : Term),
 v1 <> v2 ->
 ~ In v2 (freeVarTerm L s1) ->
 ~ In v1 (freeVarTerm L s2) ->
 substituteTerm L (substituteTerm L t v1 s1) v2 s2 =
 substituteTerm L (substituteTerm L t v2 s2) v1 s1.

Lemma subTermsNil :
 forall (n : nat) (ts : Terms n) (v : nat) (s : Term),
 ~ In v (freeVarTerms L n ts) -> substituteTerms L n ts v s = ts.

Lemma subTermsTrans :
 forall (n : nat) (ts : Terms n) (v1 v2 : nat) (s : Term),
 ~ In v2 (list_remove _ eq_nat_dec v1 (freeVarTerms L n ts)) ->
 substituteTerms L n (substituteTerms L n ts v1 (var v2)) v2 s =
 substituteTerms L n ts v1 s.

Lemma subTermsExch :
 forall (n : nat) (ts : Terms n) (v1 v2 : nat) (s1 s2 : Term),
 v1 <> v2 ->
 ~ In v2 (freeVarTerm L s1) ->
 ~ In v1 (freeVarTerm L s2) ->
 substituteTerms L n (substituteTerms L n ts v1 s1) v2 s2 =
 substituteTerms L n (substituteTerms L n ts v2 s2) v1 s1.

Remark subFormulaNTEHelp :
 forall (f g : Formula) (v : nat) (s : Term),
 SysPrf (Ensembles.Add _ (Empty_set Formula) f) g ->

Remark subFormulaNTE :
 forall (f : Formula) (T : System),
 (forall (v : nat) (s : Term),
  ~ In v (freeVarFormula L f) ->
  SysPrf T (iffH (substituteFormula L f v s) f)) /\
 (forall (v1 v2 : nat) (s : Term),
  ~ In v2 (list_remove _ eq_nat_dec v1 (freeVarFormula L f)) ->
  SysPrf T
    (iffH (substituteFormula L (substituteFormula L f v1 (var v2)) v2 s)
       (substituteFormula L f v1 s))) /\
 (forall (v1 v2 : nat) (s1 s2 : Term),
  v1 <> v2 ->
  ~ In v2 (freeVarTerm L s1) ->
  ~ In v1 (freeVarTerm L s2) ->
  SysPrf T
    (iffH (substituteFormula L (substituteFormula L f v1 s1) v2 s2)
       (substituteFormula L (substituteFormula L f v2 s2) v1 s1))).

Lemma subFormulaNil :
 forall (f : Formula) (T : System) (v : nat) (s : Term),
 ~ In v (freeVarFormula L f) -> SysPrf T (iffH (substituteFormula L f v s) f).

Lemma subFormulaTrans :
 forall (f : Formula) (T : System) (v1 v2 : nat) (s : Term),
 ~ In v2 (list_remove _ eq_nat_dec v1 (freeVarFormula L f)) ->
 SysPrf T
   (iffH (substituteFormula L (substituteFormula L f v1 (var v2)) v2 s)
      (substituteFormula L f v1 s)).

Lemma subFormulaExch :
 forall (f : Formula) (T : System) (v1 v2 : nat) (s1 s2 : Term),
 v1 <> v2 ->
 ~ In v2 (freeVarTerm L s1) ->
 ~ In v1 (freeVarTerm L s2) ->
 SysPrf T
   (iffH (substituteFormula L (substituteFormula L f v1 s1) v2 s2)
      (substituteFormula L (substituteFormula L f v2 s2) v1 s1)).

End Substitution_Properties. *)

Require Import folReplace.
(* folReplace:
Require Import Ensembles.
Require Import Coq.Lists.List.
Require Import Peano_dec.

Require Import ListExt.
Require Import folProof.
Require Import folLogic.
Require Import folProp.

Section Replacement.

Variable L : Language.
Let Formula := Formula L.
Let Formulas := Formulas L.
Let System := System L.
Let Term := Term L.
Let Terms := Terms L.
Let var := var L.
Let apply := apply L.
Let equal := equal L.
Let atomic := atomic L.
Let impH := impH L.
Let notH := notH L.
Let forallH := forallH L.
Let orH := orH L.
Let andH := andH L.
Let existH := existH L.
Let iffH := iffH L.
Let ifThenElseH := ifThenElseH L.
Let SysPrf := SysPrf L.

Lemma reduceImp :
 forall (f1 f2 f3 f4 : Formula) (T : System),
 SysPrf T (iffH f1 f3) ->
 SysPrf T (iffH f2 f4) -> SysPrf T (iffH (impH f1 f2) (impH f3 f4)).

Lemma reduceNot :
 forall (f1 f2 : Formula) (T : System),
 SysPrf T (iffH f1 f2) -> SysPrf T (iffH (notH f1) (notH f2)).

Lemma impForall :
 forall (f1 f2 : Formula) (v : nat) (T : System),
 ~ In_freeVarSys _ v T ->
 SysPrf T (impH f1 f2) -> SysPrf T (impH (forallH v f1) (forallH v f2)).

Lemma reduceForall :
 forall (f1 f2 : Formula) (v : nat) (T : System),
 ~ In_freeVarSys _ v T ->
 SysPrf T (iffH f1 f2) -> SysPrf T (iffH (forallH v f1) (forallH v f2)).

Lemma reduceOr :
 forall (f1 f2 f3 f4 : Formula) (T : System),
 SysPrf T (iffH f1 f3) ->
 SysPrf T (iffH f2 f4) -> SysPrf T (iffH (orH f1 f2) (orH f3 f4)).

Lemma reduceAnd :
 forall (f1 f2 f3 f4 : Formula) (T : System),
 SysPrf T (iffH f1 f3) ->
 SysPrf T (iffH f2 f4) -> SysPrf T (iffH (andH f1 f2) (andH f3 f4)).

Lemma iffExist :
 forall (f1 f2 : Formula) (v : nat) (T : System),
 ~ In_freeVarSys _ v T ->
 SysPrf T (impH f1 f2) -> SysPrf T (impH (existH v f1) (existH v f2)).

Lemma reduceExist :
 forall (f1 f2 : Formula) (v : nat) (T : System),
 ~ In_freeVarSys _ v T ->
 SysPrf T (iffH f1 f2) -> SysPrf T (iffH (existH v f1) (existH v f2)).

Lemma reduceIff :
 forall (f1 f2 f3 f4 : Formula) (T : System),
 SysPrf T (iffH f1 f3) ->
 SysPrf T (iffH f2 f4) -> SysPrf T (iffH (iffH f1 f2) (iffH f3 f4)).

Lemma reduceIfThenElse :
 forall (f1 f2 f3 f4 f5 f6 : Formula) (T : System),
 SysPrf T (iffH f1 f4) ->
 SysPrf T (iffH f2 f5) ->
 SysPrf T (iffH f3 f6) ->
 SysPrf T (iffH (ifThenElseH f1 f2 f3) (ifThenElseH f4 f5 f6)).

Lemma reduceSub :
 forall (T : System) (v : nat) (s : Term) (f g : Formula),
 ~ In_freeVarSys L v T ->
 SysPrf T (iffH f g) ->
 SysPrf T (iffH (substituteFormula L f v s) (substituteFormula L g v s)).

Lemma reduceCloseList :
 forall (l : list nat) (f1 f2 : Formula) (T : System),
 (forall v : nat, In v l -> ~ In_freeVarSys _ v T) ->
 SysPrf T (iffH f1 f2) ->
 SysPrf T (iffH (closeList L l f1) (closeList L l f2)).

End Replacement. *)

Require Import Arith.

Require Import subAll.
(* subAll:
Require Import Ensembles.
Require Import Coq.Lists.List.
Require Import Arith.
Require Import Peano_dec.
Require Import ListExt.
Require Import Max.

Require Import folProof.
Require Import folLogic2.
Require Import folProp.
Require Import folReplace.
Require Import subProp.

Section SubAllVars.

Variable L : Language.
Notation Formula := (Formula L) (only parsing).
Notation Formulas := (Formulas L) (only parsing).
Notation System := (System L) (only parsing).
Notation Term := (Term L) (only parsing).
Notation Terms := (Terms L) (only parsing).
Notation var := (var L) (only parsing).
Notation apply := (apply L) (only parsing).
Notation equal := (equal L) (only parsing).
Notation atomic := (atomic L) (only parsing).
Notation impH := (impH L) (only parsing).
Notation notH := (notH L) (only parsing).
Notation forallH := (forallH L) (only parsing).
Notation iffH := (iffH L) (only parsing).
Notation SysPrf := (SysPrf L) (only parsing).

Fixpoint subAllTerm (t : fol.Term L) : (nat -> fol.Term L) -> fol.Term L :=
  match t return ((nat -> fol.Term L) -> fol.Term L) with
  | fol.var x => fun m => m x
  | fol.apply f ts => fun m => fol.apply L f (subAllTerms _ ts m)
  end
 
 with subAllTerms (n : nat) (ts : fol.Terms L n) {struct ts} :
 (nat -> fol.Term L) -> fol.Terms L n :=
  match
    ts in (fol.Terms _ n) return ((nat -> fol.Term L) -> fol.Terms L n)
  with
  | Tnil => fun _ => Tnil L
  | Tcons n' t ss =>
      fun m => Tcons L n' (subAllTerm t m) (subAllTerms _ ss m)
  end.

Lemma subAllTerm_ext :
 forall (t : fol.Term L) (m1 m2 : nat -> fol.Term L),

Lemma subAllTerms_ext :
 forall (n : nat) (ts : fol.Terms L n) (m1 m2 : nat -> fol.Term L),

Fixpoint freeVarMap (l : list nat) : (nat -> fol.Term L) -> list nat :=
  match l with
  | nil => fun _ => nil
  | a :: l' => fun m => freeVarTerm L (m a) ++ freeVarMap l' m
  end.

Lemma freeVarMap_ext :
 forall (l : list nat) (f1 f2 : nat -> fol.Term L),

Lemma freeVarMap1 :
 forall (l : list nat) (m : nat -> fol.Term L) (v n : nat),

Fixpoint subAllFormula (f : Formula) (m : (nat -> Term)) {struct f} : Formula :=
  match f with
  | fol.equal t s => equal (subAllTerm t m) (subAllTerm s m)
  | fol.atomic r ts => atomic r (subAllTerms _ ts m)
  | fol.impH f g =>
      impH (subAllFormula f m) (subAllFormula g m)
  | fol.notH f => notH (subAllFormula f m)
  | fol.forallH n f =>
      let nv :=
        newVar
          (freeVarFormula L f ++
           freeVarMap (freeVarFormula L (forallH n f)) m) in
      forallH nv
        (subAllFormula f
           (fun v : nat =>
            match eq_nat_dec v n with
            | left _ => var nv
            | right _ => m v
            end))
  end.

Lemma subAllFormula_ext :
 forall (f : fol.Formula L) (m1 m2 : nat -> fol.Term L),

Lemma freeVarSubAllTerm1 :
 forall (t : fol.Term L) (m : nat -> fol.Term L) (v : nat),

Lemma freeVarSubAllTerms1 :
 forall (n : nat) (ts : fol.Terms L n) (m : nat -> fol.Term L) (v : nat),

Lemma freeVarSubAllTerm2 :
 forall (t : fol.Term L) (m : nat -> fol.Term L) (v n : nat),

Lemma freeVarSubAllTerms2 :
 forall (a : nat) (ts : fol.Terms L a) (m : nat -> fol.Term L) (v n : nat),

Lemma freeVarSubAllFormula1 :
 forall (f : fol.Formula L) (m : nat -> fol.Term L) (v : nat),

Lemma freeVarSubAllFormula2 :
 forall (f : fol.Formula L) (m : nat -> fol.Term L) (v n : nat),

Lemma subSubAllTerm :
 forall (t : fol.Term L) (m : nat -> fol.Term L) (v : nat) (s : fol.Term L),

Lemma subSubAllTerms :
 forall (n : nat) (ts : fol.Terms L n) (m : nat -> fol.Term L) 

Lemma subSubAllFormula :
 forall (T : fol.System L) (f : fol.Formula L) (m : nat -> fol.Term L)

Lemma subAllTermId :
 forall t : fol.Term L, subAllTerm t (fun x : nat => fol.var L x) = t.

Lemma subAllTermsId :
 forall (n : nat) (ts : fol.Terms L n),

Lemma subAllFormulaId :
 forall (T : fol.System L) (f : fol.Formula L),

Lemma subAllSubAllTerm :
 forall (t : fol.Term L) (m1 m2 : nat -> fol.Term L),

Lemma subAllSubAllTerms :
 forall (n : nat) (ts : fol.Terms L n) (m1 m2 : nat -> fol.Term L),

Lemma subAllSubAllFormula :
 forall (T : fol.System L) (f : fol.Formula L) (m1 m2 : nat -> fol.Term L),

Section subAllCloseFrom.

Fixpoint closeFrom (a n : nat) (f : fol.Formula L) {struct n} :
 fol.Formula L :=
  match n with
  | O => f
  | S m => fol.forallH L (a + m) (closeFrom a m f)
  end.

Opaque le_lt_dec.

Lemma liftCloseFrom :
 forall (n : nat) (f : fol.Formula L) (T : fol.System L) (m : nat),

Lemma subAllCloseFrom1 :
 forall (n m : nat) (map : nat -> fol.Term L) (f : fol.Formula L)

Lemma subAllCloseFrom :
 forall (n : nat) (m : nat -> fol.Term L) (f : fol.Formula L)

Lemma reduceSubAll :
 forall (T : fol.System L) (map : nat -> fol.Term L) (A B : fol.Formula L),

End subAllCloseFrom.

Lemma subToSubAll :
 forall (T : fol.System L) (A : fol.Formula L) (v : nat) (s : fol.Term L),

Lemma subAllSubFormula :
 forall (T : fol.System L) (A : fol.Formula L) (v : nat) 

End SubAllVars. *)

Require Import misc.
(* misc:
Require Import Eqdep_dec.

Global Set Asymmetric Patterns.

Lemma inj_right_pair2 :
 forall A : Set,
 (forall x y : A, {x = y} + {x <> y}) ->
 forall (x : A) (P : A -> Set) (y y' : P x),
 existS P x y = existS P x y' -> y = y'. *)



Unset Standard Proposition Elimination Names.



Section Equality_Logic_Rules.



Variable L : Language.

Notation Formula := (Formula L) (only parsing).

Notation Formulas := (Formulas L) (only parsing).

Notation System := (System L) (only parsing).

Notation Term := (Term L) (only parsing).

Notation Terms := (Terms L) (only parsing).

Let var := var L.

Let apply := apply L.

Let equal := equal L.

Let atomic := atomic L.

Let impH := impH L.

Let notH := notH L.

Let forallH := forallH L.

Let orH := orH L.

Let andH := andH L.

Let existH := existH L.

Let iffH := iffH L.

Let ifThenElseH := ifThenElseH L.

Let Prf := Prf L.

Let SysPrf := SysPrf L.



Lemma eqRefl :

 forall (T : fol.System L) (a : fol.Term L), SysPrf T (equal a a).

Proof.

intros.

replace (equal a a) with (substituteFormula L (equal (var 0) (var 0)) 0 a).

apply (forallE L).

apply sysExtend with (Empty_set (fol.Formula L)).

unfold Included in |- *.

intros.

induction H.

apply forallI.

apply (notInFreeVarSys L).

exists (nil (A:=fol.Formula L)).

exists (EQ1 L).

contradiction.

rewrite (subFormulaEqual L).

simpl in |- *.

reflexivity.

Qed.



Lemma eqSym :

 forall (T : fol.System L) (a b : fol.Term L),

 SysPrf T (equal a b) -> SysPrf T (equal b a).

Proof.

intros.

apply (impE L) with (equal a b); auto.

set (m := fun x : nat => match x with

                         | O => a

                         | S _ => b

                         end) in *.

apply

 (impE L)

  with

    (subAllFormula L (impH (equal (var 0) (var 1)) (equal (var 1) (var 0)))

       (fun x : nat =>

        match le_lt_dec 2 x with

        | left _ => var x

        | right _ => m x

        end)).

simpl in |- *.

induction (le_lt_dec 2 0).

elim (le_not_lt _ _ a0).

auto.

induction (le_lt_dec 2 1).

elim (le_not_lt _ _ a0).

auto.

apply (impRefl L).

apply (subAllCloseFrom L).

apply sysExtend with (Empty_set (fol.Formula L)).

unfold Included in |- *.

intros.

induction H0.

simpl in |- *.

apply forallI.

apply (notInFreeVarSys L).

apply forallI.

apply (notInFreeVarSys L).

exists (nil (A:=fol.Formula L)).

exists (EQ2 L).

contradiction.

Qed.



Lemma eqTrans :

 forall (T : fol.System L) (a b c : fol.Term L),

 SysPrf T (equal a b) -> SysPrf T (equal b c) -> SysPrf T (equal a c).

Proof.

intros.

apply (impE L) with (equal b c); auto.

apply (impE L) with (equal a b); auto.

clear H0 H.

set

 (m :=

  fun x : nat =>

  match x with

  | O => a

  | S y => match y with

           | O => b

           | S _ => c

           end

  end) in *.

apply

 (impE L)

  with

    (subAllFormula L

       (impH (equal (var 0) (var 1))

          (impH (equal (var 1) (var 2)) (equal (var 0) (var 2))))

       (fun x : nat =>

        match le_lt_dec 3 x with

        | left _ => var x

        | right _ => m x

        end)).

simpl in |- *.

induction (le_lt_dec 3 0).

elim (le_not_lt _ _ a0).

auto.

induction (le_lt_dec 3 1).

elim (le_not_lt _ _ a0).

auto.

induction (le_lt_dec 3 2).

elim (le_not_lt _ _ a0).

auto.

apply (impRefl L).

apply (subAllCloseFrom L).

apply sysExtend with (Empty_set (fol.Formula L)).

unfold Included in |- *.

intros.

induction H.

simpl in |- *.

apply forallI.

apply (notInFreeVarSys L).

apply forallI.

apply (notInFreeVarSys L).

apply forallI.

apply (notInFreeVarSys L).

exists (nil (A:=fol.Formula L)).

exists (EQ3 L).

contradiction.

Qed.



Fixpoint PairwiseEqual (T : fol.System L) (n : nat) {struct n} :

 fol.Terms L n -> fol.Terms L n -> Prop :=

  match n return (fol.Terms L n -> fol.Terms L n -> Prop) with

  | O => fun ts ss : fol.Terms L 0 => True

  | S x =>

      fun ts ss : fol.Terms L (S x) =>

      let (a, b) := proj1_sig (consTerms L x ts) in

      let (c, d) := proj1_sig (consTerms L x ss) in

      SysPrf T (equal a c) /\ PairwiseEqual T x b d

  end.



Let termsMap (m : nat) (ts ss : fol.Terms L m) : nat -> fol.Term L.

induction m as [| m Hrecm].

exact (fun n : nat => var n).

induction (consTerms L _ ts).

induction x as (a, b).

induction (consTerms L _ ss).

induction x as (a0, b0).

exact

 (fun n : nat =>

  match eq_nat_dec n (m + m) with

  | left _ => a

  | right _ =>

      match eq_nat_dec n (S (m + m)) with

      | left _ => a0

      | right _ => Hrecm b b0 n

      end

  end).

Defined.



Remark subAllnVars1 :

 forall (a : nat) (ts ss : fol.Terms L a),

 ts = subAllTerms L _ (fst (nVars L a)) (termsMap a ts ss).

Proof.

intros.

induction a as [| a Hreca].

simpl in |- *.

symmetry  in |- *.

apply (nilTerms L).

assert

 (forall v : nat, In v (freeVarTerms L _ (fst (nVars L a))) -> v < a + a).

intros.

clear Hreca ss ts.

induction a as [| a Hreca].

elim H.

simpl in H.

induction (nVars L a).

simpl in H.

induction H as [H| H].

rewrite <- H.

rewrite <- plus_Snm_nSm.

simpl in |- *.

apply lt_S.

apply lt_n_Sn.

rewrite <- plus_Snm_nSm.

apply lt_trans with (a + a).

apply Hreca.

apply H.

simpl in |- *.

apply lt_S.

apply lt_n_Sn.

simpl in |- *.

induction (consTerms L a ts).

induction x as (a0, b).

induction (consTerms L a ss).

induction x as (a1, b0).

simpl in |- *.

simpl in H.

induction (nVars L a).

simpl in |- *.

simpl in Hreca.

induction (eq_nat_dec (a + a) (a + a)).

simpl in p.

rewrite <- p.

replace

 (subAllTerms L a a2

    (fun n : nat =>

     match eq_nat_dec n (a + a) with

     | left _ => a0

     | right _ =>

         match eq_nat_dec n (S (a + a)) with

         | left _ => a1

         | right _ => termsMap a b b0 n

         end

     end)) with (subAllTerms L a a2 (termsMap a b b0)).

rewrite <- Hreca.

reflexivity.

apply subAllTerms_ext.

intros.

induction (eq_nat_dec m (a + a)).

elim (lt_not_le m (a + a)).

apply H; auto.

rewrite a4; auto.

induction (eq_nat_dec m (S (a + a))).

elim (lt_not_le m (a + a)).

apply H; auto.

rewrite a4; apply le_n_Sn.

auto.

elim b2; auto.

Qed.



Remark subAllnVars2 :

 forall (a : nat) (ts ss : fol.Terms L a),

 ss = subAllTerms L _ (snd (nVars L a)) (termsMap a ts ss).

Proof.

intros.

induction a as [| a Hreca].

simpl in |- *.

symmetry  in |- *.

apply (nilTerms L).

assert

 (forall v : nat, In v (freeVarTerms L _ (snd (nVars L a))) -> v < a + a).

intros.

clear Hreca ss ts.

induction a as [| a Hreca].

elim H.

simpl in H.

induction (nVars L a).

simpl in H.

induction H as [H| H].

rewrite <- H.

rewrite <- plus_Snm_nSm.

simpl in |- *.

apply lt_n_Sn.

rewrite <- plus_Snm_nSm.

apply lt_trans with (a + a).

apply Hreca.

apply H.

simpl in |- *.

apply lt_S.

apply lt_n_Sn.

simpl in |- *.

induction (consTerms L a ts).

induction x as (a0, b).

induction (consTerms L a ss).

induction x as (a1, b0).

simpl in |- *.

simpl in H.

induction (nVars L a).

Opaque eq_nat_dec.

simpl.

Transparent eq_nat_dec.

destruct (eq_nat_dec (S (a+a)) (a + a)).

elim (n_Sn (a+a)).

auto.

destruct (eq_nat_dec (S (a + a)) (S (a+a))).

replace

 (subAllTerms L a b1

    (fun n : nat =>

     match eq_nat_dec n (a + a) with

     | left _ => a0

     | right _ =>

         match eq_nat_dec n (S (a + a)) with

         | left _ => a1

         | right _ => termsMap a b b0 n

         end

     end)) with (subAllTerms L a b1 (termsMap a b b0)).

rewrite <- Hreca.

auto.

apply subAllTerms_ext.

intros.

induction (eq_nat_dec m (a + a)).

elim (lt_not_le m (a + a)).

apply H; auto.

rewrite a3; auto.

induction (eq_nat_dec m (S (a + a))).

elim (lt_not_le m (a + a)).

apply H; auto.

rewrite a3; apply le_n_Sn.

auto.

elim n0; auto.

Qed.



Remark addPairwiseEquals :

 forall (T : fol.System L) (n : nat) (ts ss : fol.Terms L n),

 PairwiseEqual T n ts ss ->

 forall m0 : nat -> fol.Term L,

 (forall q : nat, q < n + n -> m0 q = termsMap n ts ss q) ->

 forall f0 : fol.Formula L,

 SysPrf T

   (subAllFormula L

      (nat_rec (fun _ : nat => fol.Formula L) f0

         (fun (n : nat) (Hrecn : fol.Formula L) =>

          fol.impH L

            (fol.equal L (fol.var L (n + n)) (fol.var L (S (n + n)))) Hrecn)

         n) m0) -> SysPrf T (subAllFormula L f0 m0).

Proof.

intros T n ts ss H.

set (m := termsMap n ts ss) in *.

induction n as [| n Hrecn].

simpl in |- *.

auto.

simpl in (value of m).

simpl in H.

induction (consTerms L n ts).

induction x as (a, b).

induction (consTerms L n ss).

induction x as (a0, b0).

simpl in H.

simpl in (value of m).

induction H as (H, H0).

simpl in |- *.

intros.

apply (Hrecn b b0).

auto.

intros.

rewrite H1.

unfold m in |- *.

induction (eq_nat_dec q (n + n)).

rewrite <- a1 in H3.

elim (lt_irrefl _ H3).

induction (eq_nat_dec q (S (n + n))).

elim (lt_not_le _ _ H3).

rewrite a1.

apply le_n_Sn.

reflexivity.

rewrite <- plus_Snm_nSm.

simpl in |- *.

repeat apply lt_S.

auto.

apply (impE L) with (fol.equal L (m0 (n + n)) (m0 (S (n + n)))).

apply H2.

rewrite <- plus_Snm_nSm in H1.

repeat rewrite H1.

unfold m in |- *.

induction (eq_nat_dec (n + n) (n + n)).

induction (eq_nat_dec (S (n + n)) (n + n)).

elim (le_not_lt (S (n + n)) (n + n)).

rewrite a2.

auto.

apply lt_n_Sn.

induction (eq_nat_dec (S (n + n)) (S (n + n))).

apply H.

elim b2; auto.

elim b1; auto.

simpl in |- *.

apply lt_n_S.

apply lt_n_Sn.

simpl in |- *.

apply lt_S.

apply lt_n_Sn.

Qed.



Lemma equalRelation :

 forall (T : fol.System L) (r : Relations L) (ts ss : fol.Terms L _),

 PairwiseEqual T _ ts ss -> SysPrf T (iffH (atomic r ts) (atomic r ss)).

Proof.

intros.

set (n := arity L (inl (Functions L) r)) in *.

set (m := termsMap n ts ss) in *.

rewrite (subAllnVars1 _ ts ss).

fold m in |- *.

rewrite (subAllnVars2 _ ts ss).

fold m in |- *.

replace

 (iffH (atomic r (subAllTerms L n (fst (nVars L n)) m))

    (atomic r (subAllTerms L n (snd (nVars L n)) m))) with

 (subAllFormula L

    (iffH (atomic r (fst (nVars L n))) (atomic r (snd (nVars L n)))) m);

 [ idtac | reflexivity ].

cut (SysPrf T (subAllFormula L (AxmEq4 L r) m)).

unfold AxmEq4 in |- *.

fold n in |- *.

replace

 (prod_rec (fun _ : fol.Terms L n * fol.Terms L n => fol.Formula L)

    (fun a b : fol.Terms L n =>

     fol.iffH L (fol.atomic L r a) (fol.atomic L r b)) 

    (nVars L n)) with

 (iffH (atomic r (fst (nVars L n))) (atomic r (snd (nVars L n)))).

generalize (iffH (atomic r (fst (nVars L n))) (atomic r (snd (nVars L n)))).

intros.

apply (addPairwiseEquals T n ts ss).

auto.

unfold m in |- *; auto.

auto.

induction (nVars L n).

simpl in |- *.

reflexivity.

replace (subAllFormula L (AxmEq4 L r) m) with

 (subAllFormula L (AxmEq4 L r)

    (fun x : nat =>

     match le_lt_dec (n + n) x with

     | left _ => fol.var L x

     | right _ => m x

     end)).

apply (subAllCloseFrom L).

apply sysExtend with (Empty_set (fol.Formula L)).

unfold Included in |- *.

intros.

induction H0.

clear m H ts ss T.

induction n as [| n Hrecn].

simpl in |- *.

exists (nil (A:=fol.Formula L)).

exists (EQ4 L r).

contradiction.

simpl in |- *.

apply (forallI L).

apply (notInFreeVarSys L).

rewrite <- plus_Snm_nSm.

simpl in |- *.

apply (forallI L).

apply (notInFreeVarSys L).

apply Hrecn.

apply subAllFormula_ext.

intros.

clear H0 H.

induction (le_lt_dec (n + n) m0).

unfold m in |- *.

induction n as [| n Hrecn].

simpl in |- *.

reflexivity.

simpl in |- *.

induction (consTerms L n ts).

induction x as (a0, b).

induction (consTerms L n ss).

induction x as (a1, b0).

simpl in |- *.

rewrite <- plus_Snm_nSm in a.

induction (eq_nat_dec m0 (n + n)).

rewrite a2 in a.

elim (le_not_lt _ _ a).

simpl in |- *.

apply lt_S.

apply lt_n_Sn.

induction (eq_nat_dec m0 (S (n + n))).

rewrite a2 in a.

elim (le_not_lt _ _ a).

simpl in |- *.

apply lt_n_Sn.

apply Hrecn.

do 2 apply le_S_n.

repeat apply le_S.

apply a.

reflexivity.

Qed.



Lemma equalFunction :

 forall (T : fol.System L) (f : Functions L) (ts ss : fol.Terms L _),

 PairwiseEqual T _ ts ss -> SysPrf T (equal (apply f ts) (apply f ss)).

Proof.

intros.

set (n := arity L (inr (Relations L) f)) in *.

set (m := termsMap n ts ss) in *.

rewrite (subAllnVars1 _ ts ss).

fold m in |- *.

rewrite (subAllnVars2 _ ts ss).

fold m in |- *.

replace

 (equal (apply f (subAllTerms L n (fst (nVars L n)) m))

    (apply f (subAllTerms L n (snd (nVars L n)) m))) with

 (subAllFormula L

    (equal (apply f (fst (nVars L n))) (apply f (snd (nVars L n)))) m);

 [ idtac | reflexivity ].

cut (SysPrf T (subAllFormula L (AxmEq5 L f) m)).

unfold AxmEq5 in |- *.

fold n in |- *.

replace

 (prod_rec (fun _ : fol.Terms L n * fol.Terms L n => fol.Formula L)

    (fun a b : fol.Terms L n =>

     fol.equal L (fol.apply L f a) (fol.apply L f b)) 

    (nVars L n)) with

 (equal (apply f (fst (nVars L n))) (apply f (snd (nVars L n)))).

generalize (equal (apply f (fst (nVars L n))) (apply f (snd (nVars L n)))).

intros.

apply (addPairwiseEquals T n ts ss).

auto.

unfold m in |- *; auto.

auto.

induction (nVars L n).

simpl in |- *.

reflexivity.

replace (subAllFormula L (AxmEq5 L f) m) with

 (subAllFormula L (AxmEq5 L f)

    (fun x : nat =>

     match le_lt_dec (n + n) x with

     | left _ => fol.var L x

     | right _ => m x

     end)).

apply (subAllCloseFrom L).

apply sysExtend with (Empty_set (fol.Formula L)).

unfold Included in |- *.

intros.

induction H0.

clear m H ts ss T.

induction n as [| n Hrecn].

simpl in |- *.

exists (nil (A:=fol.Formula L)).

exists (EQ5 L f).

contradiction.

simpl in |- *.

apply (forallI L).

apply (notInFreeVarSys L).

rewrite <- plus_Snm_nSm.

simpl in |- *.

apply (forallI L).

apply (notInFreeVarSys L).

apply Hrecn.

apply subAllFormula_ext.

intros.

clear H0 H.

induction (le_lt_dec (n + n) m0).

unfold m in |- *.

induction n as [| n Hrecn].

simpl in |- *.

reflexivity.

simpl in |- *.

induction (consTerms L n ts).

induction x as (a0, b).

induction (consTerms L n ss).

induction x as (a1, b0).

simpl in |- *.

rewrite <- plus_Snm_nSm in a.

induction (eq_nat_dec m0 (n + n)).

rewrite a2 in a.

elim (le_not_lt _ _ a).

simpl in |- *.

apply lt_S.

apply lt_n_Sn.

induction (eq_nat_dec m0 (S (n + n))).

rewrite a2 in a.

elim (le_not_lt _ _ a).

simpl in |- *.

apply lt_n_Sn.

apply Hrecn.

do 2 apply le_S_n.

repeat apply le_S.

apply a.

reflexivity.

Qed.



Lemma subWithEqualsTerm :

 forall (a b t : fol.Term L) (v : nat) (T : fol.System L),

 SysPrf T (equal a b) ->

 SysPrf T (equal (substituteTerm L t v a) (substituteTerm L t v b)).

Proof.

intros.

elim t using

 Term_Terms_ind

  with

    (P0 := fun (n : nat) (ts : fol.Terms L n) =>

           PairwiseEqual T _ (substituteTerms L _ ts v a)

             (substituteTerms L _ ts v b)); simpl in |- *; 

 intros.

induction (eq_nat_dec v n).

auto.

apply eqRefl.

apply equalFunction.

apply H0.

auto.

induction

 (consTerms L n

    (Tcons L n (substituteTerm L t0 v a) (substituteTerms L n t1 v a))).

induction x as (a0, b0).

induction

 (consTerms L n

    (Tcons L n (substituteTerm L t0 v b) (substituteTerms L n t1 v b))).

induction x as (a1, b1).

simpl in |- *.

simpl in p.

simpl in p0.

inversion p.

inversion p0.

split.

auto.

rewrite (inj_right_pair2 _ eq_nat_dec _ _ _ _ H4).

rewrite (inj_right_pair2 _ eq_nat_dec _ _ _ _ H6).

auto.

Qed.



Lemma subWithEqualsTerms :

 forall (a b : fol.Term L) (n : nat) (ts : fol.Terms L n) 

   (v : nat) (T : fol.System L),

 SysPrf T (equal a b) ->

 PairwiseEqual T _ (substituteTerms L _ ts v a) (substituteTerms L _ ts v b).

Proof.

intros.

induction ts as [| n t ts Hrects]; simpl in |- *.

auto.

induction

 (consTerms L n

    (Tcons L n (substituteTerm L t v a) (substituteTerms L n ts v a))).

induction x as (a0, b0).

induction

 (consTerms L n

    (Tcons L n (substituteTerm L t v b) (substituteTerms L n ts v b))).

induction x as (a1, b1).

simpl in |- *.

simpl in p.

simpl in p0.

inversion p.

inversion p0.

split.

apply subWithEqualsTerm.

auto.

rewrite (inj_right_pair2 _ eq_nat_dec _ _ _ _ H2).

rewrite (inj_right_pair2 _ eq_nat_dec _ _ _ _ H4).

auto.

Qed.



Lemma subWithEquals :

 forall (f : fol.Formula L) (v : nat) (a b : fol.Term L) (T : fol.System L),

 SysPrf T (equal a b) ->

 SysPrf T (impH (substituteFormula L f v a) (substituteFormula L f v b)).

Proof.

intro.

elim f using Formula_depth_ind2; intros.

repeat rewrite subFormulaEqual.

apply (impI L).

apply eqTrans with (substituteTerm L t v a).

apply subWithEqualsTerm.

apply (sysWeaken L).

apply eqSym.

auto.

apply eqTrans with (substituteTerm L t0 v a).

apply (Axm L); right; constructor.

apply subWithEqualsTerm.

apply (sysWeaken L).

auto.

apply (iffE1 L).

repeat rewrite subFormulaRelation.

apply equalRelation.

apply subWithEqualsTerms.

auto.

repeat rewrite subFormulaImp.

repeat apply (impI L).

apply impE with (substituteFormula L f1 v a).

apply H0.

repeat apply (sysWeaken L).

auto.

apply impE with (substituteFormula L f0 v a).

apply (Axm L); left; right; constructor.

apply impE with (substituteFormula L f0 v b).

apply H.

repeat apply (sysWeaken L).

apply eqSym.

auto.

apply (Axm L); right; constructor.

repeat rewrite subFormulaNot.

apply (cp2 L).

apply H.

apply eqSym.

auto.

decompose record (subFormulaForall2 L a v v0 a0).

rewrite H5; clear H5.

decompose record (subFormulaForall2 L a v v0 b).

rewrite H8; clear H8.

induction (eq_nat_dec v v0).

apply (impRefl L).

set

 (nv :=

  v0

  :: list_remove nat eq_nat_dec v (freeVarFormula L a) ++

     freeVarTerm L a0 ++ freeVarTerm L b) in *.

apply

 (impTrans L)

  with

    (fol.forallH L (newVar nv)

       (substituteFormula L (substituteFormula L a v (fol.var L (newVar nv)))

          v0 a0)).

apply sysExtend with (Empty_set (fol.Formula L)).

unfold Included in |- *; intros.

induction H7.

apply

 (impTrans L)

  with

    (fol.forallH L (newVar nv)

       (substituteFormula L

          (substituteFormula L (substituteFormula L a v (fol.var L x)) v0 a0)

          x (var (newVar nv)))).

apply (iffE1 L).

apply (rebindForall L).

unfold not in |- *; intros.

elim (newVar1 nv).

unfold nv at 2 in |- *.

assert

 (In (newVar nv)

    (freeVarFormula L

       (substituteFormula L (substituteFormula L a v (fol.var L x)) v0 a0))).

eapply In_list_remove1.

apply H7.

induction (freeVarSubFormula3 _ _ _ _ _ H8).

assert

 (In (newVar nv) (freeVarFormula L (substituteFormula L a v (fol.var L x)))).

eapply In_list_remove1.

apply H9.

induction (freeVarSubFormula3 _ _ _ _ _ H10).

right.

apply in_or_app.

auto.

elim (In_list_remove2 _ _ _ _ _ H7).

induction H11 as [H11| H11].

auto.

contradiction.

right.

auto with datatypes.

apply (iffE1 L).

apply (reduceForall L).

apply (notInFreeVarSys L).

apply

 (iffTrans L)

  with

    (substituteFormula L

       (substituteFormula L (substituteFormula L a v (fol.var L x)) x

          (var (newVar nv))) v0 a0).

apply (subFormulaExch L); auto.

unfold not in |- *; intros.

elim (newVar1 nv).

unfold nv at 2 in |- *.

simpl in |- *.

left.

induction H7 as [H7| H7].

auto.

contradiction.

apply (reduceSub L).

apply (notInFreeVarSys L).

apply (subFormulaTrans L).

auto.

apply

 (impTrans L)

  with

    (fol.forallH L (newVar nv)

       (substituteFormula L (substituteFormula L a v (fol.var L (newVar nv)))

          v0 b)).

apply impE with (equal a0 b).

apply sysExtend with (Empty_set (fol.Formula L)).

unfold Included in |- *; intros.

induction H7.

repeat apply (impI L).

apply forallI.

unfold not in |- *; intros.

induction H7 as (x1, H7); induction H7 as (H7, H8).

induction H8 as [x1 H8| x1 H8];

 [ induction H8 as [x1 H8| x1 H8] | induction H8 ]. 

induction H8; simple induction H8.

induction H8.

simpl in H7.

elim (newVar1 nv).

unfold nv at 2 in |- *.

right.

auto with datatypes.

elim (In_list_remove2 _ _ _ _ _ H7).

reflexivity.

apply

 impE

  with

    (substituteFormula L (substituteFormula L a v (fol.var L (newVar nv))) v0

       a0).

apply H.

eapply eqDepth.

symmetry  in |- *.

apply (subFormulaDepth L).

apply depthForall.

apply (Axm L); left; right; constructor.

eapply forallSimp.

apply (Axm L); right; constructor.

apply H0.

apply sysExtend with (Empty_set (fol.Formula L)).

unfold Included in |- *; intros.

induction H7.

apply (iffE2 L).

apply

 (iffTrans L)

  with

    (fol.forallH L (newVar nv)

       (substituteFormula L

          (substituteFormula L (substituteFormula L a v (fol.var L x0)) v0 b)

          x0 (var (newVar nv)))).

apply (rebindForall L).

unfold not in |- *; intros.

elim (newVar1 nv).

unfold nv at 2 in |- *.

assert

 (In (newVar nv)

    (freeVarFormula L

       (substituteFormula L (substituteFormula L a v (fol.var L x0)) v0 b))).

eapply In_list_remove1.

apply H7.

induction (freeVarSubFormula3 _ _ _ _ _ H8).

assert

 (In (newVar nv) (freeVarFormula L (substituteFormula L a v (fol.var L x0)))).

eapply In_list_remove1.

apply H9.

induction (freeVarSubFormula3 _ _ _ _ _ H10).

right.

apply in_or_app.

auto.

elim (In_list_remove2 _ _ _ _ _ H7).

induction H11 as [H11| H11].

auto.

contradiction.

right.

auto with datatypes.

apply (reduceForall L).

apply (notInFreeVarSys L).

apply

 (iffTrans L)

  with

    (substituteFormula L

       (substituteFormula L (substituteFormula L a v (fol.var L x0)) x0

          (var (newVar nv))) v0 b).

apply (subFormulaExch L); auto.

unfold not in |- *; intros.

elim (newVar1 nv).

unfold nv at 2 in |- *.

simpl in |- *.

left.

induction H7 as [H7| H7].

auto.

contradiction.

apply (reduceSub L).

apply (notInFreeVarSys L).

apply (subFormulaTrans L).

auto.

Qed.



End Equality_Logic_Rules.

