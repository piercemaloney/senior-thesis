Require Import primRec.
(* primRec:
Require Import Arith.
Require Import Peano_dec.
Require Import Compare_dec.
Require Import Coq.Lists.List.
Require Import Eqdep_dec.
Require Import extEqualNat.
Require Vector.
Require Import misc.
Require Export Bool.
Require Export EqNat.
Require Import Even.
Require Import Max.

Inductive PrimRec : nat -> Set :=
  | succFunc : PrimRec 1
  | zeroFunc : PrimRec 0
  | projFunc : forall n m : nat, m < n -> PrimRec n
  | composeFunc :
      forall (n m : nat) (g : PrimRecs n m) (h : PrimRec m), PrimRec n
  | primRecFunc :
      forall (n : nat) (g : PrimRec n) (h : PrimRec (S (S n))), PrimRec (S n)
with PrimRecs : nat -> nat -> Set :=
  | PRnil : forall n : nat, PrimRecs n 0
  | PRcons : forall n m : nat, PrimRec n -> PrimRecs n m -> PrimRecs n (S m).

Scheme PrimRec_PrimRecs_rec := Induction for PrimRec
  Sort Set
  with PrimRecs_PrimRec_rec := Induction for PrimRecs 
  Sort Set.

Scheme PrimRec_PrimRecs_ind := Induction for PrimRec
  Sort Prop
  with PrimRecs_PrimRec_ind := Induction for PrimRecs 
  Sort Prop.

Fixpoint evalConstFunc (n m : nat) {struct n} : naryFunc n :=
  match n return (naryFunc n) with
  | O => m
  | S n' => fun _ => evalConstFunc n' m
  end.

Fixpoint evalProjFunc (n : nat) : forall m : nat, m < n -> naryFunc n :=
  match n return (forall m : nat, m < n -> naryFunc n) with
  | O => fun (m : nat) (l : m < 0) => False_rec _ (lt_n_O _ l)
  | S n' =>
      fun (m : nat) (l : m < S n') =>
      match eq_nat_dec m n' with
      | left _ => fun a : nat => evalConstFunc _ a
      | right l1 =>
          fun _ =>
          evalProjFunc n' m
            match le_lt_or_eq _ _ (lt_n_Sm_le _ _ l) with
            | or_introl l2 => l2
            | or_intror l2 => False_ind _ (l1 l2)
            end
      end
  end.

Lemma evalProjFuncInd :
 forall (n m : nat) (p1 p2 : m < n),
 evalProjFunc n m p1 = evalProjFunc n m p2.

Fixpoint evalList (m : nat) (l : Vector.t nat m) {struct l} :
 naryFunc m -> nat :=
  match l in (Vector.t _ m) return (naryFunc m -> nat) with
  | Vector.nil => fun x : naryFunc 0 => x
  | Vector.cons a n l' => fun x : naryFunc (S n) => evalList n l' (x a)
  end.

Fixpoint evalOneParamList (n m a : nat) (l : Vector.t (naryFunc (S n)) m)
 {struct l} : Vector.t (naryFunc n) m :=
  match l in (Vector.t _ m) return (Vector.t (naryFunc n) m) with
  | Vector.nil  => Vector.nil  (naryFunc n)
  | Vector.cons f m' l' => Vector.cons _ (f a) m' (evalOneParamList n m' a l')
  end.

Fixpoint evalComposeFunc (n : nat) :
 forall m : nat, Vector.t (naryFunc n) m -> naryFunc m -> naryFunc n :=
  match
    n
    return
      (forall m : nat, Vector.t (naryFunc n) m -> naryFunc m -> naryFunc n)
  with
  | O => evalList
  | S n' =>
      fun (m : nat) (l : Vector.t (naryFunc (S n')) m) 
        (f : naryFunc m) (a : nat) =>
      evalComposeFunc n' m (evalOneParamList _ _ a l) f
  end.

Fixpoint compose2 (n : nat) : naryFunc n -> naryFunc (S n) -> naryFunc n :=
  match n return (naryFunc n -> naryFunc (S n) -> naryFunc n) with
  | O => fun (a : nat) (g : nat -> nat) => g a
  | S n' =>
      fun (f : naryFunc (S n')) (g : naryFunc (S (S n'))) (a : nat) =>
      compose2 n' (f a) (fun x : nat => g x a)
  end.

Fixpoint evalPrimRecFunc (n : nat) (g : naryFunc n) 
 (h : naryFunc (S (S n))) (a : nat) {struct a} : naryFunc n :=
  match a with
  | O => g
  | S a' => compose2 _ (evalPrimRecFunc n g h a') (h a')
  end.

Fixpoint evalPrimRec (n : nat) (f : PrimRec n) {struct f} : 
 naryFunc n :=
  match f in (PrimRec n) return (naryFunc n) with
  | succFunc => S
  | zeroFunc => 0
  | projFunc n m pf => evalProjFunc n m pf
  | composeFunc n m l f =>
      evalComposeFunc n m (evalPrimRecs _ _ l) (evalPrimRec _ f)
  | primRecFunc n g h =>
      evalPrimRecFunc n (evalPrimRec _ g) (evalPrimRec _ h)
  end
 
 with evalPrimRecs (n m : nat) (fs : PrimRecs n m) {struct fs} :
 Vector.t (naryFunc n) m :=
  match fs in (PrimRecs n m) return (Vector.t (naryFunc n) m) with
  | PRnil a => Vector.nil  (naryFunc a)
  | PRcons a b g gs => Vector.cons _ (evalPrimRec _ g) _ (evalPrimRecs _ _ gs)
  end.

Definition extEqualVectorGeneral (n m : nat) (l : Vector.t (naryFunc n) m) :

Definition extEqualVector n: forall m (l l' : Vector.t (naryFunc n) m), Prop.

Lemma extEqualVectorRefl :
 forall (n m : nat) (l : Vector.t (naryFunc n) m), extEqualVector n m l l.

Lemma extEqualOneParamList :
 forall (n m : nat) (l1 l2 : Vector.t (naryFunc (S n)) m) (c : nat),

Lemma extEqualCompose :
 forall (n m : nat) (l1 l2 : Vector.t (naryFunc n) m) (f1 f2 : naryFunc m),

Lemma extEqualCompose2 :
 forall (n : nat) (f1 f2 : naryFunc n),
 extEqual n f1 f2 ->
 forall g1 g2 : naryFunc (S n),
 extEqual (S n) g1 g2 -> extEqual n (compose2 n f1 g1) (compose2 n f2 g2).

Lemma extEqualPrimRec :
 forall (n : nat) (g1 g2 : naryFunc n) (h1 h2 : naryFunc (S (S n))),
 extEqual n g1 g2 ->
 extEqual (S (S n)) h1 h2 ->
 extEqual (S n) (evalPrimRecFunc n g1 h1) (evalPrimRecFunc n g2 h2).

Definition isPR (n : nat) (f : naryFunc n) : Set :=
  {p : PrimRec n | extEqual n (evalPrimRec _ p) f}.

Definition isPRrel (n : nat) (R : naryRel n) : Set :=
  isPR n (charFunction n R).

Lemma succIsPR : isPR 1 S.

Lemma const0_NIsPR : forall n : nat, isPR 0 n.

Lemma const1_NIsPR : forall n : nat, isPR 1 (fun _ => n).

Lemma idIsPR : isPR 1 (fun x : nat => x).

Lemma pi1_2IsPR : isPR 2 (fun a b : nat => a).

Lemma pi2_2IsPR : isPR 2 (fun a b : nat => b).

Lemma pi1_3IsPR : isPR 3 (fun a b c : nat => a).

Lemma pi2_3IsPR : isPR 3 (fun a b c : nat => b).

Lemma pi3_3IsPR : isPR 3 (fun a b c : nat => c).

Lemma pi1_4IsPR : isPR 4 (fun a b c d : nat => a).

Lemma pi2_4IsPR : isPR 4 (fun a b c d : nat => b).

Lemma pi3_4IsPR : isPR 4 (fun a b c d : nat => c).

Lemma pi4_4IsPR : isPR 4 (fun a b c d : nat => d).

Lemma filter01IsPR :
 forall g : nat -> nat, isPR 1 g -> isPR 2 (fun a b : nat => g b).

Lemma filter10IsPR :
 forall g : nat -> nat, isPR 1 g -> isPR 2 (fun a b : nat => g a).

Lemma filter100IsPR :
 forall g : nat -> nat, isPR 1 g -> isPR 3 (fun a b c : nat => g a).

Lemma filter010IsPR :
 forall g : nat -> nat, isPR 1 g -> isPR 3 (fun a b c : nat => g b).

Lemma filter001IsPR :
 forall g : nat -> nat, isPR 1 g -> isPR 3 (fun a b c : nat => g c).

Lemma filter011IsPR :
 forall g : nat -> nat -> nat, isPR 2 g -> isPR 3 (fun a b c : nat => g b c).

Lemma filter110IsPR :
 forall g : nat -> nat -> nat, isPR 2 g -> isPR 3 (fun a b c : nat => g a b).

Lemma filter101IsPR :
 forall g : nat -> nat -> nat, isPR 2 g -> isPR 3 (fun a b c : nat => g a c).

Lemma filter0011IsPR :
 forall g : nat -> nat -> nat,
 isPR 2 g -> isPR 4 (fun a b c d : nat => g c d).

Lemma filter1000IsPR :
 forall g : nat -> nat, isPR 1 g -> isPR 4 (fun a b c d : nat => g a).

Lemma filter1011IsPR :
 forall g : nat -> nat -> nat -> nat,
 isPR 3 g -> isPR 4 (fun a b c d : nat => g a c d).

Lemma filter1100IsPR :
 forall g : nat -> nat -> nat,
 isPR 2 g -> isPR 4 (fun a b c d : nat => g a b).

Lemma compose1_1IsPR :
 forall f : nat -> nat,
 isPR 1 f ->
 forall g : nat -> nat, isPR 1 g -> isPR 1 (fun x : nat => g (f x)).

Lemma compose1_2IsPR :
 forall f : nat -> nat,
 isPR 1 f ->
 forall f' : nat -> nat,
 isPR 1 f' ->
 forall g : nat -> nat -> nat,
 isPR 2 g -> isPR 1 (fun x : nat => g (f x) (f' x)).

Lemma compose1_3IsPR :
 forall f1 : nat -> nat,
 isPR 1 f1 ->
 forall f2 : nat -> nat,
 isPR 1 f2 ->
 forall f3 : nat -> nat,
 isPR 1 f3 ->
 forall g : nat -> nat -> nat -> nat,
 isPR 3 g -> isPR 1 (fun x : nat => g (f1 x) (f2 x) (f3 x)).

Lemma compose2_1IsPR :
 forall f : nat -> nat -> nat,
 isPR 2 f ->
 forall g : nat -> nat, isPR 1 g -> isPR 2 (fun x y : nat => g (f x y)).

Lemma compose2_2IsPR :
 forall f : nat -> nat -> nat,
 isPR 2 f ->
 forall g : nat -> nat -> nat,
 isPR 2 g ->
 forall h : nat -> nat -> nat,
 isPR 2 h -> isPR 2 (fun x y : nat => h (f x y) (g x y)).

Lemma compose2_3IsPR :
 forall f1 : nat -> nat -> nat,
 isPR 2 f1 ->
 forall f2 : nat -> nat -> nat,
 isPR 2 f2 ->
 forall f3 : nat -> nat -> nat,
 isPR 2 f3 ->
 forall g : nat -> nat -> nat -> nat,
 isPR 3 g -> isPR 2 (fun x y : nat => g (f1 x y) (f2 x y) (f3 x y)).

Lemma compose2_4IsPR :
 forall f1 : nat -> nat -> nat,
 isPR 2 f1 ->
 forall f2 : nat -> nat -> nat,
 isPR 2 f2 ->
 forall f3 : nat -> nat -> nat,
 isPR 2 f3 ->
 forall f4 : nat -> nat -> nat,
 isPR 2 f4 ->
 forall g : nat -> nat -> nat -> nat -> nat,
 isPR 4 g -> isPR 2 (fun x y : nat => g (f1 x y) (f2 x y) (f3 x y) (f4 x y)).

Lemma compose3_1IsPR :
 forall f : nat -> nat -> nat -> nat,
 isPR 3 f ->
 forall g : nat -> nat, isPR 1 g -> isPR 3 (fun x y z : nat => g (f x y z)).

Lemma compose3_2IsPR :
 forall f1 : nat -> nat -> nat -> nat,
 isPR 3 f1 ->
 forall f2 : nat -> nat -> nat -> nat,
 isPR 3 f2 ->
 forall g : nat -> nat -> nat,
 isPR 2 g -> isPR 3 (fun x y z : nat => g (f1 x y z) (f2 x y z)).

Lemma compose3_3IsPR :
 forall f1 : nat -> nat -> nat -> nat,
 isPR 3 f1 ->
 forall f2 : nat -> nat -> nat -> nat,
 isPR 3 f2 ->
 forall f3 : nat -> nat -> nat -> nat,
 isPR 3 f3 ->
 forall g : nat -> nat -> nat -> nat,
 isPR 3 g -> isPR 3 (fun x y z : nat => g (f1 x y z) (f2 x y z) (f3 x y z)).

Lemma compose4_2IsPR :
 forall f1 : nat -> nat -> nat -> nat -> nat,
 isPR 4 f1 ->
 forall f2 : nat -> nat -> nat -> nat -> nat,
 isPR 4 f2 ->
 forall g : nat -> nat -> nat,
 isPR 2 g -> isPR 4 (fun w x y z : nat => g (f1 w x y z) (f2 w x y z)).

Lemma compose4_3IsPR :
 forall f1 : nat -> nat -> nat -> nat -> nat,
 isPR 4 f1 ->
 forall f2 : nat -> nat -> nat -> nat -> nat,
 isPR 4 f2 ->
 forall f3 : nat -> nat -> nat -> nat -> nat,
 isPR 4 f3 ->
 forall g : nat -> nat -> nat -> nat,
 isPR 3 g ->
 isPR 4 (fun w x y z : nat => g (f1 w x y z) (f2 w x y z) (f3 w x y z)).

Lemma swapIsPR :
 forall f : nat -> nat -> nat, isPR 2 f -> isPR 2 (fun x y : nat => f y x).

Lemma indIsPR :
 forall f : nat -> nat -> nat,
 isPR 2 f ->
 forall g : nat,
 isPR 1
   (fun a : nat => nat_rec (fun n : nat => nat) g (fun x y : nat => f x y) a).

Lemma ind1ParamIsPR :
 forall f : nat -> nat -> nat -> nat,
 isPR 3 f ->
 forall g : nat -> nat,
 isPR 1 g ->
 isPR 2
   (fun a b : nat =>
    nat_rec (fun n : nat => nat) (g b) (fun x y : nat => f x y b) a).

Lemma ind2ParamIsPR :
 forall f : nat -> nat -> nat -> nat -> nat,
 isPR 4 f ->
 forall g : nat -> nat -> nat,
 isPR 2 g ->
 isPR 3
   (fun a b c : nat =>
    nat_rec (fun n : nat => nat) (g b c) (fun x y : nat => f x y b c) a).

Lemma plusIndIsPR : isPR 3 (fun n fn b : nat => S fn).

Lemma plusIsPR : isPR 2 plus.

Lemma multIndIsPR : isPR 3 (fun n fn b : nat => fn + b).

Lemma multIsPR : isPR 2 mult.

Lemma predIsPR : isPR 1 pred.

Lemma minusIndIsPR : isPR 3 (fun n fn b : nat => pred fn).

Lemma minusIsPR : isPR 2 minus.

Definition notZero (a : nat) :=
  nat_rec (fun n : nat => nat) 0 (fun x y : nat => 1) a.

Lemma notZeroIsPR : isPR 1 notZero.

Definition ltBool (a b : nat) : bool.

Lemma ltBoolTrue : forall a b : nat, ltBool a b = true -> a < b.

Lemma ltBoolFalse : forall a b : nat, ltBool a b = false -> ~ a < b.

Lemma ltIsPR : isPRrel 2 ltBool.

Lemma maxIsPR : isPR 2 max.

Lemma gtIsPR : isPRrel 2 (fun a b : nat => ltBool b a).

Remark replaceCompose2 :
 forall (n : nat) (a b a' b' : naryFunc n) (c c' : naryFunc 2),
 extEqual n a a' ->
 extEqual n b b' ->
 extEqual 2 c c' ->
 extEqual n
   (evalComposeFunc _ _ (Vector.cons _ a _ (Vector.cons _ b _ (Vector.nil  (naryFunc n)))) c)

Definition orRel (n : nat) (R S : naryRel n) : naryRel n.

Lemma orRelPR :
 forall (n : nat) (R R' : naryRel n),
 isPRrel n R -> isPRrel n R' -> isPRrel n (orRel n R R').

Definition andRel (n : nat) (R S : naryRel n) : naryRel n.

Lemma andRelPR :
 forall (n : nat) (R R' : naryRel n),
 isPRrel n R -> isPRrel n R' -> isPRrel n (andRel n R R').

Definition notRel (n : nat) (R : naryRel n) : naryRel n.

Lemma notRelPR :
 forall (n : nat) (R : naryRel n), isPRrel n R -> isPRrel n (notRel n R).

Fixpoint bodd (n : nat) : bool :=
  match n with
  | O => false
  | S n' => negb (bodd n')
  end.

Lemma boddIsPR : isPRrel 1 bodd.

Lemma beq_nat_not_refl : forall a b : nat, a <> b -> beq_nat a b = false.

Lemma neqIsPR : isPRrel 2 (fun a b : nat => negb (beq_nat a b)).

Lemma eqIsPR : isPRrel 2 beq_nat.

Definition leBool (a b : nat) : bool.

Lemma leIsPR : isPRrel 2 leBool.

Section Ignore_Params.

Fixpoint ignoreParams (n m : nat) (f : naryFunc n) {struct m} :
 naryFunc (m + n) :=
  match m return (naryFunc (m + n)) with
  | O => f
  | S x => fun _ => ignoreParams n x f
  end.

Definition projectionListPR (n m : nat) (p : m <= n) : PrimRecs n m.

Definition projectionList (n m : nat) (p : m <= n) : 
  Vector.t (naryFunc n) m := evalPrimRecs n m (projectionListPR n m p).

Lemma projectionListInd :
 forall (n m : nat) (p1 p2 : m <= n),
 projectionList n m p1 = projectionList n m p2.

Lemma projectionListApplyParam :
 forall (m n c : nat) (p1 : m <= n) (p2 : m <= S n),
 extEqualVector _ _ (projectionList n m p1)
   (evalOneParamList n m c (projectionList (S n) m p2)).

Lemma projectionListId :
 forall (n : nat) (f : naryFunc n) (p : n <= n),
 extEqual n f (evalComposeFunc n n (projectionList n n p) f).

Lemma ignoreParamsIsPR :
 forall (n m : nat) (f : naryFunc n), isPR _ f -> isPR _ (ignoreParams n m f).

End Ignore_Params.

Lemma reduce1stCompose :
 forall (c n m : nat) (v : Vector.t (naryFunc n) m) (g : naryFunc (S m)),

Lemma reduce2ndCompose :
 forall (c n m : nat) (v : Vector.t (naryFunc n) m) (n0 : naryFunc n)

Lemma evalPrimRecParam :
 forall (n c d : nat) (g : naryFunc (S n)) (h : naryFunc (S (S (S n)))),
 extEqual _ (evalPrimRecFunc n (g d) (fun x y : nat => h x y d) c)
   (evalPrimRecFunc (S n) g h c d).

Lemma compose2IsPR :
 forall (n : nat) (f : naryFunc n) (p : isPR n f) (g : naryFunc (S n))
   (q : isPR (S n) g), isPR n (compose2 n f g).

Lemma compose1_NIsPR :
 forall (n : nat) (g : naryFunc (S n)),
 isPR (S n) g ->
 forall f : naryFunc 1, isPR 1 f -> isPR (S n) (fun x : nat => g (f x)).

Definition switchPR : naryFunc 3. 

Lemma switchIsPR : isPR 3 switchPR.

Fixpoint boundedSearchHelp (P : naryRel 1) (b : nat) {struct b} : nat :=
  match b with
  | O => 0
  | S b' =>
      match eq_nat_dec (boundedSearchHelp P b') b' with
      | left _ => match P b' with
                  | true => b'
                  | false => S b'
                  end
      | right _ => boundedSearchHelp P b'
      end
  end.
   
Definition boundedSearch (P : naryRel 2) (b : nat) : nat :=
  boundedSearchHelp (P b) b.

Lemma boundedSearch1 :
 forall (P : naryRel 2) (b x : nat), x < boundedSearch P b -> P b x = false.

Lemma boundedSearch2 :
 forall (P : naryRel 2) (b : nat),
 boundedSearch P b = b \/ P b (boundedSearch P b) = true.

Lemma boundSearchIsPR :
 forall P : naryRel 2,
 isPRrel 2 P -> isPR 1 (fun b : nat => boundedSearch P b).

Definition iterate (g : nat -> nat) :=
  nat_rec (fun _ => nat -> nat) (fun x : nat => x)
    (fun (_ : nat) (rec : nat -> nat) (x : nat) => g (rec x)).

Lemma iterateIsPR :
 forall g : nat -> nat, isPR 1 g -> forall n : nat, isPR 1 (iterate g n). *)

Require Import cPair.
(* cPair:
Require Import Arith.
Require Import Coq.Lists.List.
Require Import extEqualNat.
Require Import primRec.
Require Vector.
Require Import Div2.

Definition sumToN (n : nat) :=
  nat_rec (fun _ => nat) 0 (fun x y : nat => S x + y) n.

Lemma sumToN1 : forall n : nat, n <= sumToN n.

Lemma sumToN2 : forall b a : nat, a <= b -> sumToN a <= sumToN b.

Lemma sumToNIsPR : isPR 1 sumToN.

Definition cPair (a b : nat) := a + sumToN (a + b).

Lemma cPairIsPR : isPR 2 cPair.

Section CPair_Injectivity.

Remark cPairInjHelp :
 forall a b c d : nat, cPair a b = cPair c d -> a + b = c + d.

Lemma cPairInj1 : forall a b c d : nat, cPair a b = cPair c d -> a = c.

Lemma cPairInj2 : forall a b c d : nat, cPair a b = cPair c d -> b = d.

End CPair_Injectivity.

Section CPair_projections.

Let searchXY (a : nat) :=
  boundedSearch (fun a y : nat => ltBool a (sumToN (S y))) a.

Definition cPairPi1 (a : nat) := a - sumToN (searchXY a).
Definition cPairPi2 (a : nat) := searchXY a - cPairPi1 a.

Lemma cPairProjectionsHelp :
 forall a b : nat, b < sumToN (S a) -> sumToN a <= b -> searchXY b = a.

Lemma cPairProjections : forall a : nat, cPair (cPairPi1 a) (cPairPi2 a) = a.

Remark searchXYIsPR : isPR 1 searchXY.

Lemma cPairPi1IsPR : isPR 1 cPairPi1.

Lemma cPairPi2IsPR : isPR 1 cPairPi2.

Lemma cPairProjections1 : forall a b : nat, cPairPi1 (cPair a b) = a.

Lemma cPairProjections2 : forall a b : nat, cPairPi2 (cPair a b) = b.

End CPair_projections.

Section CPair_Order.

Lemma cPairLe1 : forall a b : nat, a <= cPair a b.

Lemma cPairLe1A : forall a : nat, cPairPi1 a <= a.

Lemma cPairLe2 : forall a b : nat, b <= cPair a b.

Lemma cPairLe2A : forall a : nat, cPairPi2 a <= a.

Lemma cPairLe3 :
 forall a b c d : nat, a <= b -> c <= d -> cPair a c <= cPair b d.

Lemma cPairLt1 : forall a b : nat, a < cPair a (S b).

Lemma cPairLt2 : forall a b : nat, b < cPair (S a) b.

End CPair_Order.

Section code_nat_list.

Fixpoint codeList (l : list nat) : nat :=
  match l with
  | nil => 0
  | n :: l' => S (cPair n (codeList l'))
  end.

Lemma codeListInj : forall l m : list nat, codeList l = codeList m -> l = m.

Definition codeNth (n m : nat) : nat.

Let drop (n : nat) : forall (l : list nat), list nat.

Lemma codeNthCorrect :
 forall (n : nat) (l : list nat), codeNth n (codeList l) = nth n l 0.

Lemma codeNthIsPR : isPR 2 codeNth.

End code_nat_list.

Section Strong_Recursion.

Definition evalStrongRecHelp (n : nat) (f : naryFunc (S (S n))) :
  naryFunc (S n) :=
  evalPrimRecFunc n (evalComposeFunc n 0 (Vector.nil _) (codeList nil))
    (evalComposeFunc (S (S n)) 2
       (Vector.cons _ f _
          (Vector.cons _ (evalProjFunc (S (S n)) n (lt_S _ _ (lt_n_Sn _))) _
             (Vector.nil _))) (fun a b : nat => S (cPair a b))).

Definition evalStrongRec (n : nat) (f : naryFunc (S (S n))) :
  naryFunc (S n) :=
  evalComposeFunc (S n) 1
    (Vector.cons _ (fun z : nat => evalStrongRecHelp n f (S z)) _ (Vector.nil _))
    (fun z : nat => cPairPi1 (pred z)).

Lemma evalStrongRecIsPR :
 forall (n : nat) (f : naryFunc (S (S n))),
 isPR _ f -> isPR _ (evalStrongRec n f).

Lemma computeEvalStrongRecHelp :
 forall (n : nat) (f : naryFunc (S (S n))) (c : nat),
 evalStrongRecHelp n f (S c) =
 compose2 n (evalStrongRecHelp n f c)
   (fun a0 : nat =>
    evalComposeFunc n 2
      (Vector.cons (naryFunc n) (f c a0) 1

Let listValues (f : naryFunc 2) (n : nat) : list nat.

Lemma evalStrongRecHelp1 :
 forall (f : naryFunc 2) (n m : nat),
 m < n -> codeNth (n - S m) (evalStrongRecHelp _ f n) = evalStrongRec _ f m.

Lemma evalStrongRecHelpParam :
 forall (a n c : nat) (f : naryFunc (S (S (S a)))),
 extEqual a (evalStrongRecHelp (S a) f n c)
   (evalStrongRecHelp a (fun x y : nat => f x y c) n).

Lemma evalStrongRecHelp2 :
 forall (a : nat) (f : naryFunc (S (S a))) (n m : nat),
 m < n ->
 extEqual _
   (evalComposeFunc _ 1 (Vector.cons _ (evalStrongRecHelp _ f n) 0 (Vector.nil _))

Lemma callIsPR :
 forall g : nat -> nat,
 isPR 1 g -> isPR 2 (fun a recs : nat => codeNth (a - S (g a)) recs).

End Strong_Recursion.

Lemma div2IsPR : isPR 1 div2. *)

Require Import Arith.

Require Import code.
(* code:
Require Import Arith.
Require Import fol.
Require Import folProof.
Require Import cPair.

Section Code_Term_Formula_Proof.

Variable L : Language.
Variable codeF : Functions L -> nat.
Variable codeR : Relations L -> nat.
Hypothesis codeFInj : forall f g : Functions L, codeF f = codeF g -> f = g.
Hypothesis codeRInj : forall R S : Relations L, codeR R = codeR S -> R = S.

Let Formula := Formula L.
Let Formulas := Formulas L.
Let System := System L.
Let Term := Term L.
Let Terms := Terms L.
Let var := var L.
Let apply := apply L.
Let equal := equal L.
Let atomic := atomic L.
Let impH := impH L.
Let notH := notH L.
Let forallH := forallH L.
Let orH := orH L.
Let andH := andH L.
Let existH := existH L.
Let iffH := iffH L.
Let ifThenElseH := ifThenElseH L.
Let Prf := Prf L.
Let SysPrf := SysPrf L.

Fixpoint codeTerm (t : Term) : nat :=
  match t with
  | fol.var n => cPair 0 n
  | fol.apply f ts => cPair (S (codeF f)) (codeTerms _ ts)
  end
 
 with codeTerms (n : nat) (ts : Terms n) {struct ts} : nat :=
  match ts with
  | Tnil => 0
  | Tcons n t ss => S (cPair (codeTerm t) (codeTerms n ss))
  end.

Lemma codeTermInj : forall t s : Term, codeTerm t = codeTerm s -> t = s.

Lemma codeTermsInj :
 forall (n : nat) (ts ss : Terms n),
 codeTerms n ts = codeTerms n ss -> ts = ss.

Fixpoint codeFormula (f : Formula) : nat :=
  match f with
  | fol.equal t1 t2 => cPair 0 (cPair (codeTerm t1) (codeTerm t2))
  | fol.impH f1 f2 => cPair 1 (cPair (codeFormula f1) (codeFormula f2))
  | fol.notH f1 => cPair 2 (codeFormula f1)
  | fol.forallH n f1 => cPair 3 (cPair n (codeFormula f1))
  | fol.atomic R ts => cPair (4+(codeR R)) (codeTerms _ ts)
  end.

Lemma codeFormulaInj :
 forall f g : Formula, codeFormula f = codeFormula g -> f = g.

Fixpoint codePrf (Z : Formulas) (f : Formula) (prf : Prf Z f) {struct prf} :
 nat :=
  match prf with
  | AXM A => cPair 0 (codeFormula A)
  | MP Axm1 Axm2 A B rec1 rec2 =>
      cPair 1
        (cPair
           (cPair (cPair 1 (cPair (codeFormula A) (codeFormula B)))
              (codePrf _ _ rec1)) (cPair (codeFormula A) (codePrf _ _ rec2)))
  | GEN Axm A v _ rec =>
      cPair 2 (cPair v (cPair (codeFormula A) (codePrf _ _ rec)))
  | IMP1 A B => cPair 3 (cPair (codeFormula A) (codeFormula B))
  | IMP2 A B C =>
      cPair 4 (cPair (codeFormula A) (cPair (codeFormula B) (codeFormula C)))
  | CP A B => cPair 5 (cPair (codeFormula A) (codeFormula B))
  | FA1 A v t => cPair 6 (cPair (codeFormula A) (cPair v (codeTerm t)))
  | FA2 A v _ => cPair 7 (cPair (codeFormula A) v)
  | FA3 A B v => cPair 8 (cPair (codeFormula A) (cPair (codeFormula B) v))
  | EQ1 => cPair 9 0
  | EQ2 => cPair 10 0
  | EQ3 => cPair 11 0
  | EQ4 r => cPair 12 (codeR r)
  | EQ5 f => cPair 13 (codeF f)
  end.

Lemma codePrfInjAxm :
 forall (a b : Formula) (A B : Formulas) (p : Prf A a) (q : Prf B b),
 codePrf A a p = codePrf B b q -> A = B.

Definition codeImp (a b : nat) := cPair 1 (cPair a b).

Lemma codeImpCorrect :
 forall a b : Formula,
 codeImp (codeFormula a) (codeFormula b) = codeFormula (impH a b).

Definition codeNot (a : nat) := cPair 2 a.

Lemma codeNotCorrect :
 forall a : Formula, codeNot (codeFormula a) = codeFormula (notH a).

Definition codeForall (n a : nat) := cPair 3 (cPair n a).

Lemma codeForallCorrect :
 forall (n : nat) (a : Formula),
 codeForall n (codeFormula a) = codeFormula (forallH n a).

Definition codeOr (a b : nat) := codeImp (codeNot a) b.

Lemma codeOrCorrect :
 forall a b : Formula,
 codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).

Definition codeAnd (a b : nat) := codeNot (codeOr (codeNot a) (codeNot b)).

Lemma codeAndCorrect :
 forall a b : Formula,
 codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).

Definition codeIff (a b : nat) := codeAnd (codeImp a b) (codeImp b a).

Lemma codeIffCorrect :
 forall a b : Formula,
 codeIff (codeFormula a) (codeFormula b) = codeFormula (iffH a b).

End Code_Term_Formula_Proof. *)

Require Import codeSubFormula.
(* codeSubFormula:
Require Import primRec.
Require Import cPair.
Require Import Arith.
Require Import folProp.
Require Import code.
Require Import extEqualNat.
Require Vector.
Require Import codeSubTerm.
Require Import codeFreeVar.
Require Import Max.

Section Code_Substitute_Formula.

Variable L : Language.
Variable codeF : Functions L -> nat.
Variable codeR : Relations L -> nat.

Notation Formula := (Formula L) (only parsing).
Notation Formulas := (Formulas L) (only parsing).
Notation System := (System L) (only parsing).
Notation Term := (Term L) (only parsing).
Notation Terms := (Terms L) (only parsing).
Let var := var L.
Let apply := apply L.
Let codeFormula := codeFormula L codeF codeR.
Let codeTerm := codeTerm L codeF.

Definition cTriple (a b c : nat) : nat := cPair a (cPair b c).

Definition cTriplePi1 (n : nat) : nat := cPairPi1 n.

Definition cTriplePi2 (n : nat) : nat := cPairPi1 (cPairPi2 n).

Definition cTriplePi3 (n : nat) : nat := cPairPi2 (cPairPi2 n).

Lemma cTripleIsPR : isPR 3 cTriple.

Lemma cTriplePi1IsPR : isPR 1 cTriplePi1.

Lemma cTriplePi2IsPR : isPR 1 cTriplePi2.

Lemma cTriplePi3IsPR : isPR 1 cTriplePi3.

Lemma cTripleProj1 : forall a b c : nat, cTriplePi1 (cTriple a b c) = a.

Lemma cTripleProj2 : forall a b c : nat, cTriplePi2 (cTriple a b c) = b.

Lemma cTripleProj3 : forall a b c : nat, cTriplePi3 (cTriple a b c) = c.

Lemma cTripleProj :
 forall a : nat, cTriple (cTriplePi1 a) (cTriplePi2 a) (cTriplePi3 a) = a.

Definition codeNewVar (l : nat) : nat :=
  evalStrongRec 0
    (fun n Hrecs : nat =>
     switchPR n
       (max (S (cPairPi1 (pred n)))
          (codeNth (n - S (cPairPi2 (pred n))) Hrecs)) 0) l.

Lemma codeNewVarCorrect :
 forall l : list nat, codeNewVar (codeList l) = newVar l.

Lemma codeNewVarIsPR : isPR 1 codeNewVar.

Definition checkSubFormulaTrace : nat -> nat :=
  evalStrongRec 0
    (fun trace recs : nat =>
     let v := cTriplePi1 (cTriplePi1 trace) in
     let s := cTriplePi2 (cTriplePi1 trace) in
     let input := cTriplePi3 (cTriplePi1 trace) in
     let output := cTriplePi2 trace in
     let rest := cTriplePi3 trace in
     let type := cPairPi1 input in
     switchPR type
       (switchPR (pred type)
          (switchPR (pred (pred type))
             (switchPR (pred (pred (pred type)))
                (charFunction 2 beq_nat output
                   (cPair type (codeSubTerms (cPairPi2 input) v s)))
                (switchPR
                   (charFunction 2 beq_nat v (cPairPi1 (cPairPi2 input)))
                   (charFunction 2 beq_nat input output)
                   (switchPR
                      (codeIn (cPairPi1 (cPairPi2 input)) (codeFreeVarTerm s))
                      (let nv :=
                         codeNewVar
                           (S
                              (cPair v
                                 (codeApp (codeFreeVarTerm s)
                                    (codeFreeVarFormula
                                       (cPairPi2 (cPairPi2 input)))))) in
                       charFunction 0
                         (beq_nat output
                            (cPair 3 (cPair nv (cTriplePi2 (cPairPi2 rest)))) &&
                          (beq_nat (cTriple v s (cTriplePi2 (cPairPi1 rest)))
                             (cTriplePi1 (cPairPi2 rest)) &&
                           beq_nat
                             (cTriple (cPairPi1 (cPairPi2 input))
                                (cPair 0 nv) (cPairPi2 (cPairPi2 input)))
                             (cTriplePi1 (cPairPi1 rest)))) *
                       (codeNth (trace - S (cPairPi1 rest)) recs *
                        codeNth (trace - S (cPairPi2 rest)) recs))
                      (charFunction 0
                         (beq_nat output
                            (cPair 3
                               (cPair (cPairPi1 (cPairPi2 input))
                                  (cTriplePi2 rest))) &&
                          beq_nat (cTriple v s (cPairPi2 (cPairPi2 input)))
                            (cTriplePi1 rest)) *
                       codeNth (trace - S rest) recs))))
             (charFunction 0
                (beq_nat output (cPair 2 (cTriplePi2 rest)) &&
                 beq_nat (cTriple v s (cPairPi2 input)) (cTriplePi1 rest)) *
              codeNth (trace - S rest) recs))
          (charFunction 0
             (beq_nat output
                (cPair 1
                   (cPair (cTriplePi2 (cPairPi1 rest))
                      (cTriplePi2 (cPairPi2 rest)))) &&
              (beq_nat (cTriple v s (cPairPi1 (cPairPi2 input)))
                 (cTriplePi1 (cPairPi1 rest)) &&
               beq_nat (cTriple v s (cPairPi2 (cPairPi2 input)))
                 (cTriplePi1 (cPairPi2 rest)))) *
           (codeNth (trace - S (cPairPi1 rest)) recs *
            codeNth (trace - S (cPairPi2 rest)) recs)))
       (charFunction 2 beq_nat output
          (cPair 0
             (cPair (codeSubTerm (cPairPi1 (cPairPi2 input)) v s)
                (codeSubTerm (cPairPi2 (cPairPi2 input)) v s))))).

Definition makeTraceImp (f1 : fol.Formula L)
  (f1rec : nat * fol.Term L -> nat) (f2 : fol.Formula L)
  (f2rec : nat * fol.Term L -> nat) (p : nat * fol.Term L) : nat :=
  let v := fst p in
  let s := snd p in
  cTriple (cTriple v (codeTerm s) (codeFormula (impH L f1 f2)))
    (codeFormula (substituteFormula L (impH L f1 f2) v s))
    (cPair (f1rec p) (f2rec p)).

Definition makeTraceNot (f : fol.Formula L) (frec : nat * fol.Term L -> nat)
  (p : nat * fol.Term L) : nat :=
  let v := fst p in
  let s := snd p in
  cTriple (cTriple v (codeTerm s) (codeFormula (notH L f)))
    (codeFormula (substituteFormula L (notH L f) v s)) 
    (frec p).

Definition makeTraceForall (n : nat) (f : fol.Formula L)

Definition makeTrace : fol.Formula L -> nat * fol.Term L -> nat :=
  Formula_depth_rec2 L (fun _ : fol.Formula L => nat * fol.Term L -> nat)
    (fun (t t0 : fol.Term L) (p : nat * fol.Term L) =>
     let v := fst p in
     let s := snd p in
     cTriple (cTriple v (codeTerm s) (codeFormula (equal L t t0)))
       (codeFormula (substituteFormula L (equal L t t0) v s)) 0)
    (fun (r : Relations L) t (p : nat * fol.Term L) =>
     let v := fst p in
     let s := snd p in
     cTriple (cTriple v (codeTerm s) (codeFormula (atomic L r t)))
       (codeFormula (substituteFormula L (atomic L r t) v s)) 0) makeTraceImp
    makeTraceNot makeTraceForall.

Lemma makeTraceImpNice :
 forall (f2 g : fol.Formula L) (z1 z2 : nat * fol.Term L -> nat),

Lemma makeTraceNotNice :
 forall (f2 : fol.Formula L) (z1 z2 : nat * fol.Term L -> nat),

Lemma makeTraceForallNice :
 forall (v0 : nat) (a : fol.Formula L)

Remark makeTrace1 :
 forall (f : fol.Formula L) (v : nat) (s : fol.Term L),

Remark makeTrace2 :
 forall (f : fol.Formula L) (v : nat) (s : fol.Term L),

Lemma makeTraceCorrect :
 forall (f : fol.Formula L) (v : nat) (s : fol.Term L),

Lemma checkTraceCorrect :
 forall (f : fol.Formula L) (v : nat) (s : fol.Term L) (n m : nat),

Lemma switch5IsPR :
 forall (f1 f2 f3 f4 f5 : nat -> nat -> nat) (g : nat -> nat),
 isPR 2 f1 ->
 isPR 2 f2 ->
 isPR 2 f3 ->
 isPR 2 f4 ->
 isPR 2 f5 ->
 isPR 1 g ->
 isPR 2
   (fun n recs : nat =>
    switchPR (g n)
      (switchPR (pred (g n))
         (switchPR (pred (pred (g n)))
            (switchPR (pred (pred (pred (g n)))) (f1 n recs) (f2 n recs))
            (f3 n recs)) (f4 n recs)) (f5 n recs)).

Lemma checkTraceIsPR : isPR 1 checkSubFormulaTrace.

Definition ReplaceTermTermsTerm : nat -> nat -> nat :=
  evalStrongRec 1
    (fun t recs s : nat =>
     cPair
       (switchPR (cPairPi1 t)
          (cPair (cPairPi1 t) (cPairPi2 (codeNth (t - S (cPairPi2 t)) recs)))
          (cPair 0 s))
       (switchPR t
          (S
             (cPair (cPairPi1 (codeNth (t - S (cPairPi1 (pred t))) recs))
                (cPairPi2 (codeNth (t - S (cPairPi2 (pred t))) recs)))) 0)).

Remark ReplaceTermTermsTermIsPR : isPR 2 ReplaceTermTermsTerm.

Definition ReplaceTermTerm (t s : nat) : nat :=
  cPairPi1 (ReplaceTermTermsTerm t s).

Definition ReplaceTermsTerm (t s : nat) : nat :=
  cPairPi2 (ReplaceTermTermsTerm t s).

Lemma ReplaceTermTermIsPR : isPR 2 ReplaceTermTerm.

Lemma ReplaceTermsTermIsPR : isPR 2 ReplaceTermsTerm.

Remark ReplaceTermTermsTermMonotone :
 forall a s1 s2 : nat,
 s1 <= s2 ->
 ReplaceTermTerm a s1 <= ReplaceTermTerm a s2 /\
 ReplaceTermsTerm a s1 <= ReplaceTermsTerm a s2.

Lemma ReplaceTermTermMonotone :
 forall a s1 s2 : nat,
 s1 <= s2 -> ReplaceTermTerm a s1 <= ReplaceTermTerm a s2.

Lemma ReplaceTermsTermMonotone :
 forall a s1 s2 : nat,
 s1 <= s2 -> ReplaceTermsTerm a s1 <= ReplaceTermsTerm a s2.

Remark maxLemma :
 forall a b c d : nat, a <= b -> c <= d -> max a c <= max b d.

Remark maxLemma2 :
 forall a b : list nat, fold_right max 0 a <= fold_right max 0 (a ++ b).
Proof.
intros.
induction a as [| a a0 Hreca].
apply le_O_n.
simpl in |- *.
apply maxLemma.

Remark maxLemma3 :
 forall a b : list nat, fold_right max 0 b <= fold_right max 0 (a ++ b).

Remark maxApp :
 forall a b : list nat,
 {fold_right max 0 (a ++ b) = fold_right max 0 a} +
 {fold_right max 0 (a ++ b) = fold_right max 0 b}.
Proof.
intros.
induction a as [| a a0 Hreca].
simpl in |- *.
auto.
simpl in |- *.
induction (max_dec a (fold_right max 0 (a0 ++ b))).
rewrite a1.
left.
symmetry  in |- *.
apply max_l.
apply le_trans with (max a (fold_right max 0 (a0 ++ b))).
apply le_trans with (max a (fold_right max 0 a0)).
apply le_max_r.
apply maxLemma.
apply le_n.
apply maxLemma2.

Lemma boundSubTerm :
 forall (t : fol.Term L) (v : nat) (s : fol.Term L),
 codeTerm (substituteTerm L t v s) <=
 ReplaceTermTerm (codeTerm t)
   (fold_right max 0 (codeTerm s :: freeVarTerm L t)).
Proof.
intro.
unfold ReplaceTermTerm in |- *.
unfold ReplaceTermsTerm in |- *.
unfold ReplaceTermTermsTerm in |- *.
set
 (A :=
  fun t0 recs s0 : nat =>
  cPair
    (switchPR (cPairPi1 t0)
       (cPair (cPairPi1 t0) (cPairPi2 (codeNth (t0 - S (cPairPi2 t0)) recs)))
       (cPair 0 s0))
    (switchPR t0
       (S
          (cPair (cPairPi1 (codeNth (t0 - S (cPairPi1 (pred t0))) recs))
             (cPairPi2 (codeNth (t0 - S (cPairPi2 (pred t0))) recs)))) 0))
 in *.
assert
 (forall n m : nat,
  m < n ->
  extEqual 1
    (evalComposeFunc 1 1 (Vector.cons _ (evalStrongRecHelp 1 A n) 0 (Vector.nil _))
       (fun b : nat => codeNth (n - S m) b)) (evalStrongRec 1 A m)).
intros.
apply (evalStrongRecHelp2 1). 
assumption.
simpl in H.
elim t using
 Term_Terms_ind
  with
    (P0 := fun (n : nat) (ts : fol.Terms L n) =>
           forall (v : nat) (s : fol.Term L),
           codeTerms L codeF n (substituteTerms L n ts v s) <=
           ReplaceTermsTerm (codeTerms L codeF n ts)
             (fold_right max 0 (codeTerm s :: freeVarTerms L n ts)));
 simpl in |- *; intros; unfold evalStrongRec in |- *;
 unfold evalComposeFunc, evalOneParamList, evalList in |- *;
 repeat rewrite computeEvalStrongRecHelp; unfold compose2 in |- *;
 unfold evalComposeFunc, evalOneParamList, evalList in |- *; 
 simpl in |- *; repeat rewrite cPairProjections1.
unfold A in |- *.
simpl in |- *.
repeat rewrite cPairProjections1.
replace (codeTerm (fol.var L n)) with (cPair 0 n); [ idtac | reflexivity ].
repeat rewrite cPairProjections1.
simpl in |- *.
induction (eq_nat_dec v n).
eapply le_trans; [ idtac | apply cPairLe2 ].
apply le_max_l.
replace (codeTerm (fol.var L n)) with (cPair 0 n); [ idtac | reflexivity ].
apply cPairLe3.
apply le_n.
eapply le_trans; [ idtac | apply le_max_r ].
apply le_max_l.
unfold A in |- *.
repeat rewrite cPairProjections1.
replace (codeTerm (fol.apply L f t0)) with
 (cPair (S (codeF f)) (codeTerms L codeF _ t0)); [ idtac | reflexivity ].
repeat rewrite cPairProjections1.
rewrite
 H
   with
   (m := 
     cPairPi2
       (cPair (S (codeF f))
          (codeTerms L codeF (arity L (inr (Relations L) f)) t0))).
simpl in |- *.
replace
 (codeTerm
    (fol.apply L f (substituteTerms L (arity L (inr (Relations L) f)) t0 v s)))
 with
 (cPair (S (codeF f))
    (codeTerms L codeF _
       (substituteTerms L (arity L (inr (Relations L) f)) t0 v s)));
 [ idtac | reflexivity ].
apply cPairLe3.
apply le_n.
unfold ReplaceTermsTerm in H0.
unfold ReplaceTermTermsTerm in H0.
fold A in H0.
repeat rewrite cPairProjections2.
apply (H0 v s).
repeat rewrite cPairProjections2.
apply cPairLt2.
apply le_O_n.
replace
 (codeTerms L codeF (S n)
    (Tcons L n (substituteTerm L t0 v s) (substituteTerms L n t1 v s))) with
 (S
    (cPair (codeTerm (substituteTerm L t0 v s))
       (codeTerms L codeF n (substituteTerms L n t1 v s))));
 [ idtac | reflexivity ].
unfold ReplaceTermsTerm in |- *.
unfold ReplaceTermsTerm in H1.
unfold ReplaceTermTermsTerm in |- *.
unfold ReplaceTermTermsTerm in H1.
fold A in |- *.
fold A in H1.
unfold evalStrongRec in |- *.
unfold evalComposeFunc, evalOneParamList, evalList in |- *.
repeat rewrite computeEvalStrongRecHelp.
unfold compose2 in |- *.
unfold evalComposeFunc, evalOneParamList, evalList in |- *.
simpl in |- *.
repeat rewrite cPairProjections1.
unfold A at 1 in |- *.
repeat rewrite cPairProjections2.
repeat rewrite H.
replace (codeTerms L codeF (S n) (Tcons L n t0 t1)) with
 (S (cPair (codeTerm t0) (codeTerms L codeF n t1))); 
 [ idtac | reflexivity ].
simpl in |- *.
repeat rewrite cPairProjections1.
apply le_n_S.
apply cPairLe3.
eapply le_trans.
apply H0.
apply
 (ReplaceTermTermMonotone (codeTerm t0)
    (max (codeTerm s) (fold_right max 0 (freeVarTerm L t0)))
    (max (codeTerm s)
       (fold_right max 0 (freeVarTerms L (S n) (Tcons L n t0 t1))))).
apply maxLemma.
apply le_n.
replace (freeVarTerms L (S n) (Tcons L n t0 t1)) with
 (freeVarTerm L t0 ++ freeVarTerms L n t1); [ idtac | reflexivity ].
apply maxLemma2.
eapply le_trans.
apply H1.
repeat rewrite cPairProjections2.
apply
 (ReplaceTermsTermMonotone (codeTerms L codeF n t1)
    (max (codeTerm s) (fold_right max 0 (freeVarTerms L n t1)))
    (max (codeTerm s)
       (fold_right max 0 (freeVarTerms L (S n) (Tcons L n t0 t1))))).
apply maxLemma.
apply le_n.
replace (freeVarTerms L (S n) (Tcons L n t0 t1)) with
 (freeVarTerm L t0 ++ freeVarTerms L n t1); [ idtac | reflexivity ].
apply maxLemma3.

Lemma boundSubTerms :
 forall (n : nat) (ts : fol.Terms L n) (v : nat) (s : fol.Term L),
 codeTerms L codeF n (substituteTerms L n ts v s) <=
 ReplaceTermsTerm (codeTerms L codeF n ts)
   (fold_right max 0 (codeTerm s :: freeVarTerms L n ts)).
Proof.
intros n ts.
unfold ReplaceTermTerm in |- *.
unfold ReplaceTermsTerm in |- *.
unfold ReplaceTermTermsTerm in |- *.
set
 (A :=
  fun t0 recs s0 : nat =>
  cPair
    (switchPR (cPairPi1 t0)
       (cPair (cPairPi1 t0) (cPairPi2 (codeNth (t0 - S (cPairPi2 t0)) recs)))
       (cPair 0 s0))
    (switchPR t0
       (S
          (cPair (cPairPi1 (codeNth (t0 - S (cPairPi1 (pred t0))) recs))
             (cPairPi2 (codeNth (t0 - S (cPairPi2 (pred t0))) recs)))) 0))
 in *.
assert
 (forall n m : nat,
  m < n ->
  extEqual 1
    (evalComposeFunc 1 1 (Vector.cons _ (evalStrongRecHelp 1 A n) 0 (Vector.nil _))
       (fun b : nat => codeNth (n - S m) b)) (evalStrongRec 1 A m)).
intros.
apply (evalStrongRecHelp2 1). 
assumption.
simpl in H.
induction ts as [| n t ts Hrects]; simpl in |- *; intros.
apply le_O_n.
replace
 (codeTerms L codeF (S n)
    (Tcons L n (substituteTerm L t v s) (substituteTerms L n ts v s))) with
 (S
    (cPair (codeTerm (substituteTerm L t v s))
       (codeTerms L codeF n (substituteTerms L n ts v s))));
 [ idtac | reflexivity ].
unfold evalStrongRec in |- *;
 unfold evalComposeFunc, evalOneParamList, evalList in |- *;
 repeat rewrite computeEvalStrongRecHelp; unfold compose2 in |- *;
 unfold evalComposeFunc, evalOneParamList, evalList in |- *; 
 simpl in |- *; repeat rewrite cPairProjections1.
unfold A at 1 in |- *.
repeat rewrite cPairProjections2.
repeat rewrite H.
replace (codeTerms L codeF (S n) (Tcons L n t ts)) with
 (S (cPair (codeTerm t) (codeTerms L codeF n ts))); 
 [ idtac | reflexivity ].
simpl in |- *.
repeat rewrite cPairProjections1.
apply le_n_S.
apply cPairLe3.
eapply le_trans.
apply boundSubTerm.
apply
 (ReplaceTermTermMonotone (codeTerm t)
    (max (codeTerm s) (fold_right max 0 (freeVarTerm L t)))
    (max (codeTerm s)
       (fold_right max 0 (freeVarTerms L (S n) (Tcons L n t ts))))).
apply maxLemma.
apply le_n.
replace (freeVarTerms L (S n) (Tcons L n t ts)) with
 (freeVarTerm L t ++ freeVarTerms L n ts); [ idtac | reflexivity ].
apply maxLemma2.
eapply le_trans.
apply Hrects.
repeat rewrite cPairProjections2.
apply
 (ReplaceTermsTermMonotone (codeTerms L codeF n ts)
    (max (codeTerm s) (fold_right max 0 (freeVarTerms L n ts)))
    (max (codeTerm s)
       (fold_right max 0 (freeVarTerms L (S n) (Tcons L n t ts))))).
apply maxLemma.
apply le_n.
replace (freeVarTerms L (S n) (Tcons L n t ts)) with
 (freeVarTerm L t ++ freeVarTerms L n ts); [ idtac | reflexivity ].
apply maxLemma3.

Lemma ReplaceTermTermSub :
 forall (t : fol.Term L) (v w s2 : nat),

Lemma ReplaceTermsTermSub :
 forall (n : nat) (ts : fol.Terms L n) (v w s2 : nat),

Definition ReplaceFormulaTerm : nat -> nat -> nat :=
  evalStrongRec 1
    (fun f recs s : nat =>
     switchPR (cPairPi1 f)
       (switchPR (pred (cPairPi1 f))
          (switchPR (pred (pred (cPairPi1 f)))
             (switchPR (pred (pred (pred (cPairPi1 f))))
                (cPair (cPairPi1 f) (ReplaceTermsTerm (cPairPi2 f) s))
                (cPair 3
                   (cPair s (codeNth (f - S (cPairPi2 (cPairPi2 f))) recs))))
             (cPair 2 (codeNth (f - S (cPairPi2 f)) recs)))
          (cPair 1
             (cPair (codeNth (f - S (cPairPi1 (cPairPi2 f))) recs)
                (codeNth (f - S (cPairPi2 (cPairPi2 f))) recs))))
       (cPair 0
          (cPair (ReplaceTermTerm (cPairPi1 (cPairPi2 f)) s)
             (ReplaceTermTerm (cPairPi2 (cPairPi2 f)) s)))).

Lemma ReplaceFormulaTermIsPR : isPR 2 ReplaceFormulaTerm.

Lemma ReplaceFormulaTermMonotone :
 forall a s1 s2 : nat,
 s1 <= s2 -> ReplaceFormulaTerm a s1 <= ReplaceFormulaTerm a s2.

Fixpoint varFormula (f : fol.Formula L) : list nat :=
  match f with
  | equal t s => freeVarTerm L t ++ freeVarTerm L s
  | atomic r ts => freeVarTerms L _ ts
  | impH A B => varFormula A ++ varFormula B
  | notH A => varFormula A
  | forallH v A => v :: varFormula A
  end.

Lemma ReplaceFormulaTermSub :
 forall (f : fol.Formula L) (v w s2 : nat),

Remark codeTermFreeVar :
 forall s : fol.Term L, fold_right max 0 (freeVarTerm L s) <= codeTerm s.

Remark maxVarFreeVar :
 forall f : fol.Formula L,
 fold_right max 0 (freeVarFormula L f) <= fold_right max 0 (varFormula f).
Proof.
intros.
induction f as [t t0| r t| f1 Hrecf1 f0 Hrecf0| f Hrecf| n f Hrecf];
 simpl in |- *.
apply le_n.
apply le_n.
induction (maxApp (freeVarFormula L f1) (freeVarFormula L f0)).
rewrite a.
eapply le_trans.
apply Hrecf1.
apply maxLemma2.
rewrite b.
eapply le_trans.
apply Hrecf0.
apply maxLemma3.
assumption.
apply le_trans with (fold_right max 0 (freeVarFormula L f)).
clear Hrecf.
induction (freeVarFormula L f).
simpl in |- *.
apply le_O_n.
simpl in |- *.
induction (eq_nat_dec a n).
eapply le_trans.
apply IHl.
apply le_max_r.
simpl in |- *.
apply maxLemma.

Remark maxSubTerm :
 forall (t : fol.Term L) (v : nat) (s : fol.Term L),
 fold_right max 0 (freeVarTerm L (substituteTerm L t v s)) <=
 fold_right max 0 (freeVarTerm L s ++ freeVarTerm L t).
Proof.
intros.
elim t using
 Term_Terms_ind
  with
    (P0 := fun (n : nat) (ts : fol.Terms L n) =>
           fold_right max 0 (freeVarTerms L n (substituteTerms L n ts v s)) <=
           fold_right max 0 (freeVarTerm L s ++ freeVarTerms L n ts));
 simpl in |- *; intros.
induction (eq_nat_dec v n).
apply maxLemma2.
apply maxLemma3.
apply H.
apply le_O_n.
replace
 (freeVarTerms L (S n)
    (Tcons L n (substituteTerm L t0 v s) (substituteTerms L n t1 v s))) with
 (freeVarTerm L (substituteTerm L t0 v s) ++
  freeVarTerms L n (substituteTerms L n t1 v s)).
replace (freeVarTerms L (S n) (Tcons L n t0 t1)) with
 (freeVarTerm L t0 ++ freeVarTerms L n t1).
induction
 (maxApp (freeVarTerm L (substituteTerm L t0 v s))
    (freeVarTerms L n (substituteTerms L n t1 v s))).
rewrite a.
eapply le_trans.
apply H.
induction (maxApp (freeVarTerm L s) (freeVarTerm L t0)).
rewrite a0.
apply maxLemma2.
rewrite b.
apply
 le_trans with (fold_right max 0 (freeVarTerm L t0 ++ freeVarTerms L n t1)).
apply maxLemma2.
apply maxLemma3.
rewrite b.
eapply le_trans.
apply H0.
induction (maxApp (freeVarTerm L s) (freeVarTerms L n t1)).
rewrite a.
apply maxLemma2.
rewrite b0.
apply
 le_trans with (fold_right max 0 (freeVarTerm L t0 ++ freeVarTerms L n t1)).
apply maxLemma3.
apply maxLemma3.

Remark maxSubTerms :
 forall (n : nat) (ts : fol.Terms L n) (v : nat) (s : fol.Term L),
 fold_right max 0 (freeVarTerms L n (substituteTerms L n ts v s)) <=
 fold_right max 0 (freeVarTerm L s ++ freeVarTerms L n ts).
Proof.
intros.
induction ts as [| n t ts Hrects]; simpl in |- *; intros.
apply le_O_n.
replace
 (freeVarTerms L (S n)
    (Tcons L n (substituteTerm L t v s) (substituteTerms L n ts v s))) with
 (freeVarTerm L (substituteTerm L t v s) ++
  freeVarTerms L n (substituteTerms L n ts v s)).
replace (freeVarTerms L (S n) (Tcons L n t ts)) with
 (freeVarTerm L t ++ freeVarTerms L n ts).
induction
 (maxApp (freeVarTerm L (substituteTerm L t v s))
    (freeVarTerms L n (substituteTerms L n ts v s))).
rewrite a.
eapply le_trans.
apply maxSubTerm.
induction (maxApp (freeVarTerm L s) (freeVarTerm L t)).
rewrite a0.
apply maxLemma2.
rewrite b.
apply
 le_trans with (fold_right max 0 (freeVarTerm L t ++ freeVarTerms L n ts)).
apply maxLemma2.
apply maxLemma3.
rewrite b.
eapply le_trans.
apply Hrects.
induction (maxApp (freeVarTerm L s) (freeVarTerms L n ts)).
rewrite a.
apply maxLemma2.
rewrite b0.
apply
 le_trans with (fold_right max 0 (freeVarTerm L t ++ freeVarTerms L n ts)).
apply maxLemma3.
apply maxLemma3.

Definition pow3 : nat -> nat :=
  nat_rec (fun _ => nat) 1 (fun _ rec : nat => rec + (rec + rec)).

Lemma pow3IsPR : isPR 1 pow3.

Lemma pow3Monotone : forall a b : nat, a <= b -> pow3 a <= pow3 b.

Lemma pow3Min : forall a : nat, 1 <= pow3 a.

Remark mapListLemma :
 forall l : list nat, fold_right max 0 (map S l) <= S (fold_right max 0 l).
Proof.
intros.
induction l as [| a l Hrecl].
simpl in |- *.
auto.
simpl in |- *.
induction (fold_right max 0 (map S l)).
apply le_n_S.
apply le_max_l.
apply le_n_S.
apply maxLemma.

Remark boundSubFormulaHelp2 :
 forall (a : fol.Formula L) (v0 : nat) (s : fol.Term L),
 newVar (v0 :: freeVarTerm L s ++ freeVarFormula L a) <=
 S
   (fold_right max 0
      (v0 :: fold_right max 0 (freeVarTerm L s) :: varFormula a)).
intros.
unfold newVar in |- *.
apply
 le_trans
  with (S (fold_right max 0 (v0 :: freeVarTerm L s ++ freeVarFormula L a))).
apply mapListLemma.
apply le_n_S.
simpl in |- *.
apply maxLemma.

Remark boundSubFormulaHelp1 :
 forall (b a : fol.Formula L) (v0 v : nat) (s : fol.Term L),
 fold_right max 0
   (varFormula
      (substituteFormula L b v
         (fol.var L (newVar (v0 :: freeVarTerm L s ++ freeVarFormula L a))))) <=
 pow3 (depth L b) + pow3 (depth L b) +
 max v0
   (max (fold_right max 0 (freeVarTerm L s))
      (max v
         (max (fold_right max 0 (varFormula b))
            (fold_right max 0 (varFormula a))))).
Proof.
intro.
elim b using Formula_depth_ind2; intros;
 set (nv := newVar (v0 :: freeVarTerm L s ++ freeVarFormula L a)) in *.
simpl in |- *.
apply le_S.
induction
 (maxApp (freeVarTerm L (substituteTerm L t v (fol.var L nv)))
    (freeVarTerm L (substituteTerm L t0 v (fol.var L nv)))).
rewrite a0.
eapply le_trans.
apply maxSubTerm.
simpl in |- *.
apply (max_case2 nv (fold_right max 0 (freeVarTerm L t))).
eapply le_trans.
apply (boundSubFormulaHelp2 a v0 s).
apply le_n_S.
simpl in |- *.
repeat apply maxLemma; try apply le_n.
eapply le_trans; [ idtac | apply le_max_r ].
apply le_max_r.
apply le_S.
do 3 (eapply le_trans; [ idtac | apply le_max_r ]).
eapply le_trans; [ idtac | apply le_max_l ].
apply maxLemma2.
rewrite b0.
eapply le_trans.
apply maxSubTerm.
simpl in |- *.
apply (max_case2 nv (fold_right max 0 (freeVarTerm L t0))).
eapply le_trans.
apply (boundSubFormulaHelp2 a v0 s).
 apply le_n_S.
simpl in |- *.
repeat apply maxLemma; try apply le_n.
eapply le_trans; [ idtac | apply le_max_r ].
apply le_max_r.
apply le_S.
do 3 (eapply le_trans; [ idtac | apply le_max_r ]).
eapply le_trans; [ idtac | apply le_max_l ].
apply maxLemma3.
eapply le_trans.
simpl in |- *.
apply maxSubTerms.
simpl in |- *.
apply le_S.
apply
 (max_case2 nv
    (fold_right max 0 (freeVarTerms L (arity L (inl (Functions L) r)) t))).
eapply le_trans.
apply (boundSubFormulaHelp2 a v0 s).
apply le_n_S.
simpl in |- *.
repeat apply maxLemma; try apply le_n.
eapply le_trans; [ idtac | apply le_max_r ].
apply le_max_r.
apply le_S.
do 3 (eapply le_trans; [ idtac | apply le_max_r ]).
eapply le_trans; [ idtac | apply le_max_l ].
apply le_n.
rewrite subFormulaImp.
simpl in |- *.
induction
 (maxApp (varFormula (substituteFormula L f v (fol.var L nv)))
    (varFormula (substituteFormula L f0 v (fol.var L nv)))).
rewrite a0.
eapply le_trans.
apply (H a v0 v s).
apply plus_le_compat.
eapply le_trans; [ idtac | apply le_plus_l ].
assert (pow3 (depth L f) <= pow3 (max (depth L f) (depth L f0))).
apply pow3Monotone.
apply le_max_l.
apply plus_le_compat.
assumption.
eapply le_trans; [ idtac | apply le_plus_l ].
assumption.
repeat apply maxLemma; try apply le_n.
apply maxLemma2.
rewrite b0.
eapply le_trans.
apply (H0 a v0 v s).
apply plus_le_compat.
eapply le_trans; [ idtac | apply le_plus_l ].
assert (pow3 (depth L f0) <= pow3 (max (depth L f) (depth L f0))).
apply pow3Monotone.
apply le_max_r.
apply plus_le_compat.
assumption.
eapply le_trans; [ idtac | apply le_plus_l ].
assumption.
repeat apply maxLemma; try apply le_n.
apply maxLemma3.
rewrite subFormulaNot.
eapply le_trans.
apply (H a v0 v s).
apply plus_le_compat.
simpl in |- *.
eapply le_trans; [ idtac | apply le_plus_l ].
apply le_plus_r.
apply le_n.
clear nv.
rewrite subFormulaForall.
induction (eq_nat_dec v v1).
eapply le_trans; [ idtac | apply le_plus_r ].
do 3 (eapply le_trans; [ idtac | apply le_max_r ]).
apply le_max_l.
induction
 (In_dec eq_nat_dec v
    (freeVarTerm L
       (fol.var L (newVar (v0 :: freeVarTerm L s ++ freeVarFormula L a0))))).
simpl in |- *.
apply
 (max_case2
    (newVar
       (v1
        :: newVar (v0 :: freeVarTerm L s ++ freeVarFormula L a0)
           :: freeVarFormula L a))
    (fold_right max 0
       (varFormula
          (substituteFormula L
             (substituteFormula L a v
                (fol.var L
                   (newVar
                      (v1
                       :: newVar
                            (v0 :: freeVarTerm L s ++ freeVarFormula L a0)
                          :: freeVarFormula L a)))) v1
             (fol.var L
                (newVar (v0 :: freeVarTerm L s ++ freeVarFormula L a0))))))).
unfold newVar at 1 in |- *.
eapply le_trans.
apply mapListLemma.
apply
 le_trans
  with
    (1 + 1 +
     max v0
       (max (fold_right max 0 (freeVarTerm L s))
          (max v1
             (max (max v (fold_right max 0 (varFormula a)))
                (fold_right max 0 (varFormula a0)))))).
simpl in |- *.
apply le_n_S.
apply
 (max_case2 v1
    (max (newVar (v0 :: freeVarTerm L s ++ freeVarFormula L a0))
       (fold_right max 0 (freeVarFormula L a)))).
apply le_S.
do 2 (eapply le_trans; [ idtac | apply le_max_r ]).
apply le_max_l.
apply
 (max_case2 (newVar (v0 :: freeVarTerm L s ++ freeVarFormula L a0))
    (fold_right max 0 (freeVarFormula L a))).
eapply le_trans.
apply boundSubFormulaHelp2.
apply le_n_S.
simpl in |- *.
repeat apply maxLemma; try apply le_n.
eapply le_trans; [ idtac | apply le_max_r ].
apply le_max_r.
apply le_S.
do 3 (eapply le_trans; [ idtac | apply le_max_r ]).
eapply le_trans; [ idtac | apply le_max_l ].
eapply le_trans.
apply maxVarFreeVar.
apply le_max_r.
apply plus_le_compat.
eapply le_trans; [ idtac | apply le_plus_r ].
apply plus_le_compat.
apply pow3Min.
simpl in |- *.
eapply le_trans; [ idtac | apply le_plus_r ].
apply pow3Min.
apply le_n.
eapply le_trans.
apply H.
eapply eqDepth.
symmetry  in |- *.
apply subFormulaDepth.
apply depthForall.
rewrite subFormulaDepth.
rewrite (plus_assoc (pow3 (depth L a)) (pow3 (depth L a)) (pow3 (depth L a))).
repeat rewrite (plus_assoc_reverse (pow3 (depth L a) + pow3 (depth L a))).
apply plus_le_compat.
apply le_n.
apply
 (max_case2 v0
    (max (fold_right max 0 (freeVarTerm L s))
       (max v1
          (max
             (fold_right max 0
                (varFormula
                   (substituteFormula L a v
                      (fol.var L
                         (newVar
                            (v1
                             :: newVar
                                  (v0
                                   :: freeVarTerm L s ++ freeVarFormula L a0)
                                :: freeVarFormula L a))))))
             (fold_right max 0 (varFormula a0)))))).
eapply le_trans; [ idtac | apply le_plus_r ].
apply le_max_l.
apply
 (max_case2 (fold_right max 0 (freeVarTerm L s))
    (max v1
       (max
          (fold_right max 0
             (varFormula
                (substituteFormula L a v
                   (fol.var L
                      (newVar
                         (v1
                          :: newVar
                               (v0 :: freeVarTerm L s ++ freeVarFormula L a0)
                             :: freeVarFormula L a))))))
          (fold_right max 0 (varFormula a0))))).
eapply le_trans; [ idtac | apply le_plus_r ].
eapply le_trans; [ idtac | apply le_max_r ].
apply le_max_l.
apply
 (max_case2 v1
    (max
       (fold_right max 0
          (varFormula
             (substituteFormula L a v
                (fol.var L
                   (newVar
                      (v1
                       :: newVar
                            (v0 :: freeVarTerm L s ++ freeVarFormula L a0)
                          :: freeVarFormula L a))))))
       (fold_right max 0 (varFormula a0)))).
eapply le_trans; [ idtac | apply le_plus_r ].
do 2 (eapply le_trans; [ idtac | apply le_max_r ]).
apply le_max_l.
apply
 (max_case2
    (fold_right max 0
       (varFormula
          (substituteFormula L a v
             (fol.var L
                (newVar
                   (v1
                    :: newVar (v0 :: freeVarTerm L s ++ freeVarFormula L a0)
                       :: freeVarFormula L a))))))
    (fold_right max 0 (varFormula a0))).
eapply le_trans.
apply
 H
  with
    (b := a)
    (v := v)
    (v0 := v1)
    (a := a)
    (s := var (newVar (v0 :: freeVarTerm L s ++ freeVarFormula L a0))).
apply depthForall.
rewrite
 (plus_comm (pow3 (depth L a))
    (pow3 (depth L a) + pow3 (depth L a) + pow3 (depth L a)))
 .
repeat rewrite (plus_assoc_reverse (pow3 (depth L a) + pow3 (depth L a))).
apply plus_le_compat.
apply le_n.
apply
 (max_case2 v1
    (max
       (fold_right max 0
          (freeVarTerm L
             (var (newVar (v0 :: freeVarTerm L s ++ freeVarFormula L a0)))))
       (max v
          (max (fold_right max 0 (varFormula a))
             (fold_right max 0 (varFormula a)))))).
eapply le_trans; [ idtac | apply le_plus_r ].
do 2 (eapply le_trans; [ idtac | apply le_max_r ]).
apply le_max_l.
apply
 (max_case2
    (fold_right max 0
       (freeVarTerm L
          (var (newVar (v0 :: freeVarTerm L s ++ freeVarFormula L a0)))))
    (max v
       (max (fold_right max 0 (varFormula a))
          (fold_right max 0 (varFormula a))))).
simpl in |- *.
apply (max_case2 (newVar (v0 :: freeVarTerm L s ++ freeVarFormula L a0)) 0).
eapply le_trans.
apply boundSubFormulaHelp2.
apply
 le_trans
  with
    (1 +
     max v0
       (max (fold_right max 0 (freeVarTerm L s))
          (max v1
             (max (max v (fold_right max 0 (varFormula a)))
                (fold_right max 0 (varFormula a0)))))).
simpl in |- *.
apply le_n_S.
repeat apply maxLemma; try apply le_n.
repeat (eapply le_trans; [ idtac | apply le_max_r ]).
apply le_n.
apply plus_le_compat.
eapply le_trans; [ idtac | apply le_plus_r ].
apply pow3Min.
apply le_n.
apply le_O_n.
eapply le_trans; [ idtac | apply le_plus_r ].
do 3 (eapply le_trans; [ idtac | apply le_max_r ]).
apply
 (max_case2 v
    (max (fold_right max 0 (varFormula a)) (fold_right max 0 (varFormula a)))).
eapply le_trans; [ idtac | apply le_max_l ].
apply le_max_l.
apply
 (max_case2 (fold_right max 0 (varFormula a))
    (fold_right max 0 (varFormula a)));
 (eapply le_trans; [ idtac | apply le_max_l ]; apply le_max_r).
eapply le_trans; [ idtac | apply le_plus_r ].
repeat (eapply le_trans; [ idtac | apply le_max_r ]).
apply le_n.
simpl in |- *.
apply
 (max_case2 v
    (fold_right max 0
       (varFormula
          (substituteFormula L a v1
             (fol.var L
                (newVar (v0 :: freeVarTerm L s ++ freeVarFormula L a0))))))).
eapply le_trans; [ idtac | apply le_plus_r ].
do 3 (eapply le_trans; [ idtac | apply le_max_r ]).
eapply le_trans; [ idtac | apply le_max_l ].
apply le_max_l.
eapply le_trans.
apply H.
apply depthForall.
apply plus_le_compat.
eapply le_trans; [ idtac | apply le_plus_r ].
apply plus_le_compat.
apply le_n.
apply le_plus_l.
repeat apply maxLemma; try apply le_n.

Remark boundSubFormulaHelp :
 forall (f : fol.Formula L) (v : nat) (s : fol.Term L),
 codeFormula (substituteFormula L f v s) <=
 ReplaceFormulaTerm (codeFormula f)
   (max (codeTerm s)
      (pow3 (depth L f) +
       fold_right max 0 (v :: freeVarTerm L s ++ varFormula f))).
Proof.
intro.
unfold ReplaceFormulaTerm in |- *.
set
 (A :=
  fun f0 recs s0 : nat =>
  switchPR (cPairPi1 f0)
    (switchPR (pred (cPairPi1 f0))
       (switchPR (pred (pred (cPairPi1 f0)))
          (switchPR (pred (pred (pred (cPairPi1 f0))))
             (cPair (cPairPi1 f0) (ReplaceTermsTerm (cPairPi2 f0) s0))
             (cPair 3
                (cPair s0 (codeNth (f0 - S (cPairPi2 (cPairPi2 f0))) recs))))
          (cPair 2 (codeNth (f0 - S (cPairPi2 f0)) recs)))
       (cPair 1
          (cPair (codeNth (f0 - S (cPairPi1 (cPairPi2 f0))) recs)
             (codeNth (f0 - S (cPairPi2 (cPairPi2 f0))) recs))))
    (cPair 0
       (cPair (ReplaceTermTerm (cPairPi1 (cPairPi2 f0)) s0)
          (ReplaceTermTerm (cPairPi2 (cPairPi2 f0)) s0)))) 
 in *.
assert
 (forall n m : nat,
  m < n ->
  extEqual 1
    (evalComposeFunc 1 1 (Vector.cons _ (evalStrongRecHelp 1 A n) 0 (Vector.nil _))
       (fun b : nat => codeNth (n - S m) b)) (evalStrongRec 1 A m)).
intros.
apply (evalStrongRecHelp2 1). 
assumption.
simpl in H.
elim f using Formula_depth_ind2; intros.
unfold evalStrongRec in |- *.
unfold evalComposeFunc, evalOneParamList, evalList in |- *.
repeat rewrite computeEvalStrongRecHelp.
unfold compose2 in |- *.
unfold evalComposeFunc, evalOneParamList, evalList in |- *.
set
 (C :=
  max (codeTerm s)
    (pow3 (depth L (equal L t t0)) +
     fold_right max 0 (v :: freeVarTerm L s ++ varFormula (equal L t t0))))
 in *.
simpl in |- *.
repeat rewrite cPairProjections1.
unfold A at 1 in |- *.
repeat first [ rewrite cPairProjections1 | rewrite cPairProjections2 ].
simpl in |- *.
apply cPairLe3.
apply le_n.
apply cPairLe3.
apply
 le_trans
  with
    (ReplaceTermTerm (codeTerm t)
       (fold_right max 0 (codeTerm s :: freeVarTerm L t))).
apply boundSubTerm.
apply ReplaceTermTermMonotone.
unfold C in |- *.
simpl in |- *.
apply maxLemma.
apply le_n.
apply le_S.
eapply le_trans; [ idtac | apply le_max_r ].
eapply le_trans; [ idtac | apply maxLemma3 ].
apply maxLemma2.
apply
 le_trans
  with
    (ReplaceTermTerm (codeTerm t0)
       (fold_right max 0 (codeTerm s :: freeVarTerm L t0))).
apply boundSubTerm.
apply ReplaceTermTermMonotone.
unfold C in |- *.
simpl in |- *.
apply maxLemma.
apply le_n.
apply le_S.
eapply le_trans; [ idtac | apply le_max_r ].
eapply le_trans; [ idtac | apply maxLemma3 ].
apply maxLemma3.
unfold evalStrongRec in |- *.
unfold evalComposeFunc, evalOneParamList, evalList in |- *.
repeat rewrite computeEvalStrongRecHelp.
unfold compose2 in |- *.
unfold evalComposeFunc, evalOneParamList, evalList in |- *.
set
 (C :=
  max (codeTerm s)
    (pow3 (depth L (atomic L r t)) +
     fold_right max 0 (v :: freeVarTerm L s ++ varFormula (atomic L r t))))
 in *.
simpl in |- *.
repeat rewrite cPairProjections1.
unfold A at 1 in |- *.
repeat first [ rewrite cPairProjections1 | rewrite cPairProjections2 ].
simpl in |- *.
apply cPairLe3.
apply le_n.
apply
 le_trans
  with
    (ReplaceTermsTerm (codeTerms L codeF _ t)
       (fold_right max 0 (codeTerm s :: freeVarTerms L _ t))).
apply boundSubTerms.
apply ReplaceTermsTermMonotone.
unfold C in |- *.
simpl in |- *.
apply maxLemma.
apply le_n.
apply le_S.
eapply le_trans; [ idtac | apply le_max_r ].
apply maxLemma3.
rewrite subFormulaImp.
set
 (C :=
  max (codeTerm s)
    (pow3 (depth L (impH L f0 f1)) +
     fold_right max 0 (v :: freeVarTerm L s ++ varFormula (impH L f0 f1))))
 in *.
unfold evalStrongRec in |- *.
unfold evalComposeFunc, evalOneParamList, evalList in |- *.
repeat rewrite computeEvalStrongRecHelp.
unfold compose2 in |- *.
unfold evalComposeFunc, evalOneParamList, evalList in |- *.
simpl in |- *.
repeat rewrite cPairProjections1.
unfold A at 1 in |- *.
repeat first [ rewrite cPairProjections1 | rewrite cPairProjections2 ].
rewrite H with (m := codeFormula f0).
rewrite H with (m := codeFormula f1).
simpl in |- *.
apply cPairLe3.
apply le_n.
apply cPairLe3.
apply
 le_trans
  with
    (evalStrongRec 1 A (codeFormula f0)
       (max (codeTerm s)
          (pow3 (depth L f0) +
           fold_right max 0 (v :: freeVarTerm L s ++ varFormula f0)))).
auto.
apply ReplaceFormulaTermMonotone.
unfold C in |- *.
apply maxLemma.
apply le_n.
apply plus_le_compat.
apply pow3Monotone.
simpl in |- *.
apply le_S.
apply le_max_l.
simpl in |- *.
apply maxLemma.
apply le_n.
rewrite ass_app.
apply maxLemma2.
apply
 le_trans
  with
    (evalStrongRec 1 A (codeFormula f1)
       (max (codeTerm s)
          (pow3 (depth L f1) +
           fold_right max 0 (v :: freeVarTerm L s ++ varFormula f1)))).
auto.
apply ReplaceFormulaTermMonotone.
unfold C in |- *.
apply maxLemma.
apply le_n.
apply plus_le_compat.
apply pow3Monotone.
simpl in |- *.
apply le_S.
apply le_max_r.
simpl in |- *.
apply maxLemma.
apply le_n.
induction (maxApp (freeVarTerm L s) (varFormula f1)).
rewrite a.
apply maxLemma2.
rewrite b.
eapply le_trans; [ idtac | apply maxLemma3 ].
apply maxLemma3.
eapply le_lt_trans; [ idtac | apply cPairLt2 ].
apply cPairLe2.
eapply le_lt_trans; [ idtac | apply cPairLt2 ].
apply cPairLe1.
rewrite subFormulaNot.
set
 (C :=
  max (codeTerm s)
    (pow3 (depth L (notH L f0)) +
     fold_right max 0 (v :: freeVarTerm L s ++ varFormula (notH L f0)))) 
 in *.
unfold evalStrongRec in |- *.
unfold evalComposeFunc, evalOneParamList, evalList in |- *.
repeat rewrite computeEvalStrongRecHelp.
unfold compose2 in |- *.
unfold evalComposeFunc, evalOneParamList, evalList in |- *.
simpl in |- *.
repeat rewrite cPairProjections1.
unfold A at 1 in |- *.
repeat first [ rewrite cPairProjections1 | rewrite cPairProjections2 ].
rewrite H with (m := codeFormula f0).
simpl in |- *.
apply cPairLe3.
apply le_n.
apply
 le_trans
  with
    (evalStrongRec 1 A (codeFormula f0)
       (max (codeTerm s)
          (pow3 (depth L f0) +
           fold_right max 0 (v :: freeVarTerm L s ++ varFormula f0)))).
auto.
apply ReplaceFormulaTermMonotone.
unfold C in |- *.
apply maxLemma.
apply le_n.
apply plus_le_compat.
apply pow3Monotone.
simpl in |- *.
apply le_n_Sn.
apply le_n.
apply cPairLt2.
set
 (C :=
  max (codeTerm s)
    (pow3 (depth L (forallH L v a)) +
     fold_right max 0 (v0 :: freeVarTerm L s ++ varFormula (forallH L v a))))
 in *.
unfold evalStrongRec in |- *.
unfold evalComposeFunc, evalOneParamList, evalList in |- *.
repeat rewrite computeEvalStrongRecHelp.
unfold compose2 in |- *.
unfold evalComposeFunc, evalOneParamList, evalList in |- *.
simpl in |- *.
repeat rewrite cPairProjections1.
unfold A at 1 in |- *.
repeat first [ rewrite cPairProjections1 | rewrite cPairProjections2 ].
rewrite H with (m := codeFormula a).
simpl in |- *.
rewrite subFormulaForall.
induction (eq_nat_dec v v0).
simpl in |- *.
apply cPairLe3.
apply le_n.
apply cPairLe3.
unfold C in |- *.
rewrite a0.
eapply le_trans; [ idtac | apply le_max_r ].
eapply le_trans; [ idtac | apply le_plus_r ].
simpl in |- *.
apply le_max_l.
apply le_trans with (codeFormula (substituteFormula L a 0 (var 0))).
rewrite (subFormulaId L).
apply le_n.
apply
 le_trans
  with
    (evalStrongRec 1 A (codeFormula a)
       (max (codeTerm (var 0))
          (pow3 (depth L a) +
           fold_right max 0 (0 :: freeVarTerm L (var 0) ++ varFormula a)))).
apply H0.
apply depthForall.
apply ReplaceFormulaTermMonotone.
unfold C in |- *.
apply maxLemma.
apply le_O_n.
apply plus_le_compat.
apply pow3Monotone.
simpl in |- *.
apply le_n_Sn.
simpl in |- *.
eapply le_trans; [ idtac | apply le_max_r ].
eapply le_trans; [ idtac | apply maxLemma3 ].
simpl in |- *.
apply le_max_r.
induction (In_dec eq_nat_dec v (freeVarTerm L s)).
simpl in |- *.
apply cPairLe3.
apply le_n.
set (nv := newVar (v0 :: freeVarTerm L s ++ freeVarFormula L a)) in *.
apply cPairLe3.
unfold C in |- *.
eapply le_trans; [ idtac | apply le_max_r ].
simpl in |- *.
apply
 le_trans
  with (1 + max v0 (fold_right max 0 (freeVarTerm L s ++ v :: varFormula a))).
simpl in |- *.
unfold nv in |- *.
unfold newVar in |- *.
eapply le_trans.
apply mapListLemma.
apply le_n_S.
simpl in |- *.
apply maxLemma.
apply le_n.
induction (maxApp (freeVarTerm L s) (freeVarFormula L a)).
rewrite a1.
apply maxLemma2.
rewrite b0.
eapply le_trans; [ idtac | apply maxLemma3 ].
simpl in |- *.
eapply le_trans; [ idtac | apply le_max_r ].
apply maxVarFreeVar.
apply plus_le_compat.
eapply le_trans; [ idtac | apply le_plus_l ].
apply pow3Min.
apply le_n.
set (B := substituteFormula L a v (fol.var L nv)) in *.
apply
 le_trans
  with
    (evalStrongRec 1 A (codeFormula B)
       (max (codeTerm s)
          (pow3 (depth L B) +
           fold_right max 0 (v0 :: freeVarTerm L s ++ varFormula B)))).
apply H0.
unfold B in |- *.
eapply eqDepth.
symmetry  in |- *.
apply subFormulaDepth.
apply depthForall.
unfold B at 1 in |- *.
rewrite ReplaceFormulaTermSub.
apply ReplaceFormulaTermMonotone.
simpl in |- *.
unfold B at 1 2 in |- *.
rewrite subFormulaDepth.
unfold C in |- *.
simpl in |- *.
apply maxLemma.
apply le_n.
rewrite plus_assoc_reverse.
apply plus_le_compat_l.
apply
 (max_case2 v0
    (fold_right max 0
       (freeVarTerm L s ++
        varFormula (substituteFormula L a v (fol.var L nv))))).
eapply le_trans; [ idtac | apply le_plus_r ].
apply le_max_l.
induction
 (maxApp (freeVarTerm L s)
    (varFormula (substituteFormula L a v (fol.var L nv)))).
rewrite a1.
eapply le_trans; [ idtac | apply le_plus_r ].
eapply le_trans; [ idtac | apply le_max_r ].
apply maxLemma2.
rewrite b0; clear b0.
clear H0 C B.
unfold nv in |- *.
clear nv.
eapply le_trans.
apply boundSubFormulaHelp1.
apply plus_le_compat.
apply le_n.
repeat apply maxLemma.
apply le_n.
apply max_case2.
apply maxLemma2.
eapply le_trans; [ idtac | apply maxLemma3 ].
simpl in |- *.
apply maxLemma.
apply le_n.
apply max_case2; apply le_n.
simpl in |- *.
apply cPairLe3.
apply le_n.
apply cPairLe3.
unfold C in |- *.
simpl in |- *.
eapply le_trans; [ idtac | apply le_max_r ].
eapply le_trans; [ idtac | apply le_plus_r ].
eapply le_trans; [ idtac | apply le_max_r ].
eapply le_trans; [ idtac | apply maxLemma3 ].
simpl in |- *.
apply le_max_l.
eapply le_trans.
apply H0.
apply depthForall.
apply ReplaceFormulaTermMonotone.
unfold C in |- *.
apply maxLemma.
apply le_n.
apply plus_le_compat.
simpl in |- *.
apply le_plus_l.
simpl in |- *.
apply maxLemma.
apply le_n.
induction (maxApp (freeVarTerm L s) (varFormula a)).
rewrite a0.
apply maxLemma2.
rewrite b1.
eapply le_trans; [ idtac | apply maxLemma3 ].

Definition boundComputation (d p1 p2 : nat) : nat :=
  nat_rec (fun _ => nat) (cTriple p1 p2 0)
    (fun _ rec : nat => cTriple p1 p2 (cPair rec rec)) d.

Lemma boundComputationIsPR : isPR 3 boundComputation.

Lemma boundComputationMonotone :
 forall a1 a2 b1 b2 c1 c2 : nat,
 a1 <= a2 ->
 b1 <= b2 ->
 c1 <= c2 -> boundComputation a1 b1 c1 <= boundComputation a2 b2 c2.

Lemma boundMakeTrace :
 forall (f : fol.Formula L) (v : nat) (s : fol.Term L),
 let C :=
   max (codeTerm s)
     (cPair 0
        (pow3 (depth L f) +
         fold_right max 0 (v :: freeVarTerm L s ++ varFormula f))) in
 makeTrace f (v, s) <=
 boundComputation (depth L f)
   (cTriple C C (ReplaceFormulaTerm (codeFormula f) C))
   (ReplaceFormulaTerm (codeFormula f) C).
Proof.
set
 (A :=
  fun f2 recs s0 : nat =>
  switchPR (cPairPi1 f2)
    (switchPR (pred (cPairPi1 f2))
       (switchPR (pred (pred (cPairPi1 f2)))
          (switchPR (pred (pred (pred (cPairPi1 f2))))
             (cPair (cPairPi1 f2) (ReplaceTermsTerm (cPairPi2 f2) s0))
             (cPair 3
                (cPair s0 (codeNth (f2 - S (cPairPi2 (cPairPi2 f2))) recs))))
          (cPair 2 (codeNth (f2 - S (cPairPi2 f2)) recs)))
       (cPair 1
          (cPair (codeNth (f2 - S (cPairPi1 (cPairPi2 f2))) recs)
             (codeNth (f2 - S (cPairPi2 (cPairPi2 f2))) recs))))
    (cPair 0
       (cPair (ReplaceTermTerm (cPairPi1 (cPairPi2 f2)) s0)
          (ReplaceTermTerm (cPairPi2 (cPairPi2 f2)) s0)))) 
 in *.
assert
 (E :
  forall (f : fol.Formula L) (v : nat) (s : fol.Term L),
  codeFormula (substituteFormula L f v s) <=
  ReplaceFormulaTerm (codeFormula f)
    (max (codeTerm s)
       (cPair 0
          (pow3 (depth L f) +
           fold_right max 0 (v :: freeVarTerm L s ++ varFormula f))))).
intros.
eapply le_trans.
apply boundSubFormulaHelp.
apply ReplaceFormulaTermMonotone.
apply maxLemma.
apply le_n.
apply cPairLe2.
assert
 (D :
  forall n m : nat,
  m < n ->
  extEqual 1
    (evalComposeFunc 1 1 (Vector.cons _ (evalStrongRecHelp 1 A n) 0 (Vector.nil _))
       (fun b : nat => codeNth (n - S m) b)) (evalStrongRec 1 A m)).
intros.
apply (evalStrongRecHelp2 1). 
assumption.
simpl in D.
intro.
assert (forall w v n s : nat, v <= max s (cPair 0 (w + max v n))).
intros.
eapply le_trans; [ idtac | apply le_max_r ].
eapply le_trans; [ idtac | apply cPairLe2 ].
eapply le_trans; [ idtac | apply le_plus_r ].
apply le_max_l.
assert
 (forall (f : fol.Formula L) (v : nat) (s : fol.Term L),
  codeFormula f <=
  ReplaceFormulaTerm (codeFormula f)
    (max (codeTerm s)
       (cPair 0
          (pow3 (depth L f) +
           fold_right max 0 (v :: freeVarTerm L s ++ varFormula f))))).
intros.
apply le_trans with (codeFormula (substituteFormula L f0 0 (var 0))).
rewrite (subFormulaId L).
apply le_n.
eapply le_trans.
apply E.
apply ReplaceFormulaTermMonotone.
apply maxLemma.
apply le_O_n.
apply cPairLe3.
apply le_n.
apply plus_le_compat.
apply le_n.
simpl in |- *.
eapply le_trans; [ idtac | apply le_max_r ].
apply maxLemma3.
elim f using Formula_depth_ind2; intros; simpl in |- *.
unfold makeTrace in |- *.
unfold Formula_depth_rec2 in |- *.
unfold Formula_depth_rec in |- *.
simpl in |- *.
unfold cTriple in |- *.
unfold C in |- *.
simpl in |- *.
repeat apply cPairLe3.
apply
 (H 1 v
    (fold_right max 0
       (freeVarTerm L s ++ freeVarTerm L t ++ freeVarTerm L t0)) 
    (codeTerm s)).
apply le_max_l.
apply (H0 (equal L t t0) v s).
apply (E (equal L t t0) v s).
apply le_n.
unfold makeTrace in |- *.
unfold Formula_depth_rec2 in |- *.
unfold Formula_depth_rec in |- *.
simpl in |- *.
unfold cTriple in |- *.
unfold C in |- *.
simpl in |- *.
repeat apply cPairLe3.
apply
 (H 1 v
    (fold_right max 0
       (freeVarTerm L s ++ freeVarTerms L (arity L (inl (Functions L) r)) t))
    (codeTerm s)).
apply le_max_l.
apply (H0 (atomic L r t) v s).
apply (E (atomic L r t) v s).
apply le_n.
replace (makeTrace (impH L f0 f1) (v, s)) with
 (cTriple (cTriple v (codeTerm s) (codeFormula (impH L f0 f1)))
    (codeFormula (substituteFormula L (impH L f0 f1) v s))
    (cPair (makeTrace f0 (v, s)) (makeTrace f1 (v, s)))).
unfold cTriple in |- *.
repeat apply cPairLe3.
unfold C in |- *; simpl in |- *. 
apply
 (H
    (pow3 (max (depth L f0) (depth L f1)) +
     (pow3 (max (depth L f0) (depth L f1)) +
      pow3 (max (depth L f0) (depth L f1)))) v
    (fold_right max 0 (freeVarTerm L s ++ varFormula f0 ++ varFormula f1))
    (codeTerm s)).
unfold C in |- *; simpl in |- *. 
apply le_max_l.
apply (H0 (impH L f0 f1) v s).
apply (E (impH L f0 f1) v s).
eapply le_trans.
apply H1.
assert
 (max (codeTerm s)
    (cPair 0
       (pow3 (depth L f0) +
        fold_right max 0 (v :: freeVarTerm L s ++ varFormula f0))) <= C).
unfold C in |- *.
apply maxLemma.
apply le_n.
apply cPairLe3.
apply le_n.
apply plus_le_compat.
apply pow3Monotone.
simpl in |- *.
apply le_S.
apply le_max_l.
simpl in |- *.
apply max_case2.
apply le_max_l.
eapply le_trans; [ idtac | apply le_max_r ].
induction (maxApp (freeVarTerm L s) (varFormula f0)).
rewrite a.
apply maxLemma2.
rewrite b.
eapply le_trans; [ idtac | apply maxLemma3 ].
apply maxLemma2.
assert
 (ReplaceFormulaTerm (codeFormula f0)
    (max (codeTerm s)
       (cPair 0
          (pow3 (depth L f0) +
           fold_right max 0 (v :: freeVarTerm L s ++ varFormula f0)))) <=
  ReplaceFormulaTerm (cPair 1 (cPair (codeFormula f0) (codeFormula f1))) C).
unfold ReplaceFormulaTerm at 2 in |- *.
fold A in |- *.
unfold evalStrongRec in |- *.
unfold evalComposeFunc, evalOneParamList, evalList in |- *.
repeat rewrite computeEvalStrongRecHelp.
unfold compose2 in |- *.
unfold evalComposeFunc, evalOneParamList, evalList in |- *.
simpl in |- *.
unfold A at 1 in |- *.
repeat first [ rewrite cPairProjections1 | rewrite cPairProjections2 ].
rewrite D with (m := codeFormula f0).
simpl in |- *.
eapply le_trans; [ idtac | apply cPairLe2 ].
eapply le_trans; [ idtac | apply cPairLe1 ].
apply ReplaceFormulaTermMonotone.
apply H3.
eapply le_lt_trans; [ idtac | apply cPairLt2 ].
apply cPairLe1.
apply boundComputationMonotone.
apply le_max_l.
unfold cTriple in |- *.
repeat apply cPairLe3.
apply H3.
apply H3.
apply H4.
apply H4.
eapply le_trans.
apply H2.
assert
 (max (codeTerm s)
    (cPair 0
       (pow3 (depth L f1) +
        fold_right max 0 (v :: freeVarTerm L s ++ varFormula f1))) <= C).
unfold C in |- *.
apply maxLemma.
apply le_n.
apply cPairLe3.
apply le_n.
apply plus_le_compat.
apply pow3Monotone.
simpl in |- *.
apply le_S.
apply le_max_r.
simpl in |- *.
apply max_case2.
apply le_max_l.
eapply le_trans; [ idtac | apply le_max_r ].
induction (maxApp (freeVarTerm L s) (varFormula f1)).
rewrite a.
apply maxLemma2.
rewrite b.
eapply le_trans; [ idtac | apply maxLemma3 ].
apply maxLemma3.
assert
 (ReplaceFormulaTerm (codeFormula f1)
    (max (codeTerm s)
       (cPair 0
          (pow3 (depth L f1) +
           fold_right max 0 (v :: freeVarTerm L s ++ varFormula f1)))) <=
  ReplaceFormulaTerm (cPair 1 (cPair (codeFormula f0) (codeFormula f1))) C).
unfold ReplaceFormulaTerm at 2 in |- *.
fold A in |- *.
unfold evalStrongRec in |- *.
unfold evalComposeFunc, evalOneParamList, evalList in |- *.
repeat rewrite computeEvalStrongRecHelp.
unfold compose2 in |- *.
unfold evalComposeFunc, evalOneParamList, evalList in |- *.
simpl in |- *.
unfold A at 1 in |- *.
repeat first [ rewrite cPairProjections1 | rewrite cPairProjections2 ].
rewrite D with (m := codeFormula f1).
simpl in |- *.
eapply le_trans; [ idtac | apply cPairLe2 ].
eapply le_trans; [ idtac | apply cPairLe2 ].
apply ReplaceFormulaTermMonotone.
apply H3.
eapply le_lt_trans; [ idtac | apply cPairLt2 ].
apply cPairLe2.
apply boundComputationMonotone.
apply le_max_r.
unfold cTriple in |- *.
repeat apply cPairLe3.
apply H3.
apply H3.
apply H4.
apply H4.
unfold makeTrace in |- *.
rewrite
 (Formula_depth_rec2_imp L)
                            with
                            (Q := 
                              fun _ : fol.Formula L =>
                              (nat * fol.Term L)%type)
                           (P := fun _ : fol.Formula L => nat).
unfold makeTraceImp at 1 in |- *.
reflexivity.
apply makeTraceImpNice.
apply makeTraceNotNice.
apply makeTraceForallNice.
replace (makeTrace (notH L f0) (v, s)) with
 (cTriple (cTriple v (codeTerm s) (codeFormula (notH L f0)))
    (codeFormula (substituteFormula L (notH L f0) v s)) 
    (makeTrace f0 (v, s))).
unfold cTriple in |- *.
repeat apply cPairLe3.
unfold C in |- *; simpl in |- *. 
apply
 (H (pow3 (depth L f0) + (pow3 (depth L f0) + pow3 (depth L f0))) v
    (fold_right max 0 (freeVarTerm L s ++ varFormula f0)) 
    (codeTerm s)).
unfold C in |- *; simpl in |- *. 
apply le_max_l.
apply (H0 (notH L f0) v s).
apply (E (notH L f0) v s).
eapply le_trans.
apply H1.
assert
 (max (codeTerm s)
    (cPair 0
       (pow3 (depth L f0) +
        fold_right max 0 (v :: freeVarTerm L s ++ varFormula f0))) <= C).
unfold C in |- *; simpl in |- *.
apply maxLemma.
apply le_n.
apply cPairLe3.
apply le_n.
apply plus_le_compat.
apply le_plus_l.
apply le_n.
assert
 (ReplaceFormulaTerm (codeFormula f0)
    (max (codeTerm s)
       (cPair 0
          (pow3 (depth L f0) +
           fold_right max 0 (v :: freeVarTerm L s ++ varFormula f0)))) <=
  ReplaceFormulaTerm (cPair 2 (codeFormula f0)) C).
unfold ReplaceFormulaTerm at 2 in |- *.
fold A in |- *.
unfold evalStrongRec in |- *.
unfold evalComposeFunc, evalOneParamList, evalList in |- *.
repeat rewrite computeEvalStrongRecHelp.
unfold compose2 in |- *.
unfold evalComposeFunc, evalOneParamList, evalList in |- *.
simpl in |- *.
unfold A at 1 in |- *.
repeat first [ rewrite cPairProjections1 | rewrite cPairProjections2 ].
rewrite D with (m := codeFormula f0).
simpl in |- *.
eapply le_trans; [ idtac | apply cPairLe2 ].
apply ReplaceFormulaTermMonotone.
apply H2.
apply cPairLt2.
eapply le_trans; [ idtac | apply cPairLe1 ].
apply boundComputationMonotone.
apply le_n.
unfold cTriple in |- *.
repeat apply cPairLe3.
apply H2.
apply H2.
apply H3.
apply H3.
unfold makeTrace in |- *.
rewrite
 (Formula_depth_rec2_not L)
                            with
                            (Q := 
                              fun _ : fol.Formula L =>
                              (nat * fol.Term L)%type)
                           (P := fun _ : fol.Formula L => nat).
unfold makeTraceNot at 1 in |- *.
reflexivity.
apply makeTraceImpNice.
apply makeTraceNotNice.
apply makeTraceForallNice.
replace (makeTrace (forallH L v a) (v0, s)) with
 (makeTraceForall v a (fun (b : fol.Formula L) _ => makeTrace b) (v0, s)).
unfold makeTraceForall in |- *.
simpl in |- *.
induction (eq_nat_dec v v0); simpl in |- *.
unfold cTriple in |- *.
repeat apply cPairLe3.
unfold C in |- *; simpl in |- *. 
apply
 (H (pow3 (depth L a) + (pow3 (depth L a) + pow3 (depth L a))) v0
    (fold_right max 0 (freeVarTerm L s ++ v :: varFormula a)) 
    (codeTerm s)).
unfold C in |- *; simpl in |- *. 
apply le_max_l.
apply (H0 (forallH L v a) v0 s).
apply (E (forallH L v a) v0 s).
apply le_O_n.
induction (In_dec eq_nat_dec v (freeVarTerm L s)); simpl in |- *.
unfold cTriple in |- *.
repeat apply cPairLe3.
unfold C in |- *; simpl in |- *. 
apply
 (H (pow3 (depth L a) + (pow3 (depth L a) + pow3 (depth L a))) v0
    (fold_right max 0 (freeVarTerm L s ++ v :: varFormula a)) 
    (codeTerm s)).
unfold C in |- *; simpl in |- *. 
apply le_max_l.
apply (H0 (forallH L v a) v0 s).
apply (E (forallH L v a) v0 s).
eapply le_trans.
apply H1.
apply depthForall.
assert
 (max (codeTerm (var (newVar (v0 :: freeVarTerm L s ++ freeVarFormula L a))))
    (cPair 0
       (pow3 (depth L a) +
        fold_right max 0
          (v
           :: freeVarTerm L
                (var (newVar (v0 :: freeVarTerm L s ++ freeVarFormula L a))) ++
              varFormula a))) <= C).
assert
 (newVar (v0 :: freeVarTerm L s ++ freeVarFormula L a) <=
  pow3 (depth L a) +
  fold_right max 0 (v0 :: freeVarTerm L s ++ varFormula (forallH L v a))).
apply
 le_trans
  with
    (1 +
     fold_right max 0
       (v0 :: fold_right max 0 (freeVarTerm L s) :: varFormula a)).
apply boundSubFormulaHelp2 with (a := a) (v0 := v0) (s := s).
apply plus_le_compat.
apply pow3Min.
simpl in |- *.
apply max_case2.
apply le_max_l.
eapply le_trans; [ idtac | apply le_max_r ].
apply max_case2.
apply maxLemma2.
eapply le_trans; [ idtac | apply maxLemma3 ].
simpl in |- *.
apply le_max_r.
apply max_case2.
replace
 (codeTerm (var (newVar (v0 :: freeVarTerm L s ++ freeVarFormula L a)))) with
 (cPair 0 (newVar (v0 :: freeVarTerm L s ++ freeVarFormula L a)));
 [ idtac | reflexivity ].
unfold C in |- *.
eapply le_trans; [ idtac | apply le_max_r ].
apply cPairLe3.
apply le_n.
eapply le_trans.
apply H2.
apply plus_le_compat_r.
simpl in |- *.
apply le_plus_l.
unfold C in |- *.
eapply le_trans; [ idtac | apply le_max_r ].
apply cPairLe3.
apply le_n.
simpl in |- *.
rewrite plus_assoc_reverse.
apply plus_le_compat_l.
apply max_case2.
eapply le_trans; [ idtac | apply le_plus_r ].
eapply le_trans; [ idtac | apply le_max_r ].
eapply le_trans; [ idtac | apply maxLemma3 ].
simpl in |- *.
apply le_max_l.
apply max_case2.
rewrite plus_assoc_reverse.
eapply le_trans; [ idtac | apply le_plus_r ].
apply H2.
eapply le_trans; [ idtac | apply le_plus_r ].
eapply le_trans; [ idtac | apply le_max_r ].
eapply le_trans; [ idtac | apply maxLemma3 ].
simpl in |- *.
apply le_max_r.
assert
 (ReplaceFormulaTerm (codeFormula a)
    (max
       (codeTerm (var (newVar (v0 :: freeVarTerm L s ++ freeVarFormula L a))))
       (cPair 0
          (pow3 (depth L a) +
           fold_right max 0
             (v
              :: freeVarTerm L
                   (var
                      (newVar (v0 :: freeVarTerm L s ++ freeVarFormula L a))) ++
                 varFormula a)))) <=
  ReplaceFormulaTerm (cPair 3 (cPair v (codeFormula a))) C).
unfold ReplaceFormulaTerm at 2 in |- *.
fold A in |- *.
unfold evalStrongRec in |- *.
unfold evalComposeFunc, evalOneParamList, evalList in |- *.
repeat rewrite computeEvalStrongRecHelp.
unfold compose2 in |- *.
unfold evalComposeFunc, evalOneParamList, evalList in |- *.
simpl in |- *.
unfold A at 1 in |- *.
repeat first [ rewrite cPairProjections1 | rewrite cPairProjections2 ].
rewrite D with (m := codeFormula a).
simpl in |- *.
eapply le_trans; [ idtac | apply cPairLe2 ].
eapply le_trans; [ idtac | apply cPairLe2 ].
apply ReplaceFormulaTermMonotone.
simpl in H2.
apply H2.
eapply le_lt_trans; [ idtac | apply cPairLt2 ].
apply cPairLe2.
apply boundComputationMonotone.
apply le_n.
unfold cTriple in |- *.
repeat apply cPairLe3.
apply H2.
apply H2.
apply H3.
apply H3.
eapply le_trans.
apply H1.
eapply eqDepth.
symmetry  in |- *.
apply subFormulaDepth.
apply depthForall.
rewrite subFormulaDepth.
assert
 (max (codeTerm s)
    (cPair 0
       (pow3 (depth L a) +
        fold_right max 0
          (v0
           :: freeVarTerm L s ++
              varFormula
                (substituteFormula L a v
                   (var
                      (newVar (v0 :: freeVarTerm L s ++ freeVarFormula L a))))))) <=
  C).
unfold C in |- *.
apply maxLemma.
apply le_n.
apply cPairLe3.
apply le_n.
simpl in |- *.
rewrite plus_assoc_reverse.
apply plus_le_compat_l.
apply max_case2.
eapply le_trans; [ idtac | apply le_plus_r ].
apply le_max_l.
induction
 (maxApp (freeVarTerm L s)
    (varFormula
       (substituteFormula L a v
          (var (newVar (v0 :: freeVarTerm L s ++ freeVarFormula L a)))))).
rewrite a1.
eapply le_trans; [ idtac | apply le_plus_r ].
eapply le_trans; [ idtac | apply le_max_r ].
apply maxLemma2.
rewrite b0.
clear b0.
eapply le_trans.
apply boundSubFormulaHelp1.
apply plus_le_compat_l.
apply maxLemma.
apply le_n.
apply max_case2.
apply maxLemma2.
eapply le_trans; [ idtac | apply maxLemma3 ].
simpl in |- *.
apply maxLemma.
apply le_n.
apply max_case2; apply le_n.
assert
 (ReplaceFormulaTerm
    (codeFormula
       (substituteFormula L a v
          (var (newVar (v0 :: freeVarTerm L s ++ freeVarFormula L a)))))
    (max (codeTerm s)
       (cPair 0
          (pow3 (depth L a) +
           fold_right max 0
             (v0
              :: freeVarTerm L s ++
                 varFormula
                   (substituteFormula L a v
                      (var
                         (newVar
                            (v0 :: freeVarTerm L s ++ freeVarFormula L a)))))))) <=
  ReplaceFormulaTerm (cPair 3 (cPair v (codeFormula a))) C).
unfold ReplaceFormulaTerm at 2 in |- *.
fold A in |- *.
unfold evalStrongRec in |- *.
unfold evalComposeFunc, evalOneParamList, evalList in |- *.
repeat rewrite computeEvalStrongRecHelp.
unfold compose2 in |- *.
unfold evalComposeFunc, evalOneParamList, evalList in |- *.
simpl in |- *.
unfold A at 1 in |- *.
repeat first [ rewrite cPairProjections1 | rewrite cPairProjections2 ].
rewrite D with (m := codeFormula a).
simpl in |- *.
eapply le_trans; [ idtac | apply cPairLe2 ].
eapply le_trans; [ idtac | apply cPairLe2 ].
rewrite ReplaceFormulaTermSub.
apply ReplaceFormulaTermMonotone.
apply H2.
eapply le_lt_trans; [ idtac | apply cPairLt2 ].
apply cPairLe2.
apply boundComputationMonotone.
apply le_n.
unfold cTriple in |- *.
repeat apply cPairLe3.
apply H2.
apply H2.
apply H3.
apply H3.
unfold cTriple in |- *.
repeat apply cPairLe3.
unfold C in |- *; simpl in |- *. 
apply
 (H (pow3 (depth L a) + (pow3 (depth L a) + pow3 (depth L a))) v0
    (fold_right max 0 (freeVarTerm L s ++ v :: varFormula a)) 
    (codeTerm s)).
unfold C in |- *; simpl in |- *. 
apply le_max_l.
apply (H0 (forallH L v a) v0 s).
apply (E (forallH L v a) v0 s).
eapply le_trans.
apply H1.
apply depthForall.
assert
 (max (codeTerm s)
    (cPair 0
       (pow3 (depth L a) +
        fold_right max 0 (v0 :: freeVarTerm L s ++ varFormula a))) <= C).
unfold C in |- *.
apply maxLemma.
apply le_n.
apply cPairLe3.
apply le_n.
apply plus_le_compat.
simpl in |- *.
apply le_plus_l.
simpl in |- *.
apply maxLemma.
apply le_n.
induction (maxApp (freeVarTerm L s) (varFormula a)).
rewrite a0.
apply maxLemma2.
rewrite b1.
eapply le_trans; [ idtac | apply maxLemma3 ].

Definition codeSubFormula (f v s : nat) : nat :=
  let C := cPair 0 (pow3 f + (v + (s + f))) in
  cPairPi1
    (boundedSearch
       (fun p x : nat =>
        ltBool 0 (checkSubFormulaTrace (cPair (cPairPi1 p) x)))
       (cPair (cTriple v s f)
          (S
             (boundComputation f (cTriple C C (ReplaceFormulaTerm f C))
                (ReplaceFormulaTerm f C))))).

Lemma codeSubFormulaCorrect :
 forall (f : Formula) (v : nat) (s : Term),
 codeSubFormula (codeFormula f) v (codeTerm s) =
 codeFormula (substituteFormula L f v s).

Lemma codeSubFormulaIsPR : isPR 3 codeSubFormula.

End Code_Substitute_Formula. *)

Require Import folProp.
(* folProp:
Require Import Wf_nat.
Require Import Max.
Require Import Arith.
Require Import Coq.Lists.List.
Require Import ListExt.
Require Import Peano_dec.

Require Export fol.

Section Fol_Properties.

Variable L : Language.

Notation Formula := (Formula L) (only parsing).
Notation Formulas := (Formulas L) (only parsing).
Notation System := (System L) (only parsing).
Notation Term := (Term L) (only parsing).
Notation Terms := (Terms L) (only parsing).
Let var := var L.
Let apply := apply L.
Let equal := equal L.
Let atomic := atomic L.
Let impH := impH L.
Let notH := notH L.
Let forallH := forallH L.
Let lt_depth := lt_depth L.

Section Free_Variables.

Fixpoint freeVarTerm (s : fol.Term L) : list nat :=
  match s with
  | fol.var v => v :: nil
  | fol.apply f ts => freeVarTerms (arity L (inr _ f)) ts
  end
 
 with freeVarTerms (n : nat) (ss : fol.Terms L n) {struct ss} : 
 list nat :=
  match ss with
  | Tnil => nil (A:=nat)
  | Tcons m t ts => freeVarTerm t ++ freeVarTerms m ts
  end.

Lemma freeVarTermApply :
 forall (f : Functions L) (ts : fol.Terms L _),

Fixpoint freeVarFormula (A : fol.Formula L) : list nat :=
  match A with
  | fol.equal t s => freeVarTerm t ++ freeVarTerm s
  | fol.atomic r ts => freeVarTerms _ ts
  | fol.impH A B => freeVarFormula A ++ freeVarFormula B
  | fol.notH A => freeVarFormula A
  | fol.forallH v A => list_remove _ eq_nat_dec v (freeVarFormula A)
  end.

Definition ClosedSystem (T : fol.System L) :=
  forall (v : nat) (f : fol.Formula L),
  mem _ T f -> ~ In v (freeVarFormula f).

Definition closeList (l : list nat) (x : fol.Formula L) : 
  fol.Formula L :=
  list_rec (fun _ => fol.Formula L) x
    (fun (a : nat) _ (rec : fol.Formula L) => forallH a rec) l.

Definition close (x : fol.Formula L) : fol.Formula L :=
  closeList (no_dup _ eq_nat_dec (freeVarFormula x)) x.

Lemma freeVarClosedList1 :
 forall (l : list nat) (v : nat) (x : fol.Formula L),

Lemma freeVarClosedList2 :
 forall (l : list nat) (v : nat) (x : fol.Formula L),

Lemma freeVarClosed :
 forall (x : fol.Formula L) (v : nat), ~ In v (freeVarFormula (close x)).

Fixpoint freeVarListFormula (l : fol.Formulas L) : 
 list nat :=
  match l with
  | nil => nil (A:=nat)
  | f :: l => freeVarFormula f ++ freeVarListFormula l
  end.

Lemma freeVarListFormulaApp :
 forall a b : fol.Formulas L,

Lemma In_freeVarListFormula :
 forall (v : nat) (f : fol.Formula L) (F : fol.Formulas L),

Lemma In_freeVarListFormulaE :
 forall (v : nat) (F : fol.Formulas L),

Definition In_freeVarSys (v : nat) (T : fol.System L) :=
  exists f : fol.Formula L, In v (freeVarFormula f) /\ mem _ T f.

Lemma notInFreeVarSys :
 forall x, ~ In_freeVarSys x (Ensembles.Empty_set (fol.Formula L)).

End Free_Variables.

Section Substitution.

Fixpoint substituteTerm (s : fol.Term L) (x : nat) 
 (t : fol.Term L) {struct s} : fol.Term L :=
  match s with
  | fol.var v =>
      match eq_nat_dec x v with
      | left _ => t
      | right _ => var v
      end
  | fol.apply f ts => apply f (substituteTerms _ ts x t)
  end
 
 with substituteTerms (n : nat) (ss : fol.Terms L n) 
 (x : nat) (t : fol.Term L) {struct ss} : fol.Terms L n :=
  match ss in (fol.Terms _ n0) return (fol.Terms L n0) with
  | Tnil => Tnil L
  | Tcons m s ts =>
      Tcons L m (substituteTerm s x t) (substituteTerms m ts x t)
  end.

Lemma subTermVar1 :
 forall (v : nat) (s : fol.Term L), substituteTerm (var v) v s = s.

Lemma subTermVar2 :
 forall (v x : nat) (s : fol.Term L),

Lemma subTermFunction :
 forall (f : Functions L) (ts : fol.Terms L (arity L (inr _ f))) 

Definition newVar (l : list nat) : nat := fold_right max 0 (map S l).

Lemma newVar2 : forall (l : list nat) (n : nat), In n l -> n < newVar l.

Lemma newVar1 : forall l : list nat, ~ In (newVar l) l.

Definition substituteFormulaImp (f : fol.Formula L)
  (frec : nat * fol.Term L -> {y : fol.Formula L | depth L y = depth L f})
  (g : fol.Formula L)
  (grec : nat * fol.Term L -> {y : fol.Formula L | depth L y = depth L g})
  (p : nat * fol.Term L) :
  {y : fol.Formula L | depth L y = depth L (impH f g)} :=
  match frec p with
  | exist f' prf1 =>
      match grec p with
      | exist g' prf2 =>
          exist
            (fun y : fol.Formula L =>
             depth L y = S (max (depth L f) (depth L g))) 
            (impH f' g')
            (eq_ind_r
               (fun n : nat =>
                S (max n (depth L g')) = S (max (depth L f) (depth L g)))
               (eq_ind_r
                  (fun n : nat =>
                   S (max (depth L f) n) = S (max (depth L f) (depth L g)))
                  (refl_equal (S (max (depth L f) (depth L g)))) prf2) prf1)
      end
  end.

Remark substituteFormulaImpNice :
 forall (f g : fol.Formula L)

Definition substituteFormulaNot (f : fol.Formula L)
  (frec : nat * fol.Term L -> {y : fol.Formula L | depth L y = depth L f})
  (p : nat * fol.Term L) :
  {y : fol.Formula L | depth L y = depth L (notH f)} :=
  match frec p with
  | exist f' prf1 =>
      exist (fun y : fol.Formula L => depth L y = S (depth L f)) 
        (notH f')
        (eq_ind_r (fun n : nat => S n = S (depth L f))
           (refl_equal (S (depth L f))) prf1)
  end.

Remark substituteFormulaNotNice :
 forall (f : fol.Formula L)

Definition substituteFormulaForall (n : nat) (f : fol.Formula L)
  (frec : forall b : fol.Formula L,
          lt_depth b (forallH n f) ->
          nat * fol.Term L -> {y : fol.Formula L | depth L y = depth L b})
  (p : nat * fol.Term L) :
  {y : fol.Formula L | depth L y = depth L (forallH n f)} :=
  match p with
  | (v, s) =>
      match eq_nat_dec n v with
      | left _ =>
          exist (fun y : fol.Formula L => depth L y = S (depth L f))
            (forallH n f) (refl_equal (depth L (forallH n f)))
      | right _ =>
          match In_dec eq_nat_dec n (freeVarTerm s) with
          | left _ =>
              let nv := newVar (v :: freeVarTerm s ++ freeVarFormula f) in
              match frec f (depthForall L f n) (n, var nv) with
              | exist f' prf1 =>
                  match
                    frec f'
                      (eqDepth L f' f (forallH n f) 
                         (sym_eq prf1) (depthForall L f n)) p
                  with
                  | exist f'' prf2 =>
                      exist
                        (fun y : fol.Formula L => depth L y = S (depth L f))
                        (forallH nv f'')
                        (eq_ind_r (fun n : nat => S n = S (depth L f))
                           (refl_equal (S (depth L f))) 
                           (trans_eq prf2 prf1))
                  end
              end
          | right _ =>
              match frec f (depthForall L f n) p with
              | exist f' prf1 =>
                  exist (fun y : fol.Formula L => depth L y = S (depth L f))
                    (forallH n f')
                    (eq_ind_r (fun n : nat => S n = S (depth L f))
                       (refl_equal (S (depth L f))) prf1)
              end
          end
      end
  end.

Remark substituteFormulaForallNice :
 forall (v : nat) (a : fol.Formula L)

Definition substituteFormulaHelp (f : fol.Formula L) 

Definition substituteFormula (f : fol.Formula L) (v : nat) 
  (s : fol.Term L) : fol.Formula L := proj1_sig (substituteFormulaHelp f v s).

Lemma subFormulaEqual :
 forall (t1 t2 : fol.Term L) (v : nat) (s : fol.Term L),

Lemma subFormulaRelation :
 forall (r : Relations L) (ts : fol.Terms L (arity L (inl _ r))) 

Lemma subFormulaImp :
 forall (f1 f2 : fol.Formula L) (v : nat) (s : fol.Term L),

Lemma subFormulaNot :
 forall (f : fol.Formula L) (v : nat) (s : fol.Term L),

Lemma subFormulaForall :
 forall (f : fol.Formula L) (x v : nat) (s : fol.Term L),

Section Extensions.

Let orH := orH L.
Let andH := andH L.
Let existH := existH L.
Let iffH := iffH L.
Let ifThenElseH := ifThenElseH L.

Lemma subFormulaOr :
 forall (f1 f2 : fol.Formula L) (v : nat) (s : fol.Term L),

Lemma subFormulaAnd :
 forall (f1 f2 : fol.Formula L) (v : nat) (s : fol.Term L),

Lemma subFormulaExist :
 forall (f : fol.Formula L) (x v : nat) (s : fol.Term L),

Lemma subFormulaIff :
 forall (f1 f2 : fol.Formula L) (v : nat) (s : fol.Term L),

Lemma subFormulaIfThenElse :
 forall (f1 f2 f3 : fol.Formula L) (v : nat) (s : fol.Term L),

End Extensions.

Lemma subFormulaDepth :
 forall (f : fol.Formula L) (v : nat) (s : fol.Term L),

Section Substitution_Properties.

Lemma subTermId :
 forall (t : fol.Term L) (v : nat), substituteTerm t v (var v) = t.

Lemma subTermsId :
 forall (n : nat) (ts : fol.Terms L n) (v : nat),

Lemma subFormulaId :
 forall (f : fol.Formula L) (v : nat), substituteFormula f v (var v) = f.

Lemma subFormulaForall2 :
 forall (f : fol.Formula L) (x v : nat) (s : fol.Term L),

Let existH := existH L.

Lemma subFormulaExist2 :
 forall (f : fol.Formula L) (x v : nat) (s : fol.Term L),

End Substitution_Properties.

End Substitution.
 
Definition Sentence (f:Formula) := (forall v : nat, ~ In v (freeVarFormula f)).

End Fol_Properties. *)

Require Import folProof.
(* folProof:
Require Import Ensembles.
Require Import Coq.Lists.List.
Require Import Arith.

Require Export fol.
Require Import folProp.

Section ProofH.

Variable L : Language.

Let Formula := Formula L.
Let Formulas := Formulas L.
Let System := System L.
Let Term := Term L.
Let Terms := Terms L.
Let var := var L.
Let apply := apply L.
Let equal := equal L.
Let atomic := atomic L.
Let impH := impH L.
Let notH := notH L.
Let iffH := iffH L.
Let forallH := forallH L.

Definition nVars (n : nat) : Terms n * Terms n.

Definition AxmEq4 (R : Relations L) : Formula.

Definition AxmEq5 (f : Functions L) : Formula.

Inductive Prf : Formulas -> Formula -> Set :=
  | AXM : forall A : Formula, Prf (A :: nil) A
  | MP :
      forall (Axm1 Axm2 : Formulas) (A B : Formula),
      Prf Axm1 (impH A B) -> Prf Axm2 A -> Prf (Axm1 ++ Axm2) B
  | GEN :
      forall (Axm : Formulas) (A : Formula) (v : nat),
      ~ In v (freeVarListFormula L Axm) -> Prf Axm A -> Prf Axm (forallH v A)
  | IMP1 : forall A B : Formula, Prf nil (impH A (impH B A))
  | IMP2 :
      forall A B C : Formula,
      Prf nil (impH (impH A (impH B C)) (impH (impH A B) (impH A C)))
  | CP :
      forall A B : Formula,
      Prf nil (impH (impH (notH A) (notH B)) (impH B A))
  | FA1 :
      forall (A : Formula) (v : nat) (t : Term),
      Prf nil (impH (forallH v A) (substituteFormula L A v t))
  | FA2 :
      forall (A : Formula) (v : nat),
      ~ In v (freeVarFormula L A) -> Prf nil (impH A (forallH v A))
  | FA3 :
      forall (A B : Formula) (v : nat),
      Prf nil
        (impH (forallH v (impH A B)) (impH (forallH v A) (forallH v B)))
  | EQ1 : Prf nil (equal (var 0) (var 0))
  | EQ2 : Prf nil (impH (equal (var 0) (var 1)) (equal (var 1) (var 0)))
  | EQ3 :
      Prf nil
        (impH (equal (var 0) (var 1))
           (impH (equal (var 1) (var 2)) (equal (var 0) (var 2))))
  | EQ4 : forall R : Relations L, Prf nil (AxmEq4 R)
  | EQ5 : forall f : Functions L, Prf nil (AxmEq5 f).

Definition SysPrf (T : System) (f : Formula) :=
  exists Axm : Formulas,
    (exists prf : Prf Axm f,
       (forall g : Formula, In g Axm -> mem _ T g)).

Definition Inconsistent (T : System) := forall f : Formula, SysPrf T f.

Definition Consistent (T : System) := exists f : Formula, ~ SysPrf T f.

End ProofH. *)

Require Import Languages.
(* Languages:
Require Import Arith.
Require Import fol.
Require Import primRec.
Require Import Coq.Lists.List.

Inductive LNTFunction : Set :=
  | Plus : LNTFunction
  | Times : LNTFunction
  | Succ : LNTFunction
  | Zero : LNTFunction.

Inductive LNNRelation : Set :=
    LT : LNNRelation.

Definition LNTFunctionArity (x : LNTFunction) : nat :=
  match x with
  | Plus => 2
  | Times => 2
  | Succ => 1
  | Zero => 0
  end.

Definition LNTArity (x : Empty_set + LNTFunction) : nat :=
  match x return nat with
  | inl bot => Empty_set_rec (fun _ => nat) bot
  | inr y => LNTFunctionArity y
  end.

Definition LNNArity (x : LNNRelation + LNTFunction) : nat :=
  match x return nat with
  | inl y => match y with
             | LT => 2
             end
  | inr y => LNTFunctionArity y
  end.

Definition LNT : Language := language Empty_set LNTFunction LNTArity.

Definition LNN : Language := language LNNRelation LNTFunction LNNArity.

Definition codeLNTFunction (f : LNTFunction) : nat :=
  match f with
  | Plus => 0
  | Times => 1
  | Succ => 2
  | Zero => 3
  end.

Definition codeLNTRelation (R : Empty_set) : nat :=
  match R return nat with
  end.

Definition codeLNNRelation (R : LNNRelation) : nat := 0.

Lemma codeLNTFunctionInj :
 forall f g : LNTFunction, codeLNTFunction f = codeLNTFunction g -> f = g.

Lemma codeLNTRelationInj :
 forall R S : Empty_set, codeLNTRelation R = codeLNTRelation S -> R = S.

Lemma codeLNNRelationInj :
 forall R S : LNNRelation, codeLNNRelation R = codeLNNRelation S -> R = S.

Definition codeArityLNNR (r : nat) := switchPR r 0 3.

Lemma codeArityLNNRIsPR : isPR 1 codeArityLNNR.

Lemma codeArityLNNRIsCorrect1 :
 forall r : Relations LNN,
 codeArityLNNR (codeLNNRelation r) = S (arity LNN (inl _ r)).

Lemma codeArityLNNRIsCorrect2 :
 forall n : nat,
 codeArityLNNR n <> 0 -> exists r : Relations LNN, codeLNNRelation r = n.

Definition codeArityLNTR (r : nat) := 0.

Lemma codeArityLNTRIsPR : isPR 1 codeArityLNTR.

Lemma codeArityLNTRIsCorrect1 :
 forall r : Relations LNT,
 codeArityLNTR (codeLNTRelation r) = S (arity LNT (inl _ r)).

Lemma codeArityLNTRIsCorrect2 :
 forall n : nat,
 codeArityLNTR n <> 0 -> exists r : Relations LNT, codeLNTRelation r = n.

Definition codeArityLNTF (f : nat) :=
  switchPR f
    (switchPR (pred f)
       (switchPR (pred (pred f)) (switchPR (pred (pred (pred f))) 0 1) 2) 3)
    3.

Lemma codeArityLNTFIsPR : isPR 1 codeArityLNTF.

Lemma codeArityLNTFIsCorrect1 :
 forall f : Functions LNT,
 codeArityLNTF (codeLNTFunction f) = S (arity LNT (inr _ f)).

Lemma codeArityLNNFIsCorrect1 :
 forall f : Functions LNN,
 codeArityLNTF (codeLNTFunction f) = S (arity LNN (inr _ f)).

Lemma codeArityLNTFIsCorrect2 :
 forall n : nat,
 codeArityLNTF n <> 0 -> exists f : Functions LNT, codeLNTFunction f = n.

Lemma codeArityLNNFIsCorrect2 :
 forall n : nat,
 codeArityLNTF n <> 0 -> exists f : Functions LNN, codeLNTFunction f = n. *)

Require Import subAll.
(* subAll:
Require Import Ensembles.
Require Import Coq.Lists.List.
Require Import Arith.
Require Import Peano_dec.
Require Import ListExt.
Require Import Max.

Require Import folProof.
Require Import folLogic2.
Require Import folProp.
Require Import folReplace.
Require Import subProp.

Section SubAllVars.

Variable L : Language.
Notation Formula := (Formula L) (only parsing).
Notation Formulas := (Formulas L) (only parsing).
Notation System := (System L) (only parsing).
Notation Term := (Term L) (only parsing).
Notation Terms := (Terms L) (only parsing).
Notation var := (var L) (only parsing).
Notation apply := (apply L) (only parsing).
Notation equal := (equal L) (only parsing).
Notation atomic := (atomic L) (only parsing).
Notation impH := (impH L) (only parsing).
Notation notH := (notH L) (only parsing).
Notation forallH := (forallH L) (only parsing).
Notation iffH := (iffH L) (only parsing).
Notation SysPrf := (SysPrf L) (only parsing).

Fixpoint subAllTerm (t : fol.Term L) : (nat -> fol.Term L) -> fol.Term L :=
  match t return ((nat -> fol.Term L) -> fol.Term L) with
  | fol.var x => fun m => m x
  | fol.apply f ts => fun m => fol.apply L f (subAllTerms _ ts m)
  end
 
 with subAllTerms (n : nat) (ts : fol.Terms L n) {struct ts} :
 (nat -> fol.Term L) -> fol.Terms L n :=
  match
    ts in (fol.Terms _ n) return ((nat -> fol.Term L) -> fol.Terms L n)
  with
  | Tnil => fun _ => Tnil L
  | Tcons n' t ss =>
      fun m => Tcons L n' (subAllTerm t m) (subAllTerms _ ss m)
  end.

Lemma subAllTerm_ext :
 forall (t : fol.Term L) (m1 m2 : nat -> fol.Term L),

Lemma subAllTerms_ext :
 forall (n : nat) (ts : fol.Terms L n) (m1 m2 : nat -> fol.Term L),

Fixpoint freeVarMap (l : list nat) : (nat -> fol.Term L) -> list nat :=
  match l with
  | nil => fun _ => nil
  | a :: l' => fun m => freeVarTerm L (m a) ++ freeVarMap l' m
  end.

Lemma freeVarMap_ext :
 forall (l : list nat) (f1 f2 : nat -> fol.Term L),

Lemma freeVarMap1 :
 forall (l : list nat) (m : nat -> fol.Term L) (v n : nat),

Fixpoint subAllFormula (f : Formula) (m : (nat -> Term)) {struct f} : Formula :=
  match f with
  | fol.equal t s => equal (subAllTerm t m) (subAllTerm s m)
  | fol.atomic r ts => atomic r (subAllTerms _ ts m)
  | fol.impH f g =>
      impH (subAllFormula f m) (subAllFormula g m)
  | fol.notH f => notH (subAllFormula f m)
  | fol.forallH n f =>
      let nv :=
        newVar
          (freeVarFormula L f ++
           freeVarMap (freeVarFormula L (forallH n f)) m) in
      forallH nv
        (subAllFormula f
           (fun v : nat =>
            match eq_nat_dec v n with
            | left _ => var nv
            | right _ => m v
            end))
  end.

Lemma subAllFormula_ext :
 forall (f : fol.Formula L) (m1 m2 : nat -> fol.Term L),

Lemma freeVarSubAllTerm1 :
 forall (t : fol.Term L) (m : nat -> fol.Term L) (v : nat),

Lemma freeVarSubAllTerms1 :
 forall (n : nat) (ts : fol.Terms L n) (m : nat -> fol.Term L) (v : nat),

Lemma freeVarSubAllTerm2 :
 forall (t : fol.Term L) (m : nat -> fol.Term L) (v n : nat),

Lemma freeVarSubAllTerms2 :
 forall (a : nat) (ts : fol.Terms L a) (m : nat -> fol.Term L) (v n : nat),

Lemma freeVarSubAllFormula1 :
 forall (f : fol.Formula L) (m : nat -> fol.Term L) (v : nat),

Lemma freeVarSubAllFormula2 :
 forall (f : fol.Formula L) (m : nat -> fol.Term L) (v n : nat),

Lemma subSubAllTerm :
 forall (t : fol.Term L) (m : nat -> fol.Term L) (v : nat) (s : fol.Term L),

Lemma subSubAllTerms :
 forall (n : nat) (ts : fol.Terms L n) (m : nat -> fol.Term L) 

Lemma subSubAllFormula :
 forall (T : fol.System L) (f : fol.Formula L) (m : nat -> fol.Term L)

Lemma subAllTermId :
 forall t : fol.Term L, subAllTerm t (fun x : nat => fol.var L x) = t.

Lemma subAllTermsId :
 forall (n : nat) (ts : fol.Terms L n),

Lemma subAllFormulaId :
 forall (T : fol.System L) (f : fol.Formula L),

Lemma subAllSubAllTerm :
 forall (t : fol.Term L) (m1 m2 : nat -> fol.Term L),

Lemma subAllSubAllTerms :
 forall (n : nat) (ts : fol.Terms L n) (m1 m2 : nat -> fol.Term L),

Lemma subAllSubAllFormula :
 forall (T : fol.System L) (f : fol.Formula L) (m1 m2 : nat -> fol.Term L),

Section subAllCloseFrom.

Fixpoint closeFrom (a n : nat) (f : fol.Formula L) {struct n} :
 fol.Formula L :=
  match n with
  | O => f
  | S m => fol.forallH L (a + m) (closeFrom a m f)
  end.

Opaque le_lt_dec.

Lemma liftCloseFrom :
 forall (n : nat) (f : fol.Formula L) (T : fol.System L) (m : nat),

Lemma subAllCloseFrom1 :
 forall (n m : nat) (map : nat -> fol.Term L) (f : fol.Formula L)

Lemma subAllCloseFrom :
 forall (n : nat) (m : nat -> fol.Term L) (f : fol.Formula L)

Lemma reduceSubAll :
 forall (T : fol.System L) (map : nat -> fol.Term L) (A B : fol.Formula L),

End subAllCloseFrom.

Lemma subToSubAll :
 forall (T : fol.System L) (A : fol.Formula L) (v : nat) (s : fol.Term L),

Lemma subAllSubFormula :
 forall (T : fol.System L) (A : fol.Formula L) (v : nat) 

End SubAllVars. *)

Require Import subProp.
(* subProp:
Require Import Ensembles.
Require Import Coq.Lists.List.
Require Import Peano_dec.
Require Import ListExt.
Require Import Arith.

Require Import folProof.
Require Import folLogic.
Require Import folProp.
Require Import folReplace.

Section Substitution_Properties.

Variable L : Language.
Let Formula := Formula L.
Let Formulas := Formulas L.
Let System := System L.
Let Term := Term L.
Let Terms := Terms L.
Let var := var L.
Let apply := apply L.
Let equal := equal L.
Let atomic := atomic L.
Let impH := impH L.
Let notH := notH L.
Let forallH := forallH L.
Let orH := orH L.
Let andH := andH L.
Let existH := existH L.
Let iffH := iffH L.
Let SysPrf := SysPrf L.

Lemma freeVarSubTerm1 :
 forall (t : Term) (v : nat) (s : Term) (x : nat),
 In x (freeVarTerm L t) ->
 v <> x -> In x (freeVarTerm L (substituteTerm L t v s)).

Lemma freeVarSubTerms1 :
 forall (n : nat) (ts : Terms n) (v : nat) (s : Term) (x : nat),
 In x (freeVarTerms L n ts) ->
 v <> x -> In x (freeVarTerms L n (substituteTerms L n ts v s)).

Lemma freeVarSubFormula1 :
 forall (f : Formula) (v : nat) (s : Term) (x : nat),
 v <> x ->
 In x (freeVarFormula L f) ->
 In x (freeVarFormula L (substituteFormula L f v s)).

Lemma freeVarSubTerm2 :
 forall (t : Term) (v : nat) (s : Term) (x : nat),
 In x (freeVarTerm L s) ->
 In v (freeVarTerm L t) -> In x (freeVarTerm L (substituteTerm L t v s)).

Lemma freeVarSubTerms2 :
 forall (n : nat) (ts : Terms n) (v : nat) (s : Term) (x : nat),
 In x (freeVarTerm L s) ->
 In v (freeVarTerms L n ts) ->
 In x (freeVarTerms L n (substituteTerms L n ts v s)).

Lemma freeVarSubFormula2 :
 forall (f : Formula) (v : nat) (s : Term) (x : nat),
 In x (freeVarTerm L s) ->
 In v (freeVarFormula L f) ->
 In x (freeVarFormula L (substituteFormula L f v s)).

Lemma freeVarSubTerm3 :
 forall (t : Term) (v : nat) (s : Term) (x : nat),
 In x (freeVarTerm L (substituteTerm L t v s)) ->
 In x (list_remove _ eq_nat_dec v (freeVarTerm L t)) \/
 In x (freeVarTerm L s).

Lemma freeVarSubTerms3 :
 forall (n : nat) (ts : fol.Terms L n) (v : nat) (s : Term) (x : nat),

Lemma freeVarSubFormula3 :
 forall (f : Formula) (v : nat) (s : Term) (x : nat),
 In x (freeVarFormula L (substituteFormula L f v s)) ->
 In x (list_remove _ eq_nat_dec v (freeVarFormula L f)) \/
 In x (freeVarTerm L s).

Lemma freeVarSubTerm4 :
 forall (t : Term) (v : nat) (s : Term) (x : nat),
 In x (freeVarTerm L (substituteTerm L t v s)) ->
 ~ In v (freeVarTerm L t) -> In x (freeVarTerm L t).

Lemma freeVarSubTerms4 :
 forall (n : nat) (ts : Terms n) (v : nat) (s : Term) (x : nat),
 In x (freeVarTerms L n (substituteTerms L n ts v s)) ->
 ~ In v (freeVarTerms L n ts) -> In x (freeVarTerms L n ts).

Lemma freeVarSubFormula4 :
 forall (f : Formula) (v : nat) (s : Term) (x : nat),
 In x (freeVarFormula L (substituteFormula L f v s)) ->
 ~ In v (freeVarFormula L f) -> In x (freeVarFormula L f).

Lemma subTermNil :
 forall (t : Term) (v : nat) (s : Term),
 ~ In v (freeVarTerm L t) -> substituteTerm L t v s = t.

Lemma subTermTrans :
 forall (t : Term) (v1 v2 : nat) (s : Term),
 ~ In v2 (list_remove _ eq_nat_dec v1 (freeVarTerm L t)) ->
 substituteTerm L (substituteTerm L t v1 (var v2)) v2 s =
 substituteTerm L t v1 s.

Lemma subTermExch :
 forall (t : Term) (v1 v2 : nat) (s1 s2 : Term),
 v1 <> v2 ->
 ~ In v2 (freeVarTerm L s1) ->
 ~ In v1 (freeVarTerm L s2) ->
 substituteTerm L (substituteTerm L t v1 s1) v2 s2 =
 substituteTerm L (substituteTerm L t v2 s2) v1 s1.

Lemma subTermsNil :
 forall (n : nat) (ts : Terms n) (v : nat) (s : Term),
 ~ In v (freeVarTerms L n ts) -> substituteTerms L n ts v s = ts.

Lemma subTermsTrans :
 forall (n : nat) (ts : Terms n) (v1 v2 : nat) (s : Term),
 ~ In v2 (list_remove _ eq_nat_dec v1 (freeVarTerms L n ts)) ->
 substituteTerms L n (substituteTerms L n ts v1 (var v2)) v2 s =
 substituteTerms L n ts v1 s.

Lemma subTermsExch :
 forall (n : nat) (ts : Terms n) (v1 v2 : nat) (s1 s2 : Term),
 v1 <> v2 ->
 ~ In v2 (freeVarTerm L s1) ->
 ~ In v1 (freeVarTerm L s2) ->
 substituteTerms L n (substituteTerms L n ts v1 s1) v2 s2 =
 substituteTerms L n (substituteTerms L n ts v2 s2) v1 s1.

Remark subFormulaNTEHelp :
 forall (f g : Formula) (v : nat) (s : Term),
 SysPrf (Ensembles.Add _ (Empty_set Formula) f) g ->

Remark subFormulaNTE :
 forall (f : Formula) (T : System),
 (forall (v : nat) (s : Term),
  ~ In v (freeVarFormula L f) ->
  SysPrf T (iffH (substituteFormula L f v s) f)) /\
 (forall (v1 v2 : nat) (s : Term),
  ~ In v2 (list_remove _ eq_nat_dec v1 (freeVarFormula L f)) ->
  SysPrf T
    (iffH (substituteFormula L (substituteFormula L f v1 (var v2)) v2 s)
       (substituteFormula L f v1 s))) /\
 (forall (v1 v2 : nat) (s1 s2 : Term),
  v1 <> v2 ->
  ~ In v2 (freeVarTerm L s1) ->
  ~ In v1 (freeVarTerm L s2) ->
  SysPrf T
    (iffH (substituteFormula L (substituteFormula L f v1 s1) v2 s2)
       (substituteFormula L (substituteFormula L f v2 s2) v1 s1))).

Lemma subFormulaNil :
 forall (f : Formula) (T : System) (v : nat) (s : Term),
 ~ In v (freeVarFormula L f) -> SysPrf T (iffH (substituteFormula L f v s) f).

Lemma subFormulaTrans :
 forall (f : Formula) (T : System) (v1 v2 : nat) (s : Term),
 ~ In v2 (list_remove _ eq_nat_dec v1 (freeVarFormula L f)) ->
 SysPrf T
   (iffH (substituteFormula L (substituteFormula L f v1 (var v2)) v2 s)
      (substituteFormula L f v1 s)).

Lemma subFormulaExch :
 forall (f : Formula) (T : System) (v1 v2 : nat) (s1 s2 : Term),
 v1 <> v2 ->
 ~ In v2 (freeVarTerm L s1) ->
 ~ In v1 (freeVarTerm L s2) ->
 SysPrf T
   (iffH (substituteFormula L (substituteFormula L f v1 s1) v2 s2)
      (substituteFormula L (substituteFormula L f v2 s2) v1 s1)).

End Substitution_Properties. *)

Require Import folLogic3.
(* folLogic3:
Require Import Ensembles.
Require Import Coq.Lists.List.
Require Import ListExt.

Require Import folProp.
Require Import folProof.
Require Export folLogic2.
Require Import subProp.
Require Import folReplace.
Require Import Arith.
Require Import subAll.
Require Import misc.

Unset Standard Proposition Elimination Names.

Section Equality_Logic_Rules.

Variable L : Language.
Notation Formula := (Formula L) (only parsing).
Notation Formulas := (Formulas L) (only parsing).
Notation System := (System L) (only parsing).
Notation Term := (Term L) (only parsing).
Notation Terms := (Terms L) (only parsing).
Let var := var L.
Let apply := apply L.
Let equal := equal L.
Let atomic := atomic L.
Let impH := impH L.
Let notH := notH L.
Let forallH := forallH L.
Let orH := orH L.
Let andH := andH L.
Let existH := existH L.
Let iffH := iffH L.
Let ifThenElseH := ifThenElseH L.
Let Prf := Prf L.
Let SysPrf := SysPrf L.

Lemma eqRefl :
 forall (T : fol.System L) (a : fol.Term L), SysPrf T (equal a a).

Lemma eqSym :
 forall (T : fol.System L) (a b : fol.Term L),

Lemma eqTrans :
 forall (T : fol.System L) (a b c : fol.Term L),

Fixpoint PairwiseEqual (T : fol.System L) (n : nat) {struct n} :
 fol.Terms L n -> fol.Terms L n -> Prop :=
  match n return (fol.Terms L n -> fol.Terms L n -> Prop) with
  | O => fun ts ss : fol.Terms L 0 => True
  | S x =>
      fun ts ss : fol.Terms L (S x) =>
      let (a, b) := proj1_sig (consTerms L x ts) in
      let (c, d) := proj1_sig (consTerms L x ss) in
      SysPrf T (equal a c) /\ PairwiseEqual T x b d
  end.

Let termsMap (m : nat) (ts ss : fol.Terms L m) : nat -> fol.Term L.

Remark subAllnVars1 :
 forall (a : nat) (ts ss : fol.Terms L a),

Remark subAllnVars2 :
 forall (a : nat) (ts ss : fol.Terms L a),

Remark addPairwiseEquals :
 forall (T : fol.System L) (n : nat) (ts ss : fol.Terms L n),

Lemma equalRelation :
 forall (T : fol.System L) (r : Relations L) (ts ss : fol.Terms L _),

Lemma equalFunction :
 forall (T : fol.System L) (f : Functions L) (ts ss : fol.Terms L _),

Lemma subWithEqualsTerm :
 forall (a b t : fol.Term L) (v : nat) (T : fol.System L),

Lemma subWithEqualsTerms :
 forall (a b : fol.Term L) (n : nat) (ts : fol.Terms L n) 

Lemma subWithEquals :
 forall (f : fol.Formula L) (v : nat) (a b : fol.Term L) (T : fol.System L),

End Equality_Logic_Rules. *)

Require Import folReplace.
(* folReplace:
Require Import Ensembles.
Require Import Coq.Lists.List.
Require Import Peano_dec.

Require Import ListExt.
Require Import folProof.
Require Import folLogic.
Require Import folProp.

Section Replacement.

Variable L : Language.
Let Formula := Formula L.
Let Formulas := Formulas L.
Let System := System L.
Let Term := Term L.
Let Terms := Terms L.
Let var := var L.
Let apply := apply L.
Let equal := equal L.
Let atomic := atomic L.
Let impH := impH L.
Let notH := notH L.
Let forallH := forallH L.
Let orH := orH L.
Let andH := andH L.
Let existH := existH L.
Let iffH := iffH L.
Let ifThenElseH := ifThenElseH L.
Let SysPrf := SysPrf L.

Lemma reduceImp :
 forall (f1 f2 f3 f4 : Formula) (T : System),
 SysPrf T (iffH f1 f3) ->
 SysPrf T (iffH f2 f4) -> SysPrf T (iffH (impH f1 f2) (impH f3 f4)).

Lemma reduceNot :
 forall (f1 f2 : Formula) (T : System),
 SysPrf T (iffH f1 f2) -> SysPrf T (iffH (notH f1) (notH f2)).

Lemma impForall :
 forall (f1 f2 : Formula) (v : nat) (T : System),
 ~ In_freeVarSys _ v T ->
 SysPrf T (impH f1 f2) -> SysPrf T (impH (forallH v f1) (forallH v f2)).

Lemma reduceForall :
 forall (f1 f2 : Formula) (v : nat) (T : System),
 ~ In_freeVarSys _ v T ->
 SysPrf T (iffH f1 f2) -> SysPrf T (iffH (forallH v f1) (forallH v f2)).

Lemma reduceOr :
 forall (f1 f2 f3 f4 : Formula) (T : System),
 SysPrf T (iffH f1 f3) ->
 SysPrf T (iffH f2 f4) -> SysPrf T (iffH (orH f1 f2) (orH f3 f4)).

Lemma reduceAnd :
 forall (f1 f2 f3 f4 : Formula) (T : System),
 SysPrf T (iffH f1 f3) ->
 SysPrf T (iffH f2 f4) -> SysPrf T (iffH (andH f1 f2) (andH f3 f4)).

Lemma iffExist :
 forall (f1 f2 : Formula) (v : nat) (T : System),
 ~ In_freeVarSys _ v T ->
 SysPrf T (impH f1 f2) -> SysPrf T (impH (existH v f1) (existH v f2)).

Lemma reduceExist :
 forall (f1 f2 : Formula) (v : nat) (T : System),
 ~ In_freeVarSys _ v T ->
 SysPrf T (iffH f1 f2) -> SysPrf T (iffH (existH v f1) (existH v f2)).

Lemma reduceIff :
 forall (f1 f2 f3 f4 : Formula) (T : System),
 SysPrf T (iffH f1 f3) ->
 SysPrf T (iffH f2 f4) -> SysPrf T (iffH (iffH f1 f2) (iffH f3 f4)).

Lemma reduceIfThenElse :
 forall (f1 f2 f3 f4 f5 f6 : Formula) (T : System),
 SysPrf T (iffH f1 f4) ->
 SysPrf T (iffH f2 f5) ->
 SysPrf T (iffH f3 f6) ->
 SysPrf T (iffH (ifThenElseH f1 f2 f3) (ifThenElseH f4 f5 f6)).

Lemma reduceSub :
 forall (T : System) (v : nat) (s : Term) (f g : Formula),
 ~ In_freeVarSys L v T ->
 SysPrf T (iffH f g) ->
 SysPrf T (iffH (substituteFormula L f v s) (substituteFormula L g v s)).

Lemma reduceCloseList :
 forall (l : list nat) (f1 f2 : Formula) (T : System),
 (forall v : nat, In v l -> ~ In_freeVarSys _ v T) ->
 SysPrf T (iffH f1 f2) ->
 SysPrf T (iffH (closeList L l f1) (closeList L l f2)).

End Replacement. *)

Require Import LNN.
(* LNN:
Require Import Arith.
Require Import Ensembles.
Require Import Coq.Lists.List.

Require Export Languages.
Require Import folProof.
Require Import folProp.
Require Import folLogic3.

Definition Formula := Formula LNN.
Definition Formulas := Formulas LNN.
Definition System := System LNN.
Definition Sentence := Sentence LNN.
Definition Term := Term LNN.
Definition Terms := Terms LNN.
Definition var := var LNN.
Definition equal := equal LNN.
Definition impH := impH LNN.
Definition notH := notH LNN.
Definition iffH := iffH LNN.
Definition forallH := forallH LNN.
Definition orH := orH LNN.
Definition andH := andH LNN.
Definition existH := existH LNN.
Definition ifThenElseH := ifThenElseH LNN.
Definition SysPrf := SysPrf LNN.

Definition Plus (x y : Term) : Term :=
  apply LNN Plus (Tcons LNN 1 x (Tcons LNN 0 y (Tnil LNN))).

Definition Times (x y : Term) : Term :=
  apply LNN Times (Tcons LNN 1 x (Tcons LNN 0 y (Tnil LNN))).

Definition Succ (x : Term) : Term :=
  apply LNN Succ (Tcons LNN 0 x (Tnil LNN)).

Definition Zero : Term := apply LNN Zero (Tnil LNN).

Definition LT (x y : Term) : Formula :=
  atomic LNN LT (Tcons LNN 1 x (Tcons LNN 0 y (Tnil LNN))). 

Lemma LNN_dec : language_decideable LNN.

Section Free_Variables.

Lemma freeVarPlus :
 forall x y : Term,
 freeVarTerm LNN (Plus x y) = freeVarTerm LNN x ++ freeVarTerm LNN y.

Lemma freeVarTimes :
 forall x y : Term,
 freeVarTerm LNN (Times x y) = freeVarTerm LNN x ++ freeVarTerm LNN y.

Lemma freeVarSucc :
 forall x : Term, freeVarTerm LNN (Succ x) = freeVarTerm LNN x.

Lemma freeVarZero : freeVarTerm LNN Zero = nil.

Lemma freeVarLT :
 forall x y : Term,
 freeVarFormula LNN (LT x y) = freeVarTerm LNN x ++ freeVarTerm LNN y.

End Free_Variables.

Section Logic.

Lemma Axm :
 forall (T : System) (f : Formula), mem _ T f -> SysPrf T f.

Lemma sysExtend :
 forall (T U : System) (f : Formula),
 Included _ T U -> SysPrf T f -> SysPrf U f.

Lemma sysWeaken :
 forall (T : System) (f g : Formula), SysPrf T f -> SysPrf (Ensembles.Add _ T g) f.

Lemma impI :
 forall (T : System) (f g : Formula),
 SysPrf (Ensembles.Add _ T g) f -> SysPrf T (impH g f).

Lemma impE :
 forall (T : System) (f g : Formula),
 SysPrf T (impH g f) -> SysPrf T g -> SysPrf T f.

Lemma contradiction :
 forall (T : System) (f g : Formula),
 SysPrf T f -> SysPrf T (notH f) -> SysPrf T g.

Lemma nnE :
 forall (T : System) (f : Formula), SysPrf T (notH (notH f)) -> SysPrf T f.

Lemma noMiddle : forall (T : System) (f : Formula), SysPrf T (orH (notH f) f).

Lemma nnI :
 forall (T : System) (f : Formula), SysPrf T f -> SysPrf T (notH (notH f)).

Lemma cp1 :
 forall (T : System) (f g : Formula),
 SysPrf T (impH (notH f) (notH g)) -> SysPrf T (impH g f).

Lemma cp2 :
 forall (T : System) (f g : Formula),
 SysPrf T (impH g f) -> SysPrf T (impH (notH f) (notH g)).

Lemma orI1 :
 forall (T : System) (f g : Formula), SysPrf T f -> SysPrf T (orH f g).

Lemma orI2 :
 forall (T : System) (f g : Formula), SysPrf T g -> SysPrf T (orH f g).

Lemma orE :
 forall (T : System) (f g h : Formula),
 SysPrf T (orH f g) ->
 SysPrf T (impH f h) -> SysPrf T (impH g h) -> SysPrf T h.

Lemma orSys :
 forall (T : System) (f g h : Formula),
 SysPrf (Ensembles.Add _ T f) h -> SysPrf (Ensembles.Add _ T g) h -> SysPrf (Ensembles.Add _ T (orH f g)) h.

Lemma andI :
 forall (T : System) (f g : Formula),
 SysPrf T f -> SysPrf T g -> SysPrf T (andH f g).

Lemma andE1 :
 forall (T : System) (f g : Formula), SysPrf T (andH f g) -> SysPrf T f.

Lemma andE2 :
 forall (T : System) (f g : Formula), SysPrf T (andH f g) -> SysPrf T g.

Lemma iffI :
 forall (T : System) (f g : Formula),
 SysPrf T (impH f g) -> SysPrf T (impH g f) -> SysPrf T (iffH f g).

Lemma iffE1 :
 forall (T : System) (f g : Formula),
 SysPrf T (iffH f g) -> SysPrf T (impH f g).

Lemma iffE2 :
 forall (T : System) (f g : Formula),
 SysPrf T (iffH f g) -> SysPrf T (impH g f).

Lemma forallI :
 forall (T : System) (f : Formula) (v : nat),
 ~ In_freeVarSys LNN v T -> SysPrf T f -> SysPrf T (forallH v f).

Lemma forallE :
 forall (T : System) (f : Formula) (v : nat) (t : Term),
 SysPrf T (forallH v f) -> SysPrf T (substituteFormula LNN f v t).

Lemma forallSimp :
 forall (T : System) (f : Formula) (v : nat),
 SysPrf T (forallH v f) -> SysPrf T f.

Lemma existI :
 forall (T : System) (f : Formula) (v : nat) (t : Term),
 SysPrf T (substituteFormula LNN f v t) -> SysPrf T (existH v f).

Lemma existE :
 forall (T : System) (f g : Formula) (v : nat),
 ~ In_freeVarSys LNN v T ->
 ~ In v (freeVarFormula LNN g) ->
 SysPrf T (existH v f) -> SysPrf T (impH f g) -> SysPrf T g.

Lemma existSimp :
 forall (T : System) (f : Formula) (v : nat),
 SysPrf T f -> SysPrf T (existH v f).

Lemma existSys :
 forall (T : System) (f g : Formula) (v : nat),
 ~ In_freeVarSys LNN v T ->
 ~ In v (freeVarFormula LNN g) ->
 SysPrf (Ensembles.Add _ T f) g -> SysPrf (Ensembles.Add _ T (existH v f)) g.

Lemma absurd1 :
 forall (T : System) (f : Formula),
 SysPrf T (impH f (notH f)) -> SysPrf T (notH f).

Lemma nImp :
 forall (T : System) (f g : Formula),
 SysPrf T (andH f (notH g)) -> SysPrf T (notH (impH f g)).

Lemma nOr :
 forall (T : System) (f g : Formula),
 SysPrf T (andH (notH f) (notH g)) -> SysPrf T (notH (orH f g)).

Lemma nAnd :
 forall (T : System) (f g : Formula),
 SysPrf T (orH (notH f) (notH g)) -> SysPrf T (notH (andH f g)).

Lemma nForall :
 forall (T : System) (f : Formula) (v : nat),
 SysPrf T (existH v (notH f)) -> SysPrf T (notH (forallH v f)).

Lemma nExist :
 forall (T : System) (f : Formula) (v : nat),
 SysPrf T (forallH v (notH f)) -> SysPrf T (notH (existH v f)).

Lemma impRefl : forall (T : System) (f : Formula), SysPrf T (impH f f).

Lemma impTrans :
 forall (T : System) (f g h : Formula),
 SysPrf T (impH f g) -> SysPrf T (impH g h) -> SysPrf T (impH f h).

Lemma orSym :
 forall (T : System) (f g : Formula),
 SysPrf T (orH f g) -> SysPrf T (orH g f).

Lemma andSym :
 forall (T : System) (f g : Formula),
 SysPrf T (andH f g) -> SysPrf T (andH g f).

Lemma iffRefl : forall (T : System) (f : Formula), SysPrf T (iffH f f).

Lemma iffSym :
 forall (T : System) (f g : Formula),
 SysPrf T (iffH f g) -> SysPrf T (iffH g f).

Lemma iffTrans :
 forall (T : System) (f g h : Formula),
 SysPrf T (iffH f g) -> SysPrf T (iffH g h) -> SysPrf T (iffH f h).

Lemma eqRefl : forall (T : System) (a : Term), SysPrf T (equal a a).

Lemma eqSym :
 forall (T : System) (a b : Term),
 SysPrf T (equal a b) -> SysPrf T (equal b a).

Lemma eqTrans :
 forall (T : System) (a b c : Term),
 SysPrf T (equal a b) -> SysPrf T (equal b c) -> SysPrf T (equal a c).

Lemma eqPlus :
 forall (T : System) (a b c d : Term),
 SysPrf T (equal a b) ->
 SysPrf T (equal c d) -> SysPrf T (equal (Plus a c) (Plus b d)).

Lemma eqTimes :
 forall (T : System) (a b c d : Term),
 SysPrf T (equal a b) ->
 SysPrf T (equal c d) -> SysPrf T (equal (Times a c) (Times b d)).

Lemma eqSucc :
 forall (T : System) (a b : Term),
 SysPrf T (equal a b) -> SysPrf T (equal (Succ a) (Succ b)).

Lemma eqLT :
 forall (T : System) (a b c d : Term),
 SysPrf T (equal a b) ->
 SysPrf T (equal c d) -> SysPrf T (iffH (LT a c) (LT b d)).

End Logic.

Fixpoint natToTerm (n : nat) : Term :=
  match n with
  | O => Zero
  | S m => Succ (natToTerm m)
  end.

Lemma closedNatToTerm :
 forall a v : nat, ~ In v (freeVarTerm LNN (natToTerm a)). *)

Require Import codeNatToTerm.
(* codeNatToTerm:
Require Import primRec.
Require Import cPair.
Require Import Arith.
Require Import code.
Require Import folProp.
Require Import folProof.
Require Import Languages.
Require LNN. 
Require LNT.

Definition natToTermLNN := LNN.natToTerm.

Definition natToTermLNT := LNT.natToTerm.

Definition codeNatToTerm : nat -> nat :=
  nat_rec (fun _ => nat) (cPair 4 0)
    (fun _ rec : nat => cPair 3 (S (cPair rec 0))).

Lemma codeNatToTermCorrectLNN :
 forall n : nat,
 codeNatToTerm n = codeTerm LNN codeLNTFunction (natToTermLNN n).

Lemma codeNatToTermCorrectLNT :
 forall n : nat,
 codeNatToTerm n = codeTerm LNT codeLNTFunction (natToTermLNT n).

Lemma codeNatToTermIsPR : isPR 1 codeNatToTerm. *)

Require Import PRrepresentable.
(* PRrepresentable:
Require Import Arith.
Require Import extEqualNat.
Require Import subAll.
Require Import folProp.
Require Import subProp.
Require Import folReplace.
Require Import folLogic3.
Require Import NN.
Require Import NNtheory.
Require Import primRec.
Require Import chRem.
Require Import expressible.
Require Import Coq.Lists.List.
Require Vector.
Require Import ListExt.
Require Import cPair.
Require Import Decidable.

Section Primative_Recursive_Representable.

Let Representable := Representable NN.
Let RepresentableAlternate := RepresentableAlternate NN closedNN1.
Let RepresentableHelp := RepresentableHelp NN.
Let Representable_ext := Representable_ext NN.

Definition beta (a z : nat) : nat :=
  snd
    (proj1_sig
       (modulo (coPrimeBeta z (cPairPi1 a)) (gtBeta z (cPairPi1 a))
          (cPairPi2 a))).

Definition betaFormula : Formula :=
  existH 3
    (andH (LT (var 3) (Succ (var 2)))
       (existH 4
          (andH (LT (var 4) (Succ (var 2)))
             (andH
                (equal
                   (Plus
                      (Times (Plus (var 3) (var 4))
                         (Succ (Plus (var 3) (var 4))))
                      (Times (natToTerm 2) (var 3)))
                   (Times (natToTerm 2) (var 2)))
                (andH (LT (var 0) (Succ (Times (var 3) (Succ (var 1)))))
                   (existH 5
                      (andH (LT (var 5) (Succ (var 4)))
                         (equal
                            (Plus (var 0)
                               (Times (var 5)
                                  (Succ (Times (var 3) (Succ (var 1))))))
                            (var 4))))))))).

Lemma betaRepresentable : Representable 2 beta betaFormula.
Proof.
assert
 (cPairLemma1 :
  forall a b : nat, (a + b) * S (a + b) + 2 * a = 2 * cPair a b).
intros.
unfold cPair in |- *.
rewrite mult_plus_distr_l.
rewrite plus_comm.
replace (2 * sumToN (a + b)) with ((a + b) * S (a + b)).
reflexivity.
induction (a + b).
simpl in |- *.
reflexivity.
simpl in |- *.
simpl in IHn.
rewrite <- plus_Snm_nSm.
simpl in |- *.
rewrite (plus_comm (sumToN n) 0) in IHn.
simpl in IHn.
rewrite (plus_comm (n + sumToN n) 0).
simpl in |- *.
rewrite plus_assoc_reverse.
rewrite (plus_comm (sumToN n)).
rewrite plus_assoc_reverse.
rewrite <- IHn.
replace (n * S (S n)) with (n + n * S n).
reflexivity.
repeat rewrite (mult_comm n).
simpl in |- *.
reflexivity.
unfold Representable in |- *.
split.
intros.
simpl in H.
decompose sum H; rewrite <- H0 || rewrite <- H1; auto.
simpl in |- *.
intros.
unfold betaFormula in |- *.
assert
 (forall (A : Formula) (v x a : nat),
  v <> x ->
  substituteFormula LNN (existH v A) x (natToTerm a) =
  existH v (substituteFormula LNN A x (natToTerm a))).
intros.
rewrite (subFormulaExist LNN).
induction (eq_nat_dec v x).
elim H.
auto.
induction (In_dec eq_nat_dec v (freeVarTerm LNN (natToTerm a1))).
elim (closedNatToTerm _ _ a2).
reflexivity.
assert
 (forall (t1 t2 : Term) (v a : nat),
  substituteFormula LNN (LT t1 t2) v (natToTerm a) =
  LT (substituteTerm LNN t1 v (natToTerm a))
    (substituteTerm LNN t2 v (natToTerm a))).
intros.
unfold LT at 1 in |- *.
rewrite (subFormulaRelation LNN).
reflexivity.
repeat first
 [ rewrite H; [ idtac | discriminate ]
 | rewrite H0
 | rewrite (subFormulaAnd LNN)
 | rewrite (subFormulaEqual LNN) ].
simpl in |- *.
repeat rewrite (subTermNil LNN).
cut
 (SysPrf NN
    (iffH
       (existH 3
          (andH (LT (var 3) (natToTerm (S a)))
             (existH 4
                (andH (LT (var 4) (natToTerm (S a)))
                   (andH
                      (equal
                         (Plus
                            (Times (Plus (var 3) (var 4))
                               (Succ (Plus (var 3) (var 4))))
                            (Times (natToTerm 2) (var 3)))
                         (Times (natToTerm 2) (natToTerm a)))
                      (andH
                         (LT (var 0)
                            (Succ (Times (var 3) (Succ (natToTerm a0)))))
                         (existH 5
                            (andH (LT (var 5) (Succ (var 4)))
                               (equal
                                  (Plus (var 0)
                                     (Times (var 5)
                                        (Succ
                                           (Times (var 3)
                                              (Succ (natToTerm a0))))))
                                  (var 4))))))))))
       (equal (var 0) (natToTerm (beta a a0))))).
auto.
apply iffI.
apply impI.
apply existSys.
apply closedNN.
unfold not in |- *; intros.
induction H1 as [H1| H1].
discriminate H1.
simpl in H1.
elim (closedNatToTerm _ _ H1).
apply impE with (LT (var 3) (natToTerm (S a))).
apply
 impE
  with
    (existH 4
       (andH (LT (var 4) (natToTerm (S a)))
          (andH
             (equal
                (Plus
                   (Times (Plus (var 3) (var 4))
                      (Succ (Plus (var 3) (var 4))))
                   (Times (natToTerm 2) (var 3)))
                (Times (natToTerm 2) (natToTerm a)))
             (andH (LT (var 0) (Succ (Times (var 3) (Succ (natToTerm a0)))))
                (existH 5
                   (andH (LT (var 5) (Succ (var 4)))
                      (equal
                         (Plus (var 0)
                            (Times (var 5)
                               (Succ (Times (var 3) (Succ (natToTerm a0))))))
                         (var 4)))))))).
apply sysWeaken.
apply impI.
apply existSys.
apply closedNN.
replace
 (freeVarFormula LNN
    (impH (LT (var 3) (natToTerm (S a)))
       (equal (var 0) (natToTerm (beta a a0))))) with
 ((freeVarTerm LNN (var 3) ++ freeVarTerm LNN (natToTerm (S a))) ++
  freeVarFormula LNN (equal (var 0) (natToTerm (beta a a0)))).
unfold not in |- *; intros.
simpl in H1.
induction H1 as [H1| H1].
discriminate H1.
induction (in_app_or _ _ _ H1).
rewrite freeVarSucc in H2.
elim (closedNatToTerm _ _ H2).
induction H2 as [H2| H2].
discriminate H2.
elim (closedNatToTerm _ _ H2).
rewrite <- freeVarLT.
reflexivity.
apply
 impTrans
  with
    (andH (equal (var 3) (natToTerm (cPairPi1 a)))
       (equal (var 4) (natToTerm (cPairPi2 a)))).
apply impI.
apply
 impE
  with
    (equal
       (Plus (Times (Plus (var 3) (var 4)) (Succ (Plus (var 3) (var 4))))
          (Times (natToTerm 2) (var 3))) (Times (natToTerm 2) (natToTerm a))).
apply impE with (LT (var 4) (natToTerm (S a))).
apply impE with (LT (var 3) (natToTerm (S a))).
do 2 apply sysWeaken.
apply boundedLT.
intros.
rewrite (subFormulaImp LNN).
unfold LT at 1 in |- *.
rewrite (subFormulaRelation LNN).
simpl in |- *.
rewrite subTermNil.
fold (var 4) in |- *.
replace (apply LNN Languages.Succ (Tcons LNN 0 (natToTerm a) (Tnil LNN)))
 with (natToTerm (S a)); [ idtac | reflexivity ].
fold (LT (var 4) (natToTerm (S a))) in |- *.
apply boundedLT.
intros.
repeat rewrite (subFormulaImp LNN).
repeat rewrite (subFormulaAnd LNN).
repeat rewrite (subFormulaEqual LNN).
replace
 (substituteTerm LNN
    (substituteTerm LNN
       (Plus (Times (Plus (var 3) (var 4)) (Succ (Plus (var 3) (var 4))))
          (Times (Succ (Succ Zero)) (var 3))) 3 (natToTerm n)) 4
    (natToTerm n0)) with
 (Plus
    (Times (Plus (natToTerm n) (natToTerm n0))
       (Succ (Plus (natToTerm n) (natToTerm n0))))
    (Times (Succ (Succ Zero)) (natToTerm n))).
replace
 (substituteTerm LNN
    (substituteTerm LNN (Times (Succ (Succ Zero)) (natToTerm a)) 3
       (natToTerm n)) 4 (natToTerm n0)) with
 (Times (natToTerm 2) (natToTerm a)).
simpl in |- *.
assert
 (forall (a b : nat) (s : Term),
  substituteTerm LNN (natToTerm a) b s = natToTerm a).
intros.
apply (subTermNil LNN).
apply closedNatToTerm.
repeat rewrite H3.
apply
 impTrans
  with
    (equal (natToTerm ((n + n0) * S (n + n0) + 2 * n)) (natToTerm (2 * a))).
apply impI.
eapply eqTrans; [ apply sysWeaken; apply eqSym | idtac ].
apply natPlus.
eapply eqTrans.
apply eqPlus.
eapply eqTrans; [ apply sysWeaken; apply eqSym | idtac ].
apply natTimes.
eapply eqTrans.
apply eqTimes.
apply sysWeaken; apply eqSym.
apply natPlus.
eapply eqTrans; [ apply sysWeaken; apply eqSym | idtac ].
simpl in |- *.
apply eqSucc.
apply natPlus.
apply eqRefl.
apply eqRefl.
apply sysWeaken; apply eqSym.
apply natTimes.
eapply eqTrans.
apply Axm; right; constructor.
apply sysWeaken.
replace (Succ (Succ Zero)) with (natToTerm 2).
apply natTimes.
reflexivity.
rewrite cPairLemma1.
induction (eq_nat_dec a (cPair n n0)).
rewrite a1.
rewrite cPairProjections1.
rewrite cPairProjections2.
apply impI.
apply andI; apply eqRefl.
apply impI.
apply
 contradiction with (equal (natToTerm (2 * cPair n n0)) (natToTerm (2 * a))).
apply Axm; right; constructor.
apply sysWeaken.
apply natNE.
unfold not in |- *; intros.
induction (nat_total_order _ _ b).
elim (lt_not_le (2 * a) (2 * cPair n n0)).
apply mult_S_lt_compat_l.
auto.
rewrite H4.
apply le_n.
elim (lt_not_le (2 * cPair n n0) (2 * a)).
apply mult_S_lt_compat_l.
auto.
rewrite H4.
apply le_n.
simpl in |- *.
repeat
 (rewrite (subTermNil LNN (natToTerm a)); [ idtac | apply closedNatToTerm ]).
reflexivity.
simpl in |- *.
repeat
 (rewrite (subTermNil LNN (natToTerm n)); [ idtac | apply closedNatToTerm ]).
reflexivity.
apply closedNatToTerm.
apply Axm; right; constructor.
eapply andE1.
apply Axm; left; right; constructor.
eapply andE1.
eapply andE2.
apply Axm; left; right; constructor.
repeat apply impI.
apply
 impE
  with
    (existH 5
       (andH (LT (var 5) (Succ (var 4)))
          (equal
             (Plus (var 0)
                (Times (var 5) (Succ (Times (var 3) (Succ (natToTerm a0))))))
             (var 4)))).
apply impE with (LT (var 0) (Succ (Times (var 3) (Succ (natToTerm a0))))).
rewrite <-
 (subFormulaId LNN
    (impH (LT (var 0) (Succ (Times (var 3) (Succ (natToTerm a0)))))
       (impH
          (existH 5
             (andH (LT (var 5) (Succ (var 4)))
                (equal
                   (Plus (var 0)
                      (Times (var 5)
                         (Succ (Times (var 3) (Succ (natToTerm a0))))))
                   (var 4)))) (equal (var 0) (natToTerm (beta a a0))))) 3)
 .
apply
 impE
  with
    (substituteFormula LNN
       (impH (LT (var 0) (Succ (Times (var 3) (Succ (natToTerm a0)))))
          (impH
             (existH 5
                (andH (LT (var 5) (Succ (var 4)))
                   (equal
                      (Plus (var 0)
                         (Times (var 5)
                            (Succ (Times (var 3) (Succ (natToTerm a0))))))
                      (var 4)))) (equal (var 0) (natToTerm (beta a a0))))) 3
       (natToTerm (cPairPi1 a))).
apply (subWithEquals LNN).
apply eqSym.
eapply andE1.
apply Axm; right; constructor.
rewrite <-
 (subFormulaId LNN
    (substituteFormula LNN
       (impH (LT (var 0) (Succ (Times (var 3) (Succ (natToTerm a0)))))
          (impH
             (existH 5
                (andH (LT (var 5) (Succ (var 4)))
                   (equal
                      (Plus (var 0)
                         (Times (var 5)
                            (Succ (Times (var 3) (Succ (natToTerm a0))))))
                      (var 4)))) (equal (var 0) (natToTerm (beta a a0))))) 3
       (natToTerm (cPairPi1 a))) 4).
apply
 impE
  with
    (substituteFormula LNN
       (substituteFormula LNN
          (impH (LT (var 0) (Succ (Times (var 3) (Succ (natToTerm a0)))))
             (impH
                (existH 5
                   (andH (LT (var 5) (Succ (var 4)))
                      (equal
                         (Plus (var 0)
                            (Times (var 5)
                               (Succ (Times (var 3) (Succ (natToTerm a0))))))
                         (var 4)))) (equal (var 0) (natToTerm (beta a a0)))))
          3 (natToTerm (cPairPi1 a))) 4 (natToTerm (cPairPi2 a))).
apply (subWithEquals LNN).
apply eqSym.
eapply andE2.
apply Axm; right; constructor.
do 2 apply sysWeaken.
repeat first
 [ rewrite H; [ idtac | discriminate ]
 | rewrite H0
 | rewrite (subFormulaImp LNN)
 | rewrite (subFormulaAnd LNN)
 | rewrite (subFormulaEqual LNN) ].
simpl in |- *.
repeat (rewrite (subTermNil LNN); [ idtac | apply closedNatToTerm ]).
repeat
 (rewrite (subTermNil LNN (natToTerm a0)); [ idtac | apply closedNatToTerm ]).
repeat
 (rewrite (subTermNil LNN (natToTerm (beta a a0)));
   [ idtac | apply closedNatToTerm ]).
apply impTrans with (LT (var 0) (natToTerm (S (cPairPi1 a * S a0)))).
apply impI.
apply
 impE
  with
    (substituteFormula LNN (LT (var 0) (var 1)) 1
       (natToTerm (S (cPairPi1 a * S a0)))).
unfold LT at 2 in |- *.
rewrite (subFormulaRelation LNN).
apply impRefl.
apply
 impE
  with
    (substituteFormula LNN (LT (var 0) (var 1)) 1
       (Succ (Times (natToTerm (cPairPi1 a)) (Succ (natToTerm a0))))).
apply (subWithEquals LNN).
apply sysWeaken.
simpl in |- *.
apply eqSucc.
replace (Succ (natToTerm a0)) with (natToTerm (S a0)).
apply natTimes.
reflexivity.
unfold LT at 2 in |- *.
rewrite (subFormulaRelation LNN).
apply Axm; right; constructor.
apply boundedLT.
intros.
repeat first
 [ rewrite H; [ idtac | discriminate ]
 | rewrite H0
 | rewrite (subFormulaImp LNN)
 | rewrite (subFormulaAnd LNN)
 | rewrite (subFormulaEqual LNN) ].
simpl in |- *.
repeat (rewrite (subTermNil LNN); [ idtac | apply closedNatToTerm ]).
apply impI.
apply existSys.
apply closedNN.
simpl in |- *.
unfold not in |- *; intros.
induction (in_app_or _ _ _ H2); elim (closedNatToTerm _ _ H3).
apply
 impE
  with
    (fol.equal LNN
       (apply LNN Languages.Plus
          (Tcons LNN 1 (natToTerm n)
             (Tcons LNN 0
                (apply LNN Languages.Times
                   (Tcons LNN 1 (fol.var LNN 5)
                      (Tcons LNN 0
                         (apply LNN Languages.Succ
                            (Tcons LNN 0
                               (apply LNN Languages.Times
                                  (Tcons LNN 1 (natToTerm (cPairPi1 a))
                                     (Tcons LNN 0
                                        (apply LNN Languages.Succ
                                           (Tcons LNN 0 
                                              (natToTerm a0) 
                                              (Tnil LNN))) 
                                        (Tnil LNN)))) 
                               (Tnil LNN))) (Tnil LNN)))) 
                (Tnil LNN)))) (natToTerm (cPairPi2 a))).
apply impE with (LT (var 5) (natToTerm (S (cPairPi2 a)))).
apply sysWeaken.
apply boundedLT.
intros.
repeat first
 [ rewrite H; [ idtac | discriminate ]
 | rewrite H0
 | rewrite (subFormulaImp LNN)
 | rewrite (subFormulaAnd LNN)
 | rewrite (subFormulaEqual LNN) ].
simpl in |- *.
repeat (rewrite (subTermNil LNN); [ idtac | apply closedNatToTerm ]).
apply impI.
induction (eq_nat_dec n (beta a a0)).
rewrite <- a1.
apply eqRefl.
apply
 contradiction
  with
    (equal (natToTerm (n + n0 * S (cPairPi1 a * S a0)))
       (natToTerm (cPairPi2 a))).
eapply eqTrans; [ idtac | apply Axm; right; constructor ].
apply sysWeaken.
eapply eqTrans.
apply eqSym.
apply natPlus.
replace
 (apply LNN Languages.Plus
    (Tcons LNN 1 (natToTerm n)
       (Tcons LNN 0
          (apply LNN Languages.Times
             (Tcons LNN 1 (natToTerm n0)
                (Tcons LNN 0
                   (apply LNN Languages.Succ
                      (Tcons LNN 0
                         (apply LNN Languages.Times
                            (Tcons LNN 1 (natToTerm (cPairPi1 a))
                               (Tcons LNN 0
                                  (apply LNN Languages.Succ
                                     (Tcons LNN 0 (natToTerm a0) (Tnil LNN)))
                                  (Tnil LNN)))) (Tnil LNN))) 
                   (Tnil LNN)))) (Tnil LNN)))) with
 (Plus (natToTerm n)
    (Times (natToTerm n0)
       (Succ (Times (natToTerm (cPairPi1 a)) (Succ (natToTerm a0)))))).
apply eqPlus.
apply eqRefl.
eapply eqTrans.
apply eqSym.
apply natTimes.
apply eqTimes.
apply eqRefl.
simpl in |- *.
apply eqSucc.
replace (Succ (natToTerm a0)) with (natToTerm (S a0)).
apply eqSym.
apply natTimes.
reflexivity.
reflexivity.
apply sysWeaken.
apply natNE.
unfold not in |- *; intros; elim b.
unfold beta in |- *.
induction
 (modulo (coPrimeBeta a0 (cPairPi1 a)) (gtBeta a0 (cPairPi1 a)) (cPairPi2 a)).
induction x as (a1, b0).
simpl in p.
simpl in |- *.
induction p as (H4, H5).
unfold coPrimeBeta in H4.
rewrite plus_comm in H3.
eapply uniqueRem.
unfold gt in |- *.
apply lt_O_Sn.
exists n0.
split.
symmetry  in |- *.
apply H3.
apply H1.
exists a1.
split.
apply H4.
apply H5.
eapply andE1.
apply Axm; right; constructor.
eapply andE2.
apply Axm; right; constructor.
eapply andE1.
eapply andE2.
eapply andE2.
apply Axm; left; right; constructor.
eapply andE2.
eapply andE2.
eapply andE2.
apply Axm; left; right; constructor.
eapply andE2.
apply Axm; right; constructor.
eapply andE1.
apply Axm; right; constructor.
apply impI.
unfold beta in |- *.
induction
 (modulo (coPrimeBeta a0 (cPairPi1 a)) (gtBeta a0 (cPairPi1 a)) (cPairPi2 a)).
induction x as (a1, b).
simpl in |- *.
simpl in p.
induction p as (H1, H2).
apply existI with (natToTerm (cPairPi1 a)).
rewrite (subFormulaAnd LNN).
apply andI.
apply sysWeaken.
rewrite H0.
simpl in |- *.
rewrite subTermNil.
replace (apply LNN Languages.Succ (Tcons LNN 0 (natToTerm a) (Tnil LNN)))
 with (natToTerm (S a)).
apply natLT.
apply le_lt_n_Sm.
apply le_trans with (cPair (cPairPi1 a) (cPairPi2 a)).
apply cPairLe1.
rewrite cPairProjections.
apply le_n.
reflexivity.
apply closedNatToTerm.
rewrite H.
apply existI with (natToTerm (cPairPi2 a)).
repeat rewrite (subFormulaAnd LNN).
apply andI.
apply sysWeaken.
repeat rewrite H0.
simpl in |- *.
repeat rewrite (subTermNil LNN (natToTerm a)).
replace (apply LNN Languages.Succ (Tcons LNN 0 (natToTerm a) (Tnil LNN)))
 with (natToTerm (S a)).
apply natLT.
apply le_lt_n_Sm.
apply le_trans with (cPair (cPairPi1 a) (cPairPi2 a)).
apply cPairLe2.
rewrite cPairProjections.
apply le_n.
reflexivity.
apply closedNatToTerm.
apply closedNatToTerm.
apply andI.
repeat rewrite (subFormulaEqual LNN).
simpl in |- *.
repeat
 (rewrite (subTermNil LNN (natToTerm (cPairPi1 a)));
   [ idtac | apply closedNatToTerm ]).
repeat
 (rewrite (subTermNil LNN (natToTerm a)); [ idtac | apply closedNatToTerm ]).
replace
 (fol.equal LNN
    (apply LNN Languages.Plus
       (Tcons LNN 1
          (apply LNN Languages.Times
             (Tcons LNN 1
                (apply LNN Languages.Plus
                   (Tcons LNN 1 (natToTerm (cPairPi1 a))
                      (Tcons LNN 0 (natToTerm (cPairPi2 a)) (Tnil LNN))))
                (Tcons LNN 0
                   (apply LNN Languages.Succ
                      (Tcons LNN 0
                         (apply LNN Languages.Plus
                            (Tcons LNN 1 (natToTerm (cPairPi1 a))
                               (Tcons LNN 0 (natToTerm (cPairPi2 a))
                                  (Tnil LNN)))) (Tnil LNN))) 
                   (Tnil LNN))))
          (Tcons LNN 0
             (apply LNN Languages.Times
                (Tcons LNN 1
                   (apply LNN Languages.Succ
                      (Tcons LNN 0
                         (apply LNN Languages.Succ
                            (Tcons LNN 0
                               (apply LNN Languages.Zero (Tnil LNN))
                               (Tnil LNN))) (Tnil LNN)))
                   (Tcons LNN 0 (natToTerm (cPairPi1 a)) (Tnil LNN))))
             (Tnil LNN))))
    (apply LNN Languages.Times
       (Tcons LNN 1
          (apply LNN Languages.Succ
             (Tcons LNN 0
                (apply LNN Languages.Succ
                   (Tcons LNN 0 (apply LNN Languages.Zero (Tnil LNN))
                      (Tnil LNN))) (Tnil LNN)))
          (Tcons LNN 0 (natToTerm a) (Tnil LNN))))) with
 (equal
    (Plus
       (Times (Plus (natToTerm (cPairPi1 a)) (natToTerm (cPairPi2 a)))
          (Succ (Plus (natToTerm (cPairPi1 a)) (natToTerm (cPairPi2 a)))))
       (Times (natToTerm 2) (natToTerm (cPairPi1 a))))
    (Times (natToTerm 2) (natToTerm a))); [ idtac | reflexivity ].
apply
 eqTrans
  with
    (natToTerm
       ((cPairPi1 a + cPairPi2 a) * S (cPairPi1 a + cPairPi2 a) +
        2 * cPairPi1 a)).
apply sysWeaken.
apply eqSym.
eapply eqTrans.
apply eqSym.
apply natPlus.
apply eqPlus.
eapply eqTrans.
apply eqSym.
apply natTimes.
apply eqTimes.
apply eqSym.
apply natPlus.
simpl in |- *.
apply eqSucc.
apply eqSym.
apply natPlus.
apply eqSym.
apply natTimes.
rewrite cPairLemma1.

Fixpoint addExists (m n : nat) (f : Formula) {struct n} : Formula :=
  match n with
  | O => f
  | S n' => existH (n' + m) (addExists m n' f)
  end.

Lemma freeVarAddExists1 :
 forall (n m v : nat) (A : Formula),
 In v (freeVarFormula LNN (addExists m n A)) -> In v (freeVarFormula LNN A).

Lemma freeVarAddExists2 :
 forall (n m v : nat) (A : Formula),
 In v (freeVarFormula LNN (addExists m n A)) -> n + m <= v \/ v < m.

Lemma reduceAddExistsOneWay :
 forall (n m : nat) (A B : Formula),
 SysPrf NN (impH A B) -> SysPrf NN (impH (addExists m n A) (addExists m n B)).

Lemma reduceAddExists :
 forall (n m : nat) (A B : Formula),
 SysPrf NN (iffH A B) -> SysPrf NN (iffH (addExists m n A) (addExists m n B)).

Lemma subAddExistsNice :
 forall (n m : nat) (A : Formula) (v : nat) (s : Term),
 n + m <= v \/ v < m ->
 (forall v : nat, In v (freeVarTerm LNN s) -> n + m <= v \/ v < m) ->
 substituteFormula LNN (addExists m n A) v s =
 addExists m n (substituteFormula LNN A v s).

Fixpoint addForalls (m n : nat) (f : Formula) {struct n} : Formula :=
  match n with
  | O => f
  | S n' => forallH (n' + m) (addForalls m n' f)
  end.

Lemma freeVarAddForalls1 :
 forall (n m v : nat) (A : Formula),
 In v (freeVarFormula LNN (addForalls m n A)) -> In v (freeVarFormula LNN A).

Lemma freeVarAddForalls2 :
 forall (n m v : nat) (A : Formula),
 In v (freeVarFormula LNN (addForalls m n A)) -> n + m <= v \/ v < m.

Lemma reduceAddForalls :
 forall (n m : nat) (A B : Formula),
 SysPrf NN (iffH A B) ->
 SysPrf NN (iffH (addForalls m n A) (addForalls m n B)).

Lemma subAddForallsNice :
 forall (n m : nat) (A : Formula) (v : nat) (s : Term),
 n + m <= v \/ v < m ->
 (forall v : nat, In v (freeVarTerm LNN s) -> n + m <= v \/ v < m) ->
 substituteFormula LNN (addForalls m n A) v s =
 addForalls m n (substituteFormula LNN A v s).

Fixpoint FormulasToFormula (n w m : nat)
 (vs : Vector.t (Formula * naryFunc n) m) {struct vs} : Formula :=
  match vs with
  | Vector.nil => equal (var 0) (var 0)
  | Vector.cons v m' vs' =>
      andH (substituteFormula LNN (fst v) 0 (var (S m' + w)))
        (FormulasToFormula n w m' vs')
  end.

Fixpoint FormulasToFuncs (n m : nat) (vs : Vector.t (Formula * naryFunc n) m)
 {struct vs} : Vector.t (naryFunc n) m :=
  match vs in (Vector.t _ m) return (Vector.t (naryFunc n) m) with
  | Vector.nil => Vector.nil _
  | Vector.cons v m' vs' => Vector.cons _ (snd v) m' (FormulasToFuncs n m' vs')
  end.

Fixpoint RepresentablesHelp (n m : nat)
 (vs : Vector.t (Formula * naryFunc n) m) {struct vs} : Prop :=
  match vs with
  | Vector.nil => True
  | Vector.cons a m' vs' =>
      RepresentableHelp _ (snd a) (fst a) /\ RepresentablesHelp n m' vs'
  end.

Let succFormula : Formula := equal (var 0) (Succ (var 1)).

Remark succRepresentable : Representable 1 S succFormula.

Let zeroFormula : Formula := equal (var 0) Zero.

Remark zeroRepresentable : Representable 0 0 zeroFormula.

Let projFormula (m : nat) : Formula := equal (var 0) (var (S m)).

Remark projRepresentable :
 forall (n m : nat) (pr : m < n),
 Representable n (evalProjFunc n m pr) (projFormula m).

Let composeSigmaFormula (n w m : nat) (A : Vector.t (Formula * naryFunc n) m)
  (B : Formula) : Formula :=
  addExists (S w) m
    (andH (FormulasToFormula n w m A)
       (subAllFormula LNN B
          (fun x : nat =>
           match x with
           | O => var 0
           | S x' => var (S x' + w)
           end))).

Remark composeSigmaRepresentable :
 forall n w m : nat,
 n <= w ->
 forall (A : Vector.t (Formula * naryFunc n) m) (B : Formula) (g : naryFunc m),

Remark boundedCheck :
 forall P : nat -> Prop,
 (forall x : nat, decidable (P x)) ->
 forall c : nat,
 (forall d : nat, d < c -> ~ P d) \/ (exists d : nat, d < c /\ P d).

Remark smallestExists :
 forall P : nat -> Prop,
 (forall x : nat, decidable (P x)) ->
 forall c : nat,
 P c -> exists a : nat, P a /\ (forall b : nat, b < a -> ~ P b).

Let minimize (A B : Formula) (v x : nat) : Formula :=
  andH A
    (forallH x
       (impH (LT (var x) (var v)) (notH (substituteFormula LNN B v (var x))))).

Remark minimize1 :
 forall (A B : Formula) (v x : nat),
 v <> x ->
 ~ In x (freeVarFormula LNN B) ->
 forall a : nat,
 SysPrf NN (substituteFormula LNN A v (natToTerm a)) ->
 SysPrf NN (substituteFormula LNN B v (natToTerm a)) ->
 (forall b : nat,
  b < a -> SysPrf NN (notH (substituteFormula LNN A v (natToTerm b)))) ->
 (forall b : nat,
  b < a -> SysPrf NN (notH (substituteFormula LNN B v (natToTerm b)))) ->
 SysPrf NN (iffH (minimize A B v x) (equal (var v) (natToTerm a))).

Lemma subFormulaMinimize :
 forall (A B : Formula) (v x z : nat) (s : Term),
 ~ In x (freeVarTerm LNN s) ->
 ~ In v (freeVarTerm LNN s) ->
 x <> z ->
 v <> z ->
 SysPrf NN
   (iffH (substituteFormula LNN (minimize A B v x) z s)
      (minimize (substituteFormula LNN A z s) (substituteFormula LNN B z s) v
         x)).

Let primRecSigmaFormulaHelp (n : nat) (SigA SigB : Formula) : Formula :=
  andH
    (existH 0
       (andH SigA
          (substituteFormula LNN (substituteFormula LNN betaFormula 1 Zero) 2
             (var (S (S n))))))
    (forallH (S (S (S n)))
       (impH (LT (var (S (S (S n)))) (var (S n)))
          (existH 0
             (existH (S n)
                (andH
                   (substituteFormula LNN
                      (substituteFormula LNN
                         (substituteFormula LNN betaFormula 1
                            (var (S (S (S n))))) 2 
                         (var (S (S n)))) 0 (var (S n)))
                   (andH
                      (substituteFormula LNN SigB (S (S n))
                         (var (S (S (S n)))))
                      (substituteFormula LNN
                         (substituteFormula LNN betaFormula 1
                            (Succ (var (S (S (S n)))))) 2 
                         (var (S (S n)))))))))).

Let primRecPiFormulaHelp (n : nat) (SigA SigB : Formula) : Formula :=
  andH
    (forallH 0
       (impH SigA
          (substituteFormula LNN (substituteFormula LNN betaFormula 1 Zero) 2
             (var (S (S n))))))
    (forallH (S (S (S n)))
       (impH (LT (var (S (S (S n)))) (var (S n)))
          (forallH 0
             (forallH (S n)
                (impH
                   (substituteFormula LNN
                      (substituteFormula LNN
                         (substituteFormula LNN betaFormula 1
                            (var (S (S (S n))))) 2 
                         (var (S (S n)))) 0 (var (S n)))
                   (impH
                      (substituteFormula LNN SigB (S (S n))
                         (var (S (S (S n)))))
                      (substituteFormula LNN
                         (substituteFormula LNN betaFormula 1
                            (Succ (var (S (S (S n)))))) 2 
                         (var (S (S n)))))))))).

Lemma freeVarPrimRecSigmaFormulaHelp1 :
 forall (n : nat) (A B : Formula) (v : nat),
 In v (freeVarFormula LNN (primRecSigmaFormulaHelp n A B)) ->
 In v (freeVarFormula LNN A) \/
 In v (freeVarFormula LNN B) \/ v = S (S n) \/ v = S n.

Lemma freeVarPrimRecPiFormulaHelp1 :
 forall (n : nat) (A B : Formula) (v : nat),
 In v (freeVarFormula LNN (primRecPiFormulaHelp n A B)) ->
 In v (freeVarFormula LNN A) \/
 In v (freeVarFormula LNN B) \/ v = S (S n) \/ v = S n.

Let primRecSigmaFormula (n : nat) (SigA SigB : Formula) : Formula :=
  existH (S (S n))
    (andH
       (minimize (primRecSigmaFormulaHelp n SigA SigB)
          (primRecPiFormulaHelp n SigA SigB) (S (S n)) 
          (S (S (S (S n)))))
       (substituteFormula LNN
          (substituteFormula LNN betaFormula 2 (var (S (S n)))) 1 
          (var (S n)))).

Remark notBoundedForall :
 forall (P : nat -> Prop) (b : nat),
 (forall x : nat, decidable (P x)) ->
 ~ (forall n : nat, n < b -> P n) -> exists n : nat, n < b /\ ~ P n.

Lemma succ_plus_discr : forall n m : nat, n <> S (m + n).

Lemma n_SSn : forall n : nat, n <> S (S n).

Lemma n_SSSn : forall n : nat, n <> S (S (S n)).

Lemma n_SSSSn : forall n : nat, n <> S (S (S (S n))).

Remark In_betaFormula_subst_1_2_0 :
 forall (a b c : Term) (v : nat),
 In v
   (freeVarFormula LNN
      (substituteFormula LNN
         (substituteFormula LNN (substituteFormula LNN betaFormula 1 a) 2 b)
         0 c)) ->
 In v (freeVarTerm LNN a) \/
 In v (freeVarTerm LNN b) \/ In v (freeVarTerm LNN c).

Remark In_betaFormula_subst_1_2 :
 forall (a b : Term) (v : nat),
 In v
   (freeVarFormula LNN
      (substituteFormula LNN (substituteFormula LNN betaFormula 1 a) 2 b)) ->
 In v (freeVarTerm LNN a) \/
 In v (freeVarTerm LNN b) \/ In v (freeVarTerm LNN (var 0)).

Remark In_betaFormula_subst_1 :
 forall (a : Term) (v : nat),
 In v (freeVarFormula LNN (substituteFormula LNN betaFormula 1 a)) ->
 In v (freeVarTerm LNN a) \/
 In v (freeVarTerm LNN (var 2)) \/ In v (freeVarTerm LNN (var 0)).

Remark In_betaFormula :
 forall v : nat,
 In v (freeVarFormula LNN betaFormula) ->
 In v (freeVarTerm LNN (var 1)) \/
 In v (freeVarTerm LNN (var 2)) \/ In v (freeVarTerm LNN (var 0)).

Remark In_betaFormula_subst_2 :
 forall (a : Term) (v : nat),
 In v (freeVarFormula LNN (substituteFormula LNN betaFormula 2 a)) ->
 In v (freeVarTerm LNN a) \/
 In v (freeVarTerm LNN (var 1)) \/ In v (freeVarTerm LNN (var 0)).

Remark In_betaFormula_subst_2_1 :
 forall (a b : Term) (v : nat),
 In v
   (freeVarFormula LNN
      (substituteFormula LNN (substituteFormula LNN betaFormula 2 a) 1 b)) ->
 In v (freeVarTerm LNN a) \/
 In v (freeVarTerm LNN b) \/ In v (freeVarTerm LNN (var 0)).

Ltac PRsolveFV A B n :=
  unfold existH, forallH, not in |- *; intros;
   repeat
    match goal with
    | H:(_ = _) |- _ => discriminate H
    | H:(?X1 <> ?X1) |- _ => elim H; reflexivity
    | H:(?X1 = S ?X1) |- _ => elim (n_Sn _ H)
    | H:(S ?X1 = ?X1) |- _ =>
        elim (n_Sn X1); symmetry  in |- *; apply H
    | H:(?X1 = S (S ?X1)) |- _ => elim (n_SSn _ H)
    | H:(S (S ?X1) = ?X1) |- _ =>
        elim (n_SSn X1); symmetry  in |- *; apply H
    | H:(?X1 = S (S (S ?X1))) |- _ =>
        elim (n_SSSn _ H)
    | H:(S (S (S ?X1)) = ?X1) |- _ =>
        elim (n_SSSn X1); symmetry  in |- *; apply H
    | H:(In ?X3
           (freeVarFormula LNN
              (substituteFormula LNN
                 (substituteFormula LNN
                    (substituteFormula LNN betaFormula 1 _) 2 _) 0 _))) |- _
    =>
        decompose sum (In_betaFormula_subst_1_2_0 _ _ _ _ H); clear H
    | H:(In ?X3
           (freeVarFormula LNN
              (substituteFormula LNN (substituteFormula LNN betaFormula 1 _)
                 2 _))) |- _ =>
        decompose sum (In_betaFormula_subst_1_2 _ _ _ H); clear H
    | H:(In ?X3 (freeVarFormula LNN (substituteFormula LNN betaFormula 1 _)))
    |- _ =>
        decompose sum (In_betaFormula_subst_1 _ _ H); clear H
    | H:(In ?X3 (freeVarFormula LNN betaFormula)) |- _ =>
        decompose sum (In_betaFormula _ H); clear H
    | H:(In ?X3
           (freeVarFormula LNN
              (substituteFormula LNN (substituteFormula LNN betaFormula 2 _)
                 1 _))) |- _ =>
        decompose sum (In_betaFormula_subst_2_1 _ _ _ H); clear H
    | H:(In ?X3 (freeVarFormula LNN (substituteFormula LNN betaFormula 2 _)))
    |- _ =>
        decompose sum (In_betaFormula_subst_2 _ _ H);
         clear H
              | H:(In ?X3 (freeVarFormula LNN (fol.existH LNN ?X1 ?X2))) |- _ =>
        assert
         (In X3 (list_remove nat eq_nat_dec X1 (freeVarFormula LNN X2)));
         [ apply H | clear H ]
    | H:(In ?X3 (freeVarFormula LNN (fol.forallH LNN ?X1 ?X2))) |- _ =>
        assert
         (In X3 (list_remove nat eq_nat_dec X1 (freeVarFormula LNN X2)));
         [ apply H | clear H ]
    | 
        H:(In ?X3 (list_remove nat eq_nat_dec ?X1 (freeVarFormula LNN ?X2))) |- _
    =>
        assert (In X3 (freeVarFormula LNN X2));
         [ eapply In_list_remove1; apply H
         | assert (X3 <> X1); [ eapply In_list_remove2; apply H | clear H ] ]
    | H:(In ?X3 (freeVarFormula LNN (fol.andH LNN ?X1 ?X2))) |- _ =>
        assert (In X3 (freeVarFormula LNN X1 ++ freeVarFormula LNN X2));
         [ apply H | clear H ]
    | H:(In ?X3 (freeVarFormula LNN (fol.impH LNN ?X1 ?X2))) |- _ =>
        assert (In X3 (freeVarFormula LNN X1 ++ freeVarFormula LNN X2));
         [ apply H | clear H ]
    | H:(In ?X3 (freeVarFormula LNN (fol.notH LNN ?X1))) |- _ =>
        assert (In X3 (freeVarFormula LNN X1)); [ apply H | clear H ]
    | H:(In _ (freeVarFormula LNN (primRecPiFormulaHelp _ _ _))) |- _ =>
        decompose sum (freeVarPrimRecPiFormulaHelp1 _ _ _ _ H); clear H
    | J:(In ?X3 (freeVarFormula LNN A)),H:(forall v : nat,
                                           In v (freeVarFormula LNN A) ->
                                           v <= S n) |- _ =>
        elim (le_not_lt X3 (S n));
         [ apply H; apply J | clear J; repeat apply lt_n_Sn || apply lt_S ]
    | H:(In ?X3 (freeVarFormula LNN B)),H0:(forall v : nat,
                                            In v (freeVarFormula LNN B) ->
                                            v <= S (S (S n))) |- _ =>
        elim (le_not_lt X3 (S (S (S n))));
         [ apply H0; apply H | clear H; repeat apply lt_n_Sn || apply lt_S ]
    | H:(In _ (_ ++ _)) |- _ =>
        induction (in_app_or _ _ _ H); clear H
    | H:(In _ (freeVarFormula LNN (substituteFormula LNN ?X1 ?X2 ?X3))) |- _
    =>
        induction (freeVarSubFormula3 _ _ _ _ _ H); clear H
    | H:(In _ (freeVarFormula LNN (LT ?X1 ?X2))) |- _ =>
        rewrite freeVarLT in H
    | H:(In _ (freeVarTerm LNN (natToTerm _))) |- _ =>
        elim (closedNatToTerm _ _ H)
    | H:(In _ (freeVarTerm LNN Zero)) |- _ =>
        elim H
    | H:(In _ (freeVarTerm LNN (Succ _))) |- _ =>
        rewrite freeVarSucc in H
    | H:(In _ (freeVarTerm LNN (var _))) |- _ =>
        simpl in H; decompose sum H; clear H
    | H:(In _ (freeVarTerm LNN (fol.var LNN _))) |- _ =>
        simpl in H; decompose sum H; clear H
    end.

Remark primRecSigmaRepresentable :
 forall (n : nat) (A : Formula) (g : naryFunc n),
 Representable n g A ->
 forall (B : Formula) (h : naryFunc (S (S n))),
 Representable (S (S n)) h B ->
 Representable (S n) (evalPrimRecFunc n g h) (primRecSigmaFormula n A B).
Proof.
assert
 (forall (n : nat) (A : Formula) (g : naryFunc n),
  Representable n g A ->
  forall (B : Formula) (h : naryFunc (S (S n))),
  Representable (S (S n)) h B ->
  RepresentableHelp (S n) (evalPrimRecFunc n g h) (primRecSigmaFormula n A B)).
intro.
induction n as [| n Hrecn].
simpl in |- *; intros.
unfold primRecSigmaFormula in |- *.
rewrite (subFormulaExist LNN).
induction (In_dec eq_nat_dec 2 (freeVarTerm LNN (natToTerm a))).
elim (closedNatToTerm _ _ a0).
simpl in |- *.
clear b.
assert (repBeta : Representable 2 beta betaFormula).
apply betaRepresentable.
rewrite (subFormulaAnd LNN).
repeat rewrite (subFormulaId LNN).
apply
 iffTrans
  with
    (fol.existH LNN 2
       (fol.andH LNN
          (minimize
             (substituteFormula LNN (primRecSigmaFormulaHelp 0 A B) 1
                (natToTerm a))
             (substituteFormula LNN (primRecPiFormulaHelp 0 A B) 1
                (natToTerm a)) 2 4)
          (substituteFormula LNN betaFormula 1 (natToTerm a)))).
apply (reduceExist LNN).
apply closedNN.
apply (reduceAnd LNN).
apply subFormulaMinimize; first [ discriminate | apply closedNatToTerm ].
apply iffRefl.
set (f := evalPrimRecFunc 0 g h) in *.
induction (betaTheorem1 (S a) f).

Fixpoint primRecFormula (n : nat) (f : PrimRec n) {struct f} : Formula :=
  match f with
  | succFunc => succFormula
  | zeroFunc => zeroFormula
  | projFunc n m _ => projFormula m
  | composeFunc n m g h =>
      composeSigmaFormula n n m (primRecsFormula n m g) (primRecFormula m h)
  | primRecFunc n g h =>
      primRecSigmaFormula n (primRecFormula n g) (primRecFormula (S (S n)) h)
  end
 
 with primRecsFormula (n m : nat) (fs : PrimRecs n m) {struct fs} :
 Vector.t (Formula * naryFunc n) m :=
  match fs in (PrimRecs n m) return (Vector.t (Formula * naryFunc n) m) with
  | PRnil n => Vector.nil _
  | PRcons n m f fs' =>
      Vector.cons (Formula * naryFunc n) (primRecFormula n f, evalPrimRec n f) m
        (primRecsFormula n m fs')
  end.

Lemma primRecRepresentable1 :
 forall (n : nat) (f : PrimRec n),
 Representable n (evalPrimRec n f) (primRecFormula n f).

Lemma primRecRepresentable :
 forall (n : nat) (f : naryFunc n) (p : isPR n f),
 Representable n f (primRecFormula n (proj1_sig p)).

End Primative_Recursive_Representable. *)

Require Import ListExt.
(* ListExt:
Require Import Coq.Lists.List.

Section List_Remove.

Variable A : Set.
Hypothesis Aeq_dec : forall a b : A, {a = b} + {a <> b}.

Definition list_remove (x : A) (l : list A) : list A :=
  list_rec (fun _ => list A) nil
    (fun (a : A) _ (recl : list A) =>
     match Aeq_dec a x with
     | left _ => recl
     | right _ => a :: recl
     end) l.

Lemma In_list_remove1 :
 forall (a b : A) (l : list A), In a (list_remove b l) -> In a l.

Lemma In_list_remove2 :
 forall (a b : A) (l : list A), In a (list_remove b l) -> a <> b.

Lemma In_list_remove3 :
 forall (a b : A) (l : list A), In a l -> a <> b -> In a (list_remove b l).

End List_Remove.

Section No_Duplicate.

Variable A : Set.
Hypothesis Aeq_dec : forall a b : A, {a = b} + {a <> b}.

Definition no_dup (l : list A) : list A :=
  list_rec (fun _ => list A) nil
    (fun (a : A) _ (rec : list A) =>
     match In_dec Aeq_dec a rec with
     | left _ => rec
     | right _ => a :: rec
     end) l.

Lemma no_dup1 : forall (a : A) (l : list A), In a l -> In a (no_dup l).

Lemma no_dup2 : forall (a : A) (l : list A), In a (no_dup l) -> In a l.

Lemma no_dup3 : forall (k l : list A) (a : A), no_dup k = a :: l -> ~ In a l.

End No_Duplicate. *)

Require Import Coq.Lists.List.

Require Import NN.

Require Import expressible.
(* expressible:
Require Import Arith.
Require Import Coq.Lists.List.
Require Import ListExt.
Require Import folProp.
Require Import subProp.
Require Import extEqualNat.
Require Import LNN.

Section RepresentableExpressible.

Variable T : System.
Hypothesis closedT1: (ClosedSystem LNN T).

Lemma closedT : forall v : nat, ~ In_freeVarSys LNN v T.

Fixpoint RepresentableHalf1 (n : nat) : naryFunc n -> Formula -> Prop :=
  match n return (naryFunc n -> Formula -> Prop) with
  | O =>
      fun (f : naryFunc 0) (A : Formula) =>
      SysPrf T (impH A (equal (var 0) (natToTerm f)))
  | S m =>
      fun (f : naryFunc (S m)) (A : Formula) =>
      forall a : nat,
      RepresentableHalf1 m (f a)
        (substituteFormula LNN A (S m) (natToTerm a))
  end.

Fixpoint RepresentableHalf2 (n : nat) : naryFunc n -> Formula -> Prop :=
  match n return (naryFunc n -> Formula -> Prop) with
  | O =>
      fun (f : naryFunc 0) (A : Formula) =>
      SysPrf T (impH (equal (var 0) (natToTerm f)) A)
  | S m =>
      fun (f : naryFunc (S m)) (A : Formula) =>
      forall a : nat,
      RepresentableHalf2 m (f a)
        (substituteFormula LNN A (S m) (natToTerm a))
  end.

Lemma RepresentableHalf1Alternate :
 forall (n : nat) (f : naryFunc n) (A B : Formula),
 SysPrf T (impH A B) -> RepresentableHalf1 n f B -> RepresentableHalf1 n f A.

Lemma RepresentableHalf2Alternate :
 forall (n : nat) (f : naryFunc n) (A B : Formula),
 SysPrf T (impH A B) -> RepresentableHalf2 n f A -> RepresentableHalf2 n f B.

Fixpoint RepresentableHelp (n : nat) : naryFunc n -> Formula -> Prop :=
  match n return (naryFunc n -> Formula -> Prop) with
  | O =>
      fun (f : naryFunc 0) (A : Formula) =>
      SysPrf T (iffH A (equal (var 0) (natToTerm f)))
  | S m =>
      fun (f : naryFunc (S m)) (A : Formula) =>
      forall a : nat,
      RepresentableHelp m (f a) (substituteFormula LNN A (S m) (natToTerm a))
  end.

Lemma RepresentableHalfHelp :
 forall (n : nat) (f : naryFunc n) (A : Formula),
 RepresentableHalf1 n f A ->
 RepresentableHalf2 n f A -> RepresentableHelp n f A.

Definition Representable (n : nat) (f : naryFunc n) 
  (A : Formula) : Prop :=
  (forall v : nat, In v (freeVarFormula LNN A) -> v <= n) /\
  RepresentableHelp n f A.

Lemma RepresentableAlternate :
 forall (n : nat) (f : naryFunc n) (A B : Formula),
 SysPrf T (iffH A B) -> RepresentableHelp n f A -> RepresentableHelp n f B.

Lemma Representable_ext :
 forall (n : nat) (f g : naryFunc n) (A : Formula),
 extEqual n f g -> RepresentableHelp n f A -> RepresentableHelp n g A.

Fixpoint ExpressibleHelp (n : nat) : naryRel n -> Formula -> Prop :=
  match n return (naryRel n -> Formula -> Prop) with
  | O =>
      fun (R : naryRel 0) (A : Formula) =>
      match R with
      | true => SysPrf T A
      | false => SysPrf T (notH A)
      end
  | S m =>
      fun (R : naryRel (S m)) (A : Formula) =>
      forall a : nat,
      ExpressibleHelp m (R a) (substituteFormula LNN A (S m) (natToTerm a))
  end.

Definition Expressible (n : nat) (R : naryRel n) (A : Formula) : Prop :=
  (forall v : nat, In v (freeVarFormula LNN A) -> v <= n /\ v <> 0) /\
  ExpressibleHelp n R A.

Lemma expressibleAlternate :
 forall (n : nat) (R : naryRel n) (A B : Formula),
 SysPrf T (iffH A B) -> ExpressibleHelp n R A -> ExpressibleHelp n R B.

Hypothesis nn1:(SysPrf T (notH (equal (natToTerm 1) (natToTerm 0)))).

Lemma Representable2Expressible :
 forall (n : nat) (R : naryRel n) (A : Formula),
 Representable n (charFunction n R) A ->
 Expressible n R (substituteFormula LNN A 0 (natToTerm 1)).

End RepresentableExpressible. *)



Definition subStar (a v n : nat) := codeSubFormula a v (codeNatToTerm n).



Lemma subStarIsPR : isPR 3 subStar.

Proof.

unfold subStar in |- *.

apply

 compose3_3IsPR

  with

    (f1 := fun a v n : nat => a)

    (f2 := fun a v n : nat => v)

    (f3 := fun a v n : nat => codeNatToTerm n).

apply pi1_3IsPR.

apply pi2_3IsPR.

apply filter001IsPR.

apply codeNatToTermIsPR.

apply codeSubFormulaIsPR.

Qed.



Section LNN_FixPoint.



Let codeFormula := codeFormula LNN codeLNTFunction codeLNNRelation.



Lemma FixPointLNN :

 forall (A : Formula) (v : nat),

 {B : Formula |

   SysPrf NN

     (iffH B (substituteFormula LNN A v (natToTermLNN (codeFormula B)))) /\

   (forall x : nat,

    In x (freeVarFormula LNN B) <->

    In x (list_remove _ eq_nat_dec v (freeVarFormula LNN A)))}.

Proof.

intros.

set (subStarFormula := primRecFormula _ (proj1_sig subStarIsPR)) in *.

assert (represent : Representable NN 3 subStar subStarFormula).

unfold subStarFormula in |- *.

apply primRecRepresentable.

set (nv := newVar (v :: 1 :: 2 :: 3 :: 0 :: freeVarFormula LNN A)) in *.

assert (0 <> nv).

unfold not in |- *; intros.

elim (newVar1 (v :: 1 :: 2 :: 3 :: 0 :: freeVarFormula LNN A)).

unfold nv in H.

rewrite <- H.

simpl in |- *.

right.

auto.

assert (1 <> nv).

unfold not in |- *; intros.

elim (newVar1 (v :: 1 :: 2 :: 3 :: 0 :: freeVarFormula LNN A)).

unfold nv in H0.

rewrite <- H0.

simpl in |- *.

auto.

assert (2 <> nv).

unfold not in |- *; intros.

elim (newVar1 (v :: 1 :: 2 :: 3 :: 0 :: freeVarFormula LNN A)).

unfold nv in H1.

rewrite <- H1.

simpl in |- *.

auto.

assert (3 <> nv).

unfold not in |- *; intros.

elim (newVar1 (v :: 1 :: 2 :: 3 :: 0 :: freeVarFormula LNN A)).

unfold nv in H2.

rewrite <- H2.

simpl in |- *.

auto.

assert (3 < nv).

destruct nv as [| n].

elim H; auto.

destruct n.

elim H0; auto.

destruct n.

elim H1; auto.

destruct n.

elim H2; auto.

repeat apply lt_n_S.

apply lt_O_Sn.

set

 (Theta :=

  existH v

    (andH

       (substituteFormula LNN

          (substituteFormula LNN

             (substituteFormula LNN

                (substituteFormula LNN subStarFormula 3 (var nv)) 2

                (natToTerm nv)) 1 (var nv)) 0 (var v)) A)) 

 in *.

exists (substituteFormula LNN Theta nv (natToTerm (codeFormula Theta))).

split.

set

 (N :=

  natToTermLNN

    (codeFormula

       (substituteFormula LNN Theta nv (natToTerm (codeFormula Theta)))))

 in *.

unfold Theta at 1 in |- *.

rewrite (subFormulaExist LNN).

induction (eq_nat_dec v nv).

elim (newVar1 (v :: 1 :: 2 :: 3 :: 0 :: freeVarFormula LNN A)).

fold nv in |- *.

simpl in |- *.

auto.

induction

 (In_dec eq_nat_dec v (freeVarTerm LNN (natToTerm (codeFormula Theta)))).

elim (closedNatToTerm _ _ a).

clear b b0.

rewrite (subFormulaAnd LNN).

apply

 iffTrans

  with

    (existH v

       (andH

          (substituteFormula LNN

             (substituteFormula LNN

                (substituteFormula LNN

                   (substituteFormula LNN subStarFormula 3

                      (natToTerm (codeFormula Theta))) 2 

                   (natToTerm nv)) 1 (natToTerm (codeFormula Theta))) 0

             (var v)) A)).

apply (reduceExist LNN).

apply closedNN.

apply (reduceAnd LNN).

eapply iffTrans.

apply (subFormulaExch LNN).

assumption.

unfold not in |- *; intros.

induction H4 as [H4| H4].

elim (newVar1 (v :: 1 :: 2 :: 3 :: 0 :: freeVarFormula LNN A)).

fold nv in |- *.

rewrite <- H4.

simpl in |- *.

auto.

apply H4.

apply closedNatToTerm.

apply (reduceSub LNN).

apply closedNN.

eapply iffTrans.

apply (subSubFormula LNN).

assumption.

apply closedNatToTerm.

rewrite (subTermVar1 LNN).

apply (reduceSub LNN).

apply closedNN.

eapply iffTrans.

apply (subFormulaExch LNN).

assumption.

apply closedNatToTerm.

apply closedNatToTerm.

apply (reduceSub LNN).

apply closedNN.

apply (subFormulaTrans LNN).

unfold not in |- *; intros.

assert (In nv (freeVarFormula LNN subStarFormula)).

eapply In_list_remove1.

apply H4.

induction represent as (H6, H7).

elim (lt_not_le _ _ H3).

auto.

apply (subFormulaNil LNN).

unfold not in |- *; intros.

elim (newVar1 (v :: 1 :: 2 :: 3 :: 0 :: freeVarFormula LNN A)).

fold nv in |- *.

simpl in |- *.

repeat right.

auto.

apply iffI.

apply impI.

apply existSys.

apply closedNN.

unfold not in |- *; intros.

induction (freeVarSubFormula3 _ _ _ _ _ H4).

elim (In_list_remove2 _ _ _ _ _ H5).

auto.

elim (closedNatToTerm _ _ H5).

apply impE with (substituteFormula LNN (equal (var 0) N) 0 (var v)).

rewrite (subFormulaEqual LNN).

rewrite (subTermVar1 LNN).

rewrite (subTermNil LNN).

apply impI.

apply impE with (substituteFormula LNN A v (var v)).

apply (subWithEquals LNN).

apply Axm; right; constructor.

rewrite (subFormulaId LNN).

eapply andE2.

apply Axm; left; right; constructor.

unfold N in |- *.

apply closedNatToTerm.

apply

 impE

  with

    (substituteFormula LNN

       (substituteFormula LNN

          (substituteFormula LNN

             (substituteFormula LNN subStarFormula 3

                (natToTerm (codeFormula Theta))) 2 

             (natToTerm nv)) 1 (natToTerm (codeFormula Theta))) 0 

       (var v)).

apply iffE1.

apply sysWeaken.

apply (reduceSub LNN).

apply closedNN.

induction represent as (H4, H5).

simpl in H5.

unfold N in |- *.

replace

 (codeFormula

    (substituteFormula LNN Theta nv (natToTerm (codeFormula Theta)))) with

 (subStar (codeFormula Theta) nv (codeFormula Theta)).

apply H5.

unfold subStar in |- *.

rewrite codeNatToTermCorrectLNN.

unfold codeFormula at 1 in |- *.

rewrite codeSubFormulaCorrect.

reflexivity.

eapply andE1.

apply Axm; right; constructor.

apply impI.

apply existI with N.

rewrite (subFormulaAnd LNN).

apply andI.

apply sysWeaken.

eapply

 impE

      with

      (substituteFormula LNN

         (substituteFormula LNN (equal (var 0) N) 0 (var v)) v N).

apply iffE2.

apply (reduceSub LNN).

apply closedNN.

apply (reduceSub LNN).

apply closedNN.

induction represent as (H4, H5).

simpl in H5.

unfold N in |- *.

replace

 (codeFormula

    (substituteFormula LNN Theta nv (natToTerm (codeFormula Theta)))) with

 (subStar (codeFormula Theta) nv (codeFormula Theta)).

apply H5.

unfold subStar in |- *.

rewrite codeNatToTermCorrectLNN.

unfold codeFormula at 1 in |- *.

rewrite codeSubFormulaCorrect.

reflexivity.

repeat rewrite (subFormulaEqual LNN).

repeat rewrite (subTermVar1 LNN).

repeat rewrite (subTermNil LNN N).

apply eqRefl.

unfold N in |- *.

apply closedNatToTerm.

unfold N in |- *.

apply closedNatToTerm.

apply Axm; right; constructor.

intro.

split.

intro.

unfold Theta at 1 in H4.

unfold existH, andH in H4.

induction represent as (H5, H6).

repeat

 match goal with

 | H1:(?X1 = ?X2),H2:(?X1 <> ?X2) |- _ =>

     elim H2; apply H1

 | H1:(?X1 = ?X2),H2:(?X2 <> ?X1) |- _ =>

     elim H2; symmetry  in |- *; apply H1

 | H:(In ?X3 (freeVarFormula LNN (fol.existH LNN ?X1 ?X2))) |- _ =>

     assert (In X3 (list_remove nat eq_nat_dec X1 (freeVarFormula LNN X2)));

      [ apply H | clear H ]

 | H:(In ?X3 (freeVarFormula LNN (fol.forallH LNN ?X1 ?X2))) |- _ =>

     assert (In X3 (list_remove nat eq_nat_dec X1 (freeVarFormula LNN X2)));

      [ apply H | clear H ]

 | H:(In ?X3 (list_remove nat eq_nat_dec ?X1 (freeVarFormula LNN ?X2))) |- _

 =>

     assert (In X3 (freeVarFormula LNN X2));

      [ eapply In_list_remove1; apply H

      | assert (X3 <> X1); [ eapply In_list_remove2; apply H | clear H ] ]

 | H:(In ?X3 (freeVarFormula LNN (fol.andH LNN ?X1 ?X2))) |- _ =>

     assert (In X3 (freeVarFormula LNN X1 ++ freeVarFormula LNN X2));

      [ apply H | clear H ]

 | H:(In ?X3 (freeVarFormula LNN (fol.impH LNN ?X1 ?X2))) |- _ =>

     assert (In X3 (freeVarFormula LNN X1 ++ freeVarFormula LNN X2));

      [ apply H | clear H ]

 | H:(In ?X3 (freeVarFormula LNN (fol.notH LNN ?X1))) |- _ =>

     assert (In X3 (freeVarFormula LNN X1)); [ apply H | clear H ]

 | H:(In _ (_ ++ _)) |- _ =>

     induction (in_app_or _ _ _ H); clear H

 | H:(In _ (freeVarFormula LNN (substituteFormula LNN ?X1 ?X2 ?X3))) |- _ =>

     induction (freeVarSubFormula3 _ _ _ _ _ H); clear H

 | H:(In _ (freeVarTerm LNN (natToTerm _))) |- _ =>

     elim (closedNatToTerm _ _ H)

 | H:(In _ (freeVarTerm LNN Zero)) |- _ =>

     elim H

 | H:(In _ (freeVarTerm LNN (Succ _))) |- _ =>

     rewrite freeVarSucc in H

 | H:(In _ (freeVarTerm LNN (var _))) |- _ =>

     simpl in H; decompose sum H; clear H

 | H:(In _ (freeVarTerm LNN (fol.var LNN _))) |- _ =>

     simpl in H; decompose sum H; clear H

 end.

elim (le_not_lt _ _ (H5 _ H4)).

destruct x as [| n].

elim H10; auto.

destruct n.

elim H11; auto.

destruct n.

elim H12; auto.

destruct n.

elim H13; auto.

repeat apply lt_n_S.

apply lt_O_Sn.

apply In_list_remove3; auto.

intro.

assert (In x (freeVarFormula LNN A));

 [ eapply In_list_remove1; apply H4

 | assert (x <> v); [ eapply In_list_remove2; apply H4 | clear H4 ] ].

apply freeVarSubFormula1.

unfold not in |- *; intros.

rewrite <- H4 in H5.

elim (newVar1 (v :: 1 :: 2 :: 3 :: 0 :: freeVarFormula LNN A)).

fold nv in |- *.

simpl in |- *.

repeat right.

auto.

unfold Theta in |- *.

apply

 (In_list_remove3 nat eq_nat_dec x v

    (freeVarFormula LNN

       (substituteFormula LNN

          (substituteFormula LNN

             (substituteFormula LNN

                (substituteFormula LNN subStarFormula 3 (var nv)) 2

                (natToTerm nv)) 1 (var nv)) 0 (var v)) ++

     freeVarFormula LNN A)).

apply in_or_app.

auto.

assumption.

Qed.



End LNN_FixPoint.



Section LNT_FixPoint.



Require Import PA.

Require Import NN2PA.
(* NN2PA:
Require Import Ensembles.
Require Import Coq.Lists.List.
Require Import Arith.

Require Import folProp.
Require Import folProof.
Require Import subProp.
Require Import folLogic3.
Require Import folReplace.
Require Import NN.
Require Import PAtheory.
Require Export LNN2LNT.
Require Import subAll.
Require Import ListExt.

Lemma NN2PA :
 forall f : fol.Formula LNN,

Lemma PAboundedLT :
 forall (m : nat) (a : Formula) (x : nat),
 (forall n : nat,
  n < m -> SysPrf PA (substituteFormula LNT a x (natToTerm n))) ->
 SysPrf PA (impH (LNN2LNT_formula (LT (fol.var LNN x) (LNN.natToTerm m))) a). *)



Let codeFormula := codeFormula LNT codeLNTFunction codeLNTRelation.



Lemma FixPointLNT :

 forall (A : Formula) (v : nat),

 {B : Formula |

   SysPrf PA

     (iffH B (substituteFormula LNT A v (natToTermLNT (codeFormula B)))) /\

   (forall x : nat,

    In x (freeVarFormula LNT B) <->

    In x (list_remove _ eq_nat_dec v (freeVarFormula LNT A)))}.

Proof.

intros.

set (subStarFormula := primRecFormula _ (proj1_sig subStarIsPR)) in *.

assert (represent : Representable NN 3 subStar subStarFormula).

unfold subStarFormula in |- *.

apply primRecRepresentable.

set (nv := newVar (v :: 1 :: 2 :: 3 :: 0 :: freeVarFormula LNT A)) in *.

assert (0 <> nv).

unfold not in |- *; intros.

elim (newVar1 (v :: 1 :: 2 :: 3 :: 0 :: freeVarFormula LNT A)).

unfold nv in H.

rewrite <- H.

simpl in |- *.

right.

auto.

assert (1 <> nv).

unfold not in |- *; intros.

elim (newVar1 (v :: 1 :: 2 :: 3 :: 0 :: freeVarFormula LNT A)).

unfold nv in H0.

rewrite <- H0.

simpl in |- *.

auto.

assert (2 <> nv).

unfold not in |- *; intros.

elim (newVar1 (v :: 1 :: 2 :: 3 :: 0 :: freeVarFormula LNT A)).

unfold nv in H1.

rewrite <- H1.

simpl in |- *.

auto.

assert (3 <> nv).

unfold not in |- *; intros.

elim (newVar1 (v :: 1 :: 2 :: 3 :: 0 :: freeVarFormula LNT A)).

unfold nv in H2.

rewrite <- H2.

simpl in |- *.

auto.

assert (3 < nv).

destruct nv as [| n].

elim H; auto.

destruct n.

elim H0; auto.

destruct n.

elim H1; auto.

destruct n.

elim H2; auto.

repeat apply lt_n_S.

apply lt_O_Sn.

set

 (Theta :=

  existH v

    (andH

       (substituteFormula LNT

          (substituteFormula LNT

             (substituteFormula LNT

                (substituteFormula LNT (LNN2LNT_formula subStarFormula) 3

                   (var nv)) 2 (natToTerm nv)) 1 (var nv)) 0 

          (var v)) A)) in *.

exists (substituteFormula LNT Theta nv (natToTerm (codeFormula Theta))).

split.

set

 (N :=

  natToTermLNT

    (codeFormula

       (substituteFormula LNT Theta nv (natToTerm (codeFormula Theta)))))

 in *.

unfold Theta at 1 in |- *.

rewrite (subFormulaExist LNT).

induction (eq_nat_dec v nv).

elim (newVar1 (v :: 1 :: 2 :: 3 :: 0 :: freeVarFormula LNT A)).

fold nv in |- *.

simpl in |- *.

auto.

induction

 (In_dec eq_nat_dec v (freeVarTerm LNT (natToTerm (codeFormula Theta)))).

elim (closedNatToTerm _ _ a).

clear b b0.

rewrite (subFormulaAnd LNT).

apply

 iffTrans

  with

    (existH v

       (andH

          (substituteFormula LNT

             (substituteFormula LNT

                (substituteFormula LNT

                   (substituteFormula LNT (LNN2LNT_formula subStarFormula) 3

                      (natToTerm (codeFormula Theta))) 2 

                   (natToTerm nv)) 1 (natToTerm (codeFormula Theta))) 0

             (var v)) A)).

apply (reduceExist LNT).

apply closedPA.

apply (reduceAnd LNT).

eapply iffTrans.

apply (subFormulaExch LNT).

assumption.

unfold not in |- *; intros.

induction H4 as [H4| H4].

elim (newVar1 (v :: 1 :: 2 :: 3 :: 0 :: freeVarFormula LNT A)).

fold nv in |- *.

rewrite <- H4.

simpl in |- *.

auto.

apply H4.

apply closedNatToTerm.

apply (reduceSub LNT).

apply closedPA.

eapply iffTrans.

apply (subSubFormula LNT).

assumption.

apply closedNatToTerm.

rewrite (subTermVar1 LNT).

apply (reduceSub LNT).

apply closedPA.

eapply iffTrans.

apply (subFormulaExch LNT).

assumption.

apply closedNatToTerm.

apply closedNatToTerm.

apply (reduceSub LNT).

apply closedPA.

apply (subFormulaTrans LNT).

unfold not in |- *; intros.

assert (In nv (freeVarFormula LNT (LNN2LNT_formula subStarFormula))).

eapply In_list_remove1.

apply H4.

induction represent as (H6, H7).

elim (lt_not_le _ _ H3).

apply H6.

apply LNN2LNT_freeVarFormula1.

assumption.

apply (subFormulaNil LNT).

unfold not in |- *; intros.

elim (newVar1 (v :: 1 :: 2 :: 3 :: 0 :: freeVarFormula LNT A)).

fold nv in |- *.

simpl in |- *.

repeat right.

auto.

apply iffI.

apply impI.

apply existSys.

apply closedPA.

unfold not in |- *; intros.

induction (freeVarSubFormula3 _ _ _ _ _ H4).

elim (In_list_remove2 _ _ _ _ _ H5).

auto.

elim (closedNatToTerm _ _ H5).

apply impE with (substituteFormula LNT (equal (var 0) N) 0 (var v)).

rewrite (subFormulaEqual LNT).

rewrite (subTermVar1 LNT).

rewrite (subTermNil LNT).

apply impI.

apply impE with (substituteFormula LNT A v (var v)).

apply (subWithEquals LNT).

apply Axm; right; constructor.

rewrite (subFormulaId LNT).

eapply andE2.

apply Axm; left; right; constructor.

unfold N in |- *.

apply closedNatToTerm.

apply

 impE

  with

    (substituteFormula LNT

       (substituteFormula LNT

          (substituteFormula LNT

             (substituteFormula LNT (LNN2LNT_formula subStarFormula) 3

                (natToTerm (codeFormula Theta))) 2 

             (natToTerm nv)) 1 (natToTerm (codeFormula Theta))) 0 

       (var v)).

apply iffE1.

apply sysWeaken.

apply (reduceSub LNT).

apply closedPA.

induction represent as (H4, H5).

simpl in H5.

unfold N in |- *.

replace

 (codeFormula

    (substituteFormula LNT Theta nv (natToTerm (codeFormula Theta)))) with

 (subStar (codeFormula Theta) nv (codeFormula Theta)).

replace

 (equal (var 0)

    (natToTermLNT (subStar (codeFormula Theta) nv (codeFormula Theta)))) with

 (LNN2LNT_formula

    (LNN.equal (LNN.var 0)

       (LNN.natToTerm (subStar (codeFormula Theta) nv (codeFormula Theta))))).

apply

 iffTrans

  with

    (LNN2LNT_formula

       (substituteFormula LNN

          (substituteFormula LNN

             (substituteFormula LNN subStarFormula 3

                (LNN.natToTerm (codeFormula Theta))) 2 

             (LNN.natToTerm nv)) 1 (LNN.natToTerm (codeFormula Theta)))).

apply iffSym.

eapply iffTrans; [ apply LNN2LNT_subFormula | idtac ].

rewrite LNN2LNT_natToTerm; apply (reduceSub LNT);

 [ apply closedPA | idtac ].

eapply iffTrans; [ apply LNN2LNT_subFormula | idtac ].

rewrite LNN2LNT_natToTerm; apply (reduceSub LNT);

 [ apply closedPA | idtac ].

eapply iffTrans; [ apply LNN2LNT_subFormula | idtac ].

rewrite LNN2LNT_natToTerm; apply (reduceSub LNT);

 [ apply closedPA | idtac ].

apply iffRefl.

rewrite <- LNN2LNT_iff.

apply NN2PA.

apply H5.

rewrite <- LNN2LNT_natToTerm.

reflexivity.

unfold subStar in |- *.

rewrite codeNatToTermCorrectLNT.

unfold codeFormula at 1 in |- *.

rewrite codeSubFormulaCorrect.

reflexivity.

eapply andE1.

apply Axm; right; constructor.

apply impI.

apply existI with N.

rewrite (subFormulaAnd LNT).

apply andI.

apply sysWeaken.

eapply

 impE

      with

      (substituteFormula LNT

         (substituteFormula LNT (equal (var 0) N) 0 (var v)) v N).

apply iffE2.

apply (reduceSub LNT).

apply closedPA.

apply (reduceSub LNT).

apply closedPA.

induction represent as (H4, H5).

simpl in H5.

unfold N in |- *.

replace

 (codeFormula

    (substituteFormula LNT Theta nv (natToTerm (codeFormula Theta)))) with

 (subStar (codeFormula Theta) nv (codeFormula Theta)).

replace

 (equal (var 0)

    (natToTermLNT (subStar (codeFormula Theta) nv (codeFormula Theta)))) with

 (LNN2LNT_formula

    (LNN.equal (LNN.var 0)

       (LNN.natToTerm (subStar (codeFormula Theta) nv (codeFormula Theta))))).

apply

 iffTrans

  with

    (LNN2LNT_formula

       (substituteFormula LNN

          (substituteFormula LNN

             (substituteFormula LNN subStarFormula 3

                (LNN.natToTerm (codeFormula Theta))) 2 

             (LNN.natToTerm nv)) 1 (LNN.natToTerm (codeFormula Theta)))).

apply iffSym.

eapply iffTrans; [ apply LNN2LNT_subFormula | idtac ].

rewrite LNN2LNT_natToTerm; apply (reduceSub LNT);

 [ apply closedPA | idtac ].

eapply iffTrans; [ apply LNN2LNT_subFormula | idtac ].

rewrite LNN2LNT_natToTerm; apply (reduceSub LNT);

 [ apply closedPA | idtac ].

eapply iffTrans; [ apply LNN2LNT_subFormula | idtac ].

rewrite LNN2LNT_natToTerm; apply (reduceSub LNT);

 [ apply closedPA | idtac ].

apply iffRefl.

rewrite <- LNN2LNT_iff.

apply NN2PA.

apply H5.

rewrite <- LNN2LNT_natToTerm.

reflexivity.

unfold subStar in |- *.

rewrite codeNatToTermCorrectLNT.

unfold codeFormula at 1 in |- *.

rewrite codeSubFormulaCorrect.

reflexivity.

repeat rewrite (subFormulaEqual LNT).

repeat rewrite (subTermVar1 LNT).

repeat rewrite (subTermNil LNT N).

apply eqRefl.

unfold N in |- *.

apply closedNatToTerm.

unfold N in |- *.

apply closedNatToTerm.

apply Axm; right; constructor.

intro.

split.

intro.

unfold Theta at 1 in H4.

unfold existH, andH in H4.

induction represent as (H5, H6).

repeat

 match goal with

 | H1:(?X1 = ?X2),H2:(?X1 <> ?X2) |- _ =>

     elim H2; apply H1

 | H1:(?X1 = ?X2),H2:(?X2 <> ?X1) |- _ =>

     elim H2; symmetry  in |- *; apply H1

 | H:(In ?X3 (freeVarFormula LNT (fol.existH LNT ?X1 ?X2))) |- _ =>

     assert (In X3 (list_remove nat eq_nat_dec X1 (freeVarFormula LNT X2)));

      [ apply H | clear H ]

 | H:(In ?X3 (freeVarFormula LNT (fol.forallH LNT ?X1 ?X2))) |- _ =>

     assert (In X3 (list_remove nat eq_nat_dec X1 (freeVarFormula LNT X2)));

      [ apply H | clear H ]

 | H:(In ?X3 (list_remove nat eq_nat_dec ?X1 (freeVarFormula LNT ?X2))) |- _

 =>

     assert (In X3 (freeVarFormula LNT X2));

      [ eapply In_list_remove1; apply H

      | assert (X3 <> X1); [ eapply In_list_remove2; apply H | clear H ] ]

 | H:(In ?X3 (freeVarFormula LNT (fol.andH LNT ?X1 ?X2))) |- _ =>

     assert (In X3 (freeVarFormula LNT X1 ++ freeVarFormula LNT X2));

      [ apply H | clear H ]

 | H:(In ?X3 (freeVarFormula LNT (fol.impH LNT ?X1 ?X2))) |- _ =>

     assert (In X3 (freeVarFormula LNT X1 ++ freeVarFormula LNT X2));

      [ apply H | clear H ]

 | H:(In ?X3 (freeVarFormula LNT (fol.notH LNT ?X1))) |- _ =>

     assert (In X3 (freeVarFormula LNT X1)); [ apply H | clear H ]

 | H:(In _ (_ ++ _)) |- _ =>

     induction (in_app_or _ _ _ H); clear H

 | H:(In _ (freeVarFormula LNT (substituteFormula LNT ?X1 ?X2 ?X3))) |- _ =>

     induction (freeVarSubFormula3 _ _ _ _ _ H); clear H

 | H:(In _ (freeVarTerm LNT (natToTerm _))) |- _ =>

     elim (closedNatToTerm _ _ H)

 | H:(In _ (freeVarTerm LNT Zero)) |- _ =>

     elim H

 | H:(In _ (freeVarTerm LNT (Succ _))) |- _ =>

     rewrite freeVarSucc in H

 | H:(In _ (freeVarTerm LNT (var _))) |- _ =>

     simpl in H; decompose sum H; clear H

 | H:(In _ (freeVarTerm LNT (fol.var LNT _))) |- _ =>

     simpl in H; decompose sum H; clear H

 end.

elim (le_not_lt x 3).

apply H5.

apply LNN2LNT_freeVarFormula1.

assumption.

destruct x as [| n].

elim H10; auto.

destruct n.

elim H11; auto.

destruct n.

elim H12; auto.

destruct n.

elim H13; auto.

repeat apply lt_n_S.

apply lt_O_Sn.

apply In_list_remove3; auto.

intro.

assert (In x (freeVarFormula LNT A));

 [ eapply In_list_remove1; apply H4

 | assert (x <> v); [ eapply In_list_remove2; apply H4 | clear H4 ] ].

apply freeVarSubFormula1.

unfold not in |- *; intros.

rewrite <- H4 in H5.

elim (newVar1 (v :: 1 :: 2 :: 3 :: 0 :: freeVarFormula LNT A)).

fold nv in |- *.

simpl in |- *.

repeat right.

auto.

unfold Theta in |- *.

apply

 (In_list_remove3 nat eq_nat_dec x v

    (freeVarFormula LNT

       (substituteFormula LNT

          (substituteFormula LNT

             (substituteFormula LNT

                (substituteFormula LNT (LNN2LNT_formula subStarFormula) 3

                   (var nv)) 2 (natToTerm nv)) 1 (var nv)) 0 

          (var v)) ++ freeVarFormula LNT A)).

apply in_or_app.

auto.

assumption.

Qed.



End LNT_FixPoint.

