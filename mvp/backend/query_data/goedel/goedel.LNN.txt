Require Import Arith.

Require Import Ensembles.

Require Import Coq.Lists.List.



Require Export Languages.

Require Import folProof.
(* folProof:
Require Import Ensembles.
Require Import Coq.Lists.List.
Require Import Arith.

Require Export fol.
Require Import folProp.

Section ProofH.

Variable L : Language.

Let Formula := Formula L.
Let Formulas := Formulas L.
Let System := System L.
Let Term := Term L.
Let Terms := Terms L.
Let var := var L.
Let apply := apply L.
Let equal := equal L.
Let atomic := atomic L.
Let impH := impH L.
Let notH := notH L.
Let iffH := iffH L.
Let forallH := forallH L.

Definition nVars (n : nat) : Terms n * Terms n.

Definition AxmEq4 (R : Relations L) : Formula.

Definition AxmEq5 (f : Functions L) : Formula.

Inductive Prf : Formulas -> Formula -> Set :=
  | AXM : forall A : Formula, Prf (A :: nil) A
  | MP :
      forall (Axm1 Axm2 : Formulas) (A B : Formula),
      Prf Axm1 (impH A B) -> Prf Axm2 A -> Prf (Axm1 ++ Axm2) B
  | GEN :
      forall (Axm : Formulas) (A : Formula) (v : nat),
      ~ In v (freeVarListFormula L Axm) -> Prf Axm A -> Prf Axm (forallH v A)
  | IMP1 : forall A B : Formula, Prf nil (impH A (impH B A))
  | IMP2 :
      forall A B C : Formula,
      Prf nil (impH (impH A (impH B C)) (impH (impH A B) (impH A C)))
  | CP :
      forall A B : Formula,
      Prf nil (impH (impH (notH A) (notH B)) (impH B A))
  | FA1 :
      forall (A : Formula) (v : nat) (t : Term),
      Prf nil (impH (forallH v A) (substituteFormula L A v t))
  | FA2 :
      forall (A : Formula) (v : nat),
      ~ In v (freeVarFormula L A) -> Prf nil (impH A (forallH v A))
  | FA3 :
      forall (A B : Formula) (v : nat),
      Prf nil
        (impH (forallH v (impH A B)) (impH (forallH v A) (forallH v B)))
  | EQ1 : Prf nil (equal (var 0) (var 0))
  | EQ2 : Prf nil (impH (equal (var 0) (var 1)) (equal (var 1) (var 0)))
  | EQ3 :
      Prf nil
        (impH (equal (var 0) (var 1))
           (impH (equal (var 1) (var 2)) (equal (var 0) (var 2))))
  | EQ4 : forall R : Relations L, Prf nil (AxmEq4 R)
  | EQ5 : forall f : Functions L, Prf nil (AxmEq5 f).

Definition SysPrf (T : System) (f : Formula) :=
  exists Axm : Formulas,
    (exists prf : Prf Axm f,
       (forall g : Formula, In g Axm -> mem _ T g)).

Definition Inconsistent (T : System) := forall f : Formula, SysPrf T f.

Definition Consistent (T : System) := exists f : Formula, ~ SysPrf T f.

End ProofH. *)

Require Import folProp.
(* folProp:
Require Import Wf_nat.
Require Import Max.
Require Import Arith.
Require Import Coq.Lists.List.
Require Import ListExt.
Require Import Peano_dec.

Require Export fol.

Section Fol_Properties.

Variable L : Language.

Notation Formula := (Formula L) (only parsing).
Notation Formulas := (Formulas L) (only parsing).
Notation System := (System L) (only parsing).
Notation Term := (Term L) (only parsing).
Notation Terms := (Terms L) (only parsing).
Let var := var L.
Let apply := apply L.
Let equal := equal L.
Let atomic := atomic L.
Let impH := impH L.
Let notH := notH L.
Let forallH := forallH L.
Let lt_depth := lt_depth L.

Section Free_Variables.

Fixpoint freeVarTerm (s : fol.Term L) : list nat :=
  match s with
  | fol.var v => v :: nil
  | fol.apply f ts => freeVarTerms (arity L (inr _ f)) ts
  end
 
 with freeVarTerms (n : nat) (ss : fol.Terms L n) {struct ss} : 
 list nat :=
  match ss with
  | Tnil => nil (A:=nat)
  | Tcons m t ts => freeVarTerm t ++ freeVarTerms m ts
  end.

Lemma freeVarTermApply :
 forall (f : Functions L) (ts : fol.Terms L _),

Fixpoint freeVarFormula (A : fol.Formula L) : list nat :=
  match A with
  | fol.equal t s => freeVarTerm t ++ freeVarTerm s
  | fol.atomic r ts => freeVarTerms _ ts
  | fol.impH A B => freeVarFormula A ++ freeVarFormula B
  | fol.notH A => freeVarFormula A
  | fol.forallH v A => list_remove _ eq_nat_dec v (freeVarFormula A)
  end.

Definition ClosedSystem (T : fol.System L) :=
  forall (v : nat) (f : fol.Formula L),
  mem _ T f -> ~ In v (freeVarFormula f).

Definition closeList (l : list nat) (x : fol.Formula L) : 
  fol.Formula L :=
  list_rec (fun _ => fol.Formula L) x
    (fun (a : nat) _ (rec : fol.Formula L) => forallH a rec) l.

Definition close (x : fol.Formula L) : fol.Formula L :=
  closeList (no_dup _ eq_nat_dec (freeVarFormula x)) x.

Lemma freeVarClosedList1 :
 forall (l : list nat) (v : nat) (x : fol.Formula L),

Lemma freeVarClosedList2 :
 forall (l : list nat) (v : nat) (x : fol.Formula L),

Lemma freeVarClosed :
 forall (x : fol.Formula L) (v : nat), ~ In v (freeVarFormula (close x)).

Fixpoint freeVarListFormula (l : fol.Formulas L) : 
 list nat :=
  match l with
  | nil => nil (A:=nat)
  | f :: l => freeVarFormula f ++ freeVarListFormula l
  end.

Lemma freeVarListFormulaApp :
 forall a b : fol.Formulas L,

Lemma In_freeVarListFormula :
 forall (v : nat) (f : fol.Formula L) (F : fol.Formulas L),

Lemma In_freeVarListFormulaE :
 forall (v : nat) (F : fol.Formulas L),

Definition In_freeVarSys (v : nat) (T : fol.System L) :=
  exists f : fol.Formula L, In v (freeVarFormula f) /\ mem _ T f.

Lemma notInFreeVarSys :
 forall x, ~ In_freeVarSys x (Ensembles.Empty_set (fol.Formula L)).

End Free_Variables.

Section Substitution.

Fixpoint substituteTerm (s : fol.Term L) (x : nat) 
 (t : fol.Term L) {struct s} : fol.Term L :=
  match s with
  | fol.var v =>
      match eq_nat_dec x v with
      | left _ => t
      | right _ => var v
      end
  | fol.apply f ts => apply f (substituteTerms _ ts x t)
  end
 
 with substituteTerms (n : nat) (ss : fol.Terms L n) 
 (x : nat) (t : fol.Term L) {struct ss} : fol.Terms L n :=
  match ss in (fol.Terms _ n0) return (fol.Terms L n0) with
  | Tnil => Tnil L
  | Tcons m s ts =>
      Tcons L m (substituteTerm s x t) (substituteTerms m ts x t)
  end.

Lemma subTermVar1 :
 forall (v : nat) (s : fol.Term L), substituteTerm (var v) v s = s.

Lemma subTermVar2 :
 forall (v x : nat) (s : fol.Term L),

Lemma subTermFunction :
 forall (f : Functions L) (ts : fol.Terms L (arity L (inr _ f))) 

Definition newVar (l : list nat) : nat := fold_right max 0 (map S l).

Lemma newVar2 : forall (l : list nat) (n : nat), In n l -> n < newVar l.

Lemma newVar1 : forall l : list nat, ~ In (newVar l) l.

Definition substituteFormulaImp (f : fol.Formula L)
  (frec : nat * fol.Term L -> {y : fol.Formula L | depth L y = depth L f})
  (g : fol.Formula L)
  (grec : nat * fol.Term L -> {y : fol.Formula L | depth L y = depth L g})
  (p : nat * fol.Term L) :
  {y : fol.Formula L | depth L y = depth L (impH f g)} :=
  match frec p with
  | exist f' prf1 =>
      match grec p with
      | exist g' prf2 =>
          exist
            (fun y : fol.Formula L =>
             depth L y = S (max (depth L f) (depth L g))) 
            (impH f' g')
            (eq_ind_r
               (fun n : nat =>
                S (max n (depth L g')) = S (max (depth L f) (depth L g)))
               (eq_ind_r
                  (fun n : nat =>
                   S (max (depth L f) n) = S (max (depth L f) (depth L g)))
                  (refl_equal (S (max (depth L f) (depth L g)))) prf2) prf1)
      end
  end.

Remark substituteFormulaImpNice :
 forall (f g : fol.Formula L)

Definition substituteFormulaNot (f : fol.Formula L)
  (frec : nat * fol.Term L -> {y : fol.Formula L | depth L y = depth L f})
  (p : nat * fol.Term L) :
  {y : fol.Formula L | depth L y = depth L (notH f)} :=
  match frec p with
  | exist f' prf1 =>
      exist (fun y : fol.Formula L => depth L y = S (depth L f)) 
        (notH f')
        (eq_ind_r (fun n : nat => S n = S (depth L f))
           (refl_equal (S (depth L f))) prf1)
  end.

Remark substituteFormulaNotNice :
 forall (f : fol.Formula L)

Definition substituteFormulaForall (n : nat) (f : fol.Formula L)
  (frec : forall b : fol.Formula L,
          lt_depth b (forallH n f) ->
          nat * fol.Term L -> {y : fol.Formula L | depth L y = depth L b})
  (p : nat * fol.Term L) :
  {y : fol.Formula L | depth L y = depth L (forallH n f)} :=
  match p with
  | (v, s) =>
      match eq_nat_dec n v with
      | left _ =>
          exist (fun y : fol.Formula L => depth L y = S (depth L f))
            (forallH n f) (refl_equal (depth L (forallH n f)))
      | right _ =>
          match In_dec eq_nat_dec n (freeVarTerm s) with
          | left _ =>
              let nv := newVar (v :: freeVarTerm s ++ freeVarFormula f) in
              match frec f (depthForall L f n) (n, var nv) with
              | exist f' prf1 =>
                  match
                    frec f'
                      (eqDepth L f' f (forallH n f) 
                         (sym_eq prf1) (depthForall L f n)) p
                  with
                  | exist f'' prf2 =>
                      exist
                        (fun y : fol.Formula L => depth L y = S (depth L f))
                        (forallH nv f'')
                        (eq_ind_r (fun n : nat => S n = S (depth L f))
                           (refl_equal (S (depth L f))) 
                           (trans_eq prf2 prf1))
                  end
              end
          | right _ =>
              match frec f (depthForall L f n) p with
              | exist f' prf1 =>
                  exist (fun y : fol.Formula L => depth L y = S (depth L f))
                    (forallH n f')
                    (eq_ind_r (fun n : nat => S n = S (depth L f))
                       (refl_equal (S (depth L f))) prf1)
              end
          end
      end
  end.

Remark substituteFormulaForallNice :
 forall (v : nat) (a : fol.Formula L)

Definition substituteFormulaHelp (f : fol.Formula L) 

Definition substituteFormula (f : fol.Formula L) (v : nat) 
  (s : fol.Term L) : fol.Formula L := proj1_sig (substituteFormulaHelp f v s).

Lemma subFormulaEqual :
 forall (t1 t2 : fol.Term L) (v : nat) (s : fol.Term L),

Lemma subFormulaRelation :
 forall (r : Relations L) (ts : fol.Terms L (arity L (inl _ r))) 

Lemma subFormulaImp :
 forall (f1 f2 : fol.Formula L) (v : nat) (s : fol.Term L),

Lemma subFormulaNot :
 forall (f : fol.Formula L) (v : nat) (s : fol.Term L),

Lemma subFormulaForall :
 forall (f : fol.Formula L) (x v : nat) (s : fol.Term L),

Section Extensions.

Let orH := orH L.
Let andH := andH L.
Let existH := existH L.
Let iffH := iffH L.
Let ifThenElseH := ifThenElseH L.

Lemma subFormulaOr :
 forall (f1 f2 : fol.Formula L) (v : nat) (s : fol.Term L),

Lemma subFormulaAnd :
 forall (f1 f2 : fol.Formula L) (v : nat) (s : fol.Term L),

Lemma subFormulaExist :
 forall (f : fol.Formula L) (x v : nat) (s : fol.Term L),

Lemma subFormulaIff :
 forall (f1 f2 : fol.Formula L) (v : nat) (s : fol.Term L),

Lemma subFormulaIfThenElse :
 forall (f1 f2 f3 : fol.Formula L) (v : nat) (s : fol.Term L),

End Extensions.

Lemma subFormulaDepth :
 forall (f : fol.Formula L) (v : nat) (s : fol.Term L),

Section Substitution_Properties.

Lemma subTermId :
 forall (t : fol.Term L) (v : nat), substituteTerm t v (var v) = t.

Lemma subTermsId :
 forall (n : nat) (ts : fol.Terms L n) (v : nat),

Lemma subFormulaId :
 forall (f : fol.Formula L) (v : nat), substituteFormula f v (var v) = f.

Lemma subFormulaForall2 :
 forall (f : fol.Formula L) (x v : nat) (s : fol.Term L),

Let existH := existH L.

Lemma subFormulaExist2 :
 forall (f : fol.Formula L) (x v : nat) (s : fol.Term L),

End Substitution_Properties.

End Substitution.
 
Definition Sentence (f:Formula) := (forall v : nat, ~ In v (freeVarFormula f)).

End Fol_Properties. *)

Require Import folLogic3.
(* folLogic3:
Require Import Ensembles.
Require Import Coq.Lists.List.
Require Import ListExt.

Require Import folProp.
Require Import folProof.
Require Export folLogic2.
Require Import subProp.
Require Import folReplace.
Require Import Arith.
Require Import subAll.
Require Import misc.

Unset Standard Proposition Elimination Names.

Section Equality_Logic_Rules.

Variable L : Language.
Notation Formula := (Formula L) (only parsing).
Notation Formulas := (Formulas L) (only parsing).
Notation System := (System L) (only parsing).
Notation Term := (Term L) (only parsing).
Notation Terms := (Terms L) (only parsing).
Let var := var L.
Let apply := apply L.
Let equal := equal L.
Let atomic := atomic L.
Let impH := impH L.
Let notH := notH L.
Let forallH := forallH L.
Let orH := orH L.
Let andH := andH L.
Let existH := existH L.
Let iffH := iffH L.
Let ifThenElseH := ifThenElseH L.
Let Prf := Prf L.
Let SysPrf := SysPrf L.

Lemma eqRefl :
 forall (T : fol.System L) (a : fol.Term L), SysPrf T (equal a a).

Lemma eqSym :
 forall (T : fol.System L) (a b : fol.Term L),

Lemma eqTrans :
 forall (T : fol.System L) (a b c : fol.Term L),

Fixpoint PairwiseEqual (T : fol.System L) (n : nat) {struct n} :
 fol.Terms L n -> fol.Terms L n -> Prop :=
  match n return (fol.Terms L n -> fol.Terms L n -> Prop) with
  | O => fun ts ss : fol.Terms L 0 => True
  | S x =>
      fun ts ss : fol.Terms L (S x) =>
      let (a, b) := proj1_sig (consTerms L x ts) in
      let (c, d) := proj1_sig (consTerms L x ss) in
      SysPrf T (equal a c) /\ PairwiseEqual T x b d
  end.

Let termsMap (m : nat) (ts ss : fol.Terms L m) : nat -> fol.Term L.

Remark subAllnVars1 :
 forall (a : nat) (ts ss : fol.Terms L a),

Remark subAllnVars2 :
 forall (a : nat) (ts ss : fol.Terms L a),

Remark addPairwiseEquals :
 forall (T : fol.System L) (n : nat) (ts ss : fol.Terms L n),

Lemma equalRelation :
 forall (T : fol.System L) (r : Relations L) (ts ss : fol.Terms L _),

Lemma equalFunction :
 forall (T : fol.System L) (f : Functions L) (ts ss : fol.Terms L _),

Lemma subWithEqualsTerm :
 forall (a b t : fol.Term L) (v : nat) (T : fol.System L),

Lemma subWithEqualsTerms :
 forall (a b : fol.Term L) (n : nat) (ts : fol.Terms L n) 

Lemma subWithEquals :
 forall (f : fol.Formula L) (v : nat) (a b : fol.Term L) (T : fol.System L),

End Equality_Logic_Rules. *)



Definition Formula := Formula LNN.

Definition Formulas := Formulas LNN.

Definition System := System LNN.

Definition Sentence := Sentence LNN.

Definition Term := Term LNN.

Definition Terms := Terms LNN.

Definition var := var LNN.

Definition equal := equal LNN.

Definition impH := impH LNN.

Definition notH := notH LNN.

Definition iffH := iffH LNN.

Definition forallH := forallH LNN.

Definition orH := orH LNN.

Definition andH := andH LNN.

Definition existH := existH LNN.

Definition ifThenElseH := ifThenElseH LNN.

Definition SysPrf := SysPrf LNN.



Definition Plus (x y : Term) : Term :=

  apply LNN Plus (Tcons LNN 1 x (Tcons LNN 0 y (Tnil LNN))).



Definition Times (x y : Term) : Term :=

  apply LNN Times (Tcons LNN 1 x (Tcons LNN 0 y (Tnil LNN))).



Definition Succ (x : Term) : Term :=

  apply LNN Succ (Tcons LNN 0 x (Tnil LNN)).



Definition Zero : Term := apply LNN Zero (Tnil LNN).



Definition LT (x y : Term) : Formula :=

  atomic LNN LT (Tcons LNN 1 x (Tcons LNN 0 y (Tnil LNN))). 



Lemma LNN_dec : language_decideable LNN.

Proof.

unfold language_decideable in |- *.

split; decide equality.

Qed.



Section Free_Variables.



Lemma freeVarPlus :

 forall x y : Term,

 freeVarTerm LNN (Plus x y) = freeVarTerm LNN x ++ freeVarTerm LNN y.

Proof.

intros.

rewrite (app_nil_end (freeVarTerm LNN y)).

reflexivity.

Qed.



Lemma freeVarTimes :

 forall x y : Term,

 freeVarTerm LNN (Times x y) = freeVarTerm LNN x ++ freeVarTerm LNN y.

Proof.

intros.

rewrite (app_nil_end (freeVarTerm LNN y)).

reflexivity.

Qed.



Lemma freeVarSucc :

 forall x : Term, freeVarTerm LNN (Succ x) = freeVarTerm LNN x.

Proof.

intros.

rewrite (app_nil_end (freeVarTerm LNN x)).

reflexivity.

Qed.



Lemma freeVarZero : freeVarTerm LNN Zero = nil.

Proof.

reflexivity.

Qed.



Lemma freeVarLT :

 forall x y : Term,

 freeVarFormula LNN (LT x y) = freeVarTerm LNN x ++ freeVarTerm LNN y.

Proof.

intros.

rewrite (app_nil_end (freeVarTerm LNN y)).

reflexivity.

Qed.



End Free_Variables.



Section Logic.



Lemma Axm :

 forall (T : System) (f : Formula), mem _ T f -> SysPrf T f.

Proof.

apply (Axm LNN).

Qed.



Lemma sysExtend :

 forall (T U : System) (f : Formula),

 Included _ T U -> SysPrf T f -> SysPrf U f.

Proof.

apply (sysExtend LNN).

Qed.



Lemma sysWeaken :

 forall (T : System) (f g : Formula), SysPrf T f -> SysPrf (Ensembles.Add _ T g) f.

Proof.

apply (sysWeaken LNN).

Qed.



Lemma impI :

 forall (T : System) (f g : Formula),

 SysPrf (Ensembles.Add _ T g) f -> SysPrf T (impH g f).

Proof.

apply (impI LNN).

Qed.



Lemma impE :

 forall (T : System) (f g : Formula),

 SysPrf T (impH g f) -> SysPrf T g -> SysPrf T f.

Proof.

apply (impE LNN).

Qed.



Lemma contradiction :

 forall (T : System) (f g : Formula),

 SysPrf T f -> SysPrf T (notH f) -> SysPrf T g.

Proof.

apply (contradiction LNN).

Qed.



Lemma nnE :

 forall (T : System) (f : Formula), SysPrf T (notH (notH f)) -> SysPrf T f.

Proof.

apply (nnE LNN).

Qed.



Lemma noMiddle : forall (T : System) (f : Formula), SysPrf T (orH (notH f) f).

Proof.

apply (noMiddle LNN).

Qed.



Lemma nnI :

 forall (T : System) (f : Formula), SysPrf T f -> SysPrf T (notH (notH f)).

Proof.

apply (nnI LNN).

Qed.



Lemma cp1 :

 forall (T : System) (f g : Formula),

 SysPrf T (impH (notH f) (notH g)) -> SysPrf T (impH g f).

Proof.

apply (cp1 LNN).

Qed.



Lemma cp2 :

 forall (T : System) (f g : Formula),

 SysPrf T (impH g f) -> SysPrf T (impH (notH f) (notH g)).

Proof.

apply (cp2 LNN).

Qed.



Lemma orI1 :

 forall (T : System) (f g : Formula), SysPrf T f -> SysPrf T (orH f g).

Proof.

apply (orI1 LNN).

Qed.



Lemma orI2 :

 forall (T : System) (f g : Formula), SysPrf T g -> SysPrf T (orH f g).

Proof.

apply (orI2 LNN).

Qed.



Lemma orE :

 forall (T : System) (f g h : Formula),

 SysPrf T (orH f g) ->

 SysPrf T (impH f h) -> SysPrf T (impH g h) -> SysPrf T h.

Proof.

apply (orE LNN).

Qed.



Lemma orSys :

 forall (T : System) (f g h : Formula),

 SysPrf (Ensembles.Add _ T f) h -> SysPrf (Ensembles.Add _ T g) h -> SysPrf (Ensembles.Add _ T (orH f g)) h.

Proof.

apply (orSys LNN).

Qed.



Lemma andI :

 forall (T : System) (f g : Formula),

 SysPrf T f -> SysPrf T g -> SysPrf T (andH f g).

Proof.

apply (andI LNN).

Qed.



Lemma andE1 :

 forall (T : System) (f g : Formula), SysPrf T (andH f g) -> SysPrf T f.

Proof.

apply (andE1 LNN).

Qed.



Lemma andE2 :

 forall (T : System) (f g : Formula), SysPrf T (andH f g) -> SysPrf T g.

Proof.

apply (andE2 LNN).

Qed.



Lemma iffI :

 forall (T : System) (f g : Formula),

 SysPrf T (impH f g) -> SysPrf T (impH g f) -> SysPrf T (iffH f g).

Proof.

apply (iffI LNN).

Qed.



Lemma iffE1 :

 forall (T : System) (f g : Formula),

 SysPrf T (iffH f g) -> SysPrf T (impH f g).

Proof.

apply (iffE1 LNN).

Qed.



Lemma iffE2 :

 forall (T : System) (f g : Formula),

 SysPrf T (iffH f g) -> SysPrf T (impH g f).

Proof.

apply (iffE2 LNN).

Qed.



Lemma forallI :

 forall (T : System) (f : Formula) (v : nat),

 ~ In_freeVarSys LNN v T -> SysPrf T f -> SysPrf T (forallH v f).

Proof.

apply (forallI LNN).

Qed.



Lemma forallE :

 forall (T : System) (f : Formula) (v : nat) (t : Term),

 SysPrf T (forallH v f) -> SysPrf T (substituteFormula LNN f v t).

Proof.

apply (forallE LNN).

Qed.



Lemma forallSimp :

 forall (T : System) (f : Formula) (v : nat),

 SysPrf T (forallH v f) -> SysPrf T f.

Proof.

apply (forallSimp LNN).

Qed.



Lemma existI :

 forall (T : System) (f : Formula) (v : nat) (t : Term),

 SysPrf T (substituteFormula LNN f v t) -> SysPrf T (existH v f).

Proof.

apply (existI LNN).

Qed.



Lemma existE :

 forall (T : System) (f g : Formula) (v : nat),

 ~ In_freeVarSys LNN v T ->

 ~ In v (freeVarFormula LNN g) ->

 SysPrf T (existH v f) -> SysPrf T (impH f g) -> SysPrf T g.

Proof.

apply (existE LNN).

Qed.



Lemma existSimp :

 forall (T : System) (f : Formula) (v : nat),

 SysPrf T f -> SysPrf T (existH v f).

Proof.

apply (existSimp LNN).

Qed.



Lemma existSys :

 forall (T : System) (f g : Formula) (v : nat),

 ~ In_freeVarSys LNN v T ->

 ~ In v (freeVarFormula LNN g) ->

 SysPrf (Ensembles.Add _ T f) g -> SysPrf (Ensembles.Add _ T (existH v f)) g.

Proof.

apply (existSys LNN).

Qed.



Lemma absurd1 :

 forall (T : System) (f : Formula),

 SysPrf T (impH f (notH f)) -> SysPrf T (notH f).

Proof. 

apply (absurd1 LNN).

Qed.



Lemma nImp :

 forall (T : System) (f g : Formula),

 SysPrf T (andH f (notH g)) -> SysPrf T (notH (impH f g)).

Proof.

apply (nImp LNN).

Qed.



Lemma nOr :

 forall (T : System) (f g : Formula),

 SysPrf T (andH (notH f) (notH g)) -> SysPrf T (notH (orH f g)).

Proof.

apply (nOr LNN).

Qed.



Lemma nAnd :

 forall (T : System) (f g : Formula),

 SysPrf T (orH (notH f) (notH g)) -> SysPrf T (notH (andH f g)).

Proof.

apply (nAnd LNN).

Qed.



Lemma nForall :

 forall (T : System) (f : Formula) (v : nat),

 SysPrf T (existH v (notH f)) -> SysPrf T (notH (forallH v f)).

Proof.

apply (nForall LNN).

Qed.



Lemma nExist :

 forall (T : System) (f : Formula) (v : nat),

 SysPrf T (forallH v (notH f)) -> SysPrf T (notH (existH v f)).

Proof.

apply (nExist LNN).

Qed.



Lemma impRefl : forall (T : System) (f : Formula), SysPrf T (impH f f).

Proof.

apply (impRefl LNN).

Qed.



Lemma impTrans :

 forall (T : System) (f g h : Formula),

 SysPrf T (impH f g) -> SysPrf T (impH g h) -> SysPrf T (impH f h).

Proof.

apply (impTrans LNN).

Qed.



Lemma orSym :

 forall (T : System) (f g : Formula),

 SysPrf T (orH f g) -> SysPrf T (orH g f).

Proof.

apply (orSym LNN).

Qed.



Lemma andSym :

 forall (T : System) (f g : Formula),

 SysPrf T (andH f g) -> SysPrf T (andH g f).

Proof.

apply (andSym LNN).

Qed.



Lemma iffRefl : forall (T : System) (f : Formula), SysPrf T (iffH f f).

Proof.

apply (iffRefl LNN).

Qed.



Lemma iffSym :

 forall (T : System) (f g : Formula),

 SysPrf T (iffH f g) -> SysPrf T (iffH g f).

Proof.

apply (iffSym LNN).

Qed.



Lemma iffTrans :

 forall (T : System) (f g h : Formula),

 SysPrf T (iffH f g) -> SysPrf T (iffH g h) -> SysPrf T (iffH f h).

Proof.

apply (iffTrans LNN).

Qed.



Lemma eqRefl : forall (T : System) (a : Term), SysPrf T (equal a a).

Proof.

apply (eqRefl LNN).

Qed.



Lemma eqSym :

 forall (T : System) (a b : Term),

 SysPrf T (equal a b) -> SysPrf T (equal b a).

Proof.

apply (eqSym LNN).

Qed.



Lemma eqTrans :

 forall (T : System) (a b c : Term),

 SysPrf T (equal a b) -> SysPrf T (equal b c) -> SysPrf T (equal a c).

Proof.

apply (eqTrans LNN).

Qed.



Lemma eqPlus :

 forall (T : System) (a b c d : Term),

 SysPrf T (equal a b) ->

 SysPrf T (equal c d) -> SysPrf T (equal (Plus a c) (Plus b d)).

Proof.

intros.

unfold Plus in |- *.

apply (equalFunction LNN).

simpl in |- *.

induction (consTerms LNN 1 (Tcons LNN 1 a (Tcons LNN 0 c (Tnil LNN)))).

induction x as (a0, b0).

simpl in |- *.

induction (consTerms LNN 1 (Tcons LNN 1 b (Tcons LNN 0 d (Tnil LNN)))).

induction x as (a1, b1).

simpl in |- *.

induction (consTerms LNN 0 b0).

induction x as (a2, b2).

simpl in |- *.

induction (consTerms LNN 0 b1).

induction x as (a3, b3).

simpl in |- *.

repeat split.

simpl in p.

inversion p.

simpl in p0.

inversion p0.

apply H.

simpl in p.

inversion p.

rewrite <- p1 in H3.

simpl in H3.

inversion H3.

simpl in p0.

inversion p0.

rewrite <- p2 in H7.

inversion H7.

apply H0.

Qed.



Lemma eqTimes :

 forall (T : System) (a b c d : Term),

 SysPrf T (equal a b) ->

 SysPrf T (equal c d) -> SysPrf T (equal (Times a c) (Times b d)).

Proof.

intros.

unfold Times in |- *.

apply (equalFunction LNN).

simpl in |- *.

induction (consTerms LNN 1 (Tcons LNN 1 a (Tcons LNN 0 c (Tnil LNN)))).

induction x as (a0, b0).

simpl in |- *.

induction (consTerms LNN 1 (Tcons LNN 1 b (Tcons LNN 0 d (Tnil LNN)))).

induction x as (a1, b1).

simpl in |- *.

induction (consTerms LNN 0 b0).

induction x as (a2, b2).

simpl in |- *.

induction (consTerms LNN 0 b1).

induction x as (a3, b3).

simpl in |- *.

repeat split.

simpl in p.

inversion p.

simpl in p0.

inversion p0.

apply H.

simpl in p.

inversion p.

rewrite <- p1 in H3.

simpl in H3.

inversion H3.

simpl in p0.

inversion p0.

rewrite <- p2 in H7.

inversion H7.

apply H0.

Qed.



Lemma eqSucc :

 forall (T : System) (a b : Term),

 SysPrf T (equal a b) -> SysPrf T (equal (Succ a) (Succ b)).

Proof.

intros.

unfold Succ in |- *.

apply (equalFunction LNN).

simpl in |- *.

induction (consTerms LNN 0 (Tcons LNN 0 a (Tnil LNN))).

induction x as (a0, b0).

simpl in |- *.

induction (consTerms LNN 0 (Tcons LNN 0 b (Tnil LNN))).

induction x as (a1, b1).

simpl in |- *.

repeat split.

simpl in p.

inversion p.

simpl in p0.

inversion p0.

apply H.

Qed.



Lemma eqLT :

 forall (T : System) (a b c d : Term),

 SysPrf T (equal a b) ->

 SysPrf T (equal c d) -> SysPrf T (iffH (LT a c) (LT b d)).

Proof.

intros.

unfold LT in |- *.

apply (equalRelation LNN).

simpl in |- *.

induction (consTerms LNN 1 (Tcons LNN 1 a (Tcons LNN 0 c (Tnil LNN)))).

induction x as (a0, b0).

simpl in |- *.

induction (consTerms LNN 1 (Tcons LNN 1 b (Tcons LNN 0 d (Tnil LNN)))).

induction x as (a1, b1).

simpl in |- *.

induction (consTerms LNN 0 b0).

induction x as (a2, b2).

simpl in |- *.

induction (consTerms LNN 0 b1).

induction x as (a3, b3).

simpl in |- *.

repeat split.

simpl in p.

inversion p.

simpl in p0.

inversion p0.

apply H.

simpl in p.

inversion p.

rewrite <- p1 in H3.

simpl in H3.

inversion H3.

simpl in p0.

inversion p0.

rewrite <- p2 in H7.

inversion H7.

apply H0.

Qed.



End Logic.



Fixpoint natToTerm (n : nat) : Term :=

  match n with

  | O => Zero

  | S m => Succ (natToTerm m)

  end.



Lemma closedNatToTerm :

 forall a v : nat, ~ In v (freeVarTerm LNN (natToTerm a)).

Proof.

intros.

induction a as [| a Hreca].

auto.

simpl in |- *.

rewrite freeVarSucc.

auto.

Qed.

