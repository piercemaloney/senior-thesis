Require Import Ensembles.
Require Import Coq.Lists.List.
Require Import Arith.

Require Import subAll.
(* subAll:
Require Import Ensembles.
Require Import Coq.Lists.List.
Require Import Arith.
Require Import Peano_dec.
Require Import ListExt.
Require Import Max.

Require Import folProof.
Require Import folLogic2.
Require Import folProp.
Require Import folReplace.
Require Import subProp.

Section SubAllVars.

Variable L : Language.
Notation Formula := (Formula L) (only parsing).
Notation Formulas := (Formulas L) (only parsing).
Notation System := (System L) (only parsing).
Notation Term := (Term L) (only parsing).
Notation Terms := (Terms L) (only parsing).
Notation var := (var L) (only parsing).
Notation apply := (apply L) (only parsing).
Notation equal := (equal L) (only parsing).
Notation atomic := (atomic L) (only parsing).
Notation impH := (impH L) (only parsing).
Notation notH := (notH L) (only parsing).
Notation forallH := (forallH L) (only parsing).
Notation iffH := (iffH L) (only parsing).
Notation SysPrf := (SysPrf L) (only parsing).

Fixpoint subAllTerm (t : fol.Term L) : (nat -> fol.Term L) -> fol.Term L :=
  match t return ((nat -> fol.Term L) -> fol.Term L) with
  | fol.var x => fun m => m x
  | fol.apply f ts => fun m => fol.apply L f (subAllTerms _ ts m)
  end
 
 with subAllTerms (n : nat) (ts : fol.Terms L n) {struct ts} :
 (nat -> fol.Term L) -> fol.Terms L n :=
  match
    ts in (fol.Terms _ n) return ((nat -> fol.Term L) -> fol.Terms L n)
  with
  | Tnil => fun _ => Tnil L
  | Tcons n' t ss =>
      fun m => Tcons L n' (subAllTerm t m) (subAllTerms _ ss m)
  end.

Lemma subAllTerm_ext :
 forall (t : fol.Term L) (m1 m2 : nat -> fol.Term L),

Lemma subAllTerms_ext :
 forall (n : nat) (ts : fol.Terms L n) (m1 m2 : nat -> fol.Term L),

Fixpoint freeVarMap (l : list nat) : (nat -> fol.Term L) -> list nat :=
  match l with
  | nil => fun _ => nil
  | a :: l' => fun m => freeVarTerm L (m a) ++ freeVarMap l' m
  end.

Lemma freeVarMap_ext :
 forall (l : list nat) (f1 f2 : nat -> fol.Term L),

Lemma freeVarMap1 :
 forall (l : list nat) (m : nat -> fol.Term L) (v n : nat),

Fixpoint subAllFormula (f : Formula) (m : (nat -> Term)) {struct f} : Formula :=
  match f with
  | fol.equal t s => equal (subAllTerm t m) (subAllTerm s m)
  | fol.atomic r ts => atomic r (subAllTerms _ ts m)
  | fol.impH f g =>
      impH (subAllFormula f m) (subAllFormula g m)
  | fol.notH f => notH (subAllFormula f m)
  | fol.forallH n f =>
      let nv :=
        newVar
          (freeVarFormula L f ++
           freeVarMap (freeVarFormula L (forallH n f)) m) in
      forallH nv
        (subAllFormula f
           (fun v : nat =>
            match eq_nat_dec v n with
            | left _ => var nv
            | right _ => m v
            end))
  end.

Lemma subAllFormula_ext :
 forall (f : fol.Formula L) (m1 m2 : nat -> fol.Term L),

Lemma freeVarSubAllTerm1 :
 forall (t : fol.Term L) (m : nat -> fol.Term L) (v : nat),

Lemma freeVarSubAllTerms1 :
 forall (n : nat) (ts : fol.Terms L n) (m : nat -> fol.Term L) (v : nat),

Lemma freeVarSubAllTerm2 :
 forall (t : fol.Term L) (m : nat -> fol.Term L) (v n : nat),

Lemma freeVarSubAllTerms2 :
 forall (a : nat) (ts : fol.Terms L a) (m : nat -> fol.Term L) (v n : nat),

Lemma freeVarSubAllFormula1 :
 forall (f : fol.Formula L) (m : nat -> fol.Term L) (v : nat),

Lemma freeVarSubAllFormula2 :
 forall (f : fol.Formula L) (m : nat -> fol.Term L) (v n : nat),

Lemma subSubAllTerm :
 forall (t : fol.Term L) (m : nat -> fol.Term L) (v : nat) (s : fol.Term L),

Lemma subSubAllTerms :
 forall (n : nat) (ts : fol.Terms L n) (m : nat -> fol.Term L) 

Lemma subSubAllFormula :
 forall (T : fol.System L) (f : fol.Formula L) (m : nat -> fol.Term L)

Lemma subAllTermId :
 forall t : fol.Term L, subAllTerm t (fun x : nat => fol.var L x) = t.

Lemma subAllTermsId :
 forall (n : nat) (ts : fol.Terms L n),

Lemma subAllFormulaId :
 forall (T : fol.System L) (f : fol.Formula L),

Lemma subAllSubAllTerm :
 forall (t : fol.Term L) (m1 m2 : nat -> fol.Term L),

Lemma subAllSubAllTerms :
 forall (n : nat) (ts : fol.Terms L n) (m1 m2 : nat -> fol.Term L),

Lemma subAllSubAllFormula :
 forall (T : fol.System L) (f : fol.Formula L) (m1 m2 : nat -> fol.Term L),

Section subAllCloseFrom.

Fixpoint closeFrom (a n : nat) (f : fol.Formula L) {struct n} :
 fol.Formula L :=
  match n with
  | O => f
  | S m => fol.forallH L (a + m) (closeFrom a m f)
  end.

Opaque le_lt_dec.

Lemma liftCloseFrom :
 forall (n : nat) (f : fol.Formula L) (T : fol.System L) (m : nat),

Lemma subAllCloseFrom1 :
 forall (n m : nat) (map : nat -> fol.Term L) (f : fol.Formula L)

Lemma subAllCloseFrom :
 forall (n : nat) (m : nat -> fol.Term L) (f : fol.Formula L)

Lemma reduceSubAll :
 forall (T : fol.System L) (map : nat -> fol.Term L) (A B : fol.Formula L),

End subAllCloseFrom.

Lemma subToSubAll :
 forall (T : fol.System L) (A : fol.Formula L) (v : nat) (s : fol.Term L),

Lemma subAllSubFormula :
 forall (T : fol.System L) (A : fol.Formula L) (v : nat) 

End SubAllVars. *)
Require Import folReplace.
(* folReplace:
Require Import Ensembles.
Require Import Coq.Lists.List.
Require Import Peano_dec.

Require Import ListExt.
Require Import folProof.
Require Import folLogic.
Require Import folProp.

Section Replacement.

Variable L : Language.
Let Formula := Formula L.
Let Formulas := Formulas L.
Let System := System L.
Let Term := Term L.
Let Terms := Terms L.
Let var := var L.
Let apply := apply L.
Let equal := equal L.
Let atomic := atomic L.
Let impH := impH L.
Let notH := notH L.
Let forallH := forallH L.
Let orH := orH L.
Let andH := andH L.
Let existH := existH L.
Let iffH := iffH L.
Let ifThenElseH := ifThenElseH L.
Let SysPrf := SysPrf L.

Lemma reduceImp :
 forall (f1 f2 f3 f4 : Formula) (T : System),
 SysPrf T (iffH f1 f3) ->
 SysPrf T (iffH f2 f4) -> SysPrf T (iffH (impH f1 f2) (impH f3 f4)).

Lemma reduceNot :
 forall (f1 f2 : Formula) (T : System),
 SysPrf T (iffH f1 f2) -> SysPrf T (iffH (notH f1) (notH f2)).

Lemma impForall :
 forall (f1 f2 : Formula) (v : nat) (T : System),
 ~ In_freeVarSys _ v T ->
 SysPrf T (impH f1 f2) -> SysPrf T (impH (forallH v f1) (forallH v f2)).

Lemma reduceForall :
 forall (f1 f2 : Formula) (v : nat) (T : System),
 ~ In_freeVarSys _ v T ->
 SysPrf T (iffH f1 f2) -> SysPrf T (iffH (forallH v f1) (forallH v f2)).

Lemma reduceOr :
 forall (f1 f2 f3 f4 : Formula) (T : System),
 SysPrf T (iffH f1 f3) ->
 SysPrf T (iffH f2 f4) -> SysPrf T (iffH (orH f1 f2) (orH f3 f4)).

Lemma reduceAnd :
 forall (f1 f2 f3 f4 : Formula) (T : System),
 SysPrf T (iffH f1 f3) ->
 SysPrf T (iffH f2 f4) -> SysPrf T (iffH (andH f1 f2) (andH f3 f4)).

Lemma iffExist :
 forall (f1 f2 : Formula) (v : nat) (T : System),
 ~ In_freeVarSys _ v T ->
 SysPrf T (impH f1 f2) -> SysPrf T (impH (existH v f1) (existH v f2)).

Lemma reduceExist :
 forall (f1 f2 : Formula) (v : nat) (T : System),
 ~ In_freeVarSys _ v T ->
 SysPrf T (iffH f1 f2) -> SysPrf T (iffH (existH v f1) (existH v f2)).

Lemma reduceIff :
 forall (f1 f2 f3 f4 : Formula) (T : System),
 SysPrf T (iffH f1 f3) ->
 SysPrf T (iffH f2 f4) -> SysPrf T (iffH (iffH f1 f2) (iffH f3 f4)).

Lemma reduceIfThenElse :
 forall (f1 f2 f3 f4 f5 f6 : Formula) (T : System),
 SysPrf T (iffH f1 f4) ->
 SysPrf T (iffH f2 f5) ->
 SysPrf T (iffH f3 f6) ->
 SysPrf T (iffH (ifThenElseH f1 f2 f3) (ifThenElseH f4 f5 f6)).

Lemma reduceSub :
 forall (T : System) (v : nat) (s : Term) (f g : Formula),
 ~ In_freeVarSys L v T ->
 SysPrf T (iffH f g) ->
 SysPrf T (iffH (substituteFormula L f v s) (substituteFormula L g v s)).

Lemma reduceCloseList :
 forall (l : list nat) (f1 f2 : Formula) (T : System),
 (forall v : nat, In v l -> ~ In_freeVarSys _ v T) ->
 SysPrf T (iffH f1 f2) ->
 SysPrf T (iffH (closeList L l f1) (closeList L l f2)).

End Replacement. *)
Require Import folProp.
(* folProp:
Require Import Wf_nat.
Require Import Max.
Require Import Arith.
Require Import Coq.Lists.List.
Require Import ListExt.
Require Import Peano_dec.

Require Export fol.

Section Fol_Properties.

Variable L : Language.

Notation Formula := (Formula L) (only parsing).
Notation Formulas := (Formulas L) (only parsing).
Notation System := (System L) (only parsing).
Notation Term := (Term L) (only parsing).
Notation Terms := (Terms L) (only parsing).
Let var := var L.
Let apply := apply L.
Let equal := equal L.
Let atomic := atomic L.
Let impH := impH L.
Let notH := notH L.
Let forallH := forallH L.
Let lt_depth := lt_depth L.

Section Free_Variables.

Fixpoint freeVarTerm (s : fol.Term L) : list nat :=
  match s with
  | fol.var v => v :: nil
  | fol.apply f ts => freeVarTerms (arity L (inr _ f)) ts
  end
 
 with freeVarTerms (n : nat) (ss : fol.Terms L n) {struct ss} : 
 list nat :=
  match ss with
  | Tnil => nil (A:=nat)
  | Tcons m t ts => freeVarTerm t ++ freeVarTerms m ts
  end.

Lemma freeVarTermApply :
 forall (f : Functions L) (ts : fol.Terms L _),

Fixpoint freeVarFormula (A : fol.Formula L) : list nat :=
  match A with
  | fol.equal t s => freeVarTerm t ++ freeVarTerm s
  | fol.atomic r ts => freeVarTerms _ ts
  | fol.impH A B => freeVarFormula A ++ freeVarFormula B
  | fol.notH A => freeVarFormula A
  | fol.forallH v A => list_remove _ eq_nat_dec v (freeVarFormula A)
  end.

Definition ClosedSystem (T : fol.System L) :=
  forall (v : nat) (f : fol.Formula L),
  mem _ T f -> ~ In v (freeVarFormula f).

Definition closeList (l : list nat) (x : fol.Formula L) : 
  fol.Formula L :=
  list_rec (fun _ => fol.Formula L) x
    (fun (a : nat) _ (rec : fol.Formula L) => forallH a rec) l.

Definition close (x : fol.Formula L) : fol.Formula L :=
  closeList (no_dup _ eq_nat_dec (freeVarFormula x)) x.

Lemma freeVarClosedList1 :
 forall (l : list nat) (v : nat) (x : fol.Formula L),

Lemma freeVarClosedList2 :
 forall (l : list nat) (v : nat) (x : fol.Formula L),

Lemma freeVarClosed :
 forall (x : fol.Formula L) (v : nat), ~ In v (freeVarFormula (close x)).

Fixpoint freeVarListFormula (l : fol.Formulas L) : 
 list nat :=
  match l with
  | nil => nil (A:=nat)
  | f :: l => freeVarFormula f ++ freeVarListFormula l
  end.

Lemma freeVarListFormulaApp :
 forall a b : fol.Formulas L,

Lemma In_freeVarListFormula :
 forall (v : nat) (f : fol.Formula L) (F : fol.Formulas L),

Lemma In_freeVarListFormulaE :
 forall (v : nat) (F : fol.Formulas L),

Definition In_freeVarSys (v : nat) (T : fol.System L) :=
  exists f : fol.Formula L, In v (freeVarFormula f) /\ mem _ T f.

Lemma notInFreeVarSys :
 forall x, ~ In_freeVarSys x (Ensembles.Empty_set (fol.Formula L)).

End Free_Variables.

Section Substitution.

Fixpoint substituteTerm (s : fol.Term L) (x : nat) 
 (t : fol.Term L) {struct s} : fol.Term L :=
  match s with
  | fol.var v =>
      match eq_nat_dec x v with
      | left _ => t
      | right _ => var v
      end
  | fol.apply f ts => apply f (substituteTerms _ ts x t)
  end
 
 with substituteTerms (n : nat) (ss : fol.Terms L n) 
 (x : nat) (t : fol.Term L) {struct ss} : fol.Terms L n :=
  match ss in (fol.Terms _ n0) return (fol.Terms L n0) with
  | Tnil => Tnil L
  | Tcons m s ts =>
      Tcons L m (substituteTerm s x t) (substituteTerms m ts x t)
  end.

Lemma subTermVar1 :
 forall (v : nat) (s : fol.Term L), substituteTerm (var v) v s = s.

Lemma subTermVar2 :
 forall (v x : nat) (s : fol.Term L),

Lemma subTermFunction :
 forall (f : Functions L) (ts : fol.Terms L (arity L (inr _ f))) 

Definition newVar (l : list nat) : nat := fold_right max 0 (map S l).

Lemma newVar2 : forall (l : list nat) (n : nat), In n l -> n < newVar l.

Lemma newVar1 : forall l : list nat, ~ In (newVar l) l.

Definition substituteFormulaImp (f : fol.Formula L)
  (frec : nat * fol.Term L -> {y : fol.Formula L | depth L y = depth L f})
  (g : fol.Formula L)
  (grec : nat * fol.Term L -> {y : fol.Formula L | depth L y = depth L g})
  (p : nat * fol.Term L) :
  {y : fol.Formula L | depth L y = depth L (impH f g)} :=
  match frec p with
  | exist f' prf1 =>
      match grec p with
      | exist g' prf2 =>
          exist
            (fun y : fol.Formula L =>
             depth L y = S (max (depth L f) (depth L g))) 
            (impH f' g')
            (eq_ind_r
               (fun n : nat =>
                S (max n (depth L g')) = S (max (depth L f) (depth L g)))
               (eq_ind_r
                  (fun n : nat =>
                   S (max (depth L f) n) = S (max (depth L f) (depth L g)))
                  (refl_equal (S (max (depth L f) (depth L g)))) prf2) prf1)
      end
  end.

Remark substituteFormulaImpNice :
 forall (f g : fol.Formula L)

Definition substituteFormulaNot (f : fol.Formula L)
  (frec : nat * fol.Term L -> {y : fol.Formula L | depth L y = depth L f})
  (p : nat * fol.Term L) :
  {y : fol.Formula L | depth L y = depth L (notH f)} :=
  match frec p with
  | exist f' prf1 =>
      exist (fun y : fol.Formula L => depth L y = S (depth L f)) 
        (notH f')
        (eq_ind_r (fun n : nat => S n = S (depth L f))
           (refl_equal (S (depth L f))) prf1)
  end.

Remark substituteFormulaNotNice :
 forall (f : fol.Formula L)

Definition substituteFormulaForall (n : nat) (f : fol.Formula L)
  (frec : forall b : fol.Formula L,
          lt_depth b (forallH n f) ->
          nat * fol.Term L -> {y : fol.Formula L | depth L y = depth L b})
  (p : nat * fol.Term L) :
  {y : fol.Formula L | depth L y = depth L (forallH n f)} :=
  match p with
  | (v, s) =>
      match eq_nat_dec n v with
      | left _ =>
          exist (fun y : fol.Formula L => depth L y = S (depth L f))
            (forallH n f) (refl_equal (depth L (forallH n f)))
      | right _ =>
          match In_dec eq_nat_dec n (freeVarTerm s) with
          | left _ =>
              let nv := newVar (v :: freeVarTerm s ++ freeVarFormula f) in
              match frec f (depthForall L f n) (n, var nv) with
              | exist f' prf1 =>
                  match
                    frec f'
                      (eqDepth L f' f (forallH n f) 
                         (sym_eq prf1) (depthForall L f n)) p
                  with
                  | exist f'' prf2 =>
                      exist
                        (fun y : fol.Formula L => depth L y = S (depth L f))
                        (forallH nv f'')
                        (eq_ind_r (fun n : nat => S n = S (depth L f))
                           (refl_equal (S (depth L f))) 
                           (trans_eq prf2 prf1))
                  end
              end
          | right _ =>
              match frec f (depthForall L f n) p with
              | exist f' prf1 =>
                  exist (fun y : fol.Formula L => depth L y = S (depth L f))
                    (forallH n f')
                    (eq_ind_r (fun n : nat => S n = S (depth L f))
                       (refl_equal (S (depth L f))) prf1)
              end
          end
      end
  end.

Remark substituteFormulaForallNice :
 forall (v : nat) (a : fol.Formula L)

Definition substituteFormulaHelp (f : fol.Formula L) 

Definition substituteFormula (f : fol.Formula L) (v : nat) 
  (s : fol.Term L) : fol.Formula L := proj1_sig (substituteFormulaHelp f v s).

Lemma subFormulaEqual :
 forall (t1 t2 : fol.Term L) (v : nat) (s : fol.Term L),

Lemma subFormulaRelation :
 forall (r : Relations L) (ts : fol.Terms L (arity L (inl _ r))) 

Lemma subFormulaImp :
 forall (f1 f2 : fol.Formula L) (v : nat) (s : fol.Term L),

Lemma subFormulaNot :
 forall (f : fol.Formula L) (v : nat) (s : fol.Term L),

Lemma subFormulaForall :
 forall (f : fol.Formula L) (x v : nat) (s : fol.Term L),

Section Extensions.

Let orH := orH L.
Let andH := andH L.
Let existH := existH L.
Let iffH := iffH L.
Let ifThenElseH := ifThenElseH L.

Lemma subFormulaOr :
 forall (f1 f2 : fol.Formula L) (v : nat) (s : fol.Term L),

Lemma subFormulaAnd :
 forall (f1 f2 : fol.Formula L) (v : nat) (s : fol.Term L),

Lemma subFormulaExist :
 forall (f : fol.Formula L) (x v : nat) (s : fol.Term L),

Lemma subFormulaIff :
 forall (f1 f2 : fol.Formula L) (v : nat) (s : fol.Term L),

Lemma subFormulaIfThenElse :
 forall (f1 f2 f3 : fol.Formula L) (v : nat) (s : fol.Term L),

End Extensions.

Lemma subFormulaDepth :
 forall (f : fol.Formula L) (v : nat) (s : fol.Term L),

Section Substitution_Properties.

Lemma subTermId :
 forall (t : fol.Term L) (v : nat), substituteTerm t v (var v) = t.

Lemma subTermsId :
 forall (n : nat) (ts : fol.Terms L n) (v : nat),

Lemma subFormulaId :
 forall (f : fol.Formula L) (v : nat), substituteFormula f v (var v) = f.

Lemma subFormulaForall2 :
 forall (f : fol.Formula L) (x v : nat) (s : fol.Term L),

Let existH := existH L.

Lemma subFormulaExist2 :
 forall (f : fol.Formula L) (x v : nat) (s : fol.Term L),

End Substitution_Properties.

End Substitution.
 
Definition Sentence (f:Formula) := (forall v : nat, ~ In v (freeVarFormula f)).

End Fol_Properties. *)
Require Import folLogic3.
(* folLogic3:
Require Import Ensembles.
Require Import Coq.Lists.List.
Require Import ListExt.

Require Import folProp.
Require Import folProof.
Require Export folLogic2.
Require Import subProp.
Require Import folReplace.
Require Import Arith.
Require Import subAll.
Require Import misc.

Unset Standard Proposition Elimination Names.

Section Equality_Logic_Rules.

Variable L : Language.
Notation Formula := (Formula L) (only parsing).
Notation Formulas := (Formulas L) (only parsing).
Notation System := (System L) (only parsing).
Notation Term := (Term L) (only parsing).
Notation Terms := (Terms L) (only parsing).
Let var := var L.
Let apply := apply L.
Let equal := equal L.
Let atomic := atomic L.
Let impH := impH L.
Let notH := notH L.
Let forallH := forallH L.
Let orH := orH L.
Let andH := andH L.
Let existH := existH L.
Let iffH := iffH L.
Let ifThenElseH := ifThenElseH L.
Let Prf := Prf L.
Let SysPrf := SysPrf L.

Lemma eqRefl :
 forall (T : fol.System L) (a : fol.Term L), SysPrf T (equal a a).

Lemma eqSym :
 forall (T : fol.System L) (a b : fol.Term L),

Lemma eqTrans :
 forall (T : fol.System L) (a b c : fol.Term L),

Fixpoint PairwiseEqual (T : fol.System L) (n : nat) {struct n} :
 fol.Terms L n -> fol.Terms L n -> Prop :=
  match n return (fol.Terms L n -> fol.Terms L n -> Prop) with
  | O => fun ts ss : fol.Terms L 0 => True
  | S x =>
      fun ts ss : fol.Terms L (S x) =>
      let (a, b) := proj1_sig (consTerms L x ts) in
      let (c, d) := proj1_sig (consTerms L x ss) in
      SysPrf T (equal a c) /\ PairwiseEqual T x b d
  end.

Let termsMap (m : nat) (ts ss : fol.Terms L m) : nat -> fol.Term L.

Remark subAllnVars1 :
 forall (a : nat) (ts ss : fol.Terms L a),

Remark subAllnVars2 :
 forall (a : nat) (ts ss : fol.Terms L a),

Remark addPairwiseEquals :
 forall (T : fol.System L) (n : nat) (ts ss : fol.Terms L n),

Lemma equalRelation :
 forall (T : fol.System L) (r : Relations L) (ts ss : fol.Terms L _),

Lemma equalFunction :
 forall (T : fol.System L) (f : Functions L) (ts ss : fol.Terms L _),

Lemma subWithEqualsTerm :
 forall (a b t : fol.Term L) (v : nat) (T : fol.System L),

Lemma subWithEqualsTerms :
 forall (a b : fol.Term L) (n : nat) (ts : fol.Terms L n) 

Lemma subWithEquals :
 forall (f : fol.Formula L) (v : nat) (a b : fol.Term L) (T : fol.System L),

End Equality_Logic_Rules. *)
Require Import NN.
(* NN:
Require Import Arith.
Require Import Ensembles.
Require Import Coq.Lists.List.

Require Import folProp.
Require Import subAll.
Require Import folLogic3.
Require Export Languages.
Require Export LNN.

Section NN.

Definition NN1 := forallH 0 (notH (equal (Succ (var 0)) Zero)).
Definition NN2 :=
  forallH 1
    (forallH 0
       (impH (equal (Succ (var 0)) (Succ (var 1))) (equal (var 0) (var 1)))).
Definition NN3 := forallH 0 (equal (Plus (var 0) Zero) (var 0)).
Definition NN4 :=
  forallH 1
    (forallH 0
       (equal (Plus (var 0) (Succ (var 1))) (Succ (Plus (var 0) (var 1))))).
Definition NN5 := forallH 0 (equal (Times (var 0) Zero) Zero).
Definition NN6 :=
  forallH 1
    (forallH 0
       (equal (Times (var 0) (Succ (var 1)))
          (Plus (Times (var 0) (var 1)) (var 0)))).
Definition NN7 := forallH 0 (notH (LT (var 0) Zero)).
Definition NN8 :=
  forallH 1
    (forallH 0
       (impH (LT (var 0) (Succ (var 1)))
          (orH (LT (var 0) (var 1)) (equal (var 0) (var 1))))).
Definition NN9 :=
  forallH 1
    (forallH 0
       (orH (LT (var 0) (var 1))
          (orH (equal (var 0) (var 1)) (LT (var 1) (var 0))))).
Definition NNStar :=
  forallH 1
    (forallH 0
       (impH (orH (LT (var 0) (var 1)) (equal (var 0) (var 1)))
          (LT (var 0) (Succ (var 1))))).

Definition NN :=
  Ensembles.Add _
    (Ensembles.Add _
       (Ensembles.Add _
          (Ensembles.Add _
             (Ensembles.Add _ (Ensembles.Add _ (Ensembles.Add _ (Ensembles.Add _ (Singleton _ NN1) NN2) NN3) NN4) NN5)
             NN6) NN7) NN8) NN9.

Lemma closedNN1 : ClosedSystem LNN NN.

Lemma closedNN : forall v : nat, ~ In_freeVarSys LNN v NN.

Lemma nn1 : forall a : Term, SysPrf NN (notH (equal (Succ a) Zero)).

Lemma nn2 :
 forall a b : Term, SysPrf NN (impH (equal (Succ a) (Succ b)) (equal a b)).

Lemma nn3 : forall a : Term, SysPrf NN (equal (Plus a Zero) a).

Lemma nn4 :
 forall a b : Term, SysPrf NN (equal (Plus a (Succ b)) (Succ (Plus a b))).

Lemma nn5 : forall a : Term, SysPrf NN (equal (Times a Zero) Zero).

Lemma nn6 :
 forall a b : Term, SysPrf NN (equal (Times a (Succ b)) (Plus (Times a b) a)).

Lemma nn7 : forall a : Term, SysPrf NN (notH (LT a Zero)).

Lemma nn8 :
 forall a b : Term,
 SysPrf NN (impH (LT a (Succ b)) (orH (LT a b) (equal a b))).

Lemma nn9 :
 forall a b : Term, SysPrf NN (orH (LT a b) (orH (equal a b) (LT b a))).

End NN. *)
Require Import LNN2LNT.
(* LNN2LNT:
Require Import Ensembles.
Require Import Coq.Lists.List.
Require Import Arith.
Require Import misc.

Require Import ListExt.
Require Import folProp.
Require Import folProof.
Require Import Languages.
Require Import subAll.
Require Import subProp.
Require Import folLogic3.
Require Import folReplace.
Require Import LNT.
Require Import Max.
Require Import codeNatToTerm.

Fixpoint LNN2LNT_term (t : fol.Term LNN) : Term :=
  match t with
  | fol.var v => var v
  | apply f ts => apply LNT f (LNN2LNT_terms _ ts)
  end
 
 with LNN2LNT_terms (n : nat) (ts : fol.Terms LNN n) {struct ts} : 
 Terms n :=
  match ts in (fol.Terms _ n0) return (Terms n0) with
  | Tnil => Tnil LNT
  | Tcons m s ss => Tcons LNT m (LNN2LNT_term s) (LNN2LNT_terms m ss)
  end. 

Definition LTFormula :=
  existH 2 (equal (Plus (var 0) (Succ (var 2))) (var 1)).

Definition translateLT (ts : fol.Terms LNN (arity LNN (inl _ LT))) : Formula.

Lemma LNN2LNT_natToTerm :
 forall n : nat, LNN2LNT_term (natToTermLNN n) = natToTerm n.

Lemma translateLT1 :
 forall a a0 b0,
 translateLT (Tcons LNN 1 a (Tcons LNN 0 a0 b0)) =
 subAllFormula LNT LTFormula
   (fun H : nat =>
    nat_rec (fun _ : nat => fol.Term LNT) (LNN2LNT_term a)

Fixpoint LNN2LNT_formula (f : fol.Formula LNN) : Formula :=
  match f with
  | fol.equal t1 t2 => equal (LNN2LNT_term t1) (LNN2LNT_term t2)
  | atomic r ts =>
      match
        r as l return (fol.Terms LNN (arity LNN (inl _ l)) -> Formula)
      with
      | LT => fun t0 : fol.Terms LNN (arity LNN (inl _ LT)) => translateLT t0
      end ts
  | fol.impH A B => impH (LNN2LNT_formula A) (LNN2LNT_formula B)
  | fol.notH A => notH (LNN2LNT_formula A)
  | fol.forallH v A => forallH v (LNN2LNT_formula A)
  end.

Lemma LNN2LNT_or :
 forall a b : fol.Formula LNN,

Lemma LNN2LNT_and :
 forall a b : fol.Formula LNN,

Lemma LNN2LNT_iff :
 forall a b : fol.Formula LNN,

Lemma LNN2LNT_exist :
 forall (v : nat) (a : fol.Formula LNN),

Lemma LNN2LNT_freeVarTerm :
 forall t : fol.Term LNN,

Lemma LNN2LNT_freeVarTerms :
 forall (n : nat) (ts : fol.Terms LNN n),

Lemma LNN2LNT_freeVarFormula :
 forall (f : fol.Formula LNN) (v : nat),

Lemma LNN2LNT_freeVarFormula1 :
 forall (f : fol.Formula LNN) (v : nat),

Lemma LNN2LNT_freeVarFormula2 :
 forall (f : fol.Formula LNN) (v : nat),

Lemma LNN2LNT_subTerm :
 forall (t : fol.Term LNN) (v : nat) (s : fol.Term LNN),

Lemma LNN2LNT_subTerms :
 forall (n : nat) (ts : fol.Terms LNN n) (v : nat) (s : fol.Term LNN),

Lemma LNN2LNT_subFormula :
 forall (T : System) (f : fol.Formula LNN) (v : nat) (s : fol.Term LNN),

Fixpoint LNT2LNN_term (t : Term) : fol.Term LNN :=
  match t with
  | fol.var v => fol.var LNN v
  | apply f ts => apply LNN f (LNT2LNN_terms _ ts)
  end
 
 with LNT2LNN_terms (n : nat) (ts : Terms n) {struct ts} : 
 fol.Terms LNN n :=
  match ts in (fol.Terms _ n0) return (fol.Terms LNN n0) with
  | Tnil => Tnil LNN
  | Tcons m s ss => Tcons LNN m (LNT2LNN_term s) (LNT2LNN_terms m ss)
  end.

Lemma LNT2LNN_natToTerm :
 forall n : nat, LNT2LNN_term (natToTerm n) = natToTermLNN n.

Fixpoint LNT2LNN_formula (f : Formula) : fol.Formula LNN :=
  match f with
  | fol.equal t1 t2 => fol.equal LNN (LNT2LNN_term t1) (LNT2LNN_term t2)
  | atomic r ts => match r with
                   end
  | fol.impH A B => fol.impH LNN (LNT2LNN_formula A) (LNT2LNN_formula B)
  | fol.notH A => fol.notH LNN (LNT2LNN_formula A)
  | fol.forallH v A => fol.forallH LNN v (LNT2LNN_formula A)
  end.

Lemma LNT2LNT_term : forall t : Term, LNN2LNT_term (LNT2LNN_term t) = t.

Lemma LNT2LNT_formula :
 forall f : Formula, LNN2LNT_formula (LNT2LNN_formula f) = f.

Lemma LNT2LNN_subTerm :
 forall (t : Term) (v : nat) (s : Term),
 LNT2LNN_term (substituteTerm LNT t v s) =
 substituteTerm LNN (LNT2LNN_term t) v (LNT2LNN_term s).

Lemma LNT2LNN_freeVarTerm :
 forall t : Term, freeVarTerm LNN (LNT2LNN_term t) = freeVarTerm LNT t.

Lemma LNT2LNN_freeVarFormula :
 forall f : Formula,
 freeVarFormula LNN (LNT2LNN_formula f) = freeVarFormula LNT f.

Lemma LNT2LNN_subFormula :
 forall (f : Formula) (v : nat) (s : Term),
 LNT2LNN_formula (substituteFormula LNT f v s) =
 substituteFormula LNN (LNT2LNN_formula f) v (LNT2LNN_term s).

Section Translate_Proof.

Variable U : fol.System LNN.
Variable V : System.

Hypothesis
  AxiomsOK :
    forall f : fol.Formula LNN,
    mem _ U f ->  
    exists Axm : Formulas,
    (exists prf : Prf LNT Axm (LNN2LNT_formula f),
       (forall g : Formula, In g Axm -> mem _ V g)) /\
    forall v, In v (freeVarListFormula LNT Axm) -> (In v (freeVarFormula LNN f)).

Lemma translatePrf : forall f,
 forall axm, Prf LNN axm f -> 
  (forall g, In g axm -> mem _ U g) ->
  exists Axm : Formulas,
    (exists prf : Prf LNT Axm (LNN2LNT_formula f),
       (forall g : Formula, In g Axm -> mem _ V g)) /\
    forall v, In v (freeVarListFormula LNT Axm) -> (In v (freeVarListFormula LNN axm)).

End Translate_Proof.

Lemma translateProof
     : forall (U : fol.System LNN) (V : System), *)
Require Export PA.
(* PA:
Require Import Arith.
Require Import Ensembles.

Require Import folProp.
Require Import subAll.
Require Import folLogic3.
Require Export Languages.
Require Export LNT.

Section PA.

Definition PA1 := forallH 0 (notH (equal (Succ (var 0)) Zero)).
Definition PA2 :=
  forallH 1
    (forallH 0
       (impH (equal (Succ (var 0)) (Succ (var 1))) (equal (var 0) (var 1)))).
Definition PA3 := forallH 0 (equal (Plus (var 0) Zero) (var 0)).
Definition PA4 :=
  forallH 1
    (forallH 0
       (equal (Plus (var 0) (Succ (var 1))) (Succ (Plus (var 0) (var 1))))).
Definition PA5 := forallH 0 (equal (Times (var 0) Zero) Zero).
Definition PA6 :=
  forallH 1
    (forallH 0
       (equal (Times (var 0) (Succ (var 1)))
          (Plus (Times (var 0) (var 1)) (var 0)))).
Definition PA7 (f : Formula) (v : nat) : Formula :=
  close LNT
    (impH (substituteFormula LNT f v Zero)
       (impH (forallH v (impH f (substituteFormula LNT f v (Succ (var v)))))
          (forallH v f))).

Definition InductionSchema (f : Formula) : Prop :=
  exists g : Formula, (exists v : nat, f = PA7 g v).

Definition PA :=
  Ensembles.Add _
    (Ensembles.Add _ (Ensembles.Add _ (Ensembles.Add _ (Ensembles.Add _ (Ensembles.Add _ InductionSchema PA1) PA2) PA3) PA4)
       PA5) PA6.

Definition open :=
  Formula_rec LNT (fun _ => Formula) (fun t t0 : Term => equal t t0)
    (fun (r : Relations LNT) (ts : Terms (arity LNT (inl (Functions LNT) r))) =>
     atomic LNT r ts) (fun (f : Formula) _ (f0 : Formula) _ => impH f f0)
    (fun (f : Formula) _ => notH f)
    (fun (n : nat) _ (recf : Formula) => recf).

Lemma PAdec : forall x : Formula, In _ PA x \/ ~ In _ PA x.

Lemma closedPA1 : ClosedSystem LNT PA.

Lemma closedPA : forall v : nat, ~ In_freeVarSys LNT v PA.

Lemma pa1 : forall a : Term, SysPrf PA (notH (equal (Succ a) Zero)).

Lemma pa2 :
 forall a b : Term, SysPrf PA (impH (equal (Succ a) (Succ b)) (equal a b)).

Lemma pa3 : forall a : Term, SysPrf PA (equal (Plus a Zero) a).

Lemma pa4 :
 forall a b : Term, SysPrf PA (equal (Plus a (Succ b)) (Succ (Plus a b))).

Lemma pa5 : forall a : Term, SysPrf PA (equal (Times a Zero) Zero).

Lemma pa6 :
 forall a b : Term, SysPrf PA (equal (Times a (Succ b)) (Plus (Times a b) a)).

Lemma induct :
 forall (f : Formula) (v : nat),
 SysPrf PA (substituteFormula LNT f v Zero) ->
 SysPrf PA (forallH v (impH f (substituteFormula LNT f v (Succ (var v))))) ->
 SysPrf PA (forallH v f).

End PA. *)

Unset Standard Proposition Elimination Names.

Lemma paZeroOrSucc :
 forall t : Term,
 SysPrf PA
   (orH (equal t Zero)
      (existH (newVar (0 :: freeVarTerm LNT t))
         (equal t (Succ (var (newVar (0 :: freeVarTerm LNT t))))))).
Proof.
intros.
set (nv := newVar (0 :: freeVarTerm LNT t)) in *.
apply
 impE
  with
    (substituteFormula LNT
       (orH (equal (var 0) Zero) (existH nv (equal (var 0) (Succ (var nv)))))
       0 t).
rewrite (subFormulaOr LNT).
rewrite (subFormulaEqual LNT).
simpl in |- *.
apply iffE1.
apply (reduceOr LNT).
apply iffRefl.
rewrite (subFormulaExist LNT).
induction (eq_nat_dec nv 0).
elim (newVar1 (0 :: freeVarTerm LNT t)).
fold nv in |- *.
rewrite a.
simpl in |- *.
auto.
induction (In_dec eq_nat_dec nv (freeVarTerm LNT t)).
elim (newVar1 (0 :: freeVarTerm LNT t)).
fold nv in |- *.
simpl in |- *.
auto.
rewrite (subFormulaEqual LNT).
Opaque eq_nat_dec.
simpl in |- *.
Transparent eq_nat_dec.
destruct (eq_nat_dec 0 nv).
elim b.
auto.
apply iffRefl.
apply forallE.
apply induct.
rewrite (subFormulaOr LNT).
apply orI1.
rewrite (subFormulaEqual LNT).
simpl in |- *.
apply eqRefl.
apply forallI.
apply closedPA.
apply impI.
rewrite (subFormulaOr LNT).
apply orI2.
rewrite (subFormulaExist LNT).
induction (eq_nat_dec nv 0).
elim (newVar1 (0 :: freeVarTerm LNT t)).
fold nv in |- *.
simpl in |- *.
auto.
induction (In_dec eq_nat_dec nv (freeVarTerm LNT (Succ (var 0)))).
elim (newVar1 (0 :: freeVarTerm LNT t)).
fold nv in |- *.
simpl in a.
induction a as [H| H].
simpl in |- *.
auto.
elim H.
rewrite (subFormulaEqual LNT).
Opaque eq_nat_dec.
simpl in |- *.
Transparent eq_nat_dec.
induction
 (nat_rec (fun n : nat => {0 = n} + {0 <> n}) (left (0 <> 0) (refl_equal 0))
    (fun (m : nat) (_ : {0 = m} + {0 <> m}) => right (0 = S m) (O_S m)) nv).
elim b.
auto.
fold var in |- *.
fold (Succ (var nv)) in |- *.
apply sysWeaken.
apply existI with (var 0).
rewrite (subFormulaEqual LNT).
simpl in |- *.
destruct (eq_nat_dec nv 0).
elim b1; auto.
change match nv as n return ({0 = n} + {0 <> n}) with
                  | 0 => left (0 <> 0) (refl_equal 0)
                  | S m => right (0 = S m) (O_S m)
                  end
 with (eq_nat_dec 0 nv).
destruct (eq_nat_dec 0 nv).
elim b1.
auto.
simpl.
destruct (eq_nat_dec nv nv).
apply eqRefl.
elim n1.
reflexivity.
Qed.

Lemma paPlusSym : forall a b : Term, SysPrf PA (equal (Plus a b) (Plus b a)).
Proof.
assert
 (SysPrf PA
    (forallH 1
       (forallH 0 (equal (Plus (var 0) (var 1)) (Plus (var 1) (var 0)))))).
apply induct.
rewrite (subFormulaForall LNT).
induction (eq_nat_dec 0 1).
discriminate a.
induction (In_dec eq_nat_dec 0 (freeVarTerm LNT Zero)).
elim a.
apply induct.
repeat rewrite (subFormulaEqual LNT).
simpl in |- *.
apply eqRefl.
apply forallI.
apply closedPA.
repeat rewrite (subFormulaEqual LNT).
simpl in |- *.
apply impI.
apply eqTrans with (Succ (var 0)).
apply sysWeaken.
apply pa3 with (a := Succ (var 0)).
apply eqTrans with (Succ (Plus Zero (var 0))).
apply eqSucc.
apply eqTrans with (Plus (var 0) Zero).
apply sysWeaken.
apply eqSym.
apply pa3.
apply Axm; right; constructor.
apply eqSym.
apply sysWeaken.
apply pa4 with (a := Zero) (b := var 0).
apply forallI.
apply closedPA.
apply impI.
rewrite (subFormulaForall LNT).
induction (eq_nat_dec 0 1).
discriminate a.
induction (In_dec eq_nat_dec 0 (freeVarTerm LNT (Succ (var 1)))).
simpl in a.
induction a as [H| H].
elim b; auto.
contradiction.
rewrite (subFormulaEqual LNT).
simpl in |- *.
apply forallI.
unfold not in |- *; intros.
induction H as (x, H); induction H as (H, H0).
induction H0 as [x H0| x H0].
elim closedPA with 0.
exists x.
auto.
induction H0.
simpl in H.
decompose sum H.
discriminate H0.
discriminate H1.
apply eqTrans with (Succ (Plus (var 0) (var 1))).
apply sysWeaken.
apply pa4 with (a := var 0) (b := var 1).
apply eqTrans with (Succ (Plus (var 1) (var 0))).
apply eqSucc.
apply forallSimp with 0.
apply Axm; right; constructor.
apply sysWeaken.
apply forallSimp with 0.
apply induct.
rewrite (subFormulaEqual LNT).
simpl in |- *.
apply eqTrans with (Succ (var 1)).
fold
 (Succ
    (apply LNT Languages.Plus
       (Tcons LNT 1 (fol.var LNT 1) (Tcons LNT 0 Zero (Tnil LNT))))) 
 in |- *.
apply eqSucc.
apply pa3 with (a := var 1).
apply eqSym.
apply pa3 with (a := Succ (var 1)).
apply forallI.
apply closedPA.
apply impI.
rewrite (subFormulaEqual LNT).
simpl in |- *.
apply eqTrans with (Succ (Plus (Succ (var 1)) (var 0))).
fold
 (Succ
    (apply LNT Languages.Plus
       (Tcons LNT 1 (fol.var LNT 1) (Tcons LNT 0 (Succ (var 0)) (Tnil LNT)))))
 in |- *.
apply eqSucc.
apply eqTrans with (Succ (Plus (var 1) (var 0))).
apply sysWeaken.
apply pa4 with (a := var 1) (b := var 0).
apply Axm; right; constructor.
apply sysWeaken.
apply eqSym.
apply pa4 with (a := Succ (var 1)) (b := var 0).
intros.
set (m := fun x : nat => match x with
                         | O => a
                         | S _ => b
                         end) in *.
replace (equal (Plus a b) (Plus b a)) with
 (subAllFormula LNT (equal (Plus (var 0) (var 1)) (Plus (var 1) (var 0)))
    (fun x : nat =>
     match le_lt_dec 2 x with
     | left _ => var x
     | right _ => m x
     end)).
apply (subAllCloseFrom LNT).
simpl in |- *.
apply H.
simpl in |- *.
induction (le_lt_dec 2 0).
elim (le_not_lt _ _ a0).
auto.
induction (le_lt_dec 2 1).
elim (le_not_lt _ _ a0).
auto.
reflexivity.
Qed.

Lemma NN72PA : SysPrf PA (LNN2LNT_formula NN7).
Proof.
simpl in |- *.
apply forallI.
apply closedPA.
rewrite translateLT1.
simpl in |- *.
set (nv := newVar (0 :: 2 :: 1 :: 0 :: nil)) in *.
fold var in |- *.
fold Zero in |- *.
fold (Succ (var nv)) in |- *.
fold (Plus (var 0) (Succ (var nv))) in |- *.
apply nnI.
apply forallI.
apply closedPA.
apply impE with (notH (equal (Succ (Plus (var 0) (var nv))) Zero)).
apply cp2.
apply impI.
apply eqTrans with (Plus (var 0) (Succ (var nv))).
apply sysWeaken.
apply eqSym.
apply pa4.
apply Axm; right; constructor.
apply pa1.
Qed.

Lemma NN82PA : SysPrf PA (LNN2LNT_formula NN8).
Proof.
replace (LNN2LNT_formula NN8) with
 (forallH 1
    (forallH 0
       (impH (LNN2LNT_formula (LT (LNN.var 0) (LNN.Succ (LNN.var 1))))
          (orH (LNN2LNT_formula (LT (LNN.var 0) (LNN.var 1)))
             (equal (var 0) (var 1)))))).
simpl in |- *.
repeat rewrite translateLT1.
simpl in |- *.
unfold newVar in |- *.
simpl in |- *.
fold var in |- *.
fold (Succ (var 3)) in |- *.
fold (Succ (var 1)) in |- *.
fold (Plus (var 0) (Succ (var 3))) in |- *.
fold equal in |- *.
fold (fol.existH LNT 3 (equal (Plus (var 0) (Succ (var 3))) (Succ (var 1))))
 in |- *.
fold (fol.existH LNT 3 (equal (Plus (var 0) (Succ (var 3))) (var 1))) in |- *.
fold existH in |- *.
apply forallI.
apply closedPA.
apply forallI.
apply closedPA.
apply impI.
apply existSys.
apply closedPA.
simpl in |- *.
unfold not in |- *; intros.
repeat (elim H; clear H; [ discriminate | intros ]); auto.
eapply orE.
apply sysWeaken.
apply paZeroOrSucc.
apply impI.
apply orI2.
apply impE with (equal (Succ (var 0)) (Succ (var 1))).
repeat simple apply sysWeaken.
apply pa2.
apply eqTrans with (Plus (var 0) (Succ (var 3))).
apply eqTrans with (Succ (Plus (var 0) (var 3))).
apply eqSucc.
apply eqTrans with (Plus (var 0) Zero).
apply eqSym.
repeat simple apply sysWeaken.
apply pa3.
apply eqPlus.
apply eqRefl.
apply eqSym.
apply Axm; right; constructor.
apply eqSym.
repeat simple apply sysWeaken.
apply pa4.
apply Axm; left; right; constructor.
unfold newVar in |- *.
simpl in |- *.
apply impI.
apply existSys.
unfold not in |- *; intros.
induction H as (x, H); induction H as (H, H0).
induction H0 as [x H0| x H0].
elim closedPA with 4.
exists x.
auto.
induction H0.
simpl in H.
repeat (elim H; clear H; [ discriminate | intros ]); auto.
unfold not in |- *; intros.
simpl in H.
repeat (elim H; clear H; [ discriminate | intros ]); auto.
apply orI1.
apply existI with (var 4).
rewrite (subFormulaEqual LNT).
simpl in |- *.
apply impE with (equal (Succ (Plus (var 0) (Succ (var 4)))) (Succ (var 1))).
repeat simple apply sysWeaken.
apply pa2.
apply eqTrans with (Plus (var 0) (Succ (var 3))).
apply eqTrans with (Plus (var 0) (Succ (Succ (var 4)))).
repeat simple apply sysWeaken.
apply eqSym.
apply pa4.
apply eqPlus.
apply eqRefl.
apply eqSucc.
apply eqSym.
apply Axm; right; constructor.
apply Axm; left; right; constructor.
reflexivity.
Qed.

Lemma NN92PA : SysPrf PA (LNN2LNT_formula NN9).
Proof.
replace (LNN2LNT_formula NN9) with
 (forallH 1
    (forallH 0
       (orH (LNN2LNT_formula (LT (LNN.var 0) (LNN.var 1)))
          (orH (equal (var 0) (var 1))
             (LNN2LNT_formula (LT (LNN.var 1) (LNN.var 0)))))));
 [ idtac | reflexivity ].
simpl in |- *.
repeat rewrite translateLT1.
simpl in |- *.
unfold newVar in |- *.
simpl in |- *.
fold var in |- *.
fold (Succ (var 3)) in |- *.
fold (Plus (var 0) (Succ (var 3))) in |- *.
fold (Plus (var 1) (Succ (var 3))) in |- *.
fold equal in |- *.
fold (fol.existH LNT 3 (equal (Plus (var 0) (Succ (var 3))) (var 1))) in |- *.
fold (fol.existH LNT 3 (equal (Plus (var 1) (Succ (var 3))) (var 0))) in |- *.
fold existH in |- *.
apply induct.
rewrite (subFormulaForall LNT).
induction (eq_nat_dec 0 1).
discriminate a.
induction (In_dec eq_nat_dec 0 (freeVarTerm LNT Zero)).
simpl in a.
elim a.
rewrite (subFormulaOr LNT).
apply forallI.
apply closedPA.
apply orI2.
rewrite (subFormulaOr LNT).
rewrite (subFormulaEqual LNT).
simpl in |- *.
eapply orE.
apply paZeroOrSucc with (t := var 0).
apply impI.
apply orI1.
apply Axm; right; constructor.
apply impI.
apply orI2.
unfold newVar in |- *.
simpl in |- *.
rewrite (subFormulaExist LNT).
induction (eq_nat_dec 3 1).
discriminate a.
induction (In_dec eq_nat_dec 3 (freeVarTerm LNT Zero)).
elim a.
apply impE with (existH 3 (equal (var 0) (Succ (var 3)))).
apply sysWeaken.
apply impI.
apply existSys.
apply closedPA.
unfold not in |- *; intros.
simpl in H.
induction H as [H| H].
discriminate H.
contradiction.
apply existI with (var 3).
repeat rewrite (subFormulaEqual LNT).
simpl in |- *.
apply eqTrans with (Succ (var 3)).
apply sysWeaken.
apply eqTrans with (Plus (Succ (var 3)) Zero).
apply paPlusSym with (a := Zero) (b := Succ (var 3)).
apply pa3.
apply eqSym.
apply Axm; right; constructor.
apply impE with (existH 1 (equal (var 0) (Succ (var 1)))).
replace (equal (var 0) (Succ (var 3))) with
 (substituteFormula LNT (equal (var 0) (Succ (var 1))) 1 (var 3)).
apply iffE1.
apply (rebindExist LNT).
simpl in |- *.
unfold not in |- *; intros.
induction H as [H| H].
discriminate H.
contradiction.
rewrite (subFormulaEqual LNT).
reflexivity.
apply Axm; right; constructor.
apply forallI.
apply closedPA.
apply impI.
rewrite (subFormulaForall LNT).
induction (eq_nat_dec 0 1).
discriminate a.
induction (In_dec eq_nat_dec 0 (freeVarTerm LNT (Succ (var 1)))).
simpl in a.
induction a as [H| H].
discriminate H.
contradiction.
rewrite (subFormulaOr LNT).
apply sysWeaken.
apply induct.
rewrite (subFormulaOr LNT).
apply orI1.
rewrite (subFormulaExist LNT).
induction (eq_nat_dec 3 1).
discriminate a.
induction (In_dec eq_nat_dec 3 (freeVarTerm LNT (Succ (var 1)))).
simpl in a.
induction a as [H| H].
elim b1; auto.
contradiction.
rewrite (subFormulaExist LNT).
induction (eq_nat_dec 3 0).
discriminate a.
induction (In_dec eq_nat_dec 3 (freeVarTerm LNT Zero)).
simpl in a.
contradiction.
apply existI with (var 1).
repeat rewrite (subFormulaEqual LNT).
simpl in |- *.
apply eqTrans with (Plus (Succ (var 1)) Zero).
apply paPlusSym with (a := Zero) (b := Succ (var 1)).
apply pa3.
apply forallI.
apply closedPA.
apply impI.
apply orSys.
rewrite (subFormulaExist LNT).
induction (eq_nat_dec 3 1).
discriminate a.
induction (In_dec eq_nat_dec 3 (freeVarTerm LNT (Succ (var 1)))).
simpl in a.
induction a as [H| H].
elim b1; auto.
contradiction.
repeat rewrite (subFormulaOr LNT).
rewrite (subFormulaExist LNT).
induction (eq_nat_dec 3 0).
discriminate a.
induction (In_dec eq_nat_dec 3 (freeVarTerm LNT (Succ (var 0)))).
simpl in a.
induction a as [H| H].
elim b3; auto.
contradiction.
rewrite (subFormulaExist LNT).
induction (eq_nat_dec 3 1).
elim b1; auto.
induction (In_dec eq_nat_dec 3 (freeVarTerm LNT (Succ (var 1)))).
elim b2; auto.
rewrite (subFormulaExist LNT).
induction (eq_nat_dec 3 0).
elim b3; auto.
induction (In_dec eq_nat_dec 3 (freeVarTerm LNT (Succ (var 0)))).
elim b4; auto.
repeat rewrite (subFormulaEqual LNT); simpl in |- *.
apply existSys.
apply closedPA.
simpl in |- *.
unfold not in |- *; intros.
decompose sum H; auto.
eapply orE.
apply sysWeaken.
apply paZeroOrSucc with (t := var 3).
apply impI.
apply orI2.
apply orI1.
apply eqTrans with (Plus (var 0) (Succ (var 3))).
apply eqTrans with (Succ (Plus (var 0) (var 3))).
apply eqSucc.
apply eqTrans with (Plus (var 0) Zero).
apply eqSym.
repeat simple apply sysWeaken.
apply pa3.
apply eqPlus.
apply eqRefl.
apply eqSym.
apply Axm; right; constructor.
apply eqSym.
repeat simple apply sysWeaken.
apply pa4.
apply Axm; left; right; constructor.
unfold newVar in |- *.
simpl in |- *.
apply impI.
apply orI1.
apply existSys.
unfold not in |- *; intros.
induction H as (x, H); induction H as (H, H0).
induction H0 as [x H0| x H0].
elim closedPA with 4.
exists x.
auto.
induction H0.
simpl in H.
decompose sum H; discriminate H0 || discriminate H1.
simpl in |- *.
unfold not in |- *; intros.
decompose sum H; discriminate H0 || discriminate H1.
apply existI with (var 4).
rewrite (subFormulaEqual LNT); simpl in |- *.
apply eqTrans with (Plus (var 0) (Succ (var 3))).
apply eqTrans with (Plus (var 0) (Succ (Succ (var 4)))).
apply eqTrans with (Succ (Plus (var 0) (Succ (var 4)))).
apply eqTrans with (Plus (Succ (var 4)) (Succ (var 0))).
repeat simple apply sysWeaken.
apply paPlusSym with (a := Succ (var 0)) (b := Succ (var 4)).
repeat simple apply sysWeaken.
eapply eqTrans.
apply pa4.
apply eqSucc.
apply paPlusSym.
repeat simple apply sysWeaken.
apply eqSym.
apply pa4.
apply eqPlus.
apply eqRefl.
apply eqSucc.
apply eqSym.
apply Axm; right; constructor.
apply Axm; left; right; constructor.
repeat rewrite (subFormulaOr LNT).
apply orSys.
apply orI2.
apply orI2.
rewrite (subFormulaExist LNT).
induction (eq_nat_dec 3 1).
discriminate a.
induction (In_dec eq_nat_dec 3 (freeVarTerm LNT (Succ (var 1)))).
induction a as [H| H].
elim b1; auto.
contradiction.
rewrite (subFormulaExist LNT).
induction (eq_nat_dec 3 0).
discriminate a.
induction (In_dec eq_nat_dec 3 (freeVarTerm LNT (Succ (var 0)))).
induction a as [H| H].
elim b3; auto.
contradiction.
apply existI with Zero.
repeat rewrite (subFormulaEqual LNT).
simpl in |- *.
apply eqTrans with (Succ (Plus (Succ (var 1)) Zero)).
apply sysWeaken.
apply pa4 with (a := Succ (var 1)) (b := Zero).
apply eqTrans with (Succ (Succ (var 1))).
apply eqSucc.
apply sysWeaken.
apply pa3.
fold (Succ (fol.var LNT 0)) in |- *.
apply eqSucc.
apply eqSym.
apply Axm; right; constructor.
do 2 rewrite (subFormulaExist LNT).
induction (eq_nat_dec 3 1).
discriminate a.
induction (In_dec eq_nat_dec 3 (freeVarTerm LNT (Succ (var 1)))).
induction a as [H| H].
elim b1; auto.
contradiction.
do 2 rewrite (subFormulaExist LNT).
induction (eq_nat_dec 3 0).
discriminate a.
induction (In_dec eq_nat_dec 3 (freeVarTerm LNT (Succ (var 0)))).
induction a as [H| H].
elim b3; auto.
contradiction.
apply orI2.
apply orI2.
apply existSys.
apply closedPA.
simpl in |- *.
unfold not in |- *; intros.
decompose sum H; auto.
apply existI with (Succ (var 3)).
repeat rewrite (subFormulaEqual LNT).
simpl in |- *.
apply eqTrans with (Succ (Plus (Succ (var 1)) (Succ (var 3)))).
apply sysWeaken.
apply pa4 with (a := Succ (var 1)) (b := Succ (var 3)).
fold (Succ (fol.var LNT 0)) in |- *.
apply eqSucc.
apply Axm; right; constructor.
Qed.
