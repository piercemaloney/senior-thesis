Require Import primRec.
(* primRec:
Require Import Arith.
Require Import Peano_dec.
Require Import Compare_dec.
Require Import Coq.Lists.List.
Require Import Eqdep_dec.
Require Import extEqualNat.
Require Vector.
Require Import misc.
Require Export Bool.
Require Export EqNat.
Require Import Even.
Require Import Max.

Inductive PrimRec : nat -> Set :=
  | succFunc : PrimRec 1
  | zeroFunc : PrimRec 0
  | projFunc : forall n m : nat, m < n -> PrimRec n
  | composeFunc :
      forall (n m : nat) (g : PrimRecs n m) (h : PrimRec m), PrimRec n
  | primRecFunc :
      forall (n : nat) (g : PrimRec n) (h : PrimRec (S (S n))), PrimRec (S n)
with PrimRecs : nat -> nat -> Set :=
  | PRnil : forall n : nat, PrimRecs n 0
  | PRcons : forall n m : nat, PrimRec n -> PrimRecs n m -> PrimRecs n (S m).

Scheme PrimRec_PrimRecs_rec := Induction for PrimRec
  Sort Set
  with PrimRecs_PrimRec_rec := Induction for PrimRecs 
  Sort Set.

Scheme PrimRec_PrimRecs_ind := Induction for PrimRec
  Sort Prop
  with PrimRecs_PrimRec_ind := Induction for PrimRecs 
  Sort Prop.

Fixpoint evalConstFunc (n m : nat) {struct n} : naryFunc n :=
  match n return (naryFunc n) with
  | O => m
  | S n' => fun _ => evalConstFunc n' m
  end.

Fixpoint evalProjFunc (n : nat) : forall m : nat, m < n -> naryFunc n :=
  match n return (forall m : nat, m < n -> naryFunc n) with
  | O => fun (m : nat) (l : m < 0) => False_rec _ (lt_n_O _ l)
  | S n' =>
      fun (m : nat) (l : m < S n') =>
      match eq_nat_dec m n' with
      | left _ => fun a : nat => evalConstFunc _ a
      | right l1 =>
          fun _ =>
          evalProjFunc n' m
            match le_lt_or_eq _ _ (lt_n_Sm_le _ _ l) with
            | or_introl l2 => l2
            | or_intror l2 => False_ind _ (l1 l2)
            end
      end
  end.

Lemma evalProjFuncInd :
 forall (n m : nat) (p1 p2 : m < n),
 evalProjFunc n m p1 = evalProjFunc n m p2.

Fixpoint evalList (m : nat) (l : Vector.t nat m) {struct l} :
 naryFunc m -> nat :=
  match l in (Vector.t _ m) return (naryFunc m -> nat) with
  | Vector.nil => fun x : naryFunc 0 => x
  | Vector.cons a n l' => fun x : naryFunc (S n) => evalList n l' (x a)
  end.

Fixpoint evalOneParamList (n m a : nat) (l : Vector.t (naryFunc (S n)) m)
 {struct l} : Vector.t (naryFunc n) m :=
  match l in (Vector.t _ m) return (Vector.t (naryFunc n) m) with
  | Vector.nil  => Vector.nil  (naryFunc n)
  | Vector.cons f m' l' => Vector.cons _ (f a) m' (evalOneParamList n m' a l')
  end.

Fixpoint evalComposeFunc (n : nat) :
 forall m : nat, Vector.t (naryFunc n) m -> naryFunc m -> naryFunc n :=
  match
    n
    return
      (forall m : nat, Vector.t (naryFunc n) m -> naryFunc m -> naryFunc n)
  with
  | O => evalList
  | S n' =>
      fun (m : nat) (l : Vector.t (naryFunc (S n')) m) 
        (f : naryFunc m) (a : nat) =>
      evalComposeFunc n' m (evalOneParamList _ _ a l) f
  end.

Fixpoint compose2 (n : nat) : naryFunc n -> naryFunc (S n) -> naryFunc n :=
  match n return (naryFunc n -> naryFunc (S n) -> naryFunc n) with
  | O => fun (a : nat) (g : nat -> nat) => g a
  | S n' =>
      fun (f : naryFunc (S n')) (g : naryFunc (S (S n'))) (a : nat) =>
      compose2 n' (f a) (fun x : nat => g x a)
  end.

Fixpoint evalPrimRecFunc (n : nat) (g : naryFunc n) 
 (h : naryFunc (S (S n))) (a : nat) {struct a} : naryFunc n :=
  match a with
  | O => g
  | S a' => compose2 _ (evalPrimRecFunc n g h a') (h a')
  end.

Fixpoint evalPrimRec (n : nat) (f : PrimRec n) {struct f} : 
 naryFunc n :=
  match f in (PrimRec n) return (naryFunc n) with
  | succFunc => S
  | zeroFunc => 0
  | projFunc n m pf => evalProjFunc n m pf
  | composeFunc n m l f =>
      evalComposeFunc n m (evalPrimRecs _ _ l) (evalPrimRec _ f)
  | primRecFunc n g h =>
      evalPrimRecFunc n (evalPrimRec _ g) (evalPrimRec _ h)
  end
 
 with evalPrimRecs (n m : nat) (fs : PrimRecs n m) {struct fs} :
 Vector.t (naryFunc n) m :=
  match fs in (PrimRecs n m) return (Vector.t (naryFunc n) m) with
  | PRnil a => Vector.nil  (naryFunc a)
  | PRcons a b g gs => Vector.cons _ (evalPrimRec _ g) _ (evalPrimRecs _ _ gs)
  end.

Definition extEqualVectorGeneral (n m : nat) (l : Vector.t (naryFunc n) m) :

Definition extEqualVector n: forall m (l l' : Vector.t (naryFunc n) m), Prop.

Lemma extEqualVectorRefl :
 forall (n m : nat) (l : Vector.t (naryFunc n) m), extEqualVector n m l l.

Lemma extEqualOneParamList :
 forall (n m : nat) (l1 l2 : Vector.t (naryFunc (S n)) m) (c : nat),

Lemma extEqualCompose :
 forall (n m : nat) (l1 l2 : Vector.t (naryFunc n) m) (f1 f2 : naryFunc m),

Lemma extEqualCompose2 :
 forall (n : nat) (f1 f2 : naryFunc n),
 extEqual n f1 f2 ->
 forall g1 g2 : naryFunc (S n),
 extEqual (S n) g1 g2 -> extEqual n (compose2 n f1 g1) (compose2 n f2 g2).

Lemma extEqualPrimRec :
 forall (n : nat) (g1 g2 : naryFunc n) (h1 h2 : naryFunc (S (S n))),
 extEqual n g1 g2 ->
 extEqual (S (S n)) h1 h2 ->
 extEqual (S n) (evalPrimRecFunc n g1 h1) (evalPrimRecFunc n g2 h2).

Definition isPR (n : nat) (f : naryFunc n) : Set :=
  {p : PrimRec n | extEqual n (evalPrimRec _ p) f}.

Definition isPRrel (n : nat) (R : naryRel n) : Set :=
  isPR n (charFunction n R).

Lemma succIsPR : isPR 1 S.

Lemma const0_NIsPR : forall n : nat, isPR 0 n.

Lemma const1_NIsPR : forall n : nat, isPR 1 (fun _ => n).

Lemma idIsPR : isPR 1 (fun x : nat => x).

Lemma pi1_2IsPR : isPR 2 (fun a b : nat => a).

Lemma pi2_2IsPR : isPR 2 (fun a b : nat => b).

Lemma pi1_3IsPR : isPR 3 (fun a b c : nat => a).

Lemma pi2_3IsPR : isPR 3 (fun a b c : nat => b).

Lemma pi3_3IsPR : isPR 3 (fun a b c : nat => c).

Lemma pi1_4IsPR : isPR 4 (fun a b c d : nat => a).

Lemma pi2_4IsPR : isPR 4 (fun a b c d : nat => b).

Lemma pi3_4IsPR : isPR 4 (fun a b c d : nat => c).

Lemma pi4_4IsPR : isPR 4 (fun a b c d : nat => d).

Lemma filter01IsPR :
 forall g : nat -> nat, isPR 1 g -> isPR 2 (fun a b : nat => g b).

Lemma filter10IsPR :
 forall g : nat -> nat, isPR 1 g -> isPR 2 (fun a b : nat => g a).

Lemma filter100IsPR :
 forall g : nat -> nat, isPR 1 g -> isPR 3 (fun a b c : nat => g a).

Lemma filter010IsPR :
 forall g : nat -> nat, isPR 1 g -> isPR 3 (fun a b c : nat => g b).

Lemma filter001IsPR :
 forall g : nat -> nat, isPR 1 g -> isPR 3 (fun a b c : nat => g c).

Lemma filter011IsPR :
 forall g : nat -> nat -> nat, isPR 2 g -> isPR 3 (fun a b c : nat => g b c).

Lemma filter110IsPR :
 forall g : nat -> nat -> nat, isPR 2 g -> isPR 3 (fun a b c : nat => g a b).

Lemma filter101IsPR :
 forall g : nat -> nat -> nat, isPR 2 g -> isPR 3 (fun a b c : nat => g a c).

Lemma filter0011IsPR :
 forall g : nat -> nat -> nat,
 isPR 2 g -> isPR 4 (fun a b c d : nat => g c d).

Lemma filter1000IsPR :
 forall g : nat -> nat, isPR 1 g -> isPR 4 (fun a b c d : nat => g a).

Lemma filter1011IsPR :
 forall g : nat -> nat -> nat -> nat,
 isPR 3 g -> isPR 4 (fun a b c d : nat => g a c d).

Lemma filter1100IsPR :
 forall g : nat -> nat -> nat,
 isPR 2 g -> isPR 4 (fun a b c d : nat => g a b).

Lemma compose1_1IsPR :
 forall f : nat -> nat,
 isPR 1 f ->
 forall g : nat -> nat, isPR 1 g -> isPR 1 (fun x : nat => g (f x)).

Lemma compose1_2IsPR :
 forall f : nat -> nat,
 isPR 1 f ->
 forall f' : nat -> nat,
 isPR 1 f' ->
 forall g : nat -> nat -> nat,
 isPR 2 g -> isPR 1 (fun x : nat => g (f x) (f' x)).

Lemma compose1_3IsPR :
 forall f1 : nat -> nat,
 isPR 1 f1 ->
 forall f2 : nat -> nat,
 isPR 1 f2 ->
 forall f3 : nat -> nat,
 isPR 1 f3 ->
 forall g : nat -> nat -> nat -> nat,
 isPR 3 g -> isPR 1 (fun x : nat => g (f1 x) (f2 x) (f3 x)).

Lemma compose2_1IsPR :
 forall f : nat -> nat -> nat,
 isPR 2 f ->
 forall g : nat -> nat, isPR 1 g -> isPR 2 (fun x y : nat => g (f x y)).

Lemma compose2_2IsPR :
 forall f : nat -> nat -> nat,
 isPR 2 f ->
 forall g : nat -> nat -> nat,
 isPR 2 g ->
 forall h : nat -> nat -> nat,
 isPR 2 h -> isPR 2 (fun x y : nat => h (f x y) (g x y)).

Lemma compose2_3IsPR :
 forall f1 : nat -> nat -> nat,
 isPR 2 f1 ->
 forall f2 : nat -> nat -> nat,
 isPR 2 f2 ->
 forall f3 : nat -> nat -> nat,
 isPR 2 f3 ->
 forall g : nat -> nat -> nat -> nat,
 isPR 3 g -> isPR 2 (fun x y : nat => g (f1 x y) (f2 x y) (f3 x y)).

Lemma compose2_4IsPR :
 forall f1 : nat -> nat -> nat,
 isPR 2 f1 ->
 forall f2 : nat -> nat -> nat,
 isPR 2 f2 ->
 forall f3 : nat -> nat -> nat,
 isPR 2 f3 ->
 forall f4 : nat -> nat -> nat,
 isPR 2 f4 ->
 forall g : nat -> nat -> nat -> nat -> nat,
 isPR 4 g -> isPR 2 (fun x y : nat => g (f1 x y) (f2 x y) (f3 x y) (f4 x y)).

Lemma compose3_1IsPR :
 forall f : nat -> nat -> nat -> nat,
 isPR 3 f ->
 forall g : nat -> nat, isPR 1 g -> isPR 3 (fun x y z : nat => g (f x y z)).

Lemma compose3_2IsPR :
 forall f1 : nat -> nat -> nat -> nat,
 isPR 3 f1 ->
 forall f2 : nat -> nat -> nat -> nat,
 isPR 3 f2 ->
 forall g : nat -> nat -> nat,
 isPR 2 g -> isPR 3 (fun x y z : nat => g (f1 x y z) (f2 x y z)).

Lemma compose3_3IsPR :
 forall f1 : nat -> nat -> nat -> nat,
 isPR 3 f1 ->
 forall f2 : nat -> nat -> nat -> nat,
 isPR 3 f2 ->
 forall f3 : nat -> nat -> nat -> nat,
 isPR 3 f3 ->
 forall g : nat -> nat -> nat -> nat,
 isPR 3 g -> isPR 3 (fun x y z : nat => g (f1 x y z) (f2 x y z) (f3 x y z)).

Lemma compose4_2IsPR :
 forall f1 : nat -> nat -> nat -> nat -> nat,
 isPR 4 f1 ->
 forall f2 : nat -> nat -> nat -> nat -> nat,
 isPR 4 f2 ->
 forall g : nat -> nat -> nat,
 isPR 2 g -> isPR 4 (fun w x y z : nat => g (f1 w x y z) (f2 w x y z)).

Lemma compose4_3IsPR :
 forall f1 : nat -> nat -> nat -> nat -> nat,
 isPR 4 f1 ->
 forall f2 : nat -> nat -> nat -> nat -> nat,
 isPR 4 f2 ->
 forall f3 : nat -> nat -> nat -> nat -> nat,
 isPR 4 f3 ->
 forall g : nat -> nat -> nat -> nat,
 isPR 3 g ->
 isPR 4 (fun w x y z : nat => g (f1 w x y z) (f2 w x y z) (f3 w x y z)).

Lemma swapIsPR :
 forall f : nat -> nat -> nat, isPR 2 f -> isPR 2 (fun x y : nat => f y x).

Lemma indIsPR :
 forall f : nat -> nat -> nat,
 isPR 2 f ->
 forall g : nat,
 isPR 1
   (fun a : nat => nat_rec (fun n : nat => nat) g (fun x y : nat => f x y) a).

Lemma ind1ParamIsPR :
 forall f : nat -> nat -> nat -> nat,
 isPR 3 f ->
 forall g : nat -> nat,
 isPR 1 g ->
 isPR 2
   (fun a b : nat =>
    nat_rec (fun n : nat => nat) (g b) (fun x y : nat => f x y b) a).

Lemma ind2ParamIsPR :
 forall f : nat -> nat -> nat -> nat -> nat,
 isPR 4 f ->
 forall g : nat -> nat -> nat,
 isPR 2 g ->
 isPR 3
   (fun a b c : nat =>
    nat_rec (fun n : nat => nat) (g b c) (fun x y : nat => f x y b c) a).

Lemma plusIndIsPR : isPR 3 (fun n fn b : nat => S fn).

Lemma plusIsPR : isPR 2 plus.

Lemma multIndIsPR : isPR 3 (fun n fn b : nat => fn + b).

Lemma multIsPR : isPR 2 mult.

Lemma predIsPR : isPR 1 pred.

Lemma minusIndIsPR : isPR 3 (fun n fn b : nat => pred fn).

Lemma minusIsPR : isPR 2 minus.

Definition notZero (a : nat) :=
  nat_rec (fun n : nat => nat) 0 (fun x y : nat => 1) a.

Lemma notZeroIsPR : isPR 1 notZero.

Definition ltBool (a b : nat) : bool.

Lemma ltBoolTrue : forall a b : nat, ltBool a b = true -> a < b.

Lemma ltBoolFalse : forall a b : nat, ltBool a b = false -> ~ a < b.

Lemma ltIsPR : isPRrel 2 ltBool.

Lemma maxIsPR : isPR 2 max.

Lemma gtIsPR : isPRrel 2 (fun a b : nat => ltBool b a).

Remark replaceCompose2 :
 forall (n : nat) (a b a' b' : naryFunc n) (c c' : naryFunc 2),
 extEqual n a a' ->
 extEqual n b b' ->
 extEqual 2 c c' ->
 extEqual n
   (evalComposeFunc _ _ (Vector.cons _ a _ (Vector.cons _ b _ (Vector.nil  (naryFunc n)))) c)

Definition orRel (n : nat) (R S : naryRel n) : naryRel n.

Lemma orRelPR :
 forall (n : nat) (R R' : naryRel n),
 isPRrel n R -> isPRrel n R' -> isPRrel n (orRel n R R').

Definition andRel (n : nat) (R S : naryRel n) : naryRel n.

Lemma andRelPR :
 forall (n : nat) (R R' : naryRel n),
 isPRrel n R -> isPRrel n R' -> isPRrel n (andRel n R R').

Definition notRel (n : nat) (R : naryRel n) : naryRel n.

Lemma notRelPR :
 forall (n : nat) (R : naryRel n), isPRrel n R -> isPRrel n (notRel n R).

Fixpoint bodd (n : nat) : bool :=
  match n with
  | O => false
  | S n' => negb (bodd n')
  end.

Lemma boddIsPR : isPRrel 1 bodd.

Lemma beq_nat_not_refl : forall a b : nat, a <> b -> beq_nat a b = false.

Lemma neqIsPR : isPRrel 2 (fun a b : nat => negb (beq_nat a b)).

Lemma eqIsPR : isPRrel 2 beq_nat.

Definition leBool (a b : nat) : bool.

Lemma leIsPR : isPRrel 2 leBool.

Section Ignore_Params.

Fixpoint ignoreParams (n m : nat) (f : naryFunc n) {struct m} :
 naryFunc (m + n) :=
  match m return (naryFunc (m + n)) with
  | O => f
  | S x => fun _ => ignoreParams n x f
  end.

Definition projectionListPR (n m : nat) (p : m <= n) : PrimRecs n m.

Definition projectionList (n m : nat) (p : m <= n) : 
  Vector.t (naryFunc n) m := evalPrimRecs n m (projectionListPR n m p).

Lemma projectionListInd :
 forall (n m : nat) (p1 p2 : m <= n),
 projectionList n m p1 = projectionList n m p2.

Lemma projectionListApplyParam :
 forall (m n c : nat) (p1 : m <= n) (p2 : m <= S n),
 extEqualVector _ _ (projectionList n m p1)
   (evalOneParamList n m c (projectionList (S n) m p2)).

Lemma projectionListId :
 forall (n : nat) (f : naryFunc n) (p : n <= n),
 extEqual n f (evalComposeFunc n n (projectionList n n p) f).

Lemma ignoreParamsIsPR :
 forall (n m : nat) (f : naryFunc n), isPR _ f -> isPR _ (ignoreParams n m f).

End Ignore_Params.

Lemma reduce1stCompose :
 forall (c n m : nat) (v : Vector.t (naryFunc n) m) (g : naryFunc (S m)),

Lemma reduce2ndCompose :
 forall (c n m : nat) (v : Vector.t (naryFunc n) m) (n0 : naryFunc n)

Lemma evalPrimRecParam :
 forall (n c d : nat) (g : naryFunc (S n)) (h : naryFunc (S (S (S n)))),
 extEqual _ (evalPrimRecFunc n (g d) (fun x y : nat => h x y d) c)
   (evalPrimRecFunc (S n) g h c d).

Lemma compose2IsPR :
 forall (n : nat) (f : naryFunc n) (p : isPR n f) (g : naryFunc (S n))
   (q : isPR (S n) g), isPR n (compose2 n f g).

Lemma compose1_NIsPR :
 forall (n : nat) (g : naryFunc (S n)),
 isPR (S n) g ->
 forall f : naryFunc 1, isPR 1 f -> isPR (S n) (fun x : nat => g (f x)).

Definition switchPR : naryFunc 3. 

Lemma switchIsPR : isPR 3 switchPR.

Fixpoint boundedSearchHelp (P : naryRel 1) (b : nat) {struct b} : nat :=
  match b with
  | O => 0
  | S b' =>
      match eq_nat_dec (boundedSearchHelp P b') b' with
      | left _ => match P b' with
                  | true => b'
                  | false => S b'
                  end
      | right _ => boundedSearchHelp P b'
      end
  end.
   
Definition boundedSearch (P : naryRel 2) (b : nat) : nat :=
  boundedSearchHelp (P b) b.

Lemma boundedSearch1 :
 forall (P : naryRel 2) (b x : nat), x < boundedSearch P b -> P b x = false.

Lemma boundedSearch2 :
 forall (P : naryRel 2) (b : nat),
 boundedSearch P b = b \/ P b (boundedSearch P b) = true.

Lemma boundSearchIsPR :
 forall P : naryRel 2,
 isPRrel 2 P -> isPR 1 (fun b : nat => boundedSearch P b).

Definition iterate (g : nat -> nat) :=
  nat_rec (fun _ => nat -> nat) (fun x : nat => x)
    (fun (_ : nat) (rec : nat -> nat) (x : nat) => g (rec x)).

Lemma iterateIsPR :
 forall g : nat -> nat, isPR 1 g -> forall n : nat, isPR 1 (iterate g n). *)

Require Import cPair.
(* cPair:
Require Import Arith.
Require Import Coq.Lists.List.
Require Import extEqualNat.
Require Import primRec.
Require Vector.
Require Import Div2.

Definition sumToN (n : nat) :=
  nat_rec (fun _ => nat) 0 (fun x y : nat => S x + y) n.

Lemma sumToN1 : forall n : nat, n <= sumToN n.

Lemma sumToN2 : forall b a : nat, a <= b -> sumToN a <= sumToN b.

Lemma sumToNIsPR : isPR 1 sumToN.

Definition cPair (a b : nat) := a + sumToN (a + b).

Lemma cPairIsPR : isPR 2 cPair.

Section CPair_Injectivity.

Remark cPairInjHelp :
 forall a b c d : nat, cPair a b = cPair c d -> a + b = c + d.

Lemma cPairInj1 : forall a b c d : nat, cPair a b = cPair c d -> a = c.

Lemma cPairInj2 : forall a b c d : nat, cPair a b = cPair c d -> b = d.

End CPair_Injectivity.

Section CPair_projections.

Let searchXY (a : nat) :=
  boundedSearch (fun a y : nat => ltBool a (sumToN (S y))) a.

Definition cPairPi1 (a : nat) := a - sumToN (searchXY a).
Definition cPairPi2 (a : nat) := searchXY a - cPairPi1 a.

Lemma cPairProjectionsHelp :
 forall a b : nat, b < sumToN (S a) -> sumToN a <= b -> searchXY b = a.

Lemma cPairProjections : forall a : nat, cPair (cPairPi1 a) (cPairPi2 a) = a.

Remark searchXYIsPR : isPR 1 searchXY.

Lemma cPairPi1IsPR : isPR 1 cPairPi1.

Lemma cPairPi2IsPR : isPR 1 cPairPi2.

Lemma cPairProjections1 : forall a b : nat, cPairPi1 (cPair a b) = a.

Lemma cPairProjections2 : forall a b : nat, cPairPi2 (cPair a b) = b.

End CPair_projections.

Section CPair_Order.

Lemma cPairLe1 : forall a b : nat, a <= cPair a b.

Lemma cPairLe1A : forall a : nat, cPairPi1 a <= a.

Lemma cPairLe2 : forall a b : nat, b <= cPair a b.

Lemma cPairLe2A : forall a : nat, cPairPi2 a <= a.

Lemma cPairLe3 :
 forall a b c d : nat, a <= b -> c <= d -> cPair a c <= cPair b d.

Lemma cPairLt1 : forall a b : nat, a < cPair a (S b).

Lemma cPairLt2 : forall a b : nat, b < cPair (S a) b.

End CPair_Order.

Section code_nat_list.

Fixpoint codeList (l : list nat) : nat :=
  match l with
  | nil => 0
  | n :: l' => S (cPair n (codeList l'))
  end.

Lemma codeListInj : forall l m : list nat, codeList l = codeList m -> l = m.

Definition codeNth (n m : nat) : nat.

Let drop (n : nat) : forall (l : list nat), list nat.

Lemma codeNthCorrect :
 forall (n : nat) (l : list nat), codeNth n (codeList l) = nth n l 0.

Lemma codeNthIsPR : isPR 2 codeNth.

End code_nat_list.

Section Strong_Recursion.

Definition evalStrongRecHelp (n : nat) (f : naryFunc (S (S n))) :
  naryFunc (S n) :=
  evalPrimRecFunc n (evalComposeFunc n 0 (Vector.nil _) (codeList nil))
    (evalComposeFunc (S (S n)) 2
       (Vector.cons _ f _
          (Vector.cons _ (evalProjFunc (S (S n)) n (lt_S _ _ (lt_n_Sn _))) _
             (Vector.nil _))) (fun a b : nat => S (cPair a b))).

Definition evalStrongRec (n : nat) (f : naryFunc (S (S n))) :
  naryFunc (S n) :=
  evalComposeFunc (S n) 1
    (Vector.cons _ (fun z : nat => evalStrongRecHelp n f (S z)) _ (Vector.nil _))
    (fun z : nat => cPairPi1 (pred z)).

Lemma evalStrongRecIsPR :
 forall (n : nat) (f : naryFunc (S (S n))),
 isPR _ f -> isPR _ (evalStrongRec n f).

Lemma computeEvalStrongRecHelp :
 forall (n : nat) (f : naryFunc (S (S n))) (c : nat),
 evalStrongRecHelp n f (S c) =
 compose2 n (evalStrongRecHelp n f c)
   (fun a0 : nat =>
    evalComposeFunc n 2
      (Vector.cons (naryFunc n) (f c a0) 1

Let listValues (f : naryFunc 2) (n : nat) : list nat.

Lemma evalStrongRecHelp1 :
 forall (f : naryFunc 2) (n m : nat),
 m < n -> codeNth (n - S m) (evalStrongRecHelp _ f n) = evalStrongRec _ f m.

Lemma evalStrongRecHelpParam :
 forall (a n c : nat) (f : naryFunc (S (S (S a)))),
 extEqual a (evalStrongRecHelp (S a) f n c)
   (evalStrongRecHelp a (fun x y : nat => f x y c) n).

Lemma evalStrongRecHelp2 :
 forall (a : nat) (f : naryFunc (S (S a))) (n m : nat),
 m < n ->
 extEqual _
   (evalComposeFunc _ 1 (Vector.cons _ (evalStrongRecHelp _ f n) 0 (Vector.nil _))

Lemma callIsPR :
 forall g : nat -> nat,
 isPR 1 g -> isPR 2 (fun a recs : nat => codeNth (a - S (g a)) recs).

End Strong_Recursion.

Lemma div2IsPR : isPR 1 div2. *)

Require Export Coq.Lists.List.

Require Import ListExt.
(* ListExt:
Require Import Coq.Lists.List.

Section List_Remove.

Variable A : Set.
Hypothesis Aeq_dec : forall a b : A, {a = b} + {a <> b}.

Definition list_remove (x : A) (l : list A) : list A :=
  list_rec (fun _ => list A) nil
    (fun (a : A) _ (recl : list A) =>
     match Aeq_dec a x with
     | left _ => recl
     | right _ => a :: recl
     end) l.

Lemma In_list_remove1 :
 forall (a b : A) (l : list A), In a (list_remove b l) -> In a l.

Lemma In_list_remove2 :
 forall (a b : A) (l : list A), In a (list_remove b l) -> a <> b.

Lemma In_list_remove3 :
 forall (a b : A) (l : list A), In a l -> a <> b -> In a (list_remove b l).

End List_Remove.

Section No_Duplicate.

Variable A : Set.
Hypothesis Aeq_dec : forall a b : A, {a = b} + {a <> b}.

Definition no_dup (l : list A) : list A :=
  list_rec (fun _ => list A) nil
    (fun (a : A) _ (rec : list A) =>
     match In_dec Aeq_dec a rec with
     | left _ => rec
     | right _ => a :: rec
     end) l.

Lemma no_dup1 : forall (a : A) (l : list A), In a l -> In a (no_dup l).

Lemma no_dup2 : forall (a : A) (l : list A), In a (no_dup l) -> In a l.

Lemma no_dup3 : forall (k l : list A) (a : A), no_dup k = a :: l -> ~ In a l.

End No_Duplicate. *)

Require Import Arith.

Require Vector.

Require Import extEqualNat.
(* extEqualNat:
Require Import Arith.

Fixpoint naryFunc (n : nat) : Set :=
  match n with
  | O => nat
  | S n => nat -> naryFunc n
  end.

Fixpoint naryRel (n : nat) : Set :=
  match n with
  | O => bool
  | S n => nat -> naryRel n
  end.

Definition extEqual (n : nat) (a b : naryFunc n) : Prop.

Lemma extEqualRefl : forall (n : nat) (a : naryFunc n), extEqual n a a.

Lemma extEqualSym :
 forall (n : nat) (a b : naryFunc n), extEqual n a b -> extEqual n b a.

Lemma extEqualTrans :
 forall (n : nat) (a b c : naryFunc n),
 extEqual n a b -> extEqual n b c -> extEqual n a c.

Fixpoint charFunction (n : nat) : naryRel n -> naryFunc n :=
  match n return (naryRel n -> naryFunc n) with
  | O => fun R : bool => match R with
                         | true => 1
                         | false => 0
                         end
  | S m => fun (R : naryRel (S m)) (a : nat) => charFunction m (R a)
  end. *)



Definition codeLength : nat -> nat :=

  evalStrongRec 0

    (fun n Hrecs : nat =>

     switchPR n (S (codeNth (n - S (cPairPi2 (pred n))) Hrecs)) 0).



Lemma codeLengthCorrect :

 forall l : list nat, codeLength (codeList l) = length l.

Proof.

intros.

induction l as [| a l Hrecl].

reflexivity.

simpl in |- *.

unfold codeLength in |- *.

set

 (f :=

  fun n Hrecs : nat =>

  switchPR n (S (codeNth (n - S (cPairPi2 (pred n))) Hrecs)) 0) 

 in *.

unfold evalStrongRec in |- *.

unfold evalComposeFunc in |- *.

unfold evalOneParamList in |- *.

unfold evalList in |- *.

rewrite computeEvalStrongRecHelp.

unfold compose2 in |- *.

unfold evalComposeFunc in |- *.

unfold evalList in |- *.

unfold f at 1 in |- *.

rewrite evalStrongRecHelp1.

simpl in |- *.

rewrite cPairProjections1.

apply eq_S.

rewrite cPairProjections2.

apply Hrecl.

simpl in |- *.

apply le_lt_n_Sm.

generalize (cPair a (codeList l)).

intro.

apply le_trans with (cPair (cPairPi1 n) (cPairPi2 n)).

apply cPairLe2.

rewrite cPairProjections.

apply le_n.

Qed.



Lemma codeLengthIsPR : isPR 1 codeLength.

Proof.

unfold codeLength in |- *.

apply evalStrongRecIsPR.

apply

 compose2_3IsPR

  with

    (f1 := fun n Hrecs : nat => n)

    (f2 := fun n Hrecs : nat => S (codeNth (n - S (cPairPi2 (pred n))) Hrecs))

    (f3 := fun n Hrecs : nat => 0).

apply pi1_2IsPR.

apply

 compose2_1IsPR

  with (f := fun n Hrecs : nat => codeNth (n - S (cPairPi2 (pred n))) Hrecs).

apply

 compose2_2IsPR

  with

    (f := fun n Hrecs : nat => n - S (cPairPi2 (pred n)))

    (g := fun n Hrecs : nat => Hrecs).

apply filter10IsPR with (g := fun n : nat => n - S (cPairPi2 (pred n))).

apply

 compose1_2IsPR

  with (f := fun n : nat => n) (f' := fun n : nat => S (cPairPi2 (pred n))).

apply idIsPR.

apply compose1_1IsPR with (f := fun n : nat => cPairPi2 (pred n)).

apply compose1_1IsPR.

apply predIsPR.

apply cPairPi2IsPR.

apply succIsPR.

apply minusIsPR.

apply pi2_2IsPR.

apply codeNthIsPR.

apply succIsPR.

apply filter10IsPR with (g := fun _ : nat => 0).

apply const1_NIsPR.

apply switchIsPR.

Qed.



Definition codeApp : nat -> nat -> nat :=

  evalStrongRec 1

    (fun n Hrecs p1 : nat =>

     switchPR n

       (S

          (cPair (cPairPi1 (pred n))

             (codeNth (n - S (cPairPi2 (pred n))) Hrecs))) p1).



Lemma codeAppCorrect :

 forall l1 l2 : list nat,

 codeApp (codeList l1) (codeList l2) = codeList (l1 ++ l2).

Proof.

intros.

unfold codeApp in |- *.

set

 (f :=

  fun n Hrecs p1 : nat =>

  switchPR n

    (S

       (cPair (cPairPi1 (pred n)) (codeNth (n - S (cPairPi2 (pred n))) Hrecs)))

    p1) in *.

induction l1 as [| a l1 Hrecl1].

unfold evalStrongRec in |- *.

simpl in |- *.

rewrite cPairProjections1.

reflexivity.

simpl in |- *.

unfold evalStrongRec in |- *.

unfold evalComposeFunc in |- *.

unfold evalOneParamList in |- *.

rewrite computeEvalStrongRecHelp.

unfold f at 2 in |- *.

unfold pred in |- *.

set (n := S (cPair a (codeList l1))) in *.

simpl in |- *.

repeat rewrite cPairProjections1 || rewrite cPairProjections2.

replace (codeList (l1 ++ l2)) with

 (codeNth (cPair a (codeList l1) - codeList l1)

    (evalStrongRecHelp 1 f n (codeList l2))).

reflexivity.

assert

 (extEqual 1

    (evalComposeFunc 1 1 (Vector.cons _ (evalStrongRecHelp 1 f n) 0 (Vector.nil _))

       (fun b : nat => codeNth (n - S (codeList l1)) b))

    (evalStrongRec 1 f (codeList l1))).

apply (evalStrongRecHelp2 1).

unfold n in |- *.

apply le_lt_n_Sm.

apply cPairLe2.

simpl in H.

rewrite H.

auto.

Qed.



Lemma codeAppIsPR : isPR 2 codeApp.

Proof.

unfold codeApp in |- *.

apply evalStrongRecIsPR.

apply

 compose3_3IsPR

  with

    (f1 := fun n Hrecs p1 : nat => n)

    (f2 := fun n Hrecs p1 : nat =>

           S

             (cPair (cPairPi1 (pred n))

                (codeNth (n - S (cPairPi2 (pred n))) Hrecs)))

    (f3 := fun n Hrecs p1 : nat => p1).

apply pi1_3IsPR.

apply

 filter110IsPR

  with

    (g := fun n Hrecs : nat =>

          S

            (cPair (cPairPi1 (pred n))

               (codeNth (n - S (cPairPi2 (pred n))) Hrecs))).

apply

 compose2_1IsPR

  with

    (g := S)

    (f := fun n Hrecs : nat =>

          cPair (cPairPi1 (pred n))

            (codeNth (n - S (cPairPi2 (pred n))) Hrecs)).

apply

 compose2_2IsPR

  with

    (h := cPair)

    (f := fun n Hrecs : nat => cPairPi1 (pred n))

    (g := fun n Hrecs : nat => codeNth (n - S (cPairPi2 (pred n))) Hrecs).

apply filter10IsPR with (g := fun n : nat => cPairPi1 (pred n)).

apply compose1_1IsPR.

apply predIsPR.

apply cPairPi1IsPR.

apply

 compose2_2IsPR

  with

    (h := codeNth)

    (f := fun n Hrecs : nat => n - S (cPairPi2 (pred n)))

    (g := fun n Hrecs : nat => Hrecs).

apply filter10IsPR with (g := fun n : nat => n - S (cPairPi2 (pred n))).

apply

 compose1_2IsPR

  with

    (g := minus)

    (f := fun n : nat => n)

    (f' := fun n : nat => S (cPairPi2 (pred n))).

apply idIsPR.

apply compose1_1IsPR with (g := S) (f := fun n : nat => cPairPi2 (pred n)).

apply compose1_1IsPR.

apply predIsPR.

apply cPairPi2IsPR.

apply succIsPR.

apply minusIsPR.

apply pi2_2IsPR.

apply codeNthIsPR.

apply cPairIsPR.

apply succIsPR.

apply pi3_3IsPR.

apply switchIsPR.

Qed.



Definition codeListRemove (a l : nat) : nat :=

  evalStrongRec 1

    (fun n Hrecs p1 : nat =>

     switchPR n

       (switchPR (charFunction 2 beq_nat (cPairPi1 (pred n)) p1)

          (codeNth (n - S (cPairPi2 (pred n))) Hrecs)

          (S

             (cPair (cPairPi1 (pred n))

                (codeNth (n - S (cPairPi2 (pred n))) Hrecs)))) 

       (codeList nil)) l a.



Lemma codeListRemoveCorrect :

 forall (a : nat) (l : list nat),

 codeListRemove a (codeList l) = codeList (list_remove nat eq_nat_dec a l).

Proof.

intros.

unfold codeListRemove in |- *.

set

 (f :=

  fun n Hrecs p1 : nat =>

  switchPR n

    (switchPR (charFunction 2 beq_nat (cPairPi1 (pred n)) p1)

       (codeNth (n - S (cPairPi2 (pred n))) Hrecs)

       (S

          (cPair (cPairPi1 (pred n))

             (codeNth (n - S (cPairPi2 (pred n))) Hrecs)))) 

    (codeList nil)) in *.

induction l as [| a0 l Hrecl].

simpl in |- *.

unfold evalStrongRec in |- *.

simpl in |- *.

reflexivity.

unfold evalStrongRec in |- *.

unfold evalComposeFunc in |- *.

unfold evalOneParamList in |- *.

rewrite computeEvalStrongRecHelp.

unfold f at 2 in |- *.

unfold compose2 in |- *.

set (n := codeList (a0 :: l)) in *.

set (A := n - S (cPairPi2 (pred n))) in *.

simpl in |- *.

repeat rewrite cPairProjections1 || rewrite cPairProjections2.

assert

 (extEqual 1

    (evalComposeFunc 1 1 (Vector.cons _ (evalStrongRecHelp 1 f n) 0 (Vector.nil _))

       (fun b : nat => codeNth (n - S (cPairPi2 (pred n))) b))

    (evalStrongRec 1 f (cPairPi2 (pred n)))).

apply (evalStrongRecHelp2 1).

simpl in |- *.

unfold n in |- *.

rewrite cPairProjections2.

simpl in |- *.

apply le_lt_n_Sm.

apply cPairLe2.

simpl in H.

induction (eq_nat_dec a0 a).

rewrite a1.

rewrite <- beq_nat_refl.

simpl in |- *.

unfold A in |- *.

rewrite H.

rewrite cPairProjections2.

auto.

rewrite beq_nat_not_refl.

simpl in |- *.

replace (codeList (list_remove nat eq_nat_dec a l)) with

 (codeNth A (evalStrongRecHelp 1 f n a)).

reflexivity.

unfold A in |- *.

rewrite H.

simpl in |- *.

rewrite cPairProjections2.

auto.

auto.

Qed.



Lemma codeListRemoveIsPR : isPR 2 codeListRemove.

Proof.

intros.

unfold codeListRemove in |- *.

apply swapIsPR.

apply evalStrongRecIsPR.

apply

 compose3_3IsPR

  with

    (g := switchPR)

    (f1 := fun n Hrecs p1 : nat => n)

    (f2 := fun n Hrecs p1 : nat =>

           switchPR (charFunction 2 beq_nat (cPairPi1 (pred n)) p1)

             (codeNth (n - S (cPairPi2 (pred n))) Hrecs)

             (S

                (cPair (cPairPi1 (pred n))

                   (codeNth (n - S (cPairPi2 (pred n))) Hrecs))))

    (f3 := fun n Hrecs p1 : nat => codeList nil).

apply pi1_3IsPR.

assert

 (isPR 3 (fun n Hrecs p1 : nat => codeNth (n - S (cPairPi2 (pred n))) Hrecs)).

apply

 filter110IsPR

  with (g := fun n Hrecs : nat => codeNth (n - S (cPairPi2 (pred n))) Hrecs).

apply

 compose2_2IsPR

  with

    (h := codeNth)

    (f := fun n Hrecs : nat => n - S (cPairPi2 (pred n)))

    (g := fun n Hrecs : nat => Hrecs).

apply filter10IsPR with (g := fun n : nat => n - S (cPairPi2 (pred n))).

apply

 compose1_2IsPR

  with

    (g := minus)

    (f := fun n : nat => n)

    (f' := fun n : nat => S (cPairPi2 (pred n))).

apply idIsPR.

apply compose1_1IsPR with (f := fun n : nat => cPairPi2 (pred n)).

apply compose1_1IsPR.

apply predIsPR.

apply cPairPi2IsPR.

apply succIsPR.

apply minusIsPR.

apply pi2_2IsPR.

apply codeNthIsPR.

apply

 compose3_3IsPR

  with

    (g := switchPR)

    (f1 := fun n Hrecs p1 : nat =>

           charFunction 2 beq_nat (cPairPi1 (pred n)) p1)

    (f2 := fun n Hrecs p1 : nat => codeNth (n - S (cPairPi2 (pred n))) Hrecs)

    (f3 := fun n Hrecs p1 : nat =>

           S

             (cPair (cPairPi1 (pred n))

                (codeNth (n - S (cPairPi2 (pred n))) Hrecs))).

apply

 filter101IsPR

  with (g := fun n p1 : nat => charFunction 2 beq_nat (cPairPi1 (pred n)) p1).

apply

 compose2_2IsPR

  with (f := fun n p1 : nat => cPairPi1 (pred n)) (g := fun n p1 : nat => p1).

apply filter10IsPR with (g := fun n : nat => cPairPi1 (pred n)).

apply compose1_1IsPR.

apply predIsPR.

apply cPairPi1IsPR.

apply pi2_2IsPR.

apply eqIsPR.

apply H.

apply

 compose3_1IsPR

  with

    (g := S)

    (f := fun n Hrecs _ : nat =>

          cPair (cPairPi1 (pred n))

            (codeNth (n - S (cPairPi2 (pred n))) Hrecs)).

apply

 compose3_2IsPR

  with

    (g := cPair)

    (f1 := fun n Hrecs _ : nat => cPairPi1 (pred n))

    (f2 := fun n Hrecs _ : nat => codeNth (n - S (cPairPi2 (pred n))) Hrecs).

apply filter100IsPR with (g := fun n : nat => cPairPi1 (pred n)).

apply compose1_1IsPR.

apply predIsPR.

apply cPairPi1IsPR.

apply H.

apply cPairIsPR.

apply succIsPR.

apply switchIsPR.

exists (composeFunc 3 0 (PRnil _) zeroFunc).

simpl in |- *.

auto.

apply switchIsPR.

Qed.



Definition codeIn (a l : nat) : nat :=

  evalStrongRec 1

    (fun n Hrecs p1 : nat =>

     switchPR n

       (switchPR (charFunction 2 beq_nat (cPairPi1 (pred n)) p1) 1

          (codeNth (n - S (cPairPi2 (pred n))) Hrecs)) 0) l a.



Lemma codeInCorrect :

 forall (a : nat) (l : list nat),

 codeIn a (codeList l) =

 match In_dec eq_nat_dec a l with

 | left _ => 1

 | right _ => 0

 end.

Proof.

intros.

induction l as [| a0 l Hrecl]; simpl in |- *.

unfold codeIn, evalStrongRec in |- *.

simpl in |- *.

rewrite cPairProjections1.

reflexivity.

unfold codeIn, evalStrongRec in |- *.

unfold evalComposeFunc in |- *.

unfold evalOneParamList in |- *.

rewrite computeEvalStrongRecHelp.

unfold evalList in |- *.

set

 (f :=

  fun n Hrecs p1 : nat =>

  switchPR n

    (switchPR (charFunction 2 beq_nat (cPairPi1 (pred n)) p1) 1

       (codeNth (n - S (cPairPi2 (pred n))) Hrecs)) 0) 

 in *.

set (m := cPairPi2 (pred (S (cPair a0 (codeList l))))) in *.

set (n := S (cPair a0 (codeList l))) in *.

simpl in |- *.

repeat rewrite cPairProjections1.

induction (eq_nat_dec a0 a).

rewrite a1.

rewrite <- beq_nat_refl.

simpl in |- *.

reflexivity.

rewrite beq_nat_not_refl.

simpl in |- *.

assert

 (extEqual _

    (evalComposeFunc 1 1 (Vector.cons _ (evalStrongRecHelp 1 f n) 0 (Vector.nil _))

       (fun b : nat => codeNth (n - S m) b)) (evalStrongRec 1 f m)).

apply (evalStrongRecHelp2 1).

unfold m in |- *.

unfold n in |- *.

simpl in |- *.

rewrite cPairProjections2.

apply le_lt_n_Sm.

apply cPairLe2.

simpl in H.

rewrite H.

unfold codeIn in Hrecl.

move f after Hrecl;  fold f in Hrecl.

unfold m, n in |- *.

simpl in |- *.

rewrite cPairProjections2.

rewrite Hrecl.

clear H f Hrecl.

induction (In_dec eq_nat_dec a l).

induction (In_dec eq_nat_dec a (a0 :: l)).

reflexivity.

elim b0.

simpl in |- *.

auto.

induction (In_dec eq_nat_dec a (a0 :: l)).

induction a1 as [H| H].

elim b; auto.

elim b0; auto.

reflexivity.

auto.

Qed.



Lemma codeInIsPR : isPR 2 codeIn.

Proof.

unfold codeIn in |- *.

apply swapIsPR.

apply evalStrongRecIsPR.

apply

 compose3_3IsPR

  with

    (g := switchPR)

    (f1 := fun n Hrecs p1 : nat => n)

    (f2 := fun n Hrecs p1 : nat =>

           switchPR (charFunction 2 beq_nat (cPairPi1 (pred n)) p1) 1

             (codeNth (n - S (cPairPi2 (pred n))) Hrecs))

    (f3 := fun n Hrecs p1 : nat => 0).

apply pi1_3IsPR.

apply

 compose3_3IsPR

  with

    (g := switchPR)

    (f1 := fun n Hrecs p1 : nat =>

           charFunction 2 beq_nat (cPairPi1 (pred n)) p1)

    (f2 := fun n Hrecs p1 : nat => 1)

    (f3 := fun n Hrecs p1 : nat => codeNth (n - S (cPairPi2 (pred n))) Hrecs).

apply

 filter101IsPR

  with (g := fun n p1 : nat => charFunction 2 beq_nat (cPairPi1 (pred n)) p1).

apply

 compose2_2IsPR

  with

    (h := charFunction 2 beq_nat)

    (f := fun n p1 : nat => cPairPi1 (pred n))

    (g := fun n p1 : nat => p1).

apply filter10IsPR with (g := fun n : nat => cPairPi1 (pred n)).

apply compose1_1IsPR.

apply predIsPR.

apply cPairPi1IsPR.

apply pi2_2IsPR.

apply eqIsPR.

apply filter100IsPR with (g := fun _ : nat => 1).

apply const1_NIsPR.

apply

 filter110IsPR

  with (g := fun n Hrecs : nat => codeNth (n - S (cPairPi2 (pred n))) Hrecs).

apply

 compose2_2IsPR

  with

    (h := codeNth)

    (f := fun n Hrecs : nat => n - S (cPairPi2 (pred n)))

    (g := fun n Hrecs : nat => Hrecs).

apply filter10IsPR with (g := fun n : nat => n - S (cPairPi2 (pred n))).

apply

 compose1_2IsPR

  with

    (g := minus)

    (f := fun n : nat => n)

    (f' := fun n : nat => S (cPairPi2 (pred n))).

apply idIsPR.

apply compose1_1IsPR with (g := S) (f := fun n : nat => cPairPi2 (pred n)).

apply compose1_1IsPR.

apply predIsPR.

apply cPairPi2IsPR.

apply succIsPR.

apply minusIsPR.

apply pi2_2IsPR.

apply codeNthIsPR.

apply switchIsPR.

apply filter100IsPR with (g := fun _ : nat => 0).

apply const1_NIsPR.

apply switchIsPR.

Qed.



Definition codeNoDup : nat -> nat :=

  evalStrongRec 0

    (fun l recs : nat =>

     switchPR l

       (switchPR

          (codeIn (cPairPi1 (pred l))

             (codeNth (l - S (cPairPi2 (pred l))) recs))

          (codeNth (l - S (cPairPi2 (pred l))) recs)

          (S

             (cPair (cPairPi1 (pred l))

                (codeNth (l - S (cPairPi2 (pred l))) recs)))) 0).



Lemma codeNoDupCorrect :

 forall l : list nat,

 codeNoDup (codeList l) = codeList (no_dup _ eq_nat_dec l).

Proof.

intros.

unfold codeNoDup in |- *.

set

 (g :=

  fun l0 recs : nat =>

  switchPR l0

    (switchPR

       (codeIn (cPairPi1 (pred l0))

          (codeNth (l0 - S (cPairPi2 (pred l0))) recs))

       (codeNth (l0 - S (cPairPi2 (pred l0))) recs)

       (S

          (cPair (cPairPi1 (pred l0))

             (codeNth (l0 - S (cPairPi2 (pred l0))) recs)))) 0) 

 in *.

induction l as [| a l Hrecl].

simpl in |- *.

unfold evalStrongRec in |- *.

simpl in |- *.

rewrite cPairProjections1.

reflexivity.

simpl in |- *.

unfold evalStrongRec in |- *.

unfold evalComposeFunc, evalOneParamList, evalList in |- *.

rewrite computeEvalStrongRecHelp.

unfold compose2 in |- *.

unfold evalComposeFunc, evalOneParamList, evalList in |- *.

unfold g at 1 in |- *.

repeat rewrite evalStrongRecHelp1.

unfold pred in |- *.

repeat rewrite cPairProjections1 || rewrite cPairProjections2.

rewrite Hrecl.

rewrite codeInCorrect.

induction (In_dec eq_nat_dec a (no_dup nat eq_nat_dec l)).

reflexivity.

reflexivity.

simpl in |- *.

apply le_lt_n_Sm.

apply cPairLe2A.

Qed.



Lemma codeNoDupIsPR : isPR 1 codeNoDup.

Proof.

unfold codeNoDup in |- *.

apply evalStrongRecIsPR.

apply

 compose2_3IsPR

  with

    (f1 := fun l recs : nat => l)

    (f2 := fun l recs : nat =>

           switchPR

             (codeIn (cPairPi1 (pred l))

                (codeNth (l - S (cPairPi2 (pred l))) recs))

             (codeNth (l - S (cPairPi2 (pred l))) recs)

             (S

                (cPair (cPairPi1 (pred l))

                   (codeNth (l - S (cPairPi2 (pred l))) recs))))

    (f3 := fun l recs : nat => 0).

apply pi1_2IsPR.

assert

 (isPR 2 (fun l recs : nat => codeNth (l - S (cPairPi2 (pred l))) recs)).

apply callIsPR with (g := fun l : nat => cPairPi2 (pred l)).

apply compose1_1IsPR.

apply predIsPR.

apply cPairPi2IsPR.

apply

 compose2_3IsPR

  with

    (f1 := fun l recs : nat =>

           codeIn (cPairPi1 (pred l))

             (codeNth (l - S (cPairPi2 (pred l))) recs))

    (f2 := fun l recs : nat => codeNth (l - S (cPairPi2 (pred l))) recs)

    (f3 := fun l recs : nat =>

           S

             (cPair (cPairPi1 (pred l))

                (codeNth (l - S (cPairPi2 (pred l))) recs))).

apply

 compose2_2IsPR

  with

    (f := fun l recs : nat => cPairPi1 (pred l))

    (g := fun l recs : nat => codeNth (l - S (cPairPi2 (pred l))) recs).

apply filter10IsPR with (g := fun l : nat => cPairPi1 (pred l)).

apply compose1_1IsPR.

apply predIsPR.

apply cPairPi1IsPR.

assumption.

apply codeInIsPR.

assumption.

apply

 compose2_1IsPR

  with

    (f := fun l recs : nat =>

          cPair (cPairPi1 (pred l))

            (codeNth (l - S (cPairPi2 (pred l))) recs)).

apply

 compose2_2IsPR

  with

    (f := fun l recs : nat => cPairPi1 (pred l))

    (g := fun l recs : nat => codeNth (l - S (cPairPi2 (pred l))) recs).

apply filter10IsPR with (g := fun l : nat => cPairPi1 (pred l)).

apply compose1_1IsPR.

apply predIsPR.

apply cPairPi1IsPR.

assumption.

apply cPairIsPR.

apply succIsPR.

apply switchIsPR.

apply filter10IsPR with (g := fun _ : nat => 0).

apply const1_NIsPR.

apply switchIsPR.

Qed.

