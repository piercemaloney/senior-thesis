Require Import Ensembles.

Require Import Coq.Lists.List.

Require Import checkPrf.
(* checkPrf:
Require Import primRec.
Require Import codeFreeVar.
Require Import codeSubFormula.
Require Import cPair.
Require Import Arith.
Require Import code.
Require Import folProp.
Require Import extEqualNat.
Require Import wellFormed.
Require Import folProof.
Require Import prLogic.

Section Check_Proof.

Variable L : Language.
Variable codeF : Functions L -> nat.
Variable codeR : Relations L -> nat.
Variable codeArityF : nat -> nat.
Variable codeArityR : nat -> nat.
Hypothesis codeArityFIsPR : isPR 1 codeArityF.
Hypothesis
  codeArityFIsCorrect1 :
    forall f : Functions L, codeArityF (codeF f) = S (arity L (inr _ f)).
Hypothesis
  codeArityFIsCorrect2 :
    forall n : nat, codeArityF n <> 0 -> exists f : Functions L, codeF f = n.
Hypothesis codeArityRIsPR : isPR 1 codeArityR.
Hypothesis
  codeArityRIsCorrect1 :
    forall r : Relations L, codeArityR (codeR r) = S (arity L (inl _ r)).
Hypothesis
  codeArityRIsCorrect2 :
    forall n : nat, codeArityR n <> 0 -> exists r : Relations L, codeR r = n.

Hypothesis codeFInj : forall f g : Functions L, codeF f = codeF g -> f = g.
Hypothesis codeRInj : forall R S : Relations L, codeR R = codeR S -> R = S.

Let Term := Term L.
Let Terms := Terms L.
Let var := var L.
Let apply := apply L.
Let Formula := Formula L.
Let equal := equal L.
Let atomic := atomic L.
Let impH := impH L.
Let notH := notH L.
Let forallH := forallH L.
Let wellFormedTerm := wellFormedTerm codeArityF.
Let wellFormedFormula := wellFormedFormula codeArityF codeArityR.
Let Prf := Prf L.

Definition checkPrfAXM (p recs : nat) :=
  switchPR (charFunction 2 beq_nat (cPairPi2 (cPairPi2 p)) (cPairPi1 p))
    (S (S (cPair (cPairPi1 p) 0))) 0.

Lemma checkPrfAXMIsPR : isPR 2 checkPrfAXM.

Definition checkPrfMP (p recs : nat) :=
  switchPR
    (wellFormedFormula (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p)))) *
     (charFunction 2 beq_nat (cPairPi1 (cPairPi1 (cPairPi2 (cPairPi2 p))))
        (codeImp (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p)))) (cPairPi1 p)) *
      (codeNth (p - S (cPairPi1 (cPairPi2 (cPairPi2 p)))) recs *
       codeNth (p - S (cPairPi2 (cPairPi2 (cPairPi2 p)))) recs)))
    (S
       (codeApp
          (pred (codeNth (p - S (cPairPi1 (cPairPi2 (cPairPi2 p)))) recs))
          (pred (codeNth (p - S (cPairPi2 (cPairPi2 (cPairPi2 p)))) recs))))
    0.

Lemma checkPrfMPIsPR : isPR 2 checkPrfMP.

Definition checkPrfGEN (p recs : nat) :=
  switchPR
    (charFunction 2 beq_nat
       (cPair 3
          (cPair (cPairPi1 (cPairPi2 (cPairPi2 p)))
             (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p)))))) 
       (cPairPi1 p) *
     (codeNth (p - S (cPairPi2 (cPairPi2 (cPairPi2 p)))) recs *
      (1 -
       codeIn (cPairPi1 (cPairPi2 (cPairPi2 p)))
         (codeFreeVarListFormula
            (pred (codeNth (p - S (cPairPi2 (cPairPi2 (cPairPi2 p)))) recs))))))
    (codeNth (p - S (cPairPi2 (cPairPi2 (cPairPi2 p)))) recs) 0.

Lemma checkPrfGENIsPR : isPR 2 checkPrfGEN.

Definition checkPrfIMP1 (p recs : nat) :=
  let A := cPairPi1 (cPairPi2 (cPairPi2 p)) in
  let B := cPairPi2 (cPairPi2 (cPairPi2 p)) in
  charFunction 2 beq_nat (cPair 1 (cPair A (cPair 1 (cPair B A))))
    (cPairPi1 p).

Lemma checkPrfIMP1IsPR : isPR 2 checkPrfIMP1.

Definition checkPrfIMP2 (p recs : nat) :=
  let A := cPairPi1 (cPairPi2 (cPairPi2 p)) in
  let B := cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p))) in
  let C := cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p))) in
  charFunction 2 beq_nat
    (cPair 1
       (cPair (cPair 1 (cPair A (cPair 1 (cPair B C))))
          (cPair 1 (cPair (cPair 1 (cPair A B)) (cPair 1 (cPair A C))))))
    (cPairPi1 p).

Lemma checkPrfIMP2IsPR : isPR 2 checkPrfIMP2.

Definition checkPrfCP (p recs : nat) :=
  let A := cPairPi1 (cPairPi2 (cPairPi2 p)) in
  let B := cPairPi2 (cPairPi2 (cPairPi2 p)) in
  charFunction 2 beq_nat
    (cPair 1
       (cPair (cPair 1 (cPair (cPair 2 A) (cPair 2 B))) (cPair 1 (cPair B A))))
    (cPairPi1 p).

Lemma checkPrfCPIsPR : isPR 2 checkPrfCP.

Definition checkPrfFA1 (p recs : nat) :=
  let A := cPairPi1 (cPairPi2 (cPairPi2 p)) in
  let v := cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p))) in
  let t := cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p))) in
  wellFormedTerm t *
  charFunction 2 beq_nat
    (cPair 1 (cPair (cPair 3 (cPair v A)) (codeSubFormula A v t)))
    (cPairPi1 p).

Lemma checkPrfFA1IsPR : isPR 2 checkPrfFA1.

Definition checkPrfFA2 (p recs : nat) :=
  let A := cPairPi1 (cPairPi2 (cPairPi2 p)) in
  let v := cPairPi2 (cPairPi2 (cPairPi2 p)) in
  (1 - codeIn v (codeFreeVarFormula A)) *
  charFunction 2 beq_nat (cPair 1 (cPair A (cPair 3 (cPair v A))))
    (cPairPi1 p).

Lemma checkPrfFA2IsPR : isPR 2 checkPrfFA2.

Definition checkPrfFA3 (p recs : nat) :=
  let A := cPairPi1 (cPairPi2 (cPairPi2 p)) in
  let B := cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p))) in
  let v := cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p))) in
  charFunction 2 beq_nat
    (cPair 1
       (cPair (cPair 3 (cPair v (cPair 1 (cPair A B))))
          (cPair 1 (cPair (cPair 3 (cPair v A)) (cPair 3 (cPair v B))))))
    (cPairPi1 p).

Lemma checkPrfFA3IsPR : isPR 2 checkPrfFA3.

Definition checkPrfEQ1 (p recs : nat) :=
  charFunction 2 beq_nat (cPairPi2 (cPairPi2 p)) 0 *
  charFunction 2 beq_nat
    (codeFormula L codeF codeR (fol.equal L (fol.var L 0) (fol.var L 0)))
    (cPairPi1 p).

Lemma checkPrfEQnIsPR :
 forall n : nat,
 isPR 2
   (fun p recs : nat =>
    charFunction 2 beq_nat (cPairPi2 (cPairPi2 p)) 0 *
    charFunction 2 beq_nat n (cPairPi1 p)).

Lemma checkPrfEQ1IsPR : isPR 2 checkPrfEQ1.

Definition checkPrfEQ2 (p recs : nat) :=
  charFunction 2 beq_nat (cPairPi2 (cPairPi2 p)) 0 *
  charFunction 2 beq_nat
    (codeFormula L codeF codeR
       (fol.impH L (fol.equal L (fol.var L 0) (fol.var L 1))
          (fol.equal L (fol.var L 1) (fol.var L 0)))) 
    (cPairPi1 p).

Lemma checkPrfEQ2IsPR : isPR 2 checkPrfEQ2.

Definition checkPrfEQ3 (p recs : nat) :=
  charFunction 2 beq_nat (cPairPi2 (cPairPi2 p)) 0 *
  charFunction 2 beq_nat
    (codeFormula L codeF codeR
       (fol.impH L (fol.equal L (fol.var L 0) (fol.var L 1))
          (fol.impH L (fol.equal L (fol.var L 1) (fol.var L 2))
             (fol.equal L (fol.var L 0) (fol.var L 2))))) 
    (cPairPi1 p).

Lemma checkPrfEQ3IsPR : isPR 2 checkPrfEQ3.

Definition codeAxmEqHelp (n f : nat) : nat :=
  nat_rec (fun _ => nat) f
    (fun m rec : nat =>
     cPair 1
       (cPair (cPair 0 (cPair (cPair 0 (m + m)) (cPair 0 (S (m + m))))) rec))
    n.

Lemma codeAxmEqHelpIsPR : isPR 2 codeAxmEqHelp.

Definition codeNVars1 (n : nat) : nat :=
  nat_rec (fun _ => nat) 0
    (fun m rec : nat => S (cPair (cPair 0 (m + m)) rec)) n.

Lemma codeNVars1IsPR : isPR 1 codeNVars1.

Definition codeNVars2 (n : nat) : nat :=
  nat_rec (fun _ => nat) 0
    (fun m rec : nat => S (cPair (cPair 0 (S (m + m))) rec)) n.

Lemma codeNVars2IsPR : isPR 1 codeNVars2.

Lemma codeNVarsCorrect :
 forall n : nat,
 codeNVars1 n = codeTerms L codeF n (fst (nVars L n)) /\
 codeNVars2 n = codeTerms L codeF n (snd (nVars L n)).

Definition checkPrfEQ4 (p recs : nat) :=
  let r := cPairPi2 (cPairPi2 p) in
  let A := cPair (S (S (S (S r)))) (codeNVars1 (pred (codeArityR r))) in
  let B := cPair (S (S (S (S r)))) (codeNVars2 (pred (codeArityR r))) in
  notZero (codeArityR r) *
  charFunction 2 beq_nat (codeAxmEqHelp (pred (codeArityR r)) (codeIff A B))
    (cPairPi1 p).

Lemma codeOrIsPR : isPR 2 codeOr.

Lemma codeAndIsPR : isPR 2 codeAnd.

Lemma codeIffIsPR : isPR 2 codeIff.

Lemma checkPrfEQ4IsPR : isPR 2 checkPrfEQ4.

Definition checkPrfEQ5 (p recs : nat) :=
  let f := cPairPi2 (cPairPi2 p) in
  notZero (codeArityF f) *
  charFunction 2 beq_nat
    (codeAxmEqHelp (pred (codeArityF f))
       (cPair 0
          (cPair (cPair (S f) (codeNVars1 (pred (codeArityF f))))
             (cPair (S f) (codeNVars2 (pred (codeArityF f))))))) 
    (cPairPi1 p).

Lemma checkPrfEQ5IsPR : isPR 2 checkPrfEQ5.

Definition checkPrfHelp : nat -> nat :=
  evalStrongRec 0
    (fun p recs : nat =>
     let type := cPairPi1 (cPairPi2 p) in
     switchPR type
       (switchPR (pred type)
          (switchPR (pred (pred type))
             (switchPR (pred (pred (pred type)))
                (switchPR (pred (pred (pred (pred type))))
                   (switchPR (pred (pred (pred (pred (pred type)))))
                      (switchPR
                         (pred (pred (pred (pred (pred (pred type))))))
                         (switchPR
                            (pred
                               (pred (pred (pred (pred (pred (pred type)))))))
                            (switchPR
                               (pred
                                  (pred
                                     (pred
                                        (pred
                                           (pred (pred (pred (pred type))))))))
                               (switchPR
                                  (pred
                                     (pred
                                        (pred
                                           (pred
                                              (pred
                                                 (pred
                                                  (pred (pred (pred type)))))))))
                                  (switchPR
                                     (pred
                                        (pred
                                           (pred
                                              (pred
                                                 (pred
                                                  (pred
                                                  (pred
                                                  (pred (pred (pred type))))))))))
                                     (switchPR
                                        (pred
                                           (pred
                                              (pred
                                                 (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred (pred (pred type)))))))))))
                                        (switchPR
                                           (pred
                                              (pred
                                                 (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred (pred (pred type))))))))))))
                                           (switchPR
                                              (pred
                                                 (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred (pred (pred type)))))))))))))
                                              0 (checkPrfEQ5 p recs))
                                           (checkPrfEQ4 p recs))
                                        (checkPrfEQ3 p recs))
                                     (checkPrfEQ2 p recs))
                                  (checkPrfEQ1 p recs)) 
                               (checkPrfFA3 p recs)) 
                            (checkPrfFA2 p recs)) (checkPrfFA1 p recs))
                      (checkPrfCP p recs)) (checkPrfIMP2 p recs))
                (checkPrfIMP1 p recs)) (checkPrfGEN p recs))
          (checkPrfMP p recs)) (checkPrfAXM p recs)).

Lemma checkPrfHelpIsPR : isPR 1 checkPrfHelp.

Definition checkPrf (f p : nat) : nat :=
  switchPR (wellFormedFormula f) (checkPrfHelp (cPair f p)) 0.

Lemma checkPrfIsPR : isPR 2 checkPrf.

Lemma checkPrfCorrect1 :
 forall (l : list Formula) (f : Formula) (p : Prf l f),
 checkPrf (codeFormula L codeF codeR f) (codePrf L codeF codeR l f p) =
 S (codeList (map (codeFormula L codeF codeR) l)).

Lemma checkPrfCorrect2 :
 forall n m : nat,
 checkPrf n m <> 0 ->
 exists f : Formula,
   codeFormula L codeF codeR f = n /\
   (exists l : list Formula,
      (exists p : Prf l f, codePrf L codeF codeR l f p = m)).
Proof.
assert (multLemma1 : forall a b : nat, a * b <> 0 -> a <> 0).
unfold not in |- *; intros.
apply H.
rewrite H0.
simpl in |- *.
reflexivity.
assert (multLemma2 : forall a b : nat, a * b <> 0 -> b <> 0).
intros.
rewrite mult_comm in H.
eapply multLemma1.
apply H.
assert
 (forall m n : nat,
  n < m ->
  checkPrf (cPairPi1 n) (cPairPi2 n) <> 0 ->
  exists f : Formula,
    (exists l : list Formula,
       (exists p : Prf l f,
          cPair (codeFormula L codeF codeR f) (codePrf L codeF codeR l f p) =
          n))).
intro.
induction m as [| m Hrecm].
intros.
elim (lt_n_O _ H).
intros.
induction (le_lt_or_eq _ _ (lt_n_Sm_le _ _ H)).
apply Hrecm; assumption.
unfold checkPrf in H0.
assert (wellFormedFormula (cPairPi1 n) <> 0).
destruct (wellFormedFormula (cPairPi1 n)).
assumption.
discriminate.
induction
 (wellFormedFormulaCorrect2 L codeF codeArityF codeArityFIsCorrect1
    codeArityFIsCorrect2 codeR codeArityR codeArityRIsCorrect1
    codeArityRIsCorrect2 _ H2).
exists x.
destruct (wellFormedFormula (cPairPi1 n)).
elim H2.
auto.
simpl in H0.
clear H2.
unfold checkPrfHelp in H0.
set
 (A :=
  fun p recs : nat =>
  switchPR (cPairPi1 (cPairPi2 p))
    (switchPR (pred (cPairPi1 (cPairPi2 p)))
       (switchPR (pred (pred (cPairPi1 (cPairPi2 p))))
          (switchPR (pred (pred (pred (cPairPi1 (cPairPi2 p)))))
             (switchPR (pred (pred (pred (pred (cPairPi1 (cPairPi2 p))))))
                (switchPR
                   (pred (pred (pred (pred (pred (cPairPi1 (cPairPi2 p)))))))
                   (switchPR
                      (pred
                         (pred
                            (pred
                               (pred (pred (pred (cPairPi1 (cPairPi2 p))))))))
                      (switchPR
                         (pred
                            (pred
                               (pred
                                  (pred
                                     (pred
                                        (pred (pred (cPairPi1 (cPairPi2 p)))))))))
                         (switchPR
                            (pred
                               (pred
                                  (pred
                                     (pred
                                        (pred
                                           (pred
                                              (pred
                                                 (pred
                                                  (cPairPi1 (cPairPi2 p))))))))))
                            (switchPR
                               (pred
                                  (pred
                                     (pred
                                        (pred
                                           (pred
                                              (pred
                                                 (pred
                                                  (pred
                                                  (pred
                                                  (cPairPi1 (cPairPi2 p)))))))))))
                               (switchPR
                                  (pred
                                     (pred
                                        (pred
                                           (pred
                                              (pred
                                                 (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (cPairPi1 (cPairPi2 p))))))))))))
                                  (switchPR
                                     (pred
                                        (pred
                                           (pred
                                              (pred
                                                 (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (cPairPi1 (cPairPi2 p)))))))))))))
                                     (switchPR
                                        (pred
                                           (pred
                                              (pred
                                                 (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (cPairPi1 (cPairPi2 p))))))))))))))
                                        (switchPR
                                           (pred
                                              (pred
                                                 (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (cPairPi1 (cPairPi2 p)))))))))))))))
                                           0 (checkPrfEQ5 p recs))
                                        (checkPrfEQ4 p recs))
                                     (checkPrfEQ3 p recs))
                                  (checkPrfEQ2 p recs)) 
                               (checkPrfEQ1 p recs)) 
                            (checkPrfFA3 p recs)) (checkPrfFA2 p recs))
                      (checkPrfFA1 p recs)) (checkPrfCP p recs))
                (checkPrfIMP2 p recs)) (checkPrfIMP1 p recs))
          (checkPrfGEN p recs)) (checkPrfMP p recs)) 
    (checkPrfAXM p recs)) in *.
unfold evalStrongRec, evalComposeFunc, evalOneParamList, evalList in H0;
 rewrite computeEvalStrongRecHelp in H0;
 unfold compose2, evalComposeFunc, evalOneParamList, evalList in H0;
 simpl in H0.
rewrite cPairProjections1 in H0.
assert (cPair (cPairPi1 (cPairPi2 n)) (cPairPi2 (cPairPi2 n)) = cPairPi2 n).
apply cPairProjections.
unfold A at 1 in H0.
repeat first
 [ rewrite cPairProjections1 in H0 | rewrite cPairProjections2 in H0 ].
destruct (cPairPi1 (cPairPi2 n)).
simpl in H0.
unfold checkPrfAXM in H0.
repeat first
 [ rewrite cPairProjections1 in H0 | rewrite cPairProjections2 in H0 ].
rewrite <- H3 in H0.
induction (eq_nat_dec (cPairPi2 (cPairPi2 n)) (codeFormula L codeF codeR x)).
exists (x :: nil).
exists (AXM L x).
rewrite H3.
simpl in |- *.
rewrite a in H2.
rewrite H2.
apply cPairProjections.
elim H0.
unfold charFunction in |- *.
rewrite beq_nat_not_refl.
reflexivity.
assumption.
destruct n1.
simpl in H0.
unfold checkPrfMP in H0.
repeat first
 [ rewrite cPairProjections1 in H0 | rewrite cPairProjections2 in H0 ].
assert (cPairPi2 (cPairPi2 n) < n).
apply lt_le_trans with (cPair 1 (cPairPi2 (cPairPi2 n)));
 [ idtac | rewrite H2; apply cPairLe2A ].
apply cPairLt2.
assert (cPairPi1 (cPairPi2 (cPairPi2 n)) < n).
apply le_lt_trans with (cPairPi2 (cPairPi2 n)).
apply cPairLe1A.
assumption.
assert (cPairPi2 (cPairPi2 (cPairPi2 n)) < n).
apply le_lt_trans with (cPairPi2 (cPairPi2 n)).
apply cPairLe2A.
assumption.
rewrite evalStrongRecHelp1 in H0.
rewrite evalStrongRecHelp1 in H0.
assert (wellFormedFormula (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 n)))) <> 0).
unfold not in |- *; intros.
apply H0.
rewrite H7.
reflexivity.
induction
 (eq_nat_dec (cPairPi1 (cPairPi1 (cPairPi2 (cPairPi2 n))))
    (codeImp (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 n)))) (cPairPi1 n))).
induction
 (wellFormedFormulaCorrect2 L codeF codeArityF codeArityFIsCorrect1
    codeArityFIsCorrect2 codeR codeArityR codeArityRIsCorrect1
    codeArityRIsCorrect2 _ H7).
assert
 (checkPrf (cPairPi1 (cPairPi1 (cPairPi2 (cPairPi2 n))))
    (cPairPi2 (cPairPi1 (cPairPi2 (cPairPi2 n)))) <> 0).
unfold checkPrf in |- *.
rewrite a.
rewrite <- H3.
rewrite <- H8.
rewrite codeImpCorrect.
rewrite
 (wellFormedFormulaCorrect1 L codeF codeArityF codeArityFIsCorrect1 codeR
    codeArityR codeArityRIsCorrect1).
simpl in |- *.
unfold checkPrfHelp in |- *.
fold A in |- *.
rewrite H8.
rewrite H3.
replace
 (cPair 1 (cPair (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 n)))) (cPairPi1 n)))
 with (cPairPi1 (cPairPi1 (cPairPi2 (cPairPi2 n)))).
rewrite cPairProjections.
destruct (evalStrongRec 0 A (cPairPi1 (cPairPi2 (cPairPi2 n)))).
rewrite mult_comm in H0.
rewrite
 (mult_comm
    (charFunction 2 beq_nat (cPairPi1 (cPairPi1 (cPairPi2 (cPairPi2 n))))
       (codeImp (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 n)))) (cPairPi1 n))))
  in H0.
simpl in H0.
assumption.
discriminate.
assert
 (checkPrf (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 n))))
    (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 n)))) <> 0).
unfold checkPrf in |- *.
rewrite <- H8.
rewrite
 (wellFormedFormulaCorrect1 L codeF codeArityF codeArityFIsCorrect1 codeR
    codeArityR codeArityRIsCorrect1).
simpl in |- *.
unfold checkPrfHelp in |- *.
fold A in |- *.
rewrite H8.
rewrite cPairProjections.
destruct (evalStrongRec 0 A (cPairPi2 (cPairPi2 (cPairPi2 n)))).
rewrite mult_comm in H0.
rewrite
 (mult_comm
    (charFunction 2 beq_nat (cPairPi1 (cPairPi1 (cPairPi2 (cPairPi2 n))))
       (codeImp (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 n)))) (cPairPi1 n))))
  in H0.
rewrite (mult_comm (evalStrongRec 0 A (cPairPi1 (cPairPi2 (cPairPi2 n)))))
  in H0.
simpl in H0.
assumption.
discriminate.
assert (cPairPi1 (cPairPi2 (cPairPi2 n)) < m).
apply lt_le_trans with n.
assumption.
rewrite H1.
apply le_n.
assert (cPairPi2 (cPairPi2 (cPairPi2 n)) < m).
apply lt_le_trans with n.
assumption.
rewrite H1.
apply le_n.
induction (Hrecm _ H11 H9).
induction (Hrecm _ H12 H10).
induction H13 as (x3, H13).
induction H13 as (x4, H13).
induction H14 as (x5, H14).
induction H14 as (x6, H14).
exists (x3 ++ x5).
rewrite <- H13 in a.
rewrite <- H14 in a.
repeat rewrite cPairProjections1 in a.
rewrite <- H3 in a.
rewrite codeImpCorrect in a.
assert (x1 = impH x2 x).
apply (codeFormulaInj L codeF codeR codeFInj codeRInj).
assumption.
intros.
cut
 (cPair (codeFormula L codeF codeR x1) (codePrf L codeF codeR x3 x1 x4) =
  cPairPi1 (cPairPi2 (cPairPi2 n))).
generalize x4.
clear H13 x4.
rewrite H15.
intros.
exists (MP L x3 x5 x2 x x4 x6).
rewrite <- (cPairProjections n).
rewrite H3.
simpl in |- *.
rewrite <- H2.
replace
 (cPair 1
    (cPair (codeFormula L codeF codeR x2) (codeFormula L codeF codeR x)))
 with (codeFormula L codeF codeR x1).
rewrite H14.
fold impH in |- *.
rewrite H15.
rewrite H13.
rewrite cPairProjections.
reflexivity.
assumption.
unfold charFunction in H0.
rewrite beq_nat_not_refl in H0.
rewrite mult_comm in H0.
simpl in H0.
elim H0.
reflexivity.
assumption.
rewrite cPairProjections.
assumption.
rewrite cPairProjections.
assumption.
destruct n1.
simpl in H0.
unfold checkPrfGEN in H0.
repeat first
 [ rewrite cPairProjections1 in H0 | rewrite cPairProjections2 in H0 ].
assert (cPairPi2 (cPairPi2 (cPairPi2 n)) < n).
eapply le_lt_trans.
apply cPairLe2A.
apply lt_le_trans with (cPair 2 (cPairPi2 (cPairPi2 n)));
 [ idtac | rewrite H2; apply cPairLe2A ].
apply cPairLt2.
rewrite evalStrongRecHelp1 in H0.
induction
 (eq_nat_dec
    (cPair 3
       (cPair (cPairPi1 (cPairPi2 (cPairPi2 n)))
          (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 n)))))) 
    (cPairPi1 n)).
rewrite <- a in H3.
destruct x as [t t0| r t| f f0| f| n1 f]; simpl in H3;
 try
  match goal with
  | H:(cPair ?X1 _ = cPair ?X2 _) |- _ =>
      cut (X1 = X2); [ intro I; discriminate I | eapply cPairInj1; apply H ]
  end.
assert (n1 = cPairPi1 (cPairPi2 (cPairPi2 n))).
eapply cPairInj1.
eapply cPairInj2.
apply H3.
assert
 (codeFormula L codeF codeR f = cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 n)))).
eapply cPairInj2.
eapply cPairInj2.
apply H3.
assert
 (checkPrf (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 n))))
    (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 n)))) <> 0).
unfold checkPrf in |- *.
rewrite <- H6.
rewrite
 (wellFormedFormulaCorrect1 L codeF codeArityF codeArityFIsCorrect1 codeR
    codeArityR codeArityRIsCorrect1).
simpl in |- *.
unfold checkPrfHelp in |- *.
fold A in |- *.
rewrite H6.
rewrite cPairProjections.
destruct (evalStrongRec 0 A (cPairPi2 (cPairPi2 (cPairPi2 n)))).
rewrite mult_comm in H0.
simpl in H0.
assumption.
discriminate.
assert (cPairPi2 (cPairPi2 (cPairPi2 n)) < m).
apply lt_le_trans with n.
assumption.
rewrite H1.
apply le_n.
induction (Hrecm _ H8 H7).
induction H9 as (x0, H9).
induction H9 as (x1, H9).
exists x0.
rewrite <- H5 in H0.
rewrite <- H9 in H0.
assert
 (checkPrf (codeFormula L codeF codeR x) (codePrf L codeF codeR x0 x x1) =
  S (codeList (map (codeFormula L codeF codeR) x0))).
apply checkPrfCorrect1.
unfold checkPrf in H10.
rewrite
 (wellFormedFormulaCorrect1 L codeF codeArityF codeArityFIsCorrect1 codeR
    codeArityR codeArityRIsCorrect1) in H10.
simpl in H10.
unfold checkPrfHelp in H10.
fold A in H10.
rewrite H10 in H0.
unfold pred in H0.
rewrite codeFreeVarListFormulaCorrect in H0.
rewrite codeInCorrect in H0.
induction (In_dec eq_nat_dec n1 (freeVarListFormula L x0)).
rewrite (mult_comm (S (codeList (map (codeFormula L codeF codeR) x0)))) in H0.
rewrite mult_comm in H0.
simpl in H0.
elim H0; reflexivity.
rewrite <- H9 in H6.
rewrite cPairProjections1 in H6.
cut
 (cPair (codeFormula L codeF codeR x) (codePrf L codeF codeR x0 x x1) =
  cPairPi2 (cPairPi2 (cPairPi2 n))).
generalize x1.
clear H10 H0 x1 H9.
replace x with f.
intros.
exists (GEN L x0 f n1 b x1).
simpl in |- *.
rewrite H3.
rewrite a.
rewrite H0.
rewrite H5.
rewrite cPairProjections.
rewrite H2.
apply cPairProjections.
apply (codeFormulaInj L codeF codeR codeFInj codeRInj).
assumption.
assumption.
unfold charFunction in H0.
rewrite beq_nat_not_refl in H0.
elim H0.
simpl in |- *.
reflexivity.
assumption.
rewrite cPairProjections.
assumption.
destruct n1.
simpl in H0.
unfold checkPrfIMP1 in H0.
repeat first
 [ rewrite cPairProjections1 in H0 | rewrite cPairProjections2 in H0 ].
exists (nil (A:=Formula)).
rewrite <- H3 in H0.
induction
 (eq_nat_dec
    (cPair 1
       (cPair (cPairPi1 (cPairPi2 (cPairPi2 n)))
          (cPair 1
             (cPair (cPairPi2 (cPairPi2 (cPairPi2 n)))
                (cPairPi1 (cPairPi2 (cPairPi2 n)))))))
    (codeFormula L codeF codeR x)).
destruct x as [t t0| r t| f f0| f| n1 f]; simpl in a;
 try
  match goal with
  | H:(cPair ?X1 _ = cPair ?X2 _) |- _ =>
      cut (X1 = X2); [ intro I; discriminate I | eapply cPairInj1; apply H ]
  end.
assert (cPairPi1 (cPairPi2 (cPairPi2 n)) = codeFormula L codeF codeR f).
eapply cPairInj1.
eapply cPairInj2.
apply a.
assert
 (cPair 1
    (cPair (cPairPi2 (cPairPi2 (cPairPi2 n)))
       (cPairPi1 (cPairPi2 (cPairPi2 n)))) = codeFormula L codeF codeR f0).
eapply cPairInj2.
eapply cPairInj2.
apply a.
clear a.
destruct f0 as [t t0| r t| f0 f1| f0| n1 f0]; simpl in H5;
 try
  match goal with
  | H:(cPair ?X1 _ = cPair ?X2 _) |- _ =>
      cut (X1 = X2); [ intro I; discriminate I | eapply cPairInj1; apply H ]
  end.
assert (cPairPi2 (cPairPi2 (cPairPi2 n)) = codeFormula L codeF codeR f0).
eapply cPairInj1.
eapply cPairInj2.
apply H5.
assert (cPairPi1 (cPairPi2 (cPairPi2 n)) = codeFormula L codeF codeR f1).
eapply cPairInj2.
eapply cPairInj2.
apply H5.
assert (f1 = f).
apply (codeFormulaInj L codeF codeR codeFInj codeRInj).
transitivity (cPairPi1 (cPairPi2 (cPairPi2 n))).
symmetry  in |- *.
assumption.
assumption.
rewrite H8.
rewrite H8 in H3.
exists (IMP1 L f f0).
rewrite H3.
simpl in |- *.
rewrite <- H4.
rewrite <- H6.
rewrite cPairProjections.
rewrite H2.
apply cPairProjections.
elim H0.
unfold charFunction in |- *.
rewrite beq_nat_not_refl.
reflexivity.
assumption.
destruct n1.
simpl in H0.
unfold checkPrfIMP2 in H0.
repeat first
 [ rewrite cPairProjections1 in H0 | rewrite cPairProjections2 in H0 ].
exists (nil (A:=Formula)).
clear A.
rewrite <- H3 in H0.
rename x into f.
induction
 (eq_nat_dec
    (cPair 1
       (cPair
          (cPair 1
             (cPair (cPairPi1 (cPairPi2 (cPairPi2 n)))
                (cPair 1
                   (cPair (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 n))))
                      (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 n))))))))
          (cPair 1
             (cPair
                (cPair 1
                   (cPair (cPairPi1 (cPairPi2 (cPairPi2 n)))
                      (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 n))))))
                (cPair 1
                   (cPair (cPairPi1 (cPairPi2 (cPairPi2 n)))
                      (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 n))))))))))
    (codeFormula L codeF codeR f)).
repeat
 match goal with
 | H:(cPair ?X1 (cPair ?X2 ?X3) = cPair ?X1 (cPair ?X4 ?X5)) |- _ =>
     assert (X2 = X4);
      [ eapply cPairInj1; eapply cPairInj2; apply H
      | assert (X3 = X5);
         [ eapply cPairInj2; eapply cPairInj2; apply H | clear H ] ]
 | H:(cPair ?X1 (cPair _ _) = codeFormula L codeF codeR ?X2) |- _ =>
      destruct X2;
      simpl in H;
      try
       match goal with
       | J:(cPair ?X1 _ = cPair ?X2 _) |- _ =>
           cut (X1 = X2);
            [ intro I; discriminate I | eapply cPairInj1; apply J ]
       end
 end.
rewrite H3.
replace f2_2_1 with f1_1.
replace f1_2_2 with f2_2_2.
replace f1_2_1 with f2_1_2.
replace f2_1_1 with f1_1.
exists (IMP2 L f1_1 f2_1_2 f2_2_2).
simpl in |- *.
rewrite <- H9.
rewrite <- H8.
rewrite cPairProjections.
rewrite <- H6.
rewrite cPairProjections.
rewrite H2.
apply cPairProjections.
apply (codeFormulaInj L codeF codeR codeFInj codeRInj).
transitivity (cPairPi1 (cPairPi2 (cPairPi2 n)));
 [ symmetry  in |- *; assumption | assumption ].
apply (codeFormulaInj L codeF codeR codeFInj codeRInj).
transitivity (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 n))));
 [ symmetry  in |- *; assumption | assumption ].
apply (codeFormulaInj L codeF codeR codeFInj codeRInj).
transitivity (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 n))));
 [ symmetry  in |- *; assumption | assumption ].
apply (codeFormulaInj L codeF codeR codeFInj codeRInj).
transitivity (cPairPi1 (cPairPi2 (cPairPi2 n)));
 [ symmetry  in |- *; assumption | assumption ].
elim H0.
unfold charFunction in |- *.
rewrite beq_nat_not_refl.
reflexivity.
assumption.
destruct n1.
simpl in H0.
unfold checkPrfCP in H0.
clear A.
repeat first
 [ rewrite cPairProjections1 in H0 | rewrite cPairProjections2 in H0 ].
exists (nil (A:=Formula)).
rewrite <- H3 in H0.
rename x into f.
induction
 (eq_nat_dec
    (cPair 1
       (cPair
          (cPair 1
             (cPair (cPair 2 (cPairPi1 (cPairPi2 (cPairPi2 n))))
                (cPair 2 (cPairPi2 (cPairPi2 (cPairPi2 n))))))
          (cPair 1
             (cPair (cPairPi2 (cPairPi2 (cPairPi2 n)))
                (cPairPi1 (cPairPi2 (cPairPi2 n)))))))
    (codeFormula L codeF codeR f)).
repeat
 match goal with
 | H:(cPair 1 (cPair ?X2 ?X3) = cPair 1 (cPair ?X4 ?X5)) |- _ =>
     assert (X2 = X4);
      [ eapply cPairInj1; eapply cPairInj2; apply H
      | assert (X3 = X5);
         [ eapply cPairInj2; eapply cPairInj2; apply H | clear H ] ]
 | H:(cPair 2 ?X2 = cPair 2 ?X4) |- _ =>
     assert (X2 = X4); [ eapply cPairInj2; apply H | clear H ]
 | H:(cPair ?X1 _ = codeFormula L codeF codeR ?X2) |- _ =>
      destruct X2;
      simpl in H;
      try
       match goal with
       | J:(cPair ?X1 _ = cPair ?X2 _) |- _ =>
           cut (X1 = X2);
            [ intro I; discriminate I | eapply cPairInj1; apply J ]
       end
 end.
rewrite H3.
replace f2_2 with f1_1.
replace f1_2 with f2_1.
exists (CP L f1_1 f2_1).
simpl in |- *.
rewrite <- H8.
rewrite <- H6.
rewrite cPairProjections.
rewrite H2.
apply cPairProjections.
apply (codeFormulaInj L codeF codeR codeFInj codeRInj).
transitivity (cPairPi2 (cPairPi2 (cPairPi2 n)));
 [ symmetry  in |- *; assumption | assumption ].
apply (codeFormulaInj L codeF codeR codeFInj codeRInj).
transitivity (cPairPi1 (cPairPi2 (cPairPi2 n)));
 [ symmetry  in |- *; assumption | assumption ].
elim H0.
unfold charFunction in |- *.
rewrite beq_nat_not_refl.
reflexivity.
assumption.
destruct n1.
simpl in H0.
unfold checkPrfFA1 in H0.
clear A.
repeat first
 [ rewrite cPairProjections1 in H0 | rewrite cPairProjections2 in H0 ].
exists (nil (A:=Formula)).
rewrite <- H3 in H0.
rename x into f.
induction
 (eq_nat_dec
    (cPair 1
       (cPair
          (cPair 3
             (cPair (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 n))))
                (cPairPi1 (cPairPi2 (cPairPi2 n)))))
          (codeSubFormula (cPairPi1 (cPairPi2 (cPairPi2 n)))
             (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 n))))
             (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 n)))))))
    (codeFormula L codeF codeR f)).
repeat
 match goal with
 | H:(cPair 1 (cPair ?X2 ?X3) = cPair 1 (cPair ?X4 ?X5)) |- _ =>
     assert (X2 = X4);
      [ eapply cPairInj1; eapply cPairInj2; apply H
      | assert (X3 = X5);
         [ eapply cPairInj2; eapply cPairInj2; apply H | clear H ] ]
 | H:(cPair 3 (cPair ?X2 ?X3) = cPair 3 (cPair ?X4 ?X5)) |- _ =>
     assert (X2 = X4);
      [ eapply cPairInj1; eapply cPairInj2; apply H
      | assert (X3 = X5);
         [ eapply cPairInj2; eapply cPairInj2; apply H | clear H ] ]
 | H:(cPair ?X1 _ = codeFormula L codeF codeR ?X2) |- _ =>
      destruct X2;
      simpl in H;
      try
       match goal with
       | J:(cPair ?X1 _ = cPair ?X2 _) |- _ =>
           cut (X1 = X2);
            [ intro I; discriminate I | eapply cPairInj1; apply J ]
       end
 end.
rewrite H3.
rewrite H6 in H5.
rewrite H7 in H5.
assert (wellFormedTerm (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 n)))) <> 0).
eapply multLemma1.

End Check_Proof. *)

Require Import code.
(* code:
Require Import Arith.
Require Import fol.
Require Import folProof.
Require Import cPair.

Section Code_Term_Formula_Proof.

Variable L : Language.
Variable codeF : Functions L -> nat.
Variable codeR : Relations L -> nat.
Hypothesis codeFInj : forall f g : Functions L, codeF f = codeF g -> f = g.
Hypothesis codeRInj : forall R S : Relations L, codeR R = codeR S -> R = S.

Let Formula := Formula L.
Let Formulas := Formulas L.
Let System := System L.
Let Term := Term L.
Let Terms := Terms L.
Let var := var L.
Let apply := apply L.
Let equal := equal L.
Let atomic := atomic L.
Let impH := impH L.
Let notH := notH L.
Let forallH := forallH L.
Let orH := orH L.
Let andH := andH L.
Let existH := existH L.
Let iffH := iffH L.
Let ifThenElseH := ifThenElseH L.
Let Prf := Prf L.
Let SysPrf := SysPrf L.

Fixpoint codeTerm (t : Term) : nat :=
  match t with
  | fol.var n => cPair 0 n
  | fol.apply f ts => cPair (S (codeF f)) (codeTerms _ ts)
  end
 
 with codeTerms (n : nat) (ts : Terms n) {struct ts} : nat :=
  match ts with
  | Tnil => 0
  | Tcons n t ss => S (cPair (codeTerm t) (codeTerms n ss))
  end.

Lemma codeTermInj : forall t s : Term, codeTerm t = codeTerm s -> t = s.

Lemma codeTermsInj :
 forall (n : nat) (ts ss : Terms n),
 codeTerms n ts = codeTerms n ss -> ts = ss.

Fixpoint codeFormula (f : Formula) : nat :=
  match f with
  | fol.equal t1 t2 => cPair 0 (cPair (codeTerm t1) (codeTerm t2))
  | fol.impH f1 f2 => cPair 1 (cPair (codeFormula f1) (codeFormula f2))
  | fol.notH f1 => cPair 2 (codeFormula f1)
  | fol.forallH n f1 => cPair 3 (cPair n (codeFormula f1))
  | fol.atomic R ts => cPair (4+(codeR R)) (codeTerms _ ts)
  end.

Lemma codeFormulaInj :
 forall f g : Formula, codeFormula f = codeFormula g -> f = g.

Fixpoint codePrf (Z : Formulas) (f : Formula) (prf : Prf Z f) {struct prf} :
 nat :=
  match prf with
  | AXM A => cPair 0 (codeFormula A)
  | MP Axm1 Axm2 A B rec1 rec2 =>
      cPair 1
        (cPair
           (cPair (cPair 1 (cPair (codeFormula A) (codeFormula B)))
              (codePrf _ _ rec1)) (cPair (codeFormula A) (codePrf _ _ rec2)))
  | GEN Axm A v _ rec =>
      cPair 2 (cPair v (cPair (codeFormula A) (codePrf _ _ rec)))
  | IMP1 A B => cPair 3 (cPair (codeFormula A) (codeFormula B))
  | IMP2 A B C =>
      cPair 4 (cPair (codeFormula A) (cPair (codeFormula B) (codeFormula C)))
  | CP A B => cPair 5 (cPair (codeFormula A) (codeFormula B))
  | FA1 A v t => cPair 6 (cPair (codeFormula A) (cPair v (codeTerm t)))
  | FA2 A v _ => cPair 7 (cPair (codeFormula A) v)
  | FA3 A B v => cPair 8 (cPair (codeFormula A) (cPair (codeFormula B) v))
  | EQ1 => cPair 9 0
  | EQ2 => cPair 10 0
  | EQ3 => cPair 11 0
  | EQ4 r => cPair 12 (codeR r)
  | EQ5 f => cPair 13 (codeF f)
  end.

Lemma codePrfInjAxm :
 forall (a b : Formula) (A B : Formulas) (p : Prf A a) (q : Prf B b),
 codePrf A a p = codePrf B b q -> A = B.

Definition codeImp (a b : nat) := cPair 1 (cPair a b).

Lemma codeImpCorrect :
 forall a b : Formula,
 codeImp (codeFormula a) (codeFormula b) = codeFormula (impH a b).

Definition codeNot (a : nat) := cPair 2 a.

Lemma codeNotCorrect :
 forall a : Formula, codeNot (codeFormula a) = codeFormula (notH a).

Definition codeForall (n a : nat) := cPair 3 (cPair n a).

Lemma codeForallCorrect :
 forall (n : nat) (a : Formula),
 codeForall n (codeFormula a) = codeFormula (forallH n a).

Definition codeOr (a b : nat) := codeImp (codeNot a) b.

Lemma codeOrCorrect :
 forall a b : Formula,
 codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).

Definition codeAnd (a b : nat) := codeNot (codeOr (codeNot a) (codeNot b)).

Lemma codeAndCorrect :
 forall a b : Formula,
 codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).

Definition codeIff (a b : nat) := codeAnd (codeImp a b) (codeImp b a).

Lemma codeIffCorrect :
 forall a b : Formula,
 codeIff (codeFormula a) (codeFormula b) = codeFormula (iffH a b).

End Code_Term_Formula_Proof. *)

Require Import Languages.
(* Languages:
Require Import Arith.
Require Import fol.
Require Import primRec.
Require Import Coq.Lists.List.

Inductive LNTFunction : Set :=
  | Plus : LNTFunction
  | Times : LNTFunction
  | Succ : LNTFunction
  | Zero : LNTFunction.

Inductive LNNRelation : Set :=
    LT : LNNRelation.

Definition LNTFunctionArity (x : LNTFunction) : nat :=
  match x with
  | Plus => 2
  | Times => 2
  | Succ => 1
  | Zero => 0
  end.

Definition LNTArity (x : Empty_set + LNTFunction) : nat :=
  match x return nat with
  | inl bot => Empty_set_rec (fun _ => nat) bot
  | inr y => LNTFunctionArity y
  end.

Definition LNNArity (x : LNNRelation + LNTFunction) : nat :=
  match x return nat with
  | inl y => match y with
             | LT => 2
             end
  | inr y => LNTFunctionArity y
  end.

Definition LNT : Language := language Empty_set LNTFunction LNTArity.

Definition LNN : Language := language LNNRelation LNTFunction LNNArity.

Definition codeLNTFunction (f : LNTFunction) : nat :=
  match f with
  | Plus => 0
  | Times => 1
  | Succ => 2
  | Zero => 3
  end.

Definition codeLNTRelation (R : Empty_set) : nat :=
  match R return nat with
  end.

Definition codeLNNRelation (R : LNNRelation) : nat := 0.

Lemma codeLNTFunctionInj :
 forall f g : LNTFunction, codeLNTFunction f = codeLNTFunction g -> f = g.

Lemma codeLNTRelationInj :
 forall R S : Empty_set, codeLNTRelation R = codeLNTRelation S -> R = S.

Lemma codeLNNRelationInj :
 forall R S : LNNRelation, codeLNNRelation R = codeLNNRelation S -> R = S.

Definition codeArityLNNR (r : nat) := switchPR r 0 3.

Lemma codeArityLNNRIsPR : isPR 1 codeArityLNNR.

Lemma codeArityLNNRIsCorrect1 :
 forall r : Relations LNN,
 codeArityLNNR (codeLNNRelation r) = S (arity LNN (inl _ r)).

Lemma codeArityLNNRIsCorrect2 :
 forall n : nat,
 codeArityLNNR n <> 0 -> exists r : Relations LNN, codeLNNRelation r = n.

Definition codeArityLNTR (r : nat) := 0.

Lemma codeArityLNTRIsPR : isPR 1 codeArityLNTR.

Lemma codeArityLNTRIsCorrect1 :
 forall r : Relations LNT,
 codeArityLNTR (codeLNTRelation r) = S (arity LNT (inl _ r)).

Lemma codeArityLNTRIsCorrect2 :
 forall n : nat,
 codeArityLNTR n <> 0 -> exists r : Relations LNT, codeLNTRelation r = n.

Definition codeArityLNTF (f : nat) :=
  switchPR f
    (switchPR (pred f)
       (switchPR (pred (pred f)) (switchPR (pred (pred (pred f))) 0 1) 2) 3)
    3.

Lemma codeArityLNTFIsPR : isPR 1 codeArityLNTF.

Lemma codeArityLNTFIsCorrect1 :
 forall f : Functions LNT,
 codeArityLNTF (codeLNTFunction f) = S (arity LNT (inr _ f)).

Lemma codeArityLNNFIsCorrect1 :
 forall f : Functions LNN,
 codeArityLNTF (codeLNTFunction f) = S (arity LNN (inr _ f)).

Lemma codeArityLNTFIsCorrect2 :
 forall n : nat,
 codeArityLNTF n <> 0 -> exists f : Functions LNT, codeLNTFunction f = n.

Lemma codeArityLNNFIsCorrect2 :
 forall n : nat,
 codeArityLNTF n <> 0 -> exists f : Functions LNN, codeLNTFunction f = n. *)

Require Import folProp.
(* folProp:
Require Import Wf_nat.
Require Import Max.
Require Import Arith.
Require Import Coq.Lists.List.
Require Import ListExt.
Require Import Peano_dec.

Require Export fol.

Section Fol_Properties.

Variable L : Language.

Notation Formula := (Formula L) (only parsing).
Notation Formulas := (Formulas L) (only parsing).
Notation System := (System L) (only parsing).
Notation Term := (Term L) (only parsing).
Notation Terms := (Terms L) (only parsing).
Let var := var L.
Let apply := apply L.
Let equal := equal L.
Let atomic := atomic L.
Let impH := impH L.
Let notH := notH L.
Let forallH := forallH L.
Let lt_depth := lt_depth L.

Section Free_Variables.

Fixpoint freeVarTerm (s : fol.Term L) : list nat :=
  match s with
  | fol.var v => v :: nil
  | fol.apply f ts => freeVarTerms (arity L (inr _ f)) ts
  end
 
 with freeVarTerms (n : nat) (ss : fol.Terms L n) {struct ss} : 
 list nat :=
  match ss with
  | Tnil => nil (A:=nat)
  | Tcons m t ts => freeVarTerm t ++ freeVarTerms m ts
  end.

Lemma freeVarTermApply :
 forall (f : Functions L) (ts : fol.Terms L _),

Fixpoint freeVarFormula (A : fol.Formula L) : list nat :=
  match A with
  | fol.equal t s => freeVarTerm t ++ freeVarTerm s
  | fol.atomic r ts => freeVarTerms _ ts
  | fol.impH A B => freeVarFormula A ++ freeVarFormula B
  | fol.notH A => freeVarFormula A
  | fol.forallH v A => list_remove _ eq_nat_dec v (freeVarFormula A)
  end.

Definition ClosedSystem (T : fol.System L) :=
  forall (v : nat) (f : fol.Formula L),
  mem _ T f -> ~ In v (freeVarFormula f).

Definition closeList (l : list nat) (x : fol.Formula L) : 
  fol.Formula L :=
  list_rec (fun _ => fol.Formula L) x
    (fun (a : nat) _ (rec : fol.Formula L) => forallH a rec) l.

Definition close (x : fol.Formula L) : fol.Formula L :=
  closeList (no_dup _ eq_nat_dec (freeVarFormula x)) x.

Lemma freeVarClosedList1 :
 forall (l : list nat) (v : nat) (x : fol.Formula L),

Lemma freeVarClosedList2 :
 forall (l : list nat) (v : nat) (x : fol.Formula L),

Lemma freeVarClosed :
 forall (x : fol.Formula L) (v : nat), ~ In v (freeVarFormula (close x)).

Fixpoint freeVarListFormula (l : fol.Formulas L) : 
 list nat :=
  match l with
  | nil => nil (A:=nat)
  | f :: l => freeVarFormula f ++ freeVarListFormula l
  end.

Lemma freeVarListFormulaApp :
 forall a b : fol.Formulas L,

Lemma In_freeVarListFormula :
 forall (v : nat) (f : fol.Formula L) (F : fol.Formulas L),

Lemma In_freeVarListFormulaE :
 forall (v : nat) (F : fol.Formulas L),

Definition In_freeVarSys (v : nat) (T : fol.System L) :=
  exists f : fol.Formula L, In v (freeVarFormula f) /\ mem _ T f.

Lemma notInFreeVarSys :
 forall x, ~ In_freeVarSys x (Ensembles.Empty_set (fol.Formula L)).

End Free_Variables.

Section Substitution.

Fixpoint substituteTerm (s : fol.Term L) (x : nat) 
 (t : fol.Term L) {struct s} : fol.Term L :=
  match s with
  | fol.var v =>
      match eq_nat_dec x v with
      | left _ => t
      | right _ => var v
      end
  | fol.apply f ts => apply f (substituteTerms _ ts x t)
  end
 
 with substituteTerms (n : nat) (ss : fol.Terms L n) 
 (x : nat) (t : fol.Term L) {struct ss} : fol.Terms L n :=
  match ss in (fol.Terms _ n0) return (fol.Terms L n0) with
  | Tnil => Tnil L
  | Tcons m s ts =>
      Tcons L m (substituteTerm s x t) (substituteTerms m ts x t)
  end.

Lemma subTermVar1 :
 forall (v : nat) (s : fol.Term L), substituteTerm (var v) v s = s.

Lemma subTermVar2 :
 forall (v x : nat) (s : fol.Term L),

Lemma subTermFunction :
 forall (f : Functions L) (ts : fol.Terms L (arity L (inr _ f))) 

Definition newVar (l : list nat) : nat := fold_right max 0 (map S l).

Lemma newVar2 : forall (l : list nat) (n : nat), In n l -> n < newVar l.

Lemma newVar1 : forall l : list nat, ~ In (newVar l) l.

Definition substituteFormulaImp (f : fol.Formula L)
  (frec : nat * fol.Term L -> {y : fol.Formula L | depth L y = depth L f})
  (g : fol.Formula L)
  (grec : nat * fol.Term L -> {y : fol.Formula L | depth L y = depth L g})
  (p : nat * fol.Term L) :
  {y : fol.Formula L | depth L y = depth L (impH f g)} :=
  match frec p with
  | exist f' prf1 =>
      match grec p with
      | exist g' prf2 =>
          exist
            (fun y : fol.Formula L =>
             depth L y = S (max (depth L f) (depth L g))) 
            (impH f' g')
            (eq_ind_r
               (fun n : nat =>
                S (max n (depth L g')) = S (max (depth L f) (depth L g)))
               (eq_ind_r
                  (fun n : nat =>
                   S (max (depth L f) n) = S (max (depth L f) (depth L g)))
                  (refl_equal (S (max (depth L f) (depth L g)))) prf2) prf1)
      end
  end.

Remark substituteFormulaImpNice :
 forall (f g : fol.Formula L)

Definition substituteFormulaNot (f : fol.Formula L)
  (frec : nat * fol.Term L -> {y : fol.Formula L | depth L y = depth L f})
  (p : nat * fol.Term L) :
  {y : fol.Formula L | depth L y = depth L (notH f)} :=
  match frec p with
  | exist f' prf1 =>
      exist (fun y : fol.Formula L => depth L y = S (depth L f)) 
        (notH f')
        (eq_ind_r (fun n : nat => S n = S (depth L f))
           (refl_equal (S (depth L f))) prf1)
  end.

Remark substituteFormulaNotNice :
 forall (f : fol.Formula L)

Definition substituteFormulaForall (n : nat) (f : fol.Formula L)
  (frec : forall b : fol.Formula L,
          lt_depth b (forallH n f) ->
          nat * fol.Term L -> {y : fol.Formula L | depth L y = depth L b})
  (p : nat * fol.Term L) :
  {y : fol.Formula L | depth L y = depth L (forallH n f)} :=
  match p with
  | (v, s) =>
      match eq_nat_dec n v with
      | left _ =>
          exist (fun y : fol.Formula L => depth L y = S (depth L f))
            (forallH n f) (refl_equal (depth L (forallH n f)))
      | right _ =>
          match In_dec eq_nat_dec n (freeVarTerm s) with
          | left _ =>
              let nv := newVar (v :: freeVarTerm s ++ freeVarFormula f) in
              match frec f (depthForall L f n) (n, var nv) with
              | exist f' prf1 =>
                  match
                    frec f'
                      (eqDepth L f' f (forallH n f) 
                         (sym_eq prf1) (depthForall L f n)) p
                  with
                  | exist f'' prf2 =>
                      exist
                        (fun y : fol.Formula L => depth L y = S (depth L f))
                        (forallH nv f'')
                        (eq_ind_r (fun n : nat => S n = S (depth L f))
                           (refl_equal (S (depth L f))) 
                           (trans_eq prf2 prf1))
                  end
              end
          | right _ =>
              match frec f (depthForall L f n) p with
              | exist f' prf1 =>
                  exist (fun y : fol.Formula L => depth L y = S (depth L f))
                    (forallH n f')
                    (eq_ind_r (fun n : nat => S n = S (depth L f))
                       (refl_equal (S (depth L f))) prf1)
              end
          end
      end
  end.

Remark substituteFormulaForallNice :
 forall (v : nat) (a : fol.Formula L)

Definition substituteFormulaHelp (f : fol.Formula L) 

Definition substituteFormula (f : fol.Formula L) (v : nat) 
  (s : fol.Term L) : fol.Formula L := proj1_sig (substituteFormulaHelp f v s).

Lemma subFormulaEqual :
 forall (t1 t2 : fol.Term L) (v : nat) (s : fol.Term L),

Lemma subFormulaRelation :
 forall (r : Relations L) (ts : fol.Terms L (arity L (inl _ r))) 

Lemma subFormulaImp :
 forall (f1 f2 : fol.Formula L) (v : nat) (s : fol.Term L),

Lemma subFormulaNot :
 forall (f : fol.Formula L) (v : nat) (s : fol.Term L),

Lemma subFormulaForall :
 forall (f : fol.Formula L) (x v : nat) (s : fol.Term L),

Section Extensions.

Let orH := orH L.
Let andH := andH L.
Let existH := existH L.
Let iffH := iffH L.
Let ifThenElseH := ifThenElseH L.

Lemma subFormulaOr :
 forall (f1 f2 : fol.Formula L) (v : nat) (s : fol.Term L),

Lemma subFormulaAnd :
 forall (f1 f2 : fol.Formula L) (v : nat) (s : fol.Term L),

Lemma subFormulaExist :
 forall (f : fol.Formula L) (x v : nat) (s : fol.Term L),

Lemma subFormulaIff :
 forall (f1 f2 : fol.Formula L) (v : nat) (s : fol.Term L),

Lemma subFormulaIfThenElse :
 forall (f1 f2 f3 : fol.Formula L) (v : nat) (s : fol.Term L),

End Extensions.

Lemma subFormulaDepth :
 forall (f : fol.Formula L) (v : nat) (s : fol.Term L),

Section Substitution_Properties.

Lemma subTermId :
 forall (t : fol.Term L) (v : nat), substituteTerm t v (var v) = t.

Lemma subTermsId :
 forall (n : nat) (ts : fol.Terms L n) (v : nat),

Lemma subFormulaId :
 forall (f : fol.Formula L) (v : nat), substituteFormula f v (var v) = f.

Lemma subFormulaForall2 :
 forall (f : fol.Formula L) (x v : nat) (s : fol.Term L),

Let existH := existH L.

Lemma subFormulaExist2 :
 forall (f : fol.Formula L) (x v : nat) (s : fol.Term L),

End Substitution_Properties.

End Substitution.
 
Definition Sentence (f:Formula) := (forall v : nat, ~ In v (freeVarFormula f)).

End Fol_Properties. *)

Require Import folProof.
(* folProof:
Require Import Ensembles.
Require Import Coq.Lists.List.
Require Import Arith.

Require Export fol.
Require Import folProp.

Section ProofH.

Variable L : Language.

Let Formula := Formula L.
Let Formulas := Formulas L.
Let System := System L.
Let Term := Term L.
Let Terms := Terms L.
Let var := var L.
Let apply := apply L.
Let equal := equal L.
Let atomic := atomic L.
Let impH := impH L.
Let notH := notH L.
Let iffH := iffH L.
Let forallH := forallH L.

Definition nVars (n : nat) : Terms n * Terms n.

Definition AxmEq4 (R : Relations L) : Formula.

Definition AxmEq5 (f : Functions L) : Formula.

Inductive Prf : Formulas -> Formula -> Set :=
  | AXM : forall A : Formula, Prf (A :: nil) A
  | MP :
      forall (Axm1 Axm2 : Formulas) (A B : Formula),
      Prf Axm1 (impH A B) -> Prf Axm2 A -> Prf (Axm1 ++ Axm2) B
  | GEN :
      forall (Axm : Formulas) (A : Formula) (v : nat),
      ~ In v (freeVarListFormula L Axm) -> Prf Axm A -> Prf Axm (forallH v A)
  | IMP1 : forall A B : Formula, Prf nil (impH A (impH B A))
  | IMP2 :
      forall A B C : Formula,
      Prf nil (impH (impH A (impH B C)) (impH (impH A B) (impH A C)))
  | CP :
      forall A B : Formula,
      Prf nil (impH (impH (notH A) (notH B)) (impH B A))
  | FA1 :
      forall (A : Formula) (v : nat) (t : Term),
      Prf nil (impH (forallH v A) (substituteFormula L A v t))
  | FA2 :
      forall (A : Formula) (v : nat),
      ~ In v (freeVarFormula L A) -> Prf nil (impH A (forallH v A))
  | FA3 :
      forall (A B : Formula) (v : nat),
      Prf nil
        (impH (forallH v (impH A B)) (impH (forallH v A) (forallH v B)))
  | EQ1 : Prf nil (equal (var 0) (var 0))
  | EQ2 : Prf nil (impH (equal (var 0) (var 1)) (equal (var 1) (var 0)))
  | EQ3 :
      Prf nil
        (impH (equal (var 0) (var 1))
           (impH (equal (var 1) (var 2)) (equal (var 0) (var 2))))
  | EQ4 : forall R : Relations L, Prf nil (AxmEq4 R)
  | EQ5 : forall f : Functions L, Prf nil (AxmEq5 f).

Definition SysPrf (T : System) (f : Formula) :=
  exists Axm : Formulas,
    (exists prf : Prf Axm f,
       (forall g : Formula, In g Axm -> mem _ T g)).

Definition Inconsistent (T : System) := forall f : Formula, SysPrf T f.

Definition Consistent (T : System) := exists f : Formula, ~ SysPrf T f.

End ProofH. *)

Require Import folLogic3.
(* folLogic3:
Require Import Ensembles.
Require Import Coq.Lists.List.
Require Import ListExt.

Require Import folProp.
Require Import folProof.
Require Export folLogic2.
Require Import subProp.
Require Import folReplace.
Require Import Arith.
Require Import subAll.
Require Import misc.

Unset Standard Proposition Elimination Names.

Section Equality_Logic_Rules.

Variable L : Language.
Notation Formula := (Formula L) (only parsing).
Notation Formulas := (Formulas L) (only parsing).
Notation System := (System L) (only parsing).
Notation Term := (Term L) (only parsing).
Notation Terms := (Terms L) (only parsing).
Let var := var L.
Let apply := apply L.
Let equal := equal L.
Let atomic := atomic L.
Let impH := impH L.
Let notH := notH L.
Let forallH := forallH L.
Let orH := orH L.
Let andH := andH L.
Let existH := existH L.
Let iffH := iffH L.
Let ifThenElseH := ifThenElseH L.
Let Prf := Prf L.
Let SysPrf := SysPrf L.

Lemma eqRefl :
 forall (T : fol.System L) (a : fol.Term L), SysPrf T (equal a a).

Lemma eqSym :
 forall (T : fol.System L) (a b : fol.Term L),

Lemma eqTrans :
 forall (T : fol.System L) (a b c : fol.Term L),

Fixpoint PairwiseEqual (T : fol.System L) (n : nat) {struct n} :
 fol.Terms L n -> fol.Terms L n -> Prop :=
  match n return (fol.Terms L n -> fol.Terms L n -> Prop) with
  | O => fun ts ss : fol.Terms L 0 => True
  | S x =>
      fun ts ss : fol.Terms L (S x) =>
      let (a, b) := proj1_sig (consTerms L x ts) in
      let (c, d) := proj1_sig (consTerms L x ss) in
      SysPrf T (equal a c) /\ PairwiseEqual T x b d
  end.

Let termsMap (m : nat) (ts ss : fol.Terms L m) : nat -> fol.Term L.

Remark subAllnVars1 :
 forall (a : nat) (ts ss : fol.Terms L a),

Remark subAllnVars2 :
 forall (a : nat) (ts ss : fol.Terms L a),

Remark addPairwiseEquals :
 forall (T : fol.System L) (n : nat) (ts ss : fol.Terms L n),

Lemma equalRelation :
 forall (T : fol.System L) (r : Relations L) (ts ss : fol.Terms L _),

Lemma equalFunction :
 forall (T : fol.System L) (f : Functions L) (ts ss : fol.Terms L _),

Lemma subWithEqualsTerm :
 forall (a b t : fol.Term L) (v : nat) (T : fol.System L),

Lemma subWithEqualsTerms :
 forall (a b : fol.Term L) (n : nat) (ts : fol.Terms L n) 

Lemma subWithEquals :
 forall (f : fol.Formula L) (v : nat) (a b : fol.Term L) (T : fol.System L),

End Equality_Logic_Rules. *)

Require Import folReplace.
(* folReplace:
Require Import Ensembles.
Require Import Coq.Lists.List.
Require Import Peano_dec.

Require Import ListExt.
Require Import folProof.
Require Import folLogic.
Require Import folProp.

Section Replacement.

Variable L : Language.
Let Formula := Formula L.
Let Formulas := Formulas L.
Let System := System L.
Let Term := Term L.
Let Terms := Terms L.
Let var := var L.
Let apply := apply L.
Let equal := equal L.
Let atomic := atomic L.
Let impH := impH L.
Let notH := notH L.
Let forallH := forallH L.
Let orH := orH L.
Let andH := andH L.
Let existH := existH L.
Let iffH := iffH L.
Let ifThenElseH := ifThenElseH L.
Let SysPrf := SysPrf L.

Lemma reduceImp :
 forall (f1 f2 f3 f4 : Formula) (T : System),
 SysPrf T (iffH f1 f3) ->
 SysPrf T (iffH f2 f4) -> SysPrf T (iffH (impH f1 f2) (impH f3 f4)).

Lemma reduceNot :
 forall (f1 f2 : Formula) (T : System),
 SysPrf T (iffH f1 f2) -> SysPrf T (iffH (notH f1) (notH f2)).

Lemma impForall :
 forall (f1 f2 : Formula) (v : nat) (T : System),
 ~ In_freeVarSys _ v T ->
 SysPrf T (impH f1 f2) -> SysPrf T (impH (forallH v f1) (forallH v f2)).

Lemma reduceForall :
 forall (f1 f2 : Formula) (v : nat) (T : System),
 ~ In_freeVarSys _ v T ->
 SysPrf T (iffH f1 f2) -> SysPrf T (iffH (forallH v f1) (forallH v f2)).

Lemma reduceOr :
 forall (f1 f2 f3 f4 : Formula) (T : System),
 SysPrf T (iffH f1 f3) ->
 SysPrf T (iffH f2 f4) -> SysPrf T (iffH (orH f1 f2) (orH f3 f4)).

Lemma reduceAnd :
 forall (f1 f2 f3 f4 : Formula) (T : System),
 SysPrf T (iffH f1 f3) ->
 SysPrf T (iffH f2 f4) -> SysPrf T (iffH (andH f1 f2) (andH f3 f4)).

Lemma iffExist :
 forall (f1 f2 : Formula) (v : nat) (T : System),
 ~ In_freeVarSys _ v T ->
 SysPrf T (impH f1 f2) -> SysPrf T (impH (existH v f1) (existH v f2)).

Lemma reduceExist :
 forall (f1 f2 : Formula) (v : nat) (T : System),
 ~ In_freeVarSys _ v T ->
 SysPrf T (iffH f1 f2) -> SysPrf T (iffH (existH v f1) (existH v f2)).

Lemma reduceIff :
 forall (f1 f2 f3 f4 : Formula) (T : System),
 SysPrf T (iffH f1 f3) ->
 SysPrf T (iffH f2 f4) -> SysPrf T (iffH (iffH f1 f2) (iffH f3 f4)).

Lemma reduceIfThenElse :
 forall (f1 f2 f3 f4 f5 f6 : Formula) (T : System),
 SysPrf T (iffH f1 f4) ->
 SysPrf T (iffH f2 f5) ->
 SysPrf T (iffH f3 f6) ->
 SysPrf T (iffH (ifThenElseH f1 f2 f3) (ifThenElseH f4 f5 f6)).

Lemma reduceSub :
 forall (T : System) (v : nat) (s : Term) (f g : Formula),
 ~ In_freeVarSys L v T ->
 SysPrf T (iffH f g) ->
 SysPrf T (iffH (substituteFormula L f v s) (substituteFormula L g v s)).

Lemma reduceCloseList :
 forall (l : list nat) (f1 f2 : Formula) (T : System),
 (forall v : nat, In v l -> ~ In_freeVarSys _ v T) ->
 SysPrf T (iffH f1 f2) ->
 SysPrf T (iffH (closeList L l f1) (closeList L l f2)).

End Replacement. *)

Require Import PRrepresentable.
(* PRrepresentable:
Require Import Arith.
Require Import extEqualNat.
Require Import subAll.
Require Import folProp.
Require Import subProp.
Require Import folReplace.
Require Import folLogic3.
Require Import NN.
Require Import NNtheory.
Require Import primRec.
Require Import chRem.
Require Import expressible.
Require Import Coq.Lists.List.
Require Vector.
Require Import ListExt.
Require Import cPair.
Require Import Decidable.

Section Primative_Recursive_Representable.

Let Representable := Representable NN.
Let RepresentableAlternate := RepresentableAlternate NN closedNN1.
Let RepresentableHelp := RepresentableHelp NN.
Let Representable_ext := Representable_ext NN.

Definition beta (a z : nat) : nat :=
  snd
    (proj1_sig
       (modulo (coPrimeBeta z (cPairPi1 a)) (gtBeta z (cPairPi1 a))
          (cPairPi2 a))).

Definition betaFormula : Formula :=
  existH 3
    (andH (LT (var 3) (Succ (var 2)))
       (existH 4
          (andH (LT (var 4) (Succ (var 2)))
             (andH
                (equal
                   (Plus
                      (Times (Plus (var 3) (var 4))
                         (Succ (Plus (var 3) (var 4))))
                      (Times (natToTerm 2) (var 3)))
                   (Times (natToTerm 2) (var 2)))
                (andH (LT (var 0) (Succ (Times (var 3) (Succ (var 1)))))
                   (existH 5
                      (andH (LT (var 5) (Succ (var 4)))
                         (equal
                            (Plus (var 0)
                               (Times (var 5)
                                  (Succ (Times (var 3) (Succ (var 1))))))
                            (var 4))))))))).

Lemma betaRepresentable : Representable 2 beta betaFormula.
Proof.
assert
 (cPairLemma1 :
  forall a b : nat, (a + b) * S (a + b) + 2 * a = 2 * cPair a b).
intros.
unfold cPair in |- *.
rewrite mult_plus_distr_l.
rewrite plus_comm.
replace (2 * sumToN (a + b)) with ((a + b) * S (a + b)).
reflexivity.
induction (a + b).
simpl in |- *.
reflexivity.
simpl in |- *.
simpl in IHn.
rewrite <- plus_Snm_nSm.
simpl in |- *.
rewrite (plus_comm (sumToN n) 0) in IHn.
simpl in IHn.
rewrite (plus_comm (n + sumToN n) 0).
simpl in |- *.
rewrite plus_assoc_reverse.
rewrite (plus_comm (sumToN n)).
rewrite plus_assoc_reverse.
rewrite <- IHn.
replace (n * S (S n)) with (n + n * S n).
reflexivity.
repeat rewrite (mult_comm n).
simpl in |- *.
reflexivity.
unfold Representable in |- *.
split.
intros.
simpl in H.
decompose sum H; rewrite <- H0 || rewrite <- H1; auto.
simpl in |- *.
intros.
unfold betaFormula in |- *.
assert
 (forall (A : Formula) (v x a : nat),
  v <> x ->
  substituteFormula LNN (existH v A) x (natToTerm a) =
  existH v (substituteFormula LNN A x (natToTerm a))).
intros.
rewrite (subFormulaExist LNN).
induction (eq_nat_dec v x).
elim H.
auto.
induction (In_dec eq_nat_dec v (freeVarTerm LNN (natToTerm a1))).
elim (closedNatToTerm _ _ a2).
reflexivity.
assert
 (forall (t1 t2 : Term) (v a : nat),
  substituteFormula LNN (LT t1 t2) v (natToTerm a) =
  LT (substituteTerm LNN t1 v (natToTerm a))
    (substituteTerm LNN t2 v (natToTerm a))).
intros.
unfold LT at 1 in |- *.
rewrite (subFormulaRelation LNN).
reflexivity.
repeat first
 [ rewrite H; [ idtac | discriminate ]
 | rewrite H0
 | rewrite (subFormulaAnd LNN)
 | rewrite (subFormulaEqual LNN) ].
simpl in |- *.
repeat rewrite (subTermNil LNN).
cut
 (SysPrf NN
    (iffH
       (existH 3
          (andH (LT (var 3) (natToTerm (S a)))
             (existH 4
                (andH (LT (var 4) (natToTerm (S a)))
                   (andH
                      (equal
                         (Plus
                            (Times (Plus (var 3) (var 4))
                               (Succ (Plus (var 3) (var 4))))
                            (Times (natToTerm 2) (var 3)))
                         (Times (natToTerm 2) (natToTerm a)))
                      (andH
                         (LT (var 0)
                            (Succ (Times (var 3) (Succ (natToTerm a0)))))
                         (existH 5
                            (andH (LT (var 5) (Succ (var 4)))
                               (equal
                                  (Plus (var 0)
                                     (Times (var 5)
                                        (Succ
                                           (Times (var 3)
                                              (Succ (natToTerm a0))))))
                                  (var 4))))))))))
       (equal (var 0) (natToTerm (beta a a0))))).
auto.
apply iffI.
apply impI.
apply existSys.
apply closedNN.
unfold not in |- *; intros.
induction H1 as [H1| H1].
discriminate H1.
simpl in H1.
elim (closedNatToTerm _ _ H1).
apply impE with (LT (var 3) (natToTerm (S a))).
apply
 impE
  with
    (existH 4
       (andH (LT (var 4) (natToTerm (S a)))
          (andH
             (equal
                (Plus
                   (Times (Plus (var 3) (var 4))
                      (Succ (Plus (var 3) (var 4))))
                   (Times (natToTerm 2) (var 3)))
                (Times (natToTerm 2) (natToTerm a)))
             (andH (LT (var 0) (Succ (Times (var 3) (Succ (natToTerm a0)))))
                (existH 5
                   (andH (LT (var 5) (Succ (var 4)))
                      (equal
                         (Plus (var 0)
                            (Times (var 5)
                               (Succ (Times (var 3) (Succ (natToTerm a0))))))
                         (var 4)))))))).
apply sysWeaken.
apply impI.
apply existSys.
apply closedNN.
replace
 (freeVarFormula LNN
    (impH (LT (var 3) (natToTerm (S a)))
       (equal (var 0) (natToTerm (beta a a0))))) with
 ((freeVarTerm LNN (var 3) ++ freeVarTerm LNN (natToTerm (S a))) ++
  freeVarFormula LNN (equal (var 0) (natToTerm (beta a a0)))).
unfold not in |- *; intros.
simpl in H1.
induction H1 as [H1| H1].
discriminate H1.
induction (in_app_or _ _ _ H1).
rewrite freeVarSucc in H2.
elim (closedNatToTerm _ _ H2).
induction H2 as [H2| H2].
discriminate H2.
elim (closedNatToTerm _ _ H2).
rewrite <- freeVarLT.
reflexivity.
apply
 impTrans
  with
    (andH (equal (var 3) (natToTerm (cPairPi1 a)))
       (equal (var 4) (natToTerm (cPairPi2 a)))).
apply impI.
apply
 impE
  with
    (equal
       (Plus (Times (Plus (var 3) (var 4)) (Succ (Plus (var 3) (var 4))))
          (Times (natToTerm 2) (var 3))) (Times (natToTerm 2) (natToTerm a))).
apply impE with (LT (var 4) (natToTerm (S a))).
apply impE with (LT (var 3) (natToTerm (S a))).
do 2 apply sysWeaken.
apply boundedLT.
intros.
rewrite (subFormulaImp LNN).
unfold LT at 1 in |- *.
rewrite (subFormulaRelation LNN).
simpl in |- *.
rewrite subTermNil.
fold (var 4) in |- *.
replace (apply LNN Languages.Succ (Tcons LNN 0 (natToTerm a) (Tnil LNN)))
 with (natToTerm (S a)); [ idtac | reflexivity ].
fold (LT (var 4) (natToTerm (S a))) in |- *.
apply boundedLT.
intros.
repeat rewrite (subFormulaImp LNN).
repeat rewrite (subFormulaAnd LNN).
repeat rewrite (subFormulaEqual LNN).
replace
 (substituteTerm LNN
    (substituteTerm LNN
       (Plus (Times (Plus (var 3) (var 4)) (Succ (Plus (var 3) (var 4))))
          (Times (Succ (Succ Zero)) (var 3))) 3 (natToTerm n)) 4
    (natToTerm n0)) with
 (Plus
    (Times (Plus (natToTerm n) (natToTerm n0))
       (Succ (Plus (natToTerm n) (natToTerm n0))))
    (Times (Succ (Succ Zero)) (natToTerm n))).
replace
 (substituteTerm LNN
    (substituteTerm LNN (Times (Succ (Succ Zero)) (natToTerm a)) 3
       (natToTerm n)) 4 (natToTerm n0)) with
 (Times (natToTerm 2) (natToTerm a)).
simpl in |- *.
assert
 (forall (a b : nat) (s : Term),
  substituteTerm LNN (natToTerm a) b s = natToTerm a).
intros.
apply (subTermNil LNN).
apply closedNatToTerm.
repeat rewrite H3.
apply
 impTrans
  with
    (equal (natToTerm ((n + n0) * S (n + n0) + 2 * n)) (natToTerm (2 * a))).
apply impI.
eapply eqTrans; [ apply sysWeaken; apply eqSym | idtac ].
apply natPlus.
eapply eqTrans.
apply eqPlus.
eapply eqTrans; [ apply sysWeaken; apply eqSym | idtac ].
apply natTimes.
eapply eqTrans.
apply eqTimes.
apply sysWeaken; apply eqSym.
apply natPlus.
eapply eqTrans; [ apply sysWeaken; apply eqSym | idtac ].
simpl in |- *.
apply eqSucc.
apply natPlus.
apply eqRefl.
apply eqRefl.
apply sysWeaken; apply eqSym.
apply natTimes.
eapply eqTrans.
apply Axm; right; constructor.
apply sysWeaken.
replace (Succ (Succ Zero)) with (natToTerm 2).
apply natTimes.
reflexivity.
rewrite cPairLemma1.
induction (eq_nat_dec a (cPair n n0)).
rewrite a1.
rewrite cPairProjections1.
rewrite cPairProjections2.
apply impI.
apply andI; apply eqRefl.
apply impI.
apply
 contradiction with (equal (natToTerm (2 * cPair n n0)) (natToTerm (2 * a))).
apply Axm; right; constructor.
apply sysWeaken.
apply natNE.
unfold not in |- *; intros.
induction (nat_total_order _ _ b).
elim (lt_not_le (2 * a) (2 * cPair n n0)).
apply mult_S_lt_compat_l.
auto.
rewrite H4.
apply le_n.
elim (lt_not_le (2 * cPair n n0) (2 * a)).
apply mult_S_lt_compat_l.
auto.
rewrite H4.
apply le_n.
simpl in |- *.
repeat
 (rewrite (subTermNil LNN (natToTerm a)); [ idtac | apply closedNatToTerm ]).
reflexivity.
simpl in |- *.
repeat
 (rewrite (subTermNil LNN (natToTerm n)); [ idtac | apply closedNatToTerm ]).
reflexivity.
apply closedNatToTerm.
apply Axm; right; constructor.
eapply andE1.
apply Axm; left; right; constructor.
eapply andE1.
eapply andE2.
apply Axm; left; right; constructor.
repeat apply impI.
apply
 impE
  with
    (existH 5
       (andH (LT (var 5) (Succ (var 4)))
          (equal
             (Plus (var 0)
                (Times (var 5) (Succ (Times (var 3) (Succ (natToTerm a0))))))
             (var 4)))).
apply impE with (LT (var 0) (Succ (Times (var 3) (Succ (natToTerm a0))))).
rewrite <-
 (subFormulaId LNN
    (impH (LT (var 0) (Succ (Times (var 3) (Succ (natToTerm a0)))))
       (impH
          (existH 5
             (andH (LT (var 5) (Succ (var 4)))
                (equal
                   (Plus (var 0)
                      (Times (var 5)
                         (Succ (Times (var 3) (Succ (natToTerm a0))))))
                   (var 4)))) (equal (var 0) (natToTerm (beta a a0))))) 3)
 .
apply
 impE
  with
    (substituteFormula LNN
       (impH (LT (var 0) (Succ (Times (var 3) (Succ (natToTerm a0)))))
          (impH
             (existH 5
                (andH (LT (var 5) (Succ (var 4)))
                   (equal
                      (Plus (var 0)
                         (Times (var 5)
                            (Succ (Times (var 3) (Succ (natToTerm a0))))))
                      (var 4)))) (equal (var 0) (natToTerm (beta a a0))))) 3
       (natToTerm (cPairPi1 a))).
apply (subWithEquals LNN).
apply eqSym.
eapply andE1.
apply Axm; right; constructor.
rewrite <-
 (subFormulaId LNN
    (substituteFormula LNN
       (impH (LT (var 0) (Succ (Times (var 3) (Succ (natToTerm a0)))))
          (impH
             (existH 5
                (andH (LT (var 5) (Succ (var 4)))
                   (equal
                      (Plus (var 0)
                         (Times (var 5)
                            (Succ (Times (var 3) (Succ (natToTerm a0))))))
                      (var 4)))) (equal (var 0) (natToTerm (beta a a0))))) 3
       (natToTerm (cPairPi1 a))) 4).
apply
 impE
  with
    (substituteFormula LNN
       (substituteFormula LNN
          (impH (LT (var 0) (Succ (Times (var 3) (Succ (natToTerm a0)))))
             (impH
                (existH 5
                   (andH (LT (var 5) (Succ (var 4)))
                      (equal
                         (Plus (var 0)
                            (Times (var 5)
                               (Succ (Times (var 3) (Succ (natToTerm a0))))))
                         (var 4)))) (equal (var 0) (natToTerm (beta a a0)))))
          3 (natToTerm (cPairPi1 a))) 4 (natToTerm (cPairPi2 a))).
apply (subWithEquals LNN).
apply eqSym.
eapply andE2.
apply Axm; right; constructor.
do 2 apply sysWeaken.
repeat first
 [ rewrite H; [ idtac | discriminate ]
 | rewrite H0
 | rewrite (subFormulaImp LNN)
 | rewrite (subFormulaAnd LNN)
 | rewrite (subFormulaEqual LNN) ].
simpl in |- *.
repeat (rewrite (subTermNil LNN); [ idtac | apply closedNatToTerm ]).
repeat
 (rewrite (subTermNil LNN (natToTerm a0)); [ idtac | apply closedNatToTerm ]).
repeat
 (rewrite (subTermNil LNN (natToTerm (beta a a0)));
   [ idtac | apply closedNatToTerm ]).
apply impTrans with (LT (var 0) (natToTerm (S (cPairPi1 a * S a0)))).
apply impI.
apply
 impE
  with
    (substituteFormula LNN (LT (var 0) (var 1)) 1
       (natToTerm (S (cPairPi1 a * S a0)))).
unfold LT at 2 in |- *.
rewrite (subFormulaRelation LNN).
apply impRefl.
apply
 impE
  with
    (substituteFormula LNN (LT (var 0) (var 1)) 1
       (Succ (Times (natToTerm (cPairPi1 a)) (Succ (natToTerm a0))))).
apply (subWithEquals LNN).
apply sysWeaken.
simpl in |- *.
apply eqSucc.
replace (Succ (natToTerm a0)) with (natToTerm (S a0)).
apply natTimes.
reflexivity.
unfold LT at 2 in |- *.
rewrite (subFormulaRelation LNN).
apply Axm; right; constructor.
apply boundedLT.
intros.
repeat first
 [ rewrite H; [ idtac | discriminate ]
 | rewrite H0
 | rewrite (subFormulaImp LNN)
 | rewrite (subFormulaAnd LNN)
 | rewrite (subFormulaEqual LNN) ].
simpl in |- *.
repeat (rewrite (subTermNil LNN); [ idtac | apply closedNatToTerm ]).
apply impI.
apply existSys.
apply closedNN.
simpl in |- *.
unfold not in |- *; intros.
induction (in_app_or _ _ _ H2); elim (closedNatToTerm _ _ H3).
apply
 impE
  with
    (fol.equal LNN
       (apply LNN Languages.Plus
          (Tcons LNN 1 (natToTerm n)
             (Tcons LNN 0
                (apply LNN Languages.Times
                   (Tcons LNN 1 (fol.var LNN 5)
                      (Tcons LNN 0
                         (apply LNN Languages.Succ
                            (Tcons LNN 0
                               (apply LNN Languages.Times
                                  (Tcons LNN 1 (natToTerm (cPairPi1 a))
                                     (Tcons LNN 0
                                        (apply LNN Languages.Succ
                                           (Tcons LNN 0 
                                              (natToTerm a0) 
                                              (Tnil LNN))) 
                                        (Tnil LNN)))) 
                               (Tnil LNN))) (Tnil LNN)))) 
                (Tnil LNN)))) (natToTerm (cPairPi2 a))).
apply impE with (LT (var 5) (natToTerm (S (cPairPi2 a)))).
apply sysWeaken.
apply boundedLT.
intros.
repeat first
 [ rewrite H; [ idtac | discriminate ]
 | rewrite H0
 | rewrite (subFormulaImp LNN)
 | rewrite (subFormulaAnd LNN)
 | rewrite (subFormulaEqual LNN) ].
simpl in |- *.
repeat (rewrite (subTermNil LNN); [ idtac | apply closedNatToTerm ]).
apply impI.
induction (eq_nat_dec n (beta a a0)).
rewrite <- a1.
apply eqRefl.
apply
 contradiction
  with
    (equal (natToTerm (n + n0 * S (cPairPi1 a * S a0)))
       (natToTerm (cPairPi2 a))).
eapply eqTrans; [ idtac | apply Axm; right; constructor ].
apply sysWeaken.
eapply eqTrans.
apply eqSym.
apply natPlus.
replace
 (apply LNN Languages.Plus
    (Tcons LNN 1 (natToTerm n)
       (Tcons LNN 0
          (apply LNN Languages.Times
             (Tcons LNN 1 (natToTerm n0)
                (Tcons LNN 0
                   (apply LNN Languages.Succ
                      (Tcons LNN 0
                         (apply LNN Languages.Times
                            (Tcons LNN 1 (natToTerm (cPairPi1 a))
                               (Tcons LNN 0
                                  (apply LNN Languages.Succ
                                     (Tcons LNN 0 (natToTerm a0) (Tnil LNN)))
                                  (Tnil LNN)))) (Tnil LNN))) 
                   (Tnil LNN)))) (Tnil LNN)))) with
 (Plus (natToTerm n)
    (Times (natToTerm n0)
       (Succ (Times (natToTerm (cPairPi1 a)) (Succ (natToTerm a0)))))).
apply eqPlus.
apply eqRefl.
eapply eqTrans.
apply eqSym.
apply natTimes.
apply eqTimes.
apply eqRefl.
simpl in |- *.
apply eqSucc.
replace (Succ (natToTerm a0)) with (natToTerm (S a0)).
apply eqSym.
apply natTimes.
reflexivity.
reflexivity.
apply sysWeaken.
apply natNE.
unfold not in |- *; intros; elim b.
unfold beta in |- *.
induction
 (modulo (coPrimeBeta a0 (cPairPi1 a)) (gtBeta a0 (cPairPi1 a)) (cPairPi2 a)).
induction x as (a1, b0).
simpl in p.
simpl in |- *.
induction p as (H4, H5).
unfold coPrimeBeta in H4.
rewrite plus_comm in H3.
eapply uniqueRem.
unfold gt in |- *.
apply lt_O_Sn.
exists n0.
split.
symmetry  in |- *.
apply H3.
apply H1.
exists a1.
split.
apply H4.
apply H5.
eapply andE1.
apply Axm; right; constructor.
eapply andE2.
apply Axm; right; constructor.
eapply andE1.
eapply andE2.
eapply andE2.
apply Axm; left; right; constructor.
eapply andE2.
eapply andE2.
eapply andE2.
apply Axm; left; right; constructor.
eapply andE2.
apply Axm; right; constructor.
eapply andE1.
apply Axm; right; constructor.
apply impI.
unfold beta in |- *.
induction
 (modulo (coPrimeBeta a0 (cPairPi1 a)) (gtBeta a0 (cPairPi1 a)) (cPairPi2 a)).
induction x as (a1, b).
simpl in |- *.
simpl in p.
induction p as (H1, H2).
apply existI with (natToTerm (cPairPi1 a)).
rewrite (subFormulaAnd LNN).
apply andI.
apply sysWeaken.
rewrite H0.
simpl in |- *.
rewrite subTermNil.
replace (apply LNN Languages.Succ (Tcons LNN 0 (natToTerm a) (Tnil LNN)))
 with (natToTerm (S a)).
apply natLT.
apply le_lt_n_Sm.
apply le_trans with (cPair (cPairPi1 a) (cPairPi2 a)).
apply cPairLe1.
rewrite cPairProjections.
apply le_n.
reflexivity.
apply closedNatToTerm.
rewrite H.
apply existI with (natToTerm (cPairPi2 a)).
repeat rewrite (subFormulaAnd LNN).
apply andI.
apply sysWeaken.
repeat rewrite H0.
simpl in |- *.
repeat rewrite (subTermNil LNN (natToTerm a)).
replace (apply LNN Languages.Succ (Tcons LNN 0 (natToTerm a) (Tnil LNN)))
 with (natToTerm (S a)).
apply natLT.
apply le_lt_n_Sm.
apply le_trans with (cPair (cPairPi1 a) (cPairPi2 a)).
apply cPairLe2.
rewrite cPairProjections.
apply le_n.
reflexivity.
apply closedNatToTerm.
apply closedNatToTerm.
apply andI.
repeat rewrite (subFormulaEqual LNN).
simpl in |- *.
repeat
 (rewrite (subTermNil LNN (natToTerm (cPairPi1 a)));
   [ idtac | apply closedNatToTerm ]).
repeat
 (rewrite (subTermNil LNN (natToTerm a)); [ idtac | apply closedNatToTerm ]).
replace
 (fol.equal LNN
    (apply LNN Languages.Plus
       (Tcons LNN 1
          (apply LNN Languages.Times
             (Tcons LNN 1
                (apply LNN Languages.Plus
                   (Tcons LNN 1 (natToTerm (cPairPi1 a))
                      (Tcons LNN 0 (natToTerm (cPairPi2 a)) (Tnil LNN))))
                (Tcons LNN 0
                   (apply LNN Languages.Succ
                      (Tcons LNN 0
                         (apply LNN Languages.Plus
                            (Tcons LNN 1 (natToTerm (cPairPi1 a))
                               (Tcons LNN 0 (natToTerm (cPairPi2 a))
                                  (Tnil LNN)))) (Tnil LNN))) 
                   (Tnil LNN))))
          (Tcons LNN 0
             (apply LNN Languages.Times
                (Tcons LNN 1
                   (apply LNN Languages.Succ
                      (Tcons LNN 0
                         (apply LNN Languages.Succ
                            (Tcons LNN 0
                               (apply LNN Languages.Zero (Tnil LNN))
                               (Tnil LNN))) (Tnil LNN)))
                   (Tcons LNN 0 (natToTerm (cPairPi1 a)) (Tnil LNN))))
             (Tnil LNN))))
    (apply LNN Languages.Times
       (Tcons LNN 1
          (apply LNN Languages.Succ
             (Tcons LNN 0
                (apply LNN Languages.Succ
                   (Tcons LNN 0 (apply LNN Languages.Zero (Tnil LNN))
                      (Tnil LNN))) (Tnil LNN)))
          (Tcons LNN 0 (natToTerm a) (Tnil LNN))))) with
 (equal
    (Plus
       (Times (Plus (natToTerm (cPairPi1 a)) (natToTerm (cPairPi2 a)))
          (Succ (Plus (natToTerm (cPairPi1 a)) (natToTerm (cPairPi2 a)))))
       (Times (natToTerm 2) (natToTerm (cPairPi1 a))))
    (Times (natToTerm 2) (natToTerm a))); [ idtac | reflexivity ].
apply
 eqTrans
  with
    (natToTerm
       ((cPairPi1 a + cPairPi2 a) * S (cPairPi1 a + cPairPi2 a) +
        2 * cPairPi1 a)).
apply sysWeaken.
apply eqSym.
eapply eqTrans.
apply eqSym.
apply natPlus.
apply eqPlus.
eapply eqTrans.
apply eqSym.
apply natTimes.
apply eqTimes.
apply eqSym.
apply natPlus.
simpl in |- *.
apply eqSucc.
apply eqSym.
apply natPlus.
apply eqSym.
apply natTimes.
rewrite cPairLemma1.

Fixpoint addExists (m n : nat) (f : Formula) {struct n} : Formula :=
  match n with
  | O => f
  | S n' => existH (n' + m) (addExists m n' f)
  end.

Lemma freeVarAddExists1 :
 forall (n m v : nat) (A : Formula),
 In v (freeVarFormula LNN (addExists m n A)) -> In v (freeVarFormula LNN A).

Lemma freeVarAddExists2 :
 forall (n m v : nat) (A : Formula),
 In v (freeVarFormula LNN (addExists m n A)) -> n + m <= v \/ v < m.

Lemma reduceAddExistsOneWay :
 forall (n m : nat) (A B : Formula),
 SysPrf NN (impH A B) -> SysPrf NN (impH (addExists m n A) (addExists m n B)).

Lemma reduceAddExists :
 forall (n m : nat) (A B : Formula),
 SysPrf NN (iffH A B) -> SysPrf NN (iffH (addExists m n A) (addExists m n B)).

Lemma subAddExistsNice :
 forall (n m : nat) (A : Formula) (v : nat) (s : Term),
 n + m <= v \/ v < m ->
 (forall v : nat, In v (freeVarTerm LNN s) -> n + m <= v \/ v < m) ->
 substituteFormula LNN (addExists m n A) v s =
 addExists m n (substituteFormula LNN A v s).

Fixpoint addForalls (m n : nat) (f : Formula) {struct n} : Formula :=
  match n with
  | O => f
  | S n' => forallH (n' + m) (addForalls m n' f)
  end.

Lemma freeVarAddForalls1 :
 forall (n m v : nat) (A : Formula),
 In v (freeVarFormula LNN (addForalls m n A)) -> In v (freeVarFormula LNN A).

Lemma freeVarAddForalls2 :
 forall (n m v : nat) (A : Formula),
 In v (freeVarFormula LNN (addForalls m n A)) -> n + m <= v \/ v < m.

Lemma reduceAddForalls :
 forall (n m : nat) (A B : Formula),
 SysPrf NN (iffH A B) ->
 SysPrf NN (iffH (addForalls m n A) (addForalls m n B)).

Lemma subAddForallsNice :
 forall (n m : nat) (A : Formula) (v : nat) (s : Term),
 n + m <= v \/ v < m ->
 (forall v : nat, In v (freeVarTerm LNN s) -> n + m <= v \/ v < m) ->
 substituteFormula LNN (addForalls m n A) v s =
 addForalls m n (substituteFormula LNN A v s).

Fixpoint FormulasToFormula (n w m : nat)
 (vs : Vector.t (Formula * naryFunc n) m) {struct vs} : Formula :=
  match vs with
  | Vector.nil => equal (var 0) (var 0)
  | Vector.cons v m' vs' =>
      andH (substituteFormula LNN (fst v) 0 (var (S m' + w)))
        (FormulasToFormula n w m' vs')
  end.

Fixpoint FormulasToFuncs (n m : nat) (vs : Vector.t (Formula * naryFunc n) m)
 {struct vs} : Vector.t (naryFunc n) m :=
  match vs in (Vector.t _ m) return (Vector.t (naryFunc n) m) with
  | Vector.nil => Vector.nil _
  | Vector.cons v m' vs' => Vector.cons _ (snd v) m' (FormulasToFuncs n m' vs')
  end.

Fixpoint RepresentablesHelp (n m : nat)
 (vs : Vector.t (Formula * naryFunc n) m) {struct vs} : Prop :=
  match vs with
  | Vector.nil => True
  | Vector.cons a m' vs' =>
      RepresentableHelp _ (snd a) (fst a) /\ RepresentablesHelp n m' vs'
  end.

Let succFormula : Formula := equal (var 0) (Succ (var 1)).

Remark succRepresentable : Representable 1 S succFormula.

Let zeroFormula : Formula := equal (var 0) Zero.

Remark zeroRepresentable : Representable 0 0 zeroFormula.

Let projFormula (m : nat) : Formula := equal (var 0) (var (S m)).

Remark projRepresentable :
 forall (n m : nat) (pr : m < n),
 Representable n (evalProjFunc n m pr) (projFormula m).

Let composeSigmaFormula (n w m : nat) (A : Vector.t (Formula * naryFunc n) m)
  (B : Formula) : Formula :=
  addExists (S w) m
    (andH (FormulasToFormula n w m A)
       (subAllFormula LNN B
          (fun x : nat =>
           match x with
           | O => var 0
           | S x' => var (S x' + w)
           end))).

Remark composeSigmaRepresentable :
 forall n w m : nat,
 n <= w ->
 forall (A : Vector.t (Formula * naryFunc n) m) (B : Formula) (g : naryFunc m),

Remark boundedCheck :
 forall P : nat -> Prop,
 (forall x : nat, decidable (P x)) ->
 forall c : nat,
 (forall d : nat, d < c -> ~ P d) \/ (exists d : nat, d < c /\ P d).

Remark smallestExists :
 forall P : nat -> Prop,
 (forall x : nat, decidable (P x)) ->
 forall c : nat,
 P c -> exists a : nat, P a /\ (forall b : nat, b < a -> ~ P b).

Let minimize (A B : Formula) (v x : nat) : Formula :=
  andH A
    (forallH x
       (impH (LT (var x) (var v)) (notH (substituteFormula LNN B v (var x))))).

Remark minimize1 :
 forall (A B : Formula) (v x : nat),
 v <> x ->
 ~ In x (freeVarFormula LNN B) ->
 forall a : nat,
 SysPrf NN (substituteFormula LNN A v (natToTerm a)) ->
 SysPrf NN (substituteFormula LNN B v (natToTerm a)) ->
 (forall b : nat,
  b < a -> SysPrf NN (notH (substituteFormula LNN A v (natToTerm b)))) ->
 (forall b : nat,
  b < a -> SysPrf NN (notH (substituteFormula LNN B v (natToTerm b)))) ->
 SysPrf NN (iffH (minimize A B v x) (equal (var v) (natToTerm a))).

Lemma subFormulaMinimize :
 forall (A B : Formula) (v x z : nat) (s : Term),
 ~ In x (freeVarTerm LNN s) ->
 ~ In v (freeVarTerm LNN s) ->
 x <> z ->
 v <> z ->
 SysPrf NN
   (iffH (substituteFormula LNN (minimize A B v x) z s)
      (minimize (substituteFormula LNN A z s) (substituteFormula LNN B z s) v
         x)).

Let primRecSigmaFormulaHelp (n : nat) (SigA SigB : Formula) : Formula :=
  andH
    (existH 0
       (andH SigA
          (substituteFormula LNN (substituteFormula LNN betaFormula 1 Zero) 2
             (var (S (S n))))))
    (forallH (S (S (S n)))
       (impH (LT (var (S (S (S n)))) (var (S n)))
          (existH 0
             (existH (S n)
                (andH
                   (substituteFormula LNN
                      (substituteFormula LNN
                         (substituteFormula LNN betaFormula 1
                            (var (S (S (S n))))) 2 
                         (var (S (S n)))) 0 (var (S n)))
                   (andH
                      (substituteFormula LNN SigB (S (S n))
                         (var (S (S (S n)))))
                      (substituteFormula LNN
                         (substituteFormula LNN betaFormula 1
                            (Succ (var (S (S (S n)))))) 2 
                         (var (S (S n)))))))))).

Let primRecPiFormulaHelp (n : nat) (SigA SigB : Formula) : Formula :=
  andH
    (forallH 0
       (impH SigA
          (substituteFormula LNN (substituteFormula LNN betaFormula 1 Zero) 2
             (var (S (S n))))))
    (forallH (S (S (S n)))
       (impH (LT (var (S (S (S n)))) (var (S n)))
          (forallH 0
             (forallH (S n)
                (impH
                   (substituteFormula LNN
                      (substituteFormula LNN
                         (substituteFormula LNN betaFormula 1
                            (var (S (S (S n))))) 2 
                         (var (S (S n)))) 0 (var (S n)))
                   (impH
                      (substituteFormula LNN SigB (S (S n))
                         (var (S (S (S n)))))
                      (substituteFormula LNN
                         (substituteFormula LNN betaFormula 1
                            (Succ (var (S (S (S n)))))) 2 
                         (var (S (S n)))))))))).

Lemma freeVarPrimRecSigmaFormulaHelp1 :
 forall (n : nat) (A B : Formula) (v : nat),
 In v (freeVarFormula LNN (primRecSigmaFormulaHelp n A B)) ->
 In v (freeVarFormula LNN A) \/
 In v (freeVarFormula LNN B) \/ v = S (S n) \/ v = S n.

Lemma freeVarPrimRecPiFormulaHelp1 :
 forall (n : nat) (A B : Formula) (v : nat),
 In v (freeVarFormula LNN (primRecPiFormulaHelp n A B)) ->
 In v (freeVarFormula LNN A) \/
 In v (freeVarFormula LNN B) \/ v = S (S n) \/ v = S n.

Let primRecSigmaFormula (n : nat) (SigA SigB : Formula) : Formula :=
  existH (S (S n))
    (andH
       (minimize (primRecSigmaFormulaHelp n SigA SigB)
          (primRecPiFormulaHelp n SigA SigB) (S (S n)) 
          (S (S (S (S n)))))
       (substituteFormula LNN
          (substituteFormula LNN betaFormula 2 (var (S (S n)))) 1 
          (var (S n)))).

Remark notBoundedForall :
 forall (P : nat -> Prop) (b : nat),
 (forall x : nat, decidable (P x)) ->
 ~ (forall n : nat, n < b -> P n) -> exists n : nat, n < b /\ ~ P n.

Lemma succ_plus_discr : forall n m : nat, n <> S (m + n).

Lemma n_SSn : forall n : nat, n <> S (S n).

Lemma n_SSSn : forall n : nat, n <> S (S (S n)).

Lemma n_SSSSn : forall n : nat, n <> S (S (S (S n))).

Remark In_betaFormula_subst_1_2_0 :
 forall (a b c : Term) (v : nat),
 In v
   (freeVarFormula LNN
      (substituteFormula LNN
         (substituteFormula LNN (substituteFormula LNN betaFormula 1 a) 2 b)
         0 c)) ->
 In v (freeVarTerm LNN a) \/
 In v (freeVarTerm LNN b) \/ In v (freeVarTerm LNN c).

Remark In_betaFormula_subst_1_2 :
 forall (a b : Term) (v : nat),
 In v
   (freeVarFormula LNN
      (substituteFormula LNN (substituteFormula LNN betaFormula 1 a) 2 b)) ->
 In v (freeVarTerm LNN a) \/
 In v (freeVarTerm LNN b) \/ In v (freeVarTerm LNN (var 0)).

Remark In_betaFormula_subst_1 :
 forall (a : Term) (v : nat),
 In v (freeVarFormula LNN (substituteFormula LNN betaFormula 1 a)) ->
 In v (freeVarTerm LNN a) \/
 In v (freeVarTerm LNN (var 2)) \/ In v (freeVarTerm LNN (var 0)).

Remark In_betaFormula :
 forall v : nat,
 In v (freeVarFormula LNN betaFormula) ->
 In v (freeVarTerm LNN (var 1)) \/
 In v (freeVarTerm LNN (var 2)) \/ In v (freeVarTerm LNN (var 0)).

Remark In_betaFormula_subst_2 :
 forall (a : Term) (v : nat),
 In v (freeVarFormula LNN (substituteFormula LNN betaFormula 2 a)) ->
 In v (freeVarTerm LNN a) \/
 In v (freeVarTerm LNN (var 1)) \/ In v (freeVarTerm LNN (var 0)).

Remark In_betaFormula_subst_2_1 :
 forall (a b : Term) (v : nat),
 In v
   (freeVarFormula LNN
      (substituteFormula LNN (substituteFormula LNN betaFormula 2 a) 1 b)) ->
 In v (freeVarTerm LNN a) \/
 In v (freeVarTerm LNN b) \/ In v (freeVarTerm LNN (var 0)).

Ltac PRsolveFV A B n :=
  unfold existH, forallH, not in |- *; intros;
   repeat
    match goal with
    | H:(_ = _) |- _ => discriminate H
    | H:(?X1 <> ?X1) |- _ => elim H; reflexivity
    | H:(?X1 = S ?X1) |- _ => elim (n_Sn _ H)
    | H:(S ?X1 = ?X1) |- _ =>
        elim (n_Sn X1); symmetry  in |- *; apply H
    | H:(?X1 = S (S ?X1)) |- _ => elim (n_SSn _ H)
    | H:(S (S ?X1) = ?X1) |- _ =>
        elim (n_SSn X1); symmetry  in |- *; apply H
    | H:(?X1 = S (S (S ?X1))) |- _ =>
        elim (n_SSSn _ H)
    | H:(S (S (S ?X1)) = ?X1) |- _ =>
        elim (n_SSSn X1); symmetry  in |- *; apply H
    | H:(In ?X3
           (freeVarFormula LNN
              (substituteFormula LNN
                 (substituteFormula LNN
                    (substituteFormula LNN betaFormula 1 _) 2 _) 0 _))) |- _
    =>
        decompose sum (In_betaFormula_subst_1_2_0 _ _ _ _ H); clear H
    | H:(In ?X3
           (freeVarFormula LNN
              (substituteFormula LNN (substituteFormula LNN betaFormula 1 _)
                 2 _))) |- _ =>
        decompose sum (In_betaFormula_subst_1_2 _ _ _ H); clear H
    | H:(In ?X3 (freeVarFormula LNN (substituteFormula LNN betaFormula 1 _)))
    |- _ =>
        decompose sum (In_betaFormula_subst_1 _ _ H); clear H
    | H:(In ?X3 (freeVarFormula LNN betaFormula)) |- _ =>
        decompose sum (In_betaFormula _ H); clear H
    | H:(In ?X3
           (freeVarFormula LNN
              (substituteFormula LNN (substituteFormula LNN betaFormula 2 _)
                 1 _))) |- _ =>
        decompose sum (In_betaFormula_subst_2_1 _ _ _ H); clear H
    | H:(In ?X3 (freeVarFormula LNN (substituteFormula LNN betaFormula 2 _)))
    |- _ =>
        decompose sum (In_betaFormula_subst_2 _ _ H);
         clear H
              | H:(In ?X3 (freeVarFormula LNN (fol.existH LNN ?X1 ?X2))) |- _ =>
        assert
         (In X3 (list_remove nat eq_nat_dec X1 (freeVarFormula LNN X2)));
         [ apply H | clear H ]
    | H:(In ?X3 (freeVarFormula LNN (fol.forallH LNN ?X1 ?X2))) |- _ =>
        assert
         (In X3 (list_remove nat eq_nat_dec X1 (freeVarFormula LNN X2)));
         [ apply H | clear H ]
    | 
        H:(In ?X3 (list_remove nat eq_nat_dec ?X1 (freeVarFormula LNN ?X2))) |- _
    =>
        assert (In X3 (freeVarFormula LNN X2));
         [ eapply In_list_remove1; apply H
         | assert (X3 <> X1); [ eapply In_list_remove2; apply H | clear H ] ]
    | H:(In ?X3 (freeVarFormula LNN (fol.andH LNN ?X1 ?X2))) |- _ =>
        assert (In X3 (freeVarFormula LNN X1 ++ freeVarFormula LNN X2));
         [ apply H | clear H ]
    | H:(In ?X3 (freeVarFormula LNN (fol.impH LNN ?X1 ?X2))) |- _ =>
        assert (In X3 (freeVarFormula LNN X1 ++ freeVarFormula LNN X2));
         [ apply H | clear H ]
    | H:(In ?X3 (freeVarFormula LNN (fol.notH LNN ?X1))) |- _ =>
        assert (In X3 (freeVarFormula LNN X1)); [ apply H | clear H ]
    | H:(In _ (freeVarFormula LNN (primRecPiFormulaHelp _ _ _))) |- _ =>
        decompose sum (freeVarPrimRecPiFormulaHelp1 _ _ _ _ H); clear H
    | J:(In ?X3 (freeVarFormula LNN A)),H:(forall v : nat,
                                           In v (freeVarFormula LNN A) ->
                                           v <= S n) |- _ =>
        elim (le_not_lt X3 (S n));
         [ apply H; apply J | clear J; repeat apply lt_n_Sn || apply lt_S ]
    | H:(In ?X3 (freeVarFormula LNN B)),H0:(forall v : nat,
                                            In v (freeVarFormula LNN B) ->
                                            v <= S (S (S n))) |- _ =>
        elim (le_not_lt X3 (S (S (S n))));
         [ apply H0; apply H | clear H; repeat apply lt_n_Sn || apply lt_S ]
    | H:(In _ (_ ++ _)) |- _ =>
        induction (in_app_or _ _ _ H); clear H
    | H:(In _ (freeVarFormula LNN (substituteFormula LNN ?X1 ?X2 ?X3))) |- _
    =>
        induction (freeVarSubFormula3 _ _ _ _ _ H); clear H
    | H:(In _ (freeVarFormula LNN (LT ?X1 ?X2))) |- _ =>
        rewrite freeVarLT in H
    | H:(In _ (freeVarTerm LNN (natToTerm _))) |- _ =>
        elim (closedNatToTerm _ _ H)
    | H:(In _ (freeVarTerm LNN Zero)) |- _ =>
        elim H
    | H:(In _ (freeVarTerm LNN (Succ _))) |- _ =>
        rewrite freeVarSucc in H
    | H:(In _ (freeVarTerm LNN (var _))) |- _ =>
        simpl in H; decompose sum H; clear H
    | H:(In _ (freeVarTerm LNN (fol.var LNN _))) |- _ =>
        simpl in H; decompose sum H; clear H
    end.

Remark primRecSigmaRepresentable :
 forall (n : nat) (A : Formula) (g : naryFunc n),
 Representable n g A ->
 forall (B : Formula) (h : naryFunc (S (S n))),
 Representable (S (S n)) h B ->
 Representable (S n) (evalPrimRecFunc n g h) (primRecSigmaFormula n A B).
Proof.
assert
 (forall (n : nat) (A : Formula) (g : naryFunc n),
  Representable n g A ->
  forall (B : Formula) (h : naryFunc (S (S n))),
  Representable (S (S n)) h B ->
  RepresentableHelp (S n) (evalPrimRecFunc n g h) (primRecSigmaFormula n A B)).
intro.
induction n as [| n Hrecn].
simpl in |- *; intros.
unfold primRecSigmaFormula in |- *.
rewrite (subFormulaExist LNN).
induction (In_dec eq_nat_dec 2 (freeVarTerm LNN (natToTerm a))).
elim (closedNatToTerm _ _ a0).
simpl in |- *.
clear b.
assert (repBeta : Representable 2 beta betaFormula).
apply betaRepresentable.
rewrite (subFormulaAnd LNN).
repeat rewrite (subFormulaId LNN).
apply
 iffTrans
  with
    (fol.existH LNN 2
       (fol.andH LNN
          (minimize
             (substituteFormula LNN (primRecSigmaFormulaHelp 0 A B) 1
                (natToTerm a))
             (substituteFormula LNN (primRecPiFormulaHelp 0 A B) 1
                (natToTerm a)) 2 4)
          (substituteFormula LNN betaFormula 1 (natToTerm a)))).
apply (reduceExist LNN).
apply closedNN.
apply (reduceAnd LNN).
apply subFormulaMinimize; first [ discriminate | apply closedNatToTerm ].
apply iffRefl.
set (f := evalPrimRecFunc 0 g h) in *.
induction (betaTheorem1 (S a) f).

Fixpoint primRecFormula (n : nat) (f : PrimRec n) {struct f} : Formula :=
  match f with
  | succFunc => succFormula
  | zeroFunc => zeroFormula
  | projFunc n m _ => projFormula m
  | composeFunc n m g h =>
      composeSigmaFormula n n m (primRecsFormula n m g) (primRecFormula m h)
  | primRecFunc n g h =>
      primRecSigmaFormula n (primRecFormula n g) (primRecFormula (S (S n)) h)
  end
 
 with primRecsFormula (n m : nat) (fs : PrimRecs n m) {struct fs} :
 Vector.t (Formula * naryFunc n) m :=
  match fs in (PrimRecs n m) return (Vector.t (Formula * naryFunc n) m) with
  | PRnil n => Vector.nil _
  | PRcons n m f fs' =>
      Vector.cons (Formula * naryFunc n) (primRecFormula n f, evalPrimRec n f) m
        (primRecsFormula n m fs')
  end.

Lemma primRecRepresentable1 :
 forall (n : nat) (f : PrimRec n),
 Representable n (evalPrimRec n f) (primRecFormula n f).

Lemma primRecRepresentable :
 forall (n : nat) (f : naryFunc n) (p : isPR n f),
 Representable n f (primRecFormula n (proj1_sig p)).

End Primative_Recursive_Representable. *)

Require Import expressible.
(* expressible:
Require Import Arith.
Require Import Coq.Lists.List.
Require Import ListExt.
Require Import folProp.
Require Import subProp.
Require Import extEqualNat.
Require Import LNN.

Section RepresentableExpressible.

Variable T : System.
Hypothesis closedT1: (ClosedSystem LNN T).

Lemma closedT : forall v : nat, ~ In_freeVarSys LNN v T.

Fixpoint RepresentableHalf1 (n : nat) : naryFunc n -> Formula -> Prop :=
  match n return (naryFunc n -> Formula -> Prop) with
  | O =>
      fun (f : naryFunc 0) (A : Formula) =>
      SysPrf T (impH A (equal (var 0) (natToTerm f)))
  | S m =>
      fun (f : naryFunc (S m)) (A : Formula) =>
      forall a : nat,
      RepresentableHalf1 m (f a)
        (substituteFormula LNN A (S m) (natToTerm a))
  end.

Fixpoint RepresentableHalf2 (n : nat) : naryFunc n -> Formula -> Prop :=
  match n return (naryFunc n -> Formula -> Prop) with
  | O =>
      fun (f : naryFunc 0) (A : Formula) =>
      SysPrf T (impH (equal (var 0) (natToTerm f)) A)
  | S m =>
      fun (f : naryFunc (S m)) (A : Formula) =>
      forall a : nat,
      RepresentableHalf2 m (f a)
        (substituteFormula LNN A (S m) (natToTerm a))
  end.

Lemma RepresentableHalf1Alternate :
 forall (n : nat) (f : naryFunc n) (A B : Formula),
 SysPrf T (impH A B) -> RepresentableHalf1 n f B -> RepresentableHalf1 n f A.

Lemma RepresentableHalf2Alternate :
 forall (n : nat) (f : naryFunc n) (A B : Formula),
 SysPrf T (impH A B) -> RepresentableHalf2 n f A -> RepresentableHalf2 n f B.

Fixpoint RepresentableHelp (n : nat) : naryFunc n -> Formula -> Prop :=
  match n return (naryFunc n -> Formula -> Prop) with
  | O =>
      fun (f : naryFunc 0) (A : Formula) =>
      SysPrf T (iffH A (equal (var 0) (natToTerm f)))
  | S m =>
      fun (f : naryFunc (S m)) (A : Formula) =>
      forall a : nat,
      RepresentableHelp m (f a) (substituteFormula LNN A (S m) (natToTerm a))
  end.

Lemma RepresentableHalfHelp :
 forall (n : nat) (f : naryFunc n) (A : Formula),
 RepresentableHalf1 n f A ->
 RepresentableHalf2 n f A -> RepresentableHelp n f A.

Definition Representable (n : nat) (f : naryFunc n) 
  (A : Formula) : Prop :=
  (forall v : nat, In v (freeVarFormula LNN A) -> v <= n) /\
  RepresentableHelp n f A.

Lemma RepresentableAlternate :
 forall (n : nat) (f : naryFunc n) (A B : Formula),
 SysPrf T (iffH A B) -> RepresentableHelp n f A -> RepresentableHelp n f B.

Lemma Representable_ext :
 forall (n : nat) (f g : naryFunc n) (A : Formula),
 extEqual n f g -> RepresentableHelp n f A -> RepresentableHelp n g A.

Fixpoint ExpressibleHelp (n : nat) : naryRel n -> Formula -> Prop :=
  match n return (naryRel n -> Formula -> Prop) with
  | O =>
      fun (R : naryRel 0) (A : Formula) =>
      match R with
      | true => SysPrf T A
      | false => SysPrf T (notH A)
      end
  | S m =>
      fun (R : naryRel (S m)) (A : Formula) =>
      forall a : nat,
      ExpressibleHelp m (R a) (substituteFormula LNN A (S m) (natToTerm a))
  end.

Definition Expressible (n : nat) (R : naryRel n) (A : Formula) : Prop :=
  (forall v : nat, In v (freeVarFormula LNN A) -> v <= n /\ v <> 0) /\
  ExpressibleHelp n R A.

Lemma expressibleAlternate :
 forall (n : nat) (R : naryRel n) (A B : Formula),
 SysPrf T (iffH A B) -> ExpressibleHelp n R A -> ExpressibleHelp n R B.

Hypothesis nn1:(SysPrf T (notH (equal (natToTerm 1) (natToTerm 0)))).

Lemma Representable2Expressible :
 forall (n : nat) (R : naryRel n) (A : Formula),
 Representable n (charFunction n R) A ->
 Expressible n R (substituteFormula LNN A 0 (natToTerm 1)).

End RepresentableExpressible. *)

Require Import primRec.
(* primRec:
Require Import Arith.
Require Import Peano_dec.
Require Import Compare_dec.
Require Import Coq.Lists.List.
Require Import Eqdep_dec.
Require Import extEqualNat.
Require Vector.
Require Import misc.
Require Export Bool.
Require Export EqNat.
Require Import Even.
Require Import Max.

Inductive PrimRec : nat -> Set :=
  | succFunc : PrimRec 1
  | zeroFunc : PrimRec 0
  | projFunc : forall n m : nat, m < n -> PrimRec n
  | composeFunc :
      forall (n m : nat) (g : PrimRecs n m) (h : PrimRec m), PrimRec n
  | primRecFunc :
      forall (n : nat) (g : PrimRec n) (h : PrimRec (S (S n))), PrimRec (S n)
with PrimRecs : nat -> nat -> Set :=
  | PRnil : forall n : nat, PrimRecs n 0
  | PRcons : forall n m : nat, PrimRec n -> PrimRecs n m -> PrimRecs n (S m).

Scheme PrimRec_PrimRecs_rec := Induction for PrimRec
  Sort Set
  with PrimRecs_PrimRec_rec := Induction for PrimRecs 
  Sort Set.

Scheme PrimRec_PrimRecs_ind := Induction for PrimRec
  Sort Prop
  with PrimRecs_PrimRec_ind := Induction for PrimRecs 
  Sort Prop.

Fixpoint evalConstFunc (n m : nat) {struct n} : naryFunc n :=
  match n return (naryFunc n) with
  | O => m
  | S n' => fun _ => evalConstFunc n' m
  end.

Fixpoint evalProjFunc (n : nat) : forall m : nat, m < n -> naryFunc n :=
  match n return (forall m : nat, m < n -> naryFunc n) with
  | O => fun (m : nat) (l : m < 0) => False_rec _ (lt_n_O _ l)
  | S n' =>
      fun (m : nat) (l : m < S n') =>
      match eq_nat_dec m n' with
      | left _ => fun a : nat => evalConstFunc _ a
      | right l1 =>
          fun _ =>
          evalProjFunc n' m
            match le_lt_or_eq _ _ (lt_n_Sm_le _ _ l) with
            | or_introl l2 => l2
            | or_intror l2 => False_ind _ (l1 l2)
            end
      end
  end.

Lemma evalProjFuncInd :
 forall (n m : nat) (p1 p2 : m < n),
 evalProjFunc n m p1 = evalProjFunc n m p2.

Fixpoint evalList (m : nat) (l : Vector.t nat m) {struct l} :
 naryFunc m -> nat :=
  match l in (Vector.t _ m) return (naryFunc m -> nat) with
  | Vector.nil => fun x : naryFunc 0 => x
  | Vector.cons a n l' => fun x : naryFunc (S n) => evalList n l' (x a)
  end.

Fixpoint evalOneParamList (n m a : nat) (l : Vector.t (naryFunc (S n)) m)
 {struct l} : Vector.t (naryFunc n) m :=
  match l in (Vector.t _ m) return (Vector.t (naryFunc n) m) with
  | Vector.nil  => Vector.nil  (naryFunc n)
  | Vector.cons f m' l' => Vector.cons _ (f a) m' (evalOneParamList n m' a l')
  end.

Fixpoint evalComposeFunc (n : nat) :
 forall m : nat, Vector.t (naryFunc n) m -> naryFunc m -> naryFunc n :=
  match
    n
    return
      (forall m : nat, Vector.t (naryFunc n) m -> naryFunc m -> naryFunc n)
  with
  | O => evalList
  | S n' =>
      fun (m : nat) (l : Vector.t (naryFunc (S n')) m) 
        (f : naryFunc m) (a : nat) =>
      evalComposeFunc n' m (evalOneParamList _ _ a l) f
  end.

Fixpoint compose2 (n : nat) : naryFunc n -> naryFunc (S n) -> naryFunc n :=
  match n return (naryFunc n -> naryFunc (S n) -> naryFunc n) with
  | O => fun (a : nat) (g : nat -> nat) => g a
  | S n' =>
      fun (f : naryFunc (S n')) (g : naryFunc (S (S n'))) (a : nat) =>
      compose2 n' (f a) (fun x : nat => g x a)
  end.

Fixpoint evalPrimRecFunc (n : nat) (g : naryFunc n) 
 (h : naryFunc (S (S n))) (a : nat) {struct a} : naryFunc n :=
  match a with
  | O => g
  | S a' => compose2 _ (evalPrimRecFunc n g h a') (h a')
  end.

Fixpoint evalPrimRec (n : nat) (f : PrimRec n) {struct f} : 
 naryFunc n :=
  match f in (PrimRec n) return (naryFunc n) with
  | succFunc => S
  | zeroFunc => 0
  | projFunc n m pf => evalProjFunc n m pf
  | composeFunc n m l f =>
      evalComposeFunc n m (evalPrimRecs _ _ l) (evalPrimRec _ f)
  | primRecFunc n g h =>
      evalPrimRecFunc n (evalPrimRec _ g) (evalPrimRec _ h)
  end
 
 with evalPrimRecs (n m : nat) (fs : PrimRecs n m) {struct fs} :
 Vector.t (naryFunc n) m :=
  match fs in (PrimRecs n m) return (Vector.t (naryFunc n) m) with
  | PRnil a => Vector.nil  (naryFunc a)
  | PRcons a b g gs => Vector.cons _ (evalPrimRec _ g) _ (evalPrimRecs _ _ gs)
  end.

Definition extEqualVectorGeneral (n m : nat) (l : Vector.t (naryFunc n) m) :

Definition extEqualVector n: forall m (l l' : Vector.t (naryFunc n) m), Prop.

Lemma extEqualVectorRefl :
 forall (n m : nat) (l : Vector.t (naryFunc n) m), extEqualVector n m l l.

Lemma extEqualOneParamList :
 forall (n m : nat) (l1 l2 : Vector.t (naryFunc (S n)) m) (c : nat),

Lemma extEqualCompose :
 forall (n m : nat) (l1 l2 : Vector.t (naryFunc n) m) (f1 f2 : naryFunc m),

Lemma extEqualCompose2 :
 forall (n : nat) (f1 f2 : naryFunc n),
 extEqual n f1 f2 ->
 forall g1 g2 : naryFunc (S n),
 extEqual (S n) g1 g2 -> extEqual n (compose2 n f1 g1) (compose2 n f2 g2).

Lemma extEqualPrimRec :
 forall (n : nat) (g1 g2 : naryFunc n) (h1 h2 : naryFunc (S (S n))),
 extEqual n g1 g2 ->
 extEqual (S (S n)) h1 h2 ->
 extEqual (S n) (evalPrimRecFunc n g1 h1) (evalPrimRecFunc n g2 h2).

Definition isPR (n : nat) (f : naryFunc n) : Set :=
  {p : PrimRec n | extEqual n (evalPrimRec _ p) f}.

Definition isPRrel (n : nat) (R : naryRel n) : Set :=
  isPR n (charFunction n R).

Lemma succIsPR : isPR 1 S.

Lemma const0_NIsPR : forall n : nat, isPR 0 n.

Lemma const1_NIsPR : forall n : nat, isPR 1 (fun _ => n).

Lemma idIsPR : isPR 1 (fun x : nat => x).

Lemma pi1_2IsPR : isPR 2 (fun a b : nat => a).

Lemma pi2_2IsPR : isPR 2 (fun a b : nat => b).

Lemma pi1_3IsPR : isPR 3 (fun a b c : nat => a).

Lemma pi2_3IsPR : isPR 3 (fun a b c : nat => b).

Lemma pi3_3IsPR : isPR 3 (fun a b c : nat => c).

Lemma pi1_4IsPR : isPR 4 (fun a b c d : nat => a).

Lemma pi2_4IsPR : isPR 4 (fun a b c d : nat => b).

Lemma pi3_4IsPR : isPR 4 (fun a b c d : nat => c).

Lemma pi4_4IsPR : isPR 4 (fun a b c d : nat => d).

Lemma filter01IsPR :
 forall g : nat -> nat, isPR 1 g -> isPR 2 (fun a b : nat => g b).

Lemma filter10IsPR :
 forall g : nat -> nat, isPR 1 g -> isPR 2 (fun a b : nat => g a).

Lemma filter100IsPR :
 forall g : nat -> nat, isPR 1 g -> isPR 3 (fun a b c : nat => g a).

Lemma filter010IsPR :
 forall g : nat -> nat, isPR 1 g -> isPR 3 (fun a b c : nat => g b).

Lemma filter001IsPR :
 forall g : nat -> nat, isPR 1 g -> isPR 3 (fun a b c : nat => g c).

Lemma filter011IsPR :
 forall g : nat -> nat -> nat, isPR 2 g -> isPR 3 (fun a b c : nat => g b c).

Lemma filter110IsPR :
 forall g : nat -> nat -> nat, isPR 2 g -> isPR 3 (fun a b c : nat => g a b).

Lemma filter101IsPR :
 forall g : nat -> nat -> nat, isPR 2 g -> isPR 3 (fun a b c : nat => g a c).

Lemma filter0011IsPR :
 forall g : nat -> nat -> nat,
 isPR 2 g -> isPR 4 (fun a b c d : nat => g c d).

Lemma filter1000IsPR :
 forall g : nat -> nat, isPR 1 g -> isPR 4 (fun a b c d : nat => g a).

Lemma filter1011IsPR :
 forall g : nat -> nat -> nat -> nat,
 isPR 3 g -> isPR 4 (fun a b c d : nat => g a c d).

Lemma filter1100IsPR :
 forall g : nat -> nat -> nat,
 isPR 2 g -> isPR 4 (fun a b c d : nat => g a b).

Lemma compose1_1IsPR :
 forall f : nat -> nat,
 isPR 1 f ->
 forall g : nat -> nat, isPR 1 g -> isPR 1 (fun x : nat => g (f x)).

Lemma compose1_2IsPR :
 forall f : nat -> nat,
 isPR 1 f ->
 forall f' : nat -> nat,
 isPR 1 f' ->
 forall g : nat -> nat -> nat,
 isPR 2 g -> isPR 1 (fun x : nat => g (f x) (f' x)).

Lemma compose1_3IsPR :
 forall f1 : nat -> nat,
 isPR 1 f1 ->
 forall f2 : nat -> nat,
 isPR 1 f2 ->
 forall f3 : nat -> nat,
 isPR 1 f3 ->
 forall g : nat -> nat -> nat -> nat,
 isPR 3 g -> isPR 1 (fun x : nat => g (f1 x) (f2 x) (f3 x)).

Lemma compose2_1IsPR :
 forall f : nat -> nat -> nat,
 isPR 2 f ->
 forall g : nat -> nat, isPR 1 g -> isPR 2 (fun x y : nat => g (f x y)).

Lemma compose2_2IsPR :
 forall f : nat -> nat -> nat,
 isPR 2 f ->
 forall g : nat -> nat -> nat,
 isPR 2 g ->
 forall h : nat -> nat -> nat,
 isPR 2 h -> isPR 2 (fun x y : nat => h (f x y) (g x y)).

Lemma compose2_3IsPR :
 forall f1 : nat -> nat -> nat,
 isPR 2 f1 ->
 forall f2 : nat -> nat -> nat,
 isPR 2 f2 ->
 forall f3 : nat -> nat -> nat,
 isPR 2 f3 ->
 forall g : nat -> nat -> nat -> nat,
 isPR 3 g -> isPR 2 (fun x y : nat => g (f1 x y) (f2 x y) (f3 x y)).

Lemma compose2_4IsPR :
 forall f1 : nat -> nat -> nat,
 isPR 2 f1 ->
 forall f2 : nat -> nat -> nat,
 isPR 2 f2 ->
 forall f3 : nat -> nat -> nat,
 isPR 2 f3 ->
 forall f4 : nat -> nat -> nat,
 isPR 2 f4 ->
 forall g : nat -> nat -> nat -> nat -> nat,
 isPR 4 g -> isPR 2 (fun x y : nat => g (f1 x y) (f2 x y) (f3 x y) (f4 x y)).

Lemma compose3_1IsPR :
 forall f : nat -> nat -> nat -> nat,
 isPR 3 f ->
 forall g : nat -> nat, isPR 1 g -> isPR 3 (fun x y z : nat => g (f x y z)).

Lemma compose3_2IsPR :
 forall f1 : nat -> nat -> nat -> nat,
 isPR 3 f1 ->
 forall f2 : nat -> nat -> nat -> nat,
 isPR 3 f2 ->
 forall g : nat -> nat -> nat,
 isPR 2 g -> isPR 3 (fun x y z : nat => g (f1 x y z) (f2 x y z)).

Lemma compose3_3IsPR :
 forall f1 : nat -> nat -> nat -> nat,
 isPR 3 f1 ->
 forall f2 : nat -> nat -> nat -> nat,
 isPR 3 f2 ->
 forall f3 : nat -> nat -> nat -> nat,
 isPR 3 f3 ->
 forall g : nat -> nat -> nat -> nat,
 isPR 3 g -> isPR 3 (fun x y z : nat => g (f1 x y z) (f2 x y z) (f3 x y z)).

Lemma compose4_2IsPR :
 forall f1 : nat -> nat -> nat -> nat -> nat,
 isPR 4 f1 ->
 forall f2 : nat -> nat -> nat -> nat -> nat,
 isPR 4 f2 ->
 forall g : nat -> nat -> nat,
 isPR 2 g -> isPR 4 (fun w x y z : nat => g (f1 w x y z) (f2 w x y z)).

Lemma compose4_3IsPR :
 forall f1 : nat -> nat -> nat -> nat -> nat,
 isPR 4 f1 ->
 forall f2 : nat -> nat -> nat -> nat -> nat,
 isPR 4 f2 ->
 forall f3 : nat -> nat -> nat -> nat -> nat,
 isPR 4 f3 ->
 forall g : nat -> nat -> nat -> nat,
 isPR 3 g ->
 isPR 4 (fun w x y z : nat => g (f1 w x y z) (f2 w x y z) (f3 w x y z)).

Lemma swapIsPR :
 forall f : nat -> nat -> nat, isPR 2 f -> isPR 2 (fun x y : nat => f y x).

Lemma indIsPR :
 forall f : nat -> nat -> nat,
 isPR 2 f ->
 forall g : nat,
 isPR 1
   (fun a : nat => nat_rec (fun n : nat => nat) g (fun x y : nat => f x y) a).

Lemma ind1ParamIsPR :
 forall f : nat -> nat -> nat -> nat,
 isPR 3 f ->
 forall g : nat -> nat,
 isPR 1 g ->
 isPR 2
   (fun a b : nat =>
    nat_rec (fun n : nat => nat) (g b) (fun x y : nat => f x y b) a).

Lemma ind2ParamIsPR :
 forall f : nat -> nat -> nat -> nat -> nat,
 isPR 4 f ->
 forall g : nat -> nat -> nat,
 isPR 2 g ->
 isPR 3
   (fun a b c : nat =>
    nat_rec (fun n : nat => nat) (g b c) (fun x y : nat => f x y b c) a).

Lemma plusIndIsPR : isPR 3 (fun n fn b : nat => S fn).

Lemma plusIsPR : isPR 2 plus.

Lemma multIndIsPR : isPR 3 (fun n fn b : nat => fn + b).

Lemma multIsPR : isPR 2 mult.

Lemma predIsPR : isPR 1 pred.

Lemma minusIndIsPR : isPR 3 (fun n fn b : nat => pred fn).

Lemma minusIsPR : isPR 2 minus.

Definition notZero (a : nat) :=
  nat_rec (fun n : nat => nat) 0 (fun x y : nat => 1) a.

Lemma notZeroIsPR : isPR 1 notZero.

Definition ltBool (a b : nat) : bool.

Lemma ltBoolTrue : forall a b : nat, ltBool a b = true -> a < b.

Lemma ltBoolFalse : forall a b : nat, ltBool a b = false -> ~ a < b.

Lemma ltIsPR : isPRrel 2 ltBool.

Lemma maxIsPR : isPR 2 max.

Lemma gtIsPR : isPRrel 2 (fun a b : nat => ltBool b a).

Remark replaceCompose2 :
 forall (n : nat) (a b a' b' : naryFunc n) (c c' : naryFunc 2),
 extEqual n a a' ->
 extEqual n b b' ->
 extEqual 2 c c' ->
 extEqual n
   (evalComposeFunc _ _ (Vector.cons _ a _ (Vector.cons _ b _ (Vector.nil  (naryFunc n)))) c)

Definition orRel (n : nat) (R S : naryRel n) : naryRel n.

Lemma orRelPR :
 forall (n : nat) (R R' : naryRel n),
 isPRrel n R -> isPRrel n R' -> isPRrel n (orRel n R R').

Definition andRel (n : nat) (R S : naryRel n) : naryRel n.

Lemma andRelPR :
 forall (n : nat) (R R' : naryRel n),
 isPRrel n R -> isPRrel n R' -> isPRrel n (andRel n R R').

Definition notRel (n : nat) (R : naryRel n) : naryRel n.

Lemma notRelPR :
 forall (n : nat) (R : naryRel n), isPRrel n R -> isPRrel n (notRel n R).

Fixpoint bodd (n : nat) : bool :=
  match n with
  | O => false
  | S n' => negb (bodd n')
  end.

Lemma boddIsPR : isPRrel 1 bodd.

Lemma beq_nat_not_refl : forall a b : nat, a <> b -> beq_nat a b = false.

Lemma neqIsPR : isPRrel 2 (fun a b : nat => negb (beq_nat a b)).

Lemma eqIsPR : isPRrel 2 beq_nat.

Definition leBool (a b : nat) : bool.

Lemma leIsPR : isPRrel 2 leBool.

Section Ignore_Params.

Fixpoint ignoreParams (n m : nat) (f : naryFunc n) {struct m} :
 naryFunc (m + n) :=
  match m return (naryFunc (m + n)) with
  | O => f
  | S x => fun _ => ignoreParams n x f
  end.

Definition projectionListPR (n m : nat) (p : m <= n) : PrimRecs n m.

Definition projectionList (n m : nat) (p : m <= n) : 
  Vector.t (naryFunc n) m := evalPrimRecs n m (projectionListPR n m p).

Lemma projectionListInd :
 forall (n m : nat) (p1 p2 : m <= n),
 projectionList n m p1 = projectionList n m p2.

Lemma projectionListApplyParam :
 forall (m n c : nat) (p1 : m <= n) (p2 : m <= S n),
 extEqualVector _ _ (projectionList n m p1)
   (evalOneParamList n m c (projectionList (S n) m p2)).

Lemma projectionListId :
 forall (n : nat) (f : naryFunc n) (p : n <= n),
 extEqual n f (evalComposeFunc n n (projectionList n n p) f).

Lemma ignoreParamsIsPR :
 forall (n m : nat) (f : naryFunc n), isPR _ f -> isPR _ (ignoreParams n m f).

End Ignore_Params.

Lemma reduce1stCompose :
 forall (c n m : nat) (v : Vector.t (naryFunc n) m) (g : naryFunc (S m)),

Lemma reduce2ndCompose :
 forall (c n m : nat) (v : Vector.t (naryFunc n) m) (n0 : naryFunc n)

Lemma evalPrimRecParam :
 forall (n c d : nat) (g : naryFunc (S n)) (h : naryFunc (S (S (S n)))),
 extEqual _ (evalPrimRecFunc n (g d) (fun x y : nat => h x y d) c)
   (evalPrimRecFunc (S n) g h c d).

Lemma compose2IsPR :
 forall (n : nat) (f : naryFunc n) (p : isPR n f) (g : naryFunc (S n))
   (q : isPR (S n) g), isPR n (compose2 n f g).

Lemma compose1_NIsPR :
 forall (n : nat) (g : naryFunc (S n)),
 isPR (S n) g ->
 forall f : naryFunc 1, isPR 1 f -> isPR (S n) (fun x : nat => g (f x)).

Definition switchPR : naryFunc 3. 

Lemma switchIsPR : isPR 3 switchPR.

Fixpoint boundedSearchHelp (P : naryRel 1) (b : nat) {struct b} : nat :=
  match b with
  | O => 0
  | S b' =>
      match eq_nat_dec (boundedSearchHelp P b') b' with
      | left _ => match P b' with
                  | true => b'
                  | false => S b'
                  end
      | right _ => boundedSearchHelp P b'
      end
  end.
   
Definition boundedSearch (P : naryRel 2) (b : nat) : nat :=
  boundedSearchHelp (P b) b.

Lemma boundedSearch1 :
 forall (P : naryRel 2) (b x : nat), x < boundedSearch P b -> P b x = false.

Lemma boundedSearch2 :
 forall (P : naryRel 2) (b : nat),
 boundedSearch P b = b \/ P b (boundedSearch P b) = true.

Lemma boundSearchIsPR :
 forall P : naryRel 2,
 isPRrel 2 P -> isPR 1 (fun b : nat => boundedSearch P b).

Definition iterate (g : nat -> nat) :=
  nat_rec (fun _ => nat -> nat) (fun x : nat => x)
    (fun (_ : nat) (rec : nat -> nat) (x : nat) => g (rec x)).

Lemma iterateIsPR :
 forall g : nat -> nat, isPR 1 g -> forall n : nat, isPR 1 (iterate g n). *)

Require Import Arith.

Require Import PA.

Require Import NNtheory.
(* NNtheory:
Require Import Arith.

Require Import folLogic3.
Require Import folProp.
Require Import subProp.
Require Export NN.

Lemma natNE :
 forall a b : nat,
 a <> b -> SysPrf NN (notH (equal (natToTerm a) (natToTerm b))).

Lemma natLE :
 forall a b : nat,
 b <= a -> SysPrf NN (notH (LT (natToTerm a) (natToTerm b))).

Lemma natLT :
 forall a b : nat, a < b -> SysPrf NN (LT (natToTerm a) (natToTerm b)).

Lemma natPlus :
 forall a b : nat,
 SysPrf NN (equal (Plus (natToTerm a) (natToTerm b)) (natToTerm (a + b))).

Lemma natTimes :
 forall a b : nat,
 SysPrf NN (equal (Times (natToTerm a) (natToTerm b)) (natToTerm (a * b))).

Lemma boundedLT :
 forall (m : nat) (a : Formula) (x : nat),
 (forall n : nat,
  n < m -> SysPrf NN (substituteFormula LNN a x (natToTerm n))) ->
 SysPrf NN (impH (LT (var x) (natToTerm m)) a).

Lemma nnPlusNotNeeded :
 forall n : nat,
 SysPrf NN
   (impH (orH (LT (var 1) (natToTerm n)) (equal (var 1) (natToTerm n)))
      (LT (var 1) (Succ (natToTerm n)))). *)

Require Import codeList.
(* codeList:
Require Import primRec.
Require Import cPair.
Require Export Coq.Lists.List.
Require Import ListExt.
Require Import Arith.
Require Vector.
Require Import extEqualNat.

Definition codeLength : nat -> nat :=
  evalStrongRec 0
    (fun n Hrecs : nat =>
     switchPR n (S (codeNth (n - S (cPairPi2 (pred n))) Hrecs)) 0).

Lemma codeLengthCorrect :
 forall l : list nat, codeLength (codeList l) = length l.

Lemma codeLengthIsPR : isPR 1 codeLength.

Definition codeApp : nat -> nat -> nat :=
  evalStrongRec 1
    (fun n Hrecs p1 : nat =>
     switchPR n
       (S
          (cPair (cPairPi1 (pred n))
             (codeNth (n - S (cPairPi2 (pred n))) Hrecs))) p1).

Lemma codeAppCorrect :
 forall l1 l2 : list nat,
 codeApp (codeList l1) (codeList l2) = codeList (l1 ++ l2).

Lemma codeAppIsPR : isPR 2 codeApp.

Definition codeListRemove (a l : nat) : nat :=
  evalStrongRec 1
    (fun n Hrecs p1 : nat =>
     switchPR n
       (switchPR (charFunction 2 beq_nat (cPairPi1 (pred n)) p1)
          (codeNth (n - S (cPairPi2 (pred n))) Hrecs)
          (S
             (cPair (cPairPi1 (pred n))
                (codeNth (n - S (cPairPi2 (pred n))) Hrecs)))) 
       (codeList nil)) l a.

Lemma codeListRemoveCorrect :
 forall (a : nat) (l : list nat),
 codeListRemove a (codeList l) = codeList (list_remove nat eq_nat_dec a l).

Lemma codeListRemoveIsPR : isPR 2 codeListRemove.

Definition codeIn (a l : nat) : nat :=
  evalStrongRec 1
    (fun n Hrecs p1 : nat =>
     switchPR n
       (switchPR (charFunction 2 beq_nat (cPairPi1 (pred n)) p1) 1
          (codeNth (n - S (cPairPi2 (pred n))) Hrecs)) 0) l a.

Lemma codeInCorrect :
 forall (a : nat) (l : list nat),
 codeIn a (codeList l) =
 match In_dec eq_nat_dec a l with
 | left _ => 1
 | right _ => 0
 end.

Lemma codeInIsPR : isPR 2 codeIn.

Definition codeNoDup : nat -> nat :=
  evalStrongRec 0
    (fun l recs : nat =>
     switchPR l
       (switchPR
          (codeIn (cPairPi1 (pred l))
             (codeNth (l - S (cPairPi2 (pred l))) recs))
          (codeNth (l - S (cPairPi2 (pred l))) recs)
          (S
             (cPair (cPairPi1 (pred l))
                (codeNth (l - S (cPairPi2 (pred l))) recs)))) 0).

Lemma codeNoDupCorrect :
 forall l : list nat,
 codeNoDup (codeList l) = codeList (no_dup _ eq_nat_dec l).

Lemma codeNoDupIsPR : isPR 1 codeNoDup. *)

Require Import subProp.
(* subProp:
Require Import Ensembles.
Require Import Coq.Lists.List.
Require Import Peano_dec.
Require Import ListExt.
Require Import Arith.

Require Import folProof.
Require Import folLogic.
Require Import folProp.
Require Import folReplace.

Section Substitution_Properties.

Variable L : Language.
Let Formula := Formula L.
Let Formulas := Formulas L.
Let System := System L.
Let Term := Term L.
Let Terms := Terms L.
Let var := var L.
Let apply := apply L.
Let equal := equal L.
Let atomic := atomic L.
Let impH := impH L.
Let notH := notH L.
Let forallH := forallH L.
Let orH := orH L.
Let andH := andH L.
Let existH := existH L.
Let iffH := iffH L.
Let SysPrf := SysPrf L.

Lemma freeVarSubTerm1 :
 forall (t : Term) (v : nat) (s : Term) (x : nat),
 In x (freeVarTerm L t) ->
 v <> x -> In x (freeVarTerm L (substituteTerm L t v s)).

Lemma freeVarSubTerms1 :
 forall (n : nat) (ts : Terms n) (v : nat) (s : Term) (x : nat),
 In x (freeVarTerms L n ts) ->
 v <> x -> In x (freeVarTerms L n (substituteTerms L n ts v s)).

Lemma freeVarSubFormula1 :
 forall (f : Formula) (v : nat) (s : Term) (x : nat),
 v <> x ->
 In x (freeVarFormula L f) ->
 In x (freeVarFormula L (substituteFormula L f v s)).

Lemma freeVarSubTerm2 :
 forall (t : Term) (v : nat) (s : Term) (x : nat),
 In x (freeVarTerm L s) ->
 In v (freeVarTerm L t) -> In x (freeVarTerm L (substituteTerm L t v s)).

Lemma freeVarSubTerms2 :
 forall (n : nat) (ts : Terms n) (v : nat) (s : Term) (x : nat),
 In x (freeVarTerm L s) ->
 In v (freeVarTerms L n ts) ->
 In x (freeVarTerms L n (substituteTerms L n ts v s)).

Lemma freeVarSubFormula2 :
 forall (f : Formula) (v : nat) (s : Term) (x : nat),
 In x (freeVarTerm L s) ->
 In v (freeVarFormula L f) ->
 In x (freeVarFormula L (substituteFormula L f v s)).

Lemma freeVarSubTerm3 :
 forall (t : Term) (v : nat) (s : Term) (x : nat),
 In x (freeVarTerm L (substituteTerm L t v s)) ->
 In x (list_remove _ eq_nat_dec v (freeVarTerm L t)) \/
 In x (freeVarTerm L s).

Lemma freeVarSubTerms3 :
 forall (n : nat) (ts : fol.Terms L n) (v : nat) (s : Term) (x : nat),

Lemma freeVarSubFormula3 :
 forall (f : Formula) (v : nat) (s : Term) (x : nat),
 In x (freeVarFormula L (substituteFormula L f v s)) ->
 In x (list_remove _ eq_nat_dec v (freeVarFormula L f)) \/
 In x (freeVarTerm L s).

Lemma freeVarSubTerm4 :
 forall (t : Term) (v : nat) (s : Term) (x : nat),
 In x (freeVarTerm L (substituteTerm L t v s)) ->
 ~ In v (freeVarTerm L t) -> In x (freeVarTerm L t).

Lemma freeVarSubTerms4 :
 forall (n : nat) (ts : Terms n) (v : nat) (s : Term) (x : nat),
 In x (freeVarTerms L n (substituteTerms L n ts v s)) ->
 ~ In v (freeVarTerms L n ts) -> In x (freeVarTerms L n ts).

Lemma freeVarSubFormula4 :
 forall (f : Formula) (v : nat) (s : Term) (x : nat),
 In x (freeVarFormula L (substituteFormula L f v s)) ->
 ~ In v (freeVarFormula L f) -> In x (freeVarFormula L f).

Lemma subTermNil :
 forall (t : Term) (v : nat) (s : Term),
 ~ In v (freeVarTerm L t) -> substituteTerm L t v s = t.

Lemma subTermTrans :
 forall (t : Term) (v1 v2 : nat) (s : Term),
 ~ In v2 (list_remove _ eq_nat_dec v1 (freeVarTerm L t)) ->
 substituteTerm L (substituteTerm L t v1 (var v2)) v2 s =
 substituteTerm L t v1 s.

Lemma subTermExch :
 forall (t : Term) (v1 v2 : nat) (s1 s2 : Term),
 v1 <> v2 ->
 ~ In v2 (freeVarTerm L s1) ->
 ~ In v1 (freeVarTerm L s2) ->
 substituteTerm L (substituteTerm L t v1 s1) v2 s2 =
 substituteTerm L (substituteTerm L t v2 s2) v1 s1.

Lemma subTermsNil :
 forall (n : nat) (ts : Terms n) (v : nat) (s : Term),
 ~ In v (freeVarTerms L n ts) -> substituteTerms L n ts v s = ts.

Lemma subTermsTrans :
 forall (n : nat) (ts : Terms n) (v1 v2 : nat) (s : Term),
 ~ In v2 (list_remove _ eq_nat_dec v1 (freeVarTerms L n ts)) ->
 substituteTerms L n (substituteTerms L n ts v1 (var v2)) v2 s =
 substituteTerms L n ts v1 s.

Lemma subTermsExch :
 forall (n : nat) (ts : Terms n) (v1 v2 : nat) (s1 s2 : Term),
 v1 <> v2 ->
 ~ In v2 (freeVarTerm L s1) ->
 ~ In v1 (freeVarTerm L s2) ->
 substituteTerms L n (substituteTerms L n ts v1 s1) v2 s2 =
 substituteTerms L n (substituteTerms L n ts v2 s2) v1 s1.

Remark subFormulaNTEHelp :
 forall (f g : Formula) (v : nat) (s : Term),
 SysPrf (Ensembles.Add _ (Empty_set Formula) f) g ->

Remark subFormulaNTE :
 forall (f : Formula) (T : System),
 (forall (v : nat) (s : Term),
  ~ In v (freeVarFormula L f) ->
  SysPrf T (iffH (substituteFormula L f v s) f)) /\
 (forall (v1 v2 : nat) (s : Term),
  ~ In v2 (list_remove _ eq_nat_dec v1 (freeVarFormula L f)) ->
  SysPrf T
    (iffH (substituteFormula L (substituteFormula L f v1 (var v2)) v2 s)
       (substituteFormula L f v1 s))) /\
 (forall (v1 v2 : nat) (s1 s2 : Term),
  v1 <> v2 ->
  ~ In v2 (freeVarTerm L s1) ->
  ~ In v1 (freeVarTerm L s2) ->
  SysPrf T
    (iffH (substituteFormula L (substituteFormula L f v1 s1) v2 s2)
       (substituteFormula L (substituteFormula L f v2 s2) v1 s1))).

Lemma subFormulaNil :
 forall (f : Formula) (T : System) (v : nat) (s : Term),
 ~ In v (freeVarFormula L f) -> SysPrf T (iffH (substituteFormula L f v s) f).

Lemma subFormulaTrans :
 forall (f : Formula) (T : System) (v1 v2 : nat) (s : Term),
 ~ In v2 (list_remove _ eq_nat_dec v1 (freeVarFormula L f)) ->
 SysPrf T
   (iffH (substituteFormula L (substituteFormula L f v1 (var v2)) v2 s)
      (substituteFormula L f v1 s)).

Lemma subFormulaExch :
 forall (f : Formula) (T : System) (v1 v2 : nat) (s1 s2 : Term),
 v1 <> v2 ->
 ~ In v2 (freeVarTerm L s1) ->
 ~ In v1 (freeVarTerm L s2) ->
 SysPrf T
   (iffH (substituteFormula L (substituteFormula L f v1 s1) v2 s2)
      (substituteFormula L (substituteFormula L f v2 s2) v1 s1)).

End Substitution_Properties. *)

Require Import ListExt.
(* ListExt:
Require Import Coq.Lists.List.

Section List_Remove.

Variable A : Set.
Hypothesis Aeq_dec : forall a b : A, {a = b} + {a <> b}.

Definition list_remove (x : A) (l : list A) : list A :=
  list_rec (fun _ => list A) nil
    (fun (a : A) _ (recl : list A) =>
     match Aeq_dec a x with
     | left _ => recl
     | right _ => a :: recl
     end) l.

Lemma In_list_remove1 :
 forall (a b : A) (l : list A), In a (list_remove b l) -> In a l.

Lemma In_list_remove2 :
 forall (a b : A) (l : list A), In a (list_remove b l) -> a <> b.

Lemma In_list_remove3 :
 forall (a b : A) (l : list A), In a l -> a <> b -> In a (list_remove b l).

End List_Remove.

Section No_Duplicate.

Variable A : Set.
Hypothesis Aeq_dec : forall a b : A, {a = b} + {a <> b}.

Definition no_dup (l : list A) : list A :=
  list_rec (fun _ => list A) nil
    (fun (a : A) _ (rec : list A) =>
     match In_dec Aeq_dec a rec with
     | left _ => rec
     | right _ => a :: rec
     end) l.

Lemma no_dup1 : forall (a : A) (l : list A), In a l -> In a (no_dup l).

Lemma no_dup2 : forall (a : A) (l : list A), In a (no_dup l) -> In a l.

Lemma no_dup3 : forall (k l : list A) (a : A), no_dup k = a :: l -> ~ In a l.

End No_Duplicate. *)

Require Import cPair.
(* cPair:
Require Import Arith.
Require Import Coq.Lists.List.
Require Import extEqualNat.
Require Import primRec.
Require Vector.
Require Import Div2.

Definition sumToN (n : nat) :=
  nat_rec (fun _ => nat) 0 (fun x y : nat => S x + y) n.

Lemma sumToN1 : forall n : nat, n <= sumToN n.

Lemma sumToN2 : forall b a : nat, a <= b -> sumToN a <= sumToN b.

Lemma sumToNIsPR : isPR 1 sumToN.

Definition cPair (a b : nat) := a + sumToN (a + b).

Lemma cPairIsPR : isPR 2 cPair.

Section CPair_Injectivity.

Remark cPairInjHelp :
 forall a b c d : nat, cPair a b = cPair c d -> a + b = c + d.

Lemma cPairInj1 : forall a b c d : nat, cPair a b = cPair c d -> a = c.

Lemma cPairInj2 : forall a b c d : nat, cPair a b = cPair c d -> b = d.

End CPair_Injectivity.

Section CPair_projections.

Let searchXY (a : nat) :=
  boundedSearch (fun a y : nat => ltBool a (sumToN (S y))) a.

Definition cPairPi1 (a : nat) := a - sumToN (searchXY a).
Definition cPairPi2 (a : nat) := searchXY a - cPairPi1 a.

Lemma cPairProjectionsHelp :
 forall a b : nat, b < sumToN (S a) -> sumToN a <= b -> searchXY b = a.

Lemma cPairProjections : forall a : nat, cPair (cPairPi1 a) (cPairPi2 a) = a.

Remark searchXYIsPR : isPR 1 searchXY.

Lemma cPairPi1IsPR : isPR 1 cPairPi1.

Lemma cPairPi2IsPR : isPR 1 cPairPi2.

Lemma cPairProjections1 : forall a b : nat, cPairPi1 (cPair a b) = a.

Lemma cPairProjections2 : forall a b : nat, cPairPi2 (cPair a b) = b.

End CPair_projections.

Section CPair_Order.

Lemma cPairLe1 : forall a b : nat, a <= cPair a b.

Lemma cPairLe1A : forall a : nat, cPairPi1 a <= a.

Lemma cPairLe2 : forall a b : nat, b <= cPair a b.

Lemma cPairLe2A : forall a : nat, cPairPi2 a <= a.

Lemma cPairLe3 :
 forall a b c d : nat, a <= b -> c <= d -> cPair a c <= cPair b d.

Lemma cPairLt1 : forall a b : nat, a < cPair a (S b).

Lemma cPairLt2 : forall a b : nat, b < cPair (S a) b.

End CPair_Order.

Section code_nat_list.

Fixpoint codeList (l : list nat) : nat :=
  match l with
  | nil => 0
  | n :: l' => S (cPair n (codeList l'))
  end.

Lemma codeListInj : forall l m : list nat, codeList l = codeList m -> l = m.

Definition codeNth (n m : nat) : nat.

Let drop (n : nat) : forall (l : list nat), list nat.

Lemma codeNthCorrect :
 forall (n : nat) (l : list nat), codeNth n (codeList l) = nth n l 0.

Lemma codeNthIsPR : isPR 2 codeNth.

End code_nat_list.

Section Strong_Recursion.

Definition evalStrongRecHelp (n : nat) (f : naryFunc (S (S n))) :
  naryFunc (S n) :=
  evalPrimRecFunc n (evalComposeFunc n 0 (Vector.nil _) (codeList nil))
    (evalComposeFunc (S (S n)) 2
       (Vector.cons _ f _
          (Vector.cons _ (evalProjFunc (S (S n)) n (lt_S _ _ (lt_n_Sn _))) _
             (Vector.nil _))) (fun a b : nat => S (cPair a b))).

Definition evalStrongRec (n : nat) (f : naryFunc (S (S n))) :
  naryFunc (S n) :=
  evalComposeFunc (S n) 1
    (Vector.cons _ (fun z : nat => evalStrongRecHelp n f (S z)) _ (Vector.nil _))
    (fun z : nat => cPairPi1 (pred z)).

Lemma evalStrongRecIsPR :
 forall (n : nat) (f : naryFunc (S (S n))),
 isPR _ f -> isPR _ (evalStrongRec n f).

Lemma computeEvalStrongRecHelp :
 forall (n : nat) (f : naryFunc (S (S n))) (c : nat),
 evalStrongRecHelp n f (S c) =
 compose2 n (evalStrongRecHelp n f c)
   (fun a0 : nat =>
    evalComposeFunc n 2
      (Vector.cons (naryFunc n) (f c a0) 1

Let listValues (f : naryFunc 2) (n : nat) : list nat.

Lemma evalStrongRecHelp1 :
 forall (f : naryFunc 2) (n m : nat),
 m < n -> codeNth (n - S m) (evalStrongRecHelp _ f n) = evalStrongRec _ f m.

Lemma evalStrongRecHelpParam :
 forall (a n c : nat) (f : naryFunc (S (S (S a)))),
 extEqual a (evalStrongRecHelp (S a) f n c)
   (evalStrongRecHelp a (fun x y : nat => f x y c) n).

Lemma evalStrongRecHelp2 :
 forall (a : nat) (f : naryFunc (S (S a))) (n m : nat),
 m < n ->
 extEqual _
   (evalComposeFunc _ 1 (Vector.cons _ (evalStrongRecHelp _ f n) 0 (Vector.nil _))

Lemma callIsPR :
 forall g : nat -> nat,
 isPR 1 g -> isPR 2 (fun a recs : nat => codeNth (a - S (g a)) recs).

End Strong_Recursion.

Lemma div2IsPR : isPR 1 div2. *)

Require Import wellFormed.
(* wellFormed:
Require Import primRec.
Require Import cPair.
Require Import Arith.
Require Import code.
Require Import folProp.
Require Import extEqualNat.
Require Import codeList.

Section Well_Formed_Term.

Variable L : Language.
Variable codeF : Functions L -> nat.
Variable codeArityF : nat -> nat.
Hypothesis codeArityFIsPR : isPR 1 codeArityF.
Hypothesis
  codeArityFIsCorrect1 :
    forall f : Functions L, codeArityF (codeF f) = S (arity L (inr _ f)).
Hypothesis
  codeArityFIsCorrect2 :
    forall n : nat, codeArityF n <> 0 -> exists f : Functions L, codeF f = n.

Let Term := Term L.
Let Terms := Terms L.
Let var := var L.
Let apply := apply L.

Definition wellFormedTermTerms : nat -> nat :=
  evalStrongRec 0
    (fun t recs : nat =>
     cPair
       (switchPR (cPairPi1 t)
          (charFunction 2 beq_nat (codeArityF (pred (cPairPi1 t)))
             (S (codeLength (cPairPi2 t))) *
           cPairPi2 (codeNth (t - S (cPairPi2 t)) recs)) 1)
       (switchPR t
          (cPairPi1 (codeNth (t - S (cPairPi1 (pred t))) recs) *
           cPairPi2 (codeNth (t - S (cPairPi2 (pred t))) recs)) 1)).

Definition wellFormedTerm (t : nat) : nat := cPairPi1 (wellFormedTermTerms t).

Definition wellFormedTerms (ts : nat) : nat :=
  cPairPi2 (wellFormedTermTerms ts).

Lemma lengthTerms :
 forall (n : nat) (ts : Terms n), codeLength (codeTerms L codeF n ts) = n.

Lemma wellFormedTermCorrect1 :
 forall t : Term, wellFormedTerm (codeTerm L codeF t) = 1.

Lemma wellFormedTermsCorrect1 :
 forall (n : nat) (ts : Terms n),
 wellFormedTerms (codeTerms L codeF n ts) = 1.

Remark wellFormedTermTermsCorrect2 :
 forall n : nat,
 (wellFormedTerm n <> 0 -> exists t : Term, codeTerm L codeF t = n) /\
 (wellFormedTerms n <> 0 ->
  exists m : nat, (exists ts : Terms m, codeTerms L codeF m ts = n)).
Proof.
assert (multLemma1 : forall a b : nat, a * b <> 0 -> a <> 0).
unfold not in |- *; intros.
apply H.
rewrite H0.
simpl in |- *.
reflexivity.
assert (multLemma2 : forall a b : nat, a * b <> 0 -> b <> 0).
intros.
rewrite mult_comm in H.
eapply multLemma1.
apply H.
assert
 (forall m n : nat,
  n < m ->
  (wellFormedTerm n <> 0 -> exists t : Term, codeTerm L codeF t = n) /\
  (wellFormedTerms n <> 0 ->
   exists m : nat, (exists ts : Terms m, codeTerms L codeF m ts = n))).
intro.
induction m as [| m Hrecm].
intros.
elim (lt_not_le _ _ H).
apply le_O_n.
intros.
induction (le_lt_or_eq _ _ (lt_n_Sm_le _ _ H)).
apply Hrecm; auto.
unfold wellFormedTerm in |- *.
unfold wellFormedTerms in |- *.
unfold wellFormedTermTerms in |- *.
set
 (A :=
  fun t recs : nat =>
  cPair
    (switchPR (cPairPi1 t)
       (charFunction 2 beq_nat (codeArityF (pred (cPairPi1 t)))
          (S (codeLength (cPairPi2 t))) *
        cPairPi2 (codeNth (t - S (cPairPi2 t)) recs)) 1)
    (switchPR t
       (cPairPi1 (codeNth (t - S (cPairPi1 (pred t))) recs) *
        cPairPi2 (codeNth (t - S (cPairPi2 (pred t))) recs)) 1)) 
 in *.
unfold evalStrongRec, evalComposeFunc, evalOneParamList, evalList in |- *.
rewrite computeEvalStrongRecHelp.
unfold compose2, evalComposeFunc, evalOneParamList, evalList in |- *.
simpl in |- *.
rewrite cPairProjections1.
split.
unfold A at 1 in |- *.
rewrite cPairProjections1.
assert (cPair (cPairPi1 n) (cPairPi2 n) = n).
apply cPairProjections.
destruct (cPairPi1 n).
simpl in |- *.
intros.
exists (var (cPairPi2 n)).
transitivity (cPair 0 (cPairPi2 n)).
reflexivity.
assumption.
rewrite evalStrongRecHelp1.
simpl in |- *.
intros.
induction (eq_nat_dec (codeArityF n0) (S (codeLength (cPairPi2 n)))).
assert (wellFormedTerms (cPairPi2 n) <> 0).
eapply multLemma2.
apply H2.
assert (cPairPi2 n < m).
apply lt_le_trans with (cPair (S n0) (cPairPi2 n)).
apply cPairLt2.
rewrite H1.
rewrite H0.
apply le_n.
induction (Hrecm _ H4).
clear H5.
induction (H6 H3).
induction H5 as (x0, H5).
assert (codeArityF n0 <> 0).
unfold not in |- *; intros.
rewrite H7 in a.
discriminate a.
induction (codeArityFIsCorrect2 _ H7).
rewrite <- H8 in a.
rewrite codeArityFIsCorrect1 in a.
injection a.
clear a.
intro.
rewrite <- H5 in H9.
rewrite lengthTerms in H9.
cut (codeTerms L codeF x x0 = cPairPi2 n).
clear H5.
generalize x0.
clear x0.
rewrite <- H9.
intros.
exists (apply x1 x0).
transitivity (cPair (S n0) (cPairPi2 n)).
rewrite <- H8.
rewrite <- H5.
reflexivity.
assumption.
assumption.
rewrite beq_nat_not_refl in H2.
elim H2.
reflexivity.
assumption.
apply lt_le_trans with (cPair (S n0) (cPairPi2 n)).
apply cPairLt2.
rewrite H1.
apply le_n.
unfold A at 1 in |- *.
rewrite cPairProjections2.
destruct n.
simpl in |- *.
intros.
exists 0.
exists (Tnil L).
reflexivity.
repeat rewrite evalStrongRecHelp1.
simpl in |- *.
intros.
assert (cPairPi1 n < m).
rewrite <- H0.
apply le_lt_n_Sm.
apply le_trans with (cPair (cPairPi1 n) (cPairPi2 n)).
apply cPairLe1.
rewrite cPairProjections.
apply le_n.
assert (cPairPi2 n < m).
rewrite <- H0.
apply le_lt_n_Sm.
apply le_trans with (cPair (cPairPi1 n) (cPairPi2 n)).
apply cPairLe2.
rewrite cPairProjections.
apply le_n.
induction (Hrecm _ H2).
clear H5.
induction (Hrecm _ H3).
clear H5.
assert (wellFormedTerm (cPairPi1 n) <> 0).
eapply multLemma1.
apply H1.
assert (wellFormedTerms (cPairPi2 n) <> 0).
eapply multLemma2.

Lemma wellFormedTermCorrect2 :
 forall n : nat,
 wellFormedTerm n <> 0 -> exists t : Term, codeTerm L codeF t = n.

Lemma wellFormedTermsCorrect2 :
 forall n : nat,
 wellFormedTerms n <> 0 ->
 exists m : nat, (exists ts : Terms m, codeTerms L codeF m ts = n).

Remark wellFormedTermTermsIsPR : isPR 1 wellFormedTermTerms.

Lemma wellFormedTermIsPR : isPR 1 wellFormedTerm.

Lemma wellFormedTermsIsPR : isPR 1 wellFormedTerms.

Section Well_Formed_Formula.

Variable codeR : Relations L -> nat.
Variable codeArityR : nat -> nat.
Hypothesis codeArityRIsPR : isPR 1 codeArityR.
Hypothesis
  codeArityRIsCorrect1 :
    forall r : Relations L, codeArityR (codeR r) = S (arity L (inl _ r)).
Hypothesis
  codeArityRIsCorrect2 :
    forall n : nat, codeArityR n <> 0 -> exists r : Relations L, codeR r = n.

Let Formula := Formula L.
Let equal := equal L.
Let atomic := atomic L.
Let impH := impH L.
Let notH := notH L.
Let forallH := forallH L.

Definition wellFormedFormula : nat -> nat :=
  evalStrongRec 0
    (fun f recs : nat =>
     switchPR (cPairPi1 f)
       (switchPR (pred (cPairPi1 f))
          (switchPR (pred (pred (cPairPi1 f)))
             (switchPR (pred (pred (pred (cPairPi1 f))))
                (charFunction 2 beq_nat
                   (codeArityR (pred (pred (pred (pred (cPairPi1 f))))))
                   (S (codeLength (cPairPi2 f))) *
                 wellFormedTerms (cPairPi2 f))
                (codeNth (f - S (cPairPi2 (cPairPi2 f))) recs))
             (codeNth (f - S (cPairPi2 f)) recs))
          (codeNth (f - S (cPairPi1 (cPairPi2 f))) recs *
           codeNth (f - S (cPairPi2 (cPairPi2 f))) recs))
       (wellFormedTerm (cPairPi1 (cPairPi2 f)) *
        wellFormedTerm (cPairPi2 (cPairPi2 f)))).

Lemma wellFormedFormulaCorrect1 :
 forall f : Formula, wellFormedFormula (codeFormula L codeF codeR f) = 1.

Lemma wellFormedFormulaCorrect2 :
 forall n : nat,
 wellFormedFormula n <> 0 ->
 exists f : Formula, codeFormula L codeF codeR f = n.
Proof.
assert (multLemma1 : forall a b : nat, a * b <> 0 -> a <> 0).
unfold not in |- *; intros.
apply H.
rewrite H0.
simpl in |- *.
reflexivity.
assert (multLemma2 : forall a b : nat, a * b <> 0 -> b <> 0).
intros.
rewrite mult_comm in H.
eapply multLemma1.
apply H.
assert
 (forall m n : nat,
  n < m ->
  wellFormedFormula n <> 0 ->
  exists f : Formula, codeFormula L codeF codeR f = n).
intro.
induction m as [| m Hrecm].
intros n H.
elim (lt_not_le _ _ H).
apply le_O_n.
intros n H.
induction (le_lt_or_eq _ _ (lt_n_Sm_le _ _ H)).
apply Hrecm; auto.
unfold wellFormedFormula in |- *.
set
 (A :=
  fun f recs : nat =>
  switchPR (cPairPi1 f)
    (switchPR (pred (cPairPi1 f))
       (switchPR (pred (pred (cPairPi1 f)))
          (switchPR (pred (pred (pred (cPairPi1 f))))
             (charFunction 2 beq_nat
                (codeArityR (pred (pred (pred (pred (cPairPi1 f))))))
                (S (codeLength (cPairPi2 f))) * wellFormedTerms (cPairPi2 f))
             (codeNth (f - S (cPairPi2 (cPairPi2 f))) recs))
          (codeNth (f - S (cPairPi2 f)) recs))
       (codeNth (f - S (cPairPi1 (cPairPi2 f))) recs *
        codeNth (f - S (cPairPi2 (cPairPi2 f))) recs))
    (wellFormedTerm (cPairPi1 (cPairPi2 f)) *
     wellFormedTerm (cPairPi2 (cPairPi2 f)))) in *.
unfold evalStrongRec, evalComposeFunc, evalOneParamList, evalList in |- *.
rewrite computeEvalStrongRecHelp.
unfold compose2, evalComposeFunc, evalOneParamList, evalList in |- *.
simpl in |- *.
rewrite cPairProjections1.
unfold A at 1 in |- *.
assert (cPair (cPairPi1 n) (cPairPi2 n) = n).
apply cPairProjections.
destruct (cPairPi1 n).
simpl in |- *.
intros.
assert (wellFormedTerm (cPairPi1 (cPairPi2 n)) <> 0).
eapply multLemma1.
apply H2.
assert (wellFormedTerm (cPairPi2 (cPairPi2 n)) <> 0).
eapply multLemma2.
apply H2.
induction (wellFormedTermCorrect2 _ H3).
induction (wellFormedTermCorrect2 _ H4).
exists (equal x x0).
simpl in |- *.
rewrite H5.
rewrite H6.
rewrite cPairProjections.
assumption.
destruct n0.
simpl in |- *.
assert (cPairPi2 n < m).
apply lt_le_trans with (cPair 1 (cPairPi2 n)).
apply cPairLt2.
rewrite H1.
rewrite H0.
apply le_n.
assert (cPairPi1 (cPairPi2 n) < m).
apply
 le_lt_trans with (cPair (cPairPi1 (cPairPi2 n)) (cPairPi2 (cPairPi2 n))).
apply cPairLe1.
rewrite cPairProjections.
assumption.
assert (cPairPi2 (cPairPi2 n) < m).
apply
 le_lt_trans with (cPair (cPairPi1 (cPairPi2 n)) (cPairPi2 (cPairPi2 n))).
apply cPairLe2.
rewrite cPairProjections.
assumption.
repeat rewrite evalStrongRecHelp1.
intros.
assert (evalStrongRec 0 A (cPairPi1 (cPairPi2 n)) <> 0).
eapply multLemma1.
apply H5.
assert (evalStrongRec 0 A (cPairPi2 (cPairPi2 n)) <> 0).
eapply multLemma2.
apply H5.
induction (Hrecm _ H3 H6).
induction (Hrecm _ H4 H7).
exists (impH x x0).
simpl in |- *.
rewrite H8.
rewrite H9.
rewrite cPairProjections.
assumption.
eapply lt_le_trans.
apply H4.
rewrite H0.
apply le_n.
eapply lt_le_trans.
apply H3.
rewrite H0.
apply le_n.
destruct n0.
simpl in |- *.
assert (cPairPi2 n < m).
apply lt_le_trans with (cPair 2 (cPairPi2 n)).
apply cPairLt2.
rewrite H1.
rewrite H0.
apply le_n.
repeat rewrite evalStrongRecHelp1.
intros.
induction (Hrecm _ H2 H3).
exists (notH x).
simpl in |- *.
rewrite H4.
assumption.
eapply lt_le_trans.
apply H2.
rewrite H0.
apply le_n.
destruct n0.
simpl in |- *.
assert (cPairPi2 n < m).
apply lt_le_trans with (cPair 3 (cPairPi2 n)).
apply cPairLt2.
rewrite H1.
rewrite H0.
apply le_n.
assert (cPairPi2 (cPairPi2 n) < m).
apply
 le_lt_trans with (cPair (cPairPi1 (cPairPi2 n)) (cPairPi2 (cPairPi2 n))).
apply cPairLe2.
rewrite cPairProjections.
assumption.
repeat rewrite evalStrongRecHelp1.
intros.
induction (Hrecm _ H3 H4).
exists (forallH (cPairPi1 (cPairPi2 n)) x).
simpl in |- *.
rewrite H5.
rewrite cPairProjections.
assumption.
eapply lt_le_trans.
apply H3.
rewrite H0.
apply le_n.
simpl in |- *.
induction (eq_nat_dec (codeArityR n0) (S (codeLength (cPairPi2 n)))).
assert (codeArityR n0 <> 0).
unfold not in |- *; intros.
rewrite H2 in a.
discriminate a.
induction (codeArityRIsCorrect2 _ H2).
intros.
assert (wellFormedTerms (cPairPi2 n) <> 0).
eapply multLemma2.

Lemma wellFormedFormulaIsPR : isPR 1 wellFormedFormula.

End Well_Formed_Formula.

End Well_Formed_Term. *)

Require Import prLogic.
(* prLogic:
Require Import primRec.
Require Import code.
Require Import Arith.
Require Import cPair.

Lemma codeForallIsPR : isPR 2 (fun a b : nat => cPair 3 (cPair a b)).

Lemma codeNotIsPR : isPR 1 codeNot.

Lemma codeImpIsPR : isPR 2 codeImp. *)



Ltac SimplFreeVar :=

  repeat

   match goal with

   | H1:(?X1 = ?X2),H2:(?X1 <> ?X2) |- _ =>

       elim H2; apply H1

   | H1:(?X1 = ?X2),H2:(?X2 <> ?X1) |- _ =>

       elim H2; symmetry  in |- *; apply H1

   | H1:(?X1 <> ?X1) |- _ =>

       elim H1; reflexivity

   | H:(In ?X3 (freeVarFormula ?X9 (existH ?X1 ?X2))) |- _ =>

       assert (In X3 (list_remove nat eq_nat_dec X1 (freeVarFormula X9 X2)));

        [ apply H | clear H ]

   | H:(In ?X3 (freeVarFormula ?X9 (fol.existH ?X9 ?X1 ?X2))) |- _ =>

       assert (In X3 (list_remove nat eq_nat_dec X1 (freeVarFormula X9 X2)));

        [ apply H | clear H ]

   | H:(In ?X3 (freeVarFormula ?X9 (forallH ?X1 ?X2))) |- _ =>

       assert (In X3 (list_remove nat eq_nat_dec X1 (freeVarFormula X9 X2)));

        [ apply H | clear H ]

   | H:(In ?X3 (freeVarFormula ?X9 (fol.forallH ?X9 ?X1 ?X2))) |- _ =>

       assert (In X3 (list_remove nat eq_nat_dec X1 (freeVarFormula X9 X2)));

        [ apply H | clear H ]

   | H:(In ?X3 (list_remove nat eq_nat_dec ?X1 (freeVarFormula ?X9 ?X2))) |-

   _ =>

       assert (In X3 (freeVarFormula X9 X2));

        [ eapply In_list_remove1; apply H

        | assert (X3 <> X1); [ eapply In_list_remove2; apply H | clear H ] ]

   | H:(In ?X3 (freeVarFormula ?X9 (andH ?X1 ?X2))) |- _ =>

       assert (In X3 (freeVarFormula X9 X1 ++ freeVarFormula X9 X2));

        [ apply H | clear H ]

   | H:(In ?X3 (freeVarFormula ?X9 (fol.andH ?X9 ?X1 ?X2))) |- _ =>

       assert (In X3 (freeVarFormula X9 X1 ++ freeVarFormula X9 X2));

        [ apply H | clear H ]

   | H:(In ?X3 (freeVarFormula ?X9 (orH ?X1 ?X2))) |- _ =>

       assert (In X3 (freeVarFormula X9 X1 ++ freeVarFormula X9 X2));

        [ apply H | clear H ]

   | H:(In ?X3 (freeVarFormula ?X9 (fol.orH ?X9 ?X1 ?X2))) |- _ =>

       assert (In X3 (freeVarFormula X9 X1 ++ freeVarFormula X9 X2));

        [ apply H | clear H ]

   | H:(In ?X3 (freeVarFormula ?X9 (impH ?X1 ?X2))) |- _ =>

       assert (In X3 (freeVarFormula X9 X1 ++ freeVarFormula X9 X2));

        [ apply H | clear H ]

   | H:(In ?X3 (freeVarFormula ?X9 (fol.impH ?X9 ?X1 ?X2))) |- _ =>

       assert (In X3 (freeVarFormula X9 X1 ++ freeVarFormula X9 X2));

        [ apply H | clear H ]

   | H:(In ?X3 (freeVarFormula ?X9 (notH ?X1))) |- _ =>

       assert (In X3 (freeVarFormula X9 X1)); [ apply H | clear H ]

   | H:(In ?X3 (freeVarFormula ?X9 (fol.notH ?X9 ?X1))) |- _ =>

       assert (In X3 (freeVarFormula X9 X1)); [ apply H | clear H ]

   | H:(In _ (_ ++ _)) |- _ =>

       induction (in_app_or _ _ _ H); clear H

   | H:(In _ (freeVarFormula ?X9 (substituteFormula ?X9 ?X1 ?X2 ?X3))) |- _

   =>

       induction (freeVarSubFormula3 _ _ _ _ _ H); clear H

   | H:(In _ (freeVarFormula ?X9 (LT ?X1 ?X2))) |- _ =>

       rewrite freeVarLT in H

   | H:(In _ (freeVarTerm ?X9 (LNT.natToTerm _))) |- _ =>

       elim (LNT.closedNatToTerm _ _ H)

   | H:(In _ (freeVarTerm ?X9 (natToTerm _))) |- _ =>

       elim (closedNatToTerm _ _ H)

   | H:(In _ (freeVarTerm ?X9 Zero)) |- _ =>

       elim H

   | H:(In _ (freeVarTerm ?X9 (Succ _))) |- _ =>

       rewrite freeVarSucc in H

   | H:(In _ (freeVarTerm ?X9 (var _))) |- _ =>

       simpl in H; decompose sum H; clear H

   | H:(In _ (freeVarTerm ?X9 (LNT.var _))) |- _ =>

       simpl in H; decompose sum H; clear H

   | H:(In _ (freeVarTerm ?X9 (fol.var ?X9 _))) |- _ =>

       simpl in H; decompose sum H; clear H

   end.



Section code_SysPrf.



Variable L : Language.

Variable codeF : Functions L -> nat.

Variable codeR : Relations L -> nat.

Variable codeArityF : nat -> nat.

Variable codeArityR : nat -> nat.

Hypothesis codeArityFIsPR : isPR 1 codeArityF.

Hypothesis

  codeArityFIsCorrect1 :

    forall f : Functions L, codeArityF (codeF f) = S (arity L (inr _ f)).

Hypothesis

  codeArityFIsCorrect2 :

    forall n : nat, codeArityF n <> 0 -> exists f : Functions L, codeF f = n.

Hypothesis codeArityRIsPR : isPR 1 codeArityR.

Hypothesis

  codeArityRIsCorrect1 :

    forall r : Relations L, codeArityR (codeR r) = S (arity L (inl _ r)).

Hypothesis

  codeArityRIsCorrect2 :

    forall n : nat, codeArityR n <> 0 -> exists r : Relations L, codeR r = n.



Hypothesis codeFInj : forall f g : Functions L, codeF f = codeF g -> f = g.

Hypothesis codeRInj : forall R S : Relations L, codeR R = codeR S -> R = S.



Section LNN.



Variable T : System.

Hypothesis TextendsNN : Included _ NN T.

Variable U : fol.System L.

Variable fU : Formula.

Variable v0 : nat.

Hypothesis freeVarfU : forall v : nat, In v (freeVarFormula LNN fU) -> v = v0.

Hypothesis

  expressU1 :

    forall f : fol.Formula L,

    mem _ U f ->

    SysPrf T

      (substituteFormula LNN fU v0 (natToTerm (codeFormula L codeF codeR f))).

Hypothesis

  expressU2 :

    forall f : fol.Formula L,

    ~ mem _ U f ->

    SysPrf T

      (notH

         (substituteFormula LNN fU v0

            (natToTerm (codeFormula L codeF codeR f)))).



Definition codeSysPrf : Formula :=

  let nv := newVar (2 :: 1 :: 0 :: v0 :: nil) in

  existH nv

    (andH

       (substituteFormula LNN

          (substituteFormula LNN

             (primRecFormula 2

                (proj1_sig

                   (checkPrfIsPR L codeF codeR codeArityF codeArityR

                      codeArityFIsPR codeArityRIsPR))) 0 

             (Succ (var nv))) 2 (var 0))

       (forallH (S nv)

          (impH (LT (var (S nv)) (var nv))

             (orH

                (substituteFormula LNN

                   (substituteFormula LNN

                      (substituteFormula LNN

                         (primRecFormula 2 (proj1_sig codeInIsPR)) 2

                         (var (S nv))) 1 (var nv)) 0 Zero)

                (substituteFormula LNN fU v0 (var (S nv))))))).



Lemma codeSysPrfCorrect1 :

 forall (f : fol.Formula L) (A : list (fol.Formula L)) (p : Prf L A f),

 (forall g : fol.Formula L, In g A -> mem _ U g) ->

 SysPrf T

   (substituteFormula LNN

      (substituteFormula LNN codeSysPrf 0

         (natToTerm (codeFormula L codeF codeR f))) 1

      (natToTerm (codePrf L codeF codeR A f p))).

Proof.

intros.

unfold codeSysPrf in |- *.

set (nvl := 2 :: 1 :: 0 :: v0 :: nil) in *.

set (nv := newVar nvl) in *.

assert (nv <> 0).

unfold nv, not in |- *; intros; elim (newVar1 nvl).

rewrite H0; unfold nvl in |- *.

simpl in |- *; auto.

assert (nv <> 1).

unfold nv, not in |- *; intros; elim (newVar1 nvl).

rewrite H1; unfold nvl in |- *.

simpl in |- *; auto.

assert (nv <> 2).

unfold nv, not in |- *; intros; elim (newVar1 nvl).

rewrite H2; unfold nvl in |- *.

simpl in |- *; auto.

assert (nv <> v0).

unfold nv, not in |- *; intros; elim (newVar1 nvl).

rewrite H3; unfold nvl in |- *.

simpl in |- *; auto.

rewrite (subFormulaExist LNN).

induction (eq_nat_dec nv 0).

elim H0; assumption.

induction

 (In_dec eq_nat_dec nv

    (freeVarTerm LNN (natToTerm (codeFormula L codeF codeR f)))).

elim (closedNatToTerm _ _ a).

clear b b0.

rewrite (subFormulaExist LNN).

induction (eq_nat_dec nv 1).

elim H1; assumption.

induction

 (In_dec eq_nat_dec nv

    (freeVarTerm LNN (natToTerm (codePrf L codeF codeR A f p)))).

elim (closedNatToTerm _ _ a).

clear b b0.

apply existI with (natToTerm (codeList (map (codeFormula L codeF codeR) A))).

repeat rewrite (subFormulaAnd LNN).

apply andI.

apply sysExtend with NN.

apply TextendsNN.

set

 (B :=

  primRecFormula 2

    (proj1_sig

       (checkPrfIsPR L codeF codeR codeArityF codeArityR codeArityFIsPR

          codeArityRIsPR))) in *.

apply

 impE

  with

    (substituteFormula LNN

       (substituteFormula LNN

          (substituteFormula LNN (substituteFormula LNN B 0 (Succ (var nv)))

             2 (natToTerm (codeFormula L codeF codeR f))) 1

          (natToTerm (codePrf L codeF codeR A f p))) nv

       (natToTerm (codeList (map (codeFormula L codeF codeR) A)))).

apply iffE2.

repeat (apply (reduceSub LNN); [ apply closedNN | idtac ]).

apply (subFormulaTrans LNN).

unfold not in |- *; intros.

assert

 (In 0 (freeVarFormula LNN (substituteFormula LNN B 0 (Succ (var nv))))).

eapply In_list_remove1.

apply H4.

induction (freeVarSubFormula3 _ _ _ _ _ H5).

elim (In_list_remove2 _ _ _ _ _ H6).

reflexivity.

simpl in H6.

decompose sum H6.

auto.

apply

 impE

  with

    (substituteFormula LNN

       (substituteFormula LNN

          (substituteFormula LNN

             (substituteFormula LNN B 2

                (natToTerm (codeFormula L codeF codeR f))) 1

             (natToTerm (codePrf L codeF codeR A f p))) 0 

          (Succ (var nv))) nv

       (natToTerm (codeList (map (codeFormula L codeF codeR) A)))).

apply iffE2.

repeat (apply (reduceSub LNN); [ apply closedNN | idtac ]).

apply

 iffTrans

  with

    (substituteFormula LNN

       (substituteFormula LNN

          (substituteFormula LNN B 2

             (natToTerm (codeFormula L codeF codeR f))) 0 

          (Succ (var nv))) 1 (natToTerm (codePrf L codeF codeR A f p))).

repeat (apply (reduceSub LNN); [ apply closedNN | idtac ]).

apply (subFormulaExch LNN).

discriminate.

simpl in |- *.

unfold not in |- *; intros.

decompose sum H4.

apply H2; assumption.

apply closedNatToTerm.

apply (subFormulaExch LNN).

discriminate.

simpl in |- *.

unfold not in |- *; intros.

decompose sum H4.

apply H1; assumption.

apply closedNatToTerm.

unfold B in |- *.

clear B.

assert

 (Representable NN 2 (checkPrf L codeF codeR codeArityF codeArityR)

    (primRecFormula 2

       (proj1_sig

          (checkPrfIsPR L codeF codeR codeArityF codeArityR codeArityFIsPR

             codeArityRIsPR)))).

apply primRecRepresentable.

induction H4 as (H4, H5).

set

 (F :=

  primRecFormula 2

    (proj1_sig

       (checkPrfIsPR L codeF codeR codeArityF codeArityR codeArityFIsPR

          codeArityRIsPR))) in *.

simpl in H5.

apply

 impE

  with

    (substituteFormula LNN

       (substituteFormula LNN

          (equal (var 0)

             (natToTerm

                (checkPrf L codeF codeR codeArityF codeArityR

                   (codeFormula L codeF codeR f)

                   (codePrf L codeF codeR A f p)))) 0 

          (Succ (var nv))) nv

       (natToTerm (codeList (map (codeFormula L codeF codeR) A)))).

apply iffE2.

repeat (apply (reduceSub LNN); [ apply closedNN | idtac ]).

apply H5.

rewrite (subFormulaEqual LNN).

rewrite (subTermVar1 LNN).

rewrite (subTermNil LNN).

rewrite (subFormulaEqual LNN).

replace

 (substituteTerm LNN (Succ (var nv)) nv

    (natToTerm (codeList (map (codeFormula L codeF codeR) A)))) with

 (natToTerm (S (codeList (map (codeFormula L codeF codeR) A)))).

rewrite (subTermNil LNN).

rewrite checkPrfCorrect1.

apply eqRefl.

apply codeArityFIsCorrect1.

apply codeArityRIsCorrect1.

apply closedNatToTerm.

generalize nv.

intro.

simpl in |- *.

induction (eq_nat_dec nv0 nv0).

reflexivity.

elim b.

reflexivity.

apply closedNatToTerm.

assert (S nv <> 1).

unfold not in |- *; intros.

elim (le_not_lt (S nv) 1).

rewrite H4.

apply le_n.

apply lt_S.

unfold nv in |- *.

apply newVar2.

unfold nvl in |- *; simpl in |- *; auto.

assert (S nv <> 2).

unfold not in |- *; intros.

elim (le_not_lt (S nv) 2).

rewrite H5.

apply le_n.

apply lt_S.

unfold nv in |- *.

apply newVar2.

unfold nvl in |- *; simpl in |- *; auto.

assert (S nv <> nv).

unfold not in |- *; intros.

eapply (n_Sn nv).

symmetry  in |- *; assumption.

rewrite (subFormulaForall LNN).

induction (eq_nat_dec (S nv) 0).

discriminate a.

induction

 (In_dec eq_nat_dec (S nv)

    (freeVarTerm LNN (natToTerm (codeFormula L codeF codeR f)))).

elim (closedNatToTerm _ _ a).

clear b b0.

rewrite (subFormulaForall LNN).

induction (eq_nat_dec (S nv) 1).

elim H4; assumption.

induction

 (In_dec eq_nat_dec (S nv)

    (freeVarTerm LNN (natToTerm (codePrf L codeF codeR A f p)))).

elim (closedNatToTerm _ _ a).

clear b b0.

rewrite (subFormulaForall LNN).

induction (eq_nat_dec (S nv) nv).

elim H6; assumption.

induction

 (In_dec eq_nat_dec (S nv)

    (freeVarTerm LNN

       (natToTerm (codeList (map (codeFormula L codeF codeR) A))))).

elim (closedNatToTerm _ _ a).

clear b b0.

repeat rewrite (subFormulaImp LNN).

replace

 (substituteFormula LNN

    (substituteFormula LNN

       (substituteFormula LNN (LT (var (S nv)) (var nv)) 0

          (natToTerm (codeFormula L codeF codeR f))) 1

       (natToTerm (codePrf L codeF codeR A f p))) nv

    (natToTerm (codeList (map (codeFormula L codeF codeR) A)))) with

 (LT (var (S nv)) (natToTerm (codeList (map (codeFormula L codeF codeR) A)))).

set

 (G :=

  list_rec (fun _ => Formula) (equal Zero Zero)

    (fun (a : fol.Formula L) _ (rec : Formula) =>

     andH

       (substituteFormula LNN fU v0 (natToTerm (codeFormula L codeF codeR a)))

       rec) A) in *.

assert (forall v : nat, ~ In v (freeVarFormula LNN G)).

unfold G in |- *.

intros.

generalize A.

intro.

induction A0 as [| a A0 HrecA0].

simpl in |- *.

auto.

simpl in |- *.

unfold not in |- *; intros.

induction (in_app_or _ _ _ H7).

induction (freeVarSubFormula3 _ _ _ _ _ H8).

absurd (v = v0).

eapply In_list_remove2.

apply H9.

apply freeVarfU.

eapply In_list_remove1.

apply H9.

elim (closedNatToTerm _ _ H9).

auto.

apply impE with G.

apply sysExtend with NN.

assumption.

apply impI.

assert (forall v : nat, ~ In_freeVarSys LNN v (Ensembles.Add (fol.Formula LNN) NN G)).

unfold not in |- *; intros.

induction H8 as (x, H8).

induction H8 as (H8, H9).

induction H9 as [x H9| x H9].

elim (closedNN v).

exists x.

auto.

induction H9.

apply (H7 v).

assumption.

apply forallI.

apply H8.

apply impI.

apply impE with G.

apply

 impE

  with

    (LT (var (S nv))

       (natToTerm (codeList (map (codeFormula L codeF codeR) A)))).

repeat simple apply sysWeaken.

apply boundedLT.

intros.

rewrite (subFormulaImp LNN).

apply impTrans with G.

apply iffE1.

apply (subFormulaNil LNN).

apply H7.

apply impI.

repeat rewrite (subFormulaOr LNN).

induction (In_dec eq_nat_dec n (map (codeFormula L codeF codeR) A)).

apply orI2.

apply impE with (substituteFormula LNN fU v0 (natToTerm n)).

apply iffE2.

apply sysWeaken.

assert

 (forall v : nat,

  ~ In v (list_remove nat eq_nat_dec v0 (freeVarFormula LNN fU))).

unfold not in |- *; intros.

absurd (v = v0).

eapply In_list_remove2.

apply H10.

apply freeVarfU.

eapply In_list_remove1.

apply H10.

apply

 iffTrans

  with

    (substituteFormula LNN

       (substituteFormula LNN

          (substituteFormula LNN (substituteFormula LNN fU v0 (var (S nv))) 1

             (natToTerm (codePrf L codeF codeR A f p))) nv

          (natToTerm (codeList (map (codeFormula L codeF codeR) A)))) 

       (S nv) (natToTerm n)).

repeat (apply (reduceSub LNN); [ apply closedNN | idtac ]).

apply (subFormulaNil LNN).

unfold not in |- *; intros.

induction (freeVarSubFormula3 _ _ _ _ _ H11).

apply (H10 0).

assumption.

simpl in H12.

decompose sum H12.

discriminate H13.

apply

 iffTrans

  with

    (substituteFormula LNN

       (substituteFormula LNN (substituteFormula LNN fU v0 (var (S nv))) nv

          (natToTerm (codeList (map (codeFormula L codeF codeR) A)))) 

       (S nv) (natToTerm n)).

repeat (apply (reduceSub LNN); [ apply closedNN | idtac ]).

apply (subFormulaNil LNN).

unfold not in |- *; intros.

induction (freeVarSubFormula3 _ _ _ _ _ H11).

apply (H10 1).

assumption.

simpl in H12.

decompose sum H12.

apply H4; assumption.

apply

 iffTrans

  with

    (substituteFormula LNN (substituteFormula LNN fU v0 (var (S nv))) 

       (S nv) (natToTerm n)).

repeat (apply (reduceSub LNN); [ apply closedNN | idtac ]).

apply (subFormulaNil LNN).

unfold not in |- *; intros.

induction (freeVarSubFormula3 _ _ _ _ _ H11).

apply (H10 nv).

assumption.

simpl in H12.

decompose sum H12.

apply H6; assumption.

apply (subFormulaTrans LNN).

unfold not in |- *; intros.

absurd (S nv = v0).

unfold not in |- *; intros.

elim (le_not_lt (S nv) v0).

rewrite H12.

apply le_n.

apply lt_S.

unfold nv in |- *.

apply newVar2.

unfold nvl in |- *; simpl in |- *; auto.

apply freeVarfU.

eapply In_list_remove1.

apply H11.

clear H9 H8 H7 H p.

induction A as [| a0 A HrecA].

elim a.

simpl in (value of G).

simpl in a.

induction a as [H| H].

unfold G in |- *.

rewrite H.

eapply andE1.

apply Axm; right; constructor.

apply

 impE

  with

    (list_rec (fun _ => Formula) (equal Zero Zero)

       (fun (a : fol.Formula L) (_ : list (fol.Formula L)) (rec : Formula) =>

        andH

          (substituteFormula LNN fU v0

             (natToTerm (codeFormula L codeF codeR a))) rec) A).

apply sysWeaken.

apply impI.

apply HrecA.

assumption.

eapply andE2.

unfold G in |- *.

apply Axm; right; constructor.

apply orI1.

assert (Representable NN 2 codeIn (primRecFormula 2 (proj1_sig codeInIsPR))).

apply primRecRepresentable.

induction H10 as (H10, H11).

set (J := primRecFormula 2 (proj1_sig codeInIsPR)) in *.

simpl in H11.

apply sysWeaken.

apply

 impE

  with

    (substituteFormula LNN

       (substituteFormula LNN (substituteFormula LNN J 2 (natToTerm n)) 1

          (natToTerm (codeList (map (codeFormula L codeF codeR) A)))) 0 Zero).

apply iffE2.

apply

 iffTrans

  with

    (substituteFormula LNN

       (substituteFormula LNN

          (substituteFormula LNN

             (substituteFormula LNN

                (substituteFormula LNN

                   (substituteFormula LNN J 2 (var (S nv))) 1 

                   (var nv)) 0 Zero) 1

             (natToTerm (codePrf L codeF codeR A f p))) nv

          (natToTerm (codeList (map (codeFormula L codeF codeR) A)))) 

       (S nv) (natToTerm n)).

repeat (apply (reduceSub LNN); [ apply closedNN | idtac ]).

apply (subFormulaNil LNN).

unfold not in |- *; intros.

induction (freeVarSubFormula3 _ _ _ _ _ H12).

elim (In_list_remove2 _ _ _ _ _ H13).

reflexivity.

apply H13.

apply

 iffTrans

  with

    (substituteFormula LNN

       (substituteFormula LNN

          (substituteFormula LNN

             (substituteFormula LNN (substituteFormula LNN J 2 (var (S nv)))

                1 (var nv)) 0 Zero) nv

          (natToTerm (codeList (map (codeFormula L codeF codeR) A)))) 

       (S nv) (natToTerm n)).

repeat (apply (reduceSub LNN); [ apply closedNN | idtac ]).

apply (subFormulaNil LNN).

unfold not in |- *; intros.

induction (freeVarSubFormula3 _ _ _ _ _ H12).

assert

 (In 1

    (freeVarFormula LNN

       (substituteFormula LNN (substituteFormula LNN J 2 (var (S nv))) 1

          (var nv)))).

eapply In_list_remove1.

apply H13.

induction (freeVarSubFormula3 _ _ _ _ _ H14).

elim (In_list_remove2 _ _ _ _ _ H15).

reflexivity.

simpl in H15.

decompose sum H15.

apply H1; assumption.

apply H13.

apply

 iffTrans

  with

    (substituteFormula LNN

       (substituteFormula LNN

          (substituteFormula LNN

             (substituteFormula LNN (substituteFormula LNN J 2 (var (S nv)))

                1 (var nv)) nv

             (natToTerm (codeList (map (codeFormula L codeF codeR) A)))) 0

          Zero) (S nv) (natToTerm n)).

repeat (apply (reduceSub LNN); [ apply closedNN | idtac ]).

apply (subFormulaExch LNN).

unfold not in |- *; intros; apply H0; symmetry  in |- *; assumption.

auto.

apply closedNatToTerm.

apply

 iffTrans

  with

    (substituteFormula LNN

       (substituteFormula LNN

          (substituteFormula LNN (substituteFormula LNN J 2 (var (S nv))) 1

             (natToTerm (codeList (map (codeFormula L codeF codeR) A)))) 0

          Zero) (S nv) (natToTerm n)).

repeat (apply (reduceSub LNN); [ apply closedNN | idtac ]).

apply (subFormulaTrans LNN).

unfold not in |- *; intros.

assert (In nv (freeVarFormula LNN (substituteFormula LNN J 2 (var (S nv))))).

eapply In_list_remove1.

apply H12.

induction (freeVarSubFormula3 _ _ _ _ _ H13).

apply (le_not_lt nv 2).

apply H10.

eapply In_list_remove1.

apply H14.

destruct nv as [| n0].

elim H0; reflexivity.

destruct n0.

elim H1; reflexivity.

destruct n0.

elim H2; reflexivity.

repeat apply lt_n_S.

apply lt_O_Sn.

simpl in H14.

decompose sum H14.

apply H6; assumption.

apply

 iffTrans

  with

    (substituteFormula LNN

       (substituteFormula LNN

          (substituteFormula LNN (substituteFormula LNN J 2 (var (S nv))) 1

             (natToTerm (codeList (map (codeFormula L codeF codeR) A))))

          (S nv) (natToTerm n)) 0 Zero).

apply (subFormulaExch LNN).

discriminate.

auto.

apply closedNatToTerm.

apply

 iffTrans

  with

    (substituteFormula LNN

       (substituteFormula LNN

          (substituteFormula LNN (substituteFormula LNN J 2 (var (S nv)))

             (S nv) (natToTerm n)) 1

          (natToTerm (codeList (map (codeFormula L codeF codeR) A)))) 0 Zero).

repeat (apply (reduceSub LNN); [ apply closedNN | idtac ]).

apply (subFormulaExch LNN).

unfold not in |- *; intros; apply H4; symmetry  in |- *; assumption.

apply closedNatToTerm.

apply closedNatToTerm.

repeat (apply (reduceSub LNN); [ apply closedNN | idtac ]).

apply (subFormulaTrans LNN).

unfold not in |- *; intros.

apply (le_not_lt (S nv) 2).

apply H10.

eapply In_list_remove1.

apply H12.

apply le_lt_n_Sm.

destruct nv as [| n0].

elim H0; reflexivity.

destruct n0.

elim H1; reflexivity.

repeat apply le_n_S.

apply le_O_n.

apply

 impE

  with

    (substituteFormula LNN

       (equal (var 0)

          (natToTerm

             (codeIn n (codeList (map (codeFormula L codeF codeR) A))))) 0

       Zero).

apply iffE2.

repeat (apply (reduceSub LNN); [ apply closedNN | idtac ]).

apply H11.

rewrite codeInCorrect.

induction (In_dec eq_nat_dec n (map (codeFormula L codeF codeR) A)).

elim b; assumption.

rewrite (subFormulaEqual LNN).

rewrite (subTermVar1 LNN).

rewrite (subTermNil LNN).

apply eqRefl.

apply closedNatToTerm.

apply Axm; right; constructor.

apply Axm; left; right; constructor.

clear p H7.

induction A as [| a A HrecA]; simpl in (value of G).

unfold G in |- *.

apply eqRefl.

simpl in H.

unfold G in |- *.

apply andI.

apply expressU1.

apply H.

auto.

apply HrecA.

intros.

apply H.

auto.

assert

 (forall (t1 t2 s : Term) (v : nat),

  substituteFormula LNN (LT t1 t2) v s =

  LT (substituteTerm LNN t1 v s) (substituteTerm LNN t2 v s)).

reflexivity.

repeat rewrite H7.

repeat rewrite (subTermVar1 LNN) || rewrite (subTermVar2 LNN);

 try unfold not in |- *; intros.

reflexivity.

apply H1; auto.

apply H0; auto.

apply H6; auto.

apply H4; auto.

discriminate H8.

Qed.



Lemma codeSysPrfCorrect2 :

 forall (f : fol.Formula L) (A : fol.Formulas L),

 (exists g : fol.Formula L, In g A /\ ~ mem _ U g) ->

 forall p : Prf L A f,

 SysPrf T

   (notH

      (substituteFormula LNN

         (substituteFormula LNN codeSysPrf 0

            (natToTerm (codeFormula L codeF codeR f))) 1

         (natToTerm (codePrf L codeF codeR A f p)))).

Proof.

intros.

unfold codeSysPrf in |- *.

set (nvl := 2 :: 1 :: 0 :: v0 :: nil) in *.

set (nv := newVar nvl) in *.

assert (nv <> 0).

unfold nv, not in |- *; intros; elim (newVar1 nvl).

rewrite H0; unfold nvl in |- *.

simpl in |- *; auto.

assert (nv <> 1).

unfold nv, not in |- *; intros; elim (newVar1 nvl).

rewrite H1; unfold nvl in |- *.

simpl in |- *; auto.

assert (nv <> 2).

unfold nv, not in |- *; intros; elim (newVar1 nvl).

rewrite H2; unfold nvl in |- *.

simpl in |- *; auto.

assert (nv <> v0).

unfold nv, not in |- *; intros; elim (newVar1 nvl).

rewrite H3; unfold nvl in |- *.

simpl in |- *; auto.

set

 (F :=

  primRecFormula 2

    (proj1_sig

       (checkPrfIsPR L codeF codeR codeArityF codeArityR codeArityFIsPR

          codeArityRIsPR))) in *.

set (J := primRecFormula 2 (proj1_sig codeInIsPR)) in *.

rewrite (subFormulaExist LNN).

induction (eq_nat_dec nv 0).

elim H0; assumption.

induction

 (In_dec eq_nat_dec nv

    (freeVarTerm LNN (natToTerm (codeFormula L codeF codeR f)))).

elim (closedNatToTerm _ _ a).

clear b b0.

rewrite (subFormulaExist LNN).

induction (eq_nat_dec nv 1).

elim H1; assumption.

induction

 (In_dec eq_nat_dec nv

    (freeVarTerm LNN (natToTerm (codePrf L codeF codeR A f p)))).

elim (closedNatToTerm _ _ a).

clear b b0.

repeat rewrite (subFormulaAnd LNN).

apply nExist.

set (n := codePrf L codeF codeR A f p) in *.

apply

 impE

  with

    (forallH nv

       (notH

          (fol.andH LNN

             (equal (Succ (var nv))

                (natToTerm

                   (checkPrf L codeF codeR codeArityF codeArityR

                      (codeFormula L codeF codeR f) n)))

             (substituteFormula LNN

                (substituteFormula LNN

                   (forallH (S nv)

                      (impH (LT (var (S nv)) (var nv))

                         (orH

                            (substituteFormula LNN

                               (substituteFormula LNN

                                  (substituteFormula LNN J 2 (var (S nv))) 1

                                  (var nv)) 0 Zero)

                            (substituteFormula LNN fU v0 (var (S nv)))))) 0

                   (natToTerm (codeFormula L codeF codeR f))) 1 

                (natToTerm n))))).

apply sysExtend with NN.

assumption.

apply iffE2.

apply (reduceForall LNN).

apply closedNN.

apply (reduceNot LNN).

apply (reduceAnd LNN).

apply

 iffTrans

  with

    (substituteFormula LNN

       (substituteFormula LNN

          (substituteFormula LNN F 2

             (natToTerm (codeFormula L codeF codeR f))) 1 

          (natToTerm n)) 0 (Succ (var nv))).

apply

 iffTrans

  with

    (substituteFormula LNN

       (substituteFormula LNN (substituteFormula LNN F 0 (Succ (var nv))) 2

          (natToTerm (codeFormula L codeF codeR f))) 1 

       (natToTerm n)).

repeat (apply (reduceSub LNN); [ apply closedNN | idtac ]).

apply (subFormulaTrans LNN).

unfold not in |- *; intros.

assert

 (In 0 (freeVarFormula LNN (substituteFormula LNN F 0 (Succ (var nv))))).

eapply In_list_remove1.

apply H4.

induction (freeVarSubFormula3 _ _ _ _ _ H5).

elim (In_list_remove2 _ _ _ _ _ H6).

reflexivity.

simpl in H6.

decompose sum H6.

apply H0; assumption.

apply

 iffTrans

  with

    (substituteFormula LNN

       (substituteFormula LNN

          (substituteFormula LNN F 2

             (natToTerm (codeFormula L codeF codeR f))) 0 

          (Succ (var nv))) 1 (natToTerm n)).

repeat (apply (reduceSub LNN); [ apply closedNN | idtac ]).

apply (subFormulaExch LNN).

discriminate.

unfold not in |- *; intros.

simpl in H4.

decompose sum H4.

apply H2; assumption.

apply closedNatToTerm.

apply (subFormulaExch LNN).

discriminate.

unfold not in |- *; intros.

simpl in H4.

decompose sum H4.

apply H1; assumption.

apply closedNatToTerm.

assert

 (Representable NN 2 (checkPrf L codeF codeR codeArityF codeArityR)

    (primRecFormula 2

       (proj1_sig

          (checkPrfIsPR L codeF codeR codeArityF codeArityR codeArityFIsPR

             codeArityRIsPR)))).

apply primRecRepresentable.

fold F in H4.

induction H4 as (H4, H5).

simpl in H5.

apply

 iffTrans

  with

    (substituteFormula LNN

       (equal (var 0)

          (natToTerm

             (checkPrf L codeF codeR codeArityF codeArityR

                (codeFormula L codeF codeR f) n))) 0 

       (Succ (var nv))).

repeat (apply (reduceSub LNN); [ apply closedNN | idtac ]).

apply H5.

rewrite (subFormulaEqual LNN).

rewrite (subTermVar1 LNN).

rewrite (subTermNil LNN).

apply iffRefl.

apply closedNatToTerm.

apply iffRefl.

unfold n in |- *.

rewrite checkPrfCorrect1.

decompose record H.

apply

 impE

  with

    (notH

       (substituteFormula LNN fU v0 (natToTerm (codeFormula L codeF codeR x)))).

apply sysExtend with NN.

assumption.

apply impI.

assert

 (forall v : nat,

  ~

  In v

    (freeVarFormula LNN

       (notH

          (substituteFormula LNN fU v0

             (natToTerm (codeFormula L codeF codeR x)))))).

unfold not in |- *; intros.

induction (freeVarSubFormula3 _ _ _ _ _ H4).

absurd (v = v0).

eapply In_list_remove2.

apply H7.

apply freeVarfU.

eapply In_list_remove1.

apply H7.

apply (closedNatToTerm _ _ H7).

assert

 (forall v : nat,

  ~

  In_freeVarSys LNN v

    (Ensembles.Add (fol.Formula LNN) NN

       (notH

          (substituteFormula LNN fU v0

             (natToTerm (codeFormula L codeF codeR x)))))).

unfold not in |- *; intros.

induction H7 as (x0, H7); induction H7 as (H7, H8).

induction H8 as [x0 H8| x0 H8].

elim (closedNN v).

exists x0.

auto.

induction H8.

apply (H4 v).

assumption.

apply forallI.

apply H7.

apply nAnd.

unfold orH at 1 in |- *.

unfold fol.orH in |- *.

apply

 impTrans

  with

    (equal (Succ (var nv))

       (natToTerm (S (codeList (map (codeFormula L codeF codeR) A))))).

apply impI.

apply nnE.

apply Axm; right; constructor.

apply impI.

rewrite <-

 (subFormulaId LNN

    (notH

       (substituteFormula LNN

          (substituteFormula LNN

             (forallH (S nv)

                (impH (LT (var (S nv)) (var nv))

                   (orH

                      (substituteFormula LNN

                         (substituteFormula LNN

                            (substituteFormula LNN J 2 (var (S nv))) 1

                            (var nv)) 0 Zero)

                      (substituteFormula LNN fU v0 (var (S nv)))))) 0

             (natToTerm (codeFormula L codeF codeR f))) 1

          (natToTerm (codePrf L codeF codeR A f p)))) nv)

 .

apply

 impE

  with

    (substituteFormula LNN

       (notH

          (substituteFormula LNN

             (substituteFormula LNN

                (forallH (S nv)

                   (impH (LT (var (S nv)) (var nv))

                      (orH

                         (substituteFormula LNN

                            (substituteFormula LNN

                               (substituteFormula LNN J 2 (var (S nv))) 1

                               (var nv)) 0 Zero)

                         (substituteFormula LNN fU v0 (var (S nv)))))) 0

                (natToTerm (codeFormula L codeF codeR f))) 1

             (natToTerm (codePrf L codeF codeR A f p)))) nv

       (natToTerm (codeList (map (codeFormula L codeF codeR) A)))).

apply (subWithEquals LNN).

apply eqSym.

apply

 impE

  with

    (fol.equal LNN (Succ (var nv))

       (natToTerm (S (codeList (map (codeFormula L codeF codeR) A))))).

apply sysWeaken.

fold var in |- *.

simpl in |- *.

apply sysWeaken.

apply nn2.

apply Axm; right; constructor.

apply sysWeaken.

assert (S nv <> 1).

unfold not in |- *; intros.

elim (le_not_lt (S nv) 1).

rewrite H8.

apply le_n.

apply lt_S.

unfold nv in |- *.

apply newVar2.

unfold nvl in |- *; simpl in |- *; auto.

assert (S nv <> 2).

unfold not in |- *; intros.

elim (le_not_lt (S nv) 2).

rewrite H9.

apply le_n.

apply lt_S.

unfold nv in |- *.

apply newVar2.

unfold nvl in |- *; simpl in |- *; auto.

assert (S nv <> nv).

unfold not in |- *; intros.

eapply (n_Sn nv).

symmetry  in |- *; assumption.

rewrite (subFormulaForall LNN).

induction (eq_nat_dec (S nv) 0).

discriminate a.

induction

 (In_dec eq_nat_dec (S nv)

    (freeVarTerm LNN (natToTerm (codeFormula L codeF codeR f)))).

elim (closedNatToTerm _ _ a).

clear b b0.

rewrite (subFormulaForall LNN).

induction (eq_nat_dec (S nv) 1).

elim H8; assumption.

induction

 (In_dec eq_nat_dec (S nv)

    (freeVarTerm LNN (natToTerm (codePrf L codeF codeR A f p)))).

elim (closedNatToTerm _ _ a).

clear b b0.

rewrite (subFormulaNot LNN).

rewrite (subFormulaForall LNN).

induction (eq_nat_dec (S nv) nv).

elim H10; assumption.

induction

 (In_dec eq_nat_dec (S nv)

    (freeVarTerm LNN

       (natToTerm (codeList (map (codeFormula L codeF codeR) A))))).

elim (closedNatToTerm _ _ a).

clear b b0.

apply nForall.

apply existI with (natToTerm (codeFormula L codeF codeR x)).

rewrite (subFormulaNot LNN).

repeat rewrite (subFormulaImp LNN).

apply nImp.

apply andI.

assert

 (forall (t1 t2 s : Term) (v : nat),

  substituteFormula LNN (LT t1 t2) v s =

  LT (substituteTerm LNN t1 v s) (substituteTerm LNN t2 v s)).

reflexivity.

repeat rewrite H11.

repeat rewrite (subTermVar1 LNN) || rewrite (subTermVar2 LNN);

 try unfold not in |- *; intros.

rewrite (subTermNil LNN).

apply sysWeaken.

apply natLT.

cut (In x A).

generalize x A.

intros.

induction A0 as [| a A0 HrecA0].

elim H12.

induction H12 as [H12| H12].

rewrite H12.

simpl in |- *.

apply le_lt_n_Sm.

apply cPairLe1.

apply lt_le_trans with (codeList (map (codeFormula L codeF codeR) A0)).

auto.

simpl in |- *.

apply le_S.

apply cPairLe2.

assumption.

apply closedNatToTerm.

apply H1; auto.

apply H0; auto.

apply H10; auto.

apply H8; auto.

discriminate H12.

repeat rewrite (subFormulaOr LNN).

apply nOr.

apply andI.

apply sysWeaken.

assert (Representable NN 2 codeIn J).

unfold J in |- *; apply primRecRepresentable.

induction H11 as (H11, H12).

apply

 impE

  with

    (notH

       (substituteFormula LNN

          (substituteFormula LNN

             (substituteFormula LNN J 2

                (natToTerm (codeFormula L codeF codeR x))) 1

             (natToTerm (codeList (map (codeFormula L codeF codeR) A)))) 0

          Zero)).

apply cp2.

apply iffE1.

apply

 iffTrans

  with

    (substituteFormula LNN

       (substituteFormula LNN

          (substituteFormula LNN

             (substituteFormula LNN

                (substituteFormula LNN

                   (substituteFormula LNN J 2 (var (S nv))) 1 

                   (var nv)) 0 Zero) 1

             (natToTerm (codePrf L codeF codeR A f p))) nv

          (natToTerm (codeList (map (codeFormula L codeF codeR) A)))) 

       (S nv) (natToTerm (codeFormula L codeF codeR x))).

repeat (apply (reduceSub LNN); [ apply closedNN | idtac ]).

apply (subFormulaNil LNN).

unfold not in |- *; intros.

induction (freeVarSubFormula3 _ _ _ _ _ H13).

elim (In_list_remove2 _ _ _ _ _ H14).

reflexivity.

apply H14.

apply

 iffTrans

  with

    (substituteFormula LNN

       (substituteFormula LNN

          (substituteFormula LNN

             (substituteFormula LNN

                (substituteFormula LNN

                   (substituteFormula LNN J 2 (var (S nv))) 1 

                   (var nv)) 1 (natToTerm (codePrf L codeF codeR A f p))) 0

             Zero) nv

          (natToTerm (codeList (map (codeFormula L codeF codeR) A)))) 

       (S nv) (natToTerm (codeFormula L codeF codeR x))).

repeat (apply (reduceSub LNN); [ apply closedNN | idtac ]).

apply (subFormulaExch LNN).

discriminate.

auto.

apply closedNatToTerm.

apply

 iffTrans

  with

    (substituteFormula LNN

       (substituteFormula LNN

          (substituteFormula LNN

             (substituteFormula LNN (substituteFormula LNN J 2 (var (S nv)))

                1 (var nv)) 0 Zero) nv

          (natToTerm (codeList (map (codeFormula L codeF codeR) A)))) 

       (S nv) (natToTerm (codeFormula L codeF codeR x))).

repeat (apply (reduceSub LNN); [ apply closedNN | idtac ]).

apply (subFormulaNil LNN).

unfold not in |- *; intros.

induction (freeVarSubFormula3 _ _ _ _ _ H13).

elim (In_list_remove2 _ _ _ _ _ H14).

reflexivity.

simpl in H14.

decompose sum H14.

apply H1; assumption.

apply

 iffTrans

  with

    (substituteFormula LNN

       (substituteFormula LNN

          (substituteFormula LNN

             (substituteFormula LNN (substituteFormula LNN J 2 (var (S nv)))

                1 (var nv)) nv

             (natToTerm (codeList (map (codeFormula L codeF codeR) A)))) 0

          Zero) (S nv) (natToTerm (codeFormula L codeF codeR x))).

repeat (apply (reduceSub LNN); [ apply closedNN | idtac ]).

apply (subFormulaExch LNN).

unfold not in |- *; intros.

apply H0; symmetry  in |- *; assumption.

auto.

apply closedNatToTerm.

apply

 iffTrans

  with

    (substituteFormula LNN

       (substituteFormula LNN

          (substituteFormula LNN (substituteFormula LNN J 2 (var (S nv))) 1

             (natToTerm (codeList (map (codeFormula L codeF codeR) A)))) 0

          Zero) (S nv) (natToTerm (codeFormula L codeF codeR x))).

repeat (apply (reduceSub LNN); [ apply closedNN | idtac ]).

apply (subFormulaTrans LNN).

unfold not in |- *; intros.

assert (In nv (freeVarFormula LNN (substituteFormula LNN J 2 (var (S nv))))).

eapply In_list_remove1.

apply H13.

induction (freeVarSubFormula3 _ _ _ _ _ H14).

apply (le_not_lt nv 2).

apply H11.

eapply In_list_remove1.

apply H15.

destruct nv as [| n0].

elim H0; reflexivity.

destruct n0.

elim H1; reflexivity.

destruct n0.

elim H2; reflexivity.

repeat apply lt_n_S.

apply lt_O_Sn.

simpl in H15.

decompose sum H15.

apply H10; assumption.

apply

 iffTrans

  with

    (substituteFormula LNN

       (substituteFormula LNN

          (substituteFormula LNN (substituteFormula LNN J 2 (var (S nv))) 1

             (natToTerm (codeList (map (codeFormula L codeF codeR) A))))

          (S nv) (natToTerm (codeFormula L codeF codeR x))) 0 Zero).

repeat (apply (reduceSub LNN); [ apply closedNN | idtac ]).

apply (subFormulaExch LNN).

discriminate.

auto.

apply closedNatToTerm.

apply

 iffTrans

  with

    (substituteFormula LNN

       (substituteFormula LNN

          (substituteFormula LNN (substituteFormula LNN J 2 (var (S nv)))

             (S nv) (natToTerm (codeFormula L codeF codeR x))) 1

          (natToTerm (codeList (map (codeFormula L codeF codeR) A)))) 0 Zero).

repeat (apply (reduceSub LNN); [ apply closedNN | idtac ]).

apply (subFormulaExch LNN).

unfold not in |- *; intros.

apply H8; symmetry  in |- *; assumption.

apply closedNatToTerm.

apply closedNatToTerm.

repeat (apply (reduceSub LNN); [ apply closedNN | idtac ]).

apply (subFormulaTrans LNN).

unfold not in |- *; intros.

apply (le_not_lt (S nv) 2).

apply H11.

eapply In_list_remove1.

apply H13.

destruct nv as [| n0].

elim H8; reflexivity.

destruct n0.

elim H9; reflexivity.

repeat apply lt_n_S.

apply lt_O_Sn.

simpl in H12.

apply

 impE

  with

    (notH

       (substituteFormula LNN

          (equal (var 0)

             (natToTerm

                (codeIn (codeFormula L codeF codeR x)

                   (codeList (map (codeFormula L codeF codeR) A))))) 0 Zero)).

apply cp2.

apply iffE1.

repeat (apply (reduceSub LNN); [ apply closedNN | idtac ]).

apply H12.

rewrite (subFormulaEqual LNN).

rewrite (subTermVar1 LNN).

rewrite (subTermNil LNN).

rewrite codeInCorrect.

induction

 (In_dec eq_nat_dec (codeFormula L codeF codeR x)

    (map (codeFormula L codeF codeR) A)).

replace Zero with (natToTerm 0).

apply natNE.

discriminate.

reflexivity.

elim b.

cut (In x A).

generalize A x.

intros.

induction A0 as [| a A0 HrecA0].

elim H13.

induction H13 as [H13| H13].

rewrite H13.

simpl in |- *.

auto.

simpl in |- *.

auto.

assumption.

apply closedNatToTerm.

apply

 impE

  with

    (notH

       (substituteFormula LNN fU v0 (natToTerm (codeFormula L codeF codeR x)))).

apply sysWeaken.

apply cp2.

apply iffE1.

assert

 (forall v : nat,

  ~ In v (list_remove nat eq_nat_dec v0 (freeVarFormula LNN fU))).

unfold not in |- *; intros.

absurd (v = v0).

eapply In_list_remove2.

apply H11.

apply freeVarfU.

eapply In_list_remove1.

apply H11.

apply

 iffTrans

  with

    (substituteFormula LNN

       (substituteFormula LNN

          (substituteFormula LNN (substituteFormula LNN fU v0 (var (S nv))) 1

             (natToTerm (codePrf L codeF codeR A f p))) nv

          (natToTerm (codeList (map (codeFormula L codeF codeR) A)))) 

       (S nv) (natToTerm (codeFormula L codeF codeR x))).

repeat (apply (reduceSub LNN); [ apply closedNN | idtac ]).

apply (subFormulaNil LNN).

unfold not in |- *; intros.

induction (freeVarSubFormula3 _ _ _ _ _ H12).

apply (H11 0).

assumption.

simpl in H13.

decompose sum H13.

discriminate H14.

apply

 iffTrans

  with

    (substituteFormula LNN

       (substituteFormula LNN (substituteFormula LNN fU v0 (var (S nv))) nv

          (natToTerm (codeList (map (codeFormula L codeF codeR) A)))) 

       (S nv) (natToTerm (codeFormula L codeF codeR x))).

repeat (apply (reduceSub LNN); [ apply closedNN | idtac ]).

apply (subFormulaNil LNN).

unfold not in |- *; intros.

induction (freeVarSubFormula3 _ _ _ _ _ H12).

apply (H11 1).

assumption.

simpl in H13.

decompose sum H13.

apply H8; assumption.

apply

 iffTrans

  with

    (substituteFormula LNN (substituteFormula LNN fU v0 (var (S nv))) 

       (S nv) (natToTerm (codeFormula L codeF codeR x))).

repeat (apply (reduceSub LNN); [ apply closedNN | idtac ]).

apply (subFormulaNil LNN).

unfold not in |- *; intros.

induction (freeVarSubFormula3 _ _ _ _ _ H12).

apply (H11 nv).

assumption.

simpl in H13.

decompose sum H13.

apply H10; assumption.

apply (subFormulaTrans LNN).

apply H11.

apply Axm; right; constructor.

apply expressU2.

assumption.

assumption.

assumption.

Qed.



Lemma codeSysPrfCorrect3 :

 forall (f : fol.Formula L) (n : nat),

 (forall (A : list (fol.Formula L)) (p : Prf L A f),

  n <> codePrf L codeF codeR A f p) ->

 SysPrf T

   (notH

      (substituteFormula LNN

         (substituteFormula LNN codeSysPrf 0

            (natToTerm (codeFormula L codeF codeR f))) 1 

         (natToTerm n))).

Proof.

intros.

unfold codeSysPrf in |- *.

set (nvl := 2 :: 1 :: 0 :: v0 :: nil) in *.

set (nv := newVar nvl) in *.

assert (nv <> 0).

unfold nv, not in |- *; intros; elim (newVar1 nvl).

rewrite H0; unfold nvl in |- *.

simpl in |- *; auto.

assert (nv <> 1).

unfold nv, not in |- *; intros; elim (newVar1 nvl).

rewrite H1; unfold nvl in |- *.

simpl in |- *; auto.

assert (nv <> 2).

unfold nv, not in |- *; intros; elim (newVar1 nvl).

rewrite H2; unfold nvl in |- *.

simpl in |- *; auto.

assert (nv <> v0).

unfold nv, not in |- *; intros; elim (newVar1 nvl).

rewrite H3; unfold nvl in |- *.

simpl in |- *; auto.

set

 (F :=

  primRecFormula 2

    (proj1_sig

       (checkPrfIsPR L codeF codeR codeArityF codeArityR codeArityFIsPR

          codeArityRIsPR))) in *.

set (J := primRecFormula 2 (proj1_sig codeInIsPR)) in *.

rewrite (subFormulaExist LNN).

induction (eq_nat_dec nv 0).

elim H0; assumption.

induction

 (In_dec eq_nat_dec nv

    (freeVarTerm LNN (natToTerm (codeFormula L codeF codeR f)))).

elim (closedNatToTerm _ _ a).

clear b b0.

rewrite (subFormulaExist LNN).

induction (eq_nat_dec nv 1).

elim H1; assumption.

induction (In_dec eq_nat_dec nv (freeVarTerm LNN (natToTerm n))).

elim (closedNatToTerm _ _ a).

clear b b0.

repeat rewrite (subFormulaAnd LNN).

apply nExist.

apply sysExtend with NN.

assumption.

apply forallI.

apply closedNN.

apply nAnd.

apply orI1.

apply

 impE

  with

    (notH

       (substituteFormula LNN

          (substituteFormula LNN

             (substituteFormula LNN F 2

                (natToTerm (codeFormula L codeF codeR f))) 1 

             (natToTerm n)) 0 (Succ (var nv)))).

apply cp2.

apply iffE1.

apply

 iffTrans

  with

    (substituteFormula LNN

       (substituteFormula LNN (substituteFormula LNN F 0 (Succ (var nv))) 2

          (natToTerm (codeFormula L codeF codeR f))) 1 

       (natToTerm n)).

repeat (apply (reduceSub LNN); [ apply closedNN | idtac ]).

apply (subFormulaTrans LNN).

unfold not in |- *; intros.

assert

 (In 0 (freeVarFormula LNN (substituteFormula LNN F 0 (Succ (var nv))))).

eapply In_list_remove1.

apply H4.

induction (freeVarSubFormula3 _ _ _ _ _ H5).

elim (In_list_remove2 _ _ _ _ _ H6).

reflexivity.

simpl in H6.

decompose sum H6.

apply H0; assumption.

apply

 iffTrans

  with

    (substituteFormula LNN

       (substituteFormula LNN

          (substituteFormula LNN F 2

             (natToTerm (codeFormula L codeF codeR f))) 0 

          (Succ (var nv))) 1 (natToTerm n)).

repeat (apply (reduceSub LNN); [ apply closedNN | idtac ]).

apply (subFormulaExch LNN).

discriminate.

unfold not in |- *; intros.

simpl in H4.

decompose sum H4.

apply H2; assumption.

apply closedNatToTerm.

apply (subFormulaExch LNN).

discriminate.

unfold not in |- *; intros.

simpl in H4.

decompose sum H4.

apply H1; assumption.

apply closedNatToTerm.

assert

 (Representable NN 2 (checkPrf L codeF codeR codeArityF codeArityR)

    (primRecFormula 2

       (proj1_sig

          (checkPrfIsPR L codeF codeR codeArityF codeArityR codeArityFIsPR

             codeArityRIsPR)))).

apply primRecRepresentable.

fold F in H4.

induction H4 as (H4, H5).

simpl in H5.

apply

 impE

  with

    (notH

       (substituteFormula LNN

          (equal (var 0)

             (natToTerm

                (checkPrf L codeF codeR codeArityF codeArityR

                   (codeFormula L codeF codeR f) n))) 0 

          (Succ (var nv)))).

apply cp2.

apply iffE1.

repeat (apply (reduceSub LNN); [ apply closedNN | idtac ]).

apply H5.

rewrite (subFormulaEqual LNN).

rewrite (subTermVar1 LNN).

rewrite (subTermNil LNN).

induction

 (eq_nat_dec

    (checkPrf L codeF codeR codeArityF codeArityR

       (codeFormula L codeF codeR f) n) 0).

rewrite a.

apply nn1.

decompose record

 (checkPrfCorrect2 L codeF codeR codeArityF codeArityR codeArityFIsCorrect1

    codeArityFIsCorrect2 codeArityRIsCorrect1 codeArityRIsCorrect2 codeFInj

    codeRInj (codeFormula L codeF codeR f) n b).

assert (x = f).

eapply codeFormulaInj.

apply codeFInj.

apply codeRInj.

assumption.

rewrite <- H6 in H.

elim (H x0 x1).

symmetry  in |- *.

assumption.

apply closedNatToTerm.

Qed.



Lemma freeVarCodeSysPrf :

 forall v : nat, In v (freeVarFormula LNN codeSysPrf) -> v <= 1.

Proof.

intros.

unfold codeSysPrf in H.

set (nv := newVar (2 :: 1 :: 0 :: v0 :: nil)) in *.

unfold existH, andH, forallH, impH, orH in H.

repeat

 match goal with

 | H1:(?X1 = ?X2),H2:(?X1 <> ?X2) |- _ =>

     elim H2; apply H1

 | H1:(?X1 = ?X2),H2:(?X2 <> ?X1) |- _ =>

     elim H2; symmetry  in |- *; apply H1

 | H:(In ?X3 (freeVarFormula LNN (fol.existH LNN ?X1 ?X2))) |- _ =>

     assert (In X3 (list_remove nat eq_nat_dec X1 (freeVarFormula LNN X2)));

      [ apply H | clear H ]

 | H:(In ?X3 (freeVarFormula LNN (fol.forallH LNN ?X1 ?X2))) |- _ =>

     assert (In X3 (list_remove nat eq_nat_dec X1 (freeVarFormula LNN X2)));

      [ apply H | clear H ]

 | H:(In ?X3 (list_remove nat eq_nat_dec ?X1 (freeVarFormula LNN ?X2))) |- _

 =>

     assert (In X3 (freeVarFormula LNN X2));

      [ eapply In_list_remove1; apply H

      | assert (X3 <> X1); [ eapply In_list_remove2; apply H | clear H ] ]

 | H:(In ?X3 (freeVarFormula LNN (fol.andH LNN ?X1 ?X2))) |- _ =>

     assert (In X3 (freeVarFormula LNN X1 ++ freeVarFormula LNN X2));

      [ apply H | clear H ]

 | H:(In ?X3 (freeVarFormula LNN (fol.orH LNN ?X1 ?X2))) |- _ =>

     assert (In X3 (freeVarFormula LNN X1 ++ freeVarFormula LNN X2));

      [ apply H | clear H ]

 | H:(In ?X3 (freeVarFormula LNN (fol.impH LNN ?X1 ?X2))) |- _ =>

     assert (In X3 (freeVarFormula LNN X1 ++ freeVarFormula LNN X2));

      [ apply H | clear H ]

 | H:(In ?X3 (freeVarFormula LNN (fol.notH LNN ?X1))) |- _ =>

     assert (In X3 (freeVarFormula LNN X1)); [ apply H | clear H ]

 | H:(In _ (_ ++ _)) |- _ =>

     induction (in_app_or _ _ _ H); clear H

 | H:(In _ (freeVarFormula LNN (substituteFormula LNN ?X1 ?X2 ?X3))) |- _ =>

     induction (freeVarSubFormula3 _ _ _ _ _ H); clear H

 | H:(In _ (freeVarFormula LNN (LT ?X1 ?X2))) |- _ =>

     rewrite freeVarLT in H

 | H:(In _ (freeVarTerm LNN (natToTerm _))) |- _ =>

     elim (closedNatToTerm _ _ H)

 | H:(In _ (freeVarTerm LNN Zero)) |- _ =>

     elim H

 | H:(In _ (freeVarTerm LNN (Succ _))) |- _ =>

     rewrite freeVarSucc in H

 | H:(In _ (freeVarTerm LNN (var _))) |- _ =>

     simpl in H; decompose sum H; clear H

 | H:(In _ (freeVarTerm LNN (fol.var LNN _))) |- _ =>

     simpl in H; decompose sum H; clear H

 end.

assert

 (Representable NN 2 (checkPrf L codeF codeR codeArityF codeArityR)

    (primRecFormula 2

       (proj1_sig

          (checkPrfIsPR L codeF codeR codeArityF codeArityR codeArityFIsPR

             codeArityRIsPR)))).

apply primRecRepresentable.

induction H0 as (H0, H4).

clear H4.

induction (le_lt_or_eq _ _ (H0 _ H)).

apply le_S_n.

apply H4.

elim H2; assumption.

rewrite <- H.

auto.

assert (Representable NN 2 codeIn (primRecFormula 2 (proj1_sig codeInIsPR))).

apply primRecRepresentable.

induction H0 as (H0, H6).

induction (le_lt_or_eq _ _ (H0 _ H)).

apply le_S_n.

apply H7.

elim H5; assumption.

elim H3.

apply freeVarfU.

assumption.

Qed.



Definition codeSysPf : Formula := existH 1 codeSysPrf.



Lemma freeVarCodeSysPf :

 forall v : nat, In v (freeVarFormula LNN codeSysPf) -> v = 0.

Proof.

intros.

unfold codeSysPf in H.

destruct v as [| n].

reflexivity.

destruct n.

elim (In_list_remove2 _ _ _ _ _ H).

reflexivity.

elim (le_not_lt (S (S n)) 1).

apply freeVarCodeSysPrf.

eapply In_list_remove1.

apply H.

apply lt_n_S.

apply lt_O_Sn.

Qed.



Lemma codeSysPfCorrect :

 forall f : fol.Formula L,

 folProof.SysPrf L U f ->

 SysPrf T

   (substituteFormula LNN codeSysPf 0

      (natToTerm (codeFormula L codeF codeR f))).

Proof.

intros.

induction H as (x, H).

induction H as (x0, H).

unfold codeSysPf in |- *.

rewrite (subFormulaExist LNN).

induction (eq_nat_dec 1 0).

discriminate a.

induction

 (In_dec eq_nat_dec 1

    (freeVarTerm LNN (natToTerm (codeFormula L codeF codeR f)))).

elim (closedNatToTerm _ _ a).

apply existI with (natToTerm (codePrf L codeF codeR _ _ x0)).

apply codeSysPrfCorrect1.

assumption.

Qed.



Definition codeSysPrfNot :=

  existH 2

    (andH (substituteFormula LNN codeSysPrf 0 (var 2))

       (substituteFormula LNN

          (substituteFormula LNN (primRecFormula 1 (proj1_sig codeNotIsPR)) 0

             (var 2)) 1 (var 0))).



Lemma freeVarCodeSysPrfN :

 forall v : nat, In v (freeVarFormula LNN codeSysPrfNot) -> v <= 1.

Proof.

intros.

unfold codeSysPrfNot in H.

SimplFreeVar.

apply freeVarCodeSysPrf.

apply H.

assert (Representable NN 1 codeNot (primRecFormula 1 (proj1_sig codeNotIsPR))).

apply primRecRepresentable.

induction H0 as (H0, H4).

clear H4.

apply H0.

assumption.

rewrite <- H.

apply le_O_n.

Qed.



Lemma codeSysPrfNCorrect1 :

 forall (f : fol.Formula L) (A : fol.Formulas L) (p : Prf L A (fol.notH L f)),

 (forall g : fol.Formula L, In g A -> mem _ U g) ->

 SysPrf T

   (substituteFormula LNN

      (substituteFormula LNN codeSysPrfNot 0

         (natToTerm (codeFormula L codeF codeR f))) 1

      (natToTerm (codePrf L codeF codeR A (fol.notH L f) p))).

Proof.

intros.

unfold codeSysPrfNot in |- *.

rewrite (subFormulaExist LNN).

induction (eq_nat_dec 2 0).

discriminate a.

induction

 (In_dec eq_nat_dec 2

    (freeVarTerm LNN (natToTerm (codeFormula L codeF codeR f)))).

elim (closedNatToTerm _ _ a).

clear b b0.

rewrite (subFormulaExist LNN).

induction (eq_nat_dec 2 1).

discriminate a.

induction

 (In_dec eq_nat_dec 2

    (freeVarTerm LNN (natToTerm (codePrf L codeF codeR A (fol.notH L f) p)))).

elim (closedNatToTerm _ _ a).

clear b b0.

apply existI with (natToTerm (codeFormula L codeF codeR (fol.notH L f))).

repeat rewrite (subFormulaAnd LNN).

apply andI.

apply

 impE

  with

    (substituteFormula LNN

       (substituteFormula LNN codeSysPrf 0

          (natToTerm (codeFormula L codeF codeR (fol.notH L f)))) 1

       (natToTerm (codePrf L codeF codeR A (fol.notH L f) p))).

apply sysExtend with NN.

apply TextendsNN.

apply iffE2.

apply

 iffTrans

  with

    (substituteFormula LNN

       (substituteFormula LNN (substituteFormula LNN codeSysPrf 0 (var 2)) 1

          (natToTerm (codePrf L codeF codeR A (fol.notH L f) p))) 2

       (natToTerm (codeFormula L codeF codeR (fol.notH L f)))).

repeat (apply (reduceSub LNN); [ apply closedNN | idtac ]).

apply (subFormulaNil LNN).

unfold not in |- *; intros.

induction (freeVarSubFormula3 _ _ _ _ _ H0).

apply (In_list_remove2 _ _ _ _ _ H1).

reflexivity.

simpl in H1.

decompose sum H1.

discriminate H2.

apply

 iffTrans

  with

    (substituteFormula LNN

       (substituteFormula LNN (substituteFormula LNN codeSysPrf 0 (var 2)) 2

          (natToTerm (codeFormula L codeF codeR (fol.notH L f)))) 1

       (natToTerm (codePrf L codeF codeR A (fol.notH L f) p))).

apply (subFormulaExch LNN).

discriminate.

apply closedNatToTerm.

apply closedNatToTerm.

repeat (apply (reduceSub LNN); [ apply closedNN | idtac ]).

apply (subFormulaTrans LNN).

unfold not in |- *; intros.

elim (le_not_lt 2 1).

apply freeVarCodeSysPrf.

eapply In_list_remove1.

apply H0.

eapply lt_n_S.

apply lt_O_Sn.

apply codeSysPrfCorrect1.

assumption.

apply sysExtend with NN.

apply TextendsNN.

set (B := primRecFormula 1 (proj1_sig codeNotIsPR)) in *.

assert (rep : Representable NN 1 codeNot B).

unfold B in |- *; apply primRecRepresentable.

apply

 impE

  with

    (substituteFormula LNN

       (substituteFormula LNN B 1 (natToTerm (codeFormula L codeF codeR f)))

       0 (natToTerm (codeFormula L codeF codeR (fol.notH L f)))).

apply iffE2.

apply

 iffTrans

  with

    (substituteFormula LNN

       (substituteFormula LNN

          (substituteFormula LNN (substituteFormula LNN B 0 (var 2)) 1

             (natToTerm (codeFormula L codeF codeR f))) 1

          (natToTerm (codePrf L codeF codeR A (fol.notH L f) p))) 2

       (natToTerm (codeFormula L codeF codeR (fol.notH L f)))).

repeat (apply (reduceSub LNN); [ apply closedNN | idtac ]).

apply (subFormulaTrans LNN).

unfold not in |- *; intros.

assert (In 0 (freeVarFormula LNN (substituteFormula LNN B 0 (var 2)))).

eapply In_list_remove1.

apply H0.

induction (freeVarSubFormula3 _ _ _ _ _ H1).

elim (In_list_remove2 _ _ _ _ _ H2).

reflexivity.

induction H2 as [H2| H2].

discriminate H2.

apply H2.

apply

 iffTrans

  with

    (substituteFormula LNN

       (substituteFormula LNN (substituteFormula LNN B 0 (var 2)) 1

          (natToTerm (codeFormula L codeF codeR f))) 2

       (natToTerm (codeFormula L codeF codeR (fol.notH L f)))).

repeat (apply (reduceSub LNN); [ apply closedNN | idtac ]).

apply (subFormulaNil LNN).

unfold not in |- *; intros.

induction (freeVarSubFormula3 _ _ _ _ _ H0).

elim (In_list_remove2 _ _ _ _ _ H1).

reflexivity.

elim (closedNatToTerm _ _ H1).

apply

 iffTrans

  with

    (substituteFormula LNN

       (substituteFormula LNN

          (substituteFormula LNN B 1

             (natToTerm (codeFormula L codeF codeR f))) 0 

          (var 2)) 2 (natToTerm (codeFormula L codeF codeR (fol.notH L f)))).

repeat (apply (reduceSub LNN); [ apply closedNN | idtac ]).

apply (subFormulaExch LNN).

discriminate.

unfold not in |- *; intros.

simpl in H0.

decompose sum H0.

discriminate H1.

apply closedNatToTerm.

apply (subFormulaTrans LNN).

unfold not in |- *; intros.

assert

 (In 2

    (freeVarFormula LNN

       (substituteFormula LNN B 1 (natToTerm (codeFormula L codeF codeR f))))).

eapply In_list_remove1.

apply H0.

induction (freeVarSubFormula3 _ _ _ _ _ H1).

induction rep as (H3, H4).

apply (le_not_lt 2 1).

apply H3.

eapply In_list_remove1.

apply H2.

apply lt_n_S.

apply lt_O_Sn.

apply (closedNatToTerm _ _ H2).

induction rep as (H0, H1).

unfold RepresentableHelp in H1.

apply

 impE

  with

    (substituteFormula LNN

       (equal (var 0) (natToTerm (codeNot (codeFormula L codeF codeR f)))) 0

       (natToTerm (codeFormula L codeF codeR (fol.notH L f)))).

apply iffE2.

repeat (apply (reduceSub LNN); [ apply closedNN | idtac ]).

apply H1.

rewrite (subFormulaEqual LNN).

rewrite (subTermVar1 LNN).

rewrite (subTermNil LNN).

rewrite (codeNotCorrect L codeF codeR).

apply eqRefl.

apply closedNatToTerm.

Qed.



Lemma codeSysPrfNCorrect2 :

 forall (f : fol.Formula L) (A : fol.Formulas L),

 (exists g : fol.Formula L, In g A /\ ~ mem _ U g) ->

 forall p : Prf L A (fol.notH L f),

 SysPrf T

   (notH

      (substituteFormula LNN

         (substituteFormula LNN codeSysPrfNot 0

            (natToTerm (codeFormula L codeF codeR f))) 1

         (natToTerm (codePrf L codeF codeR A (fol.notH L f) p)))). 

Proof.

intros.

unfold codeSysPrfNot in |- *.

rewrite (subFormulaExist LNN).

induction (eq_nat_dec 2 0).

discriminate a.

induction

 (In_dec eq_nat_dec 2

    (freeVarTerm LNN (natToTerm (codeFormula L codeF codeR f)))).

elim (closedNatToTerm _ _ a).

clear b b0.

rewrite (subFormulaExist LNN).

induction (eq_nat_dec 2 1).

discriminate a.

induction

 (In_dec eq_nat_dec 2

    (freeVarTerm LNN (natToTerm (codePrf L codeF codeR A (fol.notH L f) p)))).

elim (closedNatToTerm _ _ a).

clear b b0.

apply nExist.

apply

 impE

  with

    (fol.notH LNN

       (substituteFormula LNN

          (substituteFormula LNN codeSysPrf 0

             (natToTerm (codeFormula L codeF codeR (fol.notH L f)))) 1

          (natToTerm (codePrf L codeF codeR A (fol.notH L f) p)))).

apply sysExtend with NN.

apply TextendsNN.

apply impI.

apply forallI.

unfold not in |- *; intros.

induction H0 as (x, H0); induction H0 as (H0, H1).

induction H1 as [x H1| x H1].

apply (closedNN 2).

exists x.

auto.

induction H1.



SimplFreeVar.

elim (le_not_lt 2 1).

apply freeVarCodeSysPrf.

apply H1.

apply lt_n_Sn.

repeat rewrite (subFormulaAnd LNN).

apply nAnd.

apply orSym.

unfold orH, fol.orH in |- *.

apply

 impTrans

  with

    (substituteFormula LNN

       (substituteFormula LNN (primRecFormula 1 (proj1_sig codeNotIsPR)) 1

          (natToTerm (codeFormula L codeF codeR f))) 0 

       (var 2)).

apply sysWeaken.

apply

 impTrans

  with

    (substituteFormula LNN

       (substituteFormula LNN

          (substituteFormula LNN

             (substituteFormula LNN

                (primRecFormula 1 (proj1_sig codeNotIsPR)) 0 

                (var 2)) 1 (var 0)) 0

          (natToTerm (codeFormula L codeF codeR f))) 1

       (natToTerm (codePrf L codeF codeR A (fol.notH L f) p))).

apply impI.

apply nnE.

apply Axm; right; constructor.

apply iffE1.

apply

 iffTrans

  with

    (substituteFormula LNN

       (substituteFormula LNN

          (substituteFormula LNN (primRecFormula 1 (proj1_sig codeNotIsPR)) 0

             (var 2)) 1 (natToTerm (codeFormula L codeF codeR f))) 1

       (natToTerm (codePrf L codeF codeR A (fol.notH L f) p))).

repeat (apply (reduceSub LNN); [ apply closedNN | idtac ]).

apply (subFormulaTrans LNN).

unfold not in |- *; intros; SimplFreeVar.

discriminate H1.

apply

 iffTrans

  with

    (substituteFormula LNN

       (substituteFormula LNN (primRecFormula 1 (proj1_sig codeNotIsPR)) 0

          (var 2)) 1 (natToTerm (codeFormula L codeF codeR f))).

apply (subFormulaNil LNN).

unfold not in |- *; intros; SimplFreeVar.

apply (subFormulaExch LNN).

discriminate.

unfold not in |- *; intros; SimplFreeVar.

discriminate H1.

unfold not in |- *; intros; SimplFreeVar.

set (B := primRecFormula 1 (proj1_sig codeNotIsPR)) in *.

assert (rep : Representable NN 1 codeNot B).

unfold B in |- *; apply primRecRepresentable.

induction rep as (H0, H1).

unfold RepresentableHelp in H1.

apply

 impTrans

  with

    (substituteFormula LNN

       (equal (var 0) (natToTerm (codeNot (codeFormula L codeF codeR f)))) 0

       (var 2)).

apply iffE1.

apply sysWeaken.

repeat (apply (reduceSub LNN); [ apply closedNN | idtac ]).

apply H1.

rewrite (subFormulaEqual LNN).

rewrite (subTermVar1 LNN).

rewrite (subTermNil LNN).

rewrite (codeNotCorrect L) with (a := f).

apply impI.

rewrite <-

 (subFormulaId LNN

    (notH

       (substituteFormula LNN

          (substituteFormula LNN (substituteFormula LNN codeSysPrf 0 (var 2))

             0 (natToTerm (codeFormula L codeF codeR f))) 1

          (natToTerm (codePrf L codeF codeR A (fol.notH L f) p)))) 2)

 .

apply

 impE

  with

    (substituteFormula LNN

       (notH

          (substituteFormula LNN

             (substituteFormula LNN

                (substituteFormula LNN codeSysPrf 0 (var 2)) 0

                (natToTerm (codeFormula L codeF codeR f))) 1

             (natToTerm (codePrf L codeF codeR A (fol.notH L f) p)))) 2

       (natToTerm (codeFormula L codeF codeR (fol.notH L f)))).

eapply (subWithEquals LNN).

apply eqSym.

apply Axm; right; constructor.

apply sysWeaken.

rewrite (subFormulaNot LNN).

apply

 impE

  with

    (fol.notH LNN

       (substituteFormula LNN

          (substituteFormula LNN codeSysPrf 0

             (natToTerm (codeFormula L codeF codeR (fol.notH L f)))) 1

          (natToTerm (codePrf L codeF codeR A (fol.notH L f) p)))).

apply cp2.

apply sysWeaken.

apply iffE1.

apply

 iffTrans

  with

    (substituteFormula LNN

       (substituteFormula LNN (substituteFormula LNN codeSysPrf 0 (var 2)) 1

          (natToTerm (codePrf L codeF codeR A (fol.notH L f) p))) 2

       (natToTerm (codeFormula L codeF codeR (fol.notH L f)))).

repeat (apply (reduceSub LNN); [ apply closedNN | idtac ]).

apply (subFormulaNil LNN).

unfold not in |- *; intros; SimplFreeVar.

discriminate.

apply

 iffTrans

  with

    (substituteFormula LNN

       (substituteFormula LNN (substituteFormula LNN codeSysPrf 0 (var 2)) 2

          (natToTerm (codeFormula L codeF codeR (fol.notH L f)))) 1

       (natToTerm (codePrf L codeF codeR A (fol.notH L f) p))).

apply (subFormulaExch LNN).

discriminate.

apply closedNatToTerm.

apply closedNatToTerm.

repeat (apply (reduceSub LNN); [ apply closedNN | idtac ]).

apply (subFormulaTrans LNN).

unfold not in |- *; intros; SimplFreeVar.

elim (le_not_lt 2 1).

apply freeVarCodeSysPrf.

apply H3.

apply lt_n_Sn.

apply Axm; right; constructor.

apply closedNatToTerm.

apply codeSysPrfCorrect2.

assumption.

Qed.



Lemma codeSysPrfNCorrect3 :

 forall (f : fol.Formula L) (n : nat),

 (forall (A : fol.Formulas L) (p : Prf L A (fol.notH L f)),

  n <> codePrf L codeF codeR A (fol.notH L f) p) ->

 SysPrf T

   (notH

      (substituteFormula LNN

         (substituteFormula LNN codeSysPrfNot 0

            (natToTerm (codeFormula L codeF codeR f))) 1 

         (natToTerm n))).

Proof.

intros.

unfold codeSysPrfNot in |- *.

rewrite (subFormulaExist LNN).

induction (eq_nat_dec 2 0).

discriminate a.

induction

 (In_dec eq_nat_dec 2

    (freeVarTerm LNN (natToTerm (codeFormula L codeF codeR f)))).

elim (closedNatToTerm _ _ a).

clear b b0.

rewrite (subFormulaExist LNN).

induction (eq_nat_dec 2 1).

discriminate a.

induction (In_dec eq_nat_dec 2 (freeVarTerm LNN (natToTerm n))).

elim (closedNatToTerm _ _ a).

clear b b0.

apply nExist.

apply

 impE

  with

    (fol.notH LNN

       (substituteFormula LNN

          (substituteFormula LNN codeSysPrf 0

             (natToTerm (codeFormula L codeF codeR (fol.notH L f)))) 1

          (natToTerm n))).

apply sysExtend with NN.

apply TextendsNN.

apply impI.

apply forallI.

unfold not in |- *; intros.

induction H0 as (x, H0); induction H0 as (H0, H1).

induction H1 as [x H1| x H1].

apply (closedNN 2).

exists x.

auto.

induction H1.

fold notH in H0.

SimplFreeVar.

elim (le_not_lt 2 1).

apply freeVarCodeSysPrf.

apply H1.

apply lt_n_Sn.

repeat rewrite (subFormulaAnd LNN).

apply nAnd.

apply orSym.

unfold orH, fol.orH in |- *.

apply

 impTrans

  with

    (substituteFormula LNN

       (substituteFormula LNN (primRecFormula 1 (proj1_sig codeNotIsPR)) 1

          (natToTerm (codeFormula L codeF codeR f))) 0 

       (var 2)).

apply sysWeaken.

apply

 impTrans

  with

    (substituteFormula LNN

       (substituteFormula LNN

          (substituteFormula LNN

             (substituteFormula LNN

                (primRecFormula 1 (proj1_sig codeNotIsPR)) 0 

                (var 2)) 1 (var 0)) 0

          (natToTerm (codeFormula L codeF codeR f))) 1 

       (natToTerm n)).

apply impI.

apply nnE.

apply Axm; right; constructor.

apply iffE1.

apply

 iffTrans

  with

    (substituteFormula LNN

       (substituteFormula LNN

          (substituteFormula LNN (primRecFormula 1 (proj1_sig codeNotIsPR)) 0

             (var 2)) 1 (natToTerm (codeFormula L codeF codeR f))) 1

       (natToTerm n)).

repeat (apply (reduceSub LNN); [ apply closedNN | idtac ]).

apply (subFormulaTrans LNN).

unfold not in |- *; intros; SimplFreeVar.

discriminate H1.

apply

 iffTrans

  with

    (substituteFormula LNN

       (substituteFormula LNN (primRecFormula 1 (proj1_sig codeNotIsPR)) 0

          (var 2)) 1 (natToTerm (codeFormula L codeF codeR f))).

apply (subFormulaNil LNN).

unfold not in |- *; intros; SimplFreeVar.

apply (subFormulaExch LNN).

discriminate.

unfold not in |- *; intros; SimplFreeVar.

discriminate H1.

unfold not in |- *; intros; SimplFreeVar.

set (B := primRecFormula 1 (proj1_sig codeNotIsPR)) in *.

assert (rep : Representable NN 1 codeNot B).

unfold B in |- *; apply primRecRepresentable.

induction rep as (H0, H1).

unfold RepresentableHelp in H1.

apply

 impTrans

  with

    (substituteFormula LNN

       (equal (var 0) (natToTerm (codeNot (codeFormula L codeF codeR f)))) 0

       (var 2)).

apply iffE1.

apply sysWeaken.

repeat (apply (reduceSub LNN); [ apply closedNN | idtac ]).

apply H1.

rewrite (subFormulaEqual LNN).

rewrite (subTermVar1 LNN).

rewrite (subTermNil LNN).

rewrite (codeNotCorrect L) with (a := f).

apply impI.

rewrite <-

 (subFormulaId LNN

    (notH

       (substituteFormula LNN

          (substituteFormula LNN (substituteFormula LNN codeSysPrf 0 (var 2))

             0 (natToTerm (codeFormula L codeF codeR f))) 1 

          (natToTerm n))) 2).

apply

 impE

  with

    (substituteFormula LNN

       (notH

          (substituteFormula LNN

             (substituteFormula LNN

                (substituteFormula LNN codeSysPrf 0 (var 2)) 0

                (natToTerm (codeFormula L codeF codeR f))) 1 

             (natToTerm n))) 2

       (natToTerm (codeFormula L codeF codeR (fol.notH L f)))).

eapply (subWithEquals LNN).

apply eqSym.

apply Axm; right; constructor.

apply sysWeaken.

rewrite (subFormulaNot LNN).

apply

 impE

  with

    (fol.notH LNN

       (substituteFormula LNN

          (substituteFormula LNN codeSysPrf 0

             (natToTerm (codeFormula L codeF codeR (fol.notH L f)))) 1

          (natToTerm n))).

apply cp2.

apply sysWeaken.

apply iffE1.

apply

 iffTrans

  with

    (substituteFormula LNN

       (substituteFormula LNN (substituteFormula LNN codeSysPrf 0 (var 2)) 1

          (natToTerm n)) 2

       (natToTerm (codeFormula L codeF codeR (fol.notH L f)))).

repeat (apply (reduceSub LNN); [ apply closedNN | idtac ]).

apply (subFormulaNil LNN).

unfold not in |- *; intros; SimplFreeVar.

discriminate.

apply

 iffTrans

  with

    (substituteFormula LNN

       (substituteFormula LNN (substituteFormula LNN codeSysPrf 0 (var 2)) 2

          (natToTerm (codeFormula L codeF codeR (fol.notH L f)))) 1

       (natToTerm n)).

apply (subFormulaExch LNN).

discriminate.

apply closedNatToTerm.

apply closedNatToTerm.

repeat (apply (reduceSub LNN); [ apply closedNN | idtac ]).

apply (subFormulaTrans LNN).

unfold not in |- *; intros; SimplFreeVar.

elim (le_not_lt 2 1).

apply freeVarCodeSysPrf.

apply H3.

apply lt_n_Sn.

apply Axm; right; constructor.

apply closedNatToTerm.

fold notH in |- *.

apply codeSysPrfCorrect3.

assumption.

Qed.



End LNN.



End code_SysPrf.

