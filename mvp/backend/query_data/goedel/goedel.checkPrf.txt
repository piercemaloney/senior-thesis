Require Import primRec.
(* primRec:
Require Import Arith.
Require Import Peano_dec.
Require Import Compare_dec.
Require Import Coq.Lists.List.
Require Import Eqdep_dec.
Require Import extEqualNat.
Require Vector.
Require Import misc.
Require Export Bool.
Require Export EqNat.
Require Import Even.
Require Import Max.

Inductive PrimRec : nat -> Set :=
  | succFunc : PrimRec 1
  | zeroFunc : PrimRec 0
  | projFunc : forall n m : nat, m < n -> PrimRec n
  | composeFunc :
      forall (n m : nat) (g : PrimRecs n m) (h : PrimRec m), PrimRec n
  | primRecFunc :
      forall (n : nat) (g : PrimRec n) (h : PrimRec (S (S n))), PrimRec (S n)
with PrimRecs : nat -> nat -> Set :=
  | PRnil : forall n : nat, PrimRecs n 0
  | PRcons : forall n m : nat, PrimRec n -> PrimRecs n m -> PrimRecs n (S m).

Scheme PrimRec_PrimRecs_rec := Induction for PrimRec
  Sort Set
  with PrimRecs_PrimRec_rec := Induction for PrimRecs 
  Sort Set.

Scheme PrimRec_PrimRecs_ind := Induction for PrimRec
  Sort Prop
  with PrimRecs_PrimRec_ind := Induction for PrimRecs 
  Sort Prop.

Fixpoint evalConstFunc (n m : nat) {struct n} : naryFunc n :=
  match n return (naryFunc n) with
  | O => m
  | S n' => fun _ => evalConstFunc n' m
  end.

Fixpoint evalProjFunc (n : nat) : forall m : nat, m < n -> naryFunc n :=
  match n return (forall m : nat, m < n -> naryFunc n) with
  | O => fun (m : nat) (l : m < 0) => False_rec _ (lt_n_O _ l)
  | S n' =>
      fun (m : nat) (l : m < S n') =>
      match eq_nat_dec m n' with
      | left _ => fun a : nat => evalConstFunc _ a
      | right l1 =>
          fun _ =>
          evalProjFunc n' m
            match le_lt_or_eq _ _ (lt_n_Sm_le _ _ l) with
            | or_introl l2 => l2
            | or_intror l2 => False_ind _ (l1 l2)
            end
      end
  end.

Lemma evalProjFuncInd :
 forall (n m : nat) (p1 p2 : m < n),
 evalProjFunc n m p1 = evalProjFunc n m p2.

Fixpoint evalList (m : nat) (l : Vector.t nat m) {struct l} :
 naryFunc m -> nat :=
  match l in (Vector.t _ m) return (naryFunc m -> nat) with
  | Vector.nil => fun x : naryFunc 0 => x
  | Vector.cons a n l' => fun x : naryFunc (S n) => evalList n l' (x a)
  end.

Fixpoint evalOneParamList (n m a : nat) (l : Vector.t (naryFunc (S n)) m)
 {struct l} : Vector.t (naryFunc n) m :=
  match l in (Vector.t _ m) return (Vector.t (naryFunc n) m) with
  | Vector.nil  => Vector.nil  (naryFunc n)
  | Vector.cons f m' l' => Vector.cons _ (f a) m' (evalOneParamList n m' a l')
  end.

Fixpoint evalComposeFunc (n : nat) :
 forall m : nat, Vector.t (naryFunc n) m -> naryFunc m -> naryFunc n :=
  match
    n
    return
      (forall m : nat, Vector.t (naryFunc n) m -> naryFunc m -> naryFunc n)
  with
  | O => evalList
  | S n' =>
      fun (m : nat) (l : Vector.t (naryFunc (S n')) m) 
        (f : naryFunc m) (a : nat) =>
      evalComposeFunc n' m (evalOneParamList _ _ a l) f
  end.

Fixpoint compose2 (n : nat) : naryFunc n -> naryFunc (S n) -> naryFunc n :=
  match n return (naryFunc n -> naryFunc (S n) -> naryFunc n) with
  | O => fun (a : nat) (g : nat -> nat) => g a
  | S n' =>
      fun (f : naryFunc (S n')) (g : naryFunc (S (S n'))) (a : nat) =>
      compose2 n' (f a) (fun x : nat => g x a)
  end.

Fixpoint evalPrimRecFunc (n : nat) (g : naryFunc n) 
 (h : naryFunc (S (S n))) (a : nat) {struct a} : naryFunc n :=
  match a with
  | O => g
  | S a' => compose2 _ (evalPrimRecFunc n g h a') (h a')
  end.

Fixpoint evalPrimRec (n : nat) (f : PrimRec n) {struct f} : 
 naryFunc n :=
  match f in (PrimRec n) return (naryFunc n) with
  | succFunc => S
  | zeroFunc => 0
  | projFunc n m pf => evalProjFunc n m pf
  | composeFunc n m l f =>
      evalComposeFunc n m (evalPrimRecs _ _ l) (evalPrimRec _ f)
  | primRecFunc n g h =>
      evalPrimRecFunc n (evalPrimRec _ g) (evalPrimRec _ h)
  end
 
 with evalPrimRecs (n m : nat) (fs : PrimRecs n m) {struct fs} :
 Vector.t (naryFunc n) m :=
  match fs in (PrimRecs n m) return (Vector.t (naryFunc n) m) with
  | PRnil a => Vector.nil  (naryFunc a)
  | PRcons a b g gs => Vector.cons _ (evalPrimRec _ g) _ (evalPrimRecs _ _ gs)
  end.

Definition extEqualVectorGeneral (n m : nat) (l : Vector.t (naryFunc n) m) :

Definition extEqualVector n: forall m (l l' : Vector.t (naryFunc n) m), Prop.

Lemma extEqualVectorRefl :
 forall (n m : nat) (l : Vector.t (naryFunc n) m), extEqualVector n m l l.

Lemma extEqualOneParamList :
 forall (n m : nat) (l1 l2 : Vector.t (naryFunc (S n)) m) (c : nat),

Lemma extEqualCompose :
 forall (n m : nat) (l1 l2 : Vector.t (naryFunc n) m) (f1 f2 : naryFunc m),

Lemma extEqualCompose2 :
 forall (n : nat) (f1 f2 : naryFunc n),
 extEqual n f1 f2 ->
 forall g1 g2 : naryFunc (S n),
 extEqual (S n) g1 g2 -> extEqual n (compose2 n f1 g1) (compose2 n f2 g2).

Lemma extEqualPrimRec :
 forall (n : nat) (g1 g2 : naryFunc n) (h1 h2 : naryFunc (S (S n))),
 extEqual n g1 g2 ->
 extEqual (S (S n)) h1 h2 ->
 extEqual (S n) (evalPrimRecFunc n g1 h1) (evalPrimRecFunc n g2 h2).

Definition isPR (n : nat) (f : naryFunc n) : Set :=
  {p : PrimRec n | extEqual n (evalPrimRec _ p) f}.

Definition isPRrel (n : nat) (R : naryRel n) : Set :=
  isPR n (charFunction n R).

Lemma succIsPR : isPR 1 S.

Lemma const0_NIsPR : forall n : nat, isPR 0 n.

Lemma const1_NIsPR : forall n : nat, isPR 1 (fun _ => n).

Lemma idIsPR : isPR 1 (fun x : nat => x).

Lemma pi1_2IsPR : isPR 2 (fun a b : nat => a).

Lemma pi2_2IsPR : isPR 2 (fun a b : nat => b).

Lemma pi1_3IsPR : isPR 3 (fun a b c : nat => a).

Lemma pi2_3IsPR : isPR 3 (fun a b c : nat => b).

Lemma pi3_3IsPR : isPR 3 (fun a b c : nat => c).

Lemma pi1_4IsPR : isPR 4 (fun a b c d : nat => a).

Lemma pi2_4IsPR : isPR 4 (fun a b c d : nat => b).

Lemma pi3_4IsPR : isPR 4 (fun a b c d : nat => c).

Lemma pi4_4IsPR : isPR 4 (fun a b c d : nat => d).

Lemma filter01IsPR :
 forall g : nat -> nat, isPR 1 g -> isPR 2 (fun a b : nat => g b).

Lemma filter10IsPR :
 forall g : nat -> nat, isPR 1 g -> isPR 2 (fun a b : nat => g a).

Lemma filter100IsPR :
 forall g : nat -> nat, isPR 1 g -> isPR 3 (fun a b c : nat => g a).

Lemma filter010IsPR :
 forall g : nat -> nat, isPR 1 g -> isPR 3 (fun a b c : nat => g b).

Lemma filter001IsPR :
 forall g : nat -> nat, isPR 1 g -> isPR 3 (fun a b c : nat => g c).

Lemma filter011IsPR :
 forall g : nat -> nat -> nat, isPR 2 g -> isPR 3 (fun a b c : nat => g b c).

Lemma filter110IsPR :
 forall g : nat -> nat -> nat, isPR 2 g -> isPR 3 (fun a b c : nat => g a b).

Lemma filter101IsPR :
 forall g : nat -> nat -> nat, isPR 2 g -> isPR 3 (fun a b c : nat => g a c).

Lemma filter0011IsPR :
 forall g : nat -> nat -> nat,
 isPR 2 g -> isPR 4 (fun a b c d : nat => g c d).

Lemma filter1000IsPR :
 forall g : nat -> nat, isPR 1 g -> isPR 4 (fun a b c d : nat => g a).

Lemma filter1011IsPR :
 forall g : nat -> nat -> nat -> nat,
 isPR 3 g -> isPR 4 (fun a b c d : nat => g a c d).

Lemma filter1100IsPR :
 forall g : nat -> nat -> nat,
 isPR 2 g -> isPR 4 (fun a b c d : nat => g a b).

Lemma compose1_1IsPR :
 forall f : nat -> nat,
 isPR 1 f ->
 forall g : nat -> nat, isPR 1 g -> isPR 1 (fun x : nat => g (f x)).

Lemma compose1_2IsPR :
 forall f : nat -> nat,
 isPR 1 f ->
 forall f' : nat -> nat,
 isPR 1 f' ->
 forall g : nat -> nat -> nat,
 isPR 2 g -> isPR 1 (fun x : nat => g (f x) (f' x)).

Lemma compose1_3IsPR :
 forall f1 : nat -> nat,
 isPR 1 f1 ->
 forall f2 : nat -> nat,
 isPR 1 f2 ->
 forall f3 : nat -> nat,
 isPR 1 f3 ->
 forall g : nat -> nat -> nat -> nat,
 isPR 3 g -> isPR 1 (fun x : nat => g (f1 x) (f2 x) (f3 x)).

Lemma compose2_1IsPR :
 forall f : nat -> nat -> nat,
 isPR 2 f ->
 forall g : nat -> nat, isPR 1 g -> isPR 2 (fun x y : nat => g (f x y)).

Lemma compose2_2IsPR :
 forall f : nat -> nat -> nat,
 isPR 2 f ->
 forall g : nat -> nat -> nat,
 isPR 2 g ->
 forall h : nat -> nat -> nat,
 isPR 2 h -> isPR 2 (fun x y : nat => h (f x y) (g x y)).

Lemma compose2_3IsPR :
 forall f1 : nat -> nat -> nat,
 isPR 2 f1 ->
 forall f2 : nat -> nat -> nat,
 isPR 2 f2 ->
 forall f3 : nat -> nat -> nat,
 isPR 2 f3 ->
 forall g : nat -> nat -> nat -> nat,
 isPR 3 g -> isPR 2 (fun x y : nat => g (f1 x y) (f2 x y) (f3 x y)).

Lemma compose2_4IsPR :
 forall f1 : nat -> nat -> nat,
 isPR 2 f1 ->
 forall f2 : nat -> nat -> nat,
 isPR 2 f2 ->
 forall f3 : nat -> nat -> nat,
 isPR 2 f3 ->
 forall f4 : nat -> nat -> nat,
 isPR 2 f4 ->
 forall g : nat -> nat -> nat -> nat -> nat,
 isPR 4 g -> isPR 2 (fun x y : nat => g (f1 x y) (f2 x y) (f3 x y) (f4 x y)).

Lemma compose3_1IsPR :
 forall f : nat -> nat -> nat -> nat,
 isPR 3 f ->
 forall g : nat -> nat, isPR 1 g -> isPR 3 (fun x y z : nat => g (f x y z)).

Lemma compose3_2IsPR :
 forall f1 : nat -> nat -> nat -> nat,
 isPR 3 f1 ->
 forall f2 : nat -> nat -> nat -> nat,
 isPR 3 f2 ->
 forall g : nat -> nat -> nat,
 isPR 2 g -> isPR 3 (fun x y z : nat => g (f1 x y z) (f2 x y z)).

Lemma compose3_3IsPR :
 forall f1 : nat -> nat -> nat -> nat,
 isPR 3 f1 ->
 forall f2 : nat -> nat -> nat -> nat,
 isPR 3 f2 ->
 forall f3 : nat -> nat -> nat -> nat,
 isPR 3 f3 ->
 forall g : nat -> nat -> nat -> nat,
 isPR 3 g -> isPR 3 (fun x y z : nat => g (f1 x y z) (f2 x y z) (f3 x y z)).

Lemma compose4_2IsPR :
 forall f1 : nat -> nat -> nat -> nat -> nat,
 isPR 4 f1 ->
 forall f2 : nat -> nat -> nat -> nat -> nat,
 isPR 4 f2 ->
 forall g : nat -> nat -> nat,
 isPR 2 g -> isPR 4 (fun w x y z : nat => g (f1 w x y z) (f2 w x y z)).

Lemma compose4_3IsPR :
 forall f1 : nat -> nat -> nat -> nat -> nat,
 isPR 4 f1 ->
 forall f2 : nat -> nat -> nat -> nat -> nat,
 isPR 4 f2 ->
 forall f3 : nat -> nat -> nat -> nat -> nat,
 isPR 4 f3 ->
 forall g : nat -> nat -> nat -> nat,
 isPR 3 g ->
 isPR 4 (fun w x y z : nat => g (f1 w x y z) (f2 w x y z) (f3 w x y z)).

Lemma swapIsPR :
 forall f : nat -> nat -> nat, isPR 2 f -> isPR 2 (fun x y : nat => f y x).

Lemma indIsPR :
 forall f : nat -> nat -> nat,
 isPR 2 f ->
 forall g : nat,
 isPR 1
   (fun a : nat => nat_rec (fun n : nat => nat) g (fun x y : nat => f x y) a).

Lemma ind1ParamIsPR :
 forall f : nat -> nat -> nat -> nat,
 isPR 3 f ->
 forall g : nat -> nat,
 isPR 1 g ->
 isPR 2
   (fun a b : nat =>
    nat_rec (fun n : nat => nat) (g b) (fun x y : nat => f x y b) a).

Lemma ind2ParamIsPR :
 forall f : nat -> nat -> nat -> nat -> nat,
 isPR 4 f ->
 forall g : nat -> nat -> nat,
 isPR 2 g ->
 isPR 3
   (fun a b c : nat =>
    nat_rec (fun n : nat => nat) (g b c) (fun x y : nat => f x y b c) a).

Lemma plusIndIsPR : isPR 3 (fun n fn b : nat => S fn).

Lemma plusIsPR : isPR 2 plus.

Lemma multIndIsPR : isPR 3 (fun n fn b : nat => fn + b).

Lemma multIsPR : isPR 2 mult.

Lemma predIsPR : isPR 1 pred.

Lemma minusIndIsPR : isPR 3 (fun n fn b : nat => pred fn).

Lemma minusIsPR : isPR 2 minus.

Definition notZero (a : nat) :=
  nat_rec (fun n : nat => nat) 0 (fun x y : nat => 1) a.

Lemma notZeroIsPR : isPR 1 notZero.

Definition ltBool (a b : nat) : bool.

Lemma ltBoolTrue : forall a b : nat, ltBool a b = true -> a < b.

Lemma ltBoolFalse : forall a b : nat, ltBool a b = false -> ~ a < b.

Lemma ltIsPR : isPRrel 2 ltBool.

Lemma maxIsPR : isPR 2 max.

Lemma gtIsPR : isPRrel 2 (fun a b : nat => ltBool b a).

Remark replaceCompose2 :
 forall (n : nat) (a b a' b' : naryFunc n) (c c' : naryFunc 2),
 extEqual n a a' ->
 extEqual n b b' ->
 extEqual 2 c c' ->
 extEqual n
   (evalComposeFunc _ _ (Vector.cons _ a _ (Vector.cons _ b _ (Vector.nil  (naryFunc n)))) c)

Definition orRel (n : nat) (R S : naryRel n) : naryRel n.

Lemma orRelPR :
 forall (n : nat) (R R' : naryRel n),
 isPRrel n R -> isPRrel n R' -> isPRrel n (orRel n R R').

Definition andRel (n : nat) (R S : naryRel n) : naryRel n.

Lemma andRelPR :
 forall (n : nat) (R R' : naryRel n),
 isPRrel n R -> isPRrel n R' -> isPRrel n (andRel n R R').

Definition notRel (n : nat) (R : naryRel n) : naryRel n.

Lemma notRelPR :
 forall (n : nat) (R : naryRel n), isPRrel n R -> isPRrel n (notRel n R).

Fixpoint bodd (n : nat) : bool :=
  match n with
  | O => false
  | S n' => negb (bodd n')
  end.

Lemma boddIsPR : isPRrel 1 bodd.

Lemma beq_nat_not_refl : forall a b : nat, a <> b -> beq_nat a b = false.

Lemma neqIsPR : isPRrel 2 (fun a b : nat => negb (beq_nat a b)).

Lemma eqIsPR : isPRrel 2 beq_nat.

Definition leBool (a b : nat) : bool.

Lemma leIsPR : isPRrel 2 leBool.

Section Ignore_Params.

Fixpoint ignoreParams (n m : nat) (f : naryFunc n) {struct m} :
 naryFunc (m + n) :=
  match m return (naryFunc (m + n)) with
  | O => f
  | S x => fun _ => ignoreParams n x f
  end.

Definition projectionListPR (n m : nat) (p : m <= n) : PrimRecs n m.

Definition projectionList (n m : nat) (p : m <= n) : 
  Vector.t (naryFunc n) m := evalPrimRecs n m (projectionListPR n m p).

Lemma projectionListInd :
 forall (n m : nat) (p1 p2 : m <= n),
 projectionList n m p1 = projectionList n m p2.

Lemma projectionListApplyParam :
 forall (m n c : nat) (p1 : m <= n) (p2 : m <= S n),
 extEqualVector _ _ (projectionList n m p1)
   (evalOneParamList n m c (projectionList (S n) m p2)).

Lemma projectionListId :
 forall (n : nat) (f : naryFunc n) (p : n <= n),
 extEqual n f (evalComposeFunc n n (projectionList n n p) f).

Lemma ignoreParamsIsPR :
 forall (n m : nat) (f : naryFunc n), isPR _ f -> isPR _ (ignoreParams n m f).

End Ignore_Params.

Lemma reduce1stCompose :
 forall (c n m : nat) (v : Vector.t (naryFunc n) m) (g : naryFunc (S m)),

Lemma reduce2ndCompose :
 forall (c n m : nat) (v : Vector.t (naryFunc n) m) (n0 : naryFunc n)

Lemma evalPrimRecParam :
 forall (n c d : nat) (g : naryFunc (S n)) (h : naryFunc (S (S (S n)))),
 extEqual _ (evalPrimRecFunc n (g d) (fun x y : nat => h x y d) c)
   (evalPrimRecFunc (S n) g h c d).

Lemma compose2IsPR :
 forall (n : nat) (f : naryFunc n) (p : isPR n f) (g : naryFunc (S n))
   (q : isPR (S n) g), isPR n (compose2 n f g).

Lemma compose1_NIsPR :
 forall (n : nat) (g : naryFunc (S n)),
 isPR (S n) g ->
 forall f : naryFunc 1, isPR 1 f -> isPR (S n) (fun x : nat => g (f x)).

Definition switchPR : naryFunc 3. 

Lemma switchIsPR : isPR 3 switchPR.

Fixpoint boundedSearchHelp (P : naryRel 1) (b : nat) {struct b} : nat :=
  match b with
  | O => 0
  | S b' =>
      match eq_nat_dec (boundedSearchHelp P b') b' with
      | left _ => match P b' with
                  | true => b'
                  | false => S b'
                  end
      | right _ => boundedSearchHelp P b'
      end
  end.
   
Definition boundedSearch (P : naryRel 2) (b : nat) : nat :=
  boundedSearchHelp (P b) b.

Lemma boundedSearch1 :
 forall (P : naryRel 2) (b x : nat), x < boundedSearch P b -> P b x = false.

Lemma boundedSearch2 :
 forall (P : naryRel 2) (b : nat),
 boundedSearch P b = b \/ P b (boundedSearch P b) = true.

Lemma boundSearchIsPR :
 forall P : naryRel 2,
 isPRrel 2 P -> isPR 1 (fun b : nat => boundedSearch P b).

Definition iterate (g : nat -> nat) :=
  nat_rec (fun _ => nat -> nat) (fun x : nat => x)
    (fun (_ : nat) (rec : nat -> nat) (x : nat) => g (rec x)).

Lemma iterateIsPR :
 forall g : nat -> nat, isPR 1 g -> forall n : nat, isPR 1 (iterate g n). *)
Require Import codeFreeVar.
(* codeFreeVar:
Require Import primRec.
Require Import cPair.
Require Import Coq.Lists.List.
Require Import ListExt.
Require Import Arith.
Require Export codeList.
Require Import folProp.
Require Import code.

Section Code_Free_Vars.

Variable L : Language.
Variable codeF : Functions L -> nat.
Variable codeR : Relations L -> nat.

Let Formula := Formula L.
Let Formulas := Formulas L.
Let System := System L.
Let Term := Term L.
Let Terms := Terms L.
Let var := var L.
Let apply := apply L.
Let equal := equal L.
Let atomic := atomic L.
Let impH := impH L.
Let notH := notH L.
Let forallH := forallH L.
Let orH := orH L.
Let andH := andH L.
Let existH := existH L.
Let iffH := iffH L.
Let ifThenElseH := ifThenElseH L.

Definition codeFreeVarTermTerms : nat -> nat :=
  evalStrongRec 0
    (fun t recs : nat =>
     cPair
       (switchPR (cPairPi1 t) (cPairPi2 (codeNth (t - S (cPairPi2 t)) recs))
          (S (cPair (cPairPi2 t) 0)))
       (switchPR t
          (codeApp (cPairPi1 (codeNth (t - S (cPairPi1 (pred t))) recs))
             (cPairPi2 (codeNth (t - S (cPairPi2 (pred t))) recs))) 0)).

Definition codeFreeVarTerm (t : nat) : nat :=
  cPairPi1 (codeFreeVarTermTerms t).

Definition codeFreeVarTerms (t : nat) : nat :=
  cPairPi2 (codeFreeVarTermTerms t).

Lemma codeFreeVarTermCorrect :
 forall t : Term,
 codeFreeVarTerm (codeTerm L codeF t) = codeList (freeVarTerm L t).

Lemma codeFreeVarTermsCorrect :
 forall (n : nat) (ts : Terms n),
 codeFreeVarTerms (codeTerms L codeF n ts) = codeList (freeVarTerms L n ts).

Lemma codeFreeVarTermTermsIsPR : isPR 1 codeFreeVarTermTerms.

Lemma codeFreeVarTermIsPR : isPR 1 codeFreeVarTerm.

Lemma codeFreeVarTermsIsPR : isPR 1 codeFreeVarTerms.

Definition codeFreeVarFormula : nat -> nat :=
  evalStrongRec 0
    (fun f recs : nat =>
     switchPR (cPairPi1 f)
       (switchPR (pred (cPairPi1 f))
          (switchPR (pred (pred (cPairPi1 f)))
             (switchPR (pred (pred (pred (cPairPi1 f))))
                (codeFreeVarTerms (cPairPi2 f))
                (codeListRemove (cPairPi1 (cPairPi2 f))
                   (codeNth (f - S (cPairPi2 (cPairPi2 f))) recs)))
             (codeNth (f - S (cPairPi2 f)) recs))
          (codeApp (codeNth (f - S (cPairPi1 (cPairPi2 f))) recs)
             (codeNth (f - S (cPairPi2 (cPairPi2 f))) recs)))
       (codeApp (codeFreeVarTerm (cPairPi1 (cPairPi2 f)))
          (codeFreeVarTerm (cPairPi2 (cPairPi2 f))))).

Lemma codeFreeVarFormulaCorrect :
 forall f : Formula,
 codeFreeVarFormula (codeFormula L codeF codeR f) =
 codeList (freeVarFormula L f).

Lemma codeFreeVarFormulaIsPR : isPR 1 codeFreeVarFormula.

Definition codeFreeVarListFormula : nat -> nat :=
  evalStrongRec 0
    (fun l recs : nat =>
     switchPR l
       (codeApp (codeFreeVarFormula (cPairPi1 (pred l)))
          (codeNth (l - S (cPairPi2 (pred l))) recs)) 0).

Lemma codeFreeVarListFormulaCorrect :
 forall l : list Formula,
 codeFreeVarListFormula (codeList (map (codeFormula L codeF codeR) l)) =
 codeList (freeVarListFormula L l).

Lemma codeFreeVarListFormulaIsPR : isPR 1 codeFreeVarListFormula.

End Code_Free_Vars. *)
Require Import codeSubFormula.
(* codeSubFormula:
Require Import primRec.
Require Import cPair.
Require Import Arith.
Require Import folProp.
Require Import code.
Require Import extEqualNat.
Require Vector.
Require Import codeSubTerm.
Require Import codeFreeVar.
Require Import Max.

Section Code_Substitute_Formula.

Variable L : Language.
Variable codeF : Functions L -> nat.
Variable codeR : Relations L -> nat.

Notation Formula := (Formula L) (only parsing).
Notation Formulas := (Formulas L) (only parsing).
Notation System := (System L) (only parsing).
Notation Term := (Term L) (only parsing).
Notation Terms := (Terms L) (only parsing).
Let var := var L.
Let apply := apply L.
Let codeFormula := codeFormula L codeF codeR.
Let codeTerm := codeTerm L codeF.

Definition cTriple (a b c : nat) : nat := cPair a (cPair b c).

Definition cTriplePi1 (n : nat) : nat := cPairPi1 n.

Definition cTriplePi2 (n : nat) : nat := cPairPi1 (cPairPi2 n).

Definition cTriplePi3 (n : nat) : nat := cPairPi2 (cPairPi2 n).

Lemma cTripleIsPR : isPR 3 cTriple.

Lemma cTriplePi1IsPR : isPR 1 cTriplePi1.

Lemma cTriplePi2IsPR : isPR 1 cTriplePi2.

Lemma cTriplePi3IsPR : isPR 1 cTriplePi3.

Lemma cTripleProj1 : forall a b c : nat, cTriplePi1 (cTriple a b c) = a.

Lemma cTripleProj2 : forall a b c : nat, cTriplePi2 (cTriple a b c) = b.

Lemma cTripleProj3 : forall a b c : nat, cTriplePi3 (cTriple a b c) = c.

Lemma cTripleProj :
 forall a : nat, cTriple (cTriplePi1 a) (cTriplePi2 a) (cTriplePi3 a) = a.

Definition codeNewVar (l : nat) : nat :=
  evalStrongRec 0
    (fun n Hrecs : nat =>
     switchPR n
       (max (S (cPairPi1 (pred n)))
          (codeNth (n - S (cPairPi2 (pred n))) Hrecs)) 0) l.

Lemma codeNewVarCorrect :
 forall l : list nat, codeNewVar (codeList l) = newVar l.

Lemma codeNewVarIsPR : isPR 1 codeNewVar.

Definition checkSubFormulaTrace : nat -> nat :=
  evalStrongRec 0
    (fun trace recs : nat =>
     let v := cTriplePi1 (cTriplePi1 trace) in
     let s := cTriplePi2 (cTriplePi1 trace) in
     let input := cTriplePi3 (cTriplePi1 trace) in
     let output := cTriplePi2 trace in
     let rest := cTriplePi3 trace in
     let type := cPairPi1 input in
     switchPR type
       (switchPR (pred type)
          (switchPR (pred (pred type))
             (switchPR (pred (pred (pred type)))
                (charFunction 2 beq_nat output
                   (cPair type (codeSubTerms (cPairPi2 input) v s)))
                (switchPR
                   (charFunction 2 beq_nat v (cPairPi1 (cPairPi2 input)))
                   (charFunction 2 beq_nat input output)
                   (switchPR
                      (codeIn (cPairPi1 (cPairPi2 input)) (codeFreeVarTerm s))
                      (let nv :=
                         codeNewVar
                           (S
                              (cPair v
                                 (codeApp (codeFreeVarTerm s)
                                    (codeFreeVarFormula
                                       (cPairPi2 (cPairPi2 input)))))) in
                       charFunction 0
                         (beq_nat output
                            (cPair 3 (cPair nv (cTriplePi2 (cPairPi2 rest)))) &&
                          (beq_nat (cTriple v s (cTriplePi2 (cPairPi1 rest)))
                             (cTriplePi1 (cPairPi2 rest)) &&
                           beq_nat
                             (cTriple (cPairPi1 (cPairPi2 input))
                                (cPair 0 nv) (cPairPi2 (cPairPi2 input)))
                             (cTriplePi1 (cPairPi1 rest)))) *
                       (codeNth (trace - S (cPairPi1 rest)) recs *
                        codeNth (trace - S (cPairPi2 rest)) recs))
                      (charFunction 0
                         (beq_nat output
                            (cPair 3
                               (cPair (cPairPi1 (cPairPi2 input))
                                  (cTriplePi2 rest))) &&
                          beq_nat (cTriple v s (cPairPi2 (cPairPi2 input)))
                            (cTriplePi1 rest)) *
                       codeNth (trace - S rest) recs))))
             (charFunction 0
                (beq_nat output (cPair 2 (cTriplePi2 rest)) &&
                 beq_nat (cTriple v s (cPairPi2 input)) (cTriplePi1 rest)) *
              codeNth (trace - S rest) recs))
          (charFunction 0
             (beq_nat output
                (cPair 1
                   (cPair (cTriplePi2 (cPairPi1 rest))
                      (cTriplePi2 (cPairPi2 rest)))) &&
              (beq_nat (cTriple v s (cPairPi1 (cPairPi2 input)))
                 (cTriplePi1 (cPairPi1 rest)) &&
               beq_nat (cTriple v s (cPairPi2 (cPairPi2 input)))
                 (cTriplePi1 (cPairPi2 rest)))) *
           (codeNth (trace - S (cPairPi1 rest)) recs *
            codeNth (trace - S (cPairPi2 rest)) recs)))
       (charFunction 2 beq_nat output
          (cPair 0
             (cPair (codeSubTerm (cPairPi1 (cPairPi2 input)) v s)
                (codeSubTerm (cPairPi2 (cPairPi2 input)) v s))))).

Definition makeTraceImp (f1 : fol.Formula L)
  (f1rec : nat * fol.Term L -> nat) (f2 : fol.Formula L)
  (f2rec : nat * fol.Term L -> nat) (p : nat * fol.Term L) : nat :=
  let v := fst p in
  let s := snd p in
  cTriple (cTriple v (codeTerm s) (codeFormula (impH L f1 f2)))
    (codeFormula (substituteFormula L (impH L f1 f2) v s))
    (cPair (f1rec p) (f2rec p)).

Definition makeTraceNot (f : fol.Formula L) (frec : nat * fol.Term L -> nat)
  (p : nat * fol.Term L) : nat :=
  let v := fst p in
  let s := snd p in
  cTriple (cTriple v (codeTerm s) (codeFormula (notH L f)))
    (codeFormula (substituteFormula L (notH L f) v s)) 
    (frec p).

Definition makeTraceForall (n : nat) (f : fol.Formula L)

Definition makeTrace : fol.Formula L -> nat * fol.Term L -> nat :=
  Formula_depth_rec2 L (fun _ : fol.Formula L => nat * fol.Term L -> nat)
    (fun (t t0 : fol.Term L) (p : nat * fol.Term L) =>
     let v := fst p in
     let s := snd p in
     cTriple (cTriple v (codeTerm s) (codeFormula (equal L t t0)))
       (codeFormula (substituteFormula L (equal L t t0) v s)) 0)
    (fun (r : Relations L) t (p : nat * fol.Term L) =>
     let v := fst p in
     let s := snd p in
     cTriple (cTriple v (codeTerm s) (codeFormula (atomic L r t)))
       (codeFormula (substituteFormula L (atomic L r t) v s)) 0) makeTraceImp
    makeTraceNot makeTraceForall.

Lemma makeTraceImpNice :
 forall (f2 g : fol.Formula L) (z1 z2 : nat * fol.Term L -> nat),

Lemma makeTraceNotNice :
 forall (f2 : fol.Formula L) (z1 z2 : nat * fol.Term L -> nat),

Lemma makeTraceForallNice :
 forall (v0 : nat) (a : fol.Formula L)

Remark makeTrace1 :
 forall (f : fol.Formula L) (v : nat) (s : fol.Term L),

Remark makeTrace2 :
 forall (f : fol.Formula L) (v : nat) (s : fol.Term L),

Lemma makeTraceCorrect :
 forall (f : fol.Formula L) (v : nat) (s : fol.Term L),

Lemma checkTraceCorrect :
 forall (f : fol.Formula L) (v : nat) (s : fol.Term L) (n m : nat),

Lemma switch5IsPR :
 forall (f1 f2 f3 f4 f5 : nat -> nat -> nat) (g : nat -> nat),
 isPR 2 f1 ->
 isPR 2 f2 ->
 isPR 2 f3 ->
 isPR 2 f4 ->
 isPR 2 f5 ->
 isPR 1 g ->
 isPR 2
   (fun n recs : nat =>
    switchPR (g n)
      (switchPR (pred (g n))
         (switchPR (pred (pred (g n)))
            (switchPR (pred (pred (pred (g n)))) (f1 n recs) (f2 n recs))
            (f3 n recs)) (f4 n recs)) (f5 n recs)).

Lemma checkTraceIsPR : isPR 1 checkSubFormulaTrace.

Definition ReplaceTermTermsTerm : nat -> nat -> nat :=
  evalStrongRec 1
    (fun t recs s : nat =>
     cPair
       (switchPR (cPairPi1 t)
          (cPair (cPairPi1 t) (cPairPi2 (codeNth (t - S (cPairPi2 t)) recs)))
          (cPair 0 s))
       (switchPR t
          (S
             (cPair (cPairPi1 (codeNth (t - S (cPairPi1 (pred t))) recs))
                (cPairPi2 (codeNth (t - S (cPairPi2 (pred t))) recs)))) 0)).

Remark ReplaceTermTermsTermIsPR : isPR 2 ReplaceTermTermsTerm.

Definition ReplaceTermTerm (t s : nat) : nat :=
  cPairPi1 (ReplaceTermTermsTerm t s).

Definition ReplaceTermsTerm (t s : nat) : nat :=
  cPairPi2 (ReplaceTermTermsTerm t s).

Lemma ReplaceTermTermIsPR : isPR 2 ReplaceTermTerm.

Lemma ReplaceTermsTermIsPR : isPR 2 ReplaceTermsTerm.

Remark ReplaceTermTermsTermMonotone :
 forall a s1 s2 : nat,
 s1 <= s2 ->
 ReplaceTermTerm a s1 <= ReplaceTermTerm a s2 /\
 ReplaceTermsTerm a s1 <= ReplaceTermsTerm a s2.

Lemma ReplaceTermTermMonotone :
 forall a s1 s2 : nat,
 s1 <= s2 -> ReplaceTermTerm a s1 <= ReplaceTermTerm a s2.

Lemma ReplaceTermsTermMonotone :
 forall a s1 s2 : nat,
 s1 <= s2 -> ReplaceTermsTerm a s1 <= ReplaceTermsTerm a s2.

Remark maxLemma :
 forall a b c d : nat, a <= b -> c <= d -> max a c <= max b d.

Remark maxLemma2 :
 forall a b : list nat, fold_right max 0 a <= fold_right max 0 (a ++ b).
Proof.
intros.
induction a as [| a a0 Hreca].
apply le_O_n.
simpl in |- *.
apply maxLemma.

Remark maxLemma3 :
 forall a b : list nat, fold_right max 0 b <= fold_right max 0 (a ++ b).

Remark maxApp :
 forall a b : list nat,
 {fold_right max 0 (a ++ b) = fold_right max 0 a} +
 {fold_right max 0 (a ++ b) = fold_right max 0 b}.
Proof.
intros.
induction a as [| a a0 Hreca].
simpl in |- *.
auto.
simpl in |- *.
induction (max_dec a (fold_right max 0 (a0 ++ b))).
rewrite a1.
left.
symmetry  in |- *.
apply max_l.
apply le_trans with (max a (fold_right max 0 (a0 ++ b))).
apply le_trans with (max a (fold_right max 0 a0)).
apply le_max_r.
apply maxLemma.
apply le_n.
apply maxLemma2.

Lemma boundSubTerm :
 forall (t : fol.Term L) (v : nat) (s : fol.Term L),
 codeTerm (substituteTerm L t v s) <=
 ReplaceTermTerm (codeTerm t)
   (fold_right max 0 (codeTerm s :: freeVarTerm L t)).
Proof.
intro.
unfold ReplaceTermTerm in |- *.
unfold ReplaceTermsTerm in |- *.
unfold ReplaceTermTermsTerm in |- *.
set
 (A :=
  fun t0 recs s0 : nat =>
  cPair
    (switchPR (cPairPi1 t0)
       (cPair (cPairPi1 t0) (cPairPi2 (codeNth (t0 - S (cPairPi2 t0)) recs)))
       (cPair 0 s0))
    (switchPR t0
       (S
          (cPair (cPairPi1 (codeNth (t0 - S (cPairPi1 (pred t0))) recs))
             (cPairPi2 (codeNth (t0 - S (cPairPi2 (pred t0))) recs)))) 0))
 in *.
assert
 (forall n m : nat,
  m < n ->
  extEqual 1
    (evalComposeFunc 1 1 (Vector.cons _ (evalStrongRecHelp 1 A n) 0 (Vector.nil _))
       (fun b : nat => codeNth (n - S m) b)) (evalStrongRec 1 A m)).
intros.
apply (evalStrongRecHelp2 1). 
assumption.
simpl in H.
elim t using
 Term_Terms_ind
  with
    (P0 := fun (n : nat) (ts : fol.Terms L n) =>
           forall (v : nat) (s : fol.Term L),
           codeTerms L codeF n (substituteTerms L n ts v s) <=
           ReplaceTermsTerm (codeTerms L codeF n ts)
             (fold_right max 0 (codeTerm s :: freeVarTerms L n ts)));
 simpl in |- *; intros; unfold evalStrongRec in |- *;
 unfold evalComposeFunc, evalOneParamList, evalList in |- *;
 repeat rewrite computeEvalStrongRecHelp; unfold compose2 in |- *;
 unfold evalComposeFunc, evalOneParamList, evalList in |- *; 
 simpl in |- *; repeat rewrite cPairProjections1.
unfold A in |- *.
simpl in |- *.
repeat rewrite cPairProjections1.
replace (codeTerm (fol.var L n)) with (cPair 0 n); [ idtac | reflexivity ].
repeat rewrite cPairProjections1.
simpl in |- *.
induction (eq_nat_dec v n).
eapply le_trans; [ idtac | apply cPairLe2 ].
apply le_max_l.
replace (codeTerm (fol.var L n)) with (cPair 0 n); [ idtac | reflexivity ].
apply cPairLe3.
apply le_n.
eapply le_trans; [ idtac | apply le_max_r ].
apply le_max_l.
unfold A in |- *.
repeat rewrite cPairProjections1.
replace (codeTerm (fol.apply L f t0)) with
 (cPair (S (codeF f)) (codeTerms L codeF _ t0)); [ idtac | reflexivity ].
repeat rewrite cPairProjections1.
rewrite
 H
   with
   (m := 
     cPairPi2
       (cPair (S (codeF f))
          (codeTerms L codeF (arity L (inr (Relations L) f)) t0))).
simpl in |- *.
replace
 (codeTerm
    (fol.apply L f (substituteTerms L (arity L (inr (Relations L) f)) t0 v s)))
 with
 (cPair (S (codeF f))
    (codeTerms L codeF _
       (substituteTerms L (arity L (inr (Relations L) f)) t0 v s)));
 [ idtac | reflexivity ].
apply cPairLe3.
apply le_n.
unfold ReplaceTermsTerm in H0.
unfold ReplaceTermTermsTerm in H0.
fold A in H0.
repeat rewrite cPairProjections2.
apply (H0 v s).
repeat rewrite cPairProjections2.
apply cPairLt2.
apply le_O_n.
replace
 (codeTerms L codeF (S n)
    (Tcons L n (substituteTerm L t0 v s) (substituteTerms L n t1 v s))) with
 (S
    (cPair (codeTerm (substituteTerm L t0 v s))
       (codeTerms L codeF n (substituteTerms L n t1 v s))));
 [ idtac | reflexivity ].
unfold ReplaceTermsTerm in |- *.
unfold ReplaceTermsTerm in H1.
unfold ReplaceTermTermsTerm in |- *.
unfold ReplaceTermTermsTerm in H1.
fold A in |- *.
fold A in H1.
unfold evalStrongRec in |- *.
unfold evalComposeFunc, evalOneParamList, evalList in |- *.
repeat rewrite computeEvalStrongRecHelp.
unfold compose2 in |- *.
unfold evalComposeFunc, evalOneParamList, evalList in |- *.
simpl in |- *.
repeat rewrite cPairProjections1.
unfold A at 1 in |- *.
repeat rewrite cPairProjections2.
repeat rewrite H.
replace (codeTerms L codeF (S n) (Tcons L n t0 t1)) with
 (S (cPair (codeTerm t0) (codeTerms L codeF n t1))); 
 [ idtac | reflexivity ].
simpl in |- *.
repeat rewrite cPairProjections1.
apply le_n_S.
apply cPairLe3.
eapply le_trans.
apply H0.
apply
 (ReplaceTermTermMonotone (codeTerm t0)
    (max (codeTerm s) (fold_right max 0 (freeVarTerm L t0)))
    (max (codeTerm s)
       (fold_right max 0 (freeVarTerms L (S n) (Tcons L n t0 t1))))).
apply maxLemma.
apply le_n.
replace (freeVarTerms L (S n) (Tcons L n t0 t1)) with
 (freeVarTerm L t0 ++ freeVarTerms L n t1); [ idtac | reflexivity ].
apply maxLemma2.
eapply le_trans.
apply H1.
repeat rewrite cPairProjections2.
apply
 (ReplaceTermsTermMonotone (codeTerms L codeF n t1)
    (max (codeTerm s) (fold_right max 0 (freeVarTerms L n t1)))
    (max (codeTerm s)
       (fold_right max 0 (freeVarTerms L (S n) (Tcons L n t0 t1))))).
apply maxLemma.
apply le_n.
replace (freeVarTerms L (S n) (Tcons L n t0 t1)) with
 (freeVarTerm L t0 ++ freeVarTerms L n t1); [ idtac | reflexivity ].
apply maxLemma3.

Lemma boundSubTerms :
 forall (n : nat) (ts : fol.Terms L n) (v : nat) (s : fol.Term L),
 codeTerms L codeF n (substituteTerms L n ts v s) <=
 ReplaceTermsTerm (codeTerms L codeF n ts)
   (fold_right max 0 (codeTerm s :: freeVarTerms L n ts)).
Proof.
intros n ts.
unfold ReplaceTermTerm in |- *.
unfold ReplaceTermsTerm in |- *.
unfold ReplaceTermTermsTerm in |- *.
set
 (A :=
  fun t0 recs s0 : nat =>
  cPair
    (switchPR (cPairPi1 t0)
       (cPair (cPairPi1 t0) (cPairPi2 (codeNth (t0 - S (cPairPi2 t0)) recs)))
       (cPair 0 s0))
    (switchPR t0
       (S
          (cPair (cPairPi1 (codeNth (t0 - S (cPairPi1 (pred t0))) recs))
             (cPairPi2 (codeNth (t0 - S (cPairPi2 (pred t0))) recs)))) 0))
 in *.
assert
 (forall n m : nat,
  m < n ->
  extEqual 1
    (evalComposeFunc 1 1 (Vector.cons _ (evalStrongRecHelp 1 A n) 0 (Vector.nil _))
       (fun b : nat => codeNth (n - S m) b)) (evalStrongRec 1 A m)).
intros.
apply (evalStrongRecHelp2 1). 
assumption.
simpl in H.
induction ts as [| n t ts Hrects]; simpl in |- *; intros.
apply le_O_n.
replace
 (codeTerms L codeF (S n)
    (Tcons L n (substituteTerm L t v s) (substituteTerms L n ts v s))) with
 (S
    (cPair (codeTerm (substituteTerm L t v s))
       (codeTerms L codeF n (substituteTerms L n ts v s))));
 [ idtac | reflexivity ].
unfold evalStrongRec in |- *;
 unfold evalComposeFunc, evalOneParamList, evalList in |- *;
 repeat rewrite computeEvalStrongRecHelp; unfold compose2 in |- *;
 unfold evalComposeFunc, evalOneParamList, evalList in |- *; 
 simpl in |- *; repeat rewrite cPairProjections1.
unfold A at 1 in |- *.
repeat rewrite cPairProjections2.
repeat rewrite H.
replace (codeTerms L codeF (S n) (Tcons L n t ts)) with
 (S (cPair (codeTerm t) (codeTerms L codeF n ts))); 
 [ idtac | reflexivity ].
simpl in |- *.
repeat rewrite cPairProjections1.
apply le_n_S.
apply cPairLe3.
eapply le_trans.
apply boundSubTerm.
apply
 (ReplaceTermTermMonotone (codeTerm t)
    (max (codeTerm s) (fold_right max 0 (freeVarTerm L t)))
    (max (codeTerm s)
       (fold_right max 0 (freeVarTerms L (S n) (Tcons L n t ts))))).
apply maxLemma.
apply le_n.
replace (freeVarTerms L (S n) (Tcons L n t ts)) with
 (freeVarTerm L t ++ freeVarTerms L n ts); [ idtac | reflexivity ].
apply maxLemma2.
eapply le_trans.
apply Hrects.
repeat rewrite cPairProjections2.
apply
 (ReplaceTermsTermMonotone (codeTerms L codeF n ts)
    (max (codeTerm s) (fold_right max 0 (freeVarTerms L n ts)))
    (max (codeTerm s)
       (fold_right max 0 (freeVarTerms L (S n) (Tcons L n t ts))))).
apply maxLemma.
apply le_n.
replace (freeVarTerms L (S n) (Tcons L n t ts)) with
 (freeVarTerm L t ++ freeVarTerms L n ts); [ idtac | reflexivity ].
apply maxLemma3.

Lemma ReplaceTermTermSub :
 forall (t : fol.Term L) (v w s2 : nat),

Lemma ReplaceTermsTermSub :
 forall (n : nat) (ts : fol.Terms L n) (v w s2 : nat),

Definition ReplaceFormulaTerm : nat -> nat -> nat :=
  evalStrongRec 1
    (fun f recs s : nat =>
     switchPR (cPairPi1 f)
       (switchPR (pred (cPairPi1 f))
          (switchPR (pred (pred (cPairPi1 f)))
             (switchPR (pred (pred (pred (cPairPi1 f))))
                (cPair (cPairPi1 f) (ReplaceTermsTerm (cPairPi2 f) s))
                (cPair 3
                   (cPair s (codeNth (f - S (cPairPi2 (cPairPi2 f))) recs))))
             (cPair 2 (codeNth (f - S (cPairPi2 f)) recs)))
          (cPair 1
             (cPair (codeNth (f - S (cPairPi1 (cPairPi2 f))) recs)
                (codeNth (f - S (cPairPi2 (cPairPi2 f))) recs))))
       (cPair 0
          (cPair (ReplaceTermTerm (cPairPi1 (cPairPi2 f)) s)
             (ReplaceTermTerm (cPairPi2 (cPairPi2 f)) s)))).

Lemma ReplaceFormulaTermIsPR : isPR 2 ReplaceFormulaTerm.

Lemma ReplaceFormulaTermMonotone :
 forall a s1 s2 : nat,
 s1 <= s2 -> ReplaceFormulaTerm a s1 <= ReplaceFormulaTerm a s2.

Fixpoint varFormula (f : fol.Formula L) : list nat :=
  match f with
  | equal t s => freeVarTerm L t ++ freeVarTerm L s
  | atomic r ts => freeVarTerms L _ ts
  | impH A B => varFormula A ++ varFormula B
  | notH A => varFormula A
  | forallH v A => v :: varFormula A
  end.

Lemma ReplaceFormulaTermSub :
 forall (f : fol.Formula L) (v w s2 : nat),

Remark codeTermFreeVar :
 forall s : fol.Term L, fold_right max 0 (freeVarTerm L s) <= codeTerm s.

Remark maxVarFreeVar :
 forall f : fol.Formula L,
 fold_right max 0 (freeVarFormula L f) <= fold_right max 0 (varFormula f).
Proof.
intros.
induction f as [t t0| r t| f1 Hrecf1 f0 Hrecf0| f Hrecf| n f Hrecf];
 simpl in |- *.
apply le_n.
apply le_n.
induction (maxApp (freeVarFormula L f1) (freeVarFormula L f0)).
rewrite a.
eapply le_trans.
apply Hrecf1.
apply maxLemma2.
rewrite b.
eapply le_trans.
apply Hrecf0.
apply maxLemma3.
assumption.
apply le_trans with (fold_right max 0 (freeVarFormula L f)).
clear Hrecf.
induction (freeVarFormula L f).
simpl in |- *.
apply le_O_n.
simpl in |- *.
induction (eq_nat_dec a n).
eapply le_trans.
apply IHl.
apply le_max_r.
simpl in |- *.
apply maxLemma.

Remark maxSubTerm :
 forall (t : fol.Term L) (v : nat) (s : fol.Term L),
 fold_right max 0 (freeVarTerm L (substituteTerm L t v s)) <=
 fold_right max 0 (freeVarTerm L s ++ freeVarTerm L t).
Proof.
intros.
elim t using
 Term_Terms_ind
  with
    (P0 := fun (n : nat) (ts : fol.Terms L n) =>
           fold_right max 0 (freeVarTerms L n (substituteTerms L n ts v s)) <=
           fold_right max 0 (freeVarTerm L s ++ freeVarTerms L n ts));
 simpl in |- *; intros.
induction (eq_nat_dec v n).
apply maxLemma2.
apply maxLemma3.
apply H.
apply le_O_n.
replace
 (freeVarTerms L (S n)
    (Tcons L n (substituteTerm L t0 v s) (substituteTerms L n t1 v s))) with
 (freeVarTerm L (substituteTerm L t0 v s) ++
  freeVarTerms L n (substituteTerms L n t1 v s)).
replace (freeVarTerms L (S n) (Tcons L n t0 t1)) with
 (freeVarTerm L t0 ++ freeVarTerms L n t1).
induction
 (maxApp (freeVarTerm L (substituteTerm L t0 v s))
    (freeVarTerms L n (substituteTerms L n t1 v s))).
rewrite a.
eapply le_trans.
apply H.
induction (maxApp (freeVarTerm L s) (freeVarTerm L t0)).
rewrite a0.
apply maxLemma2.
rewrite b.
apply
 le_trans with (fold_right max 0 (freeVarTerm L t0 ++ freeVarTerms L n t1)).
apply maxLemma2.
apply maxLemma3.
rewrite b.
eapply le_trans.
apply H0.
induction (maxApp (freeVarTerm L s) (freeVarTerms L n t1)).
rewrite a.
apply maxLemma2.
rewrite b0.
apply
 le_trans with (fold_right max 0 (freeVarTerm L t0 ++ freeVarTerms L n t1)).
apply maxLemma3.
apply maxLemma3.

Remark maxSubTerms :
 forall (n : nat) (ts : fol.Terms L n) (v : nat) (s : fol.Term L),
 fold_right max 0 (freeVarTerms L n (substituteTerms L n ts v s)) <=
 fold_right max 0 (freeVarTerm L s ++ freeVarTerms L n ts).
Proof.
intros.
induction ts as [| n t ts Hrects]; simpl in |- *; intros.
apply le_O_n.
replace
 (freeVarTerms L (S n)
    (Tcons L n (substituteTerm L t v s) (substituteTerms L n ts v s))) with
 (freeVarTerm L (substituteTerm L t v s) ++
  freeVarTerms L n (substituteTerms L n ts v s)).
replace (freeVarTerms L (S n) (Tcons L n t ts)) with
 (freeVarTerm L t ++ freeVarTerms L n ts).
induction
 (maxApp (freeVarTerm L (substituteTerm L t v s))
    (freeVarTerms L n (substituteTerms L n ts v s))).
rewrite a.
eapply le_trans.
apply maxSubTerm.
induction (maxApp (freeVarTerm L s) (freeVarTerm L t)).
rewrite a0.
apply maxLemma2.
rewrite b.
apply
 le_trans with (fold_right max 0 (freeVarTerm L t ++ freeVarTerms L n ts)).
apply maxLemma2.
apply maxLemma3.
rewrite b.
eapply le_trans.
apply Hrects.
induction (maxApp (freeVarTerm L s) (freeVarTerms L n ts)).
rewrite a.
apply maxLemma2.
rewrite b0.
apply
 le_trans with (fold_right max 0 (freeVarTerm L t ++ freeVarTerms L n ts)).
apply maxLemma3.
apply maxLemma3.

Definition pow3 : nat -> nat :=
  nat_rec (fun _ => nat) 1 (fun _ rec : nat => rec + (rec + rec)).

Lemma pow3IsPR : isPR 1 pow3.

Lemma pow3Monotone : forall a b : nat, a <= b -> pow3 a <= pow3 b.

Lemma pow3Min : forall a : nat, 1 <= pow3 a.

Remark mapListLemma :
 forall l : list nat, fold_right max 0 (map S l) <= S (fold_right max 0 l).
Proof.
intros.
induction l as [| a l Hrecl].
simpl in |- *.
auto.
simpl in |- *.
induction (fold_right max 0 (map S l)).
apply le_n_S.
apply le_max_l.
apply le_n_S.
apply maxLemma.

Remark boundSubFormulaHelp2 :
 forall (a : fol.Formula L) (v0 : nat) (s : fol.Term L),
 newVar (v0 :: freeVarTerm L s ++ freeVarFormula L a) <=
 S
   (fold_right max 0
      (v0 :: fold_right max 0 (freeVarTerm L s) :: varFormula a)).
intros.
unfold newVar in |- *.
apply
 le_trans
  with (S (fold_right max 0 (v0 :: freeVarTerm L s ++ freeVarFormula L a))).
apply mapListLemma.
apply le_n_S.
simpl in |- *.
apply maxLemma.

Remark boundSubFormulaHelp1 :
 forall (b a : fol.Formula L) (v0 v : nat) (s : fol.Term L),
 fold_right max 0
   (varFormula
      (substituteFormula L b v
         (fol.var L (newVar (v0 :: freeVarTerm L s ++ freeVarFormula L a))))) <=
 pow3 (depth L b) + pow3 (depth L b) +
 max v0
   (max (fold_right max 0 (freeVarTerm L s))
      (max v
         (max (fold_right max 0 (varFormula b))
            (fold_right max 0 (varFormula a))))).
Proof.
intro.
elim b using Formula_depth_ind2; intros;
 set (nv := newVar (v0 :: freeVarTerm L s ++ freeVarFormula L a)) in *.
simpl in |- *.
apply le_S.
induction
 (maxApp (freeVarTerm L (substituteTerm L t v (fol.var L nv)))
    (freeVarTerm L (substituteTerm L t0 v (fol.var L nv)))).
rewrite a0.
eapply le_trans.
apply maxSubTerm.
simpl in |- *.
apply (max_case2 nv (fold_right max 0 (freeVarTerm L t))).
eapply le_trans.
apply (boundSubFormulaHelp2 a v0 s).
apply le_n_S.
simpl in |- *.
repeat apply maxLemma; try apply le_n.
eapply le_trans; [ idtac | apply le_max_r ].
apply le_max_r.
apply le_S.
do 3 (eapply le_trans; [ idtac | apply le_max_r ]).
eapply le_trans; [ idtac | apply le_max_l ].
apply maxLemma2.
rewrite b0.
eapply le_trans.
apply maxSubTerm.
simpl in |- *.
apply (max_case2 nv (fold_right max 0 (freeVarTerm L t0))).
eapply le_trans.
apply (boundSubFormulaHelp2 a v0 s).
 apply le_n_S.
simpl in |- *.
repeat apply maxLemma; try apply le_n.
eapply le_trans; [ idtac | apply le_max_r ].
apply le_max_r.
apply le_S.
do 3 (eapply le_trans; [ idtac | apply le_max_r ]).
eapply le_trans; [ idtac | apply le_max_l ].
apply maxLemma3.
eapply le_trans.
simpl in |- *.
apply maxSubTerms.
simpl in |- *.
apply le_S.
apply
 (max_case2 nv
    (fold_right max 0 (freeVarTerms L (arity L (inl (Functions L) r)) t))).
eapply le_trans.
apply (boundSubFormulaHelp2 a v0 s).
apply le_n_S.
simpl in |- *.
repeat apply maxLemma; try apply le_n.
eapply le_trans; [ idtac | apply le_max_r ].
apply le_max_r.
apply le_S.
do 3 (eapply le_trans; [ idtac | apply le_max_r ]).
eapply le_trans; [ idtac | apply le_max_l ].
apply le_n.
rewrite subFormulaImp.
simpl in |- *.
induction
 (maxApp (varFormula (substituteFormula L f v (fol.var L nv)))
    (varFormula (substituteFormula L f0 v (fol.var L nv)))).
rewrite a0.
eapply le_trans.
apply (H a v0 v s).
apply plus_le_compat.
eapply le_trans; [ idtac | apply le_plus_l ].
assert (pow3 (depth L f) <= pow3 (max (depth L f) (depth L f0))).
apply pow3Monotone.
apply le_max_l.
apply plus_le_compat.
assumption.
eapply le_trans; [ idtac | apply le_plus_l ].
assumption.
repeat apply maxLemma; try apply le_n.
apply maxLemma2.
rewrite b0.
eapply le_trans.
apply (H0 a v0 v s).
apply plus_le_compat.
eapply le_trans; [ idtac | apply le_plus_l ].
assert (pow3 (depth L f0) <= pow3 (max (depth L f) (depth L f0))).
apply pow3Monotone.
apply le_max_r.
apply plus_le_compat.
assumption.
eapply le_trans; [ idtac | apply le_plus_l ].
assumption.
repeat apply maxLemma; try apply le_n.
apply maxLemma3.
rewrite subFormulaNot.
eapply le_trans.
apply (H a v0 v s).
apply plus_le_compat.
simpl in |- *.
eapply le_trans; [ idtac | apply le_plus_l ].
apply le_plus_r.
apply le_n.
clear nv.
rewrite subFormulaForall.
induction (eq_nat_dec v v1).
eapply le_trans; [ idtac | apply le_plus_r ].
do 3 (eapply le_trans; [ idtac | apply le_max_r ]).
apply le_max_l.
induction
 (In_dec eq_nat_dec v
    (freeVarTerm L
       (fol.var L (newVar (v0 :: freeVarTerm L s ++ freeVarFormula L a0))))).
simpl in |- *.
apply
 (max_case2
    (newVar
       (v1
        :: newVar (v0 :: freeVarTerm L s ++ freeVarFormula L a0)
           :: freeVarFormula L a))
    (fold_right max 0
       (varFormula
          (substituteFormula L
             (substituteFormula L a v
                (fol.var L
                   (newVar
                      (v1
                       :: newVar
                            (v0 :: freeVarTerm L s ++ freeVarFormula L a0)
                          :: freeVarFormula L a)))) v1
             (fol.var L
                (newVar (v0 :: freeVarTerm L s ++ freeVarFormula L a0))))))).
unfold newVar at 1 in |- *.
eapply le_trans.
apply mapListLemma.
apply
 le_trans
  with
    (1 + 1 +
     max v0
       (max (fold_right max 0 (freeVarTerm L s))
          (max v1
             (max (max v (fold_right max 0 (varFormula a)))
                (fold_right max 0 (varFormula a0)))))).
simpl in |- *.
apply le_n_S.
apply
 (max_case2 v1
    (max (newVar (v0 :: freeVarTerm L s ++ freeVarFormula L a0))
       (fold_right max 0 (freeVarFormula L a)))).
apply le_S.
do 2 (eapply le_trans; [ idtac | apply le_max_r ]).
apply le_max_l.
apply
 (max_case2 (newVar (v0 :: freeVarTerm L s ++ freeVarFormula L a0))
    (fold_right max 0 (freeVarFormula L a))).
eapply le_trans.
apply boundSubFormulaHelp2.
apply le_n_S.
simpl in |- *.
repeat apply maxLemma; try apply le_n.
eapply le_trans; [ idtac | apply le_max_r ].
apply le_max_r.
apply le_S.
do 3 (eapply le_trans; [ idtac | apply le_max_r ]).
eapply le_trans; [ idtac | apply le_max_l ].
eapply le_trans.
apply maxVarFreeVar.
apply le_max_r.
apply plus_le_compat.
eapply le_trans; [ idtac | apply le_plus_r ].
apply plus_le_compat.
apply pow3Min.
simpl in |- *.
eapply le_trans; [ idtac | apply le_plus_r ].
apply pow3Min.
apply le_n.
eapply le_trans.
apply H.
eapply eqDepth.
symmetry  in |- *.
apply subFormulaDepth.
apply depthForall.
rewrite subFormulaDepth.
rewrite (plus_assoc (pow3 (depth L a)) (pow3 (depth L a)) (pow3 (depth L a))).
repeat rewrite (plus_assoc_reverse (pow3 (depth L a) + pow3 (depth L a))).
apply plus_le_compat.
apply le_n.
apply
 (max_case2 v0
    (max (fold_right max 0 (freeVarTerm L s))
       (max v1
          (max
             (fold_right max 0
                (varFormula
                   (substituteFormula L a v
                      (fol.var L
                         (newVar
                            (v1
                             :: newVar
                                  (v0
                                   :: freeVarTerm L s ++ freeVarFormula L a0)
                                :: freeVarFormula L a))))))
             (fold_right max 0 (varFormula a0)))))).
eapply le_trans; [ idtac | apply le_plus_r ].
apply le_max_l.
apply
 (max_case2 (fold_right max 0 (freeVarTerm L s))
    (max v1
       (max
          (fold_right max 0
             (varFormula
                (substituteFormula L a v
                   (fol.var L
                      (newVar
                         (v1
                          :: newVar
                               (v0 :: freeVarTerm L s ++ freeVarFormula L a0)
                             :: freeVarFormula L a))))))
          (fold_right max 0 (varFormula a0))))).
eapply le_trans; [ idtac | apply le_plus_r ].
eapply le_trans; [ idtac | apply le_max_r ].
apply le_max_l.
apply
 (max_case2 v1
    (max
       (fold_right max 0
          (varFormula
             (substituteFormula L a v
                (fol.var L
                   (newVar
                      (v1
                       :: newVar
                            (v0 :: freeVarTerm L s ++ freeVarFormula L a0)
                          :: freeVarFormula L a))))))
       (fold_right max 0 (varFormula a0)))).
eapply le_trans; [ idtac | apply le_plus_r ].
do 2 (eapply le_trans; [ idtac | apply le_max_r ]).
apply le_max_l.
apply
 (max_case2
    (fold_right max 0
       (varFormula
          (substituteFormula L a v
             (fol.var L
                (newVar
                   (v1
                    :: newVar (v0 :: freeVarTerm L s ++ freeVarFormula L a0)
                       :: freeVarFormula L a))))))
    (fold_right max 0 (varFormula a0))).
eapply le_trans.
apply
 H
  with
    (b := a)
    (v := v)
    (v0 := v1)
    (a := a)
    (s := var (newVar (v0 :: freeVarTerm L s ++ freeVarFormula L a0))).
apply depthForall.
rewrite
 (plus_comm (pow3 (depth L a))
    (pow3 (depth L a) + pow3 (depth L a) + pow3 (depth L a)))
 .
repeat rewrite (plus_assoc_reverse (pow3 (depth L a) + pow3 (depth L a))).
apply plus_le_compat.
apply le_n.
apply
 (max_case2 v1
    (max
       (fold_right max 0
          (freeVarTerm L
             (var (newVar (v0 :: freeVarTerm L s ++ freeVarFormula L a0)))))
       (max v
          (max (fold_right max 0 (varFormula a))
             (fold_right max 0 (varFormula a)))))).
eapply le_trans; [ idtac | apply le_plus_r ].
do 2 (eapply le_trans; [ idtac | apply le_max_r ]).
apply le_max_l.
apply
 (max_case2
    (fold_right max 0
       (freeVarTerm L
          (var (newVar (v0 :: freeVarTerm L s ++ freeVarFormula L a0)))))
    (max v
       (max (fold_right max 0 (varFormula a))
          (fold_right max 0 (varFormula a))))).
simpl in |- *.
apply (max_case2 (newVar (v0 :: freeVarTerm L s ++ freeVarFormula L a0)) 0).
eapply le_trans.
apply boundSubFormulaHelp2.
apply
 le_trans
  with
    (1 +
     max v0
       (max (fold_right max 0 (freeVarTerm L s))
          (max v1
             (max (max v (fold_right max 0 (varFormula a)))
                (fold_right max 0 (varFormula a0)))))).
simpl in |- *.
apply le_n_S.
repeat apply maxLemma; try apply le_n.
repeat (eapply le_trans; [ idtac | apply le_max_r ]).
apply le_n.
apply plus_le_compat.
eapply le_trans; [ idtac | apply le_plus_r ].
apply pow3Min.
apply le_n.
apply le_O_n.
eapply le_trans; [ idtac | apply le_plus_r ].
do 3 (eapply le_trans; [ idtac | apply le_max_r ]).
apply
 (max_case2 v
    (max (fold_right max 0 (varFormula a)) (fold_right max 0 (varFormula a)))).
eapply le_trans; [ idtac | apply le_max_l ].
apply le_max_l.
apply
 (max_case2 (fold_right max 0 (varFormula a))
    (fold_right max 0 (varFormula a)));
 (eapply le_trans; [ idtac | apply le_max_l ]; apply le_max_r).
eapply le_trans; [ idtac | apply le_plus_r ].
repeat (eapply le_trans; [ idtac | apply le_max_r ]).
apply le_n.
simpl in |- *.
apply
 (max_case2 v
    (fold_right max 0
       (varFormula
          (substituteFormula L a v1
             (fol.var L
                (newVar (v0 :: freeVarTerm L s ++ freeVarFormula L a0))))))).
eapply le_trans; [ idtac | apply le_plus_r ].
do 3 (eapply le_trans; [ idtac | apply le_max_r ]).
eapply le_trans; [ idtac | apply le_max_l ].
apply le_max_l.
eapply le_trans.
apply H.
apply depthForall.
apply plus_le_compat.
eapply le_trans; [ idtac | apply le_plus_r ].
apply plus_le_compat.
apply le_n.
apply le_plus_l.
repeat apply maxLemma; try apply le_n.

Remark boundSubFormulaHelp :
 forall (f : fol.Formula L) (v : nat) (s : fol.Term L),
 codeFormula (substituteFormula L f v s) <=
 ReplaceFormulaTerm (codeFormula f)
   (max (codeTerm s)
      (pow3 (depth L f) +
       fold_right max 0 (v :: freeVarTerm L s ++ varFormula f))).
Proof.
intro.
unfold ReplaceFormulaTerm in |- *.
set
 (A :=
  fun f0 recs s0 : nat =>
  switchPR (cPairPi1 f0)
    (switchPR (pred (cPairPi1 f0))
       (switchPR (pred (pred (cPairPi1 f0)))
          (switchPR (pred (pred (pred (cPairPi1 f0))))
             (cPair (cPairPi1 f0) (ReplaceTermsTerm (cPairPi2 f0) s0))
             (cPair 3
                (cPair s0 (codeNth (f0 - S (cPairPi2 (cPairPi2 f0))) recs))))
          (cPair 2 (codeNth (f0 - S (cPairPi2 f0)) recs)))
       (cPair 1
          (cPair (codeNth (f0 - S (cPairPi1 (cPairPi2 f0))) recs)
             (codeNth (f0 - S (cPairPi2 (cPairPi2 f0))) recs))))
    (cPair 0
       (cPair (ReplaceTermTerm (cPairPi1 (cPairPi2 f0)) s0)
          (ReplaceTermTerm (cPairPi2 (cPairPi2 f0)) s0)))) 
 in *.
assert
 (forall n m : nat,
  m < n ->
  extEqual 1
    (evalComposeFunc 1 1 (Vector.cons _ (evalStrongRecHelp 1 A n) 0 (Vector.nil _))
       (fun b : nat => codeNth (n - S m) b)) (evalStrongRec 1 A m)).
intros.
apply (evalStrongRecHelp2 1). 
assumption.
simpl in H.
elim f using Formula_depth_ind2; intros.
unfold evalStrongRec in |- *.
unfold evalComposeFunc, evalOneParamList, evalList in |- *.
repeat rewrite computeEvalStrongRecHelp.
unfold compose2 in |- *.
unfold evalComposeFunc, evalOneParamList, evalList in |- *.
set
 (C :=
  max (codeTerm s)
    (pow3 (depth L (equal L t t0)) +
     fold_right max 0 (v :: freeVarTerm L s ++ varFormula (equal L t t0))))
 in *.
simpl in |- *.
repeat rewrite cPairProjections1.
unfold A at 1 in |- *.
repeat first [ rewrite cPairProjections1 | rewrite cPairProjections2 ].
simpl in |- *.
apply cPairLe3.
apply le_n.
apply cPairLe3.
apply
 le_trans
  with
    (ReplaceTermTerm (codeTerm t)
       (fold_right max 0 (codeTerm s :: freeVarTerm L t))).
apply boundSubTerm.
apply ReplaceTermTermMonotone.
unfold C in |- *.
simpl in |- *.
apply maxLemma.
apply le_n.
apply le_S.
eapply le_trans; [ idtac | apply le_max_r ].
eapply le_trans; [ idtac | apply maxLemma3 ].
apply maxLemma2.
apply
 le_trans
  with
    (ReplaceTermTerm (codeTerm t0)
       (fold_right max 0 (codeTerm s :: freeVarTerm L t0))).
apply boundSubTerm.
apply ReplaceTermTermMonotone.
unfold C in |- *.
simpl in |- *.
apply maxLemma.
apply le_n.
apply le_S.
eapply le_trans; [ idtac | apply le_max_r ].
eapply le_trans; [ idtac | apply maxLemma3 ].
apply maxLemma3.
unfold evalStrongRec in |- *.
unfold evalComposeFunc, evalOneParamList, evalList in |- *.
repeat rewrite computeEvalStrongRecHelp.
unfold compose2 in |- *.
unfold evalComposeFunc, evalOneParamList, evalList in |- *.
set
 (C :=
  max (codeTerm s)
    (pow3 (depth L (atomic L r t)) +
     fold_right max 0 (v :: freeVarTerm L s ++ varFormula (atomic L r t))))
 in *.
simpl in |- *.
repeat rewrite cPairProjections1.
unfold A at 1 in |- *.
repeat first [ rewrite cPairProjections1 | rewrite cPairProjections2 ].
simpl in |- *.
apply cPairLe3.
apply le_n.
apply
 le_trans
  with
    (ReplaceTermsTerm (codeTerms L codeF _ t)
       (fold_right max 0 (codeTerm s :: freeVarTerms L _ t))).
apply boundSubTerms.
apply ReplaceTermsTermMonotone.
unfold C in |- *.
simpl in |- *.
apply maxLemma.
apply le_n.
apply le_S.
eapply le_trans; [ idtac | apply le_max_r ].
apply maxLemma3.
rewrite subFormulaImp.
set
 (C :=
  max (codeTerm s)
    (pow3 (depth L (impH L f0 f1)) +
     fold_right max 0 (v :: freeVarTerm L s ++ varFormula (impH L f0 f1))))
 in *.
unfold evalStrongRec in |- *.
unfold evalComposeFunc, evalOneParamList, evalList in |- *.
repeat rewrite computeEvalStrongRecHelp.
unfold compose2 in |- *.
unfold evalComposeFunc, evalOneParamList, evalList in |- *.
simpl in |- *.
repeat rewrite cPairProjections1.
unfold A at 1 in |- *.
repeat first [ rewrite cPairProjections1 | rewrite cPairProjections2 ].
rewrite H with (m := codeFormula f0).
rewrite H with (m := codeFormula f1).
simpl in |- *.
apply cPairLe3.
apply le_n.
apply cPairLe3.
apply
 le_trans
  with
    (evalStrongRec 1 A (codeFormula f0)
       (max (codeTerm s)
          (pow3 (depth L f0) +
           fold_right max 0 (v :: freeVarTerm L s ++ varFormula f0)))).
auto.
apply ReplaceFormulaTermMonotone.
unfold C in |- *.
apply maxLemma.
apply le_n.
apply plus_le_compat.
apply pow3Monotone.
simpl in |- *.
apply le_S.
apply le_max_l.
simpl in |- *.
apply maxLemma.
apply le_n.
rewrite ass_app.
apply maxLemma2.
apply
 le_trans
  with
    (evalStrongRec 1 A (codeFormula f1)
       (max (codeTerm s)
          (pow3 (depth L f1) +
           fold_right max 0 (v :: freeVarTerm L s ++ varFormula f1)))).
auto.
apply ReplaceFormulaTermMonotone.
unfold C in |- *.
apply maxLemma.
apply le_n.
apply plus_le_compat.
apply pow3Monotone.
simpl in |- *.
apply le_S.
apply le_max_r.
simpl in |- *.
apply maxLemma.
apply le_n.
induction (maxApp (freeVarTerm L s) (varFormula f1)).
rewrite a.
apply maxLemma2.
rewrite b.
eapply le_trans; [ idtac | apply maxLemma3 ].
apply maxLemma3.
eapply le_lt_trans; [ idtac | apply cPairLt2 ].
apply cPairLe2.
eapply le_lt_trans; [ idtac | apply cPairLt2 ].
apply cPairLe1.
rewrite subFormulaNot.
set
 (C :=
  max (codeTerm s)
    (pow3 (depth L (notH L f0)) +
     fold_right max 0 (v :: freeVarTerm L s ++ varFormula (notH L f0)))) 
 in *.
unfold evalStrongRec in |- *.
unfold evalComposeFunc, evalOneParamList, evalList in |- *.
repeat rewrite computeEvalStrongRecHelp.
unfold compose2 in |- *.
unfold evalComposeFunc, evalOneParamList, evalList in |- *.
simpl in |- *.
repeat rewrite cPairProjections1.
unfold A at 1 in |- *.
repeat first [ rewrite cPairProjections1 | rewrite cPairProjections2 ].
rewrite H with (m := codeFormula f0).
simpl in |- *.
apply cPairLe3.
apply le_n.
apply
 le_trans
  with
    (evalStrongRec 1 A (codeFormula f0)
       (max (codeTerm s)
          (pow3 (depth L f0) +
           fold_right max 0 (v :: freeVarTerm L s ++ varFormula f0)))).
auto.
apply ReplaceFormulaTermMonotone.
unfold C in |- *.
apply maxLemma.
apply le_n.
apply plus_le_compat.
apply pow3Monotone.
simpl in |- *.
apply le_n_Sn.
apply le_n.
apply cPairLt2.
set
 (C :=
  max (codeTerm s)
    (pow3 (depth L (forallH L v a)) +
     fold_right max 0 (v0 :: freeVarTerm L s ++ varFormula (forallH L v a))))
 in *.
unfold evalStrongRec in |- *.
unfold evalComposeFunc, evalOneParamList, evalList in |- *.
repeat rewrite computeEvalStrongRecHelp.
unfold compose2 in |- *.
unfold evalComposeFunc, evalOneParamList, evalList in |- *.
simpl in |- *.
repeat rewrite cPairProjections1.
unfold A at 1 in |- *.
repeat first [ rewrite cPairProjections1 | rewrite cPairProjections2 ].
rewrite H with (m := codeFormula a).
simpl in |- *.
rewrite subFormulaForall.
induction (eq_nat_dec v v0).
simpl in |- *.
apply cPairLe3.
apply le_n.
apply cPairLe3.
unfold C in |- *.
rewrite a0.
eapply le_trans; [ idtac | apply le_max_r ].
eapply le_trans; [ idtac | apply le_plus_r ].
simpl in |- *.
apply le_max_l.
apply le_trans with (codeFormula (substituteFormula L a 0 (var 0))).
rewrite (subFormulaId L).
apply le_n.
apply
 le_trans
  with
    (evalStrongRec 1 A (codeFormula a)
       (max (codeTerm (var 0))
          (pow3 (depth L a) +
           fold_right max 0 (0 :: freeVarTerm L (var 0) ++ varFormula a)))).
apply H0.
apply depthForall.
apply ReplaceFormulaTermMonotone.
unfold C in |- *.
apply maxLemma.
apply le_O_n.
apply plus_le_compat.
apply pow3Monotone.
simpl in |- *.
apply le_n_Sn.
simpl in |- *.
eapply le_trans; [ idtac | apply le_max_r ].
eapply le_trans; [ idtac | apply maxLemma3 ].
simpl in |- *.
apply le_max_r.
induction (In_dec eq_nat_dec v (freeVarTerm L s)).
simpl in |- *.
apply cPairLe3.
apply le_n.
set (nv := newVar (v0 :: freeVarTerm L s ++ freeVarFormula L a)) in *.
apply cPairLe3.
unfold C in |- *.
eapply le_trans; [ idtac | apply le_max_r ].
simpl in |- *.
apply
 le_trans
  with (1 + max v0 (fold_right max 0 (freeVarTerm L s ++ v :: varFormula a))).
simpl in |- *.
unfold nv in |- *.
unfold newVar in |- *.
eapply le_trans.
apply mapListLemma.
apply le_n_S.
simpl in |- *.
apply maxLemma.
apply le_n.
induction (maxApp (freeVarTerm L s) (freeVarFormula L a)).
rewrite a1.
apply maxLemma2.
rewrite b0.
eapply le_trans; [ idtac | apply maxLemma3 ].
simpl in |- *.
eapply le_trans; [ idtac | apply le_max_r ].
apply maxVarFreeVar.
apply plus_le_compat.
eapply le_trans; [ idtac | apply le_plus_l ].
apply pow3Min.
apply le_n.
set (B := substituteFormula L a v (fol.var L nv)) in *.
apply
 le_trans
  with
    (evalStrongRec 1 A (codeFormula B)
       (max (codeTerm s)
          (pow3 (depth L B) +
           fold_right max 0 (v0 :: freeVarTerm L s ++ varFormula B)))).
apply H0.
unfold B in |- *.
eapply eqDepth.
symmetry  in |- *.
apply subFormulaDepth.
apply depthForall.
unfold B at 1 in |- *.
rewrite ReplaceFormulaTermSub.
apply ReplaceFormulaTermMonotone.
simpl in |- *.
unfold B at 1 2 in |- *.
rewrite subFormulaDepth.
unfold C in |- *.
simpl in |- *.
apply maxLemma.
apply le_n.
rewrite plus_assoc_reverse.
apply plus_le_compat_l.
apply
 (max_case2 v0
    (fold_right max 0
       (freeVarTerm L s ++
        varFormula (substituteFormula L a v (fol.var L nv))))).
eapply le_trans; [ idtac | apply le_plus_r ].
apply le_max_l.
induction
 (maxApp (freeVarTerm L s)
    (varFormula (substituteFormula L a v (fol.var L nv)))).
rewrite a1.
eapply le_trans; [ idtac | apply le_plus_r ].
eapply le_trans; [ idtac | apply le_max_r ].
apply maxLemma2.
rewrite b0; clear b0.
clear H0 C B.
unfold nv in |- *.
clear nv.
eapply le_trans.
apply boundSubFormulaHelp1.
apply plus_le_compat.
apply le_n.
repeat apply maxLemma.
apply le_n.
apply max_case2.
apply maxLemma2.
eapply le_trans; [ idtac | apply maxLemma3 ].
simpl in |- *.
apply maxLemma.
apply le_n.
apply max_case2; apply le_n.
simpl in |- *.
apply cPairLe3.
apply le_n.
apply cPairLe3.
unfold C in |- *.
simpl in |- *.
eapply le_trans; [ idtac | apply le_max_r ].
eapply le_trans; [ idtac | apply le_plus_r ].
eapply le_trans; [ idtac | apply le_max_r ].
eapply le_trans; [ idtac | apply maxLemma3 ].
simpl in |- *.
apply le_max_l.
eapply le_trans.
apply H0.
apply depthForall.
apply ReplaceFormulaTermMonotone.
unfold C in |- *.
apply maxLemma.
apply le_n.
apply plus_le_compat.
simpl in |- *.
apply le_plus_l.
simpl in |- *.
apply maxLemma.
apply le_n.
induction (maxApp (freeVarTerm L s) (varFormula a)).
rewrite a0.
apply maxLemma2.
rewrite b1.
eapply le_trans; [ idtac | apply maxLemma3 ].

Definition boundComputation (d p1 p2 : nat) : nat :=
  nat_rec (fun _ => nat) (cTriple p1 p2 0)
    (fun _ rec : nat => cTriple p1 p2 (cPair rec rec)) d.

Lemma boundComputationIsPR : isPR 3 boundComputation.

Lemma boundComputationMonotone :
 forall a1 a2 b1 b2 c1 c2 : nat,
 a1 <= a2 ->
 b1 <= b2 ->
 c1 <= c2 -> boundComputation a1 b1 c1 <= boundComputation a2 b2 c2.

Lemma boundMakeTrace :
 forall (f : fol.Formula L) (v : nat) (s : fol.Term L),
 let C :=
   max (codeTerm s)
     (cPair 0
        (pow3 (depth L f) +
         fold_right max 0 (v :: freeVarTerm L s ++ varFormula f))) in
 makeTrace f (v, s) <=
 boundComputation (depth L f)
   (cTriple C C (ReplaceFormulaTerm (codeFormula f) C))
   (ReplaceFormulaTerm (codeFormula f) C).
Proof.
set
 (A :=
  fun f2 recs s0 : nat =>
  switchPR (cPairPi1 f2)
    (switchPR (pred (cPairPi1 f2))
       (switchPR (pred (pred (cPairPi1 f2)))
          (switchPR (pred (pred (pred (cPairPi1 f2))))
             (cPair (cPairPi1 f2) (ReplaceTermsTerm (cPairPi2 f2) s0))
             (cPair 3
                (cPair s0 (codeNth (f2 - S (cPairPi2 (cPairPi2 f2))) recs))))
          (cPair 2 (codeNth (f2 - S (cPairPi2 f2)) recs)))
       (cPair 1
          (cPair (codeNth (f2 - S (cPairPi1 (cPairPi2 f2))) recs)
             (codeNth (f2 - S (cPairPi2 (cPairPi2 f2))) recs))))
    (cPair 0
       (cPair (ReplaceTermTerm (cPairPi1 (cPairPi2 f2)) s0)
          (ReplaceTermTerm (cPairPi2 (cPairPi2 f2)) s0)))) 
 in *.
assert
 (E :
  forall (f : fol.Formula L) (v : nat) (s : fol.Term L),
  codeFormula (substituteFormula L f v s) <=
  ReplaceFormulaTerm (codeFormula f)
    (max (codeTerm s)
       (cPair 0
          (pow3 (depth L f) +
           fold_right max 0 (v :: freeVarTerm L s ++ varFormula f))))).
intros.
eapply le_trans.
apply boundSubFormulaHelp.
apply ReplaceFormulaTermMonotone.
apply maxLemma.
apply le_n.
apply cPairLe2.
assert
 (D :
  forall n m : nat,
  m < n ->
  extEqual 1
    (evalComposeFunc 1 1 (Vector.cons _ (evalStrongRecHelp 1 A n) 0 (Vector.nil _))
       (fun b : nat => codeNth (n - S m) b)) (evalStrongRec 1 A m)).
intros.
apply (evalStrongRecHelp2 1). 
assumption.
simpl in D.
intro.
assert (forall w v n s : nat, v <= max s (cPair 0 (w + max v n))).
intros.
eapply le_trans; [ idtac | apply le_max_r ].
eapply le_trans; [ idtac | apply cPairLe2 ].
eapply le_trans; [ idtac | apply le_plus_r ].
apply le_max_l.
assert
 (forall (f : fol.Formula L) (v : nat) (s : fol.Term L),
  codeFormula f <=
  ReplaceFormulaTerm (codeFormula f)
    (max (codeTerm s)
       (cPair 0
          (pow3 (depth L f) +
           fold_right max 0 (v :: freeVarTerm L s ++ varFormula f))))).
intros.
apply le_trans with (codeFormula (substituteFormula L f0 0 (var 0))).
rewrite (subFormulaId L).
apply le_n.
eapply le_trans.
apply E.
apply ReplaceFormulaTermMonotone.
apply maxLemma.
apply le_O_n.
apply cPairLe3.
apply le_n.
apply plus_le_compat.
apply le_n.
simpl in |- *.
eapply le_trans; [ idtac | apply le_max_r ].
apply maxLemma3.
elim f using Formula_depth_ind2; intros; simpl in |- *.
unfold makeTrace in |- *.
unfold Formula_depth_rec2 in |- *.
unfold Formula_depth_rec in |- *.
simpl in |- *.
unfold cTriple in |- *.
unfold C in |- *.
simpl in |- *.
repeat apply cPairLe3.
apply
 (H 1 v
    (fold_right max 0
       (freeVarTerm L s ++ freeVarTerm L t ++ freeVarTerm L t0)) 
    (codeTerm s)).
apply le_max_l.
apply (H0 (equal L t t0) v s).
apply (E (equal L t t0) v s).
apply le_n.
unfold makeTrace in |- *.
unfold Formula_depth_rec2 in |- *.
unfold Formula_depth_rec in |- *.
simpl in |- *.
unfold cTriple in |- *.
unfold C in |- *.
simpl in |- *.
repeat apply cPairLe3.
apply
 (H 1 v
    (fold_right max 0
       (freeVarTerm L s ++ freeVarTerms L (arity L (inl (Functions L) r)) t))
    (codeTerm s)).
apply le_max_l.
apply (H0 (atomic L r t) v s).
apply (E (atomic L r t) v s).
apply le_n.
replace (makeTrace (impH L f0 f1) (v, s)) with
 (cTriple (cTriple v (codeTerm s) (codeFormula (impH L f0 f1)))
    (codeFormula (substituteFormula L (impH L f0 f1) v s))
    (cPair (makeTrace f0 (v, s)) (makeTrace f1 (v, s)))).
unfold cTriple in |- *.
repeat apply cPairLe3.
unfold C in |- *; simpl in |- *. 
apply
 (H
    (pow3 (max (depth L f0) (depth L f1)) +
     (pow3 (max (depth L f0) (depth L f1)) +
      pow3 (max (depth L f0) (depth L f1)))) v
    (fold_right max 0 (freeVarTerm L s ++ varFormula f0 ++ varFormula f1))
    (codeTerm s)).
unfold C in |- *; simpl in |- *. 
apply le_max_l.
apply (H0 (impH L f0 f1) v s).
apply (E (impH L f0 f1) v s).
eapply le_trans.
apply H1.
assert
 (max (codeTerm s)
    (cPair 0
       (pow3 (depth L f0) +
        fold_right max 0 (v :: freeVarTerm L s ++ varFormula f0))) <= C).
unfold C in |- *.
apply maxLemma.
apply le_n.
apply cPairLe3.
apply le_n.
apply plus_le_compat.
apply pow3Monotone.
simpl in |- *.
apply le_S.
apply le_max_l.
simpl in |- *.
apply max_case2.
apply le_max_l.
eapply le_trans; [ idtac | apply le_max_r ].
induction (maxApp (freeVarTerm L s) (varFormula f0)).
rewrite a.
apply maxLemma2.
rewrite b.
eapply le_trans; [ idtac | apply maxLemma3 ].
apply maxLemma2.
assert
 (ReplaceFormulaTerm (codeFormula f0)
    (max (codeTerm s)
       (cPair 0
          (pow3 (depth L f0) +
           fold_right max 0 (v :: freeVarTerm L s ++ varFormula f0)))) <=
  ReplaceFormulaTerm (cPair 1 (cPair (codeFormula f0) (codeFormula f1))) C).
unfold ReplaceFormulaTerm at 2 in |- *.
fold A in |- *.
unfold evalStrongRec in |- *.
unfold evalComposeFunc, evalOneParamList, evalList in |- *.
repeat rewrite computeEvalStrongRecHelp.
unfold compose2 in |- *.
unfold evalComposeFunc, evalOneParamList, evalList in |- *.
simpl in |- *.
unfold A at 1 in |- *.
repeat first [ rewrite cPairProjections1 | rewrite cPairProjections2 ].
rewrite D with (m := codeFormula f0).
simpl in |- *.
eapply le_trans; [ idtac | apply cPairLe2 ].
eapply le_trans; [ idtac | apply cPairLe1 ].
apply ReplaceFormulaTermMonotone.
apply H3.
eapply le_lt_trans; [ idtac | apply cPairLt2 ].
apply cPairLe1.
apply boundComputationMonotone.
apply le_max_l.
unfold cTriple in |- *.
repeat apply cPairLe3.
apply H3.
apply H3.
apply H4.
apply H4.
eapply le_trans.
apply H2.
assert
 (max (codeTerm s)
    (cPair 0
       (pow3 (depth L f1) +
        fold_right max 0 (v :: freeVarTerm L s ++ varFormula f1))) <= C).
unfold C in |- *.
apply maxLemma.
apply le_n.
apply cPairLe3.
apply le_n.
apply plus_le_compat.
apply pow3Monotone.
simpl in |- *.
apply le_S.
apply le_max_r.
simpl in |- *.
apply max_case2.
apply le_max_l.
eapply le_trans; [ idtac | apply le_max_r ].
induction (maxApp (freeVarTerm L s) (varFormula f1)).
rewrite a.
apply maxLemma2.
rewrite b.
eapply le_trans; [ idtac | apply maxLemma3 ].
apply maxLemma3.
assert
 (ReplaceFormulaTerm (codeFormula f1)
    (max (codeTerm s)
       (cPair 0
          (pow3 (depth L f1) +
           fold_right max 0 (v :: freeVarTerm L s ++ varFormula f1)))) <=
  ReplaceFormulaTerm (cPair 1 (cPair (codeFormula f0) (codeFormula f1))) C).
unfold ReplaceFormulaTerm at 2 in |- *.
fold A in |- *.
unfold evalStrongRec in |- *.
unfold evalComposeFunc, evalOneParamList, evalList in |- *.
repeat rewrite computeEvalStrongRecHelp.
unfold compose2 in |- *.
unfold evalComposeFunc, evalOneParamList, evalList in |- *.
simpl in |- *.
unfold A at 1 in |- *.
repeat first [ rewrite cPairProjections1 | rewrite cPairProjections2 ].
rewrite D with (m := codeFormula f1).
simpl in |- *.
eapply le_trans; [ idtac | apply cPairLe2 ].
eapply le_trans; [ idtac | apply cPairLe2 ].
apply ReplaceFormulaTermMonotone.
apply H3.
eapply le_lt_trans; [ idtac | apply cPairLt2 ].
apply cPairLe2.
apply boundComputationMonotone.
apply le_max_r.
unfold cTriple in |- *.
repeat apply cPairLe3.
apply H3.
apply H3.
apply H4.
apply H4.
unfold makeTrace in |- *.
rewrite
 (Formula_depth_rec2_imp L)
                            with
                            (Q := 
                              fun _ : fol.Formula L =>
                              (nat * fol.Term L)%type)
                           (P := fun _ : fol.Formula L => nat).
unfold makeTraceImp at 1 in |- *.
reflexivity.
apply makeTraceImpNice.
apply makeTraceNotNice.
apply makeTraceForallNice.
replace (makeTrace (notH L f0) (v, s)) with
 (cTriple (cTriple v (codeTerm s) (codeFormula (notH L f0)))
    (codeFormula (substituteFormula L (notH L f0) v s)) 
    (makeTrace f0 (v, s))).
unfold cTriple in |- *.
repeat apply cPairLe3.
unfold C in |- *; simpl in |- *. 
apply
 (H (pow3 (depth L f0) + (pow3 (depth L f0) + pow3 (depth L f0))) v
    (fold_right max 0 (freeVarTerm L s ++ varFormula f0)) 
    (codeTerm s)).
unfold C in |- *; simpl in |- *. 
apply le_max_l.
apply (H0 (notH L f0) v s).
apply (E (notH L f0) v s).
eapply le_trans.
apply H1.
assert
 (max (codeTerm s)
    (cPair 0
       (pow3 (depth L f0) +
        fold_right max 0 (v :: freeVarTerm L s ++ varFormula f0))) <= C).
unfold C in |- *; simpl in |- *.
apply maxLemma.
apply le_n.
apply cPairLe3.
apply le_n.
apply plus_le_compat.
apply le_plus_l.
apply le_n.
assert
 (ReplaceFormulaTerm (codeFormula f0)
    (max (codeTerm s)
       (cPair 0
          (pow3 (depth L f0) +
           fold_right max 0 (v :: freeVarTerm L s ++ varFormula f0)))) <=
  ReplaceFormulaTerm (cPair 2 (codeFormula f0)) C).
unfold ReplaceFormulaTerm at 2 in |- *.
fold A in |- *.
unfold evalStrongRec in |- *.
unfold evalComposeFunc, evalOneParamList, evalList in |- *.
repeat rewrite computeEvalStrongRecHelp.
unfold compose2 in |- *.
unfold evalComposeFunc, evalOneParamList, evalList in |- *.
simpl in |- *.
unfold A at 1 in |- *.
repeat first [ rewrite cPairProjections1 | rewrite cPairProjections2 ].
rewrite D with (m := codeFormula f0).
simpl in |- *.
eapply le_trans; [ idtac | apply cPairLe2 ].
apply ReplaceFormulaTermMonotone.
apply H2.
apply cPairLt2.
eapply le_trans; [ idtac | apply cPairLe1 ].
apply boundComputationMonotone.
apply le_n.
unfold cTriple in |- *.
repeat apply cPairLe3.
apply H2.
apply H2.
apply H3.
apply H3.
unfold makeTrace in |- *.
rewrite
 (Formula_depth_rec2_not L)
                            with
                            (Q := 
                              fun _ : fol.Formula L =>
                              (nat * fol.Term L)%type)
                           (P := fun _ : fol.Formula L => nat).
unfold makeTraceNot at 1 in |- *.
reflexivity.
apply makeTraceImpNice.
apply makeTraceNotNice.
apply makeTraceForallNice.
replace (makeTrace (forallH L v a) (v0, s)) with
 (makeTraceForall v a (fun (b : fol.Formula L) _ => makeTrace b) (v0, s)).
unfold makeTraceForall in |- *.
simpl in |- *.
induction (eq_nat_dec v v0); simpl in |- *.
unfold cTriple in |- *.
repeat apply cPairLe3.
unfold C in |- *; simpl in |- *. 
apply
 (H (pow3 (depth L a) + (pow3 (depth L a) + pow3 (depth L a))) v0
    (fold_right max 0 (freeVarTerm L s ++ v :: varFormula a)) 
    (codeTerm s)).
unfold C in |- *; simpl in |- *. 
apply le_max_l.
apply (H0 (forallH L v a) v0 s).
apply (E (forallH L v a) v0 s).
apply le_O_n.
induction (In_dec eq_nat_dec v (freeVarTerm L s)); simpl in |- *.
unfold cTriple in |- *.
repeat apply cPairLe3.
unfold C in |- *; simpl in |- *. 
apply
 (H (pow3 (depth L a) + (pow3 (depth L a) + pow3 (depth L a))) v0
    (fold_right max 0 (freeVarTerm L s ++ v :: varFormula a)) 
    (codeTerm s)).
unfold C in |- *; simpl in |- *. 
apply le_max_l.
apply (H0 (forallH L v a) v0 s).
apply (E (forallH L v a) v0 s).
eapply le_trans.
apply H1.
apply depthForall.
assert
 (max (codeTerm (var (newVar (v0 :: freeVarTerm L s ++ freeVarFormula L a))))
    (cPair 0
       (pow3 (depth L a) +
        fold_right max 0
          (v
           :: freeVarTerm L
                (var (newVar (v0 :: freeVarTerm L s ++ freeVarFormula L a))) ++
              varFormula a))) <= C).
assert
 (newVar (v0 :: freeVarTerm L s ++ freeVarFormula L a) <=
  pow3 (depth L a) +
  fold_right max 0 (v0 :: freeVarTerm L s ++ varFormula (forallH L v a))).
apply
 le_trans
  with
    (1 +
     fold_right max 0
       (v0 :: fold_right max 0 (freeVarTerm L s) :: varFormula a)).
apply boundSubFormulaHelp2 with (a := a) (v0 := v0) (s := s).
apply plus_le_compat.
apply pow3Min.
simpl in |- *.
apply max_case2.
apply le_max_l.
eapply le_trans; [ idtac | apply le_max_r ].
apply max_case2.
apply maxLemma2.
eapply le_trans; [ idtac | apply maxLemma3 ].
simpl in |- *.
apply le_max_r.
apply max_case2.
replace
 (codeTerm (var (newVar (v0 :: freeVarTerm L s ++ freeVarFormula L a)))) with
 (cPair 0 (newVar (v0 :: freeVarTerm L s ++ freeVarFormula L a)));
 [ idtac | reflexivity ].
unfold C in |- *.
eapply le_trans; [ idtac | apply le_max_r ].
apply cPairLe3.
apply le_n.
eapply le_trans.
apply H2.
apply plus_le_compat_r.
simpl in |- *.
apply le_plus_l.
unfold C in |- *.
eapply le_trans; [ idtac | apply le_max_r ].
apply cPairLe3.
apply le_n.
simpl in |- *.
rewrite plus_assoc_reverse.
apply plus_le_compat_l.
apply max_case2.
eapply le_trans; [ idtac | apply le_plus_r ].
eapply le_trans; [ idtac | apply le_max_r ].
eapply le_trans; [ idtac | apply maxLemma3 ].
simpl in |- *.
apply le_max_l.
apply max_case2.
rewrite plus_assoc_reverse.
eapply le_trans; [ idtac | apply le_plus_r ].
apply H2.
eapply le_trans; [ idtac | apply le_plus_r ].
eapply le_trans; [ idtac | apply le_max_r ].
eapply le_trans; [ idtac | apply maxLemma3 ].
simpl in |- *.
apply le_max_r.
assert
 (ReplaceFormulaTerm (codeFormula a)
    (max
       (codeTerm (var (newVar (v0 :: freeVarTerm L s ++ freeVarFormula L a))))
       (cPair 0
          (pow3 (depth L a) +
           fold_right max 0
             (v
              :: freeVarTerm L
                   (var
                      (newVar (v0 :: freeVarTerm L s ++ freeVarFormula L a))) ++
                 varFormula a)))) <=
  ReplaceFormulaTerm (cPair 3 (cPair v (codeFormula a))) C).
unfold ReplaceFormulaTerm at 2 in |- *.
fold A in |- *.
unfold evalStrongRec in |- *.
unfold evalComposeFunc, evalOneParamList, evalList in |- *.
repeat rewrite computeEvalStrongRecHelp.
unfold compose2 in |- *.
unfold evalComposeFunc, evalOneParamList, evalList in |- *.
simpl in |- *.
unfold A at 1 in |- *.
repeat first [ rewrite cPairProjections1 | rewrite cPairProjections2 ].
rewrite D with (m := codeFormula a).
simpl in |- *.
eapply le_trans; [ idtac | apply cPairLe2 ].
eapply le_trans; [ idtac | apply cPairLe2 ].
apply ReplaceFormulaTermMonotone.
simpl in H2.
apply H2.
eapply le_lt_trans; [ idtac | apply cPairLt2 ].
apply cPairLe2.
apply boundComputationMonotone.
apply le_n.
unfold cTriple in |- *.
repeat apply cPairLe3.
apply H2.
apply H2.
apply H3.
apply H3.
eapply le_trans.
apply H1.
eapply eqDepth.
symmetry  in |- *.
apply subFormulaDepth.
apply depthForall.
rewrite subFormulaDepth.
assert
 (max (codeTerm s)
    (cPair 0
       (pow3 (depth L a) +
        fold_right max 0
          (v0
           :: freeVarTerm L s ++
              varFormula
                (substituteFormula L a v
                   (var
                      (newVar (v0 :: freeVarTerm L s ++ freeVarFormula L a))))))) <=
  C).
unfold C in |- *.
apply maxLemma.
apply le_n.
apply cPairLe3.
apply le_n.
simpl in |- *.
rewrite plus_assoc_reverse.
apply plus_le_compat_l.
apply max_case2.
eapply le_trans; [ idtac | apply le_plus_r ].
apply le_max_l.
induction
 (maxApp (freeVarTerm L s)
    (varFormula
       (substituteFormula L a v
          (var (newVar (v0 :: freeVarTerm L s ++ freeVarFormula L a)))))).
rewrite a1.
eapply le_trans; [ idtac | apply le_plus_r ].
eapply le_trans; [ idtac | apply le_max_r ].
apply maxLemma2.
rewrite b0.
clear b0.
eapply le_trans.
apply boundSubFormulaHelp1.
apply plus_le_compat_l.
apply maxLemma.
apply le_n.
apply max_case2.
apply maxLemma2.
eapply le_trans; [ idtac | apply maxLemma3 ].
simpl in |- *.
apply maxLemma.
apply le_n.
apply max_case2; apply le_n.
assert
 (ReplaceFormulaTerm
    (codeFormula
       (substituteFormula L a v
          (var (newVar (v0 :: freeVarTerm L s ++ freeVarFormula L a)))))
    (max (codeTerm s)
       (cPair 0
          (pow3 (depth L a) +
           fold_right max 0
             (v0
              :: freeVarTerm L s ++
                 varFormula
                   (substituteFormula L a v
                      (var
                         (newVar
                            (v0 :: freeVarTerm L s ++ freeVarFormula L a)))))))) <=
  ReplaceFormulaTerm (cPair 3 (cPair v (codeFormula a))) C).
unfold ReplaceFormulaTerm at 2 in |- *.
fold A in |- *.
unfold evalStrongRec in |- *.
unfold evalComposeFunc, evalOneParamList, evalList in |- *.
repeat rewrite computeEvalStrongRecHelp.
unfold compose2 in |- *.
unfold evalComposeFunc, evalOneParamList, evalList in |- *.
simpl in |- *.
unfold A at 1 in |- *.
repeat first [ rewrite cPairProjections1 | rewrite cPairProjections2 ].
rewrite D with (m := codeFormula a).
simpl in |- *.
eapply le_trans; [ idtac | apply cPairLe2 ].
eapply le_trans; [ idtac | apply cPairLe2 ].
rewrite ReplaceFormulaTermSub.
apply ReplaceFormulaTermMonotone.
apply H2.
eapply le_lt_trans; [ idtac | apply cPairLt2 ].
apply cPairLe2.
apply boundComputationMonotone.
apply le_n.
unfold cTriple in |- *.
repeat apply cPairLe3.
apply H2.
apply H2.
apply H3.
apply H3.
unfold cTriple in |- *.
repeat apply cPairLe3.
unfold C in |- *; simpl in |- *. 
apply
 (H (pow3 (depth L a) + (pow3 (depth L a) + pow3 (depth L a))) v0
    (fold_right max 0 (freeVarTerm L s ++ v :: varFormula a)) 
    (codeTerm s)).
unfold C in |- *; simpl in |- *. 
apply le_max_l.
apply (H0 (forallH L v a) v0 s).
apply (E (forallH L v a) v0 s).
eapply le_trans.
apply H1.
apply depthForall.
assert
 (max (codeTerm s)
    (cPair 0
       (pow3 (depth L a) +
        fold_right max 0 (v0 :: freeVarTerm L s ++ varFormula a))) <= C).
unfold C in |- *.
apply maxLemma.
apply le_n.
apply cPairLe3.
apply le_n.
apply plus_le_compat.
simpl in |- *.
apply le_plus_l.
simpl in |- *.
apply maxLemma.
apply le_n.
induction (maxApp (freeVarTerm L s) (varFormula a)).
rewrite a0.
apply maxLemma2.
rewrite b1.
eapply le_trans; [ idtac | apply maxLemma3 ].

Definition codeSubFormula (f v s : nat) : nat :=
  let C := cPair 0 (pow3 f + (v + (s + f))) in
  cPairPi1
    (boundedSearch
       (fun p x : nat =>
        ltBool 0 (checkSubFormulaTrace (cPair (cPairPi1 p) x)))
       (cPair (cTriple v s f)
          (S
             (boundComputation f (cTriple C C (ReplaceFormulaTerm f C))
                (ReplaceFormulaTerm f C))))).

Lemma codeSubFormulaCorrect :
 forall (f : Formula) (v : nat) (s : Term),
 codeSubFormula (codeFormula f) v (codeTerm s) =
 codeFormula (substituteFormula L f v s).

Lemma codeSubFormulaIsPR : isPR 3 codeSubFormula.

End Code_Substitute_Formula. *)
Require Import cPair.
(* cPair:
Require Import Arith.
Require Import Coq.Lists.List.
Require Import extEqualNat.
Require Import primRec.
Require Vector.
Require Import Div2.

Definition sumToN (n : nat) :=
  nat_rec (fun _ => nat) 0 (fun x y : nat => S x + y) n.

Lemma sumToN1 : forall n : nat, n <= sumToN n.

Lemma sumToN2 : forall b a : nat, a <= b -> sumToN a <= sumToN b.

Lemma sumToNIsPR : isPR 1 sumToN.

Definition cPair (a b : nat) := a + sumToN (a + b).

Lemma cPairIsPR : isPR 2 cPair.

Section CPair_Injectivity.

Remark cPairInjHelp :
 forall a b c d : nat, cPair a b = cPair c d -> a + b = c + d.

Lemma cPairInj1 : forall a b c d : nat, cPair a b = cPair c d -> a = c.

Lemma cPairInj2 : forall a b c d : nat, cPair a b = cPair c d -> b = d.

End CPair_Injectivity.

Section CPair_projections.

Let searchXY (a : nat) :=
  boundedSearch (fun a y : nat => ltBool a (sumToN (S y))) a.

Definition cPairPi1 (a : nat) := a - sumToN (searchXY a).
Definition cPairPi2 (a : nat) := searchXY a - cPairPi1 a.

Lemma cPairProjectionsHelp :
 forall a b : nat, b < sumToN (S a) -> sumToN a <= b -> searchXY b = a.

Lemma cPairProjections : forall a : nat, cPair (cPairPi1 a) (cPairPi2 a) = a.

Remark searchXYIsPR : isPR 1 searchXY.

Lemma cPairPi1IsPR : isPR 1 cPairPi1.

Lemma cPairPi2IsPR : isPR 1 cPairPi2.

Lemma cPairProjections1 : forall a b : nat, cPairPi1 (cPair a b) = a.

Lemma cPairProjections2 : forall a b : nat, cPairPi2 (cPair a b) = b.

End CPair_projections.

Section CPair_Order.

Lemma cPairLe1 : forall a b : nat, a <= cPair a b.

Lemma cPairLe1A : forall a : nat, cPairPi1 a <= a.

Lemma cPairLe2 : forall a b : nat, b <= cPair a b.

Lemma cPairLe2A : forall a : nat, cPairPi2 a <= a.

Lemma cPairLe3 :
 forall a b c d : nat, a <= b -> c <= d -> cPair a c <= cPair b d.

Lemma cPairLt1 : forall a b : nat, a < cPair a (S b).

Lemma cPairLt2 : forall a b : nat, b < cPair (S a) b.

End CPair_Order.

Section code_nat_list.

Fixpoint codeList (l : list nat) : nat :=
  match l with
  | nil => 0
  | n :: l' => S (cPair n (codeList l'))
  end.

Lemma codeListInj : forall l m : list nat, codeList l = codeList m -> l = m.

Definition codeNth (n m : nat) : nat.

Let drop (n : nat) : forall (l : list nat), list nat.

Lemma codeNthCorrect :
 forall (n : nat) (l : list nat), codeNth n (codeList l) = nth n l 0.

Lemma codeNthIsPR : isPR 2 codeNth.

End code_nat_list.

Section Strong_Recursion.

Definition evalStrongRecHelp (n : nat) (f : naryFunc (S (S n))) :
  naryFunc (S n) :=
  evalPrimRecFunc n (evalComposeFunc n 0 (Vector.nil _) (codeList nil))
    (evalComposeFunc (S (S n)) 2
       (Vector.cons _ f _
          (Vector.cons _ (evalProjFunc (S (S n)) n (lt_S _ _ (lt_n_Sn _))) _
             (Vector.nil _))) (fun a b : nat => S (cPair a b))).

Definition evalStrongRec (n : nat) (f : naryFunc (S (S n))) :
  naryFunc (S n) :=
  evalComposeFunc (S n) 1
    (Vector.cons _ (fun z : nat => evalStrongRecHelp n f (S z)) _ (Vector.nil _))
    (fun z : nat => cPairPi1 (pred z)).

Lemma evalStrongRecIsPR :
 forall (n : nat) (f : naryFunc (S (S n))),
 isPR _ f -> isPR _ (evalStrongRec n f).

Lemma computeEvalStrongRecHelp :
 forall (n : nat) (f : naryFunc (S (S n))) (c : nat),
 evalStrongRecHelp n f (S c) =
 compose2 n (evalStrongRecHelp n f c)
   (fun a0 : nat =>
    evalComposeFunc n 2
      (Vector.cons (naryFunc n) (f c a0) 1

Let listValues (f : naryFunc 2) (n : nat) : list nat.

Lemma evalStrongRecHelp1 :
 forall (f : naryFunc 2) (n m : nat),
 m < n -> codeNth (n - S m) (evalStrongRecHelp _ f n) = evalStrongRec _ f m.

Lemma evalStrongRecHelpParam :
 forall (a n c : nat) (f : naryFunc (S (S (S a)))),
 extEqual a (evalStrongRecHelp (S a) f n c)
   (evalStrongRecHelp a (fun x y : nat => f x y c) n).

Lemma evalStrongRecHelp2 :
 forall (a : nat) (f : naryFunc (S (S a))) (n m : nat),
 m < n ->
 extEqual _
   (evalComposeFunc _ 1 (Vector.cons _ (evalStrongRecHelp _ f n) 0 (Vector.nil _))

Lemma callIsPR :
 forall g : nat -> nat,
 isPR 1 g -> isPR 2 (fun a recs : nat => codeNth (a - S (g a)) recs).

End Strong_Recursion.

Lemma div2IsPR : isPR 1 div2. *)
Require Import Arith.
Require Import code.
(* code:
Require Import Arith.
Require Import fol.
Require Import folProof.
Require Import cPair.

Section Code_Term_Formula_Proof.

Variable L : Language.
Variable codeF : Functions L -> nat.
Variable codeR : Relations L -> nat.
Hypothesis codeFInj : forall f g : Functions L, codeF f = codeF g -> f = g.
Hypothesis codeRInj : forall R S : Relations L, codeR R = codeR S -> R = S.

Let Formula := Formula L.
Let Formulas := Formulas L.
Let System := System L.
Let Term := Term L.
Let Terms := Terms L.
Let var := var L.
Let apply := apply L.
Let equal := equal L.
Let atomic := atomic L.
Let impH := impH L.
Let notH := notH L.
Let forallH := forallH L.
Let orH := orH L.
Let andH := andH L.
Let existH := existH L.
Let iffH := iffH L.
Let ifThenElseH := ifThenElseH L.
Let Prf := Prf L.
Let SysPrf := SysPrf L.

Fixpoint codeTerm (t : Term) : nat :=
  match t with
  | fol.var n => cPair 0 n
  | fol.apply f ts => cPair (S (codeF f)) (codeTerms _ ts)
  end
 
 with codeTerms (n : nat) (ts : Terms n) {struct ts} : nat :=
  match ts with
  | Tnil => 0
  | Tcons n t ss => S (cPair (codeTerm t) (codeTerms n ss))
  end.

Lemma codeTermInj : forall t s : Term, codeTerm t = codeTerm s -> t = s.

Lemma codeTermsInj :
 forall (n : nat) (ts ss : Terms n),
 codeTerms n ts = codeTerms n ss -> ts = ss.

Fixpoint codeFormula (f : Formula) : nat :=
  match f with
  | fol.equal t1 t2 => cPair 0 (cPair (codeTerm t1) (codeTerm t2))
  | fol.impH f1 f2 => cPair 1 (cPair (codeFormula f1) (codeFormula f2))
  | fol.notH f1 => cPair 2 (codeFormula f1)
  | fol.forallH n f1 => cPair 3 (cPair n (codeFormula f1))
  | fol.atomic R ts => cPair (4+(codeR R)) (codeTerms _ ts)
  end.

Lemma codeFormulaInj :
 forall f g : Formula, codeFormula f = codeFormula g -> f = g.

Fixpoint codePrf (Z : Formulas) (f : Formula) (prf : Prf Z f) {struct prf} :
 nat :=
  match prf with
  | AXM A => cPair 0 (codeFormula A)
  | MP Axm1 Axm2 A B rec1 rec2 =>
      cPair 1
        (cPair
           (cPair (cPair 1 (cPair (codeFormula A) (codeFormula B)))
              (codePrf _ _ rec1)) (cPair (codeFormula A) (codePrf _ _ rec2)))
  | GEN Axm A v _ rec =>
      cPair 2 (cPair v (cPair (codeFormula A) (codePrf _ _ rec)))
  | IMP1 A B => cPair 3 (cPair (codeFormula A) (codeFormula B))
  | IMP2 A B C =>
      cPair 4 (cPair (codeFormula A) (cPair (codeFormula B) (codeFormula C)))
  | CP A B => cPair 5 (cPair (codeFormula A) (codeFormula B))
  | FA1 A v t => cPair 6 (cPair (codeFormula A) (cPair v (codeTerm t)))
  | FA2 A v _ => cPair 7 (cPair (codeFormula A) v)
  | FA3 A B v => cPair 8 (cPair (codeFormula A) (cPair (codeFormula B) v))
  | EQ1 => cPair 9 0
  | EQ2 => cPair 10 0
  | EQ3 => cPair 11 0
  | EQ4 r => cPair 12 (codeR r)
  | EQ5 f => cPair 13 (codeF f)
  end.

Lemma codePrfInjAxm :
 forall (a b : Formula) (A B : Formulas) (p : Prf A a) (q : Prf B b),
 codePrf A a p = codePrf B b q -> A = B.

Definition codeImp (a b : nat) := cPair 1 (cPair a b).

Lemma codeImpCorrect :
 forall a b : Formula,
 codeImp (codeFormula a) (codeFormula b) = codeFormula (impH a b).

Definition codeNot (a : nat) := cPair 2 a.

Lemma codeNotCorrect :
 forall a : Formula, codeNot (codeFormula a) = codeFormula (notH a).

Definition codeForall (n a : nat) := cPair 3 (cPair n a).

Lemma codeForallCorrect :
 forall (n : nat) (a : Formula),
 codeForall n (codeFormula a) = codeFormula (forallH n a).

Definition codeOr (a b : nat) := codeImp (codeNot a) b.

Lemma codeOrCorrect :
 forall a b : Formula,
 codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).

Definition codeAnd (a b : nat) := codeNot (codeOr (codeNot a) (codeNot b)).

Lemma codeAndCorrect :
 forall a b : Formula,
 codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).

Definition codeIff (a b : nat) := codeAnd (codeImp a b) (codeImp b a).

Lemma codeIffCorrect :
 forall a b : Formula,
 codeIff (codeFormula a) (codeFormula b) = codeFormula (iffH a b).

End Code_Term_Formula_Proof. *)
Require Import folProp.
(* folProp:
Require Import Wf_nat.
Require Import Max.
Require Import Arith.
Require Import Coq.Lists.List.
Require Import ListExt.
Require Import Peano_dec.

Require Export fol.

Section Fol_Properties.

Variable L : Language.

Notation Formula := (Formula L) (only parsing).
Notation Formulas := (Formulas L) (only parsing).
Notation System := (System L) (only parsing).
Notation Term := (Term L) (only parsing).
Notation Terms := (Terms L) (only parsing).
Let var := var L.
Let apply := apply L.
Let equal := equal L.
Let atomic := atomic L.
Let impH := impH L.
Let notH := notH L.
Let forallH := forallH L.
Let lt_depth := lt_depth L.

Section Free_Variables.

Fixpoint freeVarTerm (s : fol.Term L) : list nat :=
  match s with
  | fol.var v => v :: nil
  | fol.apply f ts => freeVarTerms (arity L (inr _ f)) ts
  end
 
 with freeVarTerms (n : nat) (ss : fol.Terms L n) {struct ss} : 
 list nat :=
  match ss with
  | Tnil => nil (A:=nat)
  | Tcons m t ts => freeVarTerm t ++ freeVarTerms m ts
  end.

Lemma freeVarTermApply :
 forall (f : Functions L) (ts : fol.Terms L _),

Fixpoint freeVarFormula (A : fol.Formula L) : list nat :=
  match A with
  | fol.equal t s => freeVarTerm t ++ freeVarTerm s
  | fol.atomic r ts => freeVarTerms _ ts
  | fol.impH A B => freeVarFormula A ++ freeVarFormula B
  | fol.notH A => freeVarFormula A
  | fol.forallH v A => list_remove _ eq_nat_dec v (freeVarFormula A)
  end.

Definition ClosedSystem (T : fol.System L) :=
  forall (v : nat) (f : fol.Formula L),
  mem _ T f -> ~ In v (freeVarFormula f).

Definition closeList (l : list nat) (x : fol.Formula L) : 
  fol.Formula L :=
  list_rec (fun _ => fol.Formula L) x
    (fun (a : nat) _ (rec : fol.Formula L) => forallH a rec) l.

Definition close (x : fol.Formula L) : fol.Formula L :=
  closeList (no_dup _ eq_nat_dec (freeVarFormula x)) x.

Lemma freeVarClosedList1 :
 forall (l : list nat) (v : nat) (x : fol.Formula L),

Lemma freeVarClosedList2 :
 forall (l : list nat) (v : nat) (x : fol.Formula L),

Lemma freeVarClosed :
 forall (x : fol.Formula L) (v : nat), ~ In v (freeVarFormula (close x)).

Fixpoint freeVarListFormula (l : fol.Formulas L) : 
 list nat :=
  match l with
  | nil => nil (A:=nat)
  | f :: l => freeVarFormula f ++ freeVarListFormula l
  end.

Lemma freeVarListFormulaApp :
 forall a b : fol.Formulas L,

Lemma In_freeVarListFormula :
 forall (v : nat) (f : fol.Formula L) (F : fol.Formulas L),

Lemma In_freeVarListFormulaE :
 forall (v : nat) (F : fol.Formulas L),

Definition In_freeVarSys (v : nat) (T : fol.System L) :=
  exists f : fol.Formula L, In v (freeVarFormula f) /\ mem _ T f.

Lemma notInFreeVarSys :
 forall x, ~ In_freeVarSys x (Ensembles.Empty_set (fol.Formula L)).

End Free_Variables.

Section Substitution.

Fixpoint substituteTerm (s : fol.Term L) (x : nat) 
 (t : fol.Term L) {struct s} : fol.Term L :=
  match s with
  | fol.var v =>
      match eq_nat_dec x v with
      | left _ => t
      | right _ => var v
      end
  | fol.apply f ts => apply f (substituteTerms _ ts x t)
  end
 
 with substituteTerms (n : nat) (ss : fol.Terms L n) 
 (x : nat) (t : fol.Term L) {struct ss} : fol.Terms L n :=
  match ss in (fol.Terms _ n0) return (fol.Terms L n0) with
  | Tnil => Tnil L
  | Tcons m s ts =>
      Tcons L m (substituteTerm s x t) (substituteTerms m ts x t)
  end.

Lemma subTermVar1 :
 forall (v : nat) (s : fol.Term L), substituteTerm (var v) v s = s.

Lemma subTermVar2 :
 forall (v x : nat) (s : fol.Term L),

Lemma subTermFunction :
 forall (f : Functions L) (ts : fol.Terms L (arity L (inr _ f))) 

Definition newVar (l : list nat) : nat := fold_right max 0 (map S l).

Lemma newVar2 : forall (l : list nat) (n : nat), In n l -> n < newVar l.

Lemma newVar1 : forall l : list nat, ~ In (newVar l) l.

Definition substituteFormulaImp (f : fol.Formula L)
  (frec : nat * fol.Term L -> {y : fol.Formula L | depth L y = depth L f})
  (g : fol.Formula L)
  (grec : nat * fol.Term L -> {y : fol.Formula L | depth L y = depth L g})
  (p : nat * fol.Term L) :
  {y : fol.Formula L | depth L y = depth L (impH f g)} :=
  match frec p with
  | exist f' prf1 =>
      match grec p with
      | exist g' prf2 =>
          exist
            (fun y : fol.Formula L =>
             depth L y = S (max (depth L f) (depth L g))) 
            (impH f' g')
            (eq_ind_r
               (fun n : nat =>
                S (max n (depth L g')) = S (max (depth L f) (depth L g)))
               (eq_ind_r
                  (fun n : nat =>
                   S (max (depth L f) n) = S (max (depth L f) (depth L g)))
                  (refl_equal (S (max (depth L f) (depth L g)))) prf2) prf1)
      end
  end.

Remark substituteFormulaImpNice :
 forall (f g : fol.Formula L)

Definition substituteFormulaNot (f : fol.Formula L)
  (frec : nat * fol.Term L -> {y : fol.Formula L | depth L y = depth L f})
  (p : nat * fol.Term L) :
  {y : fol.Formula L | depth L y = depth L (notH f)} :=
  match frec p with
  | exist f' prf1 =>
      exist (fun y : fol.Formula L => depth L y = S (depth L f)) 
        (notH f')
        (eq_ind_r (fun n : nat => S n = S (depth L f))
           (refl_equal (S (depth L f))) prf1)
  end.

Remark substituteFormulaNotNice :
 forall (f : fol.Formula L)

Definition substituteFormulaForall (n : nat) (f : fol.Formula L)
  (frec : forall b : fol.Formula L,
          lt_depth b (forallH n f) ->
          nat * fol.Term L -> {y : fol.Formula L | depth L y = depth L b})
  (p : nat * fol.Term L) :
  {y : fol.Formula L | depth L y = depth L (forallH n f)} :=
  match p with
  | (v, s) =>
      match eq_nat_dec n v with
      | left _ =>
          exist (fun y : fol.Formula L => depth L y = S (depth L f))
            (forallH n f) (refl_equal (depth L (forallH n f)))
      | right _ =>
          match In_dec eq_nat_dec n (freeVarTerm s) with
          | left _ =>
              let nv := newVar (v :: freeVarTerm s ++ freeVarFormula f) in
              match frec f (depthForall L f n) (n, var nv) with
              | exist f' prf1 =>
                  match
                    frec f'
                      (eqDepth L f' f (forallH n f) 
                         (sym_eq prf1) (depthForall L f n)) p
                  with
                  | exist f'' prf2 =>
                      exist
                        (fun y : fol.Formula L => depth L y = S (depth L f))
                        (forallH nv f'')
                        (eq_ind_r (fun n : nat => S n = S (depth L f))
                           (refl_equal (S (depth L f))) 
                           (trans_eq prf2 prf1))
                  end
              end
          | right _ =>
              match frec f (depthForall L f n) p with
              | exist f' prf1 =>
                  exist (fun y : fol.Formula L => depth L y = S (depth L f))
                    (forallH n f')
                    (eq_ind_r (fun n : nat => S n = S (depth L f))
                       (refl_equal (S (depth L f))) prf1)
              end
          end
      end
  end.

Remark substituteFormulaForallNice :
 forall (v : nat) (a : fol.Formula L)

Definition substituteFormulaHelp (f : fol.Formula L) 

Definition substituteFormula (f : fol.Formula L) (v : nat) 
  (s : fol.Term L) : fol.Formula L := proj1_sig (substituteFormulaHelp f v s).

Lemma subFormulaEqual :
 forall (t1 t2 : fol.Term L) (v : nat) (s : fol.Term L),

Lemma subFormulaRelation :
 forall (r : Relations L) (ts : fol.Terms L (arity L (inl _ r))) 

Lemma subFormulaImp :
 forall (f1 f2 : fol.Formula L) (v : nat) (s : fol.Term L),

Lemma subFormulaNot :
 forall (f : fol.Formula L) (v : nat) (s : fol.Term L),

Lemma subFormulaForall :
 forall (f : fol.Formula L) (x v : nat) (s : fol.Term L),

Section Extensions.

Let orH := orH L.
Let andH := andH L.
Let existH := existH L.
Let iffH := iffH L.
Let ifThenElseH := ifThenElseH L.

Lemma subFormulaOr :
 forall (f1 f2 : fol.Formula L) (v : nat) (s : fol.Term L),

Lemma subFormulaAnd :
 forall (f1 f2 : fol.Formula L) (v : nat) (s : fol.Term L),

Lemma subFormulaExist :
 forall (f : fol.Formula L) (x v : nat) (s : fol.Term L),

Lemma subFormulaIff :
 forall (f1 f2 : fol.Formula L) (v : nat) (s : fol.Term L),

Lemma subFormulaIfThenElse :
 forall (f1 f2 f3 : fol.Formula L) (v : nat) (s : fol.Term L),

End Extensions.

Lemma subFormulaDepth :
 forall (f : fol.Formula L) (v : nat) (s : fol.Term L),

Section Substitution_Properties.

Lemma subTermId :
 forall (t : fol.Term L) (v : nat), substituteTerm t v (var v) = t.

Lemma subTermsId :
 forall (n : nat) (ts : fol.Terms L n) (v : nat),

Lemma subFormulaId :
 forall (f : fol.Formula L) (v : nat), substituteFormula f v (var v) = f.

Lemma subFormulaForall2 :
 forall (f : fol.Formula L) (x v : nat) (s : fol.Term L),

Let existH := existH L.

Lemma subFormulaExist2 :
 forall (f : fol.Formula L) (x v : nat) (s : fol.Term L),

End Substitution_Properties.

End Substitution.
 
Definition Sentence (f:Formula) := (forall v : nat, ~ In v (freeVarFormula f)).

End Fol_Properties. *)
Require Import extEqualNat.
(* extEqualNat:
Require Import Arith.

Fixpoint naryFunc (n : nat) : Set :=
  match n with
  | O => nat
  | S n => nat -> naryFunc n
  end.

Fixpoint naryRel (n : nat) : Set :=
  match n with
  | O => bool
  | S n => nat -> naryRel n
  end.

Definition extEqual (n : nat) (a b : naryFunc n) : Prop.

Lemma extEqualRefl : forall (n : nat) (a : naryFunc n), extEqual n a a.

Lemma extEqualSym :
 forall (n : nat) (a b : naryFunc n), extEqual n a b -> extEqual n b a.

Lemma extEqualTrans :
 forall (n : nat) (a b c : naryFunc n),
 extEqual n a b -> extEqual n b c -> extEqual n a c.

Fixpoint charFunction (n : nat) : naryRel n -> naryFunc n :=
  match n return (naryRel n -> naryFunc n) with
  | O => fun R : bool => match R with
                         | true => 1
                         | false => 0
                         end
  | S m => fun (R : naryRel (S m)) (a : nat) => charFunction m (R a)
  end. *)
Require Import wellFormed.
(* wellFormed:
Require Import primRec.
Require Import cPair.
Require Import Arith.
Require Import code.
Require Import folProp.
Require Import extEqualNat.
Require Import codeList.

Section Well_Formed_Term.

Variable L : Language.
Variable codeF : Functions L -> nat.
Variable codeArityF : nat -> nat.
Hypothesis codeArityFIsPR : isPR 1 codeArityF.
Hypothesis
  codeArityFIsCorrect1 :
    forall f : Functions L, codeArityF (codeF f) = S (arity L (inr _ f)).
Hypothesis
  codeArityFIsCorrect2 :
    forall n : nat, codeArityF n <> 0 -> exists f : Functions L, codeF f = n.

Let Term := Term L.
Let Terms := Terms L.
Let var := var L.
Let apply := apply L.

Definition wellFormedTermTerms : nat -> nat :=
  evalStrongRec 0
    (fun t recs : nat =>
     cPair
       (switchPR (cPairPi1 t)
          (charFunction 2 beq_nat (codeArityF (pred (cPairPi1 t)))
             (S (codeLength (cPairPi2 t))) *
           cPairPi2 (codeNth (t - S (cPairPi2 t)) recs)) 1)
       (switchPR t
          (cPairPi1 (codeNth (t - S (cPairPi1 (pred t))) recs) *
           cPairPi2 (codeNth (t - S (cPairPi2 (pred t))) recs)) 1)).

Definition wellFormedTerm (t : nat) : nat := cPairPi1 (wellFormedTermTerms t).

Definition wellFormedTerms (ts : nat) : nat :=
  cPairPi2 (wellFormedTermTerms ts).

Lemma lengthTerms :
 forall (n : nat) (ts : Terms n), codeLength (codeTerms L codeF n ts) = n.

Lemma wellFormedTermCorrect1 :
 forall t : Term, wellFormedTerm (codeTerm L codeF t) = 1.

Lemma wellFormedTermsCorrect1 :
 forall (n : nat) (ts : Terms n),
 wellFormedTerms (codeTerms L codeF n ts) = 1.

Remark wellFormedTermTermsCorrect2 :
 forall n : nat,
 (wellFormedTerm n <> 0 -> exists t : Term, codeTerm L codeF t = n) /\
 (wellFormedTerms n <> 0 ->
  exists m : nat, (exists ts : Terms m, codeTerms L codeF m ts = n)).
Proof.
assert (multLemma1 : forall a b : nat, a * b <> 0 -> a <> 0).
unfold not in |- *; intros.
apply H.
rewrite H0.
simpl in |- *.
reflexivity.
assert (multLemma2 : forall a b : nat, a * b <> 0 -> b <> 0).
intros.
rewrite mult_comm in H.
eapply multLemma1.
apply H.
assert
 (forall m n : nat,
  n < m ->
  (wellFormedTerm n <> 0 -> exists t : Term, codeTerm L codeF t = n) /\
  (wellFormedTerms n <> 0 ->
   exists m : nat, (exists ts : Terms m, codeTerms L codeF m ts = n))).
intro.
induction m as [| m Hrecm].
intros.
elim (lt_not_le _ _ H).
apply le_O_n.
intros.
induction (le_lt_or_eq _ _ (lt_n_Sm_le _ _ H)).
apply Hrecm; auto.
unfold wellFormedTerm in |- *.
unfold wellFormedTerms in |- *.
unfold wellFormedTermTerms in |- *.
set
 (A :=
  fun t recs : nat =>
  cPair
    (switchPR (cPairPi1 t)
       (charFunction 2 beq_nat (codeArityF (pred (cPairPi1 t)))
          (S (codeLength (cPairPi2 t))) *
        cPairPi2 (codeNth (t - S (cPairPi2 t)) recs)) 1)
    (switchPR t
       (cPairPi1 (codeNth (t - S (cPairPi1 (pred t))) recs) *
        cPairPi2 (codeNth (t - S (cPairPi2 (pred t))) recs)) 1)) 
 in *.
unfold evalStrongRec, evalComposeFunc, evalOneParamList, evalList in |- *.
rewrite computeEvalStrongRecHelp.
unfold compose2, evalComposeFunc, evalOneParamList, evalList in |- *.
simpl in |- *.
rewrite cPairProjections1.
split.
unfold A at 1 in |- *.
rewrite cPairProjections1.
assert (cPair (cPairPi1 n) (cPairPi2 n) = n).
apply cPairProjections.
destruct (cPairPi1 n).
simpl in |- *.
intros.
exists (var (cPairPi2 n)).
transitivity (cPair 0 (cPairPi2 n)).
reflexivity.
assumption.
rewrite evalStrongRecHelp1.
simpl in |- *.
intros.
induction (eq_nat_dec (codeArityF n0) (S (codeLength (cPairPi2 n)))).
assert (wellFormedTerms (cPairPi2 n) <> 0).
eapply multLemma2.
apply H2.
assert (cPairPi2 n < m).
apply lt_le_trans with (cPair (S n0) (cPairPi2 n)).
apply cPairLt2.
rewrite H1.
rewrite H0.
apply le_n.
induction (Hrecm _ H4).
clear H5.
induction (H6 H3).
induction H5 as (x0, H5).
assert (codeArityF n0 <> 0).
unfold not in |- *; intros.
rewrite H7 in a.
discriminate a.
induction (codeArityFIsCorrect2 _ H7).
rewrite <- H8 in a.
rewrite codeArityFIsCorrect1 in a.
injection a.
clear a.
intro.
rewrite <- H5 in H9.
rewrite lengthTerms in H9.
cut (codeTerms L codeF x x0 = cPairPi2 n).
clear H5.
generalize x0.
clear x0.
rewrite <- H9.
intros.
exists (apply x1 x0).
transitivity (cPair (S n0) (cPairPi2 n)).
rewrite <- H8.
rewrite <- H5.
reflexivity.
assumption.
assumption.
rewrite beq_nat_not_refl in H2.
elim H2.
reflexivity.
assumption.
apply lt_le_trans with (cPair (S n0) (cPairPi2 n)).
apply cPairLt2.
rewrite H1.
apply le_n.
unfold A at 1 in |- *.
rewrite cPairProjections2.
destruct n.
simpl in |- *.
intros.
exists 0.
exists (Tnil L).
reflexivity.
repeat rewrite evalStrongRecHelp1.
simpl in |- *.
intros.
assert (cPairPi1 n < m).
rewrite <- H0.
apply le_lt_n_Sm.
apply le_trans with (cPair (cPairPi1 n) (cPairPi2 n)).
apply cPairLe1.
rewrite cPairProjections.
apply le_n.
assert (cPairPi2 n < m).
rewrite <- H0.
apply le_lt_n_Sm.
apply le_trans with (cPair (cPairPi1 n) (cPairPi2 n)).
apply cPairLe2.
rewrite cPairProjections.
apply le_n.
induction (Hrecm _ H2).
clear H5.
induction (Hrecm _ H3).
clear H5.
assert (wellFormedTerm (cPairPi1 n) <> 0).
eapply multLemma1.
apply H1.
assert (wellFormedTerms (cPairPi2 n) <> 0).
eapply multLemma2.

Lemma wellFormedTermCorrect2 :
 forall n : nat,
 wellFormedTerm n <> 0 -> exists t : Term, codeTerm L codeF t = n.

Lemma wellFormedTermsCorrect2 :
 forall n : nat,
 wellFormedTerms n <> 0 ->
 exists m : nat, (exists ts : Terms m, codeTerms L codeF m ts = n).

Remark wellFormedTermTermsIsPR : isPR 1 wellFormedTermTerms.

Lemma wellFormedTermIsPR : isPR 1 wellFormedTerm.

Lemma wellFormedTermsIsPR : isPR 1 wellFormedTerms.

Section Well_Formed_Formula.

Variable codeR : Relations L -> nat.
Variable codeArityR : nat -> nat.
Hypothesis codeArityRIsPR : isPR 1 codeArityR.
Hypothesis
  codeArityRIsCorrect1 :
    forall r : Relations L, codeArityR (codeR r) = S (arity L (inl _ r)).
Hypothesis
  codeArityRIsCorrect2 :
    forall n : nat, codeArityR n <> 0 -> exists r : Relations L, codeR r = n.

Let Formula := Formula L.
Let equal := equal L.
Let atomic := atomic L.
Let impH := impH L.
Let notH := notH L.
Let forallH := forallH L.

Definition wellFormedFormula : nat -> nat :=
  evalStrongRec 0
    (fun f recs : nat =>
     switchPR (cPairPi1 f)
       (switchPR (pred (cPairPi1 f))
          (switchPR (pred (pred (cPairPi1 f)))
             (switchPR (pred (pred (pred (cPairPi1 f))))
                (charFunction 2 beq_nat
                   (codeArityR (pred (pred (pred (pred (cPairPi1 f))))))
                   (S (codeLength (cPairPi2 f))) *
                 wellFormedTerms (cPairPi2 f))
                (codeNth (f - S (cPairPi2 (cPairPi2 f))) recs))
             (codeNth (f - S (cPairPi2 f)) recs))
          (codeNth (f - S (cPairPi1 (cPairPi2 f))) recs *
           codeNth (f - S (cPairPi2 (cPairPi2 f))) recs))
       (wellFormedTerm (cPairPi1 (cPairPi2 f)) *
        wellFormedTerm (cPairPi2 (cPairPi2 f)))).

Lemma wellFormedFormulaCorrect1 :
 forall f : Formula, wellFormedFormula (codeFormula L codeF codeR f) = 1.

Lemma wellFormedFormulaCorrect2 :
 forall n : nat,
 wellFormedFormula n <> 0 ->
 exists f : Formula, codeFormula L codeF codeR f = n.
Proof.
assert (multLemma1 : forall a b : nat, a * b <> 0 -> a <> 0).
unfold not in |- *; intros.
apply H.
rewrite H0.
simpl in |- *.
reflexivity.
assert (multLemma2 : forall a b : nat, a * b <> 0 -> b <> 0).
intros.
rewrite mult_comm in H.
eapply multLemma1.
apply H.
assert
 (forall m n : nat,
  n < m ->
  wellFormedFormula n <> 0 ->
  exists f : Formula, codeFormula L codeF codeR f = n).
intro.
induction m as [| m Hrecm].
intros n H.
elim (lt_not_le _ _ H).
apply le_O_n.
intros n H.
induction (le_lt_or_eq _ _ (lt_n_Sm_le _ _ H)).
apply Hrecm; auto.
unfold wellFormedFormula in |- *.
set
 (A :=
  fun f recs : nat =>
  switchPR (cPairPi1 f)
    (switchPR (pred (cPairPi1 f))
       (switchPR (pred (pred (cPairPi1 f)))
          (switchPR (pred (pred (pred (cPairPi1 f))))
             (charFunction 2 beq_nat
                (codeArityR (pred (pred (pred (pred (cPairPi1 f))))))
                (S (codeLength (cPairPi2 f))) * wellFormedTerms (cPairPi2 f))
             (codeNth (f - S (cPairPi2 (cPairPi2 f))) recs))
          (codeNth (f - S (cPairPi2 f)) recs))
       (codeNth (f - S (cPairPi1 (cPairPi2 f))) recs *
        codeNth (f - S (cPairPi2 (cPairPi2 f))) recs))
    (wellFormedTerm (cPairPi1 (cPairPi2 f)) *
     wellFormedTerm (cPairPi2 (cPairPi2 f)))) in *.
unfold evalStrongRec, evalComposeFunc, evalOneParamList, evalList in |- *.
rewrite computeEvalStrongRecHelp.
unfold compose2, evalComposeFunc, evalOneParamList, evalList in |- *.
simpl in |- *.
rewrite cPairProjections1.
unfold A at 1 in |- *.
assert (cPair (cPairPi1 n) (cPairPi2 n) = n).
apply cPairProjections.
destruct (cPairPi1 n).
simpl in |- *.
intros.
assert (wellFormedTerm (cPairPi1 (cPairPi2 n)) <> 0).
eapply multLemma1.
apply H2.
assert (wellFormedTerm (cPairPi2 (cPairPi2 n)) <> 0).
eapply multLemma2.
apply H2.
induction (wellFormedTermCorrect2 _ H3).
induction (wellFormedTermCorrect2 _ H4).
exists (equal x x0).
simpl in |- *.
rewrite H5.
rewrite H6.
rewrite cPairProjections.
assumption.
destruct n0.
simpl in |- *.
assert (cPairPi2 n < m).
apply lt_le_trans with (cPair 1 (cPairPi2 n)).
apply cPairLt2.
rewrite H1.
rewrite H0.
apply le_n.
assert (cPairPi1 (cPairPi2 n) < m).
apply
 le_lt_trans with (cPair (cPairPi1 (cPairPi2 n)) (cPairPi2 (cPairPi2 n))).
apply cPairLe1.
rewrite cPairProjections.
assumption.
assert (cPairPi2 (cPairPi2 n) < m).
apply
 le_lt_trans with (cPair (cPairPi1 (cPairPi2 n)) (cPairPi2 (cPairPi2 n))).
apply cPairLe2.
rewrite cPairProjections.
assumption.
repeat rewrite evalStrongRecHelp1.
intros.
assert (evalStrongRec 0 A (cPairPi1 (cPairPi2 n)) <> 0).
eapply multLemma1.
apply H5.
assert (evalStrongRec 0 A (cPairPi2 (cPairPi2 n)) <> 0).
eapply multLemma2.
apply H5.
induction (Hrecm _ H3 H6).
induction (Hrecm _ H4 H7).
exists (impH x x0).
simpl in |- *.
rewrite H8.
rewrite H9.
rewrite cPairProjections.
assumption.
eapply lt_le_trans.
apply H4.
rewrite H0.
apply le_n.
eapply lt_le_trans.
apply H3.
rewrite H0.
apply le_n.
destruct n0.
simpl in |- *.
assert (cPairPi2 n < m).
apply lt_le_trans with (cPair 2 (cPairPi2 n)).
apply cPairLt2.
rewrite H1.
rewrite H0.
apply le_n.
repeat rewrite evalStrongRecHelp1.
intros.
induction (Hrecm _ H2 H3).
exists (notH x).
simpl in |- *.
rewrite H4.
assumption.
eapply lt_le_trans.
apply H2.
rewrite H0.
apply le_n.
destruct n0.
simpl in |- *.
assert (cPairPi2 n < m).
apply lt_le_trans with (cPair 3 (cPairPi2 n)).
apply cPairLt2.
rewrite H1.
rewrite H0.
apply le_n.
assert (cPairPi2 (cPairPi2 n) < m).
apply
 le_lt_trans with (cPair (cPairPi1 (cPairPi2 n)) (cPairPi2 (cPairPi2 n))).
apply cPairLe2.
rewrite cPairProjections.
assumption.
repeat rewrite evalStrongRecHelp1.
intros.
induction (Hrecm _ H3 H4).
exists (forallH (cPairPi1 (cPairPi2 n)) x).
simpl in |- *.
rewrite H5.
rewrite cPairProjections.
assumption.
eapply lt_le_trans.
apply H3.
rewrite H0.
apply le_n.
simpl in |- *.
induction (eq_nat_dec (codeArityR n0) (S (codeLength (cPairPi2 n)))).
assert (codeArityR n0 <> 0).
unfold not in |- *; intros.
rewrite H2 in a.
discriminate a.
induction (codeArityRIsCorrect2 _ H2).
intros.
assert (wellFormedTerms (cPairPi2 n) <> 0).
eapply multLemma2.

Lemma wellFormedFormulaIsPR : isPR 1 wellFormedFormula.

End Well_Formed_Formula.

End Well_Formed_Term. *)
Require Import folProof.
(* folProof:
Require Import Ensembles.
Require Import Coq.Lists.List.
Require Import Arith.

Require Export fol.
Require Import folProp.

Section ProofH.

Variable L : Language.

Let Formula := Formula L.
Let Formulas := Formulas L.
Let System := System L.
Let Term := Term L.
Let Terms := Terms L.
Let var := var L.
Let apply := apply L.
Let equal := equal L.
Let atomic := atomic L.
Let impH := impH L.
Let notH := notH L.
Let iffH := iffH L.
Let forallH := forallH L.

Definition nVars (n : nat) : Terms n * Terms n.

Definition AxmEq4 (R : Relations L) : Formula.

Definition AxmEq5 (f : Functions L) : Formula.

Inductive Prf : Formulas -> Formula -> Set :=
  | AXM : forall A : Formula, Prf (A :: nil) A
  | MP :
      forall (Axm1 Axm2 : Formulas) (A B : Formula),
      Prf Axm1 (impH A B) -> Prf Axm2 A -> Prf (Axm1 ++ Axm2) B
  | GEN :
      forall (Axm : Formulas) (A : Formula) (v : nat),
      ~ In v (freeVarListFormula L Axm) -> Prf Axm A -> Prf Axm (forallH v A)
  | IMP1 : forall A B : Formula, Prf nil (impH A (impH B A))
  | IMP2 :
      forall A B C : Formula,
      Prf nil (impH (impH A (impH B C)) (impH (impH A B) (impH A C)))
  | CP :
      forall A B : Formula,
      Prf nil (impH (impH (notH A) (notH B)) (impH B A))
  | FA1 :
      forall (A : Formula) (v : nat) (t : Term),
      Prf nil (impH (forallH v A) (substituteFormula L A v t))
  | FA2 :
      forall (A : Formula) (v : nat),
      ~ In v (freeVarFormula L A) -> Prf nil (impH A (forallH v A))
  | FA3 :
      forall (A B : Formula) (v : nat),
      Prf nil
        (impH (forallH v (impH A B)) (impH (forallH v A) (forallH v B)))
  | EQ1 : Prf nil (equal (var 0) (var 0))
  | EQ2 : Prf nil (impH (equal (var 0) (var 1)) (equal (var 1) (var 0)))
  | EQ3 :
      Prf nil
        (impH (equal (var 0) (var 1))
           (impH (equal (var 1) (var 2)) (equal (var 0) (var 2))))
  | EQ4 : forall R : Relations L, Prf nil (AxmEq4 R)
  | EQ5 : forall f : Functions L, Prf nil (AxmEq5 f).

Definition SysPrf (T : System) (f : Formula) :=
  exists Axm : Formulas,
    (exists prf : Prf Axm f,
       (forall g : Formula, In g Axm -> mem _ T g)).

Definition Inconsistent (T : System) := forall f : Formula, SysPrf T f.

Definition Consistent (T : System) := exists f : Formula, ~ SysPrf T f.

End ProofH. *)
Require Import prLogic.
(* prLogic:
Require Import primRec.
Require Import code.
Require Import Arith.
Require Import cPair.

Lemma codeForallIsPR : isPR 2 (fun a b : nat => cPair 3 (cPair a b)).

Lemma codeNotIsPR : isPR 1 codeNot.

Lemma codeImpIsPR : isPR 2 codeImp. *)

Section Check_Proof.

Variable L : Language.
Variable codeF : Functions L -> nat.
Variable codeR : Relations L -> nat.
Variable codeArityF : nat -> nat.
Variable codeArityR : nat -> nat.
Hypothesis codeArityFIsPR : isPR 1 codeArityF.
Hypothesis
  codeArityFIsCorrect1 :
    forall f : Functions L, codeArityF (codeF f) = S (arity L (inr _ f)).
Hypothesis
  codeArityFIsCorrect2 :
    forall n : nat, codeArityF n <> 0 -> exists f : Functions L, codeF f = n.
Hypothesis codeArityRIsPR : isPR 1 codeArityR.
Hypothesis
  codeArityRIsCorrect1 :
    forall r : Relations L, codeArityR (codeR r) = S (arity L (inl _ r)).
Hypothesis
  codeArityRIsCorrect2 :
    forall n : nat, codeArityR n <> 0 -> exists r : Relations L, codeR r = n.

Hypothesis codeFInj : forall f g : Functions L, codeF f = codeF g -> f = g.
Hypothesis codeRInj : forall R S : Relations L, codeR R = codeR S -> R = S.

Let Term := Term L.
Let Terms := Terms L.
Let var := var L.
Let apply := apply L.
Let Formula := Formula L.
Let equal := equal L.
Let atomic := atomic L.
Let impH := impH L.
Let notH := notH L.
Let forallH := forallH L.
Let wellFormedTerm := wellFormedTerm codeArityF.
Let wellFormedFormula := wellFormedFormula codeArityF codeArityR.
Let Prf := Prf L.

Definition checkPrfAXM (p recs : nat) :=
  switchPR (charFunction 2 beq_nat (cPairPi2 (cPairPi2 p)) (cPairPi1 p))
    (S (S (cPair (cPairPi1 p) 0))) 0.

Lemma checkPrfAXMIsPR : isPR 2 checkPrfAXM.
Proof.
unfold checkPrfAXM in |- *.
apply
 filter10IsPR
  with
    (g := fun p : nat =>
          switchPR
            (charFunction 2 beq_nat (cPairPi2 (cPairPi2 p)) (cPairPi1 p))
            (S (S (cPair (cPairPi1 p) 0))) 0).
apply
 compose1_3IsPR
  with
    (f1 := fun p : nat =>
           charFunction 2 beq_nat (cPairPi2 (cPairPi2 p)) (cPairPi1 p))
    (f2 := fun p : nat => S (S (cPair (cPairPi1 p) 0)))
    (f3 := fun p : nat => 0).
apply compose1_2IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).
apply compose1_1IsPR.
apply cPairPi2IsPR.
apply cPairPi2IsPR.
apply cPairPi1IsPR.
apply eqIsPR.
apply compose1_1IsPR with (f := fun p : nat => S (cPair (cPairPi1 p) 0)).
apply compose1_1IsPR with (f := fun p : nat => cPair (cPairPi1 p) 0).
apply compose1_2IsPR with (f' := fun p : nat => 0).
apply cPairPi1IsPR.
apply const1_NIsPR.
apply cPairIsPR.
apply succIsPR.
apply succIsPR.
apply const1_NIsPR.
apply switchIsPR.
Qed.

Definition checkPrfMP (p recs : nat) :=
  switchPR
    (wellFormedFormula (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p)))) *
     (charFunction 2 beq_nat (cPairPi1 (cPairPi1 (cPairPi2 (cPairPi2 p))))
        (codeImp (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p)))) (cPairPi1 p)) *
      (codeNth (p - S (cPairPi1 (cPairPi2 (cPairPi2 p)))) recs *
       codeNth (p - S (cPairPi2 (cPairPi2 (cPairPi2 p)))) recs)))
    (S
       (codeApp
          (pred (codeNth (p - S (cPairPi1 (cPairPi2 (cPairPi2 p)))) recs))
          (pred (codeNth (p - S (cPairPi2 (cPairPi2 (cPairPi2 p)))) recs))))
    0.

Lemma checkPrfMPIsPR : isPR 2 checkPrfMP.
Proof.
unfold checkPrfMP in |- *.
apply
 compose2_3IsPR
  with
    (f1 := fun p recs : nat =>
           wellFormedFormula (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p)))) *
           (charFunction 2 beq_nat
              (cPairPi1 (cPairPi1 (cPairPi2 (cPairPi2 p))))
              (codeImp (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p))))
                 (cPairPi1 p)) *
            (codeNth (p - S (cPairPi1 (cPairPi2 (cPairPi2 p)))) recs *
             codeNth (p - S (cPairPi2 (cPairPi2 (cPairPi2 p)))) recs)))
    (f2 := fun p recs : nat =>
           S
             (codeApp
                (pred
                   (codeNth (p - S (cPairPi1 (cPairPi2 (cPairPi2 p)))) recs))
                (pred
                   (codeNth (p - S (cPairPi2 (cPairPi2 (cPairPi2 p)))) recs))))
    (f3 := fun p recs : nat => 0).
apply
 compose2_2IsPR
  with
    (f := fun p recs : nat =>
          wellFormedFormula (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p)))))
    (g := fun p recs : nat =>
          charFunction 2 beq_nat
            (cPairPi1 (cPairPi1 (cPairPi2 (cPairPi2 p))))
            (codeImp (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p))))
               (cPairPi1 p)) *
          (codeNth (p - S (cPairPi1 (cPairPi2 (cPairPi2 p)))) recs *
           codeNth (p - S (cPairPi2 (cPairPi2 (cPairPi2 p)))) recs)).
apply
 filter10IsPR
  with
    (g := fun p : nat =>
          wellFormedFormula (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p))))).
apply
 compose1_1IsPR
  with (f := fun p : nat => cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p)))).
apply
 compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 (cPairPi2 p))).
apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).
apply compose1_1IsPR; apply cPairPi2IsPR.
apply cPairPi2IsPR.
apply cPairPi1IsPR.
unfold wellFormedFormula in |- *.
apply wellFormedFormulaIsPR.
apply codeArityFIsPR.
apply codeArityRIsPR.
apply
 compose2_2IsPR
  with
    (f := fun p recs : nat =>
          charFunction 2 beq_nat
            (cPairPi1 (cPairPi1 (cPairPi2 (cPairPi2 p))))
            (codeImp (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p))))
               (cPairPi1 p)))
    (g := fun p recs : nat =>
          codeNth (p - S (cPairPi1 (cPairPi2 (cPairPi2 p)))) recs *
          codeNth (p - S (cPairPi2 (cPairPi2 (cPairPi2 p)))) recs).
apply
 filter10IsPR
  with
    (g := fun p : nat =>
          charFunction 2 beq_nat
            (cPairPi1 (cPairPi1 (cPairPi2 (cPairPi2 p))))
            (codeImp (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p))))
               (cPairPi1 p))).
apply
 compose1_2IsPR
  with
    (f := fun p : nat => cPairPi1 (cPairPi1 (cPairPi2 (cPairPi2 p))))
    (f' := fun p : nat =>
           codeImp (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p)))) (cPairPi1 p)).
apply
 compose1_1IsPR with (f := fun p : nat => cPairPi1 (cPairPi2 (cPairPi2 p))).
apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).
apply compose1_1IsPR; apply cPairPi2IsPR.
apply cPairPi1IsPR.
apply cPairPi1IsPR.
apply
 compose1_2IsPR
  with (f := fun p : nat => cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p)))).
apply
 compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 (cPairPi2 p))).
apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).
apply compose1_1IsPR; apply cPairPi2IsPR.
apply cPairPi2IsPR.
apply cPairPi1IsPR.
apply cPairPi1IsPR.
apply codeImpIsPR.
apply eqIsPR.
apply
 compose2_2IsPR
  with
    (f := fun p recs : nat =>
          codeNth (p - S (cPairPi1 (cPairPi2 (cPairPi2 p)))) recs)
    (g := fun p recs : nat =>
          codeNth (p - S (cPairPi2 (cPairPi2 (cPairPi2 p)))) recs).
apply callIsPR with (g := fun p : nat => cPairPi1 (cPairPi2 (cPairPi2 p))).
apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).
apply compose1_1IsPR; apply cPairPi2IsPR.
apply cPairPi1IsPR.
apply callIsPR with (g := fun p : nat => cPairPi2 (cPairPi2 (cPairPi2 p))).
apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).
apply compose1_1IsPR; apply cPairPi2IsPR.
apply cPairPi2IsPR.
apply multIsPR.
apply multIsPR.
apply multIsPR.
apply
 compose2_1IsPR
  with
    (f := fun p recs : nat =>
          codeApp
            (pred (codeNth (p - S (cPairPi1 (cPairPi2 (cPairPi2 p)))) recs))
            (pred (codeNth (p - S (cPairPi2 (cPairPi2 (cPairPi2 p)))) recs))).
apply
 compose2_2IsPR
  with
    (f := fun p recs : nat =>
          pred (codeNth (p - S (cPairPi1 (cPairPi2 (cPairPi2 p)))) recs))
    (g := fun p recs : nat =>
          pred (codeNth (p - S (cPairPi2 (cPairPi2 (cPairPi2 p)))) recs)).
apply
 compose2_1IsPR
  with
    (f := fun p recs : nat =>
          codeNth (p - S (cPairPi1 (cPairPi2 (cPairPi2 p)))) recs).
apply callIsPR with (g := fun p : nat => cPairPi1 (cPairPi2 (cPairPi2 p))).
apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).
apply compose1_1IsPR; apply cPairPi2IsPR.
apply cPairPi1IsPR.
apply predIsPR.
apply
 compose2_1IsPR
  with
    (f := fun p recs : nat =>
          codeNth (p - S (cPairPi2 (cPairPi2 (cPairPi2 p)))) recs).
apply callIsPR with (g := fun p : nat => cPairPi2 (cPairPi2 (cPairPi2 p))).
apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).
apply compose1_1IsPR; apply cPairPi2IsPR.
apply cPairPi2IsPR.
apply predIsPR.
apply codeAppIsPR.
apply succIsPR.
apply filter10IsPR with (g := fun _ : nat => 0).
apply const1_NIsPR.
apply switchIsPR.
Qed.

Definition checkPrfGEN (p recs : nat) :=
  switchPR
    (charFunction 2 beq_nat
       (cPair 3
          (cPair (cPairPi1 (cPairPi2 (cPairPi2 p)))
             (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p)))))) 
       (cPairPi1 p) *
     (codeNth (p - S (cPairPi2 (cPairPi2 (cPairPi2 p)))) recs *
      (1 -
       codeIn (cPairPi1 (cPairPi2 (cPairPi2 p)))
         (codeFreeVarListFormula
            (pred (codeNth (p - S (cPairPi2 (cPairPi2 (cPairPi2 p)))) recs))))))
    (codeNth (p - S (cPairPi2 (cPairPi2 (cPairPi2 p)))) recs) 0.

Lemma checkPrfGENIsPR : isPR 2 checkPrfGEN.
Proof.
unfold checkPrfGEN in |- *.
apply
 compose2_3IsPR
  with
    (f1 := fun p recs : nat =>
           charFunction 2 beq_nat
             (cPair 3
                (cPair (cPairPi1 (cPairPi2 (cPairPi2 p)))
                   (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p))))))
             (cPairPi1 p) *
           (codeNth (p - S (cPairPi2 (cPairPi2 (cPairPi2 p)))) recs *
            (1 -
             codeIn (cPairPi1 (cPairPi2 (cPairPi2 p)))
               (codeFreeVarListFormula
                  (pred
                     (codeNth (p - S (cPairPi2 (cPairPi2 (cPairPi2 p)))) recs))))))
    (f2 := fun p recs : nat =>
           codeNth (p - S (cPairPi2 (cPairPi2 (cPairPi2 p)))) recs)
    (f3 := fun p recs : nat => 0).
apply
 compose2_2IsPR
  with
    (f := fun p recs : nat =>
          charFunction 2 beq_nat
            (cPair 3
               (cPair (cPairPi1 (cPairPi2 (cPairPi2 p)))
                  (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p))))))
            (cPairPi1 p))
    (g := fun p recs : nat =>
          codeNth (p - S (cPairPi2 (cPairPi2 (cPairPi2 p)))) recs *
          (1 -
           codeIn (cPairPi1 (cPairPi2 (cPairPi2 p)))
             (codeFreeVarListFormula
                (pred
                   (codeNth (p - S (cPairPi2 (cPairPi2 (cPairPi2 p)))) recs))))).
apply
 filter10IsPR
  with
    (g := fun p : nat =>
          charFunction 2 beq_nat
            (cPair 3
               (cPair (cPairPi1 (cPairPi2 (cPairPi2 p)))
                  (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p))))))
            (cPairPi1 p)).
apply
 compose1_2IsPR
  with
    (f := fun p : nat =>
          cPair 3
            (cPair (cPairPi1 (cPairPi2 (cPairPi2 p)))
               (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p))))))
    (f' := fun p : nat => cPairPi1 p).
apply
 compose1_2IsPR
  with
    (f := fun p : nat => 3)
    (f' := fun p : nat =>
           cPair (cPairPi1 (cPairPi2 (cPairPi2 p)))
             (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p))))).
apply const1_NIsPR.
apply
 compose1_2IsPR
  with
    (f := fun p : nat => cPairPi1 (cPairPi2 (cPairPi2 p)))
    (f' := fun p : nat => cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p)))).
apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).
apply compose1_1IsPR; apply cPairPi2IsPR.
apply cPairPi1IsPR.
apply
 compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 (cPairPi2 p))).
apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).
apply compose1_1IsPR; apply cPairPi2IsPR.
apply cPairPi2IsPR.
apply cPairPi1IsPR.
apply cPairIsPR.
apply cPairIsPR.
apply cPairPi1IsPR.
apply eqIsPR.
apply
 compose2_2IsPR
  with
    (f := fun p recs : nat =>
          codeNth (p - S (cPairPi2 (cPairPi2 (cPairPi2 p)))) recs)
    (g := fun p recs : nat =>
          1 -
          codeIn (cPairPi1 (cPairPi2 (cPairPi2 p)))
            (codeFreeVarListFormula
               (pred
                  (codeNth (p - S (cPairPi2 (cPairPi2 (cPairPi2 p)))) recs)))).
apply callIsPR with (g := fun p : nat => cPairPi2 (cPairPi2 (cPairPi2 p))).
apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).
apply compose1_1IsPR; apply cPairPi2IsPR.
apply cPairPi2IsPR.
apply
 compose2_2IsPR
  with
    (f := fun p recs : nat => 1)
    (g := fun p recs : nat =>
          codeIn (cPairPi1 (cPairPi2 (cPairPi2 p)))
            (codeFreeVarListFormula
               (pred
                  (codeNth (p - S (cPairPi2 (cPairPi2 (cPairPi2 p)))) recs)))).
apply filter10IsPR with (g := fun _ : nat => 1).
apply const1_NIsPR.
apply
 compose2_2IsPR
  with
    (f := fun p recs : nat => cPairPi1 (cPairPi2 (cPairPi2 p)))
    (g := fun p recs : nat =>
          codeFreeVarListFormula
            (pred (codeNth (p - S (cPairPi2 (cPairPi2 (cPairPi2 p)))) recs))).
apply
 filter10IsPR with (g := fun p : nat => cPairPi1 (cPairPi2 (cPairPi2 p))).
apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).
apply compose1_1IsPR; apply cPairPi2IsPR.
apply cPairPi1IsPR.
apply
 compose2_1IsPR
  with
    (f := fun p recs : nat =>
          pred (codeNth (p - S (cPairPi2 (cPairPi2 (cPairPi2 p)))) recs)).
apply
 compose2_1IsPR
  with
    (f := fun p recs : nat =>
          codeNth (p - S (cPairPi2 (cPairPi2 (cPairPi2 p)))) recs).
apply callIsPR with (g := fun p : nat => cPairPi2 (cPairPi2 (cPairPi2 p))).
apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).
apply compose1_1IsPR; apply cPairPi2IsPR.
apply cPairPi2IsPR.
apply predIsPR.
apply codeFreeVarListFormulaIsPR.
apply codeInIsPR.
apply minusIsPR.
apply multIsPR.
apply multIsPR.
apply callIsPR with (g := fun p : nat => cPairPi2 (cPairPi2 (cPairPi2 p))).
apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).
apply compose1_1IsPR; apply cPairPi2IsPR.
apply cPairPi2IsPR.
apply filter10IsPR with (g := fun _ : nat => 0).
apply const1_NIsPR.
apply switchIsPR.
Qed.

Definition checkPrfIMP1 (p recs : nat) :=
  let A := cPairPi1 (cPairPi2 (cPairPi2 p)) in
  let B := cPairPi2 (cPairPi2 (cPairPi2 p)) in
  charFunction 2 beq_nat (cPair 1 (cPair A (cPair 1 (cPair B A))))
    (cPairPi1 p).

Lemma checkPrfIMP1IsPR : isPR 2 checkPrfIMP1.
Proof.
unfold checkPrfIMP1 in |- *.
apply
 filter10IsPR
  with
    (g := fun p : nat =>
          charFunction 2 beq_nat
            (cPair 1
               (cPair (cPairPi1 (cPairPi2 (cPairPi2 p)))
                  (cPair 1
                     (cPair (cPairPi2 (cPairPi2 (cPairPi2 p)))
                        (cPairPi1 (cPairPi2 (cPairPi2 p))))))) 
            (cPairPi1 p)).
assert (isPR 1 (fun p : nat => cPairPi1 (cPairPi2 (cPairPi2 p)))).
apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).
apply compose1_1IsPR; apply cPairPi2IsPR.
apply cPairPi1IsPR.
assert (isPR 1 (fun p : nat => cPairPi2 (cPairPi2 (cPairPi2 p)))).
apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).
apply compose1_1IsPR; apply cPairPi2IsPR.
apply cPairPi2IsPR.
apply
 compose1_2IsPR
  with
    (f := fun p : nat =>
          cPair 1
            (cPair (cPairPi1 (cPairPi2 (cPairPi2 p)))
               (cPair 1
                  (cPair (cPairPi2 (cPairPi2 (cPairPi2 p)))
                     (cPairPi1 (cPairPi2 (cPairPi2 p))))))).
apply
 compose1_2IsPR
  with
    (f := fun p : nat => 1)
    (f' := fun p : nat =>
           cPair (cPairPi1 (cPairPi2 (cPairPi2 p)))
             (cPair 1
                (cPair (cPairPi2 (cPairPi2 (cPairPi2 p)))
                   (cPairPi1 (cPairPi2 (cPairPi2 p)))))).
apply const1_NIsPR.
apply
 compose1_2IsPR
  with
    (f := fun p : nat => cPairPi1 (cPairPi2 (cPairPi2 p)))
    (f' := fun p : nat =>
           cPair 1
             (cPair (cPairPi2 (cPairPi2 (cPairPi2 p)))
                (cPairPi1 (cPairPi2 (cPairPi2 p))))).
assumption.
apply
 compose1_2IsPR
  with
    (f := fun p : nat => 1)
    (f' := fun p : nat =>
           cPair (cPairPi2 (cPairPi2 (cPairPi2 p)))
             (cPairPi1 (cPairPi2 (cPairPi2 p)))).
apply const1_NIsPR.
apply
 compose1_2IsPR
  with
    (f := fun p : nat => cPairPi2 (cPairPi2 (cPairPi2 p)))
    (f' := fun p : nat => cPairPi1 (cPairPi2 (cPairPi2 p))).
assumption.
assumption.
apply cPairIsPR.
apply cPairIsPR.
apply cPairIsPR.
apply cPairIsPR.
apply cPairPi1IsPR.
apply eqIsPR.
Qed.

Definition checkPrfIMP2 (p recs : nat) :=
  let A := cPairPi1 (cPairPi2 (cPairPi2 p)) in
  let B := cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p))) in
  let C := cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p))) in
  charFunction 2 beq_nat
    (cPair 1
       (cPair (cPair 1 (cPair A (cPair 1 (cPair B C))))
          (cPair 1 (cPair (cPair 1 (cPair A B)) (cPair 1 (cPair A C))))))
    (cPairPi1 p).

Lemma checkPrfIMP2IsPR : isPR 2 checkPrfIMP2.
Proof.
unfold checkPrfIMP2 in |- *.
apply
 filter10IsPR
  with
    (g := fun p : nat =>
          charFunction 2 beq_nat
            (cPair 1
               (cPair
                  (cPair 1
                     (cPair (cPairPi1 (cPairPi2 (cPairPi2 p)))
                        (cPair 1
                           (cPair
                              (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p))))
                              (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p))))))))
                  (cPair 1
                     (cPair
                        (cPair 1
                           (cPair (cPairPi1 (cPairPi2 (cPairPi2 p)))
                              (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p))))))
                        (cPair 1
                           (cPair (cPairPi1 (cPairPi2 (cPairPi2 p)))
                              (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p))))))))))
            (cPairPi1 p)).
assert (isPR 1 (fun p : nat => cPairPi1 (cPairPi2 (cPairPi2 p)))).
apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).
apply compose1_1IsPR; apply cPairPi2IsPR.
apply cPairPi1IsPR.
assert (isPR 1 (fun p : nat => cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p))))).
apply
 compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 (cPairPi2 p))).
apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).
apply compose1_1IsPR; apply cPairPi2IsPR.
apply cPairPi2IsPR.
apply cPairPi1IsPR.
assert (isPR 1 (fun p : nat => cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p))))).
apply
 compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 (cPairPi2 p))).
apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).
apply compose1_1IsPR; apply cPairPi2IsPR.
apply cPairPi2IsPR.
apply cPairPi2IsPR.
apply
 compose1_2IsPR
  with
    (f := fun p : nat =>
          cPair 1
            (cPair
               (cPair 1
                  (cPair (cPairPi1 (cPairPi2 (cPairPi2 p)))
                     (cPair 1
                        (cPair (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p))))
                           (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p))))))))
               (cPair 1
                  (cPair
                     (cPair 1
                        (cPair (cPairPi1 (cPairPi2 (cPairPi2 p)))
                           (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p))))))
                     (cPair 1
                        (cPair (cPairPi1 (cPairPi2 (cPairPi2 p)))
                           (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p)))))))))).
replace
 (fun p : nat =>
  cPair 1
    (cPair
       (cPair 1
          (cPair (cPairPi1 (cPairPi2 (cPairPi2 p)))
             (cPair 1
                (cPair (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p))))
                   (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p))))))))
       (cPair 1
          (cPair
             (cPair 1
                (cPair (cPairPi1 (cPairPi2 (cPairPi2 p)))
                   (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p))))))
             (cPair 1
                (cPair (cPairPi1 (cPairPi2 (cPairPi2 p)))
                   (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p)))))))))) with
 (fun p : nat =>
  codeImp
    (codeImp (cPairPi1 (cPairPi2 (cPairPi2 p)))
       (codeImp (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p))))
          (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p))))))
    (codeImp
       (codeImp (cPairPi1 (cPairPi2 (cPairPi2 p)))
          (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p)))))
       (codeImp (cPairPi1 (cPairPi2 (cPairPi2 p)))
          (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p)))))));
 [ idtac | reflexivity ].
apply
 compose1_2IsPR
  with
    (f := fun p : nat =>
          codeImp (cPairPi1 (cPairPi2 (cPairPi2 p)))
            (codeImp (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p))))
               (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p))))))
    (f' := fun p : nat =>
           codeImp
             (codeImp (cPairPi1 (cPairPi2 (cPairPi2 p)))
                (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p)))))
             (codeImp (cPairPi1 (cPairPi2 (cPairPi2 p)))
                (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p)))))).
apply
 compose1_2IsPR
  with
    (f := fun p : nat => cPairPi1 (cPairPi2 (cPairPi2 p)))
    (f' := fun p : nat =>
           codeImp (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p))))
             (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p))))).
assumption.
apply
 compose1_2IsPR
  with
    (f := fun p : nat => cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p))))
    (f' := fun p : nat => cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p)))).
assumption.
assumption.
apply codeImpIsPR.
apply codeImpIsPR.
apply
 compose1_2IsPR
  with
    (f := fun p : nat =>
          codeImp (cPairPi1 (cPairPi2 (cPairPi2 p)))
            (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p)))))
    (f' := fun p : nat =>
           codeImp (cPairPi1 (cPairPi2 (cPairPi2 p)))
             (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p))))).
apply
 compose1_2IsPR
  with
    (f := fun p : nat => cPairPi1 (cPairPi2 (cPairPi2 p)))
    (f' := fun p : nat => cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p)))).
assumption.
assumption.
apply codeImpIsPR.
apply
 compose1_2IsPR
  with
    (f := fun p : nat => cPairPi1 (cPairPi2 (cPairPi2 p)))
    (f' := fun p : nat => cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p)))).
assumption.
assumption.
apply codeImpIsPR.
apply codeImpIsPR.
apply codeImpIsPR.
apply cPairPi1IsPR.
apply eqIsPR.
Qed.

Definition checkPrfCP (p recs : nat) :=
  let A := cPairPi1 (cPairPi2 (cPairPi2 p)) in
  let B := cPairPi2 (cPairPi2 (cPairPi2 p)) in
  charFunction 2 beq_nat
    (cPair 1
       (cPair (cPair 1 (cPair (cPair 2 A) (cPair 2 B))) (cPair 1 (cPair B A))))
    (cPairPi1 p).

Lemma checkPrfCPIsPR : isPR 2 checkPrfCP.
Proof.
unfold checkPrfCP in |- *.
apply
 filter10IsPR
  with
    (g := fun p : nat =>
          charFunction 2 beq_nat
            (cPair 1
               (cPair
                  (cPair 1
                     (cPair (cPair 2 (cPairPi1 (cPairPi2 (cPairPi2 p))))
                        (cPair 2 (cPairPi2 (cPairPi2 (cPairPi2 p))))))
                  (cPair 1
                     (cPair (cPairPi2 (cPairPi2 (cPairPi2 p)))
                        (cPairPi1 (cPairPi2 (cPairPi2 p))))))) 
            (cPairPi1 p)).
assert (isPR 1 (fun p : nat => cPairPi1 (cPairPi2 (cPairPi2 p)))).
apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).
apply compose1_1IsPR; apply cPairPi2IsPR.
apply cPairPi1IsPR.
assert (isPR 1 (fun p : nat => cPairPi2 (cPairPi2 (cPairPi2 p)))).
apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).
apply compose1_1IsPR; apply cPairPi2IsPR.
apply cPairPi2IsPR.
apply
 compose1_2IsPR
  with
    (f := fun p : nat =>
          cPair 1
            (cPair
               (cPair 1
                  (cPair (cPair 2 (cPairPi1 (cPairPi2 (cPairPi2 p))))
                     (cPair 2 (cPairPi2 (cPairPi2 (cPairPi2 p))))))
               (cPair 1
                  (cPair (cPairPi2 (cPairPi2 (cPairPi2 p)))
                     (cPairPi1 (cPairPi2 (cPairPi2 p))))))).
replace
 (fun p : nat =>
  cPair 1
    (cPair
       (cPair 1
          (cPair (cPair 2 (cPairPi1 (cPairPi2 (cPairPi2 p))))
             (cPair 2 (cPairPi2 (cPairPi2 (cPairPi2 p))))))
       (cPair 1
          (cPair (cPairPi2 (cPairPi2 (cPairPi2 p)))
             (cPairPi1 (cPairPi2 (cPairPi2 p))))))) with
 (fun p : nat =>
  codeImp
    (codeImp (codeNot (cPairPi1 (cPairPi2 (cPairPi2 p))))
       (codeNot (cPairPi2 (cPairPi2 (cPairPi2 p)))))
    (codeImp (cPairPi2 (cPairPi2 (cPairPi2 p)))
       (cPairPi1 (cPairPi2 (cPairPi2 p))))); [ idtac | reflexivity ].
apply
 compose1_2IsPR
  with
    (f := fun p : nat =>
          codeImp (codeNot (cPairPi1 (cPairPi2 (cPairPi2 p))))
            (codeNot (cPairPi2 (cPairPi2 (cPairPi2 p)))))
    (f' := fun p : nat =>
           codeImp (cPairPi2 (cPairPi2 (cPairPi2 p)))
             (cPairPi1 (cPairPi2 (cPairPi2 p)))).
apply
 compose1_2IsPR
  with
    (f := fun p : nat => codeNot (cPairPi1 (cPairPi2 (cPairPi2 p))))
    (f' := fun p : nat => codeNot (cPairPi2 (cPairPi2 (cPairPi2 p)))).
apply
 compose1_1IsPR with (f := fun p : nat => cPairPi1 (cPairPi2 (cPairPi2 p))).
assumption.
apply codeNotIsPR.
apply
 compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 (cPairPi2 p))).
assumption.
apply codeNotIsPR.
apply codeImpIsPR.
apply
 compose1_2IsPR
  with
    (f := fun p : nat => cPairPi2 (cPairPi2 (cPairPi2 p)))
    (f' := fun p : nat => cPairPi1 (cPairPi2 (cPairPi2 p))).
assumption.
assumption.
apply codeImpIsPR.
apply codeImpIsPR.
apply cPairPi1IsPR.
apply eqIsPR.
Qed.

Definition checkPrfFA1 (p recs : nat) :=
  let A := cPairPi1 (cPairPi2 (cPairPi2 p)) in
  let v := cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p))) in
  let t := cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p))) in
  wellFormedTerm t *
  charFunction 2 beq_nat
    (cPair 1 (cPair (cPair 3 (cPair v A)) (codeSubFormula A v t)))
    (cPairPi1 p).

Lemma checkPrfFA1IsPR : isPR 2 checkPrfFA1.
Proof.
unfold checkPrfFA1 in |- *.
apply
 filter10IsPR
  with
    (g := fun p : nat =>
          wellFormedTerm (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p)))) *
          charFunction 2 beq_nat
            (cPair 1
               (cPair
                  (cPair 3
                     (cPair (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p))))
                        (cPairPi1 (cPairPi2 (cPairPi2 p)))))
                  (codeSubFormula (cPairPi1 (cPairPi2 (cPairPi2 p)))
                     (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p))))
                     (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p)))))))
            (cPairPi1 p)).
assert (isPR 1 (fun p : nat => cPairPi1 (cPairPi2 (cPairPi2 p)))).
apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).
apply compose1_1IsPR; apply cPairPi2IsPR.
apply cPairPi1IsPR.
assert (isPR 1 (fun p : nat => cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p))))).
apply
 compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 (cPairPi2 p))).
apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).
apply compose1_1IsPR; apply cPairPi2IsPR.
apply cPairPi2IsPR.
apply cPairPi1IsPR.
assert (isPR 1 (fun p : nat => cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p))))).
apply
 compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 (cPairPi2 p))).
apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).
apply compose1_1IsPR; apply cPairPi2IsPR.
apply cPairPi2IsPR.
apply cPairPi2IsPR.
apply
 compose1_2IsPR
  with
    (f := fun p : nat =>
          wellFormedTerm (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p)))))
    (f' := fun p : nat =>
           charFunction 2 beq_nat
             (cPair 1
                (cPair
                   (cPair 3
                      (cPair (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p))))
                         (cPairPi1 (cPairPi2 (cPairPi2 p)))))
                   (codeSubFormula (cPairPi1 (cPairPi2 (cPairPi2 p)))
                      (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p))))
                      (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p)))))))
             (cPairPi1 p)).
apply
 compose1_1IsPR
  with (f := fun p : nat => cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p)))).
assumption.
unfold wellFormedTerm in |- *.
apply wellFormedTermIsPR.
apply codeArityFIsPR.
apply
 compose1_2IsPR
  with
    (f := fun p : nat =>
          cPair 1
            (cPair
               (cPair 3
                  (cPair (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p))))
                     (cPairPi1 (cPairPi2 (cPairPi2 p)))))
               (codeSubFormula (cPairPi1 (cPairPi2 (cPairPi2 p)))
                  (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p))))
                  (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p))))))).
replace
 (fun p : nat =>
  cPair 1
    (cPair
       (cPair 3
          (cPair (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p))))
             (cPairPi1 (cPairPi2 (cPairPi2 p)))))
       (codeSubFormula (cPairPi1 (cPairPi2 (cPairPi2 p)))
          (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p))))
          (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p))))))) with
 (fun p : nat =>
  codeImp
    (cPair 3
       (cPair (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p))))
          (cPairPi1 (cPairPi2 (cPairPi2 p)))))
    (codeSubFormula (cPairPi1 (cPairPi2 (cPairPi2 p)))
       (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p))))
       (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p))))));
 [ idtac | reflexivity ].
apply
 compose1_2IsPR
  with
    (f := fun p : nat =>
          cPair 3
            (cPair (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p))))
               (cPairPi1 (cPairPi2 (cPairPi2 p)))))
    (f' := fun p : nat =>
           codeSubFormula (cPairPi1 (cPairPi2 (cPairPi2 p)))
             (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p))))
             (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p))))).
apply
 compose1_2IsPR
  with
    (f := fun p : nat => cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p))))
    (f' := fun p : nat => cPairPi1 (cPairPi2 (cPairPi2 p)))
    (g := fun a b : nat => cPair 3 (cPair a b)).
assumption.
assumption.
apply codeForallIsPR.
apply
 compose1_3IsPR
  with
    (f1 := fun p : nat => cPairPi1 (cPairPi2 (cPairPi2 p)))
    (f2 := fun p : nat => cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p))))
    (f3 := fun p : nat => cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p))));
 try assumption.
apply codeSubFormulaIsPR.
apply codeImpIsPR.
apply cPairPi1IsPR.
apply eqIsPR.
apply multIsPR.
Qed.

Definition checkPrfFA2 (p recs : nat) :=
  let A := cPairPi1 (cPairPi2 (cPairPi2 p)) in
  let v := cPairPi2 (cPairPi2 (cPairPi2 p)) in
  (1 - codeIn v (codeFreeVarFormula A)) *
  charFunction 2 beq_nat (cPair 1 (cPair A (cPair 3 (cPair v A))))
    (cPairPi1 p).

Lemma checkPrfFA2IsPR : isPR 2 checkPrfFA2.
Proof.
unfold checkPrfFA2 in |- *.
apply
 filter10IsPR
  with
    (g := fun p : nat =>
          (1 -
           codeIn (cPairPi2 (cPairPi2 (cPairPi2 p)))
             (codeFreeVarFormula (cPairPi1 (cPairPi2 (cPairPi2 p))))) *
          charFunction 2 beq_nat
            (cPair 1
               (cPair (cPairPi1 (cPairPi2 (cPairPi2 p)))
                  (cPair 3
                     (cPair (cPairPi2 (cPairPi2 (cPairPi2 p)))
                        (cPairPi1 (cPairPi2 (cPairPi2 p))))))) 
            (cPairPi1 p)).
assert (isPR 1 (fun p : nat => cPairPi1 (cPairPi2 (cPairPi2 p)))).
apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).
apply compose1_1IsPR; apply cPairPi2IsPR.
apply cPairPi1IsPR.
assert (isPR 1 (fun p : nat => cPairPi2 (cPairPi2 (cPairPi2 p)))).
apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).
apply compose1_1IsPR; apply cPairPi2IsPR.
apply cPairPi2IsPR.
apply
 compose1_2IsPR
  with
    (f := fun p : nat =>
          1 -
          codeIn (cPairPi2 (cPairPi2 (cPairPi2 p)))
            (codeFreeVarFormula (cPairPi1 (cPairPi2 (cPairPi2 p)))))
    (f' := fun p : nat =>
           charFunction 2 beq_nat
             (cPair 1
                (cPair (cPairPi1 (cPairPi2 (cPairPi2 p)))
                   (cPair 3
                      (cPair (cPairPi2 (cPairPi2 (cPairPi2 p)))
                         (cPairPi1 (cPairPi2 (cPairPi2 p))))))) 
             (cPairPi1 p)).
apply
 compose1_2IsPR
  with
    (f := fun p : nat => 1)
    (f' := fun p : nat =>
           codeIn (cPairPi2 (cPairPi2 (cPairPi2 p)))
             (codeFreeVarFormula (cPairPi1 (cPairPi2 (cPairPi2 p))))).
apply const1_NIsPR.
apply
 compose1_2IsPR
  with
    (f := fun p : nat => cPairPi2 (cPairPi2 (cPairPi2 p)))
    (f' := fun p : nat =>
           codeFreeVarFormula (cPairPi1 (cPairPi2 (cPairPi2 p)))).
assumption.
apply
 compose1_1IsPR with (f := fun p : nat => cPairPi1 (cPairPi2 (cPairPi2 p))).
assumption.
apply codeFreeVarFormulaIsPR.
apply codeInIsPR.
apply minusIsPR.
apply
 compose1_2IsPR
  with
    (f := fun p : nat =>
          cPair 1
            (cPair (cPairPi1 (cPairPi2 (cPairPi2 p)))
               (cPair 3
                  (cPair (cPairPi2 (cPairPi2 (cPairPi2 p)))
                     (cPairPi1 (cPairPi2 (cPairPi2 p))))))).
replace
 (fun p : nat =>
  cPair 1
    (cPair (cPairPi1 (cPairPi2 (cPairPi2 p)))
       (cPair 3
          (cPair (cPairPi2 (cPairPi2 (cPairPi2 p)))
             (cPairPi1 (cPairPi2 (cPairPi2 p))))))) with
 (fun p : nat =>
  codeImp (cPairPi1 (cPairPi2 (cPairPi2 p)))
    (cPair 3
       (cPair (cPairPi2 (cPairPi2 (cPairPi2 p)))
          (cPairPi1 (cPairPi2 (cPairPi2 p)))))); [ idtac | reflexivity ].
apply
 compose1_2IsPR
  with
    (f := fun p : nat => cPairPi1 (cPairPi2 (cPairPi2 p)))
    (f' := fun p : nat =>
           cPair 3
             (cPair (cPairPi2 (cPairPi2 (cPairPi2 p)))
                (cPairPi1 (cPairPi2 (cPairPi2 p))))).
assumption.
apply
 compose1_2IsPR
  with
    (f := fun p : nat => cPairPi2 (cPairPi2 (cPairPi2 p)))
    (f' := fun p : nat => cPairPi1 (cPairPi2 (cPairPi2 p)))
    (g := fun a b : nat => cPair 3 (cPair a b)).
assumption.
assumption.
apply codeForallIsPR.
apply codeImpIsPR.
apply cPairPi1IsPR.
apply eqIsPR.
apply multIsPR.
Qed.

Definition checkPrfFA3 (p recs : nat) :=
  let A := cPairPi1 (cPairPi2 (cPairPi2 p)) in
  let B := cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p))) in
  let v := cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p))) in
  charFunction 2 beq_nat
    (cPair 1
       (cPair (cPair 3 (cPair v (cPair 1 (cPair A B))))
          (cPair 1 (cPair (cPair 3 (cPair v A)) (cPair 3 (cPair v B))))))
    (cPairPi1 p).

Lemma checkPrfFA3IsPR : isPR 2 checkPrfFA3.
Proof.
unfold checkPrfFA3 in |- *.
apply
 filter10IsPR
  with
    (g := fun p : nat =>
          charFunction 2 beq_nat
            (cPair 1
               (cPair
                  (cPair 3
                     (cPair (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p))))
                        (cPair 1
                           (cPair (cPairPi1 (cPairPi2 (cPairPi2 p)))
                              (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p))))))))
                  (cPair 1
                     (cPair
                        (cPair 3
                           (cPair
                              (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p))))
                              (cPairPi1 (cPairPi2 (cPairPi2 p)))))
                        (cPair 3
                           (cPair
                              (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p))))
                              (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p))))))))))
            (cPairPi1 p)).
assert (isPR 1 (fun p : nat => cPairPi1 (cPairPi2 (cPairPi2 p)))).
apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).
apply compose1_1IsPR; apply cPairPi2IsPR.
apply cPairPi1IsPR.
assert (isPR 1 (fun p : nat => cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p))))).
apply
 compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 (cPairPi2 p))).
apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).
apply compose1_1IsPR; apply cPairPi2IsPR.
apply cPairPi2IsPR.
apply cPairPi1IsPR.
assert (isPR 1 (fun p : nat => cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p))))).
apply
 compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 (cPairPi2 p))).
apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).
apply compose1_1IsPR; apply cPairPi2IsPR.
apply cPairPi2IsPR.
apply cPairPi2IsPR.
apply
 compose1_2IsPR
  with
    (f := fun p : nat =>
          cPair 1
            (cPair
               (cPair 3
                  (cPair (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p))))
                     (cPair 1
                        (cPair (cPairPi1 (cPairPi2 (cPairPi2 p)))
                           (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p))))))))
               (cPair 1
                  (cPair
                     (cPair 3
                        (cPair (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p))))
                           (cPairPi1 (cPairPi2 (cPairPi2 p)))))
                     (cPair 3
                        (cPair (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p))))
                           (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p)))))))))).
replace
 (fun p : nat =>
  cPair 1
    (cPair
       (cPair 3
          (cPair (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p))))
             (cPair 1
                (cPair (cPairPi1 (cPairPi2 (cPairPi2 p)))
                   (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p))))))))
       (cPair 1
          (cPair
             (cPair 3
                (cPair (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p))))
                   (cPairPi1 (cPairPi2 (cPairPi2 p)))))
             (cPair 3
                (cPair (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p))))
                   (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p)))))))))) with
 (fun p : nat =>
  codeImp
    (cPair 3
       (cPair (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p))))
          (codeImp (cPairPi1 (cPairPi2 (cPairPi2 p)))
             (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p)))))))
    (codeImp
       (cPair 3
          (cPair (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p))))
             (cPairPi1 (cPairPi2 (cPairPi2 p)))))
       (cPair 3
          (cPair (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p))))
             (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p))))))));
 [ idtac | reflexivity ].
apply
 compose1_2IsPR
  with
    (f := fun p : nat =>
          cPair 3
            (cPair (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p))))
               (codeImp (cPairPi1 (cPairPi2 (cPairPi2 p)))
                  (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p)))))))
    (f' := fun p : nat =>
           codeImp
             (cPair 3
                (cPair (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p))))
                   (cPairPi1 (cPairPi2 (cPairPi2 p)))))
             (cPair 3
                (cPair (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p))))
                   (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p))))))).
apply
 compose1_2IsPR
  with
    (f := fun p : nat => cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p))))
    (f' := fun p : nat =>
           codeImp (cPairPi1 (cPairPi2 (cPairPi2 p)))
             (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p)))))
    (g := fun a b : nat => cPair 3 (cPair a b)).
assumption.
apply
 compose1_2IsPR
  with
    (f := fun p : nat => cPairPi1 (cPairPi2 (cPairPi2 p)))
    (f' := fun p : nat => cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p)))).
assumption.
assumption.
apply codeImpIsPR.
apply codeForallIsPR.
apply
 compose1_2IsPR
  with
    (f := fun p : nat =>
          cPair 3
            (cPair (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p))))
               (cPairPi1 (cPairPi2 (cPairPi2 p)))))
    (f' := fun p : nat =>
           cPair 3
             (cPair (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p))))
                (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p)))))).
apply
 compose1_2IsPR
  with
    (f := fun p : nat => cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p))))
    (f' := fun p : nat => cPairPi1 (cPairPi2 (cPairPi2 p)))
    (g := fun a b : nat => cPair 3 (cPair a b)).
assumption.
assumption.
apply codeForallIsPR.
apply
 compose1_2IsPR
  with
    (f := fun p : nat => cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p))))
    (f' := fun p : nat => cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p))))
    (g := fun a b : nat => cPair 3 (cPair a b)).
assumption.
assumption.
apply codeForallIsPR.
apply codeImpIsPR.
apply codeImpIsPR.
apply cPairPi1IsPR.
apply eqIsPR.
Qed.

Definition checkPrfEQ1 (p recs : nat) :=
  charFunction 2 beq_nat (cPairPi2 (cPairPi2 p)) 0 *
  charFunction 2 beq_nat
    (codeFormula L codeF codeR (fol.equal L (fol.var L 0) (fol.var L 0)))
    (cPairPi1 p).

Lemma checkPrfEQnIsPR :
 forall n : nat,
 isPR 2
   (fun p recs : nat =>
    charFunction 2 beq_nat (cPairPi2 (cPairPi2 p)) 0 *
    charFunction 2 beq_nat n (cPairPi1 p)).
Proof.
unfold checkPrfEQ1 in |- *.
intros.
apply
 filter10IsPR
  with
    (g := fun p : nat =>
          charFunction 2 beq_nat (cPairPi2 (cPairPi2 p)) 0 *
          charFunction 2 beq_nat n (cPairPi1 p)).
apply
 compose1_2IsPR
  with
    (f := fun p : nat => charFunction 2 beq_nat (cPairPi2 (cPairPi2 p)) 0)
    (f' := fun p : nat => charFunction 2 beq_nat n (cPairPi1 p)).
apply
 compose1_2IsPR
  with (f := fun p : nat => cPairPi2 (cPairPi2 p)) (f' := fun p : nat => 0).
apply compose1_1IsPR; apply cPairPi2IsPR. 
apply const1_NIsPR.
apply eqIsPR.
apply compose1_2IsPR with (f := fun p : nat => n).
apply const1_NIsPR.
apply cPairPi1IsPR.
apply eqIsPR.
apply multIsPR.
Qed.

Lemma checkPrfEQ1IsPR : isPR 2 checkPrfEQ1.
Proof.
unfold checkPrfEQ1 in |- *.
apply checkPrfEQnIsPR.
Qed.

Definition checkPrfEQ2 (p recs : nat) :=
  charFunction 2 beq_nat (cPairPi2 (cPairPi2 p)) 0 *
  charFunction 2 beq_nat
    (codeFormula L codeF codeR
       (fol.impH L (fol.equal L (fol.var L 0) (fol.var L 1))
          (fol.equal L (fol.var L 1) (fol.var L 0)))) 
    (cPairPi1 p).

Lemma checkPrfEQ2IsPR : isPR 2 checkPrfEQ2.
Proof.
unfold checkPrfEQ2 in |- *.
apply checkPrfEQnIsPR.
Qed.

Definition checkPrfEQ3 (p recs : nat) :=
  charFunction 2 beq_nat (cPairPi2 (cPairPi2 p)) 0 *
  charFunction 2 beq_nat
    (codeFormula L codeF codeR
       (fol.impH L (fol.equal L (fol.var L 0) (fol.var L 1))
          (fol.impH L (fol.equal L (fol.var L 1) (fol.var L 2))
             (fol.equal L (fol.var L 0) (fol.var L 2))))) 
    (cPairPi1 p).

Lemma checkPrfEQ3IsPR : isPR 2 checkPrfEQ3.
Proof.
unfold checkPrfEQ3 in |- *.
apply checkPrfEQnIsPR.
Qed.

Definition codeAxmEqHelp (n f : nat) : nat :=
  nat_rec (fun _ => nat) f
    (fun m rec : nat =>
     cPair 1
       (cPair (cPair 0 (cPair (cPair 0 (m + m)) (cPair 0 (S (m + m))))) rec))
    n.

Lemma codeAxmEqHelpIsPR : isPR 2 codeAxmEqHelp.
Proof.
unfold codeAxmEqHelp in |- *.
apply
 ind1ParamIsPR
  with
    (g := fun f : nat => f)
    (f := fun m rec f : nat =>
          cPair 1
            (cPair (cPair 0 (cPair (cPair 0 (m + m)) (cPair 0 (S (m + m)))))
               rec)).
apply
 filter110IsPR
  with
    (g := fun m rec : nat =>
          codeImp (cPair 0 (cPair (cPair 0 (m + m)) (cPair 0 (S (m + m)))))
            rec).
apply
 compose2_2IsPR
  with
    (f := fun m rec : nat =>
          cPair 0 (cPair (cPair 0 (m + m)) (cPair 0 (S (m + m)))))
    (g := fun m rec : nat => rec).
apply
 filter10IsPR
  with
    (g := fun m : nat =>
          cPair 0 (cPair (cPair 0 (m + m)) (cPair 0 (S (m + m))))).
assert
 (forall g : nat -> nat, isPR 1 g -> isPR 1 (fun a : nat => cPair 0 (g a))).
intros.
apply compose1_2IsPR with (f := fun a : nat => 0).
apply const1_NIsPR.
assumption.
apply cPairIsPR.
apply
 H with (g := fun m : nat => cPair (cPair 0 (m + m)) (cPair 0 (S (m + m)))).
apply
 compose1_2IsPR
  with
    (f := fun m : nat => cPair 0 (m + m))
    (f' := fun m : nat => cPair 0 (S (m + m))).
apply H with (g := fun m : nat => m + m).
apply compose1_2IsPR with (f := fun m : nat => m) (f' := fun m : nat => m).
apply idIsPR.
apply idIsPR.
apply plusIsPR.
apply H with (g := fun m : nat => S (m + m)).
apply compose1_1IsPR with (f := fun m : nat => m + m).
apply compose1_2IsPR with (f := fun m : nat => m) (f' := fun m : nat => m).
apply idIsPR.
apply idIsPR.
apply plusIsPR.
apply succIsPR.
apply cPairIsPR.
apply pi2_2IsPR.
apply codeImpIsPR.
apply idIsPR.
Qed.

Definition codeNVars1 (n : nat) : nat :=
  nat_rec (fun _ => nat) 0
    (fun m rec : nat => S (cPair (cPair 0 (m + m)) rec)) n.

Lemma codeNVars1IsPR : isPR 1 codeNVars1.
Proof.
unfold codeNVars1 in |- *.
apply indIsPR with (f := fun m rec : nat => S (cPair (cPair 0 (m + m)) rec)).
apply
 compose2_1IsPR with (f := fun m rec : nat => cPair (cPair 0 (m + m)) rec).
apply
 compose2_2IsPR
  with
    (f := fun m rec : nat => cPair 0 (m + m))
    (g := fun m rec : nat => rec).
apply filter10IsPR with (g := fun m : nat => cPair 0 (m + m)).
apply
 compose1_2IsPR with (f := fun m : nat => 0) (f' := fun m : nat => m + m).
apply const1_NIsPR.
apply compose1_2IsPR with (f := fun m : nat => m) (f' := fun m : nat => m).
apply idIsPR.
apply idIsPR.
apply plusIsPR.
apply cPairIsPR.
apply pi2_2IsPR.
apply cPairIsPR.
apply succIsPR.
Qed.

Definition codeNVars2 (n : nat) : nat :=
  nat_rec (fun _ => nat) 0
    (fun m rec : nat => S (cPair (cPair 0 (S (m + m))) rec)) n.

Lemma codeNVars2IsPR : isPR 1 codeNVars2.
Proof.
unfold codeNVars2 in |- *.
apply
 indIsPR with (f := fun m rec : nat => S (cPair (cPair 0 (S (m + m))) rec)).
apply
 compose2_1IsPR
  with (f := fun m rec : nat => cPair (cPair 0 (S (m + m))) rec).
apply
 compose2_2IsPR
  with
    (f := fun m rec : nat => cPair 0 (S (m + m)))
    (g := fun m rec : nat => rec).
apply filter10IsPR with (g := fun m : nat => cPair 0 (S (m + m))).
apply
 compose1_2IsPR with (f := fun m : nat => 0) (f' := fun m : nat => S (m + m)).
apply const1_NIsPR.
apply compose1_1IsPR with (f := fun m : nat => m + m).
apply compose1_2IsPR with (f := fun m : nat => m) (f' := fun m : nat => m).
apply idIsPR.
apply idIsPR.
apply plusIsPR.
apply succIsPR.
apply cPairIsPR.
apply pi2_2IsPR.
apply cPairIsPR.
apply succIsPR.
Qed.

Lemma codeNVarsCorrect :
 forall n : nat,
 codeNVars1 n = codeTerms L codeF n (fst (nVars L n)) /\
 codeNVars2 n = codeTerms L codeF n (snd (nVars L n)).
Proof.
intros.
split.
induction n as [| n Hrecn].
simpl in |- *.
reflexivity.
simpl in |- *.
rewrite Hrecn.
induction (nVars L n).
simpl in |- *.
reflexivity.
induction n as [| n Hrecn].
simpl in |- *.
reflexivity.
simpl in |- *.
rewrite Hrecn.
induction (nVars L n).
simpl in |- *.
reflexivity.
Qed.

Definition checkPrfEQ4 (p recs : nat) :=
  let r := cPairPi2 (cPairPi2 p) in
  let A := cPair (S (S (S (S r)))) (codeNVars1 (pred (codeArityR r))) in
  let B := cPair (S (S (S (S r)))) (codeNVars2 (pred (codeArityR r))) in
  notZero (codeArityR r) *
  charFunction 2 beq_nat (codeAxmEqHelp (pred (codeArityR r)) (codeIff A B))
    (cPairPi1 p).

Lemma codeOrIsPR : isPR 2 codeOr.
Proof.
unfold codeOr in |- *.
apply
 compose2_2IsPR
  with (f := fun a b : nat => codeNot a) (g := fun a b : nat => b).
apply filter10IsPR.
apply codeNotIsPR.
apply pi2_2IsPR.
apply codeImpIsPR.
Qed.

Lemma codeAndIsPR : isPR 2 codeAnd.
Proof.
unfold codeAnd in |- *.
apply
 compose2_1IsPR with (f := fun a b : nat => codeOr (codeNot a) (codeNot b)).
apply
 compose2_2IsPR
  with (f := fun a b : nat => codeNot a) (g := fun a b : nat => codeNot b).
apply filter10IsPR.
apply codeNotIsPR.
apply filter01IsPR.
apply codeNotIsPR.
apply codeOrIsPR.
apply codeNotIsPR.
Qed.

Lemma codeIffIsPR : isPR 2 codeIff.
Proof.
unfold codeIff in |- *.
apply compose2_2IsPR with (g := fun a b : nat => codeImp b a).
apply codeImpIsPR.
apply swapIsPR.
apply codeImpIsPR.
apply codeAndIsPR.
Qed.

Lemma checkPrfEQ4IsPR : isPR 2 checkPrfEQ4.
Proof.
unfold checkPrfEQ4 in |- *.
apply
 filter10IsPR
  with
    (g := fun p : nat =>
          notZero (codeArityR (cPairPi2 (cPairPi2 p))) *
          charFunction 2 beq_nat
            (codeAxmEqHelp (pred (codeArityR (cPairPi2 (cPairPi2 p))))
               (codeIff
                  (cPair (S (S (S (S (cPairPi2 (cPairPi2 p))))))
                     (codeNVars1 (pred (codeArityR (cPairPi2 (cPairPi2 p))))))
                  (cPair (S (S (S (S (cPairPi2 (cPairPi2 p))))))
                     (codeNVars2 (pred (codeArityR (cPairPi2 (cPairPi2 p))))))))
            (cPairPi1 p)).
assert (isPR 1 (fun p : nat => cPairPi2 (cPairPi2 p))).
apply compose1_1IsPR; apply cPairPi2IsPR.
apply
 compose1_2IsPR
  with
    (f := fun p : nat => notZero (codeArityR (cPairPi2 (cPairPi2 p))))
    (f' := fun p : nat =>
           charFunction 2 beq_nat
             (codeAxmEqHelp (pred (codeArityR (cPairPi2 (cPairPi2 p))))
                (codeIff
                   (cPair (S (S (S (S (cPairPi2 (cPairPi2 p))))))
                      (codeNVars1 (pred (codeArityR (cPairPi2 (cPairPi2 p))))))
                   (cPair (S (S (S (S (cPairPi2 (cPairPi2 p))))))
                      (codeNVars2 (pred (codeArityR (cPairPi2 (cPairPi2 p))))))))
             (cPairPi1 p)).
apply
 compose1_1IsPR with (f := fun p : nat => codeArityR (cPairPi2 (cPairPi2 p))).
apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).
assumption.
apply codeArityRIsPR.
apply notZeroIsPR.
apply
 compose1_2IsPR
  with
    (f := fun p : nat =>
          codeAxmEqHelp (pred (codeArityR (cPairPi2 (cPairPi2 p))))
            (codeIff
               (cPair (S (S (S (S (cPairPi2 (cPairPi2 p))))))
                  (codeNVars1 (pred (codeArityR (cPairPi2 (cPairPi2 p))))))
               (cPair (S (S (S (S (cPairPi2 (cPairPi2 p))))))
                  (codeNVars2 (pred (codeArityR (cPairPi2 (cPairPi2 p)))))))).
apply
 compose1_2IsPR
  with
    (f := fun p : nat => pred (codeArityR (cPairPi2 (cPairPi2 p))))
    (f' := fun p : nat =>
           codeIff
             (cPair (S (S (S (S (cPairPi2 (cPairPi2 p))))))
                (codeNVars1 (pred (codeArityR (cPairPi2 (cPairPi2 p))))))
             (cPair (S (S (S (S (cPairPi2 (cPairPi2 p))))))
                (codeNVars2 (pred (codeArityR (cPairPi2 (cPairPi2 p))))))).
apply
 compose1_1IsPR with (f := fun p : nat => codeArityR (cPairPi2 (cPairPi2 p))).
apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).
assumption.
apply codeArityRIsPR.
apply predIsPR.
apply
 compose1_2IsPR
  with
    (f := fun p : nat =>
          cPair (S (S (S (S (cPairPi2 (cPairPi2 p))))))
            (codeNVars1 (pred (codeArityR (cPairPi2 (cPairPi2 p))))))
    (f' := fun p : nat =>
           cPair (S (S (S (S (cPairPi2 (cPairPi2 p))))))
             (codeNVars2 (pred (codeArityR (cPairPi2 (cPairPi2 p)))))).
apply
 compose1_2IsPR
  with
    (f := fun p : nat => S (S (S (S (cPairPi2 (cPairPi2 p))))))
    (f' := fun p : nat =>
           codeNVars1 (pred (codeArityR (cPairPi2 (cPairPi2 p))))).
apply
 compose1_1IsPR
  with (f := fun p : nat => cPairPi2 (cPairPi2 p)) (g := iterate S 4).
assumption.
apply iterateIsPR.
apply succIsPR.
apply
 compose1_1IsPR
  with (f := fun p : nat => pred (codeArityR (cPairPi2 (cPairPi2 p)))).
apply
 compose1_1IsPR with (f := fun p : nat => codeArityR (cPairPi2 (cPairPi2 p))).
apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).
assumption.
apply codeArityRIsPR.
apply predIsPR.
apply codeNVars1IsPR.
apply cPairIsPR.
apply
 compose1_2IsPR
  with
    (f := fun p : nat => S (S (S (S (cPairPi2 (cPairPi2 p))))))
    (f' := fun p : nat =>
           codeNVars2 (pred (codeArityR (cPairPi2 (cPairPi2 p))))).
apply
 compose1_1IsPR
  with (f := fun p : nat => cPairPi2 (cPairPi2 p)) (g := iterate S 4).
assumption.
apply iterateIsPR.
apply succIsPR.
apply
 compose1_1IsPR
  with (f := fun p : nat => pred (codeArityR (cPairPi2 (cPairPi2 p)))).
apply
 compose1_1IsPR with (f := fun p : nat => codeArityR (cPairPi2 (cPairPi2 p))).
apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).
assumption.
apply codeArityRIsPR.
apply predIsPR.
apply codeNVars2IsPR.
apply cPairIsPR.
apply codeIffIsPR.
apply codeAxmEqHelpIsPR.
apply cPairPi1IsPR.
apply eqIsPR.
apply multIsPR.
Qed.

Definition checkPrfEQ5 (p recs : nat) :=
  let f := cPairPi2 (cPairPi2 p) in
  notZero (codeArityF f) *
  charFunction 2 beq_nat
    (codeAxmEqHelp (pred (codeArityF f))
       (cPair 0
          (cPair (cPair (S f) (codeNVars1 (pred (codeArityF f))))
             (cPair (S f) (codeNVars2 (pred (codeArityF f))))))) 
    (cPairPi1 p).

Lemma checkPrfEQ5IsPR : isPR 2 checkPrfEQ5.
Proof.
unfold checkPrfEQ5 in |- *.
apply
 filter10IsPR
  with
    (g := fun p : nat =>
          notZero (codeArityF (cPairPi2 (cPairPi2 p))) *
          charFunction 2 beq_nat
            (codeAxmEqHelp (pred (codeArityF (cPairPi2 (cPairPi2 p))))
               (cPair 0
                  (cPair
                     (cPair (S (cPairPi2 (cPairPi2 p)))
                        (codeNVars1
                           (pred (codeArityF (cPairPi2 (cPairPi2 p))))))
                     (cPair (S (cPairPi2 (cPairPi2 p)))
                        (codeNVars2
                           (pred (codeArityF (cPairPi2 (cPairPi2 p)))))))))
            (cPairPi1 p)).
assert (isPR 1 (fun p : nat => cPairPi2 (cPairPi2 p))).
apply compose1_1IsPR; apply cPairPi2IsPR.
apply
 compose1_2IsPR
  with
    (f := fun p : nat => notZero (codeArityF (cPairPi2 (cPairPi2 p))))
    (f' := fun p : nat =>
           charFunction 2 beq_nat
             (codeAxmEqHelp (pred (codeArityF (cPairPi2 (cPairPi2 p))))
                (cPair 0
                   (cPair
                      (cPair (S (cPairPi2 (cPairPi2 p)))
                         (codeNVars1
                            (pred (codeArityF (cPairPi2 (cPairPi2 p))))))
                      (cPair (S (cPairPi2 (cPairPi2 p)))
                         (codeNVars2
                            (pred (codeArityF (cPairPi2 (cPairPi2 p)))))))))
             (cPairPi1 p)).
apply
 compose1_1IsPR with (f := fun p : nat => codeArityF (cPairPi2 (cPairPi2 p))).
apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).
assumption.
apply codeArityFIsPR.
apply notZeroIsPR.
apply
 compose1_2IsPR
  with
    (f := fun p : nat =>
          codeAxmEqHelp (pred (codeArityF (cPairPi2 (cPairPi2 p))))
            (cPair 0
               (cPair
                  (cPair (S (cPairPi2 (cPairPi2 p)))
                     (codeNVars1 (pred (codeArityF (cPairPi2 (cPairPi2 p))))))
                  (cPair (S (cPairPi2 (cPairPi2 p)))
                     (codeNVars2 (pred (codeArityF (cPairPi2 (cPairPi2 p))))))))).
apply
 compose1_2IsPR
  with
    (f := fun p : nat => pred (codeArityF (cPairPi2 (cPairPi2 p))))
    (f' := fun p : nat =>
           cPair 0
             (cPair
                (cPair (S (cPairPi2 (cPairPi2 p)))
                   (codeNVars1 (pred (codeArityF (cPairPi2 (cPairPi2 p))))))
                (cPair (S (cPairPi2 (cPairPi2 p)))
                   (codeNVars2 (pred (codeArityF (cPairPi2 (cPairPi2 p)))))))).
apply
 compose1_1IsPR with (f := fun p : nat => codeArityF (cPairPi2 (cPairPi2 p))).
apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).
assumption.
apply codeArityFIsPR.
apply predIsPR.
apply
 compose1_2IsPR
  with
    (f := fun p : nat =>
          cPair (S (cPairPi2 (cPairPi2 p)))
            (codeNVars1 (pred (codeArityF (cPairPi2 (cPairPi2 p))))))
    (f' := fun p : nat =>
           cPair (S (cPairPi2 (cPairPi2 p)))
             (codeNVars2 (pred (codeArityF (cPairPi2 (cPairPi2 p))))))
    (g := fun a b : nat => cPair 0 (cPair a b)).
apply
 compose1_2IsPR
  with
    (f := fun p : nat => S (cPairPi2 (cPairPi2 p)))
    (f' := fun p : nat =>
           codeNVars1 (pred (codeArityF (cPairPi2 (cPairPi2 p))))).
apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).
assumption.
apply succIsPR.
apply
 compose1_1IsPR
  with (f := fun p : nat => pred (codeArityF (cPairPi2 (cPairPi2 p)))).
apply
 compose1_1IsPR with (f := fun p : nat => codeArityF (cPairPi2 (cPairPi2 p))).
apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).
assumption.
apply codeArityFIsPR.
apply predIsPR.
apply codeNVars1IsPR.
apply cPairIsPR.
apply
 compose1_2IsPR
  with
    (f := fun p : nat => S (cPairPi2 (cPairPi2 p)))
    (f' := fun p : nat =>
           codeNVars2 (pred (codeArityF (cPairPi2 (cPairPi2 p))))).
apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).
assumption.
apply succIsPR.
apply
 compose1_1IsPR
  with (f := fun p : nat => pred (codeArityF (cPairPi2 (cPairPi2 p)))).
apply
 compose1_1IsPR with (f := fun p : nat => codeArityF (cPairPi2 (cPairPi2 p))).
apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).
assumption.
apply codeArityFIsPR.
apply predIsPR.
apply codeNVars2IsPR.
apply cPairIsPR.
apply compose2_2IsPR with (f := fun a b : nat => 0).
apply filter10IsPR with (g := fun _ : nat => 0).
apply const1_NIsPR.
apply cPairIsPR.
apply cPairIsPR.
apply codeAxmEqHelpIsPR.
apply cPairPi1IsPR.
apply eqIsPR.
apply multIsPR.
Qed.

Definition checkPrfHelp : nat -> nat :=
  evalStrongRec 0
    (fun p recs : nat =>
     let type := cPairPi1 (cPairPi2 p) in
     switchPR type
       (switchPR (pred type)
          (switchPR (pred (pred type))
             (switchPR (pred (pred (pred type)))
                (switchPR (pred (pred (pred (pred type))))
                   (switchPR (pred (pred (pred (pred (pred type)))))
                      (switchPR
                         (pred (pred (pred (pred (pred (pred type))))))
                         (switchPR
                            (pred
                               (pred (pred (pred (pred (pred (pred type)))))))
                            (switchPR
                               (pred
                                  (pred
                                     (pred
                                        (pred
                                           (pred (pred (pred (pred type))))))))
                               (switchPR
                                  (pred
                                     (pred
                                        (pred
                                           (pred
                                              (pred
                                                 (pred
                                                  (pred (pred (pred type)))))))))
                                  (switchPR
                                     (pred
                                        (pred
                                           (pred
                                              (pred
                                                 (pred
                                                  (pred
                                                  (pred
                                                  (pred (pred (pred type))))))))))
                                     (switchPR
                                        (pred
                                           (pred
                                              (pred
                                                 (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred (pred (pred type)))))))))))
                                        (switchPR
                                           (pred
                                              (pred
                                                 (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred (pred (pred type))))))))))))
                                           (switchPR
                                              (pred
                                                 (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred (pred (pred type)))))))))))))
                                              0 (checkPrfEQ5 p recs))
                                           (checkPrfEQ4 p recs))
                                        (checkPrfEQ3 p recs))
                                     (checkPrfEQ2 p recs))
                                  (checkPrfEQ1 p recs)) 
                               (checkPrfFA3 p recs)) 
                            (checkPrfFA2 p recs)) (checkPrfFA1 p recs))
                      (checkPrfCP p recs)) (checkPrfIMP2 p recs))
                (checkPrfIMP1 p recs)) (checkPrfGEN p recs))
          (checkPrfMP p recs)) (checkPrfAXM p recs)).

Lemma checkPrfHelpIsPR : isPR 1 checkPrfHelp.
set
 (f :=
  list_rec (fun _ => nat -> nat -> nat -> nat) (fun _ _ _ : nat => 0)
    (fun (a : nat -> nat -> nat) (l : list (nat -> nat -> nat))
       (rec : nat -> nat -> nat -> nat) (n p recs : nat) =>
     switchPR (iterate pred n (cPairPi1 (cPairPi2 p))) 
       (rec (S n) p recs) (a p recs))) in *.
set
 (l :=
  checkPrfAXM
  :: checkPrfMP
     :: checkPrfGEN
        :: checkPrfIMP1
           :: checkPrfIMP2
              :: checkPrfCP
                 :: checkPrfFA1
                    :: checkPrfFA2
                       :: checkPrfFA3
                          :: checkPrfEQ1
                             :: checkPrfEQ2
                                :: checkPrfEQ3
                                   :: checkPrfEQ4 :: checkPrfEQ5 :: nil) 
 in *.
assert
 (forall (l : list (nat -> nat -> nat)) (n : nat),
  list_rect (fun _ => Set) unit
    (fun (a : nat -> nat -> nat) _ (rec : Set) => (isPR 2 a * rec)%type) l ->
  isPR 2 (f l n)). 
intro.
induction l0 as [| a l0 Hrecl0].
simpl in |- *.
intros.
apply filter10IsPR with (g := fun _ : nat => 0).
apply const1_NIsPR.
simpl in |- *.
intros.
apply
 compose2_3IsPR
  with (f1 := fun p recs : nat => iterate pred n (cPairPi1 (cPairPi2 p))).
apply
 filter10IsPR
  with (g := fun p : nat => iterate pred n (cPairPi1 (cPairPi2 p))).
apply compose1_1IsPR with (f := fun p : nat => cPairPi1 (cPairPi2 p)).
apply compose1_1IsPR.
apply cPairPi2IsPR.
apply cPairPi1IsPR.
apply iterateIsPR.
apply predIsPR.
apply Hrecl0.
eapply snd.
apply H.
eapply fst.
apply H.
apply switchIsPR.
assert (isPR 2 (f l 0)).
apply H.
simpl in |- *.
repeat split.
apply checkPrfAXMIsPR.
apply checkPrfMPIsPR.
apply checkPrfGENIsPR.
apply checkPrfIMP1IsPR.
apply checkPrfIMP2IsPR.
apply checkPrfCPIsPR.
apply checkPrfFA1IsPR.
apply checkPrfFA2IsPR.
apply checkPrfFA3IsPR.
apply checkPrfEQ1IsPR.
apply checkPrfEQ2IsPR.
apply checkPrfEQ3IsPR.
apply checkPrfEQ4IsPR.
apply checkPrfEQ5IsPR.
unfold checkPrfHelp in |- *.
apply evalStrongRecIsPR.
apply H0.
Qed.

Definition checkPrf (f p : nat) : nat :=
  switchPR (wellFormedFormula f) (checkPrfHelp (cPair f p)) 0.

Lemma checkPrfIsPR : isPR 2 checkPrf.
Proof.
unfold checkPrf in |- *.
apply
 compose2_3IsPR
  with
    (f1 := fun f p : nat => wellFormedFormula f)
    (f2 := fun f p : nat => checkPrfHelp (cPair f p))
    (f3 := fun f p : nat => 0).
apply filter10IsPR.
unfold wellFormedFormula in |- *.
apply wellFormedFormulaIsPR.
apply codeArityFIsPR.
apply codeArityRIsPR.
apply compose2_1IsPR.
apply cPairIsPR.
apply checkPrfHelpIsPR.
apply filter10IsPR with (g := fun _ : nat => 0).
apply const1_NIsPR.
apply switchIsPR.
Qed.

Lemma checkPrfCorrect1 :
 forall (l : list Formula) (f : Formula) (p : Prf l f),
 checkPrf (codeFormula L codeF codeR f) (codePrf L codeF codeR l f p) =
 S (codeList (map (codeFormula L codeF codeR) l)).
Proof.
intros.
unfold checkPrf in |- *.
rewrite
 (wellFormedFormulaCorrect1 L codeF codeArityF codeArityFIsCorrect1 codeR
    codeArityR codeArityRIsCorrect1).
simpl in |- *.
lazy beta delta [checkPrfHelp] in |- *.
set
 (A :=
  fun p0 recs : nat =>
  let type := cPairPi1 (cPairPi2 p0) in
  switchPR type
    (switchPR (pred type)
       (switchPR (pred (pred type))
          (switchPR (pred (pred (pred type)))
             (switchPR (pred (pred (pred (pred type))))
                (switchPR (pred (pred (pred (pred (pred type)))))
                   (switchPR (pred (pred (pred (pred (pred (pred type))))))
                      (switchPR
                         (pred (pred (pred (pred (pred (pred (pred type)))))))
                         (switchPR
                            (pred
                               (pred
                                  (pred
                                     (pred (pred (pred (pred (pred type))))))))
                            (switchPR
                               (pred
                                  (pred
                                     (pred
                                        (pred
                                           (pred
                                              (pred (pred (pred (pred type)))))))))
                               (switchPR
                                  (pred
                                     (pred
                                        (pred
                                           (pred
                                              (pred
                                                 (pred
                                                  (pred
                                                  (pred (pred (pred type))))))))))
                                  (switchPR
                                     (pred
                                        (pred
                                           (pred
                                              (pred
                                                 (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred (pred (pred type)))))))))))
                                     (switchPR
                                        (pred
                                           (pred
                                              (pred
                                                 (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred (pred (pred type))))))))))))
                                        (switchPR
                                           (pred
                                              (pred
                                                 (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred (pred (pred type)))))))))))))
                                           0 (checkPrfEQ5 p0 recs))
                                        (checkPrfEQ4 p0 recs))
                                     (checkPrfEQ3 p0 recs))
                                  (checkPrfEQ2 p0 recs))
                               (checkPrfEQ1 p0 recs)) 
                            (checkPrfFA3 p0 recs)) 
                         (checkPrfFA2 p0 recs)) (checkPrfFA1 p0 recs))
                   (checkPrfCP p0 recs)) (checkPrfIMP2 p0 recs))
             (checkPrfIMP1 p0 recs)) (checkPrfGEN p0 recs))
       (checkPrfMP p0 recs)) (checkPrfAXM p0 recs)) 
 in *.
induction p
 as
  [A0|
   Axm1 Axm2 A0 B p1 Hrecp1 p0 Hrecp0|
   Axm A0 v n p Hrecp|
   A0 B|
   A0 B C|
   A0 B|
   A0 v t|
   A0 v n|
   A0 B v|
   |
   |
   |
   R|
   f];
 unfold evalStrongRec, evalComposeFunc, evalOneParamList, evalList in |- *;
 rewrite computeEvalStrongRecHelp;
 unfold compose2, evalComposeFunc, evalOneParamList, evalList in |- *;
 simpl in |- *; rewrite cPairProjections1.
unfold A at 1 in |- *.
repeat first [ rewrite cPairProjections1 | rewrite cPairProjections2 ];
 simpl in |- *.
unfold checkPrfAXM in |- *.
repeat first [ rewrite cPairProjections1 | rewrite cPairProjections2 ];
 simpl in |- *.
rewrite <- beq_nat_refl.
reflexivity.
set
 (C :=
  cPair
    (cPair
       (cPair 1
          (cPair (codeFormula L codeF codeR A0) (codeFormula L codeF codeR B)))
       (codePrf L codeF codeR Axm1 (fol.impH L A0 B) p1))
    (cPair (codeFormula L codeF codeR A0) (codePrf L codeF codeR Axm2 A0 p0)))
 in *.
unfold A at 1 in |- *.
repeat first [ rewrite cPairProjections1 | rewrite cPairProjections2 ].
simpl in |- *.
unfold C at 1 in |- *.
unfold checkPrfMP in |- *.
repeat first [ rewrite cPairProjections1 | rewrite cPairProjections2 ].
simpl in |- *.
repeat rewrite evalStrongRecHelp1.
rewrite <- beq_nat_refl.
rewrite Hrecp0.
replace
 (cPair 1
    (cPair (codeFormula L codeF codeR A0) (codeFormula L codeF codeR B)))
 with (codeFormula L codeF codeR (fol.impH L A0 B)); 
 [ idtac | reflexivity ].
rewrite Hrecp1.
rewrite
 (wellFormedFormulaCorrect1 L codeF codeArityF codeArityFIsCorrect1 codeR
    codeArityR codeArityRIsCorrect1).
simpl in |- *.
replace (map (codeFormula L codeF codeR) (Axm1 ++ Axm2)) with
 (map (codeFormula L codeF codeR) Axm1 ++
  map (codeFormula L codeF codeR) Axm2).
rewrite codeAppCorrect.
reflexivity.
generalize (codeFormula L codeF codeR); intro.
clear p1 A Hrecp1 Hrecp0 C.
induction Axm1 as [| a Axm1 HrecAxm1].
reflexivity.
simpl in |- *.
rewrite HrecAxm1.
reflexivity.
eapply lt_le_trans; [ idtac | apply cPairLe2 ].
eapply le_lt_trans; [ idtac | apply cPairLt2 ].
unfold C in |- *.
apply cPairLe2.
eapply lt_le_trans; [ idtac | apply cPairLe2 ].
eapply le_lt_trans; [ idtac | apply cPairLt2 ].
unfold C in |- *.
apply cPairLe1.
unfold A at 1 in |- *.
repeat first [ rewrite cPairProjections1 | rewrite cPairProjections2 ].
simpl in |- *.
unfold checkPrfGEN in |- *.
repeat first [ rewrite cPairProjections1 | rewrite cPairProjections2 ].
repeat rewrite evalStrongRecHelp1.
rewrite Hrecp.
unfold pred in |- *.
rewrite codeFreeVarListFormulaCorrect.
rewrite codeInCorrect.
induction (In_dec eq_nat_dec v (freeVarListFormula L Axm)).
elim n.
assumption.
replace
 (charFunction 2 beq_nat (cPair 3 (cPair v (codeFormula L codeF codeR A0)))
    (cPair 3 (cPair v (codeFormula L codeF codeR A0)))) with 1.
simpl in |- *.
reflexivity.
simpl in |- *.
rewrite <- beq_nat_refl.
reflexivity.
eapply lt_le_trans; [ idtac | apply cPairLe2 ].
eapply le_lt_trans; [ idtac | apply cPairLt2 ].
apply cPairLe2.
unfold A at 1 in |- *.
repeat first [ rewrite cPairProjections1 | rewrite cPairProjections2 ].
simpl in |- *.
unfold checkPrfIMP1 in |- *.
repeat first [ rewrite cPairProjections1 | rewrite cPairProjections2 ].
unfold charFunction in |- *.
rewrite <- beq_nat_refl.
reflexivity.
unfold A at 1 in |- *.
repeat first [ rewrite cPairProjections1 | rewrite cPairProjections2 ].
simpl in |- *.
unfold checkPrfIMP2 in |- *.
repeat first [ rewrite cPairProjections1 | rewrite cPairProjections2 ].
unfold charFunction in |- *.
rewrite <- beq_nat_refl.
reflexivity.
unfold A at 1 in |- *.
repeat first [ rewrite cPairProjections1 | rewrite cPairProjections2 ].
simpl in |- *.
unfold checkPrfCP in |- *.
repeat first [ rewrite cPairProjections1 | rewrite cPairProjections2 ].
unfold charFunction in |- *.
rewrite <- beq_nat_refl.
reflexivity.
unfold A at 1 in |- *.
repeat first [ rewrite cPairProjections1 | rewrite cPairProjections2 ].
simpl in |- *.
unfold checkPrfFA1 in |- *.
repeat first [ rewrite cPairProjections1 | rewrite cPairProjections2 ].
rewrite codeSubFormulaCorrect.
unfold charFunction in |- *.
rewrite <- beq_nat_refl.
rewrite (wellFormedTermCorrect1 L codeF codeArityF codeArityFIsCorrect1).
reflexivity.
unfold A at 1 in |- *.
repeat first [ rewrite cPairProjections1 | rewrite cPairProjections2 ].
simpl in |- *.
unfold checkPrfFA2 in |- *.
repeat first [ rewrite cPairProjections1 | rewrite cPairProjections2 ].
rewrite codeFreeVarFormulaCorrect.
rewrite codeInCorrect.
induction (In_dec eq_nat_dec v (freeVarFormula L A0)).
elim n.
assumption.
unfold charFunction in |- *.
rewrite <- beq_nat_refl.
reflexivity.
unfold A at 1 in |- *.
repeat first [ rewrite cPairProjections1 | rewrite cPairProjections2 ].
simpl in |- *.
unfold checkPrfFA3 in |- *.
repeat first [ rewrite cPairProjections1 | rewrite cPairProjections2 ].
unfold charFunction in |- *.
rewrite <- beq_nat_refl.
reflexivity.
set
 (C :=
  cPair 0
    (cPair (codeTerm L codeF (fol.var L 0)) (codeTerm L codeF (fol.var L 0))))
 in *.
unfold A at 1 in |- *.

cut (cPairPi1 (cPairPi2 (cPair C (cPair 9 0))) = 9);
 [ intro H; rewrite H; clear H | idtac ].

simpl in |- *.
unfold checkPrfEQ1 in |- *.

rewrite (cPairProjections2 C (cPair 9 0)).
rewrite (cPairProjections1 C (cPair 9 0)).
rewrite (cPairProjections2 9 0).

unfold C in |- *.
unfold charFunction in |- *.
rewrite <- beq_nat_refl.
simpl in |- *.
reflexivity.

rewrite (cPairProjections2 C (cPair 9 0)).
rewrite (cPairProjections1 9 0).

reflexivity.
set
 (C :=
  cPair 1
    (cPair
       (cPair 0
          (cPair (codeTerm L codeF (fol.var L 0))
             (codeTerm L codeF (fol.var L 1))))
       (cPair 0
          (cPair (codeTerm L codeF (fol.var L 1))
             (codeTerm L codeF (fol.var L 0)))))) in *.
unfold A at 1 in |- *.
cut (cPairPi1 (cPairPi2 (cPair C (cPair 10 0))) = 10).
generalize (cPairPi1 (cPairPi2 (cPair C (cPair 10 0)))).
intros.
rewrite H.
simpl in |- *.
unfold checkPrfEQ2 in |- *.
replace
 (codeFormula L codeF codeR
    (fol.impH L (fol.equal L (fol.var L 0) (fol.var L 1))
       (fol.equal L (fol.var L 1) (fol.var L 0)))) with C;
 [ idtac | reflexivity ].
generalize C; intros.

rewrite (cPairProjections2 C0 (cPair 10 0)).
rewrite (cPairProjections2 10 0).
rewrite (cPairProjections1 C0 (cPair 10 0)).

unfold charFunction in |- *.
repeat rewrite <- beq_nat_refl.
reflexivity.

rewrite (cPairProjections2 C (cPair 10 0)).
rewrite (cPairProjections1 10 0).

reflexivity.
set
 (C :=
  cPair 1
    (cPair
       (cPair 0
          (cPair (codeTerm L codeF (fol.var L 0))
             (codeTerm L codeF (fol.var L 1))))
       (cPair 1
          (cPair
             (cPair 0
                (cPair (codeTerm L codeF (fol.var L 1))
                   (codeTerm L codeF (fol.var L 2))))
             (cPair 0
                (cPair (codeTerm L codeF (fol.var L 0))
                   (codeTerm L codeF (fol.var L 2)))))))) 
 in *.
unfold A at 1 in |- *.
cut (cPairPi1 (cPairPi2 (cPair C (cPair 11 0))) = 11).
generalize (cPairPi1 (cPairPi2 (cPair C (cPair 11 0)))).
intros.
rewrite H.
simpl in |- *.
unfold checkPrfEQ3 in |- *.
replace
 (codeFormula L codeF codeR
    (fol.impH L (fol.equal L (fol.var L 0) (fol.var L 1))
       (fol.impH L (fol.equal L (fol.var L 1) (fol.var L 2))
          (fol.equal L (fol.var L 0) (fol.var L 2))))) with C;
 [ idtac | reflexivity ].
generalize C; intros.

rewrite (cPairProjections2 C0 (cPair 11 0)).
rewrite (cPairProjections1 C0 (cPair 11 0)).
rewrite (cPairProjections2 11 0).

unfold charFunction in |- *.
repeat rewrite <- beq_nat_refl.
reflexivity.

rewrite (cPairProjections2 C (cPair 11 0)).
rewrite (cPairProjections1 11 0).

reflexivity.
unfold A at 1 in |- *.
repeat first [ rewrite cPairProjections1 | rewrite cPairProjections2 ].
simpl in |- *.
unfold checkPrfEQ4 in |- *.
repeat first [ rewrite cPairProjections1 | rewrite cPairProjections2 ].
rewrite codeArityRIsCorrect1.
replace
 (codeAxmEqHelp (pred (S (arity L (inl (Functions L) R))))
    (codeIff
       (cPair (S (S (S (S (codeR R)))))
          (codeNVars1 (pred (S (arity L (inl (Functions L) R))))))
       (cPair (S (S (S (S (codeR R)))))
          (codeNVars2 (pred (S (arity L (inl (Functions L) R)))))))) with
 (codeFormula L codeF codeR (AxmEq4 L R)).
unfold charFunction in |- *.
repeat rewrite <- beq_nat_refl.
reflexivity.
unfold AxmEq4 in |- *.
clear A.
simpl in |- *.
induction (codeNVarsCorrect (arity L (inl (Functions L) R))).
rewrite H.
rewrite H0.
clear H H0.
induction (nVars L (arity L (inl (Functions L) R))).
simpl in |- *.
replace
 (codeIff
    (cPair (S (S (S (S (codeR R)))))
       (codeTerms L codeF (arity L (inl (Functions L) R)) a))
    (cPair (S (S (S (S (codeR R)))))
       (codeTerms L codeF (arity L (inl (Functions L) R)) b))) with
 (codeFormula L codeF codeR (iffH L (fol.atomic L R a) (fol.atomic L R b))).
generalize (arity L (inl (Functions L) R)).
intros.
induction n as [| n Hrecn].
reflexivity.
simpl in |- *.
rewrite Hrecn.
reflexivity.
rewrite <- codeIffCorrect.
reflexivity.
unfold A at 1 in |- *.
repeat first [ rewrite cPairProjections1 | rewrite cPairProjections2 ].
simpl in |- *.
unfold checkPrfEQ5 in |- *.
repeat first [ rewrite cPairProjections1 | rewrite cPairProjections2 ].
rewrite codeArityFIsCorrect1.
replace
 (codeAxmEqHelp (pred (S (arity L (inr (Relations L) f))))
    (cPair 0
       (cPair
          (cPair (S (codeF f))
             (codeNVars1 (pred (S (arity L (inr (Relations L) f))))))
          (cPair (S (codeF f))
             (codeNVars2 (pred (S (arity L (inr (Relations L) f))))))))) with
 (codeFormula L codeF codeR (AxmEq5 L f)).
unfold charFunction in |- *.
repeat rewrite <- beq_nat_refl.
reflexivity.
unfold AxmEq5 in |- *.
clear A.
simpl in |- *.
induction (codeNVarsCorrect (arity L (inr (Relations L) f))).
rewrite H.
rewrite H0.
clear H H0.
induction (nVars L (arity L (inr (Relations L) f))).
simpl in |- *.
replace
 (cPair 0
    (cPair
       (cPair (S (codeF f))
          (codeTerms L codeF (arity L (inr (Relations L) f)) a))
       (cPair (S (codeF f))
          (codeTerms L codeF (arity L (inr (Relations L) f)) b)))) with
 (codeFormula L codeF codeR (fol.equal L (fol.apply L f a) (fol.apply L f b))).
generalize (arity L (inr (Relations L) f)).
intros.
induction n as [| n Hrecn].
reflexivity.
simpl in |- *.
rewrite Hrecn.
reflexivity.
reflexivity.
Qed.

Lemma checkPrfCorrect2 :
 forall n m : nat,
 checkPrf n m <> 0 ->
 exists f : Formula,
   codeFormula L codeF codeR f = n /\
   (exists l : list Formula,
      (exists p : Prf l f, codePrf L codeF codeR l f p = m)).
Proof.
assert (multLemma1 : forall a b : nat, a * b <> 0 -> a <> 0).
unfold not in |- *; intros.
apply H.
rewrite H0.
simpl in |- *.
reflexivity.
assert (multLemma2 : forall a b : nat, a * b <> 0 -> b <> 0).
intros.
rewrite mult_comm in H.
eapply multLemma1.
apply H.
assert
 (forall m n : nat,
  n < m ->
  checkPrf (cPairPi1 n) (cPairPi2 n) <> 0 ->
  exists f : Formula,
    (exists l : list Formula,
       (exists p : Prf l f,
          cPair (codeFormula L codeF codeR f) (codePrf L codeF codeR l f p) =
          n))).
intro.
induction m as [| m Hrecm].
intros.
elim (lt_n_O _ H).
intros.
induction (le_lt_or_eq _ _ (lt_n_Sm_le _ _ H)).
apply Hrecm; assumption.
unfold checkPrf in H0.
assert (wellFormedFormula (cPairPi1 n) <> 0).
destruct (wellFormedFormula (cPairPi1 n)).
assumption.
discriminate.
induction
 (wellFormedFormulaCorrect2 L codeF codeArityF codeArityFIsCorrect1
    codeArityFIsCorrect2 codeR codeArityR codeArityRIsCorrect1
    codeArityRIsCorrect2 _ H2).
exists x.
destruct (wellFormedFormula (cPairPi1 n)).
elim H2.
auto.
simpl in H0.
clear H2.
unfold checkPrfHelp in H0.
set
 (A :=
  fun p recs : nat =>
  switchPR (cPairPi1 (cPairPi2 p))
    (switchPR (pred (cPairPi1 (cPairPi2 p)))
       (switchPR (pred (pred (cPairPi1 (cPairPi2 p))))
          (switchPR (pred (pred (pred (cPairPi1 (cPairPi2 p)))))
             (switchPR (pred (pred (pred (pred (cPairPi1 (cPairPi2 p))))))
                (switchPR
                   (pred (pred (pred (pred (pred (cPairPi1 (cPairPi2 p)))))))
                   (switchPR
                      (pred
                         (pred
                            (pred
                               (pred (pred (pred (cPairPi1 (cPairPi2 p))))))))
                      (switchPR
                         (pred
                            (pred
                               (pred
                                  (pred
                                     (pred
                                        (pred (pred (cPairPi1 (cPairPi2 p)))))))))
                         (switchPR
                            (pred
                               (pred
                                  (pred
                                     (pred
                                        (pred
                                           (pred
                                              (pred
                                                 (pred
                                                  (cPairPi1 (cPairPi2 p))))))))))
                            (switchPR
                               (pred
                                  (pred
                                     (pred
                                        (pred
                                           (pred
                                              (pred
                                                 (pred
                                                  (pred
                                                  (pred
                                                  (cPairPi1 (cPairPi2 p)))))))))))
                               (switchPR
                                  (pred
                                     (pred
                                        (pred
                                           (pred
                                              (pred
                                                 (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (cPairPi1 (cPairPi2 p))))))))))))
                                  (switchPR
                                     (pred
                                        (pred
                                           (pred
                                              (pred
                                                 (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (cPairPi1 (cPairPi2 p)))))))))))))
                                     (switchPR
                                        (pred
                                           (pred
                                              (pred
                                                 (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (cPairPi1 (cPairPi2 p))))))))))))))
                                        (switchPR
                                           (pred
                                              (pred
                                                 (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (cPairPi1 (cPairPi2 p)))))))))))))))
                                           0 (checkPrfEQ5 p recs))
                                        (checkPrfEQ4 p recs))
                                     (checkPrfEQ3 p recs))
                                  (checkPrfEQ2 p recs)) 
                               (checkPrfEQ1 p recs)) 
                            (checkPrfFA3 p recs)) (checkPrfFA2 p recs))
                      (checkPrfFA1 p recs)) (checkPrfCP p recs))
                (checkPrfIMP2 p recs)) (checkPrfIMP1 p recs))
          (checkPrfGEN p recs)) (checkPrfMP p recs)) 
    (checkPrfAXM p recs)) in *.
unfold evalStrongRec, evalComposeFunc, evalOneParamList, evalList in H0;
 rewrite computeEvalStrongRecHelp in H0;
 unfold compose2, evalComposeFunc, evalOneParamList, evalList in H0;
 simpl in H0.
rewrite cPairProjections1 in H0.
assert (cPair (cPairPi1 (cPairPi2 n)) (cPairPi2 (cPairPi2 n)) = cPairPi2 n).
apply cPairProjections.
unfold A at 1 in H0.
repeat first
 [ rewrite cPairProjections1 in H0 | rewrite cPairProjections2 in H0 ].
destruct (cPairPi1 (cPairPi2 n)).
simpl in H0.
unfold checkPrfAXM in H0.
repeat first
 [ rewrite cPairProjections1 in H0 | rewrite cPairProjections2 in H0 ].
rewrite <- H3 in H0.
induction (eq_nat_dec (cPairPi2 (cPairPi2 n)) (codeFormula L codeF codeR x)).
exists (x :: nil).
exists (AXM L x).
rewrite H3.
simpl in |- *.
rewrite a in H2.
rewrite H2.
apply cPairProjections.
elim H0.
unfold charFunction in |- *.
rewrite beq_nat_not_refl.
reflexivity.
assumption.
destruct n1.
simpl in H0.
unfold checkPrfMP in H0.
repeat first
 [ rewrite cPairProjections1 in H0 | rewrite cPairProjections2 in H0 ].
assert (cPairPi2 (cPairPi2 n) < n).
apply lt_le_trans with (cPair 1 (cPairPi2 (cPairPi2 n)));
 [ idtac | rewrite H2; apply cPairLe2A ].
apply cPairLt2.
assert (cPairPi1 (cPairPi2 (cPairPi2 n)) < n).
apply le_lt_trans with (cPairPi2 (cPairPi2 n)).
apply cPairLe1A.
assumption.
assert (cPairPi2 (cPairPi2 (cPairPi2 n)) < n).
apply le_lt_trans with (cPairPi2 (cPairPi2 n)).
apply cPairLe2A.
assumption.
rewrite evalStrongRecHelp1 in H0.
rewrite evalStrongRecHelp1 in H0.
assert (wellFormedFormula (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 n)))) <> 0).
unfold not in |- *; intros.
apply H0.
rewrite H7.
reflexivity.
induction
 (eq_nat_dec (cPairPi1 (cPairPi1 (cPairPi2 (cPairPi2 n))))
    (codeImp (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 n)))) (cPairPi1 n))).
induction
 (wellFormedFormulaCorrect2 L codeF codeArityF codeArityFIsCorrect1
    codeArityFIsCorrect2 codeR codeArityR codeArityRIsCorrect1
    codeArityRIsCorrect2 _ H7).
assert
 (checkPrf (cPairPi1 (cPairPi1 (cPairPi2 (cPairPi2 n))))
    (cPairPi2 (cPairPi1 (cPairPi2 (cPairPi2 n)))) <> 0).
unfold checkPrf in |- *.
rewrite a.
rewrite <- H3.
rewrite <- H8.
rewrite codeImpCorrect.
rewrite
 (wellFormedFormulaCorrect1 L codeF codeArityF codeArityFIsCorrect1 codeR
    codeArityR codeArityRIsCorrect1).
simpl in |- *.
unfold checkPrfHelp in |- *.
fold A in |- *.
rewrite H8.
rewrite H3.
replace
 (cPair 1 (cPair (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 n)))) (cPairPi1 n)))
 with (cPairPi1 (cPairPi1 (cPairPi2 (cPairPi2 n)))).
rewrite cPairProjections.
destruct (evalStrongRec 0 A (cPairPi1 (cPairPi2 (cPairPi2 n)))).
rewrite mult_comm in H0.
rewrite
 (mult_comm
    (charFunction 2 beq_nat (cPairPi1 (cPairPi1 (cPairPi2 (cPairPi2 n))))
       (codeImp (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 n)))) (cPairPi1 n))))
  in H0.
simpl in H0.
assumption.
discriminate.
assert
 (checkPrf (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 n))))
    (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 n)))) <> 0).
unfold checkPrf in |- *.
rewrite <- H8.
rewrite
 (wellFormedFormulaCorrect1 L codeF codeArityF codeArityFIsCorrect1 codeR
    codeArityR codeArityRIsCorrect1).
simpl in |- *.
unfold checkPrfHelp in |- *.
fold A in |- *.
rewrite H8.
rewrite cPairProjections.
destruct (evalStrongRec 0 A (cPairPi2 (cPairPi2 (cPairPi2 n)))).
rewrite mult_comm in H0.
rewrite
 (mult_comm
    (charFunction 2 beq_nat (cPairPi1 (cPairPi1 (cPairPi2 (cPairPi2 n))))
       (codeImp (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 n)))) (cPairPi1 n))))
  in H0.
rewrite (mult_comm (evalStrongRec 0 A (cPairPi1 (cPairPi2 (cPairPi2 n)))))
  in H0.
simpl in H0.
assumption.
discriminate.
assert (cPairPi1 (cPairPi2 (cPairPi2 n)) < m).
apply lt_le_trans with n.
assumption.
rewrite H1.
apply le_n.
assert (cPairPi2 (cPairPi2 (cPairPi2 n)) < m).
apply lt_le_trans with n.
assumption.
rewrite H1.
apply le_n.
induction (Hrecm _ H11 H9).
induction (Hrecm _ H12 H10).
induction H13 as (x3, H13).
induction H13 as (x4, H13).
induction H14 as (x5, H14).
induction H14 as (x6, H14).
exists (x3 ++ x5).
rewrite <- H13 in a.
rewrite <- H14 in a.
repeat rewrite cPairProjections1 in a.
rewrite <- H3 in a.
rewrite codeImpCorrect in a.
assert (x1 = impH x2 x).
apply (codeFormulaInj L codeF codeR codeFInj codeRInj).
assumption.
intros.
cut
 (cPair (codeFormula L codeF codeR x1) (codePrf L codeF codeR x3 x1 x4) =
  cPairPi1 (cPairPi2 (cPairPi2 n))).
generalize x4.
clear H13 x4.
rewrite H15.
intros.
exists (MP L x3 x5 x2 x x4 x6).
rewrite <- (cPairProjections n).
rewrite H3.
simpl in |- *.
rewrite <- H2.
replace
 (cPair 1
    (cPair (codeFormula L codeF codeR x2) (codeFormula L codeF codeR x)))
 with (codeFormula L codeF codeR x1).
rewrite H14.
fold impH in |- *.
rewrite H15.
rewrite H13.
rewrite cPairProjections.
reflexivity.
assumption.
unfold charFunction in H0.
rewrite beq_nat_not_refl in H0.
rewrite mult_comm in H0.
simpl in H0.
elim H0.
reflexivity.
assumption.
rewrite cPairProjections.
assumption.
rewrite cPairProjections.
assumption.
destruct n1.
simpl in H0.
unfold checkPrfGEN in H0.
repeat first
 [ rewrite cPairProjections1 in H0 | rewrite cPairProjections2 in H0 ].
assert (cPairPi2 (cPairPi2 (cPairPi2 n)) < n).
eapply le_lt_trans.
apply cPairLe2A.
apply lt_le_trans with (cPair 2 (cPairPi2 (cPairPi2 n)));
 [ idtac | rewrite H2; apply cPairLe2A ].
apply cPairLt2.
rewrite evalStrongRecHelp1 in H0.
induction
 (eq_nat_dec
    (cPair 3
       (cPair (cPairPi1 (cPairPi2 (cPairPi2 n)))
          (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 n)))))) 
    (cPairPi1 n)).
rewrite <- a in H3.
destruct x as [t t0| r t| f f0| f| n1 f]; simpl in H3;
 try
  match goal with
  | H:(cPair ?X1 _ = cPair ?X2 _) |- _ =>
      cut (X1 = X2); [ intro I; discriminate I | eapply cPairInj1; apply H ]
  end.
assert (n1 = cPairPi1 (cPairPi2 (cPairPi2 n))).
eapply cPairInj1.
eapply cPairInj2.
apply H3.
assert
 (codeFormula L codeF codeR f = cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 n)))).
eapply cPairInj2.
eapply cPairInj2.
apply H3.
assert
 (checkPrf (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 n))))
    (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 n)))) <> 0).
unfold checkPrf in |- *.
rewrite <- H6.
rewrite
 (wellFormedFormulaCorrect1 L codeF codeArityF codeArityFIsCorrect1 codeR
    codeArityR codeArityRIsCorrect1).
simpl in |- *.
unfold checkPrfHelp in |- *.
fold A in |- *.
rewrite H6.
rewrite cPairProjections.
destruct (evalStrongRec 0 A (cPairPi2 (cPairPi2 (cPairPi2 n)))).
rewrite mult_comm in H0.
simpl in H0.
assumption.
discriminate.
assert (cPairPi2 (cPairPi2 (cPairPi2 n)) < m).
apply lt_le_trans with n.
assumption.
rewrite H1.
apply le_n.
induction (Hrecm _ H8 H7).
induction H9 as (x0, H9).
induction H9 as (x1, H9).
exists x0.
rewrite <- H5 in H0.
rewrite <- H9 in H0.
assert
 (checkPrf (codeFormula L codeF codeR x) (codePrf L codeF codeR x0 x x1) =
  S (codeList (map (codeFormula L codeF codeR) x0))).
apply checkPrfCorrect1.
unfold checkPrf in H10.
rewrite
 (wellFormedFormulaCorrect1 L codeF codeArityF codeArityFIsCorrect1 codeR
    codeArityR codeArityRIsCorrect1) in H10.
simpl in H10.
unfold checkPrfHelp in H10.
fold A in H10.
rewrite H10 in H0.
unfold pred in H0.
rewrite codeFreeVarListFormulaCorrect in H0.
rewrite codeInCorrect in H0.
induction (In_dec eq_nat_dec n1 (freeVarListFormula L x0)).
rewrite (mult_comm (S (codeList (map (codeFormula L codeF codeR) x0)))) in H0.
rewrite mult_comm in H0.
simpl in H0.
elim H0; reflexivity.
rewrite <- H9 in H6.
rewrite cPairProjections1 in H6.
cut
 (cPair (codeFormula L codeF codeR x) (codePrf L codeF codeR x0 x x1) =
  cPairPi2 (cPairPi2 (cPairPi2 n))).
generalize x1.
clear H10 H0 x1 H9.
replace x with f.
intros.
exists (GEN L x0 f n1 b x1).
simpl in |- *.
rewrite H3.
rewrite a.
rewrite H0.
rewrite H5.
rewrite cPairProjections.
rewrite H2.
apply cPairProjections.
apply (codeFormulaInj L codeF codeR codeFInj codeRInj).
assumption.
assumption.
unfold charFunction in H0.
rewrite beq_nat_not_refl in H0.
elim H0.
simpl in |- *.
reflexivity.
assumption.
rewrite cPairProjections.
assumption.
destruct n1.
simpl in H0.
unfold checkPrfIMP1 in H0.
repeat first
 [ rewrite cPairProjections1 in H0 | rewrite cPairProjections2 in H0 ].
exists (nil (A:=Formula)).
rewrite <- H3 in H0.
induction
 (eq_nat_dec
    (cPair 1
       (cPair (cPairPi1 (cPairPi2 (cPairPi2 n)))
          (cPair 1
             (cPair (cPairPi2 (cPairPi2 (cPairPi2 n)))
                (cPairPi1 (cPairPi2 (cPairPi2 n)))))))
    (codeFormula L codeF codeR x)).
destruct x as [t t0| r t| f f0| f| n1 f]; simpl in a;
 try
  match goal with
  | H:(cPair ?X1 _ = cPair ?X2 _) |- _ =>
      cut (X1 = X2); [ intro I; discriminate I | eapply cPairInj1; apply H ]
  end.
assert (cPairPi1 (cPairPi2 (cPairPi2 n)) = codeFormula L codeF codeR f).
eapply cPairInj1.
eapply cPairInj2.
apply a.
assert
 (cPair 1
    (cPair (cPairPi2 (cPairPi2 (cPairPi2 n)))
       (cPairPi1 (cPairPi2 (cPairPi2 n)))) = codeFormula L codeF codeR f0).
eapply cPairInj2.
eapply cPairInj2.
apply a.
clear a.
destruct f0 as [t t0| r t| f0 f1| f0| n1 f0]; simpl in H5;
 try
  match goal with
  | H:(cPair ?X1 _ = cPair ?X2 _) |- _ =>
      cut (X1 = X2); [ intro I; discriminate I | eapply cPairInj1; apply H ]
  end.
assert (cPairPi2 (cPairPi2 (cPairPi2 n)) = codeFormula L codeF codeR f0).
eapply cPairInj1.
eapply cPairInj2.
apply H5.
assert (cPairPi1 (cPairPi2 (cPairPi2 n)) = codeFormula L codeF codeR f1).
eapply cPairInj2.
eapply cPairInj2.
apply H5.
assert (f1 = f).
apply (codeFormulaInj L codeF codeR codeFInj codeRInj).
transitivity (cPairPi1 (cPairPi2 (cPairPi2 n))).
symmetry  in |- *.
assumption.
assumption.
rewrite H8.
rewrite H8 in H3.
exists (IMP1 L f f0).
rewrite H3.
simpl in |- *.
rewrite <- H4.
rewrite <- H6.
rewrite cPairProjections.
rewrite H2.
apply cPairProjections.
elim H0.
unfold charFunction in |- *.
rewrite beq_nat_not_refl.
reflexivity.
assumption.
destruct n1.
simpl in H0.
unfold checkPrfIMP2 in H0.
repeat first
 [ rewrite cPairProjections1 in H0 | rewrite cPairProjections2 in H0 ].
exists (nil (A:=Formula)).
clear A.
rewrite <- H3 in H0.
rename x into f.
induction
 (eq_nat_dec
    (cPair 1
       (cPair
          (cPair 1
             (cPair (cPairPi1 (cPairPi2 (cPairPi2 n)))
                (cPair 1
                   (cPair (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 n))))
                      (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 n))))))))
          (cPair 1
             (cPair
                (cPair 1
                   (cPair (cPairPi1 (cPairPi2 (cPairPi2 n)))
                      (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 n))))))
                (cPair 1
                   (cPair (cPairPi1 (cPairPi2 (cPairPi2 n)))
                      (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 n))))))))))
    (codeFormula L codeF codeR f)).
repeat
 match goal with
 | H:(cPair ?X1 (cPair ?X2 ?X3) = cPair ?X1 (cPair ?X4 ?X5)) |- _ =>
     assert (X2 = X4);
      [ eapply cPairInj1; eapply cPairInj2; apply H
      | assert (X3 = X5);
         [ eapply cPairInj2; eapply cPairInj2; apply H | clear H ] ]
 | H:(cPair ?X1 (cPair _ _) = codeFormula L codeF codeR ?X2) |- _ =>
      destruct X2;
      simpl in H;
      try
       match goal with
       | J:(cPair ?X1 _ = cPair ?X2 _) |- _ =>
           cut (X1 = X2);
            [ intro I; discriminate I | eapply cPairInj1; apply J ]
       end
 end.
rewrite H3.
replace f2_2_1 with f1_1.
replace f1_2_2 with f2_2_2.
replace f1_2_1 with f2_1_2.
replace f2_1_1 with f1_1.
exists (IMP2 L f1_1 f2_1_2 f2_2_2).
simpl in |- *.
rewrite <- H9.
rewrite <- H8.
rewrite cPairProjections.
rewrite <- H6.
rewrite cPairProjections.
rewrite H2.
apply cPairProjections.
apply (codeFormulaInj L codeF codeR codeFInj codeRInj).
transitivity (cPairPi1 (cPairPi2 (cPairPi2 n)));
 [ symmetry  in |- *; assumption | assumption ].
apply (codeFormulaInj L codeF codeR codeFInj codeRInj).
transitivity (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 n))));
 [ symmetry  in |- *; assumption | assumption ].
apply (codeFormulaInj L codeF codeR codeFInj codeRInj).
transitivity (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 n))));
 [ symmetry  in |- *; assumption | assumption ].
apply (codeFormulaInj L codeF codeR codeFInj codeRInj).
transitivity (cPairPi1 (cPairPi2 (cPairPi2 n)));
 [ symmetry  in |- *; assumption | assumption ].
elim H0.
unfold charFunction in |- *.
rewrite beq_nat_not_refl.
reflexivity.
assumption.
destruct n1.
simpl in H0.
unfold checkPrfCP in H0.
clear A.
repeat first
 [ rewrite cPairProjections1 in H0 | rewrite cPairProjections2 in H0 ].
exists (nil (A:=Formula)).
rewrite <- H3 in H0.
rename x into f.
induction
 (eq_nat_dec
    (cPair 1
       (cPair
          (cPair 1
             (cPair (cPair 2 (cPairPi1 (cPairPi2 (cPairPi2 n))))
                (cPair 2 (cPairPi2 (cPairPi2 (cPairPi2 n))))))
          (cPair 1
             (cPair (cPairPi2 (cPairPi2 (cPairPi2 n)))
                (cPairPi1 (cPairPi2 (cPairPi2 n)))))))
    (codeFormula L codeF codeR f)).
repeat
 match goal with
 | H:(cPair 1 (cPair ?X2 ?X3) = cPair 1 (cPair ?X4 ?X5)) |- _ =>
     assert (X2 = X4);
      [ eapply cPairInj1; eapply cPairInj2; apply H
      | assert (X3 = X5);
         [ eapply cPairInj2; eapply cPairInj2; apply H | clear H ] ]
 | H:(cPair 2 ?X2 = cPair 2 ?X4) |- _ =>
     assert (X2 = X4); [ eapply cPairInj2; apply H | clear H ]
 | H:(cPair ?X1 _ = codeFormula L codeF codeR ?X2) |- _ =>
      destruct X2;
      simpl in H;
      try
       match goal with
       | J:(cPair ?X1 _ = cPair ?X2 _) |- _ =>
           cut (X1 = X2);
            [ intro I; discriminate I | eapply cPairInj1; apply J ]
       end
 end.
rewrite H3.
replace f2_2 with f1_1.
replace f1_2 with f2_1.
exists (CP L f1_1 f2_1).
simpl in |- *.
rewrite <- H8.
rewrite <- H6.
rewrite cPairProjections.
rewrite H2.
apply cPairProjections.
apply (codeFormulaInj L codeF codeR codeFInj codeRInj).
transitivity (cPairPi2 (cPairPi2 (cPairPi2 n)));
 [ symmetry  in |- *; assumption | assumption ].
apply (codeFormulaInj L codeF codeR codeFInj codeRInj).
transitivity (cPairPi1 (cPairPi2 (cPairPi2 n)));
 [ symmetry  in |- *; assumption | assumption ].
elim H0.
unfold charFunction in |- *.
rewrite beq_nat_not_refl.
reflexivity.
assumption.
destruct n1.
simpl in H0.
unfold checkPrfFA1 in H0.
clear A.
repeat first
 [ rewrite cPairProjections1 in H0 | rewrite cPairProjections2 in H0 ].
exists (nil (A:=Formula)).
rewrite <- H3 in H0.
rename x into f.
induction
 (eq_nat_dec
    (cPair 1
       (cPair
          (cPair 3
             (cPair (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 n))))
                (cPairPi1 (cPairPi2 (cPairPi2 n)))))
          (codeSubFormula (cPairPi1 (cPairPi2 (cPairPi2 n)))
             (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 n))))
             (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 n)))))))
    (codeFormula L codeF codeR f)).
repeat
 match goal with
 | H:(cPair 1 (cPair ?X2 ?X3) = cPair 1 (cPair ?X4 ?X5)) |- _ =>
     assert (X2 = X4);
      [ eapply cPairInj1; eapply cPairInj2; apply H
      | assert (X3 = X5);
         [ eapply cPairInj2; eapply cPairInj2; apply H | clear H ] ]
 | H:(cPair 3 (cPair ?X2 ?X3) = cPair 3 (cPair ?X4 ?X5)) |- _ =>
     assert (X2 = X4);
      [ eapply cPairInj1; eapply cPairInj2; apply H
      | assert (X3 = X5);
         [ eapply cPairInj2; eapply cPairInj2; apply H | clear H ] ]
 | H:(cPair ?X1 _ = codeFormula L codeF codeR ?X2) |- _ =>
      destruct X2;
      simpl in H;
      try
       match goal with
       | J:(cPair ?X1 _ = cPair ?X2 _) |- _ =>
           cut (X1 = X2);
            [ intro I; discriminate I | eapply cPairInj1; apply J ]
       end
 end.
rewrite H3.
rewrite H6 in H5.
rewrite H7 in H5.
assert (wellFormedTerm (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 n)))) <> 0).
eapply multLemma1.
apply H0.
induction
 (wellFormedTermCorrect2 L codeF codeArityF codeArityFIsCorrect1
    codeArityFIsCorrect2 _ H4).
rewrite <- H8 in H5.
rewrite codeSubFormulaCorrect in H5.
replace f2 with (substituteFormula L f1 n1 x).
exists (FA1 L f1 n1 x).
simpl in |- *.
rewrite <- H7.
rewrite <- H6.
rewrite H8.
repeat rewrite cPairProjections.
rewrite H2.
apply cPairProjections.
apply (codeFormulaInj L codeF codeR codeFInj codeRInj).
assumption.
elim H0.
unfold charFunction in |- *.
rewrite beq_nat_not_refl.
rewrite mult_comm.
reflexivity.
assumption.
destruct n1.
simpl in H0.
unfold checkPrfFA2 in H0.
clear A.
repeat first
 [ rewrite cPairProjections1 in H0 | rewrite cPairProjections2 in H0 ].
exists (nil (A:=Formula)).
rewrite <- H3 in H0.
rename x into f.
induction
 (eq_nat_dec
    (cPair 1
       (cPair (cPairPi1 (cPairPi2 (cPairPi2 n)))
          (cPair 3
             (cPair (cPairPi2 (cPairPi2 (cPairPi2 n)))
                (cPairPi1 (cPairPi2 (cPairPi2 n)))))))
    (codeFormula L codeF codeR f)).
repeat
 match goal with
 | H:(cPair 1 (cPair ?X2 ?X3) = cPair 1 (cPair ?X4 ?X5)) |- _ =>
     assert (X2 = X4);
      [ eapply cPairInj1; eapply cPairInj2; apply H
      | assert (X3 = X5);
         [ eapply cPairInj2; eapply cPairInj2; apply H | clear H ] ]
 | H:(cPair 3 (cPair ?X2 ?X3) = cPair 3 (cPair ?X4 ?X5)) |- _ =>
     assert (X2 = X4);
      [ eapply cPairInj1; eapply cPairInj2; apply H
      | assert (X3 = X5);
         [ eapply cPairInj2; eapply cPairInj2; apply H | clear H ] ]
 | H:(cPair ?X1 _ = codeFormula L codeF codeR ?X2) |- _ =>
      destruct X2;
      simpl in H;
      try
       match goal with
       | J:(cPair ?X1 _ = cPair ?X2 _) |- _ =>
           cut (X1 = X2);
            [ intro I; discriminate I | eapply cPairInj1; apply J ]
       end
 end.
rewrite H3.
replace f2 with f1.
rewrite H6 in H0.
rewrite H4 in H0.
rewrite codeFreeVarFormulaCorrect in H0.
rewrite codeInCorrect in H0.
induction (In_dec eq_nat_dec n1 (freeVarFormula L f1)).
elim H0.
reflexivity.
exists (FA2 L f1 n1 b).
simpl in |- *.
rewrite <- H4.
rewrite <- H6.
rewrite cPairProjections.
rewrite H2.
apply cPairProjections.
apply (codeFormulaInj L codeF codeR codeFInj codeRInj).
transitivity (cPairPi1 (cPairPi2 (cPairPi2 n)));
 [ symmetry  in |- *; assumption | assumption ].
elim H0.
unfold charFunction in |- *.
rewrite beq_nat_not_refl.
rewrite mult_comm.
reflexivity.
assumption.
destruct n1.
simpl in H0.
unfold checkPrfFA3 in H0.
clear A.
repeat first
 [ rewrite cPairProjections1 in H0 | rewrite cPairProjections2 in H0 ].
exists (nil (A:=Formula)).
rewrite <- H3 in H0.
rename x into f.
induction
 (eq_nat_dec
    (cPair 1
       (cPair
          (cPair 3
             (cPair (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 n))))
                (cPair 1
                   (cPair (cPairPi1 (cPairPi2 (cPairPi2 n)))
                      (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 n))))))))
          (cPair 1
             (cPair
                (cPair 3
                   (cPair (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 n))))
                      (cPairPi1 (cPairPi2 (cPairPi2 n)))))
                (cPair 3
                   (cPair (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 n))))
                      (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 n))))))))))
    (codeFormula L codeF codeR f)).
repeat
 match goal with
 | H:(cPair 1 (cPair ?X2 ?X3) = cPair 1 (cPair ?X4 ?X5)) |- _ =>
     assert (X2 = X4);
      [ eapply cPairInj1; eapply cPairInj2; apply H
      | assert (X3 = X5);
         [ eapply cPairInj2; eapply cPairInj2; apply H | clear H ] ]
 | H:(cPair 3 (cPair ?X2 ?X3) = cPair 3 (cPair ?X4 ?X5)) |- _ =>
     assert (X2 = X4);
      [ eapply cPairInj1; eapply cPairInj2; apply H
      | assert (X3 = X5);
         [ eapply cPairInj2; eapply cPairInj2; apply H | clear H ] ]
 | H:(cPair ?X1 _ = codeFormula L codeF codeR ?X2) |- _ =>
      destruct X2;
      simpl in H;
      try
       match goal with
       | J:(cPair ?X1 _ = cPair ?X2 _) |- _ =>
           cut (X1 = X2);
            [ intro I; discriminate I | eapply cPairInj1; apply J ]
       end
 end.
rewrite H3.
replace f2_1 with f1_1.
replace f1_2 with f2_2.
replace n3 with n1.
replace n2 with n1.
exists (FA3 L f1_1 f2_2 n1).
simpl in |- *.
rewrite <- H4.
rewrite <- H8.
rewrite <- H5.
repeat rewrite cPairProjections.
rewrite H2.
apply cPairProjections.
transitivity (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 n))));
 [ symmetry  in |- *; assumption | assumption ].
transitivity (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 n))));
 [ symmetry  in |- *; assumption | assumption ].
apply (codeFormulaInj L codeF codeR codeFInj codeRInj).
transitivity (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 n))));
 [ symmetry  in |- *; assumption | assumption ].
apply (codeFormulaInj L codeF codeR codeFInj codeRInj).
transitivity (cPairPi1 (cPairPi2 (cPairPi2 n)));
 [ symmetry  in |- *; assumption | assumption ].
elim H0.
unfold charFunction in |- *.
rewrite beq_nat_not_refl.
reflexivity.
assumption.
destruct n1.
simpl in H0.
unfold checkPrfEQ1 in H0.
clear A.
exists (nil (A:=Formula)).
rewrite <- H3 in H0.
induction
 (eq_nat_dec
    (codeFormula L codeF codeR (fol.equal L (fol.var L 0) (fol.var L 0)))
    (codeFormula L codeF codeR x)).
rewrite H3.
replace x with (fol.equal L (fol.var L 0) (fol.var L 0)).
exists (EQ1 L).
simpl in |- *.
induction (eq_nat_dec (cPairPi2 (cPairPi2 n)) 0).
rewrite a0 in H2.
rewrite H2.
apply cPairProjections.
elim H0.
unfold charFunction in |- *.
rewrite beq_nat_not_refl.
reflexivity.
rewrite cPairProjections2.
assumption.
apply (codeFormulaInj L codeF codeR codeFInj codeRInj).
assumption.
elim H0.
unfold charFunction in |- *.
rewrite
 (beq_nat_not_refl
    (codeFormula L codeF codeR (fol.equal L (fol.var L 0) (fol.var L 0))))
 .
rewrite mult_comm.
reflexivity.
rewrite cPairProjections1.
assumption.
destruct n1.
simpl in H0.
unfold checkPrfEQ2 in H0.
clear A.
exists (nil (A:=Formula)).
rewrite <- H3 in H0.
induction
 (eq_nat_dec
    (codeFormula L codeF codeR
       (fol.impH L (fol.equal L (fol.var L 0) (fol.var L 1))
          (fol.equal L (fol.var L 1) (fol.var L 0))))
    (codeFormula L codeF codeR x)).
rewrite H3.
replace x with
 (fol.impH L (fol.equal L (fol.var L 0) (fol.var L 1))
    (fol.equal L (fol.var L 1) (fol.var L 0))).
exists (EQ2 L).
simpl in |- *.
induction (eq_nat_dec (cPairPi2 (cPairPi2 n)) 0).
rewrite a0 in H2.
rewrite H2.
apply cPairProjections.
elim H0.
unfold charFunction in |- *.
rewrite beq_nat_not_refl.
reflexivity.
rewrite cPairProjections2.
assumption.
apply (codeFormulaInj L codeF codeR codeFInj codeRInj).
assumption.
elim H0.
unfold charFunction in |- *.
rewrite
 (beq_nat_not_refl
    (codeFormula L codeF codeR
       (fol.impH L (fol.equal L (fol.var L 0) (fol.var L 1))
          (fol.equal L (fol.var L 1) (fol.var L 0)))))
 .
rewrite mult_comm.
reflexivity.
rewrite cPairProjections1.
assumption.

repeat rewrite <- pred_Sn in H0.
assert (H4 : forall n2 p q : nat, switchPR (S n2) p q = p).
simple destruct n2; trivial.
repeat rewrite H4 in H0.
clear H4.

destruct n1.
simpl in H0.
unfold checkPrfEQ3 in H0.
clear A.
exists (nil (A:=Formula)).
rewrite <- H3 in H0.
induction
 (eq_nat_dec
    (codeFormula L codeF codeR
       (fol.impH L (fol.equal L (fol.var L 0) (fol.var L 1))
          (fol.impH L (fol.equal L (fol.var L 1) (fol.var L 2))
             (fol.equal L (fol.var L 0) (fol.var L 2)))))
    (codeFormula L codeF codeR x)).
rewrite H3.
replace x with
 (fol.impH L (fol.equal L (fol.var L 0) (fol.var L 1))
    (fol.impH L (fol.equal L (fol.var L 1) (fol.var L 2))
       (fol.equal L (fol.var L 0) (fol.var L 2)))).
exists (EQ3 L).
simpl in |- *.
rewrite cPairProjections2 in H0.
rewrite cPairProjections1 in H0.
induction (eq_nat_dec (cPairPi2 (cPairPi2 n)) 0).
rewrite a0 in H2.
rewrite H2.
apply cPairProjections.
elim H0.
unfold charFunction in |- *.
rewrite beq_nat_not_refl.
reflexivity.
assumption.
apply (codeFormulaInj L codeF codeR codeFInj codeRInj).
assumption.
elim H0.
unfold charFunction in |- *.
rewrite
 (beq_nat_not_refl
    (codeFormula L codeF codeR
       (fol.impH L (fol.equal L (fol.var L 0) (fol.var L 1))
          (fol.impH L (fol.equal L (fol.var L 1) (fol.var L 2))
             (fol.equal L (fol.var L 0) (fol.var L 2))))))
 .
rewrite mult_comm.
reflexivity.
rewrite cPairProjections1.
assumption.
destruct n1.
simpl in H0.
unfold checkPrfEQ4 in H0.
clear A.
repeat rewrite cPairProjections2 in H0.
repeat rewrite cPairProjections1 in H0.
exists (nil (A:=Formula)).
rewrite <- H3 in H0.
assert (codeArityR (cPairPi2 (cPairPi2 n)) <> 0).
unfold notZero in H0.
unfold not in |- *; intros.
rewrite H4 in H0.
apply H0.
reflexivity.
induction (codeArityRIsCorrect2 _ H4).
rewrite <- H5 in H0.
rewrite codeArityRIsCorrect1 in H0.
simpl in H0.
induction (codeNVarsCorrect (arity L (inl (Functions L) x0))).
rewrite H6 in H0.
rewrite H7 in H0.
clear H6 H7.
assert
 (codeIff
    (cPair (S (S (S (S (codeR x0)))))
       (codeTerms L codeF (arity L (inl (Functions L) x0))
          (fst (nVars L (arity L (inl (Functions L) x0))))))
    (cPair (S (S (S (S (codeR x0)))))
       (codeTerms L codeF (arity L (inl (Functions L) x0))
          (snd (nVars L (arity L (inl (Functions L) x0)))))) =
  codeIff
    (codeFormula L codeF codeR
       (atomic x0 (fst (nVars L (arity L (inl (Functions L) x0))))))
    (codeFormula L codeF codeR
       (atomic x0 (snd (nVars L (arity L (inl (Functions L) x0))))))).
reflexivity.
rewrite H6 in H0.
clear H6.
rewrite codeIffCorrect in H0.
assert (AxmEq4 L x0 = x).
clear H5.
unfold AxmEq4 in |- *.
induction (nVars L (arity L (inl (Functions L) x0))).
simpl in |- *.
unfold fst, snd in H0.
cut
 ((if beq_nat
        (codeAxmEqHelp (arity L (inl (Functions L) x0))
           (codeFormula L codeF codeR (iffH L (atomic x0 a) (atomic x0 b))))
        (codeFormula L codeF codeR x)
   then 1
   else 0) + 0 <> 0).
fold atomic in |- *.
generalize (iffH L (atomic x0 a) (atomic x0 b)).
intros.
clear H0.
clear a b.
cut
 (codeAxmEqHelp (arity L (inl (Functions L) x0))
    (codeFormula L codeF codeR f) = codeFormula L codeF codeR x).
generalize x.
clear H5.
induction (arity L (inl (Functions L) x0)); simpl in |- *; intros.
apply (codeFormulaInj L codeF codeR codeFInj codeRInj).
assumption.
rename x1 into f0.
repeat
 match goal with
 | H:(cPair 1 (cPair ?X2 ?X3) = cPair 1 (cPair ?X4 ?X5)) |- _ =>
     assert (X2 = X4);
      [ eapply cPairInj1; eapply cPairInj2; apply H
      | assert (X3 = X5);
         [ eapply cPairInj2; eapply cPairInj2; apply H | clear H ] ]
 | H:(cPair 0 (cPair ?X2 ?X3) = cPair 0 (cPair ?X4 ?X5)) |- _ =>
     assert (X2 = X4);
      [ eapply cPairInj1; eapply cPairInj2; apply H
      | assert (X3 = X5);
         [ eapply cPairInj2; eapply cPairInj2; apply H | clear H ] ]
 | H:(cPair ?X1 _ = codeFormula L codeF codeR ?X2) |- _ =>
      destruct X2;
      simpl in H;
      try
       match goal with
       | J:(cPair ?X1 _ = cPair ?X2 _) |- _ =>
           cut (X1 = X2);
            [ intro I; discriminate I | eapply cPairInj1; apply J ]
       end
 end.
rewrite (IHn1 f0_2).
destruct t.
replace n2 with (n1 + n1).
destruct t0.
replace n3 with (S (n1 + n1)).
reflexivity.
apply cPairInj2 with 0 0.
apply H7.
elim O_S with (codeF f0).
apply
 cPairInj1
  with (S (n1 + n1)) (codeTerms L codeF (arity L (inr (Relations L) f0)) t).
apply H7.
apply cPairInj2 with 0 0.
apply H0.
elim O_S with (codeF f0).
apply
 cPairInj1
  with (n1 + n1) (codeTerms L codeF (arity L (inr (Relations L) f0)) t).
apply H0.
assumption.
induction
 (eq_nat_dec
    (codeAxmEqHelp (arity L (inl (Functions L) x0))
       (codeFormula L codeF codeR f)) (codeFormula L codeF codeR x)).
assumption.
elim H5.
rewrite beq_nat_not_refl.
reflexivity.
assumption.
assumption.
rewrite H3.
rewrite <- H6.
exists (EQ4 L x0).
simpl in |- *.
rewrite H5.
rewrite H2.
apply cPairProjections.
destruct n1.
simpl in H0.
unfold checkPrfEQ5 in H0.
clear A.
repeat rewrite cPairProjections2 in H0.
repeat rewrite cPairProjections1 in H0.
exists (nil (A:=Formula)).
rewrite <- H3 in H0.
assert (codeArityF (cPairPi2 (cPairPi2 n)) <> 0).
unfold notZero in H0.
unfold not in |- *; intros.
rewrite H4 in H0.
apply H0.
reflexivity.
induction (codeArityFIsCorrect2 _ H4).
rewrite <- H5 in H0.
rewrite codeArityFIsCorrect1 in H0.
simpl in H0.
induction (codeNVarsCorrect (arity L (inr (Relations L) x0))).
rewrite H6 in H0.
rewrite H7 in H0.
clear H6 H7.
assert
 (cPair 0
    (cPair
       (cPair (S (codeF x0))
          (codeTerms L codeF (arity L (inr (Relations L) x0))
             (fst (nVars L (arity L (inr (Relations L) x0))))))
       (cPair (S (codeF x0))
          (codeTerms L codeF (arity L (inr (Relations L) x0))
             (snd (nVars L (arity L (inr (Relations L) x0))))))) =
  codeFormula L codeF codeR
    (equal (apply x0 (fst (nVars L (arity L (inr (Relations L) x0)))))
       (apply x0 (snd (nVars L (arity L (inr (Relations L) x0))))))).
reflexivity.
rewrite H6 in H0.
clear H6.
assert (AxmEq5 L x0 = x).
clear H5.
unfold AxmEq5 in |- *.
induction (nVars L (arity L (inr (Relations L) x0))).
simpl in |- *.
unfold fst, snd in H0.
cut
 ((if beq_nat
        (codeAxmEqHelp (arity L (inr (Relations L) x0))
           (codeFormula L codeF codeR (equal (apply x0 a) (apply x0 b))))
        (codeFormula L codeF codeR x)
   then 1
   else 0) + 0 <> 0).
fold apply equal in |- *.
generalize (equal (apply x0 a) (apply x0 b)).
intros.
clear H0.
clear a b.
cut
 (codeAxmEqHelp (arity L (inr (Relations L) x0))
    (codeFormula L codeF codeR f) = codeFormula L codeF codeR x).
generalize x.
clear H5.
induction (arity L (inr (Relations L) x0)); simpl in |- *; intros.
apply (codeFormulaInj L codeF codeR codeFInj codeRInj).
assumption.
repeat
 match goal with
 | H:(cPair 1 (cPair ?X2 ?X3) = cPair 1 (cPair ?X4 ?X5)) |- _ =>
     assert (X2 = X4);
      [ eapply cPairInj1; eapply cPairInj2; apply H
      | assert (X3 = X5);
         [ eapply cPairInj2; eapply cPairInj2; apply H | clear H ] ]
 | H:(cPair 0 (cPair ?X2 ?X3) = cPair 0 (cPair ?X4 ?X5)) |- _ =>
     assert (X2 = X4);
      [ eapply cPairInj1; eapply cPairInj2; apply H
      | assert (X3 = X5);
         [ eapply cPairInj2; eapply cPairInj2; apply H | clear H ] ]
 | H:(cPair ?X1 _ = codeFormula L codeF codeR ?X2) |- _ =>
      destruct X2;
      simpl in H;
      try
       match goal with
       | J:(cPair ?X1 _ = cPair ?X2 _) |- _ =>
           cut (X1 = X2);
            [ intro I; discriminate I | eapply cPairInj1; apply J ]
       end
 end.
rewrite (IHn1 x1_2).
destruct t.
replace n2 with (n1 + n1).
destruct t0.
replace n3 with (S (n1 + n1)).
reflexivity.
apply cPairInj2 with 0 0.
apply H7.
elim O_S with (codeF f0).
apply
 cPairInj1
  with (S (n1 + n1)) (codeTerms L codeF (arity L (inr (Relations L) f0)) t).
apply H7.
apply cPairInj2 with 0 0.
apply H0.
elim O_S with (codeF f0).
apply
 cPairInj1
  with (n1 + n1) (codeTerms L codeF (arity L (inr (Relations L) f0)) t).
apply H0.
assumption.
induction
 (eq_nat_dec
    (codeAxmEqHelp (arity L (inr (Relations L) x0))
       (codeFormula L codeF codeR f)) (codeFormula L codeF codeR x)).
assumption.
elim H5.
rewrite beq_nat_not_refl.
reflexivity.
assumption.
assumption.
rewrite H3.
rewrite <- H6.
exists (EQ5 L x0).
simpl in |- *.
rewrite H5.
rewrite H2.
apply cPairProjections.
elim H0.
simpl in |- *.
reflexivity.
intros.
assert
 (exists f : Formula,
    (exists l : list Formula,
       (exists p : Prf l f,
          cPair (codeFormula L codeF codeR f) (codePrf L codeF codeR l f p) =
          cPair n m))).
eapply H.
apply lt_n_Sn.
rewrite cPairProjections1.
rewrite cPairProjections2.
assumption.
decompose record H1.
exists x.
split.
eapply cPairInj1.
apply H2.
exists x0.
exists x1.
eapply cPairInj2.
apply H2.
Qed.

End Check_Proof.
