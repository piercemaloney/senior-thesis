Require Import Ensembles.

Require Import Coq.Lists.List.

Require Import Arith.

Require Import folProp.
(* folProp:
Require Import Wf_nat.
Require Import Max.
Require Import Arith.
Require Import Coq.Lists.List.
Require Import ListExt.
Require Import Peano_dec.

Require Export fol.

Section Fol_Properties.

Variable L : Language.

Notation Formula := (Formula L) (only parsing).
Notation Formulas := (Formulas L) (only parsing).
Notation System := (System L) (only parsing).
Notation Term := (Term L) (only parsing).
Notation Terms := (Terms L) (only parsing).
Let var := var L.
Let apply := apply L.
Let equal := equal L.
Let atomic := atomic L.
Let impH := impH L.
Let notH := notH L.
Let forallH := forallH L.
Let lt_depth := lt_depth L.

Section Free_Variables.

Fixpoint freeVarTerm (s : fol.Term L) : list nat :=
  match s with
  | fol.var v => v :: nil
  | fol.apply f ts => freeVarTerms (arity L (inr _ f)) ts
  end
 
 with freeVarTerms (n : nat) (ss : fol.Terms L n) {struct ss} : 
 list nat :=
  match ss with
  | Tnil => nil (A:=nat)
  | Tcons m t ts => freeVarTerm t ++ freeVarTerms m ts
  end.

Lemma freeVarTermApply :
 forall (f : Functions L) (ts : fol.Terms L _),

Fixpoint freeVarFormula (A : fol.Formula L) : list nat :=
  match A with
  | fol.equal t s => freeVarTerm t ++ freeVarTerm s
  | fol.atomic r ts => freeVarTerms _ ts
  | fol.impH A B => freeVarFormula A ++ freeVarFormula B
  | fol.notH A => freeVarFormula A
  | fol.forallH v A => list_remove _ eq_nat_dec v (freeVarFormula A)
  end.

Definition ClosedSystem (T : fol.System L) :=
  forall (v : nat) (f : fol.Formula L),
  mem _ T f -> ~ In v (freeVarFormula f).

Definition closeList (l : list nat) (x : fol.Formula L) : 
  fol.Formula L :=
  list_rec (fun _ => fol.Formula L) x
    (fun (a : nat) _ (rec : fol.Formula L) => forallH a rec) l.

Definition close (x : fol.Formula L) : fol.Formula L :=
  closeList (no_dup _ eq_nat_dec (freeVarFormula x)) x.

Lemma freeVarClosedList1 :
 forall (l : list nat) (v : nat) (x : fol.Formula L),

Lemma freeVarClosedList2 :
 forall (l : list nat) (v : nat) (x : fol.Formula L),

Lemma freeVarClosed :
 forall (x : fol.Formula L) (v : nat), ~ In v (freeVarFormula (close x)).

Fixpoint freeVarListFormula (l : fol.Formulas L) : 
 list nat :=
  match l with
  | nil => nil (A:=nat)
  | f :: l => freeVarFormula f ++ freeVarListFormula l
  end.

Lemma freeVarListFormulaApp :
 forall a b : fol.Formulas L,

Lemma In_freeVarListFormula :
 forall (v : nat) (f : fol.Formula L) (F : fol.Formulas L),

Lemma In_freeVarListFormulaE :
 forall (v : nat) (F : fol.Formulas L),

Definition In_freeVarSys (v : nat) (T : fol.System L) :=
  exists f : fol.Formula L, In v (freeVarFormula f) /\ mem _ T f.

Lemma notInFreeVarSys :
 forall x, ~ In_freeVarSys x (Ensembles.Empty_set (fol.Formula L)).

End Free_Variables.

Section Substitution.

Fixpoint substituteTerm (s : fol.Term L) (x : nat) 
 (t : fol.Term L) {struct s} : fol.Term L :=
  match s with
  | fol.var v =>
      match eq_nat_dec x v with
      | left _ => t
      | right _ => var v
      end
  | fol.apply f ts => apply f (substituteTerms _ ts x t)
  end
 
 with substituteTerms (n : nat) (ss : fol.Terms L n) 
 (x : nat) (t : fol.Term L) {struct ss} : fol.Terms L n :=
  match ss in (fol.Terms _ n0) return (fol.Terms L n0) with
  | Tnil => Tnil L
  | Tcons m s ts =>
      Tcons L m (substituteTerm s x t) (substituteTerms m ts x t)
  end.

Lemma subTermVar1 :
 forall (v : nat) (s : fol.Term L), substituteTerm (var v) v s = s.

Lemma subTermVar2 :
 forall (v x : nat) (s : fol.Term L),

Lemma subTermFunction :
 forall (f : Functions L) (ts : fol.Terms L (arity L (inr _ f))) 

Definition newVar (l : list nat) : nat := fold_right max 0 (map S l).

Lemma newVar2 : forall (l : list nat) (n : nat), In n l -> n < newVar l.

Lemma newVar1 : forall l : list nat, ~ In (newVar l) l.

Definition substituteFormulaImp (f : fol.Formula L)
  (frec : nat * fol.Term L -> {y : fol.Formula L | depth L y = depth L f})
  (g : fol.Formula L)
  (grec : nat * fol.Term L -> {y : fol.Formula L | depth L y = depth L g})
  (p : nat * fol.Term L) :
  {y : fol.Formula L | depth L y = depth L (impH f g)} :=
  match frec p with
  | exist f' prf1 =>
      match grec p with
      | exist g' prf2 =>
          exist
            (fun y : fol.Formula L =>
             depth L y = S (max (depth L f) (depth L g))) 
            (impH f' g')
            (eq_ind_r
               (fun n : nat =>
                S (max n (depth L g')) = S (max (depth L f) (depth L g)))
               (eq_ind_r
                  (fun n : nat =>
                   S (max (depth L f) n) = S (max (depth L f) (depth L g)))
                  (refl_equal (S (max (depth L f) (depth L g)))) prf2) prf1)
      end
  end.

Remark substituteFormulaImpNice :
 forall (f g : fol.Formula L)

Definition substituteFormulaNot (f : fol.Formula L)
  (frec : nat * fol.Term L -> {y : fol.Formula L | depth L y = depth L f})
  (p : nat * fol.Term L) :
  {y : fol.Formula L | depth L y = depth L (notH f)} :=
  match frec p with
  | exist f' prf1 =>
      exist (fun y : fol.Formula L => depth L y = S (depth L f)) 
        (notH f')
        (eq_ind_r (fun n : nat => S n = S (depth L f))
           (refl_equal (S (depth L f))) prf1)
  end.

Remark substituteFormulaNotNice :
 forall (f : fol.Formula L)

Definition substituteFormulaForall (n : nat) (f : fol.Formula L)
  (frec : forall b : fol.Formula L,
          lt_depth b (forallH n f) ->
          nat * fol.Term L -> {y : fol.Formula L | depth L y = depth L b})
  (p : nat * fol.Term L) :
  {y : fol.Formula L | depth L y = depth L (forallH n f)} :=
  match p with
  | (v, s) =>
      match eq_nat_dec n v with
      | left _ =>
          exist (fun y : fol.Formula L => depth L y = S (depth L f))
            (forallH n f) (refl_equal (depth L (forallH n f)))
      | right _ =>
          match In_dec eq_nat_dec n (freeVarTerm s) with
          | left _ =>
              let nv := newVar (v :: freeVarTerm s ++ freeVarFormula f) in
              match frec f (depthForall L f n) (n, var nv) with
              | exist f' prf1 =>
                  match
                    frec f'
                      (eqDepth L f' f (forallH n f) 
                         (sym_eq prf1) (depthForall L f n)) p
                  with
                  | exist f'' prf2 =>
                      exist
                        (fun y : fol.Formula L => depth L y = S (depth L f))
                        (forallH nv f'')
                        (eq_ind_r (fun n : nat => S n = S (depth L f))
                           (refl_equal (S (depth L f))) 
                           (trans_eq prf2 prf1))
                  end
              end
          | right _ =>
              match frec f (depthForall L f n) p with
              | exist f' prf1 =>
                  exist (fun y : fol.Formula L => depth L y = S (depth L f))
                    (forallH n f')
                    (eq_ind_r (fun n : nat => S n = S (depth L f))
                       (refl_equal (S (depth L f))) prf1)
              end
          end
      end
  end.

Remark substituteFormulaForallNice :
 forall (v : nat) (a : fol.Formula L)

Definition substituteFormulaHelp (f : fol.Formula L) 

Definition substituteFormula (f : fol.Formula L) (v : nat) 
  (s : fol.Term L) : fol.Formula L := proj1_sig (substituteFormulaHelp f v s).

Lemma subFormulaEqual :
 forall (t1 t2 : fol.Term L) (v : nat) (s : fol.Term L),

Lemma subFormulaRelation :
 forall (r : Relations L) (ts : fol.Terms L (arity L (inl _ r))) 

Lemma subFormulaImp :
 forall (f1 f2 : fol.Formula L) (v : nat) (s : fol.Term L),

Lemma subFormulaNot :
 forall (f : fol.Formula L) (v : nat) (s : fol.Term L),

Lemma subFormulaForall :
 forall (f : fol.Formula L) (x v : nat) (s : fol.Term L),

Section Extensions.

Let orH := orH L.
Let andH := andH L.
Let existH := existH L.
Let iffH := iffH L.
Let ifThenElseH := ifThenElseH L.

Lemma subFormulaOr :
 forall (f1 f2 : fol.Formula L) (v : nat) (s : fol.Term L),

Lemma subFormulaAnd :
 forall (f1 f2 : fol.Formula L) (v : nat) (s : fol.Term L),

Lemma subFormulaExist :
 forall (f : fol.Formula L) (x v : nat) (s : fol.Term L),

Lemma subFormulaIff :
 forall (f1 f2 : fol.Formula L) (v : nat) (s : fol.Term L),

Lemma subFormulaIfThenElse :
 forall (f1 f2 f3 : fol.Formula L) (v : nat) (s : fol.Term L),

End Extensions.

Lemma subFormulaDepth :
 forall (f : fol.Formula L) (v : nat) (s : fol.Term L),

Section Substitution_Properties.

Lemma subTermId :
 forall (t : fol.Term L) (v : nat), substituteTerm t v (var v) = t.

Lemma subTermsId :
 forall (n : nat) (ts : fol.Terms L n) (v : nat),

Lemma subFormulaId :
 forall (f : fol.Formula L) (v : nat), substituteFormula f v (var v) = f.

Lemma subFormulaForall2 :
 forall (f : fol.Formula L) (x v : nat) (s : fol.Term L),

Let existH := existH L.

Lemma subFormulaExist2 :
 forall (f : fol.Formula L) (x v : nat) (s : fol.Term L),

End Substitution_Properties.

End Substitution.
 
Definition Sentence (f:Formula) := (forall v : nat, ~ In v (freeVarFormula f)).

End Fol_Properties. *)

Require Import folProof.
(* folProof:
Require Import Ensembles.
Require Import Coq.Lists.List.
Require Import Arith.

Require Export fol.
Require Import folProp.

Section ProofH.

Variable L : Language.

Let Formula := Formula L.
Let Formulas := Formulas L.
Let System := System L.
Let Term := Term L.
Let Terms := Terms L.
Let var := var L.
Let apply := apply L.
Let equal := equal L.
Let atomic := atomic L.
Let impH := impH L.
Let notH := notH L.
Let iffH := iffH L.
Let forallH := forallH L.

Definition nVars (n : nat) : Terms n * Terms n.

Definition AxmEq4 (R : Relations L) : Formula.

Definition AxmEq5 (f : Functions L) : Formula.

Inductive Prf : Formulas -> Formula -> Set :=
  | AXM : forall A : Formula, Prf (A :: nil) A
  | MP :
      forall (Axm1 Axm2 : Formulas) (A B : Formula),
      Prf Axm1 (impH A B) -> Prf Axm2 A -> Prf (Axm1 ++ Axm2) B
  | GEN :
      forall (Axm : Formulas) (A : Formula) (v : nat),
      ~ In v (freeVarListFormula L Axm) -> Prf Axm A -> Prf Axm (forallH v A)
  | IMP1 : forall A B : Formula, Prf nil (impH A (impH B A))
  | IMP2 :
      forall A B C : Formula,
      Prf nil (impH (impH A (impH B C)) (impH (impH A B) (impH A C)))
  | CP :
      forall A B : Formula,
      Prf nil (impH (impH (notH A) (notH B)) (impH B A))
  | FA1 :
      forall (A : Formula) (v : nat) (t : Term),
      Prf nil (impH (forallH v A) (substituteFormula L A v t))
  | FA2 :
      forall (A : Formula) (v : nat),
      ~ In v (freeVarFormula L A) -> Prf nil (impH A (forallH v A))
  | FA3 :
      forall (A B : Formula) (v : nat),
      Prf nil
        (impH (forallH v (impH A B)) (impH (forallH v A) (forallH v B)))
  | EQ1 : Prf nil (equal (var 0) (var 0))
  | EQ2 : Prf nil (impH (equal (var 0) (var 1)) (equal (var 1) (var 0)))
  | EQ3 :
      Prf nil
        (impH (equal (var 0) (var 1))
           (impH (equal (var 1) (var 2)) (equal (var 0) (var 2))))
  | EQ4 : forall R : Relations L, Prf nil (AxmEq4 R)
  | EQ5 : forall f : Functions L, Prf nil (AxmEq5 f).

Definition SysPrf (T : System) (f : Formula) :=
  exists Axm : Formulas,
    (exists prf : Prf Axm f,
       (forall g : Formula, In g Axm -> mem _ T g)).

Definition Inconsistent (T : System) := forall f : Formula, SysPrf T f.

Definition Consistent (T : System) := exists f : Formula, ~ SysPrf T f.

End ProofH. *)

Require Import folReplace.
(* folReplace:
Require Import Ensembles.
Require Import Coq.Lists.List.
Require Import Peano_dec.

Require Import ListExt.
Require Import folProof.
Require Import folLogic.
Require Import folProp.

Section Replacement.

Variable L : Language.
Let Formula := Formula L.
Let Formulas := Formulas L.
Let System := System L.
Let Term := Term L.
Let Terms := Terms L.
Let var := var L.
Let apply := apply L.
Let equal := equal L.
Let atomic := atomic L.
Let impH := impH L.
Let notH := notH L.
Let forallH := forallH L.
Let orH := orH L.
Let andH := andH L.
Let existH := existH L.
Let iffH := iffH L.
Let ifThenElseH := ifThenElseH L.
Let SysPrf := SysPrf L.

Lemma reduceImp :
 forall (f1 f2 f3 f4 : Formula) (T : System),
 SysPrf T (iffH f1 f3) ->
 SysPrf T (iffH f2 f4) -> SysPrf T (iffH (impH f1 f2) (impH f3 f4)).

Lemma reduceNot :
 forall (f1 f2 : Formula) (T : System),
 SysPrf T (iffH f1 f2) -> SysPrf T (iffH (notH f1) (notH f2)).

Lemma impForall :
 forall (f1 f2 : Formula) (v : nat) (T : System),
 ~ In_freeVarSys _ v T ->
 SysPrf T (impH f1 f2) -> SysPrf T (impH (forallH v f1) (forallH v f2)).

Lemma reduceForall :
 forall (f1 f2 : Formula) (v : nat) (T : System),
 ~ In_freeVarSys _ v T ->
 SysPrf T (iffH f1 f2) -> SysPrf T (iffH (forallH v f1) (forallH v f2)).

Lemma reduceOr :
 forall (f1 f2 f3 f4 : Formula) (T : System),
 SysPrf T (iffH f1 f3) ->
 SysPrf T (iffH f2 f4) -> SysPrf T (iffH (orH f1 f2) (orH f3 f4)).

Lemma reduceAnd :
 forall (f1 f2 f3 f4 : Formula) (T : System),
 SysPrf T (iffH f1 f3) ->
 SysPrf T (iffH f2 f4) -> SysPrf T (iffH (andH f1 f2) (andH f3 f4)).

Lemma iffExist :
 forall (f1 f2 : Formula) (v : nat) (T : System),
 ~ In_freeVarSys _ v T ->
 SysPrf T (impH f1 f2) -> SysPrf T (impH (existH v f1) (existH v f2)).

Lemma reduceExist :
 forall (f1 f2 : Formula) (v : nat) (T : System),
 ~ In_freeVarSys _ v T ->
 SysPrf T (iffH f1 f2) -> SysPrf T (iffH (existH v f1) (existH v f2)).

Lemma reduceIff :
 forall (f1 f2 f3 f4 : Formula) (T : System),
 SysPrf T (iffH f1 f3) ->
 SysPrf T (iffH f2 f4) -> SysPrf T (iffH (iffH f1 f2) (iffH f3 f4)).

Lemma reduceIfThenElse :
 forall (f1 f2 f3 f4 f5 f6 : Formula) (T : System),
 SysPrf T (iffH f1 f4) ->
 SysPrf T (iffH f2 f5) ->
 SysPrf T (iffH f3 f6) ->
 SysPrf T (iffH (ifThenElseH f1 f2 f3) (ifThenElseH f4 f5 f6)).

Lemma reduceSub :
 forall (T : System) (v : nat) (s : Term) (f g : Formula),
 ~ In_freeVarSys L v T ->
 SysPrf T (iffH f g) ->
 SysPrf T (iffH (substituteFormula L f v s) (substituteFormula L g v s)).

Lemma reduceCloseList :
 forall (l : list nat) (f1 f2 : Formula) (T : System),
 (forall v : nat, In v l -> ~ In_freeVarSys _ v T) ->
 SysPrf T (iffH f1 f2) ->
 SysPrf T (iffH (closeList L l f1) (closeList L l f2)).

End Replacement. *)

Require Import folLogic3.
(* folLogic3:
Require Import Ensembles.
Require Import Coq.Lists.List.
Require Import ListExt.

Require Import folProp.
Require Import folProof.
Require Export folLogic2.
Require Import subProp.
Require Import folReplace.
Require Import Arith.
Require Import subAll.
Require Import misc.

Unset Standard Proposition Elimination Names.

Section Equality_Logic_Rules.

Variable L : Language.
Notation Formula := (Formula L) (only parsing).
Notation Formulas := (Formulas L) (only parsing).
Notation System := (System L) (only parsing).
Notation Term := (Term L) (only parsing).
Notation Terms := (Terms L) (only parsing).
Let var := var L.
Let apply := apply L.
Let equal := equal L.
Let atomic := atomic L.
Let impH := impH L.
Let notH := notH L.
Let forallH := forallH L.
Let orH := orH L.
Let andH := andH L.
Let existH := existH L.
Let iffH := iffH L.
Let ifThenElseH := ifThenElseH L.
Let Prf := Prf L.
Let SysPrf := SysPrf L.

Lemma eqRefl :
 forall (T : fol.System L) (a : fol.Term L), SysPrf T (equal a a).

Lemma eqSym :
 forall (T : fol.System L) (a b : fol.Term L),

Lemma eqTrans :
 forall (T : fol.System L) (a b c : fol.Term L),

Fixpoint PairwiseEqual (T : fol.System L) (n : nat) {struct n} :
 fol.Terms L n -> fol.Terms L n -> Prop :=
  match n return (fol.Terms L n -> fol.Terms L n -> Prop) with
  | O => fun ts ss : fol.Terms L 0 => True
  | S x =>
      fun ts ss : fol.Terms L (S x) =>
      let (a, b) := proj1_sig (consTerms L x ts) in
      let (c, d) := proj1_sig (consTerms L x ss) in
      SysPrf T (equal a c) /\ PairwiseEqual T x b d
  end.

Let termsMap (m : nat) (ts ss : fol.Terms L m) : nat -> fol.Term L.

Remark subAllnVars1 :
 forall (a : nat) (ts ss : fol.Terms L a),

Remark subAllnVars2 :
 forall (a : nat) (ts ss : fol.Terms L a),

Remark addPairwiseEquals :
 forall (T : fol.System L) (n : nat) (ts ss : fol.Terms L n),

Lemma equalRelation :
 forall (T : fol.System L) (r : Relations L) (ts ss : fol.Terms L _),

Lemma equalFunction :
 forall (T : fol.System L) (f : Functions L) (ts ss : fol.Terms L _),

Lemma subWithEqualsTerm :
 forall (a b t : fol.Term L) (v : nat) (T : fol.System L),

Lemma subWithEqualsTerms :
 forall (a b : fol.Term L) (n : nat) (ts : fol.Terms L n) 

Lemma subWithEquals :
 forall (f : fol.Formula L) (v : nat) (a b : fol.Term L) (T : fol.System L),

End Equality_Logic_Rules. *)

Require Import subProp.
(* subProp:
Require Import Ensembles.
Require Import Coq.Lists.List.
Require Import Peano_dec.
Require Import ListExt.
Require Import Arith.

Require Import folProof.
Require Import folLogic.
Require Import folProp.
Require Import folReplace.

Section Substitution_Properties.

Variable L : Language.
Let Formula := Formula L.
Let Formulas := Formulas L.
Let System := System L.
Let Term := Term L.
Let Terms := Terms L.
Let var := var L.
Let apply := apply L.
Let equal := equal L.
Let atomic := atomic L.
Let impH := impH L.
Let notH := notH L.
Let forallH := forallH L.
Let orH := orH L.
Let andH := andH L.
Let existH := existH L.
Let iffH := iffH L.
Let SysPrf := SysPrf L.

Lemma freeVarSubTerm1 :
 forall (t : Term) (v : nat) (s : Term) (x : nat),
 In x (freeVarTerm L t) ->
 v <> x -> In x (freeVarTerm L (substituteTerm L t v s)).

Lemma freeVarSubTerms1 :
 forall (n : nat) (ts : Terms n) (v : nat) (s : Term) (x : nat),
 In x (freeVarTerms L n ts) ->
 v <> x -> In x (freeVarTerms L n (substituteTerms L n ts v s)).

Lemma freeVarSubFormula1 :
 forall (f : Formula) (v : nat) (s : Term) (x : nat),
 v <> x ->
 In x (freeVarFormula L f) ->
 In x (freeVarFormula L (substituteFormula L f v s)).

Lemma freeVarSubTerm2 :
 forall (t : Term) (v : nat) (s : Term) (x : nat),
 In x (freeVarTerm L s) ->
 In v (freeVarTerm L t) -> In x (freeVarTerm L (substituteTerm L t v s)).

Lemma freeVarSubTerms2 :
 forall (n : nat) (ts : Terms n) (v : nat) (s : Term) (x : nat),
 In x (freeVarTerm L s) ->
 In v (freeVarTerms L n ts) ->
 In x (freeVarTerms L n (substituteTerms L n ts v s)).

Lemma freeVarSubFormula2 :
 forall (f : Formula) (v : nat) (s : Term) (x : nat),
 In x (freeVarTerm L s) ->
 In v (freeVarFormula L f) ->
 In x (freeVarFormula L (substituteFormula L f v s)).

Lemma freeVarSubTerm3 :
 forall (t : Term) (v : nat) (s : Term) (x : nat),
 In x (freeVarTerm L (substituteTerm L t v s)) ->
 In x (list_remove _ eq_nat_dec v (freeVarTerm L t)) \/
 In x (freeVarTerm L s).

Lemma freeVarSubTerms3 :
 forall (n : nat) (ts : fol.Terms L n) (v : nat) (s : Term) (x : nat),

Lemma freeVarSubFormula3 :
 forall (f : Formula) (v : nat) (s : Term) (x : nat),
 In x (freeVarFormula L (substituteFormula L f v s)) ->
 In x (list_remove _ eq_nat_dec v (freeVarFormula L f)) \/
 In x (freeVarTerm L s).

Lemma freeVarSubTerm4 :
 forall (t : Term) (v : nat) (s : Term) (x : nat),
 In x (freeVarTerm L (substituteTerm L t v s)) ->
 ~ In v (freeVarTerm L t) -> In x (freeVarTerm L t).

Lemma freeVarSubTerms4 :
 forall (n : nat) (ts : Terms n) (v : nat) (s : Term) (x : nat),
 In x (freeVarTerms L n (substituteTerms L n ts v s)) ->
 ~ In v (freeVarTerms L n ts) -> In x (freeVarTerms L n ts).

Lemma freeVarSubFormula4 :
 forall (f : Formula) (v : nat) (s : Term) (x : nat),
 In x (freeVarFormula L (substituteFormula L f v s)) ->
 ~ In v (freeVarFormula L f) -> In x (freeVarFormula L f).

Lemma subTermNil :
 forall (t : Term) (v : nat) (s : Term),
 ~ In v (freeVarTerm L t) -> substituteTerm L t v s = t.

Lemma subTermTrans :
 forall (t : Term) (v1 v2 : nat) (s : Term),
 ~ In v2 (list_remove _ eq_nat_dec v1 (freeVarTerm L t)) ->
 substituteTerm L (substituteTerm L t v1 (var v2)) v2 s =
 substituteTerm L t v1 s.

Lemma subTermExch :
 forall (t : Term) (v1 v2 : nat) (s1 s2 : Term),
 v1 <> v2 ->
 ~ In v2 (freeVarTerm L s1) ->
 ~ In v1 (freeVarTerm L s2) ->
 substituteTerm L (substituteTerm L t v1 s1) v2 s2 =
 substituteTerm L (substituteTerm L t v2 s2) v1 s1.

Lemma subTermsNil :
 forall (n : nat) (ts : Terms n) (v : nat) (s : Term),
 ~ In v (freeVarTerms L n ts) -> substituteTerms L n ts v s = ts.

Lemma subTermsTrans :
 forall (n : nat) (ts : Terms n) (v1 v2 : nat) (s : Term),
 ~ In v2 (list_remove _ eq_nat_dec v1 (freeVarTerms L n ts)) ->
 substituteTerms L n (substituteTerms L n ts v1 (var v2)) v2 s =
 substituteTerms L n ts v1 s.

Lemma subTermsExch :
 forall (n : nat) (ts : Terms n) (v1 v2 : nat) (s1 s2 : Term),
 v1 <> v2 ->
 ~ In v2 (freeVarTerm L s1) ->
 ~ In v1 (freeVarTerm L s2) ->
 substituteTerms L n (substituteTerms L n ts v1 s1) v2 s2 =
 substituteTerms L n (substituteTerms L n ts v2 s2) v1 s1.

Remark subFormulaNTEHelp :
 forall (f g : Formula) (v : nat) (s : Term),
 SysPrf (Ensembles.Add _ (Empty_set Formula) f) g ->

Remark subFormulaNTE :
 forall (f : Formula) (T : System),
 (forall (v : nat) (s : Term),
  ~ In v (freeVarFormula L f) ->
  SysPrf T (iffH (substituteFormula L f v s) f)) /\
 (forall (v1 v2 : nat) (s : Term),
  ~ In v2 (list_remove _ eq_nat_dec v1 (freeVarFormula L f)) ->
  SysPrf T
    (iffH (substituteFormula L (substituteFormula L f v1 (var v2)) v2 s)
       (substituteFormula L f v1 s))) /\
 (forall (v1 v2 : nat) (s1 s2 : Term),
  v1 <> v2 ->
  ~ In v2 (freeVarTerm L s1) ->
  ~ In v1 (freeVarTerm L s2) ->
  SysPrf T
    (iffH (substituteFormula L (substituteFormula L f v1 s1) v2 s2)
       (substituteFormula L (substituteFormula L f v2 s2) v1 s1))).

Lemma subFormulaNil :
 forall (f : Formula) (T : System) (v : nat) (s : Term),
 ~ In v (freeVarFormula L f) -> SysPrf T (iffH (substituteFormula L f v s) f).

Lemma subFormulaTrans :
 forall (f : Formula) (T : System) (v1 v2 : nat) (s : Term),
 ~ In v2 (list_remove _ eq_nat_dec v1 (freeVarFormula L f)) ->
 SysPrf T
   (iffH (substituteFormula L (substituteFormula L f v1 (var v2)) v2 s)
      (substituteFormula L f v1 s)).

Lemma subFormulaExch :
 forall (f : Formula) (T : System) (v1 v2 : nat) (s1 s2 : Term),
 v1 <> v2 ->
 ~ In v2 (freeVarTerm L s1) ->
 ~ In v1 (freeVarTerm L s2) ->
 SysPrf T
   (iffH (substituteFormula L (substituteFormula L f v1 s1) v2 s2)
      (substituteFormula L (substituteFormula L f v2 s2) v1 s1)).

End Substitution_Properties. *)

Require Import ListExt.
(* ListExt:
Require Import Coq.Lists.List.

Section List_Remove.

Variable A : Set.
Hypothesis Aeq_dec : forall a b : A, {a = b} + {a <> b}.

Definition list_remove (x : A) (l : list A) : list A :=
  list_rec (fun _ => list A) nil
    (fun (a : A) _ (recl : list A) =>
     match Aeq_dec a x with
     | left _ => recl
     | right _ => a :: recl
     end) l.

Lemma In_list_remove1 :
 forall (a b : A) (l : list A), In a (list_remove b l) -> In a l.

Lemma In_list_remove2 :
 forall (a b : A) (l : list A), In a (list_remove b l) -> a <> b.

Lemma In_list_remove3 :
 forall (a b : A) (l : list A), In a l -> a <> b -> In a (list_remove b l).

End List_Remove.

Section No_Duplicate.

Variable A : Set.
Hypothesis Aeq_dec : forall a b : A, {a = b} + {a <> b}.

Definition no_dup (l : list A) : list A :=
  list_rec (fun _ => list A) nil
    (fun (a : A) _ (rec : list A) =>
     match In_dec Aeq_dec a rec with
     | left _ => rec
     | right _ => a :: rec
     end) l.

Lemma no_dup1 : forall (a : A) (l : list A), In a l -> In a (no_dup l).

Lemma no_dup2 : forall (a : A) (l : list A), In a (no_dup l) -> In a l.

Lemma no_dup3 : forall (k l : list A) (a : A), no_dup k = a :: l -> ~ In a l.

End No_Duplicate. *)

Require Import fixPoint.
(* fixPoint:
Require Import primRec.
Require Import cPair.
Require Import Arith.
Require Import code.
Require Import codeSubFormula.
Require Import folProp.
Require Import folProof.
Require Import Languages.
Require Import subAll.
Require Import subProp.
Require Import folLogic3.
Require Import folReplace.
Require Import LNN.
Require Import codeNatToTerm.
Require Import PRrepresentable.
Require Import ListExt.
Require Import Coq.Lists.List.
Require Import NN.
Require Import expressible.

Definition subStar (a v n : nat) := codeSubFormula a v (codeNatToTerm n).

Lemma subStarIsPR : isPR 3 subStar.

Section LNN_FixPoint.

Let codeFormula := codeFormula LNN codeLNTFunction codeLNNRelation.

Lemma FixPointLNN :
 forall (A : Formula) (v : nat),
 {B : Formula |
   SysPrf NN
     (iffH B (substituteFormula LNN A v (natToTermLNN (codeFormula B)))) /\
   (forall x : nat,
    In x (freeVarFormula LNN B) <->
    In x (list_remove _ eq_nat_dec v (freeVarFormula LNN A)))}.

End LNN_FixPoint.

Section LNT_FixPoint.

Require Import PA.
Require Import NN2PA.

Let codeFormula := codeFormula LNT codeLNTFunction codeLNTRelation.

Lemma FixPointLNT :
 forall (A : Formula) (v : nat),
 {B : Formula |
   SysPrf PA
     (iffH B (substituteFormula LNT A v (natToTermLNT (codeFormula B)))) /\
   (forall x : nat,
    In x (freeVarFormula LNT B) <->
    In x (list_remove _ eq_nat_dec v (freeVarFormula LNT A)))}.

End LNT_FixPoint. *)

Require Import codeSysPrf.
(* codeSysPrf:
Require Import Ensembles.
Require Import Coq.Lists.List.
Require Import checkPrf.
Require Import code.
Require Import Languages.
Require Import folProp.
Require Import folProof.
Require Import folLogic3.
Require Import folReplace.
Require Import PRrepresentable.
Require Import expressible.
Require Import primRec.
Require Import Arith.
Require Import PA.
Require Import NNtheory.
Require Import codeList.
Require Import subProp.
Require Import ListExt.
Require Import cPair.
Require Import wellFormed.
Require Import prLogic.

Ltac SimplFreeVar :=
  repeat
   match goal with
   | H1:(?X1 = ?X2),H2:(?X1 <> ?X2) |- _ =>
       elim H2; apply H1
   | H1:(?X1 = ?X2),H2:(?X2 <> ?X1) |- _ =>
       elim H2; symmetry  in |- *; apply H1
   | H1:(?X1 <> ?X1) |- _ =>
       elim H1; reflexivity
   | H:(In ?X3 (freeVarFormula ?X9 (existH ?X1 ?X2))) |- _ =>
       assert (In X3 (list_remove nat eq_nat_dec X1 (freeVarFormula X9 X2)));
        [ apply H | clear H ]
   | H:(In ?X3 (freeVarFormula ?X9 (fol.existH ?X9 ?X1 ?X2))) |- _ =>
       assert (In X3 (list_remove nat eq_nat_dec X1 (freeVarFormula X9 X2)));
        [ apply H | clear H ]
   | H:(In ?X3 (freeVarFormula ?X9 (forallH ?X1 ?X2))) |- _ =>
       assert (In X3 (list_remove nat eq_nat_dec X1 (freeVarFormula X9 X2)));
        [ apply H | clear H ]
   | H:(In ?X3 (freeVarFormula ?X9 (fol.forallH ?X9 ?X1 ?X2))) |- _ =>
       assert (In X3 (list_remove nat eq_nat_dec X1 (freeVarFormula X9 X2)));
        [ apply H | clear H ]
   | H:(In ?X3 (list_remove nat eq_nat_dec ?X1 (freeVarFormula ?X9 ?X2))) |-
   _ =>
       assert (In X3 (freeVarFormula X9 X2));
        [ eapply In_list_remove1; apply H
        | assert (X3 <> X1); [ eapply In_list_remove2; apply H | clear H ] ]
   | H:(In ?X3 (freeVarFormula ?X9 (andH ?X1 ?X2))) |- _ =>
       assert (In X3 (freeVarFormula X9 X1 ++ freeVarFormula X9 X2));
        [ apply H | clear H ]
   | H:(In ?X3 (freeVarFormula ?X9 (fol.andH ?X9 ?X1 ?X2))) |- _ =>
       assert (In X3 (freeVarFormula X9 X1 ++ freeVarFormula X9 X2));
        [ apply H | clear H ]
   | H:(In ?X3 (freeVarFormula ?X9 (orH ?X1 ?X2))) |- _ =>
       assert (In X3 (freeVarFormula X9 X1 ++ freeVarFormula X9 X2));
        [ apply H | clear H ]
   | H:(In ?X3 (freeVarFormula ?X9 (fol.orH ?X9 ?X1 ?X2))) |- _ =>
       assert (In X3 (freeVarFormula X9 X1 ++ freeVarFormula X9 X2));
        [ apply H | clear H ]
   | H:(In ?X3 (freeVarFormula ?X9 (impH ?X1 ?X2))) |- _ =>
       assert (In X3 (freeVarFormula X9 X1 ++ freeVarFormula X9 X2));
        [ apply H | clear H ]
   | H:(In ?X3 (freeVarFormula ?X9 (fol.impH ?X9 ?X1 ?X2))) |- _ =>
       assert (In X3 (freeVarFormula X9 X1 ++ freeVarFormula X9 X2));
        [ apply H | clear H ]
   | H:(In ?X3 (freeVarFormula ?X9 (notH ?X1))) |- _ =>
       assert (In X3 (freeVarFormula X9 X1)); [ apply H | clear H ]
   | H:(In ?X3 (freeVarFormula ?X9 (fol.notH ?X9 ?X1))) |- _ =>
       assert (In X3 (freeVarFormula X9 X1)); [ apply H | clear H ]
   | H:(In _ (_ ++ _)) |- _ =>
       induction (in_app_or _ _ _ H); clear H
   | H:(In _ (freeVarFormula ?X9 (substituteFormula ?X9 ?X1 ?X2 ?X3))) |- _
   =>
       induction (freeVarSubFormula3 _ _ _ _ _ H); clear H
   | H:(In _ (freeVarFormula ?X9 (LT ?X1 ?X2))) |- _ =>
       rewrite freeVarLT in H
   | H:(In _ (freeVarTerm ?X9 (LNT.natToTerm _))) |- _ =>
       elim (LNT.closedNatToTerm _ _ H)
   | H:(In _ (freeVarTerm ?X9 (natToTerm _))) |- _ =>
       elim (closedNatToTerm _ _ H)
   | H:(In _ (freeVarTerm ?X9 Zero)) |- _ =>
       elim H
   | H:(In _ (freeVarTerm ?X9 (Succ _))) |- _ =>
       rewrite freeVarSucc in H
   | H:(In _ (freeVarTerm ?X9 (var _))) |- _ =>
       simpl in H; decompose sum H; clear H
   | H:(In _ (freeVarTerm ?X9 (LNT.var _))) |- _ =>
       simpl in H; decompose sum H; clear H
   | H:(In _ (freeVarTerm ?X9 (fol.var ?X9 _))) |- _ =>
       simpl in H; decompose sum H; clear H
   end.

Section code_SysPrf.

Variable L : Language.
Variable codeF : Functions L -> nat.
Variable codeR : Relations L -> nat.
Variable codeArityF : nat -> nat.
Variable codeArityR : nat -> nat.
Hypothesis codeArityFIsPR : isPR 1 codeArityF.
Hypothesis
  codeArityFIsCorrect1 :
    forall f : Functions L, codeArityF (codeF f) = S (arity L (inr _ f)).
Hypothesis
  codeArityFIsCorrect2 :
    forall n : nat, codeArityF n <> 0 -> exists f : Functions L, codeF f = n.
Hypothesis codeArityRIsPR : isPR 1 codeArityR.
Hypothesis
  codeArityRIsCorrect1 :
    forall r : Relations L, codeArityR (codeR r) = S (arity L (inl _ r)).
Hypothesis
  codeArityRIsCorrect2 :
    forall n : nat, codeArityR n <> 0 -> exists r : Relations L, codeR r = n.

Hypothesis codeFInj : forall f g : Functions L, codeF f = codeF g -> f = g.
Hypothesis codeRInj : forall R S : Relations L, codeR R = codeR S -> R = S.

Section LNN.

Variable T : System.
Hypothesis TextendsNN : Included _ NN T.
Variable U : fol.System L.
Variable fU : Formula.
Variable v0 : nat.
Hypothesis freeVarfU : forall v : nat, In v (freeVarFormula LNN fU) -> v = v0.
Hypothesis
  expressU1 :
    forall f : fol.Formula L,
    mem _ U f ->
    SysPrf T
      (substituteFormula LNN fU v0 (natToTerm (codeFormula L codeF codeR f))).
Hypothesis
  expressU2 :
    forall f : fol.Formula L,
    ~ mem _ U f ->
    SysPrf T
      (notH
         (substituteFormula LNN fU v0
            (natToTerm (codeFormula L codeF codeR f)))).

Definition codeSysPrf : Formula :=
  let nv := newVar (2 :: 1 :: 0 :: v0 :: nil) in
  existH nv
    (andH
       (substituteFormula LNN
          (substituteFormula LNN
             (primRecFormula 2
                (proj1_sig
                   (checkPrfIsPR L codeF codeR codeArityF codeArityR
                      codeArityFIsPR codeArityRIsPR))) 0 
             (Succ (var nv))) 2 (var 0))
       (forallH (S nv)
          (impH (LT (var (S nv)) (var nv))
             (orH
                (substituteFormula LNN
                   (substituteFormula LNN
                      (substituteFormula LNN
                         (primRecFormula 2 (proj1_sig codeInIsPR)) 2
                         (var (S nv))) 1 (var nv)) 0 Zero)
                (substituteFormula LNN fU v0 (var (S nv))))))).

Lemma codeSysPrfCorrect1 :
 forall (f : fol.Formula L) (A : list (fol.Formula L)) (p : Prf L A f),

Lemma codeSysPrfCorrect2 :
 forall (f : fol.Formula L) (A : fol.Formulas L),

Lemma codeSysPrfCorrect3 :
 forall (f : fol.Formula L) (n : nat),

Lemma freeVarCodeSysPrf :
 forall v : nat, In v (freeVarFormula LNN codeSysPrf) -> v <= 1.

Definition codeSysPf : Formula := existH 1 codeSysPrf.

Lemma freeVarCodeSysPf :
 forall v : nat, In v (freeVarFormula LNN codeSysPf) -> v = 0.

Lemma codeSysPfCorrect :
 forall f : fol.Formula L,

Definition codeSysPrfNot :=
  existH 2
    (andH (substituteFormula LNN codeSysPrf 0 (var 2))
       (substituteFormula LNN
          (substituteFormula LNN (primRecFormula 1 (proj1_sig codeNotIsPR)) 0
             (var 2)) 1 (var 0))).

Lemma freeVarCodeSysPrfN :
 forall v : nat, In v (freeVarFormula LNN codeSysPrfNot) -> v <= 1.

Lemma codeSysPrfNCorrect1 :
 forall (f : fol.Formula L) (A : fol.Formulas L) (p : Prf L A (fol.notH L f)),

Lemma codeSysPrfNCorrect2 :
 forall (f : fol.Formula L) (A : fol.Formulas L),

Lemma codeSysPrfNCorrect3 :
 forall (f : fol.Formula L) (n : nat),

End LNN.

End code_SysPrf. *)

Require Import NNtheory.
(* NNtheory:
Require Import Arith.

Require Import folLogic3.
Require Import folProp.
Require Import subProp.
Require Export NN.

Lemma natNE :
 forall a b : nat,
 a <> b -> SysPrf NN (notH (equal (natToTerm a) (natToTerm b))).

Lemma natLE :
 forall a b : nat,
 b <= a -> SysPrf NN (notH (LT (natToTerm a) (natToTerm b))).

Lemma natLT :
 forall a b : nat, a < b -> SysPrf NN (LT (natToTerm a) (natToTerm b)).

Lemma natPlus :
 forall a b : nat,
 SysPrf NN (equal (Plus (natToTerm a) (natToTerm b)) (natToTerm (a + b))).

Lemma natTimes :
 forall a b : nat,
 SysPrf NN (equal (Times (natToTerm a) (natToTerm b)) (natToTerm (a * b))).

Lemma boundedLT :
 forall (m : nat) (a : Formula) (x : nat),
 (forall n : nat,
  n < m -> SysPrf NN (substituteFormula LNN a x (natToTerm n))) ->
 SysPrf NN (impH (LT (var x) (natToTerm m)) a).

Lemma nnPlusNotNeeded :
 forall n : nat,
 SysPrf NN
   (impH (orH (LT (var 1) (natToTerm n)) (equal (var 1) (natToTerm n)))
      (LT (var 1) (Succ (natToTerm n)))). *)

Require Import code.
(* code:
Require Import Arith.
Require Import fol.
Require Import folProof.
Require Import cPair.

Section Code_Term_Formula_Proof.

Variable L : Language.
Variable codeF : Functions L -> nat.
Variable codeR : Relations L -> nat.
Hypothesis codeFInj : forall f g : Functions L, codeF f = codeF g -> f = g.
Hypothesis codeRInj : forall R S : Relations L, codeR R = codeR S -> R = S.

Let Formula := Formula L.
Let Formulas := Formulas L.
Let System := System L.
Let Term := Term L.
Let Terms := Terms L.
Let var := var L.
Let apply := apply L.
Let equal := equal L.
Let atomic := atomic L.
Let impH := impH L.
Let notH := notH L.
Let forallH := forallH L.
Let orH := orH L.
Let andH := andH L.
Let existH := existH L.
Let iffH := iffH L.
Let ifThenElseH := ifThenElseH L.
Let Prf := Prf L.
Let SysPrf := SysPrf L.

Fixpoint codeTerm (t : Term) : nat :=
  match t with
  | fol.var n => cPair 0 n
  | fol.apply f ts => cPair (S (codeF f)) (codeTerms _ ts)
  end
 
 with codeTerms (n : nat) (ts : Terms n) {struct ts} : nat :=
  match ts with
  | Tnil => 0
  | Tcons n t ss => S (cPair (codeTerm t) (codeTerms n ss))
  end.

Lemma codeTermInj : forall t s : Term, codeTerm t = codeTerm s -> t = s.

Lemma codeTermsInj :
 forall (n : nat) (ts ss : Terms n),
 codeTerms n ts = codeTerms n ss -> ts = ss.

Fixpoint codeFormula (f : Formula) : nat :=
  match f with
  | fol.equal t1 t2 => cPair 0 (cPair (codeTerm t1) (codeTerm t2))
  | fol.impH f1 f2 => cPair 1 (cPair (codeFormula f1) (codeFormula f2))
  | fol.notH f1 => cPair 2 (codeFormula f1)
  | fol.forallH n f1 => cPair 3 (cPair n (codeFormula f1))
  | fol.atomic R ts => cPair (4+(codeR R)) (codeTerms _ ts)
  end.

Lemma codeFormulaInj :
 forall f g : Formula, codeFormula f = codeFormula g -> f = g.

Fixpoint codePrf (Z : Formulas) (f : Formula) (prf : Prf Z f) {struct prf} :
 nat :=
  match prf with
  | AXM A => cPair 0 (codeFormula A)
  | MP Axm1 Axm2 A B rec1 rec2 =>
      cPair 1
        (cPair
           (cPair (cPair 1 (cPair (codeFormula A) (codeFormula B)))
              (codePrf _ _ rec1)) (cPair (codeFormula A) (codePrf _ _ rec2)))
  | GEN Axm A v _ rec =>
      cPair 2 (cPair v (cPair (codeFormula A) (codePrf _ _ rec)))
  | IMP1 A B => cPair 3 (cPair (codeFormula A) (codeFormula B))
  | IMP2 A B C =>
      cPair 4 (cPair (codeFormula A) (cPair (codeFormula B) (codeFormula C)))
  | CP A B => cPair 5 (cPair (codeFormula A) (codeFormula B))
  | FA1 A v t => cPair 6 (cPair (codeFormula A) (cPair v (codeTerm t)))
  | FA2 A v _ => cPair 7 (cPair (codeFormula A) v)
  | FA3 A B v => cPair 8 (cPair (codeFormula A) (cPair (codeFormula B) v))
  | EQ1 => cPair 9 0
  | EQ2 => cPair 10 0
  | EQ3 => cPair 11 0
  | EQ4 r => cPair 12 (codeR r)
  | EQ5 f => cPair 13 (codeF f)
  end.

Lemma codePrfInjAxm :
 forall (a b : Formula) (A B : Formulas) (p : Prf A a) (q : Prf B b),
 codePrf A a p = codePrf B b q -> A = B.

Definition codeImp (a b : nat) := cPair 1 (cPair a b).

Lemma codeImpCorrect :
 forall a b : Formula,
 codeImp (codeFormula a) (codeFormula b) = codeFormula (impH a b).

Definition codeNot (a : nat) := cPair 2 a.

Lemma codeNotCorrect :
 forall a : Formula, codeNot (codeFormula a) = codeFormula (notH a).

Definition codeForall (n a : nat) := cPair 3 (cPair n a).

Lemma codeForallCorrect :
 forall (n : nat) (a : Formula),
 codeForall n (codeFormula a) = codeFormula (forallH n a).

Definition codeOr (a b : nat) := codeImp (codeNot a) b.

Lemma codeOrCorrect :
 forall a b : Formula,
 codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).

Definition codeAnd (a b : nat) := codeNot (codeOr (codeNot a) (codeNot b)).

Lemma codeAndCorrect :
 forall a b : Formula,
 codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).

Definition codeIff (a b : nat) := codeAnd (codeImp a b) (codeImp b a).

Lemma codeIffCorrect :
 forall a b : Formula,
 codeIff (codeFormula a) (codeFormula b) = codeFormula (iffH a b).

End Code_Term_Formula_Proof. *)

Require Import PRrepresentable.
(* PRrepresentable:
Require Import Arith.
Require Import extEqualNat.
Require Import subAll.
Require Import folProp.
Require Import subProp.
Require Import folReplace.
Require Import folLogic3.
Require Import NN.
Require Import NNtheory.
Require Import primRec.
Require Import chRem.
Require Import expressible.
Require Import Coq.Lists.List.
Require Vector.
Require Import ListExt.
Require Import cPair.
Require Import Decidable.

Section Primative_Recursive_Representable.

Let Representable := Representable NN.
Let RepresentableAlternate := RepresentableAlternate NN closedNN1.
Let RepresentableHelp := RepresentableHelp NN.
Let Representable_ext := Representable_ext NN.

Definition beta (a z : nat) : nat :=
  snd
    (proj1_sig
       (modulo (coPrimeBeta z (cPairPi1 a)) (gtBeta z (cPairPi1 a))
          (cPairPi2 a))).

Definition betaFormula : Formula :=
  existH 3
    (andH (LT (var 3) (Succ (var 2)))
       (existH 4
          (andH (LT (var 4) (Succ (var 2)))
             (andH
                (equal
                   (Plus
                      (Times (Plus (var 3) (var 4))
                         (Succ (Plus (var 3) (var 4))))
                      (Times (natToTerm 2) (var 3)))
                   (Times (natToTerm 2) (var 2)))
                (andH (LT (var 0) (Succ (Times (var 3) (Succ (var 1)))))
                   (existH 5
                      (andH (LT (var 5) (Succ (var 4)))
                         (equal
                            (Plus (var 0)
                               (Times (var 5)
                                  (Succ (Times (var 3) (Succ (var 1))))))
                            (var 4))))))))).

Lemma betaRepresentable : Representable 2 beta betaFormula.
Proof.
assert
 (cPairLemma1 :
  forall a b : nat, (a + b) * S (a + b) + 2 * a = 2 * cPair a b).
intros.
unfold cPair in |- *.
rewrite mult_plus_distr_l.
rewrite plus_comm.
replace (2 * sumToN (a + b)) with ((a + b) * S (a + b)).
reflexivity.
induction (a + b).
simpl in |- *.
reflexivity.
simpl in |- *.
simpl in IHn.
rewrite <- plus_Snm_nSm.
simpl in |- *.
rewrite (plus_comm (sumToN n) 0) in IHn.
simpl in IHn.
rewrite (plus_comm (n + sumToN n) 0).
simpl in |- *.
rewrite plus_assoc_reverse.
rewrite (plus_comm (sumToN n)).
rewrite plus_assoc_reverse.
rewrite <- IHn.
replace (n * S (S n)) with (n + n * S n).
reflexivity.
repeat rewrite (mult_comm n).
simpl in |- *.
reflexivity.
unfold Representable in |- *.
split.
intros.
simpl in H.
decompose sum H; rewrite <- H0 || rewrite <- H1; auto.
simpl in |- *.
intros.
unfold betaFormula in |- *.
assert
 (forall (A : Formula) (v x a : nat),
  v <> x ->
  substituteFormula LNN (existH v A) x (natToTerm a) =
  existH v (substituteFormula LNN A x (natToTerm a))).
intros.
rewrite (subFormulaExist LNN).
induction (eq_nat_dec v x).
elim H.
auto.
induction (In_dec eq_nat_dec v (freeVarTerm LNN (natToTerm a1))).
elim (closedNatToTerm _ _ a2).
reflexivity.
assert
 (forall (t1 t2 : Term) (v a : nat),
  substituteFormula LNN (LT t1 t2) v (natToTerm a) =
  LT (substituteTerm LNN t1 v (natToTerm a))
    (substituteTerm LNN t2 v (natToTerm a))).
intros.
unfold LT at 1 in |- *.
rewrite (subFormulaRelation LNN).
reflexivity.
repeat first
 [ rewrite H; [ idtac | discriminate ]
 | rewrite H0
 | rewrite (subFormulaAnd LNN)
 | rewrite (subFormulaEqual LNN) ].
simpl in |- *.
repeat rewrite (subTermNil LNN).
cut
 (SysPrf NN
    (iffH
       (existH 3
          (andH (LT (var 3) (natToTerm (S a)))
             (existH 4
                (andH (LT (var 4) (natToTerm (S a)))
                   (andH
                      (equal
                         (Plus
                            (Times (Plus (var 3) (var 4))
                               (Succ (Plus (var 3) (var 4))))
                            (Times (natToTerm 2) (var 3)))
                         (Times (natToTerm 2) (natToTerm a)))
                      (andH
                         (LT (var 0)
                            (Succ (Times (var 3) (Succ (natToTerm a0)))))
                         (existH 5
                            (andH (LT (var 5) (Succ (var 4)))
                               (equal
                                  (Plus (var 0)
                                     (Times (var 5)
                                        (Succ
                                           (Times (var 3)
                                              (Succ (natToTerm a0))))))
                                  (var 4))))))))))
       (equal (var 0) (natToTerm (beta a a0))))).
auto.
apply iffI.
apply impI.
apply existSys.
apply closedNN.
unfold not in |- *; intros.
induction H1 as [H1| H1].
discriminate H1.
simpl in H1.
elim (closedNatToTerm _ _ H1).
apply impE with (LT (var 3) (natToTerm (S a))).
apply
 impE
  with
    (existH 4
       (andH (LT (var 4) (natToTerm (S a)))
          (andH
             (equal
                (Plus
                   (Times (Plus (var 3) (var 4))
                      (Succ (Plus (var 3) (var 4))))
                   (Times (natToTerm 2) (var 3)))
                (Times (natToTerm 2) (natToTerm a)))
             (andH (LT (var 0) (Succ (Times (var 3) (Succ (natToTerm a0)))))
                (existH 5
                   (andH (LT (var 5) (Succ (var 4)))
                      (equal
                         (Plus (var 0)
                            (Times (var 5)
                               (Succ (Times (var 3) (Succ (natToTerm a0))))))
                         (var 4)))))))).
apply sysWeaken.
apply impI.
apply existSys.
apply closedNN.
replace
 (freeVarFormula LNN
    (impH (LT (var 3) (natToTerm (S a)))
       (equal (var 0) (natToTerm (beta a a0))))) with
 ((freeVarTerm LNN (var 3) ++ freeVarTerm LNN (natToTerm (S a))) ++
  freeVarFormula LNN (equal (var 0) (natToTerm (beta a a0)))).
unfold not in |- *; intros.
simpl in H1.
induction H1 as [H1| H1].
discriminate H1.
induction (in_app_or _ _ _ H1).
rewrite freeVarSucc in H2.
elim (closedNatToTerm _ _ H2).
induction H2 as [H2| H2].
discriminate H2.
elim (closedNatToTerm _ _ H2).
rewrite <- freeVarLT.
reflexivity.
apply
 impTrans
  with
    (andH (equal (var 3) (natToTerm (cPairPi1 a)))
       (equal (var 4) (natToTerm (cPairPi2 a)))).
apply impI.
apply
 impE
  with
    (equal
       (Plus (Times (Plus (var 3) (var 4)) (Succ (Plus (var 3) (var 4))))
          (Times (natToTerm 2) (var 3))) (Times (natToTerm 2) (natToTerm a))).
apply impE with (LT (var 4) (natToTerm (S a))).
apply impE with (LT (var 3) (natToTerm (S a))).
do 2 apply sysWeaken.
apply boundedLT.
intros.
rewrite (subFormulaImp LNN).
unfold LT at 1 in |- *.
rewrite (subFormulaRelation LNN).
simpl in |- *.
rewrite subTermNil.
fold (var 4) in |- *.
replace (apply LNN Languages.Succ (Tcons LNN 0 (natToTerm a) (Tnil LNN)))
 with (natToTerm (S a)); [ idtac | reflexivity ].
fold (LT (var 4) (natToTerm (S a))) in |- *.
apply boundedLT.
intros.
repeat rewrite (subFormulaImp LNN).
repeat rewrite (subFormulaAnd LNN).
repeat rewrite (subFormulaEqual LNN).
replace
 (substituteTerm LNN
    (substituteTerm LNN
       (Plus (Times (Plus (var 3) (var 4)) (Succ (Plus (var 3) (var 4))))
          (Times (Succ (Succ Zero)) (var 3))) 3 (natToTerm n)) 4
    (natToTerm n0)) with
 (Plus
    (Times (Plus (natToTerm n) (natToTerm n0))
       (Succ (Plus (natToTerm n) (natToTerm n0))))
    (Times (Succ (Succ Zero)) (natToTerm n))).
replace
 (substituteTerm LNN
    (substituteTerm LNN (Times (Succ (Succ Zero)) (natToTerm a)) 3
       (natToTerm n)) 4 (natToTerm n0)) with
 (Times (natToTerm 2) (natToTerm a)).
simpl in |- *.
assert
 (forall (a b : nat) (s : Term),
  substituteTerm LNN (natToTerm a) b s = natToTerm a).
intros.
apply (subTermNil LNN).
apply closedNatToTerm.
repeat rewrite H3.
apply
 impTrans
  with
    (equal (natToTerm ((n + n0) * S (n + n0) + 2 * n)) (natToTerm (2 * a))).
apply impI.
eapply eqTrans; [ apply sysWeaken; apply eqSym | idtac ].
apply natPlus.
eapply eqTrans.
apply eqPlus.
eapply eqTrans; [ apply sysWeaken; apply eqSym | idtac ].
apply natTimes.
eapply eqTrans.
apply eqTimes.
apply sysWeaken; apply eqSym.
apply natPlus.
eapply eqTrans; [ apply sysWeaken; apply eqSym | idtac ].
simpl in |- *.
apply eqSucc.
apply natPlus.
apply eqRefl.
apply eqRefl.
apply sysWeaken; apply eqSym.
apply natTimes.
eapply eqTrans.
apply Axm; right; constructor.
apply sysWeaken.
replace (Succ (Succ Zero)) with (natToTerm 2).
apply natTimes.
reflexivity.
rewrite cPairLemma1.
induction (eq_nat_dec a (cPair n n0)).
rewrite a1.
rewrite cPairProjections1.
rewrite cPairProjections2.
apply impI.
apply andI; apply eqRefl.
apply impI.
apply
 contradiction with (equal (natToTerm (2 * cPair n n0)) (natToTerm (2 * a))).
apply Axm; right; constructor.
apply sysWeaken.
apply natNE.
unfold not in |- *; intros.
induction (nat_total_order _ _ b).
elim (lt_not_le (2 * a) (2 * cPair n n0)).
apply mult_S_lt_compat_l.
auto.
rewrite H4.
apply le_n.
elim (lt_not_le (2 * cPair n n0) (2 * a)).
apply mult_S_lt_compat_l.
auto.
rewrite H4.
apply le_n.
simpl in |- *.
repeat
 (rewrite (subTermNil LNN (natToTerm a)); [ idtac | apply closedNatToTerm ]).
reflexivity.
simpl in |- *.
repeat
 (rewrite (subTermNil LNN (natToTerm n)); [ idtac | apply closedNatToTerm ]).
reflexivity.
apply closedNatToTerm.
apply Axm; right; constructor.
eapply andE1.
apply Axm; left; right; constructor.
eapply andE1.
eapply andE2.
apply Axm; left; right; constructor.
repeat apply impI.
apply
 impE
  with
    (existH 5
       (andH (LT (var 5) (Succ (var 4)))
          (equal
             (Plus (var 0)
                (Times (var 5) (Succ (Times (var 3) (Succ (natToTerm a0))))))
             (var 4)))).
apply impE with (LT (var 0) (Succ (Times (var 3) (Succ (natToTerm a0))))).
rewrite <-
 (subFormulaId LNN
    (impH (LT (var 0) (Succ (Times (var 3) (Succ (natToTerm a0)))))
       (impH
          (existH 5
             (andH (LT (var 5) (Succ (var 4)))
                (equal
                   (Plus (var 0)
                      (Times (var 5)
                         (Succ (Times (var 3) (Succ (natToTerm a0))))))
                   (var 4)))) (equal (var 0) (natToTerm (beta a a0))))) 3)
 .
apply
 impE
  with
    (substituteFormula LNN
       (impH (LT (var 0) (Succ (Times (var 3) (Succ (natToTerm a0)))))
          (impH
             (existH 5
                (andH (LT (var 5) (Succ (var 4)))
                   (equal
                      (Plus (var 0)
                         (Times (var 5)
                            (Succ (Times (var 3) (Succ (natToTerm a0))))))
                      (var 4)))) (equal (var 0) (natToTerm (beta a a0))))) 3
       (natToTerm (cPairPi1 a))).
apply (subWithEquals LNN).
apply eqSym.
eapply andE1.
apply Axm; right; constructor.
rewrite <-
 (subFormulaId LNN
    (substituteFormula LNN
       (impH (LT (var 0) (Succ (Times (var 3) (Succ (natToTerm a0)))))
          (impH
             (existH 5
                (andH (LT (var 5) (Succ (var 4)))
                   (equal
                      (Plus (var 0)
                         (Times (var 5)
                            (Succ (Times (var 3) (Succ (natToTerm a0))))))
                      (var 4)))) (equal (var 0) (natToTerm (beta a a0))))) 3
       (natToTerm (cPairPi1 a))) 4).
apply
 impE
  with
    (substituteFormula LNN
       (substituteFormula LNN
          (impH (LT (var 0) (Succ (Times (var 3) (Succ (natToTerm a0)))))
             (impH
                (existH 5
                   (andH (LT (var 5) (Succ (var 4)))
                      (equal
                         (Plus (var 0)
                            (Times (var 5)
                               (Succ (Times (var 3) (Succ (natToTerm a0))))))
                         (var 4)))) (equal (var 0) (natToTerm (beta a a0)))))
          3 (natToTerm (cPairPi1 a))) 4 (natToTerm (cPairPi2 a))).
apply (subWithEquals LNN).
apply eqSym.
eapply andE2.
apply Axm; right; constructor.
do 2 apply sysWeaken.
repeat first
 [ rewrite H; [ idtac | discriminate ]
 | rewrite H0
 | rewrite (subFormulaImp LNN)
 | rewrite (subFormulaAnd LNN)
 | rewrite (subFormulaEqual LNN) ].
simpl in |- *.
repeat (rewrite (subTermNil LNN); [ idtac | apply closedNatToTerm ]).
repeat
 (rewrite (subTermNil LNN (natToTerm a0)); [ idtac | apply closedNatToTerm ]).
repeat
 (rewrite (subTermNil LNN (natToTerm (beta a a0)));
   [ idtac | apply closedNatToTerm ]).
apply impTrans with (LT (var 0) (natToTerm (S (cPairPi1 a * S a0)))).
apply impI.
apply
 impE
  with
    (substituteFormula LNN (LT (var 0) (var 1)) 1
       (natToTerm (S (cPairPi1 a * S a0)))).
unfold LT at 2 in |- *.
rewrite (subFormulaRelation LNN).
apply impRefl.
apply
 impE
  with
    (substituteFormula LNN (LT (var 0) (var 1)) 1
       (Succ (Times (natToTerm (cPairPi1 a)) (Succ (natToTerm a0))))).
apply (subWithEquals LNN).
apply sysWeaken.
simpl in |- *.
apply eqSucc.
replace (Succ (natToTerm a0)) with (natToTerm (S a0)).
apply natTimes.
reflexivity.
unfold LT at 2 in |- *.
rewrite (subFormulaRelation LNN).
apply Axm; right; constructor.
apply boundedLT.
intros.
repeat first
 [ rewrite H; [ idtac | discriminate ]
 | rewrite H0
 | rewrite (subFormulaImp LNN)
 | rewrite (subFormulaAnd LNN)
 | rewrite (subFormulaEqual LNN) ].
simpl in |- *.
repeat (rewrite (subTermNil LNN); [ idtac | apply closedNatToTerm ]).
apply impI.
apply existSys.
apply closedNN.
simpl in |- *.
unfold not in |- *; intros.
induction (in_app_or _ _ _ H2); elim (closedNatToTerm _ _ H3).
apply
 impE
  with
    (fol.equal LNN
       (apply LNN Languages.Plus
          (Tcons LNN 1 (natToTerm n)
             (Tcons LNN 0
                (apply LNN Languages.Times
                   (Tcons LNN 1 (fol.var LNN 5)
                      (Tcons LNN 0
                         (apply LNN Languages.Succ
                            (Tcons LNN 0
                               (apply LNN Languages.Times
                                  (Tcons LNN 1 (natToTerm (cPairPi1 a))
                                     (Tcons LNN 0
                                        (apply LNN Languages.Succ
                                           (Tcons LNN 0 
                                              (natToTerm a0) 
                                              (Tnil LNN))) 
                                        (Tnil LNN)))) 
                               (Tnil LNN))) (Tnil LNN)))) 
                (Tnil LNN)))) (natToTerm (cPairPi2 a))).
apply impE with (LT (var 5) (natToTerm (S (cPairPi2 a)))).
apply sysWeaken.
apply boundedLT.
intros.
repeat first
 [ rewrite H; [ idtac | discriminate ]
 | rewrite H0
 | rewrite (subFormulaImp LNN)
 | rewrite (subFormulaAnd LNN)
 | rewrite (subFormulaEqual LNN) ].
simpl in |- *.
repeat (rewrite (subTermNil LNN); [ idtac | apply closedNatToTerm ]).
apply impI.
induction (eq_nat_dec n (beta a a0)).
rewrite <- a1.
apply eqRefl.
apply
 contradiction
  with
    (equal (natToTerm (n + n0 * S (cPairPi1 a * S a0)))
       (natToTerm (cPairPi2 a))).
eapply eqTrans; [ idtac | apply Axm; right; constructor ].
apply sysWeaken.
eapply eqTrans.
apply eqSym.
apply natPlus.
replace
 (apply LNN Languages.Plus
    (Tcons LNN 1 (natToTerm n)
       (Tcons LNN 0
          (apply LNN Languages.Times
             (Tcons LNN 1 (natToTerm n0)
                (Tcons LNN 0
                   (apply LNN Languages.Succ
                      (Tcons LNN 0
                         (apply LNN Languages.Times
                            (Tcons LNN 1 (natToTerm (cPairPi1 a))
                               (Tcons LNN 0
                                  (apply LNN Languages.Succ
                                     (Tcons LNN 0 (natToTerm a0) (Tnil LNN)))
                                  (Tnil LNN)))) (Tnil LNN))) 
                   (Tnil LNN)))) (Tnil LNN)))) with
 (Plus (natToTerm n)
    (Times (natToTerm n0)
       (Succ (Times (natToTerm (cPairPi1 a)) (Succ (natToTerm a0)))))).
apply eqPlus.
apply eqRefl.
eapply eqTrans.
apply eqSym.
apply natTimes.
apply eqTimes.
apply eqRefl.
simpl in |- *.
apply eqSucc.
replace (Succ (natToTerm a0)) with (natToTerm (S a0)).
apply eqSym.
apply natTimes.
reflexivity.
reflexivity.
apply sysWeaken.
apply natNE.
unfold not in |- *; intros; elim b.
unfold beta in |- *.
induction
 (modulo (coPrimeBeta a0 (cPairPi1 a)) (gtBeta a0 (cPairPi1 a)) (cPairPi2 a)).
induction x as (a1, b0).
simpl in p.
simpl in |- *.
induction p as (H4, H5).
unfold coPrimeBeta in H4.
rewrite plus_comm in H3.
eapply uniqueRem.
unfold gt in |- *.
apply lt_O_Sn.
exists n0.
split.
symmetry  in |- *.
apply H3.
apply H1.
exists a1.
split.
apply H4.
apply H5.
eapply andE1.
apply Axm; right; constructor.
eapply andE2.
apply Axm; right; constructor.
eapply andE1.
eapply andE2.
eapply andE2.
apply Axm; left; right; constructor.
eapply andE2.
eapply andE2.
eapply andE2.
apply Axm; left; right; constructor.
eapply andE2.
apply Axm; right; constructor.
eapply andE1.
apply Axm; right; constructor.
apply impI.
unfold beta in |- *.
induction
 (modulo (coPrimeBeta a0 (cPairPi1 a)) (gtBeta a0 (cPairPi1 a)) (cPairPi2 a)).
induction x as (a1, b).
simpl in |- *.
simpl in p.
induction p as (H1, H2).
apply existI with (natToTerm (cPairPi1 a)).
rewrite (subFormulaAnd LNN).
apply andI.
apply sysWeaken.
rewrite H0.
simpl in |- *.
rewrite subTermNil.
replace (apply LNN Languages.Succ (Tcons LNN 0 (natToTerm a) (Tnil LNN)))
 with (natToTerm (S a)).
apply natLT.
apply le_lt_n_Sm.
apply le_trans with (cPair (cPairPi1 a) (cPairPi2 a)).
apply cPairLe1.
rewrite cPairProjections.
apply le_n.
reflexivity.
apply closedNatToTerm.
rewrite H.
apply existI with (natToTerm (cPairPi2 a)).
repeat rewrite (subFormulaAnd LNN).
apply andI.
apply sysWeaken.
repeat rewrite H0.
simpl in |- *.
repeat rewrite (subTermNil LNN (natToTerm a)).
replace (apply LNN Languages.Succ (Tcons LNN 0 (natToTerm a) (Tnil LNN)))
 with (natToTerm (S a)).
apply natLT.
apply le_lt_n_Sm.
apply le_trans with (cPair (cPairPi1 a) (cPairPi2 a)).
apply cPairLe2.
rewrite cPairProjections.
apply le_n.
reflexivity.
apply closedNatToTerm.
apply closedNatToTerm.
apply andI.
repeat rewrite (subFormulaEqual LNN).
simpl in |- *.
repeat
 (rewrite (subTermNil LNN (natToTerm (cPairPi1 a)));
   [ idtac | apply closedNatToTerm ]).
repeat
 (rewrite (subTermNil LNN (natToTerm a)); [ idtac | apply closedNatToTerm ]).
replace
 (fol.equal LNN
    (apply LNN Languages.Plus
       (Tcons LNN 1
          (apply LNN Languages.Times
             (Tcons LNN 1
                (apply LNN Languages.Plus
                   (Tcons LNN 1 (natToTerm (cPairPi1 a))
                      (Tcons LNN 0 (natToTerm (cPairPi2 a)) (Tnil LNN))))
                (Tcons LNN 0
                   (apply LNN Languages.Succ
                      (Tcons LNN 0
                         (apply LNN Languages.Plus
                            (Tcons LNN 1 (natToTerm (cPairPi1 a))
                               (Tcons LNN 0 (natToTerm (cPairPi2 a))
                                  (Tnil LNN)))) (Tnil LNN))) 
                   (Tnil LNN))))
          (Tcons LNN 0
             (apply LNN Languages.Times
                (Tcons LNN 1
                   (apply LNN Languages.Succ
                      (Tcons LNN 0
                         (apply LNN Languages.Succ
                            (Tcons LNN 0
                               (apply LNN Languages.Zero (Tnil LNN))
                               (Tnil LNN))) (Tnil LNN)))
                   (Tcons LNN 0 (natToTerm (cPairPi1 a)) (Tnil LNN))))
             (Tnil LNN))))
    (apply LNN Languages.Times
       (Tcons LNN 1
          (apply LNN Languages.Succ
             (Tcons LNN 0
                (apply LNN Languages.Succ
                   (Tcons LNN 0 (apply LNN Languages.Zero (Tnil LNN))
                      (Tnil LNN))) (Tnil LNN)))
          (Tcons LNN 0 (natToTerm a) (Tnil LNN))))) with
 (equal
    (Plus
       (Times (Plus (natToTerm (cPairPi1 a)) (natToTerm (cPairPi2 a)))
          (Succ (Plus (natToTerm (cPairPi1 a)) (natToTerm (cPairPi2 a)))))
       (Times (natToTerm 2) (natToTerm (cPairPi1 a))))
    (Times (natToTerm 2) (natToTerm a))); [ idtac | reflexivity ].
apply
 eqTrans
  with
    (natToTerm
       ((cPairPi1 a + cPairPi2 a) * S (cPairPi1 a + cPairPi2 a) +
        2 * cPairPi1 a)).
apply sysWeaken.
apply eqSym.
eapply eqTrans.
apply eqSym.
apply natPlus.
apply eqPlus.
eapply eqTrans.
apply eqSym.
apply natTimes.
apply eqTimes.
apply eqSym.
apply natPlus.
simpl in |- *.
apply eqSucc.
apply eqSym.
apply natPlus.
apply eqSym.
apply natTimes.
rewrite cPairLemma1.

Fixpoint addExists (m n : nat) (f : Formula) {struct n} : Formula :=
  match n with
  | O => f
  | S n' => existH (n' + m) (addExists m n' f)
  end.

Lemma freeVarAddExists1 :
 forall (n m v : nat) (A : Formula),
 In v (freeVarFormula LNN (addExists m n A)) -> In v (freeVarFormula LNN A).

Lemma freeVarAddExists2 :
 forall (n m v : nat) (A : Formula),
 In v (freeVarFormula LNN (addExists m n A)) -> n + m <= v \/ v < m.

Lemma reduceAddExistsOneWay :
 forall (n m : nat) (A B : Formula),
 SysPrf NN (impH A B) -> SysPrf NN (impH (addExists m n A) (addExists m n B)).

Lemma reduceAddExists :
 forall (n m : nat) (A B : Formula),
 SysPrf NN (iffH A B) -> SysPrf NN (iffH (addExists m n A) (addExists m n B)).

Lemma subAddExistsNice :
 forall (n m : nat) (A : Formula) (v : nat) (s : Term),
 n + m <= v \/ v < m ->
 (forall v : nat, In v (freeVarTerm LNN s) -> n + m <= v \/ v < m) ->
 substituteFormula LNN (addExists m n A) v s =
 addExists m n (substituteFormula LNN A v s).

Fixpoint addForalls (m n : nat) (f : Formula) {struct n} : Formula :=
  match n with
  | O => f
  | S n' => forallH (n' + m) (addForalls m n' f)
  end.

Lemma freeVarAddForalls1 :
 forall (n m v : nat) (A : Formula),
 In v (freeVarFormula LNN (addForalls m n A)) -> In v (freeVarFormula LNN A).

Lemma freeVarAddForalls2 :
 forall (n m v : nat) (A : Formula),
 In v (freeVarFormula LNN (addForalls m n A)) -> n + m <= v \/ v < m.

Lemma reduceAddForalls :
 forall (n m : nat) (A B : Formula),
 SysPrf NN (iffH A B) ->
 SysPrf NN (iffH (addForalls m n A) (addForalls m n B)).

Lemma subAddForallsNice :
 forall (n m : nat) (A : Formula) (v : nat) (s : Term),
 n + m <= v \/ v < m ->
 (forall v : nat, In v (freeVarTerm LNN s) -> n + m <= v \/ v < m) ->
 substituteFormula LNN (addForalls m n A) v s =
 addForalls m n (substituteFormula LNN A v s).

Fixpoint FormulasToFormula (n w m : nat)
 (vs : Vector.t (Formula * naryFunc n) m) {struct vs} : Formula :=
  match vs with
  | Vector.nil => equal (var 0) (var 0)
  | Vector.cons v m' vs' =>
      andH (substituteFormula LNN (fst v) 0 (var (S m' + w)))
        (FormulasToFormula n w m' vs')
  end.

Fixpoint FormulasToFuncs (n m : nat) (vs : Vector.t (Formula * naryFunc n) m)
 {struct vs} : Vector.t (naryFunc n) m :=
  match vs in (Vector.t _ m) return (Vector.t (naryFunc n) m) with
  | Vector.nil => Vector.nil _
  | Vector.cons v m' vs' => Vector.cons _ (snd v) m' (FormulasToFuncs n m' vs')
  end.

Fixpoint RepresentablesHelp (n m : nat)
 (vs : Vector.t (Formula * naryFunc n) m) {struct vs} : Prop :=
  match vs with
  | Vector.nil => True
  | Vector.cons a m' vs' =>
      RepresentableHelp _ (snd a) (fst a) /\ RepresentablesHelp n m' vs'
  end.

Let succFormula : Formula := equal (var 0) (Succ (var 1)).

Remark succRepresentable : Representable 1 S succFormula.

Let zeroFormula : Formula := equal (var 0) Zero.

Remark zeroRepresentable : Representable 0 0 zeroFormula.

Let projFormula (m : nat) : Formula := equal (var 0) (var (S m)).

Remark projRepresentable :
 forall (n m : nat) (pr : m < n),
 Representable n (evalProjFunc n m pr) (projFormula m).

Let composeSigmaFormula (n w m : nat) (A : Vector.t (Formula * naryFunc n) m)
  (B : Formula) : Formula :=
  addExists (S w) m
    (andH (FormulasToFormula n w m A)
       (subAllFormula LNN B
          (fun x : nat =>
           match x with
           | O => var 0
           | S x' => var (S x' + w)
           end))).

Remark composeSigmaRepresentable :
 forall n w m : nat,
 n <= w ->
 forall (A : Vector.t (Formula * naryFunc n) m) (B : Formula) (g : naryFunc m),

Remark boundedCheck :
 forall P : nat -> Prop,
 (forall x : nat, decidable (P x)) ->
 forall c : nat,
 (forall d : nat, d < c -> ~ P d) \/ (exists d : nat, d < c /\ P d).

Remark smallestExists :
 forall P : nat -> Prop,
 (forall x : nat, decidable (P x)) ->
 forall c : nat,
 P c -> exists a : nat, P a /\ (forall b : nat, b < a -> ~ P b).

Let minimize (A B : Formula) (v x : nat) : Formula :=
  andH A
    (forallH x
       (impH (LT (var x) (var v)) (notH (substituteFormula LNN B v (var x))))).

Remark minimize1 :
 forall (A B : Formula) (v x : nat),
 v <> x ->
 ~ In x (freeVarFormula LNN B) ->
 forall a : nat,
 SysPrf NN (substituteFormula LNN A v (natToTerm a)) ->
 SysPrf NN (substituteFormula LNN B v (natToTerm a)) ->
 (forall b : nat,
  b < a -> SysPrf NN (notH (substituteFormula LNN A v (natToTerm b)))) ->
 (forall b : nat,
  b < a -> SysPrf NN (notH (substituteFormula LNN B v (natToTerm b)))) ->
 SysPrf NN (iffH (minimize A B v x) (equal (var v) (natToTerm a))).

Lemma subFormulaMinimize :
 forall (A B : Formula) (v x z : nat) (s : Term),
 ~ In x (freeVarTerm LNN s) ->
 ~ In v (freeVarTerm LNN s) ->
 x <> z ->
 v <> z ->
 SysPrf NN
   (iffH (substituteFormula LNN (minimize A B v x) z s)
      (minimize (substituteFormula LNN A z s) (substituteFormula LNN B z s) v
         x)).

Let primRecSigmaFormulaHelp (n : nat) (SigA SigB : Formula) : Formula :=
  andH
    (existH 0
       (andH SigA
          (substituteFormula LNN (substituteFormula LNN betaFormula 1 Zero) 2
             (var (S (S n))))))
    (forallH (S (S (S n)))
       (impH (LT (var (S (S (S n)))) (var (S n)))
          (existH 0
             (existH (S n)
                (andH
                   (substituteFormula LNN
                      (substituteFormula LNN
                         (substituteFormula LNN betaFormula 1
                            (var (S (S (S n))))) 2 
                         (var (S (S n)))) 0 (var (S n)))
                   (andH
                      (substituteFormula LNN SigB (S (S n))
                         (var (S (S (S n)))))
                      (substituteFormula LNN
                         (substituteFormula LNN betaFormula 1
                            (Succ (var (S (S (S n)))))) 2 
                         (var (S (S n)))))))))).

Let primRecPiFormulaHelp (n : nat) (SigA SigB : Formula) : Formula :=
  andH
    (forallH 0
       (impH SigA
          (substituteFormula LNN (substituteFormula LNN betaFormula 1 Zero) 2
             (var (S (S n))))))
    (forallH (S (S (S n)))
       (impH (LT (var (S (S (S n)))) (var (S n)))
          (forallH 0
             (forallH (S n)
                (impH
                   (substituteFormula LNN
                      (substituteFormula LNN
                         (substituteFormula LNN betaFormula 1
                            (var (S (S (S n))))) 2 
                         (var (S (S n)))) 0 (var (S n)))
                   (impH
                      (substituteFormula LNN SigB (S (S n))
                         (var (S (S (S n)))))
                      (substituteFormula LNN
                         (substituteFormula LNN betaFormula 1
                            (Succ (var (S (S (S n)))))) 2 
                         (var (S (S n)))))))))).

Lemma freeVarPrimRecSigmaFormulaHelp1 :
 forall (n : nat) (A B : Formula) (v : nat),
 In v (freeVarFormula LNN (primRecSigmaFormulaHelp n A B)) ->
 In v (freeVarFormula LNN A) \/
 In v (freeVarFormula LNN B) \/ v = S (S n) \/ v = S n.

Lemma freeVarPrimRecPiFormulaHelp1 :
 forall (n : nat) (A B : Formula) (v : nat),
 In v (freeVarFormula LNN (primRecPiFormulaHelp n A B)) ->
 In v (freeVarFormula LNN A) \/
 In v (freeVarFormula LNN B) \/ v = S (S n) \/ v = S n.

Let primRecSigmaFormula (n : nat) (SigA SigB : Formula) : Formula :=
  existH (S (S n))
    (andH
       (minimize (primRecSigmaFormulaHelp n SigA SigB)
          (primRecPiFormulaHelp n SigA SigB) (S (S n)) 
          (S (S (S (S n)))))
       (substituteFormula LNN
          (substituteFormula LNN betaFormula 2 (var (S (S n)))) 1 
          (var (S n)))).

Remark notBoundedForall :
 forall (P : nat -> Prop) (b : nat),
 (forall x : nat, decidable (P x)) ->
 ~ (forall n : nat, n < b -> P n) -> exists n : nat, n < b /\ ~ P n.

Lemma succ_plus_discr : forall n m : nat, n <> S (m + n).

Lemma n_SSn : forall n : nat, n <> S (S n).

Lemma n_SSSn : forall n : nat, n <> S (S (S n)).

Lemma n_SSSSn : forall n : nat, n <> S (S (S (S n))).

Remark In_betaFormula_subst_1_2_0 :
 forall (a b c : Term) (v : nat),
 In v
   (freeVarFormula LNN
      (substituteFormula LNN
         (substituteFormula LNN (substituteFormula LNN betaFormula 1 a) 2 b)
         0 c)) ->
 In v (freeVarTerm LNN a) \/
 In v (freeVarTerm LNN b) \/ In v (freeVarTerm LNN c).

Remark In_betaFormula_subst_1_2 :
 forall (a b : Term) (v : nat),
 In v
   (freeVarFormula LNN
      (substituteFormula LNN (substituteFormula LNN betaFormula 1 a) 2 b)) ->
 In v (freeVarTerm LNN a) \/
 In v (freeVarTerm LNN b) \/ In v (freeVarTerm LNN (var 0)).

Remark In_betaFormula_subst_1 :
 forall (a : Term) (v : nat),
 In v (freeVarFormula LNN (substituteFormula LNN betaFormula 1 a)) ->
 In v (freeVarTerm LNN a) \/
 In v (freeVarTerm LNN (var 2)) \/ In v (freeVarTerm LNN (var 0)).

Remark In_betaFormula :
 forall v : nat,
 In v (freeVarFormula LNN betaFormula) ->
 In v (freeVarTerm LNN (var 1)) \/
 In v (freeVarTerm LNN (var 2)) \/ In v (freeVarTerm LNN (var 0)).

Remark In_betaFormula_subst_2 :
 forall (a : Term) (v : nat),
 In v (freeVarFormula LNN (substituteFormula LNN betaFormula 2 a)) ->
 In v (freeVarTerm LNN a) \/
 In v (freeVarTerm LNN (var 1)) \/ In v (freeVarTerm LNN (var 0)).

Remark In_betaFormula_subst_2_1 :
 forall (a b : Term) (v : nat),
 In v
   (freeVarFormula LNN
      (substituteFormula LNN (substituteFormula LNN betaFormula 2 a) 1 b)) ->
 In v (freeVarTerm LNN a) \/
 In v (freeVarTerm LNN b) \/ In v (freeVarTerm LNN (var 0)).

Ltac PRsolveFV A B n :=
  unfold existH, forallH, not in |- *; intros;
   repeat
    match goal with
    | H:(_ = _) |- _ => discriminate H
    | H:(?X1 <> ?X1) |- _ => elim H; reflexivity
    | H:(?X1 = S ?X1) |- _ => elim (n_Sn _ H)
    | H:(S ?X1 = ?X1) |- _ =>
        elim (n_Sn X1); symmetry  in |- *; apply H
    | H:(?X1 = S (S ?X1)) |- _ => elim (n_SSn _ H)
    | H:(S (S ?X1) = ?X1) |- _ =>
        elim (n_SSn X1); symmetry  in |- *; apply H
    | H:(?X1 = S (S (S ?X1))) |- _ =>
        elim (n_SSSn _ H)
    | H:(S (S (S ?X1)) = ?X1) |- _ =>
        elim (n_SSSn X1); symmetry  in |- *; apply H
    | H:(In ?X3
           (freeVarFormula LNN
              (substituteFormula LNN
                 (substituteFormula LNN
                    (substituteFormula LNN betaFormula 1 _) 2 _) 0 _))) |- _
    =>
        decompose sum (In_betaFormula_subst_1_2_0 _ _ _ _ H); clear H
    | H:(In ?X3
           (freeVarFormula LNN
              (substituteFormula LNN (substituteFormula LNN betaFormula 1 _)
                 2 _))) |- _ =>
        decompose sum (In_betaFormula_subst_1_2 _ _ _ H); clear H
    | H:(In ?X3 (freeVarFormula LNN (substituteFormula LNN betaFormula 1 _)))
    |- _ =>
        decompose sum (In_betaFormula_subst_1 _ _ H); clear H
    | H:(In ?X3 (freeVarFormula LNN betaFormula)) |- _ =>
        decompose sum (In_betaFormula _ H); clear H
    | H:(In ?X3
           (freeVarFormula LNN
              (substituteFormula LNN (substituteFormula LNN betaFormula 2 _)
                 1 _))) |- _ =>
        decompose sum (In_betaFormula_subst_2_1 _ _ _ H); clear H
    | H:(In ?X3 (freeVarFormula LNN (substituteFormula LNN betaFormula 2 _)))
    |- _ =>
        decompose sum (In_betaFormula_subst_2 _ _ H);
         clear H
              | H:(In ?X3 (freeVarFormula LNN (fol.existH LNN ?X1 ?X2))) |- _ =>
        assert
         (In X3 (list_remove nat eq_nat_dec X1 (freeVarFormula LNN X2)));
         [ apply H | clear H ]
    | H:(In ?X3 (freeVarFormula LNN (fol.forallH LNN ?X1 ?X2))) |- _ =>
        assert
         (In X3 (list_remove nat eq_nat_dec X1 (freeVarFormula LNN X2)));
         [ apply H | clear H ]
    | 
        H:(In ?X3 (list_remove nat eq_nat_dec ?X1 (freeVarFormula LNN ?X2))) |- _
    =>
        assert (In X3 (freeVarFormula LNN X2));
         [ eapply In_list_remove1; apply H
         | assert (X3 <> X1); [ eapply In_list_remove2; apply H | clear H ] ]
    | H:(In ?X3 (freeVarFormula LNN (fol.andH LNN ?X1 ?X2))) |- _ =>
        assert (In X3 (freeVarFormula LNN X1 ++ freeVarFormula LNN X2));
         [ apply H | clear H ]
    | H:(In ?X3 (freeVarFormula LNN (fol.impH LNN ?X1 ?X2))) |- _ =>
        assert (In X3 (freeVarFormula LNN X1 ++ freeVarFormula LNN X2));
         [ apply H | clear H ]
    | H:(In ?X3 (freeVarFormula LNN (fol.notH LNN ?X1))) |- _ =>
        assert (In X3 (freeVarFormula LNN X1)); [ apply H | clear H ]
    | H:(In _ (freeVarFormula LNN (primRecPiFormulaHelp _ _ _))) |- _ =>
        decompose sum (freeVarPrimRecPiFormulaHelp1 _ _ _ _ H); clear H
    | J:(In ?X3 (freeVarFormula LNN A)),H:(forall v : nat,
                                           In v (freeVarFormula LNN A) ->
                                           v <= S n) |- _ =>
        elim (le_not_lt X3 (S n));
         [ apply H; apply J | clear J; repeat apply lt_n_Sn || apply lt_S ]
    | H:(In ?X3 (freeVarFormula LNN B)),H0:(forall v : nat,
                                            In v (freeVarFormula LNN B) ->
                                            v <= S (S (S n))) |- _ =>
        elim (le_not_lt X3 (S (S (S n))));
         [ apply H0; apply H | clear H; repeat apply lt_n_Sn || apply lt_S ]
    | H:(In _ (_ ++ _)) |- _ =>
        induction (in_app_or _ _ _ H); clear H
    | H:(In _ (freeVarFormula LNN (substituteFormula LNN ?X1 ?X2 ?X3))) |- _
    =>
        induction (freeVarSubFormula3 _ _ _ _ _ H); clear H
    | H:(In _ (freeVarFormula LNN (LT ?X1 ?X2))) |- _ =>
        rewrite freeVarLT in H
    | H:(In _ (freeVarTerm LNN (natToTerm _))) |- _ =>
        elim (closedNatToTerm _ _ H)
    | H:(In _ (freeVarTerm LNN Zero)) |- _ =>
        elim H
    | H:(In _ (freeVarTerm LNN (Succ _))) |- _ =>
        rewrite freeVarSucc in H
    | H:(In _ (freeVarTerm LNN (var _))) |- _ =>
        simpl in H; decompose sum H; clear H
    | H:(In _ (freeVarTerm LNN (fol.var LNN _))) |- _ =>
        simpl in H; decompose sum H; clear H
    end.

Remark primRecSigmaRepresentable :
 forall (n : nat) (A : Formula) (g : naryFunc n),
 Representable n g A ->
 forall (B : Formula) (h : naryFunc (S (S n))),
 Representable (S (S n)) h B ->
 Representable (S n) (evalPrimRecFunc n g h) (primRecSigmaFormula n A B).
Proof.
assert
 (forall (n : nat) (A : Formula) (g : naryFunc n),
  Representable n g A ->
  forall (B : Formula) (h : naryFunc (S (S n))),
  Representable (S (S n)) h B ->
  RepresentableHelp (S n) (evalPrimRecFunc n g h) (primRecSigmaFormula n A B)).
intro.
induction n as [| n Hrecn].
simpl in |- *; intros.
unfold primRecSigmaFormula in |- *.
rewrite (subFormulaExist LNN).
induction (In_dec eq_nat_dec 2 (freeVarTerm LNN (natToTerm a))).
elim (closedNatToTerm _ _ a0).
simpl in |- *.
clear b.
assert (repBeta : Representable 2 beta betaFormula).
apply betaRepresentable.
rewrite (subFormulaAnd LNN).
repeat rewrite (subFormulaId LNN).
apply
 iffTrans
  with
    (fol.existH LNN 2
       (fol.andH LNN
          (minimize
             (substituteFormula LNN (primRecSigmaFormulaHelp 0 A B) 1
                (natToTerm a))
             (substituteFormula LNN (primRecPiFormulaHelp 0 A B) 1
                (natToTerm a)) 2 4)
          (substituteFormula LNN betaFormula 1 (natToTerm a)))).
apply (reduceExist LNN).
apply closedNN.
apply (reduceAnd LNN).
apply subFormulaMinimize; first [ discriminate | apply closedNatToTerm ].
apply iffRefl.
set (f := evalPrimRecFunc 0 g h) in *.
induction (betaTheorem1 (S a) f).

Fixpoint primRecFormula (n : nat) (f : PrimRec n) {struct f} : Formula :=
  match f with
  | succFunc => succFormula
  | zeroFunc => zeroFormula
  | projFunc n m _ => projFormula m
  | composeFunc n m g h =>
      composeSigmaFormula n n m (primRecsFormula n m g) (primRecFormula m h)
  | primRecFunc n g h =>
      primRecSigmaFormula n (primRecFormula n g) (primRecFormula (S (S n)) h)
  end
 
 with primRecsFormula (n m : nat) (fs : PrimRecs n m) {struct fs} :
 Vector.t (Formula * naryFunc n) m :=
  match fs in (PrimRecs n m) return (Vector.t (Formula * naryFunc n) m) with
  | PRnil n => Vector.nil _
  | PRcons n m f fs' =>
      Vector.cons (Formula * naryFunc n) (primRecFormula n f, evalPrimRec n f) m
        (primRecsFormula n m fs')
  end.

Lemma primRecRepresentable1 :
 forall (n : nat) (f : PrimRec n),
 Representable n (evalPrimRec n f) (primRecFormula n f).

Lemma primRecRepresentable :
 forall (n : nat) (f : naryFunc n) (p : isPR n f),
 Representable n f (primRecFormula n (proj1_sig p)).

End Primative_Recursive_Representable. *)

Require Import expressible.
(* expressible:
Require Import Arith.
Require Import Coq.Lists.List.
Require Import ListExt.
Require Import folProp.
Require Import subProp.
Require Import extEqualNat.
Require Import LNN.

Section RepresentableExpressible.

Variable T : System.
Hypothesis closedT1: (ClosedSystem LNN T).

Lemma closedT : forall v : nat, ~ In_freeVarSys LNN v T.

Fixpoint RepresentableHalf1 (n : nat) : naryFunc n -> Formula -> Prop :=
  match n return (naryFunc n -> Formula -> Prop) with
  | O =>
      fun (f : naryFunc 0) (A : Formula) =>
      SysPrf T (impH A (equal (var 0) (natToTerm f)))
  | S m =>
      fun (f : naryFunc (S m)) (A : Formula) =>
      forall a : nat,
      RepresentableHalf1 m (f a)
        (substituteFormula LNN A (S m) (natToTerm a))
  end.

Fixpoint RepresentableHalf2 (n : nat) : naryFunc n -> Formula -> Prop :=
  match n return (naryFunc n -> Formula -> Prop) with
  | O =>
      fun (f : naryFunc 0) (A : Formula) =>
      SysPrf T (impH (equal (var 0) (natToTerm f)) A)
  | S m =>
      fun (f : naryFunc (S m)) (A : Formula) =>
      forall a : nat,
      RepresentableHalf2 m (f a)
        (substituteFormula LNN A (S m) (natToTerm a))
  end.

Lemma RepresentableHalf1Alternate :
 forall (n : nat) (f : naryFunc n) (A B : Formula),
 SysPrf T (impH A B) -> RepresentableHalf1 n f B -> RepresentableHalf1 n f A.

Lemma RepresentableHalf2Alternate :
 forall (n : nat) (f : naryFunc n) (A B : Formula),
 SysPrf T (impH A B) -> RepresentableHalf2 n f A -> RepresentableHalf2 n f B.

Fixpoint RepresentableHelp (n : nat) : naryFunc n -> Formula -> Prop :=
  match n return (naryFunc n -> Formula -> Prop) with
  | O =>
      fun (f : naryFunc 0) (A : Formula) =>
      SysPrf T (iffH A (equal (var 0) (natToTerm f)))
  | S m =>
      fun (f : naryFunc (S m)) (A : Formula) =>
      forall a : nat,
      RepresentableHelp m (f a) (substituteFormula LNN A (S m) (natToTerm a))
  end.

Lemma RepresentableHalfHelp :
 forall (n : nat) (f : naryFunc n) (A : Formula),
 RepresentableHalf1 n f A ->
 RepresentableHalf2 n f A -> RepresentableHelp n f A.

Definition Representable (n : nat) (f : naryFunc n) 
  (A : Formula) : Prop :=
  (forall v : nat, In v (freeVarFormula LNN A) -> v <= n) /\
  RepresentableHelp n f A.

Lemma RepresentableAlternate :
 forall (n : nat) (f : naryFunc n) (A B : Formula),
 SysPrf T (iffH A B) -> RepresentableHelp n f A -> RepresentableHelp n f B.

Lemma Representable_ext :
 forall (n : nat) (f g : naryFunc n) (A : Formula),
 extEqual n f g -> RepresentableHelp n f A -> RepresentableHelp n g A.

Fixpoint ExpressibleHelp (n : nat) : naryRel n -> Formula -> Prop :=
  match n return (naryRel n -> Formula -> Prop) with
  | O =>
      fun (R : naryRel 0) (A : Formula) =>
      match R with
      | true => SysPrf T A
      | false => SysPrf T (notH A)
      end
  | S m =>
      fun (R : naryRel (S m)) (A : Formula) =>
      forall a : nat,
      ExpressibleHelp m (R a) (substituteFormula LNN A (S m) (natToTerm a))
  end.

Definition Expressible (n : nat) (R : naryRel n) (A : Formula) : Prop :=
  (forall v : nat, In v (freeVarFormula LNN A) -> v <= n /\ v <> 0) /\
  ExpressibleHelp n R A.

Lemma expressibleAlternate :
 forall (n : nat) (R : naryRel n) (A B : Formula),
 SysPrf T (iffH A B) -> ExpressibleHelp n R A -> ExpressibleHelp n R B.

Hypothesis nn1:(SysPrf T (notH (equal (natToTerm 1) (natToTerm 0)))).

Lemma Representable2Expressible :
 forall (n : nat) (R : naryRel n) (A : Formula),
 Representable n (charFunction n R) A ->
 Expressible n R (substituteFormula LNN A 0 (natToTerm 1)).

End RepresentableExpressible. *)

Require Import checkPrf.
(* checkPrf:
Require Import primRec.
Require Import codeFreeVar.
Require Import codeSubFormula.
Require Import cPair.
Require Import Arith.
Require Import code.
Require Import folProp.
Require Import extEqualNat.
Require Import wellFormed.
Require Import folProof.
Require Import prLogic.

Section Check_Proof.

Variable L : Language.
Variable codeF : Functions L -> nat.
Variable codeR : Relations L -> nat.
Variable codeArityF : nat -> nat.
Variable codeArityR : nat -> nat.
Hypothesis codeArityFIsPR : isPR 1 codeArityF.
Hypothesis
  codeArityFIsCorrect1 :
    forall f : Functions L, codeArityF (codeF f) = S (arity L (inr _ f)).
Hypothesis
  codeArityFIsCorrect2 :
    forall n : nat, codeArityF n <> 0 -> exists f : Functions L, codeF f = n.
Hypothesis codeArityRIsPR : isPR 1 codeArityR.
Hypothesis
  codeArityRIsCorrect1 :
    forall r : Relations L, codeArityR (codeR r) = S (arity L (inl _ r)).
Hypothesis
  codeArityRIsCorrect2 :
    forall n : nat, codeArityR n <> 0 -> exists r : Relations L, codeR r = n.

Hypothesis codeFInj : forall f g : Functions L, codeF f = codeF g -> f = g.
Hypothesis codeRInj : forall R S : Relations L, codeR R = codeR S -> R = S.

Let Term := Term L.
Let Terms := Terms L.
Let var := var L.
Let apply := apply L.
Let Formula := Formula L.
Let equal := equal L.
Let atomic := atomic L.
Let impH := impH L.
Let notH := notH L.
Let forallH := forallH L.
Let wellFormedTerm := wellFormedTerm codeArityF.
Let wellFormedFormula := wellFormedFormula codeArityF codeArityR.
Let Prf := Prf L.

Definition checkPrfAXM (p recs : nat) :=
  switchPR (charFunction 2 beq_nat (cPairPi2 (cPairPi2 p)) (cPairPi1 p))
    (S (S (cPair (cPairPi1 p) 0))) 0.

Lemma checkPrfAXMIsPR : isPR 2 checkPrfAXM.

Definition checkPrfMP (p recs : nat) :=
  switchPR
    (wellFormedFormula (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p)))) *
     (charFunction 2 beq_nat (cPairPi1 (cPairPi1 (cPairPi2 (cPairPi2 p))))
        (codeImp (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p)))) (cPairPi1 p)) *
      (codeNth (p - S (cPairPi1 (cPairPi2 (cPairPi2 p)))) recs *
       codeNth (p - S (cPairPi2 (cPairPi2 (cPairPi2 p)))) recs)))
    (S
       (codeApp
          (pred (codeNth (p - S (cPairPi1 (cPairPi2 (cPairPi2 p)))) recs))
          (pred (codeNth (p - S (cPairPi2 (cPairPi2 (cPairPi2 p)))) recs))))
    0.

Lemma checkPrfMPIsPR : isPR 2 checkPrfMP.

Definition checkPrfGEN (p recs : nat) :=
  switchPR
    (charFunction 2 beq_nat
       (cPair 3
          (cPair (cPairPi1 (cPairPi2 (cPairPi2 p)))
             (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p)))))) 
       (cPairPi1 p) *
     (codeNth (p - S (cPairPi2 (cPairPi2 (cPairPi2 p)))) recs *
      (1 -
       codeIn (cPairPi1 (cPairPi2 (cPairPi2 p)))
         (codeFreeVarListFormula
            (pred (codeNth (p - S (cPairPi2 (cPairPi2 (cPairPi2 p)))) recs))))))
    (codeNth (p - S (cPairPi2 (cPairPi2 (cPairPi2 p)))) recs) 0.

Lemma checkPrfGENIsPR : isPR 2 checkPrfGEN.

Definition checkPrfIMP1 (p recs : nat) :=
  let A := cPairPi1 (cPairPi2 (cPairPi2 p)) in
  let B := cPairPi2 (cPairPi2 (cPairPi2 p)) in
  charFunction 2 beq_nat (cPair 1 (cPair A (cPair 1 (cPair B A))))
    (cPairPi1 p).

Lemma checkPrfIMP1IsPR : isPR 2 checkPrfIMP1.

Definition checkPrfIMP2 (p recs : nat) :=
  let A := cPairPi1 (cPairPi2 (cPairPi2 p)) in
  let B := cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p))) in
  let C := cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p))) in
  charFunction 2 beq_nat
    (cPair 1
       (cPair (cPair 1 (cPair A (cPair 1 (cPair B C))))
          (cPair 1 (cPair (cPair 1 (cPair A B)) (cPair 1 (cPair A C))))))
    (cPairPi1 p).

Lemma checkPrfIMP2IsPR : isPR 2 checkPrfIMP2.

Definition checkPrfCP (p recs : nat) :=
  let A := cPairPi1 (cPairPi2 (cPairPi2 p)) in
  let B := cPairPi2 (cPairPi2 (cPairPi2 p)) in
  charFunction 2 beq_nat
    (cPair 1
       (cPair (cPair 1 (cPair (cPair 2 A) (cPair 2 B))) (cPair 1 (cPair B A))))
    (cPairPi1 p).

Lemma checkPrfCPIsPR : isPR 2 checkPrfCP.

Definition checkPrfFA1 (p recs : nat) :=
  let A := cPairPi1 (cPairPi2 (cPairPi2 p)) in
  let v := cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p))) in
  let t := cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p))) in
  wellFormedTerm t *
  charFunction 2 beq_nat
    (cPair 1 (cPair (cPair 3 (cPair v A)) (codeSubFormula A v t)))
    (cPairPi1 p).

Lemma checkPrfFA1IsPR : isPR 2 checkPrfFA1.

Definition checkPrfFA2 (p recs : nat) :=
  let A := cPairPi1 (cPairPi2 (cPairPi2 p)) in
  let v := cPairPi2 (cPairPi2 (cPairPi2 p)) in
  (1 - codeIn v (codeFreeVarFormula A)) *
  charFunction 2 beq_nat (cPair 1 (cPair A (cPair 3 (cPair v A))))
    (cPairPi1 p).

Lemma checkPrfFA2IsPR : isPR 2 checkPrfFA2.

Definition checkPrfFA3 (p recs : nat) :=
  let A := cPairPi1 (cPairPi2 (cPairPi2 p)) in
  let B := cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p))) in
  let v := cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p))) in
  charFunction 2 beq_nat
    (cPair 1
       (cPair (cPair 3 (cPair v (cPair 1 (cPair A B))))
          (cPair 1 (cPair (cPair 3 (cPair v A)) (cPair 3 (cPair v B))))))
    (cPairPi1 p).

Lemma checkPrfFA3IsPR : isPR 2 checkPrfFA3.

Definition checkPrfEQ1 (p recs : nat) :=
  charFunction 2 beq_nat (cPairPi2 (cPairPi2 p)) 0 *
  charFunction 2 beq_nat
    (codeFormula L codeF codeR (fol.equal L (fol.var L 0) (fol.var L 0)))
    (cPairPi1 p).

Lemma checkPrfEQnIsPR :
 forall n : nat,
 isPR 2
   (fun p recs : nat =>
    charFunction 2 beq_nat (cPairPi2 (cPairPi2 p)) 0 *
    charFunction 2 beq_nat n (cPairPi1 p)).

Lemma checkPrfEQ1IsPR : isPR 2 checkPrfEQ1.

Definition checkPrfEQ2 (p recs : nat) :=
  charFunction 2 beq_nat (cPairPi2 (cPairPi2 p)) 0 *
  charFunction 2 beq_nat
    (codeFormula L codeF codeR
       (fol.impH L (fol.equal L (fol.var L 0) (fol.var L 1))
          (fol.equal L (fol.var L 1) (fol.var L 0)))) 
    (cPairPi1 p).

Lemma checkPrfEQ2IsPR : isPR 2 checkPrfEQ2.

Definition checkPrfEQ3 (p recs : nat) :=
  charFunction 2 beq_nat (cPairPi2 (cPairPi2 p)) 0 *
  charFunction 2 beq_nat
    (codeFormula L codeF codeR
       (fol.impH L (fol.equal L (fol.var L 0) (fol.var L 1))
          (fol.impH L (fol.equal L (fol.var L 1) (fol.var L 2))
             (fol.equal L (fol.var L 0) (fol.var L 2))))) 
    (cPairPi1 p).

Lemma checkPrfEQ3IsPR : isPR 2 checkPrfEQ3.

Definition codeAxmEqHelp (n f : nat) : nat :=
  nat_rec (fun _ => nat) f
    (fun m rec : nat =>
     cPair 1
       (cPair (cPair 0 (cPair (cPair 0 (m + m)) (cPair 0 (S (m + m))))) rec))
    n.

Lemma codeAxmEqHelpIsPR : isPR 2 codeAxmEqHelp.

Definition codeNVars1 (n : nat) : nat :=
  nat_rec (fun _ => nat) 0
    (fun m rec : nat => S (cPair (cPair 0 (m + m)) rec)) n.

Lemma codeNVars1IsPR : isPR 1 codeNVars1.

Definition codeNVars2 (n : nat) : nat :=
  nat_rec (fun _ => nat) 0
    (fun m rec : nat => S (cPair (cPair 0 (S (m + m))) rec)) n.

Lemma codeNVars2IsPR : isPR 1 codeNVars2.

Lemma codeNVarsCorrect :
 forall n : nat,
 codeNVars1 n = codeTerms L codeF n (fst (nVars L n)) /\
 codeNVars2 n = codeTerms L codeF n (snd (nVars L n)).

Definition checkPrfEQ4 (p recs : nat) :=
  let r := cPairPi2 (cPairPi2 p) in
  let A := cPair (S (S (S (S r)))) (codeNVars1 (pred (codeArityR r))) in
  let B := cPair (S (S (S (S r)))) (codeNVars2 (pred (codeArityR r))) in
  notZero (codeArityR r) *
  charFunction 2 beq_nat (codeAxmEqHelp (pred (codeArityR r)) (codeIff A B))
    (cPairPi1 p).

Lemma codeOrIsPR : isPR 2 codeOr.

Lemma codeAndIsPR : isPR 2 codeAnd.

Lemma codeIffIsPR : isPR 2 codeIff.

Lemma checkPrfEQ4IsPR : isPR 2 checkPrfEQ4.

Definition checkPrfEQ5 (p recs : nat) :=
  let f := cPairPi2 (cPairPi2 p) in
  notZero (codeArityF f) *
  charFunction 2 beq_nat
    (codeAxmEqHelp (pred (codeArityF f))
       (cPair 0
          (cPair (cPair (S f) (codeNVars1 (pred (codeArityF f))))
             (cPair (S f) (codeNVars2 (pred (codeArityF f))))))) 
    (cPairPi1 p).

Lemma checkPrfEQ5IsPR : isPR 2 checkPrfEQ5.

Definition checkPrfHelp : nat -> nat :=
  evalStrongRec 0
    (fun p recs : nat =>
     let type := cPairPi1 (cPairPi2 p) in
     switchPR type
       (switchPR (pred type)
          (switchPR (pred (pred type))
             (switchPR (pred (pred (pred type)))
                (switchPR (pred (pred (pred (pred type))))
                   (switchPR (pred (pred (pred (pred (pred type)))))
                      (switchPR
                         (pred (pred (pred (pred (pred (pred type))))))
                         (switchPR
                            (pred
                               (pred (pred (pred (pred (pred (pred type)))))))
                            (switchPR
                               (pred
                                  (pred
                                     (pred
                                        (pred
                                           (pred (pred (pred (pred type))))))))
                               (switchPR
                                  (pred
                                     (pred
                                        (pred
                                           (pred
                                              (pred
                                                 (pred
                                                  (pred (pred (pred type)))))))))
                                  (switchPR
                                     (pred
                                        (pred
                                           (pred
                                              (pred
                                                 (pred
                                                  (pred
                                                  (pred
                                                  (pred (pred (pred type))))))))))
                                     (switchPR
                                        (pred
                                           (pred
                                              (pred
                                                 (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred (pred (pred type)))))))))))
                                        (switchPR
                                           (pred
                                              (pred
                                                 (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred (pred (pred type))))))))))))
                                           (switchPR
                                              (pred
                                                 (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred (pred (pred type)))))))))))))
                                              0 (checkPrfEQ5 p recs))
                                           (checkPrfEQ4 p recs))
                                        (checkPrfEQ3 p recs))
                                     (checkPrfEQ2 p recs))
                                  (checkPrfEQ1 p recs)) 
                               (checkPrfFA3 p recs)) 
                            (checkPrfFA2 p recs)) (checkPrfFA1 p recs))
                      (checkPrfCP p recs)) (checkPrfIMP2 p recs))
                (checkPrfIMP1 p recs)) (checkPrfGEN p recs))
          (checkPrfMP p recs)) (checkPrfAXM p recs)).

Lemma checkPrfHelpIsPR : isPR 1 checkPrfHelp.

Definition checkPrf (f p : nat) : nat :=
  switchPR (wellFormedFormula f) (checkPrfHelp (cPair f p)) 0.

Lemma checkPrfIsPR : isPR 2 checkPrf.

Lemma checkPrfCorrect1 :
 forall (l : list Formula) (f : Formula) (p : Prf l f),
 checkPrf (codeFormula L codeF codeR f) (codePrf L codeF codeR l f p) =
 S (codeList (map (codeFormula L codeF codeR) l)).

Lemma checkPrfCorrect2 :
 forall n m : nat,
 checkPrf n m <> 0 ->
 exists f : Formula,
   codeFormula L codeF codeR f = n /\
   (exists l : list Formula,
      (exists p : Prf l f, codePrf L codeF codeR l f p = m)).
Proof.
assert (multLemma1 : forall a b : nat, a * b <> 0 -> a <> 0).
unfold not in |- *; intros.
apply H.
rewrite H0.
simpl in |- *.
reflexivity.
assert (multLemma2 : forall a b : nat, a * b <> 0 -> b <> 0).
intros.
rewrite mult_comm in H.
eapply multLemma1.
apply H.
assert
 (forall m n : nat,
  n < m ->
  checkPrf (cPairPi1 n) (cPairPi2 n) <> 0 ->
  exists f : Formula,
    (exists l : list Formula,
       (exists p : Prf l f,
          cPair (codeFormula L codeF codeR f) (codePrf L codeF codeR l f p) =
          n))).
intro.
induction m as [| m Hrecm].
intros.
elim (lt_n_O _ H).
intros.
induction (le_lt_or_eq _ _ (lt_n_Sm_le _ _ H)).
apply Hrecm; assumption.
unfold checkPrf in H0.
assert (wellFormedFormula (cPairPi1 n) <> 0).
destruct (wellFormedFormula (cPairPi1 n)).
assumption.
discriminate.
induction
 (wellFormedFormulaCorrect2 L codeF codeArityF codeArityFIsCorrect1
    codeArityFIsCorrect2 codeR codeArityR codeArityRIsCorrect1
    codeArityRIsCorrect2 _ H2).
exists x.
destruct (wellFormedFormula (cPairPi1 n)).
elim H2.
auto.
simpl in H0.
clear H2.
unfold checkPrfHelp in H0.
set
 (A :=
  fun p recs : nat =>
  switchPR (cPairPi1 (cPairPi2 p))
    (switchPR (pred (cPairPi1 (cPairPi2 p)))
       (switchPR (pred (pred (cPairPi1 (cPairPi2 p))))
          (switchPR (pred (pred (pred (cPairPi1 (cPairPi2 p)))))
             (switchPR (pred (pred (pred (pred (cPairPi1 (cPairPi2 p))))))
                (switchPR
                   (pred (pred (pred (pred (pred (cPairPi1 (cPairPi2 p)))))))
                   (switchPR
                      (pred
                         (pred
                            (pred
                               (pred (pred (pred (cPairPi1 (cPairPi2 p))))))))
                      (switchPR
                         (pred
                            (pred
                               (pred
                                  (pred
                                     (pred
                                        (pred (pred (cPairPi1 (cPairPi2 p)))))))))
                         (switchPR
                            (pred
                               (pred
                                  (pred
                                     (pred
                                        (pred
                                           (pred
                                              (pred
                                                 (pred
                                                  (cPairPi1 (cPairPi2 p))))))))))
                            (switchPR
                               (pred
                                  (pred
                                     (pred
                                        (pred
                                           (pred
                                              (pred
                                                 (pred
                                                  (pred
                                                  (pred
                                                  (cPairPi1 (cPairPi2 p)))))))))))
                               (switchPR
                                  (pred
                                     (pred
                                        (pred
                                           (pred
                                              (pred
                                                 (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (cPairPi1 (cPairPi2 p))))))))))))
                                  (switchPR
                                     (pred
                                        (pred
                                           (pred
                                              (pred
                                                 (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (cPairPi1 (cPairPi2 p)))))))))))))
                                     (switchPR
                                        (pred
                                           (pred
                                              (pred
                                                 (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (cPairPi1 (cPairPi2 p))))))))))))))
                                        (switchPR
                                           (pred
                                              (pred
                                                 (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (pred
                                                  (cPairPi1 (cPairPi2 p)))))))))))))))
                                           0 (checkPrfEQ5 p recs))
                                        (checkPrfEQ4 p recs))
                                     (checkPrfEQ3 p recs))
                                  (checkPrfEQ2 p recs)) 
                               (checkPrfEQ1 p recs)) 
                            (checkPrfFA3 p recs)) (checkPrfFA2 p recs))
                      (checkPrfFA1 p recs)) (checkPrfCP p recs))
                (checkPrfIMP2 p recs)) (checkPrfIMP1 p recs))
          (checkPrfGEN p recs)) (checkPrfMP p recs)) 
    (checkPrfAXM p recs)) in *.
unfold evalStrongRec, evalComposeFunc, evalOneParamList, evalList in H0;
 rewrite computeEvalStrongRecHelp in H0;
 unfold compose2, evalComposeFunc, evalOneParamList, evalList in H0;
 simpl in H0.
rewrite cPairProjections1 in H0.
assert (cPair (cPairPi1 (cPairPi2 n)) (cPairPi2 (cPairPi2 n)) = cPairPi2 n).
apply cPairProjections.
unfold A at 1 in H0.
repeat first
 [ rewrite cPairProjections1 in H0 | rewrite cPairProjections2 in H0 ].
destruct (cPairPi1 (cPairPi2 n)).
simpl in H0.
unfold checkPrfAXM in H0.
repeat first
 [ rewrite cPairProjections1 in H0 | rewrite cPairProjections2 in H0 ].
rewrite <- H3 in H0.
induction (eq_nat_dec (cPairPi2 (cPairPi2 n)) (codeFormula L codeF codeR x)).
exists (x :: nil).
exists (AXM L x).
rewrite H3.
simpl in |- *.
rewrite a in H2.
rewrite H2.
apply cPairProjections.
elim H0.
unfold charFunction in |- *.
rewrite beq_nat_not_refl.
reflexivity.
assumption.
destruct n1.
simpl in H0.
unfold checkPrfMP in H0.
repeat first
 [ rewrite cPairProjections1 in H0 | rewrite cPairProjections2 in H0 ].
assert (cPairPi2 (cPairPi2 n) < n).
apply lt_le_trans with (cPair 1 (cPairPi2 (cPairPi2 n)));
 [ idtac | rewrite H2; apply cPairLe2A ].
apply cPairLt2.
assert (cPairPi1 (cPairPi2 (cPairPi2 n)) < n).
apply le_lt_trans with (cPairPi2 (cPairPi2 n)).
apply cPairLe1A.
assumption.
assert (cPairPi2 (cPairPi2 (cPairPi2 n)) < n).
apply le_lt_trans with (cPairPi2 (cPairPi2 n)).
apply cPairLe2A.
assumption.
rewrite evalStrongRecHelp1 in H0.
rewrite evalStrongRecHelp1 in H0.
assert (wellFormedFormula (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 n)))) <> 0).
unfold not in |- *; intros.
apply H0.
rewrite H7.
reflexivity.
induction
 (eq_nat_dec (cPairPi1 (cPairPi1 (cPairPi2 (cPairPi2 n))))
    (codeImp (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 n)))) (cPairPi1 n))).
induction
 (wellFormedFormulaCorrect2 L codeF codeArityF codeArityFIsCorrect1
    codeArityFIsCorrect2 codeR codeArityR codeArityRIsCorrect1
    codeArityRIsCorrect2 _ H7).
assert
 (checkPrf (cPairPi1 (cPairPi1 (cPairPi2 (cPairPi2 n))))
    (cPairPi2 (cPairPi1 (cPairPi2 (cPairPi2 n)))) <> 0).
unfold checkPrf in |- *.
rewrite a.
rewrite <- H3.
rewrite <- H8.
rewrite codeImpCorrect.
rewrite
 (wellFormedFormulaCorrect1 L codeF codeArityF codeArityFIsCorrect1 codeR
    codeArityR codeArityRIsCorrect1).
simpl in |- *.
unfold checkPrfHelp in |- *.
fold A in |- *.
rewrite H8.
rewrite H3.
replace
 (cPair 1 (cPair (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 n)))) (cPairPi1 n)))
 with (cPairPi1 (cPairPi1 (cPairPi2 (cPairPi2 n)))).
rewrite cPairProjections.
destruct (evalStrongRec 0 A (cPairPi1 (cPairPi2 (cPairPi2 n)))).
rewrite mult_comm in H0.
rewrite
 (mult_comm
    (charFunction 2 beq_nat (cPairPi1 (cPairPi1 (cPairPi2 (cPairPi2 n))))
       (codeImp (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 n)))) (cPairPi1 n))))
  in H0.
simpl in H0.
assumption.
discriminate.
assert
 (checkPrf (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 n))))
    (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 n)))) <> 0).
unfold checkPrf in |- *.
rewrite <- H8.
rewrite
 (wellFormedFormulaCorrect1 L codeF codeArityF codeArityFIsCorrect1 codeR
    codeArityR codeArityRIsCorrect1).
simpl in |- *.
unfold checkPrfHelp in |- *.
fold A in |- *.
rewrite H8.
rewrite cPairProjections.
destruct (evalStrongRec 0 A (cPairPi2 (cPairPi2 (cPairPi2 n)))).
rewrite mult_comm in H0.
rewrite
 (mult_comm
    (charFunction 2 beq_nat (cPairPi1 (cPairPi1 (cPairPi2 (cPairPi2 n))))
       (codeImp (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 n)))) (cPairPi1 n))))
  in H0.
rewrite (mult_comm (evalStrongRec 0 A (cPairPi1 (cPairPi2 (cPairPi2 n)))))
  in H0.
simpl in H0.
assumption.
discriminate.
assert (cPairPi1 (cPairPi2 (cPairPi2 n)) < m).
apply lt_le_trans with n.
assumption.
rewrite H1.
apply le_n.
assert (cPairPi2 (cPairPi2 (cPairPi2 n)) < m).
apply lt_le_trans with n.
assumption.
rewrite H1.
apply le_n.
induction (Hrecm _ H11 H9).
induction (Hrecm _ H12 H10).
induction H13 as (x3, H13).
induction H13 as (x4, H13).
induction H14 as (x5, H14).
induction H14 as (x6, H14).
exists (x3 ++ x5).
rewrite <- H13 in a.
rewrite <- H14 in a.
repeat rewrite cPairProjections1 in a.
rewrite <- H3 in a.
rewrite codeImpCorrect in a.
assert (x1 = impH x2 x).
apply (codeFormulaInj L codeF codeR codeFInj codeRInj).
assumption.
intros.
cut
 (cPair (codeFormula L codeF codeR x1) (codePrf L codeF codeR x3 x1 x4) =
  cPairPi1 (cPairPi2 (cPairPi2 n))).
generalize x4.
clear H13 x4.
rewrite H15.
intros.
exists (MP L x3 x5 x2 x x4 x6).
rewrite <- (cPairProjections n).
rewrite H3.
simpl in |- *.
rewrite <- H2.
replace
 (cPair 1
    (cPair (codeFormula L codeF codeR x2) (codeFormula L codeF codeR x)))
 with (codeFormula L codeF codeR x1).
rewrite H14.
fold impH in |- *.
rewrite H15.
rewrite H13.
rewrite cPairProjections.
reflexivity.
assumption.
unfold charFunction in H0.
rewrite beq_nat_not_refl in H0.
rewrite mult_comm in H0.
simpl in H0.
elim H0.
reflexivity.
assumption.
rewrite cPairProjections.
assumption.
rewrite cPairProjections.
assumption.
destruct n1.
simpl in H0.
unfold checkPrfGEN in H0.
repeat first
 [ rewrite cPairProjections1 in H0 | rewrite cPairProjections2 in H0 ].
assert (cPairPi2 (cPairPi2 (cPairPi2 n)) < n).
eapply le_lt_trans.
apply cPairLe2A.
apply lt_le_trans with (cPair 2 (cPairPi2 (cPairPi2 n)));
 [ idtac | rewrite H2; apply cPairLe2A ].
apply cPairLt2.
rewrite evalStrongRecHelp1 in H0.
induction
 (eq_nat_dec
    (cPair 3
       (cPair (cPairPi1 (cPairPi2 (cPairPi2 n)))
          (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 n)))))) 
    (cPairPi1 n)).
rewrite <- a in H3.
destruct x as [t t0| r t| f f0| f| n1 f]; simpl in H3;
 try
  match goal with
  | H:(cPair ?X1 _ = cPair ?X2 _) |- _ =>
      cut (X1 = X2); [ intro I; discriminate I | eapply cPairInj1; apply H ]
  end.
assert (n1 = cPairPi1 (cPairPi2 (cPairPi2 n))).
eapply cPairInj1.
eapply cPairInj2.
apply H3.
assert
 (codeFormula L codeF codeR f = cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 n)))).
eapply cPairInj2.
eapply cPairInj2.
apply H3.
assert
 (checkPrf (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 n))))
    (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 n)))) <> 0).
unfold checkPrf in |- *.
rewrite <- H6.
rewrite
 (wellFormedFormulaCorrect1 L codeF codeArityF codeArityFIsCorrect1 codeR
    codeArityR codeArityRIsCorrect1).
simpl in |- *.
unfold checkPrfHelp in |- *.
fold A in |- *.
rewrite H6.
rewrite cPairProjections.
destruct (evalStrongRec 0 A (cPairPi2 (cPairPi2 (cPairPi2 n)))).
rewrite mult_comm in H0.
simpl in H0.
assumption.
discriminate.
assert (cPairPi2 (cPairPi2 (cPairPi2 n)) < m).
apply lt_le_trans with n.
assumption.
rewrite H1.
apply le_n.
induction (Hrecm _ H8 H7).
induction H9 as (x0, H9).
induction H9 as (x1, H9).
exists x0.
rewrite <- H5 in H0.
rewrite <- H9 in H0.
assert
 (checkPrf (codeFormula L codeF codeR x) (codePrf L codeF codeR x0 x x1) =
  S (codeList (map (codeFormula L codeF codeR) x0))).
apply checkPrfCorrect1.
unfold checkPrf in H10.
rewrite
 (wellFormedFormulaCorrect1 L codeF codeArityF codeArityFIsCorrect1 codeR
    codeArityR codeArityRIsCorrect1) in H10.
simpl in H10.
unfold checkPrfHelp in H10.
fold A in H10.
rewrite H10 in H0.
unfold pred in H0.
rewrite codeFreeVarListFormulaCorrect in H0.
rewrite codeInCorrect in H0.
induction (In_dec eq_nat_dec n1 (freeVarListFormula L x0)).
rewrite (mult_comm (S (codeList (map (codeFormula L codeF codeR) x0)))) in H0.
rewrite mult_comm in H0.
simpl in H0.
elim H0; reflexivity.
rewrite <- H9 in H6.
rewrite cPairProjections1 in H6.
cut
 (cPair (codeFormula L codeF codeR x) (codePrf L codeF codeR x0 x x1) =
  cPairPi2 (cPairPi2 (cPairPi2 n))).
generalize x1.
clear H10 H0 x1 H9.
replace x with f.
intros.
exists (GEN L x0 f n1 b x1).
simpl in |- *.
rewrite H3.
rewrite a.
rewrite H0.
rewrite H5.
rewrite cPairProjections.
rewrite H2.
apply cPairProjections.
apply (codeFormulaInj L codeF codeR codeFInj codeRInj).
assumption.
assumption.
unfold charFunction in H0.
rewrite beq_nat_not_refl in H0.
elim H0.
simpl in |- *.
reflexivity.
assumption.
rewrite cPairProjections.
assumption.
destruct n1.
simpl in H0.
unfold checkPrfIMP1 in H0.
repeat first
 [ rewrite cPairProjections1 in H0 | rewrite cPairProjections2 in H0 ].
exists (nil (A:=Formula)).
rewrite <- H3 in H0.
induction
 (eq_nat_dec
    (cPair 1
       (cPair (cPairPi1 (cPairPi2 (cPairPi2 n)))
          (cPair 1
             (cPair (cPairPi2 (cPairPi2 (cPairPi2 n)))
                (cPairPi1 (cPairPi2 (cPairPi2 n)))))))
    (codeFormula L codeF codeR x)).
destruct x as [t t0| r t| f f0| f| n1 f]; simpl in a;
 try
  match goal with
  | H:(cPair ?X1 _ = cPair ?X2 _) |- _ =>
      cut (X1 = X2); [ intro I; discriminate I | eapply cPairInj1; apply H ]
  end.
assert (cPairPi1 (cPairPi2 (cPairPi2 n)) = codeFormula L codeF codeR f).
eapply cPairInj1.
eapply cPairInj2.
apply a.
assert
 (cPair 1
    (cPair (cPairPi2 (cPairPi2 (cPairPi2 n)))
       (cPairPi1 (cPairPi2 (cPairPi2 n)))) = codeFormula L codeF codeR f0).
eapply cPairInj2.
eapply cPairInj2.
apply a.
clear a.
destruct f0 as [t t0| r t| f0 f1| f0| n1 f0]; simpl in H5;
 try
  match goal with
  | H:(cPair ?X1 _ = cPair ?X2 _) |- _ =>
      cut (X1 = X2); [ intro I; discriminate I | eapply cPairInj1; apply H ]
  end.
assert (cPairPi2 (cPairPi2 (cPairPi2 n)) = codeFormula L codeF codeR f0).
eapply cPairInj1.
eapply cPairInj2.
apply H5.
assert (cPairPi1 (cPairPi2 (cPairPi2 n)) = codeFormula L codeF codeR f1).
eapply cPairInj2.
eapply cPairInj2.
apply H5.
assert (f1 = f).
apply (codeFormulaInj L codeF codeR codeFInj codeRInj).
transitivity (cPairPi1 (cPairPi2 (cPairPi2 n))).
symmetry  in |- *.
assumption.
assumption.
rewrite H8.
rewrite H8 in H3.
exists (IMP1 L f f0).
rewrite H3.
simpl in |- *.
rewrite <- H4.
rewrite <- H6.
rewrite cPairProjections.
rewrite H2.
apply cPairProjections.
elim H0.
unfold charFunction in |- *.
rewrite beq_nat_not_refl.
reflexivity.
assumption.
destruct n1.
simpl in H0.
unfold checkPrfIMP2 in H0.
repeat first
 [ rewrite cPairProjections1 in H0 | rewrite cPairProjections2 in H0 ].
exists (nil (A:=Formula)).
clear A.
rewrite <- H3 in H0.
rename x into f.
induction
 (eq_nat_dec
    (cPair 1
       (cPair
          (cPair 1
             (cPair (cPairPi1 (cPairPi2 (cPairPi2 n)))
                (cPair 1
                   (cPair (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 n))))
                      (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 n))))))))
          (cPair 1
             (cPair
                (cPair 1
                   (cPair (cPairPi1 (cPairPi2 (cPairPi2 n)))
                      (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 n))))))
                (cPair 1
                   (cPair (cPairPi1 (cPairPi2 (cPairPi2 n)))
                      (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 n))))))))))
    (codeFormula L codeF codeR f)).
repeat
 match goal with
 | H:(cPair ?X1 (cPair ?X2 ?X3) = cPair ?X1 (cPair ?X4 ?X5)) |- _ =>
     assert (X2 = X4);
      [ eapply cPairInj1; eapply cPairInj2; apply H
      | assert (X3 = X5);
         [ eapply cPairInj2; eapply cPairInj2; apply H | clear H ] ]
 | H:(cPair ?X1 (cPair _ _) = codeFormula L codeF codeR ?X2) |- _ =>
      destruct X2;
      simpl in H;
      try
       match goal with
       | J:(cPair ?X1 _ = cPair ?X2 _) |- _ =>
           cut (X1 = X2);
            [ intro I; discriminate I | eapply cPairInj1; apply J ]
       end
 end.
rewrite H3.
replace f2_2_1 with f1_1.
replace f1_2_2 with f2_2_2.
replace f1_2_1 with f2_1_2.
replace f2_1_1 with f1_1.
exists (IMP2 L f1_1 f2_1_2 f2_2_2).
simpl in |- *.
rewrite <- H9.
rewrite <- H8.
rewrite cPairProjections.
rewrite <- H6.
rewrite cPairProjections.
rewrite H2.
apply cPairProjections.
apply (codeFormulaInj L codeF codeR codeFInj codeRInj).
transitivity (cPairPi1 (cPairPi2 (cPairPi2 n)));
 [ symmetry  in |- *; assumption | assumption ].
apply (codeFormulaInj L codeF codeR codeFInj codeRInj).
transitivity (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 n))));
 [ symmetry  in |- *; assumption | assumption ].
apply (codeFormulaInj L codeF codeR codeFInj codeRInj).
transitivity (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 n))));
 [ symmetry  in |- *; assumption | assumption ].
apply (codeFormulaInj L codeF codeR codeFInj codeRInj).
transitivity (cPairPi1 (cPairPi2 (cPairPi2 n)));
 [ symmetry  in |- *; assumption | assumption ].
elim H0.
unfold charFunction in |- *.
rewrite beq_nat_not_refl.
reflexivity.
assumption.
destruct n1.
simpl in H0.
unfold checkPrfCP in H0.
clear A.
repeat first
 [ rewrite cPairProjections1 in H0 | rewrite cPairProjections2 in H0 ].
exists (nil (A:=Formula)).
rewrite <- H3 in H0.
rename x into f.
induction
 (eq_nat_dec
    (cPair 1
       (cPair
          (cPair 1
             (cPair (cPair 2 (cPairPi1 (cPairPi2 (cPairPi2 n))))
                (cPair 2 (cPairPi2 (cPairPi2 (cPairPi2 n))))))
          (cPair 1
             (cPair (cPairPi2 (cPairPi2 (cPairPi2 n)))
                (cPairPi1 (cPairPi2 (cPairPi2 n)))))))
    (codeFormula L codeF codeR f)).
repeat
 match goal with
 | H:(cPair 1 (cPair ?X2 ?X3) = cPair 1 (cPair ?X4 ?X5)) |- _ =>
     assert (X2 = X4);
      [ eapply cPairInj1; eapply cPairInj2; apply H
      | assert (X3 = X5);
         [ eapply cPairInj2; eapply cPairInj2; apply H | clear H ] ]
 | H:(cPair 2 ?X2 = cPair 2 ?X4) |- _ =>
     assert (X2 = X4); [ eapply cPairInj2; apply H | clear H ]
 | H:(cPair ?X1 _ = codeFormula L codeF codeR ?X2) |- _ =>
      destruct X2;
      simpl in H;
      try
       match goal with
       | J:(cPair ?X1 _ = cPair ?X2 _) |- _ =>
           cut (X1 = X2);
            [ intro I; discriminate I | eapply cPairInj1; apply J ]
       end
 end.
rewrite H3.
replace f2_2 with f1_1.
replace f1_2 with f2_1.
exists (CP L f1_1 f2_1).
simpl in |- *.
rewrite <- H8.
rewrite <- H6.
rewrite cPairProjections.
rewrite H2.
apply cPairProjections.
apply (codeFormulaInj L codeF codeR codeFInj codeRInj).
transitivity (cPairPi2 (cPairPi2 (cPairPi2 n)));
 [ symmetry  in |- *; assumption | assumption ].
apply (codeFormulaInj L codeF codeR codeFInj codeRInj).
transitivity (cPairPi1 (cPairPi2 (cPairPi2 n)));
 [ symmetry  in |- *; assumption | assumption ].
elim H0.
unfold charFunction in |- *.
rewrite beq_nat_not_refl.
reflexivity.
assumption.
destruct n1.
simpl in H0.
unfold checkPrfFA1 in H0.
clear A.
repeat first
 [ rewrite cPairProjections1 in H0 | rewrite cPairProjections2 in H0 ].
exists (nil (A:=Formula)).
rewrite <- H3 in H0.
rename x into f.
induction
 (eq_nat_dec
    (cPair 1
       (cPair
          (cPair 3
             (cPair (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 n))))
                (cPairPi1 (cPairPi2 (cPairPi2 n)))))
          (codeSubFormula (cPairPi1 (cPairPi2 (cPairPi2 n)))
             (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 n))))
             (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 n)))))))
    (codeFormula L codeF codeR f)).
repeat
 match goal with
 | H:(cPair 1 (cPair ?X2 ?X3) = cPair 1 (cPair ?X4 ?X5)) |- _ =>
     assert (X2 = X4);
      [ eapply cPairInj1; eapply cPairInj2; apply H
      | assert (X3 = X5);
         [ eapply cPairInj2; eapply cPairInj2; apply H | clear H ] ]
 | H:(cPair 3 (cPair ?X2 ?X3) = cPair 3 (cPair ?X4 ?X5)) |- _ =>
     assert (X2 = X4);
      [ eapply cPairInj1; eapply cPairInj2; apply H
      | assert (X3 = X5);
         [ eapply cPairInj2; eapply cPairInj2; apply H | clear H ] ]
 | H:(cPair ?X1 _ = codeFormula L codeF codeR ?X2) |- _ =>
      destruct X2;
      simpl in H;
      try
       match goal with
       | J:(cPair ?X1 _ = cPair ?X2 _) |- _ =>
           cut (X1 = X2);
            [ intro I; discriminate I | eapply cPairInj1; apply J ]
       end
 end.
rewrite H3.
rewrite H6 in H5.
rewrite H7 in H5.
assert (wellFormedTerm (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 n)))) <> 0).
eapply multLemma1.

End Check_Proof. *)

Require Import codeNatToTerm.
(* codeNatToTerm:
Require Import primRec.
Require Import cPair.
Require Import Arith.
Require Import code.
Require Import folProp.
Require Import folProof.
Require Import Languages.
Require LNN. 
Require LNT.

Definition natToTermLNN := LNN.natToTerm.

Definition natToTermLNT := LNT.natToTerm.

Definition codeNatToTerm : nat -> nat :=
  nat_rec (fun _ => nat) (cPair 4 0)
    (fun _ rec : nat => cPair 3 (S (cPair rec 0))).

Lemma codeNatToTermCorrectLNN :
 forall n : nat,
 codeNatToTerm n = codeTerm LNN codeLNTFunction (natToTermLNN n).

Lemma codeNatToTermCorrectLNT :
 forall n : nat,
 codeNatToTerm n = codeTerm LNT codeLNTFunction (natToTermLNT n).

Lemma codeNatToTermIsPR : isPR 1 codeNatToTerm. *)



Section Rosser's_Incompleteness.



Definition codeFormula := codeFormula LNN codeLNTFunction codeLNNRelation.



Variable T : System.



Hypothesis extendsNN : Included _ NN T.



Variable repT : Formula.

Variable v0 : nat.

Hypothesis

  freeVarRepT : forall v : nat, In v (freeVarFormula LNN repT) -> v = v0.

Hypothesis

  expressT1 :

    forall f : Formula,

    mem _ T f ->

    SysPrf T (substituteFormula LNN repT v0 (natToTerm (codeFormula f))).

Hypothesis

  expressT2 :

    forall f : Formula,

    ~ mem _ T f ->

    SysPrf T

      (notH (substituteFormula LNN repT v0 (natToTerm (codeFormula f)))).



Definition codeSysPrf :=

  codeSysPrf LNN codeLNTFunction codeLNNRelation codeArityLNTF codeArityLNNR

    codeArityLNTFIsPR codeArityLNNRIsPR repT v0.



Definition codeSysPrfCorrect1 :=

  codeSysPrfCorrect1 LNN codeLNTFunction codeLNNRelation codeArityLNTF

    codeArityLNNR codeArityLNTFIsPR codeArityLNTFIsCorrect1 codeArityLNNRIsPR

    codeArityLNNRIsCorrect1 T extendsNN T repT v0 freeVarRepT expressT1.



Definition codeSysPrfCorrect2 :=

  codeSysPrfCorrect2 LNN codeLNTFunction codeLNNRelation codeArityLNTF

    codeArityLNNR codeArityLNTFIsPR codeArityLNTFIsCorrect1 codeArityLNNRIsPR

    codeArityLNNRIsCorrect1 T extendsNN T repT v0 freeVarRepT expressT2.



Definition codeSysPrfCorrect3 :=

  codeSysPrfCorrect3 LNN codeLNTFunction codeLNNRelation codeArityLNTF

    codeArityLNNR codeArityLNTFIsPR codeArityLNTFIsCorrect1

    codeArityLNTFIsCorrect2 codeArityLNNRIsPR codeArityLNNRIsCorrect1

    codeArityLNNRIsCorrect2 codeLNTFunctionInj codeLNNRelationInj T extendsNN.

  

Definition codePrf := codePrf LNN codeLNTFunction codeLNNRelation.



Definition codeSysPrfNot :=

  codeSysPrfNot LNN codeLNTFunction codeLNNRelation codeArityLNTF

    codeArityLNNR codeArityLNTFIsPR codeArityLNNRIsPR repT v0.



Definition freeVarCodeSysPrfN :=

  freeVarCodeSysPrfN LNN codeLNTFunction codeLNNRelation codeArityLNTF

    codeArityLNNR codeArityLNTFIsPR codeArityLNNRIsPR repT v0 freeVarRepT.



Definition codeSysPrfNCorrect1 :=

  codeSysPrfNCorrect1 LNN codeLNTFunction codeLNNRelation codeArityLNTF

    codeArityLNNR codeArityLNTFIsPR codeArityLNTFIsCorrect1 codeArityLNNRIsPR

    codeArityLNNRIsCorrect1 T extendsNN T repT v0 freeVarRepT expressT1.



Definition codeSysPrfNCorrect2 :=

  codeSysPrfNCorrect2 LNN codeLNTFunction codeLNNRelation codeArityLNTF

    codeArityLNNR codeArityLNTFIsPR codeArityLNTFIsCorrect1 codeArityLNNRIsPR

    codeArityLNNRIsCorrect1 T extendsNN T repT v0 freeVarRepT expressT2.



Definition codeSysPrfNCorrect3 :=

  codeSysPrfNCorrect3 LNN codeLNTFunction codeLNNRelation codeArityLNTF

    codeArityLNNR codeArityLNTFIsPR codeArityLNTFIsCorrect1

    codeArityLNTFIsCorrect2 codeArityLNNRIsPR codeArityLNNRIsCorrect1

    codeArityLNNRIsCorrect2 codeLNTFunctionInj codeLNNRelationInj T extendsNN

    repT v0 freeVarRepT.



Lemma decideAxioms :

 (forall x : Formula, mem _ T x \/ ~ mem _ T x) ->

 forall x : Formulas,

 (forall g : Formula, In g x -> mem _ T g) \/

 (exists g : Formula, In g x /\ ~ mem _ T g).

Proof.

intros.

induction x as [| a x Hrecx].

left.

intros.

elim H0.

induction Hrecx as [H0| H0].

induction (H a).

left.

intros.

induction H2 as [H2| H2].

rewrite <- H2.

assumption.

auto.

right.

exists a.

split.

auto with datatypes.

assumption.

right.

induction H0 as (x0, H0).

exists x0.

induction H0 as (H0, H1).

auto with datatypes.

Qed.



Lemma searchProof :

 (forall x : Formula, mem _ T x \/ ~ mem _ T x) ->

 forall (a b : Formula) (A : Formulas) (p : Prf LNN A a),

 (exists B : Formulas,

    (exists q : Prf LNN B b,

       codePrf _ _ q < S (codePrf _ _ p) /\

       (forall x : Formula, In x B -> mem _ T x))) \/

 (forall (B : Formulas) (q : Prf LNN B b),

  codePrf _ _ q < S (codePrf _ _ p) ->

  exists g : Formula, In g B /\ ~ mem _ T g).

Proof.

intros.

induction (S (codePrf A a p)).

right.

intros.

elim (lt_n_O _ H0).

induction IHn as [H0| H0].

left.

decompose record H0.

exists x.

exists x0.

auto.

induction

 (eq_nat_dec

    (checkPrf LNN codeLNTFunction codeLNNRelation codeArityLNTF codeArityLNNR

       (codeFormula b) n) 0).

right.

intros.

induction (le_lt_or_eq _ _ (lt_n_Sm_le _ _ H1)).

eauto.

rewrite <- H2 in a0.

rewrite

 (checkPrfCorrect1 LNN codeLNTFunction codeLNNRelation codeArityLNTF

    codeArityLNNR codeArityLNTFIsCorrect1 codeArityLNNRIsCorrect1)

  in a0.

discriminate a0.

decompose record

 (checkPrfCorrect2 LNN codeLNTFunction codeLNNRelation codeArityLNTF

    codeArityLNNR codeArityLNTFIsCorrect1 codeArityLNTFIsCorrect2

    codeArityLNNRIsCorrect1 codeArityLNNRIsCorrect2 codeLNTFunctionInj

    codeLNNRelationInj _ _ b0).

assert (x = b).

eapply codeFormulaInj.

apply codeLNTFunctionInj.

apply codeLNNRelationInj.

assumption.

rewrite <- H1.

induction (decideAxioms H x0).

left.

exists x0.

exists x1.

unfold codePrf in |- *.

rewrite H3.

auto.

right.

intros.

induction (le_lt_or_eq _ _ (lt_n_Sm_le _ _ H5)).

rewrite <- H1 in H0.

eauto.

assert (B = x0).

eapply (codePrfInjAxm LNN) with (p := q) (q := x1).

apply codeLNTFunctionInj.

apply codeLNNRelationInj.

transitivity n.

unfold codePrf in H6.

apply H6.

symmetry  in |- *.

apply H3.

rewrite H7.

assumption.

Qed.



Theorem Rosser'sIncompleteness :

 (forall x : Formula, mem _ T x \/ ~ mem _ T x) ->

 exists f : Formula,

   (forall v : nat, ~ In v (freeVarFormula LNN f)) /\

   (SysPrf T f \/ SysPrf T (notH f) -> Inconsistent LNN T).

Proof.

intros decide.

set

 (A :=

  forallH 1

    (impH codeSysPrf

       (existH 2

          (andH (LT (var 2) (var 1))

             (substituteFormula LNN codeSysPrfNot 1 (var 2)))))) 

 in *.

destruct (FixPointLNN A 0) as [x [H0 H1]].

exists x.

split.

unfold not in |- *; intros.

induction (H1 v).

assert (In v (list_remove nat eq_nat_dec 0 (freeVarFormula LNN A))).

apply H2.

assumption.

unfold A in H4.

SimplFreeVar.

assert (v <= 1).

apply

 (freeVarCodeSysPrf LNN codeLNTFunction codeLNNRelation codeArityLNTF

    codeArityLNNR codeArityLNTFIsPR codeArityLNNRIsPR repT v0 freeVarRepT).

apply H5.

destruct v as [| n].

apply H6.

reflexivity.

destruct n.

apply H7.

reflexivity.

apply (le_not_lt (S (S n)) 1).

assumption.

apply lt_n_S.

apply lt_O_Sn.

assert (v <= 1).

apply freeVarCodeSysPrfN.

assumption.

destruct v as [| n].

apply H6.

reflexivity.

destruct n.

apply H7.

reflexivity.

apply (le_not_lt (S (S n)) 1).

assumption.

apply lt_n_S.

apply lt_O_Sn.

intros.

induction H as [H| H].

unfold Inconsistent in |- *.

intros.

elim H.

intros.

induction H2 as (x1, H2).

induction (searchProof decide _ (notH x) _ x1).

decompose record H3.

apply contradiction with x.

assumption.

exists x2.

exists x3.

assumption.

apply

 contradiction

  with

    (existH 2

       (andH (LT (var 2) (natToTerm (codePrf _ _ x1)))

          (substituteFormula LNN

             (substituteFormula LNN codeSysPrfNot 0

                (natToTerm (codeFormula x))) 1 (var 2)))).

apply

 impE

  with

    (existH 2

       (andH (LT (var 2) (natToTerm (codePrf x0 x x1)))

          (substituteFormula LNN

             (substituteFormula LNN

                (substituteFormula LNN codeSysPrfNot 0

                   (natToTerm (codeFormula x))) 1 (var 2)) 1

             (natToTerm (codePrf _ _ x1))))).

apply iffE1.

apply sysExtend with NN.

apply extendsNN.

apply (reduceExist LNN).

apply closedNN.

apply (reduceAnd LNN).

apply iffRefl.

apply (subFormulaNil LNN).

unfold not in |- *; intros.

induction (freeVarSubFormula3 _ _ _ _ _ H4).

apply (In_list_remove2 _ _ _ _ _ H5).

reflexivity.

simpl in H5.

decompose sum H5.

discriminate H6.

replace (LT (var 2) (natToTerm (codePrf _ _ x1))) with

 (substituteFormula LNN (LT (var 2) (var 1)) 1 (natToTerm (codePrf _ _ x1))).

rewrite <- (subFormulaAnd LNN).

apply

 impE

  with

    (existH 2

       (substituteFormula LNN

          (fol.andH LNN (LT (var 2) (var 1))

             (substituteFormula LNN

                (substituteFormula LNN codeSysPrfNot 1 (var 2)) 0

                (natToTerm (codeFormula x)))) 1 (natToTerm (codePrf x0 x x1)))).

apply iffE1.

apply sysExtend with NN.

apply extendsNN.

apply (reduceExist LNN).

apply closedNN.

apply (reduceSub LNN).

apply closedNN.

apply (reduceAnd LNN).

apply iffRefl.

apply (subFormulaExch LNN).

discriminate.

unfold not in |- *; intros.

simpl in H4.

decompose sum H4.

discriminate H5.

apply closedNatToTerm.

replace (LT (var 2) (var 1)) with

 (substituteFormula LNN (LT (var 2) (var 1)) 0 (natToTerm (codeFormula x))).

rewrite <- (subFormulaAnd LNN).

replace

 (existH 2

    (substituteFormula LNN

       (substituteFormula LNN

          (fol.andH LNN (LT (var 2) (var 1))

             (substituteFormula LNN codeSysPrfNot 1 (var 2))) 0

          (natToTerm (codeFormula x))) 1 (natToTerm (codePrf x0 x x1)))) with

 (substituteFormula LNN

    (existH 2

       (substituteFormula LNN

          (fol.andH LNN (LT (var 2) (var 1))

             (substituteFormula LNN codeSysPrfNot 1 (var 2))) 0

          (natToTerm (codeFormula x)))) 1 (natToTerm (codePrf x0 x x1))).

replace

 (existH 2

    (substituteFormula LNN

       (fol.andH LNN (LT (var 2) (var 1))

          (substituteFormula LNN codeSysPrfNot 1 (var 2))) 0

       (natToTerm (codeFormula x)))) with

 (substituteFormula LNN

    (existH 2

       (fol.andH LNN (LT (var 2) (var 1))

          (substituteFormula LNN codeSysPrfNot 1 (var 2)))) 0

    (natToTerm (codeFormula x))).

apply

 impE

  with

    (substituteFormula LNN

       (substituteFormula LNN codeSysPrf 0 (natToTerm (codeFormula x))) 1

       (natToTerm (codePrf _ _ x1))).

repeat rewrite <- (subFormulaImp LNN).

apply forallE.

replace

 (forallH 1

    (substituteFormula LNN

       (fol.impH LNN codeSysPrf

          (existH 2

             (fol.andH LNN (LT (var 2) (var 1))

                (substituteFormula LNN codeSysPrfNot 1 (var 2))))) 0

       (natToTerm (codeFormula x)))) with

 (substituteFormula LNN

    (forallH 1

       (fol.impH LNN codeSysPrf

          (existH 2

             (fol.andH LNN (LT (var 2) (var 1))

                (substituteFormula LNN codeSysPrfNot 1 (var 2)))))) 0

    (natToTerm (codeFormula x))).

apply impE with x.

apply iffE1.

apply sysExtend with NN.

apply extendsNN.

apply H0.

assumption.

rewrite (subFormulaForall LNN).

induction (eq_nat_dec 1 0).

discriminate a.

induction (In_dec eq_nat_dec 1 (freeVarTerm LNN (natToTerm (codeFormula x)))).

elim (closedNatToTerm _ _ a).

reflexivity.

apply codeSysPrfCorrect1.

assumption.

rewrite (subFormulaExist LNN).

induction (eq_nat_dec 2 0).

discriminate a.

induction (In_dec eq_nat_dec 2 (freeVarTerm LNN (natToTerm (codeFormula x)))).

elim (closedNatToTerm _ _ a).

reflexivity.

rewrite (subFormulaExist LNN).

induction (eq_nat_dec 2 1).

discriminate a.

induction

 (In_dec eq_nat_dec 2 (freeVarTerm LNN (natToTerm (codePrf x0 x x1)))).

elim (closedNatToTerm _ _ a).

reflexivity.

unfold LT in |- *.

rewrite (subFormulaRelation LNN).

simpl in |- *.

reflexivity.

unfold LT in |- *.

rewrite (subFormulaRelation LNN).

simpl in |- *.

reflexivity.

apply nExist.

set

 (E :=

  nat_rec (fun _ => Formula) (equal Zero Zero)

    (fun (n : nat) (rec : Formula) =>

     andH

       (notH

          (substituteFormula LNN

             (substituteFormula LNN codeSysPrfNot 0

                (natToTerm (codeFormula x))) 1 (natToTerm n))) rec)

    (codePrf x0 x x1)) in *.

assert (forall x : nat, ~ In x (freeVarFormula LNN E)).

unfold E in |- *.

clear H3 E.

induction (codePrf x0 x x1).

simpl in |- *.

auto.

intros.

unfold nat_rec, nat_rect in |- *.

unfold not in |- *; intros.

set

 (Q :=

  (fix F (n : nat) : (fun _ : nat => Formula) n :=

     match n with

     | O => equal Zero Zero

     | S n0 =>

         (fun (n1 : nat) (rec : Formula) =>

          andH

            (notH

               (substituteFormula LNN

                  (substituteFormula LNN codeSysPrfNot 0

                     (natToTerm (codeFormula x))) 1 

                  (natToTerm n1))) rec) n0 (F n0)

     end) n) in *.

SimplFreeVar.

apply (le_not_lt x2 1).

apply freeVarCodeSysPrfN.

assumption.

destruct x2 as [| n0].

elim H6; reflexivity.

destruct n0.

elim H5; reflexivity.

apply lt_n_S.

apply lt_O_Sn.

apply (IHn x2 H3).

apply impE with E.

apply sysExtend with NN.

apply extendsNN.

apply impI.

apply forallI.

unfold not in |- *; intros.

induction H5 as (x2, H5).

induction H5 as (H5, H6).

induction H6 as [x2 H6| x2 H6].

apply (closedNN 2).

exists x2.

auto.

induction H6.

apply (H4 2).

assumption.

apply nAnd.

unfold orH, fol.orH in |- *.

apply impTrans with (LT (var 2) (natToTerm (codePrf x0 x x1))).

apply impI.

apply nnE.

apply Axm; right; constructor.

apply impI.

apply impE with E.

apply impE with (LT (var 2) (natToTerm (codePrf x0 x x1))).

do 2 apply sysWeaken.

apply boundedLT.

intros.

rewrite (subFormulaImp LNN).

rewrite (subFormulaNot LNN).

apply

 impE

  with

    (fol.impH LNN E

       (fol.notH LNN

          (substituteFormula LNN

             (substituteFormula LNN codeSysPrfNot 0

                (natToTerm (codeFormula x))) 1 (natToTerm n)))).

apply iffE2.

apply (reduceImp LNN).

apply (subFormulaNil LNN).

apply H4.

apply (reduceNot LNN).

apply (subFormulaTrans LNN).

unfold not in |- *; intros.

SimplFreeVar.

apply (le_not_lt 2 1).

apply freeVarCodeSysPrfN.

assumption.

apply lt_n_Sn.

unfold E in |- *.

clear E H4 H3.

apply impI.

induction (codePrf x0 x x1).

elim (lt_n_O _ H5).

unfold nat_rec, nat_rect in |- *.

set

 (Q :=

  (fix F (n1 : nat) : (fun _ : nat => Formula) n1 :=

     match n1 with

     | O => equal Zero Zero

     | S n2 =>

         (fun (n3 : nat) (rec : Formula) =>

          andH

            (notH

               (substituteFormula LNN

                  (substituteFormula LNN codeSysPrfNot 0

                     (natToTerm (codeFormula x))) 1 

                  (natToTerm n3))) rec) n2 (F n2)

     end) n0) in *.

induction (le_lt_or_eq _ _ (lt_n_Sm_le _ _ H5)).

apply impE with Q.

apply sysWeaken.

apply impI.

apply (IHn0 H3).

eapply andE2.

apply Axm; right; constructor.

rewrite H3.

eapply andE1.

apply Axm; right; constructor.

apply Axm; right; constructor.

apply Axm; left; right; constructor.

unfold E in |- *.

clear H4 E.

induction (codePrf x0 x x1).

simpl in |- *.

apply eqRefl.

simpl in |- *.

apply andI.

induction

 (eq_nat_dec

    (checkPrf LNN codeLNTFunction codeLNNRelation codeArityLNTF codeArityLNNR

       (codeFormula (notH x)) n) 0).

unfold codeSysPrfNot in |- *.

apply codeSysPrfNCorrect3.

unfold not in |- *; intros.

rewrite H4 in a.

rewrite

 (checkPrfCorrect1 LNN codeLNTFunction codeLNNRelation codeArityLNTF

    codeArityLNNR codeArityLNTFIsCorrect1 codeArityLNNRIsCorrect1)

  in a.

discriminate a.

decompose record

 (checkPrfCorrect2 LNN codeLNTFunction codeLNNRelation codeArityLNTF

    codeArityLNNR codeArityLNTFIsCorrect1 codeArityLNTFIsCorrect2

    codeArityLNNRIsCorrect1 codeArityLNNRIsCorrect2 codeLNTFunctionInj

    codeLNNRelationInj _ _ b).

rewrite <- H6.

assert (x2 = notH x).

eapply codeFormulaInj.

apply codeLNTFunctionInj.

apply codeLNNRelationInj.

assumption.

cut (code.codePrf LNN codeLNTFunction codeLNNRelation x3 x2 x4 = n).

generalize x4.

clear H6 x4.

rewrite H4.

intros.

apply codeSysPrfNCorrect2.

eapply H3.

apply lt_S.

rewrite <- H6.

apply lt_n_Sn.

assumption.

apply IHn.

intros.

eapply H3.

apply lt_S.

apply H4.

unfold Inconsistent in |- *.

intros.

elim H.

intros.

induction H2 as (x1, H2).

induction (searchProof decide _ x _ x1).

decompose record H3.

apply contradiction with x.

exists x2.

exists x3.

assumption.

assumption.

apply

 contradiction

  with

    (substituteFormula LNN A 0

       (natToTermLNN (code.codeFormula LNN codeLNTFunction codeLNNRelation x))).

unfold A in |- *.

rewrite (subFormulaForall LNN).

induction (eq_nat_dec 1 0).

discriminate a.

induction

 (In_dec eq_nat_dec 1

    (freeVarTerm LNN

       (natToTermLNN (code.codeFormula LNN codeLNTFunction codeLNNRelation x)))).

elim (closedNatToTerm _ _ a).

clear b0 b.

set

 (E :=

  nat_rec (fun _ => Formula) (equal Zero Zero)

    (fun (n : nat) (rec : Formula) =>

     andH

       (notH

          (substituteFormula LNN

             (substituteFormula LNN codeSysPrf 0 (natToTerm (codeFormula x)))

             1 (natToTerm n))) rec) (S (codePrf _ _ x1))) 

 in *.

assert (forall x : nat, ~ In x (freeVarFormula LNN E)).

unfold E in |- *.

clear H3 E.

induction (S (codePrf x0 (notH x) x1)).

simpl in |- *.

auto.

intros.

unfold nat_rec, nat_rect in |- *.

unfold not in |- *; intros.

SimplFreeVar.

apply (le_not_lt x2 1).

apply

 (freeVarCodeSysPrf LNN codeLNTFunction codeLNNRelation codeArityLNTF

    codeArityLNNR codeArityLNTFIsPR codeArityLNNRIsPR repT v0 freeVarRepT).

apply H4.

destruct x2 as [| n0].

elim H6; reflexivity.

destruct n0.

elim H5; reflexivity.

apply lt_n_S.

apply lt_O_Sn.

apply (IHn _ H3).

apply impE with E.

set

 (G :=

  substituteFormula LNN

    (substituteFormula LNN codeSysPrfNot 0 (natToTerm (codeFormula x))) 1

    (natToTerm (codePrf x0 (notH x) x1))) in *.

apply impE with G.

apply sysExtend with NN.

assumption.

repeat apply impI.

apply forallI.

unfold not in |- *; intros.

induction H5 as (x2, H5); induction H5 as (H5, H6).

induction H6 as [x2 H6| x2 H6].

induction H6 as [x2 H6| x2 H6].

apply (closedNN 1).

exists x2.

auto.

induction H6.

unfold G in H5.

SimplFreeVar.

induction H6.

apply (H4 _ H5).

rewrite (subFormulaImp LNN).

rewrite (subFormulaExist LNN).

induction (eq_nat_dec 2 0).

discriminate a.

induction

 (In_dec eq_nat_dec 2

    (freeVarTerm LNN

       (natToTermLNN (code.codeFormula LNN codeLNTFunction codeLNNRelation x)))).

elim (closedNatToTerm _ _ a).

clear b0 b.

rewrite (subFormulaAnd LNN).

replace

 (substituteFormula LNN (LT (var 2) (var 1)) 0

    (natToTermLNN (code.codeFormula LNN codeLNTFunction codeLNNRelation x)))

 with (LT (var 2) (var 1)).

apply

 orE

  with

    (orH (LT (var 1) (natToTerm (codePrf x0 (notH x) x1)))

       (equal (var 1) (natToTerm (codePrf x0 (notH x) x1))))

    (LT (natToTerm (codePrf x0 (notH x) x1)) (var 1)).

repeat simple apply sysWeaken.

apply

 impE

  with

    (orH (LT (var 1) (natToTerm (codePrf x0 (notH x) x1)))

       (orH (equal (var 1) (natToTerm (codePrf x0 (notH x) x1)))

          (LT (natToTerm (codePrf x0 (notH x) x1)) (var 1)))).

apply impI.

apply orSys.

apply orI1.

apply orI1.

apply Axm; right; constructor.

apply orSys.

apply orI1.

apply orI2.

apply Axm; right; constructor.

apply orI2.

apply Axm; right; constructor.

apply nn9.

apply impI.

apply impE with G.

apply impE with E.

apply impE with (LT (var 1) (natToTerm (S (codePrf x0 (notH x) x1)))).

repeat simple apply sysWeaken.

apply boundedLT.

intros.

repeat apply impE.

repeat rewrite (subFormulaImp LNN).

repeat apply impI.

fold codeFormula in |- *.

apply

 contradiction

  with

    (substituteFormula LNN

       (substituteFormula LNN codeSysPrf 0 (natToTermLNN (codeFormula x))) 1

       (natToTerm n)).

apply Axm; right; constructor.

apply sysWeaken.

apply impE with E.

repeat simple apply sysWeaken.

apply impI.

clear H3.

clear H4.

induction (S (codePrf x0 (notH x) x1)).

elim (lt_n_O _ H5).

induction (le_lt_or_eq _ _ (lt_n_Sm_le _ _ H5)).

unfold E in |- *.

apply

 impE

  with

    (nat_rec (fun _ : nat => Formula) (equal Zero Zero)

       (fun (n : nat) (rec : Formula) =>

        andH

          (notH

             (substituteFormula LNN

                (substituteFormula LNN codeSysPrf 0

                   (natToTerm (codeFormula x))) 1 (natToTerm n))) rec) n0).

apply sysWeaken.

repeat apply impI.

apply IHn0.

assumption.

simpl in |- *.

eapply andE2.

apply Axm; right; constructor.

unfold E in |- *.

simpl in |- *.

rewrite H3.

eapply andE1.

apply Axm; right; constructor.

apply impE with (substituteFormula LNN E 1 (natToTerm n)).

apply iffE1.

apply (subFormulaNil LNN).

apply H4.

apply Axm; left; right; constructor.

apply

 impE

  with

    (orH (LT (var 1) (natToTerm (codePrf x0 (notH x) x1)))

       (equal (var 1) (natToTerm (codePrf x0 (notH x) x1)))).

repeat simple apply sysWeaken.

simpl in |- *.

apply nnPlusNotNeeded.

apply Axm; right; constructor.

apply Axm; left; right; constructor.

apply Axm; do 2 left; right; constructor.

repeat apply impI.

apply sysWeaken.

apply existI with (natToTerm (codePrf x0 (notH x) x1)).

rewrite (subFormulaAnd LNN).

apply andI.

unfold LT in |- *.

rewrite (subFormulaRelation LNN).

simpl in |- *.

apply Axm; right; constructor.

apply sysWeaken.

apply sysWeaken.

apply

 impE

  with

    (substituteFormula LNN

       (substituteFormula LNN codeSysPrfNot 0 (natToTerm (codeFormula x))) 1

       (natToTerm (codePrf x0 (notH x) x1))).

apply sysWeaken.

apply iffE2.

fold codeFormula in |- *.

apply

 iffTrans

  with

    (substituteFormula LNN

       (substituteFormula LNN

          (substituteFormula LNN codeSysPrfNot 0

             (natToTermLNN (codeFormula x))) 1 (var 2)) 2

       (natToTerm (codePrf x0 (notH x) x1))).

repeat (apply (reduceSub LNN); [ apply closedNN | idtac ]).

apply (subFormulaExch LNN).

discriminate.

unfold not in |- *; intros; SimplFreeVar.

discriminate H6.

apply closedNatToTerm.

apply (subFormulaTrans LNN).

unfold not in |- *; intros; SimplFreeVar.

apply (le_not_lt 2 1).

apply freeVarCodeSysPrfN.

assumption.

apply lt_n_Sn.

apply Axm; right; constructor.

unfold LT in |- *.

rewrite (subFormulaRelation LNN).

reflexivity.

unfold G in |- *.

apply codeSysPrfNCorrect1.

assumption.

clear H4.

unfold E in |- *; clear E.

induction (S (codePrf x0 (notH x) x1)).

simpl in |- *.

apply eqRefl.

simpl in |- *.

apply andI.

induction

 (eq_nat_dec

    (checkPrf LNN codeLNTFunction codeLNNRelation codeArityLNTF codeArityLNNR

       (codeFormula x) n) 0).

unfold codeSysPrf, codeFormula in |- *.

apply codeSysPrfCorrect3.

unfold not in |- *; intros.

rewrite H4 in a.

rewrite

 (checkPrfCorrect1 LNN codeLNTFunction codeLNNRelation codeArityLNTF

    codeArityLNNR codeArityLNTFIsCorrect1 codeArityLNNRIsCorrect1)

  in a.

discriminate a.

decompose record

 (checkPrfCorrect2 LNN codeLNTFunction codeLNNRelation codeArityLNTF

    codeArityLNNR codeArityLNTFIsCorrect1 codeArityLNTFIsCorrect2

    codeArityLNNRIsCorrect1 codeArityLNNRIsCorrect2 codeLNTFunctionInj

    codeLNNRelationInj _ _ b).

rewrite <- H6.

assert (x2 = x).

eapply (codeFormulaInj LNN).

apply codeLNTFunctionInj.

apply codeLNNRelationInj.

assumption.

rewrite <- H4.

apply codeSysPrfCorrect2.

rewrite <- H4 in H3.

apply H3 with x4.

rewrite <- H6.

apply lt_n_Sn.

apply IHn.

intros.

eapply H3.

apply lt_S.

apply H4.

apply impE with (notH x).

apply cp2.

apply iffE2.

apply sysExtend with NN.

apply extendsNN.

assumption.

assumption.

Qed.



End Rosser's_Incompleteness.



Definition RepresentsInSelf (T:System) := 

exists rep:Formula, exists v:nat,

(forall x : nat, In x (freeVarFormula LNN rep) -> x = v)  /\

(forall f : Formula,

        mem Formula T f ->

        SysPrf T (substituteFormula LNN rep v (natToTerm (codeFormula f)))) /\

(forall f : Formula,

        ~ mem Formula T f ->

        SysPrf T

          (notH (substituteFormula LNN rep v (natToTerm (codeFormula f))))).



Definition DecidableSet (A:_)(s:Ensemble A) :=

(forall x : A,

        mem A s x \/

        ~ mem A s x).



Theorem Incompleteness :

       forall T : System,

       Included Formula NN T ->

       RepresentsInSelf T ->

       DecidableSet Formula T ->

       exists f : Formula,

         (Sentence f) /\

         (SysPrf T f \/ SysPrf T (notH f) -> Inconsistent LNN T).

Proof.

intros.

repeat induction H0.

apply Rosser'sIncompleteness with x x0; auto; tauto.

Qed.

