Require Import Ensembles.

Require Import Coq.Lists.List.

Require Import Arith.

Require Import misc.
(* misc:
Require Import Eqdep_dec.

Global Set Asymmetric Patterns.

Lemma inj_right_pair2 :
 forall A : Set,
 (forall x y : A, {x = y} + {x <> y}) ->
 forall (x : A) (P : A -> Set) (y y' : P x),
 existS P x y = existS P x y' -> y = y'. *)



Require Import ListExt.
(* ListExt:
Require Import Coq.Lists.List.

Section List_Remove.

Variable A : Set.
Hypothesis Aeq_dec : forall a b : A, {a = b} + {a <> b}.

Definition list_remove (x : A) (l : list A) : list A :=
  list_rec (fun _ => list A) nil
    (fun (a : A) _ (recl : list A) =>
     match Aeq_dec a x with
     | left _ => recl
     | right _ => a :: recl
     end) l.

Lemma In_list_remove1 :
 forall (a b : A) (l : list A), In a (list_remove b l) -> In a l.

Lemma In_list_remove2 :
 forall (a b : A) (l : list A), In a (list_remove b l) -> a <> b.

Lemma In_list_remove3 :
 forall (a b : A) (l : list A), In a l -> a <> b -> In a (list_remove b l).

End List_Remove.

Section No_Duplicate.

Variable A : Set.
Hypothesis Aeq_dec : forall a b : A, {a = b} + {a <> b}.

Definition no_dup (l : list A) : list A :=
  list_rec (fun _ => list A) nil
    (fun (a : A) _ (rec : list A) =>
     match In_dec Aeq_dec a rec with
     | left _ => rec
     | right _ => a :: rec
     end) l.

Lemma no_dup1 : forall (a : A) (l : list A), In a l -> In a (no_dup l).

Lemma no_dup2 : forall (a : A) (l : list A), In a (no_dup l) -> In a l.

Lemma no_dup3 : forall (k l : list A) (a : A), no_dup k = a :: l -> ~ In a l.

End No_Duplicate. *)

Require Import folProp.
(* folProp:
Require Import Wf_nat.
Require Import Max.
Require Import Arith.
Require Import Coq.Lists.List.
Require Import ListExt.
Require Import Peano_dec.

Require Export fol.

Section Fol_Properties.

Variable L : Language.

Notation Formula := (Formula L) (only parsing).
Notation Formulas := (Formulas L) (only parsing).
Notation System := (System L) (only parsing).
Notation Term := (Term L) (only parsing).
Notation Terms := (Terms L) (only parsing).
Let var := var L.
Let apply := apply L.
Let equal := equal L.
Let atomic := atomic L.
Let impH := impH L.
Let notH := notH L.
Let forallH := forallH L.
Let lt_depth := lt_depth L.

Section Free_Variables.

Fixpoint freeVarTerm (s : fol.Term L) : list nat :=
  match s with
  | fol.var v => v :: nil
  | fol.apply f ts => freeVarTerms (arity L (inr _ f)) ts
  end
 
 with freeVarTerms (n : nat) (ss : fol.Terms L n) {struct ss} : 
 list nat :=
  match ss with
  | Tnil => nil (A:=nat)
  | Tcons m t ts => freeVarTerm t ++ freeVarTerms m ts
  end.

Lemma freeVarTermApply :
 forall (f : Functions L) (ts : fol.Terms L _),

Fixpoint freeVarFormula (A : fol.Formula L) : list nat :=
  match A with
  | fol.equal t s => freeVarTerm t ++ freeVarTerm s
  | fol.atomic r ts => freeVarTerms _ ts
  | fol.impH A B => freeVarFormula A ++ freeVarFormula B
  | fol.notH A => freeVarFormula A
  | fol.forallH v A => list_remove _ eq_nat_dec v (freeVarFormula A)
  end.

Definition ClosedSystem (T : fol.System L) :=
  forall (v : nat) (f : fol.Formula L),
  mem _ T f -> ~ In v (freeVarFormula f).

Definition closeList (l : list nat) (x : fol.Formula L) : 
  fol.Formula L :=
  list_rec (fun _ => fol.Formula L) x
    (fun (a : nat) _ (rec : fol.Formula L) => forallH a rec) l.

Definition close (x : fol.Formula L) : fol.Formula L :=
  closeList (no_dup _ eq_nat_dec (freeVarFormula x)) x.

Lemma freeVarClosedList1 :
 forall (l : list nat) (v : nat) (x : fol.Formula L),

Lemma freeVarClosedList2 :
 forall (l : list nat) (v : nat) (x : fol.Formula L),

Lemma freeVarClosed :
 forall (x : fol.Formula L) (v : nat), ~ In v (freeVarFormula (close x)).

Fixpoint freeVarListFormula (l : fol.Formulas L) : 
 list nat :=
  match l with
  | nil => nil (A:=nat)
  | f :: l => freeVarFormula f ++ freeVarListFormula l
  end.

Lemma freeVarListFormulaApp :
 forall a b : fol.Formulas L,

Lemma In_freeVarListFormula :
 forall (v : nat) (f : fol.Formula L) (F : fol.Formulas L),

Lemma In_freeVarListFormulaE :
 forall (v : nat) (F : fol.Formulas L),

Definition In_freeVarSys (v : nat) (T : fol.System L) :=
  exists f : fol.Formula L, In v (freeVarFormula f) /\ mem _ T f.

Lemma notInFreeVarSys :
 forall x, ~ In_freeVarSys x (Ensembles.Empty_set (fol.Formula L)).

End Free_Variables.

Section Substitution.

Fixpoint substituteTerm (s : fol.Term L) (x : nat) 
 (t : fol.Term L) {struct s} : fol.Term L :=
  match s with
  | fol.var v =>
      match eq_nat_dec x v with
      | left _ => t
      | right _ => var v
      end
  | fol.apply f ts => apply f (substituteTerms _ ts x t)
  end
 
 with substituteTerms (n : nat) (ss : fol.Terms L n) 
 (x : nat) (t : fol.Term L) {struct ss} : fol.Terms L n :=
  match ss in (fol.Terms _ n0) return (fol.Terms L n0) with
  | Tnil => Tnil L
  | Tcons m s ts =>
      Tcons L m (substituteTerm s x t) (substituteTerms m ts x t)
  end.

Lemma subTermVar1 :
 forall (v : nat) (s : fol.Term L), substituteTerm (var v) v s = s.

Lemma subTermVar2 :
 forall (v x : nat) (s : fol.Term L),

Lemma subTermFunction :
 forall (f : Functions L) (ts : fol.Terms L (arity L (inr _ f))) 

Definition newVar (l : list nat) : nat := fold_right max 0 (map S l).

Lemma newVar2 : forall (l : list nat) (n : nat), In n l -> n < newVar l.

Lemma newVar1 : forall l : list nat, ~ In (newVar l) l.

Definition substituteFormulaImp (f : fol.Formula L)
  (frec : nat * fol.Term L -> {y : fol.Formula L | depth L y = depth L f})
  (g : fol.Formula L)
  (grec : nat * fol.Term L -> {y : fol.Formula L | depth L y = depth L g})
  (p : nat * fol.Term L) :
  {y : fol.Formula L | depth L y = depth L (impH f g)} :=
  match frec p with
  | exist f' prf1 =>
      match grec p with
      | exist g' prf2 =>
          exist
            (fun y : fol.Formula L =>
             depth L y = S (max (depth L f) (depth L g))) 
            (impH f' g')
            (eq_ind_r
               (fun n : nat =>
                S (max n (depth L g')) = S (max (depth L f) (depth L g)))
               (eq_ind_r
                  (fun n : nat =>
                   S (max (depth L f) n) = S (max (depth L f) (depth L g)))
                  (refl_equal (S (max (depth L f) (depth L g)))) prf2) prf1)
      end
  end.

Remark substituteFormulaImpNice :
 forall (f g : fol.Formula L)

Definition substituteFormulaNot (f : fol.Formula L)
  (frec : nat * fol.Term L -> {y : fol.Formula L | depth L y = depth L f})
  (p : nat * fol.Term L) :
  {y : fol.Formula L | depth L y = depth L (notH f)} :=
  match frec p with
  | exist f' prf1 =>
      exist (fun y : fol.Formula L => depth L y = S (depth L f)) 
        (notH f')
        (eq_ind_r (fun n : nat => S n = S (depth L f))
           (refl_equal (S (depth L f))) prf1)
  end.

Remark substituteFormulaNotNice :
 forall (f : fol.Formula L)

Definition substituteFormulaForall (n : nat) (f : fol.Formula L)
  (frec : forall b : fol.Formula L,
          lt_depth b (forallH n f) ->
          nat * fol.Term L -> {y : fol.Formula L | depth L y = depth L b})
  (p : nat * fol.Term L) :
  {y : fol.Formula L | depth L y = depth L (forallH n f)} :=
  match p with
  | (v, s) =>
      match eq_nat_dec n v with
      | left _ =>
          exist (fun y : fol.Formula L => depth L y = S (depth L f))
            (forallH n f) (refl_equal (depth L (forallH n f)))
      | right _ =>
          match In_dec eq_nat_dec n (freeVarTerm s) with
          | left _ =>
              let nv := newVar (v :: freeVarTerm s ++ freeVarFormula f) in
              match frec f (depthForall L f n) (n, var nv) with
              | exist f' prf1 =>
                  match
                    frec f'
                      (eqDepth L f' f (forallH n f) 
                         (sym_eq prf1) (depthForall L f n)) p
                  with
                  | exist f'' prf2 =>
                      exist
                        (fun y : fol.Formula L => depth L y = S (depth L f))
                        (forallH nv f'')
                        (eq_ind_r (fun n : nat => S n = S (depth L f))
                           (refl_equal (S (depth L f))) 
                           (trans_eq prf2 prf1))
                  end
              end
          | right _ =>
              match frec f (depthForall L f n) p with
              | exist f' prf1 =>
                  exist (fun y : fol.Formula L => depth L y = S (depth L f))
                    (forallH n f')
                    (eq_ind_r (fun n : nat => S n = S (depth L f))
                       (refl_equal (S (depth L f))) prf1)
              end
          end
      end
  end.

Remark substituteFormulaForallNice :
 forall (v : nat) (a : fol.Formula L)

Definition substituteFormulaHelp (f : fol.Formula L) 

Definition substituteFormula (f : fol.Formula L) (v : nat) 
  (s : fol.Term L) : fol.Formula L := proj1_sig (substituteFormulaHelp f v s).

Lemma subFormulaEqual :
 forall (t1 t2 : fol.Term L) (v : nat) (s : fol.Term L),

Lemma subFormulaRelation :
 forall (r : Relations L) (ts : fol.Terms L (arity L (inl _ r))) 

Lemma subFormulaImp :
 forall (f1 f2 : fol.Formula L) (v : nat) (s : fol.Term L),

Lemma subFormulaNot :
 forall (f : fol.Formula L) (v : nat) (s : fol.Term L),

Lemma subFormulaForall :
 forall (f : fol.Formula L) (x v : nat) (s : fol.Term L),

Section Extensions.

Let orH := orH L.
Let andH := andH L.
Let existH := existH L.
Let iffH := iffH L.
Let ifThenElseH := ifThenElseH L.

Lemma subFormulaOr :
 forall (f1 f2 : fol.Formula L) (v : nat) (s : fol.Term L),

Lemma subFormulaAnd :
 forall (f1 f2 : fol.Formula L) (v : nat) (s : fol.Term L),

Lemma subFormulaExist :
 forall (f : fol.Formula L) (x v : nat) (s : fol.Term L),

Lemma subFormulaIff :
 forall (f1 f2 : fol.Formula L) (v : nat) (s : fol.Term L),

Lemma subFormulaIfThenElse :
 forall (f1 f2 f3 : fol.Formula L) (v : nat) (s : fol.Term L),

End Extensions.

Lemma subFormulaDepth :
 forall (f : fol.Formula L) (v : nat) (s : fol.Term L),

Section Substitution_Properties.

Lemma subTermId :
 forall (t : fol.Term L) (v : nat), substituteTerm t v (var v) = t.

Lemma subTermsId :
 forall (n : nat) (ts : fol.Terms L n) (v : nat),

Lemma subFormulaId :
 forall (f : fol.Formula L) (v : nat), substituteFormula f v (var v) = f.

Lemma subFormulaForall2 :
 forall (f : fol.Formula L) (x v : nat) (s : fol.Term L),

Let existH := existH L.

Lemma subFormulaExist2 :
 forall (f : fol.Formula L) (x v : nat) (s : fol.Term L),

End Substitution_Properties.

End Substitution.
 
Definition Sentence (f:Formula) := (forall v : nat, ~ In v (freeVarFormula f)).

End Fol_Properties. *)

Require Import folProof.
(* folProof:
Require Import Ensembles.
Require Import Coq.Lists.List.
Require Import Arith.

Require Export fol.
Require Import folProp.

Section ProofH.

Variable L : Language.

Let Formula := Formula L.
Let Formulas := Formulas L.
Let System := System L.
Let Term := Term L.
Let Terms := Terms L.
Let var := var L.
Let apply := apply L.
Let equal := equal L.
Let atomic := atomic L.
Let impH := impH L.
Let notH := notH L.
Let iffH := iffH L.
Let forallH := forallH L.

Definition nVars (n : nat) : Terms n * Terms n.

Definition AxmEq4 (R : Relations L) : Formula.

Definition AxmEq5 (f : Functions L) : Formula.

Inductive Prf : Formulas -> Formula -> Set :=
  | AXM : forall A : Formula, Prf (A :: nil) A
  | MP :
      forall (Axm1 Axm2 : Formulas) (A B : Formula),
      Prf Axm1 (impH A B) -> Prf Axm2 A -> Prf (Axm1 ++ Axm2) B
  | GEN :
      forall (Axm : Formulas) (A : Formula) (v : nat),
      ~ In v (freeVarListFormula L Axm) -> Prf Axm A -> Prf Axm (forallH v A)
  | IMP1 : forall A B : Formula, Prf nil (impH A (impH B A))
  | IMP2 :
      forall A B C : Formula,
      Prf nil (impH (impH A (impH B C)) (impH (impH A B) (impH A C)))
  | CP :
      forall A B : Formula,
      Prf nil (impH (impH (notH A) (notH B)) (impH B A))
  | FA1 :
      forall (A : Formula) (v : nat) (t : Term),
      Prf nil (impH (forallH v A) (substituteFormula L A v t))
  | FA2 :
      forall (A : Formula) (v : nat),
      ~ In v (freeVarFormula L A) -> Prf nil (impH A (forallH v A))
  | FA3 :
      forall (A B : Formula) (v : nat),
      Prf nil
        (impH (forallH v (impH A B)) (impH (forallH v A) (forallH v B)))
  | EQ1 : Prf nil (equal (var 0) (var 0))
  | EQ2 : Prf nil (impH (equal (var 0) (var 1)) (equal (var 1) (var 0)))
  | EQ3 :
      Prf nil
        (impH (equal (var 0) (var 1))
           (impH (equal (var 1) (var 2)) (equal (var 0) (var 2))))
  | EQ4 : forall R : Relations L, Prf nil (AxmEq4 R)
  | EQ5 : forall f : Functions L, Prf nil (AxmEq5 f).

Definition SysPrf (T : System) (f : Formula) :=
  exists Axm : Formulas,
    (exists prf : Prf Axm f,
       (forall g : Formula, In g Axm -> mem _ T g)).

Definition Inconsistent (T : System) := forall f : Formula, SysPrf T f.

Definition Consistent (T : System) := exists f : Formula, ~ SysPrf T f.

End ProofH. *)

Require Import Languages.
(* Languages:
Require Import Arith.
Require Import fol.
Require Import primRec.
Require Import Coq.Lists.List.

Inductive LNTFunction : Set :=
  | Plus : LNTFunction
  | Times : LNTFunction
  | Succ : LNTFunction
  | Zero : LNTFunction.

Inductive LNNRelation : Set :=
    LT : LNNRelation.

Definition LNTFunctionArity (x : LNTFunction) : nat :=
  match x with
  | Plus => 2
  | Times => 2
  | Succ => 1
  | Zero => 0
  end.

Definition LNTArity (x : Empty_set + LNTFunction) : nat :=
  match x return nat with
  | inl bot => Empty_set_rec (fun _ => nat) bot
  | inr y => LNTFunctionArity y
  end.

Definition LNNArity (x : LNNRelation + LNTFunction) : nat :=
  match x return nat with
  | inl y => match y with
             | LT => 2
             end
  | inr y => LNTFunctionArity y
  end.

Definition LNT : Language := language Empty_set LNTFunction LNTArity.

Definition LNN : Language := language LNNRelation LNTFunction LNNArity.

Definition codeLNTFunction (f : LNTFunction) : nat :=
  match f with
  | Plus => 0
  | Times => 1
  | Succ => 2
  | Zero => 3
  end.

Definition codeLNTRelation (R : Empty_set) : nat :=
  match R return nat with
  end.

Definition codeLNNRelation (R : LNNRelation) : nat := 0.

Lemma codeLNTFunctionInj :
 forall f g : LNTFunction, codeLNTFunction f = codeLNTFunction g -> f = g.

Lemma codeLNTRelationInj :
 forall R S : Empty_set, codeLNTRelation R = codeLNTRelation S -> R = S.

Lemma codeLNNRelationInj :
 forall R S : LNNRelation, codeLNNRelation R = codeLNNRelation S -> R = S.

Definition codeArityLNNR (r : nat) := switchPR r 0 3.

Lemma codeArityLNNRIsPR : isPR 1 codeArityLNNR.

Lemma codeArityLNNRIsCorrect1 :
 forall r : Relations LNN,
 codeArityLNNR (codeLNNRelation r) = S (arity LNN (inl _ r)).

Lemma codeArityLNNRIsCorrect2 :
 forall n : nat,
 codeArityLNNR n <> 0 -> exists r : Relations LNN, codeLNNRelation r = n.

Definition codeArityLNTR (r : nat) := 0.

Lemma codeArityLNTRIsPR : isPR 1 codeArityLNTR.

Lemma codeArityLNTRIsCorrect1 :
 forall r : Relations LNT,
 codeArityLNTR (codeLNTRelation r) = S (arity LNT (inl _ r)).

Lemma codeArityLNTRIsCorrect2 :
 forall n : nat,
 codeArityLNTR n <> 0 -> exists r : Relations LNT, codeLNTRelation r = n.

Definition codeArityLNTF (f : nat) :=
  switchPR f
    (switchPR (pred f)
       (switchPR (pred (pred f)) (switchPR (pred (pred (pred f))) 0 1) 2) 3)
    3.

Lemma codeArityLNTFIsPR : isPR 1 codeArityLNTF.

Lemma codeArityLNTFIsCorrect1 :
 forall f : Functions LNT,
 codeArityLNTF (codeLNTFunction f) = S (arity LNT (inr _ f)).

Lemma codeArityLNNFIsCorrect1 :
 forall f : Functions LNN,
 codeArityLNTF (codeLNTFunction f) = S (arity LNN (inr _ f)).

Lemma codeArityLNTFIsCorrect2 :
 forall n : nat,
 codeArityLNTF n <> 0 -> exists f : Functions LNT, codeLNTFunction f = n.

Lemma codeArityLNNFIsCorrect2 :
 forall n : nat,
 codeArityLNTF n <> 0 -> exists f : Functions LNN, codeLNTFunction f = n. *)

Require Import subAll.
(* subAll:
Require Import Ensembles.
Require Import Coq.Lists.List.
Require Import Arith.
Require Import Peano_dec.
Require Import ListExt.
Require Import Max.

Require Import folProof.
Require Import folLogic2.
Require Import folProp.
Require Import folReplace.
Require Import subProp.

Section SubAllVars.

Variable L : Language.
Notation Formula := (Formula L) (only parsing).
Notation Formulas := (Formulas L) (only parsing).
Notation System := (System L) (only parsing).
Notation Term := (Term L) (only parsing).
Notation Terms := (Terms L) (only parsing).
Notation var := (var L) (only parsing).
Notation apply := (apply L) (only parsing).
Notation equal := (equal L) (only parsing).
Notation atomic := (atomic L) (only parsing).
Notation impH := (impH L) (only parsing).
Notation notH := (notH L) (only parsing).
Notation forallH := (forallH L) (only parsing).
Notation iffH := (iffH L) (only parsing).
Notation SysPrf := (SysPrf L) (only parsing).

Fixpoint subAllTerm (t : fol.Term L) : (nat -> fol.Term L) -> fol.Term L :=
  match t return ((nat -> fol.Term L) -> fol.Term L) with
  | fol.var x => fun m => m x
  | fol.apply f ts => fun m => fol.apply L f (subAllTerms _ ts m)
  end
 
 with subAllTerms (n : nat) (ts : fol.Terms L n) {struct ts} :
 (nat -> fol.Term L) -> fol.Terms L n :=
  match
    ts in (fol.Terms _ n) return ((nat -> fol.Term L) -> fol.Terms L n)
  with
  | Tnil => fun _ => Tnil L
  | Tcons n' t ss =>
      fun m => Tcons L n' (subAllTerm t m) (subAllTerms _ ss m)
  end.

Lemma subAllTerm_ext :
 forall (t : fol.Term L) (m1 m2 : nat -> fol.Term L),

Lemma subAllTerms_ext :
 forall (n : nat) (ts : fol.Terms L n) (m1 m2 : nat -> fol.Term L),

Fixpoint freeVarMap (l : list nat) : (nat -> fol.Term L) -> list nat :=
  match l with
  | nil => fun _ => nil
  | a :: l' => fun m => freeVarTerm L (m a) ++ freeVarMap l' m
  end.

Lemma freeVarMap_ext :
 forall (l : list nat) (f1 f2 : nat -> fol.Term L),

Lemma freeVarMap1 :
 forall (l : list nat) (m : nat -> fol.Term L) (v n : nat),

Fixpoint subAllFormula (f : Formula) (m : (nat -> Term)) {struct f} : Formula :=
  match f with
  | fol.equal t s => equal (subAllTerm t m) (subAllTerm s m)
  | fol.atomic r ts => atomic r (subAllTerms _ ts m)
  | fol.impH f g =>
      impH (subAllFormula f m) (subAllFormula g m)
  | fol.notH f => notH (subAllFormula f m)
  | fol.forallH n f =>
      let nv :=
        newVar
          (freeVarFormula L f ++
           freeVarMap (freeVarFormula L (forallH n f)) m) in
      forallH nv
        (subAllFormula f
           (fun v : nat =>
            match eq_nat_dec v n with
            | left _ => var nv
            | right _ => m v
            end))
  end.

Lemma subAllFormula_ext :
 forall (f : fol.Formula L) (m1 m2 : nat -> fol.Term L),

Lemma freeVarSubAllTerm1 :
 forall (t : fol.Term L) (m : nat -> fol.Term L) (v : nat),

Lemma freeVarSubAllTerms1 :
 forall (n : nat) (ts : fol.Terms L n) (m : nat -> fol.Term L) (v : nat),

Lemma freeVarSubAllTerm2 :
 forall (t : fol.Term L) (m : nat -> fol.Term L) (v n : nat),

Lemma freeVarSubAllTerms2 :
 forall (a : nat) (ts : fol.Terms L a) (m : nat -> fol.Term L) (v n : nat),

Lemma freeVarSubAllFormula1 :
 forall (f : fol.Formula L) (m : nat -> fol.Term L) (v : nat),

Lemma freeVarSubAllFormula2 :
 forall (f : fol.Formula L) (m : nat -> fol.Term L) (v n : nat),

Lemma subSubAllTerm :
 forall (t : fol.Term L) (m : nat -> fol.Term L) (v : nat) (s : fol.Term L),

Lemma subSubAllTerms :
 forall (n : nat) (ts : fol.Terms L n) (m : nat -> fol.Term L) 

Lemma subSubAllFormula :
 forall (T : fol.System L) (f : fol.Formula L) (m : nat -> fol.Term L)

Lemma subAllTermId :
 forall t : fol.Term L, subAllTerm t (fun x : nat => fol.var L x) = t.

Lemma subAllTermsId :
 forall (n : nat) (ts : fol.Terms L n),

Lemma subAllFormulaId :
 forall (T : fol.System L) (f : fol.Formula L),

Lemma subAllSubAllTerm :
 forall (t : fol.Term L) (m1 m2 : nat -> fol.Term L),

Lemma subAllSubAllTerms :
 forall (n : nat) (ts : fol.Terms L n) (m1 m2 : nat -> fol.Term L),

Lemma subAllSubAllFormula :
 forall (T : fol.System L) (f : fol.Formula L) (m1 m2 : nat -> fol.Term L),

Section subAllCloseFrom.

Fixpoint closeFrom (a n : nat) (f : fol.Formula L) {struct n} :
 fol.Formula L :=
  match n with
  | O => f
  | S m => fol.forallH L (a + m) (closeFrom a m f)
  end.

Opaque le_lt_dec.

Lemma liftCloseFrom :
 forall (n : nat) (f : fol.Formula L) (T : fol.System L) (m : nat),

Lemma subAllCloseFrom1 :
 forall (n m : nat) (map : nat -> fol.Term L) (f : fol.Formula L)

Lemma subAllCloseFrom :
 forall (n : nat) (m : nat -> fol.Term L) (f : fol.Formula L)

Lemma reduceSubAll :
 forall (T : fol.System L) (map : nat -> fol.Term L) (A B : fol.Formula L),

End subAllCloseFrom.

Lemma subToSubAll :
 forall (T : fol.System L) (A : fol.Formula L) (v : nat) (s : fol.Term L),

Lemma subAllSubFormula :
 forall (T : fol.System L) (A : fol.Formula L) (v : nat) 

End SubAllVars. *)

Require Import subProp.
(* subProp:
Require Import Ensembles.
Require Import Coq.Lists.List.
Require Import Peano_dec.
Require Import ListExt.
Require Import Arith.

Require Import folProof.
Require Import folLogic.
Require Import folProp.
Require Import folReplace.

Section Substitution_Properties.

Variable L : Language.
Let Formula := Formula L.
Let Formulas := Formulas L.
Let System := System L.
Let Term := Term L.
Let Terms := Terms L.
Let var := var L.
Let apply := apply L.
Let equal := equal L.
Let atomic := atomic L.
Let impH := impH L.
Let notH := notH L.
Let forallH := forallH L.
Let orH := orH L.
Let andH := andH L.
Let existH := existH L.
Let iffH := iffH L.
Let SysPrf := SysPrf L.

Lemma freeVarSubTerm1 :
 forall (t : Term) (v : nat) (s : Term) (x : nat),
 In x (freeVarTerm L t) ->
 v <> x -> In x (freeVarTerm L (substituteTerm L t v s)).

Lemma freeVarSubTerms1 :
 forall (n : nat) (ts : Terms n) (v : nat) (s : Term) (x : nat),
 In x (freeVarTerms L n ts) ->
 v <> x -> In x (freeVarTerms L n (substituteTerms L n ts v s)).

Lemma freeVarSubFormula1 :
 forall (f : Formula) (v : nat) (s : Term) (x : nat),
 v <> x ->
 In x (freeVarFormula L f) ->
 In x (freeVarFormula L (substituteFormula L f v s)).

Lemma freeVarSubTerm2 :
 forall (t : Term) (v : nat) (s : Term) (x : nat),
 In x (freeVarTerm L s) ->
 In v (freeVarTerm L t) -> In x (freeVarTerm L (substituteTerm L t v s)).

Lemma freeVarSubTerms2 :
 forall (n : nat) (ts : Terms n) (v : nat) (s : Term) (x : nat),
 In x (freeVarTerm L s) ->
 In v (freeVarTerms L n ts) ->
 In x (freeVarTerms L n (substituteTerms L n ts v s)).

Lemma freeVarSubFormula2 :
 forall (f : Formula) (v : nat) (s : Term) (x : nat),
 In x (freeVarTerm L s) ->
 In v (freeVarFormula L f) ->
 In x (freeVarFormula L (substituteFormula L f v s)).

Lemma freeVarSubTerm3 :
 forall (t : Term) (v : nat) (s : Term) (x : nat),
 In x (freeVarTerm L (substituteTerm L t v s)) ->
 In x (list_remove _ eq_nat_dec v (freeVarTerm L t)) \/
 In x (freeVarTerm L s).

Lemma freeVarSubTerms3 :
 forall (n : nat) (ts : fol.Terms L n) (v : nat) (s : Term) (x : nat),

Lemma freeVarSubFormula3 :
 forall (f : Formula) (v : nat) (s : Term) (x : nat),
 In x (freeVarFormula L (substituteFormula L f v s)) ->
 In x (list_remove _ eq_nat_dec v (freeVarFormula L f)) \/
 In x (freeVarTerm L s).

Lemma freeVarSubTerm4 :
 forall (t : Term) (v : nat) (s : Term) (x : nat),
 In x (freeVarTerm L (substituteTerm L t v s)) ->
 ~ In v (freeVarTerm L t) -> In x (freeVarTerm L t).

Lemma freeVarSubTerms4 :
 forall (n : nat) (ts : Terms n) (v : nat) (s : Term) (x : nat),
 In x (freeVarTerms L n (substituteTerms L n ts v s)) ->
 ~ In v (freeVarTerms L n ts) -> In x (freeVarTerms L n ts).

Lemma freeVarSubFormula4 :
 forall (f : Formula) (v : nat) (s : Term) (x : nat),
 In x (freeVarFormula L (substituteFormula L f v s)) ->
 ~ In v (freeVarFormula L f) -> In x (freeVarFormula L f).

Lemma subTermNil :
 forall (t : Term) (v : nat) (s : Term),
 ~ In v (freeVarTerm L t) -> substituteTerm L t v s = t.

Lemma subTermTrans :
 forall (t : Term) (v1 v2 : nat) (s : Term),
 ~ In v2 (list_remove _ eq_nat_dec v1 (freeVarTerm L t)) ->
 substituteTerm L (substituteTerm L t v1 (var v2)) v2 s =
 substituteTerm L t v1 s.

Lemma subTermExch :
 forall (t : Term) (v1 v2 : nat) (s1 s2 : Term),
 v1 <> v2 ->
 ~ In v2 (freeVarTerm L s1) ->
 ~ In v1 (freeVarTerm L s2) ->
 substituteTerm L (substituteTerm L t v1 s1) v2 s2 =
 substituteTerm L (substituteTerm L t v2 s2) v1 s1.

Lemma subTermsNil :
 forall (n : nat) (ts : Terms n) (v : nat) (s : Term),
 ~ In v (freeVarTerms L n ts) -> substituteTerms L n ts v s = ts.

Lemma subTermsTrans :
 forall (n : nat) (ts : Terms n) (v1 v2 : nat) (s : Term),
 ~ In v2 (list_remove _ eq_nat_dec v1 (freeVarTerms L n ts)) ->
 substituteTerms L n (substituteTerms L n ts v1 (var v2)) v2 s =
 substituteTerms L n ts v1 s.

Lemma subTermsExch :
 forall (n : nat) (ts : Terms n) (v1 v2 : nat) (s1 s2 : Term),
 v1 <> v2 ->
 ~ In v2 (freeVarTerm L s1) ->
 ~ In v1 (freeVarTerm L s2) ->
 substituteTerms L n (substituteTerms L n ts v1 s1) v2 s2 =
 substituteTerms L n (substituteTerms L n ts v2 s2) v1 s1.

Remark subFormulaNTEHelp :
 forall (f g : Formula) (v : nat) (s : Term),
 SysPrf (Ensembles.Add _ (Empty_set Formula) f) g ->

Remark subFormulaNTE :
 forall (f : Formula) (T : System),
 (forall (v : nat) (s : Term),
  ~ In v (freeVarFormula L f) ->
  SysPrf T (iffH (substituteFormula L f v s) f)) /\
 (forall (v1 v2 : nat) (s : Term),
  ~ In v2 (list_remove _ eq_nat_dec v1 (freeVarFormula L f)) ->
  SysPrf T
    (iffH (substituteFormula L (substituteFormula L f v1 (var v2)) v2 s)
       (substituteFormula L f v1 s))) /\
 (forall (v1 v2 : nat) (s1 s2 : Term),
  v1 <> v2 ->
  ~ In v2 (freeVarTerm L s1) ->
  ~ In v1 (freeVarTerm L s2) ->
  SysPrf T
    (iffH (substituteFormula L (substituteFormula L f v1 s1) v2 s2)
       (substituteFormula L (substituteFormula L f v2 s2) v1 s1))).

Lemma subFormulaNil :
 forall (f : Formula) (T : System) (v : nat) (s : Term),
 ~ In v (freeVarFormula L f) -> SysPrf T (iffH (substituteFormula L f v s) f).

Lemma subFormulaTrans :
 forall (f : Formula) (T : System) (v1 v2 : nat) (s : Term),
 ~ In v2 (list_remove _ eq_nat_dec v1 (freeVarFormula L f)) ->
 SysPrf T
   (iffH (substituteFormula L (substituteFormula L f v1 (var v2)) v2 s)
      (substituteFormula L f v1 s)).

Lemma subFormulaExch :
 forall (f : Formula) (T : System) (v1 v2 : nat) (s1 s2 : Term),
 v1 <> v2 ->
 ~ In v2 (freeVarTerm L s1) ->
 ~ In v1 (freeVarTerm L s2) ->
 SysPrf T
   (iffH (substituteFormula L (substituteFormula L f v1 s1) v2 s2)
      (substituteFormula L (substituteFormula L f v2 s2) v1 s1)).

End Substitution_Properties. *)

Require Import folLogic3.
(* folLogic3:
Require Import Ensembles.
Require Import Coq.Lists.List.
Require Import ListExt.

Require Import folProp.
Require Import folProof.
Require Export folLogic2.
Require Import subProp.
Require Import folReplace.
Require Import Arith.
Require Import subAll.
Require Import misc.

Unset Standard Proposition Elimination Names.

Section Equality_Logic_Rules.

Variable L : Language.
Notation Formula := (Formula L) (only parsing).
Notation Formulas := (Formulas L) (only parsing).
Notation System := (System L) (only parsing).
Notation Term := (Term L) (only parsing).
Notation Terms := (Terms L) (only parsing).
Let var := var L.
Let apply := apply L.
Let equal := equal L.
Let atomic := atomic L.
Let impH := impH L.
Let notH := notH L.
Let forallH := forallH L.
Let orH := orH L.
Let andH := andH L.
Let existH := existH L.
Let iffH := iffH L.
Let ifThenElseH := ifThenElseH L.
Let Prf := Prf L.
Let SysPrf := SysPrf L.

Lemma eqRefl :
 forall (T : fol.System L) (a : fol.Term L), SysPrf T (equal a a).

Lemma eqSym :
 forall (T : fol.System L) (a b : fol.Term L),

Lemma eqTrans :
 forall (T : fol.System L) (a b c : fol.Term L),

Fixpoint PairwiseEqual (T : fol.System L) (n : nat) {struct n} :
 fol.Terms L n -> fol.Terms L n -> Prop :=
  match n return (fol.Terms L n -> fol.Terms L n -> Prop) with
  | O => fun ts ss : fol.Terms L 0 => True
  | S x =>
      fun ts ss : fol.Terms L (S x) =>
      let (a, b) := proj1_sig (consTerms L x ts) in
      let (c, d) := proj1_sig (consTerms L x ss) in
      SysPrf T (equal a c) /\ PairwiseEqual T x b d
  end.

Let termsMap (m : nat) (ts ss : fol.Terms L m) : nat -> fol.Term L.

Remark subAllnVars1 :
 forall (a : nat) (ts ss : fol.Terms L a),

Remark subAllnVars2 :
 forall (a : nat) (ts ss : fol.Terms L a),

Remark addPairwiseEquals :
 forall (T : fol.System L) (n : nat) (ts ss : fol.Terms L n),

Lemma equalRelation :
 forall (T : fol.System L) (r : Relations L) (ts ss : fol.Terms L _),

Lemma equalFunction :
 forall (T : fol.System L) (f : Functions L) (ts ss : fol.Terms L _),

Lemma subWithEqualsTerm :
 forall (a b t : fol.Term L) (v : nat) (T : fol.System L),

Lemma subWithEqualsTerms :
 forall (a b : fol.Term L) (n : nat) (ts : fol.Terms L n) 

Lemma subWithEquals :
 forall (f : fol.Formula L) (v : nat) (a b : fol.Term L) (T : fol.System L),

End Equality_Logic_Rules. *)

Require Import folReplace.
(* folReplace:
Require Import Ensembles.
Require Import Coq.Lists.List.
Require Import Peano_dec.

Require Import ListExt.
Require Import folProof.
Require Import folLogic.
Require Import folProp.

Section Replacement.

Variable L : Language.
Let Formula := Formula L.
Let Formulas := Formulas L.
Let System := System L.
Let Term := Term L.
Let Terms := Terms L.
Let var := var L.
Let apply := apply L.
Let equal := equal L.
Let atomic := atomic L.
Let impH := impH L.
Let notH := notH L.
Let forallH := forallH L.
Let orH := orH L.
Let andH := andH L.
Let existH := existH L.
Let iffH := iffH L.
Let ifThenElseH := ifThenElseH L.
Let SysPrf := SysPrf L.

Lemma reduceImp :
 forall (f1 f2 f3 f4 : Formula) (T : System),
 SysPrf T (iffH f1 f3) ->
 SysPrf T (iffH f2 f4) -> SysPrf T (iffH (impH f1 f2) (impH f3 f4)).

Lemma reduceNot :
 forall (f1 f2 : Formula) (T : System),
 SysPrf T (iffH f1 f2) -> SysPrf T (iffH (notH f1) (notH f2)).

Lemma impForall :
 forall (f1 f2 : Formula) (v : nat) (T : System),
 ~ In_freeVarSys _ v T ->
 SysPrf T (impH f1 f2) -> SysPrf T (impH (forallH v f1) (forallH v f2)).

Lemma reduceForall :
 forall (f1 f2 : Formula) (v : nat) (T : System),
 ~ In_freeVarSys _ v T ->
 SysPrf T (iffH f1 f2) -> SysPrf T (iffH (forallH v f1) (forallH v f2)).

Lemma reduceOr :
 forall (f1 f2 f3 f4 : Formula) (T : System),
 SysPrf T (iffH f1 f3) ->
 SysPrf T (iffH f2 f4) -> SysPrf T (iffH (orH f1 f2) (orH f3 f4)).

Lemma reduceAnd :
 forall (f1 f2 f3 f4 : Formula) (T : System),
 SysPrf T (iffH f1 f3) ->
 SysPrf T (iffH f2 f4) -> SysPrf T (iffH (andH f1 f2) (andH f3 f4)).

Lemma iffExist :
 forall (f1 f2 : Formula) (v : nat) (T : System),
 ~ In_freeVarSys _ v T ->
 SysPrf T (impH f1 f2) -> SysPrf T (impH (existH v f1) (existH v f2)).

Lemma reduceExist :
 forall (f1 f2 : Formula) (v : nat) (T : System),
 ~ In_freeVarSys _ v T ->
 SysPrf T (iffH f1 f2) -> SysPrf T (iffH (existH v f1) (existH v f2)).

Lemma reduceIff :
 forall (f1 f2 f3 f4 : Formula) (T : System),
 SysPrf T (iffH f1 f3) ->
 SysPrf T (iffH f2 f4) -> SysPrf T (iffH (iffH f1 f2) (iffH f3 f4)).

Lemma reduceIfThenElse :
 forall (f1 f2 f3 f4 f5 f6 : Formula) (T : System),
 SysPrf T (iffH f1 f4) ->
 SysPrf T (iffH f2 f5) ->
 SysPrf T (iffH f3 f6) ->
 SysPrf T (iffH (ifThenElseH f1 f2 f3) (ifThenElseH f4 f5 f6)).

Lemma reduceSub :
 forall (T : System) (v : nat) (s : Term) (f g : Formula),
 ~ In_freeVarSys L v T ->
 SysPrf T (iffH f g) ->
 SysPrf T (iffH (substituteFormula L f v s) (substituteFormula L g v s)).

Lemma reduceCloseList :
 forall (l : list nat) (f1 f2 : Formula) (T : System),
 (forall v : nat, In v l -> ~ In_freeVarSys _ v T) ->
 SysPrf T (iffH f1 f2) ->
 SysPrf T (iffH (closeList L l f1) (closeList L l f2)).

End Replacement. *)

Require Import LNT.
(* LNT:
Require Import Ensembles.
Require Import Coq.Lists.List.
Require Import Arith.
Require Import misc.

Require Import ListExt.
Require Import folProp.
Require Import folProof.
Require Import Languages.
Require Import subAll.
Require Import subProp.
Require Import folLogic3.
Require Import folReplace.
Require Import LNT.
Require Import Max.
Require Import codeNatToTerm.

Fixpoint LNN2LNT_term (t : fol.Term LNN) : Term :=
  match t with
  | fol.var v => var v
  | apply f ts => apply LNT f (LNN2LNT_terms _ ts)
  end
 
 with LNN2LNT_terms (n : nat) (ts : fol.Terms LNN n) {struct ts} : 
 Terms n :=
  match ts in (fol.Terms _ n0) return (Terms n0) with
  | Tnil => Tnil LNT
  | Tcons m s ss => Tcons LNT m (LNN2LNT_term s) (LNN2LNT_terms m ss)
  end. 

Definition LTFormula :=
  existH 2 (equal (Plus (var 0) (Succ (var 2))) (var 1)).

Definition translateLT (ts : fol.Terms LNN (arity LNN (inl _ LT))) : Formula.

Lemma LNN2LNT_natToTerm :
 forall n : nat, LNN2LNT_term (natToTermLNN n) = natToTerm n.

Lemma translateLT1 :
 forall a a0 b0,
 translateLT (Tcons LNN 1 a (Tcons LNN 0 a0 b0)) =
 subAllFormula LNT LTFormula
   (fun H : nat =>
    nat_rec (fun _ : nat => fol.Term LNT) (LNN2LNT_term a)

Fixpoint LNN2LNT_formula (f : fol.Formula LNN) : Formula :=
  match f with
  | fol.equal t1 t2 => equal (LNN2LNT_term t1) (LNN2LNT_term t2)
  | atomic r ts =>
      match
        r as l return (fol.Terms LNN (arity LNN (inl _ l)) -> Formula)
      with
      | LT => fun t0 : fol.Terms LNN (arity LNN (inl _ LT)) => translateLT t0
      end ts
  | fol.impH A B => impH (LNN2LNT_formula A) (LNN2LNT_formula B)
  | fol.notH A => notH (LNN2LNT_formula A)
  | fol.forallH v A => forallH v (LNN2LNT_formula A)
  end.

Lemma LNN2LNT_or :
 forall a b : fol.Formula LNN,

Lemma LNN2LNT_and :
 forall a b : fol.Formula LNN,

Lemma LNN2LNT_iff :
 forall a b : fol.Formula LNN,

Lemma LNN2LNT_exist :
 forall (v : nat) (a : fol.Formula LNN),

Lemma LNN2LNT_freeVarTerm :
 forall t : fol.Term LNN,

Lemma LNN2LNT_freeVarTerms :
 forall (n : nat) (ts : fol.Terms LNN n),

Lemma LNN2LNT_freeVarFormula :
 forall (f : fol.Formula LNN) (v : nat),

Lemma LNN2LNT_freeVarFormula1 :
 forall (f : fol.Formula LNN) (v : nat),

Lemma LNN2LNT_freeVarFormula2 :
 forall (f : fol.Formula LNN) (v : nat),

Lemma LNN2LNT_subTerm :
 forall (t : fol.Term LNN) (v : nat) (s : fol.Term LNN),

Lemma LNN2LNT_subTerms :
 forall (n : nat) (ts : fol.Terms LNN n) (v : nat) (s : fol.Term LNN),

Lemma LNN2LNT_subFormula :
 forall (T : System) (f : fol.Formula LNN) (v : nat) (s : fol.Term LNN),

Fixpoint LNT2LNN_term (t : Term) : fol.Term LNN :=
  match t with
  | fol.var v => fol.var LNN v
  | apply f ts => apply LNN f (LNT2LNN_terms _ ts)
  end
 
 with LNT2LNN_terms (n : nat) (ts : Terms n) {struct ts} : 
 fol.Terms LNN n :=
  match ts in (fol.Terms _ n0) return (fol.Terms LNN n0) with
  | Tnil => Tnil LNN
  | Tcons m s ss => Tcons LNN m (LNT2LNN_term s) (LNT2LNN_terms m ss)
  end.

Lemma LNT2LNN_natToTerm :
 forall n : nat, LNT2LNN_term (natToTerm n) = natToTermLNN n.

Fixpoint LNT2LNN_formula (f : Formula) : fol.Formula LNN :=
  match f with
  | fol.equal t1 t2 => fol.equal LNN (LNT2LNN_term t1) (LNT2LNN_term t2)
  | atomic r ts => match r with
                   end
  | fol.impH A B => fol.impH LNN (LNT2LNN_formula A) (LNT2LNN_formula B)
  | fol.notH A => fol.notH LNN (LNT2LNN_formula A)
  | fol.forallH v A => fol.forallH LNN v (LNT2LNN_formula A)
  end.

Lemma LNT2LNT_term : forall t : Term, LNN2LNT_term (LNT2LNN_term t) = t.

Lemma LNT2LNT_formula :
 forall f : Formula, LNN2LNT_formula (LNT2LNN_formula f) = f.

Lemma LNT2LNN_subTerm :
 forall (t : Term) (v : nat) (s : Term),
 LNT2LNN_term (substituteTerm LNT t v s) =
 substituteTerm LNN (LNT2LNN_term t) v (LNT2LNN_term s).

Lemma LNT2LNN_freeVarTerm :
 forall t : Term, freeVarTerm LNN (LNT2LNN_term t) = freeVarTerm LNT t.

Lemma LNT2LNN_freeVarFormula :
 forall f : Formula,
 freeVarFormula LNN (LNT2LNN_formula f) = freeVarFormula LNT f.

Lemma LNT2LNN_subFormula :
 forall (f : Formula) (v : nat) (s : Term),
 LNT2LNN_formula (substituteFormula LNT f v s) =
 substituteFormula LNN (LNT2LNN_formula f) v (LNT2LNN_term s).

Section Translate_Proof.

Variable U : fol.System LNN.
Variable V : System.

Hypothesis
  AxiomsOK :
    forall f : fol.Formula LNN,
    mem _ U f ->  
    exists Axm : Formulas,
    (exists prf : Prf LNT Axm (LNN2LNT_formula f),
       (forall g : Formula, In g Axm -> mem _ V g)) /\
    forall v, In v (freeVarListFormula LNT Axm) -> (In v (freeVarFormula LNN f)).

Lemma translatePrf : forall f,
 forall axm, Prf LNN axm f -> 
  (forall g, In g axm -> mem _ U g) ->
  exists Axm : Formulas,
    (exists prf : Prf LNT Axm (LNN2LNT_formula f),
       (forall g : Formula, In g Axm -> mem _ V g)) /\
    forall v, In v (freeVarListFormula LNT Axm) -> (In v (freeVarListFormula LNN axm)).

End Translate_Proof.

Lemma translateProof
     : forall (U : fol.System LNN) (V : System), *)

Require Import Max.

Require Import codeNatToTerm.
(* codeNatToTerm:
Require Import primRec.
Require Import cPair.
Require Import Arith.
Require Import code.
Require Import folProp.
Require Import folProof.
Require Import Languages.
Require LNN. 
Require LNT.

Definition natToTermLNN := LNN.natToTerm.

Definition natToTermLNT := LNT.natToTerm.

Definition codeNatToTerm : nat -> nat :=
  nat_rec (fun _ => nat) (cPair 4 0)
    (fun _ rec : nat => cPair 3 (S (cPair rec 0))).

Lemma codeNatToTermCorrectLNN :
 forall n : nat,
 codeNatToTerm n = codeTerm LNN codeLNTFunction (natToTermLNN n).

Lemma codeNatToTermCorrectLNT :
 forall n : nat,
 codeNatToTerm n = codeTerm LNT codeLNTFunction (natToTermLNT n).

Lemma codeNatToTermIsPR : isPR 1 codeNatToTerm. *)



Fixpoint LNN2LNT_term (t : fol.Term LNN) : Term :=

  match t with

  | fol.var v => var v

  | apply f ts => apply LNT f (LNN2LNT_terms _ ts)

  end

 

 with LNN2LNT_terms (n : nat) (ts : fol.Terms LNN n) {struct ts} : 

 Terms n :=

  match ts in (fol.Terms _ n0) return (Terms n0) with

  | Tnil => Tnil LNT

  | Tcons m s ss => Tcons LNT m (LNN2LNT_term s) (LNN2LNT_terms m ss)

  end. 



Definition LTFormula :=

  existH 2 (equal (Plus (var 0) (Succ (var 2))) (var 1)).



Definition translateLT (ts : fol.Terms LNN (arity LNN (inl _ LT))) : Formula.

simpl in ts.

induction (consTerms _ _ ts).

induction x as (a, b).

induction (consTerms _ _ b).

induction x as (a0, b0).

set (x := LNN2LNT_term a) in *.

set (y := LNN2LNT_term a0) in *.

apply (subAllFormula LNT LTFormula).

intro.

induction H as [| H HrecH].

exact x.

induction H as [| H HrecH0].

exact y.

exact (var H).

Defined.



Lemma LNN2LNT_natToTerm :

 forall n : nat, LNN2LNT_term (natToTermLNN n) = natToTerm n.

Proof.

intros.

induction n as [| n Hrecn].

reflexivity.

simpl in |- *.

rewrite Hrecn.

reflexivity.

Qed.



Lemma translateLT1 :

 forall a a0 b0,

 translateLT (Tcons LNN 1 a (Tcons LNN 0 a0 b0)) =

 subAllFormula LNT LTFormula

   (fun H : nat =>

    nat_rec (fun _ : nat => fol.Term LNT) (LNN2LNT_term a)

      (fun (H0 : nat) (_ : fol.Term LNT) =>

       nat_rec (fun _ : nat => fol.Term LNT) (LNN2LNT_term a0)

         (fun (H1 : nat) (_ : fol.Term LNT) => var H1) H0) H).

Proof.

intros.

unfold translateLT in |- *.

induction (consTerms LNN 1 (Tcons LNN 1 a (Tcons LNN 0 a0 b0))).

induction x as (a1, b).

simpl in |- *.

induction (consTerms LNN 0 b).

induction x as (a2, b1).

simpl in |- *.

simpl in p.

inversion p.

assert (b = Tcons LNN 0 a0 b0).

refine (inj_right_pair2 _ eq_nat_dec _ _ _ _ H1).

rewrite H in p0.

simpl in p0.

inversion p0.

clear H4 H3 H H1 H0.

reflexivity.

Qed.



Fixpoint LNN2LNT_formula (f : fol.Formula LNN) : Formula :=

  match f with

  | fol.equal t1 t2 => equal (LNN2LNT_term t1) (LNN2LNT_term t2)

  | atomic r ts =>

      match

        r as l return (fol.Terms LNN (arity LNN (inl _ l)) -> Formula)

      with

      | LT => fun t0 : fol.Terms LNN (arity LNN (inl _ LT)) => translateLT t0

      end ts

  | fol.impH A B => impH (LNN2LNT_formula A) (LNN2LNT_formula B)

  | fol.notH A => notH (LNN2LNT_formula A)

  | fol.forallH v A => forallH v (LNN2LNT_formula A)

  end.



Lemma LNN2LNT_or :

 forall a b : fol.Formula LNN,

 LNN2LNT_formula (fol.orH LNN a b) =

 orH (LNN2LNT_formula a) (LNN2LNT_formula b).

Proof.

reflexivity.

Qed.



Lemma LNN2LNT_and :

 forall a b : fol.Formula LNN,

 LNN2LNT_formula (fol.andH LNN a b) =

 andH (LNN2LNT_formula a) (LNN2LNT_formula b).

Proof.

reflexivity.

Qed.



Lemma LNN2LNT_iff :

 forall a b : fol.Formula LNN,

 LNN2LNT_formula (fol.iffH LNN a b) =

 iffH (LNN2LNT_formula a) (LNN2LNT_formula b).

Proof.

reflexivity.

Qed.



Lemma LNN2LNT_exist :

 forall (v : nat) (a : fol.Formula LNN),

 LNN2LNT_formula (fol.existH LNN v a) = existH v (LNN2LNT_formula a).

Proof.

reflexivity.

Qed.



Lemma LNN2LNT_freeVarTerm :

 forall t : fol.Term LNN,

 freeVarTerm LNT (LNN2LNT_term t) = freeVarTerm LNN t.

Proof.

intros.

elim t using

 Term_Terms_ind

  with

    (P0 := fun (n : nat) (ts : fol.Terms LNN n) =>

           freeVarTerms LNT n (LNN2LNT_terms n ts) = freeVarTerms LNN n ts).

intros.

reflexivity.

intros.

simpl in |- *.

repeat rewrite freeVarTermApply.

apply H.

reflexivity.

intros.

simpl in |- *.

transitivity (freeVarTerm LNN t0 ++ freeVarTerms LNN n t1).

rewrite <- H0.

rewrite <- H.

reflexivity.

reflexivity.

Qed.



Lemma LNN2LNT_freeVarTerms :

 forall (n : nat) (ts : fol.Terms LNN n),

 freeVarTerms LNT n (LNN2LNT_terms n ts) = freeVarTerms LNN n ts.

Proof.

intros.

induction ts as [| n t ts Hrects].

reflexivity.

intros.

simpl in |- *.

transitivity (freeVarTerm LNN t ++ freeVarTerms LNN n ts).

rewrite <- Hrects.

rewrite <- LNN2LNT_freeVarTerm.

reflexivity.

reflexivity.

Qed.



Lemma LNN2LNT_freeVarFormula :

 forall (f : fol.Formula LNN) (v : nat),

 In v (freeVarFormula LNT (LNN2LNT_formula f)) <->

 In v (freeVarFormula LNN f).

Proof.

intros.

induction f as [t t0| r t| f1 Hrecf1 f0 Hrecf0| f Hrecf| n f Hrecf].

simpl in |- *.

repeat rewrite LNN2LNT_freeVarTerm.

tauto.

induction r.

simpl in |- *.

induction (consTerms _ _ t).

induction x as (a, b).

simpl in p.

rewrite <- p.

induction (consTerms _ _ b).

induction x as (a0, b0).

simpl in p0.

rewrite <- p0.

rewrite translateLT1.

rewrite <- (nilTerms _ b0).

unfold freeVarTerms in |- *.

fold (freeVarTerm LNN) in |- *.

rewrite <- app_nil_end.

split.

intros.

decompose record (freeVarSubAllFormula1 _ _ _ _ H).

simpl in H1.

induction H1 as [H0| H0].

rewrite <- H0 in H2.

simpl in H2.

rewrite LNN2LNT_freeVarTerm in H2.

auto with datatypes.

induction H0 as [H0| H0].

rewrite <- H0 in H2.

simpl in H2.

rewrite LNN2LNT_freeVarTerm in H2.

auto with datatypes.

contradiction.

intros.

induction (in_app_or _ _ _ H).

eapply freeVarSubAllFormula2.

simpl in |- *.

left.

reflexivity.

simpl in |- *.

rewrite LNN2LNT_freeVarTerm.

auto.

eapply freeVarSubAllFormula2.

simpl in |- *.

right.

left.

reflexivity.

simpl in |- *.

rewrite LNN2LNT_freeVarTerm.

auto.

simpl in |- *.

induction Hrecf1 as (H, H0).

induction Hrecf0 as (H1, H2).

split.

intros.

apply in_or_app.

induction (in_app_or _ _ _ H3); tauto.

intros.

apply in_or_app.

induction (in_app_or _ _ _ H3); tauto.

assumption.

simpl in |- *.

induction Hrecf as (H, H0).

split.

intros.

apply In_list_remove3.

apply H.

eapply In_list_remove1.

apply H1.

eapply In_list_remove2.

apply H1.

intros.

apply In_list_remove3.

apply H0.

eapply In_list_remove1.

apply H1.

eapply In_list_remove2.

apply H1.

Qed.



Lemma LNN2LNT_freeVarFormula1 :

 forall (f : fol.Formula LNN) (v : nat),

 In v (freeVarFormula LNT (LNN2LNT_formula f)) -> In v (freeVarFormula LNN f).

Proof.

intros.

induction (LNN2LNT_freeVarFormula f v).

auto.

Qed.



Lemma LNN2LNT_freeVarFormula2 :

 forall (f : fol.Formula LNN) (v : nat),

 In v (freeVarFormula LNN f) -> In v (freeVarFormula LNT (LNN2LNT_formula f)).

Proof.

intros.

induction (LNN2LNT_freeVarFormula f v).

auto.

Qed.



Lemma LNN2LNT_subTerm :

 forall (t : fol.Term LNN) (v : nat) (s : fol.Term LNN),

 LNN2LNT_term (substituteTerm LNN t v s) =

 substituteTerm LNT (LNN2LNT_term t) v (LNN2LNT_term s).

Proof.

intros.

elim t using

 Term_Terms_ind

  with

    (P0 := fun (n : nat) (ts : fol.Terms LNN n) =>

           LNN2LNT_terms n (substituteTerms LNN n ts v s) =

           substituteTerms LNT n (LNN2LNT_terms n ts) v (LNN2LNT_term s)).

intros.

simpl in |- *.

induction (eq_nat_dec v n); auto.

simpl in |- *.

intros.

rewrite H.

reflexivity.

reflexivity.

simpl in |- *.

intros.

rewrite H.

rewrite H0.

reflexivity.

Qed.



Lemma LNN2LNT_subTerms :

 forall (n : nat) (ts : fol.Terms LNN n) (v : nat) (s : fol.Term LNN),

 LNN2LNT_terms n (substituteTerms LNN n ts v s) =

 substituteTerms LNT n (LNN2LNT_terms n ts) v (LNN2LNT_term s).

Proof.

intros.

induction ts as [| n t ts Hrects].

reflexivity.

simpl in |- *.

rewrite Hrects.

rewrite LNN2LNT_subTerm.

reflexivity.

Qed.



Lemma LNN2LNT_subFormula :

 forall (T : System) (f : fol.Formula LNN) (v : nat) (s : fol.Term LNN),

 SysPrf T

   (iffH (LNN2LNT_formula (substituteFormula LNN f v s))

      (substituteFormula LNT (LNN2LNT_formula f) v (LNN2LNT_term s))).

Proof.

intros.

apply sysExtend with (Empty_set Formula).

unfold Included in |- *.

intros.

induction H.

generalize f v s.

clear T f v s.

intro.

elim f using Formula_depth_ind2; intros.

simpl in |- *.

rewrite (subFormulaEqual LNT).

repeat rewrite LNN2LNT_subTerm.

apply iffRefl.

induction r.

rewrite subFormulaRelation.

simpl in |- *.

induction (consTerms _ _ t).

induction x as (a, b).

simpl in p.

rewrite <- p.

induction (consTerms _ _ b).

induction x as (a0, b0).

simpl in p0.

rewrite <- p0.

rewrite translateLT1.

apply iffSym.

eapply iffTrans.

apply (subSubAllFormula LNT).

rewrite <- (nilTerms _ b0).

replace

 (substituteTerms LNN 2 (Tcons LNN 1 a (Tcons LNN 0 a0 (Tnil LNN))) v s) with

 (Tcons LNN 1 (substituteTerm LNN a v s)

    (Tcons LNN 0 (substituteTerm LNN a0 v s) (Tnil LNN))).

rewrite translateLT1.

rewrite

 (subAllFormula_ext LNT LTFormula

    (fun H : nat =>

     nat_rec (fun _ : nat => fol.Term LNT)

       (LNN2LNT_term (substituteTerm LNN a v s))

       (fun (H0 : nat) (_ : fol.Term LNT) =>

        nat_rec (fun _ : nat => fol.Term LNT)

          (LNN2LNT_term (substituteTerm LNN a0 v s))

          (fun (H1 : nat) (_ : fol.Term LNT) => var H1) H0) H)

    (fun n : nat =>

     substituteTerm LNT

       (nat_rec (fun _ : nat => fol.Term LNT) (LNN2LNT_term a)

          (fun (H0 : nat) (_ : fol.Term LNT) =>

           nat_rec (fun _ : nat => fol.Term LNT) (LNN2LNT_term a0)

             (fun (H1 : nat) (_ : fol.Term LNT) => var H1) H0) n) v

       (LNN2LNT_term s))).

apply iffRefl.

intros.

destruct m as [| n].

simpl in |- *.

apply LNN2LNT_subTerm.

destruct n.

simpl in |- *.

apply LNN2LNT_subTerm.

simpl in H.

decompose sum H.

discriminate H0.

discriminate H1.

reflexivity.

rewrite subFormulaImp.

simpl in |- *.

rewrite (subFormulaImp LNT).

apply (reduceImp LNT).

apply H.

apply H0.

rewrite subFormulaNot.

simpl in |- *.

rewrite (subFormulaNot LNT).

apply (reduceNot LNT).

apply H.

simpl in |- *.

decompose record (subFormulaForall2 LNN a v v0 s).

rewrite H4; clear H4.

decompose record

 (subFormulaForall2 LNT (LNN2LNT_formula a) v v0 (LNN2LNT_term s)).

unfold forallH in |- *.

rewrite H7; clear H7.

induction (eq_nat_dec v v0).

simpl in |- *.

apply iffRefl.

simpl in |- *.

apply

 iffTrans

  with

    (forallH x0

       (substituteFormula LNT

          (LNN2LNT_formula

             (substituteFormula LNN

                (substituteFormula LNN a v (fol.var LNN x)) v0 s)) x 

          (var x0))).

apply (rebindForall LNT).

unfold not in |- *; intros.

assert

 (In x0

    (freeVarFormula LNT

       (LNN2LNT_formula

          (substituteFormula LNN (substituteFormula LNN a v (fol.var LNN x))

             v0 s)))).

eapply In_list_remove1.

apply H6.

assert

 (In x0

    (freeVarFormula LNN

       (substituteFormula LNN (substituteFormula LNN a v (fol.var LNN x)) v0

          s))).

apply LNN2LNT_freeVarFormula1.

assumption.

induction (freeVarSubFormula3 _ _ _ _ _ H8).

assert

 (In x0 (freeVarFormula LNN (substituteFormula LNN a v (fol.var LNN x)))).

eapply In_list_remove1.

apply H9.

induction (freeVarSubFormula3 _ _ _ _ _ H10).

elim H5.

eapply In_list_remove3.

apply LNN2LNT_freeVarFormula2.

eapply In_list_remove1.

apply H11.

eapply In_list_remove2.

apply H11.

elim (In_list_remove2 _ _ _ _ _ H6).

induction H11 as [H11| H11].

auto.

contradiction.

elim H4.

rewrite LNN2LNT_freeVarTerm.

assumption.

apply (reduceForall LNT).

apply (notInFreeVarSys LNT).

apply

 iffTrans

  with

    (substituteFormula LNT

       (substituteFormula LNT

          (substituteFormula LNT (LNN2LNT_formula a) v (fol.var LNT x)) v0

          (LNN2LNT_term s)) x (var x0)).

apply (reduceSub LNT).

apply (notInFreeVarSys LNT).

eapply iffTrans.

apply H.

eapply eqDepth.

symmetry  in |- *; rewrite subFormulaDepth; symmetry  in |- *. 

reflexivity.

apply depthForall.

apply (reduceSub LNT).

apply (notInFreeVarSys LNT).

eapply iffTrans.

apply H.

apply depthForall.

simpl in |- *.

apply iffRefl.

eapply iffTrans.

apply (subFormulaExch LNT).

auto.

rewrite LNN2LNT_freeVarTerm.

auto.

simpl in |- *.

tauto.

apply (reduceSub LNT).

apply (notInFreeVarSys LNT).

apply (subFormulaTrans LNT).

unfold not in |- *; intros; elim H2.

apply In_list_remove3.

apply LNN2LNT_freeVarFormula1.

eapply In_list_remove1.

apply H6.

eapply In_list_remove2.

apply H6.

Qed.



Fixpoint LNT2LNN_term (t : Term) : fol.Term LNN :=

  match t with

  | fol.var v => fol.var LNN v

  | apply f ts => apply LNN f (LNT2LNN_terms _ ts)

  end

 

 with LNT2LNN_terms (n : nat) (ts : Terms n) {struct ts} : 

 fol.Terms LNN n :=

  match ts in (fol.Terms _ n0) return (fol.Terms LNN n0) with

  | Tnil => Tnil LNN

  | Tcons m s ss => Tcons LNN m (LNT2LNN_term s) (LNT2LNN_terms m ss)

  end.



Lemma LNT2LNN_natToTerm :

 forall n : nat, LNT2LNN_term (natToTerm n) = natToTermLNN n.

Proof.

intros.

induction n as [| n Hrecn].

reflexivity.

simpl in |- *.

rewrite Hrecn.

reflexivity.

Qed.



Fixpoint LNT2LNN_formula (f : Formula) : fol.Formula LNN :=

  match f with

  | fol.equal t1 t2 => fol.equal LNN (LNT2LNN_term t1) (LNT2LNN_term t2)

  | atomic r ts => match r with

                   end

  | fol.impH A B => fol.impH LNN (LNT2LNN_formula A) (LNT2LNN_formula B)

  | fol.notH A => fol.notH LNN (LNT2LNN_formula A)

  | fol.forallH v A => fol.forallH LNN v (LNT2LNN_formula A)

  end.



Lemma LNT2LNT_term : forall t : Term, LNN2LNT_term (LNT2LNN_term t) = t.

Proof.

intros.

elim t using

 Term_Terms_ind

  with

    (P0 := fun (n : nat) (ts : fol.Terms LNT n) =>

           LNN2LNT_terms n (LNT2LNN_terms n ts) = ts); 

 simpl in |- *; intros.

reflexivity.

rewrite H.

reflexivity.

reflexivity.

rewrite H.

rewrite H0.

reflexivity.

Qed.



Lemma LNT2LNT_formula :

 forall f : Formula, LNN2LNT_formula (LNT2LNN_formula f) = f.

Proof.

intros.

induction f as [t t0| r t| f1 Hrecf1 f0 Hrecf0| f Hrecf| n f Hrecf];

 simpl in |- *.

repeat rewrite LNT2LNT_term.

reflexivity.

induction r.

rewrite Hrecf1.

rewrite Hrecf0.

reflexivity.

rewrite Hrecf.

reflexivity.

rewrite Hrecf.

reflexivity.

Qed.



Lemma LNT2LNN_subTerm :

 forall (t : Term) (v : nat) (s : Term),

 LNT2LNN_term (substituteTerm LNT t v s) =

 substituteTerm LNN (LNT2LNN_term t) v (LNT2LNN_term s).

Proof.

intros.

elim t using

 Term_Terms_ind

  with

    (P0 := fun (n : nat) (ts : fol.Terms LNT n) =>

           LNT2LNN_terms n (substituteTerms LNT n ts v s) =

           substituteTerms LNN n (LNT2LNN_terms n ts) v (LNT2LNN_term s));

 simpl in |- *; intros.

induction (eq_nat_dec v n).

reflexivity.

reflexivity.

rewrite H.

reflexivity.

reflexivity.

rewrite H.

rewrite H0.

reflexivity.

Qed.



Lemma LNT2LNN_freeVarTerm :

 forall t : Term, freeVarTerm LNN (LNT2LNN_term t) = freeVarTerm LNT t.

Proof.

intros.

elim t using

 Term_Terms_ind

  with

    (P0 := fun (n : nat) (ts : fol.Terms LNT n) =>

           freeVarTerms LNN n (LNT2LNN_terms n ts) = freeVarTerms LNT n ts);

 simpl in |- *; intros.

reflexivity.

transitivity

 (freeVarTerms LNN (LNTFunctionArity f)

    (LNT2LNN_terms (LNTFunctionArity f) t0)).

reflexivity.

rewrite H.

reflexivity.

reflexivity.

transitivity

 (freeVarTerm LNN (LNT2LNN_term t0) ++

  freeVarTerms LNN n (LNT2LNN_terms n t1)).

reflexivity.

rewrite H.

rewrite H0.

reflexivity.

Qed.



Lemma LNT2LNN_freeVarFormula :

 forall f : Formula,

 freeVarFormula LNN (LNT2LNN_formula f) = freeVarFormula LNT f.

Proof.

intros.

induction f as [t t0| r t| f1 Hrecf1 f0 Hrecf0| f Hrecf| n f Hrecf];

 simpl in |- *.

repeat rewrite LNT2LNN_freeVarTerm.

reflexivity.

induction r.

rewrite Hrecf1.

rewrite Hrecf0.

reflexivity.

assumption.

rewrite Hrecf.

reflexivity.

Qed.



Lemma LNT2LNN_subFormula :

 forall (f : Formula) (v : nat) (s : Term),

 LNT2LNN_formula (substituteFormula LNT f v s) =

 substituteFormula LNN (LNT2LNN_formula f) v (LNT2LNN_term s).

Proof.

intro.

elim f using Formula_depth_ind2; simpl in |- *; intros.

repeat rewrite LNT2LNN_subTerm.

reflexivity.

induction r.

rewrite (subFormulaImp LNT).

simpl in |- *.

rewrite H.

rewrite H0.

rewrite (subFormulaImp LNN).

reflexivity.

rewrite (subFormulaNot LNT).

simpl in |- *.

rewrite H.

rewrite (subFormulaNot LNN).

reflexivity.

rewrite (subFormulaForall LNT).

rewrite (subFormulaForall LNN).

induction (eq_nat_dec v v0).

reflexivity.

rewrite LNT2LNN_freeVarTerm.

induction (In_dec eq_nat_dec v (freeVarTerm LNT s)).

simpl in |- *.

repeat rewrite H.

simpl in |- *.

rewrite LNT2LNN_freeVarFormula.

reflexivity.

apply depthForall.

eapply eqDepth.

symmetry  in |- *; rewrite subFormulaDepth; symmetry  in |- *.

reflexivity.

apply depthForall.

simpl in |- *.

rewrite H.

reflexivity.

apply depthForall.

Qed.



Section Translate_Proof.



Variable U : fol.System LNN.

Variable V : System.



Hypothesis

  AxiomsOK :

    forall f : fol.Formula LNN,

    mem _ U f ->  

    exists Axm : Formulas,

    (exists prf : Prf LNT Axm (LNN2LNT_formula f),

       (forall g : Formula, In g Axm -> mem _ V g)) /\

    forall v, In v (freeVarListFormula LNT Axm) -> (In v (freeVarFormula LNN f)).



Lemma translatePrf : forall f,

 forall axm, Prf LNN axm f -> 

  (forall g, In g axm -> mem _ U g) ->

  exists Axm : Formulas,

    (exists prf : Prf LNT Axm (LNN2LNT_formula f),

       (forall g : Formula, In g Axm -> mem _ V g)) /\

    forall v, In v (freeVarListFormula LNT Axm) -> (In v (freeVarListFormula LNN axm)).

Proof.

intros f x x0 H.

induction x0

 as

  [A|

   Axm1 Axm2 A B x0_1 Hrecx0_1 x0_0 Hrecx0_0|

   Axm A v n x0 Hrecx0|

   A B|

   A B C|

   A B|

   A v t|

   A v n|

   A B v|

   |

   |

   |

   R|

   f].

destruct (AxiomsOK A).

auto with *.

exists x.

destruct H0.

split.

apply H0.

intros.

simpl.

rewrite <- app_nil_end.

apply H1.

apply H2.

assert (forall g : fol.Formula LNN,

            In g Axm2 -> mem (fol.Formula LNN) U g).

intros.

apply H.

apply in_or_app.

auto.

assert (forall g : fol.Formula LNN,

            In g Axm1 -> mem (fol.Formula LNN) U g).

intros.

apply H.

apply in_or_app.

auto.

destruct (Hrecx0_0 H0) as [x [[x0 I0] Z0]].

destruct (Hrecx0_1 H1) as [x1 [[x2 I1] Z1]].

clear H0 H1.

rename I0 into H0.

rename I1 into H1.

exists (x1 ++ x).

simpl in x2.

split.

exists (MP LNT _ _ _ _ x2 x0).

intros.

induction (in_app_or _ _ _ H2); auto.

intros.

rewrite freeVarListFormulaApp.

rewrite freeVarListFormulaApp in H2.

apply in_or_app.

destruct (in_app_or _ _ _ H2);

auto with *.

destruct (Hrecx0 H) as [x [[x1 H0] Z]].

exists x.

assert (~ In v (freeVarListFormula LNT x)).

firstorder.

split.

exists (GEN LNT _ _ _ H1 x1).

assumption.

assumption.

exists (nil (A:=Formula)).

split.

exists (IMP1 LNT (LNN2LNT_formula A) (LNN2LNT_formula B)).

contradiction.

contradiction.

exists (nil (A:=Formula)).

split.

exists (IMP2 LNT (LNN2LNT_formula A) (LNN2LNT_formula B) (LNN2LNT_formula C)).

contradiction.

contradiction.

exists (nil (A:=Formula)).

split.

exists (CP LNT (LNN2LNT_formula A) (LNN2LNT_formula B)).

contradiction.

contradiction.

assert (SysPrf (Empty_set _) (LNN2LNT_formula (fol.impH LNN (fol.forallH LNN v A) (substituteFormula LNN A v t)))).

simpl in |- *.

apply

 impE

  with

    (impH (forallH v (LNN2LNT_formula A))

       (substituteFormula LNT (LNN2LNT_formula A) v (LNN2LNT_term t))).

apply iffE1.

apply (reduceImp LNT).

apply iffRefl.

apply iffSym.

apply LNN2LNT_subFormula.

exists (nil (A:=Formula)).

exists (FA1 LNT (LNN2LNT_formula A) v (LNN2LNT_term t)).

contradiction.

destruct H0.

exists x.

split.

destruct H0.

exists x0.

intros.

elim (H0 g H1).

intros.

destruct H0.

destruct x.

assumption.

assert (In f (f::x)).

auto with *.

elim (H0 f H2).

exists (nil (A:=Formula)).

assert (~ In v (freeVarFormula LNT (LNN2LNT_formula A))).

unfold not in |- *; intros; elim n.

apply LNN2LNT_freeVarFormula1.

auto.

split.

exists (FA2 LNT (LNN2LNT_formula A) v H0).

contradiction.

contradiction.

exists (nil (A:=Formula)).

split.

exists (FA3 LNT (LNN2LNT_formula A) (LNN2LNT_formula B) v).

contradiction.

contradiction.

exists (nil (A:=Formula)).

split.

exists (EQ1 LNT).

contradiction.

contradiction.

exists (nil (A:=Formula)).

split.

exists (EQ2 LNT).

contradiction.

contradiction.

exists (nil (A:=Formula)).

split.

exists (EQ3 LNT).

contradiction.

contradiction.

assert (SysPrf (Empty_set _) (LNN2LNT_formula (AxmEq4 LNN R))).

induction R.

simpl in |- *.

repeat apply impI.

unfold notH, impH in |- *.

apply

 impE

  with

    (iffH

       (translateLT

          (Tcons LNN 1 (fol.var LNN 2)

             (Tcons LNN 0 (fol.var LNN 0) (Tnil LNN))))

       (translateLT

          (Tcons LNN 1 (fol.var LNN 3)

             (Tcons LNN 0 (fol.var LNN 1) (Tnil LNN))))).

apply impRefl.

repeat rewrite translateLT1.

simpl in |- *.

unfold newVar in |- *.

simpl in |- *.

apply

 impE

  with

    (iffH (existH 3 (equal (Plus (var 2) (Succ (var 3))) (var 0)))

       (existH 4 (equal (Plus (var 3) (Succ (var 4))) (var 1)))).

apply impRefl.

eapply

 iffTrans

          with

          (existH 4

             (substituteFormula LNT

                (equal (Plus (var 2) (Succ (var 3))) (var 0)) 3 

                (var 4))).

apply (rebindExist LNT).

simpl in |- *.

unfold not in |- *; intros.

decompose sum H0.

discriminate H1.

discriminate H2.

apply (reduceExist LNT).

unfold not in |- *; intros.

induction H0 as (x, H0); induction H0 as (H0, H1).

induction H1 as [x H1| x H1]; [ induction H1 as [x H1| x H1] | induction H1 ].

elim H1.

induction H1.

simpl in H0.

decompose sum H0.

discriminate H1.

discriminate H2.

simpl in H0.

decompose sum H0.

discriminate H1.

discriminate H2.

repeat rewrite (subFormulaEqual LNT).

simpl in |- *.

apply iffI.

apply impI.

apply eqTrans with (var 0).

apply eqTrans with (Plus (var 2) (Succ (var 4))).

apply eqPlus.

apply eqSym.

apply Axm.

left.

left.

right.

constructor.

apply eqRefl.

apply Axm.

right; constructor.

apply Axm; left; right; constructor.

apply impI.

apply eqTrans with (var 1).

apply eqTrans with (Plus (var 3) (Succ (var 4))).

fold (Succ (var 4)) in |- *.

fold (Plus (fol.var LNT 2) (Succ (var 4))) in |- *.

apply eqPlus.

apply Axm.

left.

left.

right.

constructor.

apply eqRefl.

apply Axm.

right; constructor.

apply eqSym.

apply Axm; left; right; constructor.

destruct H0.

exists x.

destruct H0.

split.

exists x0.

intros.

elim (H0 g H1).

intros.

destruct x.

assumption.

assert (In f (f::x)).

auto with *.

elim (H0 _ H2).

replace (LNN2LNT_formula (AxmEq5 LNN f)) with (AxmEq5 LNT f).

exists (nil (A:=Formula)).

split.

exists (EQ5 LNT f).

contradiction.

contradiction.

induction f; reflexivity.

Qed.



End Translate_Proof.



Lemma translateProof

     : forall (U : fol.System LNN) (V : System),

       ClosedSystem LNT V ->

       (forall f : fol.Formula LNN,

        mem (fol.Formula LNN) U f -> SysPrf V (LNN2LNT_formula f)) ->

       forall f : fol.Formula LNN,

       folProof.SysPrf LNN U f -> SysPrf V (LNN2LNT_formula f).

Proof.

intros.

destruct H1.

assert (forall f : fol.Formula LNN,

        mem (fol.Formula LNN) U f ->

        exists Axm : Formulas,

          ex

            (fun _ : Prf LNT Axm (LNN2LNT_formula f) =>

             forall g : Formula, In g Axm -> mem (fol.Formula LNT) V g) /\

          (forall v : nat,

           In v (freeVarListFormula LNT Axm) -> In v (freeVarFormula LNN f))).

intros.

destruct (H0 f0 H2).

exists x0.

split.

apply H3.

intros.

destruct H3.

clear x1.

induction x0.

elim H4.

destruct (in_app_or _ _ _ H4).

elim H with v a.

apply H3.

auto with *.

assumption.

apply IHx0.

firstorder.

apply H5.

destruct H1.

destruct (translatePrf U V H2 f x x0 H1).

exists x1.

tauto.

Qed.

