Require Import Arith.

Require Import Ensembles.



Require Import folProp.
(* folProp:
Require Import Wf_nat.
Require Import Max.
Require Import Arith.
Require Import Coq.Lists.List.
Require Import ListExt.
Require Import Peano_dec.

Require Export fol.

Section Fol_Properties.

Variable L : Language.

Notation Formula := (Formula L) (only parsing).
Notation Formulas := (Formulas L) (only parsing).
Notation System := (System L) (only parsing).
Notation Term := (Term L) (only parsing).
Notation Terms := (Terms L) (only parsing).
Let var := var L.
Let apply := apply L.
Let equal := equal L.
Let atomic := atomic L.
Let impH := impH L.
Let notH := notH L.
Let forallH := forallH L.
Let lt_depth := lt_depth L.

Section Free_Variables.

Fixpoint freeVarTerm (s : fol.Term L) : list nat :=
  match s with
  | fol.var v => v :: nil
  | fol.apply f ts => freeVarTerms (arity L (inr _ f)) ts
  end
 
 with freeVarTerms (n : nat) (ss : fol.Terms L n) {struct ss} : 
 list nat :=
  match ss with
  | Tnil => nil (A:=nat)
  | Tcons m t ts => freeVarTerm t ++ freeVarTerms m ts
  end.

Lemma freeVarTermApply :
 forall (f : Functions L) (ts : fol.Terms L _),

Fixpoint freeVarFormula (A : fol.Formula L) : list nat :=
  match A with
  | fol.equal t s => freeVarTerm t ++ freeVarTerm s
  | fol.atomic r ts => freeVarTerms _ ts
  | fol.impH A B => freeVarFormula A ++ freeVarFormula B
  | fol.notH A => freeVarFormula A
  | fol.forallH v A => list_remove _ eq_nat_dec v (freeVarFormula A)
  end.

Definition ClosedSystem (T : fol.System L) :=
  forall (v : nat) (f : fol.Formula L),
  mem _ T f -> ~ In v (freeVarFormula f).

Definition closeList (l : list nat) (x : fol.Formula L) : 
  fol.Formula L :=
  list_rec (fun _ => fol.Formula L) x
    (fun (a : nat) _ (rec : fol.Formula L) => forallH a rec) l.

Definition close (x : fol.Formula L) : fol.Formula L :=
  closeList (no_dup _ eq_nat_dec (freeVarFormula x)) x.

Lemma freeVarClosedList1 :
 forall (l : list nat) (v : nat) (x : fol.Formula L),

Lemma freeVarClosedList2 :
 forall (l : list nat) (v : nat) (x : fol.Formula L),

Lemma freeVarClosed :
 forall (x : fol.Formula L) (v : nat), ~ In v (freeVarFormula (close x)).

Fixpoint freeVarListFormula (l : fol.Formulas L) : 
 list nat :=
  match l with
  | nil => nil (A:=nat)
  | f :: l => freeVarFormula f ++ freeVarListFormula l
  end.

Lemma freeVarListFormulaApp :
 forall a b : fol.Formulas L,

Lemma In_freeVarListFormula :
 forall (v : nat) (f : fol.Formula L) (F : fol.Formulas L),

Lemma In_freeVarListFormulaE :
 forall (v : nat) (F : fol.Formulas L),

Definition In_freeVarSys (v : nat) (T : fol.System L) :=
  exists f : fol.Formula L, In v (freeVarFormula f) /\ mem _ T f.

Lemma notInFreeVarSys :
 forall x, ~ In_freeVarSys x (Ensembles.Empty_set (fol.Formula L)).

End Free_Variables.

Section Substitution.

Fixpoint substituteTerm (s : fol.Term L) (x : nat) 
 (t : fol.Term L) {struct s} : fol.Term L :=
  match s with
  | fol.var v =>
      match eq_nat_dec x v with
      | left _ => t
      | right _ => var v
      end
  | fol.apply f ts => apply f (substituteTerms _ ts x t)
  end
 
 with substituteTerms (n : nat) (ss : fol.Terms L n) 
 (x : nat) (t : fol.Term L) {struct ss} : fol.Terms L n :=
  match ss in (fol.Terms _ n0) return (fol.Terms L n0) with
  | Tnil => Tnil L
  | Tcons m s ts =>
      Tcons L m (substituteTerm s x t) (substituteTerms m ts x t)
  end.

Lemma subTermVar1 :
 forall (v : nat) (s : fol.Term L), substituteTerm (var v) v s = s.

Lemma subTermVar2 :
 forall (v x : nat) (s : fol.Term L),

Lemma subTermFunction :
 forall (f : Functions L) (ts : fol.Terms L (arity L (inr _ f))) 

Definition newVar (l : list nat) : nat := fold_right max 0 (map S l).

Lemma newVar2 : forall (l : list nat) (n : nat), In n l -> n < newVar l.

Lemma newVar1 : forall l : list nat, ~ In (newVar l) l.

Definition substituteFormulaImp (f : fol.Formula L)
  (frec : nat * fol.Term L -> {y : fol.Formula L | depth L y = depth L f})
  (g : fol.Formula L)
  (grec : nat * fol.Term L -> {y : fol.Formula L | depth L y = depth L g})
  (p : nat * fol.Term L) :
  {y : fol.Formula L | depth L y = depth L (impH f g)} :=
  match frec p with
  | exist f' prf1 =>
      match grec p with
      | exist g' prf2 =>
          exist
            (fun y : fol.Formula L =>
             depth L y = S (max (depth L f) (depth L g))) 
            (impH f' g')
            (eq_ind_r
               (fun n : nat =>
                S (max n (depth L g')) = S (max (depth L f) (depth L g)))
               (eq_ind_r
                  (fun n : nat =>
                   S (max (depth L f) n) = S (max (depth L f) (depth L g)))
                  (refl_equal (S (max (depth L f) (depth L g)))) prf2) prf1)
      end
  end.

Remark substituteFormulaImpNice :
 forall (f g : fol.Formula L)

Definition substituteFormulaNot (f : fol.Formula L)
  (frec : nat * fol.Term L -> {y : fol.Formula L | depth L y = depth L f})
  (p : nat * fol.Term L) :
  {y : fol.Formula L | depth L y = depth L (notH f)} :=
  match frec p with
  | exist f' prf1 =>
      exist (fun y : fol.Formula L => depth L y = S (depth L f)) 
        (notH f')
        (eq_ind_r (fun n : nat => S n = S (depth L f))
           (refl_equal (S (depth L f))) prf1)
  end.

Remark substituteFormulaNotNice :
 forall (f : fol.Formula L)

Definition substituteFormulaForall (n : nat) (f : fol.Formula L)
  (frec : forall b : fol.Formula L,
          lt_depth b (forallH n f) ->
          nat * fol.Term L -> {y : fol.Formula L | depth L y = depth L b})
  (p : nat * fol.Term L) :
  {y : fol.Formula L | depth L y = depth L (forallH n f)} :=
  match p with
  | (v, s) =>
      match eq_nat_dec n v with
      | left _ =>
          exist (fun y : fol.Formula L => depth L y = S (depth L f))
            (forallH n f) (refl_equal (depth L (forallH n f)))
      | right _ =>
          match In_dec eq_nat_dec n (freeVarTerm s) with
          | left _ =>
              let nv := newVar (v :: freeVarTerm s ++ freeVarFormula f) in
              match frec f (depthForall L f n) (n, var nv) with
              | exist f' prf1 =>
                  match
                    frec f'
                      (eqDepth L f' f (forallH n f) 
                         (sym_eq prf1) (depthForall L f n)) p
                  with
                  | exist f'' prf2 =>
                      exist
                        (fun y : fol.Formula L => depth L y = S (depth L f))
                        (forallH nv f'')
                        (eq_ind_r (fun n : nat => S n = S (depth L f))
                           (refl_equal (S (depth L f))) 
                           (trans_eq prf2 prf1))
                  end
              end
          | right _ =>
              match frec f (depthForall L f n) p with
              | exist f' prf1 =>
                  exist (fun y : fol.Formula L => depth L y = S (depth L f))
                    (forallH n f')
                    (eq_ind_r (fun n : nat => S n = S (depth L f))
                       (refl_equal (S (depth L f))) prf1)
              end
          end
      end
  end.

Remark substituteFormulaForallNice :
 forall (v : nat) (a : fol.Formula L)

Definition substituteFormulaHelp (f : fol.Formula L) 

Definition substituteFormula (f : fol.Formula L) (v : nat) 
  (s : fol.Term L) : fol.Formula L := proj1_sig (substituteFormulaHelp f v s).

Lemma subFormulaEqual :
 forall (t1 t2 : fol.Term L) (v : nat) (s : fol.Term L),

Lemma subFormulaRelation :
 forall (r : Relations L) (ts : fol.Terms L (arity L (inl _ r))) 

Lemma subFormulaImp :
 forall (f1 f2 : fol.Formula L) (v : nat) (s : fol.Term L),

Lemma subFormulaNot :
 forall (f : fol.Formula L) (v : nat) (s : fol.Term L),

Lemma subFormulaForall :
 forall (f : fol.Formula L) (x v : nat) (s : fol.Term L),

Section Extensions.

Let orH := orH L.
Let andH := andH L.
Let existH := existH L.
Let iffH := iffH L.
Let ifThenElseH := ifThenElseH L.

Lemma subFormulaOr :
 forall (f1 f2 : fol.Formula L) (v : nat) (s : fol.Term L),

Lemma subFormulaAnd :
 forall (f1 f2 : fol.Formula L) (v : nat) (s : fol.Term L),

Lemma subFormulaExist :
 forall (f : fol.Formula L) (x v : nat) (s : fol.Term L),

Lemma subFormulaIff :
 forall (f1 f2 : fol.Formula L) (v : nat) (s : fol.Term L),

Lemma subFormulaIfThenElse :
 forall (f1 f2 f3 : fol.Formula L) (v : nat) (s : fol.Term L),

End Extensions.

Lemma subFormulaDepth :
 forall (f : fol.Formula L) (v : nat) (s : fol.Term L),

Section Substitution_Properties.

Lemma subTermId :
 forall (t : fol.Term L) (v : nat), substituteTerm t v (var v) = t.

Lemma subTermsId :
 forall (n : nat) (ts : fol.Terms L n) (v : nat),

Lemma subFormulaId :
 forall (f : fol.Formula L) (v : nat), substituteFormula f v (var v) = f.

Lemma subFormulaForall2 :
 forall (f : fol.Formula L) (x v : nat) (s : fol.Term L),

Let existH := existH L.

Lemma subFormulaExist2 :
 forall (f : fol.Formula L) (x v : nat) (s : fol.Term L),

End Substitution_Properties.

End Substitution.
 
Definition Sentence (f:Formula) := (forall v : nat, ~ In v (freeVarFormula f)).

End Fol_Properties. *)

Require Import subAll.
(* subAll:
Require Import Ensembles.
Require Import Coq.Lists.List.
Require Import Arith.
Require Import Peano_dec.
Require Import ListExt.
Require Import Max.

Require Import folProof.
Require Import folLogic2.
Require Import folProp.
Require Import folReplace.
Require Import subProp.

Section SubAllVars.

Variable L : Language.
Notation Formula := (Formula L) (only parsing).
Notation Formulas := (Formulas L) (only parsing).
Notation System := (System L) (only parsing).
Notation Term := (Term L) (only parsing).
Notation Terms := (Terms L) (only parsing).
Notation var := (var L) (only parsing).
Notation apply := (apply L) (only parsing).
Notation equal := (equal L) (only parsing).
Notation atomic := (atomic L) (only parsing).
Notation impH := (impH L) (only parsing).
Notation notH := (notH L) (only parsing).
Notation forallH := (forallH L) (only parsing).
Notation iffH := (iffH L) (only parsing).
Notation SysPrf := (SysPrf L) (only parsing).

Fixpoint subAllTerm (t : fol.Term L) : (nat -> fol.Term L) -> fol.Term L :=
  match t return ((nat -> fol.Term L) -> fol.Term L) with
  | fol.var x => fun m => m x
  | fol.apply f ts => fun m => fol.apply L f (subAllTerms _ ts m)
  end
 
 with subAllTerms (n : nat) (ts : fol.Terms L n) {struct ts} :
 (nat -> fol.Term L) -> fol.Terms L n :=
  match
    ts in (fol.Terms _ n) return ((nat -> fol.Term L) -> fol.Terms L n)
  with
  | Tnil => fun _ => Tnil L
  | Tcons n' t ss =>
      fun m => Tcons L n' (subAllTerm t m) (subAllTerms _ ss m)
  end.

Lemma subAllTerm_ext :
 forall (t : fol.Term L) (m1 m2 : nat -> fol.Term L),

Lemma subAllTerms_ext :
 forall (n : nat) (ts : fol.Terms L n) (m1 m2 : nat -> fol.Term L),

Fixpoint freeVarMap (l : list nat) : (nat -> fol.Term L) -> list nat :=
  match l with
  | nil => fun _ => nil
  | a :: l' => fun m => freeVarTerm L (m a) ++ freeVarMap l' m
  end.

Lemma freeVarMap_ext :
 forall (l : list nat) (f1 f2 : nat -> fol.Term L),

Lemma freeVarMap1 :
 forall (l : list nat) (m : nat -> fol.Term L) (v n : nat),

Fixpoint subAllFormula (f : Formula) (m : (nat -> Term)) {struct f} : Formula :=
  match f with
  | fol.equal t s => equal (subAllTerm t m) (subAllTerm s m)
  | fol.atomic r ts => atomic r (subAllTerms _ ts m)
  | fol.impH f g =>
      impH (subAllFormula f m) (subAllFormula g m)
  | fol.notH f => notH (subAllFormula f m)
  | fol.forallH n f =>
      let nv :=
        newVar
          (freeVarFormula L f ++
           freeVarMap (freeVarFormula L (forallH n f)) m) in
      forallH nv
        (subAllFormula f
           (fun v : nat =>
            match eq_nat_dec v n with
            | left _ => var nv
            | right _ => m v
            end))
  end.

Lemma subAllFormula_ext :
 forall (f : fol.Formula L) (m1 m2 : nat -> fol.Term L),

Lemma freeVarSubAllTerm1 :
 forall (t : fol.Term L) (m : nat -> fol.Term L) (v : nat),

Lemma freeVarSubAllTerms1 :
 forall (n : nat) (ts : fol.Terms L n) (m : nat -> fol.Term L) (v : nat),

Lemma freeVarSubAllTerm2 :
 forall (t : fol.Term L) (m : nat -> fol.Term L) (v n : nat),

Lemma freeVarSubAllTerms2 :
 forall (a : nat) (ts : fol.Terms L a) (m : nat -> fol.Term L) (v n : nat),

Lemma freeVarSubAllFormula1 :
 forall (f : fol.Formula L) (m : nat -> fol.Term L) (v : nat),

Lemma freeVarSubAllFormula2 :
 forall (f : fol.Formula L) (m : nat -> fol.Term L) (v n : nat),

Lemma subSubAllTerm :
 forall (t : fol.Term L) (m : nat -> fol.Term L) (v : nat) (s : fol.Term L),

Lemma subSubAllTerms :
 forall (n : nat) (ts : fol.Terms L n) (m : nat -> fol.Term L) 

Lemma subSubAllFormula :
 forall (T : fol.System L) (f : fol.Formula L) (m : nat -> fol.Term L)

Lemma subAllTermId :
 forall t : fol.Term L, subAllTerm t (fun x : nat => fol.var L x) = t.

Lemma subAllTermsId :
 forall (n : nat) (ts : fol.Terms L n),

Lemma subAllFormulaId :
 forall (T : fol.System L) (f : fol.Formula L),

Lemma subAllSubAllTerm :
 forall (t : fol.Term L) (m1 m2 : nat -> fol.Term L),

Lemma subAllSubAllTerms :
 forall (n : nat) (ts : fol.Terms L n) (m1 m2 : nat -> fol.Term L),

Lemma subAllSubAllFormula :
 forall (T : fol.System L) (f : fol.Formula L) (m1 m2 : nat -> fol.Term L),

Section subAllCloseFrom.

Fixpoint closeFrom (a n : nat) (f : fol.Formula L) {struct n} :
 fol.Formula L :=
  match n with
  | O => f
  | S m => fol.forallH L (a + m) (closeFrom a m f)
  end.

Opaque le_lt_dec.

Lemma liftCloseFrom :
 forall (n : nat) (f : fol.Formula L) (T : fol.System L) (m : nat),

Lemma subAllCloseFrom1 :
 forall (n m : nat) (map : nat -> fol.Term L) (f : fol.Formula L)

Lemma subAllCloseFrom :
 forall (n : nat) (m : nat -> fol.Term L) (f : fol.Formula L)

Lemma reduceSubAll :
 forall (T : fol.System L) (map : nat -> fol.Term L) (A B : fol.Formula L),

End subAllCloseFrom.

Lemma subToSubAll :
 forall (T : fol.System L) (A : fol.Formula L) (v : nat) (s : fol.Term L),

Lemma subAllSubFormula :
 forall (T : fol.System L) (A : fol.Formula L) (v : nat) 

End SubAllVars. *)

Require Import folLogic3.
(* folLogic3:
Require Import Ensembles.
Require Import Coq.Lists.List.
Require Import ListExt.

Require Import folProp.
Require Import folProof.
Require Export folLogic2.
Require Import subProp.
Require Import folReplace.
Require Import Arith.
Require Import subAll.
Require Import misc.

Unset Standard Proposition Elimination Names.

Section Equality_Logic_Rules.

Variable L : Language.
Notation Formula := (Formula L) (only parsing).
Notation Formulas := (Formulas L) (only parsing).
Notation System := (System L) (only parsing).
Notation Term := (Term L) (only parsing).
Notation Terms := (Terms L) (only parsing).
Let var := var L.
Let apply := apply L.
Let equal := equal L.
Let atomic := atomic L.
Let impH := impH L.
Let notH := notH L.
Let forallH := forallH L.
Let orH := orH L.
Let andH := andH L.
Let existH := existH L.
Let iffH := iffH L.
Let ifThenElseH := ifThenElseH L.
Let Prf := Prf L.
Let SysPrf := SysPrf L.

Lemma eqRefl :
 forall (T : fol.System L) (a : fol.Term L), SysPrf T (equal a a).

Lemma eqSym :
 forall (T : fol.System L) (a b : fol.Term L),

Lemma eqTrans :
 forall (T : fol.System L) (a b c : fol.Term L),

Fixpoint PairwiseEqual (T : fol.System L) (n : nat) {struct n} :
 fol.Terms L n -> fol.Terms L n -> Prop :=
  match n return (fol.Terms L n -> fol.Terms L n -> Prop) with
  | O => fun ts ss : fol.Terms L 0 => True
  | S x =>
      fun ts ss : fol.Terms L (S x) =>
      let (a, b) := proj1_sig (consTerms L x ts) in
      let (c, d) := proj1_sig (consTerms L x ss) in
      SysPrf T (equal a c) /\ PairwiseEqual T x b d
  end.

Let termsMap (m : nat) (ts ss : fol.Terms L m) : nat -> fol.Term L.

Remark subAllnVars1 :
 forall (a : nat) (ts ss : fol.Terms L a),

Remark subAllnVars2 :
 forall (a : nat) (ts ss : fol.Terms L a),

Remark addPairwiseEquals :
 forall (T : fol.System L) (n : nat) (ts ss : fol.Terms L n),

Lemma equalRelation :
 forall (T : fol.System L) (r : Relations L) (ts ss : fol.Terms L _),

Lemma equalFunction :
 forall (T : fol.System L) (f : Functions L) (ts ss : fol.Terms L _),

Lemma subWithEqualsTerm :
 forall (a b t : fol.Term L) (v : nat) (T : fol.System L),

Lemma subWithEqualsTerms :
 forall (a b : fol.Term L) (n : nat) (ts : fol.Terms L n) 

Lemma subWithEquals :
 forall (f : fol.Formula L) (v : nat) (a b : fol.Term L) (T : fol.System L),

End Equality_Logic_Rules. *)

Require Export Languages.

Require Export LNT.



Section PA.



Definition PA1 := forallH 0 (notH (equal (Succ (var 0)) Zero)).

Definition PA2 :=

  forallH 1

    (forallH 0

       (impH (equal (Succ (var 0)) (Succ (var 1))) (equal (var 0) (var 1)))).

Definition PA3 := forallH 0 (equal (Plus (var 0) Zero) (var 0)).

Definition PA4 :=

  forallH 1

    (forallH 0

       (equal (Plus (var 0) (Succ (var 1))) (Succ (Plus (var 0) (var 1))))).

Definition PA5 := forallH 0 (equal (Times (var 0) Zero) Zero).

Definition PA6 :=

  forallH 1

    (forallH 0

       (equal (Times (var 0) (Succ (var 1)))

          (Plus (Times (var 0) (var 1)) (var 0)))).

Definition PA7 (f : Formula) (v : nat) : Formula :=

  close LNT

    (impH (substituteFormula LNT f v Zero)

       (impH (forallH v (impH f (substituteFormula LNT f v (Succ (var v)))))

          (forallH v f))).



Definition InductionSchema (f : Formula) : Prop :=

  exists g : Formula, (exists v : nat, f = PA7 g v).



Definition PA :=

  Ensembles.Add _

    (Ensembles.Add _ (Ensembles.Add _ (Ensembles.Add _ (Ensembles.Add _ (Ensembles.Add _ InductionSchema PA1) PA2) PA3) PA4)

       PA5) PA6.



Definition open :=

  Formula_rec LNT (fun _ => Formula) (fun t t0 : Term => equal t t0)

    (fun (r : Relations LNT) (ts : Terms (arity LNT (inl (Functions LNT) r))) =>

     atomic LNT r ts) (fun (f : Formula) _ (f0 : Formula) _ => impH f f0)

    (fun (f : Formula) _ => notH f)

    (fun (n : nat) _ (recf : Formula) => recf).



Lemma PAdec : forall x : Formula, In _ PA x \/ ~ In _ PA x.

intros.

unfold PA in |- *.

induction (formula_dec LNT LNT_dec x PA6).

rewrite a.

left.

right.

constructor.

induction (formula_dec LNT LNT_dec x PA5).

rewrite a.

left.

left; right.

constructor.

induction (formula_dec LNT LNT_dec x PA4).

rewrite a.

left.

do 2 left; right.

constructor.

induction (formula_dec LNT LNT_dec x PA3).

rewrite a.

left.

do 3 left; right.

constructor.

induction (formula_dec LNT LNT_dec x PA2).

rewrite a.

left.

do 4 left; right.

constructor.

induction (formula_dec LNT LNT_dec x PA1).

rewrite a.

left.

do 5 left; right.

constructor.

cut (In Formula InductionSchema x \/ ~ In Formula InductionSchema x).

intros.

induction H as [H| H].

left.

do 6 left.

assumption.

right.

unfold not in |- *; intros.

repeat tauto || induction H0.

clear b b0 b1 b2 b3 b4.

assert

 (forall y : Formula,

  (exists f : Formula,

     (exists v : nat,

        impH (substituteFormula LNT f v Zero)

          (impH

             (forallH v (impH f (substituteFormula LNT f v (Succ (var v)))))

             (forallH v f)) = y)) \/

  ~

  (exists f : Formula,

     (exists v : nat,

        impH (substituteFormula LNT f v Zero)

          (impH

             (forallH v (impH f (substituteFormula LNT f v (Succ (var v)))))

             (forallH v f)) = y))).

intros.

destruct y as [t t0| r t| f f0| f| n f];

 try (right; unfold not in |- *; intros; decompose record H; discriminate H1).

destruct f0 as [t t0| r t| f0 f1| f0| n f0];

 try (right; unfold not in |- *; intros; decompose record H; discriminate H1).

destruct f0 as [t t0| r t| f0 f2| f0| n f0];

 try (right; unfold not in |- *; intros; decompose record H; discriminate H1).

destruct f1 as [t t0| r t| f1 f2| f1| n0 f1];

 try (right; unfold not in |- *; intros; decompose record H; discriminate H1).

do 4 fold impH in |- *.

do 4 fold forallH in |- *.

induction (formula_dec LNT LNT_dec (substituteFormula LNT f1 n0 Zero) f).

rewrite <- a.

clear a f.

destruct f0 as [t t0| r t| f f0| f| n1 f];

 try (right; unfold not in |- *; intros; decompose record H; discriminate H1).

induction (formula_dec LNT LNT_dec f1 f).

rewrite <- a.

clear a f.

induction

 (formula_dec LNT LNT_dec (substituteFormula LNT f1 n0 (Succ (var n0))) f0).

rewrite <- a.

clear a f0.

induction (eq_nat_dec n n0).

rewrite a.

left.

exists f1.

exists n0.

reflexivity.

right; unfold not in |- *; intros; apply b; decompose record H.

inversion H1.

auto.

right; unfold not in |- *; intros; apply b; decompose record H.

inversion H1.

auto.

right; unfold not in |- *; intros; apply b; decompose record H.

inversion H1.

auto.

right; unfold not in |- *; intros; apply b; decompose record H.

inversion H1.

auto.

induction (formula_dec LNT LNT_dec x (close LNT (open x))).

induction (H (open x)).

left.

unfold In, InductionSchema, PA7 in |- *.

decompose record H0.

exists x0.

exists x1.

rewrite H2.

assumption.

right.

unfold not in |- *; intros; apply H0.

unfold In, InductionSchema, PA7 in H1.

decompose record H1.

exists x0.

exists x1.

rewrite H3.

unfold close in |- *.

induction

 (ListExt.no_dup nat eq_nat_dec

    (freeVarFormula LNT

       (impH (substituteFormula LNT x0 x1 Zero)

          (impH

             (forallH x1

                (impH x0 (substituteFormula LNT x0 x1 (Succ (var x1)))))

             (forallH x1 x0))))).

simpl in |- *.

reflexivity.

simpl in |- *.

assumption.

right.

unfold not in |- *; intros; apply b.

unfold In, InductionSchema, PA7 in H0.

decompose record H0.

rewrite H2.

replace

 (open

    (close LNT

       (impH (substituteFormula LNT x0 x1 Zero)

          (impH

             (forallH x1

                (impH x0 (substituteFormula LNT x0 x1 (Succ (var x1)))))

             (forallH x1 x0))))) with

 (impH (substituteFormula LNT x0 x1 Zero)

    (impH

       (forallH x1 (impH x0 (substituteFormula LNT x0 x1 (Succ (var x1)))))

       (forallH x1 x0))).

reflexivity.

unfold close in |- *.

induction

 (ListExt.no_dup nat eq_nat_dec

    (freeVarFormula LNT

       (impH (substituteFormula LNT x0 x1 Zero)

          (impH

             (forallH x1

                (impH x0 (substituteFormula LNT x0 x1 (Succ (var x1)))))

             (forallH x1 x0))))).

simpl in |- *.

reflexivity.

simpl in |- *.

auto.

Qed.



Lemma closedPA1 : ClosedSystem LNT PA.

Proof.

unfold ClosedSystem in |- *.

unfold PA in |- *.

intros.

induction H as [x H| x H].

induction H as [x H| x H].

induction H as [x H| x H].

induction H as [x H| x H].

induction H as [x H| x H].

induction H as [x H| x H].

induction H as (x0, H).

induction H as (x1, H).

unfold PA7 in H.

rewrite H.

apply freeVarClosed.

induction H; auto.

induction H; auto.

induction H; auto.

induction H; auto.

induction H; auto.

induction H; auto.

Qed.



Lemma closedPA : forall v : nat, ~ In_freeVarSys LNT v PA.

Proof.

unfold not in |- *; intros.

unfold In_freeVarSys in H.

induction H as (x, H).

elim closedPA1 with v x; tauto.

Qed.



Lemma pa1 : forall a : Term, SysPrf PA (notH (equal (Succ a) Zero)).

Proof.

intros.

replace (notH (equal (Succ a) Zero)) with

 (substituteFormula LNT (notH (equal (Succ (var 0)) Zero)) 0 a).

apply forallE.

apply Axm; repeat (try right; constructor) || left.

reflexivity.

Qed.



Lemma pa2 :

 forall a b : Term, SysPrf PA (impH (equal (Succ a) (Succ b)) (equal a b)).

Proof.

intros.

set (m := fun x : nat => match x with

                         | O => a

                         | S _ => b

                         end) in *.

replace (impH (equal (Succ a) (Succ b)) (equal a b)) with

 (subAllFormula LNT

    (impH (equal (Succ (var 0)) (Succ (var 1))) (equal (var 0) (var 1)))

    (fun x : nat =>

     match le_lt_dec 2 x with

     | left _ => var x

     | right _ => m x

     end)).

apply (subAllCloseFrom LNT).

simpl in |- *.

apply Axm; repeat (try right; constructor) || left.

simpl in |- *.

induction (le_lt_dec 2 0).

elim (le_not_lt _ _ a0).

auto.

induction (le_lt_dec 2 1).

elim (le_not_lt _ _ a0).

auto.

reflexivity.

Qed.



Lemma pa3 : forall a : Term, SysPrf PA (equal (Plus a Zero) a).

Proof.

intros.

replace (equal (Plus a Zero) a) with

 (substituteFormula LNT (equal (Plus (var 0) Zero) (var 0)) 0 a).

apply forallE.

apply Axm; repeat (try right; constructor) || left.

reflexivity.

Qed.



Lemma pa4 :

 forall a b : Term, SysPrf PA (equal (Plus a (Succ b)) (Succ (Plus a b))).

Proof.

intros.

set (m := fun x : nat => match x with

                         | O => a

                         | S _ => b

                         end) in *.

replace (equal (Plus a (Succ b)) (Succ (Plus a b))) with

 (subAllFormula LNT

    (equal (Plus (var 0) (Succ (var 1))) (Succ (Plus (var 0) (var 1))))

    (fun x : nat =>

     match le_lt_dec 2 x with

     | left _ => var x

     | right _ => m x

     end)).

apply (subAllCloseFrom LNT).

simpl in |- *.

apply Axm; repeat (try right; constructor) || left.

simpl in |- *.

induction (le_lt_dec 2 0).

elim (le_not_lt _ _ a0).

auto.

induction (le_lt_dec 2 1).

elim (le_not_lt _ _ a0).

auto.

reflexivity.

Qed.



Lemma pa5 : forall a : Term, SysPrf PA (equal (Times a Zero) Zero).

Proof.

intros.

replace (equal (Times a Zero) Zero) with

 (substituteFormula LNT (equal (Times (var 0) Zero) Zero) 0 a).

apply forallE.

apply Axm; repeat (try right; constructor) || left.

reflexivity.

Qed.



Lemma pa6 :

 forall a b : Term, SysPrf PA (equal (Times a (Succ b)) (Plus (Times a b) a)).

Proof.

intros.

set (m := fun x : nat => match x with

                         | O => a

                         | S _ => b

                         end) in *.

replace (equal (Times a (Succ b)) (Plus (Times a b) a)) with

 (subAllFormula LNT

    (equal (Times (var 0) (Succ (var 1)))

       (Plus (Times (var 0) (var 1)) (var 0)))

    (fun x : nat =>

     match le_lt_dec 2 x with

     | left _ => var x

     | right _ => m x

     end)).

apply (subAllCloseFrom LNT).

simpl in |- *.

apply Axm; repeat (try right; constructor) || left.

simpl in |- *.

induction (le_lt_dec 2 0).

elim (le_not_lt _ _ a0).

auto.

induction (le_lt_dec 2 1).

elim (le_not_lt _ _ a0).

auto.

reflexivity.

Qed.



Lemma induct :

 forall (f : Formula) (v : nat),

 SysPrf PA (substituteFormula LNT f v Zero) ->

 SysPrf PA (forallH v (impH f (substituteFormula LNT f v (Succ (var v))))) ->

 SysPrf PA (forallH v f).

Proof.

intros.

eapply impE.

eapply impE.

apply (openClosed LNT).

apply Axm.

repeat left.

unfold InductionSchema in |- *.

unfold In in |- *.

unfold PA7 in |- *.

exists f.

exists v.

reflexivity.

apply H.

apply H0.

Qed.



End PA.

