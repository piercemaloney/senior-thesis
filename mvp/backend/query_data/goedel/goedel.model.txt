Require Import Ensembles.
Require Import Coq.Lists.List.
Require Import ListExt.
(* ListExt:
Require Import Coq.Lists.List.

Section List_Remove.

Variable A : Set.
Hypothesis Aeq_dec : forall a b : A, {a = b} + {a <> b}.

Definition list_remove (x : A) (l : list A) : list A :=
  list_rec (fun _ => list A) nil
    (fun (a : A) _ (recl : list A) =>
     match Aeq_dec a x with
     | left _ => recl
     | right _ => a :: recl
     end) l.

Lemma In_list_remove1 :
 forall (a b : A) (l : list A), In a (list_remove b l) -> In a l.

Lemma In_list_remove2 :
 forall (a b : A) (l : list A), In a (list_remove b l) -> a <> b.

Lemma In_list_remove3 :
 forall (a b : A) (l : list A), In a l -> a <> b -> In a (list_remove b l).

End List_Remove.

Section No_Duplicate.

Variable A : Set.
Hypothesis Aeq_dec : forall a b : A, {a = b} + {a <> b}.

Definition no_dup (l : list A) : list A :=
  list_rec (fun _ => list A) nil
    (fun (a : A) _ (rec : list A) =>
     match In_dec Aeq_dec a rec with
     | left _ => rec
     | right _ => a :: rec
     end) l.

Lemma no_dup1 : forall (a : A) (l : list A), In a l -> In a (no_dup l).

Lemma no_dup2 : forall (a : A) (l : list A), In a (no_dup l) -> In a l.

Lemma no_dup3 : forall (k l : list A) (a : A), no_dup k = a :: l -> ~ In a l.

End No_Duplicate. *)
Require Import folProof.
(* folProof:
Require Import Ensembles.
Require Import Coq.Lists.List.
Require Import Arith.

Require Export fol.
Require Import folProp.

Section ProofH.

Variable L : Language.

Let Formula := Formula L.
Let Formulas := Formulas L.
Let System := System L.
Let Term := Term L.
Let Terms := Terms L.
Let var := var L.
Let apply := apply L.
Let equal := equal L.
Let atomic := atomic L.
Let impH := impH L.
Let notH := notH L.
Let iffH := iffH L.
Let forallH := forallH L.

Definition nVars (n : nat) : Terms n * Terms n.

Definition AxmEq4 (R : Relations L) : Formula.

Definition AxmEq5 (f : Functions L) : Formula.

Inductive Prf : Formulas -> Formula -> Set :=
  | AXM : forall A : Formula, Prf (A :: nil) A
  | MP :
      forall (Axm1 Axm2 : Formulas) (A B : Formula),
      Prf Axm1 (impH A B) -> Prf Axm2 A -> Prf (Axm1 ++ Axm2) B
  | GEN :
      forall (Axm : Formulas) (A : Formula) (v : nat),
      ~ In v (freeVarListFormula L Axm) -> Prf Axm A -> Prf Axm (forallH v A)
  | IMP1 : forall A B : Formula, Prf nil (impH A (impH B A))
  | IMP2 :
      forall A B C : Formula,
      Prf nil (impH (impH A (impH B C)) (impH (impH A B) (impH A C)))
  | CP :
      forall A B : Formula,
      Prf nil (impH (impH (notH A) (notH B)) (impH B A))
  | FA1 :
      forall (A : Formula) (v : nat) (t : Term),
      Prf nil (impH (forallH v A) (substituteFormula L A v t))
  | FA2 :
      forall (A : Formula) (v : nat),
      ~ In v (freeVarFormula L A) -> Prf nil (impH A (forallH v A))
  | FA3 :
      forall (A B : Formula) (v : nat),
      Prf nil
        (impH (forallH v (impH A B)) (impH (forallH v A) (forallH v B)))
  | EQ1 : Prf nil (equal (var 0) (var 0))
  | EQ2 : Prf nil (impH (equal (var 0) (var 1)) (equal (var 1) (var 0)))
  | EQ3 :
      Prf nil
        (impH (equal (var 0) (var 1))
           (impH (equal (var 1) (var 2)) (equal (var 0) (var 2))))
  | EQ4 : forall R : Relations L, Prf nil (AxmEq4 R)
  | EQ5 : forall f : Functions L, Prf nil (AxmEq5 f).

Definition SysPrf (T : System) (f : Formula) :=
  exists Axm : Formulas,
    (exists prf : Prf Axm f,
       (forall g : Formula, In g Axm -> mem _ T g)).

Definition Inconsistent (T : System) := forall f : Formula, SysPrf T f.

Definition Consistent (T : System) := exists f : Formula, ~ SysPrf T f.

End ProofH. *)
Require Import folProp.
(* folProp:
Require Import Wf_nat.
Require Import Max.
Require Import Arith.
Require Import Coq.Lists.List.
Require Import ListExt.
Require Import Peano_dec.

Require Export fol.

Section Fol_Properties.

Variable L : Language.

Notation Formula := (Formula L) (only parsing).
Notation Formulas := (Formulas L) (only parsing).
Notation System := (System L) (only parsing).
Notation Term := (Term L) (only parsing).
Notation Terms := (Terms L) (only parsing).
Let var := var L.
Let apply := apply L.
Let equal := equal L.
Let atomic := atomic L.
Let impH := impH L.
Let notH := notH L.
Let forallH := forallH L.
Let lt_depth := lt_depth L.

Section Free_Variables.

Fixpoint freeVarTerm (s : fol.Term L) : list nat :=
  match s with
  | fol.var v => v :: nil
  | fol.apply f ts => freeVarTerms (arity L (inr _ f)) ts
  end
 
 with freeVarTerms (n : nat) (ss : fol.Terms L n) {struct ss} : 
 list nat :=
  match ss with
  | Tnil => nil (A:=nat)
  | Tcons m t ts => freeVarTerm t ++ freeVarTerms m ts
  end.

Lemma freeVarTermApply :
 forall (f : Functions L) (ts : fol.Terms L _),

Fixpoint freeVarFormula (A : fol.Formula L) : list nat :=
  match A with
  | fol.equal t s => freeVarTerm t ++ freeVarTerm s
  | fol.atomic r ts => freeVarTerms _ ts
  | fol.impH A B => freeVarFormula A ++ freeVarFormula B
  | fol.notH A => freeVarFormula A
  | fol.forallH v A => list_remove _ eq_nat_dec v (freeVarFormula A)
  end.

Definition ClosedSystem (T : fol.System L) :=
  forall (v : nat) (f : fol.Formula L),
  mem _ T f -> ~ In v (freeVarFormula f).

Definition closeList (l : list nat) (x : fol.Formula L) : 
  fol.Formula L :=
  list_rec (fun _ => fol.Formula L) x
    (fun (a : nat) _ (rec : fol.Formula L) => forallH a rec) l.

Definition close (x : fol.Formula L) : fol.Formula L :=
  closeList (no_dup _ eq_nat_dec (freeVarFormula x)) x.

Lemma freeVarClosedList1 :
 forall (l : list nat) (v : nat) (x : fol.Formula L),

Lemma freeVarClosedList2 :
 forall (l : list nat) (v : nat) (x : fol.Formula L),

Lemma freeVarClosed :
 forall (x : fol.Formula L) (v : nat), ~ In v (freeVarFormula (close x)).

Fixpoint freeVarListFormula (l : fol.Formulas L) : 
 list nat :=
  match l with
  | nil => nil (A:=nat)
  | f :: l => freeVarFormula f ++ freeVarListFormula l
  end.

Lemma freeVarListFormulaApp :
 forall a b : fol.Formulas L,

Lemma In_freeVarListFormula :
 forall (v : nat) (f : fol.Formula L) (F : fol.Formulas L),

Lemma In_freeVarListFormulaE :
 forall (v : nat) (F : fol.Formulas L),

Definition In_freeVarSys (v : nat) (T : fol.System L) :=
  exists f : fol.Formula L, In v (freeVarFormula f) /\ mem _ T f.

Lemma notInFreeVarSys :
 forall x, ~ In_freeVarSys x (Ensembles.Empty_set (fol.Formula L)).

End Free_Variables.

Section Substitution.

Fixpoint substituteTerm (s : fol.Term L) (x : nat) 
 (t : fol.Term L) {struct s} : fol.Term L :=
  match s with
  | fol.var v =>
      match eq_nat_dec x v with
      | left _ => t
      | right _ => var v
      end
  | fol.apply f ts => apply f (substituteTerms _ ts x t)
  end
 
 with substituteTerms (n : nat) (ss : fol.Terms L n) 
 (x : nat) (t : fol.Term L) {struct ss} : fol.Terms L n :=
  match ss in (fol.Terms _ n0) return (fol.Terms L n0) with
  | Tnil => Tnil L
  | Tcons m s ts =>
      Tcons L m (substituteTerm s x t) (substituteTerms m ts x t)
  end.

Lemma subTermVar1 :
 forall (v : nat) (s : fol.Term L), substituteTerm (var v) v s = s.

Lemma subTermVar2 :
 forall (v x : nat) (s : fol.Term L),

Lemma subTermFunction :
 forall (f : Functions L) (ts : fol.Terms L (arity L (inr _ f))) 

Definition newVar (l : list nat) : nat := fold_right max 0 (map S l).

Lemma newVar2 : forall (l : list nat) (n : nat), In n l -> n < newVar l.

Lemma newVar1 : forall l : list nat, ~ In (newVar l) l.

Definition substituteFormulaImp (f : fol.Formula L)
  (frec : nat * fol.Term L -> {y : fol.Formula L | depth L y = depth L f})
  (g : fol.Formula L)
  (grec : nat * fol.Term L -> {y : fol.Formula L | depth L y = depth L g})
  (p : nat * fol.Term L) :
  {y : fol.Formula L | depth L y = depth L (impH f g)} :=
  match frec p with
  | exist f' prf1 =>
      match grec p with
      | exist g' prf2 =>
          exist
            (fun y : fol.Formula L =>
             depth L y = S (max (depth L f) (depth L g))) 
            (impH f' g')
            (eq_ind_r
               (fun n : nat =>
                S (max n (depth L g')) = S (max (depth L f) (depth L g)))
               (eq_ind_r
                  (fun n : nat =>
                   S (max (depth L f) n) = S (max (depth L f) (depth L g)))
                  (refl_equal (S (max (depth L f) (depth L g)))) prf2) prf1)
      end
  end.

Remark substituteFormulaImpNice :
 forall (f g : fol.Formula L)

Definition substituteFormulaNot (f : fol.Formula L)
  (frec : nat * fol.Term L -> {y : fol.Formula L | depth L y = depth L f})
  (p : nat * fol.Term L) :
  {y : fol.Formula L | depth L y = depth L (notH f)} :=
  match frec p with
  | exist f' prf1 =>
      exist (fun y : fol.Formula L => depth L y = S (depth L f)) 
        (notH f')
        (eq_ind_r (fun n : nat => S n = S (depth L f))
           (refl_equal (S (depth L f))) prf1)
  end.

Remark substituteFormulaNotNice :
 forall (f : fol.Formula L)

Definition substituteFormulaForall (n : nat) (f : fol.Formula L)
  (frec : forall b : fol.Formula L,
          lt_depth b (forallH n f) ->
          nat * fol.Term L -> {y : fol.Formula L | depth L y = depth L b})
  (p : nat * fol.Term L) :
  {y : fol.Formula L | depth L y = depth L (forallH n f)} :=
  match p with
  | (v, s) =>
      match eq_nat_dec n v with
      | left _ =>
          exist (fun y : fol.Formula L => depth L y = S (depth L f))
            (forallH n f) (refl_equal (depth L (forallH n f)))
      | right _ =>
          match In_dec eq_nat_dec n (freeVarTerm s) with
          | left _ =>
              let nv := newVar (v :: freeVarTerm s ++ freeVarFormula f) in
              match frec f (depthForall L f n) (n, var nv) with
              | exist f' prf1 =>
                  match
                    frec f'
                      (eqDepth L f' f (forallH n f) 
                         (sym_eq prf1) (depthForall L f n)) p
                  with
                  | exist f'' prf2 =>
                      exist
                        (fun y : fol.Formula L => depth L y = S (depth L f))
                        (forallH nv f'')
                        (eq_ind_r (fun n : nat => S n = S (depth L f))
                           (refl_equal (S (depth L f))) 
                           (trans_eq prf2 prf1))
                  end
              end
          | right _ =>
              match frec f (depthForall L f n) p with
              | exist f' prf1 =>
                  exist (fun y : fol.Formula L => depth L y = S (depth L f))
                    (forallH n f')
                    (eq_ind_r (fun n : nat => S n = S (depth L f))
                       (refl_equal (S (depth L f))) prf1)
              end
          end
      end
  end.

Remark substituteFormulaForallNice :
 forall (v : nat) (a : fol.Formula L)

Definition substituteFormulaHelp (f : fol.Formula L) 

Definition substituteFormula (f : fol.Formula L) (v : nat) 
  (s : fol.Term L) : fol.Formula L := proj1_sig (substituteFormulaHelp f v s).

Lemma subFormulaEqual :
 forall (t1 t2 : fol.Term L) (v : nat) (s : fol.Term L),

Lemma subFormulaRelation :
 forall (r : Relations L) (ts : fol.Terms L (arity L (inl _ r))) 

Lemma subFormulaImp :
 forall (f1 f2 : fol.Formula L) (v : nat) (s : fol.Term L),

Lemma subFormulaNot :
 forall (f : fol.Formula L) (v : nat) (s : fol.Term L),

Lemma subFormulaForall :
 forall (f : fol.Formula L) (x v : nat) (s : fol.Term L),

Section Extensions.

Let orH := orH L.
Let andH := andH L.
Let existH := existH L.
Let iffH := iffH L.
Let ifThenElseH := ifThenElseH L.

Lemma subFormulaOr :
 forall (f1 f2 : fol.Formula L) (v : nat) (s : fol.Term L),

Lemma subFormulaAnd :
 forall (f1 f2 : fol.Formula L) (v : nat) (s : fol.Term L),

Lemma subFormulaExist :
 forall (f : fol.Formula L) (x v : nat) (s : fol.Term L),

Lemma subFormulaIff :
 forall (f1 f2 : fol.Formula L) (v : nat) (s : fol.Term L),

Lemma subFormulaIfThenElse :
 forall (f1 f2 f3 : fol.Formula L) (v : nat) (s : fol.Term L),

End Extensions.

Lemma subFormulaDepth :
 forall (f : fol.Formula L) (v : nat) (s : fol.Term L),

Section Substitution_Properties.

Lemma subTermId :
 forall (t : fol.Term L) (v : nat), substituteTerm t v (var v) = t.

Lemma subTermsId :
 forall (n : nat) (ts : fol.Terms L n) (v : nat),

Lemma subFormulaId :
 forall (f : fol.Formula L) (v : nat), substituteFormula f v (var v) = f.

Lemma subFormulaForall2 :
 forall (f : fol.Formula L) (x v : nat) (s : fol.Term L),

Let existH := existH L.

Lemma subFormulaExist2 :
 forall (f : fol.Formula L) (x v : nat) (s : fol.Term L),

End Substitution_Properties.

End Substitution.
 
Definition Sentence (f:Formula) := (forall v : nat, ~ In v (freeVarFormula f)).

End Fol_Properties. *)
Require Vector.
Require Import Peano_dec.
Require Import misc.
(* misc:
Require Import Eqdep_dec.

Global Set Asymmetric Patterns.

Lemma inj_right_pair2 :
 forall A : Set,
 (forall x y : A, {x = y} + {x <> y}) ->
 forall (x : A) (P : A -> Set) (y y' : P x),
 existS P x y = existS P x y' -> y = y'. *)
Require Import Arith.

Section Model_Theory.

Variable L : Language.

Fixpoint naryFunc (A : Set) (n : nat) {struct n} : Set :=
  match n with
  | O => A
  | S m => A -> naryFunc A m
  end.

Fixpoint naryRel (A : Set) (n : nat) {struct n} : Type :=
  match n with
  | O => Prop
  | S m => A -> naryRel A m
  end.

Record Model : Type := model
  {U : Set;
   func : forall f : Functions L, naryFunc U (arity L (inr _ f));
   rel : forall r : Relations L, naryRel U (arity L (inl _ r))}.

Variable M : Model.

Fixpoint interpTerm (value : nat -> U M) (t : Term L) {struct t} : 
 U M :=
  match t with
  | var v => value v
  | apply f ts => interpTerms _ (func M f) value ts
  end
 
 with interpTerms (m : nat) (f : naryFunc (U M) m) 
 (value : nat -> U M) (ts : Terms L m) {struct ts} : 
 U M :=
  match ts in (Terms _ n) return (naryFunc (U M) n -> U M) with
  | Tnil => fun f => f
  | Tcons m t ts => fun f => interpTerms m (f (interpTerm value t)) value ts
  end f.

Fixpoint interpRels (m : nat) (r : naryRel (U M) m) 
 (value : nat -> U M) (ts : Terms L m) {struct ts} : Prop :=
  match ts in (Terms _ n) return (naryRel (U M) n -> Prop) with
  | Tnil => fun r => r
  | Tcons m t ts => fun r => interpRels m (r (interpTerm value t)) value ts
  end r.

Definition updateValue (value : nat -> U M) (n : nat) 
  (v : U M) (x : nat) : U M :=
  match eq_nat_dec n x with
  | left _ => v
  | right _ => value x
  end.

Fixpoint interpFormula (value : nat -> U M) (f : Formula L) {struct f} :
 Prop :=
  match f with
  | equal t s => interpTerm value t = interpTerm value s
  | atomic r ts => interpRels _ (rel M r) value ts
  | impH A B => interpFormula value A -> interpFormula value B
  | notH A => interpFormula value A -> False
  | forallH v A => forall x : U M, interpFormula (updateValue value v x) A
  end.

Lemma freeVarInterpTerm :
 forall (v1 v2 : nat -> U M) (t : Term L),
 (forall x : nat, In x (freeVarTerm L t) -> v1 x = v2 x) ->
 interpTerm v1 t = interpTerm v2 t.
Proof.
intros v1 v2 t.
elim t using
 Term_Terms_ind
  with
    (P0 := fun (n : nat) (ts : Terms L n) =>
           forall f : naryFunc (U M) n,
           (forall x : nat, In x (freeVarTerms L n ts) -> v1 x = v2 x) ->
           interpTerms n f v1 ts = interpTerms n f v2 ts); 
 simpl in |- *; intros.
apply H.
auto.
apply H.
intros.
apply H0.
apply H1.
auto.
rewrite H.
apply H0.
intros.
apply H1.
unfold freeVarTerms in |- *.
apply in_or_app.
right.
apply H2.
intros.
apply H1.
unfold freeVarTerms in |- *.
apply in_or_app.
left.
apply H2.
Qed.

Lemma freeVarInterpRel :
 forall (v1 v2 : nat -> U M) (n : nat) (ts : Terms L n) (r : naryRel (U M) n),
 (forall x : nat, In x (freeVarTerms L n ts) -> v1 x = v2 x) ->
 interpRels n r v1 ts -> interpRels n r v2 ts.
Proof.
intros v1 v2 n ts r H.
induction ts as [| n t ts Hrects]; simpl in |- *.
auto.
rewrite (freeVarInterpTerm v1 v2).
apply Hrects.
intros.
apply H.
unfold freeVarTerms in |- *.
apply in_or_app.
right.
apply H0.
intros.
apply H.
unfold freeVarTerms in |- *.
apply in_or_app.
left.
apply H0.
Qed.

Lemma freeVarInterpFormula :
 forall (v1 v2 : nat -> U M) (g : Formula L),
 (forall x : nat, In x (freeVarFormula L g) -> v1 x = v2 x) ->
 interpFormula v1 g -> interpFormula v2 g.
Proof.
intros v1 v2 g.
generalize v1 v2.
clear v1 v2.
induction g as [t t0| r t| g1 Hrecg1 g0 Hrecg0| g Hrecg| n g Hrecg];
 simpl in |- *; intros v1 v2 H.
repeat rewrite (freeVarInterpTerm v1 v2).
auto.
intros.
apply H.
simpl in |- *.
auto with datatypes.
intros.
apply H.
simpl in |- *.
auto with datatypes.
intros.
apply (freeVarInterpRel v1 v2).
apply H.
apply H0.
assert (interpFormula v2 g1 -> interpFormula v1 g1).
apply Hrecg1.
intros.
symmetry  in |- *.
apply H.
simpl in |- *.
auto with datatypes.
assert (interpFormula v1 g0 -> interpFormula v2 g0).
apply Hrecg0.
intros.
apply H.
simpl in |- *.
auto with datatypes.
tauto.
intros.
apply H0.
apply Hrecg with v2.
intros.
symmetry  in |- *.
auto.
assumption.
intros.
apply Hrecg with (updateValue v1 n x).
intros.
unfold updateValue in |- *.
induction (eq_nat_dec n x0).
reflexivity.
apply H.
apply In_list_remove3; auto.
auto.
Qed.

Lemma subInterpTerm :
 forall (value : nat -> U M) (t : Term L) (v : nat) (s : Term L),
 interpTerm (updateValue value v (interpTerm value s)) t =
 interpTerm value (substituteTerm L t v s).
Proof.
intros.
elim t using
 Term_Terms_ind
  with
    (P0 := fun (n : nat) (ts : Terms L n) =>
           forall f : naryFunc (U M) n,
           interpTerms n f (updateValue value v (interpTerm value s)) ts =
           interpTerms n f value (substituteTerms L n ts v s)); 
 simpl in |- *; intros.
unfold updateValue in |- *.
induction (eq_nat_dec v n); reflexivity.
rewrite H.
reflexivity.
reflexivity.
rewrite H.
apply H0.
Qed.

Lemma subInterpRel :
 forall (value : nat -> U M) (n : nat) (ts : Terms L n) 
   (v : nat) (s : Term L) (r : naryRel (U M) n),
 interpRels n r (updateValue value v (interpTerm value s)) ts <->
 interpRels n r value (substituteTerms L n ts v s).
Proof.
intros.
induction ts as [| n t ts Hrects].
simpl in |- *.
tauto.
simpl in |- *.
rewrite <- subInterpTerm.
apply Hrects.
Qed.

Lemma subInterpFormula :
 forall (value : nat -> U M) (f : Formula L) (v : nat) (s : Term L),
 interpFormula (updateValue value v (interpTerm value s)) f <->
 interpFormula value (substituteFormula L f v s).
Proof.
intros value f.
generalize value.
clear value.
elim f using Formula_depth_ind2; simpl in |- *; intros.
repeat rewrite subInterpTerm.
tauto.
apply subInterpRel.
rewrite (subFormulaImp L).
simpl in |- *.
assert
 (interpFormula (updateValue value v (interpTerm value s)) f1 <->
  interpFormula value (substituteFormula L f1 v s)).
auto.
assert
 (interpFormula (updateValue value v (interpTerm value s)) f0 <->
  interpFormula value (substituteFormula L f0 v s)).
auto.
tauto.
rewrite (subFormulaNot L).
simpl in |- *.
assert
 (interpFormula (updateValue value v (interpTerm value s)) f0 <->
  interpFormula value (substituteFormula L f0 v s)).
auto.
tauto.
rewrite (subFormulaForall L).
induction (eq_nat_dec v v0).
rewrite a0.
simpl in |- *.
unfold updateValue in |- *.
split.
intros.
apply
 freeVarInterpFormula
  with
    (fun x0 : nat =>
     match eq_nat_dec v0 x0 with
     | left _ => x
     | right _ =>
         match eq_nat_dec v0 x0 with
         | left _ => interpTerm value s
         | right _ => value x0
         end
     end).
intros.
induction (eq_nat_dec v0 x0); reflexivity.
auto.
intros.
apply
 freeVarInterpFormula
  with
    (fun x0 : nat =>
     match eq_nat_dec v0 x0 with
     | left _ => x
     | right _ => value x0
     end).
intros.
induction (eq_nat_dec v0 x0); reflexivity.
auto.
induction (In_dec eq_nat_dec v (freeVarTerm L s)).
simpl in |- *.
set (nv := newVar (v0 :: freeVarTerm L s ++ freeVarFormula L a)) in *.
assert (~ In nv (v0 :: freeVarTerm L s ++ freeVarFormula L a)).
unfold nv in |- *.
apply newVar1.
assert
 (forall (x : U M) (x0 : nat),
  In x0 (freeVarFormula L a) ->
  updateValue (updateValue value v0 (interpTerm value s)) v x x0 =
  updateValue
    (updateValue (updateValue value nv x) v0
       (interpTerm (updateValue value nv x) s)) v
    (interpTerm
       (updateValue (updateValue value nv x) v0
          (interpTerm (updateValue value nv x) s)) 
       (var L nv)) x0).
intros.
unfold updateValue in |- *.
simpl in |- *.
induction (eq_nat_dec v x0).
induction (eq_nat_dec v0 nv).
elim H0.
rewrite a2.
simpl in |- *.
auto.
induction (eq_nat_dec nv nv).
reflexivity.
elim b1.
reflexivity.
induction (eq_nat_dec v0 x0).
apply freeVarInterpTerm.
intros.
induction (eq_nat_dec nv x1).
elim H0.
rewrite a2.
simpl in |- *.
auto with datatypes.
reflexivity.
induction (eq_nat_dec nv x0).
elim H0.
rewrite a1.
auto with datatypes.
reflexivity.
assert
 ((forall x : U M,
   interpFormula
     (updateValue
        (updateValue (updateValue value nv x) v0
           (interpTerm (updateValue value nv x) s)) v
        (interpTerm
           (updateValue (updateValue value nv x) v0
              (interpTerm (updateValue value nv x) s)) 
           (var L nv))) a) <->
  (forall x : U M,
   interpFormula (updateValue value nv x)
     (substituteFormula L (substituteFormula L a v (var L nv)) v0 s))).
split.
assert
 (forall b : Formula L,
  lt_depth L b (forallH L v a) ->
  forall (value : nat -> U M) (v : nat) (s : Term L),
  interpFormula (updateValue value v (interpTerm value s)) b ->
  interpFormula value (substituteFormula L b v s)).
intros.
induction (H b0 H2 value0 v1 s0).
auto.
intros.
apply H2.
eapply eqDepth.
symmetry  in |- *.
apply subFormulaDepth.
apply depthForall.
apply H2.
apply depthForall.
apply H3.
intros.
assert
 (forall b : Formula L,
  lt_depth L b (forallH L v a) ->
  forall (value : nat -> U M) (v : nat) (s : Term L),
  interpFormula value (substituteFormula L b v s) ->
  interpFormula (updateValue value v (interpTerm value s)) b).
intros.
induction (H b0 H3 value0 v1 s0).
auto.
clear H.
intros.
apply H3.
apply depthForall.
apply H3.
eapply eqDepth.
symmetry  in |- *.
apply subFormulaDepth.
apply depthForall.
auto.
assert
 ((forall x : U M,
   interpFormula
     (updateValue (updateValue value v0 (interpTerm value s)) v x) a) <->
  (forall x : U M,
   interpFormula
     (updateValue
        (updateValue (updateValue value nv x) v0
           (interpTerm (updateValue value nv x) s)) v
        (interpTerm
           (updateValue (updateValue value nv x) v0
              (interpTerm (updateValue value nv x) s)) 
           (var L nv))) a)).
split.
intros.
apply
 freeVarInterpFormula
  with (updateValue (updateValue value v0 (interpTerm value s)) v x).
auto.
auto.
intros.
apply
 freeVarInterpFormula
  with
    (updateValue
       (updateValue (updateValue value nv x) v0
          (interpTerm (updateValue value nv x) s)) v
       (interpTerm
          (updateValue (updateValue value nv x) v0
             (interpTerm (updateValue value nv x) s)) 
          (var L nv))).
intros.
symmetry  in |- *.
auto.
auto.
tauto.
simpl in |- *.
assert
 (forall (x : U M) (x0 : nat),
  In x0 (freeVarFormula L a) ->
  updateValue (updateValue value v0 (interpTerm value s)) v x x0 =
  updateValue (updateValue value v x) v0
    (interpTerm (updateValue value v x) s) x0).
intros.
unfold updateValue in |- *.
induction (eq_nat_dec v x0).
induction (eq_nat_dec v0 x0).
elim b.
transitivity x0; auto.
reflexivity.
induction (eq_nat_dec v0 x0).
apply freeVarInterpTerm.
intros.
induction (eq_nat_dec v x1).
elim b0.
rewrite a1.
auto.
reflexivity.
reflexivity.
split.
intros.
assert
 (forall b : Formula L,
  lt_depth L b (forallH L v a) ->
  forall (value : nat -> U M) (v : nat) (s : Term L),
  interpFormula (updateValue value v (interpTerm value s)) b ->
  interpFormula value (substituteFormula L b v s)).
intros.
induction (H b1 H2 value0 v1 s0).
auto.
apply H2.
apply depthForall.
apply
 freeVarInterpFormula
  with (updateValue (updateValue value v0 (interpTerm value s)) v x).
apply (H0 x).
apply H1.
assert
 (forall b : Formula L,
  lt_depth L b (forallH L v a) ->
  forall (value : nat -> U M) (v : nat) (s : Term L),
  interpFormula value (substituteFormula L b v s) ->
  interpFormula (updateValue value v (interpTerm value s)) b).
intros.
induction (H b1 H1 value0 v1 s0).
auto.
intros.
apply
 freeVarInterpFormula
  with
    (updateValue (updateValue value v x) v0
       (interpTerm (updateValue value v x) s)).
intros.
symmetry  in |- *.
auto.
apply H1.
apply depthForall.
auto.
Qed.

Lemma subInterpFormula1 :
 forall (value : nat -> U M) (f : Formula L) (v : nat) (s : Term L),
 interpFormula (updateValue value v (interpTerm value s)) f ->
 interpFormula value (substituteFormula L f v s).
Proof.
intros.
induction (subInterpFormula value f v s).
auto.
Qed.

Lemma subInterpFormula2 :
 forall (value : nat -> U M) (f : Formula L) (v : nat) (s : Term L),
 interpFormula value (substituteFormula L f v s) ->
 interpFormula (updateValue value v (interpTerm value s)) f.
Proof.
intros.
induction (subInterpFormula value f v s).
auto.
Qed.

Fixpoint nnHelp (f : Formula L) : Formula L :=
  match f with
  | equal t s => equal L t s
  | atomic r ts => atomic L r ts
  | impH A B => impH L (nnHelp A) (nnHelp B)
  | notH A => notH L (nnHelp A)
  | forallH v A => forallH L v (notH L (notH L (nnHelp A)))
  end.

Definition nnTranslate (f : Formula L) : Formula L :=
  notH L (notH L (nnHelp f)).

Lemma freeVarNNHelp :
 forall f : Formula L, freeVarFormula L f = freeVarFormula L (nnHelp f).
Proof.
intros.
induction f as [t t0| r t| f1 Hrecf1 f0 Hrecf0| f Hrecf| n f Hrecf];
 try reflexivity.
simpl in |- *.
rewrite Hrecf1.
rewrite Hrecf0.
reflexivity.
simpl in |- *.
assumption.
simpl in |- *.
rewrite Hrecf.
reflexivity.
Qed.

Lemma subNNHelp :
 forall (f : Formula L) (v : nat) (s : Term L),
 substituteFormula L (nnHelp f) v s = nnHelp (substituteFormula L f v s).
Proof.
intro f.
elim f using Formula_depth_ind2; intros; try reflexivity.
simpl in |- *.
rewrite subFormulaImp.
rewrite H.
rewrite H0.
rewrite subFormulaImp.
reflexivity.
simpl in |- *.
rewrite subFormulaNot.
rewrite H.
rewrite subFormulaNot.
reflexivity.
simpl in |- *.
do 2 rewrite subFormulaForall.
simpl in |- *.
induction (eq_nat_dec v v0).
simpl in |- *.
reflexivity.
induction (In_dec eq_nat_dec v (freeVarTerm L s)).
simpl in |- *.
repeat rewrite subFormulaNot.
repeat rewrite H.
rewrite <- freeVarNNHelp.
reflexivity.
eapply eqDepth.
symmetry  in |- *.
apply subFormulaDepth.
apply depthForall.
apply depthForall.
repeat rewrite subFormulaNot.
rewrite H.
simpl in |- *.
reflexivity.
apply depthForall.
Qed.

Section Consistent_Theory.

Variable T : System L.

Fixpoint interpTermsVector (value : nat -> U M) (n : nat) 
 (ts : Terms L n) {struct ts} : Vector.t (U M) n :=
  match ts in (Terms _ n) return (Vector.t (U M) n) with
  | Tnil => Vector.nil (U M)
  | Tcons m t ts =>
      Vector.cons (U M) (interpTerm value t) m (interpTermsVector value m ts)
  end.

Lemma preserveValue :
 forall value : nat -> U M,
 (forall f : Formula L,
  mem _ T f -> interpFormula value (nnTranslate f)) ->
 forall g : Formula L, SysPrf L T g -> interpFormula value (nnTranslate g).
Proof.
intros.
induction H0 as (x, H0).
induction H0 as (x0, H0).
cut (forall g : Formula L, In g x -> interpFormula value (nnTranslate g)).
clear H H0.
generalize value.
clear value.
induction x0
 as
  [A|
   Axm1 Axm2 A B x0_1 Hrecx0_1 x0_0 Hrecx0_0|
   Axm A v n x0 Hrecx0|
   A B|
   A B C|
   A B|
   A v t|
   A v n|
   A B v|
   |
   |
   |
   R|
   f]; intros; try (simpl in |- *; tauto).
apply H.
auto with datatypes.
assert (interpFormula value (nnTranslate A)).
auto with datatypes.
assert (interpFormula value (nnTranslate (impH L A B))).
auto with datatypes.
clear Hrecx0_1 Hrecx0_0.
simpl in H0.
simpl in H1.
simpl in |- *.
tauto.
simpl in |- *.
intros.
apply H0.
clear H0.
intros.
simpl in Hrecx0.
apply (Hrecx0 (updateValue value v x)).
intros.
simpl in H.
eapply H.
apply H1.
intros.
apply H2.
apply freeVarInterpFormula with value.
intros.
rewrite <- freeVarNNHelp in H4.
unfold updateValue in |- *.
induction (eq_nat_dec v x1).
elim n.
rewrite a.
clear n x0 Hrecx0 H.
induction Axm as [| a0 Axm HrecAxm].
apply H1.
simpl in |- *.
simpl in H1.
induction H1 as [H| H].
rewrite H.
auto with datatypes.
auto with datatypes.
reflexivity.
assumption.
assumption.
simpl in |- *.
intros.
apply H0.
intros.
elim H1 with (interpTerm value t).
intros.
apply H0.
intros.
rewrite <- subNNHelp.
apply subInterpFormula1.
auto.
simpl in |- *.
intros.
apply H0.
intros.
apply H2.
apply freeVarInterpFormula with value.
intros.
unfold updateValue in |- *.
induction (eq_nat_dec v x0).
elim n.
rewrite a.
rewrite freeVarNNHelp.
assumption.
reflexivity.
assumption.
simpl in |- *.
intros.
apply H0.
clear H0.
intros.
apply H0 with x.
intros.
apply H1 with x.
auto.
simpl in |- *.
auto.
simpl in |- *.
intros.
apply H0.
intros.
transitivity (value 1); auto.
simpl in |- *.
intros.
apply H0.
clear H H0.
unfold AxmEq4 in |- *.
cut
 (forall a b : Terms L (arity L (inl (Functions L) R)),
  interpTermsVector value _ a = interpTermsVector value _ b ->
  interpFormula value (nnHelp (iffH L (atomic L R a) (atomic L R b)))).
assert
 (forall A,
  (forall a b : Terms L (arity L (inl (Functions L) R)),
   interpTermsVector value (arity L (inl (Functions L) R)) a =
   interpTermsVector value (arity L (inl (Functions L) R)) b ->
   interpFormula value (nnHelp (A a b))) ->
  interpFormula value
    (nnHelp
       (nat_rec (fun _ : nat => Formula L)
          (prod_rec
             (fun
                _ : Terms L (arity L (inl (Functions L) R)) *
                    Terms L (arity L (inl (Functions L) R)) => 
              Formula L)
             (fun a b : Terms L (arity L (inl (Functions L) R)) => A a b)
             (nVars L (arity L (inl (Functions L) R))))
          (fun (n : nat) (Hrecn : Formula L) =>
           impH L (equal L (var L (n + n)) (var L (S (n + n)))) Hrecn)
          (arity L (inl (Functions L) R))))).
generalize (arity L (inl (Functions L) R)).
simple induction n.
simpl in |- *.
intros.
apply H.
reflexivity.
intros.
simpl in |- *.
induction (nVars L n0).
simpl in |- *.
simpl in H.
intros.
apply
 (H
    (fun x y : Terms L n0 =>
     A (Tcons L n0 (var L (n0 + n0)) x) (Tcons L n0 (var L (S (n0 + n0))) y))).
intros.
apply H0.
simpl in |- *.
rewrite H1.
rewrite H2.
reflexivity.
apply (H (fun a b => iffH L (atomic L R a) (atomic L R b))).
simpl in |- *.
generalize (rel M R).
generalize (arity L (inl (Functions L) R)).
intros.
induction a as [| n t a Hreca].
assert (b = Tnil L).
symmetry  in |- *.
apply nilTerms.
rewrite H1 in H0.
auto.
induction (consTerms L n b).
induction x as (a0, b0).
simpl in p.
rewrite <- p in H0.
rewrite <- p in H.
simpl in H.
inversion H.
simpl in H0.
rewrite H2 in H0.
apply (Hreca (n0 (interpTerm value a0)) b0).
apply (inj_right_pair2 _ eq_nat_dec _ _ _ _ H3).
auto.
simpl in |- *.
intros.
apply H0.
clear H H0.
unfold AxmEq5 in |- *.
cut
 (forall a b : Terms L (arity L (inr (Relations L) f)),
  interpTermsVector value _ a = interpTermsVector value _ b ->
  interpFormula value (nnHelp (equal L (apply L f a) (apply L f b)))).
assert
 (forall A,
  (forall a b : Terms L (arity L (inr (Relations L) f)),
   interpTermsVector value (arity L (inr (Relations L) f)) a =
   interpTermsVector value (arity L (inr (Relations L) f)) b ->
   interpFormula value (nnHelp (A a b))) ->
  interpFormula value
    (nnHelp
       (nat_rec (fun _ : nat => Formula L)
          (prod_rec
             (fun
                _ : Terms L (arity L (inr (Relations L) f)) *
                    Terms L (arity L (inr (Relations L) f)) => 
              Formula L)
             (fun a b : Terms L (arity L (inr (Relations L) f)) => A a b)
             (nVars L (arity L (inr (Relations L) f))))
          (fun (n : nat) (Hrecn : Formula L) =>
           impH L (equal L (var L (n + n)) (var L (S (n + n)))) Hrecn)
          (arity L (inr (Relations L) f))))).
generalize (arity L (inr (Relations L) f)).
simple induction n.
simpl in |- *.
intros.
auto.
intros.
simpl in |- *.
induction (nVars L n0).
simpl in |- *.
simpl in H.
intros.
apply
 (H
    (fun x y : Terms L n0 =>
     A (Tcons L n0 (var L (n0 + n0)) x) (Tcons L n0 (var L (S (n0 + n0))) y))).
intros.
apply H0.
simpl in |- *.
rewrite H1.
rewrite H2.
reflexivity.
apply (H (fun a b => equal L (apply L f a) (apply L f b))).
simpl in |- *.
generalize (func M f).
generalize (arity L (inr (Relations L) f)).
intros.
induction a as [| n t a Hreca].
assert (b = Tnil L).
symmetry  in |- *.
apply nilTerms.
rewrite H0.
reflexivity.
induction (consTerms L n b).
induction x as (a0, b0).
simpl in p.
rewrite <- p.
rewrite <- p in H.
simpl in H.
inversion H.
simpl in |- *.
rewrite H1.
apply Hreca.
apply (inj_right_pair2 _ eq_nat_dec _ _ _ _ H2).
auto.
Qed.

Lemma ModelConsistent :
 forall value : nat -> U M,
 (forall f : Formula L,
  mem _ T f -> interpFormula value (nnTranslate f)) ->
 Consistent L T.
Proof.
intros.
unfold Consistent in |- *.
exists (notH L (equal L (var  L 0) (var L 0))).
unfold not in |- *; intros.
assert
 (interpFormula value
    (nnTranslate (notH L (equal L (var L 0) (var L 0))))).
apply preserveValue.
assumption.
auto.
simpl in *.
auto.
Qed.

End Consistent_Theory.

End Model_Theory.
