Require Import primRec.
(* primRec:
Require Import Arith.
Require Import Peano_dec.
Require Import Compare_dec.
Require Import Coq.Lists.List.
Require Import Eqdep_dec.
Require Import extEqualNat.
Require Vector.
Require Import misc.
Require Export Bool.
Require Export EqNat.
Require Import Even.
Require Import Max.

Inductive PrimRec : nat -> Set :=
  | succFunc : PrimRec 1
  | zeroFunc : PrimRec 0
  | projFunc : forall n m : nat, m < n -> PrimRec n
  | composeFunc :
      forall (n m : nat) (g : PrimRecs n m) (h : PrimRec m), PrimRec n
  | primRecFunc :
      forall (n : nat) (g : PrimRec n) (h : PrimRec (S (S n))), PrimRec (S n)
with PrimRecs : nat -> nat -> Set :=
  | PRnil : forall n : nat, PrimRecs n 0
  | PRcons : forall n m : nat, PrimRec n -> PrimRecs n m -> PrimRecs n (S m).

Scheme PrimRec_PrimRecs_rec := Induction for PrimRec
  Sort Set
  with PrimRecs_PrimRec_rec := Induction for PrimRecs 
  Sort Set.

Scheme PrimRec_PrimRecs_ind := Induction for PrimRec
  Sort Prop
  with PrimRecs_PrimRec_ind := Induction for PrimRecs 
  Sort Prop.

Fixpoint evalConstFunc (n m : nat) {struct n} : naryFunc n :=
  match n return (naryFunc n) with
  | O => m
  | S n' => fun _ => evalConstFunc n' m
  end.

Fixpoint evalProjFunc (n : nat) : forall m : nat, m < n -> naryFunc n :=
  match n return (forall m : nat, m < n -> naryFunc n) with
  | O => fun (m : nat) (l : m < 0) => False_rec _ (lt_n_O _ l)
  | S n' =>
      fun (m : nat) (l : m < S n') =>
      match eq_nat_dec m n' with
      | left _ => fun a : nat => evalConstFunc _ a
      | right l1 =>
          fun _ =>
          evalProjFunc n' m
            match le_lt_or_eq _ _ (lt_n_Sm_le _ _ l) with
            | or_introl l2 => l2
            | or_intror l2 => False_ind _ (l1 l2)
            end
      end
  end.

Lemma evalProjFuncInd :
 forall (n m : nat) (p1 p2 : m < n),
 evalProjFunc n m p1 = evalProjFunc n m p2.

Fixpoint evalList (m : nat) (l : Vector.t nat m) {struct l} :
 naryFunc m -> nat :=
  match l in (Vector.t _ m) return (naryFunc m -> nat) with
  | Vector.nil => fun x : naryFunc 0 => x
  | Vector.cons a n l' => fun x : naryFunc (S n) => evalList n l' (x a)
  end.

Fixpoint evalOneParamList (n m a : nat) (l : Vector.t (naryFunc (S n)) m)
 {struct l} : Vector.t (naryFunc n) m :=
  match l in (Vector.t _ m) return (Vector.t (naryFunc n) m) with
  | Vector.nil  => Vector.nil  (naryFunc n)
  | Vector.cons f m' l' => Vector.cons _ (f a) m' (evalOneParamList n m' a l')
  end.

Fixpoint evalComposeFunc (n : nat) :
 forall m : nat, Vector.t (naryFunc n) m -> naryFunc m -> naryFunc n :=
  match
    n
    return
      (forall m : nat, Vector.t (naryFunc n) m -> naryFunc m -> naryFunc n)
  with
  | O => evalList
  | S n' =>
      fun (m : nat) (l : Vector.t (naryFunc (S n')) m) 
        (f : naryFunc m) (a : nat) =>
      evalComposeFunc n' m (evalOneParamList _ _ a l) f
  end.

Fixpoint compose2 (n : nat) : naryFunc n -> naryFunc (S n) -> naryFunc n :=
  match n return (naryFunc n -> naryFunc (S n) -> naryFunc n) with
  | O => fun (a : nat) (g : nat -> nat) => g a
  | S n' =>
      fun (f : naryFunc (S n')) (g : naryFunc (S (S n'))) (a : nat) =>
      compose2 n' (f a) (fun x : nat => g x a)
  end.

Fixpoint evalPrimRecFunc (n : nat) (g : naryFunc n) 
 (h : naryFunc (S (S n))) (a : nat) {struct a} : naryFunc n :=
  match a with
  | O => g
  | S a' => compose2 _ (evalPrimRecFunc n g h a') (h a')
  end.

Fixpoint evalPrimRec (n : nat) (f : PrimRec n) {struct f} : 
 naryFunc n :=
  match f in (PrimRec n) return (naryFunc n) with
  | succFunc => S
  | zeroFunc => 0
  | projFunc n m pf => evalProjFunc n m pf
  | composeFunc n m l f =>
      evalComposeFunc n m (evalPrimRecs _ _ l) (evalPrimRec _ f)
  | primRecFunc n g h =>
      evalPrimRecFunc n (evalPrimRec _ g) (evalPrimRec _ h)
  end
 
 with evalPrimRecs (n m : nat) (fs : PrimRecs n m) {struct fs} :
 Vector.t (naryFunc n) m :=
  match fs in (PrimRecs n m) return (Vector.t (naryFunc n) m) with
  | PRnil a => Vector.nil  (naryFunc a)
  | PRcons a b g gs => Vector.cons _ (evalPrimRec _ g) _ (evalPrimRecs _ _ gs)
  end.

Definition extEqualVectorGeneral (n m : nat) (l : Vector.t (naryFunc n) m) :

Definition extEqualVector n: forall m (l l' : Vector.t (naryFunc n) m), Prop.

Lemma extEqualVectorRefl :
 forall (n m : nat) (l : Vector.t (naryFunc n) m), extEqualVector n m l l.

Lemma extEqualOneParamList :
 forall (n m : nat) (l1 l2 : Vector.t (naryFunc (S n)) m) (c : nat),

Lemma extEqualCompose :
 forall (n m : nat) (l1 l2 : Vector.t (naryFunc n) m) (f1 f2 : naryFunc m),

Lemma extEqualCompose2 :
 forall (n : nat) (f1 f2 : naryFunc n),
 extEqual n f1 f2 ->
 forall g1 g2 : naryFunc (S n),
 extEqual (S n) g1 g2 -> extEqual n (compose2 n f1 g1) (compose2 n f2 g2).

Lemma extEqualPrimRec :
 forall (n : nat) (g1 g2 : naryFunc n) (h1 h2 : naryFunc (S (S n))),
 extEqual n g1 g2 ->
 extEqual (S (S n)) h1 h2 ->
 extEqual (S n) (evalPrimRecFunc n g1 h1) (evalPrimRecFunc n g2 h2).

Definition isPR (n : nat) (f : naryFunc n) : Set :=
  {p : PrimRec n | extEqual n (evalPrimRec _ p) f}.

Definition isPRrel (n : nat) (R : naryRel n) : Set :=
  isPR n (charFunction n R).

Lemma succIsPR : isPR 1 S.

Lemma const0_NIsPR : forall n : nat, isPR 0 n.

Lemma const1_NIsPR : forall n : nat, isPR 1 (fun _ => n).

Lemma idIsPR : isPR 1 (fun x : nat => x).

Lemma pi1_2IsPR : isPR 2 (fun a b : nat => a).

Lemma pi2_2IsPR : isPR 2 (fun a b : nat => b).

Lemma pi1_3IsPR : isPR 3 (fun a b c : nat => a).

Lemma pi2_3IsPR : isPR 3 (fun a b c : nat => b).

Lemma pi3_3IsPR : isPR 3 (fun a b c : nat => c).

Lemma pi1_4IsPR : isPR 4 (fun a b c d : nat => a).

Lemma pi2_4IsPR : isPR 4 (fun a b c d : nat => b).

Lemma pi3_4IsPR : isPR 4 (fun a b c d : nat => c).

Lemma pi4_4IsPR : isPR 4 (fun a b c d : nat => d).

Lemma filter01IsPR :
 forall g : nat -> nat, isPR 1 g -> isPR 2 (fun a b : nat => g b).

Lemma filter10IsPR :
 forall g : nat -> nat, isPR 1 g -> isPR 2 (fun a b : nat => g a).

Lemma filter100IsPR :
 forall g : nat -> nat, isPR 1 g -> isPR 3 (fun a b c : nat => g a).

Lemma filter010IsPR :
 forall g : nat -> nat, isPR 1 g -> isPR 3 (fun a b c : nat => g b).

Lemma filter001IsPR :
 forall g : nat -> nat, isPR 1 g -> isPR 3 (fun a b c : nat => g c).

Lemma filter011IsPR :
 forall g : nat -> nat -> nat, isPR 2 g -> isPR 3 (fun a b c : nat => g b c).

Lemma filter110IsPR :
 forall g : nat -> nat -> nat, isPR 2 g -> isPR 3 (fun a b c : nat => g a b).

Lemma filter101IsPR :
 forall g : nat -> nat -> nat, isPR 2 g -> isPR 3 (fun a b c : nat => g a c).

Lemma filter0011IsPR :
 forall g : nat -> nat -> nat,
 isPR 2 g -> isPR 4 (fun a b c d : nat => g c d).

Lemma filter1000IsPR :
 forall g : nat -> nat, isPR 1 g -> isPR 4 (fun a b c d : nat => g a).

Lemma filter1011IsPR :
 forall g : nat -> nat -> nat -> nat,
 isPR 3 g -> isPR 4 (fun a b c d : nat => g a c d).

Lemma filter1100IsPR :
 forall g : nat -> nat -> nat,
 isPR 2 g -> isPR 4 (fun a b c d : nat => g a b).

Lemma compose1_1IsPR :
 forall f : nat -> nat,
 isPR 1 f ->
 forall g : nat -> nat, isPR 1 g -> isPR 1 (fun x : nat => g (f x)).

Lemma compose1_2IsPR :
 forall f : nat -> nat,
 isPR 1 f ->
 forall f' : nat -> nat,
 isPR 1 f' ->
 forall g : nat -> nat -> nat,
 isPR 2 g -> isPR 1 (fun x : nat => g (f x) (f' x)).

Lemma compose1_3IsPR :
 forall f1 : nat -> nat,
 isPR 1 f1 ->
 forall f2 : nat -> nat,
 isPR 1 f2 ->
 forall f3 : nat -> nat,
 isPR 1 f3 ->
 forall g : nat -> nat -> nat -> nat,
 isPR 3 g -> isPR 1 (fun x : nat => g (f1 x) (f2 x) (f3 x)).

Lemma compose2_1IsPR :
 forall f : nat -> nat -> nat,
 isPR 2 f ->
 forall g : nat -> nat, isPR 1 g -> isPR 2 (fun x y : nat => g (f x y)).

Lemma compose2_2IsPR :
 forall f : nat -> nat -> nat,
 isPR 2 f ->
 forall g : nat -> nat -> nat,
 isPR 2 g ->
 forall h : nat -> nat -> nat,
 isPR 2 h -> isPR 2 (fun x y : nat => h (f x y) (g x y)).

Lemma compose2_3IsPR :
 forall f1 : nat -> nat -> nat,
 isPR 2 f1 ->
 forall f2 : nat -> nat -> nat,
 isPR 2 f2 ->
 forall f3 : nat -> nat -> nat,
 isPR 2 f3 ->
 forall g : nat -> nat -> nat -> nat,
 isPR 3 g -> isPR 2 (fun x y : nat => g (f1 x y) (f2 x y) (f3 x y)).

Lemma compose2_4IsPR :
 forall f1 : nat -> nat -> nat,
 isPR 2 f1 ->
 forall f2 : nat -> nat -> nat,
 isPR 2 f2 ->
 forall f3 : nat -> nat -> nat,
 isPR 2 f3 ->
 forall f4 : nat -> nat -> nat,
 isPR 2 f4 ->
 forall g : nat -> nat -> nat -> nat -> nat,
 isPR 4 g -> isPR 2 (fun x y : nat => g (f1 x y) (f2 x y) (f3 x y) (f4 x y)).

Lemma compose3_1IsPR :
 forall f : nat -> nat -> nat -> nat,
 isPR 3 f ->
 forall g : nat -> nat, isPR 1 g -> isPR 3 (fun x y z : nat => g (f x y z)).

Lemma compose3_2IsPR :
 forall f1 : nat -> nat -> nat -> nat,
 isPR 3 f1 ->
 forall f2 : nat -> nat -> nat -> nat,
 isPR 3 f2 ->
 forall g : nat -> nat -> nat,
 isPR 2 g -> isPR 3 (fun x y z : nat => g (f1 x y z) (f2 x y z)).

Lemma compose3_3IsPR :
 forall f1 : nat -> nat -> nat -> nat,
 isPR 3 f1 ->
 forall f2 : nat -> nat -> nat -> nat,
 isPR 3 f2 ->
 forall f3 : nat -> nat -> nat -> nat,
 isPR 3 f3 ->
 forall g : nat -> nat -> nat -> nat,
 isPR 3 g -> isPR 3 (fun x y z : nat => g (f1 x y z) (f2 x y z) (f3 x y z)).

Lemma compose4_2IsPR :
 forall f1 : nat -> nat -> nat -> nat -> nat,
 isPR 4 f1 ->
 forall f2 : nat -> nat -> nat -> nat -> nat,
 isPR 4 f2 ->
 forall g : nat -> nat -> nat,
 isPR 2 g -> isPR 4 (fun w x y z : nat => g (f1 w x y z) (f2 w x y z)).

Lemma compose4_3IsPR :
 forall f1 : nat -> nat -> nat -> nat -> nat,
 isPR 4 f1 ->
 forall f2 : nat -> nat -> nat -> nat -> nat,
 isPR 4 f2 ->
 forall f3 : nat -> nat -> nat -> nat -> nat,
 isPR 4 f3 ->
 forall g : nat -> nat -> nat -> nat,
 isPR 3 g ->
 isPR 4 (fun w x y z : nat => g (f1 w x y z) (f2 w x y z) (f3 w x y z)).

Lemma swapIsPR :
 forall f : nat -> nat -> nat, isPR 2 f -> isPR 2 (fun x y : nat => f y x).

Lemma indIsPR :
 forall f : nat -> nat -> nat,
 isPR 2 f ->
 forall g : nat,
 isPR 1
   (fun a : nat => nat_rec (fun n : nat => nat) g (fun x y : nat => f x y) a).

Lemma ind1ParamIsPR :
 forall f : nat -> nat -> nat -> nat,
 isPR 3 f ->
 forall g : nat -> nat,
 isPR 1 g ->
 isPR 2
   (fun a b : nat =>
    nat_rec (fun n : nat => nat) (g b) (fun x y : nat => f x y b) a).

Lemma ind2ParamIsPR :
 forall f : nat -> nat -> nat -> nat -> nat,
 isPR 4 f ->
 forall g : nat -> nat -> nat,
 isPR 2 g ->
 isPR 3
   (fun a b c : nat =>
    nat_rec (fun n : nat => nat) (g b c) (fun x y : nat => f x y b c) a).

Lemma plusIndIsPR : isPR 3 (fun n fn b : nat => S fn).

Lemma plusIsPR : isPR 2 plus.

Lemma multIndIsPR : isPR 3 (fun n fn b : nat => fn + b).

Lemma multIsPR : isPR 2 mult.

Lemma predIsPR : isPR 1 pred.

Lemma minusIndIsPR : isPR 3 (fun n fn b : nat => pred fn).

Lemma minusIsPR : isPR 2 minus.

Definition notZero (a : nat) :=
  nat_rec (fun n : nat => nat) 0 (fun x y : nat => 1) a.

Lemma notZeroIsPR : isPR 1 notZero.

Definition ltBool (a b : nat) : bool.

Lemma ltBoolTrue : forall a b : nat, ltBool a b = true -> a < b.

Lemma ltBoolFalse : forall a b : nat, ltBool a b = false -> ~ a < b.

Lemma ltIsPR : isPRrel 2 ltBool.

Lemma maxIsPR : isPR 2 max.

Lemma gtIsPR : isPRrel 2 (fun a b : nat => ltBool b a).

Remark replaceCompose2 :
 forall (n : nat) (a b a' b' : naryFunc n) (c c' : naryFunc 2),
 extEqual n a a' ->
 extEqual n b b' ->
 extEqual 2 c c' ->
 extEqual n
   (evalComposeFunc _ _ (Vector.cons _ a _ (Vector.cons _ b _ (Vector.nil  (naryFunc n)))) c)

Definition orRel (n : nat) (R S : naryRel n) : naryRel n.

Lemma orRelPR :
 forall (n : nat) (R R' : naryRel n),
 isPRrel n R -> isPRrel n R' -> isPRrel n (orRel n R R').

Definition andRel (n : nat) (R S : naryRel n) : naryRel n.

Lemma andRelPR :
 forall (n : nat) (R R' : naryRel n),
 isPRrel n R -> isPRrel n R' -> isPRrel n (andRel n R R').

Definition notRel (n : nat) (R : naryRel n) : naryRel n.

Lemma notRelPR :
 forall (n : nat) (R : naryRel n), isPRrel n R -> isPRrel n (notRel n R).

Fixpoint bodd (n : nat) : bool :=
  match n with
  | O => false
  | S n' => negb (bodd n')
  end.

Lemma boddIsPR : isPRrel 1 bodd.

Lemma beq_nat_not_refl : forall a b : nat, a <> b -> beq_nat a b = false.

Lemma neqIsPR : isPRrel 2 (fun a b : nat => negb (beq_nat a b)).

Lemma eqIsPR : isPRrel 2 beq_nat.

Definition leBool (a b : nat) : bool.

Lemma leIsPR : isPRrel 2 leBool.

Section Ignore_Params.

Fixpoint ignoreParams (n m : nat) (f : naryFunc n) {struct m} :
 naryFunc (m + n) :=
  match m return (naryFunc (m + n)) with
  | O => f
  | S x => fun _ => ignoreParams n x f
  end.

Definition projectionListPR (n m : nat) (p : m <= n) : PrimRecs n m.

Definition projectionList (n m : nat) (p : m <= n) : 
  Vector.t (naryFunc n) m := evalPrimRecs n m (projectionListPR n m p).

Lemma projectionListInd :
 forall (n m : nat) (p1 p2 : m <= n),
 projectionList n m p1 = projectionList n m p2.

Lemma projectionListApplyParam :
 forall (m n c : nat) (p1 : m <= n) (p2 : m <= S n),
 extEqualVector _ _ (projectionList n m p1)
   (evalOneParamList n m c (projectionList (S n) m p2)).

Lemma projectionListId :
 forall (n : nat) (f : naryFunc n) (p : n <= n),
 extEqual n f (evalComposeFunc n n (projectionList n n p) f).

Lemma ignoreParamsIsPR :
 forall (n m : nat) (f : naryFunc n), isPR _ f -> isPR _ (ignoreParams n m f).

End Ignore_Params.

Lemma reduce1stCompose :
 forall (c n m : nat) (v : Vector.t (naryFunc n) m) (g : naryFunc (S m)),

Lemma reduce2ndCompose :
 forall (c n m : nat) (v : Vector.t (naryFunc n) m) (n0 : naryFunc n)

Lemma evalPrimRecParam :
 forall (n c d : nat) (g : naryFunc (S n)) (h : naryFunc (S (S (S n)))),
 extEqual _ (evalPrimRecFunc n (g d) (fun x y : nat => h x y d) c)
   (evalPrimRecFunc (S n) g h c d).

Lemma compose2IsPR :
 forall (n : nat) (f : naryFunc n) (p : isPR n f) (g : naryFunc (S n))
   (q : isPR (S n) g), isPR n (compose2 n f g).

Lemma compose1_NIsPR :
 forall (n : nat) (g : naryFunc (S n)),
 isPR (S n) g ->
 forall f : naryFunc 1, isPR 1 f -> isPR (S n) (fun x : nat => g (f x)).

Definition switchPR : naryFunc 3. 

Lemma switchIsPR : isPR 3 switchPR.

Fixpoint boundedSearchHelp (P : naryRel 1) (b : nat) {struct b} : nat :=
  match b with
  | O => 0
  | S b' =>
      match eq_nat_dec (boundedSearchHelp P b') b' with
      | left _ => match P b' with
                  | true => b'
                  | false => S b'
                  end
      | right _ => boundedSearchHelp P b'
      end
  end.
   
Definition boundedSearch (P : naryRel 2) (b : nat) : nat :=
  boundedSearchHelp (P b) b.

Lemma boundedSearch1 :
 forall (P : naryRel 2) (b x : nat), x < boundedSearch P b -> P b x = false.

Lemma boundedSearch2 :
 forall (P : naryRel 2) (b : nat),
 boundedSearch P b = b \/ P b (boundedSearch P b) = true.

Lemma boundSearchIsPR :
 forall P : naryRel 2,
 isPRrel 2 P -> isPR 1 (fun b : nat => boundedSearch P b).

Definition iterate (g : nat -> nat) :=
  nat_rec (fun _ => nat -> nat) (fun x : nat => x)
    (fun (_ : nat) (rec : nat -> nat) (x : nat) => g (rec x)).

Lemma iterateIsPR :
 forall g : nat -> nat, isPR 1 g -> forall n : nat, isPR 1 (iterate g n). *)

Require Import cPair.
(* cPair:
Require Import Arith.
Require Import Coq.Lists.List.
Require Import extEqualNat.
Require Import primRec.
Require Vector.
Require Import Div2.

Definition sumToN (n : nat) :=
  nat_rec (fun _ => nat) 0 (fun x y : nat => S x + y) n.

Lemma sumToN1 : forall n : nat, n <= sumToN n.

Lemma sumToN2 : forall b a : nat, a <= b -> sumToN a <= sumToN b.

Lemma sumToNIsPR : isPR 1 sumToN.

Definition cPair (a b : nat) := a + sumToN (a + b).

Lemma cPairIsPR : isPR 2 cPair.

Section CPair_Injectivity.

Remark cPairInjHelp :
 forall a b c d : nat, cPair a b = cPair c d -> a + b = c + d.

Lemma cPairInj1 : forall a b c d : nat, cPair a b = cPair c d -> a = c.

Lemma cPairInj2 : forall a b c d : nat, cPair a b = cPair c d -> b = d.

End CPair_Injectivity.

Section CPair_projections.

Let searchXY (a : nat) :=
  boundedSearch (fun a y : nat => ltBool a (sumToN (S y))) a.

Definition cPairPi1 (a : nat) := a - sumToN (searchXY a).
Definition cPairPi2 (a : nat) := searchXY a - cPairPi1 a.

Lemma cPairProjectionsHelp :
 forall a b : nat, b < sumToN (S a) -> sumToN a <= b -> searchXY b = a.

Lemma cPairProjections : forall a : nat, cPair (cPairPi1 a) (cPairPi2 a) = a.

Remark searchXYIsPR : isPR 1 searchXY.

Lemma cPairPi1IsPR : isPR 1 cPairPi1.

Lemma cPairPi2IsPR : isPR 1 cPairPi2.

Lemma cPairProjections1 : forall a b : nat, cPairPi1 (cPair a b) = a.

Lemma cPairProjections2 : forall a b : nat, cPairPi2 (cPair a b) = b.

End CPair_projections.

Section CPair_Order.

Lemma cPairLe1 : forall a b : nat, a <= cPair a b.

Lemma cPairLe1A : forall a : nat, cPairPi1 a <= a.

Lemma cPairLe2 : forall a b : nat, b <= cPair a b.

Lemma cPairLe2A : forall a : nat, cPairPi2 a <= a.

Lemma cPairLe3 :
 forall a b c d : nat, a <= b -> c <= d -> cPair a c <= cPair b d.

Lemma cPairLt1 : forall a b : nat, a < cPair a (S b).

Lemma cPairLt2 : forall a b : nat, b < cPair (S a) b.

End CPair_Order.

Section code_nat_list.

Fixpoint codeList (l : list nat) : nat :=
  match l with
  | nil => 0
  | n :: l' => S (cPair n (codeList l'))
  end.

Lemma codeListInj : forall l m : list nat, codeList l = codeList m -> l = m.

Definition codeNth (n m : nat) : nat.

Let drop (n : nat) : forall (l : list nat), list nat.

Lemma codeNthCorrect :
 forall (n : nat) (l : list nat), codeNth n (codeList l) = nth n l 0.

Lemma codeNthIsPR : isPR 2 codeNth.

End code_nat_list.

Section Strong_Recursion.

Definition evalStrongRecHelp (n : nat) (f : naryFunc (S (S n))) :
  naryFunc (S n) :=
  evalPrimRecFunc n (evalComposeFunc n 0 (Vector.nil _) (codeList nil))
    (evalComposeFunc (S (S n)) 2
       (Vector.cons _ f _
          (Vector.cons _ (evalProjFunc (S (S n)) n (lt_S _ _ (lt_n_Sn _))) _
             (Vector.nil _))) (fun a b : nat => S (cPair a b))).

Definition evalStrongRec (n : nat) (f : naryFunc (S (S n))) :
  naryFunc (S n) :=
  evalComposeFunc (S n) 1
    (Vector.cons _ (fun z : nat => evalStrongRecHelp n f (S z)) _ (Vector.nil _))
    (fun z : nat => cPairPi1 (pred z)).

Lemma evalStrongRecIsPR :
 forall (n : nat) (f : naryFunc (S (S n))),
 isPR _ f -> isPR _ (evalStrongRec n f).

Lemma computeEvalStrongRecHelp :
 forall (n : nat) (f : naryFunc (S (S n))) (c : nat),
 evalStrongRecHelp n f (S c) =
 compose2 n (evalStrongRecHelp n f c)
   (fun a0 : nat =>
    evalComposeFunc n 2
      (Vector.cons (naryFunc n) (f c a0) 1

Let listValues (f : naryFunc 2) (n : nat) : list nat.

Lemma evalStrongRecHelp1 :
 forall (f : naryFunc 2) (n m : nat),
 m < n -> codeNth (n - S m) (evalStrongRecHelp _ f n) = evalStrongRec _ f m.

Lemma evalStrongRecHelpParam :
 forall (a n c : nat) (f : naryFunc (S (S (S a)))),
 extEqual a (evalStrongRecHelp (S a) f n c)
   (evalStrongRecHelp a (fun x y : nat => f x y c) n).

Lemma evalStrongRecHelp2 :
 forall (a : nat) (f : naryFunc (S (S a))) (n m : nat),
 m < n ->
 extEqual _
   (evalComposeFunc _ 1 (Vector.cons _ (evalStrongRecHelp _ f n) 0 (Vector.nil _))

Lemma callIsPR :
 forall g : nat -> nat,
 isPR 1 g -> isPR 2 (fun a recs : nat => codeNth (a - S (g a)) recs).

End Strong_Recursion.

Lemma div2IsPR : isPR 1 div2. *)

Require Import Arith.

Require Import folProp.
(* folProp:
Require Import Wf_nat.
Require Import Max.
Require Import Arith.
Require Import Coq.Lists.List.
Require Import ListExt.
Require Import Peano_dec.

Require Export fol.

Section Fol_Properties.

Variable L : Language.

Notation Formula := (Formula L) (only parsing).
Notation Formulas := (Formulas L) (only parsing).
Notation System := (System L) (only parsing).
Notation Term := (Term L) (only parsing).
Notation Terms := (Terms L) (only parsing).
Let var := var L.
Let apply := apply L.
Let equal := equal L.
Let atomic := atomic L.
Let impH := impH L.
Let notH := notH L.
Let forallH := forallH L.
Let lt_depth := lt_depth L.

Section Free_Variables.

Fixpoint freeVarTerm (s : fol.Term L) : list nat :=
  match s with
  | fol.var v => v :: nil
  | fol.apply f ts => freeVarTerms (arity L (inr _ f)) ts
  end
 
 with freeVarTerms (n : nat) (ss : fol.Terms L n) {struct ss} : 
 list nat :=
  match ss with
  | Tnil => nil (A:=nat)
  | Tcons m t ts => freeVarTerm t ++ freeVarTerms m ts
  end.

Lemma freeVarTermApply :
 forall (f : Functions L) (ts : fol.Terms L _),

Fixpoint freeVarFormula (A : fol.Formula L) : list nat :=
  match A with
  | fol.equal t s => freeVarTerm t ++ freeVarTerm s
  | fol.atomic r ts => freeVarTerms _ ts
  | fol.impH A B => freeVarFormula A ++ freeVarFormula B
  | fol.notH A => freeVarFormula A
  | fol.forallH v A => list_remove _ eq_nat_dec v (freeVarFormula A)
  end.

Definition ClosedSystem (T : fol.System L) :=
  forall (v : nat) (f : fol.Formula L),
  mem _ T f -> ~ In v (freeVarFormula f).

Definition closeList (l : list nat) (x : fol.Formula L) : 
  fol.Formula L :=
  list_rec (fun _ => fol.Formula L) x
    (fun (a : nat) _ (rec : fol.Formula L) => forallH a rec) l.

Definition close (x : fol.Formula L) : fol.Formula L :=
  closeList (no_dup _ eq_nat_dec (freeVarFormula x)) x.

Lemma freeVarClosedList1 :
 forall (l : list nat) (v : nat) (x : fol.Formula L),

Lemma freeVarClosedList2 :
 forall (l : list nat) (v : nat) (x : fol.Formula L),

Lemma freeVarClosed :
 forall (x : fol.Formula L) (v : nat), ~ In v (freeVarFormula (close x)).

Fixpoint freeVarListFormula (l : fol.Formulas L) : 
 list nat :=
  match l with
  | nil => nil (A:=nat)
  | f :: l => freeVarFormula f ++ freeVarListFormula l
  end.

Lemma freeVarListFormulaApp :
 forall a b : fol.Formulas L,

Lemma In_freeVarListFormula :
 forall (v : nat) (f : fol.Formula L) (F : fol.Formulas L),

Lemma In_freeVarListFormulaE :
 forall (v : nat) (F : fol.Formulas L),

Definition In_freeVarSys (v : nat) (T : fol.System L) :=
  exists f : fol.Formula L, In v (freeVarFormula f) /\ mem _ T f.

Lemma notInFreeVarSys :
 forall x, ~ In_freeVarSys x (Ensembles.Empty_set (fol.Formula L)).

End Free_Variables.

Section Substitution.

Fixpoint substituteTerm (s : fol.Term L) (x : nat) 
 (t : fol.Term L) {struct s} : fol.Term L :=
  match s with
  | fol.var v =>
      match eq_nat_dec x v with
      | left _ => t
      | right _ => var v
      end
  | fol.apply f ts => apply f (substituteTerms _ ts x t)
  end
 
 with substituteTerms (n : nat) (ss : fol.Terms L n) 
 (x : nat) (t : fol.Term L) {struct ss} : fol.Terms L n :=
  match ss in (fol.Terms _ n0) return (fol.Terms L n0) with
  | Tnil => Tnil L
  | Tcons m s ts =>
      Tcons L m (substituteTerm s x t) (substituteTerms m ts x t)
  end.

Lemma subTermVar1 :
 forall (v : nat) (s : fol.Term L), substituteTerm (var v) v s = s.

Lemma subTermVar2 :
 forall (v x : nat) (s : fol.Term L),

Lemma subTermFunction :
 forall (f : Functions L) (ts : fol.Terms L (arity L (inr _ f))) 

Definition newVar (l : list nat) : nat := fold_right max 0 (map S l).

Lemma newVar2 : forall (l : list nat) (n : nat), In n l -> n < newVar l.

Lemma newVar1 : forall l : list nat, ~ In (newVar l) l.

Definition substituteFormulaImp (f : fol.Formula L)
  (frec : nat * fol.Term L -> {y : fol.Formula L | depth L y = depth L f})
  (g : fol.Formula L)
  (grec : nat * fol.Term L -> {y : fol.Formula L | depth L y = depth L g})
  (p : nat * fol.Term L) :
  {y : fol.Formula L | depth L y = depth L (impH f g)} :=
  match frec p with
  | exist f' prf1 =>
      match grec p with
      | exist g' prf2 =>
          exist
            (fun y : fol.Formula L =>
             depth L y = S (max (depth L f) (depth L g))) 
            (impH f' g')
            (eq_ind_r
               (fun n : nat =>
                S (max n (depth L g')) = S (max (depth L f) (depth L g)))
               (eq_ind_r
                  (fun n : nat =>
                   S (max (depth L f) n) = S (max (depth L f) (depth L g)))
                  (refl_equal (S (max (depth L f) (depth L g)))) prf2) prf1)
      end
  end.

Remark substituteFormulaImpNice :
 forall (f g : fol.Formula L)

Definition substituteFormulaNot (f : fol.Formula L)
  (frec : nat * fol.Term L -> {y : fol.Formula L | depth L y = depth L f})
  (p : nat * fol.Term L) :
  {y : fol.Formula L | depth L y = depth L (notH f)} :=
  match frec p with
  | exist f' prf1 =>
      exist (fun y : fol.Formula L => depth L y = S (depth L f)) 
        (notH f')
        (eq_ind_r (fun n : nat => S n = S (depth L f))
           (refl_equal (S (depth L f))) prf1)
  end.

Remark substituteFormulaNotNice :
 forall (f : fol.Formula L)

Definition substituteFormulaForall (n : nat) (f : fol.Formula L)
  (frec : forall b : fol.Formula L,
          lt_depth b (forallH n f) ->
          nat * fol.Term L -> {y : fol.Formula L | depth L y = depth L b})
  (p : nat * fol.Term L) :
  {y : fol.Formula L | depth L y = depth L (forallH n f)} :=
  match p with
  | (v, s) =>
      match eq_nat_dec n v with
      | left _ =>
          exist (fun y : fol.Formula L => depth L y = S (depth L f))
            (forallH n f) (refl_equal (depth L (forallH n f)))
      | right _ =>
          match In_dec eq_nat_dec n (freeVarTerm s) with
          | left _ =>
              let nv := newVar (v :: freeVarTerm s ++ freeVarFormula f) in
              match frec f (depthForall L f n) (n, var nv) with
              | exist f' prf1 =>
                  match
                    frec f'
                      (eqDepth L f' f (forallH n f) 
                         (sym_eq prf1) (depthForall L f n)) p
                  with
                  | exist f'' prf2 =>
                      exist
                        (fun y : fol.Formula L => depth L y = S (depth L f))
                        (forallH nv f'')
                        (eq_ind_r (fun n : nat => S n = S (depth L f))
                           (refl_equal (S (depth L f))) 
                           (trans_eq prf2 prf1))
                  end
              end
          | right _ =>
              match frec f (depthForall L f n) p with
              | exist f' prf1 =>
                  exist (fun y : fol.Formula L => depth L y = S (depth L f))
                    (forallH n f')
                    (eq_ind_r (fun n : nat => S n = S (depth L f))
                       (refl_equal (S (depth L f))) prf1)
              end
          end
      end
  end.

Remark substituteFormulaForallNice :
 forall (v : nat) (a : fol.Formula L)

Definition substituteFormulaHelp (f : fol.Formula L) 

Definition substituteFormula (f : fol.Formula L) (v : nat) 
  (s : fol.Term L) : fol.Formula L := proj1_sig (substituteFormulaHelp f v s).

Lemma subFormulaEqual :
 forall (t1 t2 : fol.Term L) (v : nat) (s : fol.Term L),

Lemma subFormulaRelation :
 forall (r : Relations L) (ts : fol.Terms L (arity L (inl _ r))) 

Lemma subFormulaImp :
 forall (f1 f2 : fol.Formula L) (v : nat) (s : fol.Term L),

Lemma subFormulaNot :
 forall (f : fol.Formula L) (v : nat) (s : fol.Term L),

Lemma subFormulaForall :
 forall (f : fol.Formula L) (x v : nat) (s : fol.Term L),

Section Extensions.

Let orH := orH L.
Let andH := andH L.
Let existH := existH L.
Let iffH := iffH L.
Let ifThenElseH := ifThenElseH L.

Lemma subFormulaOr :
 forall (f1 f2 : fol.Formula L) (v : nat) (s : fol.Term L),

Lemma subFormulaAnd :
 forall (f1 f2 : fol.Formula L) (v : nat) (s : fol.Term L),

Lemma subFormulaExist :
 forall (f : fol.Formula L) (x v : nat) (s : fol.Term L),

Lemma subFormulaIff :
 forall (f1 f2 : fol.Formula L) (v : nat) (s : fol.Term L),

Lemma subFormulaIfThenElse :
 forall (f1 f2 f3 : fol.Formula L) (v : nat) (s : fol.Term L),

End Extensions.

Lemma subFormulaDepth :
 forall (f : fol.Formula L) (v : nat) (s : fol.Term L),

Section Substitution_Properties.

Lemma subTermId :
 forall (t : fol.Term L) (v : nat), substituteTerm t v (var v) = t.

Lemma subTermsId :
 forall (n : nat) (ts : fol.Terms L n) (v : nat),

Lemma subFormulaId :
 forall (f : fol.Formula L) (v : nat), substituteFormula f v (var v) = f.

Lemma subFormulaForall2 :
 forall (f : fol.Formula L) (x v : nat) (s : fol.Term L),

Let existH := existH L.

Lemma subFormulaExist2 :
 forall (f : fol.Formula L) (x v : nat) (s : fol.Term L),

End Substitution_Properties.

End Substitution.
 
Definition Sentence (f:Formula) := (forall v : nat, ~ In v (freeVarFormula f)).

End Fol_Properties. *)

Require Import code.
(* code:
Require Import Arith.
Require Import fol.
Require Import folProof.
Require Import cPair.

Section Code_Term_Formula_Proof.

Variable L : Language.
Variable codeF : Functions L -> nat.
Variable codeR : Relations L -> nat.
Hypothesis codeFInj : forall f g : Functions L, codeF f = codeF g -> f = g.
Hypothesis codeRInj : forall R S : Relations L, codeR R = codeR S -> R = S.

Let Formula := Formula L.
Let Formulas := Formulas L.
Let System := System L.
Let Term := Term L.
Let Terms := Terms L.
Let var := var L.
Let apply := apply L.
Let equal := equal L.
Let atomic := atomic L.
Let impH := impH L.
Let notH := notH L.
Let forallH := forallH L.
Let orH := orH L.
Let andH := andH L.
Let existH := existH L.
Let iffH := iffH L.
Let ifThenElseH := ifThenElseH L.
Let Prf := Prf L.
Let SysPrf := SysPrf L.

Fixpoint codeTerm (t : Term) : nat :=
  match t with
  | fol.var n => cPair 0 n
  | fol.apply f ts => cPair (S (codeF f)) (codeTerms _ ts)
  end
 
 with codeTerms (n : nat) (ts : Terms n) {struct ts} : nat :=
  match ts with
  | Tnil => 0
  | Tcons n t ss => S (cPair (codeTerm t) (codeTerms n ss))
  end.

Lemma codeTermInj : forall t s : Term, codeTerm t = codeTerm s -> t = s.

Lemma codeTermsInj :
 forall (n : nat) (ts ss : Terms n),
 codeTerms n ts = codeTerms n ss -> ts = ss.

Fixpoint codeFormula (f : Formula) : nat :=
  match f with
  | fol.equal t1 t2 => cPair 0 (cPair (codeTerm t1) (codeTerm t2))
  | fol.impH f1 f2 => cPair 1 (cPair (codeFormula f1) (codeFormula f2))
  | fol.notH f1 => cPair 2 (codeFormula f1)
  | fol.forallH n f1 => cPair 3 (cPair n (codeFormula f1))
  | fol.atomic R ts => cPair (4+(codeR R)) (codeTerms _ ts)
  end.

Lemma codeFormulaInj :
 forall f g : Formula, codeFormula f = codeFormula g -> f = g.

Fixpoint codePrf (Z : Formulas) (f : Formula) (prf : Prf Z f) {struct prf} :
 nat :=
  match prf with
  | AXM A => cPair 0 (codeFormula A)
  | MP Axm1 Axm2 A B rec1 rec2 =>
      cPair 1
        (cPair
           (cPair (cPair 1 (cPair (codeFormula A) (codeFormula B)))
              (codePrf _ _ rec1)) (cPair (codeFormula A) (codePrf _ _ rec2)))
  | GEN Axm A v _ rec =>
      cPair 2 (cPair v (cPair (codeFormula A) (codePrf _ _ rec)))
  | IMP1 A B => cPair 3 (cPair (codeFormula A) (codeFormula B))
  | IMP2 A B C =>
      cPair 4 (cPair (codeFormula A) (cPair (codeFormula B) (codeFormula C)))
  | CP A B => cPair 5 (cPair (codeFormula A) (codeFormula B))
  | FA1 A v t => cPair 6 (cPair (codeFormula A) (cPair v (codeTerm t)))
  | FA2 A v _ => cPair 7 (cPair (codeFormula A) v)
  | FA3 A B v => cPair 8 (cPair (codeFormula A) (cPair (codeFormula B) v))
  | EQ1 => cPair 9 0
  | EQ2 => cPair 10 0
  | EQ3 => cPair 11 0
  | EQ4 r => cPair 12 (codeR r)
  | EQ5 f => cPair 13 (codeF f)
  end.

Lemma codePrfInjAxm :
 forall (a b : Formula) (A B : Formulas) (p : Prf A a) (q : Prf B b),
 codePrf A a p = codePrf B b q -> A = B.

Definition codeImp (a b : nat) := cPair 1 (cPair a b).

Lemma codeImpCorrect :
 forall a b : Formula,
 codeImp (codeFormula a) (codeFormula b) = codeFormula (impH a b).

Definition codeNot (a : nat) := cPair 2 a.

Lemma codeNotCorrect :
 forall a : Formula, codeNot (codeFormula a) = codeFormula (notH a).

Definition codeForall (n a : nat) := cPair 3 (cPair n a).

Lemma codeForallCorrect :
 forall (n : nat) (a : Formula),
 codeForall n (codeFormula a) = codeFormula (forallH n a).

Definition codeOr (a b : nat) := codeImp (codeNot a) b.

Lemma codeOrCorrect :
 forall a b : Formula,
 codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).

Definition codeAnd (a b : nat) := codeNot (codeOr (codeNot a) (codeNot b)).

Lemma codeAndCorrect :
 forall a b : Formula,
 codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).

Definition codeIff (a b : nat) := codeAnd (codeImp a b) (codeImp b a).

Lemma codeIffCorrect :
 forall a b : Formula,
 codeIff (codeFormula a) (codeFormula b) = codeFormula (iffH a b).

End Code_Term_Formula_Proof. *)

Require Import extEqualNat.
(* extEqualNat:
Require Import Arith.

Fixpoint naryFunc (n : nat) : Set :=
  match n with
  | O => nat
  | S n => nat -> naryFunc n
  end.

Fixpoint naryRel (n : nat) : Set :=
  match n with
  | O => bool
  | S n => nat -> naryRel n
  end.

Definition extEqual (n : nat) (a b : naryFunc n) : Prop.

Lemma extEqualRefl : forall (n : nat) (a : naryFunc n), extEqual n a a.

Lemma extEqualSym :
 forall (n : nat) (a b : naryFunc n), extEqual n a b -> extEqual n b a.

Lemma extEqualTrans :
 forall (n : nat) (a b c : naryFunc n),
 extEqual n a b -> extEqual n b c -> extEqual n a c.

Fixpoint charFunction (n : nat) : naryRel n -> naryFunc n :=
  match n return (naryRel n -> naryFunc n) with
  | O => fun R : bool => match R with
                         | true => 1
                         | false => 0
                         end
  | S m => fun (R : naryRel (S m)) (a : nat) => charFunction m (R a)
  end. *)

Require Vector.



Section Code_Substitute_Term.



Variable L : Language.

Variable codeF : Functions L -> nat.



Let Formula := Formula L.

Let Formulas := Formulas L.

Let System := System L.

Let Term := Term L.

Let Terms := Terms L.

Let var := var L.

Let apply := apply L.



Definition codeSubTermTerms : nat -> nat -> nat -> nat :=

  evalStrongRec 2

    (fun t recs v s : nat =>

     cPair

       (switchPR (cPairPi1 t)

          (cPair (cPairPi1 t) (cPairPi2 (codeNth (t - S (cPairPi2 t)) recs)))

          (switchPR (charFunction 2 beq_nat (cPairPi2 t) v) s t))

       (switchPR t

          (S

             (cPair (cPairPi1 (codeNth (t - S (cPairPi1 (pred t))) recs))

                (cPairPi2 (codeNth (t - S (cPairPi2 (pred t))) recs)))) 0)).



Definition codeSubTerm (t s v : nat) : nat :=

  cPairPi1 (codeSubTermTerms t s v).



Definition codeSubTerms (t s v : nat) : nat :=

  cPairPi2 (codeSubTermTerms t s v).



Lemma codeSubTermCorrect :

 forall (t : Term) (v : nat) (s : Term),

 codeSubTerm (codeTerm L codeF t) v (codeTerm L codeF s) =

 codeTerm L codeF (substituteTerm L t v s).

Proof.

set

 (g :=

  fun t0 recs v0 s0 : nat =>

  cPair

    (switchPR (cPairPi1 t0)

       (cPair (cPairPi1 t0) (cPairPi2 (codeNth (t0 - S (cPairPi2 t0)) recs)))

       (switchPR (charFunction 2 beq_nat (cPairPi2 t0) v0) s0 t0))

    (switchPR t0

       (S

          (cPair (cPairPi1 (codeNth (t0 - S (cPairPi1 (pred t0))) recs))

             (cPairPi2 (codeNth (t0 - S (cPairPi2 (pred t0))) recs)))) 0))

 in *.

intros.

elim t using

 Term_Terms_ind

  with

    (P0 := fun (n : nat) (ts : fol.Terms L n) =>

           codeSubTerms (codeTerms L codeF n ts) v (codeTerm L codeF s) =

           codeTerms L codeF n (substituteTerms L n ts v s)); 

 intros.

simpl in |- *.

replace (codeTerm L codeF (fol.var L n)) with (cPair 0 n).

unfold codeSubTerm in |- *.

unfold codeSubTermTerms in |- *.

unfold evalStrongRec in |- *.

simpl in |- *.

repeat rewrite cPairProjections1 || rewrite cPairProjections2.

simpl in |- *.

induction (eq_nat_dec v n).

rewrite a.

rewrite <- beq_nat_refl.

simpl in |- *.

reflexivity.

rewrite beq_nat_not_refl.

simpl in |- *.

reflexivity.

auto.

reflexivity.

simpl in |- *.

transitivity

 (cPair (S (codeF f))

    (codeTerms L codeF (arity L (inr (Relations L) f))

       (substituteTerms L (arity L (inr (Relations L) f)) t0 v s))).

rewrite <- H.

replace (codeTerm L codeF (fol.apply L f t0)) with

 (cPair (S (codeF f)) (codeTerms L codeF (arity L (inr (Relations L) f)) t0)).

generalize (codeF f) (codeTerms L codeF (arity L (inr (Relations L) f)) t0).

clear H t0 f.

intros.

unfold codeSubTerm in |- *.

unfold codeSubTermTerms in |- *.

fold g in |- *.

unfold evalStrongRec in |- *.

unfold evalComposeFunc in |- *.

unfold evalOneParamList in |- *.

unfold evalList in |- *.

rewrite computeEvalStrongRecHelp.

unfold compose2 in |- *.

unfold evalComposeFunc, evalOneParamList, evalList in |- *.

unfold pred in |- *.

repeat rewrite cPairProjections1 || rewrite cPairProjections2.

unfold g at 1 in |- *.

repeat rewrite cPairProjections1 || rewrite cPairProjections2.

assert

 (extEqual _

    (evalComposeFunc 2 1

       (Vector.cons _ (evalStrongRecHelp 2 g (cPair (S n) n0)) 0 (Vector.nil _))

       (fun b : nat => codeNth (cPair (S n) n0 - S n0) b))

    (evalStrongRec 2 g n0)).

apply (evalStrongRecHelp2 2).

apply cPairLt2.

simpl in H.

rewrite H.

clear H.

simpl in |- *.

reflexivity.

reflexivity.

reflexivity.

simpl in |- *.

unfold codeTerms in |- *.

unfold codeSubTerms in |- *.

unfold codeSubTermTerms in |- *.

unfold evalStrongRec in |- *.

simpl in |- *.

repeat rewrite cPairProjections1 || rewrite cPairProjections2.

reflexivity.

simpl in |- *.

transitivity

 (S

    (cPair (codeTerm L codeF (substituteTerm L t0 v s))

       (codeTerms L codeF n (substituteTerms L n t1 v s)))).

rewrite <- H.

rewrite <- H0.

replace (codeTerms L codeF (S n) (Tcons L n t0 t1)) with

 (S (cPair (codeTerm L codeF t0) (codeTerms L codeF n t1))).

generalize (codeTerm L codeF t0) (codeTerms L codeF n t1).

clear H0 t1 H t0 n.

intros.

unfold codeSubTerms at 1 in |- *.

unfold codeSubTermTerms in |- *.

fold g in |- *.

unfold evalStrongRec in |- *.

unfold evalComposeFunc, evalOneParamList, evalList in |- *.

rewrite computeEvalStrongRecHelp.

unfold compose2 in |- *.

unfold evalComposeFunc, evalOneParamList, evalList in |- *.

unfold pred in |- *.

repeat rewrite cPairProjections1 || rewrite cPairProjections2.

unfold g at 1 in |- *.

repeat rewrite cPairProjections1 || rewrite cPairProjections2.

unfold pred in |- *.

repeat rewrite cPairProjections1 || rewrite cPairProjections2.

assert

 (extEqual _

    (evalComposeFunc 2 1

       (Vector.cons _ (evalStrongRecHelp 2 g (S (cPair n n0))) 0 (Vector.nil _))

       (fun b : nat => codeNth (S (cPair n n0) - S n) b))

    (evalStrongRec 2 g n)).

apply (evalStrongRecHelp2 2).

apply le_lt_n_Sm.

apply cPairLe1.

simpl in H.

rewrite H.

clear H.

assert

 (extEqual _

    (evalComposeFunc 2 1

       (Vector.cons _ (evalStrongRecHelp 2 g (S (cPair n n0))) 0 (Vector.nil _))

       (fun b : nat => codeNth (S (cPair n n0) - S n0) b))

    (evalStrongRec 2 g n0)).

apply (evalStrongRecHelp2 2).

apply le_lt_n_Sm.

apply cPairLe2.

simpl in H.

rewrite H.

clear H.

simpl in |- *.

reflexivity.

reflexivity.

reflexivity.

Qed.



Lemma codeSubTermsCorrect :

 forall (n : nat) (ts : Terms n) (v : nat) (s : Term),

 codeSubTerms (codeTerms L codeF n ts) v (codeTerm L codeF s) =

 codeTerms L codeF n (substituteTerms L n ts v s).

Proof.

set

 (g :=

  fun t0 recs v0 s0 : nat =>

  cPair

    (switchPR (cPairPi1 t0)

       (cPair (cPairPi1 t0) (cPairPi2 (codeNth (t0 - S (cPairPi2 t0)) recs)))

       (switchPR (charFunction 2 beq_nat (cPairPi2 t0) v0) s0 t0))

    (switchPR t0

       (S

          (cPair (cPairPi1 (codeNth (t0 - S (cPairPi1 (pred t0))) recs))

             (cPairPi2 (codeNth (t0 - S (cPairPi2 (pred t0))) recs)))) 0))

 in *.

intros.

induction ts as [| n t ts Hrects].

simpl in |- *.

unfold codeTerms in |- *.

unfold codeSubTerms in |- *.

unfold codeSubTermTerms in |- *.

unfold evalStrongRec in |- *.

simpl in |- *.

repeat rewrite cPairProjections1 || rewrite cPairProjections2.

reflexivity.

simpl in |- *.

transitivity

 (S

    (cPair (codeTerm L codeF (substituteTerm L t v s))

       (codeTerms L codeF n (substituteTerms L n ts v s)))).

rewrite <- Hrects.

rewrite <- codeSubTermCorrect.

replace (codeTerms L codeF (S n) (Tcons L n t ts)) with

 (S (cPair (codeTerm L codeF t) (codeTerms L codeF n ts))).

generalize (codeTerm L codeF t) (codeTerms L codeF n ts).

clear Hrects ts t n.

intros.

unfold codeSubTerms at 1 in |- *.

unfold codeSubTermTerms in |- *.

fold g in |- *.

unfold evalStrongRec in |- *.

unfold evalComposeFunc, evalOneParamList, evalList in |- *.

rewrite computeEvalStrongRecHelp.

unfold compose2 in |- *.

unfold evalComposeFunc, evalOneParamList, evalList in |- *.

unfold pred in |- *.

repeat rewrite cPairProjections1 || rewrite cPairProjections2.

unfold g at 1 in |- *.

repeat rewrite cPairProjections1 || rewrite cPairProjections2.

unfold pred in |- *.

repeat rewrite cPairProjections1 || rewrite cPairProjections2.

assert

 (extEqual _

    (evalComposeFunc 2 1

       (Vector.cons _ (evalStrongRecHelp 2 g (S (cPair n n0))) 0 (Vector.nil _))

       (fun b : nat => codeNth (S (cPair n n0) - S n) b))

    (evalStrongRec 2 g n)).

apply (evalStrongRecHelp2 2).

apply le_lt_n_Sm.

apply cPairLe1.

simpl in H.

rewrite H.

clear H.

assert

 (extEqual _

    (evalComposeFunc 2 1

       (Vector.cons _ (evalStrongRecHelp 2 g (S (cPair n n0))) 0 (Vector.nil _))

       (fun b : nat => codeNth (S (cPair n n0) - S n0) b))

    (evalStrongRec 2 g n0)).

apply (evalStrongRecHelp2 2).

apply le_lt_n_Sm.

apply cPairLe2.

simpl in H.

rewrite H.

clear H.

simpl in |- *.

reflexivity.

reflexivity.

reflexivity.

Qed.



Lemma codeSubTermTermsIsPR : isPR 3 codeSubTermTerms.

Proof.

unfold codeSubTermTerms in |- *.

apply evalStrongRecIsPR.

apply

 compose4_2IsPR

  with

    (f1 := fun t recs v s : nat =>

           switchPR (cPairPi1 t)

             (cPair (cPairPi1 t)

                (cPairPi2 (codeNth (t - S (cPairPi2 t)) recs)))

             (switchPR (charFunction 2 beq_nat (cPairPi2 t) v) s t))

    (f2 := fun t recs v s : nat =>

           switchPR t

             (S

                (cPair (cPairPi1 (codeNth (t - S (cPairPi1 (pred t))) recs))

                   (cPairPi2 (codeNth (t - S (cPairPi2 (pred t))) recs)))) 0).

apply

 compose4_3IsPR

  with

    (f1 := fun t recs v s : nat => cPairPi1 t)

    (f2 := fun t recs v s : nat =>

           cPair (cPairPi1 t) (cPairPi2 (codeNth (t - S (cPairPi2 t)) recs)))

    (f3 := fun t recs v s : nat =>

           switchPR (charFunction 2 beq_nat (cPairPi2 t) v) s t).

apply filter1000IsPR with (g := cPairPi1).

apply cPairPi1IsPR.

apply

 filter1100IsPR

  with

    (g := fun t recs : nat =>

          cPair (cPairPi1 t) (cPairPi2 (codeNth (t - S (cPairPi2 t)) recs))).

apply

 compose2_2IsPR

  with

    (f := fun t recs : nat => cPairPi1 t)

    (g := fun t recs : nat => cPairPi2 (codeNth (t - S (cPairPi2 t)) recs)).

apply filter10IsPR with (g := cPairPi1).

apply cPairPi1IsPR.

apply

 compose2_1IsPR

  with (f := fun t recs : nat => codeNth (t - S (cPairPi2 t)) recs).

apply

 compose2_2IsPR

  with

    (f := fun t recs : nat => t - S (cPairPi2 t))

    (g := fun t recs : nat => recs).

apply filter10IsPR with (g := fun t : nat => t - S (cPairPi2 t)).

apply

 compose1_2IsPR

  with (f := fun t : nat => t) (f' := fun t : nat => S (cPairPi2 t)).

apply idIsPR.

apply compose1_1IsPR.

apply cPairPi2IsPR.

apply succIsPR.

apply minusIsPR.

apply pi2_2IsPR.

apply codeNthIsPR.

apply cPairPi2IsPR.

apply cPairIsPR.

apply

 filter1011IsPR

  with

    (g := fun t v s : nat =>

          switchPR (charFunction 2 beq_nat (cPairPi2 t) v) s t).

apply

 compose3_3IsPR

  with

    (f1 := fun t v s : nat => charFunction 2 beq_nat (cPairPi2 t) v)

    (f2 := fun t v s : nat => s)

    (f3 := fun t v s : nat => t).

apply

 filter110IsPR

  with (g := fun t v : nat => charFunction 2 beq_nat (cPairPi2 t) v).

apply

 compose2_2IsPR

  with (f := fun t v : nat => cPairPi2 t) (g := fun t v : nat => v).

apply filter10IsPR.

apply cPairPi2IsPR.

apply pi2_2IsPR.

apply eqIsPR.

apply pi3_3IsPR.

apply pi1_3IsPR.

apply switchIsPR.

apply switchIsPR.

apply

 filter1100IsPR

  with

    (g := fun t recs : nat =>

          switchPR t

            (S

               (cPair (cPairPi1 (codeNth (t - S (cPairPi1 (pred t))) recs))

                  (cPairPi2 (codeNth (t - S (cPairPi2 (pred t))) recs)))) 0).

apply

 compose2_3IsPR

  with

    (f1 := fun t recs : nat => t)

    (f2 := fun t recs : nat =>

           S

             (cPair (cPairPi1 (codeNth (t - S (cPairPi1 (pred t))) recs))

                (cPairPi2 (codeNth (t - S (cPairPi2 (pred t))) recs))))

    (f3 := fun t recs : nat => 0).

apply pi1_2IsPR.

apply

 compose2_1IsPR

  with

    (f := fun t recs : nat =>

          cPair (cPairPi1 (codeNth (t - S (cPairPi1 (pred t))) recs))

            (cPairPi2 (codeNth (t - S (cPairPi2 (pred t))) recs))).

assert

 (forall g : nat -> nat,

  isPR 1 g ->

  isPR 2 (fun t recs : nat => g (codeNth (t - S (g (pred t))) recs))).

intros.

apply

 compose2_1IsPR

  with (f := fun t recs : nat => codeNth (t - S (g (pred t))) recs).

apply

 compose2_2IsPR

  with

    (f := fun t recs : nat => t - S (g (pred t)))

    (g := fun t recs : nat => recs).

apply filter10IsPR with (g := fun t : nat => t - S (g (pred t))).

apply

 compose1_2IsPR

  with (f := fun t : nat => t) (f' := fun t : nat => S (g (pred t))).

apply idIsPR.

apply compose1_1IsPR with (f := fun t : nat => g (pred t)).

apply compose1_1IsPR.

apply predIsPR.

auto.

apply succIsPR.

apply minusIsPR.

apply pi2_2IsPR.

apply codeNthIsPR.

auto.

apply

 compose2_2IsPR

  with

    (f := fun t recs : nat =>

          cPairPi1 (codeNth (t - S (cPairPi1 (pred t))) recs))

    (g := fun t recs : nat =>

          cPairPi2 (codeNth (t - S (cPairPi2 (pred t))) recs)).

apply H.

apply cPairPi1IsPR.

apply H.

apply cPairPi2IsPR.

apply cPairIsPR.

apply succIsPR.

exists (composeFunc 2 0 (PRnil _) zeroFunc).

simpl in |- *.

auto.

apply switchIsPR.

apply cPairIsPR.

Qed.



Lemma codeSubTermIsPR : isPR 3 codeSubTerm.

Proof.

unfold codeSubTerm in |- *.

apply compose3_1IsPR.

apply codeSubTermTermsIsPR.

apply cPairPi1IsPR.

Qed.



Lemma codeSubTermsIsPR : isPR 3 codeSubTerms.

Proof.

unfold codeSubTerms in |- *.

apply compose3_1IsPR.

apply codeSubTermTermsIsPR.

apply cPairPi2IsPR.

Qed.



End Code_Substitute_Term.
