Require Import Ensembles.

Require Import Coq.Lists.List.

Require Import Peano_dec.



Require Import ListExt.
(* ListExt:
Require Import Coq.Lists.List.

Section List_Remove.

Variable A : Set.
Hypothesis Aeq_dec : forall a b : A, {a = b} + {a <> b}.

Definition list_remove (x : A) (l : list A) : list A :=
  list_rec (fun _ => list A) nil
    (fun (a : A) _ (recl : list A) =>
     match Aeq_dec a x with
     | left _ => recl
     | right _ => a :: recl
     end) l.

Lemma In_list_remove1 :
 forall (a b : A) (l : list A), In a (list_remove b l) -> In a l.

Lemma In_list_remove2 :
 forall (a b : A) (l : list A), In a (list_remove b l) -> a <> b.

Lemma In_list_remove3 :
 forall (a b : A) (l : list A), In a l -> a <> b -> In a (list_remove b l).

End List_Remove.

Section No_Duplicate.

Variable A : Set.
Hypothesis Aeq_dec : forall a b : A, {a = b} + {a <> b}.

Definition no_dup (l : list A) : list A :=
  list_rec (fun _ => list A) nil
    (fun (a : A) _ (rec : list A) =>
     match In_dec Aeq_dec a rec with
     | left _ => rec
     | right _ => a :: rec
     end) l.

Lemma no_dup1 : forall (a : A) (l : list A), In a l -> In a (no_dup l).

Lemma no_dup2 : forall (a : A) (l : list A), In a (no_dup l) -> In a l.

Lemma no_dup3 : forall (k l : list A) (a : A), no_dup k = a :: l -> ~ In a l.

End No_Duplicate. *)

Require Import folProof.
(* folProof:
Require Import Ensembles.
Require Import Coq.Lists.List.
Require Import Arith.

Require Export fol.
Require Import folProp.

Section ProofH.

Variable L : Language.

Let Formula := Formula L.
Let Formulas := Formulas L.
Let System := System L.
Let Term := Term L.
Let Terms := Terms L.
Let var := var L.
Let apply := apply L.
Let equal := equal L.
Let atomic := atomic L.
Let impH := impH L.
Let notH := notH L.
Let iffH := iffH L.
Let forallH := forallH L.

Definition nVars (n : nat) : Terms n * Terms n.

Definition AxmEq4 (R : Relations L) : Formula.

Definition AxmEq5 (f : Functions L) : Formula.

Inductive Prf : Formulas -> Formula -> Set :=
  | AXM : forall A : Formula, Prf (A :: nil) A
  | MP :
      forall (Axm1 Axm2 : Formulas) (A B : Formula),
      Prf Axm1 (impH A B) -> Prf Axm2 A -> Prf (Axm1 ++ Axm2) B
  | GEN :
      forall (Axm : Formulas) (A : Formula) (v : nat),
      ~ In v (freeVarListFormula L Axm) -> Prf Axm A -> Prf Axm (forallH v A)
  | IMP1 : forall A B : Formula, Prf nil (impH A (impH B A))
  | IMP2 :
      forall A B C : Formula,
      Prf nil (impH (impH A (impH B C)) (impH (impH A B) (impH A C)))
  | CP :
      forall A B : Formula,
      Prf nil (impH (impH (notH A) (notH B)) (impH B A))
  | FA1 :
      forall (A : Formula) (v : nat) (t : Term),
      Prf nil (impH (forallH v A) (substituteFormula L A v t))
  | FA2 :
      forall (A : Formula) (v : nat),
      ~ In v (freeVarFormula L A) -> Prf nil (impH A (forallH v A))
  | FA3 :
      forall (A B : Formula) (v : nat),
      Prf nil
        (impH (forallH v (impH A B)) (impH (forallH v A) (forallH v B)))
  | EQ1 : Prf nil (equal (var 0) (var 0))
  | EQ2 : Prf nil (impH (equal (var 0) (var 1)) (equal (var 1) (var 0)))
  | EQ3 :
      Prf nil
        (impH (equal (var 0) (var 1))
           (impH (equal (var 1) (var 2)) (equal (var 0) (var 2))))
  | EQ4 : forall R : Relations L, Prf nil (AxmEq4 R)
  | EQ5 : forall f : Functions L, Prf nil (AxmEq5 f).

Definition SysPrf (T : System) (f : Formula) :=
  exists Axm : Formulas,
    (exists prf : Prf Axm f,
       (forall g : Formula, In g Axm -> mem _ T g)).

Definition Inconsistent (T : System) := forall f : Formula, SysPrf T f.

Definition Consistent (T : System) := exists f : Formula, ~ SysPrf T f.

End ProofH. *)

Require Import folLogic.
(* folLogic:
Require Import Ensembles.
Require Import Coq.Lists.List.

Require Import ListExt.
Require Import folProof.
Require Import folProp.
Require Import Deduction.

Section Logic_Rules.

Variable L : Language.
Let Formula := Formula L.
Let Formulas := Formulas L.
Let System := System L.
Let Term := Term L.
Let Terms := Terms L.
Let var := var L.
Let apply := apply L.
Let equal := equal L.
Let atomic := atomic L.
Let impH := impH L.
Let notH := notH L.
Let forallH := forallH L.
Let orH := orH L.
Let andH := andH L.
Let existH := existH L.
Let iffH := iffH L.
Let ifThenElseH := ifThenElseH L.
Let Prf := Prf L.
Let SysPrf := SysPrf L.

Lemma Axm :
 forall (T : System) (f : Formula), mem _ T f -> SysPrf T f.

Lemma sysExtend :
 forall (T U : System) (f : Formula),
 Included _ T U -> SysPrf T f -> SysPrf U f.

Lemma sysWeaken :
 forall (T : System) (f g : Formula), SysPrf T f -> SysPrf (Ensembles.Add _ T g) f.

Lemma impI :
 forall (T : System) (f g : Formula),
 SysPrf (Ensembles.Add _ T g) f -> SysPrf T (impH g f).
Proof.
intros.
apply (DeductionTheorem L).

Lemma impE :
 forall (T : System) (f g : Formula),
 SysPrf T (impH g f) -> SysPrf T g -> SysPrf T f.

Lemma contradiction :
 forall (T : System) (f g : Formula),
 SysPrf T f -> SysPrf T (notH f) -> SysPrf T g.

Lemma nnE :
 forall (T : System) (f : Formula), SysPrf T (notH (notH f)) -> SysPrf T f.

Lemma noMiddle : forall (T : System) (f : Formula), SysPrf T (orH (notH f) f).

Lemma nnI :
 forall (T : System) (f : Formula), SysPrf T f -> SysPrf T (notH (notH f)).

Lemma cp1 :
 forall (T : System) (f g : Formula),
 SysPrf T (impH (notH f) (notH g)) -> SysPrf T (impH g f).

Lemma cp2 :
 forall (T : System) (f g : Formula),
 SysPrf T (impH g f) -> SysPrf T (impH (notH f) (notH g)).

Lemma orI1 :
 forall (T : System) (f g : Formula), SysPrf T f -> SysPrf T (orH f g).

Lemma orI2 :
 forall (T : System) (f g : Formula), SysPrf T g -> SysPrf T (orH f g).

Lemma orE :
 forall (T : System) (f g h : Formula),
 SysPrf T (orH f g) ->
 SysPrf T (impH f h) -> SysPrf T (impH g h) -> SysPrf T h.

Lemma orSys :
 forall (T : System) (f g h : Formula),
 SysPrf (Ensembles.Add _ T f) h -> SysPrf (Ensembles.Add _ T g) h -> SysPrf (Ensembles.Add _ T (orH f g)) h.

Lemma andI :
 forall (T : System) (f g : Formula),
 SysPrf T f -> SysPrf T g -> SysPrf T (andH f g).

Lemma andE1 :
 forall (T : System) (f g : Formula), SysPrf T (andH f g) -> SysPrf T f.

Lemma andE2 :
 forall (T : System) (f g : Formula), SysPrf T (andH f g) -> SysPrf T g.

Lemma iffI :
 forall (T : System) (f g : Formula),
 SysPrf T (impH f g) -> SysPrf T (impH g f) -> SysPrf T (iffH f g).

Lemma iffE1 :
 forall (T : System) (f g : Formula),
 SysPrf T (iffH f g) -> SysPrf T (impH f g).

Lemma iffE2 :
 forall (T : System) (f g : Formula),
 SysPrf T (iffH f g) -> SysPrf T (impH g f).

Lemma forallI :
 forall (T : System) (f : Formula) (v : nat),
 ~ In_freeVarSys L v T -> SysPrf T f -> SysPrf T (forallH v f).

Lemma forallE :
 forall (T : System) (f : Formula) (v : nat) (t : Term),
 SysPrf T (forallH v f) -> SysPrf T (substituteFormula L f v t).

Lemma forallSimp :
 forall (T : System) (f : Formula) (v : nat),
 SysPrf T (forallH v f) -> SysPrf T f.

Lemma existI :
 forall (T : System) (f : Formula) (v : nat) (t : Term),
 SysPrf T (substituteFormula L f v t) -> SysPrf T (existH v f).

Lemma existE :
 forall (T : System) (f g : Formula) (v : nat),
 ~ In_freeVarSys L v T ->
 ~ In v (freeVarFormula L g) ->
 SysPrf T (existH v f) -> SysPrf T (impH f g) -> SysPrf T g.

Lemma existSimp :
 forall (T : System) (f : Formula) (v : nat),
 SysPrf T f -> SysPrf T (existH v f).

Lemma existSys :
 forall (T : System) (f g : Formula) (v : nat),
 ~ In_freeVarSys L v T ->
 ~ In v (freeVarFormula L g) ->
 SysPrf (Ensembles.Add _ T f) g -> SysPrf (Ensembles.Add _ T (existH v f)) g.

Section Not_Rules.

Lemma absurd1 :
 forall (T : System) (f : Formula),
 SysPrf T (impH f (notH f)) -> SysPrf T (notH f).

Lemma nImp :
 forall (T : System) (f g : Formula),
 SysPrf T (andH f (notH g)) -> SysPrf T (notH (impH f g)).

Lemma nOr :
 forall (T : System) (f g : Formula),
 SysPrf T (andH (notH f) (notH g)) -> SysPrf T (notH (orH f g)).

Lemma nAnd :
 forall (T : System) (f g : Formula),
 SysPrf T (orH (notH f) (notH g)) -> SysPrf T (notH (andH f g)).

Lemma nForall :
 forall (T : System) (f : Formula) (v : nat),
 SysPrf T (existH v (notH f)) -> SysPrf T (notH (forallH v f)).

Lemma nExist :
 forall (T : System) (f : Formula) (v : nat),
 SysPrf T (forallH v (notH f)) -> SysPrf T (notH (existH v f)).

End Not_Rules.

Section Other_Rules.

Lemma impRefl : forall (T : System) (f : Formula), SysPrf T (impH f f).

Lemma impTrans :
 forall (T : System) (f g h : Formula),
 SysPrf T (impH f g) -> SysPrf T (impH g h) -> SysPrf T (impH f h).

Lemma orSym :
 forall (T : System) (f g : Formula),
 SysPrf T (orH f g) -> SysPrf T (orH g f).

Lemma andSym :
 forall (T : System) (f g : Formula),
 SysPrf T (andH f g) -> SysPrf T (andH g f).

Lemma iffRefl : forall (T : System) (f : Formula), SysPrf T (iffH f f).

Lemma iffSym :
 forall (T : System) (f g : Formula),
 SysPrf T (iffH f g) -> SysPrf T (iffH g f).

Lemma iffTrans :
 forall (T : System) (f g h : Formula),
 SysPrf T (iffH f g) -> SysPrf T (iffH g h) -> SysPrf T (iffH f h).

End Other_Rules.

Lemma openClosed :
 forall (T : System) (f : Formula), SysPrf T (close L f) -> SysPrf T f.

End Logic_Rules. *)

Require Import folProp.
(* folProp:
Require Import Wf_nat.
Require Import Max.
Require Import Arith.
Require Import Coq.Lists.List.
Require Import ListExt.
Require Import Peano_dec.

Require Export fol.

Section Fol_Properties.

Variable L : Language.

Notation Formula := (Formula L) (only parsing).
Notation Formulas := (Formulas L) (only parsing).
Notation System := (System L) (only parsing).
Notation Term := (Term L) (only parsing).
Notation Terms := (Terms L) (only parsing).
Let var := var L.
Let apply := apply L.
Let equal := equal L.
Let atomic := atomic L.
Let impH := impH L.
Let notH := notH L.
Let forallH := forallH L.
Let lt_depth := lt_depth L.

Section Free_Variables.

Fixpoint freeVarTerm (s : fol.Term L) : list nat :=
  match s with
  | fol.var v => v :: nil
  | fol.apply f ts => freeVarTerms (arity L (inr _ f)) ts
  end
 
 with freeVarTerms (n : nat) (ss : fol.Terms L n) {struct ss} : 
 list nat :=
  match ss with
  | Tnil => nil (A:=nat)
  | Tcons m t ts => freeVarTerm t ++ freeVarTerms m ts
  end.

Lemma freeVarTermApply :
 forall (f : Functions L) (ts : fol.Terms L _),

Fixpoint freeVarFormula (A : fol.Formula L) : list nat :=
  match A with
  | fol.equal t s => freeVarTerm t ++ freeVarTerm s
  | fol.atomic r ts => freeVarTerms _ ts
  | fol.impH A B => freeVarFormula A ++ freeVarFormula B
  | fol.notH A => freeVarFormula A
  | fol.forallH v A => list_remove _ eq_nat_dec v (freeVarFormula A)
  end.

Definition ClosedSystem (T : fol.System L) :=
  forall (v : nat) (f : fol.Formula L),
  mem _ T f -> ~ In v (freeVarFormula f).

Definition closeList (l : list nat) (x : fol.Formula L) : 
  fol.Formula L :=
  list_rec (fun _ => fol.Formula L) x
    (fun (a : nat) _ (rec : fol.Formula L) => forallH a rec) l.

Definition close (x : fol.Formula L) : fol.Formula L :=
  closeList (no_dup _ eq_nat_dec (freeVarFormula x)) x.

Lemma freeVarClosedList1 :
 forall (l : list nat) (v : nat) (x : fol.Formula L),

Lemma freeVarClosedList2 :
 forall (l : list nat) (v : nat) (x : fol.Formula L),

Lemma freeVarClosed :
 forall (x : fol.Formula L) (v : nat), ~ In v (freeVarFormula (close x)).

Fixpoint freeVarListFormula (l : fol.Formulas L) : 
 list nat :=
  match l with
  | nil => nil (A:=nat)
  | f :: l => freeVarFormula f ++ freeVarListFormula l
  end.

Lemma freeVarListFormulaApp :
 forall a b : fol.Formulas L,

Lemma In_freeVarListFormula :
 forall (v : nat) (f : fol.Formula L) (F : fol.Formulas L),

Lemma In_freeVarListFormulaE :
 forall (v : nat) (F : fol.Formulas L),

Definition In_freeVarSys (v : nat) (T : fol.System L) :=
  exists f : fol.Formula L, In v (freeVarFormula f) /\ mem _ T f.

Lemma notInFreeVarSys :
 forall x, ~ In_freeVarSys x (Ensembles.Empty_set (fol.Formula L)).

End Free_Variables.

Section Substitution.

Fixpoint substituteTerm (s : fol.Term L) (x : nat) 
 (t : fol.Term L) {struct s} : fol.Term L :=
  match s with
  | fol.var v =>
      match eq_nat_dec x v with
      | left _ => t
      | right _ => var v
      end
  | fol.apply f ts => apply f (substituteTerms _ ts x t)
  end
 
 with substituteTerms (n : nat) (ss : fol.Terms L n) 
 (x : nat) (t : fol.Term L) {struct ss} : fol.Terms L n :=
  match ss in (fol.Terms _ n0) return (fol.Terms L n0) with
  | Tnil => Tnil L
  | Tcons m s ts =>
      Tcons L m (substituteTerm s x t) (substituteTerms m ts x t)
  end.

Lemma subTermVar1 :
 forall (v : nat) (s : fol.Term L), substituteTerm (var v) v s = s.

Lemma subTermVar2 :
 forall (v x : nat) (s : fol.Term L),

Lemma subTermFunction :
 forall (f : Functions L) (ts : fol.Terms L (arity L (inr _ f))) 

Definition newVar (l : list nat) : nat := fold_right max 0 (map S l).

Lemma newVar2 : forall (l : list nat) (n : nat), In n l -> n < newVar l.

Lemma newVar1 : forall l : list nat, ~ In (newVar l) l.

Definition substituteFormulaImp (f : fol.Formula L)
  (frec : nat * fol.Term L -> {y : fol.Formula L | depth L y = depth L f})
  (g : fol.Formula L)
  (grec : nat * fol.Term L -> {y : fol.Formula L | depth L y = depth L g})
  (p : nat * fol.Term L) :
  {y : fol.Formula L | depth L y = depth L (impH f g)} :=
  match frec p with
  | exist f' prf1 =>
      match grec p with
      | exist g' prf2 =>
          exist
            (fun y : fol.Formula L =>
             depth L y = S (max (depth L f) (depth L g))) 
            (impH f' g')
            (eq_ind_r
               (fun n : nat =>
                S (max n (depth L g')) = S (max (depth L f) (depth L g)))
               (eq_ind_r
                  (fun n : nat =>
                   S (max (depth L f) n) = S (max (depth L f) (depth L g)))
                  (refl_equal (S (max (depth L f) (depth L g)))) prf2) prf1)
      end
  end.

Remark substituteFormulaImpNice :
 forall (f g : fol.Formula L)

Definition substituteFormulaNot (f : fol.Formula L)
  (frec : nat * fol.Term L -> {y : fol.Formula L | depth L y = depth L f})
  (p : nat * fol.Term L) :
  {y : fol.Formula L | depth L y = depth L (notH f)} :=
  match frec p with
  | exist f' prf1 =>
      exist (fun y : fol.Formula L => depth L y = S (depth L f)) 
        (notH f')
        (eq_ind_r (fun n : nat => S n = S (depth L f))
           (refl_equal (S (depth L f))) prf1)
  end.

Remark substituteFormulaNotNice :
 forall (f : fol.Formula L)

Definition substituteFormulaForall (n : nat) (f : fol.Formula L)
  (frec : forall b : fol.Formula L,
          lt_depth b (forallH n f) ->
          nat * fol.Term L -> {y : fol.Formula L | depth L y = depth L b})
  (p : nat * fol.Term L) :
  {y : fol.Formula L | depth L y = depth L (forallH n f)} :=
  match p with
  | (v, s) =>
      match eq_nat_dec n v with
      | left _ =>
          exist (fun y : fol.Formula L => depth L y = S (depth L f))
            (forallH n f) (refl_equal (depth L (forallH n f)))
      | right _ =>
          match In_dec eq_nat_dec n (freeVarTerm s) with
          | left _ =>
              let nv := newVar (v :: freeVarTerm s ++ freeVarFormula f) in
              match frec f (depthForall L f n) (n, var nv) with
              | exist f' prf1 =>
                  match
                    frec f'
                      (eqDepth L f' f (forallH n f) 
                         (sym_eq prf1) (depthForall L f n)) p
                  with
                  | exist f'' prf2 =>
                      exist
                        (fun y : fol.Formula L => depth L y = S (depth L f))
                        (forallH nv f'')
                        (eq_ind_r (fun n : nat => S n = S (depth L f))
                           (refl_equal (S (depth L f))) 
                           (trans_eq prf2 prf1))
                  end
              end
          | right _ =>
              match frec f (depthForall L f n) p with
              | exist f' prf1 =>
                  exist (fun y : fol.Formula L => depth L y = S (depth L f))
                    (forallH n f')
                    (eq_ind_r (fun n : nat => S n = S (depth L f))
                       (refl_equal (S (depth L f))) prf1)
              end
          end
      end
  end.

Remark substituteFormulaForallNice :
 forall (v : nat) (a : fol.Formula L)

Definition substituteFormulaHelp (f : fol.Formula L) 

Definition substituteFormula (f : fol.Formula L) (v : nat) 
  (s : fol.Term L) : fol.Formula L := proj1_sig (substituteFormulaHelp f v s).

Lemma subFormulaEqual :
 forall (t1 t2 : fol.Term L) (v : nat) (s : fol.Term L),

Lemma subFormulaRelation :
 forall (r : Relations L) (ts : fol.Terms L (arity L (inl _ r))) 

Lemma subFormulaImp :
 forall (f1 f2 : fol.Formula L) (v : nat) (s : fol.Term L),

Lemma subFormulaNot :
 forall (f : fol.Formula L) (v : nat) (s : fol.Term L),

Lemma subFormulaForall :
 forall (f : fol.Formula L) (x v : nat) (s : fol.Term L),

Section Extensions.

Let orH := orH L.
Let andH := andH L.
Let existH := existH L.
Let iffH := iffH L.
Let ifThenElseH := ifThenElseH L.

Lemma subFormulaOr :
 forall (f1 f2 : fol.Formula L) (v : nat) (s : fol.Term L),

Lemma subFormulaAnd :
 forall (f1 f2 : fol.Formula L) (v : nat) (s : fol.Term L),

Lemma subFormulaExist :
 forall (f : fol.Formula L) (x v : nat) (s : fol.Term L),

Lemma subFormulaIff :
 forall (f1 f2 : fol.Formula L) (v : nat) (s : fol.Term L),

Lemma subFormulaIfThenElse :
 forall (f1 f2 f3 : fol.Formula L) (v : nat) (s : fol.Term L),

End Extensions.

Lemma subFormulaDepth :
 forall (f : fol.Formula L) (v : nat) (s : fol.Term L),

Section Substitution_Properties.

Lemma subTermId :
 forall (t : fol.Term L) (v : nat), substituteTerm t v (var v) = t.

Lemma subTermsId :
 forall (n : nat) (ts : fol.Terms L n) (v : nat),

Lemma subFormulaId :
 forall (f : fol.Formula L) (v : nat), substituteFormula f v (var v) = f.

Lemma subFormulaForall2 :
 forall (f : fol.Formula L) (x v : nat) (s : fol.Term L),

Let existH := existH L.

Lemma subFormulaExist2 :
 forall (f : fol.Formula L) (x v : nat) (s : fol.Term L),

End Substitution_Properties.

End Substitution.
 
Definition Sentence (f:Formula) := (forall v : nat, ~ In v (freeVarFormula f)).

End Fol_Properties. *)



Section Replacement.



Variable L : Language.

Let Formula := Formula L.

Let Formulas := Formulas L.

Let System := System L.

Let Term := Term L.

Let Terms := Terms L.

Let var := var L.

Let apply := apply L.

Let equal := equal L.

Let atomic := atomic L.

Let impH := impH L.

Let notH := notH L.

Let forallH := forallH L.

Let orH := orH L.

Let andH := andH L.

Let existH := existH L.

Let iffH := iffH L.

Let ifThenElseH := ifThenElseH L.

Let SysPrf := SysPrf L.



Lemma reduceImp :

 forall (f1 f2 f3 f4 : Formula) (T : System),

 SysPrf T (iffH f1 f3) ->

 SysPrf T (iffH f2 f4) -> SysPrf T (iffH (impH f1 f2) (impH f3 f4)).

Proof.

assert

 (forall (f1 f2 f3 f4 : Formula) (T : System),

  SysPrf T (iffH f1 f3) ->

  SysPrf T (iffH f2 f4) -> SysPrf T (impH (impH f1 f2) (impH f3 f4))).

intros.

repeat apply (impI L).

apply impE with f2.

repeat apply sysWeaken.

apply (iffE1 L).

apply H0.

apply impE with f1.

apply sysWeaken.

apply Axm; right; constructor.

apply impE with f3.

repeat apply sysWeaken.

apply (iffE2 L).

apply H.

apply Axm; right; constructor.

intros.

apply (iffI L).

apply H; auto.

apply H; apply (iffSym L); auto.

Qed.



Lemma reduceNot :

 forall (f1 f2 : Formula) (T : System),

 SysPrf T (iffH f1 f2) -> SysPrf T (iffH (notH f1) (notH f2)).

Proof.

assert

 (forall (f1 f2 : Formula) (T : System),

  SysPrf T (iffH f1 f2) -> SysPrf T (impH (notH f1) (notH f2))).

intros.

apply (cp2 L).

apply (iffE2 L).

apply H.

intros.

apply (iffI L).

apply H.

assumption.

apply H.

apply (iffSym L).

assumption.

Qed.



Lemma impForall :

 forall (f1 f2 : Formula) (v : nat) (T : System),

 ~ In_freeVarSys _ v T ->

 SysPrf T (impH f1 f2) -> SysPrf T (impH (forallH v f1) (forallH v f2)).

Proof.

intros.

apply (impI L).

apply (forallI L).

unfold not in |- *; intros.

induction H1 as (x, H1); induction H1 as (H1, H2).

induction H2 as [x H2| x H2]; [ idtac | induction H2 ].

apply H.

unfold In_freeVarSys in |- *.

exists x.

auto.

apply (In_list_remove2 _ _ _ _ _ H1).

auto.

apply impE with f1.

apply sysWeaken.

apply H0.

eapply forallSimp.

apply Axm; right; constructor.

Qed.



Lemma reduceForall :

 forall (f1 f2 : Formula) (v : nat) (T : System),

 ~ In_freeVarSys _ v T ->

 SysPrf T (iffH f1 f2) -> SysPrf T (iffH (forallH v f1) (forallH v f2)).

Proof.

intros.

apply (iffI L).

apply impForall; auto.

apply (iffE1 L).

apply H0.

apply impForall; auto.

apply (iffE2 L).

apply H0.

Qed.



Lemma reduceOr :

 forall (f1 f2 f3 f4 : Formula) (T : System),

 SysPrf T (iffH f1 f3) ->

 SysPrf T (iffH f2 f4) -> SysPrf T (iffH (orH f1 f2) (orH f3 f4)).

Proof.

assert

 (forall (f1 f2 f3 f4 : Formula) (T : System),

  SysPrf T (iffH f1 f3) ->

  SysPrf T (iffH f2 f4) -> SysPrf T (impH (orH f1 f2) (orH f3 f4))).

intros.

apply (impI L).

apply (orSys L).

apply (orI1 L).

apply impE with f1.

apply sysWeaken.

apply (iffE1 L).

assumption.

apply Axm; right; constructor.

apply (orI2 L).

apply impE with f2.

apply sysWeaken.

apply (iffE1 L).

assumption.

apply Axm; right; constructor.

intros.

apply (iffI L).

apply H; auto.

apply H; apply (iffSym L); auto.

Qed.



Lemma reduceAnd :

 forall (f1 f2 f3 f4 : Formula) (T : System),

 SysPrf T (iffH f1 f3) ->

 SysPrf T (iffH f2 f4) -> SysPrf T (iffH (andH f1 f2) (andH f3 f4)).

Proof.

assert

 (forall (f1 f2 f3 f4 : Formula) (T : System),

  SysPrf T (iffH f1 f3) ->

  SysPrf T (iffH f2 f4) -> SysPrf T (impH (andH f1 f2) (andH f3 f4))).

intros.

apply (impI L).

apply (andI L).

apply impE with f1.

apply sysWeaken.

apply (iffE1 L).

assumption.

eapply (andE1 L).

apply Axm; right; constructor.

apply impE with f2.

apply sysWeaken.

apply (iffE1 L).

assumption.

eapply (andE2 L).

apply Axm; right; constructor.

intros.

apply (iffI L).

apply H; auto.

apply H; apply (iffSym L); auto.

Qed.



Lemma iffExist :

 forall (f1 f2 : Formula) (v : nat) (T : System),

 ~ In_freeVarSys _ v T ->

 SysPrf T (impH f1 f2) -> SysPrf T (impH (existH v f1) (existH v f2)).

Proof.

intros.

unfold existH, fol.existH in |- *.

apply (cp2 L).

apply impForall; auto.

apply (cp2 L).

apply H0.

Qed.



Lemma reduceExist :

 forall (f1 f2 : Formula) (v : nat) (T : System),

 ~ In_freeVarSys _ v T ->

 SysPrf T (iffH f1 f2) -> SysPrf T (iffH (existH v f1) (existH v f2)).

Proof.

intros.

unfold existH, fol.existH in |- *.

apply reduceNot.

apply reduceForall; auto.

apply reduceNot.

apply H0.

Qed.



Lemma reduceIff :

 forall (f1 f2 f3 f4 : Formula) (T : System),

 SysPrf T (iffH f1 f3) ->

 SysPrf T (iffH f2 f4) -> SysPrf T (iffH (iffH f1 f2) (iffH f3 f4)).

Proof.

assert

 (forall (f1 f2 f3 f4 : Formula) (T : System),

  SysPrf T (iffH f1 f3) ->

  SysPrf T (iffH f2 f4) -> SysPrf T (impH (iffH f1 f2) (iffH f3 f4))).

intros.

apply (impI L).

apply (iffTrans L) with f2.

apply (iffTrans L) with f1.

apply sysWeaken.

apply (iffSym L).

apply H.

apply Axm; right; constructor.

apply sysWeaken.

apply H0.

intros.

apply (iffI L).

apply H; auto.

apply H; apply (iffSym L); auto.

Qed.



Lemma reduceIfThenElse :

 forall (f1 f2 f3 f4 f5 f6 : Formula) (T : System),

 SysPrf T (iffH f1 f4) ->

 SysPrf T (iffH f2 f5) ->

 SysPrf T (iffH f3 f6) ->

 SysPrf T (iffH (ifThenElseH f1 f2 f3) (ifThenElseH f4 f5 f6)).

Proof.

intros.

unfold ifThenElseH, fol.ifThenElseH in |- *.

apply reduceAnd; apply reduceImp; auto.

apply reduceNot; auto.

Qed.



Lemma reduceSub :

 forall (T : System) (v : nat) (s : Term) (f g : Formula),

 ~ In_freeVarSys L v T ->

 SysPrf T (iffH f g) ->

 SysPrf T (iffH (substituteFormula L f v s) (substituteFormula L g v s)).

Proof.

assert

 (forall (T : System) (v : nat) (s : Term) (f g : Formula),

  ~ In_freeVarSys L v T ->

  SysPrf T (iffH f g) ->

  SysPrf T (impH (substituteFormula L f v s) (substituteFormula L g v s))).

intros.

rewrite <- (subFormulaImp L).

apply (forallE L).

apply forallI.

assumption.

apply (iffE1 L).

apply H0.

intros.

apply (iffI L).

apply H; auto.

apply H; auto.

apply (iffSym L).

auto.

Qed.



Lemma reduceCloseList :

 forall (l : list nat) (f1 f2 : Formula) (T : System),

 (forall v : nat, In v l -> ~ In_freeVarSys _ v T) ->

 SysPrf T (iffH f1 f2) ->

 SysPrf T (iffH (closeList L l f1) (closeList L l f2)).

Proof.

intro.

induction l as [| a l Hrecl]; simpl in |- *; intros.

apply H0.

apply reduceForall.

apply H.

auto.

apply Hrecl; auto.

Qed.



End Replacement.

