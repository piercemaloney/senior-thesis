Require Import primRec.
(* primRec:
Require Import Arith.
Require Import Peano_dec.
Require Import Compare_dec.
Require Import Coq.Lists.List.
Require Import Eqdep_dec.
Require Import extEqualNat.
Require Vector.
Require Import misc.
Require Export Bool.
Require Export EqNat.
Require Import Even.
Require Import Max.

Inductive PrimRec : nat -> Set :=
  | succFunc : PrimRec 1
  | zeroFunc : PrimRec 0
  | projFunc : forall n m : nat, m < n -> PrimRec n
  | composeFunc :
      forall (n m : nat) (g : PrimRecs n m) (h : PrimRec m), PrimRec n
  | primRecFunc :
      forall (n : nat) (g : PrimRec n) (h : PrimRec (S (S n))), PrimRec (S n)
with PrimRecs : nat -> nat -> Set :=
  | PRnil : forall n : nat, PrimRecs n 0
  | PRcons : forall n m : nat, PrimRec n -> PrimRecs n m -> PrimRecs n (S m).

Scheme PrimRec_PrimRecs_rec := Induction for PrimRec
  Sort Set
  with PrimRecs_PrimRec_rec := Induction for PrimRecs 
  Sort Set.

Scheme PrimRec_PrimRecs_ind := Induction for PrimRec
  Sort Prop
  with PrimRecs_PrimRec_ind := Induction for PrimRecs 
  Sort Prop.

Fixpoint evalConstFunc (n m : nat) {struct n} : naryFunc n :=
  match n return (naryFunc n) with
  | O => m
  | S n' => fun _ => evalConstFunc n' m
  end.

Fixpoint evalProjFunc (n : nat) : forall m : nat, m < n -> naryFunc n :=
  match n return (forall m : nat, m < n -> naryFunc n) with
  | O => fun (m : nat) (l : m < 0) => False_rec _ (lt_n_O _ l)
  | S n' =>
      fun (m : nat) (l : m < S n') =>
      match eq_nat_dec m n' with
      | left _ => fun a : nat => evalConstFunc _ a
      | right l1 =>
          fun _ =>
          evalProjFunc n' m
            match le_lt_or_eq _ _ (lt_n_Sm_le _ _ l) with
            | or_introl l2 => l2
            | or_intror l2 => False_ind _ (l1 l2)
            end
      end
  end.

Lemma evalProjFuncInd :
 forall (n m : nat) (p1 p2 : m < n),
 evalProjFunc n m p1 = evalProjFunc n m p2.

Fixpoint evalList (m : nat) (l : Vector.t nat m) {struct l} :
 naryFunc m -> nat :=
  match l in (Vector.t _ m) return (naryFunc m -> nat) with
  | Vector.nil => fun x : naryFunc 0 => x
  | Vector.cons a n l' => fun x : naryFunc (S n) => evalList n l' (x a)
  end.

Fixpoint evalOneParamList (n m a : nat) (l : Vector.t (naryFunc (S n)) m)
 {struct l} : Vector.t (naryFunc n) m :=
  match l in (Vector.t _ m) return (Vector.t (naryFunc n) m) with
  | Vector.nil  => Vector.nil  (naryFunc n)
  | Vector.cons f m' l' => Vector.cons _ (f a) m' (evalOneParamList n m' a l')
  end.

Fixpoint evalComposeFunc (n : nat) :
 forall m : nat, Vector.t (naryFunc n) m -> naryFunc m -> naryFunc n :=
  match
    n
    return
      (forall m : nat, Vector.t (naryFunc n) m -> naryFunc m -> naryFunc n)
  with
  | O => evalList
  | S n' =>
      fun (m : nat) (l : Vector.t (naryFunc (S n')) m) 
        (f : naryFunc m) (a : nat) =>
      evalComposeFunc n' m (evalOneParamList _ _ a l) f
  end.

Fixpoint compose2 (n : nat) : naryFunc n -> naryFunc (S n) -> naryFunc n :=
  match n return (naryFunc n -> naryFunc (S n) -> naryFunc n) with
  | O => fun (a : nat) (g : nat -> nat) => g a
  | S n' =>
      fun (f : naryFunc (S n')) (g : naryFunc (S (S n'))) (a : nat) =>
      compose2 n' (f a) (fun x : nat => g x a)
  end.

Fixpoint evalPrimRecFunc (n : nat) (g : naryFunc n) 
 (h : naryFunc (S (S n))) (a : nat) {struct a} : naryFunc n :=
  match a with
  | O => g
  | S a' => compose2 _ (evalPrimRecFunc n g h a') (h a')
  end.

Fixpoint evalPrimRec (n : nat) (f : PrimRec n) {struct f} : 
 naryFunc n :=
  match f in (PrimRec n) return (naryFunc n) with
  | succFunc => S
  | zeroFunc => 0
  | projFunc n m pf => evalProjFunc n m pf
  | composeFunc n m l f =>
      evalComposeFunc n m (evalPrimRecs _ _ l) (evalPrimRec _ f)
  | primRecFunc n g h =>
      evalPrimRecFunc n (evalPrimRec _ g) (evalPrimRec _ h)
  end
 
 with evalPrimRecs (n m : nat) (fs : PrimRecs n m) {struct fs} :
 Vector.t (naryFunc n) m :=
  match fs in (PrimRecs n m) return (Vector.t (naryFunc n) m) with
  | PRnil a => Vector.nil  (naryFunc a)
  | PRcons a b g gs => Vector.cons _ (evalPrimRec _ g) _ (evalPrimRecs _ _ gs)
  end.

Definition extEqualVectorGeneral (n m : nat) (l : Vector.t (naryFunc n) m) :

Definition extEqualVector n: forall m (l l' : Vector.t (naryFunc n) m), Prop.

Lemma extEqualVectorRefl :
 forall (n m : nat) (l : Vector.t (naryFunc n) m), extEqualVector n m l l.

Lemma extEqualOneParamList :
 forall (n m : nat) (l1 l2 : Vector.t (naryFunc (S n)) m) (c : nat),

Lemma extEqualCompose :
 forall (n m : nat) (l1 l2 : Vector.t (naryFunc n) m) (f1 f2 : naryFunc m),

Lemma extEqualCompose2 :
 forall (n : nat) (f1 f2 : naryFunc n),
 extEqual n f1 f2 ->
 forall g1 g2 : naryFunc (S n),
 extEqual (S n) g1 g2 -> extEqual n (compose2 n f1 g1) (compose2 n f2 g2).

Lemma extEqualPrimRec :
 forall (n : nat) (g1 g2 : naryFunc n) (h1 h2 : naryFunc (S (S n))),
 extEqual n g1 g2 ->
 extEqual (S (S n)) h1 h2 ->
 extEqual (S n) (evalPrimRecFunc n g1 h1) (evalPrimRecFunc n g2 h2).

Definition isPR (n : nat) (f : naryFunc n) : Set :=
  {p : PrimRec n | extEqual n (evalPrimRec _ p) f}.

Definition isPRrel (n : nat) (R : naryRel n) : Set :=
  isPR n (charFunction n R).

Lemma succIsPR : isPR 1 S.

Lemma const0_NIsPR : forall n : nat, isPR 0 n.

Lemma const1_NIsPR : forall n : nat, isPR 1 (fun _ => n).

Lemma idIsPR : isPR 1 (fun x : nat => x).

Lemma pi1_2IsPR : isPR 2 (fun a b : nat => a).

Lemma pi2_2IsPR : isPR 2 (fun a b : nat => b).

Lemma pi1_3IsPR : isPR 3 (fun a b c : nat => a).

Lemma pi2_3IsPR : isPR 3 (fun a b c : nat => b).

Lemma pi3_3IsPR : isPR 3 (fun a b c : nat => c).

Lemma pi1_4IsPR : isPR 4 (fun a b c d : nat => a).

Lemma pi2_4IsPR : isPR 4 (fun a b c d : nat => b).

Lemma pi3_4IsPR : isPR 4 (fun a b c d : nat => c).

Lemma pi4_4IsPR : isPR 4 (fun a b c d : nat => d).

Lemma filter01IsPR :
 forall g : nat -> nat, isPR 1 g -> isPR 2 (fun a b : nat => g b).

Lemma filter10IsPR :
 forall g : nat -> nat, isPR 1 g -> isPR 2 (fun a b : nat => g a).

Lemma filter100IsPR :
 forall g : nat -> nat, isPR 1 g -> isPR 3 (fun a b c : nat => g a).

Lemma filter010IsPR :
 forall g : nat -> nat, isPR 1 g -> isPR 3 (fun a b c : nat => g b).

Lemma filter001IsPR :
 forall g : nat -> nat, isPR 1 g -> isPR 3 (fun a b c : nat => g c).

Lemma filter011IsPR :
 forall g : nat -> nat -> nat, isPR 2 g -> isPR 3 (fun a b c : nat => g b c).

Lemma filter110IsPR :
 forall g : nat -> nat -> nat, isPR 2 g -> isPR 3 (fun a b c : nat => g a b).

Lemma filter101IsPR :
 forall g : nat -> nat -> nat, isPR 2 g -> isPR 3 (fun a b c : nat => g a c).

Lemma filter0011IsPR :
 forall g : nat -> nat -> nat,
 isPR 2 g -> isPR 4 (fun a b c d : nat => g c d).

Lemma filter1000IsPR :
 forall g : nat -> nat, isPR 1 g -> isPR 4 (fun a b c d : nat => g a).

Lemma filter1011IsPR :
 forall g : nat -> nat -> nat -> nat,
 isPR 3 g -> isPR 4 (fun a b c d : nat => g a c d).

Lemma filter1100IsPR :
 forall g : nat -> nat -> nat,
 isPR 2 g -> isPR 4 (fun a b c d : nat => g a b).

Lemma compose1_1IsPR :
 forall f : nat -> nat,
 isPR 1 f ->
 forall g : nat -> nat, isPR 1 g -> isPR 1 (fun x : nat => g (f x)).

Lemma compose1_2IsPR :
 forall f : nat -> nat,
 isPR 1 f ->
 forall f' : nat -> nat,
 isPR 1 f' ->
 forall g : nat -> nat -> nat,
 isPR 2 g -> isPR 1 (fun x : nat => g (f x) (f' x)).

Lemma compose1_3IsPR :
 forall f1 : nat -> nat,
 isPR 1 f1 ->
 forall f2 : nat -> nat,
 isPR 1 f2 ->
 forall f3 : nat -> nat,
 isPR 1 f3 ->
 forall g : nat -> nat -> nat -> nat,
 isPR 3 g -> isPR 1 (fun x : nat => g (f1 x) (f2 x) (f3 x)).

Lemma compose2_1IsPR :
 forall f : nat -> nat -> nat,
 isPR 2 f ->
 forall g : nat -> nat, isPR 1 g -> isPR 2 (fun x y : nat => g (f x y)).

Lemma compose2_2IsPR :
 forall f : nat -> nat -> nat,
 isPR 2 f ->
 forall g : nat -> nat -> nat,
 isPR 2 g ->
 forall h : nat -> nat -> nat,
 isPR 2 h -> isPR 2 (fun x y : nat => h (f x y) (g x y)).

Lemma compose2_3IsPR :
 forall f1 : nat -> nat -> nat,
 isPR 2 f1 ->
 forall f2 : nat -> nat -> nat,
 isPR 2 f2 ->
 forall f3 : nat -> nat -> nat,
 isPR 2 f3 ->
 forall g : nat -> nat -> nat -> nat,
 isPR 3 g -> isPR 2 (fun x y : nat => g (f1 x y) (f2 x y) (f3 x y)).

Lemma compose2_4IsPR :
 forall f1 : nat -> nat -> nat,
 isPR 2 f1 ->
 forall f2 : nat -> nat -> nat,
 isPR 2 f2 ->
 forall f3 : nat -> nat -> nat,
 isPR 2 f3 ->
 forall f4 : nat -> nat -> nat,
 isPR 2 f4 ->
 forall g : nat -> nat -> nat -> nat -> nat,
 isPR 4 g -> isPR 2 (fun x y : nat => g (f1 x y) (f2 x y) (f3 x y) (f4 x y)).

Lemma compose3_1IsPR :
 forall f : nat -> nat -> nat -> nat,
 isPR 3 f ->
 forall g : nat -> nat, isPR 1 g -> isPR 3 (fun x y z : nat => g (f x y z)).

Lemma compose3_2IsPR :
 forall f1 : nat -> nat -> nat -> nat,
 isPR 3 f1 ->
 forall f2 : nat -> nat -> nat -> nat,
 isPR 3 f2 ->
 forall g : nat -> nat -> nat,
 isPR 2 g -> isPR 3 (fun x y z : nat => g (f1 x y z) (f2 x y z)).

Lemma compose3_3IsPR :
 forall f1 : nat -> nat -> nat -> nat,
 isPR 3 f1 ->
 forall f2 : nat -> nat -> nat -> nat,
 isPR 3 f2 ->
 forall f3 : nat -> nat -> nat -> nat,
 isPR 3 f3 ->
 forall g : nat -> nat -> nat -> nat,
 isPR 3 g -> isPR 3 (fun x y z : nat => g (f1 x y z) (f2 x y z) (f3 x y z)).

Lemma compose4_2IsPR :
 forall f1 : nat -> nat -> nat -> nat -> nat,
 isPR 4 f1 ->
 forall f2 : nat -> nat -> nat -> nat -> nat,
 isPR 4 f2 ->
 forall g : nat -> nat -> nat,
 isPR 2 g -> isPR 4 (fun w x y z : nat => g (f1 w x y z) (f2 w x y z)).

Lemma compose4_3IsPR :
 forall f1 : nat -> nat -> nat -> nat -> nat,
 isPR 4 f1 ->
 forall f2 : nat -> nat -> nat -> nat -> nat,
 isPR 4 f2 ->
 forall f3 : nat -> nat -> nat -> nat -> nat,
 isPR 4 f3 ->
 forall g : nat -> nat -> nat -> nat,
 isPR 3 g ->
 isPR 4 (fun w x y z : nat => g (f1 w x y z) (f2 w x y z) (f3 w x y z)).

Lemma swapIsPR :
 forall f : nat -> nat -> nat, isPR 2 f -> isPR 2 (fun x y : nat => f y x).

Lemma indIsPR :
 forall f : nat -> nat -> nat,
 isPR 2 f ->
 forall g : nat,
 isPR 1
   (fun a : nat => nat_rec (fun n : nat => nat) g (fun x y : nat => f x y) a).

Lemma ind1ParamIsPR :
 forall f : nat -> nat -> nat -> nat,
 isPR 3 f ->
 forall g : nat -> nat,
 isPR 1 g ->
 isPR 2
   (fun a b : nat =>
    nat_rec (fun n : nat => nat) (g b) (fun x y : nat => f x y b) a).

Lemma ind2ParamIsPR :
 forall f : nat -> nat -> nat -> nat -> nat,
 isPR 4 f ->
 forall g : nat -> nat -> nat,
 isPR 2 g ->
 isPR 3
   (fun a b c : nat =>
    nat_rec (fun n : nat => nat) (g b c) (fun x y : nat => f x y b c) a).

Lemma plusIndIsPR : isPR 3 (fun n fn b : nat => S fn).

Lemma plusIsPR : isPR 2 plus.

Lemma multIndIsPR : isPR 3 (fun n fn b : nat => fn + b).

Lemma multIsPR : isPR 2 mult.

Lemma predIsPR : isPR 1 pred.

Lemma minusIndIsPR : isPR 3 (fun n fn b : nat => pred fn).

Lemma minusIsPR : isPR 2 minus.

Definition notZero (a : nat) :=
  nat_rec (fun n : nat => nat) 0 (fun x y : nat => 1) a.

Lemma notZeroIsPR : isPR 1 notZero.

Definition ltBool (a b : nat) : bool.

Lemma ltBoolTrue : forall a b : nat, ltBool a b = true -> a < b.

Lemma ltBoolFalse : forall a b : nat, ltBool a b = false -> ~ a < b.

Lemma ltIsPR : isPRrel 2 ltBool.

Lemma maxIsPR : isPR 2 max.

Lemma gtIsPR : isPRrel 2 (fun a b : nat => ltBool b a).

Remark replaceCompose2 :
 forall (n : nat) (a b a' b' : naryFunc n) (c c' : naryFunc 2),
 extEqual n a a' ->
 extEqual n b b' ->
 extEqual 2 c c' ->
 extEqual n
   (evalComposeFunc _ _ (Vector.cons _ a _ (Vector.cons _ b _ (Vector.nil  (naryFunc n)))) c)

Definition orRel (n : nat) (R S : naryRel n) : naryRel n.

Lemma orRelPR :
 forall (n : nat) (R R' : naryRel n),
 isPRrel n R -> isPRrel n R' -> isPRrel n (orRel n R R').

Definition andRel (n : nat) (R S : naryRel n) : naryRel n.

Lemma andRelPR :
 forall (n : nat) (R R' : naryRel n),
 isPRrel n R -> isPRrel n R' -> isPRrel n (andRel n R R').

Definition notRel (n : nat) (R : naryRel n) : naryRel n.

Lemma notRelPR :
 forall (n : nat) (R : naryRel n), isPRrel n R -> isPRrel n (notRel n R).

Fixpoint bodd (n : nat) : bool :=
  match n with
  | O => false
  | S n' => negb (bodd n')
  end.

Lemma boddIsPR : isPRrel 1 bodd.

Lemma beq_nat_not_refl : forall a b : nat, a <> b -> beq_nat a b = false.

Lemma neqIsPR : isPRrel 2 (fun a b : nat => negb (beq_nat a b)).

Lemma eqIsPR : isPRrel 2 beq_nat.

Definition leBool (a b : nat) : bool.

Lemma leIsPR : isPRrel 2 leBool.

Section Ignore_Params.

Fixpoint ignoreParams (n m : nat) (f : naryFunc n) {struct m} :
 naryFunc (m + n) :=
  match m return (naryFunc (m + n)) with
  | O => f
  | S x => fun _ => ignoreParams n x f
  end.

Definition projectionListPR (n m : nat) (p : m <= n) : PrimRecs n m.

Definition projectionList (n m : nat) (p : m <= n) : 
  Vector.t (naryFunc n) m := evalPrimRecs n m (projectionListPR n m p).

Lemma projectionListInd :
 forall (n m : nat) (p1 p2 : m <= n),
 projectionList n m p1 = projectionList n m p2.

Lemma projectionListApplyParam :
 forall (m n c : nat) (p1 : m <= n) (p2 : m <= S n),
 extEqualVector _ _ (projectionList n m p1)
   (evalOneParamList n m c (projectionList (S n) m p2)).

Lemma projectionListId :
 forall (n : nat) (f : naryFunc n) (p : n <= n),
 extEqual n f (evalComposeFunc n n (projectionList n n p) f).

Lemma ignoreParamsIsPR :
 forall (n m : nat) (f : naryFunc n), isPR _ f -> isPR _ (ignoreParams n m f).

End Ignore_Params.

Lemma reduce1stCompose :
 forall (c n m : nat) (v : Vector.t (naryFunc n) m) (g : naryFunc (S m)),

Lemma reduce2ndCompose :
 forall (c n m : nat) (v : Vector.t (naryFunc n) m) (n0 : naryFunc n)

Lemma evalPrimRecParam :
 forall (n c d : nat) (g : naryFunc (S n)) (h : naryFunc (S (S (S n)))),
 extEqual _ (evalPrimRecFunc n (g d) (fun x y : nat => h x y d) c)
   (evalPrimRecFunc (S n) g h c d).

Lemma compose2IsPR :
 forall (n : nat) (f : naryFunc n) (p : isPR n f) (g : naryFunc (S n))
   (q : isPR (S n) g), isPR n (compose2 n f g).

Lemma compose1_NIsPR :
 forall (n : nat) (g : naryFunc (S n)),
 isPR (S n) g ->
 forall f : naryFunc 1, isPR 1 f -> isPR (S n) (fun x : nat => g (f x)).

Definition switchPR : naryFunc 3. 

Lemma switchIsPR : isPR 3 switchPR.

Fixpoint boundedSearchHelp (P : naryRel 1) (b : nat) {struct b} : nat :=
  match b with
  | O => 0
  | S b' =>
      match eq_nat_dec (boundedSearchHelp P b') b' with
      | left _ => match P b' with
                  | true => b'
                  | false => S b'
                  end
      | right _ => boundedSearchHelp P b'
      end
  end.
   
Definition boundedSearch (P : naryRel 2) (b : nat) : nat :=
  boundedSearchHelp (P b) b.

Lemma boundedSearch1 :
 forall (P : naryRel 2) (b x : nat), x < boundedSearch P b -> P b x = false.

Lemma boundedSearch2 :
 forall (P : naryRel 2) (b : nat),
 boundedSearch P b = b \/ P b (boundedSearch P b) = true.

Lemma boundSearchIsPR :
 forall P : naryRel 2,
 isPRrel 2 P -> isPR 1 (fun b : nat => boundedSearch P b).

Definition iterate (g : nat -> nat) :=
  nat_rec (fun _ => nat -> nat) (fun x : nat => x)
    (fun (_ : nat) (rec : nat -> nat) (x : nat) => g (rec x)).

Lemma iterateIsPR :
 forall g : nat -> nat, isPR 1 g -> forall n : nat, isPR 1 (iterate g n). *)

Require Import cPair.
(* cPair:
Require Import Arith.
Require Import Coq.Lists.List.
Require Import extEqualNat.
Require Import primRec.
Require Vector.
Require Import Div2.

Definition sumToN (n : nat) :=
  nat_rec (fun _ => nat) 0 (fun x y : nat => S x + y) n.

Lemma sumToN1 : forall n : nat, n <= sumToN n.

Lemma sumToN2 : forall b a : nat, a <= b -> sumToN a <= sumToN b.

Lemma sumToNIsPR : isPR 1 sumToN.

Definition cPair (a b : nat) := a + sumToN (a + b).

Lemma cPairIsPR : isPR 2 cPair.

Section CPair_Injectivity.

Remark cPairInjHelp :
 forall a b c d : nat, cPair a b = cPair c d -> a + b = c + d.

Lemma cPairInj1 : forall a b c d : nat, cPair a b = cPair c d -> a = c.

Lemma cPairInj2 : forall a b c d : nat, cPair a b = cPair c d -> b = d.

End CPair_Injectivity.

Section CPair_projections.

Let searchXY (a : nat) :=
  boundedSearch (fun a y : nat => ltBool a (sumToN (S y))) a.

Definition cPairPi1 (a : nat) := a - sumToN (searchXY a).
Definition cPairPi2 (a : nat) := searchXY a - cPairPi1 a.

Lemma cPairProjectionsHelp :
 forall a b : nat, b < sumToN (S a) -> sumToN a <= b -> searchXY b = a.

Lemma cPairProjections : forall a : nat, cPair (cPairPi1 a) (cPairPi2 a) = a.

Remark searchXYIsPR : isPR 1 searchXY.

Lemma cPairPi1IsPR : isPR 1 cPairPi1.

Lemma cPairPi2IsPR : isPR 1 cPairPi2.

Lemma cPairProjections1 : forall a b : nat, cPairPi1 (cPair a b) = a.

Lemma cPairProjections2 : forall a b : nat, cPairPi2 (cPair a b) = b.

End CPair_projections.

Section CPair_Order.

Lemma cPairLe1 : forall a b : nat, a <= cPair a b.

Lemma cPairLe1A : forall a : nat, cPairPi1 a <= a.

Lemma cPairLe2 : forall a b : nat, b <= cPair a b.

Lemma cPairLe2A : forall a : nat, cPairPi2 a <= a.

Lemma cPairLe3 :
 forall a b c d : nat, a <= b -> c <= d -> cPair a c <= cPair b d.

Lemma cPairLt1 : forall a b : nat, a < cPair a (S b).

Lemma cPairLt2 : forall a b : nat, b < cPair (S a) b.

End CPair_Order.

Section code_nat_list.

Fixpoint codeList (l : list nat) : nat :=
  match l with
  | nil => 0
  | n :: l' => S (cPair n (codeList l'))
  end.

Lemma codeListInj : forall l m : list nat, codeList l = codeList m -> l = m.

Definition codeNth (n m : nat) : nat.

Let drop (n : nat) : forall (l : list nat), list nat.

Lemma codeNthCorrect :
 forall (n : nat) (l : list nat), codeNth n (codeList l) = nth n l 0.

Lemma codeNthIsPR : isPR 2 codeNth.

End code_nat_list.

Section Strong_Recursion.

Definition evalStrongRecHelp (n : nat) (f : naryFunc (S (S n))) :
  naryFunc (S n) :=
  evalPrimRecFunc n (evalComposeFunc n 0 (Vector.nil _) (codeList nil))
    (evalComposeFunc (S (S n)) 2
       (Vector.cons _ f _
          (Vector.cons _ (evalProjFunc (S (S n)) n (lt_S _ _ (lt_n_Sn _))) _
             (Vector.nil _))) (fun a b : nat => S (cPair a b))).

Definition evalStrongRec (n : nat) (f : naryFunc (S (S n))) :
  naryFunc (S n) :=
  evalComposeFunc (S n) 1
    (Vector.cons _ (fun z : nat => evalStrongRecHelp n f (S z)) _ (Vector.nil _))
    (fun z : nat => cPairPi1 (pred z)).

Lemma evalStrongRecIsPR :
 forall (n : nat) (f : naryFunc (S (S n))),
 isPR _ f -> isPR _ (evalStrongRec n f).

Lemma computeEvalStrongRecHelp :
 forall (n : nat) (f : naryFunc (S (S n))) (c : nat),
 evalStrongRecHelp n f (S c) =
 compose2 n (evalStrongRecHelp n f c)
   (fun a0 : nat =>
    evalComposeFunc n 2
      (Vector.cons (naryFunc n) (f c a0) 1

Let listValues (f : naryFunc 2) (n : nat) : list nat.

Lemma evalStrongRecHelp1 :
 forall (f : naryFunc 2) (n m : nat),
 m < n -> codeNth (n - S m) (evalStrongRecHelp _ f n) = evalStrongRec _ f m.

Lemma evalStrongRecHelpParam :
 forall (a n c : nat) (f : naryFunc (S (S (S a)))),
 extEqual a (evalStrongRecHelp (S a) f n c)
   (evalStrongRecHelp a (fun x y : nat => f x y c) n).

Lemma evalStrongRecHelp2 :
 forall (a : nat) (f : naryFunc (S (S a))) (n m : nat),
 m < n ->
 extEqual _
   (evalComposeFunc _ 1 (Vector.cons _ (evalStrongRecHelp _ f n) 0 (Vector.nil _))

Lemma callIsPR :
 forall g : nat -> nat,
 isPR 1 g -> isPR 2 (fun a recs : nat => codeNth (a - S (g a)) recs).

End Strong_Recursion.

Lemma div2IsPR : isPR 1 div2. *)

Require Import Coq.Lists.List.

Require Import ListExt.
(* ListExt:
Require Import Coq.Lists.List.

Section List_Remove.

Variable A : Set.
Hypothesis Aeq_dec : forall a b : A, {a = b} + {a <> b}.

Definition list_remove (x : A) (l : list A) : list A :=
  list_rec (fun _ => list A) nil
    (fun (a : A) _ (recl : list A) =>
     match Aeq_dec a x with
     | left _ => recl
     | right _ => a :: recl
     end) l.

Lemma In_list_remove1 :
 forall (a b : A) (l : list A), In a (list_remove b l) -> In a l.

Lemma In_list_remove2 :
 forall (a b : A) (l : list A), In a (list_remove b l) -> a <> b.

Lemma In_list_remove3 :
 forall (a b : A) (l : list A), In a l -> a <> b -> In a (list_remove b l).

End List_Remove.

Section No_Duplicate.

Variable A : Set.
Hypothesis Aeq_dec : forall a b : A, {a = b} + {a <> b}.

Definition no_dup (l : list A) : list A :=
  list_rec (fun _ => list A) nil
    (fun (a : A) _ (rec : list A) =>
     match In_dec Aeq_dec a rec with
     | left _ => rec
     | right _ => a :: rec
     end) l.

Lemma no_dup1 : forall (a : A) (l : list A), In a l -> In a (no_dup l).

Lemma no_dup2 : forall (a : A) (l : list A), In a (no_dup l) -> In a l.

Lemma no_dup3 : forall (k l : list A) (a : A), no_dup k = a :: l -> ~ In a l.

End No_Duplicate. *)

Require Import Arith.

Require Export codeList.

Require Import folProp.
(* folProp:
Require Import Wf_nat.
Require Import Max.
Require Import Arith.
Require Import Coq.Lists.List.
Require Import ListExt.
Require Import Peano_dec.

Require Export fol.

Section Fol_Properties.

Variable L : Language.

Notation Formula := (Formula L) (only parsing).
Notation Formulas := (Formulas L) (only parsing).
Notation System := (System L) (only parsing).
Notation Term := (Term L) (only parsing).
Notation Terms := (Terms L) (only parsing).
Let var := var L.
Let apply := apply L.
Let equal := equal L.
Let atomic := atomic L.
Let impH := impH L.
Let notH := notH L.
Let forallH := forallH L.
Let lt_depth := lt_depth L.

Section Free_Variables.

Fixpoint freeVarTerm (s : fol.Term L) : list nat :=
  match s with
  | fol.var v => v :: nil
  | fol.apply f ts => freeVarTerms (arity L (inr _ f)) ts
  end
 
 with freeVarTerms (n : nat) (ss : fol.Terms L n) {struct ss} : 
 list nat :=
  match ss with
  | Tnil => nil (A:=nat)
  | Tcons m t ts => freeVarTerm t ++ freeVarTerms m ts
  end.

Lemma freeVarTermApply :
 forall (f : Functions L) (ts : fol.Terms L _),

Fixpoint freeVarFormula (A : fol.Formula L) : list nat :=
  match A with
  | fol.equal t s => freeVarTerm t ++ freeVarTerm s
  | fol.atomic r ts => freeVarTerms _ ts
  | fol.impH A B => freeVarFormula A ++ freeVarFormula B
  | fol.notH A => freeVarFormula A
  | fol.forallH v A => list_remove _ eq_nat_dec v (freeVarFormula A)
  end.

Definition ClosedSystem (T : fol.System L) :=
  forall (v : nat) (f : fol.Formula L),
  mem _ T f -> ~ In v (freeVarFormula f).

Definition closeList (l : list nat) (x : fol.Formula L) : 
  fol.Formula L :=
  list_rec (fun _ => fol.Formula L) x
    (fun (a : nat) _ (rec : fol.Formula L) => forallH a rec) l.

Definition close (x : fol.Formula L) : fol.Formula L :=
  closeList (no_dup _ eq_nat_dec (freeVarFormula x)) x.

Lemma freeVarClosedList1 :
 forall (l : list nat) (v : nat) (x : fol.Formula L),

Lemma freeVarClosedList2 :
 forall (l : list nat) (v : nat) (x : fol.Formula L),

Lemma freeVarClosed :
 forall (x : fol.Formula L) (v : nat), ~ In v (freeVarFormula (close x)).

Fixpoint freeVarListFormula (l : fol.Formulas L) : 
 list nat :=
  match l with
  | nil => nil (A:=nat)
  | f :: l => freeVarFormula f ++ freeVarListFormula l
  end.

Lemma freeVarListFormulaApp :
 forall a b : fol.Formulas L,

Lemma In_freeVarListFormula :
 forall (v : nat) (f : fol.Formula L) (F : fol.Formulas L),

Lemma In_freeVarListFormulaE :
 forall (v : nat) (F : fol.Formulas L),

Definition In_freeVarSys (v : nat) (T : fol.System L) :=
  exists f : fol.Formula L, In v (freeVarFormula f) /\ mem _ T f.

Lemma notInFreeVarSys :
 forall x, ~ In_freeVarSys x (Ensembles.Empty_set (fol.Formula L)).

End Free_Variables.

Section Substitution.

Fixpoint substituteTerm (s : fol.Term L) (x : nat) 
 (t : fol.Term L) {struct s} : fol.Term L :=
  match s with
  | fol.var v =>
      match eq_nat_dec x v with
      | left _ => t
      | right _ => var v
      end
  | fol.apply f ts => apply f (substituteTerms _ ts x t)
  end
 
 with substituteTerms (n : nat) (ss : fol.Terms L n) 
 (x : nat) (t : fol.Term L) {struct ss} : fol.Terms L n :=
  match ss in (fol.Terms _ n0) return (fol.Terms L n0) with
  | Tnil => Tnil L
  | Tcons m s ts =>
      Tcons L m (substituteTerm s x t) (substituteTerms m ts x t)
  end.

Lemma subTermVar1 :
 forall (v : nat) (s : fol.Term L), substituteTerm (var v) v s = s.

Lemma subTermVar2 :
 forall (v x : nat) (s : fol.Term L),

Lemma subTermFunction :
 forall (f : Functions L) (ts : fol.Terms L (arity L (inr _ f))) 

Definition newVar (l : list nat) : nat := fold_right max 0 (map S l).

Lemma newVar2 : forall (l : list nat) (n : nat), In n l -> n < newVar l.

Lemma newVar1 : forall l : list nat, ~ In (newVar l) l.

Definition substituteFormulaImp (f : fol.Formula L)
  (frec : nat * fol.Term L -> {y : fol.Formula L | depth L y = depth L f})
  (g : fol.Formula L)
  (grec : nat * fol.Term L -> {y : fol.Formula L | depth L y = depth L g})
  (p : nat * fol.Term L) :
  {y : fol.Formula L | depth L y = depth L (impH f g)} :=
  match frec p with
  | exist f' prf1 =>
      match grec p with
      | exist g' prf2 =>
          exist
            (fun y : fol.Formula L =>
             depth L y = S (max (depth L f) (depth L g))) 
            (impH f' g')
            (eq_ind_r
               (fun n : nat =>
                S (max n (depth L g')) = S (max (depth L f) (depth L g)))
               (eq_ind_r
                  (fun n : nat =>
                   S (max (depth L f) n) = S (max (depth L f) (depth L g)))
                  (refl_equal (S (max (depth L f) (depth L g)))) prf2) prf1)
      end
  end.

Remark substituteFormulaImpNice :
 forall (f g : fol.Formula L)

Definition substituteFormulaNot (f : fol.Formula L)
  (frec : nat * fol.Term L -> {y : fol.Formula L | depth L y = depth L f})
  (p : nat * fol.Term L) :
  {y : fol.Formula L | depth L y = depth L (notH f)} :=
  match frec p with
  | exist f' prf1 =>
      exist (fun y : fol.Formula L => depth L y = S (depth L f)) 
        (notH f')
        (eq_ind_r (fun n : nat => S n = S (depth L f))
           (refl_equal (S (depth L f))) prf1)
  end.

Remark substituteFormulaNotNice :
 forall (f : fol.Formula L)

Definition substituteFormulaForall (n : nat) (f : fol.Formula L)
  (frec : forall b : fol.Formula L,
          lt_depth b (forallH n f) ->
          nat * fol.Term L -> {y : fol.Formula L | depth L y = depth L b})
  (p : nat * fol.Term L) :
  {y : fol.Formula L | depth L y = depth L (forallH n f)} :=
  match p with
  | (v, s) =>
      match eq_nat_dec n v with
      | left _ =>
          exist (fun y : fol.Formula L => depth L y = S (depth L f))
            (forallH n f) (refl_equal (depth L (forallH n f)))
      | right _ =>
          match In_dec eq_nat_dec n (freeVarTerm s) with
          | left _ =>
              let nv := newVar (v :: freeVarTerm s ++ freeVarFormula f) in
              match frec f (depthForall L f n) (n, var nv) with
              | exist f' prf1 =>
                  match
                    frec f'
                      (eqDepth L f' f (forallH n f) 
                         (sym_eq prf1) (depthForall L f n)) p
                  with
                  | exist f'' prf2 =>
                      exist
                        (fun y : fol.Formula L => depth L y = S (depth L f))
                        (forallH nv f'')
                        (eq_ind_r (fun n : nat => S n = S (depth L f))
                           (refl_equal (S (depth L f))) 
                           (trans_eq prf2 prf1))
                  end
              end
          | right _ =>
              match frec f (depthForall L f n) p with
              | exist f' prf1 =>
                  exist (fun y : fol.Formula L => depth L y = S (depth L f))
                    (forallH n f')
                    (eq_ind_r (fun n : nat => S n = S (depth L f))
                       (refl_equal (S (depth L f))) prf1)
              end
          end
      end
  end.

Remark substituteFormulaForallNice :
 forall (v : nat) (a : fol.Formula L)

Definition substituteFormulaHelp (f : fol.Formula L) 

Definition substituteFormula (f : fol.Formula L) (v : nat) 
  (s : fol.Term L) : fol.Formula L := proj1_sig (substituteFormulaHelp f v s).

Lemma subFormulaEqual :
 forall (t1 t2 : fol.Term L) (v : nat) (s : fol.Term L),

Lemma subFormulaRelation :
 forall (r : Relations L) (ts : fol.Terms L (arity L (inl _ r))) 

Lemma subFormulaImp :
 forall (f1 f2 : fol.Formula L) (v : nat) (s : fol.Term L),

Lemma subFormulaNot :
 forall (f : fol.Formula L) (v : nat) (s : fol.Term L),

Lemma subFormulaForall :
 forall (f : fol.Formula L) (x v : nat) (s : fol.Term L),

Section Extensions.

Let orH := orH L.
Let andH := andH L.
Let existH := existH L.
Let iffH := iffH L.
Let ifThenElseH := ifThenElseH L.

Lemma subFormulaOr :
 forall (f1 f2 : fol.Formula L) (v : nat) (s : fol.Term L),

Lemma subFormulaAnd :
 forall (f1 f2 : fol.Formula L) (v : nat) (s : fol.Term L),

Lemma subFormulaExist :
 forall (f : fol.Formula L) (x v : nat) (s : fol.Term L),

Lemma subFormulaIff :
 forall (f1 f2 : fol.Formula L) (v : nat) (s : fol.Term L),

Lemma subFormulaIfThenElse :
 forall (f1 f2 f3 : fol.Formula L) (v : nat) (s : fol.Term L),

End Extensions.

Lemma subFormulaDepth :
 forall (f : fol.Formula L) (v : nat) (s : fol.Term L),

Section Substitution_Properties.

Lemma subTermId :
 forall (t : fol.Term L) (v : nat), substituteTerm t v (var v) = t.

Lemma subTermsId :
 forall (n : nat) (ts : fol.Terms L n) (v : nat),

Lemma subFormulaId :
 forall (f : fol.Formula L) (v : nat), substituteFormula f v (var v) = f.

Lemma subFormulaForall2 :
 forall (f : fol.Formula L) (x v : nat) (s : fol.Term L),

Let existH := existH L.

Lemma subFormulaExist2 :
 forall (f : fol.Formula L) (x v : nat) (s : fol.Term L),

End Substitution_Properties.

End Substitution.
 
Definition Sentence (f:Formula) := (forall v : nat, ~ In v (freeVarFormula f)).

End Fol_Properties. *)

Require Import code.
(* code:
Require Import Arith.
Require Import fol.
Require Import folProof.
Require Import cPair.

Section Code_Term_Formula_Proof.

Variable L : Language.
Variable codeF : Functions L -> nat.
Variable codeR : Relations L -> nat.
Hypothesis codeFInj : forall f g : Functions L, codeF f = codeF g -> f = g.
Hypothesis codeRInj : forall R S : Relations L, codeR R = codeR S -> R = S.

Let Formula := Formula L.
Let Formulas := Formulas L.
Let System := System L.
Let Term := Term L.
Let Terms := Terms L.
Let var := var L.
Let apply := apply L.
Let equal := equal L.
Let atomic := atomic L.
Let impH := impH L.
Let notH := notH L.
Let forallH := forallH L.
Let orH := orH L.
Let andH := andH L.
Let existH := existH L.
Let iffH := iffH L.
Let ifThenElseH := ifThenElseH L.
Let Prf := Prf L.
Let SysPrf := SysPrf L.

Fixpoint codeTerm (t : Term) : nat :=
  match t with
  | fol.var n => cPair 0 n
  | fol.apply f ts => cPair (S (codeF f)) (codeTerms _ ts)
  end
 
 with codeTerms (n : nat) (ts : Terms n) {struct ts} : nat :=
  match ts with
  | Tnil => 0
  | Tcons n t ss => S (cPair (codeTerm t) (codeTerms n ss))
  end.

Lemma codeTermInj : forall t s : Term, codeTerm t = codeTerm s -> t = s.

Lemma codeTermsInj :
 forall (n : nat) (ts ss : Terms n),
 codeTerms n ts = codeTerms n ss -> ts = ss.

Fixpoint codeFormula (f : Formula) : nat :=
  match f with
  | fol.equal t1 t2 => cPair 0 (cPair (codeTerm t1) (codeTerm t2))
  | fol.impH f1 f2 => cPair 1 (cPair (codeFormula f1) (codeFormula f2))
  | fol.notH f1 => cPair 2 (codeFormula f1)
  | fol.forallH n f1 => cPair 3 (cPair n (codeFormula f1))
  | fol.atomic R ts => cPair (4+(codeR R)) (codeTerms _ ts)
  end.

Lemma codeFormulaInj :
 forall f g : Formula, codeFormula f = codeFormula g -> f = g.

Fixpoint codePrf (Z : Formulas) (f : Formula) (prf : Prf Z f) {struct prf} :
 nat :=
  match prf with
  | AXM A => cPair 0 (codeFormula A)
  | MP Axm1 Axm2 A B rec1 rec2 =>
      cPair 1
        (cPair
           (cPair (cPair 1 (cPair (codeFormula A) (codeFormula B)))
              (codePrf _ _ rec1)) (cPair (codeFormula A) (codePrf _ _ rec2)))
  | GEN Axm A v _ rec =>
      cPair 2 (cPair v (cPair (codeFormula A) (codePrf _ _ rec)))
  | IMP1 A B => cPair 3 (cPair (codeFormula A) (codeFormula B))
  | IMP2 A B C =>
      cPair 4 (cPair (codeFormula A) (cPair (codeFormula B) (codeFormula C)))
  | CP A B => cPair 5 (cPair (codeFormula A) (codeFormula B))
  | FA1 A v t => cPair 6 (cPair (codeFormula A) (cPair v (codeTerm t)))
  | FA2 A v _ => cPair 7 (cPair (codeFormula A) v)
  | FA3 A B v => cPair 8 (cPair (codeFormula A) (cPair (codeFormula B) v))
  | EQ1 => cPair 9 0
  | EQ2 => cPair 10 0
  | EQ3 => cPair 11 0
  | EQ4 r => cPair 12 (codeR r)
  | EQ5 f => cPair 13 (codeF f)
  end.

Lemma codePrfInjAxm :
 forall (a b : Formula) (A B : Formulas) (p : Prf A a) (q : Prf B b),
 codePrf A a p = codePrf B b q -> A = B.

Definition codeImp (a b : nat) := cPair 1 (cPair a b).

Lemma codeImpCorrect :
 forall a b : Formula,
 codeImp (codeFormula a) (codeFormula b) = codeFormula (impH a b).

Definition codeNot (a : nat) := cPair 2 a.

Lemma codeNotCorrect :
 forall a : Formula, codeNot (codeFormula a) = codeFormula (notH a).

Definition codeForall (n a : nat) := cPair 3 (cPair n a).

Lemma codeForallCorrect :
 forall (n : nat) (a : Formula),
 codeForall n (codeFormula a) = codeFormula (forallH n a).

Definition codeOr (a b : nat) := codeImp (codeNot a) b.

Lemma codeOrCorrect :
 forall a b : Formula,
 codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).

Definition codeAnd (a b : nat) := codeNot (codeOr (codeNot a) (codeNot b)).

Lemma codeAndCorrect :
 forall a b : Formula,
 codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).

Definition codeIff (a b : nat) := codeAnd (codeImp a b) (codeImp b a).

Lemma codeIffCorrect :
 forall a b : Formula,
 codeIff (codeFormula a) (codeFormula b) = codeFormula (iffH a b).

End Code_Term_Formula_Proof. *)



Section Code_Free_Vars.



Variable L : Language.

Variable codeF : Functions L -> nat.

Variable codeR : Relations L -> nat.



Let Formula := Formula L.

Let Formulas := Formulas L.

Let System := System L.

Let Term := Term L.

Let Terms := Terms L.

Let var := var L.

Let apply := apply L.

Let equal := equal L.

Let atomic := atomic L.

Let impH := impH L.

Let notH := notH L.

Let forallH := forallH L.

Let orH := orH L.

Let andH := andH L.

Let existH := existH L.

Let iffH := iffH L.

Let ifThenElseH := ifThenElseH L.



Definition codeFreeVarTermTerms : nat -> nat :=

  evalStrongRec 0

    (fun t recs : nat =>

     cPair

       (switchPR (cPairPi1 t) (cPairPi2 (codeNth (t - S (cPairPi2 t)) recs))

          (S (cPair (cPairPi2 t) 0)))

       (switchPR t

          (codeApp (cPairPi1 (codeNth (t - S (cPairPi1 (pred t))) recs))

             (cPairPi2 (codeNth (t - S (cPairPi2 (pred t))) recs))) 0)).



Definition codeFreeVarTerm (t : nat) : nat :=

  cPairPi1 (codeFreeVarTermTerms t).



Definition codeFreeVarTerms (t : nat) : nat :=

  cPairPi2 (codeFreeVarTermTerms t).



Lemma codeFreeVarTermCorrect :

 forall t : Term,

 codeFreeVarTerm (codeTerm L codeF t) = codeList (freeVarTerm L t).

Proof.

intros.

elim t using

 Term_Terms_ind

  with

    (P0 := fun (n : nat) (ts : fol.Terms L n) =>

           codeFreeVarTerms (codeTerms L codeF n ts) =

           codeList (freeVarTerms L n ts)); intros.

simpl in |- *.

unfold codeTerm in |- *.

unfold codeFreeVarTerm in |- *.

unfold codeFreeVarTermTerms in |- *.

unfold evalStrongRec in |- *.

simpl in |- *.

repeat rewrite cPairProjections1 || rewrite cPairProjections2.

simpl in |- *.

reflexivity.

unfold freeVarTerm in |- *.

fold (freeVarTerms L (arity L (inr (Relations L) f)) t0) in |- *.

rewrite <- H.

clear H.

unfold codeTerm in |- *.

fold (codeTerms L codeF (arity L (inr (Relations L) f)) t0) in |- *.

generalize (codeTerms L codeF (arity L (inr (Relations L) f)) t0).

intros.

unfold codeFreeVarTerm in |- *.

unfold codeFreeVarTermTerms in |- *.

set

 (g :=

  fun t1 recs : nat =>

  cPair

    (switchPR (cPairPi1 t1) (cPairPi2 (codeNth (t1 - S (cPairPi2 t1)) recs))

       (S (cPair (cPairPi2 t1) 0)))

    (switchPR t1

       (codeApp (cPairPi1 (codeNth (t1 - S (cPairPi1 (pred t1))) recs))

          (cPairPi2 (codeNth (t1 - S (cPairPi2 (pred t1))) recs))) 0)) 

 in *.

unfold evalStrongRec in |- *.

unfold evalComposeFunc in |- *.

unfold evalOneParamList in |- *.

rewrite computeEvalStrongRecHelp.

unfold compose2 in |- *.

unfold evalComposeFunc in |- *.

unfold g at 1 in |- *.

repeat rewrite cPairProjections1 || rewrite cPairProjections2.

rewrite (evalStrongRecHelp1 g (cPair (S (codeF f)) n) n).

simpl in |- *.

repeat rewrite cPairProjections1 || rewrite cPairProjections2.

unfold codeFreeVarTerms in |- *.

unfold codeFreeVarTermTerms in |- *.

fold g in |- *.

reflexivity.

apply cPairLt2.

simpl in |- *.

unfold codeTerms in |- *.

unfold codeFreeVarTerms in |- *.

unfold codeFreeVarTermTerms in |- *.

unfold evalStrongRec in |- *.

simpl in |- *.

repeat rewrite cPairProjections1 || rewrite cPairProjections2.

reflexivity.

unfold freeVarTerms in |- *.

fold (freeVarTerm L t0) in |- *.

fold (freeVarTerms L n t1) in |- *.

rewrite <- codeAppCorrect.

rewrite <- H.

rewrite <- H0.

clear H H0.

unfold codeTerms in |- *.

fold (codeTerm L codeF t0) in |- *.

fold (codeTerms L codeF n t1) in |- *.

generalize (codeTerm L codeF t0) (codeTerms L codeF n t1).

clear t0 t1.

intros.

unfold codeFreeVarTerms at 1 in |- *.

unfold codeFreeVarTermTerms in |- *.

unfold evalStrongRec in |- *.

set

 (g :=

  fun t0 recs : nat =>

  cPair

    (switchPR (cPairPi1 t0) (cPairPi2 (codeNth (t0 - S (cPairPi2 t0)) recs))

       (S (cPair (cPairPi2 t0) 0)))

    (switchPR t0

       (codeApp (cPairPi1 (codeNth (t0 - S (cPairPi1 (pred t0))) recs))

          (cPairPi2 (codeNth (t0 - S (cPairPi2 (pred t0))) recs))) 0)) 

 in *.

unfold evalComposeFunc in |- *.

unfold evalOneParamList in |- *.

rewrite computeEvalStrongRecHelp.

unfold compose2 in |- *.

unfold evalComposeFunc in |- *.

unfold g at 1 in |- *.

rewrite

 (evalStrongRecHelp1 g (S (cPair n0 n1)) (cPairPi1 (pred (S (cPair n0 n1)))))

 .

rewrite

 (evalStrongRecHelp1 g (S (cPair n0 n1)) (cPairPi2 (pred (S (cPair n0 n1)))))

 .

simpl in |- *.

repeat rewrite cPairProjections1 || rewrite cPairProjections2.

reflexivity.

simpl in |- *.

rewrite cPairProjections2.

apply le_lt_n_Sm.

apply cPairLe2.

simpl in |- *.

rewrite cPairProjections1.

apply le_lt_n_Sm.

apply cPairLe1.

Qed.



Lemma codeFreeVarTermsCorrect :

 forall (n : nat) (ts : Terms n),

 codeFreeVarTerms (codeTerms L codeF n ts) = codeList (freeVarTerms L n ts).

Proof.

intros.

induction ts as [| n t ts Hrects].

simpl in |- *.

unfold codeTerms in |- *.

unfold codeFreeVarTerms in |- *.

unfold codeFreeVarTermTerms in |- *.

unfold evalStrongRec in |- *.

simpl in |- *.

repeat rewrite cPairProjections1 || rewrite cPairProjections2.

reflexivity.

unfold freeVarTerms in |- *.

fold (freeVarTerm L t) in |- *.

fold (freeVarTerms L n ts) in |- *.

rewrite <- codeAppCorrect.

rewrite <- Hrects.

rewrite <- codeFreeVarTermCorrect.

clear Hrects.

unfold codeTerms in |- *.

fold (codeTerm L codeF t) in |- *.

fold (codeTerms L codeF n ts) in |- *.

generalize (codeTerm L codeF t) (codeTerms L codeF n ts).

clear t ts.

intros.

unfold codeFreeVarTerms at 1 in |- *.

unfold codeFreeVarTermTerms in |- *.

unfold evalStrongRec in |- *.

set

 (g :=

  fun t0 recs : nat =>

  cPair

    (switchPR (cPairPi1 t0) (cPairPi2 (codeNth (t0 - S (cPairPi2 t0)) recs))

       (S (cPair (cPairPi2 t0) 0)))

    (switchPR t0

       (codeApp (cPairPi1 (codeNth (t0 - S (cPairPi1 (pred t0))) recs))

          (cPairPi2 (codeNth (t0 - S (cPairPi2 (pred t0))) recs))) 0)) 

 in *.

unfold evalComposeFunc in |- *.

unfold evalOneParamList in |- *.

rewrite computeEvalStrongRecHelp.

unfold compose2 in |- *.

unfold evalComposeFunc in |- *.

unfold g at 1 in |- *.

rewrite

 (evalStrongRecHelp1 g (S (cPair n0 n1)) (cPairPi1 (pred (S (cPair n0 n1)))))

 .

rewrite

 (evalStrongRecHelp1 g (S (cPair n0 n1)) (cPairPi2 (pred (S (cPair n0 n1)))))

 .

simpl in |- *.

repeat rewrite cPairProjections1 || rewrite cPairProjections2.

reflexivity.

simpl in |- *.

rewrite cPairProjections2.

apply le_lt_n_Sm.

apply cPairLe2.

simpl in |- *.

rewrite cPairProjections1.

apply le_lt_n_Sm.

apply cPairLe1.

Qed.



Lemma codeFreeVarTermTermsIsPR : isPR 1 codeFreeVarTermTerms.

Proof.

intros.

unfold codeFreeVarTermTerms in |- *.

apply evalStrongRecIsPR.

apply

 compose2_2IsPR

  with

    (f := fun t recs : nat =>

          switchPR (cPairPi1 t)

            (cPairPi2 (codeNth (t - S (cPairPi2 t)) recs))

            (S (cPair (cPairPi2 t) 0)))

    (g := fun t recs : nat =>

          switchPR t

            (codeApp (cPairPi1 (codeNth (t - S (cPairPi1 (pred t))) recs))

               (cPairPi2 (codeNth (t - S (cPairPi2 (pred t))) recs))) 0).

apply

 compose2_3IsPR

  with

    (f1 := fun t recs : nat => cPairPi1 t)

    (f2 := fun t recs : nat => cPairPi2 (codeNth (t - S (cPairPi2 t)) recs))

    (f3 := fun t recs : nat => S (cPair (cPairPi2 t) 0)).

apply filter10IsPR.

apply cPairPi1IsPR.

apply

 compose2_1IsPR

  with (f := fun t recs : nat => codeNth (t - S (cPairPi2 t)) recs).

apply

 compose2_2IsPR

  with

    (f := fun t recs : nat => t - S (cPairPi2 t))

    (g := fun t recs : nat => recs).

apply filter10IsPR with (g := fun t : nat => t - S (cPairPi2 t)).

apply

 compose1_2IsPR

  with (f := fun t : nat => t) (f' := fun t : nat => S (cPairPi2 t)).

apply idIsPR.

apply compose1_1IsPR.

apply cPairPi2IsPR.

apply succIsPR.

apply minusIsPR.

apply pi2_2IsPR.

apply codeNthIsPR.

apply cPairPi2IsPR.

apply filter10IsPR with (g := fun t : nat => S (cPair (cPairPi2 t) 0)).

apply compose1_1IsPR with (f := fun t : nat => cPair (cPairPi2 t) 0).

apply compose1_2IsPR with (f := cPairPi2) (f' := fun _ : nat => 0).

apply cPairPi2IsPR.

apply const1_NIsPR.

apply cPairIsPR.

apply succIsPR.

apply switchIsPR.

apply

 compose2_3IsPR

  with

    (f1 := fun t recs : nat => t)

    (f2 := fun t recs : nat =>

           codeApp (cPairPi1 (codeNth (t - S (cPairPi1 (pred t))) recs))

             (cPairPi2 (codeNth (t - S (cPairPi2 (pred t))) recs)))

    (f3 := fun t recs : nat => 0).

apply pi1_2IsPR.

apply

 compose2_2IsPR

  with

    (f := fun t recs : nat =>

          cPairPi1 (codeNth (t - S (cPairPi1 (pred t))) recs))

    (g := fun t recs : nat =>

          cPairPi2 (codeNth (t - S (cPairPi2 (pred t))) recs)).

apply

 compose2_1IsPR

  with (f := fun t recs : nat => codeNth (t - S (cPairPi1 (pred t))) recs).

apply

 compose2_2IsPR

  with

    (f := fun t recs : nat => t - S (cPairPi1 (pred t)))

    (g := fun t recs : nat => recs).

apply filter10IsPR with (g := fun t : nat => t - S (cPairPi1 (pred t))).

apply

 compose1_2IsPR

  with (f := fun t : nat => t) (f' := fun t : nat => S (cPairPi1 (pred t))).

apply idIsPR.

apply compose1_1IsPR with (f := fun t : nat => cPairPi1 (pred t)).

apply compose1_1IsPR.

apply predIsPR.

apply cPairPi1IsPR.

apply succIsPR.

apply minusIsPR.

apply pi2_2IsPR.

apply codeNthIsPR.

apply cPairPi1IsPR.

apply

 compose2_1IsPR

  with (f := fun t recs : nat => codeNth (t - S (cPairPi2 (pred t))) recs).

apply

 compose2_2IsPR

  with

    (f := fun t recs : nat => t - S (cPairPi2 (pred t)))

    (g := fun t recs : nat => recs).

apply filter10IsPR with (g := fun t : nat => t - S (cPairPi2 (pred t))).

apply

 compose1_2IsPR

  with (f := fun t : nat => t) (f' := fun t : nat => S (cPairPi2 (pred t))).

apply idIsPR.

apply compose1_1IsPR with (f := fun t : nat => cPairPi2 (pred t)).

apply compose1_1IsPR.

apply predIsPR.

apply cPairPi2IsPR.

apply succIsPR.

apply minusIsPR.

apply pi2_2IsPR.

apply codeNthIsPR.

apply cPairPi2IsPR.

apply codeAppIsPR.

exists (composeFunc 2 0 (PRnil _) zeroFunc).

simpl in |- *.

auto.

apply switchIsPR.

apply cPairIsPR.

Qed.



Lemma codeFreeVarTermIsPR : isPR 1 codeFreeVarTerm.

Proof.

unfold codeFreeVarTerm in |- *.

apply compose1_1IsPR.

apply codeFreeVarTermTermsIsPR.

apply cPairPi1IsPR.

Qed.



Lemma codeFreeVarTermsIsPR : isPR 1 codeFreeVarTerms.

Proof.

unfold codeFreeVarTerms in |- *.

apply compose1_1IsPR.

apply codeFreeVarTermTermsIsPR.

apply cPairPi2IsPR.

Qed.



Definition codeFreeVarFormula : nat -> nat :=

  evalStrongRec 0

    (fun f recs : nat =>

     switchPR (cPairPi1 f)

       (switchPR (pred (cPairPi1 f))

          (switchPR (pred (pred (cPairPi1 f)))

             (switchPR (pred (pred (pred (cPairPi1 f))))

                (codeFreeVarTerms (cPairPi2 f))

                (codeListRemove (cPairPi1 (cPairPi2 f))

                   (codeNth (f - S (cPairPi2 (cPairPi2 f))) recs)))

             (codeNth (f - S (cPairPi2 f)) recs))

          (codeApp (codeNth (f - S (cPairPi1 (cPairPi2 f))) recs)

             (codeNth (f - S (cPairPi2 (cPairPi2 f))) recs)))

       (codeApp (codeFreeVarTerm (cPairPi1 (cPairPi2 f)))

          (codeFreeVarTerm (cPairPi2 (cPairPi2 f))))).



Lemma codeFreeVarFormulaCorrect :

 forall f : Formula,

 codeFreeVarFormula (codeFormula L codeF codeR f) =

 codeList (freeVarFormula L f).

Proof.

intros.

set

 (g :=

  fun f recs : nat =>

  switchPR (cPairPi1 f)

    (switchPR (pred (cPairPi1 f))

       (switchPR (pred (pred (cPairPi1 f)))

          (switchPR (pred (pred (pred (cPairPi1 f))))

             (codeFreeVarTerms (cPairPi2 f))

             (codeListRemove (cPairPi1 (cPairPi2 f))

                (codeNth (f - S (cPairPi2 (cPairPi2 f))) recs)))

          (codeNth (f - S (cPairPi2 f)) recs))

       (codeApp (codeNth (f - S (cPairPi1 (cPairPi2 f))) recs)

          (codeNth (f - S (cPairPi2 (cPairPi2 f))) recs)))

    (codeApp (codeFreeVarTerm (cPairPi1 (cPairPi2 f)))

       (codeFreeVarTerm (cPairPi2 (cPairPi2 f))))) 

 in *.

induction f as [t t0| r t| f1 Hrecf1 f0 Hrecf0| f Hrecf| n f Hrecf].

simpl in |- *.

rewrite <- codeAppCorrect.

repeat rewrite <- codeFreeVarTermCorrect.

generalize (codeTerm L codeF t) (codeTerm L codeF t0).

clear t t0.

intros.

unfold codeFreeVarFormula in |- *.

unfold evalStrongRec in |- *.

simpl in |- *.

repeat rewrite cPairProjections1 || rewrite cPairProjections2.

simpl in |- *.

reflexivity.

simpl in |- *.

rewrite <- codeFreeVarTermsCorrect.

generalize (codeTerms L codeF (arity L (inl (Functions L) r)) t).

clear t.

intros.

unfold codeFreeVarFormula in |- *.

unfold evalStrongRec in |- *.

unfold evalStrongRecHelp in |- *.

unfold evalComposeFunc in |- *.

unfold evalOneParamList in |- *.

unfold evalPrimRecFunc in |- *.

repeat rewrite cPairProjections1 || rewrite cPairProjections2.

simpl in |- *.

repeat rewrite cPairProjections1 || rewrite cPairProjections2.

reflexivity.

simpl in |- *.

rewrite <- codeAppCorrect.

rewrite <- Hrecf1.

rewrite <- Hrecf0.

clear Hrecf0 Hrecf1.

unfold codeFreeVarFormula in |- *.

fold g in |- *.

unfold evalStrongRec in |- *.

unfold evalComposeFunc in |- *.

unfold evalOneParamList in |- *.

rewrite computeEvalStrongRecHelp.

simpl in |- *.

repeat rewrite cPairProjections1 || rewrite cPairProjections2.

unfold g at 1 in |- *.

repeat rewrite cPairProjections1 || rewrite cPairProjections2.

rewrite

 (evalStrongRecHelp1 g

    (cPair 1

       (cPair (codeFormula L codeF codeR f1) (codeFormula L codeF codeR f0)))

    (codeFormula L codeF codeR f1)).

rewrite

 (evalStrongRecHelp1 g

    (cPair 1

       (cPair (codeFormula L codeF codeR f1) (codeFormula L codeF codeR f0)))

    (codeFormula L codeF codeR f0)).

simpl in |- *.

unfold evalStrongRec in |- *.

unfold evalComposeFunc in |- *.

unfold evalOneParamList in |- *.

simpl in |- *.

repeat rewrite cPairProjections1 || rewrite cPairProjections2.

reflexivity.

eapply lt_le_trans.

apply cPairLt2.

apply cPairLe3.

apply le_n.

apply cPairLe2.

eapply lt_le_trans.

apply cPairLt2.

apply cPairLe3.

apply le_n.

apply cPairLe1.

simpl in |- *.

rewrite <- Hrecf.

clear Hrecf.

generalize (codeFormula L codeF codeR f).

clear f.

intros.

unfold codeFreeVarFormula at 1 in |- *.

fold g in |- *.

unfold evalStrongRec in |- *.

unfold evalComposeFunc in |- *.

unfold evalOneParamList in |- *.

rewrite computeEvalStrongRecHelp.

unfold evalComposeFunc in |- *.

unfold compose2 in |- *.

unfold evalList in |- *.

unfold pred in |- *.

repeat rewrite cPairProjections1 || rewrite cPairProjections2.

unfold g at 1 in |- *.

repeat rewrite cPairProjections1 || rewrite cPairProjections2.

rewrite (evalStrongRecHelp1 g (cPair 2 n) n).

simpl in |- *.

reflexivity.

apply cPairLt2.

simpl in |- *.

rewrite <- codeListRemoveCorrect.

rewrite <- Hrecf.

generalize (codeFormula L codeF codeR f).

clear Hrecf f.

intros.

unfold codeFreeVarFormula at 1 in |- *.

fold g in |- *.

unfold evalStrongRec in |- *.

unfold evalComposeFunc in |- *.

unfold evalOneParamList in |- *.

unfold evalList in |- *.

rewrite computeEvalStrongRecHelp.

unfold evalComposeFunc in |- *.

unfold compose2 in |- *.

unfold evalList in |- *.

unfold pred in |- *.

repeat rewrite cPairProjections1 || rewrite cPairProjections2.

unfold g at 1 in |- *.

repeat rewrite cPairProjections1 || rewrite cPairProjections2.

rewrite (evalStrongRecHelp1 g (cPair 3 (cPair n n0)) n0).

simpl in |- *.

reflexivity.

eapply lt_le_trans.

apply cPairLt2.

apply cPairLe3.

apply le_n.

apply cPairLe2.

Qed.



Lemma codeFreeVarFormulaIsPR : isPR 1 codeFreeVarFormula.

Proof.

unfold codeFreeVarFormula in |- *.

apply evalStrongRecIsPR.

assert (isPR 1 (fun x : nat => pred (cPairPi1 x))).

apply compose1_1IsPR.

apply cPairPi1IsPR.

apply predIsPR.

assert (isPR 1 (fun x : nat => pred (pred (cPairPi1 x)))).

apply compose1_1IsPR with (f := fun x : nat => pred (cPairPi1 x)).

auto.

apply predIsPR.

assert (isPR 1 (fun x : nat => pred (pred (pred (cPairPi1 x))))).

apply compose1_1IsPR with (f := fun x : nat => pred (pred (cPairPi1 x))).

auto.

apply predIsPR.

apply

 compose2_3IsPR

  with

    (f1 := fun f recs : nat => cPairPi1 f)

    (f2 := fun f recs : nat =>

           switchPR (pred (cPairPi1 f))

             (switchPR (pred (pred (cPairPi1 f)))

                (switchPR (pred (pred (pred (cPairPi1 f))))

                   (codeFreeVarTerms (cPairPi2 f))

                   (codeListRemove (cPairPi1 (cPairPi2 f))

                      (codeNth (f - S (cPairPi2 (cPairPi2 f))) recs)))

                (codeNth (f - S (cPairPi2 f)) recs))

             (codeApp (codeNth (f - S (cPairPi1 (cPairPi2 f))) recs)

                (codeNth (f - S (cPairPi2 (cPairPi2 f))) recs)))

    (f3 := fun f recs : nat =>

           codeApp (codeFreeVarTerm (cPairPi1 (cPairPi2 f)))

             (codeFreeVarTerm (cPairPi2 (cPairPi2 f)))).

apply filter10IsPR.

apply cPairPi1IsPR.

apply

 compose2_3IsPR

  with

    (f1 := fun f recs : nat => pred (cPairPi1 f))

    (f2 := fun f recs : nat =>

           switchPR (pred (pred (cPairPi1 f)))

             (switchPR (pred (pred (pred (cPairPi1 f))))

                (codeFreeVarTerms (cPairPi2 f))

                (codeListRemove (cPairPi1 (cPairPi2 f))

                   (codeNth (f - S (cPairPi2 (cPairPi2 f))) recs)))

             (codeNth (f - S (cPairPi2 f)) recs))

    (f3 := fun f recs : nat =>

           codeApp (codeNth (f - S (cPairPi1 (cPairPi2 f))) recs)

             (codeNth (f - S (cPairPi2 (cPairPi2 f))) recs)).

apply filter10IsPR with (g := fun x : nat => pred (cPairPi1 x)).

auto.

apply

 compose2_3IsPR

  with

    (f1 := fun f recs : nat => pred (pred (cPairPi1 f)))

    (f2 := fun f recs : nat =>

           switchPR (pred (pred (pred (cPairPi1 f))))

             (codeFreeVarTerms (cPairPi2 f))

             (codeListRemove (cPairPi1 (cPairPi2 f))

                (codeNth (f - S (cPairPi2 (cPairPi2 f))) recs)))

    (f3 := fun f recs : nat => codeNth (f - S (cPairPi2 f)) recs).

apply filter10IsPR with (g := fun x : nat => pred (pred (cPairPi1 x))).

auto.

apply

 compose2_3IsPR

  with

    (f1 := fun f recs : nat => pred (pred (pred (cPairPi1 f))))

    (f2 := fun f recs : nat => codeFreeVarTerms (cPairPi2 f))

    (f3 := fun f recs : nat =>

           codeListRemove (cPairPi1 (cPairPi2 f))

             (codeNth (f - S (cPairPi2 (cPairPi2 f))) recs)).

apply filter10IsPR with (g := fun x : nat => pred (pred (pred (cPairPi1 x)))).

auto.

apply filter10IsPR with (g := fun f : nat => codeFreeVarTerms (cPairPi2 f)).

apply compose1_1IsPR.

apply cPairPi2IsPR.

apply codeFreeVarTermsIsPR.

apply

 compose2_2IsPR

  with

    (f := fun f recs : nat => cPairPi1 (cPairPi2 f))

    (g := fun f recs : nat => codeNth (f - S (cPairPi2 (cPairPi2 f))) recs).

apply filter10IsPR with (g := fun f : nat => cPairPi1 (cPairPi2 f)).

apply compose1_1IsPR.

apply cPairPi2IsPR.

apply cPairPi1IsPR.

apply

 compose2_2IsPR

  with

    (f := fun f recs : nat => f - S (cPairPi2 (cPairPi2 f)))

    (g := fun f recs : nat => recs).

apply filter10IsPR with (g := fun f : nat => f - S (cPairPi2 (cPairPi2 f))).

apply

 compose1_2IsPR

  with

    (f := fun f : nat => f)

    (f' := fun f : nat => S (cPairPi2 (cPairPi2 f))).

apply idIsPR.

apply compose1_1IsPR with (f := fun f : nat => cPairPi2 (cPairPi2 f)).

apply compose1_1IsPR; apply cPairPi2IsPR.

apply succIsPR.

apply minusIsPR.

apply pi2_2IsPR.

apply codeNthIsPR.

apply codeListRemoveIsPR.

apply switchIsPR.

apply

 compose2_2IsPR

  with

    (f := fun f recs : nat => f - S (cPairPi2 f))

    (g := fun f recs : nat => recs).

apply filter10IsPR with (g := fun f : nat => f - S (cPairPi2 f)).

apply

 compose1_2IsPR

  with (f := fun f : nat => f) (f' := fun f : nat => S (cPairPi2 f)).

apply idIsPR.

apply compose1_1IsPR.

apply cPairPi2IsPR.

apply succIsPR.

apply minusIsPR.

apply pi2_2IsPR.

apply codeNthIsPR.

apply switchIsPR.

apply

 compose2_2IsPR

  with

    (f := fun f recs : nat => codeNth (f - S (cPairPi1 (cPairPi2 f))) recs)

    (g := fun f recs : nat => codeNth (f - S (cPairPi2 (cPairPi2 f))) recs).

apply

 compose2_2IsPR

  with

    (f := fun f recs : nat => f - S (cPairPi1 (cPairPi2 f)))

    (g := fun f recs : nat => recs).

apply filter10IsPR with (g := fun f : nat => f - S (cPairPi1 (cPairPi2 f))).

apply

 compose1_2IsPR

  with

    (f := fun f : nat => f)

    (f' := fun f : nat => S (cPairPi1 (cPairPi2 f))).

apply idIsPR.

apply compose1_1IsPR with (f := fun f : nat => cPairPi1 (cPairPi2 f)).

apply compose1_1IsPR.

apply cPairPi2IsPR.

apply cPairPi1IsPR.

apply succIsPR.

apply minusIsPR.

apply pi2_2IsPR.

apply codeNthIsPR.

apply

 compose2_2IsPR

  with

    (f := fun f recs : nat => f - S (cPairPi2 (cPairPi2 f)))

    (g := fun f recs : nat => recs).

apply filter10IsPR with (g := fun f : nat => f - S (cPairPi2 (cPairPi2 f))).

apply

 compose1_2IsPR

  with

    (f := fun f : nat => f)

    (f' := fun f : nat => S (cPairPi2 (cPairPi2 f))).

apply idIsPR.

apply compose1_1IsPR with (f := fun f : nat => cPairPi2 (cPairPi2 f)).

apply compose1_1IsPR; apply cPairPi2IsPR.

apply succIsPR.

apply minusIsPR.

apply pi2_2IsPR.

apply codeNthIsPR.

apply codeAppIsPR.

apply switchIsPR.

apply

 filter10IsPR

  with

    (g := fun f : nat =>

          codeApp (codeFreeVarTerm (cPairPi1 (cPairPi2 f)))

            (codeFreeVarTerm (cPairPi2 (cPairPi2 f)))).

apply

 compose1_2IsPR

  with

    (f := fun f : nat => codeFreeVarTerm (cPairPi1 (cPairPi2 f)))

    (f' := fun f : nat => codeFreeVarTerm (cPairPi2 (cPairPi2 f))).

apply compose1_1IsPR with (f := fun f : nat => cPairPi1 (cPairPi2 f)).

apply compose1_1IsPR.

apply cPairPi2IsPR.

apply cPairPi1IsPR.

apply codeFreeVarTermIsPR.

apply compose1_1IsPR with (f := fun f : nat => cPairPi2 (cPairPi2 f)).

apply compose1_1IsPR; apply cPairPi2IsPR.

apply codeFreeVarTermIsPR.

apply codeAppIsPR.

apply switchIsPR.

Qed.



Definition codeFreeVarListFormula : nat -> nat :=

  evalStrongRec 0

    (fun l recs : nat =>

     switchPR l

       (codeApp (codeFreeVarFormula (cPairPi1 (pred l)))

          (codeNth (l - S (cPairPi2 (pred l))) recs)) 0).



Lemma codeFreeVarListFormulaCorrect :

 forall l : list Formula,

 codeFreeVarListFormula (codeList (map (codeFormula L codeF codeR) l)) =

 codeList (freeVarListFormula L l).

Proof.

intros.

unfold codeFreeVarListFormula in |- *.

set

 (A :=

  fun l0 recs : nat =>

  switchPR l0

    (codeApp (codeFreeVarFormula (cPairPi1 (pred l0)))

       (codeNth (l0 - S (cPairPi2 (pred l0))) recs)) 0) 

 in *.

induction l as [| a l Hrecl];

 unfold evalStrongRec, evalComposeFunc, evalOneParamList, evalList in |- *;

 rewrite computeEvalStrongRecHelp;

 unfold compose2, evalComposeFunc, evalOneParamList, evalList in |- *.

simpl in |- *.

rewrite cPairProjections1.

reflexivity.

unfold A at 1 in |- *.

rewrite evalStrongRecHelp1.

simpl in |- *.

repeat first [ rewrite cPairProjections1 | rewrite cPairProjections2 ].

rewrite Hrecl.

rewrite codeFreeVarFormulaCorrect.

apply codeAppCorrect.

simpl in |- *.

apply le_lt_n_Sm.

apply cPairLe2A.

Qed.



Lemma codeFreeVarListFormulaIsPR : isPR 1 codeFreeVarListFormula.

Proof.

unfold codeFreeVarListFormula in |- *.

apply evalStrongRecIsPR.

apply

 compose2_3IsPR

  with

    (f1 := fun l recs : nat => l)

    (f2 := fun l recs : nat =>

           codeApp (codeFreeVarFormula (cPairPi1 (pred l)))

             (codeNth (l - S (cPairPi2 (pred l))) recs))

    (f3 := fun l recs : nat => 0).

apply pi1_2IsPR.

apply

 compose2_2IsPR

  with

    (f := fun l recs : nat => codeFreeVarFormula (cPairPi1 (pred l)))

    (g := fun l recs : nat => codeNth (l - S (cPairPi2 (pred l))) recs).

apply

 filter10IsPR

  with (g := fun l : nat => codeFreeVarFormula (cPairPi1 (pred l))).

apply compose1_1IsPR with (f := fun l : nat => cPairPi1 (pred l)).

apply compose1_1IsPR.

apply predIsPR.

apply cPairPi1IsPR.

apply codeFreeVarFormulaIsPR.

apply callIsPR with (g := fun l : nat => cPairPi2 (pred l)).

apply compose1_1IsPR.

apply predIsPR.

apply cPairPi2IsPR.

apply codeAppIsPR.

apply filter10IsPR with (g := fun _ : nat => 0).

apply const1_NIsPR.

apply switchIsPR.

Qed.



End Code_Free_Vars.
