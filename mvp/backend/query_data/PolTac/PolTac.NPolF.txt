Require Import ZArith.

Require Import NAux.
(* NAux:
Require Export NArith.
Require Import ZArith.

Open Scope N_scope.

Theorem Nle_le: forall n  m, (N.to_nat n <= N.to_nat m)%nat -> n <= m.

Theorem le_Nle: forall n m, N.of_nat n <= N.of_nat m -> (n <= m)%nat.

Theorem Nle_le_rev: forall n  m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.

Theorem Nlt_lt: forall n  m, (N.to_nat n < N.to_nat m)%nat -> n < m.

Theorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.

Theorem Nlt_lt_rev: forall n  m, n < m -> (N.to_nat n < N.to_nat m)%nat.

Theorem Nge_ge: forall n  m, (N.to_nat n >= N.to_nat m)%nat -> n >= m.

Theorem ge_Nge: forall n m, N.of_nat n >= N.of_nat m -> (n >= m)%nat.

Theorem Nge_ge_rev: forall n  m, n >= m -> (N.to_nat n >= N.to_nat m)%nat.

Theorem Ngt_gt: forall n  m, (N.to_nat n > N.to_nat m)%nat -> n > m.

Theorem gt_Ngt: forall n m, N.of_nat n > N.of_nat m -> (n > m)%nat.

Theorem Ngt_gt_rev: forall n  m, n > m -> (N.to_nat n > N.to_nat m)%nat.

Theorem Neq_eq_rev: forall n  m, n = m -> (N.to_nat n = N.to_nat m)%nat.

Import BinPos.

Ltac to_nat_op  :=
  match goal with
      H: (N.lt _ _) |- _ => generalize (Nlt_lt_rev _ _ H); clear H; intros H
|     H: (N.gt _ _) |- _ => generalize (Ngt_gt_rev _ _ H); clear H; intros H
|     H: (N.le _ _) |- _ => generalize (Nle_le_rev _ _ H); clear H; intros H
|     H: (N.ge _ _) |- _ => generalize (Nge_ge_rev _ _ H); clear H; intros H
|     H: (@eq N _ _) |- _ => generalize (Neq_eq_rev _ _ H); clear H; intros H
|      |- (N.lt _ _)  => apply Nlt_lt
|      |- (N.le _ _)  => apply Nle_le
|      |- (N.gt _ _)  => apply Ngt_gt
|      |- (N.ge _ _)  => apply Nge_ge
|      |- (@eq N _ _)  => apply Nat2N.inj
end.

Ltac set_to_nat :=
let nn := fresh "nn" in
match goal with
       |- context [(N.to_nat (?X + ?Y)%N)]  => rewrite N2Nat.inj_add
|      |- context [(N.to_nat (?X * ?Y)%N)]  => rewrite N2Nat.inj_mul
|      |- context [(N.to_nat ?X)]  => set (nn:=N.to_nat X) in * |- *
|      H: context [(N.to_nat (?X + ?Y)%N)] |- _ => rewrite N2Nat.inj_add in H
|      H: context [(N.to_nat (?X + ?Y)%N)] |- _ => rewrite N2Nat.inj_mul in H
|      H: context [(N.to_nat ?X)] |- _ => set (nn:=N.to_nat X) in * |- *
end.

Ltac to_nat := repeat to_nat_op; repeat set_to_nat.

Theorem Nle_gt_trans: forall n m p, m <= n -> m > p -> n > p.

Theorem Ngt_le_trans: forall n m p, n > m -> p <= m -> n > p.

Theorem Nle_add_l :
  forall x y, x <= y + x.

Close Scope N_scope. *)

Require Import NPolS.
(* NPolS:
Require Import PolSBase.
Require Import PolAuxList.
Require Import PolAux.
Require Import NAux.
Require Export ArithRing.

Open Scope nat_scope.

Definition Nconvert_back (e : PExpr Z) (l : list N) : N :=
   convert_back Z N 0%N Nplus Nminus Nmult Nopp Z.abs_N l e.
 
Definition Nsimpl_minus (e : PExpr Z) :=
   simpl_minus
    Z Zplus Zmult Z.opp Z0 1%Z is_Z1 is_Z0 is_Zpos is_Zdiv Z.div e.
 
Definition Nsimpl (e : PExpr Z) :=
   simpl
    Z Zplus Zmult Z.opp Z0 1%Z is_Z1 is_Z0 is_Zpos is_Zdiv Z.div e.

Ltac
Ns term1 term2 :=
let term := constr:(Nminus term1 term2) in
let rfv := FV NCst Nplus Nmult Nminus Nopp term (@nil N) in
let fv := Trev rfv in
let expr1 := mkPolexpr Z NCst Nplus Nmult Nminus Nopp term1 fv in
let expr2 := mkPolexpr Z NCst Nplus Nmult Nminus Nopp term2 fv in
let re := eval vm_compute in (Nsimpl_minus (PEsub expr1 expr2)) in
let expr3 := match re with (PEsub ?X1 _) => X1 end in
let expr4 := match re with (PEsub _ ?X1 ) => X1 end in
let re1 := eval vm_compute in (Nsimpl (PEsub expr1 expr3)) in
let
 re1' :=
  eval
     unfold
      Nconvert_back, convert_back,  PolAuxList.pos_nth,  PolAuxList.jump, 
         PolAuxList.hd,  PolAuxList.tl in (Nconvert_back (PEadd re1 expr3) fv) in
let re1'' := eval lazy beta in re1' in
let re1''' := clean_zabs_N re1'' in
let
 re2' :=
  eval
     unfold
      Nconvert_back, convert_back,  PolAuxList.pos_nth,  PolAuxList.jump, 
         PolAuxList.hd,  PolAuxList.tl in (Nconvert_back (PEadd re1 expr4) fv) in
let re2'' := eval lazy beta in re2' in
let re2''' := clean_zabs_N re2'' in
replace2_tac term1 term2 re1''' re2'''; [idtac | ring | ring].

Ltac
Npols :=
match goal with
| |- (?X1 = ?X2)%N =>
Ns X1 X2; apply Nplus_eq_compat_l
| |- (?X1 <> ?X2)%N =>
Ns X1 X2; apply Nplus_neg_compat_l
| |- (?X1 < ?X2)%N =>
Ns X1 X2; apply Nplus_lt_compat_l
| |- (?X1 > ?X2)%N =>
Ns X1 X2; apply Nplus_gt_compat_l
| |- (?X1 <= ?X2)%N =>
Ns X1 X2; apply Nplus_le_compat_l
| |- (?X1 >= ?X2)%N =>
Ns X1 X2; apply Nplus_ge_compat_l
| _ => fail end.

Ltac
hyp_Npols H :=
generalize H;
let tmp := fresh "tmp" in
match (type of H) with
   (?X1 = ?X2)%N =>
Ns X1 X2; intros tmp; generalize (Nplus_reg_l _ _ _ tmp); clear H tmp; intro H
|  (?X1 <> ?X2)%N =>
Ns X1 X2; intros tmp; generalize (Nplus_neg_reg_l _ _ _ tmp); clear H tmp; intro H
|  (?X1 < ?X2)%N =>
Ns X1 X2; intros tmp; generalize (Nplus_lt_reg_l _ _ _ tmp); clear H tmp; intro H
|  (?X1 > ?X2)%N =>
Ns X1 X2; intros tmp; generalize (Nplus_gt_reg_l _ _ _ tmp); clear H tmp; intro H
|  (?X1 <= ?X2)%N =>
Ns X1 X2; intros tmp; generalize (Nplus_le_reg_l _ _ _ tmp); clear H tmp; intro H
|  (?X1 >= ?X2)%N =>
Ns X1 X2; intros tmp; generalize (Nplus_ge_reg_l _ _ _ tmp); clear H tmp; intro H
| _ => fail end. *)

Require Import PolSBase.
(* PolSBase:
Require Export ZArith.
Require Export List.
Require Import PolAuxList.
 
Section PolSimplBase.

Variable C : Set.

Variable Cplus : C -> C ->  C.
Variable Cmul : C -> C ->  C.
Variable Cop : C ->  C.

Variable C0 : C.
Variable C1 : C.

Variable isC1 : C ->  bool.

Variable isC0 : C ->  bool.

Variable isPos : C ->  bool.

Variable Cdivide : C -> C ->  bool.

Variable Cdiv : C -> C ->  C.

Definition le_pos p1 p2 := Zle_bool (Zpos p1) (Zpos p2).

Definition eq_pos p1 p2 := Zeq_bool (Zpos p1) (Zpos p2).

Inductive PExpr : Set :=
  PEc: C ->  PExpr
 | PEX: positive ->  PExpr
 | PEadd: PExpr -> PExpr ->  PExpr
 | PEsub: PExpr -> PExpr ->  PExpr
 | PEmul: PExpr -> PExpr ->  PExpr
 | PEopp: PExpr ->  PExpr .

Definition isP0 e :=
   match e with PEc c => isC0 c | _ => false end.

Definition isP1 e :=
   match e with PEc c => isC1 c | _ => false end.

Definition mkPEmulc (c: C) (e: PExpr) := 
  if isC0 c then  PEc C0 else
  if isC1 c then e else
  match e with
     (PEc c1) => PEc (Cmul c c1)
   | (PEopp e1) =>  PEmul (PEc (Cop c)) e1
   | (PEmul (PEc c1) e1)  => PEmul (PEc (Cmul c c1)) e1
   | _ => PEmul (PEc c) e
  end.
 
Definition mkPEmul (e1 e2 : PExpr) := 
   match e1 with
     (PEc c1) => mkPEmulc c1 e2
   | (PEopp e3) => 
                match e2 with
                 (PEc c2) => mkPEmulc (Cop c2) e3
                | (PEmul (PEc c2) e4) => mkPEmulc (Cop c2) (PEmul e3 e4)
                | (PEopp e4) => PEmul e3 e4
                |  _ => PEopp (PEmul e3 e2)
                end
   | (PEmul (PEc c1) e3)  => 
                match e2 with
                 (PEc c2) => mkPEmulc (Cmul c1 c2) e3
                | (PEmul (PEc c2) (PEopp e4)) => mkPEmulc (Cmul c1 c2)
                                                    (PEmul e3 e4)
                | (PEopp e4) => mkPEmulc (Cop c1) (PEmul e3 e4)
                |  _ => mkPEmulc c1 (PEmul e3 e2)
                end
   | _ => 
                match e2 with
                 (PEc c2) => mkPEmulc c2 e1
                | (PEmul (PEc c2) e4) => mkPEmulc c2 (PEmul e1 e4)
                | (PEopp e4) => PEopp (PEmul e1 e4)
                | _ => PEmul e1 e2
                end
   end.

Definition mkPEadd (e1 e2 : PExpr) :=
   match e1, e2 with
    (PEc c1), (PEc c2) => (PEc (Cplus c1 c2))
  | _, _ => 
   if isP0 e1 then e2
     else if isP0 e2 then e1
            else match e2 with
                   PEmul (PEc c1) e3 =>
                     if isPos c1 then PEadd e1 e2
                       else PEsub e1 (mkPEmul (PEc (Cop c1)) e3)
                  | PEc c1 =>
                      if isPos c1 then PEadd e1 e2 else PEsub e1 (PEc (Cop c1))
                  | _ => PEadd e1 e2
                 end
end.

Definition mkPEopp (e1 : PExpr) :=
   match e1 with
     PEopp e2 => e2
    | PEc c1 => PEc (Cop c1)
    | PEmul (PEc c1) e2 => PEmul (PEc (Cop c1)) e2
    | _ => PEopp e1
   end.

Definition mkPEsub (e1 e2 : PExpr) :=
  match e1, e2 with
    (PEc c1), (PEc c2) => (PEc (Cplus c1 (Cop c2)))
  | _ , _ => 
   if isP0 e1 then mkPEopp e2
     else if isP0 e2 then e1
            else match e2 with
                   PEmul (PEc c1) e3 =>
                     if isPos c1 then PEsub e1 e2
                       else PEadd e1 (mkPEmul (PEc (Cop c1)) e3)
                  | PEc c1 =>
                      if isPos c1 then PEsub e1 e2 else PEadd e1 (PEc (Cop c1))
                  | _ => PEsub e1 e2
                 end
end.

Definition lift_make_mul (e1 e2 : PExpr) : PExpr :=
   match e1 with
     PEc c1 =>
       match e2 with
         PEc c2 => PEc (Cmul c1 c2)
        | PEmul (PEc c2) e4 => PEmul (PEc (Cmul c1 c2)) e4
        | _ => PEmul (PEc c1) e2
       end
    | PEmul (PEc c1) e3 =>
        match e2 with
          PEc c2 => PEmul (PEc (Cmul c1 c2)) e3
         | PEmul (PEc c2) e4 => PEmul (PEc (Cmul c1 c2)) (PEmul e3 e4)
         | _ => PEmul (PEc c1) (PEmul e3 e2)
        end
    | _ =>
        match e2 with
          PEc c2 => PEmul (PEc c2) e1
         | PEmul (PEc c2) e4 => PEmul (PEc c2) (PEmul e1 e4)
         | _ => PEmul (PEc C1) (PEmul e1 e2)
        end
   end.

Definition list_mult_one e :=
   match e with PEX _ => PEmul (PEc C1) e | _ => e end.

Fixpoint lift_const (e : PExpr) : PExpr :=
 match e with
   PEadd e1 e2 =>
     PEadd (list_mult_one (lift_const e1)) (list_mult_one (lift_const e2))
  | PEsub e1 e2 =>
      PEsub (list_mult_one (lift_const e1)) (list_mult_one (lift_const e2))
  | PEmul e1 e2 => lift_make_mul (lift_const e1) (lift_const e2)
  | PEopp e1 => PEopp (list_mult_one (lift_const e1))
  | _ => list_mult_one e
 end.

Definition pos := positive.

Definition init_pos : pos := 1%positive.

Definition next_pos (p : pos) : pos := (1 + p)%positive.

Definition mon_pos := list pos.

Definition prod_pos (e1 e2 : mon_pos) : mon_pos := app e1 e2.

Fixpoint pos_in_mon (p : pos) (l : mon_pos) {struct l} : bool :=
 match l with
   nil => false
  | cons p1 l1 => if eq_pos p p1 then true else pos_in_mon p l1
 end.

Fixpoint pos_remove (p : pos) (l : mon_pos) {struct l} : mon_pos :=
 match l with
   nil => nil
  | cons p1 l1 => if eq_pos p p1 then l1 else cons p1 (pos_remove p l1)
 end.

Fixpoint insert_list_pos (p1 : pos) (l : list pos) {struct l} : list pos :=
 match l with
   nil => cons p1 nil
  | cons p2 l1 =>
      if eq_pos p1 p2 then l
        else if le_pos p1 p2 then cons p1 l else cons p2 (insert_list_pos p1 l1)
 end.

Definition append_pos (l1 l2 : list pos) : list pos :=
   fold_left (fun l a => insert_list_pos a l) l1 l2.

Fixpoint list_pos_intersect (l1 l2 : list pos) {struct l2} : bool :=
 match l2 with
   nil => false
  | cons p1 l3 => if pos_in_mon p1 l1 then true else list_pos_intersect l1 l3
 end.

Definition exp := positive.

Definition mon_exp := list exp.

Fixpoint mon_exp_eq (l1 l2 : mon_exp) {struct l1} : bool :=
 match l1, l2 with
   nil, nil => true
  | cons p1 l3, cons p2 l4 => if eq_pos p1 p2 then mon_exp_eq l3 l4 else false
  | _, _ => false
 end.

Fixpoint insert_exp (p1 : exp) (l : mon_exp) {struct l} : mon_exp :=
 match l with
   nil => cons p1 nil
  | cons p2 l1 => if le_pos p1 p2 then cons p1 l else cons p2 (insert_exp p1 l1)
 end.

Definition prod_exp (l1 l2 : mon_exp) : mon_exp :=
   fold_left (fun l a => insert_exp a l) l1 l2.

Definition env := (list (pos * C))%type.

Definition empty_env : env := nil.

Definition add_env n c e : env := cons (n, c) e.

Fixpoint is_bound_env (n : pos) (e : env) {struct e} : bool :=
 match e with
   nil => false
  | cons ((n1, c)) e1 => if eq_pos n n1 then true else is_bound_env n e1
 end.

Fixpoint number_of_zero_env (e : env) : Z :=
 match e with
   nil => 0%Z
  | cons ((n1, c)) e1 =>
      if isC0 c then (1 + number_of_zero_env e1)%Z else number_of_zero_env e1
 end.

Fixpoint value_env (n : pos) (e : env) {struct e} : C :=
 match e with
   nil => C0
  | cons ((n1, c)) e1 => if eq_pos n n1 then c else value_env n e1
 end.

Fixpoint update_env (n : pos) (c : C) (e : env) {struct e} : env :=
 match e with
   nil => cons (n, c) nil
  | cons ((n1, c1)) e1 =>
      if eq_pos n n1 then cons (n, c) e1 else cons (n1, c1) (update_env n c e1)
 end.

Definition merge_env (e1 e2 : env) : env :=
   fold_left (fun env x =>
                 match x with (y, val) => update_env y val env end) e1 e2.

Let restrict_env (l : list pos) (e : env) : env :=
   map (fun x => (x, value_env x e)) l.

Fixpoint number_of_equality_env (e1 e2 : env) {struct e1} : Z :=
 match e1 with
   nil => 0%Z
  | cons ((n1, c)) e3 =>

      if isC0 c then number_of_equality_env e3 e2
      else if isC0 (value_env n1 e2) then number_of_equality_env e3 e2
      else if isPos (Cmul c (value_env n1 e2))
        then (1 + number_of_equality_env e3 e2)%Z
        else number_of_equality_env e3 e2
 end.

Definition mon := ((C * mon_pos) * mon_exp)%type.

Definition get_pos (m : mon) := fst m.

Definition get_exp (m : mon) := snd m.

Definition make_const_mon n : list mon := cons ((C1, cons n nil), nil) nil.

Definition make_exp_mon x : list mon := cons ((C1, nil), cons x nil) nil.

Definition opp_mon (m : mon) : mon :=
   match m with
     ((c, l1), l2) => ((Cop c, l1), l2)
   end.

Definition prod_mon (m1 m2 : mon) : mon :=
   match m1, m2 with
     ((c1, l1), l2), ((c2, l3), l4) =>
       ((Cmul c1 c2, prod_pos l1 l3), prod_exp l2 l4)
   end.

Definition insert_mon (m : mon) (l : list mon) : list mon := map (prod_mon m) l.

Definition app_mon (l1 l2 : list mon) : list mon :=
   flat_map (fun x => insert_mon x l1) l2.

Definition list_res := ((list mon * env) * pos)%type.

Definition list_get_list (r : list_res) : list mon := fst (fst r).

Definition list_get_env (e : list_res) :=
   match e with ((_, e), _) => e end.

Definition list_get_pos (e : list_res) : pos :=
   match e with ((_, _), n) => n end.

Definition make_list_res l e n : list_res := ((l, e), n).

Fixpoint make_list (p : PExpr) (e : env) (n : pos) {struct p} : list_res :=
 match p with
   PEc c => make_list_res (make_const_mon n) (add_env n c e) (next_pos n)
  | PEX x => make_list_res (make_exp_mon x) e n
  | PEopp p1 =>
      let r1 := make_list p1 e n in
        make_list_res
         (map opp_mon (list_get_list r1)) (list_get_env r1) (list_get_pos r1)
  | PEadd p1 p2 =>
      let r1 := make_list p1 e n in
        let r2 := make_list p2 (list_get_env r1) (list_get_pos r1) in
          make_list_res
           (app (list_get_list r1) (list_get_list r2)) (list_get_env r2)
           (list_get_pos r2)
  | PEsub p1 p2 =>
      let r1 := make_list p1 e n in
        let r2 := make_list p2 (list_get_env r1) (list_get_pos r1) in
          make_list_res
           (app (list_get_list r1) (map opp_mon (list_get_list r2)))
           (list_get_env r2) (list_get_pos r2)
  | PEmul p1 p2 =>
      let r1 := make_list p1 e n in
        let r2 := make_list p2 (list_get_env r1) (list_get_pos r1) in
          make_list_res
           (app_mon (list_get_list r1) (list_get_list r2)) (list_get_env r2)
           (list_get_pos r2)
 end.

Definition factor := (C * mon_pos)%type.

Definition factor_pos (l : list factor) : list pos :=
   fold_left (fun l a => append_pos (snd a) l) l nil.

Fixpoint eval_factors (e : env) (eq : list factor) {struct eq} : C :=
 match eq with
   nil => C0
  | cons ((c, l1)) eq1 =>
      Cplus
       (Cmul c (fold_left (fun a b => Cmul a (value_env b e)) l1 C1))
       (eval_factors e eq1)
 end.

Definition group := (mon_exp * list factor)%type.

Definition make_group e1 e2 : group := (e1, e2).

Fixpoint add_groups (m : mon) (l : list group) {struct l} : list group :=
 match l with
   nil => cons (make_group (get_exp m) (cons (get_pos m) nil)) nil
  | cons ((e, p)) l1 =>
      if mon_exp_eq e (get_exp m) then cons (e, cons (get_pos m) p) l1
        else cons (e, p) (add_groups m l1)
 end.

Definition make_groups (l : list mon) : list group :=
   fold_left (fun l a => add_groups a l) l nil.

Definition equation := (C * list factor)%type.

Definition make_equation (c : C) (f : list factor) : equation := (c, f).

Definition get_const (f : equation) : C := fst f.

Definition get_factors (f : equation) : list factor := snd f.

Definition system := list (list pos * list equation).
 
Fixpoint add_equation_to_system_aux
 (l : list pos) (f : list equation) (s : system) {struct s} : system :=
 match s with
   nil => cons (l,f) nil
  | cons ((l1, f1)) s1 =>
      if list_pos_intersect l l1 
        then add_equation_to_system_aux 
               (append_pos l l1) (app f f1) s1
        else cons (l1, f1) (add_equation_to_system_aux l f s1)
 end.

Definition add_equation_to_system (l : list pos) (f : equation) (s : system)
                                 : system :=
  add_equation_to_system_aux l (cons f nil) s.

Fixpoint make_system (e : env) (l : list group) {struct l} : system :=
 match l with
   nil => nil
  | cons ((_, f)) l1 =>
      add_equation_to_system
       (factor_pos f) (make_equation (eval_factors e f) f) (make_system e l1)
 end.

Fixpoint pos_subst (p : pos) (c : C) (cumul : C) (l : list factor) {struct l} :
 equation :=
 match l with
   nil => (cumul, nil)
  | cons ((c1, l1)) l2 =>
      if pos_in_mon p l1
        then if isC0 (Cmul c c1) then pos_subst p c cumul l2
               else match pos_remove p l1 with
                      nil => pos_subst p c (Cplus cumul (Cop (Cmul c c1))) l2
                     | cons x y =>
                         let r1 := pos_subst p c cumul l2 in
                           (fst r1, cons (Cmul c c1, cons x y) (snd r1))
                    end else let r1 := pos_subst p c cumul l2 in
                               (fst r1, cons (c1, l1) (snd r1))
 end.

Definition update_res := option (equation * option (pos * C)).

Definition update_equation (p : pos) (c : C) (e : equation) : update_res :=
   match pos_subst p c (get_const e) (get_factors e) with
     (c1, nil) => if isC0 c1 then Some ((c1, nil), None) else None
    | (c1, cons ((c2, cons p1 nil)) nil) =>
        if Cdivide c2 c1 then Some ((C0, nil), Some (p1, Cdiv c1 c2)) else None
    | (c1, cons ((c2, l1)) nil) =>
        if Cdivide c2 c1 then Some ((c1, cons (c2, l1) nil), None) else None
    | (c1, l1) => Some ((c1, l1), None)
   end.

Definition updates_res := option (list equation * list (positive * C)).
 
Definition list_of_option (e : option (positive * C)) :=
   match e with None => nil | Some e => cons e nil end.
 
Definition ocons := fun (x: equation) y =>
  match x with (_, nil) => y | _ => (cons x y) end.

Fixpoint update_equations (p : pos) (c : C) (l : list equation) {struct l} :
 updates_res :=
 match l with
   nil => Some (nil, nil)
  | cons eq l1 =>
      match update_equation p c eq with
        None => None
       | Some ((eq1, v1)) =>
           match update_equations p c l1 with
             None => None
            | Some ((l2, l3)) => Some (ocons eq1 l2, app (list_of_option v1) l3)
           end
      end
 end.

Definition propagate_res := option (list equation * env).
 
Fixpoint propagate (n : nat) (p : pos) (c : C) (e : env) (l : list equation)
                   {struct n} : propagate_res :=
 match update_equations p c l with
   None => None
  | Some ((l1, nil)) => Some (l1, update_env p c e)
  | Some ((l1, l2)) =>
      match n with
        0 => None
       | S n1 =>
           fold_left
            (fun res a =>
                match res with
                  None => None
                 | Some ((l1, e1)) => propagate n1 (fst a) (snd a) e1 l1
                end) l2 (Some (l1, update_env p c e))
      end
 end.

Definition candidat := option ((Z * Z) * env).

Definition get_best (c1 c2 : candidat) : candidat :=
   match c1 with
     None => c2
    | Some (((i1, j1), _)) =>
        match c2 with
          None => c1
         | Some (((i2, j2), _)) =>
             if Zeq_bool i1 i2 then if Zle_bool j2 j1 then c1 else c2
               else if Zle_bool i1 i2 then c2 else c1
        end
   end.

Definition is_possible (best : candidat) (e : env) (vars : list pos) : bool :=
   match best with
     None => true
    | Some (((i1, j1), _)) => Zeq_bool i1 (number_of_zero_env e + Zlength vars)
   end.
 
Definition make_candidat (init_e e : env) : candidat :=
   Some ((number_of_zero_env e, number_of_equality_env e init_e), e).

Fixpoint search_best_aux (best : candidat) (n: nat) (init_e e : env) (l : list equation)
                         (vars : list pos)  {struct vars} : candidat :=
 if is_possible best e vars
   then match vars with
          nil => match l with nil => get_best best (make_candidat init_e e)
                    | _ => best
                    end
        | cons x vars1 =>
             if is_bound_env x e then search_best_aux best n init_e e l vars1
               else let best1 :=
                     match propagate n x C0 e l with
                       None => best
                      | Some ((l1, e1)) =>
                          search_best_aux best n init_e e1 l1 vars1
                     end in
                      let best2 :=
                       match propagate n x (value_env x init_e) e l
                        with
                         None => best
                        | Some ((l1, e1)) =>
                            search_best_aux best1 n init_e e1 l1 vars1
                       end in
                        search_best_aux best2 n init_e e l vars1
        end else best.
 
Definition search_best (init_e : env) (s : system) : env :=
   flat_map
    (fun x =>
        match x with
          (vars, eqs) =>
            match search_best_aux None  (S (length vars)) (restrict_env vars init_e) nil eqs vars
             with None => nil | Some ((_, e)) => e end
        end) s.

Fixpoint make_PExpr_aux (p : PExpr) (e : env) (n : pos) {struct p} :
 (PExpr * pos)%type :=
 match p with
   PEc c => (PEc (value_env n e), next_pos n)
  | PEX x => (p, n)
  | PEopp p1 => let (fr1,sr1) := make_PExpr_aux p1 e n in
                  (mkPEopp fr1, sr1)
  | PEadd p1 p2 =>
      let (fr1, sr1) := make_PExpr_aux p1 e n in
        let (fr2, sr2) := make_PExpr_aux p2 e sr1 in
          (mkPEadd fr1 fr2, sr2)
  | PEsub p1 p2 =>
      let (fr1, sr1) := make_PExpr_aux p1 e n in
        let (fr2, sr2) := make_PExpr_aux p2 e sr1 in
          (mkPEsub fr1 fr2, sr2)
  | PEmul p1 p2 =>
      let (fr1, sr1) := make_PExpr_aux p1 e n in
        let (fr2, sr2) := make_PExpr_aux p2 e sr1 in
          (mkPEmul fr1 fr2, sr2)
 end.
 
Definition make_PExpr (p : PExpr) (e : env) :=
   fst (make_PExpr_aux p e init_pos).

Definition make_PExpr_minus (p : PExpr) (e : env) :=
   fst match p with
         PEsub p1 p2 =>
           let r1 := make_PExpr_aux p1 e init_pos in
             let r2 := make_PExpr_aux p2 e (snd r1) in
               (PEsub (fst r1) (fst r2), snd r2)
        | _ => make_PExpr_aux p e init_pos
       end.

Definition simpl (e : PExpr) : PExpr :=
   let exp := lift_const e in
     let res := make_list exp empty_env init_pos in
       make_PExpr
        exp
        (search_best
          (list_get_env res)
          (make_system (list_get_env res) (make_groups (list_get_list res)))).

Definition simpl_minus (e : PExpr) :=
   let exp := lift_const e in
     let res := make_list exp empty_env init_pos in
       make_PExpr_minus
        exp
        (search_best
          (list_get_env res)
          (make_system (list_get_env res) (make_groups (list_get_list res)))).

Fixpoint convert_back (F : Set) (f : F) (Fadd Fsub Fmult : F -> F ->  F)
                      (Fop : F ->  F) (C2F : C ->  F) (l : list F) (e : PExpr)
                      {struct e} : F :=
 match e with
   PEc c => C2F c
  | PEX x => pos_nth f x l
  | PEopp e1 => Fop (convert_back F f Fadd Fsub Fmult Fop C2F l e1)
  | PEadd e1 e2 =>
      Fadd
       (convert_back F f Fadd Fsub Fmult Fop C2F l e1)
       (convert_back F f Fadd Fsub Fmult Fop C2F l e2)
  | PEsub e1 e2 =>
      Fsub
       (convert_back F f Fadd Fsub Fmult Fop C2F l e1)
       (convert_back F f Fadd Fsub Fmult Fop C2F l e2)
  | PEmul e1 e2 =>
      Fmult
       (convert_back F f Fadd Fsub Fmult Fop C2F l e1)
       (convert_back F f Fadd Fsub Fmult Fop C2F l e2)
 end.

End PolSimplBase.

Arguments PEc [C].
Arguments PEX [C].
Arguments PEadd [C].
Arguments PEsub [C].
Arguments PEmul [C].
Arguments PEopp [C].

Ltac term_eq t1 t2 :=
  constr:(ltac:(first[constr_eq t1 t2; exact true| exact false])).

Ltac IN a l :=
 match l with
 | (cons ?b ?l1) => 
    let t := term_eq a b in
    match t with
    true => constr:(true)
    | _ => IN a l1
    end
 |  nil => false
 end.

Ltac AddFv a l :=
 match (IN a l) with
 | true => constr:(l)
 | _ => constr:(cons a l)
 end.

Ltac Find_at a l :=
 match l with
 | nil  => constr:(xH)
 | (cons ?b ?l) => 
     let t := term_eq a b in
     match t with
     | true =>  constr:(xH)
     | false => let p := Find_at a l in eval compute in (Pos.succ p)
     end
 end.
		      
Ltac FV Cst add mul sub opp t fv :=
 let rec TFV t fv :=
  match t with
  | (add ?t1 ?t2) => 
    let fv1 := TFV t1 fv in let fv2 := TFV t2 fv1 in constr:(fv2)
  | (mul ?t1 ?t2) => 
    let fv1 := TFV t1 fv in let fv2 := TFV t2 fv1 in constr:(fv2)
  | (sub ?t1 ?t2) => 
    let fv1 := TFV t1 fv in let fv2 := TFV t2 fv1 in constr:(fv2)
  | (opp ?t1) => 
    let fv1 := TFV t1 fv in constr:(fv1)
  | _ =>  
    match Cst t with
    | false => let fv1 := AddFv t fv in constr:(fv1)
    | _ => constr:(fv)
    end
  end 
 in TFV t fv.

 Ltac mkPolexpr T Cst add mul sub opp t fv := 
 let rec mkP t :=
 match Cst t with
    | false => 
       match t with 
        | (add ?t1 ?t2) => 
          let e1 := mkP t1 in
          let e2 := mkP t2 in constr:(PEadd e1 e2)
        | (mul ?t1 ?t2) => 
          let e1 := mkP t1 in
          let e2 := mkP t2 in constr:(PEmul e1 e2)
        | (sub ?t1 ?t2) => 
          let e1 := mkP t1 in
          let e2 := mkP t2 in constr:(PEsub e1 e2)
        | (opp ?t1) =>
          let e1 := mkP t1 in constr:(PEopp e1)
        | _ => let p := Find_at t fv in constr:(@PEX T p)
        end
    | ?c => constr:(PEc c)
  end
  in mkP t. *)

Require Import PolFBase.
(* PolFBase:
Require Import PolSBase.

Section PolFactorSimpl.

Variable C : Set.

Variable Cplus : C -> C ->  C.
Variable Cmul : C -> C ->  C.
Variable Cop : C ->  C.

Variable C0 : C.
Variable C1 : C.

Variable isC1 : C ->  bool.

Variable isC0 : C ->  bool.

Variable isPos : C ->  bool.

Variable Cdivide : C -> C ->  bool.

Variable Cdiv : C -> C ->  C.

Variable Cgcd: C -> C -> C.

Definition is_eq :=  fun x y => 
  let r :=  simpl C Cplus Cmul Cop C0 C1 isC1 isC0 isPos Cdivide Cdiv (PEsub x y) in
   match r with
     PEc c  => isC0 c
  |  _          => false
  end.

Definition is_op :=  fun x y => 
  let r :=  simpl C Cplus Cmul Cop C0 C1 isC1 isC0 isPos Cdivide Cdiv (PEadd x y) in
   match r with
     PEc c  => isC0 c
  |  _          => false
  end.

Definition test_in :=
   fun x y => 
        match x, y with
          PEc c1, PEc c2 =>  if (isC1 (Cgcd c1 c2)) then false else true
         | _ , _ => match (is_eq x y) with true => true | false => is_op x y end
        end.

Fixpoint first_factor (e: PExpr C) : PExpr C :=
match e with
  PEadd e1 _  =>  first_factor e1
| PEsub e1 _  =>  first_factor e1
| PEopp e1     =>  first_factor e1
| _                    =>  e
end.

Fixpoint split_factor (e: PExpr C) : list (PExpr C) :=
match e with
  PEmul e1 e2  =>  (split_factor e1)++(split_factor e2)
| PEopp e1        =>  match  (split_factor e1) with (_::nil) => e::nil | l1 => l1 end 
| _                    =>  e::nil
end.

Fixpoint split_factors (e: PExpr C) : list (list (PExpr C)) :=
match e with
  PEadd e1 e2  =>  (split_factors e1)++(split_factors e2)
| PEsub e1 e2  =>  (split_factors e1)++(split_factors e2)
| PEopp e1        =>  match  (split_factors e1) with ((_::nil)::nil) => (e::nil)::nil | l1 => l1 end 
| _                    =>  (split_factor e)::nil
end.

Definition oapp:= 
   fun (A B:Set) (a: A) (f: A -> B -> B) (l: option B) => 
       match l with Some l1 => Some (f a l1) | _ => None end.

Let ocons := fun  x => oapp _ _ x (@cons (PExpr C)).

Fixpoint remove_elem (e: PExpr C) (l: list (PExpr C)) {struct l}: option (list (PExpr C)) :=
match l with
   nil   =>  None
| cons e1 l1  =>  if (test_in e e1) then Some l1 else (ocons e1 (remove_elem e l1))
end.

Let oconst := fun (A:Set) x =>  oapp _ _ x (fun x (y: A * list (PExpr C)) => let (v1,l1) := y in (v1, x::l1)).

Fixpoint remove_constant (c: C) (l: list (PExpr C)) {struct l}: option (C * list (PExpr C)) :=
match l with
   nil   =>  None
| cons (PEc c1)  l1  =>  if (isC1 (Cgcd c c1)) then oconst  _ (PEc c1) (remove_constant c l1)
                                                                             else Some (Cgcd c c1, cons (PEc (Cdiv c (Cgcd c c1))) l1)
| cons c1 l1 => oconst _  c1 (remove_constant c l1)
end.
        
Fixpoint strip (l1 l2: list (PExpr C)) {struct l1} : list (PExpr C) :=
match l1 with
  nil => nil
| cons (PEc c) l3 => match remove_constant c l2 with 
                                     None => strip l3 l2
                                  | Some (c1, l4) => cons (PEc c1) (strip l3 l4)
                                   end
| cons e l3 =>  match remove_elem e l2 with 
                                     None => strip l3 l2
                                  | Some l4 => cons e (strip l3 l4)
                           end
end.

Fixpoint delta (l1: list (PExpr C))  (l2:  list (list (PExpr C))) {struct l2} : list (PExpr C) :=
match l2 with
nil => l1
| cons l l4 => match strip l1 l with 
                         nil  => nil
                       | l3 => delta l3 l4
                      end
end.

Let mkMul := mkPEmul C Cmul Cop C0 isC1 isC0.
Let mkOpp := mkPEopp  C Cop.
Let mkAdd := mkPEadd C Cplus Cmul Cop C0 isC1 isC0 isPos.
Let mkSub := mkPEsub C Cplus Cmul Cop C0 isC1 isC0 isPos.

Fixpoint subst_elem (e: PExpr C) (l: list (PExpr C)) {struct l}: option (bool * list (PExpr C)) :=
match l with
   nil   =>  None
| cons e1 l1  =>  if is_eq e e1 then Some (true, l1) else
                             if is_op e e1 then Some (false, l1) else  (oconst _ e1 (subst_elem e l1))
end.

Fixpoint subst_constant (c: C) (l: list (PExpr C)) {struct l}: option (C * list (PExpr C)) :=
match l with
   nil   =>  None
| cons (PEc c1)  l1  =>  if (Cdivide c1 c) then  Some (Cdiv c c1,  l1)
                                                                      else oconst _ (PEc c1) (subst_constant c l1)
| cons e1 l1 => oconst _ e1 (subst_constant c l1)
end.
    
Fixpoint subst_one_factor (e: PExpr C) (l: list (PExpr C)) {struct e}: PExpr C * list (PExpr C) :=
match e with
  PEmul e1 e2  => let (e3, l1) := subst_one_factor e1 l in
                                let (e4, l2) := subst_one_factor e2 l1 in
                                  (mkMul e3 e4, l2)
| PEopp e1        =>  let (e3, l1) := subst_one_factor e1 l in
                                     (mkOpp e3, l1) 
| PEc c               => match subst_constant c l with
                                     None => (e, l)
                                 |   Some (c1, l1) => (PEc c1, l1)
                                 end 
| _ =>  match subst_elem e l with
              None => (e, l) 
           | Some (true, l1) => (PEc C1, l1)
           | Some (false, l1) => (PEc (Cop C1), l1)
           end
end.

Fixpoint subst_factor (l: list (PExpr C)) (e: PExpr C) {struct e} : PExpr C :=
match e with
  PEadd e1 e2  =>  mkAdd (subst_factor l e1) (subst_factor l e2)
| PEsub e1 e2=>  mkSub (subst_factor l e1) (subst_factor l e2)
| PEopp e1  =>   mkOpp (subst_factor l e1)
| _                 => fst (subst_one_factor e l) 
end.

Definition get_delta := fun e => match split_factors e with
                                                        l1::l => delta l1 l
                                                      | _ => nil
                                                      end.

Fixpoint mkProd (l: (list (PExpr C))) {struct l} : (PExpr C) :=
   match l with 
      nil => (PEc C1)
  | e::nil => e
  | e::l1 => mkMul e (mkProd l1)
  end.

Fixpoint find_trivial_factor (e: PExpr C) (l: list (list (PExpr C))) {struct l}: PExpr C :=
  match l with
     l1::ll2 => let e1 := mkProd l1 in
                     let e2 := simpl C Cplus Cmul Cop C0 C1 isC1 isC0 isPos Cdivide Cdiv (mkSub e e1) in
                     match subst_elem e2 l1 with
                       None => find_trivial_factor e ll2
                     | Some (true, l2) =>  PEmul e2 (mkAdd (mkProd l2) (PEc C1)) 
                     | Some (false, l2) =>   PEmul e2 (mkSub (PEc C1) (mkProd l2))
                     end 
|   _ => (PEmul (PEc C1) e)
    end.

Definition isPC1 := fun x => match x with (PEc c) => (isC1 c) | _ => false end.
Definition isPC0 := fun x => match x with (PEc c) => (isC0 c) | _ => false end.

Fixpoint factor (e:  PExpr C) : PExpr C :=
  let e1 := match e with
     PEmul e1 e2  => PEmul (factor e1) (factor e2)
|     PEadd e1 e2  => PEadd (factor e1) (factor e2)
|     PEsub e1 e2  => PEsub (factor e1) (factor e2)
|     PEopp e1        =>  PEopp (factor e1)  
| _ => e end in
     let e2 := get_delta e1 in
                                   if (isPC1 (mkProd e2)) then
                                     find_trivial_factor e1 (split_factors e1)
                                   else
                                     (PEmul (mkProd e2) (subst_factor e2 e1)).

Definition factor_sub := fun f => 
 let e := match f with
     PEmul e1 e2  => PEmul (factor e1) (factor e2)
|     PEadd e1 e2  => PEadd (factor e1) (factor e2)
|     PEsub e1 e2  => PEsub (factor e1) (factor e2)
|     PEopp e1        =>  PEopp (factor e1)  
| _ => f end in
  match e with
    PEsub e1 e2 =>   
           if (isPC0 e1)  then
               let d1 :=  (get_delta e2) in
                  PEmul (mkProd d1) (PEsub (PEc C0) (subst_factor d1 e2))
          else if (isPC0 e2) then
               let d1 := (get_delta e1) in
                  PEmul (mkProd d1) (PEsub (subst_factor d1 e2) (PEc C0))
         else
               let d := get_delta e in
                  (PEmul (mkProd d) 
                    (PEsub (subst_factor d e1) 
                                       (subst_factor d e2)))
    |  _   => let d := get_delta e in
                  (PEmul (mkProd d) (subst_factor d e))
  end.

Definition factor_sub_val := fun e d1 => 
  let d2 := split_factor d1 in
  match e with
    PEsub e1 e2 =>   
           if (isPC0 e1)  then
                  PEmul d1 (PEsub (PEc C0) (subst_factor d2 e2))
          else if (isPC0 e2) then
                  PEmul d1 (PEsub (subst_factor d2 e2) (PEc C0))
         else
                  (PEmul d1 
                    (PEsub (subst_factor d2 e1) 
                                       (subst_factor d2 e2)))
    |  _   => (PEmul d1 (subst_factor d2 e))
  end.

End PolFactorSimpl. *)

Require Import PolAux.
(* PolAux:
Require Import ZArith.
Require Import NArith.
Require Import NAux.
Require Export Replace2.
Require Import P.

Require Import Reals.

Definition Natopp := (fun x:nat => 0%nat).

Definition Nopp := (fun x:N => 0%N).

Definition is_Z0 := (Zeq_bool 0).
Definition is_Z1 := (Zeq_bool 1).
Definition is_Zpos := (Zle_bool 0).
Definition is_Zdiv :=
  fun x y => if Zeq_bool x Z0 then false else Zeq_bool Z0 (Zmod y x).
Definition Zgcd :=
 fun x y => (if (is_Zdiv x y) then x else if (is_Zdiv y x) then y else 1%Z).

Ltac is_NatCst p :=
  match p with
  | O => constr:(true)
  | S ?p' => is_NatCst p'
  | _ => constr:(false)
end.

Ltac NatCst t :=
  match is_NatCst t with
  | false => constr:(false)
  | _ => let res := eval compute in (Z_of_nat t) in constr:(res)
end.

Ltac is_PCst p :=
  match p with
  | xH => constr:(true)
  | xO ?p' => is_PCst p'
  | xI ?p' => is_PCst p'
  | _ => constr:(false)
end.

Ltac is_NCst p :=
  match p with
  | N0 => constr:(true)
  | Npos ?p' => is_PCst p'
  | _ => constr:(false)
end.

Ltac NCst t :=
  match is_NCst t with
  | false => constr:(false)
  | _ => let res := eval compute in (Z_of_N t) in constr:(res)
end.

Ltac ZCst t :=
  match t with
  | Z0 => constr:(t)
  | Zpos ?p => match is_PCst p with
               | false => constr:(false)
               | _ => constr:(t)
               end
  | Zneg ?p => match is_PCst p with
               | false => constr:(false)
               | _ => constr:(t)
               end
  | _ => constr:(false)
  end.

Ltac is_ZCst t := match t with
                | Z0 => constr:(true)
                | Zpos ?p => is_PCst p
                | Zneg ?p => is_PCst p
                | _ => constr:(false) end.

Fixpoint P2R (z: positive) {struct z}: R :=
  match z with
     xH => 1%R
  | (xO xH) => 2%R
  | (xI xH) => 3%R
  | (xO z1) => (2*(P2R z1))%R
  | (xI z1) => (1+2*(P2R z1))%R
 end.

Definition Z2R (z: Z): R :=
  match z with
     Z0 => 0%R
  | (Zpos z1) => (P2R z1)%R
  | (Zneg z1) => (-(P2R z1))%R
 end.

Ltac RCst t :=
  match t with
   | R0 => constr:(Z0)
   | R1 => constr:(Zpos xH)
   | Rplus ?e1 ?e2 =>
       match (RCst e1) with
        false => constr:(false)
      | ?e3 => match (RCst e2) with
                 false => constr:(false)
              |  ?e4 =>  eval vm_compute in (Zplus e3  e4)
              end
      end
   | Rminus ?e1 ?e2 =>
       match (RCst e1) with
        false => constr:(false)
      | ?e3 => match (RCst e2) with
                 false => constr:(false)
              |  ?e4 => eval vm_compute in (Zminus e3  e4)
              end
      end
   | Rmult ?e1 ?e2 =>
       match (RCst e1) with
        false => constr:(false)
      | ?e3 => match (RCst e2) with
                 false => constr:(false)
              |  ?e4 => eval vm_compute in (Zmult e3  e4)
              end
      end
   | Ropp ?e1 =>
       match (RCst e1) with
        false => constr:(false)
      | ?e3 => eval vm_compute in (Z.opp e3)
      end
   | IZR ?e1 =>
       match (ZCst e1) with
        false => constr:(false)
      | ?e3 => e3
      end

   | _ => constr:(false)
 end.

Ltac clean_zabs term :=
  match term with
   context id [(Z.abs_nat ?X)] =>
     match is_ZCst X with
       true =>
         let x := eval vm_compute in (Z.abs_nat X) in
         let y := context id [x] in
           clean_zabs y
     | false => term
     end
    | _ => term
  end.

Ltac clean_zabs_N term :=
  match term with
   context id [(Z.abs_N ?X)] =>
     match is_ZCst X with
       true =>
         let x := eval vm_compute in (Z.abs_N X) in
         let y := context id [x] in
           clean_zabs_N y
     | false => term
     end
    | _ => term
  end.

Ltac eqterm t1 t2 :=
  match constr:((t1,t2)) with (?X, ?X) => true | _ => false end.

Theorem trans_equal_r : forall (A: Set) (x y z:A), y = z -> x = y -> x = z.

Open Scope nat_scope.

Theorem plus_eq_compat_l: forall a b c, b = c -> a + b = a + c.

Theorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.

Theorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.

Theorem plus_neg_reg_l: forall a b c,  a + b <> a + c -> b <> c.

Theorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m.

Theorem eq_lt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).
Theorem eq_lt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).
Theorem eq_gt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).
Theorem eq_gt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).
Theorem eq_le_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).
Theorem eq_le_trans_r : forall x y z, (y = z) -> (x <= y) -> (x <= z).
Theorem eq_ge_trans_l : forall x y z, (x = z) -> (x >= y) -> (z >= y).
Theorem eq_ge_trans_r : forall x y z, (y = z) -> (x >= y) -> (x >= z).

Theorem ge_trans: forall x y z, (x >= z) -> (z >= y) -> (x >= y).

Close Scope nat_scope.

Open Scope N_scope.

Theorem Nplus_eq_compat_l: forall a b c, b = c -> a + b = a + c.

Theorem Nplus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.

Theorem Nplus_lt_compat_l: forall n m p, n < m -> p + n < p + m.

Theorem Nplus_gt_compat_l: forall n m p, n > m -> p + n > p + m.

Theorem Nplus_le_compat_l: forall n m p, n <= m -> p + n <= p + m.

Theorem Nplus_ge_compat_l: forall n m p, n >= m -> p + n >= p + m.

Theorem Nplus_neg_reg_l: forall a b c,  a + b <> a + c -> b <> c.

Theorem Nplus_lt_reg_l: forall n m p, p + n < p + m -> n < m.

Theorem Nplus_gt_reg_l: forall n m p, p + n > p + m -> n > m.

Theorem Nplus_le_reg_l: forall n m p, p + n <= p + m -> n <= m.

Theorem Nplus_ge_reg_l: forall n m p, p + n >= p + m -> n >= m.

Theorem Neq_lt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).

Theorem Neq_lt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).

Theorem Neq_gt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).
Theorem Neq_gt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).
Theorem Neq_le_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).
Theorem Neq_le_trans_r : forall x y z, (y = z) -> (x <= y) -> (x <= z).
Theorem Neq_ge_trans_l : forall x y z, (x = z) -> (x >= y) -> (z >= y).
Theorem Neq_ge_trans_r : forall x y z, (y = z) -> (x >= y) -> (x >= z).

Theorem Nge_trans: forall x y z, (x >= z) -> (z >= y) -> (x >= y).

Close Scope N_scope.

Open Scope Z_scope.

Theorem Zplus_eq_compat_l: forall a b c:Z, (b = c -> a + b = a + c)%Z.

Theorem Zplus_neg_compat_l: forall a b c: Z, (b <> c -> a + b <> a + c)%Z.

Theorem Zplus_ge_compat_l: forall n m p : Z, (n >= m -> p + n >= p + m)%Z.

Theorem Zplus_neg_reg_l: forall a b c: Z,  (a + b <> a + c -> b <> c)%Z.

Theorem Zplus_ge_reg_l: forall n m p : Z, (p + n >= p + m -> n >= m)%Z.

Theorem Zle_sign_pos_pos: forall x y: Z, (0 <= x -> 0 <= y  -> 0 <= x * y)%Z.

Theorem Zle_sign_neg_neg: forall x y: Z, (x <= 0 -> y <= 0  -> 0 <= x * y)%Z.

Theorem Zopp_le: forall n m, (m <= n -> -n <= -m)%Z.

Theorem Zle_pos_neg: forall x, (0 <= -x -> x <= 0)%Z.

Theorem Zle_sign_pos_neg: forall x y: Z, (0 <= x -> y <= 0  -> x * y <= 0)%Z.

Theorem Zle_sign_neg_pos: forall x y: Z, (x <= 0 -> 0 <= y  -> x * y <= 0)%Z.

Theorem Zlt_sign_pos_pos: forall x y: Z, (0 < x -> 0 < y  -> 0 < x * y)%Z.

Theorem Zlt_sign_neg_neg: forall x y: Z, (x < 0 -> y < 0  -> 0 < x * y)%Z.

Theorem Zlt_pos_neg: forall x, (0 < -x -> x < 0)%Z.

Theorem Zlt_sign_pos_neg: forall x y: Z, (0 < x -> y < 0  -> x * y < 0)%Z.

Theorem Zlt_sign_neg_pos: forall x y: Z, (x < 0 -> 0 < y  -> x * y < 0)%Z.

Theorem Zge_sign_neg_neg: forall x y: Z, (0 >= x -> 0 >= y  -> x * y >= 0)%Z.

Theorem Zge_sign_pos_pos: forall x y: Z, (x >= 0 -> y >= 0  -> x * y >= 0)%Z.

Theorem Zge_neg_pos: forall x, (0 >= -x -> x >= 0)%Z.

Theorem Zge_sign_neg_pos: forall x y: Z, (0 >= x -> y >= 0  -> 0>= x * y)%Z.

Theorem Zge_sign_pos_neg: forall x y: Z, (x >= 0 -> 0 >= y  -> 0 >= x * y)%Z.

Theorem Zgt_sign_neg_neg: forall x y: Z, (0 > x -> 0 > y  -> x * y > 0)%Z.

Theorem Zgt_sign_pos_pos: forall x y: Z, (x > 0 -> y > 0  -> x * y > 0)%Z.

Theorem Zgt_neg_pos: forall x, (0 > -x -> x > 0)%Z.

Theorem Zgt_sign_neg_pos: forall x y: Z, (0 > x -> y > 0  -> 0> x * y)%Z.

Theorem Zgt_sign_pos_neg: forall x y: Z, (x > 0 -> 0 > y  -> 0 > x * y)%Z.

Theorem Zle_sign_pos_pos_rev: forall x y: Z, (0 < x -> 0 <= x * y -> 0 <= y)%Z.

Theorem Zle_sign_neg_neg_rev: forall x y: Z, (x < 0 -> 0 <= x * y ->  y <= 0)%Z.

Theorem Zle_sign_pos_neg_rev: forall x y: Z, (0 < x -> x * y <= 0 -> y <= 0)%Z.

Theorem Zle_sign_neg_pos_rev: forall x y: Z, (x < 0 -> x * y <= 0 ->  0 <= y)%Z.

Theorem Zge_sign_pos_pos_rev: forall x y: Z, (x > 0 -> x * y >= 0 -> y >= 0)%Z.

Theorem Zge_sign_neg_neg_rev: forall x y: Z, (0 > x -> x * y  >= 0->  0 >= y)%Z.

Theorem Zge_sign_pos_neg_rev: forall x y: Z, (x > 0 -> 0 >= x * y -> 0 >= y)%Z.

Theorem Zge_sign_neg_pos_rev: forall x y: Z, (0 > x -> 0 >= x * y ->  y >= 0)%Z.

Theorem Zlt_sign_pos_pos_rev: forall x y: Z, (0 < x -> 0 < x * y -> 0 < y)%Z.

Theorem Zlt_sign_neg_neg_rev: forall x y: Z, (x < 0 -> 0 < x * y ->  y < 0)%Z.

Theorem Zlt_sign_pos_neg_rev: forall x y: Z, (0 < x -> x * y < 0 -> y < 0)%Z.

Theorem Zlt_sign_neg_pos_rev: forall x y: Z, (x < 0 -> x * y < 0 ->  0 < y)%Z.

Theorem Zgt_sign_pos_pos_rev: forall x y: Z, (x > 0 -> x * y > 0 -> y > 0)%Z.

Theorem Zgt_sign_neg_neg_rev: forall x y: Z, (0 > x -> x * y  > 0->  0 > y)%Z.

Theorem Zgt_sign_pos_neg_rev: forall x y: Z, (x > 0 -> 0 > x * y -> 0 > y)%Z.

Theorem Zgt_sign_neg_pos_rev: forall x y: Z, (0 > x -> 0 > x * y ->  y > 0)%Z.

Theorem Zmult_le_neg_compat_l:
  forall n m p : Z, (m <= n)%Z -> (p <= 0)%Z -> (p * n <= p * m)%Z.

Theorem Zopp_lt: forall n m, (m < n -> -n < -m)%Z.

Theorem Zmult_lt_neg_compat_l:
  forall n m p : Z, (m < n)%Z -> (p < 0)%Z -> (p * n < p * m)%Z.

Theorem Zopp_ge: forall n m, (m >= n -> -n >= -m)%Z.

Theorem Zmult_ge_neg_compat_l:
  forall n m p : Z, (m >= n)%Z -> (0 >= p)%Z -> (p * n >= p * m)%Z.

Theorem Zopp_gt: forall n m, (m > n -> -n > -m)%Z.

Theorem Zmult_gt_neg_compat_l:
  forall n m p : Z, (m > n)%Z -> (0 > p)%Z -> (p * n > p * m)%Z.

Theorem Zmult_le_compat_l_rev:
  forall n m p : Z, (0 < p)%Z -> (p * n <= p * m)%Z -> (n <= m)%Z.

Theorem Zmult_le_neg_compat_l_rev:
  forall n m p : Z, (p < 0)%Z -> (p * n <= p * m)%Z -> (m <= n)%Z.

Theorem Zmult_lt_compat_l_rev:
  forall n m p : Z, (0 < p)%Z -> (p * n < p * m)%Z -> (n < m)%Z.

Theorem Zmult_lt_neg_compat_l_rev:
  forall n m p : Z, (p < 0)%Z -> (p * n < p * m)%Z -> (m < n)%Z.

Theorem Zmult_ge_compat_l_rev:
  forall n m p : Z, (p > 0)%Z -> (p * n >= p * m)%Z -> (n >= m)%Z.

Theorem Zmult_ge_neg_compat_l_rev:
  forall n m p : Z, (0 > p)%Z -> (p * n >= p * m)%Z -> (m >= n)%Z.

Theorem Zmult_gt_compat_l_rev:
  forall n m p : Z, (p > 0)%Z -> (p * n > p * m)%Z -> (n > m)%Z.

Theorem Zmult_gt_neg_compat_l_rev:
  forall n m p : Z, (0 > p)%Z -> (p * n > p * m)%Z -> (m > n)%Z.

Theorem eq_Zlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).
Theorem eq_Zlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).
Theorem eq_Zgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).
Theorem eq_Zgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).
Theorem eq_Zle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).
Theorem eq_Zle_trans_r : forall x y z, (y = z) -> (x <= y) -> (x <= z).
Theorem eq_Zge_trans_l : forall x y z, (x = z) -> (x >= y) -> (z >= y).
Theorem eq_Zge_trans_r : forall x y z, (y = z) -> (x >= y) -> (x >= z).

Theorem Zge_trans: forall x y z, (x >= z) -> (z >= y) -> (x >= y).

Close Scope Z_scope.

Open Scope R_scope.

Theorem Rplus_eq_compat_l: forall a b c:R, (b = c -> a + b = a + c)%R.

Theorem Rplus_neg_compat_l: forall a b c: R, (b <> c -> a + b <> a + c)%R.

Theorem Rplus_ge_compat_l: forall n m p : R, (n >= m -> p + n >= p + m)%R.

Theorem Rplus_neg_reg_l: forall a b c: R,  (a + b <> a + c -> b <> c)%R.

Theorem Rplus_ge_reg_l: forall n m p : R, (p + n >= p + m -> n >= m)%R.

Theorem Rle_sign_pos_pos: forall x y, (0 <= x -> 0 <= y  -> 0 <= x * y)%R.

Theorem Rle_sign_neg_neg: forall x y, (x <= 0 -> y <= 0  -> 0 <= x * y)%R.

Theorem Rle_pos_neg: forall x, (0 <= -x -> x <= 0)%R.

Theorem Rle_sign_pos_neg: forall x y: R, (0 <= x -> y <= 0  -> x * y <= 0)%R.

Theorem Rle_sign_neg_pos: forall x y, (x <= 0 -> 0 <= y  -> x * y <= 0)%R.

Theorem Rlt_sign_pos_pos: forall x y, (0 < x -> 0 < y  -> 0 < x * y)%R.

Theorem Rlt_sign_neg_neg: forall x y, (x < 0 -> y < 0  -> 0 < x * y)%R.

Theorem Rlt_pos_neg: forall x, (0 < -x -> x < 0)%R.

Theorem Rlt_sign_pos_neg: forall x y, (0 < x -> y < 0  -> x * y < 0)%R.

Theorem Rlt_sign_neg_pos: forall x y, (x < 0 -> 0 < y  -> x * y < 0)%R.

Theorem Rge_sign_neg_neg: forall x y, (0 >= x -> 0 >= y  -> x * y >= 0)%R.

Theorem Rge_sign_pos_pos: forall x y, (x >= 0 -> y >= 0  -> x * y >= 0)%R.

Theorem Rge_neg_pos: forall x, (0 >= -x -> x >= 0)%R.

Theorem Rge_sign_neg_pos: forall x y: R, (0 >= x -> y >= 0  -> 0>= x * y)%R.

Theorem Rge_sign_pos_neg: forall x y, (x >= 0 -> 0 >= y  -> 0 >= x * y)%R.

Theorem Rgt_sign_neg_neg: forall x y, (0 > x -> 0 > y  -> x * y > 0)%R.

Theorem Rgt_sign_pos_pos: forall x y, (x > 0 -> y > 0  -> x * y > 0)%R.

Theorem Rgt_neg_pos: forall x, (0 > -x -> x > 0)%R.

Theorem Rgt_sign_neg_pos: forall x y, (0 > x -> y > 0  -> 0> x * y)%R.

Theorem Rgt_sign_pos_neg: forall x y, (x > 0 -> 0 > y  -> 0 > x * y)%R.

Theorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.

Theorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y ->  y <= 0)%R.

Theorem Rle_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y <= 0 -> y <= 0)%R.

Theorem Rle_sign_neg_pos_rev: forall x y: R, (x < 0 -> x * y <= 0 ->  0 <= y)%R.

Theorem Rge_sign_pos_pos_rev: forall x y: R, (x > 0 -> x * y >= 0 -> y >= 0)%R.

Theorem Rge_sign_neg_neg_rev: forall x y: R, (0 > x -> x * y  >= 0->  0 >= y)%R.

Theorem Rge_sign_pos_neg_rev: forall x y: R, (x > 0 -> 0 >= x * y -> 0 >= y)%R.

Theorem Rge_sign_neg_pos_rev: forall x y: R, (0 > x -> 0 >= x * y ->  y >= 0)%R.

Theorem Rlt_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 < x * y -> 0 < y)%R.

Theorem Rlt_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 < x * y ->  y < 0)%R.

Theorem Rlt_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y < 0 -> y < 0)%R.

Theorem Rlt_sign_neg_pos_rev: forall x y: R, (x < 0 -> x * y < 0 ->  0 < y)%R.

Theorem Rgt_sign_pos_pos_rev: forall x y: R, (x > 0 -> x * y > 0 -> y > 0)%R.

Theorem Rgt_sign_neg_neg_rev: forall x y: R, (0 > x -> x * y  > 0->  0 > y)%R.

Theorem Rgt_sign_pos_neg_rev: forall x y: R, (x > 0 -> 0 > x * y -> 0 > y)%R.

Theorem Rgt_sign_neg_pos_rev: forall x y: R, (0 > x -> 0 > x * y ->  y > 0)%R.

Theorem Rmult_le_compat_l:
  forall n m p : R, (m <= n)%R -> (0 <= p)%R -> (p * m <= p * n)%R.

Theorem Rmult_le_neg_compat_l:
  forall n m p : R, (m <= n)%R -> (p <= 0)%R -> (p * n <= p * m)%R.

Theorem Ropp_lt: forall n m, (m < n -> -n < -m)%R.

Theorem Rmult_lt_neg_compat_l:
  forall n m p : R, (m < n)%R -> (p < 0)%R -> (p * n < p * m)%R.

Theorem Ropp_ge: forall n m, (m >= n -> -n >= -m)%R.

Theorem Rmult_ge_compat_l:
  forall n m p : R, (m >= n)%R -> (p >= 0)%R -> (p * m >= p * n)%R.

Theorem Rmult_ge_neg_compat_l:
  forall n m p : R, (m >= n)%R -> (0 >= p)%R -> (p * n >= p * m)%R.

Theorem Ropp_gt: forall n m, (m > n -> -n > -m)%R.

Theorem Rmult_gt_compat_l:
  forall n m p : R, (n > m)%R -> (p > 0)%R -> (p * n > p * m)%R.

Theorem Rmult_gt_neg_compat_l:
  forall n m p : R, (m > n)%R -> (0 > p)%R -> (p * n > p * m)%R.

Theorem Rmult_le_compat_l_rev:
  forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.

Theorem Rmult_le_neg_compat_l_rev:
  forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.

Theorem Rmult_lt_compat_l_rev:
  forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.

Theorem Rmult_lt_neg_compat_l_rev:
  forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.

Theorem Rmult_ge_compat_l_rev:
  forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.

Theorem Rmult_ge_neg_compat_l_rev:
  forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.

Theorem Rmult_gt_compat_l_rev:
  forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.

Theorem Rmult_gt_neg_compat_l_rev:
  forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.

Theorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).
Theorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).
Theorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).
Theorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).
Theorem eq_Rle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).
Theorem eq_Rle_trans_r : forall x y z, (y = z) -> (x <= y) -> (x <= z).
Theorem eq_Rge_trans_l : forall x y z, (x = z) -> (x >= y) -> (z >= y).
Theorem eq_Rge_trans_r : forall x y z, (y = z) -> (x >= y) -> (x >= z).

Theorem Rge_trans: forall x y z, (x >= z) -> (z >= y) -> (x >= y).

Theorem Z2R_correct: forall p, (Z2R p) = (IZR p).

Theorem Z2R_le: forall p q, (p <= q)%Z -> (Z2R p <= Z2R q)%R.

Theorem Z2R_lt: forall p q, (p < q)%Z -> (Z2R p < Z2R q)%R.

Theorem Z2R_ge: forall p q, (p >= q)%Z -> (Z2R p >= Z2R q)%R.

Theorem Z2R_gt: forall p q, (p > q)%Z -> (Z2R p > Z2R q)%R.

Close Scope R_scope. *)

Require Import PolAuxList.
(* PolAuxList:
Require Import List.
Require Import ZArith.

Section AUXLIST.

 Variable A:Set.
 Variable default:A.

 Definition hd l := match l with hd :: _ => hd | _ => default end. 

 Definition tl (l: list A) := match l with _ :: tl => tl | _ => nil end. 

 Fixpoint jump (p:positive) (l:list A) {struct p} : (list A) :=
  match p with
  | xH => tl l
  | xO p => jump p (jump p l)
  | xI p  => jump p (jump p (tl l))
  end.

 Fixpoint pos_nth (p:positive) (l:list A) {struct p} : A:=
  match p with
  | xH => hd l
  | xO p => pos_nth p (jump p l)
  | xI p => pos_nth p (jump p (tl l))
  end. 

End AUXLIST.

Arguments pos_nth [A] _ _ _.

 Ltac Trev l :=  
  let rec rev_append rev l :=
   match l with
   |  nil  => constr:(rev)
   | (cons ?h ?t) => let rev := constr:(cons h rev) in rev_append rev t 
   end in
 match type of l with
  (list ?X) => rev_append (@nil X) l
 end. *)

Require Import NSignTac.
(* NSignTac:
Require Import NatSignTac.
Require Import NAux.
Require Import NArith.
Require Import List.
Require Export NGroundTac.

Open Scope N_scope.

Theorem Nmult_lt_compat_l: forall n m p, n < m -> 0 < p -> p * n < p * m.

Theorem Nmult_le_compat_l: forall n m p, n <= m -> p * n <= p * m.

Theorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.

Theorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.

Theorem Nmult_lt_compat_rev_l1: forall n m p, p * n < p * m -> 0 < p.

Theorem Nmult_lt_compat_rev_l2: forall n m p, p * n < p * m -> n < m.

Theorem Nmult_gt_compat_rev_l1: forall n m p, p * n > p * m -> p > 0.

Theorem Nmult_gt_compat_rev_l2: forall n m p, p * n > p * m -> n > m.

Theorem Nmult_le_compat_rev_l: forall n m p, p * n <= p * m -> 0 < p -> n <= m.

Theorem Nmult_ge_compat_rev_l: forall n m p , p * n >= p * m -> 0 < p -> n >= m.

Theorem Nlt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.

Theorem Ngt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.

Theorem Nlt_mult_rev_0_l: forall a b, 0 < a * b ->  0 < a .

Theorem Nlt_mult_rev_0_r: forall a b, 0 < a * b ->  0 < b .

Theorem Ngt_mult_rev_0_l: forall a b, a * b > 0 ->  a > 0.

Theorem Ngt_mult_rev_0_r: forall a b, a * b > 0  ->  b > 0 .

Theorem Nle_0_eq_0: forall n, n <= 0 -> n = 0.

Theorem Nge_0_eq_0: forall n, 0 >= n -> n = 0.

Ltac Nsign_tac :=
 repeat (apply Nmult_le_compat_l || apply Nmult_lt_compat_l ||
              apply Nmult_ge_compat_l || apply Nmult_gt_compat_l ||
              apply Nlt_mult_0 || apply Ngt_mult_0); auto.

Ltac hyp_Nsign_tac H :=
  match type of H with
   0 <= _ => clear H
| (?X1 <= 0)%N => generalize (Nle_0_eq_0 _ H); clear H; intros H; subst X1
|  (?X1 * _ <= ?X1 * _)%N => 
             let s1 := fresh "NS" in
                   (assert (s1: 0 < X1); [Nsign_tac; fail |
                   generalize (Nmult_le_compat_rev_l _ _ _ H s1);
                   clear H s1; intros H])
|   (0  < ?X1 * _)%N  => 
              let s1 := fresh "NS" in
                   (generalize (Nlt_mult_rev_0_l _ _ H);
                    generalize (Nlt_mult_rev_0_r _ _ H); clear H;
                    intros H s1; hyp_Nsign_tac s1; hyp_Nsign_tac H)
|  (?X1 < 0)%N => absurd (~ (X1 < 0)%N); auto
| (?X1 * _  < ?X1 * _)%N => 
              let s1 := fresh "NS" in
                   (generalize (Nmult_lt_compat_rev_l1 _ _ _ H);
                    generalize (Nmult_lt_compat_rev_l2 _ _ _ H); clear H;
                    intros H s1; hyp_Nsign_tac s1; hyp_Nsign_tac H)
|  (?X1 >= 0)%N => clear H
| (0 >= ?X1)%N  => generalize (Nge_0_eq_0 _ H); clear H; intros H; subst X1
|  (?X1 * _ >= ?X1 * _)%N => 
             let s1 := fresh "NS" in
                   (assert (s1: (0 < X1)%N); [Nsign_tac; fail |
                   generalize (Nmult_ge_compat_rev_l _ _ _ H s1);
                   clear H s1; intros H])
|  (?X1 * _ > 0 )%N => 
              let s1 := fresh "NS" in
                   (generalize (Ngt_mult_rev_0_l _ _ H);
                    generalize (Ngt_mult_rev_0_r _ _ H); clear H;
                    intros H s1; hyp_Nsign_tac s1; hyp_Nsign_tac H)
|  (0 > ?X1)%N => absurd (~ (0 > X1)%N); auto with arith
| (?X1 * _  > ?X1 * _)%N => 
              let s1 := fresh "NS" in
                   (generalize (Nmult_gt_compat_rev_l1 _ _ _ H);
                    generalize (Nmult_gt_compat_rev_l2 _ _ _ H); clear H;
                    intros H s1; hyp_Nsign_tac s1; hyp_Nsign_tac H)
  |  _ => (let u := type of H in (clear H; assert (H: u); [auto; fail | clear H]) || idtac)
              
   end.

Close Scope N_scope. *)



Definition Zfactor := 

  factor Z Zplus Zmult Z.opp 0%Z 1%Z is_Z1 is_Z0 is_Zpos is_Zdiv Z.div Zgcd.



Definition Zfactor_minus := 

  factor_sub Z Zplus Zmult Z.opp 0%Z 1%Z is_Z1 is_Z0 is_Zpos is_Zdiv Z.div Zgcd.



Definition Zget_delta := 

 get_delta Z Zplus Zmult Z.opp 0%Z 1%Z is_Z1 is_Z0 is_Zpos is_Zdiv Z.div Zgcd.



Ltac

Nfactor_term term1 term2 :=

let term := constr:(Nminus term1 term2) in

let rfv := FV NCst Nplus Nmult Nminus Nopp term (@nil N) in

let fv := Trev rfv in

let expr1 := mkPolexpr Z NCst Nplus Nmult Nminus Nopp term1 fv in

let expr2 := mkPolexpr Z NCst Nplus Nmult Nminus Nopp term2 fv in

let re := eval vm_compute in (Zfactor_minus (PEsub expr1 expr2)) in

let factor := match re with (PEmul ?X1 _) => X1 end in

let expr3 := match re with (PEmul _ (PEsub ?X1 _)) => X1 end in

let expr4 := match re with (PEmul _ (PEsub _ ?X1 )) => X1 end in

let

 re1' :=

  eval

     unfold

      Nconvert_back, convert_back,  pos_nth,  jump, 

         hd,  tl in (Nconvert_back (PEmul factor expr3) fv) in

let re1'' := eval lazy beta in re1' in

let re1''' := clean_zabs_N re1'' in

let

 re2' :=

  eval

     unfold

      Nconvert_back, convert_back,  pos_nth,  jump, 

         hd,  tl in (Nconvert_back (PEmul factor expr4) fv) in

let re2'' := eval lazy beta in re2' in 

let re2''' := clean_zabs_N re2'' in

replace2_tac term1 term2 re1''' re2'''; [idtac| ring | ring].



Ltac Npolf :=

progress (

(try 

match goal with

| |- (?X1 = ?X2)%N =>  Nfactor_term X1 X2 

| |- (?X1 <> ?X2)%N =>  Nfactor_term X1 X2 

| |- N.lt ?X1 ?X2 => Nfactor_term X1 X2

| |- N.gt ?X1 ?X2 =>Nfactor_term X1 X2

| |- N.le ?X1 ?X2 => Nfactor_term X1 X2

| |- N.ge ?X1 ?X2 =>Nfactor_term X1 X2

| _ => fail end)); try (Nsign_tac); try repeat (rewrite Nmult_1_l || rewrite Nmult_1_r).



Ltac hyp_Npolf H := 

progress (

generalize H; 

(try 

match type of H with

  (?X1 = ?X2)%N =>  Nfactor_term X1 X2 

| (?X1 <> ?X2)%N =>  Nfactor_term X1 X2 

| N.lt ?X1 ?X2 => Nfactor_term X1 X2

| N.gt ?X1 ?X2 =>Nfactor_term X1 X2

| N.le ?X1 ?X2 => Nfactor_term X1 X2 

| N.ge ?X1 ?X2 =>Nfactor_term X1 X2

| _ => fail end)); clear H; intros H; try hyp_Nsign_tac H; try repeat rewrite Nmult_1_l in H.

