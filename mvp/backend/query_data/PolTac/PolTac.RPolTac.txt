Require Export RPolS.
(* RPolS:
Require Import Reals.
Require Import PolSBase.
Require Import PolAuxList.
Require Import PolAux.

Definition Rconvert_back (e : PExpr Z) (l : list R) : R :=
   convert_back Z R R0 Rplus Rminus Rmult Ropp Z2R l e.

Definition Rsimpl_minus (e : PExpr Z) :=
    (simpl_minus
      Z Zplus Zmult Z.opp Z0 1%Z is_Z1 is_Z0 is_Zpos is_Zdiv Z.div e).

Definition Rsimpl (e : PExpr Z) :=
    (simpl
      Z Zplus Zmult Z.opp Z0 1%Z is_Z1 is_Z0 is_Zpos is_Zdiv Z.div e).

Ltac
rs term1 term2 :=
let term := constr:(Rminus term1 term2) in
let rfv := FV RCst Rplus Rmult Rminus Ropp term (@nil R) in
let fv := Trev rfv in
let expr1 := mkPolexpr Z RCst Rplus Rmult Rminus Ropp term1 fv in
let expr2 := mkPolexpr Z RCst Rplus Rmult Rminus Ropp term2 fv in
let re := eval vm_compute in (Rsimpl_minus (PEsub expr1 expr2)) in
let expr3 := match re with (PEsub ?X1 _) => X1 end in
let expr4 := match re with (PEsub _ ?X1 ) => X1 end in
let re1 :=  constr:(PEsub expr1 expr3) in
let
 re1' :=
  eval
     unfold
      Rconvert_back, convert_back,  pos_nth,  jump,
         hd,  tl, Z2R, P2R in (Rconvert_back (PEadd re1 expr3) fv) in
let re1'' := eval lazy beta in re1' in
let
 re2' :=
  eval
     unfold
      Rconvert_back, convert_back,  pos_nth,  jump,
         hd,  tl, Z2R, P2R in (Rconvert_back (PEadd re1 expr4) fv) in
let re2'' := eval lazy beta in re2' in
replace2_tac term1 term2 re1'' re2''; [idtac| ring | ring].

Ltac
rpols :=
match goal with
| |- (?X1 = ?X2)%R =>
rs X1 X2; try apply Rplus_eq_compat_l
| |- (?X1 <> ?X2)%R =>
rs X1 X2; apply Rplus_neg_compat_l
| |- Rlt ?X1 ?X2 =>
rs X1 X2; apply Rplus_lt_compat_l
| |- Rgt ?X1 ?X2 =>
rs X1 X2; apply Rplus_gt_compat_l
| |- Rle ?X1 ?X2 =>
rs X1 X2; apply Rplus_le_compat_l
| |- Rge ?X1 ?X2 =>
rs X1 X2; apply Rplus_ge_compat_l
| _ => fail end.

Ltac
hyp_rpols H :=
generalize H;
let tmp := fresh "tmp" in
match (type of H) with
   (?X1 = ?X2)%R =>
rs X1 X2; intros tmp; generalize (Rplus_eq_reg_l _ _ _ tmp); clear H tmp; intro H
|  (?X1 <> ?X2)%nat =>
rs X1 X2; intros tmp; generalize (Rplus_neg_reg_l _ _ _ tmp); clear H tmp; intro H
|  Rlt ?X1 ?X2 =>
rs X1 X2; intros tmp; generalize (Rplus_lt_reg_r _ _ _ tmp); clear H tmp; intro H
|  Rgt ?X1 ?X2 =>
rs X1 X2; intros tmp; generalize (Rplus_gt_reg_l _ _ _ tmp); clear H tmp; intro H
|  Rle ?X1 ?X2 =>
rs X1 X2; intros tmp; generalize (Rplus_le_reg_l _ _ _ tmp); clear H tmp; intro H
|  Rge ?X1 ?X2 =>
rs X1 X2; intros tmp; generalize (Rplus_ge_reg_l _ _ _ tmp); clear H tmp; intro H
| _ => fail end. *)
Require Export Reals.
Require Export RPolF.
(* RPolF:
Require Import ZArith.
Require Import Reals.
Require Import RPolS.
Require Import PolSBase.
Require Import PolFBase.
Require Import PolAux.
Require Import PolAuxList.
Require Import RSignTac.

Definition Rfactor :=
  factor Z Zplus Zmult Z.opp 0%Z 1%Z is_Z1 is_Z0 is_Zpos is_Zdiv Z.div Zgcd.

Definition Rfactor_minus :=
  factor_sub Z Zplus Zmult Z.opp 0%Z 1%Z is_Z1 is_Z0 is_Zpos is_Zdiv Z.div Zgcd.

Ltac Rfactor_term term1 term2 :=
let term := constr:(Rminus term1 term2) in
let rfv := FV RCst Rplus Rmult Rminus Ropp term (@nil R) in
let fv := Trev rfv in
let expr1 := mkPolexpr Z RCst Rplus Rmult Rminus Ropp term1 fv in
let expr2 := mkPolexpr Z RCst Rplus Rmult Rminus Ropp term2 fv in
let re := eval vm_compute in (Rfactor_minus (PEsub expr1 expr2)) in
let factor := match re with (PEmul ?X1 _) => X1 end in
let expr3 := match re with (PEmul _ (PEsub ?X1 _)) => X1 end in
let expr4 := match re with (PEmul _ (PEsub _ ?X1 )) => X1 end in
let
 re1' :=
  eval
     unfold
      Rconvert_back, convert_back,  pos_nth,  jump,
         hd,  tl, Z2R, P2R in (Rconvert_back (PEmul factor expr3) fv) in
let re1'' := eval lazy beta in re1' in
let
 re2' :=
  eval
     unfold
      Rconvert_back, convert_back,  pos_nth,  jump,
         hd,  tl, Z2R, P2R in (Rconvert_back (PEmul factor expr4) fv) in
let re2'' := eval lazy beta in re2' in
replace2_tac term1 term2 re1'' re2''; [idtac| ring | ring].

Ltac rpolf :=
progress (
(try
match goal with
| |- (?X1 = ?X2)%R =>  Rfactor_term X1 X2
| |- (?X1 <> ?X2)%R =>  Rfactor_term X1 X2
| |- Rlt ?X1 ?X2 => Rfactor_term X1 X2
| |- Rgt ?X1 ?X2 =>Rfactor_term X1 X2
| |- Rle ?X1 ?X2 => Rfactor_term X1 X2
| |- Rge ?X1 ?X2 =>Rfactor_term X1 X2
| _ => fail end)); try (rsign_tac); try repeat (rewrite Rmult_1_l || rewrite Rmult_1_r).

Ltac hyp_rpolf H :=
progress (
generalize H;
(try
match type of H with
  (?X1 = ?X2)%R =>  Rfactor_term X1 X2
| (?X1 <> ?X2)%R =>  Rfactor_term X1 X2
| Rlt ?X1 ?X2 => Rfactor_term X1 X2
| Rgt ?X1 ?X2 =>Rfactor_term X1 X2
| Rle ?X1 ?X2 => Rfactor_term X1 X2
| Rge ?X1 ?X2 =>Rfactor_term X1 X2
| _ => fail end)); clear H; intros H; try (hyp_rsign_tac H); try repeat rewrite Rmult_1_l in H. *)
Require Export RPolR.
(* RPolR:
Require Import ZArith.
Require Import Reals.
Require Import PolSBase.
Require Import PolAux.
Require Import PolAuxList.
Require Import RPolS.
Require Import RPolF.
Require Import PolRBase.

Definition Rreplace_term_aux :=
  replace Z Zplus Zmult Z.opp 0%Z 1%Z is_Z1 is_Z0 is_Zpos is_Zdiv Z.div.

Ltac
Rreplace_term term from to occ id :=
let rfv := FV RCst Rplus Rmult Rminus Ropp term (@nil R) in
let rfv1 := FV RCst Rplus Rmult Rminus Ropp from rfv in
let rfv2 := FV RCst Rplus Rmult Rminus Ropp to rfv1 in
let fv := Trev rfv2 in
let expr := mkPolexpr Z RCst Rplus Rmult Rminus Ropp term fv in
let expr_from := mkPolexpr Z RCst Rplus Rmult Rminus Ropp from fv in
let expr_to := mkPolexpr Z RCst Rplus Rmult Rminus Ropp to fv in
let re := eval vm_compute in (Rreplace_term_aux expr expr_from expr_to occ) in
let term1 := eval
     unfold Rconvert_back, convert_back,  pos_nth,  jump,
         hd,  tl, Z2R, P2R in (Rconvert_back re fv) in
match id with
     true => term1
  | false =>
     match eqterm term term1 with
       |false => term1
    end
end
.

Ltac rpol_is_compare term :=
match term with
| (_ < _)%R => constr:(true)
| (_ > _)%R => constr:(true)
| (_ <= _)%R => constr:(true)
| (_ >= _)%R => constr:(true)
| (?X = _)%R => match type of X with R => constr:(true) end
| _ => constr:(false)
end.

Ltac rpol_get_term dir term :=
match term with
|  (?op ?X  ?Y)%R =>
     match dir with P.L => X | P.R => Y end
|  (?X = ?Y)%R =>
     match dir with P.L => X | P.R => Y end
| _ => fail 1 "Unknown term in pol_get_term"
end.

Ltac rpol_replace_term term1 term2 dir1 dir2 occ id :=
  let dir2opp := eval compute in (P.pol_dir_opp dir2) in
  let t1 := rpol_get_term dir2 term2 in
  let t2 := match id with true => t1 | false => rpol_get_term dir2opp term2 end in
 match term1 with
   | (?op ?X ?Y) =>
     match dir1 with
       P.L  =>
             Rreplace_term X t1 t2 occ id
       | P.R =>
            Rreplace_term Y t1 t2 occ id
      end
  | (?X = ?Y)%R  =>
     match dir1 with
       P.L  =>
             Rreplace_term X t1 t2 occ id
     | P.R =>
             Rreplace_term Y  t1 t2 occ id
      end
  end.

Ltac rpol_aux_dir term dir :=
  match term with
   (_ < _)%R => dir
  | (_ > _)%R => dir
  | (_ <= _)%R => eval compute in (P.pol_dir_opp dir)
  | (_ >= _)%R  => eval compute in (P.pol_dir_opp dir)
end.

Ltac R_eq_trans_l t:=
   match goal with
     |  |- (?X >= ?Y)%R => apply eq_Rge_trans_l with t
     |  |- (?X > ?Y)%R => apply eq_Rgt_trans_l with t
     |  |- (?X <= ?Y)%R => apply eq_Rle_trans_l with t
     |  |- (?X < ?Y)%R => apply eq_Rlt_trans_l with t
     |  |- ?G  => apply trans_equal with t
    end.

Ltac R_eq_trans_r t:=
   match goal with
     |  |- (?X >= ?Y)%R => apply eq_Rge_trans_r with t
     |  |- (?X > ?Y)%R => apply eq_Rgt_trans_r with t
     |  |- (?X <= ?Y)%R => apply eq_Rle_trans_r with t
     |  |- (?X < ?Y)%R => apply eq_Rlt_trans_r with t
     |  |- ?G  => apply trans_equal_r with t
    end.

Ltac Rreplace_tac_full term dir1 dir2 occ :=
match term with
 (?T1 = ?T2)%R =>
  
  match goal with
     |-  ?G => let  t := rpol_replace_term G term dir1 dir2 occ false in
              match dir1 with
               P.L => R_eq_trans_l t
              | P.R => R_eq_trans_r t
              end
  end
| _ =>
   match goal with
     |- (?X <= ?Y)%R  =>
            let  t := rpol_replace_term (X <= Y)%R term dir1 dir2 occ false in
               apply Rle_trans with t
     |  |- (?X >= ?Y)%R =>
            let  t := rpol_replace_term (X >= Y)%R term dir1 dir2 occ false in
               apply Rge_trans with t
     | |- (?X < ?Y)%R  =>
           let  t := rpol_replace_term (X < Y)%R term dir1 dir2 occ false in
           match rpol_aux_dir term dir1 with
                P.L =>
                                    (apply Rlt_le_trans with t)
               |P.R =>
                                    (apply Rle_lt_trans with t)
            end
     | |- (?X > ?Y)%R   =>
            let  t := rpol_replace_term (X > Y)%R term dir1 dir2 occ false in
           match rpol_aux_dir term dir1 with
                P.L =>
                                    (apply Rgt_ge_trans with t)
               |P.R =>
                                    (apply Rge_gt_trans with t)
            end
   end
end.

Ltac Rreplace_tac_full_id term dir1 dir2 occ :=
  match goal with
     |-  ?G => let t1 := rpol_replace_term G term dir1 dir2 occ true in
                match dir1 with
                  P.L => R_eq_trans_l t1
               | P.R => R_eq_trans_r t1
                end; [ring | idtac]
end.

Ltac rpolrx term dir1 dir2 occ :=
match rpol_is_compare term with
  true => Rreplace_tac_full_id term dir1 dir2 occ; [Rreplace_tac_full term dir1 dir2 occ]
| false =>
     let t := type of term in
     match rpol_is_compare t with  true =>
       Rreplace_tac_full_id t dir1 dir2 occ; [Rreplace_tac_full t dir1 dir2 occ]
     end
end.

Ltac rpolr term :=
  rpolrx term P.L P.L 1%Z ||
  rpolrx term P.R P.L 1%Z ||
  rpolrx term P.L P.R 1%Z ||
  rpolrx term P.R P.R 1%Z. *)
