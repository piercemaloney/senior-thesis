Require Export NPolS.
(* NPolS:
Require Import PolSBase.
Require Import PolAuxList.
Require Import PolAux.
Require Import NAux.
Require Export ArithRing.

Open Scope nat_scope.

Definition Nconvert_back (e : PExpr Z) (l : list N) : N :=
   convert_back Z N 0%N Nplus Nminus Nmult Nopp Z.abs_N l e.
 
Definition Nsimpl_minus (e : PExpr Z) :=
   simpl_minus
    Z Zplus Zmult Z.opp Z0 1%Z is_Z1 is_Z0 is_Zpos is_Zdiv Z.div e.
 
Definition Nsimpl (e : PExpr Z) :=
   simpl
    Z Zplus Zmult Z.opp Z0 1%Z is_Z1 is_Z0 is_Zpos is_Zdiv Z.div e.

Ltac
Ns term1 term2 :=
let term := constr:(Nminus term1 term2) in
let rfv := FV NCst Nplus Nmult Nminus Nopp term (@nil N) in
let fv := Trev rfv in
let expr1 := mkPolexpr Z NCst Nplus Nmult Nminus Nopp term1 fv in
let expr2 := mkPolexpr Z NCst Nplus Nmult Nminus Nopp term2 fv in
let re := eval vm_compute in (Nsimpl_minus (PEsub expr1 expr2)) in
let expr3 := match re with (PEsub ?X1 _) => X1 end in
let expr4 := match re with (PEsub _ ?X1 ) => X1 end in
let re1 := eval vm_compute in (Nsimpl (PEsub expr1 expr3)) in
let
 re1' :=
  eval
     unfold
      Nconvert_back, convert_back,  PolAuxList.pos_nth,  PolAuxList.jump, 
         PolAuxList.hd,  PolAuxList.tl in (Nconvert_back (PEadd re1 expr3) fv) in
let re1'' := eval lazy beta in re1' in
let re1''' := clean_zabs_N re1'' in
let
 re2' :=
  eval
     unfold
      Nconvert_back, convert_back,  PolAuxList.pos_nth,  PolAuxList.jump, 
         PolAuxList.hd,  PolAuxList.tl in (Nconvert_back (PEadd re1 expr4) fv) in
let re2'' := eval lazy beta in re2' in
let re2''' := clean_zabs_N re2'' in
replace2_tac term1 term2 re1''' re2'''; [idtac | ring | ring].

Ltac
Npols :=
match goal with
| |- (?X1 = ?X2)%N =>
Ns X1 X2; apply Nplus_eq_compat_l
| |- (?X1 <> ?X2)%N =>
Ns X1 X2; apply Nplus_neg_compat_l
| |- (?X1 < ?X2)%N =>
Ns X1 X2; apply Nplus_lt_compat_l
| |- (?X1 > ?X2)%N =>
Ns X1 X2; apply Nplus_gt_compat_l
| |- (?X1 <= ?X2)%N =>
Ns X1 X2; apply Nplus_le_compat_l
| |- (?X1 >= ?X2)%N =>
Ns X1 X2; apply Nplus_ge_compat_l
| _ => fail end.

Ltac
hyp_Npols H :=
generalize H;
let tmp := fresh "tmp" in
match (type of H) with
   (?X1 = ?X2)%N =>
Ns X1 X2; intros tmp; generalize (Nplus_reg_l _ _ _ tmp); clear H tmp; intro H
|  (?X1 <> ?X2)%N =>
Ns X1 X2; intros tmp; generalize (Nplus_neg_reg_l _ _ _ tmp); clear H tmp; intro H
|  (?X1 < ?X2)%N =>
Ns X1 X2; intros tmp; generalize (Nplus_lt_reg_l _ _ _ tmp); clear H tmp; intro H
|  (?X1 > ?X2)%N =>
Ns X1 X2; intros tmp; generalize (Nplus_gt_reg_l _ _ _ tmp); clear H tmp; intro H
|  (?X1 <= ?X2)%N =>
Ns X1 X2; intros tmp; generalize (Nplus_le_reg_l _ _ _ tmp); clear H tmp; intro H
|  (?X1 >= ?X2)%N =>
Ns X1 X2; intros tmp; generalize (Nplus_ge_reg_l _ _ _ tmp); clear H tmp; intro H
| _ => fail end. *)
Require Export NAux.
(* NAux:
Require Export NArith.
Require Import ZArith.

Open Scope N_scope.

Theorem Nle_le: forall n  m, (N.to_nat n <= N.to_nat m)%nat -> n <= m.

Theorem le_Nle: forall n m, N.of_nat n <= N.of_nat m -> (n <= m)%nat.

Theorem Nle_le_rev: forall n  m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.

Theorem Nlt_lt: forall n  m, (N.to_nat n < N.to_nat m)%nat -> n < m.

Theorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.

Theorem Nlt_lt_rev: forall n  m, n < m -> (N.to_nat n < N.to_nat m)%nat.

Theorem Nge_ge: forall n  m, (N.to_nat n >= N.to_nat m)%nat -> n >= m.

Theorem ge_Nge: forall n m, N.of_nat n >= N.of_nat m -> (n >= m)%nat.

Theorem Nge_ge_rev: forall n  m, n >= m -> (N.to_nat n >= N.to_nat m)%nat.

Theorem Ngt_gt: forall n  m, (N.to_nat n > N.to_nat m)%nat -> n > m.

Theorem gt_Ngt: forall n m, N.of_nat n > N.of_nat m -> (n > m)%nat.

Theorem Ngt_gt_rev: forall n  m, n > m -> (N.to_nat n > N.to_nat m)%nat.

Theorem Neq_eq_rev: forall n  m, n = m -> (N.to_nat n = N.to_nat m)%nat.

Import BinPos.

Ltac to_nat_op  :=
  match goal with
      H: (N.lt _ _) |- _ => generalize (Nlt_lt_rev _ _ H); clear H; intros H
|     H: (N.gt _ _) |- _ => generalize (Ngt_gt_rev _ _ H); clear H; intros H
|     H: (N.le _ _) |- _ => generalize (Nle_le_rev _ _ H); clear H; intros H
|     H: (N.ge _ _) |- _ => generalize (Nge_ge_rev _ _ H); clear H; intros H
|     H: (@eq N _ _) |- _ => generalize (Neq_eq_rev _ _ H); clear H; intros H
|      |- (N.lt _ _)  => apply Nlt_lt
|      |- (N.le _ _)  => apply Nle_le
|      |- (N.gt _ _)  => apply Ngt_gt
|      |- (N.ge _ _)  => apply Nge_ge
|      |- (@eq N _ _)  => apply Nat2N.inj
end.

Ltac set_to_nat :=
let nn := fresh "nn" in
match goal with
       |- context [(N.to_nat (?X + ?Y)%N)]  => rewrite N2Nat.inj_add
|      |- context [(N.to_nat (?X * ?Y)%N)]  => rewrite N2Nat.inj_mul
|      |- context [(N.to_nat ?X)]  => set (nn:=N.to_nat X) in * |- *
|      H: context [(N.to_nat (?X + ?Y)%N)] |- _ => rewrite N2Nat.inj_add in H
|      H: context [(N.to_nat (?X + ?Y)%N)] |- _ => rewrite N2Nat.inj_mul in H
|      H: context [(N.to_nat ?X)] |- _ => set (nn:=N.to_nat X) in * |- *
end.

Ltac to_nat := repeat to_nat_op; repeat set_to_nat.

Theorem Nle_gt_trans: forall n m p, m <= n -> m > p -> n > p.

Theorem Ngt_le_trans: forall n m p, n > m -> p <= m -> n > p.

Theorem Nle_add_l :
  forall x y, x <= y + x.

Close Scope N_scope. *)
Require Export NArithRing.
Require Export NPolF.
(* NPolF:
Require Import ZArith.
Require Import NAux.
Require Import NPolS.
Require Import PolSBase.
Require Import PolFBase.
Require Import PolAux.
Require Import PolAuxList.
Require Import NSignTac.

Definition Zfactor := 
  factor Z Zplus Zmult Z.opp 0%Z 1%Z is_Z1 is_Z0 is_Zpos is_Zdiv Z.div Zgcd.

Definition Zfactor_minus := 
  factor_sub Z Zplus Zmult Z.opp 0%Z 1%Z is_Z1 is_Z0 is_Zpos is_Zdiv Z.div Zgcd.

Definition Zget_delta := 
 get_delta Z Zplus Zmult Z.opp 0%Z 1%Z is_Z1 is_Z0 is_Zpos is_Zdiv Z.div Zgcd.

Ltac
Nfactor_term term1 term2 :=
let term := constr:(Nminus term1 term2) in
let rfv := FV NCst Nplus Nmult Nminus Nopp term (@nil N) in
let fv := Trev rfv in
let expr1 := mkPolexpr Z NCst Nplus Nmult Nminus Nopp term1 fv in
let expr2 := mkPolexpr Z NCst Nplus Nmult Nminus Nopp term2 fv in
let re := eval vm_compute in (Zfactor_minus (PEsub expr1 expr2)) in
let factor := match re with (PEmul ?X1 _) => X1 end in
let expr3 := match re with (PEmul _ (PEsub ?X1 _)) => X1 end in
let expr4 := match re with (PEmul _ (PEsub _ ?X1 )) => X1 end in
let
 re1' :=
  eval
     unfold
      Nconvert_back, convert_back,  pos_nth,  jump, 
         hd,  tl in (Nconvert_back (PEmul factor expr3) fv) in
let re1'' := eval lazy beta in re1' in
let re1''' := clean_zabs_N re1'' in
let
 re2' :=
  eval
     unfold
      Nconvert_back, convert_back,  pos_nth,  jump, 
         hd,  tl in (Nconvert_back (PEmul factor expr4) fv) in
let re2'' := eval lazy beta in re2' in 
let re2''' := clean_zabs_N re2'' in
replace2_tac term1 term2 re1''' re2'''; [idtac| ring | ring].

Ltac Npolf :=
progress (
(try 
match goal with
| |- (?X1 = ?X2)%N =>  Nfactor_term X1 X2 
| |- (?X1 <> ?X2)%N =>  Nfactor_term X1 X2 
| |- N.lt ?X1 ?X2 => Nfactor_term X1 X2
| |- N.gt ?X1 ?X2 =>Nfactor_term X1 X2
| |- N.le ?X1 ?X2 => Nfactor_term X1 X2
| |- N.ge ?X1 ?X2 =>Nfactor_term X1 X2
| _ => fail end)); try (Nsign_tac); try repeat (rewrite Nmult_1_l || rewrite Nmult_1_r).

Ltac hyp_Npolf H := 
progress (
generalize H; 
(try 
match type of H with
  (?X1 = ?X2)%N =>  Nfactor_term X1 X2 
| (?X1 <> ?X2)%N =>  Nfactor_term X1 X2 
| N.lt ?X1 ?X2 => Nfactor_term X1 X2
| N.gt ?X1 ?X2 =>Nfactor_term X1 X2
| N.le ?X1 ?X2 => Nfactor_term X1 X2 
| N.ge ?X1 ?X2 =>Nfactor_term X1 X2
| _ => fail end)); clear H; intros H; try hyp_Nsign_tac H; try repeat rewrite Nmult_1_l in H. *)
Require Export NPolR.
(* NPolR:
Require Import ZArith.
Require Import NAux.
Require Import PolSBase.
Require Import PolAux.
Require Import PolAuxList.
Require Import NPolS.
Require Import NPolF.
Require Import PolRBase.
 
Definition Nreplace_term_aux :=
  replace Z Zplus Zmult Z.opp 0%Z 1%Z is_Z1 is_Z0 is_Zpos is_Zdiv Z.div.

Ltac
Nreplace_term term from to occ id :=
let rfv := FV NCst Nplus Nmult Nminus Nopp term (@nil N) in
let rfv1 := FV NCst Nplus Nmult Nminus Nopp from rfv in
let rfv2 := FV NCst Nplus Nmult Nminus Nopp to rfv1 in
let fv := Trev rfv2 in
let expr := mkPolexpr Z NCst Nplus Nmult Nminus Nopp term fv in
let expr_from := mkPolexpr Z NCst Nplus Nmult Nminus Nopp from fv in
let expr_to := mkPolexpr Z NCst Nplus Nmult Nminus Nopp to fv in
let re := eval vm_compute in (Nreplace_term_aux expr expr_from expr_to occ) in
let term1 := eval
     unfold Nconvert_back, convert_back,  pos_nth,  jump,
         hd,  tl in (Nconvert_back re fv) in
let term2 := clean_zabs_N term1 in
match id with 
     true => term2
  | false =>
     match eqterm term term1 with
       |false => term2
    end
end
.

Ltac Npol_is_compare term :=
match term with
| (_ < _)%N => constr:(true)
| (_ > _)%N => constr:(true)
| (_ <= _)%N => constr:(true)
| (_ >= _)%N => constr:(true)
| (?X = _)%N => match type of X with N => constr:(true) end
| _ => constr:(false)
end.

Ltac Npol_get_term dir term :=
match term with
|  (?op ?X  ?Y)%N =>
     match dir with P.L => X | P.R => Y end
|  (?X = ?Y)%N =>
     match dir with P.L => X | P.R => Y end
| _ => fail 1 "Unknown term in Npol_get_term"
end.

Ltac Npol_replace_term term1 term2 dir1 dir2 occ id := 
  let dir2opp := eval compute in (P.pol_dir_opp dir2) in
  let t1 := Npol_get_term dir2 term2 in
  let t2 := match id with true => t1 | false =>  Npol_get_term dir2opp term2 end in
 match term1 with
   | (?op ?X ?Y) =>
     match dir1 with
       P.L  =>
             Nreplace_term X t1 t2 occ id
       | P.R => 
            Nreplace_term Y t1 t2 occ id
      end
  | (?X = ?Y)%N  =>
     match dir1 with
       P.L  =>
             Nreplace_term X t1 t2 occ id
     | P.R => 
             Nreplace_term Y  t1 t2 occ id
      end
  end.

Ltac Npol_aux_dir term dir :=
  match term with
   (_ < _)%N => dir
  | (_ > _)%N => dir
  | (_ <= _)%N => eval compute in (P.pol_dir_opp dir) 
  | (_ >= _)%N => eval compute in (P.pol_dir_opp dir) 
end.

Ltac Nreplace_tac_full term dir1 dir2 occ :=
match term with
 (?T1 = ?T2)%N =>
  
  match goal with
     |-  ?G => let  t := Npol_replace_term G term dir1 dir2 occ false in
              match dir1 with
               P.L =>
                      apply trans_equal with t ||
                      apply Neq_lt_trans_l with t || apply Neq_gt_trans_l with t ||
                       apply Neq_le_trans_l with t || apply Neq_ge_trans_l with t
              | P.R =>
                     apply trans_equal_r with t ||
                       apply Neq_lt_trans_r with t || apply Neq_gt_trans_r with t ||
                       apply Neq_le_trans_r with t || apply Neq_ge_trans_r with t
              end
  end
| _ =>
   match goal with
     |- (?X <= ?Y)%N  =>
            let  t := Npol_replace_term (X <= Y)%N term dir1 dir2 occ false in
               apply N.le_trans with t
     |  |- (?X >= ?Y)%N =>
            let  t := Npol_replace_term (X >= Y)%N term dir1 dir2 occ false in
               apply Nge_trans with t
     | |- ?G  =>
            let  t := Npol_replace_term G term dir1 dir2 occ false in
           match Npol_aux_dir term dir1 with
                P.L =>
                                    (apply N.lt_le_trans with t || apply Ngt_le_trans with t)
               |P.R =>
                                    (apply N.le_lt_trans with t || apply Nle_gt_trans with t)
            end
   end
end.

Ltac Nreplace_tac_full_id term dir1 dir2 occ :=
  match goal with
     |-  ?G => let t1 := Npol_replace_term G term dir1 dir2 occ true in 
                match dir1 with
                  P.L =>
                       apply trans_equal with t1 ||
                       apply Neq_lt_trans_l with t1 ||
                       apply Neq_gt_trans_l with t1 ||
                       apply Neq_le_trans_l with t1 ||
                       apply Neq_ge_trans_l with t1
               | P.R =>
                      apply trans_equal_r with t1 ||
                      apply Neq_lt_trans_r with t1 ||
                      apply Neq_gt_trans_r with t1  ||
                      apply Neq_le_trans_r with t1 ||
                      apply Neq_ge_trans_r with t1
                end; [ring | idtac]
end.

Ltac Npolrx term dir1 dir2 occ :=
match Npol_is_compare term with
  true => Nreplace_tac_full_id term dir1 dir2 occ; [Nreplace_tac_full term dir1 dir2 occ] 
| false => 
     let t := type of term in
     match Npol_is_compare t with true => 
        Nreplace_tac_full_id t dir1 dir2 occ; [Nreplace_tac_full t dir1 dir2 occ]
     end 
end.

Ltac Npolr term :=
  Npolrx term P.L P.L 1%Z  ||
  Npolrx term P.R P.L 1%Z ||
  Npolrx term P.L P.R 1%Z ||
  Npolrx term P.R P.R 1%Z. *)
