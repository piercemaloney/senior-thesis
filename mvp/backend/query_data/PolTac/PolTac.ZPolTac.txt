Require Export ZPolS.
(* ZPolS:
Require Import PolSBase.
Require Import PolAuxList.
Require Import PolAux.

Definition Zconvert_back (e : PExpr Z) (l : list Z) : Z :=
   convert_back Z Z Z0 Zplus Zminus Zmult Z.opp (fun (x : Z) => x) l e.

Definition Zsimpl (e : PExpr Z)  :=
   simpl
      Z Zplus Zmult Z.opp Z0 1%Z is_Z1 is_Z0 is_Zpos is_Zdiv Z.div e. 

Definition Zsimpl_minus (e : PExpr Z) :=
   simpl_minus
    Z Zplus Zmult Z.opp Z0 1%Z is_Z1 is_Z0 is_Zpos is_Zdiv Z.div e. 

Ltac
zs term1 term2 :=
let term := constr:(Zminus term1 term2) in
let rfv := FV ZCst Zplus Zmult Zminus Z.opp term (@nil Z) in
let fv := Trev rfv in
let expr1 := mkPolexpr Z ZCst Zplus Zmult Zminus Z.opp term1 fv in
let expr2 := mkPolexpr Z ZCst Zplus Zmult Zminus Z.opp term2 fv in
let re := eval vm_compute in (Zsimpl_minus (PEsub expr1 expr2)) in
let expr3 := match re with (PEsub ?X1 _) => X1 end in
let expr4 := match re with (PEsub _ ?X1 ) => X1 end in
let re1 := eval vm_compute in (Zsimpl (PEsub expr1 expr3)) in
let
 re1' :=
  eval
     unfold
      Zconvert_back, convert_back,  pos_nth,  jump, 
         hd,  tl in (Zconvert_back (PEadd re1 expr3) fv) in
let re1'' := eval lazy beta in re1' in
let
 re2' :=
  eval
     unfold
      Zconvert_back, convert_back,  pos_nth,  jump, 
         hd,  tl in (Zconvert_back (PEadd re1 expr4) fv) in
let re2'' := eval lazy beta in re2' in 
replace2_tac term1 term2 re1'' re2''; [idtac | ring | ring].

Ltac
zpols :=
match goal with
| |- (?X1 = ?X2)%Z =>
zs X1 X2; apply Zplus_eq_compat_l
| |- (?X1 <> ?X2)%Z =>
zs X1 X2; apply Zplus_neg_compat_l
| |- Z.lt ?X1 ?X2 =>
zs X1 X2; apply Zplus_lt_compat_l
| |- Z.gt ?X1 ?X2 =>
zs X1 X2; apply Zplus_gt_compat_l
| |- Z.le ?X1 ?X2 =>
zs X1 X2; apply Zplus_le_compat_l
| |- Z.ge ?X1 ?X2 =>
zs X1 X2; apply Zplus_ge_compat_l
| _ => fail end.

Ltac
hyp_zpols H :=
generalize H;
let tmp := fresh "tmp" in
match (type of H) with
   (?X1 = ?X2)%Z =>
zs X1 X2; intros tmp; generalize (Zplus_reg_l _ _ _ tmp); clear H tmp; intro H
|  (?X1 <> ?X2)%nat =>
zs X1 X2; intros tmp; generalize (Zplus_neg_reg_l _ _ _ tmp); clear H tmp; intro H
|  Z.lt ?X1 ?X2 =>
zs X1 X2; intros tmp; generalize (Zplus_lt_reg_l _ _ _ tmp); clear H tmp; intro H
|  Z.gt ?X1 ?X2 =>
zs X1 X2; intros tmp; generalize (Zplus_gt_reg_l _ _ _ tmp); clear H tmp; intro H
|  Z.le ?X1 ?X2 =>
zs X1 X2; intros tmp; generalize (Zplus_le_reg_l _ _ _ tmp); clear H tmp; intro H
|  Z.ge ?X1 ?X2 =>
zs X1 X2; intros tmp; generalize (Zplus_ge_reg_l _ _ _ tmp); clear H tmp; intro H
| _ => fail end. *)
Require Export ZArith.
Require Export ZPolF.
(* ZPolF:
Require Import ZArith.
Require Import ZPolS.
Require Import PolSBase.
Require Import PolFBase.
Require Import PolAux.
Require Import PolAuxList.
Require Import ZSignTac.

Definition Zfactor := 
  factor Z Zplus Zmult Z.opp 0%Z 1%Z is_Z1 is_Z0 is_Zpos is_Zdiv Z.div Zgcd.

Definition Zfactor_minus := 
  factor_sub Z Zplus Zmult Z.opp 0%Z 1%Z is_Z1 is_Z0 is_Zpos is_Zdiv Z.div Zgcd.

Definition Zget_delta := 
 get_delta Z Zplus Zmult Z.opp 0%Z 1%Z is_Z1 is_Z0 is_Zpos is_Zdiv Z.div Zgcd.

Ltac
Zfactor_term term1 term2 :=
let term := constr:(Zminus term1 term2) in
let rfv := FV ZCst Zplus Zmult Zminus Z.opp term (@nil Z) in
let fv := Trev rfv in
let expr1 := mkPolexpr Z ZCst Zplus Zmult Zminus Z.opp term1 fv in
let expr2 := mkPolexpr Z ZCst Zplus Zmult Zminus Z.opp term2 fv in
let re := eval vm_compute in (Zfactor_minus (PEsub expr1 expr2)) in
let factor := match re with (PEmul ?X1 _) => X1 end in
let expr3 := match re with (PEmul _ (PEsub ?X1 _)) => X1 end in
let expr4 := match re with (PEmul _ (PEsub _ ?X1 )) => X1 end in
let
 re1' :=
  eval
     unfold
      Zconvert_back, convert_back,  pos_nth,  jump, 
         hd,  tl in (Zconvert_back (PEmul factor expr3) fv) in
let re1'' := eval lazy beta in re1' in
let
 re2' :=
  eval
     unfold
      Zconvert_back, convert_back,  pos_nth,  jump, 
         hd,  tl in (Zconvert_back (PEmul factor expr4) fv) in
let re2'' := eval lazy beta in re2' in 
replace2_tac term1 term2 re1'' re2''; [idtac| ring | ring].

Ltac zpolf :=
 (
(try 
match goal with
| |- (?X1 = ?X2)%Z =>  Zfactor_term X1 X2 
| |- (?X1 <> ?X2)%Z =>  Zfactor_term X1 X2 
| |- Z.lt ?X1 ?X2 => Zfactor_term X1 X2
| |- Z.gt ?X1 ?X2 =>Zfactor_term X1 X2
| |- Z.le ?X1 ?X2 => Zfactor_term X1 X2
| |- Z.ge ?X1 ?X2 =>Zfactor_term X1 X2
| _ => fail end));  try (zsign_tac); try repeat (rewrite Zmult_1_l || rewrite Zmult_1_r).

Ltac hyp_zpolf H := 
progress (
generalize H; 
(try 
match type of H with
  (?X1 = ?X2)%Z =>  Zfactor_term X1 X2 
| (?X1 <> ?X2)%Z =>  Zfactor_term X1 X2 
| Z.lt ?X1 ?X2 => Zfactor_term X1 X2
| Z.gt ?X1 ?X2 =>Zfactor_term X1 X2
| Z.le ?X1 ?X2 => Zfactor_term X1 X2 
| Z.ge ?X1 ?X2 =>Zfactor_term X1 X2
| _ => fail end)); clear H; intros H; try hyp_zsign_tac H; try repeat rewrite Zmult_1_l. *)
Require Export ZPolR.
(* ZPolR:
Require Import ZArith.
Require Import PolSBase.
Require Import PolAux.
Require Import PolAuxList.
Require Import ZPolS.
Require Import ZPolF.
Require Import PolRBase.

Definition Zreplace_term_aux :=
  replace Z Zplus Zmult Z.opp 0%Z 1%Z is_Z1 is_Z0 is_Zpos is_Zdiv Z.div.

Ltac
Zreplace_term term from to occ id :=
let rfv := FV ZCst Zplus Zmult Zminus Z.opp term (@nil Z) in
let rfv1 := FV ZCst Zplus Zmult Zminus Z.opp from rfv in
let rfv2 := FV ZCst Zplus Zmult Zminus Z.opp to rfv1 in
let fv := Trev rfv2 in
let expr := mkPolexpr Z ZCst Zplus Zmult Zminus Z.opp term fv in
let expr_from := mkPolexpr Z ZCst Zplus Zmult Zminus Z.opp from fv in
let expr_to := mkPolexpr Z ZCst Zplus Zmult Zminus Z.opp to fv in
let re := eval vm_compute in (Zreplace_term_aux expr expr_from expr_to occ) in
let term1 := eval
     unfold Zconvert_back, convert_back,  pos_nth,  jump,
         hd,  tl in (Zconvert_back re fv) in
match id with 
     true => term1
  | false =>
     match eqterm term term1 with
       |false => term1
    end
end
.

Ltac zpol_is_compare term :=
match term with
| (_ < _)%Z => constr:(true)
| (_ > _)%Z => constr:(true)
| (_ <= _)%Z => constr:(true)
| (_ >= _)%Z => constr:(true)
| (?X = _)%Z => match type of X with Z => constr:(true) end 
| _ => constr:(false)
end.

Ltac zpol_get_term dir term :=
match term with
|  (?op ?X  ?Y)%Z =>
     match dir with P.L => X | P.R => Y end
|  (?X = ?Y)%Z =>
     match dir with P.L => X | P.R => Y end
| _ => fail 1 "Unknown term in zpolget_term"
end.

Ltac zpol_replace_term term1 term2 dir1 dir2 occ id := 
  let dir2opp := eval vm_compute in (P.pol_dir_opp dir2) in
  let t1 := zpol_get_term dir2 term2 in
  let t2 := match id with true => t1 | false => zpol_get_term dir2opp term2 end in
  match term1 with
   | (?op ?X ?Y) =>
     match dir1 with
         P.L  =>
             Zreplace_term X t1 t2 occ id
       | P.R => 
            Zreplace_term Y t1 t2 occ id
      end
  | (?X = ?Y)%Z  =>
     match dir1 with
       P.L  =>
             Zreplace_term X t1 t2 occ id
     | P.R => 
             Zreplace_term Y  t1 t2 occ id
      end
  end.

Ltac zpol_aux_dir term dir :=
  match term with
   (_ < _)%Z => dir
  | (_ > _)%Z => dir
  | (_ <= _)%Z => eval compute in (P.pol_dir_opp dir) 
  | (_ >= _)%Z  => eval compute in (P.pol_dir_opp dir) 
end.

Ltac Zreplace_tac_full term dir1 dir2 occ :=
match term with
 (?T1 = ?T2)%Z =>
  
  match goal with
     |-  ?G => let  t := zpol_replace_term G term dir1 dir2 occ false in
              match dir1 with
               P.L =>
                      apply trans_equal with t ||
                      apply eq_Zlt_trans_l with t || apply eq_Zgt_trans_l with t ||
                       apply eq_Zle_trans_l with t || apply eq_Zge_trans_l with t
              | P.R =>
                     apply trans_equal_r with t ||
                       apply eq_Zlt_trans_r with t || apply eq_Zgt_trans_r with t ||
                       apply eq_Zle_trans_r with t || apply eq_Zge_trans_r with t
              end
  end
| _ =>
   match goal with
     |- (?X <= ?Y)%Z  =>
            let  t := zpol_replace_term (X <= Y)%Z term dir1 dir2 occ false in
               apply Z.le_trans with t
     |  |- (?X >= ?Y)%Z =>
            let  t := zpol_replace_term (X >= Y)%Z term dir1 dir2 occ false in
               apply Zge_trans with t
     | |- ?G  =>
            let  t := zpol_replace_term G term dir1 dir2 occ false in
           match zpol_aux_dir term dir1 with
                P.L =>
                                    (apply Z.lt_le_trans with t || apply Zgt_le_trans with t)
               |P.R =>
                                    (apply Z.le_lt_trans with t || apply Zle_gt_trans with t)
            end
   end
end.

Ltac Zreplace_tac_full_id term dir1 dir2 occ :=
  match goal with
     |-  ?G => let t1 := zpol_replace_term G term dir1 dir2 occ true in 
                match dir1 with
                  P.L =>
                       apply trans_equal with t1 ||
                       apply eq_Zlt_trans_l with t1 ||
                       apply eq_Zgt_trans_l with t1 ||
                       apply eq_Zle_trans_l with t1 ||
                       apply eq_Zge_trans_l with t1
               | P.R =>
                      apply trans_equal_r with t1 ||
                      apply eq_Zlt_trans_r with t1 ||
                      apply eq_Zgt_trans_r with t1  ||
                      apply eq_Zle_trans_r with t1 ||
                      apply eq_Zge_trans_r with t1
                end; [ring | idtac]
end.

Ltac zpolrx term dir1 dir2 occ :=
match zpol_is_compare term with
  true => Zreplace_tac_full_id term dir1 dir2 occ; 
                [Zreplace_tac_full term dir1 dir2 occ] 
| false => 
     let t := type of term in
     match zpol_is_compare t with true => Zreplace_tac_full_id t dir1 dir2 occ;
                                                                       [Zreplace_tac_full t dir1 dir2 occ]
     end 
end.

Ltac zpolr term :=
  zpolrx term P.L P.L 1%Z ||
  zpolrx term P.R P.L 1%Z ||
  zpolrx term P.L P.R 1%Z ||
  zpolrx term P.R P.R 1%Z. *)
