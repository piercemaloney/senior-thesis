Require Import RSignTac.
(* RSignTac:
Require Import Reals.
Require Import RPolS.
Require Import List.
Require Import Replace2.
Require Export RGroundTac.

Theorem Rle_sign_pos_pos: forall x y, (0 <= x -> 0 <= y  -> 0 <= x * y)%R.

Theorem Rle_sign_neg_neg: forall x y, (x <= 0 -> y <= 0  -> 0 <= x * y)%R.

Theorem Rle_pos_neg: forall x, (0 <= -x -> x <= 0)%R.

Theorem Rle_sign_pos_neg: forall x y: R, (0 <= x -> y <= 0  -> x * y <= 0)%R.

Theorem Rle_sign_neg_pos: forall x y, (x <= 0 -> 0 <= y  -> x * y <= 0)%R.

Theorem Rlt_sign_pos_pos: forall x y, (0 < x -> 0 < y  -> 0 < x * y)%R.

Theorem Rlt_sign_neg_neg: forall x y, (x < 0 -> y < 0  -> 0 < x * y)%R.

Theorem Rlt_pos_neg: forall x, (0 < -x -> x < 0)%R.

Theorem Rlt_sign_pos_neg: forall x y, (0 < x -> y < 0  -> x * y < 0)%R.

Theorem Rlt_sign_neg_pos: forall x y, (x < 0 -> 0 < y  -> x * y < 0)%R.

Theorem Rge_sign_neg_neg: forall x y, (0 >= x -> 0 >= y  -> x * y >= 0)%R.

Theorem Rge_sign_pos_pos: forall x y, (x >= 0 -> y >= 0  -> x * y >= 0)%R.

Theorem Rge_neg_pos: forall x, (0 >= -x -> x >= 0)%R.

Theorem Rge_sign_neg_pos: forall x y: R, (0 >= x -> y >= 0  -> 0>= x * y)%R.

Theorem Rge_sign_pos_neg: forall x y, (x >= 0 -> 0 >= y  -> 0 >= x * y)%R.

Theorem Rgt_sign_neg_neg: forall x y, (0 > x -> 0 > y  -> x * y > 0)%R.

Theorem Rgt_sign_pos_pos: forall x y, (x > 0 -> y > 0  -> x * y > 0)%R.

Theorem Rgt_neg_pos: forall x, (0 > -x -> x > 0)%R.

Theorem Rgt_sign_neg_pos: forall x y, (0 > x -> y > 0  -> 0> x * y)%R.

Theorem Rgt_sign_pos_neg: forall x y, (x > 0 -> 0 > y  -> 0 > x * y)%R.

Theorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.

Theorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y ->  y <= 0)%R.

Theorem Rle_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y <= 0 -> y <= 0)%R.

Theorem Rle_sign_neg_pos_rev: forall x y: R, (x < 0 -> x * y <= 0 ->  0 <= y)%R.

Theorem Rge_sign_pos_pos_rev: forall x y: R, (x > 0 -> x * y >= 0 -> y >= 0)%R.

Theorem Rge_sign_neg_neg_rev: forall x y: R, (0 > x -> x * y  >= 0->  0 >= y)%R.

Theorem Rge_sign_pos_neg_rev: forall x y: R, (x > 0 -> 0 >= x * y -> 0 >= y)%R.

Theorem Rge_sign_neg_pos_rev: forall x y: R, (0 > x -> 0 >= x * y ->  y >= 0)%R.

Theorem Rlt_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 < x * y -> 0 < y)%R.

Theorem Rlt_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 < x * y ->  y < 0)%R.

Theorem Rlt_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y < 0 -> y < 0)%R.

Theorem Rlt_sign_neg_pos_rev: forall x y: R, (x < 0 -> x * y < 0 ->  0 < y)%R.

Theorem Rgt_sign_pos_pos_rev: forall x y: R, (x > 0 -> x * y > 0 -> y > 0)%R.

Theorem Rgt_sign_neg_neg_rev: forall x y: R, (0 > x -> x * y  > 0->  0 > y)%R.

Theorem Rgt_sign_pos_neg_rev: forall x y: R, (x > 0 -> 0 > x * y -> 0 > y)%R.

Theorem Rgt_sign_neg_pos_rev: forall x y: R, (0 > x -> 0 > x * y ->  y > 0)%R.

Theorem Rmult_le_compat_l:
  forall n m p : R, (m <= n)%R -> (0 <= p)%R -> (p * m <= p * n)%R.

Theorem Rmult_le_neg_compat_l:
  forall n m p : R, (m <= n)%R -> (p <= 0)%R -> (p * n <= p * m)%R.

Theorem Ropp_lt: forall n m, (m < n -> -n < -m)%R.

Theorem Rmult_lt_neg_compat_l:
  forall n m p : R, (m < n)%R -> (p < 0)%R -> (p * n < p * m)%R.

Theorem Ropp_ge: forall n m, (m >= n -> -n >= -m)%R.

Theorem Rmult_ge_compat_l:
  forall n m p : R, (m >= n)%R -> (p >= 0)%R -> (p * m >= p * n)%R.

Theorem Rmult_ge_neg_compat_l:
  forall n m p : R, (m >= n)%R -> (0 >= p)%R -> (p * n >= p * m)%R.

Theorem Ropp_gt: forall n m, (m > n -> -n > -m)%R.

Theorem Rmult_gt_compat_l:
  forall n m p : R, (n > m)%R -> (p > 0)%R -> (p * n > p * m)%R.

Theorem Rmult_gt_neg_compat_l:
  forall n m p : R, (m > n)%R -> (0 > p)%R -> (p * n > p * m)%R.

Theorem Rmult_le_compat_l_rev:
  forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.

Theorem Rmult_le_neg_compat_l_rev:
  forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.

Theorem Rmult_lt_compat_l_rev:
  forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.

Theorem Rmult_lt_neg_compat_l_rev:
  forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.

Theorem Rmult_ge_compat_l_rev:
  forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.

Theorem Rmult_ge_neg_compat_l_rev:
  forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.

Theorem Rmult_gt_compat_l_rev:
  forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.

Theorem Rmult_gt_neg_compat_l_rev:
  forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.

Definition Rsign_type := fun (x y:list R) => Prop.

Definition Rsign_cons : forall x y, (Rsign_type  x y) := fun x y => True.

Ltac Rsign_push term1 term2 := generalize (Rsign_cons term1 term2); intro.

Ltac Rsign_le term :=
  match term with 
    (?X1 * ?X2)%R =>  Rsign_le X1;
                             match goal with 
                             H1: (Rsign_type ?s1 ?s2) |- _ =>
                                    Rsign_le X2;
                                   match goal with 
                                      H2: (Rsign_type ?s3 ?s4) |- _ => clear H1 H2;
                                              let s5 := eval unfold List.app in (s1++s3) in
                                              let s6 := eval unfold List.app in (s2++s4) in
                                               Rsign_push s5 s6
                                   end
                              end
| _ =>  let H1 := fresh "H" in
    (((assert (H1: (0 <= term)%R); [auto with real; fail | idtac])
      ||
     (assert (H1: (term <= 0)%R); [auto with real; fail | idtac])); clear H1;
         Rsign_push (term::nil) (@nil R)) || Rsign_push (@nil R) (term::nil)
end.

Ltac Rsign_lt term :=
  match term with 
    (?X1 * ?X2)%R =>  Rsign_lt X1;
                             match goal with 
                             H1: (Rsign_type ?s1 ?s2) |- _ =>
                                    Rsign_lt X2;
                                   match goal with 
                                      H2: (Rsign_type ?s3 ?s4) |- _ => clear H1 H2;
                                              let s5 := eval unfold List.app in (s1++s3) in
                                              let s6 := eval unfold List.app in (s2++s4) in
                                               Rsign_push s5 s6
                                   end
                              end
| _ =>  let H1 := fresh "H" in
    (((assert (H1: (0 < term)%R); [auto with real; fail | idtac])
      ||
     (assert (H1: (term < 0)%R); [auto with real; fail | idtac])); clear H1;
         Rsign_push (term::nil) (@nil R)) || Rsign_push (@nil R) (term::nil)
end.

Ltac Rsign_top0 :=
  match goal with
  |- (0 <= ?X1)%R => Rsign_le  X1
| |- (?X1 <= 0)%R => Rsign_le  X1
| |- (0 < ?X1)%R => Rsign_lt  X1
| |- (?X1 < 0)%R => Rsign_le  X1
| |- (0 >= ?X1)%R => Rsign_le  X1
| |- (?X1 >= 0)%R => Rsign_le  X1
| |- (0 > ?X1 )%R => Rsign_lt X1
| |- (?X1 > 0)%R => Rsign_le  X1
  end.

Ltac Rsign_top :=
  match goal with
| |- (?X1 * _ <= ?X1 * _)%R => Rsign_le  X1
| |- (?X1 * _ < ?X1 * _)%R => Rsign_le  X1
| |- (?X1 * _ >= ?X1 * _)%R => Rsign_le  X1
| |- (?X1 * _ > ?X1 * _)%R => Rsign_le  X1
  end.

Ltac Rhyp_sign_top0 H:=
  match type of H with
   (0 <= ?X1)%R => Rsign_lt  X1
|  (?X1 <= 0)%R => Rsign_lt  X1
|  (0 < ?X1)%R => Rsign_lt  X1
|  (?X1 < 0)%R => Rsign_lt X1
|  (0 >= ?X1)%R => Rsign_lt  X1
|  (?X1 >= 0)%R => Rsign_lt  X1
|  (0 > ?X1 )%R => Rsign_lt X1
|  (?X1 > 0)%R => Rsign_lt  X1
  end.

Ltac Rhyp_sign_top H :=
  match type of H with
|  (?X1 * _ <= ?X1 * _)%R => Rsign_lt  X1
|  (?X1 * _ < ?X1 * _)%R => Rsign_lt X1
|  (?X1 * _ >= ?X1 * _)%R => Rsign_lt  X1
|  (?X1 * _ > ?X1 * _)%R => Rsign_lt  X1
|  ?X1 => generalize H
  end.

Ltac Rsign_get_term g :=
  match g with
   (0 <= ?X1)%R =>  X1
|  (?X1 <= 0)%R => X1
|  (?X1 * _ <= ?X1 * _)%R =>  X1
|  (0 < ?X1)%R =>  X1
|  (?X1 < 0)%R => X1
|  (?X1 * _ < ?X1 * _)%R =>  X1
|  (0 >= ?X1)%R => X1
|  (?X1 >= 0)%R => X1
|  (?X1 * _ >= ?X1 * _)%R =>  X1
|  (?X1 * _  >= _)%R => X1
|  (0 > ?X1)%R => X1
|  (?X1 > 0)%R => X1
|  (?X1 * _ > ?X1 * _)%R =>  X1
  end.

Ltac Rsign_get_left g :=
  match g with
|  (_ * ?X1 <=  _)%R =>  X1
|  (_ * ?X1 <  _)%R =>  X1
|  (_ * ?X1 >=  _)%R =>  X1
|  (_ * ?X1 >  _)%R =>  X1
end.

Ltac Rsign_get_right g :=
  match g with
|  (_ <= _ * ?X1)%R =>  X1
|  (_ < _ * ?X1)%R =>  X1
|  (_ >= _ * ?X1)%R =>  X1
|  (_ > _ * ?X1)%R =>  X1
end.

Fixpoint mkRprodt (l: list R)(t:R) {struct l}: R :=
match l with nil => t | e::l1 => (e * mkRprodt l1 t)%R end.

Fixpoint mkRprod (l: list R) : R :=
match l with nil => 1%R  | e::nil => e | e::l1 => (e * mkRprod l1)%R end.

Ltac rsign_tac_aux0 := 
match goal with
  |- (0 <= ?X1 * ?X2)%R =>
  let H1 := fresh "H" in
    ((assert (H1: (0 <= X1)%R); auto with real; apply Rle_sign_pos_pos)
      ||
     (assert (H1: (X1 <= 0)%R); auto with real; apply Rle_sign_neg_neg); try rsign_tac_aux0; clear H1)
| |- (?X1 * ?X2 <= 0)%R =>
  let H1 := fresh "H" in
    ((assert (H1: (0 <= X1)%R); auto with real; apply Rle_sign_pos_neg)
      ||
     (assert (H1: (X1 <= 0)%R); auto with real; apply Rle_sign_neg_pos); try rsign_tac_aux0; clear H1)
| |- (0 < ?X1 * ?X2)%R =>
  let H1 := fresh "H" in
    ((assert (H1: (0 < X1)%R); auto with real; apply Rlt_sign_pos_pos)
      ||
     (assert (H1: (X1 < 0)%R); auto with real; apply Rlt_sign_neg_neg); try rsign_tac_aux0; clear H1)
| |- (?X1 * ?X2 < 0)%R =>
  let H1 := fresh "H" in
    ((assert (H1: (0 < X1)%R); auto with real; apply Rlt_sign_pos_neg)
      ||
     (assert (H1: (X1 < 0)%R); auto with real; apply Rlt_sign_neg_pos); try rsign_tac_aux0; clear H1)
 | |- (?X1 * ?X2 >= 0)%R =>
  let H1 := fresh "H" in
    ((assert (H1: (0 >= X1)%R); auto with real; apply Rge_sign_neg_neg)
      ||
     (assert (H1:  (X1 >= 0)%R); auto with real; apply Rge_sign_pos_pos); try rsign_tac_aux0; clear H1)
| |- (0 >= ?X1 * ?X2)%R =>
  let H1 := fresh "H" in
    ((assert (H1: (X1 >= 0)%R); auto with real; apply Rge_sign_pos_neg)
      ||
     (assert (H1: (0 >= X1)%R); auto with real; apply Rge_sign_neg_pos); try rsign_tac_aux0; clear H1)
| |- (0 > ?X1 * ?X2)%R =>
  let H1 := fresh "H" in
    ((assert (H1: (0 > X1)%R); auto with real; apply Rgt_sign_neg_pos)
      ||
     (assert (H1: (X1 > 0)%R); auto with real; apply Rgt_sign_pos_neg); try rsign_tac_aux0; clear H1)
| |- (?X1 * ?X2 > 0)%R =>
  let H1 := fresh "H" in
    ((assert (H1: (0 > X1)%R); auto with real; apply Rgt_sign_neg_neg)
      ||
     (assert (H1: (X1 > 0)%R); auto with real; apply Rgt_sign_pos_pos); try rsign_tac_aux0; clear H1)
|
 _ => auto with real; fail 1 "rsign_tac_aux"
end.

Ltac rsign_tac0 := Rsign_top0;
  match goal with
    H1: (Rsign_type ?s1 ?s2) |- ?g => clear H1;
    let s := eval unfold mkRprod, mkRprodt in 
                  (mkRprodt s1 (mkRprod s2)) in
    let t := Rsign_get_term g in
         replace t with s; [try rsign_tac_aux0 | try ring]; auto with real
  end.

Ltac hyp_rsign_tac_aux0 H := 
match  type of H  with
   (0 <= ?X1 * ?X2)%R =>
  let H1 := fresh "H" in
    ((assert (H1: (0 < X1)%R); auto with real; generalize (Rle_sign_pos_pos_rev  _ _ H1 H)
      ||
     (assert (H1: (X1 < 0)%R); auto with real; generalize (Rle_sign_neg_neg_rev  _ _ H1 H))); 
     clear H; intros H; try hyp_rsign_tac_aux0 H; clear H1)
|  (?X1 * ?X2 <= 0)%R =>
  let H1 := fresh "H" in
    ((assert (H1: (0 < X1)%R); auto with real; generalize (Rle_sign_pos_neg_rev  _ _ H1 H))
      ||
     (assert (H1: (X1 <= 0)%R); auto with real; generalize (Rle_sign_neg_pos_rev  _ _ H1 H)); 
      clear H; intros H; try hyp_rsign_tac_aux0 H; clear H1)
|  (0 < ?X1 * ?X2)%R =>
  let H1 := fresh "H" in
    ((assert (H1: (0 < X1)%R); auto with real; generalize (Rlt_sign_pos_pos_rev _  _ H1 H))
      ||
     (assert (H1: (X1 < 0)%R); auto with real; generalize (Rlt_sign_neg_neg_rev _ _ H1 H)); 
      clear H; intros H; try hyp_rsign_tac_aux0 H; clear H1)
|  (?X1 * ?X2 < 0)%R =>
  let H1 := fresh "H" in
    ((assert (H1: (0 < X1)%R); auto with real; generalize (Rlt_sign_pos_neg_rev _ _ H1 H))
      ||
     (assert (H1: (X1 < 0)%R); auto with real; generalize (Rlt_sign_neg_pos_rev _ _ H1 H)); 
     clear H; intros H; try hyp_rsign_tac_aux0 H; clear H1)
 |  (?X1 * ?X2 >= 0)%R =>
  let H1 := fresh "H" in
    ((assert (H1: (0 >X1)%R); auto with real; generalize (Rge_sign_neg_neg_rev _ _ H1 H))
      ||
     (assert (H1:  (X1 > 0)%R); auto with real; generalize (Rge_sign_pos_pos _ _ H1 H));
      clear H; intros H; try hyp_rsign_tac_aux0 H; clear H1)
|  (0 >= ?X1 * ?X2)%R =>
  let H1 := fresh "H" in
    ((assert (H1: (X1 > 0)%R); auto with real; generalize (Rge_sign_pos_neg _ _ H1 H))
      ||
     (assert (H1: (0 > X1)%R); auto with real; generalize (Rge_sign_neg_pos _ _ H1 H));
     clear H; intros H; try hyp_rsign_tac_aux0 H; clear H1)
|  (0 > ?X1 * ?X2)%R =>
  let H1 := fresh "H" in
    ((assert (H1: (0 > X1)%R); auto with real; generalize (Rgt_sign_neg_pos _ _ H1 H))
      ||
     (assert (H1: (X1 > 0)%R); auto with real; generalize (Rgt_sign_pos_neg _ _ H1 H));
     clear H; intros H; try hyp_rsign_tac_aux0 H; clear H1)
|  (?X1 * ?X2 > 0)%R =>
  let H1 := fresh "H" in
    ((assert (H1: (0 > X1)%R); auto with real; generalize (Rgt_sign_neg_neg _ _ H1 H))
      ||
     (assert (H1: (X1 > 0)%R); auto with real; generalize (Rgt_sign_pos_pos _ _ H1 H));
     clear H; intros H; try hyp_rsign_tac_aux0 H; clear H1)
|
 _ => auto with real; fail 1 "hyp_rsign_tac_aux0"
end.

Ltac hyp_rsign_tac0 H := Rhyp_sign_top0 H;
  match goal with
    H1: (Rsign_type ?s1 ?s2) |- ?g => clear H1;
    let s := eval unfold mkRprod, mkRprodt in 
                  (mkRprodt s1 (mkRprod s2)) in
    let t := Rsign_get_term g in
         replace t with s in H; [try hyp_rsign_tac_aux0 H | try ring]; auto with real
  end.

Ltac rsign_tac_aux := 
match goal with
 | |- (?X1 * ?X2 <= ?X1 * ?X3)%R =>
  let H1 := fresh "H" in
    ((assert (H1: (0 <= X1)%R); auto with real; apply Rmult_le_compat_l)
      ||
     (assert (H1: (X1 <= 0)%R); auto with real; apply Rmult_le_neg_compat_l); try rsign_tac_aux; clear H1)
| |- (?X1 * ?X2 < ?X1 * ?X3)%R =>
  let H1 := fresh "H" in
    ((assert (H1: (0 <= X1)%R); auto with real; apply Rmult_lt_compat_l)
      ||
     (assert (H1: (X1 <= 0)%R); auto with real; apply Rmult_lt_neg_compat_l); try rsign_tac_aux; clear H1) 
 | |- (?X1 * ?X2 >= ?X1 * ?X3)%R =>
  let H1 := fresh "H" in
    ((assert (H1: (X1 >= 0)%R); auto with real; apply Rmult_ge_compat_l)
      ||
     (assert (H1:  (0 >= X1)%R); auto with real; apply Rmult_ge_neg_compat_l); try rsign_tac_aux; clear H1)
| |- (?X1 * ?X2 > ?X1 * ?X3)%R =>
  let H1 := fresh "H" in
    ((assert (H1: (0 <= X1)%R); auto with real; apply Rmult_lt_compat_l)
      ||
     (assert (H1: (X1 <= 0)%R); auto with real; apply Rmult_lt_neg_compat_l); try rsign_tac_aux; clear H1)
|
 _ => auto with real; fail 1 "Rsign_tac_aux"
end.

Ltac rsign_tac := rsign_tac0 || (Rsign_top;
  match goal with
    H1: (Rsign_type ?s1 ?s2) |- ?g => clear H1;
    let s := eval unfold mkRprod, mkRprodt in 
                  (mkRprodt s1 (mkRprod s2)) in
    let t := Rsign_get_term g in
    let l := Rsign_get_left g in
    let r := Rsign_get_right g in
    let sl := eval unfold mkRprod, mkRprodt in 
                  (mkRprodt s1 (Rmult (mkRprod s2) l)) in
    let sr := eval unfold mkRprod, mkRprodt in 
                  (mkRprodt s1 (Rmult (mkRprod s2) r)) in
         replace2_tac (Rmult t l) (Rmult t r) sl sr; [rsign_tac_aux | ring | ring]
  end).

Ltac hyp_rsign_tac_aux H := 
match type of H with
 | (?X1 * ?X2 <= ?X1 * ?X3)%R =>
  let H1 := fresh "H" in
    ((assert (H1: (0 < X1)%R); auto with real; generalize (Rmult_le_compat_l_rev _ _ _ H1 H))
      ||
     (assert (H1: (X1 < 0)%R); auto with real; generalize (Rmult_le_neg_compat_l_rev _ _ _ H1 H)); 
     clear H; intros H; try hyp_rsign_tac_aux H; clear H1)
|  (?X1 * ?X2 < ?X1 * ?X3)%R =>
  let H1 := fresh "H" in
    ((assert (H1: (0 < X1)%R); auto with real; generalize (Rmult_lt_compat_l_rev _ _ _ H1 H))
      ||
     (assert (H1: (X1 < 0)%R); auto with real; generalize (Rmult_lt_neg_compat_l_rev _ _ _ H1 H)); 
    clear H; intros H; try hyp_rsign_tac_aux H; clear H1) 
 |  (?X1 * ?X2 >= ?X1 * ?X3)%R =>
  let H1 := fresh "H" in
    ((assert (H1: (X1 > 0)%R); auto with real; generalize (Rmult_ge_compat_l_rev _ _ _ H1 H))
      ||
     (assert (H1:  (0 > X1)%R); auto with real; generalize (Rmult_ge_neg_compat_l_rev _ _ _ H1 H)); 
    clear H; intros H; try hyp_rsign_tac_aux H; clear H1)
| (?X1 * ?X2 > ?X1 * ?X3)%R =>
  let H1 := fresh "H" in
    ((assert (H1: (0 < X1)%R); auto with real; generalize (Rmult_gt_compat_l_rev _ _ _ H1 H))
      ||
     (assert (H1: (X1 < 0)%R); auto with real; generalize (Rmult_gt_neg_compat_l_rev _ _ _ H1 H)); 
     clear H; intros H; try hyp_rsign_tac_aux H; clear H1)
|
 _ => auto with real; fail 0 "Rhyp_sign_tac_aux"
end.

Ltac hyp_rsign_tac H := hyp_rsign_tac0  H|| (Rhyp_sign_top H;
  match goal with
    H1: (Rsign_type ?s1 ?s2) |- _ => clear H1;
    let s := eval unfold mkRprod, mkRprodt in 
                  (mkRprodt s1 (mkRprod s2)) in
    let g := type of H in
    let t := Rsign_get_term g in
    let l := Rsign_get_left g in
    let r := Rsign_get_right g in
    let sl := eval unfold mkRprod, mkRprodt in 
                  (mkRprodt s1 (Rmult (mkRprod s2) l)) in
    let sr := eval unfold mkRprod, mkRprodt in 
                  (mkRprodt s1 (Rmult (mkRprod s2) r)) in
         (generalize H; replace2_tac (Rmult t l) (Rmult t r) sl sr; [clear H; intros H; try hyp_rsign_tac_aux H| ring | ring])
  end).

Section Test.

Let test : forall a b c, (0 < a -> a * b < a * c -> b < c)%R.

Let test1 : forall a b c, (a < 0 -> a * b < a * c -> c < b)%R.

Let test2 : forall a b c, (0 < a -> a * b <= a * c -> b <= c)%R.

Let test3 : forall a b c, (0 >  a ->  (a * b) >= (a * c) -> c >= b)%R.

End Test. *)
Require Import NSignTac.
(* NSignTac:
Require Import NatSignTac.
Require Import NAux.
Require Import NArith.
Require Import List.
Require Export NGroundTac.

Open Scope N_scope.

Theorem Nmult_lt_compat_l: forall n m p, n < m -> 0 < p -> p * n < p * m.

Theorem Nmult_le_compat_l: forall n m p, n <= m -> p * n <= p * m.

Theorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.

Theorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.

Theorem Nmult_lt_compat_rev_l1: forall n m p, p * n < p * m -> 0 < p.

Theorem Nmult_lt_compat_rev_l2: forall n m p, p * n < p * m -> n < m.

Theorem Nmult_gt_compat_rev_l1: forall n m p, p * n > p * m -> p > 0.

Theorem Nmult_gt_compat_rev_l2: forall n m p, p * n > p * m -> n > m.

Theorem Nmult_le_compat_rev_l: forall n m p, p * n <= p * m -> 0 < p -> n <= m.

Theorem Nmult_ge_compat_rev_l: forall n m p , p * n >= p * m -> 0 < p -> n >= m.

Theorem Nlt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.

Theorem Ngt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.

Theorem Nlt_mult_rev_0_l: forall a b, 0 < a * b ->  0 < a .

Theorem Nlt_mult_rev_0_r: forall a b, 0 < a * b ->  0 < b .

Theorem Ngt_mult_rev_0_l: forall a b, a * b > 0 ->  a > 0.

Theorem Ngt_mult_rev_0_r: forall a b, a * b > 0  ->  b > 0 .

Theorem Nle_0_eq_0: forall n, n <= 0 -> n = 0.

Theorem Nge_0_eq_0: forall n, 0 >= n -> n = 0.

Ltac Nsign_tac :=
 repeat (apply Nmult_le_compat_l || apply Nmult_lt_compat_l ||
              apply Nmult_ge_compat_l || apply Nmult_gt_compat_l ||
              apply Nlt_mult_0 || apply Ngt_mult_0); auto.

Ltac hyp_Nsign_tac H :=
  match type of H with
   0 <= _ => clear H
| (?X1 <= 0)%N => generalize (Nle_0_eq_0 _ H); clear H; intros H; subst X1
|  (?X1 * _ <= ?X1 * _)%N => 
             let s1 := fresh "NS" in
                   (assert (s1: 0 < X1); [Nsign_tac; fail |
                   generalize (Nmult_le_compat_rev_l _ _ _ H s1);
                   clear H s1; intros H])
|   (0  < ?X1 * _)%N  => 
              let s1 := fresh "NS" in
                   (generalize (Nlt_mult_rev_0_l _ _ H);
                    generalize (Nlt_mult_rev_0_r _ _ H); clear H;
                    intros H s1; hyp_Nsign_tac s1; hyp_Nsign_tac H)
|  (?X1 < 0)%N => absurd (~ (X1 < 0)%N); auto
| (?X1 * _  < ?X1 * _)%N => 
              let s1 := fresh "NS" in
                   (generalize (Nmult_lt_compat_rev_l1 _ _ _ H);
                    generalize (Nmult_lt_compat_rev_l2 _ _ _ H); clear H;
                    intros H s1; hyp_Nsign_tac s1; hyp_Nsign_tac H)
|  (?X1 >= 0)%N => clear H
| (0 >= ?X1)%N  => generalize (Nge_0_eq_0 _ H); clear H; intros H; subst X1
|  (?X1 * _ >= ?X1 * _)%N => 
             let s1 := fresh "NS" in
                   (assert (s1: (0 < X1)%N); [Nsign_tac; fail |
                   generalize (Nmult_ge_compat_rev_l _ _ _ H s1);
                   clear H s1; intros H])
|  (?X1 * _ > 0 )%N => 
              let s1 := fresh "NS" in
                   (generalize (Ngt_mult_rev_0_l _ _ H);
                    generalize (Ngt_mult_rev_0_r _ _ H); clear H;
                    intros H s1; hyp_Nsign_tac s1; hyp_Nsign_tac H)
|  (0 > ?X1)%N => absurd (~ (0 > X1)%N); auto with arith
| (?X1 * _  > ?X1 * _)%N => 
              let s1 := fresh "NS" in
                   (generalize (Nmult_gt_compat_rev_l1 _ _ _ H);
                    generalize (Nmult_gt_compat_rev_l2 _ _ _ H); clear H;
                    intros H s1; hyp_Nsign_tac s1; hyp_Nsign_tac H)
  |  _ => (let u := type of H in (clear H; assert (H: u); [auto; fail | clear H]) || idtac)
              
   end.

Close Scope N_scope. *)
Require Import NatSignTac.
(* NatSignTac:
Require Import Arith.
Require Import List.
Require Export NatGroundTac.

Theorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.

Theorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.

Theorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.

Theorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.

Theorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.

Theorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.

Theorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.

Theorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.

Theorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.

Theorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.

Theorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.

Theorem lt_mult_rev_0_l: forall a b, 0 < a * b ->  0 < a .

Theorem lt_mult_rev_0_r: forall a b, 0 < a * b ->  0 < b .

Theorem gt_mult_rev_0_l: forall a b, a * b > 0 ->  a > 0.

Theorem gt_mult_rev_0_r: forall a b, a * b > 0  ->  b > 0 .

Theorem le_0_eq_0: forall n, n <= 0 -> n = 0.

Ltac nsign_tac :=
 repeat (apply mult_le_compat_l || apply mult_lt_compat_l ||
              apply mult_ge_compat_l || apply mult_gt_compat_l ||
              apply lt_mult_0 || apply gt_mult_0); auto with arith.

Ltac hyp_nsign_tac H :=
  match type of H with
   0 <= _ => clear H
| ?X1 <= 0 => generalize (le_0_eq_0 _ H); clear H; intros H; subst X1
|  ?X1 * _ <= ?X1 * _ => 
             let s1 := fresh "NS" in
                   (assert (s1: 0 < X1); [nsign_tac; fail |
                   generalize (mult_le_compat_rev_l _ _ _ H s1);
                   clear H s1; intros H])
|   0  < ?X1 * _ => 
              let s1 := fresh "NS" in
                   (generalize (lt_mult_rev_0_l _ _ H);
                    generalize (lt_mult_rev_0_r _ _ H); clear H;
                    intros H s1; hyp_nsign_tac s1; hyp_nsign_tac H)
|  ?X1 < 0 => absurd (~ (X1 < 0)); auto with arith
| ?X1 * _  < ?X1 * _ => 
              let s1 := fresh "NS" in
                   (generalize (mult_lt_compat_rev_l1 _ _ _ H);
                    generalize (mult_lt_compat_rev_l2 _ _ _ H); clear H;
                    intros H s1; hyp_nsign_tac s1; hyp_nsign_tac H)
|  ?X1 >= 0 => clear H
| 0 >= ?X1  => generalize (le_0_eq_0 _ H); clear H; intros H; subst X1
|  ?X1 * _ >= ?X1 * _ => 
             let s1 := fresh "NS" in
                   (assert (s1: 0 < X1); [nsign_tac; fail |
                   generalize (mult_ge_compat_rev_l _ _ _ H s1);
                   clear H s1; intros H])
|  ?X1 * _ > 0 => 
              let s1 := fresh "NS" in
                   (generalize (gt_mult_rev_0_l _ _ H);
                    generalize (gt_mult_rev_0_r _ _ H); clear H;
                    intros H s1; hyp_nsign_tac s1; hyp_nsign_tac H)
|  0 > ?X1 => absurd (~ (0 > X1)); auto with arith
| ?X1 * _  > ?X1 * _ => 
              let s1 := fresh "NS" in
                   (generalize (mult_gt_compat_rev_l1 _ _ _ H);
                    generalize (mult_gt_compat_rev_l2 _ _ _ H); clear H;
                    intros H s1; hyp_nsign_tac s1; hyp_nsign_tac H)
  |  _ => (let u := type of H in (clear H; assert (H: u); [auto with arith; fail | clear H]) || idtac)
              
   end.

Section Test.

Let hyp_test : forall a b c d e, 
  0 <= a -> 0 < a -> a * b <= a * c  -> b * a <= b * c -> d <= 0 -> e < 0 -> d = 0.

Let hyp_test1 : forall a b c d e, 
  a >= 0 -> a > 0 -> a * b > a * c  -> b * a >= b * c -> 0 >= d -> 0 > e -> d = 0.

End Test. *)
Require Import ZSignTac.
(* ZSignTac:
Require Import Reals.
Require Import RPolS.
Require Import PolAux.
Require Import List.

Definition Zsign_type := fun (x y:list Z) => Prop.

Definition Zsign_cons : forall x y, (Zsign_type  x y) := fun x y => True.

Ltac Zsign_push term1 term2 := generalize (Zsign_cons term1 term2); intro.

Ltac Zsign_le term :=
  match term with 
    (?X1 * ?X2)%Z =>  Zsign_le X1;
                             match goal with 
                             H1: (Zsign_type ?s1 ?s2) |- _ =>
                                    Zsign_le X2;
                                   match goal with 
                                      H2: (Zsign_type ?s3 ?s4) |- _ => clear H1 H2;
                                              let s5 := eval unfold List.app in (s1++s3) in
                                              let s6 := eval unfold List.app in (s2++s4) in
                                               Zsign_push s5 s6
                                   end
                              end
| _ =>  let H1 := fresh "H" in
    (((assert (H1: (0 <= term)%Z); [auto with zarith; fail | idtac])
      ||
     (assert (H1: (term <= 0)%Z); [auto with zarith; fail | idtac])); clear H1;
         Zsign_push (term::nil) (@nil Z)) || Zsign_push (@nil Z) (term::nil)
end.

Ltac Zsign_lt term :=
  match term with 
    (?X1 * ?X2)%Z =>  Zsign_lt X1;
                             match goal with 
                             H1: (Zsign_type ?s1 ?s2) |- _ =>
                                    Zsign_lt X2;
                                   match goal with 
                                      H2: (Zsign_type ?s3 ?s4) |- _ => clear H1 H2;
                                              let s5 := eval unfold List.app in (s1++s3) in
                                              let s6 := eval unfold List.app in (s2++s4) in
                                               Zsign_push s5 s6
                                   end
                              end
| _ =>  let H1 := fresh "H" in
    (((assert (H1: (0 < term)%Z); [auto with zarith; fail | idtac])
      ||
     (assert (H1: (term < 0)%Z); [auto with zarith; fail | idtac])); clear H1;
         Zsign_push (term::nil) (@nil Z)) || Zsign_push (@nil Z) (term::nil)
end.

Ltac Zsign_top0 :=
  match goal with
  |- (0 <= ?X1)%Z => Zsign_le  X1
| |- (?X1 <= 0)%Z => Zsign_le  X1
| |- (0 < ?X1)%Z => Zsign_lt  X1
| |- (?X1 < 0)%Z => Zsign_le  X1
| |- (0 >= ?X1)%Z => Zsign_le  X1
| |- (?X1 >= 0)%Z => Zsign_le  X1
| |- (0 > ?X1 )%Z => Zsign_lt X1
| |- (?X1 > 0)%Z => Zsign_le  X1
  end.

Ltac Zsign_top :=
  match goal with
| |- (?X1 * _ <= ?X1 * _)%Z => Zsign_le  X1
| |- (?X1 * _ < ?X1 * _)%Z => Zsign_le  X1
| |- (?X1 * _ >= ?X1 * _)%Z => Zsign_le  X1
| |- (?X1 * _ > ?X1 * _)%Z => Zsign_le  X1
  end.

Ltac Zhyp_sign_top0 H:=
  match type of H with
   (0 <= ?X1)%Z => Zsign_lt  X1
|  (?X1 <= 0)%Z => Zsign_lt  X1
|  (0 < ?X1)%Z => Zsign_lt  X1
|  (?X1 < 0)%Z => Zsign_lt X1
|  (0 >= ?X1)%Z => Zsign_lt  X1
|  (?X1 >= 0)%Z => Zsign_lt  X1
|  (0 > ?X1 )%Z => Zsign_lt X1
|  (?X1 > 0)%Z => Zsign_lt  X1
  end.

Ltac Zhyp_sign_top H :=
  match type of H with
|  (?X1 * _ <= ?X1 * _)%Z => Zsign_lt  X1
|  (?X1 * _ < ?X1 * _)%Z => Zsign_lt X1
|  (?X1 * _ >= ?X1 * _)%Z => Zsign_lt  X1
|  (?X1 * _ > ?X1 * _)%Z => Zsign_lt  X1
|  ?X1 => generalize H
  end.

Ltac Zsign_get_term g :=
  match g with
   (0 <= ?X1)%Z =>  X1
|  (?X1 <= 0)%Z => X1
|  (?X1 * _ <= ?X1 * _)%Z =>  X1
|  (0 < ?X1)%Z =>  X1
|  (?X1 < 0)%Z => X1
|  (?X1 * _ < ?X1 * _)%Z =>  X1
|  (0 >= ?X1)%Z => X1
|  (?X1 >= 0)%Z => X1
|  (?X1 * _ >= ?X1 * _)%Z =>  X1
|  (?X1 * _  >= _)%Z => X1
|  (0 > ?X1)%Z => X1
|  (?X1 > 0)%Z => X1
|  (?X1 * _ > ?X1 * _)%Z =>  X1
  end.

Ltac Zsign_get_left g :=
  match g with
|  (_ * ?X1 <=  _)%Z =>  X1
|  (_ * ?X1 <  _)%Z =>  X1
|  (_ * ?X1 >=  _)%Z =>  X1
|  (_ * ?X1 >  _)%Z =>  X1
end.

Ltac Zsign_get_right g :=
  match g with
|  (_ <= _ * ?X1)%Z =>  X1
|  (_ < _ * ?X1)%Z =>  X1
|  (_ >= _ * ?X1)%Z =>  X1
|  (_ > _ * ?X1)%Z =>  X1
end.

Fixpoint mkZprodt (l: list Z)(t:Z) {struct l}: Z :=
match l with nil => t | e::l1 => (e * mkZprodt l1 t)%Z end.

Fixpoint mkZprod (l: list Z) : Z :=
match l with nil => 1%Z  | e::nil => e | e::l1 => (e * mkZprod l1)%Z end.

Ltac zsign_tac_aux0 := 
match goal with
  |- (0 <= ?X1 * ?X2)%Z =>
  let H1 := fresh "H" in
    ((assert (H1: (0 <= X1)%Z); auto with zarith; apply Zle_sign_pos_pos)
      ||
     (assert (H1: (X1 <= 0)%Z); auto with zarith; apply Zle_sign_neg_neg); try zsign_tac_aux0; clear H1)
| |- (?X1 * ?X2 <= 0)%Z =>
  let H1 := fresh "H" in
    ((assert (H1: (0 <= X1)%Z); auto with zarith; apply Zle_sign_pos_neg)
      ||
     (assert (H1: (X1 <= 0)%Z); auto with zarith; apply Zle_sign_neg_pos); try zsign_tac_aux0; clear H1)
| |- (0 < ?X1 * ?X2)%Z =>
  let H1 := fresh "H" in
    ((assert (H1: (0 < X1)%Z); auto with zarith; apply Zlt_sign_pos_pos)
      ||
     (assert (H1: (X1 < 0)%Z); auto with zarith; apply Zlt_sign_neg_neg); try zsign_tac_aux0; clear H1)
| |- (?X1 * ?X2 < 0)%Z =>
  let H1 := fresh "H" in
    ((assert (H1: (0 < X1)%Z); auto with zarith; apply Zlt_sign_pos_neg)
      ||
     (assert (H1: (X1 < 0)%Z); auto with zarith; apply Zlt_sign_neg_pos); try zsign_tac_aux0; clear H1)
 | |- (?X1 * ?X2 >= 0)%Z =>
  let H1 := fresh "H" in
    ((assert (H1: (0 >= X1)%Z); auto with zarith; apply Zge_sign_neg_neg)
      ||
     (assert (H1:  (X1 >= 0)%Z); auto with zarith; apply Zge_sign_pos_pos); try zsign_tac_aux0; clear H1)
| |- (0 >= ?X1 * ?X2)%Z =>
  let H1 := fresh "H" in
    ((assert (H1: (X1 >= 0)%Z); auto with zarith; apply Zge_sign_pos_neg)
      ||
     (assert (H1: (0 >= X1)%Z); auto with zarith; apply Zge_sign_neg_pos); try zsign_tac_aux0; clear H1)
| |- (0 > ?X1 * ?X2)%Z =>
  let H1 := fresh "H" in
    ((assert (H1: (0 > X1)%Z); auto with zarith; apply Zgt_sign_neg_pos)
      ||
     (assert (H1: (X1 > 0)%Z); auto with zarith; apply Zgt_sign_pos_neg); try zsign_tac_aux0; clear H1)
| |- (?X1 * ?X2 > 0)%Z =>
  let H1 := fresh "H" in
    ((assert (H1: (0 > X1)%Z); auto with zarith; apply Zgt_sign_neg_neg)
      ||
     (assert (H1: (X1 > 0)%Z); auto with zarith; apply Zgt_sign_pos_pos); try zsign_tac_aux0; clear H1)
|
 _ => auto with zarith; fail 1 "zsign_tac_aux"
end.

Ltac zsign_tac0 := Zsign_top0;
  match goal with
    H1: (Zsign_type ?s1 ?s2) |- ?g => clear H1;
    let s := eval unfold mkZprod, mkZprodt in 
                  (mkZprodt s1 (mkZprod s2)) in
    let t := Zsign_get_term g in
         replace t with s; [try zsign_tac_aux0 | try ring]; auto with zarith
  end.

Ltac hyp_zsign_tac_aux0 H := 
match  type of H  with
   (0 <= ?X1 * ?X2)%Z =>
  let H1 := fresh "H" in
    ((assert (H1: (0 < X1)%Z); auto with zarith; generalize (Zle_sign_pos_pos_rev  _ _ H1 H)
      ||
     (assert (H1: (X1 < 0)%Z); auto with zarith; generalize (Zle_sign_neg_neg_rev  _ _ H1 H))); 
     clear H; intros H; try hyp_zsign_tac_aux0 H; clear H1)
|  (?X1 * ?X2 <= 0)%Z =>
  let H1 := fresh "H" in
    ((assert (H1: (0 < X1)%Z); auto with zarith; generalize (Zle_sign_pos_neg_rev  _ _ H1 H))
      ||
     (assert (H1: (X1 <= 0)%Z); auto with zarith; generalize (Zle_sign_neg_pos_rev  _ _ H1 H)); 
      clear H; intros H; try hyp_zsign_tac_aux0 H; clear H1)
|  (0 < ?X1 * ?X2)%Z =>
  let H1 := fresh "H" in
    ((assert (H1: (0 < X1)%Z); auto with zarith; generalize (Zlt_sign_pos_pos_rev _  _ H1 H))
      ||
     (assert (H1: (X1 < 0)%Z); auto with zarith; generalize (Zlt_sign_neg_neg_rev _ _ H1 H)); 
      clear H; intros H; try hyp_zsign_tac_aux0 H; clear H1)
|  (?X1 * ?X2 < 0)%Z =>
  let H1 := fresh "H" in
    ((assert (H1: (0 < X1)%Z); auto with zarith; generalize (Zlt_sign_pos_neg_rev _ _ H1 H))
      ||
     (assert (H1: (X1 < 0)%Z); auto with zarith; generalize (Zlt_sign_neg_pos_rev _ _ H1 H)); 
     clear H; intros H; try hyp_zsign_tac_aux0 H; clear H1)
 |  (?X1 * ?X2 >= 0)%Z =>
  let H1 := fresh "H" in
    ((assert (H1: (0 >X1)%Z); auto with zarith; generalize (Zge_sign_neg_neg_rev _ _ H1 H))
      ||
     (assert (H1:  (X1 > 0)%Z); auto with zarith; generalize (Zge_sign_pos_pos _ _ H1 H));
      clear H; intros H; try hyp_zsign_tac_aux0 H; clear H1)
|  (0 >= ?X1 * ?X2)%Z =>
  let H1 := fresh "H" in
    ((assert (H1: (X1 > 0)%Z); auto with zarith; generalize (Zge_sign_pos_neg _ _ H1 H))
      ||
     (assert (H1: (0 > X1)%Z); auto with zarith; generalize (Zge_sign_neg_pos _ _ H1 H));
     clear H; intros H; try hyp_zsign_tac_aux0 H; clear H1)
|  (0 > ?X1 * ?X2)%Z =>
  let H1 := fresh "H" in
    ((assert (H1: (0 > X1)%Z); auto with zarith; generalize (Zgt_sign_neg_pos _ _ H1 H))
      ||
     (assert (H1: (X1 > 0)%Z); auto with zarith; generalize (Zgt_sign_pos_neg _ _ H1 H));
     clear H; intros H; try hyp_zsign_tac_aux0 H; clear H1)
|  (?X1 * ?X2 > 0)%Z =>
  let H1 := fresh "H" in
    ((assert (H1: (0 > X1)%Z); auto with zarith; generalize (Zgt_sign_neg_neg _ _ H1 H))
      ||
     (assert (H1: (X1 > 0)%Z); auto with zarith; generalize (Zgt_sign_pos_pos _ _ H1 H));
     clear H; intros H; try hyp_zsign_tac_aux0 H; clear H1)
|
 _ => auto with zarith; fail 1 "hyp_zsign_tac_aux0"
end.

Ltac hyp_zsign_tac0 H := Zhyp_sign_top0 H;
  match goal with
    H1: (Zsign_type ?s1 ?s2) |- ?g => clear H1;
    let s := eval unfold mkZprod, mkZprodt in 
                  (mkZprodt s1 (mkZprod s2)) in
    let t := Zsign_get_term g in
         replace t with s in H; [try hyp_zsign_tac_aux0 H | try ring]; auto with zarith
  end.

Ltac zsign_tac_aux := 
match goal with
 | |- (?X1 * ?X2 <= ?X1 * ?X3)%Z =>
  let H1 := fresh "H" in
    ((assert (H1: (0 <= X1)%Z); auto with zarith; apply Zmult_le_compat_l)
      ||
     (assert (H1: (X1 <= 0)%Z); auto with zarith; apply Zmult_le_neg_compat_l); try zsign_tac_aux; clear H1)
| |- (?X1 * ?X2 < ?X1 * ?X3)%Z =>
  let H1 := fresh "H" in
    ((assert (H1: (0 <= X1)%Z); auto with zarith; apply Zmult_lt_compat_l)
      ||
     (assert (H1: (X1 <= 0)%Z); auto with zarith; apply Zmult_lt_neg_compat_l); try zsign_tac_aux; clear H1) 
 | |- (?X1 * ?X2 >= ?X1 * ?X3)%Z =>
  let H1 := fresh "H" in
    ((assert (H1: (X1 >= 0)%Z); auto with zarith; apply Zmult_ge_compat_l)
      ||
     (assert (H1:  (0 >= X1)%Z); auto with zarith; apply Zmult_ge_neg_compat_l); try zsign_tac_aux; clear H1)
| |- (?X1 * ?X2 > ?X1 * ?X3)%Z =>
  let H1 := fresh "H" in
    ((assert (H1: (0 <= X1)%Z); auto with zarith; apply Zmult_lt_compat_l)
      ||
     (assert (H1: (X1 <= 0)%Z); auto with zarith; apply Zmult_lt_neg_compat_l); try zsign_tac_aux; clear H1)
|
 _ => auto with zarith; fail 1 "Zsign_tac_aux"
end.

Ltac zsign_tac := zsign_tac0 || (Zsign_top;
  match goal with
    H1: (Zsign_type ?s1 ?s2) |- ?g => clear H1;
    let s := eval unfold mkZprod, mkZprodt in 
                  (mkZprodt s1 (mkZprod s2)) in
    let t := Zsign_get_term g in
    let l := Zsign_get_left g in
    let r := Zsign_get_right g in
    let sl := eval unfold mkZprod, mkZprodt in 
                  (mkZprodt s1 (Zmult (mkZprod s2) l)) in
    let sr := eval unfold mkZprod, mkZprodt in 
                  (mkZprodt s1 (Zmult (mkZprod s2) r)) in
         replace2_tac (Zmult t l) (Zmult t r) sl sr; [zsign_tac_aux | ring | ring]
  end).

Ltac hyp_zsign_tac_aux H := 
match type of H with
 | (?X1 * ?X2 <= ?X1 * ?X3)%Z =>
  let H1 := fresh "H" in
    ((assert (H1: (0 < X1)%Z); auto with zarith; generalize (Zmult_le_compat_l_rev _ _ _ H1 H))
      ||
     (assert (H1: (X1 < 0)%Z); auto with zarith; generalize (Zmult_le_neg_compat_l_rev _ _ _ H1 H)); 
     clear H; intros H; try hyp_zsign_tac_aux H; clear H1)
|  (?X1 * ?X2 < ?X1 * ?X3)%Z =>
  let H1 := fresh "H" in
    ((assert (H1: (0 < X1)%Z); auto with zarith; generalize (Zmult_lt_compat_l_rev _ _ _ H1 H))
      ||
     (assert (H1: (X1 < 0)%Z); auto with zarith; generalize (Zmult_lt_neg_compat_l_rev _ _ _ H1 H)); 
    clear H; intros H; try hyp_zsign_tac_aux H; clear H1) 
 |  (?X1 * ?X2 >= ?X1 * ?X3)%Z =>
  let H1 := fresh "H" in
    ((assert (H1: (X1 > 0)%Z); auto with zarith; generalize (Zmult_ge_compat_l_rev _ _ _ H1 H))
      ||
     (assert (H1:  (0 > X1)%Z); auto with zarith; generalize (Zmult_ge_neg_compat_l_rev _ _ _ H1 H)); 
    clear H; intros H; try hyp_zsign_tac_aux H; clear H1)
| (?X1 * ?X2 > ?X1 * ?X3)%Z =>
  let H1 := fresh "H" in
    ((assert (H1: (0 < X1)%Z); auto with zarith; generalize (Zmult_gt_compat_l_rev _ _ _ H1 H))
      ||
     (assert (H1: (X1 < 0)%Z); auto with zarith; generalize (Zmult_gt_neg_compat_l_rev _ _ _ H1 H)); 
     clear H; intros H; try hyp_zsign_tac_aux H; clear H1)
|
 _ => auto with zarith; fail 0 "Zhyp_sign_tac_aux"
end.

Ltac hyp_zsign_tac H := hyp_zsign_tac0  H||( Zhyp_sign_top H;
  match goal with
    H1: (Zsign_type ?s1 ?s2) |- _ => clear H1;
    let s := eval unfold mkZprod, mkZprodt in 
                  (mkZprodt s1 (mkZprod s2)) in
    let g := type of H in
    let t := Zsign_get_term g in
    let l := Zsign_get_left g in
    let r := Zsign_get_right g in
    let sl := eval unfold mkZprod, mkZprodt in 
                  (mkZprodt s1 (Zmult (mkZprod s2) l)) in
    let sr := eval unfold mkZprod, mkZprodt in 
                  (mkZprodt s1 (Zmult (mkZprod s2) r)) in
         (generalize H; replace2_tac (Zmult t l) (Zmult t r) sl sr; [clear H; intros H; try hyp_zsign_tac_aux H| ring | ring])
  end).

Section Test.

Let test : forall a b c, (0 < a -> a * b < a * c -> b < c)%Z.

Let test1 : forall a b c, (a < 0 -> a * b < a * c -> c < b)%Z.

Let test2 : forall a b c, (0 < a -> a * b <= a * c -> b <= c)%Z.

Let test3 : forall a b c, (a < - 0 -> a * b >= a * c -> c >= b)%Z.

End Test. *)

Ltac sign_tac :=  nsign_tac || Nsign_tac || zsign_tac || rsign_tac.

Ltac hyp_sign_tac H :=  hyp_nsign_tac H || hyp_Nsign_tac H || hyp_zsign_tac H || hyp_rsign_tac H.

Require Import RPolS.
(* RPolS:
Require Import Reals.
Require Import PolSBase.
Require Import PolAuxList.
Require Import PolAux.

Definition Rconvert_back (e : PExpr Z) (l : list R) : R :=
   convert_back Z R R0 Rplus Rminus Rmult Ropp Z2R l e.

Definition Rsimpl_minus (e : PExpr Z) :=
    (simpl_minus
      Z Zplus Zmult Z.opp Z0 1%Z is_Z1 is_Z0 is_Zpos is_Zdiv Z.div e).

Definition Rsimpl (e : PExpr Z) :=
    (simpl
      Z Zplus Zmult Z.opp Z0 1%Z is_Z1 is_Z0 is_Zpos is_Zdiv Z.div e).

Ltac
rs term1 term2 :=
let term := constr:(Rminus term1 term2) in
let rfv := FV RCst Rplus Rmult Rminus Ropp term (@nil R) in
let fv := Trev rfv in
let expr1 := mkPolexpr Z RCst Rplus Rmult Rminus Ropp term1 fv in
let expr2 := mkPolexpr Z RCst Rplus Rmult Rminus Ropp term2 fv in
let re := eval vm_compute in (Rsimpl_minus (PEsub expr1 expr2)) in
let expr3 := match re with (PEsub ?X1 _) => X1 end in
let expr4 := match re with (PEsub _ ?X1 ) => X1 end in
let re1 :=  constr:(PEsub expr1 expr3) in
let
 re1' :=
  eval
     unfold
      Rconvert_back, convert_back,  pos_nth,  jump,
         hd,  tl, Z2R, P2R in (Rconvert_back (PEadd re1 expr3) fv) in
let re1'' := eval lazy beta in re1' in
let
 re2' :=
  eval
     unfold
      Rconvert_back, convert_back,  pos_nth,  jump,
         hd,  tl, Z2R, P2R in (Rconvert_back (PEadd re1 expr4) fv) in
let re2'' := eval lazy beta in re2' in
replace2_tac term1 term2 re1'' re2''; [idtac| ring | ring].

Ltac
rpols :=
match goal with
| |- (?X1 = ?X2)%R =>
rs X1 X2; try apply Rplus_eq_compat_l
| |- (?X1 <> ?X2)%R =>
rs X1 X2; apply Rplus_neg_compat_l
| |- Rlt ?X1 ?X2 =>
rs X1 X2; apply Rplus_lt_compat_l
| |- Rgt ?X1 ?X2 =>
rs X1 X2; apply Rplus_gt_compat_l
| |- Rle ?X1 ?X2 =>
rs X1 X2; apply Rplus_le_compat_l
| |- Rge ?X1 ?X2 =>
rs X1 X2; apply Rplus_ge_compat_l
| _ => fail end.

Ltac
hyp_rpols H :=
generalize H;
let tmp := fresh "tmp" in
match (type of H) with
   (?X1 = ?X2)%R =>
rs X1 X2; intros tmp; generalize (Rplus_eq_reg_l _ _ _ tmp); clear H tmp; intro H
|  (?X1 <> ?X2)%nat =>
rs X1 X2; intros tmp; generalize (Rplus_neg_reg_l _ _ _ tmp); clear H tmp; intro H
|  Rlt ?X1 ?X2 =>
rs X1 X2; intros tmp; generalize (Rplus_lt_reg_r _ _ _ tmp); clear H tmp; intro H
|  Rgt ?X1 ?X2 =>
rs X1 X2; intros tmp; generalize (Rplus_gt_reg_l _ _ _ tmp); clear H tmp; intro H
|  Rle ?X1 ?X2 =>
rs X1 X2; intros tmp; generalize (Rplus_le_reg_l _ _ _ tmp); clear H tmp; intro H
|  Rge ?X1 ?X2 =>
rs X1 X2; intros tmp; generalize (Rplus_ge_reg_l _ _ _ tmp); clear H tmp; intro H
| _ => fail end. *)
Require Import ZPolS.
(* ZPolS:
Require Import PolSBase.
Require Import PolAuxList.
Require Import PolAux.

Definition Zconvert_back (e : PExpr Z) (l : list Z) : Z :=
   convert_back Z Z Z0 Zplus Zminus Zmult Z.opp (fun (x : Z) => x) l e.

Definition Zsimpl (e : PExpr Z)  :=
   simpl
      Z Zplus Zmult Z.opp Z0 1%Z is_Z1 is_Z0 is_Zpos is_Zdiv Z.div e. 

Definition Zsimpl_minus (e : PExpr Z) :=
   simpl_minus
    Z Zplus Zmult Z.opp Z0 1%Z is_Z1 is_Z0 is_Zpos is_Zdiv Z.div e. 

Ltac
zs term1 term2 :=
let term := constr:(Zminus term1 term2) in
let rfv := FV ZCst Zplus Zmult Zminus Z.opp term (@nil Z) in
let fv := Trev rfv in
let expr1 := mkPolexpr Z ZCst Zplus Zmult Zminus Z.opp term1 fv in
let expr2 := mkPolexpr Z ZCst Zplus Zmult Zminus Z.opp term2 fv in
let re := eval vm_compute in (Zsimpl_minus (PEsub expr1 expr2)) in
let expr3 := match re with (PEsub ?X1 _) => X1 end in
let expr4 := match re with (PEsub _ ?X1 ) => X1 end in
let re1 := eval vm_compute in (Zsimpl (PEsub expr1 expr3)) in
let
 re1' :=
  eval
     unfold
      Zconvert_back, convert_back,  pos_nth,  jump, 
         hd,  tl in (Zconvert_back (PEadd re1 expr3) fv) in
let re1'' := eval lazy beta in re1' in
let
 re2' :=
  eval
     unfold
      Zconvert_back, convert_back,  pos_nth,  jump, 
         hd,  tl in (Zconvert_back (PEadd re1 expr4) fv) in
let re2'' := eval lazy beta in re2' in 
replace2_tac term1 term2 re1'' re2''; [idtac | ring | ring].

Ltac
zpols :=
match goal with
| |- (?X1 = ?X2)%Z =>
zs X1 X2; apply Zplus_eq_compat_l
| |- (?X1 <> ?X2)%Z =>
zs X1 X2; apply Zplus_neg_compat_l
| |- Z.lt ?X1 ?X2 =>
zs X1 X2; apply Zplus_lt_compat_l
| |- Z.gt ?X1 ?X2 =>
zs X1 X2; apply Zplus_gt_compat_l
| |- Z.le ?X1 ?X2 =>
zs X1 X2; apply Zplus_le_compat_l
| |- Z.ge ?X1 ?X2 =>
zs X1 X2; apply Zplus_ge_compat_l
| _ => fail end.

Ltac
hyp_zpols H :=
generalize H;
let tmp := fresh "tmp" in
match (type of H) with
   (?X1 = ?X2)%Z =>
zs X1 X2; intros tmp; generalize (Zplus_reg_l _ _ _ tmp); clear H tmp; intro H
|  (?X1 <> ?X2)%nat =>
zs X1 X2; intros tmp; generalize (Zplus_neg_reg_l _ _ _ tmp); clear H tmp; intro H
|  Z.lt ?X1 ?X2 =>
zs X1 X2; intros tmp; generalize (Zplus_lt_reg_l _ _ _ tmp); clear H tmp; intro H
|  Z.gt ?X1 ?X2 =>
zs X1 X2; intros tmp; generalize (Zplus_gt_reg_l _ _ _ tmp); clear H tmp; intro H
|  Z.le ?X1 ?X2 =>
zs X1 X2; intros tmp; generalize (Zplus_le_reg_l _ _ _ tmp); clear H tmp; intro H
|  Z.ge ?X1 ?X2 =>
zs X1 X2; intros tmp; generalize (Zplus_ge_reg_l _ _ _ tmp); clear H tmp; intro H
| _ => fail end. *)
Require Import NatPolS.
(* NatPolS:
Require Import PolSBase.
Require Import PolAuxList.
Require Import PolAux.
Require Export ArithRing.

Open Scope nat_scope.

Definition Natconvert_back (e : PExpr Z) (l : list nat) : nat :=
   convert_back Z nat 0 plus minus mult Natopp Z.abs_nat l e.
 
Definition Natsimpl_minus (e : PExpr Z) :=
   simpl_minus
    Z Zplus Zmult Z.opp Z0 1%Z is_Z1 is_Z0 is_Zpos is_Zdiv Z.div e.
 
Definition Natsimpl (e : PExpr Z) :=
   simpl
    Z Zplus Zmult Z.opp Z0 1%Z is_Z1 is_Z0 is_Zpos is_Zdiv Z.div e.

Ltac
ns term1 term2 :=
let term := constr:(minus term1 term2) in
let rfv := FV NatCst plus mult minus Natopp term (@nil nat) in
let fv := Trev rfv in
let expr1 := mkPolexpr Z NatCst plus mult minus Natopp term1 fv in
let expr2 := mkPolexpr Z NatCst plus mult minus Natopp term2 fv in
let re := eval vm_compute in (Natsimpl_minus (PEsub expr1 expr2)) in
let expr3 := match re with (PEsub ?X1 _) => X1 end in
let expr4 := match re with (PEsub _ ?X1 ) => X1 end in
let re1 := eval vm_compute in (Natsimpl (PEsub expr1 expr3)) in
let
 re1' :=
  eval
     unfold
      Natconvert_back, convert_back,  PolAuxList.pos_nth,  PolAuxList.jump, 
         PolAuxList.hd,  PolAuxList.tl in (Natconvert_back (PEadd re1 expr3) fv) in
let re1'' := eval lazy beta in re1' in
let re1''' := clean_zabs re1'' in
let
 re2' :=
  eval
     unfold
      Natconvert_back, convert_back,  PolAuxList.pos_nth,  PolAuxList.jump, 
         PolAuxList.hd,  PolAuxList.tl in (Natconvert_back (PEadd re1 expr4) fv) in
let re2'' := eval lazy beta in re2' in
let re2''' := clean_zabs re2'' in
replace2_tac term1 term2 re1''' re2'''; [idtac | ring | ring].

Ltac
npols :=
match goal with
| |- (?X1 = ?X2)%nat =>
ns X1 X2; apply plus_eq_compat_l
| |- (?X1 <> ?X2)%nat =>
ns X1 X2; apply plus_neg_compat_l
| |- lt ?X1 ?X2 =>
ns X1 X2; apply plus_lt_compat_l
| |- gt ?X1 ?X2 =>
ns X1 X2; apply plus_gt_compat_l
| |- le ?X1 ?X2 =>
ns X1 X2; apply plus_le_compat_l
| |- ge ?X1 ?X2 =>
ns X1 X2; apply plus_ge_compat_l
| _ => fail end.

Ltac
hyp_npols H :=
generalize H;
let tmp := fresh "tmp" in
match (type of H) with
   (?X1 = ?X2)%nat =>
ns X1 X2; intros tmp; generalize (plus_reg_l _ _ _ tmp); clear H tmp; intro H
|  (?X1 <> ?X2)%nat =>
ns X1 X2; intros tmp; generalize (plus_neg_reg_l _ _ _ tmp); clear H tmp; intro H
|  lt ?X1 ?X2 =>
ns X1 X2; intros tmp; generalize (plus_lt_reg_l _ _ _ tmp); clear H tmp; intro H
|  gt ?X1 ?X2 =>
ns X1 X2; intros tmp; generalize (plus_gt_reg_l _ _ _ tmp); clear H tmp; intro H
|  le ?X1 ?X2 =>
ns X1 X2; intros tmp; generalize (plus_le_reg_l _ _ _ tmp); clear H tmp; intro H
|  ge ?X1 ?X2 =>
ns X1 X2; intros tmp; generalize (plus_ge_reg_l _ _ _ tmp); clear H tmp; intro H
| _ => fail end. *)
Require Import NPolS.
(* NPolS:
Require Import PolSBase.
Require Import PolAuxList.
Require Import PolAux.
Require Import NAux.
Require Export ArithRing.

Open Scope nat_scope.

Definition Nconvert_back (e : PExpr Z) (l : list N) : N :=
   convert_back Z N 0%N Nplus Nminus Nmult Nopp Z.abs_N l e.
 
Definition Nsimpl_minus (e : PExpr Z) :=
   simpl_minus
    Z Zplus Zmult Z.opp Z0 1%Z is_Z1 is_Z0 is_Zpos is_Zdiv Z.div e.
 
Definition Nsimpl (e : PExpr Z) :=
   simpl
    Z Zplus Zmult Z.opp Z0 1%Z is_Z1 is_Z0 is_Zpos is_Zdiv Z.div e.

Ltac
Ns term1 term2 :=
let term := constr:(Nminus term1 term2) in
let rfv := FV NCst Nplus Nmult Nminus Nopp term (@nil N) in
let fv := Trev rfv in
let expr1 := mkPolexpr Z NCst Nplus Nmult Nminus Nopp term1 fv in
let expr2 := mkPolexpr Z NCst Nplus Nmult Nminus Nopp term2 fv in
let re := eval vm_compute in (Nsimpl_minus (PEsub expr1 expr2)) in
let expr3 := match re with (PEsub ?X1 _) => X1 end in
let expr4 := match re with (PEsub _ ?X1 ) => X1 end in
let re1 := eval vm_compute in (Nsimpl (PEsub expr1 expr3)) in
let
 re1' :=
  eval
     unfold
      Nconvert_back, convert_back,  PolAuxList.pos_nth,  PolAuxList.jump, 
         PolAuxList.hd,  PolAuxList.tl in (Nconvert_back (PEadd re1 expr3) fv) in
let re1'' := eval lazy beta in re1' in
let re1''' := clean_zabs_N re1'' in
let
 re2' :=
  eval
     unfold
      Nconvert_back, convert_back,  PolAuxList.pos_nth,  PolAuxList.jump, 
         PolAuxList.hd,  PolAuxList.tl in (Nconvert_back (PEadd re1 expr4) fv) in
let re2'' := eval lazy beta in re2' in
let re2''' := clean_zabs_N re2'' in
replace2_tac term1 term2 re1''' re2'''; [idtac | ring | ring].

Ltac
Npols :=
match goal with
| |- (?X1 = ?X2)%N =>
Ns X1 X2; apply Nplus_eq_compat_l
| |- (?X1 <> ?X2)%N =>
Ns X1 X2; apply Nplus_neg_compat_l
| |- (?X1 < ?X2)%N =>
Ns X1 X2; apply Nplus_lt_compat_l
| |- (?X1 > ?X2)%N =>
Ns X1 X2; apply Nplus_gt_compat_l
| |- (?X1 <= ?X2)%N =>
Ns X1 X2; apply Nplus_le_compat_l
| |- (?X1 >= ?X2)%N =>
Ns X1 X2; apply Nplus_ge_compat_l
| _ => fail end.

Ltac
hyp_Npols H :=
generalize H;
let tmp := fresh "tmp" in
match (type of H) with
   (?X1 = ?X2)%N =>
Ns X1 X2; intros tmp; generalize (Nplus_reg_l _ _ _ tmp); clear H tmp; intro H
|  (?X1 <> ?X2)%N =>
Ns X1 X2; intros tmp; generalize (Nplus_neg_reg_l _ _ _ tmp); clear H tmp; intro H
|  (?X1 < ?X2)%N =>
Ns X1 X2; intros tmp; generalize (Nplus_lt_reg_l _ _ _ tmp); clear H tmp; intro H
|  (?X1 > ?X2)%N =>
Ns X1 X2; intros tmp; generalize (Nplus_gt_reg_l _ _ _ tmp); clear H tmp; intro H
|  (?X1 <= ?X2)%N =>
Ns X1 X2; intros tmp; generalize (Nplus_le_reg_l _ _ _ tmp); clear H tmp; intro H
|  (?X1 >= ?X2)%N =>
Ns X1 X2; intros tmp; generalize (Nplus_ge_reg_l _ _ _ tmp); clear H tmp; intro H
| _ => fail end. *)
Require Export ArithRing.
Require Export NArithRing.

Ltac pols :=  npols || Npols || zpols || rpols.

Ltac hyp_pols H :=  hyp_npols H || hyp_Npols H || hyp_zpols H || hyp_rpols H.

Require Import RPolF.
(* RPolF:
Require Import ZArith.
Require Import Reals.
Require Import RPolS.
Require Import PolSBase.
Require Import PolFBase.
Require Import PolAux.
Require Import PolAuxList.
Require Import RSignTac.

Definition Rfactor :=
  factor Z Zplus Zmult Z.opp 0%Z 1%Z is_Z1 is_Z0 is_Zpos is_Zdiv Z.div Zgcd.

Definition Rfactor_minus :=
  factor_sub Z Zplus Zmult Z.opp 0%Z 1%Z is_Z1 is_Z0 is_Zpos is_Zdiv Z.div Zgcd.

Ltac Rfactor_term term1 term2 :=
let term := constr:(Rminus term1 term2) in
let rfv := FV RCst Rplus Rmult Rminus Ropp term (@nil R) in
let fv := Trev rfv in
let expr1 := mkPolexpr Z RCst Rplus Rmult Rminus Ropp term1 fv in
let expr2 := mkPolexpr Z RCst Rplus Rmult Rminus Ropp term2 fv in
let re := eval vm_compute in (Rfactor_minus (PEsub expr1 expr2)) in
let factor := match re with (PEmul ?X1 _) => X1 end in
let expr3 := match re with (PEmul _ (PEsub ?X1 _)) => X1 end in
let expr4 := match re with (PEmul _ (PEsub _ ?X1 )) => X1 end in
let
 re1' :=
  eval
     unfold
      Rconvert_back, convert_back,  pos_nth,  jump,
         hd,  tl, Z2R, P2R in (Rconvert_back (PEmul factor expr3) fv) in
let re1'' := eval lazy beta in re1' in
let
 re2' :=
  eval
     unfold
      Rconvert_back, convert_back,  pos_nth,  jump,
         hd,  tl, Z2R, P2R in (Rconvert_back (PEmul factor expr4) fv) in
let re2'' := eval lazy beta in re2' in
replace2_tac term1 term2 re1'' re2''; [idtac| ring | ring].

Ltac rpolf :=
progress (
(try
match goal with
| |- (?X1 = ?X2)%R =>  Rfactor_term X1 X2
| |- (?X1 <> ?X2)%R =>  Rfactor_term X1 X2
| |- Rlt ?X1 ?X2 => Rfactor_term X1 X2
| |- Rgt ?X1 ?X2 =>Rfactor_term X1 X2
| |- Rle ?X1 ?X2 => Rfactor_term X1 X2
| |- Rge ?X1 ?X2 =>Rfactor_term X1 X2
| _ => fail end)); try (rsign_tac); try repeat (rewrite Rmult_1_l || rewrite Rmult_1_r).

Ltac hyp_rpolf H :=
progress (
generalize H;
(try
match type of H with
  (?X1 = ?X2)%R =>  Rfactor_term X1 X2
| (?X1 <> ?X2)%R =>  Rfactor_term X1 X2
| Rlt ?X1 ?X2 => Rfactor_term X1 X2
| Rgt ?X1 ?X2 =>Rfactor_term X1 X2
| Rle ?X1 ?X2 => Rfactor_term X1 X2
| Rge ?X1 ?X2 =>Rfactor_term X1 X2
| _ => fail end)); clear H; intros H; try (hyp_rsign_tac H); try repeat rewrite Rmult_1_l in H. *)
Require Import ZPolF.
(* ZPolF:
Require Import ZArith.
Require Import ZPolS.
Require Import PolSBase.
Require Import PolFBase.
Require Import PolAux.
Require Import PolAuxList.
Require Import ZSignTac.

Definition Zfactor := 
  factor Z Zplus Zmult Z.opp 0%Z 1%Z is_Z1 is_Z0 is_Zpos is_Zdiv Z.div Zgcd.

Definition Zfactor_minus := 
  factor_sub Z Zplus Zmult Z.opp 0%Z 1%Z is_Z1 is_Z0 is_Zpos is_Zdiv Z.div Zgcd.

Definition Zget_delta := 
 get_delta Z Zplus Zmult Z.opp 0%Z 1%Z is_Z1 is_Z0 is_Zpos is_Zdiv Z.div Zgcd.

Ltac
Zfactor_term term1 term2 :=
let term := constr:(Zminus term1 term2) in
let rfv := FV ZCst Zplus Zmult Zminus Z.opp term (@nil Z) in
let fv := Trev rfv in
let expr1 := mkPolexpr Z ZCst Zplus Zmult Zminus Z.opp term1 fv in
let expr2 := mkPolexpr Z ZCst Zplus Zmult Zminus Z.opp term2 fv in
let re := eval vm_compute in (Zfactor_minus (PEsub expr1 expr2)) in
let factor := match re with (PEmul ?X1 _) => X1 end in
let expr3 := match re with (PEmul _ (PEsub ?X1 _)) => X1 end in
let expr4 := match re with (PEmul _ (PEsub _ ?X1 )) => X1 end in
let
 re1' :=
  eval
     unfold
      Zconvert_back, convert_back,  pos_nth,  jump, 
         hd,  tl in (Zconvert_back (PEmul factor expr3) fv) in
let re1'' := eval lazy beta in re1' in
let
 re2' :=
  eval
     unfold
      Zconvert_back, convert_back,  pos_nth,  jump, 
         hd,  tl in (Zconvert_back (PEmul factor expr4) fv) in
let re2'' := eval lazy beta in re2' in 
replace2_tac term1 term2 re1'' re2''; [idtac| ring | ring].

Ltac zpolf :=
 (
(try 
match goal with
| |- (?X1 = ?X2)%Z =>  Zfactor_term X1 X2 
| |- (?X1 <> ?X2)%Z =>  Zfactor_term X1 X2 
| |- Z.lt ?X1 ?X2 => Zfactor_term X1 X2
| |- Z.gt ?X1 ?X2 =>Zfactor_term X1 X2
| |- Z.le ?X1 ?X2 => Zfactor_term X1 X2
| |- Z.ge ?X1 ?X2 =>Zfactor_term X1 X2
| _ => fail end));  try (zsign_tac); try repeat (rewrite Zmult_1_l || rewrite Zmult_1_r).

Ltac hyp_zpolf H := 
progress (
generalize H; 
(try 
match type of H with
  (?X1 = ?X2)%Z =>  Zfactor_term X1 X2 
| (?X1 <> ?X2)%Z =>  Zfactor_term X1 X2 
| Z.lt ?X1 ?X2 => Zfactor_term X1 X2
| Z.gt ?X1 ?X2 =>Zfactor_term X1 X2
| Z.le ?X1 ?X2 => Zfactor_term X1 X2 
| Z.ge ?X1 ?X2 =>Zfactor_term X1 X2
| _ => fail end)); clear H; intros H; try hyp_zsign_tac H; try repeat rewrite Zmult_1_l. *)
Require Import NatPolF.
(* NatPolF:
Require Import ZArith.
Require Import NatPolS.
Require Import PolSBase.
Require Import PolFBase.
Require Import PolAux.
Require Import PolAuxList.
Require Import NatSignTac.

Definition Zfactor := 
  factor Z Zplus Zmult Z.opp 0%Z 1%Z is_Z1 is_Z0 is_Zpos is_Zdiv Z.div Zgcd.

Definition Zfactor_minus := 
  factor_sub Z Zplus Zmult Z.opp 0%Z 1%Z is_Z1 is_Z0 is_Zpos is_Zdiv Z.div Zgcd.

Definition Zget_delta := 
 get_delta Z Zplus Zmult Z.opp 0%Z 1%Z is_Z1 is_Z0 is_Zpos is_Zdiv Z.div Zgcd.

Ltac
Natfactor_term term1 term2 :=
let term := constr:(minus term1 term2) in
let rfv := FV NatCst plus mult minus Natopp term (@nil nat) in
let fv := Trev rfv in
let expr1 := mkPolexpr Z NatCst plus mult minus Natopp term1 fv in
let expr2 := mkPolexpr Z NatCst plus mult minus Natopp term2 fv in
let re := eval vm_compute in (Zfactor_minus (PEsub expr1 expr2)) in
let factor := match re with (PEmul ?X1 _) => X1 end in
let expr3 := match re with (PEmul _ (PEsub ?X1 _)) => X1 end in
let expr4 := match re with (PEmul _ (PEsub _ ?X1 )) => X1 end in
let
 re1' :=
  eval
     unfold
      Natconvert_back, convert_back,  pos_nth,  jump, 
         hd,  tl in (Natconvert_back (PEmul factor expr3) fv) in
let re1'' := eval lazy beta in re1' in
let re1''' := clean_zabs re1'' in
let
 re2' :=
  eval
     unfold
      Natconvert_back, convert_back,  pos_nth,  jump, 
         hd,  tl in (Natconvert_back (PEmul factor expr4) fv) in
let re2'' := eval lazy beta in re2' in 
let re2''' := clean_zabs re2'' in
replace2_tac term1 term2 re1''' re2'''; [idtac| ring | ring].

Ltac npolf :=
progress (
(try 
match goal with
| |- (?X1 = ?X2)%nat =>  Natfactor_term X1 X2 
| |- (?X1 <> ?X2)%nat =>  Natfactor_term X1 X2 
| |- lt ?X1 ?X2 => Natfactor_term X1 X2
| |- gt ?X1 ?X2 =>Natfactor_term X1 X2
| |- le ?X1 ?X2 => Natfactor_term X1 X2
| |- ge ?X1 ?X2 =>Natfactor_term X1 X2
| _ => fail end)); try (nsign_tac); try repeat (rewrite mult_1_l || rewrite mult_1_r).

Ltac hyp_npolf H := 
progress (
generalize H; 
(try 
match type of H with
  (?X1 = ?X2)%nat =>  Natfactor_term X1 X2 
| (?X1 <> ?X2)%nat =>  Natfactor_term X1 X2 
| lt ?X1 ?X2 => Natfactor_term X1 X2
| gt ?X1 ?X2 =>Natfactor_term X1 X2
| le ?X1 ?X2 => Natfactor_term X1 X2 
| ge ?X1 ?X2 =>Natfactor_term X1 X2
| _ => fail end)); clear H; intros H; try hyp_nsign_tac H; try repeat rewrite mult_1_l in H. *)
Require Import NPolF.
(* NPolF:
Require Import ZArith.
Require Import NAux.
Require Import NPolS.
Require Import PolSBase.
Require Import PolFBase.
Require Import PolAux.
Require Import PolAuxList.
Require Import NSignTac.

Definition Zfactor := 
  factor Z Zplus Zmult Z.opp 0%Z 1%Z is_Z1 is_Z0 is_Zpos is_Zdiv Z.div Zgcd.

Definition Zfactor_minus := 
  factor_sub Z Zplus Zmult Z.opp 0%Z 1%Z is_Z1 is_Z0 is_Zpos is_Zdiv Z.div Zgcd.

Definition Zget_delta := 
 get_delta Z Zplus Zmult Z.opp 0%Z 1%Z is_Z1 is_Z0 is_Zpos is_Zdiv Z.div Zgcd.

Ltac
Nfactor_term term1 term2 :=
let term := constr:(Nminus term1 term2) in
let rfv := FV NCst Nplus Nmult Nminus Nopp term (@nil N) in
let fv := Trev rfv in
let expr1 := mkPolexpr Z NCst Nplus Nmult Nminus Nopp term1 fv in
let expr2 := mkPolexpr Z NCst Nplus Nmult Nminus Nopp term2 fv in
let re := eval vm_compute in (Zfactor_minus (PEsub expr1 expr2)) in
let factor := match re with (PEmul ?X1 _) => X1 end in
let expr3 := match re with (PEmul _ (PEsub ?X1 _)) => X1 end in
let expr4 := match re with (PEmul _ (PEsub _ ?X1 )) => X1 end in
let
 re1' :=
  eval
     unfold
      Nconvert_back, convert_back,  pos_nth,  jump, 
         hd,  tl in (Nconvert_back (PEmul factor expr3) fv) in
let re1'' := eval lazy beta in re1' in
let re1''' := clean_zabs_N re1'' in
let
 re2' :=
  eval
     unfold
      Nconvert_back, convert_back,  pos_nth,  jump, 
         hd,  tl in (Nconvert_back (PEmul factor expr4) fv) in
let re2'' := eval lazy beta in re2' in 
let re2''' := clean_zabs_N re2'' in
replace2_tac term1 term2 re1''' re2'''; [idtac| ring | ring].

Ltac Npolf :=
progress (
(try 
match goal with
| |- (?X1 = ?X2)%N =>  Nfactor_term X1 X2 
| |- (?X1 <> ?X2)%N =>  Nfactor_term X1 X2 
| |- N.lt ?X1 ?X2 => Nfactor_term X1 X2
| |- N.gt ?X1 ?X2 =>Nfactor_term X1 X2
| |- N.le ?X1 ?X2 => Nfactor_term X1 X2
| |- N.ge ?X1 ?X2 =>Nfactor_term X1 X2
| _ => fail end)); try (Nsign_tac); try repeat (rewrite Nmult_1_l || rewrite Nmult_1_r).

Ltac hyp_Npolf H := 
progress (
generalize H; 
(try 
match type of H with
  (?X1 = ?X2)%N =>  Nfactor_term X1 X2 
| (?X1 <> ?X2)%N =>  Nfactor_term X1 X2 
| N.lt ?X1 ?X2 => Nfactor_term X1 X2
| N.gt ?X1 ?X2 =>Nfactor_term X1 X2
| N.le ?X1 ?X2 => Nfactor_term X1 X2 
| N.ge ?X1 ?X2 =>Nfactor_term X1 X2
| _ => fail end)); clear H; intros H; try hyp_Nsign_tac H; try repeat rewrite Nmult_1_l in H. *)
Require Export ArithRing.

Ltac polf :=  npolf || Npolf || zpolf || rpolf.

Ltac hyp_polf H := hyp_npolf H || hyp_Npolf H || hyp_zpolf H || hyp_rpolf H.

Require Import RPolR.
(* RPolR:
Require Import ZArith.
Require Import Reals.
Require Import PolSBase.
Require Import PolAux.
Require Import PolAuxList.
Require Import RPolS.
Require Import RPolF.
Require Import PolRBase.

Definition Rreplace_term_aux :=
  replace Z Zplus Zmult Z.opp 0%Z 1%Z is_Z1 is_Z0 is_Zpos is_Zdiv Z.div.

Ltac
Rreplace_term term from to occ id :=
let rfv := FV RCst Rplus Rmult Rminus Ropp term (@nil R) in
let rfv1 := FV RCst Rplus Rmult Rminus Ropp from rfv in
let rfv2 := FV RCst Rplus Rmult Rminus Ropp to rfv1 in
let fv := Trev rfv2 in
let expr := mkPolexpr Z RCst Rplus Rmult Rminus Ropp term fv in
let expr_from := mkPolexpr Z RCst Rplus Rmult Rminus Ropp from fv in
let expr_to := mkPolexpr Z RCst Rplus Rmult Rminus Ropp to fv in
let re := eval vm_compute in (Rreplace_term_aux expr expr_from expr_to occ) in
let term1 := eval
     unfold Rconvert_back, convert_back,  pos_nth,  jump,
         hd,  tl, Z2R, P2R in (Rconvert_back re fv) in
match id with
     true => term1
  | false =>
     match eqterm term term1 with
       |false => term1
    end
end
.

Ltac rpol_is_compare term :=
match term with
| (_ < _)%R => constr:(true)
| (_ > _)%R => constr:(true)
| (_ <= _)%R => constr:(true)
| (_ >= _)%R => constr:(true)
| (?X = _)%R => match type of X with R => constr:(true) end
| _ => constr:(false)
end.

Ltac rpol_get_term dir term :=
match term with
|  (?op ?X  ?Y)%R =>
     match dir with P.L => X | P.R => Y end
|  (?X = ?Y)%R =>
     match dir with P.L => X | P.R => Y end
| _ => fail 1 "Unknown term in pol_get_term"
end.

Ltac rpol_replace_term term1 term2 dir1 dir2 occ id :=
  let dir2opp := eval compute in (P.pol_dir_opp dir2) in
  let t1 := rpol_get_term dir2 term2 in
  let t2 := match id with true => t1 | false => rpol_get_term dir2opp term2 end in
 match term1 with
   | (?op ?X ?Y) =>
     match dir1 with
       P.L  =>
             Rreplace_term X t1 t2 occ id
       | P.R =>
            Rreplace_term Y t1 t2 occ id
      end
  | (?X = ?Y)%R  =>
     match dir1 with
       P.L  =>
             Rreplace_term X t1 t2 occ id
     | P.R =>
             Rreplace_term Y  t1 t2 occ id
      end
  end.

Ltac rpol_aux_dir term dir :=
  match term with
   (_ < _)%R => dir
  | (_ > _)%R => dir
  | (_ <= _)%R => eval compute in (P.pol_dir_opp dir)
  | (_ >= _)%R  => eval compute in (P.pol_dir_opp dir)
end.

Ltac R_eq_trans_l t:=
   match goal with
     |  |- (?X >= ?Y)%R => apply eq_Rge_trans_l with t
     |  |- (?X > ?Y)%R => apply eq_Rgt_trans_l with t
     |  |- (?X <= ?Y)%R => apply eq_Rle_trans_l with t
     |  |- (?X < ?Y)%R => apply eq_Rlt_trans_l with t
     |  |- ?G  => apply trans_equal with t
    end.

Ltac R_eq_trans_r t:=
   match goal with
     |  |- (?X >= ?Y)%R => apply eq_Rge_trans_r with t
     |  |- (?X > ?Y)%R => apply eq_Rgt_trans_r with t
     |  |- (?X <= ?Y)%R => apply eq_Rle_trans_r with t
     |  |- (?X < ?Y)%R => apply eq_Rlt_trans_r with t
     |  |- ?G  => apply trans_equal_r with t
    end.

Ltac Rreplace_tac_full term dir1 dir2 occ :=
match term with
 (?T1 = ?T2)%R =>
  
  match goal with
     |-  ?G => let  t := rpol_replace_term G term dir1 dir2 occ false in
              match dir1 with
               P.L => R_eq_trans_l t
              | P.R => R_eq_trans_r t
              end
  end
| _ =>
   match goal with
     |- (?X <= ?Y)%R  =>
            let  t := rpol_replace_term (X <= Y)%R term dir1 dir2 occ false in
               apply Rle_trans with t
     |  |- (?X >= ?Y)%R =>
            let  t := rpol_replace_term (X >= Y)%R term dir1 dir2 occ false in
               apply Rge_trans with t
     | |- (?X < ?Y)%R  =>
           let  t := rpol_replace_term (X < Y)%R term dir1 dir2 occ false in
           match rpol_aux_dir term dir1 with
                P.L =>
                                    (apply Rlt_le_trans with t)
               |P.R =>
                                    (apply Rle_lt_trans with t)
            end
     | |- (?X > ?Y)%R   =>
            let  t := rpol_replace_term (X > Y)%R term dir1 dir2 occ false in
           match rpol_aux_dir term dir1 with
                P.L =>
                                    (apply Rgt_ge_trans with t)
               |P.R =>
                                    (apply Rge_gt_trans with t)
            end
   end
end.

Ltac Rreplace_tac_full_id term dir1 dir2 occ :=
  match goal with
     |-  ?G => let t1 := rpol_replace_term G term dir1 dir2 occ true in
                match dir1 with
                  P.L => R_eq_trans_l t1
               | P.R => R_eq_trans_r t1
                end; [ring | idtac]
end.

Ltac rpolrx term dir1 dir2 occ :=
match rpol_is_compare term with
  true => Rreplace_tac_full_id term dir1 dir2 occ; [Rreplace_tac_full term dir1 dir2 occ]
| false =>
     let t := type of term in
     match rpol_is_compare t with  true =>
       Rreplace_tac_full_id t dir1 dir2 occ; [Rreplace_tac_full t dir1 dir2 occ]
     end
end.

Ltac rpolr term :=
  rpolrx term P.L P.L 1%Z ||
  rpolrx term P.R P.L 1%Z ||
  rpolrx term P.L P.R 1%Z ||
  rpolrx term P.R P.R 1%Z. *)
Require Import ZPolR.
(* ZPolR:
Require Import ZArith.
Require Import PolSBase.
Require Import PolAux.
Require Import PolAuxList.
Require Import ZPolS.
Require Import ZPolF.
Require Import PolRBase.

Definition Zreplace_term_aux :=
  replace Z Zplus Zmult Z.opp 0%Z 1%Z is_Z1 is_Z0 is_Zpos is_Zdiv Z.div.

Ltac
Zreplace_term term from to occ id :=
let rfv := FV ZCst Zplus Zmult Zminus Z.opp term (@nil Z) in
let rfv1 := FV ZCst Zplus Zmult Zminus Z.opp from rfv in
let rfv2 := FV ZCst Zplus Zmult Zminus Z.opp to rfv1 in
let fv := Trev rfv2 in
let expr := mkPolexpr Z ZCst Zplus Zmult Zminus Z.opp term fv in
let expr_from := mkPolexpr Z ZCst Zplus Zmult Zminus Z.opp from fv in
let expr_to := mkPolexpr Z ZCst Zplus Zmult Zminus Z.opp to fv in
let re := eval vm_compute in (Zreplace_term_aux expr expr_from expr_to occ) in
let term1 := eval
     unfold Zconvert_back, convert_back,  pos_nth,  jump,
         hd,  tl in (Zconvert_back re fv) in
match id with 
     true => term1
  | false =>
     match eqterm term term1 with
       |false => term1
    end
end
.

Ltac zpol_is_compare term :=
match term with
| (_ < _)%Z => constr:(true)
| (_ > _)%Z => constr:(true)
| (_ <= _)%Z => constr:(true)
| (_ >= _)%Z => constr:(true)
| (?X = _)%Z => match type of X with Z => constr:(true) end 
| _ => constr:(false)
end.

Ltac zpol_get_term dir term :=
match term with
|  (?op ?X  ?Y)%Z =>
     match dir with P.L => X | P.R => Y end
|  (?X = ?Y)%Z =>
     match dir with P.L => X | P.R => Y end
| _ => fail 1 "Unknown term in zpolget_term"
end.

Ltac zpol_replace_term term1 term2 dir1 dir2 occ id := 
  let dir2opp := eval vm_compute in (P.pol_dir_opp dir2) in
  let t1 := zpol_get_term dir2 term2 in
  let t2 := match id with true => t1 | false => zpol_get_term dir2opp term2 end in
  match term1 with
   | (?op ?X ?Y) =>
     match dir1 with
         P.L  =>
             Zreplace_term X t1 t2 occ id
       | P.R => 
            Zreplace_term Y t1 t2 occ id
      end
  | (?X = ?Y)%Z  =>
     match dir1 with
       P.L  =>
             Zreplace_term X t1 t2 occ id
     | P.R => 
             Zreplace_term Y  t1 t2 occ id
      end
  end.

Ltac zpol_aux_dir term dir :=
  match term with
   (_ < _)%Z => dir
  | (_ > _)%Z => dir
  | (_ <= _)%Z => eval compute in (P.pol_dir_opp dir) 
  | (_ >= _)%Z  => eval compute in (P.pol_dir_opp dir) 
end.

Ltac Zreplace_tac_full term dir1 dir2 occ :=
match term with
 (?T1 = ?T2)%Z =>
  
  match goal with
     |-  ?G => let  t := zpol_replace_term G term dir1 dir2 occ false in
              match dir1 with
               P.L =>
                      apply trans_equal with t ||
                      apply eq_Zlt_trans_l with t || apply eq_Zgt_trans_l with t ||
                       apply eq_Zle_trans_l with t || apply eq_Zge_trans_l with t
              | P.R =>
                     apply trans_equal_r with t ||
                       apply eq_Zlt_trans_r with t || apply eq_Zgt_trans_r with t ||
                       apply eq_Zle_trans_r with t || apply eq_Zge_trans_r with t
              end
  end
| _ =>
   match goal with
     |- (?X <= ?Y)%Z  =>
            let  t := zpol_replace_term (X <= Y)%Z term dir1 dir2 occ false in
               apply Z.le_trans with t
     |  |- (?X >= ?Y)%Z =>
            let  t := zpol_replace_term (X >= Y)%Z term dir1 dir2 occ false in
               apply Zge_trans with t
     | |- ?G  =>
            let  t := zpol_replace_term G term dir1 dir2 occ false in
           match zpol_aux_dir term dir1 with
                P.L =>
                                    (apply Z.lt_le_trans with t || apply Zgt_le_trans with t)
               |P.R =>
                                    (apply Z.le_lt_trans with t || apply Zle_gt_trans with t)
            end
   end
end.

Ltac Zreplace_tac_full_id term dir1 dir2 occ :=
  match goal with
     |-  ?G => let t1 := zpol_replace_term G term dir1 dir2 occ true in 
                match dir1 with
                  P.L =>
                       apply trans_equal with t1 ||
                       apply eq_Zlt_trans_l with t1 ||
                       apply eq_Zgt_trans_l with t1 ||
                       apply eq_Zle_trans_l with t1 ||
                       apply eq_Zge_trans_l with t1
               | P.R =>
                      apply trans_equal_r with t1 ||
                      apply eq_Zlt_trans_r with t1 ||
                      apply eq_Zgt_trans_r with t1  ||
                      apply eq_Zle_trans_r with t1 ||
                      apply eq_Zge_trans_r with t1
                end; [ring | idtac]
end.

Ltac zpolrx term dir1 dir2 occ :=
match zpol_is_compare term with
  true => Zreplace_tac_full_id term dir1 dir2 occ; 
                [Zreplace_tac_full term dir1 dir2 occ] 
| false => 
     let t := type of term in
     match zpol_is_compare t with true => Zreplace_tac_full_id t dir1 dir2 occ;
                                                                       [Zreplace_tac_full t dir1 dir2 occ]
     end 
end.

Ltac zpolr term :=
  zpolrx term P.L P.L 1%Z ||
  zpolrx term P.R P.L 1%Z ||
  zpolrx term P.L P.R 1%Z ||
  zpolrx term P.R P.R 1%Z. *)
Require Import NatPolR.
(* NatPolR:
Require Import ZArith.
Require Import PolSBase.
Require Import PolAux.
Require Import PolAuxList.
Require Import NatPolS.
Require Import NatPolF.
Require Import PolRBase.
 
Definition Natreplace_term_aux :=
  replace Z Zplus Zmult Z.opp 0%Z 1%Z is_Z1 is_Z0 is_Zpos is_Zdiv Z.div.

Ltac
Natreplace_term term from to occ id :=
let rfv := FV NatCst plus mult minus Natopp term (@nil nat) in
let rfv1 := FV NatCst plus mult minus Natopp from rfv in
let rfv2 := FV NatCst plus mult minus Natopp to rfv1 in
let fv := Trev rfv2 in
let expr := mkPolexpr Z NatCst plus mult minus Natopp term fv in
let expr_from := mkPolexpr Z NatCst plus mult minus Natopp from fv in
let expr_to := mkPolexpr Z NatCst plus mult minus Natopp to fv in
let re := eval vm_compute in (Natreplace_term_aux expr expr_from expr_to occ) in
let term1 := eval
     unfold Natconvert_back, convert_back,  pos_nth,  jump,
         hd,  tl in (Natconvert_back re fv) in
let term2 := clean_zabs term1 in
match id with 
     true => term2
  | false =>
     match eqterm term term1 with
       |false => term2
    end
end
.

Ltac npol_is_compare term :=
match term with
| (_ < _)%nat => constr:(true)
| (_ > _)%nat => constr:(true)
| (_ <= _)%nat => constr:(true)
| (_ >= _)%nat => constr:(true)
| (?X = _)%nat => match type of X with nat => constr:(true) end
| _ => constr:(false)
end.

Ltac npol_get_term dir term :=
match term with
|  (?op ?X  ?Y)%nat =>
     match dir with P.L => X | P.R => Y end
|  (?X = ?Y)%nat =>
     match dir with P.L => X | P.R => Y end
| _ => fail 1 "Unknown term in npol_get_term"
end.

Ltac npol_replace_term term1 term2 dir1 dir2 occ id := 
  let dir2opp := eval compute in (P.pol_dir_opp dir2) in
  let t1 := npol_get_term dir2 term2 in
  let t2 := match id with true => t1 | false => npol_get_term dir2opp term2 end in
  match term1 with
   | (?op ?X ?Y) =>
     match dir1 with
         P.L  =>
             Natreplace_term X t1 t2 occ id
       | P.R => 
            Natreplace_term Y t1 t2 occ id
      end
  | (?X = ?Y)%nat  =>
     match dir1 with
       P.L  =>
             Natreplace_term X t1 t2 occ id
     | P.R => 
             Natreplace_term Y  t1 t2 occ id
      end
  end.

Ltac npol_aux_dir term dir :=
  match term with
   (_ < _)%nat => dir
  | (_ > _)%nat => dir
  | (_ <= _)%nat => eval compute in (P.pol_dir_opp dir) 
  | (_ >= _)%nat => eval compute in (P.pol_dir_opp dir) 
end.

Ltac Nat_eq_trans_l t:= 
   match goal with
     |  |- (?X >= ?Y)%nat => apply eq_ge_trans_l with t 
     |  |- (?X > ?Y)%nat => apply eq_gt_trans_l with t 
     |  |- (?X <= ?Y)%nat => apply eq_le_trans_l with t 
     |  |- (?X < ?Y)%nat => apply eq_lt_trans_l with t 
     |  |- ?G  => apply trans_equal with t 
    end.

Ltac Nat_eq_trans_r t:= 
   match goal with
     |  |- (?X >= ?Y)%nat => apply eq_ge_trans_r with t 
     |  |- (?X > ?Y)%nat => apply eq_gt_trans_r with t 
     |  |- (?X <= ?Y)%nat => apply eq_le_trans_r with t 
     |  |- (?X < ?Y)%nat => apply eq_lt_trans_r with t 
     |  |- ?G  => apply trans_equal_r with t 
    end.

Ltac Natreplace_tac_full term dir1 dir2 occ :=
match term with
 (?T1 = ?T2)%nat =>
  
  match goal with
     |-  ?G => let  t := npol_replace_term G term dir1 dir2 occ false in
              match dir1 with
               P.L => Nat_eq_trans_l t
              | P.R => Nat_eq_trans_r t
              end
  end
| _ =>
   match goal with
     |  |- (?X >= ?Y)%nat =>
            let  t := npol_replace_term (X >= Y)%nat term dir1 dir2 occ false in
               apply ge_trans with t
     |  |- (?X <= ?Y)%nat =>
            let  t := npol_replace_term (X <= Y)%nat term dir1 dir2 occ false in
               apply le_trans with t
     |  |- (?X > ?Y)%nat  =>
            let  t := npol_replace_term (X > Y)%nat term dir1 dir2 occ false in
           match npol_aux_dir term dir1 with
                P.L =>
                                    (apply gt_le_trans with t)
               |P.R =>
                                    (apply le_gt_trans with t)
            end
     |  |- (?X < ?Y)%nat   =>
            let  t := npol_replace_term (X < Y)%nat term dir1 dir2 occ false in
           match npol_aux_dir term dir1 with
                P.L =>
                                    (apply lt_le_trans with t)
               |P.R =>
                                    (apply le_lt_trans with t)
            end
   end
end.

Ltac Natreplace_tac_full_id term dir1 dir2 occ :=
  match goal with
     |-  ?G => let t1 := npol_replace_term G term dir1 dir2 occ true in 
                match dir1 with
                  P.L => Nat_eq_trans_l t1
               | P.R => Nat_eq_trans_r t1
                end; [ring | idtac]
end.

Ltac npolrx term dir1 dir2 occ :=
match npol_is_compare term with
  true => Natreplace_tac_full_id term dir1 dir2 occ; [Natreplace_tac_full term dir1 dir2 occ]
| false => 
     let t := type of term in
     match npol_is_compare t with true => 
Natreplace_tac_full_id t dir1 dir2 occ; [Natreplace_tac_full t dir1 dir2 occ]
     end 
end.

Ltac npolr term :=
  npolrx term P.L P.L 1%Z  ||
  npolrx term P.R P.L 1%Z ||
  npolrx term P.L P.R 1%Z ||
  npolrx term P.R P.R 1%Z. *)
Require Import NPolR.
(* NPolR:
Require Import ZArith.
Require Import NAux.
Require Import PolSBase.
Require Import PolAux.
Require Import PolAuxList.
Require Import NPolS.
Require Import NPolF.
Require Import PolRBase.
 
Definition Nreplace_term_aux :=
  replace Z Zplus Zmult Z.opp 0%Z 1%Z is_Z1 is_Z0 is_Zpos is_Zdiv Z.div.

Ltac
Nreplace_term term from to occ id :=
let rfv := FV NCst Nplus Nmult Nminus Nopp term (@nil N) in
let rfv1 := FV NCst Nplus Nmult Nminus Nopp from rfv in
let rfv2 := FV NCst Nplus Nmult Nminus Nopp to rfv1 in
let fv := Trev rfv2 in
let expr := mkPolexpr Z NCst Nplus Nmult Nminus Nopp term fv in
let expr_from := mkPolexpr Z NCst Nplus Nmult Nminus Nopp from fv in
let expr_to := mkPolexpr Z NCst Nplus Nmult Nminus Nopp to fv in
let re := eval vm_compute in (Nreplace_term_aux expr expr_from expr_to occ) in
let term1 := eval
     unfold Nconvert_back, convert_back,  pos_nth,  jump,
         hd,  tl in (Nconvert_back re fv) in
let term2 := clean_zabs_N term1 in
match id with 
     true => term2
  | false =>
     match eqterm term term1 with
       |false => term2
    end
end
.

Ltac Npol_is_compare term :=
match term with
| (_ < _)%N => constr:(true)
| (_ > _)%N => constr:(true)
| (_ <= _)%N => constr:(true)
| (_ >= _)%N => constr:(true)
| (?X = _)%N => match type of X with N => constr:(true) end
| _ => constr:(false)
end.

Ltac Npol_get_term dir term :=
match term with
|  (?op ?X  ?Y)%N =>
     match dir with P.L => X | P.R => Y end
|  (?X = ?Y)%N =>
     match dir with P.L => X | P.R => Y end
| _ => fail 1 "Unknown term in Npol_get_term"
end.

Ltac Npol_replace_term term1 term2 dir1 dir2 occ id := 
  let dir2opp := eval compute in (P.pol_dir_opp dir2) in
  let t1 := Npol_get_term dir2 term2 in
  let t2 := match id with true => t1 | false =>  Npol_get_term dir2opp term2 end in
 match term1 with
   | (?op ?X ?Y) =>
     match dir1 with
       P.L  =>
             Nreplace_term X t1 t2 occ id
       | P.R => 
            Nreplace_term Y t1 t2 occ id
      end
  | (?X = ?Y)%N  =>
     match dir1 with
       P.L  =>
             Nreplace_term X t1 t2 occ id
     | P.R => 
             Nreplace_term Y  t1 t2 occ id
      end
  end.

Ltac Npol_aux_dir term dir :=
  match term with
   (_ < _)%N => dir
  | (_ > _)%N => dir
  | (_ <= _)%N => eval compute in (P.pol_dir_opp dir) 
  | (_ >= _)%N => eval compute in (P.pol_dir_opp dir) 
end.

Ltac Nreplace_tac_full term dir1 dir2 occ :=
match term with
 (?T1 = ?T2)%N =>
  
  match goal with
     |-  ?G => let  t := Npol_replace_term G term dir1 dir2 occ false in
              match dir1 with
               P.L =>
                      apply trans_equal with t ||
                      apply Neq_lt_trans_l with t || apply Neq_gt_trans_l with t ||
                       apply Neq_le_trans_l with t || apply Neq_ge_trans_l with t
              | P.R =>
                     apply trans_equal_r with t ||
                       apply Neq_lt_trans_r with t || apply Neq_gt_trans_r with t ||
                       apply Neq_le_trans_r with t || apply Neq_ge_trans_r with t
              end
  end
| _ =>
   match goal with
     |- (?X <= ?Y)%N  =>
            let  t := Npol_replace_term (X <= Y)%N term dir1 dir2 occ false in
               apply N.le_trans with t
     |  |- (?X >= ?Y)%N =>
            let  t := Npol_replace_term (X >= Y)%N term dir1 dir2 occ false in
               apply Nge_trans with t
     | |- ?G  =>
            let  t := Npol_replace_term G term dir1 dir2 occ false in
           match Npol_aux_dir term dir1 with
                P.L =>
                                    (apply N.lt_le_trans with t || apply Ngt_le_trans with t)
               |P.R =>
                                    (apply N.le_lt_trans with t || apply Nle_gt_trans with t)
            end
   end
end.

Ltac Nreplace_tac_full_id term dir1 dir2 occ :=
  match goal with
     |-  ?G => let t1 := Npol_replace_term G term dir1 dir2 occ true in 
                match dir1 with
                  P.L =>
                       apply trans_equal with t1 ||
                       apply Neq_lt_trans_l with t1 ||
                       apply Neq_gt_trans_l with t1 ||
                       apply Neq_le_trans_l with t1 ||
                       apply Neq_ge_trans_l with t1
               | P.R =>
                      apply trans_equal_r with t1 ||
                      apply Neq_lt_trans_r with t1 ||
                      apply Neq_gt_trans_r with t1  ||
                      apply Neq_le_trans_r with t1 ||
                      apply Neq_ge_trans_r with t1
                end; [ring | idtac]
end.

Ltac Npolrx term dir1 dir2 occ :=
match Npol_is_compare term with
  true => Nreplace_tac_full_id term dir1 dir2 occ; [Nreplace_tac_full term dir1 dir2 occ] 
| false => 
     let t := type of term in
     match Npol_is_compare t with true => 
        Nreplace_tac_full_id t dir1 dir2 occ; [Nreplace_tac_full t dir1 dir2 occ]
     end 
end.

Ltac Npolr term :=
  Npolrx term P.L P.L 1%Z  ||
  Npolrx term P.R P.L 1%Z ||
  Npolrx term P.L P.R 1%Z ||
  Npolrx term P.R P.R 1%Z. *)

Ltac polr term :=  
match goal with |- ?G => 
 (let u := npol_is_compare G in npolr term)
||
 (let u := Npol_is_compare G in Npolr term)
||
(let u := zpol_is_compare G in zpolr term)
||
(let u := rpol_is_compare G in rpolr term)
end.

Ltac polrx term dir1 dir2 occ :=  
match goal with |- ?G => 
  (let u := npol_is_compare G in npolrx term dir1 dir2 occ)
||
  (let u := Npol_is_compare G in Npolrx term dir1 dir2 occ)
||
(let u := zpol_is_compare G in zpolrx term dir1 dir2 occ)
||
(let u := rpol_is_compare G in rpolrx term dir1 dir2 occ)
end.
