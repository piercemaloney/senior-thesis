Require Import Reals.
Require Import PolAux.
(* PolAux:
Require Import ZArith.
Require Import NArith.
Require Import NAux.
Require Export Replace2.
Require Import P.

Require Import Reals.

Definition Natopp := (fun x:nat => 0%nat).

Definition Nopp := (fun x:N => 0%N).

Definition is_Z0 := (Zeq_bool 0).
Definition is_Z1 := (Zeq_bool 1).
Definition is_Zpos := (Zle_bool 0).
Definition is_Zdiv :=
  fun x y => if Zeq_bool x Z0 then false else Zeq_bool Z0 (Zmod y x).
Definition Zgcd :=
 fun x y => (if (is_Zdiv x y) then x else if (is_Zdiv y x) then y else 1%Z).

Ltac is_NatCst p :=
  match p with
  | O => constr:(true)
  | S ?p' => is_NatCst p'
  | _ => constr:(false)
end.

Ltac NatCst t :=
  match is_NatCst t with
  | false => constr:(false)
  | _ => let res := eval compute in (Z_of_nat t) in constr:(res)
end.

Ltac is_PCst p :=
  match p with
  | xH => constr:(true)
  | xO ?p' => is_PCst p'
  | xI ?p' => is_PCst p'
  | _ => constr:(false)
end.

Ltac is_NCst p :=
  match p with
  | N0 => constr:(true)
  | Npos ?p' => is_PCst p'
  | _ => constr:(false)
end.

Ltac NCst t :=
  match is_NCst t with
  | false => constr:(false)
  | _ => let res := eval compute in (Z_of_N t) in constr:(res)
end.

Ltac ZCst t :=
  match t with
  | Z0 => constr:(t)
  | Zpos ?p => match is_PCst p with
               | false => constr:(false)
               | _ => constr:(t)
               end
  | Zneg ?p => match is_PCst p with
               | false => constr:(false)
               | _ => constr:(t)
               end
  | _ => constr:(false)
  end.

Ltac is_ZCst t := match t with
                | Z0 => constr:(true)
                | Zpos ?p => is_PCst p
                | Zneg ?p => is_PCst p
                | _ => constr:(false) end.

Fixpoint P2R (z: positive) {struct z}: R :=
  match z with
     xH => 1%R
  | (xO xH) => 2%R
  | (xI xH) => 3%R
  | (xO z1) => (2*(P2R z1))%R
  | (xI z1) => (1+2*(P2R z1))%R
 end.

Definition Z2R (z: Z): R :=
  match z with
     Z0 => 0%R
  | (Zpos z1) => (P2R z1)%R
  | (Zneg z1) => (-(P2R z1))%R
 end.

Ltac RCst t :=
  match t with
   | R0 => constr:(Z0)
   | R1 => constr:(Zpos xH)
   | Rplus ?e1 ?e2 =>
       match (RCst e1) with
        false => constr:(false)
      | ?e3 => match (RCst e2) with
                 false => constr:(false)
              |  ?e4 =>  eval vm_compute in (Zplus e3  e4)
              end
      end
   | Rminus ?e1 ?e2 =>
       match (RCst e1) with
        false => constr:(false)
      | ?e3 => match (RCst e2) with
                 false => constr:(false)
              |  ?e4 => eval vm_compute in (Zminus e3  e4)
              end
      end
   | Rmult ?e1 ?e2 =>
       match (RCst e1) with
        false => constr:(false)
      | ?e3 => match (RCst e2) with
                 false => constr:(false)
              |  ?e4 => eval vm_compute in (Zmult e3  e4)
              end
      end
   | Ropp ?e1 =>
       match (RCst e1) with
        false => constr:(false)
      | ?e3 => eval vm_compute in (Z.opp e3)
      end
   | IZR ?e1 =>
       match (ZCst e1) with
        false => constr:(false)
      | ?e3 => e3
      end

   | _ => constr:(false)
 end.

Ltac clean_zabs term :=
  match term with
   context id [(Z.abs_nat ?X)] =>
     match is_ZCst X with
       true =>
         let x := eval vm_compute in (Z.abs_nat X) in
         let y := context id [x] in
           clean_zabs y
     | false => term
     end
    | _ => term
  end.

Ltac clean_zabs_N term :=
  match term with
   context id [(Z.abs_N ?X)] =>
     match is_ZCst X with
       true =>
         let x := eval vm_compute in (Z.abs_N X) in
         let y := context id [x] in
           clean_zabs_N y
     | false => term
     end
    | _ => term
  end.

Ltac eqterm t1 t2 :=
  match constr:((t1,t2)) with (?X, ?X) => true | _ => false end.

Theorem trans_equal_r : forall (A: Set) (x y z:A), y = z -> x = y -> x = z.

Open Scope nat_scope.

Theorem plus_eq_compat_l: forall a b c, b = c -> a + b = a + c.

Theorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.

Theorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.

Theorem plus_neg_reg_l: forall a b c,  a + b <> a + c -> b <> c.

Theorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m.

Theorem eq_lt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).
Theorem eq_lt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).
Theorem eq_gt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).
Theorem eq_gt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).
Theorem eq_le_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).
Theorem eq_le_trans_r : forall x y z, (y = z) -> (x <= y) -> (x <= z).
Theorem eq_ge_trans_l : forall x y z, (x = z) -> (x >= y) -> (z >= y).
Theorem eq_ge_trans_r : forall x y z, (y = z) -> (x >= y) -> (x >= z).

Theorem ge_trans: forall x y z, (x >= z) -> (z >= y) -> (x >= y).

Close Scope nat_scope.

Open Scope N_scope.

Theorem Nplus_eq_compat_l: forall a b c, b = c -> a + b = a + c.

Theorem Nplus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.

Theorem Nplus_lt_compat_l: forall n m p, n < m -> p + n < p + m.

Theorem Nplus_gt_compat_l: forall n m p, n > m -> p + n > p + m.

Theorem Nplus_le_compat_l: forall n m p, n <= m -> p + n <= p + m.

Theorem Nplus_ge_compat_l: forall n m p, n >= m -> p + n >= p + m.

Theorem Nplus_neg_reg_l: forall a b c,  a + b <> a + c -> b <> c.

Theorem Nplus_lt_reg_l: forall n m p, p + n < p + m -> n < m.

Theorem Nplus_gt_reg_l: forall n m p, p + n > p + m -> n > m.

Theorem Nplus_le_reg_l: forall n m p, p + n <= p + m -> n <= m.

Theorem Nplus_ge_reg_l: forall n m p, p + n >= p + m -> n >= m.

Theorem Neq_lt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).

Theorem Neq_lt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).

Theorem Neq_gt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).
Theorem Neq_gt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).
Theorem Neq_le_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).
Theorem Neq_le_trans_r : forall x y z, (y = z) -> (x <= y) -> (x <= z).
Theorem Neq_ge_trans_l : forall x y z, (x = z) -> (x >= y) -> (z >= y).
Theorem Neq_ge_trans_r : forall x y z, (y = z) -> (x >= y) -> (x >= z).

Theorem Nge_trans: forall x y z, (x >= z) -> (z >= y) -> (x >= y).

Close Scope N_scope.

Open Scope Z_scope.

Theorem Zplus_eq_compat_l: forall a b c:Z, (b = c -> a + b = a + c)%Z.

Theorem Zplus_neg_compat_l: forall a b c: Z, (b <> c -> a + b <> a + c)%Z.

Theorem Zplus_ge_compat_l: forall n m p : Z, (n >= m -> p + n >= p + m)%Z.

Theorem Zplus_neg_reg_l: forall a b c: Z,  (a + b <> a + c -> b <> c)%Z.

Theorem Zplus_ge_reg_l: forall n m p : Z, (p + n >= p + m -> n >= m)%Z.

Theorem Zle_sign_pos_pos: forall x y: Z, (0 <= x -> 0 <= y  -> 0 <= x * y)%Z.

Theorem Zle_sign_neg_neg: forall x y: Z, (x <= 0 -> y <= 0  -> 0 <= x * y)%Z.

Theorem Zopp_le: forall n m, (m <= n -> -n <= -m)%Z.

Theorem Zle_pos_neg: forall x, (0 <= -x -> x <= 0)%Z.

Theorem Zle_sign_pos_neg: forall x y: Z, (0 <= x -> y <= 0  -> x * y <= 0)%Z.

Theorem Zle_sign_neg_pos: forall x y: Z, (x <= 0 -> 0 <= y  -> x * y <= 0)%Z.

Theorem Zlt_sign_pos_pos: forall x y: Z, (0 < x -> 0 < y  -> 0 < x * y)%Z.

Theorem Zlt_sign_neg_neg: forall x y: Z, (x < 0 -> y < 0  -> 0 < x * y)%Z.

Theorem Zlt_pos_neg: forall x, (0 < -x -> x < 0)%Z.

Theorem Zlt_sign_pos_neg: forall x y: Z, (0 < x -> y < 0  -> x * y < 0)%Z.

Theorem Zlt_sign_neg_pos: forall x y: Z, (x < 0 -> 0 < y  -> x * y < 0)%Z.

Theorem Zge_sign_neg_neg: forall x y: Z, (0 >= x -> 0 >= y  -> x * y >= 0)%Z.

Theorem Zge_sign_pos_pos: forall x y: Z, (x >= 0 -> y >= 0  -> x * y >= 0)%Z.

Theorem Zge_neg_pos: forall x, (0 >= -x -> x >= 0)%Z.

Theorem Zge_sign_neg_pos: forall x y: Z, (0 >= x -> y >= 0  -> 0>= x * y)%Z.

Theorem Zge_sign_pos_neg: forall x y: Z, (x >= 0 -> 0 >= y  -> 0 >= x * y)%Z.

Theorem Zgt_sign_neg_neg: forall x y: Z, (0 > x -> 0 > y  -> x * y > 0)%Z.

Theorem Zgt_sign_pos_pos: forall x y: Z, (x > 0 -> y > 0  -> x * y > 0)%Z.

Theorem Zgt_neg_pos: forall x, (0 > -x -> x > 0)%Z.

Theorem Zgt_sign_neg_pos: forall x y: Z, (0 > x -> y > 0  -> 0> x * y)%Z.

Theorem Zgt_sign_pos_neg: forall x y: Z, (x > 0 -> 0 > y  -> 0 > x * y)%Z.

Theorem Zle_sign_pos_pos_rev: forall x y: Z, (0 < x -> 0 <= x * y -> 0 <= y)%Z.

Theorem Zle_sign_neg_neg_rev: forall x y: Z, (x < 0 -> 0 <= x * y ->  y <= 0)%Z.

Theorem Zle_sign_pos_neg_rev: forall x y: Z, (0 < x -> x * y <= 0 -> y <= 0)%Z.

Theorem Zle_sign_neg_pos_rev: forall x y: Z, (x < 0 -> x * y <= 0 ->  0 <= y)%Z.

Theorem Zge_sign_pos_pos_rev: forall x y: Z, (x > 0 -> x * y >= 0 -> y >= 0)%Z.

Theorem Zge_sign_neg_neg_rev: forall x y: Z, (0 > x -> x * y  >= 0->  0 >= y)%Z.

Theorem Zge_sign_pos_neg_rev: forall x y: Z, (x > 0 -> 0 >= x * y -> 0 >= y)%Z.

Theorem Zge_sign_neg_pos_rev: forall x y: Z, (0 > x -> 0 >= x * y ->  y >= 0)%Z.

Theorem Zlt_sign_pos_pos_rev: forall x y: Z, (0 < x -> 0 < x * y -> 0 < y)%Z.

Theorem Zlt_sign_neg_neg_rev: forall x y: Z, (x < 0 -> 0 < x * y ->  y < 0)%Z.

Theorem Zlt_sign_pos_neg_rev: forall x y: Z, (0 < x -> x * y < 0 -> y < 0)%Z.

Theorem Zlt_sign_neg_pos_rev: forall x y: Z, (x < 0 -> x * y < 0 ->  0 < y)%Z.

Theorem Zgt_sign_pos_pos_rev: forall x y: Z, (x > 0 -> x * y > 0 -> y > 0)%Z.

Theorem Zgt_sign_neg_neg_rev: forall x y: Z, (0 > x -> x * y  > 0->  0 > y)%Z.

Theorem Zgt_sign_pos_neg_rev: forall x y: Z, (x > 0 -> 0 > x * y -> 0 > y)%Z.

Theorem Zgt_sign_neg_pos_rev: forall x y: Z, (0 > x -> 0 > x * y ->  y > 0)%Z.

Theorem Zmult_le_neg_compat_l:
  forall n m p : Z, (m <= n)%Z -> (p <= 0)%Z -> (p * n <= p * m)%Z.

Theorem Zopp_lt: forall n m, (m < n -> -n < -m)%Z.

Theorem Zmult_lt_neg_compat_l:
  forall n m p : Z, (m < n)%Z -> (p < 0)%Z -> (p * n < p * m)%Z.

Theorem Zopp_ge: forall n m, (m >= n -> -n >= -m)%Z.

Theorem Zmult_ge_neg_compat_l:
  forall n m p : Z, (m >= n)%Z -> (0 >= p)%Z -> (p * n >= p * m)%Z.

Theorem Zopp_gt: forall n m, (m > n -> -n > -m)%Z.

Theorem Zmult_gt_neg_compat_l:
  forall n m p : Z, (m > n)%Z -> (0 > p)%Z -> (p * n > p * m)%Z.

Theorem Zmult_le_compat_l_rev:
  forall n m p : Z, (0 < p)%Z -> (p * n <= p * m)%Z -> (n <= m)%Z.

Theorem Zmult_le_neg_compat_l_rev:
  forall n m p : Z, (p < 0)%Z -> (p * n <= p * m)%Z -> (m <= n)%Z.

Theorem Zmult_lt_compat_l_rev:
  forall n m p : Z, (0 < p)%Z -> (p * n < p * m)%Z -> (n < m)%Z.

Theorem Zmult_lt_neg_compat_l_rev:
  forall n m p : Z, (p < 0)%Z -> (p * n < p * m)%Z -> (m < n)%Z.

Theorem Zmult_ge_compat_l_rev:
  forall n m p : Z, (p > 0)%Z -> (p * n >= p * m)%Z -> (n >= m)%Z.

Theorem Zmult_ge_neg_compat_l_rev:
  forall n m p : Z, (0 > p)%Z -> (p * n >= p * m)%Z -> (m >= n)%Z.

Theorem Zmult_gt_compat_l_rev:
  forall n m p : Z, (p > 0)%Z -> (p * n > p * m)%Z -> (n > m)%Z.

Theorem Zmult_gt_neg_compat_l_rev:
  forall n m p : Z, (0 > p)%Z -> (p * n > p * m)%Z -> (m > n)%Z.

Theorem eq_Zlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).
Theorem eq_Zlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).
Theorem eq_Zgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).
Theorem eq_Zgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).
Theorem eq_Zle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).
Theorem eq_Zle_trans_r : forall x y z, (y = z) -> (x <= y) -> (x <= z).
Theorem eq_Zge_trans_l : forall x y z, (x = z) -> (x >= y) -> (z >= y).
Theorem eq_Zge_trans_r : forall x y z, (y = z) -> (x >= y) -> (x >= z).

Theorem Zge_trans: forall x y z, (x >= z) -> (z >= y) -> (x >= y).

Close Scope Z_scope.

Open Scope R_scope.

Theorem Rplus_eq_compat_l: forall a b c:R, (b = c -> a + b = a + c)%R.

Theorem Rplus_neg_compat_l: forall a b c: R, (b <> c -> a + b <> a + c)%R.

Theorem Rplus_ge_compat_l: forall n m p : R, (n >= m -> p + n >= p + m)%R.

Theorem Rplus_neg_reg_l: forall a b c: R,  (a + b <> a + c -> b <> c)%R.

Theorem Rplus_ge_reg_l: forall n m p : R, (p + n >= p + m -> n >= m)%R.

Theorem Rle_sign_pos_pos: forall x y, (0 <= x -> 0 <= y  -> 0 <= x * y)%R.

Theorem Rle_sign_neg_neg: forall x y, (x <= 0 -> y <= 0  -> 0 <= x * y)%R.

Theorem Rle_pos_neg: forall x, (0 <= -x -> x <= 0)%R.

Theorem Rle_sign_pos_neg: forall x y: R, (0 <= x -> y <= 0  -> x * y <= 0)%R.

Theorem Rle_sign_neg_pos: forall x y, (x <= 0 -> 0 <= y  -> x * y <= 0)%R.

Theorem Rlt_sign_pos_pos: forall x y, (0 < x -> 0 < y  -> 0 < x * y)%R.

Theorem Rlt_sign_neg_neg: forall x y, (x < 0 -> y < 0  -> 0 < x * y)%R.

Theorem Rlt_pos_neg: forall x, (0 < -x -> x < 0)%R.

Theorem Rlt_sign_pos_neg: forall x y, (0 < x -> y < 0  -> x * y < 0)%R.

Theorem Rlt_sign_neg_pos: forall x y, (x < 0 -> 0 < y  -> x * y < 0)%R.

Theorem Rge_sign_neg_neg: forall x y, (0 >= x -> 0 >= y  -> x * y >= 0)%R.

Theorem Rge_sign_pos_pos: forall x y, (x >= 0 -> y >= 0  -> x * y >= 0)%R.

Theorem Rge_neg_pos: forall x, (0 >= -x -> x >= 0)%R.

Theorem Rge_sign_neg_pos: forall x y: R, (0 >= x -> y >= 0  -> 0>= x * y)%R.

Theorem Rge_sign_pos_neg: forall x y, (x >= 0 -> 0 >= y  -> 0 >= x * y)%R.

Theorem Rgt_sign_neg_neg: forall x y, (0 > x -> 0 > y  -> x * y > 0)%R.

Theorem Rgt_sign_pos_pos: forall x y, (x > 0 -> y > 0  -> x * y > 0)%R.

Theorem Rgt_neg_pos: forall x, (0 > -x -> x > 0)%R.

Theorem Rgt_sign_neg_pos: forall x y, (0 > x -> y > 0  -> 0> x * y)%R.

Theorem Rgt_sign_pos_neg: forall x y, (x > 0 -> 0 > y  -> 0 > x * y)%R.

Theorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.

Theorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y ->  y <= 0)%R.

Theorem Rle_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y <= 0 -> y <= 0)%R.

Theorem Rle_sign_neg_pos_rev: forall x y: R, (x < 0 -> x * y <= 0 ->  0 <= y)%R.

Theorem Rge_sign_pos_pos_rev: forall x y: R, (x > 0 -> x * y >= 0 -> y >= 0)%R.

Theorem Rge_sign_neg_neg_rev: forall x y: R, (0 > x -> x * y  >= 0->  0 >= y)%R.

Theorem Rge_sign_pos_neg_rev: forall x y: R, (x > 0 -> 0 >= x * y -> 0 >= y)%R.

Theorem Rge_sign_neg_pos_rev: forall x y: R, (0 > x -> 0 >= x * y ->  y >= 0)%R.

Theorem Rlt_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 < x * y -> 0 < y)%R.

Theorem Rlt_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 < x * y ->  y < 0)%R.

Theorem Rlt_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y < 0 -> y < 0)%R.

Theorem Rlt_sign_neg_pos_rev: forall x y: R, (x < 0 -> x * y < 0 ->  0 < y)%R.

Theorem Rgt_sign_pos_pos_rev: forall x y: R, (x > 0 -> x * y > 0 -> y > 0)%R.

Theorem Rgt_sign_neg_neg_rev: forall x y: R, (0 > x -> x * y  > 0->  0 > y)%R.

Theorem Rgt_sign_pos_neg_rev: forall x y: R, (x > 0 -> 0 > x * y -> 0 > y)%R.

Theorem Rgt_sign_neg_pos_rev: forall x y: R, (0 > x -> 0 > x * y ->  y > 0)%R.

Theorem Rmult_le_compat_l:
  forall n m p : R, (m <= n)%R -> (0 <= p)%R -> (p * m <= p * n)%R.

Theorem Rmult_le_neg_compat_l:
  forall n m p : R, (m <= n)%R -> (p <= 0)%R -> (p * n <= p * m)%R.

Theorem Ropp_lt: forall n m, (m < n -> -n < -m)%R.

Theorem Rmult_lt_neg_compat_l:
  forall n m p : R, (m < n)%R -> (p < 0)%R -> (p * n < p * m)%R.

Theorem Ropp_ge: forall n m, (m >= n -> -n >= -m)%R.

Theorem Rmult_ge_compat_l:
  forall n m p : R, (m >= n)%R -> (p >= 0)%R -> (p * m >= p * n)%R.

Theorem Rmult_ge_neg_compat_l:
  forall n m p : R, (m >= n)%R -> (0 >= p)%R -> (p * n >= p * m)%R.

Theorem Ropp_gt: forall n m, (m > n -> -n > -m)%R.

Theorem Rmult_gt_compat_l:
  forall n m p : R, (n > m)%R -> (p > 0)%R -> (p * n > p * m)%R.

Theorem Rmult_gt_neg_compat_l:
  forall n m p : R, (m > n)%R -> (0 > p)%R -> (p * n > p * m)%R.

Theorem Rmult_le_compat_l_rev:
  forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.

Theorem Rmult_le_neg_compat_l_rev:
  forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.

Theorem Rmult_lt_compat_l_rev:
  forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.

Theorem Rmult_lt_neg_compat_l_rev:
  forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.

Theorem Rmult_ge_compat_l_rev:
  forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.

Theorem Rmult_ge_neg_compat_l_rev:
  forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.

Theorem Rmult_gt_compat_l_rev:
  forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.

Theorem Rmult_gt_neg_compat_l_rev:
  forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.

Theorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).
Theorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).
Theorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).
Theorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).
Theorem eq_Rle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).
Theorem eq_Rle_trans_r : forall x y z, (y = z) -> (x <= y) -> (x <= z).
Theorem eq_Rge_trans_l : forall x y z, (x = z) -> (x >= y) -> (z >= y).
Theorem eq_Rge_trans_r : forall x y z, (y = z) -> (x >= y) -> (x >= z).

Theorem Rge_trans: forall x y z, (x >= z) -> (z >= y) -> (x >= y).

Theorem Z2R_correct: forall p, (Z2R p) = (IZR p).

Theorem Z2R_le: forall p q, (p <= q)%Z -> (Z2R p <= Z2R q)%R.

Theorem Z2R_lt: forall p q, (p < q)%Z -> (Z2R p < Z2R q)%R.

Theorem Z2R_ge: forall p q, (p >= q)%Z -> (Z2R p >= Z2R q)%R.

Theorem Z2R_gt: forall p q, (p > q)%Z -> (Z2R p > Z2R q)%R.

Close Scope R_scope. *)

Ltac RCst0 t :=
  match t with
   | R0 => constr:(Z0)
   | R1 => constr:(Zpos xH)
   | Rplus ?e1 ?e2 =>
       match (RCst0 e1) with
      | ?e3 => match (RCst0 e2) with
              |  ?e4 => constr:(Zplus e3  e4)
              end
      end
   | Rminus ?e1 ?e2 =>
       match (RCst0 e1) with
      | ?e3 => match (RCst0 e2) with
              |  ?e4 => constr:(Zminus e3  e4)
              end
      end
   | Rmult ?e1 ?e2 =>
       match (RCst0 e1) with
      | ?e3 => match (RCst0 e2) with
              |  ?e4 => constr:(Zmult e3  e4)
              end
      end
   | Ropp ?e1 =>
       match (RCst0 e1) with
      | ?e3 => constr:(Z.opp e3)
      end
   | IZR ?e1 =>
       match (ZCst e1) with
       | ?e3 => e3
       end
   | _ => constr:(0%Z)
 end.

Ltac rground_tac := match goal with
|- (?X1 <= ?X2)%R => 
       let r1 := RCst0 X1 in
       let r2 := RCst0 X2 in
       change (Z2R r1 <= Z2R r2)%R; apply Z2R_le; red; apply refl_equal || intros; discriminate
| |- (?X1 < ?X2)%R => 
       let r1 := RCst0 X1 in
       let r2 := RCst0 X2 in
       change (Z2R r1 < Z2R r2)%R; apply Z2R_lt; red; apply refl_equal || intros; discriminate
| |- (?X1 >= ?X2)%R => 
       let r1 := RCst0 X1 in
       let r2 := RCst0 X2 in
       change (Z2R r1 >= Z2R r2)%R; apply Z2R_ge; red; apply refl_equal || intros; discriminate
| |- (?X1 > ?X2)%R => 
       let r1 := RCst0 X1 in
       let r2 := RCst0 X2 in
       change (Z2R r1 > Z2R r2)%R; apply Z2R_gt; red; apply refl_equal || intros; discriminate
end.

Hint Extern 4 (_ <= _)%R => rground_tac: real.
Hint Extern 4 (_ < _)%R => rground_tac: real.
Hint Extern 4 (_ >= _)%R => rground_tac: real.
Hint Extern 4 (_ > _)%R => rground_tac: real.

