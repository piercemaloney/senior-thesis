Require Import PolTac.
(* PolTac:
Require Import RSignTac.
Require Import NSignTac.
Require Import NatSignTac.
Require Import ZSignTac.

Ltac sign_tac :=  nsign_tac || Nsign_tac || zsign_tac || rsign_tac.

Ltac hyp_sign_tac H :=  hyp_nsign_tac H || hyp_Nsign_tac H || hyp_zsign_tac H || hyp_rsign_tac H.

Require Import RPolS.
Require Import ZPolS.
Require Import NatPolS.
Require Import NPolS.
Require Export ArithRing.
Require Export NArithRing.

Ltac pols :=  npols || Npols || zpols || rpols.

Ltac hyp_pols H :=  hyp_npols H || hyp_Npols H || hyp_zpols H || hyp_rpols H.

Require Import RPolF.
Require Import ZPolF.
Require Import NatPolF.
Require Import NPolF.
Require Export ArithRing.

Ltac polf :=  npolf || Npolf || zpolf || rpolf.

Ltac hyp_polf H := hyp_npolf H || hyp_Npolf H || hyp_zpolf H || hyp_rpolf H.

Require Import RPolR.
Require Import ZPolR.
Require Import NatPolR.
Require Import NPolR.

Ltac polr term :=  
match goal with |- ?G => 
 (let u := npol_is_compare G in npolr term)
||
 (let u := Npol_is_compare G in Npolr term)
||
(let u := zpol_is_compare G in zpolr term)
||
(let u := rpol_is_compare G in rpolr term)
end.

Ltac polrx term dir1 dir2 occ :=  
match goal with |- ?G => 
  (let u := npol_is_compare G in npolrx term dir1 dir2 occ)
||
  (let u := Npol_is_compare G in Npolrx term dir1 dir2 occ)
||
(let u := zpol_is_compare G in zpolrx term dir1 dir2 occ)
||
(let u := rpol_is_compare G in rpolrx term dir1 dir2 occ)
end. *)
Require Import NAux.
(* NAux:
Require Export NArith.
Require Import ZArith.

Open Scope N_scope.

Theorem Nle_le: forall n  m, (N.to_nat n <= N.to_nat m)%nat -> n <= m.

Theorem le_Nle: forall n m, N.of_nat n <= N.of_nat m -> (n <= m)%nat.

Theorem Nle_le_rev: forall n  m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.

Theorem Nlt_lt: forall n  m, (N.to_nat n < N.to_nat m)%nat -> n < m.

Theorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.

Theorem Nlt_lt_rev: forall n  m, n < m -> (N.to_nat n < N.to_nat m)%nat.

Theorem Nge_ge: forall n  m, (N.to_nat n >= N.to_nat m)%nat -> n >= m.

Theorem ge_Nge: forall n m, N.of_nat n >= N.of_nat m -> (n >= m)%nat.

Theorem Nge_ge_rev: forall n  m, n >= m -> (N.to_nat n >= N.to_nat m)%nat.

Theorem Ngt_gt: forall n  m, (N.to_nat n > N.to_nat m)%nat -> n > m.

Theorem gt_Ngt: forall n m, N.of_nat n > N.of_nat m -> (n > m)%nat.

Theorem Ngt_gt_rev: forall n  m, n > m -> (N.to_nat n > N.to_nat m)%nat.

Theorem Neq_eq_rev: forall n  m, n = m -> (N.to_nat n = N.to_nat m)%nat.

Import BinPos.

Ltac to_nat_op  :=
  match goal with
      H: (N.lt _ _) |- _ => generalize (Nlt_lt_rev _ _ H); clear H; intros H
|     H: (N.gt _ _) |- _ => generalize (Ngt_gt_rev _ _ H); clear H; intros H
|     H: (N.le _ _) |- _ => generalize (Nle_le_rev _ _ H); clear H; intros H
|     H: (N.ge _ _) |- _ => generalize (Nge_ge_rev _ _ H); clear H; intros H
|     H: (@eq N _ _) |- _ => generalize (Neq_eq_rev _ _ H); clear H; intros H
|      |- (N.lt _ _)  => apply Nlt_lt
|      |- (N.le _ _)  => apply Nle_le
|      |- (N.gt _ _)  => apply Ngt_gt
|      |- (N.ge _ _)  => apply Nge_ge
|      |- (@eq N _ _)  => apply Nat2N.inj
end.

Ltac set_to_nat :=
let nn := fresh "nn" in
match goal with
       |- context [(N.to_nat (?X + ?Y)%N)]  => rewrite N2Nat.inj_add
|      |- context [(N.to_nat (?X * ?Y)%N)]  => rewrite N2Nat.inj_mul
|      |- context [(N.to_nat ?X)]  => set (nn:=N.to_nat X) in * |- *
|      H: context [(N.to_nat (?X + ?Y)%N)] |- _ => rewrite N2Nat.inj_add in H
|      H: context [(N.to_nat (?X + ?Y)%N)] |- _ => rewrite N2Nat.inj_mul in H
|      H: context [(N.to_nat ?X)] |- _ => set (nn:=N.to_nat X) in * |- *
end.

Ltac to_nat := repeat to_nat_op; repeat set_to_nat.

Theorem Nle_gt_trans: forall n m p, m <= n -> m > p -> n > p.

Theorem Ngt_le_trans: forall n m p, n > m -> p <= m -> n > p.

Theorem Nle_add_l :
  forall x y, x <= y + x.

Close Scope N_scope. *)

Open Scope N_scope.

Theorem pols_test1: forall x y: N,  x < y ->  (x + x < y + x).
intros.
pols.
auto.
Qed.

Theorem pols_test2: forall x y, y < 0 ->  (x + y < x).
intros.
pols.
auto.
Qed.
 
Theorem pols_test4:
 forall x y,
 x * x  < y * y ->  ((x + y) * (x + y) < 2 * (x * y + y * y)).
intros.
pols.
auto.
Qed.
 
Theorem pols_test5:
 forall x y z, x + y * (y + z) = 2 * z ->  2 * x + y * (y + z) = (x + z) + z.
intros.
pols.
auto.
Qed.

Theorem polf_test1: forall x y, (1 <= y -> x  <= x  * y).
intros.
polf.
Qed.

Theorem polf_test2: forall x y, 0 < x -> x  <= x  * y -> 1 <= y.
intros.
hyp_polf H0.
auto.
Qed.

Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.
intros x y z H.
polr H.
pols.
auto.
pols.
auto.
Qed.
