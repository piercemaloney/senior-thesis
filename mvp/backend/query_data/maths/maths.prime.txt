
Require Import ZArith.
Require Import ZArithRing.

Require Import divide.
(* divide:
Require Import ZArith.
Require Import ZArithRing.
Require Import Zcomplements.

Unset Standard Proposition Elimination Names.

Inductive divide (a b : Z) : Prop :=
    divide_intro : forall q : Z, b = (q * a)%Z -> divide a b.

Notation "( x | y )" := (divide x y) (at level 0) : Z_scope.

Local Open Scope Z_scope.

Lemma divide_refl : forall a : Z, (a | a).

Lemma one_divide : forall a : Z, (1 | a).

Lemma divide_0 : forall a : Z, (a | 0).

Hint Resolve divide_refl one_divide divide_0.

Lemma divide_mult_left : forall a b c : Z, (a | b) -> (c * a | c * b).

Lemma divide_mult_right : forall a b c : Z, (a | b) -> (a * c | b * c).

Hint Resolve divide_mult_left divide_mult_right.

Lemma divide_plus : forall a b c : Z, (a | b) -> (a | c) -> (a | b + c).

Lemma divide_opp : forall a b : Z, (a | b) -> (a | - b).

Lemma divide_opp_rev : forall a b : Z, (a | - b) -> (a | b).

Lemma divide_opp_left : forall a b : Z, (a | b) -> (- a | b).

Lemma divide_opp_left_rev : forall a b : Z, (- a | b) -> (a | b).

Lemma divide_minus : forall a b c : Z, (a | b) -> (a | c) -> (a | b - c).

Lemma divide_left : forall a b c : Z, (a | b) -> (a | b * c).

Lemma divide_right : forall a b c : Z, (a | c) -> (a | b * c).

Lemma divide_a_ab : forall a b : Z, (a | a * b).

Lemma divide_a_ba : forall a b : Z, (a | b * a).

Hint Resolve divide_plus divide_opp divide_opp_rev divide_opp_left
  divide_opp_left_rev divide_minus divide_left divide_right divide_a_ab
  divide_a_ba.

Lemma z_case_0_1 :
 forall x : Z, x <= -2 \/ x = -1 \/ x = 0 \/ x = 1 \/ x >= 2.

Lemma z_case_0 : forall x : Z, x <= -1 \/ x = 0 \/ x >= 1.

Lemma divide_1 : forall x : Z, (x | 1) -> x = 1 \/ x = -1.

Lemma divide_antisym : forall a b : Z, (a | b) -> (b | a) -> a = b \/ a = - b.

Lemma Zabs_ind :
 forall (P : Z -> Prop) (x : Z),
 (x >= 0 -> P x) -> (x <= 0 -> P (- x)) -> P (Zabs x).

Lemma divide_bounds : forall a b : Z, (a | b) -> b <> 0 -> Zabs a <= Zabs b. *)
Require Import gcd.
(* gcd:
Require Import ZArith.
Require Import ZArithRing.
Require Import Zdiv.
Require Import Omega.

Require Import divide.

Inductive gcd (a b d : Z) : Prop :=
    gcd_intro :
      (d | a)%Z ->
      (d | b)%Z ->
      (forall x : Z, (x | a)%Z -> (x | b)%Z -> (x | d)%Z) -> gcd a b d.

Lemma gcd_sym : forall a b d : Z, gcd a b d -> gcd b a d.

Lemma gcd_0 : forall a : Z, gcd a 0 a.

Lemma gcd_minus : forall a b d : Z, gcd a (- b) d -> gcd b a d.

Lemma gcd_opp : forall a b d : Z, gcd a b d -> gcd b a (- d).

Hint Resolve gcd_sym gcd_0 gcd_minus gcd_opp.

Lemma gcd_for_euclid : forall a b d q : Z, gcd b (a - q * b) d -> gcd a b d.

Section extended_euclid_algorithm.

Variable a b : Z.

Inductive Euclid : Set :=
    Euclid_intro :
      forall u v d : Z, (u * a + v * b)%Z = d -> gcd a b d -> Euclid.

Lemma euclid_rec :
 forall v3 : Z,
 (0 <= v3)%Z ->
 forall u1 u2 u3 v1 v2 : Z,
 (u1 * a + u2 * b)%Z = u3 ->
 (v1 * a + v2 * b)%Z = v3 ->
 (forall d : Z, gcd u3 v3 d -> gcd a b d) -> Euclid.

Lemma euclid : Euclid.

End extended_euclid_algorithm.

Theorem gcd_uniqueness_apart_sign :
 forall a b d d' : Z, gcd a b d -> gcd a b d' -> d = d' \/ d = (- d')%Z.

Inductive Bezout (a b d : Z) : Prop :=
    Bezout_intro : forall u v : Z, (u * a + v * b)%Z = d -> Bezout a b d.

Lemma gcd_bezout : forall a b d : Z, gcd a b d -> Bezout a b d.

Lemma gcd_mult : forall a b c d : Z, gcd a b d -> gcd (c * a) (c * b) (c * d). *)

Definition rel_prime (a b : Z) : Prop := gcd a b 1.

Lemma rel_prime_bezout : forall a b : Z, rel_prime a b -> Bezout a b 1.
Proof.
intros a b; exact (gcd_bezout a b 1).
Qed.

Lemma bezout_rel_prime : forall a b : Z, Bezout a b 1 -> rel_prime a b.
Proof.
simple induction 1; constructor; auto.
intros. rewrite <- H0; auto.
Qed.

Theorem Gauss : forall a b c : Z, (a | b * c)%Z -> rel_prime a b -> (a | c)%Z.
Proof.
intros. elim (rel_prime_bezout a b H0); intros.
replace c with (c * 1)%Z; [ idtac | ring ].
rewrite <- H1.
replace (c * (u * a + v * b))%Z with (c * u * a + v * (b * c))%Z;
 [ eauto | ring ].
Qed.

Lemma rel_prime_mult :
 forall a b c : Z, rel_prime a b -> rel_prime a c -> rel_prime a (b * c).
Proof.
intros a b c Hb Hc.
elim (rel_prime_bezout a b Hb); intros.
elim (rel_prime_bezout a c Hc); intros.
apply bezout_rel_prime.
apply
 Bezout_intro
  with (u := (u * u0 * a + v0 * c * u + u0 * v * b)%Z) (v := (v * v0)%Z).
rewrite <- H.
replace (u * a + v * b)%Z with ((u * a + v * b) * 1)%Z; [ idtac | ring ].
rewrite <- H0.
ring.
Qed.

Inductive prime (p : Z) : Prop :=
    prime_intro :
      (1 < p)%Z -> (forall n : Z, (1 <= n < p)%Z -> rel_prime n p) -> prime p.

Lemma prime_divisors :
 forall p : Z,
 prime p ->
 forall a : Z, (a | p)%Z -> a = (-1)%Z \/ a = 1%Z \/ a = p \/ a = (- p)%Z.
Proof.
simple induction 1; intros.
assert
 (a = (- p)%Z \/
  (- p < a < -1)%Z \/
  a = (-1)%Z \/ a = 0%Z \/ a = 1%Z \/ (1 < a < p)%Z \/ a = p).
assert (Zabs a <= Zabs p)%Z. apply divide_bounds; [ assumption | omega ].
generalize H3. 
pattern (Zabs a) in |- *; apply Zabs_ind; pattern (Zabs p) in |- *;
 apply Zabs_ind; intros; omega.
intuition.

absurd (rel_prime (- a) p); intuition.
inversion H3.
assert (- a | - a)%Z; auto.
assert (- a | p)%Z; auto.
generalize (H8 (- a)%Z H9 H10); intuition.
generalize (divide_1 (- a) H11); intuition.

inversion H2. subst a; omega.

absurd (rel_prime a p); intuition.
inversion H3.
assert (a | a)%Z; auto.
assert (a | p)%Z; auto.
generalize (H8 a H9 H10); intuition.
generalize (divide_1 a H11); intuition.
Qed.

Lemma prime_rel_prime :
 forall p : Z, prime p -> forall a : Z, ~ (p | a)%Z -> rel_prime p a.
Proof.
simple induction 1; intros.
constructor; intuition.
elim (prime_divisors p H x H3); intuition; subst; auto.
absurd (p | a)%Z; auto.
absurd (p | a)%Z; intuition.
Qed.

Hint Resolve prime_rel_prime.

Axiom divide_dec : forall a b : Z, {(a | b)%Z} + {~ (a | b)%Z}.

Lemma prime_mult :
 forall p : Z,
 prime p -> forall a b : Z, (p | a * b)%Z -> (p | a)%Z \/ (p | b)%Z.
Proof.
simple induction 1; intros.
case (divide_dec p a); intuition.
right; apply Gauss with a; auto.
Qed.

