
Require Export Fprop.
(* Fprop:
Require Export Fbound.
Section Fprop.
Variable radix : Z.
Hypothesis radixMoreThanOne : (1 < radix)%Z.
 
Let FtoRradix := FtoR radix.
Local Coercion FtoRradix : float >-> R.

Variable b : Fbound.
 
Theorem SterbenzAux :
 forall x y : float,
 Fbounded b x ->
 Fbounded b y ->
 (y <= x)%R -> (x <= 2%nat * y)%R -> Fbounded b (Fminus radix x y).
 
Theorem Sterbenz :
 forall x y : float,
 Fbounded b x ->
 Fbounded b y ->
 (/ 2%nat * y <= x)%R -> (x <= 2%nat * y)%R -> Fbounded b (Fminus radix x y).
 
Theorem BminusSameExpAux :
 forall x y : float,
 Fbounded b x ->
 Fbounded b y ->
 (0 <= y)%R -> (y <= x)%R -> Fexp x = Fexp y -> Fbounded b (Fminus radix x y).
 
Theorem BminusSameExp :
 forall x y : float,
 Fbounded b x ->
 Fbounded b y ->
 (0 <= x)%R -> (0 <= y)%R -> Fexp x = Fexp y -> Fbounded b (Fminus radix x y).
 
Theorem BminusSameExpNeg :
 forall x y : float,
 Fbounded b x ->
 Fbounded b y ->
 (x <= 0)%R -> (y <= 0)%R -> Fexp x = Fexp y -> Fbounded b (Fminus radix x y).
End Fprop.
Hint Resolve Sterbenz BminusSameExp BminusSameExpNeg: float. *)
Require Export Zdivides.
(* Zdivides:
Require Export Omega.
Require Export Paux.
 
Definition oZ1 (x : Option positive) :=
  match x with
  | None => 0%Z
  | Some z => Zpos z
  end.

Definition Zquotient (n m : Z) :=
  match n, m with
  | Z0, _ => 0%Z
  | _, Z0 => 0%Z
  | Zpos x, Zpos y => match Pdiv x y with
                      | (x, _) => oZ1 x
                      end
  | Zneg x, Zneg y => match Pdiv x y with
                      | (x, _) => oZ1 x
                      end
  | Zpos x, Zneg y => match Pdiv x y with
                      | (x, _) => (- oZ1 x)%Z
                      end
  | Zneg x, Zpos y => match Pdiv x y with
                      | (x, _) => (- oZ1 x)%Z
                      end
  end.
 
Theorem inj_oZ1 : forall z, oZ1 z = Z_of_nat (oZ z).
 
Theorem Zero_le_oZ : forall z, 0 <= oZ z.
Hint Resolve Zero_le_oZ: arith.

Theorem ZquotientProp :
 forall m n : Z,
 n <> 0%Z ->
 ex
   (fun r : Z =>
    m = (Zquotient m n * n + r)%Z /\
    (Zabs (Zquotient m n * n) <= Zabs m)%Z /\ (Zabs r < Zabs n)%Z).
 
Theorem ZquotientPos :
 forall z1 z2 : Z, (0 <= z1)%Z -> (0 <= z2)%Z -> (0 <= Zquotient z1 z2)%Z.

Definition Zdivides (n m : Z) := exists q : Z, n = (m * q)%Z.
 
Theorem ZdividesZquotient :
 forall n m : Z, m <> 0%Z -> Zdivides n m -> n = (Zquotient n m * m)%Z.
 
Theorem ZdividesZquotientInv :
 forall n m : Z, n = (Zquotient n m * m)%Z -> Zdivides n m.
 
Theorem ZdividesMult :
 forall n m p : Z, Zdivides n m -> Zdivides (p * n) (p * m).
 
Theorem Zeq_mult_simpl :
 forall a b c : Z, c <> 0%Z -> (a * c)%Z = (b * c)%Z -> a = b.
 
Theorem ZdividesDiv :
 forall n m p : Z, p <> 0%Z -> Zdivides (p * n) (p * m) -> Zdivides n m.
 
Definition ZdividesP : forall n m : Z, {Zdivides n m} + {~ Zdivides n m}.

Theorem Zquotient1 : forall m : Z, Zquotient m 1 = m.
 
Theorem Zdivides1 : forall m : Z, Zdivides m 1.
 
Theorem Zabs_eq_case :
 forall z1 z2 : Z, Zabs z1 = Zabs z2 -> z1 = z2 \/ z1 = (- z2)%Z.
 
Theorem Zabs_tri : forall z1 z2 : Z, (Zabs (z1 + z2) <= Zabs z1 + Zabs z2)%Z.
Hint Resolve Zabs_tri: zarith.
 
Theorem ZquotientUnique :
 forall m n q r : Z,
 n <> 0%Z ->
 m = (q * n + r)%Z ->
 (Zabs (q * n) <= Zabs m)%Z -> (Zabs r < Zabs n)%Z -> q = Zquotient m n.
 
Theorem ZquotientZopp :
 forall m n : Z, Zquotient (- m) n = (- Zquotient m n)%Z.
 
Theorem ZquotientMonotone :
 forall n m q : Z,
 (Zabs n <= Zabs m)%Z -> (Zabs (Zquotient n q) <= Zabs (Zquotient m q))%Z.
 
Theorem NotDividesDigit :
 forall r v : Z,
 (1 < r)%Z -> v <> 0%Z -> ~ Zdivides v (Zpower_nat r (digit r v)).
 
Theorem ZDividesLe :
 forall n m : Z, n <> 0%Z -> Zdivides n m -> (Zabs m <= Zabs n)%Z.
 
Theorem Zquotient_mult_comp :
 forall m n p : Z, p <> 0%Z -> Zquotient (m * p) (n * p) = Zquotient m n.
 
Theorem ZDivides_add :
 forall n m p : Z, Zdivides n p -> Zdivides m p -> Zdivides (n + m) p.
 
Theorem NDivides_minus :
 forall n m p : Z, Zdivides n p -> Zdivides m p -> Zdivides (n - m) p.
 
Theorem ZDivides_mult :
 forall n m p q : Z, Zdivides n p -> Zdivides m q -> Zdivides (n * m) (p * q).
 
Theorem ZdividesTrans :
 forall n m p : Z, Zdivides n m -> Zdivides m p -> Zdivides n p.
 
Theorem ZdividesLessPow :
 forall (n : Z) (m p : nat),
 m <= p -> Zdivides (Zpower_nat n p) (Zpower_nat n m). *)
Require Export Fnorm.
(* Fnorm:
Require Export Fbound.
 
Section Fnormalized_Def.
Variable radix : Z.
Hypothesis radixMoreThanOne : (1 < radix)%Z.
 
Let radixMoreThanZERO := Zlt_1_O _ (Zlt_le_weak _ _ radixMoreThanOne).
Hint Resolve radixMoreThanZERO: zarith.
 
Let FtoRradix := FtoR radix.
Coercion FtoRradix : float >-> R.
Variable b : Fbound.
 
Definition Fnormal (p : float) :=
  Fbounded b p /\ (Zpos (vNum b) <= Zabs (radix * Fnum p))%Z.
 
Theorem FnormalBounded : forall p : float, Fnormal p -> Fbounded b p.
 
Theorem FnormalBound :
 forall p : float,
 Fnormal p -> (Zpos (vNum b) <= Zabs (radix * Fnum p))%Z.
Hint Resolve FnormalBounded FnormalBound: float.
 
Theorem FnormalNotZero : forall p : float, Fnormal p -> ~ is_Fzero p.
 
Theorem FnormalFop : forall p : float, Fnormal p -> Fnormal (Fopp p).
 
Theorem FnormalFabs : forall p : float, Fnormal p -> Fnormal (Fabs p).
 
Definition pPred x := Zpred (Zpos x).
 
Theorem maxMax1 :
 forall (p : float) (z : Z),
 Fbounded b p -> (Fexp p <= z)%Z -> (Fabs p <= Float (pPred (vNum b)) z)%R.
 
Theorem FnormalBoundAbs :
 forall p : float,
 Fnormal p -> (Float (pPred (vNum b)) (Zpred (Fexp p)) < Fabs p)%R.
 
Definition Fsubnormal (p : float) :=
  Fbounded b p /\
  Fexp p = (- dExp b)%Z /\ (Zabs (radix * Fnum p) < Zpos (vNum b))%Z.
 
Theorem FsubnormalFbounded : forall p : float, Fsubnormal p -> Fbounded b p.
 
Theorem FsubnormalFexp :
 forall p : float, Fsubnormal p -> Fexp p = (- dExp b)%Z.
 
Theorem FsubnormalBound :
 forall p : float,
 Fsubnormal p -> (Zabs (radix * Fnum p) < Zpos (vNum b))%Z.
Hint Resolve FsubnormalFbounded FsubnormalBound FsubnormalFexp: float.
 
Theorem FsubnormFopp : forall p : float, Fsubnormal p -> Fsubnormal (Fopp p).
 
Theorem FsubnormFabs : forall p : float, Fsubnormal p -> Fsubnormal (Fabs p).
 
Theorem FsubnormalUnique :
 forall p q : float, Fsubnormal p -> Fsubnormal q -> p = q :>R -> p = q.
 
Theorem FsubnormalLt :
 forall p q : float,
 Fsubnormal p -> Fsubnormal q -> (p < q)%R -> (Fnum p < Fnum q)%Z.
 
Theorem LtFsubnormal :
 forall p q : float,
 Fsubnormal p -> Fsubnormal q -> (Fnum p < Fnum q)%Z -> (p < q)%R.
 
Definition Fcanonic (a : float) := Fnormal a \/ Fsubnormal a.
 
Theorem FcanonicBound : forall p : float, Fcanonic p -> Fbounded b p.
Hint Resolve FcanonicBound: float.
 
Theorem pUCanonic_absolu :
 forall p : float, Fcanonic p -> (Zabs (Fnum p) < Zpos (vNum b))%Z.
 
Theorem FcanonicFopp : forall p : float, Fcanonic p -> Fcanonic (Fopp p).
 
Theorem FcanonicFabs : forall p : float, Fcanonic p -> Fcanonic (Fabs p).
 
Theorem NormalNotSubNormal : forall p : float, ~ (Fnormal p /\ Fsubnormal p).
 
Theorem MaxFloat :
 forall x : float,
 Fbounded b x -> (Rabs x < Float (Zpos (vNum b)) (Fexp x))%R.

Variable precision : nat.
Hypothesis precisionNotZero : precision <> 0.
Hypothesis pGivesBound : Zpos (vNum b) = Zpower_nat radix precision.
 
Theorem FboundNext :
 forall p : float,
 Fbounded b p ->
 exists q : float, Fbounded b q /\ q = Float (Zsucc (Fnum p)) (Fexp p) :>R.
 
Theorem digitPredVNumiSPrecision :
 digit radix (Zpred (Zpos (vNum b))) = precision.
 
Theorem digitVNumiSPrecision :
 digit radix (Zpos (vNum b)) = S precision.
 
Theorem vNumPrecision :
 forall n : Z,
 digit radix n <= precision -> (Zabs n < Zpos (vNum b))%Z.
 
Theorem pGivesDigit :
 forall p : float, Fbounded b p -> Fdigit radix p <= precision.
 
Theorem digitGivesBoundedNum :
 forall p : float,
 Fdigit radix p <= precision -> (Zabs (Fnum p) < Zpos (vNum b))%Z.
 
Theorem FboundedOne :
 forall z : Z, (- dExp b <= z)%Z -> Fbounded b (Float 1%nat z).
 
Theorem FboundedMboundPos :
 forall z m : Z,
 (0 <= m)%Z ->
 (m <= Zpower_nat radix precision)%Z ->
 (- dExp b <= z)%Z ->
 exists c : float, Fbounded b c /\ c = (m * powerRZ radix z)%R :>R.
 
Theorem FboundedMbound :
 forall z m : Z,
 (Zabs m <= Zpower_nat radix precision)%Z ->
 (- dExp b <= z)%Z ->
 exists c : float, Fbounded b c /\ c = (m * powerRZ radix z)%R :>R.
 
Theorem FnormalPrecision :
 forall p : float, Fnormal p -> Fdigit radix p = precision.
Hint Resolve FnormalPrecision: float.
 
Theorem FnormalUnique :
 forall p q : float, Fnormal p -> Fnormal q -> p = q :>R -> p = q.
 
Theorem FnormalLtPos :
 forall p q : float,
 Fnormal p ->
 Fnormal q ->
 (0 <= p)%R ->
 (p < q)%R -> (Fexp p < Fexp q)%Z \/ Fexp p = Fexp q /\ (Fnum p < Fnum q)%Z.
 
Theorem FnormalLtNeg :
 forall p q : float,
 Fnormal p ->
 Fnormal q ->
 (q <= 0)%R ->
 (p < q)%R -> (Fexp q < Fexp p)%Z \/ Fexp p = Fexp q /\ (Fnum p < Fnum q)%Z.
 
Definition nNormMin := Zpower_nat radix (pred precision).
 
Theorem nNormPos : (0 < nNormMin)%Z.
 
Theorem digitnNormMin : digit radix nNormMin = precision.
 
Theorem nNrMMimLevNum : (nNormMin <= Zpos (vNum b))%Z.
Hint Resolve nNrMMimLevNum: arith.
 
Definition firstNormalPos := Float nNormMin (- dExp b).
 
Theorem firstNormalPosNormal : Fnormal firstNormalPos.
 
Theorem pNormal_absolu_min :
 forall p : float, Fnormal p -> (nNormMin <= Zabs (Fnum p))%Z.
 
Theorem maxMaxBis :
 forall (p : float) (z : Z),
 Fbounded b p -> (Fexp p < z)%Z -> (Fabs p < Float nNormMin z)%R.
 
Theorem FnormalLtFirstNormalPos :
 forall p : float, Fnormal p -> (0 <= p)%R -> (firstNormalPos <= p)%R.
 
Theorem FnormalLtFirstNormalNeg :
 forall p : float, Fnormal p -> (p <= 0)%R -> (p <= Fopp firstNormalPos)%R.
 
Theorem FsubnormalDigit :
 forall p : float, Fsubnormal p -> Fdigit radix p < precision.
Hint Resolve FsubnormalDigit: float.
 
Theorem pSubnormal_absolu_min :
 forall p : float, Fsubnormal p -> (Zabs (Fnum p) < nNormMin)%Z.
 
Theorem FsubnormalLtFirstNormalPos :
 forall p : float, Fsubnormal p -> (0 <= p)%R -> (p < firstNormalPos)%R.
 
Theorem FsubnormalnormalLtPos :
 forall p q : float,
 Fsubnormal p -> Fnormal q -> (0 <= p)%R -> (0 <= q)%R -> (p < q)%R.
 
Theorem FsubnormalnormalLtNeg :
 forall p q : float,
 Fsubnormal p -> Fnormal q -> (p <= 0)%R -> (q <= 0)%R -> (q < p)%R.
 
Definition Fnormalize (p : float) :=
  match Z_zerop (Fnum p) with
  | left _ => Float 0 (- dExp b)
  | right _ =>
      Fshift radix
        (min (precision - Fdigit radix p) (Zabs_nat (dExp b + Fexp p))) p
  end.
 
Theorem FnormalizeCorrect : forall p : float, Fnormalize p = p :>R.
 
Theorem Fnormalize_Fopp :
 forall p : float, Fnormalize (Fopp p) = Fopp (Fnormalize p).
 
Theorem FnormalizeBounded :
 forall p : float, Fbounded b p -> Fbounded b (Fnormalize p).
 
Theorem FnormalizeCanonic :
 forall p : float, Fbounded b p -> Fcanonic (Fnormalize p).
 
Theorem NormalAndSubNormalNotEq :
 forall p q : float, Fnormal p -> Fsubnormal q -> p <> q :>R.
 
Theorem FcanonicUnique :
 forall p q : float, Fcanonic p -> Fcanonic q -> p = q :>R -> p = q.
 
Theorem FcanonicLeastExp :
 forall x y : float,
 x = y :>R -> Fbounded b x -> Fcanonic y -> (Fexp y <= Fexp x)%Z.
 
Theorem FcanonicLtPos :
 forall p q : float,
 Fcanonic p ->
 Fcanonic q ->
 (0 <= p)%R ->
 (p < q)%R -> (Fexp p < Fexp q)%Z \/ Fexp p = Fexp q /\ (Fnum p < Fnum q)%Z.
 
Theorem FcanonicLePos :
 forall p q : float,
 Fcanonic p ->
 Fcanonic q ->
 (0 <= p)%R ->
 (p <= q)%R -> (Fexp p < Fexp q)%Z \/ Fexp p = Fexp q /\ (Fnum p <= Fnum q)%Z.
 
Theorem Fcanonic_Rle_Zle :
 forall x y : float,
 Fcanonic x -> Fcanonic y -> (Rabs x <= Rabs y)%R -> (Fexp x <= Fexp y)%Z.
 
Theorem FcanonicLtNeg :
 forall p q : float,
 Fcanonic p ->
 Fcanonic q ->
 (q <= 0)%R ->
 (p < q)%R -> (Fexp q < Fexp p)%Z \/ Fexp p = Fexp q /\ (Fnum p < Fnum q)%Z.
 
Theorem FcanonicFnormalizeEq :
 forall p : float, Fcanonic p -> Fnormalize p = p.
 
Theorem FcanonicPosFexpRlt :
 forall x y : float,
 (0 <= x)%R ->
 (0 <= y)%R -> Fcanonic x -> Fcanonic y -> (Fexp x < Fexp y)%Z -> (x < y)%R.
 
Theorem FcanonicNegFexpRlt :
 forall x y : float,
 (x <= 0)%R ->
 (y <= 0)%R -> Fcanonic x -> Fcanonic y -> (Fexp x < Fexp y)%Z -> (y < x)%R.
 
Theorem FnormalBoundAbs2 :
 forall p : float,
 Fnormal p ->
 (Zpos (vNum b) * Float 1%nat (Zpred (Fexp p)) <= Fabs p)%R.
 
Theorem vNumbMoreThanOne : (1 < Zpos (vNum b))%Z.
 
Theorem PosNormMin : Zpos (vNum b) = (radix * nNormMin)%Z.
 
Theorem FnormalPpred :
 forall x : Z, (- dExp b <= x)%Z -> Fnormal (Float (pPred (vNum b)) x).
 
Theorem FcanonicPpred :
 forall x : Z,
 (- dExp b <= x)%Z -> Fcanonic (Float (pPred (vNum b)) x).
 
Theorem FnormalNnormMin :
 forall x : Z, (- dExp b <= x)%Z -> Fnormal (Float nNormMin x).
 
Theorem FcanonicNnormMin :
 forall x : Z, (- dExp b <= x)%Z -> Fcanonic (Float nNormMin x).
 
Theorem boundedNorMinGivesExp :
 forall (x : Z) (p : float),
 Fbounded b p ->
 (- dExp b <= x)%Z ->
 (Float nNormMin x <= p)%R ->
 (p <= Float (pPred (vNum b)) x)%R -> Fexp (Fnormalize p) = x.
 
End Fnormalized_Def.
Hint Resolve FnormalBounded FnormalPrecision: float.
Hint Resolve FnormalNotZero nNrMMimLevNum firstNormalPosNormal FsubnormFopp
  FsubnormalLtFirstNormalPos FnormalizeBounded FcanonicFopp FcanonicFabs
  FnormalizeCanonic: float.
Hint Resolve nNrMMimLevNum: arith.
Hint Resolve FsubnormalFbounded FsubnormalFexp FsubnormalDigit: float.
Hint Resolve FcanonicBound: float. *)
Section mf.
Variable radix : Z.
Hypothesis radixMoreThanOne : (1 < radix)%Z.
 
Let radixMoreThanZERO := Zlt_1_O _ (Zlt_le_weak _ _ radixMoreThanOne).
Hint Resolve radixMoreThanZERO: zarith.

Let FtoRradix := FtoR radix.
Local Coercion FtoRradix : float >-> R.

Fixpoint maxDiv (v : Z) (p : nat) {struct p} : nat :=
  match p with
  | O => 0
  | S p' =>
      match ZdividesP v (Zpower_nat radix p) with
      | left _ => p
      | right _ => maxDiv v p'
      end
  end.
 
Theorem maxDivLess : forall (v : Z) (p : nat), maxDiv v p <= p.
intros v p; elim p; simpl in |- *; auto.
intros n H'; case (ZdividesP v (radix * Zpower_nat radix n)); auto.
Qed.
 
Theorem maxDivLt :
 forall (v : Z) (p : nat),
 ~ Zdivides v (Zpower_nat radix p) -> maxDiv v p < p.
intros v p; case p; simpl in |- *; auto.
intros H'; case H'.
apply Zdivides1.
intros n H'; case (ZdividesP v (radix * Zpower_nat radix n)); auto.
intros H'0; case H'; auto.
intros H'0; generalize (maxDivLess v n); auto with arith.
Qed.
 
Theorem maxDivCorrect :
 forall (v : Z) (p : nat), Zdivides v (Zpower_nat radix (maxDiv v p)).
intros v p; elim p.
unfold maxDiv in |- *; rewrite Zpower_nat_O; auto.
apply Zdivides1.
simpl in |- *.
intros n H'; case (ZdividesP v (radix * Zpower_nat radix n)); simpl in |- *;
 auto with zarith.
Qed.
 
Theorem maxDivSimplAux :
 forall (v : Z) (p q : nat),
 p = maxDiv v (S (q + p)) -> p = maxDiv v (S p).
intros v p q; elim q.
simpl in |- *; case (ZdividesP v (radix * Zpower_nat radix p)); auto.
intros n H' H'0.
apply H'; auto; clear H'.
simpl in H'0; generalize H'0; clear H'0.
case (ZdividesP v (radix * (radix * Zpower_nat radix (n + p)))).
2: simpl in |- *; auto.
intros H' H'0; Contradict H'0; auto with zarith.
Qed.
 
Theorem maxDivSimpl :
 forall (v : Z) (p q : nat),
 p < q -> p = maxDiv v q -> p = maxDiv v (S p).
intros v p q H' H'0.
apply maxDivSimplAux with (q := q - S p); auto.
replace (S (q - S p + p)) with q; auto with zarith.
Qed.
 
Theorem maxDivSimplInvAux :
 forall (v : Z) (p q : nat),
 p = maxDiv v (S p) -> p = maxDiv v (S (q + p)).
intros v p q H'; elim q.
simpl in |- *; auto.
intros n; simpl in |- *.
case (ZdividesP v (radix * Zpower_nat radix (n + p))); auto.
case (ZdividesP v (radix * (radix * Zpower_nat radix (n + p)))); auto.
intros H'0 H'1 H'2; Contradict H'2; auto with zarith.
case (ZdividesP v (radix * (radix * Zpower_nat radix (n + p)))); auto.
intros H'0 H'1 H'2; case H'1.
case H'0; intros z1 Hz1; exists (radix * z1)%Z;rewrite Hz1.
unfold Zpower_nat; simpl; ring.
Qed.
 
Theorem maxDivSimplInv :
 forall (v : Z) (p q : nat),
 p < q -> p = maxDiv v (S p) -> p = maxDiv v q.
intros v p q H' H'0.
replace q with (S (q - S p + p)); auto with zarith.
apply maxDivSimplInvAux; auto.
Qed.
 
Theorem maxDivUnique :
 forall (v : Z) (p : nat),
 p = maxDiv v (S p) ->
 Zdivides v (Zpower_nat radix p) /\ ~ Zdivides v (Zpower_nat radix (S p)).
intros v p H'; split.
rewrite H'.
apply maxDivCorrect; auto.
red in |- *; intros H'0; generalize H'; clear H'.
simpl in |- *.
case (ZdividesP v (radix * Zpower_nat radix p)); simpl in |- *; auto.
intros H' H'1; Contradict H'1; auto with zarith.
Qed.
 
Theorem maxDivUniqueDigit :
 forall v : Z,
 v <> 0 ->
 Zdivides v (Zpower_nat radix (maxDiv v (digit radix v))) /\
 ~ Zdivides v (Zpower_nat radix (S (maxDiv v (digit radix v)))).
intros v H'.
apply maxDivUnique; auto.
apply maxDivSimpl with (q := digit radix v); auto.
apply maxDivLt; auto.
apply NotDividesDigit; auto.
Qed.
 
Theorem maxDivUniqueInverse :
 forall (v : Z) (p : nat),
 Zdivides v (Zpower_nat radix p) ->
 ~ Zdivides v (Zpower_nat radix (S p)) -> p = maxDiv v (S p).
intros v p H' H'0; simpl in |- *.
case (ZdividesP v (radix * Zpower_nat radix p)); auto.
intros H'1; case H'0; simpl in |- *; auto.
intros H'1.
generalize H'; case p; simpl in |- *; auto.
intros n H'2; case (ZdividesP v (radix * Zpower_nat radix n)); auto.
intros H'3; case H'3; auto.
Qed.
 
Theorem maxDivUniqueInverseDigit :
 forall (v : Z) (p : nat),
 v <> 0 ->
 Zdivides v (Zpower_nat radix p) ->
 ~ Zdivides v (Zpower_nat radix (S p)) -> p = maxDiv v (digit radix v).
intros v p H' H'0 H'1.
apply maxDivSimplInv; auto.
2: apply maxDivUniqueInverse; auto.
apply Zpower_nat_anti_monotone_lt with (n := radix); auto.
apply Zle_lt_trans with (m := Zabs v); auto.
rewrite <- (fun x => Zabs_eq (Zpower_nat radix x)); auto with zarith;
 apply ZDividesLe; auto.
apply digitMore; auto.
Qed.
 
Theorem maxDivPlus :
 forall (v : Z) (n : nat),
 v <> 0 ->
 maxDiv (v * Zpower_nat radix n) (digit radix v + n) =
 maxDiv v (digit radix v) + n.
intros v n H.
replace (digit radix v + n) with (digit radix (v * Zpower_nat radix n)); auto.
apply sym_equal.
apply maxDivUniqueInverseDigit; auto.
red in |- *; intros Z1; case (Zmult_integral _ _ Z1); intros Z2.
case H; auto.
absurd (0 < Zpower_nat radix n)%Z; auto with zarith.
rewrite Zpower_nat_is_exp.
repeat rewrite (fun x : Z => Zmult_comm x (Zpower_nat radix n)).
apply ZdividesMult; auto.
case (maxDivUniqueDigit v); auto.
replace (S (maxDiv v (digit radix v) + n)) with
 (S (maxDiv v (digit radix v)) + n); auto.
rewrite Zpower_nat_is_exp.
repeat rewrite (fun x : Z => Zmult_comm x (Zpower_nat radix n)).
red in |- *; intros H'.
absurd (Zdivides v (Zpower_nat radix (S (maxDiv v (digit radix v))))).
case (maxDivUniqueDigit v); auto.
apply ZdividesDiv with (p := Zpower_nat radix n); auto with zarith.
apply digitAdd; auto with zarith.
Qed.
 
Definition LSB (x : float) :=
  (Z_of_nat (maxDiv (Fnum x) (Fdigit radix x)) + Fexp x)%Z.
 
Theorem LSB_shift :
 forall (x : float) (n : nat), ~ is_Fzero x -> LSB x = LSB (Fshift radix n x).
intros x n H'; unfold LSB, Fdigit in |- *; simpl in |- *.
rewrite digitAdd; auto with arith.
rewrite maxDivPlus; auto.
rewrite inj_plus; ring.
Qed.
 
Theorem LSB_comp :
 forall (x y : float) (n : nat), ~ is_Fzero x -> x = y :>R -> LSB x = LSB y.
intros x y H' H'0 H'1.
case (FshiftCorrectSym radix) with (2 := H'1); auto.
intros m1 H'2; elim H'2; intros m2 E; clear H'2.
rewrite (LSB_shift x m1); auto.
rewrite E; auto.
apply sym_equal; apply LSB_shift; auto.
apply (NisFzeroComp radix) with (x := x); auto.
Qed.
 
Theorem maxDiv_opp :
 forall (v : Z) (p : nat), maxDiv v p = maxDiv (- v) p.
intros v p; elim p; simpl in |- *; auto.
intros n H; case (ZdividesP v (radix * Zpower_nat radix n));
 case (ZdividesP (- v) (radix * Zpower_nat radix n)); auto.
intros Z1 Z2; case Z1.
case Z2; intros z1 Hz1; exists (- z1)%Z; rewrite Hz1; ring.
intros Z1 Z2; case Z2.
case Z1; intros z1 Hz1; exists (- z1)%Z.
rewrite <- (Zopp_involutive v); rewrite Hz1; ring.
Qed.
 
Theorem LSB_opp : forall x : float, LSB x = LSB (Fopp x).
intros x; unfold LSB in |- *; simpl in |- *.
rewrite Fdigit_opp; auto.
rewrite maxDiv_opp; auto.
Qed.
 
Theorem maxDiv_abs :
 forall (v : Z) (p : nat), maxDiv v p = maxDiv (Zabs v) p.
intros v p; elim p; simpl in |- *; auto.
intros n H; case (ZdividesP v (radix * Zpower_nat radix n));
 case (ZdividesP (Zabs v) (radix  * Zpower_nat radix n));
 auto.
intros Z1 Z2; case Z1.
case Z2; intros z1 Hz1; exists (Zabs z1); rewrite Hz1.
rewrite Zabs_Zmult; f_equal. apply Zabs_eq. auto with zarith.
intros Z1 Z2; case Z2.
case Z1; intros z1 Hz1.
case (Zle_or_lt v 0); intros Z4.
exists (- z1)%Z; rewrite <- (Zopp_involutive v);
 rewrite <- (Zabs_eq_opp v); auto; rewrite Hz1; ring.
exists z1; rewrite <- (Zabs_eq v); auto with zarith; rewrite Hz1; ring.
Qed.

Theorem LSB_abs : forall x : float, LSB x = LSB (Fabs x).
intros x; unfold LSB in |- *; simpl in |- *.
rewrite Fdigit_abs; auto.
rewrite maxDiv_abs; auto.
Qed.
 
Definition MSB (x : float) := Zpred (Z_of_nat (Fdigit radix x) + Fexp x).
 
Theorem MSB_shift :
 forall (x : float) (n : nat), ~ is_Fzero x -> MSB x = MSB (Fshift radix n x).
intros; unfold MSB, Fshift, Fdigit in |- *; simpl in |- *.
rewrite digitAdd; auto with zarith.
rewrite inj_plus; unfold Zpred in |- *; ring.
Qed.
 
Theorem MSB_comp :
 forall (x y : float) (n : nat), ~ is_Fzero x -> x = y :>R -> MSB x = MSB y.
intros x y H' H'0 H'1.
case (FshiftCorrectSym radix) with (2 := H'1); auto.
intros m1 H'2; elim H'2; intros m2 E; clear H'2.
rewrite (MSB_shift x m1); auto.
rewrite E; auto.
apply sym_equal; apply MSB_shift; auto.
apply (NisFzeroComp radix) with (x := x); auto.
Qed.
 
Theorem MSB_opp : forall x : float, MSB x = MSB (Fopp x).
intros x; unfold MSB in |- *; simpl in |- *.
rewrite Fdigit_opp; auto.
Qed.
 
Theorem MSB_abs : forall x : float, MSB x = MSB (Fabs x).
intros x; unfold MSB in |- *; simpl in |- *.
rewrite Fdigit_abs; auto.
Qed.
 
Theorem LSB_le_MSB : forall x : float, ~ is_Fzero x -> (LSB x <= MSB x)%Z.
intros x H'; unfold LSB, MSB in |- *.
apply Zle_Zpred.
cut (maxDiv (Fnum x) (Fdigit radix x) < Fdigit radix x); auto with zarith.
apply maxDivLt; auto.
unfold Fdigit in |- *; apply NotDividesDigit; auto.
Qed.
 
Theorem Fexp_le_LSB : forall x : float, (Fexp x <= LSB x)%Z.
intros x; unfold LSB in |- *.
auto with zarith.
Qed.
 
Theorem Ulp_Le_LSigB :
 forall x : float, (Float 1%nat (Fexp x) <= Float 1%nat (LSB x))%R.
intros x; apply (oneExp_le radix); auto.
apply Fexp_le_LSB; auto.
Qed.
 
Theorem Fexp_le_MSB : forall x : float, ~ is_Fzero x -> (Fexp x <= MSB x)%Z.
intros x H'; unfold MSB in |- *.
cut (Fdigit radix x <> 0%Z :>Z); unfold Zpred in |- *;
 auto with zarith.
unfold Fdigit in |- *.
red in |- *; intros H'0; absurd (digit radix (Fnum x) = 0); auto with zarith.
apply not_eq_sym; apply lt_O_neq; apply digitNotZero; auto.
Qed.
 
Theorem MSB_le_abs :
 forall x : float, ~ is_Fzero x -> (Float 1%nat (MSB x) <= Fabs x)%R.
intros x H'; unfold MSB, FtoRradix, FtoR in |- *; simpl in |- *.
replace (Zpred (Fdigit radix x + Fexp x)) with
 (Zpred (Fdigit radix x) + Fexp x)%Z; [ idtac | unfold Zpred in |- *; ring ].
rewrite powerRZ_add; auto with real zarith.
rewrite Rmult_1_l.
repeat rewrite (fun r : R => Rmult_comm r (powerRZ radix (Fexp x))).
apply Rmult_le_compat_l; auto with real zarith.
rewrite <- inj_pred; auto with real zarith.
rewrite <- Zpower_nat_Z_powerRZ; auto.
apply Rle_IZR; auto.
unfold Fdigit in |- *; auto with arith.
apply digitLess; auto.
unfold Fdigit in |- *.
apply not_eq_sym; apply lt_O_neq; apply digitNotZero; auto.
Qed.
 
Theorem abs_lt_MSB :
 forall x : float, (Fabs x < Float 1%nat (Zsucc (MSB x)))%R.
intros x.
rewrite (MSB_abs x).
unfold MSB, FtoRradix, FtoR in |- *.
rewrite <- Zsucc_pred; simpl in |- *.
rewrite powerRZ_add; auto with real zarith.
rewrite Rmult_1_l.
repeat rewrite (fun r : R => Rmult_comm r (powerRZ radix (Fexp x))).
apply Rmult_lt_compat_l; auto with real zarith.
rewrite <- Zpower_nat_Z_powerRZ; auto with arith.
apply Rlt_IZR.
unfold Fdigit in |- *; auto with arith.
unfold Fabs in |- *; simpl in |- *.
pattern (Zabs (Fnum x)) at 1 in |- *; rewrite <- (Zabs_eq (Zabs (Fnum x)));
 auto with zarith.
Qed.
 
Theorem LSB_le_abs :
 forall x : float, ~ is_Fzero x -> (Float 1%nat (LSB x) <= Fabs x)%R.
intros x H'; apply Rle_trans with (FtoRradix (Float 1%nat (MSB x))).
apply (oneExp_le radix); auto.
apply LSB_le_MSB; auto.
apply MSB_le_abs; auto.
Qed.
 
Theorem MSB_monotoneAux :
 forall x y : float,
 (Fabs x <= Fabs y)%R -> Fexp x = Fexp y -> (MSB x <= MSB y)%Z.
intros x y H' H'0; unfold MSB in |- *.
rewrite <- H'0.
cut (Fdigit radix x <= Fdigit radix y)%Z;
 [ unfold Zpred in |- *; auto with zarith | idtac ].
unfold Fdigit in |- *; apply inj_le.
apply digit_monotone; auto.
apply le_IZR.
apply Rmult_le_reg_l with (r := powerRZ radix (Fexp x));
 auto with real zarith.
repeat rewrite (Rmult_comm (powerRZ radix (Fexp x))); auto.
pattern (Fexp x) at 2 in |- *; rewrite H'0; auto.
Qed.
 
Theorem MSB_monotone :
 forall x y : float,
 ~ is_Fzero x -> ~ is_Fzero y -> (Fabs x <= Fabs y)%R -> (MSB x <= MSB y)%Z.
intros x y H' H'0 H'1; rewrite (MSB_abs x); rewrite (MSB_abs y).
case (Zle_or_lt (Fexp (Fabs x)) (Fexp (Fabs y))); simpl in |- *; intros Zle1.
rewrite
 MSB_shift with (x := Fabs y) (n := Zabs_nat (Fexp (Fabs y) - Fexp (Fabs x))).
apply MSB_monotoneAux; auto.
unfold FtoRradix in |- *; repeat rewrite Fabs_correct; auto with real arith.
rewrite FshiftCorrect; auto with real arith.
repeat rewrite Fabs_correct; auto with real arith.
repeat rewrite Rabs_Rabsolu; repeat rewrite <- Fabs_correct;
 auto with real arith.
unfold Fshift in |- *; simpl in |- *.
rewrite inj_abs; [ ring | auto with zarith ].
apply Fabs_Fzero; auto.
rewrite
 MSB_shift with (x := Fabs x) (n := Zabs_nat (Fexp (Fabs x) - Fexp (Fabs y))).
apply MSB_monotoneAux; auto.
unfold FtoRradix in |- *; repeat rewrite Fabs_correct; auto with real arith.
rewrite FshiftCorrect; auto with real arith.
repeat rewrite Fabs_correct; auto with real arith.
repeat rewrite Rabs_Rabsolu; repeat rewrite <- Fabs_correct;
 auto with real arith.
unfold Fshift in |- *; simpl in |- *.
rewrite inj_abs; [ ring | auto with zarith ].
apply Fabs_Fzero; auto.
Qed.
 
Theorem MSB_le_multAux :
 forall x y : float,
 ~ is_Fzero x -> ~ is_Fzero y -> (MSB x + MSB y <= MSB (Fmult x y))%Z.
intros x y H' H'0; unfold MSB, Fmult, Fdigit in |- *; simpl in |- *.
replace
 (Zpred (digit radix (Fnum x) + Fexp x) +
  Zpred (digit radix (Fnum y) + Fexp y))%Z with
 (Zpred
    (digit radix (Fnum x) + Zpred (digit radix (Fnum y)) + (Fexp x + Fexp y)));
 [ idtac | unfold Zpred in |- *; ring ].
cut
 (digit radix (Fnum x) + Zpred (digit radix (Fnum y)) <=
  digit radix (Fnum x * Fnum y))%Z;
 [ unfold Zpred in |- *; auto with zarith | idtac ].
rewrite <- inj_pred; auto with float zarith; try rewrite <- inj_plus.
apply inj_le.
rewrite <- digitAdd; auto with zarith.
apply digit_monotone; auto with zarith.
repeat rewrite Zabs_Zmult.
apply Zle_Zmult_comp_l; auto with zarith.
rewrite (fun x => Zabs_eq (Zpower_nat radix x)); auto with zarith.
apply not_eq_sym; apply lt_O_neq; apply digitNotZero; auto.
Qed.
 
Theorem MSB_le_mult :
 forall x y : float,
 ~ is_Fzero x ->
 ~ is_Fzero y ->
 (Fmult (Float 1%nat (MSB x)) (Float 1%nat (MSB y)) <=
  Float 1%nat (MSB (Fmult x y)))%R.
intros x y H' H'0.
rewrite <- oneZplus.
apply (oneExp_le radix); auto.
apply MSB_le_multAux; auto.
Qed.
 
Theorem mult_le_MSBAux :
 forall x y : float,
 ~ is_Fzero x -> ~ is_Fzero y -> (MSB (Fmult x y) <= Zsucc (MSB x + MSB y))%Z.
intros x y H' H'0; unfold MSB, Fmult, Fdigit in |- *; simpl in |- *.
replace
 (Zsucc
    (Zpred (digit radix (Fnum x) + Fexp x) +
     Zpred (digit radix (Fnum y) + Fexp y))) with
 (Zpred (digit radix (Fnum x) + digit radix (Fnum y) + (Fexp x + Fexp y)));
 [ idtac | unfold Zpred, Zsucc in |- *; ring ].
cut
 (digit radix (Fnum x * Fnum y) <=
  digit radix (Fnum x) + digit radix (Fnum y))%Z;
 [ unfold Zpred in |- *; auto with zarith | idtac ].
rewrite <- inj_plus.
apply inj_le; auto.
rewrite <- digitAdd; auto with arith.
apply digit_monotone; auto with arith.
repeat rewrite Zabs_Zmult.
apply Zle_Zmult_comp_l; auto with zarith.
rewrite (fun x => Zabs_eq (Zpower_nat radix x)); auto with zarith.
Qed.
 
Theorem mult_le_MSB :
 forall x y : float,
 ~ is_Fzero x ->
 ~ is_Fzero y ->
 (Float 1%nat (MSB (Fmult x y)) <=
  radix * Fmult (Float 1%nat (MSB x)) (Float 1%nat (MSB y)))%R.
intros x y H' H'0; rewrite <- oneZplus.
replace (radix * Float 1%nat (MSB x + MSB y))%R with
 (FtoRradix (Float 1%nat (Zsucc (MSB x + MSB y)))).
apply (oneExp_le radix); auto.
apply mult_le_MSBAux; auto.
unfold FtoRradix, FtoR in |- *; simpl in |- *.
rewrite powerRZ_Zs; auto with real zarith; ring.
Qed.
 
Theorem MSB_mix :
 forall x y : float,
 ~ is_Fzero x ->
 ~ is_Fzero y ->
 (Fabs x * Float 1%nat (MSB y) < radix * (Fabs y * Float 1%nat (MSB x)))%R.
intros x y H' H'0; rewrite (MSB_abs x); rewrite (MSB_abs y).
apply Rle_lt_trans with (Fabs x * Fabs y)%R; auto with real.
apply Rmult_le_compat_l; auto with real.
unfold FtoRradix in |- *; rewrite Fabs_correct; auto with real arith.
rewrite <- MSB_abs; apply MSB_le_abs; auto.
rewrite (Rmult_comm (Fabs x)).
replace (radix * (Fabs y * Float 1%nat (MSB (Fabs x))))%R with
 (Fabs y * (radix * Float 1%nat (MSB (Fabs x))))%R; 
 [ idtac | ring ].
apply Rmult_lt_compat_l; auto with real.
unfold FtoRradix, FtoR in |- *; simpl in |- *; auto with real arith.
rewrite Rmult_comm; replace 0%R with (powerRZ radix (Fexp y) * 0)%R;
 [ idtac | ring ].
apply Rmult_lt_compat_l; auto with real arith.
rewrite Zabs_absolu.
replace 0%R with (INR 0); [ idtac | simpl in |- *; auto ];
 rewrite <- INR_IZR_INZ; apply INR_lt_nm.
apply absolu_lt_nz; auto.
replace (radix * Float 1%nat (MSB (Fabs x)))%R with
 (FtoRradix (Float 1%nat (Zsucc (MSB (Fabs x))))).
rewrite <- MSB_abs; apply abs_lt_MSB; auto.
unfold FtoRradix, FtoR in |- *; simpl in |- *.
rewrite powerRZ_Zs; auto with real zarith; ring.
Qed.
 
Theorem LSB_rep :
 forall x y : float,
 ~ is_Fzero y ->
 (LSB x <= LSB y)%Z -> exists z : Z, y = Float z (Fexp x) :>R.
intros x y H' H'0.
case (Zle_or_lt (Fexp x) (Fexp y)); intros Zl1.
exists (Fnum y * Zpower_nat radix (Zabs_nat (Fexp y - Fexp x)))%Z.
pattern (Fexp x) at 2 in |- *;
 replace (Fexp x) with (Fexp y - Zabs_nat (Fexp y - Fexp x))%Z.
unfold FtoRradix in |- *;
 rewrite <-
  (FshiftCorrect radix) with (n := Zabs_nat (Fexp y - Fexp x)) (x := y); 
 auto.
rewrite inj_abs; try ring; auto with zarith.
exists (Zquotient (Fnum y) (Zpower_nat radix (Zabs_nat (Fexp x - Fexp y)))).
unfold FtoRradix in |- *;
 rewrite <-
  (FshiftCorrect radix)
                        with
                        (n := Zabs_nat (Fexp x - Fexp y))
                       (x := 
                         Float
                           (Zquotient (Fnum y)
                              (Zpower_nat radix (Zabs_nat (Fexp x - Fexp y))))
                           (Fexp x)); auto.
unfold Fshift in |- *; simpl in |- *.
cut (0 <= Fexp x - Fexp y)%Z;
 [ intros Le1; repeat rewrite inj_abs | auto with zarith ]; 
 auto.
unfold FtoR in |- *; simpl in |- *; auto.
replace (Fexp x - (Fexp x - Fexp y))%Z with (Fexp y); [ idtac | ring ].
replace
 (Zquotient (Fnum y) (Zpower_nat radix (Zabs_nat (Fexp x - Fexp y))) *
  Zpower_nat radix (Zabs_nat (Fexp x - Fexp y)))%Z with (
 Fnum y); auto.
apply ZdividesZquotient; auto with zarith.
apply
 ZdividesTrans
  with (m := Zpower_nat radix (maxDiv (Fnum y) (Fdigit radix y))).
apply maxDivCorrect.
apply ZdividesLessPow; auto.
apply ZleLe.
rewrite inj_abs; auto with zarith.
apply Zplus_le_reg_l with (p := Fexp y).
apply Zle_trans with (LSB x).
replace (Fexp y + (Fexp x - Fexp y))%Z with (Fexp x); [ idtac | ring ].
apply Fexp_le_LSB.
rewrite Zplus_comm; auto.
Qed.
 
Theorem LSB_rep_min :
 forall p : float, exists z : Z, p = Float z (LSB p) :>R.
intros p;
 exists (Zquotient (Fnum p) (Zpower_nat radix (Zabs_nat (LSB p - Fexp p)))).
unfold FtoRradix, FtoR, LSB in |- *; simpl in |- *.
rewrite powerRZ_add; auto with real zarith.
rewrite <- Rmult_assoc.
replace (maxDiv (Fnum p) (Fdigit radix p) + Fexp p - Fexp p)%Z with
 (Z_of_nat (maxDiv (Fnum p) (Fdigit radix p))); auto.
rewrite absolu_INR.
rewrite <- Zpower_nat_Z_powerRZ; auto with zarith.
rewrite <- Rmult_IZR.
rewrite <- ZdividesZquotient; auto with zarith.
apply maxDivCorrect.
ring.
Qed.
End mf.