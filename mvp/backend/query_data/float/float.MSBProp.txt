
Require Export MSB.
(* MSB:
Require Export Fprop.
Require Export Zdivides.
Require Export Fnorm.
Section mf.
Variable radix : Z.
Hypothesis radixMoreThanOne : (1 < radix)%Z.
 
Let radixMoreThanZERO := Zlt_1_O _ (Zlt_le_weak _ _ radixMoreThanOne).
Hint Resolve radixMoreThanZERO: zarith.

Let FtoRradix := FtoR radix.
Local Coercion FtoRradix : float >-> R.

Fixpoint maxDiv (v : Z) (p : nat) {struct p} : nat :=
  match p with
  | O => 0
  | S p' =>
      match ZdividesP v (Zpower_nat radix p) with
      | left _ => p
      | right _ => maxDiv v p'
      end
  end.
 
Theorem maxDivLess : forall (v : Z) (p : nat), maxDiv v p <= p.
 
Theorem maxDivLt :
 forall (v : Z) (p : nat),
 ~ Zdivides v (Zpower_nat radix p) -> maxDiv v p < p.
 
Theorem maxDivCorrect :
 forall (v : Z) (p : nat), Zdivides v (Zpower_nat radix (maxDiv v p)).
 
Theorem maxDivSimplAux :
 forall (v : Z) (p q : nat),
 p = maxDiv v (S (q + p)) -> p = maxDiv v (S p).
 
Theorem maxDivSimpl :
 forall (v : Z) (p q : nat),
 p < q -> p = maxDiv v q -> p = maxDiv v (S p).
 
Theorem maxDivSimplInvAux :
 forall (v : Z) (p q : nat),
 p = maxDiv v (S p) -> p = maxDiv v (S (q + p)).
 
Theorem maxDivSimplInv :
 forall (v : Z) (p q : nat),
 p < q -> p = maxDiv v (S p) -> p = maxDiv v q.
 
Theorem maxDivUnique :
 forall (v : Z) (p : nat),
 p = maxDiv v (S p) ->
 Zdivides v (Zpower_nat radix p) /\ ~ Zdivides v (Zpower_nat radix (S p)).
 
Theorem maxDivUniqueDigit :
 forall v : Z,
 v <> 0 ->
 Zdivides v (Zpower_nat radix (maxDiv v (digit radix v))) /\
 ~ Zdivides v (Zpower_nat radix (S (maxDiv v (digit radix v)))).
 
Theorem maxDivUniqueInverse :
 forall (v : Z) (p : nat),
 Zdivides v (Zpower_nat radix p) ->
 ~ Zdivides v (Zpower_nat radix (S p)) -> p = maxDiv v (S p).
 
Theorem maxDivUniqueInverseDigit :
 forall (v : Z) (p : nat),
 v <> 0 ->
 Zdivides v (Zpower_nat radix p) ->
 ~ Zdivides v (Zpower_nat radix (S p)) -> p = maxDiv v (digit radix v).
 
Theorem maxDivPlus :
 forall (v : Z) (n : nat),
 v <> 0 ->
 maxDiv (v * Zpower_nat radix n) (digit radix v + n) =
 maxDiv v (digit radix v) + n.
 
Definition LSB (x : float) :=
  (Z_of_nat (maxDiv (Fnum x) (Fdigit radix x)) + Fexp x)%Z.
 
Theorem LSB_shift :
 forall (x : float) (n : nat), ~ is_Fzero x -> LSB x = LSB (Fshift radix n x).
 
Theorem LSB_comp :
 forall (x y : float) (n : nat), ~ is_Fzero x -> x = y :>R -> LSB x = LSB y.
 
Theorem maxDiv_opp :
 forall (v : Z) (p : nat), maxDiv v p = maxDiv (- v) p.
 
Theorem LSB_opp : forall x : float, LSB x = LSB (Fopp x).
 
Theorem maxDiv_abs :
 forall (v : Z) (p : nat), maxDiv v p = maxDiv (Zabs v) p.

Theorem LSB_abs : forall x : float, LSB x = LSB (Fabs x).
 
Definition MSB (x : float) := Zpred (Z_of_nat (Fdigit radix x) + Fexp x).
 
Theorem MSB_shift :
 forall (x : float) (n : nat), ~ is_Fzero x -> MSB x = MSB (Fshift radix n x).
 
Theorem MSB_comp :
 forall (x y : float) (n : nat), ~ is_Fzero x -> x = y :>R -> MSB x = MSB y.
 
Theorem MSB_opp : forall x : float, MSB x = MSB (Fopp x).
 
Theorem MSB_abs : forall x : float, MSB x = MSB (Fabs x).
 
Theorem LSB_le_MSB : forall x : float, ~ is_Fzero x -> (LSB x <= MSB x)%Z.
 
Theorem Fexp_le_LSB : forall x : float, (Fexp x <= LSB x)%Z.
 
Theorem Ulp_Le_LSigB :
 forall x : float, (Float 1%nat (Fexp x) <= Float 1%nat (LSB x))%R.
 
Theorem Fexp_le_MSB : forall x : float, ~ is_Fzero x -> (Fexp x <= MSB x)%Z.
 
Theorem MSB_le_abs :
 forall x : float, ~ is_Fzero x -> (Float 1%nat (MSB x) <= Fabs x)%R.
 
Theorem abs_lt_MSB :
 forall x : float, (Fabs x < Float 1%nat (Zsucc (MSB x)))%R.
 
Theorem LSB_le_abs :
 forall x : float, ~ is_Fzero x -> (Float 1%nat (LSB x) <= Fabs x)%R.
 
Theorem MSB_monotoneAux :
 forall x y : float,
 (Fabs x <= Fabs y)%R -> Fexp x = Fexp y -> (MSB x <= MSB y)%Z.
 
Theorem MSB_monotone :
 forall x y : float,
 ~ is_Fzero x -> ~ is_Fzero y -> (Fabs x <= Fabs y)%R -> (MSB x <= MSB y)%Z.
 
Theorem MSB_le_multAux :
 forall x y : float,
 ~ is_Fzero x -> ~ is_Fzero y -> (MSB x + MSB y <= MSB (Fmult x y))%Z.
 
Theorem MSB_le_mult :
 forall x y : float,
 ~ is_Fzero x ->
 ~ is_Fzero y ->
 (Fmult (Float 1%nat (MSB x)) (Float 1%nat (MSB y)) <=
  Float 1%nat (MSB (Fmult x y)))%R.
 
Theorem mult_le_MSBAux :
 forall x y : float,
 ~ is_Fzero x -> ~ is_Fzero y -> (MSB (Fmult x y) <= Zsucc (MSB x + MSB y))%Z.
 
Theorem mult_le_MSB :
 forall x y : float,
 ~ is_Fzero x ->
 ~ is_Fzero y ->
 (Float 1%nat (MSB (Fmult x y)) <=
  radix * Fmult (Float 1%nat (MSB x)) (Float 1%nat (MSB y)))%R.
 
Theorem MSB_mix :
 forall x y : float,
 ~ is_Fzero x ->
 ~ is_Fzero y ->
 (Fabs x * Float 1%nat (MSB y) < radix * (Fabs y * Float 1%nat (MSB x)))%R.
 
Theorem LSB_rep :
 forall x y : float,
 ~ is_Fzero y ->
 (LSB x <= LSB y)%Z -> exists z : Z, y = Float z (Fexp x) :>R.
 
Theorem LSB_rep_min :
 forall p : float, exists z : Z, p = Float z (LSB p) :>R.
End mf. *)
Section MSBProp.
Variable b : Fbound.
Variable precision : nat.
Variable radix : Z.
 
Let FtoRradix := FtoR radix.
Coercion FtoRradix : float >-> R.
Hypothesis radixMoreThanOne : (1 < radix)%Z.
 
Let radixMoreThanZERO : (0 < radix)%Z :=
  Zlt_1_O _ (Zlt_le_weak _ _ radixMoreThanOne).
Hint Resolve radixMoreThanZERO: zarith.
Hypothesis precisionGreaterThanOne : 1 < precision.
Hypothesis pGivesBound : Zpos (vNum b) = Zpower_nat radix precision.
 
Theorem boundOnePrecision :
 forall a : float,
 Fbounded b a -> (Rabs a < Float 1%nat (precision + Fexp a))%R.
intros a H.
replace (FtoRradix (Float 1%nat (precision + Fexp a))) with
 (FtoRradix (Fshift radix precision (Float 1%nat (precision + Fexp a))));
 [ idtac | apply (FshiftCorrect radix); auto ].
unfold Fshift, FtoRradix, FtoR in |- *; simpl in |- *.
rewrite <- pGivesBound.
replace (precision + Fexp a - precision)%Z with (Fexp a); [ idtac | ring ].
rewrite Rabs_mult; rewrite (fun x y => Rabs_pos_eq (powerRZ x y));
 auto with real zarith.
apply Rlt_monotony_exp; auto with float real zarith.
rewrite Faux.Rabsolu_Zabs; auto with float real zarith.
Qed.
 
Theorem boundNormalMult :
 forall x y : float,
 Fnormal radix b x ->
 Fbounded b y ->
 (Rabs y * Float 1%nat (Fexp x) < radix * (Rabs x * Float 1%nat (Fexp y)))%R.
intros x y H H0.
apply
 Rlt_le_trans
  with (Float (Zpos (vNum b)) (Fexp y) * Float 1%nat (Fexp x))%R.
apply Rmult_lt_compat_r.
unfold FtoRradix in |- *; unfold FtoR in |- *; simpl in |- *.
replace (1 * powerRZ radix (Fexp x))%R with (powerRZ radix (Fexp x));
 [ idtac | ring ].
apply powerRZ_lt; auto with real arith.
unfold FtoRradix in |- *; apply MaxFloat; auto.
replace (Float (Zpos (vNum b)) (Fexp y) * Float 1%nat (Fexp x))%R with
 (Zpos (vNum b) * Float 1%nat (Fexp x) * Float 1%nat (Fexp y))%R.
replace (radix * (Rabs x * Float 1%nat (Fexp y)))%R with
 (radix * Rabs x * Float 1%nat (Fexp y))%R; [ idtac | ring ].
apply Rmult_le_compat_r.
unfold FtoRradix in |- *; unfold FtoR in |- *; simpl in |- *.
replace (1 * powerRZ radix (Fexp y))%R with (powerRZ radix (Fexp y));
 [ idtac | ring ].
apply powerRZ_le; auto with real arith.
replace (Zpos (vNum b) * Float 1%nat (Fexp x))%R with
 (FtoRradix (Float (Zpos (vNum b)) (Fexp x))).
rewrite <- (Fabs_correct radix); auto with real zarith.
unfold Fabs, FtoRradix, FtoR in |- *.
rewrite <- Rmult_assoc.
apply Rle_monotone_exp; auto with real arith.
rewrite <- Rmult_IZR; apply Rle_IZR; simpl in |- *.
rewrite <- (Zabs_eq radix); auto with zarith; rewrite <- Zabs_Zmult;
 auto with float.
case H; simpl in |- *; auto.
unfold FtoRradix, FtoR in |- *; simpl in |- *; ring.
unfold FtoRradix, FtoR in |- *; simpl in |- *; ring.
Qed.
End MSBProp.