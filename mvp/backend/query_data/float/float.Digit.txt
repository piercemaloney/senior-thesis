
Require Export ZArithRing.
Require Export Omega.
Require Export Faux.
(* Faux:
Require Export Min.
Require Export Arith.
Require Export Reals.
Require Export Zpower.
Require Export ZArith.
Require Export Zcomplements.
Require Export sTactic.
Hint Resolve R1_neq_R0: real.

Theorem minus_minus : forall a b : nat, a <= b -> b - (b - a) = a.
 
Theorem lte_comp_mult :
 forall p q r t : nat, p <= q -> r <= t -> p * r <= q * t.
Hint Resolve lte_comp_mult: arith.
 
Theorem le_refl_eq : forall n m : nat, n = m -> n <= m.
 
Theorem lt_le_pred : forall n m : nat, n < m -> n <= pred m.
 
Theorem lt_comp_mult_l : forall p q r : nat, 0 < p -> q < r -> p * q < p * r.
Hint Resolve lt_comp_mult_l: arith.
 
Theorem lt_comp_mult_r : forall p q r : nat, 0 < p -> q < r -> q * p < r * p.
Hint Resolve lt_comp_mult_r: arith.
 
Theorem lt_comp_mult : forall p q r s : nat, p < q -> r < s -> p * r < q * s.
Hint Resolve lt_comp_mult: arith.
 
Theorem mult_eq_inv : forall n m p : nat, 0 < n -> n * m = n * p -> m = p.
 
Definition natEq : forall n m : nat, {n = m} + {n <> m}.
 
Theorem notEqLt : forall n : nat, 0 < n -> n <> 0.
Hint Resolve notEqLt: arith.
 
Theorem lt_next : forall n m : nat, n < m -> m = S n \/ S n < m.
 
Theorem le_next : forall n m : nat, n <= m -> m = n \/ S n <= m.
 
Theorem min_or :
 forall n m : nat, min n m = n /\ n <= m \/ min n m = m /\ m < n.
 
Theorem minus_inv_lt_aux : forall n m : nat, n - m = 0 -> n - S m = 0.
 
Theorem minus_inv_lt : forall n m : nat, m <= n -> m - n = 0.
 
Theorem minus_le : forall m n p q : nat, m <= n -> p <= q -> m - q <= n - p.
 
Theorem lt_minus_inv : forall n m p : nat, n <= p -> m < n -> p - n < p - m.
 
Theorem lt_mult_anti_compatibility :
 forall n n1 n2 : nat, 0 < n -> n * n1 < n * n2 -> n1 < n2.
 
Theorem le_mult_anti_compatibility :
 forall n n1 n2 : nat, 0 < n -> n * n1 <= n * n2 -> n1 <= n2.
 
Theorem min_n_0 : forall n : nat, min n 0 = 0.

Hint Resolve Rabs_pos: real.
 
Theorem Rlt_Rminus_ZERO : forall r1 r2 : R, (r2 < r1)%R -> (0 < r1 - r2)%R.
Hint Resolve Rlt_Rminus_ZERO: real.
 
Theorem Rabsolu_left1 : forall a : R, (a <= 0)%R -> Rabs a = (- a)%R.
 
Theorem RmaxLess1 : forall r1 r2 : R, (r1 <= Rmax r1 r2)%R.
 
Theorem RmaxLess2 : forall r1 r2 : R, (r2 <= Rmax r1 r2)%R.
 
Theorem RmaxSym : forall p q : R, Rmax p q = Rmax q p.
 
Theorem RmaxAbs :
 forall p q r : R,
 (p <= q)%R -> (q <= r)%R -> (Rabs q <= Rmax (Rabs p) (Rabs r))%R.
 
Theorem Rabsolu_Zabs : forall z : Z, Rabs (IZR z) = IZR (Zabs z).
 
Theorem RmaxRmult :
 forall p q r : R, (0 <= r)%R -> Rmax (r * p) (r * q) = (r * Rmax p q)%R.
 
Theorem Rle_R0_Ropp : forall p : R, (p <= 0)%R -> (0 <= - p)%R.
 
Theorem Rlt_R0_Ropp : forall p : R, (p < 0)%R -> (0 < - p)%R.
Hint Resolve Rle_R0_Ropp Rlt_R0_Ropp: real.

Theorem convert_not_O : forall p : positive, nat_of_P p <> 0.
Hint Resolve convert_not_O: zarith arith.
Hint Resolve Zlt_le_weak Zle_not_gt Zgt_irrefl Zlt_irrefl Zle_not_lt
  Zlt_not_le Zlt_asym inj_lt inj_le: zarith.
 
Theorem inj_abs :
 forall x : Z, (0 <= x)%Z -> Z_of_nat (Zabs_nat x) = x.
 
Theorem inject_nat_convert :
 forall (p : Z) (q : positive),
 p = Zpos q -> Z_of_nat (nat_of_P q) = p.
Hint Resolve inj_le inj_lt: zarith.
 
Theorem ZleLe : forall x y : nat, (Z_of_nat x <= Z_of_nat y)%Z -> x <= y.
 
Theorem inject_nat_eq : forall x y : nat, Z_of_nat x = Z_of_nat y -> x = y.
 
Theorem Zcompare_EGAL :
 forall p q : Z, (p ?= q)%Z = Datatypes.Eq -> p = q.
 
Theorem Zlt_Zopp : forall x y : Z, (x < y)%Z -> (- y < - x)%Z.
Hint Resolve Zlt_Zopp: zarith.
 
Theorem Zle_Zopp : forall x y : Z, (x <= y)%Z -> (- y <= - x)%Z.
Hint Resolve Zle_Zopp: zarith.
 
Theorem absolu_INR : forall n : nat, Zabs_nat (Z_of_nat n) = n.
 
Theorem absolu_Zopp : forall p : Z, Zabs_nat (- p) = Zabs_nat p.
 
Theorem Zabs_absolu : forall z : Z, Zabs z = Z_of_nat (Zabs_nat z).
 
Theorem absolu_comp_mult :
 forall p q : Z, Zabs_nat (p * q) = Zabs_nat p * Zabs_nat q.
 
Theorem Zmin_sym : forall m n : Z, Zmin n m = Zmin m n.
 
Theorem Zpower_nat_O : forall z : Z, Zpower_nat z 0 = Z_of_nat 1.
 
Theorem Zpower_nat_1 : forall z : Z, Zpower_nat z 1 = z.
 
Theorem Zmin_le1 : forall z1 z2 : Z, (z1 <= z2)%Z -> Zmin z1 z2 = z1.
 
Theorem Zmin_le2 : forall z1 z2 : Z, (z2 <= z1)%Z -> Zmin z1 z2 = z2.
 
Theorem Zmin_Zle :
 forall z1 z2 z3 : Z,
 (z1 <= z2)%Z -> (z1 <= z3)%Z -> (z1 <= Zmin z2 z3)%Z.
 
Theorem Zminus_n_predm :
 forall n m : Z, Zsucc (n - m) = (n - Zpred m)%Z.
 
Theorem Zopp_Zpred_Zs : forall z : Z, (- Zpred z)%Z = Zsucc (- z).
 
Theorem Zle_mult_gen :
 forall x y : Z, (0 <= x)%Z -> (0 <= y)%Z -> (0 <= x * y)%Z.
Hint Resolve Zle_mult_gen: zarith.
 
Definition Zmax : forall x_ x_ : Z, Z :=
  fun n m : Z =>
  match (n ?= m)%Z with
  | Datatypes.Eq => m
  | Datatypes.Lt => m
  | Datatypes.Gt => n
  end.
 
Theorem ZmaxLe1 : forall z1 z2 : Z, (z1 <= Zmax z1 z2)%Z.
 
Theorem ZmaxSym : forall z1 z2 : Z, Zmax z1 z2 = Zmax z2 z1.
 
Theorem Zmax_le2 : forall z1 z2 : Z, (z1 <= z2)%Z -> Zmax z1 z2 = z2.
 
Theorem Zmax_le1 : forall z1 z2 : Z, (z2 <= z1)%Z -> Zmax z1 z2 = z1.
 
Theorem ZmaxLe2 : forall z1 z2 : Z, (z2 <= Zmax z1 z2)%Z.
Hint Resolve ZmaxLe1 ZmaxLe2: zarith.
 
Theorem Zeq_Zs :
 forall p q : Z, (p <= q)%Z -> (q < Zsucc p)%Z -> p = q.
 
Theorem Zmin_Zmax : forall z1 z2 : Z, (Zmin z1 z2 <= Zmax z1 z2)%Z.
 
Theorem Zabs_Zmult :
 forall z1 z2 : Z, Zabs (z1 * z2) = (Zabs z1 * Zabs z2)%Z.
 
Theorem Zle_Zmult_comp_r :
 forall x y z : Z, (0 <= z)%Z -> (x <= y)%Z -> (x * z <= y * z)%Z.
 
Theorem Zle_Zmult_comp_l :
 forall x y z : Z, (0 <= z)%Z -> (x <= y)%Z -> (z * x <= z * y)%Z.
 
Theorem NotZmultZero :
 forall z1 z2 : Z, z1 <> 0%Z -> z2 <> 0%Z -> (z1 * z2)%Z <> 0%Z.
Hint Resolve NotZmultZero: zarith.

Theorem IZR_zero : forall p : Z, p = 0%Z -> IZR p = 0%R.
Hint Resolve not_O_INR: real.
 
Theorem IZR_zero_r : forall p : Z, IZR p = 0%R -> p = 0%Z.
 
Theorem INR_lt_nm : forall n m : nat, n < m -> (INR n < INR m)%R.
Hint Resolve INR_lt_nm: real.
 
Theorem Rlt_INR1 : forall n : nat, 1 < n -> (1 < INR n)%R.
Hint Resolve Rlt_INR1: real.
 
Theorem NEq_INR : forall n m : nat, n <> m -> INR n <> INR m.
Hint Resolve NEq_INR: real.
 
Theorem NEq_INRO : forall n : nat, n <> 0 -> INR n <> 0%R.
Hint Resolve NEq_INRO: real.
 
Theorem NEq_INR1 : forall n : nat, n <> 1 -> INR n <> 1%R.
Hint Resolve NEq_INR1: real.
 
Theorem not_O_lt : forall n : nat, n <> 0 -> 0 < n.
Hint Resolve not_O_lt: arith.
 
Theorem NEq_IZRO : forall n : Z, n <> 0%Z -> IZR n <> 0%R.
Hint Resolve NEq_IZRO: real.
 
Theorem Rlt_IZR : forall p q : Z, (p < q)%Z -> (IZR p < IZR q)%R.
Hint Resolve Rlt_IZR: real.
 
Theorem Rle_IZR : forall x y : Z, (x <= y)%Z -> (IZR x <= IZR y)%R.
Hint Resolve Rle_IZR: real.
 
Theorem Rlt_IZRO : forall p : Z, (0 < p)%Z -> (0 < IZR p)%R.
Hint Resolve Rlt_IZRO: real.
 
Theorem Rle_IZRO : forall x y : Z, (0 <= y)%Z -> (0 <= IZR y)%R.
Hint Resolve Rle_IZRO: real.
 
Theorem Rlt_IZR1 : forall p q : Z, (1 < q)%Z -> (1 < IZR q)%R.
Hint Resolve Rlt_IZR1: real.
 
Theorem Rle_IZR1 : forall x y : Z, (1 <= y)%Z -> (1 <= IZR y)%R.
Hint Resolve Rle_IZR1: real.
 
Theorem lt_Rlt : forall n m : nat, (INR n < INR m)%R -> n < m.
 
Theorem INR_inv : forall n m : nat, INR n = INR m -> n = m.
 
Theorem Rle_INR : forall x y : nat, x <= y -> (INR x <= INR y)%R.
Hint Resolve Rle_INR: real.
 
Theorem le_Rle : forall n m : nat, (INR n <= INR m)%R -> n <= m.
 
Theorem Rmult_IZR : forall z t : Z, IZR (z * t) = (IZR z * IZR t)%R.
 
Theorem absolu_Zs :
 forall z : Z, (0 <= z)%Z -> Zabs_nat (Zsucc z) = S (Zabs_nat z).
Hint Resolve Zlt_le_succ: zarith.
 
Theorem Zlt_next :
 forall n m : Z, (n < m)%Z -> m = Zsucc n \/ (Zsucc n < m)%Z.
 
Theorem Zle_next :
 forall n m : Z, (n <= m)%Z -> m = n \/ (Zsucc n <= m)%Z.
 
Theorem Zlt_Zopp_Inv : forall p q : Z, (- p < - q)%Z -> (q < p)%Z.
 
Theorem Zle_Zopp_Inv : forall p q : Z, (- p <= - q)%Z -> (q <= p)%Z.
 
Theorem absolu_Zs_neg :
 forall z : Z, (z < 0)%Z -> S (Zabs_nat (Zsucc z)) = Zabs_nat z.
 
Theorem Zlt_absolu :
 forall (x : Z) (n : nat), Zabs_nat x < n -> (x < Z_of_nat n)%Z.
 
Theorem inj_pred :
 forall n : nat, n <> 0 -> Z_of_nat (pred n) = Zpred (Z_of_nat n).
 
Theorem Zle_abs : forall p : Z, (p <= Z_of_nat (Zabs_nat p))%Z.
Hint Resolve Zle_abs: zarith.
 
Theorem ZleAbs :
 forall (z : Z) (n : nat),
 (- Z_of_nat n <= z)%Z -> (z <= Z_of_nat n)%Z -> Zabs_nat z <= n.
 
Theorem lt_Zlt_inv : forall n m : nat, (Z_of_nat n < Z_of_nat m)%Z -> n < m.
 
Theorem NconvertO : forall p : positive, nat_of_P p <> 0.
Hint Resolve NconvertO: zarith.
 
Theorem absolu_lt_nz : forall z : Z, z <> 0%Z -> 0 < Zabs_nat z.
 
Theorem Rlt2 : (0 < INR 2)%R.
Hint Resolve Rlt2: real.
 
Theorem RlIt2 : (0 < / INR 2)%R.
Hint Resolve RlIt2: real.
 
Theorem Rledouble : forall r : R, (0 <= r)%R -> (r <= INR 2 * r)%R.
 
Theorem Rltdouble : forall r : R, (0 < r)%R -> (r < INR 2 * r)%R.
 
Theorem Rlt_RinvDouble : forall r : R, (0 < r)%R -> (/ INR 2 * r < r)%R.
Hint Resolve Rledouble: real.
 
Theorem Rle_Rinv : forall x y : R, (0 < x)%R -> (x <= y)%R -> (/ y <= / x)%R.
 
Theorem Int_part_INR : forall n : nat, Int_part (INR n) = Z_of_nat n.
 
Theorem Int_part_IZR : forall z : Z, Int_part (IZR z) = z.
 
Theorem Zlt_Rlt : forall z1 z2 : Z, (IZR z1 < IZR z2)%R -> (z1 < z2)%Z.
 
Theorem Zle_Rle :
 forall z1 z2 : Z, (IZR z1 <= IZR z2)%R -> (z1 <= z2)%Z.
 
Theorem IZR_inv : forall z1 z2 : Z, IZR z1 = IZR z2 :>R -> z1 = z2.
 
Theorem Zabs_eq_opp : forall x, (x <= 0)%Z -> Zabs x = (- x)%Z.
 
Theorem Zabs_Zs : forall z : Z, (Zabs (Zsucc z) <= Zsucc (Zabs z))%Z.
Hint Resolve Zabs_Zs: zarith.
 
Theorem Zle_Zpred : forall x y : Z, (x < y)%Z -> (x <= Zpred y)%Z.
Hint Resolve Zle_Zpred: zarith.
 
Theorem Zabs_Zopp : forall z : Z, Zabs (- z) = Zabs z.
 
Theorem Zle_Zabs : forall z : Z, (z <= Zabs z)%Z.
Hint Resolve Zle_Zabs: zarith.
 
Theorem Zlt_mult_simpl_l :
 forall a b c : Z, (0 < c)%Z -> (c * a < c * b)%Z -> (a < b)%Z.

Fixpoint pos_eq_bool (a b : positive) {struct b} : bool :=
  match a, b with
  | xH, xH => true
  | xI a', xI b' => pos_eq_bool a' b'
  | xO a', xO b' => pos_eq_bool a' b'
  | _, _ => false
  end.
 
Theorem pos_eq_bool_correct :
 forall p q : positive,
 match pos_eq_bool p q with
 | true => p = q
 | false => p <> q
 end.
 
Theorem Z_O_1 : (0 < 1)%Z.
Hint Resolve Z_O_1: zarith.
 
Definition Z_eq_bool a b :=
  match a, b with
  | Z0, Z0 => true
  | Zpos a', Zpos b' => pos_eq_bool a' b'
  | Zneg a', Zneg b' => pos_eq_bool a' b'
  | _, _ => false
  end.
 
Theorem Z_eq_bool_correct :
 forall p q : Z,
 match Z_eq_bool p q with
 | true => p = q
 | false => p <> q
 end.
 
Theorem Zlt_mult_ZERO :
 forall x y : Z, (0 < x)%Z -> (0 < y)%Z -> (0 < x * y)%Z.
Hint Resolve Zlt_mult_ZERO: zarith.
 
Theorem Zlt_Zminus_ZERO :
 forall z1 z2 : Z, (z2 < z1)%Z -> (0 < z1 - z2)%Z.
 
Theorem Zle_Zminus_ZERO :
 forall z1 z2 : Z, (z2 <= z1)%Z -> (0 <= z1 - z2)%Z.
Hint Resolve Zle_Zminus_ZERO Zlt_Zminus_ZERO: zarith.
 
Theorem Zle_Zpred_Zpred :
 forall z1 z2 : Z, (z1 <= z2)%Z -> (Zpred z1 <= Zpred z2)%Z.
Hint Resolve Zle_Zpred_Zpred: zarith.
 
Theorem Zle_ZERO_Zabs : forall z : Z, (0 <= Zabs z)%Z.
Hint Resolve Zle_ZERO_Zabs: zarith.
 
Theorem Zlt_Zabs_inv1 :
 forall z1 z2 : Z, (Zabs z1 < z2)%Z -> (- z2 < z1)%Z.
 
Theorem Zlt_Zabs_inv2 :
 forall z1 z2 : Z, (Zabs z1 < Zabs z2)%Z -> (z1 < Zabs z2)%Z.
 
Theorem Zle_Zabs_inv1 :
 forall z1 z2 : Z, (Zabs z1 <= z2)%Z -> (- z2 <= z1)%Z.
 
Theorem Zle_Zabs_inv2 :
 forall z1 z2 : Z, (Zabs z1 <= z2)%Z -> (z1 <= z2)%Z.
 
Theorem Zlt_Zabs_Zpred :
 forall z1 z2 : Z,
 (Zabs z1 < z2)%Z -> z1 <> Zpred z2 -> (Zabs (Zsucc z1) < z2)%Z.
 
Theorem Zle_n_Zpred :
 forall z1 z2 : Z, (Zpred z1 <= Zpred z2)%Z -> (z1 <= z2)%Z.
 
Theorem Zpred_Zopp_Zs : forall z : Z, Zpred (- z) = (- Zsucc z)%Z.
 
Theorem Zlt_1_O : forall z : Z, (1 <= z)%Z -> (0 < z)%Z.
Hint Resolve Zlt_succ Zsucc_lt_compat Zle_lt_succ: zarith.
 
Theorem Zlt_not_eq : forall p q : Z, (p < q)%Z -> p <> q.
 
Theorem Zlt_not_eq_rev : forall p q : Z, (q < p)%Z -> p <> q.
Hint Resolve Zlt_not_eq Zlt_not_eq_rev: zarith.
 
Theorem Zle_Zpred_Zlt :
 forall z1 z2 : Z, (z1 <= z2)%Z -> (Zpred z1 < z2)%Z.
Hint Resolve Zle_Zpred_Zlt: zarith.
 
Theorem Zle_Zpred_inv :
 forall z1 z2 : Z, (z1 <= Zpred z2)%Z -> (z1 < z2)%Z.
 
Theorem Zabs_intro :
 forall (P : Z -> Prop) (z : Z), P (- z)%Z -> P z -> P (Zabs z).
 
Theorem Zpred_Zle_Zabs_intro :
 forall z1 z2 : Z,
 (- Zpred z2 <= z1)%Z -> (z1 <= Zpred z2)%Z -> (Zabs z1 < z2)%Z.
 
Theorem Zlt_ZERO_Zle_ONE : forall z : Z, (0 < z)%Z -> (1 <= z)%Z.
Hint Resolve Zlt_ZERO_Zle_ONE: zarith.
 
Theorem ptonat_def1 : forall p q, 1 < Pmult_nat p (S (S q)).
Hint Resolve ptonat_def1: arith.
 
Theorem lt_S_le : forall p q, p < q -> S p <= q.
Hint Resolve lt_S_le: arith.
 
Theorem Zlt_Zabs_intro :
 forall z1 z2 : Z, (- z2 < z1)%Z -> (z1 < z2)%Z -> (Zabs z1 < z2)%Z. *)
Section Pdigit.

Variable n : Z.

Hypothesis nMoreThan1 : (1 < n)%Z.
 
Let nMoreThanOne := Zlt_1_O _ (Zlt_le_weak _ _ nMoreThan1).
Hint Resolve nMoreThanOne: zarith.
 
Theorem Zpower_nat_less : forall q : nat, (0 < Zpower_nat n q)%Z.
intros q; elim q; simpl in |- *;
auto with zarith.
Qed.
Hint Resolve Zpower_nat_less: zarith.
 
Theorem Zpower_nat_monotone_S :
 forall p : nat, (Zpower_nat n p < Zpower_nat n (S p))%Z.
intros p; rewrite <- (Zmult_1_l (Zpower_nat n p)); replace (S p) with (1 + p);
 [ rewrite Zpower_nat_is_exp | auto with zarith ].
rewrite Zpower_nat_1; auto with zarith.
apply Zmult_gt_0_lt_compat_r; auto with zarith.
apply Zlt_gt; auto with zarith.
Qed.
 
Theorem Zpower_nat_monotone_lt :
 forall p q : nat, p < q -> (Zpower_nat n p < Zpower_nat n q)%Z.
intros p q H'; elim H'; simpl in |- *; auto.
apply Zpower_nat_monotone_S.
intros m H H0; apply Zlt_trans with (1 := H0).
apply Zpower_nat_monotone_S.
Qed.
Hint Resolve Zpower_nat_monotone_lt: zarith.
 
Theorem Zpower_nat_anti_monotone_lt :
 forall p q : nat, (Zpower_nat n p < Zpower_nat n q)%Z -> p < q.
intros p q H'.
case (le_or_lt q p); auto; (intros H'1; generalize H'; case H'1).
intros H'0; Contradict H'0; auto with zarith.
intros m H'0 H'2; Contradict H'2; auto with zarith.
Qed.
 
Theorem Zpower_nat_monotone_le :
 forall p q : nat, p <= q -> (Zpower_nat n p <= Zpower_nat n q)%Z.
intros p q H'; case (le_lt_or_eq _ _ H'); auto with zarith.
intros H1; rewrite H1; auto with zarith.
Qed.
 
Theorem Zpower_nat_anti_monotone_le :
 forall p q : nat, (Zpower_nat n p <= Zpower_nat n q)%Z -> p <= q.
intros p q H'; case (le_or_lt p q); intros H'0; auto with arith.
Contradict H'; auto with zarith.
Qed.
 
Theorem Zpower_nat_anti_eq :
 forall p q : nat, Zpower_nat n p = Zpower_nat n q -> p = q.
intros p q H'; apply le_antisym; apply Zpower_nat_anti_monotone_le;
 rewrite H'; auto with zarith.
Qed.

Fixpoint digitAux (v r : Z) (q : positive) {struct q} : nat :=
  match q with
  | xH => 0
  | xI q' =>
      match (n * r)%Z with
      | r' =>
          match (r ?= v)%Z with
          | Datatypes.Gt => 0
          | _ => S (digitAux v r' q')
          end
      end
  | xO q' =>
      match (n * r)%Z with
      | r' =>
          match (r ?= v)%Z with
          | Datatypes.Gt => 0
          | _ => S (digitAux v r' q')
          end
      end
  end.

Definition digit (q : Z) :=
  match q with
  | Z0 => 0
  | Zpos q' => digitAux (Zabs q) 1 (xO q')
  | Zneg q' => digitAux (Zabs q) 1 (xO q')
  end.
Hint Unfold digit.
 
Theorem digitAux1 :
 forall p r, (Zpower_nat n (S p) * r)%Z = (Zpower_nat n p * (n * r))%Z.
intros p r; replace (S p) with (1 + p);
 [ rewrite Zpower_nat_is_exp | auto with arith ].
rewrite Zpower_nat_1; ring.
Qed.
 
Theorem Zcompare_correct :
 forall p q : Z,
 match (p ?= q)%Z with
 | Datatypes.Gt => (q < p)%Z
 | Datatypes.Lt => (p < q)%Z
 | Datatypes.Eq => p = q
 end.
intros p q; unfold Zlt in |- *; generalize (Zcompare_EGAL p q);
 (CaseEq (p ?= q)%Z; simpl in |- *; auto).
intros H H0; case (Zcompare_Gt_Lt_antisym p q); auto.
Qed.
 
Theorem digitAuxLess :
 forall (v r : Z) (q : positive),
 match digitAux v r q with
 | S r' => (Zpower_nat n r' * r <= v)%Z
 | O => True
 end.
intros v r q; generalize r; elim q; clear r q; simpl in |- *; auto.
intros q' Rec r; generalize (Zcompare_correct r v); case (r ?= v)%Z; auto.
intros H1; generalize (Rec (n * r)%Z); case (digitAux v (n * r) q').
intros; rewrite H1; rewrite Zpower_nat_O; auto with zarith.
intros r'; rewrite digitAux1; auto.
intros H1; generalize (Rec (n * r)%Z); case (digitAux v (n * r) q').
intros; rewrite Zpower_nat_O; auto with zarith.
apply Zle_trans with (m := r); auto with zarith.
intros r'; rewrite digitAux1; auto.
intros q' Rec r; generalize (Zcompare_correct r v); case (r ?= v)%Z; auto.
intros H1; generalize (Rec (n * r)%Z); case (digitAux v (n * r) q').
intros; rewrite H1; rewrite Zpower_nat_O; auto with zarith.
intros r'; rewrite digitAux1; auto.
intros H1; generalize (Rec (n * r)%Z); case (digitAux v (n * r) q').
intros; rewrite Zpower_nat_O; auto with zarith.
apply Zle_trans with (m := r); auto with zarith.
intros r'; rewrite digitAux1; auto.
Qed.

Theorem digitLess :
 forall q : Z, q <> 0%Z -> (Zpower_nat n (pred (digit q)) <= Zabs q)%Z.
intros q; case q.
intros H; Contradict H; auto with zarith.
intros p H; unfold digit in |- *;
 generalize (digitAuxLess (Zabs (Zpos p)) 1 (xO p));
 case (digitAux (Zabs (Zpos p)) 1 (xO p)); simpl in |- *; 
 auto with zarith.
intros p H; unfold digit in |- *;
 generalize (digitAuxLess (Zabs (Zneg p)) 1 (xO p));
 case (digitAux (Zabs (Zneg p)) 1 (xO p)); simpl in |- *; 
 auto with zarith.
Qed.
Hint Resolve digitLess: zarith.
Hint Resolve Zmult_gt_0_lt_compat_r Zmult_gt_0_lt_compat_l: zarith.
 
Fixpoint pos_length (p : positive) : nat :=
  match p with
  | xH => 0
  | xO p' => S (pos_length p')
  | xI p' => S (pos_length p')
  end.
 
Theorem digitAuxMore :
 forall (v r : Z) (q : positive),
 (0 < r)%Z ->
 (v < Zpower_nat n (pos_length q) * r)%Z ->
 (v < Zpower_nat n (digitAux v r q) * r)%Z.
intros v r q; generalize r; elim q; clear r q; simpl in |- *.
intros p Rec r Hr; generalize (Zcompare_correct r v); case (r ?= v)%Z; auto.
intros H1 H2; rewrite <- H1.
apply Zle_lt_trans with (Zpower_nat n 0 * r)%Z; auto with zarith arith.
rewrite Zpower_nat_O; rewrite Zmult_1_l; auto with zarith.
intros H1 H2; rewrite digitAux1.
apply Rec.
apply Zlt_mult_ZERO; auto with zarith.
rewrite <- digitAux1; auto.
rewrite Zpower_nat_O; rewrite Zmult_1_l; auto with zarith.
intros p Rec r Hr; generalize (Zcompare_correct r v); case (r ?= v)%Z; auto.
intros H1 H2; rewrite <- H1.
apply Zle_lt_trans with (Zpower_nat n 0 * r)%Z; auto with zarith arith.
rewrite Zpower_nat_O; rewrite Zmult_1_l; auto with zarith.
intros H1 H2; rewrite digitAux1.
apply Rec.
apply Zlt_mult_ZERO; auto with zarith.
rewrite <- digitAux1; auto.
rewrite Zpower_nat_O; rewrite Zmult_1_l; auto with zarith.
auto.
Qed.
 
Theorem pos_length_pow :
 forall p : positive, (Zpos p < Zpower_nat n (S (pos_length p)))%Z.
intros p; elim p; simpl in |- *; auto.
intros p0 H; rewrite Zpos_xI.
apply Zlt_le_trans with (2 * (n * Zpower_nat n (pos_length p0)))%Z;
auto with zarith.
intros p0 H; rewrite Zpos_xO.
apply Zlt_le_trans with (2 * (n * Zpower_nat n (pos_length p0)))%Z;
auto with zarith.
auto with zarith.
Qed.

Theorem digitMore : forall q : Z, (Zabs q < Zpower_nat n (digit q))%Z.
intros q; case q.
easy.
intros q'; rewrite <- (Zmult_1_r (Zpower_nat n (digit (Zpos q')))).
unfold digit in |- *; apply digitAuxMore; auto with zarith.
rewrite Zmult_1_r.
simpl in |- *; apply pos_length_pow.
intros q'; rewrite <- (Zmult_1_r (Zpower_nat n (digit (Zneg q')))).
unfold digit in |- *; apply digitAuxMore; auto with zarith.
rewrite Zmult_1_r.
simpl in |- *; apply pos_length_pow.
Qed.
Hint Resolve digitMore: zarith.

Theorem digitInv :
 forall (q : Z) (r : nat),
 (Zpower_nat n (pred r) <= Zabs q)%Z ->
 (Zabs q < Zpower_nat n r)%Z -> digit q = r.
intros q r H' H'0; case (le_or_lt (digit q) r).
intros H'1; case (le_lt_or_eq _ _ H'1); auto; intros H'2.
absurd (Zabs q < Zpower_nat n (digit q))%Z; auto with zarith.
apply Zle_not_lt; auto with zarith.
apply Zle_trans with (m := Zpower_nat n (pred r)); auto with zarith.
apply Zpower_nat_monotone_le.
generalize H'2; case r; auto with arith.
intros H'1.
absurd (Zpower_nat n (pred (digit q)) <= Zabs q)%Z; auto with zarith.
apply Zlt_not_le; auto with zarith.
apply Zlt_le_trans with (m := Zpower_nat n r); auto.
apply Zpower_nat_monotone_le.
generalize H'1; case (digit q); auto with arith.
apply digitLess; auto with zarith.
generalize H'1; case q; unfold digit in |- *; intros tmp; intros; red in |- *;
 intros; try discriminate; Contradict tmp; auto with arith.
Qed.
 
Theorem digitO : digit 0 = 0.
unfold digit in |- *; simpl in |- *; auto with arith.
Qed.
 
Theorem digit1 : digit 1 = 1.
unfold digit in |- *; simpl in |- *; auto.
Qed.

Theorem digit_monotone :
 forall p q : Z, (Zabs p <= Zabs q)%Z -> digit p <= digit q.
intros p q H; case (le_or_lt (digit p) (digit q)); auto; intros H1;
 Contradict H.
apply Zlt_not_le.
cut (p <> 0%Z); [ intros H2 | idtac ].
apply Zlt_le_trans with (2 := digitLess p H2).
cut (digit q <= pred (digit p)); [ intros H3 | idtac ].
apply Zlt_le_trans with (2 := Zpower_nat_monotone_le _ _ H3);
 auto with zarith.
generalize H1; case (digit p); simpl in |- *; auto with arith.
generalize H1; case p; simpl in |- *; intros tmp; intros; red in |- *; intros;
 try discriminate; Contradict tmp; auto with arith.
Qed.
Hint Resolve digit_monotone: arith.

Theorem digitNotZero : forall q : Z, q <> 0%Z -> 0 < digit q.
intros q H'.
apply lt_le_trans with (m := digit 1); auto with zarith.
apply digit_monotone.
generalize H'; case q; simpl in |- *; auto with zarith; intros q'; case q';
 simpl in |- *; auto with zarith arith; intros; red in |- *; 
 simpl in |- *; red in |- *; intros; discriminate.
Qed.
Hint Resolve Zlt_gt: zarith.
 
Theorem digitAdd :
 forall (q : Z) (r : nat),
 q <> 0%Z -> digit (q * Zpower_nat n r) = digit q + r.
intros q r H0.
apply digitInv.
replace (pred (digit q + r)) with (pred (digit q) + r).
rewrite Zpower_nat_is_exp; rewrite Zabs_Zmult;
 rewrite (fun x => Zabs_eq (Zpower_nat n x)); auto with zarith arith.
generalize (digitNotZero _ H0); case (digit q); auto with arith.
intros H'; Contradict H'; auto with arith.
rewrite Zpower_nat_is_exp; rewrite Zabs_Zmult;
 rewrite (fun x => Zabs_eq (Zpower_nat n x)); auto with zarith arith.
Qed.
 
Theorem digit_minus1 : forall p : nat, digit (Zpower_nat n p - 1) = p.
intros p; case p; auto.
intros n0; apply digitInv; auto.
rewrite Zabs_eq.
cut (Zpower_nat n (pred (S n0)) < Zpower_nat n (S n0))%Z; auto with zarith.
cut (0 < Zpower_nat n (S n0))%Z; auto with zarith.
rewrite Zabs_eq; auto with zarith.
Qed.
 
Theorem digit_bound :
 forall (x y z : Z) (n : nat),
 (Zabs x <= Zabs y)%Z ->
 (Zabs y <= Zabs z)%Z -> digit x = n -> digit z = n -> digit y = n.
intros x y z n0 H' H'0 H'1 H'2; apply le_antisym.
rewrite <- H'2; auto with arith.
rewrite <- H'1; auto with arith.
Qed.
 
Theorem digit_abs : forall p : Z, digit (Zabs p) = digit p.
intros p; case p; simpl in |- *; auto.
Qed.

Theorem digit_anti_monotone_lt :
 (1 < n)%Z -> forall p q : Z, digit p < digit q -> (Zabs p < Zabs q)%Z.
intros H' p q H'0.
case (Zle_or_lt (Zabs q) (Zabs p)); auto; intros H'1.
Contradict H'0.
case (Zle_lt_or_eq _ _ H'1); intros H'2.
apply le_not_lt; auto with arith.
rewrite <- (digit_abs p); rewrite <- (digit_abs q); rewrite H'2;
 auto with arith.
Qed.
End Pdigit.
Hint Resolve Zpower_nat_less: zarith.
Hint Resolve Zpower_nat_monotone_lt: zarith.
Hint Resolve Zpower_nat_monotone_le: zarith.
Hint Unfold digit.
Hint Resolve digitLess: zarith.
Hint Resolve digitMore: zarith.
Hint Resolve digit_monotone: arith.