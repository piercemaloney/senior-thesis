
Require Export ArithCompl.
(* ArithCompl:
Require Export Wf_nat.
Require Export ZArith.
Require Export Znumtheory.
Require Export Reals.
Open Scope Z_scope.

Unset Standard Proposition Elimination Names.

Definition is_sqr (n : Z) : Prop :=
  0 <= n /\ exists i : Z, i * i = n /\ 0 <= i.

Lemma is_sqr_sqr : forall n: Z, is_sqr (n * n).

Lemma is_sqr_mult : forall p q : Z, is_sqr p -> is_sqr q -> is_sqr (p * q).

Lemma sqr_0 : forall z : Z, z * z = 0 -> z = 0.

Lemma sqr_compat : forall a b : Z, a * a = b * b -> a = b \/ a = -b.

Lemma sqr_le : forall a : Z, a <= a * a.

Lemma sqr_spos : forall z : Z, z <> 0 -> z * z > 0.

Lemma sqr_poss : forall z : Z, 0 < z * z -> z <> 0.

Lemma sqr_lt : forall a : Z, a <> 0 -> a <> 1 -> a < a * a.

Lemma sqr_sum : forall a b : Z, b <> 0 -> a * a + b * b <> 0.

Lemma sqr_sum2 : forall a b : Z, 0 <= a * a + b * b.

Lemma sqr_sum3 : forall a b : Z, b > 0 -> a * a + b * b > 0.

Lemma sqr_sum4: forall a b : Z, a * a + b * b = 0 -> a = 0 /\ b = 0.

Lemma sqr_sub1 : forall a b : Z, 0 <= b -> b <= a -> 0 <= a * a - b * b.

Lemma sqr_sub2 : forall a b : Z, 0 <= b -> b < a -> 0 < a * a - b * b.

Lemma sqr_sub3 : forall a b : Z, 0 < a -> 0 < b -> 0 < a * a - b * b -> b < a.

Lemma sqr_2 : forall a : Z, 0 <= 2 * (a * a).

Lemma sqr_gt : forall a b : Z, a >= 0 -> a < b -> a * a < b * b.

Lemma sqr_ge : forall a b : Z, a >= 0 -> a <= b -> a * a <= b * b.

Lemma Zle_square_simpl : forall n m:Z,
  0 <= n -> 0 <= m -> m * m <= n * n -> m <= n.

Lemma neq_1 : forall u v m n : Z,
  m <> 0 -> n <> 0 -> u * u = m * m + n * n -> v * v = n * n - m * m ->
  u <> 1 /\ v <> 1.

Lemma Zmult_eq_reg_l : forall z z1 z2, z * z1 = z * z2 -> z <> 0 -> z1 = z2.

Lemma Zmult_neq_0 : forall a b : Z, a * b <> 0 -> a <> 0 /\ b <> 0.

Definition both_odd (x y : Z) := Zodd x /\ Zodd y.

Definition distinct_parity (a b : Z) :=
   (Zeven a) /\ (Zodd b) \/ (Zodd a) /\ (Zeven b).

Lemma ndistp_eq : forall a : Z, ~ distinct_parity a a.

Lemma sqr_sum5 : forall a b: Z,
  a <> 0 -> b <> 0 -> distinct_parity a b -> a + b < a * a + b * b.

Lemma Zeven_def1 : forall z : Z, (Zeven z) -> exists k : Z, z = 2 * k.

Lemma Zeven_def2 : forall z : Z, (exists k : Z, z = 2 * k) -> (Zeven z).

Lemma Zodd_def1 : forall z : Z, (Zodd z) -> exists k : Z, z = 2 * k + 1.

Lemma Zodd_def2 : forall z : Z, (exists k : Z, z = 2 * k + 1) -> (Zodd z).

Lemma Zodd_0: forall n : Z, Zodd n -> n <> 0.

Lemma Zodd_opp1 : forall a : Z, Zodd (-a) -> Zodd a.

Lemma Zodd_opp2 : forall a : Z, Zodd a -> Zodd (-a).

Lemma Zodd_sum1 : forall a b : Z, Zodd a -> Zodd b -> Zeven (a + b).

Lemma Zodd_sum2 : forall a b : Z, Zodd a -> Zodd b -> Zeven (a - b).

Lemma Zodd_sum3 : forall a b : Z, Zodd (a + 2 * b) -> Zodd a.

Lemma Zodd_mult : forall u v : Z,
  Zodd u -> Zodd v -> 
  (exists s : Z, 
    (exists w : Z, (u - v = 4 * s /\ u + v = 2 * w) \/
                   (u - v = 2 * w /\ u + v = 4 * s))).

Lemma Zeven_sqr1 : forall z : Z, Zeven z -> Zeven (z * z).

Lemma Zeven_sqr2 : forall n, Zeven (n * n) -> Zeven n.

Lemma Zodd_sqr1 : forall z : Z, Zodd z -> Zodd (z * z).

Lemma Zodd_sqr2 : forall n, Zodd (n * n) -> Zodd n.

Lemma distp_neq : forall p q : Z, distinct_parity p q -> p <> q.

Lemma distp_sqr1 : forall p q : Z,
  (distinct_parity p q) -> (distinct_parity (p * p) (q * q)).

Lemma distp_sqr2 : forall p q : Z,
  (distinct_parity (p * p) (q * q)) -> (distinct_parity p q).

Lemma distp_odd : forall p q : Z,
  (distinct_parity p q) -> both_odd (p + q) (q - p).

Lemma not_divide1 : forall a b : Z,
  a <> 1 -> a <> -1 -> b <> 0 -> ~(a * b | b).

Lemma not_divide2 : forall a b : Z, 0 < a -> 0 < b -> b < a -> ~(a | b).

Lemma rel_prime_1: forall a : Z, rel_prime 1 a.

Lemma prime_2 : prime 2.

Lemma rel_prime_sym : forall x y : Z, rel_prime x y -> rel_prime y x.

Lemma rel_prime_dec : forall x y : Z, {rel_prime x y} + {~ rel_prime x y}.

Lemma not_rel_prime1 : forall x y : Z,
  ~ rel_prime x y -> exists d : Z, Zis_gcd x y d /\ d <> 1 /\ d <> -1.

Lemma not_rel_prime2 : forall x y d : Z,
  (d | x) -> (d | y) -> d <> 1 -> d <> -1 -> ~ rel_prime x y.

Lemma gcd_rel_prime : forall x y d : Z,
  Zis_gcd x y d -> exists a : Z, exists b : Z,
    x = d * a /\ y = d * b /\ rel_prime a b.

Lemma relp_mult2 : forall a b : Z, rel_prime (a * b) a -> a = 1 \/ a = -1.

Lemma relp_mult3 : forall a b c : Z, rel_prime (a * b) c -> rel_prime a c.

Lemma gcd2_rel_prime : forall a b s w : Z,
  (Zis_gcd a b 2) -> a = 4 * s -> b = 2 * w -> rel_prime s w.

Lemma relp_neq : forall m n : Z, m <> 1 -> m <> -1 -> rel_prime m n -> m <> n.

Lemma prop2 : forall m n : Z, rel_prime m n -> rel_prime (m * m) (n * n).

Lemma is_sqr_compat : forall k a : Z,
  k <> 0 -> is_sqr ((k * k) * a) -> is_sqr a.

Lemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).

Lemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).

Lemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).

Lemma divide_0 : forall z : Z, (0 | z) -> z = 0.

Lemma divide_2 : forall z : Z, 0 <= z -> z <> 0 -> z <> 1 -> (z | 2) -> z = 2.

Lemma divide_2b : forall z : Z,
  z <> 1 -> z <> -1 -> (z | 2) -> z = 2 \/ z = -2.

Lemma divide_4 : forall a b : Z, (a * a * a * a | b * b * b * b) -> (a | b).

Lemma divide_sqr : forall a b : Z, (a | b) -> (a * a | b * b).

Lemma gcd2_relp_odd : forall u v : Z,
  Zodd u -> Zodd v -> rel_prime u v -> (Zis_gcd (u - v) (u + v) 2).

Lemma rel_prime_opp : forall x y : Z, rel_prime x y -> rel_prime (-x) (-y).

Lemma rel_prime_oppr : forall x y : Z, rel_prime x y -> rel_prime x (-y).

Lemma rel_prime_2 : forall z : Z, Zodd z -> rel_prime 2 z.

Lemma relp_mult1 : forall a b c d k: Z, 0 <= a -> 0 <= b -> 0 < c -> 0 <= d ->
  a = k * c -> b = k * d -> rel_prime a b -> k = 1.

Lemma relp_parity :
  forall x y : Z, (rel_prime x y) -> (distinct_parity x y) \/ (both_odd x y).

Lemma relp_sum :
  forall m n : Z, (rel_prime (m + n) (m - n)) -> (rel_prime m n).

Lemma prop1 : forall m n : Z,
  rel_prime m n -> distinct_parity m n -> rel_prime (m + n) (n - m).

Lemma prop2b : forall m n : Z, rel_prime m n -> rel_prime m (m * m + n * n).

Lemma prop2c : forall m n : Z, rel_prime m n -> rel_prime m (m * m - n * n).

Lemma prop3 : forall m n : Z, rel_prime (m * m) (n * n) -> rel_prime m n.

Definition R_prime (x y : Z) := 1 < x /\ 1 < y /\ x < y.

Definition f_Z (x : Z) := Zabs_nat x.

Lemma R_prime_wf : well_founded R_prime.

Lemma ind_prime : forall P : Z -> Prop,
  (forall x : Z, (forall y : Z, (R_prime y x -> P y)) -> P x) ->
  forall x : Z, P x.

Lemma prime_dec_gen : forall a b : Z, 1 < b -> b < a ->
  (forall c : Z, b < c < a -> rel_prime c a) -> prime a \/ ~ prime a.

Lemma prime_dec : forall a : Z, prime a \/ ~ prime a.

Lemma not_prime_gen : forall a b : Z, 1 < a -> 1 < b -> b < a -> ~ prime a ->
  (forall c : Z, b < c < a -> rel_prime c a) ->
  exists q : Z, exists b : Z, a = q * b /\ 1 < q /\ 1 < b.

Lemma not_prime : forall a : Z, 1 < a -> ~ prime a ->
  exists q : Z, exists b : Z, a = q * b /\ 1 < q /\ 1 < b.

Definition R_fact (x y : Z) :=
  1 < x /\ 1 < y /\ exists q : Z, y = q * x /\ 1 < q.

Lemma R_fact_wf : well_founded R_fact.

Lemma ind_fact : forall P : Z -> Prop,
  (forall x : Z, (forall y : Z, (R_fact y x -> P y)) -> P x) ->
  forall x : Z, P x.

Lemma Zfact : forall a : Z, 1 < a -> exists b : Z, (b | a) /\ prime b.

Definition R_p4 (x y : Z) :=
  0 <= x /\ 1 < y /\ exists d : Z, y = d * d * x /\ 1 < d.

Lemma R_p4_wf : well_founded R_p4.

Lemma ind_p4 : forall P : Z -> Prop,
  (forall x : Z, (forall y : Z, (R_p4 y x -> P y)) -> P x) ->
  forall x : Z, P x.

Lemma sqr_prime1 :
  forall a : Z, is_sqr a -> forall b : Z, (b | a) -> prime b -> (b * b | a).

Lemma sqr_prime2 : forall a b c : Z,
  (a | b) -> (a * a | b * c) -> prime a -> (a * a | b) \/ (a | c).

Lemma prop4 : forall p q : Z,
  0 <= p -> 0 <= q -> rel_prime p q -> is_sqr (p * q) -> is_sqr p /\ is_sqr q.

Lemma prop4b : forall p q : Z, 0 <= p -> 0 <= q -> p <= q -> rel_prime p q ->
  is_sqr (p * (q * (q * q - p * p))) ->
  is_sqr p /\ is_sqr q /\ is_sqr (q * q - p * p).

Lemma relp_pq1 : forall p q : Z, p >= 0 -> p <= q -> (rel_prime p q) ->
  (distinct_parity p q) -> (rel_prime (q * q - p * p) (p * p + q * q)).

Lemma relp_pq2 : forall p q : Z, (rel_prime p q) -> (distinct_parity p q) ->
  (rel_prime (2 * p * q) (p * p + q * q)).

Lemma not_IZR_0 : forall a : Z, (IZR a <> 0)%R -> a <> 0.

Lemma sqr_inv : forall a b : Z, b <> 0 ->
  (1 + IZR a * / IZR b * (IZR a * / IZR b) <> 0)%R.

Lemma Rdiv_ge_0 : forall a b : R, (a >= 0 -> b > 0 -> a / b >= 0)%R.

Lemma Rcross_prod : forall a b c d : R,
  (b <> 0 -> d <> 0 -> a / b = c / d -> a * d = b * c)%R.

Definition frac (a b : Z) := ((IZR a) / (IZR b))%R.
Definition is_rat (r : R) :=
  exists pq : Z * Z, let (p,q) := pq in ~(q = 0) /\ r = (frac p q).
Definition is_ratp (c : R * R) := let (x,y) := c in (is_rat x) /\ (is_rat y).

Lemma frac_eq : forall a b c d : Z,
  b <> 0 -> c <> 0 -> (frac a (b * c)) = (frac d c) -> a = b * d.

Lemma frac_rat : forall a b : Z,
  b <> 0 -> (frac a b >= 0)%R -> (frac a b <= 1)%R ->
    a >= 0 /\ b > 0 /\ a <= b \/ a <= 0 /\ b < 0 /\ b <= a.

Lemma frac_simp : forall a b c : Z,
  b <> 0 -> c <> 0 -> frac (c * a) (c * b) = frac a b.

Lemma frac_opp : forall a b : Z, b <> 0 -> frac (-a) (-b) = frac a b.

Lemma relp_rat : forall r : R, (is_rat r) -> (r >= 0)%R -> (r <= 1)%R ->
  exists pq : Z * Z,
  let (p,q) := pq in
  (p >= 0) /\ (q > 0) /\ (p <= q) /\ (rel_prime p q) /\ r = (frac p q).

Hint Resolve rel_prime_sym : zarith.

Hint Immediate sqr_0 sqr_pos sqr_spos sqr_sum sqr_sum2 sqr_sum3 sqr_sum4
  sqr_sum5 sqr_sub1 sqr_sub2 sqr_sub3 sqr_ge : zarith.

Hint Immediate sqr_inv Rdiv_ge_0 : reals. *)

Ltac elim_hyps :=
  repeat
    match goal with
    | id : (exists x : _, _) |- _ => elim id; clear id; intros
    | id : _ /\ _ |- _ => elim id; clear id; intros
    | id : _ \/ _ |- _ => elim id; clear id; intros
    end.

Ltac elim_hyps_no_or :=
  repeat
    match goal with
    | id : (exists x : _, _) |- _ => elim id; clear id; intros
    | id : _ /\ _ |- _ => elim id; clear id; intros
    end.

Ltac fold_Zminus :=
  repeat
    match goal with
    | |- context[?x1 + (- ?x2)] => fold (x1 - x2)
    end.

Ltac Zparity_hyps :=
  repeat
    match goal with
    | id : Zeven _ |- _ => generalize (Zeven_def1 _ id); clear id; intro
    | id : Zodd _ |- _ => generalize (Zodd_def1 _ id); clear id; intro
    end; elim_hyps.

Ltac atomic_IZR :=
  repeat rewrite plus_IZR || rewrite mult_IZR || rewrite Ropp_Ropp_IZR ||
    rewrite <- Z_R_minus.

Ltac head_IZR :=
  replace 1%R with (IZR 1);
    [ repeat rewrite <- plus_IZR || rewrite <- mult_IZR ||
      rewrite <- Ropp_Ropp_IZR || rewrite Z_R_minus
    | simpl; auto ].

Ltac neq_0 :=
  (repeat progress head_IZR; replace 0%R with (IZR 0);
      [ apply IZR_neq; fold_Zminus | auto ]).
