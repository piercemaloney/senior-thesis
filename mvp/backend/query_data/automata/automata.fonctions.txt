
Require Import Ensf.
(* Ensf:
Require Export Ensf_types.

Require Export Ensf_dans.

Require Export Ensf_union.

Require Export Ensf_couple.

Require Export Ensf_produit.

Require Export Ensf_inclus.

Require Export Ensf_inter.

Require Export Ensf_map.

Require Export Ensf_disj. *)
Require Import Words.
(* Words:
Require Import Ensf.

Parameter alph : Ensf.
Parameter epsilon : Elt.
  Axiom not_dans_epsilon_alph : ~ dans epsilon alph.

Inductive inmonoid (X : Ensf) : Word -> Prop :=
  | inmonoid_nil : inmonoid X nil
  | inmonoid_cons :
      forall (w : Word) (e : Elt),
      inmonoid X w -> dans e X -> inmonoid X (cons e w).
Hint Resolve inmonoid_nil.
Hint Resolve inmonoid_cons.

Fixpoint Inmonoid (X : Ensf) (w : Word) {struct w} : Prop :=
  match w with
  | nil => True
  | cons a w' => dans a X /\ Inmonoid X w'
  end.

Lemma i_I : forall (X : Ensf) (w : Word), inmonoid X w -> Inmonoid X w.
Hint Resolve i_I.

Lemma I_i : forall (X : Ensf) (w : Word), Inmonoid X w -> inmonoid X w.
Hint Resolve I_i.

Lemma inmonoid_cons_inv :
 forall (X : Ensf) (w : Word) (a : Elt),
 inmonoid X (cons a w) -> inmonoid X w.

Lemma inmonoid_cons_inv2 :
 forall (X : Ensf) (a : Elt) (w : Word), inmonoid X (cons a w) -> dans a X.

Lemma inmonoid_inclus :
 forall (E F : Ensf) (x : Word), inclus E F -> inmonoid E x -> inmonoid F x.

Fixpoint Append (w1 : Word) : Word -> Word :=
  fun w2 : Word =>
  match w1 with
  | nil => w2
  | cons a w3 => cons a (Append w3 w2)
  end.

Lemma Append_w_nil : forall w : Word, Append w nil = w :>Word.

Inductive append : Word -> Word -> Word -> Prop :=
  | append_nil : forall w : Word, append nil w w
  | append_cons :
      forall (w1 w2 w3 : Word) (a : Elt),
      append w1 w2 w3 -> append (cons a w1) w2 (cons a w3).

Lemma Append_inmonoid_g :
 forall (X : Ensf) (w1 w2 : Word), inmonoid X (Append w1 w2) -> inmonoid X w1.

Lemma Append_inmonoid_d :
 forall (X : Ensf) (w1 w2 : Word), inmonoid X (Append w1 w2) -> inmonoid X w2.

Lemma inmonoid_Append :
 forall (X : Ensf) (w1 w2 : Word),
 inmonoid X w1 -> inmonoid X w2 -> inmonoid X (Append w1 w2).

Definition wordset := Word -> Prop.

Definition eqwordset (l1 l2 : wordset) : Prop :=
  forall w : Word, (l1 w -> l2 w) /\ (l2 w -> l1 w).

Lemma eqwordset_refl : forall L : wordset, eqwordset L L.

Lemma eqwordset_sym :
 forall l1 l2 : wordset, eqwordset l1 l2 -> eqwordset l2 l1.

Lemma eqwordset_trans :
 forall l1 l2 l3 : wordset,
 eqwordset l1 l2 -> eqwordset l2 l3 -> eqwordset l1 l3.

Definition islanguage (X : Ensf) (L : wordset) : Prop :=
  forall w : Word, L w -> inmonoid X w.

Fixpoint Word_ext (f : Elt -> Elt) (w : Word) {struct w} : Word :=
  match w with
  | nil => nil
  | cons a w' => cons (f a) (Word_ext f w')
  end.

Lemma inmonoid_map :
 forall (f : Elt -> Elt) (a : Ensf) (w : Word),
 inmonoid a w -> inmonoid (map f a) (Word_ext f w).
Hint Resolve inmonoid_map.

Lemma cons_cons :
 forall (x1 x2 : Elt) (w1 w2 : Word),
 x1 = x2 :>Elt -> w1 = w2 :>Word -> cons x1 w1 = cons x2 w2 :>Word.
Hint Resolve cons_cons.

Definition fun_consaw_a (w : Word) : Elt :=
  match w return Elt with
  | nil =>
        zero
       
  | cons a w' => a
  end.

Definition fun_consaw_w (w : Word) : Word :=
  match w return Word with
  | nil =>
        nil
       
  | cons a w' => w'
  end.

Lemma cons_cons_inv :
 forall (x1 x2 : Elt) (w1 w2 : Word),
 cons x1 w1 = cons x2 w2 -> x1 = x2 /\ w1 = w2.

Hint Resolve cons_cons_inv.

Lemma cons_cons_inv1 :
 forall (x1 x2 : Elt) (w1 w2 : Word),
 cons x1 w1 = cons x2 w2 :>Word -> x1 = x2 :>Elt.

Lemma cons_cons_inv2 :
 forall (x1 x2 : Elt) (w1 w2 : Word), cons x1 w1 = cons x2 w2 -> w1 = w2.

Lemma nil_or_cons :
 forall w : Word,
 w = nil \/ (exists x : Elt, (exists w0 : Word, w = cons x w0)). *)
Require Import more_words.
(* more_words:
Require Import Ensf.
Require Import Words.

Hint Unfold eqwordset .

Definition l_inclus (l1 l2 : wordset) : Prop := forall w : Word, l1 w -> l2 w.

Hint Unfold l_inclus.

Lemma refl_l_inclus : forall l1 : wordset, l_inclus l1 l1.
Hint Resolve refl_l_inclus.

Lemma trans_l_inclus :
 forall l1 l2 l3 : wordset,
 l_inclus l1 l2 -> l_inclus l2 l3 -> l_inclus l1 l3.

Definition l_egal (l1 l2 : wordset) : Prop :=
  l_inclus l1 l2 /\ l_inclus l2 l1.

Hint Unfold l_egal.

Lemma equiv_l_egal_eqwordset :
 forall a b : wordset, l_egal a b <-> eqwordset a b.

Lemma refl_l_egal : forall l1 : wordset, l_egal l1 l1.
Hint Resolve refl_l_egal.

Section more_about_words.

Variable f : Elt -> Elt. 

Let wef := Word_ext f.

Lemma wef_append :
 forall u v : Word, wef (Append u v) = Append (wef u) (wef v).

Lemma wef_nil : forall a : Word, wef a = nil -> a = nil.

Lemma wef_cons :
 forall (a b : Word) (e : Elt),
 cons e a = wef b ->
 exists x : Elt,
   ex2 (fun w : Word => cons x w = b) (fun w : Word => f x = e /\ wef w = a).

End more_about_words.

Hint Resolve wef_cons.

Lemma Append_assoc :
 forall a b c : Word, Append a (Append b c) = Append (Append a b) c.
Hint Resolve Append_assoc. *)
Require Import need.
(* need:
Require Import Ensf.
Require Import Words.
Require Import more_words.

Axiom Dans_spec : forall (a : Elt) (E : Ensf), {dans a E} + {~ dans a E}.

Definition Dans (a : Elt) (E : Ensf) :=
  match Dans_spec a E return bool with
  | left a => true
  | right a => false
  end.

Axiom
  Append_Append :
    forall a a' b b' : Word,
    Append a b = Append a' b' ->
    exists w : Word,
      a = Append a' w /\ b' = Append w b \/
      a' = Append a w /\ b = Append w b'.

Axiom
  inmonoid_Append_inv2 :
    forall (X : Ensf) (a b : Word), inmonoid X (Append a b) -> inmonoid X b.

Hint Resolve dans_add. *)
Hint Resolve dans_map_inv.
Hint Resolve dans_map.
Hint Resolve dans_add1.

Definition comp (f g : Elt -> Elt) (x : Elt) := f (g x).

Lemma map_map_eg_map_comp :
 forall (f g : Elt -> Elt) (E : Ensf),
 map f (map g E) = map (comp f g) E :>Ensf.
intros f g.
simple induction E; simpl in |- *; auto.
Qed.

Definition comp_word (f g : Word -> Word) (x : Word) := f (g x).

Definition eg_f_W_W (f g : Word -> Word) := forall x : Word, f x = g x :>Word.

Lemma comp_Word_ext :
 forall f g : Elt -> Elt,
 eg_f_W_W (Word_ext (comp f g)) (comp_word (Word_ext f) (Word_ext g)).
intros f g.
unfold eg_f_W_W, Word_ext, comp, comp_word in |- *.
simple induction x; simpl in |- *; auto.
Qed.
Hint Resolve comp_Word_ext.

Definition Id (E : Ensf) (f : Elt -> Elt) :=
  forall x : Elt, dans x E -> f x = x :>Elt.

Lemma Id_inv :
 forall (E : Ensf) (f : Elt -> Elt) (x : Elt),
 dans x E -> Id E f -> f x = x :>Elt.
auto.
Qed.

Hint Unfold Id.

Lemma Id_inclus :
 forall (E F : Ensf) (f : Elt -> Elt), inclus F E -> Id E f -> Id F f.
auto.
Qed.

Lemma map_Id :
 forall (E : Ensf) (f : Elt -> Elt), Id E f -> map f E = E :>Ensf.
intros E f.
 elim E; unfold map in |- *.
 auto.

 intros a b Hyp_rec Id_a_b_f.
 apply add_add.
	auto.

 	apply Hyp_rec.
	apply Id_inclus with (add a b); auto.
Qed.

Definition Id_words (E : Ensf) (f : Word -> Word) :=
  forall x : Word, inmonoid E x -> f x = x :>Word.

Lemma Id_words_inv :
 forall (E : Ensf) (f : Word -> Word) (x : Word),
 inmonoid E x -> Id_words E f -> f x = x :>Word.

auto.
Qed.

Lemma Id_words_inclus :
 forall (E F : Ensf) (f : Word -> Word),
 inclus F E -> Id_words E f -> Id_words F f.
intros E F f inclus_F_E Id_E_f.
red in |- *.
intros x inmonoid_F_x.
apply Id_E_f.
apply inmonoid_inclus with F; assumption.
Qed.

Lemma extension_Id :
 forall (E : Ensf) (f : Elt -> Elt), Id E f -> Id_words E (Word_ext f).
intros E f Id_E_f.
red in |- *.
simple induction x; clear x.
	auto.

        unfold Word_ext in |- *.
		intros x w Hyp inmonoid_E_cons_x_w.
        simpl in |- *.
	
	apply cons_cons.
		apply Id_E_f; apply inmonoid_cons_inv2 with w; assumption.

		apply Hyp.
		apply inmonoid_cons_inv with x; assumption.

Qed.

Section fonctions.

Variable E : Ensf.
Variable F : Ensf.
Variable f : Elt -> Elt.

Definition application := forall x : Elt, dans x E -> dans (f x) F.

Hint Unfold application.

Definition is_mono :=
  forall x y : Elt, dans x E -> dans y E -> f x = f y :>Elt -> x = y :>Elt.

Definition is_epi :=
  application /\
  (forall x : Elt, dans x F -> exists2 y : Elt, x = f y & dans y E).

Definition is_iso := is_epi /\ is_mono.

Lemma mono_epi_imp_iso : is_mono -> is_epi -> is_iso.
intros; red in |- *; auto.
Qed.

Variable fw : Word -> Word.

Definition application_words :=
  forall x : Word, inmonoid E x -> inmonoid F (fw x).

Definition is_mono_words :=
  forall x y : Word,
  inmonoid E x -> inmonoid E y -> fw x = fw y :>Word -> x = y :>Word.

Definition is_epi_words :=
  application_words /\
  (forall x : Word, inmonoid F x -> exists2 y : Word, x = fw y & inmonoid E y).

Definition is_iso_words := is_mono_words /\ is_epi_words.

Lemma mono_epi_imp_iso_words : is_mono_words -> is_epi_words -> is_iso_words.
intros; red in |- *; auto.
Qed.

End fonctions.

Hint Resolve mono_epi_imp_iso.

Parameter inv : Ensf -> Ensf -> (Elt -> Elt) -> Elt -> Elt.

Axiom
  dans_inv_f :
    forall (E F : Ensf) (f : Elt -> Elt),
    is_iso E F f -> forall x : Elt, dans x F -> dans (inv E F f x) E.
Hint Resolve dans_inv_f.

Axiom
  inv1 :
    forall (E F : Ensf) (f : Elt -> Elt),
    is_iso E F f -> forall x : Elt, dans x E -> inv E F f (f x) = x :>Elt.

Hint Resolve inv1.

Axiom
  inv2 :
    forall (E F : Ensf) (f : Elt -> Elt),
    is_iso E F f -> forall x : Elt, dans x F -> f (inv E F f x) = x :>Elt.

Hint Resolve inv2.

Lemma inv1' :
 forall (E F : Ensf) (f : Elt -> Elt),
 is_iso E F f -> Id E (comp (inv E F f) f).
unfold Id, comp in |- *.
intros.
auto.
Qed.
Hint Resolve inv1'.

Axiom
  extension_spec :
    forall (V : Ensf) (f : Elt -> Elt) (x : Elt),
    {y : Elt | dans x V /\ y = f x :>Elt \/ ~ dans x V /\ y = x :>Elt}.

Definition extension (V : Ensf) (f : Elt -> Elt) (x : Elt) :=
  let (y, p) return Elt := extension_spec V f x in y.

Lemma extension_in :
 forall (e : Ensf) (f : Elt -> Elt) (x : Elt),
 dans x e -> extension e f x = f x :>Elt.
unfold extension in |- *.
intros e f x dans_x_e.
elim (extension_spec e f x).
intro.
tauto.
Qed.

Lemma extension_out :
 forall (e : Ensf) (f : Elt -> Elt) (x : Elt),
 ~ dans x e -> extension e f x = x :>Elt.
unfold extension in |- *.
intros e f x N_dans_x_e.
elim (extension_spec e f x).
intro; tauto.
Qed.

Section fonctions2.

Variable E : Ensf.
Variable F : Ensf.
Variable f : Elt -> Elt.

Hint Unfold application.
Lemma is_epi_f_over_image : is_epi E (map f E) f.

split.
 auto.

 intros.
 cut (exists y : Elt, dans y E /\ x = f y :>Elt).
	intro temp; elim temp; clear temp.
	intro. intuition.

	prolog [ ex_intro2 ] 4.
	 	auto.

Qed.

Hint Resolve is_epi_f_over_image.

Lemma mono_imp_iso_over_image : is_mono E f -> is_iso E (map f E) f.
auto.
Qed.

Let invf := inv E F f.

Hint Unfold invf.

Lemma inv_is_mono : is_iso E F f -> is_mono F invf.
intros.
red in |- *.
intros x y dans_x dans_y egal_inv.
replace x with (f (inv E F f x)).
replace y with (f (inv E F f y)).
apply (f_equal (A:=Elt) (B:=Elt)); assumption.
auto.
auto.
Qed.

Lemma inv_is_epi : is_iso E F f -> is_epi F E invf.
unfold invf in |- *.
intro is_iso_f.
split.
 auto. 

 intros x dans_x.
 exists (f x); [ apply sym_equal; auto | elim is_iso_f ].
 intros is_epi_f. elim is_epi_f.
 auto.

Qed.

Let wef := Word_ext f.

Lemma application_imp_application_words :
 application E F f -> application_words E F wef.
intro Hyp.
red in |- *.
intros x inmon; elim inmon; clear inmon.
	auto.

	intros.
	replace (wef (cons e w)) with (cons (f e) (wef w)); auto.

Qed.

Hint Resolve application_imp_application_words.

Lemma is_mono_f_imp_is_mono_words : is_mono E f -> is_mono_words E wef.
intro Hyp.
red in |- *.
simple induction x.
	intros.
	apply sym_equal.
	apply wef_nil with f.
	auto.

	intros x0 w0. intros.
	cut
  (exists x : Elt,
     (exists2 w : Word, cons x w = y & f x = f x0 /\ wef w = wef w0)).
	intro temp; elim temp; clear temp.
	intro e.
	intro temp; elim temp; clear temp.
	intro r.
	intros y_egal temp.
	elim temp; clear temp.
	intros.
	rewrite <- y_egal.
	apply cons_cons.
	apply Hyp. 
	apply inmonoid_cons_inv2 with w0; assumption.
	apply inmonoid_cons_inv2 with r; rewrite y_egal; assumption.
	auto.
	apply H.
		apply (inmonoid_cons_inv E w0 x0); assumption.
		apply (inmonoid_cons_inv E r e); rewrite y_egal; assumption.
		auto.

	unfold wef in |- *.

	auto.
Qed.

Hint Resolve is_mono_f_imp_is_mono_words.

Lemma is_epi_f_imp_is_epi_words : is_epi E F f -> is_epi_words E F wef.
intro temp; elim temp; clear temp.
intro application_f.
intro is_epi_f.
split.
auto.

simple induction x; clear x.
	exists nil; auto.

	intros x w Hyp inmonoid_F_cons.
	cut (exists2 y : Word, w = wef y & inmonoid E y). 
	intro temp; elim temp; clear temp.
	intros y1 y1_egal inmonoid_y1.
	cut (exists2 x_ant : Elt, x = f x_ant & dans x_ant E). 
	intro temp; elim temp; clear temp.
	intros x_ant x_egal dans_x_ant.
	exists (cons x_ant y1).
		unfold wef, Word_ext in |- *.
		auto.
		
		auto. 
	
	prolog [ inmonoid_cons_inv2 ] 3.     
	prolog [ inmonoid_cons_inv ] 3. 
Qed.

Hint Resolve is_epi_f_imp_is_epi_words.

Lemma is_iso_f_imp_is_iso_words : is_iso E F f -> is_iso_words E F wef.
intro is_iso_f.
elim is_iso_f; intros.
split; auto.
Qed.

Let invf' := inv E F f.
Let weinvf := Word_ext invf'.
Let weinvf_wef := comp_word weinvf wef.

Lemma is_iso_f_imp_Id_words_weinvf_wef :
 is_iso E F f -> Id_words E weinvf_wef.

intro is_iso_f.
red in |- *.
intro x.
unfold weinvf_wef, weinvf, wef in |- *. 
cut
 (eg_f_W_W (Word_ext (comp invf' f))
    (comp_word (Word_ext invf') (Word_ext f))).
unfold eg_f_W_W in |- *.
intro Hyp.
rewrite <- (Hyp x).
generalize x.
change (Id_words E (Word_ext (comp invf' f))) in |- *.
apply extension_Id.
unfold invf' in |- *.
auto.

auto.
Qed.

End fonctions2.
Hint Resolve mono_imp_iso_over_image.