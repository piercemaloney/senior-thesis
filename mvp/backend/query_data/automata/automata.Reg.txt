

Require Import Ensf.
(* Ensf:
Require Export Ensf_types.

Require Export Ensf_dans.

Require Export Ensf_union.

Require Export Ensf_couple.

Require Export Ensf_produit.

Require Export Ensf_inclus.

Require Export Ensf_inter.

Require Export Ensf_map.

Require Export Ensf_disj. *)

Require Import Max.
(* Max:
Require Import Le.
Require Import Lt.
Require Import Ensf.
Require Export Arith.Max.

Definition Z (x : Elt) : nat := match x with
                                | natural n => S n
                                | _ => 0
                                end.

Fixpoint sup (e : Ensf) : nat :=
  match e with
  | empty => 0
  | add x f => max (Z x) (sup f)
  end.

Lemma sup_add :
 forall (x : Elt) (e : Ensf), sup (add x e) = max (Z x) (sup e) :>nat.
Hint Resolve sup_add.

Lemma elt_not_sym : forall a b : Elt, a <> b :>Elt -> b <> a :>Elt.

Lemma lt_n_Z : forall n : nat, n < Z (natural n).

Lemma lt_n_sup : forall (x : Ensf) (n : nat), dans (natural n) x -> n < sup x.

Lemma sup_out : forall x : Ensf, ~ dans (natural (sup x)) x.

Lemma exist_other : forall e : Ensf, exists x : Elt, ~ dans x e. *)

Require Import Words.
(* Words:
Require Import Ensf.

Parameter alph : Ensf.
Parameter epsilon : Elt.
  Axiom not_dans_epsilon_alph : ~ dans epsilon alph.

Inductive inmonoid (X : Ensf) : Word -> Prop :=
  | inmonoid_nil : inmonoid X nil
  | inmonoid_cons :
      forall (w : Word) (e : Elt),
      inmonoid X w -> dans e X -> inmonoid X (cons e w).
Hint Resolve inmonoid_nil.
Hint Resolve inmonoid_cons.

Fixpoint Inmonoid (X : Ensf) (w : Word) {struct w} : Prop :=
  match w with
  | nil => True
  | cons a w' => dans a X /\ Inmonoid X w'
  end.

Lemma i_I : forall (X : Ensf) (w : Word), inmonoid X w -> Inmonoid X w.
Hint Resolve i_I.

Lemma I_i : forall (X : Ensf) (w : Word), Inmonoid X w -> inmonoid X w.
Hint Resolve I_i.

Lemma inmonoid_cons_inv :
 forall (X : Ensf) (w : Word) (a : Elt),
 inmonoid X (cons a w) -> inmonoid X w.

Lemma inmonoid_cons_inv2 :
 forall (X : Ensf) (a : Elt) (w : Word), inmonoid X (cons a w) -> dans a X.

Lemma inmonoid_inclus :
 forall (E F : Ensf) (x : Word), inclus E F -> inmonoid E x -> inmonoid F x.

Fixpoint Append (w1 : Word) : Word -> Word :=
  fun w2 : Word =>
  match w1 with
  | nil => w2
  | cons a w3 => cons a (Append w3 w2)
  end.

Lemma Append_w_nil : forall w : Word, Append w nil = w :>Word.

Inductive append : Word -> Word -> Word -> Prop :=
  | append_nil : forall w : Word, append nil w w
  | append_cons :
      forall (w1 w2 w3 : Word) (a : Elt),
      append w1 w2 w3 -> append (cons a w1) w2 (cons a w3).

Lemma Append_inmonoid_g :
 forall (X : Ensf) (w1 w2 : Word), inmonoid X (Append w1 w2) -> inmonoid X w1.

Lemma Append_inmonoid_d :
 forall (X : Ensf) (w1 w2 : Word), inmonoid X (Append w1 w2) -> inmonoid X w2.

Lemma inmonoid_Append :
 forall (X : Ensf) (w1 w2 : Word),
 inmonoid X w1 -> inmonoid X w2 -> inmonoid X (Append w1 w2).

Definition wordset := Word -> Prop.

Definition eqwordset (l1 l2 : wordset) : Prop :=
  forall w : Word, (l1 w -> l2 w) /\ (l2 w -> l1 w).

Lemma eqwordset_refl : forall L : wordset, eqwordset L L.

Lemma eqwordset_sym :
 forall l1 l2 : wordset, eqwordset l1 l2 -> eqwordset l2 l1.

Lemma eqwordset_trans :
 forall l1 l2 l3 : wordset,
 eqwordset l1 l2 -> eqwordset l2 l3 -> eqwordset l1 l3.

Definition islanguage (X : Ensf) (L : wordset) : Prop :=
  forall w : Word, L w -> inmonoid X w.

Fixpoint Word_ext (f : Elt -> Elt) (w : Word) {struct w} : Word :=
  match w with
  | nil => nil
  | cons a w' => cons (f a) (Word_ext f w')
  end.

Lemma inmonoid_map :
 forall (f : Elt -> Elt) (a : Ensf) (w : Word),
 inmonoid a w -> inmonoid (map f a) (Word_ext f w).
Hint Resolve inmonoid_map.

Lemma cons_cons :
 forall (x1 x2 : Elt) (w1 w2 : Word),
 x1 = x2 :>Elt -> w1 = w2 :>Word -> cons x1 w1 = cons x2 w2 :>Word.
Hint Resolve cons_cons.

Definition fun_consaw_a (w : Word) : Elt :=
  match w return Elt with
  | nil =>
        zero
       
  | cons a w' => a
  end.

Definition fun_consaw_w (w : Word) : Word :=
  match w return Word with
  | nil =>
        nil
       
  | cons a w' => w'
  end.

Lemma cons_cons_inv :
 forall (x1 x2 : Elt) (w1 w2 : Word),
 cons x1 w1 = cons x2 w2 -> x1 = x2 /\ w1 = w2.

Hint Resolve cons_cons_inv.

Lemma cons_cons_inv1 :
 forall (x1 x2 : Elt) (w1 w2 : Word),
 cons x1 w1 = cons x2 w2 :>Word -> x1 = x2 :>Elt.

Lemma cons_cons_inv2 :
 forall (x1 x2 : Elt) (w1 w2 : Word), cons x1 w1 = cons x2 w2 -> w1 = w2.

Lemma nil_or_cons :
 forall w : Word,
 w = nil \/ (exists x : Elt, (exists w0 : Word, w = cons x w0)). *)

Require Import Dec.
(* Dec:
Require Import Ensf.

Axiom Pdec : forall (P : Elt -> Prop) (x : Elt), {P x} + {~ P x}.

Fixpoint tq (f : Elt -> Prop) (e : Ensf) {struct e} : Ensf :=
  match e return Ensf with
  | empty =>
        empty
       
  | add x F =>
      match Pdec f x return Ensf with
      | left fx =>
          	 add x (tq f F)
          	
      | right nfx => tq f F
      end
  end.

Lemma dans_tq_imp :
 forall (x : Elt) (f : Elt -> Prop) (E : Ensf),
 dans x (tq f E) -> dans x E /\ f x.

Lemma imp_dans_tq :
 forall (x : Elt) (f : Elt -> Prop) (E : Ensf),
 dans x E -> f x -> dans x (tq f E).

Lemma inclus_tq : forall (f : Elt -> Prop) (a : Ensf), inclus (tq f a) a. *)



Definition automate (q qd qa d : Ensf) : Prop :=

  inclus qa q /\ inclus qd q /\ inclus d (prodcart q (prodcart alph q)).



Lemma automate_def1 :

 forall q qd qa d : Ensf,

 automate q qd qa d -> inclus d (prodcart q (prodcart alph q)).

intros q qd qa d H.

elim H.

intros H1 H0; elim H0; clear H0.

auto.

Qed.



Lemma automate_def2 :

 forall q qd qa d : Ensf, automate q qd qa d -> inclus qd q.

intros q qd qa d H.

elim H.

intros H1 H0; elim H0; clear H0.

auto.

Qed.



Lemma automate_def3 :

 forall q qd qa d : Ensf, automate q qd qa d -> inclus qa q.

intros q qd qa d H.

elim H.

intros H1 H0; elim H0; clear H0.

auto.

Qed.



Inductive chemin : Elt -> Elt -> Ensf -> Ensf -> Word -> Prop :=

  | chemin_nil :

      forall (e1 e2 : Elt) (q d : Ensf),

      dans e1 q -> e1 = e2 :>Elt -> chemin e1 e2 q d nil

  | chemin_cons :

      forall (e1 e2 : Elt) (q d : Ensf) (w : Word) (e a : Elt),

      chemin e1 e2 q d w ->

      dans e q ->

      dans a alph ->

      dans (couple e (couple a e1)) d -> chemin e e2 q d (cons a w).



Hint Resolve chemin_nil.



Definition Chemin (e1 e2 : Elt) (q d : Ensf) (w : Word) : Prop :=

  match w return Prop with

  | nil =>

        dans e1 q /\ e1 = e2 :>Elt

       

  | cons a w' =>

      exists e : Elt,

        chemin e e2 q d w' /\

        dans e1 q /\ dans a alph /\ dans (couple e1 (couple a e)) d

  end.



Lemma Chemin_chemin :

 forall (e1 e2 : Elt) (q d : Ensf) (w : Word),

 Chemin e1 e2 q d w -> chemin e1 e2 q d w.

intros e1 e2 q d.

simple induction w.

intro.

cut (dans e1 q /\ e1 = e2 :>Elt); auto.

intro H0; elim H0; clear H0. 

intros; apply chemin_nil; auto.

intros x w0 H H0.

cut

 (exists e : Elt,

    chemin e e2 q d w0 /\

    dans e1 q /\ dans x alph /\ dans (couple e1 (couple x e)) d);

 auto.

intro H1; elim H1.

intros e H2; elim H2; clear H1 H2.

intros H1 H2; elim H2; clear H2.

intros H2 H3; elim H3; clear H3.

intros.

apply chemin_cons with e; auto.

Qed.

Hint Resolve Chemin_chemin.



Lemma chemin_Chemin :

 forall (e1 e2 : Elt) (q d : Ensf) (w : Word),

 chemin e1 e2 q d w -> Chemin e1 e2 q d w.

intros e1 e2 q d w H; elim H; clear H.

intros.

red in |- *; simpl in |- *; auto.

intros.

red in |- *; simpl in |- *.

exists e0.

auto.

Qed.

Hint Resolve chemin_Chemin.



Definition reconnait (q qd qa d : Ensf) (w : Word) : Prop :=

  inmonoid alph w /\

  (exists e1 : Elt,

     (exists e2 : Elt, dans e1 qd /\ dans e2 qa /\ chemin e1 e2 q d w)).



Lemma dans_e1_q :

 forall (q d : Ensf) (w : Word) (e1 e2 : Elt),

 chemin e1 e2 q d w -> dans e1 q.

intros q d.

simple induction w.

intros.

cut (Chemin e1 e2 q d nil); auto.

intro.

cut (dans e1 q /\ e1 = e2 :>Elt); auto.

intro Ht; elim Ht; auto.

intros x w0 H e1 e2 H0.

cut (Chemin e1 e2 q d (cons x w0)); auto.

intro.

cut

 (exists e : Elt,

    chemin e e2 q d w0 /\

    dans e1 q /\ dans x alph /\ dans (couple e1 (couple x e)) d);

 auto.

intro Ht; elim Ht; clear Ht.

intros e Ht; elim Ht; clear Ht.

intros H2 Ht; elim Ht; auto.

Qed.



Lemma dans_e2_q :

 forall (q d : Ensf) (w : Word) (e1 e2 : Elt),

 chemin e1 e2 q d w -> dans e2 q.

intros q d.

simple induction w.

intros.

cut (Chemin e1 e2 q d nil); auto.

intro.

cut (dans e1 q /\ e1 = e2 :>Elt); auto.

intro Ht; elim Ht; auto.

intros.

rewrite <- H2; auto.

intros x w0 H e1 e2 H0.

cut (Chemin e1 e2 q d (cons x w0)); auto.

intro.

cut

 (exists e : Elt,

    chemin e e2 q d w0 /\

    dans e1 q /\ dans x alph /\ dans (couple e1 (couple x e)) d);

 auto.

intro Ht; elim Ht; clear Ht.

intros e Ht; elim Ht; clear Ht.

intros H2 Ht.  

apply (H e e2); auto.

Qed.



Lemma Cheminmonoid :

 forall (w : Word) (q qd qa d : Ensf),

 automate q qd qa d ->

 forall e1 e2 : Elt, chemin e1 e2 q d w -> inmonoid alph w.

simple induction w.

auto.

intros x w0 H q qd qa d H0 e1 e2 H1.

cut (Chemin e1 e2 q d (cons x w0)); auto.

intro.

cut

 (exists e : Elt,

    chemin e e2 q d w0 /\

    dans e1 q /\ dans x alph /\ dans (couple e1 (couple x e)) d);

 auto.

intro H3; elim H3; clear H3.

intros e H3; elim H3; clear H3.

intros H3 H4; elim H4; clear H4.

intros H4 H5; elim H5; clear H5; intros.

apply inmonoid_cons; auto.

apply (H q qd qa d H0 e e2); auto.

Qed.



Lemma chemin_lettre :

 forall (e1 e2 x : Elt) (q d : Ensf),

 dans x alph ->

 dans e1 q ->

 dans e2 q ->

 dans (couple e1 (couple x e2)) d -> chemin e1 e2 q d (cons x nil).

intros.

apply chemin_cons with e2; auto. 

Qed.



Definition automate_A (q qd qa d : Ensf) : Prop :=

  inclus qa q /\

  inclus qd q /\ inclus d (prodcart q (prodcart (add epsilon alph) q)).



Lemma automate_A_def2 :

 forall q qd qa d : Ensf, automate_A q qd qa d -> inclus qd q.

intros.

elim H.

intros H0 Ht; elim Ht; auto.

Qed.



Inductive chemin_A (q d : Ensf) : Elt -> Elt -> Word -> Prop :=

  | chemin_A_nil :

      forall e1 e2 : Elt,

      dans e1 q -> e1 = e2 :>Elt -> chemin_A q d e1 e2 nil

  | chemin_A_cons :

      forall (e1 e e2 x : Elt) (w : Word),

      chemin_A q d e e2 w ->

      dans e1 q ->

      dans x alph ->

      dans (couple e1 (couple x e)) d -> chemin_A q d e1 e2 (cons x w)

  | chemin_A_epsilon :

      forall (e1 e e2 : Elt) (w : Word),

      chemin_A q d e e2 w ->

      dans e1 q ->

      dans (couple e1 (couple epsilon e)) d -> chemin_A q d e1 e2 w.

Hint Resolve chemin_A_nil.



Definition Chemin_A (q d : Ensf) (e1 e2 : Elt) (w : Word) : Prop :=

  match w return Prop with

  | nil =>

       

      dans e1 q /\ e1 = e2 :>Elt \/

      (exists e : Elt,

         chemin_A q d e e2 nil /\

         dans e1 q /\ dans (couple e1 (couple epsilon e)) d)

      

  | cons a w =>

      (exists e : Elt,

         chemin_A q d e e2 w /\

         dans e1 q /\ dans a alph /\ dans (couple e1 (couple a e)) d) \/

      (exists e : Elt,

         chemin_A q d e e2 w /\

         dans e1 q /\ dans (couple e1 (couple epsilon e)) d)

  end.



Lemma chemin_A_d1_d2 :

 forall (q d1 d2 : Ensf) (w : Word) (e1 e2 : Elt),

 chemin_A q d1 e1 e2 w -> inclus d1 d2 -> chemin_A q d2 e1 e2 w.

intros q d d2 w e1 e2 H.

elim H; clear H.

auto.



intros.

apply chemin_A_cons with e; auto.



intros.

apply chemin_A_epsilon with e; auto.

Qed.



Lemma chemin_A_q1_q2 :

 forall (q1 q2 d : Ensf) (e1 e2 : Elt) (w : Word),

 chemin_A q1 d e1 e2 w -> inclus q1 q2 -> chemin_A q2 d e1 e2 w.

intros q1 q2 d w e1 e2 H.

elim H; clear H.



auto.



intros.

apply chemin_A_cons with e; auto.



intros.

apply chemin_A_epsilon with e; auto.

Qed.



Lemma chemin_chemin_A :

 forall (q d : Ensf) (w : Word) (e1 e2 : Elt),

 chemin e1 e2 q d w -> chemin_A q d e1 e2 w.

intros q d w e1 e2 H. 

elim H; clear H.

auto.



intros.

apply chemin_A_cons with e0; auto.

Qed.



Lemma chemin_Append :

 forall (e1 e e2 : Elt) (q d : Ensf) (w1 w2 : Word),

 chemin_A q d e1 e w1 ->

 chemin_A q d e e2 w2 -> chemin_A q d e1 e2 (Append w1 w2).

intros e1 e e2 q d w1 w2 H.

elim H.



intros e0 e3 H0 H1 H2.

simpl in |- *; rewrite H1; auto.



intros.

simpl in |- *.

cut (chemin_A q d e3 e2 (Append w w2)); auto.

intro.

apply chemin_A_cons with e3; auto.



intros.

cut (chemin_A q d e3 e2 (Append w w2)); auto.

intro.

apply chemin_A_epsilon with e3; auto.

Qed.



Lemma dansA_e1_q :

 forall (q d : Ensf) (w : Word) (e1 e2 : Elt),

 chemin_A q d e1 e2 w -> dans e1 q.

intros.

elim H; auto.

Qed.



Lemma dansA_e2_q :

 forall (q d : Ensf) (w : Word) (e1 e2 : Elt),

 chemin_A q d e1 e2 w -> dans e2 q.

intros.

elim H; auto.

intros e0 e3 H0 H1.

rewrite <- H1.

assumption.

Qed.



Lemma cheminA_monoid :

 forall (w : Word) (q qd qaA dA : Ensf),

 automate_A q qd qaA dA ->

 forall e1 e2 : Elt, chemin_A q dA e1 e2 w -> inmonoid alph w.

intros.

elim H0; auto.

Qed.



Definition reconnait_A (q qd qa d : Ensf) (w : Word) : Prop :=

  inmonoid alph w /\

  (exists e1 : Elt,

     (exists e2 : Elt, dans e1 qd /\ dans e2 qa /\ chemin_A q d e1 e2 w)).



Definition est_dans_d2 (q dA : Ensf) (e y : Elt) : Prop :=

  match y return Prop with

  | natural n =>

        False

       

  | couple a e' => chemin_A q dA e e' (cons a nil)

       

  | up e => False

       

  | word w => False

  end.



Definition est_dans_d (q dA : Ensf) (x : Elt) : Prop :=

  match x return Prop with

  | natural n =>

        False

       

  | couple e y => est_dans_d2 q dA e y

       

  | up e => False

       

  | word w => False

  end.



Definition sync_d (q dA : Ensf) : Ensf :=

  tq (est_dans_d q dA) (prodcart q (prodcart alph q)).



Definition sync_qa (q qaA dA : Ensf) : Ensf :=

  union qaA

    (tq

       (fun e : Elt => exists e' : Elt, dans e' qaA /\ chemin_A q dA e e' nil)

       q).

Hint Unfold sync_qa.



Lemma inclus_qaA_qa : forall q qaA dA : Ensf, inclus qaA (sync_qa q qaA dA).

unfold sync_qa in |- *.

auto.

Qed.



Lemma nouvx_dans_qa :

 forall (q qaA dA : Ensf) (e : Elt),

 dans e q ->

 (exists e' : Elt, dans e' qaA /\ chemin_A q dA e e' nil) ->

 dans e (sync_qa q qaA dA).

intros.

elim H0; clear H0.

intros e' Ht; elim Ht; clear Ht.

intros H0 H1.

unfold sync_qa in |- *.

apply union_d.

apply imp_dans_tq; auto.

exists e'; auto.

Qed.



Lemma sync_d_def :

 forall (e1 e2 x : Elt) (q dA : Ensf),

 dans x alph ->

 chemin_A q dA e1 e2 (cons x nil) ->

 dans (couple e1 (couple x e2)) (sync_d q dA).

intros.

unfold sync_d in |- *.

apply imp_dans_tq; auto.

apply coupl2_inv.

apply (dansA_e1_q q dA (cons x nil) e1 e2); auto.

apply coupl2_inv; auto.

apply (dansA_e2_q q dA (cons x nil) e1 e2); auto.

Qed.



Lemma sync_d_def2 :

 forall (e1 e2 x : Elt) (q dA : Ensf),

 dans x alph ->

 dans (couple e1 (couple x e2)) (sync_d q dA) ->

 chemin_A q dA e1 e2 (cons x nil).

intros e1 e2 x q dA H.

unfold sync_d in |- *.

intro.

cut

 (dans (couple e1 (couple x e2)) (prodcart q (prodcart alph q)) /\

  est_dans_d q dA (couple e1 (couple x e2))).

2: apply dans_tq_imp; auto.

intro Ht; elim Ht; clear Ht.

intro H1.

unfold est_dans_d in |- *.

unfold est_dans_d2 in |- *.

auto.

Qed.



Lemma trans_dA_d :

 forall (q dA : Ensf) (e0 e x : Elt),

 dans e0 q ->

 dans x alph ->

 dans e q ->

 dans (couple e0 (couple x e)) dA ->

 dans (couple e0 (couple x e)) (sync_d q dA).

intros.

cut (chemin_A q dA e0 e (cons x nil)).

intro.

unfold sync_d in |- *.

apply imp_dans_tq; auto.

cut (chemin_A q dA e e nil); auto.

intro.

apply chemin_A_cons with e; auto.

Qed.



Lemma automateA_automate :

 forall q qd qaA dA : Ensf,

 automate_A q qd qaA dA -> automate q qd (sync_qa q qaA dA) (sync_d q dA).

intros.

elim H.

intros H1 H2; elim H2; clear H2; intros H2 H3.

red in |- *.

split.

unfold sync_qa in |- *.

apply union_inclus; auto.

apply inclus_tq.

split; auto.

unfold sync_d in |- *.

apply inclus_tq.

Qed.



Lemma epsilon_chemin :

 forall (q qaA dA : Ensf) (w : Word) (e1 e e2 : Elt),

 chemin e e2 q (sync_d q dA) w ->

 dans (couple e1 (couple epsilon e)) dA ->

 dans e2 (sync_qa q qaA dA) ->

 dans e1 q ->

 exists e2' : Elt,

   chemin e1 e2' q (sync_d q dA) w /\ dans e2' (sync_qa q qaA dA).

intros q qaA dA.

simple induction w.



intros.

exists e1.

split.

auto.

cut (Chemin e e2 q (sync_d q dA) nil); auto.

intro H3.

cut (dans e q /\ e = e2 :>Elt); auto.

intro Ht; elim Ht; clear Ht.

intros H4 H5.

cut (chemin_A q dA e e2 nil); auto.

cut (chemin_A q dA e1 e2 nil).

2: apply chemin_A_epsilon with e; auto.

intros.

unfold sync_qa in H1.

cut

 (dans e2 qaA \/

  dans e2

    (tq

       (fun e : Elt => exists e' : Elt, dans e' qaA /\ chemin_A q dA e e' nil)

       q)).   

2: apply dans_union; auto.

intro Ht; elim Ht; clear Ht.

intro; apply nouvx_dans_qa; auto.

exists e2; auto.



intro.

cut

 (dans e2 q /\

  (fun e : Elt => exists e' : Elt, dans e' qaA /\ chemin_A q dA e e' nil) e2).

2: apply

    dans_tq_imp

     with

       (f := fun e : Elt =>

             ex (fun e' : Elt => dans e' qaA /\ chemin_A q dA e e' nil));

    assumption.

intro Ht; elim Ht; clear Ht.

intros H9 Ht; elim Ht; clear Ht.

intros e3 Ht; elim Ht; clear Ht.

intros H10 H11.

cut (chemin_A q dA e e3 nil); auto.

2: rewrite H5; auto.

intro H12.

cut (chemin_A q dA e1 e3 nil).

2: apply chemin_A_epsilon with e; auto.

intro; apply nouvx_dans_qa; auto.

exists e3; auto.



intros x w0 H e1 e e2 H0 H1 H2 H3.

cut (Chemin e e2 q (sync_d q dA) (cons x w0)); auto.

intro.

cut

 (exists e22 : Elt,

    chemin e22 e2 q (sync_d q dA) w0 /\

    dans e q /\ dans x alph /\ dans (couple e (couple x e22)) (sync_d q dA));

 auto.

intro Ht; elim Ht; clear Ht.

intros e22 Ht; elim Ht; clear Ht.

intros H5 Ht; elim Ht; clear Ht.

intros H6 Ht; elim Ht; clear Ht; intros H7 H8.

exists e2.

split; auto.

cut (chemin_A q dA e e22 (cons x nil)).

2: apply sync_d_def2; auto.

intro.

cut (chemin_A q dA e1 e22 (cons x nil)).

2: apply chemin_A_epsilon with e; auto.

intro.

cut (dans (couple e1 (couple x e22)) (sync_d q dA)).

2: apply sync_d_def; auto.

intro.

apply chemin_cons with e22; auto.

Qed.



Lemma cheminA_chemin :

 forall q qd qaA dA : Ensf,

 automate_A q qd qaA dA ->

 forall (w : Word) (e1 e2 : Elt),

 chemin_A q dA e1 e2 w ->

 dans e2 qaA ->

 exists e2' : Elt,

   chemin e1 e2' q (sync_d q dA) w /\ dans e2' (sync_qa q qaA dA).

intros q qd qaA dA H_aut w.

cut (inclus qaA (sync_qa q qaA dA)).

2: apply inclus_qaA_qa.

intro H0.

intros e1 e2 H1.

elim H1.



intros e0 e3 H H2 H3.

exists e0.

split.

apply chemin_nil; auto.

rewrite H2.

apply dans_trans with qaA; auto.



intros.

cut

 (exists e2' : Elt,

    chemin e e2' q (sync_d q dA) w0 /\ dans e2' (sync_qa q qaA dA));

 auto.

intro Ht; elim Ht; clear Ht.

intros e2' Ht; elim Ht; clear Ht.

intros H7 H8.

exists e2'.

split; auto.

apply chemin_cons with e; auto.

cut (dans e q).

2: apply (dans_e1_q q (sync_d q dA) w0 e e2'); auto.

intro dans_e_q.

apply trans_dA_d; auto.



intros.

cut

 (exists e2' : Elt,

    chemin e e2' q (sync_d q dA) w0 /\ dans e2' (sync_qa q qaA dA));

 auto.

intro Ht; elim Ht; clear Ht.

intros e9 Ht; elim Ht; clear Ht.

intros H6 H7.

apply (epsilon_chemin q qaA dA w0 e0 e e9); auto.

Qed.



Lemma reconnaitA_reconnait :

 forall (q qd qaA dA : Ensf) (w : Word),

 automate_A q qd qaA dA ->

 reconnait_A q qd qaA dA w ->

 reconnait q qd (sync_qa q qaA dA) (sync_d q dA) w.

intros q qd qaA dA w H_aut.

unfold reconnait_A in |- *.

intro H; elim H; clear H.

intros H1 H; elim H; clear H.

intros e1 H; elim H; clear H.

intros e2 H; elim H; clear H.

intros H2 H; elim H; clear H; intros H3 H4.

unfold reconnait in |- *.

split; auto. 

exists e1.

cut

 (exists e2' : Elt,

    chemin e1 e2' q (sync_d q dA) w /\ dans e2' (sync_qa q qaA dA)). 

2: apply (cheminA_chemin q qd qaA dA H_aut w e1 e2); auto.

intro Ht; elim Ht; clear Ht.

intros e2' Ht; elim Ht; clear Ht.

intros H5 H6.

exists e2'.

auto.

Qed.



Lemma chemin_cheminA :

 forall q qd qaA dA : Ensf,

 automate_A q qd qaA dA ->

 forall (w : Word) (e1 e2 : Elt),

 chemin e1 e2 q (sync_d q dA) w -> chemin_A q dA e1 e2 w.

intros q qd qaA dA H_aut.

simple induction w.

intros.

cut (Chemin e1 e2 q (sync_d q dA) nil); auto.



intro.

cut (dans e1 q /\ e1 = e2 :>Elt); auto.

intro Ht; elim Ht; clear Ht.

intros; apply chemin_A_nil; auto.



intros x w0 H e1 e2 H0.

cut (Chemin e1 e2 q (sync_d q dA) (cons x w0)); auto.

intro H1.

cut

 (exists e : Elt,

    chemin e e2 q (sync_d q dA) w0 /\

    dans e1 q /\ dans x alph /\ dans (couple e1 (couple x e)) (sync_d q dA));

 auto.

intro Ht; elim Ht; clear Ht.

intros e Ht; elim Ht; clear Ht.

intros H2 Ht; elim Ht; clear Ht.

intros H3 H4.

cut (chemin_A q dA e e2 w0); auto.

intro.

elim H4; clear H4; intros H4 H6.

cut (chemin_A q dA e1 e (cons x nil)).

2: apply sync_d_def2; auto.

intro.

replace (cons x w0) with (Append (cons x nil) w0); auto.

apply chemin_Append with e; auto.

Qed.



Lemma reconnait_reconnaitA :

 forall (q qd qaA dA : Ensf) (w : Word),

 automate_A q qd qaA dA ->

 reconnait q qd (sync_qa q qaA dA) (sync_d q dA) w ->

 reconnait_A q qd qaA dA w.

intros q qd qaA dA w H_aut.

unfold reconnait in |- *.

intro Ht; elim Ht; clear Ht.

intros H Ht; elim Ht; clear Ht.

intros e1 Ht; elim Ht; clear Ht.

intros e2 Ht; elim Ht; clear Ht.

intros H0 Ht; elim Ht; clear Ht.

intros H1 H2.

cut

 (dans e2

    (union qaA

       (tq

          (fun e : Elt =>

           exists e' : Elt, dans e' qaA /\ chemin_A q dA e e' nil) q)));

 auto.

intro H3.

cut

 (dans e2 qaA \/

  dans e2

    (tq

       (fun e : Elt => exists e' : Elt, dans e' qaA /\ chemin_A q dA e e' nil)

       q)).

2: apply dans_union; auto.

intro H4.

unfold reconnait_A in |- *.

split; auto.

exists e1.

clear H3; elim H4.



intro.

exists e2.

split; auto.

split; auto.

apply (chemin_cheminA q qd qaA dA H_aut); auto.



intro.

cut

 (dans e2 q /\

  (fun e : Elt => exists e' : Elt, dans e' qaA /\ chemin_A q dA e e' nil) e2).

2: apply

    dans_tq_imp

     with

       (f := fun e : Elt =>

             exists e' : Elt, dans e' qaA /\ chemin_A q dA e e' nil);

    auto.

intro Ht; elim Ht; clear Ht.

intros H5 Ht; elim Ht; clear Ht. 

intros e2' Ht; elim Ht; clear Ht.

intros H6 H7.

exists e2'.

split; auto.

split; auto.

cut (chemin_A q dA e1 e2 w). 

2: apply (chemin_cheminA q qd qaA dA H_aut); auto.

intro.

replace w with (Append w nil).

apply chemin_Append with e2; auto.

apply Append_w_nil.

Qed.



Lemma async_is_sync :

 forall q qd qaA dA : Ensf,

 automate_A q qd qaA dA ->

 exists d : Ensf,

   (exists qa : Ensf,

      automate q qd qa d /\

      eqwordset (reconnait_A q qd qaA dA) (reconnait q qd qa d)).

intros q qd qaA dA H.   

exists (sync_d q dA).

exists (sync_qa q qaA dA).

split.

apply automateA_automate; auto.

unfold eqwordset in |- *.

split.

intro.

apply reconnaitA_reconnait; auto.

intro.

apply reconnait_reconnaitA; auto.

Qed.



Lemma Recislang :

 forall q qd qa d : Ensf,

 automate q qd qa d -> islanguage alph (reconnait q qd qa d).

intros.

unfold islanguage at 1 in |- *.

intro.

unfold reconnait at 1 in |- *.

intro.

elim H0.

intros.

assumption.

Qed.



Definition isregular (l : wordset) : Prop :=

  exists q : Ensf,

    (exists qd : Ensf,

       (exists qa : Ensf,

          (exists d : Ensf,

             automate q qd qa d /\ eqwordset (reconnait q qd qa d) l))).

  

Definition isregular_A (l : wordset) : Prop :=

  exists q : Ensf,

    (exists qd : Ensf,

       (exists qa : Ensf,

          (exists d : Ensf,

             automate_A q qd qa d /\ eqwordset (reconnait_A q qd qa d) l))).



Lemma isregular_A_isregular :

 forall l : wordset, isregular_A l -> isregular l.

unfold isregular_A in |- *.

intros l Ht; elim Ht; clear Ht.

intros q Ht; elim Ht; clear Ht.

intros qd Ht; elim Ht; clear Ht.

intros qaA Ht; elim Ht; clear Ht.

intros dA Ht; elim Ht; clear Ht.

intros.

cut

 (exists d : Ensf,

    (exists qa : Ensf,

       automate q qd qa d /\

       eqwordset (reconnait_A q qd qaA dA) (reconnait q qd qa d))).

2: apply async_is_sync; auto.

intro Ht; elim Ht; clear Ht.

intros d Ht; elim Ht; clear Ht.

intros qa Ht; elim Ht; clear Ht.

intros.

unfold isregular in |- *.

exists q.

exists qd.

exists qa.

exists d.

split; auto.

apply eqwordset_trans with (reconnait_A q qd qaA dA); auto.

apply eqwordset_sym; auto.

Qed.



Definition isregular_D (l : wordset) : Prop :=

  exists q : Ensf,

    (exists g0 : Elt,

       (exists qa : Ensf,

          (exists d : Ensf,

             automate q (singleton g0) qa d /\

             (forall w : Word, chemin g0 g0 q d w -> w = nil :>Word) /\

             eqwordset (reconnait q (singleton g0) qa d) l))).



Definition transition_D (g0 x : Elt) : Elt := couple g0 (couple epsilon x).



Definition delta_D (g0 : Elt) (qd : Ensf) : Ensf := map (transition_D g0) qd.



Lemma automate_A_D :

 forall (q qd qa d : Ensf) (g0 : Elt),

 automate q qd qa d ->

 automate_A (add g0 q) (singleton g0) qa (union d (delta_D g0 qd)).

unfold automate_A in |- *.

split.

apply inclus_add.

apply automate_def3 with qd d; auto.

split; auto.

apply union_inclus.

apply inclus_trans with (prodcart q (prodcart alph q)).

apply automate_def1 with qd qa; assumption.

apply cart_inclus; auto.

unfold delta_D in |- *.

unfold inclus in |- *.

intros x H2.

cut (exists y : Elt, dans y qd /\ x = transition_D g0 y :>Elt).

2: apply dans_map; auto.

intro Ht; elim Ht; clear Ht; intros t Ht; elim Ht; clear Ht; intros.

rewrite H1.

unfold transition_D in |- *.

apply coupl2_inv; auto.

apply coupl2_inv; auto.

apply dans_add2.

apply dans_trans with qd; auto.

apply automate_def2 with qa d; auto.

Qed.



Lemma chemin_D_chemin :

 forall (q qd qa d : Ensf) (g0 e e2 : Elt) (w : Word),

 automate q qd qa d ->

 ~ dans g0 q ->

 chemin_A (add g0 q) (union d (delta_D g0 qd)) e e2 w ->

 dans e q -> chemin e e2 q d w.

intros q qd qa d g0 e e2 w H_aut H_g0 H.

elim H; clear H.



auto.



intros e1 e0 e3 x w0 H H0 H1 H2 H3 H4.

cut

 (dans (couple e1 (couple x e0)) d \/

  dans (couple e1 (couple x e0)) (delta_D g0 qd)); 

 auto.

intro Ht; elim Ht; clear Ht.

	intro.

	cut (dans (couple e1 (couple x e0)) (prodcart q (prodcart alph q))).

	2: apply dans_trans with d; auto.

	2: apply automate_def1 with qd qa; auto.

	intro.

	cut (dans e1 q /\ dans (couple x e0) (prodcart alph q)).

	2: apply coupl2; auto.	

	intro Ht; elim Ht; clear Ht; intros.

	cut (dans x alph /\ dans e0 q).

	2: apply coupl2; auto.	

	intro Ht; elim Ht; clear Ht; intros.

	apply chemin_cons with e0; auto.



	unfold delta_D in |- *.

	intro H5.

	cut

  (exists y : Elt,

     dans y qd /\ couple e1 (couple x e0) = transition_D g0 y :>Elt).

	2: apply dans_map; auto.

	intro Ht; elim Ht; clear Ht; intros y' Ht; elim Ht; clear Ht; intros.

	unfold transition_D in H7.

	cut (e1 = g0 :>Elt /\ couple x e0 = couple epsilon y' :>Elt).

	2: apply equal_couple; auto.

	intro Ht; elim Ht; clear Ht; intros.

	cut (x = epsilon :>Elt /\ e0 = y' :>Elt).

	2: apply equal_couple; auto.

	intro Ht; elim Ht; clear Ht; intros.

	absurd (dans x alph); auto.

	rewrite H10.

	red in |- *; intro; apply not_dans_epsilon_alph; assumption.



intros e1 e0 e3 w0 H H1 H2 H3 H4.

cut

 (dans (couple e1 (couple epsilon e0)) d \/

  dans (couple e1 (couple epsilon e0)) (delta_D g0 qd)); 

 auto.

intro Ht; elim Ht; clear Ht.

	intro.

	cut (dans (couple e1 (couple epsilon e0)) (prodcart q (prodcart alph q))).

	2: apply dans_trans with d; auto.

	2: apply automate_def1 with qd qa; auto.

	intro.

	cut (dans e1 q /\ dans (couple epsilon e0) (prodcart alph q)).

	2: apply coupl2; auto.	

	intro Ht; elim Ht; clear Ht; intros.

	cut (dans epsilon alph /\ dans e0 q).

	2: apply coupl2; auto.	

	intro Ht; elim Ht; clear Ht; intros.

	absurd (dans epsilon alph); auto.

	red in |- *; intro; apply not_dans_epsilon_alph; assumption.



	unfold delta_D in |- *.

	intro.

	cut

  (exists y : Elt,

     dans y qd /\ couple e1 (couple epsilon e0) = transition_D g0 y :>Elt).

	2: apply dans_map; auto.

	intro Ht; elim Ht; clear Ht; intros y' Ht; elim Ht; clear Ht; intros.

	unfold transition_D in H6.

	cut (e1 = g0 :>Elt /\ couple epsilon e0 = couple epsilon y' :>Elt).

	2: apply equal_couple; auto.

	intro Ht; elim Ht; clear Ht; intros.

	absurd (dans g0 q); auto.

	rewrite <- H7.

	assumption. 

Qed.



Lemma chemin_A_g0_e2 :

 forall (q qd qa d : Ensf) (g0 e1 e2 : Elt) (w : Word),

 automate q qd qa d ->

 ~ dans g0 q ->

 chemin_A (add g0 q) (union d (delta_D g0 qd)) e1 e2 w ->

 e1 = g0 :>Elt ->

 dans e2 qa ->

 exists e : Elt,

   dans e qd /\ chemin_A (add g0 q) (union d (delta_D g0 qd)) e e2 w.

intros q qd qa d g0 e1 e2 w H_aut H_g0 H.

elim H; clear H.



intros e0 e3 H H0 H1 H2.

absurd (dans g0 q); auto.

rewrite <- H1.

rewrite H0.

apply dans_trans with qa; auto.

apply automate_def3 with qd d; auto.



intros e0 e e3 x w0 H H0 H1 H2 H3 H4 H5.

clear H0.

cut

 (dans (couple e0 (couple x e)) d \/

  dans (couple e0 (couple x e)) (delta_D g0 qd)); auto.

intro Ht; elim Ht; clear Ht.

	intro.

	cut (dans (couple e0 (couple x e)) (prodcart q (prodcart alph q))).

	2: apply dans_trans with d; auto.

	2: apply automate_def1 with qd qa; auto.

	intro.

	cut (dans e0 q /\ dans (couple x e) (prodcart alph q)).

	2: apply coupl2; auto.	

	intro Ht; elim Ht; clear Ht; intros.

	absurd (dans g0 q); auto.

	rewrite <- H4.

	assumption.

	

	unfold delta_D in |- *.

	intro.

	cut

  (exists y : Elt,

     dans y qd /\ couple e0 (couple x e) = transition_D g0 y :>Elt).

	2: apply dans_map; auto.

	intro Ht; elim Ht; clear Ht; intros y' Ht; elim Ht; clear Ht; intros.

	unfold transition_D in H7.

	cut (e0 = g0 :>Elt /\ couple x e = couple epsilon y' :>Elt).

	2: apply equal_couple; auto.

	intro Ht; elim Ht; clear Ht; intros.

	cut (x = epsilon :>Elt /\ e = y' :>Elt).

	2: apply equal_couple; auto.

	intro Ht; elim Ht; clear Ht; intros.

	absurd (dans x alph); auto.

	rewrite H10.

	red in |- *; intro; apply not_dans_epsilon_alph; assumption.



intros e0 e e3 w0 H H0 H1 H2 H3 H4.

clear H0.

exists e.

split.

2: assumption.

cut

 (dans (couple e0 (couple epsilon e)) d \/

  dans (couple e0 (couple epsilon e)) (delta_D g0 qd)); 

 auto.

intro Ht; elim Ht; clear Ht.

	intro.

	cut (dans (couple e0 (couple epsilon e)) (prodcart q (prodcart alph q))).

	2: apply dans_trans with d; auto.

	2: apply automate_def1 with qd qa; auto.

	intro.

	cut (dans e0 q /\ dans (couple epsilon e) (prodcart alph q)).

	2: apply coupl2; auto.	

	intro Ht; elim Ht; clear Ht; intros.

	cut (dans epsilon alph /\ dans e q).

	2: apply coupl2; auto.	

	intro Ht; elim Ht; clear Ht; intros.

	absurd (dans epsilon alph); auto.

	red in |- *; intro; apply not_dans_epsilon_alph; assumption.

	

	unfold delta_D in |- *.

	intro.

	cut

  (exists y : Elt,

     dans y qd /\ couple e0 (couple epsilon e) = transition_D g0 y :>Elt).

	2: apply dans_map; auto.

	intro Ht; elim Ht; clear Ht; intros y' Ht; elim Ht; clear Ht; intros.

	unfold transition_D in H6.

	cut (e0 = g0 :>Elt /\ couple epsilon e = couple epsilon y' :>Elt).

	2: apply equal_couple; auto.

	intro Ht; elim Ht; clear Ht; intros.

	cut (epsilon = epsilon :>Elt /\ e = y' :>Elt).

	2: apply equal_couple; auto.

	intro Ht; elim Ht; clear Ht; intros.

	rewrite H10.

	assumption.

Qed.



Lemma chemin_A_e1_g0_abs :

 forall (q qd qa d : Ensf) (g0 e e2 : Elt) (w : Word),

 automate q qd qa d ->

 dans e q ->

 ~ dans g0 q ->

 e2 = g0 :>Elt -> ~ chemin_A (add g0 q) (union d (delta_D g0 qd)) e e2 w.

intros q qd qa d g0 e e2 w H_aut H H0 H1.

red in |- *; intro.

cut (dans e q); auto.

cut (e2 = g0 :>Elt); auto.

elim H2.



intros e1 e0 H3 H4 H5 H6.

absurd (dans g0 q); auto.

rewrite <- H5.

rewrite <- H4; assumption.



intros e1 e0 e3 x w0 H3 H4 H5 H6 H7 H8 H9.

apply H4; auto.

cut

 (dans (couple e1 (couple x e0)) d \/

  dans (couple e1 (couple x e0)) (delta_D g0 qd)); 

 auto.

intro Ht; elim Ht; clear Ht.



	intro.

	cut (dans (couple e1 (couple x e0)) (prodcart q (prodcart alph q))).

	2: apply dans_trans with d; auto.

	2: apply automate_def1 with qd qa; auto.

	intro.	

	cut (dans e1 q /\ dans (couple x e0) (prodcart alph q)).

	2: apply coupl2; auto.

	intro Ht; elim Ht; clear Ht; intros.

	cut (dans x alph /\ dans e0 q).

	2: apply coupl2; auto.

	intro Ht; elim Ht; clear Ht; intros.

	assumption.

	

	unfold delta_D in |- *.

	intro.

	cut

  (exists y : Elt,

     dans y qd /\ couple e1 (couple x e0) = transition_D g0 y :>Elt).

	2: apply dans_map; auto.

	intro Ht; elim Ht; clear Ht; intros y' Ht; elim Ht; clear Ht; intros.

	unfold transition_D in H12.

	cut (e1 = g0 :>Elt /\ couple x e0 = couple epsilon y' :>Elt).

	2: apply equal_couple; auto.

	intro Ht; elim Ht; clear Ht; intros.

	absurd (dans e1 q); auto.

	rewrite H13; auto.



intros e1 e0 e3 w0 H3 H4 H5 H6 H7 H8.

apply H4; auto.

cut

 (dans (couple e1 (couple epsilon e0)) d \/

  dans (couple e1 (couple epsilon e0)) (delta_D g0 qd)); 

 auto.

intro Ht; elim Ht; clear Ht.



	intro.

	cut (dans (couple e1 (couple epsilon e0)) (prodcart q (prodcart alph q))).

	2: apply dans_trans with d; auto.

	2: apply automate_def1 with qd qa; auto.

	intro.	

	cut (dans e1 q /\ dans (couple epsilon e0) (prodcart alph q)).

	2: apply coupl2; auto.

	intro Ht; elim Ht; clear Ht; intros.

	cut (dans epsilon alph /\ dans e0 q).

	2: apply coupl2; auto.

	intro Ht; elim Ht; clear Ht; intros.

	absurd (dans epsilon alph); auto.

	

	unfold delta_D in |- *.

	intro.

	cut

  (exists y : Elt,

     dans y qd /\ couple e1 (couple epsilon e0) = transition_D g0 y :>Elt).

	2: apply dans_map; auto.

	intro Ht; elim Ht; clear Ht; intros y' Ht; elim Ht; clear Ht; intros.

	unfold transition_D in H11.

	cut (e1 = g0 :>Elt /\ couple epsilon e0 = couple epsilon y' :>Elt).

	2: apply equal_couple; auto.

	intro Ht; elim Ht; clear Ht; intros.

	absurd (dans e1 q); auto.

	rewrite H12; auto.

Qed.



Lemma chemin_A_e1_g0 :

 forall (q qd qa d : Ensf) (g0 e1 e2 : Elt) (w : Word),

 automate q qd qa d ->

 ~ dans g0 q ->

 chemin_A (add g0 q) (union d (delta_D g0 qd)) e1 e2 w ->

 e2 = g0 :>Elt -> w = nil :>Word.

intros q qd qa d g0 e1 e2 w H_aut H_g0 H.

elim H; auto.

intros e0 e e3 x w0 H0 H1 H2 H3 H4 H5.

absurd (chemin_A (add g0 q) (union d (delta_D g0 qd)) e g0 w0).

2: cut (chemin_A (add g0 q) (union d (delta_D g0 qd)) e e3 w0); auto.

2: rewrite H5; auto.

apply chemin_A_e1_g0_abs with qa; auto.

cut

 (dans (couple e0 (couple x e)) d \/

  dans (couple e0 (couple x e)) (delta_D g0 qd)); auto.

intro Ht; elim Ht; clear Ht.



intro.

cut (dans (couple e0 (couple x e)) (prodcart q (prodcart alph q))).

2: apply dans_trans with d; auto.

2: apply automate_def1 with qd qa; auto.

intro.

cut (dans e0 q /\ dans (couple x e) (prodcart alph q)).

2: apply coupl2; auto.

intro Ht; elim Ht; clear Ht; intros.

cut (dans x alph /\ dans e q).

2: apply coupl2; auto.

intro Ht; elim Ht; clear Ht; intros.

assumption.



unfold delta_D in |- *. 

intro.

cut

 (exists y : Elt,

    dans y qd /\ couple e0 (couple x e) = transition_D g0 y :>Elt).

2: apply dans_map; auto.

intro Ht; elim Ht; clear Ht; intros y' Ht; elim Ht; clear Ht; intros.

unfold transition_D in H8.

cut (e0 = g0 :>Elt /\ couple x e = couple epsilon y' :>Elt).

2: apply equal_couple; auto.

intro Ht; elim Ht; clear Ht; intros.

cut (x = epsilon :>Elt /\ e = y' :>Elt).

2: apply equal_couple; auto.

intro Ht; elim Ht; clear Ht; intros.

absurd (dans x alph); auto.

rewrite H11.

red in |- *; intro; apply not_dans_epsilon_alph; assumption.

Qed.



Lemma isregular_isregular_D_1 :

 forall (q qd qa d : Ensf) (g0 : Elt),

 automate q qd qa d ->

 ~ dans g0 q ->

 eqwordset (reconnait q qd qa d)

   (reconnait_A (add g0 q) (singleton g0) qa (union d (delta_D g0 qd))) /\

 (forall w : Word,

  chemin_A (add g0 q) (union d (delta_D g0 qd)) g0 g0 w -> w = nil :>Word).

intros.

split.

unfold eqwordset in |- *.

intro w.

split.

	unfold reconnait in |- *.

	intro Ht; elim Ht; clear Ht; intros H1 Ht; elim Ht; clear Ht; intros e1 Ht;

  elim Ht; clear Ht; intros e2 Ht; elim Ht; clear Ht; 

  intros H2 Ht; elim Ht; clear Ht; intros.

	unfold reconnait_A in |- *.

	split.

	assumption.

	exists g0.

	exists e2.

	split; [ auto | split ].

	assumption.

	apply chemin_A_epsilon with e1; auto.

	apply chemin_A_d1_d2 with d; auto.

	apply chemin_A_q1_q2 with q; auto.

	apply chemin_chemin_A; auto.

	apply union_d.

	unfold delta_D in |- *.

	replace (couple g0 (couple epsilon e1)) with (transition_D g0 e1);

  auto.



	unfold reconnait_A in |- *.

	intro Ht; elim Ht; clear Ht; intros H1 Ht; elim Ht; clear Ht; intros e1 Ht;

  elim Ht; clear Ht; intros e2 Ht; elim Ht; clear Ht; 

  intros H2 Ht; elim Ht; clear Ht; intros.

	unfold reconnait in |- *.

	split.

	assumption.

	cut (e1 = g0 :>Elt); auto.

	intro.

	cut

  (exists e : Elt,

     dans e qd /\ chemin_A (add g0 q) (union d (delta_D g0 qd)) e e2 w).

	2: apply chemin_A_g0_e2 with qa e1; auto.

	intro Ht; elim Ht; clear Ht; intros e Ht; elim Ht; clear Ht; intros.

	exists e.

	exists e2.

	split; [ assumption | split ].

	assumption.

	apply chemin_D_chemin with qd qa g0; auto.

	apply dans_trans with qd; auto.

	apply automate_def2 with qa d; auto.



intros.

apply chemin_A_e1_g0 with q qd qa d g0 g0 g0; auto.

Qed.



Lemma isregular_isregular_D :

 forall l : wordset, isregular l -> isregular_D l.

intro l.

unfold isregular at 1 in |- *.

intro Ht; elim Ht; clear Ht; intros q Ht; elim Ht; clear Ht; intros qd Ht;

 elim Ht; clear Ht; intros qa Ht; elim Ht; clear Ht; 

 intros d Ht; elim Ht; clear Ht; intros.

cut (exists g0 : Elt, ~ dans g0 q).

2: apply exist_other.

intro Ht; elim Ht; clear Ht; intros g0 H1.



cut (automate_A (add g0 q) (singleton g0) qa (union d (delta_D g0 qd))).

2: apply automate_A_D; auto.

intro.

unfold isregular_D in |- *.

exists (add g0 q).

exists g0.

exists (sync_qa (add g0 q) qa (union d (delta_D g0 qd))).

exists (sync_d (add g0 q) (union d (delta_D g0 qd))).

split.

apply automateA_automate; auto.

cut

 (eqwordset (reconnait q qd qa d)

    (reconnait_A (add g0 q) (singleton g0) qa (union d (delta_D g0 qd))) /\

  (forall w : Word,

   chemin_A (add g0 q) (union d (delta_D g0 qd)) g0 g0 w -> w = nil :>Word)). 

2: apply isregular_isregular_D_1; auto.

intro Ht; elim Ht; clear Ht; intros.

split.



	intros w H5.

	cut (chemin_A (add g0 q) (union d (delta_D g0 qd)) g0 g0 w).

	2: apply chemin_cheminA with (singleton g0) qa; auto.

	intro.

	apply (H4 w); auto.



	apply

  eqwordset_trans

   with (reconnait_A (add g0 q) (singleton g0) qa (union d (delta_D g0 qd))).

	unfold eqwordset in |- *.

	intro w.

	split.

	intro.

	apply reconnait_reconnaitA; auto.

	intro.

	apply reconnaitA_reconnait; auto.

	apply eqwordset_trans with (reconnait q qd qa d); auto.

	apply eqwordset_sym; assumption.

Qed.
