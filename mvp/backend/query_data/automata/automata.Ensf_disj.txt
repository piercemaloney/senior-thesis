
Require Import Ensf_types.
(* Ensf_types:
Inductive Ensf : Set :=
  | empty : Ensf
  | add : Elt -> Ensf -> Ensf
with Elt : Set :=
  | natural : nat -> Elt
  | couple : Elt -> Elt -> Elt
  | up : Ensf -> Elt
  | word : Word -> Elt
with Word : Set :=
  | nil : Word
  | cons : Elt -> Word -> Word.

Definition natural_inv (e : Elt) : nat :=
  match e with
  | natural n => n
  | _ => 0
  end.

Lemma nat_invol : forall n : nat, natural_inv (natural n) = n.

Definition word_inv (e : Elt) : Word :=
  match e with
  | word w => w
  | _ => nil
  end.

Lemma add_add :
 forall (a b : Elt) (c d : Ensf), a = b -> c = d -> add a c = add b d.
Hint Resolve add_add.

Lemma couple_couple :
 forall a b c d : Elt, a = b -> c = d -> couple a c = couple b d.

Lemma word_word : forall a b : Word, a = b -> word a = word b.
Hint Resolve word_word.
 
Lemma word_word_inv : forall a b : Word, word a = word b -> a = b.

Definition zero : Elt := natural 0.
Definition un : Elt := natural 1.
Definition singleton (e : Elt) : Ensf := add e empty.

Lemma False_imp_P : forall P : Prop, False -> P.

Lemma equal_add : forall (a b : Ensf) (e : Elt), a = b -> add e a = add e b. *)
Require Import Ensf_dans.
(* Ensf_dans:
Require Import Ensf_types.

Inductive dans : Elt -> Ensf -> Prop :=
  | dans_add1 : forall (x : Elt) (e : Ensf), dans x (add x e)
  | dans_add2 : forall (x y : Elt) (e : Ensf), dans x e -> dans x (add y e).
Hint Resolve dans_add1 dans_add2.
 
Lemma dans_add :
 forall (x y : Elt) (e : Ensf), dans x (add y e) -> y = x \/ dans x e.
 
Lemma dans_add_contr :
 forall (x y : Elt) (e : Ensf), y <> x -> ~ dans x e -> ~ dans x (add y e).
 
Lemma empty_empty : forall E : Elt, ~ dans E empty.
Hint Resolve empty_empty.
 
Lemma dans_empty_imp_P : forall (x : Elt) (P : Prop), dans x empty -> P.
 
Lemma singl2 : forall x : Elt, dans x (singleton x).
Hint Resolve singl2.

Unset Structural Injection.

Lemma singl2_inv : forall x e : Elt, dans x (singleton e) -> x = e :>Elt.
Hint Resolve singl2_inv. *)
Require Import Ensf_union.
(* Ensf_union:
Require Import Ensf_types.
Require Import Ensf_dans.

Fixpoint union (A : Ensf) : Ensf -> Ensf :=
  fun B : Ensf =>
  match A return Ensf with
  | empty =>
        B
       
  | add x e => add x (union e B)
  end.

Lemma union_a_empty : forall a : Ensf, a = union a empty :>Ensf.
Hint Resolve union_a_empty.

Lemma dans_union :
 forall (x : Elt) (a b : Ensf), dans x (union a b) -> dans x a \/ dans x b.
Hint Resolve dans_union.

Lemma union_g : forall (x : Elt) (a b : Ensf), dans x a -> dans x (union a b).
Hint Resolve union_g.

Lemma union_d : forall (x : Elt) (a b : Ensf), dans x b -> dans x (union a b).
Hint Resolve union_d.

Lemma dans_union_inv :
 forall (x : Elt) (a b : Ensf), dans x a \/ dans x b -> dans x (union a b). *)
Require Import Ensf_couple.
(* Ensf_couple:
Require Import Ensf_types.

Definition first (x : Elt) : Elt :=
  match x return Elt with
  | natural n =>
        zero
       
  | couple a b => a
       
  | up e => zero
       
  | word w => zero
  end.

Definition second (x : Elt) : Elt :=
  match x return Elt with
  | natural n =>
        zero
       
  | couple a b => b
       
  | up e => zero
       
  | word w => zero
  end.

Lemma equal_couple :
 forall x y z t : Elt,
 couple x y = couple z t :>Elt -> x = z :>Elt /\ y = t :>Elt.

Lemma couple_couple_inv1 :
 forall a b c d : Elt, couple a c = couple b d :>Elt -> a = b :>Elt.
 
Lemma couple_couple_inv2 :
 forall a b c d : Elt, couple a c = couple b d :>Elt -> c = d :>Elt. *)
Require Import Ensf_inclus.
(* Ensf_inclus:
Require Import Ensf_types.

Require Import Ensf_dans.
Require Import Ensf_union.
Require Import Ensf_produit.

Definition inclus (A B : Ensf) : Prop := forall x : Elt, dans x A -> dans x B.

Hint Unfold inclus.

Lemma empty_inclus : forall x : Ensf, inclus empty x.
Hint Resolve empty_inclus.

Lemma refl_inclus : forall x : Ensf, inclus x x.
Hint Resolve refl_inclus.

Lemma inclus_trans :
 forall a b c : Ensf, inclus a b -> inclus b c -> inclus a c.

Lemma cart_inclus :
 forall a b c d : Ensf,
 inclus a b -> inclus c d -> inclus (prodcart a c) (prodcart b d).
Hint Resolve cart_inclus.

Lemma inclus_add :
 forall (a b : Ensf) (y : Elt), inclus a b -> inclus a (add y b).
Hint Resolve inclus_add.

Lemma singl_inclus_add :
 forall (e : Elt) (a : Ensf), inclus (singleton e) (add e a).
Hint Resolve singl_inclus_add.

Lemma inclus_singl :
 forall (e : Elt) (a : Ensf), inclus (singleton e) a -> dans e a.

Lemma add_inclus :
 forall (x : Elt) (a b : Ensf), dans x b -> inclus a b -> inclus (add x a) b.
Hint Resolve add_inclus.

Lemma dans_trans :
 forall (x : Elt) (a b : Ensf), dans x a -> inclus a b -> dans x b.

Lemma union_inclus :
 forall a b c : Ensf, inclus a c -> inclus b c -> inclus (union a b) c.
Hint Resolve union_inclus.

Lemma inclus_g : forall a b : Ensf, inclus a (union a b).

Lemma inclus_d : forall a b : Ensf, inclus b (union a b).

Lemma inclus_g2 : forall A B C : Ensf, inclus A B -> inclus A (union B C).
Hint Resolve inclus_g2.

Lemma inclus_d2 : forall A B C : Ensf, inclus A C -> inclus A (union B C).
Hint Resolve inclus_d2. *)
Require Import Ensf_map.
(* Ensf_map:
Require Import Ensf_types.
Require Import Ensf_dans.
Require Import Ensf_union.
Require Import Ensf_inclus.

Fixpoint map (f : Elt -> Elt) (e : Ensf) {struct e} : Ensf :=
  match e with
  | empty => empty
  | add y e => add (f y) (map f e)
  end.

Lemma dans_map :
 forall (f : Elt -> Elt) (a : Ensf) (x : Elt),
 dans x (map f a) -> exists y : Elt, dans y a /\ x = f y.
Hint Resolve dans_map.

Lemma dans_map_inv :
 forall (f : Elt -> Elt) (x : Elt) (a : Ensf),
 dans x a -> dans (f x) (map f a).
Hint Resolve dans_map_inv.

Lemma map_union :
 forall (f : Elt -> Elt) (a b : Ensf),
 union (map f a) (map f b) = map f (union a b) :>Ensf.
Hint Resolve map_union.

Lemma dans_map_trans :
 forall (x : Elt) (f : Elt -> Elt) (a b : Ensf),
 dans x (map f a) -> inclus a b -> dans x (map f b).

Lemma map_egal :
 forall (f g : Elt -> Elt) (E : Ensf),
 (forall x : Elt, dans x E -> f x = g x :>Elt) -> map f E = map g E :>Ensf.

Lemma map_inclus :
 forall (a b : Ensf) (f : Elt -> Elt),
 inclus a b -> inclus (map f a) (map f b). *)

Definition injgauche (e : Elt) : Elt := couple e zero.

Definition injdroite (e : Elt) : Elt := couple e un.

Definition union_disj (e f : Ensf) : Ensf :=
  union (map injgauche e) (map injdroite f).

Lemma dans_map_injg :
 forall (e : Ensf) (x : Elt), dans x (map injgauche e) -> dans (first x) e.
intros.
cut (exists y : Elt, dans y e /\ x = injgauche y).
2: apply dans_map; auto.
intro Ht; elim Ht; clear Ht.
intros y Ht; elim Ht; clear Ht.
intros.  
unfold injgauche in H1.
replace (first x) with y; auto.
symmetry  in |- *.
replace y with (first (couple y zero)); auto.
apply (f_equal (A:=Elt) (B:=Elt)); auto.
Qed.

Lemma dans_map_injd :
 forall (e : Ensf) (x : Elt), dans x (map injdroite e) -> dans (first x) e.
intros.
cut (exists y : Elt, dans y e /\ x = injdroite y).
2: apply dans_map; auto.
intro Ht; elim Ht; clear Ht.
intros y Ht; elim Ht; clear Ht.
intros.  
unfold injdroite in H1.
replace (first x) with y; auto.
symmetry  in |- *.
replace y with (first (couple y un)); auto.
apply (f_equal (A:=Elt) (B:=Elt)); auto.
Qed.

Lemma absurd_injg_injd :
 forall (x : Elt) (e f : Ensf),
 dans x (map injgauche e) -> ~ dans x (map injdroite f).
intros.
cut (exists y : Elt, dans y e /\ x = injgauche y).
2: apply dans_map; auto.
intro Ht; elim Ht; clear Ht.
intros y Ht; elim Ht; clear Ht.
intros.  
red in |- *.
intro.
cut (exists y' : Elt, dans y' f /\ x = injdroite y' :>Elt).
2: apply dans_map; auto.
intro Ht; elim Ht; clear Ht.
intros y' Ht; elim Ht; clear Ht.
intros.  
absurd (zero = un :>Elt).
unfold zero in |- *.
unfold un in |- *.
discriminate.

unfold injdroite in H4.
unfold injgauche in H1.
replace zero with (second (couple y zero)); auto.
replace un with (second (couple y' un)); auto.
rewrite <- H4.
rewrite <- H1.
auto.
Qed.

Lemma union_disj1 :
 forall (x : Elt) (a b : Ensf),
 dans x (union_disj a b) ->
 (exists y : Elt, dans y a /\ x = injgauche y :>Elt) \/
 (exists y : Elt, dans y b /\ x = injdroite y :>Elt).
unfold union_disj in |- *.
intros.
cut (dans x (map injgauche a) \/ dans x (map injdroite b)).
2: auto.
intro H0; elim H0; clear H0.
intro; left.
apply dans_map; auto.
intro; right.
apply dans_map; auto.
Qed.

Lemma union_disj_d :
 forall (x : Elt) (a b : Ensf),
 dans x b -> dans (injdroite x) (union_disj a b).
intros.
unfold union_disj in |- *.
apply union_d.
apply dans_map_inv.
auto.
Qed.

Lemma union_disj_g :
 forall (x : Elt) (a b : Ensf),
 dans x a -> dans (injgauche x) (union_disj a b).
intros.
unfold union_disj in |- *.
apply union_g.
apply dans_map_inv.
auto.
Qed.

Lemma inclus_union_disj :
 forall a b c d : Ensf,
 inclus a c -> inclus b d -> inclus (union_disj a b) (union_disj c d).
unfold inclus in |- *.
intros.
unfold union_disj in H1.
cut (dans x (map injgauche a) \/ dans x (map injdroite b)); auto.
intro Ht; elim Ht; clear Ht.

intro.
cut (exists y : Elt, dans y a /\ x = injgauche y).
2: apply dans_map; auto.
intro Ht; elim Ht; clear Ht.
intros y Ht; elim Ht; clear Ht; intros H3 H4.
cut (dans y c); auto.
intro.
unfold union_disj in |- *.
apply union_g.
rewrite H4.
apply dans_map_inv; auto.

intro.
cut (exists y : Elt, dans y b /\ x = injdroite y :>Elt).
2: apply dans_map; auto.
intro Ht; elim Ht; clear Ht.
intros y Ht; elim Ht; clear Ht; intros H3 H4.
cut (dans y d); auto.
intro.
unfold union_disj in |- *.
apply union_d.
rewrite H4.
apply dans_map_inv; auto.
Qed.

Lemma pair_equal :
 forall (A B : Set) (x x' : A) (y y' : B),
 x = x' :>A -> y = y' :>B -> pair x y = pair x' y' :>A * B.
intros A B x x' y y' X Y.
rewrite X.
rewrite Y.
apply refl_equal.
Qed.
Hint Resolve pair_equal.