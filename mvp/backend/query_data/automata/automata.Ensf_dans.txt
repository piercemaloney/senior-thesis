

Require Import Ensf_types.
(* Ensf_types:
Inductive Ensf : Set :=
  | empty : Ensf
  | add : Elt -> Ensf -> Ensf
with Elt : Set :=
  | natural : nat -> Elt
  | couple : Elt -> Elt -> Elt
  | up : Ensf -> Elt
  | word : Word -> Elt
with Word : Set :=
  | nil : Word
  | cons : Elt -> Word -> Word.

Definition natural_inv (e : Elt) : nat :=
  match e with
  | natural n => n
  | _ => 0
  end.

Lemma nat_invol : forall n : nat, natural_inv (natural n) = n.

Definition word_inv (e : Elt) : Word :=
  match e with
  | word w => w
  | _ => nil
  end.

Lemma add_add :
 forall (a b : Elt) (c d : Ensf), a = b -> c = d -> add a c = add b d.
Hint Resolve add_add.

Lemma couple_couple :
 forall a b c d : Elt, a = b -> c = d -> couple a c = couple b d.

Lemma word_word : forall a b : Word, a = b -> word a = word b.
Hint Resolve word_word.
 
Lemma word_word_inv : forall a b : Word, word a = word b -> a = b.

Definition zero : Elt := natural 0.
Definition un : Elt := natural 1.
Definition singleton (e : Elt) : Ensf := add e empty.

Lemma False_imp_P : forall P : Prop, False -> P.

Lemma equal_add : forall (a b : Ensf) (e : Elt), a = b -> add e a = add e b. *)



Inductive dans : Elt -> Ensf -> Prop :=

  | dans_add1 : forall (x : Elt) (e : Ensf), dans x (add x e)

  | dans_add2 : forall (x y : Elt) (e : Ensf), dans x e -> dans x (add y e).

Hint Resolve dans_add1 dans_add2.

 

Lemma dans_add :

 forall (x y : Elt) (e : Ensf), dans x (add y e) -> y = x \/ dans x e.

intros x y e H.

simple inversion H.

left.

injection H1.

intros.

apply trans_equal with x0; [ auto | assumption ].



intro.

right.

injection H2.

intros.

rewrite <- H3.

rewrite <- H1.

assumption.

Qed. 

 

Lemma dans_add_contr :

 forall (x y : Elt) (e : Ensf), y <> x -> ~ dans x e -> ~ dans x (add y e).

intros; red in |- *; intro.

absurd (y = x \/ dans x e).

2: apply dans_add; auto.

red in |- *.

intro.

elim H2; auto.

Qed.

 

Lemma empty_empty : forall E : Elt, ~ dans E empty.

unfold not in |- *; intros E H.

simple inversion H; [ discriminate H1 | discriminate H2 ].

Qed.

Hint Resolve empty_empty.

 

Lemma dans_empty_imp_P : forall (x : Elt) (P : Prop), dans x empty -> P.

intros.

elimtype False.

cut (~ dans x empty); auto.

Qed.

 

Lemma singl2 : forall x : Elt, dans x (singleton x).

unfold singleton in |- *.

auto.

Qed.

Hint Resolve singl2.



Unset Structural Injection.



Lemma singl2_inv : forall x e : Elt, dans x (singleton e) -> x = e :>Elt.

unfold singleton in |- *.

intros x e H.

simple inversion H.

injection H1; intros.

rewrite <- H0; assumption.

injection H2; intros.

apply dans_empty_imp_P with x0.

rewrite <- H0; assumption.

Qed.

Hint Resolve singl2_inv.

