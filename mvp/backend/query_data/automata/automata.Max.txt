
Require Import Le.
Require Import Lt.
Require Import Ensf.
(* Ensf:
Require Export Ensf_types.

Require Export Ensf_dans.

Require Export Ensf_union.

Require Export Ensf_couple.

Require Export Ensf_produit.

Require Export Ensf_inclus.

Require Export Ensf_inter.

Require Export Ensf_map.

Require Export Ensf_disj. *)
Require Export Arith.Max.

Definition Z (x : Elt) : nat := match x with
                                | natural n => S n
                                | _ => 0
                                end.

Fixpoint sup (e : Ensf) : nat :=
  match e with
  | empty => 0
  | add x f => max (Z x) (sup f)
  end.

Lemma sup_add :
 forall (x : Elt) (e : Ensf), sup (add x e) = max (Z x) (sup e) :>nat.
intros x.
simple induction e; auto.
Qed.
Hint Resolve sup_add.

Lemma elt_not_sym : forall a b : Elt, a <> b :>Elt -> b <> a :>Elt.
auto.
Qed.

Lemma lt_n_Z : forall n : nat, n < Z (natural n).
intro.
replace (Z (natural n)) with (S n); auto.
Qed.

Lemma lt_n_sup : forall (x : Ensf) (n : nat), dans (natural n) x -> n < sup x.
simple induction x.
intros.
absurd (dans (natural n) empty); auto.
intros a b H n H0.
replace (sup (add a b)) with (max (Z a) (sup b)).
2: auto.
cut (n < Z a \/ n < sup b).
intro.
elim H1; auto.
intros; apply lt_le_trans with (Z a); auto with arith.
intros; apply lt_le_trans with (sup b); auto with arith.
cut (a = natural n :>Elt \/ dans (natural n) b).
2: apply dans_add; auto.
intro.
elim H1.
intro; left.
rewrite H2; apply lt_n_Z.
intro; right.
apply H; assumption.
Qed.

Lemma sup_out : forall x : Ensf, ~ dans (natural (sup x)) x.
intro.
red in |- *.
intro.
cut (sup x < sup x).
change (~ sup x < sup x) in |- *.
apply lt_irrefl.
apply lt_n_sup.
assumption.
Qed.

Lemma exist_other : forall e : Ensf, exists x : Elt, ~ dans x e.
intro.
exists (natural (sup e)).
apply sup_out.
Qed.