
Require Import Ensf_types.
(* Ensf_types:
Inductive Ensf : Set :=
  | empty : Ensf
  | add : Elt -> Ensf -> Ensf
with Elt : Set :=
  | natural : nat -> Elt
  | couple : Elt -> Elt -> Elt
  | up : Ensf -> Elt
  | word : Word -> Elt
with Word : Set :=
  | nil : Word
  | cons : Elt -> Word -> Word.

Definition natural_inv (e : Elt) : nat :=
  match e with
  | natural n => n
  | _ => 0
  end.

Lemma nat_invol : forall n : nat, natural_inv (natural n) = n.

Definition word_inv (e : Elt) : Word :=
  match e with
  | word w => w
  | _ => nil
  end.

Lemma add_add :
 forall (a b : Elt) (c d : Ensf), a = b -> c = d -> add a c = add b d.
Hint Resolve add_add.

Lemma couple_couple :
 forall a b c d : Elt, a = b -> c = d -> couple a c = couple b d.

Lemma word_word : forall a b : Word, a = b -> word a = word b.
Hint Resolve word_word.
 
Lemma word_word_inv : forall a b : Word, word a = word b -> a = b.

Definition zero : Elt := natural 0.
Definition un : Elt := natural 1.
Definition singleton (e : Elt) : Ensf := add e empty.

Lemma False_imp_P : forall P : Prop, False -> P.

Lemma equal_add : forall (a b : Ensf) (e : Elt), a = b -> add e a = add e b. *)

Definition first (x : Elt) : Elt :=
  match x return Elt with
  | natural n =>
        zero
       
  | couple a b => a
       
  | up e => zero
       
  | word w => zero
  end.

Definition second (x : Elt) : Elt :=
  match x return Elt with
  | natural n =>
        zero
       
  | couple a b => b
       
  | up e => zero
       
  | word w => zero
  end.

Lemma equal_couple :
 forall x y z t : Elt,
 couple x y = couple z t :>Elt -> x = z :>Elt /\ y = t :>Elt.
intros x y z t H.
injection H; auto.
Qed.

Lemma couple_couple_inv1 :
 forall a b c d : Elt, couple a c = couple b d :>Elt -> a = b :>Elt.
intros a b c d H.
injection H; auto.
Qed.
 
Lemma couple_couple_inv2 :
 forall a b c d : Elt, couple a c = couple b d :>Elt -> c = d :>Elt.
intros a b c d H.
injection H; auto.
Qed.