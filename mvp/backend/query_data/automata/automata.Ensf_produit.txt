

Require Import Ensf_types.
(* Ensf_types:
Inductive Ensf : Set :=
  | empty : Ensf
  | add : Elt -> Ensf -> Ensf
with Elt : Set :=
  | natural : nat -> Elt
  | couple : Elt -> Elt -> Elt
  | up : Ensf -> Elt
  | word : Word -> Elt
with Word : Set :=
  | nil : Word
  | cons : Elt -> Word -> Word.

Definition natural_inv (e : Elt) : nat :=
  match e with
  | natural n => n
  | _ => 0
  end.

Lemma nat_invol : forall n : nat, natural_inv (natural n) = n.

Definition word_inv (e : Elt) : Word :=
  match e with
  | word w => w
  | _ => nil
  end.

Lemma add_add :
 forall (a b : Elt) (c d : Ensf), a = b -> c = d -> add a c = add b d.
Hint Resolve add_add.

Lemma couple_couple :
 forall a b c d : Elt, a = b -> c = d -> couple a c = couple b d.

Lemma word_word : forall a b : Word, a = b -> word a = word b.
Hint Resolve word_word.
 
Lemma word_word_inv : forall a b : Word, word a = word b -> a = b.

Definition zero : Elt := natural 0.
Definition un : Elt := natural 1.
Definition singleton (e : Elt) : Ensf := add e empty.

Lemma False_imp_P : forall P : Prop, False -> P.

Lemma equal_add : forall (a b : Ensf) (e : Elt), a = b -> add e a = add e b. *)

Require Import Ensf_dans.
(* Ensf_dans:
Require Import Ensf_types.

Inductive dans : Elt -> Ensf -> Prop :=
  | dans_add1 : forall (x : Elt) (e : Ensf), dans x (add x e)
  | dans_add2 : forall (x y : Elt) (e : Ensf), dans x e -> dans x (add y e).
Hint Resolve dans_add1 dans_add2.
 
Lemma dans_add :
 forall (x y : Elt) (e : Ensf), dans x (add y e) -> y = x \/ dans x e.
 
Lemma dans_add_contr :
 forall (x y : Elt) (e : Ensf), y <> x -> ~ dans x e -> ~ dans x (add y e).
 
Lemma empty_empty : forall E : Elt, ~ dans E empty.
Hint Resolve empty_empty.
 
Lemma dans_empty_imp_P : forall (x : Elt) (P : Prop), dans x empty -> P.
 
Lemma singl2 : forall x : Elt, dans x (singleton x).
Hint Resolve singl2.

Unset Structural Injection.

Lemma singl2_inv : forall x e : Elt, dans x (singleton e) -> x = e :>Elt.
Hint Resolve singl2_inv. *)

Require Import Ensf_union.
(* Ensf_union:
Require Import Ensf_types.
Require Import Ensf_dans.

Fixpoint union (A : Ensf) : Ensf -> Ensf :=
  fun B : Ensf =>
  match A return Ensf with
  | empty =>
        B
       
  | add x e => add x (union e B)
  end.

Lemma union_a_empty : forall a : Ensf, a = union a empty :>Ensf.
Hint Resolve union_a_empty.

Lemma dans_union :
 forall (x : Elt) (a b : Ensf), dans x (union a b) -> dans x a \/ dans x b.
Hint Resolve dans_union.

Lemma union_g : forall (x : Elt) (a b : Ensf), dans x a -> dans x (union a b).
Hint Resolve union_g.

Lemma union_d : forall (x : Elt) (a b : Ensf), dans x b -> dans x (union a b).
Hint Resolve union_d.

Lemma dans_union_inv :
 forall (x : Elt) (a b : Ensf), dans x a \/ dans x b -> dans x (union a b). *)

Require Import Ensf_couple.
(* Ensf_couple:
Require Import Ensf_types.

Definition first (x : Elt) : Elt :=
  match x return Elt with
  | natural n =>
        zero
       
  | couple a b => a
       
  | up e => zero
       
  | word w => zero
  end.

Definition second (x : Elt) : Elt :=
  match x return Elt with
  | natural n =>
        zero
       
  | couple a b => b
       
  | up e => zero
       
  | word w => zero
  end.

Lemma equal_couple :
 forall x y z t : Elt,
 couple x y = couple z t :>Elt -> x = z :>Elt /\ y = t :>Elt.

Lemma couple_couple_inv1 :
 forall a b c d : Elt, couple a c = couple b d :>Elt -> a = b :>Elt.
 
Lemma couple_couple_inv2 :
 forall a b c d : Elt, couple a c = couple b d :>Elt -> c = d :>Elt. *)



Fixpoint singleprod (x : Elt) (A : Ensf) {struct A} : Ensf :=

  match A with

  | empty => empty

  | add y e => add (couple x y) (singleprod x e)

  end.



Fixpoint prodcart (A : Ensf) : Ensf -> Ensf :=

  fun B : Ensf =>

  match A with

  | empty => empty

  | add x e => union (singleprod x B) (prodcart e B)

  end.



Lemma dans_singleprod :

 forall (x y x0 : Elt) (b : Ensf),

 dans (couple x y) (singleprod x0 b) -> x = x0 :>Elt /\ dans y b.

intros x y x0.

simple induction b.

simpl in |- *.

intro.

apply (dans_empty_imp_P (couple x y)); auto.



intros a b0 H.

simpl in |- *.

intro.

cut (couple x0 a = couple x y :>Elt \/ dans (couple x y) (singleprod x0 b0)).

2: apply dans_add; auto.

intro H1; elim H1; clear H1.

intro H1.

injection H1; intros.

split; auto.

rewrite H2; auto.



intro.

cut (x = x0 :>Elt /\ dans y b0); auto.

intro H2; elim H2; clear H2.

intros.

split; auto.

Qed.



Lemma coupl2 :

 forall (x y : Elt) (a b : Ensf),

 dans (couple x y) (prodcart a b) -> dans x a /\ dans y b.

intros x y.

simple induction a.

intro b.

simpl in |- *.

intro.

apply (dans_empty_imp_P (couple x y)); auto.



intros a0 b H b0.

simpl in |- *.

intro.

cut

 (dans (couple x y) (singleprod a0 b0) \/ dans (couple x y) (prodcart b b0)).

2: apply dans_union; auto.

intro H1; elim H1; clear H1.

intro H1.

cut (x = a0 :>Elt /\ dans y b0).

2: apply dans_singleprod; auto.

intro H2; elim H2; clear H2.

intros.

rewrite H2.

split; auto.

intro.

cut (dans x b /\ dans y b0); auto.

intro H2; elim H2; clear H2.

intros.

split; auto.

Qed.



Lemma dans_single :

 forall (x y : Elt) (a : Ensf),

 dans y a -> dans (couple x y) (singleprod x a).

intros x y.

simple induction a.

intro.

apply (dans_empty_imp_P y); auto.

intros a0 b H H1.

cut (a0 = y :>Elt \/ dans y b).

2: apply dans_add; auto.

intro H2; elim H2; clear H2.

intro.

simpl in |- *.

rewrite H0; auto.

simpl in |- *; auto.

Qed.



Lemma coupl2_inv :

 forall (x y : Elt) (a b : Ensf),

 dans x a -> dans y b -> dans (couple x y) (prodcart a b).

intros x y.

simple induction a.

intros b H.

apply (dans_empty_imp_P x); auto.



intros a0 b H b0 H0.

cut (a0 = x :>Elt \/ dans x b).

2: apply dans_add; auto.

simpl in |- *.

intro H1; elim H1; clear H1.

intros H1 H2.

apply dans_union_inv.

left.

rewrite H1.

apply dans_single; auto.

intros H1 H2.

apply dans_union_inv.

right.

auto.

Qed.

Hint Resolve coupl2_inv.



Lemma dans_singleprod2 :

 forall (x x0 : Elt) (b : Ensf),

 dans x (singleprod x0 b) -> exists y : Elt, x = couple x0 y /\ dans y b.

intros x x0.

simple induction b.

intro.

apply (dans_empty_imp_P x); auto.

intros a b0 H.

simpl in |- *.

intro.

cut (couple x0 a = x :>Elt \/ dans x (singleprod x0 b0)).

2: apply dans_add; auto.

intro H1; elim H1; clear H1.

intro.

exists a; auto.

intro.

cut (exists y : Elt, x = couple x0 y /\ dans y b0); auto.

intro H2; elim H2; clear H2.

intros.

exists x1.

elim H2; clear H2.

intros.

split; auto.

Qed.



Lemma coupl3 :

 forall (a b : Ensf) (x : Elt),

 dans x (prodcart a b) ->

 exists x1 : Elt,

   (exists x2 : Elt, dans x1 a /\ dans x2 b /\ x = couple x1 x2).

simple induction a.

intro b.

simpl in |- *.

intros x H.

apply (dans_empty_imp_P x); auto.



intros a0 b H b0 x.

simpl in |- *.

intro.

cut (dans x (singleprod a0 b0) \/ dans x (prodcart b b0)); auto.

intro H1; elim H1; clear H1.

intro.

cut (exists y : Elt, x = couple a0 y /\ dans y b0).

2: apply dans_singleprod2; auto.

intro H2; elim H2; clear H2.

intros x0 H2.

exists a0.

exists x0.

elim H2; clear H2.

intros.

split; auto.

intro.

cut

 (exists x1 : Elt,

    (exists x2 : Elt, dans x1 b /\ dans x2 b0 /\ x = couple x1 x2));

 auto.

intro H2; elim H2; clear H2.

intros x0 H2; elim H2; clear H2.

intros x1 H2; elim H2; clear H2.

intros H2 H3; elim H3; clear H3.

intros H4 H5.

exists x0.

exists x1.

split; auto.

Qed.
