

Require Import Ensf.
(* Ensf:
Require Export Ensf_types.

Require Export Ensf_dans.

Require Export Ensf_union.

Require Export Ensf_couple.

Require Export Ensf_produit.

Require Export Ensf_inclus.

Require Export Ensf_inter.

Require Export Ensf_map.

Require Export Ensf_disj. *)

Require Import Words.
(* Words:
Require Import Ensf.

Parameter alph : Ensf.
Parameter epsilon : Elt.
  Axiom not_dans_epsilon_alph : ~ dans epsilon alph.

Inductive inmonoid (X : Ensf) : Word -> Prop :=
  | inmonoid_nil : inmonoid X nil
  | inmonoid_cons :
      forall (w : Word) (e : Elt),
      inmonoid X w -> dans e X -> inmonoid X (cons e w).
Hint Resolve inmonoid_nil.
Hint Resolve inmonoid_cons.

Fixpoint Inmonoid (X : Ensf) (w : Word) {struct w} : Prop :=
  match w with
  | nil => True
  | cons a w' => dans a X /\ Inmonoid X w'
  end.

Lemma i_I : forall (X : Ensf) (w : Word), inmonoid X w -> Inmonoid X w.
Hint Resolve i_I.

Lemma I_i : forall (X : Ensf) (w : Word), Inmonoid X w -> inmonoid X w.
Hint Resolve I_i.

Lemma inmonoid_cons_inv :
 forall (X : Ensf) (w : Word) (a : Elt),
 inmonoid X (cons a w) -> inmonoid X w.

Lemma inmonoid_cons_inv2 :
 forall (X : Ensf) (a : Elt) (w : Word), inmonoid X (cons a w) -> dans a X.

Lemma inmonoid_inclus :
 forall (E F : Ensf) (x : Word), inclus E F -> inmonoid E x -> inmonoid F x.

Fixpoint Append (w1 : Word) : Word -> Word :=
  fun w2 : Word =>
  match w1 with
  | nil => w2
  | cons a w3 => cons a (Append w3 w2)
  end.

Lemma Append_w_nil : forall w : Word, Append w nil = w :>Word.

Inductive append : Word -> Word -> Word -> Prop :=
  | append_nil : forall w : Word, append nil w w
  | append_cons :
      forall (w1 w2 w3 : Word) (a : Elt),
      append w1 w2 w3 -> append (cons a w1) w2 (cons a w3).

Lemma Append_inmonoid_g :
 forall (X : Ensf) (w1 w2 : Word), inmonoid X (Append w1 w2) -> inmonoid X w1.

Lemma Append_inmonoid_d :
 forall (X : Ensf) (w1 w2 : Word), inmonoid X (Append w1 w2) -> inmonoid X w2.

Lemma inmonoid_Append :
 forall (X : Ensf) (w1 w2 : Word),
 inmonoid X w1 -> inmonoid X w2 -> inmonoid X (Append w1 w2).

Definition wordset := Word -> Prop.

Definition eqwordset (l1 l2 : wordset) : Prop :=
  forall w : Word, (l1 w -> l2 w) /\ (l2 w -> l1 w).

Lemma eqwordset_refl : forall L : wordset, eqwordset L L.

Lemma eqwordset_sym :
 forall l1 l2 : wordset, eqwordset l1 l2 -> eqwordset l2 l1.

Lemma eqwordset_trans :
 forall l1 l2 l3 : wordset,
 eqwordset l1 l2 -> eqwordset l2 l3 -> eqwordset l1 l3.

Definition islanguage (X : Ensf) (L : wordset) : Prop :=
  forall w : Word, L w -> inmonoid X w.

Fixpoint Word_ext (f : Elt -> Elt) (w : Word) {struct w} : Word :=
  match w with
  | nil => nil
  | cons a w' => cons (f a) (Word_ext f w')
  end.

Lemma inmonoid_map :
 forall (f : Elt -> Elt) (a : Ensf) (w : Word),
 inmonoid a w -> inmonoid (map f a) (Word_ext f w).
Hint Resolve inmonoid_map.

Lemma cons_cons :
 forall (x1 x2 : Elt) (w1 w2 : Word),
 x1 = x2 :>Elt -> w1 = w2 :>Word -> cons x1 w1 = cons x2 w2 :>Word.
Hint Resolve cons_cons.

Definition fun_consaw_a (w : Word) : Elt :=
  match w return Elt with
  | nil =>
        zero
       
  | cons a w' => a
  end.

Definition fun_consaw_w (w : Word) : Word :=
  match w return Word with
  | nil =>
        nil
       
  | cons a w' => w'
  end.

Lemma cons_cons_inv :
 forall (x1 x2 : Elt) (w1 w2 : Word),
 cons x1 w1 = cons x2 w2 -> x1 = x2 /\ w1 = w2.

Hint Resolve cons_cons_inv.

Lemma cons_cons_inv1 :
 forall (x1 x2 : Elt) (w1 w2 : Word),
 cons x1 w1 = cons x2 w2 :>Word -> x1 = x2 :>Elt.

Lemma cons_cons_inv2 :
 forall (x1 x2 : Elt) (w1 w2 : Word), cons x1 w1 = cons x2 w2 -> w1 = w2.

Lemma nil_or_cons :
 forall w : Word,
 w = nil \/ (exists x : Elt, (exists w0 : Word, w = cons x w0)). *)



Definition lword (w : Word) : wordset := fun w1 : Word => w = w1 :>Word.



Definition lconc (l1 l2 : wordset) : wordset :=

  fun w : Word =>

  exists w1 : Word,

    (exists w2 : Word, l1 w1 /\ l2 w2 /\ w = Append w1 w2 :>Word).



Definition lunion (l1 l2 : wordset) : wordset := fun w : Word => l1 w \/ l2 w.



Definition linter (l1 l2 : wordset) : wordset := fun w : Word => l1 w /\ l2 w.



Fixpoint lpuiss (n : nat) : wordset -> wordset :=

  fun l : wordset =>

  match n return wordset with

  | O =>

        lword nil

       

  | S p => lconc l (lpuiss p l)

  end.



Definition lstar (l : wordset) : wordset :=

  fun w : Word => exists n : nat, lpuiss n l w.



Lemma induction_star :

 forall (P : Word -> Prop) (l : wordset),

 (forall (n : nat) (w : Word), lpuiss n l w -> P w) ->

 forall w : Word, lstar l w -> P w.

unfold lstar in |- *.

intros.

elim H0; clear H0.

intros x H0.

apply (H x w); auto.

Qed.



Lemma lw_imp_lstarlw : forall (l : wordset) (w : Word), l w -> lstar l w.

intros.

unfold lstar in |- *.

exists 1.

change (lconc l (lpuiss 0 l) w) in |- *.

unfold lconc in |- *.

exists w.

exists nil.

split; [ assumption | split ]. 

unfold lpuiss in |- *.

unfold lword in |- *; auto.

symmetry  in |- *.

apply Append_w_nil.

Qed.



Inductive isrationnal : wordset -> Prop :=

  | israt_lword : forall w : Word, inmonoid alph w -> isrationnal (lword w)

  | israt_lunion :

      forall l1 l2 : wordset,

      isrationnal l1 -> isrationnal l2 -> isrationnal (lunion l1 l2)

  | israt_conc :

      forall l1 l2 : wordset,

      isrationnal l1 -> isrationnal l2 -> isrationnal (lconc l1 l2)

  | israt_lstar : forall l : wordset, isrationnal l -> isrationnal (lstar l).



