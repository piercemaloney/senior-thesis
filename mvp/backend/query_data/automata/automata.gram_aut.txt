

Require Import Ensf.
(* Ensf:
Require Export Ensf_types.

Require Export Ensf_dans.

Require Export Ensf_union.

Require Export Ensf_couple.

Require Export Ensf_produit.

Require Export Ensf_inclus.

Require Export Ensf_inter.

Require Export Ensf_map.

Require Export Ensf_disj. *)

Require Import Words.
(* Words:
Require Import Ensf.

Parameter alph : Ensf.
Parameter epsilon : Elt.
  Axiom not_dans_epsilon_alph : ~ dans epsilon alph.

Inductive inmonoid (X : Ensf) : Word -> Prop :=
  | inmonoid_nil : inmonoid X nil
  | inmonoid_cons :
      forall (w : Word) (e : Elt),
      inmonoid X w -> dans e X -> inmonoid X (cons e w).
Hint Resolve inmonoid_nil.
Hint Resolve inmonoid_cons.

Fixpoint Inmonoid (X : Ensf) (w : Word) {struct w} : Prop :=
  match w with
  | nil => True
  | cons a w' => dans a X /\ Inmonoid X w'
  end.

Lemma i_I : forall (X : Ensf) (w : Word), inmonoid X w -> Inmonoid X w.
Hint Resolve i_I.

Lemma I_i : forall (X : Ensf) (w : Word), Inmonoid X w -> inmonoid X w.
Hint Resolve I_i.

Lemma inmonoid_cons_inv :
 forall (X : Ensf) (w : Word) (a : Elt),
 inmonoid X (cons a w) -> inmonoid X w.

Lemma inmonoid_cons_inv2 :
 forall (X : Ensf) (a : Elt) (w : Word), inmonoid X (cons a w) -> dans a X.

Lemma inmonoid_inclus :
 forall (E F : Ensf) (x : Word), inclus E F -> inmonoid E x -> inmonoid F x.

Fixpoint Append (w1 : Word) : Word -> Word :=
  fun w2 : Word =>
  match w1 with
  | nil => w2
  | cons a w3 => cons a (Append w3 w2)
  end.

Lemma Append_w_nil : forall w : Word, Append w nil = w :>Word.

Inductive append : Word -> Word -> Word -> Prop :=
  | append_nil : forall w : Word, append nil w w
  | append_cons :
      forall (w1 w2 w3 : Word) (a : Elt),
      append w1 w2 w3 -> append (cons a w1) w2 (cons a w3).

Lemma Append_inmonoid_g :
 forall (X : Ensf) (w1 w2 : Word), inmonoid X (Append w1 w2) -> inmonoid X w1.

Lemma Append_inmonoid_d :
 forall (X : Ensf) (w1 w2 : Word), inmonoid X (Append w1 w2) -> inmonoid X w2.

Lemma inmonoid_Append :
 forall (X : Ensf) (w1 w2 : Word),
 inmonoid X w1 -> inmonoid X w2 -> inmonoid X (Append w1 w2).

Definition wordset := Word -> Prop.

Definition eqwordset (l1 l2 : wordset) : Prop :=
  forall w : Word, (l1 w -> l2 w) /\ (l2 w -> l1 w).

Lemma eqwordset_refl : forall L : wordset, eqwordset L L.

Lemma eqwordset_sym :
 forall l1 l2 : wordset, eqwordset l1 l2 -> eqwordset l2 l1.

Lemma eqwordset_trans :
 forall l1 l2 l3 : wordset,
 eqwordset l1 l2 -> eqwordset l2 l3 -> eqwordset l1 l3.

Definition islanguage (X : Ensf) (L : wordset) : Prop :=
  forall w : Word, L w -> inmonoid X w.

Fixpoint Word_ext (f : Elt -> Elt) (w : Word) {struct w} : Word :=
  match w with
  | nil => nil
  | cons a w' => cons (f a) (Word_ext f w')
  end.

Lemma inmonoid_map :
 forall (f : Elt -> Elt) (a : Ensf) (w : Word),
 inmonoid a w -> inmonoid (map f a) (Word_ext f w).
Hint Resolve inmonoid_map.

Lemma cons_cons :
 forall (x1 x2 : Elt) (w1 w2 : Word),
 x1 = x2 :>Elt -> w1 = w2 :>Word -> cons x1 w1 = cons x2 w2 :>Word.
Hint Resolve cons_cons.

Definition fun_consaw_a (w : Word) : Elt :=
  match w return Elt with
  | nil =>
        zero
       
  | cons a w' => a
  end.

Definition fun_consaw_w (w : Word) : Word :=
  match w return Word with
  | nil =>
        nil
       
  | cons a w' => w'
  end.

Lemma cons_cons_inv :
 forall (x1 x2 : Elt) (w1 w2 : Word),
 cons x1 w1 = cons x2 w2 -> x1 = x2 /\ w1 = w2.

Hint Resolve cons_cons_inv.

Lemma cons_cons_inv1 :
 forall (x1 x2 : Elt) (w1 w2 : Word),
 cons x1 w1 = cons x2 w2 :>Word -> x1 = x2 :>Elt.

Lemma cons_cons_inv2 :
 forall (x1 x2 : Elt) (w1 w2 : Word), cons x1 w1 = cons x2 w2 -> w1 = w2.

Lemma nil_or_cons :
 forall w : Word,
 w = nil \/ (exists x : Elt, (exists w0 : Word, w = cons x w0)). *)

Require Import more_words.
(* more_words:
Require Import Ensf.
Require Import Words.

Hint Unfold eqwordset .

Definition l_inclus (l1 l2 : wordset) : Prop := forall w : Word, l1 w -> l2 w.

Hint Unfold l_inclus.

Lemma refl_l_inclus : forall l1 : wordset, l_inclus l1 l1.
Hint Resolve refl_l_inclus.

Lemma trans_l_inclus :
 forall l1 l2 l3 : wordset,
 l_inclus l1 l2 -> l_inclus l2 l3 -> l_inclus l1 l3.

Definition l_egal (l1 l2 : wordset) : Prop :=
  l_inclus l1 l2 /\ l_inclus l2 l1.

Hint Unfold l_egal.

Lemma equiv_l_egal_eqwordset :
 forall a b : wordset, l_egal a b <-> eqwordset a b.

Lemma refl_l_egal : forall l1 : wordset, l_egal l1 l1.
Hint Resolve refl_l_egal.

Section more_about_words.

Variable f : Elt -> Elt. 

Let wef := Word_ext f.

Lemma wef_append :
 forall u v : Word, wef (Append u v) = Append (wef u) (wef v).

Lemma wef_nil : forall a : Word, wef a = nil -> a = nil.

Lemma wef_cons :
 forall (a b : Word) (e : Elt),
 cons e a = wef b ->
 exists x : Elt,
   ex2 (fun w : Word => cons x w = b) (fun w : Word => f x = e /\ wef w = a).

End more_about_words.

Hint Resolve wef_cons.

Lemma Append_assoc :
 forall a b c : Word, Append a (Append b c) = Append (Append a b) c.
Hint Resolve Append_assoc. *)

Require Import need.
(* need:
Require Import Ensf.
Require Import Words.
Require Import more_words.

Axiom Dans_spec : forall (a : Elt) (E : Ensf), {dans a E} + {~ dans a E}.

Definition Dans (a : Elt) (E : Ensf) :=
  match Dans_spec a E return bool with
  | left a => true
  | right a => false
  end.

Axiom
  Append_Append :
    forall a a' b b' : Word,
    Append a b = Append a' b' ->
    exists w : Word,
      a = Append a' w /\ b' = Append w b \/
      a' = Append a w /\ b = Append w b'.

Axiom
  inmonoid_Append_inv2 :
    forall (X : Ensf) (a b : Word), inmonoid X (Append a b) -> inmonoid X b.

Hint Resolve dans_add. *)

Require Import Relations.
(* Relations:
Section Relations.

  Variable A : Set.  
  Variable R : A -> A -> Prop.  

Definition Rstar (x y : A) :=
  forall P : A -> A -> Prop,
  (forall u : A, P u u) ->
  (forall u v w : A, R u v -> P v w -> P u w) -> P x y.  

Theorem Rstar_reflexive : forall x : A, Rstar x x.
 Proof
   fun (x : A) (P : A -> A -> Prop) (h1 : forall u : A, P u u)
     (h2 : forall u v w : A, R u v -> P v w -> P u w) => 
   h1 x.  

Theorem Rstar_R : forall x y z : A, R x y -> Rstar y z -> Rstar x z.
 Proof
   fun (x y z : A) (t1 : R x y) (t2 : Rstar y z) (P : A -> A -> Prop)
     (h1 : forall u : A, P u u)
     (h2 : forall u v w : A, R u v -> P v w -> P u w) =>
   h2 x y z t1 (t2 P h1 h2).  

Theorem Rstar_transitive :
 forall x y z : A, Rstar x y -> Rstar y z -> Rstar x z.
 Proof
   fun (x y z : A) (h : Rstar x y) =>
   h (fun u v : A => Rstar v z -> Rstar u z)
     (fun (u : A) (t : Rstar u z) => t)
     (fun (u v w : A) (t1 : R u v) (t2 : Rstar w z -> Rstar v z)
        (t3 : Rstar w z) => Rstar_R u v z t1 (t2 t3)).  

Definition Rstar' (x y : A) :=
  forall P : A -> A -> Prop,
  P x x -> (forall u : A, R x u -> Rstar u y -> P x y) -> P x y.  

Theorem Rstar'_reflexive : forall x : A, Rstar' x x.
 Proof
   fun (x : A) (P : A -> A -> Prop) (h : P x x)
     (h' : forall u : A, R x u -> Rstar u x -> P x x) => h.
  
Theorem Rstar'_R : forall x y z : A, R x z -> Rstar z y -> Rstar' x y.
 Proof
   fun (x y z : A) (t1 : R x z) (t2 : Rstar z y) (P : A -> A -> Prop)
     (h1 : P x x) (h2 : forall u : A, R x u -> Rstar u y -> P x y) =>
   h2 z t1 t2.  

Theorem Rstar'_Rstar : forall x y : A, Rstar' x y -> Rstar x y.
 Proof
   fun (x y : A) (h : Rstar' x y) =>
   h Rstar (Rstar_reflexive x) (fun u : A => Rstar_R x u y).  
  
Theorem Rstar_Rstar' : forall x y : A, Rstar x y -> Rstar' x y.
 Proof
   fun (x y : A) (h : Rstar x y) =>
   h Rstar' (fun u : A => Rstar'_reflexive u)
     (fun (u v w : A) (h1 : R u v) (h2 : Rstar' v w) =>
      Rstar'_R u w v h1 (Rstar'_Rstar v w h2)).  

Lemma Rstar_inv :
 forall x y : A,
 Rstar x y -> x = y \/ ex2 (fun z : A => R x z) (fun z : A => Rstar z y).

End Relations.

Hint Resolve Rstar_reflexive. *)



Require Import gram.
(* gram:
Require Import Ensf.
Require Import Words.
Require Import more_words.
Require Import need.
Require Import fonctions.
Require Import Relations.

Definition Mots (X : Ensf) :=
  forall a : Elt, dans a X -> exists w : Word, word w = a.

Definition Regles (X V R : Ensf) :=
  forall x : Elt,
  dans x R ->
  ex2 (fun A : Elt => dans A V)
    (fun A : Elt =>
     ex2 (fun B : Word => x = couple A (word B))
       (fun B : Word => inmonoid (union X V) B)).

Lemma Regles_inv1 :
 forall (X V R : Ensf) (x y : Elt),
 Regles X V R -> dans (couple x y) R -> dans x V.

Lemma Regles_inv2 :
 forall (X V R : Ensf) (x : Elt) (u : Word),
 Regles X V R -> dans (couple x (word u)) R -> inmonoid (union X V) u.

Definition isGram (X V R : Ensf) (S : Elt) : Prop :=
  Mots X /\ inter X V empty /\ dans S V /\ Regles X V R.

Section Easy_lemma_isGram.

Variable X V R : Ensf.
Variable S : Elt.
Let H := isGram X V R S.

Lemma isGram1 : H -> Mots X.

Lemma isGram2 : H -> inter X V empty.

Lemma isGram3 : H -> dans S V.

Lemma isGram4 : H -> Regles X V R.

Lemma isGram5 : Mots X -> inter X V empty -> dans S V -> Regles X V R -> H.

End Easy_lemma_isGram.

Lemma Regles_R :
 forall X V R R' : Ensf, inclus R' R -> Regles X V R -> Regles X V R'.

Lemma Regles_V :
 forall X V R V' : Ensf, inclus V V' -> Regles X V R -> Regles X V' R.

Lemma Regles_add :
 forall (X V R : Ensf) (a : Elt) (u : Word),
 Regles X V R ->
 dans a V -> inmonoid (union X V) u -> Regles X V (add (couple a (word u)) R).

Lemma Regles_add2 :
 forall (X V R : Ensf) (a : Elt), Regles X V R -> Regles X (add a V) R.

Lemma Regles_union :
 forall X V R R' : Ensf,
 Regles X V R -> Regles X V R' -> Regles X V (union R R').

Lemma isGram_inclus2 :
 forall (X V R R' : Ensf) (S : Elt),
 inclus R' R -> isGram X V R S -> isGram X V R' S.

Lemma isGram_inclus3 :
 forall (X V R : Ensf) (S a : Elt), isGram X V (add a R) S -> isGram X V R S.

Inductive Derive (R : Ensf) : Word -> Word -> Prop :=
 
  | Derive1 :
      forall (u v : Word) (A : Elt),
      dans (couple A (word u)) R ->
      Derive R (cons A v) (Append u v)
      
  | Derive2 :
      forall (u v : Word) (x : Elt),
      Derive R u v -> Derive R (cons x u) (cons x v).

Hint Resolve Derive1.
Hint Resolve Derive2.

Lemma Derive_inclus :
 forall (R1 R2 : Ensf) (u v : Word),
 inclus R1 R2 -> Derive R1 u v -> Derive R2 u v.

Definition Derive_inv (R : Ensf) (x y : Word) :=
  match x return Prop with
  | nil =>
        False
       
  | cons A w =>
      ex2 (fun u : Word => dans (couple A (word u)) R)
        (fun u : Word =>
         ex2 (fun v : Word => cons A v = x :>Word)
           (fun v : Word => Append u v = y :>Word)) \/
      ex2 (fun v : Word => Derive R w v)
        (fun v : Word => cons A v = y :>Word)
  end.

Lemma Derive_inv1 :
 forall (R : Ensf) (u v : Word), Derive R u v -> Derive_inv R u v.

Hint Resolve Derive_inv1.

Lemma Derive_inv2 :
 forall (R : Ensf) (x y : Word),
 Derive_inv R x y ->
 exists A : Elt,
   (exists2 w : Word,
      cons A w = x &
      (exists2 u : Word,
         dans (couple A (word u)) R &
         (exists2 v : Word, cons A v = x & Append u v = y)) \/
      (exists2 v : Word, Derive R w v & cons A v = y)).

Lemma Derive_inv3 :
 forall (R : Ensf) (x y : Word),
 Derive R x y ->
 exists A : _,
   (exists2 w : _,
      cons A w = x &
      (exists2 u : _,
         dans (couple A (word u)) R &
         (exists2 v : _, cons A v = x & Append u v = y)) \/
      (exists2 v : _, Derive R w v & cons A v = y)).

Lemma in_mon_X_Der_imp_inmon_X :
 forall (X V R : Ensf) (u v : Word),
 Regles X V R ->
 Derive R u v -> inmonoid (union X V) u -> inmonoid (union X V) v.

Definition Derivestar (R : Ensf) := Rstar Word (Derive R).

Hint Unfold Derivestar.

Lemma Derivestar_refl : forall (R : Ensf) (u : Word), Derivestar R u u.

Hint Resolve Derivestar_refl.

Lemma Derivestar_R :
 forall (R : Ensf) (u v w : Word),
 Derive R u v -> Derivestar R v w -> Derivestar R u w.

Lemma Derivestar_inv :
 forall (R : Ensf) (u v : Word),
 Derivestar R u v ->
 u = v \/ (exists2 w : Word, Derive R u w & Derivestar R w v).

Hint Resolve Derivestar_inv.

Lemma Derivestar_inclus :
 forall (R1 R2 : Ensf) (u v : Word),
 inclus R1 R2 -> Derivestar R1 u v -> Derivestar R2 u v.

Definition LG (X V R : Ensf) (S : Elt) : wordset :=
  fun w : Word => Derivestar R (cons S nil) w /\ inmonoid X w.

Lemma LG_inv :
 forall (X V R : Ensf) (S : Elt) (w : Word), LG X V R S w -> inmonoid X w.

Lemma LG_langage :
 forall (X V R : Ensf) (S : Elt), isGram X V R S -> islanguage X (LG X V R S).

Definition Gunion (V1 R1 V2 R2 : Ensf) := (union V1 V2, union R1 R2).

Section injprod.

Let injproduc (f : Elt -> Elt) (V : Ensf) := extension V f.

Definition injproducg : Ensf -> Elt -> Elt := injproduc injgauche.

Definition injproducd : Ensf -> Elt -> Elt := injproduc injdroite.
					
End injprod.

Definition Gunion_disj_p (V1 R1 : Ensf) (S1 : Elt) 
  (V2 R2 : Ensf) (S2 S : Elt) :=
  (add S (fst (Gunion V1 R1 V2 R2)),
  (add (couple S (word (cons S1 nil)))
     (add (couple S (word (cons S2 nil))) (snd (Gunion V1 R1 V2 R2))), S)).

Definition imageGram (f : Elt -> Elt) (X V R : Ensf) 
  (S : Elt) :=
  (map f X,
  (map f V,
  (map
     (fun P : Elt =>
      couple (f (first P))
        ((fun w : Elt => word (Word_ext f (word_inv w))) (second P))) R, 
  f S))). *)

Require Import gram_g.
(* gram_g:
Require Import Ensf.
Require Import Words.
Require Import fonctions.
Require Import Relations.
Require Import gram.

Inductive Deriveg (X R : Ensf) : Word -> Word -> Prop :=
  | Deriveg1 :
      forall (u v : Word) (A : Elt),
      dans (couple A (word u)) R -> Deriveg X R (cons A v) (Append u v)
  | Deriveg2 :
      forall (u v : Word) (x : Elt),
      dans x X -> Deriveg X R u v -> Deriveg X R (cons x u) (cons x v).

Hint Resolve Deriveg1.
Hint Resolve Deriveg2.

Definition Derivegstar (X R : Ensf) := Rstar Word (Deriveg X R).

Lemma Deriveg_Derive :
 forall (X R : Ensf) (u v : Word), Deriveg X R u v -> Derive R u v.

Lemma Derivegstar_Derivestar :
 forall (X R : Ensf) (u v : Word), Derivegstar X R u v -> Derivestar R u v.

Axiom
  Derivestar_Derivegstar :
    forall (X R : Ensf) (u v : Word), Derivestar R u v -> Derivegstar X R u v.

Hint Resolve Derivestar_Derivegstar. *)

Require Import PushdownAutomata.
(* PushdownAutomata:
Require Import Ensf.
Require Import Max.
Require Import Words.
Require Import fonctions.
Require Import need.
Require Import Relations.

Section pushdown_automata.

Variable X P : Ensf.
Variable wd : Word.
Variable wa : Word.
Variable d : Ensf.

Definition eps := natural (sup X).

Lemma not_dans_X_eps : ~ dans eps X.

Definition Transition : Prop :=
  forall x : Elt,
  dans x d ->
  exists2 w1 : Word,
    inmonoid P w1 &
    (exists2 y : Elt,
       dans y (add eps X) &
       (exists2 w2 : Word,
          inmonoid P w2 & x = couple (word w1) (couple y (word w2)) :>Elt)).

Definition P_automata := inmonoid P wd /\ inmonoid P wa /\ Transition.

Lemma P_automata_1 : P_automata -> inmonoid P wd.

Lemma P_automata_2 : P_automata -> Transition.

Definition Conf := (Word * Word)%type.

Inductive Derive_P_A : Conf -> Conf -> Prop :=
  | Derive_cons :
      forall (w w1 w2 u : Word) (x : Elt),
      dans x X ->
      dans (couple (word w1) (couple x (word w2))) d ->
      Derive_P_A (pair (Append w1 w) (cons x u)) (pair (Append w2 w) u)
  | Derive_eps :
      forall w w1 w2 u : Word,
      dans (couple (word w1) (couple eps (word w2))) d ->
      Derive_P_A (pair (Append w1 w) u) (pair (Append w2 w) u).

Definition Derivestar_P_A := Rstar Conf Derive_P_A.

Definition LA (u : Word) :=
  Derivestar_P_A (pair wd u) (pair wa nil) /\ inmonoid X u.

Lemma LA_langage : islanguage X LA.

End pushdown_automata. *)



Section APD.



Variable X V R : Ensf.

Variable S' : Elt.



Hypothesis Gram : isGram X V R S'.



Lemma Regles_X_V_R : Regles X V R.

apply isGram4 with S'.

exact Gram.

Qed.



Let P := union X V.



Let f_R_d (a : Elt) :=

  couple (word (cons (first a) nil)) (couple (eps X) (second a)).



Let f_X_d (x : Elt) := couple (word (cons x nil)) (couple x (word nil)).



Let d := union (map f_R_d R) (map f_X_d X).



Let wd := cons S' nil.



Let wa := nil.



Lemma Trans : Transition X P d.

red in |- *.

intros x dans_x_d.

elimtype (dans x (map f_R_d R) \/ dans x (map f_X_d X)).

intros dans_x.



elimtype (exists y : Elt, dans y R /\ x = f_R_d y).

intros y temp; elim temp; clear temp.

unfold f_R_d in |- *.

intros dans_y_R eg_x_f_y.

exists (cons (first y) nil).

apply inmonoid_cons.

trivial.

elim (Regles_X_V_R y dans_y_R).

intros f_y dans_f_y_V temp; elim temp; clear temp.

intros u eg_y inmono_u.

rewrite eg_y.

unfold first in |- *.

unfold P in |- *.

auto.

exists (eps X).

auto.

exists (word_inv (second y)).

elim (Regles_X_V_R y dans_y_R).

intros f_y dans_f_y_V temp; elim temp; clear temp.

intros u eg_y inmono_u.

rewrite eg_y.

unfold second in |- *.

unfold word_inv in |- *.

assumption.



elim (Regles_X_V_R y dans_y_R).

intros f_y dans_f_y_V temp; elim temp; clear temp.

intros u eg_y inmono_u.



replace (word (word_inv (second y))) with (second y).

assumption.

replace (second y) with (word u).

apply refl_equal.

rewrite eg_y.

apply refl_equal.



apply dans_map.

assumption.



intros dans_x.

elimtype (exists y : Elt, dans y X /\ x = f_X_d y).

intros y temp; elim temp; clear temp.

unfold f_X_d in |- *.

intros dans_y_X eg_x_f_y.

exists (cons y nil).

apply inmonoid_cons.

trivial.

unfold P in |- *.

auto.



exists y.

auto.

exists nil.

trivial.

assumption.



apply dans_map.

assumption.



auto.

Qed.



Lemma X_P_wd_wa_d : P_automata X P wd wa d.

red in |- *.

split.

unfold wd in |- *.

apply inmonoid_cons.

trivial.

unfold P in |- *.

apply union_d.

apply isGram3 with X R.

exact Gram.

split.

apply inmonoid_nil.

exact Trans.

Qed.



Lemma cut_spec :

 forall u : Word,

 {a : Word & 

 {b : Word |

 inmonoid X a /\

 Append a b = u /\

 (b = nil \/

  ex2 (fun x : Elt => ~ dans x X)

    (fun x : Elt => exists w : Word, b = cons x w))}}.

intro u.

pattern u in |- *.

apply Word_rec.



exists nil.

exists nil.

auto.



intros x w Hyp.

elim Hyp.

intros a' spec; elim spec.

intros b' temp; elim temp; clear temp.

intros inmonoid_a' temp; elim temp; clear temp.

intros spec_App spec_or.

elimtype ({dans x X} + {~ dans x X}).

intro dans_x_X.

exists (cons x a').

exists b'.

split.

apply inmonoid_cons; assumption.

split.

unfold Append in |- *.

simpl in |- *.

auto.



elim spec_or; intro; assumption.

intro N_dans_x_X.

exists nil.

exists (cons x w).

split.

auto.

split.

auto.

apply or_intror.

exists x.

assumption.

exists w.

apply refl_equal.

exact (Dans_spec x X).

Qed.



Definition cut (u : Word) :=

  let (a, s) := cut_spec u in (a, let (b, s2) := s in b).



Definition cut1 (u : Word) := fst (cut u).

Definition cut2 (u : Word) := snd (cut u).



Lemma cut_unicite :

 forall u a b a' b' : Word,

 inmonoid X a /\

 Append a b = u /\

 (b = nil \/

  ex2 (fun x : Elt => ~ dans x X)

    (fun x : Elt => exists w : Word, b = cons x w)) ->

 inmonoid X a' /\

 Append a' b' = u /\

 (b' = nil \/

  ex2 (fun x : Elt => ~ dans x X)

    (fun x : Elt => exists w : Word, b' = cons x w)) -> 

 a = a'.

intros u a b a' b' temp1 temp2; elim temp1; elim temp2; clear temp1;

 clear temp2.

intros inmon temp inmon' temp'; elim temp; elim temp'; clear temp;

 clear temp'.

intros App spec_or App' spec_or'.

elimtype

 (exists w : Word,

    a = Append a' w /\ b' = Append w b \/ a' = Append a w /\ b = Append w b').

intros x temp; elim temp; clear temp.

pattern a' at 2 in |- *.

replace a' with (Append a' nil).

generalize x; clear x; simple induction x.



intro temp; elim temp.

auto.



intros x0 w Hyp temp; elim temp; clear temp.

intros a_eg b'_eg.

absurd (dans x0 X).

elim spec_or'.

rewrite b'_eg.

intro cons_nil.

absurd (cons x0 (Append w b) = nil).

discriminate.

assumption.

intro temp; elim temp; clear temp.

intros x1 N_dans_x1 temp; elim temp; clear temp.

intros w' b'_eg_2.

replace x0 with x1.

assumption.

apply cons_cons_inv1 with w' (Append w b).

rewrite <- b'_eg_2.

assumption.

apply inmonoid_cons_inv2 with w.

apply inmonoid_Append_inv2 with a'.

rewrite <- a_eg.

assumption.

apply Append_w_nil.



pattern a at 2 in |- *.

replace a with (Append a nil).

generalize x; clear x; simple induction x.



intro temp; elim temp.

auto.



intros x0 w Hyp temp; elim temp; clear temp.

intros a'_eg b_eg.

absurd (dans x0 X).

elim spec_or.

rewrite b_eg.

intro cons_nil.

absurd (cons x0 (Append w b') = nil).

discriminate.

assumption.

intro temp; elim temp; clear temp.

intros x1 N_dans_x1 temp; elim temp; clear temp.

intros w' b_eg_2.

replace x0 with x1.

assumption.

apply cons_cons_inv1 with w' (Append w b').

rewrite <- b_eg_2.

assumption.

apply inmonoid_cons_inv2 with w.

apply inmonoid_Append_inv2 with a.

rewrite <- a'_eg.

assumption.

apply Append_w_nil.

apply Append_Append.

rewrite App'; assumption.

Qed.



Lemma inmonoid_cut1 : forall w : Word, inmonoid X (cut1 w).

intro w.

unfold cut1, cut in |- *.

elim (cut_spec w).

intros a temp; elim temp; clear temp.

intros b temp; elim temp; clear temp.

simpl in |- *; auto.

Qed.



Lemma cut_Append : forall w : Word, w = Append (cut1 w) (cut2 w).

intro w.

unfold cut1, cut2, cut in |- *.

elim (cut_spec w).

intros a temp; elim temp; clear temp.

intros b temp; elim temp; clear temp.

intros inm temp; elim temp.

simpl in |- *; auto.

Qed.



Lemma cut1_cons :

 forall (a : Elt) (w : Word), dans a X -> cut1 (cons a w) = cons a (cut1 w).

intros a w dans_a_X.

unfold cut1, cut in |- *.

elim (cut_spec w).

intros x temp; elim temp; clear temp.

intros b temp; elim temp; clear temp.

intros inmon_X_x temp; elim temp; clear temp.



elim (cut_spec (cons a w)).

intros x' temp; elim temp; clear temp.

intros b' temp; elim temp; clear temp.

intros inmon_X_x' temp; elim temp; clear temp.



intros App_eg' spec' App_eg spec.

simpl in |- *.



cut (inmonoid X x').

cut (Append x' b' = cons a w).



clear inmon_X_x' App_eg'.

generalize x'; clear x'; simple induction x'.



intro App_nil_b'_eg_cons_a_w.

absurd (dans a X).

elim spec'.

intro b'_nil.

absurd (cons a w = nil).

discriminate.

rewrite <- b'_nil.

rewrite <- App_nil_b'_eg_cons_a_w.

trivial.

intro temp; elim temp; clear temp.

intros x0 N_dans_x0_X temp; elim temp; clear temp.

intros w1 eg_b'_cons.

replace a with x0.

assumption.

apply cons_cons_inv1 with w1 w.

rewrite <- eg_b'_cons.

assumption.

assumption.



intros x0 w0 Hyp App_eg_cons inmon_cons.

apply cons_cons.

apply cons_cons_inv1 with (Append w0 b') w.

assumption.

apply cut_unicite with w b' b.

split.

apply inmonoid_cons_inv with x0; assumption.



split.

apply cons_cons_inv2 with x0 a.

assumption.

assumption.



split; auto.

assumption.

assumption.

Qed.



Lemma cut1_Append :

 forall u v : Word, inmonoid X u -> cut1 (Append u v) = Append u (cut1 v).

intros u v.

generalize u; clear u; simple induction u.

auto.

intros x w Hyp inmon_x_w.

replace (cut1 (Append (cons x w) v)) with (cons x (cut1 (Append w v))).

replace (Append (cons x w) (cut1 v)) with (cons x (Append w (cut1 v))).

apply cons_cons.

trivial.



apply Hyp.

apply inmonoid_cons_inv with x; assumption.



trivial.



apply sym_equal.

unfold Append in |- *.

simpl in |- *.

apply cut1_cons.

apply inmonoid_cons_inv2 with w.

trivial.

Qed.



Axiom

  cut2_cons :

    forall (A : Elt) (v : Word), dans A X -> cut2 (cons A v) = cut2 v.



Lemma cut2_cons_N :

 forall (A : Elt) (v : Word), ~ dans A X -> cut2 (cons A v) = cons A v.

intros A v N_dans_A_X.

unfold cut2, cut in |- *.

elim (cut_spec (cons A v)).

intros a temp; elim temp; clear temp.

intros b temp; elim temp; clear temp.

intros inmon_a temp; elim temp; clear temp.

intros App_eg spec_or.

cut (inmonoid X a).

cut (Append a b = cons A v).

clear App_eg inmon_a.

generalize a; clear a; simple induction a.

	auto.



	intros x w Hyp App_eg_x_w inmon.

	absurd (dans A X).

		assumption.



		replace A with x.

		apply inmonoid_cons_inv2 with w.

		assumption.

		apply cons_cons_inv1 with (Append w b) v.

		assumption.

assumption.

assumption.

Qed.



Lemma Deriveg_imp_Deriveg_cut :

 forall x y : Word,

 Deriveg X R x y ->

 ex2 (fun w : Word => Append (cut1 x) w = y)

   (fun w : Word => Deriveg X R (cut2 x) w).

intros x y Der.

elim Der.

intros.

replace (cut1 (cons A v)) with nil.

exists (Append u v).

trivial.

replace (cut2 (cons A v)) with (cons A v).

apply Deriveg1.

assumption.

apply sym_equal.

apply cut2_cons_N.

apply inter_dans with V.

apply sym_inter.

apply isGram2 with R S'.

exact Gram.

apply Regles_inv1 with X R (word u).

apply isGram4 with S'.

exact Gram.

assumption.



unfold cut1, cut in |- *.

elim (cut_spec (cons A v)).

intros a p.

elim p.

intros b temp; elim temp; clear temp.

intros inmon_a temp; elim temp; clear temp.



intros App_eg spec_or.



cut (inmonoid X a). 

cut (Append a b = cons A v). 

clear App_eg inmon_a p.

generalize a; clear a; simple induction a.



auto.



intros x0 w Hyp App inmon.

absurd (dans A X).



intros.

apply inter_dans with V.

apply sym_inter.

apply isGram2 with R S'.

exact Gram.



apply Regles_inv1 with X R (word u).

apply isGram4 with S'.

exact Gram.

assumption.



apply inmonoid_cons_inv2 with w.

replace A with x0.

assumption.

apply cons_cons_inv1 with (Append w b) v.

assumption.



assumption. 

assumption. 



intros u v x0 dans_x0_X Deriveg_X_R_u_v temp.

elim temp; clear temp.

intros w eg_App_cut Der_g_cut2.

exists w.

replace (cut1 (cons x0 u)) with (cons x0 (cut1 u)).

unfold Append in |- *.

simpl in |- *.

apply cons_cons; trivial.



apply sym_equal.

apply cut1_cons.

assumption.



replace (cut2 (cons x0 u)) with (cut2 u).

assumption.

apply sym_equal.

apply cut2_cons.

assumption.

Qed.



Lemma Deriveg_imp_Deriveg_App :

 forall x y : Word,

 Deriveg X R x y ->

 forall u v : Word,

 Append u v = x ->

 inmonoid X u ->

 ex2 (fun w : Word => Append u w = y) (fun w : Word => Deriveg X R v w).

intros x y Derg.

elim Derg.



intros u0 v0 A dans_A_u0_R u v eg_App.

elimtype (u = nil \/ (exists w : Word, (exists x : Elt, u = cons x w))).

intros u_eg.

exists (Append u0 v0).

rewrite u_eg.

trivial.

replace v with (cons A v0).

apply Deriveg1; assumption.

replace v with (Append u v).

auto.

rewrite u_eg.

trivial.

intro temp; elim temp; clear temp.

intros w temp; elim temp; clear temp.

intros x0 u_eg inmon_u.

absurd (dans x0 V).

apply inter_dans with X.

apply isGram2 with R S'.

exact Gram.

apply inmonoid_cons_inv2 with w.

rewrite <- u_eg.

assumption.

replace x0 with A.

apply Regles_inv1 with X R (word u0).

exact Regles_X_V_R.

assumption.

apply cons_cons_inv1 with v0 (Append w v).

change (cons A v0 = Append (cons x0 w) v) in |- *.

rewrite <- u_eg.

auto.



clear eg_App.

generalize u; clear u; simple induction u.



auto.



intros x0 w hyp.

apply or_intror.

exists w.

exists x0.

trivial.



intros u0 v0 x0 dans_x0_X Derg_u_v Hyp u v.

elimtype (u = nil \/ (exists w : Word, (exists x : Elt, u = cons x w))).

intro eg_u. 

rewrite eg_u.

intros App_eg inmon_nil.

exists (cons x0 v0).

trivial.

replace v with (cons x0 u0).

apply Deriveg2.

assumption.

assumption.

intro temp; elim temp; clear temp.

intros w temp; elim temp; clear temp.

intros x1 u_eg.

rewrite u_eg.

intros App_cons_eg inmonoid_X_cons_x1_w.

elimtype

 (ex2 (fun w1 : Word => Append w w1 = v0) (fun w1 : Word => Deriveg X R v w1)).

intros w0 App_eg Der_v_w0.

exists w0.

change (cons x1 (Append w w0) = cons x0 v0) in |- *.

apply cons_cons.

apply cons_cons_inv1 with (Append w v) u0.

assumption.

assumption.

assumption.

apply Hyp.

apply cons_cons_inv2 with x1 x0.

assumption.

apply inmonoid_cons_inv with x1.

assumption.



generalize u; clear u; simple induction u.

auto.

intros x2 w hyp.

apply or_intror.

exists w.

exists x2.

trivial.



Qed.



Lemma Derivegstar_imp_Der_inmon :

 forall x y : Word,

 Derivegstar X R x y ->

 forall u v : Word,

 Append u v = x ->

 inmonoid X u ->

 ex2 (fun w : Word => Append u w = y) (fun w : Word => Derivegstar X R v w).

unfold Derivegstar in |- *.

intros x y Der_star.

unfold Rstar in Der_star.

pattern x, y in |- *.

apply Der_star.



intros; exists v.

assumption.

apply Rstar_reflexive.



intros u v w Der_u_v Hyp u0 v0 App_eg inmon_u0.

elimtype

 (ex2 (fun w1 : Word => Append u0 w1 = v)

    (fun w1 : Word => Deriveg X R v0 w1)).

intros w0 App_eg_u0_w0 Deriveg_v0_x0.

elimtype

 (ex2 (fun w1 : Word => Append u0 w1 = w)

    (fun w1 : Word => Rstar Word (Deriveg X R) w0 w1)).

intros w1 App_eg_u0_w1_w Rstar_Der.

exists w1.

assumption.

apply Rstar_R with w0.

assumption.

assumption.

apply Hyp; assumption.

apply Deriveg_imp_Deriveg_App with u; assumption.

Qed.



Inductive Derive_P_A_2 : Conf -> Conf -> Prop :=

  | Derive_X :

      forall (w u : Word) (x : Elt),

      dans x X -> Derive_P_A_2 (cons x w, cons x u) (w, u)

  | Derive_V :

      forall (v w u : Word) (x : Elt),

      dans (couple x (word u)) R ->

      Derive_P_A_2 (cons x w, v) (Append u w, v).



Definition Derive_P_A_2_nind (x y : Conf) :=

  ex2 (fun a : Elt => dans a X)

    (fun a : Elt => fst x = cons a (fst y) /\ snd x = cons a (snd y)) \/

  (exists a : Elt,

     ex2 (fun w : Word => cons a w = fst x)

       (fun w : Word =>

        ex2 (fun u : Word => dans (couple a (word u)) R)

          (fun u : Word => Append u w = fst y))).



Lemma Derive_P_A_2_inv :

 forall x y : Conf, Derive_P_A_2 x y -> Derive_P_A_2_nind x y.

intros x y Der.

unfold Derive_P_A_2_nind in |- *.

elim Der.

intros w u x0 dans_x0_X.

apply or_introl.

exists x0; auto.



intros v w u x0 dans_couple_Der.

apply or_intror.

exists x0.

exists w.

auto.

exists u; auto.

Qed.



Definition Derivestar_P_A_2 := Rstar Conf Derive_P_A_2.



Lemma Der_cons_inv :

 forall (x : Elt) (u v : Word),

 dans x X ->

 Derivestar_P_A_2 (cons x u, v) (nil, nil) ->

 ex2 (fun v2 : Word => v = cons x v2)

   (fun v2 : Word => Derivestar_P_A_2 (u, v2) (nil, nil)).

intros x u v dans_x_X Der_star.

elimtype

 ((cons x u, v) = (nil, nil) \/

  ex2 (fun z : Conf => Derive_P_A_2 (cons x u, v) z)

    (fun z : Conf => Rstar (Word * Word) Derive_P_A_2 z (nil, nil))).

intro eg.

absurd (cons x u = nil).

discriminate.



change (fst (cons x u, v) = fst (nil, nil)) in |- *.

apply (f_equal (fst (A:=Word) (B:=Word))).

assumption.

intro temp; elim temp; clear temp; intros z Der Der_star_2.

cut (Derive_P_A_2_nind (cons x u, v) z).

unfold Derive_P_A_2_nind in |- *.

intro temp; elim temp; clear temp; intro temp; elim temp; clear temp.

simpl in |- *.

intros x0 dans_x0_X temp; elim temp; clear temp.

intros eg_cons_x_x0 eg_v_cons.

exists (snd z).

replace x with x0.

trivial.

apply cons_cons_inv1 with (fst z) u.

auto.

unfold Derivestar_P_A_2 in |- *.

replace u with (fst z).

cut (Rstar (Word * Word) Derive_P_A_2 z (nil, nil)).

elim z.

auto.

assumption.

apply cons_cons_inv2 with x0 x.

auto.



simpl in |- *.

intros x0 temp; elim temp; clear temp; intros w eg temp; elim temp;

 clear temp.

intros u0 dans_couple.

absurd (dans x0 V).

apply inter_dans with X.

exact (isGram2 X V R S' Gram).

replace x0 with x.

trivial.

apply cons_cons_inv1 with u w.

auto.

apply Regles_inv1 with X R (word u0).

exact Regles_X_V_R.

assumption.

apply Derive_P_A_2_inv.

assumption.

apply Rstar_inv.

assumption.

Qed.



Lemma Derive_P_A_2_imp_Der_P_A_2_App :

 forall x y : Word,

 Derivestar_P_A_2 (x, y) (nil, nil) ->

 forall u v : Word,

 Append u v = x ->

 inmonoid X u ->

 ex2 (fun w : Word => Append u w = y)

   (fun w : Word => Derivestar_P_A_2 (v, w) (nil, nil)).

unfold Derivestar_P_A_2 in |- *.

simple induction x.

intros y Der_P_A_2 u v.

elimtype (u = nil \/ (exists w : Word, (exists x : Elt, u = cons x w))).

intros u_eg.

rewrite u_eg.

intros App_eg inmon_nil.

exists y; auto.

replace v with nil; trivial.



intro temp; elim temp; clear temp; intros w temp; elim temp; clear temp.

intros x0 eg_u.

rewrite eg_u.

intros cons_eg_nil.

absurd (cons x0 (Append w v) = nil).

discriminate.

trivial.



generalize u; clear u; simple induction u.

auto.

intros x1 w1 Hyp; apply or_intror; exists w1; exists x1; trivial.



intros x0 w Hyp y Der_star_cons u v App_eg inmon_X.

elimtype (u = nil \/ (exists w : Word, (exists x : Elt, u = cons x w))).

intros u_eg.

rewrite u_eg.

replace v with (cons x0 w).

exists y; trivial.

replace v with (Append u v).

auto.

rewrite u_eg.

trivial.



intro temp; elim temp; clear temp; intros w1 temp; elim temp; clear temp.

intros x1 eg_u.

rewrite eg_u.

elimtype

 (ex2 (fun v2 : Word => y = cons x0 v2)

    (fun v2 : Word => Derivestar_P_A_2 (w, v2) (nil, nil))).

intros v2 y_eg Der_w_v2.

elimtype

 (ex2 (fun w : Word => Append w1 w = v2)

    (fun w : Word => Rstar Conf Derive_P_A_2 (v, w) (nil, nil))).

intros we App_w1_we_eg_v2 Rstar_Der.

exists we.

rewrite y_eg.

replace (Append (cons x1 w1) we) with (cons x1 (Append w1 we)).

apply cons_cons.

apply cons_cons_inv1 with (Append w1 v) w.

rewrite <- App_eg.

rewrite eg_u.

trivial.

trivial.

trivial.

trivial.



apply Hyp.

trivial.

apply cons_cons_inv2 with x1 x0.

rewrite <- App_eg.

rewrite eg_u.

trivial.

apply inmonoid_cons_inv with x1.

rewrite <- eg_u.

trivial.

apply Der_cons_inv.

replace x0 with x1.

apply inmonoid_cons_inv2 with w1.

rewrite <- eg_u.

trivial.

apply cons_cons_inv1 with (Append w1 v) w.

rewrite <- App_eg.

rewrite eg_u.

trivial.

assumption.



clear inmon_X App_eg.

generalize u; clear u; simple induction u.

auto.

intros x1 w1 tmp; apply or_intror; exists w1; exists x1; trivial.



Qed.



Lemma Derive_P_A_2_imp_Der_P_A_2_cons :

 forall (u : Elt) (x y : Word),

 Derivestar_P_A_2 (cons u x, y) (nil, nil) ->

 dans u X ->

 ex2 (fun w : Word => cons u w = y)

   (fun w : Word => Derivestar_P_A_2 (x, w) (nil, nil)).

intros.

elimtype

 (ex2 (fun w : Word => Append (cons u nil) w = y)

    (fun w : Word => Derivestar_P_A_2 (x, w) (nil, nil))).

intros w eg_App Der.

exists w; trivial.



apply Derive_P_A_2_imp_Der_P_A_2_App with (cons u x); auto.

Qed.



Lemma Derivestar_P_A_2_x :

 forall x : Word, inmonoid X x -> Derivestar_P_A_2 (x, x) (nil, nil).

unfold Derivestar_P_A_2 in |- *.

simple induction x.

intro.

apply Rstar_reflexive.

intros x0 w Hyp inmon.

apply Rstar_R with (w, w).

apply Derive_X.

apply inmonoid_cons_inv2 with w; assumption.



apply Hyp.

apply inmonoid_cons_inv with x0; assumption.

Qed.

Hint Resolve Derivestar_P_A_2_x.



Lemma Derivegstar_imp_Derivestar_P_A_2 :

 forall x y : Word,

 Derivegstar X R x y -> inmonoid X y -> Derivestar_P_A_2 (x, y) (nil, nil).

unfold Derivegstar, Rstar in |- *.

intros x y Der_star.

pattern x, y in |- *.

apply Der_star.

auto.



intros u v w Derg_u_v.

generalize w.

elim Derg_u_v.

intros u0 v0 A dans_couple w0 Hyp inmon_w0.

unfold Derivestar_P_A_2 in |- *.

apply Rstar_R with (Append u0 v0, w0).

apply Derive_V.

assumption.

apply Hyp; assumption.



intros u0 v0 x0 dans_x0_v0 Der_u0_v0 Hyp1 w0 Hyp2 inmon_w0.



elimtype

 (ex2 (fun v2 : Word => w0 = cons x0 v2)

    (fun v2 : Word => Derivestar_P_A_2 (v0, v2) (nil, nil))).

intros x1 w0_eg_cons Derivestar_v0_x1.

rewrite w0_eg_cons.

unfold Derivestar_P_A_2 in |- *.

apply Rstar_R with (u0, x1).

apply Derive_X.

assumption.

apply Hyp1.

auto.

apply inmonoid_cons_inv with x0.

rewrite <- w0_eg_cons.

assumption.



apply Der_cons_inv.

assumption.

exact (Hyp2 inmon_w0).

Qed.

Hint Resolve Derivegstar_imp_Derivestar_P_A_2.



Lemma Derive_P_A_2_imp_Derive_P_A :

 forall x y : Word * Word, Derive_P_A_2 x y -> Derive_P_A X d x y.

intros x y Der.

elim Der.

intros w u x0 dans_x0_X.

replace (cons x0 w) with (Append (cons x0 nil) w).

pattern w at 2 in |- *.

replace w with (Append nil w).

apply Derive_cons.

assumption.

unfold d in |- *.

apply union_d.

change (dans (f_X_d x0) (map f_X_d X)) in |- *.

apply dans_map_inv.

assumption.

trivial.

trivial.



intros v w u x0 dans_couple.

replace (cons x0 w) with (Append (cons x0 nil) w).

apply Derive_eps.

unfold d in |- *.

apply union_g.

replace (couple (word (cons x0 nil)) (couple (eps X) (word u))) with

 (f_R_d (couple x0 (word u))).

apply dans_map_inv.

assumption.

unfold f_R_d in |- *.

trivial.

trivial.

Qed.

Hint Resolve Derive_P_A_2_imp_Derive_P_A.



Lemma Derivestar_P_A_2_imp_Derivestar_P_A :

 forall x y : Word * Word, Derivestar_P_A_2 x y -> Derivestar_P_A X d x y.

unfold Derivestar_P_A_2, Rstar, Derivestar_P_A in |- *.

intros x y Rstar_Der.

pattern x, y in |- *.

apply Rstar_Der.

intros.

apply Rstar_reflexive.

intros u v w Hyp1 Hyp2.

apply Rstar_R with v; auto.

Qed.

Hint Resolve Derivestar_P_A_2_imp_Derivestar_P_A.



Lemma Derive_P_A_imp_Derive_P_A_2 :

 forall x y : Word * Word, Derive_P_A X d x y -> Derive_P_A_2 x y.

unfold d in |- *.

intros x y Der.

elim Der.

intros w w1 w2 u x0 dans_x0_X dans_couple_d.

elimtype

 (dans (couple (word w1) (couple x0 (word w2))) (map f_R_d R) \/

  dans (couple (word w1) (couple x0 (word w2))) (map f_X_d X)).

intros dans_couple.

absurd (dans (eps X) X).

apply not_dans_X_eps.

replace (eps X) with x0.

assumption.

elimtype

 (exists r : Elt,

    dans r R /\ couple (word w1) (couple x0 (word w2)) = f_R_d r).

intros r temp; elim temp; clear temp; intros dans_r_R.

unfold f_R_d in |- *.

intro eg.

apply couple_couple_inv1 with (word w2) (second r).

apply couple_couple_inv2 with (word w1) (word (cons (first r) nil)).

assumption.

apply dans_map.

assumption.



intros dans_couple.

elimtype

 (exists r : Elt,

    dans r X /\ couple (word w1) (couple x0 (word w2)) = f_X_d r).

intros r temp; elim temp; clear temp; intros dans_r_X eg.



replace w1 with (cons x0 nil).

replace w2 with nil.

simpl in |- *.

replace (Append nil w) with w.

replace (Append (cons x0 nil) w) with (cons x0 w).

apply Derive_X.

assumption.

trivial.

trivial.

apply word_word_inv.

apply couple_couple_inv2 with r x0.

apply couple_couple_inv2 with (word (cons r nil)) (word w1).

auto.

replace x0 with r.

apply word_word_inv.

apply couple_couple_inv1 with (couple r (word nil)) (couple x0 (word w2)).

auto.

apply couple_couple_inv1 with (word nil) (word w2).

apply couple_couple_inv2 with (word (cons r nil)) (word w1).

auto.



apply dans_map.

assumption.

auto.



unfold d in |- *.

intros w w1 w2 u dans_couple_d.

elimtype

 (dans (couple (word w1) (couple (eps X) (word w2))) (map f_R_d R) \/

  dans (couple (word w1) (couple (eps X) (word w2))) (map f_X_d X)).

intros dans_couple.



elimtype

 (exists r : Elt,

    dans r R /\ couple (word w1) (couple (eps X) (word w2)) = f_R_d r).

intros r temp; elim temp; clear temp; intros dans_r_R eg.

replace w1 with (cons (first r) nil).

replace (Append (cons (first r) nil) w) with (cons (first r) w).

apply Derive_V.

replace (word w2) with (second r).

elimtype

 (ex2 (fun A : Elt => dans A V)

    (fun A : Elt =>

     ex2 (fun B : Word => r = couple A (word B))

       (fun B : Word => inmonoid (union X V) B))).

intros A dans_A_V temp; elim temp; clear temp; intros B eg_r inmon_B.

rewrite eg_r.

replace (first (couple A (word B))) with A.

replace (second (couple A (word B))) with (word B).

rewrite <- eg_r.

assumption.

trivial.

trivial.



apply Regles_X_V_R.

assumption.

apply couple_couple_inv2 with (eps X) (eps X).

apply couple_couple_inv2 with (word (cons (first r) nil)) (word w1).

auto.

trivial.

apply word_word_inv.

apply

 couple_couple_inv1

  with (couple (eps X) (second r)) (couple (eps X) (word w2)).

auto.

apply dans_map.

assumption.



intro dans_couple.

elimtype

 (exists r : Elt,

    dans r X /\ couple (word w1) (couple (eps X) (word w2)) = f_X_d r).

intros r temp; elim temp; clear temp; intros dans_r_X eg.

absurd (dans (eps X) X).

apply not_dans_X_eps.

replace (eps X) with r.

assumption.

apply couple_couple_inv1 with (word nil) (word w2).

apply couple_couple_inv2 with (word (cons r nil)) (word w1).

auto.

apply dans_map.

assumption.

auto.

Qed.

Hint Resolve Derive_P_A_imp_Derive_P_A_2.



Lemma Derivestar_P_A_imp_Derivestar_P_A_2 :

 forall x y : Word * Word, Derivestar_P_A X d x y -> Derivestar_P_A_2 x y.

unfold Derivestar_P_A, Rstar, Derivestar_P_A_2 in |- *.

intros x y Der_star.

pattern x, y in |- *.

apply Der_star.

intros.

apply Rstar_reflexive.

intros u v w Deri_u_v Rstar_v_w.

apply Rstar_R with v; auto.

Qed.



Hint Resolve Derivestar_P_A_imp_Derivestar_P_A_2.



Theorem Derivestar_imp_Derivestar_P_A :

 forall x y : Word,

 Derivestar R x y -> inmonoid X y -> Derivestar_P_A X d (x, y) (nil, nil).



auto.

Qed.



Inductive Derive_P_A_3 : Word * Conf -> Word * Conf -> Prop :=

  | Derive3_X :

      forall (w u s : Word) (x : Elt),

      dans x X ->

      Derive_P_A_3 (s, (cons x w, cons x u)) (Append s (cons x nil), (w, u))

  | Derive3_V :

      forall (v w u s : Word) (x : Elt),

      dans (couple x (word u)) R ->

      Derive_P_A_3 (s, (cons x w, v)) (s, (Append u w, v)).



Definition Derivestar_P_A_3 := Rstar (Word * Conf) Derive_P_A_3.



Lemma Conserve_App_s_u :

 forall s1 s2 u1 u2 v1 v2 : Word,

 Derive_P_A_3 (s1, (u1, v1)) (s2, (u2, v2)) -> Append s1 v1 = Append s2 v2.

intros s1 s2 u1 u2 v1 v2 Derive_P_A_3_s1_v1_s2_v2.

change

  ((fun a b : Word * Conf =>

    Append (fst a) (snd (snd a)) = Append (fst b) (snd (snd b)))

     (s1, (u1, v1)) (s2, (u2, v2))) in |- *.



elim Derive_P_A_3_s1_v1_s2_v2; simpl in |- *.

intros w u s x dans_x_X.

replace (cons x u) with (Append (cons x nil) u); trivial.

auto.

Qed.



Lemma Derisvestar_P_A_3_conserve :

 forall s1 s2 u1 u2 v1 v2 : Word,

 Derivestar_P_A_3 (s1, (u1, v1)) (s2, (u2, v2)) ->

 Append s1 v1 = Append s2 v2.

unfold Derivestar_P_A_3, Rstar in |- *.

intros s1 s2 u1 u2 v1 v2 Derivestar_P_A_3_s1_v1_s2_v2.

change

  ((fun a b : Word * Conf =>

    Append (fst a) (snd (snd a)) = Append (fst b) (snd (snd b)))

     (s1, (u1, v1)) (s2, (u2, v2))) in |- *.



apply Derivestar_P_A_3_s1_v1_s2_v2.

trivial.

intros u v w.

elim u. intros uu1 uuc. elim uuc. intros uu2 uu3.

elim v. intros vv1 vvc. elim vvc. intros vv2 vv3.

simpl in |- *.

intros Der eg1.

rewrite <- eg1.

apply Conserve_App_s_u with uu2 vv2.

assumption.

Qed.



Lemma Derive_P_A_2_imp_Derive_P_A_3 :

 forall (s : Word) (x y : Conf),

 Derive_P_A_2 x y -> exists s2 : Word, Derive_P_A_3 (s, x) (s2, y).

intros s x y Derive_P_A_2_x_y.

elim Derive_P_A_2_x_y.

intros w u x0 dans_x0_X.

exists (Append s (cons x0 nil)).

apply Derive3_X; assumption.



intros v w u x0 dans_couple.

intros; exists s.

apply Derive3_V; assumption.

Qed.



Lemma Derivestar_P_A_2_imp_Derivestar_P_A_3 :

 forall x y : Conf,

 Derivestar_P_A_2 x y ->

 forall s : Word, exists s2 : Word, Derivestar_P_A_3 (s, x) (s2, y).

unfold Derivestar_P_A_2, Rstar, Derivestar_P_A_3 in |- *.

intros x y Der_star.

pattern x, y in |- *.

apply Der_star.

intros; exists s.

apply Rstar_reflexive.



intros u v w Der_u_v Ex_v_w s.

elimtype (exists s2 : Word, Derive_P_A_3 (s, u) (s2, v)).

intros s1 Der_3_s_u_s1_v.

elim (Ex_v_w s1).

intros s2 Rstar_s1_v_s2_w.

exists s2.

apply Rstar_R with (s1, v); trivial.

apply Derive_P_A_2_imp_Derive_P_A_3; assumption.

Qed.



Lemma Deriveg_imp_Deriveg_App_2 :

 forall x y a : Word,

 inmonoid X a -> Deriveg X R x y -> Deriveg X R (Append a x) (Append a y).

intros x y.

simple induction a.

auto.



intros x0 w Hyp inmonoid_X_cons_x0_w Der_x_y.

change (Deriveg X R (cons x0 (Append w x)) (cons x0 (Append w y))) in |- *.

apply Deriveg2.

apply inmonoid_cons_inv2 with w; assumption.

apply Hyp.

apply inmonoid_cons_inv with x0; assumption.

assumption.

Qed.



Lemma Derive_P_A_3_imp_Derivegstar :

 forall x y x' y' s s' : Word,

 Derive_P_A_3 (s, (x, y)) (s', (x', y')) ->

 inmonoid X s -> Derivegstar X R (Append s x) (Append s' x').

intros x y x' y' s s' Der.

change

  ((fun a a' : Word * Conf =>

    inmonoid X (fst a) ->

    Derivegstar X R (Append (fst a) (fst (snd a)))

      (Append (fst a') (fst (snd a')))) (s, (x, y)) 

     (s', (x', y'))) in |- *.



unfold Derivegstar in |- *.

elim Der; simpl in |- *.

intros w u s0 x0 dans_x0_X inmon_s.

replace (Append (Append s0 (cons x0 nil)) w) with

 (Append s0 (Append (cons x0 nil) w)).

apply Rstar_reflexive.

auto.



intros v w u s0 x0 dans_couple_x0_u_R inmon_s.

apply Rstar_R with (Append s0 (Append u w)).

apply Deriveg_imp_Deriveg_App_2.

assumption.

apply Deriveg1.

assumption.

apply Rstar_reflexive.

Qed.



Lemma Derive_P_A_3_conserve_inmonoid_s :

 forall x y x' y' s s' : Word,

 Derive_P_A_3 (s, (x, y)) (s', (x', y')) -> inmonoid X s -> inmonoid X s'.

intros x y x' y' s s' Der.

change

  ((fun a a' : Word * Conf => inmonoid X (fst a) -> inmonoid X (fst a'))

     (s, (x, y)) (s', (x', y'))) in |- *.



elim Der; simpl in |- *.

intros.

apply inmonoid_Append; auto.

auto.

Qed.



Lemma Derivestar_P_A_3_imp_Derivegstar :

 forall x y x' y' s s' : Word,

 Derivestar_P_A_3 (s, (x, y)) (s', (x', y')) ->

 inmonoid X s -> Derivegstar X R (Append s x) (Append s' x').

unfold Derivestar_P_A_3, Rstar in |- *.

intros x y x' y' s s' Der_star.

change

  ((fun a a' : Word * Conf =>

    inmonoid X (fst a) ->

    Derivegstar X R (Append (fst a) (fst (snd a)))

      (Append (fst a') (fst (snd a')))) (s, (x, y)) 

     (s', (x', y'))) in |- *.



apply Der_star; unfold Derivegstar in |- *.



intros.

apply Rstar_reflexive.



intros u v w.

elim u. intros u1 uc. elim uc. intros u2 u3.

elim v. intros v1 vc. elim vc. intros v2 v3.

simpl in |- *.

intros Der_3_u_v Hyp inmon_u1.

apply Rstar_transitive with (Append v1 v2). 

change (Derivegstar X R (Append u1 u2) (Append v1 v2)) in |- *.

apply Derive_P_A_3_imp_Derivegstar with u3 v3.

assumption.

assumption.

apply Hyp.

apply Derive_P_A_3_conserve_inmonoid_s with u2 u3 v2 v3 u1.

assumption.

assumption.

Qed.



Theorem Derivestar_P_A_imp_Derivestar :

 forall x y : Word, Derivestar_P_A X d (x, y) (nil, nil) -> Derivestar R x y.

intros x y Derivestar_P_A_x_y_nil_nil.

elimtype (exists s2 : Word, Derivestar_P_A_3 (nil, (x, y)) (s2, (nil, nil))).

intros s2 Derivestar_P_A_3_x_y.

apply Derivegstar_Derivestar with X.

replace x with (Append nil x).

replace y with (Append s2 nil).

apply Derivestar_P_A_3_imp_Derivegstar with y nil.

assumption.

trivial.

replace y with (Append nil y).

apply sym_equal.

apply Derisvestar_P_A_3_conserve with x nil.

assumption.

trivial.

trivial.



apply Derivestar_P_A_2_imp_Derivestar_P_A_3.

auto.

Qed.



Hint Resolve Derivestar_P_A_imp_Derivestar.



Theorem equiv_APD_Gram : l_egal (LA X wd wa d) (LG X V R S').

red in |- *.

unfold l_inclus, LA, LG in |- *.

split.

intros w temp; elim temp; intros Der inmon.

auto.

intros w temp; elim temp; intros Der inmon.

auto.

Qed.



End APD.
