
Require Import Ensf.
(* Ensf:
Require Export Ensf_types.

Require Export Ensf_dans.

Require Export Ensf_union.

Require Export Ensf_couple.

Require Export Ensf_produit.

Require Export Ensf_inclus.

Require Export Ensf_inter.

Require Export Ensf_map.

Require Export Ensf_disj. *)
Require Import more_words.
(* more_words:
Require Import Ensf.
Require Import Words.

Hint Unfold eqwordset .

Definition l_inclus (l1 l2 : wordset) : Prop := forall w : Word, l1 w -> l2 w.

Hint Unfold l_inclus.

Lemma refl_l_inclus : forall l1 : wordset, l_inclus l1 l1.
Hint Resolve refl_l_inclus.

Lemma trans_l_inclus :
 forall l1 l2 l3 : wordset,
 l_inclus l1 l2 -> l_inclus l2 l3 -> l_inclus l1 l3.

Definition l_egal (l1 l2 : wordset) : Prop :=
  l_inclus l1 l2 /\ l_inclus l2 l1.

Hint Unfold l_egal.

Lemma equiv_l_egal_eqwordset :
 forall a b : wordset, l_egal a b <-> eqwordset a b.

Lemma refl_l_egal : forall l1 : wordset, l_egal l1 l1.
Hint Resolve refl_l_egal.

Section more_about_words.

Variable f : Elt -> Elt. 

Let wef := Word_ext f.

Lemma wef_append :
 forall u v : Word, wef (Append u v) = Append (wef u) (wef v).

Lemma wef_nil : forall a : Word, wef a = nil -> a = nil.

Lemma wef_cons :
 forall (a b : Word) (e : Elt),
 cons e a = wef b ->
 exists x : Elt,
   ex2 (fun w : Word => cons x w = b) (fun w : Word => f x = e /\ wef w = a).

End more_about_words.

Hint Resolve wef_cons.

Lemma Append_assoc :
 forall a b c : Word, Append a (Append b c) = Append (Append a b) c.
Hint Resolve Append_assoc. *)
Require Import PushdownAutomata.
(* PushdownAutomata:
Require Import Ensf.
Require Import Max.
Require Import Words.
Require Import fonctions.
Require Import need.
Require Import Relations.

Section pushdown_automata.

Variable X P : Ensf.
Variable wd : Word.
Variable wa : Word.
Variable d : Ensf.

Definition eps := natural (sup X).

Lemma not_dans_X_eps : ~ dans eps X.

Definition Transition : Prop :=
  forall x : Elt,
  dans x d ->
  exists2 w1 : Word,
    inmonoid P w1 &
    (exists2 y : Elt,
       dans y (add eps X) &
       (exists2 w2 : Word,
          inmonoid P w2 & x = couple (word w1) (couple y (word w2)) :>Elt)).

Definition P_automata := inmonoid P wd /\ inmonoid P wa /\ Transition.

Lemma P_automata_1 : P_automata -> inmonoid P wd.

Lemma P_automata_2 : P_automata -> Transition.

Definition Conf := (Word * Word)%type.

Inductive Derive_P_A : Conf -> Conf -> Prop :=
  | Derive_cons :
      forall (w w1 w2 u : Word) (x : Elt),
      dans x X ->
      dans (couple (word w1) (couple x (word w2))) d ->
      Derive_P_A (pair (Append w1 w) (cons x u)) (pair (Append w2 w) u)
  | Derive_eps :
      forall w w1 w2 u : Word,
      dans (couple (word w1) (couple eps (word w2))) d ->
      Derive_P_A (pair (Append w1 w) u) (pair (Append w2 w) u).

Definition Derivestar_P_A := Rstar Conf Derive_P_A.

Definition LA (u : Word) :=
  Derivestar_P_A (pair wd u) (pair wa nil) /\ inmonoid X u.

Lemma LA_langage : islanguage X LA.

End pushdown_automata. *)
Require Import gram.
(* gram:
Require Import Ensf.
Require Import Words.
Require Import more_words.
Require Import need.
Require Import fonctions.
Require Import Relations.

Definition Mots (X : Ensf) :=
  forall a : Elt, dans a X -> exists w : Word, word w = a.

Definition Regles (X V R : Ensf) :=
  forall x : Elt,
  dans x R ->
  ex2 (fun A : Elt => dans A V)
    (fun A : Elt =>
     ex2 (fun B : Word => x = couple A (word B))
       (fun B : Word => inmonoid (union X V) B)).

Lemma Regles_inv1 :
 forall (X V R : Ensf) (x y : Elt),
 Regles X V R -> dans (couple x y) R -> dans x V.

Lemma Regles_inv2 :
 forall (X V R : Ensf) (x : Elt) (u : Word),
 Regles X V R -> dans (couple x (word u)) R -> inmonoid (union X V) u.

Definition isGram (X V R : Ensf) (S : Elt) : Prop :=
  Mots X /\ inter X V empty /\ dans S V /\ Regles X V R.

Section Easy_lemma_isGram.

Variable X V R : Ensf.
Variable S : Elt.
Let H := isGram X V R S.

Lemma isGram1 : H -> Mots X.

Lemma isGram2 : H -> inter X V empty.

Lemma isGram3 : H -> dans S V.

Lemma isGram4 : H -> Regles X V R.

Lemma isGram5 : Mots X -> inter X V empty -> dans S V -> Regles X V R -> H.

End Easy_lemma_isGram.

Lemma Regles_R :
 forall X V R R' : Ensf, inclus R' R -> Regles X V R -> Regles X V R'.

Lemma Regles_V :
 forall X V R V' : Ensf, inclus V V' -> Regles X V R -> Regles X V' R.

Lemma Regles_add :
 forall (X V R : Ensf) (a : Elt) (u : Word),
 Regles X V R ->
 dans a V -> inmonoid (union X V) u -> Regles X V (add (couple a (word u)) R).

Lemma Regles_add2 :
 forall (X V R : Ensf) (a : Elt), Regles X V R -> Regles X (add a V) R.

Lemma Regles_union :
 forall X V R R' : Ensf,
 Regles X V R -> Regles X V R' -> Regles X V (union R R').

Lemma isGram_inclus2 :
 forall (X V R R' : Ensf) (S : Elt),
 inclus R' R -> isGram X V R S -> isGram X V R' S.

Lemma isGram_inclus3 :
 forall (X V R : Ensf) (S a : Elt), isGram X V (add a R) S -> isGram X V R S.

Inductive Derive (R : Ensf) : Word -> Word -> Prop :=
 
  | Derive1 :
      forall (u v : Word) (A : Elt),
      dans (couple A (word u)) R ->
      Derive R (cons A v) (Append u v)
      
  | Derive2 :
      forall (u v : Word) (x : Elt),
      Derive R u v -> Derive R (cons x u) (cons x v).

Hint Resolve Derive1.
Hint Resolve Derive2.

Lemma Derive_inclus :
 forall (R1 R2 : Ensf) (u v : Word),
 inclus R1 R2 -> Derive R1 u v -> Derive R2 u v.

Definition Derive_inv (R : Ensf) (x y : Word) :=
  match x return Prop with
  | nil =>
        False
       
  | cons A w =>
      ex2 (fun u : Word => dans (couple A (word u)) R)
        (fun u : Word =>
         ex2 (fun v : Word => cons A v = x :>Word)
           (fun v : Word => Append u v = y :>Word)) \/
      ex2 (fun v : Word => Derive R w v)
        (fun v : Word => cons A v = y :>Word)
  end.

Lemma Derive_inv1 :
 forall (R : Ensf) (u v : Word), Derive R u v -> Derive_inv R u v.

Hint Resolve Derive_inv1.

Lemma Derive_inv2 :
 forall (R : Ensf) (x y : Word),
 Derive_inv R x y ->
 exists A : Elt,
   (exists2 w : Word,
      cons A w = x &
      (exists2 u : Word,
         dans (couple A (word u)) R &
         (exists2 v : Word, cons A v = x & Append u v = y)) \/
      (exists2 v : Word, Derive R w v & cons A v = y)).

Lemma Derive_inv3 :
 forall (R : Ensf) (x y : Word),
 Derive R x y ->
 exists A : _,
   (exists2 w : _,
      cons A w = x &
      (exists2 u : _,
         dans (couple A (word u)) R &
         (exists2 v : _, cons A v = x & Append u v = y)) \/
      (exists2 v : _, Derive R w v & cons A v = y)).

Lemma in_mon_X_Der_imp_inmon_X :
 forall (X V R : Ensf) (u v : Word),
 Regles X V R ->
 Derive R u v -> inmonoid (union X V) u -> inmonoid (union X V) v.

Definition Derivestar (R : Ensf) := Rstar Word (Derive R).

Hint Unfold Derivestar.

Lemma Derivestar_refl : forall (R : Ensf) (u : Word), Derivestar R u u.

Hint Resolve Derivestar_refl.

Lemma Derivestar_R :
 forall (R : Ensf) (u v w : Word),
 Derive R u v -> Derivestar R v w -> Derivestar R u w.

Lemma Derivestar_inv :
 forall (R : Ensf) (u v : Word),
 Derivestar R u v ->
 u = v \/ (exists2 w : Word, Derive R u w & Derivestar R w v).

Hint Resolve Derivestar_inv.

Lemma Derivestar_inclus :
 forall (R1 R2 : Ensf) (u v : Word),
 inclus R1 R2 -> Derivestar R1 u v -> Derivestar R2 u v.

Definition LG (X V R : Ensf) (S : Elt) : wordset :=
  fun w : Word => Derivestar R (cons S nil) w /\ inmonoid X w.

Lemma LG_inv :
 forall (X V R : Ensf) (S : Elt) (w : Word), LG X V R S w -> inmonoid X w.

Lemma LG_langage :
 forall (X V R : Ensf) (S : Elt), isGram X V R S -> islanguage X (LG X V R S).

Definition Gunion (V1 R1 V2 R2 : Ensf) := (union V1 V2, union R1 R2).

Section injprod.

Let injproduc (f : Elt -> Elt) (V : Ensf) := extension V f.

Definition injproducg : Ensf -> Elt -> Elt := injproduc injgauche.

Definition injproducd : Ensf -> Elt -> Elt := injproduc injdroite.
					
End injprod.

Definition Gunion_disj_p (V1 R1 : Ensf) (S1 : Elt) 
  (V2 R2 : Ensf) (S2 S : Elt) :=
  (add S (fst (Gunion V1 R1 V2 R2)),
  (add (couple S (word (cons S1 nil)))
     (add (couple S (word (cons S2 nil))) (snd (Gunion V1 R1 V2 R2))), S)).

Definition imageGram (f : Elt -> Elt) (X V R : Ensf) 
  (S : Elt) :=
  (map f X,
  (map f V,
  (map
     (fun P : Elt =>
      couple (f (first P))
        ((fun w : Elt => word (Word_ext f (word_inv w))) (second P))) R, 
  f S))). *)
Require Import gram_aut.
(* gram_aut:
Require Import Ensf.
Require Import Words.
Require Import more_words.
Require Import need.
Require Import Relations.

Require Import gram.
Require Import gram_g.
Require Import PushdownAutomata.

Section APD.

Variable X V R : Ensf.
Variable S' : Elt.

Hypothesis Gram : isGram X V R S'.

Lemma Regles_X_V_R : Regles X V R.

Let P := union X V.

Let f_R_d (a : Elt) :=
  couple (word (cons (first a) nil)) (couple (eps X) (second a)).

Let f_X_d (x : Elt) := couple (word (cons x nil)) (couple x (word nil)).

Let d := union (map f_R_d R) (map f_X_d X).

Let wd := cons S' nil.

Let wa := nil.

Lemma Trans : Transition X P d.

Lemma X_P_wd_wa_d : P_automata X P wd wa d.

Lemma cut_spec :
 forall u : Word,
 {a : Word & 
 {b : Word |
 inmonoid X a /\
 Append a b = u /\
 (b = nil \/
  ex2 (fun x : Elt => ~ dans x X)
    (fun x : Elt => exists w : Word, b = cons x w))}}.

Definition cut (u : Word) :=
  let (a, s) := cut_spec u in (a, let (b, s2) := s in b).

Definition cut1 (u : Word) := fst (cut u).
Definition cut2 (u : Word) := snd (cut u).

Lemma cut_unicite :
 forall u a b a' b' : Word,
 inmonoid X a /\
 Append a b = u /\
 (b = nil \/
  ex2 (fun x : Elt => ~ dans x X)
    (fun x : Elt => exists w : Word, b = cons x w)) ->
 inmonoid X a' /\
 Append a' b' = u /\
 (b' = nil \/
  ex2 (fun x : Elt => ~ dans x X)
    (fun x : Elt => exists w : Word, b' = cons x w)) -> 
 a = a'.

Lemma inmonoid_cut1 : forall w : Word, inmonoid X (cut1 w).

Lemma cut_Append : forall w : Word, w = Append (cut1 w) (cut2 w).

Lemma cut1_cons :
 forall (a : Elt) (w : Word), dans a X -> cut1 (cons a w) = cons a (cut1 w).

Lemma cut1_Append :
 forall u v : Word, inmonoid X u -> cut1 (Append u v) = Append u (cut1 v).

Axiom
  cut2_cons :
    forall (A : Elt) (v : Word), dans A X -> cut2 (cons A v) = cut2 v.

Lemma cut2_cons_N :
 forall (A : Elt) (v : Word), ~ dans A X -> cut2 (cons A v) = cons A v.

Lemma Deriveg_imp_Deriveg_cut :
 forall x y : Word,
 Deriveg X R x y ->
 ex2 (fun w : Word => Append (cut1 x) w = y)
   (fun w : Word => Deriveg X R (cut2 x) w).

Lemma Deriveg_imp_Deriveg_App :
 forall x y : Word,
 Deriveg X R x y ->
 forall u v : Word,
 Append u v = x ->
 inmonoid X u ->
 ex2 (fun w : Word => Append u w = y) (fun w : Word => Deriveg X R v w).

Lemma Derivegstar_imp_Der_inmon :
 forall x y : Word,
 Derivegstar X R x y ->
 forall u v : Word,
 Append u v = x ->
 inmonoid X u ->
 ex2 (fun w : Word => Append u w = y) (fun w : Word => Derivegstar X R v w).

Inductive Derive_P_A_2 : Conf -> Conf -> Prop :=
  | Derive_X :
      forall (w u : Word) (x : Elt),
      dans x X -> Derive_P_A_2 (cons x w, cons x u) (w, u)
  | Derive_V :
      forall (v w u : Word) (x : Elt),
      dans (couple x (word u)) R ->
      Derive_P_A_2 (cons x w, v) (Append u w, v).

Definition Derive_P_A_2_nind (x y : Conf) :=
  ex2 (fun a : Elt => dans a X)
    (fun a : Elt => fst x = cons a (fst y) /\ snd x = cons a (snd y)) \/
  (exists a : Elt,
     ex2 (fun w : Word => cons a w = fst x)
       (fun w : Word =>
        ex2 (fun u : Word => dans (couple a (word u)) R)
          (fun u : Word => Append u w = fst y))).

Lemma Derive_P_A_2_inv :
 forall x y : Conf, Derive_P_A_2 x y -> Derive_P_A_2_nind x y.

Definition Derivestar_P_A_2 := Rstar Conf Derive_P_A_2.

Lemma Der_cons_inv :
 forall (x : Elt) (u v : Word),
 dans x X ->
 Derivestar_P_A_2 (cons x u, v) (nil, nil) ->
 ex2 (fun v2 : Word => v = cons x v2)
   (fun v2 : Word => Derivestar_P_A_2 (u, v2) (nil, nil)).

Lemma Derive_P_A_2_imp_Der_P_A_2_App :
 forall x y : Word,
 Derivestar_P_A_2 (x, y) (nil, nil) ->
 forall u v : Word,
 Append u v = x ->
 inmonoid X u ->
 ex2 (fun w : Word => Append u w = y)
   (fun w : Word => Derivestar_P_A_2 (v, w) (nil, nil)).

Lemma Derive_P_A_2_imp_Der_P_A_2_cons :
 forall (u : Elt) (x y : Word),
 Derivestar_P_A_2 (cons u x, y) (nil, nil) ->
 dans u X ->
 ex2 (fun w : Word => cons u w = y)
   (fun w : Word => Derivestar_P_A_2 (x, w) (nil, nil)).

Lemma Derivestar_P_A_2_x :
 forall x : Word, inmonoid X x -> Derivestar_P_A_2 (x, x) (nil, nil).
Hint Resolve Derivestar_P_A_2_x.

Lemma Derivegstar_imp_Derivestar_P_A_2 :
 forall x y : Word,
 Derivegstar X R x y -> inmonoid X y -> Derivestar_P_A_2 (x, y) (nil, nil).
Hint Resolve Derivegstar_imp_Derivestar_P_A_2.

Lemma Derive_P_A_2_imp_Derive_P_A :
 forall x y : Word * Word, Derive_P_A_2 x y -> Derive_P_A X d x y.
Hint Resolve Derive_P_A_2_imp_Derive_P_A.

Lemma Derivestar_P_A_2_imp_Derivestar_P_A :
 forall x y : Word * Word, Derivestar_P_A_2 x y -> Derivestar_P_A X d x y.
Hint Resolve Derivestar_P_A_2_imp_Derivestar_P_A.

Lemma Derive_P_A_imp_Derive_P_A_2 :
 forall x y : Word * Word, Derive_P_A X d x y -> Derive_P_A_2 x y.
Hint Resolve Derive_P_A_imp_Derive_P_A_2.

Lemma Derivestar_P_A_imp_Derivestar_P_A_2 :
 forall x y : Word * Word, Derivestar_P_A X d x y -> Derivestar_P_A_2 x y.

Hint Resolve Derivestar_P_A_imp_Derivestar_P_A_2.

Theorem Derivestar_imp_Derivestar_P_A :
 forall x y : Word,
 Derivestar R x y -> inmonoid X y -> Derivestar_P_A X d (x, y) (nil, nil).

Inductive Derive_P_A_3 : Word * Conf -> Word * Conf -> Prop :=
  | Derive3_X :
      forall (w u s : Word) (x : Elt),
      dans x X ->
      Derive_P_A_3 (s, (cons x w, cons x u)) (Append s (cons x nil), (w, u))
  | Derive3_V :
      forall (v w u s : Word) (x : Elt),
      dans (couple x (word u)) R ->
      Derive_P_A_3 (s, (cons x w, v)) (s, (Append u w, v)).

Definition Derivestar_P_A_3 := Rstar (Word * Conf) Derive_P_A_3.

Lemma Conserve_App_s_u :
 forall s1 s2 u1 u2 v1 v2 : Word,
 Derive_P_A_3 (s1, (u1, v1)) (s2, (u2, v2)) -> Append s1 v1 = Append s2 v2.

Lemma Derisvestar_P_A_3_conserve :
 forall s1 s2 u1 u2 v1 v2 : Word,
 Derivestar_P_A_3 (s1, (u1, v1)) (s2, (u2, v2)) ->
 Append s1 v1 = Append s2 v2.

Lemma Derive_P_A_2_imp_Derive_P_A_3 :
 forall (s : Word) (x y : Conf),
 Derive_P_A_2 x y -> exists s2 : Word, Derive_P_A_3 (s, x) (s2, y).

Lemma Derivestar_P_A_2_imp_Derivestar_P_A_3 :
 forall x y : Conf,
 Derivestar_P_A_2 x y ->
 forall s : Word, exists s2 : Word, Derivestar_P_A_3 (s, x) (s2, y).

Lemma Deriveg_imp_Deriveg_App_2 :
 forall x y a : Word,
 inmonoid X a -> Deriveg X R x y -> Deriveg X R (Append a x) (Append a y).

Lemma Derive_P_A_3_imp_Derivegstar :
 forall x y x' y' s s' : Word,
 Derive_P_A_3 (s, (x, y)) (s', (x', y')) ->
 inmonoid X s -> Derivegstar X R (Append s x) (Append s' x').

Lemma Derive_P_A_3_conserve_inmonoid_s :
 forall x y x' y' s s' : Word,
 Derive_P_A_3 (s, (x, y)) (s', (x', y')) -> inmonoid X s -> inmonoid X s'.

Lemma Derivestar_P_A_3_imp_Derivegstar :
 forall x y x' y' s s' : Word,
 Derivestar_P_A_3 (s, (x, y)) (s', (x', y')) ->
 inmonoid X s -> Derivegstar X R (Append s x) (Append s' x').

Theorem Derivestar_P_A_imp_Derivestar :
 forall x y : Word, Derivestar_P_A X d (x, y) (nil, nil) -> Derivestar R x y.

Hint Resolve Derivestar_P_A_imp_Derivestar.

Theorem equiv_APD_Gram : l_egal (LA X wd wa d) (LG X V R S').

End APD. *)

Section def_axiom_APD.

Variable X P : Ensf.
Variable wd : Word.
Variable wa : Word.
Variable d : Ensf.
Let L := LA X wd wa d.

Axiom axiom_APD : P_automata X P wd wa d -> forall u : Word, {L u} + {~ L u}.

End def_axiom_APD.

Section parser.

Variable X V R : Ensf.
Variable S' : Elt.
Hypothesis H : isGram X V R S'.
Let LL := LG X V R S'.

Let P := union X V.

Let f_R_d (a : Elt) :=
  couple (word (cons (first a) nil)) (couple (eps X) (second a)).

Let f_X_d (x : Elt) := couple (word (cons x nil)) (couple x (word nil)).

Let d := union (map f_R_d R) (map f_X_d X).

Let wd := cons S' nil.

Let wa := nil.

Let L := LA X wd wa d.

Theorem Parser1 : forall u : Word, {LL u} + {~ LL u}.
intros.
elimtype ({L u} + {~ L u}).

intro Hyp.
left.
cut (l_egal L LL).
intro temp; elim temp.
unfold l_inclus in |- *.
intros.
auto.
unfold L, LL, wa, wd, d, f_R_d, f_X_d in |- *.
apply equiv_APD_Gram.
exact H.

unfold not in |- *.
intro Hyp.
right.
intro LL_u.
apply Hyp.
cut (l_egal L LL).
intro temp; elim temp.
unfold l_inclus in |- *.
intros.
auto.
unfold L, LL, wa, wd, d, f_R_d, f_X_d in |- *.
apply equiv_APD_Gram.
exact H.

unfold L in |- *.
apply axiom_APD with P.
unfold P, wd, wa, d, f_R_d, f_X_d in |- *.
apply X_P_wd_wa_d.
exact H.
Qed.

End parser.