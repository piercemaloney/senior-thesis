

Require Import Ensf.
(* Ensf:
Require Export Ensf_types.

Require Export Ensf_dans.

Require Export Ensf_union.

Require Export Ensf_couple.

Require Export Ensf_produit.

Require Export Ensf_inclus.

Require Export Ensf_inter.

Require Export Ensf_map.

Require Export Ensf_disj. *)

Require Import Words.
(* Words:
Require Import Ensf.

Parameter alph : Ensf.
Parameter epsilon : Elt.
  Axiom not_dans_epsilon_alph : ~ dans epsilon alph.

Inductive inmonoid (X : Ensf) : Word -> Prop :=
  | inmonoid_nil : inmonoid X nil
  | inmonoid_cons :
      forall (w : Word) (e : Elt),
      inmonoid X w -> dans e X -> inmonoid X (cons e w).
Hint Resolve inmonoid_nil.
Hint Resolve inmonoid_cons.

Fixpoint Inmonoid (X : Ensf) (w : Word) {struct w} : Prop :=
  match w with
  | nil => True
  | cons a w' => dans a X /\ Inmonoid X w'
  end.

Lemma i_I : forall (X : Ensf) (w : Word), inmonoid X w -> Inmonoid X w.
Hint Resolve i_I.

Lemma I_i : forall (X : Ensf) (w : Word), Inmonoid X w -> inmonoid X w.
Hint Resolve I_i.

Lemma inmonoid_cons_inv :
 forall (X : Ensf) (w : Word) (a : Elt),
 inmonoid X (cons a w) -> inmonoid X w.

Lemma inmonoid_cons_inv2 :
 forall (X : Ensf) (a : Elt) (w : Word), inmonoid X (cons a w) -> dans a X.

Lemma inmonoid_inclus :
 forall (E F : Ensf) (x : Word), inclus E F -> inmonoid E x -> inmonoid F x.

Fixpoint Append (w1 : Word) : Word -> Word :=
  fun w2 : Word =>
  match w1 with
  | nil => w2
  | cons a w3 => cons a (Append w3 w2)
  end.

Lemma Append_w_nil : forall w : Word, Append w nil = w :>Word.

Inductive append : Word -> Word -> Word -> Prop :=
  | append_nil : forall w : Word, append nil w w
  | append_cons :
      forall (w1 w2 w3 : Word) (a : Elt),
      append w1 w2 w3 -> append (cons a w1) w2 (cons a w3).

Lemma Append_inmonoid_g :
 forall (X : Ensf) (w1 w2 : Word), inmonoid X (Append w1 w2) -> inmonoid X w1.

Lemma Append_inmonoid_d :
 forall (X : Ensf) (w1 w2 : Word), inmonoid X (Append w1 w2) -> inmonoid X w2.

Lemma inmonoid_Append :
 forall (X : Ensf) (w1 w2 : Word),
 inmonoid X w1 -> inmonoid X w2 -> inmonoid X (Append w1 w2).

Definition wordset := Word -> Prop.

Definition eqwordset (l1 l2 : wordset) : Prop :=
  forall w : Word, (l1 w -> l2 w) /\ (l2 w -> l1 w).

Lemma eqwordset_refl : forall L : wordset, eqwordset L L.

Lemma eqwordset_sym :
 forall l1 l2 : wordset, eqwordset l1 l2 -> eqwordset l2 l1.

Lemma eqwordset_trans :
 forall l1 l2 l3 : wordset,
 eqwordset l1 l2 -> eqwordset l2 l3 -> eqwordset l1 l3.

Definition islanguage (X : Ensf) (L : wordset) : Prop :=
  forall w : Word, L w -> inmonoid X w.

Fixpoint Word_ext (f : Elt -> Elt) (w : Word) {struct w} : Word :=
  match w with
  | nil => nil
  | cons a w' => cons (f a) (Word_ext f w')
  end.

Lemma inmonoid_map :
 forall (f : Elt -> Elt) (a : Ensf) (w : Word),
 inmonoid a w -> inmonoid (map f a) (Word_ext f w).
Hint Resolve inmonoid_map.

Lemma cons_cons :
 forall (x1 x2 : Elt) (w1 w2 : Word),
 x1 = x2 :>Elt -> w1 = w2 :>Word -> cons x1 w1 = cons x2 w2 :>Word.
Hint Resolve cons_cons.

Definition fun_consaw_a (w : Word) : Elt :=
  match w return Elt with
  | nil =>
        zero
       
  | cons a w' => a
  end.

Definition fun_consaw_w (w : Word) : Word :=
  match w return Word with
  | nil =>
        nil
       
  | cons a w' => w'
  end.

Lemma cons_cons_inv :
 forall (x1 x2 : Elt) (w1 w2 : Word),
 cons x1 w1 = cons x2 w2 -> x1 = x2 /\ w1 = w2.

Hint Resolve cons_cons_inv.

Lemma cons_cons_inv1 :
 forall (x1 x2 : Elt) (w1 w2 : Word),
 cons x1 w1 = cons x2 w2 :>Word -> x1 = x2 :>Elt.

Lemma cons_cons_inv2 :
 forall (x1 x2 : Elt) (w1 w2 : Word), cons x1 w1 = cons x2 w2 -> w1 = w2.

Lemma nil_or_cons :
 forall w : Word,
 w = nil \/ (exists x : Elt, (exists w0 : Word, w = cons x w0)). *)

Require Import more_words.
(* more_words:
Require Import Ensf.
Require Import Words.

Hint Unfold eqwordset .

Definition l_inclus (l1 l2 : wordset) : Prop := forall w : Word, l1 w -> l2 w.

Hint Unfold l_inclus.

Lemma refl_l_inclus : forall l1 : wordset, l_inclus l1 l1.
Hint Resolve refl_l_inclus.

Lemma trans_l_inclus :
 forall l1 l2 l3 : wordset,
 l_inclus l1 l2 -> l_inclus l2 l3 -> l_inclus l1 l3.

Definition l_egal (l1 l2 : wordset) : Prop :=
  l_inclus l1 l2 /\ l_inclus l2 l1.

Hint Unfold l_egal.

Lemma equiv_l_egal_eqwordset :
 forall a b : wordset, l_egal a b <-> eqwordset a b.

Lemma refl_l_egal : forall l1 : wordset, l_egal l1 l1.
Hint Resolve refl_l_egal.

Section more_about_words.

Variable f : Elt -> Elt. 

Let wef := Word_ext f.

Lemma wef_append :
 forall u v : Word, wef (Append u v) = Append (wef u) (wef v).

Lemma wef_nil : forall a : Word, wef a = nil -> a = nil.

Lemma wef_cons :
 forall (a b : Word) (e : Elt),
 cons e a = wef b ->
 exists x : Elt,
   ex2 (fun w : Word => cons x w = b) (fun w : Word => f x = e /\ wef w = a).

End more_about_words.

Hint Resolve wef_cons.

Lemma Append_assoc :
 forall a b c : Word, Append a (Append b c) = Append (Append a b) c.
Hint Resolve Append_assoc. *)

Require Import Rat.
(* Rat:
Require Import Ensf.
Require Import Words.

Definition lword (w : Word) : wordset := fun w1 : Word => w = w1 :>Word.

Definition lconc (l1 l2 : wordset) : wordset :=
  fun w : Word =>
  exists w1 : Word,
    (exists w2 : Word, l1 w1 /\ l2 w2 /\ w = Append w1 w2 :>Word).

Definition lunion (l1 l2 : wordset) : wordset := fun w : Word => l1 w \/ l2 w.

Definition linter (l1 l2 : wordset) : wordset := fun w : Word => l1 w /\ l2 w.

Fixpoint lpuiss (n : nat) : wordset -> wordset :=
  fun l : wordset =>
  match n return wordset with
  | O =>
        lword nil
       
  | S p => lconc l (lpuiss p l)
  end.

Definition lstar (l : wordset) : wordset :=
  fun w : Word => exists n : nat, lpuiss n l w.

Lemma induction_star :
 forall (P : Word -> Prop) (l : wordset),
 (forall (n : nat) (w : Word), lpuiss n l w -> P w) ->
 forall w : Word, lstar l w -> P w.

Lemma lw_imp_lstarlw : forall (l : wordset) (w : Word), l w -> lstar l w.

Inductive isrationnal : wordset -> Prop :=
  | israt_lword : forall w : Word, inmonoid alph w -> isrationnal (lword w)
  | israt_lunion :
      forall l1 l2 : wordset,
      isrationnal l1 -> isrationnal l2 -> isrationnal (lunion l1 l2)
  | israt_conc :
      forall l1 l2 : wordset,
      isrationnal l1 -> isrationnal l2 -> isrationnal (lconc l1 l2)
  | israt_lstar : forall l : wordset, isrationnal l -> isrationnal (lstar l). *)

Require Import need.
(* need:
Require Import Ensf.
Require Import Words.
Require Import more_words.

Axiom Dans_spec : forall (a : Elt) (E : Ensf), {dans a E} + {~ dans a E}.

Definition Dans (a : Elt) (E : Ensf) :=
  match Dans_spec a E return bool with
  | left a => true
  | right a => false
  end.

Axiom
  Append_Append :
    forall a a' b b' : Word,
    Append a b = Append a' b' ->
    exists w : Word,
      a = Append a' w /\ b' = Append w b \/
      a' = Append a w /\ b = Append w b'.

Axiom
  inmonoid_Append_inv2 :
    forall (X : Ensf) (a b : Word), inmonoid X (Append a b) -> inmonoid X b.

Hint Resolve dans_add. *)

Require Import fonctions.
(* fonctions:
Require Import Ensf.
Require Import Words.
Require Import more_words.
Require Import need.
Hint Resolve dans_map_inv.
Hint Resolve dans_map.
Hint Resolve dans_add1.

Definition comp (f g : Elt -> Elt) (x : Elt) := f (g x).

Lemma map_map_eg_map_comp :
 forall (f g : Elt -> Elt) (E : Ensf),
 map f (map g E) = map (comp f g) E :>Ensf.

Definition comp_word (f g : Word -> Word) (x : Word) := f (g x).

Definition eg_f_W_W (f g : Word -> Word) := forall x : Word, f x = g x :>Word.

Lemma comp_Word_ext :
 forall f g : Elt -> Elt,
 eg_f_W_W (Word_ext (comp f g)) (comp_word (Word_ext f) (Word_ext g)).
Hint Resolve comp_Word_ext.

Definition Id (E : Ensf) (f : Elt -> Elt) :=
  forall x : Elt, dans x E -> f x = x :>Elt.

Lemma Id_inv :
 forall (E : Ensf) (f : Elt -> Elt) (x : Elt),
 dans x E -> Id E f -> f x = x :>Elt.

Hint Unfold Id.

Lemma Id_inclus :
 forall (E F : Ensf) (f : Elt -> Elt), inclus F E -> Id E f -> Id F f.

Lemma map_Id :
 forall (E : Ensf) (f : Elt -> Elt), Id E f -> map f E = E :>Ensf.

Definition Id_words (E : Ensf) (f : Word -> Word) :=
  forall x : Word, inmonoid E x -> f x = x :>Word.

Lemma Id_words_inv :
 forall (E : Ensf) (f : Word -> Word) (x : Word),
 inmonoid E x -> Id_words E f -> f x = x :>Word.

Lemma Id_words_inclus :
 forall (E F : Ensf) (f : Word -> Word),
 inclus F E -> Id_words E f -> Id_words F f.

Lemma extension_Id :
 forall (E : Ensf) (f : Elt -> Elt), Id E f -> Id_words E (Word_ext f).

Section fonctions.

Variable E : Ensf.
Variable F : Ensf.
Variable f : Elt -> Elt.

Definition application := forall x : Elt, dans x E -> dans (f x) F.

Hint Unfold application.

Definition is_mono :=
  forall x y : Elt, dans x E -> dans y E -> f x = f y :>Elt -> x = y :>Elt.

Definition is_epi :=
  application /\
  (forall x : Elt, dans x F -> exists2 y : Elt, x = f y & dans y E).

Definition is_iso := is_epi /\ is_mono.

Lemma mono_epi_imp_iso : is_mono -> is_epi -> is_iso.

Variable fw : Word -> Word.

Definition application_words :=
  forall x : Word, inmonoid E x -> inmonoid F (fw x).

Definition is_mono_words :=
  forall x y : Word,
  inmonoid E x -> inmonoid E y -> fw x = fw y :>Word -> x = y :>Word.

Definition is_epi_words :=
  application_words /\
  (forall x : Word, inmonoid F x -> exists2 y : Word, x = fw y & inmonoid E y).

Definition is_iso_words := is_mono_words /\ is_epi_words.

Lemma mono_epi_imp_iso_words : is_mono_words -> is_epi_words -> is_iso_words.

End fonctions.

Hint Resolve mono_epi_imp_iso.

Parameter inv : Ensf -> Ensf -> (Elt -> Elt) -> Elt -> Elt.

Axiom
  dans_inv_f :
    forall (E F : Ensf) (f : Elt -> Elt),
    is_iso E F f -> forall x : Elt, dans x F -> dans (inv E F f x) E.
Hint Resolve dans_inv_f.

Axiom
  inv1 :
    forall (E F : Ensf) (f : Elt -> Elt),
    is_iso E F f -> forall x : Elt, dans x E -> inv E F f (f x) = x :>Elt.

Hint Resolve inv1.

Axiom
  inv2 :
    forall (E F : Ensf) (f : Elt -> Elt),
    is_iso E F f -> forall x : Elt, dans x F -> f (inv E F f x) = x :>Elt.

Hint Resolve inv2.

Lemma inv1' :
 forall (E F : Ensf) (f : Elt -> Elt),
 is_iso E F f -> Id E (comp (inv E F f) f).
Hint Resolve inv1'.

Axiom
  extension_spec :
    forall (V : Ensf) (f : Elt -> Elt) (x : Elt),
    {y : Elt | dans x V /\ y = f x :>Elt \/ ~ dans x V /\ y = x :>Elt}.

Definition extension (V : Ensf) (f : Elt -> Elt) (x : Elt) :=
  let (y, p) return Elt := extension_spec V f x in y.

Lemma extension_in :
 forall (e : Ensf) (f : Elt -> Elt) (x : Elt),
 dans x e -> extension e f x = f x :>Elt.

Lemma extension_out :
 forall (e : Ensf) (f : Elt -> Elt) (x : Elt),
 ~ dans x e -> extension e f x = x :>Elt.

Section fonctions2.

Variable E : Ensf.
Variable F : Ensf.
Variable f : Elt -> Elt.

Hint Unfold application.
Lemma is_epi_f_over_image : is_epi E (map f E) f.

Hint Resolve is_epi_f_over_image.

Lemma mono_imp_iso_over_image : is_mono E f -> is_iso E (map f E) f.

Let invf := inv E F f.

Hint Unfold invf.

Lemma inv_is_mono : is_iso E F f -> is_mono F invf.

Lemma inv_is_epi : is_iso E F f -> is_epi F E invf.

Let wef := Word_ext f.

Lemma application_imp_application_words :
 application E F f -> application_words E F wef.

Hint Resolve application_imp_application_words.

Lemma is_mono_f_imp_is_mono_words : is_mono E f -> is_mono_words E wef.

Hint Resolve is_mono_f_imp_is_mono_words.

Lemma is_epi_f_imp_is_epi_words : is_epi E F f -> is_epi_words E F wef.

Hint Resolve is_epi_f_imp_is_epi_words.

Lemma is_iso_f_imp_is_iso_words : is_iso E F f -> is_iso_words E F wef.

Let invf' := inv E F f.
Let weinvf := Word_ext invf'.
Let weinvf_wef := comp_word weinvf wef.

Lemma is_iso_f_imp_Id_words_weinvf_wef :
 is_iso E F f -> Id_words E weinvf_wef.

End fonctions2.
Hint Resolve mono_imp_iso_over_image. *)

Require Import Relations.
(* Relations:
Section Relations.

  Variable A : Set.  
  Variable R : A -> A -> Prop.  

Definition Rstar (x y : A) :=
  forall P : A -> A -> Prop,
  (forall u : A, P u u) ->
  (forall u v w : A, R u v -> P v w -> P u w) -> P x y.  

Theorem Rstar_reflexive : forall x : A, Rstar x x.
 Proof
   fun (x : A) (P : A -> A -> Prop) (h1 : forall u : A, P u u)
     (h2 : forall u v w : A, R u v -> P v w -> P u w) => 
   h1 x.  

Theorem Rstar_R : forall x y z : A, R x y -> Rstar y z -> Rstar x z.
 Proof
   fun (x y z : A) (t1 : R x y) (t2 : Rstar y z) (P : A -> A -> Prop)
     (h1 : forall u : A, P u u)
     (h2 : forall u v w : A, R u v -> P v w -> P u w) =>
   h2 x y z t1 (t2 P h1 h2).  

Theorem Rstar_transitive :
 forall x y z : A, Rstar x y -> Rstar y z -> Rstar x z.
 Proof
   fun (x y z : A) (h : Rstar x y) =>
   h (fun u v : A => Rstar v z -> Rstar u z)
     (fun (u : A) (t : Rstar u z) => t)
     (fun (u v w : A) (t1 : R u v) (t2 : Rstar w z -> Rstar v z)
        (t3 : Rstar w z) => Rstar_R u v z t1 (t2 t3)).  

Definition Rstar' (x y : A) :=
  forall P : A -> A -> Prop,
  P x x -> (forall u : A, R x u -> Rstar u y -> P x y) -> P x y.  

Theorem Rstar'_reflexive : forall x : A, Rstar' x x.
 Proof
   fun (x : A) (P : A -> A -> Prop) (h : P x x)
     (h' : forall u : A, R x u -> Rstar u x -> P x x) => h.
  
Theorem Rstar'_R : forall x y z : A, R x z -> Rstar z y -> Rstar' x y.
 Proof
   fun (x y z : A) (t1 : R x z) (t2 : Rstar z y) (P : A -> A -> Prop)
     (h1 : P x x) (h2 : forall u : A, R x u -> Rstar u y -> P x y) =>
   h2 z t1 t2.  

Theorem Rstar'_Rstar : forall x y : A, Rstar' x y -> Rstar x y.
 Proof
   fun (x y : A) (h : Rstar' x y) =>
   h Rstar (Rstar_reflexive x) (fun u : A => Rstar_R x u y).  
  
Theorem Rstar_Rstar' : forall x y : A, Rstar x y -> Rstar' x y.
 Proof
   fun (x y : A) (h : Rstar x y) =>
   h Rstar' (fun u : A => Rstar'_reflexive u)
     (fun (u v w : A) (h1 : R u v) (h2 : Rstar' v w) =>
      Rstar'_R u w v h1 (Rstar'_Rstar v w h2)).  

Lemma Rstar_inv :
 forall x y : A,
 Rstar x y -> x = y \/ ex2 (fun z : A => R x z) (fun z : A => Rstar z y).

End Relations.

Hint Resolve Rstar_reflexive. *)

Require Import gram.
(* gram:
Require Import Ensf.
Require Import Words.
Require Import more_words.
Require Import need.
Require Import fonctions.
Require Import Relations.

Definition Mots (X : Ensf) :=
  forall a : Elt, dans a X -> exists w : Word, word w = a.

Definition Regles (X V R : Ensf) :=
  forall x : Elt,
  dans x R ->
  ex2 (fun A : Elt => dans A V)
    (fun A : Elt =>
     ex2 (fun B : Word => x = couple A (word B))
       (fun B : Word => inmonoid (union X V) B)).

Lemma Regles_inv1 :
 forall (X V R : Ensf) (x y : Elt),
 Regles X V R -> dans (couple x y) R -> dans x V.

Lemma Regles_inv2 :
 forall (X V R : Ensf) (x : Elt) (u : Word),
 Regles X V R -> dans (couple x (word u)) R -> inmonoid (union X V) u.

Definition isGram (X V R : Ensf) (S : Elt) : Prop :=
  Mots X /\ inter X V empty /\ dans S V /\ Regles X V R.

Section Easy_lemma_isGram.

Variable X V R : Ensf.
Variable S : Elt.
Let H := isGram X V R S.

Lemma isGram1 : H -> Mots X.

Lemma isGram2 : H -> inter X V empty.

Lemma isGram3 : H -> dans S V.

Lemma isGram4 : H -> Regles X V R.

Lemma isGram5 : Mots X -> inter X V empty -> dans S V -> Regles X V R -> H.

End Easy_lemma_isGram.

Lemma Regles_R :
 forall X V R R' : Ensf, inclus R' R -> Regles X V R -> Regles X V R'.

Lemma Regles_V :
 forall X V R V' : Ensf, inclus V V' -> Regles X V R -> Regles X V' R.

Lemma Regles_add :
 forall (X V R : Ensf) (a : Elt) (u : Word),
 Regles X V R ->
 dans a V -> inmonoid (union X V) u -> Regles X V (add (couple a (word u)) R).

Lemma Regles_add2 :
 forall (X V R : Ensf) (a : Elt), Regles X V R -> Regles X (add a V) R.

Lemma Regles_union :
 forall X V R R' : Ensf,
 Regles X V R -> Regles X V R' -> Regles X V (union R R').

Lemma isGram_inclus2 :
 forall (X V R R' : Ensf) (S : Elt),
 inclus R' R -> isGram X V R S -> isGram X V R' S.

Lemma isGram_inclus3 :
 forall (X V R : Ensf) (S a : Elt), isGram X V (add a R) S -> isGram X V R S.

Inductive Derive (R : Ensf) : Word -> Word -> Prop :=
 
  | Derive1 :
      forall (u v : Word) (A : Elt),
      dans (couple A (word u)) R ->
      Derive R (cons A v) (Append u v)
      
  | Derive2 :
      forall (u v : Word) (x : Elt),
      Derive R u v -> Derive R (cons x u) (cons x v).

Hint Resolve Derive1.
Hint Resolve Derive2.

Lemma Derive_inclus :
 forall (R1 R2 : Ensf) (u v : Word),
 inclus R1 R2 -> Derive R1 u v -> Derive R2 u v.

Definition Derive_inv (R : Ensf) (x y : Word) :=
  match x return Prop with
  | nil =>
        False
       
  | cons A w =>
      ex2 (fun u : Word => dans (couple A (word u)) R)
        (fun u : Word =>
         ex2 (fun v : Word => cons A v = x :>Word)
           (fun v : Word => Append u v = y :>Word)) \/
      ex2 (fun v : Word => Derive R w v)
        (fun v : Word => cons A v = y :>Word)
  end.

Lemma Derive_inv1 :
 forall (R : Ensf) (u v : Word), Derive R u v -> Derive_inv R u v.

Hint Resolve Derive_inv1.

Lemma Derive_inv2 :
 forall (R : Ensf) (x y : Word),
 Derive_inv R x y ->
 exists A : Elt,
   (exists2 w : Word,
      cons A w = x &
      (exists2 u : Word,
         dans (couple A (word u)) R &
         (exists2 v : Word, cons A v = x & Append u v = y)) \/
      (exists2 v : Word, Derive R w v & cons A v = y)).

Lemma Derive_inv3 :
 forall (R : Ensf) (x y : Word),
 Derive R x y ->
 exists A : _,
   (exists2 w : _,
      cons A w = x &
      (exists2 u : _,
         dans (couple A (word u)) R &
         (exists2 v : _, cons A v = x & Append u v = y)) \/
      (exists2 v : _, Derive R w v & cons A v = y)).

Lemma in_mon_X_Der_imp_inmon_X :
 forall (X V R : Ensf) (u v : Word),
 Regles X V R ->
 Derive R u v -> inmonoid (union X V) u -> inmonoid (union X V) v.

Definition Derivestar (R : Ensf) := Rstar Word (Derive R).

Hint Unfold Derivestar.

Lemma Derivestar_refl : forall (R : Ensf) (u : Word), Derivestar R u u.

Hint Resolve Derivestar_refl.

Lemma Derivestar_R :
 forall (R : Ensf) (u v w : Word),
 Derive R u v -> Derivestar R v w -> Derivestar R u w.

Lemma Derivestar_inv :
 forall (R : Ensf) (u v : Word),
 Derivestar R u v ->
 u = v \/ (exists2 w : Word, Derive R u w & Derivestar R w v).

Hint Resolve Derivestar_inv.

Lemma Derivestar_inclus :
 forall (R1 R2 : Ensf) (u v : Word),
 inclus R1 R2 -> Derivestar R1 u v -> Derivestar R2 u v.

Definition LG (X V R : Ensf) (S : Elt) : wordset :=
  fun w : Word => Derivestar R (cons S nil) w /\ inmonoid X w.

Lemma LG_inv :
 forall (X V R : Ensf) (S : Elt) (w : Word), LG X V R S w -> inmonoid X w.

Lemma LG_langage :
 forall (X V R : Ensf) (S : Elt), isGram X V R S -> islanguage X (LG X V R S).

Definition Gunion (V1 R1 V2 R2 : Ensf) := (union V1 V2, union R1 R2).

Section injprod.

Let injproduc (f : Elt -> Elt) (V : Ensf) := extension V f.

Definition injproducg : Ensf -> Elt -> Elt := injproduc injgauche.

Definition injproducd : Ensf -> Elt -> Elt := injproduc injdroite.
					
End injprod.

Definition Gunion_disj_p (V1 R1 : Ensf) (S1 : Elt) 
  (V2 R2 : Ensf) (S2 S : Elt) :=
  (add S (fst (Gunion V1 R1 V2 R2)),
  (add (couple S (word (cons S1 nil)))
     (add (couple S (word (cons S2 nil))) (snd (Gunion V1 R1 V2 R2))), S)).

Definition imageGram (f : Elt -> Elt) (X V R : Ensf) 
  (S : Elt) :=
  (map f X,
  (map f V,
  (map
     (fun P : Elt =>
      couple (f (first P))
        ((fun w : Elt => word (Word_ext f (word_inv w))) (second P))) R, 
  f S))). *)

Require Import gram2.
(* gram2:
Require Import Ensf.
Require Import Words.
Require Import more_words.
Require Import need.
Require Import fonctions.
Require Import Relations.
Require Import gram.

Hint Resolve extension_Id.
Section resultats.

Variable X V1 R1 : Ensf.
Variable S1 : Elt.
Variable V2 R2 : Ensf.
Variable S2 : Elt.

Let C := Gunion V1 R1 V2 R2.
Let Vu := fst C.
Let Ru := snd C.

Lemma inter_X_Vu : isGram X V1 R1 S1 -> isGram X V2 R2 S2 -> inter X Vu empty.

Lemma Gunion_Regles :
 isGram X V1 R1 S1 -> isGram X V2 R2 S2 -> Regles X Vu Ru.

Lemma inmon_Der_imp_Der :
 Regles X V1 R1 ->
 Regles X V2 R2 ->
 inter (union X V1) V2 empty ->
 forall u v : Word, Derive Ru u v -> inmonoid (union X V1) u -> Derive R1 u v.

Lemma inmon_Der_imp_inmon_R1 :
 forall u v : Word,
 Regles X V1 R1 ->
 Derive R1 u v -> inmonoid (union X V1) u -> inmonoid (union X V1) v.

Lemma inmon_Der_imp_inmon :
 forall u v : Word,
 isGram X V1 R1 S1 ->
 isGram X V2 R2 S2 ->
 inter V1 V2 empty ->
 inmonoid (union X V1) u -> Derive Ru u v -> inmonoid (union X V1) v.

Lemma Gunion_Derivestar :
 isGram X V1 R1 S1 ->
 isGram X V2 R2 S2 ->
 inter V1 V2 empty ->
 forall u v : Word,
 Derivestar Ru u v -> inmonoid (union X V1) u -> Derivestar R1 u v.

Lemma inmon_Der_imp_Der2 :
 Regles X V1 R1 ->
 Regles X V2 R2 ->
 inter (union X V2) V1 empty ->
 forall u v : Word, Derive Ru u v -> inmonoid (union X V2) u -> Derive R2 u v.

Lemma inmon_Der_imp_inmon_R2 :
 forall u v : Word,
 Regles X V2 R2 ->
 Derive R2 u v -> inmonoid (union X V2) u -> inmonoid (union X V2) v.

Lemma inmon_Der_imp_inmon_2 :
 forall u v : Word,
 isGram X V1 R1 S1 ->
 isGram X V2 R2 S2 ->
 inter V1 V2 empty ->
 inmonoid (union X V2) u -> Derive Ru u v -> inmonoid (union X V2) v.

Lemma Gunion_Derivestar2 :
 isGram X V1 R1 S1 ->
 isGram X V2 R2 S2 ->
 inter V1 V2 empty ->
 forall u v : Word,
 Derivestar Ru u v -> inmonoid (union X V2) u -> Derivestar R2 u v.

Lemma Gunion_isGram :
 forall S : Elt,
 isGram X V1 R1 S1 -> isGram X V2 R2 S2 -> dans S Vu -> isGram X Vu Ru S.

Variable f : Elt -> Elt.

Let wef := Word_ext f.
Let fet (w : Elt) := word (wef (word_inv w)).
Let fonc (P : Elt) := couple (f (first P)) (fet (second P)).

Let Gim := imageGram f X V1 R1 S1.
Let Xim := fst Gim.
Let Gim2 := snd Gim.
Let Vim := fst Gim2.
Let Gim3 := snd Gim2.
Let Rim := fst Gim3.
Let Sim := snd Gim3.

Lemma dans_Rim :
 forall (A : Elt) (u : Word),
 dans (couple A (word u)) R1 -> dans (couple (f A) (word (wef u))) Rim.
Hint Resolve dans_Rim.

Lemma image_Regles : Regles X V1 R1 -> Regles Xim Vim Rim.

Lemma image_isGram :
 isGram X V1 R1 S1 ->
 Mots Xim -> inter Xim Vim empty -> isGram Xim Vim Rim Sim.

Lemma Id_image_X : Id (union X V1) f -> Xim = X :>Ensf.

Lemma Id_image_V : Id (union X V1) f -> Vim = V1 :>Ensf.

Lemma Id_image_R : Id (union X V1) f -> isGram X V1 R1 S1 -> Rim = R1 :>Ensf.

Lemma Id_image_S : Id (union X V1) f -> isGram X V1 R1 S1 -> Sim = S1 :>Elt.

Lemma Gim_egal : Gim = (Xim, (Vim, (Rim, Sim))).

Lemma Id_image_G :
 Id (union X V1) f -> isGram X V1 R1 S1 -> Gim = (X, (V1, (R1, S1))).

Lemma Derive_image :
 forall u v : Word, Derive R1 u v -> Derive Rim (wef u) (wef v).

Hint Resolve Derive_image.

Lemma Derivestar_image :
 forall u v : Word, Derivestar R1 u v -> Derivestar Rim (wef u) (wef v).

Hint Resolve Derivestar_image.

Lemma Reconnait_imageGram :
 forall w : Word, LG X V1 R1 S1 w -> LG Xim Vim Rim Sim (wef w).

End resultats.

Hint Resolve dans_Rim.
Hint Resolve Derive_image.
Hint Resolve Derivestar_image.
Hint Resolve Reconnait_imageGram. *)

Require Import gram3.
(* gram3:
Require Import Ensf.
Require Import Words.
Require Import more_words.
Require Import need.
Require Import fonctions.
Require Import Relations.
Require Import gram.
Require Import gram2.

Section resultats_iso_image.

Variable X V R : Ensf.
Variable S : Elt.
Variable f : Elt -> Elt.

Let Gim := imageGram f X V R S.
Let Xim := fst Gim.
Let Gim2 := snd Gim.
Let Vim := fst Gim2.
Let Gim3 := snd Gim2.
Let Rim := fst Gim3.
Let Sim := snd Gim3.

Let invf := inv (union X V) (union Xim Vim) f.

Let Gim' := imageGram invf Xim Vim Rim Sim.
Let Xim' := fst Gim'.
Let Gim2' := snd Gim'.
Let Vim' := fst Gim2'.
Let Gim3' := snd Gim2'.
Let Rim' := fst Gim3'.
Let Sim' := snd Gim3'.

Hypothesis Gram : isGram X V R S.

Lemma Regles_X_V_R : Regles X V R.
Proof isGram4 X V R S Gram.

Hypothesis Mono : is_mono (union X V) f.

Lemma inter_Xim_Vim_empty : inter Xim Vim empty.

Lemma union_Xim_Vim_map_f_union_X_V :
 union Xim Vim = map f (union X V) :>Ensf.

Lemma Iso : is_iso (union X V) (union Xim Vim) f.

Hint Resolve Iso.

Let wef := Word_ext f.
Let weinvf := Word_ext invf.

Lemma invf_f : Id (union X V) (comp invf f).

Lemma weinvf_wef : Id_words (union X V) (comp_word weinvf wef).

Let Rf (g : Elt -> Elt) (P : Elt) :=
  couple (g (first P)) (word (Word_ext g (word_inv (second P)))).

Lemma comp_Rf :
 forall (g f : Elt -> Elt) (x : Elt),
 dans x R -> comp (Rf g) (Rf f) x = Rf (comp g f) x :>Elt.

Lemma egalGim'_image_comp :
 Gim' = imageGram (comp invf f) X V R S :>Ensf * (Ensf * (Ensf * Elt)).

Lemma egalG : Gim' = (X, (V, (R, S))).

Lemma egalS : Sim' = S :>Elt.

Lemma egalR : Rim' = R :>Ensf.

Lemma egalX : Xim' = X :>Ensf.

Lemma egalV : Vim' = V :>Ensf.

Lemma Reconnait_imageGram_iso :
 forall w : Word, inmonoid X w -> LG Xim Vim Rim Sim (wef w) -> LG X V R S w.

Lemma egal_Xim : Id X f -> Xim = X :>Ensf.

Lemma egal_LG : Id X f -> l_egal (LG X V R S) (LG Xim Vim Rim Sim).
		
End resultats_iso_image. *)



Section gram4.



Variable X V1 R1 : Ensf.

Variable S1 : Elt.



Variable V2 R2 : Ensf.

Variable S2 : Elt.



Variable S : Elt.

Let C := Gunion_disj_p V1 R1 S1 V2 R2 S2 S.

Let Vu := fst C.

Let C' := snd C.

Let Ru := fst C'.

Let Su := snd C'.



Lemma inter_X_V1_u_V2 :

 isGram X V1 R1 S1 -> isGram X V2 R2 S2 -> inter X (union V1 V2) empty.



prolog [ isGram2 union_inter ] 5.



Qed.



Lemma inter_X_Vu_d :

 isGram X V1 R1 S1 -> isGram X V2 R2 S2 -> ~ dans S X -> inter X Vu empty.

intros G_1 G_2 N_dans_S_X.

unfold inter in |- *.

split.

 auto.

 split.

  auto.

  intros x dans_x_X dans_x_Vu.

  absurd (dans x X).

  cut (S = x :>Elt \/ dans x (union V1 V2)). 

  intro temp; elim temp; clear temp.

	intros egal_S_x.

	rewrite <- egal_S_x; assumption.



	intro dans_x_V1_u_V2.

	prolog [ inter_X_V1_u_V2 sym_inter inter_dans ] 4.

	
  auto.



  assumption.

Qed.



Lemma Gunion_disj_Regles :

 isGram X V1 R1 S1 -> isGram X V2 R2 S2 -> Regles X Vu Ru.

intros.

unfold Vu, Ru in |- *; simpl in |- *.

apply Regles_add.

apply Regles_add.

apply Regles_add2.

change (Regles X (fst (Gunion V1 R1 V2 R2)) (snd (Gunion V1 R1 V2 R2)))

 in |- *.

prolog [ Gunion_Regles ] 2.



auto.

apply inmonoid_cons.

trivial.

cut (dans S2 V2);

 [ auto

 | prolog [ isGram3 ] 2 ].



auto.



apply inmonoid_cons.

trivial.

cut (dans S1 V1);

 [ auto

 | prolog [ isGram3 ] 2  ].



Qed.



Lemma inmon_Der_imp_Der_d :

 ~ dans S X ->

 ~ dans S V1 ->

 ~ dans S V2 ->

 Regles X V1 R1 ->

 Regles X V2 R2 ->

 inter (union X V1) V2 empty ->

 forall u v : Word, Derive Ru u v -> inmonoid (union X V1) u -> Derive R1 u v.

intros N_dans_X N_dans_V1 N_dans_V2 Re_1 Re_2 inter_X_V1_V2_empty u v

 Der_Ru_u.

elim Der_Ru_u.

	intros u0 v0 A dans_couple_Ru inmon_cons_A_v0.

	apply Derive1.

	cut

  (couple S (word (cons S1 nil)) = couple A (word u0) :>Elt \/

   dans (couple A (word u0))

     (add (couple S (word (cons S2 nil))) (union R1 R2))). 

	intro temp; elim temp; clear temp.

	intro egal_S.

	absurd (dans S X \/ dans S V1).

	red in |- *.

	intro temp; elim temp; clear temp.

	exact N_dans_X.

	exact N_dans_V1.

	apply dans_union.

	replace S with A.

	prolog [ inmonoid_cons_inv2 ] 2.

	

	injection egal_S; auto.



	intro dans_couple_add.

	cut

  (couple S (word (cons S2 nil)) = couple A (word u0) :>Elt \/

   dans (couple A (word u0)) (union R1 R2)). 

	intro temp; elim temp; clear temp.

	intro egal_S.

	absurd (dans S X \/ dans S V1).

	red in |- *.

	intro temp; elim temp; auto.



	apply dans_union.

	replace S with A.

	prolog [ inmonoid_cons_inv2 ] 2.

	

	injection egal_S; auto.



	intro dans_couple_union.	

	cut (dans (couple A (word u0)) R1 \/ dans (couple A (word u0)) R2). 

	intro temp; elim temp; clear temp.

		auto.

		intro dans_R2.

		absurd (inter (union X V1) V2 empty).

			red in |- *.

			unfold inter in |- *.

			intro temp; elim temp; clear temp.

				      intros HH temp; elim temp; clear temp; intros HHH HHHH.

			

			prolog [ Regles_inv1 inmonoid_cons_inv2 dans_empty_imp_P ] 4.

			
		assumption.



	auto.



	auto.



	auto.



	prolog [ inmonoid_cons_inv Derive2 ] 10.

	
Qed.



Lemma inmon_Der_imp_inmon_R1_d :

 forall u v : Word,

 Regles X V1 R1 ->

 Derive R1 u v -> inmonoid (union X V1) u -> inmonoid (union X V1) v.

prolog [ in_mon_X_Der_imp_inmon_X ] 7.



Qed.



Lemma inmon_Der_imp_inmon_d :

 ~ dans S X ->

 ~ dans S V1 ->

 ~ dans S V2 ->

 forall u v : Word,

 isGram X V1 R1 S1 ->

 isGram X V2 R2 S2 ->

 inter V1 V2 empty ->

 inmonoid (union X V1) u -> Derive Ru u v -> inmonoid (union X V1) v.

prolog

 [ isGram2 isGram4 inter_union inmon_Der_imp_Der_d inmon_Der_imp_inmon_R1_d ]

 15.



Qed.



Lemma Gunion_disj_Derivestar :

 ~ dans S X ->

 ~ dans S V1 ->

 ~ dans S V2 ->

 isGram X V1 R1 S1 ->

 isGram X V2 R2 S2 ->

 inter V1 V2 empty ->

 forall u v : Word,

 Derivestar Ru u v -> inmonoid (union X V1) u -> Derivestar R1 u v.

unfold Derivestar in |- *.

intros N_dans_X N_dans_V1 N_dans_V2 G_1 G_2 inter_V1_V2_empty u v

 Derivestar_Ru.

pattern u, v in |- *.

apply Derivestar_Ru.

	auto.



	intros u0 v0 w Der_Ru inmon_v0_imp_Rstar_R1_v0 inmon_u0. 

	apply Rstar_R with v0;

  prolog

   [ isGram2 inter_union isGram4 inmon_Der_imp_Der_d inmon_Der_imp_inmon_d ]

   4.

	
Qed.



Lemma inmon_Der_imp_Der_d2 :

 ~ dans S X ->

 ~ dans S V1 ->

 ~ dans S V2 ->

 Regles X V1 R1 ->

 Regles X V2 R2 ->

 inter (union X V2) V1 empty ->

 forall u v : Word, Derive Ru u v -> inmonoid (union X V2) u -> Derive R2 u v.

intros N_dans_X N_dans_V1 N_dans_V2 Re_1 Re_2 inter_X_V2_V1_empty u v

 Der_Ru_u.

elim Der_Ru_u.

	intros u0 v0 A dans_couple_Ru inmon_cons_A_v0.

	apply Derive1.

	cut

  (couple S (word (cons S1 nil)) = couple A (word u0) :>Elt \/

   dans (couple A (word u0))

     (add (couple S (word (cons S2 nil))) (union R1 R2))). 

	intro temp; elim temp; clear temp.

	intro egal_S.

	absurd (dans S X \/ dans S V2).

	red in |- *.

	intuition.

	apply dans_union.

	replace S with A.

	prolog [ inmonoid_cons_inv2 ] 2.

	

	injection egal_S; auto.



	intro dans_couple_add.

	cut

  (couple S (word (cons S2 nil)) = couple A (word u0) :>Elt \/

   dans (couple A (word u0)) (union R1 R2)). 

	intro temp; elim temp; clear temp.

	intro egal_S.

	absurd (dans S X \/ dans S V2).

	red in |- *.

	intuition.

	apply dans_union.

	replace S with A.

	prolog [ inmonoid_cons_inv2 ] 2.

	

	injection egal_S; auto.



	intro dans_couple_union.	

	cut (dans (couple A (word u0)) R1 \/ dans (couple A (word u0)) R2). 

	 intro temp; elim temp; clear temp.

		intro dans_R1.

		absurd (inter (union X V2) V1 empty).

			red in |- *.

			unfold inter in |- *.

			 intro temp; elim temp; clear temp.

				 intros inc_empt temp; elim temp; clear temp.

			intros incl_empty_V1 imp_dans_empty.

			apply dans_empty_imp_P with A.

			apply imp_dans_empty; prolog [ Regles_inv1 inmonoid_cons_inv2 ] 4.

			
		assumption.



		trivial.

		

	auto.



	auto.



	auto.



	prolog [ inmonoid_cons_inv Derive2 ] 10.

	
Qed.



Lemma inmon_Der_imp_inmon_R2_d :

 forall u v : Word,

 Regles X V2 R2 ->

 Derive R2 u v -> inmonoid (union X V2) u -> inmonoid (union X V2) v.

prolog [ in_mon_X_Der_imp_inmon_X ] 10.



Qed.



Lemma inmon_Der_imp_inmon_d2 :

 ~ dans S X ->

 ~ dans S V1 ->

 ~ dans S V2 ->

 forall u v : Word,

 isGram X V1 R1 S1 ->

 isGram X V2 R2 S2 ->

 inter V1 V2 empty ->

 inmonoid (union X V2) u -> Derive Ru u v -> inmonoid (union X V2) v.

prolog

 [ sym_inter isGram2 inter_union isGram4 inmon_Der_imp_Der_d2

  inmon_Der_imp_inmon_R2_d ] 15.



Qed.



Lemma Gunion_disj_Derivestar2 :

 ~ dans S X ->

 ~ dans S V1 ->

 ~ dans S V2 ->

 isGram X V1 R1 S1 ->

 isGram X V2 R2 S2 ->

 inter V1 V2 empty ->

 forall u v : Word,

 Derivestar Ru u v -> inmonoid (union X V2) u -> Derivestar R2 u v.

unfold Derivestar in |- *.

intros N_dans_X N_dans_V1 N_dans_V2 G_1 G_2 inter_V1_V2_empty u v

 Derivestar_Ru.

pattern u, v in |- *.

apply Derivestar_Ru.

	auto.



	intros u0 v0 w Der_Ru inmon_v0_imp_Rstar_R2_v0 inmon_u0. 

	apply Rstar_R with v0.

		prolog [ sym_inter isGram2 inter_union isGram4 inmon_Der_imp_Der_d2 ] 4.

		
		prolog [ inmon_Der_imp_inmon_d2 ] 3.

		
Qed.



Lemma Gunion_disj_Derive1 :

 ~ dans S X ->

 ~ dans S V1 ->

 ~ dans S V2 ->

 isGram X V1 R1 S1 ->

 isGram X V2 R2 S2 ->

 forall u : Word,

 Derive Ru (cons S nil) u -> cons S1 nil = u :>Word \/ cons S2 nil = u :>Word.

intros N_dans_X N_dans_V1 N_dans_V2 G_1 G_2 u Derive_Ru.

cut (Derive_inv Ru (cons S nil) u).

unfold Derive_inv in |- *.

simpl in |- *.

intro temp; elim temp; clear temp; intro temp; elim temp; clear temp.



	intros x dans_S_x_Ru temp.

	elim temp; clear temp.

	intros x0 egal_S_x0_S_nil egal_Append_x_x0_u.

	replace u with x.



	cut

  (couple S (word (cons S1 nil)) = couple S (word x) :>Elt \/

   dans (couple S (word x))

     (add (couple S (word (cons S2 nil))) (union R1 R2))). 

	intro temp; elim temp; clear temp.

	intro egal_S.

	injection egal_S; auto.

	

	intro dans_couple_add.

	cut

  (couple S (word (cons S2 nil)) = couple S (word x) :>Elt \/

   dans (couple S (word x)) (union R1 R2)). 

	intro temp; elim temp; clear temp.

	intro egal_S.

	injection egal_S; auto.

	

	intro dans_couple_union.	

	cut (dans (couple S (word x)) R1 \/ dans (couple S (word x)) R2). 

	intro temp; elim temp; clear temp.

	intro dans_R1.

	absurd (dans S V1).

		assumption.

		prolog [ isGram4 Regles_inv1 ] 3.

		
	intros dans_R2.

	absurd (dans S V2).

		assumption.

		prolog [ isGram4 Regles_inv1 ] 3.

		
	auto.



	auto.



	auto.



replace x with (Append x nil).

replace nil with x0.

assumption.

apply cons_cons_inv2 with S S; assumption.

apply Append_w_nil.



intros.

cut (Derive_inv Ru nil x).

unfold Derive_inv in |- *.

simpl in |- *.

tauto.

auto.



auto.

Qed.



Hint Resolve Gunion_disj_Derive1.



Lemma Gunion_disj_Derivestar_S :

 ~ dans S X ->

 ~ dans S V1 ->

 ~ dans S V2 ->

 isGram X V1 R1 S1 ->

 isGram X V2 R2 S2 ->

 inter V1 V2 empty ->

 forall u : Word,

 Derivestar Ru (cons S nil) u ->

 cons S nil = u :>Word \/

 Derivestar R1 (cons S1 nil) u \/ Derivestar R2 (cons S2 nil) u.

intros N_dans_X N_dans_V1 N_dans_V2 G_1 G_2 inter_V1_V2_empty u Derivestar_Ru.



cut

 (cons S nil = u :>Word \/

  (exists2 w : Word, Derive Ru (cons S nil) w & Derivestar Ru w u)). 



intro temp; elim temp; clear temp.

	auto.



	intro temp; elim temp; clear temp.

	intros x Der_Ru_cons_S_nil_x Derivestar_Ru_x_u.

	right.

	cut (cons S1 nil = x :>Word \/ cons S2 nil = x :>Word). 



	intro temp; elim temp; clear temp; intro x_egal; rewrite x_egal.

		apply or_introl.	

		apply Gunion_disj_Derivestar;

   [ auto

   | auto

   | auto

   | auto

   | auto

   | auto

   | auto

   | idtac ].

			rewrite <- x_egal; cut (dans S1 V1).

						auto.

						prolog [ isGram3 ] 2.

						
		apply or_intror.	

		apply Gunion_disj_Derivestar2;

   [ auto

   | auto

   | auto

   | auto

   | auto

   | auto

   | auto

   | idtac ].

			rewrite <- x_egal; cut (dans S2 V2).

						auto.

						prolog [ isGram3 ] 2.

						
	auto.

	

auto.

Qed.



Hint Resolve Gunion_disj_Derivestar_S.



Lemma Gunion_disj_LG_inclus1 :

 ~ dans S X ->

 ~ dans S V1 ->

 ~ dans S V2 ->

 isGram X V1 R1 S1 ->

 isGram X V2 R2 S2 ->

 inter V1 V2 empty ->

 l_inclus (LG X Vu Ru S) (lunion (LG X V1 R1 S1) (LG X V2 R2 S2)).

intros N_dans_X N_dans_V1 N_dans_V2 G_1 G_2 inter_V1_V2_empty.

red in |- *.

unfold LG in |- *.

intros w temp; elim temp; clear temp; intros Der_Ru inmonoid_X_w.

unfold lunion in |- *.

elimtype

 (cons S nil = w :>Word \/

  Derivestar R1 (cons S1 nil) w \/ Derivestar R2 (cons S2 nil) w). 

	intro eg_cons_S_nil_w.

	absurd (dans S X).

		assumption.

		apply inmonoid_cons_inv2 with nil.

		rewrite eg_cons_S_nil_w; assumption.



	intro temp; elim temp; clear temp; auto.



auto.

Qed.



Lemma Gunion_disj_LG_inclus2 : l_inclus (LG X V1 R1 S1) (LG X Vu Ru S).

red in |- *.

unfold LG in |- *.

intros w temp; elim temp; clear temp.

intros Der_Ru inmonoid_X_w.

unfold Ru in |- *; simpl in |- *.

split.

	apply Derivestar_R with (cons S1 nil).

		replace (cons S1 nil) with (Append (cons S1 nil) nil).

			auto.

			

			auto.



		apply Derivestar_inclus with R1; auto.



assumption.

Qed.



Lemma Gunion_disj_LG_inclus3 : l_inclus (LG X V2 R2 S2) (LG X Vu Ru S).

red in |- *.

unfold LG in |- *.

intros w temp; elim temp; clear temp.

intros Der_Ru inmonoid_X_w.

unfold Ru in |- *; simpl in |- *.

split.

	apply Derivestar_R with (cons S2 nil).

		replace (cons S2 nil) with (Append (cons S2 nil) nil).

			auto.

			

			auto.



		apply Derivestar_inclus with R2; auto.



assumption.

Qed.



Lemma Gunion_disj_LG_inclus4 :

 l_inclus (lunion (LG X V1 R1 S1) (LG X V2 R2 S2)) (LG X Vu Ru S).

unfold l_inclus, lunion in |- *.

intros w temp; elim temp; clear temp; intro LG_w.

apply Gunion_disj_LG_inclus2; assumption.

apply Gunion_disj_LG_inclus3; assumption.

Qed.



Lemma Gunion_disj_LG :

 ~ dans S X ->

 ~ dans S V1 ->

 ~ dans S V2 ->

 isGram X V1 R1 S1 ->

 isGram X V2 R2 S2 ->

 inter V1 V2 empty ->

 l_egal (LG X Vu Ru S) (lunion (LG X V1 R1 S1) (LG X V2 R2 S2)).

intros.

unfold l_egal in |- *; split.

apply Gunion_disj_LG_inclus1; assumption.

exact Gunion_disj_LG_inclus4.

Qed.



End gram4.

