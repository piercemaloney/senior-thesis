Require Import NArith.

Require Import GeoCoq.Utils.sets.
(* GeoCoq.Utils.sets:
Require Export MSets.
Require Import Arith.
Require Import NArith.
Require Import Notations.
Require Import Sorting.
Require Import Coq.Program.Equality.
Require Export GeoCoq.Tactics.Coinc.tactics_axioms.

Module S := MSetList.Make PositiveOrderedTypeBits.

Module SWP := WPropertiesOn PositiveOrderedTypeBits S.

Module SetOfSetsOfPositiveOrderedType <: OrderedType.

  Definition t := S.t.

  Definition eq := S.Equal.

  Include IsEq.

  Definition eqb := S.equal.

  Definition eqb_eq := S.equal_spec.

  Include HasEqBool2Dec.

  Definition lt := S.lt.

  Definition compare := S.compare.

  Definition compare_spec := S.compare_spec.

End SetOfSetsOfPositiveOrderedType.

Module SS := MSetList.Make SetOfSetsOfPositiveOrderedType.

Definition fstpp (pair : (positive * positive)) :=
  match pair with
    |(a,b) => Pos.min a b
  end.

Definition sndpp (pair : (positive * positive)) :=
  match pair with
    |(a,b) => Pos.max a b
  end.

Module SetOfPairsOfPositiveOrderedType <: OrderedType.

  Definition t:= (positive * positive).

  Definition eq (t1 t2 : t) :=
    Pos.eq (fstpp(t1)) (fstpp(t2)) /\ Pos.eq (sndpp(t1)) (sndpp(t2)).

  Include IsEq.

  Definition eqb (t1 t2 : t) :=
    Pos.eqb (fstpp(t1)) (fstpp(t2)) && Pos.eqb (sndpp(t1)) (sndpp(t2)).

  Lemma eqb_eq : forall t1 t2, eqb t1 t2 = true <-> eq t1 t2.

  Include HasEqBool2Dec.

  Definition lt (t1 t2 : t) :=
    let ft1 := fstpp(t1) in
    let ft2 := fstpp(t2) in
    let st1 := sndpp(t1) in
    let st2 := sndpp(t2) in
    if Pos.eqb ft1 ft2 then Pos.lt st1 st2
                       else Pos.lt ft1 ft2.

  Lemma lt_irrefl : Irreflexive lt.

  Lemma lt_antiref : forall x, ~ lt x x.

  Lemma lt_trans : Transitive lt.

  Definition compare t1 t2 :=
    let ft1 := fstpp(t1) in
    let ft2 := fstpp(t2) in
    let st1 := sndpp(t1) in
    let st2 := sndpp(t2) in
    match (Pos.compare ft1 ft2) with
      | Lt => Lt
      | Eq => Pos.compare st1 st2
      | Gt => Gt
    end.

  Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).

End SetOfPairsOfPositiveOrderedType.

Module SP := MSetList.Make SetOfPairsOfPositiveOrderedType.

Module PosOrder <: TotalLeBool.

  Definition t := positive.

  Definition leb := Pos.leb.

  Lemma leb_total : forall p1 p2,
    leb p1 p2 = true \/ leb p2 p1 = true.

  Lemma leb_dec : forall p1 p2,
    leb p1 p2 = true \/ leb p1 p2 = false.

End PosOrder.

Module Import PosSort := Sort PosOrder.

Definition OCPAux {n : nat} (cp : cartesianPower positive (S (S n))) := (PosSort.sort (CPToList cp)).

Lemma OCPALengthOK {n : nat} : forall (cp : cartesianPower positive (S (S n))), (length (OCPAux cp)) = (S (S n)).

Lemma OCPSortedTl :
  forall (l : list positive),
  StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l ->
  StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) (tl l).

Lemma PermSorted : forall (l l' : list positive),
  Permutation.Permutation l l' ->

Definition OCP {n : nat} (cp : cartesianPower positive (S (S n))) : cartesianPower positive (S (S n)).

Lemma OCPSortedAux {n : nat} :
  forall (cp : cartesianPower positive (S (S n))),
  StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) (CPToList (OCP cp)).

Lemma OCPPerm {n : nat} :
  forall (cp : cartesianPower positive (S (S n))),
  Permutation.Permutation (CPToList cp) (CPToList (OCP cp)).

Lemma CPLOCPTlOK {n : nat} :
  forall (cp : cartesianPower positive (S (S (S n)))),
  headCP cp = headCP (OCP cp) ->
  CPToList (OCP (tailCP cp)) = CPToList (tailCP (OCP cp)).

Lemma OCPTlOK {n : nat} :
  forall (cp : cartesianPower positive (S (S (S n)))),
  headCP cp = headCP (OCP cp) ->
  OCP (tailCP cp) = tailCP (OCP cp).

Lemma InCPOCP {n : nat} : forall p (cp : cartesianPower positive (S (S n))),
  InCP p cp <-> InCP p (OCP cp).

Section Set_of_tuple_of_positive.

  Context {Ar : Arity}.

  Fixpoint eqList (l1 l2 : list positive) :=
    match l1, l2 with
      | nil, nil => True
      | (hd1 :: tl1), (hd2 :: tl2) => (Pos.eq hd1 hd2) /\ (eqList tl1 tl2)
      | _, _ => False
    end.

  Lemma eqListRefl : forall l, eqList l l.

  Lemma eqListSym : forall l l', eqList l l' -> eqList l' l.

  Lemma eqListTrans : forall l1 l2 l3, eqList l1 l2 -> eqList l2 l3 -> eqList l1 l3.

  Definition tST := cartesianPower positive (S (S n)).

  Definition eqST (cp1 cp2 : tST) :=
    eqList (PosSort.sort (CPToList cp1)) (PosSort.sort (CPToList cp2)).

  Lemma eqListSortOCP : forall (cp : tST), eqList (CPToList (OCP cp)) (PosSort.sort (CPToList cp)).

  Fixpoint eqbList (l1 l2 : list positive) :=
    match l1, l2 with
      | nil         , nil          => true
      | (hd1 :: tl1), (hd2 :: tl2) => (Pos.eqb hd1 hd2) && (eqbList tl1 tl2)
      | _           , _            => false
    end.

  Lemma eqbListEqList : forall l1 l2, eqbList l1 l2 = true <-> eqList l1 l2.

  Definition eqbST (cp1 cp2 : tST) :=
    eqbList (PosSort.sort (CPToList cp1)) (PosSort.sort (CPToList cp2)).

  Lemma eqbST_eqST : forall cp1 cp2, eqbST cp1 cp2 = true <-> eqST cp1 cp2.

  Fixpoint ltList (l1 l2 : list positive) :=
    match l1, l2 with
      | nil, nil => False
      | (hd1 :: tl1), (hd2 :: tl2) => if (Pos.ltb hd1 hd2) then True
                                      else if (Pos.ltb hd2 hd1) then False
                                           else (ltList tl1 tl2)
      | nil, _ => True
      | _, nil => False
    end.

  Lemma lengthOne : forall (l : list positive),
    length l = 1 -> exists a, l = a :: nil.

  Lemma lengthAtLeastOne : forall (l : list positive) n,
    length l = (S n) -> exists a0 l0, l = a0 :: l0.

  Lemma ltListTrans : forall m x y z,
    length x = (S m) ->
    length y = (S m) ->
    length z = (S m) ->
    ltList x y -> ltList y z -> ltList x z.

  Lemma sortOK : forall m l, length l = m -> length (sort l) = m.

  Definition ltST (cp1 cp2 : tST) :=
    ltList (PosSort.sort (CPToList cp1)) (PosSort.sort (CPToList cp2)).

  Lemma ltTrans : Transitive ltST.

  Lemma ltListIrrefl : forall l, ltList l l -> False.

  Lemma eqListOK : forall l1 l2, eqList l1 l2 -> l1 = l2.

  Fixpoint compareList (l1 l2 : list positive) :=
    match l1, l2 with
    | nil, nil => Eq
    | (hd1 :: tl1), (hd2 :: tl2) => match Pos.compare hd1 hd2 with
                                    | Lt => Lt
                                    | Eq => compareList tl1 tl2
                                    | Gt => Gt
                                    end
    | nil, _ => Lt
    | _, nil => Gt
    end.

  Lemma compareListSpec : forall l1 l2,
    CompSpec eqList ltList l1 l2 (compareList l1 l2).

  Definition compareST (cp1 cp2 : tST) :=
    compareList (PosSort.sort (CPToList cp1)) (PosSort.sort (CPToList cp2)).

  Lemma compare_spec : forall cp1 cp2,
    CompSpec eqST ltST cp1 cp2 (compareST cp1 cp2).

  Definition STelt := tST.

  Definition STt := list tST.

  Definition STempty : STt := nil.

  Lemma eqST_dec : forall x y, {eqST x y} + {~ eqST x y}.

  Definition STadd (x : STelt) (s : STt) := cons x s.

  Fixpoint STexists_ (f : STelt -> bool) (s : STt) :=
    match s with
      | nil      => false
      | hd :: tl => f hd || STexists_ f tl
    end.

  Fixpoint STmem elt l :=
    match l with
      | nil      => false
      | hd :: tl => if eqST_dec hd elt then true else STmem elt tl
    end.

  Lemma STempty_b : forall y : STelt, STmem y STempty = false.

  Lemma STexists_mem_4 :
    forall f (s : STt),
      STexists_ f s = true ->
      exists x : STelt ,  STmem x s = true /\ f x = true.

  Lemma STadd_iff : forall (s : STt) (x y : STelt),
    STmem y (STadd x s) = true <-> (eqST x y \/ STmem y s = true).

End Set_of_tuple_of_positive. *)

Require Import GeoCoq.Meta_theory.Models.tarski_to_coinc_theory_for_col.
(* GeoCoq.Meta_theory.Models.tarski_to_coinc_theory_for_col:
Require Export GeoCoq.Tarski_dev.Ch06_out_lines.
Require Import GeoCoq.Tactics.Coinc.tactics_axioms.

Section Tarski_is_a_Coinc_theory_for_col.

Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.

Definition diff : arity Tpoint 2 := fun A B : Tpoint => A <> B.

Lemma diff_perm_1 : forall A B, app_1_n diff A B -> app_n_1 diff B A.

Lemma diff_perm_2 : forall A B (X : cartesianPower Tpoint 0), app_2_n diff A B X -> app_2_n diff B A X.

Definition col : arity Tpoint 3 := Col.

Lemma col_perm_1 : forall A (X : cartesianPower Tpoint 2), app_1_n col A X -> app_n_1 col X A.

Lemma col_perm_2 : forall A B (X : cartesianPower Tpoint 1), app_2_n col A B X -> app_2_n col B A X.

Lemma col_bd : forall A (X : cartesianPower Tpoint 1), app_2_n col A A X.

Lemma col_3 : forall (COL : cartesianPower Tpoint 3) (DIFF : cartesianPower Tpoint 2),
  pred_conj col COL DIFF -> app diff DIFF -> app col COL.

Global Instance Tarski_is_a_Arity_for_col : Arity.

Global Instance Tarski_is_a_Coinc_predicates_for_col :
  (Coinc_predicates Tarski_is_a_Arity_for_col).

Global Instance Tarski_is_a_Coinc_theory_for_col :
  (Coinc_theory Tarski_is_a_Arity_for_col Tarski_is_a_Coinc_predicates_for_col).

End Tarski_is_a_Coinc_theory_for_col. *)

Require Import GeoCoq.Tactics.Coinc.CoincR.
(* GeoCoq.Tactics.Coinc.CoincR:
Require Import Recdef.
Require Import NArith.
Require Import Sorting.
Require Import GeoCoq.Tactics.Coinc.Permutations.
Require Import GeoCoq.Utils.general_tactics.
Require Import GeoCoq.Utils.sets.

Module SSWP := WPropertiesOn SetOfSetsOfPositiveOrderedType SS.

Module SSWEqP := WEqPropertiesOn SetOfSetsOfPositiveOrderedType SS.

Module Import PosSort := Sort PosOrder.

Section Coinc_refl.

Context {AR : Arity}.

Definition pick_variety_auxCP {m : nat} (s : SS.elt) (cp : cartesianPower positive (S (S m))) : bool.

Definition pick_variety_aux (s : SS.elt) (t : tST) := pick_variety_auxCP s t.

Lemma pick_variety_auxCP_forallT {m : nat} :
  forall s (cp : cartesianPower positive (S (S m))),
  pick_variety_auxCP s cp = true <-> (forall p, InCP p cp -> S.mem p s = true).

Lemma pick_variety_auxCP_existsF {m : nat} :
  forall s (cp : cartesianPower positive (S (S m))),
  pick_variety_auxCP s cp = false <-> (exists p, InCP p cp /\ S.mem p s = false).

Lemma proper_00 :
  forall s,
  Proper
  ((fun (t1 t2 : tST) =>
     eqST t1 t2) ==> eq)
  (fun t : tST => pick_variety_aux s t).

Definition pick_variety (s : SS.elt) (st : STt) :=
  STexists_ (fun t => pick_variety_aux s t) st.

Lemma proper_0 :
  Proper (S.Equal ==> eq ==> eq) pick_variety.

Lemma proper_1 : forall s1 st,
  Proper (S.Equal ==> eq)

Definition exists_witness (f : SS.elt -> bool) (s : SS.t) : option SS.elt :=
  SS.choose (SS.filter f s).

Lemma exists_witness_ok : forall e f s,
  Proper (S.Equal ==> eq) f ->

Definition pick_varieties_aux (s1 : SS.elt) (ss : SS.t) (st : STt)
                              : (option (SS.elt * SS.elt)) :=
  match ((exists_witness (fun s2 => let i := S.inter s1 s2 in
                                    pick_variety i st)) ss) with
    | None => None
    | Some s2 => Some(s1,s2)
  end.

Definition pick_varieties (ss : SS.t) (st : STt)
                          : (option (SS.elt * SS.elt)) :=
  match (exists_witness (fun s =>
                           match (pick_varieties_aux s (SS.remove s ss) st) with
                             | None => false
                             | _ => true
                           end) ss) with
    | None => None
    | Some s1 => pick_varieties_aux s1 (SS.remove s1 ss) st
  end.

Definition eqop (p1 p2 : option SS.elt) :=
  match p1,p2 with
    | None, None => True
    | Some s1, Some s2 => True
    | _, _ => False
  end.

Lemma proper_2 : forall (f1 f2 : SS.elt -> bool) (s1 s2 : SS.t),

Definition eqopp (p1 p2 : option (SS.elt * SS.elt)) :=
  match p1,p2 with
    | None, None => True
    | Some s1, Some s2 => True
    | _, _ => False
  end.

Lemma proper_3 : Proper (S.Equal ==> SS.Equal ==> eq ==> eqopp) pick_varieties_aux.

Lemma pick_varieties_ok_1 : forall s1 s2 ss st,
  pick_varieties ss st = Some(s1,s2) ->
  SS.In s1 ss.

Lemma pick_varieties_ok_2 : forall s1 s2 ss st,
  pick_varieties ss st = Some(s1,s2) ->
  SS.In s2 (SS.remove s1 ss).

Definition memCPAux m (cp : cartesianPower positive (S (S m))) (s : SS.elt) : bool.

Lemma memCPAuxHdTl : forall m cp s,
  memCPAux (S m) cp s = S.mem (fst cp) s && memCPAux m (tailCP cp) s.

Lemma memCPAuxProperOK : forall m, Proper (eq ==> S.Equal==> eq) (memCPAux m).

Lemma memCPAuxOK : forall m cp s e,
  memCPAux m cp s = true -> InCP e cp -> S.mem e s = true.

Lemma memMemCPAuxOK : forall m cp s,
  (forall e, InCP e cp -> S.mem e s = true) -> memCPAux m cp s = true.

Lemma memCPAuxTlOK : forall m cp s,
  memCPAux (S m) cp s = true ->
  memCPAux m (tailCP cp) s = true.

Definition memCP (cp : cartesianPower positive (S (S (S n)))) (s : SS.elt) := memCPAux (S n) cp s.

Lemma memCPProper : Proper (eq ==> S.Equal==> eq) memCP.

Lemma memMemCPOK : forall cp s,
  (forall e, InCP e cp -> S.mem e s = true) -> memCP cp s = true.

Lemma memCPConsHd : forall p s x,
  S.mem p s = true ->

Definition test_coinc (ss : SS.t) (st : STt) (cp : cartesianPower positive (S (S (S n)))) : bool :=
  let newss := identify_varieties ss st  in
    SS.exists_ (fun s => memCP cp s) newss.

Lemma pick_variety_aux_memCPAux1 : forall s1 s2 m (cp : cartesianPower positive (S (S m))),
  pick_variety_auxCP (S.inter s1 s2) cp = true ->

Lemma pick_variety_aux_memCPAux2 : forall s1 s2 m (cp : cartesianPower positive (S (S m))),
  pick_variety_auxCP (S.inter s1 s2) cp = true ->

Definition interp_CP {m : nat} (cp : cartesianPower positive (S m)) (interp: positive -> COINCpoint) : cartesianPower COINCpoint (S m).

Lemma interp_CPHdOK {m : nat} : forall (cp : cartesianPower positive (S m)) interp,
  interp_CP (headCPbis cp) interp = headCP (interp_CP cp interp).

Lemma interp_CPTlOK {m : nat} : forall (cp : cartesianPower positive (S (S m))) interp,
  interp_CP (tailCP cp) interp = tailCP (interp_CP cp interp).

Lemma interp_CPOK {m : nat} : forall (cp : cartesianPower positive (S m)) (interp: positive -> COINCpoint),
  CPToList (interp_CP cp interp) = map interp (CPToList cp).

Context {COP : Coinc_predicates AR}.

Definition ss_ok (ss : SS.t) (interp: positive -> COINCpoint) :=
  forall s, SS.mem s ss = true ->
  forall cp, memCP cp s = true ->
    app coinc (interp_CP cp interp).

Lemma consHdInterpOK : forall (cp : cartesianPower positive 1) (x : tST) interp,
  consHeadCP (interp_CP cp interp) (interp_CP x interp) = interp_CP (consHeadCP cp x) interp.

Lemma ss_ok_inter_ok1 : forall ss interp s1 s2 x (p : cartesianPower positive 1),
  ss_ok ss interp ->
  SS.In s1 ss ->

Lemma ss_ok_inter_ok2 : forall ss interp s1 s2 x (p : cartesianPower positive 1),
  ss_ok ss interp ->
  SS.In s2 ss ->

Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp,
  ss_ok ss interp ->
  SS.In s1 ss ->

Definition st_ok (st : STt) (interp: positive -> COINCpoint) :=
  forall t, STmem t st = true -> app wd (interp_CP t interp).

Context {COT : Coinc_theory AR COP}.

Lemma identify_varieties_ok : forall ss st interp,
  ss_ok ss interp -> st_ok st interp ->
  ss_ok (identify_varieties ss st) interp.

Lemma test_coinc_ok : forall ss st interp cp,
  ss_ok ss interp -> st_ok st interp ->
  test_coinc ss st cp = true ->
  app coinc (interp_CP cp interp).

Lemma ss_ok_empty : forall interp,
  ss_ok SS.empty interp.

Lemma st_ok_empty : forall interp,
  st_ok STempty interp.

Definition CPToSS {m:nat} (cp : cartesianPower positive m) : SS.elt.

Lemma CPToSSHdTl {m:nat} : forall (cp : cartesianPower positive (S (S m))),
  CPToSS cp = S.add (headCP cp) (CPToSS (tailCP cp)).

Lemma memCPToSSOK {m : nat} : forall e (cp : cartesianPower positive (S m)),
  S.mem e (CPToSS cp) = true ->

Lemma CPToSSOKAux {m m' : nat} :
  forall (cp : cartesianPower positive (S (S m))) (cp' : cartesianPower positive (S (S m'))) e s,
  S.Equal (CPToSS cp) s ->

Lemma CPToSSOK : forall (cp cp' : cartesianPower positive (S (S (S n)))) s,
  S.Equal (CPToSS cp) s ->

Lemma CoappDupPerm {m : nat} :
  forall (cp : cartesianPower positive m),
  ~ List.NoDup (CPToList cp) ->

Lemma CoappDupAux {m : nat} :
  forall (cp : cartesianPower positive (S (S (S m)))),
  ~ List.NoDup (CPToList cp) ->

Lemma CoappDup : forall cp interp,
  ~ List.NoDup (CPToList cp) ->

Lemma collect_coincs :
forall cp ss interp,
  app coinc (interp_CP cp interp) ->
  ss_ok ss interp -> ss_ok (SS.add (CPToSS cp) ss) interp.

Lemma collect_wds :
  forall cp st interp,
  app wd (interp_CP cp interp) ->
  st_ok st interp -> st_ok (STadd cp st) interp.

Definition list_assoc_inv :=
  (fix list_assoc_inv_rec (A:Type) (B:Set)
                          (eq_dec:forall e1 e2:B, {e1 = e2} + {e1 <> e2})
                          (lst : list (prodT A B)) {struct lst} : B -> A -> A :=
  fun (key:B) (default:A) =>
    match lst with
      | nil => default
      | cons (pairT v e) l =>
        match eq_dec e key with
          | left _ => v
          | right _ => list_assoc_inv_rec A B eq_dec l key default
        end
    end).

Lemma positive_dec : forall (p1 p2:positive), {p1=p2}+{~p1=p2}.

Definition interp (lvar : list (COINCpoint * positive)) (Default : COINCpoint) : positive -> COINCpoint := 
  fun p => list_assoc_inv COINCpoint positive positive_dec lvar p Default.

End Coinc_refl.

Ltac add_to_distinct_list x xs :=
  match xs with
    | nil     => constr:(x::xs)
    | x::_    => fail 1
    | ?y::?ys => let zs := add_to_distinct_list x ys in constr:(y::zs)
  end.

Ltac collect_points_list Tpoint xs :=
  match goal with
    | N : Tpoint |- _ => let ys := add_to_distinct_list N xs in
                           collect_points_list Tpoint ys
    | _               => xs
  end.

Ltac collect_points Tpoint := collect_points_list Tpoint (@nil Tpoint).

Ltac number_aux Tpoint lvar cpt :=
  match constr:(lvar) with
    | nil          => constr:(@nil (prodT Tpoint positive))
    | cons ?H ?T => let scpt := eval vm_compute in (Pos.succ cpt) in
                    let lvar2 := number_aux Tpoint T scpt in
                      constr:(cons (@pairT  Tpoint positive H cpt) lvar2)
  end.

Ltac number Tpoint lvar := number_aux Tpoint lvar (1%positive).

Ltac build_numbered_points_list Tpoint := let lvar := collect_points Tpoint in number Tpoint lvar.

Ltac List_assoc Tpoint elt lst :=
  match constr:(lst) with
    | nil => fail
    | (cons (@pairT Tpoint positive ?X1 ?X2) ?X3) =>
      match constr:(elt = X1) with
        | (?X1 = ?X1) => constr:(X2)
        | _ => List_assoc Tpoint elt X3
      end
  end.

Definition Tagged P : Prop := P.

Lemma PropToTagged : forall P : Prop, P -> Tagged P. *)



Section CoincR_for_col.



Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.



Definition ss_ok_for_col ss interp :=

  @ss_ok Tarski_is_a_Arity_for_col

         Tarski_is_a_Coinc_predicates_for_col ss interp.



Lemma ss_ok_empty_for_col : forall interp, ss_ok_for_col SS.empty interp.

Proof. exact ss_ok_empty. Qed.



Lemma collect_coincs_for_col : forall A B C pa pb pc ss interp,

  Col A B C ->

  interp pa = A ->

  interp pb = B ->

  interp pc = C ->

  ss_ok_for_col ss interp ->

  ss_ok_for_col (SS.add (@CPToSS 3 (pa, (pb, pc))) ss) interp.

Proof.

intros A B C pa pb pc ss interp HCol HA HB HC HSS.

apply (@collect_coincs Tarski_is_a_Arity_for_col

                       Tarski_is_a_Coinc_predicates_for_col);

[apply Tarski_is_a_Coinc_theory_for_col|simpl|auto].

rewrite HA; rewrite HB; rewrite HC; auto.

Qed.



Definition st_ok_for_col st interp :=

  @st_ok Tarski_is_a_Arity_for_col

         Tarski_is_a_Coinc_predicates_for_col st interp.



Lemma st_ok_empty_for_col : forall interp, st_ok_for_col STempty interp.

Proof. exact st_ok_empty. Qed.



Lemma collect_wds_for_col : forall A B pa pb st interp,

  A <> B ->

  interp pa = A ->

  interp pb = B ->

  st_ok_for_col st interp ->

  st_ok_for_col (STadd (pa, pb) st) interp.

Proof.

intros A B pa pb st interp HDiff HA HB HST.

apply (@collect_wds Tarski_is_a_Arity_for_col

                    Tarski_is_a_Coinc_predicates_for_col);

[apply Tarski_is_a_Coinc_theory_for_col|simpl|auto].

rewrite HA; rewrite HB; auto.

Qed.



Definition test_coinc_for_col ss st (pa pb pc : positive) :=

  @test_coinc Tarski_is_a_Arity_for_col ss st (pa, (pb, pc)).



Definition interp_CP_for_col (pa pb pc : positive) interp :=

  @interp_CP Tarski_is_a_Arity_for_col 2 (pa, (pb, pc)) interp.



Lemma test_coinc_ok_for_col : forall pa pb pc ss st interp,

  ss_ok_for_col ss interp ->

  st_ok_for_col st interp ->

  test_coinc_for_col ss st pa pb pc = true ->

  Col (interp pa) (interp pb) (interp pc).

Proof.

intros pa pb pc ss st interp HSS HST HTest.

assert (HCol := @test_coinc_ok Tarski_is_a_Arity_for_col

                               Tarski_is_a_Coinc_predicates_for_col

                               Tarski_is_a_Coinc_theory_for_col

                               ss st interp (pa, (pb, pc)) HSS HST HTest).

simpl in HCol; auto.

Qed.



End CoincR_for_col.



Ltac assert_ss_ok Tpoint Col lvar :=

  repeat

  match goal with

    | HCol : Col ?A ?B ?C, HOK : ss_ok_for_col ?SS ?Interp |- _ =>

      let pa := List_assoc Tpoint A lvar in

      let pb := List_assoc Tpoint B lvar in

      let pc := List_assoc Tpoint C lvar in

      apply PropToTagged in HCol;

      apply (collect_coincs_for_col A B C pa pb pc SS Interp HCol) in HOK;

      try reflexivity

  end.



Ltac assert_st_ok Tpoint lvar :=

  repeat

  match goal with

    | HDiff : ?A <> ?B, HOK : st_ok_for_col ?ST ?Interp |- _ =>

      let pa := List_assoc Tpoint A lvar in

      let pb := List_assoc Tpoint B lvar in

      apply PropToTagged in HDiff;

      apply (collect_wds_for_col A B pa pb ST Interp HDiff) in HOK;

      try reflexivity

  end.



Ltac Col_refl Tpoint Col :=

  match goal with

    | Default : Tpoint |- Col ?A ?B ?C =>

      let lvar := build_numbered_points_list Tpoint in

      let pa := List_assoc Tpoint A lvar in

      let pb := List_assoc Tpoint B lvar in

      let pc := List_assoc Tpoint C lvar in

      let c := ((vm_compute;reflexivity) || fail 2 "Can not be deduced") in

      let HSS := fresh in

      assert (HSS := ss_ok_empty_for_col (interp lvar Default));

      assert_ss_ok Tpoint Col lvar;

      let HST := fresh in

      assert (HST := st_ok_empty_for_col (interp lvar Default));

      assert_st_ok Tpoint lvar;

      match goal with

        | HOKSS : ss_ok_for_col ?SS ?Interp, HOKST : st_ok_for_col ?ST ?Interp |- _ =>

          apply (test_coinc_ok_for_col pa pb pc SS ST

                                       Interp HOKSS HOKST); c

      end

  end.

