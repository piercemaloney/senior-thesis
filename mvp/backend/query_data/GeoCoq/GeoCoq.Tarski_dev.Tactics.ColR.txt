Require Import NArith.

Require Import GeoCoq.Utils.sets.
(* GeoCoq.Utils.sets:
Require Export MSets.
Require Import Arith.
Require Import NArith.
Require Import Notations.
Require Import Sorting.
Require Import Coq.Program.Equality.
Require Export GeoCoq.Tactics.Coinc.tactics_axioms.

Module S := MSetList.Make PositiveOrderedTypeBits.

Module SWP := WPropertiesOn PositiveOrderedTypeBits S.

Module SetOfSetsOfPositiveOrderedType <: OrderedType.

  Definition t := S.t.

  Definition eq := S.Equal.

  Include IsEq.

  Definition eqb := S.equal.

  Definition eqb_eq := S.equal_spec.

  Include HasEqBool2Dec.

  Definition lt := S.lt.

  Definition compare := S.compare.

  Definition compare_spec := S.compare_spec.

End SetOfSetsOfPositiveOrderedType.

Module SS := MSetList.Make SetOfSetsOfPositiveOrderedType.

Definition fstpp (pair : (positive * positive)) :=
  match pair with
    |(a,b) => Pos.min a b
  end.

Definition sndpp (pair : (positive * positive)) :=
  match pair with
    |(a,b) => Pos.max a b
  end.

Module SetOfPairsOfPositiveOrderedType <: OrderedType.

  Definition t:= (positive * positive).

  Definition eq (t1 t2 : t) :=
    Pos.eq (fstpp(t1)) (fstpp(t2)) /\ Pos.eq (sndpp(t1)) (sndpp(t2)).

  Include IsEq.

  Definition eqb (t1 t2 : t) :=
    Pos.eqb (fstpp(t1)) (fstpp(t2)) && Pos.eqb (sndpp(t1)) (sndpp(t2)).

  Lemma eqb_eq : forall t1 t2, eqb t1 t2 = true <-> eq t1 t2.

  Include HasEqBool2Dec.

  Definition lt (t1 t2 : t) :=
    let ft1 := fstpp(t1) in
    let ft2 := fstpp(t2) in
    let st1 := sndpp(t1) in
    let st2 := sndpp(t2) in
    if Pos.eqb ft1 ft2 then Pos.lt st1 st2
                       else Pos.lt ft1 ft2.

  Lemma lt_irrefl : Irreflexive lt.

  Lemma lt_antiref : forall x, ~ lt x x.

  Lemma lt_trans : Transitive lt.

  Definition compare t1 t2 :=
    let ft1 := fstpp(t1) in
    let ft2 := fstpp(t2) in
    let st1 := sndpp(t1) in
    let st2 := sndpp(t2) in
    match (Pos.compare ft1 ft2) with
      | Lt => Lt
      | Eq => Pos.compare st1 st2
      | Gt => Gt
    end.

  Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).

End SetOfPairsOfPositiveOrderedType.

Module SP := MSetList.Make SetOfPairsOfPositiveOrderedType.

Module PosOrder <: TotalLeBool.

  Definition t := positive.

  Definition leb := Pos.leb.

  Lemma leb_total : forall p1 p2,
    leb p1 p2 = true \/ leb p2 p1 = true.

  Lemma leb_dec : forall p1 p2,
    leb p1 p2 = true \/ leb p1 p2 = false.

End PosOrder.

Module Import PosSort := Sort PosOrder.

Definition OCPAux {n : nat} (cp : cartesianPower positive (S (S n))) := (PosSort.sort (CPToList cp)).

Lemma OCPALengthOK {n : nat} : forall (cp : cartesianPower positive (S (S n))), (length (OCPAux cp)) = (S (S n)).

Lemma OCPSortedTl :
  forall (l : list positive),
  StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l ->
  StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) (tl l).

Lemma PermSorted : forall (l l' : list positive),
  Permutation.Permutation l l' ->

Definition OCP {n : nat} (cp : cartesianPower positive (S (S n))) : cartesianPower positive (S (S n)).

Lemma OCPSortedAux {n : nat} :
  forall (cp : cartesianPower positive (S (S n))),
  StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) (CPToList (OCP cp)).

Lemma OCPPerm {n : nat} :
  forall (cp : cartesianPower positive (S (S n))),
  Permutation.Permutation (CPToList cp) (CPToList (OCP cp)).

Lemma CPLOCPTlOK {n : nat} :
  forall (cp : cartesianPower positive (S (S (S n)))),
  headCP cp = headCP (OCP cp) ->
  CPToList (OCP (tailCP cp)) = CPToList (tailCP (OCP cp)).

Lemma OCPTlOK {n : nat} :
  forall (cp : cartesianPower positive (S (S (S n)))),
  headCP cp = headCP (OCP cp) ->
  OCP (tailCP cp) = tailCP (OCP cp).

Lemma InCPOCP {n : nat} : forall p (cp : cartesianPower positive (S (S n))),
  InCP p cp <-> InCP p (OCP cp).

Section Set_of_tuple_of_positive.

  Context {Ar : Arity}.

  Fixpoint eqList (l1 l2 : list positive) :=
    match l1, l2 with
      | nil, nil => True
      | (hd1 :: tl1), (hd2 :: tl2) => (Pos.eq hd1 hd2) /\ (eqList tl1 tl2)
      | _, _ => False
    end.

  Lemma eqListRefl : forall l, eqList l l.

  Lemma eqListSym : forall l l', eqList l l' -> eqList l' l.

  Lemma eqListTrans : forall l1 l2 l3, eqList l1 l2 -> eqList l2 l3 -> eqList l1 l3.

  Definition tST := cartesianPower positive (S (S n)).

  Definition eqST (cp1 cp2 : tST) :=
    eqList (PosSort.sort (CPToList cp1)) (PosSort.sort (CPToList cp2)).

  Lemma eqListSortOCP : forall (cp : tST), eqList (CPToList (OCP cp)) (PosSort.sort (CPToList cp)).

  Fixpoint eqbList (l1 l2 : list positive) :=
    match l1, l2 with
      | nil         , nil          => true
      | (hd1 :: tl1), (hd2 :: tl2) => (Pos.eqb hd1 hd2) && (eqbList tl1 tl2)
      | _           , _            => false
    end.

  Lemma eqbListEqList : forall l1 l2, eqbList l1 l2 = true <-> eqList l1 l2.

  Definition eqbST (cp1 cp2 : tST) :=
    eqbList (PosSort.sort (CPToList cp1)) (PosSort.sort (CPToList cp2)).

  Lemma eqbST_eqST : forall cp1 cp2, eqbST cp1 cp2 = true <-> eqST cp1 cp2.

  Fixpoint ltList (l1 l2 : list positive) :=
    match l1, l2 with
      | nil, nil => False
      | (hd1 :: tl1), (hd2 :: tl2) => if (Pos.ltb hd1 hd2) then True
                                      else if (Pos.ltb hd2 hd1) then False
                                           else (ltList tl1 tl2)
      | nil, _ => True
      | _, nil => False
    end.

  Lemma lengthOne : forall (l : list positive),
    length l = 1 -> exists a, l = a :: nil.

  Lemma lengthAtLeastOne : forall (l : list positive) n,
    length l = (S n) -> exists a0 l0, l = a0 :: l0.

  Lemma ltListTrans : forall m x y z,
    length x = (S m) ->
    length y = (S m) ->
    length z = (S m) ->
    ltList x y -> ltList y z -> ltList x z.

  Lemma sortOK : forall m l, length l = m -> length (sort l) = m.

  Definition ltST (cp1 cp2 : tST) :=
    ltList (PosSort.sort (CPToList cp1)) (PosSort.sort (CPToList cp2)).

  Lemma ltTrans : Transitive ltST.

  Lemma ltListIrrefl : forall l, ltList l l -> False.

  Lemma eqListOK : forall l1 l2, eqList l1 l2 -> l1 = l2.

  Fixpoint compareList (l1 l2 : list positive) :=
    match l1, l2 with
    | nil, nil => Eq
    | (hd1 :: tl1), (hd2 :: tl2) => match Pos.compare hd1 hd2 with
                                    | Lt => Lt
                                    | Eq => compareList tl1 tl2
                                    | Gt => Gt
                                    end
    | nil, _ => Lt
    | _, nil => Gt
    end.

  Lemma compareListSpec : forall l1 l2,
    CompSpec eqList ltList l1 l2 (compareList l1 l2).

  Definition compareST (cp1 cp2 : tST) :=
    compareList (PosSort.sort (CPToList cp1)) (PosSort.sort (CPToList cp2)).

  Lemma compare_spec : forall cp1 cp2,
    CompSpec eqST ltST cp1 cp2 (compareST cp1 cp2).

  Definition STelt := tST.

  Definition STt := list tST.

  Definition STempty : STt := nil.

  Lemma eqST_dec : forall x y, {eqST x y} + {~ eqST x y}.

  Definition STadd (x : STelt) (s : STt) := cons x s.

  Fixpoint STexists_ (f : STelt -> bool) (s : STt) :=
    match s with
      | nil      => false
      | hd :: tl => f hd || STexists_ f tl
    end.

  Fixpoint STmem elt l :=
    match l with
      | nil      => false
      | hd :: tl => if eqST_dec hd elt then true else STmem elt tl
    end.

  Lemma STempty_b : forall y : STelt, STmem y STempty = false.

  Lemma STexists_mem_4 :
    forall f (s : STt),
      STexists_ f s = true ->
      exists x : STelt ,  STmem x s = true /\ f x = true.

  Lemma STadd_iff : forall (s : STt) (x y : STelt),
    STmem y (STadd x s) = true <-> (eqST x y \/ STmem y s = true).

End Set_of_tuple_of_positive. *)

Require Import GeoCoq.Meta_theory.Models.tarski_to_col_theory.
(* GeoCoq.Meta_theory.Models.tarski_to_col_theory:
Require Export GeoCoq.Tarski_dev.Ch06_out_lines.
Require Import GeoCoq.Tactics.Coinc.tactics_axioms.

Section Tarski_is_a_Col_theory.

Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.

Global Instance Tarski_is_a_Col_theory : (Col_theory Tpoint Col).

End Tarski_is_a_Col_theory. *)

Require Import GeoCoq.Tactics.Coinc.ColR.
(* GeoCoq.Tactics.Coinc.ColR:
Require Import Recdef.
Require Import NArith.
Require Import GeoCoq.Utils.sets.

Module SSWP := WPropertiesOn SetOfSetsOfPositiveOrderedType SS.

Module SSWEqP := WEqPropertiesOn SetOfSetsOfPositiveOrderedType SS.

Module SPWEqP := WEqPropertiesOn SetOfPairsOfPositiveOrderedType SP.

Definition pick_line (s : SS.elt) (sp : SP.t) :=
  SP.exists_ (fun p => (S.mem (fstpp p) s) && (S.mem (sndpp p) s)) sp.

Lemma proper_00 : forall s,
  Proper
  ((fun t1 t2 : SetOfPairsOfPositiveOrderedType.t =>

Lemma proper_0 :
  Proper (S.Equal ==> eq ==> eq) pick_line.

Lemma proper_1 : forall s1 sp,
  Proper (S.Equal ==> eq)

Definition exists_witness (f : SS.elt -> bool) (s : SS.t) : option SS.elt :=
  SS.choose (SS.filter f s).

Lemma exists_witness_ok : forall e f s,
  Proper (S.Equal ==> eq) f ->

Definition pick_lines_aux (s1 : SS.elt)
                          (ss : SS.t)
                          (sp : SP.t)
                          : (option (SS.elt * SS.elt)) :=
  match ((exists_witness (fun s2 => let i := S.inter s1 s2 in
                                    pick_line i sp)) ss) with
    | None => None
    | Some s2 => Some(s1,s2)
  end.

Definition pick_lines (ss : SS.t) (sp : SP.t)
                      : (option (SS.elt * SS.elt)) :=
  match (exists_witness (fun s =>
                           match (pick_lines_aux s (SS.remove s ss) sp) with
                             | None => false
                             | _ => true
                           end) ss) with
    | None => None
    | Some s1 => pick_lines_aux s1 (SS.remove s1 ss) sp
  end.

Definition eqop (p1 p2 : option SS.elt) :=
  match p1,p2 with
    | None, None => True
    | Some s1, Some s2 => True
    | _, _ => False
  end.

Lemma proper_2 : forall (f1 f2 : SS.elt -> bool) (s1 s2 : SS.t),

Definition eqopp (p1 p2 : option (SS.elt * SS.elt)) :=
  match p1,p2 with
    | None, None => True
    | Some s1, Some s2 => True
    | _, _ => False
  end.

Lemma proper_3 : Proper (S.Equal ==> SS.Equal ==> eq ==> eqopp) pick_lines_aux.

Lemma pick_lines_ok_1 : forall s1 s2 ss sp,
  pick_lines ss sp = Some(s1,s2) ->
  SS.In s1 ss.

Lemma pick_lines_ok_2 : forall s1 s2 ss sp,
  pick_lines ss sp = Some(s1,s2) ->
  SS.In s2 (SS.remove s1 ss).

Definition test_col (ss : SS.t) (sp : SP.t) p1 p2 p3 : bool :=
  let newss := identify_lines ss sp  in
    SS.exists_ (fun s => S.mem p1 s && S.mem p2 s && S.mem p3 s) newss.

Section Col_refl.

Context `{CT:Col_theory}.

Lemma CTcol_permutation_5 : forall A B C : COLTpoint, CTCol A B C -> CTCol A C B.

Lemma CTcol_permutation_2 : forall A B C : COLTpoint, CTCol A B C -> CTCol C A B.

Lemma CTcol_permutation_3 : forall A B C : COLTpoint, CTCol A B C -> CTCol C B A.

Lemma CTcol_permutation_4 : forall A B C : COLTpoint, CTCol A B C -> CTCol B A C.

Lemma CTcol_trivial_1 : forall A B : COLTpoint, CTCol A A B.

Lemma CTcol_trivial_2 : forall A B : COLTpoint, CTCol A B B.

Definition ss_ok (ss : SS.t) (interp: positive -> COLTpoint) :=
  forall s, SS.mem s ss = true ->
  forall p1 p2 p3, S.mem p1 s && S.mem p2 s && S.mem p3 s = true ->
    CTCol (interp p1) (interp p2) (interp p3).

Definition sp_ok (sp : SP.t) (interp: positive -> COLTpoint) :=
  forall p, SP.mem p sp = true -> interp (fstpp p) <> interp (sndpp p).

Lemma identify_lines_ok : forall ss sp interp,
  ss_ok ss interp -> sp_ok sp interp ->
  ss_ok (identify_lines ss sp) interp.

Lemma test_col_ok : forall ss sp interp p1 p2 p3,
  ss_ok ss interp -> sp_ok sp interp ->
  test_col ss sp p1 p2 p3 = true ->
  CTCol (interp p1) (interp p2) (interp p3).

Lemma ss_ok_empty : forall interp,
  ss_ok SS.empty interp.

Lemma sp_ok_empty : forall interp,
  sp_ok SP.empty interp.

Lemma collect_cols :
  forall (A B C : COLTpoint) (HCol : CTCol A B C) pa pb pc ss (interp :  positive -> COLTpoint),
  interp pa = A ->
  interp pb = B ->
  interp pc = C ->
  ss_ok ss interp -> ss_ok (SS.add (S.add pa (S.add pb (S.add pc S.empty))) ss) interp.

Lemma collect_diffs :
  forall (A B : COLTpoint) (H : A <> B) pa pb sp (interp :  positive -> COLTpoint),
  interp pa = A ->
  interp pb = B ->
  sp_ok sp interp -> sp_ok (SP.add (pa, pb) sp) interp.

Definition list_assoc_inv :=
  (fix list_assoc_inv_rec (A:Type) (B:Set)
                          (eq_dec:forall e1 e2:B, {e1 = e2} + {e1 <> e2})
                          (lst : list (prodT A B)) {struct lst} : B -> A -> A :=
  fun (key:B) (default:A) =>
    match lst with
      | nil => default
      | cons (pairT v e) l =>
        match eq_dec e key with
          | left _ => v
          | right _ => list_assoc_inv_rec A B eq_dec l key default
        end
    end).

Lemma positive_dec : forall (p1 p2:positive), {p1=p2}+{~p1=p2}.

Definition interp (lvar : list (COLTpoint * positive)) (Default : COLTpoint) : positive -> COLTpoint := 
  fun p => list_assoc_inv COLTpoint positive positive_dec lvar p Default.

Definition eq_tagged (lvar : list (COLTpoint * positive)) := lvar = lvar.

Lemma eq_eq_tagged : forall lvar, lvar = lvar -> eq_tagged lvar.

Definition partition_ss e ss :=
  SS.partition (fun s => S.mem e s) ss.

Definition fst_ss (pair : SS.t * SS.t) :=
 match pair with
    |(a,b) => a
  end.

Definition snd_ss (pair : SS.t * SS.t) :=
 match pair with
    |(a,b) => b
  end.

Definition subst_in_set p1 p2 s := S.add p1 (S.remove p2 s).

Definition subst_in_ss_aux p1 p2 := (fun s ss => SS.add (subst_in_set p1 p2 s) ss).

Definition subst_in_ss p1 p2 ss :=
  let pair := partition_ss p2 ss in
  let fss := fst_ss(pair) in
  let sss := snd_ss(pair) in
  let newfss := SS.fold (subst_in_ss_aux p1 p2) fss SS.empty in
  SS.union newfss sss.

Lemma proper_4 : forall p, Proper (S.Equal ==> eq) (fun s : SS.elt => S.mem p s).

Lemma proper_5 : forall p, Proper (S.Equal ==> eq) (fun s : SS.elt => negb (S.mem p s)).

Lemma subst_ss_ok :
  forall (A B : COLTpoint) (H : A = B) pa pb ss (interp :  positive -> COLTpoint),
  interp pa = A ->
  interp pb = B ->
  ss_ok ss interp -> ss_ok (subst_in_ss pa pb ss) interp.

Definition partition_sp_1 p sp :=
  SP.partition (fun e => Pos.eqb (fstpp e) p || Pos.eqb (sndpp e) p) sp.

Definition partition_sp_2 p sp :=
  SP.partition (fun e => Pos.eqb (fstpp e) p) sp.

Definition fst_sp (pair : SP.t * SP.t) :=
 match pair with
    |(a,b) => a
  end.

Definition snd_sp (pair : SP.t * SP.t) :=
 match pair with
    |(a,b) => b
  end.

Definition new_pair_1 pair (pos : positive) := (pos, sndpp(pair)).

Definition new_pair_2 pair (pos : positive) := (fstpp(pair), pos).

Definition subst_in_sp_aux_1 := (fun pos pair sp => SP.add (new_pair_1 pair pos) sp).

Definition subst_in_sp_aux_2 := (fun pos pair sp => SP.add (new_pair_2 pair pos) sp).

Definition subst_in_sp p1 p2 sp :=
  let pair_1 := partition_sp_1 p2 sp in
  let sp_to_modify := fst_sp(pair_1) in
  let sp_to_keep := snd_sp(pair_1) in
  let pair_2 := partition_sp_2 p2 sp_to_modify in
  let sp_to_modify_f := fst_sp(pair_2) in
  let sp_to_modify_s := snd_sp(pair_2) in
  let newsp_to_modify_f := SP.fold (subst_in_sp_aux_1 p1) sp_to_modify_f SP.empty in
  let newsp_to_modify_s := SP.fold (subst_in_sp_aux_2 p1) sp_to_modify_s SP.empty in
  SP.union (SP.union newsp_to_modify_f newsp_to_modify_s) sp_to_keep.

Lemma proper_6 : forall p, Proper ((fun t1 t2 : SetOfPairsOfPositiveOrderedType.t =>

Lemma proper_7 : forall p, Proper ((fun t1 t2 : SetOfPairsOfPositiveOrderedType.t =>

Lemma proper_8 : forall p, Proper ((fun t1 t2 : SetOfPairsOfPositiveOrderedType.t =>

Lemma proper_9 : forall p, Proper ((fun t1 t2 : SetOfPairsOfPositiveOrderedType.t =>

Lemma subst_sp_ok :
  forall (A B : COLTpoint) (H : A = B) pa pb sp (interp :  positive -> COLTpoint),
  interp pa = A ->
  interp pb = B ->
  sp_ok sp interp -> sp_ok (subst_in_sp pa pb sp) interp.

End Col_refl. *)



Ltac add_to_distinct_list x xs :=

  match xs with

    | nil     => constr:(x::xs)

    | x::_    => fail 1

    | ?y::?ys => let zs := add_to_distinct_list x ys in constr:(y::zs)

  end.



Ltac collect_points_list Tpoint xs :=

  match goal with

    | N : Tpoint |- _ => let ys := add_to_distinct_list N xs in

                           collect_points_list Tpoint ys

    | _               => xs

  end.



Ltac collect_points Tpoint := collect_points_list Tpoint (@nil Tpoint).



Ltac number_aux Tpoint lvar cpt :=

  match constr:(lvar) with

    | nil          => constr:(@nil (prodT Tpoint positive))

    | cons ?H ?T => let scpt := eval vm_compute in (Pos.succ cpt) in

                    let lvar2 := number_aux Tpoint T scpt in

                      constr:(cons (@pairT  Tpoint positive H cpt) lvar2)

  end.



Ltac number Tpoint lvar := number_aux Tpoint lvar (1%positive).



Ltac build_numbered_points_list Tpoint := let lvar := collect_points Tpoint in number Tpoint lvar.



Ltac List_assoc Tpoint elt lst :=

  match constr:(lst) with

    | nil => fail

    | (cons (@pairT Tpoint positive ?X1 ?X2) ?X3) =>

      match constr:(elt = X1) with

        | (?X1 = ?X1) => constr:(X2)

        | _ => List_assoc Tpoint elt X3

      end

  end.



Definition Tagged P : Prop := P.



Lemma PropToTagged : forall P : Prop, P -> Tagged P.

Proof. trivial. Qed.



Ltac assert_ss_ok Tpoint Col lvar :=

  repeat

  match goal with

    | HCol : Col ?A ?B ?C, HOK : ss_ok ?SS ?Interp |- _ =>

        let pa := List_assoc Tpoint A lvar in

        let pb := List_assoc Tpoint B lvar in

        let pc := List_assoc Tpoint C lvar in

         apply PropToTagged in HCol;

         apply (collect_cols A B C HCol pa pb pc SS Interp) in HOK; try reflexivity

  end.



Ltac assert_sp_ok Tpoint Col lvar :=

  repeat

  match goal with

    | HDiff : ?A <> ?B, HOK : sp_ok ?SP ?Interp |- _ =>

        let pa := List_assoc Tpoint A lvar in

        let pb := List_assoc Tpoint B lvar in

          apply PropToTagged in HDiff;

          apply (collect_diffs A B HDiff pa pb SP Interp) in HOK; try reflexivity

  end.



Ltac subst_in_cols Tpoint Col :=

  repeat

  match goal with

    | HOKSS : ss_ok ?SS ?Interp, HOKSP : sp_ok ?SP ?Interp, HL : eq_tagged ?Lvar, HEQ : ?A = ?B |- _ =>

      let pa := List_assoc Tpoint A Lvar in

      let pb := List_assoc Tpoint B Lvar in

        apply (subst_ss_ok A B HEQ pa pb SS Interp) in HOKSS; try reflexivity;

        apply (subst_sp_ok A B HEQ pa pb SP Interp) in HOKSP; try reflexivity;

        subst B

  end.



Ltac clear_cols_aux Tpoint Col :=

  repeat

  match goal with

    | HOKSS : ss_ok ?SS ?Interp, HOKSP : sp_ok ?SP ?Interp, HL : eq_tagged ?Lvar |- _ =>

      clear HOKSS; clear HOKSP; clear HL

  end.



Ltac tag_hyps_gen Tpoint Col :=

  repeat

  match goal with

    | HDiff : ?A <> ?B |- _ => apply PropToTagged in HDiff

    | HCol : Col ?A ?B ?C |- _ => apply PropToTagged in HCol

  end.



Ltac untag_hyps_gen Tpoint Col := unfold Tagged in *.



Ltac show_all' :=

  repeat

  match goal with

    | Hhidden : Something |- _ => show Hhidden

  end.



Ltac clear_cols_gen Tpoint Col := show_all'; clear_cols_aux Tpoint Col.



Ltac Col_refl Tpoint Col :=

  match goal with

    | Default : Tpoint |- Col ?A ?B ?C =>

        let lvar := build_numbered_points_list Tpoint in

        let pa := List_assoc Tpoint A lvar in

        let pb := List_assoc Tpoint B lvar in

        let pc := List_assoc Tpoint C lvar in

        let c := ((vm_compute;reflexivity) || fail 2 "Can not be deduced") in

        let HSS := fresh in

          assert (HSS := @ss_ok_empty Tpoint Col (interp lvar Default)); assert_ss_ok Tpoint Col lvar;

        let HSP := fresh in

          assert (HSP := @sp_ok_empty Tpoint (interp lvar Default)); assert_sp_ok Tpoint Col lvar; 

          match goal with

            | HOKSS : ss_ok ?SS ?Interp, HOKSP : sp_ok ?SP ?Interp |- _ =>

              apply (test_col_ok SS SP Interp pa pb pc HOKSS HOKSP); c

          end

  end.



Ltac deduce_cols_hide_aux Tpoint Col :=

  match goal with

    | Default : Tpoint |- _ =>

        let lvar := build_numbered_points_list Tpoint in

        let HSS := fresh in

          assert (HSS := @ss_ok_empty Tpoint Col (interp lvar Default)); assert_ss_ok Tpoint Col lvar;

        let HSP := fresh in

          assert (HSP := @sp_ok_empty Tpoint (interp lvar Default)); assert_sp_ok Tpoint Col lvar;

        let HL := fresh in

          assert (HL : lvar = lvar) by reflexivity;

          apply (@eq_eq_tagged Tpoint) in HL;

          hide HSS; hide HSP; hide HL

  end.



Ltac deduce_cols_hide_gen Tpoint Col := deduce_cols_hide_aux Tpoint Col.



Ltac update_cols_aux Tpoint Col :=

  match goal with

    | HOKSS : ss_ok ?SS ?Interp, HOKSP : sp_ok ?SP ?Interp, HEQ : eq_tagged ?Lvar |- _ =>

      assert_ss_ok Tpoint Col Lvar; assert_sp_ok Tpoint Col Lvar; subst_in_cols Tpoint Col; hide HOKSS; hide HOKSP; hide HEQ

  end.



Ltac update_cols_gen Tpoint Col := show_all'; update_cols_aux Tpoint Col.



Ltac cols_aux Tpoint Col :=

  match goal with

    | HOKSS : ss_ok ?SS ?Interp, HOKSP : sp_ok ?SP ?Interp, HL : eq_tagged ?Lvar |- Col ?A ?B ?C =>

      let pa := List_assoc Tpoint A Lvar in

      let pb := List_assoc Tpoint B Lvar in

      let pc := List_assoc Tpoint C Lvar in

      let c := ((vm_compute;reflexivity) || fail 1 "Can not be deduced") in

        apply (test_col_ok SS SP Interp pa pb pc ); [assumption|assumption|c];

        hide HOKSS; hide HOKSP; hide HL

  end.



Ltac cols_gen Tpoint Col := show_all'; cols_aux Tpoint Col.



Ltac Col_refl_test Tpoint Col := deduce_cols_hide_gen Tpoint Col; cols_gen Tpoint Col.

