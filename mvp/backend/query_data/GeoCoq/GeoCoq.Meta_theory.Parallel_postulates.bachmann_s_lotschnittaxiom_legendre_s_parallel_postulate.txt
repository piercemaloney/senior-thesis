Require Import GeoCoq.Axioms.parallel_postulates.
(* GeoCoq.Axioms.parallel_postulates:
Require Import GeoCoq.Tarski_dev.Definitions.

Section Euclid_def.

Context `{Tn:Tarski_neutral_dimensionless}.

Definition decidability_of_parallelism := forall A B C D,
  Par A B C D \/ ~ Par A B C D.

Definition decidability_of_not_intersection := forall A B C D,
  ~ (exists I, Col I A B /\ Col I C D) \/
  ~ ~ (exists I, Col I A B /\ Col I C D).

Definition decidability_of_intersection := forall A B C D,
  (exists I, Col I A B /\ Col I C D) \/
  ~ (exists I, Col I A B /\ Col I C D).

Definition tarski_s_parallel_postulate := forall A B C D T,
  Bet A D T -> Bet B D C -> A <> D ->
  exists X Y, Bet A B X /\ Bet A C Y /\ Bet X T Y.

Definition playfair_s_postulate := forall A1 A2 B1 B2 C1 C2 P,
  Par A1 A2 B1 B2 -> Col P B1 B2 ->
  Par A1 A2 C1 C2 -> Col P C1 C2 ->
  Col C1 B1 B2 /\ Col C2 B1 B2.

Definition triangle_postulate := forall A B C D E F,
  TriSumA A B C D E F -> Bet D E F.

Definition bachmann_s_lotschnittaxiom := forall P Q R P1 R1,
  P <> Q -> Q <> R -> Per P Q R -> Per Q P P1 -> Per Q R R1 ->
  Coplanar P Q R P1 -> Coplanar P Q R R1 ->
  exists S, Col P P1 S /\ Col R R1 S.

Definition postulate_of_transitivity_of_parallelism := forall A1 A2 B1 B2 C1 C2,
  Par A1 A2 B1 B2 -> Par B1 B2 C1 C2 ->
  Par A1 A2 C1 C2.

Definition midpoint_converse_postulate := forall A B C P Q,
  ~ Col A B C ->
  Midpoint P B C -> Par A B Q P -> Col A C Q ->
  Midpoint Q A C.

Definition alternate_interior_angles_postulate := forall A B C D,
  TS A C B D -> Par A B C D ->
  CongA B A C D C A.

Definition consecutive_interior_angles_postulate := forall A B C D,
  OS B C A D -> Par A B C D -> SuppA A B C B C D.

Definition perpendicular_transversal_postulate := forall A B C D P Q,
  Par A B C D -> Perp A B P Q -> Coplanar C D P Q ->
  Perp C D P Q.

Definition postulate_of_parallelism_of_perpendicular_transversals :=
  forall A1 A2 B1 B2 C1 C2 D1 D2,
    Par A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 ->
    Coplanar A1 A2 C1 D1 -> Coplanar A1 A2 C1 D2 ->
    Coplanar A1 A2 C2 D1 -> Coplanar A1 A2 C2 D2 ->
    Par C1 C2 D1 D2.

Definition universal_posidonius_postulate := forall A1 A2 A3 A4 B1 B2 B3 B4,
  Par A1 A2 B1 B2 ->
  Col A1 A2 A3 -> Col B1 B2 B3 -> Perp A1 A2 A3 B3 ->
  Col A1 A2 A4 -> Col B1 B2 B4 -> Perp A1 A2 A4 B4 ->
  Cong A3 B3 A4 B4.

Definition alternative_playfair_s_postulate := forall A1 A2 B1 B2 C1 C2 P,
  Perp2 A1 A2 B1 B2 P -> ~ Col A1 A2 P -> Col P B1 B2 -> Coplanar A1 A2 B1 B2 ->
  Par A1 A2 C1 C2 -> Col P C1 C2 ->
  Col C1 B1 B2 /\ Col C2 B1 B2.

Definition proclus_postulate := forall A B C D P Q,
  Par A B C D -> Col A B P -> ~ Col A B Q -> Coplanar C D P Q ->
  exists Y, Col P Q Y /\ Col C D Y.

Definition alternative_proclus_postulate := forall A B C D P Q,
  Perp2 A B C D P -> ~ Col C D P -> Coplanar A B C D ->
  Col A B P -> ~ Col A B Q -> Coplanar C D P Q ->
  exists Y, Col P Q Y /\ Col C D Y.

Definition triangle_circumscription_principle := forall A B C,
  ~ Col A B C ->
  exists CC, Cong A CC B CC /\ Cong A CC C CC /\ Coplanar A B C CC.

Definition inverse_projection_postulate := forall A B C P Q,
  Acute A B C ->
  Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q ->
  exists Y, Out B C Y /\ Col P Q Y.

Definition euclid_5 := forall P Q R S T U,
  BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S ->
  Cong P T Q T -> Cong R T S T ->
  exists I, BetS S Q I /\ BetS P U I.

Definition strong_parallel_postulate :=  forall P Q R S T U,
  BetS P T Q -> BetS R T S -> ~ Col P R U ->
  Coplanar P Q R U ->
  Cong P T Q T -> Cong R T S T ->
  exists I, Col S Q I /\ Col P U I.

Definition alternative_strong_parallel_postulate := forall A B C D P Q R,
  OS B C A D -> SumA A B C B C D P Q R -> ~ Bet P Q R ->
  exists Y, Col B A Y /\ Col C D Y.

Definition euclid_s_parallel_postulate := forall A B C D P Q R,
  OS B C A D -> SAMS A B C B C D -> SumA A B C B C D P Q R -> ~ Bet P Q R ->
  exists Y, Out B A Y /\ Out C D Y.

Definition postulate_of_existence_of_a_triangle_whose_angles_sum_to_two_rights :=
  exists A B C D E F, ~ Col A B C /\ TriSumA A B C D E F /\ Bet D E F.

Definition posidonius_postulate :=
  exists A1 A2 B1 B2,
    ~ Col A1 A2 B1 /\ B1 <> B2 /\ Coplanar A1 A2 B1 B2 /\
    forall A3 A4 B3 B4,
      Col A1 A2 A3 -> Col B1 B2 B3 -> Perp A1 A2 A3 B3 ->
      Col A1 A2 A4 -> Col B1 B2 B4 -> Perp A1 A2 A4 B4 ->
      Cong A3 B3 A4 B4.

Definition postulate_of_existence_of_similar_triangles :=
  exists A B C D E F,
    ~ Col A B C /\ ~ Cong A B D E /\
    CongA A B C D E F /\ CongA B C A E F D /\ CongA C A B F D E.

Definition thales_postulate := forall A B C M,
  ~ Col A B C -> Midpoint M A B -> Cong M A M C ->
  Per A C B.

Definition thales_converse_postulate := forall A B C M,
  ~ Col A B C -> Midpoint M A B -> Per A C B ->
  Cong M A M C.

Definition existential_thales_postulate :=
  exists A B C M, ~ Col A B C /\ Midpoint M A B /\ Cong M A M C /\ Per A C B.

Definition postulate_of_right_saccheri_quadrilaterals := forall A B C D,
  Saccheri A B C D -> Per A B C.

Definition postulate_of_existence_of_a_right_saccheri_quadrilateral :=
  exists A B C D, Saccheri A B C D /\ Per A B C.

Definition postulate_of_right_lambert_quadrilaterals := forall A B C D,
  Lambert A B C D -> Per B C D.

Definition postulate_of_existence_of_a_right_lambert_quadrilateral :=
  exists A B C D, Lambert A B C D /\ Per B C D.

Definition weak_inverse_projection_postulate := forall A B C D E F P Q,
  Acute A B C -> Per D E F -> SumA A B C A B C D E F ->
  Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q ->
  exists Y, Out B C Y /\ Col P Q Y.

Definition weak_tarski_s_parallel_postulate := forall A B C T,
  Per A B C -> InAngle T A B C ->
  exists X Y, Out B A X /\ Out B C Y /\ Bet X T Y.

Definition weak_triangle_circumscription_principle := forall A B C A1 A2 B1 B2,
  ~ Col A B C -> Per A C B ->
  Perp_bisect A1 A2 B C -> Perp_bisect B1 B2 A C ->
  Coplanar A B C A1 -> Coplanar A B C A2 ->
  Coplanar A B C B1 -> Coplanar A B C B2 ->
  exists I, Col A1 A2 I /\ Col B1 B2 I.

Definition legendre_s_parallel_postulate :=
  exists A B C,
    ~ Col A B C /\ Acute A B C /\
    forall T,
      InAngle T A B C ->
      exists X Y, Out B A X /\ Out B C Y /\ Bet X T Y.

Definition existential_playfair_s_postulate :=
  exists A1 A2 P, ~ Col A1 A2 P /\
             (forall B1 B2 C1 C2,
                Par A1 A2 B1 B2 -> Col P B1 B2 ->
                Par A1 A2 C1 C2 -> Col P C1 C2 ->
                Col C1 B1 B2 /\ Col C2 B1 B2).

End Euclid_def. *)

Require Import GeoCoq.Tarski_dev.Annexes.suma.
(* GeoCoq.Tarski_dev.Annexes.suma:
Require Export GeoCoq.Tarski_dev.Ch11_angles.

Section Suma_1.

Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.

Lemma suma_distincts : forall A B C D E F G H I, SumA A B C D E F G H I ->
   A<>B /\ B<>C /\ D<>E /\ E<>F /\ G<>H /\ H<>I.

Lemma trisuma_distincts : forall A B C D E F, TriSumA A B C D E F ->
  A <> B /\ B <> C /\ A <> C /\ D <> E /\ E <> F.

Lemma ex_suma : forall A B C D E F, A<>B -> B<>C -> D<>E -> E<>F ->
   exists G H I, SumA A B C D E F G H I.

Lemma suma2__conga : forall A B C D E F G H I G' H' I',
   SumA A B C D E F G H I -> SumA A B C D E F G' H' I' -> CongA G H I G' H' I'.

Lemma suma_sym : forall A B C D E F G H I, SumA A B C D E F G H I -> SumA D E F A B C G H I.

Lemma conga3_suma__suma : forall A B C D E F G H I A' B' C' D' E' F' G' H' I',
   SumA A B C D E F G H I ->
   CongA A B C A' B' C' ->
   CongA D E F D' E' F' ->
   CongA G H I G' H' I' ->
   SumA A' B' C' D' E' F' G' H' I'.

Lemma out6_suma__suma : forall A B C D E F G H I A' C' D' F' G' I',
   SumA A B C D E F G H I -> Out B A A' -> Out B C C' -> Out E D D' ->
   Out E F F' -> Out H G G' -> Out H I I' -> SumA A' B C' D' E F' G' H I'.

Lemma out546_suma__conga : forall A B C D E F G H I, SumA A B C D E F G H I ->
   Out E D F -> CongA A B C G H I.

Lemma out546__suma : forall A B C D E F, A <> B -> B <> C -> Out E D F -> SumA A B C D E F A B C.

Lemma out213_suma__conga : forall A B C D E F G H I, SumA A B C D E F G H I ->
   Out B A C -> CongA D E F G H I.

Lemma out213__suma : forall A B C D E F, D <> E -> E <> F -> Out B A C -> SumA A B C D E F D E F.

Lemma suma_left_comm : forall A B C D E F G H I,
   SumA A B C D E F G H I -> SumA C B A D E F G H I.

Lemma suma_middle_comm : forall A B C D E F G H I,
   SumA A B C D E F G H I -> SumA A B C F E D G H I.

Lemma suma_right_comm : forall A B C D E F G H I,
   SumA A B C D E F G H I -> SumA A B C D E F I H G.

Lemma suma_comm : forall A B C D E F G H I,
   SumA A B C D E F G H I -> SumA C B A F E D I H G.

Lemma ts__suma : forall A B C D, TS A B C D -> SumA C B A A B D C B D.

Lemma inangle__suma : forall A B C P, InAngle P A B C -> SumA A B P P B C A B C.

Lemma bet__suma : forall A B C P, A <> B -> B <> C -> P <> B -> Bet A B C ->
  SumA A B P P B C A B C.

Lemma sams_chara : forall A B C D E F A', A<>B -> A'<>B -> Bet A B A' ->
   (SAMS A B C D E F <-> LeA D E F C B A').

Lemma sams_distincts : forall A B C D E F, SAMS A B C D E F ->
   A<>B /\ B<>C /\ D<>E /\ E<>F.

Lemma sams_sym : forall A B C D E F, SAMS A B C D E F ->
   SAMS D E F A B C.

Lemma sams_right_comm : forall A B C D E F, SAMS A B C D E F ->
   SAMS A B C F E D.

Lemma sams_left_comm : forall A B C D E F, SAMS A B C D E F ->
   SAMS C B A D E F.

Lemma sams_comm : forall A B C D E F, SAMS A B C D E F ->
   SAMS C B A F E D.

Lemma conga2_sams__sams : forall A B C D E F A' B' C' D' E' F',
   CongA A B C A' B' C' -> CongA D E F D' E' F' ->
   SAMS A B C D E F -> SAMS A' B' C' D' E' F'.

Lemma out546__sams : forall A B C D E F, A <> B -> B <> C -> Out E D F -> SAMS A B C D E F.

Lemma out213__sams : forall A B C D E F, D <> E -> E <> F -> Out B A C -> SAMS A B C D E F.

Lemma bet_suma__sams : forall A B C D E F G H I, SumA A B C D E F G H I -> Bet G H I ->
  SAMS A B C D E F.

Lemma bet__sams : forall A B C P, A <> B -> B <> C -> P <> B -> Bet A B C -> SAMS A B P P B C.

Lemma suppa__sams : forall A B C D E F, SuppA A B C D E F -> SAMS A B C D E F.

Lemma inangle__sams : forall A B C P, InAngle P A B C -> SAMS A B P P B C.

End Suma_1.

Ltac assert_diffs :=
repeat
 match goal with
      | H:(~Col ?X1 ?X2 ?X3) |- _ =>
      let h := fresh in
      not_exist_hyp3 X1 X2 X1 X3 X2 X3;
      assert (h := not_col_distincts X1 X2 X3 H);decompose [and] h;clear h;clean_reap_hyps

      | H:(~Bet ?X1 ?X2 ?X3) |- _ =>
      let h := fresh in
      not_exist_hyp2 X1 X2 X2 X3;
      assert (h := not_bet_distincts X1 X2 X3 H);decompose [and] h;clear h;clean_reap_hyps
      | H:Bet ?A ?B ?C, H2 : ?A <> ?B |-_ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= bet_neq12__neq A B C H H2);clean_reap_hyps
      | H:Bet ?A ?B ?C, H2 : ?B <> ?A |-_ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= bet_neq21__neq A B C H H2);clean_reap_hyps
      | H:Bet ?A ?B ?C, H2 : ?B <> ?C |-_ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= bet_neq23__neq A B C H H2);clean_reap_hyps
      | H:Bet ?A ?B ?C, H2 : ?C <> ?B |-_ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= bet_neq32__neq A B C H H2);clean_reap_hyps

      | H:Cong ?A ?B ?C ?D, H2 : ?A <> ?B |-_ =>
      let T:= fresh in (not_exist_hyp_comm C D);
        assert (T:= cong_diff A B C D H2 H);clean_reap_hyps
      | H:Cong ?A ?B ?C ?D, H2 : ?B <> ?A |-_ =>
      let T:= fresh in (not_exist_hyp_comm C D);
        assert (T:= cong_diff_2 A B C D H2 H);clean_reap_hyps
      | H:Cong ?A ?B ?C ?D, H2 : ?C <> ?D |-_ =>
      let T:= fresh in (not_exist_hyp_comm A B);
        assert (T:= cong_diff_3 A B C D H2 H);clean_reap_hyps
      | H:Cong ?A ?B ?C ?D, H2 : ?D <> ?C |-_ =>
      let T:= fresh in (not_exist_hyp_comm A B);
        assert (T:= cong_diff_4 A B C D H2 H);clean_reap_hyps

      | H:Le ?A ?B ?C ?D, H2 : ?A <> ?B |-_ =>
      let T:= fresh in (not_exist_hyp_comm C D);
        assert (T:= le_diff A B C D H2 H);clean_reap_hyps
      | H:Le ?A ?B ?C ?D, H2 : ?B <> ?A |-_ =>
      let T:= fresh in (not_exist_hyp_comm C D);
        assert (T:= le_diff A B C D (swap_diff B A H2) H);clean_reap_hyps
      | H:Lt ?A ?B ?C ?D |-_ =>
      let T:= fresh in (not_exist_hyp_comm C D);
        assert (T:= lt_diff A B C D H);clean_reap_hyps

      | H:Midpoint ?I ?A ?B, H2 : ?A<>?B |- _ =>
      let T:= fresh in (not_exist_hyp2 I B I A);
       assert (T:= midpoint_distinct_1 I A B H2 H);
       decompose [and] T;clear T;clean_reap_hyps
      | H:Midpoint ?I ?A ?B, H2 : ?B<>?A |- _ =>
      let T:= fresh in (not_exist_hyp2 I B I A);
       assert (T:= midpoint_distinct_1 I A B (swap_diff B A H2) H);
       decompose [and] T;clear T;clean_reap_hyps

      | H:Midpoint ?I ?A ?B, H2 : ?I<>?A |- _ =>
      let T:= fresh in (not_exist_hyp2 I B A B);
       assert (T:= midpoint_distinct_2 I A B H2 H);
       decompose [and] T;clear T;clean_reap_hyps
      | H:Midpoint ?I ?A ?B, H2 : ?A<>?I |- _ =>
      let T:= fresh in (not_exist_hyp2 I B A B);
       assert (T:= midpoint_distinct_2 I A B (swap_diff A I H2) H);
       decompose [and] T;clear T;clean_reap_hyps

      | H:Midpoint ?I ?A ?B, H2 : ?I<>?B |- _ =>
      let T:= fresh in (not_exist_hyp2 I A A B);
       assert (T:= midpoint_distinct_3 I A B H2 H);
       decompose [and] T;clear T;clean_reap_hyps
      | H:Midpoint ?I ?A ?B, H2 : ?B<>?I |- _ =>
      let T:= fresh in (not_exist_hyp2 I A A B);
       assert (T:= midpoint_distinct_3 I A B (swap_diff B I H2) H);
       decompose [and] T;clear T;clean_reap_hyps

      | H:Per ?A ?B ?C, H2 : ?A<>?B |- _ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= per_distinct A B C H H2); clean_reap_hyps
      | H:Per ?A ?B ?C, H2 : ?B<>?A |- _ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= per_distinct A B C H (swap_diff B A H2)); clean_reap_hyps
      | H:Per ?A ?B ?C, H2 : ?B<>?C |- _ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= per_distinct_1 A B C H H2); clean_reap_hyps
      | H:Per ?A ?B ?C, H2 : ?C<>?B |- _ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= per_distinct_1 A B C H (swap_diff C B H2)); clean_reap_hyps

      | H:Perp ?A ?B ?C ?D |- _ =>
      let T:= fresh in (not_exist_hyp2 A B C D);
       assert (T:= perp_distinct A B C D H);
       decompose [and] T;clear T;clean_reap_hyps
      | H:Perp_at ?X ?A ?B ?C ?D |- _ =>
      let T:= fresh in (not_exist_hyp2 A B C D);
       assert (T:= perp_in_distinct X A B C D H);
       decompose [and] T;clear T;clean_reap_hyps
      | H:Out ?A ?B ?C |- _ =>
      let T:= fresh in (not_exist_hyp2 A B A C);
       assert (T:= out_distinct A B C H);
       decompose [and] T;clear T;clean_reap_hyps

      | H:TS ?A ?B ?C ?D |- _ =>
      let h := fresh in
      not_exist_hyp6 A B A C A D B C B D C D;
      assert (h := ts_distincts A B C D H);decompose [and] h;clear h;clean_reap_hyps
      | H:OS ?A ?B ?C ?D |- _ =>
      let h := fresh in
      not_exist_hyp5 A B A C A D B C B D;
      assert (h := os_distincts A B C D H);decompose [and] h;clear h;clean_reap_hyps
      | H:~ Coplanar ?A ?B ?C ?D |- _ =>
      let h := fresh in
      not_exist_hyp6 A B A C A D B C B D C D;
      assert (h := ncop_distincts A B C D H);decompose [and] h;clear h;clean_reap_hyps

      | H:CongA ?A ?B ?C ?A' ?B' ?C' |- _ =>
      let T:= fresh in (not_exist_hyp_comm A B);
        assert (T:= conga_diff1 A B C A' B' C' H);clean_reap_hyps
      | H:CongA ?A ?B ?C ?A' ?B' ?C' |- _ =>
      let T:= fresh in (not_exist_hyp_comm B C);
        assert (T:= conga_diff2 A B C A' B' C' H);clean_reap_hyps
      | H:CongA ?A ?B ?C ?A' ?B' ?C' |- _ =>
      let T:= fresh in (not_exist_hyp_comm A' B');
        assert (T:= conga_diff45 A B C A' B' C' H);clean_reap_hyps
      | H:CongA ?A ?B ?C ?A' ?B' ?C' |- _ =>
      let T:= fresh in (not_exist_hyp_comm B' C');
        assert (T:= conga_diff56 A B C A' B' C' H);clean_reap_hyps

      | H:(Orth_at ?X ?A ?B ?C ?U ?V) |- _ =>
      let h := fresh in
      not_exist_hyp4 A B A C B C U V;
      assert (h := orth_at_distincts A B C U V X H);decompose [and] h;clear h;clean_reap_hyps
      | H:(Orth ?A ?B ?C ?U ?V) |- _ =>
      let h := fresh in
      not_exist_hyp4 A B A C B C U V;
      assert (h := orth_distincts A B C U V H);decompose [and] h;clear h;clean_reap_hyps

      | H:SumA ?A ?B ?C ?D ?E ?F ?G ?I ?J |- _ =>
      let h := fresh in
      not_exist_hyp6 A B B C D E E F G I I J;
      assert (h := suma_distincts A B C D E F G I J H);decompose [and] h;clear h;clean_reap_hyps
      | H: TriSumA ?A ?B ?C ?D ?E ?F |- _ =>
      let h := fresh in
      not_exist_hyp5 A B B C A C D E E F;
      assert (h := trisuma_distincts A B C D E F H);decompose [and] h;clear h; clean_reap_hyps
      | H:SAMS ?A ?B ?C ?D ?E ?F |- _ =>
      let h := fresh in
      not_exist_hyp4 A B B C D E E F;
      assert (h := sams_distincts A B C D E F H);decompose [and] h;clear h;clean_reap_hyps

      | H:(InAngle ?P ?A ?B ?C) |- _ =>
      let h := fresh in
      not_exist_hyp3 A B C B P B;
      assert (h := inangle_distincts A B C P H);decompose [and] h;clear h;clean_reap_hyps
      | H:LeA ?A ?B ?C ?D ?E ?F |- _ =>
      let h := fresh in
      not_exist_hyp4 A B B C D E E F;
      assert (h := lea_distincts A B C D E F H);decompose [and] h;clear h;clean_reap_hyps
      | H:LtA ?A ?B ?C ?D ?E ?F |- _ =>
      let h := fresh in
      not_exist_hyp4 A B B C D E E F;
      assert (h := lta_distincts A B C D E F H);decompose [and] h;clear h;clean_reap_hyps
      | H:(Acute ?A ?B ?C) |- _ =>
      let h := fresh in
      not_exist_hyp2 A B B C;
      assert (h := acute_distincts A B C H);decompose [and] h;clear h;clean_reap_hyps
      | H:(Obtuse ?A ?B ?C) |- _ =>
      let h := fresh in
      not_exist_hyp2 A B B C;
      assert (h := obtuse_distincts A B C H);decompose [and] h;clear h;clean_reap_hyps
      | H:SuppA ?A ?B ?C ?D ?E ?F |- _ =>
      let h := fresh in
      not_exist_hyp4 A B B C D E E F;
      assert (h := suppa_distincts A B C D E F H);decompose [and] h;clear h;clean_reap_hyps
 end.

Hint Resolve suma_sym suma_left_comm suma_middle_comm suma_right_comm
             suma_comm ts__suma inangle__suma bet__suma
             sams_right_comm sams_comm sams_left_comm sams_sym
             out213__sams out546__sams bet__sams suppa__sams inangle__sams : suma.

Ltac SumA := eauto with suma.

Section Suma_2.

Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.

Lemma sams_suma__lea123789 : forall A B C D E F G H I, SumA A B C D E F G H I ->
   SAMS A B C D E F -> LeA A B C G H I.

Lemma sams_suma__lea456789 : forall A B C D E F G H I, SumA A B C D E F G H I ->
   SAMS A B C D E F -> LeA D E F G H I.

Lemma sams_lea2__sams : forall A B C D E F A' B' C' D' E' F',
   SAMS A' B' C' D' E' F' -> LeA A B C A' B' C' -> LeA D E F D' E' F' ->
   SAMS A B C D E F.

Lemma sams_lea456_suma2__lea : forall A B C D E F G H I D' E' F' G' H' I',
   LeA D E F D' E' F' -> SAMS A B C D' E' F' -> SumA A B C D E F G H I ->
   SumA A B C D' E' F' G' H' I' -> LeA G H I G' H' I'.

Lemma sams_lea123_suma2__lea : forall A B C D E F G H I A' B' C' G' H' I',
   LeA A B C A' B' C' -> SAMS A' B' C' D E F -> SumA A B C D E F G H I ->
   SumA A' B' C' D E F G' H' I' -> LeA G H I G' H' I'.

Lemma sams_lea2_suma2__lea : forall A B C D E F G H I A' B' C' D' E' F' G' H' I',
   LeA A B C A' B' C' -> LeA D E F D' E' F' -> SAMS A' B' C' D' E' F' ->
   SumA A B C D E F G H I -> SumA A' B' C' D' E' F' G' H' I' -> LeA G H I G' H' I'.

Lemma sams2_suma2__conga456 : forall A B C D E F D' E' F' G H I,
   SAMS A B C D E F -> SAMS A B C D' E' F' ->
   SumA A B C D E F G H I -> SumA A B C D' E' F' G H I ->
   CongA D E F D' E' F'.

Lemma sams2_suma2__conga123 : forall A B C A' B' C' D E F G H I,
   SAMS A B C D E F -> SAMS A' B' C' D E F ->
   SumA A B C D E F G H I -> SumA A' B' C' D E F G H I ->
   CongA A B C A' B' C'.

Lemma suma_assoc_1 : forall A B C D E F G H I K L M A' B' C' D' E' F',
   SAMS A B C D E F -> SAMS D E F G H I ->
   SumA A B C D E F A' B' C' -> SumA D E F G H I D' E' F' ->
   SumA A' B' C' G H I K L M -> SumA A B C D' E' F' K L M.

Lemma suma_assoc_2 : forall A B C D E F G H I K L M A' B' C' D' E' F',
   SAMS A B C D E F -> SAMS D E F G H I ->
   SumA A B C D E F A' B' C' -> SumA D E F G H I D' E' F' ->
   SumA A B C D' E' F' K L M -> SumA A' B' C' G H I K L M.

Lemma suma_assoc : forall A B C D E F G H I K L M A' B' C' D' E' F',
   SAMS A B C D E F -> SAMS D E F G H I ->
   SumA A B C D E F A' B' C' -> SumA D E F G H I D' E' F' ->
   (SumA A' B' C' G H I K L M <-> SumA A B C D' E' F' K L M).

Lemma sams_assoc_1 : forall A B C D E F G H I A' B' C' D' E' F',
   SAMS A B C D E F -> SAMS D E F G H I ->
   SumA A B C D E F A' B' C' -> SumA D E F G H I D' E' F' ->
   SAMS A' B' C' G H I -> SAMS A B C D' E' F'.

Lemma sams_assoc_2 : forall A B C D E F G H I A' B' C' D' E' F',
   SAMS A B C D E F -> SAMS D E F G H I ->
   SumA A B C D E F A' B' C' -> SumA D E F G H I D' E' F' ->
   SAMS A B C D' E' F' -> SAMS A' B' C' G H I.

Lemma sams_assoc : forall A B C D E F G H I A' B' C' D' E' F',
   SAMS A B C D E F -> SAMS D E F G H I ->
   SumA A B C D E F A' B' C' -> SumA D E F G H I D' E' F' ->
   (SAMS A' B' C' G H I <-> SAMS A B C D' E' F').

Lemma sams_nos__nts : forall A B C J, SAMS A B C C B J -> ~ OS B C A J ->
  ~ TS A B C J.

Lemma conga_sams_nos__nts : forall A B C D E F J,
  SAMS A B C D E F -> CongA C B J D E F -> ~ OS B C A J -> ~ TS A B C J.

Lemma sams_lea2_suma2__conga123 : forall A B C D E F G H I A' B' C' D' E' F',
   LeA A B C A' B' C' -> LeA D E F D' E' F' -> SAMS A' B' C' D' E' F' ->
   SumA A B C D E F G H I -> SumA A' B' C' D' E' F' G H I -> CongA A B C A' B' C'.

Lemma sams_lea2_suma2__conga456 : forall A B C D E F G H I A' B' C' D' E' F',
   LeA A B C A' B' C' -> LeA D E F D' E' F' -> SAMS A' B' C' D' E' F' ->
   SumA A B C D E F G H I -> SumA A' B' C' D' E' F' G H I -> CongA D E F D' E' F'.

Lemma sams_suma__out213 : forall A B C D E F, SumA A B C D E F D E F -> SAMS A B C D E F -> Out B A C.

Lemma sams_suma__out546 : forall A B C D E F, SumA A B C D E F A B C -> SAMS A B C D E F -> Out E D F.

Lemma sams_lea_lta123_suma2__lta : forall A B C D E F G H I A' B' C' D' E' F' G' H' I',
   LtA A B C A' B' C' -> LeA D E F D' E' F' -> SAMS A' B' C' D' E' F' ->
   SumA A B C D E F G H I -> SumA A' B' C' D' E' F' G' H' I' -> LtA G H I G' H' I'.

Lemma sams_lea_lta456_suma2__lta : forall A B C D E F G H I A' B' C' D' E' F' G' H' I',
   LeA A B C A' B' C' -> LtA D E F D' E' F' -> SAMS A' B' C' D' E' F' ->
   SumA A B C D E F G H I -> SumA A' B' C' D' E' F' G' H' I' -> LtA G H I G' H' I'.

Lemma sams_lta2_suma2__lta : forall A B C D E F G H I A' B' C' D' E' F' G' H' I',
   LtA A B C A' B' C' -> LtA D E F D' E' F' -> SAMS A' B' C' D' E' F' ->
   SumA A B C D E F G H I -> SumA A' B' C' D' E' F' G' H' I' -> LtA G H I G' H' I'.

Lemma sams_lea2_suma2__lea123 : forall A B C D E F G H I A' B' C' D' E' F' G' H' I',
   LeA D' E' F' D E F -> LeA G H I G' H' I' -> SAMS A B C D E F ->
   SumA A B C D E F G H I -> SumA A' B' C' D' E' F' G' H' I' -> LeA A B C A' B' C'.

Lemma sams_lea2_suma2__lea456 : forall A B C D E F G H I A' B' C' D' E' F' G' H' I',
   LeA A' B' C' A B C -> LeA G H I G' H' I' -> SAMS A B C D E F ->
   SumA A B C D E F G H I -> SumA A' B' C' D' E' F' G' H' I' -> LeA D E F D' E' F'.

Lemma sams_lea_lta456_suma2__lta123 : forall A B C D E F G H I A' B' C' D' E' F' G' H' I',
   LtA D' E' F' D E F -> LeA G H I G' H' I' -> SAMS A B C D E F ->
   SumA A B C D E F G H I -> SumA A' B' C' D' E' F' G' H' I' -> LtA A B C A' B' C'.

Lemma sams_lea_lta123_suma2__lta456 : forall A B C D E F G H I A' B' C' D' E' F' G' H' I',
   LtA A' B' C' A B C -> LeA G H I G' H' I' -> SAMS A B C D E F ->
   SumA A B C D E F G H I -> SumA A' B' C' D' E' F' G' H' I' -> LtA D E F D' E' F'.

Lemma sams_lea_lta789_suma2__lta123 : forall A B C D E F G H I A' B' C' D' E' F' G' H' I',
   LeA D' E' F' D E F -> LtA G H I G' H' I' -> SAMS A B C D E F ->
   SumA A B C D E F G H I -> SumA A' B' C' D' E' F' G' H' I' -> LtA A B C A' B' C'.

Lemma sams_lea_lta789_suma2__lta456 : forall A B C D E F G H I A' B' C' D' E' F' G' H' I',
   LeA A' B' C' A B C -> LtA G H I G' H' I' -> SAMS A B C D E F ->
   SumA A B C D E F G H I -> SumA A' B' C' D' E' F' G' H' I' -> LtA D E F D' E' F'.

Lemma sams_lta2_suma2__lta123 : forall A B C D E F G H I A' B' C' D' E' F' G' H' I',
   LtA D' E' F' D E F -> LtA G H I G' H' I' -> SAMS A B C D E F ->
   SumA A B C D E F G H I -> SumA A' B' C' D' E' F' G' H' I' -> LtA A B C A' B' C'.

Lemma sams_lta2_suma2__lta456 : forall A B C D E F G H I A' B' C' D' E' F' G' H' I',
   LtA A' B' C' A B C -> LtA G H I G' H' I' -> SAMS A B C D E F ->
   SumA A B C D E F G H I -> SumA A' B' C' D' E' F' G' H' I' -> LtA D E F D' E' F'.

Lemma sams123231 : forall A B C, A <> B -> A <> C -> B <> C -> SAMS A B C B C A.

Lemma col_suma__col : forall A B C D E F, Col D E F -> SumA A B C B C A D E F -> Col A B C.

Lemma ncol_suma__ncol : forall A B C D E F, ~ Col A B C -> SumA A B C B C A D E F -> ~ Col D E F.

Lemma per2_suma__bet : forall A B C D E F G H I, Per A B C -> Per D E F ->
   SumA A B C D E F G H I -> Bet G H I.

Lemma bet_per2__suma : forall A B C D E F G H I,
   A <> B -> B <> C -> D <> E -> E <> F -> G <> H -> H <> I ->
   Per A B C -> Per D E F ->
   Bet G H I -> SumA A B C D E F G H I.

Lemma per2__sams : forall A B C D E F, A <> B -> B <> C -> D <> E -> E <> F ->
  Per A B C -> Per D E F -> SAMS A B C D E F.

Lemma bet_per_suma__per456 : forall A B C D E F G H I, Per A B C -> Bet G H I ->
   SumA A B C D E F G H I -> Per D E F.

Lemma bet_per_suma__per123 : forall A B C D E F G H I, Per D E F -> Bet G H I ->
   SumA A B C D E F G H I -> Per A B C.

Lemma bet_suma__per : forall A B C D E F, Bet D E F -> SumA A B C A B C D E F ->
   Per A B C.

Lemma acute__sams : forall A B C, Acute A B C -> SAMS A B C A B C.

Lemma acute_suma__nbet : forall A B C D E F, Acute A B C -> SumA A B C A B C D E F -> ~ Bet D E F.

Lemma acute2__sams : forall A B C D E F, Acute A B C -> Acute D E F -> SAMS A B C D E F.

Lemma acute2_suma__nbet : forall A B C D E F G H I,
  Acute A B C -> Acute D E F -> SumA A B C D E F G H I -> ~ Bet G H I.

Lemma acute_per__sams : forall A B C D E F, A <> B -> B <> C ->
  Per A B C -> Acute D E F -> SAMS A B C D E F.

Lemma acute_per_suma__nbet : forall A B C D E F G H I, A <> B -> B <> C ->
  Per A B C -> Acute D E F -> SumA A B C D E F G H I -> ~ Bet G H I.

Lemma obtuse__nsams : forall A B C, Obtuse A B C -> ~ SAMS A B C A B C.

Lemma nbet_sams_suma__acute : forall A B C D E F, ~ Bet D E F -> SAMS A B C A B C ->
   SumA A B C A B C D E F -> Acute A B C.

Lemma nsams__obtuse : forall A B C, A <> B -> B <> C -> ~ SAMS A B C A B C -> Obtuse A B C.

Lemma sams2_suma2__conga : forall A B C D E F A' B' C',
  SAMS A B C A B C -> SumA A B C A B C D E F ->
  SAMS A' B' C' A' B' C' -> SumA A' B' C' A' B' C' D E F ->
  CongA A B C A' B' C'.

Lemma acute2_suma2__conga : forall A B C D E F A' B' C',
  Acute A B C -> SumA A B C A B C D E F ->
  Acute A' B' C' -> SumA A' B' C' A' B' C' D E F ->
  CongA A B C A' B' C'.

Lemma bet2_suma__out : forall A B C D E F G H I, Bet A B C -> Bet D E F ->
  SumA A B C D E F G H I -> Out H G I.

Lemma col2_suma__col : forall A B C D E F G H I, Col A B C -> Col D E F ->
  SumA A B C D E F G H I -> Col G H I.

Lemma suma_suppa__bet : forall A B C D E F G H I,
  SuppA A B C D E F -> SumA A B C D E F G H I -> Bet G H I.

Lemma bet_suppa__suma : forall A B C D E F G H I, G <> H -> H <> I ->
  SuppA A B C D E F -> Bet G H I -> SumA A B C D E F G H I.

Lemma bet_suma__suppa : forall A B C D E F G H I,
  SumA A B C D E F G H I -> Bet G H I -> SuppA A B C D E F.

Lemma bet2_suma__suma : forall A B C D E F G H I A' D', A' <> B -> D' <> E ->
  Bet A B A' -> Bet D E D' -> SumA A B C D E F G H I -> SumA A' B C D' E F G H I.

Lemma suma_suppa2__suma : forall A B C D E F G H I A' B' C' D' E' F',
  SuppA A B C A' B' C' -> SuppA D E F D' E' F' -> SumA A B C D E F G H I ->
  SumA A' B' C' D' E' F' G H I.

Lemma suma2_obtuse2__conga : forall A B C D E F A' B' C',
  Obtuse A B C -> SumA A B C A B C D E F ->
  Obtuse A' B' C' -> SumA A' B' C' A' B' C' D E F ->
  CongA A B C A' B' C'.

Lemma bet_suma2__or_conga : forall A B C D E F A' B' C' A0, A0 <> B ->
  Bet A B A0 -> SumA A B C A B C D E F -> SumA A' B' C' A' B' C' D E F ->
  CongA A B C A' B' C' \/ CongA A0 B C A' B' C'.

Lemma suma2__or_conga_suppa : forall A B C A' B' C' D E F ,
  SumA A B C A B C D E F -> SumA A' B' C' A' B' C' D E F ->
  CongA A B C A' B' C' \/ SuppA A B C A' B' C'.

Lemma ex_trisuma : forall A B C, A <> B -> B <> C -> A <> C ->
  exists D E F, TriSumA A B C D E F.

Lemma trisuma_perm_231 : forall A B C D E F, TriSumA A B C D E F -> TriSumA B C A D E F.

Lemma trisuma_perm_312 : forall A B C D E F, TriSumA A B C D E F -> TriSumA C A B D E F.

Lemma trisuma_perm_321 : forall A B C D E F, TriSumA A B C D E F -> TriSumA C B A D E F.

Lemma trisuma_perm_213 : forall A B C D E F, TriSumA A B C D E F -> TriSumA B A C D E F.

Lemma trisuma_perm_132 : forall A B C D E F, TriSumA A B C D E F -> TriSumA A C B D E F.

Lemma conga_trisuma__trisuma : forall A B C D E F D' E' F',
  TriSumA A B C D E F -> CongA D E F D' E' F' -> TriSumA A B C D' E' F'.

Lemma trisuma2__conga : forall A B C D E F D' E' F',
  TriSumA A B C D E F -> TriSumA A B C D' E' F' -> CongA D E F D' E' F'.

Lemma conga3_trisuma__trisuma : forall A B C D E F A' B' C', TriSumA A B C D E F ->
  CongA A B C A' B' C' -> CongA B C A B' C' A' -> CongA C A B C' A' B' ->
  TriSumA A' B' C' D E F.

Lemma col_trisuma__bet : forall A B C P Q R, Col A B C -> TriSumA A B C P Q R -> Bet P Q R.

Lemma suma_dec : forall A B C D E F G H I, SumA A B C D E F G H I \/ ~ SumA A B C D E F G H I.

Lemma sams_dec : forall A B C D E F, SAMS A B C D E F \/ ~ SAMS A B C D E F.

Lemma trisuma_dec : forall A B C P Q R, TriSumA A B C P Q R \/ ~ TriSumA A B C P Q R.

End Suma_2.

Hint Resolve per2__sams acute2__sams acute_per__sams sams123231 bet_suppa__suma : suma. *)

Require Import GeoCoq.Tarski_dev.Annexes.perp_bisect.
(* GeoCoq.Tarski_dev.Annexes.perp_bisect:
Require Export GeoCoq.Tarski_dev.Ch10_line_reflexivity_2.

Section PerpBisect_1.

Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.

Lemma perp_bisect_equiv_def :
  forall P Q A B, Perp_bisect P Q A B <-> Perp_bisect_bis P Q A B.

Lemma perp_bisect_sym_1 :
 forall P Q A B,
  Perp_bisect P Q A B ->
  Perp_bisect Q P A B.

Lemma perp_bisect_sym_2 :
 forall P Q A B,
  Perp_bisect P Q A B ->
  Perp_bisect P Q B A.

Lemma perp_bisect_sym_3 : forall A B C D,
 Perp_bisect A B C D ->
 Perp_bisect B A D C.

Lemma perp_bisect_perp :
 forall P Q A B,
  Perp_bisect P Q A B ->
  Perp P Q A B.

End PerpBisect_1.

Hint Resolve perp_bisect_perp : perp.

Section PerpBisect_2.

Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.

Lemma perp_bisect_cong_1 :
 forall P Q A B,
 Perp_bisect P Q A B ->
 Cong A P B P.

Lemma perp_bisect_cong_2 :
 forall P Q A B,
 Perp_bisect P Q A B ->
 Cong A Q B Q.

End PerpBisect_2.

Hint Resolve perp_bisect_cong_1 perp_bisect_cong_2 : cong.

Section PerpBisect_3.

Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.

Lemma perp_bisect_cong2 :
 forall P Q A B,
 Perp_bisect P Q A B ->
 Cong A P B P /\ Cong A Q B Q.

Lemma perp_bisect_cong :
 forall A A1 B B1 C C1 O: Tpoint,
 ~ Col A B C ->
 Perp_bisect O A1 B C -> Perp_bisect O B1 A C -> Perp_bisect O C1 A B ->
 Cong A O B O -> Cong B O C O ->
 Cong A O C O.

Lemma cong_cop_perp_bisect :
 forall P Q A B,
 P <> Q -> A <> B ->
 Coplanar P Q A B ->
 Cong A P B P ->
 Cong A Q B Q ->
 Perp_bisect P Q A B.

Lemma perp_bisect_is_on_perp_bisect :
 forall A B C P,
  Is_on_perp_bisect P A B ->
  Is_on_perp_bisect P B C ->
  Is_on_perp_bisect P A C.

Lemma perp_mid_perp_bisect : forall A B C D,
 Midpoint C A B -> Perp C D A B ->
 Perp_bisect C D A B.

Lemma cong_cop2_perp_bisect_col : forall A B C D E,
  Coplanar A C D E ->
  Coplanar B C D E ->
  Cong C D C E ->
  Perp_bisect A B D E ->
  Col A B C.

Lemma perp_bisect_cop2_existence : forall A B C,
  A <> B -> exists P, exists Q, Perp_bisect P Q A B /\ Coplanar A B C P /\ Coplanar A B C Q.

Lemma perp_bisect_existence :
  forall A B, A <> B -> exists P, exists Q, Perp_bisect P Q A B.

Lemma perp_bisect_existence_cop : forall A B C,
  A <> B -> exists P, exists Q, Perp_bisect P Q A B /\ Coplanar A B C P /\
                                Coplanar A B C Q.

End PerpBisect_3.

Section PerpBisect_2D.

Context `{T2D:Tarski_2D}.

Lemma cong_perp_bisect :
 forall P Q A B,
 P <> Q -> A <> B ->
 Cong A P B P ->
 Cong A Q B Q ->
 Perp_bisect P Q A B.

Lemma cong_perp_bisect_col : forall A B C D E,
  Cong C D C E ->
  Perp_bisect A B D E ->
  Col A B C.

End PerpBisect_2D. *)

Require Import GeoCoq.Tarski_dev.Ch13_1.
(* GeoCoq.Tarski_dev.Ch13_1:
Require Export GeoCoq.Tarski_dev.Ch12_parallel.

Section L13_1.

Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.

Lemma per2_col_eq : forall A P P' B, A <> P -> A <> P' -> Per A P B -> Per A P' B -> Col P A P' -> P = P'.

Lemma per2_preserves_diff : forall O A B A' B', O <> A' -> O <> B' -> Col O A' B' -> Per O A' A -> Per O B' B -> A' <> B' -> A <> B.

Lemma per23_preserves_bet : forall A B C B' C', Bet A B C -> A <> B' -> A <> C' -> Col A B' C' -> Per A B' B -> Per A C' C -> Bet A B' C'.

Lemma per23_preserves_bet_inv : forall A B C B' C', Bet A B' C' -> A <> B' -> Col A B C -> Per A B' B -> Per A C' C -> Bet A B C.

Lemma per13_preserves_bet : forall A B C A' C', Bet A B C -> B <> A' -> B <> C' -> Col A' B C' -> Per B A' A -> Per B C' C -> Bet A' B C'.

Lemma per13_preserves_bet_inv : forall A B C A' C', Bet A' B C' -> B <> A' -> B <> C' ->  Col A B C  -> Per B A' A -> Per B C' C -> Bet A B C.

Lemma per3_preserves_bet1 : forall O A B C A' B' C', Col O A B -> Bet A B C -> O <> A' -> O <> B' -> O <> C'
                                                    -> Per O A' A -> Per O B' B -> Per O C' C
                                                    -> Col A' B' C' -> Col O A' B' -> Bet A' B' C'.

Lemma per3_preserves_bet2_aux : forall O A B C B' C', Col O A C -> A <> C' ->
                               Bet A B' C' -> O <> A -> O <> B' -> O <> C'
                               -> Per O B' B -> Per O C' C
                               -> Col A B C -> Col O A C' -> Bet A B C.

Lemma per3_preserves_bet2 : forall O A B C A' B' C', Col O A C -> A' <> C' ->
                               Bet A' B' C' -> O <> A' -> O <> B' -> O <> C'
                               -> Per O A' A -> Per O B' B -> Per O C' C
                               -> Col A B C -> Col O A' C' -> Bet A B C.

Lemma symmetry_preserves_per : forall A P B A' P', Per B P A -> Midpoint B A A' -> Midpoint B P P'
                                                   -> Per B P' A'.

Lemma l13_1_aux : forall A B C P Q R,
   ~ Col A B C -> Midpoint P B C -> Midpoint Q A C -> Midpoint R A B ->
   exists X, exists Y, Perp_at R X Y A B /\ Perp X Y P Q /\ Coplanar A B C X /\ Coplanar A B C Y.

Lemma l13_1 : forall A B C P Q R,
   ~ Col A B C -> Midpoint P B C -> Midpoint Q A C -> Midpoint R A B ->
   exists X, exists Y, Perp_at R X Y A B /\ Perp X Y P Q.

Lemma per_lt : forall A B C, A <> B ->  C <> B -> Per A B C -> Lt A B A C /\ Lt C B A C.

Lemma cong_perp_conga : forall A B C P,  Cong A B C B -> Perp A C B P -> CongA A B P C B P /\ TS B P A C.

Lemma perp_per_bet : forall A B C P, ~Col A B C -> Col A P C -> Per A B C -> Perp_at P P B A C -> Bet A P C.

Lemma ts_per_per_ts : forall A B C D, TS A B C D -> Per B C A -> Per B D A -> TS C D A B.

Lemma l13_2_1 : forall A B C D E, TS A B C D -> Per B C A -> Per B D A -> Col C D E
    -> Perp A E C D -> CongA C A B D A B
    -> CongA B A C D A E /\ CongA B A D C A E /\ Bet C E D.

  Lemma triangle_mid_par : forall A B C P Q, ~Col A B C -> Midpoint P B C -> Midpoint Q A C -> Par_strict A B Q P.

Lemma cop4_perp_in2__col : forall A B A' B' X Y P,
  Coplanar X Y A A' -> Coplanar X Y A B' ->
  Coplanar X Y B A' -> Coplanar X Y B B' ->
  Perp_at P A B X Y -> Perp_at P A' B' X Y  -> Col A B A'.

Lemma l13_2 : forall A B C D E, TS A B C D -> Per B C A -> Per B D A -> Col C D E -> Perp A E C D
    -> CongA B A C D A E /\ CongA B A D C A E /\ Bet C E D.

Lemma perp2_refl : forall A B P, A <> B -> Perp2 A B A B P.

Lemma perp2_sym : forall A B C D P, Perp2 A B C D P -> Perp2 C D A B P.

Lemma perp2_left_comm : forall A B C D P, Perp2 A B C D P -> Perp2 B A C D P.

Lemma perp2_right_comm : forall A B C D P, Perp2 A B C D P -> Perp2 A B D C P.

Lemma perp2_comm : forall A B C D P, Perp2 A B C D P -> Perp2 B A D C P.

Lemma perp2_pseudo_trans : forall A B C D E F P, Perp2 A B C D P -> Perp2 C D E F P -> ~ Col C D P ->
  Perp2 A B E F P.

Lemma perp2_preserves_bet23 : forall O A B A' B', Bet O A B -> Col O A' B' -> ~Col O A A' ->
    Perp2 A A' B B' O -> Bet O A' B'.

Lemma perp2_preserves_bet13 : forall O B C B' C', Bet B O C -> Col O B' C' -> ~Col O B B' ->
    Perp2 B C' C B' O -> Bet B' O C'.

Lemma is_image_perp_in : forall A A' X Y, A <> A' -> X <> Y -> Reflect A A' X Y ->
  exists P, Perp_at P A A' X Y.

Lemma perp_inter_perp_in_n
     : forall A B C D : Tpoint,
       Perp A B C D ->
       exists P : Tpoint, Col A B P /\ Col C D P /\ Perp_at P A B C D.

Lemma perp2_perp_in : forall A B C D O, Perp2 A B C D O -> ~Col O A B /\ ~Col O C D ->
    exists P, exists Q, Col A B P /\ Col C D Q /\ Col O P Q /\ Perp_at P O P A B /\ Perp_at Q O Q C D.

Lemma l13_8 : forall O P Q U V, U <> O -> V <> O -> Col O P Q -> Col O U V
    -> Per P U O -> Per Q V O -> (Out O P Q <-> Out O U V).

Lemma perp_in_rewrite : forall A B C D P, Perp_at P A B C D ->
                                          Perp_at P A P P C \/
                                          Perp_at P A P P D \/
                                          Perp_at P B P P C \/
                                          Perp_at P B P P D.

Lemma gta_to_lta : forall A B C D E F, GtA A B C D E F -> LtA D E F A B C.

Lemma lta_to_gta : forall A B C D E F, LtA A B C D E F -> GtA D E F A B C.

Lemma perp_out_acute : forall A B C C', Out B A C' -> Perp A B C C' -> Acute A B C.

Lemma flat_all_lea : forall A B C, A <> B -> C <> B -> Bet A B C -> forall P, P <> B -> LeA A B P A B C.

Lemma perp_bet_obtuse : forall A B C C', B <> C' -> Perp A B C C' -> Bet A B C' -> Obtuse A B C.

End L13_1.

Section L13_1_2D.

Context `{T2D:Tarski_2D}.

Lemma perp_in2__col : forall A B A' B' X Y P, Perp_at P A B X Y -> Perp_at P A' B' X Y  ->
  Col A B A'.

Lemma perp2_trans : forall A B C D E F P, Perp2 A B C D P -> Perp2 C D E F P -> Perp2 A B E F P.

Lemma perp2_par : forall A B C D O, Perp2 A B C D O -> Par A B C D.

End L13_1_2D. *)



Section bachmann_s_lotschnittaxiom_legendre_s_parallel_postulate.



Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.



Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate :

  bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.

Proof.

intro bla.

cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD,

        Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 ->

        Col A1 A2 IAB -> Col B1 B2 IAB ->

        Col A1 A2 IAC -> Col C1 C2 IAC ->

        Col B1 B2 IBD -> Col D1 D2 IBD ->

        Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 ->

        Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 ->

       ~ Col IAB IAC IBD ->

        exists I, Col C1 C2 I /\ Col D1 D2 I).

  {

  clear bla; intro bla.

  cut (exists A B C,

          ~ Col A B C /\ Acute A B C /\

          forall P Q,

            Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q ->

            exists Y, Out B C Y /\ Col P Q Y).

    {

    intros [A [B [C [HNC [HAcute HP]]]]]; exists A, B, C; split; try split; Col.

    intros T HInAngle; elim (col_dec A B T); intro HABT.



      {

      assert (HNC' : ~ Col B C T)

        by (intro; apply HNC; unfold InAngle in *; spliter; ColR).

      destruct (l8_18_existence B C T) as [Y [HC HPerp]]; [auto|exists T, Y].

      assert (HOut : Out B A T).

        {

        apply col_in_angle_out with C; try (intro; apply HNC; assert_cols); Col.

        }

      split; [|split]; Between.

      apply l6_6; apply acute_col_perp__out with T; Col.

      apply acute_conga__acute with A B C; auto.

      apply out213_suma__conga with T B A; try apply l6_6; auto.

      assert_diffs.

      exists C; repeat (split; CongA); Cop.

      apply col123__nos; Col.

      }



      {

      destruct (l8_18_existence A B T) as [X [HC HPerp]]; Col.

      assert (HOut1 : Out B A X).

        {

        apply l6_6; apply acute_col_perp__out with T; Col; Perp.

        apply acute_lea_acute with A B C; auto.

        apply lea_left_comm; apply l11_29_b;

        exists C; split; auto; apply conga_refl; assert_diffs; auto.

        }

      destruct (HP X T) as [Y [HOut2 H]];

      try apply perp_per_1; try solve[assert_diffs; auto];

      try apply perp_sym; try apply perp_col0 with A B;

      try solve[assert_diffs; assert_cols; Col]; Cop.

      exists X, Y; repeat (split; auto); elim H; clear H; intro H; auto.

      elim (eq_dec_points T Y); intro HTY; treat_equalities; Between.

      assert (HACT : ~ Col B C T).

        {

        intro; apply HTY; apply l6_21 with B C X T; Col;

        try solve[assert_diffs; auto];

        try (intro; apply HNC; assert_diffs; ColR).

        elim H; assert_cols; Col.

        }

      elim H; clear H; intro HBet.



        {

        assert (HOS : OS C B T A)

          by (apply in_angle_one_side; try apply l11_24; Col).

        exfalso; apply (l9_9_bis _ _ _ _ HOS).

        apply l9_2; apply l9_8_2 with X.



          {

          split; [intro; assert_diffs; assert_cols; apply HNC; ColR|].

          split; [intro; assert_diffs; assert_cols; apply HNC; ColR|].

          exists Y; assert_cols; split; Col; Between.

          }



          {

          apply l9_19 with B; try split; try apply l6_6; assert_diffs;

          assert_cols; Col; intro; apply HNC; ColR.

          }

        }



        {

        assert (HOS : OS A B T C) by (apply in_angle_one_side; Col).

        exfalso; apply (l9_9_bis _ _ _ _ HOS).

        apply l9_2; apply l9_8_2 with Y.



          {

          split; [intro; assert_diffs; assert_cols; apply HNC; ColR|].

          split; [intro; assert_diffs; assert_cols; apply HNC; ColR|].

          exists X; assert_cols; split; Col; Between.

          }



          {

          apply l9_19 with B; try split; try apply l6_6; assert_diffs;

          assert_cols; Col; intro; apply HNC; ColR.

          }

        }

      }

    }



    {

    destruct lower_dim_ex as [C [E [D H]]].

    assert (HNC : ~ Col C E D) by auto; clear H.

    destruct (l8_18_existence D E C) as [B [HC1 HPerp]]; Col.

    assert (HF : exists F, Col D E F /\ B <> F);

    [|destruct HF as [F [HC2 HNE]]].

      {

      elim (perp_not_col2 _ _ _ _ (perp_sym _ _ _ _ HPerp)); intro;

      [exists D|exists E]; split; assert_diffs; Col.

      }

    destruct (segment_construction_2 F B B C) as [A [H HCong1]]; auto.

    assert (HC3 : Col D E A) by (induction H; assert_diffs; assert_cols; ColR).

    clear H; assert (HPerp1 : Perp B A C B)

      by (apply perp_sym; apply perp_col0 with D E; assert_diffs; Perp).

    clear HPerp; clear HC1; clear HC2; clear HC3;

    clear HNE; clear HNC; clear D; clear E; clear F.

    assert (HNC := perp_not_col _ _ _ HPerp1).

    destruct (midpoint_existence A C) as [D HD]; exists A, B, D.

    split; [intro; apply HNC; assert_diffs; assert_cols; ColR|split].



      {

      exists A, B, C; split; [apply perp_per_1; assert_diffs; auto|split].



        {

        exists D; split; try apply conga_refl; repeat split;

        try (intro; treat_equalities; apply HNC; assert_cols; Col); exists D;

        split; [unfold Midpoint in *; spliter; auto|right; apply out_trivial].

        intro; treat_equalities; apply HNC; Col.

        }



        {

        intro HCongA; assert (HPer1 : Per A B D).

          {

          apply l11_17 with A B C; CongA; apply perp_per_1; assert_diffs; Perp.

          }

        assert (HPer2 : Per C B D).

          {

          apply l11_17 with A B D; auto; apply cong3_conga;

          try (intro; treat_equalities; apply HNC; assert_cols; Col).

          repeat split; try solve[unfold Midpoint in *; spliter; Cong].

          }

        assert (HSumA : SumA A B D C B D A B C).

          {

          assert_diffs.

          exists C; repeat (split; CongA); Cop.

          apply l9_9.

          repeat split; [apply per_not_col; auto..|].

          exists D; split; Col; Between.

          }

        assert (HC := per2_suma__bet _ _ _ _ _ _ _ _ _ HPer1 HPer2 HSumA);

        apply HNC; assert_cols; Col.

        }

      }



      {

      intros P Q HOut1 HNE1 HPer HCop1.

      destruct (segment_construction_2 C B B P) as [P' [H HCong2]];

      [assert_diffs; auto|]. assert (HOut2 : Out B C P')

        by (assert_diffs; repeat (split; auto)); clear H.

      destruct (ex_perp_cop B C P' A) as [Q' [HPerp2 HCop2]]; [assert_diffs; auto|].

      assert (HPerp3 : Perp B A Q P).

        {

        apply l8_16_2 with B; assert_diffs; Col; Perp.

        apply per_not_col in HPer; auto.

        intro; apply HPer; assert_cols; ColR.

        }

      assert (Coplanar B P P' P) by Cop.

      assert (Coplanar A B C P) by Cop.

      assert (Coplanar B Q A C)

        by (assert_diffs; apply col2_cop__cop with A D; Col; Cop).

      assert (Coplanar A B C P') by Cop.

      assert (Coplanar B P P' Q) by CopR.

      assert (Coplanar B P P' Q') by CopR.

      destruct (bla B A B C P Q P' Q' B P P') as [I [HC1 HC2]]; Col; Perp; Cop;

      try (intro; apply HNC; assert_diffs; assert_cols; ColR).

      assert (HNE2 : B <> D)

        by (intro; treat_equalities; apply HNC; assert_cols; Col).

      assert (HOS : OS B C P I).

        {

        apply l12_6; apply par_strict_col_par_strict with Q; Col.



          {

          intro; treat_equalities; apply (perp_not_col _ _ _ HPerp1).

          destruct (not_strict_par A B P' Q' P) as [HC3 HC4];

          try apply l12_9 with B C; Perp; try solve[assert_cols; Col]; Cop.

          assert_diffs; assert_cols; ColR.

          }



          {

          apply par_not_col_strict with P; try apply l12_9 with A B; Perp; Col; Cop.

          intro; apply HNC; assert_diffs; assert_cols; ColR.

          }

        }

      exists I; split; Col; apply l6_4_2; split;

      try (intro; apply (l9_9_bis _ _ _ _ HOS)).



        {

        assert (Coplanar A B C I) by (apply col_cop2__cop with P Q; Cop).

        assert (Coplanar A B C D) by Cop.

        elim (eq_dec_points D I); intro HNE3; treat_equalities; Col.

        destruct HD as [_ HD]; apply cop_perp2__col with A C; Cop;

        apply perp_bisect_perp; apply cong_cop_perp_bisect;

        try solve[assert_diffs; Cong]; try CopR. assert (HPerp4 : Perp P I B P).

          {

          apply perp_col0 with A B; try apply perp_col0 with P Q;

          try solve[assert_diffs; assert_cols; Col; Perp].

          intro; treat_equalities; apply HNC.

          assert (HPar : Par B A P' Q') by (apply l12_9 with B C; Perp; Cop).

          destruct (not_strict_par B A P' Q' P);

          assert_diffs; assert_cols; Col; ColR.

          }

        assert (HPerp5 : Perp P' I B P').

          {

          apply perp_col0 with B C; try apply perp_col0 with P' Q';

          try solve[assert_diffs; assert_cols; Col; Perp].

          intro; treat_equalities; apply HNC.

          assert (HPar : Par B C P Q) by (apply l12_9 with B A; Perp; Cop).

          destruct (not_strict_par B C P Q P');

          assert_diffs; assert_cols; Col; ColR.

          }

        destruct (per_lt B P I) as [HLt _];

        try solve[assert_diffs; try apply perp_per_1; Perp].

        destruct (l11_52 I P B I P' B) as [_ [_ HCongA2]]; Cong;

        try (apply l11_16; assert_diffs; try apply perp_per_1; auto);

        [apply lt__le; apply lt_comm; auto|clear HNE3; clear HLt; clear HOS].

        apply cong2_conga_cong with B B; Cong; apply out_conga with P I P' I;

        auto; apply l6_6; auto; apply out_trivial;

        apply perp_not_col in HPerp4; assert_diffs; auto.

        }



        {

        apply l9_8_2 with D; try apply one_side_transitivity with A.



          {

          apply one_side_symmetry in HOS; apply one_side_not_col123 in HOS.

          assert_diffs; assert_cols.

          split; [intro; apply HNC; ColR|split; Col].

          exists B; split; Col.

          }



          {

          assert_diffs; assert_cols; apply l9_19 with C; Col.

          split; [repeat (split; Between)|intro; apply HNC; ColR].

          }



          {

          assert_diffs; assert_cols; apply l9_19 with B; Col.

          }

        }

      }

    }

  }



  {

  intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.

  intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HNCop1 HCop2 HCop3 HCop4 HNC1.

  assert (Col IAB IAC A1) by (assert_diffs; ColR).

  assert (Col IAB IAC A2) by (assert_diffs; ColR).

  assert (Col IAB IBD B1) by (assert_diffs; ColR).

  assert (Col IAB IBD B2) by (assert_diffs; ColR).

  assert (Coplanar IAB IAC IBD A1) by Cop.

  assert (Coplanar IAB IAC IBD A2) by Cop.

  assert (Coplanar IAB IAC IBD B1) by Cop.

  assert (Coplanar IAB IAC IBD B2) by Cop.

  assert (HNC2 : ~ Col A1 A2 D1).

    {

    apply par_strict_not_col_1 with D2; apply par_not_col_strict with IBD;

    Col; try (intro; apply HNC1; assert_diffs; ColR).

    apply l12_9 with B1 B2; Perp; CopR.

    }

  assert (HNC3 : ~ Col B1 B2 C1).

    {

    apply par_strict_not_col_1 with C2; apply par_not_col_strict with IAC;

    Col; try (intro; apply HNC1; assert_diffs; ColR).

    apply l12_9 with A1 A2; Perp; CopR.

    }

  assert (HParA : Par_strict A1 A2 D1 D2).

    apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.

  assert (HParB : Par_strict B1 B2 C1 C2).

    apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.

  assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).

  assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).

  assert (HPQ : IAC <> IAB) by (assert_diffs; auto).

  assert (HQR : IAB <> IBD) by (assert_diffs; auto).

  destruct (diff_col_ex3 C1 C2 IAC) as [P1 [HC1P1 [HC2P1 [HPP1 HCP1]]]]; Col.

  destruct (diff_col_ex3 D1 D2 IBD) as [R1 [HD1R1 [HD2R1 [HRR1 HDR1]]]]; Col.

  destruct (bla IAC IAB IBD P1 R1) as [I [HI1 HI2]]; auto.

    apply perp_per_2; apply perp_col2 with A1 A2; Col;

    apply perp_sym; apply perp_col2 with B1 B2; Col; Perp.

    apply perp_per_2; apply perp_col2 with A1 A2; Col;

    apply perp_sym; apply perp_col2 with C1 C2; Col; Perp.

    apply perp_per_2; apply perp_col2 with B1 B2; Col;

    apply perp_sym; apply perp_col2 with D1 D2; Col; Perp.

    assert_diffs; apply col_cop2__cop with C1 C2; Col; CopR.

    assert_diffs; apply col_cop2__cop with D1 D2; Col; CopR.

  exists I.

  split; assert_diffs; ColR.

  }

Qed.



End bachmann_s_lotschnittaxiom_legendre_s_parallel_postulate.
