Require Import GeoCoq.Axioms.continuity_axioms.
(* GeoCoq.Axioms.continuity_axioms:
Require Import GeoCoq.Tarski_dev.Definitions.

Section Continuity_Defs.

Context `{Tn:Tarski_neutral_dimensionless}.

Definition segment_circle := forall A B P Q,
  InCircle P A B ->
  OutCircle Q A B ->
  exists Z, Bet P Z Q /\ OnCircle Z A B.

Definition one_point_line_circle := forall A B U V P,
  Col U V P -> U <> V -> Bet A P B ->
  exists Z, Col U V Z /\ OnCircle Z A B.

Definition two_points_line_circle := forall A B U V P,
  Col U V P -> U <> V -> Bet A P B ->
  exists Z1 Z2, Col U V Z1 /\ OnCircle Z1 A B /\
                Col U V Z2 /\ OnCircle Z2 A B /\
                Bet Z1 P Z2 /\ (P <> B -> Z1 <> Z2).

Definition circle_circle := forall A B C D P Q,
  OnCircle P C D ->
  OnCircle Q C D ->
  InCircle P A B ->
  OutCircle Q A B ->
  exists Z, OnCircle Z A B /\ OnCircle Z C D.

Definition circle_circle_bis := forall A B C D P Q,
  OnCircle P C D ->
  InCircle P A B ->
  OnCircle Q A B ->
  InCircle Q C D ->
  exists Z, OnCircle Z A B /\ OnCircle Z C D.

Definition circle_circle_axiom := forall A B C D B' D',
  Cong A B' A B -> Cong C D' C D ->
  Bet A D' B -> Bet C B' D ->
  exists Z, Cong A Z A B /\ Cong C Z C D.

Definition circle_circle_two := forall A B C D P Q,
  OnCircle P C D ->
  OnCircle Q C D ->
  InCircle P A B ->
  OutCircle Q A B ->
  exists Z1 Z2,
    OnCircle Z1 A B /\ OnCircle Z1 C D /\
    OnCircle Z2 A B /\ OnCircle Z2 C D /\
    (InCircleS P A B -> OutCircleS Q A B -> Z1<>Z2).

Definition euclid_s_prop_1_22 := forall A B C D E F A' B' C' D' E' F',
  SumS A B C D E' F' -> SumS A B E F C' D' -> SumS C D E F A' B' ->
  Le E F E' F' -> Le C D C' D' -> Le A B A' B' ->
  exists P Q R, Cong P Q A B /\ Cong P R C D /\ Cong Q R E F.

Definition Nested (A B:nat -> Tpoint -> Prop) :=
  (forall n, exists An, A n An) /\ (forall n, exists Bn, B n Bn) /\
  forall n An Am Bm Bn,
    A n An -> A (S n) Am -> B (S n) Bm -> B n Bn -> Bet An Am Bm /\ Bet Am Bm Bn /\ Am <> Bm.

Definition cantor_s_axiom := forall A B, Nested A B ->
  exists X, forall n An Bn, A n An -> B n Bn -> Bet An X Bn.

Definition dedekind_s_axiom := forall (Alpha Beta : Tpoint -> Prop),
  (exists A, forall X Y, Alpha X -> Beta Y -> Bet A X Y) ->
  (exists B, forall X Y, Alpha X -> Beta Y -> Bet X B Y).

Inductive FOF : Prop -> Prop :=
| eq_fof : forall A B:Tpoint, FOF (A = B)
| bet_fof : forall A B C, FOF (Bet A B C)
| cong_fof : forall A B C D, FOF (Cong A B C D)
| not_fof : forall P, FOF P -> FOF (~ P)
| and_fof : forall P Q, FOF P -> FOF Q -> FOF (P /\ Q)
| or_fof : forall P Q, FOF P -> FOF Q -> FOF (P \/ Q)
| implies_fof : forall P Q, FOF P -> FOF Q -> FOF (P -> Q)
| forall_fof : forall P, (forall (A:Tpoint), FOF (P A)) -> FOF (forall A, P A)
| exists_fof : forall P, (forall (A:Tpoint), FOF (P A)) -> FOF (exists A, P A).

Definition first_order_dedekind := forall Alpha Beta,
  (forall X, FOF (Alpha X)) -> (forall Y, FOF (Beta Y)) ->
  (exists A, forall X Y, Alpha X -> Beta Y -> Bet A X Y) ->
  (exists B, forall X Y, Alpha X -> Beta Y -> Bet X B Y).

Definition archimedes_axiom := forall A B C D, A <> B -> Reach A B C D.

Definition aristotle_s_axiom := forall P Q A B C,
  ~ Col A B C -> Acute A B C ->
  exists X Y, Out B A X /\ Out B C Y /\ Per B X Y /\ Lt P Q X Y.

Definition greenberg_s_axiom := forall P Q R A B C,
  ~ Col A B C ->
  Acute A B C -> Q <> R -> Per P Q R ->
  exists S, LtA P S Q A B C /\ Out Q S R.

End Continuity_Defs.

Section Completeness.

Context `{Tn:Tarski_neutral_dimensionless}.

Definition inj {T1 T2:Type} (f:T1->T2) := forall A B, f A = f B -> A = B.

Definition pres_bet {Tm: Tarski_neutral_dimensionless}
  (f : @Tpoint Tn -> @Tpoint Tm) := forall A B C, Bet A B C -> Bet (f A) (f B) (f C).

Definition pres_cong {Tm: Tarski_neutral_dimensionless}
  (f : @Tpoint Tn -> @Tpoint Tm) := forall A B C D, Cong A B C D -> Cong (f A) (f B) (f C) (f D).

Definition extension {Tm: Tarski_neutral_dimensionless} f := inj f /\ pres_bet f /\ pres_cong f.

Definition completeness_for_planes := forall (Tm: Tarski_neutral_dimensionless)
  (Tm2 : Tarski_neutral_dimensionless_with_decidable_point_equality Tm)
  (M : Tarski_2D Tm2)
  (f : @Tpoint Tn -> @Tpoint Tm),
  @archimedes_axiom Tm ->
  extension f ->
  forall A, exists B, f B = A.

Definition completeness_for_3d_spaces := forall (Tm: Tarski_neutral_dimensionless)
  (Tm2 : Tarski_neutral_dimensionless_with_decidable_point_equality Tm)
  (M : Tarski_3D Tm2)
  (f : @Tpoint Tn -> @Tpoint Tm),
  @archimedes_axiom Tm ->
  extension f ->
  forall A, exists B, f B = A.

Definition inj_line {T:Type} (f:Tpoint->T) P Q := forall A B, Col P Q A -> Col P Q B ->
  f A = f B -> A = B.

Definition pres_bet_line {Tm: Tarski_neutral_dimensionless}
  (f : @Tpoint Tn -> @Tpoint Tm) P Q := forall A B C, Col P Q A -> Col P Q B -> Col P Q C ->
  Bet A B C -> Bet (f A) (f B) (f C).

Definition pres_cong_line {Tm: Tarski_neutral_dimensionless}
  (f : @Tpoint Tn -> @Tpoint Tm) P Q := forall A B C D,
  Col P Q A -> Col P Q B -> Col P Q C -> Col P Q D ->
  Cong A B C D -> Cong (f A) (f B) (f C) (f D).

Definition line_extension {Tm: Tarski_neutral_dimensionless} f P Q :=
  P <> Q /\ inj_line f P Q /\ pres_bet_line f P Q /\ pres_cong_line f P Q.

Definition line_completeness := forall (Tm: Tarski_neutral_dimensionless)
  (Tm2 : Tarski_neutral_dimensionless_with_decidable_point_equality Tm)
  P Q
  (f : @Tpoint Tn -> @Tpoint Tm),
  @archimedes_axiom Tm ->
  line_extension f P Q ->
  forall A, Col (f P) (f Q) A -> exists B, Col P Q B /\ f B = A.

End Completeness. *)

Require Import GeoCoq.Meta_theory.Dimension_axioms.upper_dim_2.
(* GeoCoq.Meta_theory.Dimension_axioms.upper_dim_2:
Require Export GeoCoq.Tarski_dev.Ch09_plane.

Section Upper_dim.

Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.

Definition upper_dim_axiom := forall A B C P Q : Tpoint,
  P <> Q -> Cong A P A Q -> Cong B P B Q -> Cong C P C Q ->
  (Bet A B C \/ Bet B C A \/ Bet C A B).

Definition all_coplanar_axiom := forall A B C D, Coplanar A B C D.

Lemma upper_dim_implies_per2__col :
  upper_dim_axiom ->
  (forall A B C X, Per A X C -> X <> C -> Per B X C -> Col A B X).

Lemma upper_dim_implies_col_perp2__col :
  upper_dim_axiom ->
  (forall A B X Y P,
   Col A B P ->
   Perp A B X P ->
   Perp P A Y P ->
   Col Y X P).

Lemma upper_dim_implies_perp2__col :
  upper_dim_axiom ->
  (forall X Y Z A B,
   Perp X Y A B ->
   Perp X Z A B ->
   Col X Y Z).

Lemma upper_dim_implies_not_two_sides_one_side_aux :
  upper_dim_axiom ->
  (forall A B X Y PX,
   A <> B -> PX <> A ->
   Perp A B X PX ->
   Col A B PX ->
   ~ Col X A B ->
   ~ Col Y A B ->
   ~ TS A B X Y ->
   OS A B X Y).

Lemma upper_dim_implies_not_two_sides_one_side :
  upper_dim_axiom ->
  (forall A B X Y,
   ~ Col X A B ->
   ~ Col Y A B ->
   ~ TS A B X Y ->
   OS A B X Y).

Lemma upper_dim_implies_not_one_side_two_sides :
  upper_dim_axiom ->
  (forall A B X Y,
   ~ Col X A B ->
   ~ Col Y A B ->
   ~ OS A B X Y ->
   TS A B X Y).

Lemma upper_dim_implies_one_or_two_sides :
  upper_dim_axiom ->
  (forall A B X Y,
   ~ Col X A B ->
   ~ Col Y A B ->
   TS A B X Y \/ OS A B X Y).

Lemma upper_dim_implies_all_coplanar : upper_dim_axiom -> all_coplanar_axiom.

Lemma all_coplanar_implies_upper_dim : all_coplanar_axiom -> upper_dim_axiom.

Lemma all_coplanar_upper_dim : all_coplanar_axiom <-> upper_dim_axiom.

Lemma upper_dim_stab : ~ ~ upper_dim_axiom -> upper_dim_axiom.

End Upper_dim. *)

Require Import GeoCoq.Meta_theory.Dimension_axioms.upper_dim_3.
(* GeoCoq.Meta_theory.Dimension_axioms.upper_dim_3:
Require Export GeoCoq.Tarski_dev.Ch11_angles.
Require Import GeoCoq.Utils.all_equiv.

Section Upper_dim_3.

Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.

Definition upper_dim_3_axiom := forall A B C P Q R,
  P <> Q -> Q <> R -> P <> R ->
  Cong A P A Q -> Cong B P B Q -> Cong C P C Q ->
  Cong A P A R -> Cong B P B R -> Cong C P C R ->
  (Bet A B C \/ Bet B C A \/ Bet C A B).

Definition median_planes_axiom := forall A B C D P Q, P <> Q ->
  Cong A P A Q -> Cong B P B Q -> Cong C P C Q -> Cong D P D Q ->
  Coplanar A B C D.

Definition plane_intersection_axiom := forall A B C D E F P,
  Coplanar A B C P -> Coplanar D E F P ->
  exists Q, Coplanar A B C Q /\ Coplanar D E F Q /\ P <> Q.

Definition space_separation_axiom := forall A B C P Q,
  ~ Coplanar A B C P -> ~ Coplanar A B C Q -> TSP A B C P Q \/ OSP A B C P Q.

Definition orthonormal_family_axiom := forall S U1' U1 U2 U3 U4,
  ~ (S <> U1' /\ Bet U1 S U1' /\
     Cong S U1 S U1' /\ Cong S U2 S U1' /\ Cong S U3 S U1' /\ Cong S U4 S U1' /\
     Cong U1 U2 U1' U2 /\ Cong U1 U3 U1' U2 /\ Cong U1 U4 U1' U2 /\
     Cong U2 U3 U1' U2 /\ Cong U2 U4 U1' U2 /\ Cong U3 U4 U1' U2).

Lemma upper_dim_3_stab : ~ ~ upper_dim_3_axiom -> upper_dim_3_axiom.

Lemma median_planes_implies_upper_dim : median_planes_axiom -> upper_dim_3_axiom.

Lemma median_planes_aux :
  (forall A B C P Q M, P <> Q -> Cong A P A Q -> Cong B P B Q -> Cong C P C Q -> Midpoint M P Q ->
                       Coplanar M A B C) ->
  median_planes_axiom.

Lemma orthonormal_family_aux : orthonormal_family_axiom <->
  (forall A B X P Q, ~ Col P Q X -> Per A X P -> Per A X Q -> Per B X P -> Per B X Q -> Col A B X).

Lemma upper_dim_implies_orthonormal_family_axiom : upper_dim_3_axiom -> orthonormal_family_axiom.

Lemma orthonormal_family_axiom_implies_orth_at2__col :
  orthonormal_family_axiom ->
  (forall A B C P Q X, Orth_at X A B C X P -> Orth_at X A B C X Q -> Col P Q X).

Lemma orthonormal_family_axiom_implies_not_two_sides_one_side :
  orthonormal_family_axiom ->
  (forall A B C X Y, ~ Coplanar A B C X -> ~ Coplanar A B C Y -> ~ TSP A B C X Y -> OSP A B C X Y).

Lemma orthonormal_family_axiom_implies_space_separation :
  orthonormal_family_axiom -> space_separation_axiom.

Lemma space_separation_implies_plane_intersection : space_separation_axiom -> plane_intersection_axiom.

Lemma plane_intersection_implies_space_separation :
  plane_intersection_axiom -> space_separation_axiom.

Lemma space_separation_implies_median_planes : space_separation_axiom -> median_planes_axiom.

Theorem upper_dim_3_equivalent_axioms : all_equiv (upper_dim_3_axiom::
                                                   orthonormal_family_axiom::
                                                   space_separation_axiom::
                                                   plane_intersection_axiom::
                                                   median_planes_axiom::
                                                   nil).

End Upper_dim_3. *)

Require Import GeoCoq.Tarski_dev.Ch10_line_reflexivity_2.
(* GeoCoq.Tarski_dev.Ch10_line_reflexivity_2:
Require Export GeoCoq.Tarski_dev.Ch10_line_reflexivity.
Require Import GeoCoq.Meta_theory.Dimension_axioms.upper_dim_2.

Section T10_1.

Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.

Lemma cop__cong_on_bissect : forall A B M P X,
 Coplanar A B X P -> Midpoint M A B -> Perp_at M A B P M -> Cong X A X B ->
 Col M P X.

Lemma cong_cop_mid_perp__col : forall A B M P X,
 Coplanar A B X P -> Cong A X B X -> Midpoint M A B -> Perp A B P M -> Col M P X.

Lemma cop__image_in_col : forall A B P P' Q Q' M,
 Coplanar A B P Q -> ReflectL_at M P P' A B -> ReflectL_at M Q Q' A B ->
 Col M P Q.

Lemma l10_10_spec : forall A B P Q P' Q',
 ReflectL P' P A B -> ReflectL Q' Q A B ->
 Cong P Q P' Q'.

Lemma l10_10 : forall A B P Q P' Q',
 Reflect P' P A B -> Reflect Q' Q A B ->
 Cong P Q P' Q'.

Lemma image_preserves_bet : forall A B C A' B' C' X Y,
  ReflectL A A' X Y -> ReflectL B B' X Y -> ReflectL C C' X Y ->
  Bet A B C ->
  Bet A' B' C'.

Lemma image_gen_preserves_bet : forall A B C A' B' C' X Y,
  Reflect A A' X Y ->
  Reflect B B' X Y ->
  Reflect C C' X Y ->
  Bet A B C ->
  Bet A' B' C'.

Lemma image_preserves_col : forall A B C A' B' C' X Y,
  ReflectL A A' X Y -> ReflectL B B' X Y -> ReflectL C C' X Y ->
  Col A B C ->
  Col A' B' C'.

Lemma image_gen_preserves_col : forall A B C A' B' C' X Y,
  Reflect A A' X Y -> Reflect B B' X Y -> Reflect C C' X Y ->
  Col A B C ->
  Col A' B' C'.

Lemma image_gen_preserves_ncol : forall A B C A' B' C' X Y,
  Reflect A A' X Y -> Reflect B B' X Y -> Reflect C C' X Y ->
  ~ Col A B C ->
  ~ Col A' B' C'.

Lemma image_gen_preserves_inter : forall A B C D I A' B' C' D' I' X Y,
  Reflect A A' X Y -> Reflect B B' X Y -> Reflect C C' X Y -> Reflect D D' X Y ->
  ~ Col A B C -> C <> D ->
  Col A B I -> Col C D I -> Col A' B' I' -> Col C' D' I' ->
  Reflect I I' X Y.

Lemma intersection_with_image_gen : forall A B C A' B' X Y,
  Reflect A A' X Y -> Reflect B B' X Y ->
  ~ Col A B A' -> Col A B C -> Col A' B' C ->
  Col C X Y.

Lemma image_preserves_midpoint :
 forall A B C A' B' C' X Y,
 ReflectL A A' X Y -> ReflectL B B' X Y -> ReflectL C C' X Y ->
 Midpoint A B C ->
 Midpoint A' B' C'.

Lemma image_spec_preserves_per : forall A B C A' B' C' X Y,
 ReflectL A A' X Y -> ReflectL B B' X Y -> ReflectL C C' X Y ->
 Per A B C ->
 Per A' B' C'.

Lemma image_preserves_per : forall A B C A' B' C' X Y,
 Reflect A A' X Y -> Reflect B B' X Y -> Reflect C C' X Y ->
 Per A B C ->
 Per A' B' C'.

Lemma l10_12 : forall A B C A' B' C',
 Per A B C -> Per A' B' C' ->
 Cong A B A' B' -> Cong B C B' C' ->
 Cong A C A' C'.

Lemma cong4_cop2__eq : forall A B C P Q, ~ Col A B C ->
  Cong A P B P -> Cong A P C P -> Coplanar A B C P ->
  Cong A Q B Q -> Cong A Q C Q -> Coplanar A B C Q ->
  P = Q.

Lemma l10_16 : forall A B C A' B' P,
 ~ Col A B C -> ~ Col A' B' P -> Cong A B A' B' ->
 exists C', Cong_3 A B C A' B' C' /\ OS  A' B' P C' .

Lemma cong_cop_image__col : forall A B P P' X,
 P <> P' -> Reflect P P' A B -> Cong P X P' X -> Coplanar A B P X ->
 Col A B X.

Lemma cong_cop_per2_1 :
 forall A B X Y, A <> B -> Per A B X -> Per A B Y ->
 Cong B X B Y -> Coplanar A B X Y -> X = Y \/ Midpoint B X Y.

Lemma cong_cop_per2 : forall A B X Y,
 A <> B -> Per A B X -> Per A B Y -> Cong B X B Y -> Coplanar A B X Y ->
 X = Y \/ ReflectL X Y A B.

Lemma cong_cop_per2_gen : forall A B X Y,
 A <> B -> Per A B X -> Per A B Y -> Cong B X B Y -> Coplanar A B X Y ->
 X = Y \/ Reflect X Y A B.

Lemma ex_perp_cop : forall A B C P,
 A <> B -> exists Q, Perp A B Q C /\ Coplanar A B P Q.

Lemma hilbert_s_version_of_pasch_aux : forall A B C I P, Coplanar A B C P ->
  ~ Col A I P -> ~ Col B C P -> Bet B I C -> B <> I -> I <> C -> B <> C ->
  exists X, Col I P X /\
            ((Bet A X B /\ A <> X /\ X <> B /\ A <> B) \/
             (Bet A X C /\ A <> X /\ X <> C /\ A <> C)).

Lemma hilbert_s_version_of_pasch : forall A B C P Q, Coplanar A B C P ->
  ~ Col C Q P -> ~ Col A B P -> BetS A Q B ->
  exists X, Col P Q X /\ (BetS A X C \/ BetS B X C).

Lemma two_sides_cases : forall O P A B,
 ~ Col O A B -> OS O P A B -> TS O A P B \/ TS O B P A.

Lemma not_par_two_sides :
  forall A B C D I, C <> D -> Col A B I -> Col C D I -> ~ Col A B C ->
  exists X, exists Y, Col C D X /\ Col C D Y /\ TS A B X Y.

Lemma cop_not_par_other_side :
  forall A B C D I P, C <> D -> Col A B I -> Col C D I -> ~ Col A B C -> ~ Col A B P ->
  Coplanar A B C P ->
  exists Q, Col C D Q /\ TS A B P Q.

Lemma cop_not_par_same_side :
  forall A B C D I P, C <> D -> Col A B I -> Col C D I -> ~ Col A B C -> ~ Col A B P ->
  Coplanar A B C P ->
  exists Q, Col C D Q /\ OS A B P Q.

End T10_1.

Section T10_2D.

Context `{T2D:Tarski_2D}.

Lemma all_coplanar : forall A B C D, Coplanar A B C D.

Lemma per2__col : forall A B C X, Per A X C -> X <> C -> Per B X C -> Col A B X.

Lemma perp2__col : forall X Y Z A B,
 Perp X Y A B -> Perp X Z A B -> Col X Y Z.

Lemma cong_on_bissect : forall A B M P X,
 Midpoint M A B -> Perp_at M A B P M -> Cong X A X B ->
 Col M P X.

Lemma cong_mid_perp__col : forall A B M P X, Cong A X B X -> Midpoint M A B -> Perp A B P M -> Col M P X.

Lemma image_in_col : forall A B P P' Q Q' M,
 ReflectL_at M P P' A B -> ReflectL_at M Q Q' A B ->
 Col M P Q.

Lemma cong_image__col : forall A B P P' X,
 P <> P' -> Reflect P P' A B -> Cong P X P' X ->
 Col A B X.

Lemma cong_per2_1 :
 forall A B X Y, A <> B -> Per A B X -> Per A B Y ->
 Cong B X B Y -> X = Y \/ Midpoint B X Y.

Lemma cong_per2 : forall A B X Y,
 A <> B -> Per A B X -> Per A B Y -> Cong B X B Y ->
 X = Y \/ ReflectL X Y A B.

Lemma cong_per2_gen : forall A B X Y,
 A <> B -> Per A B X -> Per A B Y -> Cong B X B Y ->
 X = Y \/ Reflect X Y A B.

Lemma not_two_sides_one_side :
 forall A B X Y,
  ~ Col X A B ->
  ~ Col Y A B ->
  ~ TS A B X Y ->
  OS A B X Y.

Lemma col_perp2__col :
 forall A B X Y P,
  Col A B P ->
  Perp A B X P ->
  Perp P A Y P ->
  Col Y X P.

Lemma hilbert_s_version_of_pasch_2D : forall A B C P Q,
  ~ Col C Q P -> ~ Col A B P -> BetS A Q B ->
  exists X, Col P Q X /\ (BetS A X C \/ BetS B X C).

Lemma not_one_side_two_sides :
 forall A B X Y,
  ~ Col X A B ->
  ~ Col Y A B ->
  ~ OS A B X Y ->
  TS A B X Y.

Lemma one_or_two_sides :
 forall A B X Y,
  ~ Col X A B ->
  ~ Col Y A B ->
  TS A B X Y \/ OS A B X Y.

Lemma not_par_other_side :
  forall A B C D I P, C <> D -> Col A B I -> Col C D I -> ~ Col A B C -> ~ Col A B P ->
  exists Q, Col C D Q /\ TS A B P Q.

Lemma not_par_same_side :
  forall A B C D I P, C <> D -> Col A B I -> Col C D I -> ~ Col A B C -> ~ Col A B P ->
  exists Q, Col C D Q /\ OS A B P Q.

End T10_2D.

Hint Resolve all_coplanar : cop. *)



Section Completeness.



Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.



Lemma extension__line_extension : forall {Tm: Tarski_neutral_dimensionless}

  (f : @Tpoint Tn -> @Tpoint Tm) P Q,

  P <> Q -> extension f -> line_extension f P Q.

Proof.

  unfold extension, inj, pres_bet, pres_cong, line_extension, inj_line, pres_bet_line, pres_cong_line.

  intros Tm f P Q HPQ fext; spliter.

  repeat split; auto.

Qed.



Lemma extension_reverse_bet : forall {Tm: Tarski_neutral_dimensionless}

  {Tm2 : Tarski_neutral_dimensionless_with_decidable_point_equality Tm}

  (f : @Tpoint Tn -> @Tpoint Tm),

  extension f ->

  forall A B C, Bet (f A) (f B) (f C) -> Bet A B C.

Proof.

  intros Tm Tm2 f [finj [fBet fCong]] A B C HBet.

  destruct (eq_dec_points (f A) (f B)) as [Heq|].

    apply finj in Heq; subst; Between.

  destruct (segment_construction A B B C) as [D [HD1 HD2]].

  assert (C = D); [|subst; auto].

  apply finj.

  apply between_cong_3 with (f A) (f B); Cong.

Qed.



Lemma extension_reverse_col : forall {Tm: Tarski_neutral_dimensionless}

  {Tm2 : Tarski_neutral_dimensionless_with_decidable_point_equality Tm}

  (f : @Tpoint Tn -> @Tpoint Tm),

  extension f ->

  forall A B C, Col (f A) (f B) (f C) -> Col A B C.

Proof.

  unfold Col.

  intros Tm Tm2 f fext A B C HCol.

  assert (fBetInv := extension_reverse_bet f fext).

  destruct HCol as [|[|]]; auto.

Qed.



Lemma line_completeness_aux : line_completeness ->

  forall (Tm: Tarski_neutral_dimensionless)

  (Tm2 : Tarski_neutral_dimensionless_with_decidable_point_equality Tm)

  (f : @Tpoint Tn -> @Tpoint Tm),

  @archimedes_axiom Tm ->

  extension f ->

  forall A P Q R, ~ Col P Q R -> Coplanar (f P) (f Q) (f R) A ->

    exists B, Coplanar P Q R B /\ f B = A.

Proof.

  intros lc Tm Tm2 f archi fext A P Q R HNCol HCop.

  assert (fext' := fext).

  assert (Haux : forall X Y, X <> Y -> line_extension f X Y).

    intros; apply extension__line_extension; assumption.

  unfold extension, inj, pres_bet, pres_cong in fext'; spliter.

  destruct (@midpoint_existence Tn TnEQD P Q) as [S HS].

  assert_diffs.

  destruct (col_dec (f R) (f S) A).

  { assert (HB : exists B, Col R S B /\ f B = A).

      assert (R <> S) by (intro; subst; apply HNCol; Col).

      apply lc; auto.

    destruct HB as [B []].

    exists B; split; [exists S; left; split|]; Col.

  }

  destruct (col_dec (f P) (f Q) A).

  { assert (HB : exists B, Col P Q B /\ f B = A) by (apply lc; auto).

    destruct HB as [B []].

    exists B; split; Cop.

  }

  destruct (hilbert_s_version_of_pasch (f P) (f Q) (f R) A (f S)) as [X [HX1 HX2]]; trivial.

    repeat split; Between.

  assert (HY : exists Y, Coplanar P Q R Y /\ f Y = X).

  { destruct HX2 as [[]|[]];

      [assert (HY : exists Y, Col P R Y /\ f Y = X)|assert (HY : exists Y, Col Q R Y /\ f Y = X)];

      try apply lc; Col;

      destruct HY as [Y []]; exists Y; split; Cop.

  }

  destruct HY as [Y []].

  subst X.

  assert (S <> Y).

  { intro; treat_equalities.

    apply HNCol.

    apply (extension_reverse_col f); auto.

    assert (Bet P S Q) by Between.

    assert (Bet (f P) (f S) (f Q)) by auto.

    destruct HX2 as [[HBet []]|[HBet []]];

      [|apply col_permutation_4]; apply (col_transitivity_2 (f S)); Col.

  }

  assert (HB : exists B, Col S Y B /\ f B = A) by (apply lc; Col).

  destruct HB as [B []].

  exists B.

  split; [apply col_cop2__cop with S Y|]; Cop.

Qed.



Lemma line_completeness__completeness_for_planes : line_completeness -> completeness_for_planes.

Proof.

  intros lc Tm Tm2 M f archi fext A.

  assert (HB : exists B, Coplanar PA PB PC B /\ f B = A).

    apply line_completeness_aux; trivial; [exact lower_dim|apply all_coplanar].

  destruct HB as [B []].

  exists B; assumption.

Qed.



Lemma completeness_aux : forall {Tm: Tarski_neutral_dimensionless}

  P Q R (f : @Tpoint Tn -> @Tpoint Tm) A,

  (exists B, Coplanar P Q R B /\ f B = A) -> exists B, f B = A.

Proof.

  intros Tm P Q R f A [B []].

  exists B; assumption.

Qed.



Lemma line_completeness__completeness_for_3d_spaces :

  (exists P Q R S, ~ Coplanar P Q R S) ->

  line_completeness -> completeness_for_3d_spaces.

Proof.

  intros [P [Q [R [S HNCop]]]] lc Tm Tm2 M f archi fext A.

  assert (~ Col P Q R) . apply ncop__ncol with S, HNCop.

  destruct (col_dec (f P) (f Q) A).

    apply (completeness_aux P Q R), line_completeness_aux; Cop.

  assert (pi : plane_intersection_axiom).

  { cut upper_dim_3_axiom.

      apply upper_dim_3_equivalent_axioms; simpl; tauto.

    unfold upper_dim_3_axiom; exact upper_dim_3.

  }

  destruct (pi (f P) (f Q) A (f P) (f R) (f S) (f P)) as [X [HX1 [HX2 HX3]]]; Cop.

  assert (HY : exists Y, Coplanar P R S Y /\ f Y = X).

    apply line_completeness_aux; trivial; apply ncop__ncol with Q; Cop.

  destruct HY as [Y []]; subst.

  apply completeness_aux with P Q Y, line_completeness_aux; Cop.

  intro.

  apply HNCop.

  apply coplanar_perm_16, col_cop__cop with Y; Col; Cop.

  intro; subst; apply HX3; reflexivity.

Qed.



End Completeness.



Section Dimension.



Context `{Tn:Tarski_neutral_dimensionless}.



Lemma extension_to_plane__plane : forall {Tm: Tarski_neutral_dimensionless}

  {Tm2 : Tarski_neutral_dimensionless_with_decidable_point_equality Tm}

  {M : Tarski_2D Tm2}

  (f : @Tpoint Tn -> @Tpoint Tm),

  extension f ->

  @upper_dim_axiom Tn.

Proof.

  intros Tm Tm2 M f fext A B C P Q HPQ H1 H2 H3.

  apply (extension_reverse_col f); trivial.

  unfold extension, inj, pres_cong in fext; spliter.

  unfold Col; apply upper_dim with (f P) (f Q); auto.

Qed.



Lemma nupper_dim__completeness_for_planes : ~ upper_dim_axiom -> completeness_for_planes.

Proof.

  intros lowerdim Tm Tm2 M f archi fext A.

  exfalso; apply lowerdim.

  apply extension_to_plane__plane with f; trivial.

Qed.



Lemma extension_to_3d__upper_dim_3 : forall {Tm: Tarski_neutral_dimensionless}

  {Tm2 : Tarski_neutral_dimensionless_with_decidable_point_equality Tm}

  {M : Tarski_3D Tm2}

  (f : @Tpoint Tn -> @Tpoint Tm),

  extension f ->

  @upper_dim_3_axiom Tn.

Proof.

  intros Tm Tm2 M f fext A B C P Q R; intros.

  apply (extension_reverse_col f); trivial.

  unfold extension, inj, pres_cong in fext; spliter.

  unfold Col; apply upper_dim_3 with (f P) (f Q) (f R); auto.

Qed.



Lemma nupper_dim_3__completeness_for_3d_spaces : ~ upper_dim_3_axiom -> completeness_for_3d_spaces.

Proof.

  intros lowerdim Tm Tm2 M f archi fext A.

  exfalso; apply lowerdim.

  apply extension_to_3d__upper_dim_3 with f; trivial.

Qed.



End Dimension.



Section Dimension'.



Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.



Lemma ncompleteness_for_planes__upper_dim : ~ completeness_for_planes -> upper_dim_axiom.

Proof.

  intro nc.

  apply upper_dim_stab.

  intro nupper.

  apply nc, (nupper_dim__completeness_for_planes nupper).

Qed.



Lemma ncompleteness_for_3d_spaces__upper_dim_3 : ~ completeness_for_3d_spaces -> upper_dim_3_axiom.

Proof.

  intro nc.

  apply upper_dim_3_stab.

  intro nupper.

  apply nc, (nupper_dim_3__completeness_for_3d_spaces nupper).

Qed.



End Dimension'.
