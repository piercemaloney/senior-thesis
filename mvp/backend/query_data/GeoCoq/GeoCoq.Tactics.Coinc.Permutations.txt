Require Import GeoCoq.Utils.arity.
(* GeoCoq.Utils.arity:
Require Import Arith.
Require Import NArith.
Require Import List.
Require Import Sorting.
Require Import Coq.Program.Equality.

Lemma minus_n_0 : forall n, n-0 = n.

Lemma plus_0_n : forall n, 0+n = n.

Lemma plus_n_0 : forall n, n+0 = n.

Lemma plus_n_1 : forall n, n+1 = S n.

Lemma minus_n1_n2_0 : forall n1 n2, n1+n2-0 = n1+n2.

Fixpoint arity (T:Type) (n:nat) :=
 match n with
 | 0 => Prop
 | S p => T -> arity T p
 end.

Fixpoint cartesianPowerAux (T:Type) (n:nat) :=
 match n with
 | 0 => T
 | S p => (T * cartesianPowerAux T p)%type
 end.

Definition cartesianPower T n := cartesianPowerAux T (n-1).

Definition headCP {T:Type} {n:nat} (cp : cartesianPower T (S n)) : T.

Definition headCPbis {T:Type} {n:nat} (cp : cartesianPower T (S n)) : cartesianPower T 1.

Definition tailCP {T:Type} {n:nat} (cp : cartesianPower T (S (S n))) : (cartesianPower T (S n)).

Definition tailDefaultCP {T:Type} {n:nat} (cp : cartesianPower T (S n)) (Default : cartesianPower T n) : (cartesianPower T n).

Definition allButLastCP {T:Type} {n:nat} (cp : cartesianPower T (S (S n))) : (cartesianPower T (S n)).

Lemma allButLastCPTl {T:Type} {n:nat} :
  forall (cp : cartesianPower T (S (S (S n)))),
  allButLastCP (tailCP cp) = tailCP (allButLastCP cp).

Definition lastCP {T:Type} {n:nat} (cp : cartesianPower T (S n)) : T.

Lemma lastCPTl {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))), lastCP cp = lastCP (tailCP cp).

Lemma CP_ind {T:Type} {n : nat} : forall (cp cp' : cartesianPower T (S (S n))),
  headCP cp = headCP cp' -> tailCP cp = tailCP cp' -> cp = cp'.

Definition CPPair {T : Type} :
  forall (cp : cartesianPower T 2),
  cp = (fst cp, snd cp).

Definition tailCPbis {T:Type} {n:nat} m1 m2 (cp : cartesianPower T m1) :
  (S (S n)) = m1 -> (S n) = m2 -> (cartesianPower T m2).

Definition consHeadCP {T:Type} {n:nat} (t : T) (cp : cartesianPower T n) : (cartesianPower T (S n)).

Lemma consHeadCPHd {T:Type} {n:nat} :
  forall (cp : cartesianPower T n) t,
  headCP (consHeadCP t cp) = t.

Lemma consHeadCPTl {T:Type} {n:nat} :
  forall (cp : cartesianPower T (S n)) t,
  tailCP (consHeadCP t cp) = cp.

Lemma consHeadCPOK {T:Type} {n:nat} :
  forall (cp : cartesianPower T (S (S n))),
  cp = consHeadCP (headCP cp) (tailCP cp).

Definition consTailCP {T:Type} {n:nat} (cp : cartesianPower T n) (t : T) : (cartesianPower T (S n)).

Lemma consTailCPTl {T:Type} {n:nat} :
  forall (cp : cartesianPower T (S (S n))) t,
  tailCP (consTailCP cp t) = consTailCP (tailCP cp) t.

Lemma consTailCPOK {T:Type} {n:nat} :
  forall (cp : cartesianPower T (S (S n))),
  cp = consTailCP (allButLastCP cp) (lastCP cp).

Lemma consTailCPAbl {T:Type} {n:nat} :
  forall (cp : cartesianPower T (S n)) t,
  allButLastCP (consTailCP cp t) = cp.

Lemma consTailCPTlD {T:Type} {n:nat} :
  forall (cp : cartesianPower T n) t,
  tailDefaultCP (consHeadCP t cp) cp = cp.

Lemma consHdTlTlHd {T:Type} {n:nat} :
  forall (F L : T) (X : cartesianPower T n),
  consHeadCP F (consTailCP X L) = consTailCP (consHeadCP F X) L.

Lemma consTlHdHdTl {T:Type} {n:nat} :
  forall (A B C : T) (X : cartesianPower T n),
  consHeadCP A (consHeadCP B (consTailCP X C)) = consTailCP (consHeadCP A (consHeadCP B X)) C.

Definition CPToList {T:Type} {n:nat} (cp : cartesianPower T n) : list T.

Definition InCP {T:Type} {n:nat} p (cp : cartesianPower T n) := In p (CPToList cp).

Lemma InCPOK {T:Type} {n:nat} : forall p (cp : cartesianPower T (S (S n))),
  InCP p cp <-> ((p = headCP cp) \/ InCP p (tailCP cp)).

Lemma lastCPIn {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)), InCP (lastCP cp) cp.

Definition nthCP {T:Type} {m:nat} (n : nat) (cp : cartesianPower T m) (Default : T) := nth (n-1) (CPToList cp) Default.

Lemma CPToListOK {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))), CPToList cp = cons (headCP cp) (CPToList (tailCP cp)).

Lemma CPLHdTlOK {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))),
  CPToList cp = ((headCP cp) :: nil) ++ CPToList (tailCP cp).

Lemma consTailOK {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) t,
  CPToList (consTailCP cp t) = CPToList cp ++ t :: nil.

Lemma InNth {T:Type} {n:nat} :
  forall (cp : cartesianPower T n) (t Default : T),
  InCP t cp -> (exists id, id >= 1 /\ id <= n /\ t = nthCP id cp Default).

Lemma nthFirst {T:Type} {n:nat} :
  forall (cp : cartesianPower T (S n)) (t Default : T),
  t = nthCP 1 cp Default -> t = headCP cp.

Lemma lengthOfCPToList {T:Type} {n:nat} : forall (cp : cartesianPower T n), n = length (CPToList cp).

Lemma lastTailOK {T:Type} {n:nat} :
  forall (cp : cartesianPower T (S (S n))),
  lastCP cp = lastCP (tailCP cp).

Lemma consTailCPLast {T:Type} {n:nat} :
  forall (cp : cartesianPower T (S n)) t,
  lastCP (consTailCP cp t) = t.

Lemma nthLast {T:Type} {n:nat} :
  forall (cp : cartesianPower T (S n)) (Default : T),
  lastCP cp = nthCP (S n) cp Default.

Lemma nthCircPerm1 {T:Type} {n:nat} :
  forall (cp : cartesianPower T (S (S n))) (t Default : T),
  t = nthCP 1 cp Default -> t = nthCP (S (S n)) (consTailCP (tailCP cp) (headCP cp)) Default.

Lemma nthCircPerm1Eq {T:Type} {n:nat} :
  forall (cp : cartesianPower T (S (S n))) (Default : T),
  nthCP 1 cp Default = nthCP (S (S n)) (consTailCP (tailCP cp) (headCP cp)) Default.

Lemma nthCircPerm2 {T:Type} {n:nat} :
  forall (cp : cartesianPower T (S (S n))) (t Default : T) id,
  t = nthCP (S (S id)) cp Default -> id <= n ->
  t = nthCP (S id) (consTailCP (tailCP cp) (headCP cp)) Default.

Lemma nthCircPerm2Eq {T:Type} {n:nat} :
  forall (cp : cartesianPower T (S (S n))) (Default : T) id,
  id <= n -> nthCP (S (S id)) cp Default = nthCP (S id) (consTailCP (tailCP cp) (headCP cp)) Default.

Lemma nthCPTlOK {T:Type} {m:nat} :
  forall (cp : cartesianPower T (S (S m))) (Default : T) n,
  nthCP (S n) (tailCP cp) Default = nthCP (S (S n)) cp Default.

Lemma nthEqOK {T:Type} {m:nat} :
  forall (cp1 cp2 : cartesianPower T (S m)) (Default : T),
  (forall n, nthCP n cp1 Default = nthCP n cp2 Default) -> cp1 = cp2.

Lemma consTailPerm  {T:Type} {n:nat} :
  forall (cp : cartesianPower T (S (S n))),
  Permutation.Permutation (CPToList cp) (CPToList (consTailCP (tailCP cp) (headCP cp))).

Definition ListToCP {T : Type} (l : list T) (Default : T) : cartesianPower T (length l).

Fixpoint circPermNCP {T:Type} {m:nat} (n : nat) (cp : cartesianPower T (S (S m))) :=
  match n with
  | 0 => cp
  | S p => circPermNCP p (consTailCP (tailCP cp) (headCP cp))
  end.

Lemma circPermNCP0 {T:Type} {n:nat} :
  forall (cp : cartesianPower T (S (S n))),
  cp = circPermNCP 0 cp.

Lemma circPermNCPOK {T:Type} {m:nat} :
  forall (n : nat) (cp : cartesianPower T (S (S m))),
  circPermNCP (S n) cp = circPermNCP n (consTailCP (tailCP cp) (headCP cp)).

Lemma nthCircPermNAny {T:Type} {m:nat} :
  forall (cp : cartesianPower T (S (S m))) (Default : T) id n,
  id + n <= S m -> nthCP (S id + n) cp Default = nthCP (S id) (circPermNCP n cp) Default.

Lemma circPermNIdFirst {T:Type} {n:nat} :
  forall (cp : cartesianPower T (S (S n))) (Default : T),
  nthCP 1 cp Default = nthCP 1 (circPermNCP (S (S n)) cp) Default.

Lemma circPermNConsTlOK {T:Type} {m:nat} :
  forall (n : nat) (cp : cartesianPower T (S (S m))),
  consTailCP (tailCP (circPermNCP n cp)) (headCP (circPermNCP n cp)) = circPermNCP n (consTailCP (tailCP cp) (headCP cp)).

Lemma circPermPerm {T:Type} {m:nat} :
  forall (n : nat) (cp : cartesianPower T (S (S m))),
  circPermNCP (S (S (S n))) cp = circPermNCP 1 (circPermNCP (S (S n)) cp).

Lemma nthCP01 {T:Type} {n:nat} :
  forall (cp : cartesianPower T (S n)) Default,
  nthCP 0 cp Default = nthCP 1 cp Default.

Lemma circPermNIdAux {T:Type} {n:nat} :
  forall (cp : cartesianPower T (S (S n))) (Default : T),
  cp = circPermNCP (S (S n)) cp.

Lemma circPermNId {T:Type} {n:nat} :
  forall (cp : cartesianPower T (S (S n))),
  cp = circPermNCP (S (S n)) cp.

Lemma circPermNConsOK {T:Type} {n:nat} :
  forall (cp : cartesianPower T (S n)) (t1 t2 : T),
  circPermNCP (S n) (consTailCP (consTailCP cp t1) t2) = consHeadCP t1 (consHeadCP t2 cp).

Lemma listInd {T : Type} : forall n (l l' : list T) Default,
  length l = (S n) ->
  length l' = (S n) ->
  hd Default l = hd Default l' ->
  tl l = tl l' ->
  l = l'.

Lemma CPLHd {T : Type} :
  forall (a : T) l Default,
  hd Default (CPToList (ListToCP (a :: l) Default)) = a.

Lemma ListToCPTl {T : Type} :
  forall (a a0 : T) l (Ha0l : (S (length l)) = length (a0  :: l)) Haa0l Default,
  tailCPbis (length (a :: a0 :: l)) (length (a :: l)) (ListToCP (a :: a0 :: l) Default) Haa0l Ha0l =
  ListToCP (a0 :: l) Default.

Lemma CPToListTl1 {T : Type} :
  forall (a a0 : T) l (cp : cartesianPower T (length (a :: a0 :: l))), tl (CPToList cp) = CPToList (tailCP cp).

Lemma CPToListTl2 {T : Type} {n : nat} :
  forall (cp : cartesianPower T (S (S n))), tl (CPToList cp) = CPToList (tailCP cp).

Lemma CPCPL {T : Type} :
  forall (a : T) l (cp1 : cartesianPower T (length (a :: l)))
  (cp2 : cartesianPower T (S(length l))),
  cp1 = cp2 -> CPToList cp1 = CPToList cp2.

Lemma CPLCP {T : Type} {n : nat} :
  forall (cp1 cp2 : cartesianPower T (S n)),
  CPToList cp1 = CPToList cp2 -> cp1 = cp2.

Lemma CPLRec {T : Type} :
  forall (a : T) l Default,
  (a :: (CPToList (ListToCP l Default))) = CPToList (ListToCP (a :: l) Default).

Lemma CPLOK {T : Type} : forall (l : list T) Default,
  CPToList (ListToCP l Default) = l.

Definition fixLastCP {T:Type} {n:nat} (appPred : cartesianPower T (S (S n)) -> Prop) (t : T) : cartesianPower T (S n) -> Prop.

Lemma fixLastCPOK {T:Type} {n:nat} :
  forall (appPred : cartesianPower T (S (S n)) -> Prop) (cp : cartesianPower T (S n)) (t : T),
  appPred (consTailCP  cp t) = (fixLastCP appPred t) cp.

Definition app {T:Type} {n:nat} (pred : arity T n) (cp : cartesianPower T n) : Prop.

Definition app_n_1 {T:Type} {n:nat} (pred : arity T (S n)) (cp : cartesianPower T n) (x : T) : Prop.

Lemma app_n_1_app {T:Type} {n:nat} :
  forall (pred : arity T (S (S n))) (x : T)
         (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))),
    app_n_1 pred cpp x -> allButLastCP cpt = cpp -> lastCP cpt = x ->
    app pred cpt.

Lemma app_app_n_1 {T:Type} {n:nat} :
  forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))),
  app pred cpt -> allButLastCP cpt = cpp -> lastCP cpt = x ->
  app_n_1 pred cpp x.

Lemma app_n_1_app_eq {T:Type} {n:nat} :
  forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))),
  allButLastCP cpt = cpp -> lastCP cpt = x ->
  (app pred cpt <-> app_n_1 pred cpp x).

Definition app_1_n {T:Type} {n:nat} (pred : arity T (S n)) (x : T) (cp : cartesianPower T n) : Prop.

Lemma app_1_n_app {T:Type} {n:nat} :
  forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))),
  app_1_n pred x cpp -> headCP cpt = x -> tailCP cpt = cpp ->
  app pred cpt.

Lemma app_app_1_n {T:Type} {n:nat} :
  forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))),
  app pred cpt -> headCP cpt = x -> tailCP cpt = cpp ->
  app_1_n pred x cpp.

Lemma app_1_n_app_eq {T:Type} {n:nat} :
  forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))),
  headCP cpt = x -> tailCP cpt = cpp ->
  (app pred cpt <-> app_1_n pred x cpp).

Definition app_2_n {T:Type} {n:nat} (pred : arity T (S (S n))) (x1 x2 : T) (cp : cartesianPower T n) : Prop.

Lemma app_2_n_app {T:Type} {n:nat} :
  forall (pred : arity T (S (S (S n)))) (x1 x2 : T)
  (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S (S n)))),
  app_2_n pred x1 x2 cpp -> headCP cpt = x1 -> headCP (tailCP cpt) = x2 -> tailCP (tailCP cpt) = cpp ->
  app pred cpt.

Lemma app_2_n_app_default {T:Type} {n:nat} :
  forall (pred : arity T (S (S n))) (x1 x2 : T)
  (cpp Default : cartesianPower T n) (cpt : cartesianPower T (S (S n))),
  app_2_n pred x1 x2 cpp -> headCP cpt = x1 ->
  headCP (tailCP cpt) = x2 ->
  tailDefaultCP (tailCP cpt) Default = cpp ->
  app pred cpt.

Lemma app_app_2_n {T:Type} {n:nat} :
  forall (pred : arity T (S (S (S n)))) (x1 x2 : T)
  (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S (S n)))),
  app pred cpt -> headCP cpt = x1 -> headCP (tailCP cpt) = x2 -> tailCP (tailCP cpt) = cpp ->
  app_2_n pred x1 x2 cpp.

Lemma app_app_2_n_default {T:Type} {n:nat} :
  forall (pred : arity T (S (S n))) (x1 x2 : T)
  (cpp Default : cartesianPower T n) (cpt : cartesianPower T (S (S n))),
  app pred cpt -> headCP cpt = x1 -> headCP (tailCP cpt) = x2 -> tailDefaultCP (tailCP cpt) Default = cpp ->
  app_2_n pred x1 x2 cpp.

Lemma app_2_n_app_eq {T:Type} {n:nat} :
  forall (pred : arity T (S (S (S n)))) (x1 x2 : T)
  (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S (S n)))),
  headCP cpt = x1 -> headCP (tailCP cpt) = x2 -> tailCP (tailCP cpt) = cpp ->
  (app pred cpt <-> app_2_n pred x1 x2 cpp).

Lemma PermOKAux {T : Type} {m : nat} :
  forall (appPred : (cartesianPower T (S (S m))) -> Prop) n,
  (forall (A : T) (X : cartesianPower T (S m)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) ->
  (forall (X : cartesianPower T (S (S m))),
          appPred X -> appPred (circPermNCP n X)).

Lemma PermOK {T : Type} {n : nat} :
  forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop),
  (forall (A : T) (X : cartesianPower T (S n)),
    appPred (consHeadCP A X) -> appPred (consTailCP X A)) ->
  (forall (A B : T) (X : cartesianPower T n),
    appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) ->
  appPred cp1 ->
  Permutation.Permutation (CPToList cp1) (CPToList cp2) ->

Lemma lengthNilOK {A : Type} : forall (l : list A),
  length l = 0 -> l = nil.

Lemma NoDupOK {A : Type} : forall (l l' : list A),
  incl l l' ->
  length l = length l' ->
  NoDup l ->
  Permutation.Permutation l l'.

Lemma NoDup_dec {A : Type} : forall (l : list A),
  (forall x y : A, {x = y} + {x <> y}) ->
  NoDup l \/ ~ NoDup l.

Lemma NotNoDupDup {A : Type} : forall (l : list A),
  (forall x y : A, {x = y} + {x <> y}) ->
  ~ NoDup l->
  exists e l1 l2, l = l1 ++ e :: l2 /\ In e (l1 ++ l2).

Definition pred_conj_aux {T:Type} {n:nat} (pred : arity T (S n)) (m : nat) (cp : cartesianPower T (S m)) (cpwd : cartesianPower T n) : Prop.

Lemma pcaHdTl {T:Type} {n:nat} : forall (pred : arity T (S n)) m cp cpwd,
  pred_conj_aux pred (S m) cp cpwd = (app_1_n pred (headCP cp) cpwd /\ pred_conj_aux pred m (tailCP cp) cpwd).

Definition pred_conj {T:Type} {n:nat} (pred : arity T (S n)) (cp : cartesianPower T (S n)) (cpwd : cartesianPower T n) : Prop. *)

Require Import GeoCoq.Tactics.Coinc.tactics_axioms.
(* GeoCoq.Tactics.Coinc.tactics_axioms:
Require Export GeoCoq.Utils.arity.

Class Col_theory (COLTpoint : Type) (CTCol: COLTpoint -> COLTpoint -> COLTpoint -> Prop) :=
{
  CTcol_trivial : forall A B : COLTpoint, CTCol A A B;
  CTcol_permutation_1 : forall A B C : COLTpoint, CTCol A B C -> CTCol B C A;
  CTcol_permutation_2 : forall A B C : COLTpoint, CTCol A B C -> CTCol A C B;
  CTcol3 : forall X Y A B C : COLTpoint,
             X <> Y -> CTCol X Y A -> CTCol X Y B -> CTCol X Y C -> CTCol A B C
}.

Class Arity :=
{
  COINCpoint : Type;
  n : nat
}.

Class Coinc_predicates (Ar : Arity) :=
{
  wd : arity COINCpoint (S (S n));
  coinc : arity COINCpoint (S (S (S n)))
}.

Class Coinc_theory (Ar : Arity) (COP : Coinc_predicates Ar) :=
{
  wd_perm_1 : forall A : COINCpoint,
              forall X : cartesianPower COINCpoint (S n),
                app_1_n wd A X -> app_n_1 wd X A;
  wd_perm_2 : forall A B : COINCpoint,
              forall X : cartesianPower COINCpoint n,
                app_2_n wd A B X -> app_2_n wd B A X;
  coinc_perm_1 : forall A : COINCpoint,
                 forall X : cartesianPower COINCpoint (S (S n)),
                   app_1_n coinc A X -> app_n_1 coinc X A;
  coinc_perm_2 : forall A B : COINCpoint,
                 forall X : cartesianPower COINCpoint (S n),
                   app_2_n coinc A B X -> app_2_n coinc B A X;
  coinc_bd : forall A : COINCpoint,
             forall X : cartesianPower COINCpoint (S n),
              app_2_n coinc A A X;
  coinc_n : forall COINC : cartesianPower COINCpoint (S (S (S n))),
            forall WD : cartesianPower COINCpoint (S (S n)),
              pred_conj coinc COINC WD ->
              app wd WD ->
              app coinc COINC
}. *)



Section Permutations.



Context `{COT : Coinc_theory}.



Lemma PermWdOK :

  forall (cp1 cp2 : cartesianPower COINCpoint (S (S n))),

  app wd cp1 ->

  Permutation.Permutation (CPToList cp1) (CPToList cp2) ->

  app wd cp2.

Proof.

intros cp1 cp2 Happ HPerm.

apply PermOK with cp1; try assumption; clear HPerm; clear Happ; clear cp2; clear cp1.



  intros A X Happ; apply app_n_1_app with A X; try (apply wd_perm_1;

  apply app_app_1_n with (consHeadCP A X); try assumption).



    simpl; reflexivity.



    apply consHeadCPTl.



    apply consTailCPAbl.



    apply consTailCPLast.



  intros A B X Happ; apply app_2_n_app_default with B A X X; try (apply wd_perm_2;

  apply app_app_2_n_default with X (consHeadCP A (consHeadCP B X)); try assumption).



    simpl; reflexivity.



    rewrite consHeadCPTl; rewrite consHeadCPHd; reflexivity.



    rewrite consHeadCPTl; apply consTailCPTlD.



    simpl; reflexivity.



    rewrite consHeadCPTl; rewrite consHeadCPHd; reflexivity.



    rewrite consHeadCPTl; apply consTailCPTlD.

Qed.



Lemma PermCoincOK :

  forall (cp1 cp2 : cartesianPower COINCpoint (S (S (S n)))),

  app coinc cp1 ->

  Permutation.Permutation (CPToList cp1) (CPToList cp2) ->

  app coinc cp2.

Proof.

intros cp1 cp2 Happ HPerm.

apply PermOK with cp1; try assumption; clear HPerm; clear Happ; clear cp2; clear cp1.



  intros A X Happ; apply app_n_1_app with A X; try (apply coinc_perm_1;

  apply app_app_1_n with (consHeadCP A X); try assumption).



    simpl; reflexivity.



    apply consHeadCPTl.



    apply consTailCPAbl.



    apply consTailCPLast.



  intros A B X Happ; apply app_2_n_app with B A X; try (apply coinc_perm_2;

  apply app_app_2_n with (consHeadCP A (consHeadCP B X)); try assumption).



    simpl; reflexivity.



    simpl; reflexivity.



    apply consHeadCPTl.



    simpl; reflexivity.



    simpl; reflexivity.



    apply consHeadCPTl.

Qed.



End Permutations.

