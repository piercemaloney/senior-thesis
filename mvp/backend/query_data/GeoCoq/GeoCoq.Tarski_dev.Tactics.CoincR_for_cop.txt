Require Import GeoCoq.Tarski_dev.Ch09_plane.
(* GeoCoq.Tarski_dev.Ch09_plane:
Require Export GeoCoq.Tarski_dev.Ch08_orthogonality.
Require Export GeoCoq.Tarski_dev.Annexes.coplanar.

Ltac clean_reap_hyps :=
  clean_duplicated_hyps;
  repeat
  match goal with
   | H:(Midpoint ?A ?B ?C), H2 : Midpoint ?A ?C ?B |- _ => clear H2
   | H:(Col ?A ?B ?C), H2 : Col ?A ?C ?B |- _ => clear H2
   | H:(Col ?A ?B ?C), H2 : Col ?B ?A ?C |- _ => clear H2
   | H:(Col ?A ?B ?C), H2 : Col ?B ?C ?A |- _ => clear H2
   | H:(Col ?A ?B ?C), H2 : Col ?C ?B ?A |- _ => clear H2
   | H:(Col ?A ?B ?C), H2 : Col ?C ?A ?B |- _ => clear H2
   | H:(Bet ?A ?B ?C), H2 : Bet ?C ?B ?A |- _ => clear H2
   | H:(Cong ?A ?B ?C ?D), H2 : Cong ?A ?B ?D ?C |- _ => clear H2
   | H:(Cong ?A ?B ?C ?D), H2 : Cong ?C ?D ?A ?B |- _ => clear H2
   | H:(Cong ?A ?B ?C ?D), H2 : Cong ?C ?D ?B ?A |- _ => clear H2
   | H:(Cong ?A ?B ?C ?D), H2 : Cong ?D ?C ?B ?A |- _ => clear H2
   | H:(Cong ?A ?B ?C ?D), H2 : Cong ?D ?C ?A ?B |- _ => clear H2
   | H:(Cong ?A ?B ?C ?D), H2 : Cong ?B ?A ?C ?D |- _ => clear H2
   | H:(Cong ?A ?B ?C ?D), H2 : Cong ?B ?A ?D ?C |- _ => clear H2
   | H:(Perp ?A ?B ?C ?D), H2 : Perp ?A ?B ?D ?C |- _ => clear H2
   | H:(Perp ?A ?B ?C ?D), H2 : Perp ?C ?D ?A ?B |- _ => clear H2
   | H:(Perp ?A ?B ?C ?D), H2 : Perp ?C ?D ?B ?A |- _ => clear H2
   | H:(Perp ?A ?B ?C ?D), H2 : Perp ?D ?C ?B ?A |- _ => clear H2
   | H:(Perp ?A ?B ?C ?D), H2 : Perp ?D ?C ?A ?B |- _ => clear H2
   | H:(Perp ?A ?B ?C ?D), H2 : Perp ?B ?A ?C ?D |- _ => clear H2
   | H:(Perp ?A ?B ?C ?D), H2 : Perp ?B ?A ?D ?C |- _ => clear H2
   | H:(?A<>?B), H2 : (?B<>?A) |- _ => clear H2
   | H:(Per ?A ?D ?C), H2 : (Per ?C ?D ?A) |- _ => clear H2
   | H:(Perp_at ?X ?A ?B ?C ?D), H2 : Perp_at ?X ?A ?B ?D ?C |- _ => clear H2
   | H:(Perp_at ?X ?A ?B ?C ?D), H2 : Perp_at ?X ?C ?D ?A ?B |- _ => clear H2
   | H:(Perp_at ?X ?A ?B ?C ?D), H2 : Perp_at ?X ?C ?D ?B ?A |- _ => clear H2
   | H:(Perp_at ?X ?A ?B ?C ?D), H2 : Perp_at ?X ?D ?C ?B ?A |- _ => clear H2
   | H:(Perp_at ?X ?A ?B ?C ?D), H2 : Perp_at ?X ?D ?C ?A ?B |- _ => clear H2
   | H:(Perp_at ?X ?A ?B ?C ?D), H2 : Perp_at ?X ?B ?A ?C ?D |- _ => clear H2
   | H:(Perp_at ?X ?A ?B ?C ?D), H2 : Perp_at ?X ?B ?A ?D ?C |- _ => clear H2
end.

Ltac assert_diffs :=
repeat
 match goal with
      | H:(~Col ?X1 ?X2 ?X3) |- _ =>
      let h := fresh in
      not_exist_hyp3 X1 X2 X1 X3 X2 X3;
      assert (h := not_col_distincts X1 X2 X3 H);decompose [and] h;clear h;clean_reap_hyps

      | H:(~Bet ?X1 ?X2 ?X3) |- _ =>
      let h := fresh in
      not_exist_hyp2 X1 X2 X2 X3;
      assert (h := not_bet_distincts X1 X2 X3 H);decompose [and] h;clear h;clean_reap_hyps
      | H:Bet ?A ?B ?C, H2 : ?A <> ?B |-_ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= bet_neq12__neq A B C H H2);clean_reap_hyps
      | H:Bet ?A ?B ?C, H2 : ?B <> ?A |-_ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= bet_neq21__neq A B C H H2);clean_reap_hyps
      | H:Bet ?A ?B ?C, H2 : ?B <> ?C |-_ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= bet_neq23__neq A B C H H2);clean_reap_hyps
      | H:Bet ?A ?B ?C, H2 : ?C <> ?B |-_ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= bet_neq32__neq A B C H H2);clean_reap_hyps

      | H:Cong ?A ?B ?C ?D, H2 : ?A <> ?B |-_ =>
      let T:= fresh in (not_exist_hyp_comm C D);
        assert (T:= cong_diff A B C D H2 H);clean_reap_hyps
      | H:Cong ?A ?B ?C ?D, H2 : ?B <> ?A |-_ =>
      let T:= fresh in (not_exist_hyp_comm C D);
        assert (T:= cong_diff_2 A B C D H2 H);clean_reap_hyps
      | H:Cong ?A ?B ?C ?D, H2 : ?C <> ?D |-_ =>
      let T:= fresh in (not_exist_hyp_comm A B);
        assert (T:= cong_diff_3 A B C D H2 H);clean_reap_hyps
      | H:Cong ?A ?B ?C ?D, H2 : ?D <> ?C |-_ =>
      let T:= fresh in (not_exist_hyp_comm A B);
        assert (T:= cong_diff_4 A B C D H2 H);clean_reap_hyps

      | H:Le ?A ?B ?C ?D, H2 : ?A <> ?B |-_ =>
      let T:= fresh in (not_exist_hyp_comm C D);
        assert (T:= le_diff A B C D H2 H);clean_reap_hyps
      | H:Le ?A ?B ?C ?D, H2 : ?B <> ?A |-_ =>
      let T:= fresh in (not_exist_hyp_comm C D);
        assert (T:= le_diff A B C D (swap_diff B A H2) H);clean_reap_hyps
      | H:Lt ?A ?B ?C ?D |-_ =>
      let T:= fresh in (not_exist_hyp_comm C D);
        assert (T:= lt_diff A B C D H);clean_reap_hyps

      | H:Midpoint ?I ?A ?B, H2 : ?A<>?B |- _ =>
      let T:= fresh in (not_exist_hyp2 I B I A);
       assert (T:= midpoint_distinct_1 I A B H2 H);
       decompose [and] T;clear T;clean_reap_hyps
      | H:Midpoint ?I ?A ?B, H2 : ?B<>?A |- _ =>
      let T:= fresh in (not_exist_hyp2 I B I A);
       assert (T:= midpoint_distinct_1 I A B (swap_diff B A H2) H);
       decompose [and] T;clear T;clean_reap_hyps

      | H:Midpoint ?I ?A ?B, H2 : ?I<>?A |- _ =>
      let T:= fresh in (not_exist_hyp2 I B A B);
       assert (T:= midpoint_distinct_2 I A B H2 H);
       decompose [and] T;clear T;clean_reap_hyps
      | H:Midpoint ?I ?A ?B, H2 : ?A<>?I |- _ =>
      let T:= fresh in (not_exist_hyp2 I B A B);
       assert (T:= midpoint_distinct_2 I A B (swap_diff A I H2) H);
       decompose [and] T;clear T;clean_reap_hyps

      | H:Midpoint ?I ?A ?B, H2 : ?I<>?B |- _ =>
      let T:= fresh in (not_exist_hyp2 I A A B);
       assert (T:= midpoint_distinct_3 I A B H2 H);
       decompose [and] T;clear T;clean_reap_hyps
      | H:Midpoint ?I ?A ?B, H2 : ?B<>?I |- _ =>
      let T:= fresh in (not_exist_hyp2 I A A B);
       assert (T:= midpoint_distinct_3 I A B (swap_diff B I H2) H);
       decompose [and] T;clear T;clean_reap_hyps

      | H:Per ?A ?B ?C, H2 : ?A<>?B |- _ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= per_distinct A B C H H2); clean_reap_hyps
      | H:Per ?A ?B ?C, H2 : ?B<>?A |- _ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= per_distinct A B C H (swap_diff B A H2)); clean_reap_hyps
      | H:Per ?A ?B ?C, H2 : ?B<>?C |- _ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= per_distinct_1 A B C H H2); clean_reap_hyps
      | H:Per ?A ?B ?C, H2 : ?C<>?B |- _ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= per_distinct_1 A B C H (swap_diff C B H2)); clean_reap_hyps

      | H:Perp ?A ?B ?C ?D |- _ =>
      let T:= fresh in (not_exist_hyp2 A B C D);
       assert (T:= perp_distinct A B C D H);
       decompose [and] T;clear T;clean_reap_hyps
      | H:Perp_at ?X ?A ?B ?C ?D |- _ =>
      let T:= fresh in (not_exist_hyp2 A B C D);
       assert (T:= perp_in_distinct X A B C D H);
       decompose [and] T;clear T;clean_reap_hyps
      | H:Out ?A ?B ?C |- _ =>
      let T:= fresh in (not_exist_hyp2 A B A C);
       assert (T:= out_distinct A B C H);
       decompose [and] T;clear T;clean_reap_hyps
 end.

Ltac clean_trivial_hyps :=
  repeat
  match goal with
   | H:(Cong ?X1 ?X1 ?X2 ?X2) |- _ => clear H
   | H:(Cong ?X1 ?X2 ?X2 ?X1) |- _ => clear H
   | H:(Cong ?X1 ?X2 ?X1 ?X2) |- _ => clear H
   | H:(Bet ?X1 ?X1 ?X2) |- _ => clear H
   | H:(Bet ?X2 ?X1 ?X1) |- _ => clear H
   | H:(Col ?X1 ?X1 ?X2) |- _ => clear H
   | H:(Col ?X2 ?X1 ?X1) |- _ => clear H
   | H:(Col ?X1 ?X2 ?X1) |- _ => clear H
   | H:(Per ?X1 ?X2 ?X2)     |- _ => clear H
   | H:(Per ?X1 ?X1 ?X2)     |- _ => clear H
   | H:(Midpoint ?X1 ?X1 ?X1) |- _ => clear H
end.

Ltac clean := clean_trivial_hyps;clean_reap_hyps.

Section T9.

Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.

Lemma ts_distincts : forall A B P Q, TS A B P Q ->
  A <> B /\ A <> P /\ A <> Q /\ B <> P /\ B <> Q /\ P <> Q.

Lemma l9_2 : forall A B P Q, TS A B P Q -> TS A B Q P.

Lemma invert_two_sides : forall A B P Q,
 TS A B P Q -> TS B A P Q.

Lemma l9_3 : forall P Q A C M R B,
 TS P Q A C -> Col M P Q ->
 Midpoint M A C -> Col R P Q ->
 Out R A B -> TS P Q B C.

Lemma mid_preserves_col : forall A B C M A' B' C',
  Col A B C ->
  Midpoint M A A' ->
  Midpoint M B B' ->
  Midpoint M C C' ->
  Col A' B' C'.

Lemma per_mid_per : forall A B X Y M,
   A <> B -> Per X A B ->
   Midpoint M A B -> Midpoint M X Y ->
   Cong A X B Y /\ Per Y B A.

Lemma sym_preserve_diff : forall A B M A' B',
 A <> B -> Midpoint M A A' -> Midpoint M B B' -> A'<> B'.

Lemma l9_4_1_aux : forall P Q A C R S M,
 Le S C R A ->
 TS P Q A C -> Col R P Q -> Perp P Q A R -> Col S P Q ->
 Perp P Q C S -> Midpoint M R S ->
 (forall U C',Midpoint M U C' -> (Out R U A <-> Out S C C')).

Lemma per_col_eq : forall A B C, Per A B C -> Col A B C -> B <> C -> A = B.

Lemma l9_4_1 : forall P Q A C R S M,
 TS P Q A C -> Col R P Q ->
 Perp P Q A R -> Col S P Q ->
 Perp P Q C S -> Midpoint M R S ->
 (forall U C',Midpoint M U C' -> (Out R U A <-> Out S C C')).

Lemma mid_two_sides : forall A B M X Y,
 Midpoint M A B -> ~ Col A B X -> Midpoint M X Y ->
 TS A B X Y.

Lemma col_preserves_two_sides : forall A B C D X Y,
 C <> D -> Col A B C -> Col A B D ->
 TS A B X Y ->
 TS C D X Y.

Lemma out_out_two_sides : forall A B X Y U V I,
  A <> B ->
  TS A B X Y ->
  Col I A B -> Col I X Y ->
  Out I X U -> Out I Y V ->
  TS A B U V.

Lemma l9_4_2_aux : forall P Q A C R S U V, Le S C R A -> TS P Q A C -> Col R P Q -> Perp P Q A R -> Col S P Q ->
Perp P Q C S -> Out R U A -> Out S V C -> TS P Q U V.

Lemma l9_4_2 : forall P Q A C R S U V,
TS P Q A C -> Col R P Q -> Perp P Q A R -> Col S P Q ->
Perp P Q C S -> Out R U A -> Out S V C -> TS P Q U V.

Lemma l9_5 : forall P Q A C R B,
 TS P Q A C -> Col R P Q -> Out R A B -> TS P Q B C.

Lemma outer_pasch : forall A B C P Q,
 Bet A C P -> Bet B Q C -> exists X, Bet A X B /\ Bet P Q X.

Lemma os_distincts : forall A B X Y, OS A B X Y ->
  A <> B /\ A <> X /\ A <> Y /\ B <> X /\ B <> Y.

Lemma invert_one_side : forall A B P Q,
 OS A B P Q -> OS B A P Q.

Lemma l9_8_1 : forall P Q A B C, TS P Q A C -> TS P Q B C -> OS P Q A B.

Lemma not_two_sides_id : forall A P Q, ~ TS P Q A A.

Lemma l9_8_2 : forall P Q A B C,
 TS P Q A C ->
 OS P Q A B ->
 TS P Q B C.

Lemma l9_9 : forall P Q A B, TS P Q A B -> ~ OS P Q A B.

Lemma l9_9_bis : forall P Q A B, OS P Q A B -> ~ TS P Q A B.

Lemma one_side_chara : forall P Q A B,
 OS P Q A B -> (forall X, Col X P Q -> ~ Bet A X B).

Lemma l9_10 : forall P Q A,
 ~ Col A P Q -> exists C, TS P Q A C.

Lemma one_side_reflexivity : forall P Q A,
 ~ Col A P Q -> OS P Q A A.

Lemma one_side_symmetry : forall P Q A B,
 OS P Q A B -> OS P Q B A.

Lemma one_side_transitivity : forall P Q A B C,
OS P Q A B -> OS P Q B C -> OS P Q A C.

Lemma col_eq : forall A B X Y,
  A <> X -> Col A X Y -> Col B X Y ->
 ~ Col A X B ->
 X = Y.

Lemma l9_17 : forall A B C P Q, OS P Q A C -> Bet A B C -> OS P Q A B.

Lemma l9_18 : forall X Y A B P,
 Col X Y P -> Col A B P -> (TS X Y A B <-> (Bet A P B /\ ~Col X Y A /\ ~Col X Y B)).

Lemma l9_19 : forall X Y A B P ,
 Col X Y P -> Col A B P -> (OS X Y A B <-> (Out P A B /\ ~Col X Y A)).

Lemma one_side_not_col123 :
 forall A B X Y,
  OS A B X Y ->
  ~ Col A B X.

Lemma one_side_not_col124 :
 forall A B X Y,
  OS A B X Y ->
  ~ Col A B Y.

Lemma col_two_sides : forall A B C P Q,
 Col A B C -> A <> C -> TS A B P Q ->
 TS A C P Q.

Lemma col_one_side : forall A B C P Q,
  Col A B C -> A <> C -> OS A B P Q -> OS A C P Q.

Lemma out_out_one_side :
 forall A B X Y Z,
  OS A B X Y ->
  Out A Y Z ->
  OS A B X Z.

Lemma out_one_side : forall A B X Y, (~ Col A B X \/ ~ Col A B Y) -> Out A X Y -> OS A B X Y.

Lemma bet_ts__ts : forall A B X Y Z, TS A B X Y -> Bet X Y Z -> TS A B X Z.

Lemma bet_ts__os : forall A B X Y Z, TS A B X Y -> Bet X Y Z -> OS A B Y Z.

Lemma l9_31 :
 forall A X Y Z,
  OS A X Y Z ->
  OS A Z Y X ->
  TS A Y X Z.

Lemma col123__nos : forall A B P Q, Col P Q A -> ~ OS P Q A B.

Lemma col124__nos : forall A B P Q, Col P Q B -> ~ OS P Q A B.

Lemma col2_os__os : forall A B C D X Y, C <> D -> Col A B C ->
   Col A B D -> OS A B X Y -> OS C D X Y.

Lemma os_out_os : forall A B C D C' P , Col A B P -> OS A B C D -> Out P C C' -> OS A B C' D.

Lemma ts_ts_os : forall A B C D, TS A B C D -> TS C D A B -> OS A C B D.

Lemma two_sides_not_col :
 forall A B X Y,
  TS A B X Y ->
  ~ Col A B X.

Lemma col_one_side_out : forall A B X Y,
 Col A X Y ->
 OS A B X Y ->
 Out A X Y.

Lemma col_two_sides_bet :
 forall A B X Y,
 Col A X Y ->
 TS A B X Y ->
 Bet X A Y.

Lemma os_ts1324__os : forall A X Y Z,
  OS A X Y Z ->
  TS A Y X Z ->
  OS A Z X Y.

Lemma ts2__ex_bet2 : forall A B C D, TS A C B D -> TS B D A C ->
  exists X, Bet A X C /\ Bet B X D.

Lemma ts2__inangle : forall A B C P, TS A C B P -> TS B P A C ->
  InAngle P A B C.

Lemma out_one_side_1 :
 forall A B C D X,
 ~ Col A B C -> Col A B X -> Out X C D ->
 OS A B C D.

Lemma out_two_sides_two_sides :
 forall A B X Y P PX,
  A <> PX ->
  Col A B PX ->
  Out PX X P ->
  TS A B P Y ->
  TS A B X Y.

Lemma l8_21_bis : forall A B C X Y, X <> Y -> ~ Col C A B -> exists P : Tpoint,
  Cong A P X Y /\ Perp A B P A /\ TS A B C P.

Lemma ts__ncol : forall A B X Y, TS A B X Y -> ~Col A X Y \/ ~Col B X Y.

Lemma one_or_two_sides_aux : forall A B C D X,
 ~ Col C A B -> ~ Col D A B -> Col A C X -> Col B D X ->
 TS A B C D \/ OS A B C D.

Lemma cop__one_or_two_sides :
 forall A B C D, Coplanar A B C D ->
  ~ Col C A B ->
  ~ Col D A B ->
  TS A B C D \/ OS A B C D.

Lemma os__coplanar : forall A B C D, OS A B C D -> Coplanar A B C D.

Lemma coplanar_trans_1 : forall P Q R A B,
  ~ Col P Q R -> Coplanar P Q R A -> Coplanar P Q R B -> Coplanar Q R A B.

Lemma coplanar_pseudo_trans : forall A B C D P Q R,
  ~ Col P Q R ->
  Coplanar P Q R A ->
  Coplanar P Q R B ->
  Coplanar P Q R C ->
  Coplanar P Q R D ->
  Coplanar A B C D.

Lemma col_cop__cop : forall A B C D E, Coplanar A B C D -> C <> D -> Col C D E -> Coplanar A B C E.

Lemma bet_cop__cop : forall A B C D E, Coplanar A B C E -> Bet C D E -> Coplanar A B C D.

Lemma col2_cop__cop : forall A B C D E F, Coplanar A B C D -> C <> D -> Col C D E -> Col C D F ->
  Coplanar A B E F.

Lemma l9_30 : forall A B C D E F P X Y Z,
  ~ Coplanar A B C P -> ~ Col D E F -> Coplanar D E F P ->
  Coplanar A B C X -> Coplanar A B C Y -> Coplanar A B C Z ->
  Coplanar D E F X -> Coplanar D E F Y -> Coplanar D E F Z ->
  Col X Y Z.

Lemma cop_per2__col : forall A X Y Z,
  Coplanar A X Y Z ->  A <> Z -> Per X Z A -> Per Y Z A -> Col X Y Z.

Lemma cop_perp2__col : forall X Y Z A B,
 Coplanar A B Y Z -> Perp X Y A B -> Perp X Z A B -> Col X Y Z.

Lemma two_sides_dec : forall A B C D, TS A B C D \/ ~ TS A B C D.

Lemma cop__not_two_sides_one_side :
 forall A B C D,
  Coplanar A B C D ->
  ~ Col C A B ->
  ~ Col D A B ->
  ~ TS A B C D ->
  OS A B C D.

Lemma cop__not_one_side_two_sides :
 forall A B C D,
  Coplanar A B C D ->
  ~ Col C A B ->
  ~ Col D A B ->
  ~ OS A B C D ->
  TS A B C D.

Lemma one_side_dec : forall A B C D,
 OS A B C D \/ ~ OS A B C D.

Lemma cop_dec : forall A B C D,
 Coplanar A B C D \/ ~ Coplanar A B C D.

Lemma ex_diff_cop : forall A B C D, exists E,
  Coplanar A B C E /\ D <> E.

Lemma ex_ncol_cop : forall A B C D E, D <> E ->
  exists F, Coplanar A B C F /\ ~ Col D E F.

Lemma ex_ncol_cop2 : forall A B C D, exists E F,
  Coplanar A B C E /\ Coplanar A B C F /\ ~ Col D E F.

Lemma cop4__col : forall A1 A2 A3 B1 B2 B3 P Q R, ~ Coplanar A1 A2 A3 B1 -> ~ Col B1 B2 B3 ->
  Coplanar A1 A2 A3 P -> Coplanar B1 B2 B3 P ->
  Coplanar A1 A2 A3 Q -> Coplanar B1 B2 B3 Q ->
  Coplanar A1 A2 A3 R -> Coplanar B1 B2 B3 R ->
  Col P Q R.

Lemma col_cop2__cop : forall A B C U V P, U <> V ->
  Coplanar A B C U -> Coplanar A B C V -> Col U V P ->
  Coplanar A B C P.

Lemma bet_cop2__cop : forall A B C U V W,
  Coplanar A B C U -> Coplanar A B C W -> Bet U V W -> Coplanar A B C V.

Lemma col2_cop2__eq : forall A B C U V P Q, ~ Coplanar A B C U -> U <> V ->
  Coplanar A B C P -> Coplanar A B C Q -> Col U V P -> Col U V Q ->
  P = Q.

Lemma cong3_cop2__col : forall A B C P Q,
  Coplanar A B C P -> Coplanar A B C Q ->
  P <> Q -> Cong A P A Q -> Cong B P B Q -> Cong C P C Q ->
  Col A B C.

Lemma l9_38 : forall A B C P Q, TSP A B C P Q -> TSP A B C Q P.

Lemma l9_39 : forall A B C D P Q R, TSP A B C P R -> Coplanar A B C D -> Out D P Q ->
  TSP A B C Q R.

Lemma l9_41_1 : forall A B C P Q R, TSP A B C P R -> TSP A B C Q R -> OSP A B C P Q.

Lemma l9_41_2 : forall A B C P Q R, TSP A B C P R -> OSP A B C P Q -> TSP A B C Q R.

Lemma tsp_exists : forall A B C P, ~ Coplanar A B C P -> exists Q, TSP A B C P Q.

Lemma osp_reflexivity : forall A B C P, ~ Coplanar A B C P -> OSP A B C P P.

Lemma osp_symmetry : forall A B C P Q, OSP A B C P Q -> OSP A B C Q P.

Lemma osp_transitivity : forall A B C P Q R, OSP A B C P Q -> OSP A B C Q R -> OSP A B C P R.

Lemma cop3_tsp__tsp : forall A B C D E F P Q, ~ Col D E F ->
  Coplanar A B C D -> Coplanar A B C E -> Coplanar A B C F ->
  TSP A B C P Q -> TSP D E F P Q.

Lemma cop3_osp__osp : forall A B C D E F P Q, ~ Col D E F ->
  Coplanar A B C D -> Coplanar A B C E -> Coplanar A B C F ->
  OSP A B C P Q -> OSP D E F P Q.

Lemma ncop_distincts : forall A B C D, ~ Coplanar A B C D ->
  A <> B /\ A <> C /\ A <> D /\ B <> C /\ B <> D /\ C <> D.

Lemma tsp_distincts : forall A B C P Q, TSP A B C P Q ->
  A <> B /\ A <> C /\ B <> C /\ A <> P /\ B <> P /\ C <> P /\ A <> Q /\ B <> Q /\ C <> Q /\ P <> Q.

Lemma osp_distincts : forall A B C P Q, OSP A B C P Q ->
  A <> B /\ A <> C /\ B <> C /\ A <> P /\ B <> P /\ C <> P /\ A <> Q /\ B <> Q /\ C <> Q.

Lemma tsp__ncop1 : forall A B C P Q, TSP A B C P Q -> ~ Coplanar A B C P.

Lemma tsp__ncop2 : forall A B C P Q, TSP A B C P Q -> ~ Coplanar A B C Q.

Lemma osp__ncop1 : forall A B C P Q, OSP A B C P Q -> ~ Coplanar A B C P.

Lemma osp__ncop2 : forall A B C P Q, OSP A B C P Q -> ~ Coplanar A B C Q.

Lemma tsp__nosp : forall A B C P Q, TSP A B C P Q -> ~ OSP A B C P Q.

Lemma osp__ntsp : forall A B C P Q, OSP A B C P Q -> ~ TSP A B C P Q.

Lemma osp_bet__osp : forall A B C P Q R, OSP A B C P R -> Bet P Q R -> OSP A B C P Q.

Lemma l9_18_3 : forall A B C X Y P, Coplanar A B C P -> Col X Y P ->
  TSP A B C X Y <-> Bet X P Y /\ ~ Coplanar A B C X /\ ~ Coplanar A B C Y.

Lemma bet_cop__tsp : forall A B C X Y P,
  ~ Coplanar A B C X -> P <> Y -> Coplanar A B C P -> Bet X P Y ->
  TSP A B C X Y.

Lemma cop_out__osp : forall A B C X Y P,
  ~ Coplanar A B C X -> Coplanar A B C P -> Out P X Y -> OSP A B C X Y.

Lemma l9_19_3 : forall A B C X Y P, Coplanar A B C P -> Col X Y P ->
  OSP A B C X Y <-> Out P X Y /\ ~ Coplanar A B C X.

Lemma cop2_ts__tsp : forall A B C D E X Y, ~ Coplanar A B C X ->
  Coplanar A B C D -> Coplanar A B C E -> TS D E X Y ->
  TSP A B C X Y.

Lemma cop2_os__osp : forall A B C D E X Y, ~ Coplanar A B C X ->
  Coplanar A B C D -> Coplanar A B C E -> OS D E X Y ->
  OSP A B C X Y.

Lemma cop3_tsp__ts : forall A B C D E X Y, D <> E ->
  Coplanar A B C D -> Coplanar A B C E -> Coplanar D E X Y ->
  TSP A B C X Y -> TS D E X Y.

Lemma cop3_osp__os : forall A B C D E X Y, D <> E ->
  Coplanar A B C D -> Coplanar A B C E -> Coplanar D E X Y ->
  OSP A B C X Y -> OS D E X Y.

Lemma cop_tsp__ex_cop2 : forall A B C D E P,
  Coplanar A B C P -> TSP A B C D E ->
  exists Q, Coplanar A B C Q /\ Coplanar D E P Q /\ P <> Q.

Lemma cop_osp__ex_cop2 : forall A B C D E P,
  Coplanar A B C P -> OSP A B C D E ->
  exists Q, Coplanar A B C Q /\ Coplanar D E P Q /\ P <> Q.

End T9.

Hint Resolve l9_2 invert_two_sides invert_one_side one_side_symmetry l9_9 l9_9_bis
             l9_38 osp_symmetry osp__ntsp tsp__nosp : side.
Hint Resolve os__coplanar : cop.

Ltac Side := eauto with side.

Ltac not_exist_hyp_perm4 A B C D := first [not_exist_hyp_perm_ncol A B C|not_exist_hyp_perm_ncol A B D|not_exist_hyp_perm_ncol A C D|not_exist_hyp_perm_ncol B C D].

Ltac assert_ncols :=
repeat
  match goal with
      | H:OS ?A ?B ?X ?Y |- _ =>
     not_exist_hyp_perm_ncol A B X;assert (~ Col A B X) by (apply(one_side_not_col123 A B X Y);finish)

      | H:OS ?A ?B ?X ?Y |- _ =>
     not_exist_hyp_perm_ncol A B Y;assert (~ Col A B Y) by (apply(one_side_not_col124 A B X Y);finish)

      | H:TS ?A ?B ?X ?Y |- _ =>
     not_exist_hyp_perm_ncol A B X;assert (~ Col A B X) by (apply(two_sides_not_col A B X Y);finish)

      | H:TS ?A ?B ?X ?Y |- _ =>
     not_exist_hyp_perm_ncol A B Y;assert (~ Col A B Y) by (apply(two_sides_not_col A B Y X);finish)

      | H:~ Coplanar ?A ?B ?C ?D |- _ =>
      let h := fresh in
      not_exist_hyp_perm4 A B C D;
      assert (h := ncop__ncols A B C D H);decompose [and] h;clear h;clean_reap_hyps
  end. *)

Require Import NArith.

Require Import GeoCoq.Utils.sets.
(* GeoCoq.Utils.sets:
Require Export MSets.
Require Import Arith.
Require Import NArith.
Require Import Notations.
Require Import Sorting.
Require Import Coq.Program.Equality.
Require Export GeoCoq.Tactics.Coinc.tactics_axioms.

Module S := MSetList.Make PositiveOrderedTypeBits.

Module SWP := WPropertiesOn PositiveOrderedTypeBits S.

Module SetOfSetsOfPositiveOrderedType <: OrderedType.

  Definition t := S.t.

  Definition eq := S.Equal.

  Include IsEq.

  Definition eqb := S.equal.

  Definition eqb_eq := S.equal_spec.

  Include HasEqBool2Dec.

  Definition lt := S.lt.

  Definition compare := S.compare.

  Definition compare_spec := S.compare_spec.

End SetOfSetsOfPositiveOrderedType.

Module SS := MSetList.Make SetOfSetsOfPositiveOrderedType.

Definition fstpp (pair : (positive * positive)) :=
  match pair with
    |(a,b) => Pos.min a b
  end.

Definition sndpp (pair : (positive * positive)) :=
  match pair with
    |(a,b) => Pos.max a b
  end.

Module SetOfPairsOfPositiveOrderedType <: OrderedType.

  Definition t:= (positive * positive).

  Definition eq (t1 t2 : t) :=
    Pos.eq (fstpp(t1)) (fstpp(t2)) /\ Pos.eq (sndpp(t1)) (sndpp(t2)).

  Include IsEq.

  Definition eqb (t1 t2 : t) :=
    Pos.eqb (fstpp(t1)) (fstpp(t2)) && Pos.eqb (sndpp(t1)) (sndpp(t2)).

  Lemma eqb_eq : forall t1 t2, eqb t1 t2 = true <-> eq t1 t2.

  Include HasEqBool2Dec.

  Definition lt (t1 t2 : t) :=
    let ft1 := fstpp(t1) in
    let ft2 := fstpp(t2) in
    let st1 := sndpp(t1) in
    let st2 := sndpp(t2) in
    if Pos.eqb ft1 ft2 then Pos.lt st1 st2
                       else Pos.lt ft1 ft2.

  Lemma lt_irrefl : Irreflexive lt.

  Lemma lt_antiref : forall x, ~ lt x x.

  Lemma lt_trans : Transitive lt.

  Definition compare t1 t2 :=
    let ft1 := fstpp(t1) in
    let ft2 := fstpp(t2) in
    let st1 := sndpp(t1) in
    let st2 := sndpp(t2) in
    match (Pos.compare ft1 ft2) with
      | Lt => Lt
      | Eq => Pos.compare st1 st2
      | Gt => Gt
    end.

  Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).

End SetOfPairsOfPositiveOrderedType.

Module SP := MSetList.Make SetOfPairsOfPositiveOrderedType.

Module PosOrder <: TotalLeBool.

  Definition t := positive.

  Definition leb := Pos.leb.

  Lemma leb_total : forall p1 p2,
    leb p1 p2 = true \/ leb p2 p1 = true.

  Lemma leb_dec : forall p1 p2,
    leb p1 p2 = true \/ leb p1 p2 = false.

End PosOrder.

Module Import PosSort := Sort PosOrder.

Definition OCPAux {n : nat} (cp : cartesianPower positive (S (S n))) := (PosSort.sort (CPToList cp)).

Lemma OCPALengthOK {n : nat} : forall (cp : cartesianPower positive (S (S n))), (length (OCPAux cp)) = (S (S n)).

Lemma OCPSortedTl :
  forall (l : list positive),
  StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l ->
  StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) (tl l).

Lemma PermSorted : forall (l l' : list positive),
  Permutation.Permutation l l' ->

Definition OCP {n : nat} (cp : cartesianPower positive (S (S n))) : cartesianPower positive (S (S n)).

Lemma OCPSortedAux {n : nat} :
  forall (cp : cartesianPower positive (S (S n))),
  StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) (CPToList (OCP cp)).

Lemma OCPPerm {n : nat} :
  forall (cp : cartesianPower positive (S (S n))),
  Permutation.Permutation (CPToList cp) (CPToList (OCP cp)).

Lemma CPLOCPTlOK {n : nat} :
  forall (cp : cartesianPower positive (S (S (S n)))),
  headCP cp = headCP (OCP cp) ->
  CPToList (OCP (tailCP cp)) = CPToList (tailCP (OCP cp)).

Lemma OCPTlOK {n : nat} :
  forall (cp : cartesianPower positive (S (S (S n)))),
  headCP cp = headCP (OCP cp) ->
  OCP (tailCP cp) = tailCP (OCP cp).

Lemma InCPOCP {n : nat} : forall p (cp : cartesianPower positive (S (S n))),
  InCP p cp <-> InCP p (OCP cp).

Section Set_of_tuple_of_positive.

  Context {Ar : Arity}.

  Fixpoint eqList (l1 l2 : list positive) :=
    match l1, l2 with
      | nil, nil => True
      | (hd1 :: tl1), (hd2 :: tl2) => (Pos.eq hd1 hd2) /\ (eqList tl1 tl2)
      | _, _ => False
    end.

  Lemma eqListRefl : forall l, eqList l l.

  Lemma eqListSym : forall l l', eqList l l' -> eqList l' l.

  Lemma eqListTrans : forall l1 l2 l3, eqList l1 l2 -> eqList l2 l3 -> eqList l1 l3.

  Definition tST := cartesianPower positive (S (S n)).

  Definition eqST (cp1 cp2 : tST) :=
    eqList (PosSort.sort (CPToList cp1)) (PosSort.sort (CPToList cp2)).

  Lemma eqListSortOCP : forall (cp : tST), eqList (CPToList (OCP cp)) (PosSort.sort (CPToList cp)).

  Fixpoint eqbList (l1 l2 : list positive) :=
    match l1, l2 with
      | nil         , nil          => true
      | (hd1 :: tl1), (hd2 :: tl2) => (Pos.eqb hd1 hd2) && (eqbList tl1 tl2)
      | _           , _            => false
    end.

  Lemma eqbListEqList : forall l1 l2, eqbList l1 l2 = true <-> eqList l1 l2.

  Definition eqbST (cp1 cp2 : tST) :=
    eqbList (PosSort.sort (CPToList cp1)) (PosSort.sort (CPToList cp2)).

  Lemma eqbST_eqST : forall cp1 cp2, eqbST cp1 cp2 = true <-> eqST cp1 cp2.

  Fixpoint ltList (l1 l2 : list positive) :=
    match l1, l2 with
      | nil, nil => False
      | (hd1 :: tl1), (hd2 :: tl2) => if (Pos.ltb hd1 hd2) then True
                                      else if (Pos.ltb hd2 hd1) then False
                                           else (ltList tl1 tl2)
      | nil, _ => True
      | _, nil => False
    end.

  Lemma lengthOne : forall (l : list positive),
    length l = 1 -> exists a, l = a :: nil.

  Lemma lengthAtLeastOne : forall (l : list positive) n,
    length l = (S n) -> exists a0 l0, l = a0 :: l0.

  Lemma ltListTrans : forall m x y z,
    length x = (S m) ->
    length y = (S m) ->
    length z = (S m) ->
    ltList x y -> ltList y z -> ltList x z.

  Lemma sortOK : forall m l, length l = m -> length (sort l) = m.

  Definition ltST (cp1 cp2 : tST) :=
    ltList (PosSort.sort (CPToList cp1)) (PosSort.sort (CPToList cp2)).

  Lemma ltTrans : Transitive ltST.

  Lemma ltListIrrefl : forall l, ltList l l -> False.

  Lemma eqListOK : forall l1 l2, eqList l1 l2 -> l1 = l2.

  Fixpoint compareList (l1 l2 : list positive) :=
    match l1, l2 with
    | nil, nil => Eq
    | (hd1 :: tl1), (hd2 :: tl2) => match Pos.compare hd1 hd2 with
                                    | Lt => Lt
                                    | Eq => compareList tl1 tl2
                                    | Gt => Gt
                                    end
    | nil, _ => Lt
    | _, nil => Gt
    end.

  Lemma compareListSpec : forall l1 l2,
    CompSpec eqList ltList l1 l2 (compareList l1 l2).

  Definition compareST (cp1 cp2 : tST) :=
    compareList (PosSort.sort (CPToList cp1)) (PosSort.sort (CPToList cp2)).

  Lemma compare_spec : forall cp1 cp2,
    CompSpec eqST ltST cp1 cp2 (compareST cp1 cp2).

  Definition STelt := tST.

  Definition STt := list tST.

  Definition STempty : STt := nil.

  Lemma eqST_dec : forall x y, {eqST x y} + {~ eqST x y}.

  Definition STadd (x : STelt) (s : STt) := cons x s.

  Fixpoint STexists_ (f : STelt -> bool) (s : STt) :=
    match s with
      | nil      => false
      | hd :: tl => f hd || STexists_ f tl
    end.

  Fixpoint STmem elt l :=
    match l with
      | nil      => false
      | hd :: tl => if eqST_dec hd elt then true else STmem elt tl
    end.

  Lemma STempty_b : forall y : STelt, STmem y STempty = false.

  Lemma STexists_mem_4 :
    forall f (s : STt),
      STexists_ f s = true ->
      exists x : STelt ,  STmem x s = true /\ f x = true.

  Lemma STadd_iff : forall (s : STt) (x y : STelt),
    STmem y (STadd x s) = true <-> (eqST x y \/ STmem y s = true).

End Set_of_tuple_of_positive. *)

Require Import GeoCoq.Meta_theory.Models.tarski_to_coinc_theory_for_cop.
(* GeoCoq.Meta_theory.Models.tarski_to_coinc_theory_for_cop:
Require Import GeoCoq.Tarski_dev.Ch09_plane.
Require Import GeoCoq.Tactics.Coinc.tactics_axioms.

Section Tarski_is_a_Coinc_theory_for_cop.

Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.

Definition not_col : arity Tpoint 3 := fun A B C : Tpoint => ~ Col A B C.

Lemma not_col_perm_1 : forall A X, app_1_n not_col A X -> app_n_1 not_col X A.

Lemma not_col_perm_2 : forall A B (X : cartesianPower Tpoint 1),
  app_2_n not_col A B X -> app_2_n not_col B A X.

Definition cop : arity Tpoint 4 := Coplanar.

Lemma cop_perm_1 : forall A (X : cartesianPower Tpoint 3), app_1_n cop A X -> app_n_1 cop X A.

Lemma cop_perm_2 : forall A B (X : cartesianPower Tpoint 2), app_2_n cop A B X -> app_2_n cop B A X.

Lemma cop_bd : forall A (X : cartesianPower Tpoint 2), app_2_n cop A A X.

Lemma cop_3 : forall (COP : cartesianPower Tpoint 4) (NOT_COL : cartesianPower Tpoint 3),
  pred_conj cop COP NOT_COL -> app not_col NOT_COL -> app cop COP.

Global Instance Tarski_is_a_Arity_for_cop : Arity.

Global Instance Tarski_is_a_Coinc_predicates_for_cop :
  (Coinc_predicates Tarski_is_a_Arity_for_cop).

Global Instance Tarski_is_a_Coinc_theory_for_cop :   (Coinc_theory Tarski_is_a_Arity_for_cop Tarski_is_a_Coinc_predicates_for_cop).

End Tarski_is_a_Coinc_theory_for_cop. *)

Require Import GeoCoq.Tactics.Coinc.CoincR.
(* GeoCoq.Tactics.Coinc.CoincR:
Require Import Recdef.
Require Import NArith.
Require Import Sorting.
Require Import GeoCoq.Tactics.Coinc.Permutations.
Require Import GeoCoq.Utils.general_tactics.
Require Import GeoCoq.Utils.sets.

Module SSWP := WPropertiesOn SetOfSetsOfPositiveOrderedType SS.

Module SSWEqP := WEqPropertiesOn SetOfSetsOfPositiveOrderedType SS.

Module Import PosSort := Sort PosOrder.

Section Coinc_refl.

Context {AR : Arity}.

Definition pick_variety_auxCP {m : nat} (s : SS.elt) (cp : cartesianPower positive (S (S m))) : bool.

Definition pick_variety_aux (s : SS.elt) (t : tST) := pick_variety_auxCP s t.

Lemma pick_variety_auxCP_forallT {m : nat} :
  forall s (cp : cartesianPower positive (S (S m))),
  pick_variety_auxCP s cp = true <-> (forall p, InCP p cp -> S.mem p s = true).

Lemma pick_variety_auxCP_existsF {m : nat} :
  forall s (cp : cartesianPower positive (S (S m))),
  pick_variety_auxCP s cp = false <-> (exists p, InCP p cp /\ S.mem p s = false).

Lemma proper_00 :
  forall s,
  Proper
  ((fun (t1 t2 : tST) =>
     eqST t1 t2) ==> eq)
  (fun t : tST => pick_variety_aux s t).

Definition pick_variety (s : SS.elt) (st : STt) :=
  STexists_ (fun t => pick_variety_aux s t) st.

Lemma proper_0 :
  Proper (S.Equal ==> eq ==> eq) pick_variety.

Lemma proper_1 : forall s1 st,
  Proper (S.Equal ==> eq)

Definition exists_witness (f : SS.elt -> bool) (s : SS.t) : option SS.elt :=
  SS.choose (SS.filter f s).

Lemma exists_witness_ok : forall e f s,
  Proper (S.Equal ==> eq) f ->

Definition pick_varieties_aux (s1 : SS.elt) (ss : SS.t) (st : STt)
                              : (option (SS.elt * SS.elt)) :=
  match ((exists_witness (fun s2 => let i := S.inter s1 s2 in
                                    pick_variety i st)) ss) with
    | None => None
    | Some s2 => Some(s1,s2)
  end.

Definition pick_varieties (ss : SS.t) (st : STt)
                          : (option (SS.elt * SS.elt)) :=
  match (exists_witness (fun s =>
                           match (pick_varieties_aux s (SS.remove s ss) st) with
                             | None => false
                             | _ => true
                           end) ss) with
    | None => None
    | Some s1 => pick_varieties_aux s1 (SS.remove s1 ss) st
  end.

Definition eqop (p1 p2 : option SS.elt) :=
  match p1,p2 with
    | None, None => True
    | Some s1, Some s2 => True
    | _, _ => False
  end.

Lemma proper_2 : forall (f1 f2 : SS.elt -> bool) (s1 s2 : SS.t),

Definition eqopp (p1 p2 : option (SS.elt * SS.elt)) :=
  match p1,p2 with
    | None, None => True
    | Some s1, Some s2 => True
    | _, _ => False
  end.

Lemma proper_3 : Proper (S.Equal ==> SS.Equal ==> eq ==> eqopp) pick_varieties_aux.

Lemma pick_varieties_ok_1 : forall s1 s2 ss st,
  pick_varieties ss st = Some(s1,s2) ->
  SS.In s1 ss.

Lemma pick_varieties_ok_2 : forall s1 s2 ss st,
  pick_varieties ss st = Some(s1,s2) ->
  SS.In s2 (SS.remove s1 ss).

Definition memCPAux m (cp : cartesianPower positive (S (S m))) (s : SS.elt) : bool.

Lemma memCPAuxHdTl : forall m cp s,
  memCPAux (S m) cp s = S.mem (fst cp) s && memCPAux m (tailCP cp) s.

Lemma memCPAuxProperOK : forall m, Proper (eq ==> S.Equal==> eq) (memCPAux m).

Lemma memCPAuxOK : forall m cp s e,
  memCPAux m cp s = true -> InCP e cp -> S.mem e s = true.

Lemma memMemCPAuxOK : forall m cp s,
  (forall e, InCP e cp -> S.mem e s = true) -> memCPAux m cp s = true.

Lemma memCPAuxTlOK : forall m cp s,
  memCPAux (S m) cp s = true ->
  memCPAux m (tailCP cp) s = true.

Definition memCP (cp : cartesianPower positive (S (S (S n)))) (s : SS.elt) := memCPAux (S n) cp s.

Lemma memCPProper : Proper (eq ==> S.Equal==> eq) memCP.

Lemma memMemCPOK : forall cp s,
  (forall e, InCP e cp -> S.mem e s = true) -> memCP cp s = true.

Lemma memCPConsHd : forall p s x,
  S.mem p s = true ->

Definition test_coinc (ss : SS.t) (st : STt) (cp : cartesianPower positive (S (S (S n)))) : bool :=
  let newss := identify_varieties ss st  in
    SS.exists_ (fun s => memCP cp s) newss.

Lemma pick_variety_aux_memCPAux1 : forall s1 s2 m (cp : cartesianPower positive (S (S m))),
  pick_variety_auxCP (S.inter s1 s2) cp = true ->

Lemma pick_variety_aux_memCPAux2 : forall s1 s2 m (cp : cartesianPower positive (S (S m))),
  pick_variety_auxCP (S.inter s1 s2) cp = true ->

Definition interp_CP {m : nat} (cp : cartesianPower positive (S m)) (interp: positive -> COINCpoint) : cartesianPower COINCpoint (S m).

Lemma interp_CPHdOK {m : nat} : forall (cp : cartesianPower positive (S m)) interp,
  interp_CP (headCPbis cp) interp = headCP (interp_CP cp interp).

Lemma interp_CPTlOK {m : nat} : forall (cp : cartesianPower positive (S (S m))) interp,
  interp_CP (tailCP cp) interp = tailCP (interp_CP cp interp).

Lemma interp_CPOK {m : nat} : forall (cp : cartesianPower positive (S m)) (interp: positive -> COINCpoint),
  CPToList (interp_CP cp interp) = map interp (CPToList cp).

Context {COP : Coinc_predicates AR}.

Definition ss_ok (ss : SS.t) (interp: positive -> COINCpoint) :=
  forall s, SS.mem s ss = true ->
  forall cp, memCP cp s = true ->
    app coinc (interp_CP cp interp).

Lemma consHdInterpOK : forall (cp : cartesianPower positive 1) (x : tST) interp,
  consHeadCP (interp_CP cp interp) (interp_CP x interp) = interp_CP (consHeadCP cp x) interp.

Lemma ss_ok_inter_ok1 : forall ss interp s1 s2 x (p : cartesianPower positive 1),
  ss_ok ss interp ->
  SS.In s1 ss ->

Lemma ss_ok_inter_ok2 : forall ss interp s1 s2 x (p : cartesianPower positive 1),
  ss_ok ss interp ->
  SS.In s2 ss ->

Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp,
  ss_ok ss interp ->
  SS.In s1 ss ->

Definition st_ok (st : STt) (interp: positive -> COINCpoint) :=
  forall t, STmem t st = true -> app wd (interp_CP t interp).

Context {COT : Coinc_theory AR COP}.

Lemma identify_varieties_ok : forall ss st interp,
  ss_ok ss interp -> st_ok st interp ->
  ss_ok (identify_varieties ss st) interp.

Lemma test_coinc_ok : forall ss st interp cp,
  ss_ok ss interp -> st_ok st interp ->
  test_coinc ss st cp = true ->
  app coinc (interp_CP cp interp).

Lemma ss_ok_empty : forall interp,
  ss_ok SS.empty interp.

Lemma st_ok_empty : forall interp,
  st_ok STempty interp.

Definition CPToSS {m:nat} (cp : cartesianPower positive m) : SS.elt.

Lemma CPToSSHdTl {m:nat} : forall (cp : cartesianPower positive (S (S m))),
  CPToSS cp = S.add (headCP cp) (CPToSS (tailCP cp)).

Lemma memCPToSSOK {m : nat} : forall e (cp : cartesianPower positive (S m)),
  S.mem e (CPToSS cp) = true ->

Lemma CPToSSOKAux {m m' : nat} :
  forall (cp : cartesianPower positive (S (S m))) (cp' : cartesianPower positive (S (S m'))) e s,
  S.Equal (CPToSS cp) s ->

Lemma CPToSSOK : forall (cp cp' : cartesianPower positive (S (S (S n)))) s,
  S.Equal (CPToSS cp) s ->

Lemma CoappDupPerm {m : nat} :
  forall (cp : cartesianPower positive m),
  ~ List.NoDup (CPToList cp) ->

Lemma CoappDupAux {m : nat} :
  forall (cp : cartesianPower positive (S (S (S m)))),
  ~ List.NoDup (CPToList cp) ->

Lemma CoappDup : forall cp interp,
  ~ List.NoDup (CPToList cp) ->

Lemma collect_coincs :
forall cp ss interp,
  app coinc (interp_CP cp interp) ->
  ss_ok ss interp -> ss_ok (SS.add (CPToSS cp) ss) interp.

Lemma collect_wds :
  forall cp st interp,
  app wd (interp_CP cp interp) ->
  st_ok st interp -> st_ok (STadd cp st) interp.

Definition list_assoc_inv :=
  (fix list_assoc_inv_rec (A:Type) (B:Set)
                          (eq_dec:forall e1 e2:B, {e1 = e2} + {e1 <> e2})
                          (lst : list (prodT A B)) {struct lst} : B -> A -> A :=
  fun (key:B) (default:A) =>
    match lst with
      | nil => default
      | cons (pairT v e) l =>
        match eq_dec e key with
          | left _ => v
          | right _ => list_assoc_inv_rec A B eq_dec l key default
        end
    end).

Lemma positive_dec : forall (p1 p2:positive), {p1=p2}+{~p1=p2}.

Definition interp (lvar : list (COINCpoint * positive)) (Default : COINCpoint) : positive -> COINCpoint := 
  fun p => list_assoc_inv COINCpoint positive positive_dec lvar p Default.

End Coinc_refl.

Ltac add_to_distinct_list x xs :=
  match xs with
    | nil     => constr:(x::xs)
    | x::_    => fail 1
    | ?y::?ys => let zs := add_to_distinct_list x ys in constr:(y::zs)
  end.

Ltac collect_points_list Tpoint xs :=
  match goal with
    | N : Tpoint |- _ => let ys := add_to_distinct_list N xs in
                           collect_points_list Tpoint ys
    | _               => xs
  end.

Ltac collect_points Tpoint := collect_points_list Tpoint (@nil Tpoint).

Ltac number_aux Tpoint lvar cpt :=
  match constr:(lvar) with
    | nil          => constr:(@nil (prodT Tpoint positive))
    | cons ?H ?T => let scpt := eval vm_compute in (Pos.succ cpt) in
                    let lvar2 := number_aux Tpoint T scpt in
                      constr:(cons (@pairT  Tpoint positive H cpt) lvar2)
  end.

Ltac number Tpoint lvar := number_aux Tpoint lvar (1%positive).

Ltac build_numbered_points_list Tpoint := let lvar := collect_points Tpoint in number Tpoint lvar.

Ltac List_assoc Tpoint elt lst :=
  match constr:(lst) with
    | nil => fail
    | (cons (@pairT Tpoint positive ?X1 ?X2) ?X3) =>
      match constr:(elt = X1) with
        | (?X1 = ?X1) => constr:(X2)
        | _ => List_assoc Tpoint elt X3
      end
  end.

Definition Tagged P : Prop := P.

Lemma PropToTagged : forall P : Prop, P -> Tagged P. *)



Section CoincR_for_cop.



Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.



Definition ss_ok_for_cop ss interp :=

  @ss_ok Tarski_is_a_Arity_for_cop

         Tarski_is_a_Coinc_predicates_for_cop ss interp.



Lemma ss_ok_empty_for_cop : forall interp, ss_ok_for_cop SS.empty interp.

Proof. exact ss_ok_empty. Qed.



Lemma collect_coincs_for_cop : forall A B C D pa pb pc pd ss interp,

  Coplanar A B C D ->

  interp pa = A ->

  interp pb = B ->

  interp pc = C ->

  interp pd = D ->

  ss_ok_for_cop ss interp ->

  ss_ok_for_cop (SS.add (@CPToSS 4 (pa, (pb, (pc, pd)))) ss) interp.

Proof.

intros A B C D pa pb pc pd ss interp HCol HA HB HC HD HSS.

apply (@collect_coincs Tarski_is_a_Arity_for_cop

                       Tarski_is_a_Coinc_predicates_for_cop);

[apply Tarski_is_a_Coinc_theory_for_cop|simpl|auto].

rewrite HA; rewrite HB; rewrite HC; rewrite HD; auto.

Qed.



Definition st_ok_for_cop st interp :=

  @st_ok Tarski_is_a_Arity_for_cop

         Tarski_is_a_Coinc_predicates_for_cop st interp.



Lemma st_ok_empty_for_cop : forall interp, st_ok_for_cop STempty interp.

Proof. exact st_ok_empty. Qed.



Lemma collect_wds_for_cop : forall A B C pa pb pc st interp,

  ~ Col A B C ->

  interp pa = A ->

  interp pb = B ->

  interp pc = C ->

  st_ok_for_cop st interp ->

  st_ok_for_cop (STadd (pa, (pb, pc)) st) interp.

Proof.

intros A B C pa pb pc st interp HDiff HA HB HC HST.

apply (@collect_wds Tarski_is_a_Arity_for_cop

                    Tarski_is_a_Coinc_predicates_for_cop);

[apply Tarski_is_a_Coinc_theory_for_cop|simpl|auto].

rewrite HA; rewrite HB; rewrite HC; auto.

Qed.



Definition test_coinc_for_cop ss st (pa pb pc pd : positive) :=

  @test_coinc Tarski_is_a_Arity_for_cop ss st (pa, (pb, (pc, pd))).



Definition interp_CP_for_cop (pa pb pc pd : positive) interp :=

  @interp_CP Tarski_is_a_Arity_for_cop 3 (pa, (pb, (pc, pd))) interp.



Lemma test_coinc_ok_for_cop : forall pa pb pc pd ss st interp,

  ss_ok_for_cop ss interp ->

  st_ok_for_cop st interp ->

  test_coinc_for_cop ss st pa pb pc pd = true ->

  Coplanar (interp pa) (interp pb) (interp pc) (interp pd).

Proof.

intros pa pb pc pd ss st interp HSS HST HTest.

assert (HCop := @test_coinc_ok Tarski_is_a_Arity_for_cop

                               Tarski_is_a_Coinc_predicates_for_cop

                               Tarski_is_a_Coinc_theory_for_cop

                               ss st interp (pa, (pb, (pc, pd))) HSS HST HTest).

simpl in HCop; auto.

Qed.



End CoincR_for_cop.



Ltac assert_ss_ok Tpoint Cop lvar :=

  repeat

  match goal with

    | HCop : Cop ?A ?B ?C ?D, HOK : ss_ok_for_cop ?SS ?Interp |- _ =>

      let pa := List_assoc Tpoint A lvar in

      let pb := List_assoc Tpoint B lvar in

      let pc := List_assoc Tpoint C lvar in

      let pd := List_assoc Tpoint D lvar in

      apply PropToTagged in HCop;

      apply (collect_coincs_for_cop A B C D pa pb pc pd SS Interp HCop) in HOK;

      try reflexivity

  end.



Ltac assert_st_ok Tpoint Col lvar :=

  repeat

  match goal with

    | HNCol : ~ Col ?A ?B ?C, HOK : st_ok_for_cop ?ST ?Interp |- _ =>

      let pa := List_assoc Tpoint A lvar in

      let pb := List_assoc Tpoint B lvar in

      let pc := List_assoc Tpoint C lvar in

      apply PropToTagged in HNCol;

      apply (collect_wds_for_cop A B C pa pb pc ST Interp HNCol) in HOK;

      try reflexivity

  end.



Ltac Cop_refl Tpoint Col Cop :=

  match goal with

    | Default : Tpoint |- Cop ?A ?B ?C ?D =>

      let lvar := build_numbered_points_list Tpoint in

      let pa := List_assoc Tpoint A lvar in

      let pb := List_assoc Tpoint B lvar in

      let pc := List_assoc Tpoint C lvar in

      let pd := List_assoc Tpoint D lvar in

      let c := ((vm_compute;reflexivity) || fail 2 "Can not be deduced") in

      let HSS := fresh in

      assert (HSS := ss_ok_empty_for_cop (interp lvar Default));

      assert_ss_ok Tpoint Cop lvar;

      let HST := fresh in

      assert (HST := st_ok_empty_for_cop (interp lvar Default));

      assert_st_ok Tpoint Col lvar;

      match goal with

        | HOKSS : ss_ok_for_cop ?SS ?Interp, HOKST : st_ok_for_cop ?ST ?Interp |- _ =>

          apply (test_coinc_ok_for_cop pa pb pc pd SS ST

                                       Interp HOKSS HOKST); c

      end

  end.



