Require Import GeoCoq.Axioms.continuity_axioms.
(* GeoCoq.Axioms.continuity_axioms:
Require Import GeoCoq.Tarski_dev.Definitions.

Section Continuity_Defs.

Context `{Tn:Tarski_neutral_dimensionless}.

Definition segment_circle := forall A B P Q,
  InCircle P A B ->
  OutCircle Q A B ->
  exists Z, Bet P Z Q /\ OnCircle Z A B.

Definition one_point_line_circle := forall A B U V P,
  Col U V P -> U <> V -> Bet A P B ->
  exists Z, Col U V Z /\ OnCircle Z A B.

Definition two_points_line_circle := forall A B U V P,
  Col U V P -> U <> V -> Bet A P B ->
  exists Z1 Z2, Col U V Z1 /\ OnCircle Z1 A B /\
                Col U V Z2 /\ OnCircle Z2 A B /\
                Bet Z1 P Z2 /\ (P <> B -> Z1 <> Z2).

Definition circle_circle := forall A B C D P Q,
  OnCircle P C D ->
  OnCircle Q C D ->
  InCircle P A B ->
  OutCircle Q A B ->
  exists Z, OnCircle Z A B /\ OnCircle Z C D.

Definition circle_circle_bis := forall A B C D P Q,
  OnCircle P C D ->
  InCircle P A B ->
  OnCircle Q A B ->
  InCircle Q C D ->
  exists Z, OnCircle Z A B /\ OnCircle Z C D.

Definition circle_circle_axiom := forall A B C D B' D',
  Cong A B' A B -> Cong C D' C D ->
  Bet A D' B -> Bet C B' D ->
  exists Z, Cong A Z A B /\ Cong C Z C D.

Definition circle_circle_two := forall A B C D P Q,
  OnCircle P C D ->
  OnCircle Q C D ->
  InCircle P A B ->
  OutCircle Q A B ->
  exists Z1 Z2,
    OnCircle Z1 A B /\ OnCircle Z1 C D /\
    OnCircle Z2 A B /\ OnCircle Z2 C D /\
    (InCircleS P A B -> OutCircleS Q A B -> Z1<>Z2).

Definition euclid_s_prop_1_22 := forall A B C D E F A' B' C' D' E' F',
  SumS A B C D E' F' -> SumS A B E F C' D' -> SumS C D E F A' B' ->
  Le E F E' F' -> Le C D C' D' -> Le A B A' B' ->
  exists P Q R, Cong P Q A B /\ Cong P R C D /\ Cong Q R E F.

Definition Nested (A B:nat -> Tpoint -> Prop) :=
  (forall n, exists An, A n An) /\ (forall n, exists Bn, B n Bn) /\
  forall n An Am Bm Bn,
    A n An -> A (S n) Am -> B (S n) Bm -> B n Bn -> Bet An Am Bm /\ Bet Am Bm Bn /\ Am <> Bm.

Definition cantor_s_axiom := forall A B, Nested A B ->
  exists X, forall n An Bn, A n An -> B n Bn -> Bet An X Bn.

Definition dedekind_s_axiom := forall (Alpha Beta : Tpoint -> Prop),
  (exists A, forall X Y, Alpha X -> Beta Y -> Bet A X Y) ->
  (exists B, forall X Y, Alpha X -> Beta Y -> Bet X B Y).

Inductive FOF : Prop -> Prop :=
| eq_fof : forall A B:Tpoint, FOF (A = B)
| bet_fof : forall A B C, FOF (Bet A B C)
| cong_fof : forall A B C D, FOF (Cong A B C D)
| not_fof : forall P, FOF P -> FOF (~ P)
| and_fof : forall P Q, FOF P -> FOF Q -> FOF (P /\ Q)
| or_fof : forall P Q, FOF P -> FOF Q -> FOF (P \/ Q)
| implies_fof : forall P Q, FOF P -> FOF Q -> FOF (P -> Q)
| forall_fof : forall P, (forall (A:Tpoint), FOF (P A)) -> FOF (forall A, P A)
| exists_fof : forall P, (forall (A:Tpoint), FOF (P A)) -> FOF (exists A, P A).

Definition first_order_dedekind := forall Alpha Beta,
  (forall X, FOF (Alpha X)) -> (forall Y, FOF (Beta Y)) ->
  (exists A, forall X Y, Alpha X -> Beta Y -> Bet A X Y) ->
  (exists B, forall X Y, Alpha X -> Beta Y -> Bet X B Y).

Definition archimedes_axiom := forall A B C D, A <> B -> Reach A B C D.

Definition aristotle_s_axiom := forall P Q A B C,
  ~ Col A B C -> Acute A B C ->
  exists X Y, Out B A X /\ Out B C Y /\ Per B X Y /\ Lt P Q X Y.

Definition greenberg_s_axiom := forall P Q R A B C,
  ~ Col A B C ->
  Acute A B C -> Q <> R -> Per P Q R ->
  exists S, LtA P S Q A B C /\ Out Q S R.

End Continuity_Defs.

Section Completeness.

Context `{Tn:Tarski_neutral_dimensionless}.

Definition inj {T1 T2:Type} (f:T1->T2) := forall A B, f A = f B -> A = B.

Definition pres_bet {Tm: Tarski_neutral_dimensionless}
  (f : @Tpoint Tn -> @Tpoint Tm) := forall A B C, Bet A B C -> Bet (f A) (f B) (f C).

Definition pres_cong {Tm: Tarski_neutral_dimensionless}
  (f : @Tpoint Tn -> @Tpoint Tm) := forall A B C D, Cong A B C D -> Cong (f A) (f B) (f C) (f D).

Definition extension {Tm: Tarski_neutral_dimensionless} f := inj f /\ pres_bet f /\ pres_cong f.

Definition completeness_for_planes := forall (Tm: Tarski_neutral_dimensionless)
  (Tm2 : Tarski_neutral_dimensionless_with_decidable_point_equality Tm)
  (M : Tarski_2D Tm2)
  (f : @Tpoint Tn -> @Tpoint Tm),
  @archimedes_axiom Tm ->
  extension f ->
  forall A, exists B, f B = A.

Definition completeness_for_3d_spaces := forall (Tm: Tarski_neutral_dimensionless)
  (Tm2 : Tarski_neutral_dimensionless_with_decidable_point_equality Tm)
  (M : Tarski_3D Tm2)
  (f : @Tpoint Tn -> @Tpoint Tm),
  @archimedes_axiom Tm ->
  extension f ->
  forall A, exists B, f B = A.

Definition inj_line {T:Type} (f:Tpoint->T) P Q := forall A B, Col P Q A -> Col P Q B ->
  f A = f B -> A = B.

Definition pres_bet_line {Tm: Tarski_neutral_dimensionless}
  (f : @Tpoint Tn -> @Tpoint Tm) P Q := forall A B C, Col P Q A -> Col P Q B -> Col P Q C ->
  Bet A B C -> Bet (f A) (f B) (f C).

Definition pres_cong_line {Tm: Tarski_neutral_dimensionless}
  (f : @Tpoint Tn -> @Tpoint Tm) P Q := forall A B C D,
  Col P Q A -> Col P Q B -> Col P Q C -> Col P Q D ->
  Cong A B C D -> Cong (f A) (f B) (f C) (f D).

Definition line_extension {Tm: Tarski_neutral_dimensionless} f P Q :=
  P <> Q /\ inj_line f P Q /\ pres_bet_line f P Q /\ pres_cong_line f P Q.

Definition line_completeness := forall (Tm: Tarski_neutral_dimensionless)
  (Tm2 : Tarski_neutral_dimensionless_with_decidable_point_equality Tm)
  P Q
  (f : @Tpoint Tn -> @Tpoint Tm),
  @archimedes_axiom Tm ->
  line_extension f P Q ->
  forall A, Col (f P) (f Q) A -> exists B, Col P Q B /\ f B = A.

End Completeness. *)

Require Import GeoCoq.Meta_theory.Continuity.archimedes.
(* GeoCoq.Meta_theory.Continuity.archimedes:
Require Import GeoCoq.Axioms.continuity_axioms.
Require Import GeoCoq.Tarski_dev.Annexes.saccheri.
Require Import GeoCoq.Tarski_dev.Ch13_1.
Require Import GeoCoq.Meta_theory.Continuity.grad.

Section Archimedes.

Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.

Lemma t22_18_aux1 : forall A0 A1 E0 E1 D1 D,
  Bet A0 D1 A1 -> Cong E0 E1 A1 D1 ->
  Grad A0 D1 D ->
  exists A E, Grad2 A0 A1 A E0 E1 E /\ Cong E0 E A D /\ Bet A0 D A.

Lemma t22_18_aux2 : forall A0 A1 B0 B1 A B E,
  Saccheri A0 B0 B1 A1 ->
  Grad2 A0 A1 A B0 B1 E -> Saccheri A0 B0 B A -> Le B0 B B0 E.

Lemma t22_18 :
  archimedes_axiom ->
  forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.

Lemma t22_19 :
  archimedes_axiom ->
  forall A B C D, Saccheri A B C D -> ~ Obtuse A B C.

Lemma archi__obtuse_case_elimination :
  archimedes_axiom ->
  ~ hypothesis_of_obtuse_saccheri_quadrilaterals.

Lemma t22_23_aux :
  forall A B C M N L,
    ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B ->
    Per M N A -> Col A C N ->
    Midpoint M N L -> Bet A N C /\ Lambert N L B C /\ Cong B L A N.

Lemma t22_23 :
  ~ hypothesis_of_obtuse_saccheri_quadrilaterals ->
  forall A B C M N L,
    ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B ->
    Per M N A -> Col A C N -> Midpoint M N L ->
    Bet A N C /\ Le N C A N /\ Le L N B C.

Lemma t22_24_aux :
  ~ hypothesis_of_obtuse_saccheri_quadrilaterals ->
  forall A B0 B00 C0 B C E,
    ~ Col A B0 C0 -> Perp A C0 B0 C0 -> B0 = B00 ->
    GradExp2 A B0 B B00 C0 E -> Perp A C0 B C -> Col A C0 C ->
    Le B0 E B C.

Lemma t22_24_aux1 : forall A B0 C0 E,
  ~ Col A B0 C0 -> Perp A C0 B0 C0 -> GradExp B0 C0 E ->
  exists B C, GradExp2 A B0 B B0 C0 E /\ Perp A C0 B C /\ Col A C0 C.

Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.

End Archimedes. *)

Require Import GeoCoq.Tarski_dev.Annexes.suma.
(* GeoCoq.Tarski_dev.Annexes.suma:
Require Export GeoCoq.Tarski_dev.Ch11_angles.

Section Suma_1.

Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.

Lemma suma_distincts : forall A B C D E F G H I, SumA A B C D E F G H I ->
   A<>B /\ B<>C /\ D<>E /\ E<>F /\ G<>H /\ H<>I.

Lemma trisuma_distincts : forall A B C D E F, TriSumA A B C D E F ->
  A <> B /\ B <> C /\ A <> C /\ D <> E /\ E <> F.

Lemma ex_suma : forall A B C D E F, A<>B -> B<>C -> D<>E -> E<>F ->
   exists G H I, SumA A B C D E F G H I.

Lemma suma2__conga : forall A B C D E F G H I G' H' I',
   SumA A B C D E F G H I -> SumA A B C D E F G' H' I' -> CongA G H I G' H' I'.

Lemma suma_sym : forall A B C D E F G H I, SumA A B C D E F G H I -> SumA D E F A B C G H I.

Lemma conga3_suma__suma : forall A B C D E F G H I A' B' C' D' E' F' G' H' I',
   SumA A B C D E F G H I ->
   CongA A B C A' B' C' ->
   CongA D E F D' E' F' ->
   CongA G H I G' H' I' ->
   SumA A' B' C' D' E' F' G' H' I'.

Lemma out6_suma__suma : forall A B C D E F G H I A' C' D' F' G' I',
   SumA A B C D E F G H I -> Out B A A' -> Out B C C' -> Out E D D' ->
   Out E F F' -> Out H G G' -> Out H I I' -> SumA A' B C' D' E F' G' H I'.

Lemma out546_suma__conga : forall A B C D E F G H I, SumA A B C D E F G H I ->
   Out E D F -> CongA A B C G H I.

Lemma out546__suma : forall A B C D E F, A <> B -> B <> C -> Out E D F -> SumA A B C D E F A B C.

Lemma out213_suma__conga : forall A B C D E F G H I, SumA A B C D E F G H I ->
   Out B A C -> CongA D E F G H I.

Lemma out213__suma : forall A B C D E F, D <> E -> E <> F -> Out B A C -> SumA A B C D E F D E F.

Lemma suma_left_comm : forall A B C D E F G H I,
   SumA A B C D E F G H I -> SumA C B A D E F G H I.

Lemma suma_middle_comm : forall A B C D E F G H I,
   SumA A B C D E F G H I -> SumA A B C F E D G H I.

Lemma suma_right_comm : forall A B C D E F G H I,
   SumA A B C D E F G H I -> SumA A B C D E F I H G.

Lemma suma_comm : forall A B C D E F G H I,
   SumA A B C D E F G H I -> SumA C B A F E D I H G.

Lemma ts__suma : forall A B C D, TS A B C D -> SumA C B A A B D C B D.

Lemma inangle__suma : forall A B C P, InAngle P A B C -> SumA A B P P B C A B C.

Lemma bet__suma : forall A B C P, A <> B -> B <> C -> P <> B -> Bet A B C ->
  SumA A B P P B C A B C.

Lemma sams_chara : forall A B C D E F A', A<>B -> A'<>B -> Bet A B A' ->
   (SAMS A B C D E F <-> LeA D E F C B A').

Lemma sams_distincts : forall A B C D E F, SAMS A B C D E F ->
   A<>B /\ B<>C /\ D<>E /\ E<>F.

Lemma sams_sym : forall A B C D E F, SAMS A B C D E F ->
   SAMS D E F A B C.

Lemma sams_right_comm : forall A B C D E F, SAMS A B C D E F ->
   SAMS A B C F E D.

Lemma sams_left_comm : forall A B C D E F, SAMS A B C D E F ->
   SAMS C B A D E F.

Lemma sams_comm : forall A B C D E F, SAMS A B C D E F ->
   SAMS C B A F E D.

Lemma conga2_sams__sams : forall A B C D E F A' B' C' D' E' F',
   CongA A B C A' B' C' -> CongA D E F D' E' F' ->
   SAMS A B C D E F -> SAMS A' B' C' D' E' F'.

Lemma out546__sams : forall A B C D E F, A <> B -> B <> C -> Out E D F -> SAMS A B C D E F.

Lemma out213__sams : forall A B C D E F, D <> E -> E <> F -> Out B A C -> SAMS A B C D E F.

Lemma bet_suma__sams : forall A B C D E F G H I, SumA A B C D E F G H I -> Bet G H I ->
  SAMS A B C D E F.

Lemma bet__sams : forall A B C P, A <> B -> B <> C -> P <> B -> Bet A B C -> SAMS A B P P B C.

Lemma suppa__sams : forall A B C D E F, SuppA A B C D E F -> SAMS A B C D E F.

Lemma inangle__sams : forall A B C P, InAngle P A B C -> SAMS A B P P B C.

End Suma_1.

Ltac assert_diffs :=
repeat
 match goal with
      | H:(~Col ?X1 ?X2 ?X3) |- _ =>
      let h := fresh in
      not_exist_hyp3 X1 X2 X1 X3 X2 X3;
      assert (h := not_col_distincts X1 X2 X3 H);decompose [and] h;clear h;clean_reap_hyps

      | H:(~Bet ?X1 ?X2 ?X3) |- _ =>
      let h := fresh in
      not_exist_hyp2 X1 X2 X2 X3;
      assert (h := not_bet_distincts X1 X2 X3 H);decompose [and] h;clear h;clean_reap_hyps
      | H:Bet ?A ?B ?C, H2 : ?A <> ?B |-_ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= bet_neq12__neq A B C H H2);clean_reap_hyps
      | H:Bet ?A ?B ?C, H2 : ?B <> ?A |-_ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= bet_neq21__neq A B C H H2);clean_reap_hyps
      | H:Bet ?A ?B ?C, H2 : ?B <> ?C |-_ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= bet_neq23__neq A B C H H2);clean_reap_hyps
      | H:Bet ?A ?B ?C, H2 : ?C <> ?B |-_ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= bet_neq32__neq A B C H H2);clean_reap_hyps

      | H:Cong ?A ?B ?C ?D, H2 : ?A <> ?B |-_ =>
      let T:= fresh in (not_exist_hyp_comm C D);
        assert (T:= cong_diff A B C D H2 H);clean_reap_hyps
      | H:Cong ?A ?B ?C ?D, H2 : ?B <> ?A |-_ =>
      let T:= fresh in (not_exist_hyp_comm C D);
        assert (T:= cong_diff_2 A B C D H2 H);clean_reap_hyps
      | H:Cong ?A ?B ?C ?D, H2 : ?C <> ?D |-_ =>
      let T:= fresh in (not_exist_hyp_comm A B);
        assert (T:= cong_diff_3 A B C D H2 H);clean_reap_hyps
      | H:Cong ?A ?B ?C ?D, H2 : ?D <> ?C |-_ =>
      let T:= fresh in (not_exist_hyp_comm A B);
        assert (T:= cong_diff_4 A B C D H2 H);clean_reap_hyps

      | H:Le ?A ?B ?C ?D, H2 : ?A <> ?B |-_ =>
      let T:= fresh in (not_exist_hyp_comm C D);
        assert (T:= le_diff A B C D H2 H);clean_reap_hyps
      | H:Le ?A ?B ?C ?D, H2 : ?B <> ?A |-_ =>
      let T:= fresh in (not_exist_hyp_comm C D);
        assert (T:= le_diff A B C D (swap_diff B A H2) H);clean_reap_hyps
      | H:Lt ?A ?B ?C ?D |-_ =>
      let T:= fresh in (not_exist_hyp_comm C D);
        assert (T:= lt_diff A B C D H);clean_reap_hyps

      | H:Midpoint ?I ?A ?B, H2 : ?A<>?B |- _ =>
      let T:= fresh in (not_exist_hyp2 I B I A);
       assert (T:= midpoint_distinct_1 I A B H2 H);
       decompose [and] T;clear T;clean_reap_hyps
      | H:Midpoint ?I ?A ?B, H2 : ?B<>?A |- _ =>
      let T:= fresh in (not_exist_hyp2 I B I A);
       assert (T:= midpoint_distinct_1 I A B (swap_diff B A H2) H);
       decompose [and] T;clear T;clean_reap_hyps

      | H:Midpoint ?I ?A ?B, H2 : ?I<>?A |- _ =>
      let T:= fresh in (not_exist_hyp2 I B A B);
       assert (T:= midpoint_distinct_2 I A B H2 H);
       decompose [and] T;clear T;clean_reap_hyps
      | H:Midpoint ?I ?A ?B, H2 : ?A<>?I |- _ =>
      let T:= fresh in (not_exist_hyp2 I B A B);
       assert (T:= midpoint_distinct_2 I A B (swap_diff A I H2) H);
       decompose [and] T;clear T;clean_reap_hyps

      | H:Midpoint ?I ?A ?B, H2 : ?I<>?B |- _ =>
      let T:= fresh in (not_exist_hyp2 I A A B);
       assert (T:= midpoint_distinct_3 I A B H2 H);
       decompose [and] T;clear T;clean_reap_hyps
      | H:Midpoint ?I ?A ?B, H2 : ?B<>?I |- _ =>
      let T:= fresh in (not_exist_hyp2 I A A B);
       assert (T:= midpoint_distinct_3 I A B (swap_diff B I H2) H);
       decompose [and] T;clear T;clean_reap_hyps

      | H:Per ?A ?B ?C, H2 : ?A<>?B |- _ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= per_distinct A B C H H2); clean_reap_hyps
      | H:Per ?A ?B ?C, H2 : ?B<>?A |- _ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= per_distinct A B C H (swap_diff B A H2)); clean_reap_hyps
      | H:Per ?A ?B ?C, H2 : ?B<>?C |- _ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= per_distinct_1 A B C H H2); clean_reap_hyps
      | H:Per ?A ?B ?C, H2 : ?C<>?B |- _ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= per_distinct_1 A B C H (swap_diff C B H2)); clean_reap_hyps

      | H:Perp ?A ?B ?C ?D |- _ =>
      let T:= fresh in (not_exist_hyp2 A B C D);
       assert (T:= perp_distinct A B C D H);
       decompose [and] T;clear T;clean_reap_hyps
      | H:Perp_at ?X ?A ?B ?C ?D |- _ =>
      let T:= fresh in (not_exist_hyp2 A B C D);
       assert (T:= perp_in_distinct X A B C D H);
       decompose [and] T;clear T;clean_reap_hyps
      | H:Out ?A ?B ?C |- _ =>
      let T:= fresh in (not_exist_hyp2 A B A C);
       assert (T:= out_distinct A B C H);
       decompose [and] T;clear T;clean_reap_hyps

      | H:TS ?A ?B ?C ?D |- _ =>
      let h := fresh in
      not_exist_hyp6 A B A C A D B C B D C D;
      assert (h := ts_distincts A B C D H);decompose [and] h;clear h;clean_reap_hyps
      | H:OS ?A ?B ?C ?D |- _ =>
      let h := fresh in
      not_exist_hyp5 A B A C A D B C B D;
      assert (h := os_distincts A B C D H);decompose [and] h;clear h;clean_reap_hyps
      | H:~ Coplanar ?A ?B ?C ?D |- _ =>
      let h := fresh in
      not_exist_hyp6 A B A C A D B C B D C D;
      assert (h := ncop_distincts A B C D H);decompose [and] h;clear h;clean_reap_hyps

      | H:CongA ?A ?B ?C ?A' ?B' ?C' |- _ =>
      let T:= fresh in (not_exist_hyp_comm A B);
        assert (T:= conga_diff1 A B C A' B' C' H);clean_reap_hyps
      | H:CongA ?A ?B ?C ?A' ?B' ?C' |- _ =>
      let T:= fresh in (not_exist_hyp_comm B C);
        assert (T:= conga_diff2 A B C A' B' C' H);clean_reap_hyps
      | H:CongA ?A ?B ?C ?A' ?B' ?C' |- _ =>
      let T:= fresh in (not_exist_hyp_comm A' B');
        assert (T:= conga_diff45 A B C A' B' C' H);clean_reap_hyps
      | H:CongA ?A ?B ?C ?A' ?B' ?C' |- _ =>
      let T:= fresh in (not_exist_hyp_comm B' C');
        assert (T:= conga_diff56 A B C A' B' C' H);clean_reap_hyps

      | H:(Orth_at ?X ?A ?B ?C ?U ?V) |- _ =>
      let h := fresh in
      not_exist_hyp4 A B A C B C U V;
      assert (h := orth_at_distincts A B C U V X H);decompose [and] h;clear h;clean_reap_hyps
      | H:(Orth ?A ?B ?C ?U ?V) |- _ =>
      let h := fresh in
      not_exist_hyp4 A B A C B C U V;
      assert (h := orth_distincts A B C U V H);decompose [and] h;clear h;clean_reap_hyps

      | H:SumA ?A ?B ?C ?D ?E ?F ?G ?I ?J |- _ =>
      let h := fresh in
      not_exist_hyp6 A B B C D E E F G I I J;
      assert (h := suma_distincts A B C D E F G I J H);decompose [and] h;clear h;clean_reap_hyps
      | H: TriSumA ?A ?B ?C ?D ?E ?F |- _ =>
      let h := fresh in
      not_exist_hyp5 A B B C A C D E E F;
      assert (h := trisuma_distincts A B C D E F H);decompose [and] h;clear h; clean_reap_hyps
      | H:SAMS ?A ?B ?C ?D ?E ?F |- _ =>
      let h := fresh in
      not_exist_hyp4 A B B C D E E F;
      assert (h := sams_distincts A B C D E F H);decompose [and] h;clear h;clean_reap_hyps

      | H:(InAngle ?P ?A ?B ?C) |- _ =>
      let h := fresh in
      not_exist_hyp3 A B C B P B;
      assert (h := inangle_distincts A B C P H);decompose [and] h;clear h;clean_reap_hyps
      | H:LeA ?A ?B ?C ?D ?E ?F |- _ =>
      let h := fresh in
      not_exist_hyp4 A B B C D E E F;
      assert (h := lea_distincts A B C D E F H);decompose [and] h;clear h;clean_reap_hyps
      | H:LtA ?A ?B ?C ?D ?E ?F |- _ =>
      let h := fresh in
      not_exist_hyp4 A B B C D E E F;
      assert (h := lta_distincts A B C D E F H);decompose [and] h;clear h;clean_reap_hyps
      | H:(Acute ?A ?B ?C) |- _ =>
      let h := fresh in
      not_exist_hyp2 A B B C;
      assert (h := acute_distincts A B C H);decompose [and] h;clear h;clean_reap_hyps
      | H:(Obtuse ?A ?B ?C) |- _ =>
      let h := fresh in
      not_exist_hyp2 A B B C;
      assert (h := obtuse_distincts A B C H);decompose [and] h;clear h;clean_reap_hyps
      | H:SuppA ?A ?B ?C ?D ?E ?F |- _ =>
      let h := fresh in
      not_exist_hyp4 A B B C D E E F;
      assert (h := suppa_distincts A B C D E F H);decompose [and] h;clear h;clean_reap_hyps
 end.

Hint Resolve suma_sym suma_left_comm suma_middle_comm suma_right_comm
             suma_comm ts__suma inangle__suma bet__suma
             sams_right_comm sams_comm sams_left_comm sams_sym
             out213__sams out546__sams bet__sams suppa__sams inangle__sams : suma.

Ltac SumA := eauto with suma.

Section Suma_2.

Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.

Lemma sams_suma__lea123789 : forall A B C D E F G H I, SumA A B C D E F G H I ->
   SAMS A B C D E F -> LeA A B C G H I.

Lemma sams_suma__lea456789 : forall A B C D E F G H I, SumA A B C D E F G H I ->
   SAMS A B C D E F -> LeA D E F G H I.

Lemma sams_lea2__sams : forall A B C D E F A' B' C' D' E' F',
   SAMS A' B' C' D' E' F' -> LeA A B C A' B' C' -> LeA D E F D' E' F' ->
   SAMS A B C D E F.

Lemma sams_lea456_suma2__lea : forall A B C D E F G H I D' E' F' G' H' I',
   LeA D E F D' E' F' -> SAMS A B C D' E' F' -> SumA A B C D E F G H I ->
   SumA A B C D' E' F' G' H' I' -> LeA G H I G' H' I'.

Lemma sams_lea123_suma2__lea : forall A B C D E F G H I A' B' C' G' H' I',
   LeA A B C A' B' C' -> SAMS A' B' C' D E F -> SumA A B C D E F G H I ->
   SumA A' B' C' D E F G' H' I' -> LeA G H I G' H' I'.

Lemma sams_lea2_suma2__lea : forall A B C D E F G H I A' B' C' D' E' F' G' H' I',
   LeA A B C A' B' C' -> LeA D E F D' E' F' -> SAMS A' B' C' D' E' F' ->
   SumA A B C D E F G H I -> SumA A' B' C' D' E' F' G' H' I' -> LeA G H I G' H' I'.

Lemma sams2_suma2__conga456 : forall A B C D E F D' E' F' G H I,
   SAMS A B C D E F -> SAMS A B C D' E' F' ->
   SumA A B C D E F G H I -> SumA A B C D' E' F' G H I ->
   CongA D E F D' E' F'.

Lemma sams2_suma2__conga123 : forall A B C A' B' C' D E F G H I,
   SAMS A B C D E F -> SAMS A' B' C' D E F ->
   SumA A B C D E F G H I -> SumA A' B' C' D E F G H I ->
   CongA A B C A' B' C'.

Lemma suma_assoc_1 : forall A B C D E F G H I K L M A' B' C' D' E' F',
   SAMS A B C D E F -> SAMS D E F G H I ->
   SumA A B C D E F A' B' C' -> SumA D E F G H I D' E' F' ->
   SumA A' B' C' G H I K L M -> SumA A B C D' E' F' K L M.

Lemma suma_assoc_2 : forall A B C D E F G H I K L M A' B' C' D' E' F',
   SAMS A B C D E F -> SAMS D E F G H I ->
   SumA A B C D E F A' B' C' -> SumA D E F G H I D' E' F' ->
   SumA A B C D' E' F' K L M -> SumA A' B' C' G H I K L M.

Lemma suma_assoc : forall A B C D E F G H I K L M A' B' C' D' E' F',
   SAMS A B C D E F -> SAMS D E F G H I ->
   SumA A B C D E F A' B' C' -> SumA D E F G H I D' E' F' ->
   (SumA A' B' C' G H I K L M <-> SumA A B C D' E' F' K L M).

Lemma sams_assoc_1 : forall A B C D E F G H I A' B' C' D' E' F',
   SAMS A B C D E F -> SAMS D E F G H I ->
   SumA A B C D E F A' B' C' -> SumA D E F G H I D' E' F' ->
   SAMS A' B' C' G H I -> SAMS A B C D' E' F'.

Lemma sams_assoc_2 : forall A B C D E F G H I A' B' C' D' E' F',
   SAMS A B C D E F -> SAMS D E F G H I ->
   SumA A B C D E F A' B' C' -> SumA D E F G H I D' E' F' ->
   SAMS A B C D' E' F' -> SAMS A' B' C' G H I.

Lemma sams_assoc : forall A B C D E F G H I A' B' C' D' E' F',
   SAMS A B C D E F -> SAMS D E F G H I ->
   SumA A B C D E F A' B' C' -> SumA D E F G H I D' E' F' ->
   (SAMS A' B' C' G H I <-> SAMS A B C D' E' F').

Lemma sams_nos__nts : forall A B C J, SAMS A B C C B J -> ~ OS B C A J ->
  ~ TS A B C J.

Lemma conga_sams_nos__nts : forall A B C D E F J,
  SAMS A B C D E F -> CongA C B J D E F -> ~ OS B C A J -> ~ TS A B C J.

Lemma sams_lea2_suma2__conga123 : forall A B C D E F G H I A' B' C' D' E' F',
   LeA A B C A' B' C' -> LeA D E F D' E' F' -> SAMS A' B' C' D' E' F' ->
   SumA A B C D E F G H I -> SumA A' B' C' D' E' F' G H I -> CongA A B C A' B' C'.

Lemma sams_lea2_suma2__conga456 : forall A B C D E F G H I A' B' C' D' E' F',
   LeA A B C A' B' C' -> LeA D E F D' E' F' -> SAMS A' B' C' D' E' F' ->
   SumA A B C D E F G H I -> SumA A' B' C' D' E' F' G H I -> CongA D E F D' E' F'.

Lemma sams_suma__out213 : forall A B C D E F, SumA A B C D E F D E F -> SAMS A B C D E F -> Out B A C.

Lemma sams_suma__out546 : forall A B C D E F, SumA A B C D E F A B C -> SAMS A B C D E F -> Out E D F.

Lemma sams_lea_lta123_suma2__lta : forall A B C D E F G H I A' B' C' D' E' F' G' H' I',
   LtA A B C A' B' C' -> LeA D E F D' E' F' -> SAMS A' B' C' D' E' F' ->
   SumA A B C D E F G H I -> SumA A' B' C' D' E' F' G' H' I' -> LtA G H I G' H' I'.

Lemma sams_lea_lta456_suma2__lta : forall A B C D E F G H I A' B' C' D' E' F' G' H' I',
   LeA A B C A' B' C' -> LtA D E F D' E' F' -> SAMS A' B' C' D' E' F' ->
   SumA A B C D E F G H I -> SumA A' B' C' D' E' F' G' H' I' -> LtA G H I G' H' I'.

Lemma sams_lta2_suma2__lta : forall A B C D E F G H I A' B' C' D' E' F' G' H' I',
   LtA A B C A' B' C' -> LtA D E F D' E' F' -> SAMS A' B' C' D' E' F' ->
   SumA A B C D E F G H I -> SumA A' B' C' D' E' F' G' H' I' -> LtA G H I G' H' I'.

Lemma sams_lea2_suma2__lea123 : forall A B C D E F G H I A' B' C' D' E' F' G' H' I',
   LeA D' E' F' D E F -> LeA G H I G' H' I' -> SAMS A B C D E F ->
   SumA A B C D E F G H I -> SumA A' B' C' D' E' F' G' H' I' -> LeA A B C A' B' C'.

Lemma sams_lea2_suma2__lea456 : forall A B C D E F G H I A' B' C' D' E' F' G' H' I',
   LeA A' B' C' A B C -> LeA G H I G' H' I' -> SAMS A B C D E F ->
   SumA A B C D E F G H I -> SumA A' B' C' D' E' F' G' H' I' -> LeA D E F D' E' F'.

Lemma sams_lea_lta456_suma2__lta123 : forall A B C D E F G H I A' B' C' D' E' F' G' H' I',
   LtA D' E' F' D E F -> LeA G H I G' H' I' -> SAMS A B C D E F ->
   SumA A B C D E F G H I -> SumA A' B' C' D' E' F' G' H' I' -> LtA A B C A' B' C'.

Lemma sams_lea_lta123_suma2__lta456 : forall A B C D E F G H I A' B' C' D' E' F' G' H' I',
   LtA A' B' C' A B C -> LeA G H I G' H' I' -> SAMS A B C D E F ->
   SumA A B C D E F G H I -> SumA A' B' C' D' E' F' G' H' I' -> LtA D E F D' E' F'.

Lemma sams_lea_lta789_suma2__lta123 : forall A B C D E F G H I A' B' C' D' E' F' G' H' I',
   LeA D' E' F' D E F -> LtA G H I G' H' I' -> SAMS A B C D E F ->
   SumA A B C D E F G H I -> SumA A' B' C' D' E' F' G' H' I' -> LtA A B C A' B' C'.

Lemma sams_lea_lta789_suma2__lta456 : forall A B C D E F G H I A' B' C' D' E' F' G' H' I',
   LeA A' B' C' A B C -> LtA G H I G' H' I' -> SAMS A B C D E F ->
   SumA A B C D E F G H I -> SumA A' B' C' D' E' F' G' H' I' -> LtA D E F D' E' F'.

Lemma sams_lta2_suma2__lta123 : forall A B C D E F G H I A' B' C' D' E' F' G' H' I',
   LtA D' E' F' D E F -> LtA G H I G' H' I' -> SAMS A B C D E F ->
   SumA A B C D E F G H I -> SumA A' B' C' D' E' F' G' H' I' -> LtA A B C A' B' C'.

Lemma sams_lta2_suma2__lta456 : forall A B C D E F G H I A' B' C' D' E' F' G' H' I',
   LtA A' B' C' A B C -> LtA G H I G' H' I' -> SAMS A B C D E F ->
   SumA A B C D E F G H I -> SumA A' B' C' D' E' F' G' H' I' -> LtA D E F D' E' F'.

Lemma sams123231 : forall A B C, A <> B -> A <> C -> B <> C -> SAMS A B C B C A.

Lemma col_suma__col : forall A B C D E F, Col D E F -> SumA A B C B C A D E F -> Col A B C.

Lemma ncol_suma__ncol : forall A B C D E F, ~ Col A B C -> SumA A B C B C A D E F -> ~ Col D E F.

Lemma per2_suma__bet : forall A B C D E F G H I, Per A B C -> Per D E F ->
   SumA A B C D E F G H I -> Bet G H I.

Lemma bet_per2__suma : forall A B C D E F G H I,
   A <> B -> B <> C -> D <> E -> E <> F -> G <> H -> H <> I ->
   Per A B C -> Per D E F ->
   Bet G H I -> SumA A B C D E F G H I.

Lemma per2__sams : forall A B C D E F, A <> B -> B <> C -> D <> E -> E <> F ->
  Per A B C -> Per D E F -> SAMS A B C D E F.

Lemma bet_per_suma__per456 : forall A B C D E F G H I, Per A B C -> Bet G H I ->
   SumA A B C D E F G H I -> Per D E F.

Lemma bet_per_suma__per123 : forall A B C D E F G H I, Per D E F -> Bet G H I ->
   SumA A B C D E F G H I -> Per A B C.

Lemma bet_suma__per : forall A B C D E F, Bet D E F -> SumA A B C A B C D E F ->
   Per A B C.

Lemma acute__sams : forall A B C, Acute A B C -> SAMS A B C A B C.

Lemma acute_suma__nbet : forall A B C D E F, Acute A B C -> SumA A B C A B C D E F -> ~ Bet D E F.

Lemma acute2__sams : forall A B C D E F, Acute A B C -> Acute D E F -> SAMS A B C D E F.

Lemma acute2_suma__nbet : forall A B C D E F G H I,
  Acute A B C -> Acute D E F -> SumA A B C D E F G H I -> ~ Bet G H I.

Lemma acute_per__sams : forall A B C D E F, A <> B -> B <> C ->
  Per A B C -> Acute D E F -> SAMS A B C D E F.

Lemma acute_per_suma__nbet : forall A B C D E F G H I, A <> B -> B <> C ->
  Per A B C -> Acute D E F -> SumA A B C D E F G H I -> ~ Bet G H I.

Lemma obtuse__nsams : forall A B C, Obtuse A B C -> ~ SAMS A B C A B C.

Lemma nbet_sams_suma__acute : forall A B C D E F, ~ Bet D E F -> SAMS A B C A B C ->
   SumA A B C A B C D E F -> Acute A B C.

Lemma nsams__obtuse : forall A B C, A <> B -> B <> C -> ~ SAMS A B C A B C -> Obtuse A B C.

Lemma sams2_suma2__conga : forall A B C D E F A' B' C',
  SAMS A B C A B C -> SumA A B C A B C D E F ->
  SAMS A' B' C' A' B' C' -> SumA A' B' C' A' B' C' D E F ->
  CongA A B C A' B' C'.

Lemma acute2_suma2__conga : forall A B C D E F A' B' C',
  Acute A B C -> SumA A B C A B C D E F ->
  Acute A' B' C' -> SumA A' B' C' A' B' C' D E F ->
  CongA A B C A' B' C'.

Lemma bet2_suma__out : forall A B C D E F G H I, Bet A B C -> Bet D E F ->
  SumA A B C D E F G H I -> Out H G I.

Lemma col2_suma__col : forall A B C D E F G H I, Col A B C -> Col D E F ->
  SumA A B C D E F G H I -> Col G H I.

Lemma suma_suppa__bet : forall A B C D E F G H I,
  SuppA A B C D E F -> SumA A B C D E F G H I -> Bet G H I.

Lemma bet_suppa__suma : forall A B C D E F G H I, G <> H -> H <> I ->
  SuppA A B C D E F -> Bet G H I -> SumA A B C D E F G H I.

Lemma bet_suma__suppa : forall A B C D E F G H I,
  SumA A B C D E F G H I -> Bet G H I -> SuppA A B C D E F.

Lemma bet2_suma__suma : forall A B C D E F G H I A' D', A' <> B -> D' <> E ->
  Bet A B A' -> Bet D E D' -> SumA A B C D E F G H I -> SumA A' B C D' E F G H I.

Lemma suma_suppa2__suma : forall A B C D E F G H I A' B' C' D' E' F',
  SuppA A B C A' B' C' -> SuppA D E F D' E' F' -> SumA A B C D E F G H I ->
  SumA A' B' C' D' E' F' G H I.

Lemma suma2_obtuse2__conga : forall A B C D E F A' B' C',
  Obtuse A B C -> SumA A B C A B C D E F ->
  Obtuse A' B' C' -> SumA A' B' C' A' B' C' D E F ->
  CongA A B C A' B' C'.

Lemma bet_suma2__or_conga : forall A B C D E F A' B' C' A0, A0 <> B ->
  Bet A B A0 -> SumA A B C A B C D E F -> SumA A' B' C' A' B' C' D E F ->
  CongA A B C A' B' C' \/ CongA A0 B C A' B' C'.

Lemma suma2__or_conga_suppa : forall A B C A' B' C' D E F ,
  SumA A B C A B C D E F -> SumA A' B' C' A' B' C' D E F ->
  CongA A B C A' B' C' \/ SuppA A B C A' B' C'.

Lemma ex_trisuma : forall A B C, A <> B -> B <> C -> A <> C ->
  exists D E F, TriSumA A B C D E F.

Lemma trisuma_perm_231 : forall A B C D E F, TriSumA A B C D E F -> TriSumA B C A D E F.

Lemma trisuma_perm_312 : forall A B C D E F, TriSumA A B C D E F -> TriSumA C A B D E F.

Lemma trisuma_perm_321 : forall A B C D E F, TriSumA A B C D E F -> TriSumA C B A D E F.

Lemma trisuma_perm_213 : forall A B C D E F, TriSumA A B C D E F -> TriSumA B A C D E F.

Lemma trisuma_perm_132 : forall A B C D E F, TriSumA A B C D E F -> TriSumA A C B D E F.

Lemma conga_trisuma__trisuma : forall A B C D E F D' E' F',
  TriSumA A B C D E F -> CongA D E F D' E' F' -> TriSumA A B C D' E' F'.

Lemma trisuma2__conga : forall A B C D E F D' E' F',
  TriSumA A B C D E F -> TriSumA A B C D' E' F' -> CongA D E F D' E' F'.

Lemma conga3_trisuma__trisuma : forall A B C D E F A' B' C', TriSumA A B C D E F ->
  CongA A B C A' B' C' -> CongA B C A B' C' A' -> CongA C A B C' A' B' ->
  TriSumA A' B' C' D E F.

Lemma col_trisuma__bet : forall A B C P Q R, Col A B C -> TriSumA A B C P Q R -> Bet P Q R.

Lemma suma_dec : forall A B C D E F G H I, SumA A B C D E F G H I \/ ~ SumA A B C D E F G H I.

Lemma sams_dec : forall A B C D E F, SAMS A B C D E F \/ ~ SAMS A B C D E F.

Lemma trisuma_dec : forall A B C P Q R, TriSumA A B C P Q R \/ ~ TriSumA A B C P Q R.

End Suma_2.

Hint Resolve per2__sams acute2__sams acute_per__sams sams123231 bet_suppa__suma : suma. *)

Require Import GeoCoq.Tarski_dev.Ch12_parallel.
(* GeoCoq.Tarski_dev.Ch12_parallel:
Require Export GeoCoq.Tarski_dev.Ch11_angles.

Section T12_1.

Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.

Lemma par_reflexivity : forall A B, A<>B -> Par A B A B.

Lemma par_strict_irreflexivity : forall A B,
 ~ Par_strict A B A B.

Lemma not_par_strict_id : forall A B C,
 ~ Par_strict A B A C.

Lemma par_id : forall A B C,
 Par A B A C -> Col A B C.

Lemma par_strict_not_col_1 : forall A B C D,
 Par_strict A B C D  -> ~ Col A B C.

Lemma par_strict_not_col_2 : forall A B C D,
 Par_strict A B C D  -> ~ Col B C D.

Lemma par_strict_not_col_3 : forall A B C D,
 Par_strict A B C D  -> ~ Col C D A.

Lemma par_strict_not_col_4 : forall A B C D,
 Par_strict A B C D  -> ~ Col A B D.

Lemma par_strict_not_cols : forall A B C D,
 Par_strict A B C D -> ~ Col A B C /\ ~ Col B C D /\ ~ Col C D A /\ ~ Col A B D.

Lemma par_id_1 : forall A B C,
 Par A B A C -> Col B A C.

Lemma par_id_2 : forall A B C,
 Par A B A C -> Col B C A.

Lemma par_id_3 : forall A B C,
 Par A B A C -> Col A C B.

Lemma par_id_4 : forall A B C,
 Par A B A C -> Col C B A.

Lemma par_id_5 : forall A B C,
 Par A B A C -> Col C A B.

Lemma par_strict_symmetry :forall A B C D,
 Par_strict A B C D -> Par_strict C D A B.

Lemma par_symmetry :forall A B C D,
 Par A B C D -> Par C D A B.

Lemma par_left_comm : forall A B C D,
 Par A B C D -> Par B A C D.

Lemma par_right_comm : forall A B C D,
 Par A B C D -> Par A B D C.

Lemma par_comm : forall A B C D,
 Par A B C D -> Par B A D C.

Lemma par_strict_left_comm : forall A B C D,
 Par_strict A B C D -> Par_strict B A C D.

Lemma par_strict_right_comm : forall A B C D,
 Par_strict A B C D -> Par_strict A B D C.

Lemma par_strict_comm : forall A B C D,
 Par_strict A B C D -> Par_strict B A D C.

Lemma par_strict_neq1 : forall A B C D, Par_strict A B C D -> A <> B.

Lemma par_strict_neq2 : forall A B C D, Par_strict A B C D -> C <> D.

Lemma par_neq1 : forall A B C D, Par A B C D -> A <> B.

Lemma par_neq2 : forall A B C D, Par A B C D -> C <> D.

End T12_1.

Ltac assert_diffs :=
repeat
 match goal with
      | H:(~Col ?X1 ?X2 ?X3) |- _ =>
      let h := fresh in
      not_exist_hyp3 X1 X2 X1 X3 X2 X3;
      assert (h := not_col_distincts X1 X2 X3 H);decompose [and] h;clear h;clean_reap_hyps

      | H:(~Bet ?X1 ?X2 ?X3) |- _ =>
      let h := fresh in
      not_exist_hyp2 X1 X2 X2 X3;
      assert (h := not_bet_distincts X1 X2 X3 H);decompose [and] h;clear h;clean_reap_hyps
      | H:Bet ?A ?B ?C, H2 : ?A <> ?B |-_ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= bet_neq12__neq A B C H H2);clean_reap_hyps
      | H:Bet ?A ?B ?C, H2 : ?B <> ?A |-_ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= bet_neq21__neq A B C H H2);clean_reap_hyps
      | H:Bet ?A ?B ?C, H2 : ?B <> ?C |-_ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= bet_neq23__neq A B C H H2);clean_reap_hyps
      | H:Bet ?A ?B ?C, H2 : ?C <> ?B |-_ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= bet_neq32__neq A B C H H2);clean_reap_hyps

      | H:Cong ?A ?B ?C ?D, H2 : ?A <> ?B |-_ =>
      let T:= fresh in (not_exist_hyp_comm C D);
        assert (T:= cong_diff A B C D H2 H);clean_reap_hyps
      | H:Cong ?A ?B ?C ?D, H2 : ?B <> ?A |-_ =>
      let T:= fresh in (not_exist_hyp_comm C D);
        assert (T:= cong_diff_2 A B C D H2 H);clean_reap_hyps
      | H:Cong ?A ?B ?C ?D, H2 : ?C <> ?D |-_ =>
      let T:= fresh in (not_exist_hyp_comm A B);
        assert (T:= cong_diff_3 A B C D H2 H);clean_reap_hyps
      | H:Cong ?A ?B ?C ?D, H2 : ?D <> ?C |-_ =>
      let T:= fresh in (not_exist_hyp_comm A B);
        assert (T:= cong_diff_4 A B C D H2 H);clean_reap_hyps

      | H:Le ?A ?B ?C ?D, H2 : ?A <> ?B |-_ =>
      let T:= fresh in (not_exist_hyp_comm C D);
        assert (T:= le_diff A B C D H2 H);clean_reap_hyps
      | H:Le ?A ?B ?C ?D, H2 : ?B <> ?A |-_ =>
      let T:= fresh in (not_exist_hyp_comm C D);
        assert (T:= le_diff A B C D (swap_diff B A H2) H);clean_reap_hyps
      | H:Lt ?A ?B ?C ?D |-_ =>
      let T:= fresh in (not_exist_hyp_comm C D);
        assert (T:= lt_diff A B C D H);clean_reap_hyps

      | H:Midpoint ?I ?A ?B, H2 : ?A<>?B |- _ =>
      let T:= fresh in (not_exist_hyp2 I B I A);
       assert (T:= midpoint_distinct_1 I A B H2 H);
       decompose [and] T;clear T;clean_reap_hyps
      | H:Midpoint ?I ?A ?B, H2 : ?B<>?A |- _ =>
      let T:= fresh in (not_exist_hyp2 I B I A);
       assert (T:= midpoint_distinct_1 I A B (swap_diff B A H2) H);
       decompose [and] T;clear T;clean_reap_hyps

      | H:Midpoint ?I ?A ?B, H2 : ?I<>?A |- _ =>
      let T:= fresh in (not_exist_hyp2 I B A B);
       assert (T:= midpoint_distinct_2 I A B H2 H);
       decompose [and] T;clear T;clean_reap_hyps
      | H:Midpoint ?I ?A ?B, H2 : ?A<>?I |- _ =>
      let T:= fresh in (not_exist_hyp2 I B A B);
       assert (T:= midpoint_distinct_2 I A B (swap_diff A I H2) H);
       decompose [and] T;clear T;clean_reap_hyps

      | H:Midpoint ?I ?A ?B, H2 : ?I<>?B |- _ =>
      let T:= fresh in (not_exist_hyp2 I A A B);
       assert (T:= midpoint_distinct_3 I A B H2 H);
       decompose [and] T;clear T;clean_reap_hyps
      | H:Midpoint ?I ?A ?B, H2 : ?B<>?I |- _ =>
      let T:= fresh in (not_exist_hyp2 I A A B);
       assert (T:= midpoint_distinct_3 I A B (swap_diff B I H2) H);
       decompose [and] T;clear T;clean_reap_hyps

      | H:Per ?A ?B ?C, H2 : ?A<>?B |- _ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= per_distinct A B C H H2); clean_reap_hyps
      | H:Per ?A ?B ?C, H2 : ?B<>?A |- _ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= per_distinct A B C H (swap_diff B A H2)); clean_reap_hyps
      | H:Per ?A ?B ?C, H2 : ?B<>?C |- _ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= per_distinct_1 A B C H H2); clean_reap_hyps
      | H:Per ?A ?B ?C, H2 : ?C<>?B |- _ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= per_distinct_1 A B C H (swap_diff C B H2)); clean_reap_hyps

      | H:Perp ?A ?B ?C ?D |- _ =>
      let T:= fresh in (not_exist_hyp2 A B C D);
       assert (T:= perp_distinct A B C D H);
       decompose [and] T;clear T;clean_reap_hyps
      | H:Perp_at ?X ?A ?B ?C ?D |- _ =>
      let T:= fresh in (not_exist_hyp2 A B C D);
       assert (T:= perp_in_distinct X A B C D H);
       decompose [and] T;clear T;clean_reap_hyps
      | H:Out ?A ?B ?C |- _ =>
      let T:= fresh in (not_exist_hyp2 A B A C);
       assert (T:= out_distinct A B C H);
       decompose [and] T;clear T;clean_reap_hyps

      | H:TS ?A ?B ?C ?D |- _ =>
      let h := fresh in
      not_exist_hyp6 A B A C A D B C B D C D;
      assert (h := ts_distincts A B C D H);decompose [and] h;clear h;clean_reap_hyps
      | H:OS ?A ?B ?C ?D |- _ =>
      let h := fresh in
      not_exist_hyp5 A B A C A D B C B D;
      assert (h := os_distincts A B C D H);decompose [and] h;clear h;clean_reap_hyps
      | H:~ Coplanar ?A ?B ?C ?D |- _ =>
      let h := fresh in
      not_exist_hyp6 A B A C A D B C B D C D;
      assert (h := ncop_distincts A B C D H);decompose [and] h;clear h;clean_reap_hyps

      | H:CongA ?A ?B ?C ?A' ?B' ?C' |- _ =>
      let T:= fresh in (not_exist_hyp_comm A B);
        assert (T:= conga_diff1 A B C A' B' C' H);clean_reap_hyps
      | H:CongA ?A ?B ?C ?A' ?B' ?C' |- _ =>
      let T:= fresh in (not_exist_hyp_comm B C);
        assert (T:= conga_diff2 A B C A' B' C' H);clean_reap_hyps
      | H:CongA ?A ?B ?C ?A' ?B' ?C' |- _ =>
      let T:= fresh in (not_exist_hyp_comm A' B');
        assert (T:= conga_diff45 A B C A' B' C' H);clean_reap_hyps
      | H:CongA ?A ?B ?C ?A' ?B' ?C' |- _ =>
      let T:= fresh in (not_exist_hyp_comm B' C');
        assert (T:= conga_diff56 A B C A' B' C' H);clean_reap_hyps

      | H:(InAngle ?P ?A ?B ?C) |- _ =>
      let h := fresh in
      not_exist_hyp3 A B C B P B;
      assert (h := inangle_distincts A B C P H);decompose [and] h;clear h;clean_reap_hyps
      | H:LeA ?A ?B ?C ?D ?E ?F |- _ =>
      let h := fresh in
      not_exist_hyp4 A B B C D E E F;
      assert (h := lea_distincts A B C D E F H);decompose [and] h;clear h;clean_reap_hyps
      | H:LtA ?A ?B ?C ?D ?E ?F |- _ =>
      let h := fresh in
      not_exist_hyp4 A B B C D E E F;
      assert (h := lta_distincts A B C D E F H);decompose [and] h;clear h;clean_reap_hyps
      | H:(Acute ?A ?B ?C) |- _ =>
      let h := fresh in
      not_exist_hyp2 A B B C;
      assert (h := acute_distincts A B C H);decompose [and] h;clear h;clean_reap_hyps
      | H:(Obtuse ?A ?B ?C) |- _ =>
      let h := fresh in
      not_exist_hyp2 A B B C;
      assert (h := obtuse_distincts A B C H);decompose [and] h;clear h;clean_reap_hyps
      | H:SuppA ?A ?B ?C ?D ?E ?F |- _ =>
      let h := fresh in
      not_exist_hyp4 A B B C D E E F;
      assert (h := suppa_distincts A B C D E F H);decompose [and] h;clear h;clean_reap_hyps

      | H:(Orth_at ?X ?A ?B ?C ?U ?V) |- _ =>
      let h := fresh in
      not_exist_hyp4 A B A C B C U V;
      assert (h := orth_at_distincts A B C U V X H);decompose [and] h;clear h;clean_reap_hyps
      | H:(Orth ?A ?B ?C ?U ?V) |- _ =>
      let h := fresh in
      not_exist_hyp4 A B A C B C U V;
      assert (h := orth_distincts A B C U V H);decompose [and] h;clear h;clean_reap_hyps

      | H:Par ?A ?B ?C ?D |- _ =>
      let T:= fresh in (not_exist_hyp_comm A B);
        assert (T:= par_neq1 A B C D H);clean_reap_hyps
      | H:Par ?A ?B ?C ?D |- _ =>
      let T:= fresh in (not_exist_hyp_comm C D);
        assert (T:= par_neq2 A B C D H);clean_reap_hyps
      | H:Par_strict ?A ?B ?C ?D |- _ =>
      let T:= fresh in (not_exist_hyp_comm A B);
        assert (T:= par_strict_neq1 A B C D H);clean_reap_hyps
      | H:Par_strict ?A ?B ?C ?D |- _ =>
      let T:= fresh in (not_exist_hyp_comm C D);
        assert (T:= par_strict_neq2 A B C D H);clean_reap_hyps
 end.

Ltac assert_ncols :=
repeat
  match goal with
      | H:OS ?A ?B ?X ?Y |- _ =>
     not_exist_hyp_perm_ncol A B X;assert (~ Col A B X) by (apply(one_side_not_col123 A B X Y);finish)

      | H:OS ?A ?B ?X ?Y |- _ =>
     not_exist_hyp_perm_ncol A B Y;assert (~ Col A B Y) by (apply(one_side_not_col124 A B X Y);finish)

      | H:TS ?A ?B ?X ?Y |- _ =>
     not_exist_hyp_perm_ncol A B X;assert (~ Col A B X) by (apply(two_sides_not_col A B X Y);finish)

      | H:TS ?A ?B ?X ?Y |- _ =>
     not_exist_hyp_perm_ncol A B Y;assert (~ Col A B Y) by (apply(two_sides_not_col A B Y X);finish)

      | H:~ Coplanar ?A ?B ?C ?D |- _ =>
      let h := fresh in
      not_exist_hyp_perm4 A B C D;
      assert (h := ncop__ncols A B C D H);decompose [and] h;clear h;clean_reap_hyps

      | H:Par_strict ?A ?B ?C ?D |- _ =>
      let h := fresh in
      not_exist_hyp_perm4 A B C D;
      assert (h := par_strict_not_cols A B C D H);decompose [and] h;clear h;clean_reap_hyps
  end.

Hint Resolve
 par_reflexivity par_strict_irreflexivity
 par_strict_symmetry par_strict_comm par_strict_right_comm par_strict_left_comm
 par_symmetry par_comm par_right_comm par_left_comm : par.

Hint Resolve par_strict_not_col_1 par_strict_not_col_2
             par_strict_not_col_3 par_strict_not_col_4 : col.

Ltac Par := eauto with par.

Section T12_2.

Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.

Lemma Par_cases :
  forall A B C D,
  Par A B C D \/ Par B A C D \/ Par A B D C \/ Par B A D C \/
  Par C D A B \/ Par C D B A \/ Par D C A B \/ Par D C B A ->
  Par A B C D.

Lemma Par_perm :
  forall A B C D,
  Par A B C D ->
  Par A B C D /\ Par B A C D /\ Par A B D C /\ Par B A D C /\
  Par C D A B /\ Par C D B A /\ Par D C A B /\ Par D C B A.

Lemma Par_strict_cases :
  forall A B C D,
  Par_strict A B C D \/ Par_strict B A C D \/ Par_strict A B D C \/ Par_strict B A D C \/
  Par_strict C D A B \/ Par_strict C D B A \/ Par_strict D C A B \/ Par_strict D C B A ->
  Par_strict A B C D.

Lemma Par_strict_perm :
  forall A B C D,
  Par_strict A B C D ->
  Par_strict A B C D /\ Par_strict B A C D /\ Par_strict A B D C /\ Par_strict B A D C /\
  Par_strict C D A B /\ Par_strict C D B A /\ Par_strict D C A B /\ Par_strict D C B A.

End T12_2.

Section T12_2'.

Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.

Lemma l12_6 : forall A B C D,
 Par_strict A B C D -> OS A B C D.

Lemma pars__os3412 : forall A B C D,
 Par_strict A B C D -> OS C D A B.

Lemma perp_dec : forall A B C D, Perp A B C D \/ ~ Perp A B C D.

Lemma col_cop2_perp2__col : forall X1 X2 Y1 Y2 A B,
 Perp X1 X2 A B -> Perp Y1 Y2 A B -> Col X1 Y1 Y2 ->
 Coplanar A B X2 Y1 -> Coplanar A B X2 Y2 -> Col X2 Y1 Y2.

Lemma col_perp2_ncol__col : forall X1 X2 Y1 Y2 A B,
 Perp X1 X2 A B -> Perp Y1 Y2 A B ->
 Col X1 Y1 Y2 -> ~ Col X1 A B ->
 Col X2 Y1 Y2.

Lemma l12_9 : forall A1 A2 B1 B2 C1 C2,
 Coplanar C1 C2 A1 B1 -> Coplanar C1 C2 A1 B2 ->
 Coplanar C1 C2 A2 B1 -> Coplanar C1 C2 A2 B2 ->
 Perp A1 A2 C1 C2 -> Perp B1 B2 C1 C2 ->
 Par A1 A2 B1 B2.

Lemma parallel_existence : forall A B P, A <> B ->
 exists C, exists D, C<>D /\ Par A B C D /\ Col P C D.

Lemma par_col_par : forall A B C D D',
 C <> D' -> Par A B C D -> Col C D D' -> Par A B C D'.

Lemma parallel_existence1 : forall A B P, A <> B -> exists Q, Par A B P Q.

Lemma par_not_col : forall A B C D X, Par_strict A B C D -> Col X A B -> ~Col X C D.

Lemma not_strict_par1 : forall A B C D X, Par A B C D -> Col A B X -> Col C D X -> Col A B C.

Lemma not_strict_par2 : forall A B C D X, Par A B C D -> Col A B X -> Col C D X -> Col A B D.

Lemma not_strict_par : forall A B C D X, Par A B C D -> Col A B X -> Col C D X -> Col A B C /\ Col A B D.

Lemma not_par_not_col : forall A B C, A <> B -> A <> C -> ~Par A B A C -> ~Col A B C.

Lemma not_par_inter_uniqueness : forall A B C D X Y,
  A <> B -> C <> D -> ~Par A B C D -> Col A B X -> Col C D X -> Col A B Y -> Col C D Y ->
  X = Y.

Lemma inter_uniqueness_not_par : forall A B C D P,
  ~Col A B C -> Col A B P -> Col C D P -> ~Par A B C D.

Lemma col_not_col_not_par :
 forall A B C D,
 (exists P, Col A B P /\ Col C D P) ->
 (exists Q, Col C D Q /\ ~Col A B Q) -> ~Par A B C D.

Lemma par_distincts : forall A B C D,
 Par A B C D -> (Par A B C D /\ A <> B /\ C <> D).

Lemma par_not_col_strict : forall A B C D P,
 Par A B C D -> Col C D P -> ~Col A B P -> Par_strict A B C D.

Lemma all_one_side_par_strict : forall A B C D,
 C <> D -> (forall P, Col C D P -> OS A B C P) ->
 Par_strict A B C D.

Lemma par_col_par_2 : forall A B C D P,
 A <> P -> Col A B P -> Par A B C D -> Par A P C D.

Lemma par_col2_par : forall A B C D E F,
 E <> F -> Par A B C D -> Col C D E -> Col C D F -> Par A B E F.

Lemma par_col2_par_bis : forall A B C D E F,
 E <> F -> Par A B C D -> Col E F C -> Col E F D -> Par A B E F.

Lemma par_strict_col_par_strict : forall A B C D E,
 C <> E -> Par_strict A B C D -> Col C D E ->
 Par_strict A B C E.

Lemma par_strict_col2_par_strict : forall A B C D E F,
 E <> F -> Par_strict A B C D -> Col C D E -> Col C D F ->
 Par_strict A B E F.

Lemma line_dec : forall B1 B2 C1 C2, (Col C1 B1 B2 /\ Col C2 B1 B2) \/ ~ (Col C1 B1 B2 /\ Col C2 B1 B2).

Lemma par_distinct : forall A B C D, Par A B C D -> A <> B /\ C <> D.

Lemma par_col4__par : forall A B C D E F G H, E <> F -> G <> H -> Par A B C D ->
 Col A B E -> Col A B F -> Col C D G -> Col C D H -> Par E F G H.

Lemma par_strict_col4__par_strict : forall A B C D E F G H, E <> F -> G <> H ->
 Par_strict A B C D -> Col A B E -> Col A B F -> Col C D G -> Col C D H ->
 Par_strict E F G H.

Lemma par_strict_one_side : forall A B C D P,
 Par_strict A B C D -> Col C D P -> OS A B C P.

Lemma par_strict_all_one_side : forall A B C D,
 Par_strict A B C D -> (forall P, Col C D P -> OS A B C P).

Lemma inter_distincts : forall A B C D X, Inter A B C D X -> A <> B /\ C <> D.

Lemma inter_trivial : forall A B X, ~ Col A B X -> Inter A X B X X.

Lemma inter_sym : forall A B C D X, Inter A B C D X -> Inter C D A B X.

Lemma inter_left_comm : forall A B C D X, Inter A B C D X -> Inter B A C D X.

Lemma inter_right_comm : forall A B C D X, Inter A B C D X -> Inter A B D C X.

Lemma inter_comm : forall A B C D X, Inter A B C D X -> Inter B A D C X.

Lemma l12_17 : forall A B C D P,
 A <> B -> Midpoint P A C -> Midpoint P B D -> Par A B C D.

Lemma l12_18_a :
  forall A B C D P,
  Cong A B C D -> Cong B C D A -> ~Col A B C ->
  B <> D -> Col A P C -> Col B P D ->
  Par A B C D.

Lemma l12_18_b :
  forall A B C D P,
  Cong A B C D -> Cong B C D A -> ~Col A B C ->
  B <> D -> Col A P C -> Col B P D ->
  Par B C D A.

Lemma l12_18_c :
 forall A B C D P,
  Cong A B C D -> Cong B C D A -> ~Col A B C ->
  B <> D -> Col A P C -> Col B P D ->
  TS B D A C.

Lemma l12_18_d :
 forall A B C D P,
 Cong A B C D -> Cong B C D A -> ~Col A B C ->
 B <> D -> Col A P C -> Col B P D ->
 TS A C B D.

Lemma l12_18 :
 forall A B C D P,
  Cong A B C D -> Cong B C D A -> ~Col A B C ->
  B <> D -> Col A P C -> Col B P D ->
  Par A B C D /\ Par B C D A /\ TS B D A C /\ TS A C B D.

Lemma par_two_sides_two_sides :
  forall A B C D,
  Par A B C D -> TS B D A C ->
  TS A C B D.

Lemma par_one_or_two_sides :
 forall A B C D,
  Par_strict A B C D ->
 TS A C B D /\ TS B D A C \/ OS A C B D /\ OS B D A C.

Lemma l12_21_b : forall A B C D,
 TS A C B D ->
 CongA B A C D C A -> Par A B C D.

Lemma l12_22_aux :
 forall A B C D P,
  P <> A -> A <> C -> Bet P A C -> OS P A B D ->
  CongA B A P D C P ->
  Par A B C D.

Lemma l12_22_b :
 forall A B C D P,
  Out P A C -> OS P A B D -> CongA B A P D C P ->
  Par A B C D.

Lemma par_strict_par : forall A B C D,
 Par_strict A B C D -> Par A B C D.

Lemma par_strict_distinct : forall A B C D,
 Par_strict A B C D ->
  A<>B /\ A<>C /\ A<>D /\ B<>C /\ B<>D /\ C<>D.

Lemma col_par : forall A B C,
 A <> B -> B <> C ->
 Col A B C -> Par A B B C.

Lemma acute_col_perp__out : forall A B C A',
  Acute A B C -> Col B C A' -> Perp B C A A' -> Out B A' C.

Lemma acute_col_perp__out_1 : forall A B C A',
  Acute A B C -> Col B C A' -> Perp B A A A' -> Out B A' C.

Lemma conga_cop_inangle_per2__inangle : forall A B C P T,
  Per A B C -> InAngle T A B C -> CongA P B A P B C -> Per B P T -> Coplanar A B C P ->
  InAngle P A B C.

End T12_2'.

Hint Resolve col_par par_strict_par : par.

Hint Resolve l12_6 pars__os3412 : side.

Section T12_3.

Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.

Lemma perp_not_par : forall A B X Y, Perp A B X Y -> ~ Par A B X Y.

Lemma cong_conga_perp : forall A B C P, TS B P A C -> Cong A B C B -> CongA A B P C B P -> Perp A C B P.

Lemma perp_inter_exists : forall A B C D, Perp A B C D -> exists P, Col A B P /\ Col C D P.

Lemma perp_inter_perp_in : forall A B C D, Perp A B C D -> exists P, Col A B P /\ Col C D P /\ Perp_at P A B C D.

End T12_3.

Section T12_2D.

Context `{T2D:Tarski_2D}.

Lemma col_perp2__col : forall X1 X2 Y1 Y2 A B,
  Perp X1 X2 A B -> Perp Y1 Y2 A B -> Col X1 Y1 Y2 -> Col X2 Y1 Y2.

Lemma l12_9_2D : forall A1 A2 B1 B2 C1 C2,
  Perp A1 A2 C1 C2 -> Perp B1 B2 C1 C2 -> Par A1 A2 B1 B2.

Lemma conga_inangle_per2__inangle : forall A B C P T,
  Per A B C -> InAngle T A B C -> CongA P B A P B C -> Per B P T ->
  InAngle P A B C.

End T12_2D. *)



Section Archimedes_for_angles.



Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.



Lemma grada_distincts : forall A B C D E F,

  GradA A B C D E F ->

  A <> B /\ C <> B /\ D <> E /\ F <> E.

Proof.

  induction 1.

    assert_diffs; repeat split; trivial.

  apply suma_distincts in H2; spliter; repeat split; auto.

Qed.



Lemma conga2_grada__grada : forall A B C D E F A' B' C' D' E' F',

  GradA A B C D E F ->

  CongA A B C A' B' C' -> CongA D E F D' E' F' ->

  GradA A' B' C' D' E' F'.

Proof.

  intros A B C D E F A' B' C' D' E' F' HGA.

  revert A' B' C' D' E' F'.

  induction HGA; intros A' B' C' D' E' F' Hconga1 Hconga2.

    apply grada_init, conga_trans with D E F; trivial; apply conga_trans with A B C; CongA.

  suma.assert_diffs.

  assert (Hconga3 : CongA D E F D E F) by CongA.

  apply grada_stab with D E F.

    apply (IHHGA A' B' C' D E F); trivial.

    apply (conga2_sams__sams D E F A B C); trivial.

  apply (conga3_suma__suma D E F A B C G H I); trivial.

Qed.



Lemma grada__lea : forall A B C D E F, GradA A B C D E F -> LeA A B C D E F.

Proof.

  intros A B C D E F.

  induction 1.

    Lea.

  apply lea_trans with D E F; trivial.

  apply sams_suma__lea123789 with A B C; trivial.

Qed.



Lemma grada_out__out : forall A B C D E F,

  Out E D F -> GradA A B C D E F ->

  Out B A C.

Proof.

  intros A B C D E F Hout HGA.

  apply out_lea__out with D E F; trivial.

  apply grada__lea; trivial.

Qed.



Lemma grada2_sams_suma__grada : forall A B C D E F G H I K L M,

  GradA A B C D E F -> GradA A B C G H I ->

  SAMS D E F G H I -> SumA D E F G H I K L M ->

  GradA A B C K L M.

Proof.

  intros A B C D E F G H I K L M HGA1 HGA2 HIsi.

  revert K L M.

  induction HGA2.

  { rename H into HConga; rename D0 into G; rename E0 into H; rename F0 into I.

    intros K L M HSuma.

    suma.assert_diffs.

    apply (conga2_sams__sams D E F G H I D E F A B C) in HIsi; CongA.

    apply (conga3_suma__suma D E F G H I K L M D E F A B C K L M) in HSuma; CongA.

    apply grada_stab with D E F; trivial.

  }

  assert (Hd1 := sams_distincts D0 E0 F0 A B C H0); assert (Hd2 := sams_distincts D E F G H I HIsi); spliter.

  destruct (ex_suma D E F D0 E0 F0) as [K [L [M HSuma]]]; auto.

  intros K0 L0 M0 HSuma2.

  assert (HIsi2 : SAMS D E F D0 E0 F0).

    apply sams_lea2__sams with D E F G H I; Lea.

    apply sams_suma__lea123789 with A B C; trivial.

  apply grada_stab with K L M.

    apply IHHGA2; trivial.

    apply sams_assoc_2 with D E F D0 E0 F0 G H I; trivial.

  apply suma_assoc_2 with D E F D0 E0 F0 G H I; trivial.

Qed.



Lemma gradaexp__grada : forall A B C D E F,

  GradAExp A B C D E F -> GradA A B C D E F.

Proof.

  intros A B C.

  induction 1; [apply grada_init | apply grada2_sams_suma__grada with D E F D E F]; trivial.

Qed.



Lemma acute_archi_aux : forall O A B C D E,

  Per O A B -> O <> A -> B <> A -> C <> D -> D <> E ->

  Bet A C D -> Bet C D E -> Bet D E B -> CongA C O D D O E ->

  Lt C D D E.

Proof.

  intros O A B C D E HPer HOA HBA HCD HDE HBet1 HBet2 HBet3 HCongA.

  assert_diffs.

  assert (HNCol1 : ~ Col O A B) by (apply per_not_col; auto).

  assert (HNCol2 : ~ Col O A D).

    intro; elim (eq_dec_points A C); intro; assert_cols; treat_equalities; apply HNCol1; ColR.

  destruct (angle_construction_1 A D O O D E) as [P [HP1 HP2]]; Col.

    intro; apply HNCol2; ColR.

  assert (HAcute : Acute A D O).

    apply l11_43_aux; Col; left; apply l8_2, per_col with B; auto; ColR.

  assert (HF : InAngle P O D E).

  { apply lea_in_angle; Side.

    apply (l11_30 A D O E D O); CongA.

    destruct (acute_chara A D O E) as [HD HI]; eBetween.

    apply lta__lea, HD, HAcute.

  }

  destruct HF as [_ [_ [HDP [F [HBet4 [Heq|HOut]]]]]].

    exfalso; subst F; apply HNCol2; ColR.

  assert_diffs.

  apply l6_6 in HOut.

  assert (HCongA1 : CongA A D O O D F).

    apply (out_conga A D O O D P); trivial; apply out_trivial; auto.

  assert (HCongA2 : CongA O D C A D O).

    elim (eq_dec_points A C); intro.

      treat_equalities; CongA.

    apply (out_conga O D C C D O); CongA; try (apply out_trivial; auto); apply bet_out; eBetween.

  clear dependent P.

  assert (HNCol3 : ~ Col O D F) by (apply (ncol_conga_ncol A D O); Col).

  assert_diffs.

  destruct (l11_50_1 O D C O D F) as [HCong1 [HCong2 HCongA3]]; Cong.

    intro; apply HNCol2; ColR.

    apply (out_conga D O C D O E); CongA; try (apply out_trivial; auto); apply l6_6, bet_out; auto.

    apply conga_trans with A D O; trivial.

  apply (cong2_lt__lt D F D E); Cong.

  assert (HNCol4 : ~ Col E D F).

  { intro; elim (eq_dec_points E F); intro; [|apply HNCol3; ColR].

    treat_equalities.

    apply (acute_not_per A D O); trivial.

    apply l8_2, per_col with C; Col.

    exists E; repeat split; Cong.

  }

  assert_diffs.

  apply l11_44_2_b; trivial.

  apply lta_trans with F D O.

  - destruct (l11_41 D E O C) as [Hlta1 Hlta2]; Between.

      intro; apply HNCol3; ColR.

    apply (conga_preserves_lta D E O O D C); trivial;

    [apply (out_conga D E F D E F)|apply (out_conga O D A F D O)]; CongA;

    try (apply out_trivial; auto).

      apply bet_out; Between.

    apply l6_6, bet_out; eBetween.

  - destruct (l11_41 F O D E); Col.

Qed.



Lemma acute_archi_aux1 : forall O A0 A1 B P Q R,

  Per O A0 B -> B <> A0 -> Bet A0 A1 B ->

  GradA A0 O A1 P Q R -> A0 <> A1 ->

  LeA A0 O B P Q R \/ exists A, Bet A0 A1 A /\ Bet A0 A B /\ CongA P Q R A0 O A.

Proof.

  intros O A0 A1 B P Q R HPer HBA0 HBet HGA HA0A1.

  assert (Hdiff := grada_distincts A0 O A1 P Q R HGA); spliter.

  assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).

  assert_diffs.

  elim (lea_total A0 O B P Q R); auto.

  intro HLeA; right.

  assert (HNCol2 : ~ Col P Q R).

  { intro HCol.

    assert (HBet1 : Bet P Q R).

      apply not_out_bet; trivial.

      intro HOut; assert (Out O A0 A1) by (apply grada_out__out with P Q R; trivial).

      apply HNCol; ColR.

    assert (Bet A0 O B); assert_cols; Col.

    apply bet_lea__bet with P Q R; trivial.

  }

  destruct (angle_construction_1 P Q R A0 O B) as [C [Hconga HOS]]; Col.

  assert (HA : InAngle C A0 O B).

    apply lea_in_angle; Side; apply (l11_30 P Q R A0 O B); CongA.

  destruct HA as [_ [_ [HCO [A [HA HUn]]]]].

  destruct HUn as [Heq|Hout].

    exfalso; treat_equalities; apply HNCol; Col.

  exists A.

  apply (out_conga P Q R A0 O C P R A0 A) in Hconga; try (apply out_trivial; auto); [|apply l6_6; trivial].

  repeat (split; trivial).

  elim (eq_dec_points A1 A).

    intro; subst A; Between.

  intro HAA1.

  apply (ncol_conga_ncol P Q R A0 O A) in HNCol2; trivial.

  assert (HInangle : InAngle A1 A0 O A).

  { apply lea_in_angle.

      apply (l11_30 A0 O A1 P Q R); CongA; apply grada__lea; trivial.

    apply out_one_side; auto.

    assert_diffs.

    apply l6_7 with B; [|apply l6_6]; apply bet_out; auto.

  }

  destruct HInangle as [_ [_ [_ [X [HX1 HUn]]]]].

  destruct HUn as [HX2|HX2].

    subst X; exfalso; Col.

  elim (eq_dec_points X A1); intro.

    subst X; trivial.

  exfalso; apply HNCol2; assert_diffs; ColR.

Qed.



Lemma acute_archi_aux2 : forall O A0 A1 B C,

  Per O A0 B -> O <> A0 -> B <> A0 ->

  Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C ->

  exists P, exists Q, exists R, GradA A0 O A1 P Q R /\ (LeA A0 O B P Q R \/

  exists A', Bet A0 A1 A' /\ Bet A0 A' B /\ CongA P Q R A0 O A' /\ Le A0 C A0 A' /\

  exists A, Bet A0 A A' /\ CongA A O A' A0 O A1 /\ Le A0 A1 A A').

Proof.

  intros O A0 A1 B E HPer HOA0 HBA0 HBet HA0A1 HG.

  assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).

  assert (HNCol1 : ~ Col A0 O A1) by (intro; apply HNCol; ColR).

  assert_diffs.

  induction HG; rename A into A0; rename B0 into A1.

    exists A0; exists O; exists A1; split; [apply grada_init; CongA|].

    right; exists A1; repeat (split; CongA); Between; Le.

    exists A0; repeat (split; CongA); Between; Le.

  destruct IHHG as [P [Q [R [HGA HUn]]]]; auto.

  destruct HUn as [HLea|HA'].

    exists P; exists Q; exists R; split; trivial; left; trivial.

  destruct HA' as [A' [HBet1' [HBet2' [HConga' [HLe' HA]]]]].

  destruct HA as [A [HBet1 [HConga HLe]]].

  assert (HIsi : SAMS P Q R A0 O A1).

  { apply sams_lea2__sams with A0 O B A0 O B.

    - apply acute__sams, l11_43_aux; Col.

    - apply (l11_30 A0 O A' A0 O B); CongA.

      exists A'; assert_diffs; split; CongA.

      repeat split; auto.

      exists A'; split; trivial.

      right; apply out_trivial; auto.

    - exists A1; split; CongA.

      repeat split; auto.

      exists A1; split; trivial.

      right; apply out_trivial; auto.

  }

  assert_diffs.

  destruct (ex_suma P Q R A0 O A1) as [P' [Q' [R' HSuma]]]; auto.

  assert (HGA' : GradA A0 O A1 P' Q' R') by (apply grada_stab with P Q R; trivial).

  exists P'; exists Q'; exists R'; split; trivial.

  destruct (acute_archi_aux1 O A0 A1 B P' Q' R') as [HLea|HA'']; auto.

  right; destruct HA'' as [A'' [HBet1'' [HBet2'' HConga'']]].

  assert (HNCol2 : ~ Col A O A') by (apply (ncol_conga_ncol A0 O A1); Col; CongA).

  assert (HNCol3 : ~ Col A0 O A') by (intro; assert_diffs; apply HNCol; ColR).

  assert (HNCol4 : ~ Col A' O A'').

  { intro HCol; apply HNCol1.

    elim (eq_dec_points A' A''); intro; [|ColR].

    treat_equalities.

    assert (HSuma2 : SumA A0 O A' A0 O A1 A0 O A').

      apply (conga3_suma__suma P Q R A0 O A1 P' Q' R'); CongA.

    apply sams_suma__out546 in HSuma2; Col.

    apply (conga2_sams__sams P Q R A0 O A1); CongA.

  }

  assert (HNCol5 : ~ Col A0 O A'') by (intro; assert_diffs; apply HNCol4; ColR).

  assert (HBet4 : Bet A0 A' A'').

  { apply col_two_sides_bet with O.

      ColR.

    apply in_angle_two_sides; Col.

    apply lea_in_angle.

      apply (l11_30 P Q R P' Q' R'); CongA; apply sams_suma__lea123789 with A0 O A1; trivial.

    apply out_one_side; Col; apply l6_7 with B; [|apply l6_6]; assert_diffs; apply bet_out; auto.

  }

  assert (HConga4 : CongA A O A' A' O A'').

  { assert_diffs.

    assert (HNOS : ~ OS O A' A0 A'') by (apply l9_9; repeat split; auto; Col; exists A'; Col).

    apply conga_trans with A0 O A1; trivial.

    apply sams2_suma2__conga456 with P Q R P' Q' R'; trivial.

    - apply (conga2_sams__sams A0 O A' A' O A''); CongA.

      split; auto; split.

        right; intro; Col.

      exists A''; repeat (split; CongA); Cop.

      apply l9_9_bis, out_one_side; Col.

      apply bet_out; auto.

    - apply (conga3_suma__suma A0 O A' A' O A'' A0 O A''); CongA.

      exists A''; repeat (split; CongA); Cop.

  }

  assert (HLe'' : Le A0 A1 A' A'').

    apply le_transitivity with A A'; trivial; assert_diffs.

    apply lt__le, acute_archi_aux with O A0 B; eBetween.

  exists A''; repeat (split; trivial).

    apply bet2_le2__le1346 with C A'; auto.

    apply (l5_6 A0 A1 A' A''); Cong.

  exists A'; split; trivial; split; trivial.

  apply conga_trans with A O A'; CongA.

Qed.



Lemma archi_in_acute_angles :

  archimedes_axiom ->

  forall A B C D E F,

    ~ Col A B C -> Acute D E F ->

    exists P Q R, GradA A B C P Q R /\ LeA D E F P Q R.

Proof.

  intros archi A B C D E F HNCol HAcute.

  assert_diffs.

  elim (col_dec D E F).

  { intro HCol; exists A; exists B; exists C; split.

      apply grada_init; CongA.

    apply l11_31_1; auto; apply not_bet_out; trivial.

    intro HBet; apply (nlta D E F), acute_obtuse__lta; trivial.

    apply bet__obtuse; auto.

  }

  intro HNCol1.

  elim (lea_total D E F A B C); auto; intro HLea.

    exists A; exists B; exists C; split; trivial; apply grada_init; CongA.

  destruct (l8_18_existence D E F) as [D0 [HD0 HD0']]; trivial.

  assert (HOut : Out E D0 D) by (apply acute_col_perp__out with F; Col; Perp; apply acute_sym; trivial).

  assert_diffs.

  assert (HConga : CongA D E F D0 E F) by (apply (out_conga D0 E F D0 E F); CongA; apply out_trivial; auto).

  apply (acute_conga__acute D E F D0 E F) in HAcute; trivial.

  apply (l11_30 A B C D E F A B C D0 E F) in HLea; CongA.

  apply (ncol_conga_ncol D E F D0 E F) in HNCol1; trivial.

  assert (HPer : Per E D0 F) by (apply perp_per_1; auto; apply perp_left_comm, perp_col with D; Perp; Col).

  clear H0 HD0 HD0' HOut H9.

  destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]]; trivial.

  destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]]; Side.

    apply (l11_30 A B C D0 E F); CongA.

  destruct HUn as [Heq|HOut].

    exfalso; subst D1; Col.

  apply l6_6 in HOut.

  apply (out_conga A B C D0 E D1' A C D0 D1) in HConga1; trivial; try (apply out_trivial; auto).

  apply one_side_not_col123 in HOS.

  assert_diffs.

  assert (D0 <> D1) by (intro; subst D1; assert_cols; Col).

  clear dependent D1'.

  destruct (segment_construction D0 F D0 F) as [F' [HF'1 HF'2]].

  destruct (archi D0 D1 D0 F') as [G [HG1 HG2]]; auto.

  destruct (acute_archi_aux2 E D0 D1 F G) as [P [Q [R [HGA HUn]]]]; auto.

  exists P; exists Q; exists R; split.

    assert (Hdistincts := grada_distincts D0 E D1 P Q R HGA); spliter.

    apply (conga2_grada__grada D0 E D1 P Q R); CongA.

  destruct HUn as [HLea2|Habs].

    assert_diffs; apply (l11_30 D0 E F P Q R); CongA.

  exfalso.

  destruct Habs as [A' [HBet2 [HBet3 [HConga2 [HLe HA]]]]].

  apply (le__nlt D0 F' D0 G); trivial.

  apply le1234_lt__lt with D0 F.

    apply le_transitivity with D0 A'; Le.

  split; Le.

  intro HCong.

  assert (F = F') by (apply between_cong with D0; trivial).

  treat_equalities; auto.

Qed.



Lemma angles_archi_aux :

  forall A B C D E F G H I,

    GradA A B C D E F -> GradA A B C G H I -> ~ SAMS D E F G H I ->

    exists P Q R, GradA A B C P Q R /\ ~ SAMS P Q R A B C.

Proof.

  intros A B C D E F G H I HGA1 HGA2.

  induction HGA2.

    intro HNIsi; exists D; exists E; exists F; split; trivial.

    assert (Hd := grada_distincts A B C D E F HGA1); spliter.

    intro HIsi; apply HNIsi, (conga2_sams__sams D E F A B C); CongA.

  intro HNIsi.

  elim (sams_dec D E F D0 E0 F0); [|apply IHHGA2; trivial].

  intro HIsi; clear IHHGA2.

  assert (Hd := sams_distincts D E F D0 E0 F0 HIsi); spliter.

  destruct (ex_suma D E F D0 E0 F0) as [P [Q [R HSuma]]]; auto.

  exists P; exists Q; exists R; split.

    apply grada2_sams_suma__grada with D E F D0 E0 F0; trivial.

  intro HIsi2; apply HNIsi, sams_assoc_1 with D0 E0 F0 A B C P Q R; trivial.

Qed.



Lemma angles_archi_aux1 :

  archimedes_axiom ->

  forall A B C D E F,

    ~ Col A B C -> ~ Bet D E F ->

    exists P Q R, GradA A B C P Q R /\ (LeA D E F P Q R \/ ~ SAMS P Q R A B C).

Proof.

  intros archi A B C D E F HNCol HNBet.

  assert (Hdiff : D <> E /\ F <> E) by (split; intro; subst E; Between); spliter.

  assert_diffs.

  destruct (angle_bisector D E F) as [F1 [HInangle HConga]]; auto.

  assert(HNOS : ~ OS E F1 D F).

  { assert_diffs.

    elim (col_dec D E F1).

      intros HCol; apply col123__nos; Col.

    intro HNCol1.

    apply l9_9, invert_two_sides, in_angle_two_sides; Col.

    apply not_col_permutation_1, (ncol_conga_ncol D E F1); CongA.

  }

  assert (HSuma : SumA D E F1 D E F1 D E F) by (assert_diffs; exists F; repeat (split; CongA); Cop).

  destruct (archi_in_acute_angles archi A B C D E F1) as [P1 [Q1 [R1 [HGA HLea]]]]; trivial.

  { apply nbet_sams_suma__acute with D E F; trivial.

    assert_diffs; split; trivial; split.

      right; intro HBet; apply HNBet, bet_in_angle_bet with F1; trivial.

    exists F; repeat (split; CongA); Cop.

    elim (col_dec D E F1).

      intros HCol HTS; destruct HTS; Col.

    intro HNCol1.

    elim (col_dec D E F).

      intros HCol HTS; destruct HTS as [_ []]; Col.

    intro HNCol2; apply l9_9_bis, in_angle_one_side; Col.

  }

  assert_diffs.

  destruct (sams_dec P1 Q1 R1 P1 Q1 R1) as [HIsi|HNIsi].

  { destruct (ex_suma P1 Q1 R1 P1 Q1 R1) as [P [Q [R HSuma1]]]; auto.

    exists P; exists Q; exists R; split.

      apply grada2_sams_suma__grada with P1 Q1 R1 P1 Q1 R1; trivial.

    left; apply sams_lea2_suma2__lea with D E F1 D E F1 P1 Q1 R1 P1 Q1 R1; trivial.

  }

  destruct (angles_archi_aux A B C P1 Q1 R1 P1 Q1 R1) as [P [Q [R [HGA1 HNsams1]]]]; trivial.

  exists P; exists Q; exists R; split; auto.

Qed.



Lemma archi_in_angles :

  archimedes_axiom ->

  forall A B C D E F,

    ~ Col A B C -> D <> E -> F <> E ->

    exists P Q R, GradA A B C P Q R /\ (LeA D E F P Q R \/ ~ SAMS P Q R A B C).

Proof.

  intros archi A B C D E F HNCol HDE HFE.

  elim (bet_dec D E F); [|apply angles_archi_aux1; trivial].

  intro HBet1.

  destruct (segment_construction A B A B) as [A0 [HBet HCong]].

  assert_diffs.

  assert (HNCol1 : ~ Col A0 B C) by (intro; apply HNCol; ColR).

  destruct (angles_archi_aux1 archi A B C C B A0) as [P1 [Q1 [R1 [HGA HUn]]]]; Between.

  elim (sams_dec P1 Q1 R1 A B C); [|intro; exists P1; exists Q1; exists R1; auto].

  intro HIsi.

  destruct HUn as [HLea|HNIsi]; [|exfalso; auto].

  assert_diffs.

  destruct (ex_suma P1 Q1 R1 A B C) as [P [Q [R HSuma]]]; auto.

  exists P; exists Q; exists R; split.

    apply grada_stab with P1 Q1 R1; trivial.

  suma.assert_diffs.

  left; apply l11_31_2; auto.

  apply (bet_lea__bet A B A0); trivial.

  apply sams_lea2_suma2__lea with A0 B C A B C P1 Q1 R1 A B C; Lea.

  exists A; repeat (split; CongA); Cop.

  apply l9_9; repeat split; auto.

  exists B; split; Col; Between.

Qed.



Lemma archi__grada_destruction :

  archimedes_axiom ->

  forall A B C,

    ~ Col A B C ->

    exists P Q R, GradA A B C P Q R /\ ~ SAMS P Q R A B C.

Proof.

  intros archi A B C HNCol.

  destruct (segment_construction A B A B) as [A0 [HBet HCong]].

  assert_diffs.

  destruct (archi_in_angles archi A B C A B A0) as [P [Q [R [HGA HUn]]]]; auto.

  exists P; exists Q; exists R; split; auto.

  destruct HUn as [HLea|]; trivial.

  intro HIsi.

  destruct HIsi as [_ [[HOut|HNBet] _]].

    apply HNCol; Col.

  apply HNBet, (bet_lea__bet A B A0); trivial.

Qed.



Lemma gradaexp_destruction_aux : forall A B C P Q R,

  GradA A B C P Q R ->

  exists S T U, GradAExp A B C S T U /\ (Obtuse S T U \/ LeA P Q R S T U).

Proof.

  intros A B C.

  induction 1.

    assert_diffs; exists D; exists E; exists F; split; [apply gradaexp_init|right]; Lea.

  destruct IHGradA as [P [Q [R [HGAE HUn]]]].

  assert (Hd := HGAE); apply gradaexp__grada, grada_distincts in Hd; spliter.

  destruct (sams_dec P Q R P Q R) as [HIsi|HNIsi].

  { destruct HUn as [Habs|HLea].

      absurd (SAMS P Q R P Q R); trivial; apply obtuse__nsams, Habs.

    destruct (ex_suma P Q R P Q R) as [S [T [U HSuma]]]; auto.

    exists S; exists T; exists U; split.

      apply gradaexp_stab with P Q R; trivial.

    right; apply sams_lea2_suma2__lea with D E F A B C P Q R P Q R; trivial.

    apply grada__lea, gradaexp__grada, HGAE.

  }

  apply nsams__obtuse in HNIsi; auto.

  exists P; exists Q; exists R; split; auto.

Qed.



Lemma archi__gradaexp_destruction :

  archimedes_axiom ->

  forall A B C,

    ~ Col A B C ->

    exists P Q R, GradAExp A B C P Q R /\ Obtuse P Q R.

Proof.

  intros archi A B C HNCol.

  destruct (archi__grada_destruction archi A B C HNCol) as [D [E [F [HGA HNIsi]]]].

  destruct (gradaexp_destruction_aux A B C D E F HGA) as [P [Q [R [HGAE HUn]]]].

  exists P; exists Q; exists R; split; trivial.

  destruct HUn as [HObtuse|HLea]; trivial.

  assert_diffs.

  apply nsams__obtuse; auto.

  intro HIsi; apply HNIsi.

  apply sams_lea2__sams with P Q R P Q R; trivial.

  apply grada__lea, gradaexp__grada, HGAE.

Qed.



End Archimedes_for_angles.
