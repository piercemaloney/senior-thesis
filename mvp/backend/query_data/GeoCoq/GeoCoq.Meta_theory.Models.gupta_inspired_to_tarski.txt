Require Import GeoCoq.Axioms.tarski_axioms.
(* GeoCoq.Axioms.tarski_axioms:
Require Export GeoCoq.Utils.general_tactics.

Class Tarski_neutral_dimensionless :=
{
 Tpoint : Type;
 Bet : Tpoint -> Tpoint -> Tpoint -> Prop;
 Cong : Tpoint -> Tpoint -> Tpoint -> Tpoint -> Prop;
 cong_pseudo_reflexivity : forall A B, Cong A B B A;
 cong_inner_transitivity : forall A B C D E F,
   Cong A B C D -> Cong A B E F -> Cong C D E F;
 cong_identity : forall A B C, Cong A B C C -> A = B;
 segment_construction : forall A B C D,
   exists E, Bet A B E /\ Cong B E C D;
 five_segment : forall A A' B B' C C' D D',
   Cong A B A' B' ->
   Cong B C B' C' ->
   Cong A D A' D' ->
   Cong B D B' D' ->
   Bet A B C -> Bet A' B' C' -> A <> B -> Cong C D C' D';
 between_identity : forall A B, Bet A B A -> A = B;
 inner_pasch : forall A B C P Q,
   Bet A P C -> Bet B Q C ->
   exists X, Bet P X B /\ Bet Q X A;
 PA : Tpoint;
 PB : Tpoint;
 PC : Tpoint;
 lower_dim : ~ (Bet PA PB PC \/ Bet PB PC PA \/ Bet PC PA PB)
}.

Class Tarski_neutral_dimensionless_with_decidable_point_equality
 `(Tn : Tarski_neutral_dimensionless) :=
{
 point_equality_decidability : forall A B : Tpoint, A = B \/ ~ A = B
}.

Class Tarski_2D
 `(TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality) :=
{
 upper_dim : forall A B C P Q,
   P <> Q -> Cong A P A Q -> Cong B P B Q -> Cong C P C Q ->
   (Bet A B C \/ Bet B C A \/ Bet C A B)
}.

Class Tarski_3D
 `(TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality) :=
{
 S1 : Tpoint;
 S2 : Tpoint;
 S3 : Tpoint;
 S4 : Tpoint;
 lower_dim_3 : ~ exists X,
   (Bet S1 S2 X \/ Bet S2 X S1 \/ Bet X S1 S2) /\ (Bet S3 S4 X \/ Bet S4 X S3 \/ Bet X S3 S4) \/
   (Bet S1 S3 X \/ Bet S3 X S1 \/ Bet X S1 S3) /\ (Bet S2 S4 X \/ Bet S4 X S2 \/ Bet X S2 S4) \/
   (Bet S1 S4 X \/ Bet S4 X S1 \/ Bet X S1 S4) /\ (Bet S2 S3 X \/ Bet S3 X S2 \/ Bet X S2 S3);
 upper_dim_3 : forall A B C P Q R,
   P <> Q -> Q <> R -> P <> R ->
   Cong A P A Q -> Cong B P B Q -> Cong C P C Q ->
   Cong A P A R -> Cong B P B R -> Cong C P C R ->
   (Bet A B C \/ Bet B C A \/ Bet C A B)
}.

Class Tarski_euclidean
 `(TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality) :=
{
 euclid : forall A B C D T,
   Bet A D T -> Bet B D C -> A<>D ->
   exists X, exists Y,
   Bet A B X /\ Bet A C Y /\ Bet X T Y
}.

Class Tarski_ruler_and_compass
 `(TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality) :=
{
 circle_circle_continuity : forall A B C D B' D',
   Cong A B' A B -> Cong C D' C D ->
   Bet A D' B -> Bet C B' D ->
   exists Z, Cong A Z A B /\ Cong C Z C D
}.

Class Tarski_continuous
 `(TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality) :=
{
 continuity : forall (Alpha Beta : Tpoint -> Prop),
   (exists A, forall X Y, Alpha X -> Beta Y -> Bet A X Y) ->
   (exists B, forall X Y, Alpha X -> Beta Y -> Bet X B Y)
}. *)

Require Import GeoCoq.Axioms.gupta_inspired_variant_axioms.
(* GeoCoq.Axioms.gupta_inspired_variant_axioms:
Class Gupta_inspired_variant_of_Tarski_neutral_dimensionless_with_decidable_point_equality := {
 TpointG : Type;
 BetG : TpointG -> TpointG -> TpointG -> Prop;
 CongG : TpointG -> TpointG -> TpointG -> TpointG -> Prop;
 point_equality_decidabilityG : forall A B : TpointG, A = B \/ ~ A = B;
 cong_pseudo_reflexivityG : forall A B, CongG A B B A;
 cong_inner_transitivityG : forall A B C D E F,
   CongG A B E F -> CongG C D E F -> CongG A B C D;
 cong_identityG : forall A B C, CongG A B C C -> A = B;
 segment_constructionG : forall A B C D,
   exists E, BetG A B E /\ CongG B E C D;
 five_segmentG : forall A A' B B' C C' D D',
   CongG A B A' B' -> CongG B C B' C' -> CongG A D A' D' -> CongG B D B' D' ->
   BetG A B C -> BetG A' B' C' -> A <> B -> CongG C D C' D';
 bet_symmetryG : forall A B C, BetG A B C -> BetG C B A;
 bet_inner_transitivityG : forall A B C D, BetG A B D -> BetG B C D -> BetG A B C;
 inner_paschG : forall A B C P Q,
   BetG A P C -> BetG B Q C ->
   A <> P -> P <> C -> B <> Q -> Q <> C ->
   ~ (BetG A B C \/ BetG B C A \/ BetG C A B) ->
   exists x, BetG P x B /\ BetG Q x A;
 GPA : TpointG;
 GPB : TpointG;
 GPC : TpointG;
 lower_dimG : ~ (BetG GPA GPB GPC \/ BetG GPB GPC GPA \/ BetG GPC GPA GPB)
}.

Class Gupta_inspired_variant_of_Tarski_2D `(TnG : Gupta_inspired_variant_of_Tarski_neutral_dimensionless_with_decidable_point_equality) := {
 upper_dimG : forall A B C P Q,
   P <> Q -> A <> B -> A <> C -> B <> C ->
   CongG A P A Q -> CongG B P B Q -> CongG C P C Q ->
   (BetG A B C \/ BetG B C A \/ BetG C A B)
}.

Class Gupta_inspired_variant_of_Tarski_euclidean `(TnG : Gupta_inspired_variant_of_Tarski_neutral_dimensionless_with_decidable_point_equality) := {
 euclidG : forall A B C D T,
   BetG A D T -> BetG B D C ->
   B <> D -> D <> C ->
   ~ (BetG A B C \/ BetG B C A \/ BetG C A B) ->
   exists x, exists y, BetG A B x /\ BetG A C y /\ BetG x T y
}. *)

Require Import GeoCoq.Tarski_dev.Ch05_bet_le.
(* GeoCoq.Tarski_dev.Ch05_bet_le:
Require Export GeoCoq.Meta_theory.Decidability.equivalence_between_decidability_properties_of_basic_relations.

Section T5.

Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.

Lemma l5_1 : forall A B C D,
  A<>B -> Bet A B C -> Bet A B D -> Bet A C D \/ Bet A D C.

Lemma l5_2 : forall A B C D,
  A<>B -> Bet A B C -> Bet A B D -> Bet B C D \/ Bet B D C.

Lemma segment_construction_2 :
  forall A Q B C, A<>Q -> exists X, (Bet Q A X \/ Bet Q X A) /\ Cong Q X B C.

Lemma l5_3 : forall A B C D,
 Bet A B D -> Bet A C D -> Bet A B C \/ Bet A C B.

Lemma bet3__bet : forall A B C D E, Bet A B E -> Bet A D E -> Bet B C D -> Bet A C E.

Lemma le_bet : forall A B C D, Le C D A B -> exists X, Bet A X B /\ Cong A X C D.

Lemma l5_5_1 : forall A B C D,
  Le A B C D -> exists x, Bet A B x /\ Cong A x C D.

Lemma l5_5_2 : forall A B C D,
 (exists x, Bet A B x /\ Cong A x C D) -> Le A B C D.

Lemma l5_6 : forall A B C D A' B' C' D',
 Le A B C D -> Cong A B A' B' -> Cong C D C' D' -> Le A' B' C' D'.

Lemma le_reflexivity : forall A B, Le A B A B.

Lemma le_transitivity : forall A B C D E F, Le A B C D -> Le C D E F -> Le A B E F.

Lemma between_cong : forall A B C, Bet A C B -> Cong A C A B -> C=B.

Lemma cong3_symmetry : forall A B C A' B' C' : Tpoint , Cong_3 A B C A' B' C' -> Cong_3 A' B' C' A B C.

Lemma between_cong_2 : forall A B D E, Bet A D B -> Bet A E B -> Cong A D A E -> D = E.

Lemma between_cong_3 :
  forall A B D E, A <> B -> Bet A B D -> Bet A B E -> Cong B D B E -> D = E.

Lemma le_anti_symmetry : forall A B C D, Le A B C D -> Le C D A B -> Cong A B C D.

Lemma cong_dec : forall A B C D,
  Cong A B C D \/ ~ Cong A B C D.

Lemma bet_dec : forall A B C, Bet A B C  \/  ~ Bet A B C.

Lemma col_dec : forall A B C, Col A B C \/ ~ Col A B C.

Lemma le_trivial : forall A C D, Le A A C D .

Lemma le_cases : forall A B C D, Le A B C D \/ Le C D A B.

Lemma le_zero : forall A B C, Le A B C C -> A=B.

Lemma le_diff : forall A B C D, A <> B -> Le A B C D -> C <> D.

Lemma lt_diff : forall A B C D, Lt A B C D -> C <> D.

Lemma bet_cong_eq :
 forall A B C D,
  Bet A B C ->
  Bet A C D ->
  Cong B C A D ->
  C = D /\ A = B.

Lemma cong__le : forall A B C D, Cong A B C D -> Le A B C D.

Lemma cong__le3412 : forall A B C D, Cong A B C D -> Le C D A B.

Lemma le1221 : forall A B, Le A B B A.

Lemma le_left_comm : forall A B C D, Le A B C D -> Le B A C D.

Lemma le_right_comm : forall A B C D, Le A B C D -> Le A B D C.

Lemma le_comm : forall A B C D, Le A B C D -> Le B A D C.

Lemma ge_left_comm : forall A B C D, Ge A B C D -> Ge B A C D.

Lemma ge_right_comm : forall A B C D, Ge A B C D -> Ge A B D C.

Lemma ge_comm :  forall A B C D, Ge A B C D -> Ge B A D C.

Lemma lt_right_comm : forall A B C D, Lt A B C D -> Lt A B D C.

Lemma lt_left_comm : forall A B  C D, Lt A B C D -> Lt B A C D.

Lemma lt_comm : forall A B  C D, Lt A B C D -> Lt B A D C.

Lemma gt_left_comm : forall A B C D, Gt A B C D -> Gt B A C D.

Lemma gt_right_comm : forall A B C D, Gt A B C D -> Gt A B D C.

Lemma gt_comm : forall A B C D, Gt A B C D -> Gt B A D C.

Lemma cong2_lt__lt : forall A B C D A' B' C' D',
 Lt A B C D -> Cong A B A' B' -> Cong C D C' D' -> Lt A' B' C' D'.

Lemma fourth_point : forall A B C P, A <> B -> B <> C -> Col A B P -> Bet A B C ->
  Bet P A B \/ Bet A P B \/ Bet B P C \/ Bet B C P.

Lemma third_point : forall A B P, Col A B P -> Bet P A B \/ Bet A P B \/ Bet A B P.

Lemma l5_12_a : forall A B C, Bet A B C -> Le A B A C /\ Le B C A C.

Lemma bet__le1213 : forall A B C, Bet A B C -> Le A B A C.

Lemma bet__le2313 : forall A B C, Bet A B C -> Le B C A C.

Lemma bet__lt1213 : forall A B C, B <> C -> Bet A B C -> Lt A B A C.

Lemma bet__lt2313 : forall A B C, A <> B -> Bet A B C -> Lt B C A C.

Lemma l5_12_b : forall A B C, Col A B C -> Le A B A C -> Le B C A C -> Bet A B C.

Lemma bet_le_eq : forall A B C, Bet A B C -> Le A C B C -> A = B.

Lemma or_lt_cong_gt : forall A B C D, Lt A B C D \/ Gt A B C D \/ Cong A B C D.

Lemma lt__le : forall A B C D, Lt A B C D -> Le A B C D.

Lemma le1234_lt__lt : forall A B C D E F, Le A B C D -> Lt C D E F -> Lt A B E F.

Lemma le3456_lt__lt : forall A B C D E F, Lt A B C D -> Le C D E F -> Lt A B E F.

Lemma lt_transitivity : forall A B C D E F, Lt A B C D -> Lt C D E F -> Lt A B E F.

Lemma not_and_lt : forall A B C D, ~ (Lt A B C D /\ Lt C D A B).

Lemma nlt : forall A B, ~ Lt A B A B.

Lemma le__nlt : forall A B C D, Le A B C D -> ~ Lt C D A B.

Lemma cong__nlt : forall A B C D,
 Cong A B C D -> ~ Lt A B C D.

Lemma nlt__le : forall A B C D, ~ Lt A B C D -> Le C D A B.

Lemma lt__nle : forall A B C D, Lt A B C D -> ~ Le C D A B.

Lemma nle__lt : forall A B C D, ~ Le A B C D -> Lt C D A B.

Lemma lt1123 : forall A B C, B<>C -> Lt A A B C.

Lemma bet2_le2__le : forall O o A B a b, Bet a o b -> Bet A O B -> Le o a O A -> Le o b O B -> Le a b A B.

End T5.

Hint Resolve le_reflexivity le_anti_symmetry le_trivial le_zero cong__le cong__le3412
             le1221 le_left_comm le_right_comm le_comm lt__le bet__le1213 bet__le2313
             lt_left_comm lt_right_comm lt_comm bet__lt1213 bet__lt2313 lt1123 : le.

Ltac Le := auto with le. *)



Section Gupta_inspired_variant_of_Tarski_neutral_dimensionless_to_Tarski_neutral_dimensionless.



Context `{ITnEQD:Gupta_inspired_variant_of_Tarski_neutral_dimensionless_with_decidable_point_equality}.



Lemma g2_1 : forall A B, CongG A B A B.

Proof.

intros A B.

apply cong_inner_transitivityG with B A;

apply cong_pseudo_reflexivityG; auto.

Qed.



Lemma g2_2 : forall A B C D,

  CongG A B C D -> CongG C D A B.

Proof.

intros A B C D HCong.

apply cong_inner_transitivityG with C D; auto; apply g2_1.

Qed.



Lemma cong_inner_transitivityT : forall A B C D E F,

  CongG A B C D -> CongG A B E F -> CongG C D E F.

Proof.

intros A B C D E F HCong1 HCong2.

apply cong_inner_transitivityG with A B; apply g2_2; auto.

Qed.



Lemma g2_3 : forall A B C D,

  CongG A B C D -> CongG B A C D.

Proof.

Proof.

intros A B C D HCong.

apply cong_inner_transitivityT with A B; auto.

apply cong_pseudo_reflexivityG.

Qed.



Lemma g2_4 : forall A B C D,

  CongG A B C D -> CongG A B D C.

Proof. intros A B C D HCong; apply g2_2; apply g2_3; apply g2_2; auto. Qed.



Lemma g2_5 : forall A B C D,

  CongG A B C D -> (A = B <-> C = D).

Proof.

intros A B C D HCong.

split; intro H; rewrite H in HCong;

[apply g2_2 in HCong|]; apply cong_identityG in HCong; auto.

Qed.



Lemma g2_6 : forall A B,

  BetG A B B /\ CongG B B A A.

Proof.

intros A B; destruct (segment_constructionG A B A A) as [C [HBet HCong]].

assert (B = C) by (apply g2_5 with A A; auto).

rewrite H in *; auto.

Qed.



Lemma g2_7 : forall A B C A' B' C',

  CongG A B A' B' -> CongG B C B' C' ->

  BetG A B C -> BetG A' B' C' ->

  CongG A C A' C'.

Proof.

intros A B C A' B' C' HCong1 HCong2 HBet1 HBet2.

elim (point_equality_decidabilityG A B); intro HDiff1; [rewrite HDiff1 in *; clear HDiff1|].



  {

  assert (HEq : A' = B') by (apply g2_5 with B B; try apply g2_2; auto).

  rewrite HEq; auto.

  }



  {

  elim (g2_6 A' A); intro HBet3; intro HCong3.

  apply g2_3; apply g2_4; apply five_segmentG with A A' B B'; auto.

  apply g2_3; apply g2_4; auto.

  }

Qed.



Lemma g2_8 : forall A B C D,

  BetG A B C -> BetG A B D -> CongG B C B D -> A <> B -> C = D.

Proof.

intros A B C D HBet1 HBet2 HCong HDiff.

assert (HEq : CongG C C C D).

  {

  apply five_segmentG with A A B B; auto; try apply g2_1.

  apply g2_7 with B B; auto; apply g2_1.

  }

apply g2_5 with C C; auto; apply g2_2; auto.

Qed.



Lemma g2_9 : forall A B C, BetG A B A -> BetG C A B.

Proof.

intros A B C HBet.

apply bet_inner_transitivityG with A; auto; apply g2_6.

Qed.



Lemma g2_10 : forall A B C, BetG A B A -> BetG C B A.

Proof. intros A B C HBet; do 2 apply g2_9; auto. Qed.



Lemma g2_11 : forall A B C,

  BetG A B A -> A <> B ->

  exists D, BetG C D C /\ BetG D C D /\ C <> D.

Proof.

intros A B C HBet1 HDiff1.

destruct (segment_constructionG C C A B) as [D [HBet2 HCong1]].

assert (HDiff2 : C <> D)

  by (intro; apply g2_5 in HCong1; apply HDiff1; apply HCong1; auto).

destruct (segment_constructionG C D B A) as [E [HBet3 HCong2]].

assert (HCong3 : CongG C E A A) by (apply g2_7 with D B; auto).

assert (HEq : C = E) by (apply g2_5 in HCong3; apply HCong3; auto).

rewrite HEq in *; clear HEq; exists D; do 2 (split; auto); apply g2_9; auto.

Qed.



Lemma g2_12 : forall A B C, BetG A B A -> BetG A B C.

Proof. intros A B C HBet; apply bet_symmetryG; apply g2_10; auto. Qed.



Lemma g2_13 : forall A B C, BetG A B A -> A <> B -> BetG C B C.

Proof.

intros A B C HBet1 HDiff.

destruct (segment_constructionG C B B C) as [D [HBet2 HCong1]].

assert (HEq : C = D) by (apply g2_8 with A B; try apply g2_2; try apply g2_12; auto).

rewrite HEq in *; auto.

Qed.



Lemma g2_14 : forall A B C D, BetG A B A -> A <> B -> BetG C D C /\ BetG D C D.

Proof.

intros A B C D HBet1 HDiff1.

split.



  {

  destruct (g2_11 A B D) as [E [HBet2 [HBet3 HDiff2]]]; auto.

  apply g2_13 with E; auto.

  }



  {

  destruct (g2_11 A B C) as [E [HBet2 [HBet3 HDiff2]]]; auto.

  apply g2_13 with E; auto.

  }

Qed.



Lemma g2_15 : forall A B C D E, BetG A B A -> A <> B -> BetG C D E.

Proof.

intros A B C D E HBet HDiff.

apply g2_9. destruct (g2_14 A B D E) as [HBet1 HBet2]; auto.

Qed.



Lemma g2_16 : forall A B C D E, ~ BetG C D E -> BetG A B A -> A = B.

Proof.

intros A B C D E HNBet HBet.

elim (point_equality_decidabilityG A B); intro HDiff; auto.

exfalso; apply HNBet; apply g2_15 with A B; auto.

Qed.



Lemma between_identityT : forall A B, BetG A B A -> A = B.

Proof.

intros A B; apply g2_16 with GPA GPB GPC; intro HNBet; apply lower_dimG; left; auto.

Qed.



Lemma cong_trivial_identityT : forall A B, CongG A A B B.

Proof. intros A B; destruct (g2_6 B A); auto. Qed.



Lemma l2_11T : forall A B C A' B' C',

  BetG A B C -> BetG A' B' C' ->

  CongG A B A' B' -> CongG B C B' C' ->

  CongG A C A' C'.

Proof.

intros A B C A' B' C' HBet1 HBet2 HCong1 HCong2.

elim (point_equality_decidabilityG A B); intro HDiff; [rewrite HDiff in *; clear HDiff|].



  {

  assert (HEq : A' = B') by (apply g2_5 with B B; try apply g2_2; auto).

  rewrite HEq in *; auto.

  }



  {

  apply g2_3; apply g2_4; apply five_segmentG with A A' B B'; auto;

  try apply cong_trivial_identityT; apply g2_3; apply g2_4; auto.

  }

Qed.



Lemma construction_uniquenessT : forall Q A B C X Y,

  Q <> A -> BetG Q A X -> CongG A X B C -> BetG Q A Y -> CongG A Y B C -> X = Y.

Proof.

intros Q A B C X Y HDiff HBet1 HCong1 HBet2 HCong2.

assert (HCong3 : CongG A X A Y) by (apply cong_inner_transitivityG with B C; auto).

assert (HCong4 : CongG Q X Q Y) by (apply l2_11T with A A; auto; apply g2_1).

assert (HCong5 : CongG X X X Y)

  by (apply five_segmentG with Q Q A A; auto; apply g2_1).

apply g2_5 with X X; try apply g2_2; auto.

Qed.



Lemma between_trivialT : forall A B, BetG A B B.

Proof. intros A B; destruct (g2_6 A B); auto. Qed.



Lemma bet_decG : forall A B C, BetG A B C \/ ~ BetG A B C.

Proof.

intros A B C.

destruct (segment_constructionG A B B C) as [D [HBet1 HCong]].

elim (point_equality_decidabilityG C D); intro HDiff1; [rewrite HDiff1 in *; auto|].

elim (point_equality_decidabilityG A B); intro HDiff2;

[rewrite HDiff2 in *; left; apply bet_symmetryG; apply between_trivialT|].

right; intro HBet2; apply HDiff1; apply construction_uniquenessT with A B B C;

auto; apply g2_1.

Qed.



Definition ColG A B C := BetG A B C \/ BetG B C A \/ BetG C A B.



Lemma col_decG : forall A B C, ColG A B C \/ ~ ColG A B C.

Proof.

intros A B C; unfold ColG; induction (bet_decG A B C); induction (bet_decG B C A);

induction (bet_decG C A B); tauto.

Qed.



Lemma inner_paschT : forall A B C P Q,

  BetG A P C -> BetG B Q C ->

  exists x, BetG P x B /\ BetG Q x A.

Proof.

intros A B C P Q HBet1 HBet2.

elim (point_equality_decidabilityG A P); intro HDiff1;

[rewrite HDiff1 in *; exists P; split;

 [apply bet_symmetryG|]; apply between_trivialT|].

elim (point_equality_decidabilityG P C); intro HDiff2;

[rewrite HDiff2 in *; exists Q; split; apply bet_symmetryG;

 try apply between_trivialT; auto|].

elim (point_equality_decidabilityG B Q); intro HDiff3;

[rewrite HDiff3 in *; exists Q; split;

 [|apply bet_symmetryG]; apply between_trivialT|].

elim (point_equality_decidabilityG Q C); intro HDiff4;

[rewrite HDiff4 in *; exists P; split; apply bet_symmetryG;

 try apply between_trivialT; auto|].

elim (col_decG A B C); intro HCol; [|apply inner_paschG with C; auto].

do 2 (try (elim HCol; clear HCol; intro HCol)); rename HCol into HBet3.



  {

  exists B; split; [apply between_trivialT|].

  apply bet_symmetryG; apply bet_inner_transitivityG with C; auto.

  }



  {

  exists C; split.



    {

    apply bet_symmetryG; apply bet_inner_transitivityG with A;

    auto; apply bet_symmetryG; auto.

    }



    {

    apply bet_symmetryG; apply bet_inner_transitivityG with B;

    apply bet_symmetryG; auto.

    }

  }



  {

  exists A; split; [|apply between_trivialT].

  apply bet_symmetryG; apply bet_inner_transitivityG with C;

  auto; apply bet_symmetryG; auto.

  }

Qed.



Global Instance TG_to_T : Tarski_neutral_dimensionless.

Proof.

exact

(Build_Tarski_neutral_dimensionless TpointG BetG CongG

   cong_pseudo_reflexivityG cong_inner_transitivityT cong_identityG

   segment_constructionG five_segmentG

   between_identityT inner_paschT

   GPA GPB GPC

   lower_dimG).

Defined.



Global Instance TG_to_TID :

  Tarski_neutral_dimensionless_with_decidable_point_equality TG_to_T.

Proof. split; exact point_equality_decidabilityG. Defined.



End Gupta_inspired_variant_of_Tarski_neutral_dimensionless_to_Tarski_neutral_dimensionless.



Section Gupta_inspired_variant_of_Tarski_2D_to_Tarski_2D.



Context `{IT2D:Gupta_inspired_variant_of_Tarski_2D}.



Lemma upper_dimT : forall A B C P Q,

  P <> Q -> CongG A P A Q -> CongG B P B Q -> CongG C P C Q ->

  (BetG A B C \/ BetG B C A \/ BetG C A B).

Proof.

intros A B C P Q HPQ HCong1 HCong2 HCong3.

elim (point_equality_decidabilityG A B); intro HAB; try (rewrite HAB in *; clear HAB);

elim (point_equality_decidabilityG A C); intro HAC; try (rewrite HAC in *; clear HAC);

elim (point_equality_decidabilityG B C); intro HBC; try (rewrite HBC in *; clear HBC).



  {

  left; apply between_trivialT.

  }



  {

  right; right; apply between_trivialT.

  }



  {

  left; apply between_trivialT.

  }



  {

  right; right; apply between_trivialT.

  }



  {

  left; apply between_trivialT.

  }



  {

  right; left; apply between_trivialT.

  }



  {

  left; apply between_trivialT.

  }



  {

  apply upper_dimG with P Q; auto.

  }

Qed.



Global Instance TG2D_to_T2D : Tarski_2D TG_to_TID.

Proof. split; exact upper_dimT. Defined.



End Gupta_inspired_variant_of_Tarski_2D_to_Tarski_2D.



Section Gupta_inspired_variant_of_Tarski_euclidean_to_Tarski_euclidean.



Context `{ITE:Gupta_inspired_variant_of_Tarski_euclidean}.



Lemma euclidT : forall A B C D T,

  Bet A D T -> Bet B D C -> A <> D ->

  exists X, exists Y, Bet A B X /\ Bet A C Y /\ Bet X T Y.

Proof.

assert (H := TG_to_TID).

intros A B C D T HBet1 HBet2 HDiff1.

elim (eq_dec_points B D); intro HDiff2;

[treat_equalities; exists T, C; Between|].

elim (eq_dec_points D C); intro HDiff3;

[treat_equalities; exists B, T; Between|].

elim (col_dec A B C); intro HCol; [|apply euclidG with D; auto].

clear HDiff2; clear HDiff3.

do 2 (try (elim HCol; clear HCol; intro HCol)); rename HCol into HBet3.



  {

  elim (eq_dec_points A B); intro HDiff2;

  [treat_equalities; exists T; exists C; Between|].

  elim (l5_2 A B C T); eBetween; intro HBet4.



    {

    elim (eq_dec_points B C); intro HDiff3;

    [treat_equalities; exists T; exists T; Between|].

    exists B; exists T; do 2 (split; Between); eBetween.

    }



    {

    elim (eq_dec_points B T); intro HDiff3;

    [treat_equalities; exists B; exists C; Between|].

    exists B; exists C; Between.

    }

  }



  {

  elim (eq_dec_points A C); intro HDiff2;

  [treat_equalities; exists B; exists T; Between|].

  elim (l5_2 A C B T); eBetween; intro HBet4.



    {

    elim (eq_dec_points B C); intro HDiff3;

    [treat_equalities; exists T; exists T; Between|].

    exists T; exists C; repeat (split; Between); eBetween.

    }



    {

    exists B; exists C; Between.

    }

  }



  {

  elim (l5_3 B A D C); Between; intro HBet4.



    {

    elim (eq_dec_points A B); intro HDiff2;

    [treat_equalities; exists T; exists C; Between|].

    elim (l5_2 B A C T); eBetween; intro HBet5.



      {

      exists B; exists T; Between.

      }



      {

      exists B; exists C; do 2 (split; Between).

      apply outer_transitivity_between2 with A; eBetween.

      intro; treat_equalities; intuition.

      }

    }



    {

    elim (l5_2 A D B T); Between; intro HBet5.



      {

      elim (eq_dec_points B D); intro HDiff2;

      [treat_equalities; exists T; exists C; Between|].

      exists T; exists C; do 2 (try split; Between); eBetween.

      }



      {

      exists B; exists C; do 2 (split; Between).

      apply outer_transitivity_between with A; eBetween;

      try (intro; treat_equalities; intuition).

      }

    }

  }

Qed.



Global Instance TG_euclidean_to_T_euclidean :

  Tarski_euclidean TG_to_TID.

Proof. split; exact euclidT. Defined.



End Gupta_inspired_variant_of_Tarski_euclidean_to_Tarski_euclidean.
