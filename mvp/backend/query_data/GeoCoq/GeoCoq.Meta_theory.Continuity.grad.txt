Require Import GeoCoq.Tarski_dev.Ch08_orthogonality.
(* GeoCoq.Tarski_dev.Ch08_orthogonality:
Require Export GeoCoq.Tarski_dev.Ch07_midpoint.

Require Export GeoCoq.Tactics.Coinc.ColR.

Ltac not_exist_hyp_perm_ncol A B C := not_exist_hyp (~ Col A B C); not_exist_hyp (~ Col A C B);
                                 not_exist_hyp (~ Col B A C); not_exist_hyp (~ Col B C A);
                                 not_exist_hyp (~ Col C A B); not_exist_hyp (~ Col C B A).

Ltac assert_diffs_by_cases :=
 repeat match goal with
 | A: Tpoint, B: Tpoint |- _ => not_exist_hyp_comm A B;induction (eq_dec_points A B);[treat_equalities;solve [finish|trivial] |idtac]
end.

Ltac assert_cols :=
repeat
 match goal with
      | H:Bet ?X1 ?X2 ?X3 |- _ =>
     not_exist_hyp_perm_col X1 X2 X3;assert (Col X1 X2 X3) by (apply bet_col;apply H)

      | H:Midpoint ?X1 ?X2 ?X3 |- _ =>
     not_exist_hyp_perm_col X1 X2 X3;let N := fresh in assert (N := midpoint_col X2 X1 X3 H)

      | H:Out ?X1 ?X2 ?X3 |- _ =>
     not_exist_hyp_perm_col X1 X2 X3;let N := fresh in assert (N := out_col X1 X2 X3 H)
 end.

Ltac assert_bets :=
repeat
 match goal with
      | H:Midpoint ?B ?A ?C |- _ => let T := fresh in not_exist_hyp (Bet A B C); assert (T := midpoint_bet A B C H)
 end.

Ltac clean_reap_hyps :=
  clean_duplicated_hyps;
  repeat
  match goal with
   | H:(Midpoint ?A ?B ?C), H2 : Midpoint ?A ?C ?B |- _ => clear H2
   | H:(Col ?A ?B ?C), H2 : Col ?A ?C ?B |- _ => clear H2
   | H:(Col ?A ?B ?C), H2 : Col ?B ?A ?C |- _ => clear H2
   | H:(Col ?A ?B ?C), H2 : Col ?B ?C ?A |- _ => clear H2
   | H:(Col ?A ?B ?C), H2 : Col ?C ?B ?A |- _ => clear H2
   | H:(Col ?A ?B ?C), H2 : Col ?C ?A ?B |- _ => clear H2
   | H:(Bet ?A ?B ?C), H2 : Bet ?C ?B ?A |- _ => clear H2
   | H:(Cong ?A ?B ?C ?D), H2 : Cong ?A ?B ?D ?C |- _ => clear H2
   | H:(Cong ?A ?B ?C ?D), H2 : Cong ?C ?D ?A ?B |- _ => clear H2
   | H:(Cong ?A ?B ?C ?D), H2 : Cong ?C ?D ?B ?A |- _ => clear H2
   | H:(Cong ?A ?B ?C ?D), H2 : Cong ?D ?C ?B ?A |- _ => clear H2
   | H:(Cong ?A ?B ?C ?D), H2 : Cong ?D ?C ?A ?B |- _ => clear H2
   | H:(Cong ?A ?B ?C ?D), H2 : Cong ?B ?A ?C ?D |- _ => clear H2
   | H:(Cong ?A ?B ?C ?D), H2 : Cong ?B ?A ?D ?C |- _ => clear H2
   | H:(?A<>?B), H2 : (?B<>?A) |- _ => clear H2
end.

Ltac assert_diffs :=
repeat
 match goal with
      | H:(~Col ?X1 ?X2 ?X3) |- _ =>
      let h := fresh in
      not_exist_hyp3 X1 X2 X1 X3 X2 X3;
      assert (h := not_col_distincts X1 X2 X3 H);decompose [and] h;clear h;clean_reap_hyps

      | H:(~Bet ?X1 ?X2 ?X3) |- _ =>
      let h := fresh in
      not_exist_hyp2 X1 X2 X2 X3;
      assert (h := not_bet_distincts X1 X2 X3 H);decompose [and] h;clear h;clean_reap_hyps
      | H:Bet ?A ?B ?C, H2 : ?A <> ?B |-_ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= bet_neq12__neq A B C H H2);clean_reap_hyps
      | H:Bet ?A ?B ?C, H2 : ?B <> ?A |-_ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= bet_neq21__neq A B C H H2);clean_reap_hyps
      | H:Bet ?A ?B ?C, H2 : ?B <> ?C |-_ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= bet_neq23__neq A B C H H2);clean_reap_hyps
      | H:Bet ?A ?B ?C, H2 : ?C <> ?B |-_ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= bet_neq32__neq A B C H H2);clean_reap_hyps

      | H:Cong ?A ?B ?C ?D, H2 : ?A <> ?B |-_ =>
      let T:= fresh in (not_exist_hyp_comm C D);
        assert (T:= cong_diff A B C D H2 H);clean_reap_hyps
      | H:Cong ?A ?B ?C ?D, H2 : ?B <> ?A |-_ =>
      let T:= fresh in (not_exist_hyp_comm C D);
        assert (T:= cong_diff_2 A B C D H2 H);clean_reap_hyps
      | H:Cong ?A ?B ?C ?D, H2 : ?C <> ?D |-_ =>
      let T:= fresh in (not_exist_hyp_comm A B);
        assert (T:= cong_diff_3 A B C D H2 H);clean_reap_hyps
      | H:Cong ?A ?B ?C ?D, H2 : ?D <> ?C |-_ =>
      let T:= fresh in (not_exist_hyp_comm A B);
        assert (T:= cong_diff_4 A B C D H2 H);clean_reap_hyps

      | H:Le ?A ?B ?C ?D, H2 : ?A <> ?B |-_ =>
      let T:= fresh in (not_exist_hyp_comm C D);
        assert (T:= le_diff A B C D H2 H);clean_reap_hyps
      | H:Lt ?A ?B ?C ?D |-_ =>
      let T:= fresh in (not_exist_hyp_comm C D);
        assert (T:= lt_diff A B C D H);clean_reap_hyps

      | H:Midpoint ?I ?A ?B, H2 : ?A<>?B |- _ =>
      let T:= fresh in (not_exist_hyp2 I B I A);
       assert (T:= midpoint_distinct_1 I A B H2 H);
       decompose [and] T;clear T;clean_reap_hyps
      | H:Midpoint ?I ?A ?B, H2 : ?B<>?A |- _ =>
      let T:= fresh in (not_exist_hyp2 I B I A);
       assert (T:= midpoint_distinct_1 I A B (swap_diff B A H2) H);
       decompose [and] T;clear T;clean_reap_hyps

      | H:Midpoint ?I ?A ?B, H2 : ?I<>?A |- _ =>
      let T:= fresh in (not_exist_hyp2 I B A B);
       assert (T:= midpoint_distinct_2 I A B H2 H);
       decompose [and] T;clear T;clean_reap_hyps
      | H:Midpoint ?I ?A ?B, H2 : ?A<>?I |- _ =>
      let T:= fresh in (not_exist_hyp2 I B A B);
       assert (T:= midpoint_distinct_2 I A B (swap_diff A I H2) H);
       decompose [and] T;clear T;clean_reap_hyps

      | H:Midpoint ?I ?A ?B, H2 : ?I<>?B |- _ =>
      let T:= fresh in (not_exist_hyp2 I A A B);
       assert (T:= midpoint_distinct_3 I A B H2 H);
       decompose [and] T;clear T;clean_reap_hyps
      | H:Midpoint ?I ?A ?B, H2 : ?B<>?I |- _ =>
      let T:= fresh in (not_exist_hyp2 I A A B);
       assert (T:= midpoint_distinct_3 I A B (swap_diff B I H2) H);
       decompose [and] T;clear T;clean_reap_hyps

      | H:Out ?A ?B ?C |- _ =>
      let T:= fresh in (not_exist_hyp2 A B A C);
       assert (T:= out_distinct A B C H);
       decompose [and] T;clear T;clean_reap_hyps
 end.

Ltac clean_trivial_hyps :=
  repeat
  match goal with
   | H:(Cong ?X1 ?X1 ?X2 ?X2) |- _ => clear H
   | H:(Cong ?X1 ?X2 ?X2 ?X1) |- _ => clear H
   | H:(Cong ?X1 ?X2 ?X1 ?X2) |- _ => clear H
   | H:(Bet ?X1 ?X1 ?X2) |- _ => clear H
   | H:(Bet ?X2 ?X1 ?X1) |- _ => clear H
   | H:(Col ?X1 ?X1 ?X2) |- _ => clear H
   | H:(Col ?X2 ?X1 ?X1) |- _ => clear H
   | H:(Col ?X1 ?X2 ?X1) |- _ => clear H
   | H:(Midpoint ?X1 ?X1 ?X1) |- _ => clear H
end.

Ltac clean := clean_trivial_hyps;clean_reap_hyps.

Ltac treat_equalities :=
try treat_equalities_aux;
repeat
  match goal with
   | H:(Cong ?X3 ?X3 ?X1 ?X2) |- _ =>
      apply cong_symmetry in H; apply cong_identity in H;
      smart_subst X2;clean_reap_hyps
   | H:(Cong ?X1 ?X2 ?X3 ?X3) |- _ =>
      apply cong_identity in H;smart_subst X2;clean_reap_hyps
   | H:(Bet ?X1 ?X2 ?X1) |- _ =>
      apply  between_identity in H;smart_subst X2;clean_reap_hyps
   | H:(Midpoint ?X ?Y ?Y) |- _ => apply l7_3 in H; smart_subst Y;clean_reap_hyps
   | H : Bet ?A ?B ?C, H2 : Bet ?B ?A ?C |- _ =>
     let T := fresh in not_exist_hyp (A=B); assert (T : A=B) by (apply (between_equality A B C); finish);
                       smart_subst A;clean_reap_hyps
   | H : Bet ?A ?B ?C, H2 : Bet ?A ?C ?B |- _ =>
     let T := fresh in not_exist_hyp (B=C); assert (T : B=C) by (apply (between_equality_2 A B C); finish);
                       smart_subst B;clean_reap_hyps
   | H : Bet ?A ?B ?C, H2 : Bet ?C ?A ?B |- _ =>
     let T := fresh in not_exist_hyp (A=B); assert (T : A=B) by (apply (between_equality A B C); finish);
                       smart_subst A;clean_reap_hyps
   | H : Bet ?A ?B ?C, H2 : Bet ?B ?C ?A |- _ =>
     let T := fresh in not_exist_hyp (B=C); assert (T : B=C) by (apply (between_equality_2 A B C); finish);
                       smart_subst A;clean_reap_hyps
   | H:(Le ?X1 ?X2 ?X3 ?X3) |- _ =>
      apply le_zero in H;smart_subst X2;clean_reap_hyps
   | H : Midpoint ?P ?A ?P1, H2 : Midpoint ?P ?A ?P2 |- _ =>
     let T := fresh in not_exist_hyp (P1=P2);
                      assert (T := symmetric_point_uniqueness A P P1 P2 H H2);
                      smart_subst P1;clean_reap_hyps
   | H : Midpoint ?A ?P ?X, H2 : Midpoint ?A ?Q ?X |- _ =>
     let T := fresh in not_exist_hyp (P=Q); assert (T := l7_9 P Q A X H H2);
                       smart_subst P;clean_reap_hyps
   | H : Midpoint ?A ?P ?X, H2 : Midpoint ?A ?X ?Q |- _ =>
     let T := fresh in not_exist_hyp (P=Q); assert (T := l7_9_bis P Q A X H H2);
                       smart_subst P;clean_reap_hyps
   | H : Midpoint ?M ?A ?A |- _ =>
     let T := fresh in not_exist_hyp (M=A); assert (T : l7_3 M A H);
                       smart_subst M;clean_reap_hyps
   | H : Midpoint ?A ?P ?P', H2 : Midpoint ?B ?P ?P' |- _ =>
     let T := fresh in not_exist_hyp (A=B); assert (T := l7_17 P P' A B H H2);
                       smart_subst A;clean_reap_hyps
   | H : Midpoint ?A ?P ?P', H2 : Midpoint ?B ?P' ?P |- _ =>
     let T := fresh in not_exist_hyp (A=B); assert (T := l7_17_bis P P' A B H H2);
                       smart_subst A;clean_reap_hyps
   | H : Midpoint ?A ?B ?A |- _ =>
     let T := fresh in not_exist_hyp (A=B); assert (T := is_midpoint_id_2 A B H);
                       smart_subst A;clean_reap_hyps
   | H : Midpoint ?A ?A ?B |- _ =>
     let T := fresh in not_exist_hyp (A=B); assert (T := is_midpoint_id A B H);
                       smart_subst A;clean_reap_hyps
end.

Ltac ColR :=
 let tpoint := constr:(Tpoint) in
 let col := constr:(Col) in
   treat_equalities; assert_cols; assert_diffs; try (solve [Col]); Col_refl tpoint col.

Ltac search_contradiction :=
 match goal with
  | H: ?A <> ?A |- _ => exfalso;apply H;reflexivity
  | H: ~ Col ?A ?B ?C |- _ => exfalso;apply H;ColR
  | H: ~ ?P, H2 : ?P |- _ => exfalso;apply (H H2)
 end.

Ltac show_distinct' X Y :=
 assert (X<>Y);
 [intro;treat_equalities; (solve [search_contradiction])|idtac].

Ltac assert_all_diffs_by_contradiction :=
repeat match goal with
 | A: Tpoint, B: Tpoint |- _ => not_exist_hyp_comm A B;show_distinct' A B
end.

Section T8_1.

Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.

Lemma per_dec : forall A B C, Per A B C \/ ~ Per A B C.

Lemma l8_2 : forall A B C, Per A B C -> Per C B A.

End T8_1.

Hint Resolve l8_2 : perp.

Ltac Perp := auto with perp.

Section T8_2.

Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.

Lemma Per_cases :
 forall A B C,
 Per A B C \/ Per C B A ->
 Per A B C.

Lemma Per_perm :
 forall A B C,
 Per A B C ->
 Per A B C /\ Per C B A.

Lemma l8_3 : forall A B C A',
 Per A B C -> A<>B -> Col B A A' -> Per A' B C.

Lemma l8_4 : forall A B C C', Per A B C -> Midpoint B C C' -> Per A B C'.

Lemma l8_5 : forall A B, Per A B B.

Lemma l8_6 : forall A B C A', Per A B C -> Per A' B C -> Bet A C A' -> B=C.

End T8_2.

Hint Resolve l8_5 : perp.

Ltac let_symmetric C P A :=
let id1:=fresh in (assert (id1:(exists A', Midpoint P A A'));
[apply symmetric_point_construction|ex_and id1 C]).

Ltac symmetric B' A B :=
assert(sp:= symmetric_point_construction B A); ex_and sp B'.

Section T8_3.

Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.

Lemma l8_7 : forall A B C, Per A B C -> Per A C B -> B=C.

Lemma l8_8 : forall A B, Per A B A -> A=B.

Lemma per_distinct : forall A B C, Per A B C -> A <> B -> A <> C.

Lemma per_distinct_1 : forall A B C, Per A B C -> B <> C -> A <> C.

Lemma l8_9 : forall A B C, Per A B C -> Col A B C -> A=B \/ C=B.

Lemma l8_10 : forall A B C A' B' C',  Per A B C -> Cong_3 A B C A' B' C' -> Per A' B' C'.

Lemma col_col_per_per : forall A X C U V,
 A<>X -> C<>X ->
 Col U A X ->
 Col V C X ->
 Per A X C ->
 Per U X V.

Lemma perp_in_dec : forall X A B C D, Perp_at X A B C D \/ ~ Perp_at X A B C D.

Lemma perp_distinct : forall A B C D, Perp A B C D -> A <> B /\ C <> D.

Lemma l8_12 : forall A B C D X, Perp_at X A B C D -> Perp_at X C D A B.

Lemma per_col : forall A B C D,
 B <> C -> Per A B C -> Col B C D -> Per A B D.

Lemma l8_13_2 : forall A B C D X,
   A <> B -> C <> D -> Col X A B -> Col X C D ->
  (exists U, exists V :Tpoint, Col U A B /\ Col V C D /\ U<>X /\ V<>X /\ Per U X V) ->
  Perp_at X A B C D.

Lemma l8_14_1 : forall A B, ~ Perp A B A B.

Lemma l8_14_2_1a : forall X A B C D, Perp_at X A B C D -> Perp A B C D.

Lemma perp_in_distinct : forall X A B C D , Perp_at X A B C D -> A <> B /\ C <> D.

Lemma l8_14_2_1b : forall X A B C D Y, Perp_at X A B C D -> Col Y A B -> Col Y C D -> X=Y.

Lemma l8_14_2_1b_bis : forall A B C D X, Perp A B C D -> Col X A B -> Col X C D -> Perp_at X A B C D.

Lemma l8_14_2_2 : forall X A B C D,
 Perp A B C D -> (forall Y, Col Y A B -> Col Y C D -> X=Y) ->  Perp_at X A B C D.

Lemma l8_14_3 : forall A B C D X Y, Perp_at X A B C D -> Perp_at Y A B C D -> X=Y.

Lemma l8_15_1 : forall A B C X, Col A B X -> Perp A B C X -> Perp_at X A B C X.

Lemma l8_15_2 : forall A B C X, Col A B X ->  Perp_at X A B C X -> Perp A B C X.

Lemma perp_in_per : forall A B C, Perp_at B A B B C-> Per A B C.

Lemma perp_sym : forall A B C D, Perp A B C D -> Perp C D A B.

Lemma perp_col0 : forall A B C D X Y, Perp A B C D -> X <> Y -> Col A B X -> Col A B Y -> Perp C D X Y.

Lemma per_perp_in : forall A B C, A <> B -> B <> C -> Per A B C -> Perp_at B A B B C.

Lemma per_perp : forall A B C, A <> B -> B <> C -> Per A B C -> Perp A B B C.

Lemma perp_left_comm : forall A B C D, Perp A B C D -> Perp B A C D.

Lemma perp_right_comm : forall A B C D, Perp A B C D -> Perp A B D C.

Lemma perp_comm : forall A B C D, Perp A B C D -> Perp B A D C.

Lemma perp_in_sym :
 forall A B C D X,
  Perp_at X A B C D -> Perp_at X C D A B.

Lemma perp_in_left_comm :
 forall A B C D X,
  Perp_at X A B C D -> Perp_at X B A C D.

Lemma perp_in_right_comm : forall A B C D X, Perp_at X A B C D -> Perp_at X A B D C.

Lemma perp_in_comm : forall A B C D X, Perp_at X A B C D -> Perp_at X B A D C.

End T8_3.

Hint Resolve perp_sym perp_left_comm perp_right_comm perp_comm per_perp_in per_perp
             perp_in_per perp_in_left_comm perp_in_right_comm perp_in_comm perp_in_sym : perp.

Ltac double A B A' :=
   assert (mp:= symmetric_point_construction A B);
   elim mp; intros A' ; intro; clear mp.

Section T8_4.

Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.

Lemma Perp_cases :
  forall A B C D,
  Perp A B C D \/ Perp B A C D \/ Perp A B D C \/ Perp B A D C \/
  Perp C D A B \/ Perp C D B A \/ Perp D C A B \/ Perp D C B A ->
  Perp A B C D.

Lemma Perp_perm :
  forall A B C D,
  Perp A B C D ->
  Perp A B C D /\ Perp B A C D /\ Perp A B D C /\ Perp B A D C /\
  Perp C D A B /\ Perp C D B A /\ Perp D C A B /\ Perp D C B A.

Lemma Perp_in_cases :
  forall X A B C D,
  Perp_at X A B C D \/ Perp_at X B A C D \/ Perp_at X A B D C \/ Perp_at X B A D C \/
  Perp_at X C D A B \/ Perp_at X C D B A \/ Perp_at X D C A B \/ Perp_at X D C B A ->
  Perp_at X A B C D.

Lemma Perp_in_perm :
  forall X A B C D,
  Perp_at X A B C D ->
  Perp_at X A B C D /\ Perp_at X B A C D /\ Perp_at X A B D C /\ Perp_at X B A D C /\
  Perp_at X C D A B /\ Perp_at X C D B A /\ Perp_at X D C A B /\ Perp_at X D C B A.

Lemma perp_in_col : forall A B C D X, Perp_at X A B C D -> Col A B X /\ Col C D X.

Lemma perp_perp_in : forall A B C, Perp A B C A -> Perp_at A A B C A.

Lemma perp_per_1 : forall A B C, Perp A B C A -> Per B A C.

Lemma perp_per_2 : forall A B C, Perp A B A C -> Per B A C.

Lemma perp_col : forall A B C D E, A<>E -> Perp A B C D -> Col A B E -> Perp A E C D.

Lemma perp_col2 : forall A B C D  X Y,
  Perp A B X Y ->
  C <> D -> Col A B C -> Col A B D -> Perp C D X Y.

Lemma perp_not_eq_1 : forall A B C D, Perp A B C D -> A<>B.

Lemma perp_not_eq_2 : forall A B C D, Perp A B C D -> C<>D.

Lemma diff_per_diff : forall A B P R ,
      A <> B -> Cong A P B R -> Per B A P -> Per A B R -> P <> R.

Lemma per_not_colp : forall A B P R, A <> B -> A <> P -> B <> R -> Per B A P -> Per A B R -> ~Col P A R.

Lemma per_not_col : forall A B C, A <> B -> B <> C -> Per A B C -> ~Col A B C.

Lemma perp_not_col2 : forall A B C D, Perp A B C D -> ~ Col A B C \/ ~ Col A B D.

Lemma perp_not_col : forall A B P, Perp A B P A -> ~ Col A B P.

Lemma perp_in_col_perp_in : forall A B C D E P, C <> E -> Col C D E -> Perp_at P A B C D -> Perp_at P A B C E.

Lemma perp_col2_bis : forall A B C D P Q,
  Perp A B P Q ->
  Col C D P ->
  Col C D Q ->
  C <> D ->
  Perp A B C D.

Lemma perp_in_perp_bis : forall A B C D X,
 Perp_at X A B C D -> Perp X B C D \/ Perp A X C D.

Lemma col_per_perp : forall A B C D,
 A <> B -> B <> C -> D <> B -> D <> C ->
 Col B C D -> Per A B C -> Perp C D A B.

Lemma per_cong_mid : forall A B C H,
 B <> C -> Bet A B C -> Cong A H C H -> Per H B C ->
 Midpoint B A C.

Lemma per_double_cong : forall A B C C',
 Per A B C -> Midpoint B C C' -> Cong A C A C'.

Lemma cong_perp_or_mid : forall A B M X, A <> B -> Midpoint M A B -> Cong A X B X ->
 X = M \/ ~Col A B X /\ Perp_at M X M A B.

Lemma col_per2_cases : forall A B C D B', 
 B <> C -> B' <> C -> C <> D -> Col B C D -> Per A B C -> Per A B' C -> 
 B = B' \/ ~Col B' C D.

Lemma l8_16_1 : forall A B C U X,
  Col A B X -> Col A B U -> Perp A B C X -> ~ Col A B C /\ Per C X U.

Lemma l8_16_2 : forall A B C U X,
  Col A B X -> Col A B U -> U<>X -> ~ Col A B C -> Per C X U -> Perp A B C X.

Lemma l8_18_uniqueness : forall A B C X Y,
  ~ Col A B C -> Col A B X -> Perp A B C X -> Col A B Y -> Perp A B C Y -> X=Y.

Lemma midpoint_distinct : forall A B X C C', ~ Col A B C -> Col A B X -> Midpoint X C C' -> C <> C'.

Lemma l8_20_1 : forall A B C C' D P,
  Per A B C -> Midpoint P C' D -> Midpoint A C' C -> Midpoint B D C -> Per B A P.

Lemma l8_20_2 : forall A B C C' D P,
  Per A B C -> Midpoint P C' D -> Midpoint A C' C -> Midpoint B D C -> B<>C -> A<>P.

Lemma perp_col1 : forall A B C D X,
 C <> X -> Perp A B C D -> Col C D X -> Perp A B C X.

Lemma l8_18_existence : forall A B C, ~ Col A B C -> exists X, Col A B X /\ Perp A B C X.

Lemma l8_21_aux : forall A B C,
 ~ Col A B C -> exists P, exists T, Perp A B P A /\ Col A B T /\ Bet C T P.

Lemma l8_21 : forall A B C,
 A <> B -> exists P, exists T, Perp A B P A /\ Col A B T /\ Bet C T P.

Lemma per_cong : forall A B P R X ,
 A <> B -> A <> P ->
 Per B A P -> Per A B R ->
 Cong A P B R -> Col A B X -> Bet P X R ->
 Cong A R P B.

Lemma perp_cong : forall A B P R X,
 A <> B -> A <> P ->
 Perp A B P A -> Perp A B R B ->
 Cong A P B R -> Col A B X -> Bet P X R ->
 Cong A R P B.

Lemma perp_exists : forall O A B, A <> B -> exists X, Perp O X A B.

Lemma perp_vector : forall A B, A <> B -> (exists X, exists Y, Perp A B X Y).

Lemma midpoint_existence_aux : forall A B P Q T,
  A<>B -> Perp A B Q B -> Perp A B P A ->
  Col A B T -> Bet Q T P -> Le A P B Q ->
  exists X : Tpoint, Midpoint X A B.

Lemma midpoint_existence : forall A B, exists X, Midpoint X A B.

Lemma perp_in_id : forall A B C X, Perp_at X A B C A -> X = A.

Lemma l8_22 : forall A B P R X ,
 A <> B -> A <> P ->
 Per B A P -> Per A B R ->
 Cong A P B R -> Col A B X -> Bet P X R ->
 Cong A R P B /\ Midpoint X A B /\ Midpoint X P R.

Lemma l8_22_bis : forall A B P R X,
 A <> B -> A <> P ->
 Perp A B P A -> Perp A B R B ->
 Cong A P B R -> Col A B X -> Bet P X R ->
 Cong A R P B /\ Midpoint X A B /\ Midpoint X P R.

Lemma perp_in_perp : forall A B C D X, Perp_at X A B C D -> Perp A B C D.

End T8_4.

Hint Resolve perp_per_1 perp_per_2 perp_col perp_perp_in perp_in_perp : perp.

Section T8_5.

Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.

Lemma perp_proj : forall A B C D, Perp A B C D -> ~Col A C D -> exists X, Col A B X /\ Perp A X C D.

Lemma l8_24 : forall A B P Q R T,
 Perp P A A B ->
 Perp Q B A B ->
 Col A B T ->
 Bet P T Q ->
 Bet B R Q ->
 Cong A P B R ->
 exists X, Midpoint X A B /\ Midpoint X P R.

Lemma col_per2__per : forall A B C P X, A <> B -> Col A B C -> Per A X P -> Per B X P -> Per C X P.

Lemma perp_in_per_1 :
 forall A B C D X,
  Perp_at X A B C D ->
  Per A X C.

Lemma perp_in_per_2 :
 forall A B C D X,
  Perp_at X A B C D ->
  Per A X D.

Lemma perp_in_per_3 :
 forall A B C D X,
  Perp_at X A B C D ->
  Per B X C.

Lemma perp_in_per_4 :
 forall A B C D X,
  Perp_at X A B C D ->
  Per B X D.

End T8_5.

Hint Resolve perp_in_per_1 perp_in_per_2 perp_in_per_3 perp_in_per_4 : perp.

Ltac midpoint M A B :=
 let T:= fresh in assert (T:= midpoint_existence A B);
 ex_and T M.

Tactic Notation "Name" ident(M) "the" "midpoint" "of" ident(A) "and" ident(B) :=
 midpoint M A B. *)

Require Import Relations.



Section Grad.



Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.



Lemma grad__bet : forall A B C, Grad A B C -> Bet A B C.

Proof.

  intros A B C HG.

  elim HG; clear HG A B C; [Between|eBetween].

Qed.



Lemma grad__col : forall A B C, Grad A B C -> Col A B C.

Proof.

  intros; apply bet_col, grad__bet; assumption.

Qed.



Lemma grad_neq__neq13 : forall A B C, Grad A B C -> A <> B -> A <> C.

Proof.

  intros A B C HG HAB Heq.

  subst C.

  apply HAB.

  apply between_identity, grad__bet; trivial.

Qed.



Lemma grad_neq__neq12 : forall A B C, Grad A B C -> A <> C -> A <> B.

Proof.

  intros A B C HG.

  elim HG; clear HG A B C; intros; intro; treat_equalities.

    auto.

  apply H0; auto.

Qed.



Lemma grad112__eq : forall A B, Grad A A B -> A = B.

Proof.

  intros A B HG.

  assert (HA' : exists A', A' = A /\ Grad A A' B) by (exists A; auto).

  destruct HA' as [A' [Heq HG']].

  clear HG.

  revert Heq.

  elim HG'; auto.

  clear HG' A B A'.

  intros; treat_equalities; auto.

Qed.



Lemma grad121__eq : forall A B, Grad A B A -> A = B.

Proof.

  intros A B HG.

  apply between_identity, grad__bet; trivial.

Qed.



Lemma grad__le : forall A B C, Grad A B C -> Le A B A C.

Proof.

  intros.

  apply grad__bet in H.

  apply l5_12_a in H; spliter; auto.

Qed.



Lemma grad2__grad123 : forall A B C D E F, Grad2 A B C D E F -> Grad A B C.

Proof.

  intros A B C D E F.

  induction 1.

    apply grad_init.

    apply (grad_stab _ _ C); auto.

Qed.



Lemma grad2__grad456 : forall A B C D E F, Grad2 A B C D E F -> Grad D E F.

Proof.

  intros A B C D E F.

  induction 1.

    apply grad_init.

    apply (grad_stab _ _ F); auto.

Qed.



Lemma grad_sum : forall A B C D E,

  Grad A B C -> Grad A B D -> Bet A C E -> Cong A D C E ->

  Grad A B E.

Proof.

  intros A B C D E HGC HGD.

  elim (eq_dec_points A B).

  { intros; subst B.

    assert(A = C) by (apply grad112__eq; trivial).

    assert(A = D) by (apply grad112__eq; trivial).

    treat_equalities; trivial.

  }

  intro HAB.

  revert E.

  induction HGD.

    intro E; apply grad_stab; trivial.

  rename C0 into D; rename C' into D'.

  intros E' HBet' HCong'.

  destruct(segment_construction A C A D) as [E [HBet HCong]].

  assert (HBet1 : Bet A B C) by (apply grad__bet; trivial).

  assert (HBet2 : Bet A B D) by (apply grad__bet; trivial).

  assert(HBet3 : Bet C E E').

  { apply l6_13_1.

      assert_diffs; apply l6_2 with A; Between.

    apply (l5_6 A D A D'); Cong.

    apply bet__le1213; trivial.

  }

  apply grad_stab with E; auto with cong; eBetween.

  apply cong_transitivity with D D'; auto.

  apply l4_3_1 with A C; Cong.

Qed.



Lemma gradexp__grad : forall A B C, GradExp A B C -> Grad A B C.

Proof.

  induction 1.

    apply grad_init.

  apply grad_sum with C C; auto.

Qed.



Lemma gradexp_le__reach : forall A B C D B',

  GradExp A B B' -> Le C D A B' ->

  Reach A B C D.

Proof.

  intros A B C D B' HGE HLe.

  exists B'; split; trivial.

  apply gradexp__grad; trivial.

Qed.



Lemma grad__ex_gradexp_le : forall A B C,

  Grad A B C ->

  exists D, GradExp A B D /\ Le A C A D.

Proof.

  intros A B C.

  induction 1.

    exists B; split; Le; apply gradexp_init.

  destruct IHGrad as [D [HGE HLe]].

  destruct (segment_construction A D A D) as [D' [HBet HCong]].

  exists D'; split.

    apply gradexp_stab with D; Cong.

  apply bet2_le2__le1346 with C D; Le.

  apply gradexp__grad, grad__bet in HGE.

  apply l5_6 with A B A D; Cong; Le.

Qed.



Lemma reach__ex_gradexp_le : forall A B C D, Reach A B C D ->

  exists B', GradExp A B B' /\ Le C D A B'.

Proof.

  intros A B C D HR.

  destruct HR as [B0 [HG HLe]].

  destruct (grad__ex_gradexp_le A B B0 HG) as [B' [HG2 HLe2]].

  exists B'; split; trivial.

  apply le_transitivity with A B0; trivial.

Qed.



Lemma gradexp2__gradexp123 : forall A B C D E F,

  GradExp2 A B C D E F ->

  GradExp A B C.

Proof.

  intros A B C D E F.

  induction 1.

    apply gradexp_init.

  apply (gradexp_stab _ _ C); auto.

Qed.



Lemma gradexp2__gradexp456 : forall A B C D E F,

  GradExp2 A B C D E F ->

  GradExp D E F.

Proof.

  intros A B C D E F.

  induction 1.

    apply gradexp_init.

  apply (gradexp_stab _ _ F); auto.

Qed.



Inductive GradExpInv : Tpoint -> Tpoint -> Tpoint -> Prop :=

    gradexpinv_init : forall A B, GradExpInv A B B

  | gradexpinv_stab : forall A B B' C, Bet A B' B -> Cong A B' B' B -> GradExpInv A B C ->

                    GradExpInv A B' C.



Lemma gradexp_clos_trans : forall A B C, GradExp A B C <->

  clos_refl_trans_n1 Tpoint (fun X Y => Midpoint X A Y) B C.

Proof.

  intros; split; induction 1.

  - constructor.

  - apply Relation_Operators.rtn1_trans with C; [split|]; assumption.

  - constructor.

  - apply gradexp_stab with y; finish.

Qed.



Lemma gradexpinv_clos_trans : forall A B C, GradExpInv A B C <->

  clos_refl_trans_1n Tpoint (fun X Y => Midpoint X A Y) B C.

Proof.

  intros; split; induction 1.

  - constructor.

  - apply Relation_Operators.rt1n_trans with B; [split|]; assumption.

  - constructor.

  - apply gradexpinv_stab with y; finish.

Qed.



Lemma gradexp__gradexpinv : forall A B C, GradExp A B C <-> GradExpInv A B C.

Proof.

  intros.

  rewrite gradexp_clos_trans, gradexpinv_clos_trans.

  rewrite <- clos_rt_rt1n_iff, <- clos_rt_rtn1_iff.

  reflexivity.

Qed.



Lemma reach__grad_min : forall A B C, A <> B -> Bet A B C -> Reach A B A C ->

  exists D E, Bet A D C /\ Grad A B D /\ E <> C /\ Bet A C E /\ Bet A D E /\ Cong A B D E.

Proof.

  intros A B C HAB HBet HReach.

  destruct HReach as [D [HD1 HD2]].

  apply l6_13_1 in HD2;

    [|apply l6_7 with B; [apply l6_6|]; apply bet_out; auto; apply grad__bet, HD1].

  revert dependent C.

  induction HD1.

    intros; assert (B = C) by (apply between_equality with A; Between); subst C.

    destruct (segment_construction A B A B) as [C []].

    assert_diffs.

    exists B, C; repeat split; finish; constructor.

  intros; destruct (l5_3 A C0 C C'); trivial.

    apply IHHD1; assumption.

  destruct (eq_dec_points C' C0).

  - subst C0.

    destruct (segment_construction A C' A B) as [C'' []].

    assert_diffs.

    exists C', C''; repeat split; Cong.

    apply grad_stab with C; assumption.

  - exists C, C'; repeat split; assumption.

Qed.



Lemma reach__ex_gradexp_lt : forall A B P Q, A <> B -> Reach P Q A B ->

  exists C, GradExp A C B /\ Lt A C P Q.

Proof.

  intros A B P Q HAB HReach.

  apply reach__ex_gradexp_le in HReach.

  destruct HReach as [R [HR1 HR2]].

  generalize dependent B.

  induction HR1; rename A0 into P, B into Q; intros.

  { destruct (midpoint_existence A B) as [C []].

    exists C; split.

      rewrite gradexp__gradexpinv.

      apply gradexpinv_stab with B; auto; constructor.

    apply le3456_lt__lt with A B; trivial.

    split; Le.

    intro; assert (C = B) by (apply (between_cong A); assumption).

    treat_equalities; auto.

  }

  rename C into R, C' into R'.

  destruct (midpoint_existence A B) as [M HM].

  assert_diffs.

  destruct (IHHR1 M) as [C []]; auto.

    apply le_mid2__le12 with B R'; [|split|]; trivial.

  exists C; split; trivial.

  destruct HM.

  apply gradexp_stab with M; trivial.

Qed.



End Grad.



Hint Resolve grad__bet : between.

Hint Resolve grad__col : col.
