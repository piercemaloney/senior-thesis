Require Import GeoCoq.Axioms.parallel_postulates.
(* GeoCoq.Axioms.parallel_postulates:
Require Import GeoCoq.Tarski_dev.Definitions.

Section Euclid_def.

Context `{Tn:Tarski_neutral_dimensionless}.

Definition decidability_of_parallelism := forall A B C D,
  Par A B C D \/ ~ Par A B C D.

Definition decidability_of_not_intersection := forall A B C D,
  ~ (exists I, Col I A B /\ Col I C D) \/
  ~ ~ (exists I, Col I A B /\ Col I C D).

Definition decidability_of_intersection := forall A B C D,
  (exists I, Col I A B /\ Col I C D) \/
  ~ (exists I, Col I A B /\ Col I C D).

Definition tarski_s_parallel_postulate := forall A B C D T,
  Bet A D T -> Bet B D C -> A <> D ->
  exists X Y, Bet A B X /\ Bet A C Y /\ Bet X T Y.

Definition playfair_s_postulate := forall A1 A2 B1 B2 C1 C2 P,
  Par A1 A2 B1 B2 -> Col P B1 B2 ->
  Par A1 A2 C1 C2 -> Col P C1 C2 ->
  Col C1 B1 B2 /\ Col C2 B1 B2.

Definition triangle_postulate := forall A B C D E F,
  TriSumA A B C D E F -> Bet D E F.

Definition bachmann_s_lotschnittaxiom := forall P Q R P1 R1,
  P <> Q -> Q <> R -> Per P Q R -> Per Q P P1 -> Per Q R R1 ->
  Coplanar P Q R P1 -> Coplanar P Q R R1 ->
  exists S, Col P P1 S /\ Col R R1 S.

Definition postulate_of_transitivity_of_parallelism := forall A1 A2 B1 B2 C1 C2,
  Par A1 A2 B1 B2 -> Par B1 B2 C1 C2 ->
  Par A1 A2 C1 C2.

Definition midpoint_converse_postulate := forall A B C P Q,
  ~ Col A B C ->
  Midpoint P B C -> Par A B Q P -> Col A C Q ->
  Midpoint Q A C.

Definition alternate_interior_angles_postulate := forall A B C D,
  TS A C B D -> Par A B C D ->
  CongA B A C D C A.

Definition consecutive_interior_angles_postulate := forall A B C D,
  OS B C A D -> Par A B C D -> SuppA A B C B C D.

Definition perpendicular_transversal_postulate := forall A B C D P Q,
  Par A B C D -> Perp A B P Q -> Coplanar C D P Q ->
  Perp C D P Q.

Definition postulate_of_parallelism_of_perpendicular_transversals :=
  forall A1 A2 B1 B2 C1 C2 D1 D2,
    Par A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 ->
    Coplanar A1 A2 C1 D1 -> Coplanar A1 A2 C1 D2 ->
    Coplanar A1 A2 C2 D1 -> Coplanar A1 A2 C2 D2 ->
    Par C1 C2 D1 D2.

Definition universal_posidonius_postulate := forall A1 A2 A3 A4 B1 B2 B3 B4,
  Par A1 A2 B1 B2 ->
  Col A1 A2 A3 -> Col B1 B2 B3 -> Perp A1 A2 A3 B3 ->
  Col A1 A2 A4 -> Col B1 B2 B4 -> Perp A1 A2 A4 B4 ->
  Cong A3 B3 A4 B4.

Definition alternative_playfair_s_postulate := forall A1 A2 B1 B2 C1 C2 P,
  Perp2 A1 A2 B1 B2 P -> ~ Col A1 A2 P -> Col P B1 B2 -> Coplanar A1 A2 B1 B2 ->
  Par A1 A2 C1 C2 -> Col P C1 C2 ->
  Col C1 B1 B2 /\ Col C2 B1 B2.

Definition proclus_postulate := forall A B C D P Q,
  Par A B C D -> Col A B P -> ~ Col A B Q -> Coplanar C D P Q ->
  exists Y, Col P Q Y /\ Col C D Y.

Definition alternative_proclus_postulate := forall A B C D P Q,
  Perp2 A B C D P -> ~ Col C D P -> Coplanar A B C D ->
  Col A B P -> ~ Col A B Q -> Coplanar C D P Q ->
  exists Y, Col P Q Y /\ Col C D Y.

Definition triangle_circumscription_principle := forall A B C,
  ~ Col A B C ->
  exists CC, Cong A CC B CC /\ Cong A CC C CC /\ Coplanar A B C CC.

Definition inverse_projection_postulate := forall A B C P Q,
  Acute A B C ->
  Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q ->
  exists Y, Out B C Y /\ Col P Q Y.

Definition euclid_5 := forall P Q R S T U,
  BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S ->
  Cong P T Q T -> Cong R T S T ->
  exists I, BetS S Q I /\ BetS P U I.

Definition strong_parallel_postulate :=  forall P Q R S T U,
  BetS P T Q -> BetS R T S -> ~ Col P R U ->
  Coplanar P Q R U ->
  Cong P T Q T -> Cong R T S T ->
  exists I, Col S Q I /\ Col P U I.

Definition alternative_strong_parallel_postulate := forall A B C D P Q R,
  OS B C A D -> SumA A B C B C D P Q R -> ~ Bet P Q R ->
  exists Y, Col B A Y /\ Col C D Y.

Definition euclid_s_parallel_postulate := forall A B C D P Q R,
  OS B C A D -> SAMS A B C B C D -> SumA A B C B C D P Q R -> ~ Bet P Q R ->
  exists Y, Out B A Y /\ Out C D Y.

Definition postulate_of_existence_of_a_triangle_whose_angles_sum_to_two_rights :=
  exists A B C D E F, ~ Col A B C /\ TriSumA A B C D E F /\ Bet D E F.

Definition posidonius_postulate :=
  exists A1 A2 B1 B2,
    ~ Col A1 A2 B1 /\ B1 <> B2 /\ Coplanar A1 A2 B1 B2 /\
    forall A3 A4 B3 B4,
      Col A1 A2 A3 -> Col B1 B2 B3 -> Perp A1 A2 A3 B3 ->
      Col A1 A2 A4 -> Col B1 B2 B4 -> Perp A1 A2 A4 B4 ->
      Cong A3 B3 A4 B4.

Definition postulate_of_existence_of_similar_triangles :=
  exists A B C D E F,
    ~ Col A B C /\ ~ Cong A B D E /\
    CongA A B C D E F /\ CongA B C A E F D /\ CongA C A B F D E.

Definition thales_postulate := forall A B C M,
  ~ Col A B C -> Midpoint M A B -> Cong M A M C ->
  Per A C B.

Definition thales_converse_postulate := forall A B C M,
  ~ Col A B C -> Midpoint M A B -> Per A C B ->
  Cong M A M C.

Definition existential_thales_postulate :=
  exists A B C M, ~ Col A B C /\ Midpoint M A B /\ Cong M A M C /\ Per A C B.

Definition postulate_of_right_saccheri_quadrilaterals := forall A B C D,
  Saccheri A B C D -> Per A B C.

Definition postulate_of_existence_of_a_right_saccheri_quadrilateral :=
  exists A B C D, Saccheri A B C D /\ Per A B C.

Definition postulate_of_right_lambert_quadrilaterals := forall A B C D,
  Lambert A B C D -> Per B C D.

Definition postulate_of_existence_of_a_right_lambert_quadrilateral :=
  exists A B C D, Lambert A B C D /\ Per B C D.

Definition weak_inverse_projection_postulate := forall A B C D E F P Q,
  Acute A B C -> Per D E F -> SumA A B C A B C D E F ->
  Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q ->
  exists Y, Out B C Y /\ Col P Q Y.

Definition weak_tarski_s_parallel_postulate := forall A B C T,
  Per A B C -> InAngle T A B C ->
  exists X Y, Out B A X /\ Out B C Y /\ Bet X T Y.

Definition weak_triangle_circumscription_principle := forall A B C A1 A2 B1 B2,
  ~ Col A B C -> Per A C B ->
  Perp_bisect A1 A2 B C -> Perp_bisect B1 B2 A C ->
  Coplanar A B C A1 -> Coplanar A B C A2 ->
  Coplanar A B C B1 -> Coplanar A B C B2 ->
  exists I, Col A1 A2 I /\ Col B1 B2 I.

Definition legendre_s_parallel_postulate :=
  exists A B C,
    ~ Col A B C /\ Acute A B C /\
    forall T,
      InAngle T A B C ->
      exists X Y, Out B A X /\ Out B C Y /\ Bet X T Y.

Definition existential_playfair_s_postulate :=
  exists A1 A2 P, ~ Col A1 A2 P /\
             (forall B1 B2 C1 C2,
                Par A1 A2 B1 B2 -> Col P B1 B2 ->
                Par A1 A2 C1 C2 -> Col P C1 C2 ->
                Col C1 B1 B2 /\ Col C2 B1 B2).

End Euclid_def. *)

Require Import GeoCoq.Meta_theory.Parallel_postulates.tarski_s_euclid_remove_degenerated_cases.
(* GeoCoq.Meta_theory.Parallel_postulates.tarski_s_euclid_remove_degenerated_cases:
Require Import GeoCoq.Axioms.parallel_postulates.
Require Import GeoCoq.Tarski_dev.Ch05_bet_le.

Section tarski_s_euclid_remove_degenerated_cases.

Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.

Lemma tarski_s_euclid_remove_degenerated_cases :
  (forall A B C D T,
   A <> B ->
   A <> C ->
   A <> D ->
   A <> T ->
   B <> C ->
   B <> D ->
   B <> T ->
   C <> D ->
   C <> T ->
   D <> T ->
   ~ Col A B C ->
   Bet A D T ->
   Bet B D C ->
   exists x y : Tpoint, Bet A B x /\ Bet A C y /\ Bet x T y) ->
  forall A B C D T,
  Bet A D T ->
  Bet B D C ->
  A <> D -> exists x y : Tpoint, Bet A B x /\ Bet A C y /\ Bet x T y.

End tarski_s_euclid_remove_degenerated_cases. *)

Require Import GeoCoq.Tarski_dev.Annexes.perp_bisect.
(* GeoCoq.Tarski_dev.Annexes.perp_bisect:
Require Export GeoCoq.Tarski_dev.Ch10_line_reflexivity_2.

Section PerpBisect_1.

Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.

Lemma perp_bisect_equiv_def :
  forall P Q A B, Perp_bisect P Q A B <-> Perp_bisect_bis P Q A B.

Lemma perp_bisect_sym_1 :
 forall P Q A B,
  Perp_bisect P Q A B ->
  Perp_bisect Q P A B.

Lemma perp_bisect_sym_2 :
 forall P Q A B,
  Perp_bisect P Q A B ->
  Perp_bisect P Q B A.

Lemma perp_bisect_sym_3 : forall A B C D,
 Perp_bisect A B C D ->
 Perp_bisect B A D C.

Lemma perp_bisect_perp :
 forall P Q A B,
  Perp_bisect P Q A B ->
  Perp P Q A B.

End PerpBisect_1.

Hint Resolve perp_bisect_perp : perp.

Section PerpBisect_2.

Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.

Lemma perp_bisect_cong_1 :
 forall P Q A B,
 Perp_bisect P Q A B ->
 Cong A P B P.

Lemma perp_bisect_cong_2 :
 forall P Q A B,
 Perp_bisect P Q A B ->
 Cong A Q B Q.

End PerpBisect_2.

Hint Resolve perp_bisect_cong_1 perp_bisect_cong_2 : cong.

Section PerpBisect_3.

Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.

Lemma perp_bisect_cong2 :
 forall P Q A B,
 Perp_bisect P Q A B ->
 Cong A P B P /\ Cong A Q B Q.

Lemma perp_bisect_cong :
 forall A A1 B B1 C C1 O: Tpoint,
 ~ Col A B C ->
 Perp_bisect O A1 B C -> Perp_bisect O B1 A C -> Perp_bisect O C1 A B ->
 Cong A O B O -> Cong B O C O ->
 Cong A O C O.

Lemma cong_cop_perp_bisect :
 forall P Q A B,
 P <> Q -> A <> B ->
 Coplanar P Q A B ->
 Cong A P B P ->
 Cong A Q B Q ->
 Perp_bisect P Q A B.

Lemma perp_bisect_is_on_perp_bisect :
 forall A B C P,
  Is_on_perp_bisect P A B ->
  Is_on_perp_bisect P B C ->
  Is_on_perp_bisect P A C.

Lemma perp_mid_perp_bisect : forall A B C D,
 Midpoint C A B -> Perp C D A B ->
 Perp_bisect C D A B.

Lemma cong_cop2_perp_bisect_col : forall A B C D E,
  Coplanar A C D E ->
  Coplanar B C D E ->
  Cong C D C E ->
  Perp_bisect A B D E ->
  Col A B C.

Lemma perp_bisect_cop2_existence : forall A B C,
  A <> B -> exists P, exists Q, Perp_bisect P Q A B /\ Coplanar A B C P /\ Coplanar A B C Q.

Lemma perp_bisect_existence :
  forall A B, A <> B -> exists P, exists Q, Perp_bisect P Q A B.

Lemma perp_bisect_existence_cop : forall A B C,
  A <> B -> exists P, exists Q, Perp_bisect P Q A B /\ Coplanar A B C P /\
                                Coplanar A B C Q.

End PerpBisect_3.

Section PerpBisect_2D.

Context `{T2D:Tarski_2D}.

Lemma cong_perp_bisect :
 forall P Q A B,
 P <> Q -> A <> B ->
 Cong A P B P ->
 Cong A Q B Q ->
 Perp_bisect P Q A B.

Lemma cong_perp_bisect_col : forall A B C D E,
  Cong C D C E ->
  Perp_bisect A B D E ->
  Col A B C.

End PerpBisect_2D. *)

Require Import GeoCoq.Tarski_dev.Ch12_parallel.
(* GeoCoq.Tarski_dev.Ch12_parallel:
Require Export GeoCoq.Tarski_dev.Ch11_angles.

Section T12_1.

Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.

Lemma par_reflexivity : forall A B, A<>B -> Par A B A B.

Lemma par_strict_irreflexivity : forall A B,
 ~ Par_strict A B A B.

Lemma not_par_strict_id : forall A B C,
 ~ Par_strict A B A C.

Lemma par_id : forall A B C,
 Par A B A C -> Col A B C.

Lemma par_strict_not_col_1 : forall A B C D,
 Par_strict A B C D  -> ~ Col A B C.

Lemma par_strict_not_col_2 : forall A B C D,
 Par_strict A B C D  -> ~ Col B C D.

Lemma par_strict_not_col_3 : forall A B C D,
 Par_strict A B C D  -> ~ Col C D A.

Lemma par_strict_not_col_4 : forall A B C D,
 Par_strict A B C D  -> ~ Col A B D.

Lemma par_strict_not_cols : forall A B C D,
 Par_strict A B C D -> ~ Col A B C /\ ~ Col B C D /\ ~ Col C D A /\ ~ Col A B D.

Lemma par_id_1 : forall A B C,
 Par A B A C -> Col B A C.

Lemma par_id_2 : forall A B C,
 Par A B A C -> Col B C A.

Lemma par_id_3 : forall A B C,
 Par A B A C -> Col A C B.

Lemma par_id_4 : forall A B C,
 Par A B A C -> Col C B A.

Lemma par_id_5 : forall A B C,
 Par A B A C -> Col C A B.

Lemma par_strict_symmetry :forall A B C D,
 Par_strict A B C D -> Par_strict C D A B.

Lemma par_symmetry :forall A B C D,
 Par A B C D -> Par C D A B.

Lemma par_left_comm : forall A B C D,
 Par A B C D -> Par B A C D.

Lemma par_right_comm : forall A B C D,
 Par A B C D -> Par A B D C.

Lemma par_comm : forall A B C D,
 Par A B C D -> Par B A D C.

Lemma par_strict_left_comm : forall A B C D,
 Par_strict A B C D -> Par_strict B A C D.

Lemma par_strict_right_comm : forall A B C D,
 Par_strict A B C D -> Par_strict A B D C.

Lemma par_strict_comm : forall A B C D,
 Par_strict A B C D -> Par_strict B A D C.

Lemma par_strict_neq1 : forall A B C D, Par_strict A B C D -> A <> B.

Lemma par_strict_neq2 : forall A B C D, Par_strict A B C D -> C <> D.

Lemma par_neq1 : forall A B C D, Par A B C D -> A <> B.

Lemma par_neq2 : forall A B C D, Par A B C D -> C <> D.

End T12_1.

Ltac assert_diffs :=
repeat
 match goal with
      | H:(~Col ?X1 ?X2 ?X3) |- _ =>
      let h := fresh in
      not_exist_hyp3 X1 X2 X1 X3 X2 X3;
      assert (h := not_col_distincts X1 X2 X3 H);decompose [and] h;clear h;clean_reap_hyps

      | H:(~Bet ?X1 ?X2 ?X3) |- _ =>
      let h := fresh in
      not_exist_hyp2 X1 X2 X2 X3;
      assert (h := not_bet_distincts X1 X2 X3 H);decompose [and] h;clear h;clean_reap_hyps
      | H:Bet ?A ?B ?C, H2 : ?A <> ?B |-_ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= bet_neq12__neq A B C H H2);clean_reap_hyps
      | H:Bet ?A ?B ?C, H2 : ?B <> ?A |-_ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= bet_neq21__neq A B C H H2);clean_reap_hyps
      | H:Bet ?A ?B ?C, H2 : ?B <> ?C |-_ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= bet_neq23__neq A B C H H2);clean_reap_hyps
      | H:Bet ?A ?B ?C, H2 : ?C <> ?B |-_ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= bet_neq32__neq A B C H H2);clean_reap_hyps

      | H:Cong ?A ?B ?C ?D, H2 : ?A <> ?B |-_ =>
      let T:= fresh in (not_exist_hyp_comm C D);
        assert (T:= cong_diff A B C D H2 H);clean_reap_hyps
      | H:Cong ?A ?B ?C ?D, H2 : ?B <> ?A |-_ =>
      let T:= fresh in (not_exist_hyp_comm C D);
        assert (T:= cong_diff_2 A B C D H2 H);clean_reap_hyps
      | H:Cong ?A ?B ?C ?D, H2 : ?C <> ?D |-_ =>
      let T:= fresh in (not_exist_hyp_comm A B);
        assert (T:= cong_diff_3 A B C D H2 H);clean_reap_hyps
      | H:Cong ?A ?B ?C ?D, H2 : ?D <> ?C |-_ =>
      let T:= fresh in (not_exist_hyp_comm A B);
        assert (T:= cong_diff_4 A B C D H2 H);clean_reap_hyps

      | H:Le ?A ?B ?C ?D, H2 : ?A <> ?B |-_ =>
      let T:= fresh in (not_exist_hyp_comm C D);
        assert (T:= le_diff A B C D H2 H);clean_reap_hyps
      | H:Le ?A ?B ?C ?D, H2 : ?B <> ?A |-_ =>
      let T:= fresh in (not_exist_hyp_comm C D);
        assert (T:= le_diff A B C D (swap_diff B A H2) H);clean_reap_hyps
      | H:Lt ?A ?B ?C ?D |-_ =>
      let T:= fresh in (not_exist_hyp_comm C D);
        assert (T:= lt_diff A B C D H);clean_reap_hyps

      | H:Midpoint ?I ?A ?B, H2 : ?A<>?B |- _ =>
      let T:= fresh in (not_exist_hyp2 I B I A);
       assert (T:= midpoint_distinct_1 I A B H2 H);
       decompose [and] T;clear T;clean_reap_hyps
      | H:Midpoint ?I ?A ?B, H2 : ?B<>?A |- _ =>
      let T:= fresh in (not_exist_hyp2 I B I A);
       assert (T:= midpoint_distinct_1 I A B (swap_diff B A H2) H);
       decompose [and] T;clear T;clean_reap_hyps

      | H:Midpoint ?I ?A ?B, H2 : ?I<>?A |- _ =>
      let T:= fresh in (not_exist_hyp2 I B A B);
       assert (T:= midpoint_distinct_2 I A B H2 H);
       decompose [and] T;clear T;clean_reap_hyps
      | H:Midpoint ?I ?A ?B, H2 : ?A<>?I |- _ =>
      let T:= fresh in (not_exist_hyp2 I B A B);
       assert (T:= midpoint_distinct_2 I A B (swap_diff A I H2) H);
       decompose [and] T;clear T;clean_reap_hyps

      | H:Midpoint ?I ?A ?B, H2 : ?I<>?B |- _ =>
      let T:= fresh in (not_exist_hyp2 I A A B);
       assert (T:= midpoint_distinct_3 I A B H2 H);
       decompose [and] T;clear T;clean_reap_hyps
      | H:Midpoint ?I ?A ?B, H2 : ?B<>?I |- _ =>
      let T:= fresh in (not_exist_hyp2 I A A B);
       assert (T:= midpoint_distinct_3 I A B (swap_diff B I H2) H);
       decompose [and] T;clear T;clean_reap_hyps

      | H:Per ?A ?B ?C, H2 : ?A<>?B |- _ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= per_distinct A B C H H2); clean_reap_hyps
      | H:Per ?A ?B ?C, H2 : ?B<>?A |- _ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= per_distinct A B C H (swap_diff B A H2)); clean_reap_hyps
      | H:Per ?A ?B ?C, H2 : ?B<>?C |- _ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= per_distinct_1 A B C H H2); clean_reap_hyps
      | H:Per ?A ?B ?C, H2 : ?C<>?B |- _ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= per_distinct_1 A B C H (swap_diff C B H2)); clean_reap_hyps

      | H:Perp ?A ?B ?C ?D |- _ =>
      let T:= fresh in (not_exist_hyp2 A B C D);
       assert (T:= perp_distinct A B C D H);
       decompose [and] T;clear T;clean_reap_hyps
      | H:Perp_at ?X ?A ?B ?C ?D |- _ =>
      let T:= fresh in (not_exist_hyp2 A B C D);
       assert (T:= perp_in_distinct X A B C D H);
       decompose [and] T;clear T;clean_reap_hyps
      | H:Out ?A ?B ?C |- _ =>
      let T:= fresh in (not_exist_hyp2 A B A C);
       assert (T:= out_distinct A B C H);
       decompose [and] T;clear T;clean_reap_hyps

      | H:TS ?A ?B ?C ?D |- _ =>
      let h := fresh in
      not_exist_hyp6 A B A C A D B C B D C D;
      assert (h := ts_distincts A B C D H);decompose [and] h;clear h;clean_reap_hyps
      | H:OS ?A ?B ?C ?D |- _ =>
      let h := fresh in
      not_exist_hyp5 A B A C A D B C B D;
      assert (h := os_distincts A B C D H);decompose [and] h;clear h;clean_reap_hyps
      | H:~ Coplanar ?A ?B ?C ?D |- _ =>
      let h := fresh in
      not_exist_hyp6 A B A C A D B C B D C D;
      assert (h := ncop_distincts A B C D H);decompose [and] h;clear h;clean_reap_hyps

      | H:CongA ?A ?B ?C ?A' ?B' ?C' |- _ =>
      let T:= fresh in (not_exist_hyp_comm A B);
        assert (T:= conga_diff1 A B C A' B' C' H);clean_reap_hyps
      | H:CongA ?A ?B ?C ?A' ?B' ?C' |- _ =>
      let T:= fresh in (not_exist_hyp_comm B C);
        assert (T:= conga_diff2 A B C A' B' C' H);clean_reap_hyps
      | H:CongA ?A ?B ?C ?A' ?B' ?C' |- _ =>
      let T:= fresh in (not_exist_hyp_comm A' B');
        assert (T:= conga_diff45 A B C A' B' C' H);clean_reap_hyps
      | H:CongA ?A ?B ?C ?A' ?B' ?C' |- _ =>
      let T:= fresh in (not_exist_hyp_comm B' C');
        assert (T:= conga_diff56 A B C A' B' C' H);clean_reap_hyps

      | H:(InAngle ?P ?A ?B ?C) |- _ =>
      let h := fresh in
      not_exist_hyp3 A B C B P B;
      assert (h := inangle_distincts A B C P H);decompose [and] h;clear h;clean_reap_hyps
      | H:LeA ?A ?B ?C ?D ?E ?F |- _ =>
      let h := fresh in
      not_exist_hyp4 A B B C D E E F;
      assert (h := lea_distincts A B C D E F H);decompose [and] h;clear h;clean_reap_hyps
      | H:LtA ?A ?B ?C ?D ?E ?F |- _ =>
      let h := fresh in
      not_exist_hyp4 A B B C D E E F;
      assert (h := lta_distincts A B C D E F H);decompose [and] h;clear h;clean_reap_hyps
      | H:(Acute ?A ?B ?C) |- _ =>
      let h := fresh in
      not_exist_hyp2 A B B C;
      assert (h := acute_distincts A B C H);decompose [and] h;clear h;clean_reap_hyps
      | H:(Obtuse ?A ?B ?C) |- _ =>
      let h := fresh in
      not_exist_hyp2 A B B C;
      assert (h := obtuse_distincts A B C H);decompose [and] h;clear h;clean_reap_hyps
      | H:SuppA ?A ?B ?C ?D ?E ?F |- _ =>
      let h := fresh in
      not_exist_hyp4 A B B C D E E F;
      assert (h := suppa_distincts A B C D E F H);decompose [and] h;clear h;clean_reap_hyps

      | H:(Orth_at ?X ?A ?B ?C ?U ?V) |- _ =>
      let h := fresh in
      not_exist_hyp4 A B A C B C U V;
      assert (h := orth_at_distincts A B C U V X H);decompose [and] h;clear h;clean_reap_hyps
      | H:(Orth ?A ?B ?C ?U ?V) |- _ =>
      let h := fresh in
      not_exist_hyp4 A B A C B C U V;
      assert (h := orth_distincts A B C U V H);decompose [and] h;clear h;clean_reap_hyps

      | H:Par ?A ?B ?C ?D |- _ =>
      let T:= fresh in (not_exist_hyp_comm A B);
        assert (T:= par_neq1 A B C D H);clean_reap_hyps
      | H:Par ?A ?B ?C ?D |- _ =>
      let T:= fresh in (not_exist_hyp_comm C D);
        assert (T:= par_neq2 A B C D H);clean_reap_hyps
      | H:Par_strict ?A ?B ?C ?D |- _ =>
      let T:= fresh in (not_exist_hyp_comm A B);
        assert (T:= par_strict_neq1 A B C D H);clean_reap_hyps
      | H:Par_strict ?A ?B ?C ?D |- _ =>
      let T:= fresh in (not_exist_hyp_comm C D);
        assert (T:= par_strict_neq2 A B C D H);clean_reap_hyps
 end.

Ltac assert_ncols :=
repeat
  match goal with
      | H:OS ?A ?B ?X ?Y |- _ =>
     not_exist_hyp_perm_ncol A B X;assert (~ Col A B X) by (apply(one_side_not_col123 A B X Y);finish)

      | H:OS ?A ?B ?X ?Y |- _ =>
     not_exist_hyp_perm_ncol A B Y;assert (~ Col A B Y) by (apply(one_side_not_col124 A B X Y);finish)

      | H:TS ?A ?B ?X ?Y |- _ =>
     not_exist_hyp_perm_ncol A B X;assert (~ Col A B X) by (apply(two_sides_not_col A B X Y);finish)

      | H:TS ?A ?B ?X ?Y |- _ =>
     not_exist_hyp_perm_ncol A B Y;assert (~ Col A B Y) by (apply(two_sides_not_col A B Y X);finish)

      | H:~ Coplanar ?A ?B ?C ?D |- _ =>
      let h := fresh in
      not_exist_hyp_perm4 A B C D;
      assert (h := ncop__ncols A B C D H);decompose [and] h;clear h;clean_reap_hyps

      | H:Par_strict ?A ?B ?C ?D |- _ =>
      let h := fresh in
      not_exist_hyp_perm4 A B C D;
      assert (h := par_strict_not_cols A B C D H);decompose [and] h;clear h;clean_reap_hyps
  end.

Hint Resolve
 par_reflexivity par_strict_irreflexivity
 par_strict_symmetry par_strict_comm par_strict_right_comm par_strict_left_comm
 par_symmetry par_comm par_right_comm par_left_comm : par.

Hint Resolve par_strict_not_col_1 par_strict_not_col_2
             par_strict_not_col_3 par_strict_not_col_4 : col.

Ltac Par := eauto with par.

Section T12_2.

Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.

Lemma Par_cases :
  forall A B C D,
  Par A B C D \/ Par B A C D \/ Par A B D C \/ Par B A D C \/
  Par C D A B \/ Par C D B A \/ Par D C A B \/ Par D C B A ->
  Par A B C D.

Lemma Par_perm :
  forall A B C D,
  Par A B C D ->
  Par A B C D /\ Par B A C D /\ Par A B D C /\ Par B A D C /\
  Par C D A B /\ Par C D B A /\ Par D C A B /\ Par D C B A.

Lemma Par_strict_cases :
  forall A B C D,
  Par_strict A B C D \/ Par_strict B A C D \/ Par_strict A B D C \/ Par_strict B A D C \/
  Par_strict C D A B \/ Par_strict C D B A \/ Par_strict D C A B \/ Par_strict D C B A ->
  Par_strict A B C D.

Lemma Par_strict_perm :
  forall A B C D,
  Par_strict A B C D ->
  Par_strict A B C D /\ Par_strict B A C D /\ Par_strict A B D C /\ Par_strict B A D C /\
  Par_strict C D A B /\ Par_strict C D B A /\ Par_strict D C A B /\ Par_strict D C B A.

End T12_2.

Section T12_2'.

Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.

Lemma l12_6 : forall A B C D,
 Par_strict A B C D -> OS A B C D.

Lemma pars__os3412 : forall A B C D,
 Par_strict A B C D -> OS C D A B.

Lemma perp_dec : forall A B C D, Perp A B C D \/ ~ Perp A B C D.

Lemma col_cop2_perp2__col : forall X1 X2 Y1 Y2 A B,
 Perp X1 X2 A B -> Perp Y1 Y2 A B -> Col X1 Y1 Y2 ->
 Coplanar A B X2 Y1 -> Coplanar A B X2 Y2 -> Col X2 Y1 Y2.

Lemma col_perp2_ncol__col : forall X1 X2 Y1 Y2 A B,
 Perp X1 X2 A B -> Perp Y1 Y2 A B ->
 Col X1 Y1 Y2 -> ~ Col X1 A B ->
 Col X2 Y1 Y2.

Lemma l12_9 : forall A1 A2 B1 B2 C1 C2,
 Coplanar C1 C2 A1 B1 -> Coplanar C1 C2 A1 B2 ->
 Coplanar C1 C2 A2 B1 -> Coplanar C1 C2 A2 B2 ->
 Perp A1 A2 C1 C2 -> Perp B1 B2 C1 C2 ->
 Par A1 A2 B1 B2.

Lemma parallel_existence : forall A B P, A <> B ->
 exists C, exists D, C<>D /\ Par A B C D /\ Col P C D.

Lemma par_col_par : forall A B C D D',
 C <> D' -> Par A B C D -> Col C D D' -> Par A B C D'.

Lemma parallel_existence1 : forall A B P, A <> B -> exists Q, Par A B P Q.

Lemma par_not_col : forall A B C D X, Par_strict A B C D -> Col X A B -> ~Col X C D.

Lemma not_strict_par1 : forall A B C D X, Par A B C D -> Col A B X -> Col C D X -> Col A B C.

Lemma not_strict_par2 : forall A B C D X, Par A B C D -> Col A B X -> Col C D X -> Col A B D.

Lemma not_strict_par : forall A B C D X, Par A B C D -> Col A B X -> Col C D X -> Col A B C /\ Col A B D.

Lemma not_par_not_col : forall A B C, A <> B -> A <> C -> ~Par A B A C -> ~Col A B C.

Lemma not_par_inter_uniqueness : forall A B C D X Y,
  A <> B -> C <> D -> ~Par A B C D -> Col A B X -> Col C D X -> Col A B Y -> Col C D Y ->
  X = Y.

Lemma inter_uniqueness_not_par : forall A B C D P,
  ~Col A B C -> Col A B P -> Col C D P -> ~Par A B C D.

Lemma col_not_col_not_par :
 forall A B C D,
 (exists P, Col A B P /\ Col C D P) ->
 (exists Q, Col C D Q /\ ~Col A B Q) -> ~Par A B C D.

Lemma par_distincts : forall A B C D,
 Par A B C D -> (Par A B C D /\ A <> B /\ C <> D).

Lemma par_not_col_strict : forall A B C D P,
 Par A B C D -> Col C D P -> ~Col A B P -> Par_strict A B C D.

Lemma all_one_side_par_strict : forall A B C D,
 C <> D -> (forall P, Col C D P -> OS A B C P) ->
 Par_strict A B C D.

Lemma par_col_par_2 : forall A B C D P,
 A <> P -> Col A B P -> Par A B C D -> Par A P C D.

Lemma par_col2_par : forall A B C D E F,
 E <> F -> Par A B C D -> Col C D E -> Col C D F -> Par A B E F.

Lemma par_col2_par_bis : forall A B C D E F,
 E <> F -> Par A B C D -> Col E F C -> Col E F D -> Par A B E F.

Lemma par_strict_col_par_strict : forall A B C D E,
 C <> E -> Par_strict A B C D -> Col C D E ->
 Par_strict A B C E.

Lemma par_strict_col2_par_strict : forall A B C D E F,
 E <> F -> Par_strict A B C D -> Col C D E -> Col C D F ->
 Par_strict A B E F.

Lemma line_dec : forall B1 B2 C1 C2, (Col C1 B1 B2 /\ Col C2 B1 B2) \/ ~ (Col C1 B1 B2 /\ Col C2 B1 B2).

Lemma par_distinct : forall A B C D, Par A B C D -> A <> B /\ C <> D.

Lemma par_col4__par : forall A B C D E F G H, E <> F -> G <> H -> Par A B C D ->
 Col A B E -> Col A B F -> Col C D G -> Col C D H -> Par E F G H.

Lemma par_strict_col4__par_strict : forall A B C D E F G H, E <> F -> G <> H ->
 Par_strict A B C D -> Col A B E -> Col A B F -> Col C D G -> Col C D H ->
 Par_strict E F G H.

Lemma par_strict_one_side : forall A B C D P,
 Par_strict A B C D -> Col C D P -> OS A B C P.

Lemma par_strict_all_one_side : forall A B C D,
 Par_strict A B C D -> (forall P, Col C D P -> OS A B C P).

Lemma inter_distincts : forall A B C D X, Inter A B C D X -> A <> B /\ C <> D.

Lemma inter_trivial : forall A B X, ~ Col A B X -> Inter A X B X X.

Lemma inter_sym : forall A B C D X, Inter A B C D X -> Inter C D A B X.

Lemma inter_left_comm : forall A B C D X, Inter A B C D X -> Inter B A C D X.

Lemma inter_right_comm : forall A B C D X, Inter A B C D X -> Inter A B D C X.

Lemma inter_comm : forall A B C D X, Inter A B C D X -> Inter B A D C X.

Lemma l12_17 : forall A B C D P,
 A <> B -> Midpoint P A C -> Midpoint P B D -> Par A B C D.

Lemma l12_18_a :
  forall A B C D P,
  Cong A B C D -> Cong B C D A -> ~Col A B C ->
  B <> D -> Col A P C -> Col B P D ->
  Par A B C D.

Lemma l12_18_b :
  forall A B C D P,
  Cong A B C D -> Cong B C D A -> ~Col A B C ->
  B <> D -> Col A P C -> Col B P D ->
  Par B C D A.

Lemma l12_18_c :
 forall A B C D P,
  Cong A B C D -> Cong B C D A -> ~Col A B C ->
  B <> D -> Col A P C -> Col B P D ->
  TS B D A C.

Lemma l12_18_d :
 forall A B C D P,
 Cong A B C D -> Cong B C D A -> ~Col A B C ->
 B <> D -> Col A P C -> Col B P D ->
 TS A C B D.

Lemma l12_18 :
 forall A B C D P,
  Cong A B C D -> Cong B C D A -> ~Col A B C ->
  B <> D -> Col A P C -> Col B P D ->
  Par A B C D /\ Par B C D A /\ TS B D A C /\ TS A C B D.

Lemma par_two_sides_two_sides :
  forall A B C D,
  Par A B C D -> TS B D A C ->
  TS A C B D.

Lemma par_one_or_two_sides :
 forall A B C D,
  Par_strict A B C D ->
 TS A C B D /\ TS B D A C \/ OS A C B D /\ OS B D A C.

Lemma l12_21_b : forall A B C D,
 TS A C B D ->
 CongA B A C D C A -> Par A B C D.

Lemma l12_22_aux :
 forall A B C D P,
  P <> A -> A <> C -> Bet P A C -> OS P A B D ->
  CongA B A P D C P ->
  Par A B C D.

Lemma l12_22_b :
 forall A B C D P,
  Out P A C -> OS P A B D -> CongA B A P D C P ->
  Par A B C D.

Lemma par_strict_par : forall A B C D,
 Par_strict A B C D -> Par A B C D.

Lemma par_strict_distinct : forall A B C D,
 Par_strict A B C D ->
  A<>B /\ A<>C /\ A<>D /\ B<>C /\ B<>D /\ C<>D.

Lemma col_par : forall A B C,
 A <> B -> B <> C ->
 Col A B C -> Par A B B C.

Lemma acute_col_perp__out : forall A B C A',
  Acute A B C -> Col B C A' -> Perp B C A A' -> Out B A' C.

Lemma acute_col_perp__out_1 : forall A B C A',
  Acute A B C -> Col B C A' -> Perp B A A A' -> Out B A' C.

Lemma conga_cop_inangle_per2__inangle : forall A B C P T,
  Per A B C -> InAngle T A B C -> CongA P B A P B C -> Per B P T -> Coplanar A B C P ->
  InAngle P A B C.

End T12_2'.

Hint Resolve col_par par_strict_par : par.

Hint Resolve l12_6 pars__os3412 : side.

Section T12_3.

Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.

Lemma perp_not_par : forall A B X Y, Perp A B X Y -> ~ Par A B X Y.

Lemma cong_conga_perp : forall A B C P, TS B P A C -> Cong A B C B -> CongA A B P C B P -> Perp A C B P.

Lemma perp_inter_exists : forall A B C D, Perp A B C D -> exists P, Col A B P /\ Col C D P.

Lemma perp_inter_perp_in : forall A B C D, Perp A B C D -> exists P, Col A B P /\ Col C D P /\ Perp_at P A B C D.

End T12_3.

Section T12_2D.

Context `{T2D:Tarski_2D}.

Lemma col_perp2__col : forall X1 X2 Y1 Y2 A B,
  Perp X1 X2 A B -> Perp Y1 Y2 A B -> Col X1 Y1 Y2 -> Col X2 Y1 Y2.

Lemma l12_9_2D : forall A1 A2 B1 B2 C1 C2,
  Perp A1 A2 C1 C2 -> Perp B1 B2 C1 C2 -> Par A1 A2 B1 B2.

Lemma conga_inangle_per2__inangle : forall A B C P T,
  Per A B C -> InAngle T A B C -> CongA P B A P B C -> Per B P T ->
  InAngle P A B C.

End T12_2D. *)



Section TCP_tarski.



Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.



Lemma impossible_case_1 :

  forall A B C D T x y,

  A <> B ->

  A <> C ->

  A <> D ->

  A <> T ->

  B <> C ->

  B <> D ->

  B <> T ->

  C <> D ->

  C <> T ->

  D <> T ->

  x <> y ->

  ~ Col A B C ->

  Bet A D T ->

  ~ Col B C T ->

  Bet B D C ->

  Bet A B x ->

  Bet C y A ->

  Bet x T y ->

  Par_strict B C x y ->

  False.

Proof.

intros A B C D T x y.

intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.

intros HABC HADT HBCT HBDC HABx HACy HxTy HPar.

apply between_symmetry in HABx.

assert (HI := inner_pasch x C A B y HABx HACy); destruct HI as [I [HBCI HIxy]].

apply HPar; exists I; assert_cols; Col.

Qed.



Lemma impossible_case_2 :

  forall A B C D T x y,

  A <> B ->

  A <> C ->

  A <> D ->

  A <> T ->

  B <> C ->

  B <> D ->

  B <> T ->

  C <> D ->

  C <> T ->

  D <> T ->

  x <> y ->

  ~ Col A B C ->

  Col A B x ->

  Bet A D T ->

  ~ Col B C T ->

  Bet B D C ->

  Bet y A C ->

  Bet x T y ->

  False.

Proof.

intros A B C D T x y.

intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.

intros HABC HABx HADT HBCT HBDC HACy HxTy.

apply between_symmetry in HACy.

assert (HI := inner_pasch C x y A T HACy HxTy); destruct HI as [I [HAIx HICT]].

assert (HAx : A <> x) by (intro; treat_equalities; apply HABC; assert_cols; ColR).

assert (HTS : TS A B C T) by (repeat (split; Col); try (intro; apply HBCT; assert_cols; ColR);

exists I; split; Between; assert_cols; ColR); apply l9_9 in HTS.

apply HTS; apply one_side_transitivity with D.



  assert (HABB : Col A B B) by Col.

  assert (HBDC' : Col C D B) by (assert_cols; Col).

  assert (H := l9_19 A B C D B HABB HBDC'); rewrite H.

  split; try (intro; apply HABC; Col).

  repeat (split; Between).



  assert (HABA : Col A B A) by Col.

  assert (HDTA : Col D T A) by (assert_cols; Col).

  assert (H := l9_19 A B D T A HABA HDTA); rewrite H.

  split; try (intro; apply HABC; assert_cols; ColR).

  repeat (split; Between).

Qed.



Lemma impossible_case_3 :

  forall A B C D T x y,

  A <> B ->

  A <> C ->

  A <> D ->

  A <> T ->

  B <> C ->

  B <> D ->

  B <> T ->

  C <> D ->

  C <> T ->

  D <> T ->

  x <> y ->

  ~ Col A B C ->

  Bet A D T ->

  ~ Col B C T ->

  Bet B D C ->

  Bet B x A ->

  Bet x T y ->

  Par_strict B C x y ->

  False.

Proof.

intros A B C D T x y.

intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.

intros HABC HADT HBCT HBDC HABx HxTy HPar.

apply between_symmetry in HADT.

assert (HI := inner_pasch B T A x D HABx HADT); destruct HI as [I [HITx HBDI]].

assert (HTx : T <> x) by (intro; subst; apply HABC; assert_cols; ColR).

assert (HPar' : Par_strict B D x T) by (apply par_strict_col_par_strict with y; assert_cols; Col;

apply par_strict_symmetry; apply par_strict_col_par_strict with C; Col; Par).

apply HPar'; exists I; assert_cols; Col.

Qed.



Lemma impossible_case_4_1 :

  forall A B C D T x y,

  A <> B ->

  A <> C ->

  A <> D ->

  A <> T ->

  B <> C ->

  B <> D ->

  B <> T ->

  C <> D ->

  C <> T ->

  D <> T ->

  x <> y ->

  ~ Col A B C ->

  Col A C y ->

  Bet A D T ->

  ~ Col B C T ->

  Bet B D C ->

  Bet A x B \/ Bet A B x ->

  Bet T y x ->

  False.

Proof.

intros A B C D T x y.

intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.

intros HABC HACy HADT HBCT HBDC HABx HTyx.

assert (HTS : TS A C x T) by (repeat (split; Col); try (intro; apply HBCT; assert_cols; ColR);

                                     exists y; split; assert_cols; Col; Between).

assert (HAx : A <> x) by (intro; subst; apply HABC; assert_cols; ColR).

assert (HOS : OS A C x B).

{

  assert (HACA : Col A C A) by Col.

  assert (HABx' : Col x B A) by (induction HABx; assert_cols; Col).

  assert (H := l9_19 A C x B A HACA HABx'); rewrite H.

  split; try (intro; apply HABC; assert_cols; ColR).

  repeat (split; auto).

}

assert (HTS' : TS A C B T) by (apply l9_8_2 with x; assumption);

clear HTS; clear HOS; rename HTS' into HTS; apply l9_9 in HTS.

apply HTS; apply one_side_transitivity with D.



  assert (HACC : Col A C C) by Col.

  assert (HBDC' : Col B D C) by (assert_cols; Col).

  assert (H := l9_19 A C B D C HACC HBDC'); rewrite H.

  split; try (intro; apply HABC; Col).

  repeat (split; Between).



  assert (HACA : Col A C A) by Col.

  assert (HDTA : Col D T A) by (assert_cols; Col).

  assert (H := l9_19 A C D T A HACA HDTA); rewrite H.

  split; try (intro; apply HABC; assert_cols; ColR).

  repeat (split; Between).

Qed.



Lemma impossible_case_4_2 :

  forall A B C D T x y,

  A <> B ->

  A <> C ->

  A <> D ->

  A <> T ->

  B <> C ->

  B <> D ->

  B <> T ->

  C <> D ->

  C <> T ->

  D <> T ->

  x <> y ->

  ~ Col A B C ->

  Col A C y ->

  Bet A D T ->

  ~ Col B C T ->

  Bet B D C ->

  Bet B A x ->

  Bet T y x ->

  Par_strict B C x y ->

  False.

Proof.

intros A B C D T x y.

intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.

intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.

assert (HTS : TS B C A T) by (repeat (split; Col); try (intro; apply HBCT; assert_cols; ColR);

                                     exists D; split; assert_cols; Col; Between).

assert (HOS : OS B C A x).

{

  assert (HBCB : Col B C B) by Col.

  assert (HABx' : Col A x B) by Col.

  assert (H := l9_19 B C A x B HBCB HABx'); rewrite H.

  split; try (intro; apply HABC; assert_cols; ColR).

  repeat (split; Between).

  intro; treat_equalities; intuition.

}

assert (HTS' : TS B C x T) by (apply l9_8_2 with A; assumption);

clear HTS; clear HOS; destruct HTS' as [Hclear [Hclear' [I [HBCI HITx]]]];

clear Hclear; clear Hclear'.

assert (HTx : T <> x) by (intro; subst; apply HABC; assert_cols; ColR).

assert (HPar' : Par_strict B C x T) by (apply par_strict_col_par_strict with y; assert_cols; Col).

apply HPar'; exists I; assert_cols; Col.

Qed.



Lemma impossible_case_4 :

  forall A B C D T x y,

  A <> B ->

  A <> C ->

  A <> D ->

  A <> T ->

  B <> C ->

  B <> D ->

  B <> T ->

  C <> D ->

  C <> T ->

  D <> T ->

  x <> y ->

  ~ Col A B C ->

  Col A C y ->

  Bet A D T ->

  ~ Col B C T ->

  Bet B D C ->

  Col A B x ->

  Bet T y x ->

  Par_strict B C x y ->

  False.

Proof.

intros A B C D T x y.

intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.

intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.

elim HABx; clear HABx; intro HABx.



  apply impossible_case_4_1 with A B C D T x y; Col.



  elim HABx; clear HABx; intro HABx.



    apply impossible_case_4_1 with A B C D T x y; Between.



    apply impossible_case_4_2 with A B C D T x y; Between.

Qed.



Lemma impossible_two_sides_not_col : forall A B C D T Y,

  A <> B ->

  A <> C ->

  A <> D ->

  A <> T ->

  A <> Y ->

  B <> C ->

  B <> D ->

  B <> T ->

  B <> Y ->

  C <> D ->

  C <> T ->

  C <> Y ->

  D <> T ->

  T <> Y ->

  ~ Col A B C ->

  Bet A D T ->

  ~ Col B C T ->

  Bet B D C ->

  Bet B Y T ->

  ~ Col A C Y.

Proof.

intros A B C D T Y HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTY.

intros  HABC HADT HBCT HBDC HBYT.

intro HACY.

assert (HTS : TS A C B T)

  by (repeat (split; Col); try (intro; apply HABC; assert_cols; ColR); exists Y; split; Col; Between).

apply l9_9 in HTS; apply HTS; apply one_side_transitivity with D.



  assert (HACC : Col A C C) by Col.

  assert (HBDC' : Col B D C) by (assert_cols; Col).

  assert (H := l9_19 A C B D C HACC HBDC'); rewrite H.

  split; try (intro; apply HABC; Col).

  repeat (split; Between).



  assert (HACA : Col A C A) by Col.

  assert (HDTA : Col D T A) by (assert_cols; Col).

  assert (H := l9_19 A C D T A HACA HDTA); rewrite H.

  split; try (intro; apply HABC; assert_cols; ColR).

  repeat (split; Between).

Qed.



Lemma triangle_circumscription_implies_tarski_s_euclid_aux :

  forall A B C D T X Y Z M1 Z1 M2 Z2,

  triangle_circumscription_principle ->

  A <> B ->

  A <> C ->

  A <> D ->

  A <> T ->

  A <> Y ->

  B <> C ->

  B <> D ->

  B <> T ->

  B <> Y ->

  C <> D ->

  C <> T ->

  C <> Y ->

  D <> T ->

  T <> X ->

  T <> Y ->

  X <> Y ->

  Y <> Z1 ->

  Y <> Z2 ->

  ~ Col A B C ->

  Col A B M1 ->

  Col A C M2 ->

  Bet A D T ->

  ~ Col B C T ->

  Bet B D C ->

  Col T Y Z ->

  Bet Y T X ->

  Bet Y M1 Z1 ->

  Bet Y M2 Z2 ->

  Cong Y T T X ->

  Cong Y M1 M1 Z1 ->

  Cong Y M2 M2 Z2 ->

  Perp B C T Z ->

  Perp A B Y Z1 ->

  Perp A C Y Z2 ->

  exists x, exists y, Bet A B x /\ Bet A C y /\ Bet x T y.

Proof.

intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.

intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.

intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.

intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.

elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.



  exfalso; apply HABC; apply par_id.

  apply l12_9 with Y Z1; Perp.

    exists A; right; left; split; Col.

    apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.

    Cop.

    assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.

  apply perp_col1 with Z2; assert_diffs; Perp; ColR.



  exfalso; apply HABC; apply par_id_1.

  assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).

  apply l12_9 with Y Z1; [Cop..| |Perp|].

    apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].

    assert_diffs; apply col_cop__cop with Z; Col; Cop.

    assert_diffs; apply col_cop__cop with Z; Cop; ColR.

    exists D; left; split; Col.

  apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.



  exfalso; apply HABC; apply par_id_2.

  assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).

  apply l12_9 with Y Z2; [Cop..| |Perp|].

    apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].

    assert_diffs; apply col_cop__cop with Z; Col; Cop.

    assert_diffs; apply col_cop__cop with Z; Cop; ColR.

    exists D; left; split; Col.

  apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.



  assert (H := HXYZ1); apply HTC in H;

  destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x;

  assert (H := HXYZ2); apply HTC in H;

  destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.

  assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).

  assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).

  assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).

  assert (HCopB : Coplanar B C T B) by Cop.

  assert (HCopC : Coplanar B C T C) by Cop.

  assert (HCopT : Coplanar B C T T) by Cop.

  assert (HCopZ : Coplanar B C T Z) by Cop.

  assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).

  assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).

  assert (HCopZ1 : Coplanar B C T Z1).

  { assert (~ Col A B Y).

      intro; destruct (perp_not_col2 A B Y Z1) as [|HNCol]; Perp; apply HNCol; ColR.

    apply coplanar_pseudo_trans with A B Y; [| |apply coplanar_pseudo_trans with B C T..|]; Cop.

  }

  assert (HCopZ2 : Coplanar B C T Z2).

  { assert (~ Col A C Y).

      intro; destruct (perp_not_col2 A C Y Z2) as [|HNCol]; Perp; apply HNCol; ColR.

    apply coplanar_pseudo_trans with A C Y;

    [|apply coplanar_pseudo_trans with B C T| |apply coplanar_pseudo_trans with B C T|]; Cop.

  }

  assert (HCopx : Coplanar B C T x).

    apply coplanar_pseudo_trans with X Y Z1; trivial; apply coplanar_pseudo_trans with B C T; assumption.

  assert (HCopy : Coplanar B C T y).

    apply coplanar_pseudo_trans with X Y Z2; trivial; apply coplanar_pseudo_trans with B C T; assumption.

  assert (HCop : Coplanar X Y x y).

    apply coplanar_pseudo_trans with B C T; assumption.

  assert (HxTy : Col x T y) by (elim (eq_dec_points T x); intro; elim (eq_dec_points T y);

                                intro; try (subst; Col); apply col_permutation_4;

                                apply cop_perp2__col with X Y; trivial; apply perp_bisect_perp;

                                apply cong_cop_perp_bisect; Cong; Cop).

  assert (HABx : Col A B x).

    {

    elim (eq_dec_points A M1); intro HAM1; subst.



      {

      apply cong_cop2_perp_bisect_col with Y Z1; trivial.

        exists M1; left; split; Col.

        apply coplanar_pseudo_trans with B C T; assumption.

        apply cong_transitivity with X x; Cong.

      apply perp_mid_perp_bisect; try split; Cong.

      }



      {

      assert (Col M1 A x).

        {

        apply cong_cop2_perp_bisect_col with Y Z1; trivial.

          exists M1; left; split; Col.

          apply coplanar_pseudo_trans with B C T; assumption.

          apply cong_transitivity with X x; Cong.

        apply perp_mid_perp_bisect; try split; Cong.

        apply perp_left_comm; apply perp_col with B; Col.

        }

      ColR.

      }

    }



  assert (HACy : Col A C y).

    {

    elim (eq_dec_points A M2); intro HAM1; subst.



      {

      apply cong_cop2_perp_bisect_col with Y Z2; trivial.

        exists M2; left; split; Col.

        apply coplanar_pseudo_trans with B C T; assumption.

        apply cong_transitivity with X y; Cong.

      apply perp_mid_perp_bisect; try split; Cong.

      }



      {

      assert (Col M2 A y).

        {

        apply cong_cop2_perp_bisect_col with Y Z2; trivial.

          exists M2; left; split; Col.

          apply coplanar_pseudo_trans with B C T; assumption.

          apply cong_transitivity with X y; Cong.

        apply perp_mid_perp_bisect; try split; Cong.

        apply perp_left_comm; apply perp_col with C; Col.

        }

      ColR.

      }

    }

  assert (Hxy : x <> y).

  {

    intro; treat_equalities.

    assert (A = x) by (apply l6_21 with A B C A; Col); treat_equalities.

    assert (H : Par B C A T).

    {

      apply l12_9 with X Y; try (apply coplanar_pseudo_trans with B C T; assumption).



        apply perp_sym; apply perp_col2 with Z T; Perp; assert_cols; ColR.

        apply perp_bisect_perp; apply cong_cop_perp_bisect; Cong.

        exists T; left; split; Col.

    }

    elim H; clear H; intro H.



      apply H; exists D; assert_cols; Col.



      spliter; apply HABC; assert_cols; ColR.

  }

  assert (HPar : Par B C x y).

  {

    apply l12_9 with X Y; try (apply coplanar_pseudo_trans with B C T; assumption).



      apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.



      apply perp_bisect_perp; apply cong_cop_perp_bisect; Cong; Cop.

  }

  clear HPerp1; clear HPerp2; clear HPerp3.

  clear HCong1; clear HCong2; clear HCong3; clear HCong4.

  assert (HPar' : Par_strict B C x y)

    by (elim HPar; clear HPar; intro HPar; try assumption; spliter; exfalso; apply HABC; assert_cols; ColR);

  clear HPar; rename HPar' into HPar.

  elim HxTy; clear HxTy; intro HxTy.



    elim HABx; clear HABx; intro HABx.



      elim HACy; clear HACy; intro HACy; auto.

      elim HACy; clear HACy; intro HACy.



        exfalso; apply impossible_case_1 with A B C D T x y; assumption.



        exfalso; apply impossible_case_2 with A B C D T x y; assert_cols; Col.



      elim HABx; clear HABx; intro HABx.



        exfalso; apply impossible_case_3 with A B C D T x y; assumption.



        exfalso; apply impossible_case_2 with A C B D T y x; assert_cols; Col; Between.



    elim HxTy; clear HxTy; intro HxTy.



      exfalso; apply impossible_case_4 with A B C D T x y; assumption.



      exfalso; apply impossible_case_4 with A C B D T y x; Between; Col; Par.

Qed.



Lemma triangle_circumscription_implies_tarski_s_euclid :

  triangle_circumscription_principle ->

  tarski_s_parallel_postulate.

Proof.

unfold tarski_s_parallel_postulate.

intro HTC; apply tarski_s_euclid_remove_degenerated_cases.

intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC;

assert (HBCT : ~ Col B C T) by (intro; apply HABC; assert_cols; ColR).

assert (HY := l8_18_existence B C T HBCT); destruct HY as [Y [HBCY HPerp]].

elim (eq_dec_points B Y); intro HBY; elim (eq_dec_points C Y); intro HCY; treat_equalities.



  {

  exfalso; apply HBCT; Col.

  }



  {

  assert (HY := midpoint_existence B T); destruct HY as [Y HY].

  assert (HAY : A <> Y) by (intro; treat_equalities; assert_cols; apply HABC; ColR).

  assert (H := midpoint_distinct_1 Y B T HBT HY); destruct H as [HBY HTY];

  apply not_eq_sym in HBY; apply not_eq_sym in HTY.

  assert (HCY : C <> Y) by (intro; subst; apply HBCT; assert_cols; Col).

  destruct HY as [HBTY HBYTY].

  assert (HACY : ~ Col A C Y) by (apply impossible_two_sides_not_col with B D T; assumption).

  assert (HX := symmetric_point_construction Y T); destruct HX as [X HX].

  assert (H := midpoint_distinct_2 T Y X HTY HX); destruct H as [HTX HXY]; apply not_eq_sym in HTX.

  destruct HX as [HXTY HXTYT].

  assert (HZ1 := l10_2_existence A B Y); destruct HZ1 as [Z1 HZ1].

  elim HZ1; clear HZ1; intro HZ1; destruct HZ1 as [Hclear HZ1]; try contradiction; clear Hclear.

  destruct HZ1 as [[M1 [[HXM1Z1 HM1XM1Z1] HABM1]] HZ1].

  assert (HZ2 := l10_2_existence A C Y); destruct HZ2 as [Z2 HZ2].

  elim HZ2; clear HZ2; intro HZ2; destruct HZ2 as [Hclear HZ2]; try contradiction; clear Hclear.

  destruct HZ2 as [[M2 [[HXM2Z2 HM2XM2Z2] HACM2]] HZ2].

  elim (eq_dec_points Y Z1); intro HYZ1; treat_equalities.



    {

    assert (HFalse : Col A B C) by (assert_cols; ColR); contradiction.

    }



    {

    elim HZ1; clear HZ1; intro HZ1; try contradiction.

    elim (eq_dec_points Y Z2); intro HYZ2; treat_equalities; try contradiction.

    elim HZ2; clear HZ2; intro HZ2; try contradiction.

    apply triangle_circumscription_implies_tarski_s_euclid_aux with D X Y B M1 Z1 M2 Z2; try assumption.

    assert_cols; Col.

    }

  }



  {

  assert (HY := midpoint_existence C T); destruct HY as [Y HY].

  assert (HAY : A <> Y) by (intro; treat_equalities; assert_cols; apply HABC; ColR).

  assert (H := midpoint_distinct_1 Y C T HCT HY); destruct H as [HCY HTY];

  apply not_eq_sym in HCY; apply not_eq_sym in HTY.

  assert (HBY : B <> Y) by (intro; subst; apply HBCT; assert_cols; Col).

  destruct HY as [HCTY HCYTY].

  assert (HACY : ~ Col A B Y) by (apply impossible_two_sides_not_col with C D T; Between; Col).

  assert (HX := symmetric_point_construction Y T); destruct HX as [X HX].

  assert (H := midpoint_distinct_2 T Y X HTY HX); destruct H as [HTX HXY]; apply not_eq_sym in HTX.

  destruct HX as [HXTY HXTYT].

  assert (HZ1 := l10_2_existence A B Y); destruct HZ1 as [Z1 HZ1].

  elim HZ1; clear HZ1; intro HZ1; destruct HZ1 as [Hclear HZ1]; try contradiction; clear Hclear.

  destruct HZ1 as [[M1 [[HXM1Z1 HM1XM1Z1] HABM1]] HZ1].

  assert (HZ2 := l10_2_existence A C Y); destruct HZ2 as [Z2 HZ2].

  elim HZ2; clear HZ2; intro HZ2; destruct HZ2 as [Hclear HZ2]; try contradiction; clear Hclear.

  destruct HZ2 as [[M2 [[HXM2Z2 HM2XM2Z2] HACM2]] HZ2].

  elim (eq_dec_points Y Z2); intro HYZ2; treat_equalities.



    {

    assert (HFalse : Col A B C) by (assert_cols; ColR); contradiction.

    }



    {

    elim HZ2; clear HZ2; intro HZ2; try contradiction.

    elim (eq_dec_points Y Z1); intro HYZ1; treat_equalities; try contradiction.

    elim HZ1; clear HZ1; intro HZ1; try contradiction.

    apply triangle_circumscription_implies_tarski_s_euclid_aux with D X Y C M1 Z1 M2 Z2; try assumption.

    assert_cols; Col.

    }

  }



  {

  assert (HAY : A <> Y) by (intro; treat_equalities; assert_cols; apply HABC; ColR).

  assert (HX := symmetric_point_construction Y T); destruct HX as [X HX].

  assert (H := perp_distinct B C T Y HPerp); destruct H as [Hclear HTY]; clear Hclear.

  assert (H := midpoint_distinct_2 T Y X HTY HX); destruct H as [HTX HXY]; apply not_eq_sym in HTX.

  destruct HX as [HXTY HXTYT].

  assert (HZ1 := l10_2_existence A B Y); destruct HZ1 as [Z1 HZ1].

  elim HZ1; clear HZ1; intro HZ1; destruct HZ1 as [Hclear HZ1]; try contradiction; clear Hclear.

  destruct HZ1 as [[M1 [[HXM1Z1 HM1XM1Z1] HABM1]] HZ1].

  assert (HZ2 := l10_2_existence A C Y); destruct HZ2 as [Z2 HZ2].

  elim HZ2; clear HZ2; intro HZ2; destruct HZ2 as [Hclear HZ2]; try contradiction; clear Hclear.

  destruct HZ2 as [[M2 [[HXM2Z2 HM2XM2Z2] HACM2]] HZ2].

  assert (HABY : ~ Col A B Y) by (intro; apply HBY; apply l6_21 with A B C B; assert_cols; Col).

  assert (HACY : ~ Col A C Y) by (intro; apply HCY; apply l6_21 with A C B C; assert_cols; Col).

  elim (eq_dec_points Y Z1); intro HYZ1; treat_equalities; try contradiction.

  elim HZ1; clear HZ1; intro HZ1; try contradiction.

  elim (eq_dec_points Y Z2); intro HYZ2; treat_equalities; try contradiction.

  elim HZ2; clear HZ2; intro HZ2; try contradiction.

  apply triangle_circumscription_implies_tarski_s_euclid_aux with D X Y Y M1 Z1 M2 Z2; Col.

  }

Qed.



End TCP_tarski.
