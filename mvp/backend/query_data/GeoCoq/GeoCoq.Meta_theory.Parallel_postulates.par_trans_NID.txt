Require Import GeoCoq.Axioms.parallel_postulates.
(* GeoCoq.Axioms.parallel_postulates:
Require Import GeoCoq.Tarski_dev.Definitions.

Section Euclid_def.

Context `{Tn:Tarski_neutral_dimensionless}.

Definition decidability_of_parallelism := forall A B C D,
  Par A B C D \/ ~ Par A B C D.

Definition decidability_of_not_intersection := forall A B C D,
  ~ (exists I, Col I A B /\ Col I C D) \/
  ~ ~ (exists I, Col I A B /\ Col I C D).

Definition decidability_of_intersection := forall A B C D,
  (exists I, Col I A B /\ Col I C D) \/
  ~ (exists I, Col I A B /\ Col I C D).

Definition tarski_s_parallel_postulate := forall A B C D T,
  Bet A D T -> Bet B D C -> A <> D ->
  exists X Y, Bet A B X /\ Bet A C Y /\ Bet X T Y.

Definition playfair_s_postulate := forall A1 A2 B1 B2 C1 C2 P,
  Par A1 A2 B1 B2 -> Col P B1 B2 ->
  Par A1 A2 C1 C2 -> Col P C1 C2 ->
  Col C1 B1 B2 /\ Col C2 B1 B2.

Definition triangle_postulate := forall A B C D E F,
  TriSumA A B C D E F -> Bet D E F.

Definition bachmann_s_lotschnittaxiom := forall P Q R P1 R1,
  P <> Q -> Q <> R -> Per P Q R -> Per Q P P1 -> Per Q R R1 ->
  Coplanar P Q R P1 -> Coplanar P Q R R1 ->
  exists S, Col P P1 S /\ Col R R1 S.

Definition postulate_of_transitivity_of_parallelism := forall A1 A2 B1 B2 C1 C2,
  Par A1 A2 B1 B2 -> Par B1 B2 C1 C2 ->
  Par A1 A2 C1 C2.

Definition midpoint_converse_postulate := forall A B C P Q,
  ~ Col A B C ->
  Midpoint P B C -> Par A B Q P -> Col A C Q ->
  Midpoint Q A C.

Definition alternate_interior_angles_postulate := forall A B C D,
  TS A C B D -> Par A B C D ->
  CongA B A C D C A.

Definition consecutive_interior_angles_postulate := forall A B C D,
  OS B C A D -> Par A B C D -> SuppA A B C B C D.

Definition perpendicular_transversal_postulate := forall A B C D P Q,
  Par A B C D -> Perp A B P Q -> Coplanar C D P Q ->
  Perp C D P Q.

Definition postulate_of_parallelism_of_perpendicular_transversals :=
  forall A1 A2 B1 B2 C1 C2 D1 D2,
    Par A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 ->
    Coplanar A1 A2 C1 D1 -> Coplanar A1 A2 C1 D2 ->
    Coplanar A1 A2 C2 D1 -> Coplanar A1 A2 C2 D2 ->
    Par C1 C2 D1 D2.

Definition universal_posidonius_postulate := forall A1 A2 A3 A4 B1 B2 B3 B4,
  Par A1 A2 B1 B2 ->
  Col A1 A2 A3 -> Col B1 B2 B3 -> Perp A1 A2 A3 B3 ->
  Col A1 A2 A4 -> Col B1 B2 B4 -> Perp A1 A2 A4 B4 ->
  Cong A3 B3 A4 B4.

Definition alternative_playfair_s_postulate := forall A1 A2 B1 B2 C1 C2 P,
  Perp2 A1 A2 B1 B2 P -> ~ Col A1 A2 P -> Col P B1 B2 -> Coplanar A1 A2 B1 B2 ->
  Par A1 A2 C1 C2 -> Col P C1 C2 ->
  Col C1 B1 B2 /\ Col C2 B1 B2.

Definition proclus_postulate := forall A B C D P Q,
  Par A B C D -> Col A B P -> ~ Col A B Q -> Coplanar C D P Q ->
  exists Y, Col P Q Y /\ Col C D Y.

Definition alternative_proclus_postulate := forall A B C D P Q,
  Perp2 A B C D P -> ~ Col C D P -> Coplanar A B C D ->
  Col A B P -> ~ Col A B Q -> Coplanar C D P Q ->
  exists Y, Col P Q Y /\ Col C D Y.

Definition triangle_circumscription_principle := forall A B C,
  ~ Col A B C ->
  exists CC, Cong A CC B CC /\ Cong A CC C CC /\ Coplanar A B C CC.

Definition inverse_projection_postulate := forall A B C P Q,
  Acute A B C ->
  Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q ->
  exists Y, Out B C Y /\ Col P Q Y.

Definition euclid_5 := forall P Q R S T U,
  BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S ->
  Cong P T Q T -> Cong R T S T ->
  exists I, BetS S Q I /\ BetS P U I.

Definition strong_parallel_postulate :=  forall P Q R S T U,
  BetS P T Q -> BetS R T S -> ~ Col P R U ->
  Coplanar P Q R U ->
  Cong P T Q T -> Cong R T S T ->
  exists I, Col S Q I /\ Col P U I.

Definition alternative_strong_parallel_postulate := forall A B C D P Q R,
  OS B C A D -> SumA A B C B C D P Q R -> ~ Bet P Q R ->
  exists Y, Col B A Y /\ Col C D Y.

Definition euclid_s_parallel_postulate := forall A B C D P Q R,
  OS B C A D -> SAMS A B C B C D -> SumA A B C B C D P Q R -> ~ Bet P Q R ->
  exists Y, Out B A Y /\ Out C D Y.

Definition postulate_of_existence_of_a_triangle_whose_angles_sum_to_two_rights :=
  exists A B C D E F, ~ Col A B C /\ TriSumA A B C D E F /\ Bet D E F.

Definition posidonius_postulate :=
  exists A1 A2 B1 B2,
    ~ Col A1 A2 B1 /\ B1 <> B2 /\ Coplanar A1 A2 B1 B2 /\
    forall A3 A4 B3 B4,
      Col A1 A2 A3 -> Col B1 B2 B3 -> Perp A1 A2 A3 B3 ->
      Col A1 A2 A4 -> Col B1 B2 B4 -> Perp A1 A2 A4 B4 ->
      Cong A3 B3 A4 B4.

Definition postulate_of_existence_of_similar_triangles :=
  exists A B C D E F,
    ~ Col A B C /\ ~ Cong A B D E /\
    CongA A B C D E F /\ CongA B C A E F D /\ CongA C A B F D E.

Definition thales_postulate := forall A B C M,
  ~ Col A B C -> Midpoint M A B -> Cong M A M C ->
  Per A C B.

Definition thales_converse_postulate := forall A B C M,
  ~ Col A B C -> Midpoint M A B -> Per A C B ->
  Cong M A M C.

Definition existential_thales_postulate :=
  exists A B C M, ~ Col A B C /\ Midpoint M A B /\ Cong M A M C /\ Per A C B.

Definition postulate_of_right_saccheri_quadrilaterals := forall A B C D,
  Saccheri A B C D -> Per A B C.

Definition postulate_of_existence_of_a_right_saccheri_quadrilateral :=
  exists A B C D, Saccheri A B C D /\ Per A B C.

Definition postulate_of_right_lambert_quadrilaterals := forall A B C D,
  Lambert A B C D -> Per B C D.

Definition postulate_of_existence_of_a_right_lambert_quadrilateral :=
  exists A B C D, Lambert A B C D /\ Per B C D.

Definition weak_inverse_projection_postulate := forall A B C D E F P Q,
  Acute A B C -> Per D E F -> SumA A B C A B C D E F ->
  Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q ->
  exists Y, Out B C Y /\ Col P Q Y.

Definition weak_tarski_s_parallel_postulate := forall A B C T,
  Per A B C -> InAngle T A B C ->
  exists X Y, Out B A X /\ Out B C Y /\ Bet X T Y.

Definition weak_triangle_circumscription_principle := forall A B C A1 A2 B1 B2,
  ~ Col A B C -> Per A C B ->
  Perp_bisect A1 A2 B C -> Perp_bisect B1 B2 A C ->
  Coplanar A B C A1 -> Coplanar A B C A2 ->
  Coplanar A B C B1 -> Coplanar A B C B2 ->
  exists I, Col A1 A2 I /\ Col B1 B2 I.

Definition legendre_s_parallel_postulate :=
  exists A B C,
    ~ Col A B C /\ Acute A B C /\
    forall T,
      InAngle T A B C ->
      exists X Y, Out B A X /\ Out B C Y /\ Bet X T Y.

Definition existential_playfair_s_postulate :=
  exists A1 A2 P, ~ Col A1 A2 P /\
             (forall B1 B2 C1 C2,
                Par A1 A2 B1 B2 -> Col P B1 B2 ->
                Par A1 A2 C1 C2 -> Col P C1 C2 ->
                Col C1 B1 B2 /\ Col C2 B1 B2).

End Euclid_def. *)

Require Import GeoCoq.Tarski_dev.Ch12_parallel.
(* GeoCoq.Tarski_dev.Ch12_parallel:
Require Export GeoCoq.Tarski_dev.Ch11_angles.

Section T12_1.

Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.

Lemma par_reflexivity : forall A B, A<>B -> Par A B A B.

Lemma par_strict_irreflexivity : forall A B,
 ~ Par_strict A B A B.

Lemma not_par_strict_id : forall A B C,
 ~ Par_strict A B A C.

Lemma par_id : forall A B C,
 Par A B A C -> Col A B C.

Lemma par_strict_not_col_1 : forall A B C D,
 Par_strict A B C D  -> ~ Col A B C.

Lemma par_strict_not_col_2 : forall A B C D,
 Par_strict A B C D  -> ~ Col B C D.

Lemma par_strict_not_col_3 : forall A B C D,
 Par_strict A B C D  -> ~ Col C D A.

Lemma par_strict_not_col_4 : forall A B C D,
 Par_strict A B C D  -> ~ Col A B D.

Lemma par_strict_not_cols : forall A B C D,
 Par_strict A B C D -> ~ Col A B C /\ ~ Col B C D /\ ~ Col C D A /\ ~ Col A B D.

Lemma par_id_1 : forall A B C,
 Par A B A C -> Col B A C.

Lemma par_id_2 : forall A B C,
 Par A B A C -> Col B C A.

Lemma par_id_3 : forall A B C,
 Par A B A C -> Col A C B.

Lemma par_id_4 : forall A B C,
 Par A B A C -> Col C B A.

Lemma par_id_5 : forall A B C,
 Par A B A C -> Col C A B.

Lemma par_strict_symmetry :forall A B C D,
 Par_strict A B C D -> Par_strict C D A B.

Lemma par_symmetry :forall A B C D,
 Par A B C D -> Par C D A B.

Lemma par_left_comm : forall A B C D,
 Par A B C D -> Par B A C D.

Lemma par_right_comm : forall A B C D,
 Par A B C D -> Par A B D C.

Lemma par_comm : forall A B C D,
 Par A B C D -> Par B A D C.

Lemma par_strict_left_comm : forall A B C D,
 Par_strict A B C D -> Par_strict B A C D.

Lemma par_strict_right_comm : forall A B C D,
 Par_strict A B C D -> Par_strict A B D C.

Lemma par_strict_comm : forall A B C D,
 Par_strict A B C D -> Par_strict B A D C.

Lemma par_strict_neq1 : forall A B C D, Par_strict A B C D -> A <> B.

Lemma par_strict_neq2 : forall A B C D, Par_strict A B C D -> C <> D.

Lemma par_neq1 : forall A B C D, Par A B C D -> A <> B.

Lemma par_neq2 : forall A B C D, Par A B C D -> C <> D.

End T12_1.

Ltac assert_diffs :=
repeat
 match goal with
      | H:(~Col ?X1 ?X2 ?X3) |- _ =>
      let h := fresh in
      not_exist_hyp3 X1 X2 X1 X3 X2 X3;
      assert (h := not_col_distincts X1 X2 X3 H);decompose [and] h;clear h;clean_reap_hyps

      | H:(~Bet ?X1 ?X2 ?X3) |- _ =>
      let h := fresh in
      not_exist_hyp2 X1 X2 X2 X3;
      assert (h := not_bet_distincts X1 X2 X3 H);decompose [and] h;clear h;clean_reap_hyps
      | H:Bet ?A ?B ?C, H2 : ?A <> ?B |-_ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= bet_neq12__neq A B C H H2);clean_reap_hyps
      | H:Bet ?A ?B ?C, H2 : ?B <> ?A |-_ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= bet_neq21__neq A B C H H2);clean_reap_hyps
      | H:Bet ?A ?B ?C, H2 : ?B <> ?C |-_ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= bet_neq23__neq A B C H H2);clean_reap_hyps
      | H:Bet ?A ?B ?C, H2 : ?C <> ?B |-_ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= bet_neq32__neq A B C H H2);clean_reap_hyps

      | H:Cong ?A ?B ?C ?D, H2 : ?A <> ?B |-_ =>
      let T:= fresh in (not_exist_hyp_comm C D);
        assert (T:= cong_diff A B C D H2 H);clean_reap_hyps
      | H:Cong ?A ?B ?C ?D, H2 : ?B <> ?A |-_ =>
      let T:= fresh in (not_exist_hyp_comm C D);
        assert (T:= cong_diff_2 A B C D H2 H);clean_reap_hyps
      | H:Cong ?A ?B ?C ?D, H2 : ?C <> ?D |-_ =>
      let T:= fresh in (not_exist_hyp_comm A B);
        assert (T:= cong_diff_3 A B C D H2 H);clean_reap_hyps
      | H:Cong ?A ?B ?C ?D, H2 : ?D <> ?C |-_ =>
      let T:= fresh in (not_exist_hyp_comm A B);
        assert (T:= cong_diff_4 A B C D H2 H);clean_reap_hyps

      | H:Le ?A ?B ?C ?D, H2 : ?A <> ?B |-_ =>
      let T:= fresh in (not_exist_hyp_comm C D);
        assert (T:= le_diff A B C D H2 H);clean_reap_hyps
      | H:Le ?A ?B ?C ?D, H2 : ?B <> ?A |-_ =>
      let T:= fresh in (not_exist_hyp_comm C D);
        assert (T:= le_diff A B C D (swap_diff B A H2) H);clean_reap_hyps
      | H:Lt ?A ?B ?C ?D |-_ =>
      let T:= fresh in (not_exist_hyp_comm C D);
        assert (T:= lt_diff A B C D H);clean_reap_hyps

      | H:Midpoint ?I ?A ?B, H2 : ?A<>?B |- _ =>
      let T:= fresh in (not_exist_hyp2 I B I A);
       assert (T:= midpoint_distinct_1 I A B H2 H);
       decompose [and] T;clear T;clean_reap_hyps
      | H:Midpoint ?I ?A ?B, H2 : ?B<>?A |- _ =>
      let T:= fresh in (not_exist_hyp2 I B I A);
       assert (T:= midpoint_distinct_1 I A B (swap_diff B A H2) H);
       decompose [and] T;clear T;clean_reap_hyps

      | H:Midpoint ?I ?A ?B, H2 : ?I<>?A |- _ =>
      let T:= fresh in (not_exist_hyp2 I B A B);
       assert (T:= midpoint_distinct_2 I A B H2 H);
       decompose [and] T;clear T;clean_reap_hyps
      | H:Midpoint ?I ?A ?B, H2 : ?A<>?I |- _ =>
      let T:= fresh in (not_exist_hyp2 I B A B);
       assert (T:= midpoint_distinct_2 I A B (swap_diff A I H2) H);
       decompose [and] T;clear T;clean_reap_hyps

      | H:Midpoint ?I ?A ?B, H2 : ?I<>?B |- _ =>
      let T:= fresh in (not_exist_hyp2 I A A B);
       assert (T:= midpoint_distinct_3 I A B H2 H);
       decompose [and] T;clear T;clean_reap_hyps
      | H:Midpoint ?I ?A ?B, H2 : ?B<>?I |- _ =>
      let T:= fresh in (not_exist_hyp2 I A A B);
       assert (T:= midpoint_distinct_3 I A B (swap_diff B I H2) H);
       decompose [and] T;clear T;clean_reap_hyps

      | H:Per ?A ?B ?C, H2 : ?A<>?B |- _ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= per_distinct A B C H H2); clean_reap_hyps
      | H:Per ?A ?B ?C, H2 : ?B<>?A |- _ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= per_distinct A B C H (swap_diff B A H2)); clean_reap_hyps
      | H:Per ?A ?B ?C, H2 : ?B<>?C |- _ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= per_distinct_1 A B C H H2); clean_reap_hyps
      | H:Per ?A ?B ?C, H2 : ?C<>?B |- _ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= per_distinct_1 A B C H (swap_diff C B H2)); clean_reap_hyps

      | H:Perp ?A ?B ?C ?D |- _ =>
      let T:= fresh in (not_exist_hyp2 A B C D);
       assert (T:= perp_distinct A B C D H);
       decompose [and] T;clear T;clean_reap_hyps
      | H:Perp_at ?X ?A ?B ?C ?D |- _ =>
      let T:= fresh in (not_exist_hyp2 A B C D);
       assert (T:= perp_in_distinct X A B C D H);
       decompose [and] T;clear T;clean_reap_hyps
      | H:Out ?A ?B ?C |- _ =>
      let T:= fresh in (not_exist_hyp2 A B A C);
       assert (T:= out_distinct A B C H);
       decompose [and] T;clear T;clean_reap_hyps

      | H:TS ?A ?B ?C ?D |- _ =>
      let h := fresh in
      not_exist_hyp6 A B A C A D B C B D C D;
      assert (h := ts_distincts A B C D H);decompose [and] h;clear h;clean_reap_hyps
      | H:OS ?A ?B ?C ?D |- _ =>
      let h := fresh in
      not_exist_hyp5 A B A C A D B C B D;
      assert (h := os_distincts A B C D H);decompose [and] h;clear h;clean_reap_hyps
      | H:~ Coplanar ?A ?B ?C ?D |- _ =>
      let h := fresh in
      not_exist_hyp6 A B A C A D B C B D C D;
      assert (h := ncop_distincts A B C D H);decompose [and] h;clear h;clean_reap_hyps

      | H:CongA ?A ?B ?C ?A' ?B' ?C' |- _ =>
      let T:= fresh in (not_exist_hyp_comm A B);
        assert (T:= conga_diff1 A B C A' B' C' H);clean_reap_hyps
      | H:CongA ?A ?B ?C ?A' ?B' ?C' |- _ =>
      let T:= fresh in (not_exist_hyp_comm B C);
        assert (T:= conga_diff2 A B C A' B' C' H);clean_reap_hyps
      | H:CongA ?A ?B ?C ?A' ?B' ?C' |- _ =>
      let T:= fresh in (not_exist_hyp_comm A' B');
        assert (T:= conga_diff45 A B C A' B' C' H);clean_reap_hyps
      | H:CongA ?A ?B ?C ?A' ?B' ?C' |- _ =>
      let T:= fresh in (not_exist_hyp_comm B' C');
        assert (T:= conga_diff56 A B C A' B' C' H);clean_reap_hyps

      | H:(InAngle ?P ?A ?B ?C) |- _ =>
      let h := fresh in
      not_exist_hyp3 A B C B P B;
      assert (h := inangle_distincts A B C P H);decompose [and] h;clear h;clean_reap_hyps
      | H:LeA ?A ?B ?C ?D ?E ?F |- _ =>
      let h := fresh in
      not_exist_hyp4 A B B C D E E F;
      assert (h := lea_distincts A B C D E F H);decompose [and] h;clear h;clean_reap_hyps
      | H:LtA ?A ?B ?C ?D ?E ?F |- _ =>
      let h := fresh in
      not_exist_hyp4 A B B C D E E F;
      assert (h := lta_distincts A B C D E F H);decompose [and] h;clear h;clean_reap_hyps
      | H:(Acute ?A ?B ?C) |- _ =>
      let h := fresh in
      not_exist_hyp2 A B B C;
      assert (h := acute_distincts A B C H);decompose [and] h;clear h;clean_reap_hyps
      | H:(Obtuse ?A ?B ?C) |- _ =>
      let h := fresh in
      not_exist_hyp2 A B B C;
      assert (h := obtuse_distincts A B C H);decompose [and] h;clear h;clean_reap_hyps
      | H:SuppA ?A ?B ?C ?D ?E ?F |- _ =>
      let h := fresh in
      not_exist_hyp4 A B B C D E E F;
      assert (h := suppa_distincts A B C D E F H);decompose [and] h;clear h;clean_reap_hyps

      | H:(Orth_at ?X ?A ?B ?C ?U ?V) |- _ =>
      let h := fresh in
      not_exist_hyp4 A B A C B C U V;
      assert (h := orth_at_distincts A B C U V X H);decompose [and] h;clear h;clean_reap_hyps
      | H:(Orth ?A ?B ?C ?U ?V) |- _ =>
      let h := fresh in
      not_exist_hyp4 A B A C B C U V;
      assert (h := orth_distincts A B C U V H);decompose [and] h;clear h;clean_reap_hyps

      | H:Par ?A ?B ?C ?D |- _ =>
      let T:= fresh in (not_exist_hyp_comm A B);
        assert (T:= par_neq1 A B C D H);clean_reap_hyps
      | H:Par ?A ?B ?C ?D |- _ =>
      let T:= fresh in (not_exist_hyp_comm C D);
        assert (T:= par_neq2 A B C D H);clean_reap_hyps
      | H:Par_strict ?A ?B ?C ?D |- _ =>
      let T:= fresh in (not_exist_hyp_comm A B);
        assert (T:= par_strict_neq1 A B C D H);clean_reap_hyps
      | H:Par_strict ?A ?B ?C ?D |- _ =>
      let T:= fresh in (not_exist_hyp_comm C D);
        assert (T:= par_strict_neq2 A B C D H);clean_reap_hyps
 end.

Ltac assert_ncols :=
repeat
  match goal with
      | H:OS ?A ?B ?X ?Y |- _ =>
     not_exist_hyp_perm_ncol A B X;assert (~ Col A B X) by (apply(one_side_not_col123 A B X Y);finish)

      | H:OS ?A ?B ?X ?Y |- _ =>
     not_exist_hyp_perm_ncol A B Y;assert (~ Col A B Y) by (apply(one_side_not_col124 A B X Y);finish)

      | H:TS ?A ?B ?X ?Y |- _ =>
     not_exist_hyp_perm_ncol A B X;assert (~ Col A B X) by (apply(two_sides_not_col A B X Y);finish)

      | H:TS ?A ?B ?X ?Y |- _ =>
     not_exist_hyp_perm_ncol A B Y;assert (~ Col A B Y) by (apply(two_sides_not_col A B Y X);finish)

      | H:~ Coplanar ?A ?B ?C ?D |- _ =>
      let h := fresh in
      not_exist_hyp_perm4 A B C D;
      assert (h := ncop__ncols A B C D H);decompose [and] h;clear h;clean_reap_hyps

      | H:Par_strict ?A ?B ?C ?D |- _ =>
      let h := fresh in
      not_exist_hyp_perm4 A B C D;
      assert (h := par_strict_not_cols A B C D H);decompose [and] h;clear h;clean_reap_hyps
  end.

Hint Resolve
 par_reflexivity par_strict_irreflexivity
 par_strict_symmetry par_strict_comm par_strict_right_comm par_strict_left_comm
 par_symmetry par_comm par_right_comm par_left_comm : par.

Hint Resolve par_strict_not_col_1 par_strict_not_col_2
             par_strict_not_col_3 par_strict_not_col_4 : col.

Ltac Par := eauto with par.

Section T12_2.

Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.

Lemma Par_cases :
  forall A B C D,
  Par A B C D \/ Par B A C D \/ Par A B D C \/ Par B A D C \/
  Par C D A B \/ Par C D B A \/ Par D C A B \/ Par D C B A ->
  Par A B C D.

Lemma Par_perm :
  forall A B C D,
  Par A B C D ->
  Par A B C D /\ Par B A C D /\ Par A B D C /\ Par B A D C /\
  Par C D A B /\ Par C D B A /\ Par D C A B /\ Par D C B A.

Lemma Par_strict_cases :
  forall A B C D,
  Par_strict A B C D \/ Par_strict B A C D \/ Par_strict A B D C \/ Par_strict B A D C \/
  Par_strict C D A B \/ Par_strict C D B A \/ Par_strict D C A B \/ Par_strict D C B A ->
  Par_strict A B C D.

Lemma Par_strict_perm :
  forall A B C D,
  Par_strict A B C D ->
  Par_strict A B C D /\ Par_strict B A C D /\ Par_strict A B D C /\ Par_strict B A D C /\
  Par_strict C D A B /\ Par_strict C D B A /\ Par_strict D C A B /\ Par_strict D C B A.

End T12_2.

Section T12_2'.

Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.

Lemma l12_6 : forall A B C D,
 Par_strict A B C D -> OS A B C D.

Lemma pars__os3412 : forall A B C D,
 Par_strict A B C D -> OS C D A B.

Lemma perp_dec : forall A B C D, Perp A B C D \/ ~ Perp A B C D.

Lemma col_cop2_perp2__col : forall X1 X2 Y1 Y2 A B,
 Perp X1 X2 A B -> Perp Y1 Y2 A B -> Col X1 Y1 Y2 ->
 Coplanar A B X2 Y1 -> Coplanar A B X2 Y2 -> Col X2 Y1 Y2.

Lemma col_perp2_ncol__col : forall X1 X2 Y1 Y2 A B,
 Perp X1 X2 A B -> Perp Y1 Y2 A B ->
 Col X1 Y1 Y2 -> ~ Col X1 A B ->
 Col X2 Y1 Y2.

Lemma l12_9 : forall A1 A2 B1 B2 C1 C2,
 Coplanar C1 C2 A1 B1 -> Coplanar C1 C2 A1 B2 ->
 Coplanar C1 C2 A2 B1 -> Coplanar C1 C2 A2 B2 ->
 Perp A1 A2 C1 C2 -> Perp B1 B2 C1 C2 ->
 Par A1 A2 B1 B2.

Lemma parallel_existence : forall A B P, A <> B ->
 exists C, exists D, C<>D /\ Par A B C D /\ Col P C D.

Lemma par_col_par : forall A B C D D',
 C <> D' -> Par A B C D -> Col C D D' -> Par A B C D'.

Lemma parallel_existence1 : forall A B P, A <> B -> exists Q, Par A B P Q.

Lemma par_not_col : forall A B C D X, Par_strict A B C D -> Col X A B -> ~Col X C D.

Lemma not_strict_par1 : forall A B C D X, Par A B C D -> Col A B X -> Col C D X -> Col A B C.

Lemma not_strict_par2 : forall A B C D X, Par A B C D -> Col A B X -> Col C D X -> Col A B D.

Lemma not_strict_par : forall A B C D X, Par A B C D -> Col A B X -> Col C D X -> Col A B C /\ Col A B D.

Lemma not_par_not_col : forall A B C, A <> B -> A <> C -> ~Par A B A C -> ~Col A B C.

Lemma not_par_inter_uniqueness : forall A B C D X Y,
  A <> B -> C <> D -> ~Par A B C D -> Col A B X -> Col C D X -> Col A B Y -> Col C D Y ->
  X = Y.

Lemma inter_uniqueness_not_par : forall A B C D P,
  ~Col A B C -> Col A B P -> Col C D P -> ~Par A B C D.

Lemma col_not_col_not_par :
 forall A B C D,
 (exists P, Col A B P /\ Col C D P) ->
 (exists Q, Col C D Q /\ ~Col A B Q) -> ~Par A B C D.

Lemma par_distincts : forall A B C D,
 Par A B C D -> (Par A B C D /\ A <> B /\ C <> D).

Lemma par_not_col_strict : forall A B C D P,
 Par A B C D -> Col C D P -> ~Col A B P -> Par_strict A B C D.

Lemma all_one_side_par_strict : forall A B C D,
 C <> D -> (forall P, Col C D P -> OS A B C P) ->
 Par_strict A B C D.

Lemma par_col_par_2 : forall A B C D P,
 A <> P -> Col A B P -> Par A B C D -> Par A P C D.

Lemma par_col2_par : forall A B C D E F,
 E <> F -> Par A B C D -> Col C D E -> Col C D F -> Par A B E F.

Lemma par_col2_par_bis : forall A B C D E F,
 E <> F -> Par A B C D -> Col E F C -> Col E F D -> Par A B E F.

Lemma par_strict_col_par_strict : forall A B C D E,
 C <> E -> Par_strict A B C D -> Col C D E ->
 Par_strict A B C E.

Lemma par_strict_col2_par_strict : forall A B C D E F,
 E <> F -> Par_strict A B C D -> Col C D E -> Col C D F ->
 Par_strict A B E F.

Lemma line_dec : forall B1 B2 C1 C2, (Col C1 B1 B2 /\ Col C2 B1 B2) \/ ~ (Col C1 B1 B2 /\ Col C2 B1 B2).

Lemma par_distinct : forall A B C D, Par A B C D -> A <> B /\ C <> D.

Lemma par_col4__par : forall A B C D E F G H, E <> F -> G <> H -> Par A B C D ->
 Col A B E -> Col A B F -> Col C D G -> Col C D H -> Par E F G H.

Lemma par_strict_col4__par_strict : forall A B C D E F G H, E <> F -> G <> H ->
 Par_strict A B C D -> Col A B E -> Col A B F -> Col C D G -> Col C D H ->
 Par_strict E F G H.

Lemma par_strict_one_side : forall A B C D P,
 Par_strict A B C D -> Col C D P -> OS A B C P.

Lemma par_strict_all_one_side : forall A B C D,
 Par_strict A B C D -> (forall P, Col C D P -> OS A B C P).

Lemma inter_distincts : forall A B C D X, Inter A B C D X -> A <> B /\ C <> D.

Lemma inter_trivial : forall A B X, ~ Col A B X -> Inter A X B X X.

Lemma inter_sym : forall A B C D X, Inter A B C D X -> Inter C D A B X.

Lemma inter_left_comm : forall A B C D X, Inter A B C D X -> Inter B A C D X.

Lemma inter_right_comm : forall A B C D X, Inter A B C D X -> Inter A B D C X.

Lemma inter_comm : forall A B C D X, Inter A B C D X -> Inter B A D C X.

Lemma l12_17 : forall A B C D P,
 A <> B -> Midpoint P A C -> Midpoint P B D -> Par A B C D.

Lemma l12_18_a :
  forall A B C D P,
  Cong A B C D -> Cong B C D A -> ~Col A B C ->
  B <> D -> Col A P C -> Col B P D ->
  Par A B C D.

Lemma l12_18_b :
  forall A B C D P,
  Cong A B C D -> Cong B C D A -> ~Col A B C ->
  B <> D -> Col A P C -> Col B P D ->
  Par B C D A.

Lemma l12_18_c :
 forall A B C D P,
  Cong A B C D -> Cong B C D A -> ~Col A B C ->
  B <> D -> Col A P C -> Col B P D ->
  TS B D A C.

Lemma l12_18_d :
 forall A B C D P,
 Cong A B C D -> Cong B C D A -> ~Col A B C ->
 B <> D -> Col A P C -> Col B P D ->
 TS A C B D.

Lemma l12_18 :
 forall A B C D P,
  Cong A B C D -> Cong B C D A -> ~Col A B C ->
  B <> D -> Col A P C -> Col B P D ->
  Par A B C D /\ Par B C D A /\ TS B D A C /\ TS A C B D.

Lemma par_two_sides_two_sides :
  forall A B C D,
  Par A B C D -> TS B D A C ->
  TS A C B D.

Lemma par_one_or_two_sides :
 forall A B C D,
  Par_strict A B C D ->
 TS A C B D /\ TS B D A C \/ OS A C B D /\ OS B D A C.

Lemma l12_21_b : forall A B C D,
 TS A C B D ->
 CongA B A C D C A -> Par A B C D.

Lemma l12_22_aux :
 forall A B C D P,
  P <> A -> A <> C -> Bet P A C -> OS P A B D ->
  CongA B A P D C P ->
  Par A B C D.

Lemma l12_22_b :
 forall A B C D P,
  Out P A C -> OS P A B D -> CongA B A P D C P ->
  Par A B C D.

Lemma par_strict_par : forall A B C D,
 Par_strict A B C D -> Par A B C D.

Lemma par_strict_distinct : forall A B C D,
 Par_strict A B C D ->
  A<>B /\ A<>C /\ A<>D /\ B<>C /\ B<>D /\ C<>D.

Lemma col_par : forall A B C,
 A <> B -> B <> C ->
 Col A B C -> Par A B B C.

Lemma acute_col_perp__out : forall A B C A',
  Acute A B C -> Col B C A' -> Perp B C A A' -> Out B A' C.

Lemma acute_col_perp__out_1 : forall A B C A',
  Acute A B C -> Col B C A' -> Perp B A A A' -> Out B A' C.

Lemma conga_cop_inangle_per2__inangle : forall A B C P T,
  Per A B C -> InAngle T A B C -> CongA P B A P B C -> Per B P T -> Coplanar A B C P ->
  InAngle P A B C.

End T12_2'.

Hint Resolve col_par par_strict_par : par.

Hint Resolve l12_6 pars__os3412 : side.

Section T12_3.

Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.

Lemma perp_not_par : forall A B X Y, Perp A B X Y -> ~ Par A B X Y.

Lemma cong_conga_perp : forall A B C P, TS B P A C -> Cong A B C B -> CongA A B P C B P -> Perp A C B P.

Lemma perp_inter_exists : forall A B C D, Perp A B C D -> exists P, Col A B P /\ Col C D P.

Lemma perp_inter_perp_in : forall A B C D, Perp A B C D -> exists P, Col A B P /\ Col C D P /\ Perp_at P A B C D.

End T12_3.

Section T12_2D.

Context `{T2D:Tarski_2D}.

Lemma col_perp2__col : forall X1 X2 Y1 Y2 A B,
  Perp X1 X2 A B -> Perp Y1 Y2 A B -> Col X1 Y1 Y2 -> Col X2 Y1 Y2.

Lemma l12_9_2D : forall A1 A2 B1 B2 C1 C2,
  Perp A1 A2 C1 C2 -> Perp B1 B2 C1 C2 -> Par A1 A2 B1 B2.

Lemma conga_inangle_per2__inangle : forall A B C P T,
  Per A B C -> InAngle T A B C -> CongA P B A P B C -> Per B P T ->
  InAngle P A B C.

End T12_2D. *)



Section par_trans_NID.



Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.



Lemma par_dec_NID : decidability_of_parallelism <-> decidability_of_not_intersection.

Proof.

split; intros Hdec A B C D; destruct (cop_dec A B C D) as [|HNCop].

- destruct (Hdec A B C D) as [[HParS|Heq]|HNPar].

  * left; unfold Par_strict in HParS; spliter; assumption.

  * right; intro Habs; apply Habs; exists B; spliter; Col.

  * right; intro Habs.

    destruct (eq_dec_points A B).

      apply Habs; exists C; subst; split; Col.

    destruct (eq_dec_points C D).

      apply Habs; exists A; subst; split; Col.

    apply HNPar; left; unfold Par_strict; repeat split; assumption.



- left; intros [I []]; apply HNCop; exists I; left; split; Col.



- destruct (eq_dec_points A B).

    right; subst; intro; assert_diffs; auto.

  destruct (eq_dec_points C D).

    right; subst; intro; assert_diffs; auto.

  destruct (col_dec A C D).



  {

    destruct (col_dec B C D).

      left; right; repeat split; assumption.

    right; intros [[_ [_ [_ Habs]]]|].

      apply Habs; exists A; split; Col.

    spliter; auto.

  }



  destruct (Hdec A B C D) as [HPar|HNPar].

    left; left; repeat split; assumption.

  right.

  intros [HParS|Heq].

    apply HNPar; unfold Par_strict in HParS; spliter; assumption.

  spliter; auto.



- right; intro HPar; apply HNCop, par__coplanar, HPar.

Qed.



Lemma par_trans__par_dec :

  postulate_of_transitivity_of_parallelism ->

  decidability_of_parallelism.

Proof.

intros HTP A B C D.

elim (eq_dec_points A B); intro HAB;

[treat_equalities; right; intro; assert_diffs; intuition|].

elim (eq_dec_points C D); intro HCD;

[treat_equalities; right; intro; assert_diffs; intuition|].

destruct (parallel_existence1 A B C HAB) as [D' HPar].

elim (col_dec C D D'); intro HCol;

[left; apply par_col_par with D'; Par; Col|

 right; intro; apply HCol; apply par_id_3; apply HTP with A B; Par].

Qed.



Lemma col_int : forall A B C,

  Col A B C <-> ~ (~ Bet A B C /\ ~ Bet B C A /\ ~ Bet C A B).

Proof.

intros A B C; unfold Col.

induction (bet_dec A B C); induction (bet_dec B C A); induction (bet_dec C A B);

intuition.

Qed.



Definition playfair_ter := forall A1 A2 B1 B2 C1 C2 P,

  A1 <> A2 -> B1 <> B2 -> C1 <> C2 ->

  Col P B1 B2 -> Col P C1 C2 ->

  ~ (Col A1 B1 B2 /\ Col A2 B1 B2) ->

  ~ (Col A1 C1 C2 /\ Col A2 C1 C2) ->

  ~ (Col C1 B1 B2 /\ Col C2 B1 B2) ->

  (exists I, ~ (~ (Col A1 A2 I /\ Col B1 B2 I) /\

                ~ (Col A1 B1 I /\ Col A2 B2 I) /\

                ~ (Col A1 B2 I /\ Col A2 B1 I))) ->

  (exists I, ~ (~ (Col A1 A2 I /\ Col C1 C2 I) /\

               ~ (Col A1 C1 I /\ Col A2 C2 I) /\

               ~ (Col A1 C2 I /\ Col A2 C1 I))) ->

  ~ (~ (exists I, Col I A1 A2 /\ Col I B1 B2) /\

     ~ (exists I, Col I A1 A2 /\ Col I C1 C2)).



Definition playfair_quater_qf A1 A2 B1 B2 C1 C2 P :=

  A1 <> A2 /\ B1 <> B2 /\ C1 <> C2 /\

  Col P B1 B2 /\ Col P C1 C2 /\

  ~ (Col A1 B1 B2 /\ Col A2 B1 B2) /\

  ~ (Col A1 C1 C2 /\ Col A2 C1 C2) /\

  ~ (Col C1 B1 B2 /\ Col C2 B1 B2) /\

  (exists I, ~ (~ (Col A1 A2 I /\ Col B1 B2 I) /\

                ~ (Col A1 B1 I /\ Col A2 B2 I) /\

                ~ (Col A1 B2 I /\ Col A2 B1 I))) /\

  (exists I, ~ (~ (Col A1 A2 I /\ Col C1 C2 I) /\

                ~ (Col A1 C1 I /\ Col A2 C2 I) /\

                ~ (Col A1 C2 I /\ Col A2 C1 I))) /\

  ~ (exists I, Col I A1 A2 /\ Col I B1 B2) /\

  ~ (exists I, Col I A1 A2 /\ Col I C1 C2).



Definition playfair_quater := ~ exists A1 A2 B1 B2 C1 C2 P,

  playfair_quater_qf A1 A2 B1 B2 C1 C2 P.



Lemma playfair__playfair_ter :

  playfair_s_postulate -> playfair_ter.

Proof.

intros HP A1 A2 B1 B2 C1 C2 P HA HB HC HP1 HP2 HNC1 HNC2 HNC3 HIAB HIAC.

intros [HAB HAC]. apply HNC3.

apply (HP A1 A2 B1 B2 C1 C2 P); Col; left;

repeat (split; Col).



  {

  destruct HIAB as [IAB HIAB]; exists IAB.

  clear HA HB HC HP1 HP2 HNC1 HNC2 HNC3 HIAC HAB HAC P C1 C2.

  induction (col_dec A1 A2 IAB); induction (col_dec B1 B2 IAB);

  try solve [left; Col];

  induction (col_dec A1 B1 IAB); induction (col_dec A2 B2 IAB);

  try solve [right; left; Col];

  induction (col_dec A1 B2 IAB); induction (col_dec A2 B1 IAB);

  try solve [right; right; Col];

  exfalso; apply HIAB; intuition.

  }



  {

  destruct HIAC as [IAC HIAC]; exists IAC.

  clear HA HB HC HP1 HP2 HNC1 HNC2 HNC3 HIAB HAB HAC P B1 B2.

  induction (col_dec A1 A2 IAC); induction (col_dec C1 C2 IAC);

  try solve [left; Col];

  induction (col_dec A1 C1 IAC); induction (col_dec A2 C2 IAC);

  try solve [right; left; Col];

  induction (col_dec A1 C2 IAC); induction (col_dec A2 C1 IAC);

  try solve [right; right; Col];

  exfalso; apply HIAC; intuition.

  }

Qed.



Lemma playfair__playfair_quater :

  playfair_s_postulate -> playfair_quater.

Proof.

intro HP; intro HPQ; destruct HPQ as [A1 [A2 [B1 [B2 [C1 [C2 [P HPQ]]]]]]].

assert (H:= HP A1 A2 B1 B2 C1 C2 P); clear HP.

destruct HPQ as [HD1 [HD2 [HD3 [HC1 [HC2 [HNC1 [HNC2 [HNC3 HPQ]]]]]]]].

destruct HPQ as [HIAB [HIAC [HNI1 HNI2]]].

apply HNC3; apply H; clear H; Col; left;

repeat (split; try assumption); auto.



  {

  destruct HIAB as [IAB HIAB]; exists IAB.

  clear HD1 HD2 HD3 HC1 HC2 HNC1 HNC2 HNC3 HIAC HNI1 HNI2 P C1 C2.

  induction (col_dec A1 A2 IAB); induction (col_dec B1 B2 IAB);

  try solve [left; Col];

  induction (col_dec A1 B1 IAB); induction (col_dec A2 B2 IAB);

  try solve [right; left; Col];

  induction (col_dec A1 B2 IAB); induction (col_dec A2 B1 IAB);

  try solve [right; right; Col];

  exfalso; apply HIAB; intuition.

  }



  {

  destruct HIAC as [IAC HIAC]; exists IAC.

  clear HD1 HD2 HD3 HC1 HC2 HNC1 HNC2 HNC3 HIAB HNI1 HNI2 P B1 B2.

  induction (col_dec A1 A2 IAC); induction (col_dec C1 C2 IAC);

  try solve [left; Col];

  induction (col_dec A1 C1 IAC); induction (col_dec A2 C2 IAC);

  try solve [right; left; Col];

  induction (col_dec A1 C2 IAC); induction (col_dec A2 C1 IAC);

  try solve [right; right; Col];

  exfalso; apply HIAC; intuition.

  }

Qed.



Lemma playfair_ter__playfair :

  playfair_ter -> playfair_s_postulate.

Proof.

intros HP A1 A2 B1 B2 C1 C2 P HPar1 HP1 HPar2 HP2.

elim (col_dec A1 B1 B2); intro HNC1.



  {

  assert (HA : A1 <> A2) by (assert_diffs; auto).

  assert (HB : B1 <> B2) by (assert_diffs; auto).

  assert (HC : C1 <> C2) by (assert_diffs; auto).

  apply (not_strict_par _ _ _ _ A1) in HPar1; Col.

  destruct HPar1 as [HC1 HC2]; clear HNC1.

  apply (not_strict_par _ _ _ _ P) in HPar2; spliter; try split; ColR.

  }



  {

  elim (col_dec A1 C1 C2); intro HNC2.



    {

    assert (HA : A1 <> A2) by (assert_diffs; auto).

    assert (HB : B1 <> B2) by (assert_diffs; auto).

    assert (HC : C1 <> C2) by (assert_diffs; auto).

    apply (not_strict_par _ _ _ _ A1) in HPar2; Col.

    destruct HPar2 as [HC1 HC2]; clear HNC2.

    apply (not_strict_par _ _ _ _ P) in HPar1; spliter; try split; ColR.

    }



    {

    assert (H : ~ ~ (Col C1 B1 B2 /\ Col C2 B1 B2) ->

                Col C1 B1 B2 /\ Col C2 B1 B2);

    [induction (col_dec C1 B1 B2); induction (col_dec C2 B1 B2); intuition|

     apply H; clear H; intro HNC3; apply (HP A1 A2 B1 B2 C1 C2 P);

     try solve [assert_diffs; Col]; try (intros [HC1 HC2]; intuition)].



      {

      apply par_symmetry in HPar1.

      apply (par_not_col_strict _ _ _ _ A1) in HPar1; Col.

      destruct HPar1 as [_ [_ [[IAB HIAB] _]]].

      exists IAB; intros [HIAB1 [HIAB2 HIAB3]].

      elim HIAB; clear HIAB; intro HIAB; [apply HIAB1|];

      try solve [spliter; split; Col].

      elim HIAB; clear HIAB; intro HIAB; [apply HIAB2|apply HIAB3];

      spliter; split; Col.

      }



      {

      apply par_symmetry in HPar2.

      apply (par_not_col_strict _ _ _ _ A1) in HPar2; Col.

      destruct HPar2 as [_ [_ [[IAC HIAC] _]]].

      exists IAC; intros [HIAC1 [HIAC2 HIAC3]].

      elim HIAC; clear HIAC; intro HIAC; [apply HIAC1|];

      try solve [spliter; split; Col].

      elim HIAC; clear HIAC; intro HIAC; [apply HIAC2|apply HIAC3];

      spliter; split; Col.

      }



      {

      apply par_symmetry in HPar1; apply par_symmetry in HPar2.

      apply (par_not_col_strict _ _ _ _ A1) in HPar1; Col.

      apply (par_not_col_strict _ _ _ _ A1) in HPar2; Col.

      destruct HPar1 as [_ [_ [_ HI1]]]; destruct HPar2 as [_ [_ [_ HI2]]].

      split; intros [I [HC1 HC2]]; [apply HI1| apply HI2]; exists I; Col.

      }

    }

  }

Qed.



Lemma not_ex_forall_not_7 :

  forall (T : Type) (P : T -> T -> T -> T -> T -> T -> T -> Prop),

  ~(exists x1 : T, exists x2 : T, exists x3 : T,

    exists x4 : T, exists x5 : T, exists x6 : T,

    exists x7 :T, P x1 x2 x3 x4 x5 x6 x7) <->

  forall x1 : T, forall x2 : T, forall x3 : T,

  forall x4 : T, forall x5 : T, forall x6 : T,

  forall x7 : T, ~ P x1 x2 x3 x4 x5 x6 x7.

Proof.

intros; split; intro H1; intros; intro H2;

[apply H1; exists x1, x2, x3, x4, x5, x6, x7; auto|].

destruct H2 as [x1 [x2 [x3 [x4 [x5 [x6 [x7 H2]]]]]]].

apply (H1 x1 x2 x3 x4 x5 x6 x7); auto.

Qed.



Lemma playfair_quater__playfair :

  playfair_quater -> playfair_s_postulate.

Proof.

intros HP A1 A2 B1 B2 C1 C2 P HPar1 HP1 HPar2 HP2.

assert (H : playfair_quater <->

              forall A1 A2 B1 B2 C1 C2 P,

                ~ playfair_quater_qf A1 A2 B1 B2 C1 C2 P)

  by (apply not_ex_forall_not_7). rewrite H in HP; clear H.

assert (H : Col C1 B1 B2 /\ Col C2 B1 B2 <-> ~ ~ (Col C1 B1 B2 /\ Col C2 B1 B2))

  by (induction (col_dec C1 B1 B2); induction (col_dec C2 B1 B2); tauto).

apply H; clear H; intro HNC; apply (HP A1 A2 B1 B2 C1 C2 P).

repeat try (split; [assert_diffs; assumption|]).

assert (HNC1 : ~ Col A1 B1 B2).

  {

  intro.

  assert (HA : A1 <> A2) by (assert_diffs; auto).

  assert (HB : B1 <> B2) by (assert_diffs; auto).

  assert (HC : C1 <> C2) by (assert_diffs; auto).

  apply (not_strict_par _ _ _ _ A1) in HPar1; Col; spliter.

  apply (not_strict_par _ _ _ _ P) in HPar2; spliter; try ColR.

  apply HNC; split; ColR.

  }

assert (HNC2 : ~ Col A2 B1 B2).

  {

  intro.

  assert (HA : A1 <> A2) by (assert_diffs; auto).

  assert (HB : B1 <> B2) by (assert_diffs; auto).

  assert (HC : C1 <> C2) by (assert_diffs; auto).

  apply (not_strict_par _ _ _ _ A2) in HPar1; Col; spliter.

  apply (not_strict_par _ _ _ _ P) in HPar2; spliter; try ColR.

  apply HNC; split; ColR.

  }

assert (HNC3 : ~ Col A1 C1 C2).

  {

  intro.

  assert (HA : A1 <> A2) by (assert_diffs; auto).

  assert (HB : B1 <> B2) by (assert_diffs; auto).

  assert (HC : C1 <> C2) by (assert_diffs; auto).

  apply (not_strict_par _ _ _ _ A1) in HPar2; Col; spliter.

  apply (not_strict_par _ _ _ _ P) in HPar1; spliter; try ColR.

  apply HNC; split; ColR.

  }

assert (HNC4 : ~ Col A2 C1 C2).

  {

  intro.

  assert (HA : A1 <> A2) by (assert_diffs; auto).

  assert (HB : B1 <> B2) by (assert_diffs; auto).

  assert (HC : C1 <> C2) by (assert_diffs; auto).

  apply (not_strict_par _ _ _ _ A2) in HPar2; Col; spliter.

  apply (not_strict_par _ _ _ _ P) in HPar1; spliter; try ColR.

  apply HNC; split; ColR.

  }

apply par_symmetry in HPar1; apply (par_not_col_strict _ _ _ _ A1) in HPar1;

Col; apply par_strict_symmetry in HPar1; destruct HPar1 as [_ [_ [HCop1 HPar1]]].

apply par_symmetry in HPar2; apply (par_not_col_strict _ _ _ _ A1) in HPar2;

Col; apply par_strict_symmetry in HPar2; destruct HPar2 as [_ [_ [HCop2 HPar2]]].

repeat (split; try tauto).



  {

  destruct HCop1 as [IAB HIAB].

  exists IAB; intros [HIAB1 [HIAB2 HIAB3]].

  elim HIAB; clear HIAB; intro HIAB; [apply HIAB1|];

  try solve [spliter; split; Col].

  elim HIAB; clear HIAB; intro HIAB; [apply HIAB2|apply HIAB3];

  spliter; split; Col.

  }



  {

  destruct HCop2 as [IAC HIAC].

  exists IAC; intros [HIAC1 [HIAC2 HIAC3]].

  elim HIAC; clear HIAC; intro HIAC; [apply HIAC1|];

  try solve [spliter; split; Col].

  elim HIAC; clear HIAC; intro HIAC; [apply HIAC2|apply HIAC3];

  spliter; split; Col.

  }

Qed.



End par_trans_NID.
