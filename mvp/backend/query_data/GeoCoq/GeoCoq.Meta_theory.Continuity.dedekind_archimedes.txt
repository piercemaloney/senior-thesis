Require Import GeoCoq.Axioms.continuity_axioms.
(* GeoCoq.Axioms.continuity_axioms:
Require Import GeoCoq.Tarski_dev.Definitions.

Section Continuity_Defs.

Context `{Tn:Tarski_neutral_dimensionless}.

Definition segment_circle := forall A B P Q,
  InCircle P A B ->
  OutCircle Q A B ->
  exists Z, Bet P Z Q /\ OnCircle Z A B.

Definition one_point_line_circle := forall A B U V P,
  Col U V P -> U <> V -> Bet A P B ->
  exists Z, Col U V Z /\ OnCircle Z A B.

Definition two_points_line_circle := forall A B U V P,
  Col U V P -> U <> V -> Bet A P B ->
  exists Z1 Z2, Col U V Z1 /\ OnCircle Z1 A B /\
                Col U V Z2 /\ OnCircle Z2 A B /\
                Bet Z1 P Z2 /\ (P <> B -> Z1 <> Z2).

Definition circle_circle := forall A B C D P Q,
  OnCircle P C D ->
  OnCircle Q C D ->
  InCircle P A B ->
  OutCircle Q A B ->
  exists Z, OnCircle Z A B /\ OnCircle Z C D.

Definition circle_circle_bis := forall A B C D P Q,
  OnCircle P C D ->
  InCircle P A B ->
  OnCircle Q A B ->
  InCircle Q C D ->
  exists Z, OnCircle Z A B /\ OnCircle Z C D.

Definition circle_circle_axiom := forall A B C D B' D',
  Cong A B' A B -> Cong C D' C D ->
  Bet A D' B -> Bet C B' D ->
  exists Z, Cong A Z A B /\ Cong C Z C D.

Definition circle_circle_two := forall A B C D P Q,
  OnCircle P C D ->
  OnCircle Q C D ->
  InCircle P A B ->
  OutCircle Q A B ->
  exists Z1 Z2,
    OnCircle Z1 A B /\ OnCircle Z1 C D /\
    OnCircle Z2 A B /\ OnCircle Z2 C D /\
    (InCircleS P A B -> OutCircleS Q A B -> Z1<>Z2).

Definition euclid_s_prop_1_22 := forall A B C D E F A' B' C' D' E' F',
  SumS A B C D E' F' -> SumS A B E F C' D' -> SumS C D E F A' B' ->
  Le E F E' F' -> Le C D C' D' -> Le A B A' B' ->
  exists P Q R, Cong P Q A B /\ Cong P R C D /\ Cong Q R E F.

Definition Nested (A B:nat -> Tpoint -> Prop) :=
  (forall n, exists An, A n An) /\ (forall n, exists Bn, B n Bn) /\
  forall n An Am Bm Bn,
    A n An -> A (S n) Am -> B (S n) Bm -> B n Bn -> Bet An Am Bm /\ Bet Am Bm Bn /\ Am <> Bm.

Definition cantor_s_axiom := forall A B, Nested A B ->
  exists X, forall n An Bn, A n An -> B n Bn -> Bet An X Bn.

Definition dedekind_s_axiom := forall (Alpha Beta : Tpoint -> Prop),
  (exists A, forall X Y, Alpha X -> Beta Y -> Bet A X Y) ->
  (exists B, forall X Y, Alpha X -> Beta Y -> Bet X B Y).

Inductive FOF : Prop -> Prop :=
| eq_fof : forall A B:Tpoint, FOF (A = B)
| bet_fof : forall A B C, FOF (Bet A B C)
| cong_fof : forall A B C D, FOF (Cong A B C D)
| not_fof : forall P, FOF P -> FOF (~ P)
| and_fof : forall P Q, FOF P -> FOF Q -> FOF (P /\ Q)
| or_fof : forall P Q, FOF P -> FOF Q -> FOF (P \/ Q)
| implies_fof : forall P Q, FOF P -> FOF Q -> FOF (P -> Q)
| forall_fof : forall P, (forall (A:Tpoint), FOF (P A)) -> FOF (forall A, P A)
| exists_fof : forall P, (forall (A:Tpoint), FOF (P A)) -> FOF (exists A, P A).

Definition first_order_dedekind := forall Alpha Beta,
  (forall X, FOF (Alpha X)) -> (forall Y, FOF (Beta Y)) ->
  (exists A, forall X Y, Alpha X -> Beta Y -> Bet A X Y) ->
  (exists B, forall X Y, Alpha X -> Beta Y -> Bet X B Y).

Definition archimedes_axiom := forall A B C D, A <> B -> Reach A B C D.

Definition aristotle_s_axiom := forall P Q A B C,
  ~ Col A B C -> Acute A B C ->
  exists X Y, Out B A X /\ Out B C Y /\ Per B X Y /\ Lt P Q X Y.

Definition greenberg_s_axiom := forall P Q R A B C,
  ~ Col A B C ->
  Acute A B C -> Q <> R -> Per P Q R ->
  exists S, LtA P S Q A B C /\ Out Q S R.

End Continuity_Defs.

Section Completeness.

Context `{Tn:Tarski_neutral_dimensionless}.

Definition inj {T1 T2:Type} (f:T1->T2) := forall A B, f A = f B -> A = B.

Definition pres_bet {Tm: Tarski_neutral_dimensionless}
  (f : @Tpoint Tn -> @Tpoint Tm) := forall A B C, Bet A B C -> Bet (f A) (f B) (f C).

Definition pres_cong {Tm: Tarski_neutral_dimensionless}
  (f : @Tpoint Tn -> @Tpoint Tm) := forall A B C D, Cong A B C D -> Cong (f A) (f B) (f C) (f D).

Definition extension {Tm: Tarski_neutral_dimensionless} f := inj f /\ pres_bet f /\ pres_cong f.

Definition completeness_for_planes := forall (Tm: Tarski_neutral_dimensionless)
  (Tm2 : Tarski_neutral_dimensionless_with_decidable_point_equality Tm)
  (M : Tarski_2D Tm2)
  (f : @Tpoint Tn -> @Tpoint Tm),
  @archimedes_axiom Tm ->
  extension f ->
  forall A, exists B, f B = A.

Definition completeness_for_3d_spaces := forall (Tm: Tarski_neutral_dimensionless)
  (Tm2 : Tarski_neutral_dimensionless_with_decidable_point_equality Tm)
  (M : Tarski_3D Tm2)
  (f : @Tpoint Tn -> @Tpoint Tm),
  @archimedes_axiom Tm ->
  extension f ->
  forall A, exists B, f B = A.

Definition inj_line {T:Type} (f:Tpoint->T) P Q := forall A B, Col P Q A -> Col P Q B ->
  f A = f B -> A = B.

Definition pres_bet_line {Tm: Tarski_neutral_dimensionless}
  (f : @Tpoint Tn -> @Tpoint Tm) P Q := forall A B C, Col P Q A -> Col P Q B -> Col P Q C ->
  Bet A B C -> Bet (f A) (f B) (f C).

Definition pres_cong_line {Tm: Tarski_neutral_dimensionless}
  (f : @Tpoint Tn -> @Tpoint Tm) P Q := forall A B C D,
  Col P Q A -> Col P Q B -> Col P Q C -> Col P Q D ->
  Cong A B C D -> Cong (f A) (f B) (f C) (f D).

Definition line_extension {Tm: Tarski_neutral_dimensionless} f P Q :=
  P <> Q /\ inj_line f P Q /\ pres_bet_line f P Q /\ pres_cong_line f P Q.

Definition line_completeness := forall (Tm: Tarski_neutral_dimensionless)
  (Tm2 : Tarski_neutral_dimensionless_with_decidable_point_equality Tm)
  P Q
  (f : @Tpoint Tn -> @Tpoint Tm),
  @archimedes_axiom Tm ->
  line_extension f P Q ->
  forall A, Col (f P) (f Q) A -> exists B, Col P Q B /\ f B = A.

End Completeness. *)

Require Import GeoCoq.Tarski_dev.Ch07_midpoint.
(* GeoCoq.Tarski_dev.Ch07_midpoint:
Require Export GeoCoq.Tarski_dev.Ch06_out_lines.
Require Export GeoCoq.Tarski_dev.Tactics.ColR.

Ltac not_exist_hyp_comm A B := not_exist_hyp (A<>B);not_exist_hyp (B<>A).

Ltac not_exist_hyp2 A B C D := first [not_exist_hyp_comm A B | not_exist_hyp_comm C D].
Ltac not_exist_hyp3 A B C D E F := first [not_exist_hyp_comm A B | not_exist_hyp_comm C D | not_exist_hyp_comm E F].

Ltac assert_diffs :=
repeat
 match goal with
      | H:(~Col ?X1 ?X2 ?X3) |- _ =>
      let h := fresh in
      not_exist_hyp3 X1 X2 X1 X3 X2 X3;
      assert (h := not_col_distincts X1 X2 X3 H);decompose [and] h;clear h;clean_reap_hyps

      | H:(~Bet ?X1 ?X2 ?X3) |- _ =>
      let h := fresh in
      not_exist_hyp2 X1 X2 X2 X3;
      assert (h := not_bet_distincts X1 X2 X3 H);decompose [and] h;clear h;clean_reap_hyps
      | H:Bet ?A ?B ?C, H2 : ?A <> ?B |-_ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= bet_neq12__neq A B C H H2);clean_reap_hyps
      | H:Bet ?A ?B ?C, H2 : ?B <> ?A |-_ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= bet_neq21__neq A B C H H2);clean_reap_hyps
      | H:Bet ?A ?B ?C, H2 : ?B <> ?C |-_ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= bet_neq23__neq A B C H H2);clean_reap_hyps
      | H:Bet ?A ?B ?C, H2 : ?C <> ?B |-_ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= bet_neq32__neq A B C H H2);clean_reap_hyps

      | H:Cong ?A ?B ?C ?D, H2 : ?A <> ?B |-_ =>
      let T:= fresh in (not_exist_hyp_comm C D);
        assert (T:= cong_diff A B C D H2 H);clean_reap_hyps
      | H:Cong ?A ?B ?C ?D, H2 : ?B <> ?A |-_ =>
      let T:= fresh in (not_exist_hyp_comm C D);
        assert (T:= cong_diff_2 A B C D H2 H);clean_reap_hyps
      | H:Cong ?A ?B ?C ?D, H2 : ?C <> ?D |-_ =>
      let T:= fresh in (not_exist_hyp_comm A B);
        assert (T:= cong_diff_3 A B C D H2 H);clean_reap_hyps
      | H:Cong ?A ?B ?C ?D, H2 : ?D <> ?C |-_ =>
      let T:= fresh in (not_exist_hyp_comm A B);
        assert (T:= cong_diff_4 A B C D H2 H);clean_reap_hyps

      | H:Le ?A ?B ?C ?D, H2 : ?A <> ?B |-_ =>
      let T:= fresh in (not_exist_hyp_comm C D);
        assert (T:= le_diff A B C D H2 H);clean_reap_hyps
      | H:Lt ?A ?B ?C ?D |-_ =>
      let T:= fresh in (not_exist_hyp_comm C D);
        assert (T:= lt_diff A B C D H);clean_reap_hyps

      | H:Out ?A ?B ?C |- _ =>
      let T:= fresh in (not_exist_hyp2 A B A C);
       assert (T:= out_distinct A B C H);
       decompose [and] T;clear T;clean_reap_hyps
 end.

Ltac ColR :=
 let tpoint := constr:(Tpoint) in
 let col := constr:(Col) in
   treat_equalities; assert_cols; assert_diffs; try (solve [Col]); Col_refl tpoint col.

Section T7_1.

Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.

Lemma midpoint_dec :
 forall I A B, Midpoint I A B \/ ~ Midpoint I A B.

Lemma is_midpoint_id : forall A B, Midpoint A A B -> A = B.

Lemma is_midpoint_id_2 : forall A B, Midpoint A B A -> A=B.

Lemma l7_2 : forall M A B, Midpoint M A B -> Midpoint M B A.

Lemma l7_3 : forall M A, Midpoint M A A -> M=A.

Lemma l7_3_2 : forall A, Midpoint A A A.

Lemma symmetric_point_construction : forall P A, exists P', Midpoint A P P'.

Lemma symmetric_point_uniqueness : forall A P P1 P2, Midpoint P A P1 -> Midpoint P A P2 -> P1=P2.

Lemma l7_9 : forall P Q A X, Midpoint A P X -> Midpoint A Q X -> P=Q.

Lemma l7_9_bis : forall P Q A X, Midpoint A P X -> Midpoint A X Q -> P=Q.

Lemma l7_13 : forall A P Q P' Q',  Midpoint A P' P -> Midpoint A Q' Q -> Cong P Q P' Q'.

Lemma l7_15 : forall P Q R P' Q' R' A,
 Midpoint A P P' -> Midpoint A Q Q' -> Midpoint A R R' -> Bet P Q R -> Bet P' Q' R'.

Lemma l7_16 : forall P Q R S P' Q' R' S' A,
  Midpoint A P P' -> Midpoint A Q Q' ->
  Midpoint A R R' -> Midpoint A S S' ->
  Cong P Q R S -> Cong P' Q' R' S'.

Lemma symmetry_preserves_midpoint :
   forall A B C D E F Z,
 Midpoint Z A D -> Midpoint Z B E ->
 Midpoint Z C F -> Midpoint B A C -> Midpoint E D F.

End T7_1.

Hint Resolve l7_13 : cong.
Hint Resolve l7_2 l7_3_2 : midpoint.

Ltac Midpoint := auto with midpoint.

Section T7_2.

Context {Tn:Tarski_neutral_dimensionless}.
Context {TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality Tn}.

Lemma Mid_cases :
  forall A B C,
  Midpoint A B C \/ Midpoint A C B ->
  Midpoint A B C.

Lemma Mid_perm :
  forall A B C,
  Midpoint A B C ->
  Midpoint A B C /\ Midpoint A C B.

Lemma l7_17 : forall P P' A B, Midpoint A P P' -> Midpoint B P P' -> A=B.

Lemma l7_17_bis : forall P P' A B, Midpoint A P P' -> Midpoint B P' P -> A=B.

Lemma l7_20 : forall M A B,
  Col A M B -> Cong M A M B -> A=B \/ Midpoint M A B.

Lemma l7_20_bis : forall M A B, A<>B ->
  Col A M B -> Cong M A M B -> Midpoint M A B.

Lemma cong_col_mid : forall A B C,
 A <> C -> Col A B C -> Cong A B B C ->
 Midpoint B A C.

Lemma l7_21 : forall A B C D P,
  ~ Col A B C -> B<>D ->
  Cong A B C D -> Cong B C D A ->
  Col A P C -> Col B P D ->
  Midpoint P A C /\ Midpoint P B D.

Lemma l7_22_aux : forall A1 A2 B1 B2 C M1 M2,
   Bet A1 C A2 -> Bet B1 C B2 ->
   Cong C A1 C B1 -> Cong C A2 C B2 ->
   Midpoint M1 A1 B1 -> Midpoint M2 A2 B2 ->
   Le C A1 C A2 ->
   Bet M1 C M2.

Lemma l7_22 : forall A1 A2 B1 B2 C M1 M2,
   Bet A1 C A2 -> Bet B1 C B2 ->
   Cong C A1 C B1 -> Cong C A2 C B2 ->
   Midpoint M1 A1 B1 -> Midpoint M2 A2 B2 ->
   Bet M1 C M2.

Lemma bet_col1 : forall A B C D, Bet A B D -> Bet A C D -> Col A B C.

Lemma l7_25 : forall A B C,
  Cong C A C B ->
  exists X, Midpoint X A B.

Lemma midpoint_distinct_1 : forall I A B,
 A<>B ->
 Midpoint I A B ->
 I<>A /\ I<>B.

Lemma midpoint_distinct_2 : forall I A B,
 I<>A ->
 Midpoint I A B ->
 A<>B /\ I<>B.

Lemma midpoint_distinct_3 : forall I A B,
 I<>B ->
 Midpoint I A B ->
 A<>B /\ I<>A.

Lemma midpoint_def : forall A B C, Bet A B C -> Cong A B B C -> Midpoint B A C.

Lemma midpoint_bet : forall A B C, Midpoint B A C -> Bet A B C.

Lemma midpoint_col : forall A M B, Midpoint M A B -> Col M A B.

Lemma midpoint_cong : forall A B C, Midpoint B A C -> Cong A B B C.

Lemma midpoint_not_midpoint : forall I A B,
  A<>B ->
  Midpoint I A B ->
~ Midpoint B A I.

Lemma swap_diff : forall (A B : Tpoint), A<>B -> B<>A.

Lemma cong_cong_half_1 : forall A M B A' M' B',
 Midpoint M A B -> Midpoint M' A' B' ->
 Cong A B A' B' -> Cong A M A' M'.

Lemma cong_cong_half_2 : forall A M B A' M' B',
 Midpoint M A B -> Midpoint M' A' B' ->
 Cong A B A' B' -> Cong B M B' M'.

Lemma cong_mid2__cong : forall A M B A' M' B',
 Midpoint M A B -> Midpoint M' A' B' ->
 Cong A M A' M' -> Cong A B A' B'.

Lemma mid__lt : forall A M B,
 A <> B -> Midpoint M A B ->
 Lt A M A B.

Lemma le_mid2__le13 : forall A M B A' M' B',
 Midpoint M A B -> Midpoint M' A' B' ->
 Le A M A' M' -> Le A B A' B'.

Lemma le_mid2__le12 : forall A M B A' M' B',
 Midpoint M A B -> Midpoint M' A' B' ->
 Le A B A' B' -> Le A M A' M'.

Lemma lt_mid2__lt13 : forall A M B A' M' B',
 Midpoint M A B -> Midpoint M' A' B' ->
 Lt A M A' M' -> Lt A B A' B'.

Lemma lt_mid2__lt12 : forall A M B A' M' B',
 Midpoint M A B -> Midpoint M' A' B' ->
 Lt A B A' B' -> Lt A M A' M'.

Lemma midpoint_preserves_out :
 forall A B C A' B' C' M,
  Out A B C ->
  Midpoint M A A' ->
  Midpoint M B B' ->
  Midpoint M C C' ->
 Out A' B' C'.

Lemma col_cong_bet : forall A B C D, Col A B D -> Cong A B C D -> Bet A C B -> Bet  C A D \/ Bet C B D.

Lemma col_cong2_bet1 : forall A B C D, Col A B D -> Bet A C B -> Cong A B C D -> Cong A C B D -> Bet C B D.

Lemma col_cong2_bet2 : forall A B C D, Col A B D -> Bet A C B -> Cong A B C D -> Cong A D B C -> Bet C A D.

Lemma col_cong2_bet3 : forall A B C D, Col A B D -> Bet A B C -> Cong A B C D -> Cong A C B D -> Bet B C D.

Lemma col_cong2_bet4 : forall A B C D, Col A B C -> Bet A B D -> Cong A B C D -> Cong A D B C -> Bet B D C.

Lemma col_bet2_cong1 : forall A B C D, Col A B D -> Bet A C B -> Cong A B C D -> Bet C B D -> Cong A C D B.

Lemma col_bet2_cong2 : forall A B C D, Col A B D -> Bet A C B -> Cong A B C D -> Bet C A D -> Cong D A B C.

Lemma bet2_lt2__lt : forall O o A B a b : Tpoint,
       Bet a o b -> Bet A O B -> Lt o a O A -> Lt o b O B -> Lt a b A B.

Lemma bet2_lt_le__lt : forall O o A B a b : Tpoint,
       Bet a o b -> Bet A O B -> Cong o a O A -> Lt o b O B -> Lt a b A B.

End T7_2.

Hint Resolve midpoint_bet : between.
Hint Resolve midpoint_col : col.
Hint Resolve midpoint_cong : cong. *)



Section Dedekind_archimedes.



Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.



Lemma archimedes_aux : (forall A B C, Out A B C -> Reach A B A C) -> archimedes_axiom.

Proof.

  intros Haux A B C D HAB.

  destruct (eq_dec_points C D).

    subst; exists B.

    split; Le.

    apply grad_init.

  destruct (segment_construction_3 A B C D) as [E [HOut HCong]]; auto.

  destruct (Haux A B E HOut) as [B' [HGrad HLe]]; trivial.

  exists B'.

  split; trivial.

  apply le_transitivity with A E; Le.

Qed.



Lemma dedekind__archimedes : (forall A B C D, ~ ~ Reach A B C D -> Reach A B C D) ->

  dedekind_s_axiom -> archimedes_axiom.

Proof.

  intros Hstab dedekind.

  apply archimedes_aux.

  intros A B C HOut.

  apply Hstab.

  intro HNReach.

  assert (HX : exists X, forall P Q, (Out A B P /\ ~ ~ Reach A B A P) ->

                                       (Out A B Q /\ ~ Reach A B A Q) -> Bet P X Q).

  { apply dedekind.

    exists A.

    intros X Y [HXOut HX] [HYOut HY].

    assert (HOut' : Out A X Y) by (apply l6_7 with B; [apply l6_6|]; trivial).

    destruct (HOut') as [_ [_ [|Habs]]]; trivial.

    exfalso.

    apply HX; clear HX.

    intro HX.

    apply HY.

    destruct HX as [B' [HGrad HLe]].

    exists B'; split; trivial.

    apply le_transitivity with A X; Le.

  }

  destruct HX as [X HX].

  assert_diffs.

  assert (HGrad := grad_init A B).

  assert (HBet : Bet B X C).

  { apply HX; split; trivial.

      apply out_trivial; auto.

    intro HAbs; apply HAbs.

    exists B; split; Le.

  }

  assert (Out A B X) by (apply out_bet_out_1 with C; auto).

  destruct HOut as [_ [_ [HBet2|HBet2]]]; [|exfalso; apply HNReach; exists B; split; Le].

  absurd (~ Reach A B A X).



  - intro HAbs.

    destruct (eq_dec_points X B).

      subst; apply HAbs; exists B; split; Le.

    destruct (le_cases X A A B) as [HLe|HLe].

      apply HAbs; exists B; split; Le.

    assert (Bet A B X) by (apply l6_13_1; Le).

    destruct HLe as [X0 [HBet1 HCong]].

    absurd (~ Reach A B A X0).

    { intro HNReach0.

      assert (HXOut : Out X X0 B).

        apply l6_7 with A; [|apply l6_6]; apply bet_out; Between.

        intro; treat_equalities; auto.

      destruct (le_cases X B X X0) as [HLe|HLe].

      - apply HNReach0; exists B; split; trivial.

        exists X0; split; Cong.

        apply between_inner_transitivity with X; Between.

        apply between_symmetry, l6_13_1; trivial.

        apply l6_6; trivial.

      - absurd (X = X0).

          assert_diffs; auto.

        apply between_equality with B.

          apply l6_13_1; trivial.

        apply between_symmetry, HX; split; trivial.

          apply out_trivial; auto.

          intro HN; apply HN; exists B; split; Le.

        apply l6_7 with X; trivial.

        apply l6_6, bet_out; Between.

        intro; subst X0; apply HNReach0.

        exists B; split; Le.

    }

    intro HReach.

    destruct HReach as [B' [HGrad' HLe]].

    destruct (segment_construction A B' A B) as [B1' [HBet' HCong']].

    apply HAbs; exists B1'; split.

      apply grad_stab with B'; Cong.

    apply bet2_le2__le1346 with X0 B'; Le; Between.

    apply cong__le, cong_transitivity with A B; Cong.



  - intro HReach.

    destruct (segment_construction_3 X C A B) as [X1 [HOut' HCong]]; auto.

      intro; subst; contradiction.

    assert (HBet1 : Bet A X X1).

      apply between_symmetry, bet_out__bet with C; eBetween.

    apply (not_bet_and_out X1 X C).

    split; [|apply l6_6; trivial].

    apply HX; split; trivial; [| |apply bet_out; auto].

    { apply l6_7 with X; trivial.

      assert_diffs; apply bet_out; auto.

    }

    destruct HReach as [B' [HGrad' HLe]].

    destruct (segment_construction A B' A B) as [B1' [HBet' HCong']].

    intro HAbs; apply HAbs.

    exists B1'; split.

      apply grad_stab with B'; Cong.

    apply bet2_le2__le1346 with X B'; Le.

    apply cong__le, cong_transitivity with A B; Cong.

Qed.



End Dedekind_archimedes.
