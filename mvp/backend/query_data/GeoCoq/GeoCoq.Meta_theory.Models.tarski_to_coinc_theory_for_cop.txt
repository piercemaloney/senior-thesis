Require Import GeoCoq.Tarski_dev.Ch09_plane.
(* GeoCoq.Tarski_dev.Ch09_plane:
Require Export GeoCoq.Tarski_dev.Ch08_orthogonality.
Require Export GeoCoq.Tarski_dev.Annexes.coplanar.

Ltac clean_reap_hyps :=
  clean_duplicated_hyps;
  repeat
  match goal with
   | H:(Midpoint ?A ?B ?C), H2 : Midpoint ?A ?C ?B |- _ => clear H2
   | H:(Col ?A ?B ?C), H2 : Col ?A ?C ?B |- _ => clear H2
   | H:(Col ?A ?B ?C), H2 : Col ?B ?A ?C |- _ => clear H2
   | H:(Col ?A ?B ?C), H2 : Col ?B ?C ?A |- _ => clear H2
   | H:(Col ?A ?B ?C), H2 : Col ?C ?B ?A |- _ => clear H2
   | H:(Col ?A ?B ?C), H2 : Col ?C ?A ?B |- _ => clear H2
   | H:(Bet ?A ?B ?C), H2 : Bet ?C ?B ?A |- _ => clear H2
   | H:(Cong ?A ?B ?C ?D), H2 : Cong ?A ?B ?D ?C |- _ => clear H2
   | H:(Cong ?A ?B ?C ?D), H2 : Cong ?C ?D ?A ?B |- _ => clear H2
   | H:(Cong ?A ?B ?C ?D), H2 : Cong ?C ?D ?B ?A |- _ => clear H2
   | H:(Cong ?A ?B ?C ?D), H2 : Cong ?D ?C ?B ?A |- _ => clear H2
   | H:(Cong ?A ?B ?C ?D), H2 : Cong ?D ?C ?A ?B |- _ => clear H2
   | H:(Cong ?A ?B ?C ?D), H2 : Cong ?B ?A ?C ?D |- _ => clear H2
   | H:(Cong ?A ?B ?C ?D), H2 : Cong ?B ?A ?D ?C |- _ => clear H2
   | H:(Perp ?A ?B ?C ?D), H2 : Perp ?A ?B ?D ?C |- _ => clear H2
   | H:(Perp ?A ?B ?C ?D), H2 : Perp ?C ?D ?A ?B |- _ => clear H2
   | H:(Perp ?A ?B ?C ?D), H2 : Perp ?C ?D ?B ?A |- _ => clear H2
   | H:(Perp ?A ?B ?C ?D), H2 : Perp ?D ?C ?B ?A |- _ => clear H2
   | H:(Perp ?A ?B ?C ?D), H2 : Perp ?D ?C ?A ?B |- _ => clear H2
   | H:(Perp ?A ?B ?C ?D), H2 : Perp ?B ?A ?C ?D |- _ => clear H2
   | H:(Perp ?A ?B ?C ?D), H2 : Perp ?B ?A ?D ?C |- _ => clear H2
   | H:(?A<>?B), H2 : (?B<>?A) |- _ => clear H2
   | H:(Per ?A ?D ?C), H2 : (Per ?C ?D ?A) |- _ => clear H2
   | H:(Perp_at ?X ?A ?B ?C ?D), H2 : Perp_at ?X ?A ?B ?D ?C |- _ => clear H2
   | H:(Perp_at ?X ?A ?B ?C ?D), H2 : Perp_at ?X ?C ?D ?A ?B |- _ => clear H2
   | H:(Perp_at ?X ?A ?B ?C ?D), H2 : Perp_at ?X ?C ?D ?B ?A |- _ => clear H2
   | H:(Perp_at ?X ?A ?B ?C ?D), H2 : Perp_at ?X ?D ?C ?B ?A |- _ => clear H2
   | H:(Perp_at ?X ?A ?B ?C ?D), H2 : Perp_at ?X ?D ?C ?A ?B |- _ => clear H2
   | H:(Perp_at ?X ?A ?B ?C ?D), H2 : Perp_at ?X ?B ?A ?C ?D |- _ => clear H2
   | H:(Perp_at ?X ?A ?B ?C ?D), H2 : Perp_at ?X ?B ?A ?D ?C |- _ => clear H2
end.

Ltac assert_diffs :=
repeat
 match goal with
      | H:(~Col ?X1 ?X2 ?X3) |- _ =>
      let h := fresh in
      not_exist_hyp3 X1 X2 X1 X3 X2 X3;
      assert (h := not_col_distincts X1 X2 X3 H);decompose [and] h;clear h;clean_reap_hyps

      | H:(~Bet ?X1 ?X2 ?X3) |- _ =>
      let h := fresh in
      not_exist_hyp2 X1 X2 X2 X3;
      assert (h := not_bet_distincts X1 X2 X3 H);decompose [and] h;clear h;clean_reap_hyps
      | H:Bet ?A ?B ?C, H2 : ?A <> ?B |-_ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= bet_neq12__neq A B C H H2);clean_reap_hyps
      | H:Bet ?A ?B ?C, H2 : ?B <> ?A |-_ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= bet_neq21__neq A B C H H2);clean_reap_hyps
      | H:Bet ?A ?B ?C, H2 : ?B <> ?C |-_ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= bet_neq23__neq A B C H H2);clean_reap_hyps
      | H:Bet ?A ?B ?C, H2 : ?C <> ?B |-_ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= bet_neq32__neq A B C H H2);clean_reap_hyps

      | H:Cong ?A ?B ?C ?D, H2 : ?A <> ?B |-_ =>
      let T:= fresh in (not_exist_hyp_comm C D);
        assert (T:= cong_diff A B C D H2 H);clean_reap_hyps
      | H:Cong ?A ?B ?C ?D, H2 : ?B <> ?A |-_ =>
      let T:= fresh in (not_exist_hyp_comm C D);
        assert (T:= cong_diff_2 A B C D H2 H);clean_reap_hyps
      | H:Cong ?A ?B ?C ?D, H2 : ?C <> ?D |-_ =>
      let T:= fresh in (not_exist_hyp_comm A B);
        assert (T:= cong_diff_3 A B C D H2 H);clean_reap_hyps
      | H:Cong ?A ?B ?C ?D, H2 : ?D <> ?C |-_ =>
      let T:= fresh in (not_exist_hyp_comm A B);
        assert (T:= cong_diff_4 A B C D H2 H);clean_reap_hyps

      | H:Le ?A ?B ?C ?D, H2 : ?A <> ?B |-_ =>
      let T:= fresh in (not_exist_hyp_comm C D);
        assert (T:= le_diff A B C D H2 H);clean_reap_hyps
      | H:Le ?A ?B ?C ?D, H2 : ?B <> ?A |-_ =>
      let T:= fresh in (not_exist_hyp_comm C D);
        assert (T:= le_diff A B C D (swap_diff B A H2) H);clean_reap_hyps
      | H:Lt ?A ?B ?C ?D |-_ =>
      let T:= fresh in (not_exist_hyp_comm C D);
        assert (T:= lt_diff A B C D H);clean_reap_hyps

      | H:Midpoint ?I ?A ?B, H2 : ?A<>?B |- _ =>
      let T:= fresh in (not_exist_hyp2 I B I A);
       assert (T:= midpoint_distinct_1 I A B H2 H);
       decompose [and] T;clear T;clean_reap_hyps
      | H:Midpoint ?I ?A ?B, H2 : ?B<>?A |- _ =>
      let T:= fresh in (not_exist_hyp2 I B I A);
       assert (T:= midpoint_distinct_1 I A B (swap_diff B A H2) H);
       decompose [and] T;clear T;clean_reap_hyps

      | H:Midpoint ?I ?A ?B, H2 : ?I<>?A |- _ =>
      let T:= fresh in (not_exist_hyp2 I B A B);
       assert (T:= midpoint_distinct_2 I A B H2 H);
       decompose [and] T;clear T;clean_reap_hyps
      | H:Midpoint ?I ?A ?B, H2 : ?A<>?I |- _ =>
      let T:= fresh in (not_exist_hyp2 I B A B);
       assert (T:= midpoint_distinct_2 I A B (swap_diff A I H2) H);
       decompose [and] T;clear T;clean_reap_hyps

      | H:Midpoint ?I ?A ?B, H2 : ?I<>?B |- _ =>
      let T:= fresh in (not_exist_hyp2 I A A B);
       assert (T:= midpoint_distinct_3 I A B H2 H);
       decompose [and] T;clear T;clean_reap_hyps
      | H:Midpoint ?I ?A ?B, H2 : ?B<>?I |- _ =>
      let T:= fresh in (not_exist_hyp2 I A A B);
       assert (T:= midpoint_distinct_3 I A B (swap_diff B I H2) H);
       decompose [and] T;clear T;clean_reap_hyps

      | H:Per ?A ?B ?C, H2 : ?A<>?B |- _ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= per_distinct A B C H H2); clean_reap_hyps
      | H:Per ?A ?B ?C, H2 : ?B<>?A |- _ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= per_distinct A B C H (swap_diff B A H2)); clean_reap_hyps
      | H:Per ?A ?B ?C, H2 : ?B<>?C |- _ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= per_distinct_1 A B C H H2); clean_reap_hyps
      | H:Per ?A ?B ?C, H2 : ?C<>?B |- _ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= per_distinct_1 A B C H (swap_diff C B H2)); clean_reap_hyps

      | H:Perp ?A ?B ?C ?D |- _ =>
      let T:= fresh in (not_exist_hyp2 A B C D);
       assert (T:= perp_distinct A B C D H);
       decompose [and] T;clear T;clean_reap_hyps
      | H:Perp_at ?X ?A ?B ?C ?D |- _ =>
      let T:= fresh in (not_exist_hyp2 A B C D);
       assert (T:= perp_in_distinct X A B C D H);
       decompose [and] T;clear T;clean_reap_hyps
      | H:Out ?A ?B ?C |- _ =>
      let T:= fresh in (not_exist_hyp2 A B A C);
       assert (T:= out_distinct A B C H);
       decompose [and] T;clear T;clean_reap_hyps
 end.

Ltac clean_trivial_hyps :=
  repeat
  match goal with
   | H:(Cong ?X1 ?X1 ?X2 ?X2) |- _ => clear H
   | H:(Cong ?X1 ?X2 ?X2 ?X1) |- _ => clear H
   | H:(Cong ?X1 ?X2 ?X1 ?X2) |- _ => clear H
   | H:(Bet ?X1 ?X1 ?X2) |- _ => clear H
   | H:(Bet ?X2 ?X1 ?X1) |- _ => clear H
   | H:(Col ?X1 ?X1 ?X2) |- _ => clear H
   | H:(Col ?X2 ?X1 ?X1) |- _ => clear H
   | H:(Col ?X1 ?X2 ?X1) |- _ => clear H
   | H:(Per ?X1 ?X2 ?X2)     |- _ => clear H
   | H:(Per ?X1 ?X1 ?X2)     |- _ => clear H
   | H:(Midpoint ?X1 ?X1 ?X1) |- _ => clear H
end.

Ltac clean := clean_trivial_hyps;clean_reap_hyps.

Section T9.

Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.

Lemma ts_distincts : forall A B P Q, TS A B P Q ->
  A <> B /\ A <> P /\ A <> Q /\ B <> P /\ B <> Q /\ P <> Q.

Lemma l9_2 : forall A B P Q, TS A B P Q -> TS A B Q P.

Lemma invert_two_sides : forall A B P Q,
 TS A B P Q -> TS B A P Q.

Lemma l9_3 : forall P Q A C M R B,
 TS P Q A C -> Col M P Q ->
 Midpoint M A C -> Col R P Q ->
 Out R A B -> TS P Q B C.

Lemma mid_preserves_col : forall A B C M A' B' C',
  Col A B C ->
  Midpoint M A A' ->
  Midpoint M B B' ->
  Midpoint M C C' ->
  Col A' B' C'.

Lemma per_mid_per : forall A B X Y M,
   A <> B -> Per X A B ->
   Midpoint M A B -> Midpoint M X Y ->
   Cong A X B Y /\ Per Y B A.

Lemma sym_preserve_diff : forall A B M A' B',
 A <> B -> Midpoint M A A' -> Midpoint M B B' -> A'<> B'.

Lemma l9_4_1_aux : forall P Q A C R S M,
 Le S C R A ->
 TS P Q A C -> Col R P Q -> Perp P Q A R -> Col S P Q ->
 Perp P Q C S -> Midpoint M R S ->
 (forall U C',Midpoint M U C' -> (Out R U A <-> Out S C C')).

Lemma per_col_eq : forall A B C, Per A B C -> Col A B C -> B <> C -> A = B.

Lemma l9_4_1 : forall P Q A C R S M,
 TS P Q A C -> Col R P Q ->
 Perp P Q A R -> Col S P Q ->
 Perp P Q C S -> Midpoint M R S ->
 (forall U C',Midpoint M U C' -> (Out R U A <-> Out S C C')).

Lemma mid_two_sides : forall A B M X Y,
 Midpoint M A B -> ~ Col A B X -> Midpoint M X Y ->
 TS A B X Y.

Lemma col_preserves_two_sides : forall A B C D X Y,
 C <> D -> Col A B C -> Col A B D ->
 TS A B X Y ->
 TS C D X Y.

Lemma out_out_two_sides : forall A B X Y U V I,
  A <> B ->
  TS A B X Y ->
  Col I A B -> Col I X Y ->
  Out I X U -> Out I Y V ->
  TS A B U V.

Lemma l9_4_2_aux : forall P Q A C R S U V, Le S C R A -> TS P Q A C -> Col R P Q -> Perp P Q A R -> Col S P Q ->
Perp P Q C S -> Out R U A -> Out S V C -> TS P Q U V.

Lemma l9_4_2 : forall P Q A C R S U V,
TS P Q A C -> Col R P Q -> Perp P Q A R -> Col S P Q ->
Perp P Q C S -> Out R U A -> Out S V C -> TS P Q U V.

Lemma l9_5 : forall P Q A C R B,
 TS P Q A C -> Col R P Q -> Out R A B -> TS P Q B C.

Lemma outer_pasch : forall A B C P Q,
 Bet A C P -> Bet B Q C -> exists X, Bet A X B /\ Bet P Q X.

Lemma os_distincts : forall A B X Y, OS A B X Y ->
  A <> B /\ A <> X /\ A <> Y /\ B <> X /\ B <> Y.

Lemma invert_one_side : forall A B P Q,
 OS A B P Q -> OS B A P Q.

Lemma l9_8_1 : forall P Q A B C, TS P Q A C -> TS P Q B C -> OS P Q A B.

Lemma not_two_sides_id : forall A P Q, ~ TS P Q A A.

Lemma l9_8_2 : forall P Q A B C,
 TS P Q A C ->
 OS P Q A B ->
 TS P Q B C.

Lemma l9_9 : forall P Q A B, TS P Q A B -> ~ OS P Q A B.

Lemma l9_9_bis : forall P Q A B, OS P Q A B -> ~ TS P Q A B.

Lemma one_side_chara : forall P Q A B,
 OS P Q A B -> (forall X, Col X P Q -> ~ Bet A X B).

Lemma l9_10 : forall P Q A,
 ~ Col A P Q -> exists C, TS P Q A C.

Lemma one_side_reflexivity : forall P Q A,
 ~ Col A P Q -> OS P Q A A.

Lemma one_side_symmetry : forall P Q A B,
 OS P Q A B -> OS P Q B A.

Lemma one_side_transitivity : forall P Q A B C,
OS P Q A B -> OS P Q B C -> OS P Q A C.

Lemma col_eq : forall A B X Y,
  A <> X -> Col A X Y -> Col B X Y ->
 ~ Col A X B ->
 X = Y.

Lemma l9_17 : forall A B C P Q, OS P Q A C -> Bet A B C -> OS P Q A B.

Lemma l9_18 : forall X Y A B P,
 Col X Y P -> Col A B P -> (TS X Y A B <-> (Bet A P B /\ ~Col X Y A /\ ~Col X Y B)).

Lemma l9_19 : forall X Y A B P ,
 Col X Y P -> Col A B P -> (OS X Y A B <-> (Out P A B /\ ~Col X Y A)).

Lemma one_side_not_col123 :
 forall A B X Y,
  OS A B X Y ->
  ~ Col A B X.

Lemma one_side_not_col124 :
 forall A B X Y,
  OS A B X Y ->
  ~ Col A B Y.

Lemma col_two_sides : forall A B C P Q,
 Col A B C -> A <> C -> TS A B P Q ->
 TS A C P Q.

Lemma col_one_side : forall A B C P Q,
  Col A B C -> A <> C -> OS A B P Q -> OS A C P Q.

Lemma out_out_one_side :
 forall A B X Y Z,
  OS A B X Y ->
  Out A Y Z ->
  OS A B X Z.

Lemma out_one_side : forall A B X Y, (~ Col A B X \/ ~ Col A B Y) -> Out A X Y -> OS A B X Y.

Lemma bet_ts__ts : forall A B X Y Z, TS A B X Y -> Bet X Y Z -> TS A B X Z.

Lemma bet_ts__os : forall A B X Y Z, TS A B X Y -> Bet X Y Z -> OS A B Y Z.

Lemma l9_31 :
 forall A X Y Z,
  OS A X Y Z ->
  OS A Z Y X ->
  TS A Y X Z.

Lemma col123__nos : forall A B P Q, Col P Q A -> ~ OS P Q A B.

Lemma col124__nos : forall A B P Q, Col P Q B -> ~ OS P Q A B.

Lemma col2_os__os : forall A B C D X Y, C <> D -> Col A B C ->
   Col A B D -> OS A B X Y -> OS C D X Y.

Lemma os_out_os : forall A B C D C' P , Col A B P -> OS A B C D -> Out P C C' -> OS A B C' D.

Lemma ts_ts_os : forall A B C D, TS A B C D -> TS C D A B -> OS A C B D.

Lemma two_sides_not_col :
 forall A B X Y,
  TS A B X Y ->
  ~ Col A B X.

Lemma col_one_side_out : forall A B X Y,
 Col A X Y ->
 OS A B X Y ->
 Out A X Y.

Lemma col_two_sides_bet :
 forall A B X Y,
 Col A X Y ->
 TS A B X Y ->
 Bet X A Y.

Lemma os_ts1324__os : forall A X Y Z,
  OS A X Y Z ->
  TS A Y X Z ->
  OS A Z X Y.

Lemma ts2__ex_bet2 : forall A B C D, TS A C B D -> TS B D A C ->
  exists X, Bet A X C /\ Bet B X D.

Lemma ts2__inangle : forall A B C P, TS A C B P -> TS B P A C ->
  InAngle P A B C.

Lemma out_one_side_1 :
 forall A B C D X,
 ~ Col A B C -> Col A B X -> Out X C D ->
 OS A B C D.

Lemma out_two_sides_two_sides :
 forall A B X Y P PX,
  A <> PX ->
  Col A B PX ->
  Out PX X P ->
  TS A B P Y ->
  TS A B X Y.

Lemma l8_21_bis : forall A B C X Y, X <> Y -> ~ Col C A B -> exists P : Tpoint,
  Cong A P X Y /\ Perp A B P A /\ TS A B C P.

Lemma ts__ncol : forall A B X Y, TS A B X Y -> ~Col A X Y \/ ~Col B X Y.

Lemma one_or_two_sides_aux : forall A B C D X,
 ~ Col C A B -> ~ Col D A B -> Col A C X -> Col B D X ->
 TS A B C D \/ OS A B C D.

Lemma cop__one_or_two_sides :
 forall A B C D, Coplanar A B C D ->
  ~ Col C A B ->
  ~ Col D A B ->
  TS A B C D \/ OS A B C D.

Lemma os__coplanar : forall A B C D, OS A B C D -> Coplanar A B C D.

Lemma coplanar_trans_1 : forall P Q R A B,
  ~ Col P Q R -> Coplanar P Q R A -> Coplanar P Q R B -> Coplanar Q R A B.

Lemma coplanar_pseudo_trans : forall A B C D P Q R,
  ~ Col P Q R ->
  Coplanar P Q R A ->
  Coplanar P Q R B ->
  Coplanar P Q R C ->
  Coplanar P Q R D ->
  Coplanar A B C D.

Lemma col_cop__cop : forall A B C D E, Coplanar A B C D -> C <> D -> Col C D E -> Coplanar A B C E.

Lemma bet_cop__cop : forall A B C D E, Coplanar A B C E -> Bet C D E -> Coplanar A B C D.

Lemma col2_cop__cop : forall A B C D E F, Coplanar A B C D -> C <> D -> Col C D E -> Col C D F ->
  Coplanar A B E F.

Lemma l9_30 : forall A B C D E F P X Y Z,
  ~ Coplanar A B C P -> ~ Col D E F -> Coplanar D E F P ->
  Coplanar A B C X -> Coplanar A B C Y -> Coplanar A B C Z ->
  Coplanar D E F X -> Coplanar D E F Y -> Coplanar D E F Z ->
  Col X Y Z.

Lemma cop_per2__col : forall A X Y Z,
  Coplanar A X Y Z ->  A <> Z -> Per X Z A -> Per Y Z A -> Col X Y Z.

Lemma cop_perp2__col : forall X Y Z A B,
 Coplanar A B Y Z -> Perp X Y A B -> Perp X Z A B -> Col X Y Z.

Lemma two_sides_dec : forall A B C D, TS A B C D \/ ~ TS A B C D.

Lemma cop__not_two_sides_one_side :
 forall A B C D,
  Coplanar A B C D ->
  ~ Col C A B ->
  ~ Col D A B ->
  ~ TS A B C D ->
  OS A B C D.

Lemma cop__not_one_side_two_sides :
 forall A B C D,
  Coplanar A B C D ->
  ~ Col C A B ->
  ~ Col D A B ->
  ~ OS A B C D ->
  TS A B C D.

Lemma one_side_dec : forall A B C D,
 OS A B C D \/ ~ OS A B C D.

Lemma cop_dec : forall A B C D,
 Coplanar A B C D \/ ~ Coplanar A B C D.

Lemma ex_diff_cop : forall A B C D, exists E,
  Coplanar A B C E /\ D <> E.

Lemma ex_ncol_cop : forall A B C D E, D <> E ->
  exists F, Coplanar A B C F /\ ~ Col D E F.

Lemma ex_ncol_cop2 : forall A B C D, exists E F,
  Coplanar A B C E /\ Coplanar A B C F /\ ~ Col D E F.

Lemma cop4__col : forall A1 A2 A3 B1 B2 B3 P Q R, ~ Coplanar A1 A2 A3 B1 -> ~ Col B1 B2 B3 ->
  Coplanar A1 A2 A3 P -> Coplanar B1 B2 B3 P ->
  Coplanar A1 A2 A3 Q -> Coplanar B1 B2 B3 Q ->
  Coplanar A1 A2 A3 R -> Coplanar B1 B2 B3 R ->
  Col P Q R.

Lemma col_cop2__cop : forall A B C U V P, U <> V ->
  Coplanar A B C U -> Coplanar A B C V -> Col U V P ->
  Coplanar A B C P.

Lemma bet_cop2__cop : forall A B C U V W,
  Coplanar A B C U -> Coplanar A B C W -> Bet U V W -> Coplanar A B C V.

Lemma col2_cop2__eq : forall A B C U V P Q, ~ Coplanar A B C U -> U <> V ->
  Coplanar A B C P -> Coplanar A B C Q -> Col U V P -> Col U V Q ->
  P = Q.

Lemma cong3_cop2__col : forall A B C P Q,
  Coplanar A B C P -> Coplanar A B C Q ->
  P <> Q -> Cong A P A Q -> Cong B P B Q -> Cong C P C Q ->
  Col A B C.

Lemma l9_38 : forall A B C P Q, TSP A B C P Q -> TSP A B C Q P.

Lemma l9_39 : forall A B C D P Q R, TSP A B C P R -> Coplanar A B C D -> Out D P Q ->
  TSP A B C Q R.

Lemma l9_41_1 : forall A B C P Q R, TSP A B C P R -> TSP A B C Q R -> OSP A B C P Q.

Lemma l9_41_2 : forall A B C P Q R, TSP A B C P R -> OSP A B C P Q -> TSP A B C Q R.

Lemma tsp_exists : forall A B C P, ~ Coplanar A B C P -> exists Q, TSP A B C P Q.

Lemma osp_reflexivity : forall A B C P, ~ Coplanar A B C P -> OSP A B C P P.

Lemma osp_symmetry : forall A B C P Q, OSP A B C P Q -> OSP A B C Q P.

Lemma osp_transitivity : forall A B C P Q R, OSP A B C P Q -> OSP A B C Q R -> OSP A B C P R.

Lemma cop3_tsp__tsp : forall A B C D E F P Q, ~ Col D E F ->
  Coplanar A B C D -> Coplanar A B C E -> Coplanar A B C F ->
  TSP A B C P Q -> TSP D E F P Q.

Lemma cop3_osp__osp : forall A B C D E F P Q, ~ Col D E F ->
  Coplanar A B C D -> Coplanar A B C E -> Coplanar A B C F ->
  OSP A B C P Q -> OSP D E F P Q.

Lemma ncop_distincts : forall A B C D, ~ Coplanar A B C D ->
  A <> B /\ A <> C /\ A <> D /\ B <> C /\ B <> D /\ C <> D.

Lemma tsp_distincts : forall A B C P Q, TSP A B C P Q ->
  A <> B /\ A <> C /\ B <> C /\ A <> P /\ B <> P /\ C <> P /\ A <> Q /\ B <> Q /\ C <> Q /\ P <> Q.

Lemma osp_distincts : forall A B C P Q, OSP A B C P Q ->
  A <> B /\ A <> C /\ B <> C /\ A <> P /\ B <> P /\ C <> P /\ A <> Q /\ B <> Q /\ C <> Q.

Lemma tsp__ncop1 : forall A B C P Q, TSP A B C P Q -> ~ Coplanar A B C P.

Lemma tsp__ncop2 : forall A B C P Q, TSP A B C P Q -> ~ Coplanar A B C Q.

Lemma osp__ncop1 : forall A B C P Q, OSP A B C P Q -> ~ Coplanar A B C P.

Lemma osp__ncop2 : forall A B C P Q, OSP A B C P Q -> ~ Coplanar A B C Q.

Lemma tsp__nosp : forall A B C P Q, TSP A B C P Q -> ~ OSP A B C P Q.

Lemma osp__ntsp : forall A B C P Q, OSP A B C P Q -> ~ TSP A B C P Q.

Lemma osp_bet__osp : forall A B C P Q R, OSP A B C P R -> Bet P Q R -> OSP A B C P Q.

Lemma l9_18_3 : forall A B C X Y P, Coplanar A B C P -> Col X Y P ->
  TSP A B C X Y <-> Bet X P Y /\ ~ Coplanar A B C X /\ ~ Coplanar A B C Y.

Lemma bet_cop__tsp : forall A B C X Y P,
  ~ Coplanar A B C X -> P <> Y -> Coplanar A B C P -> Bet X P Y ->
  TSP A B C X Y.

Lemma cop_out__osp : forall A B C X Y P,
  ~ Coplanar A B C X -> Coplanar A B C P -> Out P X Y -> OSP A B C X Y.

Lemma l9_19_3 : forall A B C X Y P, Coplanar A B C P -> Col X Y P ->
  OSP A B C X Y <-> Out P X Y /\ ~ Coplanar A B C X.

Lemma cop2_ts__tsp : forall A B C D E X Y, ~ Coplanar A B C X ->
  Coplanar A B C D -> Coplanar A B C E -> TS D E X Y ->
  TSP A B C X Y.

Lemma cop2_os__osp : forall A B C D E X Y, ~ Coplanar A B C X ->
  Coplanar A B C D -> Coplanar A B C E -> OS D E X Y ->
  OSP A B C X Y.

Lemma cop3_tsp__ts : forall A B C D E X Y, D <> E ->
  Coplanar A B C D -> Coplanar A B C E -> Coplanar D E X Y ->
  TSP A B C X Y -> TS D E X Y.

Lemma cop3_osp__os : forall A B C D E X Y, D <> E ->
  Coplanar A B C D -> Coplanar A B C E -> Coplanar D E X Y ->
  OSP A B C X Y -> OS D E X Y.

Lemma cop_tsp__ex_cop2 : forall A B C D E P,
  Coplanar A B C P -> TSP A B C D E ->
  exists Q, Coplanar A B C Q /\ Coplanar D E P Q /\ P <> Q.

Lemma cop_osp__ex_cop2 : forall A B C D E P,
  Coplanar A B C P -> OSP A B C D E ->
  exists Q, Coplanar A B C Q /\ Coplanar D E P Q /\ P <> Q.

End T9.

Hint Resolve l9_2 invert_two_sides invert_one_side one_side_symmetry l9_9 l9_9_bis
             l9_38 osp_symmetry osp__ntsp tsp__nosp : side.
Hint Resolve os__coplanar : cop.

Ltac Side := eauto with side.

Ltac not_exist_hyp_perm4 A B C D := first [not_exist_hyp_perm_ncol A B C|not_exist_hyp_perm_ncol A B D|not_exist_hyp_perm_ncol A C D|not_exist_hyp_perm_ncol B C D].

Ltac assert_ncols :=
repeat
  match goal with
      | H:OS ?A ?B ?X ?Y |- _ =>
     not_exist_hyp_perm_ncol A B X;assert (~ Col A B X) by (apply(one_side_not_col123 A B X Y);finish)

      | H:OS ?A ?B ?X ?Y |- _ =>
     not_exist_hyp_perm_ncol A B Y;assert (~ Col A B Y) by (apply(one_side_not_col124 A B X Y);finish)

      | H:TS ?A ?B ?X ?Y |- _ =>
     not_exist_hyp_perm_ncol A B X;assert (~ Col A B X) by (apply(two_sides_not_col A B X Y);finish)

      | H:TS ?A ?B ?X ?Y |- _ =>
     not_exist_hyp_perm_ncol A B Y;assert (~ Col A B Y) by (apply(two_sides_not_col A B Y X);finish)

      | H:~ Coplanar ?A ?B ?C ?D |- _ =>
      let h := fresh in
      not_exist_hyp_perm4 A B C D;
      assert (h := ncop__ncols A B C D H);decompose [and] h;clear h;clean_reap_hyps
  end. *)

Require Import GeoCoq.Tactics.Coinc.tactics_axioms.
(* GeoCoq.Tactics.Coinc.tactics_axioms:
Require Export GeoCoq.Utils.arity.

Class Col_theory (COLTpoint : Type) (CTCol: COLTpoint -> COLTpoint -> COLTpoint -> Prop) :=
{
  CTcol_trivial : forall A B : COLTpoint, CTCol A A B;
  CTcol_permutation_1 : forall A B C : COLTpoint, CTCol A B C -> CTCol B C A;
  CTcol_permutation_2 : forall A B C : COLTpoint, CTCol A B C -> CTCol A C B;
  CTcol3 : forall X Y A B C : COLTpoint,
             X <> Y -> CTCol X Y A -> CTCol X Y B -> CTCol X Y C -> CTCol A B C
}.

Class Arity :=
{
  COINCpoint : Type;
  n : nat
}.

Class Coinc_predicates (Ar : Arity) :=
{
  wd : arity COINCpoint (S (S n));
  coinc : arity COINCpoint (S (S (S n)))
}.

Class Coinc_theory (Ar : Arity) (COP : Coinc_predicates Ar) :=
{
  wd_perm_1 : forall A : COINCpoint,
              forall X : cartesianPower COINCpoint (S n),
                app_1_n wd A X -> app_n_1 wd X A;
  wd_perm_2 : forall A B : COINCpoint,
              forall X : cartesianPower COINCpoint n,
                app_2_n wd A B X -> app_2_n wd B A X;
  coinc_perm_1 : forall A : COINCpoint,
                 forall X : cartesianPower COINCpoint (S (S n)),
                   app_1_n coinc A X -> app_n_1 coinc X A;
  coinc_perm_2 : forall A B : COINCpoint,
                 forall X : cartesianPower COINCpoint (S n),
                   app_2_n coinc A B X -> app_2_n coinc B A X;
  coinc_bd : forall A : COINCpoint,
             forall X : cartesianPower COINCpoint (S n),
              app_2_n coinc A A X;
  coinc_n : forall COINC : cartesianPower COINCpoint (S (S (S n))),
            forall WD : cartesianPower COINCpoint (S (S n)),
              pred_conj coinc COINC WD ->
              app wd WD ->
              app coinc COINC
}. *)



Section Tarski_is_a_Coinc_theory_for_cop.



Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.



Definition not_col : arity Tpoint 3 := fun A B C : Tpoint => ~ Col A B C.



Lemma not_col_perm_1 : forall A X, app_1_n not_col A X -> app_n_1 not_col X A.

Proof.

unfold not_col.

simpl.

Col.

Qed.



Lemma not_col_perm_2 : forall A B (X : cartesianPower Tpoint 1),

  app_2_n not_col A B X -> app_2_n not_col B A X.

Proof.

unfold not_col.

unfold app_2_n.

simpl.

Col.

Qed.



Definition cop : arity Tpoint 4 := Coplanar.



Lemma cop_perm_1 : forall A (X : cartesianPower Tpoint 3), app_1_n cop A X -> app_n_1 cop X A.

Proof.

unfold cop.

simpl.

Cop.

Qed.



Lemma cop_perm_2 : forall A B (X : cartesianPower Tpoint 2), app_2_n cop A B X -> app_2_n cop B A X.

Proof.

unfold cop.

unfold app_2_n.

simpl.

Cop.

Qed.



Lemma cop_bd : forall A (X : cartesianPower Tpoint 2), app_2_n cop A A X.

Proof.

unfold cop.

unfold app_2_n.

simpl.

Cop.

Qed.



Lemma cop_3 : forall (COP : cartesianPower Tpoint 4) (NOT_COL : cartesianPower Tpoint 3),

  pred_conj cop COP NOT_COL -> app not_col NOT_COL -> app cop COP.

Proof.

unfold pred_conj.

unfold cop.

unfold not_col.

simpl in *.

intros COP NOT_COL HCop HNot_Col.

destruct HCop as [HCop1 [HCop2 [HCop3 HCop4]]].

apply coplanar_pseudo_trans with (fst NOT_COL) (fst (snd NOT_COL)) (snd (snd NOT_COL)); Cop.

Qed.



Global Instance Tarski_is_a_Arity_for_cop : Arity.

Proof. exact (Build_Arity Tpoint 1). Defined.



Global Instance Tarski_is_a_Coinc_predicates_for_cop :

  (Coinc_predicates Tarski_is_a_Arity_for_cop).

Proof.

exact (Build_Coinc_predicates Tarski_is_a_Arity_for_cop not_col cop).

Defined.



Global Instance Tarski_is_a_Coinc_theory_for_cop :   (Coinc_theory Tarski_is_a_Arity_for_cop Tarski_is_a_Coinc_predicates_for_cop).

Proof.

exact (Build_Coinc_theory Tarski_is_a_Arity_for_cop

                          Tarski_is_a_Coinc_predicates_for_cop

                          not_col_perm_1 not_col_perm_2 cop_perm_1 cop_perm_2

                          cop_bd cop_3).

Defined.



End Tarski_is_a_Coinc_theory_for_cop.
