Require Import GeoCoq.Axioms.continuity_axioms.
(* GeoCoq.Axioms.continuity_axioms:
Require Import GeoCoq.Tarski_dev.Definitions.

Section Continuity_Defs.

Context `{Tn:Tarski_neutral_dimensionless}.

Definition segment_circle := forall A B P Q,
  InCircle P A B ->
  OutCircle Q A B ->
  exists Z, Bet P Z Q /\ OnCircle Z A B.

Definition one_point_line_circle := forall A B U V P,
  Col U V P -> U <> V -> Bet A P B ->
  exists Z, Col U V Z /\ OnCircle Z A B.

Definition two_points_line_circle := forall A B U V P,
  Col U V P -> U <> V -> Bet A P B ->
  exists Z1 Z2, Col U V Z1 /\ OnCircle Z1 A B /\
                Col U V Z2 /\ OnCircle Z2 A B /\
                Bet Z1 P Z2 /\ (P <> B -> Z1 <> Z2).

Definition circle_circle := forall A B C D P Q,
  OnCircle P C D ->
  OnCircle Q C D ->
  InCircle P A B ->
  OutCircle Q A B ->
  exists Z, OnCircle Z A B /\ OnCircle Z C D.

Definition circle_circle_bis := forall A B C D P Q,
  OnCircle P C D ->
  InCircle P A B ->
  OnCircle Q A B ->
  InCircle Q C D ->
  exists Z, OnCircle Z A B /\ OnCircle Z C D.

Definition circle_circle_axiom := forall A B C D B' D',
  Cong A B' A B -> Cong C D' C D ->
  Bet A D' B -> Bet C B' D ->
  exists Z, Cong A Z A B /\ Cong C Z C D.

Definition circle_circle_two := forall A B C D P Q,
  OnCircle P C D ->
  OnCircle Q C D ->
  InCircle P A B ->
  OutCircle Q A B ->
  exists Z1 Z2,
    OnCircle Z1 A B /\ OnCircle Z1 C D /\
    OnCircle Z2 A B /\ OnCircle Z2 C D /\
    (InCircleS P A B -> OutCircleS Q A B -> Z1<>Z2).

Definition euclid_s_prop_1_22 := forall A B C D E F A' B' C' D' E' F',
  SumS A B C D E' F' -> SumS A B E F C' D' -> SumS C D E F A' B' ->
  Le E F E' F' -> Le C D C' D' -> Le A B A' B' ->
  exists P Q R, Cong P Q A B /\ Cong P R C D /\ Cong Q R E F.

Definition Nested (A B:nat -> Tpoint -> Prop) :=
  (forall n, exists An, A n An) /\ (forall n, exists Bn, B n Bn) /\
  forall n An Am Bm Bn,
    A n An -> A (S n) Am -> B (S n) Bm -> B n Bn -> Bet An Am Bm /\ Bet Am Bm Bn /\ Am <> Bm.

Definition cantor_s_axiom := forall A B, Nested A B ->
  exists X, forall n An Bn, A n An -> B n Bn -> Bet An X Bn.

Definition dedekind_s_axiom := forall (Alpha Beta : Tpoint -> Prop),
  (exists A, forall X Y, Alpha X -> Beta Y -> Bet A X Y) ->
  (exists B, forall X Y, Alpha X -> Beta Y -> Bet X B Y).

Inductive FOF : Prop -> Prop :=
| eq_fof : forall A B:Tpoint, FOF (A = B)
| bet_fof : forall A B C, FOF (Bet A B C)
| cong_fof : forall A B C D, FOF (Cong A B C D)
| not_fof : forall P, FOF P -> FOF (~ P)
| and_fof : forall P Q, FOF P -> FOF Q -> FOF (P /\ Q)
| or_fof : forall P Q, FOF P -> FOF Q -> FOF (P \/ Q)
| implies_fof : forall P Q, FOF P -> FOF Q -> FOF (P -> Q)
| forall_fof : forall P, (forall (A:Tpoint), FOF (P A)) -> FOF (forall A, P A)
| exists_fof : forall P, (forall (A:Tpoint), FOF (P A)) -> FOF (exists A, P A).

Definition first_order_dedekind := forall Alpha Beta,
  (forall X, FOF (Alpha X)) -> (forall Y, FOF (Beta Y)) ->
  (exists A, forall X Y, Alpha X -> Beta Y -> Bet A X Y) ->
  (exists B, forall X Y, Alpha X -> Beta Y -> Bet X B Y).

Definition archimedes_axiom := forall A B C D, A <> B -> Reach A B C D.

Definition aristotle_s_axiom := forall P Q A B C,
  ~ Col A B C -> Acute A B C ->
  exists X Y, Out B A X /\ Out B C Y /\ Per B X Y /\ Lt P Q X Y.

Definition greenberg_s_axiom := forall P Q R A B C,
  ~ Col A B C ->
  Acute A B C -> Q <> R -> Per P Q R ->
  exists S, LtA P S Q A B C /\ Out Q S R.

End Continuity_Defs.

Section Completeness.

Context `{Tn:Tarski_neutral_dimensionless}.

Definition inj {T1 T2:Type} (f:T1->T2) := forall A B, f A = f B -> A = B.

Definition pres_bet {Tm: Tarski_neutral_dimensionless}
  (f : @Tpoint Tn -> @Tpoint Tm) := forall A B C, Bet A B C -> Bet (f A) (f B) (f C).

Definition pres_cong {Tm: Tarski_neutral_dimensionless}
  (f : @Tpoint Tn -> @Tpoint Tm) := forall A B C D, Cong A B C D -> Cong (f A) (f B) (f C) (f D).

Definition extension {Tm: Tarski_neutral_dimensionless} f := inj f /\ pres_bet f /\ pres_cong f.

Definition completeness_for_planes := forall (Tm: Tarski_neutral_dimensionless)
  (Tm2 : Tarski_neutral_dimensionless_with_decidable_point_equality Tm)
  (M : Tarski_2D Tm2)
  (f : @Tpoint Tn -> @Tpoint Tm),
  @archimedes_axiom Tm ->
  extension f ->
  forall A, exists B, f B = A.

Definition completeness_for_3d_spaces := forall (Tm: Tarski_neutral_dimensionless)
  (Tm2 : Tarski_neutral_dimensionless_with_decidable_point_equality Tm)
  (M : Tarski_3D Tm2)
  (f : @Tpoint Tn -> @Tpoint Tm),
  @archimedes_axiom Tm ->
  extension f ->
  forall A, exists B, f B = A.

Definition inj_line {T:Type} (f:Tpoint->T) P Q := forall A B, Col P Q A -> Col P Q B ->
  f A = f B -> A = B.

Definition pres_bet_line {Tm: Tarski_neutral_dimensionless}
  (f : @Tpoint Tn -> @Tpoint Tm) P Q := forall A B C, Col P Q A -> Col P Q B -> Col P Q C ->
  Bet A B C -> Bet (f A) (f B) (f C).

Definition pres_cong_line {Tm: Tarski_neutral_dimensionless}
  (f : @Tpoint Tn -> @Tpoint Tm) P Q := forall A B C D,
  Col P Q A -> Col P Q B -> Col P Q C -> Col P Q D ->
  Cong A B C D -> Cong (f A) (f B) (f C) (f D).

Definition line_extension {Tm: Tarski_neutral_dimensionless} f P Q :=
  P <> Q /\ inj_line f P Q /\ pres_bet_line f P Q /\ pres_cong_line f P Q.

Definition line_completeness := forall (Tm: Tarski_neutral_dimensionless)
  (Tm2 : Tarski_neutral_dimensionless_with_decidable_point_equality Tm)
  P Q
  (f : @Tpoint Tn -> @Tpoint Tm),
  @archimedes_axiom Tm ->
  line_extension f P Q ->
  forall A, Col (f P) (f Q) A -> exists B, Col P Q B /\ f B = A.

End Completeness. *)

Require Import GeoCoq.Meta_theory.Continuity.completeness.
(* GeoCoq.Meta_theory.Continuity.completeness:
Require Import GeoCoq.Axioms.continuity_axioms.
Require Import GeoCoq.Meta_theory.Dimension_axioms.upper_dim_2.
Require Import GeoCoq.Meta_theory.Dimension_axioms.upper_dim_3.
Require Import GeoCoq.Tarski_dev.Ch10_line_reflexivity_2.

Section Completeness.

Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.

Lemma extension__line_extension : forall {Tm: Tarski_neutral_dimensionless}
  (f : @Tpoint Tn -> @Tpoint Tm) P Q,
  P <> Q -> extension f -> line_extension f P Q.

Lemma extension_reverse_bet : forall {Tm: Tarski_neutral_dimensionless}
  {Tm2 : Tarski_neutral_dimensionless_with_decidable_point_equality Tm}
  (f : @Tpoint Tn -> @Tpoint Tm),
  extension f ->
  forall A B C, Bet (f A) (f B) (f C) -> Bet A B C.

Lemma extension_reverse_col : forall {Tm: Tarski_neutral_dimensionless}
  {Tm2 : Tarski_neutral_dimensionless_with_decidable_point_equality Tm}
  (f : @Tpoint Tn -> @Tpoint Tm),
  extension f ->
  forall A B C, Col (f A) (f B) (f C) -> Col A B C.

Lemma line_completeness_aux : line_completeness ->
  forall (Tm: Tarski_neutral_dimensionless)
  (Tm2 : Tarski_neutral_dimensionless_with_decidable_point_equality Tm)
  (f : @Tpoint Tn -> @Tpoint Tm),
  @archimedes_axiom Tm ->
  extension f ->
  forall A P Q R, ~ Col P Q R -> Coplanar (f P) (f Q) (f R) A ->
    exists B, Coplanar P Q R B /\ f B = A.

Lemma line_completeness__completeness_for_planes : line_completeness -> completeness_for_planes.

Lemma completeness_aux : forall {Tm: Tarski_neutral_dimensionless}
  P Q R (f : @Tpoint Tn -> @Tpoint Tm) A,
  (exists B, Coplanar P Q R B /\ f B = A) -> exists B, f B = A.

Lemma line_completeness__completeness_for_3d_spaces :
  (exists P Q R S, ~ Coplanar P Q R S) ->
  line_completeness -> completeness_for_3d_spaces.

End Completeness.

Section Dimension.

Context `{Tn:Tarski_neutral_dimensionless}.

Lemma extension_to_plane__plane : forall {Tm: Tarski_neutral_dimensionless}
  {Tm2 : Tarski_neutral_dimensionless_with_decidable_point_equality Tm}
  {M : Tarski_2D Tm2}
  (f : @Tpoint Tn -> @Tpoint Tm),
  extension f ->
  @upper_dim_axiom Tn.

Lemma nupper_dim__completeness_for_planes : ~ upper_dim_axiom -> completeness_for_planes.

Lemma extension_to_3d__upper_dim_3 : forall {Tm: Tarski_neutral_dimensionless}
  {Tm2 : Tarski_neutral_dimensionless_with_decidable_point_equality Tm}
  {M : Tarski_3D Tm2}
  (f : @Tpoint Tn -> @Tpoint Tm),
  extension f ->
  @upper_dim_3_axiom Tn.

Lemma nupper_dim_3__completeness_for_3d_spaces : ~ upper_dim_3_axiom -> completeness_for_3d_spaces.

End Dimension.

Section Dimension'.

Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.

Lemma ncompleteness_for_planes__upper_dim : ~ completeness_for_planes -> upper_dim_axiom.

Lemma ncompleteness_for_3d_spaces__upper_dim_3 : ~ completeness_for_3d_spaces -> upper_dim_3_axiom.

End Dimension'. *)

Require Import GeoCoq.Meta_theory.Continuity.grad.
(* GeoCoq.Meta_theory.Continuity.grad:
Require Import GeoCoq.Tarski_dev.Ch08_orthogonality.
Require Import Relations.

Section Grad.

Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.

Lemma grad__bet : forall A B C, Grad A B C -> Bet A B C.

Lemma grad__col : forall A B C, Grad A B C -> Col A B C.

Lemma grad_neq__neq13 : forall A B C, Grad A B C -> A <> B -> A <> C.

Lemma grad_neq__neq12 : forall A B C, Grad A B C -> A <> C -> A <> B.

Lemma grad112__eq : forall A B, Grad A A B -> A = B.

Lemma grad121__eq : forall A B, Grad A B A -> A = B.

Lemma grad__le : forall A B C, Grad A B C -> Le A B A C.

Lemma grad2__grad123 : forall A B C D E F, Grad2 A B C D E F -> Grad A B C.

Lemma grad2__grad456 : forall A B C D E F, Grad2 A B C D E F -> Grad D E F.

Lemma grad_sum : forall A B C D E,
  Grad A B C -> Grad A B D -> Bet A C E -> Cong A D C E ->
  Grad A B E.

Lemma gradexp__grad : forall A B C, GradExp A B C -> Grad A B C.

Lemma gradexp_le__reach : forall A B C D B',
  GradExp A B B' -> Le C D A B' ->
  Reach A B C D.

Lemma grad__ex_gradexp_le : forall A B C,
  Grad A B C ->
  exists D, GradExp A B D /\ Le A C A D.

Lemma reach__ex_gradexp_le : forall A B C D, Reach A B C D ->
  exists B', GradExp A B B' /\ Le C D A B'.

Lemma gradexp2__gradexp123 : forall A B C D E F,
  GradExp2 A B C D E F ->
  GradExp A B C.

Lemma gradexp2__gradexp456 : forall A B C D E F,
  GradExp2 A B C D E F ->
  GradExp D E F.

Inductive GradExpInv : Tpoint -> Tpoint -> Tpoint -> Prop :=
    gradexpinv_init : forall A B, GradExpInv A B B
  | gradexpinv_stab : forall A B B' C, Bet A B' B -> Cong A B' B' B -> GradExpInv A B C ->
                    GradExpInv A B' C.

Lemma gradexp_clos_trans : forall A B C, GradExp A B C <->
  clos_refl_trans_n1 Tpoint (fun X Y => Midpoint X A Y) B C.

Lemma gradexpinv_clos_trans : forall A B C, GradExpInv A B C <->
  clos_refl_trans_1n Tpoint (fun X Y => Midpoint X A Y) B C.

Lemma gradexp__gradexpinv : forall A B C, GradExp A B C <-> GradExpInv A B C.

Lemma reach__grad_min : forall A B C, A <> B -> Bet A B C -> Reach A B A C ->
  exists D E, Bet A D C /\ Grad A B D /\ E <> C /\ Bet A C E /\ Bet A D E /\ Cong A B D E.

Lemma reach__ex_gradexp_lt : forall A B P Q, A <> B -> Reach P Q A B ->
  exists C, GradExp A C B /\ Lt A C P Q.

End Grad.

Hint Resolve grad__bet : between.
Hint Resolve grad__col : col. *)

Require Import GeoCoq.Tarski_dev.Ch08_orthogonality.
(* GeoCoq.Tarski_dev.Ch08_orthogonality:
Require Export GeoCoq.Tarski_dev.Ch07_midpoint.

Require Export GeoCoq.Tactics.Coinc.ColR.

Ltac not_exist_hyp_perm_ncol A B C := not_exist_hyp (~ Col A B C); not_exist_hyp (~ Col A C B);
                                 not_exist_hyp (~ Col B A C); not_exist_hyp (~ Col B C A);
                                 not_exist_hyp (~ Col C A B); not_exist_hyp (~ Col C B A).

Ltac assert_diffs_by_cases :=
 repeat match goal with
 | A: Tpoint, B: Tpoint |- _ => not_exist_hyp_comm A B;induction (eq_dec_points A B);[treat_equalities;solve [finish|trivial] |idtac]
end.

Ltac assert_cols :=
repeat
 match goal with
      | H:Bet ?X1 ?X2 ?X3 |- _ =>
     not_exist_hyp_perm_col X1 X2 X3;assert (Col X1 X2 X3) by (apply bet_col;apply H)

      | H:Midpoint ?X1 ?X2 ?X3 |- _ =>
     not_exist_hyp_perm_col X1 X2 X3;let N := fresh in assert (N := midpoint_col X2 X1 X3 H)

      | H:Out ?X1 ?X2 ?X3 |- _ =>
     not_exist_hyp_perm_col X1 X2 X3;let N := fresh in assert (N := out_col X1 X2 X3 H)
 end.

Ltac assert_bets :=
repeat
 match goal with
      | H:Midpoint ?B ?A ?C |- _ => let T := fresh in not_exist_hyp (Bet A B C); assert (T := midpoint_bet A B C H)
 end.

Ltac clean_reap_hyps :=
  clean_duplicated_hyps;
  repeat
  match goal with
   | H:(Midpoint ?A ?B ?C), H2 : Midpoint ?A ?C ?B |- _ => clear H2
   | H:(Col ?A ?B ?C), H2 : Col ?A ?C ?B |- _ => clear H2
   | H:(Col ?A ?B ?C), H2 : Col ?B ?A ?C |- _ => clear H2
   | H:(Col ?A ?B ?C), H2 : Col ?B ?C ?A |- _ => clear H2
   | H:(Col ?A ?B ?C), H2 : Col ?C ?B ?A |- _ => clear H2
   | H:(Col ?A ?B ?C), H2 : Col ?C ?A ?B |- _ => clear H2
   | H:(Bet ?A ?B ?C), H2 : Bet ?C ?B ?A |- _ => clear H2
   | H:(Cong ?A ?B ?C ?D), H2 : Cong ?A ?B ?D ?C |- _ => clear H2
   | H:(Cong ?A ?B ?C ?D), H2 : Cong ?C ?D ?A ?B |- _ => clear H2
   | H:(Cong ?A ?B ?C ?D), H2 : Cong ?C ?D ?B ?A |- _ => clear H2
   | H:(Cong ?A ?B ?C ?D), H2 : Cong ?D ?C ?B ?A |- _ => clear H2
   | H:(Cong ?A ?B ?C ?D), H2 : Cong ?D ?C ?A ?B |- _ => clear H2
   | H:(Cong ?A ?B ?C ?D), H2 : Cong ?B ?A ?C ?D |- _ => clear H2
   | H:(Cong ?A ?B ?C ?D), H2 : Cong ?B ?A ?D ?C |- _ => clear H2
   | H:(?A<>?B), H2 : (?B<>?A) |- _ => clear H2
end.

Ltac assert_diffs :=
repeat
 match goal with
      | H:(~Col ?X1 ?X2 ?X3) |- _ =>
      let h := fresh in
      not_exist_hyp3 X1 X2 X1 X3 X2 X3;
      assert (h := not_col_distincts X1 X2 X3 H);decompose [and] h;clear h;clean_reap_hyps

      | H:(~Bet ?X1 ?X2 ?X3) |- _ =>
      let h := fresh in
      not_exist_hyp2 X1 X2 X2 X3;
      assert (h := not_bet_distincts X1 X2 X3 H);decompose [and] h;clear h;clean_reap_hyps
      | H:Bet ?A ?B ?C, H2 : ?A <> ?B |-_ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= bet_neq12__neq A B C H H2);clean_reap_hyps
      | H:Bet ?A ?B ?C, H2 : ?B <> ?A |-_ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= bet_neq21__neq A B C H H2);clean_reap_hyps
      | H:Bet ?A ?B ?C, H2 : ?B <> ?C |-_ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= bet_neq23__neq A B C H H2);clean_reap_hyps
      | H:Bet ?A ?B ?C, H2 : ?C <> ?B |-_ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= bet_neq32__neq A B C H H2);clean_reap_hyps

      | H:Cong ?A ?B ?C ?D, H2 : ?A <> ?B |-_ =>
      let T:= fresh in (not_exist_hyp_comm C D);
        assert (T:= cong_diff A B C D H2 H);clean_reap_hyps
      | H:Cong ?A ?B ?C ?D, H2 : ?B <> ?A |-_ =>
      let T:= fresh in (not_exist_hyp_comm C D);
        assert (T:= cong_diff_2 A B C D H2 H);clean_reap_hyps
      | H:Cong ?A ?B ?C ?D, H2 : ?C <> ?D |-_ =>
      let T:= fresh in (not_exist_hyp_comm A B);
        assert (T:= cong_diff_3 A B C D H2 H);clean_reap_hyps
      | H:Cong ?A ?B ?C ?D, H2 : ?D <> ?C |-_ =>
      let T:= fresh in (not_exist_hyp_comm A B);
        assert (T:= cong_diff_4 A B C D H2 H);clean_reap_hyps

      | H:Le ?A ?B ?C ?D, H2 : ?A <> ?B |-_ =>
      let T:= fresh in (not_exist_hyp_comm C D);
        assert (T:= le_diff A B C D H2 H);clean_reap_hyps
      | H:Lt ?A ?B ?C ?D |-_ =>
      let T:= fresh in (not_exist_hyp_comm C D);
        assert (T:= lt_diff A B C D H);clean_reap_hyps

      | H:Midpoint ?I ?A ?B, H2 : ?A<>?B |- _ =>
      let T:= fresh in (not_exist_hyp2 I B I A);
       assert (T:= midpoint_distinct_1 I A B H2 H);
       decompose [and] T;clear T;clean_reap_hyps
      | H:Midpoint ?I ?A ?B, H2 : ?B<>?A |- _ =>
      let T:= fresh in (not_exist_hyp2 I B I A);
       assert (T:= midpoint_distinct_1 I A B (swap_diff B A H2) H);
       decompose [and] T;clear T;clean_reap_hyps

      | H:Midpoint ?I ?A ?B, H2 : ?I<>?A |- _ =>
      let T:= fresh in (not_exist_hyp2 I B A B);
       assert (T:= midpoint_distinct_2 I A B H2 H);
       decompose [and] T;clear T;clean_reap_hyps
      | H:Midpoint ?I ?A ?B, H2 : ?A<>?I |- _ =>
      let T:= fresh in (not_exist_hyp2 I B A B);
       assert (T:= midpoint_distinct_2 I A B (swap_diff A I H2) H);
       decompose [and] T;clear T;clean_reap_hyps

      | H:Midpoint ?I ?A ?B, H2 : ?I<>?B |- _ =>
      let T:= fresh in (not_exist_hyp2 I A A B);
       assert (T:= midpoint_distinct_3 I A B H2 H);
       decompose [and] T;clear T;clean_reap_hyps
      | H:Midpoint ?I ?A ?B, H2 : ?B<>?I |- _ =>
      let T:= fresh in (not_exist_hyp2 I A A B);
       assert (T:= midpoint_distinct_3 I A B (swap_diff B I H2) H);
       decompose [and] T;clear T;clean_reap_hyps

      | H:Out ?A ?B ?C |- _ =>
      let T:= fresh in (not_exist_hyp2 A B A C);
       assert (T:= out_distinct A B C H);
       decompose [and] T;clear T;clean_reap_hyps
 end.

Ltac clean_trivial_hyps :=
  repeat
  match goal with
   | H:(Cong ?X1 ?X1 ?X2 ?X2) |- _ => clear H
   | H:(Cong ?X1 ?X2 ?X2 ?X1) |- _ => clear H
   | H:(Cong ?X1 ?X2 ?X1 ?X2) |- _ => clear H
   | H:(Bet ?X1 ?X1 ?X2) |- _ => clear H
   | H:(Bet ?X2 ?X1 ?X1) |- _ => clear H
   | H:(Col ?X1 ?X1 ?X2) |- _ => clear H
   | H:(Col ?X2 ?X1 ?X1) |- _ => clear H
   | H:(Col ?X1 ?X2 ?X1) |- _ => clear H
   | H:(Midpoint ?X1 ?X1 ?X1) |- _ => clear H
end.

Ltac clean := clean_trivial_hyps;clean_reap_hyps.

Ltac treat_equalities :=
try treat_equalities_aux;
repeat
  match goal with
   | H:(Cong ?X3 ?X3 ?X1 ?X2) |- _ =>
      apply cong_symmetry in H; apply cong_identity in H;
      smart_subst X2;clean_reap_hyps
   | H:(Cong ?X1 ?X2 ?X3 ?X3) |- _ =>
      apply cong_identity in H;smart_subst X2;clean_reap_hyps
   | H:(Bet ?X1 ?X2 ?X1) |- _ =>
      apply  between_identity in H;smart_subst X2;clean_reap_hyps
   | H:(Midpoint ?X ?Y ?Y) |- _ => apply l7_3 in H; smart_subst Y;clean_reap_hyps
   | H : Bet ?A ?B ?C, H2 : Bet ?B ?A ?C |- _ =>
     let T := fresh in not_exist_hyp (A=B); assert (T : A=B) by (apply (between_equality A B C); finish);
                       smart_subst A;clean_reap_hyps
   | H : Bet ?A ?B ?C, H2 : Bet ?A ?C ?B |- _ =>
     let T := fresh in not_exist_hyp (B=C); assert (T : B=C) by (apply (between_equality_2 A B C); finish);
                       smart_subst B;clean_reap_hyps
   | H : Bet ?A ?B ?C, H2 : Bet ?C ?A ?B |- _ =>
     let T := fresh in not_exist_hyp (A=B); assert (T : A=B) by (apply (between_equality A B C); finish);
                       smart_subst A;clean_reap_hyps
   | H : Bet ?A ?B ?C, H2 : Bet ?B ?C ?A |- _ =>
     let T := fresh in not_exist_hyp (B=C); assert (T : B=C) by (apply (between_equality_2 A B C); finish);
                       smart_subst A;clean_reap_hyps
   | H:(Le ?X1 ?X2 ?X3 ?X3) |- _ =>
      apply le_zero in H;smart_subst X2;clean_reap_hyps
   | H : Midpoint ?P ?A ?P1, H2 : Midpoint ?P ?A ?P2 |- _ =>
     let T := fresh in not_exist_hyp (P1=P2);
                      assert (T := symmetric_point_uniqueness A P P1 P2 H H2);
                      smart_subst P1;clean_reap_hyps
   | H : Midpoint ?A ?P ?X, H2 : Midpoint ?A ?Q ?X |- _ =>
     let T := fresh in not_exist_hyp (P=Q); assert (T := l7_9 P Q A X H H2);
                       smart_subst P;clean_reap_hyps
   | H : Midpoint ?A ?P ?X, H2 : Midpoint ?A ?X ?Q |- _ =>
     let T := fresh in not_exist_hyp (P=Q); assert (T := l7_9_bis P Q A X H H2);
                       smart_subst P;clean_reap_hyps
   | H : Midpoint ?M ?A ?A |- _ =>
     let T := fresh in not_exist_hyp (M=A); assert (T : l7_3 M A H);
                       smart_subst M;clean_reap_hyps
   | H : Midpoint ?A ?P ?P', H2 : Midpoint ?B ?P ?P' |- _ =>
     let T := fresh in not_exist_hyp (A=B); assert (T := l7_17 P P' A B H H2);
                       smart_subst A;clean_reap_hyps
   | H : Midpoint ?A ?P ?P', H2 : Midpoint ?B ?P' ?P |- _ =>
     let T := fresh in not_exist_hyp (A=B); assert (T := l7_17_bis P P' A B H H2);
                       smart_subst A;clean_reap_hyps
   | H : Midpoint ?A ?B ?A |- _ =>
     let T := fresh in not_exist_hyp (A=B); assert (T := is_midpoint_id_2 A B H);
                       smart_subst A;clean_reap_hyps
   | H : Midpoint ?A ?A ?B |- _ =>
     let T := fresh in not_exist_hyp (A=B); assert (T := is_midpoint_id A B H);
                       smart_subst A;clean_reap_hyps
end.

Ltac ColR :=
 let tpoint := constr:(Tpoint) in
 let col := constr:(Col) in
   treat_equalities; assert_cols; assert_diffs; try (solve [Col]); Col_refl tpoint col.

Ltac search_contradiction :=
 match goal with
  | H: ?A <> ?A |- _ => exfalso;apply H;reflexivity
  | H: ~ Col ?A ?B ?C |- _ => exfalso;apply H;ColR
  | H: ~ ?P, H2 : ?P |- _ => exfalso;apply (H H2)
 end.

Ltac show_distinct' X Y :=
 assert (X<>Y);
 [intro;treat_equalities; (solve [search_contradiction])|idtac].

Ltac assert_all_diffs_by_contradiction :=
repeat match goal with
 | A: Tpoint, B: Tpoint |- _ => not_exist_hyp_comm A B;show_distinct' A B
end.

Section T8_1.

Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.

Lemma per_dec : forall A B C, Per A B C \/ ~ Per A B C.

Lemma l8_2 : forall A B C, Per A B C -> Per C B A.

End T8_1.

Hint Resolve l8_2 : perp.

Ltac Perp := auto with perp.

Section T8_2.

Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.

Lemma Per_cases :
 forall A B C,
 Per A B C \/ Per C B A ->
 Per A B C.

Lemma Per_perm :
 forall A B C,
 Per A B C ->
 Per A B C /\ Per C B A.

Lemma l8_3 : forall A B C A',
 Per A B C -> A<>B -> Col B A A' -> Per A' B C.

Lemma l8_4 : forall A B C C', Per A B C -> Midpoint B C C' -> Per A B C'.

Lemma l8_5 : forall A B, Per A B B.

Lemma l8_6 : forall A B C A', Per A B C -> Per A' B C -> Bet A C A' -> B=C.

End T8_2.

Hint Resolve l8_5 : perp.

Ltac let_symmetric C P A :=
let id1:=fresh in (assert (id1:(exists A', Midpoint P A A'));
[apply symmetric_point_construction|ex_and id1 C]).

Ltac symmetric B' A B :=
assert(sp:= symmetric_point_construction B A); ex_and sp B'.

Section T8_3.

Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.

Lemma l8_7 : forall A B C, Per A B C -> Per A C B -> B=C.

Lemma l8_8 : forall A B, Per A B A -> A=B.

Lemma per_distinct : forall A B C, Per A B C -> A <> B -> A <> C.

Lemma per_distinct_1 : forall A B C, Per A B C -> B <> C -> A <> C.

Lemma l8_9 : forall A B C, Per A B C -> Col A B C -> A=B \/ C=B.

Lemma l8_10 : forall A B C A' B' C',  Per A B C -> Cong_3 A B C A' B' C' -> Per A' B' C'.

Lemma col_col_per_per : forall A X C U V,
 A<>X -> C<>X ->
 Col U A X ->
 Col V C X ->
 Per A X C ->
 Per U X V.

Lemma perp_in_dec : forall X A B C D, Perp_at X A B C D \/ ~ Perp_at X A B C D.

Lemma perp_distinct : forall A B C D, Perp A B C D -> A <> B /\ C <> D.

Lemma l8_12 : forall A B C D X, Perp_at X A B C D -> Perp_at X C D A B.

Lemma per_col : forall A B C D,
 B <> C -> Per A B C -> Col B C D -> Per A B D.

Lemma l8_13_2 : forall A B C D X,
   A <> B -> C <> D -> Col X A B -> Col X C D ->
  (exists U, exists V :Tpoint, Col U A B /\ Col V C D /\ U<>X /\ V<>X /\ Per U X V) ->
  Perp_at X A B C D.

Lemma l8_14_1 : forall A B, ~ Perp A B A B.

Lemma l8_14_2_1a : forall X A B C D, Perp_at X A B C D -> Perp A B C D.

Lemma perp_in_distinct : forall X A B C D , Perp_at X A B C D -> A <> B /\ C <> D.

Lemma l8_14_2_1b : forall X A B C D Y, Perp_at X A B C D -> Col Y A B -> Col Y C D -> X=Y.

Lemma l8_14_2_1b_bis : forall A B C D X, Perp A B C D -> Col X A B -> Col X C D -> Perp_at X A B C D.

Lemma l8_14_2_2 : forall X A B C D,
 Perp A B C D -> (forall Y, Col Y A B -> Col Y C D -> X=Y) ->  Perp_at X A B C D.

Lemma l8_14_3 : forall A B C D X Y, Perp_at X A B C D -> Perp_at Y A B C D -> X=Y.

Lemma l8_15_1 : forall A B C X, Col A B X -> Perp A B C X -> Perp_at X A B C X.

Lemma l8_15_2 : forall A B C X, Col A B X ->  Perp_at X A B C X -> Perp A B C X.

Lemma perp_in_per : forall A B C, Perp_at B A B B C-> Per A B C.

Lemma perp_sym : forall A B C D, Perp A B C D -> Perp C D A B.

Lemma perp_col0 : forall A B C D X Y, Perp A B C D -> X <> Y -> Col A B X -> Col A B Y -> Perp C D X Y.

Lemma per_perp_in : forall A B C, A <> B -> B <> C -> Per A B C -> Perp_at B A B B C.

Lemma per_perp : forall A B C, A <> B -> B <> C -> Per A B C -> Perp A B B C.

Lemma perp_left_comm : forall A B C D, Perp A B C D -> Perp B A C D.

Lemma perp_right_comm : forall A B C D, Perp A B C D -> Perp A B D C.

Lemma perp_comm : forall A B C D, Perp A B C D -> Perp B A D C.

Lemma perp_in_sym :
 forall A B C D X,
  Perp_at X A B C D -> Perp_at X C D A B.

Lemma perp_in_left_comm :
 forall A B C D X,
  Perp_at X A B C D -> Perp_at X B A C D.

Lemma perp_in_right_comm : forall A B C D X, Perp_at X A B C D -> Perp_at X A B D C.

Lemma perp_in_comm : forall A B C D X, Perp_at X A B C D -> Perp_at X B A D C.

End T8_3.

Hint Resolve perp_sym perp_left_comm perp_right_comm perp_comm per_perp_in per_perp
             perp_in_per perp_in_left_comm perp_in_right_comm perp_in_comm perp_in_sym : perp.

Ltac double A B A' :=
   assert (mp:= symmetric_point_construction A B);
   elim mp; intros A' ; intro; clear mp.

Section T8_4.

Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.

Lemma Perp_cases :
  forall A B C D,
  Perp A B C D \/ Perp B A C D \/ Perp A B D C \/ Perp B A D C \/
  Perp C D A B \/ Perp C D B A \/ Perp D C A B \/ Perp D C B A ->
  Perp A B C D.

Lemma Perp_perm :
  forall A B C D,
  Perp A B C D ->
  Perp A B C D /\ Perp B A C D /\ Perp A B D C /\ Perp B A D C /\
  Perp C D A B /\ Perp C D B A /\ Perp D C A B /\ Perp D C B A.

Lemma Perp_in_cases :
  forall X A B C D,
  Perp_at X A B C D \/ Perp_at X B A C D \/ Perp_at X A B D C \/ Perp_at X B A D C \/
  Perp_at X C D A B \/ Perp_at X C D B A \/ Perp_at X D C A B \/ Perp_at X D C B A ->
  Perp_at X A B C D.

Lemma Perp_in_perm :
  forall X A B C D,
  Perp_at X A B C D ->
  Perp_at X A B C D /\ Perp_at X B A C D /\ Perp_at X A B D C /\ Perp_at X B A D C /\
  Perp_at X C D A B /\ Perp_at X C D B A /\ Perp_at X D C A B /\ Perp_at X D C B A.

Lemma perp_in_col : forall A B C D X, Perp_at X A B C D -> Col A B X /\ Col C D X.

Lemma perp_perp_in : forall A B C, Perp A B C A -> Perp_at A A B C A.

Lemma perp_per_1 : forall A B C, Perp A B C A -> Per B A C.

Lemma perp_per_2 : forall A B C, Perp A B A C -> Per B A C.

Lemma perp_col : forall A B C D E, A<>E -> Perp A B C D -> Col A B E -> Perp A E C D.

Lemma perp_col2 : forall A B C D  X Y,
  Perp A B X Y ->
  C <> D -> Col A B C -> Col A B D -> Perp C D X Y.

Lemma perp_not_eq_1 : forall A B C D, Perp A B C D -> A<>B.

Lemma perp_not_eq_2 : forall A B C D, Perp A B C D -> C<>D.

Lemma diff_per_diff : forall A B P R ,
      A <> B -> Cong A P B R -> Per B A P -> Per A B R -> P <> R.

Lemma per_not_colp : forall A B P R, A <> B -> A <> P -> B <> R -> Per B A P -> Per A B R -> ~Col P A R.

Lemma per_not_col : forall A B C, A <> B -> B <> C -> Per A B C -> ~Col A B C.

Lemma perp_not_col2 : forall A B C D, Perp A B C D -> ~ Col A B C \/ ~ Col A B D.

Lemma perp_not_col : forall A B P, Perp A B P A -> ~ Col A B P.

Lemma perp_in_col_perp_in : forall A B C D E P, C <> E -> Col C D E -> Perp_at P A B C D -> Perp_at P A B C E.

Lemma perp_col2_bis : forall A B C D P Q,
  Perp A B P Q ->
  Col C D P ->
  Col C D Q ->
  C <> D ->
  Perp A B C D.

Lemma perp_in_perp_bis : forall A B C D X,
 Perp_at X A B C D -> Perp X B C D \/ Perp A X C D.

Lemma col_per_perp : forall A B C D,
 A <> B -> B <> C -> D <> B -> D <> C ->
 Col B C D -> Per A B C -> Perp C D A B.

Lemma per_cong_mid : forall A B C H,
 B <> C -> Bet A B C -> Cong A H C H -> Per H B C ->
 Midpoint B A C.

Lemma per_double_cong : forall A B C C',
 Per A B C -> Midpoint B C C' -> Cong A C A C'.

Lemma cong_perp_or_mid : forall A B M X, A <> B -> Midpoint M A B -> Cong A X B X ->
 X = M \/ ~Col A B X /\ Perp_at M X M A B.

Lemma col_per2_cases : forall A B C D B', 
 B <> C -> B' <> C -> C <> D -> Col B C D -> Per A B C -> Per A B' C -> 
 B = B' \/ ~Col B' C D.

Lemma l8_16_1 : forall A B C U X,
  Col A B X -> Col A B U -> Perp A B C X -> ~ Col A B C /\ Per C X U.

Lemma l8_16_2 : forall A B C U X,
  Col A B X -> Col A B U -> U<>X -> ~ Col A B C -> Per C X U -> Perp A B C X.

Lemma l8_18_uniqueness : forall A B C X Y,
  ~ Col A B C -> Col A B X -> Perp A B C X -> Col A B Y -> Perp A B C Y -> X=Y.

Lemma midpoint_distinct : forall A B X C C', ~ Col A B C -> Col A B X -> Midpoint X C C' -> C <> C'.

Lemma l8_20_1 : forall A B C C' D P,
  Per A B C -> Midpoint P C' D -> Midpoint A C' C -> Midpoint B D C -> Per B A P.

Lemma l8_20_2 : forall A B C C' D P,
  Per A B C -> Midpoint P C' D -> Midpoint A C' C -> Midpoint B D C -> B<>C -> A<>P.

Lemma perp_col1 : forall A B C D X,
 C <> X -> Perp A B C D -> Col C D X -> Perp A B C X.

Lemma l8_18_existence : forall A B C, ~ Col A B C -> exists X, Col A B X /\ Perp A B C X.

Lemma l8_21_aux : forall A B C,
 ~ Col A B C -> exists P, exists T, Perp A B P A /\ Col A B T /\ Bet C T P.

Lemma l8_21 : forall A B C,
 A <> B -> exists P, exists T, Perp A B P A /\ Col A B T /\ Bet C T P.

Lemma per_cong : forall A B P R X ,
 A <> B -> A <> P ->
 Per B A P -> Per A B R ->
 Cong A P B R -> Col A B X -> Bet P X R ->
 Cong A R P B.

Lemma perp_cong : forall A B P R X,
 A <> B -> A <> P ->
 Perp A B P A -> Perp A B R B ->
 Cong A P B R -> Col A B X -> Bet P X R ->
 Cong A R P B.

Lemma perp_exists : forall O A B, A <> B -> exists X, Perp O X A B.

Lemma perp_vector : forall A B, A <> B -> (exists X, exists Y, Perp A B X Y).

Lemma midpoint_existence_aux : forall A B P Q T,
  A<>B -> Perp A B Q B -> Perp A B P A ->
  Col A B T -> Bet Q T P -> Le A P B Q ->
  exists X : Tpoint, Midpoint X A B.

Lemma midpoint_existence : forall A B, exists X, Midpoint X A B.

Lemma perp_in_id : forall A B C X, Perp_at X A B C A -> X = A.

Lemma l8_22 : forall A B P R X ,
 A <> B -> A <> P ->
 Per B A P -> Per A B R ->
 Cong A P B R -> Col A B X -> Bet P X R ->
 Cong A R P B /\ Midpoint X A B /\ Midpoint X P R.

Lemma l8_22_bis : forall A B P R X,
 A <> B -> A <> P ->
 Perp A B P A -> Perp A B R B ->
 Cong A P B R -> Col A B X -> Bet P X R ->
 Cong A R P B /\ Midpoint X A B /\ Midpoint X P R.

Lemma perp_in_perp : forall A B C D X, Perp_at X A B C D -> Perp A B C D.

End T8_4.

Hint Resolve perp_per_1 perp_per_2 perp_col perp_perp_in perp_in_perp : perp.

Section T8_5.

Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.

Lemma perp_proj : forall A B C D, Perp A B C D -> ~Col A C D -> exists X, Col A B X /\ Perp A X C D.

Lemma l8_24 : forall A B P Q R T,
 Perp P A A B ->
 Perp Q B A B ->
 Col A B T ->
 Bet P T Q ->
 Bet B R Q ->
 Cong A P B R ->
 exists X, Midpoint X A B /\ Midpoint X P R.

Lemma col_per2__per : forall A B C P X, A <> B -> Col A B C -> Per A X P -> Per B X P -> Per C X P.

Lemma perp_in_per_1 :
 forall A B C D X,
  Perp_at X A B C D ->
  Per A X C.

Lemma perp_in_per_2 :
 forall A B C D X,
  Perp_at X A B C D ->
  Per A X D.

Lemma perp_in_per_3 :
 forall A B C D X,
  Perp_at X A B C D ->
  Per B X C.

Lemma perp_in_per_4 :
 forall A B C D X,
  Perp_at X A B C D ->
  Per B X D.

End T8_5.

Hint Resolve perp_in_per_1 perp_in_per_2 perp_in_per_3 perp_in_per_4 : perp.

Ltac midpoint M A B :=
 let T:= fresh in assert (T:= midpoint_existence A B);
 ex_and T M.

Tactic Notation "Name" ident(M) "the" "midpoint" "of" ident(A) "and" ident(B) :=
 midpoint M A B. *)



Section Line_extension.



Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.



Lemma line_extension_symmetry : forall {Tm : Tarski_neutral_dimensionless}

  (f : @Tpoint Tn -> @Tpoint Tm) P Q, line_extension f P Q -> line_extension f Q P.

Proof.

  intros Tm f P Q [HPQ [fInj [fBet fCong]]].

  repeat split; auto; intro; intros; [apply fInj|apply fBet|apply fCong]; Col.

Qed.



Lemma line_extension_stability : forall {Tm: Tarski_neutral_dimensionless}

  (f : @Tpoint Tn -> @Tpoint Tm) P Q R,

  Col P Q R -> P <> R -> line_extension f P Q -> line_extension f P R.

Proof.

  intros Tm f P Q R HCol HPR [HPQ [fInj [fBet fCong]]].

  repeat split; auto; intro; intros;

    [apply fInj|apply fBet|apply fCong]; trivial; apply col_transitivity_1 with R; Col.

Qed.



Lemma line_extension_reverse_bet : forall {Tm: Tarski_neutral_dimensionless}

  {Tm2: Tarski_neutral_dimensionless_with_decidable_point_equality Tm}

  (f : @Tpoint Tn -> @Tpoint Tm) P Q, line_extension f P Q ->

  forall A B C, Col P Q A -> Col P Q B -> Col P Q C -> Bet (f A) (f B) (f C) -> Bet A B C.

Proof.

  intros Tm Tm2 f P Q [HPQ [fInj [fBet fCong]]] A B C HA HB HC HBet.

  destruct (eq_dec_points (f A) (f B)) as [Heq|Hdiff].

    apply fInj in Heq; subst; Between.

  assert (A <> B) by (intro; subst; auto).

  destruct (segment_construction A B B C) as [D [HD1 HD2]].

  assert (C = D); [|subst; auto].

  assert (Col P Q D) by (apply (colx A B); Col).

  apply fInj; trivial.

  apply between_cong_3 with (f A) (f B); Cong.

Qed.



Lemma pres_bet_line__col : forall {Tm: Tarski_neutral_dimensionless}

  f (P Q : @Tpoint Tn), P <> Q -> pres_bet_line f P Q ->

  forall A B C, Col P Q A -> Col P Q B -> Col P Q C -> Col (f A) (f B) (f C).

Proof.

  intros Tm f P Q HPQ fBet A B C HA HB HC.

  destruct (col3 P Q A B C) as [HBet|[HBet|HBet]]; trivial; apply fBet in HBet; Col.

Qed.



End Line_extension.



Section Completeness.



Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.



Lemma extension_grad : forall {Tm: Tarski_neutral_dimensionless}

  {Tm2 : Tarski_neutral_dimensionless_with_decidable_point_equality Tm}

  P Q (f : @Tpoint Tn -> @Tpoint Tm),

  line_extension f P Q ->

  forall A B X, Col P Q A -> Col P Q B -> Grad (f A) (f B) X ->

  exists C, Col P Q C /\ Grad A B C /\ f C = X.

Proof.

  intros Tm Tm2 P Q f [HPQ [fInj [fBet fCong]]] A B X HA HB HGrad.

  destruct (eq_dec_points A B).

  { subst B.

    apply grad112__eq in HGrad; subst X.

    exists A; repeat split; [assumption|constructor].

  }

  remember (f A) as A0.

  remember (f B) as B0.

  induction HGrad.

    exists B; repeat split; auto; constructor.

  rename C into X, C' into X'.

  destruct IHHGrad as [C [HC1 [HC2 HC3]]]; trivial.

  assert (A0 <> X).

  { intro; subst X.

    assert (A = C) by (apply fInj; auto; congruence).

    subst.

    apply grad121__eq in HGrad.

    apply fInj in HGrad; auto.

  }

  destruct (segment_construction A C A B) as [C' [HC'1 HC'2]].

  exists C'.

  assert (Col P Q C').

    apply (colx A C); Col; apply grad_neq__neq13 with B; auto.

  repeat split; trivial.

    apply grad_stab with C; Cong.

  apply (construction_uniqueness A0 X A0 B0); Cong; subst; auto.

Qed.



Lemma extension_gradexp : forall {Tm: Tarski_neutral_dimensionless}

  {Tm2 : Tarski_neutral_dimensionless_with_decidable_point_equality Tm}

  P Q (f : @Tpoint Tn -> @Tpoint Tm),

  line_extension f P Q ->

  forall A B X, Col P Q A -> Col P Q B -> GradExp (f A) X (f B) ->

  exists C, Col P Q C /\ GradExp A C B /\ f C = X.

Proof.

  intros Tm Tm2 P Q f [HPQ [fInj [fBet fCong]]] A B X HA HB.

  remember (f A) as A'.

  remember (f B) as B'.

  rewrite gradexp__gradexpinv.

  induction 1.

    exists B; repeat split; auto; constructor.

  destruct IHGradExpInv as [C' [HCol []]]; auto.

  destruct (midpoint_existence A C') as [M []].

  assert (Col P Q M).

  { destruct (eq_dec_points A C').

      treat_equalities; assumption.

    apply colx with A C'; Col.

  }

  exists M; repeat split; trivial.

    rewrite gradexp__gradexpinv.

    apply gradexpinv_stab with C'; trivial.

    rewrite <- gradexp__gradexpinv; assumption.

  apply l7_17 with A0 B0; split; trivial; subst; [apply fBet|apply fCong]; assumption.

Qed.



Lemma extension_image_density_aux : forall {Tm: Tarski_neutral_dimensionless}

  {Tm2 : Tarski_neutral_dimensionless_with_decidable_point_equality Tm}

  P Q (f : @Tpoint Tn -> @Tpoint Tm),

  @archimedes_axiom Tm ->

  line_extension f P Q ->

  forall A B, A <> B ->

  Lt (f P) (f Q) A B -> Bet (f P) (f Q) A -> Bet (f P) A B ->

  exists X, Col P Q X /\ Bet A (f X) B /\ f X <> A /\ f X <> B.

Proof.

  intros Tm Tm2 P Q f archi fLineExt A B HAB HLt HBet1 HBet2.

  cut (exists C, Grad (f P) (f Q) C /\ Bet A C B /\ C <> A /\ C <> B).

    intros [C [HC1 [HC2 [HC3 HC4]]]].

    destruct (extension_grad P Q f fLineExt P Q C) as [X]; Col.

    exists X; spliter; subst; auto.

  assert (Hdiff : f P <> f Q).

    intro; destruct fLineExt as [HPQ [fInj]]; apply HPQ, fInj; Col.

  destruct (reach__grad_min (f P) (f Q) A) as [D [E [HD1 [HD2 [HE1 [HE2 [HDE1 HDE2]]]]]]]; auto.

  assert (Bet D A E) by (apply (between_exchange3 (f P)); assumption).

  assert (Le A E D E) by Le.

  exists E; repeat split; auto.

  - apply grad_stab with D; assumption.

  - apply l6_13_1.

    { destruct (eq_dec_points A D).

        subst D; apply l6_2 with (f P); Between; apply bet_neq12__neq with (f Q); assumption.

      apply l6_2 with D; Between.

        apply between_symmetry, (between_exchange3 (f P)); assumption.

    }

    apply le_transitivity with D E; trivial.

    apply le_transitivity with (f P) (f Q); Le.

  - intro; subst E.

    apply lt__nle in HLt.

    apply HLt, le_transitivity with D B; Le.

Qed.



Lemma extension_image_density_aux2 : forall {Tm: Tarski_neutral_dimensionless}

  {Tm2 : Tarski_neutral_dimensionless_with_decidable_point_equality Tm}

  P Q (f : @Tpoint Tn -> @Tpoint Tm),

  @archimedes_axiom Tm ->

  line_extension f P Q ->

  forall A B, A <> B -> Col (f P) (f Q) A -> Col (f P) (f Q) B ->

  Lt (f P) (f Q) A B -> Bet (f P) A B ->

  exists X, Col P Q X /\ Bet A (f X) B /\ f X <> A /\ f X <> B.

Proof.

  assert (Haux := line_extension_symmetry).

  intros Tm Tm2 P Q f archi fLineExt A B HAB HColA HColB HLt HBet.

  assert (Hf' := fLineExt); destruct Hf' as [HPQ [fInj [fBet fCong]]].

  destruct (eq_dec_points (f P) A).

  { treat_equalities.

    assert (f P <> f Q) by (intro; apply HPQ, fInj; Col).

    destruct (or_bet_out (f Q) (f P) B) as [HBet|[HOut|]]; [..|exfalso; Col].

    - destruct (segment_construction Q P P Q) as [Q' []].

      exists Q'.

      assert (HBet' : Bet (f Q) (f P) (f Q')) by (apply fBet; Col).

      assert (HCong' : Cong (f P) (f Q') (f P) (f Q)) by (apply fCong; Col).

      assert (f P <> f Q').

        intro; assert (P = Q') by (apply fInj; Col); assert_diffs; auto.

      repeat split; Col.

      * apply l6_13_1.

          apply l6_2 with (f Q); Between.

          apply le_transitivity with (f P) (f Q); Le.

      * intro; subst; destruct HLt; Cong.

    - exists Q; repeat split; Col.

        apply l6_13_1; Le.

        intro; subst; destruct HLt; Cong.

  }

  destruct HColA as [|[|]].

  - apply (extension_image_density_aux P Q); trivial.

  - destruct (eq_dec_points (f Q) A).

    { treat_equalities.

      destruct (segment_construction P Q P Q) as [Q' []].

      exists Q'.

      assert (HBet' : Bet (f P) (f Q) (f Q')) by (apply fBet; Col).

      assert (HCong' : Cong (f Q) (f Q') (f P) (f Q)) by (apply fCong; Col).

      assert (f Q <> f Q') by (assert_diffs; auto).

      assert (HLt2 : Lt (f Q) (f Q') (f Q) B) by (apply (cong2_lt__lt (f P) (f Q) (f Q) B); Cong).

      repeat split; Col.

        apply l6_13_1; Le; apply l6_2 with (f P); Between.

        intro; subst; destruct HLt2; Cong.

    }

    exists Q.

    assert (HLt2 : Lt A (f Q) A B) by (apply le1234_lt__lt with (f P) (f Q); Le).

    repeat split; Col.

      apply l6_13_1; Le; apply l6_2 with (f P); Between.

      intro; subst; destruct HLt2; Cong.

  - apply line_extension_symmetry in fLineExt.

    destruct (extension_image_density_aux Q P f archi fLineExt A B) as [X]; Between.

      apply lt_left_comm, HLt.

      apply outer_transitivity_between2 with (f P); Between.

    spliter; exists X; repeat split; Col.

Qed.



Lemma extension_image_density : forall {Tm: Tarski_neutral_dimensionless}

  {Tm2 : Tarski_neutral_dimensionless_with_decidable_point_equality Tm}

  P Q (f : @Tpoint Tn -> @Tpoint Tm),

  @archimedes_axiom Tm ->

  line_extension f P Q ->

  forall A B, Col (f P) (f Q) A -> Col (f P) (f Q) B -> A <> B ->

  exists X, Col P Q X /\ Bet A (f X) B /\ f X <> A /\ f X <> B.

Proof.

  intros Tm Tm2 P Q f archi fLineExt A B HA HB HAB.

  assert (Hf' := fLineExt); destruct Hf' as [HPQ [fInj [fBet fCong]]].

  assert (f P <> f Q).

    intro; apply HPQ, fInj; Col.

  destruct (reach__ex_gradexp_lt (f P) (f Q) A B) as [fQ' [HGrad' HLt]]; auto.

  destruct (extension_gradexp P Q f fLineExt P Q fQ') as [Q' [HCol [HGrad]]]; Col.

  subst fQ'.

  apply gradexp__grad in HGrad; apply gradexp__grad in HGrad'.

  assert (HPQ' : P <> Q').

    intro; subst; apply grad112__eq in HGrad; auto.

  assert (fLineExt' : line_extension f P Q').

    apply line_extension_stability with Q; auto.

  assert (HCols : Col (f P) (f Q') A /\ Col (f P) (f Q') B /\ Col (f P) A B).

    split; [|split]; apply col_transitivity_1 with (f Q); Col.

  destruct HCols as [HA' [HB' Hdij]].

  assert (HColX : forall X, Col P Q' X -> Col P Q X).

    intros; apply col_transitivity_1 with Q'; Col.

  assert (HH : Bet (f P) A B -> exists X, Col P Q X /\ Bet A (f X) B /\ f X <> A /\ f X <> B).

  { intro HBet.

    destruct (extension_image_density_aux2 P Q' f archi fLineExt' A B) as [X]; auto.

    exists X; spliter; repeat split; auto.

  }

  assert (HH' : Bet (f P) B A -> exists X, Col P Q X /\ Bet A (f X) B /\ f X <> A /\ f X <> B).

  { intro HBet.

    destruct (extension_image_density_aux2 P Q' f archi fLineExt' B A) as [X [HX1 [HX2 []]]]; auto.

      apply lt_right_comm, HLt.

    exists X; repeat split; Between.

  }

  destruct Hdij as [|[|]].

    apply HH; trivial.

    apply HH'; Between.

  destruct (eq_dec_points (f P) A).

    subst; apply HH; Between.

  destruct (eq_dec_points (f P) B).

    subst; apply HH'; Between.

  exists P; repeat split; finish.

Qed.



Lemma dedekind__completeness : dedekind_s_axiom -> line_completeness.

Proof.

  intros dedekind Tm Tm2 P Q f archi fLineExt A HA.

  destruct (eq_dec_points (f P) A).

    subst; exists P; split; Col.

  destruct (dedekind (fun X => Col P Q X /\ Bet (f P) (f X) A)

    (fun X => Col P Q X /\ Bet (f P) A (f X))) as [B HB].

  { exists P.

    intros X Y [] [].

    apply (line_extension_reverse_bet f P Q); Col.

    eBetween.

  }

  exists B.

  assert (HR : exists R, Col P Q R /\ Bet (f P) A (f R)).

  { destruct (segment_construction (f P) A (f P) A) as [A' []].

    assert_diffs.

    destruct (extension_image_density P Q f archi fLineExt A A') as [R [HR1 [HR2 []]]]; Col.

      apply col_transitivity_1 with A; Col.

    exists R; split; eBetween.

  }

  destruct HR as [R []].

  assert (HBet : Bet P B R).

    apply HB; split; finish; eBetween.

  assert (Col P Q B).

    apply col_transitivity_1 with R; Col; intro; treat_equalities; auto.

  destruct (eq_dec_points (f B) A); [split; assumption|].

  exfalso.

  assert (Hf := fLineExt).

  destruct Hf as [HPQ [finj [fBet fCong]]].

  destruct (extension_image_density P Q f archi fLineExt A (f B)) as [X [HX1 [HX2 [HX3 Habs]]]]; auto.

    apply (pres_bet_line__col f P Q); Col.

  destruct (l5_3 (f P) A (f B) (f R)); auto; [apply fBet; Col|apply Habs..].

  - apply between_equality with (f P).

      apply between_symmetry, fBet, HB; try split; Col; Between.

      apply between_inner_transitivity with (f B); assumption.

    clear dependent R; eBetween.

  - apply between_equality with (f P).

      clear dependent R; eBetween.

    apply between_exchange3 with (f R).

      apply between_symmetry, fBet; Col; apply HB; split; Col; eBetween.

    apply bet3__bet with A (f B); finish.

Qed.



End Completeness.
