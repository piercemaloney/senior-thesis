Require Import GeoCoq.Axioms.continuity_axioms.
(* GeoCoq.Axioms.continuity_axioms:
Require Import GeoCoq.Tarski_dev.Definitions.

Section Continuity_Defs.

Context `{Tn:Tarski_neutral_dimensionless}.

Definition segment_circle := forall A B P Q,
  InCircle P A B ->
  OutCircle Q A B ->
  exists Z, Bet P Z Q /\ OnCircle Z A B.

Definition one_point_line_circle := forall A B U V P,
  Col U V P -> U <> V -> Bet A P B ->
  exists Z, Col U V Z /\ OnCircle Z A B.

Definition two_points_line_circle := forall A B U V P,
  Col U V P -> U <> V -> Bet A P B ->
  exists Z1 Z2, Col U V Z1 /\ OnCircle Z1 A B /\
                Col U V Z2 /\ OnCircle Z2 A B /\
                Bet Z1 P Z2 /\ (P <> B -> Z1 <> Z2).

Definition circle_circle := forall A B C D P Q,
  OnCircle P C D ->
  OnCircle Q C D ->
  InCircle P A B ->
  OutCircle Q A B ->
  exists Z, OnCircle Z A B /\ OnCircle Z C D.

Definition circle_circle_bis := forall A B C D P Q,
  OnCircle P C D ->
  InCircle P A B ->
  OnCircle Q A B ->
  InCircle Q C D ->
  exists Z, OnCircle Z A B /\ OnCircle Z C D.

Definition circle_circle_axiom := forall A B C D B' D',
  Cong A B' A B -> Cong C D' C D ->
  Bet A D' B -> Bet C B' D ->
  exists Z, Cong A Z A B /\ Cong C Z C D.

Definition circle_circle_two := forall A B C D P Q,
  OnCircle P C D ->
  OnCircle Q C D ->
  InCircle P A B ->
  OutCircle Q A B ->
  exists Z1 Z2,
    OnCircle Z1 A B /\ OnCircle Z1 C D /\
    OnCircle Z2 A B /\ OnCircle Z2 C D /\
    (InCircleS P A B -> OutCircleS Q A B -> Z1<>Z2).

Definition euclid_s_prop_1_22 := forall A B C D E F A' B' C' D' E' F',
  SumS A B C D E' F' -> SumS A B E F C' D' -> SumS C D E F A' B' ->
  Le E F E' F' -> Le C D C' D' -> Le A B A' B' ->
  exists P Q R, Cong P Q A B /\ Cong P R C D /\ Cong Q R E F.

Definition Nested (A B:nat -> Tpoint -> Prop) :=
  (forall n, exists An, A n An) /\ (forall n, exists Bn, B n Bn) /\
  forall n An Am Bm Bn,
    A n An -> A (S n) Am -> B (S n) Bm -> B n Bn -> Bet An Am Bm /\ Bet Am Bm Bn /\ Am <> Bm.

Definition cantor_s_axiom := forall A B, Nested A B ->
  exists X, forall n An Bn, A n An -> B n Bn -> Bet An X Bn.

Definition dedekind_s_axiom := forall (Alpha Beta : Tpoint -> Prop),
  (exists A, forall X Y, Alpha X -> Beta Y -> Bet A X Y) ->
  (exists B, forall X Y, Alpha X -> Beta Y -> Bet X B Y).

Inductive FOF : Prop -> Prop :=
| eq_fof : forall A B:Tpoint, FOF (A = B)
| bet_fof : forall A B C, FOF (Bet A B C)
| cong_fof : forall A B C D, FOF (Cong A B C D)
| not_fof : forall P, FOF P -> FOF (~ P)
| and_fof : forall P Q, FOF P -> FOF Q -> FOF (P /\ Q)
| or_fof : forall P Q, FOF P -> FOF Q -> FOF (P \/ Q)
| implies_fof : forall P Q, FOF P -> FOF Q -> FOF (P -> Q)
| forall_fof : forall P, (forall (A:Tpoint), FOF (P A)) -> FOF (forall A, P A)
| exists_fof : forall P, (forall (A:Tpoint), FOF (P A)) -> FOF (exists A, P A).

Definition first_order_dedekind := forall Alpha Beta,
  (forall X, FOF (Alpha X)) -> (forall Y, FOF (Beta Y)) ->
  (exists A, forall X Y, Alpha X -> Beta Y -> Bet A X Y) ->
  (exists B, forall X Y, Alpha X -> Beta Y -> Bet X B Y).

Definition archimedes_axiom := forall A B C D, A <> B -> Reach A B C D.

Definition aristotle_s_axiom := forall P Q A B C,
  ~ Col A B C -> Acute A B C ->
  exists X Y, Out B A X /\ Out B C Y /\ Per B X Y /\ Lt P Q X Y.

Definition greenberg_s_axiom := forall P Q R A B C,
  ~ Col A B C ->
  Acute A B C -> Q <> R -> Per P Q R ->
  exists S, LtA P S Q A B C /\ Out Q S R.

End Continuity_Defs.

Section Completeness.

Context `{Tn:Tarski_neutral_dimensionless}.

Definition inj {T1 T2:Type} (f:T1->T2) := forall A B, f A = f B -> A = B.

Definition pres_bet {Tm: Tarski_neutral_dimensionless}
  (f : @Tpoint Tn -> @Tpoint Tm) := forall A B C, Bet A B C -> Bet (f A) (f B) (f C).

Definition pres_cong {Tm: Tarski_neutral_dimensionless}
  (f : @Tpoint Tn -> @Tpoint Tm) := forall A B C D, Cong A B C D -> Cong (f A) (f B) (f C) (f D).

Definition extension {Tm: Tarski_neutral_dimensionless} f := inj f /\ pres_bet f /\ pres_cong f.

Definition completeness_for_planes := forall (Tm: Tarski_neutral_dimensionless)
  (Tm2 : Tarski_neutral_dimensionless_with_decidable_point_equality Tm)
  (M : Tarski_2D Tm2)
  (f : @Tpoint Tn -> @Tpoint Tm),
  @archimedes_axiom Tm ->
  extension f ->
  forall A, exists B, f B = A.

Definition completeness_for_3d_spaces := forall (Tm: Tarski_neutral_dimensionless)
  (Tm2 : Tarski_neutral_dimensionless_with_decidable_point_equality Tm)
  (M : Tarski_3D Tm2)
  (f : @Tpoint Tn -> @Tpoint Tm),
  @archimedes_axiom Tm ->
  extension f ->
  forall A, exists B, f B = A.

Definition inj_line {T:Type} (f:Tpoint->T) P Q := forall A B, Col P Q A -> Col P Q B ->
  f A = f B -> A = B.

Definition pres_bet_line {Tm: Tarski_neutral_dimensionless}
  (f : @Tpoint Tn -> @Tpoint Tm) P Q := forall A B C, Col P Q A -> Col P Q B -> Col P Q C ->
  Bet A B C -> Bet (f A) (f B) (f C).

Definition pres_cong_line {Tm: Tarski_neutral_dimensionless}
  (f : @Tpoint Tn -> @Tpoint Tm) P Q := forall A B C D,
  Col P Q A -> Col P Q B -> Col P Q C -> Col P Q D ->
  Cong A B C D -> Cong (f A) (f B) (f C) (f D).

Definition line_extension {Tm: Tarski_neutral_dimensionless} f P Q :=
  P <> Q /\ inj_line f P Q /\ pres_bet_line f P Q /\ pres_cong_line f P Q.

Definition line_completeness := forall (Tm: Tarski_neutral_dimensionless)
  (Tm2 : Tarski_neutral_dimensionless_with_decidable_point_equality Tm)
  P Q
  (f : @Tpoint Tn -> @Tpoint Tm),
  @archimedes_axiom Tm ->
  line_extension f P Q ->
  forall A, Col (f P) (f Q) A -> exists B, Col P Q B /\ f B = A.

End Completeness. *)

Require Import GeoCoq.Tarski_dev.Annexes.circles.
(* GeoCoq.Tarski_dev.Annexes.circles:
Require Export GeoCoq.Tarski_dev.Ch12_parallel.

Section Circle.

Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.

Lemma inc112 : forall A B,
 InCircle A A B.

Lemma onc212 : forall A B,
 OnCircle B A B.

Lemma onc_sym : forall A B P, OnCircle P A B -> OnCircle B A P.

Lemma ninc__outcs : forall X O P, ~ InCircle X O P -> OutCircleS X O P.

Lemma inc__outc : forall A B P, InCircle P A B <-> OutCircle B A P.

Lemma incs__outcs : forall A B P, InCircleS P A B <-> OutCircleS B A P.

Lemma onc__inc : forall A B P, OnCircle P A B -> InCircle P A B.

Lemma onc__outc : forall A B P, OnCircle P A B -> OutCircle P A B.

Lemma inc_outc__onc : forall A B P, InCircle P A B -> OutCircle P A B -> OnCircle P A B.

Lemma incs__inc : forall A B P, InCircleS P A B -> InCircle P A B.

Lemma outcs__outc : forall A B P, OutCircleS P A B -> OutCircle P A B.

Lemma incs__noutc : forall A B P, InCircleS P A B <-> ~ OutCircle P A B.

Lemma outcs__ninc : forall A B P, OutCircleS P A B <-> ~ InCircle P A B.

Lemma inc__noutcs : forall A B P, InCircle P A B <-> ~ OutCircleS P A B.

Lemma outc__nincs : forall A B P, OutCircle P A B <-> ~ InCircleS P A B.

Lemma inc_eq : forall A P, InCircle P A A -> A = P.

Lemma outc_eq : forall A B, OutCircle A A B -> A = B.

Lemma onc2__cong : forall O P A B, OnCircle A O P -> OnCircle B O P -> Cong O A O B.

End Circle.

Hint Resolve inc112 onc212 onc_sym inc__outc onc__inc onc__outc
             inc_outc__onc incs__inc outcs__outc : circle.

Ltac Circle := auto with circle.

Ltac treat_equalities :=
try treat_equalities_aux;
repeat
  match goal with
   | H:(Cong ?X3 ?X3 ?X1 ?X2) |- _ =>
      apply cong_symmetry in H; apply cong_identity in H;
      smart_subst X2;clean_reap_hyps
   | H:(Cong ?X1 ?X2 ?X3 ?X3) |- _ =>
      apply cong_identity in H;smart_subst X2;clean_reap_hyps
   | H:(Bet ?X1 ?X2 ?X1) |- _ =>
      apply  between_identity in H;smart_subst X2;clean_reap_hyps
   | H:(Midpoint ?X ?Y ?Y) |- _ => apply l7_3 in H; smart_subst Y;clean_reap_hyps
   | H : Bet ?A ?B ?C, H2 : Bet ?B ?A ?C |- _ =>
     let T := fresh in not_exist_hyp (A=B); assert (T : A=B) by (apply (between_equality A B C); finish);
                       smart_subst A;clean_reap_hyps
   | H : Bet ?A ?B ?C, H2 : Bet ?A ?C ?B |- _ =>
     let T := fresh in not_exist_hyp (B=C); assert (T : B=C) by (apply (between_equality_2 A B C); finish);
                       smart_subst B;clean_reap_hyps
   | H : Bet ?A ?B ?C, H2 : Bet ?C ?A ?B |- _ =>
     let T := fresh in not_exist_hyp (A=B); assert (T : A=B) by (apply (between_equality A B C); finish);
                       smart_subst A;clean_reap_hyps
   | H : Bet ?A ?B ?C, H2 : Bet ?B ?C ?A |- _ =>
     let T := fresh in not_exist_hyp (B=C); assert (T : B=C) by (apply (between_equality_2 A B C); finish);
                       smart_subst A;clean_reap_hyps
   | H:(Le ?X1 ?X2 ?X3 ?X3) |- _ =>
      apply le_zero in H;smart_subst X2;clean_reap_hyps
   | H : Midpoint ?P ?A ?P1, H2 : Midpoint ?P ?A ?P2 |- _ =>
     let T := fresh in not_exist_hyp (P1=P2);
                      assert (T := symmetric_point_uniqueness A P P1 P2 H H2);
                      smart_subst P1;clean_reap_hyps
   | H : Midpoint ?A ?P ?X, H2 : Midpoint ?A ?Q ?X |- _ =>
     let T := fresh in not_exist_hyp (P=Q); assert (T := l7_9 P Q A X H H2);
                       smart_subst P;clean_reap_hyps
   | H : Midpoint ?A ?P ?X, H2 : Midpoint ?A ?X ?Q |- _ =>
     let T := fresh in not_exist_hyp (P=Q); assert (T := l7_9_bis P Q A X H H2);
                       smart_subst P;clean_reap_hyps
   | H : Midpoint ?M ?A ?A |- _ =>
     let T := fresh in not_exist_hyp (M=A); assert (T : l7_3 M A H);
                       smart_subst M;clean_reap_hyps
   | H : Midpoint ?A ?P ?P', H2 : Midpoint ?B ?P ?P' |- _ =>
     let T := fresh in not_exist_hyp (A=B); assert (T := l7_17 P P' A B H H2);
                       smart_subst A;clean_reap_hyps
   | H : Midpoint ?A ?P ?P', H2 : Midpoint ?B ?P' ?P |- _ =>
     let T := fresh in not_exist_hyp (A=B); assert (T := l7_17_bis P P' A B H H2);
                       smart_subst A;clean_reap_hyps
   | H : Midpoint ?A ?B ?A |- _ =>
     let T := fresh in not_exist_hyp (A=B); assert (T := is_midpoint_id_2 A B H);
                       smart_subst A;clean_reap_hyps
   | H : Midpoint ?A ?A ?B |- _ =>
     let T := fresh in not_exist_hyp (A=B); assert (T := is_midpoint_id A B H);
                       smart_subst A;clean_reap_hyps
   | H : OnCircle ?A ?A ?B |- _ =>
      apply cong_reverse_identity in H;smart_subst B;clean_reap_hyps
   | H : OnCircle ?B ?A ?A |- _ =>
      apply cong_identity in H;smart_subst B;clean_reap_hyps
   | H : InCircle ?B ?A ?A |- _ =>
      apply le_zero in H;smart_subst B;clean_reap_hyps
   | H : OutCircle ?A ?A ?B |- _ =>
      apply le_zero in H;smart_subst B;clean_reap_hyps
end.

Section Circle_2.

Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.

Lemma bet_inc2__incs : forall O P U V X,
 X <> U -> X <> V -> Bet U X V ->
 InCircle U O P -> InCircle V O P ->
 InCircleS X O P.

Lemma bet_incs2__incs : forall O P U V X,
 Bet U X V -> InCircleS U O P -> InCircleS V O P ->
 InCircleS X O P.

Lemma bet_inc2__inc : forall A B U V P, InCircle U A B -> InCircle V A B -> Bet U P V ->
  InCircle P A B.

Lemma col_inc_onc2__bet : forall A B U V P, U <> V -> OnCircle U A B -> OnCircle V A B ->
  Col U V P -> InCircle P A B -> Bet U P V.

Lemma onc2_out__outcs : forall A B U V P, U <> V -> OnCircle U A B -> OnCircle V A B -> Out P U V ->
  OutCircleS P A B.

Lemma col_inc2_outcs__out : forall A B U V P, InCircle U A B -> InCircle V A B ->
  Col U V P -> OutCircleS P A B -> Out P U V.

Lemma col_onc2__mid : forall A B U V, U <> V -> OnCircle U A B -> OnCircle V A B ->
  Col U V A -> Midpoint A U V.

Lemma chord_completion : forall A B U P, OnCircle U A B -> InCircle P A B ->
  exists V, OnCircle V A B /\ Bet U P V.

Lemma outcs_exists : forall O P, exists Q, OutCircleS Q O P.

Lemma outcs_exists1 : forall O P X, X <> O -> exists Q, Out O X Q /\ OutCircleS Q O P.

Lemma incs_exists : forall O P, O <> P -> exists Q, InCircleS Q O P.

Lemma incs_exists1 : forall O P X, X <> O -> P <> O -> exists Q, Out O X Q /\ InCircleS Q O P.

Lemma onc_exists : forall O P X,  X <> O -> O <> P -> exists Q, OnCircle Q O P /\ Out O X Q.

Lemma diam_points : forall O P X, exists Q1 Q2,
  Bet Q1 O Q2 /\ Col Q1 Q2 X /\ OnCircle Q1 O P /\ OnCircle Q2 O P.

Lemma symmetric_oncircle : forall X Y O P, 
 Midpoint O X Y -> OnCircle X O P -> OnCircle Y O P.

Lemma mid_onc2__per : forall O P U V X,
 OnCircle U O P -> OnCircle V O P -> Midpoint X U V -> Per O X U.

Lemma mid_onc2__perp : forall O P A B X,
 O <> X -> A <> B -> OnCircle A O P -> OnCircle B O P -> Midpoint X A B -> Perp O X A B.

Lemma col_onc2_perp__mid : forall O P A B X,
 O<>X -> A<>B -> Col A B X -> OnCircle A O P -> OnCircle B O P -> Perp O X A B -> Midpoint X A B.

Lemma circle_circle_os : forall A B C D I P,
  OnCircle I A B -> OnCircle I C D -> ~ Col A C I -> ~ Col A C P ->
  exists Z, OnCircle Z A B /\ OnCircle Z C D /\ OS A C P Z.

Lemma circle_circle_cop : forall A B C D I P, OnCircle I A B -> OnCircle I C D ->
  exists Z, OnCircle Z A B /\ OnCircle Z C D /\ Coplanar A C P Z.

Lemma line_circle_two_points : forall O P U V W,
 U <> V -> Col U V W -> OnCircle U O P -> OnCircle V O P -> OnCircle W O P -> 
 W = U \/ W = V.

Lemma onc2_mid__incs : forall O P U V M, 
 U <> V -> OnCircle U O P -> OnCircle V O P -> Midpoint M U V ->
 InCircleS M O P.

Lemma circle_cases : forall O P X,
  OnCircle X O P \/ InCircleS X O P \/ OutCircleS X O P.

Lemma inc__radius : forall O P X, InCircle X O P ->
  exists Y, OnCircle Y O P /\ Bet O X Y.

Lemma onc_not_center : forall O P A, O <> P -> OnCircle A O P -> A <> O.

Lemma onc2_per__mid : forall O P U V M, U <> V -> M <> U ->
 OnCircle U O P -> OnCircle V O P -> Col M U V -> Per O M U -> Midpoint M U V .

Lemma cong_chord_cong_center : forall O P A B C D M N,
 OnCircle A O P ->
 OnCircle B O P ->
 OnCircle C O P ->
 OnCircle D O P ->
 Midpoint M A B ->
 Midpoint N C D ->
 Cong A B C D ->
 Cong O N O M.

Lemma cong_chord_cong_center1 : forall O P A B C D M N,
 A <> B -> C <> D -> M <> A -> N <> C ->
 OnCircle A O P ->
 OnCircle B O P ->
 OnCircle C O P ->
 OnCircle D O P ->
 Col M A B ->
 Col N C D ->
 Per O M A ->
 Per O N C ->
 Cong A B C D ->
 Cong O N O M.

Lemma onc_sym__onc : forall O P A B X Y, 
Bet O A B -> OnCircle A O P -> OnCircle B O P -> OnCircle X O P -> ReflectL X Y A B -> OnCircle Y O P.

Lemma mid_onc__diam : forall O P A B, OnCircle A O P -> Midpoint O A B -> Diam A B O P.

Lemma chord_le_diam : forall O P A B U V,
 Diam A B O P -> OnCircle U O P -> OnCircle V O P -> Le U V A B.

Lemma chord_lt_diam : forall O P A B U V, 
 ~ Col O U V -> Diam A B O P -> OnCircle U O P -> OnCircle V O P ->
 Lt U V A B.

Lemma inc2_le_diam: forall O P A B U V, Diam A B O P -> InCircle U O P -> InCircle V O P -> Le U V A B.

Lemma onc_col_diam__eq : forall O P A B X, Diam A B O P -> OnCircle X O P -> Col A B X -> X = A \/ X = B.

Lemma onc2_out__eq : forall O P A B, OnCircle A O P -> OnCircle B O P -> Out O A B -> A = B.

Lemma bet_onc_le_a : forall O P A B T X, Diam A B O P -> Bet B O T -> OnCircle X O P -> Le T A T X.

Lemma bet_onc_lt_a : forall O P A B T X,
 Diam A B O P -> O <> P -> O <> T -> X <> A -> Bet B O T  -> OnCircle X O P ->
 Lt T A T X.

Lemma bet_onc_le_b : forall O P A B T X,
 Diam A B O P -> Bet A O T -> OnCircle X O P ->
 Le T X T A.

Lemma bet_onc_lt_b : forall O P A B T X,
 Diam A B O P -> T <> O -> X <> A -> Bet A O T -> OnCircle X O P ->
 Lt T X T A.

Lemma incs2_lt_diam : forall O P A B U V, Diam A B O P -> InCircleS U O P -> InCircleS V O P -> Lt U V A B.

Lemma incs_onc_diam__lt : forall O P A B U V, Diam A B O P -> InCircleS U O P -> OnCircle V O P -> Lt U V A B.

Lemma diam_cong_incs__outcs : forall O P A B U V, Diam A B O P -> Cong A B U V -> InCircleS U O P -> OutCircleS V O P.

Lemma diam_uniqueness : forall O P A B X, Diam A B O P -> Cong A X A B -> OnCircle X O P -> X = B.

Lemma onc3__ncol : forall O P A B C,
 A <> B -> A <> C -> B <> C ->
 OnCircle A O P -> OnCircle B O P -> OnCircle C O P ->
 ~ Col A B C.

Lemma diam_exists : forall O P T, exists A, exists B, Diam A B O P /\ Col A B T.

Lemma chord_intersection : forall O P A B X Y,
  OnCircle A O P -> OnCircle B O P -> OnCircle X O P -> OnCircle Y O P -> TS A B X Y ->
  TS X Y A B.

Lemma ray_cut_chord : forall O P A B X Y,
  Diam A B O P -> OnCircle X O P -> OnCircle Y O P -> TS A B X Y -> OS X Y O A ->
  TS X Y O B.

Lemma center_col__diam : forall O P A B,
 A <> B -> Col O A B -> OnCircle A O P -> OnCircle B O P ->
 Diam A B O P.

Lemma diam__midpoint: forall O P A B, Diam A B O P -> Midpoint O A B.

Lemma diam_sym : forall O P A B, Diam A B O P -> Diam B A O P.

Lemma diam_end_uniqueness : forall O P A B C, Diam A B O P -> Diam A C O P -> B = C.

Lemma center_onc2_mid__ncol : forall O P A B M ,
 O <> P -> ~ Col O A B ->
 OnCircle A O P -> OnCircle B O P ->
 Midpoint M A B  -> ~ Col A O M.

Lemma bet_chord__diam_or_ncol : forall O P A B T,
  A <> B -> T <> A -> T <> B -> OnCircle A O P -> OnCircle B O P -> Bet A T B ->
  Diam A B O P \/ ~Col O A T /\ ~Col O B T.

Lemma mid_chord__diam_or_ncol : forall O P A B T,
 A <> B -> OnCircle A O P -> OnCircle B O P ->
 Midpoint T A B ->
 Diam A B O P \/ ~Col O A T /\ ~Col O B T.

Lemma cop_mid_onc2_perp__col : forall O P A B X Y, A <> B -> OnCircle A O P -> OnCircle B O P ->
  Midpoint X A B -> Perp X Y A B -> Coplanar O A B Y -> Col X Y O.

Lemma cong2_cop2_onc3__eq : forall O P X A B C, A <> B -> A <> C -> B <> C ->
  OnCircle A O P -> OnCircle B O P -> OnCircle C O P -> Coplanar A B C O ->
  Cong X A X B -> Cong X A X C -> Coplanar A B C X ->
  X = O.

Lemma tree_points_onc_cop : forall O P, O <> P -> exists A B C,
  A <> B /\ A <> C /\ B <> C /\ OnCircle A O P /\ OnCircle B O P /\ OnCircle C O P /\ Coplanar A B C O.

Lemma tree_points_onc_cop2 : forall O P Q, O <> P -> exists A B C,
  A <> B /\ A <> C /\ B <> C /\ OnCircle A O P /\ OnCircle B O P /\ OnCircle C O P /\
  Coplanar A B C O /\ Coplanar A B C Q.

Lemma tree_points_onc : forall O P, O <> P -> exists A B C,
  A <> B /\ A <> C /\ B <> C /\ OnCircle A O P /\ OnCircle B O P /\ OnCircle C O P.

Lemma bet_cop_onc2__ex_onc_os_out : forall O P A B C I,
  A <> I -> B <> I -> ~ Col A B C -> ~ Col A B O ->
  OnCircle A O P -> OnCircle B O P -> Bet A I B -> Coplanar A B C O ->
  exists C1, Out C1 O I /\ OnCircle C1 O P /\ OS A B C C1.

Lemma EqC_chara: forall A B C D, EqC A B C D <-> A = C /\ Cong A B C D.

Lemma nEqC_chara : forall A B C D, A <> B ->
  ~ EqC A B C D <->
  (exists X, OnCircle X A B /\ ~ OnCircle X C D).

Lemma EqC_sym : forall A B C D, EqC A B C D -> EqC C D A B.

End Circle_2.

Section Circle_2D.

Context `{T2D:Tarski_2D}.

Lemma mid_onc2_perp__col : forall O P A B X Y,
 A <> B -> OnCircle A O P -> OnCircle B O P -> Midpoint X A B -> Perp X Y A B -> Col X Y O.

Lemma mid2_onc4__eq : forall O P A B C D X, B <> C-> A <> B -> 
 OnCircle A O P ->
 OnCircle B O P ->
 OnCircle C O P ->
 OnCircle D O P ->
 Midpoint X A C ->
 Midpoint X B D ->
 X=O.

Lemma cong2_onc3__eq : forall O P X A B C, A <> B -> A <> C -> B <> C ->
  OnCircle A O P -> OnCircle B O P -> OnCircle C O P ->
  Cong X A X B -> Cong X A X C ->
  X = O.

Lemma onc2_mid_cong_col : forall O P U V M X,
 U <> V ->OnCircle U O P -> OnCircle V O P -> Midpoint M U V -> Cong U X V X -> Col O X M.

Lemma cong_onc3_cases : forall O P A X Y,
 Cong A X A Y ->
 OnCircle A O P -> OnCircle X O P -> OnCircle Y O P ->
 X = Y \/ ReflectL X Y O A.

Lemma bet_cong_onc3_cases : forall O P A X Y T,
 T <> O -> Bet A O T -> Cong T X T Y ->
 OnCircle A O P  -> OnCircle X O P  -> OnCircle Y O P ->
 X = Y \/ ReflectL X Y O A.

Lemma prop_7_8 : forall O P A B T X Y , Diam A B O P -> Bet A O T 
                               -> OnCircle X O P -> OnCircle Y O P
                               -> LeA A O X A O Y -> Le T Y T X.

Lemma Prop_7_8_uniqueness : forall O P A X Y Z T, T <> O -> X <> Y ->
  Bet A O T -> Cong T X T Y -> Cong T X T Z ->
  OnCircle A O P -> OnCircle X O P -> OnCircle Y O P -> OnCircle Z O P ->
  Z = X \/ Z = Y.

Lemma chords_midpoints_col_par : forall O P A M B C N D, 
 O <> P ->
 OnCircle A O P -> OnCircle B O P ->
 OnCircle C O P -> OnCircle D O P ->
 Midpoint M A B -> Midpoint N C D ->
 Col O M N -> ~ Col O A B -> ~ Col O C D -> Par A B C D.

Lemma onc3_mid2__ncol : forall O P A B C A' B',
 O <> P -> 
 OnCircle A O P -> OnCircle B O P -> OnCircle C O P ->
 Midpoint A' A C -> Midpoint B' B C -> ~ Col A B C ->
 ~ Col O A' B' \/ A' = O \/ B' = O.

Lemma onc4_cong2__eq: 
 forall A B C D O P X,
 A<>B -> C<>D ->
 ~ Par A B C D ->
 OnCircle A O P ->
 OnCircle B O P ->
 OnCircle C O P ->
 OnCircle D O P ->
 Cong A X B X ->
 Cong C X D X ->
 O=X.

End Circle_2D. *)



Section Dedekind_circle_circle.



Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.



Lemma circle_circle_aux : (forall A B C D P Q,

  OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B ->

  OS A C P Q \/ (Col P A C /\ ~ Col Q A C) \/ (~ Col P A C /\ Col Q A C ) ->

  exists Z : Tpoint, OnCircle Z A B /\ OnCircle Z C D) ->

  circle_circle.

Proof.

  intro Haux.

  cut (forall A B C D P Q,

  OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B ->

  Coplanar A C P Q -> (~ Col P A C \/ ~ Col Q A C) ->

  exists Z : Tpoint, OnCircle Z A B /\ OnCircle Z C D).

  - intros Haux' A B C D P Q HPOn HQOn HPIn HQOut.

    assert (HQ' : exists Q', OnCircle Q' C D /\ OutCircle Q' A B /\ Col Q' A C).

    { destruct (segment_construction A C C D) as [Q' []].

      exists Q'.

      repeat split; Col.

      apply le_transitivity with A Q; trivial.

      apply triangle_inequality with C; trivial.

      apply cong_transitivity with C D; Cong.

    }

    clear dependent Q.

    destruct HQ' as [Q [HQOn [HQOut HCol]]].

    destruct (cong_dec A P A B).

      exists P; split; trivial.

    destruct (cong_dec A B A Q).

      exists Q; Circle.

    assert (HPInS : InCircleS P A B) by (split; trivial).

    assert (HQOutS : OutCircleS Q A B) by (split; trivial).

    assert (A <> C).

    { intro; subst C.

      apply (not_and_lt A B A P); split; trivial.

      apply (cong2_lt__lt A B A Q); Cong.

      apply cong_transitivity with A D; Cong.

    }

    assert (C <> D).

      intro; treat_equalities; apply (not_and_lt A C A B); split; trivial.

    destruct (col_dec P A C); [|apply Haux' with P Q; Cop].

    destruct (exists_cong_per A C C D) as [R [HR1 HR2]].

    assert_diffs.

    apply per_not_col in HR1; auto.

    destruct (circle_cases A B R) as [HOn|HNOn].

      exists R; split; trivial.

    destruct HNOn; [apply Haux' with R Q|apply Haux' with P R]; Col; Cop.



  - intros A B C D P Q HPOn HQOn HPIn HQOut HCop HDij.

    destruct (col_dec P A C) as [HCol|HNCol].

    { destruct HDij.

        contradiction.

      apply Haux with P Q; auto.

    }

    destruct (col_dec Q A C).

      apply Haux with P Q; auto.

    destruct (cop__one_or_two_sides A C P Q); trivial; [|apply Haux with P Q; auto].

    destruct (l10_2_existence A C P) as [P' HP'].

    assert_diffs.

    apply Haux with P' Q; trivial.

      apply cong_transitivity with C P; trivial.

      apply cong_commutativity, (is_image_col_cong A C); Col.

      apply cong2_lt__lt with A P A B; Cong.

      apply cong_symmetry, cong_commutativity, (is_image_col_cong A C); Col.

    left.

    exists P; split; Side.

    apply l10_14; auto.

    intro; subst; apply HNCol, l10_8, HP'.

Qed.



Lemma fod__circle_circle : first_order_dedekind -> circle_circle.

Proof.

  intro dedekind.

  apply circle_circle_aux.

  intros A B C D P Q HPOn HQOn HPIn HQOut HDij.

  assert (A <> C).

  { intro; subst C.

    apply (not_and_lt A B A P); split; trivial.

    apply (cong2_lt__lt A B A Q); Cong.

    apply cong_transitivity with A D; Cong.

  }

  assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).

  assert (C <> D) by (intro; treat_equalities; auto).

  assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).

  { intros X Y; intros.

    destruct HDij as [HOS|[[HP HQ]|[HQ HP]]].

    - apply one_side_transitivity with P; [apply one_side_symmetry|]; apply l9_17 with Q; trivial.

    - apply one_side_transitivity with Q; [apply one_side_symmetry|];

      apply out_one_side_1 with P; Col; apply l6_6, bet_out; auto.

    - apply one_side_transitivity with P; [apply one_side_symmetry|];

      apply out_one_side_1 with Q; Col; apply l6_6, bet_out; Between.

  }

  assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).

  { intros X Y HX HY HTS.

    absurd (TS A C P Q).

    - destruct HDij as [HOS'|[[HCol HNCol]|[HNCol HCol]]]; [apply l9_9_bis; trivial|intro..].

        apply (two_sides_not_col A C P Q); Col.

        apply (two_sides_not_col A C Q P); Col; Side.

    - destruct (eq_dec_points P X); destruct (eq_dec_points Q Y); treat_equalities; trivial.

        apply bet_ts__ts with Y; trivial.

        apply l9_2, bet_ts__ts with X; Side; Between.

        apply bet_ts__ts with Y; trivial; apply l9_2, bet_ts__ts with X; Side; Between.

  }

  assert (HLta : LtA A C P A C Q).

  { apply t18_19; Cong.

      intro; treat_equalities; auto.

      apply cong_transitivity with C D; Cong.

      apply lt_comm, lt_transitivity with A B; trivial.

  }

  assert (HNCol1 : ~ Col P Q C).

  { intro.

    destruct HDij as [HOS'|[[HCol HNCol]|[HNCol HCol]]];

      [|apply HNCol; assert_diffs; ColR..].

    destruct HLta as [_ HNCongA].

    apply HNCongA, out2__conga.

      apply out_trivial; auto.

    apply col_one_side_out with A; Col; Side.

  }



  assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y ->

    OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).

  { intros X Y X0 Y0; intros.

    apply t18_18 with C C; Cong.

      apply cong_transitivity with C D; Cong.

    apply lta_comm, (conga_preserves_lta A C X A C Y).

      apply out2__conga; [apply out_trivial|apply l6_6]; auto.

      apply out2__conga; [apply out_trivial|apply l6_6]; auto.

    split.

    { apply inangle__lea.

      assert_diffs.

      apply l11_24, in_angle_trans with P.

        repeat split; auto; exists X; split; Between; right; apply out_trivial; auto.

      apply in_angle_trans2 with Q.

        repeat split; auto.

        exists Y; split; Between.

        right; apply out_trivial; auto.

      destruct HDij as [HOS'|[[HCol HNCol]|[HNCol HCol]]].

      - apply l11_24, lea_in_angle; Lea; Side.

      - apply out341__inangle; auto.

        apply not_bet_out; Col.

        intro; apply (lta__nlea A C P A C Q); trivial.

        apply l11_31_2; auto.

      - apply in_angle_line; auto.

        apply between_symmetry, not_out_bet; Col.

        intro; apply (lta__nlea A C P A C Q); trivial.

        apply l11_31_1; auto.

    }

    intro.

    destruct (conga_cop__or_out_ts A C X Y); trivial.

    - assert (Col P Q X) by ColR.

      apply coplanar_pseudo_trans with P Q C; [assumption| |Cop..].

      destruct HDij as [|[[]|[]]]; Cop.

    - absurd (X = Y); trivial; apply (l6_21 P Q C X); ColR.

    - apply (HNTS X Y); trivial.

  }



  assert (HR : exists R, forall X Y,

    (Bet P X Q /\ (exists X0, OnCircle X0 C D /\ Out C X X0 /\ InCircle X0 A B)) ->

    (Bet P Y Q /\ (exists Y0, OnCircle Y0 C D /\ Out C Y Y0 /\ OutCircle Y0 A B)) ->

    Bet X R Y).

  { apply dedekind; [repeat constructor..|].

    exists P.

    intros X Y [HX [X0]] [HY [Y0]].

    destruct (l5_3 P X Y Q); trivial.

    destruct (eq_dec_points X Y).

      subst; Between.

    exfalso.

    spliter.

    apply (lt__nle A Y0 A X0).

      apply (Haux Y X); auto.

    apply le_transitivity with A B; trivial.

  }

  assert (HP : exists X0, OnCircle X0 C D /\ Out C P X0 /\ InCircle X0 A B).

    exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.

  assert (HQ : exists Y0, OnCircle Y0 C D /\ Out C Q Y0 /\ OutCircle Y0 A B).

    exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.

  destruct HR as [R HR].

  assert (HBet : Bet P R Q) by (apply HR; split; Between).

  assert (R <> C) by (intro; subst; apply HNCol1; Col).

  destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.

  exists Z; split; trivial.

  assert (A <> B) by (apply (lt_diff A P), HPIn).

  destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.



  - assert (Q <> R).

    { intro; subst R.

      assert (Q = Z) by (apply (onc2_out__eq C D); trivial).

      subst.

      apply outcs__ninc in HQOut; Circle.

    }

    assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).

    assert (HT : exists T, OnCircle T A B /\ Bet A Z T).

    { destruct (eq_dec_points Z A).

        subst; exists B; split; Circle; Between.

      destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.

      exists T; split; trivial.

      apply l6_13_1; trivial.

      apply (l5_6 A Z A B); Cong; Le.

    }

    destruct HT as [T [HT1 HT2]].

    assert (T <> Z).

      intro; subst; apply incs__noutc in Habs; apply Habs; Circle.

    destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.

    assert_diffs.

    assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).

    destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.

    assert (HLt : Lt C X0 C I).

    { destruct (l11_46 I Z C) as [_ HLt]; auto.

        apply (cong2_lt__lt Z C I C); trivial.

          apply cong_transitivity with C D; Cong.

          Cong.

    }

    assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).

    assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).

    assert (HLt1 : Lt X0 Z I Z).

    { assert_diffs.

      destruct (l11_46 I X0 Z); auto.

      right.

      apply acute_bet__obtuse with C; auto.

        apply l6_13_1; [apply l6_6|]; Le.

      assert_diffs; apply cong__acute; auto.

      apply cong_transitivity with C D; Cong.

    }



    assert (HX0In : InCircleS X0 A B).

    { destruct (le_bet Z T Z X0) as [M [HM1 HM2]].

        apply (l5_6 X0 Z I Z); Cong; Le.

      assert (HMT : M <> T).

      { intro.

        apply (nlt Z M).

        apply (cong2_lt__lt X0 Z I Z); trivial; [|subst M; apply cong_transitivity with T Z]; Cong.

      }

      apply le1234_lt__lt with A M.

      - apply triangle_inequality with Z; Cong; eBetween.

      - apply (cong2_lt__lt A M A T); Cong.

        assert (Bet A M T) by eBetween.

        split; Le.

        intro.

        apply HMT, (between_cong A); assumption.

    }

    assert_diffs.

    assert (HX : InAngle X0 R C Q).

    { apply l11_25 with X0 Z Q; try (apply out_trivial); auto.

      apply lea_in_angle.

      - apply t18_19; auto.

          apply cong_transitivity with C D; Cong.

          Cong.

        apply le3456_lt__lt with I Z; trivial.

        apply (l5_6 T Z Q Z); Cong.

        assert (HLe : Le A T A Q) by (apply (l5_6 A B A Q); Cong; Le).

        destruct (eq_dec_points A Z).

          subst; Le.

        destruct (l5_5_1 A T A Q) as [M [HM1 HM2]]; trivial.

        assert (Bet A Z M) by eBetween.

        apply le_transitivity with M Z.

          apply bet__le2313; eBetween.

        apply le_comm, (triangle_reverse_inequality A); Cong.

        apply bet_out; auto.

      - apply invert_one_side, col_one_side with R; Col.

        apply one_side_transitivity with I; Side.

        apply out_one_side; trivial.

        left; apply one_side_not_col123 with Q; trivial.

    }

    destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].

      subst; apply HNCol2; Col.

    assert (X = R).

      apply between_equality with Q; trivial.

      apply HR; split; [eBetween|..]; Between.

      exists X0; repeat (split; Circle).

    subst; apply HNCol4; ColR.



  - assert (P <> R).

    { intro; subst R.

      assert (P = Z) by (apply (onc2_out__eq C D); trivial).

      subst.

      apply incs__noutc in HPIn; Circle.

    }

    assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).

    destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.

      apply (lt_diff A B), lt_right_comm, Habs.

    assert (HT3 : Bet A T Z).

    { apply l6_13_1.

        apply l6_6, HT2.

      apply (l5_6 A B A Z); Cong; Le.

    }

    assert (T <> Z).

      intro; subst; apply outcs__ninc in Habs; apply Habs; Circle.

    destruct (ex_per_cong C R Z P T Z) as [I [HI1 [HI2 HI3]]]; Col.

    assert_diffs.

    assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).



    destruct (onc_exists C D I) as [Y0 [HY0On HY0Out]]; auto.

    assert (HLt : Lt C Y0 C I).

    { destruct (l11_46 I Z C) as [_ HLt]; auto.

        apply (cong2_lt__lt Z C I C); trivial.

          apply cong_transitivity with C D; Cong.

          Cong.

    }

    assert (Y0 <> I) by (intro; apply (nlt C I); subst; assumption).

    assert (HNCol4 : ~ Col I Y0 Z) by (intro; apply (one_side_not_col123 C R I P); ColR).

    assert (HLt1 : Lt Y0 Z I Z).

    { assert_diffs.

      destruct (l11_46 I Y0 Z); auto.

      right.

      apply acute_bet__obtuse with C; auto.

        apply l6_13_1; [apply l6_6|]; Le.

      assert_diffs; apply cong__acute; auto.

      apply cong_transitivity with C D; Cong.

    }



    assert (HY0OutC : OutCircleS Y0 A B).

    { destruct (le_bet Z T Z Y0) as [M [HM1 HM2]].

        apply (l5_6 Y0 Z I Z); Cong; Le.

      assert (HTM : T <> M).

      { intro.

        apply (nlt Z M).

        apply (cong2_lt__lt Y0 Z I Z); trivial; [|subst M; apply cong_transitivity with T Z]; Cong.

      }

      apply le3456_lt__lt with A M.

      - apply (cong2_lt__lt A T A M); Cong.

        assert (Bet A T M) by eBetween.

        split; Le.

        intro.

        apply HTM, (between_cong A); assumption.

      - apply (triangle_reverse_inequality Z); Cong.

        assert_diffs; apply l6_6, bet_out; eBetween.

    }

    assert_diffs.

    assert (HY : InAngle Y0 P C R).

    { apply l11_25 with Y0 P Z; try (apply out_trivial); auto.

      apply l11_24, lea_in_angle.

      - apply t18_19; auto.

          apply cong_transitivity with C D; Cong.

          Cong.

        apply le3456_lt__lt with I Z; trivial.

        apply (l5_6 T Z P Z); Cong.

        destruct (le_bet A T A P) as [M [HM1 HM2]].

          apply (l5_6 A P A B); Cong; Le.

        assert (Bet A M Z) by eBetween.

        destruct (eq_dec_points M A).

          treat_equalities; Le.

        apply le_transitivity with M Z.

          apply bet__le2313; eBetween.

        apply le_comm, (triangle_reverse_inequality A); Cong.

        apply l6_6, bet_out; auto.

      - apply invert_one_side, col_one_side with R; Col.

        apply one_side_transitivity with I; Side.

        apply out_one_side; trivial.

        left; apply one_side_not_col123 with P; trivial.

    }

    destruct HY as [_ [_ [_ [Y [HY1 [HY2|HY2]]]]]].

      subst; apply HNCol2; Col.

    assert (Y = R).

      apply between_equality with P; apply between_symmetry; trivial.

      apply HR; split; [Between..| |]; [eBetween|].

      exists Y0; repeat (split; Circle).

    subst; apply HNCol4; ColR.

Qed.



End Dedekind_circle_circle.
