Require Import GeoCoq.Axioms.continuity_axioms.
(* GeoCoq.Axioms.continuity_axioms:
Require Import GeoCoq.Tarski_dev.Definitions.

Section Continuity_Defs.

Context `{Tn:Tarski_neutral_dimensionless}.

Definition segment_circle := forall A B P Q,
  InCircle P A B ->
  OutCircle Q A B ->
  exists Z, Bet P Z Q /\ OnCircle Z A B.

Definition one_point_line_circle := forall A B U V P,
  Col U V P -> U <> V -> Bet A P B ->
  exists Z, Col U V Z /\ OnCircle Z A B.

Definition two_points_line_circle := forall A B U V P,
  Col U V P -> U <> V -> Bet A P B ->
  exists Z1 Z2, Col U V Z1 /\ OnCircle Z1 A B /\
                Col U V Z2 /\ OnCircle Z2 A B /\
                Bet Z1 P Z2 /\ (P <> B -> Z1 <> Z2).

Definition circle_circle := forall A B C D P Q,
  OnCircle P C D ->
  OnCircle Q C D ->
  InCircle P A B ->
  OutCircle Q A B ->
  exists Z, OnCircle Z A B /\ OnCircle Z C D.

Definition circle_circle_bis := forall A B C D P Q,
  OnCircle P C D ->
  InCircle P A B ->
  OnCircle Q A B ->
  InCircle Q C D ->
  exists Z, OnCircle Z A B /\ OnCircle Z C D.

Definition circle_circle_axiom := forall A B C D B' D',
  Cong A B' A B -> Cong C D' C D ->
  Bet A D' B -> Bet C B' D ->
  exists Z, Cong A Z A B /\ Cong C Z C D.

Definition circle_circle_two := forall A B C D P Q,
  OnCircle P C D ->
  OnCircle Q C D ->
  InCircle P A B ->
  OutCircle Q A B ->
  exists Z1 Z2,
    OnCircle Z1 A B /\ OnCircle Z1 C D /\
    OnCircle Z2 A B /\ OnCircle Z2 C D /\
    (InCircleS P A B -> OutCircleS Q A B -> Z1<>Z2).

Definition euclid_s_prop_1_22 := forall A B C D E F A' B' C' D' E' F',
  SumS A B C D E' F' -> SumS A B E F C' D' -> SumS C D E F A' B' ->
  Le E F E' F' -> Le C D C' D' -> Le A B A' B' ->
  exists P Q R, Cong P Q A B /\ Cong P R C D /\ Cong Q R E F.

Definition Nested (A B:nat -> Tpoint -> Prop) :=
  (forall n, exists An, A n An) /\ (forall n, exists Bn, B n Bn) /\
  forall n An Am Bm Bn,
    A n An -> A (S n) Am -> B (S n) Bm -> B n Bn -> Bet An Am Bm /\ Bet Am Bm Bn /\ Am <> Bm.

Definition cantor_s_axiom := forall A B, Nested A B ->
  exists X, forall n An Bn, A n An -> B n Bn -> Bet An X Bn.

Definition dedekind_s_axiom := forall (Alpha Beta : Tpoint -> Prop),
  (exists A, forall X Y, Alpha X -> Beta Y -> Bet A X Y) ->
  (exists B, forall X Y, Alpha X -> Beta Y -> Bet X B Y).

Inductive FOF : Prop -> Prop :=
| eq_fof : forall A B:Tpoint, FOF (A = B)
| bet_fof : forall A B C, FOF (Bet A B C)
| cong_fof : forall A B C D, FOF (Cong A B C D)
| not_fof : forall P, FOF P -> FOF (~ P)
| and_fof : forall P Q, FOF P -> FOF Q -> FOF (P /\ Q)
| or_fof : forall P Q, FOF P -> FOF Q -> FOF (P \/ Q)
| implies_fof : forall P Q, FOF P -> FOF Q -> FOF (P -> Q)
| forall_fof : forall P, (forall (A:Tpoint), FOF (P A)) -> FOF (forall A, P A)
| exists_fof : forall P, (forall (A:Tpoint), FOF (P A)) -> FOF (exists A, P A).

Definition first_order_dedekind := forall Alpha Beta,
  (forall X, FOF (Alpha X)) -> (forall Y, FOF (Beta Y)) ->
  (exists A, forall X Y, Alpha X -> Beta Y -> Bet A X Y) ->
  (exists B, forall X Y, Alpha X -> Beta Y -> Bet X B Y).

Definition archimedes_axiom := forall A B C D, A <> B -> Reach A B C D.

Definition aristotle_s_axiom := forall P Q A B C,
  ~ Col A B C -> Acute A B C ->
  exists X Y, Out B A X /\ Out B C Y /\ Per B X Y /\ Lt P Q X Y.

Definition greenberg_s_axiom := forall P Q R A B C,
  ~ Col A B C ->
  Acute A B C -> Q <> R -> Per P Q R ->
  exists S, LtA P S Q A B C /\ Out Q S R.

End Continuity_Defs.

Section Completeness.

Context `{Tn:Tarski_neutral_dimensionless}.

Definition inj {T1 T2:Type} (f:T1->T2) := forall A B, f A = f B -> A = B.

Definition pres_bet {Tm: Tarski_neutral_dimensionless}
  (f : @Tpoint Tn -> @Tpoint Tm) := forall A B C, Bet A B C -> Bet (f A) (f B) (f C).

Definition pres_cong {Tm: Tarski_neutral_dimensionless}
  (f : @Tpoint Tn -> @Tpoint Tm) := forall A B C D, Cong A B C D -> Cong (f A) (f B) (f C) (f D).

Definition extension {Tm: Tarski_neutral_dimensionless} f := inj f /\ pres_bet f /\ pres_cong f.

Definition completeness_for_planes := forall (Tm: Tarski_neutral_dimensionless)
  (Tm2 : Tarski_neutral_dimensionless_with_decidable_point_equality Tm)
  (M : Tarski_2D Tm2)
  (f : @Tpoint Tn -> @Tpoint Tm),
  @archimedes_axiom Tm ->
  extension f ->
  forall A, exists B, f B = A.

Definition completeness_for_3d_spaces := forall (Tm: Tarski_neutral_dimensionless)
  (Tm2 : Tarski_neutral_dimensionless_with_decidable_point_equality Tm)
  (M : Tarski_3D Tm2)
  (f : @Tpoint Tn -> @Tpoint Tm),
  @archimedes_axiom Tm ->
  extension f ->
  forall A, exists B, f B = A.

Definition inj_line {T:Type} (f:Tpoint->T) P Q := forall A B, Col P Q A -> Col P Q B ->
  f A = f B -> A = B.

Definition pres_bet_line {Tm: Tarski_neutral_dimensionless}
  (f : @Tpoint Tn -> @Tpoint Tm) P Q := forall A B C, Col P Q A -> Col P Q B -> Col P Q C ->
  Bet A B C -> Bet (f A) (f B) (f C).

Definition pres_cong_line {Tm: Tarski_neutral_dimensionless}
  (f : @Tpoint Tn -> @Tpoint Tm) P Q := forall A B C D,
  Col P Q A -> Col P Q B -> Col P Q C -> Col P Q D ->
  Cong A B C D -> Cong (f A) (f B) (f C) (f D).

Definition line_extension {Tm: Tarski_neutral_dimensionless} f P Q :=
  P <> Q /\ inj_line f P Q /\ pres_bet_line f P Q /\ pres_cong_line f P Q.

Definition line_completeness := forall (Tm: Tarski_neutral_dimensionless)
  (Tm2 : Tarski_neutral_dimensionless_with_decidable_point_equality Tm)
  P Q
  (f : @Tpoint Tn -> @Tpoint Tm),
  @archimedes_axiom Tm ->
  line_extension f P Q ->
  forall A, Col (f P) (f Q) A -> exists B, Col P Q B /\ f B = A.

End Completeness. *)

Require Import GeoCoq.Tarski_dev.Annexes.saccheri.
(* GeoCoq.Tarski_dev.Annexes.saccheri:
Require Export GeoCoq.Tarski_dev.Ch12_parallel.
Require Export GeoCoq.Tarski_dev.Annexes.suma.

Section Saccheri.

Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.

Lemma sac_perm : forall A B C D, Saccheri A B C D -> Saccheri D C B A.

Lemma sac_distincts : forall A B C D,
  Saccheri A B C D ->
  A <> B /\ B <> C /\ C <> D /\ A <> D /\ A <> C /\ B <> D.

Lemma lam_perm : forall A B C D, Lambert A B C D -> Lambert A D C B.

Lemma sac__cong : forall A B C D, Saccheri A B C D -> Cong A C B D.

Lemma sac__conga : forall A B C D, Saccheri A B C D -> CongA A B C B C D.

Lemma lam__os : forall A B C D, Lambert A B C D -> OS A B C D.

Lemma per2_os__ncol123 : forall A B C D, Per B A D -> Per A D C -> OS A D B C ->
   ~ Col A B C.

Lemma per2_os__ncol234 : forall A B C D,
  Per B A D -> Per A D C ->
  OS A D B C ->
  ~ Col B C D.

Lemma sac__ncol123 : forall A B C D, Saccheri A B C D -> ~ Col A B C.

Lemma sac__ncol124 : forall A B C D, Saccheri A B C D -> ~ Col A B D.

Lemma sac__ncol134 : forall A B C D, Saccheri A B C D -> ~ Col A C D.

Lemma sac__ncol234 : forall A B C D, Saccheri A B C D -> ~ Col B C D.

Lemma sac__coplanar : forall A B C D, Saccheri A B C D -> Coplanar A B C D.

Lemma lt_os_per2__lta : forall A B C D,
  Per B A D -> Per A D C ->
  OS A D B C ->
  Lt A B C D ->
  LtA B C D A B C.

Lemma lt4321_os_per2__lta : forall A B C D,
  Per B A D -> Per A D C ->
  OS A D B C -> Lt D C B A ->
  LtA A B C B C D.

Lemma lta_os_per2__lt : forall A B C D,
  Per B A D -> Per A D C ->
  OS A D B C -> LtA B C D A B C ->
  Lt A B C D.

Lemma lta123234_os_per2__lt : forall A B C D,
  Per B A D -> Per A D C ->
  OS A D B C -> LtA A B C B C D ->
  Lt D C B A.

Lemma conga_per2_os__cong : forall A B C D,
  Per B A D -> Per A D C ->
  OS A D B C -> CongA B C D A B C ->
  Cong A B C D.

Lemma mid2_sac__perp_lower : forall A B C D M N,
  Saccheri A B C D ->
  Midpoint M B C -> Midpoint N A D ->
  Perp A D M N.

Lemma mid2_sac__perp_upper : forall A B C D M N, Saccheri A B C D ->
  Midpoint M B C -> Midpoint N A D -> Perp B C M N.

Lemma sac__par_strict1423 : forall A B C D, Saccheri A B C D -> Par_strict A D B C.

Lemma sac__par_strict1234 : forall A B C D, Saccheri A B C D -> Par_strict A B C D.

Lemma sac__par1423 : forall A B C D, Saccheri A B C D -> Par A D B C.

Lemma sac__par1234 : forall A B C D, Saccheri A B C D -> Par A B C D.

Lemma lam__par_strict1234 : forall A B C D, Lambert A B C D -> Par_strict A B C D.

Lemma lam__par_strict1423 : forall A B C D, Lambert A B C D -> Par_strict A D B C.

Lemma lam__par1234 : forall A B C D, Lambert A B C D -> Par A B C D.

Lemma lam__par1423 : forall A B C D, Lambert A B C D -> Par A D B C.

Lemma mid2_sac__lam6521 : forall A B C D M N,
  Saccheri A B C D ->
  Midpoint M B C -> Midpoint N A D ->
  Lambert N M B A.

Lemma mid2_sac__lam6534 : forall A B C D M N,
  Saccheri A B C D ->
  Midpoint M B C -> Midpoint N A D ->
  Lambert N M C D.

Lemma lam6521_mid2__sac : forall A B C D M N,
  Lambert N M B A ->
  Midpoint M B C -> Midpoint N A D ->
  Saccheri A B C D.

Lemma lam6534_mid2__sac : forall A B C D M N,
  Lambert N M C D ->
  Midpoint M B C -> Midpoint N A D ->
  Saccheri A B C D.

Lemma cong_lam__per : forall A B C D,
  Lambert A B C D ->
  Cong A D B C ->
  Per B C D.

Lemma lam_lt__acute : forall A B C D,
  Lambert A B C D ->
  Lt A D B C ->
  Acute B C D.

Lemma lam_lt__obtuse : forall A B C D,
  Lambert A B C D ->
  Lt B C A D ->
  Obtuse B C D.

Lemma lam_per__cong : forall A B C D,
  Lambert A B C D ->
  Per B C D ->
  Cong A D B C.

Lemma acute_lam__lt : forall A B C D,
  Lambert A B C D ->
  Acute B C D ->
  Lt A D B C.

Lemma lam_obtuse__lt : forall A B C D,
  Lambert A B C D ->
  Obtuse B C D ->
  Lt B C A D.

Lemma cong_sac__per : forall A B C D,
  Saccheri A B C D ->
  Cong A D B C <-> Per A B C.

Lemma lt_sac__acute : forall A B C D,
  Saccheri A B C D ->
  Lt A D B C <-> Acute A B C.

Lemma lt_sac__obtuse : forall A B C D,
  Saccheri A B C D ->
  Lt B C A D <-> Obtuse A B C.

Lemma t22_7__per : forall A B C D P Q,
  Saccheri A B C D ->
  Bet B P C -> Bet A Q D ->
  A <> Q -> B <> P -> P <> C ->
  Per P Q A ->
  Cong P Q A B ->
  Per A B C.

Lemma t22_7__acute : forall A B C D P Q,
  Saccheri A B C D ->
  Bet B P C -> Bet A Q D ->
  A <> Q -> B <> P -> P <> C ->
  Per P Q A ->
  Lt P Q A B ->
  Acute A B C.

Lemma t22_7__obtuse : forall A B C D P Q,
  Saccheri A B C D ->
  Bet B P C -> Bet A Q D ->
  A <> Q -> B <> P -> P <> C ->
  Per P Q A ->
  Lt A B P Q ->
  Obtuse A B C.

Lemma t22_7__cong : forall A B C D P Q,
  Saccheri A B C D ->
  Bet B P C -> Bet A Q D ->
  A <> Q -> B <> P -> P <> C ->
  Per P Q A -> Per A B C ->
  Cong P Q A B.

Lemma t22_7__lt5612 : forall A B C D P Q,
  Saccheri A B C D ->
  Bet B P C -> Bet A Q D ->
  A <> Q -> B <> P -> P <> C ->
  Per P Q A -> Acute A B C ->
  Lt P Q A B.

Lemma t22_7__lt1256 : forall A B C D P Q,
  Saccheri A B C D ->
  Bet B P C -> Bet A Q D ->
  A <> Q -> B <> P -> P <> C ->
  Per P Q A -> Obtuse A B C ->
  Lt A B P Q.

Lemma t22_8__per : forall A B C D R S,
  Saccheri A B C D ->
  Bet B C R -> Bet A D S ->
  C <> R ->
  Per A S R ->
  Cong R S A B ->
  Per A B C.

Lemma t22_8__acute : forall A B C D R S,
  Saccheri A B C D ->
  Bet B C R -> Bet A D S ->
  C <> R ->
  Per A S R ->
  Lt A B R S ->
  Acute A B C.

Lemma t22_8__obtuse : forall A B C D R S,
  Saccheri A B C D ->
  Bet B C R -> Bet A D S ->
  C <> R ->
  Per A S R ->
  Lt R S A B ->
  Obtuse A B C.

Lemma t22_8__cong : forall A B C D R S,
  Saccheri A B C D -> Bet B C R -> Bet A D S ->
  C <> R -> Per A S R -> Per A B C -> Cong R S A B.

Lemma t22_8__lt1256 : forall A B C D R S,
  Saccheri A B C D ->
  Bet B C R -> Bet A D S ->
  C <> R ->
  Per A S R -> Acute A B C ->
  Lt A B R S.

Lemma t22_8__lt5612 : forall A B C D R S,
  Saccheri A B C D ->
  Bet B C R -> Bet A D S ->
  C <> R ->
  Per A S R -> Obtuse A B C ->
  Lt R S A B.

Lemma t22_9__per : forall N M P Q R S,
  Lambert N M P Q -> Lambert N M R S ->
  Bet M P R -> Bet N Q S ->
  (Per S R M <-> Per Q P M).

Lemma t22_9__acute : forall N M P Q R S,
  Lambert N M P Q -> Lambert N M R S ->
  Bet M P R -> Bet N Q S ->
  (Acute S R M <-> Acute Q P M).

Lemma t22_9__obtuse : forall N M P Q R S,
  Lambert N M P Q -> Lambert N M R S ->
  Bet M P R -> Bet N Q S ->
  (Obtuse S R M <-> Obtuse Q P M).

Lemma cong2_lam2__cong : forall N M P Q N' M' P' Q',
  Lambert N M P Q -> Lambert N' M' P' Q' ->
  Cong N Q N' Q' -> Cong P Q P' Q' ->
  Cong N M N' M'.

Lemma cong2_lam2__conga : forall N M P Q N' M' P' Q',
  Lambert N M P Q -> Lambert N' M' P' Q' ->
  Cong N Q N' Q' -> Cong P Q P' Q' ->
  CongA M P Q M' P' Q'.

Lemma cong2_sac2__cong : forall A B C D A' B' C' D',
  Saccheri A B C D -> Saccheri A' B' C' D' ->
  Cong A B A' B' -> Cong A D A' D' ->
  Cong B C B' C'.

Lemma sac__perp1214 : forall A B C D, Saccheri A B C D -> Perp A B A D.

Lemma sac__perp3414 : forall A B C D, Saccheri A B C D -> Perp C D A D.

Lemma cop_sac2__sac : forall A B C D E F,
  Saccheri A B C D -> Saccheri A B E F -> D<>F -> Coplanar A B D F -> Saccheri D C E F.

Lemma three_hypotheses_aux : forall A B C D M N A' B' C' D' M' N',
  Saccheri A B C D -> Saccheri A' B' C' D' ->
  Midpoint M B C -> Midpoint M' B' C' -> Midpoint N A D -> Midpoint N' A' D' ->
  Le M N M' N' ->
  (Per A B C <-> Per A' B' C') /\ (Acute A B C <-> Acute A' B' C').

Definition hypothesis_of_right_saccheri_quadrilaterals := forall A B C D, Saccheri A B C D -> Per A B C.

Definition hypothesis_of_acute_saccheri_quadrilaterals := forall A B C D, Saccheri A B C D -> Acute A B C.

Definition hypothesis_of_obtuse_saccheri_quadrilaterals := forall A B C D, Saccheri A B C D -> Obtuse A B C.

Lemma per_sac__rah : forall A B C D,
  Saccheri A B C D -> Per A B C -> hypothesis_of_right_saccheri_quadrilaterals.

Lemma acute_sac__aah : forall A B C D,
  Saccheri A B C D -> Acute A B C -> hypothesis_of_acute_saccheri_quadrilaterals.

Lemma obtuse_sac__oah : forall A B C D,
  Saccheri A B C D -> Obtuse A B C -> hypothesis_of_obtuse_saccheri_quadrilaterals.

Lemma per__ex_saccheri : forall A B D, Per B A D -> A <> B -> A <> D ->
  exists C, Saccheri A B C D.

Lemma ex_saccheri : exists A B C D, Saccheri A B C D.

Lemma ex_lambert : exists A B C D, Lambert A B C D.

Lemma saccheri_s_three_hypotheses :
  hypothesis_of_acute_saccheri_quadrilaterals \/ hypothesis_of_right_saccheri_quadrilaterals \/ hypothesis_of_obtuse_saccheri_quadrilaterals.

Lemma not_aah :
  hypothesis_of_right_saccheri_quadrilaterals \/ hypothesis_of_obtuse_saccheri_quadrilaterals -> ~ hypothesis_of_acute_saccheri_quadrilaterals.

Lemma not_rah :
  hypothesis_of_acute_saccheri_quadrilaterals \/ hypothesis_of_obtuse_saccheri_quadrilaterals -> ~ hypothesis_of_right_saccheri_quadrilaterals.

Lemma not_oah :
  hypothesis_of_acute_saccheri_quadrilaterals \/ hypothesis_of_right_saccheri_quadrilaterals -> ~ hypothesis_of_obtuse_saccheri_quadrilaterals.

Lemma lam_per__rah : forall A B C D,
  Lambert A B C D -> (Per B C D <-> hypothesis_of_right_saccheri_quadrilaterals).

Lemma lam_acute__aah : forall A B C D,
  Lambert A B C D -> (Acute B C D <-> hypothesis_of_acute_saccheri_quadrilaterals).

Lemma lam_obtuse__oah : forall A B C D,
  Lambert A B C D -> (Obtuse B C D <-> hypothesis_of_obtuse_saccheri_quadrilaterals).

Lemma t22_11__per : forall A B C D,
  Saccheri A B C D -> (CongA A B D B D C <-> Per A B C).

Lemma t22_11__acute : forall A B C D,
  Saccheri A B C D -> (LtA A B D B D C <-> Acute A B C).

Lemma t22_11__obtuse : forall A B C D,
  Saccheri A B C D -> (LtA B D C A B D <-> Obtuse A B C).

Lemma t22_12__rah : forall A B C,
  A <> B -> B <> C -> Per A B C ->
  (SumA B C A C A B A B C <-> hypothesis_of_right_saccheri_quadrilaterals).

Lemma t22_12__aah : forall A B C P Q R,
  Per A B C -> SumA B C A C A B P Q R ->
  (Acute P Q R <-> hypothesis_of_acute_saccheri_quadrilaterals).

Lemma t22_12__oah : forall A B C P Q R,
  Per A B C -> SumA B C A C A B P Q R ->
  (Obtuse P Q R <-> hypothesis_of_obtuse_saccheri_quadrilaterals).

Lemma t22_14__bet_aux : forall A B C P Q R,
  hypothesis_of_right_saccheri_quadrilaterals ->
  ~ Col A B C -> TriSumA A B C P Q R -> Acute A B C -> Acute A C B -> Bet P Q R.

Lemma t22_14__bet :
  hypothesis_of_right_saccheri_quadrilaterals ->
  forall A B C P Q R, TriSumA A B C P Q R -> Bet P Q R.

Lemma t22_14__sams_nbet_aux : forall A B C D E F P Q R,
  hypothesis_of_acute_saccheri_quadrilaterals ->
  ~ Col A B C ->
  SumA C A B A B C D E F -> SumA D E F B C A P Q R ->
  Acute A B C -> Acute A C B ->
  SAMS D E F B C A /\ ~ Bet P Q R.

Lemma t22_14__sams_nbet :
  hypothesis_of_acute_saccheri_quadrilaterals ->
  forall A B C D E F P Q R, ~ Col A B C ->
  SumA C A B A B C D E F -> SumA D E F B C A P Q R ->
  SAMS D E F B C A /\ ~ Bet P Q R.

Lemma t22_14__nsams_aux : forall A B C D E F,
  hypothesis_of_obtuse_saccheri_quadrilaterals ->
  ~ Col A B C ->
  SumA C A B A B C D E F -> Acute A B C -> Acute A C B ->
  ~ SAMS D E F B C A.

Lemma t22_14__nsams :
  hypothesis_of_obtuse_saccheri_quadrilaterals ->
  forall A B C D E F, ~ Col A B C ->
  SumA C A B A B C D E F ->
  ~ SAMS D E F B C A.

Lemma t22_14__rah : forall A B C P Q R,
  ~ Col A B C -> TriSumA A B C P Q R -> Bet P Q R -> hypothesis_of_right_saccheri_quadrilaterals.

Lemma t22_14__aah : forall A B C D E F P Q R,
  SumA C A B A B C D E F -> SumA D E F B C A P Q R ->
  SAMS D E F B C A ->
  ~ Bet P Q R ->
  hypothesis_of_acute_saccheri_quadrilaterals.

Lemma t22_14__oah : forall A B C D E F,
  SumA C A B A B C D E F -> ~ SAMS D E F B C A -> hypothesis_of_obtuse_saccheri_quadrilaterals.

Lemma cong_mid__suma : forall A B C M,
  ~ Col A B C ->
  Midpoint M A B -> Cong M A M C ->
  SumA C A B A B C A C B.

Lemma t22_17__rah : forall A B C M,
  ~ Col A B C ->
  Midpoint M A B -> Cong M A M C ->
  (Per A C B <-> hypothesis_of_right_saccheri_quadrilaterals).

Lemma t22_17__oah : forall A B C M,
  ~ Col A B C ->
  Midpoint M A B -> Cong M A M C ->
  (Obtuse A C B <-> hypothesis_of_obtuse_saccheri_quadrilaterals).

Lemma t22_17__aah : forall A B C M,
  ~ Col A B C ->
  Midpoint M A B -> Cong M A M C ->
  (Acute A C B <-> hypothesis_of_acute_saccheri_quadrilaterals).

Lemma t22_20 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals ->
  forall A B C D E F, SumA A B C B C A D E F -> SAMS D E F C A B.

Lemma absolute_exterior_angle_theorem : ~ hypothesis_of_obtuse_saccheri_quadrilaterals ->
  forall A B C D E F B', Bet B A B' -> A <> B' -> SumA A B C B C A D E F ->
  LeA D E F C A B'.

End Saccheri.

Hint Resolve sac__par_strict1423 sac__par_strict1234 sac__par1423 sac__par1234
lam__par_strict1234 lam__par_strict1423 lam__par1234 lam__par1423 : Par.

Hint Resolve sac__coplanar : cop.

Section Saccheri_2D.

Context `{T2D:Tarski_2D}.

Lemma sac2__sac : forall A B C D E F,
  Saccheri A B C D -> Saccheri A B E F -> D <> F -> Saccheri D C E F.

End Saccheri_2D. *)

Require Import GeoCoq.Tarski_dev.Ch13_1.
(* GeoCoq.Tarski_dev.Ch13_1:
Require Export GeoCoq.Tarski_dev.Ch12_parallel.

Section L13_1.

Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.

Lemma per2_col_eq : forall A P P' B, A <> P -> A <> P' -> Per A P B -> Per A P' B -> Col P A P' -> P = P'.

Lemma per2_preserves_diff : forall O A B A' B', O <> A' -> O <> B' -> Col O A' B' -> Per O A' A -> Per O B' B -> A' <> B' -> A <> B.

Lemma per23_preserves_bet : forall A B C B' C', Bet A B C -> A <> B' -> A <> C' -> Col A B' C' -> Per A B' B -> Per A C' C -> Bet A B' C'.

Lemma per23_preserves_bet_inv : forall A B C B' C', Bet A B' C' -> A <> B' -> Col A B C -> Per A B' B -> Per A C' C -> Bet A B C.

Lemma per13_preserves_bet : forall A B C A' C', Bet A B C -> B <> A' -> B <> C' -> Col A' B C' -> Per B A' A -> Per B C' C -> Bet A' B C'.

Lemma per13_preserves_bet_inv : forall A B C A' C', Bet A' B C' -> B <> A' -> B <> C' ->  Col A B C  -> Per B A' A -> Per B C' C -> Bet A B C.

Lemma per3_preserves_bet1 : forall O A B C A' B' C', Col O A B -> Bet A B C -> O <> A' -> O <> B' -> O <> C'
                                                    -> Per O A' A -> Per O B' B -> Per O C' C
                                                    -> Col A' B' C' -> Col O A' B' -> Bet A' B' C'.

Lemma per3_preserves_bet2_aux : forall O A B C B' C', Col O A C -> A <> C' ->
                               Bet A B' C' -> O <> A -> O <> B' -> O <> C'
                               -> Per O B' B -> Per O C' C
                               -> Col A B C -> Col O A C' -> Bet A B C.

Lemma per3_preserves_bet2 : forall O A B C A' B' C', Col O A C -> A' <> C' ->
                               Bet A' B' C' -> O <> A' -> O <> B' -> O <> C'
                               -> Per O A' A -> Per O B' B -> Per O C' C
                               -> Col A B C -> Col O A' C' -> Bet A B C.

Lemma symmetry_preserves_per : forall A P B A' P', Per B P A -> Midpoint B A A' -> Midpoint B P P'
                                                   -> Per B P' A'.

Lemma l13_1_aux : forall A B C P Q R,
   ~ Col A B C -> Midpoint P B C -> Midpoint Q A C -> Midpoint R A B ->
   exists X, exists Y, Perp_at R X Y A B /\ Perp X Y P Q /\ Coplanar A B C X /\ Coplanar A B C Y.

Lemma l13_1 : forall A B C P Q R,
   ~ Col A B C -> Midpoint P B C -> Midpoint Q A C -> Midpoint R A B ->
   exists X, exists Y, Perp_at R X Y A B /\ Perp X Y P Q.

Lemma per_lt : forall A B C, A <> B ->  C <> B -> Per A B C -> Lt A B A C /\ Lt C B A C.

Lemma cong_perp_conga : forall A B C P,  Cong A B C B -> Perp A C B P -> CongA A B P C B P /\ TS B P A C.

Lemma perp_per_bet : forall A B C P, ~Col A B C -> Col A P C -> Per A B C -> Perp_at P P B A C -> Bet A P C.

Lemma ts_per_per_ts : forall A B C D, TS A B C D -> Per B C A -> Per B D A -> TS C D A B.

Lemma l13_2_1 : forall A B C D E, TS A B C D -> Per B C A -> Per B D A -> Col C D E
    -> Perp A E C D -> CongA C A B D A B
    -> CongA B A C D A E /\ CongA B A D C A E /\ Bet C E D.

  Lemma triangle_mid_par : forall A B C P Q, ~Col A B C -> Midpoint P B C -> Midpoint Q A C -> Par_strict A B Q P.

Lemma cop4_perp_in2__col : forall A B A' B' X Y P,
  Coplanar X Y A A' -> Coplanar X Y A B' ->
  Coplanar X Y B A' -> Coplanar X Y B B' ->
  Perp_at P A B X Y -> Perp_at P A' B' X Y  -> Col A B A'.

Lemma l13_2 : forall A B C D E, TS A B C D -> Per B C A -> Per B D A -> Col C D E -> Perp A E C D
    -> CongA B A C D A E /\ CongA B A D C A E /\ Bet C E D.

Lemma perp2_refl : forall A B P, A <> B -> Perp2 A B A B P.

Lemma perp2_sym : forall A B C D P, Perp2 A B C D P -> Perp2 C D A B P.

Lemma perp2_left_comm : forall A B C D P, Perp2 A B C D P -> Perp2 B A C D P.

Lemma perp2_right_comm : forall A B C D P, Perp2 A B C D P -> Perp2 A B D C P.

Lemma perp2_comm : forall A B C D P, Perp2 A B C D P -> Perp2 B A D C P.

Lemma perp2_pseudo_trans : forall A B C D E F P, Perp2 A B C D P -> Perp2 C D E F P -> ~ Col C D P ->
  Perp2 A B E F P.

Lemma perp2_preserves_bet23 : forall O A B A' B', Bet O A B -> Col O A' B' -> ~Col O A A' ->
    Perp2 A A' B B' O -> Bet O A' B'.

Lemma perp2_preserves_bet13 : forall O B C B' C', Bet B O C -> Col O B' C' -> ~Col O B B' ->
    Perp2 B C' C B' O -> Bet B' O C'.

Lemma is_image_perp_in : forall A A' X Y, A <> A' -> X <> Y -> Reflect A A' X Y ->
  exists P, Perp_at P A A' X Y.

Lemma perp_inter_perp_in_n
     : forall A B C D : Tpoint,
       Perp A B C D ->
       exists P : Tpoint, Col A B P /\ Col C D P /\ Perp_at P A B C D.

Lemma perp2_perp_in : forall A B C D O, Perp2 A B C D O -> ~Col O A B /\ ~Col O C D ->
    exists P, exists Q, Col A B P /\ Col C D Q /\ Col O P Q /\ Perp_at P O P A B /\ Perp_at Q O Q C D.

Lemma l13_8 : forall O P Q U V, U <> O -> V <> O -> Col O P Q -> Col O U V
    -> Per P U O -> Per Q V O -> (Out O P Q <-> Out O U V).

Lemma perp_in_rewrite : forall A B C D P, Perp_at P A B C D ->
                                          Perp_at P A P P C \/
                                          Perp_at P A P P D \/
                                          Perp_at P B P P C \/
                                          Perp_at P B P P D.

Lemma gta_to_lta : forall A B C D E F, GtA A B C D E F -> LtA D E F A B C.

Lemma lta_to_gta : forall A B C D E F, LtA A B C D E F -> GtA D E F A B C.

Lemma perp_out_acute : forall A B C C', Out B A C' -> Perp A B C C' -> Acute A B C.

Lemma flat_all_lea : forall A B C, A <> B -> C <> B -> Bet A B C -> forall P, P <> B -> LeA A B P A B C.

Lemma perp_bet_obtuse : forall A B C C', B <> C' -> Perp A B C C' -> Bet A B C' -> Obtuse A B C.

End L13_1.

Section L13_1_2D.

Context `{T2D:Tarski_2D}.

Lemma perp_in2__col : forall A B A' B' X Y P, Perp_at P A B X Y -> Perp_at P A' B' X Y  ->
  Col A B A'.

Lemma perp2_trans : forall A B C D E F P, Perp2 A B C D P -> Perp2 C D E F P -> Perp2 A B E F P.

Lemma perp2_par : forall A B C D O, Perp2 A B C D O -> Par A B C D.

End L13_1_2D. *)

Require Import GeoCoq.Meta_theory.Continuity.grad.
(* GeoCoq.Meta_theory.Continuity.grad:
Require Import GeoCoq.Tarski_dev.Ch08_orthogonality.
Require Import Relations.

Section Grad.

Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.

Lemma grad__bet : forall A B C, Grad A B C -> Bet A B C.

Lemma grad__col : forall A B C, Grad A B C -> Col A B C.

Lemma grad_neq__neq13 : forall A B C, Grad A B C -> A <> B -> A <> C.

Lemma grad_neq__neq12 : forall A B C, Grad A B C -> A <> C -> A <> B.

Lemma grad112__eq : forall A B, Grad A A B -> A = B.

Lemma grad121__eq : forall A B, Grad A B A -> A = B.

Lemma grad__le : forall A B C, Grad A B C -> Le A B A C.

Lemma grad2__grad123 : forall A B C D E F, Grad2 A B C D E F -> Grad A B C.

Lemma grad2__grad456 : forall A B C D E F, Grad2 A B C D E F -> Grad D E F.

Lemma grad_sum : forall A B C D E,
  Grad A B C -> Grad A B D -> Bet A C E -> Cong A D C E ->
  Grad A B E.

Lemma gradexp__grad : forall A B C, GradExp A B C -> Grad A B C.

Lemma gradexp_le__reach : forall A B C D B',
  GradExp A B B' -> Le C D A B' ->
  Reach A B C D.

Lemma grad__ex_gradexp_le : forall A B C,
  Grad A B C ->
  exists D, GradExp A B D /\ Le A C A D.

Lemma reach__ex_gradexp_le : forall A B C D, Reach A B C D ->
  exists B', GradExp A B B' /\ Le C D A B'.

Lemma gradexp2__gradexp123 : forall A B C D E F,
  GradExp2 A B C D E F ->
  GradExp A B C.

Lemma gradexp2__gradexp456 : forall A B C D E F,
  GradExp2 A B C D E F ->
  GradExp D E F.

Inductive GradExpInv : Tpoint -> Tpoint -> Tpoint -> Prop :=
    gradexpinv_init : forall A B, GradExpInv A B B
  | gradexpinv_stab : forall A B B' C, Bet A B' B -> Cong A B' B' B -> GradExpInv A B C ->
                    GradExpInv A B' C.

Lemma gradexp_clos_trans : forall A B C, GradExp A B C <->
  clos_refl_trans_n1 Tpoint (fun X Y => Midpoint X A Y) B C.

Lemma gradexpinv_clos_trans : forall A B C, GradExpInv A B C <->
  clos_refl_trans_1n Tpoint (fun X Y => Midpoint X A Y) B C.

Lemma gradexp__gradexpinv : forall A B C, GradExp A B C <-> GradExpInv A B C.

Lemma reach__grad_min : forall A B C, A <> B -> Bet A B C -> Reach A B A C ->
  exists D E, Bet A D C /\ Grad A B D /\ E <> C /\ Bet A C E /\ Bet A D E /\ Cong A B D E.

Lemma reach__ex_gradexp_lt : forall A B P Q, A <> B -> Reach P Q A B ->
  exists C, GradExp A C B /\ Lt A C P Q.

End Grad.

Hint Resolve grad__bet : between.
Hint Resolve grad__col : col. *)



Section Archimedes.



Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.



Lemma t22_18_aux1 : forall A0 A1 E0 E1 D1 D,

  Bet A0 D1 A1 -> Cong E0 E1 A1 D1 ->

  Grad A0 D1 D ->

  exists A E, Grad2 A0 A1 A E0 E1 E /\ Cong E0 E A D /\ Bet A0 D A.

Proof.

  intros A0 A1 E0 E1 D1 D HBet HCong HG.

  induction HG.

    exists A1; exists E1; repeat split; auto; apply grad2_init.

  rename A into A0.

  rename B into C1.

  destruct IHHG as [A [E [HG2 [HCong2 HBet2]]]]; auto.

  destruct (segment_construction A0 A A0 A1) as [A' [HBet3 HCong3]].

  destruct (segment_construction E0 E E0 E1) as [E' [HBet4 HCong4]].

  exists A'; exists E'.

  assert(HBet5 : Bet A0 C' A').

  { assert(HBet5 : Bet A0 C A') by eBetween.

    assert(Bet C C' A'); [|eBetween].

    apply grad2__grad123 in HG2.

    apply grad__bet in HG.

    apply grad__bet in HG2.

    elim(eq_dec_points A0 C).

      intro; treat_equalities; Between.

    intro.

    elim(eq_dec_points C C').

      intro; treat_equalities; Between.

    intro.

    elim(eq_dec_points A' C).

      intro; subst A'; assert (A=C) by (apply (between_equality _ _ A0); Between); treat_equalities; Between.

    intro.

    apply l6_13_1.

      destruct (l6_2 C' A' A0 C); Between.

    apply (le_transitivity _ _ A A').

      apply (l5_6 A0 C1 A0 A1); Cong; exists C1; split; Cong.

    destruct(l5_12_a C A A'); eBetween.

  }

  repeat split; auto.

    apply grad2_stab with A E; Cong.

  assert (HD : Le E0 E1 A A').

    apply (l5_6 E0 E1 A1 A0); Cong; exists C1; split; Between.

  destruct HD as [D [HBet6 HCong6]].

  apply (cong_transitivity _ _ C D).

    apply (l2_11 _ E _ _ A); Cong; eBetween; apply cong_transitivity with E0 E1; trivial.

  assert (Bet C D A') by eBetween.

  apply (l4_3 _ _ A' _ _ C); Cong; eBetween.

  apply (cong_transitivity _ _ A0 C1); Cong.

  apply cong_left_commutativity; apply (l4_3 _ _ A _ _ A1); Between; Cong.

  apply cong_transitivity with E0 E1; Cong.

Qed.



Lemma t22_18_aux2 : forall A0 A1 B0 B1 A B E,

  Saccheri A0 B0 B1 A1 ->

  Grad2 A0 A1 A B0 B1 E -> Saccheri A0 B0 B A -> Le B0 B B0 E.

Proof.

  intros A0 A1 B0 B1 A B E HSac1 HG.

  revert B.

  induction HG; rename A into A0; rename B into A1; rename D into B0; rename E into B1.

  { intros B HSac.

    assert(B = B1); [|subst B; Le].

    assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac1); unfold Saccheri in *; spliter.

    apply (l6_11_uniqueness A1 A0 B0 B1); Cong; [|apply out_trivial; auto].

    apply (col_one_side_out _ A0).

      apply col_permutation_2, cop_per2__col with A0; Perp.

      apply coplanar_perm_3, coplanar_trans_1 with B0; Cop.

      apply not_col_permutation_2, one_side_not_col123 with B1; assumption.

    apply (one_side_transitivity _ _ _ B0); Side.

  }

  rename C into A; rename F into E; rename C' into A'; rename F' into E'.

  intros B' HSac'.

  assert (A0 <> A).

  { intro; treat_equalities.

    assert (A0 = A1) by (apply between_identity, grad__bet, (grad2__grad123 _ _ _ B0 B1 E); auto).

    treat_equalities.

    apply sac_distincts in HSac1; spliter; auto.

  }

  assert (HB : exists B, Saccheri A0 B0 B A).

  { clear dependent A'; clear dependent B'; clear IHHG.

    apply grad2__grad123 in HG.

    apply grad__bet in HG.

    destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]]; Col.

      assert (HH := sac__ncol124 A0 B0 B1 A1); Col.

    destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].

      assert_diffs; auto.

      assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac1); spliter; auto.

    exists B.

    unfold Saccheri in *; spliter; assert_diffs.

    repeat split; Cong.

    - apply (per_col _ _ A1); Col.

    - apply perp_per_2; auto.

      apply (perp_col1 _ _ _ P); Col.

      apply perp_comm; apply (perp_col _ A1); Col.

    - apply invert_one_side.

      apply (out_out_one_side _ _ _ P); [|apply l6_6; auto].

      apply invert_one_side.

      apply (col_one_side _ A1); Col.

  }

  destruct HB as [B HSac].

  assert (HLe := HSac).

  apply IHHG in HLe; auto.

  clear IHHG.

  destruct (segment_construction B0 B E E') as [C [HBet HCong]].

  assert (Cong B0 B1 B B').

    apply (cong2_sac2__cong A0 B0 B1 A1 A _ _ A'); auto; [|unfold Saccheri in *; spliter; Cong].

    apply cop_sac2__sac with A0 B0; Cop.

    intro; treat_equalities; apply sac_distincts in HSac1; spliter; auto.

  apply (le_transitivity _ _ B0 C).

    apply (triangle_inequality B0 B B' C); trivial.

    apply cong_transitivity with E E'; Cong.

    apply cong_transitivity with B0 B1; Cong.

  apply (bet2_le2__le1346 _ B _ _ E); Le.

Qed.



Lemma t22_18 :

  archimedes_axiom ->

  forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.

Proof.

  intros Harchi A0 B0 B1 A1 HSac.

  intro Hlt.

  destruct Hlt as [Hle HNcong].

  destruct Hle as [D1 [Hbet Hcong]].

  destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].

  destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].

  assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).

  { intros D HG.

    destruct (t22_18_aux1 A0 A1 B0 B1 D1 D) as [A [E [HG2 [Hcong4 Hbet4]]]]; Between.

    assert (Hbet5 := grad2__grad123 A0 A1 A B0 B1 E HG2).

    apply grad__bet in Hbet5.

    destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]].

      Col.

      assert (H := sac__ncol124 A0 B0 B1 A1); Col.

    destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].

      assert_diffs; auto.

      assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac); spliter; auto.

    assert(HSac2 : Saccheri A0 B0 B A).

    { unfold Saccheri in *; spliter; assert_diffs; assert(A0 <> A) by (intro; treat_equalities; auto).

      repeat split; Cong.

      - apply (per_col _ _ A1); Col.

      - apply perp_per_2; auto.

        apply (perp_col1 _ _ _ P); Col.

        apply perp_comm; apply (perp_col _ A1); Col.

      - apply invert_one_side.

        apply (out_out_one_side _ _ _ P); [|apply l6_6; auto].

        apply invert_one_side.

        apply (col_one_side _ A1); Col.

    }

    assert(HLe : Le B0 B B0 E) by (apply (t22_18_aux2 A0 A1 B0 B1 A); auto).

    assert (HLe2 : Le B0 B A A0).

      apply (le_transitivity _ _ B0 E); auto.

      apply (l5_6 A D A A0); Cong.

      destruct (l5_12_a A D A0); Between.

    assert (HLe2' := HLe2).

    destruct HLe2' as [Q [Hbet6 Hcong6]].

    apply (le1234_lt__lt _ _ A0 Q).

      apply (bet2_le2__le1245 _ _ A _ _ A); Between; Le.

      apply (l5_6 B0 B B0 E); Cong.

    clear dependent D; clear dependent E.

    destruct (l6_11_existence A0 A0 B0 A) as [B0' [HOut2 Hcong4]];

      try (assert_diffs; intro; treat_equalities; auto).

    destruct (segment_construction A0 B0' B0 B) as [B' [Hbet7 Hcong7]].

    destruct (segment_construction B0' B' B A) as [A' [Hbet8 Hcong8]].

    assert (Le A0 A A0 A'). 

    { destruct (segment_construction A0 B0' B0 A) as [B'' [Hbet9 Hcong9]].

      apply (le_transitivity _ _ A0 B'').

        apply (triangle_inequality_2 _ B0 _ _ B0'); Cong.

      apply (bet2_le2__le1346 _ B0' _ _ B0'); Le.

        apply (outer_transitivity_between _ _ B'); auto.

        intro; treat_equalities; apply sac_distincts in HSac2; spliter; auto.

      apply (l5_6 B0 A B0' A'); Cong.

      apply (triangle_inequality_2 _ B _ _ B'); Cong.

    }

    assert (HLe3 : Le B0 B A' B0').

      apply (l5_6 B0' B' B0' A'); Cong; destruct (l5_12_a B0' B' A'); auto.

    destruct HLe3 as [Q' [Hbet9 Hcong9]].

    assert (HBet10 : Bet A0 B0' A').

      apply sac_distincts in HSac2; spliter; assert_diffs.

      apply (outer_transitivity_between _ _ B'); Between.

    apply (le1234_lt__lt _ _ A0 Q').

      apply (bet2_le2__le1245 _ _ A' _ _ A); eBetween.

      apply cong__le; apply (cong_transitivity _ _ B0 B); Cong.

    assert (Cong B0' Q' A0 B0).

    { apply (cong_transitivity _ _ A B); Cong.

      apply (cong_transitivity _ _ A' B'); Cong.

      assert(Hcong10 : Cong B0' B' A' Q') by (apply (cong_transitivity _ _ B0 B); auto).

      elim(bet_dec B0' Q' B').

        intro; apply (l4_3 _ _ B' _ _ Q'); Cong; eBetween.

      intro HNBet.

      apply sac_distincts in HSac2; spliter; assert_diffs.

      assert (Q' <> B0') by (intro; apply HNBet; Between).

      assert (A' <> B0') by (intro; treat_equalities; auto).

      assert (HOut3 : Out B0' B' Q').

       apply (l6_7 _ _ A'); [| apply l6_6]; apply bet_out; Between.

      assert (Hbet11 : Bet B0' B' Q').

        apply out2__bet; auto.

        apply not_bet_out; Col.

      apply (l2_11 _ B' _ _ Q'); Cong; eBetween.

    }

    assert (Hbet10 : Bet A0 D1 C) by eBetween.

    apply (cong2_lt__lt D1 C A0 C); Cong; [split|].

      destruct (l5_12_a A0 D1 C); auto.

      intro; assert (D1 = A0) by (apply (between_cong C); Between; Cong); treat_equalities; Cong.

    apply (l2_11 _ C0 _ _ B0'); eBetween; apply cong_transitivity with A0 B0; Cong.

  }

  unfold archimedes_axiom in *.

  specialize Harchi with A0 D1 A0 C.

  destruct Harchi as [D [HG Hle]].

    intro; treat_equalities; auto.

  assert(HLt := HG).

  apply H in HLt.

  apply grad__le in HG.

  apply (le__nlt A0 C A0 D); auto.

Qed.



Lemma t22_19 :

  archimedes_axiom ->

  forall A B C D, Saccheri A B C D -> ~ Obtuse A B C.

Proof.

  intros archi A B C D HSac HObt.

  assert (H := t22_18 archi _ _ _ _ (sac_perm _ _ _ _ HSac)).

  apply H.

  apply lt_left_comm; apply <- lt_sac__obtuse; auto.

Qed.



Lemma archi__obtuse_case_elimination :

  archimedes_axiom ->

  ~ hypothesis_of_obtuse_saccheri_quadrilaterals.

Proof.

  intros archi obtuse.

  destruct ex_saccheri as [A [B [C [D HSac]]]].

  absurd(Obtuse A B C).

    apply t22_19 with D; trivial.

    apply obtuse with D; trivial.

Qed.



Lemma t22_23_aux :

  forall A B C M N L,

    ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B ->

    Per M N A -> Col A C N ->

    Midpoint M N L -> Bet A N C /\ Lambert N L B C /\ Cong B L A N.

Proof.

  intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.

  assert_diffs.

  assert (HBet : Bet A N C) by (apply per23_preserves_bet with M B; Perp; Col; Between).

  destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]]; auto with cong.

    apply l11_14; Between.

  assert(B <> L) by (intro; treat_equalities; auto).

  repeat split; Cong.

  - intro; treat_equalities; apply HNCol; ColR.

  - intro; treat_equalities; apply H6.

    apply (l6_21 A M N M); Col.

    apply col_permutation_3, cop_per2__col with A; Col; Cop.

  - apply per_col with A; Col.

    apply l8_2, per_col with M; Col; Perp.

  - apply l8_2, per_col with A; Col.

  - apply l11_17 with M N A; auto.

    apply (out_conga M N A M L B); auto; try (apply out_trivial; auto).

    apply bet_out; Between.

  - apply coplanar_perm_16, col_cop__cop with M; Col.

    apply coplanar_perm_12, col_cop__cop with A; Col; Cop.

Qed.



Lemma t22_23 :

  ~ hypothesis_of_obtuse_saccheri_quadrilaterals ->

  forall A B C M N L,

    ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B ->

    Per M N A -> Col A C N -> Midpoint M N L ->

    Bet A N C /\ Le N C A N /\ Le L N B C.

Proof.

  intros HNob A B C M N L HNCol HPerC HAC HM HPerN HColN HN.

  destruct (t22_23_aux A B C M N L) as [HBet [HLam HCong]]; auto.

  split; auto.

  assert (HLBC : ~ Obtuse L B C) by (intro; apply HNob, (lam_obtuse__oah N L B C); trivial).

  assert (Hos1 : OS N L B C) by (apply lam__os; trivial).

  assert (Hos2 : OS N C B L) by (apply lam__os, lam_perm; trivial).

  unfold Lambert in HLam; spliter.

  destruct (angle_partition L B C) as [HAcute | [HPer | HObtuse]]; trivial; [ | | exfalso; auto].

  - split; apply lt__le; [apply (cong2_lt__lt N C B L); Cong | ].

      apply lta_os_per2__lt; Perp; Side; apply lta_left_comm, acute_per__lta; auto.

    apply lt_left_comm, lta_os_per2__lt; Side; apply acute_per__lta; auto.

  - split; apply cong__le; [apply cong_transitivity with B L; trivial | apply cong_left_commutativity];

    apply conga_per2_os__cong; Perp; Side; apply l11_16; Perp.

Qed.



Lemma t22_24_aux :

  ~ hypothesis_of_obtuse_saccheri_quadrilaterals ->

  forall A B0 B00 C0 B C E,

    ~ Col A B0 C0 -> Perp A C0 B0 C0 -> B0 = B00 ->

    GradExp2 A B0 B B00 C0 E -> Perp A C0 B C -> Col A C0 C ->

    Le B0 E B C.

Proof.

  intros HNob A B0 B00 C0 B C E HNCol HPerp0 Heq HGE.

  revert C.

  induction HGE; rename B into B0; rename D into B00; rename E into C0; subst B00.

    intros C HPerp HCol; assert (C = C0) by (apply (l8_18_uniqueness A C0 B0); Col); subst C; Le.

  rename C into B; rename C' into B'; rename F into E; rename F' into E'.

  intros C' HPerp' HCol'.

  apply gradexp2__gradexp123, gradexp__grad, grad__bet in HGE.

  destruct (l8_18_existence A C0 B) as [C [HCol HPerp]].

    intro; assert_diffs; apply HNCol; ColR.

  assert (HLe : Le B0 E B C) by (apply IHHGE; trivial).

  clear IHHGE.

  destruct (symmetric_point_construction C B) as [D HD].

  apply le_transitivity with D C.

    apply bet2_le2__le1346 with E B; Between; apply (l5_6 B0 E B C); auto with cong.

  assert (HAC : A <> C).

  { intro; subst C; assert_diffs; assert (A = C0); auto.

    apply (l8_18_uniqueness A C0 B0); Col.

    apply perp_right_comm, perp_col1 with B; Perp; Col.

  }

  assert (HAC' : A <> C').

  { intro; subst C'; assert_diffs; assert (A = C0); auto.

    apply (l8_18_uniqueness A C0 B0); Col.

    apply perp_right_comm, perp_col1 with B'; Perp; ColR.

  }

  assert (HPer : Per A C B) by (apply perp_per_1; auto; apply perp_left_comm, perp_col with C0; trivial).

  destruct (t22_23 HNob A B' C' B C D) as [_ []]; Perp; assert_diffs.

  - apply per_not_col in HPer; Col.

  - apply perp_per_1; auto; apply perp_col1 with C0; Perp.

  - split; auto.

  - ColR.

Qed.



Lemma t22_24_aux1 : forall A B0 C0 E,

  ~ Col A B0 C0 -> Perp A C0 B0 C0 -> GradExp B0 C0 E ->

  exists B C, GradExp2 A B0 B B0 C0 E /\ Perp A C0 B C /\ Col A C0 C.

Proof.

  intros A B0 C0 E HNCol HPerp0 HGE.

  induction HGE; rename A0 into B0; rename B into C0.

    exists B0; exists C0; repeat (split; Col); apply gradexp2_init.

  rename C into E; rename C' into E'.

  destruct IHHGE as [B [C [HGE2 [HPerp HCol]]]]; trivial.

  destruct (segment_construction A B A B) as [B' [HBet HCong]].

  exists B'.

  destruct (l8_18_existence A C0 B') as [C' [HCol' HPerp']].

    apply gradexp2__gradexp123, gradexp__grad, grad__bet in HGE2; intro; assert_diffs; apply HNCol; ColR. 

  exists C'; repeat (split; trivial); apply gradexp2_stab with B E; Cong.

Qed.



Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.

Proof.

  intros Harchi P Q D A B0 HNCol HACute0.

  destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]]; Col.

  assert (HAC0 : A <> C0) by (intro; subst C0; apply (acute_not_per D A B0); Perp).

  assert (HNCol0 : ~ Col A B0 C0) by (intro; apply HNCol; ColR).

  assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).

  elim (eq_dec_points P Q); intro HPQ.

  { subst Q; exists C0; exists B0; split; assert_diffs.

      apply l6_6, acute_col_perp__out with B0; trivial; apply acute_sym; trivial.

    split.

      apply out_trivial; auto.

    repeat split; Perp; Le.

    intro; treat_equalities; auto.

  }

  destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].

  destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].

    assert_diffs; apply Harchi; trivial.

  destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]]; trivial.

  assert(HOut : Out A B0 B).

    apply gradexp2__gradexp123, gradexp__grad, grad__bet in HGE2; assert_diffs; apply bet_out; auto.

  assert(HAcute : Acute D A B).

    apply (acute_conga__acute D A B0); trivial.

    assert_diffs; apply (out_conga D A B0 D A B0); CongA; apply out_trivial; auto.

  assert (HAC : A <> C) .

    intro; subst C; assert_diffs; apply (acute_not_per D A B); trivial.

    apply perp_per_1; auto; apply perp_col with C0; Col.

  exists C; exists B; split.

    assert_diffs; apply l6_6, acute_col_perp__out with B; [apply acute_sym; trivial|ColR|apply perp_col with C0; Col].

  split; trivial; split.

    apply perp_per_1; auto; apply perp_left_comm, perp_col with C0; trivial.

  apply le3456_lt__lt with P Q'.

  split.

    apply bet__le1213; trivial.

    intro; assert (Q = Q'); treat_equalities; auto.

    apply between_cong with P; trivial.

  apply le_transitivity with B0 E; trivial.

  apply le_right_comm.

  apply t22_24_aux with A B0 C0; trivial.

  apply archi__obtuse_case_elimination; trivial.

Qed.



End Archimedes.
