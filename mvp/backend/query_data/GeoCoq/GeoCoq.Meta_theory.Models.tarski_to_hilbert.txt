Require Import GeoCoq.Tarski_dev.Ch12_parallel_inter_dec.
(* GeoCoq.Tarski_dev.Ch12_parallel_inter_dec:
Require Export GeoCoq.Meta_theory.Parallel_postulates.parallel_postulates.
Require Export GeoCoq.Meta_theory.Parallel_postulates.par_trans_NID.

Section T13.

Context `{TE:Tarski_euclidean}.

Lemma cop_npar__inter_exists : forall A1 B1 A2 B2,
  Coplanar A1 B1 A2 B2 -> ~ Par A1 B1 A2 B2 -> exists X, Col X A1 B1 /\ Col X A2 B2.

Lemma cop_npar__inter : forall A1 B1 A2 B2, A1 <> B1 -> A2 <> B2 ->
  Coplanar A1 B1 A2 B2 -> ~ Par A1 B1 A2 B2 -> exists X, Inter A1 B1 A2 B2 X.

Lemma parallel_uniqueness :
 forall A1 A2 B1 B2 C1 C2 P : Tpoint,
  Par A1 A2 B1 B2 -> Col P B1 B2 ->
  Par A1 A2 C1 C2 -> Col P C1 C2 ->
  Col C1 B1 B2 /\ Col C2 B1 B2.

Lemma par_trans : forall A1 A2 B1 B2 C1 C2,
  Par A1 A2 B1 B2 -> Par B1 B2 C1 C2 -> Par A1 A2 C1 C2.

Lemma inter__npar : forall A1 A2 B1 B2 X,
  Inter A1 A2 B1 B2 X -> ~ Par A1 A2 B1 B2.

Lemma l12_16 : forall A1 A2 B1 B2 C1 C2 X,
  Par A1 A2 B1 B2 -> Coplanar B1 B2 C1 C2 -> Inter A1 A2 C1 C2 X -> exists Y, Inter B1 B2 C1 C2 Y.

Lemma par_dec : forall A B C D, Par A B C D \/ ~ Par A B C D.

Lemma par_not_par : forall A B C D P Q, Par A B C D -> ~Par A B P Q -> ~Par C D P Q.

Lemma cop_par__inter : forall A B C D P Q,
  Par A B C D -> ~Par A B P Q -> Coplanar C D P Q ->
  exists Y, Col P Q Y /\ Col C D Y.

Lemma l12_19 :
  forall A B C D ,
   ~Col A B C -> Par A B C D -> Par B C D A ->
   Cong A B C D /\ Cong B C D A /\ TS B D A C /\ TS A C B D.

Lemma l12_20_bis :
  forall A B C D,
   Par A B C D -> Cong A B C D -> TS B D A C ->
   Par B C D A /\ Cong B C D A /\ TS A C B D.

Lemma l12_20 :
 forall A B C D,
  Par A B C D -> Cong A B C D -> TS A C B D ->
  Par B C D A /\ Cong B C D A /\ TS A C B D.

Lemma l12_21_a :
 forall A B C D,
  TS A C B D ->
  (Par A B C D -> CongA B A C D C A).

Lemma l12_21 : forall A B C D,
 TS A C B D ->
 (CongA B A C D C A <-> Par A B C D).

Lemma l12_22_a : forall A B C D P,
 Out P A C -> OS P A B D -> Par A B C D ->
 CongA B A P D C P.

Lemma l12_22 :
  forall A B C D P,
  Out P A C -> OS P A B D ->
  (CongA B A P D C P <-> Par A B C D).

Lemma l12_23 :
 forall A B C,
  ~Col A B C ->
  exists B', exists C',
  TS A C B B' /\ TS A B C C' /\
      Bet B' A C' /\ CongA A B C B A C' /\ CongA A C B C A B'.

Lemma cop_npars__inter_exists :
 forall A1 B1 A2 B2,
  Coplanar A1 B1 A2 B2 -> ~ Par_strict A1 B1 A2 B2 ->
  exists X, Col X A1 B1 /\ Col X A2 B2.

Lemma cop2_npar__inter : forall A B A' B' X Y,
  Coplanar A B X Y -> Coplanar A' B' X Y -> ~ Par A B A' B' ->
  (exists P, Col P X Y /\ (Col P A B \/ Col P A' B')).

Lemma not_par_one_not_par : forall A B A' B' X Y, ~Par A B A' B' -> ~Par A B X Y \/ ~Par A' B' X Y.

Lemma col_par_par_col : forall A B C A' B' C', Col A B C -> Par A B A' B' -> Par B C B' C' -> Col A' B' C'.

Lemma cop_par_perp__perp : forall A B C D P Q, Par A B C D -> Perp A B P Q -> Coplanar C D P Q ->
  Perp C D P Q.

Lemma cop4_par_perp2__par : forall A B C D E F G H,
  Par A B C D -> Perp A B E F -> Perp C D G H ->
  Coplanar A B E G -> Coplanar A B E H ->
  Coplanar A B F G -> Coplanar A B F H ->
  Par E F G H.

End T13.

Section T13_2D.

Context `{T2D:Tarski_2D}.
Context `{TE:@Tarski_euclidean Tn TnEQD}.

Lemma not_par_inter_exists : forall A1 B1 A2 B2,
  ~ Par A1 B1 A2 B2 -> exists X, Col X A1 B1 /\ Col X A2 B2.

Lemma l12_16_2D : forall A1 A2 B1 B2 C1 C2 X,
  Par A1 A2 B1 B2 -> Inter A1 A2 C1 C2 X -> exists Y, Inter B1 B2 C1 C2 Y.

Lemma par_inter : forall A B C D P Q,
  Par A B C D -> ~Par A B P Q ->
  exists Y, Col P Q Y /\ Col C D Y.

Lemma not_par_strict_inter_exists :
 forall A1 B1 A2 B2,
  ~Par_strict A1 B1 A2 B2 ->
  exists X, Col X A1 B1 /\ Col X A2 B2.

Lemma not_par_inter : forall A B A' B' X Y, ~Par A B A' B' -> (exists P, Col P X Y /\ (Col P A B \/ Col P A' B')).

Lemma par_perp__perp : forall A B C D P Q, Par A B C D -> Perp A B P Q ->
  Perp C D P Q.

Lemma par_perp2__par : forall A B C D E F G H,
  Par A B C D -> Perp A B E F -> Perp C D G H ->
  Par E F G H.

End T13_2D. *)

Require Import Morphisms.

Require Import GeoCoq.Axioms.hilbert_axioms.
(* GeoCoq.Axioms.hilbert_axioms:
Require Export Setoid.

Class Hilbert_neutral_dimensionless :=
{
 Point : Type;
 Line  : Type;
 Plane : Type;
 EqL   : Line -> Line -> Prop;
 EqL_Equiv : Equivalence EqL;
 EqP   : Plane -> Plane -> Prop;
 EqP_Equiv : Equivalence EqP;
 IncidL : Point -> Line -> Prop;
 IncidP : Point -> Plane -> Prop;

 IncidL_morphism :
   forall P l m, IncidL P l -> EqL l m -> IncidL P m;
 IncidL_dec : forall P l, IncidL P l \/ ~ IncidL P l;
 IncidP_morphism :
   forall M p q, IncidP M p -> EqP p q -> IncidP M q;
 IncidP_dec : forall M p, IncidP M p \/ ~ IncidP M p;
 eq_dec_pointsH : forall A B : Point, A=B \/ ~ A=B;

 line_existence :
   forall A B, A <> B -> exists l, IncidL A l /\ IncidL B l;
 line_uniqueness :
   forall A B l m,
     A <> B ->
     IncidL A l -> IncidL B l -> IncidL A m -> IncidL B m ->
     EqL l m;
 two_points_on_line :
   forall l,
     { A : Point & { B | IncidL B l /\ IncidL A l /\ A <> B}};
 ColH :=
   fun A B C => exists l, IncidL A l /\ IncidL B l /\ IncidL C l;
 PP : Point;
 PQ : Point;
 PR : Point;
 lower_dim_2 : PP <> PQ /\ PQ <> PR /\ PP <> PR /\ ~ ColH PP PQ PR;
 plane_existence :
   forall A B C, ~ ColH A B C -> exists p, IncidP A p /\ IncidP B p /\ IncidP C p;
 one_point_on_plane :
   forall p,
     { A | IncidP A p };
 plane_uniqueness :
   forall A B C p q,
     ~ ColH A B C ->
     IncidP A p -> IncidP B p -> IncidP C p -> IncidP A q -> IncidP B q -> IncidP C q ->
     EqP p q;
 IncidLP :=
   fun l p => forall A, IncidL A l -> IncidP A p;
 line_on_plane :
   forall A B l p,
     A <> B ->
     IncidL A l -> IncidL B l -> IncidP A p -> IncidP B p ->
     IncidLP l p;

 BetH   : Point -> Point -> Point -> Prop;
 between_diff : forall A B C, BetH A B C -> A <> C;
 between_col :  forall A B C, BetH A B C -> ColH A B C;
 between_comm : forall A B C, BetH A B C -> BetH C B A;
 between_out :  forall A B, A <> B -> exists C, BetH A B C;
 between_only_one : forall A B C, BetH A B C -> ~ BetH B C A;
 cut :=
   fun l A B => ~ IncidL A l /\ ~ IncidL B l /\
                exists I, IncidL I l /\ BetH A I B;
 pasch :
   forall A B C l p,
     ~ ColH A B C ->
     IncidP A p -> IncidP B p -> IncidP C p -> IncidLP l p -> ~ IncidL C l -> cut l A B ->
     cut l A C \/ cut l B C;

 CongH : Point -> Point -> Point -> Point -> Prop;
 cong_permr : forall A B C D, CongH A B C D -> CongH A B D C;
 outH :=
   fun P A B => BetH P A B \/ BetH P B A \/ (P <> A /\ A = B);
 cong_existence :
   forall A B A' P l,
     A <> B -> A' <> P ->
     IncidL A' l -> IncidL P l ->
     exists B', IncidL B' l /\ outH A' P B' /\ CongH A' B' A B;
 cong_pseudo_transitivity :
   forall A B C D E F,
     CongH A B C D -> CongH A B E F -> CongH C D E F;
 disjoint := fun A B C D => ~ exists P, BetH A P B /\ BetH C P D;
 addition :
   forall A B C A' B' C',
     ColH A B C -> ColH A' B' C' ->
     disjoint A B B C -> disjoint A' B' B' C' ->
     CongH A B A' B' -> CongH B C B' C' ->
     CongH A C A' C';
 CongaH :
   Point -> Point -> Point -> Point -> Point -> Point -> Prop;
 conga_refl : forall A B C, ~ ColH A B C -> CongaH A B C A B C;
 conga_comm : forall A B C, ~ ColH A B C -> CongaH A B C C B A;
 conga_permlr :
   forall A B C D E F, CongaH A B C D E F -> CongaH C B A F E D;
 same_side := fun A B l => exists P, cut l A P /\ cut l B P;
 same_side' :=
   fun A B X Y =>
     X <> Y /\
     forall l, IncidL X l -> IncidL Y l -> same_side A B l;
 conga_out_conga :
   forall A B C D E F A' C' D' F',
    CongaH A B C D E F ->
    outH B A A' -> outH B C C' -> outH E D D' -> outH E F F' ->
    CongaH A' B C' D' E F';
 cong_4_existence :
   forall A B C O X P,
     ~ ColH P O X -> ~ ColH A B C ->
     exists Y, CongaH A B C X O Y /\ same_side' P Y O X;
 cong_4_uniqueness :
   forall A B C O P X Y Y',
     ~ ColH P O X  -> ~ ColH A B C ->
     CongaH A B C X O Y -> CongaH A B C X O Y' ->
     same_side' P Y O X -> same_side' P Y' O X ->
     outH O Y Y';
 cong_5 :
   forall A B C A' B' C',
     ~ ColH A B C -> ~ ColH A' B' C' ->
     CongH A B A' B' -> CongH A C A' C' ->
     CongaH B A C B' A' C' ->
     CongaH A B C A' B' C'
}.

Class Hilbert_neutral_2D `(Hi : Hilbert_neutral_dimensionless) :=
{
 pasch_2D :
   forall A B C l,
     ~ ColH A B C -> ~ IncidL C l -> cut l A B ->
     cut l A C \/ cut l B C
}.

Class Hilbert_neutral_3D `(Hi : Hilbert_neutral_dimensionless) :=
{
 plane_intersection :
   forall A p q,
     IncidP A p -> IncidP A q -> exists B, IncidP B p /\ IncidP B q /\ A <> B;
 HS1 : Point;
 HS2 : Point;
 HS3 : Point;
 HS4 : Point;
 lower_dim_3 : ~ exists p, IncidP HS1 p /\ IncidP HS2 p /\ IncidP HS3 p /\ IncidP HS4 p
}.

Class Hilbert_euclidean `(Hi : Hilbert_neutral_dimensionless) :=
{
 Para :=
   fun l m => (~ exists X, IncidL X l /\ IncidL X m) /\ exists p, IncidLP l p /\ IncidLP m p;
 euclid_uniqueness :
   forall l P m1 m2,
     ~ IncidL P l ->
     Para l m1 -> IncidL P m1-> Para l m2 -> IncidL P m2 ->
     EqL m1 m2
}.

Class Hilbert_euclidean_ID `(H_euclidean : Hilbert_euclidean) :=
{
 decidability_of_intersection :
   forall l m,
     (exists I, IncidL I l /\ IncidL I m) \/
     ~ (exists I, IncidL I l /\ IncidL I m)
}. *)

Require Import GeoCoq.Axioms.parallel_postulates.
(* GeoCoq.Axioms.parallel_postulates:
Require Import GeoCoq.Tarski_dev.Definitions.

Section Euclid_def.

Context `{Tn:Tarski_neutral_dimensionless}.

Definition decidability_of_parallelism := forall A B C D,
  Par A B C D \/ ~ Par A B C D.

Definition decidability_of_not_intersection := forall A B C D,
  ~ (exists I, Col I A B /\ Col I C D) \/
  ~ ~ (exists I, Col I A B /\ Col I C D).

Definition decidability_of_intersection := forall A B C D,
  (exists I, Col I A B /\ Col I C D) \/
  ~ (exists I, Col I A B /\ Col I C D).

Definition tarski_s_parallel_postulate := forall A B C D T,
  Bet A D T -> Bet B D C -> A <> D ->
  exists X Y, Bet A B X /\ Bet A C Y /\ Bet X T Y.

Definition playfair_s_postulate := forall A1 A2 B1 B2 C1 C2 P,
  Par A1 A2 B1 B2 -> Col P B1 B2 ->
  Par A1 A2 C1 C2 -> Col P C1 C2 ->
  Col C1 B1 B2 /\ Col C2 B1 B2.

Definition triangle_postulate := forall A B C D E F,
  TriSumA A B C D E F -> Bet D E F.

Definition bachmann_s_lotschnittaxiom := forall P Q R P1 R1,
  P <> Q -> Q <> R -> Per P Q R -> Per Q P P1 -> Per Q R R1 ->
  Coplanar P Q R P1 -> Coplanar P Q R R1 ->
  exists S, Col P P1 S /\ Col R R1 S.

Definition postulate_of_transitivity_of_parallelism := forall A1 A2 B1 B2 C1 C2,
  Par A1 A2 B1 B2 -> Par B1 B2 C1 C2 ->
  Par A1 A2 C1 C2.

Definition midpoint_converse_postulate := forall A B C P Q,
  ~ Col A B C ->
  Midpoint P B C -> Par A B Q P -> Col A C Q ->
  Midpoint Q A C.

Definition alternate_interior_angles_postulate := forall A B C D,
  TS A C B D -> Par A B C D ->
  CongA B A C D C A.

Definition consecutive_interior_angles_postulate := forall A B C D,
  OS B C A D -> Par A B C D -> SuppA A B C B C D.

Definition perpendicular_transversal_postulate := forall A B C D P Q,
  Par A B C D -> Perp A B P Q -> Coplanar C D P Q ->
  Perp C D P Q.

Definition postulate_of_parallelism_of_perpendicular_transversals :=
  forall A1 A2 B1 B2 C1 C2 D1 D2,
    Par A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 ->
    Coplanar A1 A2 C1 D1 -> Coplanar A1 A2 C1 D2 ->
    Coplanar A1 A2 C2 D1 -> Coplanar A1 A2 C2 D2 ->
    Par C1 C2 D1 D2.

Definition universal_posidonius_postulate := forall A1 A2 A3 A4 B1 B2 B3 B4,
  Par A1 A2 B1 B2 ->
  Col A1 A2 A3 -> Col B1 B2 B3 -> Perp A1 A2 A3 B3 ->
  Col A1 A2 A4 -> Col B1 B2 B4 -> Perp A1 A2 A4 B4 ->
  Cong A3 B3 A4 B4.

Definition alternative_playfair_s_postulate := forall A1 A2 B1 B2 C1 C2 P,
  Perp2 A1 A2 B1 B2 P -> ~ Col A1 A2 P -> Col P B1 B2 -> Coplanar A1 A2 B1 B2 ->
  Par A1 A2 C1 C2 -> Col P C1 C2 ->
  Col C1 B1 B2 /\ Col C2 B1 B2.

Definition proclus_postulate := forall A B C D P Q,
  Par A B C D -> Col A B P -> ~ Col A B Q -> Coplanar C D P Q ->
  exists Y, Col P Q Y /\ Col C D Y.

Definition alternative_proclus_postulate := forall A B C D P Q,
  Perp2 A B C D P -> ~ Col C D P -> Coplanar A B C D ->
  Col A B P -> ~ Col A B Q -> Coplanar C D P Q ->
  exists Y, Col P Q Y /\ Col C D Y.

Definition triangle_circumscription_principle := forall A B C,
  ~ Col A B C ->
  exists CC, Cong A CC B CC /\ Cong A CC C CC /\ Coplanar A B C CC.

Definition inverse_projection_postulate := forall A B C P Q,
  Acute A B C ->
  Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q ->
  exists Y, Out B C Y /\ Col P Q Y.

Definition euclid_5 := forall P Q R S T U,
  BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S ->
  Cong P T Q T -> Cong R T S T ->
  exists I, BetS S Q I /\ BetS P U I.

Definition strong_parallel_postulate :=  forall P Q R S T U,
  BetS P T Q -> BetS R T S -> ~ Col P R U ->
  Coplanar P Q R U ->
  Cong P T Q T -> Cong R T S T ->
  exists I, Col S Q I /\ Col P U I.

Definition alternative_strong_parallel_postulate := forall A B C D P Q R,
  OS B C A D -> SumA A B C B C D P Q R -> ~ Bet P Q R ->
  exists Y, Col B A Y /\ Col C D Y.

Definition euclid_s_parallel_postulate := forall A B C D P Q R,
  OS B C A D -> SAMS A B C B C D -> SumA A B C B C D P Q R -> ~ Bet P Q R ->
  exists Y, Out B A Y /\ Out C D Y.

Definition postulate_of_existence_of_a_triangle_whose_angles_sum_to_two_rights :=
  exists A B C D E F, ~ Col A B C /\ TriSumA A B C D E F /\ Bet D E F.

Definition posidonius_postulate :=
  exists A1 A2 B1 B2,
    ~ Col A1 A2 B1 /\ B1 <> B2 /\ Coplanar A1 A2 B1 B2 /\
    forall A3 A4 B3 B4,
      Col A1 A2 A3 -> Col B1 B2 B3 -> Perp A1 A2 A3 B3 ->
      Col A1 A2 A4 -> Col B1 B2 B4 -> Perp A1 A2 A4 B4 ->
      Cong A3 B3 A4 B4.

Definition postulate_of_existence_of_similar_triangles :=
  exists A B C D E F,
    ~ Col A B C /\ ~ Cong A B D E /\
    CongA A B C D E F /\ CongA B C A E F D /\ CongA C A B F D E.

Definition thales_postulate := forall A B C M,
  ~ Col A B C -> Midpoint M A B -> Cong M A M C ->
  Per A C B.

Definition thales_converse_postulate := forall A B C M,
  ~ Col A B C -> Midpoint M A B -> Per A C B ->
  Cong M A M C.

Definition existential_thales_postulate :=
  exists A B C M, ~ Col A B C /\ Midpoint M A B /\ Cong M A M C /\ Per A C B.

Definition postulate_of_right_saccheri_quadrilaterals := forall A B C D,
  Saccheri A B C D -> Per A B C.

Definition postulate_of_existence_of_a_right_saccheri_quadrilateral :=
  exists A B C D, Saccheri A B C D /\ Per A B C.

Definition postulate_of_right_lambert_quadrilaterals := forall A B C D,
  Lambert A B C D -> Per B C D.

Definition postulate_of_existence_of_a_right_lambert_quadrilateral :=
  exists A B C D, Lambert A B C D /\ Per B C D.

Definition weak_inverse_projection_postulate := forall A B C D E F P Q,
  Acute A B C -> Per D E F -> SumA A B C A B C D E F ->
  Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q ->
  exists Y, Out B C Y /\ Col P Q Y.

Definition weak_tarski_s_parallel_postulate := forall A B C T,
  Per A B C -> InAngle T A B C ->
  exists X Y, Out B A X /\ Out B C Y /\ Bet X T Y.

Definition weak_triangle_circumscription_principle := forall A B C A1 A2 B1 B2,
  ~ Col A B C -> Per A C B ->
  Perp_bisect A1 A2 B C -> Perp_bisect B1 B2 A C ->
  Coplanar A B C A1 -> Coplanar A B C A2 ->
  Coplanar A B C B1 -> Coplanar A B C B2 ->
  exists I, Col A1 A2 I /\ Col B1 B2 I.

Definition legendre_s_parallel_postulate :=
  exists A B C,
    ~ Col A B C /\ Acute A B C /\
    forall T,
      InAngle T A B C ->
      exists X Y, Out B A X /\ Out B C Y /\ Bet X T Y.

Definition existential_playfair_s_postulate :=
  exists A1 A2 P, ~ Col A1 A2 P /\
             (forall B1 B2 C1 C2,
                Par A1 A2 B1 B2 -> Col P B1 B2 ->
                Par A1 A2 C1 C2 -> Col P C1 C2 ->
                Col C1 B1 B2 /\ Col C2 B1 B2).

End Euclid_def. *)

Require Import GeoCoq.Meta_theory.Parallel_postulates.tarski_playfair.
(* GeoCoq.Meta_theory.Parallel_postulates.tarski_playfair:
Require Import GeoCoq.Axioms.parallel_postulates.
Require Import GeoCoq.Tarski_dev.Ch12_parallel.

Section tarski_playfair.

Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.

Lemma tarski_s_euclid_implies_playfair :
 tarski_s_parallel_postulate ->
 playfair_s_postulate.

End tarski_playfair. *)

Require Import GeoCoq.Meta_theory.Parallel_postulates.SPP_ID.
(* GeoCoq.Meta_theory.Parallel_postulates.SPP_ID:
Require Import GeoCoq.Axioms.parallel_postulates.
Require Import GeoCoq.Tarski_dev.Ch12_parallel.

Section SPP_ID.

Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.

Lemma strong_parallel_postulate_implies_inter_dec :
  strong_parallel_postulate ->
  decidability_of_intersection.

End SPP_ID. *)

Require Import GeoCoq.Meta_theory.Dimension_axioms.upper_dim_3.
(* GeoCoq.Meta_theory.Dimension_axioms.upper_dim_3:
Require Export GeoCoq.Tarski_dev.Ch11_angles.
Require Import GeoCoq.Utils.all_equiv.

Section Upper_dim_3.

Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.

Definition upper_dim_3_axiom := forall A B C P Q R,
  P <> Q -> Q <> R -> P <> R ->
  Cong A P A Q -> Cong B P B Q -> Cong C P C Q ->
  Cong A P A R -> Cong B P B R -> Cong C P C R ->
  (Bet A B C \/ Bet B C A \/ Bet C A B).

Definition median_planes_axiom := forall A B C D P Q, P <> Q ->
  Cong A P A Q -> Cong B P B Q -> Cong C P C Q -> Cong D P D Q ->
  Coplanar A B C D.

Definition plane_intersection_axiom := forall A B C D E F P,
  Coplanar A B C P -> Coplanar D E F P ->
  exists Q, Coplanar A B C Q /\ Coplanar D E F Q /\ P <> Q.

Definition space_separation_axiom := forall A B C P Q,
  ~ Coplanar A B C P -> ~ Coplanar A B C Q -> TSP A B C P Q \/ OSP A B C P Q.

Definition orthonormal_family_axiom := forall S U1' U1 U2 U3 U4,
  ~ (S <> U1' /\ Bet U1 S U1' /\
     Cong S U1 S U1' /\ Cong S U2 S U1' /\ Cong S U3 S U1' /\ Cong S U4 S U1' /\
     Cong U1 U2 U1' U2 /\ Cong U1 U3 U1' U2 /\ Cong U1 U4 U1' U2 /\
     Cong U2 U3 U1' U2 /\ Cong U2 U4 U1' U2 /\ Cong U3 U4 U1' U2).

Lemma upper_dim_3_stab : ~ ~ upper_dim_3_axiom -> upper_dim_3_axiom.

Lemma median_planes_implies_upper_dim : median_planes_axiom -> upper_dim_3_axiom.

Lemma median_planes_aux :
  (forall A B C P Q M, P <> Q -> Cong A P A Q -> Cong B P B Q -> Cong C P C Q -> Midpoint M P Q ->
                       Coplanar M A B C) ->
  median_planes_axiom.

Lemma orthonormal_family_aux : orthonormal_family_axiom <->
  (forall A B X P Q, ~ Col P Q X -> Per A X P -> Per A X Q -> Per B X P -> Per B X Q -> Col A B X).

Lemma upper_dim_implies_orthonormal_family_axiom : upper_dim_3_axiom -> orthonormal_family_axiom.

Lemma orthonormal_family_axiom_implies_orth_at2__col :
  orthonormal_family_axiom ->
  (forall A B C P Q X, Orth_at X A B C X P -> Orth_at X A B C X Q -> Col P Q X).

Lemma orthonormal_family_axiom_implies_not_two_sides_one_side :
  orthonormal_family_axiom ->
  (forall A B C X Y, ~ Coplanar A B C X -> ~ Coplanar A B C Y -> ~ TSP A B C X Y -> OSP A B C X Y).

Lemma orthonormal_family_axiom_implies_space_separation :
  orthonormal_family_axiom -> space_separation_axiom.

Lemma space_separation_implies_plane_intersection : space_separation_axiom -> plane_intersection_axiom.

Lemma plane_intersection_implies_space_separation :
  plane_intersection_axiom -> space_separation_axiom.

Lemma space_separation_implies_median_planes : space_separation_axiom -> median_planes_axiom.

Theorem upper_dim_3_equivalent_axioms : all_equiv (upper_dim_3_axiom::
                                                   orthonormal_family_axiom::
                                                   space_separation_axiom::
                                                   plane_intersection_axiom::
                                                   median_planes_axiom::
                                                   nil).

End Upper_dim_3. *)

Require Import GeoCoq.Meta_theory.Parallel_postulates.parallel_postulates.
(* GeoCoq.Meta_theory.Parallel_postulates.parallel_postulates:
Require Import GeoCoq.Axioms.continuity_axioms.
Require Export GeoCoq.Axioms.parallel_postulates.
Require Export GeoCoq.Meta_theory.Parallel_postulates.SPP_tarski.
Require Export GeoCoq.Meta_theory.Parallel_postulates.alternate_interior_angles_consecutive_interior_angles.
Require Export GeoCoq.Meta_theory.Parallel_postulates.alternate_interior_angles_playfair_bis.
Require Export GeoCoq.Meta_theory.Parallel_postulates.alternate_interior_angles_triangle.
Require Export GeoCoq.Meta_theory.Parallel_postulates.alternate_interior_angles_proclus.
Require Export GeoCoq.Meta_theory.Parallel_postulates.bachmann_s_lotschnittaxiom_legendre_s_parallel_postulate.
Require Export GeoCoq.Meta_theory.Parallel_postulates.bachmann_s_lotschnittaxiom_weak_inverse_projection_postulate.
Require Export GeoCoq.Meta_theory.Parallel_postulates.bachmann_s_lotschnittaxiom_weak_triangle_circumscription_principle.
Require Export GeoCoq.Meta_theory.Parallel_postulates.consecutive_interior_angles_alternate_interior_angles.
Require Export GeoCoq.Meta_theory.Parallel_postulates.existential_playfair_rah.
Require Export GeoCoq.Meta_theory.Parallel_postulates.existential_saccheri_rah.
Require Export GeoCoq.Meta_theory.Parallel_postulates.inverse_projection_postulate_proclus_bis.
Require Export GeoCoq.Meta_theory.Parallel_postulates.legendre.
Require Export GeoCoq.Meta_theory.Parallel_postulates.midpoint_playfair.
Require Export GeoCoq.Meta_theory.Parallel_postulates.original_euclid_original_spp.
Require Export GeoCoq.Meta_theory.Parallel_postulates.original_spp_inverse_projection_postulate.
Require Export GeoCoq.Meta_theory.Parallel_postulates.par_perp_2_par_par_perp_perp.
Require Export GeoCoq.Meta_theory.Parallel_postulates.par_perp_perp_par_perp_2_par.
Require Export GeoCoq.Meta_theory.Parallel_postulates.par_perp_perp_playfair.
Require Export GeoCoq.Meta_theory.Parallel_postulates.par_trans_playfair.
Require Export GeoCoq.Meta_theory.Parallel_postulates.playfair_existential_playfair.
Require Export GeoCoq.Meta_theory.Parallel_postulates.playfair_midpoint.
Require Export GeoCoq.Meta_theory.Parallel_postulates.playfair_par_trans.
Require Export GeoCoq.Meta_theory.Parallel_postulates.posidonius_postulate_rah.
Require Export GeoCoq.Meta_theory.Parallel_postulates.proclus_aristotle.
Require Export GeoCoq.Meta_theory.Parallel_postulates.proclus_bis_proclus.
Require Export GeoCoq.Meta_theory.Parallel_postulates.rah_existential_saccheri.
Require Export GeoCoq.Meta_theory.Parallel_postulates.rah_rectangle_principle.
Require Export GeoCoq.Meta_theory.Parallel_postulates.rah_similar.
Require Export GeoCoq.Meta_theory.Parallel_postulates.rah_thales_postulate.
Require Export GeoCoq.Meta_theory.Parallel_postulates.rah_posidonius_postulate.
Require Export GeoCoq.Meta_theory.Parallel_postulates.rectangle_existence_rah.
Require Export GeoCoq.Meta_theory.Parallel_postulates.rectangle_principle_rectangle_existence.
Require Export GeoCoq.Meta_theory.Parallel_postulates.similar_rah.
Require Export GeoCoq.Meta_theory.Parallel_postulates.tarski_playfair.
Require Export GeoCoq.Meta_theory.Parallel_postulates.thales_converse_postulate_thales_existence.
Require Export GeoCoq.Meta_theory.Parallel_postulates.thales_converse_postulate_weak_triangle_circumscription_principle.
Require Export GeoCoq.Meta_theory.Parallel_postulates.thales_existence_rah.
Require Export GeoCoq.Meta_theory.Parallel_postulates.thales_postulate_thales_converse_postulate.
Require Export GeoCoq.Meta_theory.Parallel_postulates.weak_inverse_projection_postulate_bachmann_s_lotschnittaxiom.
Require Export GeoCoq.Meta_theory.Parallel_postulates.weak_inverse_projection_postulate_weak_tarski_s_parallel_postulate.
Require Export GeoCoq.Meta_theory.Parallel_postulates.weak_tarski_s_parallel_postulate_weak_inverse_projection_postulate.
Require Export GeoCoq.Meta_theory.Parallel_postulates.weak_triangle_circumscription_principle_bachmann_s_lotschnittaxiom.
Require Export GeoCoq.Tarski_dev.Annexes.saccheri.
Require Export GeoCoq.Tarski_dev.Annexes.perp_bisect.
Require Export GeoCoq.Tarski_dev.Annexes.quadrilaterals.
Require Export GeoCoq.Tarski_dev.Ch13_1.

Require Import GeoCoq.Utils.all_equiv.

Require Import Rtauto.

Section Euclid.

Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.

Theorem equivalent_postulates_without_decidability_of_intersection_of_lines :
  all_equiv
    (alternate_interior_angles_postulate::
     alternative_playfair_s_postulate::
     consecutive_interior_angles_postulate::
     midpoint_converse_postulate::
     perpendicular_transversal_postulate::
     playfair_s_postulate::
     universal_posidonius_postulate::
     postulate_of_parallelism_of_perpendicular_transversals::
     postulate_of_transitivity_of_parallelism::
     nil).

Theorem equivalent_postulates_without_any_continuity :
  all_equiv
    (existential_thales_postulate::
     posidonius_postulate::
     postulate_of_existence_of_a_right_lambert_quadrilateral::
     postulate_of_existence_of_a_right_saccheri_quadrilateral::
     postulate_of_existence_of_a_triangle_whose_angles_sum_to_two_rights::
     postulate_of_existence_of_similar_triangles::
     postulate_of_right_lambert_quadrilaterals::
     postulate_of_right_saccheri_quadrilaterals::
     thales_postulate::
     thales_converse_postulate::
     triangle_postulate::
     nil).

Theorem equivalent_postulates_with_decidability_of_intersection_of_lines :
  decidability_of_intersection ->
  all_equiv
    (alternate_interior_angles_postulate::
     alternative_playfair_s_postulate::
     alternative_proclus_postulate::
     alternative_strong_parallel_postulate::
     consecutive_interior_angles_postulate::
     euclid_5::
     euclid_s_parallel_postulate::
     inverse_projection_postulate::
     midpoint_converse_postulate::
     perpendicular_transversal_postulate::
     playfair_s_postulate::
     universal_posidonius_postulate::
     postulate_of_parallelism_of_perpendicular_transversals::
     postulate_of_transitivity_of_parallelism::
     proclus_postulate::
     strong_parallel_postulate::
     tarski_s_parallel_postulate::
     triangle_circumscription_principle::
     nil).

Theorem equivalent_postulates_without_decidability_of_intersection_of_lines_bis :
  all_equiv
    (alternative_strong_parallel_postulate::
     alternative_proclus_postulate::
     euclid_5::
     euclid_s_parallel_postulate::
     inverse_projection_postulate::
     proclus_postulate::
     strong_parallel_postulate::
     tarski_s_parallel_postulate::
     triangle_circumscription_principle::
     nil).

Theorem stronger_postulates :
  stronger
    (alternative_strong_parallel_postulate::
     alternative_proclus_postulate::
     euclid_5::
     euclid_s_parallel_postulate::
     inverse_projection_postulate::
     proclus_postulate::
     strong_parallel_postulate::
     tarski_s_parallel_postulate::
     triangle_circumscription_principle::
     nil)

    (alternate_interior_angles_postulate::
     alternative_playfair_s_postulate::
     consecutive_interior_angles_postulate::
     midpoint_converse_postulate::
     perpendicular_transversal_postulate::
     playfair_s_postulate::
     universal_posidonius_postulate::
     postulate_of_parallelism_of_perpendicular_transversals::
     postulate_of_transitivity_of_parallelism::
     nil).

Theorem stronger_postulates_bis :
  stronger
    (alternate_interior_angles_postulate::
     alternative_playfair_s_postulate::
     consecutive_interior_angles_postulate::
     midpoint_converse_postulate::
     perpendicular_transversal_postulate::
     playfair_s_postulate::
     universal_posidonius_postulate::
     postulate_of_parallelism_of_perpendicular_transversals::
     postulate_of_transitivity_of_parallelism::
     nil)

    (existential_thales_postulate::
     posidonius_postulate::
     postulate_of_existence_of_a_right_lambert_quadrilateral::
     postulate_of_existence_of_a_right_saccheri_quadrilateral::
     postulate_of_existence_of_a_triangle_whose_angles_sum_to_two_rights::
     postulate_of_existence_of_similar_triangles::
     postulate_of_right_lambert_quadrilaterals::
     postulate_of_right_saccheri_quadrilaterals::
     thales_postulate::
     thales_converse_postulate::
     triangle_postulate::
     nil).

Theorem equivalence_of_aristotle_greenberg_and_decidability_of_intersection :
  all_equiv_under
    (alternate_interior_angles_postulate::
     alternative_playfair_s_postulate::
     alternative_proclus_postulate::
     alternative_strong_parallel_postulate::
     consecutive_interior_angles_postulate::
     euclid_5::
     euclid_s_parallel_postulate::
     inverse_projection_postulate::
     midpoint_converse_postulate::
     perpendicular_transversal_postulate::
     playfair_s_postulate::
     universal_posidonius_postulate::
     postulate_of_parallelism_of_perpendicular_transversals::
     postulate_of_transitivity_of_parallelism::
     proclus_postulate::
     strong_parallel_postulate::
     tarski_s_parallel_postulate::
     triangle_circumscription_principle::
     nil)

    (aristotle_s_axiom::
     greenberg_s_axiom::
     decidability_of_intersection::
     nil).

Theorem equivalent_postulates_assuming_greenberg_s_axiom :
  greenberg_s_axiom ->
  all_equiv
    (alternate_interior_angles_postulate::
     alternative_playfair_s_postulate::
     alternative_proclus_postulate::
     alternative_strong_parallel_postulate::
     consecutive_interior_angles_postulate::
     euclid_5::
     euclid_s_parallel_postulate::
     existential_playfair_s_postulate::
     existential_thales_postulate::
     inverse_projection_postulate::
     midpoint_converse_postulate::
     perpendicular_transversal_postulate::
     postulate_of_transitivity_of_parallelism::
     playfair_s_postulate::
     posidonius_postulate::
     universal_posidonius_postulate::
     postulate_of_existence_of_a_right_lambert_quadrilateral::
     postulate_of_existence_of_a_right_saccheri_quadrilateral::
     postulate_of_existence_of_a_triangle_whose_angles_sum_to_two_rights::
     postulate_of_existence_of_similar_triangles::
     postulate_of_parallelism_of_perpendicular_transversals::
     postulate_of_right_lambert_quadrilaterals::
     postulate_of_right_saccheri_quadrilaterals::
     postulate_of_transitivity_of_parallelism::
     proclus_postulate::
     strong_parallel_postulate::
     tarski_s_parallel_postulate::
     thales_postulate::
     thales_converse_postulate::
     triangle_circumscription_principle::
     triangle_postulate::
     nil).

Theorem equivalent_postulates_without_any_continuity_bis :
  all_equiv
    (bachmann_s_lotschnittaxiom::
     weak_inverse_projection_postulate::
     weak_tarski_s_parallel_postulate::
     weak_triangle_circumscription_principle::
     nil).

Theorem stronger_postulates_ter :
  stronger
    (existential_thales_postulate::
     posidonius_postulate::
     postulate_of_existence_of_a_right_lambert_quadrilateral::
     postulate_of_existence_of_a_right_saccheri_quadrilateral::
     postulate_of_existence_of_a_triangle_whose_angles_sum_to_two_rights::
     postulate_of_existence_of_similar_triangles::
     postulate_of_right_lambert_quadrilaterals::
     postulate_of_right_saccheri_quadrilaterals::
     thales_postulate::
     thales_converse_postulate::
     triangle_postulate::
     nil)

    (legendre_s_parallel_postulate::
     bachmann_s_lotschnittaxiom::
     weak_inverse_projection_postulate::
     weak_tarski_s_parallel_postulate::
     weak_triangle_circumscription_principle::
     nil).

Theorem equivalent_postulates_assuming_archimedes_axiom :
  archimedes_axiom ->
  all_equiv
    (alternate_interior_angles_postulate::
     alternative_playfair_s_postulate::
     alternative_proclus_postulate::
     alternative_strong_parallel_postulate::
     bachmann_s_lotschnittaxiom::
     consecutive_interior_angles_postulate::
     euclid_5::
     euclid_s_parallel_postulate::
     existential_playfair_s_postulate::
     existential_thales_postulate::
     inverse_projection_postulate::
     legendre_s_parallel_postulate::
     midpoint_converse_postulate::
     perpendicular_transversal_postulate::
     postulate_of_transitivity_of_parallelism::
     playfair_s_postulate::
     posidonius_postulate::
     universal_posidonius_postulate::
     postulate_of_existence_of_a_right_lambert_quadrilateral::
     postulate_of_existence_of_a_right_saccheri_quadrilateral::
     postulate_of_existence_of_a_triangle_whose_angles_sum_to_two_rights::
     postulate_of_existence_of_similar_triangles::
     postulate_of_parallelism_of_perpendicular_transversals::
     postulate_of_right_lambert_quadrilaterals::
     postulate_of_right_saccheri_quadrilaterals::
     postulate_of_transitivity_of_parallelism::
     proclus_postulate::
     strong_parallel_postulate::
     tarski_s_parallel_postulate::
     thales_postulate::
     thales_converse_postulate::
     triangle_circumscription_principle::
     triangle_postulate::
     weak_inverse_projection_postulate::
     weak_tarski_s_parallel_postulate::
     weak_triangle_circumscription_principle::
     nil).

End Euclid.

Section Euclidean.

Context `{TE:Tarski_euclidean}.

Lemma inter_dec : forall A B C D,
  (exists I, Col I A B /\ Col I C D) \/ ~ (exists I, Col I A B /\ Col I C D).

Lemma aristotle : forall P Q A B C, ~ Col A B C -> Acute A B C ->
  exists X Y, Out B A X /\ Out B C Y /\ Per B X Y /\ Lt P Q X Y.

Lemma greenberg : forall P Q R A B C, ~ Col A B C ->
  Acute A B C -> Q <> R -> Per P Q R ->
  exists S, LtA P S Q A B C /\ Out Q S R.

Theorem postulates_in_euclidean_context : forall P, List.In P

End Euclidean. *)



Require Export GeoCoq.Utils.triples.



Section T.



Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.



Definition Line := @Couple Tpoint.

Definition Lin := build_couple Tpoint.



Definition IncidentL := fun A l => Col A (P1 l) (P2 l).



Lemma axiom_line_existence : forall A B, A<>B -> exists l, IncidentL A l /\ IncidentL B l.

Proof.

intros.

exists (Lin A B H).

unfold IncidentL.

intuition.

Qed.



Definition EqL : relation Line := fun l m => forall X, IncidentL X l <-> IncidentL X m.



Infix "=l=" := EqL (at level 70):type_scope.



Lemma incident_eq : forall A B l, forall H : A<>B,

 IncidentL A l -> IncidentL B l ->

 (Lin A B H) =l= l.

Proof.

intros.

unfold EqL.

intros.

unfold IncidentL in *.

replace (P1 (Lin A B H)) with A; trivial.

replace (P2 (Lin A B H)) with B; trivial.

split;intro.

assert (T:=Cond l).

elim (eq_dec_points X B); intro.

subst X.

auto.

assert (Col (P1 l) A B).

apply col_transitivity_1 with (P2 l); Col.

assert (Col (P2 l) A B).

apply (col_transitivity_2 (P1 l)); Col.

apply (col3 A B); Col.



assert (U:=Cond l).

apply (col3 (P1 l) (P2 l)); Col.

Qed.



Lemma eq_transitivity : forall l m n, l =l= m -> m =l= n -> l =l= n.

Proof.

unfold EqL,IncidentL.

intros.

assert (T:=H X).

assert (V:= H0 X).

split;intro;intuition.

Qed.



Lemma eq_reflexivity : forall l, l =l= l.

Proof.

intros.

unfold EqL.

intuition.

Qed.



Lemma eq_symmetry : forall l m, l =l= m -> m =l= l.

Proof.

unfold EqL.

intros.

assert (T:=H X).

intuition.

Qed.



Instance EqL_Equiv : Equivalence EqL.

Proof.

split.

unfold Reflexive.

apply eq_reflexivity.

unfold Symmetric.

apply eq_symmetry.

unfold Transitive.

apply eq_transitivity.

Defined.



Lemma eq_incident : forall A l m, l =l= m ->

 (IncidentL A l <-> IncidentL A m).

Proof.

intros.

split;intros;

unfold EqL in *;

assert (T:= H A);

intuition.

Qed.



Instance incident_Proper (A:Tpoint) :

Proper (EqL ==>iff) (IncidentL A).

Proof.

intros a b H .

apply eq_incident.

assumption.

Defined.



Lemma axiom_Incid_morphism :

 forall P l m, IncidentL P l -> EqL l m -> IncidentL P m.

Proof.

intros.

destruct (eq_incident P l m H0).

intuition.

Qed.



Lemma axiom_Incid_dec : forall P l, IncidentL P l \/ ~IncidentL P l.

Proof.

intros.

unfold IncidentL.

apply col_dec.

Qed.



Lemma axiom_line_uniqueness : forall A B l m, A <> B ->

 IncidentL A l -> IncidentL B l -> IncidentL A m -> IncidentL B m ->

 l =l= m.

Proof.

intros.

assert ((Lin A B H) =l= l).

eapply incident_eq;assumption.

assert ((Lin A B H) =l= m).

eapply incident_eq;assumption.

rewrite <- H4.

assumption.

Qed.



Lemma axiom_two_points_on_line : forall l,

  { A : Tpoint & { B | IncidentL B l /\ IncidentL A l /\ A <> B}}.

Proof.

intros.

exists (P1 l).

exists (P2 l).

unfold IncidentL.

repeat split;Col.

exact (Cond l).

Qed.



Definition Col_H := fun A B C =>

  exists l, IncidentL A l /\ IncidentL B l /\ IncidentL C l.



Lemma cols_coincide_1 : forall A B C, Col_H A B C -> Col A B C.

Proof.

intros.

unfold Col_H in H.

DecompExAnd H l.

unfold IncidentL in *.

assert (T:=Cond l).

apply (col3 (P1 l) (P2 l)); Col.

Qed.



Lemma cols_coincide_2 : forall A B C, Col A B C -> Col_H A B C.

Proof.

intros.

unfold Col_H.

elim (eq_dec_points A B); intro.

subst B.

elim (eq_dec_points A C); intro.

subst C.

assert (exists B, A<>B).

eapply another_point.

DecompEx H0 B.

exists (Lin A B H1).

unfold IncidentL;intuition.

exists (Lin A C H0).

unfold IncidentL;intuition.

exists (Lin A B H0).

unfold IncidentL;intuition.

Qed.



Lemma cols_coincide : forall A B C, Col A B C <-> Col_H A B C.

Proof.

intros.

split.

apply cols_coincide_2.

apply cols_coincide_1.

Qed.



Lemma ncols_coincide : forall A B C, ~ Col A B C <-> ~ Col_H A B C.

Proof.

intros.

split; intros HNCol HCol; apply HNCol, cols_coincide, HCol.

Qed.



Lemma lower_dim' : PA <> PB /\ PB <> PC /\ PA <> PC /\ ~ Col_H PA PB PC.

Proof.

assert (HNCol : ~ Col PA PB PC) by (apply lower_dim).

assert_diffs.

apply ncols_coincide in HNCol.

repeat split; auto.

Qed.



Record Plane := Plan {M1; M2; M3; NCol : ~ Col_H M1 M2 M3}.



Definition IncidentP := fun A p => Coplanar (M1 p) (M2 p) (M3 p) A.



Lemma axiom_plane_existence : forall A B C, ~ Col_H A B C ->

  exists p, IncidentP A p /\ IncidentP B p /\ IncidentP C p.

Proof.

intros A B C HNCol.

exists (Plan A B C HNCol).

unfold IncidentP; simpl; repeat split; Cop.

Qed.



Definition EqP : relation Plane := fun p q => forall X, IncidentP X p <-> IncidentP X q.



Infix "=p=" := EqP (at level 70):type_scope.



Lemma incidentp_eqp : forall A B C p, forall H : ~ Col_H A B C,

 IncidentP A p -> IncidentP B p -> IncidentP C p ->

 (Plan A B C H) =p= p.

Proof.

intros A B C p HNCol HA HB HC X.

unfold IncidentP in *; simpl.

assert (Hp := NCol p).

apply ncols_coincide in Hp.

apply ncols_coincide in HNCol.

split; intro; [apply coplanar_pseudo_trans with A B C; trivial|];

apply coplanar_pseudo_trans with (M1 p) (M2 p) (M3 p); Cop.

Qed.



Lemma eqp_transitivity : forall p q r, p =p= q -> q =p= r -> p =p= r.

Proof.

intros p q r H1 H2 X.

rewrite (H1 X); apply H2.

Qed.



Lemma eqp_reflexivity : forall p, p =p= p.

Proof.

intros.

unfold EqP.

intuition.

Qed.



Lemma eqp_symmetry : forall p q, p =p= q -> q =p= p.

Proof.

unfold EqP.

intros p q H X.

assert (T := H X).

intuition.

Qed.



Instance EqP_Equiv : Equivalence EqP.

Proof.

split.

unfold Reflexive.

apply eqp_reflexivity.

unfold Symmetric.

apply eqp_symmetry.

unfold Transitive.

apply eqp_transitivity.

Defined.



Lemma eqp_incidentp : forall A p q, p =p= q ->

 (IncidentP A p <-> IncidentP A q).

Proof.

intros A p q H.

exact (H A).

Qed.



Instance incidentp_Proper (A:Tpoint) :

Proper (EqP ==>iff) (IncidentP A).

Proof.

intros a b H.

apply eqp_incidentp.

assumption.

Defined.



Lemma axiom_Incidp_morphism :

 forall M p q, IncidentP M p -> EqP p q -> IncidentP M q.

Proof.

intros M p q Hp H.

destruct (eqp_incidentp M p q H).

intuition.

Qed.



Lemma axiom_Incidp_dec : forall M p, IncidentP M p \/ ~ IncidentP M p.

Proof.

intros.

apply cop_dec.

Qed.



Lemma axiom_plane_uniqueness : forall A B C p q, ~ Col_H A B C ->

 IncidentP A p -> IncidentP B p -> IncidentP C p ->

 IncidentP A q -> IncidentP B q -> IncidentP C q ->

 p =p= q.

Proof.

intros A B C p q H; intros.

assert (Heq : (Plan A B C H) =p= p).

apply incidentp_eqp;assumption.

assert ((Plan A B C H) =p= q).

apply incidentp_eqp;assumption.

rewrite <- Heq.

assumption.

Qed.



Lemma axiom_one_point_on_plane : forall p,

  { A | IncidentP A p }.

Proof.

intro p.

exists (M1 p).

unfold IncidentP; Cop.

Qed.



Definition  IncidentLP := fun l p => forall A, IncidentL A l -> IncidentP A p.



Lemma axiom_line_on_plane : forall A B l p, A <> B ->

 IncidentL A l -> IncidentL B l -> IncidentP A p -> IncidentP B p ->

 IncidentLP l p.

Proof.

intros A B l p HAB HAl HBl HAp HBp X HXl.

destruct (ex_ncol_cop (M1 p) (M2 p) (M3 p) A B HAB) as [C [HCp HNCol]].

apply ncols_coincide in HNCol.

assert (Heq : (Plan A B C HNCol) =p= p).

apply incidentp_eqp; auto.

rewrite <- Heq.

unfold IncidentP; simpl.

exists X; left; split.

apply cols_coincide_1; exists l; repeat split; assumption.

Col.

Qed.



Definition Between_H := fun A B C =>

  Bet A B C /\ A <> B /\ B <> C /\ A <> C.



Lemma axiom_between_col :

 forall A B C, Between_H A B C -> Col_H A B C.

Proof.

intros.

unfold Col_H, Between_H in *.

DecompAndAll.

exists (Lin A B H2).

unfold IncidentL.

intuition.

Qed.



Lemma axiom_between_diff :

 forall A B C, Between_H A B C -> A<>C.

Proof.

intros.

unfold Between_H in *.

intuition.

Qed.



Lemma axiom_between_comm : forall A B C, Between_H A B C -> Between_H C B A.

Proof.

unfold Between_H in |- *.

intros.

intuition.

Qed.



Lemma axiom_between_out :

 forall A B, A <> B -> exists C, Between_H A B C.

Proof.

intros.

prolong A B C A B.

exists C.

unfold Between_H.

repeat split;

auto;

intro;

treat_equalities;

tauto.

Qed.



Lemma axiom_between_only_one :

 forall A B C,

 Between_H A B C -> ~ Between_H B C A.

Proof.

unfold Between_H in |- *.

intros.

intro;

spliter.

assert (B=C) by

 (apply (between_equality B C A);Between).

solve [intuition].

Qed.



Lemma between_one : forall A B C,

 A<>B -> A<>C -> B<>C -> Col A B C ->

 Between_H A B C \/ Between_H B C A \/ Between_H B A C.

Proof.

intros.

unfold Col, Between_H in *.

destruct H2 as [|[|]]; [left|right..]; Between.

Qed.



Lemma axiom_between_one : forall A B C,

 A<>B -> A<>C -> B<>C -> Col_H A B C ->

 Between_H A B C \/ Between_H B C A \/ Between_H B A C.

Proof.

intros.

apply between_one;try assumption.

apply cols_coincide_1.

assumption.

Qed.



Definition cut := fun l A B =>

  ~ IncidentL A l /\ ~ IncidentL B l /\ exists I, IncidentL I l /\ Between_H A I B.



Lemma cut_two_sides : forall l A B, cut l A B <-> TS (P1 l) (P2 l) A B.

Proof.

intros.

unfold cut.

unfold TS.

split.

intros.

spliter.

repeat split; intuition.

ex_and H1 T.

exists T.

unfold IncidentL in H1.

unfold Between_H in *.

intuition.



intros.

spliter.

ex_and H1 T.

unfold IncidentL.

repeat split; try assumption.

exists T.

split.

assumption.

unfold Between_H.

repeat split.

assumption.

intro.

subst.

contradiction.

intro.

subst.

contradiction.

intro.

treat_equalities.

contradiction.

Qed.



Lemma cop_plane_aux : forall A B C D, Coplanar A B C D -> A <> B ->

  exists p, IncidentP A p /\ IncidentP B p /\ IncidentP C p /\ IncidentP D p.

Proof.

  intros A B C D HCop HAB.

  destruct (col_dec A B C) as [|HNCol]; [destruct (col_dec A B D) as [|HNCol]|].

  - destruct (not_col_exists A B HAB) as [E HNCol].

    apply ncols_coincide in HNCol.

    exists (Plan A B E HNCol).

    unfold IncidentP; simpl; repeat split; Cop.

  - apply ncols_coincide in HNCol.

    exists (Plan A B D HNCol).

    unfold IncidentP; simpl; repeat split; Cop.

  - apply ncols_coincide in HNCol.

    exists (Plan A B C HNCol).

    unfold IncidentP; simpl; repeat split; Cop.

Qed.



Lemma cop_plane : forall A B C D, Coplanar A B C D ->

  exists p, IncidentP A p /\ IncidentP B p /\ IncidentP C p /\ IncidentP D p.

Proof.

  intros A B C D HCop.

  destruct (eq_dec_points A B) as [|HAB]; [destruct (eq_dec_points A C);

    [destruct (eq_dec_points A D)|]|].

  - destruct (another_point D) as [E].

    destruct (cop_plane_aux D E E E) as [p []]; Cop.

    subst; exists p; repeat split; assumption.

  - destruct (cop_plane_aux A D B C) as [p]; Cop.

    spliter; exists p; repeat split; assumption.

  - destruct (cop_plane_aux A C B D) as [p]; Cop.

    spliter; exists p; repeat split; assumption.

  - apply (cop_plane_aux A B C D HCop HAB).

Qed.



Lemma plane_cop: forall A B C D p,

  IncidentP A p -> IncidentP B p -> IncidentP C p -> IncidentP D p -> Coplanar A B C D.

Proof.

  unfold IncidentP.

  intros A B C D p HA HB HC HD.

  assert (HNCol := NCol p).

  apply ncols_coincide in HNCol.

  apply coplanar_pseudo_trans with (M1 p) (M2 p) (M3 p); assumption.

Qed.



Lemma axiom_pasch : forall A B C l p, ~ Col_H A B C ->

 IncidentP A p -> IncidentP B p -> IncidentP C p -> IncidentLP l p -> ~ IncidentL C l ->

 cut l A B -> cut l A C \/ cut l B C.

Proof.

intros.

apply cut_two_sides in H5.

assert(~Col A B C).

apply ncols_coincide.

assumption.



assert(HH:=H5).

unfold TS in HH.

spliter.



unfold IncidentL in H4.

assert (HCop : Coplanar (P1 l) (P2 l) A C).

apply plane_cop with p; trivial; apply H3; unfold IncidentL; simpl; Col.



assert(HH:= cop__one_or_two_sides (P1 l)(P2 l) A C HCop H7 H4).



induction HH.

left.

apply <-cut_two_sides.

assumption.

right.

apply <-cut_two_sides.

apply l9_2.

eapply l9_8_2.

apply H5.

assumption.

Qed.



Lemma Incid_line :

 forall P A B l, A<>B ->

 IncidentL A l -> IncidentL B l -> Col P A B -> IncidentL P l.

Proof.

intros.

unfold IncidentL in *.

destruct l as [C D HCD].

simpl in *.

ColR.

Qed.



Definition outH := fun P A B => Between_H P A B \/ Between_H P B A \/ (P <> A /\ A = B).



Lemma out_outH : forall P A B, Out P A B -> outH P A B.

unfold Out.

unfold outH.

intros.

spliter.

induction H1.



induction (eq_dec_points A B).

right; right.

split; auto.

left.

unfold Between_H.

repeat split; auto.



induction (eq_dec_points A B).

right; right.

split; auto.

right; left.

unfold Between_H.

repeat split; auto.

Qed.



Lemma axiom_hcong_1_existence : forall A B A' P l,

  A <> B -> A' <> P ->

  IncidentL A' l -> IncidentL P l ->

  exists B', IncidentL B' l /\ outH A' P B' /\ Cong A' B' A B.

Proof.

intros; destruct (l6_11_existence A' A B P) as [B' [HOut HCong]]; auto.

exists B'; repeat split; try apply out_outH, l6_6; auto; unfold IncidentL in *.

destruct l; simpl in *; ColR.

Qed.



Lemma axiom_hcong_1_uniqueness :

 forall A B l M A' B' A'' B'', A <> B -> IncidentL M l ->

  IncidentL A' l -> IncidentL B' l ->

  IncidentL A'' l -> IncidentL B'' l ->

  Between_H A' M B' -> Cong M A' A B ->

  Cong M B' A B -> Between_H A'' M B'' ->

  Cong M A'' A B -> Cong M B'' A B ->

  (A' = A'' /\ B' = B'') \/ (A' = B'' /\ B' = A'').

Proof.

unfold Between_H.

unfold IncidentL.

intros.

spliter.



assert(A' <> M /\ A'' <> M /\ B' <> M /\ B'' <> M /\ A' <> B' /\ A'' <> B'').

repeat split; intro; treat_equalities; tauto.

spliter.



induction(out_dec M A' A'').

left.

assert(A' = A'').

eapply (l6_11_uniqueness M A B A''); try assumption.

apply out_trivial.

assumption.



split.

assumption.

subst A''.



eapply (l6_11_uniqueness M A B B''); try assumption.



unfold Out.

repeat split; try assumption.

eapply l5_2.

apply H18.

assumption.

assumption.

apply out_trivial.

assumption.



right.

apply not_out_bet in H23.



assert(A' = B'').

eapply (l6_11_uniqueness M A B A'); try assumption.

apply out_trivial.

assumption.



unfold Out.

repeat split; try assumption.



eapply l5_2.

apply H18.

assumption.

apply between_symmetry.

assumption.



split.

assumption.



subst B''.

eapply (l6_11_uniqueness M A B B'); try assumption.

apply out_trivial.

assumption.

unfold Out.

repeat split; try assumption.

eapply l5_2.

apply H20.

apply between_symmetry.

assumption.

assumption.

eapply col3.

apply (Cond l).

Col.

Col.

Col.

Qed.



Definition same_side_scott := fun E A B => E <> A /\ E <> B /\ Col_H E A B /\ ~ Between_H A E B.



Remark axiom_hcong_scott:

 forall P Q A C, A <> C -> P <> Q ->

  exists B, same_side_scott A B C  /\ Cong P Q A B.

Proof.

intros.

unfold same_side_scott.

assert (exists X : Tpoint, Out A X C /\ Cong A X P Q).

apply l6_11_existence;auto.

decompose [ex and] H1;clear H1.

exists x.

repeat split.

unfold Out in H3.

intuition.

unfold Out in H3.

intuition.

apply cols_coincide_2.

apply out_col;assumption.



unfold Out in H3.

unfold Between_H.

intro.

decompose [and] H3;clear H3.

decompose [and] H1;clear H1.

clear H8.

destruct H7.

assert (A = x).

eapply between_equality;eauto.

intuition.

assert (A = C).

eapply between_equality;eauto.

apply between_symmetry.

auto.

intuition.

Cong.

Qed.



Definition disjoint := fun A B C D => ~ exists P, Between_H A P B /\ Between_H C P D.



Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.

Proof.

intros.

apply cols_coincide_1 in H.

unfold disjoint in H0.



induction (eq_dec_points A B).

subst  B.

apply between_trivial2.

induction (eq_dec_points B C).

subst  C.

apply between_trivial.



unfold Col in H.

induction H.

assumption.



induction H.

apply False_ind.

apply H0.

assert(exists M, Midpoint M B C) by(apply midpoint_existence).

ex_and H3 M.

exists M.

unfold Midpoint in H4.

spliter.

split.

unfold Between_H.

repeat split.

apply between_symmetry.

eapply between_exchange4.

apply H3.

assumption.

intro.

treat_equalities.



tauto.



intro.

treat_equalities.

tauto.

assumption.

unfold Between_H.

repeat split.

assumption.

intro.

treat_equalities.

tauto.

intro.

treat_equalities.

tauto.

assumption.



apply False_ind.

apply H0.

assert(exists M, Midpoint M A B) by(apply midpoint_existence).

ex_and H3 M.

exists M.

unfold Midpoint in H4.

spliter.

split.

unfold Between_H.

repeat split.

assumption.

intro.

treat_equalities.

tauto.

intro.

treat_equalities.

tauto.

assumption.



unfold Between_H.

repeat split.



eapply between_exchange4.

apply between_symmetry.

apply H3.

apply between_symmetry.

assumption.

intro.

treat_equalities.

tauto.

intro.

treat_equalities.

intuition.

assumption.

Qed.



Lemma axiom_hcong_3 : forall A B C A' B' C',

   Col_H A B C -> Col_H A' B' C' ->

  disjoint A B B C -> disjoint A' B' B' C' ->

  Cong A B A' B' -> Cong B C B' C' -> Cong A C A' C'.

Proof.

intros.

assert(Bet A B C).

eapply col_disjoint_bet.

assumption.

assumption.



assert(Bet A' B' C').

eapply col_disjoint_bet.

assumption.

assumption.

eapply l2_11;eauto.

Qed.



Lemma exists_not_incident : forall A B : Tpoint, forall  HH : A <> B , exists C, ~ IncidentL C (Lin A B HH).

Proof.

intros.

unfold IncidentL.

assert(HC:=not_col_exists A B HH).

ex_and HC C.

exists C.

intro.

apply H.

simpl in H0.

Col.

Qed.



Definition same_side := fun A B l => exists P, cut l A P /\ cut l B P.



Lemma same_side_one_side : forall A B l, same_side A B l -> OS (P1 l) (P2 l) A B.

Proof.

unfold same_side.

intros.

destruct H as [P []].

apply cut_two_sides in H.

apply cut_two_sides in H0.

eapply l9_8_1.

apply H.

apply H0.

Qed.



Lemma one_side_same_side : forall A B l, OS (P1 l) (P2 l) A B -> same_side A B l.

Proof.

intros.

unfold same_side.

unfold OS in H.

destruct H as [P []].

exists P.

unfold cut.

unfold IncidentL.

unfold TS in H.

unfold TS in H0.

spliter.

repeat split; auto.

ex_and H4 T.

exists T.

unfold Between_H.

repeat split; auto.

intro.

subst T.

contradiction.

intro.

subst T.

contradiction.

intro.

subst P.

apply between_identity in H5.

subst T.

contradiction.

ex_and H2 T.

exists T.

unfold Between_H.

repeat split; auto.

intro.

subst T.

contradiction.

intro.

subst T.

contradiction.

intro.

subst P.

apply between_identity in H5.

subst T.

contradiction.

Qed.



Definition same_side' := fun A B X Y =>

  X <> Y /\ forall l, IncidentL X l -> IncidentL Y l -> same_side A B l.



Lemma OS_distinct : forall P Q A B,

  OS P Q A B -> P<>Q.

Proof.

intros.

apply one_side_not_col123 in H.

assert_diffs;assumption.

Qed.



Lemma OS_same_side' :

 forall P Q A B, OS P Q A B -> same_side' A B P Q.

Proof.

intros.

unfold same_side'.

intros.

split.

apply OS_distinct with A B;assumption.

intros.



apply  one_side_same_side.

destruct l.

unfold IncidentL in *.

simpl in *.

apply col2_os__os with P Q; try assumption; ColR.

Qed.



Lemma same_side_OS :

 forall P Q A B, same_side' P Q A B -> OS A B P Q.

Proof.

intros.

unfold same_side' in *.

destruct H.

destruct (axiom_line_existence A B H).

destruct H1.

assert (T:=H0 x H1 H2).

assert (U:=same_side_one_side P Q x T).

destruct x.

unfold IncidentL in *.

simpl in *.

apply col2_os__os with P1 P2;Col.

Qed.



Lemma outH_out : forall P A B, outH P A B -> Out P A B.

Proof.

unfold outH.

unfold Out.

intros.

induction H.

unfold Between_H in H.

spliter.

repeat split; auto.

induction H.

unfold Between_H in H.

spliter.

repeat split; auto.

spliter.

repeat split.

auto.

subst B.

auto.

subst B.

left.

apply between_trivial.

Qed.



Lemma incident_col : forall M l, IncidentL M l -> Col M (P1 l)(P2 l).

Proof.

unfold IncidentL.

intros.

assumption.

Qed.



Lemma col_incident : forall M l, Col M (P1 l)(P2 l) -> IncidentL M l.

Proof.

unfold IncidentL.

intros.

assumption.

Qed.



Lemma Bet_Between_H : forall A B C,

 Bet A B C -> A<>B -> B<>C -> Between_H A B C.

Proof.

intros.

unfold Between_H.

repeat split;try assumption.

intro.

subst.

treat_equalities.

intuition.

Qed.



Lemma axiom_cong_5' : forall A B C A' B' C', ~ Col_H A B C -> ~ Col_H A' B' C' ->

           Cong A B A' B' -> Cong A C A' C' -> CongA B A C B' A' C' -> CongA A B C A' B' C'.

Proof.

intros A B C A' B' C'.

intros.

assert (T:=l11_49 B A C B' A' C').

assert (~ Col A B C).

intro.

apply cols_coincide_2 in H4.

intuition.

assert_diffs.

intuition.

Qed.



Lemma axiom_hcong_4_existence :  forall A B C O X P,

   ~ Col_H P O X -> ~ Col_H A B C ->

  exists Y, CongA A B C X O Y   /\ same_side' P Y O X.

Proof.

intros.

rewrite <- cols_coincide in H.

rewrite <- cols_coincide in H0.



assert(~Col X O P).

intro.

apply H.

Col.

assert(HH:=angle_construction_1 A B C X O P H0 H1).



ex_and HH Y.



exists Y.

split.

assumption.

apply OS_same_side'.

apply invert_one_side.

apply one_side_symmetry.

assumption.

Qed.



Lemma same_side_trans :

 forall A B C l,

  same_side A B l -> same_side B C l -> same_side A C l.

Proof.

intros.

apply one_side_same_side.

apply same_side_one_side in H.

apply same_side_one_side in H0.

eapply one_side_transitivity.

apply H.

assumption.

Qed.



Lemma same_side_sym :

 forall A B l,

  same_side A B l -> same_side B A l.

Proof.

intros.

apply one_side_same_side.

apply same_side_one_side in H.

apply one_side_symmetry.

assumption.

Qed.



Lemma axiom_hcong_4_uniqueness :

  forall A B C O P X Y Y', ~ Col_H P O X  -> ~ Col_H A B C -> CongA A B C X O Y -> CongA A B C X O Y' -> 

  same_side' P Y O X -> same_side' P Y' O X -> outH O Y Y'.

Proof.

intros.

rewrite <- cols_coincide in H.

rewrite <- cols_coincide in H0.

assert (T:CongA X O Y X O Y').

eapply conga_trans.

apply conga_sym.

apply H1.

assumption.



apply conga_cop__or_out_ts in T.

induction T.

apply out_outH.

assumption.



apply same_side_OS in H3.

apply same_side_OS in H4.

exfalso.

assert (OS O X Y Y').

apply one_side_transitivity with P.

apply one_side_symmetry.

assumption.

assumption.

apply invert_one_side in H6.

apply l9_9 in H5.

intuition.



apply same_side_OS in H3.

apply same_side_OS in H4.

apply coplanar_trans_1 with P; Col; Cop.

Qed.



Lemma axiom_conga_comm : forall A B C,

 ~ Col_H A B C -> CongA A B C C B A.

Proof.

intros.

rewrite <- cols_coincide in H.

assert_diffs.

apply conga_pseudo_refl;auto.

Qed.



Lemma axiom_congaH_outH_congaH :

 forall A B C D E F A' C' D' F' : Tpoint,

  CongA A B C D E F ->

  Between_H B A A' \/ Between_H B A' A \/ B <> A /\ A = A' ->

  Between_H B C C' \/ Between_H B C' C \/ B <> C /\ C = C' ->

  Between_H E D D' \/ Between_H E D' D \/ E <> D /\ D = D' ->

  Between_H E F F' \/ Between_H E F' F \/ E <> F /\ F = F' ->

  CongA A' B C' D' E F'.

Proof.

intros.

apply out_conga with A C D F;auto using outH_out.

Qed.



Lemma axiom_conga_permlr:

forall A B C D E F : Tpoint, CongA A B C D E F -> CongA C B A F E D.

Proof.

apply Ch11_angles.conga_comm.

Qed.



Lemma axiom_conga_refl : forall A B C, ~ Col_H A B C -> CongA A B C A B C.

Proof.

intros A B C H.

apply Ch11_angles.conga_refl; intro; subst; apply H; apply cols_coincide; Col.

Qed.



End T.



Section Tarski_neutral_to_Hilbert_neutral.



Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.



Instance Hilbert_neutral_follows_from_Tarski_neutral : Hilbert_neutral_dimensionless.

Proof.

exact (Build_Hilbert_neutral_dimensionless Tpoint Line Plane EqL EqL_Equiv EqP EqP_Equiv IncidentL

       IncidentP axiom_Incid_morphism axiom_Incid_dec axiom_Incidp_morphism axiom_Incidp_dec

       eq_dec_points axiom_line_existence axiom_line_uniqueness axiom_two_points_on_line PA

       PB PC lower_dim' axiom_plane_existence axiom_one_point_on_plane axiom_plane_uniqueness

       axiom_line_on_plane Between_H axiom_between_diff axiom_between_col axiom_between_comm

       axiom_between_out axiom_between_only_one axiom_pasch Cong cong_right_commutativity

       axiom_hcong_1_existence cong_inner_transitivity

        axiom_hcong_3 CongA axiom_conga_refl axiom_conga_comm

       axiom_conga_permlr axiom_congaH_outH_congaH axiom_hcong_4_existence

       axiom_hcong_4_uniqueness axiom_cong_5').

Defined.



End Tarski_neutral_to_Hilbert_neutral.



Section Tarski_neutral_2D_to_Hilbert_neutral_2D.



Context `{T2D:Tarski_2D}.



Instance Hilbert_2D_follows_from_Tarski_2D : Hilbert_neutral_2D Hilbert_neutral_follows_from_Tarski_neutral.

Proof.

split.

intros A B C l HNCol HNCl Hcut.

apply axiom_pasch with (Plan A B C HNCol); trivial;

  unfold IncidentLP, IncidentP; intros; try (apply all_coplanar).

Defined.



End Tarski_neutral_2D_to_Hilbert_neutral_2D.



Section Tarski_neutral_3D_to_Hilbert_neutral_3D.



Context `{T3D:Tarski_3D}.



Lemma lower_dim_3' : {A : Tpoint & {B : Tpoint & {C : Tpoint & {D |

  ~ exists p, IncidentP A p /\ IncidentP B p /\ IncidentP C p /\ IncidentP D p}}}}.

Proof.

exists S1, S2, S3, S4.

intros [p]; spliter.

apply tarski_axioms.lower_dim_3, plane_cop with p; assumption.

Qed.



Instance Hilbert_3D_follows_from_Tarski_3D : Hilbert_neutral_3D Hilbert_neutral_follows_from_Tarski_neutral.

Proof.

destruct lower_dim_3' as [A [B [C [D n]]]].

exists A B C D; [|assumption].

clear A B C D n.

intros A p q HAp HAq.

destruct p as [P1 P2 P3 HP].

destruct q as [Q1 Q2 Q3 HQ].

unfold IncidP in *; simpl in *; unfold IncidentP in *; simpl in *.

assert (pi : plane_intersection_axiom).

cut upper_dim_3_axiom.

apply upper_dim_3_equivalent_axioms; simpl; tauto.

unfold upper_dim_3_axiom.

apply upper_dim_3.

apply pi; assumption.

Defined.



End Tarski_neutral_3D_to_Hilbert_neutral_3D.



Section Tarski_Euclidean_to_Hilbert_Euclidean.



Context `{TE:Tarski_euclidean}.



Definition Para := fun l m =>

  (~ exists X, IncidentL X l /\ IncidentL X m) /\ exists p, IncidentLP l p /\ IncidentLP m p.



Lemma Para_Par : forall A B C D (HAB : A<>B) (HCD: C<>D),

 Para (Lin A B HAB) (Lin C D HCD) -> Par A B C D.

Proof.

unfold Para, IncidentL, Par, Par_strict; simpl.

intros.

destruct H as [HNI [p []]].

left.

repeat split;auto.

apply plane_cop with p; [apply H|apply H|apply H0..]; unfold IncidentL; simpl; Col.

Qed.



Lemma axiom_euclid_uniqueness :

  forall l P m1 m2,

  ~ IncidentL P l ->

   Para l m1 -> IncidentL P m1 ->

   Para l m2 -> IncidentL P m2 ->

   EqL m1 m2.

Proof.

intros.

destruct l as [A B HAB].

destruct m1 as [C D HCD].

destruct m2 as [C' D' HCD'].

unfold IncidentL in *;simpl in *.

apply Para_Par in H0.

apply Para_Par in H2.

elim (tarski_s_euclid_implies_playfair euclid A B C D C' D' P H0 H1 H2 H3);intros.

apply axiom_line_uniqueness with C' D';

unfold IncidentL;simpl;Col.

Qed.



Instance Hilbert_euclidean_follows_from_Tarski_euclidean :

  Hilbert_euclidean Hilbert_neutral_follows_from_Tarski_neutral.

Proof.

split.

apply axiom_euclid_uniqueness.

Defined.



Instance Hilbert_euclidean_ID_follows_from_Tarski_euclidean :

  Hilbert_euclidean_ID Hilbert_euclidean_follows_from_Tarski_euclidean.

Proof.

split.

intros l m.

assert (ID : decidability_of_intersection).

apply strong_parallel_postulate_implies_inter_dec.

cut tarski_s_parallel_postulate.

apply equivalent_postulates_without_decidability_of_intersection_of_lines_bis; simpl; tauto.

unfold tarski_s_parallel_postulate.

apply euclid.

destruct l as [L1 L2 HL].

destruct m as [M1 M2 HM].

simpl; unfold IncidentL; simpl.

apply ID.

Defined.



End Tarski_Euclidean_to_Hilbert_Euclidean.
