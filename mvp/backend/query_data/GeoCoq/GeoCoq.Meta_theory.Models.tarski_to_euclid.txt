Require Import GeoCoq.Tarski_dev.Ch12_parallel.
(* GeoCoq.Tarski_dev.Ch12_parallel:
Require Export GeoCoq.Tarski_dev.Ch11_angles.

Section T12_1.

Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.

Lemma par_reflexivity : forall A B, A<>B -> Par A B A B.

Lemma par_strict_irreflexivity : forall A B,
 ~ Par_strict A B A B.

Lemma not_par_strict_id : forall A B C,
 ~ Par_strict A B A C.

Lemma par_id : forall A B C,
 Par A B A C -> Col A B C.

Lemma par_strict_not_col_1 : forall A B C D,
 Par_strict A B C D  -> ~ Col A B C.

Lemma par_strict_not_col_2 : forall A B C D,
 Par_strict A B C D  -> ~ Col B C D.

Lemma par_strict_not_col_3 : forall A B C D,
 Par_strict A B C D  -> ~ Col C D A.

Lemma par_strict_not_col_4 : forall A B C D,
 Par_strict A B C D  -> ~ Col A B D.

Lemma par_strict_not_cols : forall A B C D,
 Par_strict A B C D -> ~ Col A B C /\ ~ Col B C D /\ ~ Col C D A /\ ~ Col A B D.

Lemma par_id_1 : forall A B C,
 Par A B A C -> Col B A C.

Lemma par_id_2 : forall A B C,
 Par A B A C -> Col B C A.

Lemma par_id_3 : forall A B C,
 Par A B A C -> Col A C B.

Lemma par_id_4 : forall A B C,
 Par A B A C -> Col C B A.

Lemma par_id_5 : forall A B C,
 Par A B A C -> Col C A B.

Lemma par_strict_symmetry :forall A B C D,
 Par_strict A B C D -> Par_strict C D A B.

Lemma par_symmetry :forall A B C D,
 Par A B C D -> Par C D A B.

Lemma par_left_comm : forall A B C D,
 Par A B C D -> Par B A C D.

Lemma par_right_comm : forall A B C D,
 Par A B C D -> Par A B D C.

Lemma par_comm : forall A B C D,
 Par A B C D -> Par B A D C.

Lemma par_strict_left_comm : forall A B C D,
 Par_strict A B C D -> Par_strict B A C D.

Lemma par_strict_right_comm : forall A B C D,
 Par_strict A B C D -> Par_strict A B D C.

Lemma par_strict_comm : forall A B C D,
 Par_strict A B C D -> Par_strict B A D C.

Lemma par_strict_neq1 : forall A B C D, Par_strict A B C D -> A <> B.

Lemma par_strict_neq2 : forall A B C D, Par_strict A B C D -> C <> D.

Lemma par_neq1 : forall A B C D, Par A B C D -> A <> B.

Lemma par_neq2 : forall A B C D, Par A B C D -> C <> D.

End T12_1.

Ltac assert_diffs :=
repeat
 match goal with
      | H:(~Col ?X1 ?X2 ?X3) |- _ =>
      let h := fresh in
      not_exist_hyp3 X1 X2 X1 X3 X2 X3;
      assert (h := not_col_distincts X1 X2 X3 H);decompose [and] h;clear h;clean_reap_hyps

      | H:(~Bet ?X1 ?X2 ?X3) |- _ =>
      let h := fresh in
      not_exist_hyp2 X1 X2 X2 X3;
      assert (h := not_bet_distincts X1 X2 X3 H);decompose [and] h;clear h;clean_reap_hyps
      | H:Bet ?A ?B ?C, H2 : ?A <> ?B |-_ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= bet_neq12__neq A B C H H2);clean_reap_hyps
      | H:Bet ?A ?B ?C, H2 : ?B <> ?A |-_ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= bet_neq21__neq A B C H H2);clean_reap_hyps
      | H:Bet ?A ?B ?C, H2 : ?B <> ?C |-_ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= bet_neq23__neq A B C H H2);clean_reap_hyps
      | H:Bet ?A ?B ?C, H2 : ?C <> ?B |-_ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= bet_neq32__neq A B C H H2);clean_reap_hyps

      | H:Cong ?A ?B ?C ?D, H2 : ?A <> ?B |-_ =>
      let T:= fresh in (not_exist_hyp_comm C D);
        assert (T:= cong_diff A B C D H2 H);clean_reap_hyps
      | H:Cong ?A ?B ?C ?D, H2 : ?B <> ?A |-_ =>
      let T:= fresh in (not_exist_hyp_comm C D);
        assert (T:= cong_diff_2 A B C D H2 H);clean_reap_hyps
      | H:Cong ?A ?B ?C ?D, H2 : ?C <> ?D |-_ =>
      let T:= fresh in (not_exist_hyp_comm A B);
        assert (T:= cong_diff_3 A B C D H2 H);clean_reap_hyps
      | H:Cong ?A ?B ?C ?D, H2 : ?D <> ?C |-_ =>
      let T:= fresh in (not_exist_hyp_comm A B);
        assert (T:= cong_diff_4 A B C D H2 H);clean_reap_hyps

      | H:Le ?A ?B ?C ?D, H2 : ?A <> ?B |-_ =>
      let T:= fresh in (not_exist_hyp_comm C D);
        assert (T:= le_diff A B C D H2 H);clean_reap_hyps
      | H:Le ?A ?B ?C ?D, H2 : ?B <> ?A |-_ =>
      let T:= fresh in (not_exist_hyp_comm C D);
        assert (T:= le_diff A B C D (swap_diff B A H2) H);clean_reap_hyps
      | H:Lt ?A ?B ?C ?D |-_ =>
      let T:= fresh in (not_exist_hyp_comm C D);
        assert (T:= lt_diff A B C D H);clean_reap_hyps

      | H:Midpoint ?I ?A ?B, H2 : ?A<>?B |- _ =>
      let T:= fresh in (not_exist_hyp2 I B I A);
       assert (T:= midpoint_distinct_1 I A B H2 H);
       decompose [and] T;clear T;clean_reap_hyps
      | H:Midpoint ?I ?A ?B, H2 : ?B<>?A |- _ =>
      let T:= fresh in (not_exist_hyp2 I B I A);
       assert (T:= midpoint_distinct_1 I A B (swap_diff B A H2) H);
       decompose [and] T;clear T;clean_reap_hyps

      | H:Midpoint ?I ?A ?B, H2 : ?I<>?A |- _ =>
      let T:= fresh in (not_exist_hyp2 I B A B);
       assert (T:= midpoint_distinct_2 I A B H2 H);
       decompose [and] T;clear T;clean_reap_hyps
      | H:Midpoint ?I ?A ?B, H2 : ?A<>?I |- _ =>
      let T:= fresh in (not_exist_hyp2 I B A B);
       assert (T:= midpoint_distinct_2 I A B (swap_diff A I H2) H);
       decompose [and] T;clear T;clean_reap_hyps

      | H:Midpoint ?I ?A ?B, H2 : ?I<>?B |- _ =>
      let T:= fresh in (not_exist_hyp2 I A A B);
       assert (T:= midpoint_distinct_3 I A B H2 H);
       decompose [and] T;clear T;clean_reap_hyps
      | H:Midpoint ?I ?A ?B, H2 : ?B<>?I |- _ =>
      let T:= fresh in (not_exist_hyp2 I A A B);
       assert (T:= midpoint_distinct_3 I A B (swap_diff B I H2) H);
       decompose [and] T;clear T;clean_reap_hyps

      | H:Per ?A ?B ?C, H2 : ?A<>?B |- _ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= per_distinct A B C H H2); clean_reap_hyps
      | H:Per ?A ?B ?C, H2 : ?B<>?A |- _ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= per_distinct A B C H (swap_diff B A H2)); clean_reap_hyps
      | H:Per ?A ?B ?C, H2 : ?B<>?C |- _ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= per_distinct_1 A B C H H2); clean_reap_hyps
      | H:Per ?A ?B ?C, H2 : ?C<>?B |- _ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= per_distinct_1 A B C H (swap_diff C B H2)); clean_reap_hyps

      | H:Perp ?A ?B ?C ?D |- _ =>
      let T:= fresh in (not_exist_hyp2 A B C D);
       assert (T:= perp_distinct A B C D H);
       decompose [and] T;clear T;clean_reap_hyps
      | H:Perp_at ?X ?A ?B ?C ?D |- _ =>
      let T:= fresh in (not_exist_hyp2 A B C D);
       assert (T:= perp_in_distinct X A B C D H);
       decompose [and] T;clear T;clean_reap_hyps
      | H:Out ?A ?B ?C |- _ =>
      let T:= fresh in (not_exist_hyp2 A B A C);
       assert (T:= out_distinct A B C H);
       decompose [and] T;clear T;clean_reap_hyps

      | H:TS ?A ?B ?C ?D |- _ =>
      let h := fresh in
      not_exist_hyp6 A B A C A D B C B D C D;
      assert (h := ts_distincts A B C D H);decompose [and] h;clear h;clean_reap_hyps
      | H:OS ?A ?B ?C ?D |- _ =>
      let h := fresh in
      not_exist_hyp5 A B A C A D B C B D;
      assert (h := os_distincts A B C D H);decompose [and] h;clear h;clean_reap_hyps
      | H:~ Coplanar ?A ?B ?C ?D |- _ =>
      let h := fresh in
      not_exist_hyp6 A B A C A D B C B D C D;
      assert (h := ncop_distincts A B C D H);decompose [and] h;clear h;clean_reap_hyps

      | H:CongA ?A ?B ?C ?A' ?B' ?C' |- _ =>
      let T:= fresh in (not_exist_hyp_comm A B);
        assert (T:= conga_diff1 A B C A' B' C' H);clean_reap_hyps
      | H:CongA ?A ?B ?C ?A' ?B' ?C' |- _ =>
      let T:= fresh in (not_exist_hyp_comm B C);
        assert (T:= conga_diff2 A B C A' B' C' H);clean_reap_hyps
      | H:CongA ?A ?B ?C ?A' ?B' ?C' |- _ =>
      let T:= fresh in (not_exist_hyp_comm A' B');
        assert (T:= conga_diff45 A B C A' B' C' H);clean_reap_hyps
      | H:CongA ?A ?B ?C ?A' ?B' ?C' |- _ =>
      let T:= fresh in (not_exist_hyp_comm B' C');
        assert (T:= conga_diff56 A B C A' B' C' H);clean_reap_hyps

      | H:(InAngle ?P ?A ?B ?C) |- _ =>
      let h := fresh in
      not_exist_hyp3 A B C B P B;
      assert (h := inangle_distincts A B C P H);decompose [and] h;clear h;clean_reap_hyps
      | H:LeA ?A ?B ?C ?D ?E ?F |- _ =>
      let h := fresh in
      not_exist_hyp4 A B B C D E E F;
      assert (h := lea_distincts A B C D E F H);decompose [and] h;clear h;clean_reap_hyps
      | H:LtA ?A ?B ?C ?D ?E ?F |- _ =>
      let h := fresh in
      not_exist_hyp4 A B B C D E E F;
      assert (h := lta_distincts A B C D E F H);decompose [and] h;clear h;clean_reap_hyps
      | H:(Acute ?A ?B ?C) |- _ =>
      let h := fresh in
      not_exist_hyp2 A B B C;
      assert (h := acute_distincts A B C H);decompose [and] h;clear h;clean_reap_hyps
      | H:(Obtuse ?A ?B ?C) |- _ =>
      let h := fresh in
      not_exist_hyp2 A B B C;
      assert (h := obtuse_distincts A B C H);decompose [and] h;clear h;clean_reap_hyps
      | H:SuppA ?A ?B ?C ?D ?E ?F |- _ =>
      let h := fresh in
      not_exist_hyp4 A B B C D E E F;
      assert (h := suppa_distincts A B C D E F H);decompose [and] h;clear h;clean_reap_hyps

      | H:(Orth_at ?X ?A ?B ?C ?U ?V) |- _ =>
      let h := fresh in
      not_exist_hyp4 A B A C B C U V;
      assert (h := orth_at_distincts A B C U V X H);decompose [and] h;clear h;clean_reap_hyps
      | H:(Orth ?A ?B ?C ?U ?V) |- _ =>
      let h := fresh in
      not_exist_hyp4 A B A C B C U V;
      assert (h := orth_distincts A B C U V H);decompose [and] h;clear h;clean_reap_hyps

      | H:Par ?A ?B ?C ?D |- _ =>
      let T:= fresh in (not_exist_hyp_comm A B);
        assert (T:= par_neq1 A B C D H);clean_reap_hyps
      | H:Par ?A ?B ?C ?D |- _ =>
      let T:= fresh in (not_exist_hyp_comm C D);
        assert (T:= par_neq2 A B C D H);clean_reap_hyps
      | H:Par_strict ?A ?B ?C ?D |- _ =>
      let T:= fresh in (not_exist_hyp_comm A B);
        assert (T:= par_strict_neq1 A B C D H);clean_reap_hyps
      | H:Par_strict ?A ?B ?C ?D |- _ =>
      let T:= fresh in (not_exist_hyp_comm C D);
        assert (T:= par_strict_neq2 A B C D H);clean_reap_hyps
 end.

Ltac assert_ncols :=
repeat
  match goal with
      | H:OS ?A ?B ?X ?Y |- _ =>
     not_exist_hyp_perm_ncol A B X;assert (~ Col A B X) by (apply(one_side_not_col123 A B X Y);finish)

      | H:OS ?A ?B ?X ?Y |- _ =>
     not_exist_hyp_perm_ncol A B Y;assert (~ Col A B Y) by (apply(one_side_not_col124 A B X Y);finish)

      | H:TS ?A ?B ?X ?Y |- _ =>
     not_exist_hyp_perm_ncol A B X;assert (~ Col A B X) by (apply(two_sides_not_col A B X Y);finish)

      | H:TS ?A ?B ?X ?Y |- _ =>
     not_exist_hyp_perm_ncol A B Y;assert (~ Col A B Y) by (apply(two_sides_not_col A B Y X);finish)

      | H:~ Coplanar ?A ?B ?C ?D |- _ =>
      let h := fresh in
      not_exist_hyp_perm4 A B C D;
      assert (h := ncop__ncols A B C D H);decompose [and] h;clear h;clean_reap_hyps

      | H:Par_strict ?A ?B ?C ?D |- _ =>
      let h := fresh in
      not_exist_hyp_perm4 A B C D;
      assert (h := par_strict_not_cols A B C D H);decompose [and] h;clear h;clean_reap_hyps
  end.

Hint Resolve
 par_reflexivity par_strict_irreflexivity
 par_strict_symmetry par_strict_comm par_strict_right_comm par_strict_left_comm
 par_symmetry par_comm par_right_comm par_left_comm : par.

Hint Resolve par_strict_not_col_1 par_strict_not_col_2
             par_strict_not_col_3 par_strict_not_col_4 : col.

Ltac Par := eauto with par.

Section T12_2.

Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.

Lemma Par_cases :
  forall A B C D,
  Par A B C D \/ Par B A C D \/ Par A B D C \/ Par B A D C \/
  Par C D A B \/ Par C D B A \/ Par D C A B \/ Par D C B A ->
  Par A B C D.

Lemma Par_perm :
  forall A B C D,
  Par A B C D ->
  Par A B C D /\ Par B A C D /\ Par A B D C /\ Par B A D C /\
  Par C D A B /\ Par C D B A /\ Par D C A B /\ Par D C B A.

Lemma Par_strict_cases :
  forall A B C D,
  Par_strict A B C D \/ Par_strict B A C D \/ Par_strict A B D C \/ Par_strict B A D C \/
  Par_strict C D A B \/ Par_strict C D B A \/ Par_strict D C A B \/ Par_strict D C B A ->
  Par_strict A B C D.

Lemma Par_strict_perm :
  forall A B C D,
  Par_strict A B C D ->
  Par_strict A B C D /\ Par_strict B A C D /\ Par_strict A B D C /\ Par_strict B A D C /\
  Par_strict C D A B /\ Par_strict C D B A /\ Par_strict D C A B /\ Par_strict D C B A.

End T12_2.

Section T12_2'.

Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.

Lemma l12_6 : forall A B C D,
 Par_strict A B C D -> OS A B C D.

Lemma pars__os3412 : forall A B C D,
 Par_strict A B C D -> OS C D A B.

Lemma perp_dec : forall A B C D, Perp A B C D \/ ~ Perp A B C D.

Lemma col_cop2_perp2__col : forall X1 X2 Y1 Y2 A B,
 Perp X1 X2 A B -> Perp Y1 Y2 A B -> Col X1 Y1 Y2 ->
 Coplanar A B X2 Y1 -> Coplanar A B X2 Y2 -> Col X2 Y1 Y2.

Lemma col_perp2_ncol__col : forall X1 X2 Y1 Y2 A B,
 Perp X1 X2 A B -> Perp Y1 Y2 A B ->
 Col X1 Y1 Y2 -> ~ Col X1 A B ->
 Col X2 Y1 Y2.

Lemma l12_9 : forall A1 A2 B1 B2 C1 C2,
 Coplanar C1 C2 A1 B1 -> Coplanar C1 C2 A1 B2 ->
 Coplanar C1 C2 A2 B1 -> Coplanar C1 C2 A2 B2 ->
 Perp A1 A2 C1 C2 -> Perp B1 B2 C1 C2 ->
 Par A1 A2 B1 B2.

Lemma parallel_existence : forall A B P, A <> B ->
 exists C, exists D, C<>D /\ Par A B C D /\ Col P C D.

Lemma par_col_par : forall A B C D D',
 C <> D' -> Par A B C D -> Col C D D' -> Par A B C D'.

Lemma parallel_existence1 : forall A B P, A <> B -> exists Q, Par A B P Q.

Lemma par_not_col : forall A B C D X, Par_strict A B C D -> Col X A B -> ~Col X C D.

Lemma not_strict_par1 : forall A B C D X, Par A B C D -> Col A B X -> Col C D X -> Col A B C.

Lemma not_strict_par2 : forall A B C D X, Par A B C D -> Col A B X -> Col C D X -> Col A B D.

Lemma not_strict_par : forall A B C D X, Par A B C D -> Col A B X -> Col C D X -> Col A B C /\ Col A B D.

Lemma not_par_not_col : forall A B C, A <> B -> A <> C -> ~Par A B A C -> ~Col A B C.

Lemma not_par_inter_uniqueness : forall A B C D X Y,
  A <> B -> C <> D -> ~Par A B C D -> Col A B X -> Col C D X -> Col A B Y -> Col C D Y ->
  X = Y.

Lemma inter_uniqueness_not_par : forall A B C D P,
  ~Col A B C -> Col A B P -> Col C D P -> ~Par A B C D.

Lemma col_not_col_not_par :
 forall A B C D,
 (exists P, Col A B P /\ Col C D P) ->
 (exists Q, Col C D Q /\ ~Col A B Q) -> ~Par A B C D.

Lemma par_distincts : forall A B C D,
 Par A B C D -> (Par A B C D /\ A <> B /\ C <> D).

Lemma par_not_col_strict : forall A B C D P,
 Par A B C D -> Col C D P -> ~Col A B P -> Par_strict A B C D.

Lemma all_one_side_par_strict : forall A B C D,
 C <> D -> (forall P, Col C D P -> OS A B C P) ->
 Par_strict A B C D.

Lemma par_col_par_2 : forall A B C D P,
 A <> P -> Col A B P -> Par A B C D -> Par A P C D.

Lemma par_col2_par : forall A B C D E F,
 E <> F -> Par A B C D -> Col C D E -> Col C D F -> Par A B E F.

Lemma par_col2_par_bis : forall A B C D E F,
 E <> F -> Par A B C D -> Col E F C -> Col E F D -> Par A B E F.

Lemma par_strict_col_par_strict : forall A B C D E,
 C <> E -> Par_strict A B C D -> Col C D E ->
 Par_strict A B C E.

Lemma par_strict_col2_par_strict : forall A B C D E F,
 E <> F -> Par_strict A B C D -> Col C D E -> Col C D F ->
 Par_strict A B E F.

Lemma line_dec : forall B1 B2 C1 C2, (Col C1 B1 B2 /\ Col C2 B1 B2) \/ ~ (Col C1 B1 B2 /\ Col C2 B1 B2).

Lemma par_distinct : forall A B C D, Par A B C D -> A <> B /\ C <> D.

Lemma par_col4__par : forall A B C D E F G H, E <> F -> G <> H -> Par A B C D ->
 Col A B E -> Col A B F -> Col C D G -> Col C D H -> Par E F G H.

Lemma par_strict_col4__par_strict : forall A B C D E F G H, E <> F -> G <> H ->
 Par_strict A B C D -> Col A B E -> Col A B F -> Col C D G -> Col C D H ->
 Par_strict E F G H.

Lemma par_strict_one_side : forall A B C D P,
 Par_strict A B C D -> Col C D P -> OS A B C P.

Lemma par_strict_all_one_side : forall A B C D,
 Par_strict A B C D -> (forall P, Col C D P -> OS A B C P).

Lemma inter_distincts : forall A B C D X, Inter A B C D X -> A <> B /\ C <> D.

Lemma inter_trivial : forall A B X, ~ Col A B X -> Inter A X B X X.

Lemma inter_sym : forall A B C D X, Inter A B C D X -> Inter C D A B X.

Lemma inter_left_comm : forall A B C D X, Inter A B C D X -> Inter B A C D X.

Lemma inter_right_comm : forall A B C D X, Inter A B C D X -> Inter A B D C X.

Lemma inter_comm : forall A B C D X, Inter A B C D X -> Inter B A D C X.

Lemma l12_17 : forall A B C D P,
 A <> B -> Midpoint P A C -> Midpoint P B D -> Par A B C D.

Lemma l12_18_a :
  forall A B C D P,
  Cong A B C D -> Cong B C D A -> ~Col A B C ->
  B <> D -> Col A P C -> Col B P D ->
  Par A B C D.

Lemma l12_18_b :
  forall A B C D P,
  Cong A B C D -> Cong B C D A -> ~Col A B C ->
  B <> D -> Col A P C -> Col B P D ->
  Par B C D A.

Lemma l12_18_c :
 forall A B C D P,
  Cong A B C D -> Cong B C D A -> ~Col A B C ->
  B <> D -> Col A P C -> Col B P D ->
  TS B D A C.

Lemma l12_18_d :
 forall A B C D P,
 Cong A B C D -> Cong B C D A -> ~Col A B C ->
 B <> D -> Col A P C -> Col B P D ->
 TS A C B D.

Lemma l12_18 :
 forall A B C D P,
  Cong A B C D -> Cong B C D A -> ~Col A B C ->
  B <> D -> Col A P C -> Col B P D ->
  Par A B C D /\ Par B C D A /\ TS B D A C /\ TS A C B D.

Lemma par_two_sides_two_sides :
  forall A B C D,
  Par A B C D -> TS B D A C ->
  TS A C B D.

Lemma par_one_or_two_sides :
 forall A B C D,
  Par_strict A B C D ->
 TS A C B D /\ TS B D A C \/ OS A C B D /\ OS B D A C.

Lemma l12_21_b : forall A B C D,
 TS A C B D ->
 CongA B A C D C A -> Par A B C D.

Lemma l12_22_aux :
 forall A B C D P,
  P <> A -> A <> C -> Bet P A C -> OS P A B D ->
  CongA B A P D C P ->
  Par A B C D.

Lemma l12_22_b :
 forall A B C D P,
  Out P A C -> OS P A B D -> CongA B A P D C P ->
  Par A B C D.

Lemma par_strict_par : forall A B C D,
 Par_strict A B C D -> Par A B C D.

Lemma par_strict_distinct : forall A B C D,
 Par_strict A B C D ->
  A<>B /\ A<>C /\ A<>D /\ B<>C /\ B<>D /\ C<>D.

Lemma col_par : forall A B C,
 A <> B -> B <> C ->
 Col A B C -> Par A B B C.

Lemma acute_col_perp__out : forall A B C A',
  Acute A B C -> Col B C A' -> Perp B C A A' -> Out B A' C.

Lemma acute_col_perp__out_1 : forall A B C A',
  Acute A B C -> Col B C A' -> Perp B A A A' -> Out B A' C.

Lemma conga_cop_inangle_per2__inangle : forall A B C P T,
  Per A B C -> InAngle T A B C -> CongA P B A P B C -> Per B P T -> Coplanar A B C P ->
  InAngle P A B C.

End T12_2'.

Hint Resolve col_par par_strict_par : par.

Hint Resolve l12_6 pars__os3412 : side.

Section T12_3.

Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.

Lemma perp_not_par : forall A B X Y, Perp A B X Y -> ~ Par A B X Y.

Lemma cong_conga_perp : forall A B C P, TS B P A C -> Cong A B C B -> CongA A B P C B P -> Perp A C B P.

Lemma perp_inter_exists : forall A B C D, Perp A B C D -> exists P, Col A B P /\ Col C D P.

Lemma perp_inter_perp_in : forall A B C D, Perp A B C D -> exists P, Col A B P /\ Col C D P /\ Perp_at P A B C D.

End T12_3.

Section T12_2D.

Context `{T2D:Tarski_2D}.

Lemma col_perp2__col : forall X1 X2 Y1 Y2 A B,
  Perp X1 X2 A B -> Perp Y1 Y2 A B -> Col X1 Y1 Y2 -> Col X2 Y1 Y2.

Lemma l12_9_2D : forall A1 A2 B1 B2 C1 C2,
  Perp A1 A2 C1 C2 -> Perp B1 B2 C1 C2 -> Par A1 A2 B1 B2.

Lemma conga_inangle_per2__inangle : forall A B C P T,
  Per A B C -> InAngle T A B C -> CongA P B A P B C -> Per B P T ->
  InAngle P A B C.

End T12_2D. *)

Require Import GeoCoq.Axioms.euclidean_axioms.
(* GeoCoq.Axioms.euclidean_axioms:
Class euclidean_neutral :=
{
  Point : Type;
  Circle : Type;
  Cong : Point -> Point -> Point -> Point -> Prop;
  BetS : Point -> Point -> Point -> Prop;
  PA : Point;
  PB : Point;
  PC : Point;
  CI : Circle -> Point -> Point -> Point -> Prop;
  eq := @eq Point;
  neq A B := ~ eq A B;
  TE A B C := ~ (neq A B /\ neq B C /\ ~ BetS A B C);
  nCol A B C := neq A B /\ neq A C /\ neq B C /\ ~ BetS A B C /\ ~ BetS A C B /\ ~ BetS B A C;
  Col A B C := (eq A B \/ eq A C \/ eq B C \/ BetS B A C \/ BetS A B C \/ BetS A C B);
  Cong_3 A B C a b c := Cong A B a b /\ Cong B C b c /\ Cong A C a c;
  TS P A B Q := exists X, BetS P X Q /\ Col A B X /\ nCol A B P;
  Triangle A B C := nCol A B C;

  OnCirc B J := exists X Y U, CI J U X Y /\ Cong U B X Y;
  InCirc P J := exists X Y U V W, CI J U V W /\ (eq P U \/ (BetS U Y X /\ Cong U X V W /\ Cong U P U Y));
  OutCirc P J := exists X U V W, CI J U V W /\ BetS U X P /\ Cong U X V W;

  cn_congruencetransitive :
   forall B C D E P Q, Cong P Q B C -> Cong P Q D E -> Cong B C D E;
  cn_congruencereflexive :
   forall A B, Cong A B A B;
  cn_equalityreverse :
   forall A B, Cong A B B A;
  cn_sumofparts :
   forall A B C a b c, Cong A B a b -> Cong B C b c -> BetS A B C -> BetS a b c -> Cong A C a c;
  cn_stability :
   forall A B, ~ neq A B -> eq A B;
  axiom_circle_center_radius :
   forall A B C J P, CI J A B C -> OnCirc P J -> Cong A P B C;
  axiom_lower_dim : nCol PA PB PC;
  axiom_betweennessidentity :
   forall A B, ~ BetS A B A;
  axiom_betweennesssymmetry :
   forall A B C, BetS A B C -> BetS C B A;
  axiom_innertransitivity :
   forall A B C D,
    BetS A B D -> BetS B C D -> BetS A B C;
  axiom_connectivity :
   forall A B C D,
    BetS A B D -> BetS A C D -> ~ BetS A B C -> ~ BetS A C B ->
    eq B C;
  axiom_nocollapse :
   forall A B C D, neq A B -> Cong A B C D -> neq C D;
  axiom_5_line :
   forall A B C D a b c d,
    Cong B C b c -> Cong A D a d -> Cong B D b d ->
    BetS A B C -> BetS a b c -> Cong A B a b ->
    Cong D C d c;
  postulate_Pasch_inner :
   forall A B C P Q,
    BetS A P C -> BetS B Q C -> nCol A C B ->
    exists X, BetS A X Q /\ BetS B X P;
  postulate_Pasch_outer :
   forall A B C P Q,
    BetS A P C -> BetS B C Q -> nCol B Q A ->
    exists X, BetS A X Q /\ BetS B P X;
  postulate_Euclid2 : forall A B, neq A B -> exists X, BetS A B X;
  postulate_Euclid3 : forall A B, neq A B -> exists X, CI X A A B;
}.

Class euclidean_neutral_ruler_compass `(Ax : euclidean_neutral) :=
{
  postulate_line_circle :
   forall A B C K P Q,
    CI K C P Q -> InCirc B K -> neq A B ->
    exists X Y, Col A B X /\ BetS A B Y /\ OnCirc X K /\ OnCirc Y K /\ BetS X B Y;
  postulate_circle_circle :
   forall C D F G J K P Q R S,
    CI J C R S -> InCirc P J ->
    OutCirc Q J -> CI K D F G ->
    OnCirc P K -> OnCirc Q K ->
    exists X, OnCirc X J /\ OnCirc X K
}.

Class euclidean_euclidean `(Ax : euclidean_neutral_ruler_compass) :=
{
  postulate_Euclid5 :
   forall a p q r s t,
    BetS r t s -> BetS p t q -> BetS r a q ->
    Cong p t q t -> Cong t r t s -> nCol p q s ->
    exists X, BetS p a X /\ BetS s q X
}.

Class area `(Ax : euclidean_euclidean) :=
{
  EF : Point -> Point -> Point -> Point -> Point -> Point -> Point -> Point -> Prop;
  ET : Point -> Point -> Point -> Point -> Point -> Point -> Prop;
  axiom_congruentequal :
   forall A B C a b c, Cong_3 A B C a b c -> ET A B C a b c;
  axiom_ETpermutation :
   forall A B C a b c,
    ET A B C a b c ->
    ET A B C b c a /\
    ET A B C a c b /\
    ET A B C b a c /\
    ET A B C c b a /\
    ET A B C c a b;
  axiom_ETsymmetric :
   forall A B C a b c, ET A B C a b c -> ET a b c A B C;
  axiom_EFpermutation :
   forall A B C D a b c d,
   EF A B C D a b c d ->
     EF A B C D b c d a /\
     EF A B C D d c b a /\
     EF A B C D c d a b /\
     EF A B C D b a d c /\
     EF A B C D d a b c /\
     EF A B C D c b a d /\
     EF A B C D a d c b;
  axiom_halvesofequals :
   forall A B C D a b c d, ET A B C B C D ->
                           TS A B C D -> ET a b c b c d ->
                           TS a b c d -> EF A B D C a b d c -> ET A B C a b c;
  axiom_EFsymmetric :
   forall A B C D a b c d, EF A B C D a b c d ->
                           EF a b c d A B C D;
  axiom_EFtransitive :
   forall A B C D P Q R S a b c d,
     EF A B C D a b c d -> EF a b c d P Q R S ->
     EF A B C D P Q R S;
  axiom_ETtransitive :
   forall A B C P Q R a b c,
    ET A B C a b c -> ET a b c P Q R -> ET A B C P Q R;
  axiom_cutoff1 :
   forall A B C D E a b c d e,
    BetS A B C -> BetS a b c -> BetS E D C -> BetS e d c ->
    ET B C D b c d -> ET A C E a c e ->
    EF A B D E a b d e;
  axiom_cutoff2 :
   forall A B C D E a b c d e,
    BetS B C D -> BetS b c d -> ET C D E c d e -> EF A B D E a b d e ->
    EF A B C E a b c e;
  axiom_paste1 :
   forall A B C D E a b c d e,
    BetS A B C -> BetS a b c -> BetS E D C -> BetS e d c ->
    ET B C D b c d -> EF A B D E a b d e ->
    ET A C E a c e;
  axiom_deZolt1 :
   forall B C D E, BetS B E D -> ~ ET D B C E B C;
  axiom_deZolt2 :
   forall A B C E F,
    Triangle A B C -> BetS B E A -> BetS B F C ->
  ~ ET A B C E B F;
  axiom_paste2 :
   forall A B C D E M a b c d e m,
    BetS B C D -> BetS b c d -> ET C D E c d e ->
    EF A B C E a b c e ->
    BetS A M D -> BetS B M E ->
    BetS a m d -> BetS b m e ->
    EF A B D E a b d e;
  axiom_paste3 :
   forall A B C D M a b c d m,
    ET A B C a b c -> ET A B D a b d ->
    BetS C M D ->
    (BetS A M B \/ eq A M \/ eq M B) ->
    BetS c m d ->
    (BetS a m b \/ eq a m \/ eq m b) ->
    EF A C B D a c b d;
  axiom_paste4 :
   forall A B C D F G H J K L M P e m,
    EF A B m D F K H G -> EF D B e C G H M L ->
    BetS A P C -> BetS B P D -> BetS K H M -> BetS F G L ->
    BetS B m D -> BetS B e C -> BetS F J M -> BetS K J L ->
    EF A B C D F K M L;
}. *)

Require Export GeoCoq.Axioms.continuity_axioms.

Require Export GeoCoq.Meta_theory.Continuity.elementary_continuity_props.

Require Export GeoCoq.Meta_theory.Parallel_postulates.parallel_postulates.



Section Tarski_neutral_to_Euclid_neutral.



Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.



Definition Tcircle : Type := Tpoint*Tpoint*Tpoint %type.



Definition OnCirc P (C:Tcircle) := 

  match C with 

  (X,A,B) => tarski_axioms.Cong X P A B

  end.



Definition CI (J:Tcircle) A C D := J=(A,C,D) /\ C<>D.



Definition InCirc P (J:Tcircle) :=

   match J with

  (C,A,B) => 

   exists X Y, Definitions.BetS X C Y /\ tarski_axioms.Cong C Y A B /\

               tarski_axioms.Cong C X A B /\ Definitions.BetS X P Y

  end.



Definition OutCirc P (J:Tcircle) :=

   match J with

  (C,A,B) => 

      exists X, Definitions.BetS C X P /\ tarski_axioms.Cong C X A B

 end.



Lemma on : 

 forall A B C D J, CI J A C D /\ OnCirc B J ->

                   tarski_axioms.Cong A B C D.

Proof.

intros.

unfold CI,OnCirc in *.

destruct J.

destruct p.

spliter.

congruence.

Qed.



Lemma inside : forall A B C J P,

  CI J C A B /\ InCirc P J <-> 

  exists X Y, CI J C A B /\ 

   Definitions.BetS X C Y /\ 

   tarski_axioms.Cong C Y A B /\ 

   tarski_axioms.Cong C X A B /\ 

   Definitions.BetS X P Y.

Proof.

intros.

unfold InCirc, CI.

destruct J;destruct p.

split.

intros;spliter.

decompose [ex and] H0;clear H0.

exists x. exists x0.

inversion H; subst; auto.

intros.

decompose [ex and] H;clear H.

inversion H1; subst;split; auto.

exists x; exists x0;auto.

Qed.



Lemma outside : forall A B C J P,

  CI J C A B /\ OutCirc P J <->

  exists X, CI J C A B /\ Definitions.BetS C X P /\

   tarski_axioms.Cong C X A B.

Proof.

intros.

unfold OutCirc, CI.

destruct J;destruct p.

split.

intros;spliter.

decompose [ex and] H0;clear H0.

exists x.

inversion H; subst; auto.

intros.

decompose [ex and] H;clear H.

inversion H0; subst;split; auto.

exists x;auto.

Qed.



End Tarski_neutral_to_Euclid_neutral.



Section circle_continuity.



Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.



Lemma bet_cases : forall B C D1 D2,

 C<>B ->

 Definitions.BetS D1 B D2 ->

 Definitions.BetS D1 C D2 ->

 Definitions.BetS D1 B C \/ Definitions.BetS C B D2.

Proof.

intros.

assert (T:Bet D1 C B \/ Bet D1 B C).

  apply (l5_3 D1 C B D2);unfold Definitions.BetS in *;spliter;finish.

 destruct T.

 right.

 unfold Definitions.BetS in *;spliter.

 assert (Bet C B D2)

  by (eBetween).

 unfold Definitions.BetS.

 repeat split;auto.

 left.

 unfold Definitions.BetS.

 unfold Definitions.BetS in *;spliter;repeat split;auto.

Qed.



Lemma circle_line :

 circle_circle ->

 forall A B C K P Q,

    CI K C P Q -> InCirc B K ->  A <> B ->

    exists X Y, Definitions.Col A B X /\ Definitions.Col A B Y /\

  OnCirc X K /\ OnCirc Y K /\ Definitions.BetS X B Y.

Proof.

intros.

apply circle_circle__circle_circle_bis in H.

apply circle_circle_bis__one_point_line_circle in H.

apply one_point_line_circle__two_points_line_circle in H.

unfold CI in *.

destruct K.

destruct p.

spliter.

injection H0.

intros;subst.

unfold InCirc in *.

unfold two_points_line_circle in H.



destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].

destruct (eq_dec_points B C).

subst.

assert (HColD: Definitions.Col A C C)

   by (unfold Definitions.Col;Between).

assert (HBet: Bet C C D2) by Between.

destruct (H C D2 A C C HColD H2 HBet) as [Z1 [Z2 HZ]].

spliter.

exists Z1. exists Z2.

repeat split;try assumption.

unfold OnCircle, OnCirc in *;eCong.

unfold OnCircle, OnCirc in *;eCong.

assert (C<>D2)

 by (unfold Definitions.BetS in *;spliter;auto).

assert (Z1<>Z2) by auto.

unfold OnCircle in *.

intro;treat_equalities;intuition.

unfold OnCircle in *.

intro;treat_equalities.

unfold Definitions.BetS in *;intuition.

assert (TwoCases:Definitions.BetS D1 B C \/ Definitions.BetS C B D2)

 by (apply bet_cases;auto).

destruct TwoCases.

- assert (HColD: Definitions.Col A B B)

   by (unfold Definitions.Col;Between).

assert (HBet:Bet C B D1)

 by (unfold Definitions.BetS in *;spliter;finish).

destruct (H C D1 A B B HColD H2 HBet)

 as [Z1 [Z2 HZ]].

exists Z1.

exists Z2.

spliter.

assert (B<>D1)

 by (unfold Definitions.BetS in *;spliter;auto).

assert (Z1<>Z2) by auto.

assert (Z1<>B).

{

 intro. subst.

 unfold OnCircle in *.

 assert (B=D1) by (apply between_cong with C;finish).

 subst. intuition.

}

assert_diffs.

assert (B<>Z2).

{

 intro. subst.

 assert (Bet C Z2 D1) 

  by (unfold BetS in *;spliter;finish).

 unfold OnCircle in *.

 assert (Z2=D1)

  by (apply between_cong with C;finish).

 intuition.

}

assert (Definitions.BetS Z1 B Z2)

 by (unfold Definitions.BetS;auto).

unfold OnCirc;simpl.

unfold OnCircle in *.

repeat split; eCong.

- assert (HColD: Definitions.Col A B B)

   by (unfold Definitions.Col;Between).

assert (HBet:Bet C B D2)

 by (unfold Definitions.BetS in *;spliter;finish).

destruct (H C D2 A B B HColD H2 HBet)

 as [Z1 [Z2 HZ]].

exists Z1.

exists Z2.

spliter.

assert (B<>D2)

 by (unfold Definitions.BetS in *;spliter;auto).

assert (Z1<>Z2) by auto.

assert (Z1<>B).

{

 intro. subst.

 unfold OnCircle in *.

 assert (B=D2) by (apply between_cong with C;finish).

 subst. intuition.

}

assert_diffs.

assert (B<>Z2).

{

 intro. subst.

 assert (Bet C Z2 D2) 

  by (unfold BetS in *;spliter;finish).

 unfold OnCircle in *.

 assert (Z2=D2)

  by (apply between_cong with C;finish).

 intuition.

}

assert (Definitions.BetS Z1 B Z2)

 by (unfold Definitions.BetS;auto).

unfold OnCirc;simpl.

unfold OnCircle in *.

repeat split; eCong.

Qed.



Lemma circle_circle' :

 circle_circle ->

 forall C D F G J K P Q R S,

    CI J C R S -> InCirc P J ->

    OutCirc Q J -> CI K D F G ->

    OnCirc P K -> OnCirc Q K ->

    exists X, OnCirc X J /\ OnCirc X K.

Proof.

intros.

unfold circle_circle in H.

destruct J.

destruct p.

destruct K.

destruct p.

unfold CI in *.

spliter.

injection H0;intros;subst.

injection H3;intros;subst.

clear H0 H3.

unfold OnCirc in *.

unfold InCirc in *.

destruct H1 as [D1 [D2 HD]].

spliter.

unfold OutCirc in *.

destruct H2 as [X HX].

spliter.

assert (OnCircle P D Q)

 by (unfold OnCircle;eCong).

assert (OnCircle Q D Q)

 by (unfold OnCircle;eCong).

assert (InCircle P C D1).

{

 unfold InCircle.

 destruct (eq_dec_points C P).

 subst. apply le_trivial.

 assert (TwoCases:Definitions.BetS D1 P C \/ Definitions.BetS C P D2)

  by (apply bet_cases;auto).

 destruct TwoCases.

 exists P.

 split; unfold Definitions.BetS in *;spliter; finish.

 apply l5_6 with C P C D2.

 exists P.

 split; unfold Definitions.BetS in *;spliter; finish.

 finish.

 eCong.

}

assert (OutCircle Q C D1).

{

 unfold OutCircle.

 exists X.

 split; unfold Definitions.BetS in *;spliter; eCong.

}

assert (Hex: exists Z : Tpoint, OnCircle Z C D1 /\ OnCircle Z D Q) by eauto.

destruct Hex as [Z HZ].

exists Z.

unfold OnCircle in *;spliter;split;eCong.

Qed.



End circle_continuity.



Section Neutral.



Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.



Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.

Proof.

eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS  tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).

- intros;apply cong_transitivity with P Q;finish.

- intro;finish.

- intro;finish.

- intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.

- intros.

  destruct (eq_dec_points A B);intuition.

- intros.

  decompose [ex and] H0.

  unfold CI in *.

  spliter.

  congruence.

- assert (T:=lower_dim).

  split.

  intro H;rewrite H in *;apply T;Between.

  split.

  intro H;rewrite H in *;apply T;Between.

  split.

  intro H;rewrite H in *;apply T;Between.

  split.

  unfold Definitions.BetS in *;intuition.

  unfold Definitions.BetS in *;intuition.

- intros; unfold Definitions.BetS;

intro;spliter;treat_equalities;intuition.

- intros;unfold Definitions.BetS in *;

intros;spliter;finish.

- intros;unfold Definitions.BetS in *;

intros;spliter;try assumption;eBetween.

- intros;unfold Definitions.BetS in *;

intros;spliter .

assert (Bet A B C \/ Bet A C B) by (apply l5_3 with D;auto).

assert (~ (Bet A C B /\ A <> C /\ B <> C)) by intuition.

assert (T3:=eq_dec_points A B).

assert (T4:=eq_dec_points A C).

assert (T5:=eq_dec_points B C).

tauto.

- intros;intro;treat_equalities;finish.

- intros.

assert (tarski_axioms.Cong C D c d)

 by (apply (five_segment A a B b C c D d);

unfold Definitions.BetS in *;spliter;auto).

finish.

- intros;unfold Definitions.BetS in *;spliter.

  destruct (inner_pasch A B C P Q H H0) as [X [HXa HXb]]. 

  exists X.

  assert_diffs.

  assert (~ Bet A C B) by tauto.

  assert (B<>C) by auto.

  assert (~ Bet A B C) by tauto.

  assert (C<>A) by auto.

  assert (~ Bet C A B) by tauto.

  assert (~ Bet B C A) by Between.

  repeat split;Between.



 all:intro;treat_equalities;assert_cols;

 assert (HCol:Definitions.Col A B C) by ColR;

 unfold Definitions.Col in HCol;

 tauto.

- intros;unfold Definitions.BetS in *;spliter.

  assert (~ Bet B Q A) by tauto.

  assert (A<>Q) by auto.

  assert (~ Bet B A Q) by tauto.

  assert (B<>A) by auto.

  assert (Q<>B) by auto.

  assert (~ Bet Q B A) by tauto.

 assert (~ Bet A Q B) by finish.

  assert (Bet Q C B) by finish.

  destruct (outer_pasch Q A C B P H18 H) as [X [HXa HXb]].

  exists X.

   assert_diffs.

  repeat split;Between.

  intro;treat_equalities;assert_cols;

 assert (HCol:Definitions.Col B A Q) by ColR;

 unfold Definitions.Col in HCol;tauto.

  intro;treat_equalities;assert_cols;

 assert (HCol:Definitions.Col B A X) by ColR;

 unfold Definitions.Col in HCol;tauto.

  intro;treat_equalities;assert_cols;

  assert (HCol:Definitions.Col A Q B) by ColR;

  unfold Definitions.Col in HCol;tauto.

  intro;treat_equalities;assert_cols;

  assert (HCol:Definitions.Col A Q B) by ColR;

  unfold Definitions.Col in HCol;tauto.

- intros. destruct (segment_construction A B A B) as [X [HXa HXb]].

  exists X; unfold Definitions.BetS;assert_diffs;auto.

- intros.

  unfold CI;exists (A,A,B);auto.

Defined.



End Neutral.



Section RulerAndCompass.



Context `{TRC:Tarski_ruler_and_compass}.



Lemma BetS_BetS : forall A B C,

 Definitions.BetS A B C <-> BetS A B C.

Proof.

intros.

unfold BetS;simpl.

intuition.

Qed.



Lemma Col_Col : forall A B C,

 Definitions.Col A B C <-> Col A B C.

Proof.

intros.

unfold Definitions.Col, Col, BetS.

simpl.

unfold Definitions.BetS,eq.

split.

intros.

destruct (eq_dec_points A B).

left;auto.

destruct (eq_dec_points A C).

right;left;auto.

destruct (eq_dec_points B C).

right;right;left;auto.

decompose [or] H.

right;right;right;right;left;auto.

right;right;right;right;right;finish.

right;right;right;left;finish.

intros.

decompose [or] H;subst;spliter;finish.

Qed.



Lemma nCol_not_Col : forall A B C,

 nCol A B C -> ~ Col A B C.

Proof.

unfold nCol.

unfold Col.

intuition.

Qed.



Lemma InCirc_not_OnCirc: forall J A,

 InCirc J A -> ~ OnCirc J A.

Proof.

unfold InCirc, OnCirc in *.

intros A J.

destruct J as [[X C] D].

intros.

destruct H as [U [V HUV]];spliter.

intro.

unfold Definitions.BetS in *;spliter.

assert (tarski_axioms.Cong X U X V) by eCong.

assert (Midpoint X U V) by (split;finish).

assert (Midpoint X A V).

apply (cong_col_mid A X V).

assumption.

ColR.

eCong.

treat_equalities;intuition.

Qed.



Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.

Proof.

intros.

unfold euclidean_axioms.InCirc in *.

destruct K as [[C U]Â V].

unfold euclidean_axioms.InCirc in *.

destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].

destruct HW2.

- unfold eq in *;subst.

unfold euclidean_axioms.CI in *;simpl in *.

unfold CI in *.

spliter.

inversion H;subst.

destruct (eq_dec_points C0 V).

subst.

destruct (symmetric_point_construction W V) as [X0 HX].

exists X0.

exists W.

assert_bets.

assert_diffs.

split;finish.

unfold Definitions.BetS;finish.

split;finish.

split;finish.

unfold Definitions.BetS;finish.

destruct (segment_construction_3 C0 V V W H1 H0) as [X0 [HX0 HX1]].

destruct (symmetric_point_construction X0 C0) as [Y0 HY0].

exists X0.

exists Y0.

assert_bets.

assert_diffs.

unfold Definitions.BetS;split;finish.

split.

eCong.

split.

eCong.

split;finish.

- spliter.

unfold euclidean_axioms.CI in *;simpl in *;unfold CI in *;spliter.

inversion H2;subst.

assert (C0 <> A).

 {

  intro;treat_equalities.

  unfold Definitions.BetS in *;intuition.

 }



destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].

destruct (eq_dec_points A X0).

 {

  treat_equalities.

  assert_diffs.

  assert (HCong: tarski_axioms.Cong C0 Y C0 X) by eCong.

  unfold Definitions.BetS in *;spliter.

  assert (eq:= between_cong C0 X Y H HCong).

  subst;intuition.

 }



destruct (symmetric_point_construction X0 C0) as [Y0 HY0].

destruct (eq_dec_points A Y0).

 {

  treat_equalities.

  unfold Definitions.BetS in *;spliter.

  assert_diffs.

  unfold Midpoint in *;spliter.

  assert (HCong: tarski_axioms.Cong C0 X0 C0 X) by eCong.

  assert (HCong2: tarski_axioms.Cong C0 Y C0 X) by eCong.

  assert (eq:= between_cong C0 X Y H HCong2).

  subst;intuition.  

 }

destruct HX0 as [HA [ HB [HC | HC]]].

exists X0.

exists Y0.

assert_diffs.

split;unfold Definitions.BetS;finish.

split.

eCong.

split.

eCong.

assert_bets;finish.

split;finish.

eBetween.



assert (Lt C0 Y C0 X)

 by (unfold Definitions.BetS in *;spliter;apply (bet__lt1213);auto).

assert (Le C0 X0 C0 A) 

 by (apply (bet__le1213);auto).

assert (HCong: tarski_axioms.Cong C0 X0 C0 X) by eCong.

assert (Lt C0 X C0 A)

 by (apply (cong2_lt__lt C0 X0 C0 A);finish).

assert (Lt C0 Y C0 A)

 by (apply (le3456_lt__lt) with C0 X;auto using lt__le).

assert (Hc : tarski_axioms.Cong C0 Y C0 A) by finish.

apply cong__nlt in Hc.

intuition.

Qed.



Lemma OnCirc_OnCirc : forall A P Q R, Q<>R -> OnCirc A (P,Q,R) -> euclidean_axioms.OnCirc A (P,Q,R).

Proof.

intros.

unfold OnCirc in *.

unfold euclidean_axioms.OnCirc.

exists Q.

exists R.

exists P.

unfold euclidean_axioms.CI;simpl;unfold CI.

finish.

Qed.



Lemma eOnCirc_OnCirc : forall A K, euclidean_axioms.OnCirc A K -> OnCirc A K.

Proof.

intros.

unfold OnCirc.

destruct K.

destruct p.

unfold euclidean_axioms.OnCirc in *.

destruct H as [X [Y [U HXY]]].

spliter.

unfold euclidean_axioms.CI in *;simpl in *;unfold CI in *.

spliter.

inversion H;subst;finish.

Qed.



Lemma eOutCirc_OutCirc : forall A K, euclidean_axioms.OutCirc A K -> OutCirc A K.

Proof.

intros.

destruct K.

destruct p.

unfold euclidean_axioms.OutCirc in *.

destruct H as [X [Y [U [V HV]]]].

spliter.

unfold euclidean_axioms.CI in *;simpl in *;unfold CI in *.

spliter.

inversion H;subst.

exists X;finish.

Qed.



Lemma InCircCenter: forall U V W, V<>W -> InCirc U (U, V, W).

Proof.

intros.



unfold InCirc.

destruct (eq_dec_points U V).

subst.

exists W.

destruct (symmetric_point_construction W V) as [Y HY].

exists Y.

assert_diffs.

unfold Definitions.BetS.

split;finish.

destruct (segment_construction_3 U V V W H0 H) as [X HX].

destruct (symmetric_point_construction X U) as [Y HY].

spliter.

assert_diffs.

assert_bets.

exists X. exists Y.

split.

unfold Definitions.BetS;finish.

split.

eCong.

split.

eCong.

unfold Definitions.BetS;finish.

Qed.



Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass :

  euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.

Proof.

assert (cc : circle_circle).

cut (circle_circle_axiom).

apply equivalent_variants_of_circle_circle; simpl; tauto.

unfold circle_circle_axiom.

exact circle_circle_continuity.

split.

- intros.

  apply InCirc_InCirc in H0.

  destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].

  spliter.

  destruct (bet_dec A B Y).

  exists X.

  exists Y.

  split.

  apply (Col_Col A B X); auto.

  split.

  unfold BetS;simpl.

  unfold Definitions.BetS.

  split.

  assumption.

  split.

  assumption.

  unfold Definitions.BetS in *;spliter;finish.



  split.

  destruct K as [p q].

  destruct p.

  apply OnCirc_OnCirc.

  { 

   unfold euclidean_axioms.CI in *;simpl in *;unfold CI in *.

   spliter.

   inversion H;subst;auto.

  }

  assumption.

  split.

  destruct K as [p q].

  destruct p.

  apply OnCirc_OnCirc.

  {

  unfold euclidean_axioms.CI in *;simpl in *;unfold CI in *.

   spliter.

   inversion H;subst;auto.

  }

  assumption.

  

  unfold BetS;simpl;auto.



 exists Y.

 exists X.

 split.

 apply (Col_Col A B Y); auto.

 split.

 unfold Definitions.BetS in *;spliter;assert_diffs.

 unfold Definitions.Col in H2.

 destruct H2.

 unfold BetS;simpl;unfold Definitions.BetS.

 split;finish.

 destruct H2.

 exfalso;apply H7.

 eBetween.

 unfold  BetS;simpl;unfold Definitions.BetS.

 split;finish.

  exfalso;apply H7;eBetween.

 split.

  destruct K as [p q].

  destruct p.

  apply OnCirc_OnCirc.

  { 

   unfold euclidean_axioms.CI in *;simpl in *;unfold CI in *.

   spliter.

   inversion H;subst;auto.

  }

  assumption.

  split.

    destruct K as [p q].

  destruct p.

  apply OnCirc_OnCirc.

  { 

   unfold euclidean_axioms.CI in *;simpl in *;unfold CI in *.

   spliter.

   inversion H;subst;auto.

  }

  assumption.

  unfold BetS;simpl;unfold Definitions.BetS in *;spliter;finish.



- simpl.

  intros.

  apply InCirc_InCirc in H0.

  apply eOnCirc_OnCirc in H3.

  apply eOnCirc_OnCirc in H4.

  apply eOutCirc_OutCirc in H1.

  destruct (circle_circle' cc C D F G J K P Q R S H) as [X HX];auto.

  spliter.

  exists X.

  split.

  destruct J.

  destruct p.

  unfold CI in *.

  spliter.

  inversion H;subst.

  apply OnCirc_OnCirc;auto.

  destruct K.

  destruct p.

  unfold CI in *.

  spliter.

  inversion H2;subst.

  apply OnCirc_OnCirc;auto.

Defined.



End RulerAndCompass.



Section Euclidean.



Context `{TRC:Tarski_ruler_and_compass}.

Context `{TE:@Tarski_euclidean Tn TnEQD}.



Lemma Euclid5 :

   forall a p q r s t,

    BetS r t s -> BetS p t q -> BetS r a q ->

    Cong p t q t -> Cong t r t s -> nCol p q s ->

    exists X, BetS p a X /\ BetS s q X.

Proof.

intros.

assert (T:tarski_s_parallel_postulate -> 

        euclid_5).

{

 assert (T:=equivalent_postulates_without_decidability_of_intersection_of_lines_bis).

 unfold all_equiv.all_equiv in *.

 apply T;simpl;auto 10.

}

assert (T2:euclid_5).

apply T.

unfold tarski_s_parallel_postulate.

apply euclid.

unfold euclid_5 in *.

assert (T3:exists I : Tpoint, Definitions.BetS s q I /\ Definitions.BetS p a I).

apply (T2 p q r s t a);

auto using BetS_BetS.

unfold BetS in *;simpl in *;

unfold Definitions.BetS in *;spliter;finish.

intro HnCol.

apply Col_Col in HnCol.

apply nCol_not_Col in H4;intuition.

finish.

destruct T3 as [X HX].

exists X;spliter;auto.

Qed.



Global Instance Euclid_follows_from_Tarski_euclidean :

 euclidean_euclidean Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass.

Proof.

intros.

split.

apply Euclid5.

Qed.



End Euclidean.
