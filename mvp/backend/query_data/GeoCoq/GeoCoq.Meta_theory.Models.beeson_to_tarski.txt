Require Import GeoCoq.Axioms.beeson_s_axioms.
(* GeoCoq.Axioms.beeson_s_axioms:
Class intuitionistic_Tarski_neutral_dimensionless := {
 ITpoint : Type;
 IBet : ITpoint -> ITpoint -> ITpoint -> Prop;
 ICong : ITpoint -> ITpoint -> ITpoint -> ITpoint -> Prop;
 Cong_stability : forall A B C D, ~ ~ ICong A B C D -> ICong A B C D;
 Bet_stability : forall A B C, ~ ~ IBet A B C -> IBet A B C;
 IT A B C := ~ (A<>B /\ B<>C /\ ~ IBet A B C);
 ICol A B C :=  ~ (~ IT C A B /\ ~ IT A C B /\ ~ IT A B C);
 Icong_identity : forall A B C, ICong A B C C -> A = B;
 Icong_inner_transitivity : forall A B C D E F,
   ICong A B C D -> ICong A B E F -> ICong C D E F;
 Icong_pseudo_reflexivity : forall A B, ICong A B B A;
 Isegment_construction : forall A B C D,
    A<>B -> exists E, IT A B E /\ ICong B E C D;
 Ifive_segment  : forall A A' B B' C C' D D',
    ICong A B A' B' ->
    ICong B C B' C' ->
    ICong A D A' D' ->
    ICong B D B' D' ->
    IT A B C -> IT A' B' C' -> A <> B -> ICong C D C' D';
 Ibetween_identity : forall A B, ~ IBet A B A;
 Ibetween_symmetry : forall A B C, IBet A B C -> IBet C B A;
 Ibetween_inner_transitivity : forall A B C D, IBet A B D -> IBet B C D -> IBet A B C;
 Iinner_pasch : forall A B C P Q,
   IBet A P C -> IBet B Q C -> ~ ICol A B C ->
   exists x, IBet P x B /\ IBet Q x A;
 PA : ITpoint;
 PB : ITpoint;
 PC : ITpoint;
 Ilower_dim : ~ IT PC PA PB /\ ~ IT PA PC PB /\ ~ IT PA PB PC
}. *)

Require Import GeoCoq.Axioms.tarski_axioms.
(* GeoCoq.Axioms.tarski_axioms:
Require Export GeoCoq.Utils.general_tactics.

Class Tarski_neutral_dimensionless :=
{
 Tpoint : Type;
 Bet : Tpoint -> Tpoint -> Tpoint -> Prop;
 Cong : Tpoint -> Tpoint -> Tpoint -> Tpoint -> Prop;
 cong_pseudo_reflexivity : forall A B, Cong A B B A;
 cong_inner_transitivity : forall A B C D E F,
   Cong A B C D -> Cong A B E F -> Cong C D E F;
 cong_identity : forall A B C, Cong A B C C -> A = B;
 segment_construction : forall A B C D,
   exists E, Bet A B E /\ Cong B E C D;
 five_segment : forall A A' B B' C C' D D',
   Cong A B A' B' ->
   Cong B C B' C' ->
   Cong A D A' D' ->
   Cong B D B' D' ->
   Bet A B C -> Bet A' B' C' -> A <> B -> Cong C D C' D';
 between_identity : forall A B, Bet A B A -> A = B;
 inner_pasch : forall A B C P Q,
   Bet A P C -> Bet B Q C ->
   exists X, Bet P X B /\ Bet Q X A;
 PA : Tpoint;
 PB : Tpoint;
 PC : Tpoint;
 lower_dim : ~ (Bet PA PB PC \/ Bet PB PC PA \/ Bet PC PA PB)
}.

Class Tarski_neutral_dimensionless_with_decidable_point_equality
 `(Tn : Tarski_neutral_dimensionless) :=
{
 point_equality_decidability : forall A B : Tpoint, A = B \/ ~ A = B
}.

Class Tarski_2D
 `(TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality) :=
{
 upper_dim : forall A B C P Q,
   P <> Q -> Cong A P A Q -> Cong B P B Q -> Cong C P C Q ->
   (Bet A B C \/ Bet B C A \/ Bet C A B)
}.

Class Tarski_3D
 `(TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality) :=
{
 S1 : Tpoint;
 S2 : Tpoint;
 S3 : Tpoint;
 S4 : Tpoint;
 lower_dim_3 : ~ exists X,
   (Bet S1 S2 X \/ Bet S2 X S1 \/ Bet X S1 S2) /\ (Bet S3 S4 X \/ Bet S4 X S3 \/ Bet X S3 S4) \/
   (Bet S1 S3 X \/ Bet S3 X S1 \/ Bet X S1 S3) /\ (Bet S2 S4 X \/ Bet S4 X S2 \/ Bet X S2 S4) \/
   (Bet S1 S4 X \/ Bet S4 X S1 \/ Bet X S1 S4) /\ (Bet S2 S3 X \/ Bet S3 X S2 \/ Bet X S2 S3);
 upper_dim_3 : forall A B C P Q R,
   P <> Q -> Q <> R -> P <> R ->
   Cong A P A Q -> Cong B P B Q -> Cong C P C Q ->
   Cong A P A R -> Cong B P B R -> Cong C P C R ->
   (Bet A B C \/ Bet B C A \/ Bet C A B)
}.

Class Tarski_euclidean
 `(TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality) :=
{
 euclid : forall A B C D T,
   Bet A D T -> Bet B D C -> A<>D ->
   exists X, exists Y,
   Bet A B X /\ Bet A C Y /\ Bet X T Y
}.

Class Tarski_ruler_and_compass
 `(TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality) :=
{
 circle_circle_continuity : forall A B C D B' D',
   Cong A B' A B -> Cong C D' C D ->
   Bet A D' B -> Bet C B' D ->
   exists Z, Cong A Z A B /\ Cong C Z C D
}.

Class Tarski_continuous
 `(TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality) :=
{
 continuity : forall (Alpha Beta : Tpoint -> Prop),
   (exists A, forall X Y, Alpha X -> Beta Y -> Bet A X Y) ->
   (exists B, forall X Y, Alpha X -> Beta Y -> Bet X B Y)
}. *)



Section Proof_of_eq_stability_in_IT.



Context `{BTn:intuitionistic_Tarski_neutral_dimensionless}.



Lemma cong_stability_eq_stability : forall A B : ITpoint, ~ A <> B -> A = B.

Proof.

intros A B HAB.

apply Icong_identity with A.

apply Cong_stability.

intro HNCong.

apply HAB.

intro HEq.

subst.

apply HNCong.

apply Icong_pseudo_reflexivity.

Qed.



End Proof_of_eq_stability_in_IT.



Require Import Classical.



Section Intuitionistic_Tarski_to_Tarski.



Context `{BTn:intuitionistic_Tarski_neutral_dimensionless}.



Lemma col_dec : forall A B C, ICol A B C \/ ~ ICol A B C.

Proof.

intros.

tauto.

Qed.



Lemma eq_dec : forall A B :ITpoint, A=B \/ A<>B.

Proof.

intros.

tauto.

Qed.



Definition BetT A B C := IBet A B C \/ A=B \/ B=C.



Lemma bet_id : forall A B : ITpoint, BetT A B A -> A = B.

Proof.

intros.

unfold BetT in H.

decompose [or] H.

apply Ibetween_identity in H0.

elim H0.

assumption.

intuition.

Qed.



Lemma IT_chara : forall A B C,

 IT A B C <-> A=B \/ B=C \/ IBet A B C.

Proof.

intros.

unfold IT.

tauto. 

Qed.



Lemma BetT_symmetry : forall A B C, BetT A B C -> BetT C B A.

Proof.

intros.

unfold BetT in *.

intuition.

left.

apply Ibetween_symmetry.

assumption.

Qed.



Lemma BetT_id : forall A B, BetT A B A -> A=B.

Proof.

intros.

unfold BetT in *.

intuition.

apply Ibetween_identity in H0.

elim H0.

Qed.



Lemma pasch_col_case : forall A B C P Q : ITpoint,

        BetT A P C ->

        BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\ BetT Q x A.

Proof.

intros.

elim (eq_dec A B);intro.

 subst.

 exists B.

 unfold BetT;auto.

elim (eq_dec A C);intro.

 subst.

 apply BetT_id in H.

 subst.

 exists P.

 unfold BetT;auto.

elim (eq_dec B C);intro.

 subst.

 apply BetT_id in H0.

 subst.

 exists Q.

 unfold BetT;auto.

elim (eq_dec B Q);intro.

 subst.

 exists Q.

 unfold BetT;auto.

elim (eq_dec C Q);intro.

 subst.

 exists P.

 split.

 unfold BetT;auto.

 apply BetT_symmetry.

 auto.

elim (eq_dec A P);intro.

 subst.

 exists P.

 unfold BetT;auto.

elim (eq_dec C P);intro.

 subst.

 exists Q.

 split.

 apply BetT_symmetry.

 auto.

 unfold BetT;auto.



unfold ICol in H1.

spliter.

apply not_and_or in H1.

induction H1.

apply NNPP in H1.

unfold IT in *.

apply not_and_or in H1.

induction H1.

apply NNPP in H1.

subst.

intuition.

apply not_and_or in H1.

induction H1.

apply NNPP in H1.

subst.

intuition.

apply NNPP in H1.

exists A.

split.

apply Ibetween_symmetry in H1.

induction H.

assert (T:=Ibetween_inner_transitivity B A P C H1 H).

unfold BetT.

left.

apply Ibetween_symmetry;auto.

induction H;subst.

unfold BetT;auto.

left.

apply Ibetween_symmetry;auto.

unfold BetT;auto.

apply not_and_or in H1.

induction H1.

apply NNPP in H1.

unfold IT in H1.

apply not_and_or in H1.

induction H1.

apply NNPP in H1.

subst.

intuition.

apply not_and_or in H1.

induction H1.

apply NNPP in H1.

subst.

intuition.

apply NNPP in H1.



exists C.



unfold BetT in H.

induction H;induction H0.

split.

apply BetT_symmetry.

left.



apply Ibetween_inner_transitivity with A.

apply Ibetween_symmetry;auto.

apply Ibetween_symmetry;auto.

apply BetT_symmetry.

left.

apply Ibetween_inner_transitivity with B.

assumption.

apply Ibetween_symmetry;auto.

induction H0;subst;intuition.

induction H;subst;intuition.

induction H;subst;intuition.



apply NNPP in H1.

induction H;induction H0.



exists B.

split.

unfold BetT;auto.



left.

apply Ibetween_symmetry.

apply Ibetween_inner_transitivity with C.

unfold IT in H1.

apply not_and_or in H1.

induction H1.

apply NNPP in H1.

subst.

intuition.

apply not_and_or in H1.

induction H1.

apply NNPP in H1.

subst.

intuition.

apply NNPP in H1.

assumption.

assumption.



induction H0;subst;intuition.

induction H;subst;intuition.

induction H;subst;intuition.

Qed.



Lemma pasch : forall A B C P Q : ITpoint,

        BetT A P C ->

        BetT B Q C -> exists x : ITpoint, BetT P x B /\ BetT Q x A.

Proof.

intros.

induction (col_dec A B C).

eapply pasch_col_case;eauto.



unfold BetT in *.

decompose [or] H;clear H.

decompose [or] H0;clear H0.



elim (Iinner_pasch A B C P Q H2 H H1).

intros.

spliter.

exists x.

split.

tauto.

tauto.



subst.

exists Q;auto.

subst.

exists P.

split.

auto.

left.

apply Ibetween_symmetry.

auto.

subst.

exists P;auto.

subst.

decompose [or] H0;clear H0.

exists Q.

split.

left.

apply Ibetween_symmetry.

auto.

auto.

subst.

exists Q;auto.

subst.

exists C;auto.

Qed.



Lemma five_segment:

 forall A A' B B' C C' D D' : ITpoint,

        ICong A B A' B' ->

        ICong B C B' C' ->

        ICong A D A' D' ->

        ICong B D B' D' ->

        BetT A B C -> BetT A' B' C' -> A <> B -> ICong C D C' D'.

Proof.

intros.

apply Ifive_segment with A A' B B' ;try assumption.

unfold IT.

intro.

spliter.

unfold BetT in *.

intuition.

unfold BetT in *.

unfold IT.

intro.

intuition.

Qed.



Lemma IT_trivial : forall A B, IT A A B.

Proof.

intros.

unfold IT.

intro.

spliter.

intuition.

Qed.



Lemma IT_trivial2 : forall A B, IT A B B.

Proof.

intros.

unfold IT.

intro.

spliter.

intuition.

Qed.



Lemma another_point : forall A, exists B:ITpoint, A<>B.

Proof.

intros.

assert (T:=Ilower_dim).

elim (eq_dec A beeson_s_axioms.PA);intro.

subst.

elim (eq_dec beeson_s_axioms.PA beeson_s_axioms.PB);intro.

rewrite <- H in *.

exfalso.

apply T.

apply IT_trivial.

exists beeson_s_axioms.PB.

assumption.

exists beeson_s_axioms.PA.

assumption.

Qed.



Lemma segment_construction :

 forall A B C D : ITpoint,

        exists E : ITpoint, BetT A B E /\ ICong B E C D.

Proof.

intros.

induction (eq_dec A B).

subst.

elim (another_point B);intros.

elim (Isegment_construction x B C D);intros.

exists x0.

split.

unfold BetT.

intuition.

intuition.

intuition.

elim (Isegment_construction A B C D H).

intros.

exists x.

spliter.

split;try assumption.

unfold IT in *.

unfold BetT.

tauto.

Qed.



Lemma lower_dim :

  ~ (BetT beeson_s_axioms.PA beeson_s_axioms.PB beeson_s_axioms.PC \/ 

     BetT beeson_s_axioms.PB beeson_s_axioms.PC beeson_s_axioms.PA \/ 

     BetT beeson_s_axioms.PC beeson_s_axioms.PA beeson_s_axioms.PB).

Proof.

assert (T:=Ilower_dim).

unfold BetT in *.

unfold ICol in  *.

unfold IT in *.

firstorder using Ibetween_symmetry.

Qed.



Lemma eq_dec_points_from_classic : forall A B : ITpoint, A = B \/ A <> B.

Proof.

intros.

apply classic.

Qed.



Instance IT_to_T : Tarski_neutral_dimensionless.

exact

(Build_Tarski_neutral_dimensionless

   ITpoint BetT ICong

   Icong_pseudo_reflexivity Icong_inner_transitivity Icong_identity

   segment_construction five_segment

   bet_id pasch beeson_s_axioms.PA beeson_s_axioms.PB beeson_s_axioms.PC lower_dim).

Defined.



Instance IT_to_TID :

  Tarski_neutral_dimensionless_with_decidable_point_equality IT_to_T.

Proof. split; apply eq_dec_points_from_classic. Defined.



End Intuitionistic_Tarski_to_Tarski.
