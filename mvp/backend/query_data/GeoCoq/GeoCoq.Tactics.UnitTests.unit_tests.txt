Require Import GeoCoq.Tarski_dev.Annexes.quadrilaterals_inter_dec.
(* GeoCoq.Tarski_dev.Annexes.quadrilaterals_inter_dec:
Require Export GeoCoq.Tarski_dev.Ch12_parallel_inter_dec.
Require Export GeoCoq.Tarski_dev.Annexes.Tagged_predicates.

Ltac image_6 A B P' H P:=
 let T:= fresh in assert (T:= l10_6_existence A B P' H);
 ex_and T P.

Ltac image A B P P':=
 let T:= fresh in assert (T:= l10_2_existence A B P);
 ex_and T P'.

Ltac perp A B C X :=
 match goal with
   | H:(~Col A B C) |- _ =>
    let T:= fresh in assert (T:= l8_18_existence A B C H);
    ex_and T X
 end.

Ltac parallel A B C D P :=
 match goal with
   | H:(A <> B) |- _ =>
    let T := fresh in assert(T:= parallel_existence A B P H);
    ex_and T C
 end.

Ltac par_strict :=
repeat
 match goal with
      | H: Par_strict ?A ?B ?C ?D |- _ =>
       let T := fresh in not_exist_hyp (Par_strict B A D C); assert (T := par_strict_comm A B C D H)  
      | H: Par_strict ?A ?B ?C ?D |- _ =>
       let T := fresh in not_exist_hyp (Par_strict C D A B); assert (T := par_strict_symmetry A B C D H)  
      | H: Par_strict ?A ?B ?C ?D |- _ =>
       let T := fresh in not_exist_hyp (Par_strict B A C D); assert (T := par_strict_left_comm A B C D H)   
      | H: Par_strict ?A ?B ?C ?D |- _ =>
       let T := fresh in not_exist_hyp (Par_strict A B D C); assert (T := par_strict_right_comm A B C D H) 
 end.

Ltac clean_trivial_hyps :=
  repeat
  match goal with
   | H:(Cong ?X1 ?X1 ?X2 ?X2) |- _ => clear H
   | H:(Cong ?X1 ?X2 ?X2 ?X1) |- _ => clear H
   | H:(Cong ?X1 ?X2 ?X1 ?X2) |- _ => clear H
   | H:(Bet ?X1 ?X1 ?X2) |- _ => clear H
   | H:(Bet ?X2 ?X1 ?X1) |- _ => clear H
   | H:(Col ?X1 ?X1 ?X2) |- _ => clear H
   | H:(Col ?X2 ?X1 ?X1) |- _ => clear H
   | H:(Col ?X1 ?X2 ?X1) |- _ => clear H
   | H:(Par ?X1 ?X2 ?X1 ?X2) |- _ => clear H
   | H:(Par ?X1 ?X2 ?X2 ?X1) |- _ => clear H
   | H:(Per ?X1 ?X2 ?X2)     |- _ => clear H
   | H:(Per ?X1 ?X1 ?X2)     |- _ => clear H
   | H:(Midpoint ?X1 ?X1 ?X1) |- _ => clear H
end.

Ltac show_distinct2 := unfold not;intro;treat_equalities; try (solve [intuition]).

Ltac symmetric A B A' :=
 let T := fresh in assert(T:= symmetric_point_construction A B);
 ex_and T A'.

Tactic Notation "Name" ident(X) "the" "symmetric" "of" ident(A) "wrt" ident(C) :=
 symmetric A C X.

Ltac sfinish := repeat match goal with
 | |- Bet ?A ?B ?C => Between; eBetween
 | |- Col ?A ?B ?C => Col;ColR
 | |- ~ Col ?A ?B ?C => Col
 | |- ~ Col ?A ?B ?C => intro;search_contradiction
 | |- Par ?A ?B ?C ?D => Par
 | |- Par_strict ?A ?B ?C ?D => Par
 | |- Perp ?A ?B ?C ?D => Perp
 | |- Perp_at ?A ?B ?C ?D ?E => Perp
 | |- Per ?A ?B ?C => Perp
 | |- Cong ?A ?B ?C ?D => Cong;eCong
 | |- Midpoint ?A ?B ?C => Midpoint
 | |- ?A<>?B => apply swap_diff;assumption
 | |- ?A<>?B => intro;treat_equalities; solve [search_contradiction]
 | |- ?G1 /\ ?G2 => split
 | |- _ => try assumption
end.

Ltac clean_reap_hyps :=
  clean_duplicated_hyps;
  repeat
  match goal with
   | H:(Parallelogram ?A ?B ?C ?D), H2 : Parallelogram ?B ?C ?D ?A |- _ => clear H2
   | H:(Parallelogram ?A ?B ?C ?D), H2 : Parallelogram ?C ?D ?A ?B |- _ => clear H2
   | H:(Parallelogram ?A ?B ?C ?D), H2 : Parallelogram ?D ?A ?B ?C |- _ => clear H2
   | H:(Parallelogram ?A ?B ?C ?D), H2 : Parallelogram ?D ?C ?B ?A |- _ => clear H2
   | H:(Parallelogram ?A ?B ?C ?D), H2 : Parallelogram ?C ?B ?A ?D |- _ => clear H2
   | H:(Parallelogram ?A ?B ?C ?D), H2 : Parallelogram ?B ?A ?D ?C |- _ => clear H2
   | H:(Parallelogram ?A ?B ?C ?D), H2 : Parallelogram ?A ?D ?C ?B |- _ => clear H2
   | H:(Par ?A ?B ?C ?D), H2 : Par ?A ?B ?D ?C |- _ => clear H2
   | H:(Par ?A ?B ?C ?D), H2 : Par ?C ?D ?A ?B |- _ => clear H2
   | H:(Par ?A ?B ?C ?D), H2 : Par ?C ?D ?B ?A |- _ => clear H2
   | H:(Par ?A ?B ?C ?D), H2 : Par ?D ?C ?B ?A |- _ => clear H2
   | H:(Par ?A ?B ?C ?D), H2 : Par ?D ?C ?A ?B |- _ => clear H2
   | H:(Par ?A ?B ?C ?D), H2 : Par ?B ?A ?C ?D |- _ => clear H2
   | H:(Par ?A ?B ?C ?D), H2 : Par ?B ?A ?D ?C |- _ => clear H2
   | H:(Par_strict ?A ?B ?C ?D), H2 : Par_strict ?A ?B ?D ?C |- _ => clear H2
   | H:(Par_strict ?A ?B ?C ?D), H2 : Par_strict ?C ?D ?A ?B |- _ => clear H2
   | H:(Par_strict ?A ?B ?C ?D), H2 : Par_strict ?C ?D ?B ?A |- _ => clear H2
   | H:(Par_strict ?A ?B ?C ?D), H2 : Par_strict ?D ?C ?B ?A |- _ => clear H2
   | H:(Par_strict ?A ?B ?C ?D), H2 : Par_strict ?D ?C ?A ?B |- _ => clear H2
   | H:(Par_strict ?A ?B ?C ?D), H2 : Par_strict ?B ?A ?C ?D |- _ => clear H2
   | H:(Par_strict ?A ?B ?C ?D), H2 : Par_strict ?B ?A ?D ?C |- _ => clear H2
   | H:(Perp ?A ?B ?C ?D), H2 : Perp ?A ?B ?D ?C |- _ => clear H2
   | H:(Perp ?A ?B ?C ?D), H2 : Perp ?C ?D ?A ?B |- _ => clear H2
   | H:(Perp ?A ?B ?C ?D), H2 : Perp ?C ?D ?B ?A |- _ => clear H2
   | H:(Perp ?A ?B ?C ?D), H2 : Perp ?D ?C ?B ?A |- _ => clear H2
   | H:(Perp ?A ?B ?C ?D), H2 : Perp ?D ?C ?A ?B |- _ => clear H2
   | H:(Perp ?A ?B ?C ?D), H2 : Perp ?B ?A ?C ?D |- _ => clear H2
   | H:(Perp ?A ?B ?C ?D), H2 : Perp ?B ?A ?D ?C |- _ => clear H2
   | H:(Perp_at ?X ?A ?B ?C ?D), H2 : Perp_at ?X ?A ?B ?D ?C |- _ => clear H2
   | H:(Perp_at ?X ?A ?B ?C ?D), H2 : Perp_at ?X ?C ?D ?A ?B |- _ => clear H2
   | H:(Perp_at ?X ?A ?B ?C ?D), H2 : Perp_at ?X ?C ?D ?B ?A |- _ => clear H2
   | H:(Perp_at ?X ?A ?B ?C ?D), H2 : Perp_at ?X ?D ?C ?B ?A |- _ => clear H2
   | H:(Perp_at ?X ?A ?B ?C ?D), H2 : Perp_at ?X ?D ?C ?A ?B |- _ => clear H2
   | H:(Perp_at ?X ?A ?B ?C ?D), H2 : Perp_at ?X ?B ?A ?C ?D |- _ => clear H2
   | H:(Perp_at ?X ?A ?B ?C ?D), H2 : Perp_at ?X ?B ?A ?D ?C |- _ => clear H2
   | H:(Per ?A ?B ?C), H2 : Per ?C ?B ?A |- _ => clear H2
   | H:(Midpoint ?A ?B ?C), H2 : Midpoint ?A ?C ?B |- _ => clear H2
   | H:(~Col ?A ?B ?C), H2 : (~Col ?B ?A ?C) |- _ => clear H2
   | H:(~Col ?A ?B ?C), H2 : (~Col ?B ?C ?A) |- _ => clear H2
   | H:(~Col ?A ?B ?C), H2 : (~Col ?C ?B ?A) |- _ => clear H2
   | H:(~Col ?A ?B ?C), H2 : (~Col ?C ?A ?B) |- _ => clear H2
   | H:(~Col ?A ?B ?C), H2 : (~Col ?A ?C ?B) |- _ => clear H2
   | H:(Col ?A ?B ?C), H2 : Col ?A ?C ?B |- _ => clear H2
   | H:(Col ?A ?B ?C), H2 : Col ?B ?A ?C |- _ => clear H2
   | H:(Col ?A ?B ?C), H2 : Col ?B ?C ?A |- _ => clear H2
   | H:(Col ?A ?B ?C), H2 : Col ?C ?B ?A |- _ => clear H2
   | H:(Col ?A ?B ?C), H2 : Col ?C ?A ?B |- _ => clear H2
   | H:(Bet ?A ?B ?C), H2 : Bet ?C ?B ?A |- _ => clear H2
   | H:(Cong ?A ?B ?C ?D), H2 : Cong ?A ?B ?D ?C |- _ => clear H2
   | H:(Cong ?A ?B ?C ?D), H2 : Cong ?C ?D ?A ?B |- _ => clear H2
   | H:(Cong ?A ?B ?C ?D), H2 : Cong ?C ?D ?B ?A |- _ => clear H2
   | H:(Cong ?A ?B ?C ?D), H2 : Cong ?D ?C ?B ?A |- _ => clear H2
   | H:(Cong ?A ?B ?C ?D), H2 : Cong ?D ?C ?A ?B |- _ => clear H2
   | H:(Cong ?A ?B ?C ?D), H2 : Cong ?B ?A ?C ?D |- _ => clear H2
   | H:(Cong ?A ?B ?C ?D), H2 : Cong ?B ?A ?D ?C |- _ => clear H2
   | H:(?A<>?B), H2 : (?B<>?A) |- _ => clear H2
end.

Ltac tag_hyps :=
  repeat
  match goal with
    | H : ?A <> ?B |- _ => apply Diff_Diff_tagged in H
    | H : Cong ?A ?B ?C ?D |- _ => apply Cong_Cong_tagged in H
    | H : Bet ?A ?B ?C |- _ => apply Bet_Bet_tagged in H
    | H : Col ?A ?B ?C |- _ => apply Col_Col_tagged in H
    | H : ~ Col ?A ?B ?C |- _ => apply NCol_NCol_tagged in H
    | H : Midpoint ?A ?B ?C |- _ => apply Mid_Mid_tagged in H
    | H : Per ?A ?B ?C |- _ => apply Per_Per_tagged in H
    | H : Perp_at ?X ?A ?B ?C ?D |- _ => apply Perp_in_Perp_in_tagged in H
    | H : Perp ?A ?B ?C ?D |- _ => apply Perp_Perp_tagged in H
    | H : Par_strict ?A ?B ?C ?D |- _ => apply Par_strict_Par_strict_tagged in H
    | H : Par ?A ?B ?C ?D |- _ => apply Par_Par_tagged in H
    | H : Parallelogram ?A ?B ?C ?D |- _ => apply Plg_Plg_tagged in H
  end.

Ltac permutation_intro_in_goal :=
 match goal with
 | |- Par ?A ?B ?C ?D => apply Par_cases
 | |- Par_strict ?A ?B ?C ?D => apply Par_strict_cases
 | |- Perp ?A ?B ?C ?D => apply Perp_cases
 | |- Perp_at ?X ?A ?B ?C ?D => apply Perp_in_cases
 | |- Per ?A ?B ?C => apply Per_cases
 | |- Midpoint ?A ?B ?C => apply Mid_cases
 | |- ~ Col ?A ?B ?C => apply NCol_cases
 | |- Col ?A ?B ?C => apply Col_cases
 | |- Bet ?A ?B ?C => apply Bet_cases
 | |- Cong ?A ?B ?C ?D => apply Cong_cases
 end.

Ltac perm_apply t :=
 permutation_intro_in_goal;
 try_or ltac:(apply t;solve [finish]).

Ltac assert_ncols :=
repeat
  match goal with
      | H:OS ?A ?B ?X ?Y |- _ =>
     not_exist_hyp_perm_ncol A B X;assert (~ Col A B X) by (apply(one_side_not_col123 A B X Y);finish)

      | H:OS ?A ?B ?X ?Y |- _ =>
     not_exist_hyp_perm_ncol A B Y;assert (~ Col A B Y) by (apply(one_side_not_col124 A B X Y);finish)

      | H:TS ?A ?B ?X ?Y |- _ =>
     not_exist_hyp_perm_ncol A B X;assert (~ Col A B X) by (apply(two_sides_not_col A B X Y);finish)

      | H:TS ?A ?B ?X ?Y |- _ =>
     not_exist_hyp_perm_ncol A B Y;assert (~ Col A B Y) by (apply(two_sides_not_col A B Y X);finish)

      | H:~ Coplanar ?A ?B ?C ?D |- _ =>
      let h := fresh in
      not_exist_hyp_perm4 A B C D;
      assert (h := ncop__ncols A B C D H);decompose [and] h;clear h;clean_reap_hyps

      | H:Par_strict ?A ?B ?C ?D |- _ =>
      let h := fresh in
      not_exist_hyp_perm4 A B C D;
      assert (h := par_strict_not_cols A B C D H);decompose [and] h;clear h;clean_reap_hyps

      | H:Parallelogram_strict ?A ?B ?C ?D |- _ =>
      let h := fresh in
      not_exist_hyp_perm4 A B C D;
      assert (h := plgs_not_col A B C D H);decompose [and] h;clear h;clean_reap_hyps
  end.

Section Quadrilateral_inter_dec_1.

Context `{TE:Tarski_euclidean}.

Lemma par_cong_mid_ts :
 forall A B A' B',
  Par_strict A B A' B' ->
  Cong A B A' B' ->
  TS A A' B B' ->
  exists M,  Midpoint M A A' /\ Midpoint M B B'.

Lemma par_cong_mid_os :
  forall A B A' B',
   Par_strict A B A' B' ->
   Cong A B A' B' ->
   OS A A' B B' ->
   exists M, Midpoint M A B' /\ Midpoint M B A'.

Lemma par_strict_cong_mid :
 forall A B A' B',
  Par_strict A B A' B' ->
  Cong A B A' B' ->
  exists M,  Midpoint M A A' /\ Midpoint M B B' \/
             Midpoint M A B' /\ Midpoint M B A'.

Lemma par_strict_cong_mid1 :
 forall A B A' B',
  Par_strict A B A' B' ->
  Cong A B A' B' ->
  (TS A A' B B'  /\ exists M,  Midpoint M A A' /\ Midpoint M B B') \/ 
  (OS A A' B B' /\ exists M, Midpoint M A B' /\ Midpoint M B A').

Lemma par_cong_mid :
 forall A B A' B',
  Par A B A' B' ->
  Cong A B A' B' ->
  exists M,  Midpoint M A A' /\ Midpoint M B B' \/
             Midpoint M A B' /\ Midpoint M B A'.

Lemma ts_cong_par_cong_par :
 forall A B A' B',
 TS A A' B B' ->
 Cong A B A' B' ->
 Par A B A' B' ->
 Cong A B' A' B /\ Par A B' A' B.

Lemma plgs_cong :
 forall A B C D,
 Parallelogram_strict A B C D ->
 Cong A B C D /\ Cong A D B C.

Lemma plg_cong :
 forall A B C D,
  Parallelogram A B C D ->
 Cong A B C D /\ Cong A D B C.

Lemma rmb_cong :
 forall A B C D,
  Rhombus A B C D ->
  Cong A B B C /\ Cong A B C D /\ Cong A B D A.

Lemma rmb_per:
 forall A B C D M,
  Midpoint M A C ->
  Rhombus A B C D ->
  Per A M D.

Lemma per_rmb :
 forall A B C D M,
  Plg A B C D ->
  Midpoint M A C ->
  Per A M B ->
  Rhombus A B C D.

Lemma perp_rmb :
 forall A B C D,
  Plg A B C D ->
  Perp A C B D ->
  Rhombus A B C D.

Lemma plg_conga1 : forall A B C D, A <> B -> A <> C -> Plg A B C D -> CongA B A C D C A.

Lemma os_cong_par_cong_par :
 forall A B A' B',
  OS A A' B B' ->
  Cong A B A' B' ->
  Par A B A' B' ->
 Cong A A' B B' /\ Par A A' B B'.

Lemma plgs_permut :
 forall A B C D,
  Parallelogram_strict A B C D ->
  Parallelogram_strict B C D A.

Lemma plg_permut :
 forall A B C D,
  Parallelogram A B C D ->
  Parallelogram B C D A.

Lemma plgs_mid :
 forall A B C D,
  Parallelogram_strict A B C D ->
  exists M, Midpoint M A C /\ Midpoint M B D.

Lemma plg_mid :
 forall A B C D,
  Parallelogram A B C D ->
  exists M, Midpoint M A C /\ Midpoint M B D.

Lemma plg_mid_2 :
 forall A B C D I,
  Parallelogram A B C D ->
  Midpoint I A C ->
  Midpoint I B D.

Lemma plgs_not_comm :
  forall A B C D,
   Parallelogram_strict A B C D ->
 ~ Parallelogram_strict A B D C /\ ~ Parallelogram_strict B A C D.

Lemma plg_not_comm :
 forall A B C D,
 A <> B ->
 Parallelogram A B C D ->
 ~ Parallelogram A B D C /\ ~ Parallelogram B A C D.

Lemma parallelogram_to_plg : forall A B C D, Parallelogram A B C D -> Plg A B C D.

Lemma parallelogram_equiv_plg : forall A B C D, Parallelogram A B C D <-> Plg A B C D.

Lemma plg_conga : forall A B C D, A <> B /\ A <> C /\ B <> C -> Parallelogram A B C D -> CongA A B C C D A /\ CongA B C D D A B.

Lemma half_plgs :
 forall A B C D P Q M,
  Parallelogram_strict A B C D ->
  Midpoint P A B ->
  Midpoint Q C D ->
  Midpoint M A C ->
  Par P Q A D /\ Midpoint M P Q /\ Cong A D P Q.

Lemma plgs_two_sides :
 forall A B C D,
 Parallelogram_strict A B C D ->
 TS A C B D /\ TS B D A C.

Lemma plgs_par_strict :
 forall A B C D,
  Parallelogram_strict A B C D ->
  Par_strict A B C D /\ Par_strict A D B C.

Lemma plgs_half_plgs_aux :
 forall A B C D P Q,
  Parallelogram_strict A B C D ->
  Midpoint P A B ->
  Midpoint Q C D ->
  Parallelogram_strict A P Q D.

Lemma plgs_comm2 :
 forall A B C D,
  Parallelogram_strict A B C D ->
  Parallelogram_strict B A D C.

Lemma plgf_comm2 :
 forall A B C D,
  Parallelogram_flat A B C D ->
  Parallelogram_flat B A D C.

Lemma plg_comm2 :
 forall A B C D,
  Parallelogram A B C D ->
  Parallelogram B A D C.

Lemma par_preserves_conga_os :
 forall A B C D P , Par A B C D -> Bet A D P -> D <> P -> OS A D B C -> CongA B A P C D P.

Lemma cong3_par2_par :
 forall A B C A' B' C', A <> C -> Cong_3 B A C B' A' C' -> Par B A B' A' -> Par B C B' C' ->
 Par A C A' C' \/ ~ Par_strict B B' A A' \/ ~Par_strict B B' C C'.

Lemma square_perp_rectangle : forall A B C D,
 Rectangle A B C D ->
 Perp A C B D ->
 Square A B C D.

Lemma plgs_half_plgs :
 forall A B C D P Q,
  Parallelogram_strict A B C D ->
  Midpoint P A B -> Midpoint Q C D ->
  Parallelogram_strict A P Q D /\ Parallelogram_strict B P Q C.

Lemma parallel_2_plg :
  forall A B C D,
  ~ Col A B C ->
  Par A B C D ->
  Par A D B C ->
  Parallelogram_strict A B C D.

Lemma par_2_plg :
  forall A B C D,
  ~ Col A B C ->
  Par A B C D ->
  Par A D B C ->
  Parallelogram A B C D.

Lemma plg_cong_1 : forall A B C D, Parallelogram A B C D -> Cong A B C D.

Lemma plg_cong_2 : forall A B C D, Parallelogram A B C D -> Cong A D B C.

Lemma plgs_cong_1 : forall A B C D, Parallelogram_strict A B C D -> Cong A B C D.

Lemma plgs_cong_2 : forall A B C D, Parallelogram_strict A B C D -> Cong A D B C.

Lemma Plg_perm :
  forall A B C D,
  Parallelogram A B C D ->
  Parallelogram A B C D /\ Parallelogram B C D A /\ Parallelogram C D A B /\Parallelogram D A B C /\ 
  Parallelogram A D C B /\ Parallelogram D C B A /\ Parallelogram C B A D /\ Parallelogram B A D C.

Lemma plg_not_comm_1 :
  forall A B C D : Tpoint,
  A <> B ->
  Parallelogram A B C D -> ~ Parallelogram A B D C.

Lemma plg_not_comm_2 :
  forall A B C D : Tpoint,
  A <> B ->
  Parallelogram A B C D -> ~ Parallelogram B A C D.

End Quadrilateral_inter_dec_1.

Ltac assert_cols :=
repeat
 match goal with
      | H:Bet ?X1 ?X2 ?X3 |- _ =>
     not_exist_hyp_perm_col X1 X2 X3;assert (Col X1 X2 X3) by (apply bet_col;apply H)

      | H:Midpoint ?X1 ?X2 ?X3 |- _ =>
     not_exist_hyp_perm_col X1 X2 X3;let N := fresh in assert (N := midpoint_col X2 X1 X3 H)

      | H:Out ?X1 ?X2 ?X3 |- _ =>
     not_exist_hyp_perm_col X1 X2 X3;let N := fresh in assert (N := out_col X1 X2 X3 H)

      | H:Par ?X1 ?X2 ?X1 ?X3 |- _ =>
     not_exist_hyp_perm_col X1 X2 X3;let N := fresh in assert (N := par_id X1 X2 X3 H)
      | H:Par ?X1 ?X2 ?X3 ?X1 |- _ =>
     not_exist_hyp_perm_col X1 X2 X3;let N := fresh in
     assert (N := par_id X1 X2 X3 (par_right_comm X1 X2 X3 X1 H))
      | H:Par ?X2 ?X1 ?X1 ?X3 |- _ =>
     not_exist_hyp_perm_col X1 X2 X3;let N := fresh in
     assert (N := par_id X1 X2 X3 (par_left_comm X2 X1 X1 X3 H))
      | H:Par ?X2 ?X1 ?X3 ?X1 |- _ =>
     not_exist_hyp_perm_col X1 X2 X3;let N := fresh in
     assert (N := par_id X1 X2 X3 (par_comm X2 X1 X3 X1 H))
 end.

Ltac permutation_intro_in_hyps_aux :=
 repeat
 match goal with
 | H : Plg_tagged ?A ?B ?C ?D |- _ => apply Plg_tagged_Plg in H; apply Plg_perm in H; spliter
 | H : Par_tagged ?A ?B ?C ?D |- _ => apply Par_tagged_Par in H; apply Par_perm in H; spliter
 | H : Par_strict_tagged ?A ?B ?C ?D |- _ => apply Par_strict_tagged_Par_strict in H; apply Par_strict_perm in H; spliter
 | H : Perp_tagged ?A ?B ?C ?D |- _ => apply Perp_tagged_Perp in H; apply Perp_perm in H; spliter
 | H : Perp_in_tagged ?X ?A ?B ?C ?D |- _ => apply Perp_in_tagged_Perp_in in H; apply Perp_in_perm in H; spliter
 | H : Per_tagged ?A ?B ?C |- _ => apply Per_tagged_Per in H; apply Per_perm in H; spliter
 | H : Mid_tagged ?A ?B ?C |- _ => apply Mid_tagged_Mid in H; apply Mid_perm in H; spliter
 | H : NCol_tagged ?A ?B ?C |- _ => apply NCol_tagged_NCol in H; apply NCol_perm in H; spliter
 | H : Col_tagged ?A ?B ?C |- _ => apply Col_tagged_Col in H; apply Col_perm in H; spliter
 | H : Bet_tagged ?A ?B ?C |- _ => apply Bet_tagged_Bet in H; apply Bet_perm in H; spliter
 | H : Cong_tagged ?A ?B ?C ?D |- _ => apply Cong_tagged_Cong in H; apply Cong_perm in H; spliter
 | H : Diff_tagged ?A ?B |- _ => apply Diff_tagged_Diff in H; apply Diff_perm in H; spliter
 end.

Ltac permutation_intro_in_hyps := clean_reap_hyps; clean_trivial_hyps; tag_hyps; permutation_intro_in_hyps_aux.

Ltac assert_cols_aux :=
repeat
 match goal with
      | H:Bet ?X1 ?X2 ?X3 |- _ =>
     not_exist_hyp (Col X1 X2 X3);assert (Col X1 X2 X3) by (apply bet_col;apply H) 

      | H:Midpoint ?X1 ?X2 ?X3 |- _ =>
     not_exist_hyp (Col X1 X2 X3);let N := fresh in assert (N := midpoint_col X2 X1 X3 H)

      | H:Out ?X1 ?X2 ?X3 |- _ =>
     not_exist_hyp (Col X1 X2 X3);let N := fresh in assert (N := out_col X1 X2 X3 H)

      | H:Par ?X1 ?X2 ?X1 ?X3 |- _ =>
     not_exist_hyp (Col X1 X2 X3);let N := fresh in assert (N := par_id X1 X2 X3 H)
      | H:Par ?X1 ?X2 ?X1 ?X3 |- _ =>
     not_exist_hyp (Col X1 X2 X3);let N := fresh in assert (N := par_id_1 X1 X2 X3 H)
      | H:Par ?X1 ?X2 ?X1 ?X3 |- _ =>
     not_exist_hyp (Col X1 X2 X3);let N := fresh in assert (N := par_id_2 X1 X2 X3 H)
      | H:Par ?X1 ?X2 ?X1 ?X3 |- _ =>
     not_exist_hyp (Col X1 X2 X3);let N := fresh in assert (N := par_id_3 X1 X2 X3 H)
      | H:Par ?X1 ?X2 ?X1 ?X3 |- _ =>
     not_exist_hyp (Col X1 X2 X3);let N := fresh in assert (N := par_id_4 X1 X2 X3 H)
      | H:Par ?X1 ?X2 ?X1 ?X3 |- _ =>
     not_exist_hyp (Col X1 X2 X3);let N := fresh in assert (N := par_id_5 X1 X2 X3 H)

      | H:Par ?X1 ?X2 ?X3 ?X4, H2:Col ?X1 ?X2 ?X5, H3:Col ?X3 ?X4 ?X5 |- _ =>
     not_exist_hyp (Col X1 X2 X3);let N := fresh in assert (N := not_strict_par1 X1 X2 X3 X4 X5 H H2 H3)
 end.

Ltac assert_cols_perm := permutation_intro_in_hyps; assert_cols_aux; clean_reap_hyps.

Ltac not_exist_hyp_perm_cong A B C D := not_exist_hyp (Cong A B C D); not_exist_hyp (Cong A B D C);
                                        not_exist_hyp (Cong B A C D); not_exist_hyp (Cong B A D C);
                                        not_exist_hyp (Cong C D A B); not_exist_hyp (Cong C D B A);
                                        not_exist_hyp (Cong D C A B); not_exist_hyp (Cong D C B A).

Ltac assert_congs_1 :=
repeat
 match goal with
      | H:Midpoint ?X1 ?X2 ?X3 |- _ =>
      let h := fresh in
      not_exist_hyp_perm_cong X1 X2 X1 X3;
      assert (h := midpoint_cong X2 X1 X3 H)

      | H1:Midpoint ?M1 ?A1 ?B1, H2:Midpoint ?M2 ?A2 ?B2, H3:Cong ?A1 ?B1 ?A2 ?B2 |- _ => 
      let h := fresh in
      not_exist_hyp_perm_cong A1 M1 A2 M2;
      assert (h := cong_cong_half_1 A1 M1 B1 A2 M2 B2 H1 H2 H3)

      | H:Parallelogram ?X1 ?X2 ?X3 ?X4 |- _ =>
      let h := fresh in
      not_exist_hyp_perm_cong X1 X2 X3 X4;
      assert (h := plg_cong_1 X1 X2 X3 X4 H)

      | H:Parallelogram_strict ?X1 ?X2 ?X3 ?X4 |- _ =>
      let h := fresh in
      not_exist_hyp_perm_cong X1 X2 X3 X4;
      assert (h := plgs_cong_1 X1 X2 X3 X4 H)
  end.

Ltac assert_congs_2 :=
repeat
 match goal with
      | H1:Midpoint ?M1 ?A1 ?B1, H2:Midpoint ?M2 ?A2 ?B2, H3:Cong ?A1 ?B1 ?A2 ?B2 |- _ => 
      let h := fresh in
      not_exist_hyp_perm_cong A1 M1 A2 M2;
      assert (h := cong_cong_half_2 A1 M1 B1 A2 M2 B2 H1 H2 H3)

      | H:Parallelogram ?X1 ?X2 ?X3 ?X4 |- _ =>
      let h := fresh in
      not_exist_hyp_perm_cong X1 X4 X2 X3;
      assert (h := plg_cong_2 X1 X2 X3 X4 H);clean_reap_hyps

      | H:Parallelogram_strict ?X1 ?X2 ?X3 ?X4 |- _ =>
      let h := fresh in
      not_exist_hyp_perm_cong X1 X4 X2 X3;
      assert (h := plgs_cong_2 X1 X2 X3 X4 H);clean_reap_hyps
  end.

Ltac assert_congs_perm := permutation_intro_in_hyps; assert_congs_1; assert_congs_2; clean_reap_hyps.

Ltac not_exist_hyp_perm_para A B C D := not_exist_hyp (Parallelogram A B C D); not_exist_hyp (Parallelogram B C D A);
                                        not_exist_hyp (Parallelogram C D A B); not_exist_hyp (Parallelogram D A B C);
                                        not_exist_hyp (Parallelogram A D C B); not_exist_hyp (Parallelogram D C B A);
                                        not_exist_hyp (Parallelogram C B A D); not_exist_hyp (Parallelogram B A D C).

Ltac not_exist_hyp_perm_para_s A B C D := not_exist_hyp (Parallelogram_strict A B C D);
                                          not_exist_hyp (Parallelogram_strict B C D A);
                                          not_exist_hyp (Parallelogram_strict C D A B);
                                          not_exist_hyp (Parallelogram_strict D A B C);
                                          not_exist_hyp (Parallelogram_strict A D C B);
                                          not_exist_hyp (Parallelogram_strict D C B A);
                                          not_exist_hyp (Parallelogram_strict C B A D);
                                          not_exist_hyp (Parallelogram_strict B A D C).

Ltac assert_paras_aux :=
repeat
 match goal with
      | H:Parallelogram_strict ?X1 ?X2 ?X3 ?X4 |- _ =>
      let h := fresh in
      not_exist_hyp_perm_para X1 X2 X3 X4;
      assert (h := Parallelogram_strict_Parallelogram X1 X2 X3 X4 H)

      | H:Plg ?X1 ?X2 ?X3 ?X4 |- _ =>
      let h := fresh in
      not_exist_hyp_perm_para X1 X2 X3 X4;
      assert (h := plg_to_parallelogram X1 X2 X3 X4 H)

      | H:(~ Col ?X1 ?X2 ?X3), H2:Par ?X1 ?X2 ?X3 ?X4, H3:Par ?X1 ?X4 ?X2 ?X3 |- _ =>
      let h := fresh in
      not_exist_hyp_perm_para_s X1 X2 X3 X4;
      assert (h := parallel_2_plg X1 X2 X3 X4 H H2 H3)
  end.

Ltac assert_paras_perm := permutation_intro_in_hyps; assert_paras_aux; clean_reap_hyps.

Ltac not_exist_hyp_perm_npara A B C D := not_exist_hyp (~Parallelogram A B C D); not_exist_hyp (~Parallelogram B C D A);
                                         not_exist_hyp (~Parallelogram C D A B); not_exist_hyp (~Parallelogram D A B C);
                                         not_exist_hyp (~Parallelogram A D C B); not_exist_hyp (~Parallelogram D C B A);
                                         not_exist_hyp (~Parallelogram C B A D); not_exist_hyp (~Parallelogram B A D C).

Ltac assert_nparas_1 :=
 repeat
 match goal with
      | H:(?X1<>?X2), H2:Parallelogram ?X1 ?X2 ?X3 ?X4 |- _ =>
      let h := fresh in
      not_exist_hyp_perm_npara X1 X2 X4 X3;
      assert (h := plg_not_comm_1 X1 X2 X3 X4 H H2)
  end.

Ltac assert_nparas_2 :=
 repeat
 match goal with
      | H:(?X1<>?X2), H2:Parallelogram ?X1 ?X2 ?X3 ?X4 |- _ =>
      let h := fresh in
      not_exist_hyp_perm_npara X2 X1 X3 X4;
      assert (h := plg_not_comm_2 X1 X2 X3 X4 H H2)
  end.

Ltac assert_nparas_perm := permutation_intro_in_hyps; assert_nparas_1; assert_nparas_2; clean_reap_hyps.

Ltac diag_plg_intersection M A B C D H :=
 let T := fresh in assert(T:= plg_mid A B C D H);
 ex_and T M.

Tactic Notation "Name" ident(M) "the" "intersection" "of" "the" "diagonals" "(" ident(A) ident(C) ")" "and" "(" ident(B) ident(D) ")" "of" "the" "parallelogram" ident(H) :=
 diag_plg_intersection M A B C D H.

Ltac assert_diffs :=
repeat
 match goal with
      | H:(~Col ?X1 ?X2 ?X3) |- _ =>
      let h := fresh in
      not_exist_hyp3 X1 X2 X1 X3 X2 X3;
      assert (h := not_col_distincts X1 X2 X3 H);decompose [and] h;clear h;clean_reap_hyps 

      | H:(~Bet ?X1 ?X2 ?X3) |- _ =>
      let h := fresh in
      not_exist_hyp2 X1 X2 X2 X3;
      assert (h := not_bet_distincts X1 X2 X3 H);decompose [and] h;clear h;clean_reap_hyps
      | H:Bet ?A ?B ?C, H2 : ?A <> ?B |-_ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= bet_neq12__neq A B C H H2);clean_reap_hyps
      | H:Bet ?A ?B ?C, H2 : ?B <> ?A |-_ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= bet_neq21__neq A B C H H2);clean_reap_hyps
      | H:Bet ?A ?B ?C, H2 : ?B <> ?C |-_ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= bet_neq23__neq A B C H H2);clean_reap_hyps
      | H:Bet ?A ?B ?C, H2 : ?C <> ?B |-_ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= bet_neq32__neq A B C H H2);clean_reap_hyps

      | H:Cong ?A ?B ?C ?D, H2 : ?A <> ?B |-_ =>
      let T:= fresh in (not_exist_hyp_comm C D);
        assert (T:= cong_diff A B C D H2 H);clean_reap_hyps
      | H:Cong ?A ?B ?C ?D, H2 : ?B <> ?A |-_ =>
      let T:= fresh in (not_exist_hyp_comm C D);
        assert (T:= cong_diff_2 A B C D H2 H);clean_reap_hyps
      | H:Cong ?A ?B ?C ?D, H2 : ?C <> ?D |-_ =>
      let T:= fresh in (not_exist_hyp_comm A B);
        assert (T:= cong_diff_3 A B C D H2 H);clean_reap_hyps
      | H:Cong ?A ?B ?C ?D, H2 : ?D <> ?C |-_ =>
      let T:= fresh in (not_exist_hyp_comm A B);
        assert (T:= cong_diff_4 A B C D H2 H);clean_reap_hyps

      | H:Le ?A ?B ?C ?D, H2 : ?A <> ?B |-_ =>
      let T:= fresh in (not_exist_hyp_comm C D);
        assert (T:= le_diff A B C D H2 H);clean_reap_hyps
      | H:Le ?A ?B ?C ?D, H2 : ?B <> ?A |-_ =>
      let T:= fresh in (not_exist_hyp_comm C D);
        assert (T:= le_diff A B C D (swap_diff B A H2) H);clean_reap_hyps
      | H:Lt ?A ?B ?C ?D |-_ =>
      let T:= fresh in (not_exist_hyp_comm C D);
        assert (T:= lt_diff A B C D H);clean_reap_hyps

      | H:Midpoint ?I ?A ?B, H2 : ?A<>?B |- _ =>
      let T:= fresh in (not_exist_hyp2 I B I A);
       assert (T:= midpoint_distinct_1 I A B H2 H);
       decompose [and] T;clear T;clean_reap_hyps
      | H:Midpoint ?I ?A ?B, H2 : ?B<>?A |- _ =>
      let T:= fresh in (not_exist_hyp2 I B I A);
       assert (T:= midpoint_distinct_1 I A B (swap_diff B A H2) H);
       decompose [and] T;clear T;clean_reap_hyps

      | H:Midpoint ?I ?A ?B, H2 : ?I<>?A |- _ =>
      let T:= fresh in (not_exist_hyp2 I B A B);
       assert (T:= midpoint_distinct_2 I A B H2 H);
       decompose [and] T;clear T;clean_reap_hyps
      | H:Midpoint ?I ?A ?B, H2 : ?A<>?I |- _ =>
      let T:= fresh in (not_exist_hyp2 I B A B);
       assert (T:= midpoint_distinct_2 I A B (swap_diff A I H2) H);
       decompose [and] T;clear T;clean_reap_hyps

      | H:Midpoint ?I ?A ?B, H2 : ?I<>?B |- _ =>
      let T:= fresh in (not_exist_hyp2 I A A B);
       assert (T:= midpoint_distinct_3 I A B H2 H);
       decompose [and] T;clear T;clean_reap_hyps
      | H:Midpoint ?I ?A ?B, H2 : ?B<>?I |- _ =>
      let T:= fresh in (not_exist_hyp2 I A A B);
       assert (T:= midpoint_distinct_3 I A B (swap_diff B I H2) H);
       decompose [and] T;clear T;clean_reap_hyps

      | H:Per ?A ?B ?C, H2 : ?A<>?B |- _ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= per_distinct A B C H H2); clean_reap_hyps
      | H:Per ?A ?B ?C, H2 : ?B<>?A |- _ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= per_distinct A B C H (swap_diff B A H2)); clean_reap_hyps
      | H:Per ?A ?B ?C, H2 : ?B<>?C |- _ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= per_distinct_1 A B C H H2); clean_reap_hyps
      | H:Per ?A ?B ?C, H2 : ?C<>?B |- _ =>
      let T:= fresh in (not_exist_hyp_comm A C);
        assert (T:= per_distinct_1 A B C H (swap_diff C B H2)); clean_reap_hyps

      | H:Perp ?A ?B ?C ?D |- _ =>
      let T:= fresh in (not_exist_hyp2 A B C D);
       assert (T:= perp_distinct A B C D H);
       decompose [and] T;clear T;clean_reap_hyps
      | H:Perp_at ?X ?A ?B ?C ?D |- _ =>
      let T:= fresh in (not_exist_hyp2 A B C D);
       assert (T:= perp_in_distinct X A B C D H);
       decompose [and] T;clear T;clean_reap_hyps
      | H:Out ?A ?B ?C |- _ =>
      let T:= fresh in (not_exist_hyp2 A B A C);
       assert (T:= out_distinct A B C H);
       decompose [and] T;clear T;clean_reap_hyps

      | H:TS ?A ?B ?C ?D |- _ =>
      let h := fresh in
      not_exist_hyp6 A B A C A D B C B D C D;
      assert (h := ts_distincts A B C D H);decompose [and] h;clear h;clean_reap_hyps
      | H:OS ?A ?B ?C ?D |- _ =>
      let h := fresh in
      not_exist_hyp5 A B A C A D B C B D;
      assert (h := os_distincts A B C D H);decompose [and] h;clear h;clean_reap_hyps
      | H:~ Coplanar ?A ?B ?C ?D |- _ =>
      let h := fresh in
      not_exist_hyp6 A B A C A D B C B D C D;
      assert (h := ncop_distincts A B C D H);decompose [and] h;clear h;clean_reap_hyps

      | H:CongA ?A ?B ?C ?A' ?B' ?C' |- _ =>
      let T:= fresh in (not_exist_hyp_comm A B);
        assert (T:= conga_diff1 A B C A' B' C' H);clean_reap_hyps
      | H:CongA ?A ?B ?C ?A' ?B' ?C' |- _ =>
      let T:= fresh in (not_exist_hyp_comm B C);
        assert (T:= conga_diff2 A B C A' B' C' H);clean_reap_hyps
      | H:CongA ?A ?B ?C ?A' ?B' ?C' |- _ =>
      let T:= fresh in (not_exist_hyp_comm A' B');
        assert (T:= conga_diff45 A B C A' B' C' H);clean_reap_hyps
      | H:CongA ?A ?B ?C ?A' ?B' ?C' |- _ =>
      let T:= fresh in (not_exist_hyp_comm B' C');
        assert (T:= conga_diff56 A B C A' B' C' H);clean_reap_hyps

      | H:(InAngle ?P ?A ?B ?C) |- _ =>
      let h := fresh in
      not_exist_hyp3 A B C B P B;
      assert (h := inangle_distincts A B C P H);decompose [and] h;clear h;clean_reap_hyps
      | H:LeA ?A ?B ?C ?D ?E ?F |- _ =>
      let h := fresh in
      not_exist_hyp4 A B B C D E E F;
      assert (h := lea_distincts A B C D E F H);decompose [and] h;clear h;clean_reap_hyps
      | H:LtA ?A ?B ?C ?D ?E ?F |- _ =>
      let h := fresh in
      not_exist_hyp4 A B B C D E E F;
      assert (h := lta_distincts A B C D E F H);decompose [and] h;clear h;clean_reap_hyps
      | H:(Acute ?A ?B ?C) |- _ =>
      let h := fresh in
      not_exist_hyp2 A B B C;
      assert (h := acute_distincts A B C H);decompose [and] h;clear h;clean_reap_hyps
      | H:(Obtuse ?A ?B ?C) |- _ =>
      let h := fresh in
      not_exist_hyp2 A B B C;
      assert (h := obtuse_distincts A B C H);decompose [and] h;clear h;clean_reap_hyps
      | H:SuppA ?A ?B ?C ?D ?E ?F |- _ =>
      let h := fresh in
      not_exist_hyp4 A B B C D E E F;
      assert (h := suppa_distincts A B C D E F H);decompose [and] h;clear h;clean_reap_hyps

      | H:(Orth_at ?X ?A ?B ?C ?U ?V) |- _ =>
      let h := fresh in
      not_exist_hyp4 A B A C B C U V;
      assert (h := orth_at_distincts A B C U V X H);decompose [and] h;clear h;clean_reap_hyps
      | H:(Orth ?A ?B ?C ?U ?V) |- _ =>
      let h := fresh in
      not_exist_hyp4 A B A C B C U V;
      assert (h := orth_distincts A B C U V H);decompose [and] h;clear h;clean_reap_hyps

      | H:Inter ?A ?B ?C ?D ?X |- _ =>
      let T:= fresh in (not_exist_hyp2 A B C D);
       assert (T:= inter_distincts A B C D X H);decompose [and] T;clear T;clean_reap_hyps

      | H:Par_strict ?A ?B ?C ?D |- _ =>
      let T:= fresh in (not_exist_hyp6 A B A C A D B C B D C D);
       assert (T:= par_strict_distinct A B C D H);
       decompose [and] T;clear T;clean_reap_hyps
      | H:Par ?A ?B ?C ?D |- _ =>
      let T:= fresh in (not_exist_hyp2 A B C D);
       assert (T:= par_distincts A B C D H);decompose [and] T;clear T;clean_reap_hyps
      | H:Perp ?A ?B ?C ?D |- _ =>
      let T:= fresh in (not_exist_hyp2 A B C D);
       assert (T:= perp_distinct A B C D H);
       decompose [and] T;clear T;clean_reap_hyps
      | H:Perp_at ?X ?A ?B ?C ?D |- _ =>
      let T:= fresh in (not_exist_hyp2 A B C D);
       assert (T:= perp_in_distinct X A B C D H);
       decompose [and] T;clear T;clean_reap_hyps
      | H:Out ?A ?B ?C |- _ =>
      let T:= fresh in (not_exist_hyp2 A B A C);
       assert (T:= out_distinct A B C H);
       decompose [and] T;clear T;clean_reap_hyps

      | H:SumA ?A ?B ?C ?D ?E ?F ?G ?I ?J |- _ =>
      let h := fresh in
      not_exist_hyp6 A B B C D E E F G I I J;
      assert (h := suma_distincts A B C D E F G I J H);decompose [and] h;clear h;clean_reap_hyps

      | H:TriSumA ?A ?B ?C ?D ?E ?F |- _ =>
      let h := fresh in
      not_exist_hyp5 A B B C A C D E E F;
      assert (h := trisuma_distincts A B C D E F H);decompose [and] h;clear h;clean_reap_hyps

      | H:SAMS ?A ?B ?C ?D ?E ?F |- _ =>
      let h := fresh in
      not_exist_hyp4 A B B C D E E F;
      assert (h := sams_distincts A B C D E F H);decompose [and] h;clear h;clean_reap_hyps

      | H:Parallelogram_strict ?A ?B ?C ?D |- _ =>
      let T := fresh in
      not_exist_hyp6 A B B C C D D A A C B D;
       assert (T:= plgs_diff A B C D H);decompose [and] T;clear T;clean_reap_hyps
 end.

Hint Resolve parallelogram_strict_not_col
             parallelogram_strict_not_col_2
             parallelogram_strict_not_col_3
             parallelogram_strict_not_col_4 : col.

Hint Resolve plg_cong_1 plg_cong_2 plgs_cong_1 plgs_cong_2 : cong.

Section Quadrilateral_inter_dec_2.

Context `{TE:Tarski_euclidean}.

Lemma parallelogram_strict_midpoint : forall A B C D I,
  Parallelogram_strict A B C D ->
  Col I A C ->
  Col I B D ->
  Midpoint I A C /\ Midpoint I B D.

Lemma rmb_perp :
 forall A B C D,
  A <> C -> B <> D ->
  Rhombus A B C D ->
  Perp A C B D.

Lemma rect_permut : forall A B C D, Rectangle A B C D -> Rectangle B C D A.

Lemma rect_comm2 : forall A B C D, Rectangle A B C D -> Rectangle B A D C.

Lemma rect_per1 : forall A B C D, Rectangle A B C D -> Per B A D.

Lemma rect_per2 : forall A B C D, Rectangle A B C D -> Per A B C.

Lemma rect_per3 : forall A B C D, Rectangle A B C D -> Per B C D.

Lemma rect_per4 : forall A B C D, Rectangle A B C D -> Per A D C.

Lemma plg_per_rect1 : forall A B C D, Plg A B C D -> Per D A B -> Rectangle A B C D.

Lemma plg_per_rect2 : forall A B C D, Plg A B C D -> Per C B A -> Rectangle A B C D.

Lemma plg_per_rect3 : forall A B C D, Plg A B C D -> Per A D C -> Rectangle A B C D.

Lemma plg_per_rect4 : forall A B C D, Plg A B C D -> Per B C D -> Rectangle A B C D.

Lemma plg_per_rect : forall A B C D, Plg A B C D -> (Per D A B \/ Per C B A \/ Per A D C \/ Per B C D) -> Rectangle A B C D.

Lemma rect_per : forall A B C D, Rectangle A B C D -> Per B A D /\ Per A B C /\ Per B C D /\ Per A D C.

Lemma plgf_rect_id : forall A B C D, Parallelogram_flat A B C D -> Rectangle A B C D -> A = D /\ B = C \/ A = B /\ D = C.

Lemma cop_perp3__perp :
 forall A B C D,
  Coplanar A B C D ->
  Perp A B B C ->
  Perp B C C D ->
  Perp C D D A ->
  Perp D A A B.

Lemma cop_perp3__rect :
 forall A B C D,
  Coplanar A B C D ->
  Perp A B B C ->
  Perp B C C D ->
  Perp C D D A ->
  Rectangle A B C D.

Lemma conga_to_par_os : forall A B C D P , Bet A D P -> OS A D B C -> CongA B A P C D P
                                           -> Par A B C D.

Lemma plg_par : forall A B C D, A <> B -> B <> C -> Parallelogram A B C D -> Par A B C D /\ Par A D B C.

Lemma plg_par_1 : forall A B C D, A <> B -> B <> C -> Parallelogram A B C D -> Par A B C D.

Lemma plg_par_2 : forall A B C D, A <> B -> B <> C -> Parallelogram A B C D -> Par A D B C.

Lemma plgs_pars_1: forall A B C D : Tpoint, Parallelogram_strict A B C D -> Par_strict A B C D.

Lemma plgs_pars_2: forall A B C D : Tpoint, Parallelogram_strict A B C D -> Par_strict A D B C.

End Quadrilateral_inter_dec_2.

Ltac not_exist_hyp_perm_par A B C D := not_exist_hyp (Par A B C D); not_exist_hyp (Par A B D C);
                                       not_exist_hyp (Par B A C D); not_exist_hyp (Par B A D C);
                                       not_exist_hyp (Par C D A B); not_exist_hyp (Par C D B A);
                                       not_exist_hyp (Par D C A B); not_exist_hyp (Par D C B A).

Ltac not_exist_hyp_perm_pars A B C D := not_exist_hyp (Par_strict A B C D); not_exist_hyp (Par_strict A B D C);
                                        not_exist_hyp (Par_strict B A C D); not_exist_hyp (Par_strict B A D C);
                                        not_exist_hyp (Par_strict C D A B); not_exist_hyp (Par_strict C D B A);
                                        not_exist_hyp (Par_strict D C A B); not_exist_hyp (Par_strict D C B A).

Ltac assert_pars_1 :=
 repeat
 match goal with
      | H:Par_strict ?X1 ?X2 ?X3 ?X4 |- _ =>
      let h := fresh in
      not_exist_hyp_perm_par X1 X2 X3 X4;
      assert (h := par_strict_par X1 X2 X3 X4 H)

      | H:Par ?X1 ?X2 ?X3 ?X4, H2:Col ?X1 ?X2 ?X5, H3:(~Col ?X3 ?X4 ?X5) |- _ =>
      let h := fresh in
      not_exist_hyp_perm_pars X1 X2 X3 X4;
      assert (h := par_not_col_strict X1 X2 X3 X4 X5 H H2 H3)

      | H: ?X1 <> ?X2, H2:?X2 <> ?X3, H3:Parallelogram ?X1 ?X2 ?X3 ?X4 |- _ =>
      let h := fresh in
      not_exist_hyp_perm_par X1 X2 X3 X4;
      assert (h := plg_par_1 X1 X2 X3 X4 H H2 H3)

      | H:Parallelogram_strict ?X1 ?X2 ?X3 ?X4 |- _ =>
      let h := fresh in
      not_exist_hyp_perm_pars X1 X2 X3 X4;
      assert (h := plgs_pars_1 X1 X2 X3 X4 H)
  end.

Ltac assert_pars_2 :=
 repeat
 match goal with
      | H: ?X1 <> ?X2, H2:?X2 <> ?X3, H3:Parallelogram ?X1 ?X2 ?X3 ?X4 |- _ =>
      let h := fresh in
      not_exist_hyp_perm_par X1 X4 X2 X3;
      assert (h := plg_par_2 X1 X2 X3 X4 H H2 H3)

      | H:Parallelogram_strict ?X1 ?X2 ?X3 ?X4 |- _ =>
      let h := fresh in
      not_exist_hyp_perm_pars X1 X4 X2 X3;
      assert (h := plgs_pars_2 X1 X2 X3 X4 H)
  end.

Ltac assert_pars_perm := permutation_intro_in_hyps; assert_pars_1; assert_pars_2; clean_reap_hyps.

Hint Resolve plg_par_1 plg_par_2 plgs_pars_1 plgs_pars_2 : par.

Section Quadrilateral_inter_dec_3.

Context `{TE:Tarski_euclidean}.

Lemma par_cong_cong : forall A B C D, Par A B C D -> Cong A B C D -> Cong A C B D \/ Cong A D B C.

Lemma col_cong_cong : forall A B C D, Col A B C -> Col A B D -> Cong A B C D -> Cong A C B D \/ Cong A D B C.

Lemma par_cong_cop :
  forall A B C D, Par A B C D -> Cong A B C D -> Coplanar A B C D.

Lemma par_cong_plg :
  forall A B C D, Par A B C D -> Cong A B C D -> Plg A B C D \/ Plg A B D C.

Lemma par_cong_plg_2 :
  forall A B C D,
  Par A B C D ->
  Cong A B C D ->
  Parallelogram A B C D \/ Parallelogram A B D C.

Lemma par_cong3_rect : forall A B C D, A <> C \/ B <> D -> Par A B C D -> Cong A B C D -> Cong A D B C -> Cong A C B D -> Rectangle A B C D \/ Rectangle A B D C.

Lemma pars_par_pars : forall A B C D, Par_strict A B C D -> Par A D B C -> Par_strict A D B C.

Lemma pars_par_plg : forall A B C D, Par_strict A B C D -> Par A D B C -> Plg A B C D.

Lemma not_par_pars_not_cong : forall O A B A' B', Out O A B -> Out O A' B' -> Par_strict A A' B B' -> ~Cong A A' B B'.

Lemma plg_uniqueness : forall A B C D D', Parallelogram A B C D -> Parallelogram A B C D' -> D = D'.

Lemma plgs_trans_trivial : forall A B C D B', Parallelogram_strict A B C D -> Parallelogram_strict C D A B' 
                                             -> Parallelogram A B B' A.

Lemma par_strict_trans : forall A B C D E F, Par_strict A B C D -> Par_strict C D E F -> Par A B E F.

Lemma plgs_pseudo_trans : forall A B C D E F, Parallelogram_strict A B C D -> Parallelogram_strict C D E F -> Parallelogram A B F E.

Lemma plgf_plgs_trans : forall A B C D E F, A <> B -> Parallelogram_flat A B C D -> Parallelogram_strict C D E F -> Parallelogram_strict A B F E.

Lemma plgf_plgf_plgf: forall A B C D E F, A <> B -> Parallelogram_flat A B C D -> Parallelogram_flat C D E F
                                          -> Parallelogram_flat A B F E.

Lemma plg_pseudo_trans : forall A B C D E F, Parallelogram A B C D -> Parallelogram C D E F -> Parallelogram A B F E \/ (A = B /\ C = D /\ E = F /\ A = E).

Lemma Square_Rhombus : forall A B C D,
 Square A B C D -> Rhombus A B C D.

Lemma plgs_in_angle : forall A B C D, Parallelogram_strict A B C D -> InAngle D A B C.

Lemma par_par_cong_cong_parallelogram :
 forall A B C D,
 B<>D ->
 Cong A B C D ->
 Cong B C D A ->
 Par B C A D ->
 Par A B C D ->
 Parallelogram A B C D.

Lemma degenerated_rect_eq : forall A B C, Rectangle A B B C -> A = C.

Lemma rect_2_rect : forall A B C1 C2 D1 D2,
  A <> B ->
  Rectangle A B C1 D1 ->
  Rectangle A B C2 D2 ->
  Rectangle C1 D1 D2 C2.

Lemma ncol123_plg__plgs : forall A B C D,
  ~ Col A B C -> Parallelogram A B C D -> Parallelogram_strict A B C D.

Lemma ncol124_plg__plgs : forall A B C D,
  ~ Col A B D -> Parallelogram A B C D -> Parallelogram_strict A B C D.

Lemma ncol134_plg__plgs : forall A B C D,
  ~ Col A C D -> Parallelogram A B C D -> Parallelogram_strict A B C D.

Lemma ncol234_plg__plgs : forall A B C D,
  ~ Col B C D -> Parallelogram A B C D -> Parallelogram_strict A B C D.

Lemma ncol123_plg__pars1234 : forall A B C D,
  ~ Col A B C -> Parallelogram A B C D -> Par_strict A B C D.

Lemma ncol124_plg__pars1234 : forall A B C D,
  ~ Col A B D -> Parallelogram A B C D -> Par_strict A B C D.

Lemma ncol134_plg__pars1234 : forall A B C D,
  ~ Col A C D -> Parallelogram A B C D -> Par_strict A B C D.

Lemma ncol234_plg__pars1234 : forall A B C D,
  ~ Col B C D -> Parallelogram A B C D -> Par_strict A B C D.

Lemma ncol123_plg__pars1423 : forall A B C D,
  ~ Col A B C -> Parallelogram A B C D -> Par_strict A D B C.

Lemma ncol124_plg__pars1423 : forall A B C D,
  ~ Col A B D -> Parallelogram A B C D -> Par_strict A D B C.

Lemma ncol134_plg__pars1423 : forall A B C D,
  ~ Col A C D -> Parallelogram A B C D -> Par_strict A D B C.

Lemma ncol234_plg__pars1423 : forall A B C D,
  ~ Col B C D -> Parallelogram A B C D -> Par_strict A D B C.

Lemma sac_plg : forall A B C D, Saccheri A B C D -> Parallelogram A B C D.

Lemma sac_rectangle : forall A B C D, Saccheri A B C D -> Rectangle A B C D.

Lemma exists_square : forall A B, A<>B -> exists C D,  Square A B C D.

End Quadrilateral_inter_dec_3.

Section Quadrilateral_inter_dec_2D.

Context `{T2D:Tarski_2D}.
Context `{TE:@Tarski_euclidean Tn TnEQD}.

Lemma perp3__perp :
 forall A B C D,
  Perp A B B C ->
  Perp B C C D ->
  Perp C D D A ->
  Perp D A A B.

Lemma perp3__rect :
 forall A B C D,
  Perp A B B C ->
  Perp B C C D ->
  Perp C D D A ->
  Rectangle A B C D.

End Quadrilateral_inter_dec_2D. *)



Section UnitTests.



Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.



Goal forall A B I, A <> B -> Midpoint I A B -> I <> A /\ I <> B.

Proof.

intros.

assert_diffs.

split;assumption.

Qed.



Goal forall A B I, B <> A -> Midpoint I A B -> I <> A /\ I <> B.

Proof.

intros.

assert_diffs.

split;assumption.

Qed.



Goal forall A B I, I<>A -> Midpoint I A B -> I <> B /\ A <> B.

Proof.

intros.

assert_diffs.

split;assumption.

Qed.



Goal forall A B I, I<>B -> Midpoint I A B -> I <> A /\ A <> B.

Proof.

intros.

assert_diffs.

split;assumption.

Qed.



Goal forall A B I, A<>I -> Midpoint I A B -> I <> B /\ A <> B.

Proof.

intros.

assert_diffs.

split;assumption.

Qed.



Goal forall A B I, B<>I -> Midpoint I A B -> I <> A /\ A <> B.

Proof.

intros.

assert_diffs.

split;assumption.

Qed.



Goal forall A B I, A<>B -> Midpoint I A B -> A <> I /\ I <> B.

Proof.

intros.

assert_diffs.

split;auto.

Qed.



Goal forall A B:Tpoint, A<>B -> B<>A -> True.

Proof.

intros.

first [not_exist_hyp_comm A B | clear H].

first [not_exist_hyp_comm A B | clear H0].

not_exist_hyp_comm A B.

auto.

Qed.



Goal forall A B C, Col A B C -> Col A C B -> Col B A C -> Col B C A -> Col C A B -> Col C B A -> True.

Proof.

intros.

first [not_exist_hyp_perm_col A B C | clear H].

first [not_exist_hyp_perm_col A B C | clear H0].

first [not_exist_hyp_perm_col A B C | clear H1].

first [not_exist_hyp_perm_col A B C | clear H2].

first [not_exist_hyp_perm_col A B C | clear H3].

first [not_exist_hyp_perm_col A B C | clear H4].

not_exist_hyp_perm_col A B C.

auto.

Qed.



Goal forall A B C, ~ Col A B C -> ~ Col A C B ->

  ~ Col B A C -> ~ Col B C A -> ~ Col C A B -> ~ Col C B A -> True.

Proof.

intros.

first [not_exist_hyp_perm_ncol A B C | clear H].

first [not_exist_hyp_perm_ncol A B C | clear H0].

first [not_exist_hyp_perm_ncol A B C | clear H1].

first [not_exist_hyp_perm_ncol A B C | clear H2].

first [not_exist_hyp_perm_ncol A B C | clear H3].

first [not_exist_hyp_perm_ncol A B C | clear H4].

not_exist_hyp_perm_ncol A B C.

auto.

Qed.



Goal forall A B C Q,

 B <> A -> Col A B C -> Midpoint Q A C ->

 A <> C -> B <> C -> Midpoint A B C ->

 Q <> C.

Proof.

intros.

assert_diffs.

assumption.

Qed.



Goal forall A B C, A<>B -> Per A B C -> A<>C.

Proof.

intros.

assert_diffs.

assumption.

Qed.



Goal forall A B C, B<>A -> Per A B C -> A<>C.

Proof.

intros.

assert_diffs.

assumption.

Qed.



Goal forall A B C, B<>C -> Per A B C -> A<>C.

Proof.

intros.

assert_diffs.

auto.

Qed.



Goal forall A B C, C<>B -> Per A B C -> A<>C.

Proof.

intros.

assert_diffs.

auto.

Qed.



Goal forall A B C D, Perp A B C D -> A<>B /\ C<>D.

Proof.

intros.

assert_diffs.

split;assumption.

Qed.



Goal forall A B C D, A<>B -> Perp A B C D -> A<>B /\ C<>D.

Proof.

intros.

assert_diffs.

split;assumption.

Qed.



Goal forall A B C D, A<>B -> Perp B A C D -> A<>B /\ C<>D.

Proof.

intros.

assert_diffs.

split;assumption.

Qed.



Goal forall A B C D, A<>B -> Perp B A D C -> A<>B /\ C<>D.

Proof.

intros.

assert_diffs.

split;intuition.

Qed.



Goal forall A B C D, A<>B -> C<>D -> Perp B A D C -> A<>B /\ C<>D.

Proof.

intros.

assert_diffs.

split;intuition.

Qed.



Goal forall A B C D, D<>C -> Perp B A D C -> A<>B /\ C<>D.

Proof.

intros.

assert_diffs.

split;intuition.

Qed.



Goal forall X A B C D, Perp_at X A B C D -> A<>B /\ C<>D.

Proof.

intros.

assert_diffs.

split;assumption.

Qed.



Goal forall A B C D, Par A B C D -> A<>B /\ C<>D.

Proof.

intros.

assert_diffs.

split;assumption.

Qed.



Goal forall A B C D, Par_strict A B C D -> A<>B /\ C<>D.

Proof.

intros.

assert_diffs.

split;assumption.

Qed.



Goal forall A B C, Out A B C -> B<>A /\ C<>A.

Proof.

intros.

assert_diffs.

split;assumption.

Qed.



Goal forall A B C, Out A B C -> Col B A C.

Proof.

intros.

assert_cols.

Col.

Qed.



Goal forall A B C D, ~ Col A B C -> ~ Col A B D ->

  A<>D.

Proof.

intros.

assert_diffs.

intuition.

Qed.



Goal forall A B C D I,

  Midpoint I A B -> Par A B C D -> I<>A.

Proof.

intros.

assert_diffs.

assumption.

Qed.



Goal forall A B C D I,

  Midpoint I A B -> Par A I C D -> B<>A.

Proof.

intros.

assert_diffs.

intuition.

Qed.



Goal forall A B C D,

 Cong A B C D -> C<>D -> A<>B.

Proof.

intros.

assert_diffs.

intuition.

Qed.



Goal forall A B C D,

 Cong A B C D -> D<>C -> A<>B.

Proof.

intros.

assert_diffs.

intuition.

Qed.



Goal forall A B C D,

 Cong A B C D -> A<>B -> C<>D.

Proof.

intros.

assert_diffs.

intuition.

Qed.



Goal forall A B C D,

 Cong A B C D -> B<>A -> C<>D.

Proof.

intros.

assert_diffs.

intuition.

Qed.



Goal forall A B C D E,

 ~ Col A B C ->

 ~ Col B D E -> A<>B ->

  Col A B D -> Col A B E -> Col A B C.

Proof.

intros.

search_contradiction.

Qed.



Goal forall A B C D X,

 Inter A B C D X ->

 A <> B /\ C <> D.

Proof.

intros.

assert_diffs.

split; auto.

Qed.



Goal forall A B C D,

 Par_strict A B C D ->

 A <> B /\ A <> C /\ A <> D /\ B <> C /\ B <> D /\ C <> D.

Proof.

intros.

assert_diffs.

repeat split; auto.

Qed.



Goal forall A B C, (A<>B -> B<>C -> A<>C -> Col A B C) -> Col A B C.

Proof.

intros.

assert_diffs_by_cases.

intuition.

Qed.



Goal forall A B C, Midpoint A B C -> Cong A B C A.

Proof.

intros.

assert_congs_perm.

finish.

Qed.



Goal forall A B C, Bet A B C -> A <> B -> A <> C.

Proof.

intros.

assert_diffs.

assumption.

Qed.



Goal forall A B C, Bet A B C -> B <> A -> A <> C.

Proof.

intros.

assert_diffs.

assumption.

Qed.



Goal forall A B C, Bet A B C -> B <> C -> A <> C.

Proof.

intros.

assert_diffs.

assumption.

Qed.



Goal forall A B C, Bet A B C -> C <> B -> A <> C.

Proof.

intros.

assert_diffs.

assumption.

Qed.



Goal forall A B C, ~ Bet A B C -> A <> B /\ B <> C.

Proof.

intros.

assert_diffs.

split; assumption.

Qed.



Goal forall A B C D, TS A B C D -> A <> B /\ A <> C /\ A <> D /\ B <> C /\ B <> D /\ C <> D.

Proof.

intros.

assert_diffs.

repeat split; assumption.

Qed.



Goal forall A B C D, OS A B C D -> A <> B /\ A <> C /\ A <> D /\ B <> C /\ B <> D.

Proof.

intros.

assert_diffs.

repeat split; assumption.

Qed.



Goal forall A B C D, Parallelogram_strict A B C D ->

  A <> B /\ B <> C /\ C <> D /\ D <> A /\ A <> C /\ B <> D.

Proof.

intros.

assert_diffs.

repeat split; assumption.

Qed.



Goal forall A B C D, A <> B -> Le A B C D -> C <> D.

Proof.

intros.

assert_diffs.

assumption.

Qed.



Goal forall A B C D, Lt A B C D -> C <> D.

Proof.

intros.

assert_diffs.

assumption.

Qed.



Goal forall A B C, Bet A B C -> Bet B A C -> A = B.

Proof.

intros.

treat_equalities.

trivial.

Qed.



Goal forall A B C, Bet A B C -> Bet A C B -> B = C.

Proof.

intros.

treat_equalities.

trivial.

Qed.



Goal forall A B C, Bet A B C -> Bet C A B -> A = B.

Proof.

intros.

treat_equalities.

trivial.

Qed.



Goal forall A B C, Bet A B C -> Bet B C A -> B = C.

Proof.

intros.

treat_equalities.

trivial.

Qed.



Goal forall A B X Y, TS A B X Y -> ~ Col A B X /\ ~ Col A B Y.

Proof.

intros.

assert_ncols.

split; assumption.

Qed.



Goal forall A B X Y, OS A B X Y -> ~ Col A B X /\ ~ Col A B Y.

Proof.

intros.

assert_ncols.

split; assumption.

Qed.



Goal forall A B C D, ~ Coplanar A B C D ->

  ~ Col A B C /\ ~ Col A B D /\ ~ Col A C D /\ ~ Col B C D.

Proof.

intros.

assert_ncols.

repeat split; assumption.

Qed.



Goal forall A B C D, Par_strict A B C D ->

  ~ Col A B C /\ ~ Col B C D /\ ~ Col C D A /\ ~ Col A B D.

Proof.

intros.

assert_ncols.

repeat split; assumption.

Qed.



Goal forall A B C D, Parallelogram_strict A B C D ->

  ~ Col A B C /\ ~ Col B C D /\ ~ Col C D A /\ ~ Col A B D.

Proof.

intros.

assert_ncols.

repeat split; assumption.

Qed.



End UnitTests.



Section UnitTestsEucl.



Context `{TE:Tarski_euclidean}.



Goal forall A B C D, Parallelogram A B C D -> Cong A B C D.

Proof.

intros.

assert_congs_perm.

finish.

Qed.



End UnitTestsEucl.
