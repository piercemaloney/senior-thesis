
Require Export Limit.
(* Limit:
Require Export Const.
Require Export CoUniversalArrow.
Require Export Ntransformation.

Set Implicit Arguments.
Unset Strict Implicit.

Section def_cone.

Variables (J C : Category) (c : C) (F : Functor J C).

SubClass Cone := NT (Const J c) F.

Definition Cones := NT_setoid (Const J c) F.

 Section cone_nt.

 Variable T : forall a : J, c --> F a.

 Definition Cone_law :=
   forall (i j : J) (g : i --> j), T j =_S T i o FMor F g.

 Lemma Prf_Cone_nt_law : Cone_law -> NT_law (F:=Const J c) T.
 
 Coercion Prf_Cone_nt_law : Cone_law >-> NT_law.

 Variable p : Cone_law.

 Canonical Structure Build_Cone : Cone := Build_NT (Prf_Cone_nt_law p).

 End cone_nt.

Coercion Build_Cone : Cone_law >-> Cone.
  
Lemma Eq_cone : forall tau : Cone, Cone_law (ApNT tau).

Lemma EqC :
 forall (tau : Cone) (i j : J) (g : i --> j), tau j =_S tau i o FMor F g.

Lemma EqC1 :
 forall (tau : Cone) (i j : J) (g : i --> j), tau i o FMor F g =_S tau j.

End def_cone.
		
Section limit_def.

Variables (J C : Category) (F : Functor J C).

 Section islimit_def. 
 
 Variables (lim : C) (nu : Cone lim F).

  Section limit_laws.

  Variable l_diese : forall c : C, Cone c F -> (c --> lim).  

  Definition Limit_eq (c : C) (tau : Cone c F) (g : c --> lim) :=
    forall i : J, g o nu i =_S tau i.
                      
  Definition Limit_law1 :=
    forall (c : C) (tau : Cone c F), Limit_eq tau (l_diese tau).

  Definition Limit_law2 :=
    forall (c : C) (tau : Cone c F) (g : c --> lim),
    Limit_eq tau g -> g =_S l_diese tau.
  
  End limit_laws.

 Structure IsLimit : Type := 
   {Lim_diese : forall c : C, Cone c F -> (c --> lim);
    Prf_limit1 : Limit_law1 Lim_diese;
    Prf_limit2 : Limit_law2 Lim_diese}.

 Variable l : IsLimit.

 Lemma Ldiese_map :
  forall (c : C) (tau1 tau2 : Cone c F),
  tau1 =_NT tau2 -> Lim_diese l tau1 =_S Lim_diese l tau2.
 
 End islimit_def.

 Structure > Limit : Type := 
   {Lim : C;
    Limiting_cone : Cone Lim F;
    Prf_Islimit :> IsLimit Limiting_cone}.

End limit_def.

Definition Complete (C : Category) :=
  forall (J : Category) (F : Functor J C), Limit F. *)
Require Export PULB.
(* PULB:
Require Export Category.
Require Export BasicTypes.

Set Implicit Arguments.
Unset Strict Implicit.

Inductive PULB_ob : Type :=
  | P1 : PULB_ob
  | P2 : PULB_ob
  | P3 : PULB_ob.

Inductive PULB_mor : PULB_ob -> PULB_ob -> Type :=
  | IP1 : PULB_mor P1 P1
  | IP2 : PULB_mor P2 P2
  | IP3 : PULB_mor P3 P3
  | F12 : PULB_mor P1 P2
  | F32 : PULB_mor P3 P2.

Lemma PULB_11_P :
 (PULB_mor P1 P1 -> Prop) -> forall a b : PULB_ob, PULB_mor a b -> Prop.

Lemma PULB_11_ind :
 forall P : PULB_mor P1 P1 -> Prop, P IP1 -> forall x : PULB_mor P1 P1, P x.

Lemma PULB_22_P :
 (PULB_mor P2 P2 -> Prop) -> forall a b : PULB_ob, PULB_mor a b -> Prop.

Lemma PULB_22_ind :
 forall P : PULB_mor P2 P2 -> Prop, P IP2 -> forall x : PULB_mor P2 P2, P x.

Lemma PULB_33_P :
 (PULB_mor P3 P3 -> Prop) -> forall a b : PULB_ob, PULB_mor a b -> Prop.

Lemma PULB_33_ind :
 forall P : PULB_mor P3 P3 -> Prop, P IP3 -> forall x : PULB_mor P3 P3, P x.

Lemma PULB_12_P :
 (PULB_mor P1 P2 -> Prop) -> forall a b : PULB_ob, PULB_mor a b -> Prop.

Lemma PULB_12_ind :
 forall P : PULB_mor P1 P2 -> Prop, P F12 -> forall x : PULB_mor P1 P2, P x.

Lemma PULB_32_P :
 (PULB_mor P3 P2 -> Prop) -> forall a b : PULB_ob, PULB_mor a b -> Prop.

Lemma PULB_32_ind :
 forall P : PULB_mor P3 P2 -> Prop, P F32 -> forall x : PULB_mor P3 P2, P x.

Lemma PULB_21_P :
 (PULB_mor P2 P1 -> Prop) -> forall a b : PULB_ob, PULB_mor a b -> Prop.

Lemma PULB_21_ind :
 forall (P : PULB_mor P2 P1 -> Prop) (x : PULB_mor P2 P1), P x.

Lemma PULB_21_T :
 (PULB_mor P2 P1 -> Type) -> forall a b : PULB_ob, PULB_mor a b -> Type.

Lemma PULB_21_rect :
 forall (P : PULB_mor P2 P1 -> Type) (x : PULB_mor P2 P1), P x.

Lemma PULB_31_P :
 (PULB_mor P3 P1 -> Prop) -> forall a b : PULB_ob, PULB_mor a b -> Prop.

Lemma PULB_31_ind :
 forall (P : PULB_mor P3 P1 -> Prop) (x : PULB_mor P3 P1), P x.

Lemma PULB_31_T :
 (PULB_mor P3 P1 -> Type) -> forall a b : PULB_ob, PULB_mor a b -> Type.

Lemma PULB_31_rect :
 forall (P : PULB_mor P3 P1 -> Type) (x : PULB_mor P3 P1), P x.

Lemma PULB_13_P :
 (PULB_mor P1 P3 -> Prop) -> forall a b : PULB_ob, PULB_mor a b -> Prop.

Lemma PULB_13_ind :
 forall (P : PULB_mor P1 P3 -> Prop) (x : PULB_mor P1 P3), P x.

Lemma PULB_13_T :
 (PULB_mor P1 P3 -> Type) -> forall a b : PULB_ob, PULB_mor a b -> Type.

Lemma PULB_13_rect :
 forall (P : PULB_mor P1 P3 -> Type) (x : PULB_mor P1 P3), P x.

Lemma PULB_23_P :
 (PULB_mor P2 P3 -> Prop) -> forall a b : PULB_ob, PULB_mor a b -> Prop.

Lemma PULB_23_ind :
 forall (P : PULB_mor P2 P3 -> Prop) (x : PULB_mor P2 P3), P x.

Lemma PULB_23_T :
 (PULB_mor P2 P3 -> Type) -> forall a b : PULB_ob, PULB_mor a b -> Type.

Lemma PULB_23_rect :
 forall (P : PULB_mor P2 P3 -> Type) (x : PULB_mor P2 P3), P x.

 Section pulb_setoid_def.

 Variable a b : PULB_ob.

 Definition Equal_PULB_mor (f g : PULB_mor a b) := True.
 
 Lemma Equal_PULB_mor_equiv : Equivalence Equal_PULB_mor.
 
 Canonical Structure PULB_mor_setoid := Build_Setoid Equal_PULB_mor_equiv.

 End pulb_setoid_def.

Definition Comp_PULB_mor (a b c : PULB_ob) (f : PULB_mor_setoid a b) :=
  match
    f in (PULB_mor p p0) return (PULB_mor_setoid p0 c -> PULB_mor_setoid p c)
  with
  | IP1 => 
       
      match c as p return (PULB_mor P1 p -> PULB_mor P1 p) with
      | P1 =>
            fun _ => IP1 
                     
      | P2 => fun _ => F12
               
      | P3 =>
          fun g => PULB_13_rect (fun _ : PULB_mor P1 P3 => PULB_mor P1 P3) g
      end
       
  | IP2 =>
      match c as p return (PULB_mor P2 p -> PULB_mor P2 p) with
      | P1 => 
           
          fun g =>
          PULB_21_rect (fun _ : PULB_mor P2 P1 => PULB_mor P2 P1) g
           
      | P2 => fun _ => IP2
               
      | P3 =>
          fun g => PULB_23_rect (fun _ : PULB_mor P2 P3 => PULB_mor P2 P3) g
      end
       
  | IP3 =>
      match c as p return (PULB_mor P3 p -> PULB_mor P3 p) with
      | P1 =>
           
          fun g =>
          PULB_31_rect (fun _ : PULB_mor P3 P1 => PULB_mor P3 P1) g 
           
      | P2 => fun _ => F32
               
      | P3 => fun _ => IP3
      end
       
  | F12 =>
      match c as p return (PULB_mor P2 p -> PULB_mor P1 p) with
      | P1 =>
           
          fun g =>
          PULB_21_rect (fun _ : PULB_mor P2 P1 => PULB_mor P1 P1) g
           
      | P2 => fun _ => F12
               
      | P3 =>
          fun g => PULB_23_rect (fun _ : PULB_mor P2 P3 => PULB_mor P1 P3) g
      end
       
  | F32 =>
      match c as p return (PULB_mor P2 p -> PULB_mor P3 p) with
      | P1 =>
           
          fun g =>
          PULB_21_rect (fun _ : PULB_mor P2 P1 => PULB_mor P3 P1) g
           
      | P2 => fun _ => F32
               
      | P3 =>
          fun g => PULB_23_rect (fun _ : PULB_mor P2 P3 => PULB_mor P3 P3) g
      end
  end.

Lemma Comp_PULB_congl : Congl_law Comp_PULB_mor.

Lemma Comp_PULB_congr : Congr_law Comp_PULB_mor.
 
Definition Comp_PULB := Build_Comp Comp_PULB_congl Comp_PULB_congr.

Lemma Assoc_PULB : Assoc_law Comp_PULB.

Definition Id_PULB (a : PULB_ob) :=
  match a as a' return (PULB_mor a' a') with
  | P1 =>   IP1 
       
  | P2 => IP2 
       
  | P3 => IP3
  end.

Lemma Idl_PULB : Idl_law Comp_PULB Id_PULB.

Lemma Idr_PULB : Idr_law Comp_PULB Id_PULB.
 
Canonical Structure PULB := Build_Category Assoc_PULB Idl_PULB Idr_PULB. *)
Require Export Pullbacks.
(* Pullbacks:
Require Export CatProperty.

Set Implicit Arguments.
Unset Strict Implicit.

Section pulbs_def.

Variables (C : Category) (a b c : C) (f : a --> b) (g : c --> b).

 Section pulbs_laws.

 Variables (Fibred_prod : C) (Fibred_p : Fibred_prod --> a)
   (Fibred_q : Fibred_prod --> c).

 Definition Pullback_eq1 (r : C) (t1 : r --> a) (t2 : r --> c) :=
   t1 o f =_S t2 o g.

 Definition Pullback_law1 := Pullback_eq1 Fibred_p Fibred_q.

 Variable
   Pb_diese :
     forall (r : C) (t1 : r --> a) (t2 : r --> c),
     Pullback_eq1 t1 t2 -> (r --> Fibred_prod).

 Definition Pullback_eq2 (x y z : C) (f1 : x --> y) 
   (f2 : z --> y) (f3 : x --> z) := f1 =_S f3 o f2.

 Definition Pullback_law2 :=
   forall (r : C) (t1 : r --> a) (t2 : r --> c) (pe : Pullback_eq1 t1 t2),
   Pullback_eq2 t1 Fibred_p (Pb_diese pe).

 Definition Pullback_law3 :=
   forall (r : C) (t1 : r --> a) (t2 : r --> c) (pe : Pullback_eq1 t1 t2),
   Pullback_eq2 t2 Fibred_q (Pb_diese pe).

 Definition Pullback_law4 :=
   forall (r : C) (t1 : r --> a) (t2 : r --> c) (pe : Pullback_eq1 t1 t2)
     (g : r --> Fibred_prod),
   Pullback_eq2 t1 Fibred_p g ->
   Pullback_eq2 t2 Fibred_q g -> g =_S Pb_diese pe.

 End pulbs_laws.

Structure Pullback : Type := 
  {Fibred_prod : C;
   Fibred_p : Fibred_prod --> a;
   Fibred_q : Fibred_prod --> c;
   Prf_pb_law1 : Pullback_law1 Fibred_p Fibred_q;
   Pb_diese :
    forall (r : C) (t1 : r --> a) (t2 : r --> c),
    Pullback_eq1 t1 t2 -> (r --> Fibred_prod);
   Prf_pb_law2 : Pullback_law2 Fibred_p Pb_diese;
   Prf_pb_law3 : Pullback_law3 Fibred_q Pb_diese;
   Prf_pb_law4 : Pullback_law4 Fibred_p Fibred_q Pb_diese}.
 
End pulbs_def. *)

Set Implicit Arguments.
Unset Strict Implicit.

Section Fpullback_limit_def.

Variables (C : Category) (G : Functor PULB C).

SubClass Fpullback1 := Limit G.

Variable l : Fpullback1.

Definition Fibred1_prod := Lim l.

Definition Fibred1_p : Fibred1_prod --> G P1 := Limiting_cone l P1.

Definition Fibred1_q : Fibred1_prod --> G P3 := Limiting_cone l P3.

Lemma Prf_pb1_law1 :
 Pullback_law1 (FMor G F12) (FMor G F32) Fibred1_p Fibred1_q.
Proof.
unfold Pullback_law1, Pullback_eq1 in |- *.
 apply Trans with (Limiting_cone l P2).
apply Sym.
apply (Eq_cone (Limiting_cone l) F12).
apply (Eq_cone (Limiting_cone l) F32).
Qed.
 
 Section pb1_diese_def.

 Variables (r : C) (t1 : r --> G P1) (t2 : r --> G P3).

 Hypothesis H : Pullback_eq1 (FMor G F12) (FMor G F32) t1 t2.

 Definition Pulb_tau (a : PULB) :=
   match a as a' return (Carrier (r --> G a')) with
   | P1 => t1
   | P2 => t1 o FMor G F12
   | P3 => t2
   end.
 
 Lemma Pulb_cone_law : Cone_law Pulb_tau.
 Proof.
 unfold Cone_law in |- *; intros x x1 t.
 elim t; simpl in |- *; unfold FMor at 1 in |- *; simpl in |- *.
 apply Trans with (t1 o Id (G P1)).
 apply Idr.
 apply Comp_l; apply (FId1 G P1).
 apply Trans with ((t1 o FMor G F12) o Id (G P2)).
 apply Idr.
 apply Comp_l; apply (FId1 G P2).
 apply Trans with (t2 o Id (G P3)).
 apply Idr.
 apply Comp_l; apply (FId1 G P3).
 apply Refl.
 apply H.
 Qed.
 
 Definition Pulb_cone : Cone r G := Pulb_cone_law.

 Definition Pb1_diese : r --> Fibred1_prod := Lim_diese l Pulb_cone.

 End pb1_diese_def.

Lemma Prf_pb1_law2 : Pullback_law2 Fibred1_p Pb1_diese.
Proof.
unfold Pullback_law2, Pullback_eq1, Pullback_eq2 in |- *; intros r t1 t2 H.
apply Sym; apply (Prf_limit1 l (Pulb_cone H) P1).
Qed.

Lemma Prf_pb1_law3 : Pullback_law3 Fibred1_q Pb1_diese.
Proof.
unfold Pullback_law3, Pullback_eq1, Pullback_eq2 in |- *; intros r t1 t2 H.
apply Sym; apply (Prf_limit1 l (Pulb_cone H) P3).
Qed.

Lemma Prf_pb1_law4 : Pullback_law4 Fibred1_p Fibred1_q Pb1_diese.
Proof.
unfold Pullback_law4, Pullback_eq1, Pullback_eq2 in |- *;
 intros r t1 t2 H h H1 H2.
unfold Pb1_diese in |- *.
apply (Prf_limit2 l).
unfold Limit_eq in |- *; simpl in |- *.
intro x; elim x; simpl in |- *.
apply Sym; exact H1.
 apply Trans with (h o Fibred1_p o FMor G F12).
apply Comp_l; apply (Eq_cone (Limiting_cone l) F12).
 apply Trans with ((h o Fibred1_p) o FMor G F12).
apply Ass.
apply Comp_r.
apply Sym; exact H1.
apply Sym; exact H2.
Qed.

Canonical Structure Pullback1_to_Pullback :=
  Build_Pullback Prf_pb1_law1 Prf_pb1_law2 Prf_pb1_law3 Prf_pb1_law4. 

End Fpullback_limit_def.

Coercion Pullback1_to_Pullback : Fpullback1 >-> Pullback. 

Section pullback_limit_def.

Variables (C : Category) (a b c : C) (f : a --> b) (g : c --> b).

Definition Fpulb_ob (x : PULB) :=
  match x return (Ob C) with
  | P1 => a
  | P2 => b
  | P3 => c
  end.

Definition Fpulb_mor (x y : PULB) (h : PULB_mor_setoid x y) :=
  match
    h in (PULB_mor x' y') return (Carrier (Fpulb_ob x' --> Fpulb_ob y'))
  with
  | IP1 => Id a
  | IP2 => Id b
  | IP3 => Id c
  | F12 => f
  | F32 => g
  end.

Lemma Fpulb_map_law : forall x y : PULB_ob, Map_law (Fpulb_mor (x:=x) (y:=y)).
Proof.
unfold Map_law in |- *; intros x y h1.
elim h1; simpl in |- *.

intro h2;
 lapply
  (PULB_11_ind
     (P:=fun t : PULB_mor P1 P1 =>
         Equal_PULB_mor IP1 t -> Id a =_S Fpulb_mor t)).
intros H H0; apply (H h2 H0).
intro H; simpl in |- *; apply Refl.

intro h2;
 lapply
  (PULB_22_ind
     (P:=fun t : PULB_mor P2 P2 =>
         Equal_PULB_mor IP2 t -> Id b =_S Fpulb_mor t)).
intros H H0; apply (H h2 H0).
intro H; simpl in |- *; apply Refl.

intro h2;
 lapply
  (PULB_33_ind
     (P:=fun t : PULB_mor P3 P3 =>
         Equal_PULB_mor IP3 t -> Id c =_S Fpulb_mor t)).
intros H H0; apply (H h2 H0).
intro H; simpl in |- *; apply Refl.

intro h2;
 lapply
  (PULB_12_ind
     (P:=fun t : PULB_mor P1 P2 => Equal_PULB_mor F12 t -> f =_S Fpulb_mor t)).
intros H H0; apply (H h2 H0).
intro H; simpl in |- *; apply Refl.

intro h2;
 lapply
  (PULB_32_ind
     (P:=fun t : PULB_mor P3 P2 => Equal_PULB_mor F32 t -> g =_S Fpulb_mor t)).
intros H H0; apply (H h2 H0).
intro H; simpl in |- *; apply Refl.
Qed.

Canonical Structure Fpulb_map (x y : PULB) :=
  Build_Map (Fpulb_map_law (x:=x) (y:=y)).

Lemma Fpulb_comp_law : Fcomp_law Fpulb_map.
Proof.
unfold Fcomp_law in |- *; simpl in |- *; intros x y z h1.
elim h1; simpl in |- *.

elim z; intro h2.

simpl in |- *;
 lapply
  (PULB_11_ind (P:=fun t : PULB_mor P1 P1 => Id a =_S Id a o Fpulb_mor t)).
intro H; apply (H h2).
simpl in |- *; apply Idr.

simpl in |- *;
 lapply (PULB_12_ind (P:=fun t : PULB_mor P1 P2 => f =_S Id a o Fpulb_mor t)).
intro H; apply (H h2).
simpl in |- *; apply Idl1.

apply
 (PULB_13_ind
    (fun t : PULB_mor P1 P3 =>
     Fpulb_mor (Comp_PULB_mor IP1 h2) =_S Id a o Fpulb_mor h2) h2).

elim z; intro h2.

apply
 (PULB_21_ind
    (fun a : PULB_mor P2 P1 =>
     Fpulb_mor (Comp_PULB_mor IP2 h2) =_S Id b o Fpulb_mor h2) h2).

simpl in |- *;
 lapply
  (PULB_22_ind (P:=fun t : PULB_mor P2 P2 => Id b =_S Id b o Fpulb_mor t)).
intro H; apply (H h2).
simpl in |- *; apply Idr.

apply
 (PULB_23_ind
    (fun a : PULB_mor P2 P3 =>
     Fpulb_mor (Comp_PULB_mor IP2 h2) =_S Id b o Fpulb_mor h2) h2).

elim z; intro h2.

apply
 (PULB_31_ind
    (fun a : PULB_mor P3 P1 =>
     Fpulb_mor (Comp_PULB_mor IP3 h2) =_S Id c o Fpulb_mor h2) h2).

simpl in |- *;
 apply (PULB_32_ind (P:=fun a : PULB_mor P3 P2 => g =_S Id c o Fpulb_mor a)).
simpl in |- *; apply Idl1.

simpl in |- *;
 lapply
  (PULB_33_ind (P:=fun t : PULB_mor P3 P3 => Id c =_S Id c o Fpulb_mor t)).
intro H; apply (H h2).
simpl in |- *; apply Idr.

elim z; intro h2.

apply
 (PULB_21_ind
    (fun a : PULB_mor P2 P1 =>
     Fpulb_mor (Comp_PULB_mor F12 h2) =_S f o Fpulb_mor h2) h2).

simpl in |- *;
 lapply (PULB_22_ind (P:=fun t : PULB_mor P2 P2 => f =_S f o Fpulb_mor t)).
intro H; apply (H h2).
simpl in |- *; apply Idr.

apply
 (PULB_23_ind
    (fun a : PULB_mor P2 P3 =>
     Fpulb_mor (Comp_PULB_mor F12 h2) =_S f o Fpulb_mor h2) h2).

elim z; intro h2.

apply
 (PULB_21_ind
    (fun a : PULB_mor P2 P1 =>
     Fpulb_mor (Comp_PULB_mor F32 h2) =_S g o Fpulb_mor h2) h2).

simpl in |- *;
 lapply (PULB_22_ind (P:=fun t : PULB_mor P2 P2 => g =_S g o Fpulb_mor t)).
intro H; apply (H h2).
simpl in |- *; apply Idr.

apply
 (PULB_23_ind
    (fun a : PULB_mor P2 P3 =>
     Fpulb_mor (Comp_PULB_mor F32 h2) =_S g o Fpulb_mor h2) h2).
Qed.

Lemma Fpulb_id_law : Fid_law Fpulb_map.
Proof.
unfold Fid_law in |- *; simpl in |- *; intro x.
elim x; simpl in |- *; apply Refl.
Qed.

Canonical Structure Fpulb := Build_Functor Fpulb_comp_law Fpulb_id_law.

SubClass Pullback1 := Fpullback1 Fpulb.

End pullback_limit_def.
