
Require Export Functor.
(* Functor:
Require Export Setoid_dup1.
Require Export Hom_Equality.

Set Implicit Arguments.
Unset Strict Implicit.

Section funct_def.

Variable C D : Category.

 Section funct_laws.

 Variables (FOb : C -> D)
   (FMap : forall a b : C, Map (a --> b) (FOb a --> FOb b)).

 Definition Fcomp_law :=
   forall (a b c : C) (f : a --> b) (g : b --> c),
   FMap a c (f o g) =_S FMap a b f o FMap b c g.

 Definition Fid_law := forall a : C, FMap a a (Id a) =_S Id (FOb a).

 End funct_laws.

Structure Functor : Type := 
  {FOb :> C -> D;
   FMap : forall a b : C, Map (a --> b) (FOb a --> FOb b);
   Prf_Fcomp_law : Fcomp_law FMap;
   Prf_Fid_law : Fid_law FMap}.

Definition FMor (F : Functor) (a b : C) (f : a --> b) := FMap F a b f.

Lemma FPres :
 forall (F : Functor) (a b : C) (f g : a --> b),
 f =_S g -> FMor F f =_S FMor F g.

Lemma FComp :
 forall (F : Functor) (a b c : C) (f : a --> b) (g : b --> c),
 FMor F (f o g) =_S FMor F f o FMor F g.

Lemma FComp1 :
 forall (F : Functor) (a b c : C) (f : a --> b) (g : b --> c),
 FMor F f o FMor F g =_S FMor F (f o g).

Lemma FId : forall (F : Functor) (a : C), FMor F (Id a) =_S Id (FOb F a).

Lemma FId1 : forall (F : Functor) (a : C), Id (FOb F a) =_S FMor F (Id a).

End funct_def.

Section funct_setoid.

Variable C D : Category. 

Definition Equal_Functor (F G : Functor C D) :=
  forall (a b : C) (f : a --> b), FMor F f =_H FMor G f.

Lemma Equal_Functor_equiv : Equivalence Equal_Functor.

Canonical Structure Functor_setoid := Build_Setoid' Equal_Functor_equiv.

End funct_setoid.

Infix "=_F" := Equal_Functor (at level 70).

Section Comp_F.

Variables (C D E : Category) (G : Functor C D) (H : Functor D E).

Definition Comp_FOb (a : C) := H (G a).

 Section comp_functor_map.

 Variable a b : C.

 Definition Comp_FMor (f : a --> b) := FMor H (FMor G f). 

 Lemma Comp_FMap_law : Map_law Comp_FMor.

 Definition Comp_FMap :=
   Build_Map (B:=Comp_FOb a --> Comp_FOb b) Comp_FMap_law.

 End comp_functor_map.

Lemma Comp_Functor_comp_law : Fcomp_law Comp_FMap.

Lemma Comp_Functor_id_law : Fid_law Comp_FMap.

Canonical Structure Comp_Functor :=
  Build_Functor Comp_Functor_comp_law Comp_Functor_id_law.

End Comp_F.

Infix "o_F" := Comp_Functor (at level 20, right associativity). *)
Require Export Setoid_dup2.
(* Setoid_dup2:
Require Export Relations.

Set Implicit Arguments.
Unset Strict Implicit.

Structure > Setoid'' : Type := 
  {Carrier'' :> Type;
   Equal'' : Relation Carrier'';
   Prf_equiv'' :> Equivalence Equal''}.

Infix "=_S''" := Equal'' (at level 70).

Lemma Refl'' : forall (S : Setoid'') (x : S), x =_S'' x.

Lemma Sym'' : forall (S : Setoid'') (x y : S), x =_S'' y -> y =_S'' x.

Lemma Trans'' :
 forall (S : Setoid'') (x y z : S), x =_S'' y -> y =_S'' z -> x =_S'' z.

Section maps''.

Variable A B : Setoid''.

Definition Map_law'' (f : A -> B) :=
  forall x y : A, x =_S'' y -> f x =_S'' f y.

Structure > Map'' : Type :=  {Ap'' :> A -> B; Pres'' :> Map_law'' Ap''}.

Lemma Pres1'' : forall (m : Map'') (x y : A), x =_S'' y -> m x =_S'' m y.

Definition Ext'' (f g : Map'') := forall x : A, f x =_S'' g x.

Lemma Ext_equiv'' : Equivalence Ext''.

Canonical Structure Map_setoid'' : Setoid'' := Ext_equiv''.

End maps''.

Section fun2_to_map2''.

Variable A B C : Setoid''.

Definition Map2'' := Map'' A (Map_setoid'' B C).

Variable f : A -> B -> C.

Definition Map2_congl_law'' :=
  forall (b1 b2 : B) (a : A), b1 =_S'' b2 -> f a b1 =_S'' f a b2.

Definition Map2_congr_law'' :=
  forall (a1 a2 : A) (b : B), a1 =_S'' a2 -> f a1 b =_S'' f a2 b.

Definition Map2_cong_law'' :=
  forall (a1 a2 : A) (b1 b2 : B),
  a1 =_S'' a2 -> b1 =_S'' b2 -> f a1 b1 =_S'' f a2 b2.

Hypothesis pgcl : Map2_congl_law''.
Hypothesis pgcr : Map2_congr_law''.

Lemma Map2_map_law1'' : forall a : A, Map_law'' (f a).

Canonical Structure Map2_map1'' (a : A) := Build_Map'' (Map2_map_law1'' a).

Lemma Map2_map_law2'' : Map_law'' Map2_map1''.

Definition Build_Map2'' : Map2'' := Build_Map'' Map2_map_law2''.

End fun2_to_map2''.

Section prop_map2''.

Variables (A B C : Setoid'') (f : Map2'' A B C).

Definition Ap2'' (a : A) (b : B) := f a b.

Lemma Prf_map2_congl'' : Map2_congl_law'' Ap2''.

Lemma Prf_map2_congr'' : Map2_congr_law'' Ap2''.

Lemma Prf_map2_cong'' : Map2_cong_law'' Ap2''.

End prop_map2''.

Coercion Ap2'' : Map2'' >-> Funclass.

Identity Coercion Map2''_Map'' : Map2'' >-> Map''. *)

Set Implicit Arguments.
Unset Strict Implicit.

Section nt_def.

Variables (C D : Category) (F G : Functor C D).

Definition NT_law (T : forall a : C, F a --> G a) :=
  forall (a b : C) (f : a --> b), FMor F f o T b =_S T a o FMor G f.

Structure > NT : Type := 
  {ApNT :> forall a : C, F a --> G a; Prf_NT_law :> NT_law ApNT}.

Lemma NatCond :
 forall (T : NT) (a b : C) (f : a --> b), FMor F f o T b =_S T a o FMor G f.
Proof.
exact Prf_NT_law.
Qed.

Lemma NatCond1 :
 forall (T : NT) (a b : C) (f : a --> b), T a o FMor G f =_S FMor F f o T b.
Proof.
intros T a b f; apply Sym; apply (Prf_NT_law T f).
Qed.

End nt_def.

Section setoid_nt.

Variables (C D : Category) (F G : Functor C D).

Definition Equal_NT (T T' : NT F G) := forall a : C, T a =_S T' a.

Lemma Equal_NT_equiv : Equivalence Equal_NT.
Proof.
apply Build_Equivalence; unfold Equal_NT in |- *.
unfold Reflexive in |- *; intros T a; apply Refl.
apply Build_Partial_equivalence.
unfold Transitive in |- *; intros T1 T2 T3 H H0 a.
 apply Trans with (ApNT T2 a); auto.
unfold Symmetric in |- *; intros T1 T2 H a.
apply Sym; apply H.
Qed.

Canonical Structure NT_setoid : Setoid'' := Equal_NT_equiv.

End setoid_nt.

Infix "=_NT" := Equal_NT (at level 70).
