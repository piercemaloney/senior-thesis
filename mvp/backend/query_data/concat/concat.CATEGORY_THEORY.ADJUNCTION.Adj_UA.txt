
Require Export CoUniversalArrow.
(* CoUniversalArrow:
Require Export UniversalArrow.
Require Export Dual_Functor.

Set Implicit Arguments.
Unset Strict Implicit.

Section coua_def.

Variables (A B : Category) (b : B) (F : Functor A B).

 Section iscoua_def.

 Variables (a : A) (u : F a --> b).

  Section coua_laws.

  Variable co_diese : forall a' : A, (F a' --> b) -> (a' --> a).

  Definition CoUA_eq (a' : A) (f : F a' --> b) (g : a' --> a) :=
    FMor F g o u =_S f.

  Definition CoUA_law1 :=
    forall (a' : A) (f : F a' --> b), CoUA_eq f (co_diese f).

  Definition CoUA_law2 :=
    forall (a' : A) (f : F a' --> b) (g : a' --> a),
    CoUA_eq f g -> g =_S co_diese f.

  End coua_laws. 
 
 Structure IsCoUA : Type := 
   {CoUA_diese : forall a' : A, (F a' --> b) -> (a' --> a);
    Prf_isCoUA_law1 : CoUA_law1 CoUA_diese;
    Prf_isCoUA_law2 : CoUA_law2 CoUA_diese}.

 Variable t : IsCoUA.

 Lemma Codiese_map : forall a' : A, Map_law (CoUA_diese t (a':=a')).

 End iscoua_def.

Structure > CoUA : Type := 
  {CoUA_ob : A; CoUA_mor : F CoUA_ob --> b; Prf_IsCoUA :> IsCoUA CoUA_mor}.

Lemma CoUA_diag :
 forall (u : CoUA) (a' : A) (f : F a' --> b),
 FMor F (CoUA_diese u f) o CoUA_mor u =_S f.
 
Lemma CoUA_diag1 :
 forall (u : CoUA) (a' : A) (f : F a' --> b),
 f =_S FMor F (CoUA_diese u f) o CoUA_mor u. 

Lemma CoUA_unic :
 forall (u : CoUA) (a' : A) (f : F a' --> b) (g : a' --> CoUA_ob u),
 FMor F g o CoUA_mor u =_S f -> g =_S CoUA_diese u f.

Lemma CoUA_unic1 :
 forall (u : CoUA) (a' : A) (f : F a' --> b) (g : a' --> CoUA_ob u),
 FMor F g o CoUA_mor u =_S f -> CoUA_diese u f =_S g.

End coua_def.

Section coua_def1.

Variables (A B : Category) (b : B) (F : Functor A B).

 Section iscoua_def1.

 Variables (a : A) (u : F a --> b).

 Definition IsCoUA1 := IsUA (G:=Dfunctor F) u.
 
 Variable u1 : IsCoUA1.

 Definition CoUA1_diese (a' : A) (f : F a' --> b) := UA_diese u1 f.

 Lemma Prf_isCoUA1_law1 : CoUA_law1 u CoUA1_diese.

 Lemma Prf_isCoUA1_law2 : CoUA_law2 u CoUA1_diese.

 Lemma IsCoUA1_to_IsCoUA : IsCoUA u. 

 End iscoua_def1.

Coercion IsCoUA1_to_IsCoUA : IsCoUA1 >-> IsCoUA.

Definition CoUA1 := UA (b:Ob (Dual B)) (Dfunctor F).

Variable u1 : CoUA1.

Definition CoUA1_to_CoUA := Build_CoUA (IsCoUA1_to_IsCoUA (Prf_IsUA u1)). 

End coua_def1.

Coercion CoUA1_to_CoUA : CoUA1 >-> CoUA. *)
Require Export Adjunction.
(* Adjunction:
Require Export NatIso.
Require Export HomFunctor2.

Set Implicit Arguments.
Unset Strict Implicit.

Section adj_def.

Variables (C D : Category) (F : Functor D C) (G : Functor C D).

SubClass Adj := NatIso (FunSET2_r F) (FunSET2_l G).

Variables (phi : NT (FunSET2_r F) (FunSET2_l G))
  (phi_1 : NT (FunSET2_l G) (FunSET2_r F)).
Variable phi_iso : AreNatIsos phi phi_1.

Definition Build_Adj : Adj := Build_NatIso phi_iso.

Variables (d : D) (c : C) (ad : Adj).
 
Definition ApAphi (f : F d --> c) : d --> G c := ad (Build_POb1 d c) f.

Definition ApAphi_inv (g : d --> G c) : F d --> c :=
  NatIso_inv ad (Build_POb1 d c) g.

Lemma AphiPres : forall f g : F d --> c, f =_S g -> ApAphi f =_S ApAphi g.

Lemma Aphi_invPres :
 forall f g : d --> G c, f =_S g -> ApAphi_inv f =_S ApAphi_inv g.

End adj_def.

Structure LeftAdj (C D : Category) (G : Functor C D) : Type := 
  {Adjoint : Functor D C; Adj_l :> Adj Adjoint G}.

Structure RightAdj (C D : Category) (F : Functor D C) : Type := 
  {CoAdjoint : Functor C D; Adj_r :> Adj F CoAdjoint}.

Section adj_eqs.

Variables (C D : Category) (F : Functor D C) (G : Functor C D) (ad : Adj F G).
Variables (d d' : D) (c c' : C) (h : d' --> d) (k : c --> c') (f : F d --> c).

Lemma Adj_eq1 :
 ApAphi ad ((FMor F h o f) o k) =_S (h o ApAphi ad f) o FMor G k.

Variable g : d --> G c.

Lemma Adj_eq2 :
 ApAphi_inv ad ((h o g) o FMor G k) =_S (FMor F h o ApAphi_inv ad g) o k.
       
End adj_eqs.

Section adj_eqs1.

Variables (C D : Category) (F : Functor D C) (G : Functor C D) (ad : Adj F G).
Variables (d d' : D) (c c' : C) (h : d' --> d) (k : c --> c') 
  (f : F d --> c) (g : d --> G c).

Lemma Adj_eq3 : ApAphi ad (f o k) =_S ApAphi ad f o FMor G k.

Lemma Adj_eq4 : ApAphi ad (FMor F h o f) =_S h o ApAphi ad f.

Lemma Adj_eq5 : ApAphi_inv ad (g o FMor G k) =_S ApAphi_inv ad g o k.
        
Lemma Adj_eq6 : ApAphi_inv ad (h o g) =_S FMor F h o ApAphi_inv ad g.

End adj_eqs1. *)

Set Implicit Arguments.
Unset Strict Implicit.

Section adj_to_ua.

Variables (C D : Category) (F : Functor D C) (G : Functor C D) (ad : Adj F G).
Variable d : D.

Definition Unit_ob := F d.

Definition Unit_arrow := ApAphi ad (Id (F d)).
 
Definition Unit_arrow_diese (c : C) (f : d --> G c) := ApAphi_inv ad f.

Lemma Unit_UAlaw1 : UA_law1 Unit_arrow Unit_arrow_diese.
Proof.
unfold UA_law1, UA_eq, Unit_arrow_diese, Unit_arrow in |- *.
intros c1 f; apply Sym.
apply Trans with (ApAphi ad (Id (F d) o ApAphi_inv ad f)).
apply Trans with (ApAphi ad (ApAphi_inv ad f)).
apply Sym; exact (Idl_inv (NTa_areIso ad (Build_POb1 d c1)) f).
apply AphiPres; apply Idl1.
apply (Adj_eq3 ad (ApAphi_inv ad f) (Id (F d))).
Qed.

Lemma Unit_UAlaw2 : UA_law2 Unit_arrow Unit_arrow_diese.
Proof.
unfold UA_law2, UA_eq, Unit_arrow_diese, Unit_arrow in |- *.
intros c1 f f' H.
apply Trans with (ApAphi_inv ad (ApAphi ad (Id (F d)) o FMor G f')).
apply Sym.
apply Trans with (ApAphi_inv ad (ApAphi ad (Id (F d))) o f').
apply (Adj_eq5 ad f' (ApAphi ad (Id (F d)))).
apply Trans with (Id (F d) o f').
apply Comp_r; apply (Idr_inv (NTa_areIso ad (Build_POb1 d (F d))) (Id (F d))).
apply Idl.
apply Aphi_invPres; apply H.
Qed.

Canonical Structure Unit' := Build_IsUA Unit_UAlaw1 Unit_UAlaw2.

Canonical Structure Unit := Build_UA Unit'.

Variable c : C.

Definition CoUnit_ob := G c.

Definition CoUnit_arrow := ApAphi_inv ad (Id (G c)).

Definition CoUnit_arrow_diese (d : D) (f : F d --> c) := ApAphi ad f.
                        
Lemma CoUnit_coUAlaw1 : CoUA_law1 CoUnit_arrow CoUnit_arrow_diese.
Proof.
unfold CoUA_law1, CoUA_eq, CoUnit_arrow_diese, CoUnit_arrow in |- *.
intros d1 f.
 apply Trans with (ApAphi_inv ad (ApAphi ad f o Id (G c))).
apply Sym; apply (Adj_eq6 ad (ApAphi ad f) (Id (G c))).
 apply Trans with (ApAphi_inv ad (ApAphi ad f)).
apply Aphi_invPres; apply Idr1.
apply (Idr_inv (NTa_areIso ad (Build_POb1 d1 c)) f).
Qed.

Lemma CoUnit_coUAlaw2 : CoUA_law2 CoUnit_arrow CoUnit_arrow_diese.
Proof.
unfold CoUA_law2, CoUA_eq, CoUnit_arrow_diese, CoUnit_arrow in |- *.
intros d1 f g H.
 apply Trans with (ApAphi ad (FMor F g o ApAphi_inv ad (Id (G c)))).
 apply Trans with (g o ApAphi ad (ApAphi_inv ad (Id (G c)))).
 apply Trans with (g o Id (G c)).
apply Idr.
apply Comp_l; apply Sym.
apply (Idl_inv (NTa_areIso ad (Build_POb1 (G c) c)) (Id (G c))).
apply Sym; apply (Adj_eq4 ad g (ApAphi_inv ad (Id (G c)))).
apply AphiPres; apply H.
Qed.

Canonical Structure CoUnit' := Build_IsCoUA CoUnit_coUAlaw1 CoUnit_coUAlaw2.

Canonical Structure CoUnit := Build_CoUA CoUnit'.

End adj_to_ua.

