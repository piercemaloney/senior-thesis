
Require Export Setoid_dup1.
(* Setoid_dup1:
Require Export Relations.

Set Implicit Arguments.
Unset Strict Implicit.

Structure > Setoid' : Type := 
  {Carrier' :> Type;
   Equal' : Relation Carrier';
   Prf_equiv' :> Equivalence Equal'}.

Infix "=_S'" := Equal' (at level 70).

Lemma Refl' : forall (S : Setoid') (x : S), x =_S' x.

Lemma Sym' : forall (S : Setoid') (x y : S), x =_S' y -> y =_S' x.

Lemma Trans' :
 forall (S : Setoid') (x y z : S), x =_S' y -> y =_S' z -> x =_S' z.

Section maps'.

Variable A B : Setoid'.

Definition Map_law' (f : A -> B) := forall x y : A, x =_S' y -> f x =_S' f y.

Structure > Map' : Type :=  {Ap' :> A -> B; Pres' :> Map_law' Ap'}.

Lemma Pres1' : forall (m : Map') (x y : A), x =_S' y -> m x =_S' m y.

Definition Ext' (f g : Map') := forall x : A, f x =_S' g x.

Lemma Ext_equiv' : Equivalence Ext'.

Canonical Structure Map_setoid' : Setoid' := Ext_equiv'.

End maps'.

Section fun2_to_map2'.

Variable A B C : Setoid'.

Definition Map2' := Map' A (Map_setoid' B C).

Variable f : A -> B -> C.

Definition Map2_congl_law' :=
  forall (b1 b2 : B) (a : A), b1 =_S' b2 -> f a b1 =_S' f a b2.

Definition Map2_congr_law' :=
  forall (a1 a2 : A) (b : B), a1 =_S' a2 -> f a1 b =_S' f a2 b.

Definition Map2_cong_law' :=
  forall (a1 a2 : A) (b1 b2 : B),
  a1 =_S' a2 -> b1 =_S' b2 -> f a1 b1 =_S' f a2 b2.

Hypothesis pgcl : Map2_congl_law'.
Hypothesis pgcr : Map2_congr_law'.

Lemma Map2_map_law1' : forall a : A, Map_law' (f a).

Canonical Structure Map2_map1' (a : A) := Build_Map' (Map2_map_law1' a).

Lemma Map2_map_law2' : Map_law' Map2_map1'.

Definition Build_Map2' : Map2' := Build_Map' Map2_map_law2'.

End fun2_to_map2'.

Section prop_map2'.

Variables (A B C : Setoid') (f : Map2' A B C).

Definition Ap2' (a : A) (b : B) := f a b.

Lemma Prf_map2_congl' : Map2_congl_law' Ap2'.

Lemma Prf_map2_congr' : Map2_congr_law' Ap2'.

Lemma Prf_map2_cong' : Map2_cong_law' Ap2'.

End prop_map2'.

Coercion Ap2' : Map2' >-> Funclass.

Identity Coercion Map2'_Map' : Map2' >-> Map'. *)
Require Export Hom_Equality.
(* Hom_Equality:
Require Export Category.

Set Implicit Arguments.
Unset Strict Implicit.

Inductive Equal_hom (C : Category) (a b : C) (f : a --> b) :
forall c d : C, (c --> d) -> Prop :=
    Build_Equal_hom : forall g : a --> b, f =_S g -> Equal_hom f g. 

Hint Resolve Build_Equal_hom.

Infix "=_H" := Equal_hom (at level 70).

Section equal_hom_equiv.

Variables (C : Category) (a b : C) (f : a --> b).

Lemma Equal_hom_refl : f =_H f.

Variables (c d : C) (g : c --> d).

Lemma Equal_hom_sym : f =_H g -> g =_H f.

Variables (i j : C) (h : i --> j).

Lemma Equal_hom_trans : f =_H g -> g =_H h -> f =_H h.

End equal_hom_equiv.

Hint Resolve Equal_hom_refl.
Hint Resolve Equal_hom_sym.

Section arrs_setoid_def.

Variable C : Category.

Structure Arrs : Type :=  {Dom : C; Codom : C; Arrow : Dom --> Codom}.

Definition Equal_Arrs (f g : Arrs) := Arrow f =_H Arrow g.

Lemma Equal_Arrs_equiv : Equivalence Equal_Arrs.

End arrs_setoid_def. *)

Set Implicit Arguments.
Unset Strict Implicit.

Section funct_def.

Variable C D : Category.

 Section funct_laws.

 Variables (FOb : C -> D)
   (FMap : forall a b : C, Map (a --> b) (FOb a --> FOb b)).

 Definition Fcomp_law :=
   forall (a b c : C) (f : a --> b) (g : b --> c),
   FMap a c (f o g) =_S FMap a b f o FMap b c g.

 Definition Fid_law := forall a : C, FMap a a (Id a) =_S Id (FOb a).

 End funct_laws.

Structure Functor : Type := 
  {FOb :> C -> D;
   FMap : forall a b : C, Map (a --> b) (FOb a --> FOb b);
   Prf_Fcomp_law : Fcomp_law FMap;
   Prf_Fid_law : Fid_law FMap}.

Definition FMor (F : Functor) (a b : C) (f : a --> b) := FMap F a b f.

Lemma FPres :
 forall (F : Functor) (a b : C) (f g : a --> b),
 f =_S g -> FMor F f =_S FMor F g.
Proof.
intros F a b; exact (Pres (FMap F a b)).
Qed.

Lemma FComp :
 forall (F : Functor) (a b c : C) (f : a --> b) (g : b --> c),
 FMor F (f o g) =_S FMor F f o FMor F g.
Proof.
exact Prf_Fcomp_law.
Qed.

Lemma FComp1 :
 forall (F : Functor) (a b c : C) (f : a --> b) (g : b --> c),
 FMor F f o FMor F g =_S FMor F (f o g).
Proof.
intros; apply Sym; apply (Prf_Fcomp_law F f g).
Qed.

Lemma FId : forall (F : Functor) (a : C), FMor F (Id a) =_S Id (FOb F a).
Proof.
exact Prf_Fid_law.
Qed.

Lemma FId1 : forall (F : Functor) (a : C), Id (FOb F a) =_S FMor F (Id a).
Proof.
intros; apply Sym; apply (Prf_Fid_law F a).
Qed.

End funct_def.

Section funct_setoid.

Variable C D : Category. 

Definition Equal_Functor (F G : Functor C D) :=
  forall (a b : C) (f : a --> b), FMor F f =_H FMor G f.

Lemma Equal_Functor_equiv : Equivalence Equal_Functor.
Proof.
apply Build_Equivalence; unfold Equal_Functor in |- *.
auto.
apply Build_Partial_equivalence.
unfold Transitive in |- *; intros F G H Ass1 Ass2 a b f.
 apply Equal_hom_trans with (G a) (G b) (FMor G f); auto.
auto.
Qed.

Canonical Structure Functor_setoid := Build_Setoid' Equal_Functor_equiv.

End funct_setoid.

Infix "=_F" := Equal_Functor (at level 70).

Section Comp_F.

Variables (C D E : Category) (G : Functor C D) (H : Functor D E).

Definition Comp_FOb (a : C) := H (G a).

 Section comp_functor_map.

 Variable a b : C.

 Definition Comp_FMor (f : a --> b) := FMor H (FMor G f). 

 Lemma Comp_FMap_law : Map_law Comp_FMor.
 Proof.
 unfold Map_law, Comp_FMor, FMor in |- *; intros f g eqfg.
 apply Pres1; apply Pres1; assumption.
 Qed.

 Definition Comp_FMap :=
   Build_Map (B:=Comp_FOb a --> Comp_FOb b) Comp_FMap_law.

 End comp_functor_map.

Lemma Comp_Functor_comp_law : Fcomp_law Comp_FMap.
Proof.
unfold Fcomp_law, Comp_FOb, Comp_FMap, Comp_FMor in |- *.
simpl in |- *; intros a b c f g.
 
 apply Trans with (FMor H (FMor G f o FMor G g)).

apply FPres; apply FComp.

apply FComp.
Qed.

Lemma Comp_Functor_id_law : Fid_law Comp_FMap.
Proof.
unfold Fid_law, Comp_FOb, Comp_FMap, Comp_FMor in |- *.
simpl in |- *; intro a.

 apply Trans with (FMor H (Id (G a))).

apply FPres; apply FId.

apply FId.
Qed.               

Canonical Structure Comp_Functor :=
  Build_Functor Comp_Functor_comp_law Comp_Functor_id_law.

End Comp_F.

Infix "o_F" := Comp_Functor (at level 20, right associativity).
