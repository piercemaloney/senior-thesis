
Require Export FreeMonoid.
(* FreeMonoid:
Require Export Monoid.

Set Implicit Arguments.
Unset Strict Implicit.

Section freem_def.

Variable A : Setoid.

Inductive Tlist : Type :=
  | Empty : Tlist
  | Concat1 : A -> Tlist -> Tlist.

Fixpoint Equal_Tlist (l : Tlist) : Tlist -> Prop :=
  fun m : Tlist =>
  match l, m with
  | Empty, Empty => True
  | Empty, _ => False
  | Concat1 a l1, Concat1 b m1 => a =_S b /\ Equal_Tlist l1 m1
  | _, _ => False
  end.

Lemma Equal_Tlist_equiv : Equivalence Equal_Tlist.

Canonical Structure Tlist_setoid : Setoid := Equal_Tlist_equiv.

Fixpoint Concat (l : Tlist_setoid) : Tlist_setoid -> Tlist_setoid :=
  fun m : Tlist_setoid =>
  match l with
  | Empty => m
  | Concat1 a l1 => Concat1 a (Concat l1 m)
  end.

Lemma Diff_Concat1_Empty :
 forall (a : A) (l : Tlist), ~ Equal_Tlist (Concat1 a l) Empty.

Lemma Concat_congl : Map2_congl_law Concat.

Lemma Concat_congr : Map2_congr_law Concat.

Definition Concat_map2 := Build_Map2 Concat_congl Concat_congr.

Lemma Mass_FreeMonoid : Monoid_ass Concat_map2.

Lemma Midl_FreeMonoid : Monoid_idl Concat_map2 Empty.

Lemma Midr_FreeMonoid : Monoid_idr Concat_map2 Empty.

Canonical Structure FreeMonoid :=
  Build_Monoid Mass_FreeMonoid Midl_FreeMonoid Midr_FreeMonoid.

End freem_def.

Coercion FreeMonoid : Setoid >-> Monoid. *)
Require Export Functor.
(* Functor:
Require Export Setoid_dup1.
Require Export Hom_Equality.

Set Implicit Arguments.
Unset Strict Implicit.

Section funct_def.

Variable C D : Category.

 Section funct_laws.

 Variables (FOb : C -> D)
   (FMap : forall a b : C, Map (a --> b) (FOb a --> FOb b)).

 Definition Fcomp_law :=
   forall (a b c : C) (f : a --> b) (g : b --> c),
   FMap a c (f o g) =_S FMap a b f o FMap b c g.

 Definition Fid_law := forall a : C, FMap a a (Id a) =_S Id (FOb a).

 End funct_laws.

Structure Functor : Type := 
  {FOb :> C -> D;
   FMap : forall a b : C, Map (a --> b) (FOb a --> FOb b);
   Prf_Fcomp_law : Fcomp_law FMap;
   Prf_Fid_law : Fid_law FMap}.

Definition FMor (F : Functor) (a b : C) (f : a --> b) := FMap F a b f.

Lemma FPres :
 forall (F : Functor) (a b : C) (f g : a --> b),
 f =_S g -> FMor F f =_S FMor F g.

Lemma FComp :
 forall (F : Functor) (a b c : C) (f : a --> b) (g : b --> c),
 FMor F (f o g) =_S FMor F f o FMor F g.

Lemma FComp1 :
 forall (F : Functor) (a b c : C) (f : a --> b) (g : b --> c),
 FMor F f o FMor F g =_S FMor F (f o g).

Lemma FId : forall (F : Functor) (a : C), FMor F (Id a) =_S Id (FOb F a).

Lemma FId1 : forall (F : Functor) (a : C), Id (FOb F a) =_S FMor F (Id a).

End funct_def.

Section funct_setoid.

Variable C D : Category. 

Definition Equal_Functor (F G : Functor C D) :=
  forall (a b : C) (f : a --> b), FMor F f =_H FMor G f.

Lemma Equal_Functor_equiv : Equivalence Equal_Functor.

Canonical Structure Functor_setoid := Build_Setoid' Equal_Functor_equiv.

End funct_setoid.

Infix "=_F" := Equal_Functor (at level 70).

Section Comp_F.

Variables (C D E : Category) (G : Functor C D) (H : Functor D E).

Definition Comp_FOb (a : C) := H (G a).

 Section comp_functor_map.

 Variable a b : C.

 Definition Comp_FMor (f : a --> b) := FMor H (FMor G f). 

 Lemma Comp_FMap_law : Map_law Comp_FMor.

 Definition Comp_FMap :=
   Build_Map (B:=Comp_FOb a --> Comp_FOb b) Comp_FMap_law.

 End comp_functor_map.

Lemma Comp_Functor_comp_law : Fcomp_law Comp_FMap.

Lemma Comp_Functor_id_law : Fid_law Comp_FMap.

Canonical Structure Comp_Functor :=
  Build_Functor Comp_Functor_comp_law Comp_Functor_id_law.

End Comp_F.

Infix "o_F" := Comp_Functor (at level 20, right associativity). *)
Require Export MON.
(* MON:
Require Export SET.
Require Export Monoid.

Set Implicit Arguments.
Unset Strict Implicit.

Section comp_mon.

Variables (m1 m2 m3 : Monoid) (f : MonMor m1 m2) (g : MonMor m2 m3).

Definition Comp_MonMor_map := f o_M g.

Lemma Comp_MonMor_unit_law : MonUnit_law Comp_MonMor_map.

Lemma Comp_MonMor_op_law : MonOp_law Comp_MonMor_map.
 
Canonical Structure Comp_MonMor : MonMor_setoid m1 m3 :=
  Build_MonMor Comp_MonMor_unit_law Comp_MonMor_op_law.

End comp_mon.

Lemma Comp_MonMor_congl : Congl_law Comp_MonMor.

Lemma Comp_MonMor_congr : Congr_law Comp_MonMor.

Definition Comp_MON := Build_Comp Comp_MonMor_congl Comp_MonMor_congr.

Lemma Assoc_MON : Assoc_law Comp_MON.

Section id_mon_def.

Variable m : Monoid.

Definition Id_MON_map := Id_SET m.

Lemma Id_MON_unit_law : MonUnit_law Id_MON_map.

Lemma Id_MON_op_law : MonOp_law Id_MON_map.

Canonical Structure Id_MON : MonMor_setoid m m :=
  Build_MonMor Id_MON_unit_law Id_MON_op_law.

End id_mon_def.

Lemma Idl_MON : Idl_law Comp_MON Id_MON.

Lemma Idr_MON : Idr_law Comp_MON Id_MON.

Canonical Structure MON := Build_Category Assoc_MON Idl_MON Idr_MON. *)

Set Implicit Arguments.
Unset Strict Implicit.

Section funfreemon_map_def.

Variable A B : Setoid.

 Section funfreemon_mor_def.

 Variable f : Map A B.

 Fixpoint Dist_fun (l : Tlist A) : Tlist B :=
   match l with
   | Empty => Empty B
   | Concat1 a l1 => Concat1 (f a) (Dist_fun l1)
   end.

 Lemma Dist_map_law : Map_law Dist_fun.
 Proof.
 unfold Map_law in |- *; intros l1; elim l1.
 intro l2; elim l2.
 intros; apply Refl.
 intros c t H H1; elim H1.
 intros c t H l2; elim l2.
 intro H1; absurd (Equal_Tlist (Concat1 c t) (Empty A)).
 apply (Diff_Concat1_Empty (A:=A)).
 trivial.
 intros c0 t0 H1 H2.
 elim H2; intros H3 H4.
 simpl in |- *; split.
 apply Pres1; trivial.
 exact (H t0 H4).
 Qed.

 Canonical Structure Dist_map := Build_Map Dist_map_law.

 Lemma Dist_map_unit_law : MonUnit_law Dist_map.
 Proof.
 unfold MonUnit_law in |- *; simpl in |- *; trivial.
 Qed.

 Lemma Dist_map_op_law : MonOp_law Dist_map.
 Proof.
 unfold MonOp_law in |- *.
 intros l1 l2; elim l1.
 unfold ApMop in |- *; apply Refl.
 intros; split.
 apply Refl.
 trivial.
 Qed.

 Canonical Structure FunFreeMon_mor :=
   Build_MonMor Dist_map_unit_law Dist_map_op_law.

 End funfreemon_mor_def.

Lemma FunFreeMon_map_law : Map_law FunFreeMon_mor.
Proof.
unfold Map_law in |- *; simpl in |- *.
intros f g; unfold Equal_MonMor in |- *; simpl in |- *.
unfold Ext in |- *; simpl in |- *; intro H; intro l; elim l; simpl in |- *.
trivial.
intros c t H1; split.
apply H.
trivial.
Qed.

Canonical Structure FunFreeMon_map := Build_Map FunFreeMon_map_law.

End funfreemon_map_def.

Lemma FunFreeMon_fcomp_law : Fcomp_law FunFreeMon_map.
Proof.
unfold Fcomp_law in |- *; simpl in |- *.
intros A B C f g; unfold Equal_MonMor in |- *; simpl in |- *.
unfold Ext in |- *; simpl in |- *; intro l; elim l; simpl in |- *.
trivial.
intros c t H; split.
apply Refl.
trivial.
Qed.

Lemma FunFreeMon_fid_law : Fid_law FunFreeMon_map.
Proof.
unfold Fid_law in |- *; simpl in |- *.
intro A; unfold Equal_MonMor in |- *; simpl in |- *.
unfold Ext in |- *; simpl in |- *; intro l; elim l; simpl in |- *.
trivial.
intros c t H; split.
apply Refl.
trivial.
Qed.

Canonical Structure FunFreeMon :=
  Build_Functor FunFreeMon_fcomp_law FunFreeMon_fid_law.

