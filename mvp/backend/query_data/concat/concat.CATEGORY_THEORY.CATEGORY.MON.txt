
Require Export SET.
(* SET:
Require Export Category.

Set Implicit Arguments.
Unset Strict Implicit.

Lemma Comp_map_congl : Congl_law Comp_map.

Lemma Comp_map_congr : Congr_law Comp_map.

Definition Comp_SET := Build_Comp Comp_map_congl Comp_map_congr.

Lemma Assoc_SET : Assoc_law Comp_SET.

Definition Id_SET := Id_map.
 
Lemma Idl_SET : Idl_law Comp_SET Id_SET.

Lemma Idr_SET : Idr_law Comp_SET Id_SET.

Canonical Structure SET := Build_Category Assoc_SET Idl_SET Idr_SET. *)
Require Export Monoid.
(* Monoid:
Require Export Map2.

Set Implicit Arguments.
Unset Strict Implicit.

SubClass BinOp (A : Setoid) := Map2 A A A.

Section monoid_laws.

Variables (A : Setoid) (op : BinOp A) (e : A).

Let Ap_op (x y : A) := op x y.

Infix "+_M" := Ap_op (at level 40, left associativity).

Definition Monoid_ass := forall x y z : A, x +_M (y +_M z) =_S x +_M y +_M z.

Definition Monoid_idl := forall x : A, e +_M x =_S x.

Definition Monoid_idr := forall x : A, x =_S x +_M e.

End monoid_laws.

Structure Monoid : Type := 
  {Mcarrier :> Setoid;
   Mop : BinOp Mcarrier;
   Munit : Mcarrier;
   Prf_monoid_ass : Monoid_ass Mop;
   Prf_monoid_idl : Monoid_idl Mop Munit;
   Prf_monoid_idr : Monoid_idr Mop Munit}.

Definition ApMop (m : Monoid) (x y : m) := Mop m x y.

Infix "+_M" := ApMop (at level 40, left associativity).
        
Lemma Mass :
 forall (M : Monoid) (x y z : M), x +_M (y +_M z) =_S x +_M y +_M z.

Lemma Mass1 :
 forall (M : Monoid) (x y z : M), x +_M y +_M z =_S x +_M (y +_M z).

Lemma Midl : forall (M : Monoid) (x : M), Munit M +_M x =_S x.

Lemma Midl1 : forall (M : Monoid) (x : M), x =_S Munit M +_M x.

Lemma Midr : forall (M : Monoid) (x : M), x =_S x +_M Munit M.

Lemma Midr1 : forall (M : Monoid) (x : M), x +_M Munit M =_S x.

Section mon_mors.

Variable m1 m2 : Monoid.

Definition MonUnit_law (f : Map m1 m2) := f (Munit m1) =_S Munit m2.

Definition MonOp_law (f : Map m1 m2) :=
  forall a b : m1, f (a +_M b) =_S f a +_M f b.

Structure MonMor : Type := 
  {MonMap :> Map m1 m2;
   Prf_MonUnit_law : MonUnit_law MonMap;
   Prf_MonOp_law : MonOp_law MonMap}.

Lemma MMon_unit : forall f : MonMor, f (Munit m1) =_S Munit m2.

Lemma MMon_op : forall (f : MonMor) (a b : m1), f (a +_M b) =_S f a +_M f b.

Definition Equal_MonMor (f g : MonMor) := f =_M g.

Lemma Equal_MonMor_equiv : Equivalence Equal_MonMor.

Canonical Structure MonMor_setoid : Setoid := Equal_MonMor_equiv.

End mon_mors. *)

Set Implicit Arguments.
Unset Strict Implicit.

Section comp_mon.

Variables (m1 m2 m3 : Monoid) (f : MonMor m1 m2) (g : MonMor m2 m3).

Definition Comp_MonMor_map := f o_M g.

Lemma Comp_MonMor_unit_law : MonUnit_law Comp_MonMor_map.
Proof.
unfold MonUnit_law, Comp_MonMor_map in |- *. 
simpl in |- *; unfold Comp_fun in |- *.
apply Trans with (g (Munit m2)).
apply Pres1; apply MMon_unit.
apply MMon_unit.
Qed.

Lemma Comp_MonMor_op_law : MonOp_law Comp_MonMor_map.
Proof.
unfold MonOp_law, Comp_MonMor_map in |- *.
simpl in |- *; unfold Comp_fun in |- *.
intros a b.
apply Trans with (g (f a +_M f b)).
apply (Pres g); apply MMon_op.
apply MMon_op.
Qed.
 
Canonical Structure Comp_MonMor : MonMor_setoid m1 m3 :=
  Build_MonMor Comp_MonMor_unit_law Comp_MonMor_op_law.

End comp_mon.

Lemma Comp_MonMor_congl : Congl_law Comp_MonMor.
Proof.
unfold Congl_law in |- *; simpl in |- *.
unfold Equal_MonMor, Ext in |- *; simpl in |- *.
unfold Comp_fun in |- *.
intros m1 m2 m3 f g h H a.
apply H.
Qed.

Lemma Comp_MonMor_congr : Congr_law Comp_MonMor.
Proof.
unfold Congr_law in |- *; simpl in |- *.
unfold Equal_MonMor, Ext in |- *; simpl in |- *.
unfold Comp_fun in |- *.
intros m1 m2 m3 f g h H a.
apply Pres1.
apply H.
Qed.

Definition Comp_MON := Build_Comp Comp_MonMor_congl Comp_MonMor_congr.

Lemma Assoc_MON : Assoc_law Comp_MON.
Proof.
unfold Assoc_law in |- *; simpl in |- *; intros m1 m2 m3 m4 f g h.
unfold Equal_MonMor, Ext in |- *; simpl in |- *.
unfold Comp_fun in |- *; intro a.
apply Refl.
Qed.

Section id_mon_def.

Variable m : Monoid.

Definition Id_MON_map := Id_SET m.

Lemma Id_MON_unit_law : MonUnit_law Id_MON_map.
Proof.
unfold MonUnit_law, Id_MON_map in |- *; simpl in |- *.
unfold Id_fun in |- *; apply Refl. 
Qed.

Lemma Id_MON_op_law : MonOp_law Id_MON_map.
Proof.
unfold MonOp_law, Id_MON_map in |- *; simpl in |- *.
unfold Id_fun in |- *; intros a b.
apply Refl.
Qed.

Canonical Structure Id_MON : MonMor_setoid m m :=
  Build_MonMor Id_MON_unit_law Id_MON_op_law.

End id_mon_def.

Lemma Idl_MON : Idl_law Comp_MON Id_MON.
Proof.
unfold Idl_law in |- *; intros m1 m2 f; simpl in |- *.
unfold Equal_MonMor, Ext in |- *; simpl in |- *.
unfold Comp_fun in |- *; intro a.
unfold Id_MON_map in |- *; simpl in |- *; unfold Id_fun in |- *.
apply Refl.
Qed.

Lemma Idr_MON : Idr_law Comp_MON Id_MON.
Proof.
unfold Idr_law in |- *; intros m1 m2 f; simpl in |- *.
unfold Equal_MonMor, Ext in |- *; simpl in |- *.
unfold Comp_fun in |- *; intro a.
unfold Id_MON_map in |- *; simpl in |- *; unfold Id_fun in |- *.
apply Refl.
Qed.

Canonical Structure MON := Build_Category Assoc_MON Idl_MON Idr_MON.