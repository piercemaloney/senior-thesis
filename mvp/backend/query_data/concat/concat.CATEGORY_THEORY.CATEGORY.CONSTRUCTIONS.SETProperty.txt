
Require Export SET.
(* SET:
Require Export Category.

Set Implicit Arguments.
Unset Strict Implicit.

Lemma Comp_map_congl : Congl_law Comp_map.

Lemma Comp_map_congr : Congr_law Comp_map.

Definition Comp_SET := Build_Comp Comp_map_congl Comp_map_congr.

Lemma Assoc_SET : Assoc_law Comp_SET.

Definition Id_SET := Id_map.
 
Lemma Idl_SET : Idl_law Comp_SET Id_SET.

Lemma Idr_SET : Idr_law Comp_SET Id_SET.

Canonical Structure SET := Build_Category Assoc_SET Idl_SET Idr_SET. *)
Require Export CatProperty.
(* CatProperty:
Require Export Dual.

Set Implicit Arguments.
Unset Strict Implicit.

Section epic_monic_def.

Variables (C : Category) (a b : C).
 
Definition Epic_law (f : a --> b) :=
  forall (c : C) (g h : b --> c), f o g =_S f o h -> g =_S h.

Structure > Epic : Type := 
  {Epic_mor : a --> b; Prf_isEpic :> Epic_law Epic_mor}.

Definition Monic_law (f : b --> a) :=
  forall (c : C) (g h : c --> b), g o f =_S h o f -> g =_S h.

Structure > Monic : Type := 
  {Monic_mor : b --> a; Prf_isMonic :> Monic_law Monic_mor}.

End epic_monic_def.

Section iso_def.

Variable C : Category.

Definition RIso_law (a b : C) (f : a --> b) (f1 : b --> a) := f1 o f =_S Id b.

Variable a b : C.

Definition AreIsos (f : a --> b) (f1 : b --> a) :=
  RIso_law f f1 /\ RIso_law f1 f.

Structure > Iso : Type := 
  {Iso_mor : a --> b; Inv_iso : b --> a; Prf_Iso :> AreIsos Iso_mor Inv_iso}.

Lemma Idl_inv : forall i : Iso, RIso_law (Iso_mor i) (Inv_iso i).

Lemma Idr_inv : forall i : Iso, RIso_law (Inv_iso i) (Iso_mor i).

Lemma Inv_iso_unique :
 forall f g : Iso, Iso_mor f =_S Iso_mor g -> Inv_iso f =_S Inv_iso g.

Lemma RightInv_epic :
 forall (h : a --> b) (h1 : b --> a), RIso_law h h1 -> Epic_law h.

End iso_def.

Coercion RightInv_epic : RIso_law >-> Epic_law.

Section initial_def.

Variable C : Category.

Definition IsInitial (a : C) (h : forall b : C, a --> b) :=
  forall (b : C) (f : a --> b), f =_S h b.
  
Structure > Initial : Type := 
  {Initial_ob : C;
   MorI : forall b : C, Initial_ob --> b;
   Prf_isInitial :> IsInitial MorI}.

Definition At_most_1mor (a b : C) := forall f g : a --> b, f =_S g.

Lemma UniqueI : forall (i : Initial) (b : C), At_most_1mor (Initial_ob i) b.

Lemma I_unic : forall i1 i2 : Initial, Iso (Initial_ob i1) (Initial_ob i2).

End initial_def.

Section terminal_def.

Variable C : Category.

Definition IsTerminal (b : C) (h : forall a : C, a --> b) :=
  forall (a : C) (f : a --> b), f =_S h a. 

Structure > Terminal : Type := 
  {Terminal_ob : C;
   MorT : forall a : C, a --> Terminal_ob;
   Prf_isTerminal :> IsTerminal MorT}.

Lemma UniqueT : forall (t : Terminal) (a : C), At_most_1mor a (Terminal_ob t).

End terminal_def.

Lemma Initial_dual :
 forall (C : Category) (a : C) (h : forall b : C, a --> b),
 IsInitial h -> IsTerminal (C:=Dual C) h.

Coercion Initial_dual : IsInitial >-> IsTerminal.

Definition IsTerminal' (C : Category) (b : C) (h : forall a : C, a --> b) :=
  IsInitial (C:=Dual C) h. *)
Require Export MapProperty.
(* MapProperty:
Require Export Map.

Set Implicit Arguments.
Unset Strict Implicit.

Section inj_surj_def.

Variable A B : Setoid.

Definition Inj_law (f : Map A B) := forall x y : A, f x =_S f y -> x =_S y.

Structure > Inj : Type :=  {Inj_map :> Map A B; Prf_isInj :> Inj_law Inj_map}.

Definition Surj_law (f : Map A B) (h : B -> A) := forall b : B, b =_S f (h b).

Structure > Surj : Type := 
  {Surj_map :> Map A B;
   Surj_elt : B -> A;
   Prf_isSurj :> Surj_law Surj_map Surj_elt}.

End inj_surj_def. *)

Set Implicit Arguments.
Unset Strict Implicit.

SubClass SET_Epic_law (A B : Setoid) (f : Map A B) := Epic_law f.

SubClass SET_Monic_law (A B : Setoid) (f : Map A B) := Monic_law f.

Section set_epic_monic.

Variables (A B : Setoid) (f : Map A B).

Lemma Surj_epic : forall h : B -> A, Surj_law f h -> SET_Epic_law f.
Proof.
intros h H; unfold Surj_law, SET_Epic_law, Epic_law in |- *;
 intros a f' f'' H1.
simpl in |- *; unfold Ext in |- *; intro x.
apply Trans with (f' (f (h x))).
apply Pres1; apply H.
apply Trans with (f'' (f (h x))).
exact (H1 (h x)).
apply Pres1; apply Sym; apply H.
Qed.

Lemma Inj_monic : Inj_law f -> SET_Monic_law f.
Proof.
unfold Inj_law, SET_Monic_law in |- *; intro H1; unfold Monic_law in |- *.
intros C g h H2; simpl in |- *; unfold Ext in |- *; intro x.
apply H1; exact (H2 x).
Qed.

 Section map_const_fun.

 Variable a : A.

 Definition MapConst_fun (b : B) := a.

 Lemma MapConst_map_law : Map_law MapConst_fun.
 Proof.
 unfold Map_law in |- *; intros x y H; apply Refl.
 Qed.

 Definition MapConst : Map B A := MapConst_map_law.

 End map_const_fun.

Lemma Monic_inj : SET_Monic_law f -> Inj_law f.
Proof.
unfold Monic_law in |- *; intros H1; unfold Inj_law in |- *.
intros x y H2.
generalize (H1 _ (MapConst x) (MapConst y)).
intros H3; exact (H3 (fun z : B => H2) (f x)).
Qed.

End set_epic_monic.

Coercion Surj_epic : Surj_law >-> SET_Epic_law. 

Coercion Inj_monic : Inj_law >-> SET_Monic_law.

Coercion Monic_inj : SET_Monic_law >-> Inj_law.

