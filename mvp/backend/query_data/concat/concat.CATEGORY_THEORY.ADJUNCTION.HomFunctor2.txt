
Require Export SET.
(* SET:
Require Export Category.

Set Implicit Arguments.
Unset Strict Implicit.

Lemma Comp_map_congl : Congl_law Comp_map.

Lemma Comp_map_congr : Congr_law Comp_map.

Definition Comp_SET := Build_Comp Comp_map_congl Comp_map_congr.

Lemma Assoc_SET : Assoc_law Comp_SET.

Definition Id_SET := Id_map.
 
Lemma Idl_SET : Idl_law Comp_SET Id_SET.

Lemma Idr_SET : Idr_law Comp_SET Id_SET.

Canonical Structure SET := Build_Category Assoc_SET Idl_SET Idr_SET. *)
Require Export Dual.
(* Dual:
Require Export Category.

Set Implicit Arguments.
Unset Strict Implicit.

Section d_cat.

Variable C : Category.

Definition DHom (a b : C) := b --> a.

Definition Comp_Darrow (a b c : C) (df : DHom a b) (dg : DHom b c) := dg o df.
                          
Lemma Comp_dual_congl : Congl_law Comp_Darrow.
                          
Lemma Comp_dual_congr : Congr_law Comp_Darrow.

Definition Comp_Dual := Build_Comp Comp_dual_congl Comp_dual_congr.
            
Lemma Assoc_Dual : Assoc_law Comp_Dual.

Lemma Idl_Dual : Idl_law (Hom:=DHom) Comp_Dual (Id (c:=C)).

Lemma Idr_Dual : Idr_law (Hom:=DHom) Comp_Dual (Id (c:=C)).

Canonical Structure Dual := Build_Category Assoc_Dual Idl_Dual Idr_Dual.

End d_cat. *)
Require Export PROD.
(* PROD:
Require Export Category. 
Require Export SetoidPROD.

Set Implicit Arguments.
Unset Strict Implicit.

Section ProdCat.

Variable A B : Category.

Structure POb : Type :=  {Ob_l : A; Ob_r : B}.

 Section pmor_setoid_def.

 Variable u t : POb.

 Structure Pmor : Type := 
   {Hom_l : Ob_l u --> Ob_l t; Hom_r : Ob_r u --> Ob_r t}.

 Definition Equal_Pmor (f g : Pmor) :=
   Hom_l f =_S Hom_l g /\ Hom_r f =_S Hom_r g.

 Lemma Equal_Pmor_equiv : Equivalence Equal_Pmor.

 Canonical Structure Prod_Hom : Setoid := Equal_Pmor_equiv.

 Definition Prod_Hom' := SPROD (Ob_l u --> Ob_l t) (Ob_r u --> Ob_r t).

 Definition Build1_Pmor :
   (Ob_l u --> Ob_l t) -> (Ob_r u --> Ob_r t) -> Prod_Hom := Build_Pmor.
                
 End pmor_setoid_def.

Definition Comp_Pmor (a b c : POb) (f : Prod_Hom a b) 
  (g : Prod_Hom b c) := Build_Pmor (Hom_l f o Hom_l g) (Hom_r f o Hom_r g).

Lemma Comp_Pmor_congl : Congl_law Comp_Pmor.

Lemma Comp_Pmor_congr : Congr_law Comp_Pmor.

Definition Comp_PROD := Build_Comp Comp_Pmor_congl Comp_Pmor_congr.

Lemma Assoc_PROD : Assoc_law Comp_PROD.

Definition Id_PROD (a : POb) := Build_Pmor (Id (Ob_l a)) (Id (Ob_r a)).

Lemma Idl_PROD : Idl_law Comp_PROD Id_PROD.
 
Lemma Idr_PROD : Idr_law Comp_PROD Id_PROD.
 
Canonical Structure PROD := Build_Category Assoc_PROD Idl_PROD Idr_PROD.

End ProdCat. *)
Require Export Functor.
(* Functor:
Require Export Setoid_dup1.
Require Export Hom_Equality.

Set Implicit Arguments.
Unset Strict Implicit.

Section funct_def.

Variable C D : Category.

 Section funct_laws.

 Variables (FOb : C -> D)
   (FMap : forall a b : C, Map (a --> b) (FOb a --> FOb b)).

 Definition Fcomp_law :=
   forall (a b c : C) (f : a --> b) (g : b --> c),
   FMap a c (f o g) =_S FMap a b f o FMap b c g.

 Definition Fid_law := forall a : C, FMap a a (Id a) =_S Id (FOb a).

 End funct_laws.

Structure Functor : Type := 
  {FOb :> C -> D;
   FMap : forall a b : C, Map (a --> b) (FOb a --> FOb b);
   Prf_Fcomp_law : Fcomp_law FMap;
   Prf_Fid_law : Fid_law FMap}.

Definition FMor (F : Functor) (a b : C) (f : a --> b) := FMap F a b f.

Lemma FPres :
 forall (F : Functor) (a b : C) (f g : a --> b),
 f =_S g -> FMor F f =_S FMor F g.

Lemma FComp :
 forall (F : Functor) (a b c : C) (f : a --> b) (g : b --> c),
 FMor F (f o g) =_S FMor F f o FMor F g.

Lemma FComp1 :
 forall (F : Functor) (a b c : C) (f : a --> b) (g : b --> c),
 FMor F f o FMor F g =_S FMor F (f o g).

Lemma FId : forall (F : Functor) (a : C), FMor F (Id a) =_S Id (FOb F a).

Lemma FId1 : forall (F : Functor) (a : C), Id (FOb F a) =_S FMor F (Id a).

End funct_def.

Section funct_setoid.

Variable C D : Category. 

Definition Equal_Functor (F G : Functor C D) :=
  forall (a b : C) (f : a --> b), FMor F f =_H FMor G f.

Lemma Equal_Functor_equiv : Equivalence Equal_Functor.

Canonical Structure Functor_setoid := Build_Setoid' Equal_Functor_equiv.

End funct_setoid.

Infix "=_F" := Equal_Functor (at level 70).

Section Comp_F.

Variables (C D E : Category) (G : Functor C D) (H : Functor D E).

Definition Comp_FOb (a : C) := H (G a).

 Section comp_functor_map.

 Variable a b : C.

 Definition Comp_FMor (f : a --> b) := FMor H (FMor G f). 

 Lemma Comp_FMap_law : Map_law Comp_FMor.

 Definition Comp_FMap :=
   Build_Map (B:=Comp_FOb a --> Comp_FOb b) Comp_FMap_law.

 End comp_functor_map.

Lemma Comp_Functor_comp_law : Fcomp_law Comp_FMap.

Lemma Comp_Functor_id_law : Fid_law Comp_FMap.

Canonical Structure Comp_Functor :=
  Build_Functor Comp_Functor_comp_law Comp_Functor_id_law.

End Comp_F.

Infix "o_F" := Comp_Functor (at level 20, right associativity). *)

Set Implicit Arguments.
Unset Strict Implicit.

Section FunSet2_r.

Variable C D : Category.

 Section abrev.
 
 Definition OB_l (dxc : POb (Dual D) C) : D := Ob_l dxc.

 Variables (d1xc1 d2xc2 : POb (Dual D) C) (foxg : Pmor d1xc1 d2xc2).

 Definition HOM_l : OB_l d2xc2 --> OB_l d1xc1 := Hom_l foxg.

 Definition Build_POb1 (d : D) (c : C) := Build_POb (A:=Dual D) (B:=C) d c.

 Definition Build_Pmor1 (c c' : C) (d d' : D) (f : d' --> d)
   (g : c --> c') := Build_Pmor (u:=Build_POb1 d c) (t:=Build_POb1 d' c') f g.

 End abrev.

Variable F : Functor D C.

Definition FunSET2_r_ob (dxc : POb (Dual D) C) := F (OB_l dxc) --> Ob_r dxc.

 Section funset2_r_map_def.

 Variable d1xc1 d2xc2 : POb (Dual D) C.

  Section funset2_r_mor_def.

  Variable foxg : Pmor d1xc1 d2xc2.

  Definition FunSET2_r_mor1 (h : FunSET2_r_ob d1xc1) :=
    (FMor F (HOM_l foxg) o h) o Hom_r foxg.

  Lemma FunSET2_r_map_law1 : Map_law FunSET2_r_mor1.
  Proof.
  unfold Map_law, FunSET2_r_mor1 in |- *; simpl in |- *.
  intros h1 h2 H.
  apply Comp_r; apply Comp_l; assumption.
  Qed.

  Canonical Structure FunSET2_r_mor :
    Map (FunSET2_r_ob d1xc1) (FunSET2_r_ob d2xc2) := FunSET2_r_map_law1.

  End funset2_r_mor_def.
  
 Lemma FunSET2_r_map_law : Map_law FunSET2_r_mor.
 Proof.
 unfold Map_law, FunSET2_r_mor in |- *.
 intros f1xg1 f2xg2; elim f1xg1; intros f1 g1. 
 elim f2xg2; intros f2 g2; simpl in |- *.
 unfold Ext in |- *; simpl in |- *.
 unfold Equal_Pmor in |- *; simpl in |- *.
 unfold FunSET2_r_mor1 in |- *; simpl in |- *.
 unfold FunSET2_r_ob in |- *.
 intro H; elim H; intros H1 H2 h.
 apply Comp_lr.
 apply Comp_r; trivial.
 apply FPres; assumption.
 assumption.
 Qed.

 Canonical Structure FunSET2_r_map := Build_Map FunSET2_r_map_law.

 End funset2_r_map_def.

Lemma Fun2_r_comp_law : Fcomp_law FunSET2_r_map.
Proof.
unfold Fcomp_law, FunSET2_r_map in |- *; simpl in |- *.
unfold FunSET2_r_mor, Ext in |- *; simpl in |- *.
unfold FunSET2_r_mor1, FunSET2_r_ob in |- *; simpl in |- *.
intros d1xc1 d2xc2 d3xc3 f1xg1 f2xg2 h.
elim f1xg1; simpl in |- *; unfold DHom in |- *; intros f1 g1.
elim f2xg2; simpl in |- *; unfold DHom in |- *; intros f2 g2; simpl in |- *.
 apply Trans with (((FMor F (f2 o f1) o h) o g1) o g2).
apply Ass.
apply Comp_r.
 apply Trans with ((FMor F f2 o FMor F f1 o h) o g1).
apply Comp_r.
 apply Trans with ((FMor F f2 o FMor F f1) o h).
apply Comp_r.
apply FComp.
apply Ass1.
apply Ass1.
Qed.

Lemma Fun2_r_id_law : Fid_law FunSET2_r_map.
Proof.
unfold Fid_law, FunSET2_r_map, FunSET2_r_mor in |- *; simpl in |- *.
unfold Ext, Id_SET in |- *; simpl in |- *.
unfold FunSET2_r_mor1 in |- *; simpl in |- *.
unfold FunSET2_r_ob in |- *; intros dxc f.
unfold Id_fun in |- *.
 apply Trans with (FMor F (Id (OB_l dxc)) o f).
apply Idr1.
 apply Trans with (Id (F (OB_l dxc)) o f).
apply Comp_r.
apply FId.
apply Idl.
Qed.

Canonical Structure FunSET2_r := Build_Functor Fun2_r_comp_law Fun2_r_id_law.

End FunSet2_r.

Section FunSet2_l.

Variables (C D : Category) (G : Functor C D).

Definition FunSET2_l_ob (dxc : POb (Dual D) C) := OB_l dxc --> G (Ob_r dxc).

 Section funset2_l_map_def.

 Variable d1xc1 d2xc2 : POb (Dual D) C.

  Section funset2_l_mor_def.

  Variable foxg : Pmor d1xc1 d2xc2.

  Definition FunSET2_l_mor1 (h : FunSET2_l_ob d1xc1) :=
    (HOM_l foxg o h) o FMor G (Hom_r foxg).

  Lemma FunSET2_l_map_law1 : Map_law FunSET2_l_mor1.
  Proof.
  unfold Map_law, FunSET2_l_mor1 in |- *; simpl in |- *.
  intros h1 h2 H.
  apply Comp_r; apply Comp_l; assumption.
  Qed.

  Canonical Structure FunSET2_l_mor :
    Map (FunSET2_l_ob d1xc1) (FunSET2_l_ob d2xc2) := FunSET2_l_map_law1.

  End funset2_l_mor_def.

 Lemma FunSET2_l_map_law : Map_law FunSET2_l_mor.
 Proof.
 unfold Map_law, FunSET2_l_mor in |- *.
 intros f1xg1 f2xg2; elim f1xg1; intros f1 g1. 
 elim f2xg2; intros f2 g2; simpl in |- *.
 unfold Ext in |- *; simpl in |- *.
 unfold Equal_Pmor in |- *; simpl in |- *.
 unfold FunSET2_l_mor1 in |- *; simpl in |- *.
 unfold FunSET2_l_ob in |- *.
 intro H; elim H; intros H1 H2 h.
 apply Comp_lr.
 apply Comp_r; trivial.
 apply FPres. 
 assumption.
 Qed.

 Canonical Structure FunSET2_l_map := Build_Map FunSET2_l_map_law.

 End funset2_l_map_def.
 
Lemma Fun2_l_comp_law : Fcomp_law FunSET2_l_map.
Proof.
unfold Fcomp_law, FunSET2_l_map in |- *; simpl in |- *.
unfold FunSET2_l_mor, Ext in |- *; simpl in |- *.
unfold FunSET2_l_mor1, FunSET2_l_ob in |- *; simpl in |- *.
intros d1xc1 d2xc2 d3xc3 f1xg1 f2xg2 h.
elim f1xg1; simpl in |- *; unfold DHom in |- *; intros f1 g1.
elim f2xg2; simpl in |- *; unfold DHom in |- *; intros f2 g2; simpl in |- *.

 apply Trans with (((f2 o f1) o h) o FMor G g1 o FMor G g2).
apply Comp_l.
apply FComp.
 apply Trans with ((((f2 o f1) o h) o FMor G g1) o FMor G g2).
apply Ass.
apply Comp_r.
 apply Trans with ((f2 o f1 o h) o FMor G g1).
apply Comp_r.
apply Ass1.
apply Ass1.
Qed.

Lemma Fun2_l_id_law : Fid_law FunSET2_l_map.
Proof.
unfold Fid_law, FunSET2_l_map, FunSET2_l_mor in |- *; simpl in |- *.
unfold Ext, Id_SET in |- *; simpl in |- *.
unfold FunSET2_l_mor1 in |- *; simpl in |- *.
unfold FunSET2_l_ob in |- *; simpl in |- *; intros dxc f.
unfold Id_fun in |- *.
 apply Trans with (Id (OB_l dxc) o f o FMor G (Id (Ob_r dxc))).
apply Ass1.
 apply Trans with (f o FMor G (Id (Ob_r dxc))).
apply Idl.
 apply Trans with (f o Id (G (Ob_r dxc))).
apply Comp_l; apply FId.
apply Idr1.
Qed.

Canonical Structure FunSET2_l := Build_Functor Fun2_l_comp_law Fun2_l_id_law.

End FunSet2_l.

