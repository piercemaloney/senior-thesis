
Require Export Map2.
(* Map2:
Require Export SetoidPROD.

Set Implicit Arguments.
Unset Strict Implicit.

Section fun2_to_map2.

Variable A B C : Setoid.

Definition Map2 := Map A (B ==> C).

Definition Map2_alt := Map (SPROD A B) C.

Variable f : A -> B -> C.

Definition Map2_congl_law :=
  forall (b1 b2 : B) (a : A), b1 =_S b2 -> f a b1 =_S f a b2.

Definition Map2_congr_law :=
  forall (a1 a2 : A) (b : B), a1 =_S a2 -> f a1 b =_S f a2 b.

Definition Map2_cong_law :=
  forall (a1 a2 : A) (b1 b2 : B),
  a1 =_S a2 -> b1 =_S b2 -> f a1 b1 =_S f a2 b2.

Hypothesis pgcl : Map2_congl_law.
Hypothesis pgcr : Map2_congr_law.

Lemma Map2_map_law1 : forall a : A, Map_law (f a).

Canonical Structure Map2_map1 (a : A) := Build_Map (Map2_map_law1 a).

Lemma Map2_map_law2 : Map_law Map2_map1.

Definition Build_Map2 : Map2 := Build_Map Map2_map_law2.

End fun2_to_map2.

Section prop_map2.

Variables (A B C : Setoid) (f : Map2 A B C).

Definition Ap2 (a : A) (b : B) := f a b.

Lemma Prf_map2_congl : Map2_congl_law Ap2.

Lemma Prf_map2_congr : Map2_congr_law Ap2.

Lemma Prf_map2_cong : Map2_cong_law Ap2.

End prop_map2.

Coercion Ap2 : Map2 >-> Funclass.

Identity Coercion Map2_Map : Map2 >-> Map.

Section rew_prop_map2.

Variables (A B C : Setoid) (f : Map2 A B C).

Lemma Map2_l : forall (b1 b2 : B) (a : A), b1 =_S b2 -> f a b1 =_S f a b2.

Lemma Map2_r : forall (a1 a2 : A) (b : B), a1 =_S a2 -> f a1 b =_S f a2 b.

Lemma Map2_lr :
 forall (a1 a2 : A) (b1 b2 : B),
 a1 =_S a2 -> b1 =_S b2 -> f a1 b1 =_S f a2 b2.

End rew_prop_map2. *)

Set Implicit Arguments.
Unset Strict Implicit.

SubClass BinOp (A : Setoid) := Map2 A A A.

Section monoid_laws.

Variables (A : Setoid) (op : BinOp A) (e : A).

Let Ap_op (x y : A) := op x y.

Infix "+_M" := Ap_op (at level 40, left associativity).

Definition Monoid_ass := forall x y z : A, x +_M (y +_M z) =_S x +_M y +_M z.

Definition Monoid_idl := forall x : A, e +_M x =_S x.

Definition Monoid_idr := forall x : A, x =_S x +_M e.

End monoid_laws.

Structure Monoid : Type := 
  {Mcarrier :> Setoid;
   Mop : BinOp Mcarrier;
   Munit : Mcarrier;
   Prf_monoid_ass : Monoid_ass Mop;
   Prf_monoid_idl : Monoid_idl Mop Munit;
   Prf_monoid_idr : Monoid_idr Mop Munit}.

Definition ApMop (m : Monoid) (x y : m) := Mop m x y.

Infix "+_M" := ApMop (at level 40, left associativity).
        
Lemma Mass :
 forall (M : Monoid) (x y z : M), x +_M (y +_M z) =_S x +_M y +_M z.
Proof.
exact Prf_monoid_ass.
Qed.

Lemma Mass1 :
 forall (M : Monoid) (x y z : M), x +_M y +_M z =_S x +_M (y +_M z).
Proof.
intros; apply Sym; apply Mass.
Qed.

Lemma Midl : forall (M : Monoid) (x : M), Munit M +_M x =_S x.
Proof.
exact Prf_monoid_idl.
Qed.

Lemma Midl1 : forall (M : Monoid) (x : M), x =_S Munit M +_M x.
Proof.
intros; apply Sym; apply Midl.
Qed.

Lemma Midr : forall (M : Monoid) (x : M), x =_S x +_M Munit M.
Proof.          
exact Prf_monoid_idr.
Qed.

Lemma Midr1 : forall (M : Monoid) (x : M), x +_M Munit M =_S x.
Proof.          
intros; apply Sym; apply Midr.
Qed.

Section mon_mors.

Variable m1 m2 : Monoid.

Definition MonUnit_law (f : Map m1 m2) := f (Munit m1) =_S Munit m2.

Definition MonOp_law (f : Map m1 m2) :=
  forall a b : m1, f (a +_M b) =_S f a +_M f b.

Structure MonMor : Type := 
  {MonMap :> Map m1 m2;
   Prf_MonUnit_law : MonUnit_law MonMap;
   Prf_MonOp_law : MonOp_law MonMap}.

Lemma MMon_unit : forall f : MonMor, f (Munit m1) =_S Munit m2.
Proof.
exact Prf_MonUnit_law.
Qed.

Lemma MMon_op : forall (f : MonMor) (a b : m1), f (a +_M b) =_S f a +_M f b.
Proof.
exact Prf_MonOp_law.
Qed.

Definition Equal_MonMor (f g : MonMor) := f =_M g.

Lemma Equal_MonMor_equiv : Equivalence Equal_MonMor.
Proof.
apply Build_Equivalence.
unfold Reflexive, Equal_MonMor in |- *; intro f.
unfold Ext in |- *; intros x; apply Refl.
apply Build_Partial_equivalence.
unfold Transitive, Equal_MonMor in |- *; intros f g h H1 H2. 
unfold Ext in |- *; intros x.
apply Trans with (g x).
apply (H1 x).
apply (H2 x).
unfold Symmetric, Equal_MonMor in |- *; intros f g H1.
unfold Ext in |- *; intros x.
apply Sym.
apply (H1 x).
Qed.

Canonical Structure MonMor_setoid : Setoid := Equal_MonMor_equiv.

End mon_mors.

