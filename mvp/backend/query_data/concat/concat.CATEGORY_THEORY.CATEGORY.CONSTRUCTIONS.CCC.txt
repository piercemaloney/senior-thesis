
Require Export Exponents.
(* Exponents:
Require Export Binary_Products.

Set Implicit Arguments.
Unset Strict Implicit.

Section expo_def.

Variables (C : Category) (C1 : HasBinProd C) (a b : C).

 Section expo_laws.

 Variables (Expo : C) (Eval : H_obj_prod C1 Expo a --> b)
   (Op : forall c : C, Map (H_obj_prod C1 c a --> b) (c --> Expo)).

 Definition Lambda_expo (c : C) (f : H_obj_prod C1 c a --> b) := Op c f.

 Definition Beta_rule_law :=
   forall (c : C) (f : H_obj_prod C1 c a --> b),
   Mor_prod C1 (Lambda_expo f) (Id a) o Eval =_S f.

 Definition Eta_rule_law :=
   forall (c : C) (h : c --> Expo),
   Lambda_expo (Mor_prod C1 h (Id a) o Eval) =_S h.

 End expo_laws.

Structure Exponent : Type := 
  {Expo : C;
   Eval : H_obj_prod C1 Expo a --> b;
   Op_lambda : forall c : C, Map (H_obj_prod C1 c a --> b) (c --> Expo);
   Prf_beta_rule : Beta_rule_law Eval Op_lambda;
   Prf_eta_rule : Eta_rule_law Eval Op_lambda}.

Variable e : Exponent.

Definition Lambda (c : C) (f : H_obj_prod C1 c a --> b) := Op_lambda e c f.

End expo_def.

Definition HasExponent (C : Category) (C1 : HasBinProd C) :=
  forall a b : C, Exponent C1 a b.

Section hasexponent_proj.

Variables (C : Category) (C1 : HasBinProd C) (C2 : HasExponent C1) (a b : C).

Definition H_expo := Expo (C2 a b).

Definition H_eval := (Eval (C2 a b)).

Definition H_lambda (c : C) (f : H_obj_prod C1 c a --> b) :=
  Lambda (C2 a b) f.

End hasexponent_proj. *)
Require Export CatProperty.
(* CatProperty:
Require Export Dual.

Set Implicit Arguments.
Unset Strict Implicit.

Section epic_monic_def.

Variables (C : Category) (a b : C).
 
Definition Epic_law (f : a --> b) :=
  forall (c : C) (g h : b --> c), f o g =_S f o h -> g =_S h.

Structure > Epic : Type := 
  {Epic_mor : a --> b; Prf_isEpic :> Epic_law Epic_mor}.

Definition Monic_law (f : b --> a) :=
  forall (c : C) (g h : c --> b), g o f =_S h o f -> g =_S h.

Structure > Monic : Type := 
  {Monic_mor : b --> a; Prf_isMonic :> Monic_law Monic_mor}.

End epic_monic_def.

Section iso_def.

Variable C : Category.

Definition RIso_law (a b : C) (f : a --> b) (f1 : b --> a) := f1 o f =_S Id b.

Variable a b : C.

Definition AreIsos (f : a --> b) (f1 : b --> a) :=
  RIso_law f f1 /\ RIso_law f1 f.

Structure > Iso : Type := 
  {Iso_mor : a --> b; Inv_iso : b --> a; Prf_Iso :> AreIsos Iso_mor Inv_iso}.

Lemma Idl_inv : forall i : Iso, RIso_law (Iso_mor i) (Inv_iso i).

Lemma Idr_inv : forall i : Iso, RIso_law (Inv_iso i) (Iso_mor i).

Lemma Inv_iso_unique :
 forall f g : Iso, Iso_mor f =_S Iso_mor g -> Inv_iso f =_S Inv_iso g.

Lemma RightInv_epic :
 forall (h : a --> b) (h1 : b --> a), RIso_law h h1 -> Epic_law h.

End iso_def.

Coercion RightInv_epic : RIso_law >-> Epic_law.

Section initial_def.

Variable C : Category.

Definition IsInitial (a : C) (h : forall b : C, a --> b) :=
  forall (b : C) (f : a --> b), f =_S h b.
  
Structure > Initial : Type := 
  {Initial_ob : C;
   MorI : forall b : C, Initial_ob --> b;
   Prf_isInitial :> IsInitial MorI}.

Definition At_most_1mor (a b : C) := forall f g : a --> b, f =_S g.

Lemma UniqueI : forall (i : Initial) (b : C), At_most_1mor (Initial_ob i) b.

Lemma I_unic : forall i1 i2 : Initial, Iso (Initial_ob i1) (Initial_ob i2).

End initial_def.

Section terminal_def.

Variable C : Category.

Definition IsTerminal (b : C) (h : forall a : C, a --> b) :=
  forall (a : C) (f : a --> b), f =_S h a. 

Structure > Terminal : Type := 
  {Terminal_ob : C;
   MorT : forall a : C, a --> Terminal_ob;
   Prf_isTerminal :> IsTerminal MorT}.

Lemma UniqueT : forall (t : Terminal) (a : C), At_most_1mor a (Terminal_ob t).

End terminal_def.

Lemma Initial_dual :
 forall (C : Category) (a : C) (h : forall b : C, a --> b),
 IsInitial h -> IsTerminal (C:=Dual C) h.

Coercion Initial_dual : IsInitial >-> IsTerminal.

Definition IsTerminal' (C : Category) (b : C) (h : forall a : C, a --> b) :=
  IsInitial (C:=Dual C) h. *)

Set Implicit Arguments.
Unset Strict Implicit.

Structure IsCartesian (C : Category) : Type := 
  {Car_terminal :> Terminal C; Car_BP :> HasBinProd C}.

Structure Cartesian : Type := 
  {Car_Cat :> Category; Prf_isCartesian :> IsCartesian Car_Cat}.

Structure IsCCC (C : Category) : Type := 
  {CCC_isCar :> IsCartesian C; CCC_exponent :> HasExponent CCC_isCar}.

Structure CCC : Type :=  {CCC_Car :> Cartesian; Prf_isCCC :> IsCCC CCC_Car}.

