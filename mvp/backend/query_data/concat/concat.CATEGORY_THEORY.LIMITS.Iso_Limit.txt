
Require Export SET.
(* SET:
Require Export Category.

Set Implicit Arguments.
Unset Strict Implicit.

Lemma Comp_map_congl : Congl_law Comp_map.

Lemma Comp_map_congr : Congr_law Comp_map.

Definition Comp_SET := Build_Comp Comp_map_congl Comp_map_congr.

Lemma Assoc_SET : Assoc_law Comp_SET.

Definition Id_SET := Id_map.
 
Lemma Idl_SET : Idl_law Comp_SET Id_SET.

Lemma Idr_SET : Idr_law Comp_SET Id_SET.

Canonical Structure SET := Build_Category Assoc_SET Idl_SET Idr_SET. *)
Require Export Limit.
(* Limit:
Require Export Const.
Require Export CoUniversalArrow.
Require Export Ntransformation.

Set Implicit Arguments.
Unset Strict Implicit.

Section def_cone.

Variables (J C : Category) (c : C) (F : Functor J C).

SubClass Cone := NT (Const J c) F.

Definition Cones := NT_setoid (Const J c) F.

 Section cone_nt.

 Variable T : forall a : J, c --> F a.

 Definition Cone_law :=
   forall (i j : J) (g : i --> j), T j =_S T i o FMor F g.

 Lemma Prf_Cone_nt_law : Cone_law -> NT_law (F:=Const J c) T.
 
 Coercion Prf_Cone_nt_law : Cone_law >-> NT_law.

 Variable p : Cone_law.

 Canonical Structure Build_Cone : Cone := Build_NT (Prf_Cone_nt_law p).

 End cone_nt.

Coercion Build_Cone : Cone_law >-> Cone.
  
Lemma Eq_cone : forall tau : Cone, Cone_law (ApNT tau).

Lemma EqC :
 forall (tau : Cone) (i j : J) (g : i --> j), tau j =_S tau i o FMor F g.

Lemma EqC1 :
 forall (tau : Cone) (i j : J) (g : i --> j), tau i o FMor F g =_S tau j.

End def_cone.
		
Section limit_def.

Variables (J C : Category) (F : Functor J C).

 Section islimit_def. 
 
 Variables (lim : C) (nu : Cone lim F).

  Section limit_laws.

  Variable l_diese : forall c : C, Cone c F -> (c --> lim).  

  Definition Limit_eq (c : C) (tau : Cone c F) (g : c --> lim) :=
    forall i : J, g o nu i =_S tau i.
                      
  Definition Limit_law1 :=
    forall (c : C) (tau : Cone c F), Limit_eq tau (l_diese tau).

  Definition Limit_law2 :=
    forall (c : C) (tau : Cone c F) (g : c --> lim),
    Limit_eq tau g -> g =_S l_diese tau.
  
  End limit_laws.

 Structure IsLimit : Type := 
   {Lim_diese : forall c : C, Cone c F -> (c --> lim);
    Prf_limit1 : Limit_law1 Lim_diese;
    Prf_limit2 : Limit_law2 Lim_diese}.

 Variable l : IsLimit.

 Lemma Ldiese_map :
  forall (c : C) (tau1 tau2 : Cone c F),
  tau1 =_NT tau2 -> Lim_diese l tau1 =_S Lim_diese l tau2.
 
 End islimit_def.

 Structure > Limit : Type := 
   {Lim : C;
    Limiting_cone : Cone Lim F;
    Prf_Islimit :> IsLimit Limiting_cone}.

End limit_def.

Definition Complete (C : Category) :=
  forall (J : Category) (F : Functor J C), Limit F. *)
Require Export Map0_dup1.
(* Map0_dup1:
Require Export Setoid.
Require Export Setoid_dup2.

Set Implicit Arguments.
Unset Strict Implicit.

Section maps0''.

Variables (A : Setoid) (B : Setoid'').

Definition Map_law0'' (f : A -> B) :=
  forall x y : A, x =_S y -> f x =_S'' f y.

Structure > Map0'' : Type :=  {Ap0'' :> A -> B; Pres0'' :> Map_law0'' Ap0''}.

End maps0''.

Section maps''0.

Variables (A : Setoid'') (B : Setoid).

Definition Map_law''0 (f : A -> B) :=
  forall x y : A, x =_S'' y -> f x =_S f y.

Structure > Map''0 : Type :=  {Ap''0 :> A -> B; Pres''0 :> Map_law''0 Ap''0}.

End maps''0.

Section bij0''.

Variables (A : Setoid) (B : Setoid'').

Definition AreBij0'' (f : Map0'' A B) (g : Map''0 B A) :=
  (forall a : A, g (f a) =_S a) /\ (forall b : B, f (g b) =_S'' b).

End bij0''. *)

Set Implicit Arguments.
Unset Strict Implicit.

Section iso_cone.

Variables (J C : Category) (F : Functor J C) (l : Limit F) (c : C).

Definition PhiCone_fun (tau : Cones c F) := Lim_diese l tau.

Lemma PhiCone_map_law : Map_law''0 PhiCone_fun.
Proof.
unfold Map_law''0, PhiCone_fun in |- *; simpl in |- *.
intros T1 T2 H.
apply (Ldiese_map l); trivial.
Qed.

Canonical Structure PhiCone_map := Build_Map''0 PhiCone_map_law.

 Section phicone_1_fun_def.

 Variable f : c --> Lim l.

 Definition PhiCone_1_fun_tau (i : J) := f o Limiting_cone l i.

 Lemma PhiCone_1_fun_cone_law : Cone_law PhiCone_1_fun_tau.
 Proof.
 unfold Cone_law, PhiCone_1_fun_tau in |- *; simpl in |- *.
 intros i j g.
  apply Trans with (f o Limiting_cone l i o FMor F g).
 apply Comp_l; apply (EqC (Limiting_cone l) g).
 apply Ass.
 Qed.

 Canonical Structure PhiCone_1_fun : Cones c F := PhiCone_1_fun_cone_law.

 End phicone_1_fun_def. 

Lemma PhiCone_1_map_law : Map_law0'' PhiCone_1_fun.
Proof.
unfold Map_law0'', PhiCone_1_fun in |- *. 
intros f g H; simpl in |- *.
unfold Equal_NT in |- *; simpl in |- *.
unfold PhiCone_1_fun_tau in |- *; intro i.
apply Comp_r; trivial.
Qed.

Canonical Structure PhiCone_1_map : Map0'' (c --> Lim l) (Cones c F) :=
  PhiCone_1_map_law.

Lemma Lim_areIso : AreBij0'' PhiCone_1_map PhiCone_map.
Proof.
unfold AreBij0'' in |- *; split.
intro f; simpl in |- *; unfold PhiCone_fun in |- *.
apply Sym; apply (Prf_limit2 l).
unfold Limit_eq, PhiCone_1_fun in |- *; simpl in |- *.
intro i; apply Refl.
intro tau; simpl in |- *; unfold Equal_NT in |- *.
unfold PhiCone_1_fun, PhiCone_fun in |- *; simpl in |- *.
intro i; unfold PhiCone_1_fun_tau in |- *.
apply (Prf_limit1 l tau i).
Qed.

End iso_cone.

