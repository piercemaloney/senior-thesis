
Require Export Cartesian1.
(* Cartesian1:
Require Export Diagonal.
Require Export CCC.
Require Export Terminal1.

Set Implicit Arguments.
Unset Strict Implicit.

Section diag_hasprod1.

Variable C : Category.

SubClass HasBinProd1 := RightAdj (Diag C).

Structure IsCartesian1 : Type := 
  {Car_terminal1 :> Terminal1 C; Car_BP1 :> HasBinProd1}.

Variable H : HasBinProd1.

 Section diag_prod1.

 Variable a b : C.

 Let ua' := CoUnit H (Build_POb a b).

 Definition Obj_prod1 := CoUA_ob ua'.

 Definition Proj1_prod1 := Hom_l (CoUA_mor ua').

 Definition Proj2_prod1 := Hom_r (CoUA_mor ua').

  Section together1_def.

  Variable c : C.

  Definition Together1 (f : c --> a) (g : c --> b) :=
    CoUA_diese ua' (Build_Pmor (u:=Build_POb c c) (t:=Build_POb a b) f g).

  Lemma Together1_l : Map2_congl_law Together1.
 
  Lemma Together1_r : Map2_congr_law Together1.

  Definition Op_together1 := Build_Map2 Together1_l Together1_r.

  End together1_def.

 Lemma Prf_eq1_prod1 : Eq1_prod_law Proj1_prod1 Op_together1. 

 Lemma Prf_eq2_prod1 : Eq2_prod_law Proj2_prod1 Op_together1. 

 Lemma Prf_unique_together1 :
  Unique_together_law Proj1_prod1 Proj2_prod1 Op_together1.

 End diag_prod1.

 Definition BP1_to_BP : HasBinProd C :=
   fun a b : C =>
   Build_BinProd (Prf_eq1_prod1 (a:=a) (b:=b)) (Prf_eq2_prod1 (a:=a) (b:=b))
     (Prf_unique_together1 (a:=a) (b:=b)).

End diag_hasprod1.

Coercion BP1_to_BP : HasBinProd1 >-> HasBinProd.

Coercion Car1_to_Car (C : Category) (H : IsCartesian1 C) :=
  Build_IsCartesian H H. *)
Require Export CCC.
(* CCC:
Require Export Exponents.
Require Export CatProperty.

Set Implicit Arguments.
Unset Strict Implicit.

Structure IsCartesian (C : Category) : Type := 
  {Car_terminal :> Terminal C; Car_BP :> HasBinProd C}.

Structure Cartesian : Type := 
  {Car_Cat :> Category; Prf_isCartesian :> IsCartesian Car_Cat}.

Structure IsCCC (C : Category) : Type := 
  {CCC_isCar :> IsCartesian C; CCC_exponent :> HasExponent CCC_isCar}.

Structure CCC : Type :=  {CCC_Car :> Cartesian; Prf_isCCC :> IsCCC CCC_Car}. *)
Require Export FunProd.
(* FunProd:
Require Export Binary_Products.
Require Export Functor.

Set Implicit Arguments.
Unset Strict Implicit.

Section fun_prod.

Variables (C : Category) (C1 : HasBinProd C) (a : C).

Definition Fun_prod_ob (c : C) := H_obj_prod C1 c a.

 Section fun_prod_map_def.

 Variable c1 c2 : C.

 Definition Fun_prod_mor (f : c1 --> c2) := Mor_prod C1 f (Id a).

 Lemma Fun_prod_map_law : Map_law Fun_prod_mor.

 Canonical Structure Fun_prod_map :
   Map (c1 --> c2) (Fun_prod_ob c1 --> Fun_prod_ob c2) := Fun_prod_map_law.

 End fun_prod_map_def.

Lemma Fun_prod_comp_law : Fcomp_law Fun_prod_map.

Lemma Fun_prod_id_law : Fid_law Fun_prod_map.

Canonical Structure Fun_prod :=
  Build_Functor Fun_prod_comp_law Fun_prod_id_law.

End fun_prod. *)

Set Implicit Arguments.
Unset Strict Implicit.

Section funprod_hasexpo.

Variable C : Category.
Variable H : HasBinProd C.

Definition HasExponent1 := forall a : C, RightAdj (Fun_prod H a).

Variable H1 : HasExponent1.

 Section funprod_expo.

 Variable a b : C.

 Let ua' := CoUnit (H1 a) b.

 Definition Expo1 := CoUA_ob ua'.

 Definition Eval1 := CoUA_mor ua'.

  Section lambda1_def.

  Variable c : C.

  Definition Lambda1_mor (f : H_obj_prod H c a --> b) := CoUA_diese ua' f.

  Lemma Lambda1_map_law : Map_law Lambda1_mor.
  Proof.
  unfold Map_law in |- *; intros f g H'.
  unfold Lambda1_mor in |- *.
  apply (Codiese_map ua' (x:=f) (y:=g)).
  trivial.
  Qed.

  Canonical Structure Lambda1 := Build_Map Lambda1_map_law.

  End lambda1_def.

 Lemma Prf_beta_rule1 : Beta_rule_law Eval1 Lambda1.
 Proof.
 unfold Beta_rule_law in |- *; intros c f.
 unfold Lambda1, Eval1 in |- *.
 apply (Prf_isCoUA_law1 ua' f).
 Qed.

 Lemma Prf_eta_rule1 : Eta_rule_law Eval1 Lambda1.
 Proof.
 unfold Eta_rule_law in |- *; intros c h; simpl in |- *.
 unfold Lambda1_mor in |- *.
 apply Sym.
 apply (Prf_isCoUA_law2 ua' (a':=c) (f:=Mor_prod H h (Id a) o Eval1) (g:=h)).
 unfold CoUA_eq in |- *.
 apply Refl.
 Qed.

 End funprod_expo.

 Definition HasExp1_to_HasExp : HasExponent H :=
   fun a b : C =>
   Build_Exponent (Prf_beta_rule1 (a:=a) (b:=b))
     (Prf_eta_rule1 (a:=a) (b:=b)).

End funprod_hasexpo.

Coercion HasExp1_to_HasExp : HasExponent1 >-> HasExponent.

Structure IsCCC1 (C : Category) : Type := 
  {CCC1_Car :> IsCartesian1 C; CCC1_exponent :> HasExponent1 CCC1_Car}.

Coercion CCC1_to_CCC (C : Category) (H : IsCCC1 C) :=
  Build_IsCCC (CCC_isCar:=H) H.
