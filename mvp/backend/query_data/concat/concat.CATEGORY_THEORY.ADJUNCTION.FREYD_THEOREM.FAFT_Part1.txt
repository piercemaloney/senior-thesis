
Require Export Limit.
(* Limit:
Require Export Const.
Require Export CoUniversalArrow.
Require Export Ntransformation.

Set Implicit Arguments.
Unset Strict Implicit.

Section def_cone.

Variables (J C : Category) (c : C) (F : Functor J C).

SubClass Cone := NT (Const J c) F.

Definition Cones := NT_setoid (Const J c) F.

 Section cone_nt.

 Variable T : forall a : J, c --> F a.

 Definition Cone_law :=
   forall (i j : J) (g : i --> j), T j =_S T i o FMor F g.

 Lemma Prf_Cone_nt_law : Cone_law -> NT_law (F:=Const J c) T.
 
 Coercion Prf_Cone_nt_law : Cone_law >-> NT_law.

 Variable p : Cone_law.

 Canonical Structure Build_Cone : Cone := Build_NT (Prf_Cone_nt_law p).

 End cone_nt.

Coercion Build_Cone : Cone_law >-> Cone.
  
Lemma Eq_cone : forall tau : Cone, Cone_law (ApNT tau).

Lemma EqC :
 forall (tau : Cone) (i j : J) (g : i --> j), tau j =_S tau i o FMor F g.

Lemma EqC1 :
 forall (tau : Cone) (i j : J) (g : i --> j), tau i o FMor F g =_S tau j.

End def_cone.
		
Section limit_def.

Variables (J C : Category) (F : Functor J C).

 Section islimit_def. 
 
 Variables (lim : C) (nu : Cone lim F).

  Section limit_laws.

  Variable l_diese : forall c : C, Cone c F -> (c --> lim).  

  Definition Limit_eq (c : C) (tau : Cone c F) (g : c --> lim) :=
    forall i : J, g o nu i =_S tau i.
                      
  Definition Limit_law1 :=
    forall (c : C) (tau : Cone c F), Limit_eq tau (l_diese tau).

  Definition Limit_law2 :=
    forall (c : C) (tau : Cone c F) (g : c --> lim),
    Limit_eq tau g -> g =_S l_diese tau.
  
  End limit_laws.

 Structure IsLimit : Type := 
   {Lim_diese : forall c : C, Cone c F -> (c --> lim);
    Prf_limit1 : Limit_law1 Lim_diese;
    Prf_limit2 : Limit_law2 Lim_diese}.

 Variable l : IsLimit.

 Lemma Ldiese_map :
  forall (c : C) (tau1 tau2 : Cone c F),
  tau1 =_NT tau2 -> Lim_diese l tau1 =_S Lim_diese l tau2.
 
 End islimit_def.

 Structure > Limit : Type := 
   {Lim : C;
    Limiting_cone : Cone Lim F;
    Prf_Islimit :> IsLimit Limiting_cone}.

End limit_def.

Definition Complete (C : Category) :=
  forall (J : Category) (F : Functor J C), Limit F. *)
Require Export Adj_UA.
(* Adj_UA:
Require Export CoUniversalArrow.
Require Export Adjunction.

Set Implicit Arguments.
Unset Strict Implicit.

Section adj_to_ua.

Variables (C D : Category) (F : Functor D C) (G : Functor C D) (ad : Adj F G).
Variable d : D.

Definition Unit_ob := F d.

Definition Unit_arrow := ApAphi ad (Id (F d)).
 
Definition Unit_arrow_diese (c : C) (f : d --> G c) := ApAphi_inv ad f.

Lemma Unit_UAlaw1 : UA_law1 Unit_arrow Unit_arrow_diese.

Lemma Unit_UAlaw2 : UA_law2 Unit_arrow Unit_arrow_diese.

Canonical Structure Unit' := Build_IsUA Unit_UAlaw1 Unit_UAlaw2.

Canonical Structure Unit := Build_UA Unit'.

Variable c : C.

Definition CoUnit_ob := G c.

Definition CoUnit_arrow := ApAphi_inv ad (Id (G c)).

Definition CoUnit_arrow_diese (d : D) (f : F d --> c) := ApAphi ad f.
                        
Lemma CoUnit_coUAlaw1 : CoUA_law1 CoUnit_arrow CoUnit_arrow_diese.

Lemma CoUnit_coUAlaw2 : CoUA_law2 CoUnit_arrow CoUnit_arrow_diese.

Canonical Structure CoUnit' := Build_IsCoUA CoUnit_coUAlaw1 CoUnit_coUAlaw2.

Canonical Structure CoUnit := Build_CoUA CoUnit'.

End adj_to_ua. *)
Require Export Single.
(* Single:
Require Export Setoid.
Require Export BasicTypes.

Set Implicit Arguments.
Unset Strict Implicit.

Definition Equal_Single (a b : UnitType) := True.

Lemma Equal_Single_equiv : Equivalence Equal_Single.

Canonical Structure Single : Setoid := Equal_Single_equiv.

Hint Resolve Elt. *)
Require Export FAFT_SSC2.
(* FAFT_SSC2:
Require Export Functor.

Set Implicit Arguments.
Unset Strict Implicit.

Section ssc2_def.

Variables (A X : Category) (G : Functor A X) (x : X).

Structure Cond2 (I : Type) (l : I -> A) (f : forall i : I, x --> G (l i))
  (a : A) (h : x --> G a) : Type := 
  {Cond2_i : I;
   Cond2_t : l Cond2_i --> a;
   Prf_Cond2_law : h =_S f Cond2_i o FMor G Cond2_t}.

Structure SSC2 : Type := 
  {SSC2_I : Type;
   SSC2_a : SSC2_I -> A;
   SSC2_f : forall i : SSC2_I, x --> G (SSC2_a i);
   SSC2_p : forall (a : A) (h : x --> G a), Cond2 SSC2_f h}.

Variables (s : SSC2) (a : A) (h : x --> G a).

Definition SSC2_i := Cond2_i (SSC2_p s h).

Definition SSC2_t := Cond2_t (SSC2_p s h).

Lemma Prf_SSC2_law : h =_S SSC2_f SSC2_i o FMor G SSC2_t.

End ssc2_def. *)

Set Implicit Arguments.
Unset Strict Implicit.

Section freyd_th_1.

Variables (A X : Category) (G : Functor A X) (A_c : Complete A)
  (la : LeftAdj G).

Variable x : X.

Let I := UnitType.

Let a (i : I) := match i with
                 | Elt => Adjoint la x
                 end.

Let f (i : I) :=
  match i as i' return (Carrier (x --> G (a i'))) with
  | Elt => UA_mor (Unit la x)
  end.

 Section cd2.
 
 Variables (r : A) (h : x --> G r).
 
 Let i := Elt.

 Let t : a i --> r := ApAphi_inv la h.

 Lemma FT_cd2_law : h =_S f i o FMor G t.
 Proof.
  apply Trans with (ApAphi la (Id (Adjoint la x) o t)).
  apply Trans with (ApAphi la t).
 apply Sym.
 exact (Idl_inv (NTa_areIso la (Build_POb1 x r)) h).
 apply AphiPres.
 apply Idl1.
 apply (Adj_eq3 la t (Id (Adjoint la x))).
 Defined.

 Canonical Structure FT_cd2 := Build_Cond2 (I:=I) FT_cd2_law.
 
 End cd2.

Lemma AFT2 : SSC2 G x.
Proof.
exact (Build_SSC2 FT_cd2).
Qed.

End freyd_th_1.

