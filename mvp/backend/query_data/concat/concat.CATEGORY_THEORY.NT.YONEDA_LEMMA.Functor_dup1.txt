
Require Export Category.
(* Category:
Require Export Map2.

Set Implicit Arguments.
Unset Strict Implicit.

Section cat.

Variables (Ob : Type) (Hom : Ob -> Ob -> Setoid).

Infix "-->" := Hom (at level 95, right associativity).

Variable Op_comp : forall a b c : Ob, Map2 (a --> b) (b --> c) (a --> c).

Definition Cat_comp (a b c : Ob) (f : a --> b) (g : b --> c) :=
  Op_comp a b c f g.

Infix "o" := Cat_comp (at level 20, right associativity).

Definition Assoc_law :=
  forall (a b c d : Ob) (f : a --> b) (g : b --> c) (h : c --> d),
  f o g o h =_S (f o g) o h.

Variable Id : forall a : Ob, a --> a.

Definition Idl_law := forall (a b : Ob) (f : a --> b), Id _ o f =_S f.

Definition Idr_law := forall (a b : Ob) (f : b --> a), f =_S f o Id _.

End cat.

Structure Category : Type := 
  {Ob :> Type;
   Hom : Ob -> Ob -> Setoid;
   Op_comp : forall a b c : Ob, Map2 (Hom a b) (Hom b c) (Hom a c);
   Id : forall a : Ob, Hom a a;
   Prf_ass : Assoc_law Op_comp;
   Prf_idl : Idl_law Op_comp Id;
   Prf_idr : Idr_law Op_comp Id}.

Definition Comp (C : Category) := Cat_comp (Op_comp (c:=C)).

Infix "-->" := Hom (at level 95, right associativity).
Infix "o" := Comp (at level 20, right associativity).

Lemma Ass :
 forall (C : Category) (a b c d : C) (f : a --> b) 
   (g : b --> c) (h : c --> d), f o g o h =_S (f o g) o h.

Lemma Ass1 :
 forall (C : Category) (a b c d : C) (f : a --> b) 
   (g : b --> c) (h : c --> d), (f o g) o h =_S f o g o h.

Lemma Idl : forall (C : Category) (a b : C) (f : a --> b), Id _ o f =_S f.

Lemma Idl1 : forall (C : Category) (a b : C) (f : a --> b), f =_S Id _ o f.

Lemma Idr : forall (C : Category) (a b : C) (f : b --> a), f =_S f o Id _.

Lemma Idr1 : forall (C : Category) (a b : C) (f : a --> b), f o Id _ =_S f.

Lemma Idrl :
 forall (C : Category) (a b : C) (f : a --> b), f o Id _ =_S Id _ o f.

Lemma Idlr :
 forall (C : Category) (a b : C) (f : a --> b), Id _ o f =_S f o Id _.

Section composition_to_operator.

Variables (A : Type) (H : A -> A -> Setoid)
  (Cfun : forall a b c : A, H a b -> H b c -> H a c).

Definition Congl_law :=
  forall (a b c : A) (f g : H b c) (h : H a b),
  f =_S g -> Cfun h f =_S Cfun h g. 

Definition Congr_law :=
  forall (a b c : A) (f g : H a b) (h : H b c),
  f =_S g -> Cfun f h =_S Cfun g h. 

Definition Cong_law :=
  forall (a b c : A) (f f' : H a b) (g g' : H b c),
  f =_S f' -> g =_S g' -> Cfun f g =_S Cfun f' g'. 

Hypothesis pcgl : Congl_law.
Hypothesis pcgr : Congr_law.

Variable a b c : A.

Definition Build_Comp :=
  Build_Map2 (pcgl (a:=a) (b:=b) (c:=c)) (pcgr (a:=a) (b:=b) (c:=c)).

End composition_to_operator.

Section cat_cong.

Variable C : Category.

Lemma Comp_l :
 forall (a b c : C) (f g : b --> c) (h : a --> b), f =_S g -> h o f =_S h o g. 

Lemma Comp_r :
 forall (a b c : C) (f g : a --> b) (h : b --> c), f =_S g -> f o h =_S g o h. 

Lemma Comp_lr :
 forall (a b c : C) (f f' : a --> b) (g g' : b --> c),
 f =_S f' -> g =_S g' -> f o g =_S f' o g'. 

End cat_cong. *)
Require Export Category_dup2.
(* Category_dup2:
Require Export Setoid_dup2.

Set Implicit Arguments.
Unset Strict Implicit.

Section composition_to_operator''.

Variables (A : Type) (H : A -> A -> Setoid'')
  (Cfun : forall a b c : A, H a b -> H b c -> H a c).

Definition Congl_law'' :=
  forall (a b c : A) (f g : H b c) (h : H a b),
  f =_S'' g -> Cfun h f =_S'' Cfun h g. 

Definition Congr_law'' :=
  forall (a b c : A) (f g : H a b) (h : H b c),
  f =_S'' g -> Cfun f h =_S'' Cfun g h. 

Definition Cong_law'' :=
  forall (a b c : A) (f f' : H a b) (g g' : H b c),
  f =_S'' f' -> g =_S'' g' -> Cfun f g =_S'' Cfun f' g'. 

Hypothesis pcgl : Congl_law''.
Hypothesis pcgr : Congr_law''.

Variable a b c : A.

Definition Build_Comp'' :=
  Build_Map2'' (pcgl (a:=a) (b:=b) (c:=c)) (pcgr (a:=a) (b:=b) (c:=c)).

End composition_to_operator''.

Section cat''.

Variables (Ob'' : Type) (Hom'' : Ob'' -> Ob'' -> Setoid'').

Variable
  Op_comp'' : forall a b c : Ob'', Map2'' (Hom'' a b) (Hom'' b c) (Hom'' a c).

Definition Cat_comp'' (a b c : Ob'') (f : Hom'' a b) 
  (g : Hom'' b c) := Op_comp'' a b c f g.

Definition Assoc_law'' :=
  forall (a b c d : Ob'') (f : Hom'' a b) (g : Hom'' b c) (h : Hom'' c d),
  Cat_comp'' f (Cat_comp'' g h) =_S'' Cat_comp'' (Cat_comp'' f g) h.

Variable Id'' : forall a : Ob'', Hom'' a a.

Definition Idl_law'' :=
  forall (a b : Ob'') (f : Hom'' a b), Cat_comp'' (Id'' _) f =_S'' f.

Definition Idr_law'' :=
  forall (a b : Ob'') (f : Hom'' b a), f =_S'' Cat_comp'' f (Id'' _).

End cat''.

Structure Category'' : Type := 
  {Ob'' :> Type;
   Hom'' : Ob'' -> Ob'' -> Setoid'';
   Op_comp'' :
    forall a b c : Ob'', Map2'' (Hom'' a b) (Hom'' b c) (Hom'' a c);
   Id'' : forall a : Ob'', Hom'' a a;
   Prf_ass'' : Assoc_law'' Op_comp'';
   Prf_idl'' : Idl_law'' Op_comp'' Id'';
   Prf_idr'' : Idr_law'' Op_comp'' Id''}.

Definition Comp'' (C : Category'') := Cat_comp'' (Op_comp'' (c:=C)).

Infix "o''" := Comp'' (at level 20, right associativity). *)
Require Export Map0_dup1.
(* Map0_dup1:
Require Export Setoid.
Require Export Setoid_dup2.

Set Implicit Arguments.
Unset Strict Implicit.

Section maps0''.

Variables (A : Setoid) (B : Setoid'').

Definition Map_law0'' (f : A -> B) :=
  forall x y : A, x =_S y -> f x =_S'' f y.

Structure > Map0'' : Type :=  {Ap0'' :> A -> B; Pres0'' :> Map_law0'' Ap0''}.

End maps0''.

Section maps''0.

Variables (A : Setoid'') (B : Setoid).

Definition Map_law''0 (f : A -> B) :=
  forall x y : A, x =_S'' y -> f x =_S f y.

Structure > Map''0 : Type :=  {Ap''0 :> A -> B; Pres''0 :> Map_law''0 Ap''0}.

End maps''0.

Section bij0''.

Variables (A : Setoid) (B : Setoid'').

Definition AreBij0'' (f : Map0'' A B) (g : Map''0 B A) :=
  (forall a : A, g (f a) =_S a) /\ (forall b : B, f (g b) =_S'' b).

End bij0''. *)
Require Export Setoid_dup2.
(* Setoid_dup2:
Require Export Relations.

Set Implicit Arguments.
Unset Strict Implicit.

Structure > Setoid'' : Type := 
  {Carrier'' :> Type;
   Equal'' : Relation Carrier'';
   Prf_equiv'' :> Equivalence Equal''}.

Infix "=_S''" := Equal'' (at level 70).

Lemma Refl'' : forall (S : Setoid'') (x : S), x =_S'' x.

Lemma Sym'' : forall (S : Setoid'') (x y : S), x =_S'' y -> y =_S'' x.

Lemma Trans'' :
 forall (S : Setoid'') (x y z : S), x =_S'' y -> y =_S'' z -> x =_S'' z.

Section maps''.

Variable A B : Setoid''.

Definition Map_law'' (f : A -> B) :=
  forall x y : A, x =_S'' y -> f x =_S'' f y.

Structure > Map'' : Type :=  {Ap'' :> A -> B; Pres'' :> Map_law'' Ap''}.

Lemma Pres1'' : forall (m : Map'') (x y : A), x =_S'' y -> m x =_S'' m y.

Definition Ext'' (f g : Map'') := forall x : A, f x =_S'' g x.

Lemma Ext_equiv'' : Equivalence Ext''.

Canonical Structure Map_setoid'' : Setoid'' := Ext_equiv''.

End maps''.

Section fun2_to_map2''.

Variable A B C : Setoid''.

Definition Map2'' := Map'' A (Map_setoid'' B C).

Variable f : A -> B -> C.

Definition Map2_congl_law'' :=
  forall (b1 b2 : B) (a : A), b1 =_S'' b2 -> f a b1 =_S'' f a b2.

Definition Map2_congr_law'' :=
  forall (a1 a2 : A) (b : B), a1 =_S'' a2 -> f a1 b =_S'' f a2 b.

Definition Map2_cong_law'' :=
  forall (a1 a2 : A) (b1 b2 : B),
  a1 =_S'' a2 -> b1 =_S'' b2 -> f a1 b1 =_S'' f a2 b2.

Hypothesis pgcl : Map2_congl_law''.
Hypothesis pgcr : Map2_congr_law''.

Lemma Map2_map_law1'' : forall a : A, Map_law'' (f a).

Canonical Structure Map2_map1'' (a : A) := Build_Map'' (Map2_map_law1'' a).

Lemma Map2_map_law2'' : Map_law'' Map2_map1''.

Definition Build_Map2'' : Map2'' := Build_Map'' Map2_map_law2''.

End fun2_to_map2''.

Section prop_map2''.

Variables (A B C : Setoid'') (f : Map2'' A B C).

Definition Ap2'' (a : A) (b : B) := f a b.

Lemma Prf_map2_congl'' : Map2_congl_law'' Ap2''.

Lemma Prf_map2_congr'' : Map2_congr_law'' Ap2''.

Lemma Prf_map2_cong'' : Map2_cong_law'' Ap2''.

End prop_map2''.

Coercion Ap2'' : Map2'' >-> Funclass.

Identity Coercion Map2''_Map'' : Map2'' >-> Map''. *)

Set Implicit Arguments.
Unset Strict Implicit.

Section funct_def0''.

Variables (C : Category) (D : Category'').

 Section funct_laws0''.

 Variables (FOb0'' : C -> D)
   (FMap0'' : forall a b : C, Map0'' (a --> b) (Hom'' (FOb0'' a) (FOb0'' b))).

 Definition Fcomp_law0'' :=
   forall (a b c : C) (f : a --> b) (g : b --> c),
   FMap0'' a c (f o g) =_S'' FMap0'' a b f o'' FMap0'' b c g.

 Definition Fid_law0'' :=
   forall a : C, FMap0'' a a (Id a) =_S'' Id'' (FOb0'' a).

 End funct_laws0''.

Structure Functor0'' : Type := 
  {FOb0'' :> C -> D;
   FMap0'' : forall a b : C, Map0'' (a --> b) (Hom'' (FOb0'' a) (FOb0'' b));
   Prf_Fcomp_law0'' : Fcomp_law0'' FMap0'';
   Prf_Fid_law0'' : Fid_law0'' FMap0''}.

Definition FMor0'' (F : Functor0'') (a b : C) (f : a --> b) :=
  FMap0'' F a b f.

End funct_def0''.

Section functor_prop0''.

Variables (C : Category) (D : Category''). 

Definition Faithful_law0'' (F : Functor0'' C D) :=
  forall (a b : C) (f g : a --> b), FMor0'' F f =_S'' FMor0'' F g -> f =_S g.

Structure > Faithful0'' : Type := 
  {Faithful_functor0'' :> Functor0'' C D;
   Prf_isFaithful0'' :> Faithful_law0'' Faithful_functor0''}.

Definition Full_law0'' (F : Functor0'' C D)
  (H : forall a b : C, Hom'' (F a) (F b) -> (a --> b)) :=
  forall (a b : C) (h : Hom'' (F a) (F b)), h =_S'' FMor0'' F (H a b h).

Structure > Full0'' : Type := 
  {Full_functor0'' :> Functor0'' C D;
   Full_mor0'' :
    forall a b : C,
    Hom'' (Full_functor0'' a) (Full_functor0'' b) -> (a --> b);
   Prf_isFull0'' :> Full_law0'' Full_mor0''}.

End functor_prop0''.
