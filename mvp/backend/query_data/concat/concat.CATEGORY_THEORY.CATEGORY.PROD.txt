
Require Export Category. 
(* Category:
Require Export Map2.

Set Implicit Arguments.
Unset Strict Implicit.

Section cat.

Variables (Ob : Type) (Hom : Ob -> Ob -> Setoid).

Infix "-->" := Hom (at level 95, right associativity).

Variable Op_comp : forall a b c : Ob, Map2 (a --> b) (b --> c) (a --> c).

Definition Cat_comp (a b c : Ob) (f : a --> b) (g : b --> c) :=
  Op_comp a b c f g.

Infix "o" := Cat_comp (at level 20, right associativity).

Definition Assoc_law :=
  forall (a b c d : Ob) (f : a --> b) (g : b --> c) (h : c --> d),
  f o g o h =_S (f o g) o h.

Variable Id : forall a : Ob, a --> a.

Definition Idl_law := forall (a b : Ob) (f : a --> b), Id _ o f =_S f.

Definition Idr_law := forall (a b : Ob) (f : b --> a), f =_S f o Id _.

End cat.

Structure Category : Type := 
  {Ob :> Type;
   Hom : Ob -> Ob -> Setoid;
   Op_comp : forall a b c : Ob, Map2 (Hom a b) (Hom b c) (Hom a c);
   Id : forall a : Ob, Hom a a;
   Prf_ass : Assoc_law Op_comp;
   Prf_idl : Idl_law Op_comp Id;
   Prf_idr : Idr_law Op_comp Id}.

Definition Comp (C : Category) := Cat_comp (Op_comp (c:=C)).

Infix "-->" := Hom (at level 95, right associativity).
Infix "o" := Comp (at level 20, right associativity).

Lemma Ass :
 forall (C : Category) (a b c d : C) (f : a --> b) 
   (g : b --> c) (h : c --> d), f o g o h =_S (f o g) o h.

Lemma Ass1 :
 forall (C : Category) (a b c d : C) (f : a --> b) 
   (g : b --> c) (h : c --> d), (f o g) o h =_S f o g o h.

Lemma Idl : forall (C : Category) (a b : C) (f : a --> b), Id _ o f =_S f.

Lemma Idl1 : forall (C : Category) (a b : C) (f : a --> b), f =_S Id _ o f.

Lemma Idr : forall (C : Category) (a b : C) (f : b --> a), f =_S f o Id _.

Lemma Idr1 : forall (C : Category) (a b : C) (f : a --> b), f o Id _ =_S f.

Lemma Idrl :
 forall (C : Category) (a b : C) (f : a --> b), f o Id _ =_S Id _ o f.

Lemma Idlr :
 forall (C : Category) (a b : C) (f : a --> b), Id _ o f =_S f o Id _.

Section composition_to_operator.

Variables (A : Type) (H : A -> A -> Setoid)
  (Cfun : forall a b c : A, H a b -> H b c -> H a c).

Definition Congl_law :=
  forall (a b c : A) (f g : H b c) (h : H a b),
  f =_S g -> Cfun h f =_S Cfun h g. 

Definition Congr_law :=
  forall (a b c : A) (f g : H a b) (h : H b c),
  f =_S g -> Cfun f h =_S Cfun g h. 

Definition Cong_law :=
  forall (a b c : A) (f f' : H a b) (g g' : H b c),
  f =_S f' -> g =_S g' -> Cfun f g =_S Cfun f' g'. 

Hypothesis pcgl : Congl_law.
Hypothesis pcgr : Congr_law.

Variable a b c : A.

Definition Build_Comp :=
  Build_Map2 (pcgl (a:=a) (b:=b) (c:=c)) (pcgr (a:=a) (b:=b) (c:=c)).

End composition_to_operator.

Section cat_cong.

Variable C : Category.

Lemma Comp_l :
 forall (a b c : C) (f g : b --> c) (h : a --> b), f =_S g -> h o f =_S h o g. 

Lemma Comp_r :
 forall (a b c : C) (f g : a --> b) (h : b --> c), f =_S g -> f o h =_S g o h. 

Lemma Comp_lr :
 forall (a b c : C) (f f' : a --> b) (g g' : b --> c),
 f =_S f' -> g =_S g' -> f o g =_S f' o g'. 

End cat_cong. *)
Require Export SetoidPROD.
(* SetoidPROD:
Require Export Map.

Set Implicit Arguments.
Unset Strict Implicit.

Section s_prod.

Variable A B : Setoid.

Structure Sprod : Type :=  {Sprod_l : A; Sprod_r : B}.

Definition Equal_Sprod (a1xb1 a2xb2 : Sprod) :=
  Sprod_l a1xb1 =_S Sprod_l a2xb2 /\ Sprod_r a1xb1 =_S Sprod_r a2xb2.

Lemma Equal_Sprod_equiv : Equivalence Equal_Sprod.

Canonical Structure SPROD : Setoid := Equal_Sprod_equiv.

Lemma Proj1_SPROD_map_law : Map_law (Sprod_l:SPROD -> A).

Canonical Structure Proj1_SPROD : Map SPROD A := Proj1_SPROD_map_law.

Lemma Proj2_SPROD_map_law : Map_law (Sprod_r:SPROD -> B).

Canonical Structure Proj2_SPROD : Map SPROD B := Proj2_SPROD_map_law.

End s_prod. *)

Set Implicit Arguments.
Unset Strict Implicit.

Section ProdCat.

Variable A B : Category.

Structure POb : Type :=  {Ob_l : A; Ob_r : B}.

 Section pmor_setoid_def.

 Variable u t : POb.

 Structure Pmor : Type := 
   {Hom_l : Ob_l u --> Ob_l t; Hom_r : Ob_r u --> Ob_r t}.

 Definition Equal_Pmor (f g : Pmor) :=
   Hom_l f =_S Hom_l g /\ Hom_r f =_S Hom_r g.

 Lemma Equal_Pmor_equiv : Equivalence Equal_Pmor.
 Proof.
 apply Build_Equivalence.
 unfold Reflexive, Equal_Pmor in |- *; intro x; split; apply Refl.  
 apply Build_Partial_equivalence.
 unfold Transitive, Equal_Pmor in |- *; intros x1 x2 x3 H H0.
 elim H; intros H1 H2; elim H0; intros H3 H4; split.
  apply Trans with (Hom_l x2); assumption.
  apply Trans with (Hom_r x2); assumption.
 unfold Symmetric, Equal_Pmor in |- *; intros x1 x2 H.
 elim H; intros H1 H2; split; apply Sym; assumption.
 Qed.

 Canonical Structure Prod_Hom : Setoid := Equal_Pmor_equiv.

 Definition Prod_Hom' := SPROD (Ob_l u --> Ob_l t) (Ob_r u --> Ob_r t).

 Definition Build1_Pmor :
   (Ob_l u --> Ob_l t) -> (Ob_r u --> Ob_r t) -> Prod_Hom := Build_Pmor.
                
 End pmor_setoid_def.

Definition Comp_Pmor (a b c : POb) (f : Prod_Hom a b) 
  (g : Prod_Hom b c) := Build_Pmor (Hom_l f o Hom_l g) (Hom_r f o Hom_r g).

Lemma Comp_Pmor_congl : Congl_law Comp_Pmor.
Proof.
unfold Congl_law in |- *; simpl in |- *.
unfold Equal_Pmor, Comp_Pmor in |- *; simpl in |- *.
intros a b c f g h H. 
elim H; intros H1 H2; split; apply Comp_l; assumption.
Qed.

Lemma Comp_Pmor_congr : Congr_law Comp_Pmor.
Proof.
unfold Congr_law in |- *; simpl in |- *.
unfold Equal_Pmor, Comp_Pmor in |- *; simpl in |- *.
intros a b c f g.
elim f; elim g; simpl in |- *.
intros gl gr fl fr H h.
elim h; simpl in |- *.
intros hl hr.
elim H; intros H1 H2; split; apply Comp_r; assumption.
Qed.

Definition Comp_PROD := Build_Comp Comp_Pmor_congl Comp_Pmor_congr.

Lemma Assoc_PROD : Assoc_law Comp_PROD.
Proof.
unfold Assoc_law in |- *; simpl in |- *.
unfold Equal_Pmor in |- *; simpl in |- *.
intros; split; apply Ass.
Qed.

Definition Id_PROD (a : POb) := Build_Pmor (Id (Ob_l a)) (Id (Ob_r a)).

Lemma Idl_PROD : Idl_law Comp_PROD Id_PROD.
Proof.
unfold Idl_law in |- *; simpl in |- *.
unfold Equal_Pmor in |- *; simpl in |- *.
intros; split; apply Idl.
Qed.
 
Lemma Idr_PROD : Idr_law Comp_PROD Id_PROD.
Proof.
unfold Idr_law in |- *; simpl in |- *.
unfold Equal_Pmor in |- *; simpl in |- *.
intros; split; apply Idr. 
Qed.
 
Canonical Structure PROD := Build_Category Assoc_PROD Idl_PROD Idr_PROD.

End ProdCat.
