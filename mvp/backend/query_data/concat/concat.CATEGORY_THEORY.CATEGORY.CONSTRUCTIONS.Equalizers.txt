
Require Export CatProperty.
(* CatProperty:
Require Export Dual.

Set Implicit Arguments.
Unset Strict Implicit.

Section epic_monic_def.

Variables (C : Category) (a b : C).
 
Definition Epic_law (f : a --> b) :=
  forall (c : C) (g h : b --> c), f o g =_S f o h -> g =_S h.

Structure > Epic : Type := 
  {Epic_mor : a --> b; Prf_isEpic :> Epic_law Epic_mor}.

Definition Monic_law (f : b --> a) :=
  forall (c : C) (g h : c --> b), g o f =_S h o f -> g =_S h.

Structure > Monic : Type := 
  {Monic_mor : b --> a; Prf_isMonic :> Monic_law Monic_mor}.

End epic_monic_def.

Section iso_def.

Variable C : Category.

Definition RIso_law (a b : C) (f : a --> b) (f1 : b --> a) := f1 o f =_S Id b.

Variable a b : C.

Definition AreIsos (f : a --> b) (f1 : b --> a) :=
  RIso_law f f1 /\ RIso_law f1 f.

Structure > Iso : Type := 
  {Iso_mor : a --> b; Inv_iso : b --> a; Prf_Iso :> AreIsos Iso_mor Inv_iso}.

Lemma Idl_inv : forall i : Iso, RIso_law (Iso_mor i) (Inv_iso i).

Lemma Idr_inv : forall i : Iso, RIso_law (Inv_iso i) (Iso_mor i).

Lemma Inv_iso_unique :
 forall f g : Iso, Iso_mor f =_S Iso_mor g -> Inv_iso f =_S Inv_iso g.

Lemma RightInv_epic :
 forall (h : a --> b) (h1 : b --> a), RIso_law h h1 -> Epic_law h.

End iso_def.

Coercion RightInv_epic : RIso_law >-> Epic_law.

Section initial_def.

Variable C : Category.

Definition IsInitial (a : C) (h : forall b : C, a --> b) :=
  forall (b : C) (f : a --> b), f =_S h b.
  
Structure > Initial : Type := 
  {Initial_ob : C;
   MorI : forall b : C, Initial_ob --> b;
   Prf_isInitial :> IsInitial MorI}.

Definition At_most_1mor (a b : C) := forall f g : a --> b, f =_S g.

Lemma UniqueI : forall (i : Initial) (b : C), At_most_1mor (Initial_ob i) b.

Lemma I_unic : forall i1 i2 : Initial, Iso (Initial_ob i1) (Initial_ob i2).

End initial_def.

Section terminal_def.

Variable C : Category.

Definition IsTerminal (b : C) (h : forall a : C, a --> b) :=
  forall (a : C) (f : a --> b), f =_S h a. 

Structure > Terminal : Type := 
  {Terminal_ob : C;
   MorT : forall a : C, a --> Terminal_ob;
   Prf_isTerminal :> IsTerminal MorT}.

Lemma UniqueT : forall (t : Terminal) (a : C), At_most_1mor a (Terminal_ob t).

End terminal_def.

Lemma Initial_dual :
 forall (C : Category) (a : C) (h : forall b : C, a --> b),
 IsInitial h -> IsTerminal (C:=Dual C) h.

Coercion Initial_dual : IsInitial >-> IsTerminal.

Definition IsTerminal' (C : Category) (b : C) (h : forall a : C, a --> b) :=
  IsInitial (C:=Dual C) h. *)

Set Implicit Arguments.
Unset Strict Implicit.

Section equaz_def.

Variables (C : Category) (a b : C) (I : Type) (k : I -> (a --> b)).

 Section equaz_laws.

 Variables (c : C) (e : c --> a).

 Definition Equalizer_eq (r : C) (h : r --> a) :=
   forall i j : I, h o k i =_S h o k j.

 Definition Equalizer_law1 := Equalizer_eq e.

 Variable E_diese : forall (r : C) (h : r --> a), Equalizer_eq h -> (r --> c).

 Definition Equalizer_law2 :=
   forall (r : C) (h : r --> a) (p : Equalizer_eq h), h =_S E_diese p o e.

 Definition Equalizer_law3 :=
   forall (r : C) (h : r --> a) (p : Equalizer_eq h) (l : r --> c),
   h =_S l o e -> l =_S E_diese p.

 End equaz_laws.

Structure Equalizer : Type := 
  {E_ob : C;
   E_mor : E_ob --> a;
   Prf_E_law1 : Equalizer_law1 E_mor;
   E_diese : forall (r : C) (h : r --> a), Equalizer_eq h -> (r --> E_ob);
   Prf_E_law2 : Equalizer_law2 E_mor E_diese;
   Prf_E_law3 : Equalizer_law3 E_mor E_diese}.

Variable f : Equalizer.

Lemma E_monic : Monic_law (E_mor f).
Proof.
unfold Monic_law in |- *; intros c j l H.
cut (Equalizer_eq (j o E_mor f)).
intro p.
 apply Trans with (E_diese f p).
apply (Prf_E_law3 p (l:=j)).
apply Refl.
apply Sym; apply (Prf_E_law3 p (l:=l)).
apply H.
unfold Equalizer_eq in |- *; intros i1 i2.
 apply Trans with (j o E_mor f o k i1).
apply Ass1.
 apply Trans with (j o E_mor f o k i2).
apply Comp_l; apply (Prf_E_law1 f i1 i2).
apply Ass.
Qed.

Lemma Epic_Equalizer_id : Epic_law (E_mor f) -> Equalizer_eq (Id a).
Proof.
unfold Equalizer_eq in |- *.
intros ep i1 i2.
 apply Trans with (k i1).
apply Idl.
 apply Trans with (k i2).
apply ep.
apply (Prf_E_law1 f i1 i2).
apply Sym; apply Idl.
Qed.

Lemma Epic_Equalizer_iso :
 forall p : Epic_law (E_mor f),
 let f1 := E_diese f (Epic_Equalizer_id p) in AreIsos (E_mor f) f1.
Proof.
intros p.
unfold AreIsos, RIso_law in |- *; split.
apply Sym; apply (Prf_E_law2 f (Epic_Equalizer_id p)).
apply E_monic.
 apply Trans with (E_mor f o Id a).
 apply Trans with (E_mor f o E_diese f (Epic_Equalizer_id p) o E_mor f).
apply Ass1.
apply Comp_l.
apply Sym; apply (Prf_E_law2 f (Epic_Equalizer_id p)).
 apply Trans with (E_mor f).
apply Idr1.
apply Idl1.
Qed.

Lemma Equalizer_iso :
 forall (h1 : a --> E_ob f) (p : RIso_law (E_mor f) h1),
 let f1 := E_diese f (Epic_Equalizer_id (RightInv_epic p)) in
 AreIsos (E_mor f) f1.
Proof.
intros h1 ri; simpl in |- *; apply Epic_Equalizer_iso.
Qed.

End equaz_def.

