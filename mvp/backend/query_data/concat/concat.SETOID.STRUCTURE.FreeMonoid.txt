
Require Export Monoid.
(* Monoid:
Require Export Map2.

Set Implicit Arguments.
Unset Strict Implicit.

SubClass BinOp (A : Setoid) := Map2 A A A.

Section monoid_laws.

Variables (A : Setoid) (op : BinOp A) (e : A).

Let Ap_op (x y : A) := op x y.

Infix "+_M" := Ap_op (at level 40, left associativity).

Definition Monoid_ass := forall x y z : A, x +_M (y +_M z) =_S x +_M y +_M z.

Definition Monoid_idl := forall x : A, e +_M x =_S x.

Definition Monoid_idr := forall x : A, x =_S x +_M e.

End monoid_laws.

Structure Monoid : Type := 
  {Mcarrier :> Setoid;
   Mop : BinOp Mcarrier;
   Munit : Mcarrier;
   Prf_monoid_ass : Monoid_ass Mop;
   Prf_monoid_idl : Monoid_idl Mop Munit;
   Prf_monoid_idr : Monoid_idr Mop Munit}.

Definition ApMop (m : Monoid) (x y : m) := Mop m x y.

Infix "+_M" := ApMop (at level 40, left associativity).
        
Lemma Mass :
 forall (M : Monoid) (x y z : M), x +_M (y +_M z) =_S x +_M y +_M z.

Lemma Mass1 :
 forall (M : Monoid) (x y z : M), x +_M y +_M z =_S x +_M (y +_M z).

Lemma Midl : forall (M : Monoid) (x : M), Munit M +_M x =_S x.

Lemma Midl1 : forall (M : Monoid) (x : M), x =_S Munit M +_M x.

Lemma Midr : forall (M : Monoid) (x : M), x =_S x +_M Munit M.

Lemma Midr1 : forall (M : Monoid) (x : M), x +_M Munit M =_S x.

Section mon_mors.

Variable m1 m2 : Monoid.

Definition MonUnit_law (f : Map m1 m2) := f (Munit m1) =_S Munit m2.

Definition MonOp_law (f : Map m1 m2) :=
  forall a b : m1, f (a +_M b) =_S f a +_M f b.

Structure MonMor : Type := 
  {MonMap :> Map m1 m2;
   Prf_MonUnit_law : MonUnit_law MonMap;
   Prf_MonOp_law : MonOp_law MonMap}.

Lemma MMon_unit : forall f : MonMor, f (Munit m1) =_S Munit m2.

Lemma MMon_op : forall (f : MonMor) (a b : m1), f (a +_M b) =_S f a +_M f b.

Definition Equal_MonMor (f g : MonMor) := f =_M g.

Lemma Equal_MonMor_equiv : Equivalence Equal_MonMor.

Canonical Structure MonMor_setoid : Setoid := Equal_MonMor_equiv.

End mon_mors. *)

Set Implicit Arguments.
Unset Strict Implicit.

Section freem_def.

Variable A : Setoid.

Inductive Tlist : Type :=
  | Empty : Tlist
  | Concat1 : A -> Tlist -> Tlist.

Fixpoint Equal_Tlist (l : Tlist) : Tlist -> Prop :=
  fun m : Tlist =>
  match l, m with
  | Empty, Empty => True
  | Empty, _ => False
  | Concat1 a l1, Concat1 b m1 => a =_S b /\ Equal_Tlist l1 m1
  | _, _ => False
  end.

Lemma Equal_Tlist_equiv : Equivalence Equal_Tlist.
Proof.
apply Build_Equivalence.
unfold Reflexive in |- *; intro l; elim l; simpl in |- *.
auto.
intros; split; [ apply Refl | auto ].
apply Build_Partial_equivalence.
unfold Transitive in |- *; intros l1; elim l1.
intro l2; elim l2.
intro l3; elim l3; simpl in |- *; trivial.
intros c t H z H1; elim H1.
intros c t H y; elim y.
intros z H1 H2; elim H1.
intros c0 t0 H0 z; elim z.
intros H1 H2; elim H2.
intros c1 t1 H1 H2 H3.
elim H2; intros H4 H5.
elim H3; intros H6 H7.
simpl in |- *; split.
apply Trans with c0; trivial.
apply (H t0 t1); trivial.
unfold Symmetric in |- *; intro l1; elim l1.
intro l2; elim l2.
trivial.
intros c t H H1; elim H1.
intros c t H l2; elim l2.
simpl in |- *; trivial.
intros c0 t0 H0 H1.
elim H1; intros H2 H3.
simpl in |- *; split.
apply Sym; trivial.
apply H; trivial.
Qed.

Canonical Structure Tlist_setoid : Setoid := Equal_Tlist_equiv.

Fixpoint Concat (l : Tlist_setoid) : Tlist_setoid -> Tlist_setoid :=
  fun m : Tlist_setoid =>
  match l with
  | Empty => m
  | Concat1 a l1 => Concat1 a (Concat l1 m)
  end.

Lemma Diff_Concat1_Empty :
 forall (a : A) (l : Tlist), ~ Equal_Tlist (Concat1 a l) Empty.
Proof.
unfold not in |- *; intros a l; simpl in |- *; trivial.
Qed.

Lemma Concat_congl : Map2_congl_law Concat.
Proof.
unfold Map2_congl_law in |- *; intros l1 l2 l3.
elim l3; simpl in |- *.
trivial.
intros c t H H0; split.
apply Refl.
auto.
Qed.

Lemma Concat_congr : Map2_congr_law Concat.
Proof.
unfold Map2_congr_law in |- *; intro l1; elim l1.
intro l2; elim l2.
intros l H; apply Refl.
intros c t H l3 H1; elim H1.
intros c t H l2; elim l2.
intros l H1; absurd (Equal_Tlist (Concat1 c t) Empty).
apply Diff_Concat1_Empty.
trivial.
intros c0 t0 H0 l H1; elim H1; intros H2 H3.
simpl in |- *; split.
trivial.
apply (H t0 l); trivial.
Qed.

Definition Concat_map2 := Build_Map2 Concat_congl Concat_congr.

Lemma Mass_FreeMonoid : Monoid_ass Concat_map2.
Proof.
unfold Monoid_ass in |- *; intros l m n; elim l.
apply Refl.
intros; split.
apply Refl.
trivial.
Qed.

Lemma Midl_FreeMonoid : Monoid_idl Concat_map2 Empty.
Proof.
unfold Monoid_idl in |- *; intro l; elim l.
apply Refl.
intros; split.
apply Refl.
trivial.
Qed.

Lemma Midr_FreeMonoid : Monoid_idr Concat_map2 Empty.
Proof.
unfold Monoid_idr in |- *; intro l; elim l; simpl in |- *.
trivial.
intros; split.
apply Refl.
trivial.
Qed.

Canonical Structure FreeMonoid :=
  Build_Monoid Mass_FreeMonoid Midl_FreeMonoid Midr_FreeMonoid.

End freem_def.

Coercion FreeMonoid : Setoid >-> Monoid.