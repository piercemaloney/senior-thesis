
Require Export Setoid.
(* Setoid:
Require Export Relations.

Set Implicit Arguments.
Unset Strict Implicit.
Global Set Asymmetric Patterns.

Structure > Setoid : Type := 
  {Carrier :> Type; Equal : Relation Carrier; Prf_equiv :> Equivalence Equal}.

Infix "=_S" := Equal (at level 70).

Lemma Refl : forall (S : Setoid) (x : S), x =_S x.

Lemma Sym : forall (S : Setoid) (x y : S), x =_S y -> y =_S x.

Lemma Trans : forall (S : Setoid) (x y z : S), x =_S y -> y =_S z -> x =_S z.

Inductive Nat : Type :=
  | Z : Nat
  | Suc : Nat -> Nat.

Definition Eq_Nat (N1 N2 : Nat) := N1 = N2.

Lemma Eq_Nat_equiv : Equivalence Eq_Nat.
 
Definition Set_of_nat : Setoid := Eq_Nat_equiv.

Structure > PSetoid : Type := 
  {PCarrier :> Type;
   Coherence : Relation PCarrier;
   Prf_PER :> Partial_equivalence Coherence}.

Definition Total (A : PSetoid) (x : A) := Coherence x x. *)
Require Export Setoid_dup2.
(* Setoid_dup2:
Require Export Relations.

Set Implicit Arguments.
Unset Strict Implicit.

Structure > Setoid'' : Type := 
  {Carrier'' :> Type;
   Equal'' : Relation Carrier'';
   Prf_equiv'' :> Equivalence Equal''}.

Infix "=_S''" := Equal'' (at level 70).

Lemma Refl'' : forall (S : Setoid'') (x : S), x =_S'' x.

Lemma Sym'' : forall (S : Setoid'') (x y : S), x =_S'' y -> y =_S'' x.

Lemma Trans'' :
 forall (S : Setoid'') (x y z : S), x =_S'' y -> y =_S'' z -> x =_S'' z.

Section maps''.

Variable A B : Setoid''.

Definition Map_law'' (f : A -> B) :=
  forall x y : A, x =_S'' y -> f x =_S'' f y.

Structure > Map'' : Type :=  {Ap'' :> A -> B; Pres'' :> Map_law'' Ap''}.

Lemma Pres1'' : forall (m : Map'') (x y : A), x =_S'' y -> m x =_S'' m y.

Definition Ext'' (f g : Map'') := forall x : A, f x =_S'' g x.

Lemma Ext_equiv'' : Equivalence Ext''.

Canonical Structure Map_setoid'' : Setoid'' := Ext_equiv''.

End maps''.

Section fun2_to_map2''.

Variable A B C : Setoid''.

Definition Map2'' := Map'' A (Map_setoid'' B C).

Variable f : A -> B -> C.

Definition Map2_congl_law'' :=
  forall (b1 b2 : B) (a : A), b1 =_S'' b2 -> f a b1 =_S'' f a b2.

Definition Map2_congr_law'' :=
  forall (a1 a2 : A) (b : B), a1 =_S'' a2 -> f a1 b =_S'' f a2 b.

Definition Map2_cong_law'' :=
  forall (a1 a2 : A) (b1 b2 : B),
  a1 =_S'' a2 -> b1 =_S'' b2 -> f a1 b1 =_S'' f a2 b2.

Hypothesis pgcl : Map2_congl_law''.
Hypothesis pgcr : Map2_congr_law''.

Lemma Map2_map_law1'' : forall a : A, Map_law'' (f a).

Canonical Structure Map2_map1'' (a : A) := Build_Map'' (Map2_map_law1'' a).

Lemma Map2_map_law2'' : Map_law'' Map2_map1''.

Definition Build_Map2'' : Map2'' := Build_Map'' Map2_map_law2''.

End fun2_to_map2''.

Section prop_map2''.

Variables (A B C : Setoid'') (f : Map2'' A B C).

Definition Ap2'' (a : A) (b : B) := f a b.

Lemma Prf_map2_congl'' : Map2_congl_law'' Ap2''.

Lemma Prf_map2_congr'' : Map2_congr_law'' Ap2''.

Lemma Prf_map2_cong'' : Map2_cong_law'' Ap2''.

End prop_map2''.

Coercion Ap2'' : Map2'' >-> Funclass.

Identity Coercion Map2''_Map'' : Map2'' >-> Map''. *)

Set Implicit Arguments.
Unset Strict Implicit.

Section maps0''.

Variables (A : Setoid) (B : Setoid'').

Definition Map_law0'' (f : A -> B) :=
  forall x y : A, x =_S y -> f x =_S'' f y.

Structure > Map0'' : Type :=  {Ap0'' :> A -> B; Pres0'' :> Map_law0'' Ap0''}.

End maps0''.

Section maps''0.

Variables (A : Setoid'') (B : Setoid).

Definition Map_law''0 (f : A -> B) :=
  forall x y : A, x =_S'' y -> f x =_S f y.

Structure > Map''0 : Type :=  {Ap''0 :> A -> B; Pres''0 :> Map_law''0 Ap''0}.

End maps''0.

Section bij0''.

Variables (A : Setoid) (B : Setoid'').

Definition AreBij0'' (f : Map0'' A B) (g : Map''0 B A) :=
  (forall a : A, g (f a) =_S a) /\ (forall b : B, f (g b) =_S'' b).

End bij0''.
