
Require Export Limit.
(* Limit:
Require Export Const.
Require Export CoUniversalArrow.
Require Export Ntransformation.

Set Implicit Arguments.
Unset Strict Implicit.

Section def_cone.

Variables (J C : Category) (c : C) (F : Functor J C).

SubClass Cone := NT (Const J c) F.

Definition Cones := NT_setoid (Const J c) F.

 Section cone_nt.

 Variable T : forall a : J, c --> F a.

 Definition Cone_law :=
   forall (i j : J) (g : i --> j), T j =_S T i o FMor F g.

 Lemma Prf_Cone_nt_law : Cone_law -> NT_law (F:=Const J c) T.
 
 Coercion Prf_Cone_nt_law : Cone_law >-> NT_law.

 Variable p : Cone_law.

 Canonical Structure Build_Cone : Cone := Build_NT (Prf_Cone_nt_law p).

 End cone_nt.

Coercion Build_Cone : Cone_law >-> Cone.
  
Lemma Eq_cone : forall tau : Cone, Cone_law (ApNT tau).

Lemma EqC :
 forall (tau : Cone) (i j : J) (g : i --> j), tau j =_S tau i o FMor F g.

Lemma EqC1 :
 forall (tau : Cone) (i j : J) (g : i --> j), tau i o FMor F g =_S tau j.

End def_cone.
		
Section limit_def.

Variables (J C : Category) (F : Functor J C).

 Section islimit_def. 
 
 Variables (lim : C) (nu : Cone lim F).

  Section limit_laws.

  Variable l_diese : forall c : C, Cone c F -> (c --> lim).  

  Definition Limit_eq (c : C) (tau : Cone c F) (g : c --> lim) :=
    forall i : J, g o nu i =_S tau i.
                      
  Definition Limit_law1 :=
    forall (c : C) (tau : Cone c F), Limit_eq tau (l_diese tau).

  Definition Limit_law2 :=
    forall (c : C) (tau : Cone c F) (g : c --> lim),
    Limit_eq tau g -> g =_S l_diese tau.
  
  End limit_laws.

 Structure IsLimit : Type := 
   {Lim_diese : forall c : C, Cone c F -> (c --> lim);
    Prf_limit1 : Limit_law1 Lim_diese;
    Prf_limit2 : Limit_law2 Lim_diese}.

 Variable l : IsLimit.

 Lemma Ldiese_map :
  forall (c : C) (tau1 tau2 : Cone c F),
  tau1 =_NT tau2 -> Lim_diese l tau1 =_S Lim_diese l tau2.
 
 End islimit_def.

 Structure > Limit : Type := 
   {Lim : C;
    Limiting_cone : Cone Lim F;
    Prf_Islimit :> IsLimit Limiting_cone}.

End limit_def.

Definition Complete (C : Category) :=
  forall (J : Category) (F : Functor J C), Limit F. *)

Set Implicit Arguments.
Unset Strict Implicit.

Section comp_cone.

Variables (J C D : Category) (c : C) (F : Functor J C) 
  (T : Cone c F) (G : Functor C D).

Definition Comp_cone_tau (i : J) : G c --> (F o_F G) i := FMor G (T i).

Lemma Comp_cone_tau_cone_law : Cone_law Comp_cone_tau.
Proof.
unfold Cone_law in |- *; intros i j g; unfold Comp_cone_tau in |- *.
unfold FMor at 3 in |- *; simpl in |- *.
unfold Comp_FMor in |- *.
 apply Trans with (FMor G (T i o FMor F g)).
unfold Comp_FOb in |- *; apply FPres. 
apply (EqC T g).
unfold Comp_FOb in |- *; apply FComp.
Qed.

Definition Comp_cone := Build_Cone Comp_cone_tau_cone_law.

End comp_cone.

Infix "o_C" := Comp_cone (at level 20, right associativity).

Section def_pres_limits.

Variables (J C D : Category) (F : Functor J C) (G : Functor C D).

Definition Preserves_1limit (l : Limit F) := IsLimit (Limiting_cone l o_C G).

Definition Preserves_limits := forall l : Limit F, Preserves_1limit l.

End def_pres_limits.

Definition Continuous (C D : Category) (G : Functor C D) :=
  forall (J : Category) (F : Functor J C), Preserves_limits F G.