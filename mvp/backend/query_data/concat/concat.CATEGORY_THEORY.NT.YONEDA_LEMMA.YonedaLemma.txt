
Require Export HomFunctor_NT.
(* HomFunctor_NT:
Require Export HomFunctor.
Require Export Ntransformation.

Set Implicit Arguments.
Unset Strict Implicit.

Section funset_nt.

Variables (C : Category) (b a : C) (f : a --> b).

Section nth_map_def.

 Variable c : C.

 Definition NtH_arrow (h : b --> c) := f o h.

 Lemma NtH_map_law : Map_law NtH_arrow.

 Definition NtH_map : Map (FunSET b c) (FunSET a c) := NtH_map_law.

End nth_map_def.

Lemma NtH_nt_law : NT_law NtH_map.

Canonical Structure NtH := Build_NT NtH_nt_law.

End funset_nt. *)
Require Export CatFunct.
(* CatFunct:
Require Export Ntransformation.
Require Export Category_dup2.

Set Implicit Arguments.
Unset Strict Implicit.

Section cat_functor.

Variable C D : Category.

 Section compnt.

 Variables (F G H : Functor C D) (T : NT F G) (T' : NT G H).

 Definition Comp_tau (a : C) := T a o T' a.

 Lemma Comp_tau_nt_law : NT_law Comp_tau.

 Canonical Structure CompV_NT : NT_setoid F H := Comp_tau_nt_law.

 End compnt.

Lemma CompV_NT_congl : Congl_law'' CompV_NT.  

Lemma CompV_NT_congr : Congr_law'' CompV_NT.  

Definition Comp_CatFunct := Build_Comp'' CompV_NT_congl CompV_NT_congr.
   
Lemma Assoc_CatFunct : Assoc_law'' Comp_CatFunct.

 Section id_catfunct_def.

 Variable F : Functor C D.

 Definition Id_CatFunct_tau (a : C) := Id (F a).
 
 Lemma Id_CatFunct_nt_law : NT_law Id_CatFunct_tau.
  
 Canonical Structure Id_CatFunct := Build_NT Id_CatFunct_nt_law.

 End id_catfunct_def.

Lemma Idl_CatFunct : Idl_law'' Comp_CatFunct Id_CatFunct.

Lemma Idr_CatFunct : Idr_law'' Comp_CatFunct Id_CatFunct.

Canonical Structure FUNCT :=
  Build_Category'' Assoc_CatFunct Idl_CatFunct Idr_CatFunct.

End cat_functor.

Infix "o_NTv" := CompV_NT (at level 20, right associativity). *)
Require Export Functor_dup1.
(* Functor_dup1:
Require Export Category.
Require Export Category_dup2.
Require Export Map0_dup1.
Require Export Setoid_dup2.

Set Implicit Arguments.
Unset Strict Implicit.

Section funct_def0''.

Variables (C : Category) (D : Category'').

 Section funct_laws0''.

 Variables (FOb0'' : C -> D)
   (FMap0'' : forall a b : C, Map0'' (a --> b) (Hom'' (FOb0'' a) (FOb0'' b))).

 Definition Fcomp_law0'' :=
   forall (a b c : C) (f : a --> b) (g : b --> c),
   FMap0'' a c (f o g) =_S'' FMap0'' a b f o'' FMap0'' b c g.

 Definition Fid_law0'' :=
   forall a : C, FMap0'' a a (Id a) =_S'' Id'' (FOb0'' a).

 End funct_laws0''.

Structure Functor0'' : Type := 
  {FOb0'' :> C -> D;
   FMap0'' : forall a b : C, Map0'' (a --> b) (Hom'' (FOb0'' a) (FOb0'' b));
   Prf_Fcomp_law0'' : Fcomp_law0'' FMap0'';
   Prf_Fid_law0'' : Fid_law0'' FMap0''}.

Definition FMor0'' (F : Functor0'') (a b : C) (f : a --> b) :=
  FMap0'' F a b f.

End funct_def0''.

Section functor_prop0''.

Variables (C : Category) (D : Category''). 

Definition Faithful_law0'' (F : Functor0'' C D) :=
  forall (a b : C) (f g : a --> b), FMor0'' F f =_S'' FMor0'' F g -> f =_S g.

Structure > Faithful0'' : Type := 
  {Faithful_functor0'' :> Functor0'' C D;
   Prf_isFaithful0'' :> Faithful_law0'' Faithful_functor0''}.

Definition Full_law0'' (F : Functor0'' C D)
  (H : forall a b : C, Hom'' (F a) (F b) -> (a --> b)) :=
  forall (a b : C) (h : Hom'' (F a) (F b)), h =_S'' FMor0'' F (H a b h).

Structure > Full0'' : Type := 
  {Full_functor0'' :> Functor0'' C D;
   Full_mor0'' :
    forall a b : C,
    Hom'' (Full_functor0'' a) (Full_functor0'' b) -> (a --> b);
   Prf_isFull0'' :> Full_law0'' Full_mor0''}.

End functor_prop0''. *)

Set Implicit Arguments.
Unset Strict Implicit.

Section yoneda_lemma.

Variable C : Category.

 Section ylphi_tau_def.

 Variables (a : C) (F : Functor C SET).

 Definition YLphi_arrow (T : NT (FunSET a) F) := T a (Id a).

 Lemma YLphi_arrow_map_law : Map_law''0 YLphi_arrow.
 Proof.
 unfold Map_law''0, YLphi_arrow in |- *; intros T1 T2 H; simpl in |- *.
 apply (H a (Id a)).
 Qed.

 Canonical Structure YLphi_tau := Build_Map''0 YLphi_arrow_map_law.

 End ylphi_tau_def.

Lemma YLphi_nt_law :
 forall (a a' : C) (g : a --> a') (F F' : Functor C SET) 
   (T : NT F F') (U : NT (FunSET a) F),
 YLphi_tau a' F' (NtH g o_NTv U o_NTv T) =_S
 (FMor F g o T a') (YLphi_tau a F U).
Proof.
intros a a' g F F' T U.
unfold YLphi_tau in |- *; simpl in |- *; unfold YLphi_arrow in |- *;
 simpl in |- *. 
unfold NtH_arrow, Comp_fun in |- *.
apply Pres1.
apply Trans with (U a' (Id a o g)).
apply Pres1.
simpl in |- *; unfold FunSET_ob in |- *.
apply Idrl.
apply (Prf_NT_law U g (Id a)).
Qed.

 Section ylpsi_tau_def.

 Variables (a : C) (F : Functor C SET).

  Section ylpsi_arrow_def.

  Variable x : F a.

   Section ylpsi_map1_def.

   Variable b : C.

   Definition YLpsi_arrow1 (f : a --> b) := FMor F f x.

   Lemma YLpsi_arrow1_map_law : Map_law YLpsi_arrow1.
   Proof.
   unfold Map_law in |- *.
   intros y z H; unfold YLpsi_arrow1 in |- *.
   apply (Pres (FMap F a b) H x).
   Qed.

   Canonical Structure YLpsi_map1 :=
     Build_Map (A:=FunSET a b) YLpsi_arrow1_map_law.

   End ylpsi_map1_def.

  Lemma YLpsi_map1_nt_law : NT_law YLpsi_map1.
  Proof.
  unfold NT_law in |- *.
  intros b c f; unfold YLpsi_map1, YLpsi_arrow1 in |- *; simpl in |- *.
  unfold Ext, FunSET_ob in |- *; intro g; simpl in |- *.
  unfold FunSET_mor, Comp_fun in |- *; simpl in |- *.
  apply (Prf_Fcomp_law F g f x).
  Qed.

  Canonical Structure YLpsi_arrow := Build_NT YLpsi_map1_nt_law.

  End ylpsi_arrow_def.

 Lemma YLpsi_arrow_map_law : Map_law0'' YLpsi_arrow.
 Proof.
 unfold Map_law0'', YLpsi_arrow in |- *. 
 intros x y H.
 unfold YLpsi_map1, YLpsi_arrow1 in |- *; simpl in |- *;
  unfold Equal_NT in |- *; simpl in |- *.
 intro a0; unfold Ext in |- *; simpl in |- *; intro f.
 apply Pres1; assumption.
 Qed.

 Canonical Structure YLpsi_tau : Map0'' (F a) (NT_setoid (FunSET a) F) :=
   YLpsi_arrow_map_law.

 End ylpsi_tau_def.

Lemma YLpsi_nt_law :
 forall (a a' : C) (g : a --> a') (F F' : Functor C SET) 
   (T : NT F F') (x : F a) (b : C) (f : a' --> b),
 YLpsi_tau a' F' ((FMor F g o T a') x) b f =_S
 (NtH g o_NTv YLpsi_tau a F x o_NTv T) b f.

Proof.
intros a a' g F F' T x b f.
unfold YLpsi_tau in |- *; simpl in |- *; unfold Comp_fun in |- *;
 simpl in |- *.
unfold YLpsi_arrow1, NtH_arrow in |- *.
apply Trans with (T b (FMor F f (FMor F g x))).
generalize (Prf_NT_law T f (FMor F g x)).
unfold NT_law in |- *; simpl in |- *; unfold Comp_fun in |- *; intro H. 
apply Sym; apply H.
apply Pres1; apply Sym; apply (Prf_Fcomp_law F g f x).
Qed.

Lemma YonedaLemma :
 forall (a : C) (F : Functor C SET),
 AreBij0'' (YLpsi_tau a F) (YLphi_tau a F).
Proof.
intros a F; unfold AreBij0'' in |- *; split; simpl in |- *.
intro x; unfold YLphi_arrow in |- *; simpl in |- *;
 unfold YLpsi_arrow1 in |- *.
apply Trans with (Id (F a) x).
apply (Prf_Fid_law F a x).
apply Refl.
intro T; unfold YLpsi_arrow, Equal_NT in |- *; simpl in |- *.
intro b; unfold YLpsi_map1, Ext in |- *; simpl in |- *.
unfold FunSET_ob in |- *; intro f.
unfold YLpsi_arrow1, YLphi_arrow in |- *.
generalize (Prf_NT_law T f (Id a)).
simpl in |- *; unfold Comp_fun in |- *; simpl in |- *;
 unfold FunSET_mor1 in |- *; intro H.
apply Trans with (T b (Id a o f)).
apply Sym; exact H.
apply Pres1; apply Idl.
Qed.

End yoneda_lemma.