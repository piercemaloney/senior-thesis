
Require Export Const.
(* Const:
Require Export Functor.

Set Implicit Arguments.
Unset Strict Implicit.

Section constFun.

Variables (A B : Category) (b : B).

Definition Const_ob (a : A) := b.

 Section const_map_def.

 Variable a1 a2 : A.

 Definition Const_mor (f : a1 --> a2) := Id b.

 Lemma Const_mor_map_law : Map_law Const_mor.

 Canonical Structure Const_map :
   Map (a1 --> a2) (Const_ob a1 --> Const_ob a1) := Const_mor_map_law.

 End const_map_def.

Lemma Const_comp_law : Fcomp_law Const_map.

Lemma Const_id_law : Fid_law Const_map.

Canonical Structure Const := Build_Functor Const_comp_law Const_id_law.

End constFun. *)
Require Export CoUniversalArrow.
(* CoUniversalArrow:
Require Export UniversalArrow.
Require Export Dual_Functor.

Set Implicit Arguments.
Unset Strict Implicit.

Section coua_def.

Variables (A B : Category) (b : B) (F : Functor A B).

 Section iscoua_def.

 Variables (a : A) (u : F a --> b).

  Section coua_laws.

  Variable co_diese : forall a' : A, (F a' --> b) -> (a' --> a).

  Definition CoUA_eq (a' : A) (f : F a' --> b) (g : a' --> a) :=
    FMor F g o u =_S f.

  Definition CoUA_law1 :=
    forall (a' : A) (f : F a' --> b), CoUA_eq f (co_diese f).

  Definition CoUA_law2 :=
    forall (a' : A) (f : F a' --> b) (g : a' --> a),
    CoUA_eq f g -> g =_S co_diese f.

  End coua_laws. 
 
 Structure IsCoUA : Type := 
   {CoUA_diese : forall a' : A, (F a' --> b) -> (a' --> a);
    Prf_isCoUA_law1 : CoUA_law1 CoUA_diese;
    Prf_isCoUA_law2 : CoUA_law2 CoUA_diese}.

 Variable t : IsCoUA.

 Lemma Codiese_map : forall a' : A, Map_law (CoUA_diese t (a':=a')).

 End iscoua_def.

Structure > CoUA : Type := 
  {CoUA_ob : A; CoUA_mor : F CoUA_ob --> b; Prf_IsCoUA :> IsCoUA CoUA_mor}.

Lemma CoUA_diag :
 forall (u : CoUA) (a' : A) (f : F a' --> b),
 FMor F (CoUA_diese u f) o CoUA_mor u =_S f.
 
Lemma CoUA_diag1 :
 forall (u : CoUA) (a' : A) (f : F a' --> b),
 f =_S FMor F (CoUA_diese u f) o CoUA_mor u. 

Lemma CoUA_unic :
 forall (u : CoUA) (a' : A) (f : F a' --> b) (g : a' --> CoUA_ob u),
 FMor F g o CoUA_mor u =_S f -> g =_S CoUA_diese u f.

Lemma CoUA_unic1 :
 forall (u : CoUA) (a' : A) (f : F a' --> b) (g : a' --> CoUA_ob u),
 FMor F g o CoUA_mor u =_S f -> CoUA_diese u f =_S g.

End coua_def.

Section coua_def1.

Variables (A B : Category) (b : B) (F : Functor A B).

 Section iscoua_def1.

 Variables (a : A) (u : F a --> b).

 Definition IsCoUA1 := IsUA (G:=Dfunctor F) u.
 
 Variable u1 : IsCoUA1.

 Definition CoUA1_diese (a' : A) (f : F a' --> b) := UA_diese u1 f.

 Lemma Prf_isCoUA1_law1 : CoUA_law1 u CoUA1_diese.

 Lemma Prf_isCoUA1_law2 : CoUA_law2 u CoUA1_diese.

 Lemma IsCoUA1_to_IsCoUA : IsCoUA u. 

 End iscoua_def1.

Coercion IsCoUA1_to_IsCoUA : IsCoUA1 >-> IsCoUA.

Definition CoUA1 := UA (b:Ob (Dual B)) (Dfunctor F).

Variable u1 : CoUA1.

Definition CoUA1_to_CoUA := Build_CoUA (IsCoUA1_to_IsCoUA (Prf_IsUA u1)). 

End coua_def1.

Coercion CoUA1_to_CoUA : CoUA1 >-> CoUA. *)
Require Export Ntransformation.
(* Ntransformation:
Require Export Functor.
Require Export Setoid_dup2.

Set Implicit Arguments.
Unset Strict Implicit.

Section nt_def.

Variables (C D : Category) (F G : Functor C D).

Definition NT_law (T : forall a : C, F a --> G a) :=
  forall (a b : C) (f : a --> b), FMor F f o T b =_S T a o FMor G f.

Structure > NT : Type := 
  {ApNT :> forall a : C, F a --> G a; Prf_NT_law :> NT_law ApNT}.

Lemma NatCond :
 forall (T : NT) (a b : C) (f : a --> b), FMor F f o T b =_S T a o FMor G f.

Lemma NatCond1 :
 forall (T : NT) (a b : C) (f : a --> b), T a o FMor G f =_S FMor F f o T b.

End nt_def.

Section setoid_nt.

Variables (C D : Category) (F G : Functor C D).

Definition Equal_NT (T T' : NT F G) := forall a : C, T a =_S T' a.

Lemma Equal_NT_equiv : Equivalence Equal_NT.

Canonical Structure NT_setoid : Setoid'' := Equal_NT_equiv.

End setoid_nt.

Infix "=_NT" := Equal_NT (at level 70). *)

Set Implicit Arguments.
Unset Strict Implicit.

Section def_cone.

Variables (J C : Category) (c : C) (F : Functor J C).

SubClass Cone := NT (Const J c) F.

Definition Cones := NT_setoid (Const J c) F.

 Section cone_nt.

 Variable T : forall a : J, c --> F a.

 Definition Cone_law :=
   forall (i j : J) (g : i --> j), T j =_S T i o FMor F g.

 Lemma Prf_Cone_nt_law : Cone_law -> NT_law (F:=Const J c) T.
 Proof.
 unfold NT_law in |- *; intros H a b f.
 unfold FMor at 1 in |- *; simpl in |- *; unfold Const_mor in |- *.
  apply Trans with (T b).
 apply Idl.
 apply (H a b).
 Qed.
 
 Coercion Prf_Cone_nt_law : Cone_law >-> NT_law.

 Variable p : Cone_law.

 Canonical Structure Build_Cone : Cone := Build_NT (Prf_Cone_nt_law p).

 End cone_nt.

Coercion Build_Cone : Cone_law >-> Cone.
  
Lemma Eq_cone : forall tau : Cone, Cone_law (ApNT tau).
Proof.
unfold Cone_law in |- *; intros tau i j g.
 apply Trans with (Id c o tau j).
apply Idl1.
apply (Prf_NT_law tau g).
Qed.

Lemma EqC :
 forall (tau : Cone) (i j : J) (g : i --> j), tau j =_S tau i o FMor F g.
Proof.
exact Eq_cone.
Qed.

Lemma EqC1 :
 forall (tau : Cone) (i j : J) (g : i --> j), tau i o FMor F g =_S tau j.
Proof.
intros; apply Sym; exact (EqC tau (i:=i) (j:=j) g).
Qed.

End def_cone.
		
Section limit_def.

Variables (J C : Category) (F : Functor J C).

 Section islimit_def. 
 
 Variables (lim : C) (nu : Cone lim F).

  Section limit_laws.

  Variable l_diese : forall c : C, Cone c F -> (c --> lim).  

  Definition Limit_eq (c : C) (tau : Cone c F) (g : c --> lim) :=
    forall i : J, g o nu i =_S tau i.
                      
  Definition Limit_law1 :=
    forall (c : C) (tau : Cone c F), Limit_eq tau (l_diese tau).

  Definition Limit_law2 :=
    forall (c : C) (tau : Cone c F) (g : c --> lim),
    Limit_eq tau g -> g =_S l_diese tau.
  
  End limit_laws.

 Structure IsLimit : Type := 
   {Lim_diese : forall c : C, Cone c F -> (c --> lim);
    Prf_limit1 : Limit_law1 Lim_diese;
    Prf_limit2 : Limit_law2 Lim_diese}.

 Variable l : IsLimit.

 Lemma Ldiese_map :
  forall (c : C) (tau1 tau2 : Cone c F),
  tau1 =_NT tau2 -> Lim_diese l tau1 =_S Lim_diese l tau2.
 Proof.
 intros c tau1 tau2 p.
 apply (Prf_limit2 l (tau:=tau2) (g:=Lim_diese l tau1)).
 unfold Limit_eq in |- *; intro i.
  apply Trans with (tau1 i).
 apply (Prf_limit1 l tau1).
 apply (p i).
 Qed.
 
 End islimit_def.

 Structure > Limit : Type := 
   {Lim : C;
    Limiting_cone : Cone Lim F;
    Prf_Islimit :> IsLimit Limiting_cone}.

End limit_def.

Definition Complete (C : Category) :=
  forall (J : Category) (F : Functor J C), Limit F.
