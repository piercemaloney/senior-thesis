
Require Export Comma.
(* Comma:
Require Export Functor.

Set Implicit Arguments.
Unset Strict Implicit.

Section comma_def.

Variables (A X : Category) (G : Functor A X) (x : X).

Structure Com_ob : Type :=  {Ob_com_ob : A; Mor_com_ob : x --> G Ob_com_ob}.

 Section com_arrow_def.

 Variable axf bxg : Com_ob.
 
 Definition Com_law (h : Ob_com_ob axf --> Ob_com_ob bxg) :=
   Mor_com_ob bxg =_S Mor_com_ob axf o FMor G h.

 Structure > Com_arrow : Type := 
   {Mor_com_arrow : Ob_com_ob axf --> Ob_com_ob bxg;
    Prf_com_law :> Com_law Mor_com_arrow}.

 Definition Equal_com_arrow (h h' : Com_arrow) :=
   Mor_com_arrow h =_S Mor_com_arrow h'.

 Lemma Equal_com_arrow_equiv : Equivalence Equal_com_arrow.

 Canonical Structure Com_arrow_setoid : Setoid := Equal_com_arrow_equiv.

 End com_arrow_def. 

 Section comp_com_def.

 Variables (axf bxg cxh : Com_ob) (f : Com_arrow axf bxg)
   (g : Com_arrow bxg cxh).

 Definition Comp_com_mor := Mor_com_arrow f o Mor_com_arrow g.

 Lemma Comp_com_law : Com_law Comp_com_mor.

 Canonical Structure Comp_com_arrow := Build_Com_arrow Comp_com_law.

 End comp_com_def.
 
Lemma Comp_com_congl : Congl_law Comp_com_arrow.

Lemma Comp_com_congr : Congr_law Comp_com_arrow.

Definition Comp_Comma := Build_Comp Comp_com_congl Comp_com_congr. 

Lemma Assoc_Comma : Assoc_law Comp_Comma.

Lemma Id_com_law : forall axf : Com_ob, Com_law (Id (Ob_com_ob axf)).

Canonical Structure Id_Comma (axf : Com_ob) :=
  Build_Com_arrow (Id_com_law axf).

Lemma Idl_Comma : Idl_law Comp_Comma Id_Comma.

Lemma Idr_Comma : Idr_law Comp_Comma Id_Comma.

Canonical Structure Comma := Build_Category Assoc_Comma Idl_Comma Idr_Comma.

End comma_def. *)
Require Export UniversalArrow.
(* UniversalArrow:
Require Export CatProperty.
Require Export Functor.

Set Implicit Arguments.
Unset Strict Implicit.

Section ua_def.

Variables (A B : Category) (b : B) (G : Functor A B).

 Section isua_def.

 Variables (a : A) (u : b --> G a).

  Section ua_laws.

  Variable diese : forall a' : A, (b --> G a') -> (a --> a').

  Definition UA_eq (a' : A) (f : b --> G a') (g : a --> a') :=
    u o FMor G g =_S f.

  Definition UA_law1 := forall (a' : A) (f : b --> G a'), UA_eq f (diese f).

  Definition UA_law2 :=
    forall (a' : A) (f : b --> G a') (g : a --> a'),
    UA_eq f g -> g =_S diese f.

  End ua_laws.

 Structure IsUA : Type := 
   {UA_diese : forall a' : A, (b --> G a') -> (a --> a');
    Prf_isUA_law1 : UA_law1 UA_diese;
    Prf_isUA_law2 : UA_law2 UA_diese}.

 Variable t : IsUA.

 Lemma Diese_map : forall a' : A, Map_law (UA_diese t (a':=a')).

 End isua_def.

Structure > UA : Type := 
  {UA_ob : A; UA_mor : b --> G UA_ob; Prf_IsUA :> IsUA UA_mor}.

Lemma UA_diag :
 forall (u : UA) (a' : A) (f : b --> G a'),
 UA_mor u o FMor G (UA_diese u f) =_S f.
 
Lemma UA_diag1 :
 forall (u : UA) (a' : A) (f : b --> G a'),
 f =_S UA_mor u o FMor G (UA_diese u f).

Lemma UA_unic :
 forall (u : UA) (a' : A) (f : b --> G a') (g : UA_ob u --> a'),
 UA_mor u o FMor G g =_S f -> g =_S UA_diese u f.

Lemma UA_unic1 :
 forall (u : UA) (a' : A) (f : b --> G a') (g : UA_ob u --> a'),
 UA_mor u o FMor G g =_S f -> UA_diese u f =_S g.

End ua_def.

Section ua_iso_def.

Variables (A B : Category) (b : B) (G : Functor A B) (u1 u2 : UA b G).

Definition UA_iso_mor := UA_diese u1 (UA_mor u2).

Definition UA_iso_mor_1 := UA_diese u2 (UA_mor u1).

Lemma UA_iso_law1 : AreIsos UA_iso_mor UA_iso_mor_1.

Definition UA_iso : Iso (UA_ob u1) (UA_ob u2) := UA_iso_law1.

End ua_iso_def. *)

Set Implicit Arguments.
Unset Strict Implicit.

Section ua_comma.

Variables (A X : Category) (G : Functor A X) (x : X).

Variable u : UA x G.

Canonical Structure UA_com_ob := Build_Com_ob (UA_mor u).

 Section ua_com_arrow_def.

 Variable axf : Comma G x.

 Lemma UA_com_law : Com_law (UA_diese u (Mor_com_ob axf)).
 Proof.
 unfold Com_law in |- *.
 elim axf; intros a f; simpl in |- *.
 apply UA_diag1.
 Qed.

 Canonical Structure UA_com_arrow := Build_Com_arrow UA_com_law.

 End ua_com_arrow_def.

Lemma UA_isInitial : IsInitial UA_com_arrow.
Proof.
unfold IsInitial in |- *; intros b f.
unfold UA_com_arrow in |- *; simpl in |- *; unfold Equal_com_arrow in |- *;
 simpl in |- *.
apply UA_unic.
apply Sym; apply (Prf_com_law f).
Qed.

Canonical Structure UA_Initial := Build_Initial UA_isInitial.

Variable axu : Initial (Comma G x).

Definition Com_diese (a' : A) (f : x --> G a') :=
  Mor_com_arrow (MorI axu (Build_Com_ob f)).

Let axu_ob := Initial_ob axu.

Lemma Com_UAlaw1 : UA_law1 (Mor_com_ob axu_ob) Com_diese.
Proof.
unfold UA_law1, UA_eq in |- *; intros a' f.
apply Sym; exact (Prf_com_law (MorI axu (Build_Com_ob f))).
Qed.

Lemma Com_UAlaw2 : UA_law2 (Mor_com_ob axu_ob) Com_diese.
Proof.
unfold UA_law2, UA_eq in |- *; intros a' f g H.
cut (Com_law (bxg:=Build_Com_ob f) g).
intro H'.
apply (UniqueI (Build_Com_arrow H') (MorI axu (Build_Com_ob f))); auto.
unfold Com_law in |- *; simpl in |- *.
apply Sym; trivial.
Qed.

Lemma Com_isUA : IsUA (Mor_com_ob axu_ob).
Proof.
apply (Build_IsUA Com_UAlaw1 Com_UAlaw2).
Defined.
         
Canonical Structure Com_UA := Build_UA Com_isUA.

End ua_comma.
