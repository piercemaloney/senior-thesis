
Require Export FSC_inc.
(* FSC_inc:
Require Export FullSubCat.
Require Export FunctorProperty.

Set Implicit Arguments.
Unset Strict Implicit.

Section fsc_inc_def.

Variables (C : Category) (I : Type) (a : I -> C).

Definition Inc_map (i j : FullSubCat a) := Id_map (a i --> a j).

Lemma Inc_comp_law : Fcomp_law Inc_map.

Lemma Inc_id_law : Fid_law Inc_map.

Canonical Structure FSC_inc := Build_Functor Inc_comp_law Inc_id_law.

Lemma Inc_faith : Faithful_law FSC_inc.

Lemma Inc_full :
 Full_law (F:=FSC_inc) (fun i j : I => Id_fun (A:=a i --> a j)).

End fsc_inc_def. *)
Require Export Comma_proj.
(* Comma_proj:
Require Export Comma.

Set Implicit Arguments.
Unset Strict Implicit.

Section comma_proj_def.

Variables (A X : Category) (G : Functor A X) (x : X).

Definition Comma_proj_ob (a : Com_ob G x) := Ob_com_ob a.

 Section comma_proj_map_def.

 Variable a b : Com_ob G x.

 Definition Comma_proj_mor (f : a --> b) := Mor_com_arrow f.

 Lemma Comma_proj_map_law : Map_law Comma_proj_mor.

 Definition Comma_proj_map := Build_Map Comma_proj_map_law.

 End comma_proj_map_def.

Lemma Comma_proj_comp_law : Fcomp_law Comma_proj_map.

Lemma Comma_proj_id_law : Fid_law Comma_proj_map.

Canonical Structure Comma_proj :=
  Build_Functor Comma_proj_comp_law Comma_proj_id_law.

End comma_proj_def. *)
Require Export FAFT_SSC2.
(* FAFT_SSC2:
Require Export Functor.

Set Implicit Arguments.
Unset Strict Implicit.

Section ssc2_def.

Variables (A X : Category) (G : Functor A X) (x : X).

Structure Cond2 (I : Type) (l : I -> A) (f : forall i : I, x --> G (l i))
  (a : A) (h : x --> G a) : Type := 
  {Cond2_i : I;
   Cond2_t : l Cond2_i --> a;
   Prf_Cond2_law : h =_S f Cond2_i o FMor G Cond2_t}.

Structure SSC2 : Type := 
  {SSC2_I : Type;
   SSC2_a : SSC2_I -> A;
   SSC2_f : forall i : SSC2_I, x --> G (SSC2_a i);
   SSC2_p : forall (a : A) (h : x --> G a), Cond2 SSC2_f h}.

Variables (s : SSC2) (a : A) (h : x --> G a).

Definition SSC2_i := Cond2_i (SSC2_p s h).

Definition SSC2_t := Cond2_t (SSC2_p s h).

Lemma Prf_SSC2_law : h =_S SSC2_f SSC2_i o FMor G SSC2_t.

End ssc2_def. *)
Require Export Th_Adjoint.
(* Th_Adjoint:
Require Export Adj_UA.

Set Implicit Arguments.
Unset Strict Implicit.

Section ua_to_ladj.

Variables (C D : Category) (G : Functor C D).

Hypothesis UA_of : forall d : D, UA d G.

Definition AdjointUA_ob (d : D) := UA_ob (UA_of d).

 Section adjoint_ua_map_def.

 Variable d d' : D.

 Definition AdjointUA_mor (f : d --> d') :=
   UA_diese (UA_of d) (f o UA_mor (UA_of d')).

 Lemma AdjointUA_map_law : Map_law AdjointUA_mor.

 Canonical Structure AdjointUA_map :
   Map (d --> d') (AdjointUA_ob d --> AdjointUA_ob d') := AdjointUA_map_law.

 End adjoint_ua_map_def.
 
Lemma AdjointUA_id_law : Fid_law AdjointUA_map.

Lemma AdjointUA_comp_law : Fcomp_law AdjointUA_map.

Canonical Structure AdjointUA :=
  Build_Functor AdjointUA_comp_law AdjointUA_id_law.

 Section phi_ua_tau_def.

 Variable dxc : POb (Dual D) C.

 Definition PhiUA_arrow (f : UA_ob (UA_of (OB_l dxc)) --> Ob_r dxc) :=
   UA_mor (UA_of (OB_l dxc)) o FMor G f.

 Lemma PhiUA_arrow_map_law : Map_law PhiUA_arrow.

 Canonical Structure PhiUA_tau := Build_Map PhiUA_arrow_map_law.

 End phi_ua_tau_def.

Lemma PhiUA_tau_nt_law :
 NT_law (F:=FunSET2_r AdjointUA) (G:=FunSET2_l G) PhiUA_tau.

Canonical Structure PhiUA := Build_NT PhiUA_tau_nt_law.

 Section phi_ua_1_tau_def.

 Variable dxc : POb (Dual D) C.

 Definition PhiUA_1_arrow (f : OB_l dxc --> G (Ob_r dxc)) :=
   UA_diese (UA_of (OB_l dxc)) f.

 Lemma PhiUA_1_arrow_map_law : Map_law PhiUA_1_arrow.

 Canonical Structure PhiUA_1_tau := Build_Map PhiUA_1_arrow_map_law.

 End phi_ua_1_tau_def.

Lemma PhiUA_1_tau_nt_law :
 NT_law (F:=FunSET2_l G) (G:=FunSET2_r AdjointUA) PhiUA_1_tau.

Canonical Structure PhiUA_1 := Build_NT PhiUA_1_tau_nt_law.

 Section phi_ua_iso.

 Variable dxc : POb (Dual D) C.

 Lemma PhiUA_1_o_PhiUA : AreIsos (PhiUA dxc) (PhiUA_1 dxc).

 End phi_ua_iso.

Definition AdjUA := Build_Adj (NT_Iso PhiUA_1_o_PhiUA).

Canonical Structure LeftAdjUA := Build_LeftAdj AdjUA.

End ua_to_ladj. *)
Require Export Pres_Limits.
(* Pres_Limits:
Require Export Limit.

Set Implicit Arguments.
Unset Strict Implicit.

Section comp_cone.

Variables (J C D : Category) (c : C) (F : Functor J C) 
  (T : Cone c F) (G : Functor C D).

Definition Comp_cone_tau (i : J) : G c --> (F o_F G) i := FMor G (T i).

Lemma Comp_cone_tau_cone_law : Cone_law Comp_cone_tau.

Definition Comp_cone := Build_Cone Comp_cone_tau_cone_law.

End comp_cone.

Infix "o_C" := Comp_cone (at level 20, right associativity).

Section def_pres_limits.

Variables (J C D : Category) (F : Functor J C) (G : Functor C D).

Definition Preserves_1limit (l : Limit F) := IsLimit (Limiting_cone l o_C G).

Definition Preserves_limits := forall l : Limit F, Preserves_1limit l.

End def_pres_limits.

Definition Continuous (C D : Category) (G : Functor C D) :=
  forall (J : Category) (F : Functor J C), Preserves_limits F G. *)
Require Export Pullbacks1.
(* Pullbacks1:
Require Export Limit.
Require Export PULB.
Require Export Pullbacks.

Set Implicit Arguments.
Unset Strict Implicit.

Section Fpullback_limit_def.

Variables (C : Category) (G : Functor PULB C).

SubClass Fpullback1 := Limit G.

Variable l : Fpullback1.

Definition Fibred1_prod := Lim l.

Definition Fibred1_p : Fibred1_prod --> G P1 := Limiting_cone l P1.

Definition Fibred1_q : Fibred1_prod --> G P3 := Limiting_cone l P3.

Lemma Prf_pb1_law1 :
 Pullback_law1 (FMor G F12) (FMor G F32) Fibred1_p Fibred1_q.
 
 Section pb1_diese_def.

 Variables (r : C) (t1 : r --> G P1) (t2 : r --> G P3).

 Hypothesis H : Pullback_eq1 (FMor G F12) (FMor G F32) t1 t2.

 Definition Pulb_tau (a : PULB) :=
   match a as a' return (Carrier (r --> G a')) with
   | P1 => t1
   | P2 => t1 o FMor G F12
   | P3 => t2
   end.
 
 Lemma Pulb_cone_law : Cone_law Pulb_tau.
 
 Definition Pulb_cone : Cone r G := Pulb_cone_law.

 Definition Pb1_diese : r --> Fibred1_prod := Lim_diese l Pulb_cone.

 End pb1_diese_def.

Lemma Prf_pb1_law2 : Pullback_law2 Fibred1_p Pb1_diese.

Lemma Prf_pb1_law3 : Pullback_law3 Fibred1_q Pb1_diese.

Lemma Prf_pb1_law4 : Pullback_law4 Fibred1_p Fibred1_q Pb1_diese.

Canonical Structure Pullback1_to_Pullback :=
  Build_Pullback Prf_pb1_law1 Prf_pb1_law2 Prf_pb1_law3 Prf_pb1_law4. 

End Fpullback_limit_def.

Coercion Pullback1_to_Pullback : Fpullback1 >-> Pullback. 

Section pullback_limit_def.

Variables (C : Category) (a b c : C) (f : a --> b) (g : c --> b).

Definition Fpulb_ob (x : PULB) :=
  match x return (Ob C) with
  | P1 => a
  | P2 => b
  | P3 => c
  end.

Definition Fpulb_mor (x y : PULB) (h : PULB_mor_setoid x y) :=
  match
    h in (PULB_mor x' y') return (Carrier (Fpulb_ob x' --> Fpulb_ob y'))
  with
  | IP1 => Id a
  | IP2 => Id b
  | IP3 => Id c
  | F12 => f
  | F32 => g
  end.

Lemma Fpulb_map_law : forall x y : PULB_ob, Map_law (Fpulb_mor (x:=x) (y:=y)).

Canonical Structure Fpulb_map (x y : PULB) :=
  Build_Map (Fpulb_map_law (x:=x) (y:=y)).

Lemma Fpulb_comp_law : Fcomp_law Fpulb_map.

Lemma Fpulb_id_law : Fid_law Fpulb_map.

Canonical Structure Fpulb := Build_Functor Fpulb_comp_law Fpulb_id_law.

SubClass Pullback1 := Fpullback1 Fpulb.

End pullback_limit_def. *)

Set Implicit Arguments.
Unset Strict Implicit.

Section freyd_th_2.

Variables (A X : Category) (G : Functor A X) (A_c : Complete A)
  (G_c : Continuous G) (s : forall x : X, SSC2 G x).

 Section uaxG.

 Variable x : X.

 Definition FT_I := SSC2_I (s x).

 Definition FT_f (i : FT_I) := SSC2_f i.

 Definition FT_a (i : FT_I) := SSC2_a i.

 Canonical Structure FamI (i : FT_I) := Build_Com_ob (FT_f i).

 Definition CommaI := FullSubCat FamI.

 Definition FT_E := FSC_inc FamI.

 Definition FT_Q := Comma_proj G x.

 Definition L_A := A_c (FT_E o_F FT_Q).

 Definition Lim_EoQ := Lim L_A.

 Definition FT_eps := Limiting_cone L_A.

 Definition L_X := G_c L_A.

 Definition FT_tau_i (i : FT_I) := FT_f i.

 Lemma FT_tau_cone_law : Cone_law (F:=(FT_E o_F FT_Q) o_F G) FT_tau_i.
 Proof.
 unfold Cone_law in |- *; simpl in |- *; unfold FT_tau_i, FMor in |- *;
  simpl in |- *.
 intros i j h.
 elim h; intros g H; exact H.
 Qed. 

 Definition FT_tau := Build_Cone FT_tau_cone_law.

 Definition FT_tau_d := Lim_diese L_X FT_tau. 

 Definition FT_Apeps (i : FT_I) : Lim_EoQ --> FT_a i := FT_eps i.

 Lemma FT_eq_tau :
  forall i : FT_I, FT_tau i =_S FT_tau_d o FMor G (FT_Apeps i).
 Proof.
 intro i; apply Sym; apply (Prf_limit1 L_X FT_tau i).
 Qed.

  Section uaxG_verif.

  Variables (a' : A) (h : x --> G a').
 
  Definition FT_i0 := SSC2_i (s x) h.

  Definition FT_t := SSC2_t (s x) h.

  Definition FT_h_diese : Lim_EoQ --> a' := FT_Apeps FT_i0 o FT_t.

  Lemma FT_UA_law1 : UA_eq FT_tau_d h FT_h_diese.
  Proof.
  unfold UA_eq, FT_h_diese in |- *.
   apply Trans with (FT_tau_d o FMor G (FT_Apeps FT_i0) o FMor G FT_t).
  apply Comp_l; apply FComp.
   apply Trans with ((FT_tau_d o FMor G (FT_Apeps FT_i0)) o FMor G FT_t).
  apply Ass.
   apply Trans with (FT_tau FT_i0 o FMor G FT_t).
  apply Comp_r.
  apply Sym; apply (FT_eq_tau FT_i0). 
  apply Sym; apply (Prf_SSC2_law (s x) h).
  Qed.

  Variable FT_h' : Lim_EoQ --> a'.

  Hypothesis H : UA_eq FT_tau_d h FT_h'.
 
  Definition FT_j0 := SSC2_i (s x) FT_tau_d.

  Definition FT_t' := SSC2_t (s x) FT_tau_d.

  Definition FT_P : Pullback1 FT_t (FT_t' o FT_h') :=
    A_c (Fpulb FT_t (FT_t' o FT_h')).
 
  Definition FT_b := Fibred1_prod FT_P.

  Definition FT_p := Fibred1_p FT_P.
 
  Definition FT_q := Fibred1_q FT_P.

  Definition FT_GP' := G_c FT_P.

  Definition FT_GP : Fpullback1 (Fpulb FT_t (FT_t' o FT_h') o_F G) :=
    Build_Limit FT_GP'.

  Lemma FT_diag1 :
   Pullback_eq1 (FMor G FT_t) (FMor G (FT_t' o FT_h')) 
     (FT_f FT_i0) (FT_f FT_j0).
  Proof.
  unfold Pullback_eq1 in |- *.
   apply Trans with (FT_f FT_j0 o FMor G FT_t' o FMor G FT_h'). 
   apply Trans with ((FT_f FT_j0 o FMor G FT_t') o FMor G FT_h'). 
   apply Trans with h.
  apply Sym; apply (Prf_SSC2_law (s x) h).
   apply Trans with (FT_tau_d o FMor G FT_h').
  apply Sym; exact H.
  apply Comp_r.
  apply (Prf_SSC2_law (s x) FT_tau_d).
  apply Ass1.
  apply Comp_l.
  apply FComp1.
  Qed.

  Definition FT_k : x --> G FT_b := Pb1_diese FT_GP FT_diag1.
  
  Definition FT_m0 := SSC2_i (s x) FT_k. 

  Definition FT_t'' : FT_a FT_m0 --> FT_b := SSC2_t (s x) FT_k.

  Lemma FT_eq1 :
   Com_law (axf:=Build_Com_ob (FT_f FT_m0)) (bxg:=Build_Com_ob (FT_f FT_i0))
     (FT_t'' o FT_p).
  Proof.
  unfold Com_law in |- *; simpl in |- *.
   apply Trans with (FT_f FT_m0 o FMor G FT_t'' o FMor G FT_p).
   apply Trans with ((FT_f FT_m0 o FMor G FT_t'') o FMor G FT_p).
   apply Trans with (FT_k o FMor G FT_p).
  apply (Prf_pb1_law2 FT_GP FT_diag1).
  apply Comp_r; apply (Prf_SSC2_law (s x) FT_k).
  apply Ass1.
  apply Comp_l; apply FComp1.
  Qed.

  Canonical Structure FT_c1 := Build_Com_arrow FT_eq1.
 
  Lemma FT_eq2 :
   Com_law (axf:=Build_Com_ob (FT_f FT_m0)) (bxg:=Build_Com_ob (FT_f FT_j0))
     (FT_t'' o FT_q).
  Proof.
  unfold Com_law in |- *.
   apply Trans with (FT_f FT_m0 o FMor G FT_t'' o FMor G FT_q).
   apply Trans with ((FT_f FT_m0 o FMor G FT_t'') o FMor G FT_q).
   apply Trans with (FT_k o FMor G FT_q).
  apply (Prf_pb1_law3 FT_GP FT_diag1).
  apply Comp_r; apply (Prf_SSC2_law (s x) FT_k).
  apply Ass1.
  apply Comp_l; apply FComp1.
  Qed.

  Canonical Structure FT_c2 := Build_Com_arrow FT_eq2.
 
  Lemma FT_diag2 : FT_Apeps FT_i0 =_S (FT_Apeps FT_m0 o FT_t'') o FT_p.
  Proof.
   apply Trans with (FT_Apeps FT_m0 o FT_t'' o FT_p).
  apply (Eq_cone FT_eps FT_c1).
  apply Ass.
  Qed.

  Lemma FT_diag3 : FT_Apeps FT_j0 =_S (FT_Apeps FT_m0 o FT_t'') o FT_q.
  Proof.
   apply Trans with (FT_Apeps FT_m0 o FT_t'' o FT_q).
  apply (Eq_cone FT_eps FT_c2).
  apply Ass.
  Qed.

  Lemma FT_diag4 : FT_Apeps FT_i0 o FT_t =_S FT_Apeps FT_j0 o FT_t' o FT_h'.
  Proof. 
   apply Trans with (((FT_Apeps FT_m0 o FT_t'') o FT_p) o FT_t). 
  apply Comp_r; apply FT_diag2.
   apply Trans with (((FT_Apeps FT_m0 o FT_t'') o FT_q) o FT_t' o FT_h').
   apply Trans with ((FT_Apeps FT_m0 o FT_t'') o FT_p o FT_t). 
  apply Ass1.
   apply Trans with ((FT_Apeps FT_m0 o FT_t'') o FT_q o FT_t' o FT_h').
  apply Comp_l; apply (Prf_pb1_law1 FT_P).
  apply Ass.
  apply Comp_r; apply Sym; apply FT_diag3.
  Qed.
 
  Lemma FT_eq3 :
   forall i : FT_I,
   Com_law (axf:=Build_Com_ob (FT_f FT_j0)) (bxg:=Build_Com_ob (FT_f i))
     (FT_t' o FT_Apeps i). 
  Proof.
  unfold Com_law in |- *; simpl in |- *; intro i.
   apply Trans with (FT_f FT_j0 o FMor G FT_t' o FMor G (FT_Apeps i)).
   apply Trans with ((FT_f FT_j0 o FMor G FT_t') o FMor G (FT_Apeps i)).
   apply Trans with (FT_tau_d o FMor G (FT_Apeps i)).
  apply (FT_eq_tau i).
  apply Comp_r.
  apply (Prf_SSC2_law (s x) FT_tau_d).
  apply Ass1.
  apply Comp_l; apply FComp1.
  Qed.
 
  Canonical Structure FT_c3 (i : FT_I) := Build_Com_arrow (FT_eq3 i).
 
  Lemma FT_eq4 : FT_Apeps FT_j0 o FT_t' =_S Id Lim_EoQ.
  Proof.
   apply Trans with (Lim_diese L_A FT_eps).
  apply (Prf_limit2 L_A).
  unfold Limit_eq in |- *; intro i.
   apply Trans with (FT_Apeps FT_j0 o FT_t' o FT_Apeps i).
  apply Ass1.
  apply Sym; apply (Eq_cone FT_eps (j:=i) (FT_c3 i)).
  
  apply Sym; apply (Prf_limit2 L_A).
  unfold Limit_eq in |- *; intro i.
  apply Idl.
  Qed.
  
  Lemma FT_h_diese_unique : FT_h' =_S FT_h_diese.
  Proof.
  unfold FT_h_diese in |- *.
   apply Trans with (Id Lim_EoQ o FT_h').
  apply Idl1.
   apply Trans with (FT_Apeps FT_j0 o FT_t' o FT_h').
   apply Trans with ((FT_Apeps FT_j0 o FT_t') o FT_h').
  apply Comp_r.
  apply Sym; apply FT_eq4.
  apply Ass1.
  apply Sym; apply FT_diag4.
  Qed.
 
  End uaxG_verif.

 Canonical Structure FT_UA :=
   Build_UA (Build_IsUA FT_UA_law1 FT_h_diese_unique).

 End uaxG.

Definition AFT1 : LeftAdj G := LeftAdjUA FT_UA.

End freyd_th_2.
