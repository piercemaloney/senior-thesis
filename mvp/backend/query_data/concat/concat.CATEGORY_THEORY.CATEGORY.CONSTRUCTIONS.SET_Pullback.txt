
Require Export Pullbacks.
(* Pullbacks:
Require Export CatProperty.

Set Implicit Arguments.
Unset Strict Implicit.

Section pulbs_def.

Variables (C : Category) (a b c : C) (f : a --> b) (g : c --> b).

 Section pulbs_laws.

 Variables (Fibred_prod : C) (Fibred_p : Fibred_prod --> a)
   (Fibred_q : Fibred_prod --> c).

 Definition Pullback_eq1 (r : C) (t1 : r --> a) (t2 : r --> c) :=
   t1 o f =_S t2 o g.

 Definition Pullback_law1 := Pullback_eq1 Fibred_p Fibred_q.

 Variable
   Pb_diese :
     forall (r : C) (t1 : r --> a) (t2 : r --> c),
     Pullback_eq1 t1 t2 -> (r --> Fibred_prod).

 Definition Pullback_eq2 (x y z : C) (f1 : x --> y) 
   (f2 : z --> y) (f3 : x --> z) := f1 =_S f3 o f2.

 Definition Pullback_law2 :=
   forall (r : C) (t1 : r --> a) (t2 : r --> c) (pe : Pullback_eq1 t1 t2),
   Pullback_eq2 t1 Fibred_p (Pb_diese pe).

 Definition Pullback_law3 :=
   forall (r : C) (t1 : r --> a) (t2 : r --> c) (pe : Pullback_eq1 t1 t2),
   Pullback_eq2 t2 Fibred_q (Pb_diese pe).

 Definition Pullback_law4 :=
   forall (r : C) (t1 : r --> a) (t2 : r --> c) (pe : Pullback_eq1 t1 t2)
     (g : r --> Fibred_prod),
   Pullback_eq2 t1 Fibred_p g ->
   Pullback_eq2 t2 Fibred_q g -> g =_S Pb_diese pe.

 End pulbs_laws.

Structure Pullback : Type := 
  {Fibred_prod : C;
   Fibred_p : Fibred_prod --> a;
   Fibred_q : Fibred_prod --> c;
   Prf_pb_law1 : Pullback_law1 Fibred_p Fibred_q;
   Pb_diese :
    forall (r : C) (t1 : r --> a) (t2 : r --> c),
    Pullback_eq1 t1 t2 -> (r --> Fibred_prod);
   Prf_pb_law2 : Pullback_law2 Fibred_p Pb_diese;
   Prf_pb_law3 : Pullback_law3 Fibred_q Pb_diese;
   Prf_pb_law4 : Pullback_law4 Fibred_p Fibred_q Pb_diese}.
 
End pulbs_def. *)
Require Export Setoid_prop.
(* Setoid_prop:
Require Export Map.

Set Implicit Arguments.
Unset Strict Implicit.

Section sub_setoid.

Variable U : Setoid.

Definition Reg_law (A : U -> Prop) := forall x y : U, x =_S y -> A x -> A y.

Structure > Setoid_pred : Type := 
  {Pred :> U -> Prop; Prf_reg :> Reg_law Pred}.

Variable A : Setoid_pred.

Structure SubType : Type :=  {Elt_sub : U; Prf_constr : A Elt_sub}.

Definition Equal_SubType (a b : SubType) := Elt_sub a =_S Elt_sub b.

Lemma Equal_SubType_equiv : Equivalence Equal_SubType.

Canonical Structure SubSetoid : Setoid := Equal_SubType_equiv.

End sub_setoid.

Section restricted_map.

Variables (A B : Setoid) (f : Map A B) (P : Setoid_pred A).

Definition Restricted_fun (a : SubSetoid P) := f (Elt_sub a).

Lemma Restricted_map_law : Map_law Restricted_fun.

Canonical Structure RestrictedMap := Build_Map Restricted_map_law.

End restricted_map. *)
Require Export SET.
(* SET:
Require Export Category.

Set Implicit Arguments.
Unset Strict Implicit.

Lemma Comp_map_congl : Congl_law Comp_map.

Lemma Comp_map_congr : Congr_law Comp_map.

Definition Comp_SET := Build_Comp Comp_map_congl Comp_map_congr.

Lemma Assoc_SET : Assoc_law Comp_SET.

Definition Id_SET := Id_map.
 
Lemma Idl_SET : Idl_law Comp_SET Id_SET.

Lemma Idr_SET : Idr_law Comp_SET Id_SET.

Canonical Structure SET := Build_Category Assoc_SET Idl_SET Idr_SET. *)
Require Export SetoidPROD.
(* SetoidPROD:
Require Export Map.

Set Implicit Arguments.
Unset Strict Implicit.

Section s_prod.

Variable A B : Setoid.

Structure Sprod : Type :=  {Sprod_l : A; Sprod_r : B}.

Definition Equal_Sprod (a1xb1 a2xb2 : Sprod) :=
  Sprod_l a1xb1 =_S Sprod_l a2xb2 /\ Sprod_r a1xb1 =_S Sprod_r a2xb2.

Lemma Equal_Sprod_equiv : Equivalence Equal_Sprod.

Canonical Structure SPROD : Setoid := Equal_Sprod_equiv.

Lemma Proj1_SPROD_map_law : Map_law (Sprod_l:SPROD -> A).

Canonical Structure Proj1_SPROD : Map SPROD A := Proj1_SPROD_map_law.

Lemma Proj2_SPROD_map_law : Map_law (Sprod_r:SPROD -> B).

Canonical Structure Proj2_SPROD : Map SPROD B := Proj2_SPROD_map_law.

End s_prod. *)

Set Implicit Arguments.
Unset Strict Implicit.

Section s_pulb_def.

Variables (A B C : Setoid) (f : Map A B) (g : Map C B).

Definition S_pulb_pred (axc : SPROD A C) :=
  f (Sprod_l axc) =_S g (Sprod_r axc).

Lemma S_pulb_reg : Reg_law S_pulb_pred.
Proof.
unfold Reg_law, S_pulb_pred in |- *; intros a1xc1 a2xc2 H1 H2.
elim H1; intros H3 H4.
apply Trans with (f (Sprod_l a1xc1)).
apply Pres1; apply Sym; assumption.
apply Trans with (g (Sprod_r a1xc1)).
assumption.
apply Pres1; assumption.
Qed.

Canonical Structure S_pulb_constr := Build_Setoid_pred S_pulb_reg.

Definition S_pulb_prod := SubSetoid S_pulb_constr.

Definition S_pulb_p := RestrictedMap (Proj1_SPROD A C) S_pulb_constr.

Definition S_pulb_q := RestrictedMap (Proj2_SPROD A C) S_pulb_constr.

Lemma S_pulb_law1 : Pullback_law1 f g S_pulb_p S_pulb_q.
Proof.
unfold Pullback_law1, Pullback_eq1 in |- *; simpl in |- *.
unfold Ext in |- *; simpl in |- *; intro x; elim x; unfold Comp_fun in |- *;
 simpl in |- *.
trivial.
Qed.

 Section s_pulb_diese_def.

 Variables (D : Setoid) (t1 : Map D A) (t2 : Map D C).
 Hypothesis H : Pullback_eq1 f g t1 t2.
 
 Lemma Check_S_pulb_constr :
  forall d : D, S_pulb_constr (Build_Sprod (t1 d) (t2 d)).
 Proof.
 intro d; exact (H d).
 Qed. 

 Canonical Structure S_pulb_fun (d : D) :=
   Build_SubType (Check_S_pulb_constr d).
 
 Lemma S_pulb_map_law : Map_law S_pulb_fun.
 Proof. 
 unfold Map_law in |- *; simpl in |- *; unfold Equal_Sprod in |- *;
  simpl in |- *.
 intros x y H1; split; apply Pres1; trivial.
 Qed.

 Canonical Structure S_pulb_diese := Build_Map S_pulb_map_law.

 End s_pulb_diese_def.

Lemma S_pulb_law2 : Pullback_law2 S_pulb_p S_pulb_diese.
Proof.
unfold Pullback_law2, Pullback_eq2 in |- *; simpl in |- *.
unfold Ext in |- *; simpl in |- *; intros; simpl in |- *.
apply Refl.
Qed.

Lemma S_pulb_law3 : Pullback_law3 S_pulb_q S_pulb_diese.
Proof.
unfold Pullback_law3, Pullback_eq2 in |- *; simpl in |- *.
unfold Ext in |- *; simpl in |- *; intros; simpl in |- *.
apply Refl.
Qed.

Lemma S_pulb_law4 : Pullback_law4 S_pulb_p S_pulb_q S_pulb_diese.
Proof.
unfold Pullback_law4, Pullback_eq2 in |- *; simpl in |- *.
unfold Ext in |- *; simpl in |- *; intros D t1 t2 H h H1 H2 x.
unfold Equal_Sprod in |- *; simpl in |- *; split.
apply Sym; apply H1.
apply Sym; apply H2.
Qed.

Canonical Structure S_pulb :=
  Build_Pullback S_pulb_law1 S_pulb_law2 S_pulb_law3 S_pulb_law4.

End s_pulb_def.

