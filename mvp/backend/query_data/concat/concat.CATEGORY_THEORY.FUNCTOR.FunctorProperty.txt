
Require Export Functor.
(* Functor:
Require Export Setoid_dup1.
Require Export Hom_Equality.

Set Implicit Arguments.
Unset Strict Implicit.

Section funct_def.

Variable C D : Category.

 Section funct_laws.

 Variables (FOb : C -> D)
   (FMap : forall a b : C, Map (a --> b) (FOb a --> FOb b)).

 Definition Fcomp_law :=
   forall (a b c : C) (f : a --> b) (g : b --> c),
   FMap a c (f o g) =_S FMap a b f o FMap b c g.

 Definition Fid_law := forall a : C, FMap a a (Id a) =_S Id (FOb a).

 End funct_laws.

Structure Functor : Type := 
  {FOb :> C -> D;
   FMap : forall a b : C, Map (a --> b) (FOb a --> FOb b);
   Prf_Fcomp_law : Fcomp_law FMap;
   Prf_Fid_law : Fid_law FMap}.

Definition FMor (F : Functor) (a b : C) (f : a --> b) := FMap F a b f.

Lemma FPres :
 forall (F : Functor) (a b : C) (f g : a --> b),
 f =_S g -> FMor F f =_S FMor F g.

Lemma FComp :
 forall (F : Functor) (a b c : C) (f : a --> b) (g : b --> c),
 FMor F (f o g) =_S FMor F f o FMor F g.

Lemma FComp1 :
 forall (F : Functor) (a b c : C) (f : a --> b) (g : b --> c),
 FMor F f o FMor F g =_S FMor F (f o g).

Lemma FId : forall (F : Functor) (a : C), FMor F (Id a) =_S Id (FOb F a).

Lemma FId1 : forall (F : Functor) (a : C), Id (FOb F a) =_S FMor F (Id a).

End funct_def.

Section funct_setoid.

Variable C D : Category. 

Definition Equal_Functor (F G : Functor C D) :=
  forall (a b : C) (f : a --> b), FMor F f =_H FMor G f.

Lemma Equal_Functor_equiv : Equivalence Equal_Functor.

Canonical Structure Functor_setoid := Build_Setoid' Equal_Functor_equiv.

End funct_setoid.

Infix "=_F" := Equal_Functor (at level 70).

Section Comp_F.

Variables (C D E : Category) (G : Functor C D) (H : Functor D E).

Definition Comp_FOb (a : C) := H (G a).

 Section comp_functor_map.

 Variable a b : C.

 Definition Comp_FMor (f : a --> b) := FMor H (FMor G f). 

 Lemma Comp_FMap_law : Map_law Comp_FMor.

 Definition Comp_FMap :=
   Build_Map (B:=Comp_FOb a --> Comp_FOb b) Comp_FMap_law.

 End comp_functor_map.

Lemma Comp_Functor_comp_law : Fcomp_law Comp_FMap.

Lemma Comp_Functor_id_law : Fid_law Comp_FMap.

Canonical Structure Comp_Functor :=
  Build_Functor Comp_Functor_comp_law Comp_Functor_id_law.

End Comp_F.

Infix "o_F" := Comp_Functor (at level 20, right associativity). *)
Require Export CatProperty.
(* CatProperty:
Require Export Dual.

Set Implicit Arguments.
Unset Strict Implicit.

Section epic_monic_def.

Variables (C : Category) (a b : C).
 
Definition Epic_law (f : a --> b) :=
  forall (c : C) (g h : b --> c), f o g =_S f o h -> g =_S h.

Structure > Epic : Type := 
  {Epic_mor : a --> b; Prf_isEpic :> Epic_law Epic_mor}.

Definition Monic_law (f : b --> a) :=
  forall (c : C) (g h : c --> b), g o f =_S h o f -> g =_S h.

Structure > Monic : Type := 
  {Monic_mor : b --> a; Prf_isMonic :> Monic_law Monic_mor}.

End epic_monic_def.

Section iso_def.

Variable C : Category.

Definition RIso_law (a b : C) (f : a --> b) (f1 : b --> a) := f1 o f =_S Id b.

Variable a b : C.

Definition AreIsos (f : a --> b) (f1 : b --> a) :=
  RIso_law f f1 /\ RIso_law f1 f.

Structure > Iso : Type := 
  {Iso_mor : a --> b; Inv_iso : b --> a; Prf_Iso :> AreIsos Iso_mor Inv_iso}.

Lemma Idl_inv : forall i : Iso, RIso_law (Iso_mor i) (Inv_iso i).

Lemma Idr_inv : forall i : Iso, RIso_law (Inv_iso i) (Iso_mor i).

Lemma Inv_iso_unique :
 forall f g : Iso, Iso_mor f =_S Iso_mor g -> Inv_iso f =_S Inv_iso g.

Lemma RightInv_epic :
 forall (h : a --> b) (h1 : b --> a), RIso_law h h1 -> Epic_law h.

End iso_def.

Coercion RightInv_epic : RIso_law >-> Epic_law.

Section initial_def.

Variable C : Category.

Definition IsInitial (a : C) (h : forall b : C, a --> b) :=
  forall (b : C) (f : a --> b), f =_S h b.
  
Structure > Initial : Type := 
  {Initial_ob : C;
   MorI : forall b : C, Initial_ob --> b;
   Prf_isInitial :> IsInitial MorI}.

Definition At_most_1mor (a b : C) := forall f g : a --> b, f =_S g.

Lemma UniqueI : forall (i : Initial) (b : C), At_most_1mor (Initial_ob i) b.

Lemma I_unic : forall i1 i2 : Initial, Iso (Initial_ob i1) (Initial_ob i2).

End initial_def.

Section terminal_def.

Variable C : Category.

Definition IsTerminal (b : C) (h : forall a : C, a --> b) :=
  forall (a : C) (f : a --> b), f =_S h a. 

Structure > Terminal : Type := 
  {Terminal_ob : C;
   MorT : forall a : C, a --> Terminal_ob;
   Prf_isTerminal :> IsTerminal MorT}.

Lemma UniqueT : forall (t : Terminal) (a : C), At_most_1mor a (Terminal_ob t).

End terminal_def.

Lemma Initial_dual :
 forall (C : Category) (a : C) (h : forall b : C, a --> b),
 IsInitial h -> IsTerminal (C:=Dual C) h.

Coercion Initial_dual : IsInitial >-> IsTerminal.

Definition IsTerminal' (C : Category) (b : C) (h : forall a : C, a --> b) :=
  IsInitial (C:=Dual C) h. *)

Set Implicit Arguments.
Unset Strict Implicit.

Section functor_prop.

Variable C D : Category. 

Lemma Functor_preserves_iso :
 forall (F : Functor C D) (a b : C), Iso a b -> Iso (F a) (F b).
Proof.
intros F a b f.
apply Build_Iso with (FMor F (Iso_mor f)) (FMor F (Inv_iso f)).
red in |- *; split; red in |- *.
 apply Trans with (FMor F (Inv_iso f o Iso_mor f)).
apply FComp1.
 apply Trans with (FMor F (Id b)).
apply FPres; apply (Idl_inv f).
apply FId.
 apply Trans with (FMor F (Iso_mor f o Inv_iso f)).
apply FComp1.
 apply Trans with (FMor F (Id a)).
apply FPres; apply (Idr_inv f).
apply FId.
Qed.

Definition Faithful_law (F : Functor C D) :=
  forall (a b : C) (f g : a --> b), FMor F f =_S FMor F g -> f =_S g.

Structure > Faithful : Type := 
  {Faithful_functor :> Functor C D;
   Prf_isFaithful :> Faithful_law Faithful_functor}.

Definition Full_law (F : Functor C D)
  (H : forall a b : C, (F a --> F b) -> (a --> b)) :=
  forall (a b : C) (h : F a --> F b), h =_S FMor F (H a b h).

Structure > Full : Type := 
  {Full_functor :> Functor C D;
   Full_mor :
    forall a b : C, (Full_functor a --> Full_functor b) -> (a --> b);
   Prf_isFull :> Full_law Full_mor}.

End functor_prop.

Section comp_functor_prop.

Variables (C D E : Category) (F : Functor C D) (G : Functor D E).

Lemma IsFaithful_comp :
 Faithful_law F -> Faithful_law G -> Faithful_law (F o_F G).
Proof.
intros H1 H2; unfold Faithful_law in |- *; intros a b f g.
unfold Comp_Functor, FMor in |- *; simpl in |- *.
unfold Comp_FMor in |- *; auto.
Qed.

Variables (F1 : forall a b : C, (F a --> F b) -> (a --> b))
  (G1 : forall a b : D, (G a --> G b) -> (a --> b)).

Lemma IsFull_comp :
 Full_law F1 ->
 Full_law G1 ->
 let H1 := fun (a b : C) (h : G (F a) --> G (F b)) => F1 (G1 h) in
 Full_law (F:=F o_F G) H1.
Proof.
intros p1 p2.
unfold Full_law in |- *; intros a b h.
unfold FMor in |- *; simpl in |- *; unfold Comp_FMor, Comp_FOb in |- *.
 apply Trans with (FMor G (G1 h)).
apply (p2 _ _ h).
apply FPres.
apply (p1 _ _ (G1 h)).
Qed.

End comp_functor_prop.

