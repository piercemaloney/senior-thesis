
Require Export Category.
(* Category:
Require Export Map2.

Set Implicit Arguments.
Unset Strict Implicit.

Section cat.

Variables (Ob : Type) (Hom : Ob -> Ob -> Setoid).

Infix "-->" := Hom (at level 95, right associativity).

Variable Op_comp : forall a b c : Ob, Map2 (a --> b) (b --> c) (a --> c).

Definition Cat_comp (a b c : Ob) (f : a --> b) (g : b --> c) :=
  Op_comp a b c f g.

Infix "o" := Cat_comp (at level 20, right associativity).

Definition Assoc_law :=
  forall (a b c d : Ob) (f : a --> b) (g : b --> c) (h : c --> d),
  f o g o h =_S (f o g) o h.

Variable Id : forall a : Ob, a --> a.

Definition Idl_law := forall (a b : Ob) (f : a --> b), Id _ o f =_S f.

Definition Idr_law := forall (a b : Ob) (f : b --> a), f =_S f o Id _.

End cat.

Structure Category : Type := 
  {Ob :> Type;
   Hom : Ob -> Ob -> Setoid;
   Op_comp : forall a b c : Ob, Map2 (Hom a b) (Hom b c) (Hom a c);
   Id : forall a : Ob, Hom a a;
   Prf_ass : Assoc_law Op_comp;
   Prf_idl : Idl_law Op_comp Id;
   Prf_idr : Idr_law Op_comp Id}.

Definition Comp (C : Category) := Cat_comp (Op_comp (c:=C)).

Infix "-->" := Hom (at level 95, right associativity).
Infix "o" := Comp (at level 20, right associativity).

Lemma Ass :
 forall (C : Category) (a b c d : C) (f : a --> b) 
   (g : b --> c) (h : c --> d), f o g o h =_S (f o g) o h.

Lemma Ass1 :
 forall (C : Category) (a b c d : C) (f : a --> b) 
   (g : b --> c) (h : c --> d), (f o g) o h =_S f o g o h.

Lemma Idl : forall (C : Category) (a b : C) (f : a --> b), Id _ o f =_S f.

Lemma Idl1 : forall (C : Category) (a b : C) (f : a --> b), f =_S Id _ o f.

Lemma Idr : forall (C : Category) (a b : C) (f : b --> a), f =_S f o Id _.

Lemma Idr1 : forall (C : Category) (a b : C) (f : a --> b), f o Id _ =_S f.

Lemma Idrl :
 forall (C : Category) (a b : C) (f : a --> b), f o Id _ =_S Id _ o f.

Lemma Idlr :
 forall (C : Category) (a b : C) (f : a --> b), Id _ o f =_S f o Id _.

Section composition_to_operator.

Variables (A : Type) (H : A -> A -> Setoid)
  (Cfun : forall a b c : A, H a b -> H b c -> H a c).

Definition Congl_law :=
  forall (a b c : A) (f g : H b c) (h : H a b),
  f =_S g -> Cfun h f =_S Cfun h g. 

Definition Congr_law :=
  forall (a b c : A) (f g : H a b) (h : H b c),
  f =_S g -> Cfun f h =_S Cfun g h. 

Definition Cong_law :=
  forall (a b c : A) (f f' : H a b) (g g' : H b c),
  f =_S f' -> g =_S g' -> Cfun f g =_S Cfun f' g'. 

Hypothesis pcgl : Congl_law.
Hypothesis pcgr : Congr_law.

Variable a b c : A.

Definition Build_Comp :=
  Build_Map2 (pcgl (a:=a) (b:=b) (c:=c)) (pcgr (a:=a) (b:=b) (c:=c)).

End composition_to_operator.

Section cat_cong.

Variable C : Category.

Lemma Comp_l :
 forall (a b c : C) (f g : b --> c) (h : a --> b), f =_S g -> h o f =_S h o g. 

Lemma Comp_r :
 forall (a b c : C) (f g : a --> b) (h : b --> c), f =_S g -> f o h =_S g o h. 

Lemma Comp_lr :
 forall (a b c : C) (f f' : a --> b) (g g' : b --> c),
 f =_S f' -> g =_S g' -> f o g =_S f' o g'. 

End cat_cong. *)
Require Export BasicTypes.
(* BasicTypes:
Inductive EmptyType : Type :=.

Inductive UnitType : Set :=
    Elt : UnitType.

Hint Resolve Elt.

Inductive TwoElts : Type :=
  | Elt1 : TwoElts
  | Elt2 : TwoElts. *)

Set Implicit Arguments.
Unset Strict Implicit.

Inductive PULB_ob : Type :=
  | P1 : PULB_ob
  | P2 : PULB_ob
  | P3 : PULB_ob.

Inductive PULB_mor : PULB_ob -> PULB_ob -> Type :=
  | IP1 : PULB_mor P1 P1
  | IP2 : PULB_mor P2 P2
  | IP3 : PULB_mor P3 P3
  | F12 : PULB_mor P1 P2
  | F32 : PULB_mor P3 P2.

Lemma PULB_11_P :
 (PULB_mor P1 P1 -> Prop) -> forall a b : PULB_ob, PULB_mor a b -> Prop.
Proof.
intros P a b; elim a; elim b.
exact P.
intro x; exact True.
intro x; exact True.
intro x; exact True.
intro x; exact True.
intro x; exact True.
intro x; exact True.
intro x; exact True.
intro x; exact True.
Defined.

Lemma PULB_11_ind :
 forall P : PULB_mor P1 P1 -> Prop, P IP1 -> forall x : PULB_mor P1 P1, P x.
Proof.
intros P Pi1 x.
change (PULB_11_P P x) in |- *.
apply
 (PULB_mor_ind (P:=fun (a b : PULB_ob) (f : PULB_mor a b) => PULB_11_P P f));
 simpl in |- *.
exact Pi1.
trivial.
trivial.
trivial.
trivial.
Qed.

Lemma PULB_22_P :
 (PULB_mor P2 P2 -> Prop) -> forall a b : PULB_ob, PULB_mor a b -> Prop.
Proof.
intros P a b; elim a; elim b.
intro x; exact True.
intro x; exact True.
intro x; exact True.
intro x; exact True.
exact P.
intro x; exact True.
intro x; exact True.
intro x; exact True.
intro x; exact True.
Defined.

Lemma PULB_22_ind :
 forall P : PULB_mor P2 P2 -> Prop, P IP2 -> forall x : PULB_mor P2 P2, P x.
Proof.
intros P Pi1 x.
change (PULB_22_P P x) in |- *.
apply
 (PULB_mor_ind (P:=fun (a b : PULB_ob) (f : PULB_mor a b) => PULB_22_P P f));
 simpl in |- *.
trivial.
exact Pi1.
trivial.
trivial.
trivial.
Qed.

Lemma PULB_33_P :
 (PULB_mor P3 P3 -> Prop) -> forall a b : PULB_ob, PULB_mor a b -> Prop.
Proof.
intros P a b; elim a; elim b.
intro x; exact True.
intro x; exact True.
intro x; exact True.
intro x; exact True.
intro x; exact True.
intro x; exact True.
intro x; exact True.
intro x; exact True.
exact P.
Defined.

Lemma PULB_33_ind :
 forall P : PULB_mor P3 P3 -> Prop, P IP3 -> forall x : PULB_mor P3 P3, P x.
Proof.
intros P Pi1 x.
change (PULB_33_P P x) in |- *.
apply
 (PULB_mor_ind (P:=fun (a b : PULB_ob) (f : PULB_mor a b) => PULB_33_P P f));
 simpl in |- *.
trivial.
trivial.
exact Pi1.
trivial.
trivial.
Qed.

Lemma PULB_12_P :
 (PULB_mor P1 P2 -> Prop) -> forall a b : PULB_ob, PULB_mor a b -> Prop.
Proof.
intros P a b; elim a; elim b.
intro x; exact True.
exact P.
intro x; exact True.
intro x; exact True.
intro x; exact True.
intro x; exact True.
intro x; exact True.
intro x; exact True.
intro x; exact True.
Defined.

Lemma PULB_12_ind :
 forall P : PULB_mor P1 P2 -> Prop, P F12 -> forall x : PULB_mor P1 P2, P x.
Proof.
intros P Pi1 x.
change (PULB_12_P P x) in |- *.
apply
 (PULB_mor_ind (P:=fun (a b : PULB_ob) (f : PULB_mor a b) => PULB_12_P P f));
 simpl in |- *.
trivial.
trivial.
trivial.
exact Pi1.
trivial.
Qed.

Lemma PULB_32_P :
 (PULB_mor P3 P2 -> Prop) -> forall a b : PULB_ob, PULB_mor a b -> Prop.
Proof.
intros P a b; elim a; elim b.
intro x; exact True.
intro x; exact True.
intro x; exact True.
intro x; exact True.
intro x; exact True.
intro x; exact True.
intro x; exact True.
exact P.
intro x; exact True.
Defined.

Lemma PULB_32_ind :
 forall P : PULB_mor P3 P2 -> Prop, P F32 -> forall x : PULB_mor P3 P2, P x.
Proof.
intros P Pi1 x.
change (PULB_32_P P x) in |- *.
apply
 (PULB_mor_ind (P:=fun (a b : PULB_ob) (f : PULB_mor a b) => PULB_32_P P f));
 simpl in |- *.
trivial.
trivial.
trivial.
trivial.
exact Pi1.
Qed.

Lemma PULB_21_P :
 (PULB_mor P2 P1 -> Prop) -> forall a b : PULB_ob, PULB_mor a b -> Prop.
Proof.
intros P a b; elim a; elim b.
intro x; exact True.
intro x; exact True.
intro x; exact True.
exact P.
intro x; exact True.
intro x; exact True.
intro x; exact True.
intro x; exact True.
intro x; exact True.
Defined.

Lemma PULB_21_ind :
 forall (P : PULB_mor P2 P1 -> Prop) (x : PULB_mor P2 P1), P x.
Proof.
intros P x.
change (PULB_21_P P x) in |- *.
apply
 (PULB_mor_ind (P:=fun (a b : PULB_ob) (f : PULB_mor a b) => PULB_21_P P f));
 simpl in |- *; auto.
Qed.

Lemma PULB_21_T :
 (PULB_mor P2 P1 -> Type) -> forall a b : PULB_ob, PULB_mor a b -> Type.
Proof.
intros P a b; elim a; elim b.
intro x; exact UnitType.
intro x; exact UnitType.
intro x; exact UnitType.
exact P.
intro x; exact UnitType.
intro x; exact UnitType.
intro x; exact UnitType.
intro x; exact UnitType.
intro x; exact UnitType.
Defined.

Lemma PULB_21_rect :
 forall (P : PULB_mor P2 P1 -> Type) (x : PULB_mor P2 P1), P x.
Proof.
intros P x.
change (PULB_21_T P x) in |- *.
apply
 (PULB_mor_rect (P:=fun (a b : PULB_ob) (f : PULB_mor a b) => PULB_21_T P f));
 simpl in |- *; auto.
Qed.

Lemma PULB_31_P :
 (PULB_mor P3 P1 -> Prop) -> forall a b : PULB_ob, PULB_mor a b -> Prop.
Proof.
intros P a b; elim a; elim b.
intro x; exact True.
intro x; exact True.
intro x; exact True.
intro x; exact True.
intro x; exact True.
intro x; exact True.
exact P.
intro x; exact True.
intro x; exact True.
Defined.

Lemma PULB_31_ind :
 forall (P : PULB_mor P3 P1 -> Prop) (x : PULB_mor P3 P1), P x.
Proof.
intros P x.
change (PULB_31_P P x) in |- *.
apply
 (PULB_mor_ind (P:=fun (a b : PULB_ob) (f : PULB_mor a b) => PULB_31_P P f));
 simpl in |- *; auto.
Qed.

Lemma PULB_31_T :
 (PULB_mor P3 P1 -> Type) -> forall a b : PULB_ob, PULB_mor a b -> Type.
Proof.
intros P a b; elim a; elim b.
intro x; exact UnitType.
intro x; exact UnitType.
intro x; exact UnitType.
intro x; exact UnitType.
intro x; exact UnitType.
intro x; exact UnitType.
exact P.
intro x; exact UnitType.
intro x; exact UnitType.
Defined.

Lemma PULB_31_rect :
 forall (P : PULB_mor P3 P1 -> Type) (x : PULB_mor P3 P1), P x.
Proof.
intros P x.
change (PULB_31_T P x) in |- *.
apply
 (PULB_mor_rect (P:=fun (a b : PULB_ob) (f : PULB_mor a b) => PULB_31_T P f));
 simpl in |- *; auto.
Qed.

Lemma PULB_13_P :
 (PULB_mor P1 P3 -> Prop) -> forall a b : PULB_ob, PULB_mor a b -> Prop.
Proof.
intros P a b; elim a; elim b.
intro x; exact True.
intro x; exact True.
exact P.
intro x; exact True.
intro x; exact True.
intro x; exact True.
intro x; exact True.
intro x; exact True.
intro x; exact True.
Defined.

Lemma PULB_13_ind :
 forall (P : PULB_mor P1 P3 -> Prop) (x : PULB_mor P1 P3), P x.
Proof.
intros P x.
change (PULB_13_P P x) in |- *.
apply
 (PULB_mor_ind (P:=fun (a b : PULB_ob) (f : PULB_mor a b) => PULB_13_P P f));
 simpl in |- *; auto.
Qed.

Lemma PULB_13_T :
 (PULB_mor P1 P3 -> Type) -> forall a b : PULB_ob, PULB_mor a b -> Type.
Proof.
intros P a b; elim a; elim b.
intro x; exact UnitType.
intro x; exact UnitType.
exact P.
intro x; exact UnitType.
intro x; exact UnitType.
intro x; exact UnitType.
intro x; exact UnitType.
intro x; exact UnitType.
intro x; exact UnitType.
Defined.

Lemma PULB_13_rect :
 forall (P : PULB_mor P1 P3 -> Type) (x : PULB_mor P1 P3), P x.
Proof.
intros P x.
change (PULB_13_T P x) in |- *.
apply
 (PULB_mor_rect (P:=fun (a b : PULB_ob) (f : PULB_mor a b) => PULB_13_T P f));
 simpl in |- *; auto.
Qed.

Lemma PULB_23_P :
 (PULB_mor P2 P3 -> Prop) -> forall a b : PULB_ob, PULB_mor a b -> Prop.
Proof.
intros P a b; elim a; elim b.
intro x; exact True.
intro x; exact True.
intro x; exact True.
intro x; exact True.
intro x; exact True.
exact P.
intro x; exact True.
intro x; exact True.
intro x; exact True.
Defined.

Lemma PULB_23_ind :
 forall (P : PULB_mor P2 P3 -> Prop) (x : PULB_mor P2 P3), P x.
Proof.
intros P x.
change (PULB_23_P P x) in |- *.
apply
 (PULB_mor_ind (P:=fun (a b : PULB_ob) (f : PULB_mor a b) => PULB_23_P P f));
 simpl in |- *; auto.
Qed.

Lemma PULB_23_T :
 (PULB_mor P2 P3 -> Type) -> forall a b : PULB_ob, PULB_mor a b -> Type.
Proof.
intros P a b; elim a; elim b.
intro x; exact UnitType.
intro x; exact UnitType.
intro x; exact UnitType.
intro x; exact UnitType.
intro x; exact UnitType.
exact P.
intro x; exact UnitType.
intro x; exact UnitType.
intro x; exact UnitType.
Defined.

Lemma PULB_23_rect :
 forall (P : PULB_mor P2 P3 -> Type) (x : PULB_mor P2 P3), P x.
Proof.
intros P x.
change (PULB_23_T P x) in |- *.
apply
 (PULB_mor_rect (P:=fun (a b : PULB_ob) (f : PULB_mor a b) => PULB_23_T P f));
 simpl in |- *; auto.
Qed.

 Section pulb_setoid_def.

 Variable a b : PULB_ob.

 Definition Equal_PULB_mor (f g : PULB_mor a b) := True.
 
 Lemma Equal_PULB_mor_equiv : Equivalence Equal_PULB_mor.
 Proof.
 apply Build_Equivalence; [ trivial | apply Build_Partial_equivalence ];
  red in |- *; unfold Equal_PULB_mor in |- *; simpl in |- *; 
  auto.
 Qed.
 
 Canonical Structure PULB_mor_setoid := Build_Setoid Equal_PULB_mor_equiv.

 End pulb_setoid_def.

Definition Comp_PULB_mor (a b c : PULB_ob) (f : PULB_mor_setoid a b) :=
  match
    f in (PULB_mor p p0) return (PULB_mor_setoid p0 c -> PULB_mor_setoid p c)
  with
  | IP1 => 
       
      match c as p return (PULB_mor P1 p -> PULB_mor P1 p) with
      | P1 =>
            fun _ => IP1 
                     
      | P2 => fun _ => F12
               
      | P3 =>
          fun g => PULB_13_rect (fun _ : PULB_mor P1 P3 => PULB_mor P1 P3) g
      end
       
  | IP2 =>
      match c as p return (PULB_mor P2 p -> PULB_mor P2 p) with
      | P1 => 
           
          fun g =>
          PULB_21_rect (fun _ : PULB_mor P2 P1 => PULB_mor P2 P1) g
           
      | P2 => fun _ => IP2
               
      | P3 =>
          fun g => PULB_23_rect (fun _ : PULB_mor P2 P3 => PULB_mor P2 P3) g
      end
       
  | IP3 =>
      match c as p return (PULB_mor P3 p -> PULB_mor P3 p) with
      | P1 =>
           
          fun g =>
          PULB_31_rect (fun _ : PULB_mor P3 P1 => PULB_mor P3 P1) g 
           
      | P2 => fun _ => F32
               
      | P3 => fun _ => IP3
      end
       
  | F12 =>
      match c as p return (PULB_mor P2 p -> PULB_mor P1 p) with
      | P1 =>
           
          fun g =>
          PULB_21_rect (fun _ : PULB_mor P2 P1 => PULB_mor P1 P1) g
           
      | P2 => fun _ => F12
               
      | P3 =>
          fun g => PULB_23_rect (fun _ : PULB_mor P2 P3 => PULB_mor P1 P3) g
      end
       
  | F32 =>
      match c as p return (PULB_mor P2 p -> PULB_mor P3 p) with
      | P1 =>
           
          fun g =>
          PULB_21_rect (fun _ : PULB_mor P2 P1 => PULB_mor P3 P1) g
           
      | P2 => fun _ => F32
               
      | P3 =>
          fun g => PULB_23_rect (fun _ : PULB_mor P2 P3 => PULB_mor P3 P3) g
      end
  end.

Lemma Comp_PULB_congl : Congl_law Comp_PULB_mor.
Proof.
unfold Congl_law, Equal_PULB_mor in |- *; simpl in |- *; auto.
Qed.

Lemma Comp_PULB_congr : Congr_law Comp_PULB_mor.
Proof.
unfold Congr_law, Equal_PULB_mor in |- *; simpl in |- *; auto.
Qed.
 
Definition Comp_PULB := Build_Comp Comp_PULB_congl Comp_PULB_congr.

Lemma Assoc_PULB : Assoc_law Comp_PULB.
Proof.
unfold Assoc_law in |- *; simpl in |- *; unfold Equal_PULB_mor in |- *;
 simpl in |- *; auto.
Qed.

Definition Id_PULB (a : PULB_ob) :=
  match a as a' return (PULB_mor a' a') with
  | P1 =>   IP1 
       
  | P2 => IP2 
       
  | P3 => IP3
  end.

Lemma Idl_PULB : Idl_law Comp_PULB Id_PULB.
Proof.
unfold Idl_law in |- *; simpl in |- *; unfold Equal_PULB_mor in |- *;
 simpl in |- *; auto.
Qed.

Lemma Idr_PULB : Idr_law Comp_PULB Id_PULB.
Proof.
unfold Idr_law in |- *; simpl in |- *; unfold Equal_PULB_mor in |- *;
 simpl in |- *; auto.
Qed.
 
Canonical Structure PULB := Build_Category Assoc_PULB Idl_PULB Idr_PULB.
