
Require Export CatProperty.
(* CatProperty:
Require Export Dual.

Set Implicit Arguments.
Unset Strict Implicit.

Section epic_monic_def.

Variables (C : Category) (a b : C).
 
Definition Epic_law (f : a --> b) :=
  forall (c : C) (g h : b --> c), f o g =_S f o h -> g =_S h.

Structure > Epic : Type := 
  {Epic_mor : a --> b; Prf_isEpic :> Epic_law Epic_mor}.

Definition Monic_law (f : b --> a) :=
  forall (c : C) (g h : c --> b), g o f =_S h o f -> g =_S h.

Structure > Monic : Type := 
  {Monic_mor : b --> a; Prf_isMonic :> Monic_law Monic_mor}.

End epic_monic_def.

Section iso_def.

Variable C : Category.

Definition RIso_law (a b : C) (f : a --> b) (f1 : b --> a) := f1 o f =_S Id b.

Variable a b : C.

Definition AreIsos (f : a --> b) (f1 : b --> a) :=
  RIso_law f f1 /\ RIso_law f1 f.

Structure > Iso : Type := 
  {Iso_mor : a --> b; Inv_iso : b --> a; Prf_Iso :> AreIsos Iso_mor Inv_iso}.

Lemma Idl_inv : forall i : Iso, RIso_law (Iso_mor i) (Inv_iso i).

Lemma Idr_inv : forall i : Iso, RIso_law (Inv_iso i) (Iso_mor i).

Lemma Inv_iso_unique :
 forall f g : Iso, Iso_mor f =_S Iso_mor g -> Inv_iso f =_S Inv_iso g.

Lemma RightInv_epic :
 forall (h : a --> b) (h1 : b --> a), RIso_law h h1 -> Epic_law h.

End iso_def.

Coercion RightInv_epic : RIso_law >-> Epic_law.

Section initial_def.

Variable C : Category.

Definition IsInitial (a : C) (h : forall b : C, a --> b) :=
  forall (b : C) (f : a --> b), f =_S h b.
  
Structure > Initial : Type := 
  {Initial_ob : C;
   MorI : forall b : C, Initial_ob --> b;
   Prf_isInitial :> IsInitial MorI}.

Definition At_most_1mor (a b : C) := forall f g : a --> b, f =_S g.

Lemma UniqueI : forall (i : Initial) (b : C), At_most_1mor (Initial_ob i) b.

Lemma I_unic : forall i1 i2 : Initial, Iso (Initial_ob i1) (Initial_ob i2).

End initial_def.

Section terminal_def.

Variable C : Category.

Definition IsTerminal (b : C) (h : forall a : C, a --> b) :=
  forall (a : C) (f : a --> b), f =_S h a. 

Structure > Terminal : Type := 
  {Terminal_ob : C;
   MorT : forall a : C, a --> Terminal_ob;
   Prf_isTerminal :> IsTerminal MorT}.

Lemma UniqueT : forall (t : Terminal) (a : C), At_most_1mor a (Terminal_ob t).

End terminal_def.

Lemma Initial_dual :
 forall (C : Category) (a : C) (h : forall b : C, a --> b),
 IsInitial h -> IsTerminal (C:=Dual C) h.

Coercion Initial_dual : IsInitial >-> IsTerminal.

Definition IsTerminal' (C : Category) (b : C) (h : forall a : C, a --> b) :=
  IsInitial (C:=Dual C) h. *)
Require Export Functor.
(* Functor:
Require Export Setoid_dup1.
Require Export Hom_Equality.

Set Implicit Arguments.
Unset Strict Implicit.

Section funct_def.

Variable C D : Category.

 Section funct_laws.

 Variables (FOb : C -> D)
   (FMap : forall a b : C, Map (a --> b) (FOb a --> FOb b)).

 Definition Fcomp_law :=
   forall (a b c : C) (f : a --> b) (g : b --> c),
   FMap a c (f o g) =_S FMap a b f o FMap b c g.

 Definition Fid_law := forall a : C, FMap a a (Id a) =_S Id (FOb a).

 End funct_laws.

Structure Functor : Type := 
  {FOb :> C -> D;
   FMap : forall a b : C, Map (a --> b) (FOb a --> FOb b);
   Prf_Fcomp_law : Fcomp_law FMap;
   Prf_Fid_law : Fid_law FMap}.

Definition FMor (F : Functor) (a b : C) (f : a --> b) := FMap F a b f.

Lemma FPres :
 forall (F : Functor) (a b : C) (f g : a --> b),
 f =_S g -> FMor F f =_S FMor F g.

Lemma FComp :
 forall (F : Functor) (a b c : C) (f : a --> b) (g : b --> c),
 FMor F (f o g) =_S FMor F f o FMor F g.

Lemma FComp1 :
 forall (F : Functor) (a b c : C) (f : a --> b) (g : b --> c),
 FMor F f o FMor F g =_S FMor F (f o g).

Lemma FId : forall (F : Functor) (a : C), FMor F (Id a) =_S Id (FOb F a).

Lemma FId1 : forall (F : Functor) (a : C), Id (FOb F a) =_S FMor F (Id a).

End funct_def.

Section funct_setoid.

Variable C D : Category. 

Definition Equal_Functor (F G : Functor C D) :=
  forall (a b : C) (f : a --> b), FMor F f =_H FMor G f.

Lemma Equal_Functor_equiv : Equivalence Equal_Functor.

Canonical Structure Functor_setoid := Build_Setoid' Equal_Functor_equiv.

End funct_setoid.

Infix "=_F" := Equal_Functor (at level 70).

Section Comp_F.

Variables (C D E : Category) (G : Functor C D) (H : Functor D E).

Definition Comp_FOb (a : C) := H (G a).

 Section comp_functor_map.

 Variable a b : C.

 Definition Comp_FMor (f : a --> b) := FMor H (FMor G f). 

 Lemma Comp_FMap_law : Map_law Comp_FMor.

 Definition Comp_FMap :=
   Build_Map (B:=Comp_FOb a --> Comp_FOb b) Comp_FMap_law.

 End comp_functor_map.

Lemma Comp_Functor_comp_law : Fcomp_law Comp_FMap.

Lemma Comp_Functor_id_law : Fid_law Comp_FMap.

Canonical Structure Comp_Functor :=
  Build_Functor Comp_Functor_comp_law Comp_Functor_id_law.

End Comp_F.

Infix "o_F" := Comp_Functor (at level 20, right associativity). *)

Set Implicit Arguments.
Unset Strict Implicit.

Section ua_def.

Variables (A B : Category) (b : B) (G : Functor A B).

 Section isua_def.

 Variables (a : A) (u : b --> G a).

  Section ua_laws.

  Variable diese : forall a' : A, (b --> G a') -> (a --> a').

  Definition UA_eq (a' : A) (f : b --> G a') (g : a --> a') :=
    u o FMor G g =_S f.

  Definition UA_law1 := forall (a' : A) (f : b --> G a'), UA_eq f (diese f).

  Definition UA_law2 :=
    forall (a' : A) (f : b --> G a') (g : a --> a'),
    UA_eq f g -> g =_S diese f.

  End ua_laws.

 Structure IsUA : Type := 
   {UA_diese : forall a' : A, (b --> G a') -> (a --> a');
    Prf_isUA_law1 : UA_law1 UA_diese;
    Prf_isUA_law2 : UA_law2 UA_diese}.

 Variable t : IsUA.

 Lemma Diese_map : forall a' : A, Map_law (UA_diese t (a':=a')).
 Proof.
 intros a'.
 unfold Map_law in |- *; intros f g H.
 apply (Prf_isUA_law2 t (f:=g) (g:=UA_diese t f)).
 unfold UA_eq in |- *.
  apply Trans with f.
 apply (Prf_isUA_law1 t f).
 assumption.
 Qed.

 End isua_def.

Structure > UA : Type := 
  {UA_ob : A; UA_mor : b --> G UA_ob; Prf_IsUA :> IsUA UA_mor}.

Lemma UA_diag :
 forall (u : UA) (a' : A) (f : b --> G a'),
 UA_mor u o FMor G (UA_diese u f) =_S f.
Proof.
intros u a' f; exact (Prf_isUA_law1 (u:=UA_mor u) u f).
Qed.
 
Lemma UA_diag1 :
 forall (u : UA) (a' : A) (f : b --> G a'),
 f =_S UA_mor u o FMor G (UA_diese u f).
Proof.
intros u a' f; apply Sym; apply UA_diag.
Qed.

Lemma UA_unic :
 forall (u : UA) (a' : A) (f : b --> G a') (g : UA_ob u --> a'),
 UA_mor u o FMor G g =_S f -> g =_S UA_diese u f.
Proof.
intros u a' f g; exact (Prf_isUA_law2 u (f:=f) (g:=g)).
Qed.

Lemma UA_unic1 :
 forall (u : UA) (a' : A) (f : b --> G a') (g : UA_ob u --> a'),
 UA_mor u o FMor G g =_S f -> UA_diese u f =_S g.
Proof.
intros u a' f g H; apply Sym; apply UA_unic; exact H.
Qed.

End ua_def.

Section ua_iso_def.

Variables (A B : Category) (b : B) (G : Functor A B) (u1 u2 : UA b G).

Definition UA_iso_mor := UA_diese u1 (UA_mor u2).

Definition UA_iso_mor_1 := UA_diese u2 (UA_mor u1).

Lemma UA_iso_law1 : AreIsos UA_iso_mor UA_iso_mor_1.
Proof.
unfold AreIsos in |- *; split; unfold RIso_law in |- *.
 apply Trans with (UA_diese u2 (UA_mor u2)).
apply UA_unic.
 apply
       Trans
        with
          (UA_mor u2
           o FMor G (UA_diese u2 (UA_mor u1))
             o FMor G (UA_diese u1 (UA_mor u2))).
apply Comp_l; apply FComp.
 apply
       Trans
        with
          ((UA_mor u2 o FMor G (UA_diese u2 (UA_mor u1)))
           o FMor G (UA_diese u1 (UA_mor u2))).
apply Ass.
 apply Trans with (UA_mor u1 o FMor G (UA_diese u1 (UA_mor u2))).
apply Comp_r; apply UA_diag.
apply UA_diag.
apply UA_unic1.
 apply Trans with (UA_mor u2 o Id (G (UA_ob u2))).
apply Comp_l; apply FId.
apply Idr1.
 apply Trans with (UA_diese u1 (UA_mor u1)).
apply UA_unic.
 apply
       Trans
        with
          (UA_mor u1
           o FMor G (UA_diese u1 (UA_mor u2))
             o FMor G (UA_diese u2 (UA_mor u1))).
apply Comp_l; apply FComp.
 apply
       Trans
        with
          ((UA_mor u1 o FMor G (UA_diese u1 (UA_mor u2)))
           o FMor G (UA_diese u2 (UA_mor u1))).
apply Ass.
 apply Trans with (UA_mor u2 o FMor G (UA_diese u2 (UA_mor u1))).
apply Comp_r; apply UA_diag.
apply UA_diag.
apply UA_unic1.
 apply Trans with (UA_mor u1 o Id (G (UA_ob u1))).
apply Comp_l; apply FId.
apply Idr1.
Qed.

Definition UA_iso : Iso (UA_ob u1) (UA_ob u2) := UA_iso_law1.

End ua_iso_def.

