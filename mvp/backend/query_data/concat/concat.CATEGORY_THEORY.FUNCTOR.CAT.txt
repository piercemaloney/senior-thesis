
Require Export IdCAT.
(* IdCAT:
Require Export Functor.

Set Implicit Arguments.
Unset Strict Implicit.

Section idCat.

Variable C : Category.

Definition Id_CAT_ob (a : C) := a.
                      
Definition Id_CAT_map (a b : C) := Id_map (a --> b).
                   
Lemma Id_CAT_comp_law : Fcomp_law (FOb:=Id_CAT_ob) Id_CAT_map.

Lemma Id_CAT_id_law : Fid_law (FOb:=Id_CAT_ob) Id_CAT_map.

Canonical Structure Id_CAT := Build_Functor Id_CAT_comp_law Id_CAT_id_law.

End idCat. *)
Require Export Category_dup1.
(* Category_dup1:
Require Export Setoid_dup1.

Set Implicit Arguments.
Unset Strict Implicit.

Section composition_to_operator'.

Variables (A : Type) (H : A -> A -> Setoid')
  (Cfun : forall a b c : A, H a b -> H b c -> H a c).

Definition Congl_law' :=
  forall (a b c : A) (f g : H b c) (h : H a b),
  f =_S' g -> Cfun h f =_S' Cfun h g. 

Definition Congr_law' :=
  forall (a b c : A) (f g : H a b) (h : H b c),
  f =_S' g -> Cfun f h =_S' Cfun g h. 

Definition Cong_law' :=
  forall (a b c : A) (f f' : H a b) (g g' : H b c),
  f =_S' f' -> g =_S' g' -> Cfun f g =_S' Cfun f' g'. 

Hypothesis pcgl : Congl_law'.
Hypothesis pcgr : Congr_law'.

Variable a b c : A.

Definition Build_Comp' :=
  Build_Map2' (pcgl (a:=a) (b:=b) (c:=c)) (pcgr (a:=a) (b:=b) (c:=c)).

End composition_to_operator'.

Section cat'.

Variables (Ob' : Type) (Hom' : Ob' -> Ob' -> Setoid').

Variable
  Op_comp' : forall a b c : Ob', Map2' (Hom' a b) (Hom' b c) (Hom' a c).

Definition Cat_comp' (a b c : Ob') (f : Hom' a b) (g : Hom' b c) :=
  Op_comp' a b c f g.

Definition Assoc_law' :=
  forall (a b c d : Ob') (f : Hom' a b) (g : Hom' b c) (h : Hom' c d),
  Cat_comp' f (Cat_comp' g h) =_S' Cat_comp' (Cat_comp' f g) h.

Variable Id' : forall a : Ob', Hom' a a.

Definition Idl_law' :=
  forall (a b : Ob') (f : Hom' a b), Cat_comp' (Id' _) f =_S' f.

Definition Idr_law' :=
  forall (a b : Ob') (f : Hom' b a), f =_S' Cat_comp' f (Id' _).

End cat'.

Structure Category' : Type := 
  {Ob' :> Type;
   Hom' : Ob' -> Ob' -> Setoid';
   Op_comp' : forall a b c : Ob', Map2' (Hom' a b) (Hom' b c) (Hom' a c);
   Id' : forall a : Ob', Hom' a a;
   Prf_ass' : Assoc_law' Op_comp';
   Prf_idl' : Idl_law' Op_comp' Id';
   Prf_idr' : Idr_law' Op_comp' Id'}.

Definition Comp' (C : Category') := Cat_comp' (Op_comp' (c:=C)).

Infix "o'" := Comp' (at level 20, right associativity). *)

Set Implicit Arguments.
Unset Strict Implicit.

Lemma Comp_Functor_congl : Congl_law' Comp_Functor.
Proof.
unfold Congl_law' in |- *; simpl in |- *.
unfold Equal_Functor, Comp_Functor in |- *.
intros A B C F G H eq_FG a1 a2 f.
unfold FMor in |- *; simpl in |- *.
unfold Comp_FOb, Comp_FMor in |- *.
apply eq_FG.
Qed.

Lemma Comp_Functor_congr : Congr_law' Comp_Functor.
Proof.
unfold Congr_law' in |- *; simpl in |- *.
unfold Equal_Functor, Comp_Functor in |- *.
intros A B C F G H eq_FG a1 a2 f.
unfold FMor in |- *; simpl in |- *.
unfold Comp_FOb, Comp_FMor in |- *.
elim (eq_FG a1 a2 f); intros g eq_Ff_g.
apply Build_Equal_hom; apply FPres; assumption.
Qed.

Definition Comp_CAT := Build_Comp' Comp_Functor_congl Comp_Functor_congr.
     
Lemma Assoc_CAT : Assoc_law' Comp_CAT.
Proof.
unfold Assoc_law', Cat_comp' in |- *; simpl in |- *.
intros C D E F G H X.
unfold Equal_Functor in |- *; simpl in |- *.
unfold Ap2 in |- *; simpl in |- *; auto.
Qed.

Lemma Idl_CAT : Idl_law' Comp_CAT Id_CAT.
Proof.
unfold Idl_law', Cat_comp', Ap2 in |- *; simpl in |- *.
intros C D G; unfold Comp_Functor, Equal_Functor in |- *.
intros a b f; unfold FMor in |- *; simpl in |- *.
unfold Comp_FMor in |- *; unfold Id_CAT, FMor in |- *; simpl in |- *.
auto.
Qed.

Lemma Idr_CAT : Idr_law' Comp_CAT Id_CAT.
Proof.
unfold Idr_law', Cat_comp', Ap2 in |- *; simpl in |- *.
intros C D G; unfold Comp_Functor, Equal_Functor in |- *.
intros a b f; unfold FMor in |- *; simpl in |- *.
unfold Comp_FMor in |- *; unfold Id_CAT, FMor in |- *; simpl in |- *.
auto.
Qed.

Canonical Structure CAT : Category' :=
  Build_Category' Assoc_CAT Idl_CAT Idr_CAT.
              