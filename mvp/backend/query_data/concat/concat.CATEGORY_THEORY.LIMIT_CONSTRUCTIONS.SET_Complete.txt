
Require Export SET.
(* SET:
Require Export Category.

Set Implicit Arguments.
Unset Strict Implicit.

Lemma Comp_map_congl : Congl_law Comp_map.

Lemma Comp_map_congr : Congr_law Comp_map.

Definition Comp_SET := Build_Comp Comp_map_congl Comp_map_congr.

Lemma Assoc_SET : Assoc_law Comp_SET.

Definition Id_SET := Id_map.
 
Lemma Idl_SET : Idl_law Comp_SET Id_SET.

Lemma Idr_SET : Idr_law Comp_SET Id_SET.

Canonical Structure SET := Build_Category Assoc_SET Idl_SET Idr_SET. *)
Require Export Single.
(* Single:
Require Export Setoid.
Require Export BasicTypes.

Set Implicit Arguments.
Unset Strict Implicit.

Definition Equal_Single (a b : UnitType) := True.

Lemma Equal_Single_equiv : Equivalence Equal_Single.

Canonical Structure Single : Setoid := Equal_Single_equiv.

Hint Resolve Elt. *)
Require Export Limit.
(* Limit:
Require Export Const.
Require Export CoUniversalArrow.
Require Export Ntransformation.

Set Implicit Arguments.
Unset Strict Implicit.

Section def_cone.

Variables (J C : Category) (c : C) (F : Functor J C).

SubClass Cone := NT (Const J c) F.

Definition Cones := NT_setoid (Const J c) F.

 Section cone_nt.

 Variable T : forall a : J, c --> F a.

 Definition Cone_law :=
   forall (i j : J) (g : i --> j), T j =_S T i o FMor F g.

 Lemma Prf_Cone_nt_law : Cone_law -> NT_law (F:=Const J c) T.
 
 Coercion Prf_Cone_nt_law : Cone_law >-> NT_law.

 Variable p : Cone_law.

 Canonical Structure Build_Cone : Cone := Build_NT (Prf_Cone_nt_law p).

 End cone_nt.

Coercion Build_Cone : Cone_law >-> Cone.
  
Lemma Eq_cone : forall tau : Cone, Cone_law (ApNT tau).

Lemma EqC :
 forall (tau : Cone) (i j : J) (g : i --> j), tau j =_S tau i o FMor F g.

Lemma EqC1 :
 forall (tau : Cone) (i j : J) (g : i --> j), tau i o FMor F g =_S tau j.

End def_cone.
		
Section limit_def.

Variables (J C : Category) (F : Functor J C).

 Section islimit_def. 
 
 Variables (lim : C) (nu : Cone lim F).

  Section limit_laws.

  Variable l_diese : forall c : C, Cone c F -> (c --> lim).  

  Definition Limit_eq (c : C) (tau : Cone c F) (g : c --> lim) :=
    forall i : J, g o nu i =_S tau i.
                      
  Definition Limit_law1 :=
    forall (c : C) (tau : Cone c F), Limit_eq tau (l_diese tau).

  Definition Limit_law2 :=
    forall (c : C) (tau : Cone c F) (g : c --> lim),
    Limit_eq tau g -> g =_S l_diese tau.
  
  End limit_laws.

 Structure IsLimit : Type := 
   {Lim_diese : forall c : C, Cone c F -> (c --> lim);
    Prf_limit1 : Limit_law1 Lim_diese;
    Prf_limit2 : Limit_law2 Lim_diese}.

 Variable l : IsLimit.

 Lemma Ldiese_map :
  forall (c : C) (tau1 tau2 : Cone c F),
  tau1 =_NT tau2 -> Lim_diese l tau1 =_S Lim_diese l tau2.
 
 End islimit_def.

 Structure > Limit : Type := 
   {Lim : C;
    Limiting_cone : Cone Lim F;
    Prf_Islimit :> IsLimit Limiting_cone}.

End limit_def.

Definition Complete (C : Category) :=
  forall (J : Category) (F : Functor J C), Limit F. *)
Require Export Map0_dup1.
(* Map0_dup1:
Require Export Setoid.
Require Export Setoid_dup2.

Set Implicit Arguments.
Unset Strict Implicit.

Section maps0''.

Variables (A : Setoid) (B : Setoid'').

Definition Map_law0'' (f : A -> B) :=
  forall x y : A, x =_S y -> f x =_S'' f y.

Structure > Map0'' : Type :=  {Ap0'' :> A -> B; Pres0'' :> Map_law0'' Ap0''}.

End maps0''.

Section maps''0.

Variables (A : Setoid'') (B : Setoid).

Definition Map_law''0 (f : A -> B) :=
  forall x y : A, x =_S'' y -> f x =_S f y.

Structure > Map''0 : Type :=  {Ap''0 :> A -> B; Pres''0 :> Map_law''0 Ap''0}.

End maps''0.

Section bij0''.

Variables (A : Setoid) (B : Setoid'').

Definition AreBij0'' (f : Map0'' A B) (g : Map''0 B A) :=
  (forall a : A, g (f a) =_S a) /\ (forall b : B, f (g b) =_S'' b).

End bij0''. *)

Set Implicit Arguments.
Unset Strict Implicit.

Section set_c.

Variables (J : Category) (F : Functor J SET).

Definition SET_lim := Cones Single F.

 Section set_lcone_tau_def.

 Variable i : J.

 Definition SET_lcone_tau_fun (sigma : SET_lim) := sigma i Elt.

 Lemma SET_lcone_tau_map_law : Map_law''0 SET_lcone_tau_fun.
 Proof.
 unfold Map_law''0 in |- *; intros s1 s2 H.
 unfold SET_lcone_tau_fun in |- *.
 apply (H i Elt).
 Qed.

 Canonical Structure SET_lcone_tau := Build_Map''0 SET_lcone_tau_map_law.

 End set_lcone_tau_def.

Lemma SET_lcone_cone_law :
 forall (i j : J) (g : i --> j) (tau : SET_lim),
 SET_lcone_tau j tau =_S FMor F g (SET_lcone_tau i tau).
Proof.
intros i j g sigma.
unfold SET_lcone_tau in |- *; simpl in |- *; unfold SET_lcone_tau_fun in |- *.
apply (EqC sigma g Elt).
Qed.

 Section set_diese.

 Variables (X : SET) (tau : Cones X F).

  Section set_diese1_def.

  Variable x : X.

   Section set_diese1_tau_def.

   Variable i : J.

   Definition SET_diese1_tau_fun (a : Single) :=
     match a with
     | Elt => tau i x
     end.

   Lemma SET_diese1_tau_map_law : Map_law SET_diese1_tau_fun.
   Proof.
   unfold Map_law in |- *.
   intros a b; elim a; elim b; simpl in |- *; intro H.
   apply Refl.
   Qed.

   Canonical Structure SET_diese1_tau := Build_Map SET_diese1_tau_map_law.
 
   End set_diese1_tau_def.

  Lemma SET_diese1_tau_cone_law : Cone_law SET_diese1_tau.
  Proof.
  unfold Cone_law in |- *; intros i j g; simpl in |- *.
  unfold Ext in |- *; simpl in |- *.
  intro a; elim a; simpl in |- *.
  unfold Comp_fun in |- *; simpl in |- *.
  apply (EqC tau g x).
  Qed.

  Definition SET_diese1 : SET_lim := Build_Cone SET_diese1_tau_cone_law.

  End set_diese1_def.

 Lemma SET_diese_map_law : Map_law0'' SET_diese1.
 Proof.
 unfold Map_law0'' in |- *; intros x y H; simpl in |- *.
 unfold Equal_NT, SET_diese1 in |- *; simpl in |- *.
 unfold Ext in |- *; simpl in |- *; intros i a.
 elim a; simpl in |- *.
 apply Pres1; trivial.
 Qed.

 Canonical Structure SET_diese := Build_Map0'' SET_diese_map_law.

 End set_diese.
 
Lemma SET_coUAlaw1 :
 forall (X : SET) (tau : Cone X F) (i : J) (x : X),
 tau i x =_S SET_lcone_tau i (SET_diese tau x).
Proof.
simpl in |- *; intros X tau i x.
unfold SET_lcone_tau_fun, SET_diese1 in |- *; simpl in |- *.
apply Refl.
Qed.

Lemma SET_coUAlaw2 :
 forall (X : SET) (tau : Cone X F) (g : Map0'' X SET_lim),
 (forall (i : J) (x : X), tau i x =_S SET_lcone_tau i (g x)) ->
 forall x : X, g x =_S'' SET_diese tau x.
Proof.
intros X tau g H x; simpl in |- *.
unfold Equal_NT in |- *; simpl in |- *; intro i; simpl in |- *;
 unfold Ext in |- *; simpl in |- *.
intro e; elim e; simpl in |- *.
apply Sym; apply (H i x).
Qed.

End set_c.