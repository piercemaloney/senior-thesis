
Require Export UniversalArrow.
(* UniversalArrow:
Require Export CatProperty.
Require Export Functor.

Set Implicit Arguments.
Unset Strict Implicit.

Section ua_def.

Variables (A B : Category) (b : B) (G : Functor A B).

 Section isua_def.

 Variables (a : A) (u : b --> G a).

  Section ua_laws.

  Variable diese : forall a' : A, (b --> G a') -> (a --> a').

  Definition UA_eq (a' : A) (f : b --> G a') (g : a --> a') :=
    u o FMor G g =_S f.

  Definition UA_law1 := forall (a' : A) (f : b --> G a'), UA_eq f (diese f).

  Definition UA_law2 :=
    forall (a' : A) (f : b --> G a') (g : a --> a'),
    UA_eq f g -> g =_S diese f.

  End ua_laws.

 Structure IsUA : Type := 
   {UA_diese : forall a' : A, (b --> G a') -> (a --> a');
    Prf_isUA_law1 : UA_law1 UA_diese;
    Prf_isUA_law2 : UA_law2 UA_diese}.

 Variable t : IsUA.

 Lemma Diese_map : forall a' : A, Map_law (UA_diese t (a':=a')).

 End isua_def.

Structure > UA : Type := 
  {UA_ob : A; UA_mor : b --> G UA_ob; Prf_IsUA :> IsUA UA_mor}.

Lemma UA_diag :
 forall (u : UA) (a' : A) (f : b --> G a'),
 UA_mor u o FMor G (UA_diese u f) =_S f.
 
Lemma UA_diag1 :
 forall (u : UA) (a' : A) (f : b --> G a'),
 f =_S UA_mor u o FMor G (UA_diese u f).

Lemma UA_unic :
 forall (u : UA) (a' : A) (f : b --> G a') (g : UA_ob u --> a'),
 UA_mor u o FMor G g =_S f -> g =_S UA_diese u f.

Lemma UA_unic1 :
 forall (u : UA) (a' : A) (f : b --> G a') (g : UA_ob u --> a'),
 UA_mor u o FMor G g =_S f -> UA_diese u f =_S g.

End ua_def.

Section ua_iso_def.

Variables (A B : Category) (b : B) (G : Functor A B) (u1 u2 : UA b G).

Definition UA_iso_mor := UA_diese u1 (UA_mor u2).

Definition UA_iso_mor_1 := UA_diese u2 (UA_mor u1).

Lemma UA_iso_law1 : AreIsos UA_iso_mor UA_iso_mor_1.

Definition UA_iso : Iso (UA_ob u1) (UA_ob u2) := UA_iso_law1.

End ua_iso_def. *)
Require Export Dual_Functor.
(* Dual_Functor:
Require Export Dual.
Require Export Functor.

Set Implicit Arguments.
Unset Strict Implicit.

Section dfunctor_def.

Variables (A B : Category) (F : Functor A B).

Definition DFunctor_ob : Dual A -> Dual B := fun a : A => F a.

Definition DFunctor_map (b a : A) := FMap F a b.

Lemma DFunctor_comp_law : Fcomp_law (FOb:=DFunctor_ob) DFunctor_map.

Lemma DFunctor_id_law : Fid_law (FOb:=DFunctor_ob) DFunctor_map.

Canonical Structure Dfunctor :=
  Build_Functor DFunctor_comp_law DFunctor_id_law.

End dfunctor_def. *)

Set Implicit Arguments.
Unset Strict Implicit.

Section coua_def.

Variables (A B : Category) (b : B) (F : Functor A B).

 Section iscoua_def.

 Variables (a : A) (u : F a --> b).

  Section coua_laws.

  Variable co_diese : forall a' : A, (F a' --> b) -> (a' --> a).

  Definition CoUA_eq (a' : A) (f : F a' --> b) (g : a' --> a) :=
    FMor F g o u =_S f.

  Definition CoUA_law1 :=
    forall (a' : A) (f : F a' --> b), CoUA_eq f (co_diese f).

  Definition CoUA_law2 :=
    forall (a' : A) (f : F a' --> b) (g : a' --> a),
    CoUA_eq f g -> g =_S co_diese f.

  End coua_laws. 
 
 Structure IsCoUA : Type := 
   {CoUA_diese : forall a' : A, (F a' --> b) -> (a' --> a);
    Prf_isCoUA_law1 : CoUA_law1 CoUA_diese;
    Prf_isCoUA_law2 : CoUA_law2 CoUA_diese}.

 Variable t : IsCoUA.

 Lemma Codiese_map : forall a' : A, Map_law (CoUA_diese t (a':=a')).
 Proof.
 intros a'.
 unfold Map_law in |- *; intros f g H.
 apply (Prf_isCoUA_law2 t (f:=g) (g:=CoUA_diese t f)).
 unfold CoUA_eq in |- *.
  apply Trans with f.
 apply (Prf_isCoUA_law1 t f).
 assumption.
 Qed.

 End iscoua_def.

Structure > CoUA : Type := 
  {CoUA_ob : A; CoUA_mor : F CoUA_ob --> b; Prf_IsCoUA :> IsCoUA CoUA_mor}.

Lemma CoUA_diag :
 forall (u : CoUA) (a' : A) (f : F a' --> b),
 FMor F (CoUA_diese u f) o CoUA_mor u =_S f.
Proof.
intros u a' f; exact (Prf_isCoUA_law1 (u:=CoUA_mor u) u f).
Qed.
 
Lemma CoUA_diag1 :
 forall (u : CoUA) (a' : A) (f : F a' --> b),
 f =_S FMor F (CoUA_diese u f) o CoUA_mor u. 
Proof.
intros u a' f; apply Sym; apply CoUA_diag.
Qed.

Lemma CoUA_unic :
 forall (u : CoUA) (a' : A) (f : F a' --> b) (g : a' --> CoUA_ob u),
 FMor F g o CoUA_mor u =_S f -> g =_S CoUA_diese u f.
Proof.
intros u a' f g; exact (Prf_isCoUA_law2 u (f:=f) (g:=g)).
Qed.

Lemma CoUA_unic1 :
 forall (u : CoUA) (a' : A) (f : F a' --> b) (g : a' --> CoUA_ob u),
 FMor F g o CoUA_mor u =_S f -> CoUA_diese u f =_S g.
Proof.
intros u a' f g H; apply Sym; apply CoUA_unic; exact H.
Qed.

End coua_def.

Section coua_def1.

Variables (A B : Category) (b : B) (F : Functor A B).

 Section iscoua_def1.

 Variables (a : A) (u : F a --> b).

 Definition IsCoUA1 := IsUA (G:=Dfunctor F) u.
 
 Variable u1 : IsCoUA1.

 Definition CoUA1_diese (a' : A) (f : F a' --> b) := UA_diese u1 f.

 Lemma Prf_isCoUA1_law1 : CoUA_law1 u CoUA1_diese.
 Proof.
 unfold CoUA_law1, CoUA_eq in |- *; intros a' f.
 unfold CoUA1_diese in |- *.
 exact (Prf_isUA_law1 u1 f).
 Qed. 

 Lemma Prf_isCoUA1_law2 : CoUA_law2 u CoUA1_diese.
 Proof.
 unfold CoUA_law2, CoUA_eq in |- *; intros a' f g H.
 unfold CoUA1_diese in |- *.
 apply (Prf_isUA_law2 u1 H).
 Qed.

 Lemma IsCoUA1_to_IsCoUA : IsCoUA u. 
 Proof.
 exact (Build_IsCoUA Prf_isCoUA1_law1 Prf_isCoUA1_law2).
 Defined.

 End iscoua_def1.

Coercion IsCoUA1_to_IsCoUA : IsCoUA1 >-> IsCoUA.

Definition CoUA1 := UA (b:Ob (Dual B)) (Dfunctor F).

Variable u1 : CoUA1.

Definition CoUA1_to_CoUA := Build_CoUA (IsCoUA1_to_IsCoUA (Prf_IsUA u1)). 

End coua_def1.

Coercion CoUA1_to_CoUA : CoUA1 >-> CoUA.
