
Require Export Products1.
(* Products1:
Require Export Limit.
Require Export Discr.
Require Export Products.

Set Implicit Arguments.
Unset Strict Implicit.

Section products_limit_def.

Variables (C : Category) (I : Type) (a : I -> C).

Definition FunDiscr_ob (i : Discr I) := a i.

Definition FunDiscr_arrow (i j : Discr I) (f : i --> j) :=
  match f in (Discr_mor d d0) return (Carrier (a d --> a d0)) with
  | Build_Discr_mor k => Id (a k)
  end.

Lemma FunDiscr_map_law :
 forall i j : I, Map_law (FunDiscr_arrow (i:=i) (j:=j)).

Canonical Structure FunDiscr_map (i j : Discr I) :=
  Build_Map (FunDiscr_map_law (i:=i) (j:=j)).

Lemma FunDiscr_comp_law : Fcomp_law FunDiscr_map.

Lemma FunDiscr_id_law : Fid_law FunDiscr_map.

Canonical Structure FunDiscr :=
  Build_Functor FunDiscr_comp_law FunDiscr_id_law.

SubClass Product1 := Limit FunDiscr.

Variable l : Product1.

Definition Pi1 := Lim l.

Definition Proj1 (i : I) : Pi1 --> a i := Limiting_cone l i.

 Section pd1_diese_def.

 Variables (c : C) (f : forall j : I, c --> FunDiscr j).

 Definition Product_tau (j : Discr I) := f j.

 Lemma Product_tau_cone_law : Cone_law Product_tau.

 Definition Product_nt := Build_Cone Product_tau_cone_law.

 Definition Pd1_diese : c --> Pi1 := Lim_diese l Product_nt.

 End pd1_diese_def.

Lemma Prf_pd1_law1 : Product_law1 Proj1 Pd1_diese.

Lemma Prf_pd1_law2 : Product_law2 Proj1 Pd1_diese.

Canonical Structure Product1_to_Product :=
  Build_Product Prf_pd1_law1 Prf_pd1_law2.

End products_limit_def.

Coercion Product1_to_Product : Product1 >-> Product. *)
Require Export Equalizers1.
(* Equalizers1:
Require Export Equalizers.
Require Export PA.
Require Export Limit.

Set Implicit Arguments.
Unset Strict Implicit.

Section equalizer_limit_def.

Variables (C : Category) (a b : C) (I : Type) (k : I -> (a --> b)).

Definition FPA_ob (x : PA k) := match x with
                                | PA1 => a
                                | PA2 => b
                                end.

Definition FPA_mor (x y : PA k) (f : x --> y) :=
  match f in (PA_mor _ x' y') return (Carrier (FPA_ob x' --> FPA_ob y')) with
  | PA_I1 => Id a
  | PA_I2 => Id b
  | PA_f i => k i
  end.

Lemma FPA_map_law : forall x y : PA_ob, Map_law (FPA_mor (x:=x) (y:=y)).

Canonical Structure FPA_map (x y : PA k) :=
  Build_Map (FPA_map_law (x:=x) (y:=y)).

Lemma FPA_comp_law : Fcomp_law FPA_map.

Lemma FPA_id_law : Fid_law FPA_map.

Canonical Structure FPA := Build_Functor FPA_comp_law FPA_id_law.

SubClass Equalizer1 := Limit FPA.

Structure Equalizer2 : Type :=  {Prf_equalizer1 :> Equalizer1; Witness : I}.

Variable l : Equalizer2.

Definition E1_ob := Lim l.

Definition E1_mor : E1_ob --> a := Limiting_cone l PA1.
 
Lemma Prf_E1_law1 : Equalizer_law1 k E1_mor.

 Section e1_diese_def.

 Variables (r : C) (h : r --> a).
 Hypothesis p : Equalizer_eq k h.

 Definition E_tau (x : PA k) :=
   match x as x' return (Carrier (r --> FPA x')) with
   | PA1 => h
   | PA2 => h o k (Witness l)
   end.
 
 Lemma E_tau_cone_law : Cone_law E_tau.
 
 Definition E_NT := Build_Cone E_tau_cone_law.

 Definition E1_diese : r --> E1_ob := Lim_diese l E_NT.
 
 End e1_diese_def.

Lemma Prf_E1_law2 : Equalizer_law2 E1_mor E1_diese.

Lemma Prf_E1_law3 : Equalizer_law3 E1_mor E1_diese.

Canonical Structure Equalizer2_to_Equalizer :=
  Build_Equalizer Prf_E1_law1 Prf_E1_law2 Prf_E1_law3.

End equalizer_limit_def.

Coercion Equalizer2_to_Equalizer : Equalizer2 >-> Equalizer.

Section equaz_fg.

Variables (C : Category) (a b : C) (f g : a --> b).

Definition K_fg (i : TwoElts) := match i with
                                 | Elt1 => f
                                 | Elt2 => g
                                 end.

Definition J_fg := PA K_fg.

Definition F_fg := FPA K_fg.

SubClass Equalizer1_fg := Equalizer1 K_fg.

Lemma Prf_law1_fg :
 forall (r : C) (h : r --> a), h o f =_S h o g -> Equalizer_eq K_fg h.

End equaz_fg.

Section equaz_hom.

Variables (C : Category) (a b : C).

Definition K_hom (f : a --> b) := f.

Definition J_hom := PA K_hom.

Definition F_hom := FPA K_hom.

SubClass Equalizer1_hom := Equalizer1 K_hom.

End equaz_hom. *)
Require Export Single.
(* Single:
Require Export Setoid.
Require Export BasicTypes.

Set Implicit Arguments.
Unset Strict Implicit.

Definition Equal_Single (a b : UnitType) := True.

Lemma Equal_Single_equiv : Equivalence Equal_Single.

Canonical Structure Single : Setoid := Equal_Single_equiv.

Hint Resolve Elt. *)

Set Implicit Arguments.
Unset Strict Implicit.

Section ssc1.

Variable D : Category.

Structure Cond1 (I : Type) (k : I -> D) (d : D) : Type := 
  {Cond1_i : I; Cond1_f : k Cond1_i --> d}.

Structure SSC1 : Type := 
  {SSC1_I : Type;
   SSC1_k : SSC1_I -> D;
   SSC1_p : forall d : D, Cond1 SSC1_k d}.

Definition SSC1_i (s : SSC1) (d : D) := Cond1_i (SSC1_p s d).

Definition SSC1_f (s : SSC1) (d : D) := Cond1_f (SSC1_p s d).

End ssc1.

Section thi1.

Variables (D : Category) (D_initial : Initial D).

Definition Thi1_d1 := Initial_ob D_initial.

Definition Thi1_I := UnitType.

Definition Thi1_k (i : Thi1_I) := match i with
                                  | Elt => Thi1_d1
                                  end.

Definition Thi1_verif_Cond1 (d : D) :=
  Build_Cond1 (k:=Thi1_k) (Cond1_i:=Elt) (MorI D_initial d).

Canonical Structure Thi1_SSC1 := Build_SSC1 Thi1_verif_Cond1.

End thi1.

Section thi2.

Variables (D : Category) (D_complete : Complete D) (SSC1_D : SSC1 D). 

Definition Thi2_D_prod : Product1 (SSC1_k (s:=SSC1_D)) :=
  D_complete (FunDiscr (SSC1_k (s:=SSC1_D))).

Definition Thi2_w := Pi1 Thi2_D_prod.

Definition Thi2_D_E_hom :=
  Build_Equalizer2 (D_complete (F_hom Thi2_w Thi2_w)) (Id Thi2_w).

Definition Thi2_v := E1_ob Thi2_D_E_hom.

Definition Thi2_e := E1_mor Thi2_D_E_hom.
           
 Section thi2_mor_d_def.

 Variable d : D.

 Definition Thi2_p_i := Proj1 Thi2_D_prod (SSC1_i SSC1_D d).
 
 Definition Thi2_f_d := SSC1_f SSC1_D d.   

 Definition Thi2_mor_d := (Thi2_e o Thi2_p_i) o Thi2_f_d.

 End thi2_mor_d_def. 

 Section unique_mor_d.
 
 Variables (d : D) (f g : Thi2_v --> d).
 
 Definition Thi2_D_E_fg := Build_Equalizer2 (D_complete (F_fg f g)) Elt1.

 Definition Thi2_c := E1_ob Thi2_D_E_fg.
 
 Definition Thi2_e1 := E1_mor Thi2_D_E_fg.
 
 Definition Thi2_p_j := Proj1 Thi2_D_prod (SSC1_i SSC1_D Thi2_c).

 Definition Thi2_f_c := SSC1_f SSC1_D Thi2_c.   

 Definition Thi2_s := Thi2_p_j o Thi2_f_c.

 Lemma Thi2_e1_RightInv : RIso_law Thi2_e1 (Thi2_e o Thi2_s).
 Proof.
 unfold RIso_law in |- *; simpl in |- *.
  apply Trans with (Thi2_e o Thi2_s o Thi2_e1).
 apply Ass1.
 apply (E_monic (f:=Thi2_D_E_hom)).
 simpl in |- *.
  apply Trans with (Thi2_e o (Thi2_s o Thi2_e1) o Thi2_e).
 apply Ass1.
  apply Trans with (Thi2_e o Id Thi2_w).
 apply (Prf_E1_law1 Thi2_D_E_hom ((Thi2_s o Thi2_e1) o Thi2_e) (Id Thi2_w)).
  apply Trans with Thi2_e.
 apply Idr1.
 apply Idl1.
 Qed.
 
 Lemma Eq_fg : f =_S g.
 Proof.
 generalize (Equalizer_iso (f:=Thi2_D_E_fg) Thi2_e1_RightInv). 
 intro H; elim H.
 intros H2 H3.
  apply
        Trans
         with
           ((E_diese Thi2_D_E_fg
               (Epic_Equalizer_id (f:=Thi2_D_E_fg) Thi2_e1_RightInv)
             o Thi2_e1) o f).
  apply Trans with (Id Thi2_v o f).
 apply Idl1.
 apply Comp_r.
 apply Sym; apply H2.
  apply
        Trans
         with
           ((E_diese Thi2_D_E_fg
               (Epic_Equalizer_id (f:=Thi2_D_E_fg) Thi2_e1_RightInv)
             o Thi2_e1) o g).
  apply
        Trans
         with
           (E_diese Thi2_D_E_fg
              (Epic_Equalizer_id (f:=Thi2_D_E_fg) Thi2_e1_RightInv)
            o Thi2_e1 o f). 
 apply Ass1.
  apply
        Trans
         with
           (E_diese Thi2_D_E_fg
              (Epic_Equalizer_id (f:=Thi2_D_E_fg) Thi2_e1_RightInv)
            o Thi2_e1 o g). 
 apply Comp_l.
 apply (Prf_E1_law1 Thi2_D_E_fg Elt1 Elt2).
 apply Ass.
  apply Trans with (Id Thi2_v o g).
 apply Comp_r; apply H2.
 apply Idl.
 Qed.

End unique_mor_d.
 
Lemma Thi2_isInitial : IsInitial Thi2_mor_d.
Proof.
red in |- *; intros b f.
apply Eq_fg.
Defined.

Definition Thi2_initial : Initial D := Thi2_isInitial.

End thi2.