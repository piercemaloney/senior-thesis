

Require Import Relations.
(* Relations:
Set Implicit Arguments.
Unset Strict Implicit.

Section Orderings.

Variable U : Type.
   
Definition Relation := U -> U -> Prop.

Variable R : Relation.
   
Definition Reflexive := forall x : U, R x x.
   
Definition Transitive := forall x y z : U, R x y -> R y z -> R x z.
   
Definition Symmetric := forall x y : U, R x y -> R y x.
   
Definition Antisymmetric := forall x y : U, R x y -> R y x -> x = y.
   
Definition Contains (R R' : Relation) := forall x y : U, R' x y -> R x y.
   
Definition Same_relation (R R' : Relation) := Contains R R' /\ Contains R' R.

Structure Preorder : Prop := 
  {Prf_refl1 : Reflexive; Prf_trans1 : Transitive}.
   
Structure Order : Prop := 
  {Prf_preorder :> Preorder; Prf_asym : Antisymmetric}.
   
Structure Partial_equivalence : Prop := 
  {Prf_trans : Transitive; Prf_sym : Symmetric}.
   
Structure Equivalence : Prop := 
  {Prf_refl : Reflexive; Prf_pequiv :> Partial_equivalence}.
   
Canonical Structure Equiv_preorder (e : Equivalence) :=
  Build_Preorder (Prf_refl e) (Prf_trans e).
   
Coercion Equiv_preorder : Equivalence >-> Preorder.

End Orderings.

Hint Unfold Reflexive.
Hint Unfold Transitive.
Hint Unfold Antisymmetric.
Hint Unfold Symmetric.
Hint Unfold Contains.
Hint Unfold Same_relation.
Hint Resolve Build_Preorder.
Hint Resolve Build_Order.
Hint Resolve Build_Equivalence.
Hint Resolve Build_Partial_equivalence. *)

Require Import Confluence.
(* Confluence:
Require Import Relations.

Set Implicit Arguments.
Unset Strict Implicit.

Section Confluence.
   Variable U : Type.
   Variable R : Relation U.
   
   Inductive Rstar : Relation U :=
     | Rstar_0 : forall x : U, Rstar x x
     | Rstar_n : forall x y z : U, R x y -> Rstar y z -> Rstar x z.
   
   Inductive Rstar1 : Relation U :=
     | Rstar1_0 : forall x : U, Rstar1 x x
     | Rstar1_1 : forall x y : U, R x y -> Rstar1 x y
     | Rstar1_n : forall x y z : U, Rstar1 x y -> Rstar1 y z -> Rstar1 x z.
   
   Inductive Rplus : Relation U :=
     | Rplus_0 : forall x y : U, R x y -> Rplus x y
     | Rplus_n : forall x y z : U, R x y -> Rplus y z -> Rplus x z.
   
   Definition Strongly_confluent : Prop :=
     forall x a b : U, R x a -> R x b -> exists z : U, R a z /\ R b z.

   Definition coherent (x y : U) : Prop :=
     exists z : U, Rstar x z /\ Rstar y z.
   
   Definition locally_confluent (x : U) : Prop :=
     forall y z : U, R x y -> R x z -> coherent y z.
   
   Definition Locally_confluent : Prop := forall x : U, locally_confluent x.
   
   Definition confluent (x : U) : Prop :=
     forall y z : U, Rstar x y -> Rstar x z -> coherent y z.
   
   Definition Confluent : Prop := forall x : U, confluent x.
   
End Confluence.
   
Hint Resolve Rstar_0.
Hint Resolve Rstar1_0.
Hint Resolve Rstar1_1.
Hint Resolve Rplus_0. *)

Require Import Coherence.
(* Coherence:
Hint Resolve refl_equal. 
Require Import Relations.
Require Import Confluence.

Set Implicit Arguments.
Unset Strict Implicit.

Theorem Rstar_reflexive :
 forall (U : Type) (R : Relation U), Reflexive (Rstar R).

Theorem Rplus_contains_R :
 forall (U : Type) (R : Relation U), Contains (Rplus R) R.

Theorem Rstar_contains_R :
 forall (U : Type) (R : Relation U), Contains (Rstar R) R.

Theorem Rstar_contains_Rplus :
 forall (U : Type) (R : Relation U), Contains (Rstar R) (Rplus R).

Theorem Rstar_transitive :
 forall (U : Type) (R : Relation U), Transitive (Rstar R).

Theorem Rstar_cases :
 forall (U : Type) (R : Relation U) (x y : U),
 Rstar R x y -> x = y \/ (exists u : U, R x u /\ Rstar R u y).

Theorem Rstar_equiv_Rstar1 :
 forall (U : Type) (R : Relation U), Same_relation (Rstar R) (Rstar1 R).

Theorem Rsym_imp_Rstarsym :
 forall (U : Type) (R : Relation U), Symmetric R -> Symmetric (Rstar R).

Theorem Sstar_contains_Rstar :
 forall (U : Type) (R S : Relation U),
 Contains (Rstar S) R -> Contains (Rstar S) (Rstar R).

Theorem star_monotone :
 forall (U : Type) (R S : Relation U),
 Contains S R -> Contains (Rstar S) (Rstar R).

Theorem RstarRplus_RRstar :
 forall (U : Type) (R : Relation U) (x y z : U),
 Rstar R x y -> Rplus R y z -> exists u : U, R x u /\ Rstar R u z.

Theorem Rstar_imp_coherent :
 forall (U : Type) (R : Relation U) (x y : U), Rstar R x y -> coherent R x y.
Hint Resolve Rstar_imp_coherent.

Theorem coherent_symmetric :
 forall (U : Type) (R : Relation U), Symmetric (coherent R). *)



Set Implicit Arguments.

Unset Strict Implicit.



Theorem Strip :

 forall (U : Type) (R : Relation U),

 Strongly_confluent R ->

 forall x b : U,

 Rstar R x b -> forall a : U, R x a -> exists z : U, Rstar R a z /\ R b z.

Proof.

intros U R H' x b H'0; elim H'0.

intros x0 a H'1; exists a; auto.

intros x0 y z H'1 H'2 H'3 a H'4.

red in H'.

generalize (H' x0 a y); intro h; lapply h;

 [ intro H'5; lapply H'5;

    [ intro h0; elim h0; intros t h1; elim h1; intros H'6 H'7;

       clear h H'5 h0 h1; try exact H'6

    | clear h ]

 | clear h ]; auto 10.

generalize (H'3 t); intro h; lapply h;

 [ intro h0; elim h0; intros z1 h1; elim h1; intros H'5 H'8; clear h h0 h1;

    try exact H'5

 | clear h ]; auto 10.

exists z1; split; [ idtac | assumption ].

apply Rstar_n with t; auto.

Qed.



Theorem Strong_confluence_confluence :

 forall (U : Type) (R : Relation U), Strongly_confluent R -> Confluent R.

Proof.

intros U R H'; red in |- *.

intro x; red in |- *; intros a b H'0.

unfold coherent at 1 in |- *.

generalize b; clear b.

elim H'0; clear H'0.

intros x0 b H'1; exists b; auto.

intros x0 y z H'1 H'2 H'3 b H'4.

generalize (Strip (U:=U) (R:=R)); intro h; lapply h;

 [ intro H'0; generalize (H'0 x0 b); intro h0; lapply h0;

    [ intro H'5; generalize (H'5 y); intro h1; lapply h1;

       [ intro h2; elim h2; intros z0 h3; elim h3; intros H'6 H'7;

          clear h h0 h1 h2 h3

       | clear h h0 h1 ]

    | clear h h0 ]

 | clear h ]; auto.

generalize (H'3 z0); intro h; lapply h;

 [ intro h0; elim h0; intros z1 h1; elim h1; intros H'8 H'9; clear h h0 h1

 | clear h ]; auto.

exists z1; split; auto.

apply Rstar_n with z0; auto.

Qed.



