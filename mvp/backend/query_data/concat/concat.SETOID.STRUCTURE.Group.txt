
Require Export Monoid.
(* Monoid:
Require Export Map2.

Set Implicit Arguments.
Unset Strict Implicit.

SubClass BinOp (A : Setoid) := Map2 A A A.

Section monoid_laws.

Variables (A : Setoid) (op : BinOp A) (e : A).

Let Ap_op (x y : A) := op x y.

Infix "+_M" := Ap_op (at level 40, left associativity).

Definition Monoid_ass := forall x y z : A, x +_M (y +_M z) =_S x +_M y +_M z.

Definition Monoid_idl := forall x : A, e +_M x =_S x.

Definition Monoid_idr := forall x : A, x =_S x +_M e.

End monoid_laws.

Structure Monoid : Type := 
  {Mcarrier :> Setoid;
   Mop : BinOp Mcarrier;
   Munit : Mcarrier;
   Prf_monoid_ass : Monoid_ass Mop;
   Prf_monoid_idl : Monoid_idl Mop Munit;
   Prf_monoid_idr : Monoid_idr Mop Munit}.

Definition ApMop (m : Monoid) (x y : m) := Mop m x y.

Infix "+_M" := ApMop (at level 40, left associativity).
        
Lemma Mass :
 forall (M : Monoid) (x y z : M), x +_M (y +_M z) =_S x +_M y +_M z.

Lemma Mass1 :
 forall (M : Monoid) (x y z : M), x +_M y +_M z =_S x +_M (y +_M z).

Lemma Midl : forall (M : Monoid) (x : M), Munit M +_M x =_S x.

Lemma Midl1 : forall (M : Monoid) (x : M), x =_S Munit M +_M x.

Lemma Midr : forall (M : Monoid) (x : M), x =_S x +_M Munit M.

Lemma Midr1 : forall (M : Monoid) (x : M), x +_M Munit M =_S x.

Section mon_mors.

Variable m1 m2 : Monoid.

Definition MonUnit_law (f : Map m1 m2) := f (Munit m1) =_S Munit m2.

Definition MonOp_law (f : Map m1 m2) :=
  forall a b : m1, f (a +_M b) =_S f a +_M f b.

Structure MonMor : Type := 
  {MonMap :> Map m1 m2;
   Prf_MonUnit_law : MonUnit_law MonMap;
   Prf_MonOp_law : MonOp_law MonMap}.

Lemma MMon_unit : forall f : MonMor, f (Munit m1) =_S Munit m2.

Lemma MMon_op : forall (f : MonMor) (a b : m1), f (a +_M b) =_S f a +_M f b.

Definition Equal_MonMor (f g : MonMor) := f =_M g.

Lemma Equal_MonMor_equiv : Equivalence Equal_MonMor.

Canonical Structure MonMor_setoid : Setoid := Equal_MonMor_equiv.

End mon_mors. *)

Set Implicit Arguments.
Unset Strict Implicit.

Section group_laws.

Variable A : Monoid.

Definition Inverses_rel (x y : A) := x +_M y =_S Munit A.

Variable inv : Map A A.

Definition Group_invl := forall x : A, Inverses_rel (inv x) x.

Definition Group_invr := forall x : A, Inverses_rel x (inv x).

End group_laws.

Structure Group : Type := 
  {Gmon :> Monoid;
   Ginv : Map Gmon Gmon;
   Prf_ginv_l : Group_invl Ginv;
   Prf_ginv_r : Group_invr Ginv}.
