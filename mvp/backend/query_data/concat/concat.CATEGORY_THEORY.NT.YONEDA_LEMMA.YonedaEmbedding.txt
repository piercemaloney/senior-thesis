
Require Export HomFunctor_NT.
(* HomFunctor_NT:
Require Export HomFunctor.
Require Export Ntransformation.

Set Implicit Arguments.
Unset Strict Implicit.

Section funset_nt.

Variables (C : Category) (b a : C) (f : a --> b).

Section nth_map_def.

 Variable c : C.

 Definition NtH_arrow (h : b --> c) := f o h.

 Lemma NtH_map_law : Map_law NtH_arrow.

 Definition NtH_map : Map (FunSET b c) (FunSET a c) := NtH_map_law.

End nth_map_def.

Lemma NtH_nt_law : NT_law NtH_map.

Canonical Structure NtH := Build_NT NtH_nt_law.

End funset_nt. *)
Require Export CatFunct.
(* CatFunct:
Require Export Ntransformation.
Require Export Category_dup2.

Set Implicit Arguments.
Unset Strict Implicit.

Section cat_functor.

Variable C D : Category.

 Section compnt.

 Variables (F G H : Functor C D) (T : NT F G) (T' : NT G H).

 Definition Comp_tau (a : C) := T a o T' a.

 Lemma Comp_tau_nt_law : NT_law Comp_tau.

 Canonical Structure CompV_NT : NT_setoid F H := Comp_tau_nt_law.

 End compnt.

Lemma CompV_NT_congl : Congl_law'' CompV_NT.  

Lemma CompV_NT_congr : Congr_law'' CompV_NT.  

Definition Comp_CatFunct := Build_Comp'' CompV_NT_congl CompV_NT_congr.
   
Lemma Assoc_CatFunct : Assoc_law'' Comp_CatFunct.

 Section id_catfunct_def.

 Variable F : Functor C D.

 Definition Id_CatFunct_tau (a : C) := Id (F a).
 
 Lemma Id_CatFunct_nt_law : NT_law Id_CatFunct_tau.
  
 Canonical Structure Id_CatFunct := Build_NT Id_CatFunct_nt_law.

 End id_catfunct_def.

Lemma Idl_CatFunct : Idl_law'' Comp_CatFunct Id_CatFunct.

Lemma Idr_CatFunct : Idr_law'' Comp_CatFunct Id_CatFunct.

Canonical Structure FUNCT :=
  Build_Category'' Assoc_CatFunct Idl_CatFunct Idr_CatFunct.

End cat_functor.

Infix "o_NTv" := CompV_NT (at level 20, right associativity). *)
Require Export Functor_dup1.
(* Functor_dup1:
Require Export Category.
Require Export Category_dup2.
Require Export Map0_dup1.
Require Export Setoid_dup2.

Set Implicit Arguments.
Unset Strict Implicit.

Section funct_def0''.

Variables (C : Category) (D : Category'').

 Section funct_laws0''.

 Variables (FOb0'' : C -> D)
   (FMap0'' : forall a b : C, Map0'' (a --> b) (Hom'' (FOb0'' a) (FOb0'' b))).

 Definition Fcomp_law0'' :=
   forall (a b c : C) (f : a --> b) (g : b --> c),
   FMap0'' a c (f o g) =_S'' FMap0'' a b f o'' FMap0'' b c g.

 Definition Fid_law0'' :=
   forall a : C, FMap0'' a a (Id a) =_S'' Id'' (FOb0'' a).

 End funct_laws0''.

Structure Functor0'' : Type := 
  {FOb0'' :> C -> D;
   FMap0'' : forall a b : C, Map0'' (a --> b) (Hom'' (FOb0'' a) (FOb0'' b));
   Prf_Fcomp_law0'' : Fcomp_law0'' FMap0'';
   Prf_Fid_law0'' : Fid_law0'' FMap0''}.

Definition FMor0'' (F : Functor0'') (a b : C) (f : a --> b) :=
  FMap0'' F a b f.

End funct_def0''.

Section functor_prop0''.

Variables (C : Category) (D : Category''). 

Definition Faithful_law0'' (F : Functor0'' C D) :=
  forall (a b : C) (f g : a --> b), FMor0'' F f =_S'' FMor0'' F g -> f =_S g.

Structure > Faithful0'' : Type := 
  {Faithful_functor0'' :> Functor0'' C D;
   Prf_isFaithful0'' :> Faithful_law0'' Faithful_functor0''}.

Definition Full_law0'' (F : Functor0'' C D)
  (H : forall a b : C, Hom'' (F a) (F b) -> (a --> b)) :=
  forall (a b : C) (h : Hom'' (F a) (F b)), h =_S'' FMor0'' F (H a b h).

Structure > Full0'' : Type := 
  {Full_functor0'' :> Functor0'' C D;
   Full_mor0'' :
    forall a b : C,
    Hom'' (Full_functor0'' a) (Full_functor0'' b) -> (a --> b);
   Prf_isFull0'' :> Full_law0'' Full_mor0''}.

End functor_prop0''. *)

Set Implicit Arguments.
Unset Strict Implicit.

Section yoneda_functor.

Variable C : Category.

 Section funy_map_def.

 Variable a b : C.

 Lemma FunY_map_law : Map_law0'' (NtH (C:=C) (b:=a) (a:=b)).
 Proof.
 unfold Map_law0'', NtH in |- *; simpl in |- *.
 unfold Equal_NT in |- *; simpl in |- *.
 unfold Ext in |- *; simpl in |- *.
 unfold NtH_arrow in |- *; simpl in |- *.
 unfold FunSET_ob in |- *; intros.
 apply Comp_r; assumption.
 Qed.

 Canonical Structure FunY_map := Build_Map0'' FunY_map_law.

 End funy_map_def.

Lemma FunY_comp_law : Fcomp_law0'' (C:=Dual C) FunY_map.
Proof.
unfold Fcomp_law0'' in |- *; simpl in |- *.
unfold Equal_NT in |- *; simpl in |- *.
unfold Ext in |- *; simpl in |- *.
unfold NtH_arrow in |- *; simpl in |- *.
unfold FunSET_ob, DHom in |- *.
intros a b c f g d h; apply Sym.
exact (Prf_ass g f h).
Qed.

Lemma FunY_id_law : Fid_law0'' (C:=Dual C) FunY_map.
Proof.
unfold Fid_law0'' in |- *; simpl in |- *.
unfold Equal_NT in |- *; simpl in |- *. 
unfold Ext in |- *; simpl in |- *.
unfold NtH_arrow in |- *; simpl in |- *.
unfold FunSET_ob in |- *.
unfold Id_fun in |- *; simpl in |- *.
intros a b f; unfold Comp in |- *; apply (Prf_idl (c:=C)).
Qed.

Canonical Structure FunY := Build_Functor0'' FunY_comp_law FunY_id_law.      

Lemma Y_full :
 let f := fun (a b : C) (h : NT (FunSET a) (FunSET b)) => h a (Id a) in
 Full_law0'' (F:=FunY) f.
Proof.
unfold Full_law0'' in |- *; simpl in |- *; intros a b h.
unfold Equal_NT in |- *; simpl in |- *.
unfold Ext in |- *; simpl in |- *.
unfold NtH_arrow in |- *.
unfold FunSET_ob in |- *.
intros c f; simpl in |- *.
 apply Trans with (h c (Id a o f)).
apply Pres1.
apply Sym; unfold Comp in |- *; simpl in |- *; unfold FunSET_ob in |- *;
 apply (Prf_idl (c:=C)).
apply (Prf_NT_law h f (Id a)).
Qed.

Lemma Y_faithful : Faithful_law0'' FunY.
Proof.
unfold Faithful_law0'' in |- *; simpl in |- *.
unfold Equal_NT in |- *; simpl in |- *.
unfold Ext in |- *; simpl in |- *; unfold DHom in |- *.
unfold NtH_arrow in |- *.
unfold FunSET_ob in |- *.
intros a b f g H.
 apply Trans with (g o Id a).
 apply Trans with (f o Id a).
apply Idr.
apply H.
apply Idr1.
Qed.

End yoneda_functor.

