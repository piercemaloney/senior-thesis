
Require Export Functor.
(* Functor:
Require Export Setoid_dup1.
Require Export Hom_Equality.

Set Implicit Arguments.
Unset Strict Implicit.

Section funct_def.

Variable C D : Category.

 Section funct_laws.

 Variables (FOb : C -> D)
   (FMap : forall a b : C, Map (a --> b) (FOb a --> FOb b)).

 Definition Fcomp_law :=
   forall (a b c : C) (f : a --> b) (g : b --> c),
   FMap a c (f o g) =_S FMap a b f o FMap b c g.

 Definition Fid_law := forall a : C, FMap a a (Id a) =_S Id (FOb a).

 End funct_laws.

Structure Functor : Type := 
  {FOb :> C -> D;
   FMap : forall a b : C, Map (a --> b) (FOb a --> FOb b);
   Prf_Fcomp_law : Fcomp_law FMap;
   Prf_Fid_law : Fid_law FMap}.

Definition FMor (F : Functor) (a b : C) (f : a --> b) := FMap F a b f.

Lemma FPres :
 forall (F : Functor) (a b : C) (f g : a --> b),
 f =_S g -> FMor F f =_S FMor F g.

Lemma FComp :
 forall (F : Functor) (a b c : C) (f : a --> b) (g : b --> c),
 FMor F (f o g) =_S FMor F f o FMor F g.

Lemma FComp1 :
 forall (F : Functor) (a b c : C) (f : a --> b) (g : b --> c),
 FMor F f o FMor F g =_S FMor F (f o g).

Lemma FId : forall (F : Functor) (a : C), FMor F (Id a) =_S Id (FOb F a).

Lemma FId1 : forall (F : Functor) (a : C), Id (FOb F a) =_S FMor F (Id a).

End funct_def.

Section funct_setoid.

Variable C D : Category. 

Definition Equal_Functor (F G : Functor C D) :=
  forall (a b : C) (f : a --> b), FMor F f =_H FMor G f.

Lemma Equal_Functor_equiv : Equivalence Equal_Functor.

Canonical Structure Functor_setoid := Build_Setoid' Equal_Functor_equiv.

End funct_setoid.

Infix "=_F" := Equal_Functor (at level 70).

Section Comp_F.

Variables (C D E : Category) (G : Functor C D) (H : Functor D E).

Definition Comp_FOb (a : C) := H (G a).

 Section comp_functor_map.

 Variable a b : C.

 Definition Comp_FMor (f : a --> b) := FMor H (FMor G f). 

 Lemma Comp_FMap_law : Map_law Comp_FMor.

 Definition Comp_FMap :=
   Build_Map (B:=Comp_FOb a --> Comp_FOb b) Comp_FMap_law.

 End comp_functor_map.

Lemma Comp_Functor_comp_law : Fcomp_law Comp_FMap.

Lemma Comp_Functor_id_law : Fid_law Comp_FMap.

Canonical Structure Comp_Functor :=
  Build_Functor Comp_Functor_comp_law Comp_Functor_id_law.

End Comp_F.

Infix "o_F" := Comp_Functor (at level 20, right associativity). *)

Set Implicit Arguments.
Unset Strict Implicit.

Section comma_def.

Variables (A X : Category) (G : Functor A X) (x : X).

Structure Com_ob : Type :=  {Ob_com_ob : A; Mor_com_ob : x --> G Ob_com_ob}.

 Section com_arrow_def.

 Variable axf bxg : Com_ob.
 
 Definition Com_law (h : Ob_com_ob axf --> Ob_com_ob bxg) :=
   Mor_com_ob bxg =_S Mor_com_ob axf o FMor G h.

 Structure > Com_arrow : Type := 
   {Mor_com_arrow : Ob_com_ob axf --> Ob_com_ob bxg;
    Prf_com_law :> Com_law Mor_com_arrow}.

 Definition Equal_com_arrow (h h' : Com_arrow) :=
   Mor_com_arrow h =_S Mor_com_arrow h'.

 Lemma Equal_com_arrow_equiv : Equivalence Equal_com_arrow.
 Proof.
 apply Build_Equivalence; unfold Equal_com_arrow in |- *.
 unfold Reflexive in |- *; intro f.
 apply Refl.
 apply Build_Partial_equivalence.
 unfold Transitive in |- *; intros f g h H1 H2.
  apply Trans with (Mor_com_arrow g); assumption. 
 unfold Symmetric in |- *; intros f g H.
 apply Sym; assumption.
 Qed.

 Canonical Structure Com_arrow_setoid : Setoid := Equal_com_arrow_equiv.

 End com_arrow_def. 

 Section comp_com_def.

 Variables (axf bxg cxh : Com_ob) (f : Com_arrow axf bxg)
   (g : Com_arrow bxg cxh).

 Definition Comp_com_mor := Mor_com_arrow f o Mor_com_arrow g.

 Lemma Comp_com_law : Com_law Comp_com_mor.
 Proof.
 unfold Com_law, Comp_com_mor in |- *.
  apply Trans with (Mor_com_ob bxg o FMor G (Mor_com_arrow g)).
 apply (Prf_com_law g).
  apply
        Trans
         with
           (Mor_com_ob axf
            o FMor G (Mor_com_arrow f) o FMor G (Mor_com_arrow g)).
  apply
        Trans
         with
           ((Mor_com_ob axf o FMor G (Mor_com_arrow f))
            o FMor G (Mor_com_arrow g)).
 apply Comp_r; apply (Prf_com_law f).
 apply Ass1.
 apply Comp_l; apply FComp1.
 Qed.

 Canonical Structure Comp_com_arrow := Build_Com_arrow Comp_com_law.

 End comp_com_def.
 
Lemma Comp_com_congl : Congl_law Comp_com_arrow.
Proof.
unfold Congl_law in |- *; simpl in |- *.
intros a b c f1; elim f1; intros h e f2.
elim f2; intros h' e' f3; elim f3; intros h'' e''.
unfold Equal_com_arrow in |- *; simpl in |- *.
unfold Comp_com_mor in |- *; simpl in |- *.
intro H; apply Comp_l; trivial.
Qed.

Lemma Comp_com_congr : Congr_law Comp_com_arrow.
Proof.
unfold Congr_law in |- *; simpl in |- *.
intros a b c f1; elim f1; intros h e f2.
elim f2; intros h' e' f3; elim f3; intros h'' e''.
unfold Equal_com_arrow in |- *; simpl in |- *.
unfold Comp_com_mor in |- *; simpl in |- *.
intro H; apply Comp_r; trivial.
Qed.

Definition Comp_Comma := Build_Comp Comp_com_congl Comp_com_congr. 

Lemma Assoc_Comma : Assoc_law Comp_Comma.
Proof.
unfold Assoc_law in |- *; intros a b c d f1; elim f1.
intros h1 e1 f2; elim f2; intros h2 e2 f3.
elim f3; intros h3 e3.
simpl in |- *; unfold Equal_com_arrow in |- *; simpl in |- *.
unfold Comp_com_mor in |- *; simpl in |- *.
unfold Comp_com_mor in |- *; simpl in |- *.
apply Ass.
Qed.

Lemma Id_com_law : forall axf : Com_ob, Com_law (Id (Ob_com_ob axf)).
Proof.
intro axf; unfold Com_law in |- *.
 apply Trans with (Mor_com_ob axf o Id (G (Ob_com_ob axf))).
apply Idr.
apply Comp_l; apply FId1.
Qed.

Canonical Structure Id_Comma (axf : Com_ob) :=
  Build_Com_arrow (Id_com_law axf).

Lemma Idl_Comma : Idl_law Comp_Comma Id_Comma.
Proof.
unfold Idl_law in |- *; intros a b f1; elim f1; intros h e.
simpl in |- *; unfold Equal_com_arrow in |- *; simpl in |- *.
unfold Comp_com_mor in |- *; simpl in |- *.
apply Idl.
Qed.

Lemma Idr_Comma : Idr_law Comp_Comma Id_Comma.
Proof.
unfold Idr_law in |- *; intros a b f1; elim f1; intros h e.
simpl in |- *; unfold Equal_com_arrow in |- *; simpl in |- *.
unfold Comp_com_mor in |- *; simpl in |- *.
apply Idr.
Qed.

Canonical Structure Comma := Build_Category Assoc_Comma Idl_Comma Idr_Comma.

End comma_def.