
Require Export Limit.
(* Limit:
Require Export Const.
Require Export CoUniversalArrow.
Require Export Ntransformation.

Set Implicit Arguments.
Unset Strict Implicit.

Section def_cone.

Variables (J C : Category) (c : C) (F : Functor J C).

SubClass Cone := NT (Const J c) F.

Definition Cones := NT_setoid (Const J c) F.

 Section cone_nt.

 Variable T : forall a : J, c --> F a.

 Definition Cone_law :=
   forall (i j : J) (g : i --> j), T j =_S T i o FMor F g.

 Lemma Prf_Cone_nt_law : Cone_law -> NT_law (F:=Const J c) T.
 
 Coercion Prf_Cone_nt_law : Cone_law >-> NT_law.

 Variable p : Cone_law.

 Canonical Structure Build_Cone : Cone := Build_NT (Prf_Cone_nt_law p).

 End cone_nt.

Coercion Build_Cone : Cone_law >-> Cone.
  
Lemma Eq_cone : forall tau : Cone, Cone_law (ApNT tau).

Lemma EqC :
 forall (tau : Cone) (i j : J) (g : i --> j), tau j =_S tau i o FMor F g.

Lemma EqC1 :
 forall (tau : Cone) (i j : J) (g : i --> j), tau i o FMor F g =_S tau j.

End def_cone.
		
Section limit_def.

Variables (J C : Category) (F : Functor J C).

 Section islimit_def. 
 
 Variables (lim : C) (nu : Cone lim F).

  Section limit_laws.

  Variable l_diese : forall c : C, Cone c F -> (c --> lim).  

  Definition Limit_eq (c : C) (tau : Cone c F) (g : c --> lim) :=
    forall i : J, g o nu i =_S tau i.
                      
  Definition Limit_law1 :=
    forall (c : C) (tau : Cone c F), Limit_eq tau (l_diese tau).

  Definition Limit_law2 :=
    forall (c : C) (tau : Cone c F) (g : c --> lim),
    Limit_eq tau g -> g =_S l_diese tau.
  
  End limit_laws.

 Structure IsLimit : Type := 
   {Lim_diese : forall c : C, Cone c F -> (c --> lim);
    Prf_limit1 : Limit_law1 Lim_diese;
    Prf_limit2 : Limit_law2 Lim_diese}.

 Variable l : IsLimit.

 Lemma Ldiese_map :
  forall (c : C) (tau1 tau2 : Cone c F),
  tau1 =_NT tau2 -> Lim_diese l tau1 =_S Lim_diese l tau2.
 
 End islimit_def.

 Structure > Limit : Type := 
   {Lim : C;
    Limiting_cone : Cone Lim F;
    Prf_Islimit :> IsLimit Limiting_cone}.

End limit_def.

Definition Complete (C : Category) :=
  forall (J : Category) (F : Functor J C), Limit F. *)

Set Implicit Arguments.
Unset Strict Implicit.

Section def_cocone.

Variables (J C : Category) (F : Functor J C) (c : C).

SubClass CoCone := NT F (Const J c).

 Section cocone_nt. 

 Variable T : forall a : J, F a --> c.

 Definition CoCone_law :=
   forall (i j : J) (g : i --> j), FMor F g o T j =_S T i.

 Lemma Prf_CoCone_nt_law : CoCone_law -> NT_law (G:=Const J c) T.
 Proof.
 unfold NT_law in |- *; intros H a b f.
 unfold FMor at 2 in |- *; simpl in |- *; unfold Const_mor in |- *.
  apply Trans with (T a).
 apply (H a b).
 apply Idr.
 Qed.

 Coercion Prf_CoCone_nt_law : CoCone_law >-> NT_law.

 Variable p : CoCone_law.

 Canonical Structure Build_CoCone : CoCone := Build_NT (Prf_CoCone_nt_law p).

 End cocone_nt.

Coercion Build_CoCone : CoCone_law >-> CoCone.

Lemma Eq_coCone : forall tau : CoCone, CoCone_law (ApNT tau).
Proof.
unfold CoCone_law in |- *; intros tau i j g.
 apply Trans with (tau i o Id c).
apply (Prf_NT_law tau g).
apply Idr1.
Qed.

Lemma Co_EqC :
 forall (tau : CoCone) (i j : J) (g : i --> j), FMor F g o tau j =_S tau i.
Proof.
exact Eq_coCone.
Qed.

Lemma Co_EqC1 :
 forall (tau : CoCone) (i j : J) (g : i --> j), tau i =_S FMor F g o tau j.
Proof.
intros; apply Sym; exact (Co_EqC tau (i:=i) (j:=j) g).
Qed.

End def_cocone.
		
Section colimit_def.

Variables (J C : Category) (F : Functor J C).

 Section iscolimit_def.

 Variables (colim : C) (nu : CoCone F colim).

  Section colimit_laws.

  Variable cl_diese : forall c : C, CoCone F c -> (colim --> c).  

  Definition CoLimit_eq (c : C) (tau : CoCone F c) 
    (g : colim --> c) := forall i : J, nu i o g =_S tau i.
                      
  Definition CoLimit_law1 :=
    forall (c : C) (tau : CoCone F c), CoLimit_eq tau (cl_diese tau).

  Definition CoLimit_law2 :=
    forall (c : C) (tau : CoCone F c) (g : colim --> c),
    CoLimit_eq tau g -> g =_S cl_diese tau.
  
  End colimit_laws.

 Structure IsColimit : Type := 
   {Colim_diese : forall c : C, CoCone F c -> (colim --> c);
    Prf_colimit1 : CoLimit_law1 Colim_diese;
    Prf_colimit2 : CoLimit_law2 Colim_diese}.

 Variable l : IsColimit.

 Lemma Cldiese_map :
  forall (c : C) (tau1 tau2 : CoCone F c),
  tau1 =_NT tau2 -> Colim_diese l tau1 =_S Colim_diese l tau2.
 Proof.
 intros c tau1 tau2 p.
 apply (Prf_colimit2 l (tau:=tau2) (g:=Colim_diese l tau1)).
 unfold CoLimit_eq in |- *; intro i.
  apply Trans with (tau1 i).
 apply (Prf_colimit1 l tau1).
 apply (p i).
 Qed.
 
 End iscolimit_def.

 Structure > Colimit : Type := 
   {Colim : C;
    Limiting_cocone : CoCone F Colim;
    Prf_IsColimit :> IsColimit Limiting_cocone}.

End colimit_def.

Definition Cocomplete (C : Category) :=
  forall (J : Category) (F : Functor J C), Colimit F.

