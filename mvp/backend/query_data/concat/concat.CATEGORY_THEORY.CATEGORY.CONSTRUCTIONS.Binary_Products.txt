
Require Export Category.
(* Category:
Require Export Map2.

Set Implicit Arguments.
Unset Strict Implicit.

Section cat.

Variables (Ob : Type) (Hom : Ob -> Ob -> Setoid).

Infix "-->" := Hom (at level 95, right associativity).

Variable Op_comp : forall a b c : Ob, Map2 (a --> b) (b --> c) (a --> c).

Definition Cat_comp (a b c : Ob) (f : a --> b) (g : b --> c) :=
  Op_comp a b c f g.

Infix "o" := Cat_comp (at level 20, right associativity).

Definition Assoc_law :=
  forall (a b c d : Ob) (f : a --> b) (g : b --> c) (h : c --> d),
  f o g o h =_S (f o g) o h.

Variable Id : forall a : Ob, a --> a.

Definition Idl_law := forall (a b : Ob) (f : a --> b), Id _ o f =_S f.

Definition Idr_law := forall (a b : Ob) (f : b --> a), f =_S f o Id _.

End cat.

Structure Category : Type := 
  {Ob :> Type;
   Hom : Ob -> Ob -> Setoid;
   Op_comp : forall a b c : Ob, Map2 (Hom a b) (Hom b c) (Hom a c);
   Id : forall a : Ob, Hom a a;
   Prf_ass : Assoc_law Op_comp;
   Prf_idl : Idl_law Op_comp Id;
   Prf_idr : Idr_law Op_comp Id}.

Definition Comp (C : Category) := Cat_comp (Op_comp (c:=C)).

Infix "-->" := Hom (at level 95, right associativity).
Infix "o" := Comp (at level 20, right associativity).

Lemma Ass :
 forall (C : Category) (a b c d : C) (f : a --> b) 
   (g : b --> c) (h : c --> d), f o g o h =_S (f o g) o h.

Lemma Ass1 :
 forall (C : Category) (a b c d : C) (f : a --> b) 
   (g : b --> c) (h : c --> d), (f o g) o h =_S f o g o h.

Lemma Idl : forall (C : Category) (a b : C) (f : a --> b), Id _ o f =_S f.

Lemma Idl1 : forall (C : Category) (a b : C) (f : a --> b), f =_S Id _ o f.

Lemma Idr : forall (C : Category) (a b : C) (f : b --> a), f =_S f o Id _.

Lemma Idr1 : forall (C : Category) (a b : C) (f : a --> b), f o Id _ =_S f.

Lemma Idrl :
 forall (C : Category) (a b : C) (f : a --> b), f o Id _ =_S Id _ o f.

Lemma Idlr :
 forall (C : Category) (a b : C) (f : a --> b), Id _ o f =_S f o Id _.

Section composition_to_operator.

Variables (A : Type) (H : A -> A -> Setoid)
  (Cfun : forall a b c : A, H a b -> H b c -> H a c).

Definition Congl_law :=
  forall (a b c : A) (f g : H b c) (h : H a b),
  f =_S g -> Cfun h f =_S Cfun h g. 

Definition Congr_law :=
  forall (a b c : A) (f g : H a b) (h : H b c),
  f =_S g -> Cfun f h =_S Cfun g h. 

Definition Cong_law :=
  forall (a b c : A) (f f' : H a b) (g g' : H b c),
  f =_S f' -> g =_S g' -> Cfun f g =_S Cfun f' g'. 

Hypothesis pcgl : Congl_law.
Hypothesis pcgr : Congr_law.

Variable a b c : A.

Definition Build_Comp :=
  Build_Map2 (pcgl (a:=a) (b:=b) (c:=c)) (pcgr (a:=a) (b:=b) (c:=c)).

End composition_to_operator.

Section cat_cong.

Variable C : Category.

Lemma Comp_l :
 forall (a b c : C) (f g : b --> c) (h : a --> b), f =_S g -> h o f =_S h o g. 

Lemma Comp_r :
 forall (a b c : C) (f g : a --> b) (h : b --> c), f =_S g -> f o h =_S g o h. 

Lemma Comp_lr :
 forall (a b c : C) (f f' : a --> b) (g g' : b --> c),
 f =_S f' -> g =_S g' -> f o g =_S f' o g'. 

End cat_cong. *)
Require Export Map2.
(* Map2:
Require Export SetoidPROD.

Set Implicit Arguments.
Unset Strict Implicit.

Section fun2_to_map2.

Variable A B C : Setoid.

Definition Map2 := Map A (B ==> C).

Definition Map2_alt := Map (SPROD A B) C.

Variable f : A -> B -> C.

Definition Map2_congl_law :=
  forall (b1 b2 : B) (a : A), b1 =_S b2 -> f a b1 =_S f a b2.

Definition Map2_congr_law :=
  forall (a1 a2 : A) (b : B), a1 =_S a2 -> f a1 b =_S f a2 b.

Definition Map2_cong_law :=
  forall (a1 a2 : A) (b1 b2 : B),
  a1 =_S a2 -> b1 =_S b2 -> f a1 b1 =_S f a2 b2.

Hypothesis pgcl : Map2_congl_law.
Hypothesis pgcr : Map2_congr_law.

Lemma Map2_map_law1 : forall a : A, Map_law (f a).

Canonical Structure Map2_map1 (a : A) := Build_Map (Map2_map_law1 a).

Lemma Map2_map_law2 : Map_law Map2_map1.

Definition Build_Map2 : Map2 := Build_Map Map2_map_law2.

End fun2_to_map2.

Section prop_map2.

Variables (A B C : Setoid) (f : Map2 A B C).

Definition Ap2 (a : A) (b : B) := f a b.

Lemma Prf_map2_congl : Map2_congl_law Ap2.

Lemma Prf_map2_congr : Map2_congr_law Ap2.

Lemma Prf_map2_cong : Map2_cong_law Ap2.

End prop_map2.

Coercion Ap2 : Map2 >-> Funclass.

Identity Coercion Map2_Map : Map2 >-> Map.

Section rew_prop_map2.

Variables (A B C : Setoid) (f : Map2 A B C).

Lemma Map2_l : forall (b1 b2 : B) (a : A), b1 =_S b2 -> f a b1 =_S f a b2.

Lemma Map2_r : forall (a1 a2 : A) (b : B), a1 =_S a2 -> f a1 b =_S f a2 b.

Lemma Map2_lr :
 forall (a1 a2 : A) (b1 b2 : B),
 a1 =_S a2 -> b1 =_S b2 -> f a1 b1 =_S f a2 b2.

End rew_prop_map2. *)

Set Implicit Arguments.
Unset Strict Implicit.

Section bp_def.

Variables (C : Category) (a b : C).

 Section bp_laws.

 Variables (Obj_prod : C) (Proj1_prod : Obj_prod --> a)
   (Proj2_prod : Obj_prod --> b).
 Variable Op : forall c : C, Map2 (c --> a) (c --> b) (c --> Obj_prod).

 Definition Together_prod (c : C) (f : c --> a) (g : c --> b) := Op c f g.

 Definition Eq1_prod_law :=
   forall (c : C) (f : c --> a) (g : c --> b),
   Together_prod f g o Proj1_prod =_S f.

 Definition Eq2_prod_law :=
   forall (c : C) (f : c --> a) (g : c --> b),
   Together_prod f g o Proj2_prod =_S g.

 Definition Unique_together_law :=
   forall (c : C) (h : c --> Obj_prod),
   Together_prod (h o Proj1_prod) (h o Proj2_prod) =_S h.

 End bp_laws.

Structure BinProd : Type := 
  {Obj_prod : C;
   Proj1_prod : Obj_prod --> a;
   Proj2_prod : Obj_prod --> b;
   Op_together : forall c : C, Map2 (c --> a) (c --> b) (c --> Obj_prod);
   Prf_eq1_prod : Eq1_prod_law Proj1_prod Op_together;
   Prf_eq2_prod : Eq2_prod_law Proj2_prod Op_together;
   Prf_unique_together :
    Unique_together_law Proj1_prod Proj2_prod Op_together}.
 
Definition Together (C1 : BinProd) (c : C) (f : c --> a) 
  (g : c --> b) := Together_prod (Op_together C1) f g.

End bp_def.

Definition HasBinProd (C : Category) := forall a b : C, BinProd a b.

Section hasbinprod_proj.

Variables (C : Category) (C1 : HasBinProd C) (a b : C).

Definition H_obj_prod := Obj_prod (C1 a b).

Definition H_proj1_prod := Proj1_prod (C1 a b).

Definition H_proj2_prod := Proj2_prod (C1 a b).

Definition H_together (c : C) (f : c --> a) (g : c --> b) :=
  Together (C1 a b) f g.

End hasbinprod_proj.

Lemma Eq3_prod :
 forall (C : Category) (a b : C) (C1 : BinProd a b) 
   (c : C) (f : c --> a) (g : c --> b) (c' : C) (k : c' --> c),
 k o Together C1 f g =_S Together C1 (k o f) (k o g).
Proof.
intros C a b C1 c f g c' k.
 apply
       Trans
        with
          (Together C1 ((k o Together C1 f g) o Proj1_prod C1)
             ((k o Together C1 f g) o Proj2_prod C1)).
apply Sym.
apply (Prf_unique_together (k o Together C1 f g)).
 apply
       Trans
        with (Together C1 (k o f) ((k o Together C1 f g) o Proj2_prod C1)).
apply
 (Prf_map2_congr (Op_together C1 _)
    (a1:=(k o Together C1 f g) o Proj1_prod C1) (a2:=
    k o f) ((k o Together C1 f g) o Proj2_prod C1)).
 apply Trans with (k o Together C1 f g o Proj1_prod C1).
apply Ass1.
apply Comp_l.
apply (Prf_eq1_prod C1 f g).
apply
 (Prf_map2_congl (Op_together C1 _)
    (b1:=(k o Together C1 f g) o Proj2_prod C1) (b2:=
    k o g) (k o f)).
 apply Trans with (k o Together C1 f g o Proj2_prod C1).
apply Ass1.
apply Comp_l; apply (Prf_eq2_prod C1 f g).
Qed.

Section mor_prod_def.

Variables (C : Category) (C1 : HasBinProd C).

 Section mor_prod_map2.
 
 Variable a b c d : C.

 Definition Mor_prod (f : a --> c) (g : b --> d) :=
   H_together C1 (H_proj1_prod C1 a b o f) (H_proj2_prod C1 a b o g).

 Lemma Mor_prod_r : Map2_congr_law Mor_prod.
 Proof.
 unfold Map2_congr_law in |- *; intros f f' g H.
 unfold Mor_prod in |- *.
 apply
  (Prf_map2_congr (Op_together (C1 c d) _) (a1:=Proj1_prod (C1 a b) o f)
     (a2:=Proj1_prod (C1 a b) o f') (Proj2_prod (C1 a b) o g)).
 apply Comp_l.
 trivial.
 Qed.

 Lemma Mor_prod_l : Map2_congl_law Mor_prod.
 Proof.
 unfold Map2_congl_law in |- *; intros f g g' H.
 unfold Mor_prod in |- *.
 apply
  (Prf_map2_congl (Op_together (C1 c d) _) (b1:=Proj2_prod (C1 a b) o f)
     (b2:=Proj2_prod (C1 a b) o g) (Proj1_prod (C1 a b) o g')).
 apply Comp_l.
 trivial.
 Qed.

 Definition Mor_prod_map2 := Build_Map2 Mor_prod_l Mor_prod_r.

 End mor_prod_map2.

Variables (a b c a' b' c' : C) (f : a --> b) (f' : a' --> b') 
  (g : b --> c) (g' : b' --> c').

Lemma Eq_Mor_prod :
 Mor_prod f f' o Mor_prod g g' =_S Mor_prod (f o g) (f' o g').
Proof.
unfold Mor_prod, H_together in |- *.
 apply
       Trans
        with
          (Together (C1 c c')
             (Together (C1 b b') (Proj1_prod (C1 a a') o f)
                (Proj2_prod (C1 a a') o f') o Proj1_prod (C1 b b') o g)
             (Together (C1 b b') (Proj1_prod (C1 a a') o f)
                (Proj2_prod (C1 a a') o f') o Proj2_prod (C1 b b') o g')).
apply Eq3_prod.
 apply
       Trans
        with
          (Together (C1 c c') (Proj1_prod (C1 a a') o f o g)
             (Together (C1 b b') (Proj1_prod (C1 a a') o f)
                (Proj2_prod (C1 a a') o f') o Proj2_prod (C1 b b') o g')).
unfold Together, Together_prod in |- *; apply Map2_r.
 apply
       Trans
        with
          ((Together (C1 b b') (Proj1_prod (C1 a a') o f)
              (Proj2_prod (C1 a a') o f') o Proj1_prod (C1 b b')) o g).
apply Ass.
 apply Trans with ((Proj1_prod (C1 a a') o f) o g).
apply Comp_r.
apply
 (Prf_eq1_prod (C1 b b') (Proj1_prod (C1 a a') o f)
    (Proj2_prod (C1 a a') o f')).
apply Ass1.
unfold Together, Together_prod in |- *; apply Map2_l.
 apply
       Trans
        with
          ((Together (C1 b b') (Proj1_prod (C1 a a') o f)
              (Proj2_prod (C1 a a') o f') o Proj2_prod (C1 b b')) o g').
apply Ass.
 apply Trans with ((Proj2_prod (C1 a a') o f') o g').
apply Comp_r.
apply
 (Prf_eq2_prod (C1 b b') (Proj1_prod (C1 a a') o f)
    (Proj2_prod (C1 a a') o f')).
apply Ass1.
Qed.

End mor_prod_def.
