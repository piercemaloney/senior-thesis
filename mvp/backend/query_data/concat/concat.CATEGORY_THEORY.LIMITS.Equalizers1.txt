
Require Export Equalizers.
(* Equalizers:
Require Export CatProperty.

Set Implicit Arguments.
Unset Strict Implicit.

Section equaz_def.

Variables (C : Category) (a b : C) (I : Type) (k : I -> (a --> b)).

 Section equaz_laws.

 Variables (c : C) (e : c --> a).

 Definition Equalizer_eq (r : C) (h : r --> a) :=
   forall i j : I, h o k i =_S h o k j.

 Definition Equalizer_law1 := Equalizer_eq e.

 Variable E_diese : forall (r : C) (h : r --> a), Equalizer_eq h -> (r --> c).

 Definition Equalizer_law2 :=
   forall (r : C) (h : r --> a) (p : Equalizer_eq h), h =_S E_diese p o e.

 Definition Equalizer_law3 :=
   forall (r : C) (h : r --> a) (p : Equalizer_eq h) (l : r --> c),
   h =_S l o e -> l =_S E_diese p.

 End equaz_laws.

Structure Equalizer : Type := 
  {E_ob : C;
   E_mor : E_ob --> a;
   Prf_E_law1 : Equalizer_law1 E_mor;
   E_diese : forall (r : C) (h : r --> a), Equalizer_eq h -> (r --> E_ob);
   Prf_E_law2 : Equalizer_law2 E_mor E_diese;
   Prf_E_law3 : Equalizer_law3 E_mor E_diese}.

Variable f : Equalizer.

Lemma E_monic : Monic_law (E_mor f).

Lemma Epic_Equalizer_id : Epic_law (E_mor f) -> Equalizer_eq (Id a).

Lemma Epic_Equalizer_iso :
 forall p : Epic_law (E_mor f),
 let f1 := E_diese f (Epic_Equalizer_id p) in AreIsos (E_mor f) f1.

Lemma Equalizer_iso :
 forall (h1 : a --> E_ob f) (p : RIso_law (E_mor f) h1),
 let f1 := E_diese f (Epic_Equalizer_id (RightInv_epic p)) in
 AreIsos (E_mor f) f1.

End equaz_def. *)
Require Export PA.
(* PA:
Require Export BasicTypes.
Require Export Category.

Set Implicit Arguments.
Unset Strict Implicit.

Section pa_def.

Variables (C : Category) (a b : C) (I : Type) (k : I -> (a --> b)).

Inductive PA_ob : Type :=
  | PA1 : PA_ob
  | PA2 : PA_ob.

Inductive PA_mor : PA_ob -> PA_ob -> Type :=
  | PA_I1 : PA_mor PA1 PA1
  | PA_I2 : PA_mor PA2 PA2
  | PA_f : I -> PA_mor PA1 PA2.

Lemma PA_11_P :
 (PA_mor PA1 PA1 -> Prop) -> forall x y : PA_ob, PA_mor x y -> Prop.

Lemma PA_11_ind :
 forall P : PA_mor PA1 PA1 -> Prop, P PA_I1 -> forall x : PA_mor PA1 PA1, P x.

Lemma PA_22_P :
 (PA_mor PA2 PA2 -> Prop) -> forall x y : PA_ob, PA_mor x y -> Prop.

Lemma PA_22_ind :
 forall P : PA_mor PA2 PA2 -> Prop, P PA_I2 -> forall x : PA_mor PA2 PA2, P x.

Lemma PA_12_P :
 (PA_mor PA1 PA2 -> Prop) -> forall x y : PA_ob, PA_mor x y -> Prop.

Lemma PA_12_ind :
 forall P : PA_mor PA1 PA2 -> Prop,
 (forall i : I, P (PA_f i)) -> forall x : PA_mor PA1 PA2, P x.

Lemma PA_21_P :
 (PA_mor PA2 PA1 -> Prop) -> forall x y : PA_ob, PA_mor x y -> Prop.

Lemma PA_21_ind :
 forall (P : PA_mor PA2 PA1 -> Prop) (x : PA_mor PA2 PA1), P x.

Lemma PA_21_T :
 (PA_mor PA2 PA1 -> Type) -> forall x y : PA_ob, PA_mor x y -> Type.

Lemma PA_21_rect :
 forall (P : PA_mor PA2 PA1 -> Type) (x : PA_mor PA2 PA1), P x.

Definition Equal_PA_mor (x y : PA_ob) (f g : PA_mor x y) :=
  match f in (PA_mor x' y') return Prop with
  | PA_I1 => 
        True
       
  | PA_I2 => True
       
  | PA_f i =>
      match g in (PA_mor x' y') return Prop with
      | PA_I1 => 
            False
           
      | PA_I2 => False
           
      | PA_f j => k i =_S k j
      end
  end.

Lemma Equal_PA_mor_Equiv :
 forall x y : PA_ob, Equivalence (Equal_PA_mor (x:=x) (y:=y)).

Canonical Structure PA_mor_setoid (x y : PA_ob) :=
  Build_Setoid (Equal_PA_mor_Equiv x y).

Definition Comp_PA_mor (x y z : PA_ob) (f : PA_mor x y) :=
  match f in (PA_mor p p0) return (PA_mor p0 z -> PA_mor p z) with
  | PA_I1 => 
       
      match z as p return (PA_mor PA1 p -> PA_mor PA1 p) with
      | PA1 =>
            fun _ => PA_I1 
                      
      | PA2 => fun g => g
      end
       
  | PA_I2 =>
      match z as p return (PA_mor PA2 p -> PA_mor PA2 p) with
      | PA1 =>
           
          fun g => PA_21_rect (fun _ => PA_mor PA2 PA1) g
           
      | PA2 => fun _ => PA_I2
      end
       
  | PA_f x =>
      match z as p return (I -> PA_mor PA2 p -> PA_mor PA1 p) with
      | PA1 =>
           
          fun _ g => PA_21_rect (fun _ => PA_mor PA1 PA1) g
           
      | PA2 => fun i _ => PA_f i
      end x
  end.

Lemma Comp_PA_fact1 :
 forall (f : PA_mor PA1 PA1) (x : PA_ob) (g : PA_mor PA1 x),
 Comp_PA_mor f g =_S g.

Lemma Comp_PA_fact2 :
 forall (f : PA_mor PA2 PA2) (x : PA_ob) (g : PA_mor PA2 x),
 Comp_PA_mor f g =_S g.

Lemma Comp_PA_fact3 :
 forall (i : I) (g : PA_mor PA2 PA2), Comp_PA_mor (PA_f i) g =_S PA_f i.

Lemma Comp_PA_fact4 :
 forall (i : I) (g : PA_mor PA2 PA1) (h : PA_mor PA1 PA1),
 Comp_PA_mor (PA_f i) g =_S h.

Lemma Comp_PA_congl : Congl_law Comp_PA_mor.

Lemma Comp_PA_congr : Congr_law Comp_PA_mor.

Definition Comp_PA := Build_Comp Comp_PA_congl Comp_PA_congr.

Lemma Assoc_PA : Assoc_law Comp_PA.

Definition Id_PA (x : PA_ob) :=
  match x as x' return (PA_mor x' x') with
  | PA1 =>   PA_I1 
       
  | PA2 => PA_I2
  end.

Lemma Idl_PA : Idl_law Comp_PA Id_PA.

Lemma Idr_PA : Idr_law Comp_PA Id_PA.

Canonical Structure PA := Build_Category Assoc_PA Idl_PA Idr_PA.

End pa_def. *)
Require Export Limit.
(* Limit:
Require Export Const.
Require Export CoUniversalArrow.
Require Export Ntransformation.

Set Implicit Arguments.
Unset Strict Implicit.

Section def_cone.

Variables (J C : Category) (c : C) (F : Functor J C).

SubClass Cone := NT (Const J c) F.

Definition Cones := NT_setoid (Const J c) F.

 Section cone_nt.

 Variable T : forall a : J, c --> F a.

 Definition Cone_law :=
   forall (i j : J) (g : i --> j), T j =_S T i o FMor F g.

 Lemma Prf_Cone_nt_law : Cone_law -> NT_law (F:=Const J c) T.
 
 Coercion Prf_Cone_nt_law : Cone_law >-> NT_law.

 Variable p : Cone_law.

 Canonical Structure Build_Cone : Cone := Build_NT (Prf_Cone_nt_law p).

 End cone_nt.

Coercion Build_Cone : Cone_law >-> Cone.
  
Lemma Eq_cone : forall tau : Cone, Cone_law (ApNT tau).

Lemma EqC :
 forall (tau : Cone) (i j : J) (g : i --> j), tau j =_S tau i o FMor F g.

Lemma EqC1 :
 forall (tau : Cone) (i j : J) (g : i --> j), tau i o FMor F g =_S tau j.

End def_cone.
		
Section limit_def.

Variables (J C : Category) (F : Functor J C).

 Section islimit_def. 
 
 Variables (lim : C) (nu : Cone lim F).

  Section limit_laws.

  Variable l_diese : forall c : C, Cone c F -> (c --> lim).  

  Definition Limit_eq (c : C) (tau : Cone c F) (g : c --> lim) :=
    forall i : J, g o nu i =_S tau i.
                      
  Definition Limit_law1 :=
    forall (c : C) (tau : Cone c F), Limit_eq tau (l_diese tau).

  Definition Limit_law2 :=
    forall (c : C) (tau : Cone c F) (g : c --> lim),
    Limit_eq tau g -> g =_S l_diese tau.
  
  End limit_laws.

 Structure IsLimit : Type := 
   {Lim_diese : forall c : C, Cone c F -> (c --> lim);
    Prf_limit1 : Limit_law1 Lim_diese;
    Prf_limit2 : Limit_law2 Lim_diese}.

 Variable l : IsLimit.

 Lemma Ldiese_map :
  forall (c : C) (tau1 tau2 : Cone c F),
  tau1 =_NT tau2 -> Lim_diese l tau1 =_S Lim_diese l tau2.
 
 End islimit_def.

 Structure > Limit : Type := 
   {Lim : C;
    Limiting_cone : Cone Lim F;
    Prf_Islimit :> IsLimit Limiting_cone}.

End limit_def.

Definition Complete (C : Category) :=
  forall (J : Category) (F : Functor J C), Limit F. *)

Set Implicit Arguments.
Unset Strict Implicit.

Section equalizer_limit_def.

Variables (C : Category) (a b : C) (I : Type) (k : I -> (a --> b)).

Definition FPA_ob (x : PA k) := match x with
                                | PA1 => a
                                | PA2 => b
                                end.

Definition FPA_mor (x y : PA k) (f : x --> y) :=
  match f in (PA_mor _ x' y') return (Carrier (FPA_ob x' --> FPA_ob y')) with
  | PA_I1 => Id a
  | PA_I2 => Id b
  | PA_f i => k i
  end.

Lemma FPA_map_law : forall x y : PA_ob, Map_law (FPA_mor (x:=x) (y:=y)).
Proof.
unfold Map_law in |- *; simpl in |- *.
intros x y f; elim f.

simpl in |- *; intros g H;
 apply (PA_11_ind (P:=fun x : PA_mor_setoid k PA1 PA1 => Id a =_S FPA_mor x)).
simpl in |- *; apply Refl.

simpl in |- *; intros g H;
 apply
  (PA_22_ind (P:=fun x' : PA_mor_setoid k PA2 PA2 => Id b =_S FPA_mor x')).
simpl in |- *; apply Refl.

intros i g;
 lapply
  (PA_12_ind
     (P:=fun x' : PA_mor_setoid k PA1 PA2 =>
         Equal_PA_mor k (PA_f i) x' -> k i =_S FPA_mor x')).
intros H H0; apply (H g H0).
simpl in |- *; auto.
Qed.

Canonical Structure FPA_map (x y : PA k) :=
  Build_Map (FPA_map_law (x:=x) (y:=y)).

Lemma FPA_comp_law : Fcomp_law FPA_map.
Proof.
unfold Fcomp_law in |- *.
intros x y z f; elim f.

intro g.
 apply Trans with (FPA_map _ _ g).
apply Pres1.
apply (Comp_PA_fact1 k (PA_I1 I) g).
simpl in |- *; apply Idl1.

intro g.
 apply Trans with (FPA_map _ _ g).
apply Pres1.
apply (Comp_PA_fact2 k (PA_I2 I) g).
simpl in |- *; apply Idl1.

intro i; elim z; intro g.
apply
 (PA_21_ind
    (fun x' : PA_mor I PA2 PA1 =>
     FPA_mor (Comp_PA_mor (PA_f i) g) =_S k i o FPA_mor g) g).
simpl in |- *.
apply (PA_22_ind (P:=fun x : PA_mor I PA2 PA2 => k i =_S k i o FPA_mor x)).
simpl in |- *; apply Idr. 
Qed.

Lemma FPA_id_law : Fid_law FPA_map.
Proof.
unfold Fid_law in |- *; simpl in |- *.
intro x; elim x; simpl in |- *; apply Refl.
Qed.

Canonical Structure FPA := Build_Functor FPA_comp_law FPA_id_law.

SubClass Equalizer1 := Limit FPA.

Structure Equalizer2 : Type :=  {Prf_equalizer1 :> Equalizer1; Witness : I}.

Variable l : Equalizer2.

Definition E1_ob := Lim l.

Definition E1_mor : E1_ob --> a := Limiting_cone l PA1.
 
Lemma Prf_E1_law1 : Equalizer_law1 k E1_mor.
Proof.
unfold Equalizer_law1, Equalizer_eq, E1_mor in |- *.
intros i j.
 apply Trans with (Limiting_cone l PA2). 
apply (EqC1 (Limiting_cone l) (PA_f i)).
apply (EqC (Limiting_cone l) (PA_f j)).
Qed.

 Section e1_diese_def.

 Variables (r : C) (h : r --> a).
 Hypothesis p : Equalizer_eq k h.

 Definition E_tau (x : PA k) :=
   match x as x' return (Carrier (r --> FPA x')) with
   | PA1 => h
   | PA2 => h o k (Witness l)
   end.
 
 Lemma E_tau_cone_law : Cone_law E_tau.
 Proof.
 unfold Cone_law in |- *; intros x o2 f.
 elim f.
 
 unfold FMor in |- *; simpl in |- *; apply Idr.
 
 unfold FMor in |- *; simpl in |- *; apply Idr.
 
 unfold FMor in |- *; simpl in |- *.
 intro i; apply (p (Witness l) i).
 Qed.
 
 Definition E_NT := Build_Cone E_tau_cone_law.

 Definition E1_diese : r --> E1_ob := Lim_diese l E_NT.
 
 End e1_diese_def.

Lemma Prf_E1_law2 : Equalizer_law2 E1_mor E1_diese.
Proof.
unfold Equalizer_law2, E1_mor, Equalizer_eq in |- *.
intros r h p.
apply Sym; apply (Prf_limit1 l (E_NT p) PA1).
Qed.

Lemma Prf_E1_law3 : Equalizer_law3 E1_mor E1_diese.
Proof.
unfold Equalizer_law3, E1_mor, Equalizer_eq in |- *.
intros r h p q H.
unfold E1_diese in |- *; apply (Prf_limit2 l).
unfold Limit_eq in |- *; simpl in |- *.
intro x; elim x; simpl in |- *.
apply Sym; apply H.
 apply Trans with ((q o E1_mor) o k (Witness l)).
 apply Trans with (q o E1_mor o k (Witness l)).
apply Comp_l.
apply (EqC (Limiting_cone l) (PA_f (Witness l))).
apply Ass.
apply Comp_r; apply Sym; apply H.
Qed.

Canonical Structure Equalizer2_to_Equalizer :=
  Build_Equalizer Prf_E1_law1 Prf_E1_law2 Prf_E1_law3.

End equalizer_limit_def.

Coercion Equalizer2_to_Equalizer : Equalizer2 >-> Equalizer.

Section equaz_fg.

Variables (C : Category) (a b : C) (f g : a --> b).

Definition K_fg (i : TwoElts) := match i with
                                 | Elt1 => f
                                 | Elt2 => g
                                 end.

Definition J_fg := PA K_fg.

Definition F_fg := FPA K_fg.

SubClass Equalizer1_fg := Equalizer1 K_fg.

Lemma Prf_law1_fg :
 forall (r : C) (h : r --> a), h o f =_S h o g -> Equalizer_eq K_fg h.
Proof.
intros r h H; unfold Equalizer_eq in |- *.
intros i j; elim i; elim j; simpl in |- *.
apply Refl.
apply H.
apply Sym; trivial.
apply Refl.
Qed.

End equaz_fg.

Section equaz_hom.

Variables (C : Category) (a b : C).

Definition K_hom (f : a --> b) := f.

Definition J_hom := PA K_hom.

Definition F_hom := FPA K_hom.

SubClass Equalizer1_hom := Equalizer1 K_hom.

End equaz_hom.