
Require Export SetoidPROD.
(* SetoidPROD:
Require Export Map.

Set Implicit Arguments.
Unset Strict Implicit.

Section s_prod.

Variable A B : Setoid.

Structure Sprod : Type :=  {Sprod_l : A; Sprod_r : B}.

Definition Equal_Sprod (a1xb1 a2xb2 : Sprod) :=
  Sprod_l a1xb1 =_S Sprod_l a2xb2 /\ Sprod_r a1xb1 =_S Sprod_r a2xb2.

Lemma Equal_Sprod_equiv : Equivalence Equal_Sprod.

Canonical Structure SPROD : Setoid := Equal_Sprod_equiv.

Lemma Proj1_SPROD_map_law : Map_law (Sprod_l:SPROD -> A).

Canonical Structure Proj1_SPROD : Map SPROD A := Proj1_SPROD_map_law.

Lemma Proj2_SPROD_map_law : Map_law (Sprod_r:SPROD -> B).

Canonical Structure Proj2_SPROD : Map SPROD B := Proj2_SPROD_map_law.

End s_prod. *)
Require Export Binary_Products.
(* Binary_Products:
Require Export Category.
Require Export Map2.

Set Implicit Arguments.
Unset Strict Implicit.

Section bp_def.

Variables (C : Category) (a b : C).

 Section bp_laws.

 Variables (Obj_prod : C) (Proj1_prod : Obj_prod --> a)
   (Proj2_prod : Obj_prod --> b).
 Variable Op : forall c : C, Map2 (c --> a) (c --> b) (c --> Obj_prod).

 Definition Together_prod (c : C) (f : c --> a) (g : c --> b) := Op c f g.

 Definition Eq1_prod_law :=
   forall (c : C) (f : c --> a) (g : c --> b),
   Together_prod f g o Proj1_prod =_S f.

 Definition Eq2_prod_law :=
   forall (c : C) (f : c --> a) (g : c --> b),
   Together_prod f g o Proj2_prod =_S g.

 Definition Unique_together_law :=
   forall (c : C) (h : c --> Obj_prod),
   Together_prod (h o Proj1_prod) (h o Proj2_prod) =_S h.

 End bp_laws.

Structure BinProd : Type := 
  {Obj_prod : C;
   Proj1_prod : Obj_prod --> a;
   Proj2_prod : Obj_prod --> b;
   Op_together : forall c : C, Map2 (c --> a) (c --> b) (c --> Obj_prod);
   Prf_eq1_prod : Eq1_prod_law Proj1_prod Op_together;
   Prf_eq2_prod : Eq2_prod_law Proj2_prod Op_together;
   Prf_unique_together :
    Unique_together_law Proj1_prod Proj2_prod Op_together}.
 
Definition Together (C1 : BinProd) (c : C) (f : c --> a) 
  (g : c --> b) := Together_prod (Op_together C1) f g.

End bp_def.

Definition HasBinProd (C : Category) := forall a b : C, BinProd a b.

Section hasbinprod_proj.

Variables (C : Category) (C1 : HasBinProd C) (a b : C).

Definition H_obj_prod := Obj_prod (C1 a b).

Definition H_proj1_prod := Proj1_prod (C1 a b).

Definition H_proj2_prod := Proj2_prod (C1 a b).

Definition H_together (c : C) (f : c --> a) (g : c --> b) :=
  Together (C1 a b) f g.

End hasbinprod_proj.

Lemma Eq3_prod :
 forall (C : Category) (a b : C) (C1 : BinProd a b) 
   (c : C) (f : c --> a) (g : c --> b) (c' : C) (k : c' --> c),
 k o Together C1 f g =_S Together C1 (k o f) (k o g).

Section mor_prod_def.

Variables (C : Category) (C1 : HasBinProd C).

 Section mor_prod_map2.
 
 Variable a b c d : C.

 Definition Mor_prod (f : a --> c) (g : b --> d) :=
   H_together C1 (H_proj1_prod C1 a b o f) (H_proj2_prod C1 a b o g).

 Lemma Mor_prod_r : Map2_congr_law Mor_prod.

 Lemma Mor_prod_l : Map2_congl_law Mor_prod.

 Definition Mor_prod_map2 := Build_Map2 Mor_prod_l Mor_prod_r.

 End mor_prod_map2.

Variables (a b c a' b' c' : C) (f : a --> b) (f' : a' --> b') 
  (g : b --> c) (g' : b' --> c').

Lemma Eq_Mor_prod :
 Mor_prod f f' o Mor_prod g g' =_S Mor_prod (f o g) (f' o g').

End mor_prod_def. *)
Require Export SET.
(* SET:
Require Export Category.

Set Implicit Arguments.
Unset Strict Implicit.

Lemma Comp_map_congl : Congl_law Comp_map.

Lemma Comp_map_congr : Congr_law Comp_map.

Definition Comp_SET := Build_Comp Comp_map_congl Comp_map_congr.

Lemma Assoc_SET : Assoc_law Comp_SET.

Definition Id_SET := Id_map.
 
Lemma Idl_SET : Idl_law Comp_SET Id_SET.

Lemma Idr_SET : Idr_law Comp_SET Id_SET.

Canonical Structure SET := Build_Category Assoc_SET Idl_SET Idr_SET. *)

Set Implicit Arguments.
Unset Strict Implicit.

Section verif_prod.

Variable A B : Setoid.

 Section set_op_together_def.

 Variable C : Setoid.

  Section set_together_def.

  Variables (f : Map C A) (g : Map C B).

  Definition S_together_fun (c : C) := Build_Sprod (f c) (g c).

  Lemma S_together_map_law : Map_law S_together_fun.
  Proof.
  unfold Map_law in |- *.
  intros c1 c2 H; unfold S_together_fun in |- *; simpl in |- *.
  unfold Equal_Sprod in |- *; simpl in |- *; split; apply Pres1; trivial.
  Qed.

  Definition S_together := Build_Map S_together_map_law.

  End set_together_def.

 Lemma S_together_l : Map2_congl_law S_together.
 Proof.
 unfold Map2_congl_law in |- *; simpl in |- *; intros g g' f H;
  unfold Ext in |- *; simpl in |- *.
 intro c; unfold Equal_Sprod in |- *; simpl in |- *; split.
 apply Refl.
 apply (H c).
 Qed.

 Lemma S_together_r : Map2_congr_law S_together.
 Proof.
 unfold Map2_congr_law in |- *; simpl in |- *; intros f f' g H;
  unfold Ext in |- *; simpl in |- *.
 intro c; unfold Equal_Sprod in |- *; simpl in |- *; split.
 apply (H c).
 apply Refl.
 Qed.

 Definition S_op_together := Build_Map2 S_together_l S_together_r.
 
 End set_op_together_def. 

Lemma Eq1_Sprod : Eq1_prod_law (Proj1_SPROD A B) S_op_together.
Proof.
unfold S_op_together, Eq1_prod_law in |- *; simpl in |- *; intros C f g.
unfold Ext in |- *; simpl in |- *.
intro c; apply Refl.
Qed.

Lemma Eq2_Sprod : Eq2_prod_law (Proj2_SPROD A B) S_op_together.
Proof.
unfold S_op_together, Eq2_prod_law in |- *; simpl in |- *; intros C f g.
unfold Ext in |- *; simpl in |- *.
intro c; apply Refl.
Qed.

Lemma Unique_S_together :
 Unique_together_law (Proj1_SPROD A B) (Proj2_SPROD A B) S_op_together.
Proof.
unfold Unique_together_law, S_op_together in |- *; simpl in |- *; intros C h.
unfold Ext in |- *; simpl in |- *.
intro c; unfold Equal_Sprod in |- *; simpl in |- *; split; apply Refl.
Qed.

Definition SET_hasBinProd :=
  Build_BinProd Eq1_Sprod Eq2_Sprod Unique_S_together.

End verif_prod.