
Require Export Limit.
(* Limit:
Require Export Const.
Require Export CoUniversalArrow.
Require Export Ntransformation.

Set Implicit Arguments.
Unset Strict Implicit.

Section def_cone.

Variables (J C : Category) (c : C) (F : Functor J C).

SubClass Cone := NT (Const J c) F.

Definition Cones := NT_setoid (Const J c) F.

 Section cone_nt.

 Variable T : forall a : J, c --> F a.

 Definition Cone_law :=
   forall (i j : J) (g : i --> j), T j =_S T i o FMor F g.

 Lemma Prf_Cone_nt_law : Cone_law -> NT_law (F:=Const J c) T.
 
 Coercion Prf_Cone_nt_law : Cone_law >-> NT_law.

 Variable p : Cone_law.

 Canonical Structure Build_Cone : Cone := Build_NT (Prf_Cone_nt_law p).

 End cone_nt.

Coercion Build_Cone : Cone_law >-> Cone.
  
Lemma Eq_cone : forall tau : Cone, Cone_law (ApNT tau).

Lemma EqC :
 forall (tau : Cone) (i j : J) (g : i --> j), tau j =_S tau i o FMor F g.

Lemma EqC1 :
 forall (tau : Cone) (i j : J) (g : i --> j), tau i o FMor F g =_S tau j.

End def_cone.
		
Section limit_def.

Variables (J C : Category) (F : Functor J C).

 Section islimit_def. 
 
 Variables (lim : C) (nu : Cone lim F).

  Section limit_laws.

  Variable l_diese : forall c : C, Cone c F -> (c --> lim).  

  Definition Limit_eq (c : C) (tau : Cone c F) (g : c --> lim) :=
    forall i : J, g o nu i =_S tau i.
                      
  Definition Limit_law1 :=
    forall (c : C) (tau : Cone c F), Limit_eq tau (l_diese tau).

  Definition Limit_law2 :=
    forall (c : C) (tau : Cone c F) (g : c --> lim),
    Limit_eq tau g -> g =_S l_diese tau.
  
  End limit_laws.

 Structure IsLimit : Type := 
   {Lim_diese : forall c : C, Cone c F -> (c --> lim);
    Prf_limit1 : Limit_law1 Lim_diese;
    Prf_limit2 : Limit_law2 Lim_diese}.

 Variable l : IsLimit.

 Lemma Ldiese_map :
  forall (c : C) (tau1 tau2 : Cone c F),
  tau1 =_NT tau2 -> Lim_diese l tau1 =_S Lim_diese l tau2.
 
 End islimit_def.

 Structure > Limit : Type := 
   {Lim : C;
    Limiting_cone : Cone Lim F;
    Prf_Islimit :> IsLimit Limiting_cone}.

End limit_def.

Definition Complete (C : Category) :=
  forall (J : Category) (F : Functor J C), Limit F. *)
Require Export Discr.
(* Discr:
Require Export Category.

Set Implicit Arguments.
Unset Strict Implicit.

Section discrete.

Variable U : Type.

Inductive Discr_mor : U -> U -> Type :=
    Build_Discr_mor : forall a : U, Discr_mor a a.

 Section disc_mor_setoid.

 Variable a b : U.

 Definition Equal_Discr_mor (f g : Discr_mor a b) := True.

 Lemma Equal_Discr_mor_equiv : Equivalence Equal_Discr_mor.

 Canonical Structure Discr_mor_setoid := Build_Setoid Equal_Discr_mor_equiv.

 End disc_mor_setoid.

Definition Comp_Discr_mor (a b c : U) (f : Discr_mor a b) :=
  match f in (Discr_mor d d0) return (Discr_mor d0 c -> Discr_mor d c) with
  | Build_Discr_mor x =>
      fun g : Discr_mor x c =>
      match g in (Discr_mor d d0) return (Discr_mor d d0) with
      | Build_Discr_mor x => Build_Discr_mor x
      end
  end.
   
Lemma Comp_Discr_congl : Congl_law Comp_Discr_mor.

Lemma Comp_Discr_congr : Congr_law Comp_Discr_mor.

Definition Comp_Discr := Build_Comp Comp_Discr_congl Comp_Discr_congr.

Lemma Assoc_Discr : Assoc_law Comp_Discr.

Definition Id_Discr (a : U) := Build_Discr_mor a.

Lemma Idl_Discr : Idl_law Comp_Discr Id_Discr.

Lemma Idr_Discr : Idr_law Comp_Discr Id_Discr.

Canonical Structure Discr := Build_Category Assoc_Discr Idl_Discr Idr_Discr.

End discrete.

Axiom
  Discr_mor_ind1 :
    forall (U : Type) (a : U) (P : Discr_mor a a -> Prop),
    P (Build_Discr_mor a) -> forall x : Discr_mor a a, P x. *)
Require Export Products.
(* Products:
Require Export Category.
Require Export BasicTypes.

Set Implicit Arguments.
Unset Strict Implicit.

Section prodts_def.

Variables (C : Category) (I : Type) (a : I -> C).

 Section prodts_laws.

 Variables (PI : C) (Proj : forall i : I, PI --> a i).

 Definition Product_eq (r : C) (h : forall i : I, r --> a i)
   (g : r --> PI) := forall i : I, h i =_S g o Proj i.

 Variable Pd_diese : forall r : C, (forall i : I, r --> a i) -> (r --> PI).

 Definition Product_law1 :=
   forall (r : C) (h : forall i : I, r --> a i), Product_eq h (Pd_diese h).

 Definition Product_law2 :=
   forall (r : C) (h : forall i : I, r --> a i) (g : r --> PI),
   Product_eq h g -> g =_S Pd_diese h.

 End prodts_laws.

Structure Product : Type := 
  {Pi : C;
   Proj : forall i : I, Pi --> a i;
   Pd_diese : forall r : C, (forall i : I, r --> a i) -> (r --> Pi);
   Prf_pd_law1 : Product_law1 Proj Pd_diese;
   Prf_pd_law2 : Product_law2 Proj Pd_diese}.

End prodts_def.

Section binprod'_def.

Variables (C : Category) (a b : C). 

Definition Fam2 (i : TwoElts) := match i with
                                 | Elt1 => a
                                 | Elt2 => b
                                 end.

Definition BinProd' := Product Fam2.

End binprod'_def. *)

Set Implicit Arguments.
Unset Strict Implicit.

Section products_limit_def.

Variables (C : Category) (I : Type) (a : I -> C).

Definition FunDiscr_ob (i : Discr I) := a i.

Definition FunDiscr_arrow (i j : Discr I) (f : i --> j) :=
  match f in (Discr_mor d d0) return (Carrier (a d --> a d0)) with
  | Build_Discr_mor k => Id (a k)
  end.

Lemma FunDiscr_map_law :
 forall i j : I, Map_law (FunDiscr_arrow (i:=i) (j:=j)).
Proof.
unfold Map_law in |- *.
intros i j f; elim f; intros k f1 H.
apply
 (Discr_mor_ind1
    (P:=fun f1 : Discr_mor k k =>
        FunDiscr_arrow (Build_Discr_mor k) =_S FunDiscr_arrow f1)).
simpl in |- *; apply Refl.
Qed.

Canonical Structure FunDiscr_map (i j : Discr I) :=
  Build_Map (FunDiscr_map_law (i:=i) (j:=j)).

Lemma FunDiscr_comp_law : Fcomp_law FunDiscr_map.
Proof.
unfold Fcomp_law in |- *; intros i j k f.
elim f; simpl in |- *.
intros i' g; elim g; simpl in |- *.
intro i''; unfold Comp in |- *; apply (Prf_idr (c:=C)).
Qed.

Lemma FunDiscr_id_law : Fid_law FunDiscr_map.
Proof.
unfold Fid_law in |- *; simpl in |- *.
intro i; apply Refl.
Qed.

Canonical Structure FunDiscr :=
  Build_Functor FunDiscr_comp_law FunDiscr_id_law.

SubClass Product1 := Limit FunDiscr.

Variable l : Product1.

Definition Pi1 := Lim l.

Definition Proj1 (i : I) : Pi1 --> a i := Limiting_cone l i.

 Section pd1_diese_def.

 Variables (c : C) (f : forall j : I, c --> FunDiscr j).

 Definition Product_tau (j : Discr I) := f j.

 Lemma Product_tau_cone_law : Cone_law Product_tau.
 Proof.
 unfold Cone_law, Product_tau in |- *; simpl in |- *.
 intros a' b g; elim g; simpl in |- *; intro i.
 unfold FMor in |- *; simpl in |- *.
 apply Idr.
 Qed.

 Definition Product_nt := Build_Cone Product_tau_cone_law.

 Definition Pd1_diese : c --> Pi1 := Lim_diese l Product_nt.

 End pd1_diese_def.

Lemma Prf_pd1_law1 : Product_law1 Proj1 Pd1_diese.
Proof.
unfold Product_law1, Product_eq in |- *; intros c f j.
apply Sym; apply (Prf_limit1 l (Product_nt f) j).
Qed.

Lemma Prf_pd1_law2 : Product_law2 Proj1 Pd1_diese.
Proof.
unfold Product_law2, Product_eq in |- *; intros c f g H.
unfold Pd1_diese in |- *; apply (Prf_limit2 l).

unfold Limit_eq in |- *; simpl in |- *; unfold Product_tau in |- *;
 simpl in |- *.
intro i; apply Sym; apply (H i).
Qed.

Canonical Structure Product1_to_Product :=
  Build_Product Prf_pd1_law1 Prf_pd1_law2.

End products_limit_def.

Coercion Product1_to_Product : Product1 >-> Product.

