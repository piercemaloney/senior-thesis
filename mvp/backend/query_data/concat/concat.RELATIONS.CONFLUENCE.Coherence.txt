

Hint Resolve refl_equal. 

Require Import Relations.
(* Relations:
Set Implicit Arguments.
Unset Strict Implicit.

Section Orderings.

Variable U : Type.
   
Definition Relation := U -> U -> Prop.

Variable R : Relation.
   
Definition Reflexive := forall x : U, R x x.
   
Definition Transitive := forall x y z : U, R x y -> R y z -> R x z.
   
Definition Symmetric := forall x y : U, R x y -> R y x.
   
Definition Antisymmetric := forall x y : U, R x y -> R y x -> x = y.
   
Definition Contains (R R' : Relation) := forall x y : U, R' x y -> R x y.
   
Definition Same_relation (R R' : Relation) := Contains R R' /\ Contains R' R.

Structure Preorder : Prop := 
  {Prf_refl1 : Reflexive; Prf_trans1 : Transitive}.
   
Structure Order : Prop := 
  {Prf_preorder :> Preorder; Prf_asym : Antisymmetric}.
   
Structure Partial_equivalence : Prop := 
  {Prf_trans : Transitive; Prf_sym : Symmetric}.
   
Structure Equivalence : Prop := 
  {Prf_refl : Reflexive; Prf_pequiv :> Partial_equivalence}.
   
Canonical Structure Equiv_preorder (e : Equivalence) :=
  Build_Preorder (Prf_refl e) (Prf_trans e).
   
Coercion Equiv_preorder : Equivalence >-> Preorder.

End Orderings.

Hint Unfold Reflexive.
Hint Unfold Transitive.
Hint Unfold Antisymmetric.
Hint Unfold Symmetric.
Hint Unfold Contains.
Hint Unfold Same_relation.
Hint Resolve Build_Preorder.
Hint Resolve Build_Order.
Hint Resolve Build_Equivalence.
Hint Resolve Build_Partial_equivalence. *)

Require Import Confluence.
(* Confluence:
Require Import Relations.

Set Implicit Arguments.
Unset Strict Implicit.

Section Confluence.
   Variable U : Type.
   Variable R : Relation U.
   
   Inductive Rstar : Relation U :=
     | Rstar_0 : forall x : U, Rstar x x
     | Rstar_n : forall x y z : U, R x y -> Rstar y z -> Rstar x z.
   
   Inductive Rstar1 : Relation U :=
     | Rstar1_0 : forall x : U, Rstar1 x x
     | Rstar1_1 : forall x y : U, R x y -> Rstar1 x y
     | Rstar1_n : forall x y z : U, Rstar1 x y -> Rstar1 y z -> Rstar1 x z.
   
   Inductive Rplus : Relation U :=
     | Rplus_0 : forall x y : U, R x y -> Rplus x y
     | Rplus_n : forall x y z : U, R x y -> Rplus y z -> Rplus x z.
   
   Definition Strongly_confluent : Prop :=
     forall x a b : U, R x a -> R x b -> exists z : U, R a z /\ R b z.

   Definition coherent (x y : U) : Prop :=
     exists z : U, Rstar x z /\ Rstar y z.
   
   Definition locally_confluent (x : U) : Prop :=
     forall y z : U, R x y -> R x z -> coherent y z.
   
   Definition Locally_confluent : Prop := forall x : U, locally_confluent x.
   
   Definition confluent (x : U) : Prop :=
     forall y z : U, Rstar x y -> Rstar x z -> coherent y z.
   
   Definition Confluent : Prop := forall x : U, confluent x.
   
End Confluence.
   
Hint Resolve Rstar_0.
Hint Resolve Rstar1_0.
Hint Resolve Rstar1_1.
Hint Resolve Rplus_0. *)



Set Implicit Arguments.

Unset Strict Implicit.



Theorem Rstar_reflexive :

 forall (U : Type) (R : Relation U), Reflexive (Rstar R).

Proof.

auto.

Qed.



Theorem Rplus_contains_R :

 forall (U : Type) (R : Relation U), Contains (Rplus R) R.

Proof.

auto.

Qed.



Theorem Rstar_contains_R :

 forall (U : Type) (R : Relation U), Contains (Rstar R) R.

Proof.

intros U R; red in |- *; intros x y H'; apply Rstar_n with y; auto.

Qed.



Theorem Rstar_contains_Rplus :

 forall (U : Type) (R : Relation U), Contains (Rstar R) (Rplus R).

Proof.

intros U R; red in |- *.

intros x y H'; elim H'.

generalize Rstar_contains_R; intro T; red in T; auto.

intros x0 y0 z H'0 H'1 H'2; apply Rstar_n with y0; auto.

Qed.



Theorem Rstar_transitive :

 forall (U : Type) (R : Relation U), Transitive (Rstar R).

Proof.

intros U R; red in |- *.

intros x y z H'; elim H'; auto.

intros x0 y0 z0 H'0 H'1 H'2 H'3; apply Rstar_n with y0; auto.

Qed.



Theorem Rstar_cases :

 forall (U : Type) (R : Relation U) (x y : U),

 Rstar R x y -> x = y \/ (exists u : U, R x u /\ Rstar R u y).

Proof.

intros U R x y H'; elim H'; auto.

intros x0 y0 z H'0 H'1 H'2; right; exists y0; auto.

Qed.



Theorem Rstar_equiv_Rstar1 :

 forall (U : Type) (R : Relation U), Same_relation (Rstar R) (Rstar1 R).

Proof.

generalize Rstar_contains_R; intro T; red in T.

intros U R; unfold Same_relation, Contains in |- *.

split; intros x y H'; elim H'; auto.

generalize Rstar_transitive; intro T1; red in T1.

intros x0 y0 z H'0 H'1 H'2 H'3; apply T1 with y0; auto.

intros x0 y0 z H'0 H'1 H'2; apply Rstar1_n with y0; auto.

Qed.



Theorem Rsym_imp_Rstarsym :

 forall (U : Type) (R : Relation U), Symmetric R -> Symmetric (Rstar R).

Proof.

intros U R H'; red in |- *.

intros x y H'0; elim H'0; auto.

intros x0 y0 z H'1 H'2 H'3.

generalize Rstar_transitive; intro T; red in T.

apply T with y0; auto.

apply Rstar_n with x0; auto.

Qed.



Theorem Sstar_contains_Rstar :

 forall (U : Type) (R S : Relation U),

 Contains (Rstar S) R -> Contains (Rstar S) (Rstar R).

Proof.

unfold Contains in |- *.

intros U R S H' x y H'0; elim H'0; auto.

generalize Rstar_transitive; intro T; red in T.

intros x0 y0 z H'1 H'2 H'3; apply T with y0; auto.

Qed.



Theorem star_monotone :

 forall (U : Type) (R S : Relation U),

 Contains S R -> Contains (Rstar S) (Rstar R).

Proof.

intros U R S H'.

apply Sstar_contains_Rstar.

generalize (Rstar_contains_R (R:=S)); auto.

Qed.



Theorem RstarRplus_RRstar :

 forall (U : Type) (R : Relation U) (x y z : U),

 Rstar R x y -> Rplus R y z -> exists u : U, R x u /\ Rstar R u z.

Proof.

generalize Rstar_contains_Rplus; intro T; red in T.

generalize Rstar_transitive; intro T1; red in T1.

intros U R x y z H'; elim H'.

intros x0 H'0; elim H'0.

intros; exists y0; auto.

intros; exists y0; auto.

intros; exists y0; auto.

split; [ try assumption | idtac ].

apply T1 with z0; auto.

Qed.



Theorem Rstar_imp_coherent :

 forall (U : Type) (R : Relation U) (x y : U), Rstar R x y -> coherent R x y.

Proof.

intros U R x y H'; red in |- *.

exists y; auto.

Qed.

Hint Resolve Rstar_imp_coherent.



Theorem coherent_symmetric :

 forall (U : Type) (R : Relation U), Symmetric (coherent R).

Proof.

unfold coherent at 1 in |- *.

intros U R; red in |- *.

intros x y h; elim h; intros z h0; elim h0; intros H' H'0; clear h h0.

exists z; auto.

Qed.



