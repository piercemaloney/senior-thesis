
Require Export NatIso.
(* NatIso:
Require Export CatProperty.
Require Export CatFunct.

Set Implicit Arguments.
Unset Strict Implicit.

Section natiso_def.

Variable A B : Category.

Definition RNatIso_law (F G : Functor A B) (T : NT F G) 
  (T1 : NT G F) := T1 o_NTv T =_NT Id_CatFunct G.

Variable F G : Functor A B.

Definition AreNatIsos (T : NT F G) (T1 : NT G F) :=
  RNatIso_law T T1 /\ RNatIso_law T1 T.

Structure > NatIso : Type := 
  {NatIso_mor :> NT F G;
   NatIso_inv : NT G F;
   Prf_NatIso :> AreNatIsos NatIso_mor NatIso_inv}.

Lemma Idl_nat_inv :
 forall i : NatIso, RNatIso_law (NatIso_mor i) (NatIso_inv i).

Lemma Idr_nat_inv :
 forall i : NatIso, RNatIso_law (NatIso_inv i) (NatIso_mor i).

End natiso_def.

Section about_isIso.

Variables (A B : Category) (F G : Functor A B) (T : NT F G).

Variable h : forall a : A, G a --> F a.

Hypothesis H : forall a : A, AreIsos (T a) (h a).
   
Lemma NTinv_nt_law : NT_law h.

Canonical Structure NTinv := Build_NT NTinv_nt_law.

Lemma NT_areIso : AreNatIsos T NTinv.

Canonical Structure NT_Iso : NatIso F G := NT_areIso.

Variable T1 : NT G F.

Hypothesis H' : AreNatIsos T T1.

Variable a : A.

Lemma NTa_areIso : AreIsos (T a) (T1 a).

Canonical Structure NTa_Iso : Iso (F a) (G a) := NTa_areIso.

End about_isIso. *)
Require Export HomFunctor2.
(* HomFunctor2:
Require Export SET.
Require Export Dual.
Require Export PROD.
Require Export Functor.

Set Implicit Arguments.
Unset Strict Implicit.

Section FunSet2_r.

Variable C D : Category.

 Section abrev.
 
 Definition OB_l (dxc : POb (Dual D) C) : D := Ob_l dxc.

 Variables (d1xc1 d2xc2 : POb (Dual D) C) (foxg : Pmor d1xc1 d2xc2).

 Definition HOM_l : OB_l d2xc2 --> OB_l d1xc1 := Hom_l foxg.

 Definition Build_POb1 (d : D) (c : C) := Build_POb (A:=Dual D) (B:=C) d c.

 Definition Build_Pmor1 (c c' : C) (d d' : D) (f : d' --> d)
   (g : c --> c') := Build_Pmor (u:=Build_POb1 d c) (t:=Build_POb1 d' c') f g.

 End abrev.

Variable F : Functor D C.

Definition FunSET2_r_ob (dxc : POb (Dual D) C) := F (OB_l dxc) --> Ob_r dxc.

 Section funset2_r_map_def.

 Variable d1xc1 d2xc2 : POb (Dual D) C.

  Section funset2_r_mor_def.

  Variable foxg : Pmor d1xc1 d2xc2.

  Definition FunSET2_r_mor1 (h : FunSET2_r_ob d1xc1) :=
    (FMor F (HOM_l foxg) o h) o Hom_r foxg.

  Lemma FunSET2_r_map_law1 : Map_law FunSET2_r_mor1.

  Canonical Structure FunSET2_r_mor :
    Map (FunSET2_r_ob d1xc1) (FunSET2_r_ob d2xc2) := FunSET2_r_map_law1.

  End funset2_r_mor_def.
  
 Lemma FunSET2_r_map_law : Map_law FunSET2_r_mor.

 Canonical Structure FunSET2_r_map := Build_Map FunSET2_r_map_law.

 End funset2_r_map_def.

Lemma Fun2_r_comp_law : Fcomp_law FunSET2_r_map.

Lemma Fun2_r_id_law : Fid_law FunSET2_r_map.

Canonical Structure FunSET2_r := Build_Functor Fun2_r_comp_law Fun2_r_id_law.

End FunSet2_r.

Section FunSet2_l.

Variables (C D : Category) (G : Functor C D).

Definition FunSET2_l_ob (dxc : POb (Dual D) C) := OB_l dxc --> G (Ob_r dxc).

 Section funset2_l_map_def.

 Variable d1xc1 d2xc2 : POb (Dual D) C.

  Section funset2_l_mor_def.

  Variable foxg : Pmor d1xc1 d2xc2.

  Definition FunSET2_l_mor1 (h : FunSET2_l_ob d1xc1) :=
    (HOM_l foxg o h) o FMor G (Hom_r foxg).

  Lemma FunSET2_l_map_law1 : Map_law FunSET2_l_mor1.

  Canonical Structure FunSET2_l_mor :
    Map (FunSET2_l_ob d1xc1) (FunSET2_l_ob d2xc2) := FunSET2_l_map_law1.

  End funset2_l_mor_def.

 Lemma FunSET2_l_map_law : Map_law FunSET2_l_mor.

 Canonical Structure FunSET2_l_map := Build_Map FunSET2_l_map_law.

 End funset2_l_map_def.
 
Lemma Fun2_l_comp_law : Fcomp_law FunSET2_l_map.

Lemma Fun2_l_id_law : Fid_law FunSET2_l_map.

Canonical Structure FunSET2_l := Build_Functor Fun2_l_comp_law Fun2_l_id_law.

End FunSet2_l. *)

Set Implicit Arguments.
Unset Strict Implicit.

Section adj_def.

Variables (C D : Category) (F : Functor D C) (G : Functor C D).

SubClass Adj := NatIso (FunSET2_r F) (FunSET2_l G).

Variables (phi : NT (FunSET2_r F) (FunSET2_l G))
  (phi_1 : NT (FunSET2_l G) (FunSET2_r F)).
Variable phi_iso : AreNatIsos phi phi_1.

Definition Build_Adj : Adj := Build_NatIso phi_iso.

Variables (d : D) (c : C) (ad : Adj).
 
Definition ApAphi (f : F d --> c) : d --> G c := ad (Build_POb1 d c) f.

Definition ApAphi_inv (g : d --> G c) : F d --> c :=
  NatIso_inv ad (Build_POb1 d c) g.

Lemma AphiPres : forall f g : F d --> c, f =_S g -> ApAphi f =_S ApAphi g.
Proof.
intros; unfold ApAphi in |- *; apply (Pres (ad (Build_POb1 d c))); assumption.
Qed.

Lemma Aphi_invPres :
 forall f g : d --> G c, f =_S g -> ApAphi_inv f =_S ApAphi_inv g.
Proof.
intros; unfold ApAphi_inv in |- *;
 apply (Pres (NatIso_inv ad (Build_POb1 d c))); assumption.
Qed.

End adj_def.

Structure LeftAdj (C D : Category) (G : Functor C D) : Type := 
  {Adjoint : Functor D C; Adj_l :> Adj Adjoint G}.

Structure RightAdj (C D : Category) (F : Functor D C) : Type := 
  {CoAdjoint : Functor C D; Adj_r :> Adj F CoAdjoint}.

Section adj_eqs.

Variables (C D : Category) (F : Functor D C) (G : Functor C D) (ad : Adj F G).
Variables (d d' : D) (c c' : C) (h : d' --> d) (k : c --> c') (f : F d --> c).

Lemma Adj_eq1 :
 ApAphi ad ((FMor F h o f) o k) =_S (h o ApAphi ad f) o FMor G k.
Proof.
apply (Prf_NT_law ad (Build_Pmor1 h k) f).
Qed.

Variable g : d --> G c.

Lemma Adj_eq2 :
 ApAphi_inv ad ((h o g) o FMor G k) =_S (FMor F h o ApAphi_inv ad g) o k.
Proof.
apply (Prf_NT_law (NatIso_inv ad) (Build_Pmor1 h k) g).      
Qed.
       
End adj_eqs.

Section adj_eqs1.

Variables (C D : Category) (F : Functor D C) (G : Functor C D) (ad : Adj F G).
Variables (d d' : D) (c c' : C) (h : d' --> d) (k : c --> c') 
  (f : F d --> c) (g : d --> G c).

Lemma Adj_eq3 : ApAphi ad (f o k) =_S ApAphi ad f o FMor G k.
Proof.
apply Trans with (ApAphi ad ((FMor F (Id d) o f) o k)).
apply AphiPres.
apply Comp_r.
 apply Trans with (Id (F d) o f).
apply Idl1.
apply Comp_r.
apply FId1.
 apply Trans with ((Id d o ApAphi ad f) o FMor G k).
apply (Adj_eq1 ad (Id d) k f).
apply Comp_r.
apply Idl.
Qed.

Lemma Adj_eq4 : ApAphi ad (FMor F h o f) =_S h o ApAphi ad f.
Proof.
 apply Trans with (ApAphi ad ((FMor F h o f) o Id c)).
apply AphiPres.
apply Idr.
 apply Trans with ((h o ApAphi ad f) o FMor G (Id c)).
apply (Adj_eq1 ad h (Id c) f).
 apply Trans with ((h o ApAphi ad f) o Id (G c)).
apply Comp_l.
apply FId.
apply Idr1.
Qed.

Lemma Adj_eq5 : ApAphi_inv ad (g o FMor G k) =_S ApAphi_inv ad g o k.
Proof.
 apply Trans with (ApAphi_inv ad ((Id d o g) o FMor G k)).
apply Aphi_invPres.
apply Comp_r.
apply Idl1.
 apply Trans with ((FMor F (Id d) o ApAphi_inv ad g) o k).
apply (Adj_eq2 ad (Id d) k g).
apply Comp_r.
 apply Trans with (Id (F d) o ApAphi_inv ad g).
apply Comp_r.
apply FId.
apply Idl.
Qed.
        
Lemma Adj_eq6 : ApAphi_inv ad (h o g) =_S FMor F h o ApAphi_inv ad g.
Proof.
 apply Trans with (ApAphi_inv ad ((h o g) o FMor G (Id c))).
apply Aphi_invPres.
 apply Trans with ((h o g) o Id (G c)).
apply Idr.
apply Comp_l.
apply FId1.
 apply Trans with ((FMor F h o ApAphi_inv ad g) o Id c).
apply (Adj_eq2 ad h (Id c) g).
apply Idr1.
Qed.

End adj_eqs1.

