
Require Export Binary_Products.
(* Binary_Products:
Require Export Category.
Require Export Map2.

Set Implicit Arguments.
Unset Strict Implicit.

Section bp_def.

Variables (C : Category) (a b : C).

 Section bp_laws.

 Variables (Obj_prod : C) (Proj1_prod : Obj_prod --> a)
   (Proj2_prod : Obj_prod --> b).
 Variable Op : forall c : C, Map2 (c --> a) (c --> b) (c --> Obj_prod).

 Definition Together_prod (c : C) (f : c --> a) (g : c --> b) := Op c f g.

 Definition Eq1_prod_law :=
   forall (c : C) (f : c --> a) (g : c --> b),
   Together_prod f g o Proj1_prod =_S f.

 Definition Eq2_prod_law :=
   forall (c : C) (f : c --> a) (g : c --> b),
   Together_prod f g o Proj2_prod =_S g.

 Definition Unique_together_law :=
   forall (c : C) (h : c --> Obj_prod),
   Together_prod (h o Proj1_prod) (h o Proj2_prod) =_S h.

 End bp_laws.

Structure BinProd : Type := 
  {Obj_prod : C;
   Proj1_prod : Obj_prod --> a;
   Proj2_prod : Obj_prod --> b;
   Op_together : forall c : C, Map2 (c --> a) (c --> b) (c --> Obj_prod);
   Prf_eq1_prod : Eq1_prod_law Proj1_prod Op_together;
   Prf_eq2_prod : Eq2_prod_law Proj2_prod Op_together;
   Prf_unique_together :
    Unique_together_law Proj1_prod Proj2_prod Op_together}.
 
Definition Together (C1 : BinProd) (c : C) (f : c --> a) 
  (g : c --> b) := Together_prod (Op_together C1) f g.

End bp_def.

Definition HasBinProd (C : Category) := forall a b : C, BinProd a b.

Section hasbinprod_proj.

Variables (C : Category) (C1 : HasBinProd C) (a b : C).

Definition H_obj_prod := Obj_prod (C1 a b).

Definition H_proj1_prod := Proj1_prod (C1 a b).

Definition H_proj2_prod := Proj2_prod (C1 a b).

Definition H_together (c : C) (f : c --> a) (g : c --> b) :=
  Together (C1 a b) f g.

End hasbinprod_proj.

Lemma Eq3_prod :
 forall (C : Category) (a b : C) (C1 : BinProd a b) 
   (c : C) (f : c --> a) (g : c --> b) (c' : C) (k : c' --> c),
 k o Together C1 f g =_S Together C1 (k o f) (k o g).

Section mor_prod_def.

Variables (C : Category) (C1 : HasBinProd C).

 Section mor_prod_map2.
 
 Variable a b c d : C.

 Definition Mor_prod (f : a --> c) (g : b --> d) :=
   H_together C1 (H_proj1_prod C1 a b o f) (H_proj2_prod C1 a b o g).

 Lemma Mor_prod_r : Map2_congr_law Mor_prod.

 Lemma Mor_prod_l : Map2_congl_law Mor_prod.

 Definition Mor_prod_map2 := Build_Map2 Mor_prod_l Mor_prod_r.

 End mor_prod_map2.

Variables (a b c a' b' c' : C) (f : a --> b) (f' : a' --> b') 
  (g : b --> c) (g' : b' --> c').

Lemma Eq_Mor_prod :
 Mor_prod f f' o Mor_prod g g' =_S Mor_prod (f o g) (f' o g').

End mor_prod_def. *)
Require Export Functor.
(* Functor:
Require Export Setoid_dup1.
Require Export Hom_Equality.

Set Implicit Arguments.
Unset Strict Implicit.

Section funct_def.

Variable C D : Category.

 Section funct_laws.

 Variables (FOb : C -> D)
   (FMap : forall a b : C, Map (a --> b) (FOb a --> FOb b)).

 Definition Fcomp_law :=
   forall (a b c : C) (f : a --> b) (g : b --> c),
   FMap a c (f o g) =_S FMap a b f o FMap b c g.

 Definition Fid_law := forall a : C, FMap a a (Id a) =_S Id (FOb a).

 End funct_laws.

Structure Functor : Type := 
  {FOb :> C -> D;
   FMap : forall a b : C, Map (a --> b) (FOb a --> FOb b);
   Prf_Fcomp_law : Fcomp_law FMap;
   Prf_Fid_law : Fid_law FMap}.

Definition FMor (F : Functor) (a b : C) (f : a --> b) := FMap F a b f.

Lemma FPres :
 forall (F : Functor) (a b : C) (f g : a --> b),
 f =_S g -> FMor F f =_S FMor F g.

Lemma FComp :
 forall (F : Functor) (a b c : C) (f : a --> b) (g : b --> c),
 FMor F (f o g) =_S FMor F f o FMor F g.

Lemma FComp1 :
 forall (F : Functor) (a b c : C) (f : a --> b) (g : b --> c),
 FMor F f o FMor F g =_S FMor F (f o g).

Lemma FId : forall (F : Functor) (a : C), FMor F (Id a) =_S Id (FOb F a).

Lemma FId1 : forall (F : Functor) (a : C), Id (FOb F a) =_S FMor F (Id a).

End funct_def.

Section funct_setoid.

Variable C D : Category. 

Definition Equal_Functor (F G : Functor C D) :=
  forall (a b : C) (f : a --> b), FMor F f =_H FMor G f.

Lemma Equal_Functor_equiv : Equivalence Equal_Functor.

Canonical Structure Functor_setoid := Build_Setoid' Equal_Functor_equiv.

End funct_setoid.

Infix "=_F" := Equal_Functor (at level 70).

Section Comp_F.

Variables (C D E : Category) (G : Functor C D) (H : Functor D E).

Definition Comp_FOb (a : C) := H (G a).

 Section comp_functor_map.

 Variable a b : C.

 Definition Comp_FMor (f : a --> b) := FMor H (FMor G f). 

 Lemma Comp_FMap_law : Map_law Comp_FMor.

 Definition Comp_FMap :=
   Build_Map (B:=Comp_FOb a --> Comp_FOb b) Comp_FMap_law.

 End comp_functor_map.

Lemma Comp_Functor_comp_law : Fcomp_law Comp_FMap.

Lemma Comp_Functor_id_law : Fid_law Comp_FMap.

Canonical Structure Comp_Functor :=
  Build_Functor Comp_Functor_comp_law Comp_Functor_id_law.

End Comp_F.

Infix "o_F" := Comp_Functor (at level 20, right associativity). *)

Set Implicit Arguments.
Unset Strict Implicit.

Section fun_prod.

Variables (C : Category) (C1 : HasBinProd C) (a : C).

Definition Fun_prod_ob (c : C) := H_obj_prod C1 c a.

 Section fun_prod_map_def.

 Variable c1 c2 : C.

 Definition Fun_prod_mor (f : c1 --> c2) := Mor_prod C1 f (Id a).

 Lemma Fun_prod_map_law : Map_law Fun_prod_mor.
 Proof.
 unfold Map_law in |- *; intros f g H.
 unfold Fun_prod_mor, Mor_prod in |- *.
 apply
  (Map2_r (Op_together (C1 c2 a) _) (a1:=H_proj1_prod C1 c1 a o f)
     (a2:=H_proj1_prod C1 c1 a o g) (H_proj2_prod C1 c1 a o Id a)).
 apply Comp_l; trivial.
 Qed.

 Canonical Structure Fun_prod_map :
   Map (c1 --> c2) (Fun_prod_ob c1 --> Fun_prod_ob c2) := Fun_prod_map_law.

 End fun_prod_map_def.

Lemma Fun_prod_comp_law : Fcomp_law Fun_prod_map.
Proof.
unfold Fcomp_law in |- *; simpl in |- *.
intros c1 c2 c3 f g.
unfold Fun_prod_mor, Mor_prod in |- *.
 apply
       Trans
        with
          (H_together C1
             (H_together C1 (H_proj1_prod C1 c1 a o f)
                (H_proj2_prod C1 c1 a o Id a) o H_proj1_prod C1 c2 a o g)
             (H_proj2_prod C1 c1 a o Id a)).
 apply
  (Map2_r (Op_together (C1 c3 a) _) (a1:=H_proj1_prod C1 c1 a o f o g)
     (a2:=H_together C1 (H_proj1_prod C1 c1 a o f)
            (H_proj2_prod C1 c1 a o Id a) o H_proj1_prod C1 c2 a o g)
     (H_proj2_prod C1 c1 a o Id a)).
 apply Trans with ((H_proj1_prod C1 c1 a o f) o g).
apply Ass.
 apply
       Trans
        with
          ((H_together C1 (H_proj1_prod C1 c1 a o f)
              (H_proj2_prod C1 c1 a o Id a) o H_proj1_prod C1 c2 a) o g).
apply Comp_r; apply Sym.
apply
 (Prf_eq1_prod (C1 c2 a) (H_proj1_prod C1 c1 a o f)
    (H_proj2_prod C1 c1 a o Id a)).
apply Ass1.
 apply
       Trans
        with
          (H_together C1
             (H_together C1 (H_proj1_prod C1 c1 a o f)
                (H_proj2_prod C1 c1 a o Id a) o H_proj1_prod C1 c2 a o g)
             (H_together C1 (H_proj1_prod C1 c1 a o f)
                (H_proj2_prod C1 c1 a o Id a) o H_proj2_prod C1 c2 a o Id a)).
apply
 (Prf_map2_congl (Op_together (C1 c3 a) _) (b1:=H_proj2_prod C1 c1 a o Id a)
    (b2:=H_together C1 (H_proj1_prod C1 c1 a o f)
           (H_proj2_prod C1 c1 a o Id a) o H_proj2_prod C1 c2 a o Id a)
    (H_together C1 (H_proj1_prod C1 c1 a o f) (H_proj2_prod C1 c1 a o Id a)
     o H_proj1_prod C1 c2 a o g)).
 apply
       Trans
        with
          ((H_together C1 (H_proj1_prod C1 c1 a o f)
              (H_proj2_prod C1 c1 a o Id a) o H_proj2_prod C1 c2 a) o 
           Id a).
apply Comp_r.
 apply
       Trans
        with
          (H_together C1 (H_proj1_prod C1 c1 a o f) (H_proj2_prod C1 c1 a)
           o H_proj2_prod C1 c2 a).
apply Sym.
apply
 (Prf_eq2_prod (C1 c2 a) (H_proj1_prod C1 c1 a o f) (H_proj2_prod C1 c1 a)).
apply Comp_r.
apply
 (Prf_map2_congl (Op_together (C1 c2 a) _) (b1:=H_proj2_prod C1 c1 a)
    (b2:=H_proj2_prod C1 c1 a o Id a) (H_proj1_prod C1 c1 a o f)).               
apply Idr.
apply Ass1.
apply Sym.
apply
 (Eq3_prod (C1 c3 a) (H_proj1_prod C1 c2 a o g) (H_proj2_prod C1 c2 a o Id a)
    (H_together C1 (H_proj1_prod C1 c1 a o f) (H_proj2_prod C1 c1 a o Id a))).
Qed.

Lemma Fun_prod_id_law : Fid_law Fun_prod_map.
Proof.
unfold Fid_law in |- *; simpl in |- *.
unfold Fun_prod_mor, Mor_prod in |- *.
intro c; unfold Fun_prod_ob in |- *.
 apply
       Trans
        with
          (H_together C1 (Id (H_obj_prod C1 c a) o H_proj1_prod C1 c a)
             (H_proj2_prod C1 c a o Id a)).
apply
 (Prf_map2_congr (Op_together (C1 c a) _) (a1:=H_proj1_prod C1 c a o Id c)
    (a2:=Id (H_obj_prod C1 c a) o H_proj1_prod C1 c a)
    (H_proj2_prod C1 c a o Id a)).
 apply Trans with (H_proj1_prod C1 c a).
apply Idr1.
apply Idl1.
 apply
       Trans
        with
          (H_together C1 (Id (H_obj_prod C1 c a) o H_proj1_prod C1 c a)
             (Id (H_obj_prod C1 c a) o H_proj2_prod C1 c a)).
apply
 (Prf_map2_congl (Op_together (C1 c a) _) (b1:=H_proj2_prod C1 c a o Id a)
    (b2:=Id (H_obj_prod C1 c a) o H_proj2_prod C1 c a)
    (Id (H_obj_prod C1 c a) o H_proj1_prod C1 c a)).
 apply Trans with (H_proj2_prod C1 c a).
apply Idr1.
apply Idl1.
apply (Prf_unique_together (Id (H_obj_prod C1 c a))).
Qed.

Canonical Structure Fun_prod :=
  Build_Functor Fun_prod_comp_law Fun_prod_id_law.

End fun_prod.

