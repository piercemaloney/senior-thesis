
Require Export Setoid_dup1.
(* Setoid_dup1:
Require Export Relations.

Set Implicit Arguments.
Unset Strict Implicit.

Structure > Setoid' : Type := 
  {Carrier' :> Type;
   Equal' : Relation Carrier';
   Prf_equiv' :> Equivalence Equal'}.

Infix "=_S'" := Equal' (at level 70).

Lemma Refl' : forall (S : Setoid') (x : S), x =_S' x.

Lemma Sym' : forall (S : Setoid') (x y : S), x =_S' y -> y =_S' x.

Lemma Trans' :
 forall (S : Setoid') (x y z : S), x =_S' y -> y =_S' z -> x =_S' z.

Section maps'.

Variable A B : Setoid'.

Definition Map_law' (f : A -> B) := forall x y : A, x =_S' y -> f x =_S' f y.

Structure > Map' : Type :=  {Ap' :> A -> B; Pres' :> Map_law' Ap'}.

Lemma Pres1' : forall (m : Map') (x y : A), x =_S' y -> m x =_S' m y.

Definition Ext' (f g : Map') := forall x : A, f x =_S' g x.

Lemma Ext_equiv' : Equivalence Ext'.

Canonical Structure Map_setoid' : Setoid' := Ext_equiv'.

End maps'.

Section fun2_to_map2'.

Variable A B C : Setoid'.

Definition Map2' := Map' A (Map_setoid' B C).

Variable f : A -> B -> C.

Definition Map2_congl_law' :=
  forall (b1 b2 : B) (a : A), b1 =_S' b2 -> f a b1 =_S' f a b2.

Definition Map2_congr_law' :=
  forall (a1 a2 : A) (b : B), a1 =_S' a2 -> f a1 b =_S' f a2 b.

Definition Map2_cong_law' :=
  forall (a1 a2 : A) (b1 b2 : B),
  a1 =_S' a2 -> b1 =_S' b2 -> f a1 b1 =_S' f a2 b2.

Hypothesis pgcl : Map2_congl_law'.
Hypothesis pgcr : Map2_congr_law'.

Lemma Map2_map_law1' : forall a : A, Map_law' (f a).

Canonical Structure Map2_map1' (a : A) := Build_Map' (Map2_map_law1' a).

Lemma Map2_map_law2' : Map_law' Map2_map1'.

Definition Build_Map2' : Map2' := Build_Map' Map2_map_law2'.

End fun2_to_map2'.

Section prop_map2'.

Variables (A B C : Setoid') (f : Map2' A B C).

Definition Ap2' (a : A) (b : B) := f a b.

Lemma Prf_map2_congl' : Map2_congl_law' Ap2'.

Lemma Prf_map2_congr' : Map2_congr_law' Ap2'.

Lemma Prf_map2_cong' : Map2_cong_law' Ap2'.

End prop_map2'.

Coercion Ap2' : Map2' >-> Funclass.

Identity Coercion Map2'_Map' : Map2' >-> Map'. *)

Set Implicit Arguments.
Unset Strict Implicit.

Section composition_to_operator'.

Variables (A : Type) (H : A -> A -> Setoid')
  (Cfun : forall a b c : A, H a b -> H b c -> H a c).

Definition Congl_law' :=
  forall (a b c : A) (f g : H b c) (h : H a b),
  f =_S' g -> Cfun h f =_S' Cfun h g. 

Definition Congr_law' :=
  forall (a b c : A) (f g : H a b) (h : H b c),
  f =_S' g -> Cfun f h =_S' Cfun g h. 

Definition Cong_law' :=
  forall (a b c : A) (f f' : H a b) (g g' : H b c),
  f =_S' f' -> g =_S' g' -> Cfun f g =_S' Cfun f' g'. 

Hypothesis pcgl : Congl_law'.
Hypothesis pcgr : Congr_law'.

Variable a b c : A.

Definition Build_Comp' :=
  Build_Map2' (pcgl (a:=a) (b:=b) (c:=c)) (pcgr (a:=a) (b:=b) (c:=c)).

End composition_to_operator'.

Section cat'.

Variables (Ob' : Type) (Hom' : Ob' -> Ob' -> Setoid').

Variable
  Op_comp' : forall a b c : Ob', Map2' (Hom' a b) (Hom' b c) (Hom' a c).

Definition Cat_comp' (a b c : Ob') (f : Hom' a b) (g : Hom' b c) :=
  Op_comp' a b c f g.

Definition Assoc_law' :=
  forall (a b c d : Ob') (f : Hom' a b) (g : Hom' b c) (h : Hom' c d),
  Cat_comp' f (Cat_comp' g h) =_S' Cat_comp' (Cat_comp' f g) h.

Variable Id' : forall a : Ob', Hom' a a.

Definition Idl_law' :=
  forall (a b : Ob') (f : Hom' a b), Cat_comp' (Id' _) f =_S' f.

Definition Idr_law' :=
  forall (a b : Ob') (f : Hom' b a), f =_S' Cat_comp' f (Id' _).

End cat'.

Structure Category' : Type := 
  {Ob' :> Type;
   Hom' : Ob' -> Ob' -> Setoid';
   Op_comp' : forall a b c : Ob', Map2' (Hom' a b) (Hom' b c) (Hom' a c);
   Id' : forall a : Ob', Hom' a a;
   Prf_ass' : Assoc_law' Op_comp';
   Prf_idl' : Idl_law' Op_comp' Id';
   Prf_idr' : Idr_law' Op_comp' Id'}.

Definition Comp' (C : Category') := Cat_comp' (Op_comp' (c:=C)).

Infix "o'" := Comp' (at level 20, right associativity).