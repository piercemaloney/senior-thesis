
Require Export Binary_Products.
(* Binary_Products:
Require Export Category.
Require Export Map2.

Set Implicit Arguments.
Unset Strict Implicit.

Section bp_def.

Variables (C : Category) (a b : C).

 Section bp_laws.

 Variables (Obj_prod : C) (Proj1_prod : Obj_prod --> a)
   (Proj2_prod : Obj_prod --> b).
 Variable Op : forall c : C, Map2 (c --> a) (c --> b) (c --> Obj_prod).

 Definition Together_prod (c : C) (f : c --> a) (g : c --> b) := Op c f g.

 Definition Eq1_prod_law :=
   forall (c : C) (f : c --> a) (g : c --> b),
   Together_prod f g o Proj1_prod =_S f.

 Definition Eq2_prod_law :=
   forall (c : C) (f : c --> a) (g : c --> b),
   Together_prod f g o Proj2_prod =_S g.

 Definition Unique_together_law :=
   forall (c : C) (h : c --> Obj_prod),
   Together_prod (h o Proj1_prod) (h o Proj2_prod) =_S h.

 End bp_laws.

Structure BinProd : Type := 
  {Obj_prod : C;
   Proj1_prod : Obj_prod --> a;
   Proj2_prod : Obj_prod --> b;
   Op_together : forall c : C, Map2 (c --> a) (c --> b) (c --> Obj_prod);
   Prf_eq1_prod : Eq1_prod_law Proj1_prod Op_together;
   Prf_eq2_prod : Eq2_prod_law Proj2_prod Op_together;
   Prf_unique_together :
    Unique_together_law Proj1_prod Proj2_prod Op_together}.
 
Definition Together (C1 : BinProd) (c : C) (f : c --> a) 
  (g : c --> b) := Together_prod (Op_together C1) f g.

End bp_def.

Definition HasBinProd (C : Category) := forall a b : C, BinProd a b.

Section hasbinprod_proj.

Variables (C : Category) (C1 : HasBinProd C) (a b : C).

Definition H_obj_prod := Obj_prod (C1 a b).

Definition H_proj1_prod := Proj1_prod (C1 a b).

Definition H_proj2_prod := Proj2_prod (C1 a b).

Definition H_together (c : C) (f : c --> a) (g : c --> b) :=
  Together (C1 a b) f g.

End hasbinprod_proj.

Lemma Eq3_prod :
 forall (C : Category) (a b : C) (C1 : BinProd a b) 
   (c : C) (f : c --> a) (g : c --> b) (c' : C) (k : c' --> c),
 k o Together C1 f g =_S Together C1 (k o f) (k o g).

Section mor_prod_def.

Variables (C : Category) (C1 : HasBinProd C).

 Section mor_prod_map2.
 
 Variable a b c d : C.

 Definition Mor_prod (f : a --> c) (g : b --> d) :=
   H_together C1 (H_proj1_prod C1 a b o f) (H_proj2_prod C1 a b o g).

 Lemma Mor_prod_r : Map2_congr_law Mor_prod.

 Lemma Mor_prod_l : Map2_congl_law Mor_prod.

 Definition Mor_prod_map2 := Build_Map2 Mor_prod_l Mor_prod_r.

 End mor_prod_map2.

Variables (a b c a' b' c' : C) (f : a --> b) (f' : a' --> b') 
  (g : b --> c) (g' : b' --> c').

Lemma Eq_Mor_prod :
 Mor_prod f f' o Mor_prod g g' =_S Mor_prod (f o g) (f' o g').

End mor_prod_def. *)

Set Implicit Arguments.
Unset Strict Implicit.

Section expo_def.

Variables (C : Category) (C1 : HasBinProd C) (a b : C).

 Section expo_laws.

 Variables (Expo : C) (Eval : H_obj_prod C1 Expo a --> b)
   (Op : forall c : C, Map (H_obj_prod C1 c a --> b) (c --> Expo)).

 Definition Lambda_expo (c : C) (f : H_obj_prod C1 c a --> b) := Op c f.

 Definition Beta_rule_law :=
   forall (c : C) (f : H_obj_prod C1 c a --> b),
   Mor_prod C1 (Lambda_expo f) (Id a) o Eval =_S f.

 Definition Eta_rule_law :=
   forall (c : C) (h : c --> Expo),
   Lambda_expo (Mor_prod C1 h (Id a) o Eval) =_S h.

 End expo_laws.

Structure Exponent : Type := 
  {Expo : C;
   Eval : H_obj_prod C1 Expo a --> b;
   Op_lambda : forall c : C, Map (H_obj_prod C1 c a --> b) (c --> Expo);
   Prf_beta_rule : Beta_rule_law Eval Op_lambda;
   Prf_eta_rule : Eta_rule_law Eval Op_lambda}.

Variable e : Exponent.

Definition Lambda (c : C) (f : H_obj_prod C1 c a --> b) := Op_lambda e c f.

End expo_def.

Definition HasExponent (C : Category) (C1 : HasBinProd C) :=
  forall a b : C, Exponent C1 a b.

Section hasexponent_proj.

Variables (C : Category) (C1 : HasBinProd C) (C2 : HasExponent C1) (a b : C).

Definition H_expo := Expo (C2 a b).

Definition H_eval := (Eval (C2 a b)).

Definition H_lambda (c : C) (f : H_obj_prod C1 c a --> b) :=
  Lambda (C2 a b) f.

End hasexponent_proj.

