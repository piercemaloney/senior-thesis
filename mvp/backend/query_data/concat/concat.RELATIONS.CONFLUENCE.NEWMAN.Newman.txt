

Require Import Relations.
(* Relations:
Set Implicit Arguments.
Unset Strict Implicit.

Section Orderings.

Variable U : Type.
   
Definition Relation := U -> U -> Prop.

Variable R : Relation.
   
Definition Reflexive := forall x : U, R x x.
   
Definition Transitive := forall x y z : U, R x y -> R y z -> R x z.
   
Definition Symmetric := forall x y : U, R x y -> R y x.
   
Definition Antisymmetric := forall x y : U, R x y -> R y x -> x = y.
   
Definition Contains (R R' : Relation) := forall x y : U, R' x y -> R x y.
   
Definition Same_relation (R R' : Relation) := Contains R R' /\ Contains R' R.

Structure Preorder : Prop := 
  {Prf_refl1 : Reflexive; Prf_trans1 : Transitive}.
   
Structure Order : Prop := 
  {Prf_preorder :> Preorder; Prf_asym : Antisymmetric}.
   
Structure Partial_equivalence : Prop := 
  {Prf_trans : Transitive; Prf_sym : Symmetric}.
   
Structure Equivalence : Prop := 
  {Prf_refl : Reflexive; Prf_pequiv :> Partial_equivalence}.
   
Canonical Structure Equiv_preorder (e : Equivalence) :=
  Build_Preorder (Prf_refl e) (Prf_trans e).
   
Coercion Equiv_preorder : Equivalence >-> Preorder.

End Orderings.

Hint Unfold Reflexive.
Hint Unfold Transitive.
Hint Unfold Antisymmetric.
Hint Unfold Symmetric.
Hint Unfold Contains.
Hint Unfold Same_relation.
Hint Resolve Build_Preorder.
Hint Resolve Build_Order.
Hint Resolve Build_Equivalence.
Hint Resolve Build_Partial_equivalence. *)

Require Import Confluence.
(* Confluence:
Require Import Relations.

Set Implicit Arguments.
Unset Strict Implicit.

Section Confluence.
   Variable U : Type.
   Variable R : Relation U.
   
   Inductive Rstar : Relation U :=
     | Rstar_0 : forall x : U, Rstar x x
     | Rstar_n : forall x y z : U, R x y -> Rstar y z -> Rstar x z.
   
   Inductive Rstar1 : Relation U :=
     | Rstar1_0 : forall x : U, Rstar1 x x
     | Rstar1_1 : forall x y : U, R x y -> Rstar1 x y
     | Rstar1_n : forall x y z : U, Rstar1 x y -> Rstar1 y z -> Rstar1 x z.
   
   Inductive Rplus : Relation U :=
     | Rplus_0 : forall x y : U, R x y -> Rplus x y
     | Rplus_n : forall x y z : U, R x y -> Rplus y z -> Rplus x z.
   
   Definition Strongly_confluent : Prop :=
     forall x a b : U, R x a -> R x b -> exists z : U, R a z /\ R b z.

   Definition coherent (x y : U) : Prop :=
     exists z : U, Rstar x z /\ Rstar y z.
   
   Definition locally_confluent (x : U) : Prop :=
     forall y z : U, R x y -> R x z -> coherent y z.
   
   Definition Locally_confluent : Prop := forall x : U, locally_confluent x.
   
   Definition confluent (x : U) : Prop :=
     forall y z : U, Rstar x y -> Rstar x z -> coherent y z.
   
   Definition Confluent : Prop := forall x : U, confluent x.
   
End Confluence.
   
Hint Resolve Rstar_0.
Hint Resolve Rstar1_0.
Hint Resolve Rstar1_1.
Hint Resolve Rplus_0. *)

Require Import Coherence.
(* Coherence:
Hint Resolve refl_equal. 
Require Import Relations.
Require Import Confluence.

Set Implicit Arguments.
Unset Strict Implicit.

Theorem Rstar_reflexive :
 forall (U : Type) (R : Relation U), Reflexive (Rstar R).

Theorem Rplus_contains_R :
 forall (U : Type) (R : Relation U), Contains (Rplus R) R.

Theorem Rstar_contains_R :
 forall (U : Type) (R : Relation U), Contains (Rstar R) R.

Theorem Rstar_contains_Rplus :
 forall (U : Type) (R : Relation U), Contains (Rstar R) (Rplus R).

Theorem Rstar_transitive :
 forall (U : Type) (R : Relation U), Transitive (Rstar R).

Theorem Rstar_cases :
 forall (U : Type) (R : Relation U) (x y : U),
 Rstar R x y -> x = y \/ (exists u : U, R x u /\ Rstar R u y).

Theorem Rstar_equiv_Rstar1 :
 forall (U : Type) (R : Relation U), Same_relation (Rstar R) (Rstar1 R).

Theorem Rsym_imp_Rstarsym :
 forall (U : Type) (R : Relation U), Symmetric R -> Symmetric (Rstar R).

Theorem Sstar_contains_Rstar :
 forall (U : Type) (R S : Relation U),
 Contains (Rstar S) R -> Contains (Rstar S) (Rstar R).

Theorem star_monotone :
 forall (U : Type) (R S : Relation U),
 Contains S R -> Contains (Rstar S) (Rstar R).

Theorem RstarRplus_RRstar :
 forall (U : Type) (R : Relation U) (x y z : U),
 Rstar R x y -> Rplus R y z -> exists u : U, R x u /\ Rstar R u z.

Theorem Rstar_imp_coherent :
 forall (U : Type) (R : Relation U) (x y : U), Rstar R x y -> coherent R x y.
Hint Resolve Rstar_imp_coherent.

Theorem coherent_symmetric :
 forall (U : Type) (R : Relation U), Symmetric (coherent R). *)

Require Import Noetherian.
(* Noetherian:
Require Import Relations.

Set Implicit Arguments.
Unset Strict Implicit.

Section Noether.
   Variable U : Type.
   Variable R : Relation U.
   
   Inductive noetherian : U -> Prop :=
       Build_noetherian :
         forall x : U, (forall y : U, R x y -> noetherian y) -> noetherian x.
   
   Definition Noetherian : Prop := forall x : U, noetherian x.
   
End Noether.

Hint Resolve Build_noetherian.

Theorem Noetherian_contains_Noetherian :
 forall (U : Type) (R R' : Relation U),
 Noetherian R -> Contains R R' -> Noetherian R'. *)



Set Implicit Arguments.

Unset Strict Implicit.



Theorem Newman :

 forall (U : Type) (R : Relation U),

 Noetherian R -> Locally_confluent R -> Confluent R.

Proof.

intros U R H' H'0; red in |- *; intro x; red in |- *.

red in H'; generalize (H' x); intro H'1; elim H'1.

intros x0 H'2 H'3 y z H'4 H'5; clear H' H'1.

generalize (Rstar_cases (U:=U) (R:=R) (x:=x0) (y:=y)); intro h; lapply h;

 [ intro H'6; clear h | clear h; assumption ].

generalize (Rstar_cases (U:=U) (R:=R) (x:=x0) (y:=z)); intro h; lapply h;

 [ intro H'7; clear h | clear h; assumption ].

elim H'6;

 [ clear H'6; intro h

 | intro h; elim h; intros u h0; elim h0; intros H' H'1; clear H'6 h h0 ].

rewrite <- h; auto.

elim H'7;

 [ clear H'7; intro h

 | intro h; elim h; intros v h0; elim h0; intros H'6 H'8; clear H'7 h h0 ].

rewrite <- h; generalize coherent_symmetric; intro H_cs; red in H_cs; auto.

unfold Locally_confluent, locally_confluent, coherent in H'0.

generalize (H'0 x0 u v); intro h; lapply h;

 [ intro H'7; lapply H'7;

    [ intro h0; elim h0; intros t h1; elim h1; intros H'9 H'10;

       clear h H'7 h0 h1

    | clear h ]

 | clear h ]; auto.

clear H'0.

unfold coherent at 1 in H'3.

generalize (H'3 u); intro h; lapply h;

 [ intro H'0; generalize (H'0 y t); intro h0; lapply h0;

    [ intro H'7; lapply H'7;

       [ intro h1; elim h1; intros y1 h2; elim h2; intros H'11 H'12;

          clear h h0 H'7 h1 h2

       | clear h h0 ]

    | clear h h0 ]

 | clear h ]; auto.

generalize Rstar_transitive; intro H_Rst; red in H_Rst.

generalize (H'3 v); intro h; lapply h;

 [ intro H'7; generalize (H'7 y1 z); intro h0; lapply h0;

    [ intro H'13; lapply H'13;

       [ intro h1; elim h1; intros z1 h2; elim h2; intros H'14 H'15;

          clear h h0 H'13 h1 h2

       | clear h h0 ]

    | clear h h0 ]

 | clear h ]; auto.

red in |- *; (exists z1; split); auto.

apply H_Rst with y1; auto.

apply H_Rst with t; auto.

Qed.



