
Require Export Th_Adjoint.
(* Th_Adjoint:
Require Export Adj_UA.

Set Implicit Arguments.
Unset Strict Implicit.

Section ua_to_ladj.

Variables (C D : Category) (G : Functor C D).

Hypothesis UA_of : forall d : D, UA d G.

Definition AdjointUA_ob (d : D) := UA_ob (UA_of d).

 Section adjoint_ua_map_def.

 Variable d d' : D.

 Definition AdjointUA_mor (f : d --> d') :=
   UA_diese (UA_of d) (f o UA_mor (UA_of d')).

 Lemma AdjointUA_map_law : Map_law AdjointUA_mor.

 Canonical Structure AdjointUA_map :
   Map (d --> d') (AdjointUA_ob d --> AdjointUA_ob d') := AdjointUA_map_law.

 End adjoint_ua_map_def.
 
Lemma AdjointUA_id_law : Fid_law AdjointUA_map.

Lemma AdjointUA_comp_law : Fcomp_law AdjointUA_map.

Canonical Structure AdjointUA :=
  Build_Functor AdjointUA_comp_law AdjointUA_id_law.

 Section phi_ua_tau_def.

 Variable dxc : POb (Dual D) C.

 Definition PhiUA_arrow (f : UA_ob (UA_of (OB_l dxc)) --> Ob_r dxc) :=
   UA_mor (UA_of (OB_l dxc)) o FMor G f.

 Lemma PhiUA_arrow_map_law : Map_law PhiUA_arrow.

 Canonical Structure PhiUA_tau := Build_Map PhiUA_arrow_map_law.

 End phi_ua_tau_def.

Lemma PhiUA_tau_nt_law :
 NT_law (F:=FunSET2_r AdjointUA) (G:=FunSET2_l G) PhiUA_tau.

Canonical Structure PhiUA := Build_NT PhiUA_tau_nt_law.

 Section phi_ua_1_tau_def.

 Variable dxc : POb (Dual D) C.

 Definition PhiUA_1_arrow (f : OB_l dxc --> G (Ob_r dxc)) :=
   UA_diese (UA_of (OB_l dxc)) f.

 Lemma PhiUA_1_arrow_map_law : Map_law PhiUA_1_arrow.

 Canonical Structure PhiUA_1_tau := Build_Map PhiUA_1_arrow_map_law.

 End phi_ua_1_tau_def.

Lemma PhiUA_1_tau_nt_law :
 NT_law (F:=FunSET2_l G) (G:=FunSET2_r AdjointUA) PhiUA_1_tau.

Canonical Structure PhiUA_1 := Build_NT PhiUA_1_tau_nt_law.

 Section phi_ua_iso.

 Variable dxc : POb (Dual D) C.

 Lemma PhiUA_1_o_PhiUA : AreIsos (PhiUA dxc) (PhiUA_1 dxc).

 End phi_ua_iso.

Definition AdjUA := Build_Adj (NT_Iso PhiUA_1_o_PhiUA).

Canonical Structure LeftAdjUA := Build_LeftAdj AdjUA.

End ua_to_ladj. *)
Require Export Pres_Limits.
(* Pres_Limits:
Require Export Limit.

Set Implicit Arguments.
Unset Strict Implicit.

Section comp_cone.

Variables (J C D : Category) (c : C) (F : Functor J C) 
  (T : Cone c F) (G : Functor C D).

Definition Comp_cone_tau (i : J) : G c --> (F o_F G) i := FMor G (T i).

Lemma Comp_cone_tau_cone_law : Cone_law Comp_cone_tau.

Definition Comp_cone := Build_Cone Comp_cone_tau_cone_law.

End comp_cone.

Infix "o_C" := Comp_cone (at level 20, right associativity).

Section def_pres_limits.

Variables (J C D : Category) (F : Functor J C) (G : Functor C D).

Definition Preserves_1limit (l : Limit F) := IsLimit (Limiting_cone l o_C G).

Definition Preserves_limits := forall l : Limit F, Preserves_1limit l.

End def_pres_limits.

Definition Continuous (C D : Category) (G : Functor C D) :=
  forall (J : Category) (F : Functor J C), Preserves_limits F G. *)
Require Export Comma_Complete.
(* Comma_Complete:
Require Export Pres_Limits.
Require Export Comma_proj.

Set Implicit Arguments.
Unset Strict Implicit.

Section comma_complete.

Variables (X A : Category) (G : Functor A X) (J : Category).

Hypothesis A_comp_for_J : forall F : Functor J A, Limit F.
Hypothesis G_pres_JA : forall F : Functor J A, Preserves_limits F G.

Variables (x : X) (F : Functor J (Comma G x)).

Let F' := F o_F Comma_proj G x.

Let l_F' := A_comp_for_J F'.

Let l_GF' := G_pres_JA l_F'.

Definition Tc_tau (i : J) := Mor_com_ob (F i).

Lemma Tc_tau_cone_law : Cone_law (F:=F' o_F G) Tc_tau.

Definition Tc_cone := Build_Cone Tc_tau_cone_law.

Canonical Structure Tc_limF := Build_Com_ob (Lim_diese l_GF' Tc_cone).

Lemma Tc_limconeF_tau_com_law :
 forall i : J, Com_law (axf:=Tc_limF) (bxg:=F i) (Limiting_cone l_F' i).

Canonical Structure Tc_limconeF_tau (i : J) :=
  Build_Com_arrow (Tc_limconeF_tau_com_law i).

Lemma Tc_limconeF_cone_law : Cone_law Tc_limconeF_tau.

Definition Tc_limconeF := Build_Cone Tc_limconeF_cone_law.

 Section ctdiese.
  
 Variables (axf : Comma G x) (t : Cone axf F).

 Definition Tc_t_tau (i : J) := Mor_com_arrow (t i).

 Lemma Tc_t_tau_cone_law : Cone_law (c:=Ob_com_ob axf) (F:=F') Tc_t_tau.

 Definition Tc_t_cone := Build_Cone Tc_t_tau_cone_law.

 Lemma Tc_t_cone_com_law :
  Com_law (axf:=axf) (bxg:=Tc_limF) (Lim_diese l_F' Tc_t_cone).

 Canonical Structure Tc_diese := Build_Com_arrow Tc_t_cone_com_law.

 End ctdiese.
  
Lemma Tc_UA_law1 : Limit_law1 Tc_limconeF Tc_diese. 

Lemma Tc_UA_law2 : Limit_law2 Tc_limconeF Tc_diese. 

Definition Comma_l_F := Build_IsLimit Tc_UA_law1 Tc_UA_law2. 

Definition Comma_l_F1 := Build_Limit Comma_l_F.

End comma_complete.

Lemma Comma_complete :
 forall (X A : Category) (G : Functor A X),
 Complete A -> Continuous G -> forall x : X, Complete (Comma G x). *)
Require Export Th_Initial.
(* Th_Initial:
Require Export Products1.
Require Export Equalizers1.
Require Export Single.

Set Implicit Arguments.
Unset Strict Implicit.

Section ssc1.

Variable D : Category.

Structure Cond1 (I : Type) (k : I -> D) (d : D) : Type := 
  {Cond1_i : I; Cond1_f : k Cond1_i --> d}.

Structure SSC1 : Type := 
  {SSC1_I : Type;
   SSC1_k : SSC1_I -> D;
   SSC1_p : forall d : D, Cond1 SSC1_k d}.

Definition SSC1_i (s : SSC1) (d : D) := Cond1_i (SSC1_p s d).

Definition SSC1_f (s : SSC1) (d : D) := Cond1_f (SSC1_p s d).

End ssc1.

Section thi1.

Variables (D : Category) (D_initial : Initial D).

Definition Thi1_d1 := Initial_ob D_initial.

Definition Thi1_I := UnitType.

Definition Thi1_k (i : Thi1_I) := match i with
                                  | Elt => Thi1_d1
                                  end.

Definition Thi1_verif_Cond1 (d : D) :=
  Build_Cond1 (k:=Thi1_k) (Cond1_i:=Elt) (MorI D_initial d).

Canonical Structure Thi1_SSC1 := Build_SSC1 Thi1_verif_Cond1.

End thi1.

Section thi2.

Variables (D : Category) (D_complete : Complete D) (SSC1_D : SSC1 D). 

Definition Thi2_D_prod : Product1 (SSC1_k (s:=SSC1_D)) :=
  D_complete (FunDiscr (SSC1_k (s:=SSC1_D))).

Definition Thi2_w := Pi1 Thi2_D_prod.

Definition Thi2_D_E_hom :=
  Build_Equalizer2 (D_complete (F_hom Thi2_w Thi2_w)) (Id Thi2_w).

Definition Thi2_v := E1_ob Thi2_D_E_hom.

Definition Thi2_e := E1_mor Thi2_D_E_hom.
           
 Section thi2_mor_d_def.

 Variable d : D.

 Definition Thi2_p_i := Proj1 Thi2_D_prod (SSC1_i SSC1_D d).
 
 Definition Thi2_f_d := SSC1_f SSC1_D d.   

 Definition Thi2_mor_d := (Thi2_e o Thi2_p_i) o Thi2_f_d.

 End thi2_mor_d_def. 

 Section unique_mor_d.
 
 Variables (d : D) (f g : Thi2_v --> d).
 
 Definition Thi2_D_E_fg := Build_Equalizer2 (D_complete (F_fg f g)) Elt1.

 Definition Thi2_c := E1_ob Thi2_D_E_fg.
 
 Definition Thi2_e1 := E1_mor Thi2_D_E_fg.
 
 Definition Thi2_p_j := Proj1 Thi2_D_prod (SSC1_i SSC1_D Thi2_c).

 Definition Thi2_f_c := SSC1_f SSC1_D Thi2_c.   

 Definition Thi2_s := Thi2_p_j o Thi2_f_c.

 Lemma Thi2_e1_RightInv : RIso_law Thi2_e1 (Thi2_e o Thi2_s).
 
 Lemma Eq_fg : f =_S g.

End unique_mor_d.
 
Lemma Thi2_isInitial : IsInitial Thi2_mor_d.

Definition Thi2_initial : Initial D := Thi2_isInitial.

End thi2. *)
Require Export Comma_UA.
(* Comma_UA:
Require Export Comma.
Require Export UniversalArrow.

Set Implicit Arguments.
Unset Strict Implicit.

Section ua_comma.

Variables (A X : Category) (G : Functor A X) (x : X).

Variable u : UA x G.

Canonical Structure UA_com_ob := Build_Com_ob (UA_mor u).

 Section ua_com_arrow_def.

 Variable axf : Comma G x.

 Lemma UA_com_law : Com_law (UA_diese u (Mor_com_ob axf)).

 Canonical Structure UA_com_arrow := Build_Com_arrow UA_com_law.

 End ua_com_arrow_def.

Lemma UA_isInitial : IsInitial UA_com_arrow.

Canonical Structure UA_Initial := Build_Initial UA_isInitial.

Variable axu : Initial (Comma G x).

Definition Com_diese (a' : A) (f : x --> G a') :=
  Mor_com_arrow (MorI axu (Build_Com_ob f)).

Let axu_ob := Initial_ob axu.

Lemma Com_UAlaw1 : UA_law1 (Mor_com_ob axu_ob) Com_diese.

Lemma Com_UAlaw2 : UA_law2 (Mor_com_ob axu_ob) Com_diese.

Lemma Com_isUA : IsUA (Mor_com_ob axu_ob).
         
Canonical Structure Com_UA := Build_UA Com_isUA.

End ua_comma. *)
Require Export FAFT_SSC2.
(* FAFT_SSC2:
Require Export Functor.

Set Implicit Arguments.
Unset Strict Implicit.

Section ssc2_def.

Variables (A X : Category) (G : Functor A X) (x : X).

Structure Cond2 (I : Type) (l : I -> A) (f : forall i : I, x --> G (l i))
  (a : A) (h : x --> G a) : Type := 
  {Cond2_i : I;
   Cond2_t : l Cond2_i --> a;
   Prf_Cond2_law : h =_S f Cond2_i o FMor G Cond2_t}.

Structure SSC2 : Type := 
  {SSC2_I : Type;
   SSC2_a : SSC2_I -> A;
   SSC2_f : forall i : SSC2_I, x --> G (SSC2_a i);
   SSC2_p : forall (a : A) (h : x --> G a), Cond2 SSC2_f h}.

Variables (s : SSC2) (a : A) (h : x --> G a).

Definition SSC2_i := Cond2_i (SSC2_p s h).

Definition SSC2_t := Cond2_t (SSC2_p s h).

Lemma Prf_SSC2_law : h =_S SSC2_f SSC2_i o FMor G SSC2_t.

End ssc2_def. *)

Set Implicit Arguments.
Unset Strict Implicit.

Section freyd_th_2'.

Variables (A X : Category) (G : Functor A X) (A_c : Complete A)
  (G_c : Continuous G) (s : forall x : X, SSC2 G x).

Section uaxG'.

 Variable x : X.

  Section ssc2_to_ssc1.

  Let I := SSC2_I (s x).

  Let f (i : I) := SSC2_f i.

  Let a (i : I) := SSC2_a i. 

  Let k (i : I) := Build_Com_ob (f i).

   Section ssc2_to_cond1.
   
   Variable axh : Comma G x.

   Definition SSC2_1_i := SSC2_i (s x) (Mor_com_ob axh).
  
   Definition SSC2_1_t := SSC2_t (s x) (Mor_com_ob axh).  

   Lemma SSC2_1_f_com_law : Com_law (axf:=k SSC2_1_i) (bxg:=axh) SSC2_1_t.
   Proof.
   unfold Com_law in |- *.
   apply (Prf_SSC2_law (s _) (Mor_com_ob axh)).
   Qed.

   Canonical Structure SSC2_1_f := Build_Com_arrow SSC2_1_f_com_law.
  
   Canonical Structure SSC2_1_cond := Build_Cond1 (I:=I) SSC2_1_f.

   End ssc2_to_cond1.

  Canonical Structure SSC2_1 := Build_SSC1 SSC2_1_cond.
 
  End ssc2_to_ssc1.

 Definition FT_UA' :=
   Com_UA (Thi2_initial (Comma_complete A_c G_c (x:=x)) SSC2_1).

 End uaxG'.

Definition AFT1' : LeftAdj G := LeftAdjUA FT_UA'.

End freyd_th_2'.