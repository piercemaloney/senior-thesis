
Require Export FunForget.
(* FunForget:
Require Export MON.
Require Export Functor.

Set Implicit Arguments.
Unset Strict Implicit.

Section forget_map_def.

Variable m1 m2 : Monoid.

Lemma FunForget_map_law : Map_law (MonMap (m1:=m1) (m2:=m2)).

Canonical Structure FunForget_map := Build_Map FunForget_map_law.

End forget_map_def.

Lemma FunForget_fcomp_law : Fcomp_law FunForget_map.

Lemma FunForget_fid_law : Fid_law FunForget_map.

Canonical Structure FunForget :=
  Build_Functor FunForget_fcomp_law FunForget_fid_law. *)
Require Export FreeMonoid.
(* FreeMonoid:
Require Export Monoid.

Set Implicit Arguments.
Unset Strict Implicit.

Section freem_def.

Variable A : Setoid.

Inductive Tlist : Type :=
  | Empty : Tlist
  | Concat1 : A -> Tlist -> Tlist.

Fixpoint Equal_Tlist (l : Tlist) : Tlist -> Prop :=
  fun m : Tlist =>
  match l, m with
  | Empty, Empty => True
  | Empty, _ => False
  | Concat1 a l1, Concat1 b m1 => a =_S b /\ Equal_Tlist l1 m1
  | _, _ => False
  end.

Lemma Equal_Tlist_equiv : Equivalence Equal_Tlist.

Canonical Structure Tlist_setoid : Setoid := Equal_Tlist_equiv.

Fixpoint Concat (l : Tlist_setoid) : Tlist_setoid -> Tlist_setoid :=
  fun m : Tlist_setoid =>
  match l with
  | Empty => m
  | Concat1 a l1 => Concat1 a (Concat l1 m)
  end.

Lemma Diff_Concat1_Empty :
 forall (a : A) (l : Tlist), ~ Equal_Tlist (Concat1 a l) Empty.

Lemma Concat_congl : Map2_congl_law Concat.

Lemma Concat_congr : Map2_congr_law Concat.

Definition Concat_map2 := Build_Map2 Concat_congl Concat_congr.

Lemma Mass_FreeMonoid : Monoid_ass Concat_map2.

Lemma Midl_FreeMonoid : Monoid_idl Concat_map2 Empty.

Lemma Midr_FreeMonoid : Monoid_idr Concat_map2 Empty.

Canonical Structure FreeMonoid :=
  Build_Monoid Mass_FreeMonoid Midl_FreeMonoid Midr_FreeMonoid.

End freem_def.

Coercion FreeMonoid : Setoid >-> Monoid. *)
Require Export UniversalArrow.
(* UniversalArrow:
Require Export CatProperty.
Require Export Functor.

Set Implicit Arguments.
Unset Strict Implicit.

Section ua_def.

Variables (A B : Category) (b : B) (G : Functor A B).

 Section isua_def.

 Variables (a : A) (u : b --> G a).

  Section ua_laws.

  Variable diese : forall a' : A, (b --> G a') -> (a --> a').

  Definition UA_eq (a' : A) (f : b --> G a') (g : a --> a') :=
    u o FMor G g =_S f.

  Definition UA_law1 := forall (a' : A) (f : b --> G a'), UA_eq f (diese f).

  Definition UA_law2 :=
    forall (a' : A) (f : b --> G a') (g : a --> a'),
    UA_eq f g -> g =_S diese f.

  End ua_laws.

 Structure IsUA : Type := 
   {UA_diese : forall a' : A, (b --> G a') -> (a --> a');
    Prf_isUA_law1 : UA_law1 UA_diese;
    Prf_isUA_law2 : UA_law2 UA_diese}.

 Variable t : IsUA.

 Lemma Diese_map : forall a' : A, Map_law (UA_diese t (a':=a')).

 End isua_def.

Structure > UA : Type := 
  {UA_ob : A; UA_mor : b --> G UA_ob; Prf_IsUA :> IsUA UA_mor}.

Lemma UA_diag :
 forall (u : UA) (a' : A) (f : b --> G a'),
 UA_mor u o FMor G (UA_diese u f) =_S f.
 
Lemma UA_diag1 :
 forall (u : UA) (a' : A) (f : b --> G a'),
 f =_S UA_mor u o FMor G (UA_diese u f).

Lemma UA_unic :
 forall (u : UA) (a' : A) (f : b --> G a') (g : UA_ob u --> a'),
 UA_mor u o FMor G g =_S f -> g =_S UA_diese u f.

Lemma UA_unic1 :
 forall (u : UA) (a' : A) (f : b --> G a') (g : UA_ob u --> a'),
 UA_mor u o FMor G g =_S f -> UA_diese u f =_S g.

End ua_def.

Section ua_iso_def.

Variables (A B : Category) (b : B) (G : Functor A B) (u1 u2 : UA b G).

Definition UA_iso_mor := UA_diese u1 (UA_mor u2).

Definition UA_iso_mor_1 := UA_diese u2 (UA_mor u1).

Lemma UA_iso_law1 : AreIsos UA_iso_mor UA_iso_mor_1.

Definition UA_iso : Iso (UA_ob u1) (UA_ob u2) := UA_iso_law1.

End ua_iso_def. *)

Set Implicit Arguments.
Unset Strict Implicit.

Section ua_fm.

Variable A : Setoid.

Definition UA_FM_fun (a : A) : FunForget A := Concat1 a (Empty A).

Lemma UA_FM_map_law : Map_law UA_FM_fun.
Proof.
unfold Map_law in |- *; simpl in |- *; intros a b H; split; trivial. 
Qed.

Canonical Structure UA_FM_mor := Build_Map UA_FM_map_law.

 Section ua_fm_diese_def.

 Variables (B : Monoid) (f : Map A (FunForget B)). 

 Fixpoint UA_FM_diese_fun (l : FreeMonoid A) : B :=
   match l with
   | Empty => Munit B
   | Concat1 a m => f a +_M UA_FM_diese_fun m
   end.

 Lemma UA_FM_diese_map_law : Map_law UA_FM_diese_fun.
 Proof.
 unfold Map_law in |- *; simpl in |- *.
 intros l1; elim l1.
 intro l2; elim l2.
 simpl in |- *; intro; apply Refl.
 intros c t H1 H2; elim H2.
 intros c t H1 l2; elim l2.
 intro H2; absurd (Equal_Tlist (Concat1 c t) (Empty A)).
 apply Diff_Concat1_Empty.
 trivial.
 intros c0 t0 H2; simpl in |- *; intro H3; elim H3; intros H4 H5.
 apply Trans with (f c +_M UA_FM_diese_fun t0).
 unfold ApMop in |- *; apply Map2_l.
 apply H1; trivial.
 trivial.
 unfold ApMop in |- *; apply Map2_r.
 apply Pres1; trivial.
 Qed.
 
 Canonical Structure UA_FM_diese_map := Build_Map UA_FM_diese_map_law.
 
 Lemma UA_FM_diese_unit_law : MonUnit_law UA_FM_diese_map.
 Proof.
 unfold MonUnit_law in |- *; simpl in |- *.
 apply Refl.
 Qed. 

 Lemma UA_FM_diese_op_law : MonOp_law UA_FM_diese_map.
 Proof.
 unfold MonOp_law in |- *; simpl in |- *.
 intro l1; elim l1.
 simpl in |- *; intro l2.
 apply Trans with (UA_FM_diese_fun l2).
 apply Refl.
 apply Midl1.
 simpl in |- *; intros c t H l2.
 apply Trans with (f c +_M (UA_FM_diese_fun t +_M UA_FM_diese_fun l2)).
 unfold ApMop in |- *; apply Map2_l; exact (H l2).
 apply Mass. 
 Qed.

 Canonical Structure UA_FM_diese :=
   Build_MonMor UA_FM_diese_unit_law UA_FM_diese_op_law.

 End ua_fm_diese_def.

Lemma UA_FM_law1 : UA_law1 UA_FM_mor UA_FM_diese.
Proof.
unfold UA_law1, UA_eq in |- *; intros B f.
unfold UA_FM_mor in |- *; simpl in |- *.
unfold Ext in |- *; simpl in |- *.
intro a; apply Midr1.
Qed.

Lemma UA_FM_law2 : UA_law2 UA_FM_mor UA_FM_diese.
Proof.
unfold UA_law2 in |- *; simpl in |- *.
unfold UA_eq, Equal_MonMor in |- *; simpl in |- *.
unfold UA_FM_diese_map, Ext in |- *; simpl in |- *.
unfold Comp_fun, UA_FM_fun, FMor at 1 in |- *; simpl in |- *.
intros B f h H l; elim l; simpl in |- *.
apply (MMon_unit h).
intros c t H1. 
apply Trans with (h (Concat1 c (Empty A)) +_M h t).
apply (MMon_op h (Concat1 c (Empty A)) t).
apply Trans with (f c +_M h t).
unfold ApMop in |- *; apply Map2_r; exact (H c). 
unfold ApMop in |- *; apply Map2_l; trivial.
Qed.
  
Lemma IsUA_FM : IsUA UA_FM_mor.
Proof.
exact (Build_IsUA UA_FM_law1 UA_FM_law2).
Defined.

Definition UA_FM : UA A FunForget := IsUA_FM.

End ua_fm.

