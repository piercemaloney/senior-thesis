
Require Export CatProperty.
(* CatProperty:
Require Export Dual.

Set Implicit Arguments.
Unset Strict Implicit.

Section epic_monic_def.

Variables (C : Category) (a b : C).
 
Definition Epic_law (f : a --> b) :=
  forall (c : C) (g h : b --> c), f o g =_S f o h -> g =_S h.

Structure > Epic : Type := 
  {Epic_mor : a --> b; Prf_isEpic :> Epic_law Epic_mor}.

Definition Monic_law (f : b --> a) :=
  forall (c : C) (g h : c --> b), g o f =_S h o f -> g =_S h.

Structure > Monic : Type := 
  {Monic_mor : b --> a; Prf_isMonic :> Monic_law Monic_mor}.

End epic_monic_def.

Section iso_def.

Variable C : Category.

Definition RIso_law (a b : C) (f : a --> b) (f1 : b --> a) := f1 o f =_S Id b.

Variable a b : C.

Definition AreIsos (f : a --> b) (f1 : b --> a) :=
  RIso_law f f1 /\ RIso_law f1 f.

Structure > Iso : Type := 
  {Iso_mor : a --> b; Inv_iso : b --> a; Prf_Iso :> AreIsos Iso_mor Inv_iso}.

Lemma Idl_inv : forall i : Iso, RIso_law (Iso_mor i) (Inv_iso i).

Lemma Idr_inv : forall i : Iso, RIso_law (Inv_iso i) (Iso_mor i).

Lemma Inv_iso_unique :
 forall f g : Iso, Iso_mor f =_S Iso_mor g -> Inv_iso f =_S Inv_iso g.

Lemma RightInv_epic :
 forall (h : a --> b) (h1 : b --> a), RIso_law h h1 -> Epic_law h.

End iso_def.

Coercion RightInv_epic : RIso_law >-> Epic_law.

Section initial_def.

Variable C : Category.

Definition IsInitial (a : C) (h : forall b : C, a --> b) :=
  forall (b : C) (f : a --> b), f =_S h b.
  
Structure > Initial : Type := 
  {Initial_ob : C;
   MorI : forall b : C, Initial_ob --> b;
   Prf_isInitial :> IsInitial MorI}.

Definition At_most_1mor (a b : C) := forall f g : a --> b, f =_S g.

Lemma UniqueI : forall (i : Initial) (b : C), At_most_1mor (Initial_ob i) b.

Lemma I_unic : forall i1 i2 : Initial, Iso (Initial_ob i1) (Initial_ob i2).

End initial_def.

Section terminal_def.

Variable C : Category.

Definition IsTerminal (b : C) (h : forall a : C, a --> b) :=
  forall (a : C) (f : a --> b), f =_S h a. 

Structure > Terminal : Type := 
  {Terminal_ob : C;
   MorT : forall a : C, a --> Terminal_ob;
   Prf_isTerminal :> IsTerminal MorT}.

Lemma UniqueT : forall (t : Terminal) (a : C), At_most_1mor a (Terminal_ob t).

End terminal_def.

Lemma Initial_dual :
 forall (C : Category) (a : C) (h : forall b : C, a --> b),
 IsInitial h -> IsTerminal (C:=Dual C) h.

Coercion Initial_dual : IsInitial >-> IsTerminal.

Definition IsTerminal' (C : Category) (b : C) (h : forall a : C, a --> b) :=
  IsInitial (C:=Dual C) h. *)
Require Export CatFunct.
(* CatFunct:
Require Export Ntransformation.
Require Export Category_dup2.

Set Implicit Arguments.
Unset Strict Implicit.

Section cat_functor.

Variable C D : Category.

 Section compnt.

 Variables (F G H : Functor C D) (T : NT F G) (T' : NT G H).

 Definition Comp_tau (a : C) := T a o T' a.

 Lemma Comp_tau_nt_law : NT_law Comp_tau.

 Canonical Structure CompV_NT : NT_setoid F H := Comp_tau_nt_law.

 End compnt.

Lemma CompV_NT_congl : Congl_law'' CompV_NT.  

Lemma CompV_NT_congr : Congr_law'' CompV_NT.  

Definition Comp_CatFunct := Build_Comp'' CompV_NT_congl CompV_NT_congr.
   
Lemma Assoc_CatFunct : Assoc_law'' Comp_CatFunct.

 Section id_catfunct_def.

 Variable F : Functor C D.

 Definition Id_CatFunct_tau (a : C) := Id (F a).
 
 Lemma Id_CatFunct_nt_law : NT_law Id_CatFunct_tau.
  
 Canonical Structure Id_CatFunct := Build_NT Id_CatFunct_nt_law.

 End id_catfunct_def.

Lemma Idl_CatFunct : Idl_law'' Comp_CatFunct Id_CatFunct.

Lemma Idr_CatFunct : Idr_law'' Comp_CatFunct Id_CatFunct.

Canonical Structure FUNCT :=
  Build_Category'' Assoc_CatFunct Idl_CatFunct Idr_CatFunct.

End cat_functor.

Infix "o_NTv" := CompV_NT (at level 20, right associativity). *)

Set Implicit Arguments.
Unset Strict Implicit.

Section natiso_def.

Variable A B : Category.

Definition RNatIso_law (F G : Functor A B) (T : NT F G) 
  (T1 : NT G F) := T1 o_NTv T =_NT Id_CatFunct G.

Variable F G : Functor A B.

Definition AreNatIsos (T : NT F G) (T1 : NT G F) :=
  RNatIso_law T T1 /\ RNatIso_law T1 T.

Structure > NatIso : Type := 
  {NatIso_mor :> NT F G;
   NatIso_inv : NT G F;
   Prf_NatIso :> AreNatIsos NatIso_mor NatIso_inv}.

Lemma Idl_nat_inv :
 forall i : NatIso, RNatIso_law (NatIso_mor i) (NatIso_inv i).
Proof.
simple induction i; unfold AreNatIsos in |- *; intros T1 T2 p; elim p; auto.
Qed.

Lemma Idr_nat_inv :
 forall i : NatIso, RNatIso_law (NatIso_inv i) (NatIso_mor i).
Proof.
simple induction i; unfold AreNatIsos in |- *; intros T1 T2 p; elim p; auto.
Qed.

End natiso_def.

Section about_isIso.

Variables (A B : Category) (F G : Functor A B) (T : NT F G).

Variable h : forall a : A, G a --> F a.

Hypothesis H : forall a : A, AreIsos (T a) (h a).
   
Lemma NTinv_nt_law : NT_law h.
Proof.
unfold NT_law in |- *; intros a b f.
 apply Trans with ((h a o T a o FMor G f) o h b).
apply Comp_r.
 apply Trans with ((h a o T a) o FMor G f).
 apply Trans with (Id (G a) o FMor G f).
apply Idl1.
apply Comp_r; apply Sym; apply (Idl_inv (H a)).
apply Ass1.
 apply Trans with ((h a o FMor F f o T b) o h b).
apply Comp_r; apply Comp_l; apply NatCond1.
 apply Trans with (h a o (FMor F f o T b) o h b).
apply Ass1.
apply Comp_l.
 apply Trans with (FMor F f o T b o h b).
apply Ass1.
 apply Trans with (FMor F f o Id _).
apply Comp_l; apply (Idr_inv (H b)).
apply Idr1.
Qed.

Canonical Structure NTinv := Build_NT NTinv_nt_law.

Lemma NT_areIso : AreNatIsos T NTinv.
Proof.
red in |- *; split; unfold RNatIso_law in |- *; unfold Equal_NT in |- *;
 simpl in |- *; unfold Comp_tau in |- *; simpl in |- *;
 unfold Id_CatFunct_tau in |- *; intro a.
apply (Idl_inv (H a)).
apply (Idr_inv (H a)).
Qed.

Canonical Structure NT_Iso : NatIso F G := NT_areIso.

Variable T1 : NT G F.

Hypothesis H' : AreNatIsos T T1.

Variable a : A.

Lemma NTa_areIso : AreIsos (T a) (T1 a).
Proof.
red in |- *; split; unfold RIso_law in |- *.
apply (Idl_nat_inv H' a).
apply (Idr_nat_inv H' a).
Qed.

Canonical Structure NTa_Iso : Iso (F a) (G a) := NTa_areIso.

End about_isIso.

