
Require Export PROD.
(* PROD:
Require Export Category. 
Require Export SetoidPROD.

Set Implicit Arguments.
Unset Strict Implicit.

Section ProdCat.

Variable A B : Category.

Structure POb : Type :=  {Ob_l : A; Ob_r : B}.

 Section pmor_setoid_def.

 Variable u t : POb.

 Structure Pmor : Type := 
   {Hom_l : Ob_l u --> Ob_l t; Hom_r : Ob_r u --> Ob_r t}.

 Definition Equal_Pmor (f g : Pmor) :=
   Hom_l f =_S Hom_l g /\ Hom_r f =_S Hom_r g.

 Lemma Equal_Pmor_equiv : Equivalence Equal_Pmor.

 Canonical Structure Prod_Hom : Setoid := Equal_Pmor_equiv.

 Definition Prod_Hom' := SPROD (Ob_l u --> Ob_l t) (Ob_r u --> Ob_r t).

 Definition Build1_Pmor :
   (Ob_l u --> Ob_l t) -> (Ob_r u --> Ob_r t) -> Prod_Hom := Build_Pmor.
                
 End pmor_setoid_def.

Definition Comp_Pmor (a b c : POb) (f : Prod_Hom a b) 
  (g : Prod_Hom b c) := Build_Pmor (Hom_l f o Hom_l g) (Hom_r f o Hom_r g).

Lemma Comp_Pmor_congl : Congl_law Comp_Pmor.

Lemma Comp_Pmor_congr : Congr_law Comp_Pmor.

Definition Comp_PROD := Build_Comp Comp_Pmor_congl Comp_Pmor_congr.

Lemma Assoc_PROD : Assoc_law Comp_PROD.

Definition Id_PROD (a : POb) := Build_Pmor (Id (Ob_l a)) (Id (Ob_r a)).

Lemma Idl_PROD : Idl_law Comp_PROD Id_PROD.
 
Lemma Idr_PROD : Idr_law Comp_PROD Id_PROD.
 
Canonical Structure PROD := Build_Category Assoc_PROD Idl_PROD Idr_PROD.

End ProdCat. *)
Require Export Functor. 
(* Functor:
Require Export Setoid_dup1.
Require Export Hom_Equality.

Set Implicit Arguments.
Unset Strict Implicit.

Section funct_def.

Variable C D : Category.

 Section funct_laws.

 Variables (FOb : C -> D)
   (FMap : forall a b : C, Map (a --> b) (FOb a --> FOb b)).

 Definition Fcomp_law :=
   forall (a b c : C) (f : a --> b) (g : b --> c),
   FMap a c (f o g) =_S FMap a b f o FMap b c g.

 Definition Fid_law := forall a : C, FMap a a (Id a) =_S Id (FOb a).

 End funct_laws.

Structure Functor : Type := 
  {FOb :> C -> D;
   FMap : forall a b : C, Map (a --> b) (FOb a --> FOb b);
   Prf_Fcomp_law : Fcomp_law FMap;
   Prf_Fid_law : Fid_law FMap}.

Definition FMor (F : Functor) (a b : C) (f : a --> b) := FMap F a b f.

Lemma FPres :
 forall (F : Functor) (a b : C) (f g : a --> b),
 f =_S g -> FMor F f =_S FMor F g.

Lemma FComp :
 forall (F : Functor) (a b c : C) (f : a --> b) (g : b --> c),
 FMor F (f o g) =_S FMor F f o FMor F g.

Lemma FComp1 :
 forall (F : Functor) (a b c : C) (f : a --> b) (g : b --> c),
 FMor F f o FMor F g =_S FMor F (f o g).

Lemma FId : forall (F : Functor) (a : C), FMor F (Id a) =_S Id (FOb F a).

Lemma FId1 : forall (F : Functor) (a : C), Id (FOb F a) =_S FMor F (Id a).

End funct_def.

Section funct_setoid.

Variable C D : Category. 

Definition Equal_Functor (F G : Functor C D) :=
  forall (a b : C) (f : a --> b), FMor F f =_H FMor G f.

Lemma Equal_Functor_equiv : Equivalence Equal_Functor.

Canonical Structure Functor_setoid := Build_Setoid' Equal_Functor_equiv.

End funct_setoid.

Infix "=_F" := Equal_Functor (at level 70).

Section Comp_F.

Variables (C D E : Category) (G : Functor C D) (H : Functor D E).

Definition Comp_FOb (a : C) := H (G a).

 Section comp_functor_map.

 Variable a b : C.

 Definition Comp_FMor (f : a --> b) := FMor H (FMor G f). 

 Lemma Comp_FMap_law : Map_law Comp_FMor.

 Definition Comp_FMap :=
   Build_Map (B:=Comp_FOb a --> Comp_FOb b) Comp_FMap_law.

 End comp_functor_map.

Lemma Comp_Functor_comp_law : Fcomp_law Comp_FMap.

Lemma Comp_Functor_id_law : Fid_law Comp_FMap.

Canonical Structure Comp_Functor :=
  Build_Functor Comp_Functor_comp_law Comp_Functor_id_law.

End Comp_F.

Infix "o_F" := Comp_Functor (at level 20, right associativity). *)

Set Implicit Arguments.
Unset Strict Implicit.

Section prod_proj.

Variable A B : Category.

Lemma Fst_map_law : forall a b : PROD A B, Map_law (Hom_l (u:=a) (t:=b)).
Proof.
unfold Map_law in |- *.
intros a b; unfold Equal at 1 in |- *; simpl in |- *.
unfold Equal_Pmor in |- *; intros f g H.
elim H; intros; assumption.
Qed.

Canonical Structure Fst_map (a b : PROD A B) :=
  Build_Map (Fst_map_law (a:=a) (b:=b)).

Lemma Fst_comp_law : Fcomp_law Fst_map.
Proof.
unfold Fcomp_law in |- *; simpl in |- *.
intros a b c f g.
apply Refl.
Qed.

Lemma Fst_id_law : Fid_law Fst_map.
Proof.
unfold Fid_law in |- *; simpl in |- *.
intro a; apply Refl.
Qed.
 
Canonical Structure Fst := Build_Functor Fst_comp_law Fst_id_law.

Lemma Snd_map_law : forall a b : PROD A B, Map_law (Hom_r (u:=a) (t:=b)).
Proof.
unfold Map_law in |- *.
intros a b; unfold Equal at 1 in |- *; simpl in |- *.
unfold Equal_Pmor in |- *; intros f g H.
elim H; intros; assumption.
Qed.

Canonical Structure Snd_map (a b : PROD A B) :=
  Build_Map (Snd_map_law (a:=a) (b:=b)).

Lemma Snd_comp_law : Fcomp_law Snd_map.
Proof.
unfold Fcomp_law in |- *; simpl in |- *.
intros a b c f g.
apply Refl.
Qed.

Lemma Snd_id_law : Fid_law Snd_map.
Proof.
unfold Fid_law in |- *; simpl in |- *.
intro a; apply Refl.
Qed.
 
Canonical Structure Snd := Build_Functor Snd_comp_law Snd_id_law.

End prod_proj.