
Require Export Equalizers1.
(* Equalizers1:
Require Export Equalizers.
Require Export PA.
Require Export Limit.

Set Implicit Arguments.
Unset Strict Implicit.

Section equalizer_limit_def.

Variables (C : Category) (a b : C) (I : Type) (k : I -> (a --> b)).

Definition FPA_ob (x : PA k) := match x with
                                | PA1 => a
                                | PA2 => b
                                end.

Definition FPA_mor (x y : PA k) (f : x --> y) :=
  match f in (PA_mor _ x' y') return (Carrier (FPA_ob x' --> FPA_ob y')) with
  | PA_I1 => Id a
  | PA_I2 => Id b
  | PA_f i => k i
  end.

Lemma FPA_map_law : forall x y : PA_ob, Map_law (FPA_mor (x:=x) (y:=y)).

Canonical Structure FPA_map (x y : PA k) :=
  Build_Map (FPA_map_law (x:=x) (y:=y)).

Lemma FPA_comp_law : Fcomp_law FPA_map.

Lemma FPA_id_law : Fid_law FPA_map.

Canonical Structure FPA := Build_Functor FPA_comp_law FPA_id_law.

SubClass Equalizer1 := Limit FPA.

Structure Equalizer2 : Type :=  {Prf_equalizer1 :> Equalizer1; Witness : I}.

Variable l : Equalizer2.

Definition E1_ob := Lim l.

Definition E1_mor : E1_ob --> a := Limiting_cone l PA1.
 
Lemma Prf_E1_law1 : Equalizer_law1 k E1_mor.

 Section e1_diese_def.

 Variables (r : C) (h : r --> a).
 Hypothesis p : Equalizer_eq k h.

 Definition E_tau (x : PA k) :=
   match x as x' return (Carrier (r --> FPA x')) with
   | PA1 => h
   | PA2 => h o k (Witness l)
   end.
 
 Lemma E_tau_cone_law : Cone_law E_tau.
 
 Definition E_NT := Build_Cone E_tau_cone_law.

 Definition E1_diese : r --> E1_ob := Lim_diese l E_NT.
 
 End e1_diese_def.

Lemma Prf_E1_law2 : Equalizer_law2 E1_mor E1_diese.

Lemma Prf_E1_law3 : Equalizer_law3 E1_mor E1_diese.

Canonical Structure Equalizer2_to_Equalizer :=
  Build_Equalizer Prf_E1_law1 Prf_E1_law2 Prf_E1_law3.

End equalizer_limit_def.

Coercion Equalizer2_to_Equalizer : Equalizer2 >-> Equalizer.

Section equaz_fg.

Variables (C : Category) (a b : C) (f g : a --> b).

Definition K_fg (i : TwoElts) := match i with
                                 | Elt1 => f
                                 | Elt2 => g
                                 end.

Definition J_fg := PA K_fg.

Definition F_fg := FPA K_fg.

SubClass Equalizer1_fg := Equalizer1 K_fg.

Lemma Prf_law1_fg :
 forall (r : C) (h : r --> a), h o f =_S h o g -> Equalizer_eq K_fg h.

End equaz_fg.

Section equaz_hom.

Variables (C : Category) (a b : C).

Definition K_hom (f : a --> b) := f.

Definition J_hom := PA K_hom.

Definition F_hom := FPA K_hom.

SubClass Equalizer1_hom := Equalizer1 K_hom.

End equaz_hom. *)
Require Export Products1.
(* Products1:
Require Export Limit.
Require Export Discr.
Require Export Products.

Set Implicit Arguments.
Unset Strict Implicit.

Section products_limit_def.

Variables (C : Category) (I : Type) (a : I -> C).

Definition FunDiscr_ob (i : Discr I) := a i.

Definition FunDiscr_arrow (i j : Discr I) (f : i --> j) :=
  match f in (Discr_mor d d0) return (Carrier (a d --> a d0)) with
  | Build_Discr_mor k => Id (a k)
  end.

Lemma FunDiscr_map_law :
 forall i j : I, Map_law (FunDiscr_arrow (i:=i) (j:=j)).

Canonical Structure FunDiscr_map (i j : Discr I) :=
  Build_Map (FunDiscr_map_law (i:=i) (j:=j)).

Lemma FunDiscr_comp_law : Fcomp_law FunDiscr_map.

Lemma FunDiscr_id_law : Fid_law FunDiscr_map.

Canonical Structure FunDiscr :=
  Build_Functor FunDiscr_comp_law FunDiscr_id_law.

SubClass Product1 := Limit FunDiscr.

Variable l : Product1.

Definition Pi1 := Lim l.

Definition Proj1 (i : I) : Pi1 --> a i := Limiting_cone l i.

 Section pd1_diese_def.

 Variables (c : C) (f : forall j : I, c --> FunDiscr j).

 Definition Product_tau (j : Discr I) := f j.

 Lemma Product_tau_cone_law : Cone_law Product_tau.

 Definition Product_nt := Build_Cone Product_tau_cone_law.

 Definition Pd1_diese : c --> Pi1 := Lim_diese l Product_nt.

 End pd1_diese_def.

Lemma Prf_pd1_law1 : Product_law1 Proj1 Pd1_diese.

Lemma Prf_pd1_law2 : Product_law2 Proj1 Pd1_diese.

Canonical Structure Product1_to_Product :=
  Build_Product Prf_pd1_law1 Prf_pd1_law2.

End products_limit_def.

Coercion Product1_to_Product : Product1 >-> Product. *)

Set Implicit Arguments.
Unset Strict Implicit.

Section thl.

Variables (C J : Category) (H1 : forall k : J -> C, Product1 k)
  (H2 : forall k : Arrs J -> C, Product1 k)
  (H3 : forall (a b : C) (f g : a --> b), Equalizer1_fg f g)
  (F : Functor J C).

Let Limit2_fg (a b : C) (f g : a --> b) := Build_Equalizer2 (H3 f g) Elt1.

Definition Thl_k_Fi (i : J) := F i.

Definition Thl_l_Fi := H1 Thl_k_Fi.

Definition Thl_PI_Fi := Pi1 Thl_l_Fi.

Definition Thl_k_Fu (u : Arrs J) := F (Codom u).

Definition Thl_l_Fu := H2 Thl_k_Fu.

Definition Thl_PI_Fu := Pi1 Thl_l_Fu.

Definition Thl_fu (u : Arrs J) := Proj1 Thl_l_Fi (Codom u).

Definition Thl_f : Thl_PI_Fi --> Thl_PI_Fu := Pd1_diese Thl_l_Fu Thl_fu.

Lemma Thl_diag1 : forall u : Arrs J, Thl_fu u =_S Thl_f o Proj1 Thl_l_Fu u.
Proof.
exact (Prf_pd1_law1 Thl_l_Fu Thl_fu).
Qed.

Definition Thl_gu (u : Arrs J) := Proj1 Thl_l_Fi (Dom u) o FMor F (Arrow u).

Definition Thl_g := Pd1_diese Thl_l_Fu Thl_gu.

Lemma Thl_diag2 : forall u : Arrs J, Thl_gu u =_S Thl_g o Proj1 Thl_l_Fu u.
Proof.
exact (Prf_pd1_law1 Thl_l_Fu Thl_gu).
Qed.

Definition Thl_l_fg := Limit2_fg Thl_f Thl_g.

Definition Thl_d := E1_ob Thl_l_fg.
  
Definition Thl_e := E1_mor Thl_l_fg.
 
Definition Thl_mu_tau (j : J) := Thl_e o Proj1 Thl_l_Fi j.

Lemma Thl_mu_cone_law : Cone_law Thl_mu_tau.
Proof.
unfold Cone_law in |- *; intros j k u; unfold Thl_mu_tau in |- *.
 apply Trans with (Thl_e o Thl_f o Proj1 Thl_l_Fu (Build_Arrs u)).
apply Comp_l.
apply (Thl_diag1 (Build_Arrs u)).
 apply Trans with (Thl_e o Proj1 Thl_l_Fi j o FMor F u).
 apply Trans with (Thl_e o Thl_g o Proj1 Thl_l_Fu (Build_Arrs u)).
 apply Trans with ((Thl_e o Thl_f) o Proj1 Thl_l_Fu (Build_Arrs u)).
apply Ass.
 apply Trans with ((Thl_e o Thl_g) o Proj1 Thl_l_Fu (Build_Arrs u)).
apply Comp_r.
apply (Prf_E1_law1 Thl_l_fg Elt1 Elt2).
apply Ass1.
apply Comp_l.
apply Sym.
exact (Thl_diag2 (Build_Arrs u)).
apply Ass.
Qed.
 
Definition Thl_mu := Build_Cone Thl_mu_cone_law.

 Section taudiese.

 Variables (c : C) (tau : Cone c F).

 Definition Thl_h := Pd1_diese Thl_l_Fi (c:=c) (fun i : J => tau i).

 Lemma Thl_diag3 : forall i : J, tau i =_S Thl_h o Proj1 Thl_l_Fi i.
 Proof.
 intro i; apply (Prf_pd1_law1 Thl_l_Fi (r:=c) (fun i : J => tau i) i).
 Qed.

 Lemma Thl_diag4 : Thl_h o Thl_f =_S Thl_h o Thl_g.
 Proof.
  apply
        Trans
         with (Pd1_diese Thl_l_Fu (c:=c) (fun u : Arrs J => tau (Codom u))).
 apply
  (Prf_pd1_law2 (l:=Thl_l_Fu) (r:=c) (h:=fun u : Arrs J => tau (Codom u))).
 unfold Product_eq in |- *; intro u.
  apply Trans with (Thl_h o Proj1 Thl_l_Fi (Codom u)).
 apply (Thl_diag3 (Codom u)).
  apply Trans with (Thl_h o Thl_f o Proj1 Thl_l_Fu u).
 apply Comp_l.
 apply (Thl_diag1 u).
 apply Ass.
 apply Sym.
 apply
  (Prf_pd1_law2 (l:=Thl_l_Fu) (r:=c) (h:=fun u : Arrs J => tau (Codom u))).
 unfold Product_eq in |- *; intro u.
  apply Trans with (tau (Dom u) o FMor F (Arrow u)).
 apply (Eq_cone tau (Arrow u)).
  apply Trans with ((Thl_h o Proj1 Thl_l_Fi (Dom u)) o FMor F (Arrow u)).
 apply Comp_r.
 apply (Thl_diag3 (Dom u)).
  apply Trans with (Thl_h o Proj1 Thl_l_Fi (Dom u) o FMor F (Arrow u)).
 apply Ass1.
  apply Trans with (Thl_h o Thl_g o Proj1 Thl_l_Fu u).
 apply Comp_l.
 apply (Thl_diag2 u).
 apply Ass.
 Qed.

 Definition Thl_diese := E1_diese Thl_l_fg (Prf_law1_fg Thl_diag4).

 End taudiese.

Lemma Thl_limit1 : Limit_law1 Thl_mu Thl_diese.
Proof.
unfold Limit_law1, Limit_eq in |- *; intros c tau; simpl in |- *; intro i.
 apply Trans with ((Thl_diese tau o Thl_e) o Proj1 Thl_l_Fi i).
 apply Trans with (Thl_diese tau o Thl_e o Proj1 Thl_l_Fi i).
apply Refl.
apply Ass.
 apply
       Trans
        with
          (Pd1_diese Thl_l_Fi (c:=c) (fun i : J => tau i) o Proj1 Thl_l_Fi i).
apply Comp_r.
apply Sym.
apply (Prf_E1_law2 Thl_l_fg (Prf_law1_fg (Thl_diag4 tau))).
apply Sym.
apply (Thl_diag3 tau i).
Qed.

Lemma Thl_limit2 : Limit_law2 Thl_mu Thl_diese.
Proof.
unfold Limit_law2, Limit_eq in |- *; intros c tau t H.
unfold Thl_diese in |- *; apply (Prf_E1_law3 (l:=Thl_l_fg)).
apply Sym.
unfold Thl_h in |- *.
apply (Prf_pd1_law2 (l:=Thl_l_Fi)); unfold Product_eq in |- *; intro i.
apply Trans with (t o Thl_e o Proj1 Thl_l_Fi i).
apply Sym.
exact (H i).
apply Ass.
Qed.

Definition Thl_islimit := Build_IsLimit Thl_limit1 Thl_limit2.

Definition Thl_limit := Build_Limit Thl_islimit.

End thl.

