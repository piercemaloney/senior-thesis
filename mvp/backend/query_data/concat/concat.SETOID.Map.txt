
Require Export Setoid.
(* Setoid:
Require Export Relations.

Set Implicit Arguments.
Unset Strict Implicit.
Global Set Asymmetric Patterns.

Structure > Setoid : Type := 
  {Carrier :> Type; Equal : Relation Carrier; Prf_equiv :> Equivalence Equal}.

Infix "=_S" := Equal (at level 70).

Lemma Refl : forall (S : Setoid) (x : S), x =_S x.

Lemma Sym : forall (S : Setoid) (x y : S), x =_S y -> y =_S x.

Lemma Trans : forall (S : Setoid) (x y z : S), x =_S y -> y =_S z -> x =_S z.

Inductive Nat : Type :=
  | Z : Nat
  | Suc : Nat -> Nat.

Definition Eq_Nat (N1 N2 : Nat) := N1 = N2.

Lemma Eq_Nat_equiv : Equivalence Eq_Nat.
 
Definition Set_of_nat : Setoid := Eq_Nat_equiv.

Structure > PSetoid : Type := 
  {PCarrier :> Type;
   Coherence : Relation PCarrier;
   Prf_PER :> Partial_equivalence Coherence}.

Definition Total (A : PSetoid) (x : A) := Coherence x x. *)

Set Implicit Arguments.
Unset Strict Implicit.

Section maps.

Variable A B : Setoid.

Definition Map_law (f : A -> B) := forall x y : A, x =_S y -> f x =_S f y.

Structure > Map : Type :=  {Ap :> A -> B; Pres :> Map_law Ap}.

Lemma Pres1 : forall (m : Map) (x y : A), x =_S y -> m x =_S m y.
Proof.
exact Pres.
Qed.

Definition Ext (f g : Map) := forall x : A, f x =_S g x.

Lemma Ext_equiv : Equivalence Ext.
Proof.
intros; apply Build_Equivalence.
unfold Reflexive in |- *; unfold Ext in |- *; intros f x.
apply Refl.
apply Build_Partial_equivalence.
unfold Transitive in |- *; unfold Ext in |- *; intros f g h e1 e2 x.
 apply Trans with (g x).
apply (e1 x).
apply (e2 x).
unfold Symmetric in |- *; unfold Ext in |- *; intros f g e x.
apply Sym; trivial.
Qed.

Canonical Structure Map_setoid : Setoid := Ext_equiv.

End maps.

Infix "=_M" := Ext (at level 70).
Infix "==>" := Map_setoid (at level 95, right associativity).

Section id_map_def.

Variable A : Setoid.

Definition Id_fun (x : A) := x.
     
Lemma Id_fun_map_law : Map_law Id_fun.
Proof.
unfold Map_law in |- *; trivial.
Qed.

Canonical Structure Id_map : Map A A := Id_fun_map_law.
  
End id_map_def.
 
Section mcomp.

Variables (A B C : Setoid) (f : Map A B) (g : Map B C).

Definition Comp_fun (x : A) := g (f x).

Lemma Comp_fun_map_law : Map_law Comp_fun.
Proof.
unfold Map_law in |- *; intros a1 a2 H.
unfold Comp_fun in |- *; simpl in |- *.
apply Pres1.
apply Pres1; trivial.
Qed.

Canonical Structure Comp_map : Map A C := Comp_fun_map_law.

End mcomp.

Infix "o_M" := Comp_map (at level 20, right associativity). 