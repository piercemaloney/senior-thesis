

Require Import List.



Notation "A || B @ X 'by' E"

  := (eq_ind_r (fun X => B) A E) (at level 40, left associativity).



Notation "A || B @ X 'by' <- H"

  := (eq_ind_r (fun X => B) A (eq_sym H)) (at level 40, left associativity).



Notation "A =:= B"

  := (eq_refl A : A = B) (at level 90).



Theorem Forall_tail

  :  forall (A : Type) (P : A -> Prop) (x0 : A) (xs : list A), Forall P (x0 :: xs) -> Forall P xs.

Proof fun _ P x0 xs H

       => let H0

            :  forall x, In x (x0 :: xs) -> P x

            := proj1 (Forall_forall P (x0 :: xs)) H in

          let H1

            :  forall x, In x xs -> P x

            := fun x H2

                 => H0 x (or_intror (x0 = x) H2) in

          proj2 (Forall_forall P xs) H1.



Arguments Forall_tail {A} {P} x0 xs.



Theorem Exists_impl

  :  forall (A : Type) (P Q : A -> Prop),

     (forall x : A, P x -> Q x) ->

     forall xs : list A,

       Exists P xs ->

       Exists Q xs.

Proof fun _ P Q H xs H0

       => let H1

            :  exists x, In x xs /\ P x

            := proj1 (Exists_exists P xs) H0 in

          let H2

            :  exists x, In x xs /\ Q x

            := ex_ind

                 (fun x H2

                   => ex_intro

                        (fun x => In x xs /\ Q x)

                        x

                        (conj

                          (proj1 H2)

                          (H x (proj2 H2))))

                 H1 in

          (proj2 (Exists_exists Q xs)) H2.



Arguments Exists_impl {A} {P} {Q} H xs H0.

