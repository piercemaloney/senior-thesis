
Require Import cgraph.
(* cgraph:
Require Import NArith.
Require Import Ndigits.
Require Import Ndec.
From IntMap Require Import Allmaps.
Require Import Arith.
Require Import ZArith.
Require Import Bool.
Require Import Sumbool.
Require Import List.
Require Import Wf_nat.

Unset Standard Proposition Elimination Names.

Section ConstraintGraphs.

  Variable D : Set.  

  Variable Dz : D.
  Variable Dplus : D -> D -> D.
  Variable Dneg : D -> D.
  Variable Dle : D -> D -> bool.

  Variable Dplus_d_z : forall d : D, Dplus d Dz = d.
  Variable Dplus_z_d : forall d : D, Dplus Dz d = d.
  Variable
    Dplus_assoc :
      forall d d' d'' : D, Dplus (Dplus d d') d'' = Dplus d (Dplus d' d'').

  Variable Dplus_neg : forall d : D, Dplus d (Dneg d) = Dz.

  Variable Dle_refl : forall d : D, Dle d d = true.
  Variable
    Dle_antisym :
      forall d d' : D, Dle d d' = true -> Dle d' d = true -> d = d'.
  Variable
    Dle_trans :
      forall d d' d'' : D,
      Dle d d' = true -> Dle d' d'' = true -> Dle d d'' = true.
  Variable Dle_total : forall d d' : D, {Dle d d' = true} + {Dle d' d = true}.

  Variable
    Dle_plus_mono :
      forall d d' d'' d''' : D,
      Dle d d' = true ->
      Dle d'' d''' = true -> Dle (Dplus d d'') (Dplus d' d''') = true.

Lemma Dle_true_permut :
 forall d d' : D, Dle d d' = true -> {Dle d' d = false} + {d = d'}.

Definition Dmin (d d' : D) := if Dle d d' then d else d'.

Lemma Dle_true_Dmin : forall d d' : D, Dle d d' = true -> Dmin d d' = d.

Lemma Dle_inv_Dmin : forall d d' : D, Dle d' d = true -> Dmin d d' = d'.

Hint Resolve Dle_true_Dmin Dle_inv_Dmin.

Lemma Dmin_idempotent : forall d : D, Dmin d d = d.

Lemma Dmin_comm : forall d d' : D, Dmin d d' = Dmin d' d.

Lemma Dmin_assoc :
 forall d d' d'' : D, Dmin (Dmin d d') d'' = Dmin d (Dmin d' d'').

Lemma Dmin_le_1 : forall d d' : D, Dle (Dmin d d') d = true.

Lemma Dmin_le_2 : forall d d' : D, Dle (Dmin d d') d' = true.

Lemma Dmin_le_3 :
 forall d d' d'' : D, Dle d (Dmin d' d'') = true -> Dle d d' = true.

Lemma Dmin_le_4 :
 forall d d' d'' : D, Dle d (Dmin d' d'') = true -> Dle d d'' = true.

Lemma Dmin_le_5 :
 forall d d' d'' : D,
 Dle d d' = true -> Dle d d'' = true -> Dle d (Dmin d' d'') = true.

Lemma Dneg_Dz : Dneg Dz = Dz.

Lemma Dneg_neg : forall d : D, Dneg (Dneg d) = d.

Lemma Dplus_neg_2 : forall d : D, Dplus (Dneg d) d = Dz.

Lemma Dplus_reg_l :
 forall d d' d'' : D,
 Dle (Dplus d'' d) (Dplus d'' d') = true -> Dle d d' = true.

Lemma Dplus_reg_r :
 forall d d' d'' : D,
 Dle (Dplus d d'') (Dplus d' d'') = true -> Dle d d' = true.

Lemma Dmin_plus_l :
 forall d d' d'' : D,
 Dplus (Dmin d d') d'' = Dmin (Dplus d d'') (Dplus d' d'').

Lemma Dmin_plus_r :
 forall d d' d'' : D,
 Dplus d'' (Dmin d d') = Dmin (Dplus d'' d) (Dplus d'' d').

Lemma Dle_neg : forall d : D, Dle Dz d = true -> Dle (Dneg d) Dz = true.

Lemma Dle_neg_2 : forall d : D, Dle d Dz = true -> Dle Dz (Dneg d) = true.
 
Lemma Dnotle_not_eq : forall d d' : D, Dle d d' = false -> d <> d'.

Hint Immediate Dnotle_not_eq.

Lemma Dnotle_not_eq_sym : forall d d' : D, Dle d d' = false -> d' <> d.

Hint Immediate Dnotle_not_eq_sym.

Lemma D_dec : forall d d' : D, {d = d'} + {d <> d'}.

Lemma Dnotle_3_cases :
 forall d d' : D, {Dle d d' = false} + {d = d'} + {Dle d' d = false}.

Lemma Dle_noteq_notle :
 forall d d' : D, Dle d' d = true -> d <> d' -> Dle d d' = false.

Lemma Dnotle_not_refl : forall d : D, Dle d d <> false.

Lemma Dnotle_elim :
 forall d d' : D, Dle d' d = false -> Dle d d' = true /\ d <> d'.

Lemma Dnotle_trans :
 forall d d' d'' : D,
 Dle d d' = false -> Dle d' d'' = false -> Dle d d'' = false.

Lemma Dnotle_le_1 : forall d d' : D, Dle d d' = false -> Dle d' d = true.

Lemma Dmin_le_distr_l :
 forall d d' d'' : D, Dle (Dmin d d') d'' = Dle d d'' || Dle d' d''.

Lemma Dmin_choice : forall d d' : D, {Dmin d d' = d} + {Dmin d d' = d'}.

Lemma Dnotle_noteq : forall d d' : D, Dle d d' = false -> d <> d'.

Lemma Dneg_plus :
 forall d d' : D, Dneg (Dplus d d') = Dplus (Dneg d') (Dneg d).

Lemma Dneg_le :
 forall d d' : D, Dle d d' = true -> Dle (Dneg d') (Dneg d) = true.

Lemma Dnotle_plus_mono_1 :
 forall d d' d'' d''' : D,
 Dle d' d = true ->
 Dle d'' d''' = false -> Dle (Dplus d d'') (Dplus d' d''') = false.

Lemma Dnotle_plus_mono :
 forall d d' d'' d''' : D,
 Dle d d' = false ->
 Dle d'' d''' = false -> Dle (Dplus d d'') (Dplus d' d''') = false.

Definition Ddmin (dd dd' : option D) :=
  match dd, dd' with
  | None, _ => dd'
  | _, None => dd
  | Some d, Some d' => Some (Dmin d d')
  end.

Lemma Ddmin_idempotent : forall dd : option D, Ddmin dd dd = dd.

Lemma Ddmin_comm : forall dd dd' : option D, Ddmin dd dd' = Ddmin dd' dd.

Lemma Ddmin_assoc :
 forall dd dd' dd'' : option D,
 Ddmin (Ddmin dd dd') dd'' = Ddmin dd (Ddmin dd' dd'').

Definition Ddle (dd dd' : option D) :=
  match dd, dd' with
  | _, None => true
  | None, _ => false
  | Some d, Some d' => Dle d d'
  end.

Lemma Ddle_refl : forall dd : option D, Ddle dd dd = true.

Lemma Ddle_antisym :
 forall dd dd' : option D,
 Ddle dd dd' = true -> Ddle dd' dd = true -> dd = dd'.

Lemma Ddle_trans :
 forall dd dd' dd'' : option D,
 Ddle dd dd' = true -> Ddle dd' dd'' = true -> Ddle dd dd'' = true.

Lemma Ddle_d_none : forall dd : option D, Ddle dd None = true.

Lemma Ddmin_le_1 : forall dd dd' : option D, Ddle (Ddmin dd dd') dd = true.

Lemma Ddmin_le_2 : forall dd dd' : option D, Ddle (Ddmin dd dd') dd' = true.

Lemma Ddmin_le_3 :
 forall dd dd' dd'' : option D,
 Ddle dd (Ddmin dd' dd'') = true -> Ddle dd dd' = true.

Lemma Ddmin_le_4 :
 forall dd dd' dd'' : option D,
 Ddle dd (Ddmin dd' dd'') = true -> Ddle dd dd'' = true.

Lemma Ddmin_le_distr_l :
 forall dd dd' dd'' : option D,
 Ddle (Ddmin dd dd') dd'' = Ddle dd dd'' || Ddle dd' dd''.

Lemma Ddmin_choice :
 forall dd dd' : option D, {Ddmin dd dd' = dd} + {Ddmin dd dd' = dd'}.

Definition Ddplus (dd : option D) (d' : D) :=
  match dd with
  | Some d => Some (Dplus d d')
  | _ => dd
  end.

Lemma Ddmin_plus_l :
 forall (dd dd' : option D) (d'' : D),
 Ddplus (Ddmin dd dd') d'' = Ddmin (Ddplus dd d'') (Ddplus dd' d'').

Lemma Ddle_plus_mono :
 forall (dd dd' : option D) (d d' : D),
 Ddle dd dd' = true ->
 Dle d d' = true -> Ddle (Ddplus dd d) (Ddplus dd' d') = true.

Lemma Ddplus_reg_r :
 forall (dd dd' : option D) (d'' : D),
 Ddle (Ddplus dd d'') (Ddplus dd' d'') = true -> Ddle dd dd' = true.

Definition CGraph1 := Map (Map D).

Definition CGraph := option CGraph1.

Section CGDist.

    Variable cg : CGraph1.

Definition CG_edge (x y : ad) :=
  match MapGet _ cg x with
  | Some edges =>
      match MapGet _ edges y with
      | Some d => Some d
      | _ => None
      end
  | _ => None
  end.

Definition CGsat (rho : ad -> D) :=
  forall (x y : ad) (d : D),
  CG_edge x y = Some d -> Dle (rho x) (Dplus (rho y) d) = true.

Definition CGconsistent := sig CGsat. 

Inductive CG_path (last : ad) : D -> list ad -> Set :=
  | CG_p1 : forall x : ad, x = last -> CG_path last Dz (x :: nil)
  | CG_p2 :
      forall (x y : ad) (l : list ad) (d : D),
      CG_path last d (y :: l) ->
      forall d' : D,
      CG_edge x y = Some d' -> CG_path last (Dplus d d') (x :: y :: l).

Definition first (l : list ad) : ad :=
  match l with
  | nil => N0
  | x :: _ => x
  end.

Lemma CG_path_head :
 forall (l : list ad) (last : ad) (d : D),
 CG_path last d l ->
 forall rho : ad -> D,
 CGsat rho -> Dle (rho (first l)) (Dplus (rho last) d) = true.

Lemma CG_path_correct :
 forall (l : list ad) (x last : ad) (d : D),
 CG_path last d (x :: l) ->
 forall rho : ad -> D, CGsat rho -> Dle (rho x) (Dplus (rho last) d) = true.

Theorem CG_circuit_correct :
 forall (x : ad) (d : D) (l : list ad),
 CG_path x d (x :: l) -> Dle Dz d = false -> CGconsistent -> False.

Section CGConsistent.

      Variable P : CGconsistent.

Lemma CG_circuits_non_negative_weight :
 forall (x : ad) (d : D) (l : list ad),
 CG_path x d (x :: l) -> Dle Dz d = true.

End CGConsistent.

Section CGNoBadCycles.

      Variable
        no_bad_cycles :
          forall (x : ad) (d : D) (l : list ad),
          CG_path x d (x :: l) -> Dle Dz d = true.

Lemma CG_edge_in_cg_1 :
 forall (x y : ad) (d : D),
 CG_edge x y = Some d -> in_FSet x (MapDom _ cg) = true.

Lemma CG_path_in_cg_1 :
 forall (l : list ad) (last : ad) (d : D),
 CG_path last d l -> MapSubset _ _ (Elems l) (MapPut _ (MapDom _ cg) last tt).

Lemma CG_path_last :
 forall (l : list ad) (last : ad) (d : D),
 CG_path last d l -> {l' : list ad | l = l' ++ last :: nil}.

Lemma ad_simple_path_bounded_card :
 forall (l : list ad) (last x : ad) (d : D),
 CG_path last d (x :: l) ->
 ad_list_stutters (x :: l) = false -> length (x :: l) <= S (MapCard _ cg).

Lemma CG_path_app_1 :
 forall (l1 l2 : list ad) (last x : ad) (d1 d2 : D),
 CG_path last d2 (x :: l2) ->
 CG_path x d1 l1 -> CG_path last (Dplus d2 d1) (l1 ++ l2).

Lemma CG_path_app_2 :
 forall (l1 l2 : list ad) (last x : ad) (d : D),
 CG_path last d (l1 ++ x :: l2) -> {d2 : D &  CG_path last d2 (x :: l2)}.

Lemma CG_path_app_3 :
 forall (l1 l2 : list ad) (last x : ad) (d : D),
 CG_path last d (l1 ++ x :: l2) -> {d1 : D &  CG_path x d1 (l1 ++ x :: nil)}.

Lemma CG_path_weight_and_last_unique :
 forall (l : list ad) (last last' : ad) (d d' : D),
 CG_path last d l -> CG_path last' d' l -> d = d' /\ last = last'.

    Inductive and_sp (A : Set) (B : Prop) : Set :=
        conj_sp : A -> B -> and_sp A B.

Lemma ad_path_then_simple_path :
 forall (l : list ad) (last : ad) (d : D),
 CG_path last d l ->
 {sl : list ad & 
 {d0 : D & 
 and_sp (CG_path last d0 (first l :: sl))
   (ad_list_stutters (first l :: sl) = false /\ Dle d0 d = true)}}.

Lemma CG_path_app_4 :
 forall (l1 l2 : list ad) (last x : ad) (d : D),
 CG_path last d (l1 ++ x :: l2) ->
 {d1 : D & 
 {d2 : D & 
 and_sp (CG_path x d1 (l1 ++ x :: nil) * CG_path last d2 (x :: l2))
   (d = Dplus d2 d1)}}.

Fixpoint ad_simple_path_naive_search (x y : ad) (l : list ad) 
 (n : nat) {struct n} : bool :=
  Neqb x y
  || match n with
     | O => false
     | S n' =>
         match MapGet _ cg x with
         | None => false
         | Some edges =>
             let l' := x :: l in 
             match
               MapSweep D
                 (fun (z : ad) (d : D) =>
                  if ad_in_list z l'
                  then false
                  else ad_simple_path_naive_search z y l' n') edges
             with
             | None => false
             | Some _ => true
             end
         end
     end.

Lemma ad_simple_path_naive_search_correct_1 :
 forall (n : nat) (x y : ad) (l : list ad) (d : D),
 length l <= n ->
 CG_path y d (x :: l) ->
 forall prefix : list ad,
 ad_list_stutters (rev prefix ++ x :: l) = false ->
 ad_simple_path_naive_search x y prefix n = true.

Lemma ad_simple_path_naive_search_correct :
 forall (n : nat) (x y : ad) (l : list ad) (d : D),
 length l <= n ->
 CG_path y d (x :: l) ->
 ad_list_stutters (x :: l) = false ->
 ad_simple_path_naive_search x y nil n = true.

Lemma ad_simple_path_naive_search_complete_1 :
 forall (n : nat) (x y : ad) (prefix : list ad) (d' : D),
 CG_path x d' (rev (x :: prefix)) ->
 ad_list_stutters (x :: prefix) = false ->
 ad_simple_path_naive_search x y prefix n = true ->
 {d : D & 
 {l : list ad & 
 and_sp (CG_path y d (rev (x :: prefix) ++ l))
   (ad_list_stutters (rev (x :: prefix) ++ l) = false)}}.

Lemma ad_simple_path_naive_search_complete :
 forall (n : nat) (x y : ad),
 ad_simple_path_naive_search x y nil n = true ->
 {d : D & 
 {l : list ad & 
 and_sp (CG_path y d (x :: l)) (ad_list_stutters (x :: l) = false)}}.

Definition CG_simple_path (last : ad) (d : D) (l : list ad) :=
  and_sp (CG_path last d l) (ad_list_stutters l = false).

Lemma ad_simple_path_dec :
 forall x y : ad,
 {l : list ad &  {d : D &  CG_simple_path y d (x :: l)}} +
 {(forall (l : list ad) (d : D), CG_simple_path y d (x :: l) -> False)}.

Definition all_min (f : ad -> D -> option D) := MapFold _ _ None Ddmin f.

Lemma all_min_le_1 :
 forall (f : ad -> D -> option D) (m : Map D) (a : ad) (d : D),
 MapGet _ m a = Some d -> Ddle (all_min f m) (f a d) = true.

Lemma all_min_le_2_1 :
 forall (f : ad -> D -> option D) (m : Map D) (pf : ad -> ad) (d : D),
 MapFold1 _ _ None Ddmin f pf m = Some d ->
 {a : ad &  {d' : D | MapGet _ m a = Some d' /\ f (pf a) d' = Some d}}.

Lemma all_min_le_2 :
 forall (f : ad -> D -> option D) (m : Map D) (d : D),
 all_min f m = Some d ->
 {a : ad &  {d' : D | MapGet _ m a = Some d' /\ f a d' = Some d}}.

Lemma all_min_le_3 :
 forall (f g : ad -> D -> option D) (m : Map D),
 (forall (a : ad) (d : D),
  MapGet _ m a = Some d -> Ddle (f a d) (g a d) = true) ->
 Ddle (all_min f m) (all_min g m) = true.

Fixpoint ad_simple_path_dist_1 (x y : ad) (l : list ad) 
 (n : nat) {struct n} : option D :=
  if Neqb x y
  then Some Dz
  else
   match n with
   | O => None
   | S n' =>
       match MapGet _ cg x with
       | None => None
       | Some edges =>
           let l' := x :: l in 
           all_min
             (fun (z : ad) (d : D) =>
              if ad_in_list z l'
              then None
              else Ddplus (ad_simple_path_dist_1 z y l' n') d) edges
       end
   end.

Lemma ad_simple_path_dist_1_correct_1 :
 forall (n : nat) (x y : ad) (l : list ad) (d : D),
 length l <= n ->
 CG_path y d (x :: l) ->
 forall prefix : list ad,
 ad_list_stutters (rev prefix ++ x :: l) = false ->
 Ddle (ad_simple_path_dist_1 x y prefix n) (Some d) = true.

Lemma ad_simple_path_dist_1_correct_2 :
 forall (n : nat) (x y : ad) (l : list ad) (d : D),
 length l <= n ->
 CG_path y d (x :: l) ->
 ad_list_stutters (x :: l) = false ->
 Ddle (ad_simple_path_dist_1 x y nil n) (Some d) = true.

Definition ad_simple_path_dist (x y : ad) :=
  ad_simple_path_dist_1 x y nil (MapCard _ cg).

Lemma ad_simple_path_dist_correct_1 :
 forall (x y : ad) (l : list ad) (d : D),
 CG_path y d (x :: l) ->
 ad_list_stutters (x :: l) = false ->
 Ddle (ad_simple_path_dist x y) (Some d) = true.

Lemma ad_simple_path_dist_correct :
 forall (x y : ad) (l : list ad) (d : D),
 CG_path y d (x :: l) -> Ddle (ad_simple_path_dist x y) (Some d) = true.

Lemma ad_simple_path_dist_1_complete_1 :
 forall (n : nat) (x y : ad) (prefix : list ad) (d' : D),
 CG_path x d' (rev (x :: prefix)) ->
 ad_list_stutters (x :: prefix) = false ->
 forall d0 : D,
 ad_simple_path_dist_1 x y prefix n = Some d0 ->
 {l : list ad & 
 and_sp (CG_path y (Dplus d0 d') (rev (x :: prefix) ++ l))
   (ad_list_stutters (rev (x :: prefix) ++ l) = false /\ length l <= n)}.

Lemma ad_simple_path_dist_1_complete :
 forall (n : nat) (x y : ad) (d : D),
 ad_simple_path_dist_1 x y nil n = Some d ->
 {l : list ad & 
 and_sp (CG_path y d (x :: l)) (ad_list_stutters (x :: l) = false)}.

Lemma ad_simple_path_dist_complete :
 forall (x y : ad) (d : D),
 ad_simple_path_dist x y = Some d ->
 {l : list ad & 
 and_sp (CG_path y d (x :: l)) (ad_list_stutters (x :: l) = false)}.

Lemma ad_simple_path_dist_complete_2 :
 forall (x y : ad) (d : D),
 ad_simple_path_dist x y = Some d -> {l : list ad &  CG_path y d (x :: l)}.

Lemma ad_simple_path_dist_complete_3 :
 forall (x y : ad) (dd : option D),
 (forall (l : list ad) (d : D),
  CG_path y d (x :: l) -> Ddle dd (Some d) = true) ->
 Ddle dd (ad_simple_path_dist x y) = true.

Lemma ad_simple_path_dist_d_1 :
 forall x : ad, ad_simple_path_dist x x = Some Dz.

Lemma ad_simple_path_dist_d_2 :
 forall (x y z : ad) (d d' : D),
 ad_simple_path_dist x y = Some d ->
 ad_simple_path_dist y z = Some d' ->
 Ddle (ad_simple_path_dist x z) (Some (Dplus d' d)) = true.

Lemma ad_simple_path_dist_d_3 :
 forall (x y z : ad) (d d' : D),
 Ddle (ad_simple_path_dist x y) (Some d) = true ->
 Ddle (ad_simple_path_dist y z) (Some d') = true ->
 Ddle (ad_simple_path_dist x z) (Some (Dplus d' d)) = true.

Definition CG_leq (x y : ad) :=
  match ad_simple_path_dist x y with
  | Some _ => true
  | _ => false
  end.

Lemma CG_leq_refl : forall x : ad, CG_leq x x = true.

Lemma CG_leq_trans :
 forall x y z : ad,
 CG_leq x y = true -> CG_leq y z = true -> CG_leq x z = true.

Definition CG_standard_rho (root : ad) (d0 : D) (others : ad -> D)
  (x : ad) :=
  match ad_simple_path_dist root x with
  | Some d => Dplus d0 (Dneg d)
  | None => others x 
  end.

Lemma CG_standard_rho_root :
 forall (root : ad) (d0 : D) (others : ad -> D),
 CG_standard_rho root d0 others root = d0.

Lemma CG_rooted_sat_1 :
 forall (root : ad) (d0 : D) (others : ad -> D),
 (forall x : ad, in_dom _ x cg = true -> CG_leq root x = true) ->
 CGsat (CG_standard_rho root d0 others).

Lemma CG_rooted_sat :
 forall (root : ad) (d0 : D),
 (forall x : ad, in_dom _ x cg = true -> CG_leq root x = true) ->
 {rho : ad -> D | CGsat rho /\ rho root = d0}.

Lemma CG_standard_rho_minimal :
 forall (root : ad) (d0 : D) (others rho : ad -> D),
 CGsat rho ->
 Dle d0 (rho root) = true ->
 forall x : ad,
 CG_leq root x = true ->
 Dle (CG_standard_rho root d0 others x) (rho x) = true.

Lemma CG_sat_add_1 :
 forall (x y : ad) (d : D) (rho : ad -> D),
 CGsat rho ->
 Dle (rho x) (Dplus (rho y) d) = true ->
 Ddle (Some (Dneg d)) (ad_simple_path_dist y x) = true.

    End CGNoBadCycles.

Definition CG_add (x y : ad) (d : D) :=
  match MapGet _ cg x with
  | None => MapPut _ cg x (M1 _ y d)
  | Some edges =>
      match MapGet _ edges y with
      | None => MapPut _ cg x (MapPut _ edges y d)
      | Some d0 => MapPut _ cg x (MapPut _ edges y (Dmin d d0))
      end
  end.

End CGDist.

Section CGAdd.

    Variable cg1 : CGraph1.

    Variable x y : ad.
    Variable d : D.

Definition cg2 := CG_add cg1 x y d.

Lemma CG_add_edge_1 :
 forall x0 y0 : ad,
 CG_edge cg2 x0 y0 =
 (if Neqb x x0 && Neqb y y0
  then Ddmin (Some d) (CG_edge cg1 x0 y0)
  else CG_edge cg1 x0 y0).

Lemma CG_add_edge_2 :
 forall x0 y0 : ad, Ddle (CG_edge cg2 x0 y0) (CG_edge cg1 x0 y0) = true.

Lemma CG_add_1 :
 forall rho : ad -> D,
 CGsat cg1 rho -> Dle (rho x) (Dplus (rho y) d) = true -> CGsat cg2 rho.

Lemma CG_add_2 : forall rho : ad -> D, CGsat cg2 rho -> CGsat cg1 rho.

Lemma CG_add_3 :
 forall rho : ad -> D, CGsat cg2 rho -> Dle (rho x) (Dplus (rho y) d) = true.

Lemma CG_add_4_1 :
 forall (l : list ad) (x0 y0 : ad) (d0 : D),
 CG_path cg2 y0 d0 (x0 :: l) ->
 {l0 : list ad &  {l1 : list ad | x0 :: l = l0 ++ x :: y :: l1}} +
 CG_path cg1 y0 d0 (x0 :: l).

Lemma CG_add_4_2 :
 forall (l : list ad) (last : ad) (d0 : D),
 CG_path cg2 last d0 l -> ad_in_list y l = false -> CG_path cg1 last d0 l.

Lemma CG_add_4_3 :
 forall (x0 : ad) (d0 : D) (l : list ad),
 ad_list_stutters (y :: l) = false ->
 CG_path cg2 x0 d0 (y :: l) -> CG_path cg1 x0 d0 (y :: l).

Lemma CG_add_4_4 :
 forall (l : list ad) (last : ad) (d0 : D),
 CG_path cg2 last d0 l -> ad_in_list x l = false -> CG_path cg1 last d0 l.

Lemma CG_add_4_5 :
 forall (d0 : D) (l : list ad),
 ad_list_stutters (l ++ x :: nil) = false ->
 CG_path cg2 x d0 (l ++ x :: nil) -> CG_path cg1 x d0 (l ++ x :: nil).

Lemma CG_add_4 :
 (forall (x0 : ad) (d0 : D) (l : list ad),
  CG_path cg1 x0 d0 (x0 :: l) -> Dle Dz d0 = true) ->
 Ddle (Some (Dneg d)) (ad_simple_path_dist cg1 y x) = true ->
 forall (x0 : ad) (d0 : D) (l : list ad),
 CG_path cg2 x0 d0 (x0 :: l) ->
 ad_list_stutters l = false -> Dle Dz d0 = true.

Lemma CG_add_5_1 :
 forall n : nat,
 (forall (x0 : ad) (d0 : D) (l : list ad),
  CG_path cg1 x0 d0 (x0 :: l) -> Dle Dz d0 = true) ->
 Ddle (Some (Dneg d)) (ad_simple_path_dist cg1 y x) = true ->
 forall (x0 : ad) (d0 : D) (l : list ad),
 CG_path cg2 x0 d0 (x0 :: l) -> length l <= n -> Dle Dz d0 = true.

Lemma CG_add_5 :
 (forall (x0 : ad) (d0 : D) (l : list ad),
  CG_path cg1 x0 d0 (x0 :: l) -> Dle Dz d0 = true) ->
 Ddle (Some (Dneg d)) (ad_simple_path_dist cg1 y x) = true ->
 forall (x0 : ad) (d0 : D) (l : list ad),
 CG_path cg2 x0 d0 (x0 :: l) -> Dle Dz d0 = true.

  End CGAdd.

Definition cg_range := DMerge D.

Lemma cg_range_1 :
 forall (cg : CGraph1) (x y : ad) (d : D),
 CG_edge cg x y = Some d -> in_dom D y (cg_range cg) = true.

Lemma cg_range_2 :
 forall (cg : CGraph1) (y : ad),
 in_dom D y (cg_range cg) = true ->
 {x : ad &  {d : D | CG_edge cg x y = Some d}}.

Lemma cg_range_4 :
 forall (cg : CGraph1) (x y : ad) (d : D) (a : ad),
 in_dom D a (cg_range (CG_add cg x y d)) =
 Neqb a y || in_dom D a (cg_range cg).

Lemma cg_out_of_range_1 :
 forall (cg : CGraph1) (y : ad),
 in_dom D y (cg_range cg) = false -> forall x : ad, CG_edge cg x y = None.

Lemma cg_out_of_range_2 :
 forall (cg : CGraph1) (y : ad),
 in_dom D y (cg_range cg) = false ->
 forall x : ad, Neqb x y = false -> ad_simple_path_dist cg x y = None.

Lemma cg_out_of_range_3 :
 forall (cg : CGraph1) (y : ad),
 in_dom D y (cg_range cg) = false ->
 forall x : ad, Neqb x y = false -> CG_leq cg x y = false.

Lemma cg_add_out_of_range_1 :
 forall (cg : CGraph1) (x y : ad) (d : D),
 (forall (x0 : ad) (d0 : D) (l : list ad),
  CG_path cg x0 d0 (x0 :: l) -> Dle Dz d0 = true) ->
 in_dom D x (cg_range cg) = false ->
 Neqb y x = false ->
 forall (x0 : ad) (d0 : D) (l : list ad),
 CG_path (CG_add cg x y d) x0 d0 (x0 :: l) -> Dle Dz d0 = true.

Lemma cg_add_dom_subset :
 forall (cg : CGraph1) (x y : ad) (d : D),
 MapSubset _ _ (MapDom _ cg) (MapDom _ (CG_add cg x y d)).

Fixpoint CG_add_root (root : ad) (cg : CGraph1) (l : list ad) {struct l} :
 CGraph1 :=
  match l with
  | nil => cg
  | x :: l' => CG_add_root root (CG_add cg root x Dz) l'
  end.

Lemma CG_add_root_out_of_range :
 forall (l : list ad) (cg : CGraph1) (root : ad),
 (forall (x0 : ad) (d0 : D) (l : list ad),
  CG_path cg x0 d0 (x0 :: l) -> Dle Dz d0 = true) ->
 MapSubset _ _ (Elems l) (MapDom _ cg) ->
 ad_in_list root l = false ->
 in_dom _ root (cg_range cg) = false ->
 forall (x0 : ad) (d0 : D) (l0 : list ad),
 CG_path (CG_add_root root cg l) x0 d0 (x0 :: l0) -> Dle Dz d0 = true.

Lemma CG_add_rooted_1 :
 forall (cg : CGraph1) (root a : ad) (d : D),
 CG_edge cg root a = None -> CG_edge (CG_add cg root a d) root a = Some d.

Lemma CG_add_root_rooted_1 :
 forall (l : list ad) (cg : CGraph1) (root a : ad),
 ad_list_stutters l = false ->
 ad_in_list a l = false ->
 forall d : D,
 CG_edge cg root a = Some d ->
 CG_edge (CG_add_root root cg l) root a = Some d.

Lemma CG_add_root_rooted_2 :
 forall (l : list ad) (cg : CGraph1) (root : ad),
 ad_list_stutters l = false ->
 (forall a0 : ad, ad_in_list a0 l = true -> CG_edge cg root a0 = None) ->
 forall a : ad,
 ad_in_list a l = true -> CG_edge (CG_add_root root cg l) root a = Some Dz.
 
Lemma CG_add_root_rooted_3 :
 forall (cg : CGraph1) (root : ad),
 in_dom _ root cg = false ->
 forall a : ad,
 in_dom _ a cg = true ->
 CG_edge (CG_add_root root cg (ad_list_of_dom _ cg)) root a = Some Dz.

Lemma CG_add_root_rooted_4 :
 forall (l : list ad) (cg : CGraph1) (root a : ad),
 in_dom _ a (CG_add_root root cg l) = true ->
 {a = root} + {in_dom _ a cg = true}.

Lemma CG_edge_dist_some_1 :
 forall (n : nat) (cg : CGraph1) (x y : ad) (d : D) (prefix : list ad),
 CG_edge cg x y = Some d ->
 ad_in_list y prefix = false ->
 {d' : D |
 Ddle (ad_simple_path_dist_1 cg x y prefix (S n)) (Some d') = true}.

Lemma CG_edge_dist_some :
 forall (cg : CGraph1) (x y : ad) (d : D),
 CG_edge cg x y = Some d ->
 {d' : D | ad_simple_path_dist cg x y = Some d'}.

Lemma CG_add_root_rooted :
 forall (cg : CGraph1) (root : ad),
 (forall (x : ad) (d : D) (l : list ad),
  CG_path cg x d (x :: l) -> Dle Dz d = true) ->
 in_dom _ root cg = false ->
 forall a : ad,
 in_dom _ a (CG_add_root root cg (ad_list_of_dom _ cg)) = true ->
 CG_leq (CG_add_root root cg (ad_list_of_dom _ cg)) root a = true.

Lemma CG_add_sat :
 forall (cg : CGraph1) (root a : ad) (d : D) (rho : ad -> D),
 CGsat (cg2 cg root a d) rho -> CGsat cg rho.

Lemma CG_add_root_sat :
 forall (l : list ad) (cg : CGraph1) (root : ad) (rho : ad -> D),
 CGsat (CG_add_root root cg l) rho -> CGsat cg rho.

Lemma CG_add_root_consistent :
 forall (l : list ad) (cg : CGraph1) (root : ad),
 CGconsistent (CG_add_root root cg l) -> CGconsistent cg.

Lemma CG_circuit_complete_1 :
 forall cg : CGraph1,
 (forall (x : ad) (d : D) (l : list ad),
  CG_path cg x d (x :: l) -> Dle Dz d = true) ->
 forall root : ad,
 root = ad_alloc_opt unit (FSetUnion (MapDom _ cg) (MapDom _ (cg_range cg))) ->
 forall cg' : CGraph1,
 cg' = CG_add_root root cg (ad_list_of_dom _ cg) -> CGconsistent cg.

Theorem CG_circuit_complete :
 forall cg : CGraph1,
 (forall (x : ad) (d : D) (l : list ad),
  CG_path cg x d (x :: l) -> Dle Dz d = true) -> CGconsistent cg.

Lemma CG_translate_l :
 forall (cg : CGraph1) (rho : ad -> D) (d : D),
 CGsat cg rho -> CGsat cg (fun a : ad => Dplus d (rho a)).

Definition CGconsistent_anchored (cg : CGraph1) (a : ad) 
  (d0 : D) := {rho : ad -> D | CGsat cg rho /\ rho a = d0}.

Lemma CGconsistent_then_anchored :
 forall cg : CGraph1,
 CGconsistent cg -> forall (a : ad) (d0 : D), CGconsistent_anchored cg a d0.

Lemma CGanchored_then_consistent :
 forall (cg : CGraph1) (a : ad) (d0 : D),
 CGconsistent_anchored cg a d0 -> CGconsistent cg.

Section CGDist1.

    Variable cg : CGraph1.

Fixpoint ad_0_path_dist_1 (x y : ad) (l : list ad) 
 (n : nat) {struct n} : option D :=
  if Neqb x y
  then Some Dz
  else
   match n with
   | O => None
   | S n' =>
       match MapGet _ cg x with
       | None => None
       | Some edges =>
           if ad_in_list x l
           then None
           else
            let l' := x :: l in 
            all_min
              (fun (z : ad) (d : D) =>
               if ad_in_list z l'
               then None
               else Ddplus (ad_0_path_dist_1 z y l' n') d) edges
       end
   end.

Definition ad_0_path_dist (x y : ad) :=
  ad_0_path_dist_1 x y nil (MapCard _ cg).

Lemma ad_0_path_dist_1_ge :
 forall (n : nat) (l : list ad) (x y : ad),
 Ddle (ad_simple_path_dist_1 cg x y l n) (ad_0_path_dist_1 x y l n) = true.

Lemma ad_0_path_dist_1_correct_1 :
 (forall (x : ad) (d : D) (l : list ad),
  CG_path cg x d (x :: l) -> Dle Dz d = true) ->
 forall (n : nat) (x y : ad) (l : list ad) (d : D),
 length l <= n ->
 CG_path cg y d (x :: l) ->
 forall prefix : list ad,
 ad_list_stutters (rev prefix ++ x :: l) = false ->
 Ddle (ad_0_path_dist_1 x y prefix n) (Some d) = true.

Lemma ad_0_path_dist_1_le :
 (forall (x : ad) (d : D) (l : list ad),
  CG_path cg x d (x :: l) -> Dle Dz d = true) ->
 forall (n : nat) (x y : ad),
 Ddle (ad_0_path_dist_1 x y nil n) (ad_simple_path_dist_1 cg x y nil n) =
 true.

Lemma ad_0_path_dist_correct_1 :
 CGconsistent cg ->
 forall (x y : ad) (n : nat),
 ad_0_path_dist_1 x y nil n = ad_simple_path_dist_1 cg x y nil n.

Lemma ad_0_path_dist_correct :
 CGconsistent cg ->
 forall x y : ad, ad_0_path_dist x y = ad_simple_path_dist cg x y.

Fixpoint ad_1_path_dist_1 (x y : ad) (s : FSet) (n : nat) {struct n} :
 option D :=
  if Neqb x y
  then Some Dz
  else
   match n with
   | O => None
   | S n' =>
       match MapGet _ cg x with
       | None => None
       | Some edges =>
           match MapGet _ s x with
           | Some _ => None
           | None =>
               let s' := MapPut unit s x tt in
               all_min
                 (fun (z : ad) (d : D) =>
                  match MapGet _ s' z with
                  | Some _ => None
                  | None => Ddplus (ad_1_path_dist_1 z y s' n') d
                  end) edges
           end
       end
   end.

Definition ad_1_path_dist (x y : ad) :=
  ad_1_path_dist_1 x y (M0 unit) (MapCard _ cg).

Lemma ad_1_path_dist_correct_1 :
 forall (n : nat) (x y : ad) (l : list ad),
 ad_1_path_dist_1 x y (Elems l) n = ad_0_path_dist_1 x y l n.

Lemma ad_1_path_dist_correct_2 :
 forall x y : ad, ad_1_path_dist x y = ad_0_path_dist x y.

Lemma ad_1_path_dist_correct_3 :
 CGconsistent cg ->
 forall (n : nat) (x y : ad),
 ad_1_path_dist_1 x y (M0 unit) n = ad_simple_path_dist_1 cg x y nil n.

Lemma ad_1_path_dist_correct :
 CGconsistent cg ->
 forall x y : ad, ad_1_path_dist x y = ad_simple_path_dist cg x y.

Lemma ad_1_path_dist_big_enough_1 :
 forall (n : nat) (s : FSet),
 MapSubset _ _ s (MapDom _ cg) ->
 MapCard _ cg <= n + MapCard _ s ->
 forall x y : ad, ad_1_path_dist_1 x y s n = ad_1_path_dist_1 x y s (S n).

Lemma ad_1_path_dist_big_enough_2 :
 forall (n : nat) (x y : ad),
 ad_1_path_dist x y = ad_1_path_dist_1 x y (M0 unit) (n + MapCard _ cg).

Lemma ad_1_path_dist_big_enough :
 forall n : nat,
 MapCard _ cg <= n ->
 forall x y : ad, ad_1_path_dist x y = ad_1_path_dist_1 x y (M0 unit) n.

End CGDist1.

Inductive CGForm : Set :=
  | CGleq : ad -> ad -> D -> CGForm
  | CGeq : ad -> ad -> D -> CGForm
  | CGand : CGForm -> CGForm -> CGForm
  | CGor : CGForm -> CGForm -> CGForm
  | CGimp : CGForm -> CGForm -> CGForm
  | CGnot : CGForm -> CGForm.

Fixpoint CGeval (rho : ad -> D) (f : CGForm) {struct f} : Prop :=
  match f with
  | CGleq x y d => Dle (rho x) (Dplus (rho y) d) = true
  | CGeq x y d => rho x = Dplus (rho y) d
  | CGand f0 f1 => CGeval rho f0 /\ CGeval rho f1
  | CGor f0 f1 => CGeval rho f0 \/ CGeval rho f1
  | CGimp f0 f1 => CGeval rho f0 -> CGeval rho f1
  | CGnot f0 => ~ CGeval rho f0
  end.

Lemma CGeval_dec :
 forall (f : CGForm) (rho : ad -> D), {CGeval rho f} + {~ CGeval rho f}.

Inductive CGSForm : Set :=
  | CGSleq : ad -> ad -> D -> CGSForm
  | CGSand : CGSForm -> CGSForm -> CGSForm
  | CGSor : CGSForm -> CGSForm -> CGSForm.

Fixpoint CG_of_CGS (fs : CGSForm) : CGForm :=
  match fs with
  | CGSleq x y d => CGleq x y d
  | CGSand fs0 fs1 => CGand (CG_of_CGS fs0) (CG_of_CGS fs1)
  | CGSor fs0 fs1 => CGor (CG_of_CGS fs0) (CG_of_CGS fs1)
  end.

Definition CGSeval (rho : ad -> D) (fs : CGSForm) :=
  CGeval rho (CG_of_CGS fs).

Section CGSSolve.

    Variable anchor : ad.
    Variable anchor_value : D.

Definition CG_test_ineq (cg : CGraph1) (n : nat) (x y : ad) 
  (d : D) := Ddle (Some (Dneg d)) (ad_1_path_dist_1 cg y x (M0 unit) n).

    Variable def_answer : bool.

Fixpoint CGS_solve_1 (cg : CGraph1) (n : nat) (fsl : list CGSForm)
 (gas : nat) {struct gas} : bool :=
  match gas with
  | O => def_answer
  | S gas' =>
      match fsl with
      | nil => true
      | fs :: fsl' =>
          match fs with
          | CGSleq x y d =>
              if CG_test_ineq cg n x y d
              then
               let cg' := CG_add cg x y d in CGS_solve_1 cg' (S n) fsl' gas'
              else false
          | CGSand fs0 fs1 => CGS_solve_1 cg n (fs0 :: fs1 :: fsl') gas'
          | CGSor fs0 fs1 =>
              if CGS_solve_1 cg n (fs0 :: fsl') gas'
              then true
              else CGS_solve_1 cg n (fs1 :: fsl') gas'
          end
      end
  end.

Fixpoint FSize (f : CGSForm) : nat :=
  match f with
  | CGSand f0 f1 => S (FSize f0 + FSize f1)
  | CGSor f0 f1 => S (FSize f0 + FSize f1)
  | _ => 1
  end.

Fixpoint FlSize (fsl : list CGSForm) : nat :=
  match fsl with
  | nil => 0
  | fs :: fsl' => FSize fs + FlSize fsl'
  end.

Definition CGS_solve (fs : CGSForm) :=
  CGS_solve_1 (M0 _) 0 (fs :: nil) (S (FSize fs)).

Fixpoint CGSeval_l (rho : ad -> D) (fsl : list CGSForm) {struct fsl} :
 Prop :=
  match fsl with
  | nil => True
  | fs :: fsl' => CGSeval rho fs /\ CGSeval_l rho fsl'
  end.

Lemma FSize_geq_1 : forall fs : CGSForm, {n : nat | FSize fs = S n}.

Lemma FlSize_is_O : forall fsl : list CGSForm, FlSize fsl = 0 -> fsl = nil.

Lemma CG_add_card_le :
 forall (cg : CGraph1) (x y : ad) (d : D) (n : nat),
 MapCard _ cg <= n -> MapCard _ (CG_add cg x y d) <= S n.

Lemma CGS_solve_1_correct :
 forall (gas : nat) (fsl : list CGSForm) (cg : CGraph1) (n : nat),
 CGconsistent cg ->
 MapCard _ cg <= n ->
 FlSize fsl < gas ->
 CGS_solve_1 cg n fsl gas = true ->
 {rho : ad -> D | CGSeval_l rho fsl /\ CGsat cg rho}.

Lemma CGS_solve_correct :
 forall fs : CGSForm, CGS_solve fs = true -> {rho : ad -> D | CGSeval rho fs}.

Lemma CGS_translate_l :
 forall (fs : CGSForm) (rho : ad -> D) (d : D),
 CGSeval rho fs -> CGSeval (fun a : ad => Dplus d (rho a)) fs.

Lemma CGS_solve_correct_anchored :
 forall fs : CGSForm,
 CGS_solve fs = true ->
 {rho : ad -> D | CGSeval rho fs /\ rho anchor = anchor_value}.

Lemma CGS_solve_complete_1 :
 forall (gas : nat) (fsl : list CGSForm) (cg : CGraph1) (n : nat),
 FlSize fsl < gas ->
 MapCard _ cg <= n ->
 forall rho : ad -> D,
 CGsat cg rho -> CGSeval_l rho fsl -> CGS_solve_1 cg n fsl gas = true.

Lemma CGS_solve_complete :
 forall (fs : CGSForm) (rho : ad -> D), CGSeval rho fs -> CGS_solve fs = true.

Definition CGSeq (x y : ad) (d : D) :=
  CGSand (CGSleq x y d) (CGSleq y x (Dneg d)).

Lemma CGSeq_correct :
 forall (x y : ad) (d : D) (rho : ad -> D),
 CGSeval rho (CGSeq x y d) -> rho x = Dplus (rho y) d.

Lemma CGSeq_complete :
 forall (x y : ad) (d : D) (rho : ad -> D),
 rho x = Dplus (rho y) d -> CGSeval rho (CGSeq x y d).

End CGSSolve.

Section CGWithOne.

    Variable Done : D.
    Variable Done_pos : Dle Done Dz = false.
    Variable
      Done_min_pos : forall d : D, Dle d Dz = false -> Dle Done d = true.

Fixpoint CGSnot (fs : CGSForm) : CGSForm :=
  match fs with
  | CGSleq x y d => CGSleq y x (Dneg (Dplus d Done))
  | CGSand f0 f1 => CGSor (CGSnot f0) (CGSnot f1)
  | CGSor f0 f1 => CGSand (CGSnot f0) (CGSnot f1)
  end.

Lemma Dmone_neg : Dle Dz (Dneg Done) = false.

Lemma Dminus_one_1 : forall d : D, Dle d (Dplus d (Dneg Done)) = false.

Lemma Dle_lt_1 :
 forall d d' : D, Dle d' d = false -> Dle d (Dplus d' (Dneg Done)) = true.

Lemma Dle_lt_2 :
 forall d d' : D, Dle d (Dplus d' (Dneg Done)) = true -> Dle d' d = false.

Lemma CGSnot_correct :
 forall (fs : CGSForm) (rho : ad -> D),
 CGSeval rho fs -> ~ CGSeval rho (CGSnot fs).

Lemma CGSnot_complete :
 forall (fs : CGSForm) (rho : ad -> D),
 ~ CGSeval rho (CGSnot fs) -> CGSeval rho fs.

Fixpoint CGFormSimplify (f : CGForm) : CGSForm :=
  match f with
  | CGleq x y d => CGSleq x y d
  | CGeq x y d => CGSeq x y d
  | CGand f0 f1 => CGSand (CGFormSimplify f0) (CGFormSimplify f1)
  | CGor f0 f1 => CGSor (CGFormSimplify f0) (CGFormSimplify f1)
  | CGimp f0 f1 => CGSor (CGSnot (CGFormSimplify f0)) (CGFormSimplify f1)
  | CGnot f0 => CGSnot (CGFormSimplify f0)
  end.

Lemma CGFormSimplify_correct :
 forall (f : CGForm) (rho : ad -> D),
 CGeval rho f <-> CGSeval rho (CGFormSimplify f).

Definition CG_solve (f : CGForm) := CGS_solve false (CGFormSimplify f).

Theorem CG_solve_correct :
 forall f : CGForm, CG_solve f = true -> {rho : ad -> D | CGeval rho f}.

Theorem CG_solve_correct_anchored :
 forall (anchor : ad) (anchor_value : D) (f : CGForm),
 CG_solve f = true ->
 {rho : ad -> D | CGeval rho f /\ rho anchor = anchor_value}.

Theorem CG_solve_complete :
 forall (f : CGForm) (rho : ad -> D), CGeval rho f -> CG_solve f = true.

Definition CG_prove (f : CGForm) := negb (CG_solve (CGnot f)).

Theorem CG_prove_correct :
 forall f : CGForm, CG_prove f = true -> forall rho : ad -> D, CGeval rho f.

Theorem CG_prove_complete :
 forall f : CGForm, (forall rho : ad -> D, CGeval rho f) -> CG_prove f = true.

Theorem CG_prove_complete_anchored :
 forall (f : CGForm) (anchor : ad) (anchor_value : D),
 (forall rho : ad -> D, rho anchor = anchor_value -> CGeval rho f) ->
 CG_prove f = true.

  End CGWithOne.

End ConstraintGraphs. *)
Require Import ZArith.
Require Import NArith.
From IntMap Require Import Map.

Inductive ZCGForm : Set :=
  | ZCGle : ad -> ad -> ZCGForm 
  | ZCGge : ad -> ad -> ZCGForm 
  | ZCGlt : ad -> ad -> ZCGForm 
  | ZCGgt : ad -> ad -> ZCGForm 
  | ZCGlep : ad -> ad -> Z -> ZCGForm 
  | ZCGgep : ad -> ad -> Z -> ZCGForm 
  | ZCGltp : ad -> ad -> Z -> ZCGForm 
  | ZCGgtp : ad -> ad -> Z -> ZCGForm 
  | ZCGlem : ad -> ad -> Z -> ZCGForm 
  | ZCGgem : ad -> ad -> Z -> ZCGForm 
  | ZCGltm : ad -> ad -> Z -> ZCGForm 
  | ZCGgtm : ad -> ad -> Z -> ZCGForm 
  | ZCGlepm : ad -> ad -> Z -> Z -> ZCGForm 
  | ZCGgepm : ad -> ad -> Z -> Z -> ZCGForm 
  | ZCGltpm : ad -> ad -> Z -> Z -> ZCGForm 
  | ZCGgtpm : ad -> ad -> Z -> Z -> ZCGForm 
  | ZCGeq : ad -> ad -> ZCGForm 
  | ZCGeqp : ad -> ad -> Z -> ZCGForm 
  | ZCGeqm : ad -> ad -> Z -> ZCGForm 
  | ZCGeqpm : ad -> ad -> Z -> Z -> ZCGForm 
  | ZCGzylem : ad -> Z -> ZCGForm 
  | ZCGzygem : ad -> Z -> ZCGForm 
  | ZCGzyltm : ad -> Z -> ZCGForm 
  | ZCGzygtm : ad -> Z -> ZCGForm 
  | ZCGzylepm : ad -> Z -> Z -> ZCGForm 
  | ZCGzygepm : ad -> Z -> Z -> ZCGForm 
  | ZCGzyltpm : ad -> Z -> Z -> ZCGForm 
  | ZCGzygtpm : ad -> Z -> Z -> ZCGForm 
  | ZCGzyeqm : ad -> Z -> ZCGForm 
  | ZCGzyeqpm : ad -> Z -> Z -> ZCGForm 
  | ZCGxzlep : ad -> Z -> ZCGForm 
  | ZCGxzgep : ad -> Z -> ZCGForm 
  | ZCGxzltp : ad -> Z -> ZCGForm 
  | ZCGxzgtp : ad -> Z -> ZCGForm 
  | ZCGxzlepm : ad -> Z -> Z -> ZCGForm 
  | ZCGxzgepm : ad -> Z -> Z -> ZCGForm 
  | ZCGxzltpm : ad -> Z -> Z -> ZCGForm 
  | ZCGxzgtpm : ad -> Z -> Z -> ZCGForm 
  | ZCGxzeqp : ad -> Z -> ZCGForm 
  | ZCGxzeqpm : ad -> Z -> Z -> ZCGForm 
  | ZCGzzlep : Z -> Z -> ZCGForm 
  | ZCGzzltp : Z -> Z -> ZCGForm 
  | ZCGzzgep : Z -> Z -> ZCGForm 
  | ZCGzzgtp : Z -> Z -> ZCGForm 
  | ZCGzzeq : Z -> Z -> ZCGForm 
  | ZCGand : ZCGForm -> ZCGForm -> ZCGForm
  | ZCGor : ZCGForm -> ZCGForm -> ZCGForm
  | ZCGimp : ZCGForm -> ZCGForm -> ZCGForm
  | ZCGnot : ZCGForm -> ZCGForm
  | ZCGiff : ZCGForm -> ZCGForm -> ZCGForm.

Definition ZCG_eval := CGeval Z Zplus Zle_bool.

Fixpoint ZCGtranslate (f : ZCGForm) : CGForm Z :=
  match f with
  | ZCGle x y => CGleq Z x y 0%Z
  | ZCGge x y => CGleq Z y x 0%Z
  | ZCGlt x y => CGleq Z x y (-1)%Z
  | ZCGgt x y => CGleq Z y x (-1)%Z
  | ZCGlep x y k => CGleq Z x y k
  | ZCGgep x y k => CGleq Z y x (- k)%Z
  | ZCGltp x y k => CGleq Z x y (k - 1)%Z
  | ZCGgtp x y k => CGleq Z y x (- (k + 1))%Z
  | ZCGlem x y k => CGleq Z x y (- k)%Z
  | ZCGgem x y k => CGleq Z y x k
  | ZCGltm x y k => CGleq Z x y (- (k + 1))%Z
  | ZCGgtm x y k => CGleq Z y x (k - 1)%Z
  | ZCGlepm x y k k' => CGleq Z x y (k' - k)%Z
  | ZCGgepm x y k k' => CGleq Z y x (k - k')%Z
  | ZCGltpm x y k k' => CGleq Z x y (k' - k - 1)%Z
  | ZCGgtpm x y k k' => CGleq Z y x (k - k' - 1)%Z
  | ZCGeq x y => CGeq Z x y 0%Z
  | ZCGeqp x y k => CGeq Z x y k
  | ZCGeqm x y k => CGeq Z y x k
  | ZCGeqpm x y k k' => CGeq Z x y (k' - k)%Z
  | ZCGzylem y k => CGleq Z N0 y (- k)%Z
  | ZCGzygem y k => CGleq Z y N0 k
  | ZCGzyltm y k => CGleq Z N0 y (- (k + 1))%Z
  | ZCGzygtm y k => CGleq Z y N0 (k - 1)%Z
  | ZCGzylepm y k k' => CGleq Z N0 y (k' - k)%Z
  | ZCGzygepm y k k' => CGleq Z y N0 (k - k')%Z
  | ZCGzyltpm y k k' => CGleq Z N0 y (k' - k - 1)%Z
  | ZCGzygtpm y k k' => CGleq Z y N0 (k - k' - 1)%Z
  | ZCGzyeqm y k => CGeq Z y N0 k
  | ZCGzyeqpm y k k' => CGeq Z y N0 (k - k')%Z
  | ZCGxzlep x k => CGleq Z x N0 k
  | ZCGxzgep x k => CGleq Z N0 x (- k)%Z
  | ZCGxzltp x k => CGleq Z x N0 (k - 1)%Z
  | ZCGxzgtp x k => CGleq Z N0 x (- (k + 1))%Z
  | ZCGxzlepm x k k' => CGleq Z x N0 (k' - k)%Z
  | ZCGxzgepm x k k' => CGleq Z N0 x (k - k')%Z
  | ZCGxzltpm x k k' => CGleq Z x N0 (k' - k - 1)%Z
  | ZCGxzgtpm x k k' => CGleq Z N0 x (k - k' - 1)%Z
  | ZCGxzeqp x k => CGeq Z x N0 k
  | ZCGxzeqpm x k k' => CGeq Z x N0 (k' - k)%Z
  | ZCGzzlep k k' => CGleq Z N0 N0 (k' - k)%Z
  | ZCGzzltp k k' => CGleq Z N0 N0 (k' - k - 1)%Z
  | ZCGzzgep k k' => CGleq Z N0 N0 (k - k')%Z
  | ZCGzzgtp k k' => CGleq Z N0 N0 (k - k' - 1)%Z
  | ZCGzzeq k k' => CGeq Z N0 N0 (k - k')%Z
  | ZCGand f0 f1 => CGand Z (ZCGtranslate f0) (ZCGtranslate f1)
  | ZCGor f0 f1 => CGor Z (ZCGtranslate f0) (ZCGtranslate f1)
  | ZCGimp f0 f1 => CGimp Z (ZCGtranslate f0) (ZCGtranslate f1)
  | ZCGnot f0 => CGnot Z (ZCGtranslate f0)
  | ZCGiff f0 f1 =>
      CGand Z (CGimp Z (ZCGtranslate f0) (ZCGtranslate f1))
        (CGimp Z (ZCGtranslate f1) (ZCGtranslate f0))
  end.

Section ZCGevalDef.

  Variable rho : ad -> Z.

Fixpoint ZCGeval (f : ZCGForm) : Prop :=
  match f with
  | ZCGle x y => (rho x <= rho y)%Z
  | ZCGge x y => (rho x >= rho y)%Z
  | ZCGlt x y => (rho x < rho y)%Z
  | ZCGgt x y => (rho x > rho y)%Z
  | ZCGlep x y k => (rho x <= rho y + k)%Z
  | ZCGgep x y k => (rho x >= rho y + k)%Z
  | ZCGltp x y k => (rho x < rho y + k)%Z
  | ZCGgtp x y k => (rho x > rho y + k)%Z
  | ZCGlem x y k => (rho x + k <= rho y)%Z
  | ZCGgem x y k => (rho x + k >= rho y)%Z
  | ZCGltm x y k => (rho x + k < rho y)%Z
  | ZCGgtm x y k => (rho x + k > rho y)%Z
  | ZCGlepm x y k k' => (rho x + k <= rho y + k')%Z
  | ZCGgepm x y k k' => (rho x + k >= rho y + k')%Z
  | ZCGltpm x y k k' => (rho x + k < rho y + k')%Z
  | ZCGgtpm x y k k' => (rho x + k > rho y + k')%Z
  | ZCGeq x y => rho x = rho y
  | ZCGeqp x y k => rho x = (rho y + k)%Z
  | ZCGeqm x y k => (rho x + k)%Z = rho y
  | ZCGeqpm x y k k' => (rho x + k)%Z = (rho y + k')%Z
  | ZCGzylem y k => (k <= rho y)%Z
  | ZCGzygem y k => (k >= rho y)%Z
  | ZCGzyltm y k => (k < rho y)%Z
  | ZCGzygtm y k => (k > rho y)%Z
  | ZCGzylepm y k k' => (k <= rho y + k')%Z
  | ZCGzygepm y k k' => (k >= rho y + k')%Z
  | ZCGzyltpm y k k' => (k < rho y + k')%Z
  | ZCGzygtpm y k k' => (k > rho y + k')%Z
  | ZCGzyeqm y k => k = rho y
  | ZCGzyeqpm y k k' => k = (rho y + k')%Z
  | ZCGxzlep x k => (rho x <= k)%Z
  | ZCGxzgep x k => (rho x >= k)%Z
  | ZCGxzltp x k => (rho x < k)%Z
  | ZCGxzgtp x k => (rho x > k)%Z
  | ZCGxzlepm x k k' => (rho x + k <= k')%Z
  | ZCGxzgepm x k k' => (rho x + k >= k')%Z
  | ZCGxzltpm x k k' => (rho x + k < k')%Z
  | ZCGxzgtpm x k k' => (rho x + k > k')%Z
  | ZCGxzeqp x k => rho x = k
  | ZCGxzeqpm x k k' => (rho x + k)%Z = k'
  | ZCGzzlep k k' => (k <= k')%Z
  | ZCGzzltp k k' => (k < k')%Z
  | ZCGzzgep k k' => (k >= k')%Z
  | ZCGzzgtp k k' => (k > k')%Z
  | ZCGzzeq k k' => k = k'
  | ZCGand f0 f1 => ZCGeval f0 /\ ZCGeval f1
  | ZCGor f0 f1 => ZCGeval f0 \/ ZCGeval f1
  | ZCGimp f0 f1 => ZCGeval f0 -> ZCGeval f1
  | ZCGnot f0 => ~ ZCGeval f0
  | ZCGiff f0 f1 => ZCGeval f0 <-> ZCGeval f1
  end.

  Variable Zrho_zero : rho N0 = 0%Z.

Lemma ZCGeval_correct :
 forall f : ZCGForm, ZCGeval f <-> ZCG_eval rho (ZCGtranslate f).
  Proof.
    simple induction f; simpl in |- *. intros. rewrite Zplus_0_r. apply Zle_is_le_bool.
    intros. rewrite Zplus_0_r. apply Zge_is_le_bool.
    intros. exact (Zlt_is_le_bool (rho a) (rho a0)).
    intros. exact (Zgt_is_le_bool (rho a) (rho a0)).
    intros. apply Zle_is_le_bool.
    intros. apply iff_trans with (rho a0 + z <= rho a)%Z. apply Zorder.Zge_iff_le.
    apply iff_trans with (rho a0 <= rho a - z)%Z. apply Zorder.Zle_plus_swap.
    unfold Zminus in |- *. apply Zle_is_le_bool.
    intros. apply iff_trans with (Zle_bool (rho a) (rho a0 + z - 1) = true). apply Zlt_is_le_bool.
    unfold Zminus at 1 in |- *. rewrite Zplus_assoc_reverse. split; intro; assumption.
    intros. apply iff_trans with (rho a0 + z < rho a)%Z. apply Zorder.Zgt_iff_lt.
    apply iff_trans with (rho a0 < rho a - z)%Z. apply Zorder.Zlt_plus_swap.
    rewrite Zopp_plus_distr. rewrite Zplus_assoc. exact (Zlt_is_le_bool (rho a0) (rho a - z)).
    intros. apply iff_trans with (rho a <= rho a0 - z)%Z. apply Zorder.Zle_plus_swap.
    unfold Zminus in |- *. apply Zle_is_le_bool.
    intros. apply Zge_is_le_bool.
    intros. apply iff_trans with (rho a < rho a0 - z)%Z. apply Zorder.Zlt_plus_swap.
    rewrite Zopp_plus_distr. rewrite Zplus_assoc. exact (Zlt_is_le_bool (rho a) (rho a0 - z)).
    intros. unfold Zminus in |- *. rewrite Zplus_assoc. exact (Zgt_is_le_bool (rho a + z) (rho a0)).
    intros. apply iff_trans with (rho a <= rho a0 + z0 - z)%Z. apply Zorder.Zle_plus_swap.
    unfold Zminus at 1 in |- *. rewrite Zplus_assoc_reverse. unfold Zminus in |- *. apply Zle_is_le_bool.
    intros. apply iff_trans with (rho a0 + z0 <= rho a + z)%Z. apply Zorder.Zge_iff_le.
    apply iff_trans with (rho a0 <= rho a + z - z0)%Z. apply Zorder.Zle_plus_swap.
    unfold Zminus at 1 in |- *. rewrite Zplus_assoc_reverse. unfold Zminus in |- *. apply Zle_is_le_bool.
    intros. apply iff_trans with (rho a < rho a0 + z0 - z)%Z. apply Zorder.Zlt_plus_swap.
    unfold Zminus at 2 in |- *. rewrite Zplus_assoc. unfold Zminus at 1 in |- *. rewrite Zplus_assoc_reverse.
    exact (Zlt_is_le_bool (rho a) (rho a0 + (z0 + - z))).
    intros. apply iff_trans with (rho a0 + z0 < rho a + z)%Z. apply Zorder.Zgt_iff_lt.
    apply iff_trans with (rho a0 < rho a + z - z0)%Z. apply Zorder.Zlt_plus_swap.
    unfold Zminus at 2 in |- *. rewrite Zplus_assoc. unfold Zminus at 1 in |- *. rewrite Zplus_assoc_reverse.
    exact (Zlt_is_le_bool (rho a0) (rho a + (z + - z0))).
    intros. rewrite Zplus_0_r. split; intro; assumption.
    split; intro; assumption.
    split; intro; apply sym_eq; assumption.
    intros. unfold Zminus in |- *. rewrite Zplus_assoc. exact (Zorder.Zeq_plus_swap (rho a) (rho a0 + z0) z).
    rewrite Zrho_zero. intros. apply iff_trans with (0 + z <= rho a)%Z. rewrite Zplus_0_l.
    split; intro; assumption.
    apply iff_trans with (0 <= rho a - z)%Z. apply Zorder.Zle_plus_swap.
    unfold Zminus in |- *. apply Zle_is_le_bool.
    rewrite Zrho_zero. intros. rewrite Zplus_0_l. apply Zge_is_le_bool.
    rewrite Zrho_zero. intros. apply iff_trans with (0 + z < rho a)%Z. rewrite Zplus_0_l.
    split; intro; assumption.
    apply iff_trans with (0 < rho a - z)%Z. apply Zorder.Zlt_plus_swap.
    rewrite Zopp_plus_distr. rewrite Zplus_assoc. exact (Zlt_is_le_bool 0 (rho a - z)).
    rewrite Zrho_zero. intros. rewrite Zplus_0_l. apply Zgt_is_le_bool.
    rewrite Zrho_zero. intros. apply iff_trans with (0 + z <= rho a + z0)%Z. rewrite Zplus_0_l.
    split; intro; assumption.
    apply iff_trans with (0 <= rho a + z0 - z)%Z. apply Zorder.Zle_plus_swap.
    unfold Zminus at 2 in |- *. rewrite Zplus_assoc. exact (Zle_is_le_bool 0 (rho a + z0 - z)).
    rewrite Zrho_zero. intros. rewrite Zplus_0_l. apply iff_trans with (rho a + z0 <= z)%Z.
    apply Zorder.Zge_iff_le.
    apply iff_trans with (rho a <= z - z0)%Z. apply Zorder.Zle_plus_swap.
    apply Zle_is_le_bool.
    rewrite Zrho_zero. intros. apply iff_trans with (0 + z < rho a + z0)%Z. rewrite Zplus_0_l.
    split; intro; assumption.
    apply iff_trans with (0 < rho a + z0 - z)%Z. apply Zorder.Zlt_plus_swap.
    unfold Zminus at 2 in |- *. rewrite Zplus_assoc. unfold Zminus in |- *. rewrite Zplus_assoc.
    exact (Zlt_is_le_bool 0 (rho a + z0 + - z)).
    rewrite Zrho_zero. intros. rewrite Zplus_0_l. apply iff_trans with (rho a + z0 < z)%Z.
    apply Zorder.Zgt_iff_lt.
    apply iff_trans with (rho a < z - z0)%Z. apply Zorder.Zlt_plus_swap.
    apply Zlt_is_le_bool.
    rewrite Zrho_zero. intros. rewrite Zplus_0_l. split; intro; apply sym_eq; assumption.
    rewrite Zrho_zero. intros. rewrite Zplus_0_l. apply iff_trans with ((rho a + z0)%Z = z).
    split; intro; apply sym_eq; assumption.
    apply Zorder.Zeq_plus_swap.
    rewrite Zrho_zero. intros. rewrite Zplus_0_l. apply Zle_is_le_bool.
    rewrite Zrho_zero. intros. apply iff_trans with (0 + z <= rho a)%Z. rewrite Zplus_0_l.
    apply Zorder.Zge_iff_le.
    apply iff_trans with (0 <= rho a - z)%Z. apply Zorder.Zle_plus_swap.
    exact (Zle_is_le_bool 0 (rho a - z)).
    rewrite Zrho_zero. intros. rewrite Zplus_0_l. apply Zlt_is_le_bool.
    rewrite Zrho_zero. intros. apply iff_trans with (0 + z < rho a)%Z. rewrite Zplus_0_l.
    apply Zorder.Zgt_iff_lt.
    apply iff_trans with (0 < rho a - z)%Z. apply Zorder.Zlt_plus_swap.
    rewrite Zopp_plus_distr. rewrite Zplus_assoc. exact (Zlt_is_le_bool 0 (rho a - z)).
    rewrite Zrho_zero. intros. rewrite Zplus_0_l. apply iff_trans with (rho a <= z0 - z)%Z.
    apply Zorder.Zle_plus_swap.
    apply Zle_is_le_bool. 
    rewrite Zrho_zero. intros. apply iff_trans with (0 + z0 <= rho a + z)%Z. rewrite Zplus_0_l.
    apply Zorder.Zge_iff_le.
    apply iff_trans with (0 <= rho a + z - z0)%Z. apply Zorder.Zle_plus_swap.
    unfold Zminus at 2 in |- *. rewrite Zplus_assoc. exact (Zle_is_le_bool 0 (rho a + z - z0)).
    rewrite Zrho_zero. intros. rewrite Zplus_0_l. apply iff_trans with (rho a < z0 - z)%Z.
    apply Zorder.Zlt_plus_swap.
    apply Zlt_is_le_bool.
    rewrite Zrho_zero. intros. apply iff_trans with (0 + z0 < rho a + z)%Z. rewrite Zplus_0_l.
    apply Zorder.Zgt_iff_lt.
    apply iff_trans with (0 < rho a + z - z0)%Z. apply Zorder.Zlt_plus_swap.
    unfold Zminus at 2 in |- *. rewrite Zplus_assoc. unfold Zminus in |- *. rewrite Zplus_assoc.
    exact (Zlt_is_le_bool 0 (rho a + z + - z0)).
    rewrite Zrho_zero. intros. rewrite Zplus_0_l. split; intro; assumption.
    rewrite Zrho_zero. intros. rewrite Zplus_0_l. apply Zorder.Zeq_plus_swap.
    rewrite Zrho_zero. intros. rewrite Zplus_0_l. apply iff_trans with (0 + z <= z0)%Z.
    rewrite Zplus_0_l. split; intro; assumption.
    apply iff_trans with (0 <= z0 - z)%Z. apply Zorder.Zle_plus_swap.
    apply Zle_is_le_bool.
    rewrite Zrho_zero. intros. rewrite Zplus_0_l. apply iff_trans with (0 + z < z0)%Z.
    rewrite Zplus_0_l. split; intro; assumption.
    apply iff_trans with (0 < z0 - z)%Z. apply Zorder.Zlt_plus_swap.
    apply Zlt_is_le_bool.
    rewrite Zrho_zero. intros. rewrite Zplus_0_l. apply iff_trans with (0 + z0 <= z)%Z.
    rewrite Zplus_0_l. apply Zorder.Zge_iff_le.
    apply iff_trans with (0 <= z - z0)%Z. apply Zorder.Zle_plus_swap.
    apply Zle_is_le_bool.
    rewrite Zrho_zero. intros. rewrite Zplus_0_l. apply iff_trans with (0 + z0 < z)%Z.
    rewrite Zplus_0_l. apply Zorder.Zgt_iff_lt.
    apply iff_trans with (0 < z - z0)%Z. apply Zorder.Zlt_plus_swap.
    apply Zlt_is_le_bool.
    rewrite Zrho_zero. intros. rewrite Zplus_0_l. split. intro. rewrite H. apply Zminus_diag_reverse.
    intro. rewrite <- (Zplus_0_l z0). rewrite H. unfold Zminus in |- *. rewrite Zplus_assoc_reverse.
    rewrite Zplus_opp_l. rewrite Zplus_0_r. reflexivity.
    intros. elim H. intros. elim H0. intros. split. intro. elim H5. intros. split. apply H1.
    assumption.
    apply H3. assumption.
    intro. elim H5. intros. split. apply H2. assumption.
    apply H4. assumption.
    intros. elim H. intros. elim H0. intros. split. intro. elim H5. intro. left. apply H1.
    assumption.
    intro. right. apply H3. assumption.
    intro. elim H5. intro. left. apply H2. assumption.
    intro. right. apply H4. assumption.
    intros. elim H. intros. elim H0. intros. split. intros. apply H3. apply H5. apply H2.
    assumption.
    intros. apply H4. apply H5. apply H1. assumption.
    unfold not in |- *. intros. elim H. intros. split. intros. apply H2. apply H1. assumption.
    intros. apply H2. apply H0. assumption.
    intros. fold (ZCG_eval rho (ZCGtranslate z) <-> ZCG_eval rho (ZCGtranslate z0))
  in |- *. split.
    intro. apply iff_trans with (ZCGeval z). apply iff_sym. assumption.
    apply iff_trans with (ZCGeval z0). assumption.
    assumption.
    intro. apply iff_trans with (ZCG_eval rho (ZCGtranslate z)). assumption.
    apply iff_trans with (ZCG_eval rho (ZCGtranslate z0)). assumption.
    apply iff_sym. assumption.
  Qed.

End ZCGevalDef.

Definition ZCG_solve (f : ZCGForm) :=
  CG_solve Z 0%Z Zplus Zopp Zle_bool 1%Z (ZCGtranslate f).

Theorem ZCG_solve_correct :
 forall f : ZCGForm,
 ZCG_solve f = true -> {rho : ad -> Z | ZCGeval rho f /\ rho N0 = 0%Z}.
Proof.
  intros.
  elim
   (CG_solve_correct_anchored Z 0%Z Zplus Zopp Zle_bool Zplus_0_r Zplus_0_l
      Zplus_assoc_reverse Zplus_opp_r Zle_bool_refl Zle_bool_antisym
      Zle_bool_trans Zle_bool_total Zle_bool_plus_mono 1%Z Zone_pos
      Zone_min_pos N0 0%Z _ H).
  intros rho H0. split with rho. elim H0. intros. split.
  apply (proj2 (ZCGeval_correct rho H2 f)). assumption.
  assumption.
Qed.

Theorem ZCG_solve_complete :
 forall (f : ZCGForm) (rho : ad -> Z),
 ZCGeval rho f -> rho N0 = 0%Z -> ZCG_solve f = true.
Proof.
  intros. unfold ZCG_solve in |- *.
  apply
   (CG_solve_complete Z 0%Z Zplus Zopp Zle_bool Zplus_0_r Zplus_0_l
      Zplus_assoc_reverse Zplus_opp_r Zle_bool_refl Zle_bool_antisym
      Zle_bool_trans Zle_bool_total Zle_bool_plus_mono 1%Z Zone_pos
      Zone_min_pos (ZCGtranslate f) rho).
  apply (proj1 (ZCGeval_correct rho H0 f)). assumption.
Qed.

Definition ZCG_prove (f : ZCGForm) :=
  CG_prove Z 0%Z Zplus Zopp Zle_bool 1%Z (ZCGtranslate f).

Theorem ZCG_prove_correct :
 forall f : ZCGForm,
 ZCG_prove f = true -> forall rho : ad -> Z, rho N0 = 0%Z -> ZCGeval rho f.
Proof.
  intros. apply (proj2 (ZCGeval_correct rho H0 f)).
  exact
   (CG_prove_correct Z 0%Z Zplus Zopp Zle_bool Zplus_0_r Zplus_0_l
      Zplus_assoc_reverse Zplus_opp_r Zle_bool_refl Zle_bool_antisym
      Zle_bool_trans Zle_bool_total Zle_bool_plus_mono 1%Z Zone_pos
      Zone_min_pos _ H rho).
Qed.

Theorem ZCG_prove_complete :
 forall f : ZCGForm,
 (forall rho : ad -> Z, rho N0 = 0%Z -> ZCGeval rho f) ->
 ZCG_prove f = true.
Proof.
  intros. unfold ZCG_prove in |- *.
  apply
   (CG_prove_complete_anchored Z 0%Z Zplus Zopp Zle_bool Zplus_0_r Zplus_0_l
      Zplus_assoc_reverse Zplus_opp_r Zle_bool_refl Zle_bool_antisym
      Zle_bool_trans Zle_bool_total Zle_bool_plus_mono 1%Z Zone_pos
      Zone_min_pos (ZCGtranslate f) N0 0%Z).
  intros. exact (proj1 (ZCGeval_correct rho H0 f) (H rho H0)).
Qed.

