

Require Import Utf8.

Set Implicit Arguments.



Require Import Equalities.

Require Import List.
(* List:
Require Import Utf8.
Require List Bool.
Set Implicit Arguments.

Require Import Equalities.

Module CoreGenericEnvListDef (VarType : UsualDecidableType).

Import List Bool.

Import VarType.

Definition TVar := VarType.t.

Definition gen_env A := list (TVar * A).

Section CoreDefinitions.

Variable A B : Type.
Implicit Types x y : TVar.
Implicit Types xs ys : list TVar.
Implicit Types v w : A.
Implicit Types vs ws : list A.
Implicit Types E F G : gen_env A.
Implicit Types f g : A -> B.

Definition eq_keys_dec := VarType.eq_dec.

Lemma eq_keys_true : forall A x (a b : A),
  (if eq_keys_dec x x then a else b) = a.

Lemma eq_keys_false : forall A x y (a b : A),
  x <> y -> (if eq_keys_dec x y then a else b) = b.

Definition empty : gen_env A := nil.

Definition single x v := (x, v) :: nil.

Fixpoint singles xs vs : gen_env A :=
  match xs, vs with
    | x :: xs, v :: vs => (x, v) :: (singles xs vs)
    | _, _ => nil
  end.

Definition concat E F := F ++ E.

Fixpoint get x E : option A :=
  match E with
    | nil => None
    | (y, v) :: E' => if eq_keys_dec x y then Some v else get x E'
  end.

Fixpoint dom E : list TVar :=
  match E with
    | nil => nil
    | (x, _) :: E' => x :: (dom E')
  end.

Fixpoint img E : list A :=
  match E with
    | nil => nil
    | (_, v) :: E' => v :: (img E')
  end.

Definition belongs x E :=
  List.In x (dom E).

Definition all_belongs xs E :=
  forall x, List.In x xs -> belongs x E.

Definition notin x E := 
  ~ belongs x E.

Definition all_notin xs E :=
  forall x, List.In x xs -> notin x E.

Fixpoint map f E : gen_env B :=
  match E with
    | nil => nil
    | (x, v) :: E' => (x, f v) :: map f E'
  end.

Fixpoint update_one E x v : gen_env A :=
  match E with
    | nil => nil
    | (y, v') :: E' =>
      if eq_keys_dec x y then (y, v) :: E'
        else (y, v') :: (update_one E' x v)
  end.

Fixpoint update E F : gen_env A :=
  match F with
    | nil => E
    | (x, v) :: F' => update_one (update E F') x v
  end.

Fixpoint remove x E : gen_env A :=
  match E with
    | nil => nil
    | (y, v) :: E => if eq_keys_dec x y then E else (y, v) :: (remove x E)
  end.

Fixpoint all_remove xs E : gen_env A :=
  match xs with
    | nil => E
    | x :: xs => all_remove xs (remove x E)
  end.

Inductive ok : gen_env A -> Prop :=
| ok_nil : ok nil
| ok_cons : forall x v F, ok F ∧ notin x F -> ok (concat F (single x v))
.

End CoreDefinitions.

Notation "x '∶' v" := (single x v)
  (at level 63) : gen_env_scope.

Notation "xs '∷' vs" := (singles xs vs)
  (at level 63) : gen_env_scope.

Notation "E '&' F" := (concat E F) 
  (at level 65, left associativity) : gen_env_scope.

Notation "E '∖' '{' x '}'" := (remove x E) 
  (at level 64, left associativity) : gen_env_scope.

Notation "E '∖' xs" := (all_remove xs E) 
  (at level 64, left associativity) : gen_env_scope.

Notation "E '[' x '<-' v ']'" := (update_one E x v) 
  (at level 65, left associativity) : gen_env_scope.

Notation "E '::=' F" := (update E F) 
  (at level 65, left associativity) : gen_env_scope.

Notation "x '∈' E" := (belongs x E)
  (at level 67) : gen_env_scope.

Notation "xs '⊂' E" := (all_belongs xs E)
  (at level 67) : gen_env_scope.

Notation "x '∉' E" := (notin x E)
  (at level 67) : gen_env_scope.

Notation "xs '⊄' E" := (all_notin xs E)
  (at level 67) : gen_env_scope.

Bind Scope gen_env_scope with gen_env.
Delimit Scope gen_env_scope with gen_env.
Local Open Scope gen_env_scope.

Section Properties.
Variable A B : Type.
Implicit Types x y : TVar.
Implicit Types xs ys : list TVar.
Implicit Types v w : A.
Implicit Types vs ws : list A.
Implicit Types E F G : gen_env A.
Implicit Types f g : A -> B.

Lemma env_ind : forall (P : gen_env A -> Prop),
  (P (@empty A)) ->
  (forall E x v, P E -> P (E & (x ∶ v))) ->
  (forall E, P E).

Lemma singles_empty :
  nil ∷ nil = (@empty A).

Lemma singles_cons : forall x xs v vs,
  (x :: xs) ∷ (v :: vs) = (xs ∷ vs) & (x ∶ v).

Lemma singles_empty_r : forall xs,
  xs ∷ nil = (@empty A).

Lemma singles_empty_l : forall vs,
  nil ∷ vs = (@empty A).

Lemma concat_empty_r : forall E,
  E & (@empty A) = E.

Lemma concat_empty_l : forall E,
  (@empty A) & E = E.

Lemma concat_assoc : forall E F G,
  E & (F & G) = (E & F) & G.

Lemma get_empty : forall x,
  get x (@empty A) = None.

Lemma get_single_eq : forall x y v,
  x = y ->
  get x (y ∶ v) = Some v.

Lemma get_single_eq_inv : forall x y v w,
  get x (y ∶ w) = Some v ->
  x = y /\ v = w.

Lemma get_dec : forall x E,
  { v : A | get x E = Some v } + { get x E = None }.

Lemma get_concat_r : forall x y v E,
  x = y ->
  get x (E & (y ∶ v)) = Some v.

Lemma get_concat_l : forall x y v E,
  x <> y ->
  get x (E & (y ∶ v)) = get x E.

Lemma get_concat_inv : forall x y v w E,
  get x (E & (y ∶ v)) = Some w ->
  (x = y /\ v = w) \/ (x <> y /\ get x E = Some w).

Lemma dom_empty :
  dom (@empty A) = nil.

Lemma dom_empty_inv : forall E,
  dom (E) = nil ->
  E = (@empty A).

Lemma dom_single : forall x v,
  dom (x ∶ v) = x :: nil.

Lemma dom_singles : forall xs vs,
  length xs = length vs ->
  dom (xs ∷ vs) = xs.

Lemma dom_singles_incl : forall xs vs,
  List.incl (dom (xs ∷ vs)) xs.

Lemma dom_concat : forall E F,
  dom (E & F) = List.app (dom F) (dom E).

Lemma img_empty :
  img (@empty A) = nil.

Lemma img_empty_inv : forall E,
  img (E) = nil ->
  E = (@empty A).

Lemma img_single : forall x v,
  img (x ∶ v) = v :: nil.

Lemma img_singles : forall xs vs,
  length xs = length vs ->
  img (xs ∷ vs) = vs.

Lemma img_singles_incl : forall xs vs,
  List.incl (img (xs ∷ vs)) vs.

Lemma img_concat : forall E F,
  img (E & F) = List.app (img F) (img E).

Lemma dom_img_id : forall E,
  (dom E) ∷ (img E) = E.

Lemma length_dom_img_eq : forall E,
  length (dom E) = length (img E).

Lemma belongs_empty : forall x,
  x ∈ (@empty A) ->
  False.

Lemma belongs_single : forall x y v,
  x = y ->
  x ∈ (y ∶ v).

Lemma belongs_single_inv : forall x y v,
  x ∈ (y ∶ v) ->
  x = y.

Lemma belongs_singles : forall x xs vs,
  length xs = length vs ->
  List.In x xs ->

Lemma belongs_singles_inv : forall x xs vs,
  length xs = length vs ->
  x ∈ (xs ∷ vs) ->
  List.In x xs.

Lemma belongs_concat_l : forall x F G,
  x ∈ F ->
  x ∈ (F & G).

Lemma belongs_concat_r : forall x F G,
  x ∈ F ->
  x ∈ (G & F).

Lemma belongs_concat_inv : forall x F G,
  x ∈ (F & G) ->
  x ∈ F ∨ x ∈ G.

Lemma belongs_dom : forall x E,
  x ∈ E ->
  List.In x (dom E).

Lemma belongs_dom_inv : forall x E,
  List.In x (dom E) ->

Lemma all_belongs_def : forall xs E,
  (forall x, List.In x xs -> x ∈ E) ->

Lemma all_belongs_def_inv : forall xs E,
  xs ⊂ E ->
  (forall x, List.In x xs -> x ∈ E).

Lemma all_belongs_belongs : forall x xs E,
  (x :: xs) ⊂ E ->
  x ∈ E ∧ xs ⊂ E.

Lemma belongs_all_belongs : forall x xs E,
  x ∈ E ∧ xs ⊂ E ->
  (x :: xs) ⊂ E.

Lemma all_belongs_empty : forall xs,
  xs ⊂ (@empty A) ->
  xs = nil.

Lemma all_belongs_nil : forall E,
  nil ⊂ E.

Lemma all_belongs_single : forall xs y v,
  xs = y :: nil ->
  xs ⊂ (y ∶ v).

Lemma all_belongs_single_inv : forall xs y v,
  length xs = 1 ->
  xs ⊂ (y ∶ v) ->
  xs = y :: nil.

Lemma all_belongs_singles : forall xs ys vs,
  length ys = length vs ->
  List.incl xs ys ->

Lemma all_belongs_singles_inv : forall xs ys vs,
  xs ⊂ (ys ∷ vs) ->
  List.incl xs ys.

Lemma all_belongs_concat_l : forall xs F G,
  xs ⊂ F ->
  xs ⊂ (F & G).

Lemma all_belongs_concat_r : forall xs F G,
  xs ⊂ F ->
  xs ⊂ (G & F).

Lemma all_belongs_dom : forall xs E,
  xs ⊂ E ->
  List.incl xs (dom E).

Lemma all_belongs_dom_inv : forall xs E F,
  List.incl xs (dom E) ->

Lemma notin_belongs : forall x E,
  x ∉ E ->
  ¬ x ∈ E.

Lemma belongs_notin : forall x E,
  x ∈ E ->
  ¬ x ∉ E.

Lemma not_belongs_notin : forall A x (E : gen_env A),
  ¬ x ∈ E ->
  x ∉ E.

Lemma notin_belongs_neq : forall x y E,
  x ∈ E -> y ∉ E ->
  x <> y.

Lemma notin_empty : forall x,
  x ∉ (@empty A).

Lemma notin_single : forall x y v,
  x <> y ->
  x ∉ (y ∶ v).

Lemma notin_single_inv : forall x y v,
  x ∉ (y ∶ v) ->
  x <> y.

Lemma notin_singles : forall x xs vs,
  ¬ List.In x xs ->

Lemma notin_singles_inv : forall x xs vs,
  length xs = length vs ->
  x ∉ (xs ∷ vs) ->
  ¬ List.In x xs.

Lemma notin_concat : forall x F G,
  x ∉ F -> x ∉ G ->
  x ∉ (F & G).

Lemma notin_concat_inv : forall x F G,
  x ∉ (F & G) ->
  x ∉ F ∧ x ∉ G.

Lemma notin_dom : forall x E,
  x ∉ E ->
  ¬ List.In x (dom E).

Lemma notin_dom_inv : forall x E F,
  ¬ List.In x (dom E) ->

Lemma all_notin_empty_l : forall E,
  nil ⊄ E.

Lemma all_notin_def : forall xs E,
  (forall x, List.In x xs -> x ∉ E) ->

Lemma all_notin_def_inv : forall xs E,
  xs ⊄ E ->
  (forall x, List.In x xs -> x ∉ E).

Lemma all_notin_notin : forall x xs E,
  (x :: xs) ⊄ E ->
  x ∉ E ∧ xs ⊄ E.

Lemma notin_all_notin : forall x xs E,
  x ∉ E ∧ xs ⊄ E ->
  (x :: xs) ⊄ E.

Lemma all_notin_belongs_neq : forall x ys E,
  x ∈ E -> ys ⊄ E ->
  ¬ List.In x ys.

Lemma all_notin_empty_r : forall xs,
  xs ⊄ (@empty A).

Lemma all_notin_nil : forall E,
  nil ⊄ E.

Lemma all_notin_single : forall xs y v,
  ¬ List.In y xs ->

Lemma all_notin_single_inv : forall xs y v,
  xs ⊄ (y ∶ v) ->
  ¬ List.In y xs.

Lemma all_notin_singles : forall xs ys vs,
  List.Forall (fun x => ¬ List.In x ys) xs ->

Lemma all_notin_singles_inv : forall xs ys vs,
  length ys = length vs ->
  xs ⊄ (ys ∷ vs) ->
  List.Forall (fun x => ¬ List.In x ys) xs.

Lemma all_notin_concat : forall xs F G,
  xs ⊄ F -> xs ⊄ G ->
  xs ⊄ (F & G).

Lemma all_notin_concat_inv : forall xs F G,
  xs ⊄ (F & G) ->
  xs ⊄ F ∧ xs ⊄ G.

Lemma all_notin_dom : forall xs E,
  xs ⊄ E ->
  List.Forall (fun x => ¬ List.In x (dom E)) xs.

Lemma all_notin_dom_inv : forall xs E,
  List.Forall (fun x => ¬ List.In x (dom E)) xs ->

Lemma map_empty : forall f,
  map f (@empty A) = (@empty B).

Lemma map_single : forall f x v,
  map f (x ∶ v) = x ∶ (f v).

Lemma map_singles : forall f xs vs,
  map f (xs ∷ vs) = xs ∷ (List.map f vs).

Lemma map_concat : forall f E F,
  map f (E & F) = (map f E) & (map f F).

Lemma dom_map : forall E f,
  dom (map f E) = dom E.

Lemma belongs_map : forall x E f,
  x ∈ E ->
  x ∈ (map f E).

Lemma belongs_map_inv : forall x E f,
  x ∈ (map f E) ->
  x ∈ E.

Lemma all_belongs_map : forall xs E f,
  xs ⊂ E ->
  xs ⊂ (map f E).

Lemma all_belongs_map_inv : forall xs E f,
  xs ⊂ (map f E) ->
  xs ⊂ E.

Lemma notin_map : forall x E f,
  x ∉ E ->
  x ∉ (map f E).

Lemma notin_map_inv : forall x E f,
  x ∉ (map f E) ->
  x ∉ E.

Lemma all_notin_map : forall xs E f,
  xs ⊄ E ->
  xs ⊄ (map f E).

Lemma all_notin_map_inv : forall xs E f,
  xs ⊄ (map f E) ->
  xs ⊄ E.

Lemma ok_map : forall E f,
  ok E ->
  ok (map f E).

Lemma ok_map_inv : forall E f,
  ok (map f E) ->
  ok E.

Lemma update_one_empty : forall x v,
  (@empty A) [x <- v] = (@empty A).

Lemma update_one_single : forall x y v w,
  x = y ->
  (x ∶ v) [y <- w] = (x ∶ w).

Lemma update_one_single_neq : forall x y v w,
  x <> y ->
  (x ∶ v) [y <- w] = (x ∶ v).

Lemma update_one_concat_r : forall x v E F,
  x ∈ F ->
  (E & F) [x <- v] = E & (F [x <- v]).

Lemma update_one_concat_l : forall x v E F,
  x ∉ F ->
  (E & F) [x <- v] = (E [x <- v]) & F.

Lemma dom_update_one : forall x v E,
  dom (E [x <- v]) = dom E.

Lemma belongs_update_one : forall x y v E,
  y ∈ E ->
  y ∈ (E [x <- v]).

Lemma belongs_update_one_inv : forall x y v E,
  y ∈ (E [x <- v]) ->
  y ∈ E.

Lemma all_belongs_update_one : forall x xs v E,
  xs ⊂ E ->
  xs ⊂ (E [x <- v]).

Lemma all_belongs_update_one_inv : forall x xs v E,
  xs ⊂ (E [x <- v]) ->
  xs ⊂ E.

Lemma notin_update_one : forall x y v E,
  y ∉ E ->
  y ∉ (E [x <- v]).

Lemma notin_update_one_inv : forall x y v E,
  y ∉ (E [x <- v]) ->
  y ∉ E.

Lemma all_notin_update_one : forall x xs v E,
  xs ⊄ E ->
  xs ⊄ (E [x <- v]).

Lemma all_notin_update_one_inv : forall x xs v E,
  xs ⊄ (E [x <- v]) ->
  xs ⊄ E.

Lemma update_one_notin : forall x v E,
  x ∉ E ->
  E [x <- v] = E.

Lemma map_update_one : forall f x v E,
  map f (E [x <- v]) = (map f E) [x <- f v].

Lemma ok_update_one : forall x v E,
  ok E ->
  ok (E [x <- v]).

Lemma ok_update_one_inv : forall x v E,
  ok (E [x <- v]) ->
  ok E.

Lemma update_empty_r : forall E,
  E ::= (@empty A) = E.

Lemma update_empty_l : forall E,
  (@empty A) ::= E = (@empty A).

Lemma update_update_one : forall x v E,
  E ::= (x ∶ v) = E [x <- v].

Lemma update_single_single : forall x y v w,
  x = y ->
  (x ∶ v) ::= (y ∶ w) = (x ∶ w). 

Lemma update_single_single_neq : forall x y v w,
  x <> y ->
  (x ∶ v) ::= (y ∶ w) = (x ∶ v). 

Lemma update_concat_r : forall E F G,
  E ::= (F & G) = (E ::= F) ::= G.

Lemma dom_update : forall E F,
  dom (E ::= F) = dom E.

Lemma belongs_update : forall x E F,
  x ∈ E ->
  x ∈ (E ::= F).

Lemma belongs_update_inv : forall x E F,
  x ∈ (E ::= F) ->
  x ∈ E.

Lemma all_belongs_update : forall xs E F,
  xs ⊂ E ->
  xs ⊂ (E ::= F).

Lemma all_belongs_update_inv : forall xs E F,
  xs ⊂ (E ::= F) ->
  xs ⊂ E.

Lemma notin_update : forall x E F,
  x ∉ E ->
  x ∉ (E ::= F).

Lemma notin_update_inv : forall x E F,
  x ∉ (E ::= F) ->
  x ∉ E.

Lemma all_notin_update : forall xs E F,
  xs ⊄ E ->
  xs ⊄ (E ::= F).

Lemma all_notin_update_inv : forall xs E F,
  xs ⊄ (E ::= F) ->
  xs ⊄ E.

Lemma update_notin : forall E F,
  (dom F) ⊄ E ->
  E ::= F = E.

Lemma map_update : forall f E F,
  map f (E ::= F) = (map f E) ::= (map f F).

Lemma ok_update : forall E F,
  ok E ->
  ok (E ::= F).

Lemma ok_update_inv : forall E F,
  ok (E ::= F) ->
  ok E.

Lemma remove_empty : forall x,
  (@empty A) ∖ {x} = (@empty A).

Lemma remove_single_eq : forall x y v,
  x = y ->
  (x ∶ v) ∖ {y} = (@empty A).

Lemma remove_single_neq : forall x y v,
  x <> y ->
  (x ∶ v) ∖ {y} = (x ∶ v).

Lemma remove_notin : forall x E,
  x ∉ E ->
  E ∖ {x} = E.

Lemma notin_remove_notin : forall x y E,
  x ∉ E ->
  x ∉ (E ∖ {y}).

Lemma all_notin_remove_notin : forall xs y E,
  xs ⊄ E ->
  xs ⊄ (E ∖ {y}).

Lemma belongs_remove : forall x y E,
  x <> y -> x ∈ E ->
  x ∈ (E ∖ {y}).

Lemma belongs_remove_inv : forall x y E,
  ok E ->
  x ∈ (E ∖ {y}) -> x <> y.

Lemma remove_belongs_concat_r : forall x E F,
  x ∈ F ->
  (E & F) ∖ {x} = E & (F ∖ {x}).

Lemma remove_belongs_concat_l : forall x E F,
  x ∉ F ->
  (E & F) ∖ {x} = (E ∖ {x}) & F.

Lemma remove_ok_notin : forall x E,
  ok E ->
  x ∉ (E ∖ {x}).

Lemma remove_all_belongs : forall x xs F,
  ¬ List.In x xs -> (x :: xs) ⊂ F ->

Lemma remove_map : forall f E x,
  (map f E) ∖ {x} = map f (E ∖ {x}).

Lemma remove_update_one : forall x y v E,
  ok E ->
  (update_one E y v) ∖ {x} = update_one (E ∖ {x}) y v.

Lemma remove_update : forall x E F,
  ok E ->
  (E ::= F) ∖ {x} = (E ∖ {x}) ::= F.

Lemma remove_update_eq : forall x y v E,
  x = y ->
  (E ::= (y ∶ v)) ∖ {x} = E ∖ {x}.

Lemma ok_remove : forall x E,
  ok E ->
  ok (E ∖ {x}).

Lemma all_remove_remove : forall x xs E,
  E ∖ (x :: xs) = (E ∖ {x}) ∖ xs.

Lemma all_remove_empty : forall xs,
  (@empty A) ∖ xs = (@empty A).

Lemma all_remove_nil : forall E,
  E ∖ nil = E.

Lemma all_remove_single_in : forall x xs v,
  List.In x xs ->

Lemma all_remove_single_not_in : forall x xs v,
  ¬ List.In x xs ->

Lemma all_remove_singles_in : forall xs ys vs,
  xs = ys -> length xs = length vs ->
  (xs ∷ vs) ∖ ys = (@empty A).

Lemma all_remove_singles_not_in : forall xs ys vs,
  List.Forall (fun x => ¬ List.In x xs) ys ->

Lemma all_remove_notin : forall xs E,
  xs ⊄ E ->
  E ∖ xs = E.

Lemma notin_all_remove_notin : forall x ys E,
  x ∉ E ->
  x ∉ (E ∖ ys).

Lemma all_notin_all_remove_notin : forall xs ys E,
  xs ⊄ E ->
  xs ⊄ (E ∖ ys).

Lemma all_remove_ok_notin : forall xs E,
  ok E ->
  xs ⊄ (E ∖ xs).

Lemma all_remove_belongs_concat_r : forall xs E F,
  List.NoDup xs ->

Lemma all_remove_belongs_concat_l : forall xs E F,
  xs ⊄ F ->
  (E & F) ∖ xs = (E ∖ xs) & F.

Lemma all_remove_map : forall f E xs,
  (map f E) ∖ xs = map f (E ∖ xs).

Lemma all_remove_update : forall xs E F,
  ok E ->
  (E ::= F) ∖ xs = (E ∖ xs) ::= F.

Lemma ok_all_remove : forall xs E,
  ok E ->
  ok (E ∖ xs).

Lemma ok_empty :
  ok (@empty A).

Lemma ok_single : forall x v,
  ok (x ∶ v).

Lemma ok_singles : forall xs vs,
  List.NoDup xs ->

Lemma ok_singles_inv : forall xs vs,
  length xs = length vs ->
  ok (xs ∷ vs) ->
  List.NoDup xs.

Lemma ok_concat : forall E F,
  ok E -> ok F ->
  (dom E) ⊄ F -> (dom F) ⊄ E ->
  ok (E & F).

Lemma ok_concat_inv : forall E F,
  ok (E & F) ->
  ok E ∧ ok F ∧ (dom E) ⊄ F ∧ (dom F) ⊄ E.

Lemma ok_concat_comm : forall E F,
  ok (E & F) ->
  ok (F & E).

Lemma belongs_ok_concat_inv_l : forall x F G,
  ok (F & G) ->
  x ∈ F ->
  x ∉ G.

Lemma belongs_ok_concat_inv_r : forall x F G,
  ok (F & G) ->
  x ∈ G ->
  x ∉ F.

Lemma concat_not_ok : forall x F G,
  x ∈ F -> x ∈ G ->
  ¬ ok (F & G).

Lemma update_one_concat_ok : forall E F x v,
  ok (E & F) ->
  (E & F) [x <- v] =
  (E [x <- v]) & (F [x <- v]).

Lemma update_concat_l : forall E F G,
  ok (E & F) ->
  (E & F) ::= G = (E ::= G) & (F ::= G).

End Properties.

End CoreGenericEnvListDef.

Require Import CoreGenericEnv GenericEnv.

Module CoreGenericEnvList (VarType : UsualDecidableType)
  : CoreGenericEnvironmentType VarType
  := CoreGenericEnvListDef VarType.

Module GenericEnvironmentAsList (VarType : UsualDecidableType).
  Module Core := CoreGenericEnvList VarType.
  Module Ext := GenericEnvironmentType VarType Core.
  Import Ext.
End GenericEnvironmentAsList. *)



Module Type CoreGenericEnvironmentType (VarType : UsualDecidableType).



Import VarType.



Definition TVar := VarType.t.



Parameter gen_env : Type -> Type.



Section CoreDefinitions.



Variable A B : Type.



Definition eq_keys_dec := VarType.eq_dec.



Parameter empty : gen_env A.



Parameter single : TVar -> A -> gen_env A.

Parameter singles : list TVar -> list A -> gen_env A.



Parameter concat : gen_env A -> gen_env A -> gen_env A.



Parameter get : TVar -> gen_env A -> option A.



Parameter dom : gen_env A -> list TVar.

Parameter img : gen_env A -> list A.



Axiom belongs : TVar -> gen_env A -> Prop.

Axiom all_belongs : list TVar -> gen_env A -> Prop.



Axiom notin  : TVar -> gen_env A -> Prop.

Axiom all_notin : list TVar -> gen_env A -> Prop.



Parameter map : (A -> B) -> gen_env A -> gen_env B.



Parameter update_one : gen_env A -> TVar -> A -> gen_env A.

Parameter update : gen_env A -> gen_env A -> gen_env A.



Parameter remove : TVar -> gen_env A -> gen_env A.

Parameter all_remove : list TVar -> gen_env A -> gen_env A.



Inductive ok : gen_env A -> Prop :=

| ok_nil : ok empty

| ok_cons : forall x v F, ok F ∧ notin x F -> ok (concat F (single x v))

.



End CoreDefinitions.



Notation "x '∶' v" := (single x v)

  (at level 63) : gen_env_scope.



Notation "xs '∷' vs" := (singles xs vs)

  (at level 63) : gen_env_scope.



Notation "E '&' F" := (concat E F) 

  (at level 65, left associativity) : gen_env_scope.



Notation "E '∖' '{' x '}'" := (remove x E) 

  (at level 64, left associativity) : gen_env_scope.



Notation "E '∖' xs" := (all_remove xs E) 

  (at level 64, left associativity) : gen_env_scope.



Notation "E '[' x '<-' v ']'" := (update_one E x v) 

  (at level 65, left associativity) : gen_env_scope.



Notation "E '::=' F" := (update E F) 

  (at level 65, left associativity) : gen_env_scope.



Notation "x '∈' E" := (belongs x E)

  (at level 67) : gen_env_scope.



Notation "xs '⊂' E" := (all_belongs xs E)

  (at level 67) : gen_env_scope.



Notation "x '∉' E" := (notin x E)

  (at level 67) : gen_env_scope.



Notation "xs '⊄' E" := (all_notin xs E)

  (at level 67) : gen_env_scope.



Bind Scope gen_env_scope with gen_env.

Delimit Scope gen_env_scope with gen_env.

Local Open Scope gen_env_scope.



Section Properties.

Implicit Types x y : TVar.

Implicit Types xs ys : list TVar.



Axiom env_ind : forall A, forall P : gen_env A -> Prop,

  (P (@empty A)) ->

  (forall (E : gen_env A) x (v : A), P E -> P (E & (x ∶ v))) ->

  (forall (E : gen_env A), P E).



Axiom singles_empty : forall A,

  nil ∷ nil = (@empty A).

Axiom singles_cons : forall A x xs (v : A) (vs : list A),

  (x :: xs) ∷ (v :: vs) = (xs ∷ vs) & (x ∶ v).



Axiom concat_empty_r : forall A (E : gen_env A),

  E & (@empty A) = E.

Axiom concat_empty_l : forall A (E : gen_env A),

  (@empty A) & E = E.

Axiom concat_assoc : forall A (E F G : gen_env A),

  E & (F & G) = (E & F) & G.



Axiom get_empty : forall A x,

  get x (@empty A) = None.



Axiom get_single_eq : forall A x y (v : A),

  x = y ->

  get x (y ∶ v) = Some v.

Axiom get_single_eq_inv : forall A x y (v w : A),

  get x (y ∶ w) = Some v ->

  x = y /\ v = w.



Axiom get_dec : forall A x (E : gen_env A),

   { v : A | get x E = Some v } + { get x E = None }.



Axiom get_concat_r : forall A x y (v : A) (E : gen_env A),

  x = y ->

  get x (E & (y ∶ v)) = Some v.

Axiom get_concat_l : forall A x y (v : A) (E : gen_env A),

  x <> y ->

  get x (E & (y ∶ v)) = get x E.

Axiom get_concat_inv : forall A x y (v w : A) (E : gen_env A),

  get x (E & (y ∶ v)) = Some w ->

  (x = y /\ v = w) \/ (x <> y /\ get x E = Some w).



Axiom dom_empty : forall A,

  dom (@empty A) = nil.

Axiom dom_empty_inv : forall A (E : gen_env A),

  dom (E) = nil ->

  E = (@empty A).

Axiom dom_single : forall A x (v : A),

  dom (x ∶ v) = (x :: nil).

Axiom dom_singles : forall A xs (vs : list A),

  length xs = length vs ->

  dom (xs ∷ vs) = xs.

Axiom dom_singles_incl : forall A xs (vs : list A),

  List.incl (dom (xs ∷ vs)) xs.

Axiom dom_concat : forall A (E F : gen_env A),

  dom (E & F) = List.app (dom F) (dom E).



Axiom img_empty : forall A,

  img (@empty A) = nil.

Axiom img_empty_inv : forall A (E : gen_env A),

  img (E) = nil ->

  E = (@empty A).

Axiom img_single : forall A x (v : A),

  img (x ∶ v) = v :: nil.

Axiom img_singles : forall A xs (vs : list A),

  length xs = length vs ->

  img (xs ∷ vs) = vs.

Axiom img_singles_incl : forall A xs (vs : list A),

  List.incl (img (xs ∷ vs)) vs.

Axiom img_concat : forall A (E F : gen_env A),

  img (E & F) = List.app (img F) (img E).



Axiom dom_img_id : forall A (E : gen_env A),

  (dom E) ∷ (img E) = E.

Axiom length_dom_img_eq : forall A (E : gen_env A),

  length (dom E) = length (img E).



Axiom belongs_empty : forall A x,

  x ∈ (@empty A) ->

  False.



Axiom belongs_single : forall A x y (v : A),

  x = y ->

  x ∈ (y ∶ v).

Axiom belongs_single_inv : forall A x y (v : A),

  x ∈ (y ∶ v) ->

  x = y.

Axiom belongs_singles : forall A x xs (vs : list A),

  length xs = length vs ->

  List.In x xs ->

  x ∈ (xs ∷ vs).

Axiom belongs_singles_inv : forall A x xs (vs : list A),

  length xs = length vs ->

  x ∈ (xs ∷ vs) ->

  List.In x xs.



Axiom belongs_concat_l : forall A x (F G : gen_env A),

  x ∈ F ->

  x ∈ (F & G).

Axiom belongs_concat_r : forall A x (F G : gen_env A),

  x ∈ F ->

  x ∈ (G & F).

Axiom belongs_concat_inv : forall A x (F G : gen_env A),

  x ∈ (F & G) ->

  x ∈ F ∨ x ∈ G.



Axiom belongs_dom : forall A x (E : gen_env A),

  x ∈ E ->

  List.In x (dom E).

Axiom belongs_dom_inv : forall A x (E : gen_env A),

  List.In x (dom E) ->

  x ∈ E.



Axiom all_belongs_def : forall A xs (E : gen_env A),

  (forall x, List.In x xs -> x ∈ E) ->

  xs ⊂ E.

Axiom all_belongs_def_inv : forall A xs (E : gen_env A),

  xs ⊂ E ->

  (forall x, List.In x xs -> x ∈ E).

Axiom all_belongs_belongs : forall A x xs (E : gen_env A),

  (x :: xs) ⊂ E ->

  x ∈ E ∧ xs ⊂ E.

Axiom belongs_all_belongs : forall A x xs (E : gen_env A),

  x ∈ E ∧ xs ⊂ E ->

  (x :: xs) ⊂ E.



Axiom all_belongs_empty : forall A xs,

  xs ⊂ (@empty A) ->

  xs = nil.

Axiom all_belongs_nil : forall A (E : gen_env A),

  nil ⊂ E.



Axiom all_belongs_single : forall A xs y (v : A),

  xs = y :: nil ->

  xs ⊂ (y ∶ v).

Axiom all_belongs_single_inv : forall A xs y (v : A),

  length xs = 1 ->

  xs ⊂ (y ∶ v) ->

  xs = y :: nil.

Axiom all_belongs_singles : forall A xs ys (vs : list A),

  length ys = length vs ->

  List.incl xs ys ->

  xs ⊂ (ys ∷ vs).

Axiom all_belongs_singles_inv : forall A xs ys (vs : list A),

  xs ⊂ (ys ∷ vs) ->

  List.incl xs ys.



Axiom all_belongs_concat_l : forall A xs (F G : gen_env A),

  xs ⊂ F ->

  xs ⊂ (F & G).

Axiom all_belongs_concat_r : forall A xs (F G : gen_env A),

  xs ⊂ F ->

  xs ⊂ (G & F).



Axiom all_belongs_dom : forall A xs (E : gen_env A),

  xs ⊂ E ->

  List.incl xs (dom E).

Axiom all_belongs_dom_inv : forall A xs (E F : gen_env A),

  List.incl xs (dom E) ->

  xs ⊂ E.



Axiom notin_belongs : forall A x (E : gen_env A),

  x ∉ E ->

  ¬ x ∈ E.

Axiom belongs_notin : forall A x (E : gen_env A),

  x ∈ E ->

  ¬ x ∉ E.

Axiom not_belongs_notin : forall A x (E : gen_env A),

  ¬ x ∈ E ->

  x ∉ E.

Axiom notin_belongs_neq : forall A x y (E : gen_env A),

  x ∈ E -> y ∉ E ->

  x <> y.



Axiom notin_empty : forall A x,

  x ∉ (@empty A).



Axiom notin_single : forall A x y (v : A),

  x <> y ->

  x ∉ (y ∶ v).

Axiom notin_single_inv : forall A x y (v : A),

  x ∉ (y ∶ v) ->

  x <> y.

Axiom notin_singles : forall A x xs (vs : list A),

  ¬ List.In x xs ->

  x ∉ (xs ∷ vs).

Axiom notin_singles_inv : forall A x xs (vs : list A),

  length xs = length vs ->

  x ∉ (xs ∷ vs) ->

  ¬ List.In x xs.



Axiom notin_concat : forall A x (F G : gen_env A),

  x ∉ F -> x ∉ G ->

  x ∉ (F & G).

Axiom notin_concat_inv : forall A x (F G : gen_env A),

  x ∉ (F & G) ->

  x ∉ F ∧ x ∉ G.



Axiom notin_dom : forall A x (E : gen_env A),

  x ∉ E ->

  ¬ List.In x (dom E).

Axiom notin_dom_inv : forall A x (E F : gen_env A),

  ¬ List.In x (dom E) ->

  x ∉ E.



Axiom all_notin_empty_l : forall A (E : gen_env A),

  nil ⊄ E.



Axiom all_notin_def : forall A xs (E : gen_env A),

  (forall x, List.In x xs -> x ∉ E) ->

  xs ⊄ E.

Axiom all_notin_def_inv : forall A xs (E : gen_env A),

  xs ⊄ E ->

  (forall x, List.In x xs -> x ∉ E).

Axiom all_notin_notin : forall A x xs (E : gen_env A),

  (x :: xs) ⊄ E ->

  x ∉ E ∧ xs ⊄ E.

Axiom notin_all_notin : forall A x xs (E : gen_env A),

  x ∉ E ∧ xs ⊄ E ->

  (x :: xs) ⊄ E.



Axiom all_notin_belongs_neq : forall A x ys (E : gen_env A),

  x ∈ E -> ys ⊄ E ->

  ¬ List.In x ys.



Axiom all_notin_empty_r : forall A xs,

  xs ⊄ (@empty A).



Axiom all_notin_single : forall A xs y (v : A),

  ¬ List.In y xs ->

  xs ⊄ (y ∶ v).

Axiom all_notin_single_inv : forall A xs y (v : A),

  xs ⊄ (y ∶ v) ->

  ¬ List.In y xs.

Axiom all_notin_singles : forall A xs ys (vs : list A),

  List.Forall (fun x => ¬ List.In x ys) xs ->

  xs ⊄ (ys ∷ vs).

Axiom all_notin_singles_inv : forall A xs ys (vs : list A),

  length ys = length vs ->

  xs ⊄ (ys ∷ vs) ->

  List.Forall (fun x => ¬ List.In x ys) xs.



Axiom all_notin_concat : forall A xs (F G : gen_env A),

  xs ⊄ F -> xs ⊄ G ->

  xs ⊄ (F & G).

Axiom all_notin_concat_inv : forall A xs (F G : gen_env A),

  xs ⊄ (F & G) ->

  xs ⊄ F ∧ xs ⊄ G.



Axiom all_notin_dom : forall A xs (E : gen_env A),

  xs ⊄ E ->

  List.Forall (fun x => ¬ List.In x (dom E)) xs.

Axiom all_notin_dom_inv : forall A xs (E : gen_env A),

  List.Forall (fun x => ¬ List.In x (dom E)) xs ->

  xs ⊄ E.



Axiom map_empty : forall A B (f : A -> B),

  map f (@empty A) = (@empty B).

Axiom map_single : forall A B (f : A -> B) x (v : A),

  map f (x ∶ v) = x ∶ (f v).

Axiom map_singles : forall A B (f : A -> B) xs (vs : list A),

  map f (xs ∷ vs) = xs ∷ (List.map f vs).



Axiom map_concat : forall A B (f : A -> B) (E F : gen_env A),

  map f (E & F) = (map f E) & (map f F).



Axiom dom_map : forall A B (E : gen_env A) (f : A -> B),

  dom (map f E) = dom E.



Axiom belongs_map : forall A B x (E : gen_env A) (f : A -> B),

  x ∈ E ->

  x ∈ (map f E).

Axiom belongs_map_inv : forall A B x (E : gen_env A) (f : A -> B),

  x ∈ (map f E) ->

  x ∈ E.



Axiom all_belongs_map : forall A B xs (E : gen_env A) (f : A -> B),

  xs ⊂ E ->

  xs ⊂ (map f E).

Axiom all_belongs_map_inv : forall A B xs (E : gen_env A) (f : A -> B),

  xs ⊂ (map f E) ->

  xs ⊂ E.



Axiom notin_map : forall A B x (E : gen_env A) (f : A -> B),

  x ∉ E ->

  x ∉ (map f E).

Axiom notin_map_inv : forall A B x (E : gen_env A) (f : A -> B),

  x ∉ (map f E) ->

  x ∉ E.



Axiom all_notin_map : forall A B xs (E : gen_env A) (f : A -> B),

  xs ⊄ E ->

  xs ⊄ (map f E).

Axiom all_notin_map_inv : forall A B xs (E : gen_env A) (f : A -> B),

  xs ⊄ (map f E) ->

  xs ⊄ E.



Axiom ok_map : forall A B (E : gen_env A) (f : A -> B),

  ok E ->

  ok (map f E).

Axiom ok_map_inv : forall A B (E : gen_env A) (f : A -> B),

  ok (map f E) ->

  ok E.



Axiom update_one_empty : forall A x (v : A),

  (@empty A) [x <- v] = (@empty A).



Axiom update_one_single : forall A x y (v w : A),

  x = y ->

  (x ∶ v) [y <- w] = (x ∶ w).

Axiom update_one_single_neq : forall A x y (v w : A),

  x <> y ->

  (x ∶ v) [y <- w] = (x ∶ v).



Axiom update_one_concat_r : forall A x (v : A) (E F : gen_env A),

  x ∈ F ->

  (E & F) [x <- v] = E & (F [x <- v]).

Axiom update_one_concat_l : forall A x (v : A) (E F : gen_env A),

  x ∉ F ->

  (E & F) [x <- v] = (E [x <- v]) & F.



Axiom dom_update_one : forall A x (v : A) (E : gen_env A),

  dom (E [x <- v]) = dom E.



Axiom belongs_update_one : forall A x y (v : A) (E : gen_env A),

  y ∈ E ->

  y ∈ (E [x <- v]).

Axiom belongs_update_one_inv : forall A x y (v : A) (E : gen_env A),

  y ∈ (E [x <- v]) ->

  y ∈ E.



Axiom all_belongs_update_one : forall A x xs (v : A) (E : gen_env A),

  xs ⊂ E ->

  xs ⊂ (E [x <- v]).

Axiom all_belongs_update_one_inv : forall A x xs (v : A) (E : gen_env A),

  xs ⊂ (E [x <- v]) ->

  xs ⊂ E.



Axiom notin_update_one : forall A x y (v : A) (E : gen_env A),

  y ∉ E ->

  y ∉ (E [x <- v]).

Axiom notin_update_one_inv : forall A x y (v : A) (E : gen_env A),

  y ∉ (E [x <- v]) ->

  y ∉ E.



Axiom all_notin_update_one : forall A x xs (v : A) (E : gen_env A),

  xs ⊄ E ->

  xs ⊄ (E [x <- v]).

Axiom all_notin_update_one_inv : forall A x xs (v : A) (E : gen_env A),

  xs ⊄ (E [x <- v]) ->

  xs ⊄ E.



Axiom update_one_notin : forall A x (v : A) (E : gen_env A),

  x ∉ E ->

  E [x <- v] = E.



Axiom map_update_one : forall A B (f : A -> B) x (v : A) (E : gen_env A),

  map f (E [x <- v]) = (map f E) [x <- f v].



Axiom ok_update_one : forall A x (v : A) (E : gen_env A),

  ok E ->

  ok (E [x <- v]).

Axiom ok_update_one_inv : forall A x (v : A) (E : gen_env A),

  ok (E [x <- v]) ->

  ok E.



Axiom update_empty_r : forall A (E : gen_env A),

  E ::= (@empty A) = E.

Axiom update_empty_l : forall A (E : gen_env A),

  (@empty A) ::= E = (@empty A).



Axiom update_update_one : forall A x (v : A) (E : gen_env A),

  E ::= (x ∶ v) = E [x <- v].

Axiom update_single_single : forall A x y (v w : A),

  x = y ->

  (x ∶ v) ::= (y ∶ w) = (x ∶ w).

Axiom update_single_single_neq : forall A x y (v w : A),

  x <> y ->

  (x ∶ v) ::= (y ∶ w) = (x ∶ v).



Axiom update_concat_r : forall A (E F G : gen_env A),

  E ::= (F & G) = (E ::= F) ::= G.



Axiom dom_update : forall A (E F : gen_env A),

  dom (E ::= F) = dom E.



Axiom belongs_update : forall A x (E F : gen_env A),

  x ∈ E ->

  x ∈ (E ::= F).

Axiom belongs_update_inv : forall A x (E F : gen_env A),

  x ∈ (E ::= F) ->

  x ∈ E.



Axiom all_belongs_update : forall A xs (E F : gen_env A),

  xs ⊂ E ->

  xs ⊂ (E ::= F).

Axiom all_belongs_update_inv : forall A xs (E F : gen_env A),

  xs ⊂ (E ::= F) ->

  xs ⊂ E.



Axiom notin_update : forall A x (E F : gen_env A),

  x ∉ E ->

  x ∉ (E ::= F).

Axiom notin_update_inv : forall A x (E F : gen_env A),

  x ∉ (E ::= F) ->

  x ∉ E.



Axiom all_notin_update : forall A xs (E F : gen_env A),

  xs ⊄ E ->

  xs ⊄ (E ::= F).

Axiom all_notin_update_inv : forall A xs (E F : gen_env A),

  xs ⊄ (E ::= F) ->

  xs ⊄ E.



Axiom update_notin : forall A (E F : gen_env A),

  (dom F) ⊄ E ->

  E ::= F = E.



Axiom map_update : forall A B (f : A -> B) (E F : gen_env A),

  map f (E ::= F) = (map f E) ::= (map f F).



Axiom ok_update : forall A (E F : gen_env A),

  ok E ->

  ok (E ::= F).

Axiom ok_update_inv : forall A (E F : gen_env A),

  ok (E ::= F) ->

  ok E.



Axiom remove_empty : forall A x,

  (@empty A) ∖ {x} = (@empty A).



Axiom remove_single_eq : forall A x y (v : A),

  x = y ->

  (x ∶ v) ∖ {y} = (@empty A).

Axiom remove_single_neq : forall A x y (v : A),

  x <> y ->

  (x ∶ v) ∖ {y} = (x ∶ v).



Axiom remove_notin : forall A x (E : gen_env A),

  x ∉ E ->

  E ∖ {x} = E.

Axiom notin_remove_notin : forall A x y (E : gen_env A),

  x ∉ E ->

  x ∉ (E ∖ {y}).

Axiom all_notin_remove_notin : forall A xs y (E : gen_env A),

  xs ⊄ E ->

  xs ⊄ (E ∖ {y}).

Axiom belongs_remove : forall A x y (E : gen_env A),

  x <> y -> x ∈ E ->

  x ∈ (E ∖ {y}).

Axiom belongs_remove_inv : forall A x y (E : gen_env A),

  ok E ->

  x ∈ (E ∖ {y}) -> x <> y.



Axiom remove_belongs_concat_r : forall A x (E F : gen_env A),

  x ∈ F ->

  (E & F) ∖ {x} = E & (F ∖ {x}).

Axiom remove_belongs_concat_l : forall A x (E F : gen_env A),

  x ∉ F ->

  (E & F) ∖ {x} = (E ∖ {x}) & F.



Axiom remove_ok_notin : forall A x (E : gen_env A),

  ok E ->

  x ∉ (E ∖ {x}).

Axiom remove_all_belongs : forall A x xs (F : gen_env A),

  ¬ List.In x xs -> (x :: xs) ⊂ F ->

  xs ⊂ (F ∖ {x}).



Axiom remove_map : forall A B (f : A -> B) (E : gen_env A) x,

  (map f E) ∖ {x} = map f (E ∖ {x}).

Axiom remove_update : forall A x (E F : gen_env A),

  ok E ->

  (E ::= F) ∖ {x} = (E ∖ {x}) ::= F.

Axiom remove_update_eq : forall A x y (v : A) (E : gen_env A),

  x = y ->

  (E ::= (y ∶ v)) ∖ {x} = E ∖ {x}.



Axiom ok_remove : forall A x (E : gen_env A),

  ok E ->

  ok (E ∖ {x}).



Axiom all_remove_remove : forall A x xs (E : gen_env A),

  E ∖ (x :: xs) = (E ∖ {x}) ∖ xs.



Axiom all_remove_empty : forall A xs,

  (@empty A) ∖ xs = (@empty A).

Axiom all_remove_nil : forall A (E : gen_env A),

  E ∖ nil = E.



Axiom all_remove_single_in : forall A x xs (v : A),

  List.In x xs ->

  (x ∶ v) ∖ xs = (@empty A).

Axiom all_remove_single_not_in : forall A x xs (v : A),

  ¬ List.In x xs ->

  (x ∶ v) ∖ xs = (x ∶ v).



Axiom all_remove_singles_in : forall A xs ys (vs : list A),

  xs = ys -> length xs = length vs ->

  (xs ∷ vs) ∖ ys = (@empty A).

Axiom all_remove_singles_not_in : forall A xs ys (vs : list A),

  List.Forall (fun x => ¬ List.In x xs) ys ->

  (xs ∷ vs) ∖ ys = (xs ∷ vs).



Axiom all_remove_notin : forall A xs (E : gen_env A),

  xs ⊄ E ->

  E ∖ xs = E.

Axiom notin_all_remove_notin : forall A x ys (E : gen_env A),

  x ∉ E ->

  x ∉ (E ∖ ys).

Axiom all_notin_all_remove_notin : forall A xs ys (E : gen_env A),

  xs ⊄ E ->

  xs ⊄ (E ∖ ys).



Axiom all_remove_ok_notin : forall A xs (E : gen_env A),

  ok E ->

  xs ⊄ (E ∖ xs).



Axiom all_remove_belongs_concat_r : forall A xs (E F : gen_env A),

  List.NoDup xs ->

  xs ⊂ F ->

  (E & F) ∖ xs = E & (F ∖ xs).

Axiom all_remove_belongs_concat_l : forall A xs (E F : gen_env A),

  xs ⊄ F ->

  (E & F) ∖ xs = (E ∖ xs) & F.



Axiom all_remove_map : forall A B (f : A -> B) (E : gen_env A) xs,

  (map f E) ∖ xs = map f (E ∖ xs).

Axiom all_remove_update : forall A xs (E F : gen_env A),

  ok E ->

  (E ::= F) ∖ xs = (E ∖ xs) ::= F.



Axiom ok_all_remove : forall A xs (E : gen_env A),

  ok E ->

  ok (E ∖ xs).



Axiom ok_empty : forall A,

  ok (@empty A).

Axiom ok_single : forall A x (v : A),

  ok (x ∶ v).



Axiom ok_singles : forall A xs (vs : list A),

  List.NoDup xs ->

  ok (xs ∷ vs).

Axiom ok_singles_inv : forall A xs (vs : list A),

  length xs = length vs ->

  ok (xs ∷ vs) ->

  List.NoDup xs.



Axiom ok_concat : forall A (E F : gen_env A),

  ok E -> ok F ->

  (dom E) ⊄ F -> (dom F) ⊄ E ->

  ok (E & F).

Axiom ok_concat_inv : forall A (E F : gen_env A),

  ok (E & F) ->

  ok E ∧ ok F ∧ (dom E) ⊄ F ∧ (dom F) ⊄ E.

Axiom ok_concat_comm : forall A (E F : gen_env A),

  ok (E & F) ->

  ok (F & E).



Axiom belongs_ok_concat_inv_l : forall A x (F G : gen_env A),

  ok (F & G) ->

  x ∈ F ->

  x ∉ G.

Axiom belongs_ok_concat_inv_r : forall A x (F G : gen_env A),

  ok (F & G) ->

  x ∈ G ->

  x ∉ F.

Axiom concat_not_ok : forall A x (F G : gen_env A),

  x ∈ F -> x ∈ G ->

  ¬ ok (F & G).



Axiom update_concat_l : forall A (E F G : gen_env A),

  ok (E & F) ->

  (E & F) ::= G = (E ::= G) & (F ::= G).



End Properties.



End CoreGenericEnvironmentType.

