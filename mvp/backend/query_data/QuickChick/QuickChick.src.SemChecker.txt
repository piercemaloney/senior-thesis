Set Warnings "-extraction-opaque-accessed,-extraction".

Set Warnings "-notation-overridden,-parsing".



Require Import mathcomp.ssreflect.ssreflect.

From mathcomp Require Import ssrbool ssrnat eqtype.

Require Import Show Sets GenLow GenHigh RoseTrees Checker Classes.
(* Show:
From Coq Require Import
     Ascii
     Basics
     Decimal
     List
     String
     ZArith.

Import ListNotations.
Local Open Scope program_scope.
Local Open Scope string_scope.

Delimit Scope string_scope with string.

Definition newline := String "010" ""%string.

Class Show (A : Type) : Type :=
{
  show : A -> string
}.

Fixpoint show_uint (n : uint) : string :=
  match n with
  | Nil => ""
  | D0 n => String "0" (show_uint n)
  | D1 n => String "1" (show_uint n)
  | D2 n => String "2" (show_uint n)
  | D3 n => String "3" (show_uint n)
  | D4 n => String "4" (show_uint n)
  | D5 n => String "5" (show_uint n)
  | D6 n => String "6" (show_uint n)
  | D7 n => String "7" (show_uint n)
  | D8 n => String "8" (show_uint n)
  | D9 n => String "9" (show_uint n)
  end.

Definition show_int (n : int) : string :=
  match n with
  | Pos n => show_uint n
  | Neg n => String "-" (show_uint n)
  end.

Definition show_nat (n : nat) : string :=
  show_uint (Nat.to_uint n).

Definition show_bool (b : bool) : string :=
  match b with
  | true => "true"
  | false => "false"
  end.

Definition show_Z (n : Z) : string :=
  show_int (Z.to_int n).

Definition show_N : N -> string :=
  show_Z âˆ˜ Z.of_N.

Instance showUint : Show uint :=
{|
  show := show_uint
|}.

Instance showInt : Show int :=
{|
  show := show_int
|}.

Instance showNat : Show nat :=
{|
  show := show_nat
|}.

Instance showBool : Show bool :=
{|
  show := show_bool
|}.

Instance showZ : Show Z :=
{|
  show := show_Z
|}.

Instance showN : Show N :=
{|
  show := show_N
|}.

Fixpoint from_list (s : list ascii) : string :=
  match s with
  | [] => EmptyString
  | c :: s' => String c (from_list s')
  end.

Definition unit_digit (n : nat) : ascii :=
  ascii_of_nat ((n mod 10) + 48 ).

Definition three_digit (n : nat) : string :=
  let n0 := unit_digit n in
  let n1 := unit_digit (n / 10) in
  let n2 := unit_digit (n / 100) in
  from_list [n2; n1; n0].

Definition digit_of_ascii (c : ascii) : option nat :=
  let n := nat_of_ascii c in
  if ((48 <=? n)%nat && (n <=? 57)%nat)%bool then
    Some (n - 48)
  else
    None.

Definition unthree_digit (c2 c1 c0 : ascii) : option ascii :=
  let doa := digit_of_ascii in
  match doa c2, doa c1, doa c0 with
  | Some n2, Some n1, Some n0 =>
    Some (ascii_of_nat (n2 * 100 + n1 * 10 + n0))
  | _, _, _ => None
  end.

Fixpoint show_quoted_string (s:string) : string :=
  match s with
  | EmptyString => """"
  | String c s' =>
    let quoted_s' := show_quoted_string s' in
    let n := nat_of_ascii c in
    if ascii_dec c "009"  then
      "\t" ++ quoted_s'
    else if ascii_dec c "010"  then
      "\n" ++ quoted_s'
    else if ascii_dec c "013"  then
      "\r" ++ quoted_s'
    else if ascii_dec c """"  then
      "\""" ++ quoted_s'
    else if ascii_dec c "\"  then
      "\\" ++ quoted_s'
    else if ((n <? 32)%nat 
         || (126 <? n)%nat )%bool then
      "\" ++ three_digit n ++ quoted_s'
    else
      String c quoted_s'
  end.

Instance showString : Show string :=
{|
  show s := String """" (show_quoted_string s)
|}.

Fixpoint read_quoted_string (s : string) : option string :=
  match s with
  | String c s' =>
    if ascii_dec c """" then
      match s' with
      | EmptyString => Some EmptyString
      | _ => None
      end
    else if ascii_dec c "\" then
      match s' with
      | String c2 s'' =>
        if ascii_dec c2 "n" then
          option_map (String "010") (read_quoted_string s'')
        else if ascii_dec c2 "r" then
          option_map (String "013") (read_quoted_string s'')
        else if ascii_dec c2 "t" then
          option_map (String "009") (read_quoted_string s'')
        else if ascii_dec c2 "\" then
          option_map (String "\") (read_quoted_string s'')
        else if ascii_dec c2 """" then
          option_map (String """") (read_quoted_string s'')
        else
          match s'' with
          | String c1 (String c0 s''') =>
            match unthree_digit c2 c1 c0 with
            | Some c' => option_map (String c')
                                    (read_quoted_string s''')
            | None => None
            end
          | _ => None
          end
      | _ => None
      end
    else
      option_map (String c) (read_quoted_string s')
  | _ => None
  end.

Definition read_string (s : string) : option string :=
  match s with
  | EmptyString => None
  | String c s' => read_quoted_string s'
  end.

Fixpoint contents {A : Type} (s : A -> string) (l : list A) : string :=
  match l with
    | nil => ""%string
    | cons h nil => s h
    | cons h t => append (append (s h) "; ") (contents s t)
  end.

Instance showList {A : Type} `{_ : Show A} : Show (list A) :=
{|
  show l := append "[" (append (contents show l) "]")
|}.

Instance showPair {A B : Type} `{_ : Show A} `{_ : Show B} : Show (A * B) :=
{|
  show p := match p with (a,b) => ("(" ++ show a ++ "," ++  show b ++ ")")%string end
|}.

Instance showOpt {A : Type} `{_ : Show A} : Show (option A) :=
{|
  show x := match x with
              | Some x => "Some " ++ (show x)
              | None => "None"
            end
|}.

Instance showType : Show Type :=
{|
  show x := "nat :-)"
|}.

Instance showEx {A} `{_ : Show A} P : Show ({x : A | P x}) :=
  {|
    show ex := let '(exist _ x _) := ex in show x
  |}.

Require Import Ascii.
Definition nl : string := String "010" EmptyString.

Definition smart_paren (s : string) : string :=
  let fix aux s (b : bool) :=
      match s with
        | EmptyString => (if b then ")" else "", b)
        | String a s =>
          let (s', b) := aux s (orb b (nat_of_ascii a =? 32)%nat) in
          (String a s', b)
      end in
  let (s', b) := aux s false in
  if b then "(" ++ s' else s'.

Module ShowFunctions.

Class ReprSubset (A : Type) :=
  { representatives : list A }.

Instance repr_bool : ReprSubset bool :=
  {| representatives := [ true; false ] |}.

Instance repr_nat : ReprSubset nat :=
  {| representatives := [ 0 ; 1 ; 2 ; 17 ; 42 ] |}.

Instance repr_option {A} `{_ : ReprSubset A} : ReprSubset (option A) :=
  {| representatives := None :: map Some representatives |}.

Instance repr_list {A} `{_ : ReprSubset A} : ReprSubset (list A) :=
  {| representatives :=
       [] :: map (fun x => [x]) representatives
          ++ flat_map (fun x : A =>
                         map (fun y : A => [x;y]) representatives
                      ) representatives
  |}%list.

Instance repr_prod {A B} `{_ : ReprSubset A} `{_ : ReprSubset B} :
  ReprSubset (A * B) :=
  {| representatives :=
       flat_map (fun x : A =>
                   map (fun y : B => (x,y)) representatives
                ) representatives
  |}.

Fixpoint prepend {A : Type} (a : A) (l : list A) :=
  match l with
    | [] => []
    | h::t => a :: h :: prepend a t
  end.

Definition intersperse {A : Type} (a : A) (l : list A) :=
  match l with
    | [] => []
    | h::t => h :: prepend a t
  end.

Definition string_concat (l : list string) : string :=
  fold_left (fun a b => a ++ b) l "".

Instance show_fun {A B} `{_ : Show A} `{_ : ReprSubset A}
         `{_ : Show B} : Show (A -> B) :=
  {| show f :=
       "{ " ++ string_concat (intersperse " , "
                            (map (fun x => show x ++ " |-> " ++ show (f x))
                                 (@representatives A _)))
           ++ " }"
  |}.

End ShowFunctions.

Definition trace {A : Type} (s : string) (a : A) : A := a.
Definition deprecate {A : Type} (old new: string) (a : A) : A :=
  trace ("Deprecated function: " ++ old ++ ". Use " ++ new ++ " instead.") a. *)
(* Sets:
Set Warnings "-extraction-opaque-accessed,-extraction".
Set Warnings "-notation-overridden,-parsing".

Require Import mathcomp.ssreflect.ssreflect.
Require Import Classes.RelationClasses Classes.Morphisms List Tactics.
From mathcomp Require Import ssrfun ssrbool ssrnat seq.

Import ListNotations.

Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Definition set T := T -> Prop.

Notation "x \in A" := (A x) (at level 70, only parsing) : set_scope.

Definition set_eq {A} (m1 m2 : set A) :=
  forall (a : A), m1 a <-> m2 a.

Infix "<-->" := set_eq (at level 70, no associativity) : set_scope.

Open Scope set_scope.

Lemma set_eq_trans T B (A C : set T) : A <--> B -> B <--> C -> A <--> C.

Lemma set_eq_symm {A} (s1 s2 : set A) :
  s1 <--> s2 -> s2 <--> s1.

Lemma set_eq_refl {A} (s : set A) :
  s <--> s.

Global Instance : forall T, Equivalence (@set_eq T).

Definition set_incl {A} (m1 m2 : set A) :=
  forall (a : A), m1 a -> m2 a.

Infix "\subset" := set_incl (at level 70, no associativity) : set_scope.

Notation "[ 'set' x : T | P ]" := (fun x : T => P)
  (at level 0, x at level 99, only parsing) : set_scope.
Notation "[ 'set' x | P ]" := [set x : _ | P]
  (at level 0, x, P at level 99, format "[ 'set'  x  |  P ]", only parsing) : set_scope.

Definition set0 {T} := [set _ : T | False].

Definition setT {T} := [set _ : T | True].

Notation "[ 'set' : T ]" := (@setT T)
  (at level 0, format "[ 'set' :  T ]") : set_scope.

Section setOpsDef.

Context {T U : Type}.
Implicit Types (a x : T) (A B : set T).

Definition set1 a := eq a.

Definition setU A B := [set x | x \in A \/ x \in B].

Definition setI A B := [set x | x \in A /\ x \in B].

Definition codom (f : T -> U) := [set y | exists x, f x = y].

Definition bigcup A (F : T -> set U) := [set x | exists i, i \in A /\ x \in F i].

Definition bigcap (A : set T) (F : T -> set U) :=
  [set x | forall (i : T), i \in A -> x \in F i].

End setOpsDef.

Definition imset {T U} (f : T -> U) A := bigcup A (fun x => set1 (f x)).

Definition setX T U (A : set T) (B : set U) := [set x | x.1 \in A /\ x.2 \in B].

Definition imset2 T U V (f : T -> U -> V) A1 A2 :=
  imset (prod_curry f) (setX A1 A2).

Definition codom2 T U V (f : T -> U -> V) := codom (prod_curry f).

Notation "[ 'set' a ]" := (set1 a)
  (at level 0, a at level 99, format "[ 'set'  a ]") : set_scope.
Notation "[ 'set' a : T ]" := [set (a : T)]
  (at level 0, a at level 99, format "[ 'set'  a   :  T ]") : set_scope.

Notation "A :|: B" := (setU A B) (at level 52, left associativity) : set_scope.
Notation "a |: A" := ([set a] :|: A) (at level 52, left associativity) : set_scope.

Notation "A :&: B" := (setI A B) (at level 48, left associativity) : set_scope.

Notation "f @: A" := (imset f A) (at level 24) : set_scope.

Notation "f @2: ( A , B )" := (imset2 f A B)
  (at level 24, format "f  @2:  ( A ,  B )") : set_scope.

Notation "\bigcup_ i F" := (bigcup setT (fun i => F))
  (at level 41, F at level 41, i at level 0,
           format "'[' \bigcup_ i '/  '  F ']'") : set_scope.
Notation "\bigcup_ ( i : t ) F" := (bigcup (@setT t) (fun i => F))
  (at level 41, F at level 41, i at level 50,
           format "'[' \bigcup_ ( i   :  t ) '/  '  F ']'", only parsing) : set_scope.
Notation "\bigcup_ ( i 'in' A ) F" := (bigcup A (fun i => F))
  (at level 41, F at level 41, i, A at level 50,
           format "'[' \bigcup_ ( i  'in'  A ) '/  '  F ']'") : set_scope.

Notation "\bigcap_ ( i 'in' A ) F" := (bigcap A (fun i => F))
  (at level 41, F at level 41, i, A at level 50,
           format "'[' \bigcap_ ( i  'in'  A ) '/  '  F ']'") : set_scope.

Definition lift {T} (S : set T) : set (option T) :=
  Some @: S :|: [set None].

Lemma subset_eqP T (A B : set T) : (A <--> B) <-> (A \subset B /\ B \subset A).

Lemma subset_trans T (A1 A2 A3 : set T) :
  A1 \subset A2 ->
  A2 \subset A3 ->
  A1 \subset A3.

Lemma subset_refl T (A : set T) : A \subset A.

Lemma subset_singl : 
  forall {T} (x y : T), [set x] \subset [set y] <-> y = x. 

Lemma subset_respects_set_eq_l :
  forall (T : Type) (s1 s2 s3 : set T),
    s1 <--> s3 -> s3 \subset s2 -> s1 \subset s2.

Lemma subset_respects_set_eq_r :
  forall (T : Type) (s1 s2 s3 : set T),
    s3 <--> s2 -> s1 \subset s2 -> s1 \subset s3.

Lemma subset_respects_set_eq :
  forall {T : Type} {s1 s2 s1' s2' : set T},
    s1 <--> s1' ->
    s2 <--> s2' ->
    s1' \subset s2' ->
    s1 \subset s2.

Lemma imsetT T U (f : T -> U) : f @: setT <--> codom f.

Lemma imset_id T (A : set T) : id @: A <--> A.

Lemma imset_incl {T U} (A B : set T) (f : T -> U):
  A \subset B -> 
  f @: A \subset f @: B.

Lemma imset_eq {T U} (A B : set T) (f : T -> U):
  A <--> B -> 
  f @: A <--> f @: B.

Lemma imset_in a b x (f : a -> b) (A : set a) :
  x \in A -> f x \in (f @: A).

Lemma imset_id_ext T (A : set T) f : (forall x, f x = x) -> f @: A <--> A.

Lemma imset_eq_ext a b (f g : a -> b) (A : set a) :
  (forall x, f x = g x) ->
  f @: A <--> g @: A.

Lemma coverE T (A : set T) : \bigcup_(x in A) [set x] <--> A.

Lemma setXT T U : setX [set: T] [set: U] <--> [set: T * U].

Lemma sub0set T (A : set T) : set0 \subset A.

Lemma bigcup_set0 T U (F : T -> set U) :
  \bigcup_(x in set0) F x <--> set0.

Lemma imset0 T U (f : T -> U) : f @: set0 <--> set0.

Lemma bigcup_set1 T U (F : T -> set U) y :
  \bigcup_(x in [set y]) F x <--> F y.

Lemma bigcup_setU_l:
  forall (U T : Type) (s1 s2 : set U) (f : U -> set T),
  \bigcup_(i in (s1 :|: s2)) f i <-->
  \bigcup_(i in s1) f i :|: \bigcup_(i in s2) f i.

Lemma bigcup_const A B (P : set B) : inhabited A -> (\bigcup_(_ : A) P) <--> P.

Lemma bigcup_const_2 A (x :A) B (P : set B) : (\bigcup_(_ in [set x]) P) <--> P.

Lemma bigcupC T U V A B (F : T -> U -> set V) :
  \bigcup_(i in A) \bigcup_(j in B) F i j <-->
  \bigcup_(j in B) \bigcup_(i in A) F i j.

Lemma incl_bigcupr T U A (F : T -> set U) G : (forall x, F x \subset G x) ->
  \bigcup_(x in A) F x \subset \bigcup_(x in A) G x.

Lemma eq_bigcupr T U A (F : T -> set U) G : (forall x, F x <--> G x) ->
  \bigcup_(x in A) F x <--> \bigcup_(x in A) G x.

Lemma incl_bigcupl T U A B (F : T -> set U) : A \subset B ->
  \bigcup_(x in A) F x \subset \bigcup_(x in B) F x.

Lemma eq_bigcupl T U A B (F : T -> set U) : A <--> B ->
  \bigcup_(x in A) F x <--> \bigcup_(x in B) F x.

Lemma incl_bigcup a b (x:a) (A : set a) (f:a->set b) :
  x \in A -> 
  f x \subset \bigcup_(x in A) f x.

Arguments eq_bigcupl [T U A] B F _ _.

Global Instance eq_bigcup T U : Proper (set_eq ==> pointwise_relation T (@set_eq U) ==> set_eq) bigcup.

Lemma bigcup_flatten T U V A (F : T -> set U) (G : U -> set V) :
  \bigcup_(x in \bigcup_(y in A) F y) G x <-->
  \bigcup_(y in A) \bigcup_(x in F y) G x.

Lemma codom_apply {A B : Type} {f : A -> B} {x : A} : f x \in codom f.

Lemma codomE T U (f : T -> U) : codom f <--> \bigcup_x [set f x].

Lemma codom_id T : codom id <--> [set: T].

Lemma codom_const A B (x : B) : inhabited A ->
  codom (fun _ : A => x) <--> [set x].

Lemma imset_comp T U V (f : U -> T) (g : V -> U) A :
  (f \o g) @: A <--> f @: (g @: A).

Lemma codom_comp T U V (f : U -> T) (g : V -> U) :
  codom (f \o g) <--> f @: (codom g).

Lemma curry_imset2l T U V (f : T -> U -> V) A1 A2 :
  f @2: (A1, A2) <--> \bigcup_(x1 in A1) f x1 @: A2.

Lemma curry_imset2r T U V (f : T -> U -> V) A1 A2 :
  f @2: (A1, A2) <--> \bigcup_(x2 in A2) f^~ x2 @: A1.

Lemma curry_codom2l T U V (f : T -> U -> V) :
  codom (prod_curry f) <--> \bigcup_x1 codom (f x1).

Lemma imset_bigcup T U V (f : U -> V) A (F : T -> set U) :
  (f @: \bigcup_(x in A) (F x)) <--> \bigcup_(x in A) f @: F x.

Lemma bigcup_imset T U V (f : T -> U) A (F : U -> set V) :
  \bigcup_(y in f @: A) (F y) <--> \bigcup_(x in A) F (f x).

Lemma bigcup_codom T U V (f : T -> U) (F : U -> set V) :
  \bigcup_(y in codom f) (F y) <--> \bigcup_x F (f x).

Coercion seq_In T : seq T -> set T := fun s x => List.In x s.
Coercion list_In T : list T -> set T := fun s x => List.In x s.

Lemma subnilset T (A : set T) : [::] \subset A.

Lemma subconsset T (A : set T) x s :
  x :: s \subset A <-> x \in A /\ s \subset A.

Lemma reindex_bigcup I J K (h : J -> I) (F : I -> set K) A B :
  h @: B <--> A ->
  \bigcup_(x in A) F x <--> \bigcup_(y in B) F (h y).
Arguments reindex_bigcup [I J K] h [F A] B _ _.

Lemma bigcup_pointwise_incl A B (s : set A) (t : A -> set B) (u : set B) :
  (forall x, x \in s -> t x \subset u) ->
  \bigcup_(x in s) t x \subset u.

Lemma setI_comm {U} (s1 s2 : set U) : 
   s1 :&: s2 <--> s2 :&: s1.

Lemma setU_comm {U} (s1 s2 : set U) : 
   s1 :|: s2 <--> s2 :|: s1.

Lemma setI_set0_abs {U} (s : set U) :
  (s :&: set0) <--> set0.

Lemma setU_set0_neut {U} (s : set U) :
  (s :|: set0) <--> s.

Lemma setU_set0_neut_eq {A} (s s1 : set A) :
  s1 <--> set0 ->
  s <--> s :|: s1.

Lemma setU_set0_l {A} (s1 s2 s3 : set A) :
  s1 <--> set0 ->
  s2 <--> s3 ->
  (s1 :|: s2) <--> s3. 

Lemma setU_set0_r {A} (s1 s2 s3 : set A) :
  s1 <--> set0 ->
  s3 <--> s2 ->
  s3 <--> (s1 :|: s2). 

Lemma setI_setT_neut {U} (s : set U) :
  (s :&: setT) <--> s.

Lemma setU_setT_abs {U} (s : set U) :
  (s :|: setT) <--> setT.

Lemma setU_set_eq_compat {T} (s1 s2 s1' s2' : set T) :
  s1 <--> s1' ->
  s2 <--> s2' ->
  s1 :|: s2 <--> s1' :|: s2'.

Lemma setU_set_subset_compat :
  forall (T : Type) (s1 s2 s1' s2' : set T),
    s1 \subset s1' -> s2 \subset s2' -> s1 :|: s2 \subset s1' :|: s2'.

Lemma setU_set_incl_r :
  forall (T : Type) (s1 s2 s2' : set T),
    s1 \subset s2' -> s1 \subset s2 :|: s2'.

Lemma setU_assoc {U} (s1 s2 s3 : set U) :
  (s1 :|: (s2 :|: s3)) <--> ((s1 :|: s2) :|: s3).

Lemma setI_assoc {U} (s1 s2 s3 : set U) :
  (s1 :&: (s2 :&: s3)) <--> ((s1 :&: s2) :&: s3).

Lemma setI_impl_l {T} (s1 s2 : set T) : s1 \subset s2 -> s1 :&: s2 <--> s1.

Lemma setI_impl_r {T} (s1 s2 : set T) : s2 \subset s1 -> s1 :&: s2 <--> s2.

Lemma setI_set0 {U} (s1 s2 : set U) : 
  (forall x, s1 x -> ~ s2 x) ->
  (s1 :&: s2) <--> set0.

Lemma setI_subset_compat {U} (s1 s2 s1' s2' : set U) : 
  s1 \subset s1' ->
  s2 \subset s2' ->
  (s1 :&: s2) \subset (s1' :&: s2').

Lemma setU_subset_r {U} (s1 s2 s3 : set U) : 
  s1 \subset s3 ->
  s1 \subset (s2 :|: s3).

Lemma setU_subset_l {U} (s1 s2 s3 : set U) : 
  s1 \subset s2 ->
  s1 \subset (s2 :|: s3).

Lemma setI_setU_distr {U} (s1 s2 s3 : set U) : 
  ((s1 :|: s2) :&: s3) <--> ((s1 :&: s3) :|: (s2 :&: s3)).

Lemma bigcap_set0 (T U : Type) (F : T -> set U) :
  \bigcap_(x in set0) F x <--> setT.

Lemma incl_bigcapl T U A B (F : T -> set U) : B \subset A ->
  \bigcap_(x in A) F x \subset \bigcap_(x in B) F x.

Lemma eq_bigcapr (T U : Type) (A : set T) (F G : T -> set U) :
  (forall x : T, F x <--> G x) ->
  \bigcap_(x in A) F x <--> \bigcap_(x in A) G x.

Lemma eq_bigcapl T U A B (F : T -> set U) : A <--> B ->
  \bigcap_(x in A) F x <--> \bigcap_(x in B) F x.

Lemma eq_bigcup' :
  forall (T U : Type) (A B : set T) (F G : T -> set U),
    A <--> B ->
    (forall x, F x <--> G x) ->
    \bigcup_(x in A) F x <--> \bigcup_(x in B) G x.

Lemma incl_bigcup_compat :
  forall (T U : Type) (A B : set T) (F G : T -> set U),
    A \subset B ->
    (forall x : T, F x \subset G x) ->
    \bigcup_(x in A) F x \subset \bigcup_(x in B) G x.

Lemma bigcap_setI_l {U T} (s1 s2 : set U) (f : U -> set T) :
  bigcap (s1 :|: s2) f <-->
  bigcap s1 f :&: bigcap s2 f.

Lemma bigcap_setU_l {U T} (s1 s2 : set U) (f : U -> set T) :
  bigcap s1 f \subset bigcap (s1 :&: s2) f.

Lemma bigcap_set1 {U T} (x : U) (f : U -> set T) :
  bigcap [set x] f <--> f x.

Lemma bigcup_set0_r (T U : Type) (s : set T) (F : T -> set U) :
  (forall x, F x <--> set0) ->
  \bigcup_(x in s) F x <--> set0.

Lemma bigcup_set0_l_eq (T U : Type) (s : set T) (F : T -> set U) :
  s <--> set0 ->
  \bigcup_(x in s) F x <--> set0.

Lemma nil_set_eq {A : Type} :
  [::] <--> (@set0 A).

Lemma cons_set_eq {A} (x : A) l :
  (x :: l) <--> [set x] :|: l.

Lemma singl_set_eq: forall (A : Type) (x : A), [ x ] <--> [ set x ].

Lemma incl_subset {A : Type} (l1 l2 : seq A) :
  incl l1 l2 -> l1 \subset l2.

Lemma incl_hd_same {A : Type} (a : A) (l1 l2 : seq A) :
  incl l1 l2 -> incl (a :: l1) (a :: l2).
     
Lemma setI_bigcup_assoc {A B} (s1 : set B) (s2 : set A) (s3 : A -> set B) :
  s1 :&: (\bigcup_(x in s2) s3 x) <--> \bigcup_(x in s2) (s1 :&: (s3 x)).

Lemma cons_subset {A : Type} (x : A) (l : seq A) (P : set A) :
  P x ->
  l \subset P ->
  (x :: l) \subset P.

Lemma nil_subset {A : Type} (P : set A) :
  [] \subset P.

Lemma imset_union_incl {U T : Type} (s1 s2 : set U) (f : U -> T) :
  f @: (s1 :|: s2) \subset (f @: s1) :|: (f @: s2).

Lemma imset_singl_incl {U T : Type} (x : U) (f : U -> T) :
  f @: [set x] \subset [set (f x)].

Lemma imset_set0_incl  {U T : Type} (f : U -> T) :
  f @: set0 \subset set0.

Lemma set_eq_set_incl_r {U : Type} (s1 s2 : set U) :
  s1 <--> s2 -> s2 \subset s1.

Lemma set_eq_set_incl_l {U : Type} (s1 s2 : set U) :
  s1 <--> s2 -> s1 \subset s2.

Lemma rewrite_set_l {U : Type} (s1 s2 : set U) x :
  s1 x ->
  s1 <--> s2 ->
  s2 x.

Lemma rewrite_set_r {U : Type} (s1 s2 : set U) x :
  s2 x ->
  s1 <--> s2 ->
  s1 x.

Lemma imset_bigcup_incl_l :
  forall {T U V : Type} (f : U -> V) (A : set T) (F : T -> set U),
  f @: (\bigcup_(x in A) F x) \subset \bigcup_(x in A) f @: F x.

Lemma in_imset {U T} (f : U -> T) (S : set U) (x : T) :
  (f @: S) x -> exists y, x = f y.

Lemma union_lift_subset_compat {A} (s1 s2 : set (option A)) (s3 s4 : set A) :
  s1 \subset lift s3 ->
  s2 \subset lift s4 ->
  (s1 :|: s2) \subset lift (s3 :|: s4).

Lemma lift_subset_pres_l {A} (s1 : set (option A)) (s2 s3 : set A) :
  s1 \subset lift s2 ->
  s1 \subset lift (s2 :|: s3).

Lemma lift_subset_pres_r {A} (s1 : set (option A)) (s2 s3 : set A) :
  s1 \subset lift s3 ->
  s1 \subset lift (s2 :|: s3).

Lemma set_incl_setI_l {A} (s1 s2 s3 : set A) :
  s1 \subset s3 ->
  (s1 :&: s2) \subset s3.

Lemma set_incl_setI_r {A} (s1 s2 s3 : set A) :
  s2 \subset s3 ->
  (s1 :&: s2) \subset s3.

Lemma set_incl_setU_l {A} (s1 s2 s3 : set A) :
  s1 \subset s3 ->
  s2 \subset s3 ->
  (s1 :|: s2) \subset s3.

Lemma bigcup_set_I_l {A B} (s1 s2 : set A) (s3 : set B) (f : A -> set B) :
  \bigcup_(x in s1) (f x) \subset s3 ->
  \bigcup_(x in (s1 :&: s2)) (f x) \subset s3.

Lemma bigcup_set_U {A B} (s1 s2 : set A) (s3 : set B) (f : A -> set B) :
  \bigcup_(x in s1) (f x) \subset s3 ->
  \bigcup_(x in s2) (f x) \subset s3 ->
  \bigcup_(x in (s1 :|: s2)) (f x) \subset s3.

Lemma bigcup_set0_subset {A B} (s : set B) (f : A -> set B) :
  \bigcup_(x in set0) (f x) \subset s.

Lemma bigcup_cons_subset {A B} l (ls : seq A) (f : A -> set B) s :
  f l \subset s ->
  \bigcup_(x in ls) (f x) \subset s ->
  \bigcup_(x in l :: ls) (f x) \subset s. 

Lemma bigcup_nil_subset {A B} (f : A -> set B) s :
  \bigcup_(x in []) (f x) \subset s. 

Lemma option_subset {A} (s1 : set (option A)) :
  s1 \subset (isSome :&: s1) :|: [set None]. 

Lemma setU_l_subset {U} (s1 s2 s3 : set U) :
  s1 \subset s3 ->
  s2 \subset s3 ->
  (s1 :|: s2) \subset s3.

Lemma bigcup_lift_lift_bigcup {T U} (s1 : set T) (f : T -> set U) :
  \bigcup_(x in s1) (lift (f x)) \subset lift (\bigcup_(x in s1) (f x)).

Lemma lift_subset_compat {U} (s1 s2 : set U) :
  s1 \subset s2 ->
  lift s1 \subset lift s2.

Lemma lift_set_eq_compat {U} (s1 s2 : set U) :
  s1 <--> s2 ->
  lift s1 <--> lift s2.

Lemma bigcup_setU_r:
  forall (U T : Type) (s : set U) (f g : U -> set T),
    \bigcup_(i in s) (f i :|: g i) <-->
    \bigcup_(i in s) f i :|: \bigcup_(i in s) g i.

Lemma lift_bigcup_comm :
  forall (U T : Type) (s : set U) (f : U -> set T),
    inhabited U ->
    lift (\bigcup_(i in [set : U]) (f i)) <-->
    \bigcup_(i in [set : U]) (lift (f i)).

Lemma bigcap_setU_distr:
  forall (U T : Type) (s1 s2 : set U) (f : U -> set T),
    \bigcap_(i in s1) f i :&: \bigcap_(i in s2) f i <--> \bigcap_(i in s1 :|: s2) f i.

Lemma setI_set_incl :
  forall (A : Type) (s1 s2 s3 : set A),
    s1 \subset s2 ->
    s1 \subset s3 ->
    s1 \subset s2 :&: s3.

Lemma imset_isSome {A} (s : set A) :
  Some @: s \subset isSome.

Lemma bigcup_cons_subset_r :
  forall (A B : Type) (l : A) (ls : seq A) (f : A -> set B) (s1 s2 : set B),
    s1 \subset f l ->
    s2 \subset \bigcup_(x in ls) f x ->
    s1 :|: s2 \subset \bigcup_(x in (l :: ls)) f x.

Lemma bigcup_setI_cons_subset_r :
  forall (A B : Type) (l : A) (ls : seq A) (f : A -> set B) (s1 s2 : set B) (s3 : set A),
    s3 l ->
    s1 \subset f l ->
    s2 \subset \bigcup_(x in ls :&: s3) f x ->
    s1 :|: s2 \subset \bigcup_(x in (l :: ls) :&: s3) f x.

Lemma imset_union_set_eq:
  forall (U T : Type) (s1 s2 : set U) (f : U -> T),
    f @: (s1 :|: s2) <--> f @: s1 :|: f @: s2.

Lemma imset_bigcup_setI_cons_subset_r :
  forall (A B : Type) (l : A) (ls : seq A) (f : A -> set (option B))
    (s1 s2 : set B) (s3 : set A),
    s3 l ->
    Some @: s1 \subset f l ->
    Some @: s2 \subset \bigcup_(x in ls :&: s3) f x ->
    Some @: (s1 :|: s2) \subset \bigcup_(x in (l :: ls) :&: s3) f x.

Lemma imset_set0_subset {A B} (f : A -> B) (s : set B) :
  (f @: set0) \subset s.

Lemma setI_set_eq_r {A : Type} (s1 s2 s2' : set A) :
  s2 <--> s2' ->
  (s1 :&: s2) <--> (s1 :&: s2').

Lemma isSome_subset {A : Type} (s1 s2 s1' s2' : set (option A)) :
  isSome :&: s1 \subset isSome :&: s2 ->
  isSome :&: (s1 :|: ([set None] :&: s1')) \subset isSome :&: (s2 :|: ([set None] :&: s2')).

Lemma bigcup_nil_setI {A B} (f : A -> set B)
      (l : seq A) s :
  \bigcup_(x in [] :&: s) (f x) \subset
  \bigcup_(x in (l :&: s)) (f x).

Lemma isSome_set_eq {A} (s : set (option A)) (s' : set A) :
  s \subset (Some @: s') :|: [set None] ->
  Some @: s' \subset s ->
  isSome :&: s <--> Some @: s'.

Lemma set_eq_isSome_sound {A} (s : set (option A)) (s' : set A) :
  isSome :&: s <--> Some @: s' ->
  s \subset (Some @: s') :|: [set None].

Lemma set_eq_isSome_complete {A} (s : set (option A)) (s' : set A) :
  isSome :&: s <--> Some @: s' ->
  Some @: s' \subset s.

Definition somes {A} (s : set (option A)) : set A :=
  [set x | Some x \in s].

Lemma somes_subset {A} (s1 s2 : set (option A)) :
  s1 \subset s2 ->
  somes s1 \subset somes s2.

Lemma bigcup_somes {A B} (sA : set A) (s : A -> set (option B)) :
  somes (\bigcup_(a in sA) s a) <--> \bigcup_(a in sA) somes (s a).

Lemma bigcup_setI {T U} (s1 : set T) (s2 : set U) F :
  \bigcup_(x in s1) (s2 :&: F x) <--> s2 :&: \bigcup_(x in s1) (F x). *)
(* GenLow:
Set Warnings "-extraction-opaque-accessed,-extraction".
Set Warnings "-notation-overridden,-parsing".

Require Import ZArith List.
Require Import mathcomp.ssreflect.ssreflect.
From mathcomp Require Import ssrfun ssrbool ssrnat.
Require Import Numbers.BinNums.
Require Import Classes.RelationClasses.

From ExtLib.Structures Require Export
     Monads.
From ExtLib.Structures Require Import
     Functor Applicative.
Import MonadNotation.
Open Scope monad_scope.

From QuickChick Require Import
     GenLowInterface RandomQC RoseTrees Sets Tactics.

Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Set Bullet Behavior "Strict Subproofs".

Import ListNotations.

Open Scope fun_scope.
Open Scope set_scope.

Module GenLow : GenLowInterface.Sig.

  Inductive GenType (A:Type) : Type := MkGen : (nat -> RandomSeed -> A) -> GenType A.
  
  Definition G := GenType.

  Definition run {A : Type} (g : G A) := match g with MkGen f => f end.
  
  Definition returnGen {A : Type} (x : A) : G A :=
    MkGen (fun _ _ => x).

  Definition bindGen {A B : Type} (g : G A) (k : A -> G B) : G B :=
    MkGen (fun n r =>
             let (r1,r2) := randomSplit r in
             run (k (run g n r1)) n r2).
  
  Definition fmap {A B : Type} (f : A -> B) (g : G A) : G B :=
    MkGen (fun n r => f (run g n r)).

  Definition apGen {A B} (gf : G (A -> B)) (gg : G A) : G B :=
    bindGen gf (fun f => fmap f gg).

  Definition sized {A : Type} (f : nat -> G A) : G A :=
    MkGen (fun n r => run (f n) n r).

  Definition resize {A : Type} (n : nat) (g : G A) : G A :=
    match g with
    | MkGen m => MkGen (fun _ => m n)
    end.

  Definition promote {A : Type} (m : Rose (G A)) : G (Rose A) :=
    MkGen (fun n r => fmapRose (fun g => run g n r) m).

  Fixpoint rnds (s : RandomSeed) (n' : nat) : list RandomSeed :=
    match n' with
      | O => nil
      | S n'' =>
        let (s1, s2) := randomSplit s in
        cons s1 (rnds s2 n'')
    end.
  
  Fixpoint createRange (n : nat) (acc : list nat) : list nat :=
    match n with
      | O => List.rev (cons O acc)
      | S n' => createRange n' (cons n acc)
    end.

  Definition choose {A : Type} `{ChoosableFromInterval A} (range : A * A) : G A :=
    MkGen (fun _ r => fst (randomR range r)).

  Definition sample (A : Type) (g : G A) : list A :=
    match g with
      | MkGen m =>
        let rnd := newRandomSeed in
        let l := List.combine (rnds rnd 20) (createRange 10 nil) in
        List.map (fun (p : RandomSeed * nat) => let (r,n) := p in m n r) l
    end.
  
  Definition variant {A : Type} (p : SplitPath) (g : G A) : G A := 
    match g with 
      | MkGen f => MkGen (fun n r => f n (varySeed p r))
    end.
  
  Definition reallyUnsafeDelay {A : Type} : G (G A -> A) :=
    MkGen (fun r n g => (match g with MkGen f => f r n end)).
  
  Definition reallyUnsafePromote {r A : Type} (m : r -> G A) : G (r -> A) :=
    (bindGen reallyUnsafeDelay (fun eval => 
                                  returnGen (fun r => eval (m r)))).

  Definition semGenSize {A : Type} (g : G A) (s : nat) : set A := codom (run g s).
  Definition semGen {A : Type} (g : G A) : set A := \bigcup_s semGenSize g s.

  Definition semGenSizeOpt {A : Type} (g : G (option A)) (s : nat) : set A :=
    somes (semGenSize g s).

  Definition semGenOpt {A : Type} (g : G (option A)) : set A :=
    somes (semGen g).
  
  Lemma semGenOpt_equiv {A} (g : G (option A)) :
    semGenOpt g <--> \bigcup_s semGenSizeOpt g s.

  Lemma bindGen_aux {A : Type} (g : G A) (n : nat) (r : RandomSeed) : semGen g (run g n r).

  Definition bindGen' {A B : Type} (g : G A) (k : forall (a : A), (a \in semGen g) -> G B) : G B :=
    MkGen (fun n r =>
             let (r1,r2) := randomSplit r in
             run (k (run g n r1) (bindGen_aux g n r1)) n r2).

  Class Unsized {A} (g : G A) :=
    unsized : forall s1 s2, semGenSize g s1 <--> semGenSize g s2.
  
  Class SizedMonotonic {A} (g : nat -> G A) :=
    
    sizeMonotonic : forall s s1 s2,
      s1 <= s2 ->
      semGenSize (g s1) s \subset semGenSize (g s2) s.

  Class SizedMonotonicOpt {A} (g : nat -> G (option A)) :=
    sizeMonotonicOpt : forall s s1 s2,
      s1 <= s2 ->
      semGenSizeOpt (g s1) s \subset semGenSizeOpt (g s2) s.
  
  Class SizeMonotonic {A} (g : G A) :=
    monotonic : forall s1 s2,
      s1 <= s2 -> semGenSize g s1 \subset semGenSize g s2.

  Class SizeMonotonicOpt {A} (g : G (option A)) :=
    monotonicOpt : forall s1 s2,
      s1 <= s2 ->
      semGenSizeOpt g s1 \subset semGenSizeOpt g s2.

  Class SizeAntiMonotonicNone {A} (g : G (option A)) :=
    monotonicNone : forall s1 s2,
      s1 <= s2 ->
      isNone :&: semGenSize g s2 \subset isNone :&: semGenSize g s1.

  Lemma unsizedMonotonic {A} (g : G A) : Unsized g -> SizeMonotonic g. 
  
  Lemma unsized_alt_def :
    forall A (g : G A) `{Unsized _ g},
    forall s, semGenSize g s <--> semGen g.

  Lemma semReturn {A} (x : A) : semGen (returnGen x) <--> [set x].
  
  Lemma semReturnSize A (x : A) (s : nat) :
  semGenSize (returnGen x) s <--> [set x].
  
  Lemma semBindSize A B (g : G A) (f : A -> G B) (s : nat) :
    semGenSize (bindGen g f) s <-->
    \bigcup_(a in semGenSize g s) semGenSize (f a) s.
  
  Lemma semBindSize_subset_compat {A B : Type} (g g' : G A) (f f' : A -> G B) :
    (forall s, semGenSize g s \subset semGenSize g' s) ->
    (forall x s, semGenSize (f x) s \subset semGenSize (f' x) s) ->
    (forall s, semGenSize (bindGen g f) s \subset semGenSize (bindGen g' f') s).
  
  Lemma semBindSizeOpt_subset_compat {A B : Type} (g g' : G A) (f f' : A -> G (option B)) :
    (forall s, semGenSize g s \subset semGenSize g' s) ->
    (forall x s, isSome :&: semGenSize (f x) s \subset isSome :&: semGenSize (f' x) s) ->
    (forall s, isSome :&: semGenSize (bindGen g f) s \subset isSome :&: semGenSize (bindGen g' f') s).
  
  Lemma monad_leftid A B (a : A) (f : A -> G B) :
    semGen (bindGen (returnGen a) f) <--> semGen (f a).
  
  Lemma monad_rightid A (g : G A) : semGen (bindGen g returnGen) <--> semGen g.
  
  Lemma monad_assoc A B C (ga : G A) (fb : A -> G B) (fc : B -> G C) :
    semGen (bindGen (bindGen ga fb) fc) <--> 
    semGen (bindGen ga (fun a => bindGen (fb a) fc)).
  
  Lemma semBindUnsized1 {A B} (g : G A) (f : A -> G B) `{H : Unsized _ g}:
    semGen (bindGen g f) <--> \bigcup_(a in semGen g) semGen (f a).
  
  Lemma semBindUnsized2 :
    forall A B (g : G A) (f : A -> G B),
      (forall a, Unsized (f a)) ->
      semGen (bindGen g f) <--> \bigcup_(a in semGen g) semGen (f a).

  Lemma semBindSizeMonotonic {A B} (g : G A) (f : A -> G B)
        `{Hg : SizeMonotonic _ g} `{Hf : forall a, SizeMonotonic (f a)} :
    semGen (bindGen g f) <--> \bigcup_(a in semGen g) semGen (f a).
  
  Lemma semBindSizeMonotonicIncl_r {A B} (g : G A) (f : A -> G (option B)) (s1 : set A) (s2 : A -> set B) :
    semGen g \subset s1 ->
    (forall x, semGen (f x) \subset Some @: (s2 x) :|: [set None]) -> 
    semGen (bindGen g f) \subset Some @: (\bigcup_(a in s1) s2 a)  :|: [set None].

  Lemma semBindSizeMonotonicIncl_l {A B} (g : G A) (f : A -> G (option B)) (s1 : set A)
        (fs : A -> set B) 
        `{Hg : SizeMonotonic _ g}
        `{Hf : forall a, SizeMonotonicOpt (f a)} :
    s1 \subset semGen g ->
    (forall x, Some @: (fs x) \subset semGen (f x)) ->
    (Some @: \bigcup_(a in s1) (fs a)) \subset semGen (bindGen g f).

  Lemma semFmapSize A B (f : A -> B) (g : G A) (size : nat) :
    semGenSize (fmap f g) size <--> f @: semGenSize g size.  Proof.
  
  Lemma semFmap A B (f : A -> B) (g : G A) :
    semGen (fmap f g) <--> f @: semGen g.

  Lemma semChooseSize A `{ChoosableFromInterval A} (a1 a2 : A) :
    RandomQC.leq a1 a2 ->
  
  Lemma semChoose A `{RandomQC.ChoosableFromInterval A} (a1 a2 : A) :

  Lemma promoteVariant :
    forall {A B : Type} (a : A) (f : A -> SplitPath) (g : G B) size
      (r r1 r2 : RandomSeed),
      randomSplit r = (r1, r2) ->
      run (reallyUnsafePromote (fun a => variant (f a) g)) size r a =
      run g size (varySeed (f a) r1).

  Lemma semPromote A (m : Rose (G A)) :
    semGen (promote m) <-->
    codom2 (fun size seed => fmapRose (fun g => run g size seed) m).

  Lemma semPromoteSize (A : Type) (m : Rose (G A)) n :
    semGenSize (promote m) n <-->
               codom (fun seed => fmapRose (fun g => run g n seed) m).

  Lemma runPromote A (m : Rose (G A)) seed size :
    run (promote m) seed size = fmapRose (fun (g : G A) => run g seed size) m.

  Lemma runFmap (A B : Type) (f : A -> B) (g : G A) seed size :
    run (fmap f g) seed size = f (run g seed size).

  Lemma semFmapBind :
    forall A B C (g : G A) (f1 : B -> C) (f2 : A -> G B),
      semGen (fmap f1 (bindGen g f2)) <-->
      semGen (bindGen g (fun x => fmap f1 (f2 x))).

  Lemma semSized A (f : nat -> G A) :
    semGen (sized f) <--> \bigcup_n semGenSize (f n) n.

  Lemma semSizedSize A(f:nat->G A)s : semGenSize (sized f) s <--> semGenSize (f s) s.

  Lemma semSized_opt A (f : nat -> G (option A)) (H : forall n, SizeMonotonicOpt (f n)) (H' : SizedMonotonicOpt f) :
    isSome :&: semGen (sized f) <--> isSome :&: \bigcup_n (semGen (f n)).

  Lemma semSized_alt A (f : nat -> G A) (H : forall n, SizeMonotonic (f n))
        (H' : forall n m s,  n <= m -> semGenSize (f n) s \subset semGenSize (f m) s) :
    semGen (sized f) <--> \bigcup_n (semGen (f n)).
  
  Lemma semResize A n (g : G A) : semGen (resize n g) <--> semGenSize g n .

  Lemma semSizeResize A (s n : nat) (g : G A) :
    semGenSize (resize n g) s <--> semGenSize g n.

  Lemma semGenSizeInhabited {A} (g : G A) s :
    exists x, semGenSize g s x.

  Instance Functor_G : Functor G := {
    fmap A B := fmap;
  }.

  Instance Applicative_G : Applicative G := {
    pure A := returnGen;
    ap A B := apGen;
  }.

  Instance Monad_G : Monad G := {
    ret A := returnGen;
    bind A B := bindGen;
  }.

  Definition thunkGen {A} (f : unit -> G A) : G A :=
    MkGen (fun n r => run (f tt) n r).

  Lemma semThunkGenSize {A} (f : unit -> G A) s :
    semGenSize (thunkGen f) s <--> semGenSize (f tt) s.

  Lemma semThunkGen {A} (f : unit -> G A) :
    semGen (thunkGen f) <--> semGen (f tt).

End GenLow. *)
(* GenHigh:
Set Warnings "-extraction-opaque-accessed,-extraction".
Set Warnings "-notation-overridden,-parsing".

Require Import ZArith.
Require Import mathcomp.ssreflect.ssreflect.
From mathcomp Require Import ssrfun ssrbool ssrnat eqtype seq.

From QuickChick Require Import
     GenLow GenLowInterface
     GenHighImpl GenHighInterface
     RandomQC Tactics Sets.

Set Bullet Behavior "Strict Subproofs".

Import GenLow.
Module Import GenHigh := GenHighImpl.Impl GenLow.

Import QcDefaultNotation.

Lemma oneOf_freq {A} (g : G A) (gs : list (G A)) size :
  semGenSize (oneOf (g ;; gs)) size <-->
  semGenSize (freq ((1, g) ;; map (fun x => (1, x)) gs)) size.

Lemma semFreq :
  forall {A : Type} (ng : nat * G A) (l : seq (nat * G A)),
    List.Forall (fun x => x.1 > 0) (ng :: l) ->

Lemma semFreqSize :
  forall {A : Type} (ng : nat * G A) (l : seq (nat * G A)) (size : nat),
    List.Forall (fun x => x.1 > 0) (ng :: l) ->

Lemma bigcup_cons_setI_subset_compat_backtrack_weak
      {A} (n : nat) (g g' : G (option A)) (l l' : seq (nat * G (option A))) :
  (forall s, isSome :&: semGenSize g s  \subset isSome :&: semGenSize g' s) ->
  (forall s, \bigcup_(x in (l :&: (fun x => x.1 <> 0))) (isSome :&: semGenSize x.2 s) \subset

Lemma bigcup_cons_setI_subset_pres_backtrack_weak
      {A} (n : nat) (g : G (option A)) (l l' : seq (nat * G (option A))) :
  (forall s, \bigcup_(x in (l :&: (fun x => x.1 <> 0))) (isSome :&: semGenSize x.2 s) \subset *)
(* RoseTrees:
Require Import List mathcomp.ssreflect.ssreflect.
Set Implicit Arguments.

Record Lazy (T : Type) := lazy { force : T }.

Inductive Rose (A : Type) : Type :=
  MkRose : A -> Lazy (list (Rose A)) -> Rose A.

Definition returnRose {A : Type} (x : A) := MkRose x (lazy nil).

Fixpoint joinRose {A : Type} (r : Rose (Rose A)) : Rose A :=
  match r with
    | MkRose (MkRose a ts) tts =>
      MkRose a (lazy ((List.map joinRose (force tts)) ++ (force ts)))
  end.

Fixpoint repeatRose {A : Type} (n : nat) (r : Rose A) :=
  match r with
  | MkRose a ts => MkRose a (lazy (concat (repeat (force ts) n)))
  end.

Fixpoint fmapRose {A B : Type} (f : A -> B) (r : Rose A) : Rose B :=
  match r with
    | MkRose x rs => MkRose (f x) (lazy (List.map (fmapRose f) (force rs)))
  end.

Definition bindRose {A B : Type} (m : Rose A) (k : A -> Rose B) : Rose B :=
  joinRose (fmapRose k m). *)
(* Checker:
Set Warnings "-extraction-opaque-accessed,-extraction".
Set Warnings "-notation-overridden,-parsing".

Require Import mathcomp.ssreflect.ssreflect.
From mathcomp Require Import ssrbool ssrnat eqtype.
Require Import Show Sets GenLow GenHigh RoseTrees Checker Classes.

Import GenLow GenHigh QcNotation.

Definition resultSuccessful (r : Result) : bool :=
  match r with
    | MkResult (Some res) expected _ _ _ _ _ =>
      res == expected
    | _ => true
  end.

Definition successful qp :=
  match qp with
    | MkProp (MkRose res _) => resultSuccessful res
  end.

Definition semCheckerSize (c : Checker) (s : nat): Prop :=
  successful @: semGenSize c s \subset [set true].

Definition semChecker (c : Checker) : Prop := forall s, semCheckerSize c s.

Definition semCheckableSize {A} `{Checkable A} (a : A) (s : nat) : Prop :=
  semCheckerSize (checker a) s.

Definition semCheckable {A} `{Checkable A} (a : A) : Prop := semChecker (checker a).

Lemma semChecker_def2 c :
  semChecker c <-> (forall qp, semGen c qp -> successful qp = true).

Lemma semChecker_def3 c :
  semChecker c <-> (successful @: semGen c \subset [set true]).

Definition genChecker c := fmap successful c.

Class UnsizedChecker (c : Checker) :=
  {
    unsizedChecker : 
      forall s1 s2 : nat, semGenSize (genChecker c) s1 <--> semGenSize (genChecker c) s2
  }.

Class SizeMonotonicChecker (c : Checker) :=
  {
    monotonicChecker : 
      forall s1 s2, s1 <= s2 -> 
                    semGenSize (genChecker c) s1 \subset semGenSize (genChecker c) s2
                                           
  }.

Lemma unsizedChecker_alt_def (c : Checker) `{UnsizedChecker c} :
  forall s1 s2, semCheckerSize c s1 <-> semCheckerSize c s2.

Lemma monotonicChecker_alt_def (c : Checker) `{SizeMonotonicChecker c} :
  forall s1 s2, s1 <= s2 -> semCheckerSize c s2 -> semCheckerSize c s1.

Lemma mapTotalResult_idSize {C} `{Checkable C} (f : Result -> Result) (c : C) s :
    (forall res, resultSuccessful res = resultSuccessful (f res)) ->
    (semCheckerSize (mapTotalResult f c) s <-> semCheckableSize c s).

Lemma mapTotalResult_id {C} `{Checkable C} (f : Result -> Result) (c : C) :
    (forall res, resultSuccessful res = resultSuccessful (f res)) ->
    (semChecker (mapTotalResult f c) <-> semCheckable c).

Lemma semCallback_idSize {C} `{Checkable C} (cb : Callback) (c : C) (s : nat) :
    semCheckerSize (callback cb c) s <-> semCheckableSize c s.

Lemma semCallback_id {C} `{Checkable C} (cb : Callback) (c : C) :
    semChecker (callback cb c) <-> semCheckable c.

Lemma semWhenFail_idSize {C} `{Checkable C} (str : String.string) (c : C) s :

Lemma semWhenFail_id {C} `{Checkable C} (str : String.string) (c : C) :

Lemma semPrintTestCase_idSize {C} `{Checkable C} (str : String.string) (c : C) s :

Lemma semPrintTestCase_id {C} `{Checkable C} (str : String.string) (c : C) :

Lemma semShrinking_idSize {C A} {HCheck : Checkable C}
         (sh : A -> list A) (x : A) (pf : A -> C) (s : nat) :
    semCheckerSize (shrinking sh x pf) s <->
    semCheckableSize (pf x) s.

Lemma semShrinking_id {C A} {HCheck : Checkable C}
         (sh : A -> list A) (x : A) (pf : A -> C)  :
    semChecker (shrinking sh x pf) <->
    semCheckable (pf x).

Lemma semCover_idSize {C} `{Checkable C} (b: bool) (n: nat)
      (str : String.string) (c : C) (s : nat) :

Lemma semCover_id {C} `{Checkable C} (b: bool) (n: nat)
      (str : String.string) (c : C) :

Lemma semClassify_idSize {C} `{Checkable C} (b: bool) (str : String.string)

Lemma semClassify_id {C} `{Checkable C} (b: bool) (str : String.string) (c : C) :

Lemma semLabel_idSize {C} `{Checkable C} (str : String.string) (c : C) (s : nat) :

Lemma semLabel_id {C} `{Checkable C} (str : String.string) (c : C) :

Lemma semCollect_idSize {C} `{Checkable C} (str : String.string) (c : C) (s : nat) :

Lemma semCollect_id {C} `{Checkable C} (str : String.string) (c : C) :

Open Scope Checker_scope.

Lemma semImplicationSize {C} `{Checkable C} (c : C) (b : bool) s :
  semCheckerSize (b ==> c) s <-> (b -> semCheckableSize c s).

Lemma semImplication {C} `{Checkable C} (c : C) (b : bool) :
  semChecker (b ==> c) <-> (b -> semCheckable c).
  
Lemma semReturnGenSize (qp : QProp) (s: nat) :
    semCheckerSize (returnGen qp) s <-> semCheckableSize qp s.

Lemma semReturnGen (qp : QProp) :
    semChecker (returnGen qp) <-> semCheckable qp.

Lemma semBindGenSize {A} (gen : G A) (f : A -> Checker) (s: nat):
    semCheckerSize (bindGen gen f) s <->
    forall a, semGenSize gen s a -> semCheckerSize (f a) s.

Lemma semBindGenUsinzed1 {A} (gen : G A) (f : A -> Checker) `{Unsized _ gen} :
    (semChecker (bindGen gen f) <->
     forall a, semGen gen a -> semChecker (f a)).

Lemma semBindGenUsinzed2 {A} (gen : G A) (f : A -> Checker) 
      `{forall a, UnsizedChecker (f a)} :
    (semChecker (bindGen gen f) <->
     forall a, semGen gen a -> semChecker (f a)).

Lemma semBindGenSizeMonotonic {A} (gen : G A) (f : A -> Checker)
  `{SizeMonotonic _ gen}  
  `{forall a, SizeMonotonicChecker (f a)} :
  (semChecker (bindGen gen f) <->
   forall a, semGen gen a -> semChecker (f a)).

Lemma semPredQPropSize (c : Checker) (s : nat) :
    semCheckableSize c s <-> (semCheckerSize c s).

Lemma semPredQProp (c : Checker) :
    semCheckable c <-> semChecker c.

Lemma semForAllSize {A C} `{Show A, Checkable C} (g : G A) (f : A -> C) (s:nat) :
  semCheckerSize (forAll g f) s <->
  forall (a : A), a \in semGenSize g s -> semCheckableSize (f a) s.

Lemma semForAllUnsized1 {A C} `{Show A, Checkable C} (g : G A) (f : A -> C)
      `{Unsized _ g} :
  (semChecker (forAll g f) <->
   forall (a : A), a \in semGen g -> semCheckable (f a)).

Lemma semForAllUnsized2 {A C} `{Show A, Checkable C} (g : G A) (f : A -> C)
      `{forall a, UnsizedChecker (checker (f a))} :
  (semChecker (forAll g f) <->
   forall (a : A), a \in semGen g -> semCheckable (f a)).

Lemma semForAllSizeMonotonic {A C} `{Show A, Checkable C} (g : G A) (f : A -> C)
    `{SizeMonotonic _ g} `{forall a, SizeMonotonicChecker (checker (f a))} :
  (semChecker (forAll g f) <-> forall (a:A), a \in semGen g -> semCheckable (f a)).

Lemma unsized_printTestCase {A C} `{Checkable C} `{Show A} (c : A -> C) :
  (forall a, Unsized (checker (c a))) ->
  (forall a, Unsized (printTestCase (String.append (Show.show a) newline) (c a))).
Proof.

Abort.

Require Import FunctionalExtensionality.

Lemma curry_uncurry {A B C : Type} (f : A -> B -> C) :
  curry (uncurry f) = f.

Lemma uncurry_curry {A B C : Type} (f : A * B -> C) :
  uncurry (curry f) = f.

Lemma mergeBinds' :
  forall A B C (ga : G A) (gb : G B) (f : A * B -> G C),
    semGen (bindGen ga (fun x => bindGen gb ((curry f) x))) <-->
    semGen (bindGen (genPair ga gb) f).

Lemma eq_to_impl : forall (a b : Prop), a = b -> a -> b.

Lemma mergeForAlls {A B C : Type} `{Checkable C} `{Show A} `{Show B}
         (ga : G A) (gb : G B) (f : A -> B -> C) :
     semChecker (forAll ga (fun a => forAll gb (f a))) <->
     semChecker (forAll (genPair ga gb) (uncurry f)).

Lemma semForAllShrinkSize:
  forall {A C} `{Checkable C} `{Show A}
         (gen : G A) (f : A -> C) shrinker (size: nat),
    semCheckerSize (forAllShrink gen shrinker f) size <->
    forall a : A, semGenSize gen size a -> semCheckableSize (f a) size.

Lemma semForAllShrinkUnsized1 :
  forall {A C} `{Checkable C} `{Show A}
         (gen : G A) (f : A -> C) shrinker `{Unsized _ gen},
    (semChecker (forAllShrink gen shrinker f) <->
     forall a : A, semGen gen a -> semCheckable (f a)).

Lemma semForAllShrinkUnsized2 :
  forall {A C} `{Checkable C} `{Show A}
         (gen : G A) (f : A -> C) shrinker
  `{forall a, UnsizedChecker (checker (f a))},
  (semChecker (forAllShrink gen shrinker f) <->
     forall a : A, semGen gen a -> semCheckable (f a)).

Lemma semForAllShrinkMonotonic :
  forall {A C} `{Checkable C} `{Show A}
         (gen : G A) (f : A -> C) shrinker `{SizeMonotonic _ gen}, 
  (forall a, SizeMonotonicChecker (checker (f a))) ->
  (semChecker (forAllShrink gen shrinker f) <->
     forall a : A, semGen gen a -> semCheckable (f a)).

Lemma bool_successful :  
  forall b, resultSuccessful (liftBool b) = b.

Lemma semCheckableBoolSize (b : bool) size : semCheckableSize b size <-> b.

Lemma semCheckableBool (b : bool) : semCheckable b <-> b.

Lemma semCheckableResultSize:
  forall (res: Result) (size: nat),
    semCheckableSize res size <-> resultSuccessful res.

Lemma semCheckableResult :
  forall (res: Result),
    semCheckable res  <-> resultSuccessful res.

Lemma semCheckableUnitSize (t : unit) size : semCheckableSize t size <-> True.

Lemma semCheckableUnit (t : unit) : semCheckable t <-> True.

Lemma semCheckableQPropSize (qp : QProp) size :
  semCheckableSize qp size <-> successful qp.

Lemma semCheckableQProp (qp : QProp) :
  semCheckable qp  <-> successful qp.

Lemma semCheckableGenSize:
  forall (P : Type) {H : Checkable P} (gen: G P) (size : nat),
    (semCheckableSize gen size) <->
    (forall p, semGenSize gen size p -> semCheckableSize p size).

Lemma semCheckableFunSize:
  forall {A C} {H1 : Show A} `{H2 : Arbitrary A} {H3 : Checkable C}
         (f : A -> C) (size: nat),
    semCheckableSize f size <->
    forall (a : A), semGenSize arbitrary size a -> semCheckableSize (f a) size.

Lemma semCheckablePolyFunSize:
  forall {C : Type -> Type} {H : Checkable (C nat)} (f : forall T, C T)
         (size : nat),
    (semCheckableSize f size) <-> (semCheckableSize (f nat) size).

Lemma semCheckablePolyFunSetSize:
  forall {C : Set -> Type} {H : Checkable (C nat)} (f : forall T, C T) (size: nat),
    (semCheckableSize f size) <->  (semCheckableSize (f nat) size). *)



Import GenLow GenHigh QcNotation.



Definition resultSuccessful (r : Result) : bool :=

  match r with

    | MkResult (Some res) expected _ _ _ _ _ =>

      res == expected

    | _ => true

  end.



Definition successful qp :=

  match qp with

    | MkProp (MkRose res _) => resultSuccessful res

  end.



Definition semCheckerSize (c : Checker) (s : nat): Prop :=

  successful @: semGenSize c s \subset [set true].



Definition semChecker (c : Checker) : Prop := forall s, semCheckerSize c s.



Definition semCheckableSize {A} `{Checkable A} (a : A) (s : nat) : Prop :=

  semCheckerSize (checker a) s.



Definition semCheckable {A} `{Checkable A} (a : A) : Prop := semChecker (checker a).



Lemma semChecker_def2 c :

  semChecker c <-> (forall qp, semGen c qp -> successful qp = true).

Proof.

  rewrite /semChecker /semCheckerSize /semGen. split; intro H.

  - intros. destruct H0 as [s [H0 Ho']]. symmetry; eapply (H s). eexists. 

    split; eauto.  reflexivity.

  - intros n b [qp [H1 H2]]. symmetry in H2. 

    rewrite H2. symmetry. apply H.  

    eexists; eauto. split; eauto. reflexivity.

Qed.



Lemma semChecker_def3 c :

  semChecker c <-> (successful @: semGen c \subset [set true]).

Proof.

  rewrite semChecker_def2. split; intro H.



  - intros b H'. unfold imset, bigcup in H'.

    destruct H' as [qp [H1 H2]]. apply H in H1. by rewrite H1 in H2.

  - intros. specialize (H (successful qp)).

    unfold set1 in H. symmetry. apply: H.

    by eapply imset_in. 

Qed.



Definition genChecker c := fmap successful c.



Class UnsizedChecker (c : Checker) :=

  {

    unsizedChecker : 

      forall s1 s2 : nat, semGenSize (genChecker c) s1 <--> semGenSize (genChecker c) s2

  }.



Class SizeMonotonicChecker (c : Checker) :=

  {

    monotonicChecker : 

      forall s1 s2, s1 <= s2 -> 

                    semGenSize (genChecker c) s1 \subset semGenSize (genChecker c) s2

                                           

  }.



Lemma unsizedChecker_alt_def (c : Checker) `{UnsizedChecker c} :

  forall s1 s2, semCheckerSize c s1 <-> semCheckerSize c s2.

Proof.

  rewrite /semCheckerSize => s1 s2; split;

  move : H => [/(_ s1 s2) H];

  rewrite /genChecker in H; setoid_rewrite semFmapSize in H;

  by rewrite H.

Qed.



Lemma monotonicChecker_alt_def (c : Checker) `{SizeMonotonicChecker c} :

  forall s1 s2, s1 <= s2 -> semCheckerSize c s2 -> semCheckerSize c s1.

Proof.

  rewrite /semCheckerSize => s1 s2 Hle.

  move : H => [/(_ s1 s2 Hle) /= H]. 

  rewrite /genChecker in H; setoid_rewrite semFmapSize in H.

  move => H1 b H2. apply H1. eauto.

Qed.



Program Instance unsizedMonotonicChecker (c : Checker) `{UnsizedChecker c} : 

  SizeMonotonicChecker c.

Next Obligation. 

    rewrite unsizedChecker. move => b Hb. by eauto. 

Qed.



Lemma mapTotalResult_idSize {C} `{Checkable C} (f : Result -> Result) (c : C) s :

    (forall res, resultSuccessful res = resultSuccessful (f res)) ->

    (semCheckerSize (mapTotalResult f c) s <-> semCheckableSize c s).

Proof.

  move=> eq_res. 

  rewrite /mapTotalResult /mapRoseResult /mapProp/semCheckableSize /semCheckerSize. 

  split; rewrite semFmapSize. 

  - move => H1 b [[[res l]] /= [H2 H3]].

    rewrite -H3 eq_res. apply H1.

    repeat (eexists; split; eauto).

  - move => /= H1 b [[[res l]] /= [[[[res' l'] [/= H2 [H3 H4]]] H5]]]; subst.

    rewrite <- H5, <- eq_res in *.  apply H1.

    eexists. split; eauto. reflexivity.

Qed.



Lemma mapTotalResult_id {C} `{Checkable C} (f : Result -> Result) (c : C) :

    (forall res, resultSuccessful res = resultSuccessful (f res)) ->

    (semChecker (mapTotalResult f c) <-> semCheckable c).

Proof.

  move=> eq_res; split => H' s; eapply mapTotalResult_idSize; eauto.

  by apply H'.

Qed.



Lemma semCallback_idSize {C} `{Checkable C} (cb : Callback) (c : C) (s : nat) :

    semCheckerSize (callback cb c) s <-> semCheckableSize c s.

Proof.

  rewrite /callback.

  split; move => H'.

  - apply mapTotalResult_idSize in H' => //;

    by move => [? ? ? ? ? ?].

  - apply mapTotalResult_idSize => //;

    by move => [? ? ? ? ? ?].

Qed.



Lemma semCallback_id {C} `{Checkable C} (cb : Callback) (c : C) :

    semChecker (callback cb c) <-> semCheckable c.

Proof.

  split => H' s; eapply semCallback_idSize; eauto.

  by apply H'.

Qed.



Lemma semWhenFail_idSize {C} `{Checkable C} (str : String.string) (c : C) s :

    semCheckerSize (whenFail str c) s <-> semCheckableSize c s.

Proof.

  by rewrite /whenFail semCallback_idSize.

Qed.



Lemma semWhenFail_id {C} `{Checkable C} (str : String.string) (c : C) :

    semChecker (whenFail str c) <-> semCheckable c.

Proof.

  by rewrite /whenFail semCallback_id.

Qed.



Lemma semPrintTestCase_idSize {C} `{Checkable C} (str : String.string) (c : C) s :

    semCheckerSize (printTestCase str c) s <-> semCheckableSize c s.

Proof.

  by rewrite /printTestCase semCallback_idSize.

Qed.



Lemma semPrintTestCase_id {C} `{Checkable C} (str : String.string) (c : C) :

    semChecker (printTestCase str c) <-> semCheckable c.

Proof.

  by rewrite /printTestCase semCallback_id.

Qed.



Lemma semShrinking_idSize {C A} {HCheck : Checkable C}

         (sh : A -> list A) (x : A) (pf : A -> C) (s : nat) :

    semCheckerSize (shrinking sh x pf) s <->

    semCheckableSize (pf x) s.

Proof.

  unfold semCheckableSize, shrinking, semCheckerSize, semGenSize, props.

  have [n <-] : exists n, S n  = 1000 by eexists; reflexivity.

  split.

  - move => H b [[[res [l]]] [/= [seed Hgen] H']]; subst.

    + suff :

        successful

          (run

             (fmap

                (fun x0 => {| unProp := joinRose (fmapRose unProp x0) |})

                (promote (@props' _ _ HCheck (S n) pf sh x))) s seed).

      setoid_rewrite runFmap. 

      rewrite runPromote. simpl. rewrite Hgen -H' /=. 

      move => -> //. 

      rewrite <- H => //. eexists. split; try by reflexivity.

      eexists. reflexivity.

  - move => H b [[[r [l]]] /= [[seed H1] <-]]. apply H. 

    rewrite runFmap runPromote /= in H1.

    destruct ((run (checker (pf x)) s seed)) as [[res [l']]] eqn:Heq=> //=.

    simpl in *. move : H1 => [H1 H2]; subst.

    eexists. eexists. exists seed. reflexivity. rewrite Heq. reflexivity.

Qed.



Lemma semShrinking_id {C A} {HCheck : Checkable C}

         (sh : A -> list A) (x : A) (pf : A -> C)  :

    semChecker (shrinking sh x pf) <->

    semCheckable (pf x).

Proof.

  split; move => H s; eapply semShrinking_idSize; first by eauto.

  by apply H.

Qed.



Lemma semCover_idSize {C} `{Checkable C} (b: bool) (n: nat)

      (str : String.string) (c : C) (s : nat) :

  semCheckerSize (cover b n str c) s <-> semCheckableSize c s.

Proof.

  split.

  - rewrite /cover. case: b => //.

    move => H1. apply mapTotalResult_idSize in H1 => //.

      by move => [? ? ? ? ? ?].

  - move => H1. rewrite /cover. case: b => //.

    apply mapTotalResult_idSize => //.

      by move => [? ? ? ? ? ?].

Qed.



Lemma semCover_id {C} `{Checkable C} (b: bool) (n: nat)

      (str : String.string) (c : C) :

  semChecker (cover b n str c) <-> semCheckable c.

Proof.

  split; move => H' s; eapply semCover_idSize; first by eauto.

  by apply H'.

Qed.



Lemma semClassify_idSize {C} `{Checkable C} (b: bool) (str : String.string)

          (c : C) (s : nat) :

    semCheckerSize (classify b str c) s <-> semCheckableSize c s.

Proof.

  by rewrite /classify semCover_idSize.

Qed.



Lemma semClassify_id {C} `{Checkable C} (b: bool) (str : String.string) (c : C) :

    semChecker (classify b str c) <-> semCheckable c.

Proof.

  by rewrite /classify semCover_id.

Qed.



Lemma semLabel_idSize {C} `{Checkable C} (str : String.string) (c : C) (s : nat) :

    semCheckerSize (label str c) s <-> semCheckableSize c s.

Proof.

  by rewrite /label semClassify_idSize.

Qed.



Lemma semLabel_id {C} `{Checkable C} (str : String.string) (c : C) :

    semChecker (label str c) <-> semCheckable c.

Proof.

  by rewrite /label semClassify_id.

Qed.



Lemma semCollect_idSize {C} `{Checkable C} (str : String.string) (c : C) (s : nat) :

    semCheckerSize (collect str c) s <-> semCheckableSize c s.

Proof.

  by rewrite /collect semLabel_idSize.

Qed.



Lemma semCollect_id {C} `{Checkable C} (str : String.string) (c : C) :

    semChecker (collect str c) <-> semCheckable c.

Proof.

  by rewrite /collect semLabel_id.

Qed.



Open Scope Checker_scope.



Lemma semImplicationSize {C} `{Checkable C} (c : C) (b : bool) s :

  semCheckerSize (b ==> c) s <-> (b -> semCheckableSize c s).

Proof.

  case: b; split=> //=; first by move/(_ refl_equal).

  by move => _ b [x [/semReturnSize <- <-]].

Qed.



Lemma semImplication {C} `{Checkable C} (c : C) (b : bool) :

  semChecker (b ==> c) <-> (b -> semCheckable c).



Proof.

  split; [move => H1 b' s' | move => H1 s b'];

  eapply semImplicationSize; try by eauto.

  move => b''. by apply H1.

Qed.



Program Instance implicationUnsized

        {C} `{Checkable C} b (c : C) `{UnsizedChecker (checker c)} : 

  UnsizedChecker (b ==> c).

Next Obligation.

  move : H0 => [/(_ s1 s2) H0].

  rewrite /genChecker in H0 *. rewrite -> !semFmapSize in H0. 

  rewrite !semFmapSize.

  rewrite /implication. case : b; eauto.

  apply imset_eq. rewrite !semReturnSize. reflexivity.

Qed.



Program Instance implicationMonotonic

        {C} `{Checkable C} b (c : C) `{SizeMonotonicChecker (checker c)} : 

  SizeMonotonicChecker (b ==> c).

Next Obligation.

  move : H0 => [/(_ s1 s2 H1) H0].

  rewrite /genChecker in H0 *. rewrite -> !semFmapSize in H0. 

  rewrite !semFmapSize.

  rewrite /implication. case : b; eauto.

  apply imset_incl. rewrite !semReturnSize. by move => ? ?; eauto.

Qed.

  

Lemma semReturnGenSize (qp : QProp) (s: nat) :

    semCheckerSize (returnGen qp) s <-> semCheckableSize qp s.

Proof.

  rewrite /semCheckerSize. split.

  - move =>  H qp' [x [H1 H2]]. apply H. eexists; split; eauto. 

  - move => H b [x [H1 H2]] //. apply H => //=. eexists; split; eauto.

Qed.



Lemma semReturnGen (qp : QProp) :

    semChecker (returnGen qp) <-> semCheckable qp.

Proof. 

  split; move => H s.

  - by move /(_ s) /semReturnGenSize : H => //. 

  - apply semReturnGenSize; eauto. by apply H.

Qed.



Lemma semBindGenSize {A} (gen : G A) (f : A -> Checker) (s: nat):

    semCheckerSize (bindGen gen f) s <->

    forall a, semGenSize gen s a -> semCheckerSize (f a) s.

Proof.

  unfold semCheckerSize. split.

  - move => H a Hsize b [qp [H1 <-]]. apply H.

    exists qp; split => //=. apply semBindSize. eexists; split; eauto.

  - move => H b [qp [/semBindSize [a [H1 H2]] <-]]. eapply H; try eassumption.

    eexists; split => //; eauto.

Qed.



Lemma semBindGenUsinzed1 {A} (gen : G A) (f : A -> Checker) `{Unsized _ gen} :

    (semChecker (bindGen gen f) <->

     forall a, semGen gen a -> semChecker (f a)).

Proof.

  split; move => Hgen a.

  - move => [s [_ H']] s'. eapply unsized in H'.

    by eapply semBindGenSize in Hgen; eauto.

  - by eapply semBindGenSize; intros; apply Hgen; eexists; split => //; eauto.

Qed.



Lemma semBindGenUsinzed2 {A} (gen : G A) (f : A -> Checker) 

      `{forall a, UnsizedChecker (f a)} :

    (semChecker (bindGen gen f) <->

     forall a, semGen gen a -> semChecker (f a)).

Proof.

  split; move => Hgen a.

  - move => [s [_ H']] s'.

    eapply semBindGenSize in Hgen; last by eauto.

    eapply unsizedChecker_alt_def; eauto.

  - by eapply semBindGenSize; intros; apply Hgen; eexists; split => //; eauto.

Qed.



Lemma semBindGenSizeMonotonic {A} (gen : G A) (f : A -> Checker)

  `{SizeMonotonic _ gen}  

  `{forall a, SizeMonotonicChecker (f a)} :

  (semChecker (bindGen gen f) <->

   forall a, semGen gen a -> semChecker (f a)).

Proof.

  split; move => Hgen a.

  - move => [s [_ H']] s'. case_eq (s <= s') => [Hleq |  

                                                 /leP/Compare_dec.not_le/ltP/ltnW Hleq].

    + specialize (Hgen s').

      eapply semBindGenSize in Hgen; eauto. 

      eapply monotonic; eauto.

    + specialize (Hgen s). eapply semBindGenSize in Hgen; eauto. 

      eapply monotonicChecker_alt_def; eauto.

  - by eapply semBindGenSize; intros; apply Hgen; eexists; split => //; eauto.

Qed.



Lemma semPredQPropSize (c : Checker) (s : nat) :

    semCheckableSize c s <-> (semCheckerSize c s).

Proof.

  rewrite /semCheckableSize /checker

          /testChecker /checker /testProp /semCheckerSize.

  split; move => Hqp qp Hsize; auto.

Qed.



Lemma semPredQProp (c : Checker) :

    semCheckable c <-> semChecker c.

Proof.

  split => H s; eapply semPredQPropSize; eauto.

Qed.



Instance forAllMonotonic {A C} {_ : Checkable C} `{Show A} (g : G A) (f : A -> C)

        `{SizeMonotonic _ g} `{forall x, SizeMonotonicChecker (checker (f x))} :

  SizeMonotonicChecker (forAll g f).

Admitted.



Lemma semForAllSize {A C} `{Show A, Checkable C} (g : G A) (f : A -> C) (s:nat) :

  semCheckerSize (forAll g f) s <->

  forall (a : A), a \in semGenSize g s -> semCheckableSize (f a) s.

Proof.

  split=> H'.

  - rewrite /forAll in H'. move/semBindGenSize : H' => H' a /H' Hgen.

      by apply semPrintTestCase_idSize in Hgen.

  - rewrite /forAll in H' *. apply semBindGenSize => g' Hgen.

    rewrite semPrintTestCase_idSize. by apply H'.

Qed.



Lemma semForAllUnsized1 {A C} `{Show A, Checkable C} (g : G A) (f : A -> C)

      `{Unsized _ g} :

  (semChecker (forAll g f) <->

   forall (a : A), a \in semGen g -> semCheckable (f a)).

Proof.

  split=> H'.

  - move => a [s' [_ Hgen]] s. specialize (H' s).

    eapply semForAllSize in H'; first by eauto.

    eapply unsized; eauto.

  - move => s; eapply semForAllSize; move => a Hgen.

    apply H'; eexists; split => //; eauto. 

Qed.



Lemma semForAllUnsized2 {A C} `{Show A, Checkable C} (g : G A) (f : A -> C)

      `{forall a, UnsizedChecker (checker (f a))} :

  (semChecker (forAll g f) <->

   forall (a : A), a \in semGen g -> semCheckable (f a)).

Proof.

  split=> H'.

  - move => a [s' [_ Hgen]] s. specialize (H' s').

    eapply semForAllSize in H'; last by eauto.

    by eapply unsizedChecker_alt_def; eauto.

  - move => s; eapply semForAllSize; move => a Hgen. 

    apply H'; eexists; split => //; eauto. 

Qed.



Lemma semForAllSizeMonotonic {A C} `{Show A, Checkable C} (g : G A) (f : A -> C)

    `{SizeMonotonic _ g} `{forall a, SizeMonotonicChecker (checker (f a))} :

  (semChecker (forAll g f) <-> forall (a:A), a \in semGen g -> semCheckable (f a)).



Proof.

  split; move => Hcheck a.

  - move => [s [_ H']] s'. case_eq (s <= s') => [Hleq |  

                                                 /leP/Compare_dec.not_le/ltP/ltnW Hleq].

    + specialize (Hcheck s').

      rewrite -> semForAllSize in Hcheck. apply Hcheck. 

      eapply monotonic; eauto.

    + specialize (Hcheck s). eapply semForAllSize in Hcheck; eauto. 

      by eapply monotonicChecker_alt_def; eauto. 

  - by eapply semForAllSize; intros; apply Hcheck; eexists; split => //; eauto.

Qed.



Lemma unsized_printTestCase {A C} `{Checkable C} `{Show A} (c : A -> C) :

  (forall a, Unsized (checker (c a))) ->

  (forall a, Unsized (printTestCase (String.append (Show.show a) newline) (c a))).

Proof.



Abort.



Require Import FunctionalExtensionality.



Lemma curry_uncurry {A B C : Type} (f : A -> B -> C) :

  curry (uncurry f) = f.

Proof. apply functional_extensionality => x. reflexivity. Qed.



Lemma uncurry_curry {A B C : Type} (f : A * B -> C) :

  uncurry (curry f) = f.

Proof. apply functional_extensionality. by intros [a b]. Qed.



Lemma mergeBinds' :

  forall A B C (ga : G A) (gb : G B) (f : A * B -> G C),

    semGen (bindGen ga (fun x => bindGen gb ((curry f) x))) <-->

    semGen (bindGen (genPair ga gb) f).

Proof. setoid_rewrite mergeBinds. by setoid_rewrite uncurry_curry. Qed.



Lemma eq_to_impl : forall (a b : Prop), a = b -> a -> b.

Proof. move => a b H. by rewrite H. Qed.



Lemma mergeForAlls {A B C : Type} `{Checkable C} `{Show A} `{Show B}

         (ga : G A) (gb : G B) (f : A -> B -> C) :

     semChecker (forAll ga (fun a => forAll gb (f a))) <->

     semChecker (forAll (genPair ga gb) (uncurry f)).

Proof.

  
  split. 

  - move => HforAll s. apply semForAllSize; 

    move  => [a b] /= /semLiftGen2Size [[a' b'] [[/= Hg1 Hg2] [Heq1 Heq2]]]; subst.

    specialize (HforAll s). eapply semForAllSize in HforAll.

    by eapply semForAllSize in HforAll; eauto. by eauto.

  - move => HforAll s. apply semForAllSize => a Hgena. 

    apply semForAllSize => b Hgenb.

    specialize (HforAll s). 

    move /semForAllSize/(_ (a, b)) : HforAll => /= HforAll. apply HforAll.

    apply semLiftGen2Size. exists (a, b); split => //; eauto.

Qed.



Lemma semForAllShrinkSize:

  forall {A C} `{Checkable C} `{Show A}

         (gen : G A) (f : A -> C) shrinker (size: nat),

    semCheckerSize (forAllShrink gen shrinker f) size <->

    forall a : A, semGenSize gen size a -> semCheckableSize (f a) size.

Proof.

  move => A C H show gen pf shrink. split.

  - rewrite /forAllShrink semBindGenSize.

    move=> H' a /H' Hgen. setoid_rewrite semShrinking_idSize in Hgen.

    setoid_rewrite semPredQPropSize in Hgen.

    by apply semPrintTestCase_idSize in Hgen.

  - move=> H'. rewrite /forAllShrink semBindGenSize. move => a g.

    rewrite semShrinking_idSize. apply semPredQPropSize.

    rewrite semPrintTestCase_idSize. by auto.

Qed.



Lemma semForAllShrinkUnsized1 :

  forall {A C} `{Checkable C} `{Show A}

         (gen : G A) (f : A -> C) shrinker `{Unsized _ gen},

    (semChecker (forAllShrink gen shrinker f) <->

     forall a : A, semGen gen a -> semCheckable (f a)).

Proof.

  split=> H'.

  - move => a [s' [_ Hgen]] s. specialize (H' s).

    eapply semForAllShrinkSize in H'; first by eauto.

    eapply H1; eauto. 

 - move => s; eapply semForAllShrinkSize; move => a Hgen. 

    apply H'; eexists; split => //; eauto. 

Qed.



Lemma semForAllShrinkUnsized2 :

  forall {A C} `{Checkable C} `{Show A}

         (gen : G A) (f : A -> C) shrinker

  `{forall a, UnsizedChecker (checker (f a))},

  (semChecker (forAllShrink gen shrinker f) <->

     forall a : A, semGen gen a -> semCheckable (f a)).

Proof.

  split=> H'.

  - move => a [s' [_ Hgen]] s. specialize (H' s').

    eapply semForAllShrinkSize in H'; last by eauto.

    eapply unsizedChecker_alt_def; eauto.

  - move => s; eapply semForAllShrinkSize; move => a Hgen. 

    apply H'; eexists; split => //; eauto. 

Qed.



Lemma semForAllShrinkMonotonic :

  forall {A C} `{Checkable C} `{Show A}

         (gen : G A) (f : A -> C) shrinker `{SizeMonotonic _ gen}, 

  (forall a, SizeMonotonicChecker (checker (f a))) ->

  (semChecker (forAllShrink gen shrinker f) <->

     forall a : A, semGen gen a -> semCheckable (f a)).

Proof.

  move => A C H1 H2 gen f sh Hmon1 Hmon2.

  split; move => Hcheck a.

  - move => [s [_ H']] s'. case_eq (s <= s') => [Hleq |  

                                                 /leP/Compare_dec.not_le/ltP/ltnW Hleq].

    + specialize (Hcheck s').

      rewrite -> semForAllShrinkSize in Hcheck. apply Hcheck. 

      by eapply Hmon1; eauto.

    + specialize (Hcheck s). eapply semForAllShrinkSize in Hcheck; eauto. 

      by eapply monotonicChecker_alt_def; eauto. 

  - by eapply semForAllShrinkSize; intros; apply Hcheck; eexists; split => //; eauto.

Qed.



Lemma bool_successful :  

  forall b, resultSuccessful (liftBool b) = b.

Proof.

  intros. destruct b; auto.

Qed.



Lemma semCheckableBoolSize (b : bool) size : semCheckableSize b size <-> b.

Proof.

  rewrite /semCheckableSize /semCheckerSize /checker /testBool.

  split.

  - move => /(_ b) H. 

    suff : [set true] b by move => <- //.

    eapply H. eexists (MkProp (MkRose (liftBool b) (lazy nil))).

    split => //=. by rewrite -> (semReturnSize _ _ _). by eapply bool_successful.

  - move => Hb b' [qp [/semReturnSize <- <-]] /=.

    by rewrite bool_successful. 

Qed.



Lemma semCheckableBool (b : bool) : semCheckable b <-> b.



Proof. 

  
  split; [move => /(_ 0) H | move => H s]; eapply semCheckableBoolSize; eauto.

Qed.

 

Program Instance boolUnsized (b : bool) : UnsizedChecker (checker b).

Next Obligation.

  rewrite !semFmapSize !semReturnSize. apply imset_eq. reflexivity.

Qed.



Lemma semCheckableResultSize:

  forall (res: Result) (size: nat),

    semCheckableSize res size <-> resultSuccessful res.

Proof.

  rewrite /semCheckableSize /checker /testResult /=.

  move => res size. split. 

  - move => /(_ (resultSuccessful res)) H. 

    suff : [set true] (resultSuccessful res) by move <-.

    apply H. eexists. split; first by apply semReturnSize. 

    reflexivity. 

  - move => H b [qp' [/semReturnSize <- <-]] //=.

Qed.



Lemma semCheckableResult :

  forall (res: Result),

    semCheckable res  <-> resultSuccessful res.

Proof.

  split; [move => /(_ 0) H | move => H s]; eapply semCheckableResultSize; eauto.

Qed.



Program Instance resultUnsized (r : Result) : UnsizedChecker (checker r).

Next Obligation.

  rewrite !semFmapSize !semReturnSize. apply imset_eq. reflexivity.

Qed.



Lemma semCheckableUnitSize (t : unit) size : semCheckableSize t size <-> True.

Proof.

  split => // _ qp [qp' [/semReturnSize <- <-]] //.

Qed.



Lemma semCheckableUnit (t : unit) : semCheckable t <-> True.

Proof.

  split; [move => /(_ 0) H | move => H s]; eapply semCheckableUnitSize; eauto.

Qed.



Program Instance unitUnsized : UnsizedChecker (checker tt).

Next Obligation.

  rewrite !semFmapSize !semReturnSize. apply imset_eq. reflexivity.

Qed.



Lemma semCheckableQPropSize (qp : QProp) size :

  semCheckableSize qp size <-> successful qp.

Proof.

  rewrite /semCheckableSize /checker /testProp.

  split. 

  - move => /(_ (successful qp)) H. 

    suff : ([set true] (successful qp)) by move => <-.

    apply H. eexists. split ; last by reflexivity.

    by apply semReturnSize.

  - move => H b [qp' [/semReturnSize <- <-]] //=.

Qed.



Lemma semCheckableQProp (qp : QProp) :

  semCheckable qp  <-> successful qp.

Proof.

  split; [move => /(_ 0) H | move => H s]; eapply semCheckableQPropSize; eauto.

Qed.



Program Instance qpUnsized (qp : QProp) : UnsizedChecker (checker qp).

Next Obligation.

  rewrite !semFmapSize !semReturnSize. apply imset_eq. reflexivity.

Qed.



Lemma semCheckableGenSize:

  forall (P : Type) {H : Checkable P} (gen: G P) (size : nat),

    (semCheckableSize gen size) <->

    (forall p, semGenSize gen size p -> semCheckableSize p size).

Proof.

  move=> P H gen s. rewrite /semCheckableSize /checker /testGenProp. split.

  - move => /semBindGenSize Hcheck p Hgen //=; eauto.

  - move => Hcheck. apply semBindGenSize => a Hgen; eauto.

Qed.



Lemma semCheckableFunSize:

  forall {A C} {H1 : Show A} `{H2 : Arbitrary A} {H3 : Checkable C}

         (f : A -> C) (size: nat),

    semCheckableSize f size <->

    forall (a : A), semGenSize arbitrary size a -> semCheckableSize (f a) size.

Proof.

  move=> A C H1 H2 H3 f.

  rewrite /semCheckable /checker /testFun.

  split.

  - move => /semForAllShrinkSize H' a' /H' Gen. by auto.

  - move => H'. apply semForAllShrinkSize => a' /H' Hgen. by auto.

Qed.



Lemma semCheckablePolyFunSize:

  forall {C : Type -> Type} {H : Checkable (C nat)} (f : forall T, C T)

         (size : nat),

    (semCheckableSize f size) <-> (semCheckableSize (f nat) size).

Proof.

  move => C H f s. rewrite /semCheckableSize {2}/checker /testPolyFun.

  by rewrite semPrintTestCase_idSize.

Qed.



Lemma semCheckablePolyFunSetSize:

  forall {C : Set -> Type} {H : Checkable (C nat)} (f : forall T, C T) (size: nat),

    (semCheckableSize f size) <->  (semCheckableSize (f nat) size).

Proof.

  move => C H f s. rewrite /semCheckableSize {2}/checker /testPolyFun.

  by rewrite semPrintTestCase_idSize.

Qed.



Program Instance uncurryUsized {A B} (f : A -> B -> Checker) p

        `{UnsizedChecker (f (fst p) (snd p))} : UnsizedChecker (uncurry f p).

Next Obligation. by apply unsizedChecker. Qed.



Class Provable (A : Type) {H: Checkable A} : Type :=

 {

    proposition : nat -> A -> Prop;

    proposition_equiv : forall a s, proposition s a <-> semCheckableSize a s

  }.



Program Instance proveResult : Provable Result :=

  {|

    proposition s r := resultSuccessful r

  |}.

Next Obligation.

  by rewrite semCheckableResultSize.

Qed.



Program Instance proveUnit : Provable unit :=

  {|

    proposition := fun _ _ => True

  |}.

Next Obligation.

  by rewrite semCheckableUnitSize.

Qed.



Program Instance proveQProp : Provable QProp :=

  {|

    proposition s qp := successful qp = true

  |}.

Next Obligation.

  by rewrite semCheckableQPropSize.

Qed.



Program Instance proveBool : Provable bool :=

  {|

    proposition s b :=  b = true

  |}.

Next Obligation.

  by rewrite semCheckableBoolSize.

Qed.



Program Instance proveGenProp {C} `{Provable C} :

  Provable (G C) :=

  {|

    proposition s g := (forall p, semGenSize g s p -> proposition s p)

  |}.

Next Obligation.

  destruct H0 as [semP proof]. rewrite /proposition. split.

  - move => H'. apply semCheckableGenSize => p Hgen. apply proof. eapply H'. eassumption.

  - move => /semCheckableGenSize H' p Hgen. eapply proof. apply H'. by auto.

Qed.



Program Instance proveChecker : Provable Checker :=

  {|

    proposition s g := semCheckerSize g s

  |}.

Next Obligation.

  split; intros H; by apply semPredQPropSize.

Qed.



Program Instance proveFun {A C: Type} `{Arbitrary A} `{Show A}

        `{Provable C}: Provable (A -> C) :=

  {|

    proposition s p :=

      (forall a,

         semGenSize arbitrary s a ->

         proposition s (p a))

  |}.

Next Obligation.

  match goal with 

    | [ Hyp : Provable _ |- _ ] => destruct Hyp as [semP proof]

  end. rewrite /proposition. split.

  - move=> H'. apply semCheckableFunSize => a' /H' Hgen.

    by apply proof.

  - move=> H' a' Hgen. apply proof. by apply semCheckableFunSize.

Qed.



Program Instance provePolyFun {C : Type -> Type} `{Provable (C nat)} :

  Provable (forall T, C T) :=

  {

    proposition s f := proposition s (f nat)

  }.

Next Obligation.

  destruct H0 as [semP proof]. rewrite /proposition. split.

  - move=> /proof H'. by apply semCheckablePolyFunSize.

  - move=> /semCheckablePolyFunSize H'. by apply proof.

Qed.



Program Instance provePolyFunSet {C : Set -> Type} `{Provable (C nat)} :

  Provable (forall T, C T) :=

  {

    proposition s f := proposition s (f nat)

  }.

Next Obligation.

  destruct H0 as [semP proof]. rewrite /proposition. split.

  - move=> /proof H'. by apply semCheckablePolyFunSetSize.

  - move=> /semCheckablePolyFunSetSize H'. by apply proof.

Qed.

