
Set Warnings "-extraction-opaque-accessed,-extraction".
Set Warnings "-notation-overridden,-parsing".

Require Import String List. Open Scope string.

From QuickChick Require Import QuickChick Tactics.
From mathcomp Require Import ssreflect ssrfun ssrbool ssrnat eqtype seq.
Import QcDefaultNotation. Open Scope qc_scope.

Set Bullet Behavior "Strict Subproofs".

Require Import Smallstep.
(* Smallstep:
Set Warnings "-extraction-opaque-accessed,-extraction".
Set Warnings "-notation-overridden,-parsing".

Require Import String List. Open Scope string.

From QuickChick Require Import QuickChick Tactics.
From mathcomp Require Import ssreflect ssrfun ssrbool ssrnat eqtype seq.
Import QcDefaultNotation. Open Scope qc_scope.

Set Bullet Behavior "Strict Subproofs".

Require Import Coq.Arith.Arith.
Require Import Coq.Arith.EqNat.
Require Import Coq.omega.Omega.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Maps.
Require Import Imp.

Inductive tm : Type :=
  | C : nat -> tm         
  | P : tm -> tm -> tm.   

Derive (Arbitrary, Show) for tm.

Fixpoint evalF (t : tm) : nat :=
  match t with
  | C n => n
  | P a1 a2 => evalF a1 + evalF a2
  end.

Reserved Notation " t '\\' n " (at level 50, left associativity).

Inductive eval : tm -> nat -> Prop :=
  | E_Const : forall n,
      C n \\ n
  | E_Plus : forall t1 t2 n1 n2,
      t1 \\ n1 ->
      t2 \\ n2 ->
      P t1 t2 \\ (n1 + n2)

  where " t '\\' n " := (eval t n).

Module SimpleArith1.

Reserved Notation " t '===>' t' " (at level 55).

Inductive step : tm -> tm -> Prop :=
  | ST_PlusConstConst : forall n1 n2,
      P (C n1) (C n2) ===> C (n1 + n2)
  | ST_Plus1 : forall t1 t1' t2,
      t1 ===> t1' ->
      P t1 t2 ===> P t1' t2
  | ST_Plus2 : forall n1 t2 t2',
      t2 ===> t2' ->
      P (C n1) t2 ===> P (C n1) t2'

  where " t '===>' t' " := (step t t').

End SimpleArith1.

Definition relation (X: Type) := X->X->Prop.

Definition deterministic {X: Type} (R: relation X) :=
  forall x y1 y2 : X, R x y1 -> R x y2 -> y1 = y2.

Module SimpleArith2.
Import SimpleArith1.

Theorem step_deterministic:
  deterministic step.

End SimpleArith2.

Ltac solve_by_inverts n :=
  match goal with | H : ?T |- _ => 
  match type of T with Prop =>
    solve [ 
      inversion H; 
      match n with S (S (?n')) => subst; solve_by_inverts (S n') end ]
  end end.

Ltac solve_by_invert :=
  solve_by_inverts 1.

Module SimpleArith3.
Import SimpleArith1.

Theorem step_deterministic_alt: deterministic step.
Derive ArbitrarySizedSuchThat for (fun t => value t).

Reserved Notation " t '===>' t' " (at level 40).

Inductive step : tm -> tm -> Prop :=
  | ST_PlusConstConst : forall n1 n2,
          P (C n1) (C n2)
      ===> C (n1 + n2)
  | ST_Plus1 : forall t1 t1' t2,
        t1 ===> t1' ->
        P t1 t2 ===> P t1' t2
  | ST_Plus2 : forall v1 t2 t2',
        value v1 ->                     
        t2 ===> t2' ->
        P v1 t2 ===> P v1 t2'

  where " t '===>' t' " := (step t t').

Theorem step_deterministic :
  deterministic step.

Definition step_fun (t : tm) : option tm := Some t.

Theorem strong_progress : forall t,
  value t \/ (exists t', t ===> t').

Definition normal_form {X:Type} (R:relation X) (t:X) : Prop :=
  ~ exists t', R t t'.

Lemma value_is_nf : forall v,
  value v -> normal_form step v.

Lemma nf_is_value : forall t,
  normal_form step t -> value t.

Inductive multi {X:Type} (R: relation X) : relation X :=
  | multi_refl  : forall (x : X), multi R x x
  | multi_step : forall (x y z : X),
                    R x y ->
                    multi R y z ->
                    multi R x z.

Notation " t '===>*' t' " := (multi step t t') (at level 40).

Theorem multi_R : forall (X:Type) (R:relation X) (x y : X),
       R x y -> (multi R) x y.

Theorem multi_trans :
  forall (X:Type) (R: relation X) (x y z : X),
      multi R x y  ->
      multi R y z ->
      multi R x z.

Definition step_normal_form := normal_form step.

Definition normal_form_of (t t' : tm) :=
  (t ===>* t' /\ step_normal_form t').

Theorem normal_forms_unique:
  deterministic normal_form_of.

Definition normalizing {X:Type} (R:relation X) :=
  forall t, exists t',
    (multi R) t t' /\ normal_form R t'.

Lemma multistep_congr_1 : forall t1 t1' t2,
     t1 ===>* t1' ->
     P t1 t2 ===>* P t1' t2. *)
Require Import Stlc.
(* Stlc:
Definition beq_id x y :=
  match x,y with
    | Id n1, Id n2 => if string_dec n1 n2 then true else false
  end.

Hint Constructors value.

Reserved Notation "'[' x ':=' s ']' t" (at level 20).

Fixpoint subst (x:id) (s:trm) (t:trm) : trm :=
  match t with
  | tvar x' =>
      if beq_id x x' then s else t
  | tabs x' T t1 =>
      tabs x' T (if beq_id x x' then t1 else ([x:=s] t1))
  | tapp t1 t2 =>
      tapp ([x:=s] t1) ([x:=s] t2)
  | ttrue =>
      ttrue
  | tfalse =>
      tfalse
  | tif t1 t2 t3 =>
      tif ([x:=s] t1) ([x:=s] t2) ([x:=s] t3)
  end

where "'[' x ':=' s ']' t" := (subst x s t).

Reserved Notation "t1 '===>' t2" (at level 40).

Inductive step : trm -> trm -> Prop :=
  | ST_AppAbs : forall x T t12 v2,
         value v2 ->
         (tapp (tabs x T t12) v2) ===> [x:=v2]t12
  | ST_App1 : forall t1 t1' t2,
         t1 ===> t1' ->
         tapp t1 t2 ===> tapp t1' t2
  | ST_App2 : forall v1 t2 t2',
         value v1 ->
         t2 ===> t2' ->
         tapp v1 t2 ===> tapp v1  t2'
  | ST_IfTrue : forall t1 t2,
      (tif ttrue t1 t2) ===> t1
  | ST_IfFalse : forall t1 t2,
      (tif tfalse t1 t2) ===> t2
  | ST_If : forall t1 t1' t2 t3,
      t1 ===> t1' ->
      (tif t1 t2 t3) ===> (tif t1' t2 t3)

where "t1 '===>' t2" := (step t1 t2).

Hint Constructors step.

Notation multistep := (multi step).
Notation "t1 '===>*' t2" := (multistep t1 t2) (at level 40).

Definition context := list (id * ty).

Definition empty : context := nil.

Fixpoint lookup (Gamma : context) (i : id) : option ty :=
  match Gamma with 
  | nil => None
  | cons (i',T) Gamma' => 
    if beq_id i i' then Some T
    else lookup Gamma' i
  end.

Theorem beq_id_true_iff : forall x y : id,
  beq_id x y = true <-> x = y.

Theorem beq_id_false_iff : forall x y : id,
  beq_id x y = false
  <-> x <> y.

Lemma lookup_bind : forall Gamma i T, lookup Gamma i = Some T <-> bind Gamma i T.

Fixpoint get_type (Gamma : context) (t : trm) : option ty. *)

Lemma canonical_forms_bool : forall t,
  empty |- t \typ TBool ->
  value t ->
  (t = ttrue) \/ (t = tfalse).
Admitted.  

Instance dec_ex_abs t T1 : Dec (exists x u, t = tabs x T1 u).
constructor; unfold decidable.
destruct t eqn:Eq;
try solve [right => [[x [id contra]]]; congruence].
destruct (eq_dec_ty t0 T1).
destruct dec eqn:H; subst; eauto.
right => [[x [id contra]]]; inversion contra; subst; congruence.
Defined. 

Lemma canonical_forms_fun : forall t T1 T2,
  empty |- t \typ (TArrow T1 T2) ->
  value t ->
  exists x u, t = tabs x T1 u.
Admitted. 

Definition step_fun (t : trm) : option trm := Some t.

Axiom step_fun_correct : forall t t',
    step_fun t = Some t' <-> step t t'.

Instance dec_step (t : trm) : Dec (exists t', step t t') :=
  {| dec := _ |}.
Proof.
  destruct (step_fun t) eqn:Step.
  - left; exists t0; eapply step_fun_correct; eauto.
  - right => [[t' contra]]. eapply step_fun_correct in contra; congruence.
Defined.

Theorem progress : forall t T,
     empty |- t \typ T ->
     value t \/ exists t', t ===> t'.
Admitted. 

Inductive appears_free_in : id -> trm -> Prop :=
  | afi_var : forall i,
      appears_free_in i (tvar i)
  | afi_app1 : forall i t1 t2,
      appears_free_in i t1 -> appears_free_in i (tapp t1 t2)
  | afi_app2 : forall i t1 t2,
      appears_free_in i t2 -> appears_free_in i (tapp t1 t2)
  | afi_abs : forall i y T11 t12,
      y <> i  ->
      appears_free_in i t12 ->
      appears_free_in i (tabs y T11 t12)
  | afi_if1 : forall i t1 t2 t3,
      appears_free_in i t1 ->
      appears_free_in i (tif t1 t2 t3)
  | afi_if2 : forall i t1 t2 t3,
      appears_free_in i t2 ->
      appears_free_in i (tif t1 t2 t3)
  | afi_if3 : forall i t1 t2 t3,
      appears_free_in i t3 ->
      appears_free_in i (tif t1 t2 t3).

Hint Constructors appears_free_in.

Derive ArbitrarySizedSuchThat for (fun i => appears_free_in i t).
Derive SizeMonotonicSuchThatOpt for (fun i => appears_free_in i t).
Derive SizedProofEqs for (fun i => appears_free_in i t).
Derive GenSizedSuchThatCorrect for (fun i => appears_free_in i t).
Derive GenSizedSuchThatSizeMonotonicOpt for (fun i => appears_free_in i t).

Instance appears_free_in_gen_correct t : SuchThatCorrect (fun i => appears_free_in i t) 
                                                         (@arbitraryST _ (fun i => appears_free_in i t) _).
Admitted.

Definition closed (t:trm) :=
  forall x, ~ appears_free_in x t.

Instance dec_closed t : Dec (closed t). Admitted.
Instance dec_bind x Gamma : Dec (exists T, bind Gamma x T).
Admitted.

Lemma free_in_context : forall x t,
   appears_free_in x t ->
   forall T Gamma,
   Gamma |- t \typ T ->
   exists T', bind Gamma x T'.
Admitted. 

Corollary typable_empty__closed : forall t T,
    empty |- t \typ T  ->
    closed t.
Admitted. 

Lemma substitution_preserves_typing : forall Gamma x U t v T,
     cons (x,U) Gamma |- t \typ T ->
     empty |- v \typ U   ->
     Gamma |- [x:=v]t \typ T.
Admitted. 

Theorem preservation : forall t T,
     empty |- t \typ T  ->
              forall t', 
     t ===> t'  ->
     empty |- t' \typ T.
Admitted. 

Definition stuck (t:trm) : Prop :=
  (normal_form step) t /\ ~ value t.

Corollary soundness : forall t t' T,
  empty |- t \typ T ->
  t ===>* t' ->
  ~(stuck t').
Admitted. 

