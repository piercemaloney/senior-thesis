Set Implicit Arguments.

Require Import List.
Require Import Coq.Strings.String.

Require Import RoseTrees.
(* RoseTrees:
Require Import List mathcomp.ssreflect.ssreflect.
Set Implicit Arguments.

Record Lazy (T : Type) := lazy { force : T }.

Inductive Rose (A : Type) : Type :=
  MkRose : A -> Lazy (list (Rose A)) -> Rose A.

Definition returnRose {A : Type} (x : A) := MkRose x (lazy nil).

Fixpoint joinRose {A : Type} (r : Rose (Rose A)) : Rose A :=
  match r with
    | MkRose (MkRose a ts) tts =>
      MkRose a (lazy ((List.map joinRose (force tts)) ++ (force ts)))
  end.

Fixpoint repeatRose {A : Type} (n : nat) (r : Rose A) :=
  match r with
  | MkRose a ts => MkRose a (lazy (concat (repeat (force ts) n)))
  end.

Fixpoint fmapRose {A B : Type} (f : A -> B) (r : Rose A) : Rose B :=
  match r with
    | MkRose x rs => MkRose (f x) (lazy (List.map (fmapRose f) (force rs)))
  end.

Definition bindRose {A B : Type} (m : Rose A) (k : A -> Rose B) : Rose B :=
  joinRose (fmapRose k m). *)
Require Import Show.
(* Show:
From Coq Require Import
     Ascii
     Basics
     Decimal
     List
     String
     ZArith.

Import ListNotations.
Local Open Scope program_scope.
Local Open Scope string_scope.

Delimit Scope string_scope with string.

Definition newline := String "010" ""%string.

Class Show (A : Type) : Type :=
{
  show : A -> string
}.

Fixpoint show_uint (n : uint) : string :=
  match n with
  | Nil => ""
  | D0 n => String "0" (show_uint n)
  | D1 n => String "1" (show_uint n)
  | D2 n => String "2" (show_uint n)
  | D3 n => String "3" (show_uint n)
  | D4 n => String "4" (show_uint n)
  | D5 n => String "5" (show_uint n)
  | D6 n => String "6" (show_uint n)
  | D7 n => String "7" (show_uint n)
  | D8 n => String "8" (show_uint n)
  | D9 n => String "9" (show_uint n)
  end.

Definition show_int (n : int) : string :=
  match n with
  | Pos n => show_uint n
  | Neg n => String "-" (show_uint n)
  end.

Definition show_nat (n : nat) : string :=
  show_uint (Nat.to_uint n).

Definition show_bool (b : bool) : string :=
  match b with
  | true => "true"
  | false => "false"
  end.

Definition show_Z (n : Z) : string :=
  show_int (Z.to_int n).

Definition show_N : N -> string :=
  show_Z âˆ˜ Z.of_N.

Instance showUint : Show uint :=
{|
  show := show_uint
|}.

Instance showInt : Show int :=
{|
  show := show_int
|}.

Instance showNat : Show nat :=
{|
  show := show_nat
|}.

Instance showBool : Show bool :=
{|
  show := show_bool
|}.

Instance showZ : Show Z :=
{|
  show := show_Z
|}.

Instance showN : Show N :=
{|
  show := show_N
|}.

Fixpoint from_list (s : list ascii) : string :=
  match s with
  | [] => EmptyString
  | c :: s' => String c (from_list s')
  end.

Definition unit_digit (n : nat) : ascii :=
  ascii_of_nat ((n mod 10) + 48 ).

Definition three_digit (n : nat) : string :=
  let n0 := unit_digit n in
  let n1 := unit_digit (n / 10) in
  let n2 := unit_digit (n / 100) in
  from_list [n2; n1; n0].

Definition digit_of_ascii (c : ascii) : option nat :=
  let n := nat_of_ascii c in
  if ((48 <=? n)%nat && (n <=? 57)%nat)%bool then
    Some (n - 48)
  else
    None.

Definition unthree_digit (c2 c1 c0 : ascii) : option ascii :=
  let doa := digit_of_ascii in
  match doa c2, doa c1, doa c0 with
  | Some n2, Some n1, Some n0 =>
    Some (ascii_of_nat (n2 * 100 + n1 * 10 + n0))
  | _, _, _ => None
  end.

Fixpoint show_quoted_string (s:string) : string :=
  match s with
  | EmptyString => """"
  | String c s' =>
    let quoted_s' := show_quoted_string s' in
    let n := nat_of_ascii c in
    if ascii_dec c "009"  then
      "\t" ++ quoted_s'
    else if ascii_dec c "010"  then
      "\n" ++ quoted_s'
    else if ascii_dec c "013"  then
      "\r" ++ quoted_s'
    else if ascii_dec c """"  then
      "\""" ++ quoted_s'
    else if ascii_dec c "\"  then
      "\\" ++ quoted_s'
    else if ((n <? 32)%nat 
         || (126 <? n)%nat )%bool then
      "\" ++ three_digit n ++ quoted_s'
    else
      String c quoted_s'
  end.

Instance showString : Show string :=
{|
  show s := String """" (show_quoted_string s)
|}.

Fixpoint read_quoted_string (s : string) : option string :=
  match s with
  | String c s' =>
    if ascii_dec c """" then
      match s' with
      | EmptyString => Some EmptyString
      | _ => None
      end
    else if ascii_dec c "\" then
      match s' with
      | String c2 s'' =>
        if ascii_dec c2 "n" then
          option_map (String "010") (read_quoted_string s'')
        else if ascii_dec c2 "r" then
          option_map (String "013") (read_quoted_string s'')
        else if ascii_dec c2 "t" then
          option_map (String "009") (read_quoted_string s'')
        else if ascii_dec c2 "\" then
          option_map (String "\") (read_quoted_string s'')
        else if ascii_dec c2 """" then
          option_map (String """") (read_quoted_string s'')
        else
          match s'' with
          | String c1 (String c0 s''') =>
            match unthree_digit c2 c1 c0 with
            | Some c' => option_map (String c')
                                    (read_quoted_string s''')
            | None => None
            end
          | _ => None
          end
      | _ => None
      end
    else
      option_map (String c) (read_quoted_string s')
  | _ => None
  end.

Definition read_string (s : string) : option string :=
  match s with
  | EmptyString => None
  | String c s' => read_quoted_string s'
  end.

Fixpoint contents {A : Type} (s : A -> string) (l : list A) : string :=
  match l with
    | nil => ""%string
    | cons h nil => s h
    | cons h t => append (append (s h) "; ") (contents s t)
  end.

Instance showList {A : Type} `{_ : Show A} : Show (list A) :=
{|
  show l := append "[" (append (contents show l) "]")
|}.

Instance showPair {A B : Type} `{_ : Show A} `{_ : Show B} : Show (A * B) :=
{|
  show p := match p with (a,b) => ("(" ++ show a ++ "," ++  show b ++ ")")%string end
|}.

Instance showOpt {A : Type} `{_ : Show A} : Show (option A) :=
{|
  show x := match x with
              | Some x => "Some " ++ (show x)
              | None => "None"
            end
|}.

Instance showType : Show Type :=
{|
  show x := "nat :-)"
|}.

Instance showEx {A} `{_ : Show A} P : Show ({x : A | P x}) :=
  {|
    show ex := let '(exist _ x _) := ex in show x
  |}.

Require Import Ascii.
Definition nl : string := String "010" EmptyString.

Definition smart_paren (s : string) : string :=
  let fix aux s (b : bool) :=
      match s with
        | EmptyString => (if b then ")" else "", b)
        | String a s =>
          let (s', b) := aux s (orb b (nat_of_ascii a =? 32)%nat) in
          (String a s', b)
      end in
  let (s', b) := aux s false in
  if b then "(" ++ s' else s'.

Module ShowFunctions.

Class ReprSubset (A : Type) :=
  { representatives : list A }.

Instance repr_bool : ReprSubset bool :=
  {| representatives := [ true; false ] |}.

Instance repr_nat : ReprSubset nat :=
  {| representatives := [ 0 ; 1 ; 2 ; 17 ; 42 ] |}.

Instance repr_option {A} `{_ : ReprSubset A} : ReprSubset (option A) :=
  {| representatives := None :: map Some representatives |}.

Instance repr_list {A} `{_ : ReprSubset A} : ReprSubset (list A) :=
  {| representatives :=
       [] :: map (fun x => [x]) representatives
          ++ flat_map (fun x : A =>
                         map (fun y : A => [x;y]) representatives
                      ) representatives
  |}%list.

Instance repr_prod {A B} `{_ : ReprSubset A} `{_ : ReprSubset B} :
  ReprSubset (A * B) :=
  {| representatives :=
       flat_map (fun x : A =>
                   map (fun y : B => (x,y)) representatives
                ) representatives
  |}.

Fixpoint prepend {A : Type} (a : A) (l : list A) :=
  match l with
    | [] => []
    | h::t => a :: h :: prepend a t
  end.

Definition intersperse {A : Type} (a : A) (l : list A) :=
  match l with
    | [] => []
    | h::t => h :: prepend a t
  end.

Definition string_concat (l : list string) : string :=
  fold_left (fun a b => a ++ b) l "".

Instance show_fun {A B} `{_ : Show A} `{_ : ReprSubset A}
         `{_ : Show B} : Show (A -> B) :=
  {| show f :=
       "{ " ++ string_concat (intersperse " , "
                            (map (fun x => show x ++ " |-> " ++ show (f x))
                                 (@representatives A _)))
           ++ " }"
  |}.

End ShowFunctions.

Definition trace {A : Type} (s : string) (a : A) : A := a.
Definition deprecate {A : Type} (old new: string) (a : A) : A :=
  trace ("Deprecated function: " ++ old ++ ". Use " ++ new ++ " instead.") a. *)
Require Import State.
(* State:
Set Implicit Arguments.

Require Import GenLow.
Require Import RandomQC.
Require Import Coq.Strings.String.

Require Import StringOT.
Require Import FSets.FMapAVL.

Module Map := FMapAVL.Make(StringOT).

Record State := MkState
  { maxSuccessTests   : nat
  ; maxDiscardedTests : nat
  ; maxShrinkNo       : nat
  ; computeSize       : nat -> nat -> nat

  ; numSuccessTests   : nat
  ; numDiscardedTests : nat

  ; labels            : Map.t nat

  ; expectedFailure   : bool
  ; randomSeed        : RandomSeed

  ; numSuccessShrinks : nat
  ; numTryShrinks     : nat
  }.

Definition updTryShrinks (st : State) (f : nat -> nat) : State :=
  match st with
    | MkState mst mdt ms cs nst ndt ls e r nss nts =>
      MkState mst mdt ms cs nst ndt ls e r nss (f nts)
  end.

Definition updSuccessShrinks (st : State) (f : nat -> nat) : State :=
  match st with
    | MkState mst mdt ms cs nst ndt ls e r nss nts =>
      MkState mst mdt ms cs nst ndt ls e r (f nss) nts
  end. *)
Require Import GenLow GenHigh.
(* GenLow:
Set Warnings "-extraction-opaque-accessed,-extraction".
Set Warnings "-notation-overridden,-parsing".

Require Import ZArith List.
Require Import mathcomp.ssreflect.ssreflect.
From mathcomp Require Import ssrfun ssrbool ssrnat.
Require Import Numbers.BinNums.
Require Import Classes.RelationClasses.

From ExtLib.Structures Require Export
     Monads.
From ExtLib.Structures Require Import
     Functor Applicative.
Import MonadNotation.
Open Scope monad_scope.

From QuickChick Require Import
     GenLowInterface RandomQC RoseTrees Sets Tactics.

Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Set Bullet Behavior "Strict Subproofs".

Import ListNotations.

Open Scope fun_scope.
Open Scope set_scope.

Module GenLow : GenLowInterface.Sig.

  Inductive GenType (A:Type) : Type := MkGen : (nat -> RandomSeed -> A) -> GenType A.
  
  Definition G := GenType.

  Definition run {A : Type} (g : G A) := match g with MkGen f => f end.
  
  Definition returnGen {A : Type} (x : A) : G A :=
    MkGen (fun _ _ => x).

  Definition bindGen {A B : Type} (g : G A) (k : A -> G B) : G B :=
    MkGen (fun n r =>
             let (r1,r2) := randomSplit r in
             run (k (run g n r1)) n r2).
  
  Definition fmap {A B : Type} (f : A -> B) (g : G A) : G B :=
    MkGen (fun n r => f (run g n r)).

  Definition apGen {A B} (gf : G (A -> B)) (gg : G A) : G B :=
    bindGen gf (fun f => fmap f gg).

  Definition sized {A : Type} (f : nat -> G A) : G A :=
    MkGen (fun n r => run (f n) n r).

  Definition resize {A : Type} (n : nat) (g : G A) : G A :=
    match g with
    | MkGen m => MkGen (fun _ => m n)
    end.

  Definition promote {A : Type} (m : Rose (G A)) : G (Rose A) :=
    MkGen (fun n r => fmapRose (fun g => run g n r) m).

  Fixpoint rnds (s : RandomSeed) (n' : nat) : list RandomSeed :=
    match n' with
      | O => nil
      | S n'' =>
        let (s1, s2) := randomSplit s in
        cons s1 (rnds s2 n'')
    end.
  
  Fixpoint createRange (n : nat) (acc : list nat) : list nat :=
    match n with
      | O => List.rev (cons O acc)
      | S n' => createRange n' (cons n acc)
    end.

  Definition choose {A : Type} `{ChoosableFromInterval A} (range : A * A) : G A :=
    MkGen (fun _ r => fst (randomR range r)).

  Definition sample (A : Type) (g : G A) : list A :=
    match g with
      | MkGen m =>
        let rnd := newRandomSeed in
        let l := List.combine (rnds rnd 20) (createRange 10 nil) in
        List.map (fun (p : RandomSeed * nat) => let (r,n) := p in m n r) l
    end.
  
  Definition variant {A : Type} (p : SplitPath) (g : G A) : G A := 
    match g with 
      | MkGen f => MkGen (fun n r => f n (varySeed p r))
    end.
  
  Definition reallyUnsafeDelay {A : Type} : G (G A -> A) :=
    MkGen (fun r n g => (match g with MkGen f => f r n end)).
  
  Definition reallyUnsafePromote {r A : Type} (m : r -> G A) : G (r -> A) :=
    (bindGen reallyUnsafeDelay (fun eval => 
                                  returnGen (fun r => eval (m r)))).

  Definition semGenSize {A : Type} (g : G A) (s : nat) : set A := codom (run g s).
  Definition semGen {A : Type} (g : G A) : set A := \bigcup_s semGenSize g s.

  Definition semGenSizeOpt {A : Type} (g : G (option A)) (s : nat) : set A :=
    somes (semGenSize g s).

  Definition semGenOpt {A : Type} (g : G (option A)) : set A :=
    somes (semGen g).
  
  Lemma semGenOpt_equiv {A} (g : G (option A)) :
    semGenOpt g <--> \bigcup_s semGenSizeOpt g s.

  Lemma bindGen_aux {A : Type} (g : G A) (n : nat) (r : RandomSeed) : semGen g (run g n r).

  Definition bindGen' {A B : Type} (g : G A) (k : forall (a : A), (a \in semGen g) -> G B) : G B :=
    MkGen (fun n r =>
             let (r1,r2) := randomSplit r in
             run (k (run g n r1) (bindGen_aux g n r1)) n r2).

  Class Unsized {A} (g : G A) :=
    unsized : forall s1 s2, semGenSize g s1 <--> semGenSize g s2.
  
  Class SizedMonotonic {A} (g : nat -> G A) :=
    
    sizeMonotonic : forall s s1 s2,
      s1 <= s2 ->
      semGenSize (g s1) s \subset semGenSize (g s2) s.

  Class SizedMonotonicOpt {A} (g : nat -> G (option A)) :=
    sizeMonotonicOpt : forall s s1 s2,
      s1 <= s2 ->
      semGenSizeOpt (g s1) s \subset semGenSizeOpt (g s2) s.
  
  Class SizeMonotonic {A} (g : G A) :=
    monotonic : forall s1 s2,
      s1 <= s2 -> semGenSize g s1 \subset semGenSize g s2.

  Class SizeMonotonicOpt {A} (g : G (option A)) :=
    monotonicOpt : forall s1 s2,
      s1 <= s2 ->
      semGenSizeOpt g s1 \subset semGenSizeOpt g s2.

  Class SizeAntiMonotonicNone {A} (g : G (option A)) :=
    monotonicNone : forall s1 s2,
      s1 <= s2 ->
      isNone :&: semGenSize g s2 \subset isNone :&: semGenSize g s1.

  Lemma unsizedMonotonic {A} (g : G A) : Unsized g -> SizeMonotonic g. 
  
  Lemma unsized_alt_def :
    forall A (g : G A) `{Unsized _ g},
    forall s, semGenSize g s <--> semGen g.

  Lemma semReturn {A} (x : A) : semGen (returnGen x) <--> [set x].
  
  Lemma semReturnSize A (x : A) (s : nat) :
  semGenSize (returnGen x) s <--> [set x].
  
  Lemma semBindSize A B (g : G A) (f : A -> G B) (s : nat) :
    semGenSize (bindGen g f) s <-->
    \bigcup_(a in semGenSize g s) semGenSize (f a) s.
  
  Lemma semBindSize_subset_compat {A B : Type} (g g' : G A) (f f' : A -> G B) :
    (forall s, semGenSize g s \subset semGenSize g' s) ->
    (forall x s, semGenSize (f x) s \subset semGenSize (f' x) s) ->
    (forall s, semGenSize (bindGen g f) s \subset semGenSize (bindGen g' f') s).
  
  Lemma semBindSizeOpt_subset_compat {A B : Type} (g g' : G A) (f f' : A -> G (option B)) :
    (forall s, semGenSize g s \subset semGenSize g' s) ->
    (forall x s, isSome :&: semGenSize (f x) s \subset isSome :&: semGenSize (f' x) s) ->
    (forall s, isSome :&: semGenSize (bindGen g f) s \subset isSome :&: semGenSize (bindGen g' f') s).
  
  Lemma monad_leftid A B (a : A) (f : A -> G B) :
    semGen (bindGen (returnGen a) f) <--> semGen (f a).
  
  Lemma monad_rightid A (g : G A) : semGen (bindGen g returnGen) <--> semGen g.
  
  Lemma monad_assoc A B C (ga : G A) (fb : A -> G B) (fc : B -> G C) :
    semGen (bindGen (bindGen ga fb) fc) <--> 
    semGen (bindGen ga (fun a => bindGen (fb a) fc)).
  
  Lemma semBindUnsized1 {A B} (g : G A) (f : A -> G B) `{H : Unsized _ g}:
    semGen (bindGen g f) <--> \bigcup_(a in semGen g) semGen (f a).
  
  Lemma semBindUnsized2 :
    forall A B (g : G A) (f : A -> G B),
      (forall a, Unsized (f a)) ->
      semGen (bindGen g f) <--> \bigcup_(a in semGen g) semGen (f a).

  Lemma semBindSizeMonotonic {A B} (g : G A) (f : A -> G B)
        `{Hg : SizeMonotonic _ g} `{Hf : forall a, SizeMonotonic (f a)} :
    semGen (bindGen g f) <--> \bigcup_(a in semGen g) semGen (f a).
  
  Lemma semBindSizeMonotonicIncl_r {A B} (g : G A) (f : A -> G (option B)) (s1 : set A) (s2 : A -> set B) :
    semGen g \subset s1 ->
    (forall x, semGen (f x) \subset Some @: (s2 x) :|: [set None]) -> 
    semGen (bindGen g f) \subset Some @: (\bigcup_(a in s1) s2 a)  :|: [set None].

  Lemma semBindSizeMonotonicIncl_l {A B} (g : G A) (f : A -> G (option B)) (s1 : set A)
        (fs : A -> set B) 
        `{Hg : SizeMonotonic _ g}
        `{Hf : forall a, SizeMonotonicOpt (f a)} :
    s1 \subset semGen g ->
    (forall x, Some @: (fs x) \subset semGen (f x)) ->
    (Some @: \bigcup_(a in s1) (fs a)) \subset semGen (bindGen g f).

  Lemma semFmapSize A B (f : A -> B) (g : G A) (size : nat) :
    semGenSize (fmap f g) size <--> f @: semGenSize g size.  Proof.
  
  Lemma semFmap A B (f : A -> B) (g : G A) :
    semGen (fmap f g) <--> f @: semGen g.

  Lemma semChooseSize A `{ChoosableFromInterval A} (a1 a2 : A) :
    RandomQC.leq a1 a2 ->
  
  Lemma semChoose A `{RandomQC.ChoosableFromInterval A} (a1 a2 : A) :

  Lemma promoteVariant :
    forall {A B : Type} (a : A) (f : A -> SplitPath) (g : G B) size
      (r r1 r2 : RandomSeed),
      randomSplit r = (r1, r2) ->
      run (reallyUnsafePromote (fun a => variant (f a) g)) size r a =
      run g size (varySeed (f a) r1).

  Lemma semPromote A (m : Rose (G A)) :
    semGen (promote m) <-->
    codom2 (fun size seed => fmapRose (fun g => run g size seed) m).

  Lemma semPromoteSize (A : Type) (m : Rose (G A)) n :
    semGenSize (promote m) n <-->
               codom (fun seed => fmapRose (fun g => run g n seed) m).

  Lemma runPromote A (m : Rose (G A)) seed size :
    run (promote m) seed size = fmapRose (fun (g : G A) => run g seed size) m.

  Lemma runFmap (A B : Type) (f : A -> B) (g : G A) seed size :
    run (fmap f g) seed size = f (run g seed size).

  Lemma semFmapBind :
    forall A B C (g : G A) (f1 : B -> C) (f2 : A -> G B),
      semGen (fmap f1 (bindGen g f2)) <-->
      semGen (bindGen g (fun x => fmap f1 (f2 x))).

  Lemma semSized A (f : nat -> G A) :
    semGen (sized f) <--> \bigcup_n semGenSize (f n) n.

  Lemma semSizedSize A(f:nat->G A)s : semGenSize (sized f) s <--> semGenSize (f s) s.

  Lemma semSized_opt A (f : nat -> G (option A)) (H : forall n, SizeMonotonicOpt (f n)) (H' : SizedMonotonicOpt f) :
    isSome :&: semGen (sized f) <--> isSome :&: \bigcup_n (semGen (f n)).

  Lemma semSized_alt A (f : nat -> G A) (H : forall n, SizeMonotonic (f n))
        (H' : forall n m s,  n <= m -> semGenSize (f n) s \subset semGenSize (f m) s) :
    semGen (sized f) <--> \bigcup_n (semGen (f n)).
  
  Lemma semResize A n (g : G A) : semGen (resize n g) <--> semGenSize g n .

  Lemma semSizeResize A (s n : nat) (g : G A) :
    semGenSize (resize n g) s <--> semGenSize g n.

  Lemma semGenSizeInhabited {A} (g : G A) s :
    exists x, semGenSize g s x.

  Instance Functor_G : Functor G := {
    fmap A B := fmap;
  }.

  Instance Applicative_G : Applicative G := {
    pure A := returnGen;
    ap A B := apGen;
  }.

  Instance Monad_G : Monad G := {
    ret A := returnGen;
    bind A B := bindGen;
  }.

  Definition thunkGen {A} (f : unit -> G A) : G A :=
    MkGen (fun n r => run (f tt) n r).

  Lemma semThunkGenSize {A} (f : unit -> G A) s :
    semGenSize (thunkGen f) s <--> semGenSize (f tt) s.

  Lemma semThunkGen {A} (f : unit -> G A) :
    semGen (thunkGen f) <--> semGen (f tt).

End GenLow. *)
(* GenHigh:
Set Warnings "-extraction-opaque-accessed,-extraction".
Set Warnings "-notation-overridden,-parsing".

Require Import ZArith.
Require Import mathcomp.ssreflect.ssreflect.
From mathcomp Require Import ssrfun ssrbool ssrnat eqtype seq.

From QuickChick Require Import
     GenLow GenLowInterface
     GenHighImpl GenHighInterface
     RandomQC Tactics Sets.

Set Bullet Behavior "Strict Subproofs".

Import GenLow.
Module Import GenHigh := GenHighImpl.Impl GenLow.

Import QcDefaultNotation.

Lemma oneOf_freq {A} (g : G A) (gs : list (G A)) size :
  semGenSize (oneOf (g ;; gs)) size <-->
  semGenSize (freq ((1, g) ;; map (fun x => (1, x)) gs)) size.

Lemma semFreq :
  forall {A : Type} (ng : nat * G A) (l : seq (nat * G A)),
    List.Forall (fun x => x.1 > 0) (ng :: l) ->

Lemma semFreqSize :
  forall {A : Type} (ng : nat * G A) (l : seq (nat * G A)) (size : nat),
    List.Forall (fun x => x.1 > 0) (ng :: l) ->

Lemma bigcup_cons_setI_subset_compat_backtrack_weak
      {A} (n : nat) (g g' : G (option A)) (l l' : seq (nat * G (option A))) :
  (forall s, isSome :&: semGenSize g s  \subset isSome :&: semGenSize g' s) ->
  (forall s, \bigcup_(x in (l :&: (fun x => x.1 <> 0))) (isSome :&: semGenSize x.2 s) \subset

Lemma bigcup_cons_setI_subset_pres_backtrack_weak
      {A} (n : nat) (g : G (option A)) (l l' : seq (nat * G (option A))) :
  (forall s, \bigcup_(x in (l :&: (fun x => x.1 <> 0))) (isSome :&: semGenSize x.2 s) \subset *)
Require Import Classes.
(* Classes:
Set Warnings "-extraction-opaque-accessed,-extraction".
Set Warnings "-notation-overridden,-parsing".

Require Import Coq.Classes.Morphisms.
Require Import mathcomp.ssreflect.ssreflect.
From mathcomp Require Import ssrbool ssrnat.
Require Import Sets GenLow Tactics.
Require Import Recdef.
Require Import List.

Require Import ZArith ZArith.Znat Arith.

Import GenLow.

Set Bullet Behavior "Strict Subproofs".

Fixpoint appn {A} (f : A -> A) (n : nat) : A ->  A :=
  fun x =>
    match n with
      | 0%nat => x
      | S n' => f (appn f n' x)
    end.

Infix "^" := appn (at level 30, right associativity) : fun_scope.

  Class GenSized (A : Type) := { arbitrarySized : nat -> G A }.

  Class Gen (A : Type) := { arbitrary : G A }.

Class Shrink (A : Type) :=
  { shrink : A -> list A }.

Class Arbitrary (A : Type) `{Gen A} `{Shrink A}.

Class Sized (A : Type) :=
  { size : A -> nat }.

Class CanonicalSized (A : Type) `{Sized A} :=
  {
    zeroSized : set A;
    succSized : set A -> set A;

    zeroSized_spec : zeroSized <--> [ set x : A | size x = 0 ];
    succSized_spec :
      forall n, succSized [ set x : A | size x <= n ] <--> [ set x : A | size x <= S n ]
 
  }.

Lemma size_ind (A : Type) `{Hyp : Sized A} :
  forall (P : A -> Prop), (forall y, (forall x, size x < size y -> P x) -> P y) -> (forall x, P x).

Lemma size_lfp (A : Type) `{Hyp : CanonicalSized A} :
  [set x : A | True ] <--> \bigcup_(s : nat) [set x : A | size x <= s ].

Lemma succ_lfp (A : Type) `{Hyp : CanonicalSized A}
      `{Proper _ (respectful set_eq set_eq) succSized} s :
  [set x : A | size x <= s ] <-->  (succSized ^ s) zeroSized.

Class SizedCorrect {A : Type} `{Sized A} (g : nat -> G A) :=
  {
    arbitrarySizedCorrect : forall s, semGen (g s) <--> [set x : A | size x <= s ]
  }.

Class Correct (A : Type) (g : G A)  :=
  {
    arbitraryCorrect : semGen g <--> [set : A]
  }.

Class GenSizedMonotonic (A : Type) `{GenSized A}
      `{forall s, SizeMonotonic (arbitrarySized s)}.

Class GenSizedSizeMonotonic (A : Type) `{GenSized A} `{SizedMonotonic A arbitrarySized}.

Class GenMonotonic (A : Type) `{Gen A} `{SizeMonotonic A arbitrary}.

Class GenSizedCorrect (A : Type) `{GenSized A} `{SizedCorrect A arbitrarySized}.

Class GenCorrect (A : Type) `{Gen A} `{Correct A arbitrary}.
 
Class GenMonotonicCorrect (A : Type)
      `{Gen A} `{SizeMonotonic A arbitrary} `{Correct A arbitrary}.

Instance GenSizedMonotonicOfSizeMonotonic
         (A : Type) (Hgen : GenSized A) (Hmon : forall s, @SizeMonotonic A (arbitrarySized s))
: @GenSizedMonotonic A Hgen Hmon.
  
Instance GenMonotonicOfSizeMonotonic
         (A : Type) (Hgen : Gen A) (Hmon : @SizeMonotonic A arbitrary)
: @GenMonotonic A Hgen Hmon.

Instance GenSizedCorrectOfSizedCorrect
         (A : Type) (Hgen : GenSized A) `{Hcor : SizedCorrect A arbitrarySized}
: @GenSizedCorrect A Hgen _ Hcor.

Instance GenCorrectOfCorrect
         (A : Type) (Hgen : Gen A) `{Hcor : Correct A arbitrary}
: @GenCorrect A Hgen Hcor.

Instance GenSizedSizeMonotonicOfSizedMonotonic
         (A : Type) (Hgen : GenSized A) (Hmon : @SizedMonotonic A arbitrarySized)
: @GenSizedSizeMonotonic A Hgen Hmon.

Global Instance GenOfGenSized {A} `{GenSized A} : Gen A :=
  {| arbitrary := sized arbitrarySized |}.

Global Instance ArbitraryOfGenShrink {A} `{Gen A} `{Shrink A} : Arbitrary A.

Lemma nat_set_ind (A : Type) `{GenSized A} `{Hyp : CanonicalSized A} :
  (semGen (arbitrarySized 0) <--> zeroSized) ->
  (forall (s : nat) (elems : set A),
     semGen (arbitrarySized s) <--> elems ->
     semGen (arbitrarySized (s.+1)) <--> succSized elems) -> *)
Require Import DependentClasses.
(* DependentClasses:
 *)

Import GenLow GenHigh.

Inductive CallbackKind :=
| Counterexample
| NotCounterexample.

Inductive SmallResult :=
  MkSmallResult : option bool -> bool -> string -> bool ->
                  list string -> option string -> SmallResult.

Inductive Callback : Type :=
| PostTest :
    CallbackKind -> (State -> SmallResult -> nat) -> Callback
| PostFinalFailure :
    CallbackKind -> (State -> SmallResult -> nat) -> Callback.

Record Result :=
  MkResult {
      ok          : option bool; 
      expect      : bool;        
      reason      : string;      
      interrupted : bool;        
      stamp       : list string; 
      callbacks   : list Callback; 
      result_tag  : option string 
    }.

Definition debug_stamps s {A : Type} (r : Result) (x : A) :=
  trace (s ++ (ShowFunctions.string_concat (
             (ShowFunctions.intersperse " @ "%string (stamp r)))) ++ nl) x.

Definition succeeded := MkResult (Some true ) true "" false nil nil None.
Definition failed    := MkResult (Some false) true "" false nil nil None.
Definition rejected  := MkResult (   None   ) true "" false nil nil None.

Definition updExpect (res : Result) (e' : bool) : Result :=
  match res with
    | MkResult o e r i s c t => MkResult o e' r i s c t
  end.

Definition updReason (r : Result) (s' : string) : Result :=
  match r with
    | MkResult o e _ i s c t => MkResult o e s' i s c t
  end.

Definition updOk (r : Result) o' : Result :=
  match r with
    | MkResult _ e r i s c t => MkResult o' e r i s c t
  end.

Definition addCallback (res : Result) (c : Callback) : Result :=
  match res with
    | MkResult o e r i s cs t => MkResult o e r i s (cons c cs) t
  end.

Definition addCallbacks (res : Result) (cs : list Callback) : Result :=
  match res with
    | MkResult o e r i s cs' t => MkResult o e r i s (cs ++ cs') t
  end.

Definition addStamps res ss :=
  match res with
    | MkResult o e r i s cs t => MkResult o e r i (ss ++ s) cs t
  end.

Definition setTag (r : Result) (t' : string) : Result :=
  match r with 
    | MkResult o e r i s cs _ => MkResult o e r i s cs (Some t')
  end.

Record QProp : Type :=
  MkProp
    {
      unProp : Rose Result
    }.

Definition Checker : Type := G QProp.

Class Checkable (A : Type) : Type :=
  {
    checker : A -> Checker
  }.

Definition liftBool (b : bool) : Result :=
  if b then succeeded else updReason failed "Falsifiable".

Definition mapProp {P : Type} {_ : Checkable P}
           (f : QProp -> QProp) (prop : P) : Checker :=
  fmap f (checker prop).

Definition mapRoseResult {P : Type} {_ : Checkable P}
           (f : Rose Result -> Rose Result) (prop : P) : Checker :=
  mapProp (fun p => match p with MkProp t => MkProp (f t) end) prop.

Definition mapTotalResult {prop : Type} {_ : Checkable prop}
           (f : Result -> Result) : prop -> Checker :=
  mapRoseResult (fmapRose f).

Global Instance testResult : Checkable Result :=
  {|
    
    checker r := returnGen (MkProp (returnRose r))
  |}.

Global Instance testBool : Checkable bool :=
  {|
    checker b := checker (liftBool b)
  |}.

Global Instance testUnit : Checkable unit :=
  {|
    checker := fun _ => checker rejected
  |}.

Global Instance testProp : Checkable QProp :=
  {|
    checker p := returnGen p
  |}.

Global Instance testGenProp (P : Type) `{Checkable P} : Checkable (G P) :=
  {|
    checker p := bindGen p checker
  |}.

Global Instance testChecker : Checkable Checker :=
  {|
      checker x := x
  |}.

Fixpoint props' {prop A : Type} {t : Checkable prop} (n : nat)
         (pf : A -> prop) (shrinker : A -> list A) (x : A) :=
  match n with
    | O =>
      MkRose (checker (pf x)) (lazy nil)
    | S n' =>
      MkRose (checker (pf x)) (lazy (List.map (props' n' pf shrinker) (shrinker x)))
  end.

Definition props {prop A : Type} `{Checkable prop}
           (pf : A -> prop) (shrinker : A -> list A) (x : A) : Rose Checker :=
  props' 1000 pf shrinker x.

Definition shrinking {prop A : Type} `{Checkable prop}
           (shrinker : A -> list A) (x0 : A) (pf : A -> prop) : Checker :=
  fmap (fun x => MkProp (joinRose (fmapRose unProp x)))
       (promote (props pf shrinker x0)).

Definition shrinkingNondet {prop A : Type} `{Checkable prop} (n : nat)
          (shrinker : A -> list A) (x0 : A) (pf : A -> prop) : Checker :=
  fmap (fun x => MkProp (repeatRose n (joinRose (fmapRose unProp x))))
       (promote (props pf shrinker x0)).
  
Definition callback {prop : Type} `{Checkable prop}
           (cb : Callback) : prop -> Checker :=
  mapTotalResult (fun r => addCallback r cb).

Definition printTestCase {prop : Type} `{Checkable prop}
           (s : string) (p : prop) : Checker :=
  
  callback (PostFinalFailure Counterexample (fun _st _res => trace (s ) 0)) p.

Definition whenFail {prop : Type} `{Checkable prop}
           (str : string) : prop -> Checker :=
  callback (PostFinalFailure Counterexample (fun _st _sr => trace (str ++ nl) 0)).

Definition whenFail' {prop : Type} `{Checkable prop}
           (str : unit -> string) : prop -> Checker :=
  callback (PostFinalFailure Counterexample (fun _st _sr => trace (str tt ++ nl) 0)).

Notation "x 'WHENFAIL' y" := (whenFail' (fun _ => x) y) (at level 55).

Definition expectFailure {prop: Type} `{Checkable prop} (p: prop) :=
  mapTotalResult (fun res => updExpect res false) p.

Definition cover {prop : Type} {_ : Checkable prop}
           (b : bool) (n : nat) (s : string) : prop -> Checker :=
  if b then
    mapTotalResult (fun res =>
                      let '(MkResult o e r i st c t) := res in
                      MkResult o e r i (s :: st) c t)
  else checker.

Definition classify {prop : Type} {_ : Checkable prop}
           (b : bool) (s : string) : prop -> Checker :=
  cover b 0 s.

Definition label {prop : Type} {_ : Checkable prop}
           (s : string) : prop -> Checker :=
  classify true s.

Definition collect {A prop : Type} `{_ : Show A} {_ : Checkable prop}
           (x : A) : prop -> Checker :=
  label (show x).

Definition tag {prop : Type} {_ : Checkable prop} (t : string) : prop -> Checker :=
  mapTotalResult (fun res => setTag res t).

Definition implication {prop : Type} `{Checkable prop} (b : bool) (p : prop) : Checker :=
  if b then checker p else (returnGen (MkProp (returnRose rejected))).

Definition forAll {A prop : Type} {_ : Checkable prop} `{Show A}
           (gen : G A)  (pf : A -> prop) : Checker :=
  bindGen gen (fun x =>
                 printTestCase (show x ++ newline) (pf x)).

Definition forAllMaybe {A prop : Type} {_ : Checkable prop} `{Show A}
           (gen : G (option A))  (pf : A -> prop) : Checker :=
  bindGen gen (fun mx =>
                 match mx with
                 | Some x => printTestCase (show x ++ newline) (pf x)
                 | None => checker tt
                 end
              ).

Definition forAllProof {A prop : Type} {C : Checkable prop} `{S : Show A}
           (gen : G A)  (pf : forall (x : A), semGen gen x -> prop) : Checker :=
  bindGen' gen (fun x H => printTestCase (show x ++ newline) (pf x H)).
Arguments forAllProof {A} {prop} {C} {S} _ _.

Definition forAllShrink {A prop : Type} {_ : Checkable prop} `{Show A}
           (gen : G A) (shrinker : A -> list A) (pf : A -> prop) : Checker :=

  bindGen gen (fun x : A =>
                 shrinking shrinker x (fun x' =>
                                         printTestCase (show x' ++ newline) (pf x'))).

Definition forAllShrinkNonDet {A prop : Type} {_ : Checkable prop} `{Show A}
           (n : nat) (gen : G A) (shrinker : A -> list A) (pf : A -> prop) : Checker :=

  bindGen gen (fun x : A =>
                 shrinkingNondet n shrinker x (fun x' =>
                                         printTestCase (show x' ++ newline) (pf x'))).

Definition forAllShrinkShow {A prop : Type} {_ : Checkable prop}
           (gen : G A) (shrinker : A -> list A) (show' : A -> string) (pf : A -> prop) : Checker :=
  bindGen gen (fun x =>
                 shrinking shrinker x (fun x' =>
                                         printTestCase (show' x') (pf x'))).

Global Instance testFun {A prop : Type} `{Show A}
       `{Arbitrary A} `{_ : Checkable prop} : Checkable (A -> prop) :=
  {
    checker f := forAllShrink arbitrary shrink f
  }.

Global Instance testProd {A : Type} {prop : A -> Type} `{Show A} `{Arbitrary A} 
       `{forall x : A, Checkable (prop x)} :
  Checkable (forall (x : A), prop x) := 
  {| checker f := forAllShrink arbitrary shrink (fun x => checker (f x)) |}.

Global Instance testPolyFun {prop : Type -> Type} {_ : Checkable (prop nat)} : Checkable (forall T, prop T) :=
  {
    checker f := printTestCase "" (f nat)
  }.

Global Instance testPolyFunSet {prop : Set -> Type} {_ : Checkable (prop nat)} : Checkable (forall T, prop T) :=
  {
    checker f := printTestCase "" (f nat)
  }.

Definition addCallbacks' r result := 
  addCallbacks result (callbacks r).
Definition addStamps' r result := 

  let res := addStamps result (stamp r) in

  res.

Fixpoint conjAux (f : Result -> Result) 
         l := 
  match l with 
    | nil => (MkRose (f succeeded) (lazy nil))
    | cons res rs => 
      let '(MkRose r _) := res in
      match ok r with 
        | Some true =>
           (conjAux (fun r' => addStamps' r (addCallbacks' r (f r'))
                    ) rs)
        | Some false => res
        | None =>
          let res' := conjAux (fun r' => (addCallbacks' r (f r'))) rs in
          let '(MkRose r' rs) := res' in
          match ok r' with 
            | Some true => MkRose (updOk r' None) (lazy nil)
            | Some false => res'
            | None => res'
          end
      end
  end.

Definition mapGen {A B} (f : A -> G B) (l : list A) : G (list B) :=
  bindGen (foldGen (fun acc a => 
             bindGen (f a) (fun b => returnGen (cons b acc)))
          l nil) (fun l => returnGen (rev l)).

Fixpoint conjoin (l : list Checker) : Checker :=

  bindGen (mapGen (liftGen unProp) l) (fun rs =>
          (returnGen (MkProp (let res := conjAux (fun x => x) rs in
                              let '(MkRose r _) := res in 
                               res
                             )))).

Definition fmapRose' A B (r : Rose A) (f : A -> B) := fmapRose f r.

Definition expectFailureError := 
  updReason failed "Expect failure cannot occur inside a disjunction".

Definition disjAux (p q : Rose Result) : Rose Result :=
  joinRose (fmapRose' p (fun result1 =>
  if expect result1 then
    match ok result1 with 
    | Some true => returnRose result1
    | Some false => 
      joinRose (fmapRose' q (fun result2 =>
      if expect result2 then
        match ok result2 with 
        | Some true => returnRose result2
        | Some false => 
          returnRose (MkResult (ok result2)
                               (expect result2)
                               (if string_dec (reason result2) EmptyString 
                                then reason result1
                                else reason result2)
                               (orb (interrupted result1) (interrupted result2))
                               (stamp result1 ++ stamp result2)
                               (callbacks result1 ++ 
                                    cons (PostFinalFailure Counterexample
                                                      (fun _ _ => trace newline 0)) nil ++
                                    callbacks result2 )
                               (result_tag result2))
        | None => returnRose result2 
        end
      else returnRose expectFailureError))
    | None => 
      joinRose (fmapRose' p (fun result2 => 
      if expect result2 then 
        match ok result2 with
        | Some true => returnRose result2
        | _ => returnRose result1 
        end
      else returnRose expectFailureError))
    end
  else returnRose expectFailureError)).

Definition disjoin (l : list Checker) : Checker := 
  bindGen (mapGen (liftGen unProp) l) (fun rs =>
          (returnGen (MkProp (
                          fold_right disjAux (returnRose failed) rs
                        )))).

Module QcNotation.
  Export QcDefaultNotation.

  Notation "x ==> y" := (implication x y) (at level 55, right associativity)
                           : Checker_scope.

  Notation "'FORALL' x : T , c" :=
    (forAllShrink (@arbitrary T _) shrink (fun x => c))
    (at level 200, x ident, T at level 200, c at level 200, right associativity
      )
    : type_scope.

  Notation "'FORALL' x | P , c" :=
    (forAllShrink (genST (fun x => P)) shrink (fun y => match y with
                                                    | Some x => c
                                                    | _ => checker tt
                                                    end))
      (at level 200, x ident, P at level 200, c at level 200, right associativity)
     : type_scope.
End QcNotation.

