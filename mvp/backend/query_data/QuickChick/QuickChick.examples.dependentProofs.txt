From QuickChick Require Import QuickChick Tactics Instances Classes DependentClasses.

Require Import String. Open Scope string.

Require Import List.



From mathcomp Require Import ssreflect ssrfun ssrbool ssrnat eqtype seq.



Import GenLow GenHigh .



Import ListNotations.

Import QcDefaultNotation. Open Scope qc_scope.



Set Bullet Behavior "Strict Subproofs".



Typeclasses eauto := debug.



Require Import DependentTest.
(* DependentTest:
Set Warnings "-extraction-opaque-accessed,-extraction".
Set Warnings "-notation-overridden,-parsing".

From QuickChick Require Import QuickChick Tactics.
Require Import String. Open Scope string.

From mathcomp Require Import ssreflect ssrfun ssrbool ssrnat eqtype seq.

Import GenLow GenHigh.
Require Import List.
Import ListNotations.
Import QcDefaultNotation. Open Scope qc_scope.

Require Export ExtLib.Structures.Monads.
Import MonadNotation.
Open Scope monad_scope.

Set Bullet Behavior "Strict Subproofs".

Derive ArbitrarySizedSuchThat for (fun x => eq x y).

Definition GenSizedSuchThateq_manual {A} (y_ : A) :=
  let fix aux_arb (size : nat) (y_0 : A) {struct size} : G (option A) :=
      match size with
      | 0   => backtrack [(1, returnGen (Some y_0))]
      | S _ => backtrack [(1, returnGen (Some y_0))]
      end
  in aux_arb^~ y_.

Theorem GenSizedSuchThateq_proof A (n : A) :
  GenSizedSuchThateq_manual n = @arbitrarySizeST _ (fun x => eq x n) _.

Inductive Foo :=
| Foo1 : Foo 
| Foo2 : Foo -> Foo
| Foo3 : nat -> Foo -> Foo.

QuickChickWeights [(Foo1, 1); (Foo2, size); (Foo3, size)].
Derive (Arbitrary, Show) for Foo.

Fixpoint showFoo' (x : Foo) := 
  match x with 
  | Foo1 => "Foo1"
  | Foo2 f => "Foo2 " ++ smart_paren (showFoo' f)
  | Foo3 n f => "Foo3 " ++ smart_paren (show n) ++
                        " " ++ smart_paren (showFoo' f)
  end%string.

Lemma show_foo_equality : showFoo' = (@show Foo _).

Fixpoint genFooSized (size : nat) := 
  match size with 
  | O => returnGen Foo1
  | S size' => freq [ (1, returnGen Foo1) 
                    ; (S size', f <- genFooSized size';;
                                  ret (Foo2 f))
                    ; (S size', n <- arbitrary ;;
                                f <- genFooSized size' ;;
                                ret (Foo3 n f)) 
                    ]
  end.                 
                                           
Fixpoint shrink_foo x := 
  match x with
  | Foo1 => []
  | Foo2 f => ([f] ++ map (fun f' => Foo2 f') (shrink_foo f) ++ []) ++ []
  | Foo3 n f => (map (fun n' => Foo3 n' f) (shrink n) ++ []) ++
                ([f] ++ map (fun f' => Foo3 n f') (shrink_foo f) ++ []) ++ []
  end.

Lemma genFooSizedNotation : genFooSized = @arbitrarySized Foo _.

Lemma shrinkFoo_equality : shrink_foo = @shrink Foo _.

Inductive goodFoo : nat -> Foo -> Prop :=
| GoodFoo : forall n foo,  goodFoo n foo.

Derive ArbitrarySizedSuchThat for (fun foo => goodFoo n foo).

Definition g : G (option Foo) := @arbitrarySizeST _ (fun x => goodFoo 0 x) _ 4.

Definition genGoodFoo `{_ : Arbitrary Foo} (n : nat)  :=
  let fix aux_arb size n := 
    match size with 
    | 0   => backtrack [(1, foo <- arbitrary ;; ret (Some foo))]
    | S _ => backtrack [(1, foo <- arbitrary ;; ret (Some foo))]
    end
  in fun sz => aux_arb sz n.

Lemma genGoodFoo_equality n : 
  genGoodFoo n = @arbitrarySizeST _ (fun foo => goodFoo n foo) _.

Definition genGoodFoo'' `{_ : Arbitrary Foo} (n : nat) :=
  let fix aux_arb size n := 
    match size with 
    | 0   => backtrack [(1, 

      foo <- arbitrary;; ret (Some foo)

                        )]
    | S _ => backtrack [(1, foo <- arbitrary;; ret (Some foo))]
    end
  in fun sz => aux_arb sz n.

Lemma genGoodFoo_equality' : genGoodFoo = genGoodFoo''.
 
Inductive goodFooUnif : nat -> Foo -> Prop := 
| GoodUnif : forall n, goodFooUnif n Foo1.

Derive ArbitrarySizedSuchThat for (fun foo => goodFooUnif n foo).

Definition genGoodUnif (n : nat) :=
  let fix aux_arb size n := 
    match size with 
    | 0   => backtrack [(1, 

  ret (Some Foo1)

                        )] 
    | S _ => backtrack [(1, ret (Some Foo1))] 
    end
  in fun sz => aux_arb sz n.

Lemma genGoodUnif_equality n : 
  genGoodUnif n = @arbitrarySizeST _ (fun foo => goodFooUnif n foo) _. 

Inductive goodFooCombo : nat -> Foo -> Prop :=
| GoodCombo : forall n foo, goodFooCombo n (Foo2 foo).

Derive ArbitrarySizedSuchThat for (fun foo => goodFooCombo n foo).

Definition genGoodCombo `{_ : Arbitrary Foo} (n : nat) :=
  let fix aux_arb size n := 
    match size with 
    | 0   => backtrack [(1, 

   foo <- arbitrary;; ret (Some (Foo2 foo))

                        )] 
    | S _ => backtrack [(1, foo <- arbitrary;; ret (Some (Foo2 foo)))]
    end
  in fun sz => aux_arb sz n.

Lemma genGoodCombo_equality n : 
  genGoodCombo n = @arbitrarySizeST _ (fun foo => goodFooCombo n foo) _.

Inductive goodFooMatch : nat -> Foo -> Prop := 
| GoodMatch : goodFooMatch 0 Foo1.

Derive ArbitrarySizedSuchThat for (fun foo => goodFooMatch n foo).

Definition genGoodMatch (n : nat) :=
  let fix aux_arb size n := 
    match size with 
    | 0   => backtrack [(1, 

  match n with
  | 0 => ret (Some Foo1)
  | _.+1 => ret None
  end

                        )]
    | S _ => backtrack [(1,
           match n with
           | 0 => ret (Some Foo1)
           | _.+1 => ret None
           end)]
    end
  in fun sz => aux_arb sz n.

Lemma genGoodMatch_equality n : 
  genGoodMatch n = @arbitrarySizeST _ (fun foo => goodFooMatch n foo) _.

Inductive goodFooRec : nat -> Foo -> Prop :=
| GoodRecBase : forall n, goodFooRec n Foo1
| GoodRec : forall n foo, goodFooRec 0 foo -> goodFooRec n (Foo2 foo).

Derive ArbitrarySizedSuchThat for (fun foo => goodFooRec n foo).

Definition genGoodRec (n : nat) :=
  let fix aux_arb size n : G (option Foo) := 
    match size with 
    | 0 => backtrack [(1, ret (Some Foo1))]
    | S size' => backtrack [ (1, ret (Some Foo1))
                           ; (1, bindGenOpt (aux_arb size' 0) (fun foo => 
                                 ret (Some (Foo2 foo)))) ]
    end
  in fun sz => aux_arb sz n.

Lemma genGoodRec_equality n :
  genGoodRec n = @arbitrarySizeST _ (fun foo => goodFooRec n foo) _. 

Inductive goodFooPrec : nat -> Foo -> Prop :=
| GoodPrecBase : forall n, goodFooPrec n Foo1
| GoodPrec : forall n foo, goodFooPrec 0 Foo1 -> goodFooPrec n foo.

Derive DecOpt for (goodFooPrec n foo).

Definition DecOptgoodFooPrec_manual (n_ : nat) (foo_ : Foo) := 
 let fix aux_arb (size0 n_0 : nat) (foo_0 : Foo) {struct size0} : option bool :=
     match size0 with
     | 0 =>
       checker_backtrack
         [(fun u:unit =>
          match foo_0 with
          | Foo1 => Some true
          | Foo2 _ => None
          | Foo3 _ _ => None
          end
         )]
     | size'.+1 =>
       checker_backtrack
         [(fun _ =>
          match foo_0 with
          | Foo1 => Some true
          | Foo2 _ => None
          | Foo3 _ _ => None
          end)
        ;(fun _ =>
          match aux_arb size' 0 Foo1 with
          | Some _ => Some true
          | None => None
          end)
         ]
     end in
 fun size0 : nat => aux_arb size0 n_ foo_.
Theorem DecOptgoodFooPrec_proof n foo :
  DecOptgoodFooPrec_manual n foo = @decOpt (goodFooPrec n foo) _.

Derive ArbitrarySizedSuchThat for (fun foo => goodFooPrec n foo).

Definition genGoodPrec (n : nat) : nat -> G (option (Foo)):=
 let
   fix aux_arb size (n : nat) : G (option (Foo)) :=
     match size with
     | O => 
                      backtrack [ (1, ret (Some Foo1))
                     ; (1, match @decOpt (goodFooPrec O Foo1) _ 42 with
                           | Some true => foo <- arbitrary;;
                                          ret (Some foo)
                           | _ => ret None
                           end
                     )]

     | S size' =>
         backtrack [ (1, ret (Some Foo1))
                     ; (1, match @decOpt (goodFooPrec O Foo1) _ 42 with
                           | Some true => foo <- arbitrary;;
                                          ret (Some foo)
                           | _ => ret None
                           end
                     )]
     end in fun sz => aux_arb sz n.

Lemma genGoodPrec_equality n : 
  genGoodPrec n = @arbitrarySizeST _ (fun foo => goodFooPrec n foo) _.

Inductive goodFooNarrow : nat -> Foo -> Prop :=
| GoodNarrowBase : forall n, goodFooNarrow n Foo1
| GoodNarrow : forall n foo, goodFooNarrow 0 foo -> 
                        goodFooNarrow 1 foo -> 
                        goodFooNarrow n foo.

Derive DecOpt for (goodFooNarrow n foo).

Definition goodFooNarrow_decOpt (n_ : nat) (foo_ : Foo) :=
  let fix aux_arb (size0 n_0 : nat) (foo_0 : Foo) : option bool :=
      match size0 with
      | 0 =>
        checker_backtrack
          [(fun _ : unit =>
             match foo_0 with
             | Foo1 => Some true
             | Foo2 _ => None
             | Foo3 _ _ => None
             end)]
      | size'.+1 =>
        checker_backtrack
          [(fun _ : unit =>
             match foo_0 with
             | Foo1 => Some true
             | Foo2 _ => None
             | Foo3 _ _ => None
             end) ;
           (fun _ : unit =>
                 match aux_arb size' 0 foo_0 with
                 | Some _ =>
                   match aux_arb size' 1 foo_0 with
                   | Some _ => Some true
                   | None => None
                   end
                 | None => None
                 end)]
      end in
  fun size0 : nat => aux_arb size0 n_ foo_.
Lemma goodFooNarrow_decOpt_correct n foo :
  goodFooNarrow_decOpt n foo = @decOpt (goodFooNarrow n foo) _.

Derive ArbitrarySizedSuchThat for (fun foo => goodFooNarrow n foo).

Definition genGoodNarrow (n : nat) : nat -> G (option (Foo)) :=
 let
   fix aux_arb size (n : nat) : G (option (Foo)) :=
     match size with
     | O => backtrack [(1, ret (Some Foo1))]
     | S size' =>
         backtrack [ (1, ret (Some Foo1))
                   ; (1, bindGenOpt (aux_arb size' 0) (fun foo =>
                         match @decOpt (goodFooNarrow 1 foo) _  42 with
                         | Some true => ret (Some foo)
                         | _ => ret None
                         end
                     ))]
     end in fun sz => aux_arb sz n.

Lemma genGoodNarrow_equality n : 
  genGoodNarrow n = @arbitrarySizeST _ (fun foo => goodFooNarrow n foo) _. 

Set Warnings "+quickchick-uninstantiated-variables".
Fail Derive ArbitrarySizedSuchThat for (fun foo => goodFooFalse foo).
Set Warnings "quickchick-uninstantiated-variables".

Definition addFoo2 (x : Foo) := Foo2 x.

Fixpoint foo_depth f := 
  match f with
  | Foo1 => 0
  | Foo2 f => 1 + foo_depth f
  | Foo3 n f => 1 + foo_depth f
  end.

Derive ArbitrarySizedSuchThat for (fun n => goodFooPrec n x).

Inductive goodFun : Foo -> Prop :=
| GoodFun : forall (n : nat) (a : Foo), goodFooPrec n (addFoo2 a) ->
                                        goodFun a.

Derive ArbitrarySizedSuchThat for (fun a => goodFun a).

Definition success := "success".
Print success. *)



Existing Instance GenSizedFoo.

Existing Instance ShrinkFoo.

Derive Sized for Foo.

Derive SizeMonotonic for Foo using GenSizedFoo.

Derive SizedMonotonic for Foo using GenSizedFoo.

Derive CanonicalSized for Foo.

Derive SizedCorrect for Foo using GenSizedFoo and SizeMonotonicFoo.



Inductive tree : Type :=

| Leaf : tree

| Node : nat -> tree -> tree -> tree.



Inductive goodTree : nat -> tree -> Prop :=

| GL : goodTree 0 Leaf

| GN : forall k t1 t2 n m, goodTree n t1 ->

                      goodTree m t2 ->

                      goodTree m t1 ->

                      goodTree (S n) (Node k t1 t2).



Instance DecgoodTree (n : nat) (t : tree) : Dec (goodTree n t).

Admitted.



Instance DecTreeEq (t1 t2 : tree) : Dec (t1 = t2).

dec_eq. Defined.



Existing Instance GenOfGenSized.

Existing Instance genNatSized.



Derive ArbitrarySizedSuchThat for (fun foo => goodTree n foo).



QuickChickDebug Debug On.



Derive SizedProofEqs for (fun foo => goodTree n foo).



Derive SizeMonotonicSuchThatOpt for (fun foo => goodTree n foo).



Derive GenSizedSuchThatCorrect for (fun foo => goodTree n foo).



Derive GenSizedSuchThatSizeMonotonicOpt for (fun foo => goodTree n foo).



Definition genSTgooTree (n : nat) := @arbitraryST _ (fun foo => goodTree n foo) _.



Existing Instance GenSizedSuchThatgoodFooUnif. 



Derive SizeMonotonicSuchThatOpt for (fun (x : Foo) => goodFooUnif input x).



Derive SizedProofEqs for (fun foo => goodFooUnif n foo).



Derive GenSizedSuchThatCorrect for (fun foo => goodFooUnif n foo).



Derive GenSizedSuchThatSizeMonotonicOpt for (fun foo => goodFooUnif n foo).



Definition genSTgoodFooUnif (n : nat) := @arbitraryST _  (fun foo => goodFooUnif n foo) _.



Definition genSTgoodFooUnifSound (n : nat) := @STCorrect _ _ (@arbitraryST _  (fun foo => goodFooUnif n foo) _) _.



Existing Instance GenSizedSuchThatgoodFooNarrow.  



Derive SizeMonotonicSuchThatOpt for (fun foo => goodFooNarrow n foo).



Derive SizedProofEqs for (fun foo => goodFooNarrow n foo).



Derive GenSizedSuchThatCorrect for (fun foo => goodFooNarrow n foo).



Derive GenSizedSuchThatSizeMonotonicOpt for (fun foo => goodFooNarrow n foo).



Definition genSTgoodFooNarrow (n : nat) := @arbitraryST _  (fun foo => goodFooNarrow n foo) _.



Definition genSTgoodFooNarrowSound (n : nat) := @STCorrect _ _ (@arbitraryST _  (fun foo => goodFooNarrow n foo) _) _.



Existing Instance GenSizedSuchThatgoodFooCombo.



Derive SizeMonotonicSuchThatOpt for (fun foo => goodFooCombo n foo).



Derive SizedProofEqs for (fun foo => goodFooCombo n foo).



Derive GenSizedSuchThatCorrect for (fun foo => goodFooCombo n foo).



Derive GenSizedSuchThatSizeMonotonicOpt for (fun foo => goodFooCombo n foo).



Definition genSTgoodFooCombo (n : nat) := @arbitraryST _  (fun foo => goodFooCombo n foo) _.



Definition genSTgoodFooComboSound (n : nat) := @STCorrect _ _ (@arbitraryST _  (fun foo => goodFooCombo n foo) _) _.



Existing Instance GenSizedSuchThatgoodFoo.



Derive SizeMonotonicSuchThatOpt for (fun (x : Foo) => goodFoo input x).



Derive SizedProofEqs for (fun (x : Foo) => goodFoo input x).



Derive GenSizedSuchThatCorrect for (fun foo => goodFoo n foo).



Derive GenSizedSuchThatSizeMonotonicOpt for (fun foo => goodFoo n foo).



Definition genSTgoodFoo (n : nat) := @arbitraryST _  (fun foo => goodFoo n foo) _.



Definition genSTgoodFooSound (n : nat) := @STCorrect _ _ (@arbitraryST _  (fun foo => goodFoo n foo) _) _.



Existing Instance GenSizedSuchThatgoodFooPrec.  



Derive SizeMonotonicSuchThatOpt for (fun (x : Foo) => goodFooPrec input x).



Derive SizedProofEqs for (fun (x : Foo) => goodFooPrec input x).



Derive GenSizedSuchThatCorrect for (fun foo => goodFooPrec n foo).



Derive GenSizedSuchThatSizeMonotonicOpt for (fun foo => goodFooPrec n foo).



Definition genSTgoodFooPrec (n : nat) := @arbitraryST _  (fun foo => goodFooPrec n foo) _.



Definition genSTgoodFooPrecSound (n : nat) := @STCorrect _ _ (@arbitraryST _  (fun foo => goodFooPrec n foo) _) _.



Existing Instance GenSizedSuchThatgoodFooMatch.  



Derive SizeMonotonicSuchThatOpt for (fun foo => goodFooMatch n foo).



Derive SizedProofEqs for (fun foo => goodFooMatch n foo).



Derive GenSizedSuchThatCorrect for (fun foo => goodFooMatch n foo).



Derive GenSizedSuchThatSizeMonotonicOpt for (fun foo => goodFooMatch n foo).



Definition genSTgoodFooMatch (n : nat) := @arbitraryST _  (fun foo => goodFooMatch n foo) _.



Definition genSTgoodFooMatchSound (n : nat) := @STCorrect _ _ (@arbitraryST _  (fun foo => goodFooMatch n foo) _) _.



Existing Instance GenSizedSuchThatgoodFooRec.  



Derive SizeMonotonicSuchThatOpt for (fun (x : Foo) => goodFooRec input x).



Derive SizedProofEqs for (fun (x : Foo) => goodFooRec input x).



Derive GenSizedSuchThatCorrect for (fun foo => goodFooRec n foo).



Derive GenSizedSuchThatSizeMonotonicOpt for (fun foo => goodFooRec n foo).



Definition genSTgoodFooRec (n : nat) := @arbitraryST _  (fun foo => goodFooRec n foo) _.



Definition genSTgoodFooRecSound (n : nat) := @STCorrect _ _ (@arbitraryST _  (fun foo => goodFooRec n foo) _) _.



Inductive goodFooB : nat -> Foo -> Prop :=

| GF1 : goodFooB 2 (Foo2 Foo1)

| GF2 : goodFooB 3 (Foo2 (Foo2 Foo1)).



Derive ArbitrarySizedSuchThat for (fun (x : Foo) => goodFooB input x).



Derive SizedProofEqs for (fun (x : Foo) => goodFooB input x).



Derive SizeMonotonicSuchThatOpt for (fun foo => goodFooB n foo).



Derive GenSizedSuchThatCorrect for (fun foo => goodFooB n foo).



Derive GenSizedSuchThatSizeMonotonicOpt for  (fun foo => goodFooB n foo).



Definition genSTgoodFooB (n : nat) := @arbitraryST _  (fun foo => goodFooB n foo) _.



Definition genSTgoodFooBSound (n : nat) := @STCorrect _ _ (@arbitraryST _  (fun foo => goodFooB n foo) _) _.



Inductive LRTree : tree -> Prop :=

| PLeaf : LRTree Leaf

| PNode :

    forall m t1 t2,

      ~ t1 = Node 2 Leaf Leaf ->

      ~ Node 4 Leaf Leaf = t1 ->

      LRTree t1 ->

      LRTree t2 ->

      LRTree (Node m t1 t2).



Derive ArbitrarySizedSuchThat for (fun (x : tree) => LRTree x).



Instance DecidableLRTree t : Dec (LRTree t).

Proof.

Admitted.



Derive SizedProofEqs for (fun (x : tree) => LRTree x).



Derive SizeMonotonicSuchThatOpt for (fun foo => LRTree foo).



Derive GenSizedSuchThatCorrect for (fun foo => LRTree foo).



Derive GenSizedSuchThatSizeMonotonicOpt for (fun foo => LRTree foo).



Definition genSTLRTree (n : nat) := @arbitraryST _  (fun foo => LRTree foo) _.



Definition genSTLRTreeSound (n : nat) := @STCorrect _ _ (@arbitraryST _  (fun foo => LRTree foo) _) _.



Inductive HeightTree : nat -> tree -> Prop :=

| HLeaf : forall n, HeightTree n Leaf

| HNode :

    forall t1 t2 n m,

      HeightTree n t1 ->

      HeightTree n t2 ->

      HeightTree (S n) (Node m t1 t2).



Instance ArbitrarySuchThatEql {A} (x : A) : GenSuchThat A (fun y => eq x y) :=

  {| arbitraryST := returnGen (Some x) |}.



Definition success := "Proofs work!".

Print success.
