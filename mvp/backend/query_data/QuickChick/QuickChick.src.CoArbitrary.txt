Require Import PArith List ChoiceFacts Omega.

Require Import mathcomp.ssreflect.ssreflect.

From mathcomp Require Import ssrfun ssrbool.



Require Import Classes RandomQC GenLow Sets.
(* RandomQC:
Set Warnings "-extraction-opaque-accessed,-extraction".
Set Warnings "-notation-overridden,-parsing".

Require Import mathcomp.ssreflect.ssreflect.
From mathcomp Require Import ssrfun ssrbool ssrnat eqtype.
Require Import ZArith.

Axiom RandomSeed : Type.
Axiom randomSeed_inhabited : inhabited RandomSeed.

Axiom randomNext     : RandomSeed -> Z * RandomSeed.
Axiom randomGenRange : RandomSeed -> Z * Z.
Axiom mkRandomSeed   : Z          -> RandomSeed.
Axiom newRandomSeed  : RandomSeed.

Axiom randomSplit : RandomSeed -> RandomSeed * RandomSeed.
Axiom randomSplitAssumption :
  forall s1 s2 : RandomSeed, exists s, randomSplit s = (s1,s2).

CoInductive RandomSeedTree :=
| RstNode : RandomSeed -> RandomSeedTree -> RandomSeedTree -> RandomSeedTree.

Definition root_rst (rst : RandomSeedTree) : RandomSeed :=
  match rst with
  | RstNode root _ _ => root
  end.

Definition left_rst (rst : RandomSeedTree) : RandomSeedTree :=
  match rst with
  | RstNode _ t1 _ => t1
  end.

Definition right_rst (rst : RandomSeedTree) : RandomSeedTree :=
  match rst with
  | RstNode _ _ t2 => t2
  end.

Lemma rst_eta : forall rst : RandomSeedTree,
  rst = RstNode (root_rst rst) (left_rst rst) (right_rst rst).

CoFixpoint mkSeedTree (s : RandomSeed) : RandomSeedTree :=
  let (s1, s2) := randomSplit s in
  RstNode s (mkSeedTree s1) (mkSeedTree s2).

Lemma mkSeedTreeHelper r :
  mkSeedTree r = RstNode r (mkSeedTree (randomSplit r).1) (mkSeedTree (randomSplit r).2).

Inductive SplitDirection := Left | Right.

Definition SplitPath := list SplitDirection.

Require Import List. Import ListNotations.
Fixpoint varySeedAux (p : SplitPath) (rst : RandomSeedTree) : RandomSeed :=
  let '(RstNode s t1 t2) := rst in
  match p with
    | [] => s
    | Left  :: p' => varySeedAux p' t1
    | Right :: p' => varySeedAux p' t2
  end.

Definition varySeed (p : SplitPath) (s : RandomSeed) : RandomSeed :=
  varySeedAux p (mkSeedTree s).

Inductive SeedTree :=
| SeedTreeUndef : SeedTree
| SeedTreeLeaf : RandomSeed -> SeedTree
| SeedTreeNode : SeedTree -> SeedTree -> SeedTree.

Inductive SubSeedTree : SeedTree -> RandomSeedTree -> Prop :=
| SubUndef : forall (rst : RandomSeedTree), SubSeedTree SeedTreeUndef rst
| SubLeaf  : forall (s : RandomSeed) (rst1 rst2 : RandomSeedTree),
               SubSeedTree (SeedTreeLeaf s) (RstNode s rst1 rst2)
| SubNode  : forall (st1 st2 : SeedTree) (rst1 rst2 : RandomSeedTree) (s : RandomSeed),
               SubSeedTree st1 rst1 ->
               SubSeedTree st2 rst2 ->
               SubSeedTree (SeedTreeNode st1 st2) (RstNode s rst1 rst2).

Fixpoint varySeed' (st : SeedTree) (p : SplitPath) : option RandomSeed :=
  match st with
    | SeedTreeUndef => None
    | SeedTreeLeaf s =>
      match p with
        | [] => Some s
        | _  => None
      end
    | SeedTreeNode st1 st2 =>
      match p with
        | [] => None
        | Left  :: p' => varySeed' st1 p'
        | Right :: p' => varySeed' st2 p'
      end
  end.

Lemma pathAgreesOnSubTree : forall (st : SeedTree) (rst : RandomSeedTree) (p : SplitPath)
                                   (s : RandomSeed),
                              SubSeedTree st rst ->
                              varySeed' st p = Some s ->
                              varySeedAux p rst = s.

Lemma splitExpand st : exists s, SubSeedTree st (mkSeedTree s).

Inductive PrefixFree : list SplitPath -> Prop :=
| FreeNil : PrefixFree []
| FreeCons : forall (p : SplitPath) (l : list SplitPath),
               PrefixFree l ->
               (forall (p' : SplitPath), In p' l ->
                                        (forall p1 p2, p' ++ p1 = p ++ p2-> False)) ->
                                        PrefixFree (p :: l).

Lemma prefixFreeSingleton : forall p, PrefixFree [p].

Lemma prefixFreeEmpty : forall l, PrefixFree ([] :: l) -> l = [].

Inductive correspondingSeedTree (l : list SplitPath) (f : SplitPath -> RandomSeed)
          (st : SeedTree) : Prop :=
| Corresponding : (forall (p : SplitPath) s, varySeed' st p = Some s -> In p l) ->
                  (forall (p : SplitPath), In p l -> varySeed' st p = Some (f p)) ->
                  PrefixFree l ->
                  correspondingSeedTree l f st.

Lemma corrEmptyUndef : forall f, correspondingSeedTree [] f SeedTreeUndef.

Ltac fireInLeft name :=
  match goal with
    | [H : In ?X (?X :: ?XS) -> _ |- _ ] =>
      assert (In X (X :: XS)) as name by (left; auto); apply H in name; clear H
  end.

Lemma corrUndefEmpty : forall l f, correspondingSeedTree l f SeedTreeUndef -> l = [].

Lemma PrefixFreeWithNil : forall l, PrefixFree ([] :: l) -> l = [].

Lemma corrEmptyLeaf : forall s l f, correspondingSeedTree l f (SeedTreeLeaf s) ->
                                    l = [[]] /\ s = f [].

Lemma corrNodeNonEmpty : forall st1 st2 l p f,
                           correspondingSeedTree l f (SeedTreeNode st1 st2) ->
                           In p l -> p <> [].

Hint Resolve corrEmptyUndef.
Hint Resolve corrNodeNonEmpty.
Definition Direction_eq_dec : forall (d1 d2 : SplitDirection),
                                {d1 = d2} + {d1 <> d2}.

Definition eq_dir_b (d1 d2 : SplitDirection) : bool :=
  match d1,d2 with
    | Left, Left => true
    | Right, Right => true
    | _, _ => false
  end.

Lemma eq_dir_b_eq : forall d1 d2, eq_dir_b d1 d2 = true <-> d1 = d2.

Definition refineList (d : SplitDirection) (l : list SplitPath) : list SplitPath :=
  map (@tl SplitDirection) (filter (fun p => match hd_error p with
                             | Some d' => eq_dir_b d d'
                             | _       => false
                           end) l).

Lemma refineCorrect : forall d l p, In p (refineList d l) -> In (d :: p) l.

Lemma refineCorrect' : forall d l p, In (d :: p) l -> In p (refineList d l).

Lemma refinePreservesPrefixFree : forall d l, PrefixFree l -> PrefixFree (refineList d l).

Definition refineFunction (f : SplitPath -> RandomSeed) (d : SplitDirection) (arg : SplitPath) :
RandomSeed :=
  f (d :: arg).

Lemma refineFunCorrect : forall f d p, f (d :: p) = (refineFunction f d) p.

Hint Rewrite refineFunCorrect.
Hint Unfold refineFunction.
Program Fixpoint addToTree (st : SeedTree) (p : SplitPath) (f : SplitPath -> RandomSeed)
        (l : list SplitPath)
        (Corr : correspondingSeedTree l f st)
        (Pref : forall p', In p' l -> (forall p1 p2, p ++ p1 = p' ++ p2 -> False))
: SeedTree :=
  match st with
    | SeedTreeUndef =>
      match p with
        | [] => SeedTreeLeaf (f p)
        | Left  :: p' => SeedTreeNode (addToTree SeedTreeUndef p' (refineFunction f Left) [] _ _) SeedTreeUndef
        | Right :: p' => SeedTreeNode SeedTreeUndef (addToTree SeedTreeUndef p' (refineFunction f Right) [] _ _)
      end
    | SeedTreeLeaf s => _  
    | SeedTreeNode st1 st2 =>
      match p with
        | [] => SeedTreeLeaf (f p)
        | Left  :: p' => SeedTreeNode (addToTree st1 p' (refineFunction f Left) (refineList Left l) _ _) st2
        | Right :: p' => SeedTreeNode st1 (addToTree st2 p' (refineFunction f Right) (refineList Right l) _ _)
      end
  end.

Lemma addToTreeCorrect1 : forall (st : SeedTree) (p : SplitPath)
  (f : SplitPath -> RandomSeed)
  (l : list SplitPath) (Corr : correspondingSeedTree l f st)
  (Pref : forall p', In p' l -> (forall p1 p2, p ++ p1 = p' ++ p2 -> False)),
  varySeed' (addToTree st p f l Corr Pref) p = Some (f p).

Lemma addToTreeCorrect2 : forall (st : SeedTree) (p : SplitPath)
  (f : SplitPath -> RandomSeed)
  (l : list SplitPath) (Corr : correspondingSeedTree l f st)
  (Pref : forall p', In p' l -> (forall p1 p2, p ++ p1 = p' ++ p2 -> False)),
  forall p' seed, varySeed' st p' = Some seed ->
             varySeed' (addToTree st p f l Corr Pref) p' = Some seed.

Lemma addToTreeCorrect3 : forall (st : SeedTree) (p : SplitPath)
  (f : SplitPath -> RandomSeed)
  (l : list SplitPath) (Corr : correspondingSeedTree l f st)
  (Pref : forall p', In p' l -> (forall p1 p2, p ++ p1 = p' ++ p2 -> False)),
  forall p' seed, varySeed' (addToTree st p f l Corr Pref) p' = Some seed ->
             p = p' \/ varySeed' st p' = Some seed.

Lemma addToTreeCorrect : forall (st : SeedTree) (p : SplitPath)
  (f : SplitPath -> RandomSeed)
  (l : list SplitPath) (Corr : correspondingSeedTree l f st)
  (Pref : forall p', In p' l -> (forall p1 p2, p ++ p1 = p' ++ p2 -> False)),
  correspondingSeedTree (p :: l) f (addToTree st p f l Corr Pref).

Lemma PrefixFreeTail : forall a l, PrefixFree (a :: l) -> PrefixFree l.

Fixpoint listToTree (l : list SplitPath) (f : SplitPath -> RandomSeed)
        ( Pref : PrefixFree l) : {s : SeedTree | correspondingSeedTree l f s}.

Theorem SplitPathCompleteness (l : list SplitPath) (f : SplitPath -> RandomSeed) :
  PrefixFree l -> exists (s : RandomSeed), forall p, In p l -> varySeed p s = f p.

Axiom randomRBool : bool * bool -> RandomSeed -> bool * RandomSeed.
Axiom randomRBoolCorrect :
  forall b b1 b2, implb b1 b2 ->
    (implb b1 b && implb b b2 <->
    exists seed, (fst (randomRBool (b1, b2) seed)) = b).
Axiom randomRNat  : nat  * nat -> RandomSeed -> nat * RandomSeed.
Axiom randomRNatCorrect:
  forall n n1 n2, n1 <= n2 ->
    (n1 <= n <= n2 <->
    exists seed, (fst (randomRNat (n1, n2) seed)) = n).
Axiom randomRInt  : Z * Z    -> RandomSeed -> Z * RandomSeed.
Axiom randomRIntCorrect:
  forall z z1 z2, Z.leb z1 z2 ->
    (Z.leb z1 z && Z.leb z z2 <->
    exists seed, (fst (randomRInt (z1, z2) seed)) = z).
Axiom randomRN    : N * N    -> RandomSeed -> N * RandomSeed.
Axiom randomRNCorrect:
  forall n n1 n2,
    N.leb n1 n2 ->
    N.leb n1 n && N.leb n n2 <->
    exists seed, fst (randomRN (n1, n2) seed) = n.

Module InfiniteTrees.
  CoInductive RandomSeed : Type :=
  | Node : bool -> RandomSeed -> RandomSeed -> RandomSeed.

  Definition randomSplit (s : RandomSeed) :=
    match s with
    | Node b s1 s2 => (s1,s2)
    end.

  Lemma randomSplitAssumption :
    forall s1 s2 : RandomSeed, exists s, randomSplit s = (s1,s2).

Class ChoosableFromInterval (A : Type)  :=
  {
    super :> OrdType A;
    randomR : A * A -> RandomSeed -> A * RandomSeed;
    randomRCorrect :
      forall (a a1 a2 : A), leq a1 a2 ->
      (leq a1 a && leq a a2 <->
       exists seed, fst (randomR (a1, a2) seed) = a)
  }.

Program Instance ChooseBool : ChoosableFromInterval bool :=
  {
    randomR := randomRBool;
    randomRCorrect := randomRBoolCorrect
  }.

Instance ChooseNat : ChoosableFromInterval nat :=
  {
    randomR := randomRNat;
    randomRCorrect := randomRNatCorrect
  }.

Instance ChooseZ : ChoosableFromInterval Z :=
  {
    randomR := randomRInt;
    randomRCorrect := randomRIntCorrect
  }.

Instance ChooseN : ChoosableFromInterval N :=
  {
    randomR := randomRN;
    randomRCorrect := randomRNCorrect
  }. *)
(* GenLow:
Set Warnings "-extraction-opaque-accessed,-extraction".
Set Warnings "-notation-overridden,-parsing".

Require Import ZArith List.
Require Import mathcomp.ssreflect.ssreflect.
From mathcomp Require Import ssrfun ssrbool ssrnat.
Require Import Numbers.BinNums.
Require Import Classes.RelationClasses.

From ExtLib.Structures Require Export
     Monads.
From ExtLib.Structures Require Import
     Functor Applicative.
Import MonadNotation.
Open Scope monad_scope.

From QuickChick Require Import
     GenLowInterface RandomQC RoseTrees Sets Tactics.

Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Set Bullet Behavior "Strict Subproofs".

Import ListNotations.

Open Scope fun_scope.
Open Scope set_scope.

Module GenLow : GenLowInterface.Sig.

  Inductive GenType (A:Type) : Type := MkGen : (nat -> RandomSeed -> A) -> GenType A.
  
  Definition G := GenType.

  Definition run {A : Type} (g : G A) := match g with MkGen f => f end.
  
  Definition returnGen {A : Type} (x : A) : G A :=
    MkGen (fun _ _ => x).

  Definition bindGen {A B : Type} (g : G A) (k : A -> G B) : G B :=
    MkGen (fun n r =>
             let (r1,r2) := randomSplit r in
             run (k (run g n r1)) n r2).
  
  Definition fmap {A B : Type} (f : A -> B) (g : G A) : G B :=
    MkGen (fun n r => f (run g n r)).

  Definition apGen {A B} (gf : G (A -> B)) (gg : G A) : G B :=
    bindGen gf (fun f => fmap f gg).

  Definition sized {A : Type} (f : nat -> G A) : G A :=
    MkGen (fun n r => run (f n) n r).

  Definition resize {A : Type} (n : nat) (g : G A) : G A :=
    match g with
    | MkGen m => MkGen (fun _ => m n)
    end.

  Definition promote {A : Type} (m : Rose (G A)) : G (Rose A) :=
    MkGen (fun n r => fmapRose (fun g => run g n r) m).

  Fixpoint rnds (s : RandomSeed) (n' : nat) : list RandomSeed :=
    match n' with
      | O => nil
      | S n'' =>
        let (s1, s2) := randomSplit s in
        cons s1 (rnds s2 n'')
    end.
  
  Fixpoint createRange (n : nat) (acc : list nat) : list nat :=
    match n with
      | O => List.rev (cons O acc)
      | S n' => createRange n' (cons n acc)
    end.

  Definition choose {A : Type} `{ChoosableFromInterval A} (range : A * A) : G A :=
    MkGen (fun _ r => fst (randomR range r)).

  Definition sample (A : Type) (g : G A) : list A :=
    match g with
      | MkGen m =>
        let rnd := newRandomSeed in
        let l := List.combine (rnds rnd 20) (createRange 10 nil) in
        List.map (fun (p : RandomSeed * nat) => let (r,n) := p in m n r) l
    end.
  
  Definition variant {A : Type} (p : SplitPath) (g : G A) : G A := 
    match g with 
      | MkGen f => MkGen (fun n r => f n (varySeed p r))
    end.
  
  Definition reallyUnsafeDelay {A : Type} : G (G A -> A) :=
    MkGen (fun r n g => (match g with MkGen f => f r n end)).
  
  Definition reallyUnsafePromote {r A : Type} (m : r -> G A) : G (r -> A) :=
    (bindGen reallyUnsafeDelay (fun eval => 
                                  returnGen (fun r => eval (m r)))).

  Definition semGenSize {A : Type} (g : G A) (s : nat) : set A := codom (run g s).
  Definition semGen {A : Type} (g : G A) : set A := \bigcup_s semGenSize g s.

  Definition semGenSizeOpt {A : Type} (g : G (option A)) (s : nat) : set A :=
    somes (semGenSize g s).

  Definition semGenOpt {A : Type} (g : G (option A)) : set A :=
    somes (semGen g).
  
  Lemma semGenOpt_equiv {A} (g : G (option A)) :
    semGenOpt g <--> \bigcup_s semGenSizeOpt g s.

  Lemma bindGen_aux {A : Type} (g : G A) (n : nat) (r : RandomSeed) : semGen g (run g n r).

  Definition bindGen' {A B : Type} (g : G A) (k : forall (a : A), (a \in semGen g) -> G B) : G B :=
    MkGen (fun n r =>
             let (r1,r2) := randomSplit r in
             run (k (run g n r1) (bindGen_aux g n r1)) n r2).

  Class Unsized {A} (g : G A) :=
    unsized : forall s1 s2, semGenSize g s1 <--> semGenSize g s2.
  
  Class SizedMonotonic {A} (g : nat -> G A) :=
    
    sizeMonotonic : forall s s1 s2,
      s1 <= s2 ->
      semGenSize (g s1) s \subset semGenSize (g s2) s.

  Class SizedMonotonicOpt {A} (g : nat -> G (option A)) :=
    sizeMonotonicOpt : forall s s1 s2,
      s1 <= s2 ->
      semGenSizeOpt (g s1) s \subset semGenSizeOpt (g s2) s.
  
  Class SizeMonotonic {A} (g : G A) :=
    monotonic : forall s1 s2,
      s1 <= s2 -> semGenSize g s1 \subset semGenSize g s2.

  Class SizeMonotonicOpt {A} (g : G (option A)) :=
    monotonicOpt : forall s1 s2,
      s1 <= s2 ->
      semGenSizeOpt g s1 \subset semGenSizeOpt g s2.

  Class SizeAntiMonotonicNone {A} (g : G (option A)) :=
    monotonicNone : forall s1 s2,
      s1 <= s2 ->
      isNone :&: semGenSize g s2 \subset isNone :&: semGenSize g s1.

  Lemma unsizedMonotonic {A} (g : G A) : Unsized g -> SizeMonotonic g. 
  
  Lemma unsized_alt_def :
    forall A (g : G A) `{Unsized _ g},
    forall s, semGenSize g s <--> semGen g.

  Lemma semReturn {A} (x : A) : semGen (returnGen x) <--> [set x].
  
  Lemma semReturnSize A (x : A) (s : nat) :
  semGenSize (returnGen x) s <--> [set x].
  
  Lemma semBindSize A B (g : G A) (f : A -> G B) (s : nat) :
    semGenSize (bindGen g f) s <-->
    \bigcup_(a in semGenSize g s) semGenSize (f a) s.
  
  Lemma semBindSize_subset_compat {A B : Type} (g g' : G A) (f f' : A -> G B) :
    (forall s, semGenSize g s \subset semGenSize g' s) ->
    (forall x s, semGenSize (f x) s \subset semGenSize (f' x) s) ->
    (forall s, semGenSize (bindGen g f) s \subset semGenSize (bindGen g' f') s).
  
  Lemma semBindSizeOpt_subset_compat {A B : Type} (g g' : G A) (f f' : A -> G (option B)) :
    (forall s, semGenSize g s \subset semGenSize g' s) ->
    (forall x s, isSome :&: semGenSize (f x) s \subset isSome :&: semGenSize (f' x) s) ->
    (forall s, isSome :&: semGenSize (bindGen g f) s \subset isSome :&: semGenSize (bindGen g' f') s).
  
  Lemma monad_leftid A B (a : A) (f : A -> G B) :
    semGen (bindGen (returnGen a) f) <--> semGen (f a).
  
  Lemma monad_rightid A (g : G A) : semGen (bindGen g returnGen) <--> semGen g.
  
  Lemma monad_assoc A B C (ga : G A) (fb : A -> G B) (fc : B -> G C) :
    semGen (bindGen (bindGen ga fb) fc) <--> 
    semGen (bindGen ga (fun a => bindGen (fb a) fc)).
  
  Lemma semBindUnsized1 {A B} (g : G A) (f : A -> G B) `{H : Unsized _ g}:
    semGen (bindGen g f) <--> \bigcup_(a in semGen g) semGen (f a).
  
  Lemma semBindUnsized2 :
    forall A B (g : G A) (f : A -> G B),
      (forall a, Unsized (f a)) ->
      semGen (bindGen g f) <--> \bigcup_(a in semGen g) semGen (f a).

  Lemma semBindSizeMonotonic {A B} (g : G A) (f : A -> G B)
        `{Hg : SizeMonotonic _ g} `{Hf : forall a, SizeMonotonic (f a)} :
    semGen (bindGen g f) <--> \bigcup_(a in semGen g) semGen (f a).
  
  Lemma semBindSizeMonotonicIncl_r {A B} (g : G A) (f : A -> G (option B)) (s1 : set A) (s2 : A -> set B) :
    semGen g \subset s1 ->
    (forall x, semGen (f x) \subset Some @: (s2 x) :|: [set None]) -> 
    semGen (bindGen g f) \subset Some @: (\bigcup_(a in s1) s2 a)  :|: [set None].

  Lemma semBindSizeMonotonicIncl_l {A B} (g : G A) (f : A -> G (option B)) (s1 : set A)
        (fs : A -> set B) 
        `{Hg : SizeMonotonic _ g}
        `{Hf : forall a, SizeMonotonicOpt (f a)} :
    s1 \subset semGen g ->
    (forall x, Some @: (fs x) \subset semGen (f x)) ->
    (Some @: \bigcup_(a in s1) (fs a)) \subset semGen (bindGen g f).

  Lemma semFmapSize A B (f : A -> B) (g : G A) (size : nat) :
    semGenSize (fmap f g) size <--> f @: semGenSize g size.  Proof.
  
  Lemma semFmap A B (f : A -> B) (g : G A) :
    semGen (fmap f g) <--> f @: semGen g.

  Lemma semChooseSize A `{ChoosableFromInterval A} (a1 a2 : A) :
    RandomQC.leq a1 a2 ->
  
  Lemma semChoose A `{RandomQC.ChoosableFromInterval A} (a1 a2 : A) :

  Lemma promoteVariant :
    forall {A B : Type} (a : A) (f : A -> SplitPath) (g : G B) size
      (r r1 r2 : RandomSeed),
      randomSplit r = (r1, r2) ->
      run (reallyUnsafePromote (fun a => variant (f a) g)) size r a =
      run g size (varySeed (f a) r1).

  Lemma semPromote A (m : Rose (G A)) :
    semGen (promote m) <-->
    codom2 (fun size seed => fmapRose (fun g => run g size seed) m).

  Lemma semPromoteSize (A : Type) (m : Rose (G A)) n :
    semGenSize (promote m) n <-->
               codom (fun seed => fmapRose (fun g => run g n seed) m).

  Lemma runPromote A (m : Rose (G A)) seed size :
    run (promote m) seed size = fmapRose (fun (g : G A) => run g seed size) m.

  Lemma runFmap (A B : Type) (f : A -> B) (g : G A) seed size :
    run (fmap f g) seed size = f (run g seed size).

  Lemma semFmapBind :
    forall A B C (g : G A) (f1 : B -> C) (f2 : A -> G B),
      semGen (fmap f1 (bindGen g f2)) <-->
      semGen (bindGen g (fun x => fmap f1 (f2 x))).

  Lemma semSized A (f : nat -> G A) :
    semGen (sized f) <--> \bigcup_n semGenSize (f n) n.

  Lemma semSizedSize A(f:nat->G A)s : semGenSize (sized f) s <--> semGenSize (f s) s.

  Lemma semSized_opt A (f : nat -> G (option A)) (H : forall n, SizeMonotonicOpt (f n)) (H' : SizedMonotonicOpt f) :
    isSome :&: semGen (sized f) <--> isSome :&: \bigcup_n (semGen (f n)).

  Lemma semSized_alt A (f : nat -> G A) (H : forall n, SizeMonotonic (f n))
        (H' : forall n m s,  n <= m -> semGenSize (f n) s \subset semGenSize (f m) s) :
    semGen (sized f) <--> \bigcup_n (semGen (f n)).
  
  Lemma semResize A n (g : G A) : semGen (resize n g) <--> semGenSize g n .

  Lemma semSizeResize A (s n : nat) (g : G A) :
    semGenSize (resize n g) s <--> semGenSize g n.

  Lemma semGenSizeInhabited {A} (g : G A) s :
    exists x, semGenSize g s x.

  Instance Functor_G : Functor G := {
    fmap A B := fmap;
  }.

  Instance Applicative_G : Applicative G := {
    pure A := returnGen;
    ap A B := apGen;
  }.

  Instance Monad_G : Monad G := {
    ret A := returnGen;
    bind A B := bindGen;
  }.

  Definition thunkGen {A} (f : unit -> G A) : G A :=
    MkGen (fun n r => run (f tt) n r).

  Lemma semThunkGenSize {A} (f : unit -> G A) s :
    semGenSize (thunkGen f) s <--> semGenSize (f tt) s.

  Lemma semThunkGen {A} (f : unit -> G A) :
    semGen (thunkGen f) <--> semGen (f tt).

End GenLow. *)
(* Sets:
Set Warnings "-extraction-opaque-accessed,-extraction".
Set Warnings "-notation-overridden,-parsing".

Require Import mathcomp.ssreflect.ssreflect.
Require Import Classes.RelationClasses Classes.Morphisms List Tactics.
From mathcomp Require Import ssrfun ssrbool ssrnat seq.

Import ListNotations.

Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Definition set T := T -> Prop.

Notation "x \in A" := (A x) (at level 70, only parsing) : set_scope.

Definition set_eq {A} (m1 m2 : set A) :=
  forall (a : A), m1 a <-> m2 a.

Infix "<-->" := set_eq (at level 70, no associativity) : set_scope.

Open Scope set_scope.

Lemma set_eq_trans T B (A C : set T) : A <--> B -> B <--> C -> A <--> C.

Lemma set_eq_symm {A} (s1 s2 : set A) :
  s1 <--> s2 -> s2 <--> s1.

Lemma set_eq_refl {A} (s : set A) :
  s <--> s.

Global Instance : forall T, Equivalence (@set_eq T).

Definition set_incl {A} (m1 m2 : set A) :=
  forall (a : A), m1 a -> m2 a.

Infix "\subset" := set_incl (at level 70, no associativity) : set_scope.

Notation "[ 'set' x : T | P ]" := (fun x : T => P)
  (at level 0, x at level 99, only parsing) : set_scope.
Notation "[ 'set' x | P ]" := [set x : _ | P]
  (at level 0, x, P at level 99, format "[ 'set'  x  |  P ]", only parsing) : set_scope.

Definition set0 {T} := [set _ : T | False].

Definition setT {T} := [set _ : T | True].

Notation "[ 'set' : T ]" := (@setT T)
  (at level 0, format "[ 'set' :  T ]") : set_scope.

Section setOpsDef.

Context {T U : Type}.
Implicit Types (a x : T) (A B : set T).

Definition set1 a := eq a.

Definition setU A B := [set x | x \in A \/ x \in B].

Definition setI A B := [set x | x \in A /\ x \in B].

Definition codom (f : T -> U) := [set y | exists x, f x = y].

Definition bigcup A (F : T -> set U) := [set x | exists i, i \in A /\ x \in F i].

Definition bigcap (A : set T) (F : T -> set U) :=
  [set x | forall (i : T), i \in A -> x \in F i].

End setOpsDef.

Definition imset {T U} (f : T -> U) A := bigcup A (fun x => set1 (f x)).

Definition setX T U (A : set T) (B : set U) := [set x | x.1 \in A /\ x.2 \in B].

Definition imset2 T U V (f : T -> U -> V) A1 A2 :=
  imset (prod_curry f) (setX A1 A2).

Definition codom2 T U V (f : T -> U -> V) := codom (prod_curry f).

Notation "[ 'set' a ]" := (set1 a)
  (at level 0, a at level 99, format "[ 'set'  a ]") : set_scope.
Notation "[ 'set' a : T ]" := [set (a : T)]
  (at level 0, a at level 99, format "[ 'set'  a   :  T ]") : set_scope.

Notation "A :|: B" := (setU A B) (at level 52, left associativity) : set_scope.
Notation "a |: A" := ([set a] :|: A) (at level 52, left associativity) : set_scope.

Notation "A :&: B" := (setI A B) (at level 48, left associativity) : set_scope.

Notation "f @: A" := (imset f A) (at level 24) : set_scope.

Notation "f @2: ( A , B )" := (imset2 f A B)
  (at level 24, format "f  @2:  ( A ,  B )") : set_scope.

Notation "\bigcup_ i F" := (bigcup setT (fun i => F))
  (at level 41, F at level 41, i at level 0,
           format "'[' \bigcup_ i '/  '  F ']'") : set_scope.
Notation "\bigcup_ ( i : t ) F" := (bigcup (@setT t) (fun i => F))
  (at level 41, F at level 41, i at level 50,
           format "'[' \bigcup_ ( i   :  t ) '/  '  F ']'", only parsing) : set_scope.
Notation "\bigcup_ ( i 'in' A ) F" := (bigcup A (fun i => F))
  (at level 41, F at level 41, i, A at level 50,
           format "'[' \bigcup_ ( i  'in'  A ) '/  '  F ']'") : set_scope.

Notation "\bigcap_ ( i 'in' A ) F" := (bigcap A (fun i => F))
  (at level 41, F at level 41, i, A at level 50,
           format "'[' \bigcap_ ( i  'in'  A ) '/  '  F ']'") : set_scope.

Definition lift {T} (S : set T) : set (option T) :=
  Some @: S :|: [set None].

Lemma subset_eqP T (A B : set T) : (A <--> B) <-> (A \subset B /\ B \subset A).

Lemma subset_trans T (A1 A2 A3 : set T) :
  A1 \subset A2 ->
  A2 \subset A3 ->
  A1 \subset A3.

Lemma subset_refl T (A : set T) : A \subset A.

Lemma subset_singl : 
  forall {T} (x y : T), [set x] \subset [set y] <-> y = x. 

Lemma subset_respects_set_eq_l :
  forall (T : Type) (s1 s2 s3 : set T),
    s1 <--> s3 -> s3 \subset s2 -> s1 \subset s2.

Lemma subset_respects_set_eq_r :
  forall (T : Type) (s1 s2 s3 : set T),
    s3 <--> s2 -> s1 \subset s2 -> s1 \subset s3.

Lemma subset_respects_set_eq :
  forall {T : Type} {s1 s2 s1' s2' : set T},
    s1 <--> s1' ->
    s2 <--> s2' ->
    s1' \subset s2' ->
    s1 \subset s2.

Lemma imsetT T U (f : T -> U) : f @: setT <--> codom f.

Lemma imset_id T (A : set T) : id @: A <--> A.

Lemma imset_incl {T U} (A B : set T) (f : T -> U):
  A \subset B -> 
  f @: A \subset f @: B.

Lemma imset_eq {T U} (A B : set T) (f : T -> U):
  A <--> B -> 
  f @: A <--> f @: B.

Lemma imset_in a b x (f : a -> b) (A : set a) :
  x \in A -> f x \in (f @: A).

Lemma imset_id_ext T (A : set T) f : (forall x, f x = x) -> f @: A <--> A.

Lemma imset_eq_ext a b (f g : a -> b) (A : set a) :
  (forall x, f x = g x) ->
  f @: A <--> g @: A.

Lemma coverE T (A : set T) : \bigcup_(x in A) [set x] <--> A.

Lemma setXT T U : setX [set: T] [set: U] <--> [set: T * U].

Lemma sub0set T (A : set T) : set0 \subset A.

Lemma bigcup_set0 T U (F : T -> set U) :
  \bigcup_(x in set0) F x <--> set0.

Lemma imset0 T U (f : T -> U) : f @: set0 <--> set0.

Lemma bigcup_set1 T U (F : T -> set U) y :
  \bigcup_(x in [set y]) F x <--> F y.

Lemma bigcup_setU_l:
  forall (U T : Type) (s1 s2 : set U) (f : U -> set T),
  \bigcup_(i in (s1 :|: s2)) f i <-->
  \bigcup_(i in s1) f i :|: \bigcup_(i in s2) f i.

Lemma bigcup_const A B (P : set B) : inhabited A -> (\bigcup_(_ : A) P) <--> P.

Lemma bigcup_const_2 A (x :A) B (P : set B) : (\bigcup_(_ in [set x]) P) <--> P.

Lemma bigcupC T U V A B (F : T -> U -> set V) :
  \bigcup_(i in A) \bigcup_(j in B) F i j <-->
  \bigcup_(j in B) \bigcup_(i in A) F i j.

Lemma incl_bigcupr T U A (F : T -> set U) G : (forall x, F x \subset G x) ->
  \bigcup_(x in A) F x \subset \bigcup_(x in A) G x.

Lemma eq_bigcupr T U A (F : T -> set U) G : (forall x, F x <--> G x) ->
  \bigcup_(x in A) F x <--> \bigcup_(x in A) G x.

Lemma incl_bigcupl T U A B (F : T -> set U) : A \subset B ->
  \bigcup_(x in A) F x \subset \bigcup_(x in B) F x.

Lemma eq_bigcupl T U A B (F : T -> set U) : A <--> B ->
  \bigcup_(x in A) F x <--> \bigcup_(x in B) F x.

Lemma incl_bigcup a b (x:a) (A : set a) (f:a->set b) :
  x \in A -> 
  f x \subset \bigcup_(x in A) f x.

Arguments eq_bigcupl [T U A] B F _ _.

Global Instance eq_bigcup T U : Proper (set_eq ==> pointwise_relation T (@set_eq U) ==> set_eq) bigcup.

Lemma bigcup_flatten T U V A (F : T -> set U) (G : U -> set V) :
  \bigcup_(x in \bigcup_(y in A) F y) G x <-->
  \bigcup_(y in A) \bigcup_(x in F y) G x.

Lemma codom_apply {A B : Type} {f : A -> B} {x : A} : f x \in codom f.

Lemma codomE T U (f : T -> U) : codom f <--> \bigcup_x [set f x].

Lemma codom_id T : codom id <--> [set: T].

Lemma codom_const A B (x : B) : inhabited A ->
  codom (fun _ : A => x) <--> [set x].

Lemma imset_comp T U V (f : U -> T) (g : V -> U) A :
  (f \o g) @: A <--> f @: (g @: A).

Lemma codom_comp T U V (f : U -> T) (g : V -> U) :
  codom (f \o g) <--> f @: (codom g).

Lemma curry_imset2l T U V (f : T -> U -> V) A1 A2 :
  f @2: (A1, A2) <--> \bigcup_(x1 in A1) f x1 @: A2.

Lemma curry_imset2r T U V (f : T -> U -> V) A1 A2 :
  f @2: (A1, A2) <--> \bigcup_(x2 in A2) f^~ x2 @: A1.

Lemma curry_codom2l T U V (f : T -> U -> V) :
  codom (prod_curry f) <--> \bigcup_x1 codom (f x1).

Lemma imset_bigcup T U V (f : U -> V) A (F : T -> set U) :
  (f @: \bigcup_(x in A) (F x)) <--> \bigcup_(x in A) f @: F x.

Lemma bigcup_imset T U V (f : T -> U) A (F : U -> set V) :
  \bigcup_(y in f @: A) (F y) <--> \bigcup_(x in A) F (f x).

Lemma bigcup_codom T U V (f : T -> U) (F : U -> set V) :
  \bigcup_(y in codom f) (F y) <--> \bigcup_x F (f x).

Coercion seq_In T : seq T -> set T := fun s x => List.In x s.
Coercion list_In T : list T -> set T := fun s x => List.In x s.

Lemma subnilset T (A : set T) : [::] \subset A.

Lemma subconsset T (A : set T) x s :
  x :: s \subset A <-> x \in A /\ s \subset A.

Lemma reindex_bigcup I J K (h : J -> I) (F : I -> set K) A B :
  h @: B <--> A ->
  \bigcup_(x in A) F x <--> \bigcup_(y in B) F (h y).
Arguments reindex_bigcup [I J K] h [F A] B _ _.

Lemma bigcup_pointwise_incl A B (s : set A) (t : A -> set B) (u : set B) :
  (forall x, x \in s -> t x \subset u) ->
  \bigcup_(x in s) t x \subset u.

Lemma setI_comm {U} (s1 s2 : set U) : 
   s1 :&: s2 <--> s2 :&: s1.

Lemma setU_comm {U} (s1 s2 : set U) : 
   s1 :|: s2 <--> s2 :|: s1.

Lemma setI_set0_abs {U} (s : set U) :
  (s :&: set0) <--> set0.

Lemma setU_set0_neut {U} (s : set U) :
  (s :|: set0) <--> s.

Lemma setU_set0_neut_eq {A} (s s1 : set A) :
  s1 <--> set0 ->
  s <--> s :|: s1.

Lemma setU_set0_l {A} (s1 s2 s3 : set A) :
  s1 <--> set0 ->
  s2 <--> s3 ->
  (s1 :|: s2) <--> s3. 

Lemma setU_set0_r {A} (s1 s2 s3 : set A) :
  s1 <--> set0 ->
  s3 <--> s2 ->
  s3 <--> (s1 :|: s2). 

Lemma setI_setT_neut {U} (s : set U) :
  (s :&: setT) <--> s.

Lemma setU_setT_abs {U} (s : set U) :
  (s :|: setT) <--> setT.

Lemma setU_set_eq_compat {T} (s1 s2 s1' s2' : set T) :
  s1 <--> s1' ->
  s2 <--> s2' ->
  s1 :|: s2 <--> s1' :|: s2'.

Lemma setU_set_subset_compat :
  forall (T : Type) (s1 s2 s1' s2' : set T),
    s1 \subset s1' -> s2 \subset s2' -> s1 :|: s2 \subset s1' :|: s2'.

Lemma setU_set_incl_r :
  forall (T : Type) (s1 s2 s2' : set T),
    s1 \subset s2' -> s1 \subset s2 :|: s2'.

Lemma setU_assoc {U} (s1 s2 s3 : set U) :
  (s1 :|: (s2 :|: s3)) <--> ((s1 :|: s2) :|: s3).

Lemma setI_assoc {U} (s1 s2 s3 : set U) :
  (s1 :&: (s2 :&: s3)) <--> ((s1 :&: s2) :&: s3).

Lemma setI_impl_l {T} (s1 s2 : set T) : s1 \subset s2 -> s1 :&: s2 <--> s1.

Lemma setI_impl_r {T} (s1 s2 : set T) : s2 \subset s1 -> s1 :&: s2 <--> s2.

Lemma setI_set0 {U} (s1 s2 : set U) : 
  (forall x, s1 x -> ~ s2 x) ->
  (s1 :&: s2) <--> set0.

Lemma setI_subset_compat {U} (s1 s2 s1' s2' : set U) : 
  s1 \subset s1' ->
  s2 \subset s2' ->
  (s1 :&: s2) \subset (s1' :&: s2').

Lemma setU_subset_r {U} (s1 s2 s3 : set U) : 
  s1 \subset s3 ->
  s1 \subset (s2 :|: s3).

Lemma setU_subset_l {U} (s1 s2 s3 : set U) : 
  s1 \subset s2 ->
  s1 \subset (s2 :|: s3).

Lemma setI_setU_distr {U} (s1 s2 s3 : set U) : 
  ((s1 :|: s2) :&: s3) <--> ((s1 :&: s3) :|: (s2 :&: s3)).

Lemma bigcap_set0 (T U : Type) (F : T -> set U) :
  \bigcap_(x in set0) F x <--> setT.

Lemma incl_bigcapl T U A B (F : T -> set U) : B \subset A ->
  \bigcap_(x in A) F x \subset \bigcap_(x in B) F x.

Lemma eq_bigcapr (T U : Type) (A : set T) (F G : T -> set U) :
  (forall x : T, F x <--> G x) ->
  \bigcap_(x in A) F x <--> \bigcap_(x in A) G x.

Lemma eq_bigcapl T U A B (F : T -> set U) : A <--> B ->
  \bigcap_(x in A) F x <--> \bigcap_(x in B) F x.

Lemma eq_bigcup' :
  forall (T U : Type) (A B : set T) (F G : T -> set U),
    A <--> B ->
    (forall x, F x <--> G x) ->
    \bigcup_(x in A) F x <--> \bigcup_(x in B) G x.

Lemma incl_bigcup_compat :
  forall (T U : Type) (A B : set T) (F G : T -> set U),
    A \subset B ->
    (forall x : T, F x \subset G x) ->
    \bigcup_(x in A) F x \subset \bigcup_(x in B) G x.

Lemma bigcap_setI_l {U T} (s1 s2 : set U) (f : U -> set T) :
  bigcap (s1 :|: s2) f <-->
  bigcap s1 f :&: bigcap s2 f.

Lemma bigcap_setU_l {U T} (s1 s2 : set U) (f : U -> set T) :
  bigcap s1 f \subset bigcap (s1 :&: s2) f.

Lemma bigcap_set1 {U T} (x : U) (f : U -> set T) :
  bigcap [set x] f <--> f x.

Lemma bigcup_set0_r (T U : Type) (s : set T) (F : T -> set U) :
  (forall x, F x <--> set0) ->
  \bigcup_(x in s) F x <--> set0.

Lemma bigcup_set0_l_eq (T U : Type) (s : set T) (F : T -> set U) :
  s <--> set0 ->
  \bigcup_(x in s) F x <--> set0.

Lemma nil_set_eq {A : Type} :
  [::] <--> (@set0 A).

Lemma cons_set_eq {A} (x : A) l :
  (x :: l) <--> [set x] :|: l.

Lemma singl_set_eq: forall (A : Type) (x : A), [ x ] <--> [ set x ].

Lemma incl_subset {A : Type} (l1 l2 : seq A) :
  incl l1 l2 -> l1 \subset l2.

Lemma incl_hd_same {A : Type} (a : A) (l1 l2 : seq A) :
  incl l1 l2 -> incl (a :: l1) (a :: l2).
     
Lemma setI_bigcup_assoc {A B} (s1 : set B) (s2 : set A) (s3 : A -> set B) :
  s1 :&: (\bigcup_(x in s2) s3 x) <--> \bigcup_(x in s2) (s1 :&: (s3 x)).

Lemma cons_subset {A : Type} (x : A) (l : seq A) (P : set A) :
  P x ->
  l \subset P ->
  (x :: l) \subset P.

Lemma nil_subset {A : Type} (P : set A) :
  [] \subset P.

Lemma imset_union_incl {U T : Type} (s1 s2 : set U) (f : U -> T) :
  f @: (s1 :|: s2) \subset (f @: s1) :|: (f @: s2).

Lemma imset_singl_incl {U T : Type} (x : U) (f : U -> T) :
  f @: [set x] \subset [set (f x)].

Lemma imset_set0_incl  {U T : Type} (f : U -> T) :
  f @: set0 \subset set0.

Lemma set_eq_set_incl_r {U : Type} (s1 s2 : set U) :
  s1 <--> s2 -> s2 \subset s1.

Lemma set_eq_set_incl_l {U : Type} (s1 s2 : set U) :
  s1 <--> s2 -> s1 \subset s2.

Lemma rewrite_set_l {U : Type} (s1 s2 : set U) x :
  s1 x ->
  s1 <--> s2 ->
  s2 x.

Lemma rewrite_set_r {U : Type} (s1 s2 : set U) x :
  s2 x ->
  s1 <--> s2 ->
  s1 x.

Lemma imset_bigcup_incl_l :
  forall {T U V : Type} (f : U -> V) (A : set T) (F : T -> set U),
  f @: (\bigcup_(x in A) F x) \subset \bigcup_(x in A) f @: F x.

Lemma in_imset {U T} (f : U -> T) (S : set U) (x : T) :
  (f @: S) x -> exists y, x = f y.

Lemma union_lift_subset_compat {A} (s1 s2 : set (option A)) (s3 s4 : set A) :
  s1 \subset lift s3 ->
  s2 \subset lift s4 ->
  (s1 :|: s2) \subset lift (s3 :|: s4).

Lemma lift_subset_pres_l {A} (s1 : set (option A)) (s2 s3 : set A) :
  s1 \subset lift s2 ->
  s1 \subset lift (s2 :|: s3).

Lemma lift_subset_pres_r {A} (s1 : set (option A)) (s2 s3 : set A) :
  s1 \subset lift s3 ->
  s1 \subset lift (s2 :|: s3).

Lemma set_incl_setI_l {A} (s1 s2 s3 : set A) :
  s1 \subset s3 ->
  (s1 :&: s2) \subset s3.

Lemma set_incl_setI_r {A} (s1 s2 s3 : set A) :
  s2 \subset s3 ->
  (s1 :&: s2) \subset s3.

Lemma set_incl_setU_l {A} (s1 s2 s3 : set A) :
  s1 \subset s3 ->
  s2 \subset s3 ->
  (s1 :|: s2) \subset s3.

Lemma bigcup_set_I_l {A B} (s1 s2 : set A) (s3 : set B) (f : A -> set B) :
  \bigcup_(x in s1) (f x) \subset s3 ->
  \bigcup_(x in (s1 :&: s2)) (f x) \subset s3.

Lemma bigcup_set_U {A B} (s1 s2 : set A) (s3 : set B) (f : A -> set B) :
  \bigcup_(x in s1) (f x) \subset s3 ->
  \bigcup_(x in s2) (f x) \subset s3 ->
  \bigcup_(x in (s1 :|: s2)) (f x) \subset s3.

Lemma bigcup_set0_subset {A B} (s : set B) (f : A -> set B) :
  \bigcup_(x in set0) (f x) \subset s.

Lemma bigcup_cons_subset {A B} l (ls : seq A) (f : A -> set B) s :
  f l \subset s ->
  \bigcup_(x in ls) (f x) \subset s ->
  \bigcup_(x in l :: ls) (f x) \subset s. 

Lemma bigcup_nil_subset {A B} (f : A -> set B) s :
  \bigcup_(x in []) (f x) \subset s. 

Lemma option_subset {A} (s1 : set (option A)) :
  s1 \subset (isSome :&: s1) :|: [set None]. 

Lemma setU_l_subset {U} (s1 s2 s3 : set U) :
  s1 \subset s3 ->
  s2 \subset s3 ->
  (s1 :|: s2) \subset s3.

Lemma bigcup_lift_lift_bigcup {T U} (s1 : set T) (f : T -> set U) :
  \bigcup_(x in s1) (lift (f x)) \subset lift (\bigcup_(x in s1) (f x)).

Lemma lift_subset_compat {U} (s1 s2 : set U) :
  s1 \subset s2 ->
  lift s1 \subset lift s2.

Lemma lift_set_eq_compat {U} (s1 s2 : set U) :
  s1 <--> s2 ->
  lift s1 <--> lift s2.

Lemma bigcup_setU_r:
  forall (U T : Type) (s : set U) (f g : U -> set T),
    \bigcup_(i in s) (f i :|: g i) <-->
    \bigcup_(i in s) f i :|: \bigcup_(i in s) g i.

Lemma lift_bigcup_comm :
  forall (U T : Type) (s : set U) (f : U -> set T),
    inhabited U ->
    lift (\bigcup_(i in [set : U]) (f i)) <-->
    \bigcup_(i in [set : U]) (lift (f i)).

Lemma bigcap_setU_distr:
  forall (U T : Type) (s1 s2 : set U) (f : U -> set T),
    \bigcap_(i in s1) f i :&: \bigcap_(i in s2) f i <--> \bigcap_(i in s1 :|: s2) f i.

Lemma setI_set_incl :
  forall (A : Type) (s1 s2 s3 : set A),
    s1 \subset s2 ->
    s1 \subset s3 ->
    s1 \subset s2 :&: s3.

Lemma imset_isSome {A} (s : set A) :
  Some @: s \subset isSome.

Lemma bigcup_cons_subset_r :
  forall (A B : Type) (l : A) (ls : seq A) (f : A -> set B) (s1 s2 : set B),
    s1 \subset f l ->
    s2 \subset \bigcup_(x in ls) f x ->
    s1 :|: s2 \subset \bigcup_(x in (l :: ls)) f x.

Lemma bigcup_setI_cons_subset_r :
  forall (A B : Type) (l : A) (ls : seq A) (f : A -> set B) (s1 s2 : set B) (s3 : set A),
    s3 l ->
    s1 \subset f l ->
    s2 \subset \bigcup_(x in ls :&: s3) f x ->
    s1 :|: s2 \subset \bigcup_(x in (l :: ls) :&: s3) f x.

Lemma imset_union_set_eq:
  forall (U T : Type) (s1 s2 : set U) (f : U -> T),
    f @: (s1 :|: s2) <--> f @: s1 :|: f @: s2.

Lemma imset_bigcup_setI_cons_subset_r :
  forall (A B : Type) (l : A) (ls : seq A) (f : A -> set (option B))
    (s1 s2 : set B) (s3 : set A),
    s3 l ->
    Some @: s1 \subset f l ->
    Some @: s2 \subset \bigcup_(x in ls :&: s3) f x ->
    Some @: (s1 :|: s2) \subset \bigcup_(x in (l :: ls) :&: s3) f x.

Lemma imset_set0_subset {A B} (f : A -> B) (s : set B) :
  (f @: set0) \subset s.

Lemma setI_set_eq_r {A : Type} (s1 s2 s2' : set A) :
  s2 <--> s2' ->
  (s1 :&: s2) <--> (s1 :&: s2').

Lemma isSome_subset {A : Type} (s1 s2 s1' s2' : set (option A)) :
  isSome :&: s1 \subset isSome :&: s2 ->
  isSome :&: (s1 :|: ([set None] :&: s1')) \subset isSome :&: (s2 :|: ([set None] :&: s2')).

Lemma bigcup_nil_setI {A B} (f : A -> set B)
      (l : seq A) s :
  \bigcup_(x in [] :&: s) (f x) \subset
  \bigcup_(x in (l :&: s)) (f x).

Lemma isSome_set_eq {A} (s : set (option A)) (s' : set A) :
  s \subset (Some @: s') :|: [set None] ->
  Some @: s' \subset s ->
  isSome :&: s <--> Some @: s'.

Lemma set_eq_isSome_sound {A} (s : set (option A)) (s' : set A) :
  isSome :&: s <--> Some @: s' ->
  s \subset (Some @: s') :|: [set None].

Lemma set_eq_isSome_complete {A} (s : set (option A)) (s' : set A) :
  isSome :&: s <--> Some @: s' ->
  Some @: s' \subset s.

Definition somes {A} (s : set (option A)) : set A :=
  [set x | Some x \in s].

Lemma somes_subset {A} (s1 s2 : set (option A)) :
  s1 \subset s2 ->
  somes s1 \subset somes s2.

Lemma bigcup_somes {A B} (sA : set A) (s : A -> set (option B)) :
  somes (\bigcup_(a in sA) s a) <--> \bigcup_(a in sA) somes (s a).

Lemma bigcup_setI {T U} (s1 : set T) (s2 : set U) F :
  \bigcup_(x in s1) (s2 :&: F x) <--> s2 :&: \bigcup_(x in s1) (F x). *)

Import GenLow.



Import ListNotations.



Set Implicit Arguments.

Unset Strict Implicit.

Unset Printing Implicit Defensive.



Class CoArbitrary (A : Type) : Type :=

  {

    coarbitrary : A -> positive;

    coarbReverse : positive -> option A;

    coarbCorrect : forall a, coarbReverse (coarbitrary a) = Some a

  }.



Instance coArbPos : CoArbitrary positive.

Proof.

refine {|

    coarbitrary x := x;

    coarbReverse x := Some x

  |}.

auto.

Qed.



Lemma nat_lemma :   forall a : nat,

  Some (Init.Nat.pred (Pos.to_nat (Pos.of_nat (S a)))) = Some a.

Admitted.



Instance coqArbNat : CoArbitrary nat.

Proof.

refine {|

    coarbitrary x := Pos.of_nat (S x);

    coarbReverse p := Some (Coq.Init.Peano.pred (Pos.to_nat p))

  |}.

  apply nat_lemma.

Qed.



Local Open Scope positive.

Fixpoint posToPathAux (p : positive) : SplitPath := 

  match p with 

    | xH => []

    | xI p' => posToPathAux p' ++ [Left; Right]

    | xO p' => posToPathAux p' ++ [Left; Left ]

  end.



Definition posToPath (p : positive) : SplitPath := posToPathAux p ++ [Right].



Fixpoint pathToPosAux (p : SplitPath) (f : positive -> positive) 

: option positive :=

match p with 

  | [Right] => Some (f xH)

  | Left :: Right :: p' => pathToPosAux p' (fun p => xI (f p))

  | Left :: Left  :: p' => pathToPosAux p' (fun p => xO (f p))     

  | _ => None

end.



Definition pathToPos p := pathToPosAux p (fun x => x).



Definition list_ind' (A : Type) (P : list A -> Prop) : 

                    P [] -> (forall (a : A), P [a]) -> 

                    (forall (a b : A) (l : list A), P l -> P (a :: b :: l)) ->

                    forall (l : list A), P l :=

  fun H0 H1 H2 => 

    fix aux (l : list A) : P l := 

      match l with 

        | []  => H0

        | [x] => H1 x

        | a :: b :: l' => H2 a b l' (aux l')

      end.



Lemma aux1 : forall l p f, pathToPosAux (l ++ [Right]) f = Some p ->

               exists f', forall l', pathToPosAux (l ++ l') f =

                                    pathToPosAux l' f' /\ f' xH = p.

induction l using list_ind'; intros.

+ simpl in *; inversion H; subst.

  exists f; intros.

  split; auto.

+ simpl in H; destruct a; inversion H.

+ pose proof IHl p; clear IHl.

  destruct a; destruct b; simpl in *.

  -  pose proof (H0 (fun p0 => xO (f p0))); clear H0.

     apply H1 in H; clear H1.

     assumption.

  -  pose proof (H0 (fun p0 => xI (f p0))); clear H0.

     apply H1 in H; clear H1.

     assumption.

  - inversion H.

  - inversion H.

Qed.



Lemma posPathInj : forall p, pathToPos (posToPath p) = Some p.

induction p; unfold posToPath, pathToPos in *; simpl in *.

- apply aux1 in IHp. 

  inversion IHp as [f' Hyp]; clear IHp.

  rewrite <- app_assoc; simpl.

  pose proof Hyp [Left; Right; Right] as H; clear Hyp.

  inversion H as [H0 H1]; clear H.

  rewrite H0; clear H0.

  simpl; subst; auto.

- apply aux1 in IHp. 

  inversion IHp as [f' Hyp]; clear IHp.

  rewrite <- app_assoc; simpl.

  pose proof Hyp [Left; Left; Right] as H; clear Hyp.

  inversion H as [H0 H1]; clear H.

  rewrite H0; clear H0.

  simpl; subst; auto.

- auto.

Qed.



Fixpoint lengthSplit {A : Type} (l l' : list A) : option (list A * list A) :=

  match l, l' with

    | [], x => Some ([], x)

    | _::xs, y::ys => 

      option_map (fun (p : list A * list A) => 

                    let (l1,l2) := p in (y::l1, l2)) (lengthSplit xs ys)

    | _, _ => None

  end.



Lemma lengthSplit1 : forall {A : Type} (l l' : list A), 

                       le (length l) (length l') -> 

                       exists p, lengthSplit l l' = Some p.

induction l as [ | x xs IHxs].

+ intros; exists ([], l'); auto.

+ intros l' LE; destruct l' as [ | b bs] eqn:LEq.

  - inversion LE.

  - pose proof IHxs bs as IH; clear IHxs.

    assert (LE' : le (length xs) (length bs))

           by (simpl in *; omega). 

    clear LE.

    apply IH in LE'; clear IH.

    inversion LE' as [pair Split]; clear LE'.

    destruct pair as [l1 l2] eqn:Pair.

    simpl.

    rewrite Split.

    exists (b :: l1, l2).

    simpl.

    auto.

Qed.



Lemma lengthSplit2 : forall {A : Type} (l l' l1 l2 : list A), 

                       lengthSplit l l' = Some (l1, l2) -> l1 ++ l2 = l'.

induction l.

+ intros l' l1 l2 Hyp; simpl in Hyp; inversion_clear Hyp; auto.

+ intros l' l1 l2 Hyp. 

  simpl in Hyp.

  destruct l' as [ | y ys] eqn:L'.

  - inversion Hyp.

  - destruct l1 eqn:L1.

    * destruct (lengthSplit l ys); simpl in *.

      + destruct p; congruence.

      + congruence.

    * pose proof IHl ys l0 l2; clear IHl.

      destruct (lengthSplit l ys) eqn:LenSplit; simpl in *.

      + inversion Hyp. destruct p. inversion H1. subst.

        rewrite H; auto.

      + inversion Hyp.

Qed.      



Lemma lengthSplit3 : forall {A : Type} (l l' l1 l2 : list A), 

                       lengthSplit l l' = Some (l1, l2) -> length l1 = length l.

induction l as [ | x xs IHxs].

+ intros; simpl in H; inversion H; auto.

+ intros l' l1 l2 Split.

  simpl in Split.

  destruct l'.

  - inversion Split.

  - destruct l1.

    * destruct (lengthSplit xs l').

      + simpl in *. destruct p. inversion Split.

      + simpl in *. inversion Split.

    * simpl in *. 

      destruct (lengthSplit xs l') eqn:LenSplit.

      + simpl in *. destruct p. inversion Split; subst; clear Split.

        pose proof (IHxs l' l1 l2 LenSplit) as Hyp; clear IHxs.

        auto.

      + simpl in *. inversion Split.

Qed.        



Lemma lengthPathEven : forall p, exists n, length (posToPathAux p) = (2 * n)%nat.

induction p.

+ inversion IHp as [n Hyp]; clear IHp.

  simpl.

  exists (S n).

  rewrite app_length. 

  rewrite Hyp.

  simpl.

  omega.

+ inversion IHp as [n Hyp]; clear IHp.

  simpl.

  exists (S n).

  rewrite app_length. 

  rewrite Hyp.

  simpl.

  omega.

+ exists (O).

  simpl.

  auto.

Qed.



Lemma evenPathAux : forall l l' l'' lApp f n p, length l = (2 * n)%nat -> 

                      pathToPosAux (l ++ l' ++ l'') f = Some p ->

                      exists f', pathToPosAux (l ++ l') f = pathToPosAux l' f'

                                 /\ pathToPosAux (l ++ l' ++ lApp) f = 

                                    pathToPosAux (l' ++ lApp) f'.

induction l using list_ind'.

+ intros. exists f. auto.

+ intros. simpl in *. omega.

+ intros l' l'' lApp f n p Len Valid.

  destruct n.

  - simpl in Len. congruence.

  - simpl in Len; assert (length l = (2 * n)%nat) by omega.

    destruct a eqn:A; destruct b eqn:B; simpl in *.

    * unfold pathToPos in Valid. simpl in Valid.

      pose proof (IHl l' l'' lApp (fun p => xO (f p)) n p H Valid) as Hyp; clear IHl H.

      inversion Hyp as [f' HF]; clear Hyp.

      exists f'.

      auto.

    * unfold pathToPos in Valid. simpl in Valid.

      pose proof (IHl l' l'' lApp (fun p => xI (f p)) n p H Valid) as Hyp; clear IHl H.

      inversion Hyp as [f' HF]; clear Hyp.

      exists f'.

      auto.

    * inversion Valid.

    * inversion Valid.

Qed.



Lemma pathBeginsLeft : forall l1 l2 f x, l1 <> [] -> l2 <> [] -> 

                                     pathToPosAux (l1 ++ l2) f = Some x ->

                                     head l1 = Some Left.

destruct l1.

+ intros. exfalso; apply H; auto.

+ intros. 

  destruct s.

  - auto.

  - simpl in H1. 

    destruct (l1 ++ l2) eqn:Contra.

    * destruct l1; destruct l2; try solve [unfold not; exfalso; auto]; 

      simpl in *; congruence.

    * congruence.

Qed.



Lemma listAppNeq : forall (A : Type) (l1 l2 l3 l4 : list A), 

                     (forall (x y : A), {x = y} + {x <> y}) ->

                     length l1 = length l2 -> 

                     l1 <> l2 ->

                     l1 ++ l3 <> l2 ++ l4.

induction l1.

+ intros.

  destruct l2.

  - unfold not in H0. exfalso; apply H0; auto.

  - simpl in H; inversion H.

+ intros l2 l3 l4 EqDec Len Neq.

  destruct l2 as [ | b l2 ].

  - simpl in Len. congruence.

  - destruct (EqDec a b).

    * subst. simpl in Len. 

      inversion Len as [ Len']; clear Len.

      simpl.

      pose proof (IHl1 l2 l3 l4 EqDec Len') as Contra; clear IHl1.

      assert (l1 <> l2) by (unfold not; intros; congruence).

      apply Contra in H.

      unfold not in *.

      intros.

      apply H.

      inversion H0.

      auto.

    * unfold not; intros.

      inversion H.

      congruence.

Qed.



Lemma PosToPathPrefixFreeAux : forall (x y : positive), (x <> y) -> 

                                 le (length (posToPathAux y)) (length(posToPathAux x)) ->

                              PrefixFree [posToPath x;

                                          posToPath y].

intros x y H Leq.

apply FreeCons; [ apply FreeCons ; [ constructor | intros p Contra; inversion Contra] | ].

intros.

inversion H0; subst; clear H0; [ | inversion H2].

unfold posToPath in *; simpl in *; repeat rewrite <- app_assoc in *.



pose proof (lengthSplit1 Leq) as Hyp.

inversion Hyp as [pair Split]; clear Hyp.

destruct pair as [l0 l1].

pose proof (lengthSplit2 Split) as AppHyp.

pose proof (lengthSplit3 Split) as LenHyp.

pose proof (lengthPathEven y) as Hyp; inversion Hyp as [n LenN]; subst; clear Hyp.

assert (XHyp : pathToPosAux (l0 ++ l1 ++ [Right]) (fun x => x) = Some x); 

  [ rewrite app_assoc; rewrite AppHyp; apply posPathInj | ].



rewrite <- LenHyp in LenN.



pose proof (evenPathAux [Right] LenN XHyp) as Even.

inversion Even as [f' HF]; clear Even.

inversion HF as [HF1 HF2]; clear HF.

rewrite <- AppHyp in H1.

rewrite <- app_assoc in H1.



destruct (list_eq_dec Direction_eq_dec (posToPathAux y) l0).

- subst. apply app_inv_head in H1.

  destruct l1.

  *  simpl in AppHyp; rewrite app_nil_r in AppHyp.

      assert (posToPathAux y ++ [Right] = posToPathAux x ++ [Right]) 

        by (rewrite AppHyp; auto).

      assert (posToPath y = posToPath x) by (unfold posToPath; auto).

      assert (pathToPos (posToPath y) = pathToPos (posToPath x)) by (rewrite H2; auto).

      repeat rewrite posPathInj in H3.

      congruence.

  * assert (Contra : hd_error (s :: l1) = Some Left).

    eapply pathBeginsLeft.

    + unfold not; intros; congruence.

    + instantiate (1 := [Right]); unfold not; intros; congruence.

    + instantiate (1:= x); instantiate (1:=f').

      rewrite <- HF2.

      apply XHyp.

    simpl in Contra. inversion Contra; subst. simpl in H1. congruence.

- eapply listAppNeq.

  * apply Direction_eq_dec.

  * instantiate (1 := l0). instantiate (1 := posToPathAux y). eauto.

  * eassumption.

  * eapply H1.

Qed.



Lemma prefixFreeCommutative : forall l1 l2, PrefixFree [l1;l2] -> PrefixFree [l2;l1].

intros.

inversion H.

apply FreeCons.

+ apply FreeCons.

  - constructor.

  - intros. inversion H4.

+ intros.

  subst.

  eapply H3.

  - instantiate (1 := l2); left; auto.

  - inversion H4.

    * subst. inversion H4. subst. instantiate (1:= p1); instantiate (1 := p2).

      auto.

    * inversion H0.

  - inversion H0.

Qed.



Lemma PosToPathPrefixFree : forall (x y : positive), (x <> y) -> 

                              PrefixFree [posToPath x;

                                          posToPath y].

intros. 

destruct (Compare_dec.le_ge_dec (length (posToPathAux y)) 

                                (length (posToPathAux x))).

+ apply (PosToPathPrefixFreeAux H l).

+ apply prefixFreeCommutative.

  apply (@PosToPathPrefixFreeAux y x).

  - unfold not in *; intros; exfalso; auto.

  - auto.

Qed.



Function rangeNat (p : nat) : list nat :=

  match p with 

    | O => []

    | S n' => p :: (rangeNat n')

  end.



Definition rangePos (p : positive) : list positive := 

  map Pos.of_nat (rangeNat (Pos.to_nat p)).



Lemma ltInRange : forall m n, le n m -> n <> O -> In n (rangeNat m).

  induction m; intros.

  + inversion H. simpl. auto.

  + simpl. inversion H.

    - left; auto.

    - right; subst. apply IHm; auto.

Qed.



Lemma posLtInRange : forall max pos, Pos.le pos max -> In pos (rangePos max).

  intros.

  apply in_map_iff.

  exists (Pos.to_nat pos).

  split.

  - apply Pos2Nat.id.

  - apply ltInRange.

    + apply Pos2Nat.inj_le; auto.

    + pose proof (Pos2Nat.is_succ pos) as Contra; inversion_clear Contra; congruence.

Qed.



Lemma rangeNatLt : forall n m, In m (rangeNat n) -> lt m (S n) /\ m <> O.

  induction n; intros.

  + simpl in H. inversion H. 

  + inversion H.

    - split. 

      * subst. unfold lt. apply le_n.

      * congruence.

    - apply IHn in H0; inversion H0; clear H0; split.

      * unfold lt in *.

        apply le_S.

        auto.

      * auto.

Qed.    



Lemma rangePosPrefixFree : forall p, PrefixFree (map posToPath (rangePos p)).

  intros.

  unfold rangePos.

  induction (Pos.to_nat p) as [ | n IHn].

  + constructor.

  + simpl. apply FreeCons; auto.

    intros p' InP' p1 p2 App.

    apply in_map_iff in InP'.

    clear IHn.

    inversion InP' as [x xHyp]; clear InP'.

    inversion xHyp as [Pos2Path InX]; clear xHyp.

    subst.

    apply in_map_iff in InX.

    inversion InX as [y yHyp]; clear InX.

    inversion yHyp as [Pos2PathY InY]; clear yHyp.

    apply rangeNatLt in InY.

    inversion InY as [LtYSn YNotO]; clear InY.

    remember (match n with | O => 1 | S _ => Pos.succ (Pos.of_nat n) end) as m.

    assert (Neq : x <> m).

      unfold not; intros; subst.

      destruct y.

      - congruence.

      - destruct n.

        * omega.

        * assert (Pos.to_nat (Pos.of_nat (S y)) = Pos.to_nat (Pos.succ (Pos.of_nat (S n))))

            by (rewrite H; auto).

          rewrite Pos2Nat.inj_succ in H0.

          

          rewrite Nat2Pos.id in H0.

          rewrite Nat2Pos.id in H0.

          + subst; omega.

          + congruence.

          + congruence.

    pose proof (@PosToPathPrefixFree x m) as Hyp.

    apply Hyp in Neq; clear Hyp.

    inversion Neq.

    eapply H2.

    + left; auto.

    + eauto.

Qed.    



Definition posFunToPathFun (f : positive -> RandomSeed) (p : SplitPath) 

: RandomSeed :=

  match pathToPos p with 

    | Some a => f a

    | None   => newRandomSeed

  end.



Theorem coarbComplete' : forall (max : positive) (f : positive -> RandomSeed) ,

                          exists seed, forall p, p <= max -> 

                            varySeed (posToPath p) seed = f p.

intros.

pose proof (SplitPathCompleteness (map posToPath (rangePos max)) 

                                (posFunToPathFun f) (rangePosPrefixFree max)).

inversion H; clear H.

exists x.

intros.

pose proof H0 (posToPath p).

rewrite H1.

+ unfold posFunToPathFun.

  rewrite posPathInj.

  reflexivity.

+ apply in_map_iff.

  exists p.

  split; auto.

  apply posLtInRange.

  auto.

Qed.



Definition funToPosFun {A : Type} `{_ : CoArbitrary A} (f : A -> RandomSeed) (p : positive)

: RandomSeed :=

  match coarbReverse p with 

    | Some a => f a

    | None   => newRandomSeed

  end.



Definition coarbLe {A : Type} `{_ : CoArbitrary A} (x y : A) : Prop :=

  Pos.le (coarbitrary x) (coarbitrary y).



Lemma coarbLePreservesLe : forall {A : Type} `{_ : CoArbitrary A} (x y : A),

  coarbLe x y -> Pos.le (coarbitrary x) (coarbitrary y).

by [].

Qed.



Theorem coarbComplete : forall {A : Type} `{_ : CoArbitrary A} (max : A)

                               (f : A -> RandomSeed),

                          exists seed, forall a, coarbLe a max ->

                                          varySeed (posToPath (coarbitrary a)) seed = f a.

intros.

pose proof (coarbComplete' (coarbitrary max) (funToPosFun f)) as Hyp.

inversion Hyp as [seed HSeed]; clear Hyp.

exists seed.

intros a HLe.

pose proof (HSeed (coarbitrary a)) as HCo; clear HSeed.

apply coarbLePreservesLe in HLe.

apply HCo in HLe; clear HCo.

rewrite HLe; clear HLe.

unfold funToPosFun.

rewrite coarbCorrect.

reflexivity.

Qed.



Instance genFun {A B : Type} `{_ : CoArbitrary A} `{_ : Gen B} : Gen (A -> B) :=

  {|

    arbitrary := 

      reallyUnsafePromote (fun a => variant (posToPath (coarbitrary a)) arbitrary);

  |}.



Instance shrinkFunNil {A B : Type} : Shrink (A -> B) :=

  {| shrink x := nil |}.



Section arbFun_completeness.



Variables A B : Type.

Hypothesis choice : FunctionalChoice_on A RandomSeed.



Theorem arbFunComplete `{CoArbitrary A, Arbitrary B} (max:A) (f:A-> B) (s:nat) :

  s = Pos.to_nat (coarbitrary max) -> (semGenSize arbitrary s <--> setT) ->

  exists seed, forall a, coarbLe a max -> run arbitrary s seed a = f a.



Proof.

move=> eqsize semB.

have/choice [fseed fseedP]: forall a, exists seed : RandomSeed, run arbitrary s seed = f a.

  by move => a; case: (semB (f a))=> _ /(_ I) [seed ?]; exists seed.

case: (coarbComplete max fseed) => seed Hseed.

pose proof (randomSplitAssumption seed seed) as Hyp.

move : Hyp => [seed' Hsplit].

exists seed' => a le_a; rewrite -fseedP -Hseed //=.

apply (@promoteVariant A B a (fun a => posToPath (coarbitrary a)) arbitrary 

                       s seed' seed seed Hsplit).

Qed.



End arbFun_completeness.



