

Set Warnings "-notation-overridden,-parsing".

Require Export Logic.

Require Coq.omega.Omega.



Inductive ev : nat -> Prop :=

| ev_0 : ev 0

| ev_SS : forall n : nat, ev n -> ev (S (S n)).



Fail Inductive wrong_ev (n : nat) : Prop :=

| wrong_ev_0 : wrong_ev 0

| wrong_ev_SS : forall n, wrong_ev n -> wrong_ev (S (S n)).



Theorem ev_4 : ev 4.

Proof. apply ev_SS. apply ev_SS. apply ev_0. Qed.



Theorem ev_4' : ev 4.

Proof. apply (ev_SS 2 (ev_SS 0 ev_0)). Qed.



Theorem ev_plus4 : forall n, ev n -> ev (4 + n).

Proof.

  intros n. simpl. intros Hn.

  apply ev_SS. apply ev_SS. apply Hn.

Qed.



Theorem ev_double : forall n,

  ev (double n).

Proof.

   Admitted.



Theorem ev_minus2 : forall n,

  ev n -> ev (pred (pred n)).

Proof.

  intros n E.

  inversion E as [| n' E'].

  -  simpl. apply ev_0.

  -  simpl. apply E'.  Qed.



Theorem ev_minus2' : forall n,

  ev n -> ev (pred (pred n)).

Proof.

  intros n E.

  destruct E as [| n' E'].

  -  simpl. apply ev_0.

  -  simpl. apply E'.  Qed.



Theorem evSS_ev : forall n,

  ev (S (S n)) -> ev n.



Proof.

  intros n E.

  destruct E as [| n' E'].

  - 

    

Abort.



Theorem evSS_ev : forall n,

  ev (S (S n)) -> ev n.

Proof.

  intros n E.

  inversion E as [| n' E'].

  

  apply E'.

Qed.



Theorem one_not_even : ~ ev 1.

Proof.

  intros H. inversion H. Qed.



Theorem SSSSev__even : forall n,

  ev (S (S (S (S n)))) -> ev n.

Proof.

   Admitted.



Theorem even5_nonsense :

  ev 5 -> 2 + 2 = 9.

Proof.

   Admitted.



Lemma ev_even_firsttry : forall n,

  ev n -> exists k, n = double k.

Proof.



  intros n E. inversion E as [| n' E'].

  - 

    exists 0. reflexivity.

  -  simpl.



    assert (I : (exists k', n' = double k') ->

                (exists k, S (S n') = double k)).

    { intros [k' Hk']. rewrite Hk'. exists (S k'). reflexivity. }

    apply I. 



Admitted.



Lemma ev_even : forall n,

  ev n -> exists k, n = double k.

Proof.

  intros n E.

  induction E as [|n' E' IH].

  - 

    exists 0. reflexivity.

  - 


    destruct IH as [k' Hk'].

    rewrite Hk'. exists (S k'). reflexivity.

Qed.



Theorem ev_even_iff : forall n,

  ev n <-> exists k, n = double k.

Proof.

  intros n. split.

  -  apply ev_even.

  -  intros [k Hk]. rewrite Hk. apply ev_double.

Qed.



Theorem ev_sum : forall n m, ev n -> ev m -> ev (n + m).

Proof.

   Admitted.



Inductive ev' : nat -> Prop :=

| ev'_0 : ev' 0

| ev'_2 : ev' 2

| ev'_sum : forall n m, ev' n -> ev' m -> ev' (n + m).



Theorem ev'_ev : forall n, ev' n <-> ev n.

Proof.

  Admitted.



Theorem ev_ev__ev : forall n m,

  ev (n+m) -> ev n -> ev m.

Proof.

   Admitted.



Theorem ev_plus_plus : forall n m p,

  ev (n+m) -> ev (n+p) -> ev (m+p).

Proof.

   Admitted.



Module Playground.



Inductive le : nat -> nat -> Prop :=

  | le_n : forall n, le n n

  | le_S : forall n m, (le n m) -> (le n (S m)).



Notation "m <= n" := (le m n).



Theorem test_le1 :

  3 <= 3.

Proof.

  

  apply le_n.  Qed.



Theorem test_le2 :

  3 <= 6.

Proof.

  

  apply le_S. apply le_S. apply le_S. apply le_n.  Qed.



Theorem test_le3 :

  (2 <= 1) -> 2 + 2 = 5.

Proof.

  

  intros H. inversion H. inversion H2.  Qed.



End Playground.



Definition lt (n m:nat) := le (S n) m.



Notation "m < n" := (lt m n).



Inductive square_of : nat -> nat -> Prop :=

  | sq : forall n:nat, square_of n (n * n).



Inductive next_nat : nat -> nat -> Prop :=

  | nn : forall n:nat, next_nat n (S n).



Inductive next_even : nat -> nat -> Prop :=

  | ne_1 : forall n, ev (S n) -> next_even n (S n)

  | ne_2 : forall n, ev (S (S n)) -> next_even n (S (S n)).



Lemma le_trans : forall m n o, m <= n -> n <= o -> m <= o.

Proof.

   Admitted.



Theorem O_le_n : forall n,

  0 <= n.

Proof.

   Admitted.



Theorem n_le_m__Sn_le_Sm : forall n m,

  n <= m -> S n <= S m.

Proof.

   Admitted.



Theorem Sn_le_Sm__n_le_m : forall n m,

  S n <= S m -> n <= m.

Proof.

   Admitted.



Theorem le_plus_l : forall a b,

  a <= a + b.

Proof.

   Admitted.



Theorem plus_lt : forall n1 n2 m,

  n1 + n2 < m ->

  n1 < m /\ n2 < m.

Proof.

 unfold lt.

  Admitted.



Theorem lt_S : forall n m,

  n < m ->

  n < S m.

Proof.

   Admitted.



Theorem leb_complete : forall n m,

  leb n m = true -> n <= m.

Proof.

   Admitted.



Theorem leb_correct : forall n m,

  n <= m ->

  leb n m = true.

Proof.

   Admitted.



Theorem leb_true_trans : forall n m o,

  leb n m = true -> leb m o = true -> leb n o = true.

Proof.

   Admitted.



Theorem leb_iff : forall n m,

  leb n m = true <-> n <= m.

Proof.

   Admitted.



Module R.



Inductive R : nat -> nat -> nat -> Prop :=

   | c1 : R 0 0 0

   | c2 : forall m n o, R m n o -> R (S m) n (S o)

   | c3 : forall m n o, R m n o -> R m (S n) (S o)

   | c4 : forall m n o, R (S m) (S n) (S (S o)) -> R m n o

   | c5 : forall m n o, R m n o -> R n m o.



Definition fR : nat -> nat -> nat

  . Admitted.



Theorem R_equiv_fR : forall m n o, R m n o <-> fR m n = o.

Proof.

 Admitted.



End R.



Inductive reg_exp (T : Type) : Type :=

| EmptySet : reg_exp T

| EmptyStr : reg_exp T

| Char : T -> reg_exp T

| App : reg_exp T -> reg_exp T -> reg_exp T

| Union : reg_exp T -> reg_exp T -> reg_exp T

| Star : reg_exp T -> reg_exp T.



Arguments EmptySet {T}.

Arguments EmptyStr {T}.

Arguments Char {T} _.

Arguments App {T} _ _.

Arguments Union {T} _ _.

Arguments Star {T} _.



Inductive exp_match {T} : list T -> reg_exp T -> Prop :=

| MEmpty : exp_match [] EmptyStr

| MChar : forall x, exp_match [x] (Char x)

| MApp : forall s1 re1 s2 re2,

           exp_match s1 re1 ->

           exp_match s2 re2 ->

           exp_match (s1 ++ s2) (App re1 re2)

| MUnionL : forall s1 re1 re2,

              exp_match s1 re1 ->

              exp_match s1 (Union re1 re2)

| MUnionR : forall re1 s2 re2,

              exp_match s2 re2 ->

              exp_match s2 (Union re1 re2)

| MStar0 : forall re, exp_match [] (Star re)

| MStarApp : forall s1 s2 re,

               exp_match s1 re ->

               exp_match s2 (Star re) ->

               exp_match (s1 ++ s2) (Star re).



Notation "s =~ re" := (exp_match s re) (at level 80).



Example reg_exp_ex1 : [1] =~ Char 1.

Proof.

  apply MChar.

Qed.



Example reg_exp_ex2 : [1; 2] =~ App (Char 1) (Char 2).

Proof.

  apply (MApp [1] _ [2]).

  - apply MChar.

  - apply MChar.

Qed.



Example reg_exp_ex3 : ~ ([1; 2] =~ Char 1).

Proof.

  intros H. inversion H.

Qed.



Fixpoint reg_exp_of_list {T} (l : list T) :=

  match l with

  | [] => EmptyStr

  | x :: l' => App (Char x) (reg_exp_of_list l')

  end.



Example reg_exp_ex4 : [1; 2; 3] =~ reg_exp_of_list [1; 2; 3].

Proof.

  simpl. apply (MApp [1]).

  { apply MChar. }

  apply (MApp [2]).

  { apply MChar. }

  apply (MApp [3]).

  { apply MChar. }

  apply MEmpty.

Qed.



Lemma MStar1 :

  forall T s (re : reg_exp T) ,

    s =~ re ->

    s =~ Star re.

Proof.

  intros T s re H.

  rewrite <- (app_nil_r _ s).

  apply (MStarApp s [] re).

  - apply H.

  - apply MStar0.

Qed.



Lemma empty_is_empty : forall T (s : list T),

  ~ (s =~ EmptySet).

Proof.

   Admitted.



Lemma MUnion' : forall T (s : list T) (re1 re2 : reg_exp T),

  s =~ re1 \/ s =~ re2 ->

  s =~ Union re1 re2.

Proof.

   Admitted.



Lemma MStar' : forall T (ss : list (list T)) (re : reg_exp T),

  (forall s, In s ss -> s =~ re) ->

  fold app ss [] =~ Star re.

Proof.

   Admitted.



Lemma reg_exp_of_list_spec : forall T (s1 s2 : list T),

  s1 =~ reg_exp_of_list s2 <-> s1 = s2.

Proof.

   Admitted.



Fixpoint re_chars {T} (re : reg_exp T) : list T :=

  match re with

  | EmptySet => []

  | EmptyStr => []

  | Char x => [x]

  | App re1 re2 => re_chars re1 ++ re_chars re2

  | Union re1 re2 => re_chars re1 ++ re_chars re2

  | Star re => re_chars re

  end.



Theorem in_re_match : forall T (s : list T) (re : reg_exp T) (x : T),

  s =~ re ->

  In x s ->

  In x (re_chars re).

Proof.

  intros T s re x Hmatch Hin.

  induction Hmatch

    as [

        |x'

        |s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2

        |s1 re1 re2 Hmatch IH|re1 s2 re2 Hmatch IH

        |re|s1 s2 re Hmatch1 IH1 Hmatch2 IH2].

  

  - 

    apply Hin.

  - 

    apply Hin.

  - simpl. rewrite in_app_iff in *.

    destruct Hin as [Hin | Hin].

    + 

      left. apply (IH1 Hin).

    + 

      right. apply (IH2 Hin).

  - 

    simpl. rewrite in_app_iff.

    left. apply (IH Hin).

  - 

    simpl. rewrite in_app_iff.

    right. apply (IH Hin).

  - 

    destruct Hin.



  - 

    simpl. rewrite in_app_iff in Hin.

    destruct Hin as [Hin | Hin].

    + 

      apply (IH1 Hin).

    + 

      apply (IH2 Hin).

Qed.



Fixpoint re_not_empty {T : Type} (re : reg_exp T) : bool

  . Admitted.



Lemma re_not_empty_correct : forall T (re : reg_exp T),

  (exists s, s =~ re) <-> re_not_empty re = true.

Proof.

   Admitted.



Lemma star_app: forall T (s1 s2 : list T) (re : reg_exp T),

  s1 =~ Star re ->

  s2 =~ Star re ->

  s1 ++ s2 =~ Star re.

Proof.

  intros T s1 s2 re H1.



  induction H1

    as [|x'|s1 re1 s2' re2 Hmatch1 IH1 Hmatch2 IH2

        |s1 re1 re2 Hmatch IH|re1 s2' re2 Hmatch IH

        |re''|s1 s2' re'' Hmatch1 IH1 Hmatch2 IH2].



  - 

    simpl. intros H. apply H.



  - 

Abort.



Lemma star_app: forall T (s1 s2 : list T) (re re' : reg_exp T),

  s1 =~ re' ->

  re' = Star re ->

  s2 =~ Star re ->

  s1 ++ s2 =~ Star re.



Abort.



Lemma star_app: forall T (s1 s2 : list T) (re : reg_exp T),

  s1 =~ Star re ->

  s2 =~ Star re ->

  s1 ++ s2 =~ Star re.

Proof.

  intros T s1 s2 re H1.

  remember (Star re) as re'.



  generalize dependent s2.

  induction H1

    as [|x'|s1 re1 s2' re2 Hmatch1 IH1 Hmatch2 IH2

        |s1 re1 re2 Hmatch IH|re1 s2' re2 Hmatch IH

        |re''|s1 s2' re'' Hmatch1 IH1 Hmatch2 IH2].



  -   inversion Heqre'.

  -    inversion Heqre'.

  -     inversion Heqre'.

  -  inversion Heqre'.

  -  inversion Heqre'.



  - 

    inversion Heqre'. intros s H. apply H.



  - 

    inversion Heqre'. rewrite H0 in IH2, Hmatch1.

    intros s2 H1. rewrite <- app_assoc.

    apply MStarApp.

    + apply Hmatch1.

    + apply IH2.

      * reflexivity.

      * apply H1.

Qed.



Lemma MStar'' : forall T (s : list T) (re : reg_exp T),

  s =~ Star re ->

  exists ss : list (list T),

    s = fold app ss []

    /\ forall s', In s' ss -> s' =~ re.

Proof.

   Admitted.



Module Pumping.



Fixpoint pumping_constant {T} (re : reg_exp T) : nat :=

  match re with

  | EmptySet => 0

  | EmptyStr => 1

  | Char _ => 2

  | App re1 re2 =>

      pumping_constant re1 + pumping_constant re2

  | Union re1 re2 =>

      pumping_constant re1 + pumping_constant re2

  | Star _ => 1

  end.



Fixpoint napp {T} (n : nat) (l : list T) : list T :=

  match n with

  | 0 => []

  | S n' => l ++ napp n' l

  end.



Lemma napp_plus: forall T (n m : nat) (l : list T),

  napp (n + m) l = napp n l ++ napp m l.

Proof.

  intros T n m l.

  induction n as [|n IHn].

  - reflexivity.

  - simpl. rewrite IHn, app_assoc. reflexivity.

Qed.



Lemma pumping : forall T (re : reg_exp T) s,

  s =~ re ->

  pumping_constant re <= length s ->

  exists s1 s2 s3,

    s = s1 ++ s2 ++ s3 /\

    s2 <> [] /\

    forall m, s1 ++ napp m s2 ++ s3 =~ re.



Import Coq.omega.Omega.



Proof.

  intros T re s Hmatch.

  induction Hmatch

    as [ | x | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2

       | s1 re1 re2 Hmatch IH | re1 s2 re2 Hmatch IH

       | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2 ].

  - 

    simpl. omega.

   Admitted.



End Pumping.



Theorem filter_not_empty_In : forall n l,

  filter (beq_nat n) l <> [] ->

  In n l.

Proof.

  intros n l. induction l as [|m l' IHl'].

  - 

    simpl. intros H. apply H. reflexivity.

  - 

    simpl. destruct (beq_nat n m) eqn:H.

    + 

      intros _. rewrite beq_nat_true_iff in H. rewrite H.

      left. reflexivity.

    + 

      intros H'. right. apply IHl'. apply H'.

Qed.



Module FirstTry.



Inductive reflect : Prop -> bool -> Prop :=

| ReflectT : forall (P:Prop), P -> reflect P true

| ReflectF : forall (P:Prop), ~ P -> reflect P false.



End FirstTry.



Inductive reflect (P : Prop) : bool -> Prop :=

| ReflectT : P -> reflect P true

| ReflectF : ~ P -> reflect P false.



Theorem iff_reflect : forall P b, (P <-> b = true) -> reflect P b.

Proof.

  

  intros P b H. destruct b.

  - apply ReflectT. rewrite H. reflexivity.

  - apply ReflectF. rewrite H. intros H'. inversion H'.

Qed.



Theorem reflect_iff : forall P b, reflect P b -> (P <-> b = true).

Proof.

   Admitted.



Lemma beq_natP : forall n m, reflect (n = m) (beq_nat n m).

Proof.

  intros n m.

  apply iff_reflect. rewrite beq_nat_true_iff. reflexivity.

Qed.



Theorem filter_not_empty_In' : forall n l,

  filter (beq_nat n) l <> [] ->

  In n l.

Proof.

  intros n l. induction l as [|m l' IHl'].

  - 

    simpl. intros H. apply H. reflexivity.

  - 

    simpl. destruct (beq_natP n m) as [H | H].

    + 

      intros _. rewrite H. left. reflexivity.

    + 

      intros H'. right. apply IHl'. apply H'.

Qed.



Fixpoint count n l :=

  match l with

  | [] => 0

  | m :: l' => (if beq_nat n m then 1 else 0) + count n l'

  end.



Theorem beq_natP_practice : forall n l,

  count n l = 0 -> ~(In n l).

Proof.

   Admitted.



Inductive nostutter {X:Type} : list X -> Prop :=

 

.



Example test_nostutter_1: nostutter [3;1;4;1;5;6].

 Admitted.



Example test_nostutter_2:  nostutter (@nil nat).

 Admitted.



Example test_nostutter_3:  nostutter [5].

 Admitted.



Example test_nostutter_4:      not (nostutter [3;1;1;4]).

 Admitted.



Lemma in_split : forall (X:Type) (x:X) (l:list X),

  In x l ->

  exists l1 l2, l = l1 ++ x :: l2.

Proof.

   Admitted.



Inductive repeats {X:Type} : list X -> Prop :=

  

.



Theorem pigeonhole_principle: forall (X:Type) (l1  l2:list X),

   excluded_middle ->

   (forall x, In x l1 -> In x l2) ->

   length l2 < length l1 ->

   repeats l1.

Proof.

   intros X l1. induction l1 as [|x l1' IHl1'].

   Admitted.



