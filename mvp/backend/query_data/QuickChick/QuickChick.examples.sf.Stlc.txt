
Set Warnings "-extraction-opaque-accessed,-extraction".
Set Warnings "-notation-overridden,-parsing".

Require Import String List. Open Scope string.

From QuickChick Require Import QuickChick Tactics.
From mathcomp Require Import ssreflect ssrfun ssrbool ssrnat eqtype seq.
Import QcDefaultNotation. Open Scope qc_scope.

Set Bullet Behavior "Strict Subproofs".

Require Import Smallstep.
(* Smallstep:
Set Warnings "-extraction-opaque-accessed,-extraction".
Set Warnings "-notation-overridden,-parsing".

Require Import String List. Open Scope string.

From QuickChick Require Import QuickChick Tactics.
From mathcomp Require Import ssreflect ssrfun ssrbool ssrnat eqtype seq.
Import QcDefaultNotation. Open Scope qc_scope.

Set Bullet Behavior "Strict Subproofs".

Require Import Coq.Arith.Arith.
Require Import Coq.Arith.EqNat.
Require Import Coq.omega.Omega.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Maps.
Require Import Imp.

Inductive tm : Type :=
  | C : nat -> tm         
  | P : tm -> tm -> tm.   

Derive (Arbitrary, Show) for tm.

Fixpoint evalF (t : tm) : nat :=
  match t with
  | C n => n
  | P a1 a2 => evalF a1 + evalF a2
  end.

Reserved Notation " t '\\' n " (at level 50, left associativity).

Inductive eval : tm -> nat -> Prop :=
  | E_Const : forall n,
      C n \\ n
  | E_Plus : forall t1 t2 n1 n2,
      t1 \\ n1 ->
      t2 \\ n2 ->
      P t1 t2 \\ (n1 + n2)

  where " t '\\' n " := (eval t n).

Module SimpleArith1.

Reserved Notation " t '===>' t' " (at level 55).

Inductive step : tm -> tm -> Prop :=
  | ST_PlusConstConst : forall n1 n2,
      P (C n1) (C n2) ===> C (n1 + n2)
  | ST_Plus1 : forall t1 t1' t2,
      t1 ===> t1' ->
      P t1 t2 ===> P t1' t2
  | ST_Plus2 : forall n1 t2 t2',
      t2 ===> t2' ->
      P (C n1) t2 ===> P (C n1) t2'

  where " t '===>' t' " := (step t t').

End SimpleArith1.

Definition relation (X: Type) := X->X->Prop.

Definition deterministic {X: Type} (R: relation X) :=
  forall x y1 y2 : X, R x y1 -> R x y2 -> y1 = y2.

Module SimpleArith2.
Import SimpleArith1.

Theorem step_deterministic:
  deterministic step.

End SimpleArith2.

Ltac solve_by_inverts n :=
  match goal with | H : ?T |- _ => 
  match type of T with Prop =>
    solve [ 
      inversion H; 
      match n with S (S (?n')) => subst; solve_by_inverts (S n') end ]
  end end.

Ltac solve_by_invert :=
  solve_by_inverts 1.

Module SimpleArith3.
Import SimpleArith1.

Theorem step_deterministic_alt: deterministic step.
Derive ArbitrarySizedSuchThat for (fun t => value t).

Reserved Notation " t '===>' t' " (at level 40).

Inductive step : tm -> tm -> Prop :=
  | ST_PlusConstConst : forall n1 n2,
          P (C n1) (C n2)
      ===> C (n1 + n2)
  | ST_Plus1 : forall t1 t1' t2,
        t1 ===> t1' ->
        P t1 t2 ===> P t1' t2
  | ST_Plus2 : forall v1 t2 t2',
        value v1 ->                     
        t2 ===> t2' ->
        P v1 t2 ===> P v1 t2'

  where " t '===>' t' " := (step t t').

Theorem step_deterministic :
  deterministic step.

Definition step_fun (t : tm) : option tm := Some t.

Theorem strong_progress : forall t,
  value t \/ (exists t', t ===> t').

Definition normal_form {X:Type} (R:relation X) (t:X) : Prop :=
  ~ exists t', R t t'.

Lemma value_is_nf : forall v,
  value v -> normal_form step v.

Lemma nf_is_value : forall t,
  normal_form step t -> value t.

Inductive multi {X:Type} (R: relation X) : relation X :=
  | multi_refl  : forall (x : X), multi R x x
  | multi_step : forall (x y z : X),
                    R x y ->
                    multi R y z ->
                    multi R x z.

Notation " t '===>*' t' " := (multi step t t') (at level 40).

Theorem multi_R : forall (X:Type) (R:relation X) (x y : X),
       R x y -> (multi R) x y.

Theorem multi_trans :
  forall (X:Type) (R: relation X) (x y z : X),
      multi R x y  ->
      multi R y z ->
      multi R x z.

Definition step_normal_form := normal_form step.

Definition normal_form_of (t t' : tm) :=
  (t ===>* t' /\ step_normal_form t').

Theorem normal_forms_unique:
  deterministic normal_form_of.

Definition normalizing {X:Type} (R:relation X) :=
  forall t, exists t',
    (multi R) t t' /\ normal_form R t'.

Lemma multistep_congr_1 : forall t1 t1' t2,
     t1 ===>* t1' ->
     P t1 t2 ===>* P t1' t2. *)
Require Import Types.
(* Types:
Derive ArbitrarySizedSuchThat for (fun tm => nvalue tm).
Derive SizedProofEqs for (fun tm => nvalue tm).
Derive SizeMonotonicSuchThatOpt for (fun tm => nvalue tm).
Derive GenSizedSuchThatCorrect for (fun tm => nvalue tm).
Derive GenSizedSuchThatSizeMonotonicOpt for (fun tm => nvalue tm).

Definition value (t:tm) := bvalue t \/ nvalue t.

Hint Constructors bvalue nvalue.
Hint Unfold value.
Hint Unfold update.

Reserved Notation "t1 '===>' t2" (at level 40).

Inductive step : tm -> tm -> Prop :=
  | ST_IfTrue : forall t1 t2,
      (tif ttrue t1 t2) ===> t1
  | ST_IfFalse : forall t1 t2,
      (tif tfalse t1 t2) ===> t2
  | ST_If : forall t1 t1' t2 t3,
      t1 ===> t1' ->
      (tif t1 t2 t3) ===> (tif t1' t2 t3)
  | ST_Succ : forall t1 t1',
      t1 ===> t1' ->
      (tsucc t1) ===> (tsucc t1')
  | ST_PredZero :
      (tpred tzero) ===> tzero
  | ST_PredSucc : forall t1,
      nvalue t1 ->
      (tpred (tsucc t1)) ===> t1
  | ST_Pred : forall t1 t1',
      t1 ===> t1' ->
      (tpred t1) ===> (tpred t1')
  | ST_IszeroZero :
      (tiszero tzero) ===> ttrue
  | ST_IszeroSucc : forall t1,
       nvalue t1 ->
      (tiszero (tsucc t1)) ===> tfalse
  | ST_Iszero : forall t1 t1',
      t1 ===> t1' ->
      (tiszero t1) ===> (tiszero t1')

where "t1 '===>' t2" := (step t1 t2).

Hint Constructors step.

Derive ArbitrarySizedSuchThat for (fun tm => step tm0 tm).
Derive SizeMonotonicSuchThatOpt for (fun tm => step tm0 tm).
Derive GenSizedSuchThatSizeMonotonicOpt for (fun tm => step tm0 tm).

Derive SizedProofEqs for (fun tm => step tm0 tm).

Derive GenSizedSuchThatCorrect for (fun tm => step tm0 tm).

Definition success := "Proofs work!".

Notation step_normal_form := (normal_form step).

Definition stuck (t:tm) : Prop :=
  step_normal_form t /\ ~ value t.

Hint Unfold stuck.

Definition step_fun (t : tm) : option tm := Some t.

Lemma value_is_nf : forall t,
  value t -> step_normal_form t.

Theorem step_deterministic:
  deterministic step.

Lemma bool_canonical : forall t,
  |- t \typ TBool -> value t -> bvalue t.

Lemma nat_canonical : forall t,
  |- t \typ TNat -> value t -> nvalue t.

Theorem progress : forall t T,
  |- t \typ T ->
  value t \/ exists t', t ===> t'.

Global Instance testSuchThat_swap' {A B C : Type} {pre : A -> C -> Prop} 
       {prop : A -> B -> C -> Type}
       `{Checkable (forall a c, pre a c -> forall b, prop a b c)} :
  Checkable (forall a b c, pre a c -> prop a b c) :=
  {| checker f := @checker (forall a c, pre a c -> forall b, prop a b c) _ _ |}. 

Conjecture preservation : forall t t' T,
  |- t \typ T -> t ===> t' ->
  |- t' \typ T.

Definition multistep := (multi step).
Notation "t1 '===>*' t2" := (multistep t1 t2) (at level 40).

Corollary soundness : forall t t' T,
  |- t \typ T ->
  t ===>* t' ->
  ~(stuck t').

Tactic Notation "print_goal" :=
  match goal with |- ?x => idtac x end.
Tactic Notation "normalize" :=
  repeat (print_goal; eapply multi_step ;
            [ (eauto 10; fail) | (instantiate; simpl)]);
  apply multi_refl. *)

Inductive ty : Type :=
  | TBool  : ty
  | TArrow : ty -> ty -> ty.

Derive (Arbitrary, Show) for ty.
Derive (Sized, CanonicalSized) for ty.
Derive SizeMonotonic for ty using genSty.
Derive SizedMonotonic for ty.
Derive SizedCorrect for ty using genSty and SizeMonotonicty.

Instance eq_dec_ty (t1 t2 : ty) : Dec (t1 = t2).
constructor; unfold decidable; decide equality; auto. Defined.

Require Import Ascii String.

Derive (Arbitrary, Show) for ascii.
Derive (Sized, CanonicalSized) for ascii.
Derive SizeMonotonic for ascii using genSascii.
Derive SizedMonotonic for ascii.
Derive SizedCorrect for ascii using genSascii and SizeMonotonicascii.

Derive (Arbitrary, Show) for string.
Derive (Sized, CanonicalSized) for string.
Derive SizeMonotonic for string using genSstring.
Derive SizedMonotonic for string.

Inductive id : Type :=
  | Id : string -> id.

Derive (Arbitrary, Show) for id.
Derive (Sized, CanonicalSized) for id.
Derive SizeMonotonic for id using genSid.
Derive SizedMonotonic for id.
Derive SizedCorrect for id using genSid and SizeMonotonicid.

Instance eq_dec_id (x y : id) : Dec (x = y).
constructor; unfold decidable. repeat decide equality. Defined.

Definition beq_id x y :=
  match x,y with
    | Id n1, Id n2 => if string_dec n1 n2 then true else false
  end.

Inductive trm : Type :=
  | tvar : id -> trm
  | tapp : trm -> trm -> trm
  | tabs : id -> ty -> trm -> trm
  | ttrue : trm
  | tfalse : trm
  | tif : trm -> trm -> trm -> trm.

Derive (Arbitrary, Show) for trm.
Derive (Sized, CanonicalSized) for trm.
Derive SizeMonotonic for trm using genStrm.
Derive SizedMonotonic for trm.
Derive SizedCorrect for trm using genStrm and SizeMonotonictrm.

Instance eq_dec_tm (t1 t2 : trm) : Dec (t1 = t2).
constructor; unfold decidable; repeat decide equality. Defined.

Inductive value : trm -> Prop :=
  | v_abs : forall X T t,
      value (tabs X T t)
  | v_true :
      value ttrue
  | v_false :
      value tfalse.

Derive ArbitrarySizedSuchThat for (fun tm => value tm).
Derive SizedProofEqs for (fun tm => value tm).
Derive SizeMonotonicSuchThatOpt for (fun tm => value tm).
Derive GenSizedSuchThatCorrect for (fun tm => value tm).
Derive GenSizedSuchThatSizeMonotonicOpt for (fun tm => value tm).

Instance dec_value t : Dec (value t).
constructor; unfold decidable; induction t;
try solve [left; constructor; auto];
try solve [right => contra; inversion contra; eauto].
Defined.

Hint Constructors value.

Reserved Notation "'[' x ':=' s ']' t" (at level 20).

Fixpoint subst (x:id) (s:trm) (t:trm) : trm :=
  match t with
  | tvar x' =>
      if beq_id x x' then s else t
  | tabs x' T t1 =>
      tabs x' T (if beq_id x x' then t1 else ([x:=s] t1))
  | tapp t1 t2 =>
      tapp ([x:=s] t1) ([x:=s] t2)
  | ttrue =>
      ttrue
  | tfalse =>
      tfalse
  | tif t1 t2 t3 =>
      tif ([x:=s] t1) ([x:=s] t2) ([x:=s] t3)
  end

where "'[' x ':=' s ']' t" := (subst x s t).

Reserved Notation "t1 '===>' t2" (at level 40).

Inductive step : trm -> trm -> Prop :=
  | ST_AppAbs : forall x T t12 v2,
         value v2 ->
         (tapp (tabs x T t12) v2) ===> [x:=v2]t12
  | ST_App1 : forall t1 t1' t2,
         t1 ===> t1' ->
         tapp t1 t2 ===> tapp t1' t2
  | ST_App2 : forall v1 t2 t2',
         value v1 ->
         t2 ===> t2' ->
         tapp v1 t2 ===> tapp v1  t2'
  | ST_IfTrue : forall t1 t2,
      (tif ttrue t1 t2) ===> t1
  | ST_IfFalse : forall t1 t2,
      (tif tfalse t1 t2) ===> t2
  | ST_If : forall t1 t1' t2 t3,
      t1 ===> t1' ->
      (tif t1 t2 t3) ===> (tif t1' t2 t3)

where "t1 '===>' t2" := (step t1 t2).

Hint Constructors step.

Notation multistep := (multi step).
Notation "t1 '===>*' t2" := (multistep t1 t2) (at level 40).

Definition context := list (id * ty).

Definition empty : context := nil.

Inductive bind : context -> id -> ty -> Prop :=
  | BindNow   : forall i a m, bind (cons (i, a) m) i a
  | BindLater : forall i i' a a' m',
                  ~ (i = i') ->
                  bind m' i a -> 
                  bind (cons (i',a') m') i a.

Derive ArbitrarySizedSuchThat for (fun i => bind m i a).
Derive SizeMonotonicSuchThatOpt for (fun i => bind m i a).
Derive GenSizedSuchThatSizeMonotonicOpt for (fun x => bind m x a).

Instance adm_st m a : SuchThatCorrect (fun x => bind m x a) (genST (fun x => bind m x a)).
Admitted.

Instance bind_dec m x v : Dec (bind m x v) :=
  {| dec := _ |}.
Proof.
  move: x v.
  induction m => x v.
  - right => contra. inversion contra.
  - destruct a as [x' v'].
    destruct (eq_dec_id x x') as [[Eq | Neq]].
    + destruct (eq_dec_ty v v') as [[EqV | NeqV]].
      * subst; left ; constructor; eauto.
      * subst; right => Contra.
        inversion Contra; subst; eauto.
    + subst; specialize (IHm x v).
      destruct IHm as [L | R].
      * left; constructor; eauto.
      * right => Contra; inversion Contra; subst; eauto.
Defined.

Reserved Notation "Gamma '|-' t '\typ' T" (at level 40).

Inductive has_type : context -> trm -> ty -> Prop :=
  | T_Var : forall Gamma i T,
      bind Gamma i T ->
      Gamma |- tvar i \typ T
  | T_Abs : forall Gamma i T11 T12 t12,
      cons (i, T11) Gamma |- t12 \typ T12 ->
      Gamma |- tabs i T11 t12 \typ TArrow T11 T12
  | T_App : forall T11 T12 Gamma t1 t2,
      Gamma |- t1 \typ TArrow T11 T12 ->
      Gamma |- t2 \typ T11 ->
      Gamma |- tapp t1 t2 \typ T12
  | T_True : forall Gamma,
       Gamma |- ttrue \typ TBool
  | T_False : forall Gamma,
       Gamma |- tfalse \typ TBool
  | T_If : forall t1 t2 t3 T Gamma,
       Gamma |- t1 \typ TBool ->
       Gamma |- t2 \typ T ->
       Gamma |- t3 \typ T ->
       Gamma |- tif t1 t2 t3 \typ T

where "Gamma '|-' t '\typ' T" := (has_type Gamma t T).

Hint Constructors has_type.

Derive ArbitrarySizedSuchThat for (fun tm => has_type Gamma tm ty).
Derive SizedProofEqs for (fun tm => value tm).
Derive SizeMonotonicSuchThatOpt for (fun tm => value tm).
Derive GenSizedSuchThatCorrect for (fun tm => value tm).
Derive GenSizedSuchThatSizeMonotonicOpt for (fun tm => value tm).

Instance has_type_gen_correct0 Gamma T : SuchThatCorrect (fun t => has_type Gamma t T) 
                                                         (@arbitraryST _ (fun t => has_type Gamma t T) _).
Admitted.

Fixpoint lookup (Gamma : context) (i : id) : option ty :=
  match Gamma with 
  | nil => None
  | cons (i',T) Gamma' => 
    if beq_id i i' then Some T
    else lookup Gamma' i
  end.

Theorem beq_id_true_iff : forall x y : id,
  beq_id x y = true <-> x = y.
Admitted. 

Theorem beq_id_false_iff : forall x y : id,
  beq_id x y = false
  <-> x <> y.
Admitted. 

Lemma lookup_bind : forall Gamma i T, lookup Gamma i = Some T <-> bind Gamma i T.
induction Gamma => i T; split; intros; eauto.
- inversion H.
- inversion H.
- destruct a; simpl in *.
  destruct (beq_id i i0) eqn:HeqI; eauto.
  + inversion H.
    apply (beq_id_true_iff) in HeqI.
    subst; constructor.
  + apply beq_id_false_iff in HeqI; constructor; eauto.
    eapply IHGamma in H; auto.
- destruct a; inversion H; subst; eauto.
  + simpl.
    destruct (beq_id i i) eqn:B; auto.
    apply beq_id_false_iff in B; congruence.
  + simpl.
    destruct (beq_id i i0) eqn:B; auto.
    * eapply beq_id_true_iff in B; subst; congruence.
    * eapply IHGamma in H6; auto.
Qed.    

Fixpoint get_type (Gamma : context) (t : trm) : option ty.
Admitted.

Instance dec_has_type Gamma t T : Dec (has_type Gamma t T).
constructor; unfold decidable.
move: Gamma T; induction t => Gamma T.
- destruct (bind_dec Gamma i T) as [[In | NotIn]].
  + left; constructor; auto.
  + right => contra; inversion contra; eauto.
Admitted.
