

Require Import IZF_logic.
(* IZF_logic:
Definition Typ2 := Type.
Definition Typ1 : Typ2 := Type. 

Definition Rel (X : Typ1) : Typ1 := X -> X -> Prop.

Definition top : Prop := forall E : Prop, E -> E.

Lemma top_intro : top.
Proof fun E e => e.

Definition bot : Prop := forall E : Prop, E.

Definition and (A B : Prop) : Prop := forall E : Prop, (A -> B -> E) -> E.

Lemma and_intro : forall A B : Prop, A -> B -> and A B.
Proof fun A B a b E f => f a b.

Lemma and_fst : forall A B : Prop, and A B -> A.
Proof fun A B p => p A (fun a _ => a).

Lemma and_snd : forall A B : Prop, and A B -> B.
Proof fun A B p => p B (fun _ b => b).

Definition or (A B : Prop) : Prop :=
  forall E : Prop, (A -> E) -> (B -> E) -> E.

Lemma or_inl : forall A B : Prop, A -> or A B.
Proof fun A B a E f g => f a.

Lemma or_inr : forall A B : Prop, B -> or A B.
Proof fun A B b E f g => g b.

Definition iff (A B : Prop) : Prop := and (A -> B) (B -> A).

Definition ex (X : Typ1) (P : X -> Prop) : Prop :=
  forall E : Prop, (forall x : X, P x -> E) -> E.

Lemma ex_intro : forall (X : Typ1) (P : X -> Prop) (x : X), P x -> ex X P.
Proof fun X P x p E f => f x p.

Definition ex2 (X : Typ1) (P Q : X -> Prop) : Prop :=
  forall E : Prop, (forall x : X, P x -> Q x -> E) -> E.

Lemma ex2_intro :
 forall (X : Typ1) (P Q : X -> Prop) (x : X), P x -> Q x -> ex2 X P Q.
Proof fun X P Q x p q E f => f x p q.

Definition exT (P : Typ1 -> Prop) : Prop :=
  forall E : Prop, (forall X : Typ1, P X -> E) -> E.

Lemma exT_intro : forall (P : Typ1 -> Prop) (X : Typ1), P X -> exT P.
Proof fun P X p E f => f X p.

Definition exG (P : forall X : Typ1, Rel X -> X -> Prop) : Prop :=
  forall E : Prop, (forall (X : Typ1) (A : Rel X) (a : X), P X A a -> E) -> E.

Lemma exG_intro :
 forall (P : forall X : Typ1, Rel X -> X -> Prop) (X : Typ1) 
   (A : Rel X) (a : X), P X A a -> exG P.

Proof fun P X A a p E f => f X A a p.

Definition eq (X : Typ1) (x y : X) : Prop := forall P : X -> Prop, P x -> P y.

Lemma eq_refl : forall (X : Typ1) (x : X), eq X x x.
Proof fun X x P p => p.

Lemma eq_sym : forall (X : Typ1) (x y : X), eq X x y -> eq X y x.
Proof fun X x y e => e (fun z => eq X z x) (eq_refl X x).

Lemma eq_trans :
 forall (X : Typ1) (x y z : X), eq X x y -> eq X y z -> eq X x z.
Proof fun X x y z e1 e2 P p => e2 P (e1 P p).

Definition opt (X : Typ1) : Typ1 := (X -> Prop) -> Prop.
Definition some (X : Typ1) (x : X) : opt X := fun f => f x.
Definition none (X : Typ1) : opt X := fun _ => bot.

Lemma eq_some_some :
 forall (X : Typ1) (x1 x2 : X),
 eq (opt X) (some X x1) (some X x2) -> eq X x1 x2.

Proof fun X x1 x2 e => e (fun z => z (fun x => eq X x1 x)) (eq_refl X x1).

Lemma eq_some_none :
 forall (X : Typ1) (x : X), eq (opt X) (some X x) (none X) -> bot.

Proof fun X x e => e (fun z => z (fun _ => top)) top_intro.

Lemma eq_none_some :
 forall (X : Typ1) (x : X), eq (opt X) (none X) (some X x) -> bot.

Proof
  fun X x e => e (fun z => z (fun _ => top) -> bot) (fun p => p) top_intro.

Definition sum (X Y : Typ1) : Typ1 := (X -> Prop) -> (Y -> Prop) -> Prop.
Definition inl (X Y : Typ1) (x : X) : sum X Y := fun f _ => f x.
Definition inr (X Y : Typ1) (y : Y) : sum X Y := fun _ g => g y.
Definition out (X Y : Typ1) : sum X Y := fun _ _ => bot.

Lemma eq_inl_inl :
 forall (X Y : Typ1) (x1 x2 : X),
 eq (sum X Y) (inl X Y x1) (inl X Y x2) -> eq X x1 x2.

Proof
  fun X Y x1 x2 e =>
  e (fun z => z (fun x => eq X x1 x) (fun _ => bot)) (eq_refl X x1).

Lemma eq_inr_inr :
 forall (X Y : Typ1) (y1 y2 : Y),
 eq (sum X Y) (inr X Y y1) (inr X Y y2) -> eq Y y1 y2.

Proof
  fun X Y y1 y2 e =>
  e (fun z => z (fun _ => bot) (fun y => eq Y y1 y)) (eq_refl Y y1).

Lemma eq_inl_inr :
 forall (X Y : Typ1) (x : X) (y : Y),
 eq (sum X Y) (inl X Y x) (inr X Y y) -> bot.

Proof fun X Y x y e => e (fun z => z (fun _ => top) (fun _ => bot)) top_intro.

Lemma eq_inr_inl :
 forall (X Y : Typ1) (x : X) (y : Y),
 eq (sum X Y) (inr X Y y) (inl X Y x) -> bot.

Proof fun X Y x y e => e (fun z => z (fun _ => bot) (fun _ => top)) top_intro.

Lemma eq_inl_out :
 forall (X Y : Typ1) (x : X), eq (sum X Y) (inl X Y x) (out X Y) -> bot.

Proof fun X Y x e => e (fun z => z (fun _ => top) (fun _ => top)) top_intro.

Lemma eq_out_inl :
 forall (X Y : Typ1) (x : X), eq (sum X Y) (out X Y) (inl X Y x) -> bot.

Proof
  fun X Y x e =>
  e (fun z => z (fun _ => top) (fun _ => top) -> bot) (fun p => p) top_intro.

Lemma eq_inr_out :
 forall (X Y : Typ1) (y : Y), eq (sum X Y) (inr X Y y) (out X Y) -> bot.

Proof fun X Y y e => e (fun z => z (fun _ => top) (fun _ => top)) top_intro.

Lemma eq_out_inr :
 forall (X Y : Typ1) (y : Y), eq (sum X Y) (out X Y) (inr X Y y) -> bot.

Proof
  fun X Y y e =>
  e (fun z => z (fun _ => top) (fun _ => top) -> bot) (fun p => p) top_intro. *)

Require Import IZF_base.
(* IZF_base:
Require Import IZF_logic.

Definition EQV (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) 
  (B : Rel Y) (b : Y) : Prop :=
  forall E : Prop,
  (forall R : X -> Y -> Prop,
   (forall (x x' : X) (y : Y),
    A x' x -> R x y -> ex2 Y (fun y' => B y' y) (fun y' => R x' y')) ->
   (forall (y y' : Y) (x : X),
    B y' y -> R x y -> ex2 X (fun x' => A x' x) (fun x' => R x' y')) ->
   R a b -> E) -> E.

Lemma EQV_intro :
 forall (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) (B : Rel Y) 
   (b : Y) (R : X -> Y -> Prop),
 (forall (x x' : X) (y : Y),
  A x' x -> R x y -> ex2 Y (fun y' => B y' y) (fun y' => R x' y')) ->
 (forall (y y' : Y) (x : X),
  B y' y -> R x y -> ex2 X (fun x' => A x' x) (fun x' => R x' y')) ->
 R a b -> EQV X A a Y B b.

Proof fun X A a Y B b R H1 H2 H3 E e => e R H1 H2 H3.

Lemma EQV_refl : forall (X : Typ1) (A : Rel X) (a : X), EQV X A a X A a.

Lemma EQV_sym :
 forall (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) (B : Rel Y) (b : Y),
 EQV X A a Y B b -> EQV Y B b X A a.

Lemma EQV_trans :
 forall (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) (B : Rel Y) 
   (b : Y) (Z : Typ1) (C : Rel Z) (c : Z),
 EQV X A a Y B b -> EQV Y B b Z C c -> EQV X A a Z C c.

Lemma EQV_shift :
 forall (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) (B : Rel Y) (b : Y),
 EQV X A a Y B b ->
 forall a' : X,
 A a' a -> ex2 Y (fun b' => B b' b) (fun b' => EQV X A a' Y B b').

Definition ELT (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) 
  (B : Rel Y) (b : Y) : Prop :=
  forall E : Prop, (forall b' : Y, B b' b -> EQV X A a Y B b' -> E) -> E.

Lemma ELT_intro :
 forall (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) (B : Rel Y) (b b' : Y),
 B b' b -> EQV X A a Y B b' -> ELT X A a Y B b.

Proof fun X A a Y B b b' H1 H2 E e => e b' H1 H2.

Lemma ELT_direct :
 forall (X : Typ1) (A : Rel X) (a a' : X), A a' a -> ELT X A a' X A a.

Lemma ELT_compat_l :
 forall (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) (B : Rel Y) 
   (b : Y) (Z : Typ1) (C : Rel Z) (c : Z),
 EQV X A a Y B b -> ELT Y B b Z C c -> ELT X A a Z C c.

Lemma ELT_compat_r :
 forall (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) (B : Rel Y) 
   (b : Y) (Z : Typ1) (C : Rel Z) (c : Z),
 ELT X A a Y B b -> EQV Y B b Z C c -> ELT X A a Z C c.

Definition SUB (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) 
  (B : Rel Y) (b : Y) : Prop :=
  forall (Z : Typ1) (C : Rel Z) (c : Z), ELT Z C c X A a -> ELT Z C c Y B b.

Lemma SUB_refl : forall (X : Typ1) (A : Rel X) (a : X), SUB X A a X A a.

Lemma SUB_trans :
 forall (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) (B : Rel Y) 
   (b : Y) (Z : Typ1) (C : Rel Z) (c : Z),
 SUB X A a Y B b -> SUB Y B b Z C c -> SUB X A a Z C c.

Theorem extensionality :
 forall (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) (B : Rel Y) (b : Y),
 SUB X A a Y B b -> SUB Y B b X A a -> EQV X A a Y B b.

Definition deloc (X : Typ1) (A : Rel X) (Y : Typ1) 
  (B : Rel Y) (f : X -> Y) : Prop :=
  and (forall x x' : X, A x' x -> B (f x') (f x))
    (forall (x : X) (y' : Y),
     B y' (f x) -> ex2 X (fun x' => A x' x) (fun x' => eq Y y' (f x'))).

Lemma EQV_deloc :
 forall (X : Typ1) (A : Rel X) (Y : Typ1) (B : Rel Y) (f : X -> Y),
 deloc X A Y B f -> forall x : X, EQV X A x Y B (f x). *)

Require Import IZF_nat.
(* IZF_nat:
Require Import IZF_logic.

Definition Typ0 : Typ1 := Type.

Definition nat : Typ1 := forall X : Typ0, X -> (X -> X) -> X.
Definition O : nat := fun X x f => x.
Definition S (n : nat) : nat := fun X x f => f (n X x f).

Definition wf_nat (n : nat) : Prop :=
  forall P : nat -> Prop, P O -> (forall p : nat, P p -> P (S p)) -> P n.

Definition sqr (X : Typ0) : Typ0 := (X -> X -> X) -> X.
Definition pair (X : Typ0) (x y : X) : sqr X := fun f => f x y.

Definition fst (X : Typ0) (p : sqr X) : X := p (fun x _ => x).
Definition snd (X : Typ0) (p : sqr X) : X := p (fun _ y => y).

Definition step (X : Typ0) (f : X -> X) (p : sqr X) : 
  sqr X := pair X (snd X p) (f (snd X p)).

Definition pred (n : nat) : nat :=
  fun X x f => fst X (n (sqr X) (pair X x x) (step X f)).

Lemma pred_O : eq nat (pred O) O.
Proof eq_refl nat O.

Lemma pred_SO : eq nat (pred (S O)) O.
Proof eq_refl nat O.

Lemma pred_SSn : forall n : nat, eq nat (pred (S (S n))) (S (pred (S n))).
Proof fun n => eq_refl nat (pred (S (S n))).

Lemma pred_S : forall n : nat, wf_nat n -> eq nat (pred (S n)) n.

Lemma wf_nat_O : wf_nat O.

Proof fun P HO HS => HO.

Lemma wf_nat_S : forall n : nat, wf_nat n -> wf_nat (S n).

Proof fun n H P HO HS => HS n (H P HO HS).

Lemma eq_S_O : forall n : nat, wf_nat n -> eq nat (S n) O -> bot.

Proof fun n _ H => H (fun p => p Prop bot (fun _ => top)) top_intro.

Lemma eq_O_S : forall n : nat, wf_nat n -> eq nat O (S n) -> bot.

Proof fun n _ H => H (fun p => p Prop top (fun _ => bot)) top_intro.

Lemma eq_S_S :
 forall n : nat,
 wf_nat n -> forall p : nat, wf_nat p -> eq nat (S n) (S p) -> eq nat n p.

Lemma nat_ind :
 forall P : nat -> Prop,
 P O ->
 (forall p : nat, wf_nat p -> P p -> P (S p)) ->
 forall n : nat, wf_nat n -> P n.

Lemma nat_ind' :
 forall n : nat,
 wf_nat n ->
 forall P : nat -> Prop,
 P O -> (forall p : nat, wf_nat p -> P p -> P (S p)) -> P n.

Proof fun n Hn P HO HS => nat_ind P HO HS n Hn.

Definition le (n m : nat) : Prop :=
  forall P : nat -> Prop, P n -> (forall p : nat, P p -> P (S p)) -> P m.

Lemma le_refl : forall n : nat, le n n.

Proof fun n P H _ => H.

Lemma le_trans : forall n1 n2 n3 : nat, le n1 n2 -> le n2 n3 -> le n1 n3.

Proof fun n1 n2 n3 H1 H2 P Hn1 HS => H2 P (H1 P Hn1 HS) HS.

Lemma le_S : forall n m : nat, le n m -> le n (S m).

Proof fun n m H P Hn HS => HS m (H P Hn HS).

Lemma le_Sn_O : forall n : nat, le (S n) O -> bot.

Proof
  fun n H =>
  H (fun k => k Prop bot (fun _ => top)) top_intro (fun _ _ => top_intro).

Lemma le_inv :
 forall n m : nat,
 le n m -> or (eq nat n m) (ex nat (fun k => and (le n k) (eq nat m (S k)))).

Lemma le_n_Sm :
 forall n : nat,
 wf_nat n ->
 forall m : nat, wf_nat m -> le n (S m) -> or (le n m) (eq nat n (S m)).

Definition lt (n m : nat) : Prop := le (S n) m.

Lemma lt_n_Sn : forall n : nat, lt n (S n).

Proof fun n => le_refl (S n).

Lemma lt_S : forall n m : nat, lt n m -> lt n (S m).

Proof fun n m => le_S (S n) m.

Lemma lt_n_O : forall n : nat, lt n O -> bot.

Proof le_Sn_O.

Lemma lt_n_Sm :
 forall n : nat,
 wf_nat n ->
 forall m : nat, wf_nat m -> lt n (S m) -> or (lt n m) (eq nat n m). *)



Definition unit : Typ1 := forall X : Typ0, X -> X.

Definition id : unit := fun X x => x.

Definition ZERO : Rel unit := fun _ _ => bot.



Lemma ZERO_elim :

 forall (X : Typ1) (A : Rel X) (a : X), ELT X A a unit ZERO id -> bot.



Proof.

intros X A a H; apply H.

intros b' H1 H2; exact H1.

Qed.



Definition SUCC (X : Typ1) (A : Rel X) (a : X) : Rel (opt X) :=

  fun z' z =>

  forall E : Prop,

  (forall x x' : X,

   eq (opt X) z (some X x) -> eq (opt X) z' (some X x') -> A x' x -> E) ->

  (forall x' : X,

   eq (opt X) z (none X) -> eq (opt X) z' (some X x') -> A x' a -> E) ->

  (eq (opt X) z (none X) -> eq (opt X) z' (some X a) -> E) -> E.



Lemma SUCC_in :

 forall (X : Typ1) (A : Rel X) (a x x' : X),

 A x' x -> SUCC X A a (some X x') (some X x).



Proof

  fun X A a x x' H E H1 _ _ =>

  H1 x x' (eq_refl (opt X) (some X x)) (eq_refl (opt X) (some X x')) H.



Lemma SUCC_rt1 :

 forall (X : Typ1) (A : Rel X) (a x' : X),

 A x' a -> SUCC X A a (some X x') (none X).



Proof

  fun X A a x' H E _ H2 _ =>

  H2 x' (eq_refl (opt X) (none X)) (eq_refl (opt X) (some X x')) H.



Lemma SUCC_rt2 :

 forall (X : Typ1) (A : Rel X) (a : X), SUCC X A a (some X a) (none X).



Proof

  fun X A a E _ _ H3 =>

  H3 (eq_refl (opt X) (none X)) (eq_refl (opt X) (some X a)).



Lemma SUCC_deloc :

 forall (X : Typ1) (A : Rel X) (a : X),

 deloc X A (opt X) (SUCC X A a) (some X).



Proof.

intros X A a; unfold deloc in |- *; apply and_intro.



intros; apply SUCC_in; assumption.



intros x y' H; apply H; clear H.



intros x0 x' H1 H2 H3; apply ex2_intro with x'.

apply (eq_sym _ _ _ (eq_some_some X x x0 H1)); assumption.

assumption.



intros x' H1 H2 H3; apply (eq_some_none _ _ H1).



intros H1 H2; apply (eq_some_none _ _ H1).

Qed.



Lemma SUCC_eqv :

 forall (X : Typ1) (A : Rel X) (a x : X),

 EQV X A x (opt X) (SUCC X A a) (some X x).



Proof.

intros X A a x; apply EQV_deloc; apply SUCC_deloc.

Qed.



Lemma SUCC_intro1 :

 forall (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) (B : Rel Y) (b : Y),

 ELT Y B b X A a -> ELT Y B b (opt X) (SUCC X A a) (none X).



Proof.

intros X A a Y B b H; apply H; clear H; intros a' H1 H2.

apply ELT_intro with (some X a'). apply SUCC_rt1; assumption.

apply EQV_trans with X A a'. assumption. apply SUCC_eqv.

Qed.



Lemma SUCC_intro2 :

 forall (X : Typ1) (A : Rel X) (a : X),

 ELT X A a (opt X) (SUCC X A a) (none X).



Proof.

intros X A a; apply ELT_intro with (some X a).

apply SUCC_rt2. apply SUCC_eqv.

Qed.



Lemma SUCC_elim :

 forall (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) (B : Rel Y) (b : Y),

 ELT Y B b (opt X) (SUCC X A a) (none X) ->

 or (ELT Y B b X A a) (EQV Y B b X A a).



Proof.

intros X A a Y B b H; apply H; clear H.

intros z' H H1; apply H; clear H.



intros x x' H2 H3 H4; apply (eq_none_some _ _ H2).



intros x' H2 H3 H4; apply or_inl; apply ELT_intro with x'.

assumption.

apply EQV_trans with (opt X) (SUCC X A a) (some X x').

apply H3; assumption. apply EQV_sym; apply SUCC_eqv.



intros H2 H3; apply or_inr.

apply EQV_trans with (opt X) (SUCC X A a) (some X a).

apply H3; assumption. apply EQV_sym; apply SUCC_eqv.

Qed.



Lemma successor :

 forall (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) (B : Rel Y) (b : Y),

 iff (ELT Y B b (opt X) (SUCC X A a) (none X))

   (or (ELT Y B b X A a) (EQV Y B b X A a)).



Proof.

intros X A a Y B b; unfold iff in |- *.

apply and_intro; intro H.



apply SUCC_elim; assumption.



apply H; clear H; intro H.

apply SUCC_intro1; assumption.

apply ELT_compat_l with X A a.

assumption. apply SUCC_intro2.

Qed.



Lemma SUCC_compat :

 forall (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) (B : Rel Y) (b : Y),

 EQV X A a Y B b ->

 EQV (opt X) (SUCC X A a) (none X) (opt Y) (SUCC Y B b) (none Y).



Proof.

cut

 (forall (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) (B : Rel Y) (b : Y),

  EQV X A a Y B b ->

  SUB (opt X) (SUCC X A a) (none X) (opt Y) (SUCC Y B b) (none Y)).

intros H X A a Y B b H1; apply extensionality.

apply H; assumption. apply H; apply EQV_sym; assumption.

unfold SUB in |- *; intros X A a Y B b H Z C c H1.

apply (SUCC_elim X A a Z C c H1); clear H1; intro H1.

apply SUCC_intro1; apply ELT_compat_r with X A a; assumption.

apply ELT_compat_l with Y B b.

apply EQV_trans with X A a; assumption.

apply SUCC_intro2.

Qed.



Definition OMEGA : Rel (opt nat) :=

  fun z' z =>

  forall E : Prop,

  (forall n n' : nat,

   eq (opt nat) z (some nat n) ->

   eq (opt nat) z' (some nat n') -> wf_nat n -> wf_nat n' -> lt n' n -> E) ->

  (forall n' : nat,

   eq (opt nat) z (none nat) ->

   eq (opt nat) z' (some nat n') -> wf_nat n' -> E) -> E.



Lemma OMEGA_in :

 forall n : nat,

 wf_nat n ->

 forall m : nat, wf_nat m -> lt n m -> OMEGA (some nat n) (some nat m).



Proof

  fun n Hn m Hm H E H1 _ =>

  H1 m n (eq_refl (opt nat) (some nat m)) (eq_refl (opt nat) (some nat n)) Hm

    Hn H.



Lemma OMEGA_rt : forall n : nat, wf_nat n -> OMEGA (some nat n) (none nat).



Proof

  fun n Hn E _ H2 =>

  H2 n (eq_refl (opt nat) (none nat)) (eq_refl (opt nat) (some nat n)) Hn.



Lemma OMEGA_ZERO : EQV (opt nat) OMEGA (some nat O) unit ZERO id.



Proof.

apply extensionality; unfold SUB in |- *; intros X A a H.



apply H; clear H; intros z H H1; apply H; clear H.



intros n m H2 H3 Hn Hm H4.

generalize (eq_sym _ _ _ (eq_some_some _ _ _ H2)); intro H5.

apply (lt_n_O m (H5 (lt m) H4)).



intros n H2 H3 Hn; apply (eq_some_none _ _ H2).



apply H; clear H; intros u H H1; apply H.

Qed.



Lemma OMEGA_SUCC :

 forall n : nat,

 wf_nat n ->

 EQV (opt nat) OMEGA (some nat (S n)) (opt (opt nat))

   (SUCC (opt nat) OMEGA (some nat n)) (none (opt nat)).



Proof.

intros n Hn; apply extensionality; unfold SUB in |- *; intros X A a H.



apply H; clear H; intros z H H1; apply H; clear H.



intros n0 m H H2 Hn0 Hm H3.

generalize (eq_sym _ _ _ (eq_some_some _ _ _ H)); clear H; intro H.

generalize (H (lt m) H3); clear H H3 Hn0 n0; intro H3.



apply (lt_n_Sm m Hm n Hn H3); clear H3; intro H3.



apply SUCC_intro1; apply ELT_intro with (some nat m).

exact (OMEGA_in m Hm n Hn H3).  apply H2; assumption.



apply ELT_compat_l with (opt nat) OMEGA (some nat n).

apply H3; apply H2; assumption.  apply SUCC_intro2.



intros m H H2 Hm; apply (eq_some_none _ _ H).



apply (SUCC_elim _ _ _ _ _ _ H); clear H; intro H.



apply H; clear H; intros z H H1; apply H; clear H.



intros n0 m H H2 Hn0 Hm H3.

generalize (eq_sym _ _ _ (eq_some_some _ _ _ H)); clear H; intro H.

generalize (H (lt m) H3); clear H H3 Hn0 n0; intro H3.

apply ELT_intro with (some nat m).

exact (OMEGA_in m Hm (S n) (wf_nat_S n Hn) (lt_S m n H3)).

apply H2; assumption.



intros m H H2 Hm; apply (eq_some_none _ _ H).



apply ELT_intro with (some nat n).

exact (OMEGA_in n Hn (S n) (wf_nat_S n Hn) (lt_n_Sn n)).

assumption.

Qed.



Theorem omega_zero : ELT unit ZERO id (opt nat) OMEGA (none nat).



Proof.

apply ELT_intro with (some nat O).

exact (OMEGA_rt O wf_nat_O).

apply EQV_sym; exact OMEGA_ZERO.

Qed.



Theorem omega_succ :

 forall (X : Typ1) (A : Rel X) (a : X),

 ELT X A a (opt nat) OMEGA (none nat) ->

 ELT (opt X) (SUCC X A a) (none X) (opt nat) OMEGA (none nat).



Proof.

intros X A a H; apply H; clear H; intros z H H1; apply H; clear H.



intros n m H H2 Hn Hm H3; apply (eq_none_some _ _ H).



intros n H0 H Hn; apply ELT_intro with (some nat (S n)).

exact (OMEGA_rt (S n) (wf_nat_S n Hn)).

apply

 EQV_trans

  with (opt (opt nat)) (SUCC (opt nat) OMEGA (some nat n)) (none (opt nat)).

apply SUCC_compat; apply H; assumption.

apply EQV_sym; apply OMEGA_SUCC; assumption.

Qed.



Require Import IZF_select.  
(* IZF_select:
Require Import IZF_logic.
Require Import IZF_base.

Definition PRED := forall X : Typ1, Rel X -> X -> Prop.

Definition Compat (P : PRED) : Prop :=
  forall (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) (B : Rel Y) (b : Y),
  EQV X A a Y B b -> P X A a -> P Y B b.

Definition SELECT (X : Typ1) (A : Rel X) (a : X) (P : PRED) : 
  Rel (opt X) :=
  fun z' z : opt X =>
  forall E : Prop,
  (forall x x' : X,
   eq (opt X) z (some X x) -> eq (opt X) z' (some X x') -> A x' x -> E) ->
  (forall x' : X,
   eq (opt X) z' (some X x') ->
   eq (opt X) z (none X) -> A x' a -> P X A x' -> E) -> E.

Lemma SELECT_in :
 forall (X : Typ1) (A : Rel X) (a : X) (P : PRED) (x x' : X),
 A x' x -> SELECT X A a P (some X x') (some X x).

Proof
  fun X A a P x x' H E e _ =>
  e x x' (eq_refl (opt X) (some X x)) (eq_refl (opt X) (some X x')) H.

Lemma SELECT_rt :
 forall (X : Typ1) (A : Rel X) (a : X) (P : PRED) (x' : X),
 A x' a -> P X A x' -> SELECT X A a P (some X x') (none X).

Proof
  fun X A a P x' H1 H2 E _ e =>
  e x' (eq_refl (opt X) (some X x')) (eq_refl (opt X) (none X)) H1 H2.

Lemma SELECT_deloc :
 forall (X : Typ1) (A : Rel X) (a : X) (P : PRED),
 deloc X A (opt X) (SELECT X A a P) (some X).

Lemma SELECT_eqv :
 forall (X : Typ1) (A : Rel X) (a : X) (P : PRED) (x : X),
 EQV X A x (opt X) (SELECT X A a P) (some X x).

Lemma selection_intro :
 forall (X : Typ1) (A : Rel X) (a : X) (P : PRED),
 Compat P ->
 forall (Y : Typ1) (B : Rel Y) (b : Y),
 ELT Y B b X A a -> P Y B b -> ELT Y B b (opt X) (SELECT X A a P) (none X).

Lemma selection_elim :
 forall (X : Typ1) (A : Rel X) (a : X) (P : PRED),
 Compat P ->
 forall (Y : Typ1) (B : Rel Y) (b : Y),
 ELT Y B b (opt X) (SELECT X A a P) (none X) ->
 and (ELT Y B b X A a) (P Y B b).

Theorem selection :
 forall (X : Typ1) (A : Rel X) (a : X) (P : PRED),
 Compat P ->
 forall (Y : Typ1) (B : Rel Y) (b : Y),
 iff (ELT Y B b (opt X) (SELECT X A a P) (none X))
   (and (ELT Y B b X A a) (P Y B b)). *)



Theorem omega_ind

 :

 

 forall P : PRED,

 Compat P ->

 

 P unit ZERO id ->

 
 (forall (X : Typ1) (A : Rel X) (a : X),

  ELT X A a (opt nat) OMEGA (none nat) ->

  P X A a -> P (opt X) (SUCC X A a) (none X)) ->

 

 forall (X : Typ1) (A : Rel X) (a : X),

 ELT X A a (opt nat) OMEGA (none nat) -> P X A a.



Proof.

intros P HP HO HS X A a H; apply H; clear H.

intros z H H1; apply H; clear H.



intros n m H H2 Hn Hm H3; apply (eq_none_some _ _ H).



intros n H0 H Hn; clear H0.

apply (HP _ _ _ _ _ _ (EQV_sym _ _ _ _ _ _ H1)).

apply (eq_sym _ _ _ H); clear H H1 a A X z.



apply (nat_ind' n Hn); clear Hn n.



apply HP with unit ZERO id.

apply EQV_sym; exact OMEGA_ZERO. assumption.



intros n Hn Hind.

apply

 HP with (opt (opt nat)) (SUCC (opt nat) OMEGA (some nat n)) (none (opt nat)).

apply EQV_sym; apply OMEGA_SUCC; assumption.

apply HS. apply ELT_direct; apply OMEGA_rt; assumption.

assumption.

Qed.

