
Require Import IZF_logic.
(* IZF_logic:
Definition Typ2 := Type.
Definition Typ1 : Typ2 := Type. 

Definition Rel (X : Typ1) : Typ1 := X -> X -> Prop.

Definition top : Prop := forall E : Prop, E -> E.

Lemma top_intro : top.
Proof fun E e => e.

Definition bot : Prop := forall E : Prop, E.

Definition and (A B : Prop) : Prop := forall E : Prop, (A -> B -> E) -> E.

Lemma and_intro : forall A B : Prop, A -> B -> and A B.
Proof fun A B a b E f => f a b.

Lemma and_fst : forall A B : Prop, and A B -> A.
Proof fun A B p => p A (fun a _ => a).

Lemma and_snd : forall A B : Prop, and A B -> B.
Proof fun A B p => p B (fun _ b => b).

Definition or (A B : Prop) : Prop :=
  forall E : Prop, (A -> E) -> (B -> E) -> E.

Lemma or_inl : forall A B : Prop, A -> or A B.
Proof fun A B a E f g => f a.

Lemma or_inr : forall A B : Prop, B -> or A B.
Proof fun A B b E f g => g b.

Definition iff (A B : Prop) : Prop := and (A -> B) (B -> A).

Definition ex (X : Typ1) (P : X -> Prop) : Prop :=
  forall E : Prop, (forall x : X, P x -> E) -> E.

Lemma ex_intro : forall (X : Typ1) (P : X -> Prop) (x : X), P x -> ex X P.
Proof fun X P x p E f => f x p.

Definition ex2 (X : Typ1) (P Q : X -> Prop) : Prop :=
  forall E : Prop, (forall x : X, P x -> Q x -> E) -> E.

Lemma ex2_intro :
 forall (X : Typ1) (P Q : X -> Prop) (x : X), P x -> Q x -> ex2 X P Q.
Proof fun X P Q x p q E f => f x p q.

Definition exT (P : Typ1 -> Prop) : Prop :=
  forall E : Prop, (forall X : Typ1, P X -> E) -> E.

Lemma exT_intro : forall (P : Typ1 -> Prop) (X : Typ1), P X -> exT P.
Proof fun P X p E f => f X p.

Definition exG (P : forall X : Typ1, Rel X -> X -> Prop) : Prop :=
  forall E : Prop, (forall (X : Typ1) (A : Rel X) (a : X), P X A a -> E) -> E.

Lemma exG_intro :
 forall (P : forall X : Typ1, Rel X -> X -> Prop) (X : Typ1) 
   (A : Rel X) (a : X), P X A a -> exG P.

Proof fun P X A a p E f => f X A a p.

Definition eq (X : Typ1) (x y : X) : Prop := forall P : X -> Prop, P x -> P y.

Lemma eq_refl : forall (X : Typ1) (x : X), eq X x x.
Proof fun X x P p => p.

Lemma eq_sym : forall (X : Typ1) (x y : X), eq X x y -> eq X y x.
Proof fun X x y e => e (fun z => eq X z x) (eq_refl X x).

Lemma eq_trans :
 forall (X : Typ1) (x y z : X), eq X x y -> eq X y z -> eq X x z.
Proof fun X x y z e1 e2 P p => e2 P (e1 P p).

Definition opt (X : Typ1) : Typ1 := (X -> Prop) -> Prop.
Definition some (X : Typ1) (x : X) : opt X := fun f => f x.
Definition none (X : Typ1) : opt X := fun _ => bot.

Lemma eq_some_some :
 forall (X : Typ1) (x1 x2 : X),
 eq (opt X) (some X x1) (some X x2) -> eq X x1 x2.

Proof fun X x1 x2 e => e (fun z => z (fun x => eq X x1 x)) (eq_refl X x1).

Lemma eq_some_none :
 forall (X : Typ1) (x : X), eq (opt X) (some X x) (none X) -> bot.

Proof fun X x e => e (fun z => z (fun _ => top)) top_intro.

Lemma eq_none_some :
 forall (X : Typ1) (x : X), eq (opt X) (none X) (some X x) -> bot.

Proof
  fun X x e => e (fun z => z (fun _ => top) -> bot) (fun p => p) top_intro.

Definition sum (X Y : Typ1) : Typ1 := (X -> Prop) -> (Y -> Prop) -> Prop.
Definition inl (X Y : Typ1) (x : X) : sum X Y := fun f _ => f x.
Definition inr (X Y : Typ1) (y : Y) : sum X Y := fun _ g => g y.
Definition out (X Y : Typ1) : sum X Y := fun _ _ => bot.

Lemma eq_inl_inl :
 forall (X Y : Typ1) (x1 x2 : X),
 eq (sum X Y) (inl X Y x1) (inl X Y x2) -> eq X x1 x2.

Proof
  fun X Y x1 x2 e =>
  e (fun z => z (fun x => eq X x1 x) (fun _ => bot)) (eq_refl X x1).

Lemma eq_inr_inr :
 forall (X Y : Typ1) (y1 y2 : Y),
 eq (sum X Y) (inr X Y y1) (inr X Y y2) -> eq Y y1 y2.

Proof
  fun X Y y1 y2 e =>
  e (fun z => z (fun _ => bot) (fun y => eq Y y1 y)) (eq_refl Y y1).

Lemma eq_inl_inr :
 forall (X Y : Typ1) (x : X) (y : Y),
 eq (sum X Y) (inl X Y x) (inr X Y y) -> bot.

Proof fun X Y x y e => e (fun z => z (fun _ => top) (fun _ => bot)) top_intro.

Lemma eq_inr_inl :
 forall (X Y : Typ1) (x : X) (y : Y),
 eq (sum X Y) (inr X Y y) (inl X Y x) -> bot.

Proof fun X Y x y e => e (fun z => z (fun _ => bot) (fun _ => top)) top_intro.

Lemma eq_inl_out :
 forall (X Y : Typ1) (x : X), eq (sum X Y) (inl X Y x) (out X Y) -> bot.

Proof fun X Y x e => e (fun z => z (fun _ => top) (fun _ => top)) top_intro.

Lemma eq_out_inl :
 forall (X Y : Typ1) (x : X), eq (sum X Y) (out X Y) (inl X Y x) -> bot.

Proof
  fun X Y x e =>
  e (fun z => z (fun _ => top) (fun _ => top) -> bot) (fun p => p) top_intro.

Lemma eq_inr_out :
 forall (X Y : Typ1) (y : Y), eq (sum X Y) (inr X Y y) (out X Y) -> bot.

Proof fun X Y y e => e (fun z => z (fun _ => top) (fun _ => top)) top_intro.

Lemma eq_out_inr :
 forall (X Y : Typ1) (y : Y), eq (sum X Y) (out X Y) (inr X Y y) -> bot.

Proof
  fun X Y y e =>
  e (fun z => z (fun _ => top) (fun _ => top) -> bot) (fun p => p) top_intro. *)
Require Import IZF_base.
(* IZF_base:
Require Import IZF_logic.

Definition EQV (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) 
  (B : Rel Y) (b : Y) : Prop :=
  forall E : Prop,
  (forall R : X -> Y -> Prop,
   (forall (x x' : X) (y : Y),
    A x' x -> R x y -> ex2 Y (fun y' => B y' y) (fun y' => R x' y')) ->
   (forall (y y' : Y) (x : X),
    B y' y -> R x y -> ex2 X (fun x' => A x' x) (fun x' => R x' y')) ->
   R a b -> E) -> E.

Lemma EQV_intro :
 forall (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) (B : Rel Y) 
   (b : Y) (R : X -> Y -> Prop),
 (forall (x x' : X) (y : Y),
  A x' x -> R x y -> ex2 Y (fun y' => B y' y) (fun y' => R x' y')) ->
 (forall (y y' : Y) (x : X),
  B y' y -> R x y -> ex2 X (fun x' => A x' x) (fun x' => R x' y')) ->
 R a b -> EQV X A a Y B b.

Proof fun X A a Y B b R H1 H2 H3 E e => e R H1 H2 H3.

Lemma EQV_refl : forall (X : Typ1) (A : Rel X) (a : X), EQV X A a X A a.

Lemma EQV_sym :
 forall (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) (B : Rel Y) (b : Y),
 EQV X A a Y B b -> EQV Y B b X A a.

Lemma EQV_trans :
 forall (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) (B : Rel Y) 
   (b : Y) (Z : Typ1) (C : Rel Z) (c : Z),
 EQV X A a Y B b -> EQV Y B b Z C c -> EQV X A a Z C c.

Lemma EQV_shift :
 forall (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) (B : Rel Y) (b : Y),
 EQV X A a Y B b ->
 forall a' : X,
 A a' a -> ex2 Y (fun b' => B b' b) (fun b' => EQV X A a' Y B b').

Definition ELT (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) 
  (B : Rel Y) (b : Y) : Prop :=
  forall E : Prop, (forall b' : Y, B b' b -> EQV X A a Y B b' -> E) -> E.

Lemma ELT_intro :
 forall (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) (B : Rel Y) (b b' : Y),
 B b' b -> EQV X A a Y B b' -> ELT X A a Y B b.

Proof fun X A a Y B b b' H1 H2 E e => e b' H1 H2.

Lemma ELT_direct :
 forall (X : Typ1) (A : Rel X) (a a' : X), A a' a -> ELT X A a' X A a.

Lemma ELT_compat_l :
 forall (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) (B : Rel Y) 
   (b : Y) (Z : Typ1) (C : Rel Z) (c : Z),
 EQV X A a Y B b -> ELT Y B b Z C c -> ELT X A a Z C c.

Lemma ELT_compat_r :
 forall (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) (B : Rel Y) 
   (b : Y) (Z : Typ1) (C : Rel Z) (c : Z),
 ELT X A a Y B b -> EQV Y B b Z C c -> ELT X A a Z C c.

Definition SUB (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) 
  (B : Rel Y) (b : Y) : Prop :=
  forall (Z : Typ1) (C : Rel Z) (c : Z), ELT Z C c X A a -> ELT Z C c Y B b.

Lemma SUB_refl : forall (X : Typ1) (A : Rel X) (a : X), SUB X A a X A a.

Lemma SUB_trans :
 forall (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) (B : Rel Y) 
   (b : Y) (Z : Typ1) (C : Rel Z) (c : Z),
 SUB X A a Y B b -> SUB Y B b Z C c -> SUB X A a Z C c.

Theorem extensionality :
 forall (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) (B : Rel Y) (b : Y),
 SUB X A a Y B b -> SUB Y B b X A a -> EQV X A a Y B b.

Definition deloc (X : Typ1) (A : Rel X) (Y : Typ1) 
  (B : Rel Y) (f : X -> Y) : Prop :=
  and (forall x x' : X, A x' x -> B (f x') (f x))
    (forall (x : X) (y' : Y),
     B y' (f x) -> ex2 X (fun x' => A x' x) (fun x' => eq Y y' (f x'))).

Lemma EQV_deloc :
 forall (X : Typ1) (A : Rel X) (Y : Typ1) (B : Rel Y) (f : X -> Y),
 deloc X A Y B f -> forall x : X, EQV X A x Y B (f x). *)

Axiom Code : Typ1.  

Axiom eps : (Typ1 -> Prop) -> Code -> Typ1.

Axiom
  choice : forall P : Typ1 -> Prop, exT P -> ex Code (fun c => P (eps P c)).

Definition foo (X Y : Typ1) (Z : X -> Y -> Typ1) : Typ1 :=
  (forall (x : X) (y : Y), Rel (Z x y) -> Z x y -> Prop) -> Prop.

Definition foo_in (X Y : Typ1) (Z : X -> Y -> Typ1) 
  (x : X) (y : Y) (R : Rel (Z x y)) (z : Z x y) : foo X Y Z :=
  fun f => f x y R z.

Definition foo_rt (X Y : Typ1) (Z : X -> Y -> Typ1) : 
  foo X Y Z := fun _ => bot.

Lemma eq_foo_in_rt :
 forall (X Y : Typ1) (Z : X -> Y -> Typ1) (x : X) (y : Y) 
   (R : Rel (Z x y)) (z : Z x y),
 eq (foo X Y Z) (foo_in X Y Z x y R z) (foo_rt X Y Z) -> bot.

Proof fun X Y Z x y R z e => e (fun u => u (fun _ _ _ _ => top)) top_intro.

Lemma eq_foo_rt_in :
 forall (X Y : Typ1) (Z : X -> Y -> Typ1) (x : X) (y : Y) 
   (R : Rel (Z x y)) (z : Z x y),
 eq (foo X Y Z) (foo_rt X Y Z) (foo_in X Y Z x y R z) -> bot.

Proof
  fun X Y Z x y R z e =>
  e (fun u => u (fun _ _ _ _ => top) -> bot) (fun p => p) top_intro.

Lemma eq_foo_in_in :
 forall (X Y : Typ1) (Z : X -> Y -> Typ1) (x1 x2 : X) 
   (y1 y2 : Y) (R1 : Rel (Z x1 y1)) (R2 : Rel (Z x2 y2)) 
   (z1 : Z x1 y1) (z2 : Z x2 y2),
 
 eq (foo X Y Z) (foo_in X Y Z x1 y1 R1 z1) (foo_in X Y Z x2 y2 R2 z2)
 
  ->
 forall P : forall (x : X) (y : Y), Rel (Z x y) -> Z x y -> Prop,
 P x1 y1 R1 z1 -> P x2 y2 R2 z2.

Proof fun X Y Z x1 x2 y1 y2 R1 R2 z1 z2 H P p => H (fun f => f P) p.

Definition FOO (X Y : Typ1) (Z : X -> Y -> Typ1) (u' u : foo X Y Z) : Prop :=
  forall E : Prop,
  (forall (x : X) (y : Y) (R : Rel (Z x y)) (z' z : Z x y),
   eq (foo X Y Z) u' (foo_in X Y Z x y R z') ->
   eq (foo X Y Z) u (foo_in X Y Z x y R z) -> R z' z -> E) ->
  (forall (x : X) (y : Y) (R : Rel (Z x y)) (z' : Z x y),
   eq (foo X Y Z) u' (foo_in X Y Z x y R z') ->
   eq (foo X Y Z) u (foo_rt X Y Z) -> E) -> E.

Lemma FOO_in :
 forall (X Y : Typ1) (Z : X -> Y -> Typ1) (x : X) (y : Y) 
   (R : Rel (Z x y)) (z' z : Z x y),
 R z' z -> FOO X Y Z (foo_in X Y Z x y R z') (foo_in X Y Z x y R z).

Proof
  fun X Y Z x y R z' z H E H1 H2 =>
  H1 x y R z' z (eq_refl (foo X Y Z) (foo_in X Y Z x y R z'))
    (eq_refl (foo X Y Z) (foo_in X Y Z x y R z)) H.

Lemma FOO_rt :
 forall (X Y : Typ1) (Z : X -> Y -> Typ1) (x : X) (y : Y) 
   (R : Rel (Z x y)) (z' : Z x y),
 FOO X Y Z (foo_in X Y Z x y R z') (foo_rt X Y Z).

Proof
  fun X Y Z x y R z' E H1 H2 =>
  H2 x y R z' (eq_refl (foo X Y Z) (foo_in X Y Z x y R z'))
    (eq_refl (foo X Y Z) (foo_rt X Y Z)).

Lemma FOO_deloc :
 forall (X Y : Typ1) (Z : X -> Y -> Typ1) (x : X) (y : Y) (R : Rel (Z x y)),
 deloc (Z x y) R (foo X Y Z) (FOO X Y Z) (foo_in X Y Z x y R).

Proof.
intros X Y Z x y R; unfold deloc in |- *; apply and_intro.

intros; apply FOO_in; assumption.

intros z f' H; apply H; clear H.

intros x0 y0 R0 z0' z0 H2 H3 H4; apply (eq_sym _ _ _ H2).
generalize z0' H4; clear H2 H4 f' z0'.

apply (eq_foo_in_in X Y Z x x0 y y0 R R0 z z0 H3).
intros z' H4; apply ex2_intro with z'.
assumption. apply eq_refl.

intros x0 y0 R0 z0' H1 H2; apply (eq_foo_in_rt _ _ _ _ _ _ _ H2).
Qed.

Lemma FOO_eqv :
 forall (X Y : Typ1) (Z : X -> Y -> Typ1) (x : X) (y : Y) 
   (R : Rel (Z x y)) (z : Z x y),
 EQV (Z x y) R z (foo X Y Z) (FOO X Y Z) (foo_in X Y Z x y R z).

Proof.
intros; apply EQV_deloc; apply FOO_deloc.
Qed.

Lemma FOO_elt :
 forall (X Y : Typ1) (Z : X -> Y -> Prop) (x : X) (y : Y) 
   (R : Rel (Z x y)) (z : Z x y),
 ELT (Z x y) R z (foo X Y Z) (FOO X Y Z) (foo_rt X Y Z).

Proof.
intros X Y Z x y R z.
apply ELT_intro with (foo_in X Y Z x y R z).
apply FOO_rt.  apply FOO_eqv.
Qed.

Definition REL : Typ2 :=
  forall X : Typ1, Rel X -> X -> forall Y : Typ1, Rel Y -> Y -> Prop.

Definition LCOMPAT (R : REL) : Prop :=
  forall (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) 
    (B : Rel Y) (b : Y) (Z : Typ1) (C : Rel Z) (c : Z),
  EQV X A a Y B b -> R Y B b Z C c -> R X A a Z C c.

Definition RCOMPAT (R : REL) : Prop :=
  forall (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) 
    (B : Rel Y) (b : Y) (Z : Typ1) (C : Rel Z) (c : Z),
  R X A a Y B b -> EQV Y B b Z C c -> R X A a Z C c.

Definition exG_rel (X : Typ1) (A : Rel X) (a : X)
  (P : forall Y : Typ1, Rel Y -> Y -> Prop) :=
  forall E : Prop,
  (forall (Y : Typ1) (B : Rel Y) (b : Y), ELT Y B b X A a -> P Y B b -> E) ->
  E.

Lemma exG_rel_intro :
 forall (X : Typ1) (A : Rel X) (a : X)
   (P : forall Y : Typ1, Rel Y -> Y -> Prop) (Y : Typ1) 
   (B : Rel Y) (b : Y), ELT Y B b X A a -> P Y B b -> exG_rel X A a P.

Proof fun X A a P Y B b H1 H2 E f => f Y B b H1 H2.

Definition coll_fam (X : Typ1) (A : Rel X) (a : X) 
  (R : REL) (x : X) : Code -> Typ1 :=
  eps (fun Y => ex (Rel Y) (fun B => ex Y (fun b => R X A x Y B b))).

Definition coll (X : Typ1) (A : Rel X) (a : X) (R : REL) : Typ1 :=
  foo X Code (coll_fam X A a R).

Definition COLL (X : Typ1) (A : Rel X) (a : X) (R : REL) :
  Rel (coll X A a R) := FOO X Code (coll_fam X A a R).

Definition coll_rt (X : Typ1) (A : Rel X) (a : X) (R : REL) : 
  coll X A a R := foo_rt X Code (coll_fam X A a R).

Theorem collection :
 forall (X : Typ1) (A : Rel X) (a : X) (R : REL),
 LCOMPAT R ->
 RCOMPAT R ->
 (forall (X' : Typ1) (A' : Rel X') (a' : X'),
  ELT X' A' a' X A a -> exG (fun Y' B' b' => R X' A' a' Y' B' b')) ->
 forall (X' : Typ1) (A' : Rel X') (a' : X'),
 ELT X' A' a' X A a ->
 exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)
   (fun Y' B' b' => R X' A' a' Y' B' b').

Proof.
intros X A a R HL HR H0 X' A' a' H1.
apply H1; clear H1; intros x H1 H2.

cut (exT (fun Y => ex (Rel Y) (fun B => ex Y (fun b => R X A x Y B b)))).

intro H; apply (choice _ H); clear H; intros c H.
apply H; clear H; intros B H; change (Rel (coll_fam X A a R x c)) in B.
apply H; clear H; intros b H3; change (coll_fam X A a R x c) in b.
change (R X A x (coll_fam X A a R x c) B b) in H3.
apply exG_rel_intro with (coll_fam X A a R x c) B b.
apply ELT_intro with (foo_in X Code (coll_fam X A a R) x c B b).
unfold COLL, coll_rt in |- *; apply FOO_rt.
unfold coll, COLL in |- *; apply FOO_eqv.
apply HL with X A x; assumption.

apply (H0 X A x (ELT_direct X A a x H1)); intros Y B b H3.
apply exT_intro with Y.
apply ex_intro with B.
apply ex_intro with b.
assumption.
Qed.

Theorem collection2 :
 forall (X : Typ1) (A : Rel X) (a : X) (R : REL),
 LCOMPAT R ->
 RCOMPAT R ->
 forall (X' : Typ1) (A' : Rel X') (a' : X'),
 ELT X' A' a' X A a ->
 exG (fun Y' B' b' => R X' A' a' Y' B' b') ->
 exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)
   (fun Y' B' b' => R X' A' a' Y' B' b').

Proof.
intros X A a R HL HR X' A' a' H H1.
apply H; clear H; intros x H2 H3.

cut (exT (fun Y => ex (Rel Y) (fun B => ex Y (fun b => R X A x Y B b)))).

intro H; apply (choice _ H); clear H; intros c H.
apply H; clear H; intros B H; change (Rel (coll_fam X A a R x c)) in B.
apply H; clear H; intros b H4; change (coll_fam X A a R x c) in b.
change (R X A x (coll_fam X A a R x c) B b) in H4.
apply exG_rel_intro with (coll_fam X A a R x c) B b.
apply ELT_intro with (foo_in X Code (coll_fam X A a R) x c B b).
unfold COLL, coll_rt in |- *; apply FOO_rt.
unfold coll, COLL in |- *; apply FOO_eqv.
apply HL with X A x; assumption.

apply H1; clear H1; intros Y B b H1.
apply exT_intro with Y.
apply ex_intro with B.
apply ex_intro with b.
apply HL with X' A' a'.
apply EQV_sym; assumption. 
assumption.
Qed.
