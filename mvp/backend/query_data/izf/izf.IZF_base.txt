

Require Import IZF_logic.
(* IZF_logic:
Definition Typ2 := Type.
Definition Typ1 : Typ2 := Type. 

Definition Rel (X : Typ1) : Typ1 := X -> X -> Prop.

Definition top : Prop := forall E : Prop, E -> E.

Lemma top_intro : top.
Proof fun E e => e.

Definition bot : Prop := forall E : Prop, E.

Definition and (A B : Prop) : Prop := forall E : Prop, (A -> B -> E) -> E.

Lemma and_intro : forall A B : Prop, A -> B -> and A B.
Proof fun A B a b E f => f a b.

Lemma and_fst : forall A B : Prop, and A B -> A.
Proof fun A B p => p A (fun a _ => a).

Lemma and_snd : forall A B : Prop, and A B -> B.
Proof fun A B p => p B (fun _ b => b).

Definition or (A B : Prop) : Prop :=
  forall E : Prop, (A -> E) -> (B -> E) -> E.

Lemma or_inl : forall A B : Prop, A -> or A B.
Proof fun A B a E f g => f a.

Lemma or_inr : forall A B : Prop, B -> or A B.
Proof fun A B b E f g => g b.

Definition iff (A B : Prop) : Prop := and (A -> B) (B -> A).

Definition ex (X : Typ1) (P : X -> Prop) : Prop :=
  forall E : Prop, (forall x : X, P x -> E) -> E.

Lemma ex_intro : forall (X : Typ1) (P : X -> Prop) (x : X), P x -> ex X P.
Proof fun X P x p E f => f x p.

Definition ex2 (X : Typ1) (P Q : X -> Prop) : Prop :=
  forall E : Prop, (forall x : X, P x -> Q x -> E) -> E.

Lemma ex2_intro :
 forall (X : Typ1) (P Q : X -> Prop) (x : X), P x -> Q x -> ex2 X P Q.
Proof fun X P Q x p q E f => f x p q.

Definition exT (P : Typ1 -> Prop) : Prop :=
  forall E : Prop, (forall X : Typ1, P X -> E) -> E.

Lemma exT_intro : forall (P : Typ1 -> Prop) (X : Typ1), P X -> exT P.
Proof fun P X p E f => f X p.

Definition exG (P : forall X : Typ1, Rel X -> X -> Prop) : Prop :=
  forall E : Prop, (forall (X : Typ1) (A : Rel X) (a : X), P X A a -> E) -> E.

Lemma exG_intro :
 forall (P : forall X : Typ1, Rel X -> X -> Prop) (X : Typ1) 
   (A : Rel X) (a : X), P X A a -> exG P.

Proof fun P X A a p E f => f X A a p.

Definition eq (X : Typ1) (x y : X) : Prop := forall P : X -> Prop, P x -> P y.

Lemma eq_refl : forall (X : Typ1) (x : X), eq X x x.
Proof fun X x P p => p.

Lemma eq_sym : forall (X : Typ1) (x y : X), eq X x y -> eq X y x.
Proof fun X x y e => e (fun z => eq X z x) (eq_refl X x).

Lemma eq_trans :
 forall (X : Typ1) (x y z : X), eq X x y -> eq X y z -> eq X x z.
Proof fun X x y z e1 e2 P p => e2 P (e1 P p).

Definition opt (X : Typ1) : Typ1 := (X -> Prop) -> Prop.
Definition some (X : Typ1) (x : X) : opt X := fun f => f x.
Definition none (X : Typ1) : opt X := fun _ => bot.

Lemma eq_some_some :
 forall (X : Typ1) (x1 x2 : X),
 eq (opt X) (some X x1) (some X x2) -> eq X x1 x2.

Proof fun X x1 x2 e => e (fun z => z (fun x => eq X x1 x)) (eq_refl X x1).

Lemma eq_some_none :
 forall (X : Typ1) (x : X), eq (opt X) (some X x) (none X) -> bot.

Proof fun X x e => e (fun z => z (fun _ => top)) top_intro.

Lemma eq_none_some :
 forall (X : Typ1) (x : X), eq (opt X) (none X) (some X x) -> bot.

Proof
  fun X x e => e (fun z => z (fun _ => top) -> bot) (fun p => p) top_intro.

Definition sum (X Y : Typ1) : Typ1 := (X -> Prop) -> (Y -> Prop) -> Prop.
Definition inl (X Y : Typ1) (x : X) : sum X Y := fun f _ => f x.
Definition inr (X Y : Typ1) (y : Y) : sum X Y := fun _ g => g y.
Definition out (X Y : Typ1) : sum X Y := fun _ _ => bot.

Lemma eq_inl_inl :
 forall (X Y : Typ1) (x1 x2 : X),
 eq (sum X Y) (inl X Y x1) (inl X Y x2) -> eq X x1 x2.

Proof
  fun X Y x1 x2 e =>
  e (fun z => z (fun x => eq X x1 x) (fun _ => bot)) (eq_refl X x1).

Lemma eq_inr_inr :
 forall (X Y : Typ1) (y1 y2 : Y),
 eq (sum X Y) (inr X Y y1) (inr X Y y2) -> eq Y y1 y2.

Proof
  fun X Y y1 y2 e =>
  e (fun z => z (fun _ => bot) (fun y => eq Y y1 y)) (eq_refl Y y1).

Lemma eq_inl_inr :
 forall (X Y : Typ1) (x : X) (y : Y),
 eq (sum X Y) (inl X Y x) (inr X Y y) -> bot.

Proof fun X Y x y e => e (fun z => z (fun _ => top) (fun _ => bot)) top_intro.

Lemma eq_inr_inl :
 forall (X Y : Typ1) (x : X) (y : Y),
 eq (sum X Y) (inr X Y y) (inl X Y x) -> bot.

Proof fun X Y x y e => e (fun z => z (fun _ => bot) (fun _ => top)) top_intro.

Lemma eq_inl_out :
 forall (X Y : Typ1) (x : X), eq (sum X Y) (inl X Y x) (out X Y) -> bot.

Proof fun X Y x e => e (fun z => z (fun _ => top) (fun _ => top)) top_intro.

Lemma eq_out_inl :
 forall (X Y : Typ1) (x : X), eq (sum X Y) (out X Y) (inl X Y x) -> bot.

Proof
  fun X Y x e =>
  e (fun z => z (fun _ => top) (fun _ => top) -> bot) (fun p => p) top_intro.

Lemma eq_inr_out :
 forall (X Y : Typ1) (y : Y), eq (sum X Y) (inr X Y y) (out X Y) -> bot.

Proof fun X Y y e => e (fun z => z (fun _ => top) (fun _ => top)) top_intro.

Lemma eq_out_inr :
 forall (X Y : Typ1) (y : Y), eq (sum X Y) (out X Y) (inr X Y y) -> bot.

Proof
  fun X Y y e =>
  e (fun z => z (fun _ => top) (fun _ => top) -> bot) (fun p => p) top_intro. *)



Definition EQV (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) 

  (B : Rel Y) (b : Y) : Prop :=

  forall E : Prop,

  (forall R : X -> Y -> Prop,

   (forall (x x' : X) (y : Y),

    A x' x -> R x y -> ex2 Y (fun y' => B y' y) (fun y' => R x' y')) ->

   (forall (y y' : Y) (x : X),

    B y' y -> R x y -> ex2 X (fun x' => A x' x) (fun x' => R x' y')) ->

   R a b -> E) -> E.



Lemma EQV_intro :

 forall (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) (B : Rel Y) 

   (b : Y) (R : X -> Y -> Prop),

 (forall (x x' : X) (y : Y),

  A x' x -> R x y -> ex2 Y (fun y' => B y' y) (fun y' => R x' y')) ->

 (forall (y y' : Y) (x : X),

  B y' y -> R x y -> ex2 X (fun x' => A x' x) (fun x' => R x' y')) ->

 R a b -> EQV X A a Y B b.



Proof fun X A a Y B b R H1 H2 H3 E e => e R H1 H2 H3.



Lemma EQV_refl : forall (X : Typ1) (A : Rel X) (a : X), EQV X A a X A a.



Proof.

intros X A a; apply EQV_intro with (fun x y => eq X x y).



intros x x' y H1 H2; apply ex2_intro with x'.

apply H2; assumption. apply eq_refl.



intros y y' x H1 H2; apply ex2_intro with y'.

apply (eq_sym _ _ _ H2); assumption. apply eq_refl.



apply eq_refl.

Qed.



Lemma EQV_sym :

 forall (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) (B : Rel Y) (b : Y),

 EQV X A a Y B b -> EQV Y B b X A a.



Proof.

intros X A a Y B b H; apply H; clear H; intros R H1 H2 H3.

apply EQV_intro with (fun y x => R x y); assumption.

Qed.



Lemma EQV_trans :

 forall (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) (B : Rel Y) 

   (b : Y) (Z : Typ1) (C : Rel Z) (c : Z),

 EQV X A a Y B b -> EQV Y B b Z C c -> EQV X A a Z C c.



Proof.

intros X A a Y B b Z C c H1 H4.

apply H1; clear H1; intros R H1 H2 H3.

apply H4; clear H4; intros S H4 H5 H6.

apply EQV_intro with (fun x z => ex2 Y (fun y => R x y) (fun y => S y z)).



intros x x' z H7 H; apply H; clear H; intros y H8 H9.

apply (H1 x x' y H7 H8); intros y' H10 H11.

apply (H4 y y' z H10 H9); intros z' H12 H13.

apply ex2_intro with z'. assumption.

apply ex2_intro with y'; assumption.



intros z z' x H7 H; apply H; clear H; intros y H8 H9.

apply (H5 z z' y H7 H9); intros y' H10 H11.

apply (H2 y y' x H10 H8); intros x' H12 H13.

apply ex2_intro with x'. assumption.

apply ex2_intro with y'; assumption.



apply ex2_intro with b; assumption.

Qed.



Lemma EQV_shift :

 forall (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) (B : Rel Y) (b : Y),

 EQV X A a Y B b ->

 forall a' : X,

 A a' a -> ex2 Y (fun b' => B b' b) (fun b' => EQV X A a' Y B b').



Proof.

intros X A a Y B b H; eapply H; clear H; intros R H1 H2 H3.

intros a' H4; apply (H1 a a' b H4 H3); intros b' H5 H6.

apply ex2_intro with b'. assumption.

apply EQV_intro with R; assumption.

Qed.



Definition ELT (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) 

  (B : Rel Y) (b : Y) : Prop :=

  forall E : Prop, (forall b' : Y, B b' b -> EQV X A a Y B b' -> E) -> E.



Lemma ELT_intro :

 forall (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) (B : Rel Y) (b b' : Y),

 B b' b -> EQV X A a Y B b' -> ELT X A a Y B b.



Proof fun X A a Y B b b' H1 H2 E e => e b' H1 H2.



Lemma ELT_direct :

 forall (X : Typ1) (A : Rel X) (a a' : X), A a' a -> ELT X A a' X A a.



Proof.

intros X A a a' H; apply ELT_intro with a'.

assumption.  apply EQV_refl.

Qed.



Lemma ELT_compat_l :

 forall (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) (B : Rel Y) 

   (b : Y) (Z : Typ1) (C : Rel Z) (c : Z),

 EQV X A a Y B b -> ELT Y B b Z C c -> ELT X A a Z C c.



Proof.

intros X A a Y B b Z C c H1 H.

apply H; clear H; intros c' H2 H3.

apply ELT_intro with c'.  assumption.

apply EQV_trans with Y B b; assumption.

Qed.



Lemma ELT_compat_r :

 forall (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) (B : Rel Y) 

   (b : Y) (Z : Typ1) (C : Rel Z) (c : Z),

 ELT X A a Y B b -> EQV Y B b Z C c -> ELT X A a Z C c.



Proof.

intros X A a Y B b Z C c H.

eapply H; clear H; intros b' H1 H2 H3.

apply (EQV_shift _ _ _ _ _ _ H3 b' H1); intros c' H4 H5.

apply ELT_intro with c'.  assumption.

apply EQV_trans with Y B b'; assumption.

Qed.



Definition SUB (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) 

  (B : Rel Y) (b : Y) : Prop :=

  forall (Z : Typ1) (C : Rel Z) (c : Z), ELT Z C c X A a -> ELT Z C c Y B b.



Lemma SUB_refl : forall (X : Typ1) (A : Rel X) (a : X), SUB X A a X A a.



Proof.

unfold SUB in |- *; auto.

Qed.



Lemma SUB_trans :

 forall (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) (B : Rel Y) 

   (b : Y) (Z : Typ1) (C : Rel Z) (c : Z),

 SUB X A a Y B b -> SUB Y B b Z C c -> SUB X A a Z C c.



Proof.

unfold SUB in |- *; auto.

Qed.



Theorem extensionality :

 forall (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) (B : Rel Y) (b : Y),

 SUB X A a Y B b -> SUB Y B b X A a -> EQV X A a Y B b.



Proof.

intros X A a Y B b H1 H2.



apply

 EQV_intro with (fun x y => or (and (eq X x a) (eq Y y b)) (EQV X A x Y B y)).



intros x x' y H3 H4; apply H4; clear H4; intro H4.



apply H4; clear H4; intros H4 H5.

generalize (ELT_direct X A x x' H3); eapply (eq_sym _ _ _ H4).

intro H6; apply (H1 _ _ _ H6); intros y' H7 H8.

apply ex2_intro with y'.

apply (eq_sym _ _ _ H5); assumption.

apply or_inr; assumption.



apply (EQV_shift _ _ _ _ _ _ H4 x' H3).

intros y' H5 H6; apply ex2_intro with y'.

assumption.  apply or_inr; assumption.



intros y y' x H3 H4; apply H4; clear H4; intro H4.



apply H4; clear H4; intros H4 H5.

generalize (ELT_direct Y B y y' H3); eapply (eq_sym _ _ _ H5).

intro H6; apply (H2 _ _ _ H6); intros x' H7 H8.

apply ex2_intro with x'.

apply (eq_sym _ _ _ H4); assumption.

apply or_inr; apply EQV_sym; assumption.



apply (EQV_shift _ _ _ _ _ _ (EQV_sym _ _ _ _ _ _ H4) y' H3).

intros x' H5 H6; apply ex2_intro with x'.

assumption.  apply or_inr; apply EQV_sym; assumption.



apply or_inl; apply and_intro; apply eq_refl.

Qed.



Definition deloc (X : Typ1) (A : Rel X) (Y : Typ1) 

  (B : Rel Y) (f : X -> Y) : Prop :=

  and (forall x x' : X, A x' x -> B (f x') (f x))

    (forall (x : X) (y' : Y),

     B y' (f x) -> ex2 X (fun x' => A x' x) (fun x' => eq Y y' (f x'))).



Lemma EQV_deloc :

 forall (X : Typ1) (A : Rel X) (Y : Typ1) (B : Rel Y) (f : X -> Y),

 deloc X A Y B f -> forall x : X, EQV X A x Y B (f x).



Proof.

intros X A Y B f H.  eapply H; clear H; intros H1 H2 x0.

apply EQV_intro with (fun x y => eq Y y (f x)).



intros x x' y H3 H4; apply ex2_intro with (f x').

apply (eq_sym _ _ _ H4); apply H1; assumption.

apply eq_refl.



intros y y' x H3 H4.

exact (H2 x y' (H4 (B y') H3)).



apply eq_refl.

Qed.

