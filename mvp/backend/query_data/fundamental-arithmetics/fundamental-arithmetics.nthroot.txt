

Require Import missing.
(* missing:
Require Export Arith.
Require Export ArithRing.
Require Export Omega.

Unset Standard Proposition Elimination Names.

Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).

Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\/(m=O).

Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).

Lemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \/ m=1.

Lemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\(m=1).

Lemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).

Lemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.

Lemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).

Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).

Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.

Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).

Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).

Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).

Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).

Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).

Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a). *)

Require Import division.
(* division:
Require Import missing.
Require Import Wf_nat.

Definition divides (a b:nat) := exists q:nat,a = (b*q).

Lemma one_min_div : forall (n:nat),(divides n 1).

Lemma zero_max_div : forall (n:nat),(divides O n).

Lemma divides_refl : forall (a:nat),(divides a a).

Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).

Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.

Lemma non_div_1 : forall (a:nat),(a<>1)->~(divides 1 a).

Lemma divides_plus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (plus a b) d).

Lemma divides_mult : forall (d a b:nat),(divides a d)->(divides (a*b) d).

Lemma divides_minus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (b-a) d).

Lemma quo_dec : forall (a b:nat),(divides a b)->{q:nat | a=b*q}.

Definition quo (a b:nat) (H:(divides a b)) := let (q,_):=(quo_dec a b H) in q.

Lemma quo_is_quo : forall (a b:nat)(H:divides a b),a=(mult b (quo a b H)).

Lemma quo_mult : forall (a b:nat)(H:divides a b),forall (n:nat),(b<>O)->(quo (a*n) b (divides_mult b a n H))=n*(quo a b H). *)

Require Import gcd.
(* gcd:
Require Import missing.
Require Import division.
Require Import euclide.
Require Import power.
Require Import Wf_nat.

Unset Standard Proposition Elimination Names.

Definition is_cd (d a b : nat) := (divides a d)/\(divides b d).

Definition is_gcd (d a b:nat) := (is_cd d a b)/\(forall (d':nat),(is_cd d' a b)->(divides d d')).

Theorem gcd_unique : forall (d d' a b:nat),(is_gcd d a b)->(is_gcd d' a b)->d=d'.

Lemma gcd_sym : forall (d a b:nat),(is_gcd d a b)->(is_gcd d b a).

Lemma gcd_zero : forall (a:nat),(is_gcd a O a).

Lemma gcd_one : forall (a:nat),(is_gcd 1 1 a).

Lemma gcd_minus : forall (d a b:nat),(a <= b)->((is_gcd d a b)<->(is_gcd d a (b-a))).

Lemma gcd_refl : forall (a:nat),(is_gcd a a a).

Lemma gcd_div_l : forall (d a b:nat),(is_gcd d a b)->(divides a d).

Lemma gcd_div_r : forall (d a b:nat),(is_gcd d a b)->(divides b d).

Definition f (x:nat*nat) := (fst x)+(snd x).

Definition R (x y:nat*nat) := (f x)<(f y).

Lemma Rwf : well_founded R.

Lemma gcd_exists_prod : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.

Theorem gcd_exists : forall (a b:nat),{d:nat | (is_gcd d a b)}.

Definition gcd (a b:nat) := let (d,_):=(gcd_exists a b) in d.

Lemma gcd_is_gcd : forall (a b:nat),(is_gcd (gcd a b) a b).

Definition rel_prime (a b:nat) := (is_gcd 1 a b). 

Lemma rel_prime_sym : forall (a b:nat),(rel_prime a b)->(rel_prime b a).

Lemma rel_prime_1 : forall (a:nat),(rel_prime a 1).

Lemma gcd_rel_prime : forall (d a b:nat)(H:(is_gcd d a b)),(d <> O)->(rel_prime (quo a d (gcd_div_l d a b H)) (quo b d (gcd_div_r d a b H))).

Lemma gcd_non_zero : forall (d p q:nat),(q<>O)->(is_gcd d p q)->(d<>O).

Lemma bezout_aux1 : forall (x y u v:nat),(x<=y)->(is_gcd (u*x-v*(y-x)) x (y-x))->(is_gcd ((u+v)*x-v*y) x y).

Lemma bezout_aux2 : forall (x y u v:nat),(x<=y)->(is_gcd (v*(y-x)-u*x) x (y-x))->(is_gcd (v*y-(u+v)*x) x y).

Lemma bezout_exists_prod : forall (x:nat*nat),{y:nat*nat | (is_gcd ((fst y)*(fst x)-(snd y)*(snd x)) (fst x) (snd x))}+{y:nat*nat | (is_gcd ((snd y)*(snd x)-(fst y)*(fst x)) (fst x) (snd x))}.

Theorem bezout_exists : forall (a b:nat),{u:nat & {v:nat | (is_gcd (a*u-b*v) a b)}}+{u:nat & {v:nat | (is_gcd (b*v-a*u) a b)}}.

Theorem bezout : forall (d a b:nat),(is_gcd d a b)->exists u:nat,exists v:nat,d=a*u-b*v \/ d=b*v-a*u.

Theorem bezout_rel_prime : forall (a b:nat),(rel_prime a b)<->(exists u:nat, exists v:nat, 1=a*u-b*v \/ 1 = b*v-a*u).

Lemma gcd_mult : forall (d a b:nat),(is_gcd d a b)->(forall (n:nat),(is_gcd (n*d) (n*a) (n*b))).

Theorem gauss : forall (d a b:nat),(rel_prime a d)->(divides (a*b) d)->(divides b d).

Lemma gcd_euclide : forall (d a b:nat)(H:(b<>0)),(is_gcd d a b)<->(is_gcd d b (remainder_euclide a b H)).

Lemma gcd_exists_prod_bis : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.

Theorem gcd_exists_bis : forall (a b:nat),{d:nat | (is_gcd d a b)}.

Lemma rel_prime_dec : forall (a b:nat),{rel_prime a b}+{~(rel_prime a b)}.

Lemma rel_prime_mult : forall (a b c:nat),(rel_prime a b)->(rel_prime a c)->(rel_prime a (b*c)).

Lemma mult_rel_prime : forall (a b c:nat),(rel_prime a (b*c))->((rel_prime a b)/\(rel_prime a c)).

Lemma rel_prime_power : forall (d a n:nat),(rel_prime a d)->(rel_prime a (power d n)).

Lemma power_rel_prime : forall (d a n:nat),(n>0)->(rel_prime a (power d n))->(rel_prime a d).

Lemma power_power_rel_prime : forall (a n b m:nat),(n>0)->(m>0)->((rel_prime (power a n) (power b m))<->(rel_prime a b)). *)

Require Import primes.
(* primes:
Require Import missing.
Require Import division.
Require Import euclide.
Require Import gcd.
Require Import power.
Require Import permutation.
Require Import Wf_nat.

Unset Standard Proposition Elimination Names.

Definition is_prime (p:nat) := (p<>1)/\(forall (d:nat),(divides p d)->(d=1)\/(d=p)).

Lemma not_prime_zero : ~(is_prime O).

Lemma is_prime_2 : (is_prime 2).

Lemma prime_div_gcd : forall (p a:nat),(is_prime p)->~(divides a p)->(rel_prime p a).

Lemma prime_gcd : forall (d p a:nat),(is_prime p)->(is_gcd d a p)->(d=1)\/(d=p).

Lemma prime_rel_prime : forall (p a:nat),(is_prime p)->~(rel_prime a p)->(divides a p).

Lemma prime_mult : forall (p a b:nat),(is_prime p)->(divides (a*b) p)->((divides a p)\/(divides b p)).

Lemma prime_square : forall (p a:nat),(is_prime p)->(divides (square a) p)->(divides a p).

Lemma prime_power : forall (p n x:nat),(is_prime p)->(divides (power x n) p)->(divides x p).

Lemma prime_power_qn : forall (p n q x:nat),(is_prime p)->(divides (power x n) (power p (q*n)))->(1<=n)->(divides x (power p q)).

Lemma divides_prime : forall (a:nat),(exists p:nat,(p<>a)/\(is_prime p)/\(divides a p)) -> ~(is_prime a).

Lemma gcd_prime : forall (p:nat),(p<>1)->(forall (d a:nat),(is_gcd d a p)->(d=1)\/(d=p))->(is_prime p).

Lemma prime_cond : forall (p:nat),((p<>1)/\(forall (a:nat),(a<>1)->(a<>p)->~(divides p a))<->(is_prime p)).

Lemma prime_dec : forall (n:nat),{is_prime n}+{~(is_prime n)}.

Lemma not_prime_impl_prime_divides : forall (n:nat),(~(is_prime n)->({p:nat | (is_prime p)/\(divides n p)}+{n=1})).

Lemma nat_factor : forall (n p:nat),(is_prime p)->(n<>0)->{m:nat | (divides n (power p m))/\~(divides n (power p (m+1)))}.

Lemma nat_factor_prime : forall (n:nat),(n<>0)->(n<>1)->{p:nat & {m:nat & {q:nat | (is_prime p)/\(m>0)/\(n=(power p m)*q)/\(is_gcd 1 p q)/\(q<n)}}}.

Fixpoint refactor (l:(list (nat*nat))) {struct l} : nat :=
  match l with
    nil => 1
    | (cons (p,n) tail) => (power p n)*(refactor tail)
  end.

Inductive is_wf : (list (nat*nat))->Prop :=
  nil_is_wf : (is_wf nil)
|cons_is_wf : forall (p n:nat)(tail:(list (nat*nat))),(is_prime p)->(n>0)->(is_wf tail)->(rel_prime p (refactor tail))->(is_wf (cons (p,n) tail)).

Lemma factorisation : forall (n:nat),{l:(list (nat*nat)) | (is_wf l)/\n=(refactor l)}+{n=0}.

Lemma factor_divides_refactor : forall (x:nat*nat)(l:list (nat*nat)),(In x l)->(divides (refactor l) (power (fst x) (snd x))).

Lemma prime_divides_refactor : forall (p:nat)(l:list (nat*nat)),(is_prime p)->(is_wf l)->(divides (refactor l) p)->(exists m:nat,(In (p,m) l)).

Lemma in_wf : forall (l:list (nat*nat))(p n:nat),(In (p,n) l)->(is_wf l)->(is_prime p)/\(n>0).

Lemma rel_prime_wf : forall (l:list (nat*nat))(p n q m:nat),(In (p,n) l)->(is_wf ((q,m)::l))->(rel_prime p q).

Inductive is_pwd : list (nat*nat) -> Prop :=
  nil_is_pwd : (is_pwd nil)
|cons_is_pwd : forall (p n:nat)(tail:list (nat*nat)),(is_pwd tail)->(forall (n:nat),~(In (p,n) tail))->(is_pwd ((p,n)::tail)).

Lemma wf_impl_pwd : forall (l:list (nat*nat)),(is_wf l)->(is_pwd l).

Lemma prime_power_divides_refactor : forall (p n m:nat)(l:list (nat*nat)),(is_prime p)->(n>0)->(is_wf l)->(divides (refactor l) (power p n))->(In (p,m) l)->(n<=m).

Lemma factorisation_unique_upto_equiv_aux : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(forall (x n:nat),(In (x,n) l)->(In (x,n) l')).

Lemma pwd_impl_set : forall (l:list (nat*nat)),(is_pwd l)->(is_set (nat*nat) l).

Lemma factorisation_unique_upto_perm : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(is_permutation (nat*nat) l l').

Definition is_factorisation (n:nat)(l:list (nat*nat)) := (is_wf l)/\(n=(refactor l)).

Theorem factorisation_exists : forall (n:nat),n<>0->{l:list (nat*nat) | (is_factorisation n l)}.

Theorem factorisation_unique_upto_permutation : forall (n:nat)(l l':list (nat*nat)),(is_factorisation n l)->(is_factorisation n l')->(is_permutation (nat*nat) l l').

Lemma wf_power_dec : forall (n:nat)(l:list (nat*nat)),(is_wf l)->(n>0)->{x:nat | (refactor l)=(power x n)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\(0<r)/\(r<n)/\(refactor l)=(power p (q*n+r))*k/\(rel_prime p k)}}}}.

Lemma is_power_m_dec : forall (n m:nat),(m>0)->{x:nat | n=(power x m)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\(0<r)/\(r<m)/\n=(power p (q*m+r))*k/\(rel_prime p k)}}}}. *)

Require Import power.
(* power:
Require Import missing.
Require Import division.

Unset Standard Proposition Elimination Names.

Definition square (x:nat) := x*x.

Lemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).

Fixpoint power (x n:nat) {struct n} : nat :=
  match n with
    O => 1
    | (S n) => (x*(power x n))
  end.

Lemma power_mult_lemma1 : forall (n x y:nat),(power (x*y) n)=(power x n)*(power y n).

Lemma power_plus_lemma1 : forall (n m x:nat),(power x (n+m))=(power x n)*(power x m).

Lemma power_divides_lemma1 : forall (n x:nat),(0<n)->(divides (power x n) x).

Lemma power_power_lemma1 : forall (n m x:nat),(power (power x n) m)=(power x (n*m)).

Lemma power_zero : forall (n x:nat),(power x n)=O->x=O.

Lemma power_lt : forall (p m:nat),(1<p)->(0<m)->1<(power p m).

Lemma power_one : forall (n:nat),(power 1 n)=1.

Lemma power_divides_power : forall (x n m:nat),(x>1)->(divides (power x n) (power x m))->(m<=n). *)



Unset Standard Proposition Elimination Names.



Lemma sqrt_prime_irrat_aux : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(rel_prime a b)->(p*k*(square b) <> (square a)).

  intros.

  intro.

  assert (divides a p).

  apply prime_square;trivial.

  exists (k*(square b)).

  rewrite <- H2;ring.

  elim H3;intro n_a;intro.

  rewrite H4 in H2;rewrite square_mult_lemma in H2;unfold square in H2.

  assert (k*(b*b)=p*(n_a*n_a)).

  apply mult_lemma6 with p.

  intro H5;rewrite H5 in H;apply not_prime_zero;trivial.

  rewrite mult_assoc;rewrite H2;ring.

  assert (divides b p).

  apply prime_square;trivial;unfold square.

  apply gauss with k.

  apply rel_prime_sym;trivial.

  exists (n_a*n_a);trivial.

  assert (p=1).

  unfold rel_prime in H1.

  elim H1;intros.

  apply divides_antisym;try (apply one_min_div).

  apply H8;red;tauto.

  elim H;tauto.

Qed.



Theorem sqrt_prime_irrat : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(b<>O)->(p*k*(square b) <> (square a)).

  intros.

  generalize (gcd_is_gcd a b);intro.

  generalize (quo_is_quo a (gcd a b) (gcd_div_l (gcd a b) a b H2));intro.

  generalize (quo_is_quo b (gcd a b) (gcd_div_r (gcd a b) a b H2));intro.

  intro.

  rewrite H3 in H5.

  replace (square b) with (square (gcd a b * quo b (gcd a b) (gcd_div_r (gcd a b) a b H2))) in H5;auto.

  rewrite square_mult_lemma in H5;rewrite square_mult_lemma in H5.

  assert (p*k*(square (quo b (gcd a b) (gcd_div_r (gcd a b) a b H2)))=(square (quo a (gcd a b) (gcd_div_l (gcd a b) a b H2)))).

  apply mult_lemma6 with (square (gcd a b)).

  unfold square.

  generalize (gcd_non_zero (gcd a b) a b H1 H2);intro.

  intro;apply H6.

  case (mult_lemma2 (gcd a b) (gcd a b) H7);trivial.

  rewrite <- H5;ring.

  apply (sqrt_prime_irrat_aux p k (quo a (gcd a b) (gcd_div_l (gcd a b) a b H2)) (quo b (gcd a b) (gcd_div_r (gcd a b) a b H2)));auto.

  apply gcd_rel_prime;apply (gcd_non_zero (gcd a b) a b);trivial.

Qed.



Fact sqrt_prime : forall (p:nat),(is_prime p)->forall (a b:nat),(b<>O)->(p*(square b)<>(square a)).

  intros.

  replace p with (p*1);try (auto with arith).

  apply sqrt_prime_irrat;trivial;apply rel_prime_1.

Qed.



Fact sqrt_2_irrat : forall (p q:nat),(q<>O)->(2*(square q)<>(square p)).

  intros.

  apply sqrt_prime;trivial.

  apply is_prime_2.

Qed.



Lemma nth_root_irrat_aux : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(rel_prime a b)->((power p r)*k*(power b n) <> (power a n)).

  intros.

  intro.

  assert (divides a p).

  apply prime_power with n;trivial.

  generalize (power_divides_lemma1 r p H1);intro.

  elim H5;intro q;intros.

  rewrite H6 in H4.

  rewrite <- H4;exists (q*k*(power b n));ring.

  assert (divides b p).

  elim H5;intro q;intros.

  rewrite H6 in H4.

  rewrite power_mult_lemma1 in H4.

  assert ((power p n)=(power p (r+(n-r)))).

  rewrite <- le_plus_minus;try (auto with arith).

  rewrite H7 in H4;rewrite power_plus_lemma1 in H4.

  assert ((power p r)<>O).

  intro.

  apply not_prime_zero.

  assert (p=O).

  apply power_zero with r;trivial.

  rewrite H9 in H;trivial.

  rewrite <- mult_assoc in H4;rewrite <- mult_assoc in H4;generalize (mult_lemma6 (k*(power b n)) ((power p (n-r))*(power q n)) (power p r) H8 H4);intro.

  assert (divides (power p (n-r)) p).

  apply power_divides_lemma1;apply minus_lt_lemma1;trivial.

  apply prime_power with n;trivial.

  apply gauss with k;try (apply rel_prime_sym;trivial).

  rewrite H9;apply divides_mult;trivial.

  elim H3;intros.

  elim H;intros.

  apply H9;apply divides_antisym;try (apply one_min_div).

  apply H8;red;tauto.

Qed.



Theorem nth_root_irrat : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p r)*k*(power b n) <> (power a n)).

  intros.

  intro.

  generalize (gcd_is_gcd a b);intro.

  generalize (quo_is_quo a (gcd a b) (gcd_div_l (gcd a b) a b H5));intro.

  generalize (quo_is_quo b (gcd a b) (gcd_div_r (gcd a b) a b H5));intro.

  assert ((power a n)=(power (gcd a b * quo a (gcd a b) (gcd_div_l (gcd a b) a b H5)) n));try (rewrite <- H6;trivial).

  assert ((power b n)=(power (gcd a b * quo b (gcd a b) (gcd_div_r (gcd a b) a b H5)) n));try (rewrite <- H7;trivial).

  rewrite power_mult_lemma1 in H8;rewrite H8 in H4.

  rewrite power_mult_lemma1 in H9;rewrite H9 in H4.

  rewrite mult_lemma7 in H4.

  assert ((power (gcd a b) n)<>O).

  intro.

  generalize (power_zero n (gcd a b) H10);intro.

  apply (gcd_non_zero (gcd a b) a b);trivial.

  generalize (mult_lemma6 (power p r * k * power (quo b (gcd a b) (gcd_div_r (gcd a b) a b H5)) n) (power (quo a (gcd a b) (gcd_div_l (gcd a b) a b H5)) n) (power (gcd a b) n) H10 H4).

  fold ((power p r * k * power (quo b (gcd a b) (gcd_div_r (gcd a b) a b H5)) n)<>(power (quo a (gcd a b) (gcd_div_l (gcd a b) a b H5)) n)).

  apply nth_root_irrat_aux;trivial.

  apply gcd_rel_prime;apply (gcd_non_zero (gcd a b) a b);trivial.

Qed.



Theorem nth_root_irrational : forall (p k a b n q r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p (q*n+r))*k*(power b n) <> (power a n)).

  intros.

  intro.

  rewrite power_plus_lemma1 in H4.

  assert (divides a (power p q)).

  apply prime_power_qn with n;try (auto with arith);try omega.

  exists ((power p r)*k*(power b n)).

  rewrite <- H4;ring.

  assert (0<n);try omega.

  elim H5;intro a';intro.

  rewrite H7 in H4.

  rewrite power_mult_lemma1 in H4;rewrite power_power_lemma1 in H4.

  assert ((power p (q*n))<>0).

  intro;apply not_prime_zero;generalize (power_zero (q*n) p H8);intro;rewrite H9 in H;trivial.

  rewrite <- (mult_assoc (power p (q*n))) in H4;rewrite <- (mult_assoc (power p (q*n))) in H4.

  generalize (mult_lemma6 (power p r*k*power b n) (power a' n) (power p (q*n)) H8 H4).

  fold (power p r * k * power b n <> power a' n).

  apply nth_root_irrat;trivial.

Qed.



Theorem nth_root : forall (x n:nat),(n>0)->{y:nat | x=(power y n)}+{forall (a b:nat),(b<>0)->x*(power b n)<>(power a n)}.

  intros.

  case (is_power_m_dec x n H);intro;try tauto.

  elim s;intro p;intro.

  elim p0;intro q;intro.

  elim p1;intro r;intro.

  elim p2;intro k;intro.

  right;intros.

  assert (x=(power p (q*n+r))*k);try tauto.

  rewrite H1;apply nth_root_irrational;tauto.

Qed.

