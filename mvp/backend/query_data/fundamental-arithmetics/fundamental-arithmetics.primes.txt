
Require Import missing.
(* missing:
Require Export Arith.
Require Export ArithRing.
Require Export Omega.

Unset Standard Proposition Elimination Names.

Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).

Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\/(m=O).

Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).

Lemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \/ m=1.

Lemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\(m=1).

Lemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).

Lemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.

Lemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).

Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).

Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.

Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).

Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).

Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).

Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).

Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).

Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a). *)
Require Import division.
(* division:
Require Import missing.
Require Import Wf_nat.

Definition divides (a b:nat) := exists q:nat,a = (b*q).

Lemma one_min_div : forall (n:nat),(divides n 1).

Lemma zero_max_div : forall (n:nat),(divides O n).

Lemma divides_refl : forall (a:nat),(divides a a).

Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).

Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.

Lemma non_div_1 : forall (a:nat),(a<>1)->~(divides 1 a).

Lemma divides_plus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (plus a b) d).

Lemma divides_mult : forall (d a b:nat),(divides a d)->(divides (a*b) d).

Lemma divides_minus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (b-a) d).

Lemma quo_dec : forall (a b:nat),(divides a b)->{q:nat | a=b*q}.

Definition quo (a b:nat) (H:(divides a b)) := let (q,_):=(quo_dec a b H) in q.

Lemma quo_is_quo : forall (a b:nat)(H:divides a b),a=(mult b (quo a b H)).

Lemma quo_mult : forall (a b:nat)(H:divides a b),forall (n:nat),(b<>O)->(quo (a*n) b (divides_mult b a n H))=n*(quo a b H). *)
Require Import euclide.
(* euclide:
Require Import missing.
Require Import division.
Require Import Wf_nat.

Unset Standard Proposition Elimination Names.

Lemma divides_le : forall (a b:nat),(a<>O)->(divides a b)->(b<=a).

Theorem euclide : forall (a b:nat),(b<>O)->{q:nat & { r:nat | (a=b*q+r) /\ (r < b)}}.

Definition quotient_euclide (a b:nat)(H:(b<>O)) := let (q,_) := (euclide a b H) in q.

Definition remainder_euclide (a b:nat)(H:(b<>O)) := let (_,e0) := (euclide a b H) in let (r,_) := e0 in r.

Lemma quo_rem_euclide : forall (a b:nat)(H:(b<>O)),a=b*(quotient_euclide a b H)+(remainder_euclide a b H).

Lemma rem_euclide : forall (a b:nat)(H:(b<>O)),(remainder_euclide a b H)<b.

Lemma euclide_unique : forall (a b q r q' r':nat),(b<>O)->a=b*q+r->a=b*q'+r'->r<b->r'<b->(q=q')/\(r=r').

Lemma divides_euclide : forall (a b:nat)(H:(b<>O)),((divides a b)<->((remainder_euclide a b H)=O)).

Lemma divides_dec : forall (a b:nat),{divides a b}+{~(divides a b)}.

Lemma dec_impl_lt_dec : forall (P:nat->Prop),(forall (n:nat),{(P n)}+{~(P n)})->(forall (m:nat),{n:nat | (n<m)/\(P(n))}+{(forall (n:nat),(n<m)->~(P n))}).

Lemma divides_nat : forall (n:nat),{p:nat | (p<>1)/\(p<>n)/\(divides n p)}+{forall (p:nat),(p<>1)->(p<>n)->~(divides n p)}. *)
Require Import gcd.
(* gcd:
Require Import missing.
Require Import division.
Require Import euclide.
Require Import power.
Require Import Wf_nat.

Unset Standard Proposition Elimination Names.

Definition is_cd (d a b : nat) := (divides a d)/\(divides b d).

Definition is_gcd (d a b:nat) := (is_cd d a b)/\(forall (d':nat),(is_cd d' a b)->(divides d d')).

Theorem gcd_unique : forall (d d' a b:nat),(is_gcd d a b)->(is_gcd d' a b)->d=d'.

Lemma gcd_sym : forall (d a b:nat),(is_gcd d a b)->(is_gcd d b a).

Lemma gcd_zero : forall (a:nat),(is_gcd a O a).

Lemma gcd_one : forall (a:nat),(is_gcd 1 1 a).

Lemma gcd_minus : forall (d a b:nat),(a <= b)->((is_gcd d a b)<->(is_gcd d a (b-a))).

Lemma gcd_refl : forall (a:nat),(is_gcd a a a).

Lemma gcd_div_l : forall (d a b:nat),(is_gcd d a b)->(divides a d).

Lemma gcd_div_r : forall (d a b:nat),(is_gcd d a b)->(divides b d).

Definition f (x:nat*nat) := (fst x)+(snd x).

Definition R (x y:nat*nat) := (f x)<(f y).

Lemma Rwf : well_founded R.

Lemma gcd_exists_prod : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.

Theorem gcd_exists : forall (a b:nat),{d:nat | (is_gcd d a b)}.

Definition gcd (a b:nat) := let (d,_):=(gcd_exists a b) in d.

Lemma gcd_is_gcd : forall (a b:nat),(is_gcd (gcd a b) a b).

Definition rel_prime (a b:nat) := (is_gcd 1 a b). 

Lemma rel_prime_sym : forall (a b:nat),(rel_prime a b)->(rel_prime b a).

Lemma rel_prime_1 : forall (a:nat),(rel_prime a 1).

Lemma gcd_rel_prime : forall (d a b:nat)(H:(is_gcd d a b)),(d <> O)->(rel_prime (quo a d (gcd_div_l d a b H)) (quo b d (gcd_div_r d a b H))).

Lemma gcd_non_zero : forall (d p q:nat),(q<>O)->(is_gcd d p q)->(d<>O).

Lemma bezout_aux1 : forall (x y u v:nat),(x<=y)->(is_gcd (u*x-v*(y-x)) x (y-x))->(is_gcd ((u+v)*x-v*y) x y).

Lemma bezout_aux2 : forall (x y u v:nat),(x<=y)->(is_gcd (v*(y-x)-u*x) x (y-x))->(is_gcd (v*y-(u+v)*x) x y).

Lemma bezout_exists_prod : forall (x:nat*nat),{y:nat*nat | (is_gcd ((fst y)*(fst x)-(snd y)*(snd x)) (fst x) (snd x))}+{y:nat*nat | (is_gcd ((snd y)*(snd x)-(fst y)*(fst x)) (fst x) (snd x))}.

Theorem bezout_exists : forall (a b:nat),{u:nat & {v:nat | (is_gcd (a*u-b*v) a b)}}+{u:nat & {v:nat | (is_gcd (b*v-a*u) a b)}}.

Theorem bezout : forall (d a b:nat),(is_gcd d a b)->exists u:nat,exists v:nat,d=a*u-b*v \/ d=b*v-a*u.

Theorem bezout_rel_prime : forall (a b:nat),(rel_prime a b)<->(exists u:nat, exists v:nat, 1=a*u-b*v \/ 1 = b*v-a*u).

Lemma gcd_mult : forall (d a b:nat),(is_gcd d a b)->(forall (n:nat),(is_gcd (n*d) (n*a) (n*b))).

Theorem gauss : forall (d a b:nat),(rel_prime a d)->(divides (a*b) d)->(divides b d).

Lemma gcd_euclide : forall (d a b:nat)(H:(b<>0)),(is_gcd d a b)<->(is_gcd d b (remainder_euclide a b H)).

Lemma gcd_exists_prod_bis : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.

Theorem gcd_exists_bis : forall (a b:nat),{d:nat | (is_gcd d a b)}.

Lemma rel_prime_dec : forall (a b:nat),{rel_prime a b}+{~(rel_prime a b)}.

Lemma rel_prime_mult : forall (a b c:nat),(rel_prime a b)->(rel_prime a c)->(rel_prime a (b*c)).

Lemma mult_rel_prime : forall (a b c:nat),(rel_prime a (b*c))->((rel_prime a b)/\(rel_prime a c)).

Lemma rel_prime_power : forall (d a n:nat),(rel_prime a d)->(rel_prime a (power d n)).

Lemma power_rel_prime : forall (d a n:nat),(n>0)->(rel_prime a (power d n))->(rel_prime a d).

Lemma power_power_rel_prime : forall (a n b m:nat),(n>0)->(m>0)->((rel_prime (power a n) (power b m))<->(rel_prime a b)). *)
Require Import power.
(* power:
Require Import missing.
Require Import division.

Unset Standard Proposition Elimination Names.

Definition square (x:nat) := x*x.

Lemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).

Fixpoint power (x n:nat) {struct n} : nat :=
  match n with
    O => 1
    | (S n) => (x*(power x n))
  end.

Lemma power_mult_lemma1 : forall (n x y:nat),(power (x*y) n)=(power x n)*(power y n).

Lemma power_plus_lemma1 : forall (n m x:nat),(power x (n+m))=(power x n)*(power x m).

Lemma power_divides_lemma1 : forall (n x:nat),(0<n)->(divides (power x n) x).

Lemma power_power_lemma1 : forall (n m x:nat),(power (power x n) m)=(power x (n*m)).

Lemma power_zero : forall (n x:nat),(power x n)=O->x=O.

Lemma power_lt : forall (p m:nat),(1<p)->(0<m)->1<(power p m).

Lemma power_one : forall (n:nat),(power 1 n)=1.

Lemma power_divides_power : forall (x n m:nat),(x>1)->(divides (power x n) (power x m))->(m<=n). *)
Require Import permutation.
(* permutation:
Require Import Wf_nat.
Require Import missing.
Require Export List Permutation.

Inductive insertion (A:Set) : A -> list A -> list A -> Prop :=
  head_insertion : forall (x:A)(l:list A),(insertion A x l (x::l))
|tail_insertion : forall (x y:A)(l l':list A),(insertion A x l l')->(insertion A x (y::l) (y::l')).

Lemma insertion_snoc : forall (A:Set)(x:A)(xs:list A),(insertion _ x xs (app xs (cons x nil))).

Lemma insertion_in : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->(In x l').

Lemma insertion_inclusion : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->forall (y:A),(In y l)->(In y l').

Lemma in_insertion : forall (A:Set)(x:A)(l:list A),(In x l)->exists l':list A,(insertion A x l' l).

Lemma in_insertion_inv : forall (A:Set)(x y:A)(l l':list A),(insertion A y l l')->(In x l')->(x=y)\/(In x l).

Inductive is_set (A:Set) : list A->Prop :=
  nil_is_set : (is_set A nil)
|cons_is_set : forall (x:A)(l:list A),(is_set A l)->~(In x l)->(is_set A (x::l)).

Lemma is_set_insertion : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->(is_set A l).

Lemma is_set_insertion_in : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->~(In x l).

Lemma insertion_is_set : forall (A:Set)(l:list A),(is_set _ l)->forall (x:A),~(In x l)->forall (l':list A),(insertion _ x l l')->(is_set _ l').

Inductive is_permutation (A:Set) : list A->list A->Prop :=
  nil_is_permutation : (is_permutation A nil nil)
|cons_is_permutation : forall (l l':list A),(is_permutation A l l')->forall (x:A)(l'':(list A)),(insertion A x l' l'')->(is_permutation A (x::l) l'').

Lemma is_set_eq_impl_permutation : forall (A:Set)(l l':list A),(forall (x:A),(In x l)<->(In x l'))->(is_set A l)->(is_set A l')->(is_permutation A l l').

Lemma is_permutation_refl : forall (A:Set)(l:list A),(is_permutation A l l).

Lemma insertion_is_permutation : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_permutation A (x::l) l').

Lemma insertion_trans : forall (A:Set)(l0 l1:list A)(x:A),(insertion A x l0 l1)->forall (l2:list A)(y:A),(insertion A y l1 l2)->exists l3:list A,(insertion A y l0 l3)/\(insertion A x l3 l2).

Lemma permutation_insertion : forall (A:Set)(l0 l1:list A),(is_permutation A l0 l1)->forall (x:A)(l2 l3:list A),(insertion A x l0 l2)->(insertion A x l1 l3)->(is_permutation A l2 l3).

Lemma is_permutation_sym : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A l' l).

Lemma permutation_in : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (x:A),(In x l)<->(In x l').

Lemma permutation_insertion_aux : forall (A:Set)(l l' l'':list A)(x:A),(insertion A x l l')->(insertion A x l l'')->(is_permutation A l' l'').

Lemma length_recursion : forall (A:Set),forall (P:list A->Prop),(forall (x:list A),(forall (y:list A),(length y)<(length x)->(P y))->(P x))->(forall (a:list A),(P a)).

Lemma insertion_length : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(length l')=(S (length l)).

Lemma permutation_length : forall (A:Set)(l l':list A),(is_permutation A l l')->(length l)=(length l').

Lemma insertion_permutation_eq : forall (A:Set)(l l':list A)(x:A),(insertion A x l' l)->forall (l'':list A),(insertion A x l'' l)->(is_permutation A l' l'').

Lemma permutation_insertion_comm : forall (A:Set)(l1 l2:list A)(x:A),(insertion A x l1 l2)->forall (l4:list A),(is_permutation A l2 l4)->(exists l3:list A,(is_permutation A l1 l3) /\ (insertion A x l3 l4)).

Lemma permutation_insertion_permutation : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (x:A)(l'':list A),(insertion A x l' l'')->forall (l''':list A),(is_permutation A l'' l''')->(is_permutation A (x::l) l''').

Lemma is_permutation_trans : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (l'':list A),(is_permutation A l' l'')->(is_permutation A l l'').

Lemma is_permutation_reverse : forall (A:Set)(l:list A),(is_permutation A l (rev l)).

Lemma is_permutation_reverse_impl_is_permutation : forall (A:Set)(l l':list A),(is_permutation A (rev l) (rev l'))->(is_permutation A l l').

Lemma is_permutation_impl_is_permutation_reverse : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A (rev l) (rev l')).

Lemma is_permutation_cons_snoc : forall (A:Set)(x:A)(xs:list A),(is_permutation A (cons x xs) (app xs (cons x nil))).

Lemma insertion_append : forall (A:Set)(x:A)(xs xss:list A),(insertion A x xs xss)->forall (yss:list A),(insertion A x (app xs yss) (app xss yss)).

Lemma is_permutation_append : forall (A:Set)(xs ys:list A),(is_permutation A xs ys)->forall (xs' ys':list A),(is_permutation A xs' ys')->(is_permutation A (app xs xs') (app ys ys')).

Lemma insertion_map : forall (B:Set)(y:B)(ys yss:list B),(insertion _ y ys yss)->forall (A:Set)(f:A->B)(x:A),y=f x->forall (xs:list A),ys = map f xs->exists xss:list A,yss = map f xss /\ insertion _ x xs xss.

Lemma is_permutation_map : forall (B:Set)(ys1 ys2:list B),(is_permutation B ys1 ys2)->forall (A:Set)(f:A->B)(xs1:list A),(ys1 = map f xs1)->exists xs2:list A,(is_permutation A xs1 xs2)/\ys2 = map f xs2.

Lemma is_permutation_set : forall (A:Set)(l l':list A),(is_permutation _ l l')->(is_set _ l)->(is_set _ l').

Lemma Permutation_impl_permutation : forall (A:Set)(l l':list A),(Permutation l l')->(is_permutation _ l l').

Lemma insertion_append_decompose : forall (A:Set)(x:A)(l l':list A),(insertion _ x l l')->exists l1:list A,exists l2:list A,l=(app l1 l2)/\l'=(app l1 (cons x l2)).

Lemma permutation_impl_Permutation : forall (A:Set)(l l':list A),(is_permutation _ l l')->(Permutation l l'). *)
Require Import Wf_nat.

Unset Standard Proposition Elimination Names.

Definition is_prime (p:nat) := (p<>1)/\(forall (d:nat),(divides p d)->(d=1)\/(d=p)).

Lemma not_prime_zero : ~(is_prime O).
  unfold is_prime.
  intro.
  elim H;intros.
  case (H1 2);try (apply zero_max_div);intro;discriminate.
Qed.

Lemma is_prime_2 : (is_prime 2).
  unfold is_prime.
  split.
  intro;discriminate.
  intros.
  elim H;destruct x;rewrite mult_comm.
  intro;discriminate.
  simpl.
  case d.
  simpl.
  rewrite mult_comm;simpl;intro;discriminate.
  intros.
  inversion H0.
  symmetry in H2.
  case (plus_is_one n (x*(S n)) H2);intro.
  elim a;intros.
  left;rewrite H1;trivial.
  elim a;intros.
  right;rewrite H1;trivial.
Qed.

Lemma prime_div_gcd : forall (p a:nat),(is_prime p)->~(divides a p)->(rel_prime p a).
  unfold is_prime.
  unfold rel_prime.
  intros.
  unfold is_gcd;unfold is_cd.
  split.
  split;apply one_min_div.
  intros.
  elim H;intros.
  elim H1;intros.
  case (H3 d' H4);intro.
  rewrite H6;apply divides_refl.
  rewrite H6 in H5;tauto.
Qed.

Lemma prime_gcd : forall (d p a:nat),(is_prime p)->(is_gcd d a p)->(d=1)\/(d=p).
  unfold is_prime.
  intros.
  elim H;intros.
  apply H2.
  elim H0;intros.
  elim H3;trivial.
Qed.

Lemma prime_rel_prime : forall (p a:nat),(is_prime p)->~(rel_prime a p)->(divides a p).
  unfold rel_prime.
  intros.
  generalize (gcd_is_gcd a p);intros.
  case (prime_gcd (gcd a p) p a H H1);intro;rewrite H2 in H1;try tauto.
  elim H1;intros.
  elim H3;trivial.
Qed.

Lemma prime_mult : forall (p a b:nat),(is_prime p)->(divides (a*b) p)->((divides a p)\/(divides b p)).
  intros.
  generalize (gcd_is_gcd a p);intro.
  case (prime_gcd (gcd a p) p a H H1);intro;rewrite H2 in H1.
  right;apply gauss with a;trivial.
  red in H1;elim H1;intros.
  red in H3;tauto.
Qed.

Lemma prime_square : forall (p a:nat),(is_prime p)->(divides (square a) p)->(divides a p).
  unfold square.
  intros;case (prime_mult p a a H H0);trivial.
Qed.

Lemma prime_power : forall (p n x:nat),(is_prime p)->(divides (power x n) p)->(divides x p).
  induction n;simpl;intros.
  elim H;intros.
  elim H1;apply divides_antisym;trivial;apply one_min_div.
  case (prime_mult p x (power x n) H H0);trivial.
  intro;apply IHn;trivial.
Qed.

Lemma prime_power_qn : forall (p n q x:nat),(is_prime p)->(divides (power x n) (power p (q*n)))->(1<=n)->(divides x (power p q)).
  induction q;simpl;intros.
  apply one_min_div.
  rewrite power_plus_lemma1 in H0.
  assert (divides x (power p q)).
  apply IHq;trivial.
  elim H0;intros;exists ((power p n)*x0).
  rewrite H2;ring.
  elim H2;intros.
  rewrite H3 in H0.
  rewrite power_mult_lemma1 in H0;rewrite power_power_lemma1 in H0;rewrite (mult_comm (power p n)) in H0.
  elim H0;intros.
  assert ((power p (q*n))<>0).
  intro.
  generalize (power_zero (q*n) p H5).
  intro.
  apply not_prime_zero.
  rewrite H6 in H;trivial.
  rewrite <- mult_assoc in H4.
  generalize (mult_lemma6 (power x0 n) ((power p n)*x1) (power p (q*n)) H5 H4).
  intro.
  assert (exists n':nat,n=(S n')).
  inversion H1;[exists 0 | exists m];trivial.
  elim H7;intro n';intro.
  rewrite H8 in H6;simpl in H6.
  assert (divides x0 p).
  case (prime_mult p x0 (power x0 n'));trivial.
  rewrite H6.
  exists ((power p n')*x1);ring.
  intro.
  apply prime_power with n';trivial.
  elim H9;intros.
  rewrite H10 in H3.
  rewrite H3.
  exists x2;ring.
Qed.

Lemma divides_prime : forall (a:nat),(exists p:nat,(p<>a)/\(is_prime p)/\(divides a p)) -> ~(is_prime a).
  intros;intro.
  elim H;intro p;intro.
  elim H1;intros.
  elim H3;intros.
  unfold is_prime in H0.
  elim H0;intros.
  unfold is_prime in H4.
  elim H4;intros.
  case (H7 p H5);auto.
Qed.

Lemma gcd_prime : forall (p:nat),(p<>1)->(forall (d a:nat),(is_gcd d a p)->(d=1)\/(d=p))->(is_prime p).
  intros.
  split;try tauto.
  intro d';intro.
  assert (is_gcd d' d' p).
  unfold is_gcd;unfold is_cd.
  split;[split;[apply divides_refl | tauto] | tauto].
  eapply H0;apply H2.
Qed.

Lemma prime_cond : forall (p:nat),((p<>1)/\(forall (a:nat),(a<>1)->(a<>p)->~(divides p a))<->(is_prime p)).
  split;intros.
  elim H;intros.
  split;try tauto.
  intros.
  case (eq_nat_dec d 1);intro;try tauto.
  case (eq_nat_dec d p);intro;try tauto.
  elim (H1 d n n0 H2).
  elim H;intros.
  split;try tauto.
  intros;intro.
  elim (H1 a H4);auto.
Qed.

Lemma prime_dec : forall (n:nat),{is_prime n}+{~(is_prime n)}.
  intro.
  case (divides_nat n);intro.
  elim s;intros.
  right;intro.
  unfold is_prime in H.
  elim H;intros.
  elim (H1 x);try tauto.
  case (eq_nat_dec n 1);intro.
  right;unfold is_prime;tauto.
  left;unfold is_prime.
  split;trivial.
  intros.
  case (eq_nat_dec d 1);try tauto.
  case (eq_nat_dec d n);try tauto;intros.
  elim (n0 d n3 n2 H).
Qed.

Lemma not_prime_impl_prime_divides : forall (n:nat),(~(is_prime n)->({p:nat | (is_prime p)/\(divides n p)}+{n=1})).
  intro.
  apply (lt_wf_rec n (fun n:nat => ~(is_prime n)->({p:nat | (is_prime p)/\(divides n p)}+{n=1})));intros.
  case (eq_nat_dec n0 1);try tauto;intro.
  case (eq_nat_dec n0 0);intro.
  left;exists 2.
  split;[apply is_prime_2 | rewrite e;apply zero_max_div].
  case (divides_nat n0);intro.
  elim s;intro d;intro.
  elim p;intros.
  elim H2;intros.
  assert (d<n0).
  generalize (divides_le n0 d n2 H4);omega.
  case (prime_dec d);intro.
  left;exists d;tauto.
  elim (H d H5 n3);try tauto.
  intro.
  elim a;intro q;intro.
  left;exists q.
  split;try tauto.
  apply divides_trans with d;try tauto.
  elim (prime_cond n0);intros;elim H0;apply H1;auto.
Qed.

Lemma nat_factor : forall (n p:nat),(is_prime p)->(n<>0)->{m:nat | (divides n (power p m))/\~(divides n (power p (m+1)))}.
  intros n p H.
  apply (lt_wf_rec n (fun n:nat => n <> 0 -> {m : nat | divides n (power p m) /\ ~ divides n (power p (m + 1))}));intros.
  case (divides_dec n0 p);intro.
  generalize (quo_is_quo n0 p d);intro.
  elim (H0 (quo n0 p d)).
  intro m;intros.
  exists (m+1).
  elim p0;intros.
  elim H3;intros.
  rewrite H5 in H2;rewrite mult_assoc in H2.
  rewrite plus_comm.
  split;simpl.
  exists x;trivial.
  rewrite plus_comm;simpl.
  rewrite (mult_comm p (power p m));rewrite mult_assoc;intro.
  elim H6;intros.
  rewrite H2 in H7.
  assert (p<>0).
  intro.
  rewrite H8 in H.
  apply not_prime_zero;trivial.
  assert ((power p m)*x=(power p m)*p*x0).
  apply mult_lemma6 with p;trivial.
  rewrite mult_assoc;rewrite H7;ring.
  rewrite <- H5 in H9;rewrite (mult_comm (power p m) p) in H9.
  apply H4.
  rewrite plus_comm;simpl.
  exists x0;trivial.
  rewrite mult_comm in H2;rewrite H2;apply mult_lemma3.
  intro.
  apply H1;rewrite H2;rewrite H3;trivial.
  elim H.
  intros.
  destruct p;omega.
  intro;apply H1.
  rewrite H2;rewrite H3;ring.
  exists 0;simpl.
  split.
  apply one_min_div.
  rewrite mult_comm;simpl;rewrite plus_comm;simpl;trivial.
Qed.

Lemma nat_factor_prime : forall (n:nat),(n<>0)->(n<>1)->{p:nat & {m:nat & {q:nat | (is_prime p)/\(m>0)/\(n=(power p m)*q)/\(is_gcd 1 p q)/\(q<n)}}}.
  intros.
  case (prime_dec n);intro.
  exists n;exists 1;exists 1;simpl.
  split;try tauto.
  split;try omega.
  split;try ring.
  split;try omega.
  apply gcd_sym;apply gcd_one.
  elim (not_prime_impl_prime_divides n n0);intro;try tauto.
  elim a;intro p;intro.
  elim p0;intros.
  elim (nat_factor n p H1).
  intro m;intro.
  elim p1;intros.
  exists p;exists m;exists (quo n (power p m) H3).
  split;trivial.
  split.
  destruct m;try omega.
  elim H4;simpl;rewrite mult_comm;simpl;rewrite plus_comm;simpl;trivial.
  split.
  apply (quo_is_quo n (power p m) H3).
  generalize (gcd_is_gcd p (quo n (power p m) H3));intro.
  assert ((gcd p (quo n (power p m) H3))=1).
  case (prime_gcd (gcd p (quo n (power p m) H3)) p (quo n (power p m) H3));trivial.
  apply gcd_sym;trivial.
  intro.
  rewrite H6 in H5;elim H5;intros.
  elim H7;intros.
  elim H4;rewrite plus_comm;simpl.
  generalize (quo_is_quo n (power p m) H3);intro.
  elim H10;intros.
  rewrite H12 in H11.
  exists x;rewrite H11;ring.
  rewrite H6 in H5;trivial.
  generalize (quo_is_quo n (power p m) H3);intro.
  split;trivial.
  rewrite H7;rewrite mult_comm;apply mult_lemma3.
  intro.
  apply H;rewrite H7.
  rewrite H8;ring.
  red;apply power_lt.
  destruct p.
  elim (not_prime_zero H1).
  destruct p;try omega.
  elim H1;tauto.
  destruct m;try omega.
  elim H4;simpl;rewrite mult_comm;simpl;rewrite plus_comm;simpl;trivial.
  trivial.
Qed.

Fixpoint refactor (l:(list (nat*nat))) {struct l} : nat :=
  match l with
    nil => 1
    | (cons (p,n) tail) => (power p n)*(refactor tail)
  end.

Inductive is_wf : (list (nat*nat))->Prop :=
  nil_is_wf : (is_wf nil)
|cons_is_wf : forall (p n:nat)(tail:(list (nat*nat))),(is_prime p)->(n>0)->(is_wf tail)->(rel_prime p (refactor tail))->(is_wf (cons (p,n) tail)).

Lemma factorisation : forall (n:nat),{l:(list (nat*nat)) | (is_wf l)/\n=(refactor l)}+{n=0}.
  intro.
  case (eq_nat_dec n 0);intro.
  right;trivial.
  case (eq_nat_dec n 1).
  intro;left;exists (nil (A:=nat*nat)).
  split;[apply nil_is_wf | simpl;trivial].
  generalize n0.
  apply (lt_wf_rec n (fun n:nat => n<>0 -> n <> 1 -> {l : list (nat * nat) | is_wf l /\ n = refactor l}+{n=0}));intros.
  elim (nat_factor_prime n1 H0 H1).
  intro p;intro.
  elim p0;intro m;intro.
  elim p1;intro q;intro.
  elim p2;intros.
  elim H3;intros.
  elim H5;intros.
  elim H7;intros.
  case (eq_nat_dec q 1);intro.
  left;exists (cons (p,m) nil);simpl;rewrite e in H6.
  split;trivial.
  apply cons_is_wf;auto;try (apply nil_is_wf).
  unfold rel_prime;simpl;rewrite e in H8;trivial.
  assert (q<>0).
  intro;rewrite H10 in H6;rewrite mult_comm in H6;simpl in H6;auto.
  elim (H q H9 H10 n2).
  intro.
  elim a;intro l;intro.
  elim p3;intros.
  left;exists (cons (p,m) l);simpl;rewrite H12 in H6;split;trivial.
  apply cons_is_wf;auto.
  rewrite <- H12;unfold rel_prime;trivial.
  intro;tauto.
Qed.

Lemma factor_divides_refactor : forall (x:nat*nat)(l:list (nat*nat)),(In x l)->(divides (refactor l) (power (fst x) (snd x))).
  induction l;simpl;try tauto.
  intro.
  case H;intro.
  destruct a.
  rewrite <- H0;simpl.
  exists (refactor l);trivial.
  destruct a.
  elim (IHl H0);intros.
  rewrite H1.
  exists ((power n n0)*x0);ring.
Qed.

Lemma prime_divides_refactor : forall (p:nat)(l:list (nat*nat)),(is_prime p)->(is_wf l)->(divides (refactor l) p)->(exists m:nat,(In (p,m) l)).
  induction l;simpl;intros.
  assert (p=1).
  apply divides_antisym;trivial.
  apply one_min_div.
  rewrite H2 in H;elim H;tauto.
  destruct a.
  case (divides_dec (power n n0) p);intro.
  generalize (prime_power p n0 n H d);intro.
  assert (n=p).
  inversion H0.
  elim H6.
  intros.
  elim H;intros.
  case (H11 p H2);try tauto;try omega.
  exists n0;rewrite <- H3;left;trivial.
  inversion H0.
  elim (IHl H H7).
  intros;exists x;tauto.
  apply gauss with (power n n0);trivial.
  apply rel_prime_sym;apply prime_div_gcd;trivial.
Qed.

Lemma in_wf : forall (l:list (nat*nat))(p n:nat),(In (p,n) l)->(is_wf l)->(is_prime p)/\(n>0).
  induction l;simpl;try tauto.
  intros;destruct a.
  inversion H0.
  case (in_inv H);intros.
  inversion H8;rewrite <- H10;rewrite <- H11;try tauto.
  apply IHl;trivial.
Qed.

Lemma rel_prime_wf : forall (l:list (nat*nat))(p n q m:nat),(In (p,n) l)->(is_wf ((q,m)::l))->(rel_prime p q).
  induction l;simpl;intros;try tauto.
  destruct a.
  inversion H0;case (in_inv H);intro.
  rewrite H8 in H7;simpl in H7.
  elim (in_wf ((n0,n1)::l) p n H);trivial;intros.
  elim (mult_rel_prime q (power p n) (refactor l) H7);intros.
  apply rel_prime_sym;apply power_rel_prime with n;trivial.
  apply (IHl p n q m);trivial.
  apply cons_is_wf;trivial.
  inversion H6;trivial.
  simpl in H7;elim (mult_rel_prime q (power n0 n1) (refactor l) H7);auto.
Qed.

Inductive is_pwd : list (nat*nat) -> Prop :=
  nil_is_pwd : (is_pwd nil)
|cons_is_pwd : forall (p n:nat)(tail:list (nat*nat)),(is_pwd tail)->(forall (n:nat),~(In (p,n) tail))->(is_pwd ((p,n)::tail)).

Lemma wf_impl_pwd : forall (l:list (nat*nat)),(is_wf l)->(is_pwd l).
  induction l;intro.
  apply nil_is_pwd.
  destruct a.
  inversion H.
  apply cons_is_pwd;auto.
  intros;intro.
  assert (rel_prime n n).
  eapply rel_prime_wf;[apply H7 | apply H].
  generalize (gcd_refl n);intro.
  unfold rel_prime in H8.
  assert (1=n).
  eapply gcd_unique;eauto.
  rewrite <- H10 in H3;elim H3;tauto.
Qed.

Lemma prime_power_divides_refactor : forall (p n m:nat)(l:list (nat*nat)),(is_prime p)->(n>0)->(is_wf l)->(divides (refactor l) (power p n))->(In (p,m) l)->(n<=m).
  induction l;simpl;intros;try tauto.
  case H3;intro.
  rewrite H4 in H2.
  rewrite H4 in H1;inversion H1.
  generalize (rel_prime_power p (refactor l) n (rel_prime_sym p (refactor l) H11));intro.
  rewrite mult_comm in H2.
  generalize (gauss (power p n) (refactor l) (power p m) H12 H2);intro.
  apply power_divides_power with p;trivial.
  destruct p.
  elim (not_prime_zero H8).
  elim H8;omega.
  destruct a.
  inversion H1.
  apply IHl;trivial.
  apply gauss with (power n0 n1);trivial.
  apply rel_prime_power;apply rel_prime_sym;apply rel_prime_power.
  apply (rel_prime_wf l p m n0 n1);trivial.
Qed.

Lemma factorisation_unique_upto_equiv_aux : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(forall (x n:nat),(In (x,n) l)->(In (x,n) l')).
  intros l l';intro;intro;intro;intros p n;intro.
  elim (in_wf l p n H2 H);intros.
  generalize (factor_divides_refactor (p,n) l H2);simpl;intro.
  rewrite H1 in H5.
  assert (divides (refactor l') p).
  apply divides_trans with (power p n);[trivial | apply power_divides_lemma1;auto with arith].
  elim (prime_divides_refactor p l' H3 H0 H6);intro m;intro.
  cut (n=m).
  intro;rewrite H8;trivial.
  apply le_antisym.
  eapply prime_power_divides_refactor;eauto.
  generalize (factor_divides_refactor (p,m) l' H7);simpl;intro.
  rewrite <- H1 in H8.
  apply prime_power_divides_refactor with p l;auto.
  elim (in_wf l' p m);trivial.
Qed.

Lemma pwd_impl_set : forall (l:list (nat*nat)),(is_pwd l)->(is_set (nat*nat) l).
  induction 1;[apply nil_is_set | apply cons_is_set;auto].
Qed.

Lemma factorisation_unique_upto_perm : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(is_permutation (nat*nat) l l').
  intros.
  assert (forall (x n:nat),(In (x,n) l)->(In (x,n) l')).
  apply factorisation_unique_upto_equiv_aux;trivial.
  assert (forall (x n:nat),(In (x,n) l')->(In (x,n) l)).
  apply factorisation_unique_upto_equiv_aux;auto.
  apply is_set_eq_impl_permutation;intros;(try (apply pwd_impl_set;apply wf_impl_pwd;trivial));destruct x;split;auto.
Qed.

Definition is_factorisation (n:nat)(l:list (nat*nat)) := (is_wf l)/\(n=(refactor l)).

Theorem factorisation_exists : forall (n:nat),n<>0->{l:list (nat*nat) | (is_factorisation n l)}.
  intros.
  case (factorisation n);intros;try tauto.
Qed.

Theorem factorisation_unique_upto_permutation : forall (n:nat)(l l':list (nat*nat)),(is_factorisation n l)->(is_factorisation n l')->(is_permutation (nat*nat) l l').
  unfold is_factorisation;intros.
  elim H;intros.
  elim H0;intros.
  apply factorisation_unique_upto_perm;auto;congruence.
Qed.

Lemma wf_power_dec : forall (n:nat)(l:list (nat*nat)),(is_wf l)->(n>0)->{x:nat | (refactor l)=(power x n)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\(0<r)/\(r<n)/\(refactor l)=(power p (q*n+r))*k/\(rel_prime p k)}}}}.
  intro.
  induction l;simpl;intros.
  left;exists 1;rewrite power_one;trivial.
  destruct a.
  assert (n<>0);try omega.
  generalize (quo_rem_euclide n1 n H1);intro.
  case (eq_nat_dec (remainder_euclide n1 n H1) 0);intro.
  rewrite e in H2;rewrite plus_comm in H2;simpl in H2.
  case IHl;intros;trivial.
  inversion H;trivial.
  elim s;intro y;intro.
  rewrite H2.
  left;rewrite p;rewrite (mult_comm n);rewrite <- power_power_lemma1;rewrite <- power_mult_lemma1;exists (power n0 (quotient_euclide n1 n H1)*y);trivial.
  elim s;intro p;intro.
  elim p0;intro q;intro.
  elim p1;intro r;intro.
  elim p2;intro k;intro.
  elim p3;intros.
  elim H4;intros.
  elim H6;intros.
  elim H8;intros.
  right.
  exists p;exists q;exists r.
  rewrite H9;rewrite mult_comm;rewrite <- mult_assoc.
  exists (k*(power n0 n1)).
  split;trivial.
  split;trivial.
  split;trivial.
  split;trivial.
  apply rel_prime_mult;trivial.
  inversion H.
  rewrite H9 in H17.
  elim (mult_rel_prime n0 (power p (q*n+r)) k H17);intros.
  apply rel_prime_power;apply rel_prime_sym;apply power_rel_prime with (q*n+r);trivial.
  rewrite plus_comm;auto with arith.
  right.
  exists n0;exists (quotient_euclide n1 n H1);exists (remainder_euclide n1 n H1).
  rewrite (mult_comm (quotient_euclide n1 n H1));rewrite <- H2.
  exists (refactor l).
  elim (in_wf ((n0,n1)::l) n0 n1);intros.
  split;trivial.
  split;trivial.
  destruct (remainder_euclide n1 n H1);try tauto;auto with arith.
  split;trivial.
  apply rem_euclide.
  split;trivial.
  inversion H;trivial.
  simpl;tauto.
  trivial.
Qed.

Lemma is_power_m_dec : forall (n m:nat),(m>0)->{x:nat | n=(power x m)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\(0<r)/\(r<m)/\n=(power p (q*m+r))*k/\(rel_prime p k)}}}}.
  intros n m;intro H.
  case (eq_nat_dec n 0);intro.
  left;exists 0.
  destruct m;simpl;try omega;trivial.
  generalize (factorisation_exists n n0);intro.
  elim H0;intro l;intro.
  elim p;intros.
  rewrite H2;apply wf_power_dec;trivial.
Qed.
