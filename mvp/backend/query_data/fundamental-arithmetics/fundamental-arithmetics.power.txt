
Require Import missing.
(* missing:
Require Export Arith.
Require Export ArithRing.
Require Export Omega.

Unset Standard Proposition Elimination Names.

Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).

Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\/(m=O).

Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).

Lemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \/ m=1.

Lemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\(m=1).

Lemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).

Lemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.

Lemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).

Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).

Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.

Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).

Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).

Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).

Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).

Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).

Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a). *)
Require Import division.
(* division:
Require Import missing.
Require Import Wf_nat.

Definition divides (a b:nat) := exists q:nat,a = (b*q).

Lemma one_min_div : forall (n:nat),(divides n 1).

Lemma zero_max_div : forall (n:nat),(divides O n).

Lemma divides_refl : forall (a:nat),(divides a a).

Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).

Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.

Lemma non_div_1 : forall (a:nat),(a<>1)->~(divides 1 a).

Lemma divides_plus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (plus a b) d).

Lemma divides_mult : forall (d a b:nat),(divides a d)->(divides (a*b) d).

Lemma divides_minus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (b-a) d).

Lemma quo_dec : forall (a b:nat),(divides a b)->{q:nat | a=b*q}.

Definition quo (a b:nat) (H:(divides a b)) := let (q,_):=(quo_dec a b H) in q.

Lemma quo_is_quo : forall (a b:nat)(H:divides a b),a=(mult b (quo a b H)).

Lemma quo_mult : forall (a b:nat)(H:divides a b),forall (n:nat),(b<>O)->(quo (a*n) b (divides_mult b a n H))=n*(quo a b H). *)

Unset Standard Proposition Elimination Names.

Definition square (x:nat) := x*x.

Lemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).
  unfold square.
  intros.
  ring.
Qed.

Fixpoint power (x n:nat) {struct n} : nat :=
  match n with
    O => 1
    | (S n) => (x*(power x n))
  end.

Lemma power_mult_lemma1 : forall (n x y:nat),(power (x*y) n)=(power x n)*(power y n).
  induction n;simpl;trivial.
  intros;rewrite (IHn x y);ring.
Qed.

Lemma power_plus_lemma1 : forall (n m x:nat),(power x (n+m))=(power x n)*(power x m).
  induction n;simpl;intros.
  auto with arith.
  rewrite IHn;ring.
Qed.

Lemma power_divides_lemma1 : forall (n x:nat),(0<n)->(divides (power x n) x).
  induction n;simpl;intros.
  inversion H.
  exists (power x n);trivial.
Qed.

Lemma power_power_lemma1 : forall (n m x:nat),(power (power x n) m)=(power x (n*m)).
  induction n;simpl;intros.
  induction m;simpl;auto with arith.
  rewrite IHm;ring.
  rewrite power_mult_lemma1;rewrite IHn;rewrite <- power_plus_lemma1;trivial.
Qed.

Lemma power_zero : forall (n x:nat),(power x n)=O->x=O.
  induction n;simpl;intros.
  discriminate.
  case (mult_lemma2 x (power x n) H);auto.
Qed.

Lemma power_lt : forall (p m:nat),(1<p)->(0<m)->1<(power p m).
  induction m;simpl;try omega;intros.
  destruct m;simpl;try omega.
  simpl in IHm.
  assert (1 < p*(power p m)).
  apply IHm;auto with arith.
  rewrite mult_comm.
  apply lt_trans with (1*p);try omega.
  apply mult_lt_compat_r;try omega.
Qed.

Lemma power_one : forall (n:nat),(power 1 n)=1.
  induction n;simpl;trivial.
  rewrite IHn;ring.
Qed.

Lemma power_divides_power : forall (x n m:nat),(x>1)->(divides (power x n) (power x m))->(m<=n).
  intros.
  case (le_lt_dec m n);trivial.
  intro.
  generalize (le_plus_minus n m);intro.
  rewrite H1 in H0;try omega.
  elim H0;intro q;rewrite power_plus_lemma1;intro.
  assert (1=(power x (m-n))*q).
  apply mult_lemma6 with (power x n).
  intro;generalize (power_zero n x H3);omega.
  rewrite mult_assoc;rewrite <- H2;ring.
  symmetry in H3;elim (mult_lemma5 (power x (m-n)) q H3);intros.
  case (eq_nat_dec (m-n) 0);intro;try omega.
  assert (x=1);try omega.
  apply divides_antisym;[apply one_min_div | rewrite <- H4;apply power_divides_lemma1;omega].
Qed.

