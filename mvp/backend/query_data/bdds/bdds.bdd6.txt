
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import ZArith NArith Nnat Ndec Ndigits.
From IntMap Require Import Allmaps.
Require Import Wf_nat.

Require Import BDDvar_ad_nat.
(* BDDvar_ad_nat:
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import ZArith NArith Nnat Ndec Ndigits.
From IntMap Require Import Allmaps.
Definition BDDzero := N0.
Definition BDDone := Npos 1.

  Definition BDDvar := ad.

  Definition BDDcompare (x y : BDDvar) :=
    match x, y with
    | N0, N0 => Datatypes.Eq
    | N0, Npos _ => Datatypes.Lt
    | Npos _, N0 => Datatypes.Gt
    | Npos p1, Npos p2 => Pcompare p1 p2 Datatypes.Eq
    end.

Definition BDDvar_eq := Neqb.

  Definition ad_S (a : ad) :=
    match a with
    | N0 => Npos 1
    | Npos p => Npos (Psucc p)
    end.

  Lemma ad_S_is_S : forall a : ad, nat_of_N (ad_S a) = S (nat_of_N a).

Lemma lt_pred : forall x y : nat, x < y -> x <> 0 -> pred x < pred y.

Lemma O_N0 : forall x : ad, nat_of_N x = 0 -> x = N0.
Lemma INFERIEUR_neq_O :
 forall x y : ad, BDDcompare x y = Datatypes.Lt -> y <> N0.

 Lemma BDDcompare_trans :
  forall x y z : BDDvar,
  BDDcompare x y = Datatypes.Lt ->

  Lemma ad_S_le_then_le :
   forall x y : ad, Nleb (ad_S x) y = true -> Nleb x y = true.

  Lemma le_then_le_S :
   forall x y : ad, Nleb x y = true -> Nleb x (ad_S y) = true.

  Lemma ad_S_le_then_neq :
   forall x y : ad, Nleb (ad_S x) y = true -> Neqb x y = false.

  Lemma BDDcompare_succ :
   forall a : BDDvar, BDDcompare a (ad_S a) = Datatypes.Lt.

  Lemma BDDcompare_lt :
   forall x y : BDDvar,
   BDDcompare x y = Datatypes.Lt -> nat_of_N x < nat_of_N y.

Lemma BDDlt_compare :
 forall x y : BDDvar,
 nat_of_N x < nat_of_N y -> BDDcompare x y = Datatypes.Lt.

Lemma relation_sum :
 forall r : Datatypes.comparison,

Lemma BDD_EGAL_complete :
 forall x y : BDDvar, BDDcompare x y = Datatypes.Eq -> x = y.

  Lemma lt_trans_1 : forall x y z : nat, x < y -> y < S z -> x < z.

Lemma BDDcompare_sup_inf :
 forall x y : BDDvar,
 BDDcompare x y = Datatypes.Gt -> BDDcompare y x = Datatypes.Lt.

  Lemma BDDcompare_1 :
   forall x y : BDDvar,
   BDDcompare x y = Datatypes.Lt ->

Definition max (m n : nat) := if leb m n then n else m.

Lemma lt_max_1_2 :
 forall x1 y1 x2 y2 : nat, x1 < x2 -> y1 < y2 -> max x1 y1 < max x2 y2.

Lemma lt_max_2 :
 forall x1 y1 x2 y2 : nat, x1 < y2 -> y1 < y2 -> max x1 y1 < max x2 y2.

Lemma lt_max_12 :
 forall x1 y1 x2 y2 : nat, x1 < x2 -> y1 < x2 -> max x1 y1 < max x2 y2.

Lemma BDDcompare_eq :
 forall x y : BDDvar, BDDcompare x y = Datatypes.Eq -> x = y. *)
Require Import bdd1.
(* bdd1:
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import ZArith NArith Nnat Ndec Ndigits.
From IntMap Require Import Allmaps.
Require Import Wf_nat.

Require Import BDDvar_ad_nat.

  Definition BDDstate := Map (BDDvar * (ad * ad)).
	  Definition initBDDstate := newMap (BDDvar * (ad * ad)).

  Inductive BDDbounded (bs : BDDstate) : ad -> BDDvar -> Prop :=
    | BDDbounded_0 : forall n : BDDvar, BDDbounded bs BDDzero n
    | BDDbounded_1 : forall n : BDDvar, BDDbounded bs BDDone n
    | BDDbounded_2 :
        forall (node : ad) (n x : BDDvar) (l r : ad),
        MapGet _ bs node = Some (x, (l, r)) ->
        BDDcompare x n = Datatypes.Lt ->
        Neqb l r = false ->
        BDDbounded bs l x -> BDDbounded bs r x -> BDDbounded bs node n.

  Lemma BDDbounded_lemma :
   forall (bs : BDDstate) (node : ad) (n : BDDvar),
   BDDbounded bs node n ->
   node = BDDzero \/
   node = BDDone \/
   (exists x : BDDvar,
      (exists l : BDDvar,
         (exists r : BDDvar,
            MapGet _ bs node = Some (x, (l, r)) /\
            BDDcompare x n = Datatypes.Lt /\

  Lemma increase_bound :
   forall (bs : BDDstate) (n n' : BDDvar) (node : ad),
   BDDbounded bs node n ->
   BDDcompare n n' = Datatypes.Lt -> BDDbounded bs node n'.

  Lemma boundedness_preservation :
   forall bs bs' : BDDstate,
   (forall (a l r : ad) (x : BDDvar),
    MapGet _ bs a = Some (x, (l, r)) -> MapGet _ bs' a = Some (x, (l, r))) ->
   forall (n : BDDvar) (node : ad),
   BDDbounded bs node n -> BDDbounded bs' node n.

  Definition BDDordered (bs : BDDstate) (node : ad) :=
    match MapGet _ bs node with
    | None => True
    | Some (n, _) => BDDbounded bs node (ad_S n)
    end.

  Definition BDD_OK (bs : BDDstate) (node : ad) := BDDordered bs node.

  Definition BDDstate_OK (bs : BDDstate) :=
    MapGet _ bs BDDzero = None /\
    MapGet _ bs BDDone = None /\
    (forall a : ad, in_dom _ a bs = true -> BDD_OK bs a).

  Lemma initBDDstate_OK : BDDstate_OK initBDDstate.

  Definition BDDsharing_map := Map (Map (Map ad)).
	  Definition initBDDsharing_map := newMap (Map (Map ad)).

  Definition BDDshare_lookup (share : BDDsharing_map) 
    (x : BDDvar) (l r : ad) : option ad :=
    match MapGet _ share l with
    | None => None
    | Some m1 =>
        match MapGet _ m1 r with
        | None => None
        | Some m2 =>
            match MapGet _ m2 x with
            | None => None
            | Some y => Some y
            end
        end
    end.

  Definition BDDshare_put (share : BDDsharing_map) 
    (x : BDDvar) (l r counter : ad) : BDDsharing_map :=
    let m1 :=
      match MapGet _ share l with
      | Some y => y
      | None => newMap (Map ad)
      end in
    let m2 :=
      match MapGet _ m1 r with
      | Some y => y
      | None => newMap ad
      end in
    let m2' := MapPut _ m2 x counter in
    let m1' := MapPut _ m1 r m2' in MapPut _ share l m1'.

  Lemma BDDshare_put_puts :
   forall (share : BDDsharing_map) (x : BDDvar) (l r counter : ad),
   BDDshare_lookup (BDDshare_put share x l r counter) x l r = Some counter.

  Lemma BDDshare_put_no_new_node :
   forall (share : BDDsharing_map) (x x' : BDDvar)
     (l l' r r' counter counter' : ad),
   BDDshare_lookup (BDDshare_put share x l r counter) x' l' r' =
   Some counter' ->
   BDDshare_lookup share x' l' r' = Some counter' \/
   (x, (l, r)) = (x', (l', r')).

  Lemma BDDshare_put_preserves_nodes :
   forall (share : BDDsharing_map) (x x' : BDDvar)
     (l l' r r' counter counter' : ad),
   BDDshare_lookup share x' l' r' = Some counter' ->
   (x, (l, r)) <> (x', (l', r')) ->
   BDDshare_lookup (BDDshare_put share x l r counter) x' l' r' =
   Some counter'.

  Definition BDDsharing_OK (bs : BDDstate) (share : BDDsharing_map) :=
    forall (x : BDDvar) (l r a : ad),
    BDDshare_lookup share x l r = Some a <->
    MapGet _ bs a = Some (x, (l, r)).

  Lemma initBDDsharing_map_OK : BDDsharing_OK initBDDstate initBDDsharing_map.

  Definition BDDconfig := (BDDstate * (BDDsharing_map * ad))%type.

  Definition initBDDconfig :=
    (initBDDstate, (initBDDsharing_map, ad_S (ad_S N0))).

  Definition BDDconfig_OK (cfg : BDDconfig) :=
    match cfg return Prop with
    | (bs, (share, counter)) =>
        BDDstate_OK bs /\
        BDDsharing_OK bs share /\
        (forall a : ad, Nleb counter a = true -> MapGet _ bs a = None) /\
        Nleb (ad_S (ad_S N0)) counter = true
    end.

  Lemma initBDDconfig_OK : BDDconfig_OK initBDDconfig.

  Lemma config_OK_zero :
   forall cfg : BDDconfig,
   BDDconfig_OK cfg -> MapGet _ (fst cfg) BDDzero = None.

  Lemma config_OK_one :
   forall cfg : BDDconfig,
   BDDconfig_OK cfg -> MapGet _ (fst cfg) BDDone = None.

  Definition BDDalloc (cfg : BDDconfig) (x : BDDvar) 
    (l r : ad) :=
    match cfg with
    | (bs, (share, counter)) =>
        let share' := BDDshare_put share x l r counter in
        let bs' := MapPut _ bs counter (x, (l, r)) in
        let counter' := ad_S counter in (bs', (share', counter'), counter)
    end.

  Lemma BDDsharing_lookup_semantics :
   forall (bs : BDDstate) (share : BDDsharing_map) (n l r : ad) (x : BDDvar),
   BDDsharing_OK bs share ->
   (BDDshare_lookup share x l r = Some n <->
    MapGet _ bs n = Some (x, (l, r))).

  Definition node_OK (bs : BDDstate) (node : ad) :=
    node = BDDzero \/ node = BDDone \/ in_dom _ node bs = true.

  Lemma BDDbounded_node_OK :
   forall (bs : BDDstate) (node : ad) (n : BDDvar),
   BDDbounded bs node n -> node_OK bs node.

  Lemma BDDalloc_allocates :
   forall (cfg : BDDconfig) (l r : ad) (x : BDDvar),
   MapGet _ (fst (fst (BDDalloc cfg x l r))) (snd (BDDalloc cfg x l r)) =
   Some (x, (l, r)).

  Lemma BDDalloc_preserves_nodes :
   forall (cfg : BDDconfig) (l r : ad) (x : BDDvar),
   BDDconfig_OK cfg ->
   forall (a l1 r1 : ad) (x1 : BDDvar),
   MapGet _ (fst cfg) a = Some (x1, (l1, r1)) ->
   MapGet _ (fst (fst (BDDalloc cfg x l r))) a = Some (x1, (l1, r1)).

  Lemma BDDalloc_no_new_node :
   forall (cfg : BDDconfig) (l l1 r r1 a : ad) (x x1 : BDDvar),
   MapGet _ (fst (fst (BDDalloc cfg x l r))) a = Some (x1, (l1, r1)) ->
   a = snd (snd cfg) \/ MapGet _ (fst cfg) a = Some (x1, (l1, r1)).

  Lemma BDDalloc_no_new_node_1 :
   forall (cfg : BDDconfig) (l l1 r r1 a : ad) (x x1 : BDDvar),
   MapGet _ (fst (fst (BDDalloc cfg x l r))) a = Some (x1, (l1, r1)) ->
   (x1, (l1, r1)) = (x, (l, r)) \/
   MapGet _ (fst cfg) a = Some (x1, (l1, r1)).

  Lemma BDDalloc_preserves_zero :
   forall (cfg : BDDconfig) (l r : ad) (x : BDDvar),
   BDDconfig_OK cfg ->
   MapGet _ (fst (fst (BDDalloc cfg x l r))) BDDzero = None.

  Lemma BDDalloc_preserves_one :
   forall (cfg : BDDconfig) (l r : ad) (x : BDDvar),
   BDDconfig_OK cfg ->
   MapGet _ (fst (fst (BDDalloc cfg x l r))) BDDone = None.

  Lemma BDDalloc_keeps_state_OK :
   forall (cfg : BDDconfig) (l r : ad) (x : BDDvar),
   BDDconfig_OK cfg ->
   node_OK (fst cfg) l ->
   node_OK (fst cfg) r ->
   Neqb l r <> true ->
   (forall (xl : BDDvar) (ll rl : ad),
    MapGet _ (fst cfg) l = Some (xl, (ll, rl)) ->
    BDDcompare xl x = Datatypes.Lt) ->

  Lemma BDDalloc_adjusts_counter :
   forall (cfg : BDDconfig) (x : BDDvar) (l r a : ad),
   BDDconfig_OK cfg ->
   (forall a : ad,
    Nleb (snd (snd (fst (BDDalloc cfg x l r)))) a = true ->
    MapGet _ (fst (fst (BDDalloc cfg x l r))) a = None) /\
   Nleb (ad_S (ad_S N0)) (snd (snd (fst (BDDalloc cfg x l r)))) = true.

Lemma BDDalloc_keeps_sharing_OK :
 forall (cfg : BDDconfig) (l r : ad) (x : BDDvar),
 BDDconfig_OK cfg ->
 node_OK (fst cfg) l ->
 node_OK (fst cfg) r ->
 (forall (x' : BDDvar) (l' r' a : ad),
  MapGet _ (fst cfg) a = Some (x', (l', r')) ->
  (x, (l, r)) <> (x', (l', r'))) ->
 BDDsharing_OK (fst (fst (BDDalloc cfg x l r)))
   (fst (snd (fst (BDDalloc cfg x l r)))).

  Lemma BDDalloc_semantics :
   forall (cfg : BDDconfig) (l r : ad) (x : BDDvar),
   BDDconfig_OK cfg ->
   node_OK (fst cfg) l ->
   node_OK (fst cfg) r ->
   Neqb l r <> true ->
   (forall (xl : BDDvar) (ll rl : ad),
    MapGet _ (fst cfg) l = Some (xl, (ll, rl)) ->
    BDDcompare xl x = Datatypes.Lt) ->

  Definition BDDmake (cfg : BDDconfig) (x : BDDvar) 
    (l r : ad) :=
    if Neqb l r
    then (cfg, l)
    else
     match cfg with
     | (bs, (share, counter)) =>
         match BDDshare_lookup share x l r with
         | Some y => (cfg, y)
         | None => BDDalloc cfg x l r
         end
     end.

  Lemma BDDmake_semantics :
   forall (cfg : BDDconfig) (l r : ad) (x : BDDvar),
   BDDconfig_OK cfg ->
   node_OK (fst cfg) l ->
   node_OK (fst cfg) r ->
   (forall (xl : BDDvar) (ll rl : ad),
    MapGet _ (fst cfg) l = Some (xl, (ll, rl)) ->
    BDDcompare xl x = Datatypes.Lt) -> *)
Require Import bdd2.
(* bdd2:
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import ZArith NArith Nnat Ndec Ndigits.
From IntMap Require Import Allmaps.
Require Import Wf_nat.

Require Import BDDvar_ad_nat.
Require Import bdd1.

Definition var (cfg : BDDconfig) (node : ad) :=
  match MapGet _ (fst cfg) node with
  | None =>   BDDzero
  | Some (x, (l, r)) => x
  end.

Definition low (cfg : BDDconfig) (node : ad) :=
  match MapGet _ (fst cfg) node with
  | None =>   N0
  | Some (x, (l, r)) => l
  end.

Definition high (cfg : BDDconfig) (node : ad) :=
  match MapGet _ (fst cfg) node with
  | None =>   N0
  | Some (x, (l, r)) => r
  end.

Definition config_node_OK (cfg : BDDconfig) := node_OK (fst cfg).
Definition is_internal_node (cfg : BDDconfig) (node : ad) :=
  exists x : BDDvar,
    (exists l : ad,
       (exists r : ad, MapGet _ (fst cfg) node = Some (x, (l, r)))).

Lemma BDDvar_ordered_low :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node ->
 is_internal_node cfg (low cfg node) ->
 BDDcompare (var cfg (low cfg node)) (var cfg node) = Datatypes.Lt.

Lemma BDDvar_ordered_high :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node ->
 is_internal_node cfg (high cfg node) ->
 BDDcompare (var cfg (high cfg node)) (var cfg node) = Datatypes.Lt.

Definition var_binding := BDDvar -> bool.
 
Definition bool_fun := var_binding -> bool.

Definition bool_fun_eval (bf : bool_fun) (vb : var_binding) := bf vb.

Definition bool_fun_zero (vb : var_binding) := false. 
Definition bool_fun_one (vb : var_binding) := true. 

Fixpoint bool_fun_of_BDD_1 (cfg : BDDconfig) (node : ad) 
 (bound : nat) {struct bound} : bool_fun :=
  match MapGet _ (fst cfg) node with
  | None => if Neqb node BDDzero then bool_fun_zero else bool_fun_one
  | Some (x, (l, r)) =>
      match bound with
      | O =>   bool_fun_zero
      | S bound' =>
          let bfl := bool_fun_of_BDD_1 cfg l bound' in
          let bfr := bool_fun_of_BDD_1 cfg r bound' in
          fun vb : var_binding => if vb x then bfr vb else bfl vb
      end
  end.

Lemma bool_fun_of_BDD_1_semantics :
 forall cfg : BDDconfig,
 BDDconfig_OK cfg ->
 forall bound : nat,
 bool_fun_of_BDD_1 cfg BDDzero bound = bool_fun_zero /\
 bool_fun_of_BDD_1 cfg BDDone bound = bool_fun_one /\
 (forall node : ad,
  is_internal_node cfg node ->
  nat_of_N (var cfg node) < bound ->
  forall vb : var_binding,
  (vb (var cfg node) = true ->
   bool_fun_eval (bool_fun_of_BDD_1 cfg node bound) vb =
   bool_fun_eval (bool_fun_of_BDD_1 cfg (high cfg node) (pred bound)) vb) /\
  (vb (var cfg node) = false ->
   bool_fun_eval (bool_fun_of_BDD_1 cfg node bound) vb =
   bool_fun_eval (bool_fun_of_BDD_1 cfg (low cfg node) (pred bound)) vb)).

Lemma bool_fun_of_BDD_1_semantics_1 :
 forall cfg : BDDconfig,
 BDDconfig_OK cfg ->
 forall bound : nat,
 bool_fun_of_BDD_1 cfg BDDzero bound = bool_fun_zero /\
 bool_fun_of_BDD_1 cfg BDDone bound = bool_fun_one /\
 (forall node : ad,
  is_internal_node cfg node ->
  nat_of_N (var cfg node) < bound ->
  bool_fun_of_BDD_1 cfg node bound =
  (fun vb : var_binding =>
   if vb (var cfg node)
   then bool_fun_of_BDD_1 cfg (high cfg node) (pred bound) vb
   else bool_fun_of_BDD_1 cfg (low cfg node) (pred bound) vb)).

Lemma bool_fun_of_BDD_1_semantics_2 :
 forall (cfg : BDDconfig) (node : ad) (bound1 bound2 : nat),
 MapGet _ (fst cfg) node = None ->
 bool_fun_of_BDD_1 cfg node bound1 = bool_fun_of_BDD_1 cfg node bound2.

Lemma bool_fun_of_BDD_1_change_bound :
 forall cfg : BDDconfig,
 BDDconfig_OK cfg ->
 forall (bound : nat) (node : ad),
 nat_of_N (var cfg node) < bound ->
 bool_fun_of_BDD_1 cfg node bound =
 bool_fun_of_BDD_1 cfg node (S (nat_of_N (var cfg node))).

Definition bool_fun_of_BDD (cfg : BDDconfig) (node : ad) :=
  bool_fun_of_BDD_1 cfg node (S (nat_of_N (var cfg node))).

Lemma bool_fun_of_BDD_semantics :
 forall cfg : BDDconfig,
 BDDconfig_OK cfg ->
 bool_fun_of_BDD cfg BDDzero = bool_fun_zero /\
 bool_fun_of_BDD cfg BDDone = bool_fun_one /\
 (forall node : ad,
  is_internal_node cfg node ->
  bool_fun_of_BDD cfg node =
  (fun vb : var_binding =>
   if vb (var cfg node)
   then bool_fun_of_BDD cfg (high cfg node) vb
   else bool_fun_of_BDD cfg (low cfg node) vb)).

Definition bool_fun_eq (bf1 bf2 : bool_fun) :=
  forall vb : var_binding, bool_fun_eval bf1 vb = bool_fun_eval bf2 vb.

Lemma bool_fun_eq_symm :
 forall bf1 bf2 : bool_fun, bool_fun_eq bf1 bf2 -> bool_fun_eq bf2 bf1.

Lemma bool_fun_eq_trans :
 forall bf1 bf2 bf3 : bool_fun,
 bool_fun_eq bf1 bf2 -> bool_fun_eq bf2 bf3 -> bool_fun_eq bf1 bf3.

Definition bool_fun_neg (bf : bool_fun) : bool_fun :=
  fun vb : var_binding => negb (bf vb).
Definition bool_fun_or (bf1 bf2 : bool_fun) : bool_fun :=
  fun vb : var_binding => bf1 vb || bf2 vb.

Lemma bool_fun_neg_semantics :
 forall (bf : bool_fun) (vb : var_binding),
 (bool_fun_eval bf vb = true -> bool_fun_eval (bool_fun_neg bf) vb = false) /\
 (bool_fun_eval bf vb = false -> bool_fun_eval (bool_fun_neg bf) vb = true).

Lemma bool_fun_neg_zero : bool_fun_neg bool_fun_zero = bool_fun_one.

Lemma bool_fun_neg_one : bool_fun_neg bool_fun_one = bool_fun_zero.

Lemma bool_fun_eq_neg :
 forall bf1 bf2 : bool_fun,
 bool_fun_eq (bool_fun_neg bf1) (bool_fun_neg bf2) -> bool_fun_eq bf1 bf2.

Lemma bool_fun_eq_neg_1 :
 forall bf1 bf2 : bool_fun,
 bool_fun_eq bf1 bf2 -> bool_fun_eq (bool_fun_neg bf1) (bool_fun_neg bf2).

Definition BDDneg_memo := Map ad.
Definition BDDneg_memo_lookup (memo : BDDneg_memo) 
  (a : ad) := MapGet _ memo a.
Definition BDDneg_memo_put (memo : BDDneg_memo) (a node : ad) :=
  MapPut _ memo a node.

Definition BDDneg_memo_OK (cfg : BDDconfig) (memo : BDDneg_memo) :=
  forall a node : ad,
  BDDneg_memo_lookup memo a = Some node ->
  config_node_OK cfg node /\
  bool_fun_of_BDD cfg node = bool_fun_neg (bool_fun_of_BDD cfg a) /\
  var cfg a = var cfg node. 

Fixpoint BDDneg_2 (cfg : BDDconfig) (node : ad) (bound : nat) {struct bound} 
   : BDDconfig * ad :=
  match MapGet _ (fst cfg) node with
  | None => if Neqb node BDDzero then (cfg, BDDone) else (cfg, BDDzero)
  | Some (x, (l, r)) =>
      match bound with
      | O =>   (initBDDconfig, BDDzero)
      | S bound' =>
          BDDmake (fst (BDDneg_2 (fst (BDDneg_2 cfg l bound')) r bound')) x
            (snd (BDDneg_2 cfg l bound'))
            (snd (BDDneg_2 (fst (BDDneg_2 cfg l bound')) r bound'))
      end
  end. *)
Require Import bdd3.
(* bdd3:
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import ZArith NArith Nnat Ndec Ndigits.
From IntMap Require Import Allmaps.
Require Import Wf_nat.

Require Import BDDvar_ad_nat.
Require Import bdd1.
Require Import bdd2.

Lemma bool_fun_one_zero_eq : ~ bool_fun_eq bool_fun_one bool_fun_zero.

Lemma bool_fun_zero_one_eq : ~ bool_fun_eq bool_fun_zero bool_fun_one.

Definition augment (vb : var_binding) (x : BDDvar) 
  (b : bool) (y : BDDvar) := if BDDvar_eq x y then b else vb y.

Definition bool_fun_restrict (bf : bool_fun) (x : BDDvar) 
  (b : bool) (vb : var_binding) := bool_fun_eval bf (augment vb x b).

Lemma bool_fun_restrict_zero :
 forall (x : BDDvar) (b : bool),
 bool_fun_eq (bool_fun_restrict bool_fun_zero x b) bool_fun_zero. 

Lemma bool_fun_restrict_one :
 forall (x : BDDvar) (b : bool),
 bool_fun_eq (bool_fun_restrict bool_fun_one x b) bool_fun_one.

Lemma bool_fun_restrict_eq :
 forall (bf bf' : bool_fun) (x : BDDvar) (b : bool),
 bool_fun_eq bf bf' ->
 bool_fun_eq (bool_fun_restrict bf x b) (bool_fun_restrict bf' x b).

Definition var_binding_eq (vb vb' : var_binding) :=
  forall x : BDDvar, vb x = vb' x.

Definition bool_fun_ext (bf : bool_fun) :=
  forall vb vb' : var_binding,
  var_binding_eq vb vb' -> bool_fun_eval bf vb = bool_fun_eval bf vb'.

Lemma bool_fun_of_BDD_1_ext :
 forall (bound : nat) (cfg : BDDconfig) (node : ad),
 bool_fun_ext (bool_fun_of_BDD_1 cfg node bound). 

Lemma bool_fun_of_BDD_ext :
 forall (cfg : BDDconfig) (node : ad),
 bool_fun_ext (bool_fun_of_BDD cfg node).

Lemma augment_eq :
 forall (vb : var_binding) (x : BDDvar) (b : bool),
 vb x = b -> var_binding_eq (augment vb x b) vb.

Definition bool_fun_independent (bf : bool_fun) (x : BDDvar) :=
  forall vb : var_binding,
  bool_fun_eval bf (augment vb x true) =
  bool_fun_eval bf (augment vb x false).

Lemma bool_fun_independent_lemma :
 forall (bf : bool_fun) (x : BDDvar) (vb : var_binding) (b : bool),
 bool_fun_ext bf ->
 bool_fun_independent bf x ->
 bool_fun_eval bf (augment vb x b) = bool_fun_eval bf vb. 

Lemma bool_fun_independent_zero :
 forall (cfg : BDDconfig) (x : BDDvar),
 BDDconfig_OK cfg -> bool_fun_independent (bool_fun_of_BDD cfg BDDzero) x.

Lemma bool_fun_independent_one :
 forall (cfg : BDDconfig) (x : BDDvar),
 BDDconfig_OK cfg -> bool_fun_independent (bool_fun_of_BDD cfg BDDone) x.

Lemma in_dom_is_internal :
 forall (cfg : BDDconfig) (node : ad),
 in_dom _ node (fst cfg) = true -> is_internal_node cfg node.

Lemma internal_node_lemma :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node ->
 Neqb (low cfg node) (high cfg node) = false /\
 BDDbounded (fst cfg) (low cfg node) (var cfg node) /\
 BDDbounded (fst cfg) (high cfg node) (var cfg node).

Lemma high_bounded :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node ->
 BDDbounded (fst cfg) (high cfg node) (var cfg node).

Lemma low_bounded :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node ->
 BDDbounded (fst cfg) (low cfg node) (var cfg node).

Lemma high_OK :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node -> config_node_OK cfg (high cfg node).

Lemma low_OK :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node -> config_node_OK cfg (low cfg node).

Lemma low_high_neq :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node -> Neqb (low cfg node) (high cfg node) = false.

Lemma BDDvar_independent_1 :
 forall (cfg : BDDconfig) (n : nat) (node : ad) (x : BDDvar),
 BDDconfig_OK cfg ->
 is_internal_node cfg node ->
 n = nat_of_N (var cfg node) ->
 BDDcompare (var cfg node) x = Datatypes.Lt ->

Lemma BDDvar_independent_high :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node ->
 bool_fun_independent (bool_fun_of_BDD cfg (high cfg node)) (var cfg node).

Lemma BDDvar_independent_low :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node ->
 bool_fun_independent (bool_fun_of_BDD cfg (low cfg node)) (var cfg node).

Lemma bool_fun_of_BDDzero :
 forall cfg : BDDconfig,
 BDDconfig_OK cfg -> bool_fun_eq (bool_fun_of_BDD cfg BDDzero) bool_fun_zero.

Lemma bool_fun_of_BDDone :
 forall cfg : BDDconfig,
 BDDconfig_OK cfg -> bool_fun_eq (bool_fun_of_BDD cfg BDDone) bool_fun_one.

Lemma bool_fun_of_BDDhigh :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node ->
 bool_fun_eq (bool_fun_of_BDD cfg (high cfg node))
   (bool_fun_restrict (bool_fun_of_BDD cfg node) (var cfg node) true).

Lemma bool_fun_of_BDDlow :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node ->
 bool_fun_eq (bool_fun_of_BDD cfg (low cfg node))
   (bool_fun_restrict (bool_fun_of_BDD cfg node) (var cfg node) false).

Lemma internal_node_not_constant_1 :
 forall cfg : BDDconfig,
 BDDconfig_OK cfg ->
 forall (n : nat) (node : ad),
 is_internal_node cfg node ->
 n = nat_of_N (var cfg node) ->
 ~ bool_fun_eq (bool_fun_of_BDD cfg node) bool_fun_zero /\
 ~ bool_fun_eq (bool_fun_of_BDD cfg node) bool_fun_one.

Lemma internal_node_not_constant :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node ->
 ~ bool_fun_eq (bool_fun_of_BDD cfg node) bool_fun_zero /\
 ~ bool_fun_eq (bool_fun_of_BDD cfg node) bool_fun_one.

Lemma bool_fun_neq_internal_zero :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node ->
 ~ bool_fun_eq (bool_fun_of_BDD cfg node) (bool_fun_of_BDD cfg BDDzero).
 
Lemma bool_fun_neq_internal_one :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node ->
 ~ bool_fun_eq (bool_fun_of_BDD cfg node) (bool_fun_of_BDD cfg BDDone).

Lemma bool_fun_neq_zero_one :
 forall cfg : BDDconfig,
 BDDconfig_OK cfg ->
 ~ bool_fun_eq (bool_fun_of_BDD cfg BDDzero) (bool_fun_of_BDD cfg BDDone).

Lemma bool_fun_neq_one_zero :
 forall cfg : BDDconfig,
 BDDconfig_OK cfg ->
 ~ bool_fun_eq (bool_fun_of_BDD cfg BDDone) (bool_fun_of_BDD cfg BDDzero).

Lemma bool_fun_neq_lemma :
 forall bf1 bf2 : bool_fun, ~ bool_fun_eq bf1 bf2 -> ~ bool_fun_eq bf2 bf1.

Lemma no_duplicate_node :
 forall (cfg : BDDconfig) (node1 node2 : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node1 ->
 is_internal_node cfg node2 ->
 var cfg node1 = var cfg node2 ->
 high cfg node1 = high cfg node2 ->
 low cfg node1 = low cfg node2 -> node1 = node2.

Lemma BDDunique_1 :
 forall cfg : BDDconfig,
 BDDconfig_OK cfg ->
 forall (n : nat) (node1 node2 : ad),
 n = max (nat_of_N (var cfg node1)) (nat_of_N (var cfg node2)) ->
 config_node_OK cfg node1 ->
 config_node_OK cfg node2 ->
 bool_fun_eq (bool_fun_of_BDD cfg node1) (bool_fun_of_BDD cfg node2) ->
 node1 = node2.

Lemma BDDunique :
 forall cfg : BDDconfig,
 BDDconfig_OK cfg ->
 forall node1 node2 : ad,
 config_node_OK cfg node1 ->
 config_node_OK cfg node2 ->
 bool_fun_eq (bool_fun_of_BDD cfg node1) (bool_fun_of_BDD cfg node2) ->
 node1 = node2.

Lemma bool_fun_eq_lemma :
 forall (bf1 bf2 : bool_fun) (x : BDDvar),
 bool_fun_ext bf1 ->
 bool_fun_ext bf2 ->
 bool_fun_eq (bool_fun_restrict bf1 x true) (bool_fun_restrict bf2 x true) ->
 bool_fun_eq (bool_fun_restrict bf1 x false) (bool_fun_restrict bf2 x false) ->
 bool_fun_eq bf1 bf2.
  
Lemma bool_fun_preservation_1 :
 forall cfg cfg' : BDDconfig,
 BDDconfig_OK cfg ->
 BDDconfig_OK cfg' ->
 (forall (x : BDDvar) (l r a : ad),
  MapGet _ (fst cfg) a = Some (x, (l, r)) ->
  MapGet _ (fst cfg') a = Some (x, (l, r))) ->
 forall (n : nat) (node : ad),
 n = nat_of_N (var cfg node) ->
 config_node_OK cfg node ->
 bool_fun_eq (bool_fun_of_BDD cfg' node) (bool_fun_of_BDD cfg node).

Lemma bool_fun_preservation :
 forall (cfg cfg' : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 BDDconfig_OK cfg' ->
 (forall (x : BDDvar) (l r a : ad),
  MapGet _ (fst cfg) a = Some (x, (l, r)) ->
  MapGet _ (fst cfg') a = Some (x, (l, r))) ->
 config_node_OK cfg node ->
 bool_fun_eq (bool_fun_of_BDD cfg' node) (bool_fun_of_BDD cfg node). *)
Require Import bdd4.
(* bdd4:
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import ZArith NArith Nnat Ndec Ndigits.
From IntMap Require Import Allmaps.
Require Import Wf_nat.

Require Import BDDvar_ad_nat.
Require Import bdd1.
Require Import bdd2.
Require Import bdd3.

Lemma BDDneg_2_lemma :
 forall (bound : nat) (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 config_node_OK cfg node ->
 (is_internal_node cfg node -> nat_of_N (var cfg node) < bound) ->
 BDDconfig_OK (fst (BDDneg_2 cfg node bound)) /\
 (forall (x : BDDvar) (l r a : ad),
  MapGet _ (fst cfg) a = Some (x, (l, r)) ->
  MapGet _ (fst (fst (BDDneg_2 cfg node bound))) a = Some (x, (l, r))) /\
 (is_internal_node cfg node ->
  is_internal_node (fst (BDDneg_2 cfg node bound))
    (snd (BDDneg_2 cfg node bound)) /\
  var cfg node =
  var (fst (BDDneg_2 cfg node bound)) (snd (BDDneg_2 cfg node bound))) /\
 config_node_OK (fst (BDDneg_2 cfg node bound))
   (snd (BDDneg_2 cfg node bound)) /\
 bool_fun_eq
   (bool_fun_of_BDD (fst (BDDneg_2 cfg node bound))
      (snd (BDDneg_2 cfg node bound)))
   (bool_fun_neg (bool_fun_of_BDD cfg node)). *)
Require Import bdd5_1.
(* bdd5_1:
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import ZArith NArith Nnat Ndec Ndigits.
From IntMap Require Import Allmaps.
Require Import Wf_nat.

Require Import BDDvar_ad_nat.
Require Import bdd1.
Require Import bdd2.
Require Import bdd3.
Require Import bdd4.

Definition BDDneg_memo_OK_1 (cfg : BDDconfig) (memo : BDDneg_memo) :=
  forall (node node' : ad) (bound : nat),
  config_node_OK cfg node ->
  BDDneg_memo_lookup memo node = Some node' ->
  (is_internal_node cfg node -> nat_of_N (var cfg node) < bound) ->
  BDDneg_2 cfg node bound = (cfg, node').

Definition BDDneg_memo_OK_2 (cfg : BDDconfig) (memo : BDDneg_memo) :=
  forall (node node' : ad) (bound : nat),
  BDDneg_memo_lookup memo node = Some node' ->
  (is_internal_node cfg node -> nat_of_N (var cfg node) < bound) ->
  config_node_OK cfg node /\ BDDneg_2 cfg node bound = (cfg, node').

Fixpoint BDDneg_1 (arg : BDDconfig * ad * BDDneg_memo) 
 (bound : nat) {struct bound} : BDDconfig * ad * BDDneg_memo :=
  match BDDneg_memo_lookup (snd arg) (snd (fst arg)) with
  | Some node => (fst (fst arg), node, snd arg)
  | None =>
      match MapGet _ (fst (fst (fst arg))) (snd (fst arg)) with
      | None =>
          if Neqb (snd (fst arg)) BDDzero
          then
           (fst (fst arg), BDDone, BDDneg_memo_put (snd arg) BDDzero BDDone)
          else
           (fst (fst arg), BDDzero, BDDneg_memo_put (snd arg) BDDone BDDzero)
      | Some (x, (l, r)) =>
          match bound with
          | O => (initBDDconfig, BDDzero, newMap ad)
          | S bound' =>
              (BDDmake
                 (fst
                    (fst
                       (BDDneg_1
                          (fst
                             (fst
                                (BDDneg_1 (fst (fst arg), l, snd arg) bound')),
                          r,
                          snd (BDDneg_1 (fst (fst arg), l, snd arg) bound'))
                          bound'))) x
                 (snd (fst (BDDneg_1 (fst (fst arg), l, snd arg) bound')))
                 (snd
                    (fst
                       (BDDneg_1
                          (fst
                             (fst
                                (BDDneg_1 (fst (fst arg), l, snd arg) bound')),
                          r,
                          snd (BDDneg_1 (fst (fst arg), l, snd arg) bound'))
                          bound'))),
              BDDneg_memo_put
                (snd
                   (BDDneg_1
                      (fst
                         (fst (BDDneg_1 (fst (fst arg), l, snd arg) bound')),
                      r, snd (BDDneg_1 (fst (fst arg), l, snd arg) bound'))
                      bound')) (snd (fst arg))
                (snd
                   (BDDmake
                      (fst
                         (fst
                            (BDDneg_1
                               (fst
                                  (fst
                                     (BDDneg_1 (fst (fst arg), l, snd arg)
                                        bound')), r,
                               snd
                                 (BDDneg_1 (fst (fst arg), l, snd arg) bound'))
                               bound'))) x
                      (snd
                         (fst (BDDneg_1 (fst (fst arg), l, snd arg) bound')))
                      (snd
                         (fst
                            (BDDneg_1
                               (fst
                                  (fst
                                     (BDDneg_1 (fst (fst arg), l, snd arg)
                                        bound')), r,
                               snd
                                 (BDDneg_1 (fst (fst arg), l, snd arg) bound'))
                               bound'))))))
          end
      end
  end.

Lemma BDDneg_1_lemma_1 :
 forall (arg : BDDconfig * ad * BDDneg_memo) (node : ad) (bound : nat),
 BDDneg_memo_lookup (snd arg) (snd (fst arg)) = Some node ->
 BDDneg_1 arg bound = (fst (fst arg), node, snd arg).

Lemma BDDneg_1_lemma_2 :
 forall (arg : BDDconfig * ad * BDDneg_memo) (bound : nat),
 BDDneg_memo_lookup (snd arg) (snd (fst arg)) = None ->
 MapGet _ (fst (fst (fst arg))) (snd (fst arg)) = None ->
 BDDneg_1 arg bound =
 (if Neqb (snd (fst arg)) BDDzero
  then (fst (fst arg), BDDone, BDDneg_memo_put (snd arg) BDDzero BDDone)
  else (fst (fst arg), BDDzero, BDDneg_memo_put (snd arg) BDDone BDDzero)).

Lemma BDDneg_1_lemma_3 :
 forall (arg : BDDconfig * ad * BDDneg_memo) (x : BDDvar) (l r : ad),
 BDDneg_memo_lookup (snd arg) (snd (fst arg)) = None ->
 MapGet _ (fst (fst (fst arg))) (snd (fst arg)) = Some (x, (l, r)) ->
 BDDneg_1 arg 0 = (initBDDconfig, BDDzero, newMap ad).

Lemma nat_sum : forall n : nat, {m : nat | n = S m} + {n = 0}.

Lemma BDDneg_1_lemma_4 :
 forall (arg : BDDconfig * ad * BDDneg_memo) (x : BDDvar) 
   (l r : ad) (bound bound' : nat),
 bound = S bound' ->
 BDDneg_memo_lookup (snd arg) (snd (fst arg)) = None ->
 MapGet _ (fst (fst (fst arg))) (snd (fst arg)) = Some (x, (l, r)) ->
 BDDneg_1 arg bound =
 (BDDmake
    (fst
       (fst
          (BDDneg_1
             (fst (fst (BDDneg_1 (fst (fst arg), l, snd arg) bound')), r,
             snd (BDDneg_1 (fst (fst arg), l, snd arg) bound')) bound'))) x
    (snd (fst (BDDneg_1 (fst (fst arg), l, snd arg) bound')))
    (snd
       (fst
          (BDDneg_1
             (fst (fst (BDDneg_1 (fst (fst arg), l, snd arg) bound')), r,
             snd (BDDneg_1 (fst (fst arg), l, snd arg) bound')) bound'))),
 BDDneg_memo_put
   (snd
      (BDDneg_1
         (fst (fst (BDDneg_1 (fst (fst arg), l, snd arg) bound')), r,
         snd (BDDneg_1 (fst (fst arg), l, snd arg) bound')) bound'))
   (snd (fst arg))
   (snd
      (BDDmake
         (fst
            (fst
               (BDDneg_1
                  (fst (fst (BDDneg_1 (fst (fst arg), l, snd arg) bound')),
                  r, snd (BDDneg_1 (fst (fst arg), l, snd arg) bound'))
                  bound'))) x
         (snd (fst (BDDneg_1 (fst (fst arg), l, snd arg) bound')))
         (snd
            (fst
               (BDDneg_1
                  (fst (fst (BDDneg_1 (fst (fst arg), l, snd arg) bound')),
                  r, snd (BDDneg_1 (fst (fst arg), l, snd arg) bound'))
                  bound')))))).

Lemma bool_fun_restrict_neg_1 :
 forall (bf : bool_fun) (x : BDDvar) (b : bool),
 bool_fun_ext bf ->
 bool_fun_eq (bool_fun_restrict (bool_fun_neg bf) x b)
   (bool_fun_neg (bool_fun_restrict bf x b)).

Lemma bool_fun_neg_eq_var_2 :
 forall (cfg : BDDconfig) (node node' : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node ->
 is_internal_node cfg node' ->
 bool_fun_eq (bool_fun_of_BDD cfg node')
   (bool_fun_neg (bool_fun_of_BDD cfg node)) -> var cfg node = var cfg node'.

Lemma BDDneg_memo_OK_1_lemma_1_1_1 :
 forall (bound : nat) (cfg : BDDconfig) (node node' : ad),
 BDDconfig_OK cfg ->
 config_node_OK cfg node ->
 config_node_OK cfg node' ->
 (is_internal_node cfg node -> nat_of_N (var cfg node) < bound) ->
 bool_fun_eq (bool_fun_of_BDD cfg node')
   (bool_fun_neg (bool_fun_of_BDD cfg node)) ->
 BDDneg_2 cfg node bound = (cfg, node').

Lemma BDDneg_memo_OK_1_2 :
 forall (cfg : BDDconfig) (memo : BDDneg_memo),
 BDDneg_memo_OK_2 cfg memo -> BDDneg_memo_OK_1 cfg memo.

Lemma BDDneg_memo_OK_bool_fun_1 :
 forall (cfg : BDDconfig) (memo : BDDneg_memo) (node node' : ad),
 BDDconfig_OK cfg ->
 BDDneg_memo_OK_1 cfg memo ->
 config_node_OK cfg node ->
 BDDneg_memo_lookup memo node = Some node' ->
 bool_fun_eq (bool_fun_of_BDD cfg node')
   (bool_fun_neg (bool_fun_of_BDD cfg node)).

Lemma BDDneg_memo_OK_bool_fun_1' :
 forall (cfg : BDDconfig) (memo : BDDneg_memo) (node node' : ad),
 BDDconfig_OK cfg ->
 BDDneg_memo_OK_2 cfg memo ->
 config_node_OK cfg node ->
 BDDneg_memo_lookup memo node = Some node' ->
 bool_fun_eq (bool_fun_of_BDD cfg node')
   (bool_fun_neg (bool_fun_of_BDD cfg node)).

Definition nodes_preserved (cfg cfg' : BDDconfig) :=
  forall (x : BDDvar) (l r node : ad),
  MapGet _ (fst cfg) node = Some (x, (l, r)) ->
  MapGet _ (fst cfg') node = Some (x, (l, r)).

Lemma BDDmake_preserves_nodes :
 forall (cfg : BDDconfig) (x : BDDvar) (l r : ad),
 BDDconfig_OK cfg -> nodes_preserved cfg (fst (BDDmake cfg x l r)).

Lemma nodes_preserved_2 :
 forall (cfg cfg' : BDDconfig) (node : ad),
 config_node_OK cfg node ->
 nodes_preserved cfg cfg' -> config_node_OK cfg' node.

Lemma BDDneg_2_config_OK_lemma_2 :
 forall (cfg : BDDconfig) (node : ad) (x : BDDvar) (l r : ad) (n m : nat),
 BDDconfig_OK cfg ->
 MapGet _ (fst cfg) node = Some (x, (l, r)) ->
 nat_of_N (var cfg node) < n ->
 n = S m -> BDDconfig_OK (fst (BDDneg_2 (fst (BDDneg_2 cfg l m)) r m)).

Lemma nodes_preserved_1 :
 forall (cfg : BDDconfig) (node : ad) (n m : nat) (x : BDDvar) (l r : ad),
 BDDconfig_OK cfg ->
 MapGet _ (fst cfg) node = Some (x, (l, r)) ->
 n = S m ->
 nat_of_N (var cfg node) < n ->
 nodes_preserved (fst (BDDneg_2 (fst (BDDneg_2 cfg l m)) r m))
   (fst (BDDneg_2 cfg node n)).

Lemma BDDneg_memo_OK_lemma_1_4' :
 forall (cfg : BDDconfig) (memo : BDDneg_memo) (node node' : ad),
 BDDconfig_OK cfg ->
 BDDneg_memo_OK_2 cfg memo ->
 config_node_OK cfg node ->
 BDDneg_memo_lookup memo node = Some node' -> config_node_OK cfg node'. *)
Require Import bdd5_2.
(* bdd5_2:
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import ZArith NArith Nnat Ndec Ndigits.
From IntMap Require Import Allmaps.
Require Import Wf_nat.

Require Import BDDvar_ad_nat.
Require Import bdd1.
Require Import bdd2.
Require Import bdd3.
Require Import bdd4.
Require Import bdd5_1.

Lemma BDDneg_memo_OK_1_lemma_2_1' :
 forall (cfg : BDDconfig) (memo : BDDneg_memo),
 BDDconfig_OK cfg ->
 BDDneg_memo_OK_2 cfg memo ->
 BDDneg_memo_OK_2 cfg (BDDneg_memo_put memo BDDzero BDDone).

Lemma BDDneg_memo_OK_1_lemma_3_1' :
 forall (cfg : BDDconfig) (memo : BDDneg_memo),
 BDDconfig_OK cfg ->
 BDDneg_memo_OK_2 cfg memo ->
 BDDneg_memo_OK_2 cfg (BDDneg_memo_put memo BDDone BDDzero).

Lemma BDDneg_memo_OK_1_lemma_1_2' :
 forall (cfg : BDDconfig) (x : BDDvar) (l r node : ad) 
   (n m : nat) (memo : BDDneg_memo),
 BDDconfig_OK cfg ->
 MapGet _ (fst cfg) node = Some (x, (l, r)) ->
 nat_of_N (var cfg node) < n ->
 n = S m ->
 BDDneg_memo_OK_2 (fst (BDDneg_2 (fst (BDDneg_2 cfg l m)) r m)) memo ->
 BDDneg_memo_OK_2 (fst (BDDneg_2 cfg node n))
   (BDDneg_memo_put memo node (snd (BDDneg_2 cfg node n))).

Lemma BDDneg_1_lemma' :
 forall (bound : nat) (arg : BDDconfig * ad * BDDneg_memo),
 BDDconfig_OK (fst (fst arg)) ->
 config_node_OK (fst (fst arg)) (snd (fst arg)) ->
 BDDneg_memo_OK_2 (fst (fst arg)) (snd arg) ->
 (is_internal_node (fst (fst arg)) (snd (fst arg)) ->
  nat_of_N (var (fst (fst arg)) (snd (fst arg))) < bound) ->
 fst (BDDneg_1 arg bound) = BDDneg_2 (fst (fst arg)) (snd (fst arg)) bound /\
 BDDneg_memo_OK_2 (fst (fst (BDDneg_1 arg bound))) (snd (BDDneg_1 arg bound)). *)

Lemma nodes_preserved_trans :
 forall cfg1 cfg2 cfg3 : BDDconfig,
 nodes_preserved cfg1 cfg2 ->
 nodes_preserved cfg2 cfg3 -> nodes_preserved cfg1 cfg3.
Proof.
unfold nodes_preserved in |- *; intros.  apply H0.  apply H.  assumption.
Qed.

Lemma nodes_preserved_var :
 forall (cfg cfg' : BDDconfig) (node : ad),
 nodes_preserved cfg cfg' ->
 is_internal_node cfg node -> var cfg' node = var cfg node.
Proof.
  unfold nodes_preserved, is_internal_node in |- *.  intros.  inversion H0.  inversion H1.
  inversion H2.  unfold var in |- *.  rewrite H3.  rewrite (H x x0 x1 node H3).  reflexivity.
Qed.

Lemma nodes_preserved_var_1 :
 forall (cfg cfg' : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 BDDconfig_OK cfg' ->
 nodes_preserved cfg cfg' ->
 config_node_OK cfg node -> var cfg' node = var cfg node.
Proof.
  intros.  unfold var in |- *.  elim H2; intro.  rewrite H3.  rewrite (config_OK_zero cfg H).
  rewrite (config_OK_zero cfg' H0).  reflexivity.  elim H3; intro.  rewrite H4.
  rewrite (config_OK_one cfg H).  rewrite (config_OK_one cfg' H0).  reflexivity.
  cut (is_internal_node cfg node).  intro.  inversion H5.  inversion H6.  inversion H7.
  rewrite H8.  unfold nodes_preserved in H1.  rewrite (H1 x x0 x1 node H8).
  reflexivity.  apply in_dom_is_internal.  assumption.
Qed.

Lemma nodes_preserved_3 :
 forall (cfg cfg' : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 BDDconfig_OK cfg' ->
 nodes_preserved cfg cfg' ->
 config_node_OK cfg node ->
 bool_fun_eq (bool_fun_of_BDD cfg' node) (bool_fun_of_BDD cfg node).
Proof.
  intros cfg cfg' node H H0 H1 H2.  apply bool_fun_preservation.  assumption.  assumption.  unfold nodes_preserved in H1.
  intros x l r a H3.  apply H1.  assumption.  assumption.
Qed.

Lemma bool_fun_or_preserves_eq :
 forall bf1 bf2 bf1' bf2' : bool_fun,
 bool_fun_eq bf1 bf1' ->
 bool_fun_eq bf2 bf2' ->
 bool_fun_eq (bool_fun_or bf1 bf2) (bool_fun_or bf1' bf2').
Proof.
  unfold bool_fun_eq in |- *.  intros bf1 bf2 bf1' bf2' H H0 vb.  unfold bool_fun_or in |- *.  unfold bool_fun_eval in |- *.
  unfold bool_fun_eval in H, H0.  rewrite (H vb).  rewrite (H0 vb).  reflexivity.
Qed.

Definition BDDvar_le := Nleb.
Definition BDDvar_max (x y : BDDvar) := if BDDvar_le x y then y else x.

Lemma BDDvar_max_comm : forall x y : BDDvar, BDDvar_max x y = BDDvar_max y x.
Proof.
  unfold BDDvar_max in |- *.  unfold BDDvar_le in |- *.  intros x y.  elim (sumbool_of_bool (Nleb x y)).
  intro y0.  rewrite y0.  elim (sumbool_of_bool (Nleb y x)).  intro y1.  rewrite y1.
  apply Nleb_antisym.  assumption.  assumption.  intro y1.  rewrite y1.  reflexivity.
  intro y0.  rewrite y0.  elim (sumbool_of_bool (Nleb y x)).  intro y1.  rewrite y1.
  reflexivity.  intro y1.  rewrite y1.  apply Nleb_antisym.  apply Nltb_leb_weak.
  assumption.  apply Nltb_leb_weak.  assumption.
Qed.

Lemma BDDvar_max_lemma_1 :
 forall x y z : BDDvar,
 BDDcompare x y = Datatypes.Lt ->
 BDDcompare (BDDvar_max x N0) (BDDvar_max y z) = Datatypes.Lt.
Proof.
  intros x y z.  rewrite (BDDvar_max_comm x N0).  unfold BDDvar_max in |- *.  simpl in |- *.
  intro H.  unfold BDDvar_le in |- *.  unfold Nleb in |- *.  elim (sumbool_of_bool (leb (nat_of_N y) (nat_of_N z))).
  intro y0.  rewrite y0.  apply BDDlt_compare.  apply lt_le_trans with (m := nat_of_N y).
  apply BDDcompare_lt.  assumption.  apply leb_complete.  assumption.  intro y0.
  rewrite y0.  assumption.  
Qed.

Lemma BDDvar_le_z : forall x : BDDvar, BDDvar_le N0 x = true.
Proof.
  intro x.  unfold BDDvar_le in |- *.  unfold Nleb in |- *.  simpl in |- *.  reflexivity.
Qed.

Lemma BDDvar_le_compare :
 forall x y : BDDvar, BDDcompare x y = Datatypes.Lt -> BDDvar_le x y = true.
Proof.
  intros x y H.  unfold BDDvar_le in |- *.  unfold Nleb in |- *.  apply leb_correct.  apply lt_le_weak.
  apply BDDcompare_lt.  assumption.
Qed.

Lemma BDDcompare_max_1_2 :
 forall x1 x2 y1 y2 : BDDvar,
 BDDcompare x1 x2 = Datatypes.Lt ->
 BDDcompare y1 y2 = Datatypes.Lt ->
 BDDcompare (BDDvar_max x1 y1) (BDDvar_max x2 y2) = Datatypes.Lt.
Proof.
  unfold BDDvar_max in |- *.  unfold BDDvar_le in |- *.  unfold Nleb in |- *.  intros x1 x2 y1 y2 H H0.  elim (sumbool_of_bool (leb (nat_of_N x1) (nat_of_N y1))).
  intro y.  rewrite y.  elim (sumbool_of_bool (leb (nat_of_N x2) (nat_of_N y2))).
  intro y0.  rewrite y0.  assumption.  intro y0.  rewrite y0.  apply BDDlt_compare.
  apply lt_trans with (m := nat_of_N y2).  apply BDDcompare_lt.  assumption.
  apply leb_complete_conv.  assumption.  intro y.  rewrite y.  elim (sumbool_of_bool (leb (nat_of_N x2) (nat_of_N y2))).
  intro y0.  rewrite y0.  apply BDDlt_compare.  apply lt_le_trans with (m := nat_of_N x2).
  apply BDDcompare_lt.  assumption.  apply leb_complete.  assumption.
  intro y0.  rewrite y0.  assumption.
Qed.

Lemma BDDcompare_z_nz :
 forall x : BDDvar, x <> N0 -> BDDcompare N0 x = Datatypes.Lt.
Proof.
  simple induction x.  intros H.  absurd (N0 = N0).  assumption.  reflexivity.  simpl in |- *.  reflexivity.
Qed.

Lemma BDDvar_max_x_x : forall x : BDDvar, BDDvar_max x x = x.
Proof.
  unfold BDDvar_max in |- *.  unfold BDDvar_le in |- *.  intro x.  rewrite (Nleb_refl x).  reflexivity.
Qed.

Lemma BDDvar_ordered_high_1 :
 forall (cfg : BDDconfig) (node1 node2 : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node1 ->
 is_internal_node cfg node2 ->
 is_internal_node cfg (high cfg node1) \/
 is_internal_node cfg (high cfg node2) ->
 BDDcompare
   (BDDvar_max (var cfg (high cfg node1)) (var cfg (high cfg node2)))
   (BDDvar_max (var cfg node1) (var cfg node2)) = Datatypes.Lt.
Proof.
  intros cfg node1 node2 H H0 H1 H2.  cut (config_node_OK cfg (high cfg node1)).  cut (config_node_OK cfg (high cfg node2)).
  intros H3 H4.  elim H2; intro.  cut (BDDcompare (var cfg (high cfg node1)) (var cfg node1) = Datatypes.Lt).
  intro H6.  elim H3; intro.  rewrite H7.  unfold var at 2 in |- *.  rewrite (config_OK_zero cfg H).
  unfold BDDzero in |- *.  apply BDDvar_max_lemma_1.  assumption.  elim H7; intro.
  rewrite H8.  unfold var at 2 in |- *.  rewrite (config_OK_one cfg H).  unfold BDDzero in |- *.
  apply BDDvar_max_lemma_1.  assumption.  apply BDDcompare_max_1_2.  assumption.
  apply BDDvar_ordered_high.  assumption.  assumption.  apply in_dom_is_internal.
  assumption.  apply BDDvar_ordered_high.  assumption.  assumption.  assumption.
  elim H4; intro.  rewrite H6.  unfold var at 1 in |- *.  rewrite (config_OK_zero cfg H).
  unfold BDDzero in |- *.  rewrite (BDDvar_max_comm N0 (var cfg (high cfg node2))).
  rewrite (BDDvar_max_comm (var cfg node1) (var cfg node2)).  apply BDDvar_max_lemma_1.
  apply BDDvar_ordered_high.  assumption.  assumption.  assumption.  elim H6; intro.
  rewrite H7.  unfold var at 1 in |- *.  rewrite (config_OK_one cfg H).  unfold BDDzero in |- *.
  rewrite (BDDvar_max_comm N0 (var cfg (high cfg node2))).  rewrite (BDDvar_max_comm (var cfg node1) (var cfg node2)).
  apply BDDvar_max_lemma_1.  apply BDDvar_ordered_high.  assumption.  assumption.
  assumption.  apply BDDcompare_max_1_2.  apply BDDvar_ordered_high.  assumption.  
  assumption.  apply in_dom_is_internal; assumption.  apply BDDvar_ordered_high.
  assumption.  assumption.  assumption.  apply high_OK.  assumption.  assumption.
  apply high_OK.  assumption.  assumption.
Qed.

Lemma BDDvar_ordered_low_1 :
 forall (cfg : BDDconfig) (node1 node2 : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node1 ->
 is_internal_node cfg node2 ->
 is_internal_node cfg (low cfg node1) \/ is_internal_node cfg (low cfg node2) ->
 BDDcompare (BDDvar_max (var cfg (low cfg node1)) (var cfg (low cfg node2)))
   (BDDvar_max (var cfg node1) (var cfg node2)) = Datatypes.Lt.
Proof.
 intros cfg node1 node2 H H0 H1 H2.  cut (config_node_OK cfg (low cfg node1)).  cut (config_node_OK cfg (low cfg node2)).
  intros H3 H4.  elim H2; intro.  cut (BDDcompare (var cfg (low cfg node1)) (var cfg node1) = Datatypes.Lt).
  intro H6.  elim H3; intro.  rewrite H7.  unfold var at 2 in |- *.  rewrite (config_OK_zero cfg H).
  unfold BDDzero in |- *.  apply BDDvar_max_lemma_1.  assumption.  elim H7; intro.
  rewrite H8.  unfold var at 2 in |- *.  rewrite (config_OK_one cfg H).  unfold BDDzero in |- *.
  apply BDDvar_max_lemma_1.  assumption.  apply BDDcompare_max_1_2.  assumption.
  apply BDDvar_ordered_low.  assumption.  assumption.  apply in_dom_is_internal.
  assumption.  apply BDDvar_ordered_low.  assumption.  assumption.  assumption.
  elim H4; intro.  rewrite H6.  unfold var at 1 in |- *.  rewrite (config_OK_zero cfg H).
  unfold BDDzero in |- *.  rewrite (BDDvar_max_comm N0 (var cfg (low cfg node2))).
  rewrite (BDDvar_max_comm (var cfg node1) (var cfg node2)).  apply BDDvar_max_lemma_1.
  apply BDDvar_ordered_low.  assumption.  assumption.  assumption.  elim H6; intro.
  rewrite H7.  unfold var at 1 in |- *.  rewrite (config_OK_one cfg H).  unfold BDDzero in |- *.
  rewrite (BDDvar_max_comm N0 (var cfg (low cfg node2))).  rewrite (BDDvar_max_comm (var cfg node1) (var cfg node2)).
  apply BDDvar_max_lemma_1.  apply BDDvar_ordered_low.  assumption.  assumption.
  assumption.  apply BDDcompare_max_1_2.  apply BDDvar_ordered_low.  assumption.
  assumption.  apply in_dom_is_internal; assumption.  apply BDDvar_ordered_low.
  assumption.  assumption.  assumption.  apply low_OK.  assumption.  assumption.
  apply low_OK.  assumption.  assumption.
Qed.

Lemma BDDvar_ordered_high_2 :
 forall (cfg : BDDconfig) (node1 node2 : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node1 ->
 is_internal_node cfg node2 ->
 BDDcompare (var cfg node1) (var cfg node2) = Datatypes.Lt ->
 BDDcompare (BDDvar_max (var cfg node1) (var cfg (high cfg node2)))
   (var cfg node2) = Datatypes.Lt. 
Proof.
  intros cfg node1 node2 H H0 H1 H2.  cut (var cfg node2 = BDDvar_max (var cfg node2) (var cfg node2)).
  intro H3.  rewrite H3.  apply BDDcompare_max_1_2.  assumption.  cut (config_node_OK cfg (high cfg node2)).
  intro H4.  elim H4; intro.  rewrite H5.  unfold var at 1 in |- *.  rewrite (config_OK_zero cfg H).
  unfold BDDzero in |- *.  apply BDDcompare_z_nz.  apply INFERIEUR_neq_O with (x := var cfg node1).
  assumption.  elim H5; intro.  rewrite H6.  unfold var at 1 in |- *.  rewrite (config_OK_one cfg H).
  unfold BDDzero in |- *.  apply BDDcompare_z_nz.  apply INFERIEUR_neq_O with (x := var cfg node1).
  assumption.  apply BDDvar_ordered_high.  assumption.  assumption.  apply in_dom_is_internal.
  assumption.  apply high_OK.  assumption.  assumption.  rewrite (BDDvar_max_x_x (var cfg node2)).
  reflexivity.
Qed.

Lemma BDDvar_ordered_low_2 :
 forall (cfg : BDDconfig) (node1 node2 : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node1 ->
 is_internal_node cfg node2 ->
 BDDcompare (var cfg node1) (var cfg node2) = Datatypes.Lt ->
 BDDcompare (BDDvar_max (var cfg node1) (var cfg (low cfg node2)))
   (var cfg node2) = Datatypes.Lt.
Proof.
  intros cfg node1 node2 H H0 H1 H2.  cut (var cfg node2 = BDDvar_max (var cfg node2) (var cfg node2)).
  intro H3.  rewrite H3.  apply BDDcompare_max_1_2.  assumption.  cut (config_node_OK cfg (low cfg node2)).
  intro H4.  elim H4; intro.  rewrite H5.  unfold var at 1 in |- *.  rewrite (config_OK_zero cfg H).
  unfold BDDzero in |- *.  apply BDDcompare_z_nz.  apply INFERIEUR_neq_O with (x := var cfg node1).
  assumption.  elim H5; intro.  rewrite H6.  unfold var at 1 in |- *.  rewrite (config_OK_one cfg H).
  unfold BDDzero in |- *.  apply BDDcompare_z_nz.  apply INFERIEUR_neq_O with (x := var cfg node1).
  assumption.  apply BDDvar_ordered_low.  assumption.  assumption.  apply in_dom_is_internal.
  assumption.  apply low_OK.  assumption.  assumption.  rewrite (BDDvar_max_x_x (var cfg node2)).
  reflexivity.
Qed.

Lemma BDDvar_ordered_high_3 :
 forall (cfg : BDDconfig) (node1 node2 : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node1 ->
 is_internal_node cfg node2 ->
 BDDcompare (var cfg node2) (var cfg node1) = Datatypes.Lt ->
 BDDcompare (BDDvar_max (var cfg (high cfg node1)) (var cfg node2))
   (var cfg node1) = Datatypes.Lt.
Proof.
  intros cfg node1 node2 H H0 H1 H2.  rewrite (BDDvar_max_comm (var cfg (high cfg node1)) (var cfg node2)).
  apply BDDvar_ordered_high_2.  assumption.  assumption.  assumption.  assumption.
Qed.

Lemma BDDvar_ordered_low_3 :
 forall (cfg : BDDconfig) (node1 node2 : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node1 ->
 is_internal_node cfg node2 ->
 BDDcompare (var cfg node2) (var cfg node1) = Datatypes.Lt ->
 BDDcompare (BDDvar_max (var cfg (low cfg node1)) (var cfg node2))
   (var cfg node1) = Datatypes.Lt.
Proof.
  intros cfg node1 node2 H H0 H1 H2.  rewrite (BDDvar_max_comm (var cfg (low cfg node1)) (var cfg node2)).
  apply BDDvar_ordered_low_2.  assumption.  assumption.  assumption.  assumption.
Qed.

Lemma lt_max_nat_of_N :
 forall x y z : BDDvar,
 BDDcompare (BDDvar_max x y) z = Datatypes.Lt ->
 max (nat_of_N x) (nat_of_N y) < nat_of_N z.
Proof.
  unfold BDDvar_max in |- *.  unfold BDDvar_le in |- *.  intros x y z.  elim (sumbool_of_bool (Nleb x y)).
  intro y0.  rewrite y0.  intro H.  unfold max in |- *.  elim (sumbool_of_bool (leb (nat_of_N x) (nat_of_N y))).
  intro y1.  rewrite y1.  apply BDDcompare_lt.  assumption.  intro y1.  rewrite y1.
  apply le_lt_trans with (m := nat_of_N y).  apply leb_complete.  exact y0.  
  apply BDDcompare_lt.  assumption.  intro y0.  rewrite y0.  intro H.  unfold max in |- *.
  elim (sumbool_of_bool (leb (nat_of_N x) (nat_of_N y))).  intro y1.  cut (Nleb x y = true).
  intro H0.  rewrite H0 in y0.  discriminate.  exact y1.  intro y1.  rewrite y1.
  apply BDDcompare_lt.  assumption.
Qed.

Lemma le_nat_of_N_max :
 forall x y z : BDDvar,
 BDDvar_le x (BDDvar_max y z) = true ->
 nat_of_N x <= max (nat_of_N y) (nat_of_N z).
Proof.
  unfold BDDvar_max in |- *.  unfold BDDvar_le in |- *.  intros x y z.  elim (sumbool_of_bool (Nleb y z)).
  intro y0.  rewrite y0.  intro H.  unfold max in |- *.  elim (sumbool_of_bool (leb (nat_of_N y) (nat_of_N z))).
  intro y1.  rewrite y1.  apply leb_complete.  assumption.  unfold Nleb in y0.
  rewrite y0.  intro y1.  discriminate.  intro y0.  rewrite y0.  intro H.  unfold max in |- *.
  unfold Nleb in y0, H.  rewrite y0.  apply leb_complete.  assumption.
Qed.

Definition bool_fun_if (x : BDDvar) (bf bf' : bool_fun) : bool_fun :=
  fun vb : var_binding => ifb (vb x) (bf vb) (bf' vb).
  
Lemma nodes_preserved_internal :
 forall (cfg cfg' : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 BDDconfig_OK cfg' ->
 config_node_OK cfg node ->
 is_internal_node cfg' node -> is_internal_node cfg node.
Proof.
  intros cfg cfg' node H H0 H1 H2.  inversion H2.  inversion H3.  inversion H4.  elim H1.  intro H6.  rewrite H6 in H5.
  rewrite (config_OK_zero cfg' H0) in H5.  discriminate.  intro H6.  elim H6; intro.
  rewrite H7 in H5.  rewrite (config_OK_one cfg' H0) in H5.  discriminate.
  apply in_dom_is_internal.  assumption.
Qed.

Lemma bool_fun_if_preserves_eq :
 forall (x : BDDvar) (bf1 bf2 bf1' bf2' : bool_fun),
 bool_fun_eq bf1 bf1' ->
 bool_fun_eq bf2 bf2' ->
 bool_fun_eq (bool_fun_if x bf1 bf2) (bool_fun_if x bf1' bf2').
Proof.
  unfold bool_fun_eq, bool_fun_if in |- *.  unfold bool_fun_eval in |- *.  intros x bf1 bf2 bf1' bf2' H H0 vb.  rewrite (H vb).
rewrite (H0 vb).  reflexivity.
Qed.

Lemma BDDmake_var_order :
 forall (cfg : BDDconfig) (l r : ad) (x : BDDvar),
 BDDconfig_OK cfg ->
 config_node_OK cfg l ->
 config_node_OK cfg r ->
 (is_internal_node cfg l -> BDDcompare (var cfg l) x = Datatypes.Lt) ->
 (is_internal_node cfg r -> BDDcompare (var cfg r) x = Datatypes.Lt) ->
 BDDvar_le (var (fst (BDDmake cfg x l r)) (snd (BDDmake cfg x l r))) x = true. 
Proof.
  intros cfg l r x H H0 H1 H2 H3.  cut
   (forall (xl : BDDvar) (ll rl : ad),
    MapGet _ (fst cfg) l = Some (xl, (ll, rl)) ->
    BDDcompare xl x = Datatypes.Lt).
  cut
   (forall (xr : BDDvar) (lr rr : ad),
    MapGet _ (fst cfg) r = Some (xr, (lr, rr)) ->
    BDDcompare xr x = Datatypes.Lt).
  intros H4 H5.  cut (node_OK (fst cfg) l).  cut (node_OK (fst cfg) r).  intros H6 H7.
  cut
   (BDDconfig_OK (fst (BDDmake cfg x l r)) /\
    (Neqb l r = false ->
     MapGet _ (fst (fst (BDDmake cfg x l r))) (snd (BDDmake cfg x l r)) =
     Some (x, (l, r))) /\
    (Neqb l r = true -> snd (BDDmake cfg x l r) = l) /\
    (forall (a l' r' : ad) (x' : BDDvar),
     (MapGet _ (fst (fst (BDDmake cfg x l r))) a = Some (x', (l', r')) ->
      MapGet _ (fst cfg) a = Some (x', (l', r')) \/
      snd (BDDmake cfg x l r) = a) /\
     (MapGet _ (fst cfg) a = Some (x', (l', r')) ->
      MapGet _ (fst (fst (BDDmake cfg x l r))) a = Some (x', (l', r')))) /\
    node_OK (fst (fst (BDDmake cfg x l r))) (snd (BDDmake cfg x l r))).
  intros H8.  elim H8; clear H8; intros.  elim H9; clear H9; intros.  elim H10; clear H10; intros.
  elim H11; clear H11; intros.  elim (sumbool_of_bool (Neqb l r)).  intro y.
  rewrite (H10 y).  unfold var in |- *.  elim (option_sum _ (MapGet _ (fst cfg) l)); intro y0.
  elim y0.  intro x0.  elim x0.  intro y1; intro y2.  elim y2.  intros y3 y4 y5.  rewrite (proj2 (H11 l y3 y4 y1) y5).
  rewrite y5 in H5.  cut (BDDcompare y1 x = Datatypes.Lt).  intro H13.  apply BDDvar_le_compare.
  assumption.  apply H5 with (ll := y3) (rl := y4).  reflexivity.  elim H7; intro.
  rewrite H13.  rewrite H13 in H8.  rewrite (config_OK_zero (fst (BDDmake cfg x BDDzero r)) H8).
  unfold BDDzero in |- *.  apply BDDvar_le_z.  elim H13.  intro H14.  rewrite H14.  rewrite H14 in H8.
  rewrite (config_OK_one (fst (BDDmake cfg x BDDone r)) H8).  unfold BDDzero in |- *.
  apply BDDvar_le_z.  intro H14.  unfold in_dom in H14.  rewrite y0 in H14.  discriminate.
  intro y.  unfold var in |- *.  rewrite (H9 y).  unfold BDDvar_le in |- *.  unfold Nleb in |- *.  apply leb_correct.
  apply le_n.  apply BDDmake_semantics.  assumption.  assumption.  assumption.
  assumption.  assumption.  assumption.  assumption.  intros xr lr rr H4.  unfold is_internal_node in H3.
  unfold var in H3.  rewrite H4 in H3.  apply H3.  split with xr.  split with lr.
  split with rr.  reflexivity.  intros xl ll rl H4.  unfold is_internal_node in H2.  unfold var in H2.
  rewrite H4 in H2.  apply H2.  split with xl.  split with ll.  split with rl.
  reflexivity.
Qed.

Lemma BDDmake_bool_fun :
 forall (cfg : BDDconfig) (l r : ad) (x : BDDvar),
 BDDconfig_OK cfg ->
 config_node_OK cfg l ->
 config_node_OK cfg r ->
 (is_internal_node cfg l -> BDDcompare (var cfg l) x = Datatypes.Lt) ->
 (is_internal_node cfg r -> BDDcompare (var cfg r) x = Datatypes.Lt) ->
 bool_fun_eq
   (bool_fun_of_BDD (fst (BDDmake cfg x l r)) (snd (BDDmake cfg x l r)))
   (bool_fun_if x (bool_fun_of_BDD cfg r) (bool_fun_of_BDD cfg l)).
Proof.
  intros cfg l r x H H0 H1 H2 H3.  cut
   (forall (xl : BDDvar) (ll rl : ad),
    MapGet _ (fst cfg) l = Some (xl, (ll, rl)) ->
    BDDcompare xl x = Datatypes.Lt).
  cut
   (forall (xr : BDDvar) (lr rr : ad),
    MapGet _ (fst cfg) r = Some (xr, (lr, rr)) ->
    BDDcompare xr x = Datatypes.Lt).
  intros H4 H5.  cut (node_OK (fst cfg) l).  cut (node_OK (fst cfg) r).  intros H6 H7.
  cut
   (BDDconfig_OK (fst (BDDmake cfg x l r)) /\
    (Neqb l r = false ->
     MapGet _ (fst (fst (BDDmake cfg x l r))) (snd (BDDmake cfg x l r)) =
     Some (x, (l, r))) /\
    (Neqb l r = true -> snd (BDDmake cfg x l r) = l) /\
    (forall (a l' r' : ad) (x' : BDDvar),
     (MapGet _ (fst (fst (BDDmake cfg x l r))) a = Some (x', (l', r')) ->
      MapGet _ (fst cfg) a = Some (x', (l', r')) \/
      snd (BDDmake cfg x l r) = a) /\
     (MapGet _ (fst cfg) a = Some (x', (l', r')) ->
      MapGet _ (fst (fst (BDDmake cfg x l r))) a = Some (x', (l', r')))) /\
    node_OK (fst (fst (BDDmake cfg x l r))) (snd (BDDmake cfg x l r))).
  intros H8.  elim H8; clear H8; intros.  elim H9; clear H9; intros.  elim H10; clear H10; intros.
  elim H11; clear H11; intros.  elim (sumbool_of_bool (Neqb l r)).  intro y.
  rewrite (H10 y).  apply bool_fun_eq_trans with (bf2 := bool_fun_of_BDD cfg l).
  apply bool_fun_preservation.  assumption.  assumption.  intros x0 l0 r0 a H13.  exact (proj2 (H11 a l0 r0 x0) H13).
  assumption.  cut (l = r).  intro H13.  rewrite <- H13.  unfold bool_fun_if in |- *.  unfold bool_fun_eq in |- *.
  unfold bool_fun_eval in |- *.  intro vb.  elim (vb x).  simpl in |- *.  reflexivity.  simpl in |- *.  reflexivity.  
  apply Neqb_complete.  assumption.  intro y.  cut (is_internal_node (fst (BDDmake cfg x l r)) (snd (BDDmake cfg x l r))).
  intro H13.  rewrite
   (proj2 (proj2 (bool_fun_of_BDD_semantics (fst (BDDmake cfg x l r)) H8))
      (snd (BDDmake cfg x l r)) H13).
  unfold bool_fun_eq in |- *.  intro vb.  unfold bool_fun_eval in |- *.  unfold var in |- *.  rewrite (H9 y).
  unfold bool_fun_if in |- *.  unfold ifb in |- *.  unfold high, low in |- *.  rewrite (H9 y).
  cut
   (bool_fun_eq (bool_fun_of_BDD (fst (BDDmake cfg x l r)) r)
      (bool_fun_of_BDD cfg r)).
  cut
   (bool_fun_eq (bool_fun_of_BDD (fst (BDDmake cfg x l r)) l)
      (bool_fun_of_BDD cfg l)).
  intros H14 H15.  unfold bool_fun_eq in H14, H15.  unfold bool_fun_eval in H14, H15.  rewrite (H14 vb).
  rewrite (H15 vb).  reflexivity.  apply bool_fun_preservation.  assumption.
  assumption.  intros x0 l0 r0 a H14.  exact (proj2 (H11 a l0 r0 x0) H14).  assumption.
  apply bool_fun_preservation.  assumption.  intros.  assumption.  intros x0 l0 r0 a H14.
  exact (proj2 (H11 a l0 r0 x0) H14).  assumption.  split with x.  split with l.
  split with r.  apply H9.  assumption.  apply BDDmake_semantics.  assumption.  
  assumption.  assumption.  assumption.  assumption.  assumption.  assumption.
  intros xr lr rr H4.  intros.  unfold is_internal_node in H3.  unfold var in H3.  rewrite H4 in H3.
  apply H3.  split with xr.  split with lr.  split with rr.  reflexivity.  intros xl ll rl H4.
  unfold is_internal_node in H2.  unfold var in H2.  rewrite H4 in H2.  apply H2.
  split with xl.  split with ll.  split with rl.  reflexivity.  
Qed.

Lemma bool_fun_or_commute :
 forall bf bf' : bool_fun,
 bool_fun_eq (bool_fun_or bf bf') (bool_fun_or bf' bf).
Proof.
  unfold bool_fun_eq, bool_fun_or in |- *.  unfold bool_fun_eval, bool_fun_or in |- *.  intros bf bf' vb.
  apply orb_comm.
Qed.

Lemma bool_fun_or_zero :
 forall bf : bool_fun, bool_fun_eq (bool_fun_or bf bool_fun_zero) bf.
Proof.
  unfold bool_fun_eq, bool_fun_zero in |- *.  unfold bool_fun_or in |- *.  unfold bool_fun_eval in |- *. 
  intros bf vb.  elim (bf vb).  simpl in |- *.  reflexivity.  simpl in |- *.  reflexivity.
Qed.

Lemma bool_fun_or_one :
 forall bf : bool_fun, bool_fun_eq (bool_fun_or bf bool_fun_one) bool_fun_one.
Proof.
  unfold bool_fun_eq, bool_fun_or, bool_fun_one in |- *.  unfold bool_fun_eval in |- *.  intros bf vb.
  elim (bf vb).  simpl in |- *.  reflexivity.  simpl in |- *.  reflexivity.
Qed.

Lemma bool_fun_if_lemma_1 :
 forall (x : BDDvar) (bfl1 bfl2 bfr1 bfr2 : bool_fun),
 bool_fun_eq (bool_fun_if x (bool_fun_or bfr1 bfr2) (bool_fun_or bfl1 bfl2))
   (bool_fun_or (bool_fun_if x bfr1 bfl1) (bool_fun_if x bfr2 bfl2)).
Proof.
  unfold bool_fun_eq, bool_fun_or, bool_fun_if in |- *.  unfold bool_fun_eval in |- *.  intros x bfl1 bfl2 bfr1 bfr2 vb.
  elim (vb x); simpl in |- *.  reflexivity.  reflexivity.
Qed.

Lemma bool_fun_if_lemma_3 :
 forall (x : BDDvar) (bf1 bfl2 bfr2 : bool_fun),
 bool_fun_eq (bool_fun_if x (bool_fun_or bf1 bfr2) (bool_fun_or bf1 bfl2))
   (bool_fun_or bf1 (bool_fun_if x bfr2 bfl2)).
Proof.
  unfold bool_fun_eq, bool_fun_or, bool_fun_if in |- *.  unfold bool_fun_eval in |- *.  intros x bf1 bfl2 bfr2 vb.
  elim (vb x); simpl in |- *.  reflexivity.  reflexivity.
Qed.

Lemma bool_fun_if_lemma_4 :
 forall (x : BDDvar) (bfl1 bfr1 bf2 : bool_fun),
 bool_fun_eq (bool_fun_if x (bool_fun_or bfr1 bf2) (bool_fun_or bfl1 bf2))
   (bool_fun_or (bool_fun_if x bfr1 bfl1) bf2).
Proof.
  unfold bool_fun_eq, bool_fun_or, bool_fun_if in |- *.  unfold bool_fun_eval in |- *.  intros x bfl1 bfr1 bf2 vb.
  elim (vb x); simpl in |- *.  reflexivity.  reflexivity.
Qed.

Lemma bool_fun_if_lemma_2 :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node ->
 bool_fun_eq (bool_fun_of_BDD cfg node)
   (bool_fun_if (var cfg node) (bool_fun_of_BDD cfg (high cfg node))
      (bool_fun_of_BDD cfg (low cfg node))).
Proof.
  intros cfg node H H0.  rewrite (proj2 (proj2 (bool_fun_of_BDD_semantics cfg H)) node H0).
  unfold bool_fun_eq in |- *.  unfold bool_fun_eval in |- *.  unfold bool_fun_if in |- *.  unfold ifb in |- *.
  reflexivity.
Qed.

Lemma BDD_EGAL_correct : forall x y : BDDvar, BDDcompare x x = Datatypes.Eq.
Proof.
  simple induction x.  reflexivity.  simpl in |- *.  intros x0 y.  apply Pcompare_refl.
Qed.

Lemma BDD_EGALsymm :
 forall x y : BDDvar,
 BDDcompare x y = Datatypes.Eq -> BDDcompare y x = Datatypes.Eq.
Proof.
  intros x y H.  cut (x = y).  intros H0.  rewrite H0.  apply BDD_EGAL_correct.  assumption.
  apply BDD_EGAL_complete.  assumption.
Qed.

Lemma BDDcompare_le_INFERIEUR_1 :
 forall x y z : BDDvar,
 BDDvar_le x y = true ->
 BDDcompare y z = Datatypes.Lt -> BDDcompare x z = Datatypes.Lt.
Proof.
  intros x y z H H0.  apply BDDlt_compare.  apply le_lt_trans with (m := nat_of_N y).  unfold BDDvar_le in H.
  unfold Nleb in H.  apply leb_complete; assumption.  apply BDDcompare_lt.
  assumption.
Qed.

Definition BDDor_memo := Map (Map ad).
Definition initBDDor_memo := newMap (Map ad).

Definition BDDor_memo_put (memo : BDDor_memo) (node1 node2 node : ad) :=
  let m1 :=
    match MapGet _ memo node1 with
    | Some y => y
    | None => newMap ad
    end in
  let m1' := MapPut _ m1 node2 node in MapPut _ memo node1 m1'.

Definition BDDor_memo_lookup (memo : BDDor_memo) (node1 node2 : ad) :=
  match MapGet _ memo node1 with
  | None => None
  | Some m1 =>
      match MapGet _ m1 node2 with
      | None => None
      | Some node => Some node
      end
  end. 

Definition BDDor_memo_OK (cfg : BDDconfig) (memo : BDDor_memo) :=
  forall node1 node2 node : ad,
  BDDor_memo_lookup memo node1 node2 = Some node ->
  config_node_OK cfg node1 /\
  config_node_OK cfg node2 /\
  config_node_OK cfg node /\
  BDDvar_le (var cfg node) (BDDvar_max (var cfg node1) (var cfg node2)) =
  true /\
  bool_fun_eq (bool_fun_of_BDD cfg node)
    (bool_fun_or (bool_fun_of_BDD cfg node1) (bool_fun_of_BDD cfg node2)).

Lemma BDDor_memo_lookup_semantics :
 forall (memo : BDDor_memo) (node1 node2 node node1' node2' : ad),
 BDDor_memo_lookup (BDDor_memo_put memo node1 node2 node) node1' node2' =
 (if Neqb node1 node1' && Neqb node2 node2'
  then Some node
  else BDDor_memo_lookup memo node1' node2').
Proof.
  intros memo node1 node2 node node1' node2'.  unfold BDDor_memo_lookup, BDDor_memo_put in |- *.  rewrite
   (MapPut_semantics (Map ad) memo node1
      (MapPut ad
         match MapGet (Map ad) memo node1 with
         | None => newMap ad
         | Some y => y
         end node2 node) node1').
  elim (sumbool_of_bool (Neqb node1 node1')); intro y.  rewrite y.
  rewrite
   (MapPut_semantics ad
      match MapGet (Map ad) memo node1 with
      | None => newMap ad
      | Some y => y
      end node2 node node2').
  elim (sumbool_of_bool (Neqb node2 node2')).  intro y0.  rewrite y0.  simpl in |- *.
  reflexivity.  intro y0.  rewrite y0.  simpl in |- *.  elim (option_sum _ (MapGet (Map ad) memo node1)).
  intro y1.  inversion y1.  rewrite H.  cut (node1 = node1').  intro H0.  rewrite <- H0.
  rewrite H.  reflexivity.  apply Neqb_complete; assumption.  intro y1.  rewrite y1.
  cut (node1 = node1').  intro H.  rewrite <- H.  rewrite y1.  simpl in |- *.  reflexivity.
  apply Neqb_complete; assumption.  rewrite y.  simpl in |- *.  reflexivity.
Qed.