

Require Import Bool.

Require Import Sumbool.

Require Import Arith.

Require Import ZArith NArith Nnat Ndec Ndigits.

From IntMap Require Import Allmaps.

Require Import Wf_nat.



Require Import BDDvar_ad_nat.
(* BDDvar_ad_nat:
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import ZArith NArith Nnat Ndec Ndigits.
From IntMap Require Import Allmaps.
Definition BDDzero := N0.
Definition BDDone := Npos 1.

  Definition BDDvar := ad.

  Definition BDDcompare (x y : BDDvar) :=
    match x, y with
    | N0, N0 => Datatypes.Eq
    | N0, Npos _ => Datatypes.Lt
    | Npos _, N0 => Datatypes.Gt
    | Npos p1, Npos p2 => Pcompare p1 p2 Datatypes.Eq
    end.

Definition BDDvar_eq := Neqb.

  Definition ad_S (a : ad) :=
    match a with
    | N0 => Npos 1
    | Npos p => Npos (Psucc p)
    end.

  Lemma ad_S_is_S : forall a : ad, nat_of_N (ad_S a) = S (nat_of_N a).

Lemma lt_pred : forall x y : nat, x < y -> x <> 0 -> pred x < pred y.

Lemma O_N0 : forall x : ad, nat_of_N x = 0 -> x = N0.
Lemma INFERIEUR_neq_O :
 forall x y : ad, BDDcompare x y = Datatypes.Lt -> y <> N0.

 Lemma BDDcompare_trans :
  forall x y z : BDDvar,
  BDDcompare x y = Datatypes.Lt ->

  Lemma ad_S_le_then_le :
   forall x y : ad, Nleb (ad_S x) y = true -> Nleb x y = true.

  Lemma le_then_le_S :
   forall x y : ad, Nleb x y = true -> Nleb x (ad_S y) = true.

  Lemma ad_S_le_then_neq :
   forall x y : ad, Nleb (ad_S x) y = true -> Neqb x y = false.

  Lemma BDDcompare_succ :
   forall a : BDDvar, BDDcompare a (ad_S a) = Datatypes.Lt.

  Lemma BDDcompare_lt :
   forall x y : BDDvar,
   BDDcompare x y = Datatypes.Lt -> nat_of_N x < nat_of_N y.

Lemma BDDlt_compare :
 forall x y : BDDvar,
 nat_of_N x < nat_of_N y -> BDDcompare x y = Datatypes.Lt.

Lemma relation_sum :
 forall r : Datatypes.comparison,

Lemma BDD_EGAL_complete :
 forall x y : BDDvar, BDDcompare x y = Datatypes.Eq -> x = y.

  Lemma lt_trans_1 : forall x y z : nat, x < y -> y < S z -> x < z.

Lemma BDDcompare_sup_inf :
 forall x y : BDDvar,
 BDDcompare x y = Datatypes.Gt -> BDDcompare y x = Datatypes.Lt.

  Lemma BDDcompare_1 :
   forall x y : BDDvar,
   BDDcompare x y = Datatypes.Lt ->

Definition max (m n : nat) := if leb m n then n else m.

Lemma lt_max_1_2 :
 forall x1 y1 x2 y2 : nat, x1 < x2 -> y1 < y2 -> max x1 y1 < max x2 y2.

Lemma lt_max_2 :
 forall x1 y1 x2 y2 : nat, x1 < y2 -> y1 < y2 -> max x1 y1 < max x2 y2.

Lemma lt_max_12 :
 forall x1 y1 x2 y2 : nat, x1 < x2 -> y1 < x2 -> max x1 y1 < max x2 y2.

Lemma BDDcompare_eq :
 forall x y : BDDvar, BDDcompare x y = Datatypes.Eq -> x = y. *)

Require Import bdd1.
(* bdd1:
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import ZArith NArith Nnat Ndec Ndigits.
From IntMap Require Import Allmaps.
Require Import Wf_nat.

Require Import BDDvar_ad_nat.

  Definition BDDstate := Map (BDDvar * (ad * ad)).
	  Definition initBDDstate := newMap (BDDvar * (ad * ad)).

  Inductive BDDbounded (bs : BDDstate) : ad -> BDDvar -> Prop :=
    | BDDbounded_0 : forall n : BDDvar, BDDbounded bs BDDzero n
    | BDDbounded_1 : forall n : BDDvar, BDDbounded bs BDDone n
    | BDDbounded_2 :
        forall (node : ad) (n x : BDDvar) (l r : ad),
        MapGet _ bs node = Some (x, (l, r)) ->
        BDDcompare x n = Datatypes.Lt ->
        Neqb l r = false ->
        BDDbounded bs l x -> BDDbounded bs r x -> BDDbounded bs node n.

  Lemma BDDbounded_lemma :
   forall (bs : BDDstate) (node : ad) (n : BDDvar),
   BDDbounded bs node n ->
   node = BDDzero \/
   node = BDDone \/
   (exists x : BDDvar,
      (exists l : BDDvar,
         (exists r : BDDvar,
            MapGet _ bs node = Some (x, (l, r)) /\
            BDDcompare x n = Datatypes.Lt /\

  Lemma increase_bound :
   forall (bs : BDDstate) (n n' : BDDvar) (node : ad),
   BDDbounded bs node n ->
   BDDcompare n n' = Datatypes.Lt -> BDDbounded bs node n'.

  Lemma boundedness_preservation :
   forall bs bs' : BDDstate,
   (forall (a l r : ad) (x : BDDvar),
    MapGet _ bs a = Some (x, (l, r)) -> MapGet _ bs' a = Some (x, (l, r))) ->
   forall (n : BDDvar) (node : ad),
   BDDbounded bs node n -> BDDbounded bs' node n.

  Definition BDDordered (bs : BDDstate) (node : ad) :=
    match MapGet _ bs node with
    | None => True
    | Some (n, _) => BDDbounded bs node (ad_S n)
    end.

  Definition BDD_OK (bs : BDDstate) (node : ad) := BDDordered bs node.

  Definition BDDstate_OK (bs : BDDstate) :=
    MapGet _ bs BDDzero = None /\
    MapGet _ bs BDDone = None /\
    (forall a : ad, in_dom _ a bs = true -> BDD_OK bs a).

  Lemma initBDDstate_OK : BDDstate_OK initBDDstate.

  Definition BDDsharing_map := Map (Map (Map ad)).
	  Definition initBDDsharing_map := newMap (Map (Map ad)).

  Definition BDDshare_lookup (share : BDDsharing_map) 
    (x : BDDvar) (l r : ad) : option ad :=
    match MapGet _ share l with
    | None => None
    | Some m1 =>
        match MapGet _ m1 r with
        | None => None
        | Some m2 =>
            match MapGet _ m2 x with
            | None => None
            | Some y => Some y
            end
        end
    end.

  Definition BDDshare_put (share : BDDsharing_map) 
    (x : BDDvar) (l r counter : ad) : BDDsharing_map :=
    let m1 :=
      match MapGet _ share l with
      | Some y => y
      | None => newMap (Map ad)
      end in
    let m2 :=
      match MapGet _ m1 r with
      | Some y => y
      | None => newMap ad
      end in
    let m2' := MapPut _ m2 x counter in
    let m1' := MapPut _ m1 r m2' in MapPut _ share l m1'.

  Lemma BDDshare_put_puts :
   forall (share : BDDsharing_map) (x : BDDvar) (l r counter : ad),
   BDDshare_lookup (BDDshare_put share x l r counter) x l r = Some counter.

  Lemma BDDshare_put_no_new_node :
   forall (share : BDDsharing_map) (x x' : BDDvar)
     (l l' r r' counter counter' : ad),
   BDDshare_lookup (BDDshare_put share x l r counter) x' l' r' =
   Some counter' ->
   BDDshare_lookup share x' l' r' = Some counter' \/
   (x, (l, r)) = (x', (l', r')).

  Lemma BDDshare_put_preserves_nodes :
   forall (share : BDDsharing_map) (x x' : BDDvar)
     (l l' r r' counter counter' : ad),
   BDDshare_lookup share x' l' r' = Some counter' ->
   (x, (l, r)) <> (x', (l', r')) ->
   BDDshare_lookup (BDDshare_put share x l r counter) x' l' r' =
   Some counter'.

  Definition BDDsharing_OK (bs : BDDstate) (share : BDDsharing_map) :=
    forall (x : BDDvar) (l r a : ad),
    BDDshare_lookup share x l r = Some a <->
    MapGet _ bs a = Some (x, (l, r)).

  Lemma initBDDsharing_map_OK : BDDsharing_OK initBDDstate initBDDsharing_map.

  Definition BDDconfig := (BDDstate * (BDDsharing_map * ad))%type.

  Definition initBDDconfig :=
    (initBDDstate, (initBDDsharing_map, ad_S (ad_S N0))).

  Definition BDDconfig_OK (cfg : BDDconfig) :=
    match cfg return Prop with
    | (bs, (share, counter)) =>
        BDDstate_OK bs /\
        BDDsharing_OK bs share /\
        (forall a : ad, Nleb counter a = true -> MapGet _ bs a = None) /\
        Nleb (ad_S (ad_S N0)) counter = true
    end.

  Lemma initBDDconfig_OK : BDDconfig_OK initBDDconfig.

  Lemma config_OK_zero :
   forall cfg : BDDconfig,
   BDDconfig_OK cfg -> MapGet _ (fst cfg) BDDzero = None.

  Lemma config_OK_one :
   forall cfg : BDDconfig,
   BDDconfig_OK cfg -> MapGet _ (fst cfg) BDDone = None.

  Definition BDDalloc (cfg : BDDconfig) (x : BDDvar) 
    (l r : ad) :=
    match cfg with
    | (bs, (share, counter)) =>
        let share' := BDDshare_put share x l r counter in
        let bs' := MapPut _ bs counter (x, (l, r)) in
        let counter' := ad_S counter in (bs', (share', counter'), counter)
    end.

  Lemma BDDsharing_lookup_semantics :
   forall (bs : BDDstate) (share : BDDsharing_map) (n l r : ad) (x : BDDvar),
   BDDsharing_OK bs share ->
   (BDDshare_lookup share x l r = Some n <->
    MapGet _ bs n = Some (x, (l, r))).

  Definition node_OK (bs : BDDstate) (node : ad) :=
    node = BDDzero \/ node = BDDone \/ in_dom _ node bs = true.

  Lemma BDDbounded_node_OK :
   forall (bs : BDDstate) (node : ad) (n : BDDvar),
   BDDbounded bs node n -> node_OK bs node.

  Lemma BDDalloc_allocates :
   forall (cfg : BDDconfig) (l r : ad) (x : BDDvar),
   MapGet _ (fst (fst (BDDalloc cfg x l r))) (snd (BDDalloc cfg x l r)) =
   Some (x, (l, r)).

  Lemma BDDalloc_preserves_nodes :
   forall (cfg : BDDconfig) (l r : ad) (x : BDDvar),
   BDDconfig_OK cfg ->
   forall (a l1 r1 : ad) (x1 : BDDvar),
   MapGet _ (fst cfg) a = Some (x1, (l1, r1)) ->
   MapGet _ (fst (fst (BDDalloc cfg x l r))) a = Some (x1, (l1, r1)).

  Lemma BDDalloc_no_new_node :
   forall (cfg : BDDconfig) (l l1 r r1 a : ad) (x x1 : BDDvar),
   MapGet _ (fst (fst (BDDalloc cfg x l r))) a = Some (x1, (l1, r1)) ->
   a = snd (snd cfg) \/ MapGet _ (fst cfg) a = Some (x1, (l1, r1)).

  Lemma BDDalloc_no_new_node_1 :
   forall (cfg : BDDconfig) (l l1 r r1 a : ad) (x x1 : BDDvar),
   MapGet _ (fst (fst (BDDalloc cfg x l r))) a = Some (x1, (l1, r1)) ->
   (x1, (l1, r1)) = (x, (l, r)) \/
   MapGet _ (fst cfg) a = Some (x1, (l1, r1)).

  Lemma BDDalloc_preserves_zero :
   forall (cfg : BDDconfig) (l r : ad) (x : BDDvar),
   BDDconfig_OK cfg ->
   MapGet _ (fst (fst (BDDalloc cfg x l r))) BDDzero = None.

  Lemma BDDalloc_preserves_one :
   forall (cfg : BDDconfig) (l r : ad) (x : BDDvar),
   BDDconfig_OK cfg ->
   MapGet _ (fst (fst (BDDalloc cfg x l r))) BDDone = None.

  Lemma BDDalloc_keeps_state_OK :
   forall (cfg : BDDconfig) (l r : ad) (x : BDDvar),
   BDDconfig_OK cfg ->
   node_OK (fst cfg) l ->
   node_OK (fst cfg) r ->
   Neqb l r <> true ->
   (forall (xl : BDDvar) (ll rl : ad),
    MapGet _ (fst cfg) l = Some (xl, (ll, rl)) ->
    BDDcompare xl x = Datatypes.Lt) ->

  Lemma BDDalloc_adjusts_counter :
   forall (cfg : BDDconfig) (x : BDDvar) (l r a : ad),
   BDDconfig_OK cfg ->
   (forall a : ad,
    Nleb (snd (snd (fst (BDDalloc cfg x l r)))) a = true ->
    MapGet _ (fst (fst (BDDalloc cfg x l r))) a = None) /\
   Nleb (ad_S (ad_S N0)) (snd (snd (fst (BDDalloc cfg x l r)))) = true.

Lemma BDDalloc_keeps_sharing_OK :
 forall (cfg : BDDconfig) (l r : ad) (x : BDDvar),
 BDDconfig_OK cfg ->
 node_OK (fst cfg) l ->
 node_OK (fst cfg) r ->
 (forall (x' : BDDvar) (l' r' a : ad),
  MapGet _ (fst cfg) a = Some (x', (l', r')) ->
  (x, (l, r)) <> (x', (l', r'))) ->
 BDDsharing_OK (fst (fst (BDDalloc cfg x l r)))
   (fst (snd (fst (BDDalloc cfg x l r)))).

  Lemma BDDalloc_semantics :
   forall (cfg : BDDconfig) (l r : ad) (x : BDDvar),
   BDDconfig_OK cfg ->
   node_OK (fst cfg) l ->
   node_OK (fst cfg) r ->
   Neqb l r <> true ->
   (forall (xl : BDDvar) (ll rl : ad),
    MapGet _ (fst cfg) l = Some (xl, (ll, rl)) ->
    BDDcompare xl x = Datatypes.Lt) ->

  Definition BDDmake (cfg : BDDconfig) (x : BDDvar) 
    (l r : ad) :=
    if Neqb l r
    then (cfg, l)
    else
     match cfg with
     | (bs, (share, counter)) =>
         match BDDshare_lookup share x l r with
         | Some y => (cfg, y)
         | None => BDDalloc cfg x l r
         end
     end.

  Lemma BDDmake_semantics :
   forall (cfg : BDDconfig) (l r : ad) (x : BDDvar),
   BDDconfig_OK cfg ->
   node_OK (fst cfg) l ->
   node_OK (fst cfg) r ->
   (forall (xl : BDDvar) (ll rl : ad),
    MapGet _ (fst cfg) l = Some (xl, (ll, rl)) ->
    BDDcompare xl x = Datatypes.Lt) -> *)

Require Import bdd2.
(* bdd2:
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import ZArith NArith Nnat Ndec Ndigits.
From IntMap Require Import Allmaps.
Require Import Wf_nat.

Require Import BDDvar_ad_nat.
Require Import bdd1.

Definition var (cfg : BDDconfig) (node : ad) :=
  match MapGet _ (fst cfg) node with
  | None =>   BDDzero
  | Some (x, (l, r)) => x
  end.

Definition low (cfg : BDDconfig) (node : ad) :=
  match MapGet _ (fst cfg) node with
  | None =>   N0
  | Some (x, (l, r)) => l
  end.

Definition high (cfg : BDDconfig) (node : ad) :=
  match MapGet _ (fst cfg) node with
  | None =>   N0
  | Some (x, (l, r)) => r
  end.

Definition config_node_OK (cfg : BDDconfig) := node_OK (fst cfg).
Definition is_internal_node (cfg : BDDconfig) (node : ad) :=
  exists x : BDDvar,
    (exists l : ad,
       (exists r : ad, MapGet _ (fst cfg) node = Some (x, (l, r)))).

Lemma BDDvar_ordered_low :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node ->
 is_internal_node cfg (low cfg node) ->
 BDDcompare (var cfg (low cfg node)) (var cfg node) = Datatypes.Lt.

Lemma BDDvar_ordered_high :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node ->
 is_internal_node cfg (high cfg node) ->
 BDDcompare (var cfg (high cfg node)) (var cfg node) = Datatypes.Lt.

Definition var_binding := BDDvar -> bool.
 
Definition bool_fun := var_binding -> bool.

Definition bool_fun_eval (bf : bool_fun) (vb : var_binding) := bf vb.

Definition bool_fun_zero (vb : var_binding) := false. 
Definition bool_fun_one (vb : var_binding) := true. 

Fixpoint bool_fun_of_BDD_1 (cfg : BDDconfig) (node : ad) 
 (bound : nat) {struct bound} : bool_fun :=
  match MapGet _ (fst cfg) node with
  | None => if Neqb node BDDzero then bool_fun_zero else bool_fun_one
  | Some (x, (l, r)) =>
      match bound with
      | O =>   bool_fun_zero
      | S bound' =>
          let bfl := bool_fun_of_BDD_1 cfg l bound' in
          let bfr := bool_fun_of_BDD_1 cfg r bound' in
          fun vb : var_binding => if vb x then bfr vb else bfl vb
      end
  end.

Lemma bool_fun_of_BDD_1_semantics :
 forall cfg : BDDconfig,
 BDDconfig_OK cfg ->
 forall bound : nat,
 bool_fun_of_BDD_1 cfg BDDzero bound = bool_fun_zero /\
 bool_fun_of_BDD_1 cfg BDDone bound = bool_fun_one /\
 (forall node : ad,
  is_internal_node cfg node ->
  nat_of_N (var cfg node) < bound ->
  forall vb : var_binding,
  (vb (var cfg node) = true ->
   bool_fun_eval (bool_fun_of_BDD_1 cfg node bound) vb =
   bool_fun_eval (bool_fun_of_BDD_1 cfg (high cfg node) (pred bound)) vb) /\
  (vb (var cfg node) = false ->
   bool_fun_eval (bool_fun_of_BDD_1 cfg node bound) vb =
   bool_fun_eval (bool_fun_of_BDD_1 cfg (low cfg node) (pred bound)) vb)).

Lemma bool_fun_of_BDD_1_semantics_1 :
 forall cfg : BDDconfig,
 BDDconfig_OK cfg ->
 forall bound : nat,
 bool_fun_of_BDD_1 cfg BDDzero bound = bool_fun_zero /\
 bool_fun_of_BDD_1 cfg BDDone bound = bool_fun_one /\
 (forall node : ad,
  is_internal_node cfg node ->
  nat_of_N (var cfg node) < bound ->
  bool_fun_of_BDD_1 cfg node bound =
  (fun vb : var_binding =>
   if vb (var cfg node)
   then bool_fun_of_BDD_1 cfg (high cfg node) (pred bound) vb
   else bool_fun_of_BDD_1 cfg (low cfg node) (pred bound) vb)).

Lemma bool_fun_of_BDD_1_semantics_2 :
 forall (cfg : BDDconfig) (node : ad) (bound1 bound2 : nat),
 MapGet _ (fst cfg) node = None ->
 bool_fun_of_BDD_1 cfg node bound1 = bool_fun_of_BDD_1 cfg node bound2.

Lemma bool_fun_of_BDD_1_change_bound :
 forall cfg : BDDconfig,
 BDDconfig_OK cfg ->
 forall (bound : nat) (node : ad),
 nat_of_N (var cfg node) < bound ->
 bool_fun_of_BDD_1 cfg node bound =
 bool_fun_of_BDD_1 cfg node (S (nat_of_N (var cfg node))).

Definition bool_fun_of_BDD (cfg : BDDconfig) (node : ad) :=
  bool_fun_of_BDD_1 cfg node (S (nat_of_N (var cfg node))).

Lemma bool_fun_of_BDD_semantics :
 forall cfg : BDDconfig,
 BDDconfig_OK cfg ->
 bool_fun_of_BDD cfg BDDzero = bool_fun_zero /\
 bool_fun_of_BDD cfg BDDone = bool_fun_one /\
 (forall node : ad,
  is_internal_node cfg node ->
  bool_fun_of_BDD cfg node =
  (fun vb : var_binding =>
   if vb (var cfg node)
   then bool_fun_of_BDD cfg (high cfg node) vb
   else bool_fun_of_BDD cfg (low cfg node) vb)).

Definition bool_fun_eq (bf1 bf2 : bool_fun) :=
  forall vb : var_binding, bool_fun_eval bf1 vb = bool_fun_eval bf2 vb.

Lemma bool_fun_eq_symm :
 forall bf1 bf2 : bool_fun, bool_fun_eq bf1 bf2 -> bool_fun_eq bf2 bf1.

Lemma bool_fun_eq_trans :
 forall bf1 bf2 bf3 : bool_fun,
 bool_fun_eq bf1 bf2 -> bool_fun_eq bf2 bf3 -> bool_fun_eq bf1 bf3.

Definition bool_fun_neg (bf : bool_fun) : bool_fun :=
  fun vb : var_binding => negb (bf vb).
Definition bool_fun_or (bf1 bf2 : bool_fun) : bool_fun :=
  fun vb : var_binding => bf1 vb || bf2 vb.

Lemma bool_fun_neg_semantics :
 forall (bf : bool_fun) (vb : var_binding),
 (bool_fun_eval bf vb = true -> bool_fun_eval (bool_fun_neg bf) vb = false) /\
 (bool_fun_eval bf vb = false -> bool_fun_eval (bool_fun_neg bf) vb = true).

Lemma bool_fun_neg_zero : bool_fun_neg bool_fun_zero = bool_fun_one.

Lemma bool_fun_neg_one : bool_fun_neg bool_fun_one = bool_fun_zero.

Lemma bool_fun_eq_neg :
 forall bf1 bf2 : bool_fun,
 bool_fun_eq (bool_fun_neg bf1) (bool_fun_neg bf2) -> bool_fun_eq bf1 bf2.

Lemma bool_fun_eq_neg_1 :
 forall bf1 bf2 : bool_fun,
 bool_fun_eq bf1 bf2 -> bool_fun_eq (bool_fun_neg bf1) (bool_fun_neg bf2).

Definition BDDneg_memo := Map ad.
Definition BDDneg_memo_lookup (memo : BDDneg_memo) 
  (a : ad) := MapGet _ memo a.
Definition BDDneg_memo_put (memo : BDDneg_memo) (a node : ad) :=
  MapPut _ memo a node.

Definition BDDneg_memo_OK (cfg : BDDconfig) (memo : BDDneg_memo) :=
  forall a node : ad,
  BDDneg_memo_lookup memo a = Some node ->
  config_node_OK cfg node /\
  bool_fun_of_BDD cfg node = bool_fun_neg (bool_fun_of_BDD cfg a) /\
  var cfg a = var cfg node. 

Fixpoint BDDneg_2 (cfg : BDDconfig) (node : ad) (bound : nat) {struct bound} 
   : BDDconfig * ad :=
  match MapGet _ (fst cfg) node with
  | None => if Neqb node BDDzero then (cfg, BDDone) else (cfg, BDDzero)
  | Some (x, (l, r)) =>
      match bound with
      | O =>   (initBDDconfig, BDDzero)
      | S bound' =>
          BDDmake (fst (BDDneg_2 (fst (BDDneg_2 cfg l bound')) r bound')) x
            (snd (BDDneg_2 cfg l bound'))
            (snd (BDDneg_2 (fst (BDDneg_2 cfg l bound')) r bound'))
      end
  end. *)

Require Import bdd3.
(* bdd3:
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import ZArith NArith Nnat Ndec Ndigits.
From IntMap Require Import Allmaps.
Require Import Wf_nat.

Require Import BDDvar_ad_nat.
Require Import bdd1.
Require Import bdd2.

Lemma bool_fun_one_zero_eq : ~ bool_fun_eq bool_fun_one bool_fun_zero.

Lemma bool_fun_zero_one_eq : ~ bool_fun_eq bool_fun_zero bool_fun_one.

Definition augment (vb : var_binding) (x : BDDvar) 
  (b : bool) (y : BDDvar) := if BDDvar_eq x y then b else vb y.

Definition bool_fun_restrict (bf : bool_fun) (x : BDDvar) 
  (b : bool) (vb : var_binding) := bool_fun_eval bf (augment vb x b).

Lemma bool_fun_restrict_zero :
 forall (x : BDDvar) (b : bool),
 bool_fun_eq (bool_fun_restrict bool_fun_zero x b) bool_fun_zero. 

Lemma bool_fun_restrict_one :
 forall (x : BDDvar) (b : bool),
 bool_fun_eq (bool_fun_restrict bool_fun_one x b) bool_fun_one.

Lemma bool_fun_restrict_eq :
 forall (bf bf' : bool_fun) (x : BDDvar) (b : bool),
 bool_fun_eq bf bf' ->
 bool_fun_eq (bool_fun_restrict bf x b) (bool_fun_restrict bf' x b).

Definition var_binding_eq (vb vb' : var_binding) :=
  forall x : BDDvar, vb x = vb' x.

Definition bool_fun_ext (bf : bool_fun) :=
  forall vb vb' : var_binding,
  var_binding_eq vb vb' -> bool_fun_eval bf vb = bool_fun_eval bf vb'.

Lemma bool_fun_of_BDD_1_ext :
 forall (bound : nat) (cfg : BDDconfig) (node : ad),
 bool_fun_ext (bool_fun_of_BDD_1 cfg node bound). 

Lemma bool_fun_of_BDD_ext :
 forall (cfg : BDDconfig) (node : ad),
 bool_fun_ext (bool_fun_of_BDD cfg node).

Lemma augment_eq :
 forall (vb : var_binding) (x : BDDvar) (b : bool),
 vb x = b -> var_binding_eq (augment vb x b) vb.

Definition bool_fun_independent (bf : bool_fun) (x : BDDvar) :=
  forall vb : var_binding,
  bool_fun_eval bf (augment vb x true) =
  bool_fun_eval bf (augment vb x false).

Lemma bool_fun_independent_lemma :
 forall (bf : bool_fun) (x : BDDvar) (vb : var_binding) (b : bool),
 bool_fun_ext bf ->
 bool_fun_independent bf x ->
 bool_fun_eval bf (augment vb x b) = bool_fun_eval bf vb. 

Lemma bool_fun_independent_zero :
 forall (cfg : BDDconfig) (x : BDDvar),
 BDDconfig_OK cfg -> bool_fun_independent (bool_fun_of_BDD cfg BDDzero) x.

Lemma bool_fun_independent_one :
 forall (cfg : BDDconfig) (x : BDDvar),
 BDDconfig_OK cfg -> bool_fun_independent (bool_fun_of_BDD cfg BDDone) x.

Lemma in_dom_is_internal :
 forall (cfg : BDDconfig) (node : ad),
 in_dom _ node (fst cfg) = true -> is_internal_node cfg node.

Lemma internal_node_lemma :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node ->
 Neqb (low cfg node) (high cfg node) = false /\
 BDDbounded (fst cfg) (low cfg node) (var cfg node) /\
 BDDbounded (fst cfg) (high cfg node) (var cfg node).

Lemma high_bounded :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node ->
 BDDbounded (fst cfg) (high cfg node) (var cfg node).

Lemma low_bounded :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node ->
 BDDbounded (fst cfg) (low cfg node) (var cfg node).

Lemma high_OK :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node -> config_node_OK cfg (high cfg node).

Lemma low_OK :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node -> config_node_OK cfg (low cfg node).

Lemma low_high_neq :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node -> Neqb (low cfg node) (high cfg node) = false.

Lemma BDDvar_independent_1 :
 forall (cfg : BDDconfig) (n : nat) (node : ad) (x : BDDvar),
 BDDconfig_OK cfg ->
 is_internal_node cfg node ->
 n = nat_of_N (var cfg node) ->
 BDDcompare (var cfg node) x = Datatypes.Lt ->

Lemma BDDvar_independent_high :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node ->
 bool_fun_independent (bool_fun_of_BDD cfg (high cfg node)) (var cfg node).

Lemma BDDvar_independent_low :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node ->
 bool_fun_independent (bool_fun_of_BDD cfg (low cfg node)) (var cfg node).

Lemma bool_fun_of_BDDzero :
 forall cfg : BDDconfig,
 BDDconfig_OK cfg -> bool_fun_eq (bool_fun_of_BDD cfg BDDzero) bool_fun_zero.

Lemma bool_fun_of_BDDone :
 forall cfg : BDDconfig,
 BDDconfig_OK cfg -> bool_fun_eq (bool_fun_of_BDD cfg BDDone) bool_fun_one.

Lemma bool_fun_of_BDDhigh :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node ->
 bool_fun_eq (bool_fun_of_BDD cfg (high cfg node))
   (bool_fun_restrict (bool_fun_of_BDD cfg node) (var cfg node) true).

Lemma bool_fun_of_BDDlow :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node ->
 bool_fun_eq (bool_fun_of_BDD cfg (low cfg node))
   (bool_fun_restrict (bool_fun_of_BDD cfg node) (var cfg node) false).

Lemma internal_node_not_constant_1 :
 forall cfg : BDDconfig,
 BDDconfig_OK cfg ->
 forall (n : nat) (node : ad),
 is_internal_node cfg node ->
 n = nat_of_N (var cfg node) ->
 ~ bool_fun_eq (bool_fun_of_BDD cfg node) bool_fun_zero /\
 ~ bool_fun_eq (bool_fun_of_BDD cfg node) bool_fun_one.

Lemma internal_node_not_constant :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node ->
 ~ bool_fun_eq (bool_fun_of_BDD cfg node) bool_fun_zero /\
 ~ bool_fun_eq (bool_fun_of_BDD cfg node) bool_fun_one.

Lemma bool_fun_neq_internal_zero :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node ->
 ~ bool_fun_eq (bool_fun_of_BDD cfg node) (bool_fun_of_BDD cfg BDDzero).
 
Lemma bool_fun_neq_internal_one :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node ->
 ~ bool_fun_eq (bool_fun_of_BDD cfg node) (bool_fun_of_BDD cfg BDDone).

Lemma bool_fun_neq_zero_one :
 forall cfg : BDDconfig,
 BDDconfig_OK cfg ->
 ~ bool_fun_eq (bool_fun_of_BDD cfg BDDzero) (bool_fun_of_BDD cfg BDDone).

Lemma bool_fun_neq_one_zero :
 forall cfg : BDDconfig,
 BDDconfig_OK cfg ->
 ~ bool_fun_eq (bool_fun_of_BDD cfg BDDone) (bool_fun_of_BDD cfg BDDzero).

Lemma bool_fun_neq_lemma :
 forall bf1 bf2 : bool_fun, ~ bool_fun_eq bf1 bf2 -> ~ bool_fun_eq bf2 bf1.

Lemma no_duplicate_node :
 forall (cfg : BDDconfig) (node1 node2 : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node1 ->
 is_internal_node cfg node2 ->
 var cfg node1 = var cfg node2 ->
 high cfg node1 = high cfg node2 ->
 low cfg node1 = low cfg node2 -> node1 = node2.

Lemma BDDunique_1 :
 forall cfg : BDDconfig,
 BDDconfig_OK cfg ->
 forall (n : nat) (node1 node2 : ad),
 n = max (nat_of_N (var cfg node1)) (nat_of_N (var cfg node2)) ->
 config_node_OK cfg node1 ->
 config_node_OK cfg node2 ->
 bool_fun_eq (bool_fun_of_BDD cfg node1) (bool_fun_of_BDD cfg node2) ->
 node1 = node2.

Lemma BDDunique :
 forall cfg : BDDconfig,
 BDDconfig_OK cfg ->
 forall node1 node2 : ad,
 config_node_OK cfg node1 ->
 config_node_OK cfg node2 ->
 bool_fun_eq (bool_fun_of_BDD cfg node1) (bool_fun_of_BDD cfg node2) ->
 node1 = node2.

Lemma bool_fun_eq_lemma :
 forall (bf1 bf2 : bool_fun) (x : BDDvar),
 bool_fun_ext bf1 ->
 bool_fun_ext bf2 ->
 bool_fun_eq (bool_fun_restrict bf1 x true) (bool_fun_restrict bf2 x true) ->
 bool_fun_eq (bool_fun_restrict bf1 x false) (bool_fun_restrict bf2 x false) ->
 bool_fun_eq bf1 bf2.
  
Lemma bool_fun_preservation_1 :
 forall cfg cfg' : BDDconfig,
 BDDconfig_OK cfg ->
 BDDconfig_OK cfg' ->
 (forall (x : BDDvar) (l r a : ad),
  MapGet _ (fst cfg) a = Some (x, (l, r)) ->
  MapGet _ (fst cfg') a = Some (x, (l, r))) ->
 forall (n : nat) (node : ad),
 n = nat_of_N (var cfg node) ->
 config_node_OK cfg node ->
 bool_fun_eq (bool_fun_of_BDD cfg' node) (bool_fun_of_BDD cfg node).

Lemma bool_fun_preservation :
 forall (cfg cfg' : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 BDDconfig_OK cfg' ->
 (forall (x : BDDvar) (l r a : ad),
  MapGet _ (fst cfg) a = Some (x, (l, r)) ->
  MapGet _ (fst cfg') a = Some (x, (l, r))) ->
 config_node_OK cfg node ->
 bool_fun_eq (bool_fun_of_BDD cfg' node) (bool_fun_of_BDD cfg node). *)

Require Import bdd4.
(* bdd4:
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import ZArith NArith Nnat Ndec Ndigits.
From IntMap Require Import Allmaps.
Require Import Wf_nat.

Require Import BDDvar_ad_nat.
Require Import bdd1.
Require Import bdd2.
Require Import bdd3.

Lemma BDDneg_2_lemma :
 forall (bound : nat) (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 config_node_OK cfg node ->
 (is_internal_node cfg node -> nat_of_N (var cfg node) < bound) ->
 BDDconfig_OK (fst (BDDneg_2 cfg node bound)) /\
 (forall (x : BDDvar) (l r a : ad),
  MapGet _ (fst cfg) a = Some (x, (l, r)) ->
  MapGet _ (fst (fst (BDDneg_2 cfg node bound))) a = Some (x, (l, r))) /\
 (is_internal_node cfg node ->
  is_internal_node (fst (BDDneg_2 cfg node bound))
    (snd (BDDneg_2 cfg node bound)) /\
  var cfg node =
  var (fst (BDDneg_2 cfg node bound)) (snd (BDDneg_2 cfg node bound))) /\
 config_node_OK (fst (BDDneg_2 cfg node bound))
   (snd (BDDneg_2 cfg node bound)) /\
 bool_fun_eq
   (bool_fun_of_BDD (fst (BDDneg_2 cfg node bound))
      (snd (BDDneg_2 cfg node bound)))
   (bool_fun_neg (bool_fun_of_BDD cfg node)). *)

Require Import bdd5_1.
(* bdd5_1:
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import ZArith NArith Nnat Ndec Ndigits.
From IntMap Require Import Allmaps.
Require Import Wf_nat.

Require Import BDDvar_ad_nat.
Require Import bdd1.
Require Import bdd2.
Require Import bdd3.
Require Import bdd4.

Definition BDDneg_memo_OK_1 (cfg : BDDconfig) (memo : BDDneg_memo) :=
  forall (node node' : ad) (bound : nat),
  config_node_OK cfg node ->
  BDDneg_memo_lookup memo node = Some node' ->
  (is_internal_node cfg node -> nat_of_N (var cfg node) < bound) ->
  BDDneg_2 cfg node bound = (cfg, node').

Definition BDDneg_memo_OK_2 (cfg : BDDconfig) (memo : BDDneg_memo) :=
  forall (node node' : ad) (bound : nat),
  BDDneg_memo_lookup memo node = Some node' ->
  (is_internal_node cfg node -> nat_of_N (var cfg node) < bound) ->
  config_node_OK cfg node /\ BDDneg_2 cfg node bound = (cfg, node').

Fixpoint BDDneg_1 (arg : BDDconfig * ad * BDDneg_memo) 
 (bound : nat) {struct bound} : BDDconfig * ad * BDDneg_memo :=
  match BDDneg_memo_lookup (snd arg) (snd (fst arg)) with
  | Some node => (fst (fst arg), node, snd arg)
  | None =>
      match MapGet _ (fst (fst (fst arg))) (snd (fst arg)) with
      | None =>
          if Neqb (snd (fst arg)) BDDzero
          then
           (fst (fst arg), BDDone, BDDneg_memo_put (snd arg) BDDzero BDDone)
          else
           (fst (fst arg), BDDzero, BDDneg_memo_put (snd arg) BDDone BDDzero)
      | Some (x, (l, r)) =>
          match bound with
          | O => (initBDDconfig, BDDzero, newMap ad)
          | S bound' =>
              (BDDmake
                 (fst
                    (fst
                       (BDDneg_1
                          (fst
                             (fst
                                (BDDneg_1 (fst (fst arg), l, snd arg) bound')),
                          r,
                          snd (BDDneg_1 (fst (fst arg), l, snd arg) bound'))
                          bound'))) x
                 (snd (fst (BDDneg_1 (fst (fst arg), l, snd arg) bound')))
                 (snd
                    (fst
                       (BDDneg_1
                          (fst
                             (fst
                                (BDDneg_1 (fst (fst arg), l, snd arg) bound')),
                          r,
                          snd (BDDneg_1 (fst (fst arg), l, snd arg) bound'))
                          bound'))),
              BDDneg_memo_put
                (snd
                   (BDDneg_1
                      (fst
                         (fst (BDDneg_1 (fst (fst arg), l, snd arg) bound')),
                      r, snd (BDDneg_1 (fst (fst arg), l, snd arg) bound'))
                      bound')) (snd (fst arg))
                (snd
                   (BDDmake
                      (fst
                         (fst
                            (BDDneg_1
                               (fst
                                  (fst
                                     (BDDneg_1 (fst (fst arg), l, snd arg)
                                        bound')), r,
                               snd
                                 (BDDneg_1 (fst (fst arg), l, snd arg) bound'))
                               bound'))) x
                      (snd
                         (fst (BDDneg_1 (fst (fst arg), l, snd arg) bound')))
                      (snd
                         (fst
                            (BDDneg_1
                               (fst
                                  (fst
                                     (BDDneg_1 (fst (fst arg), l, snd arg)
                                        bound')), r,
                               snd
                                 (BDDneg_1 (fst (fst arg), l, snd arg) bound'))
                               bound'))))))
          end
      end
  end.

Lemma BDDneg_1_lemma_1 :
 forall (arg : BDDconfig * ad * BDDneg_memo) (node : ad) (bound : nat),
 BDDneg_memo_lookup (snd arg) (snd (fst arg)) = Some node ->
 BDDneg_1 arg bound = (fst (fst arg), node, snd arg).

Lemma BDDneg_1_lemma_2 :
 forall (arg : BDDconfig * ad * BDDneg_memo) (bound : nat),
 BDDneg_memo_lookup (snd arg) (snd (fst arg)) = None ->
 MapGet _ (fst (fst (fst arg))) (snd (fst arg)) = None ->
 BDDneg_1 arg bound =
 (if Neqb (snd (fst arg)) BDDzero
  then (fst (fst arg), BDDone, BDDneg_memo_put (snd arg) BDDzero BDDone)
  else (fst (fst arg), BDDzero, BDDneg_memo_put (snd arg) BDDone BDDzero)).

Lemma BDDneg_1_lemma_3 :
 forall (arg : BDDconfig * ad * BDDneg_memo) (x : BDDvar) (l r : ad),
 BDDneg_memo_lookup (snd arg) (snd (fst arg)) = None ->
 MapGet _ (fst (fst (fst arg))) (snd (fst arg)) = Some (x, (l, r)) ->
 BDDneg_1 arg 0 = (initBDDconfig, BDDzero, newMap ad).

Lemma nat_sum : forall n : nat, {m : nat | n = S m} + {n = 0}.

Lemma BDDneg_1_lemma_4 :
 forall (arg : BDDconfig * ad * BDDneg_memo) (x : BDDvar) 
   (l r : ad) (bound bound' : nat),
 bound = S bound' ->
 BDDneg_memo_lookup (snd arg) (snd (fst arg)) = None ->
 MapGet _ (fst (fst (fst arg))) (snd (fst arg)) = Some (x, (l, r)) ->
 BDDneg_1 arg bound =
 (BDDmake
    (fst
       (fst
          (BDDneg_1
             (fst (fst (BDDneg_1 (fst (fst arg), l, snd arg) bound')), r,
             snd (BDDneg_1 (fst (fst arg), l, snd arg) bound')) bound'))) x
    (snd (fst (BDDneg_1 (fst (fst arg), l, snd arg) bound')))
    (snd
       (fst
          (BDDneg_1
             (fst (fst (BDDneg_1 (fst (fst arg), l, snd arg) bound')), r,
             snd (BDDneg_1 (fst (fst arg), l, snd arg) bound')) bound'))),
 BDDneg_memo_put
   (snd
      (BDDneg_1
         (fst (fst (BDDneg_1 (fst (fst arg), l, snd arg) bound')), r,
         snd (BDDneg_1 (fst (fst arg), l, snd arg) bound')) bound'))
   (snd (fst arg))
   (snd
      (BDDmake
         (fst
            (fst
               (BDDneg_1
                  (fst (fst (BDDneg_1 (fst (fst arg), l, snd arg) bound')),
                  r, snd (BDDneg_1 (fst (fst arg), l, snd arg) bound'))
                  bound'))) x
         (snd (fst (BDDneg_1 (fst (fst arg), l, snd arg) bound')))
         (snd
            (fst
               (BDDneg_1
                  (fst (fst (BDDneg_1 (fst (fst arg), l, snd arg) bound')),
                  r, snd (BDDneg_1 (fst (fst arg), l, snd arg) bound'))
                  bound')))))).

Lemma bool_fun_restrict_neg_1 :
 forall (bf : bool_fun) (x : BDDvar) (b : bool),
 bool_fun_ext bf ->
 bool_fun_eq (bool_fun_restrict (bool_fun_neg bf) x b)
   (bool_fun_neg (bool_fun_restrict bf x b)).

Lemma bool_fun_neg_eq_var_2 :
 forall (cfg : BDDconfig) (node node' : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node ->
 is_internal_node cfg node' ->
 bool_fun_eq (bool_fun_of_BDD cfg node')
   (bool_fun_neg (bool_fun_of_BDD cfg node)) -> var cfg node = var cfg node'.

Lemma BDDneg_memo_OK_1_lemma_1_1_1 :
 forall (bound : nat) (cfg : BDDconfig) (node node' : ad),
 BDDconfig_OK cfg ->
 config_node_OK cfg node ->
 config_node_OK cfg node' ->
 (is_internal_node cfg node -> nat_of_N (var cfg node) < bound) ->
 bool_fun_eq (bool_fun_of_BDD cfg node')
   (bool_fun_neg (bool_fun_of_BDD cfg node)) ->
 BDDneg_2 cfg node bound = (cfg, node').

Lemma BDDneg_memo_OK_1_2 :
 forall (cfg : BDDconfig) (memo : BDDneg_memo),
 BDDneg_memo_OK_2 cfg memo -> BDDneg_memo_OK_1 cfg memo.

Lemma BDDneg_memo_OK_bool_fun_1 :
 forall (cfg : BDDconfig) (memo : BDDneg_memo) (node node' : ad),
 BDDconfig_OK cfg ->
 BDDneg_memo_OK_1 cfg memo ->
 config_node_OK cfg node ->
 BDDneg_memo_lookup memo node = Some node' ->
 bool_fun_eq (bool_fun_of_BDD cfg node')
   (bool_fun_neg (bool_fun_of_BDD cfg node)).

Lemma BDDneg_memo_OK_bool_fun_1' :
 forall (cfg : BDDconfig) (memo : BDDneg_memo) (node node' : ad),
 BDDconfig_OK cfg ->
 BDDneg_memo_OK_2 cfg memo ->
 config_node_OK cfg node ->
 BDDneg_memo_lookup memo node = Some node' ->
 bool_fun_eq (bool_fun_of_BDD cfg node')
   (bool_fun_neg (bool_fun_of_BDD cfg node)).

Definition nodes_preserved (cfg cfg' : BDDconfig) :=
  forall (x : BDDvar) (l r node : ad),
  MapGet _ (fst cfg) node = Some (x, (l, r)) ->
  MapGet _ (fst cfg') node = Some (x, (l, r)).

Lemma BDDmake_preserves_nodes :
 forall (cfg : BDDconfig) (x : BDDvar) (l r : ad),
 BDDconfig_OK cfg -> nodes_preserved cfg (fst (BDDmake cfg x l r)).

Lemma nodes_preserved_2 :
 forall (cfg cfg' : BDDconfig) (node : ad),
 config_node_OK cfg node ->
 nodes_preserved cfg cfg' -> config_node_OK cfg' node.

Lemma BDDneg_2_config_OK_lemma_2 :
 forall (cfg : BDDconfig) (node : ad) (x : BDDvar) (l r : ad) (n m : nat),
 BDDconfig_OK cfg ->
 MapGet _ (fst cfg) node = Some (x, (l, r)) ->
 nat_of_N (var cfg node) < n ->
 n = S m -> BDDconfig_OK (fst (BDDneg_2 (fst (BDDneg_2 cfg l m)) r m)).

Lemma nodes_preserved_1 :
 forall (cfg : BDDconfig) (node : ad) (n m : nat) (x : BDDvar) (l r : ad),
 BDDconfig_OK cfg ->
 MapGet _ (fst cfg) node = Some (x, (l, r)) ->
 n = S m ->
 nat_of_N (var cfg node) < n ->
 nodes_preserved (fst (BDDneg_2 (fst (BDDneg_2 cfg l m)) r m))
   (fst (BDDneg_2 cfg node n)).

Lemma BDDneg_memo_OK_lemma_1_4' :
 forall (cfg : BDDconfig) (memo : BDDneg_memo) (node node' : ad),
 BDDconfig_OK cfg ->
 BDDneg_memo_OK_2 cfg memo ->
 config_node_OK cfg node ->
 BDDneg_memo_lookup memo node = Some node' -> config_node_OK cfg node'. *)

Require Import bdd5_2.
(* bdd5_2:
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import ZArith NArith Nnat Ndec Ndigits.
From IntMap Require Import Allmaps.
Require Import Wf_nat.

Require Import BDDvar_ad_nat.
Require Import bdd1.
Require Import bdd2.
Require Import bdd3.
Require Import bdd4.
Require Import bdd5_1.

Lemma BDDneg_memo_OK_1_lemma_2_1' :
 forall (cfg : BDDconfig) (memo : BDDneg_memo),
 BDDconfig_OK cfg ->
 BDDneg_memo_OK_2 cfg memo ->
 BDDneg_memo_OK_2 cfg (BDDneg_memo_put memo BDDzero BDDone).

Lemma BDDneg_memo_OK_1_lemma_3_1' :
 forall (cfg : BDDconfig) (memo : BDDneg_memo),
 BDDconfig_OK cfg ->
 BDDneg_memo_OK_2 cfg memo ->
 BDDneg_memo_OK_2 cfg (BDDneg_memo_put memo BDDone BDDzero).

Lemma BDDneg_memo_OK_1_lemma_1_2' :
 forall (cfg : BDDconfig) (x : BDDvar) (l r node : ad) 
   (n m : nat) (memo : BDDneg_memo),
 BDDconfig_OK cfg ->
 MapGet _ (fst cfg) node = Some (x, (l, r)) ->
 nat_of_N (var cfg node) < n ->
 n = S m ->
 BDDneg_memo_OK_2 (fst (BDDneg_2 (fst (BDDneg_2 cfg l m)) r m)) memo ->
 BDDneg_memo_OK_2 (fst (BDDneg_2 cfg node n))
   (BDDneg_memo_put memo node (snd (BDDneg_2 cfg node n))).

Lemma BDDneg_1_lemma' :
 forall (bound : nat) (arg : BDDconfig * ad * BDDneg_memo),
 BDDconfig_OK (fst (fst arg)) ->
 config_node_OK (fst (fst arg)) (snd (fst arg)) ->
 BDDneg_memo_OK_2 (fst (fst arg)) (snd arg) ->
 (is_internal_node (fst (fst arg)) (snd (fst arg)) ->
  nat_of_N (var (fst (fst arg)) (snd (fst arg))) < bound) ->
 fst (BDDneg_1 arg bound) = BDDneg_2 (fst (fst arg)) (snd (fst arg)) bound /\
 BDDneg_memo_OK_2 (fst (fst (BDDneg_1 arg bound))) (snd (BDDneg_1 arg bound)). *)

Require Import bdd6.
(* bdd6:
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import ZArith NArith Nnat Ndec Ndigits.
From IntMap Require Import Allmaps.
Require Import Wf_nat.

Require Import BDDvar_ad_nat.
Require Import bdd1.
Require Import bdd2.
Require Import bdd3.
Require Import bdd4.
Require Import bdd5_1.
Require Import bdd5_2.

Lemma nodes_preserved_trans :
 forall cfg1 cfg2 cfg3 : BDDconfig,
 nodes_preserved cfg1 cfg2 ->
 nodes_preserved cfg2 cfg3 -> nodes_preserved cfg1 cfg3.

Lemma nodes_preserved_var :
 forall (cfg cfg' : BDDconfig) (node : ad),
 nodes_preserved cfg cfg' ->
 is_internal_node cfg node -> var cfg' node = var cfg node.

Lemma nodes_preserved_var_1 :
 forall (cfg cfg' : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 BDDconfig_OK cfg' ->
 nodes_preserved cfg cfg' ->
 config_node_OK cfg node -> var cfg' node = var cfg node.

Lemma nodes_preserved_3 :
 forall (cfg cfg' : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 BDDconfig_OK cfg' ->
 nodes_preserved cfg cfg' ->
 config_node_OK cfg node ->
 bool_fun_eq (bool_fun_of_BDD cfg' node) (bool_fun_of_BDD cfg node).

Lemma bool_fun_or_preserves_eq :
 forall bf1 bf2 bf1' bf2' : bool_fun,
 bool_fun_eq bf1 bf1' ->
 bool_fun_eq bf2 bf2' ->
 bool_fun_eq (bool_fun_or bf1 bf2) (bool_fun_or bf1' bf2').

Definition BDDvar_le := Nleb.
Definition BDDvar_max (x y : BDDvar) := if BDDvar_le x y then y else x.

Lemma BDDvar_max_comm : forall x y : BDDvar, BDDvar_max x y = BDDvar_max y x.

Lemma BDDvar_max_lemma_1 :
 forall x y z : BDDvar,
 BDDcompare x y = Datatypes.Lt ->

Lemma BDDvar_le_z : forall x : BDDvar, BDDvar_le N0 x = true.

Lemma BDDvar_le_compare :
 forall x y : BDDvar, BDDcompare x y = Datatypes.Lt -> BDDvar_le x y = true.

Lemma BDDcompare_max_1_2 :
 forall x1 x2 y1 y2 : BDDvar,
 BDDcompare x1 x2 = Datatypes.Lt ->

Lemma BDDcompare_z_nz :
 forall x : BDDvar, x <> N0 -> BDDcompare N0 x = Datatypes.Lt.

Lemma BDDvar_max_x_x : forall x : BDDvar, BDDvar_max x x = x.

Lemma BDDvar_ordered_high_1 :
 forall (cfg : BDDconfig) (node1 node2 : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node1 ->
 is_internal_node cfg node2 ->
 is_internal_node cfg (high cfg node1) \/
 is_internal_node cfg (high cfg node2) ->
 BDDcompare
   (BDDvar_max (var cfg (high cfg node1)) (var cfg (high cfg node2)))
   (BDDvar_max (var cfg node1) (var cfg node2)) = Datatypes.Lt.

Lemma BDDvar_ordered_low_1 :
 forall (cfg : BDDconfig) (node1 node2 : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node1 ->
 is_internal_node cfg node2 ->
 is_internal_node cfg (low cfg node1) \/ is_internal_node cfg (low cfg node2) ->
 BDDcompare (BDDvar_max (var cfg (low cfg node1)) (var cfg (low cfg node2)))
   (BDDvar_max (var cfg node1) (var cfg node2)) = Datatypes.Lt.

Lemma BDDvar_ordered_high_2 :
 forall (cfg : BDDconfig) (node1 node2 : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node1 ->
 is_internal_node cfg node2 ->
 BDDcompare (var cfg node1) (var cfg node2) = Datatypes.Lt ->

Lemma BDDvar_ordered_low_2 :
 forall (cfg : BDDconfig) (node1 node2 : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node1 ->
 is_internal_node cfg node2 ->
 BDDcompare (var cfg node1) (var cfg node2) = Datatypes.Lt ->

Lemma BDDvar_ordered_high_3 :
 forall (cfg : BDDconfig) (node1 node2 : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node1 ->
 is_internal_node cfg node2 ->
 BDDcompare (var cfg node2) (var cfg node1) = Datatypes.Lt ->

Lemma BDDvar_ordered_low_3 :
 forall (cfg : BDDconfig) (node1 node2 : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node1 ->
 is_internal_node cfg node2 ->
 BDDcompare (var cfg node2) (var cfg node1) = Datatypes.Lt ->

Lemma lt_max_nat_of_N :
 forall x y z : BDDvar,
 BDDcompare (BDDvar_max x y) z = Datatypes.Lt ->

Lemma le_nat_of_N_max :
 forall x y z : BDDvar,
 BDDvar_le x (BDDvar_max y z) = true ->
 nat_of_N x <= max (nat_of_N y) (nat_of_N z).

Definition bool_fun_if (x : BDDvar) (bf bf' : bool_fun) : bool_fun :=
  fun vb : var_binding => ifb (vb x) (bf vb) (bf' vb).
  
Lemma nodes_preserved_internal :
 forall (cfg cfg' : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 BDDconfig_OK cfg' ->
 config_node_OK cfg node ->
 is_internal_node cfg' node -> is_internal_node cfg node.

Lemma bool_fun_if_preserves_eq :
 forall (x : BDDvar) (bf1 bf2 bf1' bf2' : bool_fun),
 bool_fun_eq bf1 bf1' ->
 bool_fun_eq bf2 bf2' ->
 bool_fun_eq (bool_fun_if x bf1 bf2) (bool_fun_if x bf1' bf2').

Lemma BDDmake_var_order :
 forall (cfg : BDDconfig) (l r : ad) (x : BDDvar),
 BDDconfig_OK cfg ->
 config_node_OK cfg l ->
 config_node_OK cfg r ->
 (is_internal_node cfg l -> BDDcompare (var cfg l) x = Datatypes.Lt) ->

Lemma BDDmake_bool_fun :
 forall (cfg : BDDconfig) (l r : ad) (x : BDDvar),
 BDDconfig_OK cfg ->
 config_node_OK cfg l ->
 config_node_OK cfg r ->
 (is_internal_node cfg l -> BDDcompare (var cfg l) x = Datatypes.Lt) ->

Lemma bool_fun_or_commute :
 forall bf bf' : bool_fun,
 bool_fun_eq (bool_fun_or bf bf') (bool_fun_or bf' bf).

Lemma bool_fun_or_zero :
 forall bf : bool_fun, bool_fun_eq (bool_fun_or bf bool_fun_zero) bf.

Lemma bool_fun_or_one :
 forall bf : bool_fun, bool_fun_eq (bool_fun_or bf bool_fun_one) bool_fun_one.

Lemma bool_fun_if_lemma_1 :
 forall (x : BDDvar) (bfl1 bfl2 bfr1 bfr2 : bool_fun),
 bool_fun_eq (bool_fun_if x (bool_fun_or bfr1 bfr2) (bool_fun_or bfl1 bfl2))
   (bool_fun_or (bool_fun_if x bfr1 bfl1) (bool_fun_if x bfr2 bfl2)).

Lemma bool_fun_if_lemma_3 :
 forall (x : BDDvar) (bf1 bfl2 bfr2 : bool_fun),
 bool_fun_eq (bool_fun_if x (bool_fun_or bf1 bfr2) (bool_fun_or bf1 bfl2))
   (bool_fun_or bf1 (bool_fun_if x bfr2 bfl2)).

Lemma bool_fun_if_lemma_4 :
 forall (x : BDDvar) (bfl1 bfr1 bf2 : bool_fun),
 bool_fun_eq (bool_fun_if x (bool_fun_or bfr1 bf2) (bool_fun_or bfl1 bf2))
   (bool_fun_or (bool_fun_if x bfr1 bfl1) bf2).

Lemma bool_fun_if_lemma_2 :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node ->
 bool_fun_eq (bool_fun_of_BDD cfg node)
   (bool_fun_if (var cfg node) (bool_fun_of_BDD cfg (high cfg node))
      (bool_fun_of_BDD cfg (low cfg node))).

Lemma BDD_EGAL_correct : forall x y : BDDvar, BDDcompare x x = Datatypes.Eq.

Lemma BDD_EGALsymm :
 forall x y : BDDvar,
 BDDcompare x y = Datatypes.Eq -> BDDcompare y x = Datatypes.Eq.

Lemma BDDcompare_le_INFERIEUR_1 :
 forall x y z : BDDvar,
 BDDvar_le x y = true ->
 BDDcompare y z = Datatypes.Lt -> BDDcompare x z = Datatypes.Lt.

Definition BDDor_memo := Map (Map ad).
Definition initBDDor_memo := newMap (Map ad).

Definition BDDor_memo_put (memo : BDDor_memo) (node1 node2 node : ad) :=
  let m1 :=
    match MapGet _ memo node1 with
    | Some y => y
    | None => newMap ad
    end in
  let m1' := MapPut _ m1 node2 node in MapPut _ memo node1 m1'.

Definition BDDor_memo_lookup (memo : BDDor_memo) (node1 node2 : ad) :=
  match MapGet _ memo node1 with
  | None => None
  | Some m1 =>
      match MapGet _ m1 node2 with
      | None => None
      | Some node => Some node
      end
  end. 

Definition BDDor_memo_OK (cfg : BDDconfig) (memo : BDDor_memo) :=
  forall node1 node2 node : ad,
  BDDor_memo_lookup memo node1 node2 = Some node ->
  config_node_OK cfg node1 /\
  config_node_OK cfg node2 /\
  config_node_OK cfg node /\
  BDDvar_le (var cfg node) (BDDvar_max (var cfg node1) (var cfg node2)) =
  true /\
  bool_fun_eq (bool_fun_of_BDD cfg node)
    (bool_fun_or (bool_fun_of_BDD cfg node1) (bool_fun_of_BDD cfg node2)).

Lemma BDDor_memo_lookup_semantics :
 forall (memo : BDDor_memo) (node1 node2 node node1' node2' : ad),
 BDDor_memo_lookup (BDDor_memo_put memo node1 node2 node) node1' node2' =
 (if Neqb node1 node1' && Neqb node2 node2'
  then Some node
  else BDDor_memo_lookup memo node1' node2'). *)

Require Import bdd7.
(* bdd7:
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import ZArith NArith Nnat Ndec Ndigits.
From IntMap Require Import Allmaps.
Require Import Wf_nat.

Require Import BDDvar_ad_nat.
Require Import bdd1.
Require Import bdd2.
Require Import bdd3.
Require Import bdd4.
Require Import bdd5_1.
Require Import bdd5_2.
Require Import bdd6.

Fixpoint BDDor_1 (cfg : BDDconfig) (memo : BDDor_memo) 
 (node1 node2 : ad) (bound : nat) {struct bound} :
 BDDconfig * (ad * BDDor_memo) :=
  match BDDor_memo_lookup memo node1 node2 with
  | Some node => (cfg, (node, memo))
  | None =>
      if Neqb node1 BDDzero
      then (cfg, (node2, BDDor_memo_put memo BDDzero node2 node2))
      else
       if Neqb node1 BDDone
       then (cfg, (BDDone, BDDor_memo_put memo BDDone node2 BDDone))
       else
        if Neqb node2 BDDzero
        then (cfg, (node1, BDDor_memo_put memo node1 BDDzero node1))
        else
         if Neqb node2 BDDone
         then (cfg, (BDDone, BDDor_memo_put memo node1 BDDone BDDone))
         else
          match bound with
          | O => (initBDDconfig, (BDDzero, initBDDor_memo))
          | S bound' =>
              match BDDcompare (var cfg node1) (var cfg node2) with
              | Datatypes.Eq =>
                  (fst
                     (BDDmake
                        (fst
                           (BDDor_1
                              (fst
                                 (BDDor_1 cfg memo 
                                    (low cfg node1) 
                                    (low cfg node2) bound'))
                              (snd
                                 (snd
                                    (BDDor_1 cfg memo 
                                       (low cfg node1) 
                                       (low cfg node2) bound')))
                              (high cfg node1) (high cfg node2) bound'))
                        (var cfg node1)
                        (fst
                           (snd
                              (BDDor_1 cfg memo (low cfg node1)
                                 (low cfg node2) bound')))
                        (fst
                           (snd
                              (BDDor_1
                                 (fst
                                    (BDDor_1 cfg memo 
                                       (low cfg node1) 
                                       (low cfg node2) bound'))
                                 (snd
                                    (snd
                                       (BDDor_1 cfg memo 
                                          (low cfg node1) 
                                          (low cfg node2) bound')))
                                 (high cfg node1) (high cfg node2) bound')))),
                  (snd
                     (BDDmake
                        (fst
                           (BDDor_1
                              (fst
                                 (BDDor_1 cfg memo 
                                    (low cfg node1) 
                                    (low cfg node2) bound'))
                              (snd
                                 (snd
                                    (BDDor_1 cfg memo 
                                       (low cfg node1) 
                                       (low cfg node2) bound')))
                              (high cfg node1) (high cfg node2) bound'))
                        (var cfg node1)
                        (fst
                           (snd
                              (BDDor_1 cfg memo (low cfg node1)
                                 (low cfg node2) bound')))
                        (fst
                           (snd
                              (BDDor_1
                                 (fst
                                    (BDDor_1 cfg memo 
                                       (low cfg node1) 
                                       (low cfg node2) bound'))
                                 (snd
                                    (snd
                                       (BDDor_1 cfg memo 
                                          (low cfg node1) 
                                          (low cfg node2) bound')))
                                 (high cfg node1) (high cfg node2) bound')))),
                  BDDor_memo_put
                    (snd
                       (snd
                          (BDDor_1
                             (fst
                                (BDDor_1 cfg memo (low cfg node1)
                                   (low cfg node2) bound'))
                             (snd
                                (snd
                                   (BDDor_1 cfg memo 
                                      (low cfg node1) 
                                      (low cfg node2) bound')))
                             (high cfg node1) (high cfg node2) bound')))
                    node1 node2
                    (snd
                       (BDDmake
                          (fst
                             (BDDor_1
                                (fst
                                   (BDDor_1 cfg memo 
                                      (low cfg node1) 
                                      (low cfg node2) bound'))
                                (snd
                                   (snd
                                      (BDDor_1 cfg memo 
                                         (low cfg node1) 
                                         (low cfg node2) bound')))
                                (high cfg node1) (high cfg node2) bound'))
                          (var cfg node1)
                          (fst
                             (snd
                                (BDDor_1 cfg memo (low cfg node1)
                                   (low cfg node2) bound')))
                          (fst
                             (snd
                                (BDDor_1
                                   (fst
                                      (BDDor_1 cfg memo 
                                         (low cfg node1) 
                                         (low cfg node2) bound'))
                                   (snd
                                      (snd
                                         (BDDor_1 cfg memo 
                                            (low cfg node1) 
                                            (low cfg node2) bound')))
                                   (high cfg node1) 
                                   (high cfg node2) bound')))))))
              | Datatypes.Lt =>
                  (fst
                     (BDDmake
                        (fst
                           (BDDor_1
                              (fst
                                 (BDDor_1 cfg memo node1 
                                    (low cfg node2) bound'))
                              (snd
                                 (snd
                                    (BDDor_1 cfg memo node1 
                                       (low cfg node2) bound'))) node1
                              (high cfg node2) bound')) 
                        (var cfg node2)
                        (fst
                           (snd
                              (BDDor_1 cfg memo node1 (low cfg node2) bound')))
                        (fst
                           (snd
                              (BDDor_1
                                 (fst
                                    (BDDor_1 cfg memo node1 
                                       (low cfg node2) bound'))
                                 (snd
                                    (snd
                                       (BDDor_1 cfg memo node1
                                          (low cfg node2) bound'))) node1
                                 (high cfg node2) bound')))),
                  (snd
                     (BDDmake
                        (fst
                           (BDDor_1
                              (fst
                                 (BDDor_1 cfg memo node1 
                                    (low cfg node2) bound'))
                              (snd
                                 (snd
                                    (BDDor_1 cfg memo node1 
                                       (low cfg node2) bound'))) node1
                              (high cfg node2) bound')) 
                        (var cfg node2)
                        (fst
                           (snd
                              (BDDor_1 cfg memo node1 (low cfg node2) bound')))
                        (fst
                           (snd
                              (BDDor_1
                                 (fst
                                    (BDDor_1 cfg memo node1 
                                       (low cfg node2) bound'))
                                 (snd
                                    (snd
                                       (BDDor_1 cfg memo node1
                                          (low cfg node2) bound'))) node1
                                 (high cfg node2) bound')))),
                  BDDor_memo_put
                    (snd
                       (snd
                          (BDDor_1
                             (fst
                                (BDDor_1 cfg memo node1 
                                   (low cfg node2) bound'))
                             (snd
                                (snd
                                   (BDDor_1 cfg memo node1 
                                      (low cfg node2) bound'))) node1
                             (high cfg node2) bound'))) node1 node2
                    (snd
                       (BDDmake
                          (fst
                             (BDDor_1
                                (fst
                                   (BDDor_1 cfg memo node1 
                                      (low cfg node2) bound'))
                                (snd
                                   (snd
                                      (BDDor_1 cfg memo node1 
                                         (low cfg node2) bound'))) node1
                                (high cfg node2) bound')) 
                          (var cfg node2)
                          (fst
                             (snd
                                (BDDor_1 cfg memo node1 
                                   (low cfg node2) bound')))
                          (fst
                             (snd
                                (BDDor_1
                                   (fst
                                      (BDDor_1 cfg memo node1 
                                         (low cfg node2) bound'))
                                   (snd
                                      (snd
                                         (BDDor_1 cfg memo node1
                                            (low cfg node2) bound'))) node1
                                   (high cfg node2) bound')))))))
              | Datatypes.Gt =>
                  (fst
                     (BDDmake
                        (fst
                           (BDDor_1
                              (fst
                                 (BDDor_1 cfg memo 
                                    (low cfg node1) node2 bound'))
                              (snd
                                 (snd
                                    (BDDor_1 cfg memo 
                                       (low cfg node1) node2 bound')))
                              (high cfg node1) node2 bound')) 
                        (var cfg node1)
                        (fst
                           (snd
                              (BDDor_1 cfg memo (low cfg node1) node2 bound')))
                        (fst
                           (snd
                              (BDDor_1
                                 (fst
                                    (BDDor_1 cfg memo 
                                       (low cfg node1) node2 bound'))
                                 (snd
                                    (snd
                                       (BDDor_1 cfg memo 
                                          (low cfg node1) node2 bound')))
                                 (high cfg node1) node2 bound')))),
                  (snd
                     (BDDmake
                        (fst
                           (BDDor_1
                              (fst
                                 (BDDor_1 cfg memo 
                                    (low cfg node1) node2 bound'))
                              (snd
                                 (snd
                                    (BDDor_1 cfg memo 
                                       (low cfg node1) node2 bound')))
                              (high cfg node1) node2 bound')) 
                        (var cfg node1)
                        (fst
                           (snd
                              (BDDor_1 cfg memo (low cfg node1) node2 bound')))
                        (fst
                           (snd
                              (BDDor_1
                                 (fst
                                    (BDDor_1 cfg memo 
                                       (low cfg node1) node2 bound'))
                                 (snd
                                    (snd
                                       (BDDor_1 cfg memo 
                                          (low cfg node1) node2 bound')))
                                 (high cfg node1) node2 bound')))),
                  BDDor_memo_put
                    (snd
                       (snd
                          (BDDor_1
                             (fst
                                (BDDor_1 cfg memo (low cfg node1) node2
                                   bound'))
                             (snd
                                (snd
                                   (BDDor_1 cfg memo 
                                      (low cfg node1) node2 bound')))
                             (high cfg node1) node2 bound'))) node1 node2
                    (snd
                       (BDDmake
                          (fst
                             (BDDor_1
                                (fst
                                   (BDDor_1 cfg memo 
                                      (low cfg node1) node2 bound'))
                                (snd
                                   (snd
                                      (BDDor_1 cfg memo 
                                         (low cfg node1) node2 bound')))
                                (high cfg node1) node2 bound'))
                          (var cfg node1)
                          (fst
                             (snd
                                (BDDor_1 cfg memo (low cfg node1) node2
                                   bound')))
                          (fst
                             (snd
                                (BDDor_1
                                   (fst
                                      (BDDor_1 cfg memo 
                                         (low cfg node1) node2 bound'))
                                   (snd
                                      (snd
                                         (BDDor_1 cfg memo 
                                            (low cfg node1) node2 bound')))
                                   (high cfg node1) node2 bound')))))))
              end
          end
  end.

Lemma BDDor_1_lemma_1 :
 forall (cfg : BDDconfig) (memo : BDDor_memo) (node1 node2 node : ad)
   (bound : nat),
 BDDor_memo_lookup memo node1 node2 = Some node ->
 BDDor_1 cfg memo node1 node2 bound = (cfg, (node, memo)).

Lemma BDDor_1_lemma_zero_1 :
 forall (cfg : BDDconfig) (memo : BDDor_memo) (node1 : ad) (bound : nat),
 BDDor_memo_lookup memo node1 BDDzero = None ->
 BDDor_1 cfg memo node1 BDDzero bound =
 (cfg, (node1, BDDor_memo_put memo node1 BDDzero node1)).

Lemma BDDor_1_lemma_one_1 :
 forall (cfg : BDDconfig) (memo : BDDor_memo) (node1 : ad) (bound : nat),
 BDDor_memo_lookup memo node1 BDDone = None ->
 BDDor_1 cfg memo node1 BDDone bound =
 (cfg, (BDDone, BDDor_memo_put memo node1 BDDone BDDone)).

Lemma BDDor_1_lemma_zero_2 :
 forall (cfg : BDDconfig) (memo : BDDor_memo) (node2 : ad) (bound : nat),
 BDDor_memo_lookup memo BDDzero node2 = None ->
 BDDor_1 cfg memo BDDzero node2 bound =
 (cfg, (node2, BDDor_memo_put memo BDDzero node2 node2)).

Lemma BDDor_1_lemma_one_2 :
 forall (cfg : BDDconfig) (memo : BDDor_memo) (node2 : ad) (bound : nat),
 BDDor_memo_lookup memo BDDone node2 = None ->
 BDDor_1 cfg memo BDDone node2 bound =
 (cfg, (BDDone, BDDor_memo_put memo BDDone node2 BDDone)).

Lemma BDDor_1_lemma_internal_1 :
 forall (cfg : BDDconfig) (memo : BDDor_memo) (node1 node2 : ad)
   (bound bound' : nat),
 BDDor_memo_lookup memo node1 node2 = None ->
 BDDconfig_OK cfg ->
 is_internal_node cfg node1 ->
 is_internal_node cfg node2 ->
 max (nat_of_N (var cfg node1)) (nat_of_N (var cfg node2)) < bound ->
 bound = S bound' ->
 BDDcompare (var cfg node1) (var cfg node2) = Datatypes.Eq ->

Lemma BDDor_1_lemma_internal_2 :
 forall (cfg : BDDconfig) (memo : BDDor_memo) (node1 node2 : ad)
   (bound bound' : nat),
 BDDor_memo_lookup memo node1 node2 = None ->
 BDDconfig_OK cfg ->
 is_internal_node cfg node1 ->
 is_internal_node cfg node2 ->
 max (nat_of_N (var cfg node1)) (nat_of_N (var cfg node2)) < bound ->
 bound = S bound' ->
 BDDcompare (var cfg node1) (var cfg node2) = Datatypes.Lt ->

Lemma BDDor_1_lemma_internal_3 :
 forall (cfg : BDDconfig) (memo : BDDor_memo) (node1 node2 : ad)
   (bound bound' : nat),
 BDDor_memo_lookup memo node1 node2 = None ->
 BDDconfig_OK cfg ->
 is_internal_node cfg node1 ->
 is_internal_node cfg node2 ->
 max (nat_of_N (var cfg node1)) (nat_of_N (var cfg node2)) < bound ->
 bound = S bound' ->
 BDDcompare (var cfg node1) (var cfg node2) = Datatypes.Gt ->

Lemma BDDvar_le_max_2 :
 forall x y : BDDvar, BDDvar_le x (BDDvar_max y x) = true.

Lemma BDDvar_le_max_1 :
 forall x y : BDDvar, BDDvar_le x (BDDvar_max x y) = true.

Lemma BDDor_1_internal :
 forall (cfg : BDDconfig) (memo : BDDor_memo) (node1 node2 : ad)
   (bound : nat),
 BDDconfig_OK cfg ->
 config_node_OK cfg node1 ->
 config_node_OK cfg node2 ->
 BDDor_memo_OK cfg memo ->
 is_internal_node (fst (BDDor_1 cfg memo node1 node2 bound))
   (fst (snd (BDDor_1 cfg memo node1 node2 bound))) ->
 is_internal_node cfg node1 \/ is_internal_node cfg node2. *)

Require Import BDDdummy_lemma_2.
(* BDDdummy_lemma_2:
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import ZArith NArith Nnat Ndec Ndigits.
From IntMap Require Import Allmaps.
Require Import Wf_nat.

Require Import BDDvar_ad_nat.
Require Import bdd1.
Require Import bdd2.
Require Import bdd3.
Require Import bdd4.
Require Import bdd5_1.
Require Import bdd5_2.
Require Import bdd6.
Require Import bdd7.

Lemma BDDdummy_lemma_2 :
 forall bound : nat,
 (forall m : nat,
  m < bound ->
  forall (cfg : BDDconfig) (node1 node2 : ad) (memo : BDDor_memo),
  BDDconfig_OK cfg ->
  BDDor_memo_OK cfg memo ->
  config_node_OK cfg node1 ->
  config_node_OK cfg node2 ->
  (is_internal_node cfg node1 ->
   is_internal_node cfg node2 ->
   max (nat_of_N (var cfg node1)) (nat_of_N (var cfg node2)) < m) ->
  BDDconfig_OK (fst (BDDor_1 cfg memo node1 node2 m)) /\
  BDDor_memo_OK (fst (BDDor_1 cfg memo node1 node2 m))
    (snd (snd (BDDor_1 cfg memo node1 node2 m))) /\
  config_node_OK (fst (BDDor_1 cfg memo node1 node2 m))
    (fst (snd (BDDor_1 cfg memo node1 node2 m))) /\
  nodes_preserved cfg (fst (BDDor_1 cfg memo node1 node2 m)) /\
  BDDvar_le
    (var (fst (BDDor_1 cfg memo node1 node2 m))
       (fst (snd (BDDor_1 cfg memo node1 node2 m))))
    (BDDvar_max (var cfg node1) (var cfg node2)) = true /\
  bool_fun_eq
    (bool_fun_of_BDD (fst (BDDor_1 cfg memo node1 node2 m))
       (fst (snd (BDDor_1 cfg memo node1 node2 m))))
    (bool_fun_or (bool_fun_of_BDD cfg node1) (bool_fun_of_BDD cfg node2))) ->
 forall (cfg : BDDconfig) (node1 node2 : ad) (memo : BDDor_memo),
 BDDconfig_OK cfg ->
 BDDor_memo_OK cfg memo ->
 config_node_OK cfg node1 ->
 config_node_OK cfg node2 ->
 (is_internal_node cfg node1 ->
  is_internal_node cfg node2 ->
  max (nat_of_N (var cfg node1)) (nat_of_N (var cfg node2)) < bound) ->
 BDDor_memo_lookup memo node1 node2 = None ->
 in_dom (BDDvar * (ad * ad)) node1 (fst cfg) = true ->
 node2 = BDDone \/ in_dom (BDDvar * (ad * ad)) node2 (fst cfg) = true ->
 is_internal_node cfg node1 ->
 in_dom (BDDvar * (ad * ad)) node2 (fst cfg) = true ->
 is_internal_node cfg node2 ->
 forall bound' : nat,
 bound = S bound' ->
 max (nat_of_N (var cfg node1)) (nat_of_N (var cfg node2)) < bound ->
 BDDcompare (var cfg node1) (var cfg node2) = Datatypes.Eq -> *)

Require Import BDDdummy_lemma_3.
(* BDDdummy_lemma_3:
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import ZArith NArith Nnat Ndec Ndigits.
From IntMap Require Import Allmaps.
Require Import Wf_nat.

Require Import BDDvar_ad_nat.
Require Import bdd1.
Require Import bdd2.
Require Import bdd3.
Require Import bdd4.
Require Import bdd5_1.
Require Import bdd5_2.
Require Import bdd6.
Require Import bdd7.

Lemma BDDdummy_lemma_3 :
 forall bound : nat,
 (forall m : nat,
  m < bound ->
  forall (cfg : BDDconfig) (node1 node2 : ad) (memo : BDDor_memo),
  BDDconfig_OK cfg ->
  BDDor_memo_OK cfg memo ->
  config_node_OK cfg node1 ->
  config_node_OK cfg node2 ->
  (is_internal_node cfg node1 ->
   is_internal_node cfg node2 ->
   max (nat_of_N (var cfg node1)) (nat_of_N (var cfg node2)) < m) ->
  BDDconfig_OK (fst (BDDor_1 cfg memo node1 node2 m)) /\
  BDDor_memo_OK (fst (BDDor_1 cfg memo node1 node2 m))
    (snd (snd (BDDor_1 cfg memo node1 node2 m))) /\
  config_node_OK (fst (BDDor_1 cfg memo node1 node2 m))
    (fst (snd (BDDor_1 cfg memo node1 node2 m))) /\
  nodes_preserved cfg (fst (BDDor_1 cfg memo node1 node2 m)) /\
  BDDvar_le
    (var (fst (BDDor_1 cfg memo node1 node2 m))
       (fst (snd (BDDor_1 cfg memo node1 node2 m))))
    (BDDvar_max (var cfg node1) (var cfg node2)) = true /\
  bool_fun_eq
    (bool_fun_of_BDD (fst (BDDor_1 cfg memo node1 node2 m))
       (fst (snd (BDDor_1 cfg memo node1 node2 m))))
    (bool_fun_or (bool_fun_of_BDD cfg node1) (bool_fun_of_BDD cfg node2))) ->
 forall (cfg : BDDconfig) (node1 node2 : ad) (memo : BDDor_memo),
 BDDconfig_OK cfg ->
 BDDor_memo_OK cfg memo ->
 config_node_OK cfg node1 ->
 config_node_OK cfg node2 ->
 (is_internal_node cfg node1 ->
  is_internal_node cfg node2 ->
  max (nat_of_N (var cfg node1)) (nat_of_N (var cfg node2)) < bound) ->
 BDDor_memo_lookup memo node1 node2 = None ->
 in_dom (BDDvar * (ad * ad)) node1 (fst cfg) = true ->
 node2 = BDDone \/ in_dom (BDDvar * (ad * ad)) node2 (fst cfg) = true ->
 is_internal_node cfg node1 ->
 in_dom (BDDvar * (ad * ad)) node2 (fst cfg) = true ->
 is_internal_node cfg node2 ->
 forall bound' : nat,
 bound = S bound' ->
 max (nat_of_N (var cfg node1)) (nat_of_N (var cfg node2)) < bound ->
 BDDcompare (var cfg node1) (var cfg node2) = Datatypes.Lt -> *)

Require Import BDDdummy_lemma_4.
(* BDDdummy_lemma_4:
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import ZArith NArith Nnat Ndec Ndigits.
From IntMap Require Import Allmaps.
Require Import Wf_nat.

Require Import BDDvar_ad_nat.
Require Import bdd1.
Require Import bdd2.
Require Import bdd3.
Require Import bdd4.
Require Import bdd5_1.
Require Import bdd5_2.
Require Import bdd6.
Require Import bdd7.

Lemma BDDdummy_lemma_4 :
 forall bound : nat,
 (forall m : nat,
  m < bound ->
  forall (cfg : BDDconfig) (node1 node2 : ad) (memo : BDDor_memo),
  BDDconfig_OK cfg ->
  BDDor_memo_OK cfg memo ->
  config_node_OK cfg node1 ->
  config_node_OK cfg node2 ->
  (is_internal_node cfg node1 ->
   is_internal_node cfg node2 ->
   max (nat_of_N (var cfg node1)) (nat_of_N (var cfg node2)) < m) ->
  BDDconfig_OK (fst (BDDor_1 cfg memo node1 node2 m)) /\
  BDDor_memo_OK (fst (BDDor_1 cfg memo node1 node2 m))
    (snd (snd (BDDor_1 cfg memo node1 node2 m))) /\
  config_node_OK (fst (BDDor_1 cfg memo node1 node2 m))
    (fst (snd (BDDor_1 cfg memo node1 node2 m))) /\
  nodes_preserved cfg (fst (BDDor_1 cfg memo node1 node2 m)) /\
  BDDvar_le
    (var (fst (BDDor_1 cfg memo node1 node2 m))
       (fst (snd (BDDor_1 cfg memo node1 node2 m))))
    (BDDvar_max (var cfg node1) (var cfg node2)) = true /\
  bool_fun_eq
    (bool_fun_of_BDD (fst (BDDor_1 cfg memo node1 node2 m))
       (fst (snd (BDDor_1 cfg memo node1 node2 m))))
    (bool_fun_or (bool_fun_of_BDD cfg node1) (bool_fun_of_BDD cfg node2))) ->
 forall (cfg : BDDconfig) (node1 node2 : ad) (memo : BDDor_memo),
 BDDconfig_OK cfg ->
 BDDor_memo_OK cfg memo ->
 config_node_OK cfg node1 ->
 config_node_OK cfg node2 ->
 (is_internal_node cfg node1 ->
  is_internal_node cfg node2 ->
  max (nat_of_N (var cfg node1)) (nat_of_N (var cfg node2)) < bound) ->
 BDDor_memo_lookup memo node1 node2 = None ->
 in_dom (BDDvar * (ad * ad)) node1 (fst cfg) = true ->
 node2 = BDDone \/ in_dom (BDDvar * (ad * ad)) node2 (fst cfg) = true ->
 is_internal_node cfg node1 ->
 in_dom (BDDvar * (ad * ad)) node2 (fst cfg) = true ->
 is_internal_node cfg node2 ->
 forall bound' : nat,
 bound = S bound' ->
 max (nat_of_N (var cfg node1)) (nat_of_N (var cfg node2)) < bound ->
 BDDcompare (var cfg node1) (var cfg node2) = Datatypes.Gt -> *)

Require Import bdd8.
(* bdd8:
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import ZArith NArith Nnat Ndec Ndigits.
From IntMap Require Import Allmaps.
Require Import Wf_nat.

Require Import BDDvar_ad_nat.
Require Import bdd1.
Require Import bdd2.
Require Import bdd3.
Require Import bdd4.
Require Import bdd5_1.
Require Import bdd5_2.
Require Import bdd6.
Require Import bdd7.
Require Import BDDdummy_lemma_2.
Require Import BDDdummy_lemma_3.
Require Import BDDdummy_lemma_4.

Lemma BDDor_1_lemma :
 forall (bound : nat) (cfg : BDDconfig) (node1 node2 : ad)
   (memo : BDDor_memo),
 BDDconfig_OK cfg ->
 BDDor_memo_OK cfg memo ->
 config_node_OK cfg node1 ->
 config_node_OK cfg node2 ->
 (is_internal_node cfg node1 ->
  is_internal_node cfg node2 ->
  max (nat_of_N (var cfg node1)) (nat_of_N (var cfg node2)) < bound) ->
 BDDconfig_OK (fst (BDDor_1 cfg memo node1 node2 bound)) /\
 BDDor_memo_OK (fst (BDDor_1 cfg memo node1 node2 bound))
   (snd (snd (BDDor_1 cfg memo node1 node2 bound))) /\
 config_node_OK (fst (BDDor_1 cfg memo node1 node2 bound))
   (fst (snd (BDDor_1 cfg memo node1 node2 bound))) /\
 nodes_preserved cfg (fst (BDDor_1 cfg memo node1 node2 bound)) /\
 BDDvar_le
   (var (fst (BDDor_1 cfg memo node1 node2 bound))
      (fst (snd (BDDor_1 cfg memo node1 node2 bound))))
   (BDDvar_max (var cfg node1) (var cfg node2)) = true /\
 bool_fun_eq
   (bool_fun_of_BDD (fst (BDDor_1 cfg memo node1 node2 bound))
      (fst (snd (BDDor_1 cfg memo node1 node2 bound))))
   (bool_fun_or (bool_fun_of_BDD cfg node1) (bool_fun_of_BDD cfg node2)). *)

Require Import bdd9.
(* bdd9:
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import ZArith NArith Nnat Ndec Ndigits.
From IntMap Require Import Allmaps.
Require Import Wf_nat.

Require Import BDDvar_ad_nat.
Require Import bdd1.
Require Import bdd2.
Require Import bdd3.
Require Import bdd4.
Require Import bdd5_1.
Require Import bdd5_2.
Require Import bdd6.
Require Import bdd7.
Require Import BDDdummy_lemma_2.
Require Import BDDdummy_lemma_3.
Require Import BDDdummy_lemma_4.
Require Import bdd8.

Inductive BDDdummy_type1 : Set :=
    BDDdummy1 : BDDconfig * ad * BDDneg_memo -> BDDdummy_type1.

Inductive BDDdummy_type2 : Set :=
    BDDdummy2 : BDDconfig * ad -> BDDdummy_type2.

Inductive BDDdummy_type3 : Set :=
    BDDdummy3 : BDDconfig * (ad * BDDor_memo) -> BDDdummy_type3.

Definition initBDDneg_memo : BDDneg_memo := newMap ad.

Fixpoint BDDneg_1_1 (cfg : BDDconfig) (memo : BDDneg_memo) 
 (node : ad) (bound : nat) {struct bound} : BDDconfig * ad * BDDneg_memo :=
  match BDDneg_memo_lookup memo node with
  | Some node' => (cfg, node', memo)
  | None =>
      match MapGet _ (fst cfg) node with
      | None =>
          if Neqb node BDDzero
          then (cfg, BDDone, BDDneg_memo_put memo BDDzero BDDone)
          else (cfg, BDDzero, BDDneg_memo_put memo BDDone BDDzero)
      | Some (x, (l, r)) =>
          match bound with
          | O => (initBDDconfig, BDDzero, initBDDneg_memo)
          | S bound' =>
              match BDDdummy1 (BDDneg_1_1 cfg memo l bound') with
              | BDDdummy1 ((cfgl, nodel), memol) =>
                  match BDDdummy1 (BDDneg_1_1 cfgl memol r bound') with
                  | BDDdummy1 ((cfgr, noder), memor) =>
                      match BDDdummy2 (BDDmake cfgr x nodel noder) with
                      | BDDdummy2 (cfg', node') =>
                          (cfg', node', BDDneg_memo_put memor node node')
                      end
                  end
              end
          end
      end
  end.

Lemma BDDneg_1_1_eq_1 :
 forall (bound : nat) (cfg : BDDconfig) (memo : BDDneg_memo) (node : ad),
 BDDneg_1_1 cfg memo node bound = BDDneg_1 (cfg, node, memo) bound.

Fixpoint BDDor_1_1 (cfg : BDDconfig) (memo : BDDor_memo) 
 (node1 node2 : ad) (bound : nat) {struct bound} :
 BDDconfig * (ad * BDDor_memo) :=
  match BDDor_memo_lookup memo node1 node2 with
  | Some node => (cfg, (node, memo))
  | None =>
      if Neqb node1 BDDzero
      then (cfg, (node2, BDDor_memo_put memo BDDzero node2 node2))
      else
       if Neqb node1 BDDone
       then (cfg, (BDDone, BDDor_memo_put memo BDDone node2 BDDone))
       else
        if Neqb node2 BDDzero
        then (cfg, (node1, BDDor_memo_put memo node1 BDDzero node1))
        else
         if Neqb node2 BDDone
         then (cfg, (BDDone, BDDor_memo_put memo node1 BDDone BDDone))
         else
          match bound with
          | O => (initBDDconfig, (BDDzero, initBDDor_memo))
          | S bound' =>
              match BDDcompare (var cfg node1) (var cfg node2) with
              | Datatypes.Eq =>
                  match
                    BDDdummy3
                      (BDDor_1_1 cfg memo (low cfg node1) 
                         (low cfg node2) bound')
                  with
                  | BDDdummy3 (cfgl, (nodel, memol)) =>
                      match
                        BDDdummy3
                          (BDDor_1_1 cfgl memol (high cfg node1)
                             (high cfg node2) bound')
                      with
                      | BDDdummy3 (cfgr, (noder, memor)) =>
                          match
                            BDDdummy2
                              (BDDmake cfgr (var cfg node1) nodel noder)
                          with
                          | BDDdummy2 (cfg', node') =>
                              (cfg',
                              (node', BDDor_memo_put memor node1 node2 node'))
                          end
                      end
                  end
              | Datatypes.Lt =>
                  match
                    BDDdummy3
                      (BDDor_1_1 cfg memo node1 (low cfg node2) bound')
                  with
                  | BDDdummy3 (cfgl, (nodel, memol)) =>
                      match
                        BDDdummy3
                          (BDDor_1_1 cfgl memol node1 (high cfg node2) bound')
                      with
                      | BDDdummy3 (cfgr, (noder, memor)) =>
                          match
                            BDDdummy2
                              (BDDmake cfgr (var cfg node2) nodel noder)
                          with
                          | BDDdummy2 (cfg', node') =>
                              (cfg',
                              (node', BDDor_memo_put memor node1 node2 node'))
                          end
                      end
                  end
              | Datatypes.Gt =>
                  match
                    BDDdummy3
                      (BDDor_1_1 cfg memo (low cfg node1) node2 bound')
                  with
                  | BDDdummy3 (cfgl, (nodel, memol)) =>
                      match
                        BDDdummy3
                          (BDDor_1_1 cfgl memol (high cfg node1) node2 bound')
                      with
                      | BDDdummy3 (cfgr, (noder, memor)) =>
                          match
                            BDDdummy2
                              (BDDmake cfgr (var cfg node1) nodel noder)
                          with
                          | BDDdummy2 (cfg', node') =>
                              (cfg',
                              (node', BDDor_memo_put memor node1 node2 node'))
                          end
                      end
                  end
              end
          end
  end.

Lemma BDDor_1_1_eq_1 :
 forall (bound : nat) (cfg : BDDconfig) (memo : BDDor_memo)
   (node1 node2 : ad),
 BDDor_1_1 cfg memo node1 node2 bound = BDDor_1 cfg memo node1 node2 bound.

Lemma prod_sum :
 forall (A B : Set) (p : A * B), exists a : A, (exists b : B, p = (a, b)). *)

Require Import bdd10.
(* bdd10:
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import ZArith NArith Nnat Ndec Ndigits.
From IntMap Require Import Allmaps.
Require Import Wf_nat.

Require Import BDDvar_ad_nat.
Require Import bdd1.
Require Import bdd2.
Require Import bdd3.
Require Import bdd4.
Require Import bdd5_1.
Require Import bdd5_2.
Require Import bdd6.
Require Import bdd7.
Require Import BDDdummy_lemma_2.
Require Import BDDdummy_lemma_3.
Require Import BDDdummy_lemma_4.
Require Import bdd8.
Require Import bdd9.

Definition BDDneg (cfg : BDDconfig) (memo : BDDneg_memo) 
  (node : ad) :=
  match BDDneg_1_1 cfg memo node (S (nat_of_N (var cfg node))) with
  | ((cfg', node'), memo') => (cfg', (node', memo'))
  end.

Definition BDDor (cfg : BDDconfig) (memo : BDDor_memo) 
  (node1 node2 : ad) :=
  BDDor_1_1 cfg memo node1 node2
    (S (max (nat_of_N (var cfg node1)) (nat_of_N (var cfg node2)))).

Definition BDDand (cfg : BDDconfig) (negm : BDDneg_memo) 
  (orm : BDDor_memo) (node1 node2 : ad) :=
  match BDDneg cfg negm node1 with
  | (cfg', (node1', negm')) =>
      match BDDneg cfg' negm' node2 with
      | (cfg'', (node2', negm'')) =>
          match BDDor cfg'' orm node1' node2' with
          | (cfg''', (node, orm')) =>
              match BDDneg cfg''' negm'' node with
              | (cfg'''', (node', negm''')) =>
                  (cfg'''', (node', (negm''', orm')))
              end
          end
      end
  end.

Lemma nodes_preserved_orm_OK :
 forall (cfg cfg' : BDDconfig) (orm : BDDor_memo),
 BDDconfig_OK cfg ->
 BDDconfig_OK cfg' ->
 nodes_preserved cfg cfg' -> BDDor_memo_OK cfg orm -> BDDor_memo_OK cfg' orm.

Lemma nodes_preserved_negm_OK :
 forall (cfg cfg' : BDDconfig) (negm : BDDneg_memo),
 BDDconfig_OK cfg ->
 BDDconfig_OK cfg' ->
 nodes_preserved cfg cfg' ->
 BDDneg_memo_OK_2 cfg negm -> BDDneg_memo_OK_2 cfg' negm.

Lemma BDDneg_keeps_config_OK :
 forall (cfg : BDDconfig) (negm : BDDneg_memo) (node : ad),
 BDDconfig_OK cfg ->
 BDDneg_memo_OK_2 cfg negm ->
 config_node_OK cfg node -> BDDconfig_OK (fst (BDDneg cfg negm node)).

Lemma BDDneg_node_OK :
 forall (cfg : BDDconfig) (negm : BDDneg_memo) (node : ad),
 BDDconfig_OK cfg ->
 BDDneg_memo_OK_2 cfg negm ->
 config_node_OK cfg node ->
 config_node_OK (fst (BDDneg cfg negm node))
   (fst (snd (BDDneg cfg negm node))).

Lemma BDDneg_preserves_nodes :
 forall (cfg : BDDconfig) (negm : BDDneg_memo) (node : ad),
 BDDconfig_OK cfg ->
 BDDneg_memo_OK_2 cfg negm ->
 config_node_OK cfg node -> nodes_preserved cfg (fst (BDDneg cfg negm node)).

Lemma BDDneg_keeps_neg_memo_OK :
 forall (cfg : BDDconfig) (negm : BDDneg_memo) (node : ad),
 BDDconfig_OK cfg ->
 BDDneg_memo_OK_2 cfg negm ->
 config_node_OK cfg node ->
 BDDneg_memo_OK_2 (fst (BDDneg cfg negm node))
   (snd (snd (BDDneg cfg negm node))).
Lemma BDDneg_keeps_or_memo_OK :
 forall (cfg : BDDconfig) (negm : BDDneg_memo) (orm : BDDor_memo) (node : ad),
 BDDconfig_OK cfg ->
 BDDneg_memo_OK_2 cfg negm ->
 config_node_OK cfg node ->
 BDDor_memo_OK cfg orm -> BDDor_memo_OK (fst (BDDneg cfg negm node)) orm.

Lemma BDDneg_keeps_node_OK :
 forall (cfg : BDDconfig) (negm : BDDneg_memo) (node : ad),
 BDDconfig_OK cfg ->
 BDDneg_memo_OK_2 cfg negm ->
 config_node_OK cfg node ->
 forall node' : ad,
 config_node_OK cfg node' ->
 config_node_OK (fst (BDDneg cfg negm node)) node'.

Lemma BDDneg_preserves_bool_fun :
 forall (cfg : BDDconfig) (negm : BDDneg_memo) (node : ad),
 BDDconfig_OK cfg ->
 BDDneg_memo_OK_2 cfg negm ->
 config_node_OK cfg node ->
 forall node' : ad,
 config_node_OK cfg node' ->
 bool_fun_eq (bool_fun_of_BDD (fst (BDDneg cfg negm node)) node')
   (bool_fun_of_BDD cfg node').

Lemma BDDneg_is_neg :
 forall (cfg : BDDconfig) (negm : BDDneg_memo) (node : ad),
 BDDconfig_OK cfg ->
 BDDneg_memo_OK_2 cfg negm ->
 config_node_OK cfg node ->
 bool_fun_eq
   (bool_fun_of_BDD (fst (BDDneg cfg negm node))
      (fst (snd (BDDneg cfg negm node))))
   (bool_fun_neg (bool_fun_of_BDD cfg node)).

Lemma BDDor_keeps_config_OK :
 forall (cfg : BDDconfig) (orm : BDDor_memo) (node1 node2 : ad),
 BDDconfig_OK cfg ->
 BDDor_memo_OK cfg orm ->
 config_node_OK cfg node1 ->
 config_node_OK cfg node2 -> BDDconfig_OK (fst (BDDor cfg orm node1 node2)).

Lemma BDDor_node_OK :
 forall (cfg : BDDconfig) (orm : BDDor_memo) (node1 node2 : ad),
 BDDconfig_OK cfg ->
 BDDor_memo_OK cfg orm ->
 config_node_OK cfg node1 ->
 config_node_OK cfg node2 ->
 config_node_OK (fst (BDDor cfg orm node1 node2))
   (fst (snd (BDDor cfg orm node1 node2))).

Lemma BDDor_keeps_or_memo_OK :
 forall (cfg : BDDconfig) (orm : BDDor_memo) (node1 node2 : ad),
 BDDconfig_OK cfg ->
 BDDor_memo_OK cfg orm ->
 config_node_OK cfg node1 ->
 config_node_OK cfg node2 ->
 BDDor_memo_OK (fst (BDDor cfg orm node1 node2))
   (snd (snd (BDDor cfg orm node1 node2))).

Lemma BDDor_preserves_nodes :
 forall (cfg : BDDconfig) (orm : BDDor_memo) (node1 node2 : ad),
 BDDconfig_OK cfg ->
 BDDor_memo_OK cfg orm ->
 config_node_OK cfg node1 ->
 config_node_OK cfg node2 ->
 nodes_preserved cfg (fst (BDDor cfg orm node1 node2)).

Lemma BDDor_keeps_node_OK :
 forall (cfg : BDDconfig) (orm : BDDor_memo) (node1 node2 : ad),
 BDDconfig_OK cfg ->
 BDDor_memo_OK cfg orm ->
 config_node_OK cfg node1 ->
 config_node_OK cfg node2 ->
 forall node : ad,
 config_node_OK cfg node ->
 config_node_OK (fst (BDDor cfg orm node1 node2)) node.

Lemma BDDor_preserves_bool_fun :
 forall (cfg : BDDconfig) (orm : BDDor_memo) (node1 node2 : ad),
 BDDconfig_OK cfg ->
 BDDor_memo_OK cfg orm ->
 config_node_OK cfg node1 ->
 config_node_OK cfg node2 ->
 forall node : ad,
 config_node_OK cfg node ->
 bool_fun_eq (bool_fun_of_BDD (fst (BDDor cfg orm node1 node2)) node)
   (bool_fun_of_BDD cfg node).

Lemma BDDor_keeps_neg_memo_OK :
 forall (cfg : BDDconfig) (negm : BDDneg_memo) (orm : BDDor_memo)
   (node1 node2 : ad),
 BDDconfig_OK cfg ->
 BDDor_memo_OK cfg orm ->
 config_node_OK cfg node1 ->
 config_node_OK cfg node2 ->
 BDDneg_memo_OK_2 cfg negm ->
 BDDneg_memo_OK_2 (fst (BDDor cfg orm node1 node2)) negm.

Lemma BDDor_is_or :
 forall (cfg : BDDconfig) (orm : BDDor_memo) (node1 node2 : ad),
 BDDconfig_OK cfg ->
 BDDor_memo_OK cfg orm ->
 config_node_OK cfg node1 ->
 config_node_OK cfg node2 ->
 bool_fun_eq
   (bool_fun_of_BDD (fst (BDDor cfg orm node1 node2))
      (fst (snd (BDDor cfg orm node1 node2))))
   (bool_fun_or (bool_fun_of_BDD cfg node1) (bool_fun_of_BDD cfg node2)).

Lemma BDDand_keeps_config_OK :
 forall (cfg : BDDconfig) (negm : BDDneg_memo) (orm : BDDor_memo)
   (node1 node2 : ad),
 BDDconfig_OK cfg ->
 BDDneg_memo_OK_2 cfg negm ->
 BDDor_memo_OK cfg orm ->
 config_node_OK cfg node1 ->
 config_node_OK cfg node2 ->
 BDDconfig_OK (fst (BDDand cfg negm orm node1 node2)).

Lemma BDDand_node_OK :
 forall (cfg : BDDconfig) (negm : BDDneg_memo) (orm : BDDor_memo)
   (node1 node2 : ad),
 BDDconfig_OK cfg ->
 BDDneg_memo_OK_2 cfg negm ->
 BDDor_memo_OK cfg orm ->
 config_node_OK cfg node1 ->
 config_node_OK cfg node2 ->
 config_node_OK (fst (BDDand cfg negm orm node1 node2))
   (fst (snd (BDDand cfg negm orm node1 node2))).

Lemma BDDand_preserves_nodes :
 forall (cfg : BDDconfig) (negm : BDDneg_memo) (orm : BDDor_memo)
   (node1 node2 : ad),
 BDDconfig_OK cfg ->
 BDDneg_memo_OK_2 cfg negm ->
 BDDor_memo_OK cfg orm ->
 config_node_OK cfg node1 ->
 config_node_OK cfg node2 ->
 nodes_preserved cfg (fst (BDDand cfg negm orm node1 node2)).

Lemma BDDand_keeps_node_OK :
 forall (cfg : BDDconfig) (negm : BDDneg_memo) (orm : BDDor_memo)
   (node1 node2 : ad),
 BDDconfig_OK cfg ->
 BDDneg_memo_OK_2 cfg negm ->
 BDDor_memo_OK cfg orm ->
 config_node_OK cfg node1 ->
 config_node_OK cfg node2 ->
 forall node : ad,
 config_node_OK cfg node ->
 config_node_OK (fst (BDDand cfg negm orm node1 node2)) node.

Lemma BDDand_preserves_bool_fun :
 forall (cfg : BDDconfig) (negm : BDDneg_memo) (orm : BDDor_memo)
   (node1 node2 : ad),
 BDDconfig_OK cfg ->
 BDDneg_memo_OK_2 cfg negm ->
 BDDor_memo_OK cfg orm ->
 config_node_OK cfg node1 ->
 config_node_OK cfg node2 ->
 forall node : ad,
 config_node_OK cfg node ->
 bool_fun_eq (bool_fun_of_BDD (fst (BDDand cfg negm orm node1 node2)) node)
   (bool_fun_of_BDD cfg node).

Lemma BDDand_keeps_neg_memo_OK :
 forall (cfg : BDDconfig) (negm : BDDneg_memo) (orm : BDDor_memo)
   (node1 node2 : ad),
 BDDconfig_OK cfg ->
 BDDneg_memo_OK_2 cfg negm ->
 BDDor_memo_OK cfg orm ->
 config_node_OK cfg node1 ->
 config_node_OK cfg node2 ->
 BDDneg_memo_OK_2 (fst (BDDand cfg negm orm node1 node2))
   (fst (snd (snd (BDDand cfg negm orm node1 node2)))).

Lemma BDDand_keeps_or_memo_OK :
 forall (cfg : BDDconfig) (negm : BDDneg_memo) (orm : BDDor_memo)
   (node1 node2 : ad),
 BDDconfig_OK cfg ->
 BDDneg_memo_OK_2 cfg negm ->
 BDDor_memo_OK cfg orm ->
 config_node_OK cfg node1 ->
 config_node_OK cfg node2 ->
 BDDor_memo_OK (fst (BDDand cfg negm orm node1 node2))
   (snd (snd (snd (BDDand cfg negm orm node1 node2)))).

Definition bool_fun_and (bf1 bf2 : bool_fun) : bool_fun :=
  fun vb : var_binding => bf1 vb && bf2 vb.

Lemma bool_fun_and_is_neg_or_neg_neg :
 forall bf1 bf2 : bool_fun,
 bool_fun_eq (bool_fun_and bf1 bf2)
   (bool_fun_neg (bool_fun_or (bool_fun_neg bf1) (bool_fun_neg bf2))).

Lemma BDDand_is_and :
 forall (cfg : BDDconfig) (negm : BDDneg_memo) (orm : BDDor_memo)
   (node1 node2 : ad),
 BDDconfig_OK cfg ->
 BDDneg_memo_OK_2 cfg negm ->
 BDDor_memo_OK cfg orm ->
 config_node_OK cfg node1 ->
 config_node_OK cfg node2 ->
 bool_fun_eq
   (bool_fun_of_BDD (fst (BDDand cfg negm orm node1 node2))
      (fst (snd (BDDand cfg negm orm node1 node2))))
   (bool_fun_and (bool_fun_of_BDD cfg node1) (bool_fun_of_BDD cfg node2)). *)



Definition BDDimpl (cfg : BDDconfig) (negm : BDDneg_memo) 

  (orm : BDDor_memo) (node1 node2 : ad) :=

  match BDDneg cfg negm node1 with

  | (cfg', (node1', negm')) =>

      match BDDor cfg' orm node1' node2 with

      | (cfg'', (node, orm')) => (cfg'', (node, (negm', orm')))

      end

  end.



Lemma BDDimpl_keeps_config_OK :

 forall (cfg : BDDconfig) (negm : BDDneg_memo) (orm : BDDor_memo)

   (node1 node2 : ad),

 BDDconfig_OK cfg ->

 BDDneg_memo_OK_2 cfg negm ->

 BDDor_memo_OK cfg orm ->

 config_node_OK cfg node1 ->

 config_node_OK cfg node2 ->

 BDDconfig_OK (fst (BDDimpl cfg negm orm node1 node2)).

Proof.

  intros.  unfold BDDimpl in |- *.  elim (prod_sum _ _ (BDDneg cfg negm node1)).  intros cfg' H4.

  elim H4; clear H4.  intro.  elim x; clear x.  intros node1' negm' H4.

  rewrite H4.  elim (prod_sum _ _ (BDDor cfg' orm node1' node2)).  intros cfg'' H5.

  elim H5; clear H5.  intro.  elim x; clear x.  intros node negm'' H5.  rewrite H5.

  simpl in |- *.  cut (BDDconfig_OK cfg').  cut (config_node_OK cfg' node1').  cut (config_node_OK cfg' node2).

  cut (BDDneg_memo_OK_2 cfg' negm').  cut (BDDor_memo_OK cfg' orm).  intros.

  replace cfg'' with (fst (BDDor cfg' orm node1' node2)).  apply BDDor_keeps_config_OK.

  assumption.  assumption.  assumption.  assumption.  rewrite H5; reflexivity.

  replace cfg' with (fst (BDDneg cfg negm node1)).  apply BDDneg_keeps_or_memo_OK.

  assumption.  assumption.  assumption.  assumption.  rewrite H4; reflexivity.

  replace cfg' with (fst (BDDneg cfg negm node1)).  replace negm' with (snd (snd (BDDneg cfg negm node1))).

  apply BDDneg_keeps_neg_memo_OK.  assumption.  assumption.  assumption.  

  rewrite H4; reflexivity.  rewrite H4; reflexivity.  replace cfg' with (fst (BDDneg cfg negm node1)).

  apply BDDneg_keeps_node_OK.  assumption.  assumption.  assumption.  assumption.

  rewrite H4; reflexivity.  replace cfg' with (fst (BDDneg cfg negm node1)).

  replace node1' with (fst (snd (BDDneg cfg negm node1))).  apply BDDneg_node_OK.

  assumption.  assumption.  assumption.  rewrite H4; reflexivity.  rewrite H4; reflexivity.

  replace cfg' with (fst (BDDneg cfg negm node1)).  apply BDDneg_keeps_config_OK.

  assumption.  assumption.  assumption.  rewrite H4; reflexivity.

Qed.



Lemma BDDimpl_node_OK :

 forall (cfg : BDDconfig) (negm : BDDneg_memo) (orm : BDDor_memo)

   (node1 node2 : ad),

 BDDconfig_OK cfg ->

 BDDneg_memo_OK_2 cfg negm ->

 BDDor_memo_OK cfg orm ->

 config_node_OK cfg node1 ->

 config_node_OK cfg node2 ->

 config_node_OK (fst (BDDimpl cfg negm orm node1 node2))

   (fst (snd (BDDimpl cfg negm orm node1 node2))).

Proof.



  intros.  unfold BDDimpl in |- *.  elim (prod_sum _ _ (BDDneg cfg negm node1)).  intros cfg' H4.

  elim H4; clear H4.  intro.  elim x; clear x.  intros node1' negm' H4.

  rewrite H4.  elim (prod_sum _ _ (BDDor cfg' orm node1' node2)).  intros cfg'' H5.

  elim H5; clear H5.  intro.  elim x; clear x.  intros node negm'' H5.  rewrite H5.

  simpl in |- *.  cut (BDDconfig_OK cfg').  cut (config_node_OK cfg' node1').  cut (config_node_OK cfg' node2).

  cut (BDDneg_memo_OK_2 cfg' negm').  cut (BDDor_memo_OK cfg' orm).  intros.

  replace cfg'' with (fst (BDDor cfg' orm node1' node2)).  replace node with (fst (snd (BDDor cfg' orm node1' node2))).

  apply BDDor_node_OK.  assumption.  assumption.  assumption.  assumption.

  rewrite H5; reflexivity.  rewrite H5; reflexivity.  

  replace cfg' with (fst (BDDneg cfg negm node1)).  apply BDDneg_keeps_or_memo_OK.

  assumption.  assumption.  assumption.  assumption.  rewrite H4; reflexivity.

  replace cfg' with (fst (BDDneg cfg negm node1)).  replace negm' with (snd (snd (BDDneg cfg negm node1))).

  apply BDDneg_keeps_neg_memo_OK.  assumption.  assumption.  assumption.

  rewrite H4; reflexivity.  rewrite H4; reflexivity.  replace cfg' with (fst (BDDneg cfg negm node1)).

  apply BDDneg_keeps_node_OK.  assumption.  assumption.  assumption.  assumption.

  rewrite H4; reflexivity.  replace cfg' with (fst (BDDneg cfg negm node1)).

  replace node1' with (fst (snd (BDDneg cfg negm node1))).  apply BDDneg_node_OK.

  assumption.  assumption.  assumption.  rewrite H4; reflexivity.  rewrite H4; reflexivity.

  replace cfg' with (fst (BDDneg cfg negm node1)).  apply BDDneg_keeps_config_OK.

  assumption.  assumption.  assumption.  rewrite H4; reflexivity.



Qed.



Definition bool_fun_impl (bf1 bf2 : bool_fun) : bool_fun :=

  fun vb : var_binding => implb (bf1 vb) (bf2 vb).



Lemma bool_fun_impl_is_neg_or_bf2 :

 forall bf1 bf2 : bool_fun,

 bool_fun_eq (bool_fun_impl bf1 bf2) (bool_fun_or (bool_fun_neg bf1) bf2).

Proof.

  unfold bool_fun_eq, bool_fun_impl, bool_fun_or, bool_fun_neg in |- *.  unfold bool_fun_eval in |- *.

  intros.  elim (bf1 vb).  elim (bf2 vb).  reflexivity.  reflexivity.  reflexivity.

Qed.



Lemma BDDimpl_is_impl :

 forall (cfg : BDDconfig) (negm : BDDneg_memo) (orm : BDDor_memo)

   (node1 node2 : ad),

 BDDconfig_OK cfg ->

 BDDneg_memo_OK_2 cfg negm ->

 BDDor_memo_OK cfg orm ->

 config_node_OK cfg node1 ->

 config_node_OK cfg node2 ->

 bool_fun_eq

   (bool_fun_of_BDD (fst (BDDimpl cfg negm orm node1 node2))

      (fst (snd (BDDimpl cfg negm orm node1 node2))))

   (bool_fun_impl (bool_fun_of_BDD cfg node1) (bool_fun_of_BDD cfg node2)).

Proof.

  intros.  unfold BDDimpl in |- *.  elim (prod_sum _ _ (BDDneg cfg negm node1)).  intros cfg' H4.

  elim H4; clear H4.  intro.  elim x; clear x.  intros node1' negm' H4.

  rewrite H4.  elim (prod_sum _ _ (BDDor cfg' orm node1' node2)).  intros cfg'' H5.

  elim H5; clear H5.  intro.  elim x; clear x.  intros node negm'' H5.  rewrite H5.

  simpl in |- *.  cut (BDDconfig_OK cfg').  cut (config_node_OK cfg' node1').  cut (config_node_OK cfg' node2).

  cut (BDDneg_memo_OK_2 cfg' negm').  cut (BDDor_memo_OK cfg' orm).  intros.

  apply

   bool_fun_eq_trans

    with

      (bf2 := bool_fun_or (bool_fun_of_BDD cfg' node1')

                (bool_fun_of_BDD cfg' node2)).

  replace cfg'' with (fst (BDDor cfg' orm node1' node2)).  replace node with (fst (snd (BDDor cfg' orm node1' node2))).

  apply BDDor_is_or.  assumption.  assumption.  assumption.  assumption.

  rewrite H5; reflexivity.  rewrite H5; reflexivity.  apply

   bool_fun_eq_trans

    with

      (bf2 := bool_fun_or (bool_fun_neg (bool_fun_of_BDD cfg node1))

                (bool_fun_of_BDD cfg node2)).

  apply bool_fun_or_preserves_eq.  replace cfg' with (fst (BDDneg cfg negm node1)).

  replace node1' with (fst (snd (BDDneg cfg negm node1))).  apply BDDneg_is_neg.

  assumption.  assumption.  assumption.  rewrite H4; reflexivity.  rewrite H4; reflexivity.

  replace cfg' with (fst (BDDneg cfg negm node1)).  apply BDDneg_preserves_bool_fun.

  assumption.  assumption.  assumption.  assumption.  rewrite H4; reflexivity.

  apply bool_fun_eq_symm.  apply bool_fun_impl_is_neg_or_bf2.  

  replace cfg' with (fst (BDDneg cfg negm node1)).  apply BDDneg_keeps_or_memo_OK.

  assumption.  assumption.  assumption.  assumption.  rewrite H4; reflexivity.

  replace cfg' with (fst (BDDneg cfg negm node1)).  replace negm' with (snd (snd (BDDneg cfg negm node1))).

  apply BDDneg_keeps_neg_memo_OK.  assumption.  assumption.  assumption.

  rewrite H4; reflexivity.  rewrite H4; reflexivity.  replace cfg' with (fst (BDDneg cfg negm node1)).

  apply BDDneg_keeps_node_OK.  assumption.  assumption.  assumption.  assumption.

  rewrite H4; reflexivity.  replace cfg' with (fst (BDDneg cfg negm node1)).

  replace node1' with (fst (snd (BDDneg cfg negm node1))).  apply BDDneg_node_OK.

  assumption.  assumption.  assumption.  rewrite H4; reflexivity.  rewrite H4; reflexivity.

  replace cfg' with (fst (BDDneg cfg negm node1)).  apply BDDneg_keeps_config_OK.

  assumption.  assumption.  assumption.  rewrite H4; reflexivity.



Qed.



Lemma BDDimpl_preserves_nodes :

 forall (cfg : BDDconfig) (negm : BDDneg_memo) (orm : BDDor_memo)

   (node1 node2 : ad),

 BDDconfig_OK cfg ->

 BDDneg_memo_OK_2 cfg negm ->

 BDDor_memo_OK cfg orm ->

 config_node_OK cfg node1 ->

 config_node_OK cfg node2 ->

 nodes_preserved cfg (fst (BDDimpl cfg negm orm node1 node2)).

Proof.

  intros.  unfold BDDimpl in |- *.  elim (prod_sum _ _ (BDDneg cfg negm node1)).  intros cfg' H4.

  elim H4; clear H4.  intro.  elim x; clear x.  intros node1' negm' H4.

  rewrite H4.  elim (prod_sum _ _ (BDDor cfg' orm node1' node2)).  intros cfg'' H5.

  elim H5; clear H5.  intro.  elim x; clear x.  intros node negm'' H5.  rewrite H5.

  simpl in |- *.  cut (BDDconfig_OK cfg').  cut (config_node_OK cfg' node1').  cut (config_node_OK cfg' node2).

  cut (BDDneg_memo_OK_2 cfg' negm').  cut (BDDor_memo_OK cfg' orm).  intros.

  apply nodes_preserved_trans with (cfg2 := cfg').  replace cfg' with (fst (BDDneg cfg negm node1)).

  apply BDDneg_preserves_nodes.  assumption.  assumption.  assumption.  rewrite H4; reflexivity.

  replace cfg'' with (fst (BDDor cfg' orm node1' node2)).  apply BDDor_preserves_nodes.

  assumption.  assumption.  assumption.  assumption.  rewrite H5; reflexivity.

  replace cfg' with (fst (BDDneg cfg negm node1)).  apply BDDneg_keeps_or_memo_OK.

  assumption.  assumption.  assumption.  assumption.  rewrite H4; reflexivity.

  replace cfg' with (fst (BDDneg cfg negm node1)).  replace negm' with (snd (snd (BDDneg cfg negm node1))).

  apply BDDneg_keeps_neg_memo_OK.  assumption.  assumption.  assumption.

  rewrite H4; reflexivity.  rewrite H4; reflexivity.  replace cfg' with (fst (BDDneg cfg negm node1)).

  apply BDDneg_keeps_node_OK.  assumption.  assumption.  assumption.  assumption.

  rewrite H4; reflexivity.  replace cfg' with (fst (BDDneg cfg negm node1)).

  replace node1' with (fst (snd (BDDneg cfg negm node1))).  apply BDDneg_node_OK.

  assumption.  assumption.  assumption.  rewrite H4; reflexivity.  rewrite H4; reflexivity.

  replace cfg' with (fst (BDDneg cfg negm node1)).  apply BDDneg_keeps_config_OK.

  assumption.  assumption.  assumption.  rewrite H4; reflexivity.



Qed.



Lemma BDDimpl_keeps_node_OK :

 forall (cfg : BDDconfig) (negm : BDDneg_memo) (orm : BDDor_memo)

   (node1 node2 : ad),

 BDDconfig_OK cfg ->

 BDDneg_memo_OK_2 cfg negm ->

 BDDor_memo_OK cfg orm ->

 config_node_OK cfg node1 ->

 config_node_OK cfg node2 ->

 forall node : ad,

 config_node_OK cfg node ->

 config_node_OK (fst (BDDimpl cfg negm orm node1 node2)) node.

Proof.

  intros.  apply nodes_preserved_2 with (cfg := cfg).  assumption.  apply BDDimpl_preserves_nodes.

  assumption.  assumption.  assumption.  assumption.  assumption.

Qed.



Lemma BDDimpl_preserves_bool_fun :

 forall (cfg : BDDconfig) (negm : BDDneg_memo) (orm : BDDor_memo)

   (node1 node2 : ad),

 BDDconfig_OK cfg ->

 BDDneg_memo_OK_2 cfg negm ->

 BDDor_memo_OK cfg orm ->

 config_node_OK cfg node1 ->

 config_node_OK cfg node2 ->

 forall node : ad,

 config_node_OK cfg node ->

 bool_fun_eq (bool_fun_of_BDD (fst (BDDimpl cfg negm orm node1 node2)) node)

   (bool_fun_of_BDD cfg node).

Proof.

  intros.  apply nodes_preserved_3.  assumption.  apply BDDimpl_keeps_config_OK.

  assumption.  assumption.  assumption.  assumption.  assumption.  apply BDDimpl_preserves_nodes.

  assumption.  assumption.  assumption.  assumption.  assumption.  assumption.

Qed.



Lemma BDDimpl_keeps_neg_memo_OK :

 forall (cfg : BDDconfig) (negm : BDDneg_memo) (orm : BDDor_memo)

   (node1 node2 : ad),

 BDDconfig_OK cfg ->

 BDDneg_memo_OK_2 cfg negm ->

 BDDor_memo_OK cfg orm ->

 config_node_OK cfg node1 ->

 config_node_OK cfg node2 ->

 BDDneg_memo_OK_2 (fst (BDDimpl cfg negm orm node1 node2))

   (fst (snd (snd (BDDimpl cfg negm orm node1 node2)))).

Proof.

  intros.  unfold BDDimpl in |- *.  elim (prod_sum _ _ (BDDneg cfg negm node1)).  intros cfg' H4.

  elim H4; clear H4.  intro.  elim x; clear x.  intros node1' negm' H4.

  rewrite H4.  elim (prod_sum _ _ (BDDor cfg' orm node1' node2)).  intros cfg'' H5.

  elim H5; clear H5.  intro.  elim x; clear x.  intros node negm'' H5.  rewrite H5.

  simpl in |- *.  cut (BDDconfig_OK cfg').  cut (config_node_OK cfg' node1').  cut (config_node_OK cfg' node2).

  cut (BDDneg_memo_OK_2 cfg' negm').  cut (BDDor_memo_OK cfg' orm).  intros.

  replace cfg'' with (fst (BDDor cfg' orm node1' node2)).  apply BDDor_keeps_neg_memo_OK.

  assumption.  assumption.  assumption.  assumption.  assumption.  rewrite H5; reflexivity.

  replace cfg' with (fst (BDDneg cfg negm node1)).  apply BDDneg_keeps_or_memo_OK.

  assumption.  assumption.  assumption.  assumption.  rewrite H4; reflexivity.

  replace cfg' with (fst (BDDneg cfg negm node1)).  replace negm' with (snd (snd (BDDneg cfg negm node1))).

  apply BDDneg_keeps_neg_memo_OK.  assumption.  assumption.  assumption.

  rewrite H4; reflexivity.  rewrite H4; reflexivity.  replace cfg' with (fst (BDDneg cfg negm node1)).

  apply BDDneg_keeps_node_OK.  assumption.  assumption.  assumption.  assumption.

  rewrite H4; reflexivity.  replace cfg' with (fst (BDDneg cfg negm node1)).

  replace node1' with (fst (snd (BDDneg cfg negm node1))).  apply BDDneg_node_OK.

  assumption.  assumption.  assumption.  rewrite H4; reflexivity.  rewrite H4; reflexivity.

  replace cfg' with (fst (BDDneg cfg negm node1)).  apply BDDneg_keeps_config_OK.

  assumption.  assumption.  assumption.  rewrite H4; reflexivity.



Qed.



Lemma BDDimpl_keeps_or_memo_OK :

 forall (cfg : BDDconfig) (negm : BDDneg_memo) (orm : BDDor_memo)

   (node1 node2 : ad),

 BDDconfig_OK cfg ->

 BDDneg_memo_OK_2 cfg negm ->

 BDDor_memo_OK cfg orm ->

 config_node_OK cfg node1 ->

 config_node_OK cfg node2 ->

 BDDor_memo_OK (fst (BDDimpl cfg negm orm node1 node2))

   (snd (snd (snd (BDDimpl cfg negm orm node1 node2)))).

Proof.

  intros.  unfold BDDimpl in |- *.  elim (prod_sum _ _ (BDDneg cfg negm node1)).  intros cfg' H4.

  elim H4; clear H4.  intro.  elim x; clear x.  intros node1' negm' H4.

  rewrite H4.  elim (prod_sum _ _ (BDDor cfg' orm node1' node2)).  intros cfg'' H5.

  elim H5; clear H5.  intro.  elim x; clear x.  intros node negm'' H5.  rewrite H5.

  simpl in |- *.  cut (BDDconfig_OK cfg').  cut (config_node_OK cfg' node1').  cut (config_node_OK cfg' node2).

  cut (BDDneg_memo_OK_2 cfg' negm').  cut (BDDor_memo_OK cfg' orm).  intros.

  replace cfg'' with (fst (BDDor cfg' orm node1' node2)).  replace negm'' with (snd (snd (BDDor cfg' orm node1' node2))).

  apply BDDor_keeps_or_memo_OK.  assumption.  assumption.  assumption.  assumption.

  rewrite H5; reflexivity.  rewrite H5; reflexivity.

  replace cfg' with (fst (BDDneg cfg negm node1)).  apply BDDneg_keeps_or_memo_OK.

  assumption.  assumption.  assumption.  assumption.  rewrite H4; reflexivity.

  replace cfg' with (fst (BDDneg cfg negm node1)).  replace negm' with (snd (snd (BDDneg cfg negm node1))).

  apply BDDneg_keeps_neg_memo_OK.  assumption.  assumption.  assumption.

  rewrite H4; reflexivity.  rewrite H4; reflexivity.  replace cfg' with (fst (BDDneg cfg negm node1)).

  apply BDDneg_keeps_node_OK.  assumption.  assumption.  assumption.  assumption.

  rewrite H4; reflexivity.  replace cfg' with (fst (BDDneg cfg negm node1)).

  replace node1' with (fst (snd (BDDneg cfg negm node1))).  apply BDDneg_node_OK.

  assumption.  assumption.  assumption.  rewrite H4; reflexivity.  rewrite H4; reflexivity.

  replace cfg' with (fst (BDDneg cfg negm node1)).  apply BDDneg_keeps_config_OK.

  assumption.  assumption.  assumption.  rewrite H4; reflexivity.

Qed.



Definition BDDiff (cfg : BDDconfig) (negm : BDDneg_memo) 

  (orm : BDDor_memo) (node1 node2 : ad) :=

  match BDDimpl cfg negm orm node1 node2 with

  | (cfg', (node1', (negm', orm'))) =>

      match BDDimpl cfg' negm' orm' node2 node1 with

      | (cfg'', (node2', (negm'', orm''))) =>

          BDDand cfg'' negm'' orm'' node1' node2'

      end

  end.



Lemma BDDiff_keeps_config_OK :

 forall (cfg : BDDconfig) (negm : BDDneg_memo) (orm : BDDor_memo)

   (node1 node2 : ad),

 BDDconfig_OK cfg ->

 BDDneg_memo_OK_2 cfg negm ->

 BDDor_memo_OK cfg orm ->

 config_node_OK cfg node1 ->

 config_node_OK cfg node2 ->

 BDDconfig_OK (fst (BDDiff cfg negm orm node1 node2)).

Proof.

  intros.  unfold BDDiff in |- *.  elim (prod_sum _ _ (BDDimpl cfg negm orm node1 node2)).

  intros cfg' H4.  elim H4; clear H4.  intro.  elim x; clear x.  intros node1' y.

  elim y; clear y.  intros negm' orm' H4.  rewrite H4.  elim (prod_sum _ _ (BDDimpl cfg' negm' orm' node2 node1)).

  intros cfg'' H5.  elim H5; clear H5.  intro.  elim x; clear x.  intros node2' y.

  elim y; clear y.  intros negm'' orm'' H5.  rewrite H5.  cut (BDDconfig_OK cfg').

  cut (config_node_OK cfg' node1').  cut (config_node_OK cfg' node1).  cut (config_node_OK cfg' node2).

  cut (BDDneg_memo_OK_2 cfg' negm').  cut (BDDor_memo_OK cfg' orm').  intros.

  cut (BDDconfig_OK cfg'').  cut (config_node_OK cfg'' node2').  cut (config_node_OK cfg'' node1').

  cut (BDDneg_memo_OK_2 cfg'' negm'').  cut (BDDor_memo_OK cfg'' orm'').  intros.

  apply BDDand_keeps_config_OK.  assumption.  assumption.  assumption.  assumption.  assumption.  

  replace cfg'' with (fst (BDDimpl cfg' negm' orm' node2 node1)).  replace orm'' with (snd (snd (snd (BDDimpl cfg' negm' orm' node2 node1)))).

  apply BDDimpl_keeps_or_memo_OK.  assumption.  assumption.  assumption.  assumption.

  assumption.  rewrite H5; reflexivity.  rewrite H5; reflexivity.  replace cfg'' with (fst (BDDimpl cfg' negm' orm' node2 node1)).

  replace negm'' with (fst (snd (snd (BDDimpl cfg' negm' orm' node2 node1)))).

  apply BDDimpl_keeps_neg_memo_OK.  assumption.  assumption.  assumption.  assumption.

  assumption.  rewrite H5; reflexivity.  rewrite H5; reflexivity.  replace cfg'' with (fst (BDDimpl cfg' negm' orm' node2 node1)).

  apply BDDimpl_keeps_node_OK.  assumption.  assumption.  assumption.  assumption.

  assumption.  assumption.  rewrite H5; reflexivity.  replace cfg'' with (fst (BDDimpl cfg' negm' orm' node2 node1)).

  replace node2' with (fst (snd (BDDimpl cfg' negm' orm' node2 node1))).  apply BDDimpl_node_OK.

  assumption.  assumption.  assumption.  assumption.  assumption.  rewrite H5; reflexivity.

  rewrite H5; reflexivity.  replace cfg'' with (fst (BDDimpl cfg' negm' orm' node2 node1)).

  apply BDDimpl_keeps_config_OK.  assumption.  assumption.  assumption.  assumption.

  assumption.  rewrite H5; reflexivity.  replace cfg' with (fst (BDDimpl cfg negm orm node1 node2)).

  replace orm' with (snd (snd (snd (BDDimpl cfg negm orm node1 node2)))).  apply BDDimpl_keeps_or_memo_OK.

  assumption.  assumption.  assumption.  assumption.  assumption.  rewrite H4; reflexivity.

  rewrite H4; reflexivity.  replace cfg' with (fst (BDDimpl cfg negm orm node1 node2)).

  replace negm' with (fst (snd (snd (BDDimpl cfg negm orm node1 node2)))).

  apply BDDimpl_keeps_neg_memo_OK.  assumption.  assumption.  assumption.  assumption.

  assumption.  rewrite H4; reflexivity.  rewrite H4; reflexivity.  replace cfg' with (fst (BDDimpl cfg negm orm node1 node2)).

  apply BDDimpl_keeps_node_OK.  assumption.  assumption.  assumption.  assumption.

  assumption.  assumption.  rewrite H4; reflexivity.  replace cfg' with (fst (BDDimpl cfg negm orm node1 node2)).

  apply BDDimpl_keeps_node_OK.  assumption.  assumption.  assumption.  assumption.

  assumption.  assumption.  rewrite H4; reflexivity.  replace cfg' with (fst (BDDimpl cfg negm orm node1 node2)).

  replace node1' with (fst (snd (BDDimpl cfg negm orm node1 node2))).  apply BDDimpl_node_OK.

  assumption.  assumption.  assumption.  assumption.  assumption.  rewrite H4; reflexivity.

  rewrite H4; reflexivity.  replace cfg' with (fst (BDDimpl cfg negm orm node1 node2)).

  apply BDDimpl_keeps_config_OK.  assumption.  assumption.  assumption.  assumption.

  assumption.  rewrite H4; reflexivity.

Qed.



Lemma BDDiff_node_OK :

 forall (cfg : BDDconfig) (negm : BDDneg_memo) (orm : BDDor_memo)

   (node1 node2 : ad),

 BDDconfig_OK cfg ->

 BDDneg_memo_OK_2 cfg negm ->

 BDDor_memo_OK cfg orm ->

 config_node_OK cfg node1 ->

 config_node_OK cfg node2 ->

 config_node_OK (fst (BDDiff cfg negm orm node1 node2))

   (fst (snd (BDDiff cfg negm orm node1 node2))).

Proof.

  intros.  unfold BDDiff in |- *.  elim (prod_sum _ _ (BDDimpl cfg negm orm node1 node2)).

  intros cfg' H4.  elim H4; clear H4.  intro.  elim x; clear x.  intros node1' y.

  elim y; clear y.  intros negm' orm' H4.  rewrite H4.  elim (prod_sum _ _ (BDDimpl cfg' negm' orm' node2 node1)).

  intros cfg'' H5.  elim H5; clear H5.  intro.  elim x; clear x.  intros node2' y.

  elim y; clear y.  intros negm'' orm'' H5.  rewrite H5.  cut (BDDconfig_OK cfg').

  cut (config_node_OK cfg' node1').  cut (config_node_OK cfg' node1).  cut (config_node_OK cfg' node2).

  cut (BDDneg_memo_OK_2 cfg' negm').  cut (BDDor_memo_OK cfg' orm').  intros.

  cut (BDDconfig_OK cfg'').  cut (config_node_OK cfg'' node2').  cut (config_node_OK cfg'' node1').

  cut (BDDneg_memo_OK_2 cfg'' negm'').  cut (BDDor_memo_OK cfg'' orm'').  intros.

  apply BDDand_node_OK.  assumption.  assumption.  assumption.  assumption.  assumption.

  replace cfg'' with (fst (BDDimpl cfg' negm' orm' node2 node1)).  replace orm'' with (snd (snd (snd (BDDimpl cfg' negm' orm' node2 node1)))).

  apply BDDimpl_keeps_or_memo_OK.  assumption.  assumption.  assumption.  assumption.

  assumption.  rewrite H5; reflexivity.  rewrite H5; reflexivity.  replace cfg'' with (fst (BDDimpl cfg' negm' orm' node2 node1)).

  replace negm'' with (fst (snd (snd (BDDimpl cfg' negm' orm' node2 node1)))).

  apply BDDimpl_keeps_neg_memo_OK.  assumption.  assumption.  assumption.  assumption.

  assumption.  rewrite H5; reflexivity.  rewrite H5; reflexivity.  replace cfg'' with (fst (BDDimpl cfg' negm' orm' node2 node1)).

  apply BDDimpl_keeps_node_OK.  assumption.  assumption.  assumption.  assumption.

  assumption.  assumption.  rewrite H5; reflexivity.  replace cfg'' with (fst (BDDimpl cfg' negm' orm' node2 node1)).

  replace node2' with (fst (snd (BDDimpl cfg' negm' orm' node2 node1))).  apply BDDimpl_node_OK.

  assumption.  assumption.  assumption.  assumption.  assumption.  rewrite H5; reflexivity.

  rewrite H5; reflexivity.  replace cfg'' with (fst (BDDimpl cfg' negm' orm' node2 node1)).

  apply BDDimpl_keeps_config_OK.  assumption.  assumption.  assumption.  assumption.

  assumption.  rewrite H5; reflexivity.  replace cfg' with (fst (BDDimpl cfg negm orm node1 node2)).

  replace orm' with (snd (snd (snd (BDDimpl cfg negm orm node1 node2)))).  apply BDDimpl_keeps_or_memo_OK.

  assumption.  assumption.  assumption.  assumption.  assumption.  rewrite H4; reflexivity.

  rewrite H4; reflexivity.  replace cfg' with (fst (BDDimpl cfg negm orm node1 node2)).

  replace negm' with (fst (snd (snd (BDDimpl cfg negm orm node1 node2)))).

  apply BDDimpl_keeps_neg_memo_OK.  assumption.  assumption.  assumption.  assumption.

  assumption.  rewrite H4; reflexivity.  rewrite H4; reflexivity.  replace cfg' with (fst (BDDimpl cfg negm orm node1 node2)).

  apply BDDimpl_keeps_node_OK.  assumption.  assumption.  assumption.  assumption.

  assumption.  assumption.  rewrite H4; reflexivity.  replace cfg' with (fst (BDDimpl cfg negm orm node1 node2)).

  apply BDDimpl_keeps_node_OK.  assumption.  assumption.  assumption.  assumption.

  assumption.  assumption.  rewrite H4; reflexivity.  replace cfg' with (fst (BDDimpl cfg negm orm node1 node2)).

  replace node1' with (fst (snd (BDDimpl cfg negm orm node1 node2))).  apply BDDimpl_node_OK.

  assumption.  assumption.  assumption.  assumption.  assumption.  rewrite H4; reflexivity.

  rewrite H4; reflexivity.  replace cfg' with (fst (BDDimpl cfg negm orm node1 node2)).

  apply BDDimpl_keeps_config_OK.  assumption.  assumption.  assumption.  assumption.

  assumption.  rewrite H4; reflexivity.

Qed.



Lemma BDDiff_preserves_nodes :

 forall (cfg : BDDconfig) (negm : BDDneg_memo) (orm : BDDor_memo)

   (node1 node2 : ad),

 BDDconfig_OK cfg ->

 BDDneg_memo_OK_2 cfg negm ->

 BDDor_memo_OK cfg orm ->

 config_node_OK cfg node1 ->

 config_node_OK cfg node2 ->

 nodes_preserved cfg (fst (BDDiff cfg negm orm node1 node2)).

Proof.

  intros.  unfold BDDiff in |- *.  elim (prod_sum _ _ (BDDimpl cfg negm orm node1 node2)).

  intros cfg' H4.  elim H4; clear H4.  intro.  elim x; clear x.  intros node1' y.

  elim y; clear y.  intros negm' orm' H4.  rewrite H4.  elim (prod_sum _ _ (BDDimpl cfg' negm' orm' node2 node1)).

  intros cfg'' H5.  elim H5; clear H5.  intro.  elim x; clear x.  intros node2' y.

  elim y; clear y.  intros negm'' orm'' H5.  rewrite H5.  cut (BDDconfig_OK cfg').

  cut (config_node_OK cfg' node1').  cut (config_node_OK cfg' node1).  cut (config_node_OK cfg' node2).

  cut (BDDneg_memo_OK_2 cfg' negm').  cut (BDDor_memo_OK cfg' orm').  intros.

  cut (BDDconfig_OK cfg'').  cut (config_node_OK cfg'' node2').  cut (config_node_OK cfg'' node1').

  cut (BDDneg_memo_OK_2 cfg'' negm'').  cut (BDDor_memo_OK cfg'' orm'').  intros.

  apply nodes_preserved_trans with (cfg2 := cfg').  replace cfg' with (fst (BDDimpl cfg negm orm node1 node2)).

  apply BDDimpl_preserves_nodes.  assumption.  assumption.  assumption.  assumption.

  assumption.  rewrite H4; reflexivity.  apply nodes_preserved_trans with (cfg2 := cfg'').

  replace cfg'' with (fst (BDDimpl cfg' negm' orm' node2 node1)).  apply BDDimpl_preserves_nodes.

  assumption.  assumption.  assumption.  assumption.  assumption.  rewrite H5; reflexivity.

  apply BDDand_preserves_nodes.  assumption.  assumption.  assumption.  assumption.

  assumption.

  replace cfg'' with (fst (BDDimpl cfg' negm' orm' node2 node1)).  replace orm'' with (snd (snd (snd (BDDimpl cfg' negm' orm' node2 node1)))).

  apply BDDimpl_keeps_or_memo_OK.  assumption.  assumption.  assumption.  assumption.

  assumption.  rewrite H5; reflexivity.  rewrite H5; reflexivity.  replace cfg'' with (fst (BDDimpl cfg' negm' orm' node2 node1)).

  replace negm'' with (fst (snd (snd (BDDimpl cfg' negm' orm' node2 node1)))).

  apply BDDimpl_keeps_neg_memo_OK.  assumption.  assumption.  assumption.  assumption.

  assumption.  rewrite H5; reflexivity.  rewrite H5; reflexivity.  replace cfg'' with (fst (BDDimpl cfg' negm' orm' node2 node1)).

  apply BDDimpl_keeps_node_OK.  assumption.  assumption.  assumption.  assumption.

  assumption.  assumption.  rewrite H5; reflexivity.  replace cfg'' with (fst (BDDimpl cfg' negm' orm' node2 node1)).

  replace node2' with (fst (snd (BDDimpl cfg' negm' orm' node2 node1))).  apply BDDimpl_node_OK.

  assumption.  assumption.  assumption.  assumption.  assumption.  rewrite H5; reflexivity.

  rewrite H5; reflexivity.  replace cfg'' with (fst (BDDimpl cfg' negm' orm' node2 node1)).

  apply BDDimpl_keeps_config_OK.  assumption.  assumption.  assumption.  assumption.

  assumption.  rewrite H5; reflexivity.  replace cfg' with (fst (BDDimpl cfg negm orm node1 node2)).

  replace orm' with (snd (snd (snd (BDDimpl cfg negm orm node1 node2)))).  apply BDDimpl_keeps_or_memo_OK.

  assumption.  assumption.  assumption.  assumption.  assumption.  rewrite H4; reflexivity.

  rewrite H4; reflexivity.  replace cfg' with (fst (BDDimpl cfg negm orm node1 node2)).

  replace negm' with (fst (snd (snd (BDDimpl cfg negm orm node1 node2)))).

  apply BDDimpl_keeps_neg_memo_OK.  assumption.  assumption.  assumption.  assumption.

  assumption.  rewrite H4; reflexivity.  rewrite H4; reflexivity.  replace cfg' with (fst (BDDimpl cfg negm orm node1 node2)).

  apply BDDimpl_keeps_node_OK.  assumption.  assumption.  assumption.  assumption.

  assumption.  assumption.  rewrite H4; reflexivity.  replace cfg' with (fst (BDDimpl cfg negm orm node1 node2)).

  apply BDDimpl_keeps_node_OK.  assumption.  assumption.  assumption.  assumption.

  assumption.  assumption.  rewrite H4; reflexivity.  replace cfg' with (fst (BDDimpl cfg negm orm node1 node2)).

  replace node1' with (fst (snd (BDDimpl cfg negm orm node1 node2))).  apply BDDimpl_node_OK.

  assumption.  assumption.  assumption.  assumption.  assumption.  rewrite H4; reflexivity.

  rewrite H4; reflexivity.  replace cfg' with (fst (BDDimpl cfg negm orm node1 node2)).

  apply BDDimpl_keeps_config_OK.  assumption.  assumption.  assumption.  assumption.

  assumption.  rewrite H4; reflexivity.

Qed. 



Lemma BDDiff_keeps_neg_memo_OK :

 forall (cfg : BDDconfig) (negm : BDDneg_memo) (orm : BDDor_memo)

   (node1 node2 : ad),

 BDDconfig_OK cfg ->

 BDDneg_memo_OK_2 cfg negm ->

 BDDor_memo_OK cfg orm ->

 config_node_OK cfg node1 ->

 config_node_OK cfg node2 ->

 BDDneg_memo_OK_2 (fst (BDDiff cfg negm orm node1 node2))

   (fst (snd (snd (BDDiff cfg negm orm node1 node2)))).

Proof.

  intros.  unfold BDDiff in |- *.  elim (prod_sum _ _ (BDDimpl cfg negm orm node1 node2)).

  intros cfg' H4.  elim H4; clear H4.  intro.  elim x; clear x.  intros node1' y.

  elim y; clear y.  intros negm' orm' H4.  rewrite H4.  elim (prod_sum _ _ (BDDimpl cfg' negm' orm' node2 node1)).

  intros cfg'' H5.  elim H5; clear H5.  intro.  elim x; clear x.  intros node2' y.

  elim y; clear y.  intros negm'' orm'' H5.  rewrite H5.  cut (BDDconfig_OK cfg').

  cut (config_node_OK cfg' node1').  cut (config_node_OK cfg' node1).  cut (config_node_OK cfg' node2).

  cut (BDDneg_memo_OK_2 cfg' negm').  cut (BDDor_memo_OK cfg' orm').  intros.

  cut (BDDconfig_OK cfg'').  cut (config_node_OK cfg'' node2').  cut (config_node_OK cfg'' node1').

  cut (BDDneg_memo_OK_2 cfg'' negm'').  cut (BDDor_memo_OK cfg'' orm'').  intros.

  apply BDDand_keeps_neg_memo_OK.  assumption.  assumption.  assumption.  assumption.  assumption.

  replace cfg'' with (fst (BDDimpl cfg' negm' orm' node2 node1)).  replace orm'' with (snd (snd (snd (BDDimpl cfg' negm' orm' node2 node1)))).

  apply BDDimpl_keeps_or_memo_OK.  assumption.  assumption.  assumption.  assumption.

  assumption.  rewrite H5; reflexivity.  rewrite H5; reflexivity.  replace cfg'' with (fst (BDDimpl cfg' negm' orm' node2 node1)).

  replace negm'' with (fst (snd (snd (BDDimpl cfg' negm' orm' node2 node1)))).

  apply BDDimpl_keeps_neg_memo_OK.  assumption.  assumption.  assumption.  assumption.

  assumption.  rewrite H5; reflexivity.  rewrite H5; reflexivity.  replace cfg'' with (fst (BDDimpl cfg' negm' orm' node2 node1)).

  apply BDDimpl_keeps_node_OK.  assumption.  assumption.  assumption.  assumption.

  assumption.  assumption.  rewrite H5; reflexivity.  replace cfg'' with (fst (BDDimpl cfg' negm' orm' node2 node1)).

  replace node2' with (fst (snd (BDDimpl cfg' negm' orm' node2 node1))).  apply BDDimpl_node_OK.

  assumption.  assumption.  assumption.  assumption.  assumption.  rewrite H5; reflexivity.

  rewrite H5; reflexivity.  replace cfg'' with (fst (BDDimpl cfg' negm' orm' node2 node1)).

  apply BDDimpl_keeps_config_OK.  assumption.  assumption.  assumption.  assumption.

  assumption.  rewrite H5; reflexivity.  replace cfg' with (fst (BDDimpl cfg negm orm node1 node2)).

  replace orm' with (snd (snd (snd (BDDimpl cfg negm orm node1 node2)))).  apply BDDimpl_keeps_or_memo_OK.

  assumption.  assumption.  assumption.  assumption.  assumption.  rewrite H4; reflexivity.

  rewrite H4; reflexivity.  replace cfg' with (fst (BDDimpl cfg negm orm node1 node2)).

  replace negm' with (fst (snd (snd (BDDimpl cfg negm orm node1 node2)))).

  apply BDDimpl_keeps_neg_memo_OK.  assumption.  assumption.  assumption.  assumption.

  assumption.  rewrite H4; reflexivity.  rewrite H4; reflexivity.  replace cfg' with (fst (BDDimpl cfg negm orm node1 node2)).

  apply BDDimpl_keeps_node_OK.  assumption.  assumption.  assumption.  assumption.

  assumption.  assumption.  rewrite H4; reflexivity.  replace cfg' with (fst (BDDimpl cfg negm orm node1 node2)).

  apply BDDimpl_keeps_node_OK.  assumption.  assumption.  assumption.  assumption.

  assumption.  assumption.  rewrite H4; reflexivity.  replace cfg' with (fst (BDDimpl cfg negm orm node1 node2)).

  replace node1' with (fst (snd (BDDimpl cfg negm orm node1 node2))).  apply BDDimpl_node_OK.

  assumption.  assumption.  assumption.  assumption.  assumption.  rewrite H4; reflexivity.

  rewrite H4; reflexivity.  replace cfg' with (fst (BDDimpl cfg negm orm node1 node2)).

  apply BDDimpl_keeps_config_OK.  assumption.  assumption.  assumption.  assumption.

  assumption.  rewrite H4; reflexivity.

Qed.



Lemma BDDiff_keeps_or_memo_OK :

 forall (cfg : BDDconfig) (negm : BDDneg_memo) (orm : BDDor_memo)

   (node1 node2 : ad),

 BDDconfig_OK cfg ->

 BDDneg_memo_OK_2 cfg negm ->

 BDDor_memo_OK cfg orm ->

 config_node_OK cfg node1 ->

 config_node_OK cfg node2 ->

 BDDor_memo_OK (fst (BDDiff cfg negm orm node1 node2))

   (snd (snd (snd (BDDiff cfg negm orm node1 node2)))).

Proof.

  intros.  unfold BDDiff in |- *.  elim (prod_sum _ _ (BDDimpl cfg negm orm node1 node2)).

  intros cfg' H4.  elim H4; clear H4.  intro.  elim x; clear x.  intros node1' y.

  elim y; clear y.  intros negm' orm' H4.  rewrite H4.  elim (prod_sum _ _ (BDDimpl cfg' negm' orm' node2 node1)).

  intros cfg'' H5.  elim H5; clear H5.  intro.  elim x; clear x.  intros node2' y.

  elim y; clear y.  intros negm'' orm'' H5.  rewrite H5.  cut (BDDconfig_OK cfg').

  cut (config_node_OK cfg' node1').  cut (config_node_OK cfg' node1).  cut (config_node_OK cfg' node2).

  cut (BDDneg_memo_OK_2 cfg' negm').  cut (BDDor_memo_OK cfg' orm').  intros.

  cut (BDDconfig_OK cfg'').  cut (config_node_OK cfg'' node2').  cut (config_node_OK cfg'' node1').

  cut (BDDneg_memo_OK_2 cfg'' negm'').  cut (BDDor_memo_OK cfg'' orm'').  intros.

  apply BDDand_keeps_or_memo_OK.  assumption.  assumption.  assumption.  assumption.  assumption.  

  replace cfg'' with (fst (BDDimpl cfg' negm' orm' node2 node1)).  replace orm'' with (snd (snd (snd (BDDimpl cfg' negm' orm' node2 node1)))).

  apply BDDimpl_keeps_or_memo_OK.  assumption.  assumption.  assumption.  assumption.

  assumption.  rewrite H5; reflexivity.  rewrite H5; reflexivity.  replace cfg'' with (fst (BDDimpl cfg' negm' orm' node2 node1)).

  replace negm'' with (fst (snd (snd (BDDimpl cfg' negm' orm' node2 node1)))).

  apply BDDimpl_keeps_neg_memo_OK.  assumption.  assumption.  assumption.  assumption.

  assumption.  rewrite H5; reflexivity.  rewrite H5; reflexivity.  replace cfg'' with (fst (BDDimpl cfg' negm' orm' node2 node1)).

  apply BDDimpl_keeps_node_OK.  assumption.  assumption.  assumption.  assumption.

  assumption.  assumption.  rewrite H5; reflexivity.  replace cfg'' with (fst (BDDimpl cfg' negm' orm' node2 node1)).

  replace node2' with (fst (snd (BDDimpl cfg' negm' orm' node2 node1))).  apply BDDimpl_node_OK.

  assumption.  assumption.  assumption.  assumption.  assumption.  rewrite H5; reflexivity.

  rewrite H5; reflexivity.  replace cfg'' with (fst (BDDimpl cfg' negm' orm' node2 node1)).

  apply BDDimpl_keeps_config_OK.  assumption.  assumption.  assumption.  assumption.

  assumption.  rewrite H5; reflexivity.  replace cfg' with (fst (BDDimpl cfg negm orm node1 node2)).

  replace orm' with (snd (snd (snd (BDDimpl cfg negm orm node1 node2)))).  apply BDDimpl_keeps_or_memo_OK.

  assumption.  assumption.  assumption.  assumption.  assumption.  rewrite H4; reflexivity.

  rewrite H4; reflexivity.  replace cfg' with (fst (BDDimpl cfg negm orm node1 node2)).

  replace negm' with (fst (snd (snd (BDDimpl cfg negm orm node1 node2)))).

  apply BDDimpl_keeps_neg_memo_OK.  assumption.  assumption.  assumption.  assumption.

  assumption.  rewrite H4; reflexivity.  rewrite H4; reflexivity.  replace cfg' with (fst (BDDimpl cfg negm orm node1 node2)).

  apply BDDimpl_keeps_node_OK.  assumption.  assumption.  assumption.  assumption.

  assumption.  assumption.  rewrite H4; reflexivity.  replace cfg' with (fst (BDDimpl cfg negm orm node1 node2)).

  apply BDDimpl_keeps_node_OK.  assumption.  assumption.  assumption.  assumption.

  assumption.  assumption.  rewrite H4; reflexivity.  replace cfg' with (fst (BDDimpl cfg negm orm node1 node2)).

  replace node1' with (fst (snd (BDDimpl cfg negm orm node1 node2))).  apply BDDimpl_node_OK.

  assumption.  assumption.  assumption.  assumption.  assumption.  rewrite H4; reflexivity.

  rewrite H4; reflexivity.  replace cfg' with (fst (BDDimpl cfg negm orm node1 node2)).

  apply BDDimpl_keeps_config_OK.  assumption.  assumption.  assumption.  assumption.

  assumption.  rewrite H4; reflexivity.

Qed.



Definition bool_fun_iff (bf1 bf2 : bool_fun) : bool_fun :=

  fun vb : var_binding => eqb (bf1 vb) (bf2 vb).



Lemma bool_fun_iff_is_and_impl_impl :

 forall bf1 bf2 : bool_fun,

 bool_fun_eq (bool_fun_iff bf1 bf2)

   (bool_fun_and (bool_fun_impl bf1 bf2) (bool_fun_impl bf2 bf1)).

Proof.

  unfold bool_fun_iff, bool_fun_eq, bool_fun_and, bool_fun_impl in |- *.  unfold bool_fun_eval in |- *.

  intros.  elim (bf1 vb).  elim (bf2 vb).  reflexivity.  reflexivity.  reflexivity.

Qed.



Lemma bool_fun_and_preserves_eq :

 forall bf1 bf2 bf1' bf2' : bool_fun,

 bool_fun_eq bf1 bf1' ->

 bool_fun_eq bf2 bf2' ->

 bool_fun_eq (bool_fun_and bf1 bf2) (bool_fun_and bf1' bf2').

Proof.

  intros.  unfold bool_fun_eq in H, H0.  unfold bool_fun_eval in H, H0.

  unfold bool_fun_eq, bool_fun_and in |- *.  unfold bool_fun_eval in |- *.  intro.  rewrite (H vb).

  rewrite (H0 vb).  reflexivity.

Qed.



Lemma bool_fun_impl_preserves_eq :

 forall bf1 bf2 bf1' bf2' : bool_fun,

 bool_fun_eq bf1 bf1' ->

 bool_fun_eq bf2 bf2' ->

 bool_fun_eq (bool_fun_impl bf1 bf2) (bool_fun_impl bf1' bf2').

Proof.

  intros.  unfold bool_fun_eq in H, H0.  unfold bool_fun_eval in H, H0.

  unfold bool_fun_eq, bool_fun_impl in |- *.  unfold bool_fun_eval in |- *.  intro.  rewrite (H vb).

  rewrite (H0 vb).  reflexivity.

Qed.



Lemma bool_fun_iff_preserves_eq :

 forall bf1 bf2 bf1' bf2' : bool_fun,

 bool_fun_eq bf1 bf1' ->

 bool_fun_eq bf2 bf2' ->

 bool_fun_eq (bool_fun_iff bf1 bf2) (bool_fun_iff bf1' bf2').

Proof.

  intros.  unfold bool_fun_eq in H, H0.  unfold bool_fun_eval in H, H0.

  unfold bool_fun_eq, bool_fun_iff in |- *.  unfold bool_fun_eval in |- *.  intro.  rewrite (H vb).

  rewrite (H0 vb).  reflexivity.

Qed.



Lemma BDDiff_is_iff :

 forall (cfg : BDDconfig) (negm : BDDneg_memo) (orm : BDDor_memo)

   (node1 node2 : ad),

 BDDconfig_OK cfg ->

 BDDneg_memo_OK_2 cfg negm ->

 BDDor_memo_OK cfg orm ->

 config_node_OK cfg node1 ->

 config_node_OK cfg node2 ->

 bool_fun_eq

   (bool_fun_of_BDD (fst (BDDiff cfg negm orm node1 node2))

      (fst (snd (BDDiff cfg negm orm node1 node2))))

   (bool_fun_iff (bool_fun_of_BDD cfg node1) (bool_fun_of_BDD cfg node2)).

Proof.

  intros.  unfold BDDiff in |- *.  elim (prod_sum _ _ (BDDimpl cfg negm orm node1 node2)).

  intros cfg' H4.  elim H4; clear H4.  intro.  elim x; clear x.  intros node1' y.

  elim y; clear y.  intros negm' orm' H4.  rewrite H4.  elim (prod_sum _ _ (BDDimpl cfg' negm' orm' node2 node1)).

  intros cfg'' H5.  elim H5; clear H5.  intro.  elim x; clear x.  intros node2' y.

  elim y; clear y.  intros negm'' orm'' H5.  rewrite H5.  cut (BDDconfig_OK cfg').

  cut (config_node_OK cfg' node1').  cut (config_node_OK cfg' node1).  cut (config_node_OK cfg' node2).

  cut (BDDneg_memo_OK_2 cfg' negm').  cut (BDDor_memo_OK cfg' orm').  intros.

  cut (BDDconfig_OK cfg'').  cut (config_node_OK cfg'' node2').  cut (config_node_OK cfg'' node1').

  cut (BDDneg_memo_OK_2 cfg'' negm'').  cut (BDDor_memo_OK cfg'' orm'').  intros.

  apply

   bool_fun_eq_trans

    with

      (bf2 := bool_fun_and (bool_fun_of_BDD cfg'' node1')

                (bool_fun_of_BDD cfg'' node2')).

  apply BDDand_is_and.  assumption.  assumption.  assumption.  assumption.  assumption.

  apply

   bool_fun_eq_trans

    with

      (bf2 := bool_fun_and

                (bool_fun_impl (bool_fun_of_BDD cfg node1)

                   (bool_fun_of_BDD cfg node2))

                (bool_fun_impl (bool_fun_of_BDD cfg node2)

                   (bool_fun_of_BDD cfg node1))).

  apply bool_fun_and_preserves_eq.  apply bool_fun_eq_trans with (bf2 := bool_fun_of_BDD cfg' node1').

  replace cfg'' with (fst (BDDimpl cfg' negm' orm' node2 node1)).  apply BDDimpl_preserves_bool_fun.

  assumption.  assumption.  assumption.  assumption.  assumption.  assumption.

  rewrite H5; reflexivity.  replace cfg' with (fst (BDDimpl cfg negm orm node1 node2)).

  replace node1' with (fst (snd (BDDimpl cfg negm orm node1 node2))).  apply BDDimpl_is_impl.

  assumption.  assumption.  assumption.  assumption.  assumption.  rewrite H4; reflexivity.

  rewrite H4; reflexivity.  apply

   bool_fun_eq_trans

    with

      (bf2 := bool_fun_impl (bool_fun_of_BDD cfg' node2)

                (bool_fun_of_BDD cfg' node1)).  replace cfg'' with (fst (BDDimpl cfg' negm' orm' node2 node1)).

  replace node2' with (fst (snd (BDDimpl cfg' negm' orm' node2 node1))).  apply BDDimpl_is_impl.

  assumption.  assumption.  assumption.  assumption.  assumption.  rewrite H5; reflexivity.

  rewrite H5; reflexivity.  apply bool_fun_impl_preserves_eq.  replace cfg' with (fst (BDDimpl cfg negm orm node1 node2)).

  apply BDDimpl_preserves_bool_fun.  assumption.  assumption.  assumption.  assumption.

  assumption.  assumption.  rewrite H4; reflexivity.  replace cfg' with (fst (BDDimpl cfg negm orm node1 node2)).

  apply BDDimpl_preserves_bool_fun.  assumption.  assumption.  assumption.  assumption.

  assumption.  assumption.  rewrite H4; reflexivity.  apply bool_fun_eq_symm.

  apply bool_fun_iff_is_and_impl_impl.  

  replace cfg'' with (fst (BDDimpl cfg' negm' orm' node2 node1)).  replace orm'' with (snd (snd (snd (BDDimpl cfg' negm' orm' node2 node1)))).

  apply BDDimpl_keeps_or_memo_OK.  assumption.  assumption.  assumption.  assumption.

  assumption.  rewrite H5; reflexivity.  rewrite H5; reflexivity.  replace cfg'' with (fst (BDDimpl cfg' negm' orm' node2 node1)).

  replace negm'' with (fst (snd (snd (BDDimpl cfg' negm' orm' node2 node1)))).

  apply BDDimpl_keeps_neg_memo_OK.  assumption.  assumption.  assumption.  assumption.

  assumption.  rewrite H5; reflexivity.  rewrite H5; reflexivity.  replace cfg'' with (fst (BDDimpl cfg' negm' orm' node2 node1)).

  apply BDDimpl_keeps_node_OK.  assumption.  assumption.  assumption.  assumption.

  assumption.  assumption.  rewrite H5; reflexivity.  replace cfg'' with (fst (BDDimpl cfg' negm' orm' node2 node1)).

  replace node2' with (fst (snd (BDDimpl cfg' negm' orm' node2 node1))).  apply BDDimpl_node_OK.

  assumption.  assumption.  assumption.  assumption.  assumption.  rewrite H5; reflexivity.

  rewrite H5; reflexivity.  replace cfg'' with (fst (BDDimpl cfg' negm' orm' node2 node1)).

  apply BDDimpl_keeps_config_OK.  assumption.  assumption.  assumption.  assumption.

  assumption.  rewrite H5; reflexivity.  replace cfg' with (fst (BDDimpl cfg negm orm node1 node2)).

  replace orm' with (snd (snd (snd (BDDimpl cfg negm orm node1 node2)))).  apply BDDimpl_keeps_or_memo_OK.

  assumption.  assumption.  assumption.  assumption.  assumption.  rewrite H4; reflexivity.

  rewrite H4; reflexivity.  replace cfg' with (fst (BDDimpl cfg negm orm node1 node2)).

  replace negm' with (fst (snd (snd (BDDimpl cfg negm orm node1 node2)))).

  apply BDDimpl_keeps_neg_memo_OK.  assumption.  assumption.  assumption.  assumption.

  assumption.  rewrite H4; reflexivity.  rewrite H4; reflexivity.  replace cfg' with (fst (BDDimpl cfg negm orm node1 node2)).

  apply BDDimpl_keeps_node_OK.  assumption.  assumption.  assumption.  assumption.

  assumption.  assumption.  rewrite H4; reflexivity.  replace cfg' with (fst (BDDimpl cfg negm orm node1 node2)).

  apply BDDimpl_keeps_node_OK.  assumption.  assumption.  assumption.  assumption.

  assumption.  assumption.  rewrite H4; reflexivity.  replace cfg' with (fst (BDDimpl cfg negm orm node1 node2)).

  replace node1' with (fst (snd (BDDimpl cfg negm orm node1 node2))).  apply BDDimpl_node_OK.

  assumption.  assumption.  assumption.  assumption.  assumption.  rewrite H4; reflexivity.

  rewrite H4; reflexivity.  replace cfg' with (fst (BDDimpl cfg negm orm node1 node2)).

  apply BDDimpl_keeps_config_OK.  assumption.  assumption.  assumption.  assumption.

  assumption.  rewrite H4; reflexivity.

Qed.



Lemma BDDiff_keeps_node_OK :

 forall (cfg : BDDconfig) (negm : BDDneg_memo) (orm : BDDor_memo)

   (node1 node2 : ad),

 BDDconfig_OK cfg ->

 BDDneg_memo_OK_2 cfg negm ->

 BDDor_memo_OK cfg orm ->

 config_node_OK cfg node1 ->

 config_node_OK cfg node2 ->

 forall node : ad,

 config_node_OK cfg node ->

 config_node_OK (fst (BDDiff cfg negm orm node1 node2)) node.

Proof.

  intros.  apply nodes_preserved_2 with (cfg := cfg).  assumption.  apply BDDiff_preserves_nodes.

  assumption.  assumption.  assumption.  assumption.  assumption.

Qed.



Lemma BDDiff_preserves_bool_fun :

 forall (cfg : BDDconfig) (negm : BDDneg_memo) (orm : BDDor_memo)

   (node1 node2 : ad),

 BDDconfig_OK cfg ->

 BDDneg_memo_OK_2 cfg negm ->

 BDDor_memo_OK cfg orm ->

 config_node_OK cfg node1 ->

 config_node_OK cfg node2 ->

 forall node : ad,

 config_node_OK cfg node ->

 bool_fun_eq (bool_fun_of_BDD (fst (BDDiff cfg negm orm node1 node2)) node)

   (bool_fun_of_BDD cfg node).

Proof.

  intros.  apply nodes_preserved_3.  assumption.  apply BDDiff_keeps_config_OK.

  assumption.  assumption.  assumption.  assumption.  assumption.  apply BDDiff_preserves_nodes.

  assumption.  assumption.  assumption.  assumption.  assumption.  assumption.

Qed.



Definition BDDvar_make (cfg : BDDconfig) (x : BDDvar) :=

  BDDmake cfg x BDDzero BDDone.



Lemma BDDvar_make_keeps_config_OK :

 forall (cfg : BDDconfig) (x : BDDvar),

 BDDconfig_OK cfg -> BDDconfig_OK (fst (BDDvar_make cfg x)).

Proof.

  intros.  refine (proj1 (BDDmake_semantics _ _ _ _ _ _ _ _ _)).  assumption.  

  left; reflexivity.  right; left; reflexivity.  intros.  rewrite (config_OK_zero cfg H) in H0.

  discriminate.  intros.  rewrite (config_OK_one cfg H) in H0.  discriminate.

Qed.



Lemma BDDvar_make_node_OK :

 forall (cfg : BDDconfig) (x : BDDvar),

 BDDconfig_OK cfg ->

 config_node_OK (fst (BDDvar_make cfg x)) (snd (BDDvar_make cfg x)).

Proof.

  intros.  refine

   (proj2 (proj2 (proj2 (proj2 (BDDmake_semantics _ _ _ _ _ _ _ _ _))))).

  assumption.  left; reflexivity.  right; left; reflexivity.  intros.  rewrite (config_OK_zero cfg H) in H0.

  discriminate.  intros.  rewrite (config_OK_one cfg H) in H0.  discriminate.

Qed.



Lemma BDDvar_make_preserves_nodes :

 forall (cfg : BDDconfig) (x : BDDvar),

 BDDconfig_OK cfg -> nodes_preserved cfg (fst (BDDvar_make cfg x)).

Proof.

  intros.  unfold BDDvar_make in |- *.  apply BDDmake_preserves_nodes.  assumption.

Qed.



Lemma BDDvar_make_keeps_neg_memo_OK :

 forall (cfg : BDDconfig) (negm : BDDneg_memo) (x : BDDvar),

 BDDconfig_OK cfg ->

 BDDneg_memo_OK_2 cfg negm -> BDDneg_memo_OK_2 (fst (BDDvar_make cfg x)) negm.

Proof.

  intros.  apply nodes_preserved_negm_OK with (cfg := cfg).  assumption.  apply BDDvar_make_keeps_config_OK.

  assumption.  apply BDDvar_make_preserves_nodes.  assumption.  assumption.

Qed.



Lemma BDDvar_make_keeps_or_memo_OK :

 forall (cfg : BDDconfig) (orm : BDDor_memo) (x : BDDvar),

 BDDconfig_OK cfg ->

 BDDor_memo_OK cfg orm -> BDDor_memo_OK (fst (BDDvar_make cfg x)) orm.

Proof.

  intros.  apply nodes_preserved_orm_OK with (cfg := cfg).  assumption.  apply BDDvar_make_keeps_config_OK.

  assumption.  apply BDDvar_make_preserves_nodes.  assumption.  assumption.

Qed.



Lemma BDDvar_make_keeps_node_OK :

 forall (cfg : BDDconfig) (x : BDDvar),

 BDDconfig_OK cfg ->

 forall node : ad,

 config_node_OK cfg node -> config_node_OK (fst (BDDvar_make cfg x)) node.

Proof.

  intros.  apply nodes_preserved_2 with (cfg := cfg).  assumption.  apply BDDvar_make_preserves_nodes.  assumption.

Qed.



Lemma BDDvar_make_preserves_bool_fun :

 forall (cfg : BDDconfig) (x : BDDvar),

 BDDconfig_OK cfg ->

 forall node : ad,

 config_node_OK cfg node ->

 bool_fun_eq (bool_fun_of_BDD (fst (BDDvar_make cfg x)) node)

   (bool_fun_of_BDD cfg node).

Proof.

  intros.  apply nodes_preserved_3.  assumption.  apply BDDvar_make_keeps_config_OK.

  assumption.  apply BDDvar_make_preserves_nodes.  assumption.  assumption.

Qed.



Definition bool_fun_var (x : BDDvar) : bool_fun :=

  fun vb : var_binding => vb x.



Lemma BDDvar_make_is_var :

 forall (cfg : BDDconfig) (x : BDDvar),

 BDDconfig_OK cfg ->

 bool_fun_eq

   (bool_fun_of_BDD (fst (BDDvar_make cfg x)) (snd (BDDvar_make cfg x)))

   (bool_fun_var x).

Proof.

  intros.  apply

   bool_fun_eq_trans with (bf2 := bool_fun_if x bool_fun_one bool_fun_zero).

  unfold BDDvar_make in |- *.  apply

   bool_fun_eq_trans

    with

      (bool_fun_if x (bool_fun_of_BDD cfg BDDone)

         (bool_fun_of_BDD cfg BDDzero)).

  apply BDDmake_bool_fun.  assumption.  left; reflexivity.  right; left; reflexivity.  

  intro.  inversion H0.  inversion H1.  inversion H2.  rewrite (config_OK_zero cfg H) in H3; discriminate.

  intro.  inversion H0.  inversion H1.  inversion H2.  rewrite (config_OK_one cfg H) in H3; discriminate.

  apply bool_fun_if_preserves_eq.  apply bool_fun_of_BDDone.  assumption.  

  apply bool_fun_of_BDDzero.  assumption.  unfold bool_fun_eq, bool_fun_one, bool_fun_zero, bool_fun_var, bool_fun_if

   in |- *.

  unfold bool_fun_eval in |- *.  intro.  elim (vb x).  reflexivity.  reflexivity.  

Qed.



Inductive bool_expr : Set :=

  | Zero : bool_expr

  | One : bool_expr

  | Var : BDDvar -> bool_expr

  | Neg : bool_expr -> bool_expr

  | Or : bool_expr -> bool_expr -> bool_expr

  | ANd : bool_expr -> bool_expr -> bool_expr

  | Impl : bool_expr -> bool_expr -> bool_expr

  | Iff : bool_expr -> bool_expr -> bool_expr.



Fixpoint bool_fun_of_bool_expr (be : bool_expr) : bool_fun :=

  match be with

  | Zero => bool_fun_zero

  | One => bool_fun_one

  | Var x => bool_fun_var x

  | Neg be' => bool_fun_neg (bool_fun_of_bool_expr be')

  | Or be1 be2 =>

      bool_fun_or (bool_fun_of_bool_expr be1) (bool_fun_of_bool_expr be2)

  | ANd be1 be2 =>

      bool_fun_and (bool_fun_of_bool_expr be1) (bool_fun_of_bool_expr be2)

  | Impl be1 be2 =>

      bool_fun_impl (bool_fun_of_bool_expr be1) (bool_fun_of_bool_expr be2)

  | Iff be1 be2 =>

      bool_fun_iff (bool_fun_of_bool_expr be1) (bool_fun_of_bool_expr be2)

  end.



Fixpoint BDDof_bool_expr (cfg : BDDconfig) (negm : BDDneg_memo)

 (orm : BDDor_memo) (be : bool_expr) {struct be} :

 BDDconfig * (ad * (BDDneg_memo * BDDor_memo)) :=

  match be with

  | Zero => (cfg, (BDDzero, (negm, orm)))

  | One => (cfg, (BDDone, (negm, orm)))

  | Var x =>

      match BDDvar_make cfg x with

      | (cfg', node) => (cfg', (node, (negm, orm)))

      end

  | Neg be' =>

      match BDDof_bool_expr cfg negm orm be' with

      | (cfg', (node, (negm', orm'))) =>

          match BDDneg cfg' negm' node with

          | (cfg'', (node', negm'')) => (cfg'', (node', (negm'', orm')))

          end

      end

  | Or be1 be2 =>

      match BDDof_bool_expr cfg negm orm be1 with

      | (cfg', (node1, (negm', orm'))) =>

          match BDDof_bool_expr cfg' negm' orm' be2 with

          | (cfg'', (node2, (negm'', orm''))) =>

              match BDDor cfg'' orm'' node1 node2 with

              | (cfg''', (node, orm''')) =>

                  (cfg''', (node, (negm'', orm''')))

              end

          end

      end

  | ANd be1 be2 =>

      match BDDof_bool_expr cfg negm orm be1 with

      | (cfg', (node1, (negm', orm'))) =>

          match BDDof_bool_expr cfg' negm' orm' be2 with

          | (cfg'', (node2, (negm'', orm''))) =>

              BDDand cfg'' negm'' orm'' node1 node2

          end

      end

  | Impl be1 be2 =>

      match BDDof_bool_expr cfg negm orm be1 with

      | (cfg', (node1, (negm', orm'))) =>

          match BDDof_bool_expr cfg' negm' orm' be2 with

          | (cfg'', (node2, (negm'', orm''))) =>

              BDDimpl cfg'' negm'' orm'' node1 node2

          end

      end

  | Iff be1 be2 =>

      match BDDof_bool_expr cfg negm orm be1 with

      | (cfg', (node1, (negm', orm'))) =>

          match BDDof_bool_expr cfg' negm' orm' be2 with

          | (cfg'', (node2, (negm'', orm''))) =>

              BDDiff cfg'' negm'' orm'' node1 node2

          end

      end

  end.



Lemma BDDof_bool_expr_correct :

 forall (be : bool_expr) (cfg : BDDconfig) (negm : BDDneg_memo)

   (orm : BDDor_memo),

 BDDconfig_OK cfg ->

 BDDneg_memo_OK_2 cfg negm ->

 BDDor_memo_OK cfg orm ->

 BDDconfig_OK (fst (BDDof_bool_expr cfg negm orm be)) /\

 config_node_OK (fst (BDDof_bool_expr cfg negm orm be))

   (fst (snd (BDDof_bool_expr cfg negm orm be))) /\

 BDDneg_memo_OK_2 (fst (BDDof_bool_expr cfg negm orm be))

   (fst (snd (snd (BDDof_bool_expr cfg negm orm be)))) /\

 BDDor_memo_OK (fst (BDDof_bool_expr cfg negm orm be))

   (snd (snd (snd (BDDof_bool_expr cfg negm orm be)))) /\

 nodes_preserved cfg (fst (BDDof_bool_expr cfg negm orm be)) /\

 bool_fun_eq

   (bool_fun_of_BDD (fst (BDDof_bool_expr cfg negm orm be))

      (fst (snd (BDDof_bool_expr cfg negm orm be))))

   (bool_fun_of_bool_expr be).

Proof.

  simple induction be.  intros.  simpl in |- *.  split.  assumption.  split.  left; reflexivity.

  split.  assumption.  split.  assumption.  split.  unfold nodes_preserved in |- *.  intros.

  assumption.  apply bool_fun_of_BDDzero.  assumption.  simpl in |- *.  split.  assumption.

  split.  right; left; reflexivity.  split.  assumption.  split.  assumption.

  split.  unfold nodes_preserved in |- *.  intros; assumption.  apply bool_fun_of_BDDone.

  assumption.  simpl in |- *.  intros.  elim (prod_sum _ _ (BDDvar_make cfg b)).  intros cfg' H2.

  elim H2; clear H2.  intros node H2.  rewrite H2.  simpl in |- *.  split.  replace cfg' with (fst (BDDvar_make cfg b)).

  apply BDDvar_make_keeps_config_OK.  assumption.  rewrite H2; reflexivity.  

  split.  replace cfg' with (fst (BDDvar_make cfg b)).  replace node with (snd (BDDvar_make cfg b)).

  apply BDDvar_make_node_OK.  assumption.  rewrite H2; reflexivity.  rewrite H2; reflexivity.

  split.  replace cfg' with (fst (BDDvar_make cfg b)).  apply BDDvar_make_keeps_neg_memo_OK.

  assumption.  assumption.  rewrite H2; reflexivity.  split.  replace cfg' with (fst (BDDvar_make cfg b)).

  apply BDDvar_make_keeps_or_memo_OK.  assumption.  assumption.  rewrite H2; reflexivity.

  split.  replace cfg' with (fst (BDDvar_make cfg b)).  apply BDDvar_make_preserves_nodes.

  assumption.  rewrite H2; reflexivity.  replace cfg' with (fst (BDDvar_make cfg b)).

  replace node with (snd (BDDvar_make cfg b)).  apply BDDvar_make_is_var.  assumption.

  rewrite H2; reflexivity.  rewrite H2; reflexivity.  intros.  simpl in |- *.

  elim (prod_sum _ _ (BDDof_bool_expr cfg negm orm b)).  intros cfg' H3.  elim H3; clear H3.

  intro.  elim x; clear x.  intros node y.  elim y; clear y.  intros negm' orm' H3.

  rewrite H3.  elim (prod_sum _ _ (BDDneg cfg' negm' node)).  intros cfg'' H4.

  elim H4; clear H4.  intro.  elim x; clear x.  intros node' negm''.  intro H4.

  rewrite H4.  simpl in |- *.  cut (BDDconfig_OK cfg').  cut (config_node_OK cfg' node).

  cut (BDDneg_memo_OK_2 cfg' negm').  cut (BDDor_memo_OK cfg' orm').  cut (nodes_preserved cfg cfg').

  cut (bool_fun_eq (bool_fun_of_BDD cfg' node) (bool_fun_of_bool_expr b)).

  intros.  split.  replace cfg'' with (fst (BDDneg cfg' negm' node)).  apply BDDneg_keeps_config_OK.

  assumption.  assumption.  assumption.  rewrite H4; reflexivity.  split.

  replace cfg'' with (fst (BDDneg cfg' negm' node)).  replace node' with (fst (snd (BDDneg cfg' negm' node))).

  apply BDDneg_node_OK.  assumption.  assumption.  assumption.  rewrite H4; reflexivity.

  rewrite H4; reflexivity.  split.  replace cfg'' with (fst (BDDneg cfg' negm' node)).

  replace negm'' with (snd (snd (BDDneg cfg' negm' node))).  apply BDDneg_keeps_neg_memo_OK.

  assumption.  assumption.  assumption.  rewrite H4; reflexivity.  rewrite H4; reflexivity.

  split.  replace cfg'' with (fst (BDDneg cfg' negm' node)).  apply BDDneg_keeps_or_memo_OK.

  assumption.  assumption.  assumption.  assumption.  rewrite H4; reflexivity.

  split.  apply nodes_preserved_trans with (cfg2 := cfg').  assumption.  replace cfg'' with (fst (BDDneg cfg' negm' node)).

  apply BDDneg_preserves_nodes.  assumption.  assumption.  assumption.  rewrite H4; reflexivity.



apply

 bool_fun_eq_trans with (bf2 := bool_fun_neg (bool_fun_of_BDD cfg' node)).

replace cfg'' with (fst (BDDneg cfg' negm' node)).

replace node' with (fst (snd (BDDneg cfg' negm' node))).

apply BDDneg_is_neg.

assumption.



assumption.



assumption.



rewrite H4; reflexivity.



rewrite H4; reflexivity.



apply bool_fun_eq_neg_1.

assumption.



replace cfg' with (fst (BDDof_bool_expr cfg negm orm b)).

replace node with (fst (snd (BDDof_bool_expr cfg negm orm b))).

refine (proj2 (proj2 (proj2 (proj2 (proj2 (H _ _ _ _ _ _)))))).

assumption.



assumption.



assumption.



rewrite H3; reflexivity.



rewrite H3; reflexivity.



replace cfg' with (fst (BDDof_bool_expr cfg negm orm b)).

refine (proj1 (proj2 (proj2 (proj2 (proj2 (H _ _ _ _ _ _)))))).

assumption.



assumption.



assumption.



rewrite H3; reflexivity.



replace cfg' with (fst (BDDof_bool_expr cfg negm orm b)).

replace orm' with (snd (snd (snd (BDDof_bool_expr cfg negm orm b)))).

refine (proj1 (proj2 (proj2 (proj2 (H _ _ _ _ _ _))))).

assumption.



assumption.



assumption.



rewrite H3; reflexivity.



rewrite H3; reflexivity.



replace cfg' with (fst (BDDof_bool_expr cfg negm orm b)).

replace negm' with (fst (snd (snd (BDDof_bool_expr cfg negm orm b)))).

refine (proj1 (proj2 (proj2 (H _ _ _ _ _ _)))).

assumption.



assumption.



assumption.



rewrite H3; reflexivity.



rewrite H3; reflexivity.



replace cfg' with (fst (BDDof_bool_expr cfg negm orm b)).

replace node with (fst (snd (BDDof_bool_expr cfg negm orm b))).

refine (proj1 (proj2 (H _ _ _ _ _ _))).

assumption.



assumption.



assumption.



rewrite H3; reflexivity.



rewrite H3; reflexivity.



replace cfg' with (fst (BDDof_bool_expr cfg negm orm b)).

refine (proj1 (H _ _ _ _ _ _)).

assumption.



assumption.



assumption.



rewrite H3; reflexivity.



clear be.

intros be1 H.

intros be2 H0.

intros.

simpl in |- *.

elim (prod_sum _ _ (BDDof_bool_expr cfg negm orm be1)).

intros cfg' H4.

elim H4; clear H4.

intro.

elim x; clear x.

intros node1 y.

elim y; clear y; intros negm' orm' H4.

rewrite H4.

elim (prod_sum _ _ (BDDof_bool_expr cfg' negm' orm' be2)).

intros cfg'' H5; elim H5; clear H5; intro; elim x; clear x; intros node2 y;

 elim y; clear y; intros negm'' orm'' H5; rewrite H5.

elim (prod_sum _ _ (BDDor cfg'' orm'' node1 node2)).

intros cfg''' H6.

elim H6; clear H6.

intro.

elim x; clear x.

intros node orm''' H6.

rewrite H6.

simpl in |- *.

cut (BDDconfig_OK cfg').

cut (config_node_OK cfg' node1).

cut (BDDneg_memo_OK_2 cfg' negm').

cut (BDDor_memo_OK cfg' orm').

cut (nodes_preserved cfg cfg').

cut (bool_fun_eq (bool_fun_of_BDD cfg' node1) (bool_fun_of_bool_expr be1)).

intros.

cut (BDDconfig_OK cfg'').

cut (config_node_OK cfg'' node2).

cut (BDDneg_memo_OK_2 cfg'' negm'').

cut (BDDor_memo_OK cfg'' orm'').

cut (nodes_preserved cfg' cfg'').

cut (bool_fun_eq (bool_fun_of_BDD cfg'' node2) (bool_fun_of_bool_expr be2)).

intros.

cut (config_node_OK cfg'' node1).

intros.

split.

replace cfg''' with (fst (BDDor cfg'' orm'' node1 node2)).

apply BDDor_keeps_config_OK.

assumption.



assumption.



assumption.



assumption.



rewrite H6; reflexivity.



split.

replace cfg''' with (fst (BDDor cfg'' orm'' node1 node2)).

replace node with (fst (snd (BDDor cfg'' orm'' node1 node2))).

apply BDDor_node_OK.

assumption.



assumption.



assumption.



assumption.



rewrite H6; reflexivity.



rewrite H6; reflexivity.



split.

replace cfg''' with (fst (BDDor cfg'' orm'' node1 node2)).

apply BDDor_keeps_neg_memo_OK.

assumption.



assumption.



assumption.



assumption.



assumption.



rewrite H6; reflexivity.



split.

replace cfg''' with (fst (BDDor cfg'' orm'' node1 node2)).

replace orm''' with (snd (snd (BDDor cfg'' orm'' node1 node2))).

apply BDDor_keeps_or_memo_OK.

assumption.



assumption.



assumption.



assumption.



rewrite H6; reflexivity.



rewrite H6; reflexivity.



split.

apply nodes_preserved_trans with (cfg2 := cfg').

assumption.



apply nodes_preserved_trans with (cfg2 := cfg'').

assumption.



replace cfg''' with (fst (BDDor cfg'' orm'' node1 node2)).

apply BDDor_preserves_nodes.

assumption.



assumption.



assumption.



assumption.



rewrite H6; reflexivity.



apply

 bool_fun_eq_trans

  with

    (bf2 := bool_fun_or (bool_fun_of_BDD cfg'' node1)

              (bool_fun_of_BDD cfg'' node2)).

replace cfg''' with (fst (BDDor cfg'' orm'' node1 node2)).

replace node with (fst (snd (BDDor cfg'' orm'' node1 node2))).

apply BDDor_is_or.

assumption.



assumption.



assumption.



assumption.



rewrite H6; reflexivity.



rewrite H6; reflexivity.



apply bool_fun_or_preserves_eq.

apply bool_fun_eq_trans with (bf2 := bool_fun_of_BDD cfg' node1).

apply nodes_preserved_3.

assumption.



assumption.



assumption.



assumption.



assumption.



assumption.



apply nodes_preserved_2 with (cfg := cfg').

assumption.



assumption.



replace cfg'' with (fst (BDDof_bool_expr cfg' negm' orm' be2)).

replace node2 with (fst (snd (BDDof_bool_expr cfg' negm' orm' be2))).

refine (proj2 (proj2 (proj2 (proj2 (proj2 (H0 _ _ _ _ _ _)))))).

assumption.



assumption.



assumption.



rewrite H5; reflexivity.



rewrite H5; reflexivity.



replace cfg'' with (fst (BDDof_bool_expr cfg' negm' orm' be2)).

refine (proj1 (proj2 (proj2 (proj2 (proj2 (H0 _ _ _ _ _ _)))))).

assumption.



assumption.



assumption.



rewrite H5; reflexivity.



replace cfg'' with (fst (BDDof_bool_expr cfg' negm' orm' be2)).

replace orm'' with (snd (snd (snd (BDDof_bool_expr cfg' negm' orm' be2)))).

refine (proj1 (proj2 (proj2 (proj2 (H0 _ _ _ _ _ _))))).

assumption.



assumption.



assumption.



rewrite H5; reflexivity.



rewrite H5; reflexivity.



replace cfg'' with (fst (BDDof_bool_expr cfg' negm' orm' be2)).

replace negm'' with (fst (snd (snd (BDDof_bool_expr cfg' negm' orm' be2)))).

refine (proj1 (proj2 (proj2 (H0 _ _ _ _ _ _)))).

assumption.



assumption.



assumption.



rewrite H5; reflexivity.



rewrite H5; reflexivity.



replace cfg'' with (fst (BDDof_bool_expr cfg' negm' orm' be2)).

replace node2 with (fst (snd (BDDof_bool_expr cfg' negm' orm' be2))).

refine (proj1 (proj2 (H0 _ _ _ _ _ _))).

assumption.



assumption.



assumption.



rewrite H5; reflexivity.



rewrite H5; reflexivity.



replace cfg'' with (fst (BDDof_bool_expr cfg' negm' orm' be2)).

refine (proj1 (H0 _ _ _ _ _ _)).

assumption.



assumption.



assumption.



rewrite H5; reflexivity.



replace cfg' with (fst (BDDof_bool_expr cfg negm orm be1)).

replace node1 with (fst (snd (BDDof_bool_expr cfg negm orm be1))).

refine (proj2 (proj2 (proj2 (proj2 (proj2 (H _ _ _ _ _ _)))))).

assumption.



assumption.



assumption.



rewrite H4; reflexivity.



rewrite H4; reflexivity.



replace cfg' with (fst (BDDof_bool_expr cfg negm orm be1)).

refine (proj1 (proj2 (proj2 (proj2 (proj2 (H _ _ _ _ _ _)))))).

assumption.



assumption.



assumption.



rewrite H4; reflexivity.



replace cfg' with (fst (BDDof_bool_expr cfg negm orm be1)).

replace orm' with (snd (snd (snd (BDDof_bool_expr cfg negm orm be1)))).

refine (proj1 (proj2 (proj2 (proj2 (H _ _ _ _ _ _))))).

assumption.



assumption.



assumption.



rewrite H4; reflexivity.



rewrite H4; reflexivity.



replace cfg' with (fst (BDDof_bool_expr cfg negm orm be1)).

replace negm' with (fst (snd (snd (BDDof_bool_expr cfg negm orm be1)))).

refine (proj1 (proj2 (proj2 (H _ _ _ _ _ _)))).

assumption.



assumption.



assumption.



rewrite H4; reflexivity.



rewrite H4; reflexivity.



replace cfg' with (fst (BDDof_bool_expr cfg negm orm be1)).

replace node1 with (fst (snd (BDDof_bool_expr cfg negm orm be1))).

refine (proj1 (proj2 (H _ _ _ _ _ _))).

assumption.



assumption.



assumption.



rewrite H4; reflexivity.



rewrite H4; reflexivity.



replace cfg' with (fst (BDDof_bool_expr cfg negm orm be1)).

refine (proj1 (H _ _ _ _ _ _)).

assumption.



assumption.



assumption.



rewrite H4; reflexivity.



clear be.

intros be1 H.

intros be2 H0.

intros.

simpl in |- *.

elim (prod_sum _ _ (BDDof_bool_expr cfg negm orm be1)).

intros cfg' H4.

elim H4; clear H4.

intro.

elim x; clear x.

intros node1 y.

elim y; clear y; intros negm' orm' H4.

rewrite H4.

elim (prod_sum _ _ (BDDof_bool_expr cfg' negm' orm' be2)).

intros cfg'' H5; elim H5; clear H5; intro; elim x; clear x; intros node2 y;

 elim y; clear y; intros negm'' orm'' H5; rewrite H5.

cut (BDDconfig_OK cfg').

cut (config_node_OK cfg' node1).

cut (BDDneg_memo_OK_2 cfg' negm').

cut (BDDor_memo_OK cfg' orm').

cut (nodes_preserved cfg cfg').

cut (bool_fun_eq (bool_fun_of_BDD cfg' node1) (bool_fun_of_bool_expr be1)).

intros.

cut (BDDconfig_OK cfg'').

cut (config_node_OK cfg'' node2).

cut (BDDneg_memo_OK_2 cfg'' negm'').

cut (BDDor_memo_OK cfg'' orm'').

cut (nodes_preserved cfg' cfg'').

cut (bool_fun_eq (bool_fun_of_BDD cfg'' node2) (bool_fun_of_bool_expr be2)).

intros.

cut (config_node_OK cfg'' node1).

intros.

split.

apply BDDand_keeps_config_OK.

assumption.



assumption.



assumption.



assumption.



assumption.



split.

apply BDDand_node_OK.

assumption.



assumption.



assumption.



assumption.



assumption.



split.

apply BDDand_keeps_neg_memo_OK.

assumption.



assumption.



assumption.



assumption.



assumption.



split.

apply BDDand_keeps_or_memo_OK.

assumption.



assumption.



assumption.



assumption.



assumption.



split.

apply nodes_preserved_trans with (cfg2 := cfg').

assumption.



apply nodes_preserved_trans with (cfg2 := cfg'').

assumption.



apply BDDand_preserves_nodes.

assumption.



assumption.



assumption.



assumption.



assumption.



apply

 bool_fun_eq_trans

  with

    (bf2 := bool_fun_and (bool_fun_of_BDD cfg'' node1)

              (bool_fun_of_BDD cfg'' node2)).

apply BDDand_is_and.

assumption.



assumption.



assumption.



assumption.



assumption.



apply bool_fun_and_preserves_eq.

apply bool_fun_eq_trans with (bf2 := bool_fun_of_BDD cfg' node1).

apply nodes_preserved_3.

assumption.



assumption.



assumption.



assumption.



assumption.



assumption.



apply nodes_preserved_2 with (cfg := cfg').

assumption.



assumption.



replace cfg'' with (fst (BDDof_bool_expr cfg' negm' orm' be2)).

replace node2 with (fst (snd (BDDof_bool_expr cfg' negm' orm' be2))).

refine (proj2 (proj2 (proj2 (proj2 (proj2 (H0 _ _ _ _ _ _)))))).

assumption.



assumption.



assumption.



rewrite H5; reflexivity.



rewrite H5; reflexivity.



replace cfg'' with (fst (BDDof_bool_expr cfg' negm' orm' be2)).

refine (proj1 (proj2 (proj2 (proj2 (proj2 (H0 _ _ _ _ _ _)))))).

assumption.



assumption.



assumption.



rewrite H5; reflexivity.



replace cfg'' with (fst (BDDof_bool_expr cfg' negm' orm' be2)).

replace orm'' with (snd (snd (snd (BDDof_bool_expr cfg' negm' orm' be2)))).

refine (proj1 (proj2 (proj2 (proj2 (H0 _ _ _ _ _ _))))).

assumption.



assumption.



assumption.



rewrite H5; reflexivity.



rewrite H5; reflexivity.



replace cfg'' with (fst (BDDof_bool_expr cfg' negm' orm' be2)).

replace negm'' with (fst (snd (snd (BDDof_bool_expr cfg' negm' orm' be2)))).

refine (proj1 (proj2 (proj2 (H0 _ _ _ _ _ _)))).

assumption.



assumption.



assumption.



rewrite H5; reflexivity.



rewrite H5; reflexivity.



replace cfg'' with (fst (BDDof_bool_expr cfg' negm' orm' be2)).

replace node2 with (fst (snd (BDDof_bool_expr cfg' negm' orm' be2))).

refine (proj1 (proj2 (H0 _ _ _ _ _ _))).

assumption.



assumption.



assumption.



rewrite H5; reflexivity.



rewrite H5; reflexivity.



replace cfg'' with (fst (BDDof_bool_expr cfg' negm' orm' be2)).

refine (proj1 (H0 _ _ _ _ _ _)).

assumption.



assumption.



assumption.



rewrite H5; reflexivity.



replace cfg' with (fst (BDDof_bool_expr cfg negm orm be1)).

replace node1 with (fst (snd (BDDof_bool_expr cfg negm orm be1))).

refine (proj2 (proj2 (proj2 (proj2 (proj2 (H _ _ _ _ _ _)))))).

assumption.



assumption.



assumption.



rewrite H4; reflexivity.



rewrite H4; reflexivity.



replace cfg' with (fst (BDDof_bool_expr cfg negm orm be1)).

refine (proj1 (proj2 (proj2 (proj2 (proj2 (H _ _ _ _ _ _)))))).

assumption.



assumption.



assumption.



rewrite H4; reflexivity.



replace cfg' with (fst (BDDof_bool_expr cfg negm orm be1)).

replace orm' with (snd (snd (snd (BDDof_bool_expr cfg negm orm be1)))).

refine (proj1 (proj2 (proj2 (proj2 (H _ _ _ _ _ _))))).

assumption.



assumption.



assumption.



rewrite H4; reflexivity.



rewrite H4; reflexivity.



replace cfg' with (fst (BDDof_bool_expr cfg negm orm be1)).

replace negm' with (fst (snd (snd (BDDof_bool_expr cfg negm orm be1)))).

refine (proj1 (proj2 (proj2 (H _ _ _ _ _ _)))).

assumption.



assumption.



assumption.



rewrite H4; reflexivity.



rewrite H4; reflexivity.



replace cfg' with (fst (BDDof_bool_expr cfg negm orm be1)).

replace node1 with (fst (snd (BDDof_bool_expr cfg negm orm be1))).

refine (proj1 (proj2 (H _ _ _ _ _ _))).

assumption.



assumption.



assumption.



rewrite H4; reflexivity.



rewrite H4; reflexivity.



replace cfg' with (fst (BDDof_bool_expr cfg negm orm be1)).

refine (proj1 (H _ _ _ _ _ _)).

assumption.



assumption.



assumption.



rewrite H4; reflexivity.



clear be.

intros be1 H.

intros be2 H0.

intros.

simpl in |- *.

elim (prod_sum _ _ (BDDof_bool_expr cfg negm orm be1)).

intros cfg' H4.

elim H4; clear H4.

intro.

elim x; clear x.

intros node1 y.

elim y; clear y; intros negm' orm' H4.

rewrite H4.

elim (prod_sum _ _ (BDDof_bool_expr cfg' negm' orm' be2)).

intros cfg'' H5; elim H5; clear H5; intro; elim x; clear x; intros node2 y;

 elim y; clear y; intros negm'' orm'' H5; rewrite H5.

cut (BDDconfig_OK cfg').

cut (config_node_OK cfg' node1).

cut (BDDneg_memo_OK_2 cfg' negm').

cut (BDDor_memo_OK cfg' orm').

cut (nodes_preserved cfg cfg').

cut (bool_fun_eq (bool_fun_of_BDD cfg' node1) (bool_fun_of_bool_expr be1)).

intros.

cut (BDDconfig_OK cfg'').

cut (config_node_OK cfg'' node2).

cut (BDDneg_memo_OK_2 cfg'' negm'').

cut (BDDor_memo_OK cfg'' orm'').

cut (nodes_preserved cfg' cfg'').

cut (bool_fun_eq (bool_fun_of_BDD cfg'' node2) (bool_fun_of_bool_expr be2)).

intros.

cut (config_node_OK cfg'' node1).

intros.

split.

apply BDDimpl_keeps_config_OK.

assumption.



assumption.



assumption.



assumption.



assumption.



split.

apply BDDimpl_node_OK.

assumption.



assumption.



assumption.



assumption.



assumption.



split.

apply BDDimpl_keeps_neg_memo_OK.

assumption.



assumption.



assumption.



assumption.



assumption.



split.

apply BDDimpl_keeps_or_memo_OK.

assumption.



assumption.



assumption.



assumption.



assumption.



split.

apply nodes_preserved_trans with (cfg2 := cfg').

assumption.



apply nodes_preserved_trans with (cfg2 := cfg'').

assumption.



apply BDDimpl_preserves_nodes.

assumption.



assumption.



assumption.



assumption.



assumption.



apply

 bool_fun_eq_trans

  with

    (bf2 := bool_fun_impl (bool_fun_of_BDD cfg'' node1)

              (bool_fun_of_BDD cfg'' node2)).

apply BDDimpl_is_impl.

assumption.



assumption.



assumption.



assumption.



assumption.



apply bool_fun_impl_preserves_eq.

apply bool_fun_eq_trans with (bf2 := bool_fun_of_BDD cfg' node1).

apply nodes_preserved_3.

assumption.



assumption.



assumption.



assumption.



assumption.



assumption.



apply nodes_preserved_2 with (cfg := cfg').

assumption.



assumption.



replace cfg'' with (fst (BDDof_bool_expr cfg' negm' orm' be2)).

replace node2 with (fst (snd (BDDof_bool_expr cfg' negm' orm' be2))).

refine (proj2 (proj2 (proj2 (proj2 (proj2 (H0 _ _ _ _ _ _)))))).

assumption.



assumption.



assumption.



rewrite H5; reflexivity.



rewrite H5; reflexivity.



replace cfg'' with (fst (BDDof_bool_expr cfg' negm' orm' be2)).

refine (proj1 (proj2 (proj2 (proj2 (proj2 (H0 _ _ _ _ _ _)))))).

assumption.



assumption.



assumption.



rewrite H5; reflexivity.



replace cfg'' with (fst (BDDof_bool_expr cfg' negm' orm' be2)).

replace orm'' with (snd (snd (snd (BDDof_bool_expr cfg' negm' orm' be2)))).

refine (proj1 (proj2 (proj2 (proj2 (H0 _ _ _ _ _ _))))).

assumption.



assumption.



assumption.



rewrite H5; reflexivity.



rewrite H5; reflexivity.



replace cfg'' with (fst (BDDof_bool_expr cfg' negm' orm' be2)).

replace negm'' with (fst (snd (snd (BDDof_bool_expr cfg' negm' orm' be2)))).

refine (proj1 (proj2 (proj2 (H0 _ _ _ _ _ _)))).

assumption.



assumption.



assumption.



rewrite H5; reflexivity.



rewrite H5; reflexivity.



replace cfg'' with (fst (BDDof_bool_expr cfg' negm' orm' be2)).

replace node2 with (fst (snd (BDDof_bool_expr cfg' negm' orm' be2))).

refine (proj1 (proj2 (H0 _ _ _ _ _ _))).

assumption.



assumption.



assumption.



rewrite H5; reflexivity.



rewrite H5; reflexivity.



replace cfg'' with (fst (BDDof_bool_expr cfg' negm' orm' be2)).

refine (proj1 (H0 _ _ _ _ _ _)).

assumption.



assumption.



assumption.



rewrite H5; reflexivity.



replace cfg' with (fst (BDDof_bool_expr cfg negm orm be1)).

replace node1 with (fst (snd (BDDof_bool_expr cfg negm orm be1))).

refine (proj2 (proj2 (proj2 (proj2 (proj2 (H _ _ _ _ _ _)))))).

assumption.



assumption.



assumption.



rewrite H4; reflexivity.



rewrite H4; reflexivity.



replace cfg' with (fst (BDDof_bool_expr cfg negm orm be1)).

refine (proj1 (proj2 (proj2 (proj2 (proj2 (H _ _ _ _ _ _)))))).

assumption.



assumption.



assumption.



rewrite H4; reflexivity.



replace cfg' with (fst (BDDof_bool_expr cfg negm orm be1)).

replace orm' with (snd (snd (snd (BDDof_bool_expr cfg negm orm be1)))).

refine (proj1 (proj2 (proj2 (proj2 (H _ _ _ _ _ _))))).

assumption.



assumption.



assumption.



rewrite H4; reflexivity.



rewrite H4; reflexivity.



replace cfg' with (fst (BDDof_bool_expr cfg negm orm be1)).

replace negm' with (fst (snd (snd (BDDof_bool_expr cfg negm orm be1)))).

refine (proj1 (proj2 (proj2 (H _ _ _ _ _ _)))).

assumption.



assumption.



assumption.



rewrite H4; reflexivity.



rewrite H4; reflexivity.



replace cfg' with (fst (BDDof_bool_expr cfg negm orm be1)).

replace node1 with (fst (snd (BDDof_bool_expr cfg negm orm be1))).

refine (proj1 (proj2 (H _ _ _ _ _ _))).

assumption.



assumption.



assumption.



rewrite H4; reflexivity.



rewrite H4; reflexivity.



replace cfg' with (fst (BDDof_bool_expr cfg negm orm be1)).

refine (proj1 (H _ _ _ _ _ _)).

assumption.



assumption.



assumption.



rewrite H4; reflexivity.



clear be.

intros be1 H.

intros be2 H0.

intros.

simpl in |- *.

elim (prod_sum _ _ (BDDof_bool_expr cfg negm orm be1)).

intros cfg' H4.

elim H4; clear H4.

intro.

elim x; clear x.

intros node1 y.

elim y; clear y; intros negm' orm' H4.

rewrite H4.

elim (prod_sum _ _ (BDDof_bool_expr cfg' negm' orm' be2)).

intros cfg'' H5; elim H5; clear H5; intro; elim x; clear x; intros node2 y;

 elim y; clear y; intros negm'' orm'' H5; rewrite H5.

cut (BDDconfig_OK cfg').

cut (config_node_OK cfg' node1).

cut (BDDneg_memo_OK_2 cfg' negm').

cut (BDDor_memo_OK cfg' orm').

cut (nodes_preserved cfg cfg').

cut (bool_fun_eq (bool_fun_of_BDD cfg' node1) (bool_fun_of_bool_expr be1)).

intros.

cut (BDDconfig_OK cfg'').

cut (config_node_OK cfg'' node2).

cut (BDDneg_memo_OK_2 cfg'' negm'').

cut (BDDor_memo_OK cfg'' orm'').

cut (nodes_preserved cfg' cfg'').

cut (bool_fun_eq (bool_fun_of_BDD cfg'' node2) (bool_fun_of_bool_expr be2)).

intros.

cut (config_node_OK cfg'' node1).

intros.

split.

apply BDDiff_keeps_config_OK.

assumption.



assumption.



assumption.



assumption.



assumption.



split.

apply BDDiff_node_OK.

assumption.



assumption.



assumption.



assumption.



assumption.



split.

apply BDDiff_keeps_neg_memo_OK.

assumption.



assumption.



assumption.



assumption.



assumption.



split.

apply BDDiff_keeps_or_memo_OK.

assumption.



assumption.



assumption.



assumption.



assumption.



split.

apply nodes_preserved_trans with (cfg2 := cfg').

assumption.



apply nodes_preserved_trans with (cfg2 := cfg'').

assumption.



apply BDDiff_preserves_nodes.

assumption.



assumption.



assumption.



assumption.



assumption.



apply

 bool_fun_eq_trans

  with

    (bf2 := bool_fun_iff (bool_fun_of_BDD cfg'' node1)

              (bool_fun_of_BDD cfg'' node2)).

apply BDDiff_is_iff.

assumption.



assumption.



assumption.



assumption.



assumption.



apply bool_fun_iff_preserves_eq.

apply bool_fun_eq_trans with (bf2 := bool_fun_of_BDD cfg' node1).

apply nodes_preserved_3.

assumption.



assumption.



assumption.



assumption.



assumption.



assumption.



apply nodes_preserved_2 with (cfg := cfg').

assumption.



assumption.



replace cfg'' with (fst (BDDof_bool_expr cfg' negm' orm' be2)).

replace node2 with (fst (snd (BDDof_bool_expr cfg' negm' orm' be2))).

refine (proj2 (proj2 (proj2 (proj2 (proj2 (H0 _ _ _ _ _ _)))))).

assumption.



assumption.



assumption.



rewrite H5; reflexivity.



rewrite H5; reflexivity.



replace cfg'' with (fst (BDDof_bool_expr cfg' negm' orm' be2)).

refine (proj1 (proj2 (proj2 (proj2 (proj2 (H0 _ _ _ _ _ _)))))).

assumption.



assumption.



assumption.



rewrite H5; reflexivity.



replace cfg'' with (fst (BDDof_bool_expr cfg' negm' orm' be2)).

replace orm'' with (snd (snd (snd (BDDof_bool_expr cfg' negm' orm' be2)))).

refine (proj1 (proj2 (proj2 (proj2 (H0 _ _ _ _ _ _))))).

assumption.



assumption.



assumption.



rewrite H5; reflexivity.



rewrite H5; reflexivity.



replace cfg'' with (fst (BDDof_bool_expr cfg' negm' orm' be2)).

replace negm'' with (fst (snd (snd (BDDof_bool_expr cfg' negm' orm' be2)))).

refine (proj1 (proj2 (proj2 (H0 _ _ _ _ _ _)))).

assumption.



assumption.



assumption.



rewrite H5; reflexivity.



rewrite H5; reflexivity.



replace cfg'' with (fst (BDDof_bool_expr cfg' negm' orm' be2)).

replace node2 with (fst (snd (BDDof_bool_expr cfg' negm' orm' be2))).

refine (proj1 (proj2 (H0 _ _ _ _ _ _))).

assumption.



assumption.



assumption.



rewrite H5; reflexivity.



rewrite H5; reflexivity.



replace cfg'' with (fst (BDDof_bool_expr cfg' negm' orm' be2)).

refine (proj1 (H0 _ _ _ _ _ _)).

assumption.



assumption.



assumption.



rewrite H5; reflexivity.



replace cfg' with (fst (BDDof_bool_expr cfg negm orm be1)).

replace node1 with (fst (snd (BDDof_bool_expr cfg negm orm be1))).

refine (proj2 (proj2 (proj2 (proj2 (proj2 (H _ _ _ _ _ _)))))).

assumption.



assumption.



assumption.



rewrite H4; reflexivity.



rewrite H4; reflexivity.



replace cfg' with (fst (BDDof_bool_expr cfg negm orm be1)).

refine (proj1 (proj2 (proj2 (proj2 (proj2 (H _ _ _ _ _ _)))))).

assumption.



assumption.



assumption.



rewrite H4; reflexivity.



replace cfg' with (fst (BDDof_bool_expr cfg negm orm be1)).

replace orm' with (snd (snd (snd (BDDof_bool_expr cfg negm orm be1)))).

refine (proj1 (proj2 (proj2 (proj2 (H _ _ _ _ _ _))))).

assumption.



assumption.



assumption.



rewrite H4; reflexivity.



rewrite H4; reflexivity.



replace cfg' with (fst (BDDof_bool_expr cfg negm orm be1)).

replace negm' with (fst (snd (snd (BDDof_bool_expr cfg negm orm be1)))).

refine (proj1 (proj2 (proj2 (H _ _ _ _ _ _)))).

assumption.



assumption.



assumption.



rewrite H4; reflexivity.



rewrite H4; reflexivity.



replace cfg' with (fst (BDDof_bool_expr cfg negm orm be1)).

replace node1 with (fst (snd (BDDof_bool_expr cfg negm orm be1))).

refine (proj1 (proj2 (H _ _ _ _ _ _))).

assumption.



assumption.



assumption.



rewrite H4; reflexivity.



rewrite H4; reflexivity.



replace cfg' with (fst (BDDof_bool_expr cfg negm orm be1)).

refine (proj1 (H _ _ _ _ _ _)).

assumption.



assumption.



assumption.



rewrite H4; reflexivity.



Qed.
