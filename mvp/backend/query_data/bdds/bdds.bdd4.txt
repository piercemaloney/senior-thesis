
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import ZArith NArith Nnat Ndec Ndigits.
From IntMap Require Import Allmaps.
Require Import Wf_nat.

Require Import BDDvar_ad_nat.
(* BDDvar_ad_nat:
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import ZArith NArith Nnat Ndec Ndigits.
From IntMap Require Import Allmaps.
Definition BDDzero := N0.
Definition BDDone := Npos 1.

  Definition BDDvar := ad.

  Definition BDDcompare (x y : BDDvar) :=
    match x, y with
    | N0, N0 => Datatypes.Eq
    | N0, Npos _ => Datatypes.Lt
    | Npos _, N0 => Datatypes.Gt
    | Npos p1, Npos p2 => Pcompare p1 p2 Datatypes.Eq
    end.

Definition BDDvar_eq := Neqb.

  Definition ad_S (a : ad) :=
    match a with
    | N0 => Npos 1
    | Npos p => Npos (Psucc p)
    end.

  Lemma ad_S_is_S : forall a : ad, nat_of_N (ad_S a) = S (nat_of_N a).

Lemma lt_pred : forall x y : nat, x < y -> x <> 0 -> pred x < pred y.

Lemma O_N0 : forall x : ad, nat_of_N x = 0 -> x = N0.
Lemma INFERIEUR_neq_O :
 forall x y : ad, BDDcompare x y = Datatypes.Lt -> y <> N0.

 Lemma BDDcompare_trans :
  forall x y z : BDDvar,
  BDDcompare x y = Datatypes.Lt ->

  Lemma ad_S_le_then_le :
   forall x y : ad, Nleb (ad_S x) y = true -> Nleb x y = true.

  Lemma le_then_le_S :
   forall x y : ad, Nleb x y = true -> Nleb x (ad_S y) = true.

  Lemma ad_S_le_then_neq :
   forall x y : ad, Nleb (ad_S x) y = true -> Neqb x y = false.

  Lemma BDDcompare_succ :
   forall a : BDDvar, BDDcompare a (ad_S a) = Datatypes.Lt.

  Lemma BDDcompare_lt :
   forall x y : BDDvar,
   BDDcompare x y = Datatypes.Lt -> nat_of_N x < nat_of_N y.

Lemma BDDlt_compare :
 forall x y : BDDvar,
 nat_of_N x < nat_of_N y -> BDDcompare x y = Datatypes.Lt.

Lemma relation_sum :
 forall r : Datatypes.comparison,

Lemma BDD_EGAL_complete :
 forall x y : BDDvar, BDDcompare x y = Datatypes.Eq -> x = y.

  Lemma lt_trans_1 : forall x y z : nat, x < y -> y < S z -> x < z.

Lemma BDDcompare_sup_inf :
 forall x y : BDDvar,
 BDDcompare x y = Datatypes.Gt -> BDDcompare y x = Datatypes.Lt.

  Lemma BDDcompare_1 :
   forall x y : BDDvar,
   BDDcompare x y = Datatypes.Lt ->

Definition max (m n : nat) := if leb m n then n else m.

Lemma lt_max_1_2 :
 forall x1 y1 x2 y2 : nat, x1 < x2 -> y1 < y2 -> max x1 y1 < max x2 y2.

Lemma lt_max_2 :
 forall x1 y1 x2 y2 : nat, x1 < y2 -> y1 < y2 -> max x1 y1 < max x2 y2.

Lemma lt_max_12 :
 forall x1 y1 x2 y2 : nat, x1 < x2 -> y1 < x2 -> max x1 y1 < max x2 y2.

Lemma BDDcompare_eq :
 forall x y : BDDvar, BDDcompare x y = Datatypes.Eq -> x = y. *)
Require Import bdd1.
(* bdd1:
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import ZArith NArith Nnat Ndec Ndigits.
From IntMap Require Import Allmaps.
Require Import Wf_nat.

Require Import BDDvar_ad_nat.

  Definition BDDstate := Map (BDDvar * (ad * ad)).
	  Definition initBDDstate := newMap (BDDvar * (ad * ad)).

  Inductive BDDbounded (bs : BDDstate) : ad -> BDDvar -> Prop :=
    | BDDbounded_0 : forall n : BDDvar, BDDbounded bs BDDzero n
    | BDDbounded_1 : forall n : BDDvar, BDDbounded bs BDDone n
    | BDDbounded_2 :
        forall (node : ad) (n x : BDDvar) (l r : ad),
        MapGet _ bs node = Some (x, (l, r)) ->
        BDDcompare x n = Datatypes.Lt ->
        Neqb l r = false ->
        BDDbounded bs l x -> BDDbounded bs r x -> BDDbounded bs node n.

  Lemma BDDbounded_lemma :
   forall (bs : BDDstate) (node : ad) (n : BDDvar),
   BDDbounded bs node n ->
   node = BDDzero \/
   node = BDDone \/
   (exists x : BDDvar,
      (exists l : BDDvar,
         (exists r : BDDvar,
            MapGet _ bs node = Some (x, (l, r)) /\
            BDDcompare x n = Datatypes.Lt /\

  Lemma increase_bound :
   forall (bs : BDDstate) (n n' : BDDvar) (node : ad),
   BDDbounded bs node n ->
   BDDcompare n n' = Datatypes.Lt -> BDDbounded bs node n'.

  Lemma boundedness_preservation :
   forall bs bs' : BDDstate,
   (forall (a l r : ad) (x : BDDvar),
    MapGet _ bs a = Some (x, (l, r)) -> MapGet _ bs' a = Some (x, (l, r))) ->
   forall (n : BDDvar) (node : ad),
   BDDbounded bs node n -> BDDbounded bs' node n.

  Definition BDDordered (bs : BDDstate) (node : ad) :=
    match MapGet _ bs node with
    | None => True
    | Some (n, _) => BDDbounded bs node (ad_S n)
    end.

  Definition BDD_OK (bs : BDDstate) (node : ad) := BDDordered bs node.

  Definition BDDstate_OK (bs : BDDstate) :=
    MapGet _ bs BDDzero = None /\
    MapGet _ bs BDDone = None /\
    (forall a : ad, in_dom _ a bs = true -> BDD_OK bs a).

  Lemma initBDDstate_OK : BDDstate_OK initBDDstate.

  Definition BDDsharing_map := Map (Map (Map ad)).
	  Definition initBDDsharing_map := newMap (Map (Map ad)).

  Definition BDDshare_lookup (share : BDDsharing_map) 
    (x : BDDvar) (l r : ad) : option ad :=
    match MapGet _ share l with
    | None => None
    | Some m1 =>
        match MapGet _ m1 r with
        | None => None
        | Some m2 =>
            match MapGet _ m2 x with
            | None => None
            | Some y => Some y
            end
        end
    end.

  Definition BDDshare_put (share : BDDsharing_map) 
    (x : BDDvar) (l r counter : ad) : BDDsharing_map :=
    let m1 :=
      match MapGet _ share l with
      | Some y => y
      | None => newMap (Map ad)
      end in
    let m2 :=
      match MapGet _ m1 r with
      | Some y => y
      | None => newMap ad
      end in
    let m2' := MapPut _ m2 x counter in
    let m1' := MapPut _ m1 r m2' in MapPut _ share l m1'.

  Lemma BDDshare_put_puts :
   forall (share : BDDsharing_map) (x : BDDvar) (l r counter : ad),
   BDDshare_lookup (BDDshare_put share x l r counter) x l r = Some counter.

  Lemma BDDshare_put_no_new_node :
   forall (share : BDDsharing_map) (x x' : BDDvar)
     (l l' r r' counter counter' : ad),
   BDDshare_lookup (BDDshare_put share x l r counter) x' l' r' =
   Some counter' ->
   BDDshare_lookup share x' l' r' = Some counter' \/
   (x, (l, r)) = (x', (l', r')).

  Lemma BDDshare_put_preserves_nodes :
   forall (share : BDDsharing_map) (x x' : BDDvar)
     (l l' r r' counter counter' : ad),
   BDDshare_lookup share x' l' r' = Some counter' ->
   (x, (l, r)) <> (x', (l', r')) ->
   BDDshare_lookup (BDDshare_put share x l r counter) x' l' r' =
   Some counter'.

  Definition BDDsharing_OK (bs : BDDstate) (share : BDDsharing_map) :=
    forall (x : BDDvar) (l r a : ad),
    BDDshare_lookup share x l r = Some a <->
    MapGet _ bs a = Some (x, (l, r)).

  Lemma initBDDsharing_map_OK : BDDsharing_OK initBDDstate initBDDsharing_map.

  Definition BDDconfig := (BDDstate * (BDDsharing_map * ad))%type.

  Definition initBDDconfig :=
    (initBDDstate, (initBDDsharing_map, ad_S (ad_S N0))).

  Definition BDDconfig_OK (cfg : BDDconfig) :=
    match cfg return Prop with
    | (bs, (share, counter)) =>
        BDDstate_OK bs /\
        BDDsharing_OK bs share /\
        (forall a : ad, Nleb counter a = true -> MapGet _ bs a = None) /\
        Nleb (ad_S (ad_S N0)) counter = true
    end.

  Lemma initBDDconfig_OK : BDDconfig_OK initBDDconfig.

  Lemma config_OK_zero :
   forall cfg : BDDconfig,
   BDDconfig_OK cfg -> MapGet _ (fst cfg) BDDzero = None.

  Lemma config_OK_one :
   forall cfg : BDDconfig,
   BDDconfig_OK cfg -> MapGet _ (fst cfg) BDDone = None.

  Definition BDDalloc (cfg : BDDconfig) (x : BDDvar) 
    (l r : ad) :=
    match cfg with
    | (bs, (share, counter)) =>
        let share' := BDDshare_put share x l r counter in
        let bs' := MapPut _ bs counter (x, (l, r)) in
        let counter' := ad_S counter in (bs', (share', counter'), counter)
    end.

  Lemma BDDsharing_lookup_semantics :
   forall (bs : BDDstate) (share : BDDsharing_map) (n l r : ad) (x : BDDvar),
   BDDsharing_OK bs share ->
   (BDDshare_lookup share x l r = Some n <->
    MapGet _ bs n = Some (x, (l, r))).

  Definition node_OK (bs : BDDstate) (node : ad) :=
    node = BDDzero \/ node = BDDone \/ in_dom _ node bs = true.

  Lemma BDDbounded_node_OK :
   forall (bs : BDDstate) (node : ad) (n : BDDvar),
   BDDbounded bs node n -> node_OK bs node.

  Lemma BDDalloc_allocates :
   forall (cfg : BDDconfig) (l r : ad) (x : BDDvar),
   MapGet _ (fst (fst (BDDalloc cfg x l r))) (snd (BDDalloc cfg x l r)) =
   Some (x, (l, r)).

  Lemma BDDalloc_preserves_nodes :
   forall (cfg : BDDconfig) (l r : ad) (x : BDDvar),
   BDDconfig_OK cfg ->
   forall (a l1 r1 : ad) (x1 : BDDvar),
   MapGet _ (fst cfg) a = Some (x1, (l1, r1)) ->
   MapGet _ (fst (fst (BDDalloc cfg x l r))) a = Some (x1, (l1, r1)).

  Lemma BDDalloc_no_new_node :
   forall (cfg : BDDconfig) (l l1 r r1 a : ad) (x x1 : BDDvar),
   MapGet _ (fst (fst (BDDalloc cfg x l r))) a = Some (x1, (l1, r1)) ->
   a = snd (snd cfg) \/ MapGet _ (fst cfg) a = Some (x1, (l1, r1)).

  Lemma BDDalloc_no_new_node_1 :
   forall (cfg : BDDconfig) (l l1 r r1 a : ad) (x x1 : BDDvar),
   MapGet _ (fst (fst (BDDalloc cfg x l r))) a = Some (x1, (l1, r1)) ->
   (x1, (l1, r1)) = (x, (l, r)) \/
   MapGet _ (fst cfg) a = Some (x1, (l1, r1)).

  Lemma BDDalloc_preserves_zero :
   forall (cfg : BDDconfig) (l r : ad) (x : BDDvar),
   BDDconfig_OK cfg ->
   MapGet _ (fst (fst (BDDalloc cfg x l r))) BDDzero = None.

  Lemma BDDalloc_preserves_one :
   forall (cfg : BDDconfig) (l r : ad) (x : BDDvar),
   BDDconfig_OK cfg ->
   MapGet _ (fst (fst (BDDalloc cfg x l r))) BDDone = None.

  Lemma BDDalloc_keeps_state_OK :
   forall (cfg : BDDconfig) (l r : ad) (x : BDDvar),
   BDDconfig_OK cfg ->
   node_OK (fst cfg) l ->
   node_OK (fst cfg) r ->
   Neqb l r <> true ->
   (forall (xl : BDDvar) (ll rl : ad),
    MapGet _ (fst cfg) l = Some (xl, (ll, rl)) ->
    BDDcompare xl x = Datatypes.Lt) ->

  Lemma BDDalloc_adjusts_counter :
   forall (cfg : BDDconfig) (x : BDDvar) (l r a : ad),
   BDDconfig_OK cfg ->
   (forall a : ad,
    Nleb (snd (snd (fst (BDDalloc cfg x l r)))) a = true ->
    MapGet _ (fst (fst (BDDalloc cfg x l r))) a = None) /\
   Nleb (ad_S (ad_S N0)) (snd (snd (fst (BDDalloc cfg x l r)))) = true.

Lemma BDDalloc_keeps_sharing_OK :
 forall (cfg : BDDconfig) (l r : ad) (x : BDDvar),
 BDDconfig_OK cfg ->
 node_OK (fst cfg) l ->
 node_OK (fst cfg) r ->
 (forall (x' : BDDvar) (l' r' a : ad),
  MapGet _ (fst cfg) a = Some (x', (l', r')) ->
  (x, (l, r)) <> (x', (l', r'))) ->
 BDDsharing_OK (fst (fst (BDDalloc cfg x l r)))
   (fst (snd (fst (BDDalloc cfg x l r)))).

  Lemma BDDalloc_semantics :
   forall (cfg : BDDconfig) (l r : ad) (x : BDDvar),
   BDDconfig_OK cfg ->
   node_OK (fst cfg) l ->
   node_OK (fst cfg) r ->
   Neqb l r <> true ->
   (forall (xl : BDDvar) (ll rl : ad),
    MapGet _ (fst cfg) l = Some (xl, (ll, rl)) ->
    BDDcompare xl x = Datatypes.Lt) ->

  Definition BDDmake (cfg : BDDconfig) (x : BDDvar) 
    (l r : ad) :=
    if Neqb l r
    then (cfg, l)
    else
     match cfg with
     | (bs, (share, counter)) =>
         match BDDshare_lookup share x l r with
         | Some y => (cfg, y)
         | None => BDDalloc cfg x l r
         end
     end.

  Lemma BDDmake_semantics :
   forall (cfg : BDDconfig) (l r : ad) (x : BDDvar),
   BDDconfig_OK cfg ->
   node_OK (fst cfg) l ->
   node_OK (fst cfg) r ->
   (forall (xl : BDDvar) (ll rl : ad),
    MapGet _ (fst cfg) l = Some (xl, (ll, rl)) ->
    BDDcompare xl x = Datatypes.Lt) -> *)
Require Import bdd2.
(* bdd2:
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import ZArith NArith Nnat Ndec Ndigits.
From IntMap Require Import Allmaps.
Require Import Wf_nat.

Require Import BDDvar_ad_nat.
Require Import bdd1.

Definition var (cfg : BDDconfig) (node : ad) :=
  match MapGet _ (fst cfg) node with
  | None =>   BDDzero
  | Some (x, (l, r)) => x
  end.

Definition low (cfg : BDDconfig) (node : ad) :=
  match MapGet _ (fst cfg) node with
  | None =>   N0
  | Some (x, (l, r)) => l
  end.

Definition high (cfg : BDDconfig) (node : ad) :=
  match MapGet _ (fst cfg) node with
  | None =>   N0
  | Some (x, (l, r)) => r
  end.

Definition config_node_OK (cfg : BDDconfig) := node_OK (fst cfg).
Definition is_internal_node (cfg : BDDconfig) (node : ad) :=
  exists x : BDDvar,
    (exists l : ad,
       (exists r : ad, MapGet _ (fst cfg) node = Some (x, (l, r)))).

Lemma BDDvar_ordered_low :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node ->
 is_internal_node cfg (low cfg node) ->
 BDDcompare (var cfg (low cfg node)) (var cfg node) = Datatypes.Lt.

Lemma BDDvar_ordered_high :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node ->
 is_internal_node cfg (high cfg node) ->
 BDDcompare (var cfg (high cfg node)) (var cfg node) = Datatypes.Lt.

Definition var_binding := BDDvar -> bool.
 
Definition bool_fun := var_binding -> bool.

Definition bool_fun_eval (bf : bool_fun) (vb : var_binding) := bf vb.

Definition bool_fun_zero (vb : var_binding) := false. 
Definition bool_fun_one (vb : var_binding) := true. 

Fixpoint bool_fun_of_BDD_1 (cfg : BDDconfig) (node : ad) 
 (bound : nat) {struct bound} : bool_fun :=
  match MapGet _ (fst cfg) node with
  | None => if Neqb node BDDzero then bool_fun_zero else bool_fun_one
  | Some (x, (l, r)) =>
      match bound with
      | O =>   bool_fun_zero
      | S bound' =>
          let bfl := bool_fun_of_BDD_1 cfg l bound' in
          let bfr := bool_fun_of_BDD_1 cfg r bound' in
          fun vb : var_binding => if vb x then bfr vb else bfl vb
      end
  end.

Lemma bool_fun_of_BDD_1_semantics :
 forall cfg : BDDconfig,
 BDDconfig_OK cfg ->
 forall bound : nat,
 bool_fun_of_BDD_1 cfg BDDzero bound = bool_fun_zero /\
 bool_fun_of_BDD_1 cfg BDDone bound = bool_fun_one /\
 (forall node : ad,
  is_internal_node cfg node ->
  nat_of_N (var cfg node) < bound ->
  forall vb : var_binding,
  (vb (var cfg node) = true ->
   bool_fun_eval (bool_fun_of_BDD_1 cfg node bound) vb =
   bool_fun_eval (bool_fun_of_BDD_1 cfg (high cfg node) (pred bound)) vb) /\
  (vb (var cfg node) = false ->
   bool_fun_eval (bool_fun_of_BDD_1 cfg node bound) vb =
   bool_fun_eval (bool_fun_of_BDD_1 cfg (low cfg node) (pred bound)) vb)).

Lemma bool_fun_of_BDD_1_semantics_1 :
 forall cfg : BDDconfig,
 BDDconfig_OK cfg ->
 forall bound : nat,
 bool_fun_of_BDD_1 cfg BDDzero bound = bool_fun_zero /\
 bool_fun_of_BDD_1 cfg BDDone bound = bool_fun_one /\
 (forall node : ad,
  is_internal_node cfg node ->
  nat_of_N (var cfg node) < bound ->
  bool_fun_of_BDD_1 cfg node bound =
  (fun vb : var_binding =>
   if vb (var cfg node)
   then bool_fun_of_BDD_1 cfg (high cfg node) (pred bound) vb
   else bool_fun_of_BDD_1 cfg (low cfg node) (pred bound) vb)).

Lemma bool_fun_of_BDD_1_semantics_2 :
 forall (cfg : BDDconfig) (node : ad) (bound1 bound2 : nat),
 MapGet _ (fst cfg) node = None ->
 bool_fun_of_BDD_1 cfg node bound1 = bool_fun_of_BDD_1 cfg node bound2.

Lemma bool_fun_of_BDD_1_change_bound :
 forall cfg : BDDconfig,
 BDDconfig_OK cfg ->
 forall (bound : nat) (node : ad),
 nat_of_N (var cfg node) < bound ->
 bool_fun_of_BDD_1 cfg node bound =
 bool_fun_of_BDD_1 cfg node (S (nat_of_N (var cfg node))).

Definition bool_fun_of_BDD (cfg : BDDconfig) (node : ad) :=
  bool_fun_of_BDD_1 cfg node (S (nat_of_N (var cfg node))).

Lemma bool_fun_of_BDD_semantics :
 forall cfg : BDDconfig,
 BDDconfig_OK cfg ->
 bool_fun_of_BDD cfg BDDzero = bool_fun_zero /\
 bool_fun_of_BDD cfg BDDone = bool_fun_one /\
 (forall node : ad,
  is_internal_node cfg node ->
  bool_fun_of_BDD cfg node =
  (fun vb : var_binding =>
   if vb (var cfg node)
   then bool_fun_of_BDD cfg (high cfg node) vb
   else bool_fun_of_BDD cfg (low cfg node) vb)).

Definition bool_fun_eq (bf1 bf2 : bool_fun) :=
  forall vb : var_binding, bool_fun_eval bf1 vb = bool_fun_eval bf2 vb.

Lemma bool_fun_eq_symm :
 forall bf1 bf2 : bool_fun, bool_fun_eq bf1 bf2 -> bool_fun_eq bf2 bf1.

Lemma bool_fun_eq_trans :
 forall bf1 bf2 bf3 : bool_fun,
 bool_fun_eq bf1 bf2 -> bool_fun_eq bf2 bf3 -> bool_fun_eq bf1 bf3.

Definition bool_fun_neg (bf : bool_fun) : bool_fun :=
  fun vb : var_binding => negb (bf vb).
Definition bool_fun_or (bf1 bf2 : bool_fun) : bool_fun :=
  fun vb : var_binding => bf1 vb || bf2 vb.

Lemma bool_fun_neg_semantics :
 forall (bf : bool_fun) (vb : var_binding),
 (bool_fun_eval bf vb = true -> bool_fun_eval (bool_fun_neg bf) vb = false) /\
 (bool_fun_eval bf vb = false -> bool_fun_eval (bool_fun_neg bf) vb = true).

Lemma bool_fun_neg_zero : bool_fun_neg bool_fun_zero = bool_fun_one.

Lemma bool_fun_neg_one : bool_fun_neg bool_fun_one = bool_fun_zero.

Lemma bool_fun_eq_neg :
 forall bf1 bf2 : bool_fun,
 bool_fun_eq (bool_fun_neg bf1) (bool_fun_neg bf2) -> bool_fun_eq bf1 bf2.

Lemma bool_fun_eq_neg_1 :
 forall bf1 bf2 : bool_fun,
 bool_fun_eq bf1 bf2 -> bool_fun_eq (bool_fun_neg bf1) (bool_fun_neg bf2).

Definition BDDneg_memo := Map ad.
Definition BDDneg_memo_lookup (memo : BDDneg_memo) 
  (a : ad) := MapGet _ memo a.
Definition BDDneg_memo_put (memo : BDDneg_memo) (a node : ad) :=
  MapPut _ memo a node.

Definition BDDneg_memo_OK (cfg : BDDconfig) (memo : BDDneg_memo) :=
  forall a node : ad,
  BDDneg_memo_lookup memo a = Some node ->
  config_node_OK cfg node /\
  bool_fun_of_BDD cfg node = bool_fun_neg (bool_fun_of_BDD cfg a) /\
  var cfg a = var cfg node. 

Fixpoint BDDneg_2 (cfg : BDDconfig) (node : ad) (bound : nat) {struct bound} 
   : BDDconfig * ad :=
  match MapGet _ (fst cfg) node with
  | None => if Neqb node BDDzero then (cfg, BDDone) else (cfg, BDDzero)
  | Some (x, (l, r)) =>
      match bound with
      | O =>   (initBDDconfig, BDDzero)
      | S bound' =>
          BDDmake (fst (BDDneg_2 (fst (BDDneg_2 cfg l bound')) r bound')) x
            (snd (BDDneg_2 cfg l bound'))
            (snd (BDDneg_2 (fst (BDDneg_2 cfg l bound')) r bound'))
      end
  end. *)
Require Import bdd3.
(* bdd3:
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import ZArith NArith Nnat Ndec Ndigits.
From IntMap Require Import Allmaps.
Require Import Wf_nat.

Require Import BDDvar_ad_nat.
Require Import bdd1.
Require Import bdd2.

Lemma bool_fun_one_zero_eq : ~ bool_fun_eq bool_fun_one bool_fun_zero.

Lemma bool_fun_zero_one_eq : ~ bool_fun_eq bool_fun_zero bool_fun_one.

Definition augment (vb : var_binding) (x : BDDvar) 
  (b : bool) (y : BDDvar) := if BDDvar_eq x y then b else vb y.

Definition bool_fun_restrict (bf : bool_fun) (x : BDDvar) 
  (b : bool) (vb : var_binding) := bool_fun_eval bf (augment vb x b).

Lemma bool_fun_restrict_zero :
 forall (x : BDDvar) (b : bool),
 bool_fun_eq (bool_fun_restrict bool_fun_zero x b) bool_fun_zero. 

Lemma bool_fun_restrict_one :
 forall (x : BDDvar) (b : bool),
 bool_fun_eq (bool_fun_restrict bool_fun_one x b) bool_fun_one.

Lemma bool_fun_restrict_eq :
 forall (bf bf' : bool_fun) (x : BDDvar) (b : bool),
 bool_fun_eq bf bf' ->
 bool_fun_eq (bool_fun_restrict bf x b) (bool_fun_restrict bf' x b).

Definition var_binding_eq (vb vb' : var_binding) :=
  forall x : BDDvar, vb x = vb' x.

Definition bool_fun_ext (bf : bool_fun) :=
  forall vb vb' : var_binding,
  var_binding_eq vb vb' -> bool_fun_eval bf vb = bool_fun_eval bf vb'.

Lemma bool_fun_of_BDD_1_ext :
 forall (bound : nat) (cfg : BDDconfig) (node : ad),
 bool_fun_ext (bool_fun_of_BDD_1 cfg node bound). 

Lemma bool_fun_of_BDD_ext :
 forall (cfg : BDDconfig) (node : ad),
 bool_fun_ext (bool_fun_of_BDD cfg node).

Lemma augment_eq :
 forall (vb : var_binding) (x : BDDvar) (b : bool),
 vb x = b -> var_binding_eq (augment vb x b) vb.

Definition bool_fun_independent (bf : bool_fun) (x : BDDvar) :=
  forall vb : var_binding,
  bool_fun_eval bf (augment vb x true) =
  bool_fun_eval bf (augment vb x false).

Lemma bool_fun_independent_lemma :
 forall (bf : bool_fun) (x : BDDvar) (vb : var_binding) (b : bool),
 bool_fun_ext bf ->
 bool_fun_independent bf x ->
 bool_fun_eval bf (augment vb x b) = bool_fun_eval bf vb. 

Lemma bool_fun_independent_zero :
 forall (cfg : BDDconfig) (x : BDDvar),
 BDDconfig_OK cfg -> bool_fun_independent (bool_fun_of_BDD cfg BDDzero) x.

Lemma bool_fun_independent_one :
 forall (cfg : BDDconfig) (x : BDDvar),
 BDDconfig_OK cfg -> bool_fun_independent (bool_fun_of_BDD cfg BDDone) x.

Lemma in_dom_is_internal :
 forall (cfg : BDDconfig) (node : ad),
 in_dom _ node (fst cfg) = true -> is_internal_node cfg node.

Lemma internal_node_lemma :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node ->
 Neqb (low cfg node) (high cfg node) = false /\
 BDDbounded (fst cfg) (low cfg node) (var cfg node) /\
 BDDbounded (fst cfg) (high cfg node) (var cfg node).

Lemma high_bounded :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node ->
 BDDbounded (fst cfg) (high cfg node) (var cfg node).

Lemma low_bounded :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node ->
 BDDbounded (fst cfg) (low cfg node) (var cfg node).

Lemma high_OK :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node -> config_node_OK cfg (high cfg node).

Lemma low_OK :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node -> config_node_OK cfg (low cfg node).

Lemma low_high_neq :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node -> Neqb (low cfg node) (high cfg node) = false.

Lemma BDDvar_independent_1 :
 forall (cfg : BDDconfig) (n : nat) (node : ad) (x : BDDvar),
 BDDconfig_OK cfg ->
 is_internal_node cfg node ->
 n = nat_of_N (var cfg node) ->
 BDDcompare (var cfg node) x = Datatypes.Lt ->

Lemma BDDvar_independent_high :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node ->
 bool_fun_independent (bool_fun_of_BDD cfg (high cfg node)) (var cfg node).

Lemma BDDvar_independent_low :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node ->
 bool_fun_independent (bool_fun_of_BDD cfg (low cfg node)) (var cfg node).

Lemma bool_fun_of_BDDzero :
 forall cfg : BDDconfig,
 BDDconfig_OK cfg -> bool_fun_eq (bool_fun_of_BDD cfg BDDzero) bool_fun_zero.

Lemma bool_fun_of_BDDone :
 forall cfg : BDDconfig,
 BDDconfig_OK cfg -> bool_fun_eq (bool_fun_of_BDD cfg BDDone) bool_fun_one.

Lemma bool_fun_of_BDDhigh :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node ->
 bool_fun_eq (bool_fun_of_BDD cfg (high cfg node))
   (bool_fun_restrict (bool_fun_of_BDD cfg node) (var cfg node) true).

Lemma bool_fun_of_BDDlow :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node ->
 bool_fun_eq (bool_fun_of_BDD cfg (low cfg node))
   (bool_fun_restrict (bool_fun_of_BDD cfg node) (var cfg node) false).

Lemma internal_node_not_constant_1 :
 forall cfg : BDDconfig,
 BDDconfig_OK cfg ->
 forall (n : nat) (node : ad),
 is_internal_node cfg node ->
 n = nat_of_N (var cfg node) ->
 ~ bool_fun_eq (bool_fun_of_BDD cfg node) bool_fun_zero /\
 ~ bool_fun_eq (bool_fun_of_BDD cfg node) bool_fun_one.

Lemma internal_node_not_constant :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node ->
 ~ bool_fun_eq (bool_fun_of_BDD cfg node) bool_fun_zero /\
 ~ bool_fun_eq (bool_fun_of_BDD cfg node) bool_fun_one.

Lemma bool_fun_neq_internal_zero :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node ->
 ~ bool_fun_eq (bool_fun_of_BDD cfg node) (bool_fun_of_BDD cfg BDDzero).
 
Lemma bool_fun_neq_internal_one :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node ->
 ~ bool_fun_eq (bool_fun_of_BDD cfg node) (bool_fun_of_BDD cfg BDDone).

Lemma bool_fun_neq_zero_one :
 forall cfg : BDDconfig,
 BDDconfig_OK cfg ->
 ~ bool_fun_eq (bool_fun_of_BDD cfg BDDzero) (bool_fun_of_BDD cfg BDDone).

Lemma bool_fun_neq_one_zero :
 forall cfg : BDDconfig,
 BDDconfig_OK cfg ->
 ~ bool_fun_eq (bool_fun_of_BDD cfg BDDone) (bool_fun_of_BDD cfg BDDzero).

Lemma bool_fun_neq_lemma :
 forall bf1 bf2 : bool_fun, ~ bool_fun_eq bf1 bf2 -> ~ bool_fun_eq bf2 bf1.

Lemma no_duplicate_node :
 forall (cfg : BDDconfig) (node1 node2 : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node1 ->
 is_internal_node cfg node2 ->
 var cfg node1 = var cfg node2 ->
 high cfg node1 = high cfg node2 ->
 low cfg node1 = low cfg node2 -> node1 = node2.

Lemma BDDunique_1 :
 forall cfg : BDDconfig,
 BDDconfig_OK cfg ->
 forall (n : nat) (node1 node2 : ad),
 n = max (nat_of_N (var cfg node1)) (nat_of_N (var cfg node2)) ->
 config_node_OK cfg node1 ->
 config_node_OK cfg node2 ->
 bool_fun_eq (bool_fun_of_BDD cfg node1) (bool_fun_of_BDD cfg node2) ->
 node1 = node2.

Lemma BDDunique :
 forall cfg : BDDconfig,
 BDDconfig_OK cfg ->
 forall node1 node2 : ad,
 config_node_OK cfg node1 ->
 config_node_OK cfg node2 ->
 bool_fun_eq (bool_fun_of_BDD cfg node1) (bool_fun_of_BDD cfg node2) ->
 node1 = node2.

Lemma bool_fun_eq_lemma :
 forall (bf1 bf2 : bool_fun) (x : BDDvar),
 bool_fun_ext bf1 ->
 bool_fun_ext bf2 ->
 bool_fun_eq (bool_fun_restrict bf1 x true) (bool_fun_restrict bf2 x true) ->
 bool_fun_eq (bool_fun_restrict bf1 x false) (bool_fun_restrict bf2 x false) ->
 bool_fun_eq bf1 bf2.
  
Lemma bool_fun_preservation_1 :
 forall cfg cfg' : BDDconfig,
 BDDconfig_OK cfg ->
 BDDconfig_OK cfg' ->
 (forall (x : BDDvar) (l r a : ad),
  MapGet _ (fst cfg) a = Some (x, (l, r)) ->
  MapGet _ (fst cfg') a = Some (x, (l, r))) ->
 forall (n : nat) (node : ad),
 n = nat_of_N (var cfg node) ->
 config_node_OK cfg node ->
 bool_fun_eq (bool_fun_of_BDD cfg' node) (bool_fun_of_BDD cfg node).

Lemma bool_fun_preservation :
 forall (cfg cfg' : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 BDDconfig_OK cfg' ->
 (forall (x : BDDvar) (l r a : ad),
  MapGet _ (fst cfg) a = Some (x, (l, r)) ->
  MapGet _ (fst cfg') a = Some (x, (l, r))) ->
 config_node_OK cfg node ->
 bool_fun_eq (bool_fun_of_BDD cfg' node) (bool_fun_of_BDD cfg node). *)

Lemma BDDneg_2_lemma :
 forall (bound : nat) (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 config_node_OK cfg node ->
 (is_internal_node cfg node -> nat_of_N (var cfg node) < bound) ->
 BDDconfig_OK (fst (BDDneg_2 cfg node bound)) /\
 (forall (x : BDDvar) (l r a : ad),
  MapGet _ (fst cfg) a = Some (x, (l, r)) ->
  MapGet _ (fst (fst (BDDneg_2 cfg node bound))) a = Some (x, (l, r))) /\
 (is_internal_node cfg node ->
  is_internal_node (fst (BDDneg_2 cfg node bound))
    (snd (BDDneg_2 cfg node bound)) /\
  var cfg node =
  var (fst (BDDneg_2 cfg node bound)) (snd (BDDneg_2 cfg node bound))) /\
 config_node_OK (fst (BDDneg_2 cfg node bound))
   (snd (BDDneg_2 cfg node bound)) /\
 bool_fun_eq
   (bool_fun_of_BDD (fst (BDDneg_2 cfg node bound))
      (snd (BDDneg_2 cfg node bound)))
   (bool_fun_neg (bool_fun_of_BDD cfg node)).
Proof.
  intro bound.
  apply
   lt_wf_ind
    with
      (P := fun bound : nat =>
            forall (cfg : BDDconfig) (node : ad),
            BDDconfig_OK cfg ->
            config_node_OK cfg node ->
            (is_internal_node cfg node -> nat_of_N (var cfg node) < bound) ->
            BDDconfig_OK (fst (BDDneg_2 cfg node bound)) /\
            (forall (x : BDDvar) (l r a : ad),
             MapGet _ (fst cfg) a = Some (x, (l, r)) ->
             MapGet _ (fst (fst (BDDneg_2 cfg node bound))) a =
             Some (x, (l, r))) /\
            (is_internal_node cfg node ->
             is_internal_node (fst (BDDneg_2 cfg node bound))
               (snd (BDDneg_2 cfg node bound)) /\
             var cfg node =
             var (fst (BDDneg_2 cfg node bound))
               (snd (BDDneg_2 cfg node bound))) /\
            config_node_OK (fst (BDDneg_2 cfg node bound))
              (snd (BDDneg_2 cfg node bound)) /\
            bool_fun_eq
              (bool_fun_of_BDD (fst (BDDneg_2 cfg node bound))
                 (snd (BDDneg_2 cfg node bound)))
              (bool_fun_neg (bool_fun_of_BDD cfg node))).
  intro n.  elim n.  intro H.  intro cfg.  elim cfg.  clear cfg.  intros bs y.  elim y.   clear y.  
  intros share counter.  intros node H0 H1 H2.  unfold BDDneg_2 in |- *.
  elim
   (option_sum _
      (MapGet (BDDvar * (ad * ad)) (fst (bs, (share, counter))) node)).  intros y.
  elim y.  clear y.  intro y.  elim y.  clear y.  intros x y.  elim y.  clear y.
  intros l r.  intro y.  cut False.  tauto.  cut (~ nat_of_N (var (bs, (share, counter)) node) < 0).
  unfold not in |- *.  intro H3.  apply H3.  apply H2.  unfold is_internal_node in |- *.  split with x.
  split with l.  split with r.  assumption.  apply lt_n_O.  intro y.  rewrite y.
  elim H1.  intro H3.  rewrite H3.  simpl in |- *.  split.  exact H0.  split.  intros x l r a H4.
  assumption.  split.  split.  unfold is_internal_node in H4.  elim H4.  intros x H5.
  elim H5.  intros x0 H6.  elim H6.  intros x1 H7.  rewrite H3 in y.  rewrite y in H7.
  discriminate H7.  unfold is_internal_node in H4.  elim H4.  intros x H5.  elim H5. 
  intros x0 H6.  elim H6.  intros x1 H7.  rewrite H3 in y.  rewrite y in H7.
  discriminate H7.  split.  right.  left.  reflexivity.
  rewrite (proj1 (bool_fun_of_BDD_semantics (bs, (share, counter)) H0)).
  rewrite
   (proj1 (proj2 (bool_fun_of_BDD_semantics (bs, (share, counter)) H0)))
   .
  unfold bool_fun_eq in |- *.  unfold bool_fun_eval in |- *.  unfold bool_fun_one, bool_fun_zero, bool_fun_neg in |- *.
  simpl in |- *.  reflexivity.  intro H3.  elim H3.  clear H3.  intro H3.  rewrite H3.  simpl in |- *.
  split.  exact H0.  split.  intros x l r a H4.  assumption.  split.  split.  unfold is_internal_node in H4.  elim H4.
  intros x H5.  elim H5.  intros x0 H6.  elim H6.  intros x1 H7.  rewrite H3 in y.  rewrite y in H7.
  discriminate H7.  unfold is_internal_node in H4.  elim H4.  intros x H5.  elim H5.
  intros x0 H6.  elim H6.  intros x1 H7.  rewrite H3 in y.  rewrite y in H7.  discriminate H7.
  split.  left.  reflexivity.  rewrite (proj1 (bool_fun_of_BDD_semantics (bs, (share, counter)) H0)).
  rewrite
   (proj1 (proj2 (bool_fun_of_BDD_semantics (bs, (share, counter)) H0)))
   .
  unfold bool_fun_eq in |- *.  unfold bool_fun_eval, bool_fun_zero, bool_fun_one, bool_fun_neg in |- *.
  reflexivity.  clear H3.  intro H3.  unfold in_dom in H3.  rewrite y in H3.
  discriminate H3.  intro n0.  intro H.  intro H0.  intro cfg.  elim cfg.  clear cfg.
  intros bs y.  elim y.  clear y.  intros share counter.  intros node H1 H2 H3.  elim H2.
  intro H4.  rewrite H4.  unfold BDDneg_2 in |- *.  simpl in |- *; rewrite (proj1 (proj1 H1)).
  split.  exact H1.  split.  intros x l r a H5.  exact H5.  split.  intros H5.
  unfold is_internal_node in H5.  elim H5; intros; elim H6; intros; elim H7; intros.
  simpl in H8.  rewrite (proj1 (proj1 H1)) in H8.  discriminate H8.  
  split.  simpl in |- *.  right.  left.  reflexivity.  rewrite (proj1 (bool_fun_of_BDD_semantics (bs, (share, counter)) H1)).
  simpl in |- *.  rewrite
   (proj1 (proj2 (bool_fun_of_BDD_semantics (bs, (share, counter)) H1)))
   .
  unfold bool_fun_eq in |- *.  reflexivity.  intro; elim H4; clear H4; intro.  rewrite H4.
  simpl in |- *; rewrite (proj1 (proj2 (proj1 H1))).  split.
  unfold BDDneg_2 in |- *.  exact H1.  split.  intros x l r a H5.  exact H5.  split.  intro H5.
  unfold is_internal_node in H5.  elim H5; intros.  elim H6; intros; elim H7; intros.
  simpl in H8; rewrite (proj1 (proj2 (proj1 H1))) in H8; discriminate H8.
  split.  simpl in |- *.  left; reflexivity.  simpl in |- *;
   rewrite (proj1 (bool_fun_of_BDD_semantics (bs, (share, counter)) H1));
   rewrite
    (proj1 (proj2 (bool_fun_of_BDD_semantics (bs, (share, counter)) H1)))
    .
  unfold bool_fun_eq in |- *.  reflexivity.  elim (option_sum _ (MapGet _ (fst (bs, (share, counter))) node)).
  intros y. elim y; clear y; intro y; elim y; clear y; intros x y; elim y; clear y;
  intros l r.
  intro y.  cut (config_node_OK (bs, (share, counter)) l).  cut (config_node_OK (bs, (share, counter)) r).
  intros H5 H6.  simpl in y.  unfold BDDneg_2 in |- *; simpl in |- *; rewrite y; fold BDDneg_2 in |- *.
  cut
   (is_internal_node (bs, (share, counter)) l ->
    nat_of_N (var (bs, (share, counter)) l) < n0).
  cut
   (BDDconfig_OK (fst (BDDneg_2 (bs, (share, counter)) l n0)) /\
    (forall (x0 : BDDvar) (l0 r0 a : ad),
     MapGet _ (fst (bs, (share, counter))) a = Some (x0, (l0, r0)) ->
     MapGet _ (fst (fst (BDDneg_2 (bs, (share, counter)) l n0))) a =
     Some (x0, (l0, r0))) /\
    (is_internal_node (bs, (share, counter)) l ->
     is_internal_node (fst (BDDneg_2 (bs, (share, counter)) l n0))
       (snd (BDDneg_2 (bs, (share, counter)) l n0)) /\
     var (bs, (share, counter)) l =
     var (fst (BDDneg_2 (bs, (share, counter)) l n0))
       (snd (BDDneg_2 (bs, (share, counter)) l n0))) /\
    config_node_OK (fst (BDDneg_2 (bs, (share, counter)) l n0))
      (snd (BDDneg_2 (bs, (share, counter)) l n0)) /\
    bool_fun_eq
      (bool_fun_of_BDD (fst (BDDneg_2 (bs, (share, counter)) l n0))
         (snd (BDDneg_2 (bs, (share, counter)) l n0)))
      (bool_fun_neg (bool_fun_of_BDD (bs, (share, counter)) l))).
  intros H7 H8.  elim H7; clear H7; intros.  elim H9; clear H9; intros.  elim H10; clear H10; intros.
  elim H11; clear H11; intros.  cut (config_node_OK (fst (BDDneg_2 (bs, (share, counter)) l n0)) r).
  cut
   (is_internal_node (fst (BDDneg_2 (bs, (share, counter)) l n0)) r ->
    nat_of_N (var (fst (BDDneg_2 (bs, (share, counter)) l n0)) r) < n0).
  intros H13 H14.  cut
   (BDDconfig_OK
      (fst (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r n0)) /\
    (forall (x0 : BDDvar) (l0 r0 a : ad),
     MapGet _ (fst (fst (BDDneg_2 (bs, (share, counter)) l n0))) a =
     Some (x0, (l0, r0)) ->
     MapGet _
       (fst
          (fst (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r n0)))
       a = Some (x0, (l0, r0))) /\
    (is_internal_node (fst (BDDneg_2 (bs, (share, counter)) l n0)) r ->
     is_internal_node
       (fst (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r n0))
       (snd (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r n0)) /\
     var (fst (BDDneg_2 (bs, (share, counter)) l n0)) r =
     var (fst (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r n0))
       (snd (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r n0))) /\
    config_node_OK
      (fst (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r n0))
      (snd (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r n0)) /\
    bool_fun_eq
      (bool_fun_of_BDD
         (fst (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r n0))
         (snd (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r n0)))
      (bool_fun_neg
         (bool_fun_of_BDD (fst (BDDneg_2 (bs, (share, counter)) l n0)) r))).
  intros H15.  elim H15; clear H15; intros; elim H16; clear H16; intros; elim H17;
   clear H17; intros.
  elim H18.  clear H18.  intros H18 H19.  cut
   (node_OK
      (fst (fst (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r n0)))
      (snd (BDDneg_2 (bs, (share, counter)) l n0))).
  cut
   (node_OK
      (fst (fst (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r n0)))
      (snd (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r n0))).
  cut
   (forall (xl : BDDvar) (ll rl : ad),
    MapGet _
      (fst (fst (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r n0)))
      (snd (BDDneg_2 (bs, (share, counter)) l n0)) = 
    Some (xl, (ll, rl)) -> BDDcompare xl x = Datatypes.Lt).
  cut
   (forall (xr : BDDvar) (lr rr : ad),
    MapGet _
      (fst (fst (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r n0)))
      (snd (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r n0)) =
    Some (xr, (lr, rr)) -> BDDcompare xr x = Datatypes.Lt).
  intros H20 H21 H22 H23.
  cut
   (BDDconfig_OK
      (fst
         (BDDmake
            (fst (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r n0))
            x (snd (BDDneg_2 (bs, (share, counter)) l n0))
            (snd (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r n0)))) /\
    (Neqb (snd (BDDneg_2 (bs, (share, counter)) l n0))
       (snd (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r n0)) =
     false ->
     MapGet _
       (fst
          (fst
             (BDDmake
                (fst
                   (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r
                      n0)) x (snd (BDDneg_2 (bs, (share, counter)) l n0))
                (snd
                   (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r
                      n0)))))
       (snd
          (BDDmake
             (fst
                (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r n0))
             x (snd (BDDneg_2 (bs, (share, counter)) l n0))
             (snd
                (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r n0)))) =
     Some
       (x,
       (snd (BDDneg_2 (bs, (share, counter)) l n0),
       snd (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r n0)))) /\
    (Neqb (snd (BDDneg_2 (bs, (share, counter)) l n0))
       (snd (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r n0)) =
     true ->
     snd
       (BDDmake
          (fst (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r n0))
          x (snd (BDDneg_2 (bs, (share, counter)) l n0))
          (snd (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r n0))) =
     snd (BDDneg_2 (bs, (share, counter)) l n0)) /\
    (forall (a l' r' : ad) (x' : BDDvar),
     (MapGet _
        (fst
           (fst
              (BDDmake
                 (fst
                    (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r
                       n0)) x (snd (BDDneg_2 (bs, (share, counter)) l n0))
                 (snd
                    (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r
                       n0))))) a = Some (x', (l', r')) ->
      MapGet _
        (fst
           (fst (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r n0)))
        a = Some (x', (l', r')) \/
      snd
        (BDDmake
           (fst (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r n0))
           x (snd (BDDneg_2 (bs, (share, counter)) l n0))
           (snd (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r n0))) =
      a) /\
     (MapGet _
        (fst
           (fst (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r n0)))
        a = Some (x', (l', r')) ->
      MapGet _
        (fst
           (fst
              (BDDmake
                 (fst
                    (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r
                       n0)) x (snd (BDDneg_2 (bs, (share, counter)) l n0))
                 (snd
                    (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r
                       n0))))) a = Some (x', (l', r')))) /\
    node_OK
      (fst
         (fst
            (BDDmake
               (fst
                  (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r n0))
               x (snd (BDDneg_2 (bs, (share, counter)) l n0))
               (snd
                  (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r n0)))))
      (snd
         (BDDmake
            (fst (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r n0))
            x (snd (BDDneg_2 (bs, (share, counter)) l n0))
            (snd (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r n0))))).
  intros H24.  elim H24; clear H24; intros; elim H25; clear H25; intros; elim H26;
   clear H26; intros.  elim H27; clear H27; intros.  split.
  assumption.  cut
   (forall (x0 : BDDvar) (l0 r0 a : ad),
    MapGet (BDDvar * (ad * ad)) bs a =
    Some (x0, (l0, r0)) ->
    MapGet (BDDvar * (ad * ad))
      (fst
         (fst
            (BDDmake
               (fst
                  (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r n0))
               x (snd (BDDneg_2 (bs, (share, counter)) l n0))
               (snd
                  (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r n0)))))
      a = Some (x0, (l0, r0))).
  intros H29.  split.  assumption.  cut
   (is_internal_node (bs, (share, counter)) node ->
    is_internal_node
      (fst
         (BDDmake
            (fst (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r n0))
            x (snd (BDDneg_2 (bs, (share, counter)) l n0))
            (snd (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r n0))))
      (snd
         (BDDmake
            (fst (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r n0))
            x (snd (BDDneg_2 (bs, (share, counter)) l n0))
            (snd (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r n0)))) /\
    var (bs, (share, counter)) node =
    var
      (fst
         (BDDmake
            (fst (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r n0))
            x (snd (BDDneg_2 (bs, (share, counter)) l n0))
            (snd (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r n0))))
      (snd
         (BDDmake
            (fst (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r n0))
            x (snd (BDDneg_2 (bs, (share, counter)) l n0))
            (snd (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r n0))))).
  intros H30.  split.  assumption.  cut
   (config_node_OK
      (fst
         (BDDmake
            (fst (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r n0))
            x (snd (BDDneg_2 (bs, (share, counter)) l n0))
            (snd (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r n0))))
      (snd
         (BDDmake
            (fst (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r n0))
            x (snd (BDDneg_2 (bs, (share, counter)) l n0))
            (snd (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r n0))))).
  intros H31.  split.  assumption.  cut
   (bool_fun_eq
      (bool_fun_of_BDD
         (fst
            (BDDmake
               (fst
                  (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r n0))
               x (snd (BDDneg_2 (bs, (share, counter)) l n0))
               (snd
                  (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r n0))))
         (snd (BDDneg_2 (bs, (share, counter)) l n0)))
      (bool_fun_neg (bool_fun_of_BDD (bs, (share, counter)) l))).
  intro H32.  cut
   (bool_fun_eq
      (bool_fun_of_BDD
         (fst
            (BDDmake
               (fst
                  (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r n0))
               x (snd (BDDneg_2 (bs, (share, counter)) l n0))
               (snd
                  (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r n0))))
         (snd (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r n0)))
      (bool_fun_neg (bool_fun_of_BDD (bs, (share, counter)) r))).
  intro H33.  cut
   (Neqb (snd (BDDneg_2 (bs, (share, counter)) l n0))
      (snd (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r n0)) =
    false).
  intro H34.  cut
   (MapGet (BDDvar * (ad * ad))
      (fst
         (fst
            (BDDmake
               (fst
                  (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r n0))
               x (snd (BDDneg_2 (bs, (share, counter)) l n0))
               (snd
                  (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r n0)))))
      (snd
         (BDDmake
            (fst (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r n0))
            x (snd (BDDneg_2 (bs, (share, counter)) l n0))
            (snd (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r n0)))) =
    Some
      (x,
      (snd (BDDneg_2 (bs, (share, counter)) l n0),
      snd (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r n0)))).
  intro H35.  cut
   (is_internal_node
      (fst
         (BDDmake
            (fst (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r n0))
            x (snd (BDDneg_2 (bs, (share, counter)) l n0))
            (snd (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r n0))))
      (snd
         (BDDmake
            (fst (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r n0))
            x (snd (BDDneg_2 (bs, (share, counter)) l n0))
            (snd (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r n0))))).
  intro H36.  rewrite (proj2 (proj2 (bool_fun_of_BDD_semantics _ H24)) _ H36).
  cut (is_internal_node (bs, (share, counter)) node).  intro H37.  rewrite (proj2 (proj2 (bool_fun_of_BDD_semantics _ H1)) _ H37).
  unfold var, high, low in |- *.  rewrite H35.  simpl in |- *.  rewrite y.  unfold bool_fun_eq in H32.
  unfold bool_fun_eval in H32.  unfold bool_fun_eq in |- *.  unfold bool_fun_eval in |- *.  unfold bool_fun_neg in |- *.
  intro vb.  rewrite (H32 vb).  unfold bool_fun_eq in H33.  unfold bool_fun_eval in H33.
  rewrite (H33 vb).  elim (vb x); reflexivity.  unfold is_internal_node in |- *.
  split with x.  split with l.  split with r.  assumption.  unfold is_internal_node in |- *.
  split with x.  split with (snd (BDDneg_2 (bs, (share, counter)) l n0)).
  split
   with (snd (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r n0)). 
  assumption.  apply H25.  assumption.  cut
   (Neqb (snd (BDDneg_2 (bs, (share, counter)) l n0))
      (snd (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r n0)) <>
    true).
  elim
   (Neqb (snd (BDDneg_2 (bs, (share, counter)) l n0))
      (snd (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r n0))).
  unfold not in |- *.  intro H34.  cut False.  tauto.  apply H34.  reflexivity.  
  intro H34.  reflexivity.  unfold not in |- *.  intro H34.  cut
   (snd (BDDneg_2 (bs, (share, counter)) l n0) =
    snd (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r n0)). 
  intro H35.  rewrite <- H35 in H33.  cut
   (bool_fun_eq (bool_fun_neg (bool_fun_of_BDD (bs, (share, counter)) r))
      (bool_fun_neg (bool_fun_of_BDD (bs, (share, counter)) l))).
  intro H36.  cut
   (bool_fun_eq (bool_fun_of_BDD (bs, (share, counter)) r)
      (bool_fun_of_BDD (bs, (share, counter)) l)).
  intro H37.  cut (r = l).  intro H38.  cut (Neqb l r = true).  intro H39.  elim H1.  intros H40 H41.
  elim H40.  intros H42 H43.  elim H43.  intros H44 H45.  cut (BDD_OK bs node).  unfold BDD_OK in |- *. 
  unfold BDDordered in |- *.  rewrite y.  intro H46.  cut
   (node = BDDzero \/
    node = BDDone \/
    (exists x0 : BDDvar,
       (exists l0 : BDDvar,
          (exists r0 : BDDvar,
             MapGet _ bs node = Some (x0, (l0, r0)) /\
             BDDcompare x0 (ad_S x) = Datatypes.Lt /\
             Neqb l0 r0 = false /\
             BDDbounded bs l0 x0 /\ BDDbounded bs r0 x0)))).
  intro H47.  elim H47.  intro H48.  rewrite H48 in y.  rewrite y in H42.
  discriminate H42.  clear H47; intro.  elim H47.  clear H47.  intro H47.
  rewrite H47 in y; rewrite y in H44; discriminate.  intro H48.  elim H48.
  intros x0 H49.  elim H49; intros; elim H50; intros.  elim H51.  intros H52 H53.  rewrite y in H52.
  injection H52.  intros H54 H55 H56.  rewrite <- H54 in H53.  rewrite <- H55 in H53.
  rewrite H39 in H53.  elim H53; intros.  elim H58; intros.  discriminate H59.
  apply BDDbounded_lemma.  assumption.  apply H45.  unfold in_dom in |- *.  rewrite y.  
  reflexivity.  rewrite H38.  apply Neqb_correct.  apply BDDunique with (cfg := (bs, (share, counter))).
  assumption.  assumption.  assumption.  assumption.  apply bool_fun_eq_neg.
  assumption.  apply
   bool_fun_eq_trans
    with
      (bf2 := bool_fun_of_BDD
                (fst
                   (BDDmake
                      (fst
                         (BDDneg_2
                            (fst (BDDneg_2 (bs, (share, counter)) l n0)) r n0))
                      x (snd (BDDneg_2 (bs, (share, counter)) l n0))
                      (snd (BDDneg_2 (bs, (share, counter)) l n0))))
                (snd (BDDneg_2 (bs, (share, counter)) l n0))).
  apply bool_fun_eq_symm.  assumption.  rewrite H35.  rewrite H35 in H32.
  assumption.  apply Neqb_complete.  assumption.  apply
   bool_fun_eq_trans
    with
      (bf2 := bool_fun_of_BDD
                (fst
                   (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r
                      n0))
                (snd
                   (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r
                      n0))).
  apply bool_fun_preservation.  assumption.  assumption.  intros x0 l0 r0 a H33.  apply (proj2 (H27 a l0 r0 x0)).
  assumption.  assumption.  apply
   bool_fun_eq_trans
    with
      (bf2 := bool_fun_neg
                (bool_fun_of_BDD (fst (BDDneg_2 (bs, (share, counter)) l n0))
                   r)).
  assumption.  apply bool_fun_eq_neg_1.  apply bool_fun_preservation.  assumption.  
  assumption.  assumption.  assumption.  apply
   bool_fun_eq_trans
    with
      (bf2 := bool_fun_of_BDD
                (fst
                   (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r
                      n0)) (snd (BDDneg_2 (bs, (share, counter)) l n0))).
  apply bool_fun_preservation.  assumption.  assumption.  intros x0 l0 r0 a H32.  apply (proj2 (H27 a l0 r0 x0)).
  assumption.  assumption.  apply
   bool_fun_eq_trans
    with
      (bf2 := bool_fun_of_BDD (fst (BDDneg_2 (bs, (share, counter)) l n0))
                (snd (BDDneg_2 (bs, (share, counter)) l n0))).
  apply bool_fun_preservation.  assumption.  assumption.  assumption.  assumption.
  assumption.  assumption.  intro H30.  elim
   (sumbool_of_bool
      (Neqb (snd (BDDneg_2 (bs, (share, counter)) l n0))
         (snd (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r n0)))).
  intro y0.  cut
   (snd (BDDneg_2 (bs, (share, counter)) l n0) =
    snd (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r n0)).
  intro H31.  rewrite <- H31 in H19.  cut
   (bool_fun_eq
      (bool_fun_of_BDD (fst (BDDneg_2 (bs, (share, counter)) l n0))
         (snd (BDDneg_2 (bs, (share, counter)) l n0)))
      (bool_fun_neg
         (bool_fun_of_BDD (fst (BDDneg_2 (bs, (share, counter)) l n0)) r))).
  intro H32.  cut
   (bool_fun_eq
      (bool_fun_of_BDD (fst (BDDneg_2 (bs, (share, counter)) l n0))
         (snd (BDDneg_2 (bs, (share, counter)) l n0)))
      (bool_fun_neg (bool_fun_of_BDD (bs, (share, counter)) r))).
  intro H33.  cut (Neqb l r = true).  intro H34.  elim H1.  intros H35 H36.  elim H35; intros. 
  elim H38; intros.  cut (BDD_OK bs node).  unfold BDD_OK in |- *.  unfold BDDordered in |- *.
  rewrite y.  intro H41.  cut
   (node = BDDzero \/
    node = BDDone \/
    (exists x0 : BDDvar,
       (exists l0 : BDDvar,
          (exists r0 : BDDvar,
             MapGet _ bs node = Some (x0, (l0, r0)) /\
             BDDcompare x0 (ad_S x) = Datatypes.Lt /\
             Neqb l0 r0 = false /\
             BDDbounded bs l0 x0 /\ BDDbounded bs r0 x0)))).
  intro H42.  elim H42; intros.  rewrite H43 in y; rewrite y in H37; discriminate.
  elim H43.  intro H44.  rewrite H44 in y; rewrite y in H39; discriminate.  intro H44.
  elim H44; intros; elim H45; intros; elim H46; intros.  elim H47; intros; elim H48; intros; elim H49; intros.  elim H51; intros.  rewrite y in H48; injection H48.  intros H54 H55 H56.  rewrite <- H54 in H52.  rewrite <- H55 in H52.
  rewrite H34 in H52.  discriminate H52.  apply BDDbounded_lemma.  assumption.
  apply H40.  assumption.  cut (l = r).  intro H34.  rewrite H34; apply Neqb_correct.
  apply BDDunique with (cfg := (bs, (share, counter))).  assumption.  assumption.
  assumption.  apply bool_fun_eq_neg.  apply
   bool_fun_eq_trans
    with
      (bf2 := bool_fun_of_BDD (fst (BDDneg_2 (bs, (share, counter)) l n0))
                (snd (BDDneg_2 (bs, (share, counter)) l n0))).
  apply bool_fun_eq_symm.  assumption.  assumption.  apply
   bool_fun_eq_trans
    with
      (bf2 := bool_fun_neg
                (bool_fun_of_BDD (fst (BDDneg_2 (bs, (share, counter)) l n0))
                   r)).
  assumption.  apply bool_fun_eq_neg_1.  apply bool_fun_preservation.  assumption.
  assumption.  assumption.  assumption.  apply
   bool_fun_eq_trans
    with
      (bf2 := bool_fun_of_BDD
                (fst
                   (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r
                      n0))
                (snd
                   (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r
                      n0))).
  rewrite <- H31.  apply bool_fun_eq_symm.  apply bool_fun_preservation.  assumption.  
  assumption.  intros x0 l0 r0 a H32.  apply H16.  assumption.  assumption.  rewrite <- H31.
  assumption.  apply Neqb_complete.  assumption.  intro y0.  unfold is_internal_node, var in |- *.
  rewrite (H25 y0).  simpl in |- *.  rewrite y.  split.  split with x.
  split with (snd (BDDneg_2 (bs, (share, counter)) l n0)).  split
   with (snd (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r n0)).
  reflexivity.  reflexivity.  intros x0 l0 r0 a H29.  apply (proj2 (H27 a l0 r0 x0)).
  apply H16.  apply H9.  exact H29.  apply BDDmake_semantics.  assumption.
  assumption.  assumption.  assumption.  assumption.  intros xr lr rr H20.  elim H5.  intro H21.
  rewrite H21 in H19.  rewrite
   (proj1
      (bool_fun_of_BDD_semantics (fst (BDDneg_2 (bs, (share, counter)) l n0))
         H7)) in H19.
  rewrite bool_fun_neg_zero in H19.  rewrite H21 in H15.  rewrite <-
   (proj1
      (proj2
         (bool_fun_of_BDD_semantics
            (fst
               (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) BDDzero
                  n0)) H15))) in H19.
  cut
   (snd (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) BDDzero n0) =
    BDDone).
  intro H22.  rewrite H21 in H20.  rewrite H22 in H20.  rewrite
   (config_OK_one
      (fst (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) BDDzero n0))
      H15) in H20. 
  discriminate H20.  apply
   BDDunique
    with
      (cfg := fst
                (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0))
                   BDDzero n0)).
  assumption.  rewrite H21 in H18.  assumption.  right.  left.  reflexivity.
  assumption.  intro H21.  elim H21.  clear H21; intro.  rewrite H21 in H19.
  rewrite
   (proj1
      (proj2
         (bool_fun_of_BDD_semantics
            (fst (BDDneg_2 (bs, (share, counter)) l n0)) H7)))
    in H19.
  rewrite bool_fun_neg_one in H19.  rewrite H21 in H15.  rewrite <-
   (proj1
      (bool_fun_of_BDD_semantics
         (fst
            (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) BDDone n0))
         H15)) in H19.
  cut
   (snd (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) BDDone n0) =
    BDDzero).
  intro H22.  rewrite H21 in H20.  rewrite H22 in H20.  rewrite
   (config_OK_zero
      (fst (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) BDDone n0))
      H15) in H20.  
  discriminate H20.  apply
   BDDunique
    with
      (cfg := fst
                (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) BDDone
                   n0)).
  assumption.  rewrite H21 in H18.  assumption.  left; reflexivity.
  assumption.  intro H22.  unfold in_dom in H22.  elim
   (option_sum _ (MapGet (BDDvar * (ad * ad)) (fst (bs, (share, counter))) r)).
  intro y0.  elim y0; clear y0; intro x0.  elim x0; clear x0; intro y0; intro y1.
  elim y1; clear y1; intros y1 y2 y3.  cut (is_internal_node (fst (BDDneg_2 (bs, (share, counter)) l n0)) r).
  intro H23.  cut
   (var (fst (BDDneg_2 (bs, (share, counter)) l n0)) r =
    var (fst (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r n0))
      (snd (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r n0))).
  intro H24.  cut
   (var (bs, (share, counter)) r =
    var (fst (BDDneg_2 (bs, (share, counter)) l n0)) r).
  intro H25.  rewrite <- H25 in H24.  cut
   (BDDcompare
      (var (bs, (share, counter)) (high (bs, (share, counter)) node))
      (var (bs, (share, counter)) node) = Datatypes.Lt).
  unfold var, high, low in |- *.  simpl in |- *.  rewrite y.  simpl in y3.  rewrite y3.  unfold var in H24.
  simpl in H24.  rewrite y3 in H24.  rewrite H20 in H24.  rewrite H24.  trivial.
  apply BDDvar_ordered_high.  assumption.  unfold is_internal_node in |- *.
  split with x; split with l; split with r; assumption.  unfold high in |- *.  simpl in |- *; rewrite y.  split with y0; split with y1; split with y2; assumption.
  unfold var in |- *.  rewrite y3.  cut
   (MapGet (BDDvar * (ad * ad))
      (fst (fst (BDDneg_2 (bs, (share, counter)) l n0))) r =
    Some (y0, (y1, y2))).
  intro H25.  rewrite H25.  reflexivity.  apply H9.  assumption.  exact (proj2 (H17 H23)).
  unfold is_internal_node in |- *.  split with y0.  split with y1.  split with y2.  rewrite (H9 y0 y1 y2 r).
  reflexivity.  assumption.  intro y0.  rewrite y0 in H22; discriminate.  intros xl ll rl H20.
  elim (option_sum _ (MapGet _ (fst (bs, (share, counter))) l)).  intros y0.
  elim y0.  clear y0.  intro x0.  elim x0; clear x0; intro y0; intro y1.  elim y1; clear y1; intros y1 y2 y3.
  cut
   (is_internal_node (fst (BDDneg_2 (bs, (share, counter)) l n0))
      (snd (BDDneg_2 (bs, (share, counter)) l n0)) /\
    var (bs, (share, counter)) l =
    var (fst (BDDneg_2 (bs, (share, counter)) l n0))
      (snd (BDDneg_2 (bs, (share, counter)) l n0))).
  intros H21.  elim H21; clear H21; intros.  elim
   (option_sum _
      (MapGet _ (fst (fst (BDDneg_2 (bs, (share, counter)) l n0)))
         (snd (BDDneg_2 (bs, (share, counter)) l n0)))).
  intros y4.  elim y4; clear y4; intro x0.  elim x0; clear x0; intro y4; intro y5.  elim y5; clear y5; intros y5 y6 y7.
  unfold var in H22.  rewrite y3 in H22.  rewrite y7 in H22.
  cut
   (MapGet (BDDvar * (ad * ad))
      (fst (fst (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r n0)))
      (snd (BDDneg_2 (bs, (share, counter)) l n0)) =
    Some (y4, (y5, y6))).
  intros H23.  rewrite H20 in H23.  injection H23.  intros H24 H25 H26.  rewrite H26.  rewrite <- H22.
  cut
   (BDDcompare (var (bs, (share, counter)) (low (bs, (share, counter)) node))
      (var (bs, (share, counter)) node) = Datatypes.Lt).
  unfold var, high, low in |- *.  simpl in |- *.  rewrite y.  simpl in y3.  rewrite y3.  trivial. 
  apply BDDvar_ordered_low.  assumption.  unfold is_internal_node in |- *.  split with x; split with l; split with r.
  assumption.  unfold low, is_internal_node in |- *.  simpl in |- *.  rewrite y.  split with y0; split with y1; split with y2.
  exact y3.  apply H16.  assumption.  intro y4.  unfold is_internal_node in H21.
  rewrite y4 in H21.  inversion H21.  inversion H23.  inversion H24.  discriminate H25.
  apply H10.  unfold is_internal_node in |- *.  split with y0; split with y1; split with y2; assumption.
  intro y0.  elim H6.  intro H21.  cut (snd (BDDneg_2 (bs, (share, counter)) l n0) = BDDone).
  intro H22.  rewrite H22 in H20.  unfold BDDconfig_OK in H15.  cut
   (MapGet _
      (fst (fst (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r n0)))
      BDDone = None).
  intros H23.  rewrite H23 in H20.  discriminate H20.  apply config_OK_one.  assumption.
  apply BDDunique with (cfg := fst (BDDneg_2 (bs, (share, counter)) l n0)).  assumption.
  assumption.  right; left; reflexivity.  rewrite
   (proj1
      (proj2
         (bool_fun_of_BDD_semantics
            (fst (BDDneg_2 (bs, (share, counter)) l n0)) H7)))
   .
  rewrite <- bool_fun_neg_zero.  rewrite <- (proj1 (bool_fun_of_BDD_semantics (bs, (share, counter)) H1)).
  rewrite <- H21; exact H12.  intro H21.  elim H21; clear H21.  intro H21.
  cut (snd (BDDneg_2 (bs, (share, counter)) l n0) = BDDzero).  intro H22.  rewrite H22 in H20.
  unfold BDDconfig_OK in H15.  cut
   (MapGet _
      (fst (fst (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l n0)) r n0)))
      BDDzero = None).
  intros H23.  rewrite H23 in H20.  discriminate H20.  apply config_OK_zero.  assumption.
  apply BDDunique with (cfg := fst (BDDneg_2 (bs, (share, counter)) l n0)).  assumption.
  assumption.  left; reflexivity.  rewrite
   (proj1
      (bool_fun_of_BDD_semantics (fst (BDDneg_2 (bs, (share, counter)) l n0))
         H7)).
  rewrite <- bool_fun_neg_one.  rewrite <-
   (proj1 (proj2 (bool_fun_of_BDD_semantics (bs, (share, counter)) H1)))
   .
  rewrite <- H21; exact H12.  unfold in_dom in |- *.  rewrite y0.  intro; discriminate.
  assumption.  elim H11.  intro H20.  rewrite H20.  left; reflexivity.  intro H20.
  elim H20; intro.  rewrite H21; right; left; reflexivity. 
  elim
   (option_sum _
      (MapGet _ (fst (fst (BDDneg_2 (bs, (share, counter)) l n0)))
         (snd (BDDneg_2 (bs, (share, counter)) l n0)))).
  intro y0.  elim y0; clear y0; intro x0.  elim x0; clear x0; intro y0; intro y1.  elim y1; clear y1; intros y1 y2 y3.
  right.  right.  unfold in_dom in |- *.  rewrite (H16 y0 y1 y2 (snd (BDDneg_2 (bs, (share, counter)) l n0))).
  reflexivity.  assumption.  intro y0.  unfold in_dom in H21.  rewrite y0 in H21; discriminate.
  apply H0.  unfold lt in |- *.  apply le_n.  assumption.  assumption.  assumption.  intro H13.
  apply lt_trans_1 with (y := nat_of_N (var (bs, (share, counter)) node)).
  apply BDDcompare_lt.  cut
   (BDDcompare
      (var (bs, (share, counter)) (high (bs, (share, counter)) node))
      (var (bs, (share, counter)) node) = Datatypes.Lt).
  cut
   (var (bs, (share, counter)) r =
    var (fst (BDDneg_2 (bs, (share, counter)) l n0)) r).
  intro H14.  unfold high in |- *.  simpl in |- *.  rewrite y.  rewrite H14.  trivial.  unfold is_internal_node in H13.
  inversion H13.  inversion H14.  inversion H15.  elim H5.  intro H17.  rewrite H17 in H16.
  rewrite (config_OK_zero (fst (BDDneg_2 (bs, (share, counter)) l n0)))
    in H16.  discriminate H16.
  assumption.  intro H17.  elim H17; intro.  rewrite H18 in H16.  rewrite (config_OK_one (fst (BDDneg_2 (bs, (share, counter)) l n0))) in H16.
  discriminate H16.  assumption.  elim (option_sum _ (MapGet _ (fst (bs, (share, counter))) r)).
  intro y0.  elim y0; clear y0; intro x3.  elim x3; clear x3; intro y0.  intro y1.
  elim y1; clear y1; intros y1 y2 y3.  unfold var in |- *.  rewrite y3.  rewrite (H9 y0 y1 y2 r).
  reflexivity.  assumption.  intro y0.  unfold in_dom in H18.  rewrite y0 in H18; discriminate.
  apply BDDvar_ordered_high.  assumption.  unfold is_internal_node in |- *.  split with x; split with l; split with r; assumption.
  unfold high in |- *.  simpl in |- *.  rewrite y.  unfold is_internal_node in H13.  inversion H13; inversion H14; inversion H15.
  elim H5; intro.  rewrite H17 in H16.  rewrite (config_OK_zero (fst (BDDneg_2 (bs, (share, counter)) l n0)))
    in H16.
  discriminate H16.  assumption.  elim H17; intro.  rewrite H18 in H16.  rewrite (config_OK_one (fst (BDDneg_2 (bs, (share, counter)) l n0))) in H16.
  discriminate H16.  assumption.  unfold in_dom in H18.  unfold is_internal_node in |- *.
  elim
   (option_sum _ (MapGet (BDDvar * (ad * ad)) (fst (bs, (share, counter))) r)).  intros y0.
  elim y0; intro x3.  elim x3; intro y1; intro y2.  elim y2; intros y3 y4 y5.  split with y1; split with y3; split with y4; assumption.
  intro y0.  rewrite y0 in H18; discriminate.  apply H3.  unfold is_internal_node in |- *.
  split with x; split with l; split with r; exact y.  elim H5; intro.  rewrite H13; left; reflexivity.
  elim H13; intro.  rewrite H14; right; left; reflexivity.  unfold in_dom in H14.
  elim
   (option_sum _ (MapGet (BDDvar * (ad * ad)) (fst (bs, (share, counter))) r)).  intro y0.
  elim y0; intro x0.  elim x0; intro y1; intro y2.  elim y2; intros y3 y4 y5.  right; right.
  unfold in_dom in |- *.  rewrite (H9 y1 y3 y4 r y5).  reflexivity.  intro y0.  rewrite y0 in H14; discriminate.
  apply H0.  unfold lt in |- *.  apply le_n.  assumption.  assumption.  intro H7.  apply lt_trans_1 with (y := nat_of_N (var (bs, (share, counter)) node)).
  cut
   (nat_of_N (var (bs, (share, counter)) (low (bs, (share, counter)) node)) <
    nat_of_N (var (bs, (share, counter)) node)).
  unfold low in |- *.  simpl in |- *.  rewrite y.  trivial.  apply BDDcompare_lt.  apply BDDvar_ordered_low.
  assumption.  unfold is_internal_node in |- *.  split with x; split with l; split with r; exact y.
  unfold low in |- *.  simpl in |- *; rewrite y; assumption.  apply H3.  unfold is_internal_node in |- *.
  split with x; split with l; split with r; assumption.  intro H7.  apply lt_trans_1 with (y := nat_of_N (var (bs, (share, counter)) node)).
  cut
   (nat_of_N (var (bs, (share, counter)) (low (bs, (share, counter)) node)) <
    nat_of_N (var (bs, (share, counter)) node)).
  unfold low in |- *.  simpl in |- *.  rewrite y.  trivial.  apply BDDcompare_lt.  apply BDDvar_ordered_low.
  assumption.  unfold is_internal_node in |- *.  split with x; split with l; split with r; exact y.
  unfold low in |- *.  simpl in |- *; rewrite y; assumption.  apply H3.  unfold is_internal_node in |- *.
  split with x; split with l; split with r; assumption.  elim H1.  intros H5 H6.  elim H5.
  intros H7 H8.  cut (BDD_OK bs node).  unfold BDD_OK in |- *.  unfold BDDordered in |- *.  simpl in y.  rewrite y.
  intro H9.  cut
   (node = BDDzero \/
    node = BDDone \/
    (exists x0 : BDDvar,
       (exists l0 : BDDvar,
          (exists r0 : BDDvar,
             MapGet _ bs node = Some (x0, (l0, r0)) /\
             BDDcompare x0 (ad_S x) = Datatypes.Lt /\
             Neqb l0 r0 = false /\
             BDDbounded bs l0 x0 /\ BDDbounded bs r0 x0)))).
  intro H10.  elim H10; intro.  rewrite H11 in y; rewrite y in H7; discriminate.
  elim H11; intro.  rewrite H12 in y; rewrite (proj1 H8) in y; discriminate.  
  inversion H12.  inversion H13.  inversion H14.  inversion H15.  rewrite y in H16.
  injection H16.  intros H18 H19 H20.  rewrite <- H18 in H17.  rewrite <- H19 in H17.  unfold config_node_OK in |- *.  apply BDDbounded_node_OK with (n := x0).
  exact (proj2 (proj2 (proj2 H17))).  apply BDDbounded_lemma.  assumption.
  apply (proj2 H8).  unfold in_dom in |- *.  simpl in y.  rewrite y.  reflexivity.  elim H1.  intros H5 H6.
  elim H5.  intros H7 H8.  cut (BDD_OK bs node).  unfold BDD_OK in |- *.  unfold BDDordered in |- *.
  simpl in y.  rewrite y.  intro H9.  cut
   (node = BDDzero \/
    node = BDDone \/
    (exists x0 : BDDvar,
       (exists l0 : BDDvar,
          (exists r0 : BDDvar,
             MapGet _ bs node = Some (x0, (l0, r0)) /\
             BDDcompare x0 (ad_S x) = Datatypes.Lt /\
             Neqb l0 r0 = false /\
             BDDbounded bs l0 x0 /\ BDDbounded bs r0 x0)))).
  intro H10.  elim H10; intro.  rewrite H11 in y; rewrite y in H7; discriminate.
  elim H11; intro.  rewrite H12 in y; rewrite (proj1 H8) in y; discriminate.  
  inversion H12.  inversion H13.  inversion H14.  inversion H15.  rewrite y in H16.
  injection H16.  intros H18 H19 H20.  rewrite <- H18 in H17.  rewrite <- H19 in H17.  unfold config_node_OK in |- *.
  apply BDDbounded_node_OK with (n := x0).  exact (proj1 (proj2 (proj2 H17))).
  apply BDDbounded_lemma.  assumption.  apply (proj2 H8).  unfold in_dom in |- *.
  simpl in y.  rewrite y.  reflexivity.  intro y.  unfold in_dom in H4.  rewrite y in H4.
  discriminate H4.
Qed.
