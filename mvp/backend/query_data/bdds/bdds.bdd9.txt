
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import ZArith NArith Nnat Ndec Ndigits.
From IntMap Require Import Allmaps.
Require Import Wf_nat.

Require Import BDDvar_ad_nat.
(* BDDvar_ad_nat:
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import ZArith NArith Nnat Ndec Ndigits.
From IntMap Require Import Allmaps.
Definition BDDzero := N0.
Definition BDDone := Npos 1.

  Definition BDDvar := ad.

  Definition BDDcompare (x y : BDDvar) :=
    match x, y with
    | N0, N0 => Datatypes.Eq
    | N0, Npos _ => Datatypes.Lt
    | Npos _, N0 => Datatypes.Gt
    | Npos p1, Npos p2 => Pcompare p1 p2 Datatypes.Eq
    end.

Definition BDDvar_eq := Neqb.

  Definition ad_S (a : ad) :=
    match a with
    | N0 => Npos 1
    | Npos p => Npos (Psucc p)
    end.

  Lemma ad_S_is_S : forall a : ad, nat_of_N (ad_S a) = S (nat_of_N a).

Lemma lt_pred : forall x y : nat, x < y -> x <> 0 -> pred x < pred y.

Lemma O_N0 : forall x : ad, nat_of_N x = 0 -> x = N0.
Lemma INFERIEUR_neq_O :
 forall x y : ad, BDDcompare x y = Datatypes.Lt -> y <> N0.

 Lemma BDDcompare_trans :
  forall x y z : BDDvar,
  BDDcompare x y = Datatypes.Lt ->

  Lemma ad_S_le_then_le :
   forall x y : ad, Nleb (ad_S x) y = true -> Nleb x y = true.

  Lemma le_then_le_S :
   forall x y : ad, Nleb x y = true -> Nleb x (ad_S y) = true.

  Lemma ad_S_le_then_neq :
   forall x y : ad, Nleb (ad_S x) y = true -> Neqb x y = false.

  Lemma BDDcompare_succ :
   forall a : BDDvar, BDDcompare a (ad_S a) = Datatypes.Lt.

  Lemma BDDcompare_lt :
   forall x y : BDDvar,
   BDDcompare x y = Datatypes.Lt -> nat_of_N x < nat_of_N y.

Lemma BDDlt_compare :
 forall x y : BDDvar,
 nat_of_N x < nat_of_N y -> BDDcompare x y = Datatypes.Lt.

Lemma relation_sum :
 forall r : Datatypes.comparison,

Lemma BDD_EGAL_complete :
 forall x y : BDDvar, BDDcompare x y = Datatypes.Eq -> x = y.

  Lemma lt_trans_1 : forall x y z : nat, x < y -> y < S z -> x < z.

Lemma BDDcompare_sup_inf :
 forall x y : BDDvar,
 BDDcompare x y = Datatypes.Gt -> BDDcompare y x = Datatypes.Lt.

  Lemma BDDcompare_1 :
   forall x y : BDDvar,
   BDDcompare x y = Datatypes.Lt ->

Definition max (m n : nat) := if leb m n then n else m.

Lemma lt_max_1_2 :
 forall x1 y1 x2 y2 : nat, x1 < x2 -> y1 < y2 -> max x1 y1 < max x2 y2.

Lemma lt_max_2 :
 forall x1 y1 x2 y2 : nat, x1 < y2 -> y1 < y2 -> max x1 y1 < max x2 y2.

Lemma lt_max_12 :
 forall x1 y1 x2 y2 : nat, x1 < x2 -> y1 < x2 -> max x1 y1 < max x2 y2.

Lemma BDDcompare_eq :
 forall x y : BDDvar, BDDcompare x y = Datatypes.Eq -> x = y. *)
Require Import bdd1.
(* bdd1:
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import ZArith NArith Nnat Ndec Ndigits.
From IntMap Require Import Allmaps.
Require Import Wf_nat.

Require Import BDDvar_ad_nat.

  Definition BDDstate := Map (BDDvar * (ad * ad)).
	  Definition initBDDstate := newMap (BDDvar * (ad * ad)).

  Inductive BDDbounded (bs : BDDstate) : ad -> BDDvar -> Prop :=
    | BDDbounded_0 : forall n : BDDvar, BDDbounded bs BDDzero n
    | BDDbounded_1 : forall n : BDDvar, BDDbounded bs BDDone n
    | BDDbounded_2 :
        forall (node : ad) (n x : BDDvar) (l r : ad),
        MapGet _ bs node = Some (x, (l, r)) ->
        BDDcompare x n = Datatypes.Lt ->
        Neqb l r = false ->
        BDDbounded bs l x -> BDDbounded bs r x -> BDDbounded bs node n.

  Lemma BDDbounded_lemma :
   forall (bs : BDDstate) (node : ad) (n : BDDvar),
   BDDbounded bs node n ->
   node = BDDzero \/
   node = BDDone \/
   (exists x : BDDvar,
      (exists l : BDDvar,
         (exists r : BDDvar,
            MapGet _ bs node = Some (x, (l, r)) /\
            BDDcompare x n = Datatypes.Lt /\

  Lemma increase_bound :
   forall (bs : BDDstate) (n n' : BDDvar) (node : ad),
   BDDbounded bs node n ->
   BDDcompare n n' = Datatypes.Lt -> BDDbounded bs node n'.

  Lemma boundedness_preservation :
   forall bs bs' : BDDstate,
   (forall (a l r : ad) (x : BDDvar),
    MapGet _ bs a = Some (x, (l, r)) -> MapGet _ bs' a = Some (x, (l, r))) ->
   forall (n : BDDvar) (node : ad),
   BDDbounded bs node n -> BDDbounded bs' node n.

  Definition BDDordered (bs : BDDstate) (node : ad) :=
    match MapGet _ bs node with
    | None => True
    | Some (n, _) => BDDbounded bs node (ad_S n)
    end.

  Definition BDD_OK (bs : BDDstate) (node : ad) := BDDordered bs node.

  Definition BDDstate_OK (bs : BDDstate) :=
    MapGet _ bs BDDzero = None /\
    MapGet _ bs BDDone = None /\
    (forall a : ad, in_dom _ a bs = true -> BDD_OK bs a).

  Lemma initBDDstate_OK : BDDstate_OK initBDDstate.

  Definition BDDsharing_map := Map (Map (Map ad)).
	  Definition initBDDsharing_map := newMap (Map (Map ad)).

  Definition BDDshare_lookup (share : BDDsharing_map) 
    (x : BDDvar) (l r : ad) : option ad :=
    match MapGet _ share l with
    | None => None
    | Some m1 =>
        match MapGet _ m1 r with
        | None => None
        | Some m2 =>
            match MapGet _ m2 x with
            | None => None
            | Some y => Some y
            end
        end
    end.

  Definition BDDshare_put (share : BDDsharing_map) 
    (x : BDDvar) (l r counter : ad) : BDDsharing_map :=
    let m1 :=
      match MapGet _ share l with
      | Some y => y
      | None => newMap (Map ad)
      end in
    let m2 :=
      match MapGet _ m1 r with
      | Some y => y
      | None => newMap ad
      end in
    let m2' := MapPut _ m2 x counter in
    let m1' := MapPut _ m1 r m2' in MapPut _ share l m1'.

  Lemma BDDshare_put_puts :
   forall (share : BDDsharing_map) (x : BDDvar) (l r counter : ad),
   BDDshare_lookup (BDDshare_put share x l r counter) x l r = Some counter.

  Lemma BDDshare_put_no_new_node :
   forall (share : BDDsharing_map) (x x' : BDDvar)
     (l l' r r' counter counter' : ad),
   BDDshare_lookup (BDDshare_put share x l r counter) x' l' r' =
   Some counter' ->
   BDDshare_lookup share x' l' r' = Some counter' \/
   (x, (l, r)) = (x', (l', r')).

  Lemma BDDshare_put_preserves_nodes :
   forall (share : BDDsharing_map) (x x' : BDDvar)
     (l l' r r' counter counter' : ad),
   BDDshare_lookup share x' l' r' = Some counter' ->
   (x, (l, r)) <> (x', (l', r')) ->
   BDDshare_lookup (BDDshare_put share x l r counter) x' l' r' =
   Some counter'.

  Definition BDDsharing_OK (bs : BDDstate) (share : BDDsharing_map) :=
    forall (x : BDDvar) (l r a : ad),
    BDDshare_lookup share x l r = Some a <->
    MapGet _ bs a = Some (x, (l, r)).

  Lemma initBDDsharing_map_OK : BDDsharing_OK initBDDstate initBDDsharing_map.

  Definition BDDconfig := (BDDstate * (BDDsharing_map * ad))%type.

  Definition initBDDconfig :=
    (initBDDstate, (initBDDsharing_map, ad_S (ad_S N0))).

  Definition BDDconfig_OK (cfg : BDDconfig) :=
    match cfg return Prop with
    | (bs, (share, counter)) =>
        BDDstate_OK bs /\
        BDDsharing_OK bs share /\
        (forall a : ad, Nleb counter a = true -> MapGet _ bs a = None) /\
        Nleb (ad_S (ad_S N0)) counter = true
    end.

  Lemma initBDDconfig_OK : BDDconfig_OK initBDDconfig.

  Lemma config_OK_zero :
   forall cfg : BDDconfig,
   BDDconfig_OK cfg -> MapGet _ (fst cfg) BDDzero = None.

  Lemma config_OK_one :
   forall cfg : BDDconfig,
   BDDconfig_OK cfg -> MapGet _ (fst cfg) BDDone = None.

  Definition BDDalloc (cfg : BDDconfig) (x : BDDvar) 
    (l r : ad) :=
    match cfg with
    | (bs, (share, counter)) =>
        let share' := BDDshare_put share x l r counter in
        let bs' := MapPut _ bs counter (x, (l, r)) in
        let counter' := ad_S counter in (bs', (share', counter'), counter)
    end.

  Lemma BDDsharing_lookup_semantics :
   forall (bs : BDDstate) (share : BDDsharing_map) (n l r : ad) (x : BDDvar),
   BDDsharing_OK bs share ->
   (BDDshare_lookup share x l r = Some n <->
    MapGet _ bs n = Some (x, (l, r))).

  Definition node_OK (bs : BDDstate) (node : ad) :=
    node = BDDzero \/ node = BDDone \/ in_dom _ node bs = true.

  Lemma BDDbounded_node_OK :
   forall (bs : BDDstate) (node : ad) (n : BDDvar),
   BDDbounded bs node n -> node_OK bs node.

  Lemma BDDalloc_allocates :
   forall (cfg : BDDconfig) (l r : ad) (x : BDDvar),
   MapGet _ (fst (fst (BDDalloc cfg x l r))) (snd (BDDalloc cfg x l r)) =
   Some (x, (l, r)).

  Lemma BDDalloc_preserves_nodes :
   forall (cfg : BDDconfig) (l r : ad) (x : BDDvar),
   BDDconfig_OK cfg ->
   forall (a l1 r1 : ad) (x1 : BDDvar),
   MapGet _ (fst cfg) a = Some (x1, (l1, r1)) ->
   MapGet _ (fst (fst (BDDalloc cfg x l r))) a = Some (x1, (l1, r1)).

  Lemma BDDalloc_no_new_node :
   forall (cfg : BDDconfig) (l l1 r r1 a : ad) (x x1 : BDDvar),
   MapGet _ (fst (fst (BDDalloc cfg x l r))) a = Some (x1, (l1, r1)) ->
   a = snd (snd cfg) \/ MapGet _ (fst cfg) a = Some (x1, (l1, r1)).

  Lemma BDDalloc_no_new_node_1 :
   forall (cfg : BDDconfig) (l l1 r r1 a : ad) (x x1 : BDDvar),
   MapGet _ (fst (fst (BDDalloc cfg x l r))) a = Some (x1, (l1, r1)) ->
   (x1, (l1, r1)) = (x, (l, r)) \/
   MapGet _ (fst cfg) a = Some (x1, (l1, r1)).

  Lemma BDDalloc_preserves_zero :
   forall (cfg : BDDconfig) (l r : ad) (x : BDDvar),
   BDDconfig_OK cfg ->
   MapGet _ (fst (fst (BDDalloc cfg x l r))) BDDzero = None.

  Lemma BDDalloc_preserves_one :
   forall (cfg : BDDconfig) (l r : ad) (x : BDDvar),
   BDDconfig_OK cfg ->
   MapGet _ (fst (fst (BDDalloc cfg x l r))) BDDone = None.

  Lemma BDDalloc_keeps_state_OK :
   forall (cfg : BDDconfig) (l r : ad) (x : BDDvar),
   BDDconfig_OK cfg ->
   node_OK (fst cfg) l ->
   node_OK (fst cfg) r ->
   Neqb l r <> true ->
   (forall (xl : BDDvar) (ll rl : ad),
    MapGet _ (fst cfg) l = Some (xl, (ll, rl)) ->
    BDDcompare xl x = Datatypes.Lt) ->

  Lemma BDDalloc_adjusts_counter :
   forall (cfg : BDDconfig) (x : BDDvar) (l r a : ad),
   BDDconfig_OK cfg ->
   (forall a : ad,
    Nleb (snd (snd (fst (BDDalloc cfg x l r)))) a = true ->
    MapGet _ (fst (fst (BDDalloc cfg x l r))) a = None) /\
   Nleb (ad_S (ad_S N0)) (snd (snd (fst (BDDalloc cfg x l r)))) = true.

Lemma BDDalloc_keeps_sharing_OK :
 forall (cfg : BDDconfig) (l r : ad) (x : BDDvar),
 BDDconfig_OK cfg ->
 node_OK (fst cfg) l ->
 node_OK (fst cfg) r ->
 (forall (x' : BDDvar) (l' r' a : ad),
  MapGet _ (fst cfg) a = Some (x', (l', r')) ->
  (x, (l, r)) <> (x', (l', r'))) ->
 BDDsharing_OK (fst (fst (BDDalloc cfg x l r)))
   (fst (snd (fst (BDDalloc cfg x l r)))).

  Lemma BDDalloc_semantics :
   forall (cfg : BDDconfig) (l r : ad) (x : BDDvar),
   BDDconfig_OK cfg ->
   node_OK (fst cfg) l ->
   node_OK (fst cfg) r ->
   Neqb l r <> true ->
   (forall (xl : BDDvar) (ll rl : ad),
    MapGet _ (fst cfg) l = Some (xl, (ll, rl)) ->
    BDDcompare xl x = Datatypes.Lt) ->

  Definition BDDmake (cfg : BDDconfig) (x : BDDvar) 
    (l r : ad) :=
    if Neqb l r
    then (cfg, l)
    else
     match cfg with
     | (bs, (share, counter)) =>
         match BDDshare_lookup share x l r with
         | Some y => (cfg, y)
         | None => BDDalloc cfg x l r
         end
     end.

  Lemma BDDmake_semantics :
   forall (cfg : BDDconfig) (l r : ad) (x : BDDvar),
   BDDconfig_OK cfg ->
   node_OK (fst cfg) l ->
   node_OK (fst cfg) r ->
   (forall (xl : BDDvar) (ll rl : ad),
    MapGet _ (fst cfg) l = Some (xl, (ll, rl)) ->
    BDDcompare xl x = Datatypes.Lt) -> *)
Require Import bdd2.
(* bdd2:
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import ZArith NArith Nnat Ndec Ndigits.
From IntMap Require Import Allmaps.
Require Import Wf_nat.

Require Import BDDvar_ad_nat.
Require Import bdd1.

Definition var (cfg : BDDconfig) (node : ad) :=
  match MapGet _ (fst cfg) node with
  | None =>   BDDzero
  | Some (x, (l, r)) => x
  end.

Definition low (cfg : BDDconfig) (node : ad) :=
  match MapGet _ (fst cfg) node with
  | None =>   N0
  | Some (x, (l, r)) => l
  end.

Definition high (cfg : BDDconfig) (node : ad) :=
  match MapGet _ (fst cfg) node with
  | None =>   N0
  | Some (x, (l, r)) => r
  end.

Definition config_node_OK (cfg : BDDconfig) := node_OK (fst cfg).
Definition is_internal_node (cfg : BDDconfig) (node : ad) :=
  exists x : BDDvar,
    (exists l : ad,
       (exists r : ad, MapGet _ (fst cfg) node = Some (x, (l, r)))).

Lemma BDDvar_ordered_low :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node ->
 is_internal_node cfg (low cfg node) ->
 BDDcompare (var cfg (low cfg node)) (var cfg node) = Datatypes.Lt.

Lemma BDDvar_ordered_high :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node ->
 is_internal_node cfg (high cfg node) ->
 BDDcompare (var cfg (high cfg node)) (var cfg node) = Datatypes.Lt.

Definition var_binding := BDDvar -> bool.
 
Definition bool_fun := var_binding -> bool.

Definition bool_fun_eval (bf : bool_fun) (vb : var_binding) := bf vb.

Definition bool_fun_zero (vb : var_binding) := false. 
Definition bool_fun_one (vb : var_binding) := true. 

Fixpoint bool_fun_of_BDD_1 (cfg : BDDconfig) (node : ad) 
 (bound : nat) {struct bound} : bool_fun :=
  match MapGet _ (fst cfg) node with
  | None => if Neqb node BDDzero then bool_fun_zero else bool_fun_one
  | Some (x, (l, r)) =>
      match bound with
      | O =>   bool_fun_zero
      | S bound' =>
          let bfl := bool_fun_of_BDD_1 cfg l bound' in
          let bfr := bool_fun_of_BDD_1 cfg r bound' in
          fun vb : var_binding => if vb x then bfr vb else bfl vb
      end
  end.

Lemma bool_fun_of_BDD_1_semantics :
 forall cfg : BDDconfig,
 BDDconfig_OK cfg ->
 forall bound : nat,
 bool_fun_of_BDD_1 cfg BDDzero bound = bool_fun_zero /\
 bool_fun_of_BDD_1 cfg BDDone bound = bool_fun_one /\
 (forall node : ad,
  is_internal_node cfg node ->
  nat_of_N (var cfg node) < bound ->
  forall vb : var_binding,
  (vb (var cfg node) = true ->
   bool_fun_eval (bool_fun_of_BDD_1 cfg node bound) vb =
   bool_fun_eval (bool_fun_of_BDD_1 cfg (high cfg node) (pred bound)) vb) /\
  (vb (var cfg node) = false ->
   bool_fun_eval (bool_fun_of_BDD_1 cfg node bound) vb =
   bool_fun_eval (bool_fun_of_BDD_1 cfg (low cfg node) (pred bound)) vb)).

Lemma bool_fun_of_BDD_1_semantics_1 :
 forall cfg : BDDconfig,
 BDDconfig_OK cfg ->
 forall bound : nat,
 bool_fun_of_BDD_1 cfg BDDzero bound = bool_fun_zero /\
 bool_fun_of_BDD_1 cfg BDDone bound = bool_fun_one /\
 (forall node : ad,
  is_internal_node cfg node ->
  nat_of_N (var cfg node) < bound ->
  bool_fun_of_BDD_1 cfg node bound =
  (fun vb : var_binding =>
   if vb (var cfg node)
   then bool_fun_of_BDD_1 cfg (high cfg node) (pred bound) vb
   else bool_fun_of_BDD_1 cfg (low cfg node) (pred bound) vb)).

Lemma bool_fun_of_BDD_1_semantics_2 :
 forall (cfg : BDDconfig) (node : ad) (bound1 bound2 : nat),
 MapGet _ (fst cfg) node = None ->
 bool_fun_of_BDD_1 cfg node bound1 = bool_fun_of_BDD_1 cfg node bound2.

Lemma bool_fun_of_BDD_1_change_bound :
 forall cfg : BDDconfig,
 BDDconfig_OK cfg ->
 forall (bound : nat) (node : ad),
 nat_of_N (var cfg node) < bound ->
 bool_fun_of_BDD_1 cfg node bound =
 bool_fun_of_BDD_1 cfg node (S (nat_of_N (var cfg node))).

Definition bool_fun_of_BDD (cfg : BDDconfig) (node : ad) :=
  bool_fun_of_BDD_1 cfg node (S (nat_of_N (var cfg node))).

Lemma bool_fun_of_BDD_semantics :
 forall cfg : BDDconfig,
 BDDconfig_OK cfg ->
 bool_fun_of_BDD cfg BDDzero = bool_fun_zero /\
 bool_fun_of_BDD cfg BDDone = bool_fun_one /\
 (forall node : ad,
  is_internal_node cfg node ->
  bool_fun_of_BDD cfg node =
  (fun vb : var_binding =>
   if vb (var cfg node)
   then bool_fun_of_BDD cfg (high cfg node) vb
   else bool_fun_of_BDD cfg (low cfg node) vb)).

Definition bool_fun_eq (bf1 bf2 : bool_fun) :=
  forall vb : var_binding, bool_fun_eval bf1 vb = bool_fun_eval bf2 vb.

Lemma bool_fun_eq_symm :
 forall bf1 bf2 : bool_fun, bool_fun_eq bf1 bf2 -> bool_fun_eq bf2 bf1.

Lemma bool_fun_eq_trans :
 forall bf1 bf2 bf3 : bool_fun,
 bool_fun_eq bf1 bf2 -> bool_fun_eq bf2 bf3 -> bool_fun_eq bf1 bf3.

Definition bool_fun_neg (bf : bool_fun) : bool_fun :=
  fun vb : var_binding => negb (bf vb).
Definition bool_fun_or (bf1 bf2 : bool_fun) : bool_fun :=
  fun vb : var_binding => bf1 vb || bf2 vb.

Lemma bool_fun_neg_semantics :
 forall (bf : bool_fun) (vb : var_binding),
 (bool_fun_eval bf vb = true -> bool_fun_eval (bool_fun_neg bf) vb = false) /\
 (bool_fun_eval bf vb = false -> bool_fun_eval (bool_fun_neg bf) vb = true).

Lemma bool_fun_neg_zero : bool_fun_neg bool_fun_zero = bool_fun_one.

Lemma bool_fun_neg_one : bool_fun_neg bool_fun_one = bool_fun_zero.

Lemma bool_fun_eq_neg :
 forall bf1 bf2 : bool_fun,
 bool_fun_eq (bool_fun_neg bf1) (bool_fun_neg bf2) -> bool_fun_eq bf1 bf2.

Lemma bool_fun_eq_neg_1 :
 forall bf1 bf2 : bool_fun,
 bool_fun_eq bf1 bf2 -> bool_fun_eq (bool_fun_neg bf1) (bool_fun_neg bf2).

Definition BDDneg_memo := Map ad.
Definition BDDneg_memo_lookup (memo : BDDneg_memo) 
  (a : ad) := MapGet _ memo a.
Definition BDDneg_memo_put (memo : BDDneg_memo) (a node : ad) :=
  MapPut _ memo a node.

Definition BDDneg_memo_OK (cfg : BDDconfig) (memo : BDDneg_memo) :=
  forall a node : ad,
  BDDneg_memo_lookup memo a = Some node ->
  config_node_OK cfg node /\
  bool_fun_of_BDD cfg node = bool_fun_neg (bool_fun_of_BDD cfg a) /\
  var cfg a = var cfg node. 

Fixpoint BDDneg_2 (cfg : BDDconfig) (node : ad) (bound : nat) {struct bound} 
   : BDDconfig * ad :=
  match MapGet _ (fst cfg) node with
  | None => if Neqb node BDDzero then (cfg, BDDone) else (cfg, BDDzero)
  | Some (x, (l, r)) =>
      match bound with
      | O =>   (initBDDconfig, BDDzero)
      | S bound' =>
          BDDmake (fst (BDDneg_2 (fst (BDDneg_2 cfg l bound')) r bound')) x
            (snd (BDDneg_2 cfg l bound'))
            (snd (BDDneg_2 (fst (BDDneg_2 cfg l bound')) r bound'))
      end
  end. *)
Require Import bdd3.
(* bdd3:
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import ZArith NArith Nnat Ndec Ndigits.
From IntMap Require Import Allmaps.
Require Import Wf_nat.

Require Import BDDvar_ad_nat.
Require Import bdd1.
Require Import bdd2.

Lemma bool_fun_one_zero_eq : ~ bool_fun_eq bool_fun_one bool_fun_zero.

Lemma bool_fun_zero_one_eq : ~ bool_fun_eq bool_fun_zero bool_fun_one.

Definition augment (vb : var_binding) (x : BDDvar) 
  (b : bool) (y : BDDvar) := if BDDvar_eq x y then b else vb y.

Definition bool_fun_restrict (bf : bool_fun) (x : BDDvar) 
  (b : bool) (vb : var_binding) := bool_fun_eval bf (augment vb x b).

Lemma bool_fun_restrict_zero :
 forall (x : BDDvar) (b : bool),
 bool_fun_eq (bool_fun_restrict bool_fun_zero x b) bool_fun_zero. 

Lemma bool_fun_restrict_one :
 forall (x : BDDvar) (b : bool),
 bool_fun_eq (bool_fun_restrict bool_fun_one x b) bool_fun_one.

Lemma bool_fun_restrict_eq :
 forall (bf bf' : bool_fun) (x : BDDvar) (b : bool),
 bool_fun_eq bf bf' ->
 bool_fun_eq (bool_fun_restrict bf x b) (bool_fun_restrict bf' x b).

Definition var_binding_eq (vb vb' : var_binding) :=
  forall x : BDDvar, vb x = vb' x.

Definition bool_fun_ext (bf : bool_fun) :=
  forall vb vb' : var_binding,
  var_binding_eq vb vb' -> bool_fun_eval bf vb = bool_fun_eval bf vb'.

Lemma bool_fun_of_BDD_1_ext :
 forall (bound : nat) (cfg : BDDconfig) (node : ad),
 bool_fun_ext (bool_fun_of_BDD_1 cfg node bound). 

Lemma bool_fun_of_BDD_ext :
 forall (cfg : BDDconfig) (node : ad),
 bool_fun_ext (bool_fun_of_BDD cfg node).

Lemma augment_eq :
 forall (vb : var_binding) (x : BDDvar) (b : bool),
 vb x = b -> var_binding_eq (augment vb x b) vb.

Definition bool_fun_independent (bf : bool_fun) (x : BDDvar) :=
  forall vb : var_binding,
  bool_fun_eval bf (augment vb x true) =
  bool_fun_eval bf (augment vb x false).

Lemma bool_fun_independent_lemma :
 forall (bf : bool_fun) (x : BDDvar) (vb : var_binding) (b : bool),
 bool_fun_ext bf ->
 bool_fun_independent bf x ->
 bool_fun_eval bf (augment vb x b) = bool_fun_eval bf vb. 

Lemma bool_fun_independent_zero :
 forall (cfg : BDDconfig) (x : BDDvar),
 BDDconfig_OK cfg -> bool_fun_independent (bool_fun_of_BDD cfg BDDzero) x.

Lemma bool_fun_independent_one :
 forall (cfg : BDDconfig) (x : BDDvar),
 BDDconfig_OK cfg -> bool_fun_independent (bool_fun_of_BDD cfg BDDone) x.

Lemma in_dom_is_internal :
 forall (cfg : BDDconfig) (node : ad),
 in_dom _ node (fst cfg) = true -> is_internal_node cfg node.

Lemma internal_node_lemma :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node ->
 Neqb (low cfg node) (high cfg node) = false /\
 BDDbounded (fst cfg) (low cfg node) (var cfg node) /\
 BDDbounded (fst cfg) (high cfg node) (var cfg node).

Lemma high_bounded :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node ->
 BDDbounded (fst cfg) (high cfg node) (var cfg node).

Lemma low_bounded :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node ->
 BDDbounded (fst cfg) (low cfg node) (var cfg node).

Lemma high_OK :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node -> config_node_OK cfg (high cfg node).

Lemma low_OK :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node -> config_node_OK cfg (low cfg node).

Lemma low_high_neq :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node -> Neqb (low cfg node) (high cfg node) = false.

Lemma BDDvar_independent_1 :
 forall (cfg : BDDconfig) (n : nat) (node : ad) (x : BDDvar),
 BDDconfig_OK cfg ->
 is_internal_node cfg node ->
 n = nat_of_N (var cfg node) ->
 BDDcompare (var cfg node) x = Datatypes.Lt ->

Lemma BDDvar_independent_high :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node ->
 bool_fun_independent (bool_fun_of_BDD cfg (high cfg node)) (var cfg node).

Lemma BDDvar_independent_low :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node ->
 bool_fun_independent (bool_fun_of_BDD cfg (low cfg node)) (var cfg node).

Lemma bool_fun_of_BDDzero :
 forall cfg : BDDconfig,
 BDDconfig_OK cfg -> bool_fun_eq (bool_fun_of_BDD cfg BDDzero) bool_fun_zero.

Lemma bool_fun_of_BDDone :
 forall cfg : BDDconfig,
 BDDconfig_OK cfg -> bool_fun_eq (bool_fun_of_BDD cfg BDDone) bool_fun_one.

Lemma bool_fun_of_BDDhigh :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node ->
 bool_fun_eq (bool_fun_of_BDD cfg (high cfg node))
   (bool_fun_restrict (bool_fun_of_BDD cfg node) (var cfg node) true).

Lemma bool_fun_of_BDDlow :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node ->
 bool_fun_eq (bool_fun_of_BDD cfg (low cfg node))
   (bool_fun_restrict (bool_fun_of_BDD cfg node) (var cfg node) false).

Lemma internal_node_not_constant_1 :
 forall cfg : BDDconfig,
 BDDconfig_OK cfg ->
 forall (n : nat) (node : ad),
 is_internal_node cfg node ->
 n = nat_of_N (var cfg node) ->
 ~ bool_fun_eq (bool_fun_of_BDD cfg node) bool_fun_zero /\
 ~ bool_fun_eq (bool_fun_of_BDD cfg node) bool_fun_one.

Lemma internal_node_not_constant :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node ->
 ~ bool_fun_eq (bool_fun_of_BDD cfg node) bool_fun_zero /\
 ~ bool_fun_eq (bool_fun_of_BDD cfg node) bool_fun_one.

Lemma bool_fun_neq_internal_zero :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node ->
 ~ bool_fun_eq (bool_fun_of_BDD cfg node) (bool_fun_of_BDD cfg BDDzero).
 
Lemma bool_fun_neq_internal_one :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node ->
 ~ bool_fun_eq (bool_fun_of_BDD cfg node) (bool_fun_of_BDD cfg BDDone).

Lemma bool_fun_neq_zero_one :
 forall cfg : BDDconfig,
 BDDconfig_OK cfg ->
 ~ bool_fun_eq (bool_fun_of_BDD cfg BDDzero) (bool_fun_of_BDD cfg BDDone).

Lemma bool_fun_neq_one_zero :
 forall cfg : BDDconfig,
 BDDconfig_OK cfg ->
 ~ bool_fun_eq (bool_fun_of_BDD cfg BDDone) (bool_fun_of_BDD cfg BDDzero).

Lemma bool_fun_neq_lemma :
 forall bf1 bf2 : bool_fun, ~ bool_fun_eq bf1 bf2 -> ~ bool_fun_eq bf2 bf1.

Lemma no_duplicate_node :
 forall (cfg : BDDconfig) (node1 node2 : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node1 ->
 is_internal_node cfg node2 ->
 var cfg node1 = var cfg node2 ->
 high cfg node1 = high cfg node2 ->
 low cfg node1 = low cfg node2 -> node1 = node2.

Lemma BDDunique_1 :
 forall cfg : BDDconfig,
 BDDconfig_OK cfg ->
 forall (n : nat) (node1 node2 : ad),
 n = max (nat_of_N (var cfg node1)) (nat_of_N (var cfg node2)) ->
 config_node_OK cfg node1 ->
 config_node_OK cfg node2 ->
 bool_fun_eq (bool_fun_of_BDD cfg node1) (bool_fun_of_BDD cfg node2) ->
 node1 = node2.

Lemma BDDunique :
 forall cfg : BDDconfig,
 BDDconfig_OK cfg ->
 forall node1 node2 : ad,
 config_node_OK cfg node1 ->
 config_node_OK cfg node2 ->
 bool_fun_eq (bool_fun_of_BDD cfg node1) (bool_fun_of_BDD cfg node2) ->
 node1 = node2.

Lemma bool_fun_eq_lemma :
 forall (bf1 bf2 : bool_fun) (x : BDDvar),
 bool_fun_ext bf1 ->
 bool_fun_ext bf2 ->
 bool_fun_eq (bool_fun_restrict bf1 x true) (bool_fun_restrict bf2 x true) ->
 bool_fun_eq (bool_fun_restrict bf1 x false) (bool_fun_restrict bf2 x false) ->
 bool_fun_eq bf1 bf2.
  
Lemma bool_fun_preservation_1 :
 forall cfg cfg' : BDDconfig,
 BDDconfig_OK cfg ->
 BDDconfig_OK cfg' ->
 (forall (x : BDDvar) (l r a : ad),
  MapGet _ (fst cfg) a = Some (x, (l, r)) ->
  MapGet _ (fst cfg') a = Some (x, (l, r))) ->
 forall (n : nat) (node : ad),
 n = nat_of_N (var cfg node) ->
 config_node_OK cfg node ->
 bool_fun_eq (bool_fun_of_BDD cfg' node) (bool_fun_of_BDD cfg node).

Lemma bool_fun_preservation :
 forall (cfg cfg' : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 BDDconfig_OK cfg' ->
 (forall (x : BDDvar) (l r a : ad),
  MapGet _ (fst cfg) a = Some (x, (l, r)) ->
  MapGet _ (fst cfg') a = Some (x, (l, r))) ->
 config_node_OK cfg node ->
 bool_fun_eq (bool_fun_of_BDD cfg' node) (bool_fun_of_BDD cfg node). *)
Require Import bdd4.
(* bdd4:
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import ZArith NArith Nnat Ndec Ndigits.
From IntMap Require Import Allmaps.
Require Import Wf_nat.

Require Import BDDvar_ad_nat.
Require Import bdd1.
Require Import bdd2.
Require Import bdd3.

Lemma BDDneg_2_lemma :
 forall (bound : nat) (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 config_node_OK cfg node ->
 (is_internal_node cfg node -> nat_of_N (var cfg node) < bound) ->
 BDDconfig_OK (fst (BDDneg_2 cfg node bound)) /\
 (forall (x : BDDvar) (l r a : ad),
  MapGet _ (fst cfg) a = Some (x, (l, r)) ->
  MapGet _ (fst (fst (BDDneg_2 cfg node bound))) a = Some (x, (l, r))) /\
 (is_internal_node cfg node ->
  is_internal_node (fst (BDDneg_2 cfg node bound))
    (snd (BDDneg_2 cfg node bound)) /\
  var cfg node =
  var (fst (BDDneg_2 cfg node bound)) (snd (BDDneg_2 cfg node bound))) /\
 config_node_OK (fst (BDDneg_2 cfg node bound))
   (snd (BDDneg_2 cfg node bound)) /\
 bool_fun_eq
   (bool_fun_of_BDD (fst (BDDneg_2 cfg node bound))
      (snd (BDDneg_2 cfg node bound)))
   (bool_fun_neg (bool_fun_of_BDD cfg node)). *)
Require Import bdd5_1.
(* bdd5_1:
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import ZArith NArith Nnat Ndec Ndigits.
From IntMap Require Import Allmaps.
Require Import Wf_nat.

Require Import BDDvar_ad_nat.
Require Import bdd1.
Require Import bdd2.
Require Import bdd3.
Require Import bdd4.

Definition BDDneg_memo_OK_1 (cfg : BDDconfig) (memo : BDDneg_memo) :=
  forall (node node' : ad) (bound : nat),
  config_node_OK cfg node ->
  BDDneg_memo_lookup memo node = Some node' ->
  (is_internal_node cfg node -> nat_of_N (var cfg node) < bound) ->
  BDDneg_2 cfg node bound = (cfg, node').

Definition BDDneg_memo_OK_2 (cfg : BDDconfig) (memo : BDDneg_memo) :=
  forall (node node' : ad) (bound : nat),
  BDDneg_memo_lookup memo node = Some node' ->
  (is_internal_node cfg node -> nat_of_N (var cfg node) < bound) ->
  config_node_OK cfg node /\ BDDneg_2 cfg node bound = (cfg, node').

Fixpoint BDDneg_1 (arg : BDDconfig * ad * BDDneg_memo) 
 (bound : nat) {struct bound} : BDDconfig * ad * BDDneg_memo :=
  match BDDneg_memo_lookup (snd arg) (snd (fst arg)) with
  | Some node => (fst (fst arg), node, snd arg)
  | None =>
      match MapGet _ (fst (fst (fst arg))) (snd (fst arg)) with
      | None =>
          if Neqb (snd (fst arg)) BDDzero
          then
           (fst (fst arg), BDDone, BDDneg_memo_put (snd arg) BDDzero BDDone)
          else
           (fst (fst arg), BDDzero, BDDneg_memo_put (snd arg) BDDone BDDzero)
      | Some (x, (l, r)) =>
          match bound with
          | O => (initBDDconfig, BDDzero, newMap ad)
          | S bound' =>
              (BDDmake
                 (fst
                    (fst
                       (BDDneg_1
                          (fst
                             (fst
                                (BDDneg_1 (fst (fst arg), l, snd arg) bound')),
                          r,
                          snd (BDDneg_1 (fst (fst arg), l, snd arg) bound'))
                          bound'))) x
                 (snd (fst (BDDneg_1 (fst (fst arg), l, snd arg) bound')))
                 (snd
                    (fst
                       (BDDneg_1
                          (fst
                             (fst
                                (BDDneg_1 (fst (fst arg), l, snd arg) bound')),
                          r,
                          snd (BDDneg_1 (fst (fst arg), l, snd arg) bound'))
                          bound'))),
              BDDneg_memo_put
                (snd
                   (BDDneg_1
                      (fst
                         (fst (BDDneg_1 (fst (fst arg), l, snd arg) bound')),
                      r, snd (BDDneg_1 (fst (fst arg), l, snd arg) bound'))
                      bound')) (snd (fst arg))
                (snd
                   (BDDmake
                      (fst
                         (fst
                            (BDDneg_1
                               (fst
                                  (fst
                                     (BDDneg_1 (fst (fst arg), l, snd arg)
                                        bound')), r,
                               snd
                                 (BDDneg_1 (fst (fst arg), l, snd arg) bound'))
                               bound'))) x
                      (snd
                         (fst (BDDneg_1 (fst (fst arg), l, snd arg) bound')))
                      (snd
                         (fst
                            (BDDneg_1
                               (fst
                                  (fst
                                     (BDDneg_1 (fst (fst arg), l, snd arg)
                                        bound')), r,
                               snd
                                 (BDDneg_1 (fst (fst arg), l, snd arg) bound'))
                               bound'))))))
          end
      end
  end.

Lemma BDDneg_1_lemma_1 :
 forall (arg : BDDconfig * ad * BDDneg_memo) (node : ad) (bound : nat),
 BDDneg_memo_lookup (snd arg) (snd (fst arg)) = Some node ->
 BDDneg_1 arg bound = (fst (fst arg), node, snd arg).

Lemma BDDneg_1_lemma_2 :
 forall (arg : BDDconfig * ad * BDDneg_memo) (bound : nat),
 BDDneg_memo_lookup (snd arg) (snd (fst arg)) = None ->
 MapGet _ (fst (fst (fst arg))) (snd (fst arg)) = None ->
 BDDneg_1 arg bound =
 (if Neqb (snd (fst arg)) BDDzero
  then (fst (fst arg), BDDone, BDDneg_memo_put (snd arg) BDDzero BDDone)
  else (fst (fst arg), BDDzero, BDDneg_memo_put (snd arg) BDDone BDDzero)).

Lemma BDDneg_1_lemma_3 :
 forall (arg : BDDconfig * ad * BDDneg_memo) (x : BDDvar) (l r : ad),
 BDDneg_memo_lookup (snd arg) (snd (fst arg)) = None ->
 MapGet _ (fst (fst (fst arg))) (snd (fst arg)) = Some (x, (l, r)) ->
 BDDneg_1 arg 0 = (initBDDconfig, BDDzero, newMap ad).

Lemma nat_sum : forall n : nat, {m : nat | n = S m} + {n = 0}.

Lemma BDDneg_1_lemma_4 :
 forall (arg : BDDconfig * ad * BDDneg_memo) (x : BDDvar) 
   (l r : ad) (bound bound' : nat),
 bound = S bound' ->
 BDDneg_memo_lookup (snd arg) (snd (fst arg)) = None ->
 MapGet _ (fst (fst (fst arg))) (snd (fst arg)) = Some (x, (l, r)) ->
 BDDneg_1 arg bound =
 (BDDmake
    (fst
       (fst
          (BDDneg_1
             (fst (fst (BDDneg_1 (fst (fst arg), l, snd arg) bound')), r,
             snd (BDDneg_1 (fst (fst arg), l, snd arg) bound')) bound'))) x
    (snd (fst (BDDneg_1 (fst (fst arg), l, snd arg) bound')))
    (snd
       (fst
          (BDDneg_1
             (fst (fst (BDDneg_1 (fst (fst arg), l, snd arg) bound')), r,
             snd (BDDneg_1 (fst (fst arg), l, snd arg) bound')) bound'))),
 BDDneg_memo_put
   (snd
      (BDDneg_1
         (fst (fst (BDDneg_1 (fst (fst arg), l, snd arg) bound')), r,
         snd (BDDneg_1 (fst (fst arg), l, snd arg) bound')) bound'))
   (snd (fst arg))
   (snd
      (BDDmake
         (fst
            (fst
               (BDDneg_1
                  (fst (fst (BDDneg_1 (fst (fst arg), l, snd arg) bound')),
                  r, snd (BDDneg_1 (fst (fst arg), l, snd arg) bound'))
                  bound'))) x
         (snd (fst (BDDneg_1 (fst (fst arg), l, snd arg) bound')))
         (snd
            (fst
               (BDDneg_1
                  (fst (fst (BDDneg_1 (fst (fst arg), l, snd arg) bound')),
                  r, snd (BDDneg_1 (fst (fst arg), l, snd arg) bound'))
                  bound')))))).

Lemma bool_fun_restrict_neg_1 :
 forall (bf : bool_fun) (x : BDDvar) (b : bool),
 bool_fun_ext bf ->
 bool_fun_eq (bool_fun_restrict (bool_fun_neg bf) x b)
   (bool_fun_neg (bool_fun_restrict bf x b)).

Lemma bool_fun_neg_eq_var_2 :
 forall (cfg : BDDconfig) (node node' : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node ->
 is_internal_node cfg node' ->
 bool_fun_eq (bool_fun_of_BDD cfg node')
   (bool_fun_neg (bool_fun_of_BDD cfg node)) -> var cfg node = var cfg node'.

Lemma BDDneg_memo_OK_1_lemma_1_1_1 :
 forall (bound : nat) (cfg : BDDconfig) (node node' : ad),
 BDDconfig_OK cfg ->
 config_node_OK cfg node ->
 config_node_OK cfg node' ->
 (is_internal_node cfg node -> nat_of_N (var cfg node) < bound) ->
 bool_fun_eq (bool_fun_of_BDD cfg node')
   (bool_fun_neg (bool_fun_of_BDD cfg node)) ->
 BDDneg_2 cfg node bound = (cfg, node').

Lemma BDDneg_memo_OK_1_2 :
 forall (cfg : BDDconfig) (memo : BDDneg_memo),
 BDDneg_memo_OK_2 cfg memo -> BDDneg_memo_OK_1 cfg memo.

Lemma BDDneg_memo_OK_bool_fun_1 :
 forall (cfg : BDDconfig) (memo : BDDneg_memo) (node node' : ad),
 BDDconfig_OK cfg ->
 BDDneg_memo_OK_1 cfg memo ->
 config_node_OK cfg node ->
 BDDneg_memo_lookup memo node = Some node' ->
 bool_fun_eq (bool_fun_of_BDD cfg node')
   (bool_fun_neg (bool_fun_of_BDD cfg node)).

Lemma BDDneg_memo_OK_bool_fun_1' :
 forall (cfg : BDDconfig) (memo : BDDneg_memo) (node node' : ad),
 BDDconfig_OK cfg ->
 BDDneg_memo_OK_2 cfg memo ->
 config_node_OK cfg node ->
 BDDneg_memo_lookup memo node = Some node' ->
 bool_fun_eq (bool_fun_of_BDD cfg node')
   (bool_fun_neg (bool_fun_of_BDD cfg node)).

Definition nodes_preserved (cfg cfg' : BDDconfig) :=
  forall (x : BDDvar) (l r node : ad),
  MapGet _ (fst cfg) node = Some (x, (l, r)) ->
  MapGet _ (fst cfg') node = Some (x, (l, r)).

Lemma BDDmake_preserves_nodes :
 forall (cfg : BDDconfig) (x : BDDvar) (l r : ad),
 BDDconfig_OK cfg -> nodes_preserved cfg (fst (BDDmake cfg x l r)).

Lemma nodes_preserved_2 :
 forall (cfg cfg' : BDDconfig) (node : ad),
 config_node_OK cfg node ->
 nodes_preserved cfg cfg' -> config_node_OK cfg' node.

Lemma BDDneg_2_config_OK_lemma_2 :
 forall (cfg : BDDconfig) (node : ad) (x : BDDvar) (l r : ad) (n m : nat),
 BDDconfig_OK cfg ->
 MapGet _ (fst cfg) node = Some (x, (l, r)) ->
 nat_of_N (var cfg node) < n ->
 n = S m -> BDDconfig_OK (fst (BDDneg_2 (fst (BDDneg_2 cfg l m)) r m)).

Lemma nodes_preserved_1 :
 forall (cfg : BDDconfig) (node : ad) (n m : nat) (x : BDDvar) (l r : ad),
 BDDconfig_OK cfg ->
 MapGet _ (fst cfg) node = Some (x, (l, r)) ->
 n = S m ->
 nat_of_N (var cfg node) < n ->
 nodes_preserved (fst (BDDneg_2 (fst (BDDneg_2 cfg l m)) r m))
   (fst (BDDneg_2 cfg node n)).

Lemma BDDneg_memo_OK_lemma_1_4' :
 forall (cfg : BDDconfig) (memo : BDDneg_memo) (node node' : ad),
 BDDconfig_OK cfg ->
 BDDneg_memo_OK_2 cfg memo ->
 config_node_OK cfg node ->
 BDDneg_memo_lookup memo node = Some node' -> config_node_OK cfg node'. *)
Require Import bdd5_2.
(* bdd5_2:
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import ZArith NArith Nnat Ndec Ndigits.
From IntMap Require Import Allmaps.
Require Import Wf_nat.

Require Import BDDvar_ad_nat.
Require Import bdd1.
Require Import bdd2.
Require Import bdd3.
Require Import bdd4.
Require Import bdd5_1.

Lemma BDDneg_memo_OK_1_lemma_2_1' :
 forall (cfg : BDDconfig) (memo : BDDneg_memo),
 BDDconfig_OK cfg ->
 BDDneg_memo_OK_2 cfg memo ->
 BDDneg_memo_OK_2 cfg (BDDneg_memo_put memo BDDzero BDDone).

Lemma BDDneg_memo_OK_1_lemma_3_1' :
 forall (cfg : BDDconfig) (memo : BDDneg_memo),
 BDDconfig_OK cfg ->
 BDDneg_memo_OK_2 cfg memo ->
 BDDneg_memo_OK_2 cfg (BDDneg_memo_put memo BDDone BDDzero).

Lemma BDDneg_memo_OK_1_lemma_1_2' :
 forall (cfg : BDDconfig) (x : BDDvar) (l r node : ad) 
   (n m : nat) (memo : BDDneg_memo),
 BDDconfig_OK cfg ->
 MapGet _ (fst cfg) node = Some (x, (l, r)) ->
 nat_of_N (var cfg node) < n ->
 n = S m ->
 BDDneg_memo_OK_2 (fst (BDDneg_2 (fst (BDDneg_2 cfg l m)) r m)) memo ->
 BDDneg_memo_OK_2 (fst (BDDneg_2 cfg node n))
   (BDDneg_memo_put memo node (snd (BDDneg_2 cfg node n))).

Lemma BDDneg_1_lemma' :
 forall (bound : nat) (arg : BDDconfig * ad * BDDneg_memo),
 BDDconfig_OK (fst (fst arg)) ->
 config_node_OK (fst (fst arg)) (snd (fst arg)) ->
 BDDneg_memo_OK_2 (fst (fst arg)) (snd arg) ->
 (is_internal_node (fst (fst arg)) (snd (fst arg)) ->
  nat_of_N (var (fst (fst arg)) (snd (fst arg))) < bound) ->
 fst (BDDneg_1 arg bound) = BDDneg_2 (fst (fst arg)) (snd (fst arg)) bound /\
 BDDneg_memo_OK_2 (fst (fst (BDDneg_1 arg bound))) (snd (BDDneg_1 arg bound)). *)
Require Import bdd6.
(* bdd6:
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import ZArith NArith Nnat Ndec Ndigits.
From IntMap Require Import Allmaps.
Require Import Wf_nat.

Require Import BDDvar_ad_nat.
Require Import bdd1.
Require Import bdd2.
Require Import bdd3.
Require Import bdd4.
Require Import bdd5_1.
Require Import bdd5_2.

Lemma nodes_preserved_trans :
 forall cfg1 cfg2 cfg3 : BDDconfig,
 nodes_preserved cfg1 cfg2 ->
 nodes_preserved cfg2 cfg3 -> nodes_preserved cfg1 cfg3.

Lemma nodes_preserved_var :
 forall (cfg cfg' : BDDconfig) (node : ad),
 nodes_preserved cfg cfg' ->
 is_internal_node cfg node -> var cfg' node = var cfg node.

Lemma nodes_preserved_var_1 :
 forall (cfg cfg' : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 BDDconfig_OK cfg' ->
 nodes_preserved cfg cfg' ->
 config_node_OK cfg node -> var cfg' node = var cfg node.

Lemma nodes_preserved_3 :
 forall (cfg cfg' : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 BDDconfig_OK cfg' ->
 nodes_preserved cfg cfg' ->
 config_node_OK cfg node ->
 bool_fun_eq (bool_fun_of_BDD cfg' node) (bool_fun_of_BDD cfg node).

Lemma bool_fun_or_preserves_eq :
 forall bf1 bf2 bf1' bf2' : bool_fun,
 bool_fun_eq bf1 bf1' ->
 bool_fun_eq bf2 bf2' ->
 bool_fun_eq (bool_fun_or bf1 bf2) (bool_fun_or bf1' bf2').

Definition BDDvar_le := Nleb.
Definition BDDvar_max (x y : BDDvar) := if BDDvar_le x y then y else x.

Lemma BDDvar_max_comm : forall x y : BDDvar, BDDvar_max x y = BDDvar_max y x.

Lemma BDDvar_max_lemma_1 :
 forall x y z : BDDvar,
 BDDcompare x y = Datatypes.Lt ->

Lemma BDDvar_le_z : forall x : BDDvar, BDDvar_le N0 x = true.

Lemma BDDvar_le_compare :
 forall x y : BDDvar, BDDcompare x y = Datatypes.Lt -> BDDvar_le x y = true.

Lemma BDDcompare_max_1_2 :
 forall x1 x2 y1 y2 : BDDvar,
 BDDcompare x1 x2 = Datatypes.Lt ->

Lemma BDDcompare_z_nz :
 forall x : BDDvar, x <> N0 -> BDDcompare N0 x = Datatypes.Lt.

Lemma BDDvar_max_x_x : forall x : BDDvar, BDDvar_max x x = x.

Lemma BDDvar_ordered_high_1 :
 forall (cfg : BDDconfig) (node1 node2 : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node1 ->
 is_internal_node cfg node2 ->
 is_internal_node cfg (high cfg node1) \/
 is_internal_node cfg (high cfg node2) ->
 BDDcompare
   (BDDvar_max (var cfg (high cfg node1)) (var cfg (high cfg node2)))
   (BDDvar_max (var cfg node1) (var cfg node2)) = Datatypes.Lt.

Lemma BDDvar_ordered_low_1 :
 forall (cfg : BDDconfig) (node1 node2 : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node1 ->
 is_internal_node cfg node2 ->
 is_internal_node cfg (low cfg node1) \/ is_internal_node cfg (low cfg node2) ->
 BDDcompare (BDDvar_max (var cfg (low cfg node1)) (var cfg (low cfg node2)))
   (BDDvar_max (var cfg node1) (var cfg node2)) = Datatypes.Lt.

Lemma BDDvar_ordered_high_2 :
 forall (cfg : BDDconfig) (node1 node2 : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node1 ->
 is_internal_node cfg node2 ->
 BDDcompare (var cfg node1) (var cfg node2) = Datatypes.Lt ->

Lemma BDDvar_ordered_low_2 :
 forall (cfg : BDDconfig) (node1 node2 : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node1 ->
 is_internal_node cfg node2 ->
 BDDcompare (var cfg node1) (var cfg node2) = Datatypes.Lt ->

Lemma BDDvar_ordered_high_3 :
 forall (cfg : BDDconfig) (node1 node2 : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node1 ->
 is_internal_node cfg node2 ->
 BDDcompare (var cfg node2) (var cfg node1) = Datatypes.Lt ->

Lemma BDDvar_ordered_low_3 :
 forall (cfg : BDDconfig) (node1 node2 : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node1 ->
 is_internal_node cfg node2 ->
 BDDcompare (var cfg node2) (var cfg node1) = Datatypes.Lt ->

Lemma lt_max_nat_of_N :
 forall x y z : BDDvar,
 BDDcompare (BDDvar_max x y) z = Datatypes.Lt ->

Lemma le_nat_of_N_max :
 forall x y z : BDDvar,
 BDDvar_le x (BDDvar_max y z) = true ->
 nat_of_N x <= max (nat_of_N y) (nat_of_N z).

Definition bool_fun_if (x : BDDvar) (bf bf' : bool_fun) : bool_fun :=
  fun vb : var_binding => ifb (vb x) (bf vb) (bf' vb).
  
Lemma nodes_preserved_internal :
 forall (cfg cfg' : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 BDDconfig_OK cfg' ->
 config_node_OK cfg node ->
 is_internal_node cfg' node -> is_internal_node cfg node.

Lemma bool_fun_if_preserves_eq :
 forall (x : BDDvar) (bf1 bf2 bf1' bf2' : bool_fun),
 bool_fun_eq bf1 bf1' ->
 bool_fun_eq bf2 bf2' ->
 bool_fun_eq (bool_fun_if x bf1 bf2) (bool_fun_if x bf1' bf2').

Lemma BDDmake_var_order :
 forall (cfg : BDDconfig) (l r : ad) (x : BDDvar),
 BDDconfig_OK cfg ->
 config_node_OK cfg l ->
 config_node_OK cfg r ->
 (is_internal_node cfg l -> BDDcompare (var cfg l) x = Datatypes.Lt) ->

Lemma BDDmake_bool_fun :
 forall (cfg : BDDconfig) (l r : ad) (x : BDDvar),
 BDDconfig_OK cfg ->
 config_node_OK cfg l ->
 config_node_OK cfg r ->
 (is_internal_node cfg l -> BDDcompare (var cfg l) x = Datatypes.Lt) ->

Lemma bool_fun_or_commute :
 forall bf bf' : bool_fun,
 bool_fun_eq (bool_fun_or bf bf') (bool_fun_or bf' bf).

Lemma bool_fun_or_zero :
 forall bf : bool_fun, bool_fun_eq (bool_fun_or bf bool_fun_zero) bf.

Lemma bool_fun_or_one :
 forall bf : bool_fun, bool_fun_eq (bool_fun_or bf bool_fun_one) bool_fun_one.

Lemma bool_fun_if_lemma_1 :
 forall (x : BDDvar) (bfl1 bfl2 bfr1 bfr2 : bool_fun),
 bool_fun_eq (bool_fun_if x (bool_fun_or bfr1 bfr2) (bool_fun_or bfl1 bfl2))
   (bool_fun_or (bool_fun_if x bfr1 bfl1) (bool_fun_if x bfr2 bfl2)).

Lemma bool_fun_if_lemma_3 :
 forall (x : BDDvar) (bf1 bfl2 bfr2 : bool_fun),
 bool_fun_eq (bool_fun_if x (bool_fun_or bf1 bfr2) (bool_fun_or bf1 bfl2))
   (bool_fun_or bf1 (bool_fun_if x bfr2 bfl2)).

Lemma bool_fun_if_lemma_4 :
 forall (x : BDDvar) (bfl1 bfr1 bf2 : bool_fun),
 bool_fun_eq (bool_fun_if x (bool_fun_or bfr1 bf2) (bool_fun_or bfl1 bf2))
   (bool_fun_or (bool_fun_if x bfr1 bfl1) bf2).

Lemma bool_fun_if_lemma_2 :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node ->
 bool_fun_eq (bool_fun_of_BDD cfg node)
   (bool_fun_if (var cfg node) (bool_fun_of_BDD cfg (high cfg node))
      (bool_fun_of_BDD cfg (low cfg node))).

Lemma BDD_EGAL_correct : forall x y : BDDvar, BDDcompare x x = Datatypes.Eq.

Lemma BDD_EGALsymm :
 forall x y : BDDvar,
 BDDcompare x y = Datatypes.Eq -> BDDcompare y x = Datatypes.Eq.

Lemma BDDcompare_le_INFERIEUR_1 :
 forall x y z : BDDvar,
 BDDvar_le x y = true ->
 BDDcompare y z = Datatypes.Lt -> BDDcompare x z = Datatypes.Lt.

Definition BDDor_memo := Map (Map ad).
Definition initBDDor_memo := newMap (Map ad).

Definition BDDor_memo_put (memo : BDDor_memo) (node1 node2 node : ad) :=
  let m1 :=
    match MapGet _ memo node1 with
    | Some y => y
    | None => newMap ad
    end in
  let m1' := MapPut _ m1 node2 node in MapPut _ memo node1 m1'.

Definition BDDor_memo_lookup (memo : BDDor_memo) (node1 node2 : ad) :=
  match MapGet _ memo node1 with
  | None => None
  | Some m1 =>
      match MapGet _ m1 node2 with
      | None => None
      | Some node => Some node
      end
  end. 

Definition BDDor_memo_OK (cfg : BDDconfig) (memo : BDDor_memo) :=
  forall node1 node2 node : ad,
  BDDor_memo_lookup memo node1 node2 = Some node ->
  config_node_OK cfg node1 /\
  config_node_OK cfg node2 /\
  config_node_OK cfg node /\
  BDDvar_le (var cfg node) (BDDvar_max (var cfg node1) (var cfg node2)) =
  true /\
  bool_fun_eq (bool_fun_of_BDD cfg node)
    (bool_fun_or (bool_fun_of_BDD cfg node1) (bool_fun_of_BDD cfg node2)).

Lemma BDDor_memo_lookup_semantics :
 forall (memo : BDDor_memo) (node1 node2 node node1' node2' : ad),
 BDDor_memo_lookup (BDDor_memo_put memo node1 node2 node) node1' node2' =
 (if Neqb node1 node1' && Neqb node2 node2'
  then Some node
  else BDDor_memo_lookup memo node1' node2'). *)
Require Import bdd7.
(* bdd7:
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import ZArith NArith Nnat Ndec Ndigits.
From IntMap Require Import Allmaps.
Require Import Wf_nat.

Require Import BDDvar_ad_nat.
Require Import bdd1.
Require Import bdd2.
Require Import bdd3.
Require Import bdd4.
Require Import bdd5_1.
Require Import bdd5_2.
Require Import bdd6.

Fixpoint BDDor_1 (cfg : BDDconfig) (memo : BDDor_memo) 
 (node1 node2 : ad) (bound : nat) {struct bound} :
 BDDconfig * (ad * BDDor_memo) :=
  match BDDor_memo_lookup memo node1 node2 with
  | Some node => (cfg, (node, memo))
  | None =>
      if Neqb node1 BDDzero
      then (cfg, (node2, BDDor_memo_put memo BDDzero node2 node2))
      else
       if Neqb node1 BDDone
       then (cfg, (BDDone, BDDor_memo_put memo BDDone node2 BDDone))
       else
        if Neqb node2 BDDzero
        then (cfg, (node1, BDDor_memo_put memo node1 BDDzero node1))
        else
         if Neqb node2 BDDone
         then (cfg, (BDDone, BDDor_memo_put memo node1 BDDone BDDone))
         else
          match bound with
          | O => (initBDDconfig, (BDDzero, initBDDor_memo))
          | S bound' =>
              match BDDcompare (var cfg node1) (var cfg node2) with
              | Datatypes.Eq =>
                  (fst
                     (BDDmake
                        (fst
                           (BDDor_1
                              (fst
                                 (BDDor_1 cfg memo 
                                    (low cfg node1) 
                                    (low cfg node2) bound'))
                              (snd
                                 (snd
                                    (BDDor_1 cfg memo 
                                       (low cfg node1) 
                                       (low cfg node2) bound')))
                              (high cfg node1) (high cfg node2) bound'))
                        (var cfg node1)
                        (fst
                           (snd
                              (BDDor_1 cfg memo (low cfg node1)
                                 (low cfg node2) bound')))
                        (fst
                           (snd
                              (BDDor_1
                                 (fst
                                    (BDDor_1 cfg memo 
                                       (low cfg node1) 
                                       (low cfg node2) bound'))
                                 (snd
                                    (snd
                                       (BDDor_1 cfg memo 
                                          (low cfg node1) 
                                          (low cfg node2) bound')))
                                 (high cfg node1) (high cfg node2) bound')))),
                  (snd
                     (BDDmake
                        (fst
                           (BDDor_1
                              (fst
                                 (BDDor_1 cfg memo 
                                    (low cfg node1) 
                                    (low cfg node2) bound'))
                              (snd
                                 (snd
                                    (BDDor_1 cfg memo 
                                       (low cfg node1) 
                                       (low cfg node2) bound')))
                              (high cfg node1) (high cfg node2) bound'))
                        (var cfg node1)
                        (fst
                           (snd
                              (BDDor_1 cfg memo (low cfg node1)
                                 (low cfg node2) bound')))
                        (fst
                           (snd
                              (BDDor_1
                                 (fst
                                    (BDDor_1 cfg memo 
                                       (low cfg node1) 
                                       (low cfg node2) bound'))
                                 (snd
                                    (snd
                                       (BDDor_1 cfg memo 
                                          (low cfg node1) 
                                          (low cfg node2) bound')))
                                 (high cfg node1) (high cfg node2) bound')))),
                  BDDor_memo_put
                    (snd
                       (snd
                          (BDDor_1
                             (fst
                                (BDDor_1 cfg memo (low cfg node1)
                                   (low cfg node2) bound'))
                             (snd
                                (snd
                                   (BDDor_1 cfg memo 
                                      (low cfg node1) 
                                      (low cfg node2) bound')))
                             (high cfg node1) (high cfg node2) bound')))
                    node1 node2
                    (snd
                       (BDDmake
                          (fst
                             (BDDor_1
                                (fst
                                   (BDDor_1 cfg memo 
                                      (low cfg node1) 
                                      (low cfg node2) bound'))
                                (snd
                                   (snd
                                      (BDDor_1 cfg memo 
                                         (low cfg node1) 
                                         (low cfg node2) bound')))
                                (high cfg node1) (high cfg node2) bound'))
                          (var cfg node1)
                          (fst
                             (snd
                                (BDDor_1 cfg memo (low cfg node1)
                                   (low cfg node2) bound')))
                          (fst
                             (snd
                                (BDDor_1
                                   (fst
                                      (BDDor_1 cfg memo 
                                         (low cfg node1) 
                                         (low cfg node2) bound'))
                                   (snd
                                      (snd
                                         (BDDor_1 cfg memo 
                                            (low cfg node1) 
                                            (low cfg node2) bound')))
                                   (high cfg node1) 
                                   (high cfg node2) bound')))))))
              | Datatypes.Lt =>
                  (fst
                     (BDDmake
                        (fst
                           (BDDor_1
                              (fst
                                 (BDDor_1 cfg memo node1 
                                    (low cfg node2) bound'))
                              (snd
                                 (snd
                                    (BDDor_1 cfg memo node1 
                                       (low cfg node2) bound'))) node1
                              (high cfg node2) bound')) 
                        (var cfg node2)
                        (fst
                           (snd
                              (BDDor_1 cfg memo node1 (low cfg node2) bound')))
                        (fst
                           (snd
                              (BDDor_1
                                 (fst
                                    (BDDor_1 cfg memo node1 
                                       (low cfg node2) bound'))
                                 (snd
                                    (snd
                                       (BDDor_1 cfg memo node1
                                          (low cfg node2) bound'))) node1
                                 (high cfg node2) bound')))),
                  (snd
                     (BDDmake
                        (fst
                           (BDDor_1
                              (fst
                                 (BDDor_1 cfg memo node1 
                                    (low cfg node2) bound'))
                              (snd
                                 (snd
                                    (BDDor_1 cfg memo node1 
                                       (low cfg node2) bound'))) node1
                              (high cfg node2) bound')) 
                        (var cfg node2)
                        (fst
                           (snd
                              (BDDor_1 cfg memo node1 (low cfg node2) bound')))
                        (fst
                           (snd
                              (BDDor_1
                                 (fst
                                    (BDDor_1 cfg memo node1 
                                       (low cfg node2) bound'))
                                 (snd
                                    (snd
                                       (BDDor_1 cfg memo node1
                                          (low cfg node2) bound'))) node1
                                 (high cfg node2) bound')))),
                  BDDor_memo_put
                    (snd
                       (snd
                          (BDDor_1
                             (fst
                                (BDDor_1 cfg memo node1 
                                   (low cfg node2) bound'))
                             (snd
                                (snd
                                   (BDDor_1 cfg memo node1 
                                      (low cfg node2) bound'))) node1
                             (high cfg node2) bound'))) node1 node2
                    (snd
                       (BDDmake
                          (fst
                             (BDDor_1
                                (fst
                                   (BDDor_1 cfg memo node1 
                                      (low cfg node2) bound'))
                                (snd
                                   (snd
                                      (BDDor_1 cfg memo node1 
                                         (low cfg node2) bound'))) node1
                                (high cfg node2) bound')) 
                          (var cfg node2)
                          (fst
                             (snd
                                (BDDor_1 cfg memo node1 
                                   (low cfg node2) bound')))
                          (fst
                             (snd
                                (BDDor_1
                                   (fst
                                      (BDDor_1 cfg memo node1 
                                         (low cfg node2) bound'))
                                   (snd
                                      (snd
                                         (BDDor_1 cfg memo node1
                                            (low cfg node2) bound'))) node1
                                   (high cfg node2) bound')))))))
              | Datatypes.Gt =>
                  (fst
                     (BDDmake
                        (fst
                           (BDDor_1
                              (fst
                                 (BDDor_1 cfg memo 
                                    (low cfg node1) node2 bound'))
                              (snd
                                 (snd
                                    (BDDor_1 cfg memo 
                                       (low cfg node1) node2 bound')))
                              (high cfg node1) node2 bound')) 
                        (var cfg node1)
                        (fst
                           (snd
                              (BDDor_1 cfg memo (low cfg node1) node2 bound')))
                        (fst
                           (snd
                              (BDDor_1
                                 (fst
                                    (BDDor_1 cfg memo 
                                       (low cfg node1) node2 bound'))
                                 (snd
                                    (snd
                                       (BDDor_1 cfg memo 
                                          (low cfg node1) node2 bound')))
                                 (high cfg node1) node2 bound')))),
                  (snd
                     (BDDmake
                        (fst
                           (BDDor_1
                              (fst
                                 (BDDor_1 cfg memo 
                                    (low cfg node1) node2 bound'))
                              (snd
                                 (snd
                                    (BDDor_1 cfg memo 
                                       (low cfg node1) node2 bound')))
                              (high cfg node1) node2 bound')) 
                        (var cfg node1)
                        (fst
                           (snd
                              (BDDor_1 cfg memo (low cfg node1) node2 bound')))
                        (fst
                           (snd
                              (BDDor_1
                                 (fst
                                    (BDDor_1 cfg memo 
                                       (low cfg node1) node2 bound'))
                                 (snd
                                    (snd
                                       (BDDor_1 cfg memo 
                                          (low cfg node1) node2 bound')))
                                 (high cfg node1) node2 bound')))),
                  BDDor_memo_put
                    (snd
                       (snd
                          (BDDor_1
                             (fst
                                (BDDor_1 cfg memo (low cfg node1) node2
                                   bound'))
                             (snd
                                (snd
                                   (BDDor_1 cfg memo 
                                      (low cfg node1) node2 bound')))
                             (high cfg node1) node2 bound'))) node1 node2
                    (snd
                       (BDDmake
                          (fst
                             (BDDor_1
                                (fst
                                   (BDDor_1 cfg memo 
                                      (low cfg node1) node2 bound'))
                                (snd
                                   (snd
                                      (BDDor_1 cfg memo 
                                         (low cfg node1) node2 bound')))
                                (high cfg node1) node2 bound'))
                          (var cfg node1)
                          (fst
                             (snd
                                (BDDor_1 cfg memo (low cfg node1) node2
                                   bound')))
                          (fst
                             (snd
                                (BDDor_1
                                   (fst
                                      (BDDor_1 cfg memo 
                                         (low cfg node1) node2 bound'))
                                   (snd
                                      (snd
                                         (BDDor_1 cfg memo 
                                            (low cfg node1) node2 bound')))
                                   (high cfg node1) node2 bound')))))))
              end
          end
  end.

Lemma BDDor_1_lemma_1 :
 forall (cfg : BDDconfig) (memo : BDDor_memo) (node1 node2 node : ad)
   (bound : nat),
 BDDor_memo_lookup memo node1 node2 = Some node ->
 BDDor_1 cfg memo node1 node2 bound = (cfg, (node, memo)).

Lemma BDDor_1_lemma_zero_1 :
 forall (cfg : BDDconfig) (memo : BDDor_memo) (node1 : ad) (bound : nat),
 BDDor_memo_lookup memo node1 BDDzero = None ->
 BDDor_1 cfg memo node1 BDDzero bound =
 (cfg, (node1, BDDor_memo_put memo node1 BDDzero node1)).

Lemma BDDor_1_lemma_one_1 :
 forall (cfg : BDDconfig) (memo : BDDor_memo) (node1 : ad) (bound : nat),
 BDDor_memo_lookup memo node1 BDDone = None ->
 BDDor_1 cfg memo node1 BDDone bound =
 (cfg, (BDDone, BDDor_memo_put memo node1 BDDone BDDone)).

Lemma BDDor_1_lemma_zero_2 :
 forall (cfg : BDDconfig) (memo : BDDor_memo) (node2 : ad) (bound : nat),
 BDDor_memo_lookup memo BDDzero node2 = None ->
 BDDor_1 cfg memo BDDzero node2 bound =
 (cfg, (node2, BDDor_memo_put memo BDDzero node2 node2)).

Lemma BDDor_1_lemma_one_2 :
 forall (cfg : BDDconfig) (memo : BDDor_memo) (node2 : ad) (bound : nat),
 BDDor_memo_lookup memo BDDone node2 = None ->
 BDDor_1 cfg memo BDDone node2 bound =
 (cfg, (BDDone, BDDor_memo_put memo BDDone node2 BDDone)).

Lemma BDDor_1_lemma_internal_1 :
 forall (cfg : BDDconfig) (memo : BDDor_memo) (node1 node2 : ad)
   (bound bound' : nat),
 BDDor_memo_lookup memo node1 node2 = None ->
 BDDconfig_OK cfg ->
 is_internal_node cfg node1 ->
 is_internal_node cfg node2 ->
 max (nat_of_N (var cfg node1)) (nat_of_N (var cfg node2)) < bound ->
 bound = S bound' ->
 BDDcompare (var cfg node1) (var cfg node2) = Datatypes.Eq ->

Lemma BDDor_1_lemma_internal_2 :
 forall (cfg : BDDconfig) (memo : BDDor_memo) (node1 node2 : ad)
   (bound bound' : nat),
 BDDor_memo_lookup memo node1 node2 = None ->
 BDDconfig_OK cfg ->
 is_internal_node cfg node1 ->
 is_internal_node cfg node2 ->
 max (nat_of_N (var cfg node1)) (nat_of_N (var cfg node2)) < bound ->
 bound = S bound' ->
 BDDcompare (var cfg node1) (var cfg node2) = Datatypes.Lt ->

Lemma BDDor_1_lemma_internal_3 :
 forall (cfg : BDDconfig) (memo : BDDor_memo) (node1 node2 : ad)
   (bound bound' : nat),
 BDDor_memo_lookup memo node1 node2 = None ->
 BDDconfig_OK cfg ->
 is_internal_node cfg node1 ->
 is_internal_node cfg node2 ->
 max (nat_of_N (var cfg node1)) (nat_of_N (var cfg node2)) < bound ->
 bound = S bound' ->
 BDDcompare (var cfg node1) (var cfg node2) = Datatypes.Gt ->

Lemma BDDvar_le_max_2 :
 forall x y : BDDvar, BDDvar_le x (BDDvar_max y x) = true.

Lemma BDDvar_le_max_1 :
 forall x y : BDDvar, BDDvar_le x (BDDvar_max x y) = true.

Lemma BDDor_1_internal :
 forall (cfg : BDDconfig) (memo : BDDor_memo) (node1 node2 : ad)
   (bound : nat),
 BDDconfig_OK cfg ->
 config_node_OK cfg node1 ->
 config_node_OK cfg node2 ->
 BDDor_memo_OK cfg memo ->
 is_internal_node (fst (BDDor_1 cfg memo node1 node2 bound))
   (fst (snd (BDDor_1 cfg memo node1 node2 bound))) ->
 is_internal_node cfg node1 \/ is_internal_node cfg node2. *)
Require Import BDDdummy_lemma_2.
(* BDDdummy_lemma_2:
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import ZArith NArith Nnat Ndec Ndigits.
From IntMap Require Import Allmaps.
Require Import Wf_nat.

Require Import BDDvar_ad_nat.
Require Import bdd1.
Require Import bdd2.
Require Import bdd3.
Require Import bdd4.
Require Import bdd5_1.
Require Import bdd5_2.
Require Import bdd6.
Require Import bdd7.

Lemma BDDdummy_lemma_2 :
 forall bound : nat,
 (forall m : nat,
  m < bound ->
  forall (cfg : BDDconfig) (node1 node2 : ad) (memo : BDDor_memo),
  BDDconfig_OK cfg ->
  BDDor_memo_OK cfg memo ->
  config_node_OK cfg node1 ->
  config_node_OK cfg node2 ->
  (is_internal_node cfg node1 ->
   is_internal_node cfg node2 ->
   max (nat_of_N (var cfg node1)) (nat_of_N (var cfg node2)) < m) ->
  BDDconfig_OK (fst (BDDor_1 cfg memo node1 node2 m)) /\
  BDDor_memo_OK (fst (BDDor_1 cfg memo node1 node2 m))
    (snd (snd (BDDor_1 cfg memo node1 node2 m))) /\
  config_node_OK (fst (BDDor_1 cfg memo node1 node2 m))
    (fst (snd (BDDor_1 cfg memo node1 node2 m))) /\
  nodes_preserved cfg (fst (BDDor_1 cfg memo node1 node2 m)) /\
  BDDvar_le
    (var (fst (BDDor_1 cfg memo node1 node2 m))
       (fst (snd (BDDor_1 cfg memo node1 node2 m))))
    (BDDvar_max (var cfg node1) (var cfg node2)) = true /\
  bool_fun_eq
    (bool_fun_of_BDD (fst (BDDor_1 cfg memo node1 node2 m))
       (fst (snd (BDDor_1 cfg memo node1 node2 m))))
    (bool_fun_or (bool_fun_of_BDD cfg node1) (bool_fun_of_BDD cfg node2))) ->
 forall (cfg : BDDconfig) (node1 node2 : ad) (memo : BDDor_memo),
 BDDconfig_OK cfg ->
 BDDor_memo_OK cfg memo ->
 config_node_OK cfg node1 ->
 config_node_OK cfg node2 ->
 (is_internal_node cfg node1 ->
  is_internal_node cfg node2 ->
  max (nat_of_N (var cfg node1)) (nat_of_N (var cfg node2)) < bound) ->
 BDDor_memo_lookup memo node1 node2 = None ->
 in_dom (BDDvar * (ad * ad)) node1 (fst cfg) = true ->
 node2 = BDDone \/ in_dom (BDDvar * (ad * ad)) node2 (fst cfg) = true ->
 is_internal_node cfg node1 ->
 in_dom (BDDvar * (ad * ad)) node2 (fst cfg) = true ->
 is_internal_node cfg node2 ->
 forall bound' : nat,
 bound = S bound' ->
 max (nat_of_N (var cfg node1)) (nat_of_N (var cfg node2)) < bound ->
 BDDcompare (var cfg node1) (var cfg node2) = Datatypes.Eq -> *)
Require Import BDDdummy_lemma_3.
(* BDDdummy_lemma_3:
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import ZArith NArith Nnat Ndec Ndigits.
From IntMap Require Import Allmaps.
Require Import Wf_nat.

Require Import BDDvar_ad_nat.
Require Import bdd1.
Require Import bdd2.
Require Import bdd3.
Require Import bdd4.
Require Import bdd5_1.
Require Import bdd5_2.
Require Import bdd6.
Require Import bdd7.

Lemma BDDdummy_lemma_3 :
 forall bound : nat,
 (forall m : nat,
  m < bound ->
  forall (cfg : BDDconfig) (node1 node2 : ad) (memo : BDDor_memo),
  BDDconfig_OK cfg ->
  BDDor_memo_OK cfg memo ->
  config_node_OK cfg node1 ->
  config_node_OK cfg node2 ->
  (is_internal_node cfg node1 ->
   is_internal_node cfg node2 ->
   max (nat_of_N (var cfg node1)) (nat_of_N (var cfg node2)) < m) ->
  BDDconfig_OK (fst (BDDor_1 cfg memo node1 node2 m)) /\
  BDDor_memo_OK (fst (BDDor_1 cfg memo node1 node2 m))
    (snd (snd (BDDor_1 cfg memo node1 node2 m))) /\
  config_node_OK (fst (BDDor_1 cfg memo node1 node2 m))
    (fst (snd (BDDor_1 cfg memo node1 node2 m))) /\
  nodes_preserved cfg (fst (BDDor_1 cfg memo node1 node2 m)) /\
  BDDvar_le
    (var (fst (BDDor_1 cfg memo node1 node2 m))
       (fst (snd (BDDor_1 cfg memo node1 node2 m))))
    (BDDvar_max (var cfg node1) (var cfg node2)) = true /\
  bool_fun_eq
    (bool_fun_of_BDD (fst (BDDor_1 cfg memo node1 node2 m))
       (fst (snd (BDDor_1 cfg memo node1 node2 m))))
    (bool_fun_or (bool_fun_of_BDD cfg node1) (bool_fun_of_BDD cfg node2))) ->
 forall (cfg : BDDconfig) (node1 node2 : ad) (memo : BDDor_memo),
 BDDconfig_OK cfg ->
 BDDor_memo_OK cfg memo ->
 config_node_OK cfg node1 ->
 config_node_OK cfg node2 ->
 (is_internal_node cfg node1 ->
  is_internal_node cfg node2 ->
  max (nat_of_N (var cfg node1)) (nat_of_N (var cfg node2)) < bound) ->
 BDDor_memo_lookup memo node1 node2 = None ->
 in_dom (BDDvar * (ad * ad)) node1 (fst cfg) = true ->
 node2 = BDDone \/ in_dom (BDDvar * (ad * ad)) node2 (fst cfg) = true ->
 is_internal_node cfg node1 ->
 in_dom (BDDvar * (ad * ad)) node2 (fst cfg) = true ->
 is_internal_node cfg node2 ->
 forall bound' : nat,
 bound = S bound' ->
 max (nat_of_N (var cfg node1)) (nat_of_N (var cfg node2)) < bound ->
 BDDcompare (var cfg node1) (var cfg node2) = Datatypes.Lt -> *)
Require Import BDDdummy_lemma_4.
(* BDDdummy_lemma_4:
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import ZArith NArith Nnat Ndec Ndigits.
From IntMap Require Import Allmaps.
Require Import Wf_nat.

Require Import BDDvar_ad_nat.
Require Import bdd1.
Require Import bdd2.
Require Import bdd3.
Require Import bdd4.
Require Import bdd5_1.
Require Import bdd5_2.
Require Import bdd6.
Require Import bdd7.

Lemma BDDdummy_lemma_4 :
 forall bound : nat,
 (forall m : nat,
  m < bound ->
  forall (cfg : BDDconfig) (node1 node2 : ad) (memo : BDDor_memo),
  BDDconfig_OK cfg ->
  BDDor_memo_OK cfg memo ->
  config_node_OK cfg node1 ->
  config_node_OK cfg node2 ->
  (is_internal_node cfg node1 ->
   is_internal_node cfg node2 ->
   max (nat_of_N (var cfg node1)) (nat_of_N (var cfg node2)) < m) ->
  BDDconfig_OK (fst (BDDor_1 cfg memo node1 node2 m)) /\
  BDDor_memo_OK (fst (BDDor_1 cfg memo node1 node2 m))
    (snd (snd (BDDor_1 cfg memo node1 node2 m))) /\
  config_node_OK (fst (BDDor_1 cfg memo node1 node2 m))
    (fst (snd (BDDor_1 cfg memo node1 node2 m))) /\
  nodes_preserved cfg (fst (BDDor_1 cfg memo node1 node2 m)) /\
  BDDvar_le
    (var (fst (BDDor_1 cfg memo node1 node2 m))
       (fst (snd (BDDor_1 cfg memo node1 node2 m))))
    (BDDvar_max (var cfg node1) (var cfg node2)) = true /\
  bool_fun_eq
    (bool_fun_of_BDD (fst (BDDor_1 cfg memo node1 node2 m))
       (fst (snd (BDDor_1 cfg memo node1 node2 m))))
    (bool_fun_or (bool_fun_of_BDD cfg node1) (bool_fun_of_BDD cfg node2))) ->
 forall (cfg : BDDconfig) (node1 node2 : ad) (memo : BDDor_memo),
 BDDconfig_OK cfg ->
 BDDor_memo_OK cfg memo ->
 config_node_OK cfg node1 ->
 config_node_OK cfg node2 ->
 (is_internal_node cfg node1 ->
  is_internal_node cfg node2 ->
  max (nat_of_N (var cfg node1)) (nat_of_N (var cfg node2)) < bound) ->
 BDDor_memo_lookup memo node1 node2 = None ->
 in_dom (BDDvar * (ad * ad)) node1 (fst cfg) = true ->
 node2 = BDDone \/ in_dom (BDDvar * (ad * ad)) node2 (fst cfg) = true ->
 is_internal_node cfg node1 ->
 in_dom (BDDvar * (ad * ad)) node2 (fst cfg) = true ->
 is_internal_node cfg node2 ->
 forall bound' : nat,
 bound = S bound' ->
 max (nat_of_N (var cfg node1)) (nat_of_N (var cfg node2)) < bound ->
 BDDcompare (var cfg node1) (var cfg node2) = Datatypes.Gt -> *)
Require Import bdd8.
(* bdd8:
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import ZArith NArith Nnat Ndec Ndigits.
From IntMap Require Import Allmaps.
Require Import Wf_nat.

Require Import BDDvar_ad_nat.
Require Import bdd1.
Require Import bdd2.
Require Import bdd3.
Require Import bdd4.
Require Import bdd5_1.
Require Import bdd5_2.
Require Import bdd6.
Require Import bdd7.
Require Import BDDdummy_lemma_2.
Require Import BDDdummy_lemma_3.
Require Import BDDdummy_lemma_4.

Lemma BDDor_1_lemma :
 forall (bound : nat) (cfg : BDDconfig) (node1 node2 : ad)
   (memo : BDDor_memo),
 BDDconfig_OK cfg ->
 BDDor_memo_OK cfg memo ->
 config_node_OK cfg node1 ->
 config_node_OK cfg node2 ->
 (is_internal_node cfg node1 ->
  is_internal_node cfg node2 ->
  max (nat_of_N (var cfg node1)) (nat_of_N (var cfg node2)) < bound) ->
 BDDconfig_OK (fst (BDDor_1 cfg memo node1 node2 bound)) /\
 BDDor_memo_OK (fst (BDDor_1 cfg memo node1 node2 bound))
   (snd (snd (BDDor_1 cfg memo node1 node2 bound))) /\
 config_node_OK (fst (BDDor_1 cfg memo node1 node2 bound))
   (fst (snd (BDDor_1 cfg memo node1 node2 bound))) /\
 nodes_preserved cfg (fst (BDDor_1 cfg memo node1 node2 bound)) /\
 BDDvar_le
   (var (fst (BDDor_1 cfg memo node1 node2 bound))
      (fst (snd (BDDor_1 cfg memo node1 node2 bound))))
   (BDDvar_max (var cfg node1) (var cfg node2)) = true /\
 bool_fun_eq
   (bool_fun_of_BDD (fst (BDDor_1 cfg memo node1 node2 bound))
      (fst (snd (BDDor_1 cfg memo node1 node2 bound))))
   (bool_fun_or (bool_fun_of_BDD cfg node1) (bool_fun_of_BDD cfg node2)). *)

Inductive BDDdummy_type1 : Set :=
    BDDdummy1 : BDDconfig * ad * BDDneg_memo -> BDDdummy_type1.

Inductive BDDdummy_type2 : Set :=
    BDDdummy2 : BDDconfig * ad -> BDDdummy_type2.

Inductive BDDdummy_type3 : Set :=
    BDDdummy3 : BDDconfig * (ad * BDDor_memo) -> BDDdummy_type3.

Definition initBDDneg_memo : BDDneg_memo := newMap ad.

Fixpoint BDDneg_1_1 (cfg : BDDconfig) (memo : BDDneg_memo) 
 (node : ad) (bound : nat) {struct bound} : BDDconfig * ad * BDDneg_memo :=
  match BDDneg_memo_lookup memo node with
  | Some node' => (cfg, node', memo)
  | None =>
      match MapGet _ (fst cfg) node with
      | None =>
          if Neqb node BDDzero
          then (cfg, BDDone, BDDneg_memo_put memo BDDzero BDDone)
          else (cfg, BDDzero, BDDneg_memo_put memo BDDone BDDzero)
      | Some (x, (l, r)) =>
          match bound with
          | O => (initBDDconfig, BDDzero, initBDDneg_memo)
          | S bound' =>
              match BDDdummy1 (BDDneg_1_1 cfg memo l bound') with
              | BDDdummy1 ((cfgl, nodel), memol) =>
                  match BDDdummy1 (BDDneg_1_1 cfgl memol r bound') with
                  | BDDdummy1 ((cfgr, noder), memor) =>
                      match BDDdummy2 (BDDmake cfgr x nodel noder) with
                      | BDDdummy2 (cfg', node') =>
                          (cfg', node', BDDneg_memo_put memor node node')
                      end
                  end
              end
          end
      end
  end.

Lemma BDDneg_1_1_eq_1 :
 forall (bound : nat) (cfg : BDDconfig) (memo : BDDneg_memo) (node : ad),
 BDDneg_1_1 cfg memo node bound = BDDneg_1 (cfg, node, memo) bound.
Proof.
  simple induction bound.  intros cfg memo node.  simpl in |- *.  reflexivity.  simpl in |- *.  intros n H cfg memo node.  elim (MapGet (BDDvar * (ad * ad)) (fst cfg) node).
  Focus 2.
  reflexivity.  intro a.  elim a.  intros y y0.  elim y0.  intros y1 y2.  cut (BDDneg_1_1 cfg memo y1 n = BDDneg_1 (cfg, y1, memo) n).
  intro H0.  rewrite H0.  elim (BDDneg_1 (cfg, y1, memo) n).  intros y3 y4.  elim y3.
  intros y5 y6.  simpl in |- *.  cut (BDDneg_1_1 y5 y4 y2 n = BDDneg_1 (y5, y2, y4) n).  intro H1.
  rewrite H1.  elim (BDDneg_1 (y5, y2, y4) n).  intros y7 y8.  simpl in |- *.  elim y7.  intros y9 y10.
  simpl in |- *.  elim (BDDmake y9 y y6 y10).  intros y11 y12.  simpl in |- *.  reflexivity.  apply H.  
  apply H.
Qed.

Fixpoint BDDor_1_1 (cfg : BDDconfig) (memo : BDDor_memo) 
 (node1 node2 : ad) (bound : nat) {struct bound} :
 BDDconfig * (ad * BDDor_memo) :=
  match BDDor_memo_lookup memo node1 node2 with
  | Some node => (cfg, (node, memo))
  | None =>
      if Neqb node1 BDDzero
      then (cfg, (node2, BDDor_memo_put memo BDDzero node2 node2))
      else
       if Neqb node1 BDDone
       then (cfg, (BDDone, BDDor_memo_put memo BDDone node2 BDDone))
       else
        if Neqb node2 BDDzero
        then (cfg, (node1, BDDor_memo_put memo node1 BDDzero node1))
        else
         if Neqb node2 BDDone
         then (cfg, (BDDone, BDDor_memo_put memo node1 BDDone BDDone))
         else
          match bound with
          | O => (initBDDconfig, (BDDzero, initBDDor_memo))
          | S bound' =>
              match BDDcompare (var cfg node1) (var cfg node2) with
              | Datatypes.Eq =>
                  match
                    BDDdummy3
                      (BDDor_1_1 cfg memo (low cfg node1) 
                         (low cfg node2) bound')
                  with
                  | BDDdummy3 (cfgl, (nodel, memol)) =>
                      match
                        BDDdummy3
                          (BDDor_1_1 cfgl memol (high cfg node1)
                             (high cfg node2) bound')
                      with
                      | BDDdummy3 (cfgr, (noder, memor)) =>
                          match
                            BDDdummy2
                              (BDDmake cfgr (var cfg node1) nodel noder)
                          with
                          | BDDdummy2 (cfg', node') =>
                              (cfg',
                              (node', BDDor_memo_put memor node1 node2 node'))
                          end
                      end
                  end
              | Datatypes.Lt =>
                  match
                    BDDdummy3
                      (BDDor_1_1 cfg memo node1 (low cfg node2) bound')
                  with
                  | BDDdummy3 (cfgl, (nodel, memol)) =>
                      match
                        BDDdummy3
                          (BDDor_1_1 cfgl memol node1 (high cfg node2) bound')
                      with
                      | BDDdummy3 (cfgr, (noder, memor)) =>
                          match
                            BDDdummy2
                              (BDDmake cfgr (var cfg node2) nodel noder)
                          with
                          | BDDdummy2 (cfg', node') =>
                              (cfg',
                              (node', BDDor_memo_put memor node1 node2 node'))
                          end
                      end
                  end
              | Datatypes.Gt =>
                  match
                    BDDdummy3
                      (BDDor_1_1 cfg memo (low cfg node1) node2 bound')
                  with
                  | BDDdummy3 (cfgl, (nodel, memol)) =>
                      match
                        BDDdummy3
                          (BDDor_1_1 cfgl memol (high cfg node1) node2 bound')
                      with
                      | BDDdummy3 (cfgr, (noder, memor)) =>
                          match
                            BDDdummy2
                              (BDDmake cfgr (var cfg node1) nodel noder)
                          with
                          | BDDdummy2 (cfg', node') =>
                              (cfg',
                              (node', BDDor_memo_put memor node1 node2 node'))
                          end
                      end
                  end
              end
          end
  end.

Lemma BDDor_1_1_eq_1 :
 forall (bound : nat) (cfg : BDDconfig) (memo : BDDor_memo)
   (node1 node2 : ad),
 BDDor_1_1 cfg memo node1 node2 bound = BDDor_1 cfg memo node1 node2 bound.
Proof.
  simple induction bound.  simpl in |- *.  reflexivity.  intros n H cfg memo node1 node2.  simpl in |- *.  elim (BDDcompare (var cfg node1) (var cfg node2)).
  cut
   (BDDor_1_1 cfg memo (low cfg node1) (low cfg node2) n =
    BDDor_1 cfg memo (low cfg node1) (low cfg node2) n).
  intro H0.  rewrite H0.  elim (BDDor_1 cfg memo (low cfg node1) (low cfg node2) n).
  intros y y0.  elim y0; intros y1 y2.  simpl in |- *.  cut
   (BDDor_1_1 y y2 (high cfg node1) (high cfg node2) n =
    BDDor_1 y y2 (high cfg node1) (high cfg node2) n).
  intro H1.  rewrite H1.  elim (BDDor_1 y y2 (high cfg node1) (high cfg node2) n).
  intros y3 y4.  elim y4; intros y5 y6.  simpl in |- *.  elim (BDDmake y3 (var cfg node1) y1 y5).
  simpl in |- *.  reflexivity.  apply H.  apply H.  cut
   (BDDor_1_1 cfg memo node1 (low cfg node2) n =
    BDDor_1 cfg memo node1 (low cfg node2) n).
  intro H0.  rewrite H0.  elim (BDDor_1 cfg memo node1 (low cfg node2) n).  intros y y0.
  elim y0; intros y1 y2.  simpl in |- *.  cut
   (BDDor_1_1 y y2 node1 (high cfg node2) n =
    BDDor_1 y y2 node1 (high cfg node2) n).
  intro H1.  rewrite H1.  elim (BDDor_1 y y2 node1 (high cfg node2) n).  intros y3 y4.
  elim y4; intros y5 y6.  simpl in |- *.  elim (BDDmake y3 (var cfg node2) y1 y5).  simpl in |- *.
  reflexivity.  apply H.  apply H.  cut
   (BDDor_1_1 cfg memo (low cfg node1) node2 n =
    BDDor_1 cfg memo (low cfg node1) node2 n).
  intro H0.  rewrite H0.  elim (BDDor_1 cfg memo (low cfg node1) node2 n).  intros y y0.
  elim y0; intros y1 y2.  simpl in |- *.  cut
   (BDDor_1_1 y y2 (high cfg node1) node2 n =
    BDDor_1 y y2 (high cfg node1) node2 n).
  intro H1.  rewrite H1.  elim (BDDor_1 y y2 (high cfg node1) node2 n).  intros y3 y4.
  elim y4; intros y5 y6.  simpl in |- *.  simpl in |- *.  elim (BDDmake y3 (var cfg node1) y1 y5).
  simpl in |- *.  reflexivity.  apply H.  apply H.
Qed.

Lemma prod_sum :
 forall (A B : Set) (p : A * B), exists a : A, (exists b : B, p = (a, b)).
Proof.
  intros A B p.  elim p.  intros y y0.  split with y.  split with y0.  reflexivity.
Qed.

