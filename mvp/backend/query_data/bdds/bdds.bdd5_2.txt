
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import ZArith NArith Nnat Ndec Ndigits.
From IntMap Require Import Allmaps.
Require Import Wf_nat.

Require Import BDDvar_ad_nat.
(* BDDvar_ad_nat:
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import ZArith NArith Nnat Ndec Ndigits.
From IntMap Require Import Allmaps.
Definition BDDzero := N0.
Definition BDDone := Npos 1.

  Definition BDDvar := ad.

  Definition BDDcompare (x y : BDDvar) :=
    match x, y with
    | N0, N0 => Datatypes.Eq
    | N0, Npos _ => Datatypes.Lt
    | Npos _, N0 => Datatypes.Gt
    | Npos p1, Npos p2 => Pcompare p1 p2 Datatypes.Eq
    end.

Definition BDDvar_eq := Neqb.

  Definition ad_S (a : ad) :=
    match a with
    | N0 => Npos 1
    | Npos p => Npos (Psucc p)
    end.

  Lemma ad_S_is_S : forall a : ad, nat_of_N (ad_S a) = S (nat_of_N a).

Lemma lt_pred : forall x y : nat, x < y -> x <> 0 -> pred x < pred y.

Lemma O_N0 : forall x : ad, nat_of_N x = 0 -> x = N0.
Lemma INFERIEUR_neq_O :
 forall x y : ad, BDDcompare x y = Datatypes.Lt -> y <> N0.

 Lemma BDDcompare_trans :
  forall x y z : BDDvar,
  BDDcompare x y = Datatypes.Lt ->

  Lemma ad_S_le_then_le :
   forall x y : ad, Nleb (ad_S x) y = true -> Nleb x y = true.

  Lemma le_then_le_S :
   forall x y : ad, Nleb x y = true -> Nleb x (ad_S y) = true.

  Lemma ad_S_le_then_neq :
   forall x y : ad, Nleb (ad_S x) y = true -> Neqb x y = false.

  Lemma BDDcompare_succ :
   forall a : BDDvar, BDDcompare a (ad_S a) = Datatypes.Lt.

  Lemma BDDcompare_lt :
   forall x y : BDDvar,
   BDDcompare x y = Datatypes.Lt -> nat_of_N x < nat_of_N y.

Lemma BDDlt_compare :
 forall x y : BDDvar,
 nat_of_N x < nat_of_N y -> BDDcompare x y = Datatypes.Lt.

Lemma relation_sum :
 forall r : Datatypes.comparison,

Lemma BDD_EGAL_complete :
 forall x y : BDDvar, BDDcompare x y = Datatypes.Eq -> x = y.

  Lemma lt_trans_1 : forall x y z : nat, x < y -> y < S z -> x < z.

Lemma BDDcompare_sup_inf :
 forall x y : BDDvar,
 BDDcompare x y = Datatypes.Gt -> BDDcompare y x = Datatypes.Lt.

  Lemma BDDcompare_1 :
   forall x y : BDDvar,
   BDDcompare x y = Datatypes.Lt ->

Definition max (m n : nat) := if leb m n then n else m.

Lemma lt_max_1_2 :
 forall x1 y1 x2 y2 : nat, x1 < x2 -> y1 < y2 -> max x1 y1 < max x2 y2.

Lemma lt_max_2 :
 forall x1 y1 x2 y2 : nat, x1 < y2 -> y1 < y2 -> max x1 y1 < max x2 y2.

Lemma lt_max_12 :
 forall x1 y1 x2 y2 : nat, x1 < x2 -> y1 < x2 -> max x1 y1 < max x2 y2.

Lemma BDDcompare_eq :
 forall x y : BDDvar, BDDcompare x y = Datatypes.Eq -> x = y. *)
Require Import bdd1.
(* bdd1:
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import ZArith NArith Nnat Ndec Ndigits.
From IntMap Require Import Allmaps.
Require Import Wf_nat.

Require Import BDDvar_ad_nat.

  Definition BDDstate := Map (BDDvar * (ad * ad)).
	  Definition initBDDstate := newMap (BDDvar * (ad * ad)).

  Inductive BDDbounded (bs : BDDstate) : ad -> BDDvar -> Prop :=
    | BDDbounded_0 : forall n : BDDvar, BDDbounded bs BDDzero n
    | BDDbounded_1 : forall n : BDDvar, BDDbounded bs BDDone n
    | BDDbounded_2 :
        forall (node : ad) (n x : BDDvar) (l r : ad),
        MapGet _ bs node = Some (x, (l, r)) ->
        BDDcompare x n = Datatypes.Lt ->
        Neqb l r = false ->
        BDDbounded bs l x -> BDDbounded bs r x -> BDDbounded bs node n.

  Lemma BDDbounded_lemma :
   forall (bs : BDDstate) (node : ad) (n : BDDvar),
   BDDbounded bs node n ->
   node = BDDzero \/
   node = BDDone \/
   (exists x : BDDvar,
      (exists l : BDDvar,
         (exists r : BDDvar,
            MapGet _ bs node = Some (x, (l, r)) /\
            BDDcompare x n = Datatypes.Lt /\

  Lemma increase_bound :
   forall (bs : BDDstate) (n n' : BDDvar) (node : ad),
   BDDbounded bs node n ->
   BDDcompare n n' = Datatypes.Lt -> BDDbounded bs node n'.

  Lemma boundedness_preservation :
   forall bs bs' : BDDstate,
   (forall (a l r : ad) (x : BDDvar),
    MapGet _ bs a = Some (x, (l, r)) -> MapGet _ bs' a = Some (x, (l, r))) ->
   forall (n : BDDvar) (node : ad),
   BDDbounded bs node n -> BDDbounded bs' node n.

  Definition BDDordered (bs : BDDstate) (node : ad) :=
    match MapGet _ bs node with
    | None => True
    | Some (n, _) => BDDbounded bs node (ad_S n)
    end.

  Definition BDD_OK (bs : BDDstate) (node : ad) := BDDordered bs node.

  Definition BDDstate_OK (bs : BDDstate) :=
    MapGet _ bs BDDzero = None /\
    MapGet _ bs BDDone = None /\
    (forall a : ad, in_dom _ a bs = true -> BDD_OK bs a).

  Lemma initBDDstate_OK : BDDstate_OK initBDDstate.

  Definition BDDsharing_map := Map (Map (Map ad)).
	  Definition initBDDsharing_map := newMap (Map (Map ad)).

  Definition BDDshare_lookup (share : BDDsharing_map) 
    (x : BDDvar) (l r : ad) : option ad :=
    match MapGet _ share l with
    | None => None
    | Some m1 =>
        match MapGet _ m1 r with
        | None => None
        | Some m2 =>
            match MapGet _ m2 x with
            | None => None
            | Some y => Some y
            end
        end
    end.

  Definition BDDshare_put (share : BDDsharing_map) 
    (x : BDDvar) (l r counter : ad) : BDDsharing_map :=
    let m1 :=
      match MapGet _ share l with
      | Some y => y
      | None => newMap (Map ad)
      end in
    let m2 :=
      match MapGet _ m1 r with
      | Some y => y
      | None => newMap ad
      end in
    let m2' := MapPut _ m2 x counter in
    let m1' := MapPut _ m1 r m2' in MapPut _ share l m1'.

  Lemma BDDshare_put_puts :
   forall (share : BDDsharing_map) (x : BDDvar) (l r counter : ad),
   BDDshare_lookup (BDDshare_put share x l r counter) x l r = Some counter.

  Lemma BDDshare_put_no_new_node :
   forall (share : BDDsharing_map) (x x' : BDDvar)
     (l l' r r' counter counter' : ad),
   BDDshare_lookup (BDDshare_put share x l r counter) x' l' r' =
   Some counter' ->
   BDDshare_lookup share x' l' r' = Some counter' \/
   (x, (l, r)) = (x', (l', r')).

  Lemma BDDshare_put_preserves_nodes :
   forall (share : BDDsharing_map) (x x' : BDDvar)
     (l l' r r' counter counter' : ad),
   BDDshare_lookup share x' l' r' = Some counter' ->
   (x, (l, r)) <> (x', (l', r')) ->
   BDDshare_lookup (BDDshare_put share x l r counter) x' l' r' =
   Some counter'.

  Definition BDDsharing_OK (bs : BDDstate) (share : BDDsharing_map) :=
    forall (x : BDDvar) (l r a : ad),
    BDDshare_lookup share x l r = Some a <->
    MapGet _ bs a = Some (x, (l, r)).

  Lemma initBDDsharing_map_OK : BDDsharing_OK initBDDstate initBDDsharing_map.

  Definition BDDconfig := (BDDstate * (BDDsharing_map * ad))%type.

  Definition initBDDconfig :=
    (initBDDstate, (initBDDsharing_map, ad_S (ad_S N0))).

  Definition BDDconfig_OK (cfg : BDDconfig) :=
    match cfg return Prop with
    | (bs, (share, counter)) =>
        BDDstate_OK bs /\
        BDDsharing_OK bs share /\
        (forall a : ad, Nleb counter a = true -> MapGet _ bs a = None) /\
        Nleb (ad_S (ad_S N0)) counter = true
    end.

  Lemma initBDDconfig_OK : BDDconfig_OK initBDDconfig.

  Lemma config_OK_zero :
   forall cfg : BDDconfig,
   BDDconfig_OK cfg -> MapGet _ (fst cfg) BDDzero = None.

  Lemma config_OK_one :
   forall cfg : BDDconfig,
   BDDconfig_OK cfg -> MapGet _ (fst cfg) BDDone = None.

  Definition BDDalloc (cfg : BDDconfig) (x : BDDvar) 
    (l r : ad) :=
    match cfg with
    | (bs, (share, counter)) =>
        let share' := BDDshare_put share x l r counter in
        let bs' := MapPut _ bs counter (x, (l, r)) in
        let counter' := ad_S counter in (bs', (share', counter'), counter)
    end.

  Lemma BDDsharing_lookup_semantics :
   forall (bs : BDDstate) (share : BDDsharing_map) (n l r : ad) (x : BDDvar),
   BDDsharing_OK bs share ->
   (BDDshare_lookup share x l r = Some n <->
    MapGet _ bs n = Some (x, (l, r))).

  Definition node_OK (bs : BDDstate) (node : ad) :=
    node = BDDzero \/ node = BDDone \/ in_dom _ node bs = true.

  Lemma BDDbounded_node_OK :
   forall (bs : BDDstate) (node : ad) (n : BDDvar),
   BDDbounded bs node n -> node_OK bs node.

  Lemma BDDalloc_allocates :
   forall (cfg : BDDconfig) (l r : ad) (x : BDDvar),
   MapGet _ (fst (fst (BDDalloc cfg x l r))) (snd (BDDalloc cfg x l r)) =
   Some (x, (l, r)).

  Lemma BDDalloc_preserves_nodes :
   forall (cfg : BDDconfig) (l r : ad) (x : BDDvar),
   BDDconfig_OK cfg ->
   forall (a l1 r1 : ad) (x1 : BDDvar),
   MapGet _ (fst cfg) a = Some (x1, (l1, r1)) ->
   MapGet _ (fst (fst (BDDalloc cfg x l r))) a = Some (x1, (l1, r1)).

  Lemma BDDalloc_no_new_node :
   forall (cfg : BDDconfig) (l l1 r r1 a : ad) (x x1 : BDDvar),
   MapGet _ (fst (fst (BDDalloc cfg x l r))) a = Some (x1, (l1, r1)) ->
   a = snd (snd cfg) \/ MapGet _ (fst cfg) a = Some (x1, (l1, r1)).

  Lemma BDDalloc_no_new_node_1 :
   forall (cfg : BDDconfig) (l l1 r r1 a : ad) (x x1 : BDDvar),
   MapGet _ (fst (fst (BDDalloc cfg x l r))) a = Some (x1, (l1, r1)) ->
   (x1, (l1, r1)) = (x, (l, r)) \/
   MapGet _ (fst cfg) a = Some (x1, (l1, r1)).

  Lemma BDDalloc_preserves_zero :
   forall (cfg : BDDconfig) (l r : ad) (x : BDDvar),
   BDDconfig_OK cfg ->
   MapGet _ (fst (fst (BDDalloc cfg x l r))) BDDzero = None.

  Lemma BDDalloc_preserves_one :
   forall (cfg : BDDconfig) (l r : ad) (x : BDDvar),
   BDDconfig_OK cfg ->
   MapGet _ (fst (fst (BDDalloc cfg x l r))) BDDone = None.

  Lemma BDDalloc_keeps_state_OK :
   forall (cfg : BDDconfig) (l r : ad) (x : BDDvar),
   BDDconfig_OK cfg ->
   node_OK (fst cfg) l ->
   node_OK (fst cfg) r ->
   Neqb l r <> true ->
   (forall (xl : BDDvar) (ll rl : ad),
    MapGet _ (fst cfg) l = Some (xl, (ll, rl)) ->
    BDDcompare xl x = Datatypes.Lt) ->

  Lemma BDDalloc_adjusts_counter :
   forall (cfg : BDDconfig) (x : BDDvar) (l r a : ad),
   BDDconfig_OK cfg ->
   (forall a : ad,
    Nleb (snd (snd (fst (BDDalloc cfg x l r)))) a = true ->
    MapGet _ (fst (fst (BDDalloc cfg x l r))) a = None) /\
   Nleb (ad_S (ad_S N0)) (snd (snd (fst (BDDalloc cfg x l r)))) = true.

Lemma BDDalloc_keeps_sharing_OK :
 forall (cfg : BDDconfig) (l r : ad) (x : BDDvar),
 BDDconfig_OK cfg ->
 node_OK (fst cfg) l ->
 node_OK (fst cfg) r ->
 (forall (x' : BDDvar) (l' r' a : ad),
  MapGet _ (fst cfg) a = Some (x', (l', r')) ->
  (x, (l, r)) <> (x', (l', r'))) ->
 BDDsharing_OK (fst (fst (BDDalloc cfg x l r)))
   (fst (snd (fst (BDDalloc cfg x l r)))).

  Lemma BDDalloc_semantics :
   forall (cfg : BDDconfig) (l r : ad) (x : BDDvar),
   BDDconfig_OK cfg ->
   node_OK (fst cfg) l ->
   node_OK (fst cfg) r ->
   Neqb l r <> true ->
   (forall (xl : BDDvar) (ll rl : ad),
    MapGet _ (fst cfg) l = Some (xl, (ll, rl)) ->
    BDDcompare xl x = Datatypes.Lt) ->

  Definition BDDmake (cfg : BDDconfig) (x : BDDvar) 
    (l r : ad) :=
    if Neqb l r
    then (cfg, l)
    else
     match cfg with
     | (bs, (share, counter)) =>
         match BDDshare_lookup share x l r with
         | Some y => (cfg, y)
         | None => BDDalloc cfg x l r
         end
     end.

  Lemma BDDmake_semantics :
   forall (cfg : BDDconfig) (l r : ad) (x : BDDvar),
   BDDconfig_OK cfg ->
   node_OK (fst cfg) l ->
   node_OK (fst cfg) r ->
   (forall (xl : BDDvar) (ll rl : ad),
    MapGet _ (fst cfg) l = Some (xl, (ll, rl)) ->
    BDDcompare xl x = Datatypes.Lt) -> *)
Require Import bdd2.
(* bdd2:
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import ZArith NArith Nnat Ndec Ndigits.
From IntMap Require Import Allmaps.
Require Import Wf_nat.

Require Import BDDvar_ad_nat.
Require Import bdd1.

Definition var (cfg : BDDconfig) (node : ad) :=
  match MapGet _ (fst cfg) node with
  | None =>   BDDzero
  | Some (x, (l, r)) => x
  end.

Definition low (cfg : BDDconfig) (node : ad) :=
  match MapGet _ (fst cfg) node with
  | None =>   N0
  | Some (x, (l, r)) => l
  end.

Definition high (cfg : BDDconfig) (node : ad) :=
  match MapGet _ (fst cfg) node with
  | None =>   N0
  | Some (x, (l, r)) => r
  end.

Definition config_node_OK (cfg : BDDconfig) := node_OK (fst cfg).
Definition is_internal_node (cfg : BDDconfig) (node : ad) :=
  exists x : BDDvar,
    (exists l : ad,
       (exists r : ad, MapGet _ (fst cfg) node = Some (x, (l, r)))).

Lemma BDDvar_ordered_low :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node ->
 is_internal_node cfg (low cfg node) ->
 BDDcompare (var cfg (low cfg node)) (var cfg node) = Datatypes.Lt.

Lemma BDDvar_ordered_high :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node ->
 is_internal_node cfg (high cfg node) ->
 BDDcompare (var cfg (high cfg node)) (var cfg node) = Datatypes.Lt.

Definition var_binding := BDDvar -> bool.
 
Definition bool_fun := var_binding -> bool.

Definition bool_fun_eval (bf : bool_fun) (vb : var_binding) := bf vb.

Definition bool_fun_zero (vb : var_binding) := false. 
Definition bool_fun_one (vb : var_binding) := true. 

Fixpoint bool_fun_of_BDD_1 (cfg : BDDconfig) (node : ad) 
 (bound : nat) {struct bound} : bool_fun :=
  match MapGet _ (fst cfg) node with
  | None => if Neqb node BDDzero then bool_fun_zero else bool_fun_one
  | Some (x, (l, r)) =>
      match bound with
      | O =>   bool_fun_zero
      | S bound' =>
          let bfl := bool_fun_of_BDD_1 cfg l bound' in
          let bfr := bool_fun_of_BDD_1 cfg r bound' in
          fun vb : var_binding => if vb x then bfr vb else bfl vb
      end
  end.

Lemma bool_fun_of_BDD_1_semantics :
 forall cfg : BDDconfig,
 BDDconfig_OK cfg ->
 forall bound : nat,
 bool_fun_of_BDD_1 cfg BDDzero bound = bool_fun_zero /\
 bool_fun_of_BDD_1 cfg BDDone bound = bool_fun_one /\
 (forall node : ad,
  is_internal_node cfg node ->
  nat_of_N (var cfg node) < bound ->
  forall vb : var_binding,
  (vb (var cfg node) = true ->
   bool_fun_eval (bool_fun_of_BDD_1 cfg node bound) vb =
   bool_fun_eval (bool_fun_of_BDD_1 cfg (high cfg node) (pred bound)) vb) /\
  (vb (var cfg node) = false ->
   bool_fun_eval (bool_fun_of_BDD_1 cfg node bound) vb =
   bool_fun_eval (bool_fun_of_BDD_1 cfg (low cfg node) (pred bound)) vb)).

Lemma bool_fun_of_BDD_1_semantics_1 :
 forall cfg : BDDconfig,
 BDDconfig_OK cfg ->
 forall bound : nat,
 bool_fun_of_BDD_1 cfg BDDzero bound = bool_fun_zero /\
 bool_fun_of_BDD_1 cfg BDDone bound = bool_fun_one /\
 (forall node : ad,
  is_internal_node cfg node ->
  nat_of_N (var cfg node) < bound ->
  bool_fun_of_BDD_1 cfg node bound =
  (fun vb : var_binding =>
   if vb (var cfg node)
   then bool_fun_of_BDD_1 cfg (high cfg node) (pred bound) vb
   else bool_fun_of_BDD_1 cfg (low cfg node) (pred bound) vb)).

Lemma bool_fun_of_BDD_1_semantics_2 :
 forall (cfg : BDDconfig) (node : ad) (bound1 bound2 : nat),
 MapGet _ (fst cfg) node = None ->
 bool_fun_of_BDD_1 cfg node bound1 = bool_fun_of_BDD_1 cfg node bound2.

Lemma bool_fun_of_BDD_1_change_bound :
 forall cfg : BDDconfig,
 BDDconfig_OK cfg ->
 forall (bound : nat) (node : ad),
 nat_of_N (var cfg node) < bound ->
 bool_fun_of_BDD_1 cfg node bound =
 bool_fun_of_BDD_1 cfg node (S (nat_of_N (var cfg node))).

Definition bool_fun_of_BDD (cfg : BDDconfig) (node : ad) :=
  bool_fun_of_BDD_1 cfg node (S (nat_of_N (var cfg node))).

Lemma bool_fun_of_BDD_semantics :
 forall cfg : BDDconfig,
 BDDconfig_OK cfg ->
 bool_fun_of_BDD cfg BDDzero = bool_fun_zero /\
 bool_fun_of_BDD cfg BDDone = bool_fun_one /\
 (forall node : ad,
  is_internal_node cfg node ->
  bool_fun_of_BDD cfg node =
  (fun vb : var_binding =>
   if vb (var cfg node)
   then bool_fun_of_BDD cfg (high cfg node) vb
   else bool_fun_of_BDD cfg (low cfg node) vb)).

Definition bool_fun_eq (bf1 bf2 : bool_fun) :=
  forall vb : var_binding, bool_fun_eval bf1 vb = bool_fun_eval bf2 vb.

Lemma bool_fun_eq_symm :
 forall bf1 bf2 : bool_fun, bool_fun_eq bf1 bf2 -> bool_fun_eq bf2 bf1.

Lemma bool_fun_eq_trans :
 forall bf1 bf2 bf3 : bool_fun,
 bool_fun_eq bf1 bf2 -> bool_fun_eq bf2 bf3 -> bool_fun_eq bf1 bf3.

Definition bool_fun_neg (bf : bool_fun) : bool_fun :=
  fun vb : var_binding => negb (bf vb).
Definition bool_fun_or (bf1 bf2 : bool_fun) : bool_fun :=
  fun vb : var_binding => bf1 vb || bf2 vb.

Lemma bool_fun_neg_semantics :
 forall (bf : bool_fun) (vb : var_binding),
 (bool_fun_eval bf vb = true -> bool_fun_eval (bool_fun_neg bf) vb = false) /\
 (bool_fun_eval bf vb = false -> bool_fun_eval (bool_fun_neg bf) vb = true).

Lemma bool_fun_neg_zero : bool_fun_neg bool_fun_zero = bool_fun_one.

Lemma bool_fun_neg_one : bool_fun_neg bool_fun_one = bool_fun_zero.

Lemma bool_fun_eq_neg :
 forall bf1 bf2 : bool_fun,
 bool_fun_eq (bool_fun_neg bf1) (bool_fun_neg bf2) -> bool_fun_eq bf1 bf2.

Lemma bool_fun_eq_neg_1 :
 forall bf1 bf2 : bool_fun,
 bool_fun_eq bf1 bf2 -> bool_fun_eq (bool_fun_neg bf1) (bool_fun_neg bf2).

Definition BDDneg_memo := Map ad.
Definition BDDneg_memo_lookup (memo : BDDneg_memo) 
  (a : ad) := MapGet _ memo a.
Definition BDDneg_memo_put (memo : BDDneg_memo) (a node : ad) :=
  MapPut _ memo a node.

Definition BDDneg_memo_OK (cfg : BDDconfig) (memo : BDDneg_memo) :=
  forall a node : ad,
  BDDneg_memo_lookup memo a = Some node ->
  config_node_OK cfg node /\
  bool_fun_of_BDD cfg node = bool_fun_neg (bool_fun_of_BDD cfg a) /\
  var cfg a = var cfg node. 

Fixpoint BDDneg_2 (cfg : BDDconfig) (node : ad) (bound : nat) {struct bound} 
   : BDDconfig * ad :=
  match MapGet _ (fst cfg) node with
  | None => if Neqb node BDDzero then (cfg, BDDone) else (cfg, BDDzero)
  | Some (x, (l, r)) =>
      match bound with
      | O =>   (initBDDconfig, BDDzero)
      | S bound' =>
          BDDmake (fst (BDDneg_2 (fst (BDDneg_2 cfg l bound')) r bound')) x
            (snd (BDDneg_2 cfg l bound'))
            (snd (BDDneg_2 (fst (BDDneg_2 cfg l bound')) r bound'))
      end
  end. *)
Require Import bdd3.
(* bdd3:
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import ZArith NArith Nnat Ndec Ndigits.
From IntMap Require Import Allmaps.
Require Import Wf_nat.

Require Import BDDvar_ad_nat.
Require Import bdd1.
Require Import bdd2.

Lemma bool_fun_one_zero_eq : ~ bool_fun_eq bool_fun_one bool_fun_zero.

Lemma bool_fun_zero_one_eq : ~ bool_fun_eq bool_fun_zero bool_fun_one.

Definition augment (vb : var_binding) (x : BDDvar) 
  (b : bool) (y : BDDvar) := if BDDvar_eq x y then b else vb y.

Definition bool_fun_restrict (bf : bool_fun) (x : BDDvar) 
  (b : bool) (vb : var_binding) := bool_fun_eval bf (augment vb x b).

Lemma bool_fun_restrict_zero :
 forall (x : BDDvar) (b : bool),
 bool_fun_eq (bool_fun_restrict bool_fun_zero x b) bool_fun_zero. 

Lemma bool_fun_restrict_one :
 forall (x : BDDvar) (b : bool),
 bool_fun_eq (bool_fun_restrict bool_fun_one x b) bool_fun_one.

Lemma bool_fun_restrict_eq :
 forall (bf bf' : bool_fun) (x : BDDvar) (b : bool),
 bool_fun_eq bf bf' ->
 bool_fun_eq (bool_fun_restrict bf x b) (bool_fun_restrict bf' x b).

Definition var_binding_eq (vb vb' : var_binding) :=
  forall x : BDDvar, vb x = vb' x.

Definition bool_fun_ext (bf : bool_fun) :=
  forall vb vb' : var_binding,
  var_binding_eq vb vb' -> bool_fun_eval bf vb = bool_fun_eval bf vb'.

Lemma bool_fun_of_BDD_1_ext :
 forall (bound : nat) (cfg : BDDconfig) (node : ad),
 bool_fun_ext (bool_fun_of_BDD_1 cfg node bound). 

Lemma bool_fun_of_BDD_ext :
 forall (cfg : BDDconfig) (node : ad),
 bool_fun_ext (bool_fun_of_BDD cfg node).

Lemma augment_eq :
 forall (vb : var_binding) (x : BDDvar) (b : bool),
 vb x = b -> var_binding_eq (augment vb x b) vb.

Definition bool_fun_independent (bf : bool_fun) (x : BDDvar) :=
  forall vb : var_binding,
  bool_fun_eval bf (augment vb x true) =
  bool_fun_eval bf (augment vb x false).

Lemma bool_fun_independent_lemma :
 forall (bf : bool_fun) (x : BDDvar) (vb : var_binding) (b : bool),
 bool_fun_ext bf ->
 bool_fun_independent bf x ->
 bool_fun_eval bf (augment vb x b) = bool_fun_eval bf vb. 

Lemma bool_fun_independent_zero :
 forall (cfg : BDDconfig) (x : BDDvar),
 BDDconfig_OK cfg -> bool_fun_independent (bool_fun_of_BDD cfg BDDzero) x.

Lemma bool_fun_independent_one :
 forall (cfg : BDDconfig) (x : BDDvar),
 BDDconfig_OK cfg -> bool_fun_independent (bool_fun_of_BDD cfg BDDone) x.

Lemma in_dom_is_internal :
 forall (cfg : BDDconfig) (node : ad),
 in_dom _ node (fst cfg) = true -> is_internal_node cfg node.

Lemma internal_node_lemma :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node ->
 Neqb (low cfg node) (high cfg node) = false /\
 BDDbounded (fst cfg) (low cfg node) (var cfg node) /\
 BDDbounded (fst cfg) (high cfg node) (var cfg node).

Lemma high_bounded :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node ->
 BDDbounded (fst cfg) (high cfg node) (var cfg node).

Lemma low_bounded :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node ->
 BDDbounded (fst cfg) (low cfg node) (var cfg node).

Lemma high_OK :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node -> config_node_OK cfg (high cfg node).

Lemma low_OK :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node -> config_node_OK cfg (low cfg node).

Lemma low_high_neq :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node -> Neqb (low cfg node) (high cfg node) = false.

Lemma BDDvar_independent_1 :
 forall (cfg : BDDconfig) (n : nat) (node : ad) (x : BDDvar),
 BDDconfig_OK cfg ->
 is_internal_node cfg node ->
 n = nat_of_N (var cfg node) ->
 BDDcompare (var cfg node) x = Datatypes.Lt ->

Lemma BDDvar_independent_high :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node ->
 bool_fun_independent (bool_fun_of_BDD cfg (high cfg node)) (var cfg node).

Lemma BDDvar_independent_low :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node ->
 bool_fun_independent (bool_fun_of_BDD cfg (low cfg node)) (var cfg node).

Lemma bool_fun_of_BDDzero :
 forall cfg : BDDconfig,
 BDDconfig_OK cfg -> bool_fun_eq (bool_fun_of_BDD cfg BDDzero) bool_fun_zero.

Lemma bool_fun_of_BDDone :
 forall cfg : BDDconfig,
 BDDconfig_OK cfg -> bool_fun_eq (bool_fun_of_BDD cfg BDDone) bool_fun_one.

Lemma bool_fun_of_BDDhigh :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node ->
 bool_fun_eq (bool_fun_of_BDD cfg (high cfg node))
   (bool_fun_restrict (bool_fun_of_BDD cfg node) (var cfg node) true).

Lemma bool_fun_of_BDDlow :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node ->
 bool_fun_eq (bool_fun_of_BDD cfg (low cfg node))
   (bool_fun_restrict (bool_fun_of_BDD cfg node) (var cfg node) false).

Lemma internal_node_not_constant_1 :
 forall cfg : BDDconfig,
 BDDconfig_OK cfg ->
 forall (n : nat) (node : ad),
 is_internal_node cfg node ->
 n = nat_of_N (var cfg node) ->
 ~ bool_fun_eq (bool_fun_of_BDD cfg node) bool_fun_zero /\
 ~ bool_fun_eq (bool_fun_of_BDD cfg node) bool_fun_one.

Lemma internal_node_not_constant :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node ->
 ~ bool_fun_eq (bool_fun_of_BDD cfg node) bool_fun_zero /\
 ~ bool_fun_eq (bool_fun_of_BDD cfg node) bool_fun_one.

Lemma bool_fun_neq_internal_zero :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node ->
 ~ bool_fun_eq (bool_fun_of_BDD cfg node) (bool_fun_of_BDD cfg BDDzero).
 
Lemma bool_fun_neq_internal_one :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node ->
 ~ bool_fun_eq (bool_fun_of_BDD cfg node) (bool_fun_of_BDD cfg BDDone).

Lemma bool_fun_neq_zero_one :
 forall cfg : BDDconfig,
 BDDconfig_OK cfg ->
 ~ bool_fun_eq (bool_fun_of_BDD cfg BDDzero) (bool_fun_of_BDD cfg BDDone).

Lemma bool_fun_neq_one_zero :
 forall cfg : BDDconfig,
 BDDconfig_OK cfg ->
 ~ bool_fun_eq (bool_fun_of_BDD cfg BDDone) (bool_fun_of_BDD cfg BDDzero).

Lemma bool_fun_neq_lemma :
 forall bf1 bf2 : bool_fun, ~ bool_fun_eq bf1 bf2 -> ~ bool_fun_eq bf2 bf1.

Lemma no_duplicate_node :
 forall (cfg : BDDconfig) (node1 node2 : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node1 ->
 is_internal_node cfg node2 ->
 var cfg node1 = var cfg node2 ->
 high cfg node1 = high cfg node2 ->
 low cfg node1 = low cfg node2 -> node1 = node2.

Lemma BDDunique_1 :
 forall cfg : BDDconfig,
 BDDconfig_OK cfg ->
 forall (n : nat) (node1 node2 : ad),
 n = max (nat_of_N (var cfg node1)) (nat_of_N (var cfg node2)) ->
 config_node_OK cfg node1 ->
 config_node_OK cfg node2 ->
 bool_fun_eq (bool_fun_of_BDD cfg node1) (bool_fun_of_BDD cfg node2) ->
 node1 = node2.

Lemma BDDunique :
 forall cfg : BDDconfig,
 BDDconfig_OK cfg ->
 forall node1 node2 : ad,
 config_node_OK cfg node1 ->
 config_node_OK cfg node2 ->
 bool_fun_eq (bool_fun_of_BDD cfg node1) (bool_fun_of_BDD cfg node2) ->
 node1 = node2.

Lemma bool_fun_eq_lemma :
 forall (bf1 bf2 : bool_fun) (x : BDDvar),
 bool_fun_ext bf1 ->
 bool_fun_ext bf2 ->
 bool_fun_eq (bool_fun_restrict bf1 x true) (bool_fun_restrict bf2 x true) ->
 bool_fun_eq (bool_fun_restrict bf1 x false) (bool_fun_restrict bf2 x false) ->
 bool_fun_eq bf1 bf2.
  
Lemma bool_fun_preservation_1 :
 forall cfg cfg' : BDDconfig,
 BDDconfig_OK cfg ->
 BDDconfig_OK cfg' ->
 (forall (x : BDDvar) (l r a : ad),
  MapGet _ (fst cfg) a = Some (x, (l, r)) ->
  MapGet _ (fst cfg') a = Some (x, (l, r))) ->
 forall (n : nat) (node : ad),
 n = nat_of_N (var cfg node) ->
 config_node_OK cfg node ->
 bool_fun_eq (bool_fun_of_BDD cfg' node) (bool_fun_of_BDD cfg node).

Lemma bool_fun_preservation :
 forall (cfg cfg' : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 BDDconfig_OK cfg' ->
 (forall (x : BDDvar) (l r a : ad),
  MapGet _ (fst cfg) a = Some (x, (l, r)) ->
  MapGet _ (fst cfg') a = Some (x, (l, r))) ->
 config_node_OK cfg node ->
 bool_fun_eq (bool_fun_of_BDD cfg' node) (bool_fun_of_BDD cfg node). *)
Require Import bdd4.
(* bdd4:
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import ZArith NArith Nnat Ndec Ndigits.
From IntMap Require Import Allmaps.
Require Import Wf_nat.

Require Import BDDvar_ad_nat.
Require Import bdd1.
Require Import bdd2.
Require Import bdd3.

Lemma BDDneg_2_lemma :
 forall (bound : nat) (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 config_node_OK cfg node ->
 (is_internal_node cfg node -> nat_of_N (var cfg node) < bound) ->
 BDDconfig_OK (fst (BDDneg_2 cfg node bound)) /\
 (forall (x : BDDvar) (l r a : ad),
  MapGet _ (fst cfg) a = Some (x, (l, r)) ->
  MapGet _ (fst (fst (BDDneg_2 cfg node bound))) a = Some (x, (l, r))) /\
 (is_internal_node cfg node ->
  is_internal_node (fst (BDDneg_2 cfg node bound))
    (snd (BDDneg_2 cfg node bound)) /\
  var cfg node =
  var (fst (BDDneg_2 cfg node bound)) (snd (BDDneg_2 cfg node bound))) /\
 config_node_OK (fst (BDDneg_2 cfg node bound))
   (snd (BDDneg_2 cfg node bound)) /\
 bool_fun_eq
   (bool_fun_of_BDD (fst (BDDneg_2 cfg node bound))
      (snd (BDDneg_2 cfg node bound)))
   (bool_fun_neg (bool_fun_of_BDD cfg node)). *)
Require Import bdd5_1.
(* bdd5_1:
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import ZArith NArith Nnat Ndec Ndigits.
From IntMap Require Import Allmaps.
Require Import Wf_nat.

Require Import BDDvar_ad_nat.
Require Import bdd1.
Require Import bdd2.
Require Import bdd3.
Require Import bdd4.

Definition BDDneg_memo_OK_1 (cfg : BDDconfig) (memo : BDDneg_memo) :=
  forall (node node' : ad) (bound : nat),
  config_node_OK cfg node ->
  BDDneg_memo_lookup memo node = Some node' ->
  (is_internal_node cfg node -> nat_of_N (var cfg node) < bound) ->
  BDDneg_2 cfg node bound = (cfg, node').

Definition BDDneg_memo_OK_2 (cfg : BDDconfig) (memo : BDDneg_memo) :=
  forall (node node' : ad) (bound : nat),
  BDDneg_memo_lookup memo node = Some node' ->
  (is_internal_node cfg node -> nat_of_N (var cfg node) < bound) ->
  config_node_OK cfg node /\ BDDneg_2 cfg node bound = (cfg, node').

Fixpoint BDDneg_1 (arg : BDDconfig * ad * BDDneg_memo) 
 (bound : nat) {struct bound} : BDDconfig * ad * BDDneg_memo :=
  match BDDneg_memo_lookup (snd arg) (snd (fst arg)) with
  | Some node => (fst (fst arg), node, snd arg)
  | None =>
      match MapGet _ (fst (fst (fst arg))) (snd (fst arg)) with
      | None =>
          if Neqb (snd (fst arg)) BDDzero
          then
           (fst (fst arg), BDDone, BDDneg_memo_put (snd arg) BDDzero BDDone)
          else
           (fst (fst arg), BDDzero, BDDneg_memo_put (snd arg) BDDone BDDzero)
      | Some (x, (l, r)) =>
          match bound with
          | O => (initBDDconfig, BDDzero, newMap ad)
          | S bound' =>
              (BDDmake
                 (fst
                    (fst
                       (BDDneg_1
                          (fst
                             (fst
                                (BDDneg_1 (fst (fst arg), l, snd arg) bound')),
                          r,
                          snd (BDDneg_1 (fst (fst arg), l, snd arg) bound'))
                          bound'))) x
                 (snd (fst (BDDneg_1 (fst (fst arg), l, snd arg) bound')))
                 (snd
                    (fst
                       (BDDneg_1
                          (fst
                             (fst
                                (BDDneg_1 (fst (fst arg), l, snd arg) bound')),
                          r,
                          snd (BDDneg_1 (fst (fst arg), l, snd arg) bound'))
                          bound'))),
              BDDneg_memo_put
                (snd
                   (BDDneg_1
                      (fst
                         (fst (BDDneg_1 (fst (fst arg), l, snd arg) bound')),
                      r, snd (BDDneg_1 (fst (fst arg), l, snd arg) bound'))
                      bound')) (snd (fst arg))
                (snd
                   (BDDmake
                      (fst
                         (fst
                            (BDDneg_1
                               (fst
                                  (fst
                                     (BDDneg_1 (fst (fst arg), l, snd arg)
                                        bound')), r,
                               snd
                                 (BDDneg_1 (fst (fst arg), l, snd arg) bound'))
                               bound'))) x
                      (snd
                         (fst (BDDneg_1 (fst (fst arg), l, snd arg) bound')))
                      (snd
                         (fst
                            (BDDneg_1
                               (fst
                                  (fst
                                     (BDDneg_1 (fst (fst arg), l, snd arg)
                                        bound')), r,
                               snd
                                 (BDDneg_1 (fst (fst arg), l, snd arg) bound'))
                               bound'))))))
          end
      end
  end.

Lemma BDDneg_1_lemma_1 :
 forall (arg : BDDconfig * ad * BDDneg_memo) (node : ad) (bound : nat),
 BDDneg_memo_lookup (snd arg) (snd (fst arg)) = Some node ->
 BDDneg_1 arg bound = (fst (fst arg), node, snd arg).

Lemma BDDneg_1_lemma_2 :
 forall (arg : BDDconfig * ad * BDDneg_memo) (bound : nat),
 BDDneg_memo_lookup (snd arg) (snd (fst arg)) = None ->
 MapGet _ (fst (fst (fst arg))) (snd (fst arg)) = None ->
 BDDneg_1 arg bound =
 (if Neqb (snd (fst arg)) BDDzero
  then (fst (fst arg), BDDone, BDDneg_memo_put (snd arg) BDDzero BDDone)
  else (fst (fst arg), BDDzero, BDDneg_memo_put (snd arg) BDDone BDDzero)).

Lemma BDDneg_1_lemma_3 :
 forall (arg : BDDconfig * ad * BDDneg_memo) (x : BDDvar) (l r : ad),
 BDDneg_memo_lookup (snd arg) (snd (fst arg)) = None ->
 MapGet _ (fst (fst (fst arg))) (snd (fst arg)) = Some (x, (l, r)) ->
 BDDneg_1 arg 0 = (initBDDconfig, BDDzero, newMap ad).

Lemma nat_sum : forall n : nat, {m : nat | n = S m} + {n = 0}.

Lemma BDDneg_1_lemma_4 :
 forall (arg : BDDconfig * ad * BDDneg_memo) (x : BDDvar) 
   (l r : ad) (bound bound' : nat),
 bound = S bound' ->
 BDDneg_memo_lookup (snd arg) (snd (fst arg)) = None ->
 MapGet _ (fst (fst (fst arg))) (snd (fst arg)) = Some (x, (l, r)) ->
 BDDneg_1 arg bound =
 (BDDmake
    (fst
       (fst
          (BDDneg_1
             (fst (fst (BDDneg_1 (fst (fst arg), l, snd arg) bound')), r,
             snd (BDDneg_1 (fst (fst arg), l, snd arg) bound')) bound'))) x
    (snd (fst (BDDneg_1 (fst (fst arg), l, snd arg) bound')))
    (snd
       (fst
          (BDDneg_1
             (fst (fst (BDDneg_1 (fst (fst arg), l, snd arg) bound')), r,
             snd (BDDneg_1 (fst (fst arg), l, snd arg) bound')) bound'))),
 BDDneg_memo_put
   (snd
      (BDDneg_1
         (fst (fst (BDDneg_1 (fst (fst arg), l, snd arg) bound')), r,
         snd (BDDneg_1 (fst (fst arg), l, snd arg) bound')) bound'))
   (snd (fst arg))
   (snd
      (BDDmake
         (fst
            (fst
               (BDDneg_1
                  (fst (fst (BDDneg_1 (fst (fst arg), l, snd arg) bound')),
                  r, snd (BDDneg_1 (fst (fst arg), l, snd arg) bound'))
                  bound'))) x
         (snd (fst (BDDneg_1 (fst (fst arg), l, snd arg) bound')))
         (snd
            (fst
               (BDDneg_1
                  (fst (fst (BDDneg_1 (fst (fst arg), l, snd arg) bound')),
                  r, snd (BDDneg_1 (fst (fst arg), l, snd arg) bound'))
                  bound')))))).

Lemma bool_fun_restrict_neg_1 :
 forall (bf : bool_fun) (x : BDDvar) (b : bool),
 bool_fun_ext bf ->
 bool_fun_eq (bool_fun_restrict (bool_fun_neg bf) x b)
   (bool_fun_neg (bool_fun_restrict bf x b)).

Lemma bool_fun_neg_eq_var_2 :
 forall (cfg : BDDconfig) (node node' : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node ->
 is_internal_node cfg node' ->
 bool_fun_eq (bool_fun_of_BDD cfg node')
   (bool_fun_neg (bool_fun_of_BDD cfg node)) -> var cfg node = var cfg node'.

Lemma BDDneg_memo_OK_1_lemma_1_1_1 :
 forall (bound : nat) (cfg : BDDconfig) (node node' : ad),
 BDDconfig_OK cfg ->
 config_node_OK cfg node ->
 config_node_OK cfg node' ->
 (is_internal_node cfg node -> nat_of_N (var cfg node) < bound) ->
 bool_fun_eq (bool_fun_of_BDD cfg node')
   (bool_fun_neg (bool_fun_of_BDD cfg node)) ->
 BDDneg_2 cfg node bound = (cfg, node').

Lemma BDDneg_memo_OK_1_2 :
 forall (cfg : BDDconfig) (memo : BDDneg_memo),
 BDDneg_memo_OK_2 cfg memo -> BDDneg_memo_OK_1 cfg memo.

Lemma BDDneg_memo_OK_bool_fun_1 :
 forall (cfg : BDDconfig) (memo : BDDneg_memo) (node node' : ad),
 BDDconfig_OK cfg ->
 BDDneg_memo_OK_1 cfg memo ->
 config_node_OK cfg node ->
 BDDneg_memo_lookup memo node = Some node' ->
 bool_fun_eq (bool_fun_of_BDD cfg node')
   (bool_fun_neg (bool_fun_of_BDD cfg node)).

Lemma BDDneg_memo_OK_bool_fun_1' :
 forall (cfg : BDDconfig) (memo : BDDneg_memo) (node node' : ad),
 BDDconfig_OK cfg ->
 BDDneg_memo_OK_2 cfg memo ->
 config_node_OK cfg node ->
 BDDneg_memo_lookup memo node = Some node' ->
 bool_fun_eq (bool_fun_of_BDD cfg node')
   (bool_fun_neg (bool_fun_of_BDD cfg node)).

Definition nodes_preserved (cfg cfg' : BDDconfig) :=
  forall (x : BDDvar) (l r node : ad),
  MapGet _ (fst cfg) node = Some (x, (l, r)) ->
  MapGet _ (fst cfg') node = Some (x, (l, r)).

Lemma BDDmake_preserves_nodes :
 forall (cfg : BDDconfig) (x : BDDvar) (l r : ad),
 BDDconfig_OK cfg -> nodes_preserved cfg (fst (BDDmake cfg x l r)).

Lemma nodes_preserved_2 :
 forall (cfg cfg' : BDDconfig) (node : ad),
 config_node_OK cfg node ->
 nodes_preserved cfg cfg' -> config_node_OK cfg' node.

Lemma BDDneg_2_config_OK_lemma_2 :
 forall (cfg : BDDconfig) (node : ad) (x : BDDvar) (l r : ad) (n m : nat),
 BDDconfig_OK cfg ->
 MapGet _ (fst cfg) node = Some (x, (l, r)) ->
 nat_of_N (var cfg node) < n ->
 n = S m -> BDDconfig_OK (fst (BDDneg_2 (fst (BDDneg_2 cfg l m)) r m)).

Lemma nodes_preserved_1 :
 forall (cfg : BDDconfig) (node : ad) (n m : nat) (x : BDDvar) (l r : ad),
 BDDconfig_OK cfg ->
 MapGet _ (fst cfg) node = Some (x, (l, r)) ->
 n = S m ->
 nat_of_N (var cfg node) < n ->
 nodes_preserved (fst (BDDneg_2 (fst (BDDneg_2 cfg l m)) r m))
   (fst (BDDneg_2 cfg node n)).

Lemma BDDneg_memo_OK_lemma_1_4' :
 forall (cfg : BDDconfig) (memo : BDDneg_memo) (node node' : ad),
 BDDconfig_OK cfg ->
 BDDneg_memo_OK_2 cfg memo ->
 config_node_OK cfg node ->
 BDDneg_memo_lookup memo node = Some node' -> config_node_OK cfg node'. *)

Lemma BDDneg_memo_OK_1_lemma_2_1' :
 forall (cfg : BDDconfig) (memo : BDDneg_memo),
 BDDconfig_OK cfg ->
 BDDneg_memo_OK_2 cfg memo ->
 BDDneg_memo_OK_2 cfg (BDDneg_memo_put memo BDDzero BDDone).
Proof.
  intro cfg.  elim cfg; clear cfg; intros bs y; elim y; clear y; intros share counter.
  intros memo H H0.  unfold BDDneg_memo_OK_2 in |- *.  intros node node' bound H1 H2.  unfold BDDneg_memo_put, BDDneg_memo_lookup in H1.
  rewrite (MapPut_semantics ad memo BDDzero BDDone node) in H1.  elim (sumbool_of_bool (Neqb BDDzero node)).
  intro y.  cut (BDDzero = node).  intro H3.  rewrite y in H1.  injection H1.  intros H4.
  rewrite <- H3.  rewrite <- H4.  split.  left; reflexivity.  elim bound.
  simpl in |- *.  elim H.  intros H5 H6.  elim H5; intros.  rewrite H7.  reflexivity.  
  intros n H5.  simpl in |- *.  elim H.  intros H6 H7.  elim H6; intros.  simpl in H9.  rewrite H8.
  reflexivity.  apply Neqb_complete.  assumption.  intro y.  rewrite y in H1.
  unfold BDDneg_memo_OK_2 in H0.  apply H0.  assumption.  assumption.
Qed.

Lemma BDDneg_memo_OK_1_lemma_3_1' :
 forall (cfg : BDDconfig) (memo : BDDneg_memo),
 BDDconfig_OK cfg ->
 BDDneg_memo_OK_2 cfg memo ->
 BDDneg_memo_OK_2 cfg (BDDneg_memo_put memo BDDone BDDzero).
Proof.
  intro cfg.  elim cfg; clear cfg; intros bs y; elim y; clear y; intros share counter.
  intros memo H H0.  unfold BDDneg_memo_OK_2 in |- *.  intros node node' bound H1 H2.  unfold BDDneg_memo_put, BDDneg_memo_lookup in H1.
  rewrite (MapPut_semantics ad memo BDDone BDDzero node) in H1.  elim (sumbool_of_bool (Neqb BDDone node)).
  intro y.  cut (BDDone = node).  intro H3.  rewrite y in H1.  injection H1.  intros H4.
  rewrite <- H3.  rewrite <- H4.  split.  right; left; reflexivity.  elim bound.
  simpl in |- *.  elim H.  intros H5 H6.  elim H5; intros.  rewrite (proj1 H8).  reflexivity.
  intros n H5.  simpl in |- *.  elim H.  intros H6 H7.  elim H6; intros.  rewrite (proj1 H9).
  reflexivity.  apply Neqb_complete.  assumption.  intro y.  rewrite y in H1.  unfold BDDneg_memo_OK_2 in H0.
  apply H0.  assumption.  assumption.
Qed.

Lemma BDDneg_memo_OK_1_lemma_1_2' :
 forall (cfg : BDDconfig) (x : BDDvar) (l r node : ad) 
   (n m : nat) (memo : BDDneg_memo),
 BDDconfig_OK cfg ->
 MapGet _ (fst cfg) node = Some (x, (l, r)) ->
 nat_of_N (var cfg node) < n ->
 n = S m ->
 BDDneg_memo_OK_2 (fst (BDDneg_2 (fst (BDDneg_2 cfg l m)) r m)) memo ->
 BDDneg_memo_OK_2 (fst (BDDneg_2 cfg node n))
   (BDDneg_memo_put memo node (snd (BDDneg_2 cfg node n))).
Proof.
  intro cfg.  elim cfg; clear cfg; intros bs y; elim y; clear y; intros share counter.
  intros x l r node n m memo H H0 H1.  intro H3.  intros H2.  unfold BDDneg_memo_OK_2 in |- *.
  intros node0 node' bound H4 H5.  unfold BDDneg_memo_put, BDDneg_memo_lookup in H4.  rewrite
   (MapPut_semantics ad memo node
      (snd (BDDneg_2 (bs, (share, counter)) node n)) node0)
    in H4.
  elim (sumbool_of_bool (Neqb node node0)).  intro y.  rewrite y in H4.  injection H4; intros.
  cut (node = node0).  intro H7.  rewrite <- H7.  rewrite <- H7 in H5.  split.
  apply nodes_preserved_2 with (cfg := (bs, (share, counter))).  right; right.  unfold in_dom in |- *.
  rewrite H0.  reflexivity.  unfold nodes_preserved in |- *.  cut (config_node_OK (bs, (share, counter)) node).
  cut
   (is_internal_node (bs, (share, counter)) node ->
    nat_of_N (var (bs, (share, counter)) node) < n).
  intros H8 H9.  exact
   (proj1 (proj2 (BDDneg_2_lemma n (bs, (share, counter)) node H H9 H8))).
  intro; assumption.  right; right.  unfold in_dom in |- *.  rewrite H0; reflexivity.
  apply BDDneg_memo_OK_1_lemma_1_1_1.  cut (config_node_OK (bs, (share, counter)) node).
  intro H8.  cut
   (is_internal_node (bs, (share, counter)) node ->
    nat_of_N (var (bs, (share, counter)) node) < n).
  intros H9.  exact (proj1 (BDDneg_2_lemma n (bs, (share, counter)) node H H8 H9)).
  intro H9.  assumption.  right.  right.  unfold in_dom in |- *.  rewrite H0.  reflexivity.
  apply nodes_preserved_2 with (cfg := (bs, (share, counter))).  right; right.  unfold in_dom in |- *.
  rewrite H0.  reflexivity.  unfold nodes_preserved in |- *.  cut (config_node_OK (bs, (share, counter)) node).
  cut
   (is_internal_node (bs, (share, counter)) node ->
    nat_of_N (var (bs, (share, counter)) node) < n).
  intros H8 H9.  exact
   (proj1 (proj2 (BDDneg_2_lemma n (bs, (share, counter)) node H H9 H8))).
  intro; assumption.  right; right.  unfold in_dom in |- *.  rewrite H0; reflexivity.
  rewrite <- H6.  cut (config_node_OK (bs, (share, counter)) node).  intro H8.
  cut
   (is_internal_node (bs, (share, counter)) node ->
    nat_of_N (var (bs, (share, counter)) node) < n).
  intros H9.  exact
   (proj1
      (proj2
         (proj2
            (proj2 (BDDneg_2_lemma n (bs, (share, counter)) node H H8 H9))))).  
  intro; assumption.  right; right.  unfold in_dom in |- *.  rewrite H0; reflexivity.
  assumption.  rewrite <- H6.  cut (config_node_OK (bs, (share, counter)) node).
  intro H8.  cut
   (is_internal_node (bs, (share, counter)) node ->
    nat_of_N (var (bs, (share, counter)) node) < n).
  intro H9.  apply
   bool_fun_eq_trans
    with (bf2 := bool_fun_neg (bool_fun_of_BDD (bs, (share, counter)) node)).
  exact
   (proj2
      (proj2
         (proj2
            (proj2 (BDDneg_2_lemma n (bs, (share, counter)) node H H8 H9))))).
  apply bool_fun_eq_neg_1.  apply bool_fun_eq_symm.  apply bool_fun_preservation.
  assumption.  exact (proj1 (BDDneg_2_lemma n (bs, (share, counter)) node H H8 H9)).
  exact
   (proj1 (proj2 (BDDneg_2_lemma n (bs, (share, counter)) node H H8 H9))).
  assumption.  intro; assumption.  right; right.  unfold in_dom in |- *.  rewrite H0.
  reflexivity.  apply Neqb_complete.  assumption.  intro y.  rewrite y in H4.
  unfold BDDneg_memo_OK_2 in H2.  split.  apply
   nodes_preserved_2
    with
      (cfg := fst (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l m)) r m)).
  cut
   (is_internal_node
      (fst (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l m)) r m)) node0 ->
    nat_of_N
      (var (fst (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l m)) r m))
         node0) <
    S
      (nat_of_N
         (var
            (fst (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l m)) r m))
            node0))).
  intro H6.  exact
   (proj1
      (H2 node0 node'
         (S
            (nat_of_N
               (var
                  (fst
                     (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l m)) r
                        m)) node0))) H4 H6)).
  intro H6.  unfold lt in |- *.  apply le_n.  apply nodes_preserved_1 with (n := n) (x := x).
  assumption.  assumption.  assumption.  assumption.  apply BDDneg_memo_OK_1_lemma_1_1_1.
  cut (config_node_OK (bs, (share, counter)) node).  intro H6.  cut
   (is_internal_node (bs, (share, counter)) node ->
    nat_of_N (var (bs, (share, counter)) node) < n).
  intro H7.  exact (proj1 (BDDneg_2_lemma n (bs, (share, counter)) node H H6 H7)).
  intro H7.  assumption.  right.  right.  unfold in_dom in |- *.  rewrite H0.  reflexivity.
  apply
   nodes_preserved_2
    with
      (cfg := fst (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l m)) r m)).
  cut
   (is_internal_node
      (fst (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l m)) r m)) node0 ->
    nat_of_N
      (var (fst (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l m)) r m))
         node0) <
    S
      (nat_of_N
         (var
            (fst (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l m)) r m))
            node0))).
  intro H6.  exact
   (proj1
      (H2 node0 node'
         (S
            (nat_of_N
               (var
                  (fst
                     (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l m)) r
                        m)) node0))) H4 H6)).
  intro H6.  unfold lt in |- *.  apply le_n.  apply nodes_preserved_1 with (n := n) (x := x).  assumption.
  assumption.  assumption.  assumption.  cut
   (config_node_OK
      (fst (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l m)) r m)) node').
  intro H6.  cut
   (nodes_preserved
      (fst (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l m)) r m))
      (fst (BDDneg_2 (bs, (share, counter)) node n))).
  intro H7.  apply
   nodes_preserved_2
    with
      (cfg := fst (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l m)) r m)).
  assumption.  assumption.  apply nodes_preserved_1 with (x := x).  assumption.  
  assumption.  assumption.  assumption.  apply BDDneg_memo_OK_lemma_1_4' with (memo := memo) (node := node0).
  apply BDDneg_2_config_OK_lemma_2 with (n := n) (x := x) (node := node).  assumption.  assumption.
  assumption.  assumption.  assumption.  cut
   (is_internal_node
      (fst (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l m)) r m)) node0 ->
    nat_of_N
      (var (fst (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l m)) r m))
         node0) <
    S
      (nat_of_N
         (var
            (fst (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l m)) r m))
            node0))).
  intro H6.  exact
   (proj1
      (H2 node0 node'
         (S
            (nat_of_N
               (var
                  (fst
                     (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l m)) r
                        m)) node0))) H4 H6)).
  intro H6.  unfold lt in |- *.  apply le_n.  assumption.  assumption.  apply
   bool_fun_eq_trans
    with
      (bf2 := bool_fun_of_BDD
                (fst
                   (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l m)) r m))
                node').
  apply bool_fun_preservation.  apply BDDneg_2_config_OK_lemma_2 with (node := node) (x := x) (n := n).
  assumption.  assumption.  assumption.  assumption.  cut (config_node_OK (bs, (share, counter)) node).
  intro H6.  cut
   (is_internal_node (bs, (share, counter)) node ->
    nat_of_N (var (bs, (share, counter)) node) < n).
  intro H7.  exact (proj1 (BDDneg_2_lemma n (bs, (share, counter)) node H H6 H7)).  
  intro; assumption.  right; right.  unfold in_dom in |- *.  rewrite H0.  reflexivity.
  cut
   (nodes_preserved
      (fst (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l m)) r m))
      (fst (BDDneg_2 (bs, (share, counter)) node n))).
  unfold nodes_preserved in |- *.  intro H6.  assumption.  apply nodes_preserved_1 with (x := x).
  assumption.  assumption.  assumption.  assumption.  apply BDDneg_memo_OK_lemma_1_4' with (memo := memo) (node := node0).
  apply BDDneg_2_config_OK_lemma_2 with (node := node) (x := x) (n := n).  assumption.  assumption.
  assumption.  assumption.  assumption.  cut
   (is_internal_node
      (fst (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l m)) r m)) node0 ->
    nat_of_N
      (var (fst (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l m)) r m))
         node0) <
    S
      (nat_of_N
         (var
            (fst (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l m)) r m))
            node0))).
  intro H6.  exact
   (proj1
      (H2 node0 node'
         (S
            (nat_of_N
               (var
                  (fst
                     (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l m)) r
                        m)) node0))) H4 H6)).
  intro H6.  unfold lt in |- *.  apply le_n.  assumption.  apply
   bool_fun_eq_trans
    with
      (bf2 := bool_fun_neg
                (bool_fun_of_BDD
                   (fst
                      (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l m)) r
                         m)) node0)).
  apply BDDneg_memo_OK_bool_fun_1' with (memo := memo).  apply BDDneg_2_config_OK_lemma_2 with (node := node) (x := x) (n := n).
  assumption.  assumption.  assumption.  assumption.  assumption.  cut
   (is_internal_node
      (fst (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l m)) r m)) node0 ->
    nat_of_N
      (var (fst (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l m)) r m))
         node0) <
    S
      (nat_of_N
         (var
            (fst (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l m)) r m))
            node0))).
  intro H6.  exact
   (proj1
      (H2 node0 node'
         (S
            (nat_of_N
               (var
                  (fst
                     (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l m)) r
                        m)) node0))) H4 H6)).
  intro H6.  unfold lt in |- *.  apply le_n.  assumption.  apply bool_fun_eq_neg_1.  apply bool_fun_eq_symm.
  apply bool_fun_preservation.  apply BDDneg_2_config_OK_lemma_2 with (n := n) (x := x) (node := node).
  assumption.  assumption.  assumption.  assumption.  cut (config_node_OK (bs, (share, counter)) node).
  intro H6.  cut
   (is_internal_node (bs, (share, counter)) node ->
    nat_of_N (var (bs, (share, counter)) node) < n).
  intro H7.  exact (proj1 (BDDneg_2_lemma n (bs, (share, counter)) node H H6 H7)).
  intro; assumption.  right; right.  unfold in_dom in |- *.  rewrite H0.  reflexivity.
  cut
   (nodes_preserved
      (fst (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l m)) r m))
      (fst (BDDneg_2 (bs, (share, counter)) node n))).
  unfold nodes_preserved in |- *.  intro H6.  assumption.  apply nodes_preserved_1 with (x := x).
  assumption.  assumption.  assumption.  assumption.  cut
   (is_internal_node
      (fst (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l m)) r m)) node0 ->
    nat_of_N
      (var (fst (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l m)) r m))
         node0) <
    S
      (nat_of_N
         (var
            (fst (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l m)) r m))
            node0))).
  intro H6.  exact
   (proj1
      (H2 node0 node'
         (S
            (nat_of_N
               (var
                  (fst
                     (BDDneg_2 (fst (BDDneg_2 (bs, (share, counter)) l m)) r
                        m)) node0))) H4 H6)).
  intro H6.  unfold lt in |- *.  apply le_n.
Qed.

Lemma BDDneg_1_lemma' :
 forall (bound : nat) (arg : BDDconfig * ad * BDDneg_memo),
 BDDconfig_OK (fst (fst arg)) ->
 config_node_OK (fst (fst arg)) (snd (fst arg)) ->
 BDDneg_memo_OK_2 (fst (fst arg)) (snd arg) ->
 (is_internal_node (fst (fst arg)) (snd (fst arg)) ->
  nat_of_N (var (fst (fst arg)) (snd (fst arg))) < bound) ->
 fst (BDDneg_1 arg bound) = BDDneg_2 (fst (fst arg)) (snd (fst arg)) bound /\
 BDDneg_memo_OK_2 (fst (fst (BDDneg_1 arg bound))) (snd (BDDneg_1 arg bound)).
Proof.
  intro bound.  apply
   lt_wf_ind
    with
      (P := fun bound : nat =>
            forall arg : BDDconfig * ad * BDDneg_memo,
            BDDconfig_OK (fst (fst arg)) ->
            config_node_OK (fst (fst arg)) (snd (fst arg)) ->
            BDDneg_memo_OK_2 (fst (fst arg)) (snd arg) ->
            (is_internal_node (fst (fst arg)) (snd (fst arg)) ->
             nat_of_N (var (fst (fst arg)) (snd (fst arg))) < bound) ->
            fst (BDDneg_1 arg bound) =
            BDDneg_2 (fst (fst arg)) (snd (fst arg)) bound /\
            BDDneg_memo_OK_2 (fst (fst (BDDneg_1 arg bound)))
              (snd (BDDneg_1 arg bound))).
  intros n H arg.  elim arg; clear arg; intro y.  elim y; clear y.  intros cfg node memo.
  intros H0 H1 H2 H3.  elim
   (option_sum _
      (BDDneg_memo_lookup (snd (cfg, node, memo))
         (snd (fst (cfg, node, memo))))).
  intro y.  elim y; clear y; intros node' H4.  rewrite (BDDneg_1_lemma_1 (cfg, node, memo) node' n H4).
  simpl in |- *.  split.  simpl in H2.  unfold BDDneg_memo_OK_2 in H2.  rewrite (proj2 (H2 node node' n H4 H3)).
  reflexivity.  assumption.  intro y.  elim
   (option_sum _
      (MapGet _ (fst (fst (fst (cfg, node, memo))))
         (snd (fst (cfg, node, memo))))).
  intro y0.  elim y0; clear y0.  intro x.  elim x; clear x.  intros x y0.  elim y0; clear y0; intros l r H4.
  elim (nat_sum n).  intros y0.  elim y0; clear y0.  intros m H5.  rewrite (BDDneg_1_lemma_4 (cfg, node, memo) x l r n m H5 y H4).

  simpl in |- *.  cut
   (fst (BDDneg_1 (cfg, l, memo) m) =
    BDDneg_2 (fst (fst (cfg, l, memo))) (snd (fst (cfg, l, memo))) m /\
    BDDneg_memo_OK_2 (fst (fst (BDDneg_1 (cfg, l, memo) m)))
      (snd (BDDneg_1 (cfg, l, memo) m))).
  intro H6.  cut
   (fst
      (BDDneg_1
         (fst
            (fst
               (BDDneg_1
                  (fst (fst (cfg, node, memo)), l, snd (cfg, node, memo)) m)),
         r,
         snd
           (BDDneg_1 (fst (fst (cfg, node, memo)), l, snd (cfg, node, memo))
              m)) m) =
    BDDneg_2
      (fst
         (fst
            (fst
               (fst
                  (BDDneg_1
                     (fst (fst (cfg, node, memo)), l, snd (cfg, node, memo))
                     m)), r,
            snd
              (BDDneg_1
                 (fst (fst (cfg, node, memo)), l, snd (cfg, node, memo)) m))))
      (snd
         (fst
            (fst
               (fst
                  (BDDneg_1
                     (fst (fst (cfg, node, memo)), l, snd (cfg, node, memo))
                     m)), r,
            snd
              (BDDneg_1
                 (fst (fst (cfg, node, memo)), l, snd (cfg, node, memo)) m))))
      m /\
    BDDneg_memo_OK_2
      (fst
         (fst
            (BDDneg_1
               (fst
                  (fst
                     (BDDneg_1
                        (fst (fst (cfg, node, memo)), l,
                        snd (cfg, node, memo)) m)), r,
               snd
                 (BDDneg_1
                    (fst (fst (cfg, node, memo)), l, snd (cfg, node, memo)) m))
               m)))
      (snd
         (BDDneg_1
            (fst
               (fst
                  (BDDneg_1
                     (fst (fst (cfg, node, memo)), l, snd (cfg, node, memo))
                     m)), r,
            snd
              (BDDneg_1
                 (fst (fst (cfg, node, memo)), l, snd (cfg, node, memo)) m))
            m))).  intro H7.  simpl in H6, H7. 
  rewrite (proj1 H7).  rewrite (proj1 H6).  cut
   (BDDmake (fst (BDDneg_2 (fst (BDDneg_2 cfg l m)) r m)) x
      (snd (BDDneg_2 cfg l m)) (snd (BDDneg_2 (fst (BDDneg_2 cfg l m)) r m)) =
    BDDneg_2 cfg node n).

  intro H8.  split.  assumption.  rewrite (proj1 H6) in H7.
  elim H7; intros. rewrite H9 in H7. clear H9 H10. 
  rewrite H8.  apply BDDneg_memo_OK_1_lemma_1_2' with (x := x) (l := l) (r := r) (m := m).  assumption.
  assumption.  apply H3.  split with x; split with l; split with r; assumption.
  assumption.  exact (proj2 H7).  rewrite H5.  simpl in |- *.  simpl in H4.  rewrite H4.
  reflexivity.  apply H.  rewrite H5.  unfold lt in |- *.  apply le_n.  simpl in |- *.  rewrite (proj1 H6).
  simpl in |- *.  cut (config_node_OK cfg l).  intro.  cut (is_internal_node cfg l -> nat_of_N (var cfg l) < m).
  intros H8.  exact (proj1 (BDDneg_2_lemma m cfg l H0 H7 H8)).  intro H8.  apply lt_trans_1 with (y := nat_of_N (var cfg node)).
  cut (l = low cfg node).  intro H9.  rewrite H9.  apply BDDcompare_lt.  apply BDDvar_ordered_low.

  assumption.  split with x; split with l; split with r.  assumption.  rewrite <- H9; assumption.
  unfold low in |- *.  simpl in H4.  rewrite H4.  reflexivity.  rewrite <- H5.  apply H3.
  simpl in |- *.  split with x; split with l; split with r; assumption.  cut (l = low cfg node); intros.
  rewrite H7.  apply low_OK.  assumption.  split with x; split with l; split with r; assumption.
  unfold low in |- *; simpl in H4; rewrite H4; reflexivity.  simpl in |- *.  rewrite (proj1 H6).
  simpl in |- *.  cut (config_node_OK cfg l).  intro H7.  cut (is_internal_node cfg l -> nat_of_N (var cfg l) < m).
  intro H8.  cut (config_node_OK cfg r).  intro H9.  elim H9; intro.  rewrite H10.
  left; reflexivity.  elim H10; intro.  rewrite H11; right; left; reflexivity.
  right; right.  unfold in_dom in |- *.  cut (is_internal_node cfg r).  intro H12.  inversion H12.
  inversion H13.  inversion H14.  simpl in H0.  simpl in |- *.  cut
   (MapGet (BDDvar * (ad * ad)) (fst (fst (BDDneg_2 cfg l m))) r =
    Some (x0, (x1, x2))).
  intro H16.  rewrite H16.  reflexivity.  exact (proj1 (proj2 (BDDneg_2_lemma m cfg l H0 H7 H8)) x0 x1 x2 r H15).
  apply in_dom_is_internal.  assumption.  cut (r = high cfg node).  intro H9.  rewrite H9.
  apply high_OK.  assumption.  split with x; split with l; split with r; assumption.  
  unfold high in |- *.  simpl in H4; rewrite H4; reflexivity.  intro H8.  apply lt_trans_1 with (y := nat_of_N (var cfg node)).
  apply BDDcompare_lt.  cut (l = low cfg node).  intro; rewrite H9.  apply BDDvar_ordered_low.
  assumption.  split with x; split with l; split with r; assumption.  rewrite <- H9; assumption.
  unfold low in |- *; simpl in H4; rewrite H4; reflexivity.  rewrite <- H5; apply H3.
  simpl in |- *.  split with x; split with l; split with r; assumption.  cut (l = low cfg node).
  intro H7.  rewrite H7.  apply low_OK.  assumption.  split with x; split with l; split with r; assumption.
  unfold low in |- *; simpl in H4; rewrite H4; reflexivity.  simpl in |- *.  exact (proj2 H6).

  simpl in |- *.  rewrite (proj1 H6).  simpl in |- *.  intro H7.  cut (var (fst (BDDneg_2 cfg l m)) r = var cfg r).
  intro H8.  rewrite H8.  apply lt_trans_1 with (y := nat_of_N (var cfg node)).  apply BDDcompare_lt.
  cut (r = high cfg node).  intro H9.  rewrite H9.  apply BDDvar_ordered_high.  assumption.
  split with x; split with l; split with r; assumption.  cut (config_node_OK cfg (high cfg node)).
  intro H10.  elim H10; intro.  inversion H7.  inversion H12.  inversion H13.
  rewrite H9 in H14; rewrite H11 in H14.  cut (BDDconfig_OK (fst (BDDneg_2 cfg l m))).
  intro H15.  rewrite (config_OK_zero (fst (BDDneg_2 cfg l m)) H15) in H14.  discriminate H14.
  cut (config_node_OK cfg l).  intro H15.  cut (is_internal_node cfg l -> nat_of_N (var cfg l) < m).
  intro H16.  exact (proj1 (BDDneg_2_lemma m cfg l H0 H15 H16)).  intro H16.  apply lt_trans_1 with (y := nat_of_N (var cfg node)).
  cut (l = low cfg node).  intro H17.  rewrite H17.  apply BDDcompare_lt.  apply BDDvar_ordered_low.
  assumption.  split with x; split with l; split with r; assumption.  rewrite <- H17; assumption.
  unfold low in |- *; simpl in H4; rewrite H4.  reflexivity.  rewrite <- H5; apply H3.
  simpl in |- *.  split with x; split with l; split with r; assumption.  cut (l = low cfg node).
  intro H15.  rewrite H15.  apply low_OK.  assumption.  split with x; split with l; split with r; assumption.
  unfold low in |- *; simpl in H4; rewrite H4; reflexivity.  elim H11; intro.  rewrite H9 in H7.
  rewrite H12 in H7.  inversion H7.  inversion H13.  inversion H14.  cut (BDDconfig_OK (fst (BDDneg_2 cfg l m))).
  intro H16.  rewrite (config_OK_one (fst (BDDneg_2 cfg l m)) H16) in H15.  discriminate H15.
  cut (config_node_OK cfg l).  intro H16.  cut (is_internal_node cfg l -> nat_of_N (var cfg l) < m).

  intros H17.  exact (proj1 (BDDneg_2_lemma m cfg l H0 H16 H17)).  intro H17.
  apply lt_trans_1 with (y := nat_of_N (var cfg node)).  cut (l = low cfg node).  
  intro H18.  rewrite H18.  apply BDDcompare_lt.  apply BDDvar_ordered_low.  assumption.
  split with x; split with l; split with r.  assumption.  rewrite <- H18; assumption.
  unfold low in |- *.  simpl in H4.  rewrite H4.  reflexivity.  rewrite <- H5.  apply H3.
  simpl in |- *.  split with x; split with l; split with r; assumption.  cut (l = low cfg node); intros.
  rewrite H16.  apply low_OK.  assumption.  split with x; split with l; split with r; assumption.
  unfold low in |- *; simpl in H4; rewrite H4; reflexivity.  apply in_dom_is_internal.
  assumption.  apply high_OK.  assumption.  split with x; split with l; split with r; assumption.
  unfold high in |- *.  simpl in H4; rewrite H4; reflexivity.  rewrite <- H5; apply H3.
  simpl in |- *.  split with x; split with l; split with r; assumption.  inversion H7.
  inversion H8.  inversion H9.  unfold var in |- *.  rewrite H10.  cut (l = low cfg node).
  cut (r = high cfg node).  intros H11 H12.  cut (config_node_OK cfg l).  cut (config_node_OK cfg r).
  intros H13 H14.  cut (BDDconfig_OK (fst (BDDneg_2 cfg l m))).  intro H15.  elim H13; intro.

  rewrite H16 in H10.  rewrite (config_OK_zero (fst (BDDneg_2 cfg l m)) H15) in H10; discriminate.
  elim H16; intro.  rewrite H17 in H10.  rewrite (config_OK_one (fst (BDDneg_2 cfg l m)) H15) in H10; discriminate.
  elim (option_sum _ (MapGet (BDDvar * (ad * ad)) (fst cfg) r)).  intro y0.  elim y0; intro x3.
  elim x3; intro y1; intro y2.  elim y2; intros y3 y4 y5.  rewrite y5.  cut (is_internal_node cfg l -> nat_of_N (var cfg l) < m).
  intro H18.  cut
   (MapGet (BDDvar * (ad * ad)) (fst (fst (BDDneg_2 cfg l m))) r =
    Some (y1, (y3, y4))).
  intro H19.  rewrite H19 in H10.  injection H10.  intros H20 H21 H22.  rewrite H22; reflexivity.
  exact (proj1 (proj2 (BDDneg_2_lemma m cfg l H0 H14 H18)) y1 y3 y4 r y5).
  intro H18.  apply lt_trans_1 with (y := nat_of_N (var cfg node)).  apply BDDcompare_lt.
  rewrite H12.  apply BDDvar_ordered_low.  assumption.  split with x; split with l; split with r; assumption.
  rewrite <- H12.  assumption.  rewrite <- H5.  apply H3.  simpl in |- *.  split with x; split with l; split with r; assumption.
  intro y0.  unfold in_dom in H17.  rewrite y0 in H17.  discriminate.  cut (is_internal_node cfg l -> nat_of_N (var cfg l) < m).
  intro H15.  exact (proj1 (BDDneg_2_lemma m cfg l H0 H14 H15)).  intro H15.  apply lt_trans_1 with (y := nat_of_N (var cfg node)).

  apply BDDcompare_lt.  rewrite H12.  apply BDDvar_ordered_low.  assumption.  
 split with x; split with l; split with r; assumption.  rewrite <- H12; assumption.
  rewrite <- H5; apply H3.  simpl in |- *.  split with x; split with l; split with r; assumption.
  rewrite H11.  apply high_OK.  assumption.  split with x; split with l; split with r; assumption.
  rewrite H12.  apply low_OK.  assumption.  split with x; split with l; split with r; assumption.
  unfold high in |- *; simpl in H4; rewrite H4; reflexivity.  unfold low in |- *; simpl in H4; rewrite H4; reflexivity.  
  apply H.  rewrite H5.  unfold lt in |- *.  apply le_n.  simpl in |- *.  assumption.  simpl in |- *.
  cut (l = low cfg node).  intro; rewrite H6.  apply low_OK.  assumption.  
  split with x; split with l; split with r; assumption.  unfold low in |- *; simpl in H4; rewrite H4; reflexivity.
  simpl in |- *.  assumption.  simpl in |- *.  intro H6.  apply lt_trans_1 with (y := nat_of_N (var cfg node)).
  apply BDDcompare_lt.  cut (l = low cfg node).  intro H7.  rewrite H7.  apply BDDvar_ordered_low.
  assumption.  split with x; split with l; split with r; assumption.  rewrite <- H7; assumption.
  unfold low in |- *; simpl in H4; rewrite H4; reflexivity.  rewrite <- H5; apply H3.
  simpl in |- *.  split with x; split with l; split with r; assumption.  intro y0.  rewrite y0.
  rewrite (BDDneg_1_lemma_3 (cfg, node, memo) x l r y H4).  simpl in |- *.  simpl in H4.
  rewrite H4.  split.  reflexivity.  unfold BDDneg_memo_OK_2 in |- *.  intros node0 node' bound0 H5 H6.  unfold BDDneg_memo_lookup in H5.
  rewrite (newMap_semantics ad node0) in H5.  discriminate.  simpl in |- *.  intro y0.  rewrite (BDDneg_1_lemma_2 (cfg, node, memo) n y y0).
  simpl in |- *.  unfold BDDneg_2 in |- *.  elim n; rewrite y0.  elim (Neqb node BDDzero).

  simpl in |- *.  split.  reflexivity.  apply BDDneg_memo_OK_1_lemma_2_1'.  assumption.
  assumption.  simpl in |- *.  split.  reflexivity.  apply BDDneg_memo_OK_1_lemma_3_1'.
  assumption. assumption.
  fold BDDneg_2 in |- *.  intro n0.  intro H4.  elim (Neqb node BDDzero).  simpl in |- *.  split.
  reflexivity.  apply BDDneg_memo_OK_1_lemma_2_1'.  assumption.  assumption.
  simpl in |- *.  split.
  reflexivity.  apply BDDneg_memo_OK_1_lemma_3_1'.  assumption.  assumption.
Qed.