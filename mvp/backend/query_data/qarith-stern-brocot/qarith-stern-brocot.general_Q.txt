
Require Import FunInd.
Require Export Qpositive.
(* Qpositive:
Require Export Arith.
Require Export Compare_dec.
Require Export ArithRing.
Require Export Omega.
Require Export ZArith.
Require Export ZArithRing.
 
Ltac CaseEq f := generalize (refl_equal f); pattern f at -1 in |- *; case f.
 
Inductive Qpositive : Set :=
  | nR : Qpositive -> Qpositive
  | dL : Qpositive -> Qpositive
  | One : Qpositive.
 
Fixpoint Qpositive_i (w : Qpositive) : nat * nat :=
  match w with
  | One => (1, 1)
  | nR w' => match Qpositive_i w' with
             | (p, q) => (p + q, q)
             end
  | dL w' => match Qpositive_i w' with
             | (p, q) => (p, p + q)
             end
  end.
Coercion Z_of_nat : nat >-> Z.
 
Theorem interp_reduced_fraction :
 forall w : Qpositive,
 exists a : Z,
   (exists b : Z, (a * fst (Qpositive_i w) + b * snd (Qpositive_i w))%Z = 1%Z).
 
Fixpoint Qpositive_inv (w : Qpositive) : Qpositive :=
  match w with
  | One => One
  | nR w' => dL (Qpositive_inv w')
  | dL w' => nR (Qpositive_inv w')
  end.
 
Theorem inv_correct :
 forall (w : Qpositive) (p q : nat),
 Qpositive_i w = (p, q) -> Qpositive_i (Qpositive_inv w) = (q, p).
 
Theorem interp_non_zero :
 forall w : Qpositive,
 exists p : nat, (exists q : nat, Qpositive_i w = (S p, S q)).
 
Fixpoint Qpositive_c (p q n : nat) {struct n} : Qpositive :=
  match n with
  | O => One
  | S n' =>
      match p - q with
      | O => match q - p with
             | O => One
             | v => dL (Qpositive_c p v n')
             end
      | v => nR (Qpositive_c v q n')
      end
  end.
 
Theorem minus_O_le : forall n m : nat, n - m = 0 -> n <= m.
 
Theorem le_minus_O : forall n m : nat, n <= m -> n - m = 0.
 
Theorem minus_le : forall m n : nat, m - n <= m.
 
Theorem mult_reg_l : forall n m p : nat, S n * m = S n * p -> m = p.
 
Theorem absolu_inj_nat : forall x : nat, Z.abs_nat (Z_of_nat x) = x.
 
Theorem absolu_mult :
 forall x y : Z, Z.abs_nat (x * y) = Z.abs_nat x * Z.abs_nat y.
 
Theorem Qpositive_c_unfold1 :
 forall p q n : nat,
 S p + S q + S q <= S n ->
 Qpositive_c (S p + S q) (S q) (S n) = nR (Qpositive_c (S p) (S q) n).
 
Theorem Qpositive_c_unfold2 :
 forall p q n : nat,
 S p + (S p + S q) <= S n ->
 Qpositive_c (S p) (S p + S q) (S n) = dL (Qpositive_c (S p) (S q) n).
 
Theorem construct_correct :
 forall (w : Qpositive) (p q n : nat),
 Qpositive_i w = (p, q) -> p + q <= n -> Qpositive_c p q n = w.
 
Theorem construct_correct2 :
 forall n p q : nat,
 S p + S q <= n ->
 exists d : nat,
   S p = fst (Qpositive_i (Qpositive_c (S p) (S q) n)) * S d /\
   S q = snd (Qpositive_i (Qpositive_c (S p) (S q) n)) * S d.
 
Theorem construct_correct2' :
 forall n p q : nat,
 1 <= p ->
 1 <= q ->
 p + q <= n ->
 exists d : nat,
   p = fst (Qpositive_i (Qpositive_c p q n)) * S d /\
   q = snd (Qpositive_i (Qpositive_c p q n)) * S d.
 
Theorem construct_correct3 :
 forall n n' p q p' q' d : nat,
 S p = S d * p' ->
 S q = S d * q' ->
 S p + S q <= S n ->
 p' + q' <= S n' -> Qpositive_c (S p) (S q) (S n) = Qpositive_c p' q' (S n').
 
Theorem construct_correct4 :
 forall p q p' q' n n' : nat,
 S p + S q <= S n ->
 S p' + S q' <= S n' ->
 S p * S q' = S p' * S q ->
 Qpositive_c (S p) (S q) (S n) = Qpositive_c (S p') (S q') (S n').
 
Theorem construct_correct4' :
 forall p q p' q' n n' : nat,
 1 <= p ->
 1 <= q ->
 1 <= p' ->
 1 <= q' ->
 p + q <= n ->
 p' + q' <= n' -> p * q' = p' * q -> Qpositive_c p q n = Qpositive_c p' q' n'.
 
Theorem interp_inject :
 forall w w' : Qpositive, Qpositive_i w = Qpositive_i w' -> w = w'.
 
Theorem minus_decompose :
 forall a b c d : nat, a = b -> c = d -> a - c = b - d.
 
Theorem Qpositive_c_equiv :
 forall n p q n' p' q' : nat,
 S p + S q <= n ->
 S p' + S q' <= n' ->
 Qpositive_c (S p) (S q) n = Qpositive_c (S p') (S q') n' ->
 S p * S q' = S p' * S q.
 
Theorem Qpositive_c_equiv' :
 forall n p q n' p' q' : nat,
 1 <= p ->
 1 <= q ->
 1 <= p' ->
 1 <= q' ->
 p + q <= n ->
 p' + q' <= n' -> Qpositive_c p q n = Qpositive_c p' q' n' -> p * q' = p' * q. *)
Require Export Q_field.
(* Q_field:
Require Export Qpositive_sub.

Inductive Q : Set :=
  | Zero : Q
  | Qpos : Qpositive -> Q
  | Qneg : Qpositive -> Q.
 
Definition Qone := Qpos One.
 
Definition Qpositive_le_dec :
  forall w w' : Qpositive, {Qpositive_le w w'} + {~ Qpositive_le w w'}.

Ltac Case' f :=
  match constr:(f) with
  | (Qpositive_le_dec ?X1 ?X2) =>
      case f;
       [ idtac
       | intros Dummy;
          generalize (not_Qpositive_le_not_eq _ _ Dummy)
           (not_Qpositive_le_Qpositive_le' _ _ Dummy) Dummy; 
          clear Dummy ]
  | _ => case f
  end.

Definition Qpositive_eq_dec : forall w w' : Qpositive, {w = w'} + {w <> w'}.
 
Definition Qplus (x y : Q) :=
  match x, y with
  | Qpos x', Qpos y' => Qpos (Qpositive_plus x' y')
  | Qpos x', Qneg y' =>
      match Qpositive_le_dec x' y' with
      | left h =>
          match Qpositive_eq_dec x' y' with
          | left h => Zero
          | right h => Qneg (Qpositive_sub y' x')
          end
      | right h => Qpos (Qpositive_sub x' y')
      end
  | Qneg x', Qneg y' => Qneg (Qpositive_plus x' y')
  | Qneg x', Qpos y' =>
      match Qpositive_le_dec x' y' with
      | left h =>
          match Qpositive_eq_dec x' y' with
          | left h => Zero
          | right h => Qpos (Qpositive_sub y' x')
          end
      | right h => Qneg (Qpositive_sub x' y')
      end
  | Qneg x', Zero => Qneg x'
  | Qpos x', Zero => Qpos x'
  | Zero, x => x
  end.
 
Definition Qmult (x y : Q) :=
  match x, y with
  | Qpos x', Qpos y' => Qpos (Qpositive_mult x' y')
  | Qpos x', Qneg y' => Qneg (Qpositive_mult x' y')
  | Qneg x', Qpos y' => Qneg (Qpositive_mult x' y')
  | Qneg x', Qneg y' => Qpos (Qpositive_mult x' y')
  | _, _ => Zero
  end.
 
Definition Qopp (x : Q) :=
  match x with
  | Zero => Zero
  | Qpos x' => Qneg x'
  | Qneg x' => Qpos x'
  end.
 
Theorem Qplus_sym : forall a b : Q, Qplus a b = Qplus b a.
 
Theorem Qplus_zero_left : forall n : Q, Qplus Zero n = n.
 
Theorem add_sub_le1 :
 forall a b c : Qpositive,
 a <> b ->
 Qpositive_le b a ->
 Qpositive_le (Qpositive_sub a b) c -> Qpositive_le a (Qpositive_plus b c).
 
Theorem add_sub_le2 :
 forall a b c : Qpositive,
 a <> b ->
 Qpositive_le b a ->
 Qpositive_le a (Qpositive_plus b c) -> Qpositive_le (Qpositive_sub a b) c.
 
Theorem add_sub_eq1 :
 forall a b c : Qpositive, a = Qpositive_plus b c -> Qpositive_sub a b = c.
 
Theorem add_sub_eq2 :
 forall a b c : Qpositive,
 a <> b ->
 Qpositive_le b a -> c = Qpositive_sub a b -> Qpositive_plus b c = a.
 
Theorem Qplus_assoc_two_neg :
 forall (n : Q) (m' p' : Qpositive),
 Qplus n (Qplus (Qneg m') (Qneg p')) = Qplus (Qplus n (Qneg m')) (Qneg p').
 
Theorem Qplus_assoc_one_neg :
 forall n' m' p' : Qpositive,
 Qplus (Qpos n') (Qplus (Qpos m') (Qneg p')) =
 Qplus (Qplus (Qpos n') (Qpos m')) (Qneg p').
 
Theorem Qplus_assoc_one_neg' :
 forall (n m : Q) (p' : Qpositive),
 Qplus n (Qplus m (Qneg p')) = Qplus (Qplus n m) (Qneg p').
 
Theorem Qplus_assoc :
 forall n m p : Q, Qplus n (Qplus m p) = Qplus (Qplus n m) p. *)
Require Export Q_order.
(* Q_order:
Require Export Q_field.
 
Theorem Qmult_sym : forall n m : Q, Qmult n m = Qmult m n.
 
Theorem Qmult_assoc :
 forall n m p : Q, Qmult n (Qmult m p) = Qmult (Qmult n m) p.
 
Theorem Qplus_zero_left : forall n : Q, Qplus Zero n = n.
 
Theorem Qmult_one_left : forall n : Q, Qmult (Qpos One) n = n.
 
Theorem Q_opp_def : forall n : Q, Qplus n (Qopp n) = Zero.
 
Definition Q_eq (n m : Q) :=
  match n, m with
  | Zero, Zero => true
  | Qpos n', Qpos m' =>
      match Qpositive_eq_dec n' m' with
      | left h => true
      | right h => false
      end
  | Qneg n', Qneg m' =>
      match Qpositive_eq_dec n' m' with
      | left h => true
      | right h => false
      end
  | _, _ => false
  end.
 
Theorem Q_eq_prop : forall x y : Q, Q_eq x y = true -> x = y.
 
Theorem not_one_zero : Qpos One <> Zero.
 
Definition Qinv (x : Q) :=
  match x with
  | Qpos x => Qpos (Qpositive_inv x)
  | Qneg x => Qneg (Qpositive_inv x)
  | Zero => Zero
  end.
 
Theorem Qinv_def : forall x : Q, x <> Zero -> Qmult x (Qinv x) = Qpos One.
 
Theorem Q_integral : forall x y : Q, Qmult x y = Zero -> x = Zero \/ y = Zero.
 
Inductive Qgt : Q -> Q -> Prop :=
  | Qgt_pos_pos :
      forall x' y' : Qpositive,
      ~ Qpositive_le x' y' -> Qgt (Qpos x') (Qpos y')
  | Qgt_neg_neg :
      forall x' y' : Qpositive,
      ~ Qpositive_le y' x' -> Qgt (Qneg x') (Qneg y')
  | Qgt_pos_zero : forall x' : Qpositive, Qgt (Qpos x') Zero
  | Qgt_pos_neg : forall x' y' : Qpositive, Qgt (Qpos x') (Qneg y')
  | Qgt_zero_neg : forall x' : Qpositive, Qgt Zero (Qneg x').
Hint Resolve Qgt_pos_pos Qgt_neg_neg Qgt_pos_zero Qgt_pos_neg Qgt_zero_neg.
 
Theorem Qgt_total : forall x y : Q, Qgt x y \/ x = y \/ Qgt y x.
 
Definition Q_eq_dec : forall x y : Q, {x = y} + {x <> y}.
 
Theorem Qgt_antisym : forall x y : Q, Qgt x y -> ~ Qgt y x.
 
Theorem Qgt_trans : forall x y z : Q, Qgt x y -> Qgt y z -> Qgt x z.
 
Theorem Qpositive_le_plus_simpl :
 forall x y z : Qpositive,
 Qpositive_le (Qpositive_plus x z) (Qpositive_plus y z) -> Qpositive_le x y.
 
Theorem Qpositive_le_sub_simpl_r :
 forall x y z : Qpositive,
 Qpositive_le z x ->
 Qpositive_le z y ->
 z <> x ->
 z <> y ->
 Qpositive_le (Qpositive_sub x z) (Qpositive_sub y z) -> Qpositive_le x y.
 
Theorem Qpositive_le_sub_simpl_l :
 forall x y z : Qpositive,
 Qpositive_le x z ->
 Qpositive_le y z ->
 z <> x ->
 z <> y ->
 Qpositive_le (Qpositive_sub z x) (Qpositive_sub z y) -> Qpositive_le y x.
 
Theorem Qgt_plus : forall x y z : Q, Qgt x y -> Qgt (Qplus z x) (Qplus z y).
 
Theorem Qgt_mult :
 forall x y z : Q, Qgt z Zero -> Qgt x y -> Qgt (Qmult z x) (Qmult z y).
 
Theorem Qpositive_mult_simpl :
 forall w w' w'' : Qpositive,
 Qpositive_mult w w'' = Qpositive_mult w' w'' -> w = w'.
 
Theorem Q_distr_left_aux :
 forall (x y : Q) (z' : Qpositive),
 Qmult (Qplus x y) (Qpos z') = Qplus (Qmult x (Qpos z')) (Qmult y (Qpos z')).
 
Theorem Qmult_zero : forall x : Q, Qmult Zero x = Zero.
 
Theorem Qmult_neg :
 forall (x : Q) (y' : Qpositive),
 Qopp (Qmult x (Qneg y')) = Qmult x (Qpos y').
 
Theorem Qopp_plus :
 forall x y : Q, Qopp (Qplus x y) = Qplus (Qopp x) (Qopp y).
 
Theorem Q_distr_left :
 forall x y z : Q, Qmult (Qplus x y) z = Qplus (Qmult x z) (Qmult y z).

Definition Qminus (q1 q2 : Q) : Q := Qplus q1 (Qopp q2).
Definition Qdiv (q1 q2 : Q) : Q := Qmult q1 (Qinv q2). *)
Require Import Field_Theory_Q. 
(* Field_Theory_Q:
Require Import Eqdep_dec.
Require Export Field.
Require Export Q_order.

Lemma Q_Ring_Theory :
    ring_theory Zero Qone Qplus Qmult Qminus Qopp (eq(A:=Q)).

Lemma Qinv_defT : forall n : Q, n <> Zero -> Qmult (Qinv n) n = Qone.

Lemma QField :
  field_theory Zero Qone Qplus Qmult Qminus Qopp Qdiv Qinv (eq(A:=Q)).

Ltac isQcst t :=
  match t with
    Zero => true
  | Qpos ?p => isQcst p
  | Qneg ?p => isQcst p
  | nR ?p => isQcst p
  | dL ?p => isQcst p
  | One => true
  | Qone => true
  | _ => false
  end.
Ltac Qcst t :=
  match isQcst t with
  | true => t
  | _ => InitialRing.NotConstant
  end.
 
Add Field Qfield : QField (decidable Q_eq_prop, constants [Qcst]).

Definition not_eq2eqT (A : Set) (x y : A) (H1 : x <> y) : 
  x <> y := fun H2 : x = y => H1 (H2).

Ltac Field := field. *)
Require Export Zaux.
(* Zaux:
Require Export ZArith.
Require Export ZArithRing.

Tactic Notation "ElimCompare" constr(c) constr(d) := elim_compare c d.

Ltac Flip :=
  apply Z.gt_lt || apply Z.lt_gt || apply Z.le_ge || apply Z.ge_le; assumption.

Ltac Falsum :=
  try intro; apply False_ind;
   repeat
    match goal with
    | id1:(~ ?X1) |- ?X2 =>
        (apply id1; assumption || reflexivity) || clear id1
    end.

Ltac Step_l a :=
  match goal with
  |  |- (?X1 < ?X2)%Z => replace X1 with a; [ idtac | try ring ]
  end. 

Ltac Step_r a :=
  match goal with
  |  |- (?X1 < ?X2)%Z => replace X2 with a; [ idtac | try ring ]
  end. 

Ltac CaseEq formula :=
  generalize (refl_equal formula); pattern formula at -1 in |- *;
   case formula.

Lemma pair_1 : forall (A B : Set) (H : A * B), H = pair (fst H) (snd H).

Lemma pair_2 :
 forall (A B : Set) (H1 H2 : A * B),
 fst H1 = fst H2 -> snd H1 = snd H2 -> H1 = H2.

Section projection.   
 Variable A : Set.
 Variable P : A -> Prop.
 
 Definition projP1 (H : sig P) := let (x, h) := H in x.
 Definition projP2 (H : sig P) :=
   let (x, h) as H return (P (projP1 H)) := H in h.
End projection.

Lemma le_stepl: forall x y z, le x y -> x=z -> le z y.

Lemma le_stepr: forall x y z, le x y -> y=z -> le x z.

Lemma lt_stepl: forall x y z, lt x y -> x=z -> lt z y.

Lemma lt_stepr: forall x y z, lt x y -> y=z -> lt x z.

Lemma neq_stepl:forall (x y z:nat), x<>y -> x=z -> z<>y.

Lemma neq_stepr:forall (x y z:nat), x<>y -> y=z -> x<>z.

Declare Left Step le_stepl.
Declare Right Step le_stepr.
Declare Left Step lt_stepl.
Declare Right Step lt_stepr.
Declare Left Step neq_stepl.
Declare Right Step neq_stepr.

Lemma not_O_S : forall n : nat, n <> 0 -> {p : nat | n = S p}.
  
Lemma lt_minus_neq : forall m n : nat, m < n -> n - m <> 0.

Lemma lt_minus_eq_0 : forall m n : nat, m < n -> m - n = 0.

Lemma le_plus_Sn_1_SSn : forall n : nat, S n + 1 <= S (S n).

Lemma le_plus_O_l : forall p q : nat, p + q <= 0 -> p = 0.

Lemma le_plus_O_r : forall p q : nat, p + q <= 0 -> q = 0.

Lemma minus_pred : forall m n : nat, 0 < n -> pred m - pred n = m - n.

Lemma Zle_stepl: forall x y z, (x<=y)%Z -> x=z -> (z<=y)%Z.

Lemma Zle_stepr: forall x y z, (x<=y)%Z -> y=z -> (x<=z)%Z.

Lemma Zlt_stepl: forall x y z, (x<y)%Z -> x=z -> (z<y)%Z.

Lemma Zlt_stepr: forall x y z, (x<y)%Z -> y=z -> (x<z)%Z.

Lemma Zneq_stepl:forall (x y z:Z), (x<>y)%Z -> x=z -> (z<>y)%Z.

Lemma Zneq_stepr:forall (x y z:Z), (x<>y)%Z -> y=z -> (x<>z)%Z.

Declare Left Step Zle_stepl.
Declare Right Step Zle_stepr.
Declare Left Step Zlt_stepl.
Declare Right Step Zlt_stepr.
Declare Left Step Zneq_stepl.
Declare Right Step Zneq_stepr.

Lemma Zlt_cotrans :
 forall x y : Z, (x < y)%Z -> forall z : Z, {(x < z)%Z} + {(z < y)%Z}.

Lemma Zlt_cotrans_pos :
 forall x y : Z, (0 < x + y)%Z -> {(0 < x)%Z} + {(0 < y)%Z}.

Lemma Zlt_cotrans_neg :
 forall x y : Z, (x + y < 0)%Z -> {(x < 0)%Z} + {(y < 0)%Z}.

Lemma not_Zeq_inf : forall x y : Z, x <> y -> {(x < y)%Z} + {(y < x)%Z}.

Lemma Z_dec : forall x y : Z, {(x < y)%Z} + {(x > y)%Z} + {x = y}.
 
Lemma Z_dec' : forall x y : Z, {(x < y)%Z} + {(y < x)%Z} + {x = y}.

Lemma Z_lt_le_dec : forall x y : Z, {(x < y)%Z} + {(y <= x)%Z}.

Lemma Z_le_lt_dec : forall x y : Z, {(x <= y)%Z} + {(y < x)%Z}.

Lemma Z_lt_lt_S_eq_dec :
 forall x y : Z, (x < y)%Z -> {(x + 1 < y)%Z} + {(x + 1)%Z = y}.

Lemma quadro_leq_inf :
 forall a b c d : Z,
 {(c <= a)%Z /\ (d <= b)%Z} + {~ ((c <= a)%Z /\ (d <= b)%Z)}.

Lemma Zminus_eq : forall x y : Z, (x - y)%Z = 0%Z -> x = y.

Lemma Zlt_minus : forall a b : Z, (b < a)%Z -> (0 < a - b)%Z.

Lemma Zle_minus : forall a b : Z, (b <= a)%Z -> (0 <= a - b)%Z.

Lemma Zlt_plus_plus :
 forall m n p q : Z, (m < n)%Z -> (p < q)%Z -> (m + p < n + q)%Z.

Lemma Zgt_plus_plus :
 forall m n p q : Z, (m > n)%Z -> (p > q)%Z -> (m + p > n + q)%Z.

Lemma Zle_lt_plus_plus :
 forall m n p q : Z, (m <= n)%Z -> (p < q)%Z -> (m + p < n + q)%Z.

Lemma Zge_gt_plus_plus :
 forall m n p q : Z, (m >= n)%Z -> (p > q)%Z -> (m + p > n + q)%Z.

Lemma Zgt_ge_plus_plus :
 forall m n p q : Z, (m > n)%Z -> (p >= q)%Z -> (m + p > n + q)%Z.

Lemma Zlt_resp_pos : forall x y : Z, (0 < x)%Z -> (0 < y)%Z -> (0 < x + y)%Z.

Lemma Zle_resp_neg :
 forall x y : Z, (x <= 0)%Z -> (y <= 0)%Z -> (x + y <= 0)%Z.

Lemma Zlt_pos_opp : forall x : Z, (0 < x)%Z -> (- x < 0)%Z.

Lemma Zlt_neg_opp : forall x : Z, (x < 0)%Z -> (0 < - x)%Z.

Lemma Zle_neg_opp : forall x : Z, (x <= 0)%Z -> (0 <= - x)%Z.

Lemma Zle_pos_opp : forall x : Z, (0 <= x)%Z -> (- x <= 0)%Z.

Lemma Zge_opp : forall x y : Z, (x <= y)%Z -> (- x >= - y)%Z.

Lemma Zmult_pos_pos : forall x y : Z, (0 < x)%Z -> (0 < y)%Z -> (0 < x * y)%Z.

Lemma Zmult_neg_neg : forall x y : Z, (x < 0)%Z -> (y < 0)%Z -> (0 < x * y)%Z.

Lemma Zmult_neg_pos : forall x y : Z, (x < 0)%Z -> (0 < y)%Z -> (x * y < 0)%Z.

Lemma Zmult_pos_neg : forall x y : Z, (0 < x)%Z -> (y < 0)%Z -> (x * y < 0)%Z.

Hint Resolve Zmult_pos_pos Zmult_neg_neg Zmult_neg_pos Zmult_pos_neg: zarith.

Lemma Zle_reg_mult_l :
 forall x y a : Z, (0 < a)%Z -> (x <= y)%Z -> (a * x <= a * y)%Z.

Lemma Zsimpl_plus_l_dep :
 forall x y m n : Z, (x + m)%Z = (y + n)%Z -> x = y -> m = n.

Lemma Zsimpl_plus_r_dep :
 forall x y m n : Z, (m + x)%Z = (n + y)%Z -> x = y -> m = n.

Lemma Zmult_simpl :
 forall n m p q : Z, n = m -> p = q -> (n * p)%Z = (m * q)%Z.
 
Lemma Zsimpl_mult_l :
 forall n m p : Z, n <> 0%Z -> (n * m)%Z = (n * p)%Z -> m = p.

Lemma Zlt_reg_mult_l :
 forall x y z : Z, (x > 0)%Z -> (y < z)%Z -> (x * y < x * z)%Z. 

Lemma Zlt_opp : forall x y : Z, (x < y)%Z -> (- x > - y)%Z. 

Lemma Zlt_conv_mult_l :
 forall x y z : Z, (x < 0)%Z -> (y < z)%Z -> (x * y > x * z)%Z. 

Lemma Zgt_not_eq : forall x y : Z, (x > y)%Z -> x <> y.   

Lemma Zmult_resp_nonzero :
 forall x y : Z, x <> 0%Z -> y <> 0%Z -> (x * y)%Z <> 0%Z.

Lemma Zopp_app : forall y : Z, y <> 0%Z -> (- y)%Z <> 0%Z.

Lemma Zle_neq_Zlt : forall a b : Z, (a <= b)%Z -> b <> a -> (a < b)%Z.

Lemma not_Zle_lt : forall x y : Z, ~ (y <= x)%Z -> (x < y)%Z.

Lemma not_Zlt : forall x y : Z, ~ (y < x)%Z -> (x <= y)%Z.

Lemma Zmult_absorb :
 forall x y z : Z, x <> 0%Z -> (x * y)%Z = (x * z)%Z -> y = z.  

Lemma Zlt_mult_mult :
 forall a b c d : Z,
 (0 < a)%Z -> (0 < d)%Z -> (a < b)%Z -> (c < d)%Z -> (a * c < b * d)%Z.

Lemma Zgt_mult_conv_absorb_l :
 forall a x y : Z, (a < 0)%Z -> (a * x > a * y)%Z -> (x < y)%Z. 

Lemma Zgt_mult_reg_absorb_l :
 forall a x y : Z, (a > 0)%Z -> (a * x > a * y)%Z -> (x > y)%Z. 

Lemma Zopp_Zlt : forall x y : Z, (y < x)%Z -> (- x < - y)%Z.

Lemma Zmin_cancel_Zlt : forall x y : Z, (- x < - y)%Z -> (y < x)%Z.

Lemma Zmult_cancel_Zle :
 forall a x y : Z, (a < 0)%Z -> (a * x <= a * y)%Z -> (y <= x)%Z.

Lemma Zlt_mult_cancel_l :
 forall x y z : Z, (0 < x)%Z -> (x * y < x * z)%Z -> (y < z)%Z.
 
Lemma Zmin_cancel_Zle : forall x y : Z, (- x <= - y)%Z -> (y <= x)%Z.

Lemma Zmult_resp_Zle :
 forall a x y : Z, (0 < a)%Z -> (a * y <= a * x)%Z -> (y <= x)%Z.

Lemma Zopp_Zle : forall x y : Z, (y <= x)%Z -> (- x <= - y)%Z.

Lemma Zle_lt_eq_S : forall x y : Z, (x <= y)%Z -> (y < x + 1)%Z -> y = x.

Lemma Zlt_le_eq_S :
 forall x y : Z, (x < y)%Z -> (y <= x + 1)%Z -> y = (x + 1)%Z.

Lemma double_not_equal_zero :
 forall c d : Z, ~ (c = 0%Z /\ d = 0%Z) -> c <> d \/ c <> 0%Z.

Lemma triple_not_equal_zero :
 forall a b c : Z,
 ~ (a = 0%Z /\ b = 0%Z /\ c = 0%Z) -> a <> 0%Z \/ b <> 0%Z \/ c <> 0%Z.

Lemma mediant_1 :
 forall m n m' n' : Z, (m' * n < m * n')%Z -> ((m + m') * n < m * (n + n'))%Z.
 
Lemma mediant_2 :
 forall m n m' n' : Z,
 (m' * n < m * n')%Z -> (m' * (n + n') < (m + m') * n')%Z. 

Lemma mediant_3 :
 forall a b m n m' n' : Z,
 (0 <= a * m + b * n)%Z ->
 (0 <= a * m' + b * n')%Z -> (0 <= a * (m + m') + b * (n + n'))%Z.

Lemma fraction_lt_trans :
 forall a b c d e f : Z,
 (0 < b)%Z ->
 (0 < d)%Z ->
 (0 < f)%Z -> (a * d < c * b)%Z -> (c * f < e * d)%Z -> (a * f < e * b)%Z.

Lemma square_pos : forall a : Z, a <> 0%Z -> (0 < a * a)%Z.
 
Hint Resolve square_pos: zarith.

Definition Z2positive (z : Z) :=
  match z with
  | Zpos p => p
  | Zneg p => p
  | Z0 => 1%positive
  end.

Lemma ZL9 : forall p : positive, Z_of_nat (nat_of_P p) = Zpos p. 

Coercion Z_of_nat : nat >-> Z.

Lemma ZERO_lt_POS : forall p : positive, (0 < Zpos p)%Z.

Lemma POS_neq_ZERO : forall p : positive, Zpos p <> 0%Z.

Lemma NEG_neq_ZERO : forall p : positive, Zneg p <> 0%Z.

Lemma POS_resp_eq : forall p0 p1 : positive, Zpos p0 = Zpos p1 -> p0 = p1.

Lemma nat_nat_pos : forall m n : nat, ((m + 1) * (n + 1) > 0)%Z. 
 
Theorem S_predn : forall m : nat, m <> 0 -> S (pred m) = m. 

Lemma absolu_1 : forall x : Z, Z.abs_nat x = 0 -> x = 0%Z. 

Lemma absolu_2 : forall x : Z, x <> 0%Z -> Z.abs_nat x <> 0. 

Lemma absolu_inject_nat : forall n : nat, Z.abs_nat (Z_of_nat n) = n.

Lemma eq_inj : forall m n : nat, m = n :>Z -> m = n.

Lemma lt_inj : forall m n : nat, (m < n)%Z -> m < n.

Lemma le_inj : forall m n : nat, (m <= n)%Z -> m <= n.

Lemma inject_nat_S_inf : forall x : Z, (0 < x)%Z -> {n : nat | x = S n}.

Lemma le_absolu :
 forall x y : Z,
 (0 <= x)%Z -> (0 <= y)%Z -> (x <= y)%Z -> Z.abs_nat x <= Z.abs_nat y.

Lemma lt_absolu :
 forall x y : Z,
 (0 <= x)%Z -> (0 <= y)%Z -> (x < y)%Z -> Z.abs_nat x < Z.abs_nat y.

Lemma absolu_plus :
 forall x y : Z,
 (0 <= x)%Z -> (0 <= y)%Z -> Z.abs_nat (x + y) = Z.abs_nat x + Z.abs_nat y.

Lemma pred_absolu :
 forall x : Z, (0 < x)%Z -> pred (Z.abs_nat x) = Z.abs_nat (x - 1).

Definition pred_nat : forall (x : Z) (Hx : (0 < x)%Z), nat.

Lemma pred_nat_equal :
 forall (x : Z) (Hx1 Hx2 : (0 < x)%Z), pred_nat x Hx1 = pred_nat x Hx2.

Let pred_nat_unfolded_subproof px :
  Pos.to_nat px <> 0.

Lemma pred_nat_unfolded :
 forall (x : Z) (Hx : (0 < x)%Z), x = S (pred_nat x Hx).

Lemma absolu_pred_nat :
 forall (m : Z) (Hm : (0 < m)%Z), S (pred_nat m Hm) = Z.abs_nat m.

Lemma pred_nat_absolu :
 forall (m : Z) (Hm : (0 < m)%Z), pred_nat m Hm = Z.abs_nat (m - 1).

Lemma minus_pred_nat :
 forall (n m : Z) (Hn : (0 < n)%Z) (Hm : (0 < m)%Z) (Hnm : (0 < n - m)%Z),
 S (pred_nat n Hn) - S (pred_nat m Hm) = S (pred_nat (n - m) Hnm).

Lemma Zsgn_1 :
 forall x : Z, {Z.sgn x = 0%Z} + {Z.sgn x = 1%Z} + {Z.sgn x = (-1)%Z}. 

Lemma Zsgn_2 : forall x : Z, Z.sgn x = 0%Z -> x = 0%Z.   

Lemma Zsgn_3 : forall x : Z, x <> 0%Z -> Z.sgn x <> 0%Z.   

Theorem Zsgn_4 : forall a : Z, a = (Z.sgn a * Z.abs_nat a)%Z.  

Theorem Zsgn_5 :
 forall a b x y : Z,
 x <> 0%Z ->
 y <> 0%Z ->
 (Z.sgn a * x)%Z = (Z.sgn b * y)%Z -> (Z.sgn a * y)%Z = (Z.sgn b * x)%Z.  

Lemma Zsgn_6 : forall x : Z, x = 0%Z -> Z.sgn x = 0%Z.

Lemma Zsgn_7 : forall x : Z, (x > 0)%Z -> Z.sgn x = 1%Z.

Lemma Zsgn_7' : forall x : Z, (0 < x)%Z -> Z.sgn x = 1%Z.

Lemma Zsgn_8 : forall x : Z, (x < 0)%Z -> Z.sgn x = (-1)%Z.

Lemma Zsgn_9 : forall x : Z, Z.sgn x = 1%Z -> (0 < x)%Z.
 
Lemma Zsgn_10 : forall x : Z, Z.sgn x = (-1)%Z -> (x < 0)%Z.

Lemma Zsgn_11 : forall x : Z, (Z.sgn x < 0)%Z -> (x < 0)%Z.

Lemma Zsgn_12 : forall x : Z, (0 < Z.sgn x)%Z -> (0 < x)%Z.

Lemma Zsgn_13 : forall x : Z, (0 <= Z.sgn x)%Z -> (0 <= x)%Z.

Lemma Zsgn_14 : forall x : Z, (Z.sgn x <= 0)%Z -> (x <= 0)%Z.

Lemma Zsgn_15 : forall x y : Z, Z.sgn (x * y) = (Z.sgn x * Z.sgn y)%Z.

Lemma Zsgn_16 :
 forall x y : Z,
 Z.sgn (x * y) = 1%Z -> {(0 < x)%Z /\ (0 < y)%Z} + {(x < 0)%Z /\ (y < 0)%Z}.

Lemma Zsgn_17 :
 forall x y : Z,
 Z.sgn (x * y) = (-1)%Z -> {(0 < x)%Z /\ (y < 0)%Z} + {(x < 0)%Z /\ (0 < y)%Z}.

Lemma Zsgn_18 : forall x y : Z, Z.sgn (x * y) = 0%Z -> {x = 0%Z} + {y = 0%Z}.

Lemma Zsgn_19 : forall x y : Z, (0 < Z.sgn x + Z.sgn y)%Z -> (0 < x + y)%Z.

Lemma Zsgn_20 : forall x y : Z, (Z.sgn x + Z.sgn y < 0)%Z -> (x + y < 0)%Z.

Lemma Zsgn_21 : forall x y : Z, (0 < Z.sgn x + Z.sgn y)%Z -> (0 <= x)%Z.

Lemma Zsgn_22 : forall x y : Z, (Z.sgn x + Z.sgn y < 0)%Z -> (x <= 0)%Z.

Lemma Zsgn_23 : forall x y : Z, (0 < Z.sgn x + Z.sgn y)%Z -> (0 <= y)%Z.

Lemma Zsgn_24 : forall x y : Z, (Z.sgn x + Z.sgn y < 0)%Z -> (y <= 0)%Z.

Lemma Zsgn_25 : forall x : Z, Z.sgn (- x) = (- Z.sgn x)%Z.

Lemma Zsgn_26 : forall x : Z, (0 < x)%Z -> (0 < Z.sgn x)%Z.

Lemma Zsgn_27 : forall x : Z, (x < 0)%Z -> (Z.sgn x < 0)%Z.

Hint Resolve Zsgn_1 Zsgn_2 Zsgn_3 Zsgn_4 Zsgn_5 Zsgn_6 Zsgn_7 Zsgn_7' Zsgn_8
  Zsgn_9 Zsgn_10 Zsgn_11 Zsgn_12 Zsgn_13 Zsgn_14 Zsgn_15 Zsgn_16 Zsgn_17
  Zsgn_18 Zsgn_19 Zsgn_20 Zsgn_21 Zsgn_22 Zsgn_23 Zsgn_24 Zsgn_25 Zsgn_26
  Zsgn_27: zarith.

Lemma Zabs_1 : forall z p : Z, (Z.abs z < p)%Z -> (z < p)%Z /\ (- p < z)%Z.

Lemma Zabs_2 : forall z p : Z, (Z.abs z > p)%Z -> (z > p)%Z \/ (- p > z)%Z.

Lemma Zabs_3 : forall z p : Z, (z < p)%Z /\ (- p < z)%Z -> (Z.abs z < p)%Z.

Lemma Zabs_4 : forall z p : Z, (Z.abs z < p)%Z -> (- p < z < p)%Z.
 
Lemma Zabs_5 : forall z p : Z, (Z.abs z <= p)%Z -> (- p <= z <= p)%Z.

Lemma Zabs_6 : forall z p : Z, (Z.abs z <= p)%Z -> (z <= p)%Z.

Lemma Zabs_7 : forall z p : Z, (Z.abs z <= p)%Z -> (- p <= z)%Z.

Lemma Zabs_8 : forall z p : Z, (- p <= z <= p)%Z -> (Z.abs z <= p)%Z.

Lemma Zabs_min : forall z : Z, Z.abs z = Z.abs (- z).

Lemma Zabs_9 :
 forall z p : Z, (0 <= p)%Z -> (p < z)%Z \/ (z < - p)%Z -> (p < Z.abs z)%Z.

Lemma Zabs_10 : forall z : Z, (0 <= Z.abs z)%Z.

Lemma Zabs_11 : forall z : Z, z <> 0%Z -> (0 < Z.abs z)%Z.

Lemma Zabs_12 : forall z m : Z, (m < Z.abs z)%Z -> {(m < z)%Z} + {(z < - m)%Z}.

Lemma Zabs_mult : forall z p : Z, Z.abs (z * p) = (Z.abs z * Z.abs p)%Z.

Lemma Zabs_plus : forall z p : Z, (Z.abs (z + p) <= Z.abs z + Z.abs p)%Z.

Lemma Zabs_neg : forall z : Z, (z <= 0)%Z -> Z.abs z = (- z)%Z.

Lemma Zle_Zabs: forall z, (z <= Z.abs z)%Z.
 
Hint Resolve Zabs_1 Zabs_2 Zabs_3 Zabs_4 Zabs_5 Zabs_6 Zabs_7 Zabs_8 Zabs_9
  Zabs_10 Zabs_11 Zabs_12 Zabs_min Zabs_neg Zabs_mult Zabs_plus Zle_Zabs: zarith.

Lemma Zind :
 forall (P : Z -> Prop) (p : Z),
 P p ->
 (forall q : Z, (p <= q)%Z -> P q -> P (q + 1)%Z) ->
 forall q : Z, (p <= q)%Z -> P q. 

Lemma Zrec :
 forall (P : Z -> Set) (p : Z),
 P p ->
 (forall q : Z, (p <= q)%Z -> P q -> P (q + 1)%Z) ->
 forall q : Z, (p <= q)%Z -> P q. 

Lemma Zrec_down :
 forall (P : Z -> Set) (p : Z),
 P p ->
 (forall q : Z, (q <= p)%Z -> P q -> P (q - 1)%Z) ->
 forall q : Z, (q <= p)%Z -> P q.

Lemma Zind_down :
 forall (P : Z -> Prop) (p : Z),
 P p ->
 (forall q : Z, (q <= p)%Z -> P q -> P (q - 1)%Z) ->
 forall q : Z, (q <= p)%Z -> P q.

Lemma Zrec_wf :
 forall (P : Z -> Set) (p : Z),
 (forall q : Z, (forall r : Z, (p <= r < q)%Z -> P r) -> P q) ->
 forall q : Z, (p <= q)%Z -> P q.

Lemma Zrec_wf2 :
 forall (q : Z) (P : Z -> Set) (p : Z),
 (forall q : Z, (forall r : Z, (p <= r < q)%Z -> P r) -> P q) ->
 (p <= q)%Z -> P q.

Lemma Zrec_wf_double :
 forall (P : Z -> Z -> Set) (p0 q0 : Z),
 (forall n m : Z,
  (forall p q : Z, (q0 <= q)%Z -> (p0 <= p < n)%Z -> P p q) ->
  (forall p : Z, (q0 <= p < m)%Z -> P n p) -> P n m) ->
 forall p q : Z, (q0 <= q)%Z -> (p0 <= p)%Z -> P p q.

Lemma Zind_wf :
 forall (P : Z -> Prop) (p : Z),
 (forall q : Z, (forall r : Z, (p <= r < q)%Z -> P r) -> P q) ->
 forall q : Z, (p <= q)%Z -> P q.

Lemma Zind_wf2 :
 forall (q : Z) (P : Z -> Prop) (p : Z),
 (forall q : Z, (forall r : Z, (p <= r < q)%Z -> P r) -> P q) ->
 (p <= q)%Z -> P q.

Lemma Zind_wf_double :
 forall (P : Z -> Z -> Prop) (p0 q0 : Z),
 (forall n m : Z,
  (forall p q : Z, (q0 <= q)%Z -> (p0 <= p < n)%Z -> P p q) ->
  (forall p : Z, (q0 <= p < m)%Z -> P n p) -> P n m) ->
 forall p q : Z, (q0 <= q)%Z -> (p0 <= p)%Z -> P p q.

Definition Zmax (n m : Z) := (n + m - Z.min n m)%Z.

Lemma ZmaxSS : forall n m : Z, (Zmax n m + 1)%Z = Zmax (n + 1) (m + 1).

Lemma Zle_max_l : forall n m : Z, (n <= Zmax n m)%Z.

Lemma Zle_max_r : forall n m : Z, (m <= Zmax n m)%Z.

Lemma Zmin_or_informative : forall n m : Z, {Z.min n m = n} + {Z.min n m = m}.

Lemma Zmax_case : forall (n m : Z) (P : Z -> Set), P n -> P m -> P (Zmax n m).
 
Lemma Zmax_or_informative : forall n m : Z, {Zmax n m = n} + {Zmax n m = m}. 

Lemma Zmax_n_n : forall n : Z, Zmax n n = n.

Hint Resolve ZmaxSS Zle_max_r Zle_max_l Zmax_n_n: zarith.

Lemma Zeven_S : forall x : Z, Zeven.Zodd x -> Zeven.Zeven (x + 1).

Lemma Zeven_pred : forall x : Z, Zeven.Zodd x -> Zeven.Zeven (x - 1). 

Definition Z_modulo_2_always :
  forall x : Z, {y : Z | x = (2 * y)%Z} + {y : Z | x = (2 * y + 1)%Z} :=
  Zeven.Z_modulo_2.

Lemma Z_div_mod_eq_2 :
 forall a b : Z, (0 < b)%Z -> (b * (a / b))%Z = (a - a mod b)%Z.

Lemma Z_div_le :
 forall a b c : Z, (0 < c)%Z -> (b <= a)%Z -> (b / c <= a / c)%Z. 

Lemma Z_div_nonneg :
 forall a b : Z, (0 < b)%Z -> (0 <= a)%Z -> (0 <= a / b)%Z.

Lemma Z_div_neg : forall a b : Z, (0 < b)%Z -> (a < 0)%Z -> (a / b < 0)%Z.

Hint Resolve Z_div_mod_eq_2 Z_div_le Z_div_nonneg Z_div_neg: zarith.

Lemma Zpower_1 : forall a : Z, (a ^ 1)%Z = a.

Lemma Zpower_2 : forall a : Z, (a ^ 2)%Z = (a * a)%Z.

Hint Resolve Zpower_1 Zpower_2: zarith. *)

Lemma Z_of_nat_Zabs_nat_pos: forall z, (0<=z)%Z -> Z_of_nat (Z.abs_nat z) = z.
Proof.
 intros z Hz;
 destruct (Z_of_nat_complete_inf z Hz) as [n Hn];
 transitivity (Z_of_nat n); auto;
 apply (f_equal Z_of_nat);
 rewrite <- absolu_inj_nat;
 apply (f_equal Z.abs_nat); trivial.
Qed.

Definition make_Q (m n : Z) :=
  match m, n with
  | Zpos _, Zpos _ =>
      Qpos (Qpositive_c (Z.abs_nat m) (Z.abs_nat n) (Z.abs_nat m + Z.abs_nat n))
  | Zneg _, Zneg _ =>
      Qpos (Qpositive_c (Z.abs_nat m) (Z.abs_nat n) (Z.abs_nat m + Z.abs_nat n))
  | Z0, _ => Zero
  | _, Z0 => Zero  
  | _, _ =>
      Qneg (Qpositive_c (Z.abs_nat m) (Z.abs_nat n) (Z.abs_nat m + Z.abs_nat n))
  end.

Definition decode_Q (q : Q) :=
  match q with
  | Qpos p =>
      (Z_of_nat (fst (Qpositive_i p)), Z_of_nat (snd (Qpositive_i p)))
  | Qneg p =>
      ((- Z_of_nat (fst (Qpositive_i p)))%Z, Z_of_nat (snd (Qpositive_i p)))
  | Zero => (0%Z, 1%Z)
  end.

Definition numerator (q:Q) :Z := fst (decode_Q q).

Definition denominator (q:Q) :Z := snd (decode_Q q).

Definition Z_to_Qpositive : forall x : Z, (0 < x)%Z -> Qpositive.
intros [| p| p].
intros H; abstract discriminate H.
intro.
exact (Qpositive_c (nat_of_P p) 1 (S (nat_of_P p))).
intro; abstract discriminate H.
Defined.

Definition Z_to_Q (x : Z) : Q :=
  match x with
  | Z0 => Zero
  | Zpos p => Qpos (Qpositive_c (nat_of_P p) 1 (S (nat_of_P p)))
  | Zneg p => Qneg (Qpositive_c (nat_of_P p) 1 (S (nat_of_P p)))
  end.
 
Definition Qpositive_tail (z : Qpositive) :=
  match z with
  | nR p => p
  | dL p => p
  | One => One
  end.
 
Definition Q_tail (z : Q) :=
  match z with
  | Zero => One
  | Qpos p => p
  | Qneg p => p
  end.
 
Definition Qsgn (q : Q) :=
  match q with
  | Zero => 0%Z
  | Qpos _ => 1%Z
  | Qneg _ => (-1)%Z
  end.

Fixpoint length_of_Qpositive_to_positive (qp : Qpositive) : positive :=
  match qp with
  | One => 1%positive
  | dL qp' => Pos.succ (length_of_Qpositive_to_positive qp')
  | nR qp' => Pos.succ (length_of_Qpositive_to_positive qp')
  end.

Fixpoint length_of_Qpositive (qp : Qpositive) : Z :=
  match qp with
  | One => 0%Z
  | dL qp' => (1 + length_of_Qpositive qp')%Z
  | nR qp' => (1 + length_of_Qpositive qp')%Z
  end.

Fixpoint Qpositive_to_Z (qp : Qpositive) : Z :=
  match qp with
  | One => 1%Z
  | dL qp' => 0%Z
  | nR qp' => (1 + Qpositive_to_Z qp')%Z
  end.

Definition Q_to_Z (x : Q) : Z :=
  match x with
  | Zero => 0%Z
  | Qpos qp => Qpositive_to_Z qp
  | Qneg qp => (- Qpositive_to_Z qp)%Z
  end.

Coercion Z_to_Q : Z >-> Q.

Definition Qlt (x y : Q) : Prop := Qgt y x.

Definition Qle (x y : Q) : Prop := ~ Qlt y x. 

Lemma Qlt_zero_pos : forall x' : Qpositive, Qlt Zero (Qpos x').
Proof.
 unfold Qlt in |- *; auto with *.
Qed.

Lemma Qlt_neg_pos : forall x' y' : Qpositive, Qlt (Qneg y') (Qpos x').
Proof.
 unfold Qlt in |- *; auto with *.
Qed.

Lemma Qlt_neg_zero : forall x' : Qpositive, Qlt (Qneg x') Zero.
 unfold Qlt in |- *; auto with *.
Qed.

Hint Resolve Qlt_neg_pos Qlt_neg_zero Qlt_zero_pos.

Ltac QltCleanAbsurdCases :=
  match goal with
  | id1:(Qlt Zero (Qneg _)) |- _ => inversion id1
  | id1:(Qlt (Qpos _) Zero) |- _ =>
      inversion id1
  | id1:(Qlt (Qpos _) (Qneg _)) |- _ =>
      inversion id1
  | id1:(Qle Zero (Qneg _)) |- _ =>
      apply False_ind; apply id1; auto with *
  | id1:(Qle (Qpos _) Zero) |- _ =>
      apply False_ind; apply id1; auto with *
  | id1:(Qle (Qpos _) (Qneg _)) |- _ =>
      apply False_ind; apply id1; auto with *
  end.
 
Functional Scheme Qpositive_c_ind := Induction for Qpositive_c Sort Prop.

Lemma Qpositive_c_0 : forall p q n : nat, n = 0 -> Qpositive_c p q n = One.
Proof.
 intros p q n.
 functional induction (Qpositive_c p q n); trivial || (intros; discriminate).

Qed.

Lemma Qpositive_c_1_0_0 :
 forall p q n' : nat, p - q = 0 -> q - p = 0 -> Qpositive_c p q (S n') = One.
Proof.
 intros p q n.
 functional induction (Qpositive_c p q (S n));trivial.
 rewrite e1;intros;discriminate.
 rewrite e0;intros;discriminate.
Qed.

Lemma Qpositive_c_equal_One :
 forall m n p : nat, m = n -> Qpositive_c m n p = One.
Proof.
 intros p q [| n'] Hpq;
  [ apply Qpositive_c_0
  | apply Qpositive_c_1_0_0; rewrite Hpq; rewrite <- minus_n_n ]; 
  reflexivity.
Qed.

Lemma Qpositive_c_1_0_1 :
 forall p q n' : nat,
 p - q = 0 ->
 q - p <> 0 -> Qpositive_c p q (S n') = dL (Qpositive_c p (q - p) n').
Proof.
 intros p q n' Hpq Hqp; simpl in |- *; rewrite Hpq; elim (not_O_S _ Hqp);
  intros p' Hqp'; rewrite Hqp'; simpl in |- *; reflexivity.
Qed.

Lemma Qpositive_c_dL :
 forall p q n' : nat,
 p < q -> Qpositive_c p q (S n') = dL (Qpositive_c p (q - p) n').
Proof.
 intros p q n Hpq.
 generalize (lt_minus_eq_0 p q Hpq) (lt_minus_neq p q Hpq).
 intros Hpq0 Hqp.
 apply (Qpositive_c_1_0_1 _ _ n Hpq0 Hqp).
Qed.

Lemma Qpositive_c_1_1 :
 forall p q n' : nat,
 p - q <> 0 -> Qpositive_c p q (S n') = nR (Qpositive_c (p - q) q n').
Proof.
 intros p q n' Hpq; simpl in |- *; elim (not_O_S _ Hpq); intros p' Hpq';
  rewrite Hpq'; simpl in |- *; reflexivity.
Qed.

Lemma Qpositive_c_nR :
 forall p q n' : nat,
 q < p -> Qpositive_c p q (S n') = nR (Qpositive_c (p - q) q n').
Proof.
 intros p q n Hqp.
 generalize (lt_minus_neq q p Hqp).
 intros Hpq.
 apply (Qpositive_c_1_1 _ _ n Hpq).
Qed.

Functional Scheme Qpositive_i_ind := Induction for Qpositive_i Sort Prop.
Lemma Qpositive_i_nR_with_let :
 forall w : Qpositive,
 let (p, q) := Qpositive_i w in Qpositive_i (nR w) = (p + q, q).
Proof.
 intros w;simpl Qpositive_i. 
 functional induction (Qpositive_i w);subst;trivial.
Qed.

Lemma Qpositive_i_nR :
 forall (w : Qpositive) (p q : nat),
 Qpositive_i w = (p, q) -> Qpositive_i (nR w) = (p + q, q).
Proof.
 intros w p q H_w; generalize (Qpositive_i_nR_with_let w); rewrite H_w;
  trivial.
Qed.

Lemma Qpositive_i_c :
 forall m p : nat,
 0 < m -> S m <= p -> Qpositive_i (Qpositive_c m 1 p) = (m, 1).
Proof.
 intros m p. 
 generalize m; clear m.
 induction p.
 intros m H1 H2.
 inversion H2.
 intros m H1 H2.

 case (le_lt_eq_dec 1 m).
 auto with arith.
 intro H_1_m.
 
 rewrite (Qpositive_c_nR _ _ p H_1_m). 
 rewrite (Qpositive_i_nR (Qpositive_c (m - 1) 1 p) (m - 1) 1). 
 apply pair_2; simpl in |- *; trivial; omega.
 apply IHp; omega.
 intro H_1_1.
 rewrite <- H_1_1.
 reflexivity.
Qed.

Lemma Qpositive_c_equal :
 forall m n p p' : nat,
 0 < m ->
 0 < n -> m + n <= p -> m + n <= p' -> Qpositive_c m n p = Qpositive_c m n p'.
Proof.
 intros m n p.
 functional induction (Qpositive_c m n p) as  [| | p q  p' H_eq_1  | ].
 intros p' _ _ Hpq. 
 generalize (le_plus_O_l p q Hpq) (le_plus_O_r p q Hpq).
 intros Hp Hq.
 rewrite Hp.
 rewrite Hq.
 case p'; simpl in |- *; reflexivity.
  
 intros p' _ _ _ _. 
 symmetry  in |- *.
 apply Qpositive_c_equal_One.
 apply le_antisym; apply minus_O_le; assumption.
 
 intros [| p'x] HpO HqO Hpq Hpq'.
 generalize (le_plus_O_r p q Hpq') (le_plus_O_l p q Hpq').
 intros Hq Hp.
 apply False_ind;omega.

 rewrite Qpositive_c_1_0_1;auto.
 apply f_equal with Qpositive. 
 rewrite (IHq p'x);try omega.
 unfold Qpositive_c at 2;fold Qpositive_c.
 rewrite e1. 
 destruct (q - p);tauto.
 omega.
 
 intros [| p'x] HpO HqO Hpq Hpq'.
 generalize (le_plus_O_r p q Hpq') (le_plus_O_l p q Hpq').
 intros Hq Hp.
 apply False_ind;omega.
 unfold Qpositive_c at 2;fold Qpositive_c.
  
 rewrite e0.
 rewrite (IHq p'x);try omega.
 reflexivity.
Qed.

Lemma Qpositive_c_equal_strong :
 forall m1 m2 n1 n2 p1 p2 : nat,
 m1 = m2 ->
 n1 = n2 ->
 0 < m1 ->
 0 < n1 ->
 m1 + n1 <= p1 ->
 m2 + n2 <= p2 -> Qpositive_c m1 n1 p1 = Qpositive_c m2 n2 p2.
Proof.
 intros m1 m2 n1 n2 p1 p2 Hm Hn Hm' Hn' H1 H2; subst; apply Qpositive_c_equal;
  assumption.
Qed.

Functional Scheme Qpositive_plus_ind := Induction for Qpositive_plus Sort Prop.

Lemma what_nR_does : forall p : Qpositive, nR p = Qpositive_plus p One.
Proof.
 intros qp.
 unfold Qpositive_plus;fold Qpositive_plus.
 functional induction (Qpositive_plus qp One).
 rewrite e;rewrite e0.
 rename e into H_pq.
 rename e0 into H_p'q'.
 generalize (interp_non_zero qp).
 rename q0 into q.
 intros (p0', (q0', Hpq')).

 rewrite H_pq in Hpq'.
 let f_local := eval compute in (f_equal (fst (B:=_)) Hpq') in
 let g_local := eval compute in (sym_eq (f_equal (fst (B:=_)) H_p'q')) in
 generalize f_local g_local. 
 let f_local := eval compute in (f_equal (snd (B:=_)) Hpq') in
 let g_local := eval compute in (sym_eq (f_equal (snd (B:=_)) H_p'q')) in
 generalize f_local g_local. 
 intros Hq Hq' Hp Hp'. 
 subst.
 rewrite <- (mult_n_Sm (S q0') 0).
 repeat rewrite <- plus_n_Sm.
 rewrite <- mult_n_O.
 rewrite plus_O_n.
 rewrite mult_1_l.
 rewrite mult_1_r.
 rewrite Qpositive_c_nR. 
 rewrite plus_comm.
 rewrite minus_plus.
 apply f_equal with Qpositive.
 symmetry  in |- *; apply construct_correct.
 assumption.
 rewrite plus_comm.
 apply le_plus_l.
 clear;  omega.
Qed.

Functional Scheme Qpositive_mult_ind := Induction for Qpositive_mult Sort Prop.

Lemma what_dL_does :
 forall p : Qpositive,
 dL p = Qpositive_mult p (Qpositive_inv (Qpositive_plus p One)).
Proof.
 intros qp.

  unfold Qpositive_plus. 

 functional induction (Qpositive_plus qp One).
 rewrite e;rewrite e0.
 rename q0 into q;
   rename e into H_eq_;
     rename e0 into H_eq_0.

 generalize (interp_non_zero qp).
 intros (p0, (q0, Hpq)).
 rewrite H_eq_ in Hpq.
 let f_local := eval compute in (f_equal (fst (B:=_)) Hpq) in
 let g_local := eval compute in (sym_eq (f_equal (fst (B:=_)) H_eq_0)) in
 generalize f_local g_local. 
 let f_local := eval compute in (f_equal (snd (B:=_)) Hpq) in
 let g_local := eval compute in (sym_eq (f_equal (snd (B:=_)) H_eq_0)) in
 generalize f_local g_local. 
 intros Hq Hq' Hp Hp'. 
 subst.
 rewrite <- (mult_n_Sm (S q0) 0).
 repeat rewrite <- plus_n_Sm.
 rewrite <- mult_n_O.
 rewrite plus_O_n.
 rewrite mult_1_l.
 rewrite mult_1_r.
 unfold Qpositive_mult in |- *.
 rewrite H_eq_.
 set
  (P :=
   Qpositive_i (Qpositive_c (S p0 + S q0) (S q0) (S (S p0 + S q0 + q0))))
  in *.
 set (p' := fst P) in *.
 set (q' := snd P) in *.
 assert
  (H_P :
   Qpositive_i (Qpositive_c (S p0 + S q0) (S q0) (S (S p0 + S q0 + q0))) =
   (p', q')).
 replace (p', q') with P; trivial; unfold p', q' in |- *; apply pair_1.
 rewrite (inv_correct _ _ _ H_P).
 rewrite (Qpositive_c_unfold1 p0 q0 (S p0 + S q0 + q0)) in H_P.
 rewrite
  (construct_correct qp (S p0) (S q0) (S p0 + S q0 + q0) H_eq_
     (le_plus_l _ _)) in H_P.  
 rewrite (Qpositive_i_nR qp _ _ H_eq_) in H_P.
 let f_local :=
  eval cbv beta delta -[plus] in (sym_eq (f_equal (fst (B:=_)) H_P)) in
 let g_local :=
  eval cbv beta delta -[plus] in (sym_eq (f_equal (snd (B:=_)) H_P)) in
 generalize f_local g_local. 
 intros Hp' Hq'; rewrite Hp'; rewrite Hq'.
 clear H_eq_0 Hpq H_P Hp' Hq' P p' q'.
 rewrite <- (mult_n_Sm (S p0) q0).
 rewrite <- plus_n_Sm.
 rewrite (plus_Sn_m (S p0 * q0 + p0)).
 replace (S (S p0 * q0 + p0)) with (S q0 * S p0).
 rewrite Qpositive_c_dL.
 replace (S q0 * (S p0 + S q0) - S q0 * S p0) with (S q0 * S q0).
 apply f_equal with Qpositive.
 symmetry  in |- *.
 rewrite
  (construct_correct4' (S q0 * S p0) (S q0 * S q0) 
     (S p0) (S q0) (S p0 * q0 + p0 + S q0 * (S p0 + S q0)) 
     (S p0 + S q0)).
 apply construct_correct.  
 assumption.
 omega.
 rewrite <- mult_n_Sm.
 rewrite <- plus_n_Sm.
 auto with arith.
 rewrite <- mult_n_Sm.
 rewrite <- plus_n_Sm.
 auto with arith.
 auto with arith.
 auto with arith.
 rewrite mult_plus_distr_l.
 apply le_plus_r.
 apply le_n.
 rewrite (mult_comm (S q0) (S p0)).
 auto with arith.
 rewrite mult_plus_distr_l.
 rewrite minus_plus; reflexivity.
 rewrite mult_plus_distr_l.
 rewrite plus_comm.
 repeat rewrite <- mult_n_Sm.
 rewrite <- plus_n_Sm.
 rewrite <- plus_n_Sm with (m := q0).
 generalize (S q0 * p0 + q0) (S q0 * q0 + q0); clear qp H_eq_; intros;
  omega.
 rewrite mult_comm.
 rewrite <- mult_n_Sm.
 rewrite <- plus_n_Sm; reflexivity.
 rewrite plus_n_Sm.
 apply le_n.
Qed.

Lemma Qpos_nR : forall p : Qpositive, Qpos (nR p) = Qplus (Qpos p) Qone.
Proof.
 intros.
 simpl in |- *.
 apply f_equal with Qpositive.
 apply what_nR_does.
Qed. 

Lemma Qmult_Z_nR :
 forall (a : Z) (p : Qpositive),
 Qmult (Z_to_Q a) (Qpos (nR p)) =
 Qplus (Qmult (Z_to_Q a) (Qpos p)) (Z_to_Q a).
Proof.
 intros.
 rewrite Qpos_nR.
 ring.
Qed.

Lemma Qpos_dL :
 forall p : Qpositive,
 Qpos (dL p) = Qmult (Qpos p) (Qinv (Qplus (Qpos p) Qone)).
Proof.
 intros.
 simpl in |- *.
 apply f_equal with Qpositive.
 apply what_dL_does.
Qed. 

Lemma Qmult_Z_dL :
 forall (a : Z) (p : Qpositive),
 Qmult (Z_to_Q a) (Qpos (dL p)) =
 Qmult (Qmult (Z_to_Q a) (Qpos p)) (Qinv (Qplus (Qpos p) Qone)).
Proof.
 intros.
 rewrite Qpos_dL.
 ring.
Qed.

Lemma length_of_Qpositive_is_length :
 forall p : positive,
 length_of_Qpositive (Qpositive_c (nat_of_P p) 1 (S (nat_of_P p))) =
 (Zpos p - 1)%Z.
Proof.
 intro p.
 generalize (lt_O_nat_of_P p).
 rewrite <- ZL9.
 generalize (nat_of_P p).
 induction n.
 intro.
 inversion H.
 intro.
 case (le_lt_eq_dec 1 (S n) (lt_le_S _ _ H)).
 intro H1.
 rewrite (Qpositive_c_nR _ _ (S n) H1).
 transitivity (1 + length_of_Qpositive (Qpositive_c (S n - 1) 1 (S n)))%Z.
 reflexivity.
 rewrite Znat.inj_S.
 rewrite Zplus_comm.
 unfold Z.succ in |- *. 
 transitivity (n - 1 + 1)%Z; [ idtac | omega ].
 apply f_equal2 with Z Z; trivial. 
 rewrite <- IHn.
 apply f_equal with Qpositive.
 apply f_equal3 with nat nat nat; trivial.
 simpl in |- *; auto with arith. 
 omega.
 intro H1; rewrite <- H1.
 rewrite Qpositive_c_equal_One; trivial.
Qed.

Lemma Qpositive_to_Z_is_integer_part :
 forall x : positive,
 Qpositive_to_Z (Qpositive_c (nat_of_P x) 1 (S (nat_of_P x))) = Zpos x.
Proof.
 intro p.
 generalize (lt_O_nat_of_P p).
 rewrite <- ZL9.
 generalize (nat_of_P p).
 induction n; intro H.
 inversion H.
 case (le_lt_eq_dec 1 (S n) (lt_le_S _ _ H)).
 intro H1.
 rewrite (Qpositive_c_nR _ _ (S n) H1).
 transitivity (1 + Qpositive_to_Z (Qpositive_c (S n - 1) 1 (S n)))%Z.
 reflexivity.
 rewrite Znat.inj_S.
 rewrite Zplus_comm.
 unfold Z.succ in |- *. 
 apply f_equal2 with Z Z; trivial. 
 rewrite <- IHn.
 apply f_equal with Qpositive.
 apply f_equal3 with nat nat nat; trivial.
 simpl in |- *; auto with arith. 
 omega.
 intro H1; rewrite <- H1.
 rewrite Qpositive_c_equal_One; trivial.
Qed.
 
Lemma Q_to_Z_to_Q : forall x : Z, Q_to_Z (Z_to_Q x) = x.
Proof.
 intros [| x| x]; trivial; unfold Z_to_Q in |- *; unfold Q_to_Z in |- *;
  rewrite Qpositive_to_Z_is_integer_part; reflexivity.
Qed.
  
Lemma eq_Z_to_Q : forall x y : Z, Z_to_Q x = Z_to_Q y -> x = y.
Proof.
 intros x y H.
 generalize (f_equal Q_to_Z H). 
 intro H0.
 rewrite (Q_to_Z_to_Q x) in H0.
 rewrite (Q_to_Z_to_Q y) in H0.
 assumption.
Qed.

Lemma Z_to_Qpositive_equal :
 forall (m1 m2 : Z) (Hm1 : (0 < m1)%Z) (Hm2 : (0 < m2)%Z),
 m1 = m2 -> Z_to_Qpositive m1 Hm1 = Z_to_Qpositive m2 Hm2.
Proof.
  intros m1;
  induction m1.

  discriminate Hm1.

  unfold Z_to_Qpositive.
  intros m2 H Hm2 H_eq;revert Hm2.
  rewrite <- H_eq;reflexivity.

  intros m2 m1 abs;discriminate.
Qed. 

Functional Scheme Z_to_Q_ind := Induction for Z_to_Q Sort Prop.

Lemma Z_to_Qpositive_to_Q :
 forall (m : Z) (Hm : (0 < m)%Z), Z_to_Q m = Qpos (Z_to_Qpositive m Hm).
Proof.
 intros m; functional induction (Z_to_Q m); intros Hm;
            discriminate Hm || trivial.
Qed. 

Lemma Qpos_injective :
 forall qp1 qp2 : Qpositive, Qpos qp1 = Qpos qp2 -> qp1 = qp2.
Proof.
 intros qp1 qp2 H; injection H; trivial.
Qed.

Lemma Qneg_injective :
 forall qp1 qp2 : Qpositive, Qneg qp1 = Qneg qp2 -> qp1 = qp2.
Proof.
 intros qp1 qp2 H; injection H; trivial.
Qed.

Lemma Q_tail_Q_pos : forall q : Q, Qlt Zero q -> q = Qpos (Q_tail q).
Proof.
 intros [| q| q]; unfold Qlt in |- *; intros H;
            inversion H || unfold Q_tail in |- *; reflexivity.
Qed.

Lemma Q_tail_Q_neg : forall q : Q, Qlt q Zero -> q = Qneg (Q_tail q).
Proof.
 intros [| q| q]; unfold Qlt in |- *; intros H;
            inversion H || unfold Q_tail in |- *; reflexivity.
Qed.

Lemma Qpositive_to_Z_nonneg : forall x : Qpositive, (0 <= Qpositive_to_Z x)%Z.
Proof.
 intros x; induction  x as [x Hrecx| x Hrecx| ];
            [ replace (Qpositive_to_Z (nR x)) with (1 + Qpositive_to_Z x)%Z;
               trivial; abstract omega
            | simpl in |- *; apply Z.le_refl
            | simpl in |- *; intro H; discriminate ].
Qed. 
 
Functional Scheme Qpositive_le_bool_ind := 
  Induction for Qpositive_le_bool Sort Prop.

Lemma Qpositive_to_Z_Qpositive_le :
 forall x y : Qpositive,
 (Qpositive_to_Z x < Qpositive_to_Z y)%Z -> Qpositive_le x y.
Proof.
 intros x y.
 unfold Qpositive_le in |- *.
 functional induction (Qpositive_le_bool x y) ;intros; 
    trivial.
 apply IHb.
 unfold Qpositive_to_Z in H;fold Qpositive_to_Z in H. 
 omega.
unfold Qpositive_to_Z in H;fold Qpositive_to_Z in H;
 generalize (Qpositive_to_Z_nonneg y);intros;
 apply False_ind;omega.
unfold Qpositive_to_Z in H;fold Qpositive_to_Z in H;
 generalize (Qpositive_to_Z_nonneg y);intros;
 apply False_ind;omega.
 apply IHb.
 unfold Qpositive_to_Z in H;fold Qpositive_to_Z in H. 
 omega.
 unfold Qpositive_to_Z in H;fold Qpositive_to_Z in H;discriminate.
Qed.

Lemma Q_to_Z_monotone : forall x y : Q, Qlt x y -> (Q_to_Z x <= Q_to_Z y)%Z.
Proof.
 intros x y.
 unfold Qlt in |- *.
 intro H.
 induction H; simpl in |- *; apply not_Zlt; intro H1.
 apply H; apply Qpositive_to_Z_Qpositive_le; assumption.
 generalize (Zmin_cancel_Zlt _ _ H1); intro H2; apply H;
  apply Qpositive_to_Z_Qpositive_le; assumption.
 apply Z.lt_irrefl with 0%Z; generalize (Qpositive_to_Z_nonneg x'); intro H2;
  omega.
 apply Z.lt_irrefl with 0%Z; generalize (Qpositive_to_Z_nonneg x');
  generalize (Qpositive_to_Z_nonneg y'); intros H2 H3; abstract 
  omega.
 apply Z.lt_irrefl with 0%Z; generalize (Qpositive_to_Z_nonneg x'); intro H2;
  omega.
Qed.

Lemma Qlt_irreflexive : forall x : Q, ~ Qlt x x.
Proof.
 intro x; unfold Qlt in |- *; intro H; apply Qgt_antisym with x x; assumption.
Qed.

Hint Resolve Qlt_irreflexive.

Lemma Qlt_not_eq : forall x y : Q, Qlt x y -> y <> x.
Proof.
 intros x y Hxlty Hxy; rewrite Hxy in Hxlty; apply Qlt_irreflexive with x;
  assumption.
Qed. 

Hint Resolve Qlt_not_eq.

Lemma Qlt_transitive : forall x y z : Q, Qlt x y -> Qlt y z -> Qlt x z.
Proof.
 intros x y z H1 H2.
 unfold Qlt in |- *.
 apply Qgt_trans with y; assumption.
Qed.

Lemma Z_to_Qopp : forall x : Z, Z_to_Q (- x) = Qopp (Z_to_Q x).
Proof.
 intros [| x| x]; trivial.
Qed. 

Lemma Z_to_Qplus_POS :
 forall p1 p2 : positive,
 Z_to_Q (Zpos p1 + Zpos p2) = Qplus (Z_to_Q (Zpos p1)) (Z_to_Q (Zpos p2)).
Proof.
 intros p1 p2.
  unfold Z_to_Q at 2 3 in |- *.
  unfold Qplus in |- *.
  rewrite <- BinInt.Zpos_plus_distr.
  unfold Z_to_Q at 1 in |- *.
  apply f_equal with Qpositive.
  unfold Qpositive_plus in |- *.
  repeat rewrite Qpositive_i_c. 
  repeat rewrite mult_1_l.
  repeat rewrite mult_1_r.
  apply f_equal3 with nat nat nat; trivial.
  apply nat_of_P_plus_morphism.
  rewrite nat_of_P_plus_morphism.
  omega.
  apply lt_O_nat_of_P.
  constructor.
  apply lt_O_nat_of_P.
  constructor. 
Qed.

Lemma Z_to_Qplus_POS_NEG :
 forall p1 p2 : positive,
 Z_to_Q (Zpos p1 + Zneg p2) = Qplus (Z_to_Q (Zpos p1)) (Z_to_Q (Zneg p2)).
Proof.
 intros p1 p2.

  assert
   (H :
    Qplus (Z_to_Q (Zpos p1 + Zneg p2)) (Z_to_Q (Zpos p2)) = Z_to_Q (Zpos p1)).
  set (P := (Zpos p1 + Zneg p2)%Z) in *.
  assert (P = (Zpos p1 + Zneg p2)%Z); trivial.
  destruct P.
  unfold Z_to_Q at 1 in |- *.
  rewrite Qplus_zero_left.
  apply f_equal with Z.
  transitivity (- Zneg p2)%Z; trivial.
  omega.
  rewrite <- Z_to_Qplus_POS.
  apply f_equal with Z.
  replace (Zpos p2) with (- Zneg p2)%Z; trivial.  
  omega.
  
  unfold Z_to_Q at 1 2 3 in |- *.
  assert (Hp : (Zpos p < Zpos p2)%Z).
  apply Zmin_cancel_Zlt.
  unfold Z.opp in |- *.
  rewrite H.
  rewrite <- (Zplus_0_l (Zneg p2)).
  apply Zplus_lt_compat_r.
  constructor.

  unfold Qplus in |- *.
  
  case
   (Qpositive_le_dec (Qpositive_c (nat_of_P p) 1 (S (nat_of_P p)))
      (Qpositive_c (nat_of_P p2) 1 (S (nat_of_P p2)))); 
   intro H1.
   case
    (Qpositive_eq_dec (Qpositive_c (nat_of_P p) 1 (S (nat_of_P p)))
       (Qpositive_c (nat_of_P p2) 1 (S (nat_of_P p2)))); 
    intro H2.
    apply False_ind.
    generalize (f_equal Qpositive_to_Z H2). 
    do 2 rewrite Qpositive_to_Z_is_integer_part.
    apply Zorder.Zlt_not_eq; assumption.

    assert (Hp' : Zpos p2 = (Zpos p1 + Zpos p)%Z).
    clear H1 H2.
    replace (Zpos p) with (- Zneg p)%Z; trivial.
    rewrite H.
    replace (Zneg p2) with (- Zpos p2)%Z; trivial.
    auto with zarith.
    rewrite <- BinInt.Zpos_plus_distr in Hp'.
    generalize (POS_resp_eq _ _ Hp').
    intro Hp2.

    apply f_equal with Qpositive.
    unfold Qpositive_sub in |- *.
    repeat rewrite Qpositive_i_c. 
    repeat rewrite mult_1_l.
    repeat rewrite mult_1_r.
    clear H1 H2; apply Qpositive_c_equal_strong; trivial; try omega;
     rewrite Hp2; rewrite nat_of_P_plus_morphism.
    omega.
    replace (nat_of_P p1 + nat_of_P p - nat_of_P p) with (nat_of_P p1);
     [ apply lt_O_nat_of_P | omega ].
    apply lt_O_nat_of_P.
    constructor.
    apply lt_O_nat_of_P.
    constructor. 

   apply False_ind; apply H1.
   apply Qpositive_to_Z_Qpositive_le.
   do 2 rewrite Qpositive_to_Z_is_integer_part.
   assumption.
  
 rewrite <- H.
 replace (Zneg p2) with (- Zpos p2)%Z; trivial.
 rewrite Z_to_Qopp.
 ring.
Qed. 
 
Lemma Z_to_Qplus_NEG :
 forall p1 p2 : positive,
 Z_to_Q (Zneg p1 + Zneg p2) = Qplus (Z_to_Q (Zneg p1)) (Z_to_Q (Zneg p2)).
Proof.
 intros p1 p2.
 replace (Zneg p1) with (- Zpos p1)%Z; trivial.
 replace (Zneg p2) with (- Zpos p2)%Z; trivial.
 rewrite <- Zopp_plus_distr.
 repeat rewrite Z_to_Qopp.
 rewrite Z_to_Qplus_POS.
 ring. 
Qed.

Lemma Z_to_Qplus :
 forall x y : Z, Z_to_Q (x + y) = Qplus (Z_to_Q x) (Z_to_Q y).
Proof.
 intros [| x| x] [| y| y]; trivial;
  [ apply Z_to_Qplus_POS
  | apply Z_to_Qplus_POS_NEG
  | rewrite Zplus_comm; rewrite Qplus_sym; apply Z_to_Qplus_POS_NEG
  | apply Z_to_Qplus_NEG ].
Qed.

Lemma Z_to_Qminus :
 forall x y : Z, Z_to_Q (x - y) = Qminus (Z_to_Q x) (Z_to_Q y).
Proof.
 intros x y.
 unfold Zminus in |- *.
 rewrite Z_to_Qplus.
 rewrite Z_to_Qopp.
 reflexivity.
Qed.

Lemma Z_to_Qmult_POS :
 forall p1 p2 : positive,
 Z_to_Q (Zpos p1 * Zpos p2) = Qmult (Z_to_Q (Zpos p1)) (Z_to_Q (Zpos p2)).
Proof.
 intros p1 p2.
 unfold Z_to_Q at 2 3 in |- *.
 unfold Qmult in |- *.
 replace (Zpos p1 * Zpos p2)%Z with (Zpos (p1 * p2)); trivial. 
 unfold Z_to_Q at 1 in |- *.
 apply f_equal with Qpositive.
 unfold Qpositive_mult in |- *.
 repeat rewrite Qpositive_i_c. 
 repeat rewrite mult_1_l.
 apply f_equal3 with nat nat nat; trivial.
 apply nat_of_P_mult_morphism.
 rewrite nat_of_P_mult_morphism.
 omega.
 apply lt_O_nat_of_P.
 constructor.
 apply lt_O_nat_of_P.
 constructor. 
Qed.

Lemma Z_to_Qmult_POS_NEG :
 forall p1 p2 : positive,
 Z_to_Q (Zpos p1 * Zneg p2) = Qmult (Z_to_Q (Zpos p1)) (Z_to_Q (Zneg p2)).
Proof.
 intros p1 p2.
 unfold Z_to_Q at 2 3 in |- *.
 unfold Qmult in |- *.
 replace (Zpos p1 * Zneg p2)%Z with (Zneg (p1 * p2)); trivial. 
 unfold Z_to_Q at 1 in |- *.
 apply f_equal with Qpositive.
 unfold Qpositive_mult in |- *.
 repeat rewrite Qpositive_i_c. 
 repeat rewrite mult_1_l.
 apply f_equal3 with nat nat nat; trivial.
 apply nat_of_P_mult_morphism.
 rewrite nat_of_P_mult_morphism.
 omega.
 apply lt_O_nat_of_P.
 constructor.
 apply lt_O_nat_of_P.
 constructor. 
Qed.

Lemma Z_to_Qmult_NEG :
 forall p1 p2 : positive,
 Z_to_Q (Zneg p1 * Zneg p2) = Qmult (Z_to_Q (Zneg p1)) (Z_to_Q (Zneg p2)).
Proof.
 intros p1 p2.
 unfold Z_to_Q at 2 3 in |- *.
 unfold Qmult in |- *.
 replace (Zneg p1 * Zneg p2)%Z with (Zpos (p1 * p2)); trivial. 
 unfold Z_to_Q at 1 in |- *.
 apply f_equal with Qpositive.
 unfold Qpositive_mult in |- *.
 repeat rewrite Qpositive_i_c. 
 repeat rewrite mult_1_l.
 apply f_equal3 with nat nat nat; trivial.
 apply nat_of_P_mult_morphism.
 rewrite nat_of_P_mult_morphism.
 omega.
 apply lt_O_nat_of_P.
 constructor.
 apply lt_O_nat_of_P.
 constructor. 
Qed.

Lemma Z_to_Qmult :
 forall x y : Z, Z_to_Q (x * y) = Qmult (Z_to_Q x) (Z_to_Q y).
Proof.
 intros [| x| x] [| y| y]; trivial;
  [ apply Z_to_Qmult_POS
  | apply Z_to_Qmult_POS_NEG
  | rewrite Zmult_comm; rewrite Qmult_sym; apply Z_to_Qmult_POS_NEG
  | apply Z_to_Qmult_NEG ].
Qed.

Lemma Z_to_Q_S:forall k, Z_to_Q (Z_of_nat (S k))=Qplus k Qone.
Proof.
 induction k; trivial.
 rewrite inj_S; unfold Z.succ; rewrite Z_to_Qplus; rewrite IHk;
 unfold Z_to_Q at 2; simpl; fold Qone; ring.
Qed.

Lemma Z_to_Q_min_one:Z_to_Q (-1)%Z= Qopp Qone.
Proof.
 reflexivity.
Qed.

Lemma Qlt_Zero_Qminus : forall x y : Q, Qlt Zero (Qminus y x) -> Qlt x y. 
Proof.
 intros x y H; replace x with (Qplus x Zero); [ idtac | ring ];
            replace y with (Qplus x (Qminus y x)); 
            [ idtac | ring ]; unfold Qlt in |- *; apply Qgt_plus; 
            assumption.
Qed.

Lemma Z_to_Qlt : forall x y : Z, (x < y)%Z -> Qlt x y.
Proof. 
 intros x y H.
 apply Qlt_Zero_Qminus.
 generalize (Z.lt_gt _ _ H); clear H; intro H.
 case (Zcompare_Gt_spec _ _ H).
 intros p Hp.
 rewrite <- Z_to_Qminus.
 unfold Zminus in |- *.
 rewrite Hp.
 unfold Z_to_Q in |- *.
 apply Qlt_zero_pos.
Qed.

Lemma lt_Z_to_Q : forall x y : Z, Qlt (Z_to_Q x) (Z_to_Q y) -> (x < y)%Z.
Proof.
 intros x y H.  
 case (Z_dec' x y).
 intros [H1| H1]; trivial.
 apply False_ind.
 apply Qlt_irreflexive with x.
 apply Qlt_transitive with y; trivial.
 apply Z_to_Qlt; assumption.
 intro H1.
 apply False_ind.
 rewrite H1 in H.
 generalize H.
 apply Qlt_irreflexive.
Qed. 
 
Lemma pos_Z_to_Q : forall x : Z, Qlt Zero (Z_to_Q x) -> (0 < x)%Z.
Proof.
 intros x H.
 apply lt_Z_to_Q; assumption.
Qed.

Lemma neg_Z_to_Q : forall x : Z, Qlt (Z_to_Q x) Zero -> (x < 0)%Z.
Proof.
 intros x H.
 apply lt_Z_to_Q; assumption.
Qed.

Lemma Qlt_le_weak : forall x y : Q, Qlt x y -> Qle x y.
Proof.
 intros x y H.
 unfold Qle in |- *.
 intro H2; apply Qlt_irreflexive with x; apply Qlt_transitive with y;
  assumption. 
Qed.

Lemma Z_to_Qle : forall x y : Z, (x <= y)%Z -> Qle x y.
Proof.
 intros x y H.
 case (Z_le_lt_eq_dec _ _ H); intro H1.
 apply Qlt_le_weak; apply Z_to_Qlt; assumption.
 rewrite H1; unfold Qle in |- *; apply Qlt_irreflexive.
Qed.

Lemma Z_to_Q_pos : forall x : Z, (0 < x)%Z -> Qlt Zero x.
Proof.
 intros x H.
 replace Zero with (Z_to_Q 0); trivial.
 apply Z_to_Qlt; assumption.
Qed.

Lemma Z_to_Q_neg : forall x : Z, (x < 0)%Z -> Qlt x Zero.
Proof.
 intros x H.
 replace Zero with (Z_to_Q 0); trivial.
 apply Z_to_Qlt; assumption.
Qed.

Lemma Z_to_Q_nonneg : forall x : Z, (0 <= x)%Z -> Qle Zero x.
Proof.
 intros x H.
 replace Zero with (Z_to_Q 0); trivial.
 apply Z_to_Qle; assumption.
Qed.

Lemma Z_to_Q_nonpos : forall x : Z, (x <= 0)%Z -> Qle x Zero.
Proof.
 intros x H.
 replace Zero with (Z_to_Q 0); trivial.
 apply Z_to_Qle; assumption.
Qed.

Lemma Z_to_Q_not_eq : forall a b : Z, a <> b -> Z_to_Q a <> Z_to_Q b.
Proof.
 intros a b Hab HabQ; apply Hab; apply eq_Z_to_Q; assumption.
Qed.

Lemma Qmult_Z_plus_Z_dL :
 forall (a b : Z) (p : Qpositive),
 Qplus (Qmult (Z_to_Q a) (Qpos (dL p))) (Z_to_Q b) =
 Qmult (Qplus (Qmult (Z_to_Q (a + b)) (Qpos p)) (Z_to_Q b))
   (Qinv (Qplus (Qpos p) Qone)).
Proof.
 intros; rewrite Qmult_Z_dL.
 rewrite Z_to_Qplus; field; discriminate.
Qed.

Lemma Qinv_0 : forall q : Q, Qinv q = Zero -> q = Zero. 
Proof.
 intros [| qp | qp ] Hqp; try trivial; discriminate Hqp.
Qed. 

Lemma Qmult_resp_nonzero :
 forall x y : Q, x <> Zero -> y <> Zero -> Qmult x y <> Zero.
Proof.
 intros x y Hx Hy Hxy; generalize (Q_integral _ _ Hxy); intros [H| H];
  [ apply Hx | apply Hy ]; assumption.
Qed.

Hint Resolve Qmult_resp_nonzero.

Lemma Qlt_mult_pos_pos :
 forall x y : Q, Qlt Zero x -> Qlt Zero y -> Qlt Zero (Qmult x y).
Proof.
 intros [| x| x] [| y| y] Hx Hy; trivial; simpl in |- *;
            auto with *; [ inversion Hy | inversion Hx ].
Qed.

Lemma Qlt_mult_neg_pos :
 forall x y : Q, Qlt x Zero -> Qlt Zero y -> Qlt (Qmult x y) Zero.
Proof.
 intros [| x| x] [| y| y] Hx Hy; trivial; simpl in |- *;
            auto with *; [ inversion Hx | inversion Hy ].
Qed.

Hint Resolve Qlt_mult_pos_pos Qlt_mult_neg_pos.

Lemma Qlt_plus_pos_pos :
 forall x y : Q, Qlt Zero x -> Qlt Zero y -> Qlt Zero (Qplus x y).
Proof.
 intros [| x| x] [| y| y] Hx Hy; trivial; simpl in |- *;
            auto with *; [ inversion Hy | inversion Hx | inversion Hx ].
Qed.

Hint Resolve Qlt_plus_pos_pos.

Lemma Qdiv_num_denom :
 forall q1 q2 p : Q,
 p <> Zero -> Qmult q1 (Qinv q2) = Qmult (Qmult q1 p) (Qinv (Qmult q2 p)).
Proof.
intros q1 [| qp| qp] p Hp;
 (simpl in |- *; ring) || (field; split; discriminate || assumption).
Qed.

Lemma Qinv_1 : forall q : Q, Qlt Zero (Qinv q) -> Qlt Zero q.
Proof.
 intros [| q| q] Hq; trivial; inversion Hq.
Qed.

Lemma Qinv_2 : forall q : Q, Qlt (Qinv q) Zero -> Qlt q Zero.
Proof.
 intros [| q| q] Hq; trivial; inversion Hq.
Qed.

Lemma Qinv_pos : forall q : Q, Qlt Zero q -> Qlt Zero (Qinv q).
Proof.
 intros [| q| q] Hq; simpl in |- *; trivial; inversion Hq.
Qed.

Lemma Qmult_one_right : forall x : Q, Qmult x Qone = x.
Proof.
 intro q; rewrite Qmult_sym; apply Qmult_one_left.
Qed.

Lemma Qpos_POS_1 :
 forall (m : Z) (qp : Qpositive), Z_to_Q m = Qpos qp -> (0 < m)%Z.
Proof.
 intros m qp Hm; apply pos_Z_to_Q; rewrite Hm; apply Qlt_zero_pos.
Qed.

Lemma Qneg_NEG_1 :
 forall (m : Z) (qp : Qpositive), Z_to_Q m = Qneg qp -> (m < 0)%Z.
Proof.
 intros m qp Hm; apply neg_Z_to_Q; rewrite Hm; apply Qlt_neg_zero.
Qed.

Lemma Qopp_Qpos : forall q : Qpositive, Qneg q = Qopp (Qpos q).
Proof.
 trivial.
Qed.

Lemma Qopp_Qneg : forall q : Qpositive, Qpos q = Qopp (Qneg q).
Proof.
 trivial.
Qed.

Lemma Qopp_linear :
 forall (a b : Z) (q : Qpositive),
 Qplus (Qmult (Z_to_Q (- a)) (Qpos q)) (Z_to_Q (- b)) =
 Qopp (Qplus (Qmult (Z_to_Q a) (Qpos q)) (Z_to_Q b)).
Proof.
 intros a b q; repeat rewrite Zopp_eq_mult_neg_1;
            repeat rewrite Z_to_Qmult; repeat rewrite <- Qmult_assoc;
            rewrite (Qmult_sym (-1)%Z); repeat rewrite Qmult_assoc;
            repeat rewrite <- Q_distr_left;
            replace (Z_to_Q (-1)) with (Qopp Qone); 
            [ ring | reflexivity ].
Qed. 

Lemma Qopp_resp_nonzero : forall x : Q, x <> Zero -> Qopp x <> Zero.
Proof.
 intros [| qx| qx] H; discriminate || Falsum.
Qed.

Lemma Qinv_Qopp : forall q : Q, Qinv (Qopp q) = Qopp (Qinv q).
Proof.
 intros [| q| q]; reflexivity.
Qed. 

Lemma Qmult_Qopp_left : forall x y : Q, Qmult (Qopp x) y = Qopp (Qmult x y).
Proof.
 intros [| qx| qx] [| qy| qy]; reflexivity.
Qed.

Lemma Qpositive_dec_One : forall p : Qpositive, {p = One} + {p <> One}.
Proof. 
 intro p; exact (Qpositive_eq_dec p One).
Defined.

Lemma Q_zerop : forall x : Q, {x = Zero} + {x <> Zero}.
Proof.
 intros [| px| px]; solve [ left; trivial | right; discriminate ].
Qed.         
 
Lemma Qinv_resp_nonzero : forall x : Q, x <> Zero -> Qinv x <> Zero.
Proof.
 intros [| px| px] Hx; solve [ Falsum | discriminate ].
Qed. 

Lemma Qlt_zero_one : Qlt Zero Qone.
Proof.
 unfold Qone in |- *; apply Qlt_zero_pos. 
Qed.

Hint Resolve Qlt_zero_one.

Lemma Z_to_Qpositive_Q_tail_pos :
 forall (a : Z) (Ha : (0 < a)%Z), Z_to_Qpositive a Ha = Q_tail a.
Proof.
 intros [| px| px] Hx; discriminate Hx || reflexivity.
Qed.

Lemma Q_tail_Qinv : forall x : Q, Q_tail (Qinv x) = Qpositive_inv (Q_tail x).
Proof.
 intros [| px| px]; trivial.
Qed.

Lemma Q_tail_Qmult :
 forall x y : Q,
 x <> Zero ->
 y <> Zero -> Q_tail (Qmult x y) = Qpositive_mult (Q_tail x) (Q_tail y). 
Proof.
 intros [| px| px] [| py| py] Hx Hy; trivial; Falsum.
Qed.

Lemma Q_tail_Qplus_pos :
 forall x y : Q,
 Qlt Zero x ->
 Qlt Zero y -> Q_tail (Qplus x y) = Qpositive_plus (Q_tail x) (Q_tail y). 
Proof.
 intros [| px| px] [| py| py] Hx Hy; trivial; solve
            [ inversion Hx | inversion Hy ].
Qed.

Lemma Q_tail_Qplus_neg :
 forall x y : Q,
 Qlt x Zero ->
 Qlt y Zero -> Q_tail (Qplus x y) = Qpositive_plus (Q_tail x) (Q_tail y). 
Proof.
 intros [| px| px] [| py| py] Hx Hy; trivial; solve
            [ inversion Hx | inversion Hy ].
Qed.

Lemma Qplus_zero_right : forall n : Q, Qplus n Zero = n.
Proof.
 intros; field.
Qed.

Lemma Qmult_zero_right : forall x : Q, Qmult x Zero = Zero.
Proof.
 intros; field.
Qed.

Lemma Qle_Qpositive_le_pos :
 forall x y : Qpositive, Qle (Qpos x) (Qpos y) -> Qpositive_le x y.
Proof.
 intros x y H.
 case (Qpositive_le_dec x y); intros H1; trivial; apply False_ind; apply H;
  constructor; assumption.
Qed. 

Lemma Qle_Qpositive_le_neg :
 forall x y : Qpositive, Qle (Qneg x) (Qneg y) -> Qpositive_le y x.
Proof.
 intros x y H.
 case (Qpositive_le_dec y x); intros H1; trivial; apply False_ind; apply H;
  constructor; assumption.
Qed. 

Lemma Qle_lt_eq_dec : forall x y : Q, Qle x y -> {Qlt x y} + {x = y}.
Proof.
 intros [| x| x] [| y| y] Hxy;
  try solve
   [ right; reflexivity
   | left; auto with *
   | right; auto with *
   | apply False_rec; apply Hxy; auto with * ];
  [ generalize (Qle_Qpositive_le_pos _ _ Hxy)
  | generalize (Qle_Qpositive_le_neg _ _ Hxy) ]; clear Hxy; 
  intro Hxy;
  match goal with
  | id1:(Qpositive_le ?X1 ?X2) |- _ =>
      case (Qpositive_le_dec X2 X1); intro H;
       [ right; apply f_equal with Qpositive; apply Qpositive_le_antisym;
          assumption
       | left; constructor; assumption ]
  end. 
Qed.

Lemma Qle_lt_trans : forall x y z : Q, Qle x y -> Qlt y z -> Qlt x z.
Proof.
 intros [| x| x] [| y| y] [| z| z] Hxy Hyz; trivial; try QltCleanAbsurdCases;
  case (Qle_lt_eq_dec _ _ Hxy); intro Hxy';
  [ apply Qlt_transitive with (Qpos y)
  | rewrite Hxy'
  | apply Qlt_transitive with (Qneg y)
  | rewrite Hxy' ]; assumption.
Qed.

Lemma Qlt_le_trans : forall x y z : Q, Qlt x y -> Qle y z -> Qlt x z.
Proof.
 intros [| x| x] [| y| y] [| z| z] Hxy Hyz; trivial; try QltCleanAbsurdCases;
  case (Qle_lt_eq_dec _ _ Hyz); intro Hyz';
  [ apply Qlt_transitive with (Qpos y)
  | rewrite <- Hyz'
  | apply Qlt_transitive with (Qneg y)
  | rewrite <- Hyz' ]; assumption.
Qed.

Lemma Qle_trans : forall x y z : Q, Qle x y -> Qle y z -> Qle x z.
Proof.
 intros x y z Hxy Hyz Hxz; apply Hyz; apply Qlt_le_trans with x; assumption.
Qed.

Lemma Qlt_plus_plus :
 forall a b c d : Q, Qlt a b -> Qlt c d -> Qlt (Qplus a c) (Qplus b d).
Proof.
 intros a b c d Hab Hcd.
 apply Qlt_transitive with (Qplus b c); unfold Qlt in |- *;
  [ rewrite (Qplus_sym a); rewrite (Qplus_sym b) | idtac ]; 
  apply Qgt_plus; assumption.
Qed.

Lemma Qle_lt_reg :
 forall a b c d : Q, Qle a b -> Qlt c d -> Qlt (Qplus a c) (Qplus b d).
Proof.
 intros a b c d Hab Hcd.
 case (Qle_lt_eq_dec _ _ Hab); intro Hab';
  [ apply Qlt_plus_plus | rewrite Hab'; unfold Qlt in |- *; apply Qgt_plus ];
  assumption.
Qed.

Lemma Qlt_le_reg :
 forall a b c d : Q, Qlt a b -> Qle c d -> Qlt (Qplus a c) (Qplus b d).
Proof.
 intros a b c d Hab Hcd; rewrite (Qplus_sym a); rewrite (Qplus_sym b);
  apply Qle_lt_reg; assumption.
Qed.

Lemma Qlt_le_reg_pos :
 forall b d : Q, Qlt Zero b -> Qle Zero d -> Qlt Zero (Qplus b d).
Proof.
 intros b d Hb Hd; replace Zero with (Qplus Zero Zero); trivial;
  apply Qlt_le_reg; assumption.
Qed.

Lemma Qle_lt_reg_pos :
 forall b d : Q, Qle Zero b -> Qlt Zero d -> Qlt Zero (Qplus b d).
Proof.
 intros b d Hb Hd; replace Zero with (Qplus Zero Zero); trivial;
  apply Qle_lt_reg; assumption.
Qed.

Lemma Qlt_le_reg_neg :
 forall b d : Q, Qlt b Zero -> Qle d Zero -> Qlt (Qplus b d) Zero.
Proof.
 intros b d Hb Hd; replace Zero with (Qplus Zero Zero); trivial;
  apply Qlt_le_reg; assumption.
Qed.
 
Lemma Qle_lt_reg_neg :
 forall b d : Q, Qle b Zero -> Qlt d Zero -> Qlt (Qplus b d) Zero.
Proof.
 intros b d Hb Hd; replace Zero with (Qplus Zero Zero); trivial;
  apply Qle_lt_reg; assumption.
Qed.

Lemma Qle_plus_plus :
 forall a b c d : Q, Qle a b -> Qle c d -> Qle (Qplus a c) (Qplus b d).
Proof.
 intros a b c d Hab Hcd.
 apply Qle_trans with (Qplus b c); unfold Qlt in |- *;
  [ rewrite (Qplus_sym a); rewrite (Qplus_sym b) | idtac ];
  [ case (Qle_lt_eq_dec _ _ Hab) | case (Qle_lt_eq_dec _ _ Hcd) ]; 
  intro H_;
  [ apply Qlt_le_weak; apply Qle_lt_reg;
     [ unfold Qle in |- *; apply Qlt_irreflexive | assumption ]
  | rewrite H_; unfold Qle in |- *; apply Qlt_irreflexive
  | apply Qlt_le_weak; apply Qle_lt_reg;
     [ unfold Qle in |- *; apply Qlt_irreflexive | assumption ]
  | rewrite H_; unfold Qle in |- *; apply Qlt_irreflexive ].
Qed.

Lemma Qle_plus_pos_pos :
 forall x y : Q, Qle Zero x -> Qle Zero y -> Qle Zero (Qplus x y).
Proof.
 intros b d Hb Hd; replace Zero with (Qplus Zero Zero); trivial;
  apply Qle_plus_plus; assumption.
Qed.

Lemma Qle_plus_neg_neg :
 forall x y : Q, Qle x Zero -> Qle y Zero -> Qle (Qplus x y) Zero.
Proof.
 intros b d Hb Hd; replace Zero with (Qplus Zero Zero); trivial;
  apply Qle_plus_plus; assumption.
Qed.

Lemma Qle_mult_nonneg_nonneg :
 forall x y : Q, Qle Zero x -> Qle Zero y -> Qle Zero (Qmult x y).
Proof.
 intros [| x| x] [| y| y] Hx Hy; trivial; try QltCleanAbsurdCases;
  simpl in |- *; intro H_; inversion H_.
Qed.

Lemma Qle_mult_nonpos_nonneg :
 forall x y : Q, Qle x Zero -> Qle Zero y -> Qle (Qmult x y) Zero.
Proof.
 intros [| x| x] [| y| y] Hx Hy; trivial; try QltCleanAbsurdCases;
  simpl in |- *; intro H_; inversion H_.
Qed.

Lemma Qle_mult_nonneg_nonpos :
 forall x y : Q, Qle Zero x -> Qle y Zero -> Qle (Qmult x y) Zero.
Proof.
 intros [| x| x] [| y| y] Hx Hy; trivial; try QltCleanAbsurdCases;
  simpl in |- *; intro H_; inversion H_.
Qed.

Lemma Qle_mult_nonpos_pos:
 forall x y : Q, Qle x Zero -> Qlt Zero y -> Qle (Qmult x y) Zero.
Proof.
 intros [| x| x] [| y| y] Hx Hy; trivial; try QltCleanAbsurdCases;
  simpl in |- *; intro H_; inversion H_.
Qed.

Lemma Qle_mult_neg_nonneg :
 forall x y : Q, Qlt x Zero -> Qle Zero y -> Qle (Qmult x y) Zero.
Proof.
 intros [| x| x] [| y| y] Hx Hy; trivial; try QltCleanAbsurdCases;
  simpl in |- *; intro H_; inversion H_.
Qed.

Lemma Qle_reflexive:forall x, Qle x x.
Proof.
 intro x; unfold Qle; apply Qlt_irreflexive.
Qed.

Hint Resolve Qplus_zero_right Qlt_le_reg_pos Qle_lt_reg_pos Qlt_le_reg
  Qle_lt_reg Qlt_le_weak Qlt_le_reg_neg Qle_lt_reg_neg Qle_plus_pos_pos
  Qle_plus_neg_neg Qle_mult_nonneg_nonneg Qle_mult_nonneg_nonpos
  Qle_mult_nonpos_nonneg Qle_mult_nonpos_pos Qle_mult_neg_nonneg
  Qle_reflexive.

Lemma Qpos_not_lt_Zero : forall x, ~ Qlt (Qpos x) Zero.
Proof.
intros x Hc; apply (Qlt_irreflexive Zero); apply Qlt_transitive with (Qpos x);trivial.
Qed.

Lemma Qlt_dec_Qpos : forall x y, {~ Qlt (Qpos y) (Qpos x)} + {Qlt (Qpos y) (Qpos x)}.
  intros x y; case Qpositive_le_dec with x y; intro H'; [left;intro H; inversion H; contradiction | right;unfold Qlt; constructor; trivial].
Qed.

Lemma Zero_not_lt_Qneg : forall x, ~ Qlt Zero (Qneg x).
Proof.
intros x Hc; apply (Qlt_irreflexive Zero); apply Qlt_transitive with (Qneg x);trivial.
Qed.

Lemma Qpos_not_lt_Qneg : forall x y, ~ Qlt (Qpos y) (Qneg x).
Proof.
intros x y Hc; apply (Qlt_irreflexive (Qneg x)); apply Qlt_transitive with (Qpos y); trivial.
Qed.

Lemma Qlt_dec_Qneg : forall x y, {~ Qlt (Qneg y) (Qneg x)} + {Qlt (Qneg y) (Qneg x)}.
Proof.
intros x y; case Qpositive_le_dec with y x; intro H'; [left;intro H; inversion H; contradiction | right;unfold Qlt; constructor; trivial].
Qed.

Lemma Q_le_lt_dec:forall (x y:Q), {Qle x y}+{Qlt y x}.
Proof.
  intros [|x|x] [|y|y]; unfold Qle; try (right; trivial || fail).
  left; apply Qlt_irreflexive.
  left; apply Qpos_not_lt_Zero.
  apply Qlt_dec_Qpos.
  left; apply Zero_not_lt_Qneg.
  left; apply Qpos_not_lt_Qneg.
  apply Qlt_dec_Qneg.
Qed.

Lemma Qle_dec:forall (x y:Q), {Qle x y}+{~(Qle x y)}.
Proof.
 intros x y.
 case (Q_le_lt_dec x y);
 intros; [ left | right ] ; trivial.
 intros H'; apply H'; trivial.
Qed.

Lemma Qlt_dec:forall (x y:Q), {Qlt x y}+{~(Qlt x y)}.
Proof.
 intros x y.
 case (Q_le_lt_dec y x);
 intros; [ right | left ] ; trivial.
Qed.

Lemma Qtrichotomy_inf:forall x y,{Qlt x y}+{x=y}+{Qlt y x}.
Proof.
 intros x y.
 case (Q_le_lt_dec x y); intros H;
 [ case (Qle_lt_eq_dec x y H); intros H0; left;[left|right]
 | right
 ]; trivial.
Qed.

Lemma Qle_dec_weak:forall (x y:Q), {Qle x y}+{(Qle y x)}.
Proof.
 intros x y; case (Q_le_lt_dec x y); intros; [ left | right ] ; trivial; apply Qlt_le_weak; trivial.
Qed.

Lemma not_Qeq_inf : forall x y : Q, x <> y -> {Qlt x y} + {Qlt y x}.
Proof.
 intros x y Hxy; destruct (Q_le_lt_dec x y) as [H|H]; try tauto; 
 left; destruct (Qle_lt_eq_dec _ _ H) as [H'|H']; trivial; contradiction.
Qed.

Lemma Qlt_stepl:forall x y z, Qlt x y -> x=z -> Qlt z y.
Proof.
 intros x y z H_lt H_eq; subst; assumption.
Qed.

Lemma Qlt_stepr:forall x y z, Qlt x y -> y=z -> Qlt x z.
Proof.
 intros x y z H_lt H_eq; subst; assumption.
Qed.

Lemma Qle_stepl:forall x y z, Qle x y -> x=z -> Qle z y.
Proof.
 intros x y z H_lt H_eq; subst; assumption.
Qed.

Lemma Qle_stepr:forall x y z, Qle x y -> y=z -> Qle x z.
Proof.
 intros x y z H_lt H_eq; subst; assumption.
Qed.

Lemma Qneq_stepl:forall (x y z:Q), x<>y -> x=z -> z<>y.
Proof.
 intros x y z H_lt H_eq; subst; assumption.
Qed.

Lemma Qneq_stepr:forall (x y z:Q), x<>y -> y=z -> x<>z.
Proof.
 intros x y z H_lt H_eq; subst; assumption.
Qed.

Declare Left Step Qlt_stepl.
Declare Right Step Qlt_stepr.
Declare Left Step Qle_stepl.
Declare Right Step Qle_stepr.
Declare Left Step Qneq_stepl.
Declare Right Step Qneq_stepr.

Lemma Qsgn_1: forall x:Q,{(Qsgn x) = 0}+{(Qsgn x) = 1}+{(Qsgn x) = (-1)%Z}. 
Proof.
 intros [|x|x]; simpl; auto. 
Qed.

Lemma Qsgn_2 : forall x : Q, Qsgn x = 0%Z -> x = Zero.
Proof.
 intros [| x| x] Hx; trivial; inversion Hx.
Qed.

Lemma Qsgn_7 : forall x : Q, Qlt Zero x -> Qsgn x = 1%Z.
Proof.
 intros [| x| x] Hx; trivial; inversion Hx.
Qed.

Lemma Qsgn_8 : forall x : Q, Qlt x Zero -> Qsgn x = (-1)%Z.
Proof.
 intros [| x| x] Hx; trivial; inversion Hx.
Qed.

Lemma Qsgn_9 : forall x : Q, Qsgn x = 1%Z -> Qlt Zero x.
Proof.
 intros [| x| x] Hx; trivial; inversion Hx.
Qed.

Lemma Qsgn_10 : forall x : Q, Qsgn x = (-1)%Z -> Qlt x Zero.
Proof.
 intros [| x| x] Hx; trivial; inversion Hx.
Qed.

Lemma Qsgn_15 : forall x y : Q, Qsgn (Qmult x y) = (Qsgn x * Qsgn y)%Z.
Proof.
 intros [| x| x] [| y| y]; trivial. 
Qed.
 
Lemma Qsgn_25 : forall x : Q, Qsgn (Qopp x) = (- Qsgn x)%Z.
Proof.
 intros [| x| x]; trivial. 
Qed.

Lemma Qsgn_28 : forall x : Q, Qsgn (Qinv x) = Qsgn x.
Proof.
 intros [| x| x]; trivial. 
Qed.

Lemma Qsgn_29 : forall x : Z, Qsgn (Z_to_Q x) = Z.sgn x. 
Proof.
 intros [| x| x]; trivial. 
Qed.

Lemma Qsgn_30 : forall x y : Q, Qsgn (Qdiv x y) = (Qsgn x * Qsgn y)%Z.
Proof.
 intros [| x| x] [| y| y]; trivial. 
Qed.

Lemma Qsgn_31:forall x:Q, Qle x Zero-> Qsgn x <> 1.
Proof.
 intros [|x|x] Hx; try discriminate; apply False_ind; apply Hx; apply Qlt_zero_pos.
Qed.

Lemma Qsgn_32:forall x:Q, Qsgn x <> 1 -> Qle x  Zero.
Proof.
 intros [|x|x] Hx; auto; try apply Qle_reflexive; apply False_ind; apply Hx; reflexivity.
Qed.

Lemma Qsgn_33:forall x:Q, Qle Zero x -> Qsgn x <> (-1)%Z.
Proof.
 intros [|x|x] Hx; try discriminate; apply False_ind; apply Hx; auto.
Qed.

Lemma Qsgn_34:forall x:Q, Qsgn x <> (-1)%Z -> Qle Zero x.
Proof.
 intros [|x|x] Hx; auto; try apply Qle_reflexive; apply False_ind; apply Hx; reflexivity.
Qed.

Hint Resolve Qsgn_2 Qsgn_7 Qsgn_8 Qsgn_9 Qsgn_10 Qsgn_15 Qsgn_25 Qsgn_28
  Qsgn_29 Qsgn_30.

Ltac qnat_zero :=  replace (Z_to_Q (Z_of_nat 0)) with Zero;  trivial.
Ltac natq_zero :=  replace Zero with (Z_to_Q (Z_of_nat 0));  trivial.
Ltac qnat_one :=  replace (Z_to_Q (Z_of_nat (S 0))) with Qone;  trivial.
Ltac natq_one :=  replace Qone with (Z_to_Q (Z_of_nat (S 0)));  trivial.
Ltac qnat_S k :=  replace (Z_to_Q (Z_of_nat (S k))) with (Qplus k Qone); [idtac | rewrite Z_to_Q_S; trivial].
Ltac natq_S k :=  try qnat_one; replace (Qplus k Qone) with (Z_to_Q (Z_of_nat (S k))); [idtac | rewrite <- Z_to_Q_S; trivial].
Ltac qnat_S_rec k :=  
             try qnat_one; replace (Qplus k Qone) with (Z_to_Q (Z_of_nat (S k))); [idtac | rewrite <- Z_to_Q_S; trivial];
             try qnat_S_rec (k-1).

Ltac natZ_numerals  := 
 match goal with 
 | [ |- context [Z0] ] => replace Z0 with (Z_of_nat O); trivial; natZ_numerals
 | [ |- context [(Zpos ?X1)] ] => let v:= eval compute in (Z.abs_nat (Z.pred (Zpos X1))) in 
         replace (Zpos X1) with (Z_of_nat (S v)); trivial; natZ_numerals
 | [ |- context [(Zneg ?X1)] ] => let v:= eval compute in (Z.abs_nat (Z.succ (Zpos X1))) in 
         replace (Zneg X1) with (Z.opp (Z_of_nat (S v))); trivial; natZ_numerals
 | [ |- _ ] => idtac
 end.
