

Require Export Qhomographic.

Require Export quadraticAcc_Qquadratic_sign.

Require Import general_Q Zaux.
(* general_Q:
Require Import FunInd.
Require Export Qpositive.
Require Export Q_field.
Require Export Q_order.
Require Import Field_Theory_Q. 
Require Export Zaux.

Lemma Z_of_nat_Zabs_nat_pos: forall z, (0<=z)%Z -> Z_of_nat (Z.abs_nat z) = z.

Definition make_Q (m n : Z) :=
  match m, n with
  | Zpos _, Zpos _ =>
      Qpos (Qpositive_c (Z.abs_nat m) (Z.abs_nat n) (Z.abs_nat m + Z.abs_nat n))
  | Zneg _, Zneg _ =>
      Qpos (Qpositive_c (Z.abs_nat m) (Z.abs_nat n) (Z.abs_nat m + Z.abs_nat n))
  | Z0, _ => Zero
  | _, Z0 => Zero  
  | _, _ =>
      Qneg (Qpositive_c (Z.abs_nat m) (Z.abs_nat n) (Z.abs_nat m + Z.abs_nat n))
  end.

Definition decode_Q (q : Q) :=
  match q with
  | Qpos p =>
      (Z_of_nat (fst (Qpositive_i p)), Z_of_nat (snd (Qpositive_i p)))
  | Qneg p =>
      ((- Z_of_nat (fst (Qpositive_i p)))%Z, Z_of_nat (snd (Qpositive_i p)))
  | Zero => (0%Z, 1%Z)
  end.

Definition numerator (q:Q) :Z := fst (decode_Q q).

Definition denominator (q:Q) :Z := snd (decode_Q q).

Definition Z_to_Qpositive : forall x : Z, (0 < x)%Z -> Qpositive.

Definition Z_to_Q (x : Z) : Q :=
  match x with
  | Z0 => Zero
  | Zpos p => Qpos (Qpositive_c (nat_of_P p) 1 (S (nat_of_P p)))
  | Zneg p => Qneg (Qpositive_c (nat_of_P p) 1 (S (nat_of_P p)))
  end.
 
Definition Qpositive_tail (z : Qpositive) :=
  match z with
  | nR p => p
  | dL p => p
  | One => One
  end.
 
Definition Q_tail (z : Q) :=
  match z with
  | Zero => One
  | Qpos p => p
  | Qneg p => p
  end.
 
Definition Qsgn (q : Q) :=
  match q with
  | Zero => 0%Z
  | Qpos _ => 1%Z
  | Qneg _ => (-1)%Z
  end.

Fixpoint length_of_Qpositive_to_positive (qp : Qpositive) : positive :=
  match qp with
  | One => 1%positive
  | dL qp' => Pos.succ (length_of_Qpositive_to_positive qp')
  | nR qp' => Pos.succ (length_of_Qpositive_to_positive qp')
  end.

Fixpoint length_of_Qpositive (qp : Qpositive) : Z :=
  match qp with
  | One => 0%Z
  | dL qp' => (1 + length_of_Qpositive qp')%Z
  | nR qp' => (1 + length_of_Qpositive qp')%Z
  end.

Fixpoint Qpositive_to_Z (qp : Qpositive) : Z :=
  match qp with
  | One => 1%Z
  | dL qp' => 0%Z
  | nR qp' => (1 + Qpositive_to_Z qp')%Z
  end.

Definition Q_to_Z (x : Q) : Z :=
  match x with
  | Zero => 0%Z
  | Qpos qp => Qpositive_to_Z qp
  | Qneg qp => (- Qpositive_to_Z qp)%Z
  end.

Coercion Z_to_Q : Z >-> Q.

Definition Qlt (x y : Q) : Prop := Qgt y x.

Definition Qle (x y : Q) : Prop := ~ Qlt y x. 

Lemma Qlt_zero_pos : forall x' : Qpositive, Qlt Zero (Qpos x').

Lemma Qlt_neg_pos : forall x' y' : Qpositive, Qlt (Qneg y') (Qpos x').

Lemma Qlt_neg_zero : forall x' : Qpositive, Qlt (Qneg x') Zero.

Hint Resolve Qlt_neg_pos Qlt_neg_zero Qlt_zero_pos.

Ltac QltCleanAbsurdCases :=
  match goal with
  | id1:(Qlt Zero (Qneg _)) |- _ => inversion id1
  | id1:(Qlt (Qpos _) Zero) |- _ =>
      inversion id1
  | id1:(Qlt (Qpos _) (Qneg _)) |- _ =>
      inversion id1
  | id1:(Qle Zero (Qneg _)) |- _ =>
      apply False_ind; apply id1; auto with *
  | id1:(Qle (Qpos _) Zero) |- _ =>
      apply False_ind; apply id1; auto with *
  | id1:(Qle (Qpos _) (Qneg _)) |- _ =>
      apply False_ind; apply id1; auto with *
  end.
 
Functional Scheme Qpositive_c_ind := Induction for Qpositive_c Sort Prop.

Lemma Qpositive_c_0 : forall p q n : nat, n = 0 -> Qpositive_c p q n = One.

Lemma Qpositive_c_1_0_0 :
 forall p q n' : nat, p - q = 0 -> q - p = 0 -> Qpositive_c p q (S n') = One.

Lemma Qpositive_c_equal_One :
 forall m n p : nat, m = n -> Qpositive_c m n p = One.

Lemma Qpositive_c_1_0_1 :
 forall p q n' : nat,
 p - q = 0 ->
 q - p <> 0 -> Qpositive_c p q (S n') = dL (Qpositive_c p (q - p) n').

Lemma Qpositive_c_dL :
 forall p q n' : nat,
 p < q -> Qpositive_c p q (S n') = dL (Qpositive_c p (q - p) n').

Lemma Qpositive_c_1_1 :
 forall p q n' : nat,
 p - q <> 0 -> Qpositive_c p q (S n') = nR (Qpositive_c (p - q) q n').

Lemma Qpositive_c_nR :
 forall p q n' : nat,
 q < p -> Qpositive_c p q (S n') = nR (Qpositive_c (p - q) q n').

Functional Scheme Qpositive_i_ind := Induction for Qpositive_i Sort Prop.
Lemma Qpositive_i_nR_with_let :
 forall w : Qpositive,
 let (p, q) := Qpositive_i w in Qpositive_i (nR w) = (p + q, q).

Lemma Qpositive_i_nR :
 forall (w : Qpositive) (p q : nat),
 Qpositive_i w = (p, q) -> Qpositive_i (nR w) = (p + q, q).

Lemma Qpositive_i_c :
 forall m p : nat,
 0 < m -> S m <= p -> Qpositive_i (Qpositive_c m 1 p) = (m, 1).

Lemma Qpositive_c_equal :
 forall m n p p' : nat,
 0 < m ->
 0 < n -> m + n <= p -> m + n <= p' -> Qpositive_c m n p = Qpositive_c m n p'.

Lemma Qpositive_c_equal_strong :
 forall m1 m2 n1 n2 p1 p2 : nat,
 m1 = m2 ->
 n1 = n2 ->
 0 < m1 ->
 0 < n1 ->
 m1 + n1 <= p1 ->
 m2 + n2 <= p2 -> Qpositive_c m1 n1 p1 = Qpositive_c m2 n2 p2.

Functional Scheme Qpositive_plus_ind := Induction for Qpositive_plus Sort Prop.

Lemma what_nR_does : forall p : Qpositive, nR p = Qpositive_plus p One.

Functional Scheme Qpositive_mult_ind := Induction for Qpositive_mult Sort Prop.

Lemma what_dL_does :
 forall p : Qpositive,
 dL p = Qpositive_mult p (Qpositive_inv (Qpositive_plus p One)).

Lemma Qpos_nR : forall p : Qpositive, Qpos (nR p) = Qplus (Qpos p) Qone.

Lemma Qmult_Z_nR :
 forall (a : Z) (p : Qpositive),
 Qmult (Z_to_Q a) (Qpos (nR p)) =
 Qplus (Qmult (Z_to_Q a) (Qpos p)) (Z_to_Q a).

Lemma Qpos_dL :
 forall p : Qpositive,
 Qpos (dL p) = Qmult (Qpos p) (Qinv (Qplus (Qpos p) Qone)).

Lemma Qmult_Z_dL :
 forall (a : Z) (p : Qpositive),
 Qmult (Z_to_Q a) (Qpos (dL p)) =
 Qmult (Qmult (Z_to_Q a) (Qpos p)) (Qinv (Qplus (Qpos p) Qone)).

Lemma length_of_Qpositive_is_length :
 forall p : positive,
 length_of_Qpositive (Qpositive_c (nat_of_P p) 1 (S (nat_of_P p))) =
 (Zpos p - 1)%Z.

Lemma Qpositive_to_Z_is_integer_part :
 forall x : positive,
 Qpositive_to_Z (Qpositive_c (nat_of_P x) 1 (S (nat_of_P x))) = Zpos x.
 
Lemma Q_to_Z_to_Q : forall x : Z, Q_to_Z (Z_to_Q x) = x.
  
Lemma eq_Z_to_Q : forall x y : Z, Z_to_Q x = Z_to_Q y -> x = y.

Lemma Z_to_Qpositive_equal :
 forall (m1 m2 : Z) (Hm1 : (0 < m1)%Z) (Hm2 : (0 < m2)%Z),
 m1 = m2 -> Z_to_Qpositive m1 Hm1 = Z_to_Qpositive m2 Hm2.

Functional Scheme Z_to_Q_ind := Induction for Z_to_Q Sort Prop.

Lemma Z_to_Qpositive_to_Q :
 forall (m : Z) (Hm : (0 < m)%Z), Z_to_Q m = Qpos (Z_to_Qpositive m Hm).

Lemma Qpos_injective :
 forall qp1 qp2 : Qpositive, Qpos qp1 = Qpos qp2 -> qp1 = qp2.

Lemma Qneg_injective :
 forall qp1 qp2 : Qpositive, Qneg qp1 = Qneg qp2 -> qp1 = qp2.

Lemma Q_tail_Q_pos : forall q : Q, Qlt Zero q -> q = Qpos (Q_tail q).

Lemma Q_tail_Q_neg : forall q : Q, Qlt q Zero -> q = Qneg (Q_tail q).

Lemma Qpositive_to_Z_nonneg : forall x : Qpositive, (0 <= Qpositive_to_Z x)%Z.
 
Functional Scheme Qpositive_le_bool_ind := 
  Induction for Qpositive_le_bool Sort Prop.

Lemma Qpositive_to_Z_Qpositive_le :
 forall x y : Qpositive,
 (Qpositive_to_Z x < Qpositive_to_Z y)%Z -> Qpositive_le x y.

Lemma Q_to_Z_monotone : forall x y : Q, Qlt x y -> (Q_to_Z x <= Q_to_Z y)%Z.

Lemma Qlt_irreflexive : forall x : Q, ~ Qlt x x.

Hint Resolve Qlt_irreflexive.

Lemma Qlt_not_eq : forall x y : Q, Qlt x y -> y <> x.

Hint Resolve Qlt_not_eq.

Lemma Qlt_transitive : forall x y z : Q, Qlt x y -> Qlt y z -> Qlt x z.

Lemma Z_to_Qopp : forall x : Z, Z_to_Q (- x) = Qopp (Z_to_Q x).

Lemma Z_to_Qplus_POS :
 forall p1 p2 : positive,
 Z_to_Q (Zpos p1 + Zpos p2) = Qplus (Z_to_Q (Zpos p1)) (Z_to_Q (Zpos p2)).

Lemma Z_to_Qplus_POS_NEG :
 forall p1 p2 : positive,
 Z_to_Q (Zpos p1 + Zneg p2) = Qplus (Z_to_Q (Zpos p1)) (Z_to_Q (Zneg p2)).
 
Lemma Z_to_Qplus_NEG :
 forall p1 p2 : positive,
 Z_to_Q (Zneg p1 + Zneg p2) = Qplus (Z_to_Q (Zneg p1)) (Z_to_Q (Zneg p2)).

Lemma Z_to_Qplus :
 forall x y : Z, Z_to_Q (x + y) = Qplus (Z_to_Q x) (Z_to_Q y).

Lemma Z_to_Qminus :
 forall x y : Z, Z_to_Q (x - y) = Qminus (Z_to_Q x) (Z_to_Q y).

Lemma Z_to_Qmult_POS :
 forall p1 p2 : positive,
 Z_to_Q (Zpos p1 * Zpos p2) = Qmult (Z_to_Q (Zpos p1)) (Z_to_Q (Zpos p2)).

Lemma Z_to_Qmult_POS_NEG :
 forall p1 p2 : positive,
 Z_to_Q (Zpos p1 * Zneg p2) = Qmult (Z_to_Q (Zpos p1)) (Z_to_Q (Zneg p2)).

Lemma Z_to_Qmult_NEG :
 forall p1 p2 : positive,
 Z_to_Q (Zneg p1 * Zneg p2) = Qmult (Z_to_Q (Zneg p1)) (Z_to_Q (Zneg p2)).

Lemma Z_to_Qmult :
 forall x y : Z, Z_to_Q (x * y) = Qmult (Z_to_Q x) (Z_to_Q y).

Lemma Z_to_Q_S:forall k, Z_to_Q (Z_of_nat (S k))=Qplus k Qone.

Lemma Z_to_Q_min_one:Z_to_Q (-1)%Z= Qopp Qone.

Lemma Qlt_Zero_Qminus : forall x y : Q, Qlt Zero (Qminus y x) -> Qlt x y. 

Lemma Z_to_Qlt : forall x y : Z, (x < y)%Z -> Qlt x y.

Lemma lt_Z_to_Q : forall x y : Z, Qlt (Z_to_Q x) (Z_to_Q y) -> (x < y)%Z.
 
Lemma pos_Z_to_Q : forall x : Z, Qlt Zero (Z_to_Q x) -> (0 < x)%Z.

Lemma neg_Z_to_Q : forall x : Z, Qlt (Z_to_Q x) Zero -> (x < 0)%Z.

Lemma Qlt_le_weak : forall x y : Q, Qlt x y -> Qle x y.

Lemma Z_to_Qle : forall x y : Z, (x <= y)%Z -> Qle x y.

Lemma Z_to_Q_pos : forall x : Z, (0 < x)%Z -> Qlt Zero x.

Lemma Z_to_Q_neg : forall x : Z, (x < 0)%Z -> Qlt x Zero.

Lemma Z_to_Q_nonneg : forall x : Z, (0 <= x)%Z -> Qle Zero x.

Lemma Z_to_Q_nonpos : forall x : Z, (x <= 0)%Z -> Qle x Zero.

Lemma Z_to_Q_not_eq : forall a b : Z, a <> b -> Z_to_Q a <> Z_to_Q b.

Lemma Qmult_Z_plus_Z_dL :
 forall (a b : Z) (p : Qpositive),
 Qplus (Qmult (Z_to_Q a) (Qpos (dL p))) (Z_to_Q b) =
 Qmult (Qplus (Qmult (Z_to_Q (a + b)) (Qpos p)) (Z_to_Q b))
   (Qinv (Qplus (Qpos p) Qone)).

Lemma Qinv_0 : forall q : Q, Qinv q = Zero -> q = Zero. 

Lemma Qmult_resp_nonzero :
 forall x y : Q, x <> Zero -> y <> Zero -> Qmult x y <> Zero.

Hint Resolve Qmult_resp_nonzero.

Lemma Qlt_mult_pos_pos :
 forall x y : Q, Qlt Zero x -> Qlt Zero y -> Qlt Zero (Qmult x y).

Lemma Qlt_mult_neg_pos :
 forall x y : Q, Qlt x Zero -> Qlt Zero y -> Qlt (Qmult x y) Zero.

Hint Resolve Qlt_mult_pos_pos Qlt_mult_neg_pos.

Lemma Qlt_plus_pos_pos :
 forall x y : Q, Qlt Zero x -> Qlt Zero y -> Qlt Zero (Qplus x y).

Hint Resolve Qlt_plus_pos_pos.

Lemma Qdiv_num_denom :
 forall q1 q2 p : Q,
 p <> Zero -> Qmult q1 (Qinv q2) = Qmult (Qmult q1 p) (Qinv (Qmult q2 p)).

Lemma Qinv_1 : forall q : Q, Qlt Zero (Qinv q) -> Qlt Zero q.

Lemma Qinv_2 : forall q : Q, Qlt (Qinv q) Zero -> Qlt q Zero.

Lemma Qinv_pos : forall q : Q, Qlt Zero q -> Qlt Zero (Qinv q).

Lemma Qmult_one_right : forall x : Q, Qmult x Qone = x.

Lemma Qpos_POS_1 :
 forall (m : Z) (qp : Qpositive), Z_to_Q m = Qpos qp -> (0 < m)%Z.

Lemma Qneg_NEG_1 :
 forall (m : Z) (qp : Qpositive), Z_to_Q m = Qneg qp -> (m < 0)%Z.

Lemma Qopp_Qpos : forall q : Qpositive, Qneg q = Qopp (Qpos q).

Lemma Qopp_Qneg : forall q : Qpositive, Qpos q = Qopp (Qneg q).

Lemma Qopp_linear :
 forall (a b : Z) (q : Qpositive),
 Qplus (Qmult (Z_to_Q (- a)) (Qpos q)) (Z_to_Q (- b)) =
 Qopp (Qplus (Qmult (Z_to_Q a) (Qpos q)) (Z_to_Q b)).

Lemma Qopp_resp_nonzero : forall x : Q, x <> Zero -> Qopp x <> Zero.

Lemma Qinv_Qopp : forall q : Q, Qinv (Qopp q) = Qopp (Qinv q).

Lemma Qmult_Qopp_left : forall x y : Q, Qmult (Qopp x) y = Qopp (Qmult x y).

Lemma Qpositive_dec_One : forall p : Qpositive, {p = One} + {p <> One}.

Lemma Q_zerop : forall x : Q, {x = Zero} + {x <> Zero}.
 
Lemma Qinv_resp_nonzero : forall x : Q, x <> Zero -> Qinv x <> Zero.

Lemma Qlt_zero_one : Qlt Zero Qone.

Hint Resolve Qlt_zero_one.

Lemma Z_to_Qpositive_Q_tail_pos :
 forall (a : Z) (Ha : (0 < a)%Z), Z_to_Qpositive a Ha = Q_tail a.

Lemma Q_tail_Qinv : forall x : Q, Q_tail (Qinv x) = Qpositive_inv (Q_tail x).

Lemma Q_tail_Qmult :
 forall x y : Q,
 x <> Zero ->
 y <> Zero -> Q_tail (Qmult x y) = Qpositive_mult (Q_tail x) (Q_tail y). 

Lemma Q_tail_Qplus_pos :
 forall x y : Q,
 Qlt Zero x ->
 Qlt Zero y -> Q_tail (Qplus x y) = Qpositive_plus (Q_tail x) (Q_tail y). 

Lemma Q_tail_Qplus_neg :
 forall x y : Q,
 Qlt x Zero ->
 Qlt y Zero -> Q_tail (Qplus x y) = Qpositive_plus (Q_tail x) (Q_tail y). 

Lemma Qplus_zero_right : forall n : Q, Qplus n Zero = n.

Lemma Qmult_zero_right : forall x : Q, Qmult x Zero = Zero.

Lemma Qle_Qpositive_le_pos :
 forall x y : Qpositive, Qle (Qpos x) (Qpos y) -> Qpositive_le x y.

Lemma Qle_Qpositive_le_neg :
 forall x y : Qpositive, Qle (Qneg x) (Qneg y) -> Qpositive_le y x.

Lemma Qle_lt_eq_dec : forall x y : Q, Qle x y -> {Qlt x y} + {x = y}.

Lemma Qle_lt_trans : forall x y z : Q, Qle x y -> Qlt y z -> Qlt x z.

Lemma Qlt_le_trans : forall x y z : Q, Qlt x y -> Qle y z -> Qlt x z.

Lemma Qle_trans : forall x y z : Q, Qle x y -> Qle y z -> Qle x z.

Lemma Qlt_plus_plus :
 forall a b c d : Q, Qlt a b -> Qlt c d -> Qlt (Qplus a c) (Qplus b d).

Lemma Qle_lt_reg :
 forall a b c d : Q, Qle a b -> Qlt c d -> Qlt (Qplus a c) (Qplus b d).

Lemma Qlt_le_reg :
 forall a b c d : Q, Qlt a b -> Qle c d -> Qlt (Qplus a c) (Qplus b d).

Lemma Qlt_le_reg_pos :
 forall b d : Q, Qlt Zero b -> Qle Zero d -> Qlt Zero (Qplus b d).

Lemma Qle_lt_reg_pos :
 forall b d : Q, Qle Zero b -> Qlt Zero d -> Qlt Zero (Qplus b d).

Lemma Qlt_le_reg_neg :
 forall b d : Q, Qlt b Zero -> Qle d Zero -> Qlt (Qplus b d) Zero.
 
Lemma Qle_lt_reg_neg :
 forall b d : Q, Qle b Zero -> Qlt d Zero -> Qlt (Qplus b d) Zero.

Lemma Qle_plus_plus :
 forall a b c d : Q, Qle a b -> Qle c d -> Qle (Qplus a c) (Qplus b d).

Lemma Qle_plus_pos_pos :
 forall x y : Q, Qle Zero x -> Qle Zero y -> Qle Zero (Qplus x y).

Lemma Qle_plus_neg_neg :
 forall x y : Q, Qle x Zero -> Qle y Zero -> Qle (Qplus x y) Zero.

Lemma Qle_mult_nonneg_nonneg :
 forall x y : Q, Qle Zero x -> Qle Zero y -> Qle Zero (Qmult x y).

Lemma Qle_mult_nonpos_nonneg :
 forall x y : Q, Qle x Zero -> Qle Zero y -> Qle (Qmult x y) Zero.

Lemma Qle_mult_nonneg_nonpos :
 forall x y : Q, Qle Zero x -> Qle y Zero -> Qle (Qmult x y) Zero.

Lemma Qle_mult_nonpos_pos:
 forall x y : Q, Qle x Zero -> Qlt Zero y -> Qle (Qmult x y) Zero.

Lemma Qle_mult_neg_nonneg :
 forall x y : Q, Qlt x Zero -> Qle Zero y -> Qle (Qmult x y) Zero.

Lemma Qle_reflexive:forall x, Qle x x.

Hint Resolve Qplus_zero_right Qlt_le_reg_pos Qle_lt_reg_pos Qlt_le_reg
  Qle_lt_reg Qlt_le_weak Qlt_le_reg_neg Qle_lt_reg_neg Qle_plus_pos_pos
  Qle_plus_neg_neg Qle_mult_nonneg_nonneg Qle_mult_nonneg_nonpos
  Qle_mult_nonpos_nonneg Qle_mult_nonpos_pos Qle_mult_neg_nonneg
  Qle_reflexive.

Lemma Qpos_not_lt_Zero : forall x, ~ Qlt (Qpos x) Zero.

Lemma Qlt_dec_Qpos : forall x y, {~ Qlt (Qpos y) (Qpos x)} + {Qlt (Qpos y) (Qpos x)}.

Lemma Zero_not_lt_Qneg : forall x, ~ Qlt Zero (Qneg x).

Lemma Qpos_not_lt_Qneg : forall x y, ~ Qlt (Qpos y) (Qneg x).

Lemma Qlt_dec_Qneg : forall x y, {~ Qlt (Qneg y) (Qneg x)} + {Qlt (Qneg y) (Qneg x)}.

Lemma Q_le_lt_dec:forall (x y:Q), {Qle x y}+{Qlt y x}.

Lemma Qle_dec:forall (x y:Q), {Qle x y}+{~(Qle x y)}.

Lemma Qlt_dec:forall (x y:Q), {Qlt x y}+{~(Qlt x y)}.

Lemma Qtrichotomy_inf:forall x y,{Qlt x y}+{x=y}+{Qlt y x}.

Lemma Qle_dec_weak:forall (x y:Q), {Qle x y}+{(Qle y x)}.

Lemma not_Qeq_inf : forall x y : Q, x <> y -> {Qlt x y} + {Qlt y x}.

Lemma Qlt_stepl:forall x y z, Qlt x y -> x=z -> Qlt z y.

Lemma Qlt_stepr:forall x y z, Qlt x y -> y=z -> Qlt x z.

Lemma Qle_stepl:forall x y z, Qle x y -> x=z -> Qle z y.

Lemma Qle_stepr:forall x y z, Qle x y -> y=z -> Qle x z.

Lemma Qneq_stepl:forall (x y z:Q), x<>y -> x=z -> z<>y.

Lemma Qneq_stepr:forall (x y z:Q), x<>y -> y=z -> x<>z.

Declare Left Step Qlt_stepl.
Declare Right Step Qlt_stepr.
Declare Left Step Qle_stepl.
Declare Right Step Qle_stepr.
Declare Left Step Qneq_stepl.
Declare Right Step Qneq_stepr.

Lemma Qsgn_1: forall x:Q,{(Qsgn x) = 0}+{(Qsgn x) = 1}+{(Qsgn x) = (-1)%Z}. 

Lemma Qsgn_2 : forall x : Q, Qsgn x = 0%Z -> x = Zero.

Lemma Qsgn_7 : forall x : Q, Qlt Zero x -> Qsgn x = 1%Z.

Lemma Qsgn_8 : forall x : Q, Qlt x Zero -> Qsgn x = (-1)%Z.

Lemma Qsgn_9 : forall x : Q, Qsgn x = 1%Z -> Qlt Zero x.

Lemma Qsgn_10 : forall x : Q, Qsgn x = (-1)%Z -> Qlt x Zero.

Lemma Qsgn_15 : forall x y : Q, Qsgn (Qmult x y) = (Qsgn x * Qsgn y)%Z.
 
Lemma Qsgn_25 : forall x : Q, Qsgn (Qopp x) = (- Qsgn x)%Z.

Lemma Qsgn_28 : forall x : Q, Qsgn (Qinv x) = Qsgn x.

Lemma Qsgn_29 : forall x : Z, Qsgn (Z_to_Q x) = Z.sgn x. 

Lemma Qsgn_30 : forall x y : Q, Qsgn (Qdiv x y) = (Qsgn x * Qsgn y)%Z.

Lemma Qsgn_31:forall x:Q, Qle x Zero-> Qsgn x <> 1.

Lemma Qsgn_32:forall x:Q, Qsgn x <> 1 -> Qle x  Zero.

Lemma Qsgn_33:forall x:Q, Qle Zero x -> Qsgn x <> (-1)%Z.

Lemma Qsgn_34:forall x:Q, Qsgn x <> (-1)%Z -> Qle Zero x.

Hint Resolve Qsgn_2 Qsgn_7 Qsgn_8 Qsgn_9 Qsgn_10 Qsgn_15 Qsgn_25 Qsgn_28
  Qsgn_29 Qsgn_30.

Ltac qnat_zero :=  replace (Z_to_Q (Z_of_nat 0)) with Zero;  trivial.
Ltac natq_zero :=  replace Zero with (Z_to_Q (Z_of_nat 0));  trivial.
Ltac qnat_one :=  replace (Z_to_Q (Z_of_nat (S 0))) with Qone;  trivial.
Ltac natq_one :=  replace Qone with (Z_to_Q (Z_of_nat (S 0)));  trivial.
Ltac qnat_S k :=  replace (Z_to_Q (Z_of_nat (S k))) with (Qplus k Qone); [idtac | rewrite Z_to_Q_S; trivial].
Ltac natq_S k :=  try qnat_one; replace (Qplus k Qone) with (Z_to_Q (Z_of_nat (S k))); [idtac | rewrite <- Z_to_Q_S; trivial].
Ltac qnat_S_rec k :=  
             try qnat_one; replace (Qplus k Qone) with (Z_to_Q (Z_of_nat (S k))); [idtac | rewrite <- Z_to_Q_S; trivial];
             try qnat_S_rec (k-1).

Ltac natZ_numerals  := 
 match goal with 
 | [ |- context [Z0] ] => replace Z0 with (Z_of_nat O); trivial; natZ_numerals
 | [ |- context [(Zpos ?X1)] ] => let v:= eval compute in (Z.abs_nat (Z.pred (Zpos X1))) in 
         replace (Zpos X1) with (Z_of_nat (S v)); trivial; natZ_numerals
 | [ |- context [(Zneg ?X1)] ] => let v:= eval compute in (Z.abs_nat (Z.succ (Zpos X1))) in 
         replace (Zneg X1) with (Z.opp (Z_of_nat (S v))); trivial; natZ_numerals
 | [ |- _ ] => idtac
 end. *)
(* Zaux:
Require Export ZArith.
Require Export ZArithRing.

Tactic Notation "ElimCompare" constr(c) constr(d) := elim_compare c d.

Ltac Flip :=
  apply Z.gt_lt || apply Z.lt_gt || apply Z.le_ge || apply Z.ge_le; assumption.

Ltac Falsum :=
  try intro; apply False_ind;
   repeat
    match goal with
    | id1:(~ ?X1) |- ?X2 =>
        (apply id1; assumption || reflexivity) || clear id1
    end.

Ltac Step_l a :=
  match goal with
  |  |- (?X1 < ?X2)%Z => replace X1 with a; [ idtac | try ring ]
  end. 

Ltac Step_r a :=
  match goal with
  |  |- (?X1 < ?X2)%Z => replace X2 with a; [ idtac | try ring ]
  end. 

Ltac CaseEq formula :=
  generalize (refl_equal formula); pattern formula at -1 in |- *;
   case formula.

Lemma pair_1 : forall (A B : Set) (H : A * B), H = pair (fst H) (snd H).

Lemma pair_2 :
 forall (A B : Set) (H1 H2 : A * B),
 fst H1 = fst H2 -> snd H1 = snd H2 -> H1 = H2.

Section projection.   
 Variable A : Set.
 Variable P : A -> Prop.
 
 Definition projP1 (H : sig P) := let (x, h) := H in x.
 Definition projP2 (H : sig P) :=
   let (x, h) as H return (P (projP1 H)) := H in h.
End projection.

Lemma le_stepl: forall x y z, le x y -> x=z -> le z y.

Lemma le_stepr: forall x y z, le x y -> y=z -> le x z.

Lemma lt_stepl: forall x y z, lt x y -> x=z -> lt z y.

Lemma lt_stepr: forall x y z, lt x y -> y=z -> lt x z.

Lemma neq_stepl:forall (x y z:nat), x<>y -> x=z -> z<>y.

Lemma neq_stepr:forall (x y z:nat), x<>y -> y=z -> x<>z.

Declare Left Step le_stepl.
Declare Right Step le_stepr.
Declare Left Step lt_stepl.
Declare Right Step lt_stepr.
Declare Left Step neq_stepl.
Declare Right Step neq_stepr.

Lemma not_O_S : forall n : nat, n <> 0 -> {p : nat | n = S p}.
  
Lemma lt_minus_neq : forall m n : nat, m < n -> n - m <> 0.

Lemma lt_minus_eq_0 : forall m n : nat, m < n -> m - n = 0.

Lemma le_plus_Sn_1_SSn : forall n : nat, S n + 1 <= S (S n).

Lemma le_plus_O_l : forall p q : nat, p + q <= 0 -> p = 0.

Lemma le_plus_O_r : forall p q : nat, p + q <= 0 -> q = 0.

Lemma minus_pred : forall m n : nat, 0 < n -> pred m - pred n = m - n.

Lemma Zle_stepl: forall x y z, (x<=y)%Z -> x=z -> (z<=y)%Z.

Lemma Zle_stepr: forall x y z, (x<=y)%Z -> y=z -> (x<=z)%Z.

Lemma Zlt_stepl: forall x y z, (x<y)%Z -> x=z -> (z<y)%Z.

Lemma Zlt_stepr: forall x y z, (x<y)%Z -> y=z -> (x<z)%Z.

Lemma Zneq_stepl:forall (x y z:Z), (x<>y)%Z -> x=z -> (z<>y)%Z.

Lemma Zneq_stepr:forall (x y z:Z), (x<>y)%Z -> y=z -> (x<>z)%Z.

Declare Left Step Zle_stepl.
Declare Right Step Zle_stepr.
Declare Left Step Zlt_stepl.
Declare Right Step Zlt_stepr.
Declare Left Step Zneq_stepl.
Declare Right Step Zneq_stepr.

Lemma Zlt_cotrans :
 forall x y : Z, (x < y)%Z -> forall z : Z, {(x < z)%Z} + {(z < y)%Z}.

Lemma Zlt_cotrans_pos :
 forall x y : Z, (0 < x + y)%Z -> {(0 < x)%Z} + {(0 < y)%Z}.

Lemma Zlt_cotrans_neg :
 forall x y : Z, (x + y < 0)%Z -> {(x < 0)%Z} + {(y < 0)%Z}.

Lemma not_Zeq_inf : forall x y : Z, x <> y -> {(x < y)%Z} + {(y < x)%Z}.

Lemma Z_dec : forall x y : Z, {(x < y)%Z} + {(x > y)%Z} + {x = y}.
 
Lemma Z_dec' : forall x y : Z, {(x < y)%Z} + {(y < x)%Z} + {x = y}.

Lemma Z_lt_le_dec : forall x y : Z, {(x < y)%Z} + {(y <= x)%Z}.

Lemma Z_le_lt_dec : forall x y : Z, {(x <= y)%Z} + {(y < x)%Z}.

Lemma Z_lt_lt_S_eq_dec :
 forall x y : Z, (x < y)%Z -> {(x + 1 < y)%Z} + {(x + 1)%Z = y}.

Lemma quadro_leq_inf :
 forall a b c d : Z,
 {(c <= a)%Z /\ (d <= b)%Z} + {~ ((c <= a)%Z /\ (d <= b)%Z)}.

Lemma Zminus_eq : forall x y : Z, (x - y)%Z = 0%Z -> x = y.

Lemma Zlt_minus : forall a b : Z, (b < a)%Z -> (0 < a - b)%Z.

Lemma Zle_minus : forall a b : Z, (b <= a)%Z -> (0 <= a - b)%Z.

Lemma Zlt_plus_plus :
 forall m n p q : Z, (m < n)%Z -> (p < q)%Z -> (m + p < n + q)%Z.

Lemma Zgt_plus_plus :
 forall m n p q : Z, (m > n)%Z -> (p > q)%Z -> (m + p > n + q)%Z.

Lemma Zle_lt_plus_plus :
 forall m n p q : Z, (m <= n)%Z -> (p < q)%Z -> (m + p < n + q)%Z.

Lemma Zge_gt_plus_plus :
 forall m n p q : Z, (m >= n)%Z -> (p > q)%Z -> (m + p > n + q)%Z.

Lemma Zgt_ge_plus_plus :
 forall m n p q : Z, (m > n)%Z -> (p >= q)%Z -> (m + p > n + q)%Z.

Lemma Zlt_resp_pos : forall x y : Z, (0 < x)%Z -> (0 < y)%Z -> (0 < x + y)%Z.

Lemma Zle_resp_neg :
 forall x y : Z, (x <= 0)%Z -> (y <= 0)%Z -> (x + y <= 0)%Z.

Lemma Zlt_pos_opp : forall x : Z, (0 < x)%Z -> (- x < 0)%Z.

Lemma Zlt_neg_opp : forall x : Z, (x < 0)%Z -> (0 < - x)%Z.

Lemma Zle_neg_opp : forall x : Z, (x <= 0)%Z -> (0 <= - x)%Z.

Lemma Zle_pos_opp : forall x : Z, (0 <= x)%Z -> (- x <= 0)%Z.

Lemma Zge_opp : forall x y : Z, (x <= y)%Z -> (- x >= - y)%Z.

Lemma Zmult_pos_pos : forall x y : Z, (0 < x)%Z -> (0 < y)%Z -> (0 < x * y)%Z.

Lemma Zmult_neg_neg : forall x y : Z, (x < 0)%Z -> (y < 0)%Z -> (0 < x * y)%Z.

Lemma Zmult_neg_pos : forall x y : Z, (x < 0)%Z -> (0 < y)%Z -> (x * y < 0)%Z.

Lemma Zmult_pos_neg : forall x y : Z, (0 < x)%Z -> (y < 0)%Z -> (x * y < 0)%Z.

Hint Resolve Zmult_pos_pos Zmult_neg_neg Zmult_neg_pos Zmult_pos_neg: zarith.

Lemma Zle_reg_mult_l :
 forall x y a : Z, (0 < a)%Z -> (x <= y)%Z -> (a * x <= a * y)%Z.

Lemma Zsimpl_plus_l_dep :
 forall x y m n : Z, (x + m)%Z = (y + n)%Z -> x = y -> m = n.

Lemma Zsimpl_plus_r_dep :
 forall x y m n : Z, (m + x)%Z = (n + y)%Z -> x = y -> m = n.

Lemma Zmult_simpl :
 forall n m p q : Z, n = m -> p = q -> (n * p)%Z = (m * q)%Z.
 
Lemma Zsimpl_mult_l :
 forall n m p : Z, n <> 0%Z -> (n * m)%Z = (n * p)%Z -> m = p.

Lemma Zlt_reg_mult_l :
 forall x y z : Z, (x > 0)%Z -> (y < z)%Z -> (x * y < x * z)%Z. 

Lemma Zlt_opp : forall x y : Z, (x < y)%Z -> (- x > - y)%Z. 

Lemma Zlt_conv_mult_l :
 forall x y z : Z, (x < 0)%Z -> (y < z)%Z -> (x * y > x * z)%Z. 

Lemma Zgt_not_eq : forall x y : Z, (x > y)%Z -> x <> y.   

Lemma Zmult_resp_nonzero :
 forall x y : Z, x <> 0%Z -> y <> 0%Z -> (x * y)%Z <> 0%Z.

Lemma Zopp_app : forall y : Z, y <> 0%Z -> (- y)%Z <> 0%Z.

Lemma Zle_neq_Zlt : forall a b : Z, (a <= b)%Z -> b <> a -> (a < b)%Z.

Lemma not_Zle_lt : forall x y : Z, ~ (y <= x)%Z -> (x < y)%Z.

Lemma not_Zlt : forall x y : Z, ~ (y < x)%Z -> (x <= y)%Z.

Lemma Zmult_absorb :
 forall x y z : Z, x <> 0%Z -> (x * y)%Z = (x * z)%Z -> y = z.  

Lemma Zlt_mult_mult :
 forall a b c d : Z,
 (0 < a)%Z -> (0 < d)%Z -> (a < b)%Z -> (c < d)%Z -> (a * c < b * d)%Z.

Lemma Zgt_mult_conv_absorb_l :
 forall a x y : Z, (a < 0)%Z -> (a * x > a * y)%Z -> (x < y)%Z. 

Lemma Zgt_mult_reg_absorb_l :
 forall a x y : Z, (a > 0)%Z -> (a * x > a * y)%Z -> (x > y)%Z. 

Lemma Zopp_Zlt : forall x y : Z, (y < x)%Z -> (- x < - y)%Z.

Lemma Zmin_cancel_Zlt : forall x y : Z, (- x < - y)%Z -> (y < x)%Z.

Lemma Zmult_cancel_Zle :
 forall a x y : Z, (a < 0)%Z -> (a * x <= a * y)%Z -> (y <= x)%Z.

Lemma Zlt_mult_cancel_l :
 forall x y z : Z, (0 < x)%Z -> (x * y < x * z)%Z -> (y < z)%Z.
 
Lemma Zmin_cancel_Zle : forall x y : Z, (- x <= - y)%Z -> (y <= x)%Z.

Lemma Zmult_resp_Zle :
 forall a x y : Z, (0 < a)%Z -> (a * y <= a * x)%Z -> (y <= x)%Z.

Lemma Zopp_Zle : forall x y : Z, (y <= x)%Z -> (- x <= - y)%Z.

Lemma Zle_lt_eq_S : forall x y : Z, (x <= y)%Z -> (y < x + 1)%Z -> y = x.

Lemma Zlt_le_eq_S :
 forall x y : Z, (x < y)%Z -> (y <= x + 1)%Z -> y = (x + 1)%Z.

Lemma double_not_equal_zero :
 forall c d : Z, ~ (c = 0%Z /\ d = 0%Z) -> c <> d \/ c <> 0%Z.

Lemma triple_not_equal_zero :
 forall a b c : Z,
 ~ (a = 0%Z /\ b = 0%Z /\ c = 0%Z) -> a <> 0%Z \/ b <> 0%Z \/ c <> 0%Z.

Lemma mediant_1 :
 forall m n m' n' : Z, (m' * n < m * n')%Z -> ((m + m') * n < m * (n + n'))%Z.
 
Lemma mediant_2 :
 forall m n m' n' : Z,
 (m' * n < m * n')%Z -> (m' * (n + n') < (m + m') * n')%Z. 

Lemma mediant_3 :
 forall a b m n m' n' : Z,
 (0 <= a * m + b * n)%Z ->
 (0 <= a * m' + b * n')%Z -> (0 <= a * (m + m') + b * (n + n'))%Z.

Lemma fraction_lt_trans :
 forall a b c d e f : Z,
 (0 < b)%Z ->
 (0 < d)%Z ->
 (0 < f)%Z -> (a * d < c * b)%Z -> (c * f < e * d)%Z -> (a * f < e * b)%Z.

Lemma square_pos : forall a : Z, a <> 0%Z -> (0 < a * a)%Z.
 
Hint Resolve square_pos: zarith.

Definition Z2positive (z : Z) :=
  match z with
  | Zpos p => p
  | Zneg p => p
  | Z0 => 1%positive
  end.

Lemma ZL9 : forall p : positive, Z_of_nat (nat_of_P p) = Zpos p. 

Coercion Z_of_nat : nat >-> Z.

Lemma ZERO_lt_POS : forall p : positive, (0 < Zpos p)%Z.

Lemma POS_neq_ZERO : forall p : positive, Zpos p <> 0%Z.

Lemma NEG_neq_ZERO : forall p : positive, Zneg p <> 0%Z.

Lemma POS_resp_eq : forall p0 p1 : positive, Zpos p0 = Zpos p1 -> p0 = p1.

Lemma nat_nat_pos : forall m n : nat, ((m + 1) * (n + 1) > 0)%Z. 
 
Theorem S_predn : forall m : nat, m <> 0 -> S (pred m) = m. 

Lemma absolu_1 : forall x : Z, Z.abs_nat x = 0 -> x = 0%Z. 

Lemma absolu_2 : forall x : Z, x <> 0%Z -> Z.abs_nat x <> 0. 

Lemma absolu_inject_nat : forall n : nat, Z.abs_nat (Z_of_nat n) = n.

Lemma eq_inj : forall m n : nat, m = n :>Z -> m = n.

Lemma lt_inj : forall m n : nat, (m < n)%Z -> m < n.

Lemma le_inj : forall m n : nat, (m <= n)%Z -> m <= n.

Lemma inject_nat_S_inf : forall x : Z, (0 < x)%Z -> {n : nat | x = S n}.

Lemma le_absolu :
 forall x y : Z,
 (0 <= x)%Z -> (0 <= y)%Z -> (x <= y)%Z -> Z.abs_nat x <= Z.abs_nat y.

Lemma lt_absolu :
 forall x y : Z,
 (0 <= x)%Z -> (0 <= y)%Z -> (x < y)%Z -> Z.abs_nat x < Z.abs_nat y.

Lemma absolu_plus :
 forall x y : Z,
 (0 <= x)%Z -> (0 <= y)%Z -> Z.abs_nat (x + y) = Z.abs_nat x + Z.abs_nat y.

Lemma pred_absolu :
 forall x : Z, (0 < x)%Z -> pred (Z.abs_nat x) = Z.abs_nat (x - 1).

Definition pred_nat : forall (x : Z) (Hx : (0 < x)%Z), nat.

Lemma pred_nat_equal :
 forall (x : Z) (Hx1 Hx2 : (0 < x)%Z), pred_nat x Hx1 = pred_nat x Hx2.

Let pred_nat_unfolded_subproof px :
  Pos.to_nat px <> 0.

Lemma pred_nat_unfolded :
 forall (x : Z) (Hx : (0 < x)%Z), x = S (pred_nat x Hx).

Lemma absolu_pred_nat :
 forall (m : Z) (Hm : (0 < m)%Z), S (pred_nat m Hm) = Z.abs_nat m.

Lemma pred_nat_absolu :
 forall (m : Z) (Hm : (0 < m)%Z), pred_nat m Hm = Z.abs_nat (m - 1).

Lemma minus_pred_nat :
 forall (n m : Z) (Hn : (0 < n)%Z) (Hm : (0 < m)%Z) (Hnm : (0 < n - m)%Z),
 S (pred_nat n Hn) - S (pred_nat m Hm) = S (pred_nat (n - m) Hnm).

Lemma Zsgn_1 :
 forall x : Z, {Z.sgn x = 0%Z} + {Z.sgn x = 1%Z} + {Z.sgn x = (-1)%Z}. 

Lemma Zsgn_2 : forall x : Z, Z.sgn x = 0%Z -> x = 0%Z.   

Lemma Zsgn_3 : forall x : Z, x <> 0%Z -> Z.sgn x <> 0%Z.   

Theorem Zsgn_4 : forall a : Z, a = (Z.sgn a * Z.abs_nat a)%Z.  

Theorem Zsgn_5 :
 forall a b x y : Z,
 x <> 0%Z ->
 y <> 0%Z ->
 (Z.sgn a * x)%Z = (Z.sgn b * y)%Z -> (Z.sgn a * y)%Z = (Z.sgn b * x)%Z.  

Lemma Zsgn_6 : forall x : Z, x = 0%Z -> Z.sgn x = 0%Z.

Lemma Zsgn_7 : forall x : Z, (x > 0)%Z -> Z.sgn x = 1%Z.

Lemma Zsgn_7' : forall x : Z, (0 < x)%Z -> Z.sgn x = 1%Z.

Lemma Zsgn_8 : forall x : Z, (x < 0)%Z -> Z.sgn x = (-1)%Z.

Lemma Zsgn_9 : forall x : Z, Z.sgn x = 1%Z -> (0 < x)%Z.
 
Lemma Zsgn_10 : forall x : Z, Z.sgn x = (-1)%Z -> (x < 0)%Z.

Lemma Zsgn_11 : forall x : Z, (Z.sgn x < 0)%Z -> (x < 0)%Z.

Lemma Zsgn_12 : forall x : Z, (0 < Z.sgn x)%Z -> (0 < x)%Z.

Lemma Zsgn_13 : forall x : Z, (0 <= Z.sgn x)%Z -> (0 <= x)%Z.

Lemma Zsgn_14 : forall x : Z, (Z.sgn x <= 0)%Z -> (x <= 0)%Z.

Lemma Zsgn_15 : forall x y : Z, Z.sgn (x * y) = (Z.sgn x * Z.sgn y)%Z.

Lemma Zsgn_16 :
 forall x y : Z,
 Z.sgn (x * y) = 1%Z -> {(0 < x)%Z /\ (0 < y)%Z} + {(x < 0)%Z /\ (y < 0)%Z}.

Lemma Zsgn_17 :
 forall x y : Z,
 Z.sgn (x * y) = (-1)%Z -> {(0 < x)%Z /\ (y < 0)%Z} + {(x < 0)%Z /\ (0 < y)%Z}.

Lemma Zsgn_18 : forall x y : Z, Z.sgn (x * y) = 0%Z -> {x = 0%Z} + {y = 0%Z}.

Lemma Zsgn_19 : forall x y : Z, (0 < Z.sgn x + Z.sgn y)%Z -> (0 < x + y)%Z.

Lemma Zsgn_20 : forall x y : Z, (Z.sgn x + Z.sgn y < 0)%Z -> (x + y < 0)%Z.

Lemma Zsgn_21 : forall x y : Z, (0 < Z.sgn x + Z.sgn y)%Z -> (0 <= x)%Z.

Lemma Zsgn_22 : forall x y : Z, (Z.sgn x + Z.sgn y < 0)%Z -> (x <= 0)%Z.

Lemma Zsgn_23 : forall x y : Z, (0 < Z.sgn x + Z.sgn y)%Z -> (0 <= y)%Z.

Lemma Zsgn_24 : forall x y : Z, (Z.sgn x + Z.sgn y < 0)%Z -> (y <= 0)%Z.

Lemma Zsgn_25 : forall x : Z, Z.sgn (- x) = (- Z.sgn x)%Z.

Lemma Zsgn_26 : forall x : Z, (0 < x)%Z -> (0 < Z.sgn x)%Z.

Lemma Zsgn_27 : forall x : Z, (x < 0)%Z -> (Z.sgn x < 0)%Z.

Hint Resolve Zsgn_1 Zsgn_2 Zsgn_3 Zsgn_4 Zsgn_5 Zsgn_6 Zsgn_7 Zsgn_7' Zsgn_8
  Zsgn_9 Zsgn_10 Zsgn_11 Zsgn_12 Zsgn_13 Zsgn_14 Zsgn_15 Zsgn_16 Zsgn_17
  Zsgn_18 Zsgn_19 Zsgn_20 Zsgn_21 Zsgn_22 Zsgn_23 Zsgn_24 Zsgn_25 Zsgn_26
  Zsgn_27: zarith.

Lemma Zabs_1 : forall z p : Z, (Z.abs z < p)%Z -> (z < p)%Z /\ (- p < z)%Z.

Lemma Zabs_2 : forall z p : Z, (Z.abs z > p)%Z -> (z > p)%Z \/ (- p > z)%Z.

Lemma Zabs_3 : forall z p : Z, (z < p)%Z /\ (- p < z)%Z -> (Z.abs z < p)%Z.

Lemma Zabs_4 : forall z p : Z, (Z.abs z < p)%Z -> (- p < z < p)%Z.
 
Lemma Zabs_5 : forall z p : Z, (Z.abs z <= p)%Z -> (- p <= z <= p)%Z.

Lemma Zabs_6 : forall z p : Z, (Z.abs z <= p)%Z -> (z <= p)%Z.

Lemma Zabs_7 : forall z p : Z, (Z.abs z <= p)%Z -> (- p <= z)%Z.

Lemma Zabs_8 : forall z p : Z, (- p <= z <= p)%Z -> (Z.abs z <= p)%Z.

Lemma Zabs_min : forall z : Z, Z.abs z = Z.abs (- z).

Lemma Zabs_9 :
 forall z p : Z, (0 <= p)%Z -> (p < z)%Z \/ (z < - p)%Z -> (p < Z.abs z)%Z.

Lemma Zabs_10 : forall z : Z, (0 <= Z.abs z)%Z.

Lemma Zabs_11 : forall z : Z, z <> 0%Z -> (0 < Z.abs z)%Z.

Lemma Zabs_12 : forall z m : Z, (m < Z.abs z)%Z -> {(m < z)%Z} + {(z < - m)%Z}.

Lemma Zabs_mult : forall z p : Z, Z.abs (z * p) = (Z.abs z * Z.abs p)%Z.

Lemma Zabs_plus : forall z p : Z, (Z.abs (z + p) <= Z.abs z + Z.abs p)%Z.

Lemma Zabs_neg : forall z : Z, (z <= 0)%Z -> Z.abs z = (- z)%Z.

Lemma Zle_Zabs: forall z, (z <= Z.abs z)%Z.
 
Hint Resolve Zabs_1 Zabs_2 Zabs_3 Zabs_4 Zabs_5 Zabs_6 Zabs_7 Zabs_8 Zabs_9
  Zabs_10 Zabs_11 Zabs_12 Zabs_min Zabs_neg Zabs_mult Zabs_plus Zle_Zabs: zarith.

Lemma Zind :
 forall (P : Z -> Prop) (p : Z),
 P p ->
 (forall q : Z, (p <= q)%Z -> P q -> P (q + 1)%Z) ->
 forall q : Z, (p <= q)%Z -> P q. 

Lemma Zrec :
 forall (P : Z -> Set) (p : Z),
 P p ->
 (forall q : Z, (p <= q)%Z -> P q -> P (q + 1)%Z) ->
 forall q : Z, (p <= q)%Z -> P q. 

Lemma Zrec_down :
 forall (P : Z -> Set) (p : Z),
 P p ->
 (forall q : Z, (q <= p)%Z -> P q -> P (q - 1)%Z) ->
 forall q : Z, (q <= p)%Z -> P q.

Lemma Zind_down :
 forall (P : Z -> Prop) (p : Z),
 P p ->
 (forall q : Z, (q <= p)%Z -> P q -> P (q - 1)%Z) ->
 forall q : Z, (q <= p)%Z -> P q.

Lemma Zrec_wf :
 forall (P : Z -> Set) (p : Z),
 (forall q : Z, (forall r : Z, (p <= r < q)%Z -> P r) -> P q) ->
 forall q : Z, (p <= q)%Z -> P q.

Lemma Zrec_wf2 :
 forall (q : Z) (P : Z -> Set) (p : Z),
 (forall q : Z, (forall r : Z, (p <= r < q)%Z -> P r) -> P q) ->
 (p <= q)%Z -> P q.

Lemma Zrec_wf_double :
 forall (P : Z -> Z -> Set) (p0 q0 : Z),
 (forall n m : Z,
  (forall p q : Z, (q0 <= q)%Z -> (p0 <= p < n)%Z -> P p q) ->
  (forall p : Z, (q0 <= p < m)%Z -> P n p) -> P n m) ->
 forall p q : Z, (q0 <= q)%Z -> (p0 <= p)%Z -> P p q.

Lemma Zind_wf :
 forall (P : Z -> Prop) (p : Z),
 (forall q : Z, (forall r : Z, (p <= r < q)%Z -> P r) -> P q) ->
 forall q : Z, (p <= q)%Z -> P q.

Lemma Zind_wf2 :
 forall (q : Z) (P : Z -> Prop) (p : Z),
 (forall q : Z, (forall r : Z, (p <= r < q)%Z -> P r) -> P q) ->
 (p <= q)%Z -> P q.

Lemma Zind_wf_double :
 forall (P : Z -> Z -> Prop) (p0 q0 : Z),
 (forall n m : Z,
  (forall p q : Z, (q0 <= q)%Z -> (p0 <= p < n)%Z -> P p q) ->
  (forall p : Z, (q0 <= p < m)%Z -> P n p) -> P n m) ->
 forall p q : Z, (q0 <= q)%Z -> (p0 <= p)%Z -> P p q.

Definition Zmax (n m : Z) := (n + m - Z.min n m)%Z.

Lemma ZmaxSS : forall n m : Z, (Zmax n m + 1)%Z = Zmax (n + 1) (m + 1).

Lemma Zle_max_l : forall n m : Z, (n <= Zmax n m)%Z.

Lemma Zle_max_r : forall n m : Z, (m <= Zmax n m)%Z.

Lemma Zmin_or_informative : forall n m : Z, {Z.min n m = n} + {Z.min n m = m}.

Lemma Zmax_case : forall (n m : Z) (P : Z -> Set), P n -> P m -> P (Zmax n m).
 
Lemma Zmax_or_informative : forall n m : Z, {Zmax n m = n} + {Zmax n m = m}. 

Lemma Zmax_n_n : forall n : Z, Zmax n n = n.

Hint Resolve ZmaxSS Zle_max_r Zle_max_l Zmax_n_n: zarith.

Lemma Zeven_S : forall x : Z, Zeven.Zodd x -> Zeven.Zeven (x + 1).

Lemma Zeven_pred : forall x : Z, Zeven.Zodd x -> Zeven.Zeven (x - 1). 

Definition Z_modulo_2_always :
  forall x : Z, {y : Z | x = (2 * y)%Z} + {y : Z | x = (2 * y + 1)%Z} :=
  Zeven.Z_modulo_2.

Lemma Z_div_mod_eq_2 :
 forall a b : Z, (0 < b)%Z -> (b * (a / b))%Z = (a - a mod b)%Z.

Lemma Z_div_le :
 forall a b c : Z, (0 < c)%Z -> (b <= a)%Z -> (b / c <= a / c)%Z. 

Lemma Z_div_nonneg :
 forall a b : Z, (0 < b)%Z -> (0 <= a)%Z -> (0 <= a / b)%Z.

Lemma Z_div_neg : forall a b : Z, (0 < b)%Z -> (a < 0)%Z -> (a / b < 0)%Z.

Hint Resolve Z_div_mod_eq_2 Z_div_le Z_div_nonneg Z_div_neg: zarith.

Lemma Zpower_1 : forall a : Z, (a ^ 1)%Z = a.

Lemma Zpower_2 : forall a : Z, (a ^ 2)%Z = (a * a)%Z.

Hint Resolve Zpower_1 Zpower_2: zarith. *)



Lemma Qquadratic_sg_denom_nonzero_always :

 forall (k e f g h : Z) (p1 p2 : Qpositive),

 k <> 0%Z ->

 (0 < e)%Z ->

 (0 < f)%Z ->

 (0 < g)%Z ->

 (0 < h)%Z ->

 Qquadratic_sg_denom_nonzero (k * e) (k * f) (k * g) (k * h) p1 p2.

Proof.

 intros k e f g h p1 p2 Hk He Hf Hg Hh.

 generalize e f g h He Hf Hg Hh p2.  

 induction p1.

 

  intros.

  case p0.

  

  intros.

  apply Qquadratic_signok1.

  replace (k * e0 + k * f0 + k * g0 + k * h0)%Z with

   (k * (e0 + f0 + g0 + h0))%Z;

   try replace (k * e0 + k * f0)%Z with (k * (e0 + f0))%Z;

   try replace (k * e0 + k * g0)%Z with (k * (e0 + g0))%Z; 

   try apply IHp1; try first [ assumption | repeat apply Zlt_resp_pos ];

   try assumption;

   repeat match goal with

          |  |- (?X1 = ?X2) => abstract ring

          end. 

  intros.

  apply Qquadratic_signok2.

  replace (k * e0 + k * f0 + k * g0 + k * h0)%Z with

   (k * (e0 + f0 + g0 + h0))%Z;

   try replace (k * e0 + k * f0)%Z with (k * (e0 + f0))%Z;

   try replace (k * f0 + k * h0)%Z with (k * (f0 + h0))%Z; 

   try apply IHp1; try first [ assumption | repeat apply Zlt_resp_pos ];

   try assumption;

   repeat match goal with

          |  |- (?X1 = ?X2) => abstract ring

          end. 

  apply Qquadratic_signok0.

  reflexivity.

  replace (k * e0 + k * f0)%Z with ((e0 + f0) * k)%Z;

   try replace (k * g0 + k * h0)%Z with ((g0 + h0) * k)%Z;

   try apply Qhomographic_sg_denom_nonzero_always_1;

   try first [ assumption | repeat apply Zlt_resp_pos ]; 

   try assumption;

   repeat match goal with

          |  |- (?X1 = ?X2) => abstract ring

          end.

 

  intros.

  case p0.  

  intros.

  apply Qquadratic_signok3.

  replace (k * e0 + k * f0 + k * g0 + k * h0)%Z with

   (k * (e0 + f0 + g0 + h0))%Z;

   try replace (k * g0 + k * h0)%Z with (k * (g0 + h0))%Z;

   try replace (k * e0 + k * g0)%Z with (k * (e0 + g0))%Z; 

   try apply IHp1; try first [ assumption | repeat apply Zlt_resp_pos ];

   try assumption;

   repeat match goal with

          |  |- (?X1 = ?X2) => abstract ring

          end. 

  intros.

  apply Qquadratic_signok4.

  replace (k * e0 + k * f0 + k * g0 + k * h0)%Z with

   (k * (e0 + f0 + g0 + h0))%Z;

   try replace (k * g0 + k * h0)%Z with (k * (g0 + h0))%Z;

   try replace (k * f0 + k * h0)%Z with (k * (f0 + h0))%Z; 

   try apply IHp1; try first [ assumption | repeat apply Zlt_resp_pos ];

   try assumption;

   repeat match goal with

          |  |- (?X1 = ?X2) => abstract ring

          end. 

  apply Qquadratic_signok0.

  reflexivity.

  replace (k * e0 + k * f0)%Z with ((e0 + f0) * k)%Z;

   try replace (k * g0 + k * h0)%Z with ((g0 + h0) * k)%Z;

   try apply Qhomographic_sg_denom_nonzero_always_1;

   try first [ assumption | repeat apply Zlt_resp_pos ]; 

   try assumption;

   repeat match goal with

          |  |- (?X1 = ?X2) => abstract ring

          end.

 

 intros. 

 apply Qquadratic_signok0'.

 reflexivity.

 replace (k * e0 + k * g0)%Z with ((e0 + g0) * k)%Z;

  try replace (k * f0 + k * h0)%Z with ((f0 + h0) * k)%Z;

  try apply Qhomographic_sg_denom_nonzero_always_1;

  try first [ assumption | repeat apply Zlt_resp_pos ]; 

  try assumption; repeat match goal with

                         |  |- (?X1 = ?X2) => abstract ring

                         end.

Defined.



Lemma Qquadratic_sg_denom_nonzero_Zero_Zero_always :

 forall (k g h : Z) (p1 p2 : Qpositive),

 k <> 0%Z ->

 (0 < g)%Z ->

 (0 < h)%Z -> Qquadratic_sg_denom_nonzero 0 0 (k * g) (k * h) p1 p2.

Proof.

 intros k g h p1 p2 Hk Hg Hh.

 generalize g h Hg Hh p2. 

 induction p1.

  

  intros.

  case p0.

   intro p3.

   apply Qquadratic_signok1.

   simpl in |- *.   

   replace (k * g0 + k * h0)%Z with (k * (g0 + h0))%Z;

    [ apply IHp1; try first [ assumption | repeat apply Zlt_resp_pos ];

       try assumption

    | abstract ring ].

   

   intro p3.

   apply Qquadratic_signok2.

   simpl in |- *.

   replace (k * g0 + k * h0)%Z with (k * (g0 + h0))%Z;

    [ apply IHp1; try first [ assumption | repeat apply Zlt_resp_pos ];

       try assumption

    | abstract ring ].

   

   apply Qquadratic_signok0.

   reflexivity.

   simpl in |- *.

   apply Qhomographic_sg_denom_nonzero_Zero_always.

   replace (k * g0 + k * h0)%Z with (k * (g0 + h0))%Z.

   intro.

   apply Hk.

   apply Zmult_integral_l with (g0 + h0)%Z.

   apply sym_not_eq.

   apply Zorder.Zlt_not_eq.

   apply Zlt_resp_pos; assumption.

   assumption.

   abstract ring.

   

  intros.

   case p0.

   intro p3.

   apply Qquadratic_signok3.

   simpl in |- *.   

   replace (k * g0 + k * h0)%Z with (k * (g0 + h0))%Z;

    [ apply Qquadratic_sg_denom_nonzero_always;

       try first [ assumption | repeat apply Zlt_resp_pos ]; 

       try assumption

    | abstract ring ].

   

   intro p3.

   apply Qquadratic_signok4.

   simpl in |- *.

   replace (k * g0 + k * h0)%Z with (k * (g0 + h0))%Z;

    [ apply Qquadratic_sg_denom_nonzero_always;

       try first [ assumption | repeat apply Zlt_resp_pos ]; 

       try assumption

    | abstract ring ].

   

   apply Qquadratic_signok0.

   reflexivity.

   simpl in |- *.

   apply Qhomographic_sg_denom_nonzero_Zero_always.

   replace (k * g0 + k * h0)%Z with (k * (g0 + h0))%Z.

   intro.

   apply Hk.

   apply Zmult_integral_l with (g0 + h0)%Z.

   apply sym_not_eq.

   apply Zorder.Zlt_not_eq.

   apply Zlt_resp_pos; assumption.

   assumption.

   abstract ring.



  intros.

  apply Qquadratic_signok0'.

  reflexivity.

  simpl in |- *.

  rewrite Zmult_comm with k h0.

  rewrite Zmult_comm with k g0.

  apply Qhomographic_sg_denom_nonzero_always_1; assumption.

Defined.



Lemma Qquadratic_sg_denom_nonzero_Zero_always_Zero_always :

 forall (k f h : Z) (p1 p2 : Qpositive),

 k <> 0%Z ->

 (0 < f)%Z ->

 (0 < h)%Z -> Qquadratic_sg_denom_nonzero 0 (k * f) 0 (k * h) p1 p2.

Proof.

 intros k f h p1 p2 Hk Hf Hh.

 generalize f h Hf Hh p2. 

 abstract (induction p1; intros;

            [ 

               

               destruct p0 as [q| q| ];

               [ apply Qquadratic_signok1; simpl in |- *; rewrite Zplus_0_r;

                  rewrite <- Zmult_plus_distr_r with k f0 h0; 

                  apply IHp1

               | apply Qquadratic_signok2; simpl in |- *; rewrite Zplus_0_r;

                  rewrite <- Zmult_plus_distr_r with k f0 h0;

                  apply Qquadratic_sg_denom_nonzero_always

               | apply Qquadratic_signok0;

                  [ reflexivity

                  | simpl in |- *; rewrite Zmult_comm;

                     rewrite Zmult_comm with k h0;

                     apply Qhomographic_sg_denom_nonzero_always_1 ] ]

            | 

               

               destruct p0 as [q| q| ];

               [ apply Qquadratic_signok3; simpl in |- *; rewrite Zplus_0_r;

                  rewrite <- Zmult_plus_distr_r with k f0 h0; 

                  apply IHp1

               | apply Qquadratic_signok4; simpl in |- *; rewrite Zplus_0_r;

                  rewrite <- Zmult_plus_distr_r with k f0 h0;

                  apply Qquadratic_sg_denom_nonzero_always

               | apply Qquadratic_signok0;

                  [ reflexivity

                  | simpl in |- *; rewrite Zmult_comm;

                     rewrite Zmult_comm with k h0;

                     apply Qhomographic_sg_denom_nonzero_always_1 ] ]

            | 

               

               apply Qquadratic_signok0';

               [ reflexivity

               | simpl in |- *; rewrite <- Zmult_plus_distr_r with k f0 h0;

                  apply Qhomographic_sg_denom_nonzero_Zero_always;

                  apply Zmult_resp_nonzero;

                  [ idtac

                  | apply sym_not_eq; apply Zorder.Zlt_not_eq;

                     apply Zlt_resp_pos ] ] ];

            try first [ assumption | repeat apply Zlt_resp_pos ]; 

            assumption).

Defined.



Lemma Qquadratic_sg_denom_nonzero_always_Zero_always_Zero :

 forall (k e g : Z) (p1 p2 : Qpositive),

 k <> 0%Z ->

 (0 < e)%Z ->

 (0 < g)%Z -> Qquadratic_sg_denom_nonzero (k * e) 0 (k * g) 0 p1 p2.

Proof.

 intros k e g p1 p2 Hk He Hg.

 generalize e g He Hg p2. 

 abstract (induction p1; intros;

            [ 

               

               destruct p0 as [q| q| ];

               [ apply Qquadratic_signok1; simpl in |- *;

                  repeat rewrite Zplus_0_r;

                  rewrite <- Zmult_plus_distr_r with k e0 g0;

                  apply Qquadratic_sg_denom_nonzero_always

               | apply Qquadratic_signok2; simpl in |- *;

                  repeat rewrite Zplus_0_r;

                  rewrite <- Zmult_plus_distr_r with k e0 g0; 

                  apply IHp1

               | apply Qquadratic_signok0;

                  [ reflexivity

                  | repeat rewrite Zplus_0_r; rewrite Zmult_comm;

                     rewrite Zmult_comm with k g0;

                     apply Qhomographic_sg_denom_nonzero_always_1 ] ]

            | 

               

               destruct p0 as [q| q| ];

               [ apply Qquadratic_signok3; simpl in |- *;

                  repeat rewrite Zplus_0_r;

                  rewrite <- Zmult_plus_distr_r with k e0 g0;

                  apply Qquadratic_sg_denom_nonzero_always

               | apply Qquadratic_signok4; simpl in |- *;

                  repeat rewrite Zplus_0_r;

                  rewrite <- Zmult_plus_distr_r with k e0 g0; 

                  apply IHp1

               | apply Qquadratic_signok0;

                  [ reflexivity

                  | repeat rewrite Zplus_0_r; rewrite Zmult_comm;

                     rewrite Zmult_comm with k g0;

                     apply Qhomographic_sg_denom_nonzero_always_1 ] ]

            | 

               

               apply Qquadratic_signok0';

               [ reflexivity

               | simpl in |- *; rewrite <- Zmult_plus_distr_r with k e0 g0;

                  apply Qhomographic_sg_denom_nonzero_always_Zero;

                  apply Zmult_resp_nonzero;

                  [ idtac

                  | apply sym_not_eq; apply Zorder.Zlt_not_eq;

                     apply Zlt_resp_pos ] ] ];

            assumption || (try apply Zlt_resp_pos); 

            assumption).

Defined.



Lemma Qquadratic_sg_denom_nonzero_Zero_Zero_Zero_always :

 forall (h : Z) (p1 p2 : Qpositive),

 h <> 0%Z -> Qquadratic_sg_denom_nonzero 0 0 0 h p1 p2.

Proof.

 intros h p1 p2 Hh.

 generalize h Hh p2. 

 abstract (induction p1; intros;

            [ 

               destruct p0 as [q| q| ];

               [ apply Qquadratic_signok1; simpl in |- *; apply IHp1;

                  assumption

               | apply Qquadratic_signok2; simpl in |- *;

                  rewrite <- Zmult_1_r with h0;

                  apply Qquadratic_sg_denom_nonzero_Zero_Zero_always

               | apply Qquadratic_signok0 ]

            | 

               destruct p0 as [q| q| ];

               [ apply Qquadratic_signok3; simpl in |- *;

                  rewrite <- Zmult_1_r with h0;

                  apply Qquadratic_sg_denom_nonzero_Zero_always_Zero_always

               | apply Qquadratic_signok4; simpl in |- *;

                  rewrite <- Zmult_1_r with h0;

                  apply Qquadratic_sg_denom_nonzero_always

               | apply Qquadratic_signok0 ]

            |  

               apply Qquadratic_signok0';

               [ constructor

               | simpl in |- *;

                  apply Qhomographic_sg_denom_nonzero_Zero_always; 

                  assumption ] ]; simpl in |- *;

            try apply Qhomographic_sg_denom_nonzero_Zero_always;

            assumption || (try constructor)).

Defined.



Lemma Qquadratic_sg_denom_nonzero_Zero_Zero_always_Zero :

 forall (g : Z) (p1 p2 : Qpositive),

 g <> 0%Z -> Qquadratic_sg_denom_nonzero 0 0 g 0 p1 p2.

Proof.

 intros g p1 p2 Hg.

 generalize g Hg p2. 

 abstract (induction p1; intros;

            [ 

               destruct p0 as [q| q| ];

               [ apply Qquadratic_signok1; simpl in |- *; rewrite Zplus_0_r;

                  rewrite <- Zmult_1_r with g0;

                  apply Qquadratic_sg_denom_nonzero_Zero_Zero_always

               | apply Qquadratic_signok2; simpl in |- *; rewrite Zplus_0_r;

                  apply IHp1; assumption

               | apply Qquadratic_signok0 ]

            | 

               destruct p0 as [q| q| ];

               [ apply Qquadratic_signok3; simpl in |- *; rewrite Zplus_0_r;

                  rewrite <- Zmult_1_r with g0;

                  apply Qquadratic_sg_denom_nonzero_always

               | apply Qquadratic_signok4; simpl in |- *; rewrite Zplus_0_r;

                  rewrite <- Zmult_1_r with g0;

                  apply Qquadratic_sg_denom_nonzero_always_Zero_always_Zero

               | apply Qquadratic_signok0 ]

            |  

               apply Qquadratic_signok0';

               [ constructor

               | simpl in |- *;

                  apply Qhomographic_sg_denom_nonzero_always_Zero; 

                  assumption ] ]; simpl in |- *; try rewrite Zplus_0_r;

            try apply Qhomographic_sg_denom_nonzero_Zero_always;

            assumption || (try constructor)).

Defined.



Lemma Qquadratic_sg_denom_nonzero_nonzero :

 forall (e f g h : Z) (p1 p2 : Qpositive),

 e = 0%Z ->

 f = 0%Z -> g = 0%Z -> h = 0%Z -> ~ Qquadratic_sg_denom_nonzero e f g h p1 p2.

Proof.

 intros e f g h p1 p2 He Hf Hg Hh H_Qquadratic_sg_denom_nonzero.

 generalize He Hf Hg Hh.

 elim H_Qquadratic_sg_denom_nonzero; intros; first

  [ refine

     (Qhomographic_sg_denom_nonzero_nonzero (e0 + f0) (g0 + h0) p0 _ _ H0)

  | refine

     (Qhomographic_sg_denom_nonzero_nonzero (e0 + g0) (f0 + h0) p3 _ _ H0)

  | apply H0 ];

  repeat match goal with

         | id1:(?X1 = ?X2) |- ?X3 => rewrite id1

         end; constructor.

Defined.



Lemma Qquadratic_sg_denom_nonzero_nonzero_1 :

 forall (e f g h : Z) (p1 p2 : Qpositive),

 Qquadratic_sg_denom_nonzero e f g h p1 p2 ->

 ~ (e = 0%Z /\ f = 0%Z /\ g = 0%Z /\ h = 0%Z).

Proof.

 intros e f g h p1 p2 H_Qquadratic_sg_denom_nonzero (He, (Hf, (Hg, Hh))). 

 exact

  (Qquadratic_sg_denom_nonzero_nonzero e f g h p1 p2 He Hf Hg Hh

     H_Qquadratic_sg_denom_nonzero).

Defined. 



Lemma Qquadratic_sg_denom_nonzero_nonzero_inf :

 forall (e f g h : Z) (p1 p2 : Qpositive),

 Qquadratic_sg_denom_nonzero e f g h p1 p2 ->

 {e <> 0%Z} + {f <> 0%Z} + {g <> 0%Z} + {h <> 0%Z}.

Proof.

 intros e f g h p1 p2 H_Qquadratic_sg_denom_nonzero.

 case (Z_zerop e);

  [ case (Z_zerop f);

     [ case (Z_zerop g);

        [ case (Z_zerop h);

           [ intros; apply False_rec;

              apply

               (Qquadratic_sg_denom_nonzero_nonzero_1 e f g h p1 p2

                  H_Qquadratic_sg_denom_nonzero); repeat split; 

              assumption

           | intros ]

        | intros ]

     | intros ]

  | intros ]; [ right | left; right | left; left; right | left; left; left ];

  assumption. 

Defined.



Lemma Qquadratic_sg_denom_nonzero_nonzero_3 :

 forall (g h : Z) (p1 p2 : Qpositive),

 Qquadratic_sg_denom_nonzero 0 0 g h p1 p2 -> g <> 0%Z \/ h <> 0%Z.

Proof.

 intros.

 case (Z_zerop g);

  [ intro; case (Z_zerop h); [ intro; idtac | intro; right ] | intro; left ];

  try assumption.

 apply False_ind.

 apply (Qquadratic_sg_denom_nonzero_nonzero 0 0 g h p1 p2);

  try solve [ constructor | assumption ].

Defined. 



Definition Qquadratic_Qpositive_to_Q (a b c d e f g h : Z)

  (p1 p2 : Qpositive) (H_qsign : Qquadratic_sg_denom_nonzero e f g h p1 p2) :

  Q.

case (same_ratio_dec_inf a b c d e f g h);

 [ intros _;

    case (Qquadratic_sg_denom_nonzero_nonzero_inf e f g h p1 p2 H_qsign);

    [ intros [[He| Hf]| Hg];

       [ exact (fraction_encoding a e He)

       | exact (fraction_encoding b f Hf)

       | exact (fraction_encoding c g Hg) ]

    | intro Hh; exact (fraction_encoding d h Hh) ]

 | idtac ].



intro not_same_ratio_abcdefgh. 

case (Qquadratic_sign_sign_dec a b c d e f g h p1 p2 H_qsign).

 intros [l1_eq_zero| l1_eq_one];

  [  

  exact Zero | idtac ]. 

 

   assert

    (H :

     Qquadratic_sign a b c d e f g h p1 p2 H_qsign =

     (1%Z,

     (qnew_a a b c d e f g h p1 p2 H_qsign,

     (qnew_b a b c d e f g h p1 p2 H_qsign,

     (qnew_c a b c d e f g h p1 p2 H_qsign,

     qnew_d a b c d e f g h p1 p2 H_qsign)),

     (qnew_e a b c d e f g h p1 p2 H_qsign,

     (qnew_f a b c d e f g h p1 p2 H_qsign,

     (qnew_g a b c d e f g h p1 p2 H_qsign,

     qnew_h a b c d e f g h p1 p2 H_qsign))),

     (qnew_p1 a b c d e f g h p1 p2 H_qsign,

     qnew_p2 a b c d e f g h p1 p2 H_qsign))));

    [ abstract (rewrite <- l1_eq_one;

                 unfold qnew_a, qnew_b, qnew_c, qnew_d, qnew_e, qnew_f,

                  qnew_g, qnew_h, qnew_p1, qnew_p2 

                  in |- *;

                 replace (q_sign a b c d e f g h p1 p2 H_qsign) with

                  (fst (Qquadratic_sign a b c d e f g h p1 p2 H_qsign));

                 [ idtac | reflexivity ]; repeat rewrite <- pair_1;

                 reflexivity)

    | idtac ].



 case

  (Zsgn_1

     (qnew_a a b c d e f g h p1 p2 H_qsign +

      qnew_b a b c d e f g h p1 p2 H_qsign +

      qnew_c a b c d e f g h p1 p2 H_qsign +

      qnew_d a b c d e f g h p1 p2 H_qsign)).

 

 intros [na_nb_nc_nd_eq_zero| na_nb_nc_nd_eq_one].

 

 abstract (apply False_rec;

            generalize

             (Qquadratic_sign_pos_1 a b c d e f g h p1 p2 H_qsign

                (qnew_a a b c d e f g h p1 p2 H_qsign)

                (qnew_b a b c d e f g h p1 p2 H_qsign)

                (qnew_c a b c d e f g h p1 p2 H_qsign)

                (qnew_d a b c d e f g h p1 p2 H_qsign)

                (qnew_e a b c d e f g h p1 p2 H_qsign)

                (qnew_f a b c d e f g h p1 p2 H_qsign)

                (qnew_g a b c d e f g h p1 p2 H_qsign)

                (qnew_h a b c d e f g h p1 p2 H_qsign)

                (qnew_p1 a b c d e f g h p1 p2 H_qsign)

                (qnew_p2 a b c d e f g h p1 p2 H_qsign) H);

            intros [(na_nb_nc_nd_pos, _)| (na_nb_nc_nd_neg, _)];

            generalize (Zsgn_2 _ na_nb_nc_nd_eq_zero);

            [ apply sym_not_eq | idtac ]; apply Zorder.Zlt_not_eq; 

            assumption).

 

 refine

  (Qpos

     (Qquadratic_Qpositive_to_Qpositive

        (qnew_a a b c d e f g h p1 p2 H_qsign)

        (qnew_b a b c d e f g h p1 p2 H_qsign)

        (qnew_c a b c d e f g h p1 p2 H_qsign)

        (qnew_d a b c d e f g h p1 p2 H_qsign)

        (qnew_e a b c d e f g h p1 p2 H_qsign)

        (qnew_f a b c d e f g h p1 p2 H_qsign)

        (qnew_g a b c d e f g h p1 p2 H_qsign)

        (qnew_h a b c d e f g h p1 p2 H_qsign)

        (qnew_p1 a b c d e f g h p1 p2 H_qsign)

        (qnew_p2 a b c d e f g h p1 p2 H_qsign) _)).

 abstract apply

           (Qquadratic_Qpositive_to_Q_quadraticAcc_pos_1 a b c d e f g h p1

              p2 H_qsign not_same_ratio_abcdefgh l1_eq_one na_nb_nc_nd_eq_one).

 

 intro na_nb_nc_nd_eq_minus_one.

 refine

  (Qpos

     (Qquadratic_Qpositive_to_Qpositive

        (- qnew_a a b c d e f g h p1 p2 H_qsign)

        (- qnew_b a b c d e f g h p1 p2 H_qsign)

        (- qnew_c a b c d e f g h p1 p2 H_qsign)

        (- qnew_d a b c d e f g h p1 p2 H_qsign)

        (- qnew_e a b c d e f g h p1 p2 H_qsign)

        (- qnew_f a b c d e f g h p1 p2 H_qsign)

        (- qnew_g a b c d e f g h p1 p2 H_qsign)

        (- qnew_h a b c d e f g h p1 p2 H_qsign)

        (qnew_p1 a b c d e f g h p1 p2 H_qsign)

        (qnew_p2 a b c d e f g h p1 p2 H_qsign) _)).

 abstract apply

           (Qquadratic_Qpositive_to_Q_quadraticAcc_pos_2 a b c d e f g h p1

              p2 H_qsign not_same_ratio_abcdefgh l1_eq_one

              na_nb_nc_nd_eq_minus_one).



 intro l1_eq_min_one.



 assert

  (H :

   Qquadratic_sign a b c d e f g h p1 p2 H_qsign =

   ((-1)%Z,

   (qnew_a a b c d e f g h p1 p2 H_qsign,

   (qnew_b a b c d e f g h p1 p2 H_qsign,

   (qnew_c a b c d e f g h p1 p2 H_qsign,

   qnew_d a b c d e f g h p1 p2 H_qsign)),

   (qnew_e a b c d e f g h p1 p2 H_qsign,

   (qnew_f a b c d e f g h p1 p2 H_qsign,

   (qnew_g a b c d e f g h p1 p2 H_qsign,

   qnew_h a b c d e f g h p1 p2 H_qsign))),

   (qnew_p1 a b c d e f g h p1 p2 H_qsign,

   qnew_p2 a b c d e f g h p1 p2 H_qsign))));

  [ abstract (rewrite <- l1_eq_min_one;

               unfold qnew_a, qnew_b, qnew_c, qnew_d, qnew_e, qnew_f, qnew_g,

                qnew_h, qnew_p1, qnew_p2 in |- *;

               replace (q_sign a b c d e f g h p1 p2 H_qsign) with

                (fst (Qquadratic_sign a b c d e f g h p1 p2 H_qsign));

               [ idtac | reflexivity ]; repeat rewrite <- pair_1; 

               reflexivity)

  | idtac ].

 

 case

  (Zsgn_1

     (qnew_a a b c d e f g h p1 p2 H_qsign +

      qnew_b a b c d e f g h p1 p2 H_qsign +

      qnew_c a b c d e f g h p1 p2 H_qsign +

      qnew_d a b c d e f g h p1 p2 H_qsign)).

 

 intros [na_nb_nc_nd_eq_zero| na_nb_nc_nd_eq_one].

 

 abstract (apply False_rec;

            generalize

             (Qquadratic_sign_neg_1 a b c d e f g h p1 p2 H_qsign

                (qnew_a a b c d e f g h p1 p2 H_qsign)

                (qnew_b a b c d e f g h p1 p2 H_qsign)

                (qnew_c a b c d e f g h p1 p2 H_qsign)

                (qnew_d a b c d e f g h p1 p2 H_qsign)

                (qnew_e a b c d e f g h p1 p2 H_qsign)

                (qnew_f a b c d e f g h p1 p2 H_qsign)

                (qnew_g a b c d e f g h p1 p2 H_qsign)

                (qnew_h a b c d e f g h p1 p2 H_qsign)

                (qnew_p1 a b c d e f g h p1 p2 H_qsign)

                (qnew_p2 a b c d e f g h p1 p2 H_qsign) H);

            intros [(na_nb_nc_nd_pos, _)| (na_nb_nc_nd_neg, _)];

            generalize (Zsgn_2 _ na_nb_nc_nd_eq_zero);

            [ apply sym_not_eq | idtac ]; apply Zorder.Zlt_not_eq; 

            assumption).

 

 refine

  (Qneg

     (Qquadratic_Qpositive_to_Qpositive

        (qnew_a a b c d e f g h p1 p2 H_qsign)

        (qnew_b a b c d e f g h p1 p2 H_qsign)

        (qnew_c a b c d e f g h p1 p2 H_qsign)

        (qnew_d a b c d e f g h p1 p2 H_qsign)

        (- qnew_e a b c d e f g h p1 p2 H_qsign)

        (- qnew_f a b c d e f g h p1 p2 H_qsign)

        (- qnew_g a b c d e f g h p1 p2 H_qsign)

        (- qnew_h a b c d e f g h p1 p2 H_qsign)

        (qnew_p1 a b c d e f g h p1 p2 H_qsign)

        (qnew_p2 a b c d e f g h p1 p2 H_qsign) _)).

 abstract apply

           (Qquadratic_Qpositive_to_Q_quadraticAcc_neg_1 a b c d e f g h p1

              p2 H_qsign not_same_ratio_abcdefgh l1_eq_min_one

              na_nb_nc_nd_eq_one).



 intro na_nb_nc_nd_eq_minus_one.

 refine

  (Qneg

     (Qquadratic_Qpositive_to_Qpositive

        (- qnew_a a b c d e f g h p1 p2 H_qsign)

        (- qnew_b a b c d e f g h p1 p2 H_qsign)

        (- qnew_c a b c d e f g h p1 p2 H_qsign)

        (- qnew_d a b c d e f g h p1 p2 H_qsign)

        (qnew_e a b c d e f g h p1 p2 H_qsign)

        (qnew_f a b c d e f g h p1 p2 H_qsign)

        (qnew_g a b c d e f g h p1 p2 H_qsign)

        (qnew_h a b c d e f g h p1 p2 H_qsign)

        (qnew_p1 a b c d e f g h p1 p2 H_qsign)

        (qnew_p2 a b c d e f g h p1 p2 H_qsign) _)).

 abstract apply

           (Qquadratic_Qpositive_to_Q_quadraticAcc_neg_2 a b c d e f g h p1

              p2 H_qsign not_same_ratio_abcdefgh l1_eq_min_one

              na_nb_nc_nd_eq_minus_one).

Defined.



Inductive Qquadratic_denom_nonzero : Z -> Z -> Z -> Z -> Q -> Q -> Prop :=

  | Qquadraticok00 :

      forall (e f g h : Z) (s1 s2 : Q),

      s1 = Zero ->

      s2 = Zero -> h <> 0%Z -> Qquadratic_denom_nonzero e f g h s1 s2

  | Qquadraticok01 :

      forall (e f g h : Z) (s1 s2 : Q) (p2 : Qpositive),

      s1 = Zero ->

      s2 = Qpos p2 ->

      Qhomographic_sg_denom_nonzero g h p2 ->

      Qquadratic_denom_nonzero e f g h s1 s2

  | Qquadraticok02 :

      forall (e f g h : Z) (s1 s2 : Q) (p2 : Qpositive),

      s1 = Zero ->

      s2 = Qneg p2 ->

      Qhomographic_sg_denom_nonzero (- g) h p2 ->

      Qquadratic_denom_nonzero e f g h s1 s2

  | Qquadraticok10 :

      forall (e f g h : Z) (s1 s2 : Q) (p1 : Qpositive),

      s1 = Qpos p1 ->

      s2 = Zero ->

      Qhomographic_sg_denom_nonzero f h p1 ->

      Qquadratic_denom_nonzero e f g h s1 s2

  | Qquadraticok20 :

      forall (e f g h : Z) (s1 s2 : Q) (p1 : Qpositive),

      s1 = Qneg p1 ->

      s2 = Zero ->

      Qhomographic_sg_denom_nonzero (- f) h p1 ->

      Qquadratic_denom_nonzero e f g h s1 s2

  | Qquadraticok11 :

      forall (e f g h : Z) (s1 s2 : Q) (p1 p2 : Qpositive),

      s1 = Qpos p1 ->

      s2 = Qpos p2 ->

      Qquadratic_sg_denom_nonzero e f g h p1 p2 ->

      Qquadratic_denom_nonzero e f g h s1 s2

  | Qquadraticok12 :

      forall (e f g h : Z) (s1 s2 : Q) (p1 p2 : Qpositive),

      s1 = Qpos p1 ->

      s2 = Qneg p2 ->

      Qquadratic_sg_denom_nonzero (- e) f (- g) h p1 p2 ->

      Qquadratic_denom_nonzero e f g h s1 s2

  | Qquadraticok21 :

      forall (e f g h : Z) (s1 s2 : Q) (p1 p2 : Qpositive),

      s1 = Qneg p1 ->

      s2 = Qpos p2 ->

      Qquadratic_sg_denom_nonzero (- e) (- f) g h p1 p2 ->

      Qquadratic_denom_nonzero e f g h s1 s2

  | Qquadraticok22 :

      forall (e f g h : Z) (s1 s2 : Q) (p1 p2 : Qpositive),

      s1 = Qneg p1 ->

      s2 = Qneg p2 ->

      Qquadratic_sg_denom_nonzero e (- f) (- g) h p1 p2 ->

      Qquadratic_denom_nonzero e f g h s1 s2.



Lemma Qquadratic_00 :

 forall e f g h : Z, Qquadratic_denom_nonzero e f g h Zero Zero -> h <> 0%Z.  

Proof.

 intros.

 abstract (inversion H;

            assumption ||

              (repeat

                match goal with

                | id1:(?X1 = ?X2) |- ?X3 =>

                    try discriminate id1; clear id1

                end)).

Defined. 



Lemma Qquadratic_01 :

 forall (e f g h : Z) (p2 : Qpositive),

 Qquadratic_denom_nonzero e f g h Zero (Qpos p2) ->

 Qhomographic_sg_denom_nonzero g h p2.

Proof.

 intros.

 abstract (inversion H;

            try solve

             [ assumption

             | repeat

                match goal with

                | id1:(?X1 = ?X2) |- ?X3 =>

                    try discriminate id1; clear id1

                end ]; generalize (f_equal Q_tail H1); 

            simpl in |- *; intro H_p; rewrite H_p; 

            assumption).

Defined. 



Lemma Qquadratic_02 :

 forall (e f g h : Z) (p2 : Qpositive),

 Qquadratic_denom_nonzero e f g h Zero (Qneg p2) ->

 Qhomographic_sg_denom_nonzero (- g) h p2.

Proof.

 intros.

 abstract (inversion H;

            try solve

             [ assumption

             | repeat

                match goal with

                | id1:(?X1 = ?X2) |- ?X3 =>

                    try discriminate id1; clear id1

                end ]; generalize (f_equal Q_tail H1); 

            simpl in |- *; intro H_p; rewrite H_p; 

            assumption).

Defined. 



Lemma Qquadratic_10 :

 forall (e f g h : Z) (p1 : Qpositive),

 Qquadratic_denom_nonzero e f g h (Qpos p1) Zero ->

 Qhomographic_sg_denom_nonzero f h p1.

Proof.

 intros.

 abstract (inversion H;

            try solve

             [ assumption

             | repeat

                match goal with

                | id1:(?X1 = ?X2) |- ?X3 =>

                    try discriminate id1; clear id1

                end ]; generalize (f_equal Q_tail H0); 

            simpl in |- *; intro H_p; rewrite H_p; 

            assumption).

Defined. 



Lemma Qquadratic_20 :

 forall (e f g h : Z) (p1 : Qpositive),

 Qquadratic_denom_nonzero e f g h (Qneg p1) Zero ->

 Qhomographic_sg_denom_nonzero (- f) h p1.

Proof.

 intros.

 abstract (inversion H;

            try solve

             [ assumption

             | repeat

                match goal with

                | id1:(?X1 = ?X2) |- ?X3 =>

                    try discriminate id1; clear id1

                end ]; generalize (f_equal Q_tail H0); 

            simpl in |- *; intro H_p; rewrite H_p; 

            assumption).

Defined. 



Lemma Qquadratic_11 :

 forall (e f g h : Z) (p1 p2 : Qpositive),

 Qquadratic_denom_nonzero e f g h (Qpos p1) (Qpos p2) ->

 Qquadratic_sg_denom_nonzero e f g h p1 p2.

Proof.

 intros.

 abstract (inversion H;

            try solve

             [ assumption

             | repeat

                match goal with

                | id1:(?X1 = ?X2) |- ?X3 =>

                    try discriminate id1; clear id1

                end ];

            repeat

             match goal with

             | id1:(?X1 ?X2 = ?X1 ?X3) |- ?X4 =>

                 let tt := eval compute in (f_equal Q_tail id1) in

                 rewrite tt

             end; assumption).

Defined. 



Lemma Qquadratic_12 :

 forall (e f g h : Z) (p1 p2 : Qpositive),

 Qquadratic_denom_nonzero e f g h (Qpos p1) (Qneg p2) ->

 Qquadratic_sg_denom_nonzero (- e) f (- g) h p1 p2.

Proof.

 intros.

 abstract (inversion H;

            try solve

             [ assumption

             | repeat

                match goal with

                | id1:(?X1 = ?X2) |- ?X3 =>

                    try discriminate id1; clear id1

                end ];

            repeat

             match goal with

             | id1:(?X1 ?X2 = ?X1 ?X3) |- ?X4 =>

                 let tt := eval compute in (f_equal Q_tail id1) in

                 rewrite tt

             end; assumption).

Defined. 



Lemma Qquadratic_21 :

 forall (e f g h : Z) (p1 p2 : Qpositive),

 Qquadratic_denom_nonzero e f g h (Qneg p1) (Qpos p2) ->

 Qquadratic_sg_denom_nonzero (- e) (- f) g h p1 p2.

Proof.

 intros.

 abstract (inversion H;

            try solve

             [ assumption

             | repeat

                match goal with

                | id1:(?X1 = ?X2) |- ?X3 =>

                    try discriminate id1; clear id1

                end ];

            repeat

             match goal with

             | id1:(?X1 ?X2 = ?X1 ?X3) |- ?X4 =>

                 let tt := eval compute in (f_equal Q_tail id1) in

                 rewrite tt

             end; assumption).

Defined. 



Lemma Qquadratic_22 :

 forall (e f g h : Z) (p1 p2 : Qpositive),

 Qquadratic_denom_nonzero e f g h (Qneg p1) (Qneg p2) ->

 Qquadratic_sg_denom_nonzero e (- f) (- g) h p1 p2.

Proof.

 intros.

 abstract (inversion H;

            try solve

             [ assumption

             | repeat

                match goal with

                | id1:(?X1 = ?X2) |- ?X3 =>

                    try discriminate id1; clear id1

                end ];

            repeat

             match goal with

             | id1:(?X1 ?X2 = ?X1 ?X3) |- ?X4 =>

                 let tt := eval compute in (f_equal Q_tail id1) in

                 rewrite tt

             end; assumption).

Defined. 



Definition Qquadratic :

  Z ->

  Z ->

  Z ->

  Z ->

  forall (e f g h : Z) (s1 s2 : Q)

    (H_Qquadratic_denom_nonzero : Qquadratic_denom_nonzero e f g h s1 s2), Q.

intros a b c d e f g h [| p1 | p1 ]; [ |intros [| p2| p2] | intros [| p2| p2]]. 

 

 intros s2 H_Qquadratic_denom_nonzero.

 refine (Qhomographic c d g h s2 _).

 abstract (inversion_clear H_Qquadratic_denom_nonzero; solve

            [ apply Qhomographicok0; assumption

            | apply Qhomographicok1 with p2; assumption

            | apply Qhomographicok2 with p2; assumption

            | match goal with

              | id1:(?X2 = ?X3) |- ?X4 => discriminate id1

              end ]).

 

 intro H_Qquadratic_denom_nonzero.

 refine (Qhomographic b d f h (Qpos p1) _);

  abstract (inversion_clear H_Qquadratic_denom_nonzero;

             try solve

              [ apply Qhomographicok1 with p2; assumption

              | match goal with

                | id1:(?X2 = ?X3) |- ?X4 => discriminate id1

                end ]; injection H; intro H_injection; 

             rewrite H_injection; apply Qhomographicok1 with p0;

             [ reflexivity | assumption ]).



 intro H_Qquadratic_denom_nonzero.

 exact

  (Qquadratic_Qpositive_to_Q a b c d e f g h p1 p2

     (Qquadratic_11 e f g h p1 p2 H_Qquadratic_denom_nonzero)).

 

 intro H_Qquadratic_denom_nonzero.

 exact

  (Qquadratic_Qpositive_to_Q (- a) b (- c) d (- e) f 

     (- g) h p1 p2 (Qquadratic_12 e f g h p1 p2 H_Qquadratic_denom_nonzero)).

 

 intro H_Qquadratic_denom_nonzero.

 refine (Qhomographic b d f h (Qneg p1) _);

  abstract (inversion_clear H_Qquadratic_denom_nonzero;

             try solve

              [ apply Qhomographicok2 with p2; assumption

              | match goal with

                | id1:(?X2 = ?X3) |- ?X4 => discriminate id1

                end ]; injection H; intro H_injection; 

             rewrite H_injection; apply Qhomographicok2 with p0;

             [ reflexivity | assumption ]).

 

 intro H_Qquadratic_denom_nonzero.

 exact

  (Qquadratic_Qpositive_to_Q (- a) (- b) c d (- e) 

     (- f) g h p1 p2 (Qquadratic_21 e f g h p1 p2 H_Qquadratic_denom_nonzero)).

 

 intro H_Qquadratic_denom_nonzero.

 exact

  (Qquadratic_Qpositive_to_Q a (- b) (- c) d e (- f) 

     (- g) h p1 p2 (Qquadratic_22 e f g h p1 p2 H_Qquadratic_denom_nonzero)).

Defined.



Lemma Qquadratic_denom_nonzero_Zero_Zero_Zero_always :

 forall (h : Z) (s1 s2 : Q),

 h <> 0%Z -> Qquadratic_denom_nonzero 0 0 0 h s1 s2.

Proof.

 intros h s1 s2 Hh.

 generalize h Hh s2.  

  abstract (induction s1 as [| p| p]; intros; case s0;

             [  

             apply Qquadraticok00

             |  

                intro p; apply Qquadraticok01 with p

             |  

                intro p; apply Qquadraticok02 with p

             |  

             apply Qquadraticok10 with p

             |  

                intro p0; apply Qquadraticok11 with p p0

             |  

                intro p0; apply Qquadraticok12 with p p0

             |  

             apply Qquadraticok20 with p

             |  

                intro p0; apply Qquadraticok21 with p p0

             |  

                intro p0; apply Qquadraticok22 with p p0 ]; 

             simpl in |- *;

             reflexivity ||

               apply Qhomographic_sg_denom_nonzero_Zero_always ||

                 (try apply Qquadratic_sg_denom_nonzero_Zero_Zero_Zero_always);

             assumption).

Defined.  



Lemma Qquadratic_denom_nonzero_Zero_Zero_Zero_ONE :

 forall s1 s2 : Q, Qquadratic_denom_nonzero 0 0 0 1 s1 s2.

Proof.

 intros.

 apply Qquadratic_denom_nonzero_Zero_Zero_Zero_always.

 abstract discriminate.

Defined.



Lemma Qquadratic_denom_nonzero_Zero_Zero_always_Zero :

 forall (g : Z) (s1 s2 : Q) (H_nonzero_s2 : s2 <> Zero :>Q),

 g <> 0%Z -> Qquadratic_denom_nonzero 0 0 g 0 s1 s2.

Proof.

 intros g s1 s2 H_nonzero_s2 Hg.

 generalize g Hg s2 H_nonzero_s2.  

  abstract (induction s1 as [| p| p]; intros; destruct s0 as [| p0| p0];

             [ Falsum

             |  

              

             apply Qquadraticok01 with p0

             |  

             apply Qquadraticok02 with p0

             | Falsum

             |  

              

             apply Qquadraticok11 with p p0

             |  

             apply Qquadraticok12 with p p0

             | Falsum

             |  

              

             apply Qquadraticok21 with p p0

             |  

             apply Qquadraticok22 with p p0 ]; simpl in |- *;

             reflexivity ||

               apply Qhomographic_sg_denom_nonzero_always_Zero ||

                 (try apply Qquadratic_sg_denom_nonzero_Zero_Zero_always_Zero);

             try

              match goal with

              | id1:?X2 |- ((- ?X1)%Z <> 0%Z) => apply Zopp_app

              end; assumption).

Defined.  



Lemma Qquadratic_denom_nonzero_Zero_Zero_ONE_Zero :

 forall (s1 s2 : Q) (H_nonzero_s2 : s2 <> Zero :>Q),

 Qquadratic_denom_nonzero 0 0 1 0 s1 s2.

Proof.

 intros.

 apply (Qquadratic_denom_nonzero_Zero_Zero_always_Zero 1 s1 s2 H_nonzero_s2).

 abstract discriminate.

Defined.



Definition Qplus_lazy (x y : Q) : Q :=

  Qquadratic 0 1 1 0 0 0 0 1 x y

    (Qquadratic_denom_nonzero_Zero_Zero_Zero_ONE x y).



Definition Qmult_lazy (x y : Q) : Q :=

  Qquadratic 1 0 0 0 0 0 0 1 x y

    (Qquadratic_denom_nonzero_Zero_Zero_Zero_ONE x y).



Definition Qminus_lazy (x y : Q) : Q :=

  Qquadratic 0 1 (-1) 0 0 0 0 1 x y

    (Qquadratic_denom_nonzero_Zero_Zero_Zero_ONE x y).



Definition Qdiv_lazy (x y : Q) (Hy : y <> Zero) : Q :=

  Qquadratic 0 1 0 0 0 0 1 0 x y

    (Qquadratic_denom_nonzero_Zero_Zero_ONE_Zero x y Hy).



