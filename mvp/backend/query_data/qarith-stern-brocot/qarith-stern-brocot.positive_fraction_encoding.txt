
Require Export Zaux.
(* Zaux:
Require Export ZArith.
Require Export ZArithRing.

Tactic Notation "ElimCompare" constr(c) constr(d) := elim_compare c d.

Ltac Flip :=
  apply Z.gt_lt || apply Z.lt_gt || apply Z.le_ge || apply Z.ge_le; assumption.

Ltac Falsum :=
  try intro; apply False_ind;
   repeat
    match goal with
    | id1:(~ ?X1) |- ?X2 =>
        (apply id1; assumption || reflexivity) || clear id1
    end.

Ltac Step_l a :=
  match goal with
  |  |- (?X1 < ?X2)%Z => replace X1 with a; [ idtac | try ring ]
  end. 

Ltac Step_r a :=
  match goal with
  |  |- (?X1 < ?X2)%Z => replace X2 with a; [ idtac | try ring ]
  end. 

Ltac CaseEq formula :=
  generalize (refl_equal formula); pattern formula at -1 in |- *;
   case formula.

Lemma pair_1 : forall (A B : Set) (H : A * B), H = pair (fst H) (snd H).

Lemma pair_2 :
 forall (A B : Set) (H1 H2 : A * B),
 fst H1 = fst H2 -> snd H1 = snd H2 -> H1 = H2.

Section projection.   
 Variable A : Set.
 Variable P : A -> Prop.
 
 Definition projP1 (H : sig P) := let (x, h) := H in x.
 Definition projP2 (H : sig P) :=
   let (x, h) as H return (P (projP1 H)) := H in h.
End projection.

Lemma le_stepl: forall x y z, le x y -> x=z -> le z y.

Lemma le_stepr: forall x y z, le x y -> y=z -> le x z.

Lemma lt_stepl: forall x y z, lt x y -> x=z -> lt z y.

Lemma lt_stepr: forall x y z, lt x y -> y=z -> lt x z.

Lemma neq_stepl:forall (x y z:nat), x<>y -> x=z -> z<>y.

Lemma neq_stepr:forall (x y z:nat), x<>y -> y=z -> x<>z.

Declare Left Step le_stepl.
Declare Right Step le_stepr.
Declare Left Step lt_stepl.
Declare Right Step lt_stepr.
Declare Left Step neq_stepl.
Declare Right Step neq_stepr.

Lemma not_O_S : forall n : nat, n <> 0 -> {p : nat | n = S p}.
  
Lemma lt_minus_neq : forall m n : nat, m < n -> n - m <> 0.

Lemma lt_minus_eq_0 : forall m n : nat, m < n -> m - n = 0.

Lemma le_plus_Sn_1_SSn : forall n : nat, S n + 1 <= S (S n).

Lemma le_plus_O_l : forall p q : nat, p + q <= 0 -> p = 0.

Lemma le_plus_O_r : forall p q : nat, p + q <= 0 -> q = 0.

Lemma minus_pred : forall m n : nat, 0 < n -> pred m - pred n = m - n.

Lemma Zle_stepl: forall x y z, (x<=y)%Z -> x=z -> (z<=y)%Z.

Lemma Zle_stepr: forall x y z, (x<=y)%Z -> y=z -> (x<=z)%Z.

Lemma Zlt_stepl: forall x y z, (x<y)%Z -> x=z -> (z<y)%Z.

Lemma Zlt_stepr: forall x y z, (x<y)%Z -> y=z -> (x<z)%Z.

Lemma Zneq_stepl:forall (x y z:Z), (x<>y)%Z -> x=z -> (z<>y)%Z.

Lemma Zneq_stepr:forall (x y z:Z), (x<>y)%Z -> y=z -> (x<>z)%Z.

Declare Left Step Zle_stepl.
Declare Right Step Zle_stepr.
Declare Left Step Zlt_stepl.
Declare Right Step Zlt_stepr.
Declare Left Step Zneq_stepl.
Declare Right Step Zneq_stepr.

Lemma Zlt_cotrans :
 forall x y : Z, (x < y)%Z -> forall z : Z, {(x < z)%Z} + {(z < y)%Z}.

Lemma Zlt_cotrans_pos :
 forall x y : Z, (0 < x + y)%Z -> {(0 < x)%Z} + {(0 < y)%Z}.

Lemma Zlt_cotrans_neg :
 forall x y : Z, (x + y < 0)%Z -> {(x < 0)%Z} + {(y < 0)%Z}.

Lemma not_Zeq_inf : forall x y : Z, x <> y -> {(x < y)%Z} + {(y < x)%Z}.

Lemma Z_dec : forall x y : Z, {(x < y)%Z} + {(x > y)%Z} + {x = y}.
 
Lemma Z_dec' : forall x y : Z, {(x < y)%Z} + {(y < x)%Z} + {x = y}.

Lemma Z_lt_le_dec : forall x y : Z, {(x < y)%Z} + {(y <= x)%Z}.

Lemma Z_le_lt_dec : forall x y : Z, {(x <= y)%Z} + {(y < x)%Z}.

Lemma Z_lt_lt_S_eq_dec :
 forall x y : Z, (x < y)%Z -> {(x + 1 < y)%Z} + {(x + 1)%Z = y}.

Lemma quadro_leq_inf :
 forall a b c d : Z,
 {(c <= a)%Z /\ (d <= b)%Z} + {~ ((c <= a)%Z /\ (d <= b)%Z)}.

Lemma Zminus_eq : forall x y : Z, (x - y)%Z = 0%Z -> x = y.

Lemma Zlt_minus : forall a b : Z, (b < a)%Z -> (0 < a - b)%Z.

Lemma Zle_minus : forall a b : Z, (b <= a)%Z -> (0 <= a - b)%Z.

Lemma Zlt_plus_plus :
 forall m n p q : Z, (m < n)%Z -> (p < q)%Z -> (m + p < n + q)%Z.

Lemma Zgt_plus_plus :
 forall m n p q : Z, (m > n)%Z -> (p > q)%Z -> (m + p > n + q)%Z.

Lemma Zle_lt_plus_plus :
 forall m n p q : Z, (m <= n)%Z -> (p < q)%Z -> (m + p < n + q)%Z.

Lemma Zge_gt_plus_plus :
 forall m n p q : Z, (m >= n)%Z -> (p > q)%Z -> (m + p > n + q)%Z.

Lemma Zgt_ge_plus_plus :
 forall m n p q : Z, (m > n)%Z -> (p >= q)%Z -> (m + p > n + q)%Z.

Lemma Zlt_resp_pos : forall x y : Z, (0 < x)%Z -> (0 < y)%Z -> (0 < x + y)%Z.

Lemma Zle_resp_neg :
 forall x y : Z, (x <= 0)%Z -> (y <= 0)%Z -> (x + y <= 0)%Z.

Lemma Zlt_pos_opp : forall x : Z, (0 < x)%Z -> (- x < 0)%Z.

Lemma Zlt_neg_opp : forall x : Z, (x < 0)%Z -> (0 < - x)%Z.

Lemma Zle_neg_opp : forall x : Z, (x <= 0)%Z -> (0 <= - x)%Z.

Lemma Zle_pos_opp : forall x : Z, (0 <= x)%Z -> (- x <= 0)%Z.

Lemma Zge_opp : forall x y : Z, (x <= y)%Z -> (- x >= - y)%Z.

Lemma Zmult_pos_pos : forall x y : Z, (0 < x)%Z -> (0 < y)%Z -> (0 < x * y)%Z.

Lemma Zmult_neg_neg : forall x y : Z, (x < 0)%Z -> (y < 0)%Z -> (0 < x * y)%Z.

Lemma Zmult_neg_pos : forall x y : Z, (x < 0)%Z -> (0 < y)%Z -> (x * y < 0)%Z.

Lemma Zmult_pos_neg : forall x y : Z, (0 < x)%Z -> (y < 0)%Z -> (x * y < 0)%Z.

Hint Resolve Zmult_pos_pos Zmult_neg_neg Zmult_neg_pos Zmult_pos_neg: zarith.

Lemma Zle_reg_mult_l :
 forall x y a : Z, (0 < a)%Z -> (x <= y)%Z -> (a * x <= a * y)%Z.

Lemma Zsimpl_plus_l_dep :
 forall x y m n : Z, (x + m)%Z = (y + n)%Z -> x = y -> m = n.

Lemma Zsimpl_plus_r_dep :
 forall x y m n : Z, (m + x)%Z = (n + y)%Z -> x = y -> m = n.

Lemma Zmult_simpl :
 forall n m p q : Z, n = m -> p = q -> (n * p)%Z = (m * q)%Z.
 
Lemma Zsimpl_mult_l :
 forall n m p : Z, n <> 0%Z -> (n * m)%Z = (n * p)%Z -> m = p.

Lemma Zlt_reg_mult_l :
 forall x y z : Z, (x > 0)%Z -> (y < z)%Z -> (x * y < x * z)%Z. 

Lemma Zlt_opp : forall x y : Z, (x < y)%Z -> (- x > - y)%Z. 

Lemma Zlt_conv_mult_l :
 forall x y z : Z, (x < 0)%Z -> (y < z)%Z -> (x * y > x * z)%Z. 

Lemma Zgt_not_eq : forall x y : Z, (x > y)%Z -> x <> y.   

Lemma Zmult_resp_nonzero :
 forall x y : Z, x <> 0%Z -> y <> 0%Z -> (x * y)%Z <> 0%Z.

Lemma Zopp_app : forall y : Z, y <> 0%Z -> (- y)%Z <> 0%Z.

Lemma Zle_neq_Zlt : forall a b : Z, (a <= b)%Z -> b <> a -> (a < b)%Z.

Lemma not_Zle_lt : forall x y : Z, ~ (y <= x)%Z -> (x < y)%Z.

Lemma not_Zlt : forall x y : Z, ~ (y < x)%Z -> (x <= y)%Z.

Lemma Zmult_absorb :
 forall x y z : Z, x <> 0%Z -> (x * y)%Z = (x * z)%Z -> y = z.  

Lemma Zlt_mult_mult :
 forall a b c d : Z,
 (0 < a)%Z -> (0 < d)%Z -> (a < b)%Z -> (c < d)%Z -> (a * c < b * d)%Z.

Lemma Zgt_mult_conv_absorb_l :
 forall a x y : Z, (a < 0)%Z -> (a * x > a * y)%Z -> (x < y)%Z. 

Lemma Zgt_mult_reg_absorb_l :
 forall a x y : Z, (a > 0)%Z -> (a * x > a * y)%Z -> (x > y)%Z. 

Lemma Zopp_Zlt : forall x y : Z, (y < x)%Z -> (- x < - y)%Z.

Lemma Zmin_cancel_Zlt : forall x y : Z, (- x < - y)%Z -> (y < x)%Z.

Lemma Zmult_cancel_Zle :
 forall a x y : Z, (a < 0)%Z -> (a * x <= a * y)%Z -> (y <= x)%Z.

Lemma Zlt_mult_cancel_l :
 forall x y z : Z, (0 < x)%Z -> (x * y < x * z)%Z -> (y < z)%Z.
 
Lemma Zmin_cancel_Zle : forall x y : Z, (- x <= - y)%Z -> (y <= x)%Z.

Lemma Zmult_resp_Zle :
 forall a x y : Z, (0 < a)%Z -> (a * y <= a * x)%Z -> (y <= x)%Z.

Lemma Zopp_Zle : forall x y : Z, (y <= x)%Z -> (- x <= - y)%Z.

Lemma Zle_lt_eq_S : forall x y : Z, (x <= y)%Z -> (y < x + 1)%Z -> y = x.

Lemma Zlt_le_eq_S :
 forall x y : Z, (x < y)%Z -> (y <= x + 1)%Z -> y = (x + 1)%Z.

Lemma double_not_equal_zero :
 forall c d : Z, ~ (c = 0%Z /\ d = 0%Z) -> c <> d \/ c <> 0%Z.

Lemma triple_not_equal_zero :
 forall a b c : Z,
 ~ (a = 0%Z /\ b = 0%Z /\ c = 0%Z) -> a <> 0%Z \/ b <> 0%Z \/ c <> 0%Z.

Lemma mediant_1 :
 forall m n m' n' : Z, (m' * n < m * n')%Z -> ((m + m') * n < m * (n + n'))%Z.
 
Lemma mediant_2 :
 forall m n m' n' : Z,
 (m' * n < m * n')%Z -> (m' * (n + n') < (m + m') * n')%Z. 

Lemma mediant_3 :
 forall a b m n m' n' : Z,
 (0 <= a * m + b * n)%Z ->
 (0 <= a * m' + b * n')%Z -> (0 <= a * (m + m') + b * (n + n'))%Z.

Lemma fraction_lt_trans :
 forall a b c d e f : Z,
 (0 < b)%Z ->
 (0 < d)%Z ->
 (0 < f)%Z -> (a * d < c * b)%Z -> (c * f < e * d)%Z -> (a * f < e * b)%Z.

Lemma square_pos : forall a : Z, a <> 0%Z -> (0 < a * a)%Z.
 
Hint Resolve square_pos: zarith.

Definition Z2positive (z : Z) :=
  match z with
  | Zpos p => p
  | Zneg p => p
  | Z0 => 1%positive
  end.

Lemma ZL9 : forall p : positive, Z_of_nat (nat_of_P p) = Zpos p. 

Coercion Z_of_nat : nat >-> Z.

Lemma ZERO_lt_POS : forall p : positive, (0 < Zpos p)%Z.

Lemma POS_neq_ZERO : forall p : positive, Zpos p <> 0%Z.

Lemma NEG_neq_ZERO : forall p : positive, Zneg p <> 0%Z.

Lemma POS_resp_eq : forall p0 p1 : positive, Zpos p0 = Zpos p1 -> p0 = p1.

Lemma nat_nat_pos : forall m n : nat, ((m + 1) * (n + 1) > 0)%Z. 
 
Theorem S_predn : forall m : nat, m <> 0 -> S (pred m) = m. 

Lemma absolu_1 : forall x : Z, Z.abs_nat x = 0 -> x = 0%Z. 

Lemma absolu_2 : forall x : Z, x <> 0%Z -> Z.abs_nat x <> 0. 

Lemma absolu_inject_nat : forall n : nat, Z.abs_nat (Z_of_nat n) = n.

Lemma eq_inj : forall m n : nat, m = n :>Z -> m = n.

Lemma lt_inj : forall m n : nat, (m < n)%Z -> m < n.

Lemma le_inj : forall m n : nat, (m <= n)%Z -> m <= n.

Lemma inject_nat_S_inf : forall x : Z, (0 < x)%Z -> {n : nat | x = S n}.

Lemma le_absolu :
 forall x y : Z,
 (0 <= x)%Z -> (0 <= y)%Z -> (x <= y)%Z -> Z.abs_nat x <= Z.abs_nat y.

Lemma lt_absolu :
 forall x y : Z,
 (0 <= x)%Z -> (0 <= y)%Z -> (x < y)%Z -> Z.abs_nat x < Z.abs_nat y.

Lemma absolu_plus :
 forall x y : Z,
 (0 <= x)%Z -> (0 <= y)%Z -> Z.abs_nat (x + y) = Z.abs_nat x + Z.abs_nat y.

Lemma pred_absolu :
 forall x : Z, (0 < x)%Z -> pred (Z.abs_nat x) = Z.abs_nat (x - 1).

Definition pred_nat : forall (x : Z) (Hx : (0 < x)%Z), nat.

Lemma pred_nat_equal :
 forall (x : Z) (Hx1 Hx2 : (0 < x)%Z), pred_nat x Hx1 = pred_nat x Hx2.

Let pred_nat_unfolded_subproof px :
  Pos.to_nat px <> 0.

Lemma pred_nat_unfolded :
 forall (x : Z) (Hx : (0 < x)%Z), x = S (pred_nat x Hx).

Lemma absolu_pred_nat :
 forall (m : Z) (Hm : (0 < m)%Z), S (pred_nat m Hm) = Z.abs_nat m.

Lemma pred_nat_absolu :
 forall (m : Z) (Hm : (0 < m)%Z), pred_nat m Hm = Z.abs_nat (m - 1).

Lemma minus_pred_nat :
 forall (n m : Z) (Hn : (0 < n)%Z) (Hm : (0 < m)%Z) (Hnm : (0 < n - m)%Z),
 S (pred_nat n Hn) - S (pred_nat m Hm) = S (pred_nat (n - m) Hnm).

Lemma Zsgn_1 :
 forall x : Z, {Z.sgn x = 0%Z} + {Z.sgn x = 1%Z} + {Z.sgn x = (-1)%Z}. 

Lemma Zsgn_2 : forall x : Z, Z.sgn x = 0%Z -> x = 0%Z.   

Lemma Zsgn_3 : forall x : Z, x <> 0%Z -> Z.sgn x <> 0%Z.   

Theorem Zsgn_4 : forall a : Z, a = (Z.sgn a * Z.abs_nat a)%Z.  

Theorem Zsgn_5 :
 forall a b x y : Z,
 x <> 0%Z ->
 y <> 0%Z ->
 (Z.sgn a * x)%Z = (Z.sgn b * y)%Z -> (Z.sgn a * y)%Z = (Z.sgn b * x)%Z.  

Lemma Zsgn_6 : forall x : Z, x = 0%Z -> Z.sgn x = 0%Z.

Lemma Zsgn_7 : forall x : Z, (x > 0)%Z -> Z.sgn x = 1%Z.

Lemma Zsgn_7' : forall x : Z, (0 < x)%Z -> Z.sgn x = 1%Z.

Lemma Zsgn_8 : forall x : Z, (x < 0)%Z -> Z.sgn x = (-1)%Z.

Lemma Zsgn_9 : forall x : Z, Z.sgn x = 1%Z -> (0 < x)%Z.
 
Lemma Zsgn_10 : forall x : Z, Z.sgn x = (-1)%Z -> (x < 0)%Z.

Lemma Zsgn_11 : forall x : Z, (Z.sgn x < 0)%Z -> (x < 0)%Z.

Lemma Zsgn_12 : forall x : Z, (0 < Z.sgn x)%Z -> (0 < x)%Z.

Lemma Zsgn_13 : forall x : Z, (0 <= Z.sgn x)%Z -> (0 <= x)%Z.

Lemma Zsgn_14 : forall x : Z, (Z.sgn x <= 0)%Z -> (x <= 0)%Z.

Lemma Zsgn_15 : forall x y : Z, Z.sgn (x * y) = (Z.sgn x * Z.sgn y)%Z.

Lemma Zsgn_16 :
 forall x y : Z,
 Z.sgn (x * y) = 1%Z -> {(0 < x)%Z /\ (0 < y)%Z} + {(x < 0)%Z /\ (y < 0)%Z}.

Lemma Zsgn_17 :
 forall x y : Z,
 Z.sgn (x * y) = (-1)%Z -> {(0 < x)%Z /\ (y < 0)%Z} + {(x < 0)%Z /\ (0 < y)%Z}.

Lemma Zsgn_18 : forall x y : Z, Z.sgn (x * y) = 0%Z -> {x = 0%Z} + {y = 0%Z}.

Lemma Zsgn_19 : forall x y : Z, (0 < Z.sgn x + Z.sgn y)%Z -> (0 < x + y)%Z.

Lemma Zsgn_20 : forall x y : Z, (Z.sgn x + Z.sgn y < 0)%Z -> (x + y < 0)%Z.

Lemma Zsgn_21 : forall x y : Z, (0 < Z.sgn x + Z.sgn y)%Z -> (0 <= x)%Z.

Lemma Zsgn_22 : forall x y : Z, (Z.sgn x + Z.sgn y < 0)%Z -> (x <= 0)%Z.

Lemma Zsgn_23 : forall x y : Z, (0 < Z.sgn x + Z.sgn y)%Z -> (0 <= y)%Z.

Lemma Zsgn_24 : forall x y : Z, (Z.sgn x + Z.sgn y < 0)%Z -> (y <= 0)%Z.

Lemma Zsgn_25 : forall x : Z, Z.sgn (- x) = (- Z.sgn x)%Z.

Lemma Zsgn_26 : forall x : Z, (0 < x)%Z -> (0 < Z.sgn x)%Z.

Lemma Zsgn_27 : forall x : Z, (x < 0)%Z -> (Z.sgn x < 0)%Z.

Hint Resolve Zsgn_1 Zsgn_2 Zsgn_3 Zsgn_4 Zsgn_5 Zsgn_6 Zsgn_7 Zsgn_7' Zsgn_8
  Zsgn_9 Zsgn_10 Zsgn_11 Zsgn_12 Zsgn_13 Zsgn_14 Zsgn_15 Zsgn_16 Zsgn_17
  Zsgn_18 Zsgn_19 Zsgn_20 Zsgn_21 Zsgn_22 Zsgn_23 Zsgn_24 Zsgn_25 Zsgn_26
  Zsgn_27: zarith.

Lemma Zabs_1 : forall z p : Z, (Z.abs z < p)%Z -> (z < p)%Z /\ (- p < z)%Z.

Lemma Zabs_2 : forall z p : Z, (Z.abs z > p)%Z -> (z > p)%Z \/ (- p > z)%Z.

Lemma Zabs_3 : forall z p : Z, (z < p)%Z /\ (- p < z)%Z -> (Z.abs z < p)%Z.

Lemma Zabs_4 : forall z p : Z, (Z.abs z < p)%Z -> (- p < z < p)%Z.
 
Lemma Zabs_5 : forall z p : Z, (Z.abs z <= p)%Z -> (- p <= z <= p)%Z.

Lemma Zabs_6 : forall z p : Z, (Z.abs z <= p)%Z -> (z <= p)%Z.

Lemma Zabs_7 : forall z p : Z, (Z.abs z <= p)%Z -> (- p <= z)%Z.

Lemma Zabs_8 : forall z p : Z, (- p <= z <= p)%Z -> (Z.abs z <= p)%Z.

Lemma Zabs_min : forall z : Z, Z.abs z = Z.abs (- z).

Lemma Zabs_9 :
 forall z p : Z, (0 <= p)%Z -> (p < z)%Z \/ (z < - p)%Z -> (p < Z.abs z)%Z.

Lemma Zabs_10 : forall z : Z, (0 <= Z.abs z)%Z.

Lemma Zabs_11 : forall z : Z, z <> 0%Z -> (0 < Z.abs z)%Z.

Lemma Zabs_12 : forall z m : Z, (m < Z.abs z)%Z -> {(m < z)%Z} + {(z < - m)%Z}.

Lemma Zabs_mult : forall z p : Z, Z.abs (z * p) = (Z.abs z * Z.abs p)%Z.

Lemma Zabs_plus : forall z p : Z, (Z.abs (z + p) <= Z.abs z + Z.abs p)%Z.

Lemma Zabs_neg : forall z : Z, (z <= 0)%Z -> Z.abs z = (- z)%Z.

Lemma Zle_Zabs: forall z, (z <= Z.abs z)%Z.
 
Hint Resolve Zabs_1 Zabs_2 Zabs_3 Zabs_4 Zabs_5 Zabs_6 Zabs_7 Zabs_8 Zabs_9
  Zabs_10 Zabs_11 Zabs_12 Zabs_min Zabs_neg Zabs_mult Zabs_plus Zle_Zabs: zarith.

Lemma Zind :
 forall (P : Z -> Prop) (p : Z),
 P p ->
 (forall q : Z, (p <= q)%Z -> P q -> P (q + 1)%Z) ->
 forall q : Z, (p <= q)%Z -> P q. 

Lemma Zrec :
 forall (P : Z -> Set) (p : Z),
 P p ->
 (forall q : Z, (p <= q)%Z -> P q -> P (q + 1)%Z) ->
 forall q : Z, (p <= q)%Z -> P q. 

Lemma Zrec_down :
 forall (P : Z -> Set) (p : Z),
 P p ->
 (forall q : Z, (q <= p)%Z -> P q -> P (q - 1)%Z) ->
 forall q : Z, (q <= p)%Z -> P q.

Lemma Zind_down :
 forall (P : Z -> Prop) (p : Z),
 P p ->
 (forall q : Z, (q <= p)%Z -> P q -> P (q - 1)%Z) ->
 forall q : Z, (q <= p)%Z -> P q.

Lemma Zrec_wf :
 forall (P : Z -> Set) (p : Z),
 (forall q : Z, (forall r : Z, (p <= r < q)%Z -> P r) -> P q) ->
 forall q : Z, (p <= q)%Z -> P q.

Lemma Zrec_wf2 :
 forall (q : Z) (P : Z -> Set) (p : Z),
 (forall q : Z, (forall r : Z, (p <= r < q)%Z -> P r) -> P q) ->
 (p <= q)%Z -> P q.

Lemma Zrec_wf_double :
 forall (P : Z -> Z -> Set) (p0 q0 : Z),
 (forall n m : Z,
  (forall p q : Z, (q0 <= q)%Z -> (p0 <= p < n)%Z -> P p q) ->
  (forall p : Z, (q0 <= p < m)%Z -> P n p) -> P n m) ->
 forall p q : Z, (q0 <= q)%Z -> (p0 <= p)%Z -> P p q.

Lemma Zind_wf :
 forall (P : Z -> Prop) (p : Z),
 (forall q : Z, (forall r : Z, (p <= r < q)%Z -> P r) -> P q) ->
 forall q : Z, (p <= q)%Z -> P q.

Lemma Zind_wf2 :
 forall (q : Z) (P : Z -> Prop) (p : Z),
 (forall q : Z, (forall r : Z, (p <= r < q)%Z -> P r) -> P q) ->
 (p <= q)%Z -> P q.

Lemma Zind_wf_double :
 forall (P : Z -> Z -> Prop) (p0 q0 : Z),
 (forall n m : Z,
  (forall p q : Z, (q0 <= q)%Z -> (p0 <= p < n)%Z -> P p q) ->
  (forall p : Z, (q0 <= p < m)%Z -> P n p) -> P n m) ->
 forall p q : Z, (q0 <= q)%Z -> (p0 <= p)%Z -> P p q.

Definition Zmax (n m : Z) := (n + m - Z.min n m)%Z.

Lemma ZmaxSS : forall n m : Z, (Zmax n m + 1)%Z = Zmax (n + 1) (m + 1).

Lemma Zle_max_l : forall n m : Z, (n <= Zmax n m)%Z.

Lemma Zle_max_r : forall n m : Z, (m <= Zmax n m)%Z.

Lemma Zmin_or_informative : forall n m : Z, {Z.min n m = n} + {Z.min n m = m}.

Lemma Zmax_case : forall (n m : Z) (P : Z -> Set), P n -> P m -> P (Zmax n m).
 
Lemma Zmax_or_informative : forall n m : Z, {Zmax n m = n} + {Zmax n m = m}. 

Lemma Zmax_n_n : forall n : Z, Zmax n n = n.

Hint Resolve ZmaxSS Zle_max_r Zle_max_l Zmax_n_n: zarith.

Lemma Zeven_S : forall x : Z, Zeven.Zodd x -> Zeven.Zeven (x + 1).

Lemma Zeven_pred : forall x : Z, Zeven.Zodd x -> Zeven.Zeven (x - 1). 

Definition Z_modulo_2_always :
  forall x : Z, {y : Z | x = (2 * y)%Z} + {y : Z | x = (2 * y + 1)%Z} :=
  Zeven.Z_modulo_2.

Lemma Z_div_mod_eq_2 :
 forall a b : Z, (0 < b)%Z -> (b * (a / b))%Z = (a - a mod b)%Z.

Lemma Z_div_le :
 forall a b c : Z, (0 < c)%Z -> (b <= a)%Z -> (b / c <= a / c)%Z. 

Lemma Z_div_nonneg :
 forall a b : Z, (0 < b)%Z -> (0 <= a)%Z -> (0 <= a / b)%Z.

Lemma Z_div_neg : forall a b : Z, (0 < b)%Z -> (a < 0)%Z -> (a / b < 0)%Z.

Hint Resolve Z_div_mod_eq_2 Z_div_le Z_div_nonneg Z_div_neg: zarith.

Lemma Zpower_1 : forall a : Z, (a ^ 1)%Z = a.

Lemma Zpower_2 : forall a : Z, (a ^ 2)%Z = (a * a)%Z.

Hint Resolve Zpower_1 Zpower_2: zarith. *)
Require Import ZArithRing.
Require Export Qpositive.
(* Qpositive:
Require Export Arith.
Require Export Compare_dec.
Require Export ArithRing.
Require Export Omega.
Require Export ZArith.
Require Export ZArithRing.
 
Ltac CaseEq f := generalize (refl_equal f); pattern f at -1 in |- *; case f.
 
Inductive Qpositive : Set :=
  | nR : Qpositive -> Qpositive
  | dL : Qpositive -> Qpositive
  | One : Qpositive.
 
Fixpoint Qpositive_i (w : Qpositive) : nat * nat :=
  match w with
  | One => (1, 1)
  | nR w' => match Qpositive_i w' with
             | (p, q) => (p + q, q)
             end
  | dL w' => match Qpositive_i w' with
             | (p, q) => (p, p + q)
             end
  end.
Coercion Z_of_nat : nat >-> Z.
 
Theorem interp_reduced_fraction :
 forall w : Qpositive,
 exists a : Z,
   (exists b : Z, (a * fst (Qpositive_i w) + b * snd (Qpositive_i w))%Z = 1%Z).
 
Fixpoint Qpositive_inv (w : Qpositive) : Qpositive :=
  match w with
  | One => One
  | nR w' => dL (Qpositive_inv w')
  | dL w' => nR (Qpositive_inv w')
  end.
 
Theorem inv_correct :
 forall (w : Qpositive) (p q : nat),
 Qpositive_i w = (p, q) -> Qpositive_i (Qpositive_inv w) = (q, p).
 
Theorem interp_non_zero :
 forall w : Qpositive,
 exists p : nat, (exists q : nat, Qpositive_i w = (S p, S q)).
 
Fixpoint Qpositive_c (p q n : nat) {struct n} : Qpositive :=
  match n with
  | O => One
  | S n' =>
      match p - q with
      | O => match q - p with
             | O => One
             | v => dL (Qpositive_c p v n')
             end
      | v => nR (Qpositive_c v q n')
      end
  end.
 
Theorem minus_O_le : forall n m : nat, n - m = 0 -> n <= m.
 
Theorem le_minus_O : forall n m : nat, n <= m -> n - m = 0.
 
Theorem minus_le : forall m n : nat, m - n <= m.
 
Theorem mult_reg_l : forall n m p : nat, S n * m = S n * p -> m = p.
 
Theorem absolu_inj_nat : forall x : nat, Z.abs_nat (Z_of_nat x) = x.
 
Theorem absolu_mult :
 forall x y : Z, Z.abs_nat (x * y) = Z.abs_nat x * Z.abs_nat y.
 
Theorem Qpositive_c_unfold1 :
 forall p q n : nat,
 S p + S q + S q <= S n ->
 Qpositive_c (S p + S q) (S q) (S n) = nR (Qpositive_c (S p) (S q) n).
 
Theorem Qpositive_c_unfold2 :
 forall p q n : nat,
 S p + (S p + S q) <= S n ->
 Qpositive_c (S p) (S p + S q) (S n) = dL (Qpositive_c (S p) (S q) n).
 
Theorem construct_correct :
 forall (w : Qpositive) (p q n : nat),
 Qpositive_i w = (p, q) -> p + q <= n -> Qpositive_c p q n = w.
 
Theorem construct_correct2 :
 forall n p q : nat,
 S p + S q <= n ->
 exists d : nat,
   S p = fst (Qpositive_i (Qpositive_c (S p) (S q) n)) * S d /\
   S q = snd (Qpositive_i (Qpositive_c (S p) (S q) n)) * S d.
 
Theorem construct_correct2' :
 forall n p q : nat,
 1 <= p ->
 1 <= q ->
 p + q <= n ->
 exists d : nat,
   p = fst (Qpositive_i (Qpositive_c p q n)) * S d /\
   q = snd (Qpositive_i (Qpositive_c p q n)) * S d.
 
Theorem construct_correct3 :
 forall n n' p q p' q' d : nat,
 S p = S d * p' ->
 S q = S d * q' ->
 S p + S q <= S n ->
 p' + q' <= S n' -> Qpositive_c (S p) (S q) (S n) = Qpositive_c p' q' (S n').
 
Theorem construct_correct4 :
 forall p q p' q' n n' : nat,
 S p + S q <= S n ->
 S p' + S q' <= S n' ->
 S p * S q' = S p' * S q ->
 Qpositive_c (S p) (S q) (S n) = Qpositive_c (S p') (S q') (S n').
 
Theorem construct_correct4' :
 forall p q p' q' n n' : nat,
 1 <= p ->
 1 <= q ->
 1 <= p' ->
 1 <= q' ->
 p + q <= n ->
 p' + q' <= n' -> p * q' = p' * q -> Qpositive_c p q n = Qpositive_c p' q' n'.
 
Theorem interp_inject :
 forall w w' : Qpositive, Qpositive_i w = Qpositive_i w' -> w = w'.
 
Theorem minus_decompose :
 forall a b c d : nat, a = b -> c = d -> a - c = b - d.
 
Theorem Qpositive_c_equiv :
 forall n p q n' p' q' : nat,
 S p + S q <= n ->
 S p' + S q' <= n' ->
 Qpositive_c (S p) (S q) n = Qpositive_c (S p') (S q') n' ->
 S p * S q' = S p' * S q.
 
Theorem Qpositive_c_equiv' :
 forall n p q n' p' q' : nat,
 1 <= p ->
 1 <= q ->
 1 <= p' ->
 1 <= q' ->
 p + q <= n ->
 p' + q' <= n' -> Qpositive_c p q n = Qpositive_c p' q' n' -> p * q' = p' * q. *)
Require Export Q_field.
(* Q_field:
Require Export Qpositive_sub.

Inductive Q : Set :=
  | Zero : Q
  | Qpos : Qpositive -> Q
  | Qneg : Qpositive -> Q.
 
Definition Qone := Qpos One.
 
Definition Qpositive_le_dec :
  forall w w' : Qpositive, {Qpositive_le w w'} + {~ Qpositive_le w w'}.

Ltac Case' f :=
  match constr:(f) with
  | (Qpositive_le_dec ?X1 ?X2) =>
      case f;
       [ idtac
       | intros Dummy;
          generalize (not_Qpositive_le_not_eq _ _ Dummy)
           (not_Qpositive_le_Qpositive_le' _ _ Dummy) Dummy; 
          clear Dummy ]
  | _ => case f
  end.

Definition Qpositive_eq_dec : forall w w' : Qpositive, {w = w'} + {w <> w'}.
 
Definition Qplus (x y : Q) :=
  match x, y with
  | Qpos x', Qpos y' => Qpos (Qpositive_plus x' y')
  | Qpos x', Qneg y' =>
      match Qpositive_le_dec x' y' with
      | left h =>
          match Qpositive_eq_dec x' y' with
          | left h => Zero
          | right h => Qneg (Qpositive_sub y' x')
          end
      | right h => Qpos (Qpositive_sub x' y')
      end
  | Qneg x', Qneg y' => Qneg (Qpositive_plus x' y')
  | Qneg x', Qpos y' =>
      match Qpositive_le_dec x' y' with
      | left h =>
          match Qpositive_eq_dec x' y' with
          | left h => Zero
          | right h => Qpos (Qpositive_sub y' x')
          end
      | right h => Qneg (Qpositive_sub x' y')
      end
  | Qneg x', Zero => Qneg x'
  | Qpos x', Zero => Qpos x'
  | Zero, x => x
  end.
 
Definition Qmult (x y : Q) :=
  match x, y with
  | Qpos x', Qpos y' => Qpos (Qpositive_mult x' y')
  | Qpos x', Qneg y' => Qneg (Qpositive_mult x' y')
  | Qneg x', Qpos y' => Qneg (Qpositive_mult x' y')
  | Qneg x', Qneg y' => Qpos (Qpositive_mult x' y')
  | _, _ => Zero
  end.
 
Definition Qopp (x : Q) :=
  match x with
  | Zero => Zero
  | Qpos x' => Qneg x'
  | Qneg x' => Qpos x'
  end.
 
Theorem Qplus_sym : forall a b : Q, Qplus a b = Qplus b a.
 
Theorem Qplus_zero_left : forall n : Q, Qplus Zero n = n.
 
Theorem add_sub_le1 :
 forall a b c : Qpositive,
 a <> b ->
 Qpositive_le b a ->
 Qpositive_le (Qpositive_sub a b) c -> Qpositive_le a (Qpositive_plus b c).
 
Theorem add_sub_le2 :
 forall a b c : Qpositive,
 a <> b ->
 Qpositive_le b a ->
 Qpositive_le a (Qpositive_plus b c) -> Qpositive_le (Qpositive_sub a b) c.
 
Theorem add_sub_eq1 :
 forall a b c : Qpositive, a = Qpositive_plus b c -> Qpositive_sub a b = c.
 
Theorem add_sub_eq2 :
 forall a b c : Qpositive,
 a <> b ->
 Qpositive_le b a -> c = Qpositive_sub a b -> Qpositive_plus b c = a.
 
Theorem Qplus_assoc_two_neg :
 forall (n : Q) (m' p' : Qpositive),
 Qplus n (Qplus (Qneg m') (Qneg p')) = Qplus (Qplus n (Qneg m')) (Qneg p').
 
Theorem Qplus_assoc_one_neg :
 forall n' m' p' : Qpositive,
 Qplus (Qpos n') (Qplus (Qpos m') (Qneg p')) =
 Qplus (Qplus (Qpos n') (Qpos m')) (Qneg p').
 
Theorem Qplus_assoc_one_neg' :
 forall (n m : Q) (p' : Qpositive),
 Qplus n (Qplus m (Qneg p')) = Qplus (Qplus n m) (Qneg p').
 
Theorem Qplus_assoc :
 forall n m p : Q, Qplus n (Qplus m p) = Qplus (Qplus n m) p. *)
Require Import FunInd.

Inductive fractionalAcc : Z -> Z -> Prop :=
  | fractionalacc0 : forall m n : Z, m = n -> fractionalAcc m n
  | fractionalacc1 :
      forall m n : Z,
      (0 < m)%Z ->
      (m < n)%Z -> fractionalAcc m (n - m)%Z -> fractionalAcc m n
  | fractionalacc2 :
      forall m n : Z,
      (0 < n)%Z ->
      (n < m)%Z -> fractionalAcc (m - n)%Z n -> fractionalAcc m n.

Lemma fractionalacc_0 : forall m : Z, fractionalAcc m m.
Proof.
 intros; apply fractionalacc0; reflexivity.
Defined.

Lemma fractionalacc_1 :
 forall m n : Z,
 fractionalAcc m n -> (0 < m)%Z -> (m < n)%Z -> fractionalAcc m (n - m).
Proof.
 simple destruct 1; intros; trivial; Falsum; apply (Z.lt_irrefl n0);
  [ rewrite H0 in H2 | apply Z.lt_trans with m0 ]; assumption.
Defined.

Lemma fractionalacc_2 :
 forall m n : Z,
 fractionalAcc m n -> (0 < n)%Z -> (n < m)%Z -> fractionalAcc (m - n) n.
Proof.
 simple destruct 1; intros; trivial; Falsum; apply (Z.lt_irrefl n0);
  [ rewrite H0 in H2 | apply Z.lt_trans with m0 ]; assumption.
Defined.

Definition encoding_algorithm :
  forall (x y : Z) (h1 : (0 < x)%Z) (h2 : (0 < y)%Z) (H : fractionalAcc x y),
  Qpositive.
fix encoding_algorithm 5.
intros x y h1 h2 H.

refine
 match Z_dec' x y with
 | inleft H_x_neq_y =>
     match H_x_neq_y with
     | left Hx_lt_y =>
         dL
           (encoding_algorithm x (y - x)%Z h1 _
              (fractionalacc_1 x y H h1 Hx_lt_y))
     | right Hy_lt_x =>
         nR
           (encoding_algorithm (x - y)%Z y _ h2
              (fractionalacc_2 x y H h2 Hy_lt_x))
     end
 | inright _ => One
 end; unfold Zminus in |- *; apply Zlt_left_lt; assumption.
Defined.

Theorem Zminus2_wf :
 forall x y : Z, (0%nat < x)%Z -> (0 < y)%Z -> fractionalAcc x y.
Proof.
 intros x y. 
 case (Z_lt_le_dec 0 x).
 intro H.
 case (Z_lt_le_dec 0 y).
 intro H2.
 apply
  Zind_wf_double
   with
     (P := fun x y : Z => (0 < x)%Z -> (0 < y)%Z -> fractionalAcc x y)
     (p0 := 1%Z)
     (q0 := 1%Z).
 intros.

 case (Z.eq_dec n m).
 intro.
 apply fractionalacc0.
 assumption.

 intro H5.
 case (not_Zeq_inf n m H5).
 intro.
 apply fractionalacc1.
 assumption.
 assumption.
 apply H1.
 split.
 apply Zplus_le_reg_l with n.
 replace (n + (m - n))%Z with m.
 change (Z.succ n <= m)%Z in |- *.
 apply Zlt_le_succ.
 assumption.
 ring.
 apply Zplus_lt_reg_l with (n - m)%Z.
 replace (n - m + (m - n))%Z with 0%Z.
 replace (n - m + m)%Z with n.
 assumption.
 ring.
 ring.
 assumption.
 unfold Zminus in |- *.
 apply Zlt_left_lt.
 assumption.
 
 intro.
 apply fractionalacc2.
 assumption.
 assumption.
 apply H0.
 change (Z.succ 0 <= m)%Z in |- *. 
 apply Zlt_le_succ.
 assumption.
 split.
 apply Zplus_le_reg_l with m.
 replace (m + (n - m))%Z with n.
 change (Z.succ m <= n)%Z in |- *.
 apply Zlt_le_succ.
 assumption.
 ring.
 apply Zplus_lt_reg_l with (m - n)%Z.
 replace (m - n + (n - m))%Z with 0%Z.
 replace (m - n + n)%Z with m.
 assumption.
 ring.
 ring.
 unfold Zminus in |- *.
 apply Zlt_left_lt.
 assumption.
 assumption.
 
 change (Z.succ 0 <= y)%Z in |- *. 
 apply Zlt_le_succ.
 assumption.
 change (Z.succ 0 <= x)%Z in |- *. 
 apply Zlt_le_succ.
 assumption.
 intros.
 absurd (y <= 0)%Z.
 apply Zgt_not_le.
 Flip.
 assumption.
 intros.
 absurd (x <= 0)%Z.
 apply Zgt_not_le.
 Flip.
 assumption.
Defined.

Definition positive_fraction_encoding (x y : Z) (Hx : (0 < x)%Z)
  (Hy : (0 < y)%Z) := encoding_algorithm x y Hx Hy (Zminus2_wf x y Hx Hy). 

Definition fraction_encoding (m n : Z) (Hn : n <> 0%Z) : Q.
intros.
set (s := (Z.sgn m * Z.sgn n)%Z) in *.
case (Z_dec s 0).
 intro.  
 case s0. 
  intro z.
  refine (Qneg (positive_fraction_encoding (Z.abs m) (Z.abs n) _ _)). 
  apply Zabs_11.
  generalize (Zorder.Zlt_not_eq _ _ z).
  intro.
  intro.
  apply H.
  unfold s in |- *.
  rewrite H0.
  simpl in |- *.
  reflexivity.
  apply Zabs_11.
  assumption.
 
  intro z.
  refine (Qpos (positive_fraction_encoding (Z.abs m) (Z.abs n) _ _)).  
  apply Zabs_11.
  generalize (Zgt_not_eq _ _ z).
  intro.
  intro.
  apply H.
  unfold s in |- *.
  rewrite H0.
  simpl in |- *.
  reflexivity.
  apply Zabs_11.
  assumption.
  
 intro.
 exact Zero.
Defined.

Ltac Irreflex :=
  try solve
   [ elimtype False;
      match goal with
      | id1:(?X1 <> ?X1) |- _ => apply id1; reflexivity
      | id1:(?X1 < ?X1)%Z |- _ =>
          apply (Z.lt_irrefl X1); assumption
      | id1:(?X1 < ?X2)%Z,id2:(?X1 = ?X2) |- _ =>
          rewrite id2 in id1; apply (Z.lt_irrefl X2); assumption
      | id1:(?X1 < ?X2)%Z,id2:(?X2 = ?X1) |- _ =>
          rewrite id2 in id1; apply (Z.lt_irrefl X1); assumption
      | id1:(?X1 < ?X2)%Z,id2:(?X2 < ?X1)%Z |- _ =>
          apply (Z.lt_irrefl X2); apply Z.lt_trans with X1; assumption
      | id1:_ |- _ => idtac
      end ]. 

Scheme fractionalAcc_ind_dep := Induction for fractionalAcc Sort Prop.

Functional Scheme encoding_algorithm_ind := Induction for encoding_algorithm Sort Prop.

Lemma encoding_algorithm_equal_1 :
 forall (a b : Z) (Ha : (0 < a)%Z) (Hb : (0 < b)%Z)
   (H1 H2 : fractionalAcc a b),
 encoding_algorithm a b Ha Hb H1 = encoding_algorithm a b Ha Hb H2.
Proof.
 intros a b Ha Hb H1 H2.
 generalize Ha Hb H2.
 clear Ha Hb H2.
 pattern a, b, H1 in |- *.
 elim H1 using fractionalAcc_ind_dep.

  intros m n e Ha Hb H3; generalize e Ha Hb; clear e Ha Hb;
   pattern m, n, H3 in |- *; elim H3 using fractionalAcc_ind_dep.

   intros; simpl in |- *; case (Z_dec' m0 n0);
    [ intros [H_falsum| H_falsum]; Irreflex | trivial ].
 
   intros; Irreflex.
 
   intros; Irreflex.

  intros m n z z0 H1' H_ind Ha Hb H3.
  generalize z z0 H1' H_ind Ha Hb. 
  clear a b H1 z z0 H_ind H1' Ha Hb.
  pattern m, n, H3 in |- *.
  elim H3 using fractionalAcc_ind_dep.

   intros; Irreflex.
 
   intros; simpl in |- *; case (Z_dec' m0 n0);
    [ intros [H11| H_falsum] | trivial ];
    [ apply f_equal with Qpositive; apply H_ind | Irreflex ].
 
   intros; simpl in |- *; case (Z_dec' m0 n0);
    [ intros [H11| H_falsum] | trivial ];
    [ apply f_equal with Qpositive; apply H_ind | Irreflex ].
    
  intros m n z z0 H1' H_ind Ha Hb H3.
  generalize z z0 H1' H_ind Ha Hb. 
  clear a b H1 z z0 H_ind H1' Ha Hb.
  pattern m, n, H3 in |- *.
  elim H3 using fractionalAcc_ind_dep.
    
   intros; Irreflex.
 
   intros; simpl in |- *; case (Z_dec' m0 n0);
    [ intros [H_falsum| H11] | trivial ];
    [ Irreflex | apply f_equal with Qpositive; apply H_ind ].

   intros; simpl in |- *; case (Z_dec' m0 n0);
    [ intros [H_falsum| H11] | trivial ];
    [ Irreflex | apply f_equal with Qpositive; apply H_ind ].
Defined.
 
Lemma encoding_algorithm_equal :
 forall (a b : Z) (Ha1 Ha2 : (0 < a)%Z) (Hb1 Hb2 : (0 < b)%Z)
   (H1 H2 : fractionalAcc a b),
 encoding_algorithm a b Ha1 Hb1 H1 = encoding_algorithm a b Ha2 Hb2 H2.
Proof.

 intros a b Ha1 Ha2 Hb1 Hb2 H1 H2.
 generalize Ha1 Hb1 Ha2 Hb2 H2.
 clear Ha1 Hb1 Ha2 Hb2 H2.
 pattern a, b, H1 in |- *.
 elim H1 using fractionalAcc_ind_dep.
   
  intros m n e Ha3 Hb3 Ha4 Hb4 H3; generalize e Ha3 Hb3 Ha4 Hb4;
   clear e Ha3 Hb3 Ha4 Hb4; pattern m, n, H3 in |- *;
   elim H3 using fractionalAcc_ind_dep.
    
   intros; simpl in |- *; case (Z_dec' m0 n0);
    [ intros [H_falsum| H_falsum]; Irreflex | trivial ].

   intros; Irreflex.
 
   intros; Irreflex.
   
  intros m n z z0 H1' H_ind Ha3 Hb3 Ha4 Hb4 H3.
  generalize z z0 H1' H_ind Ha3 Hb3 Ha4 Hb4.
  clear a b H1 z z0 H_ind H1' Ha3 Hb3 Ha4 Hb4.
  pattern m, n, H3 in |- *.
  elim H3 using fractionalAcc_ind_dep.  
   
   intros; Irreflex.
 
   intros; simpl in |- *; case (Z_dec' m0 n0);
    [ intros [H11| H_falsum] | trivial ];
    [ apply f_equal with Qpositive; apply H_ind | Irreflex ].

   intros; simpl in |- *; case (Z_dec' m0 n0);
    [ intros [H11| H_falsum] | trivial ];
    [ apply f_equal with Qpositive; apply H_ind | Irreflex ].
   
  intros m n z z0 H1' H_ind Ha3 Hb3 Ha4 Hb4 H3.
  generalize z z0 H1' H_ind Ha3 Hb3 Ha4 Hb4.
  clear a b H1 z z0 H_ind H1' Ha3 Hb3 Ha4 Hb4.
  pattern m, n, H3 in |- *.
  elim H3 using fractionalAcc_ind_dep.  
   
   intros; Irreflex.
 
   intros; simpl in |- *; case (Z_dec' m0 n0);
    [ intros [H_falsum| H11] | trivial ];
    [ Irreflex | apply f_equal with Qpositive; apply H_ind ].

   intros; simpl in |- *; case (Z_dec' m0 n0);
    [ intros [H_falsum| H11] | trivial ];
    [ Irreflex | apply f_equal with Qpositive; apply H_ind ].

Defined.

Lemma encoding_algorithm_equal_strong :
 forall (a1 a2 b1 b2 : Z) (Ha1 : (0 < a1)%Z) (Ha2 : (0 < a2)%Z)
   (Hb1 : (0 < b1)%Z) (Hb2 : (0 < b2)%Z) (H1 : fractionalAcc a1 b1)
   (H2 : fractionalAcc a2 b2),
 a1 = a2 ->
 b1 = b2 ->
 encoding_algorithm a1 b1 Ha1 Hb1 H1 = encoding_algorithm a2 b2 Ha2 Hb2 H2.
Proof.
 intros; subst; apply encoding_algorithm_equal.
Defined.

Lemma encoding_algorithm_0 :
 forall (m n : Z) (Hm : (0 < m)%Z) (Hn : (0 < n)%Z) (H : fractionalAcc m n),
 m = n -> encoding_algorithm m n Hm Hn H = One.
Proof.
 intros.
 apply
  trans_eq
   with (encoding_algorithm m m Hm Hm (fractionalacc0 m m (refl_equal m))).
 apply encoding_algorithm_equal_strong.
 reflexivity.
 symmetry  in |- *.
 assumption.
   simpl in |- *; case (Z_dec' m m);
    [ intros [H_falsum| H_falsum] | trivial ]; Irreflex. 
Defined.
 
Lemma encoding_algorithm_1 :
 forall (m n : Z) (Hm : (0 < m)%Z) (Hn : (0 < n)%Z) (H : fractionalAcc m n),
 (m < n)%Z ->
 forall (H'm : (0 < m)%Z) (H'nm : (0 < n - m)%Z)
   (H' : fractionalAcc m (n - m)),
 encoding_algorithm m n Hm Hn H =
 dL (encoding_algorithm m (n - m) H'm H'nm H'). 
Proof.
 intros.
 apply
  trans_eq with (encoding_algorithm m n Hm Hn (fractionalacc1 m n Hm H0 H')).
 apply encoding_algorithm_equal.
   simpl in |- *; case (Z_dec' m n);
    [ intros [H_11| H_falsum] | intro H_falsum ]; Irreflex;
    apply f_equal with Qpositive; apply encoding_algorithm_equal.
Defined.

Lemma encoding_algorithm_2 :
 forall (m n : Z) (Hm : (0 < m)%Z) (Hn : (0 < n)%Z) (H : fractionalAcc m n),
 (n < m)%Z ->
 forall (H'mn : (0 < m - n)%Z) (H'n : (0 < n)%Z)
   (H' : fractionalAcc (m - n) n),
 encoding_algorithm m n Hm Hn H =
 nR (encoding_algorithm (m - n) n H'mn H'n H'). 
Proof.
 intros.
 apply
  trans_eq with (encoding_algorithm m n Hm Hn (fractionalacc2 m n Hn H0 H')).
 apply encoding_algorithm_equal.
   simpl in |- *; case (Z_dec' m n);
    [ intros [H_11| H_falsum] | intro H_falsum ]; Irreflex;
    apply f_equal with Qpositive; apply encoding_algorithm_equal.
Defined.

Lemma positive_fraction_encoding_equal :
 forall (a b : Z) (Ha1 Ha2 : (0 < a)%Z) (Hb1 Hb2 : (0 < b)%Z),
 positive_fraction_encoding a b Ha1 Hb1 =
 positive_fraction_encoding a b Ha2 Hb2.
Proof.
 intros. 
 unfold positive_fraction_encoding in |- *.
 apply encoding_algorithm_equal.
Defined.

Lemma positive_fraction_encoding_equal_strong :
 forall (a1 a2 b1 b2 : Z) (Ha1 : (0 < a1)%Z) (Ha2 : (0 < a2)%Z)
   (Hb1 : (0 < b1)%Z) (Hb2 : (0 < b2)%Z),
 a1 = a2 ->
 b1 = b2 ->
 positive_fraction_encoding a1 b1 Ha1 Hb1 =
 positive_fraction_encoding a2 b2 Ha2 Hb2.
Proof.
 intros.
 unfold positive_fraction_encoding in |- *.
 apply encoding_algorithm_equal_strong.
 assumption.
 assumption.
Defined.

Lemma positive_fraction_encoding_0 :
 forall (m n : Z) (Hm : (0 < m)%Z) (Hn : (0 < n)%Z),
 m = n -> positive_fraction_encoding m n Hm Hn = One.
Proof.
 intros. 
 unfold positive_fraction_encoding in |- *.
 apply encoding_algorithm_0.
 assumption.
Defined.
 
Lemma positive_fraction_encoding_1 :
 forall (m n : Z) (Hm : (0 < m)%Z) (Hn : (0 < n)%Z),
 (m < n)%Z ->
 forall (H'm : (0 < m)%Z) (H'nm : (0 < n - m)%Z),
 positive_fraction_encoding m n Hm Hn =
 dL (positive_fraction_encoding m (n - m) H'm H'nm). 
Proof.
 intros.
 unfold positive_fraction_encoding in |- *.
 apply encoding_algorithm_1.
 assumption.
Defined.

Lemma positive_fraction_encoding_2 :
 forall (m n : Z) (Hm : (0 < m)%Z) (Hn : (0 < n)%Z),
 (n < m)%Z ->
 forall (H'mn : (0 < m - n)%Z) (H'n : (0 < n)%Z),
 positive_fraction_encoding m n Hm Hn =
 nR (positive_fraction_encoding (m - n) n H'mn H'n). 
Proof.
 intros.
 unfold positive_fraction_encoding in |- *.
 apply encoding_algorithm_2.
 assumption.
Defined.
