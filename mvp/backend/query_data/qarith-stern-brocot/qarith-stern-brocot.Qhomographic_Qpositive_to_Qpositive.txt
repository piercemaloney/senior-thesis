
Require Export general_Q.
(* general_Q:
Require Import FunInd.
Require Export Qpositive.
Require Export Q_field.
Require Export Q_order.
Require Import Field_Theory_Q. 
Require Export Zaux.

Lemma Z_of_nat_Zabs_nat_pos: forall z, (0<=z)%Z -> Z_of_nat (Z.abs_nat z) = z.

Definition make_Q (m n : Z) :=
  match m, n with
  | Zpos _, Zpos _ =>
      Qpos (Qpositive_c (Z.abs_nat m) (Z.abs_nat n) (Z.abs_nat m + Z.abs_nat n))
  | Zneg _, Zneg _ =>
      Qpos (Qpositive_c (Z.abs_nat m) (Z.abs_nat n) (Z.abs_nat m + Z.abs_nat n))
  | Z0, _ => Zero
  | _, Z0 => Zero  
  | _, _ =>
      Qneg (Qpositive_c (Z.abs_nat m) (Z.abs_nat n) (Z.abs_nat m + Z.abs_nat n))
  end.

Definition decode_Q (q : Q) :=
  match q with
  | Qpos p =>
      (Z_of_nat (fst (Qpositive_i p)), Z_of_nat (snd (Qpositive_i p)))
  | Qneg p =>
      ((- Z_of_nat (fst (Qpositive_i p)))%Z, Z_of_nat (snd (Qpositive_i p)))
  | Zero => (0%Z, 1%Z)
  end.

Definition numerator (q:Q) :Z := fst (decode_Q q).

Definition denominator (q:Q) :Z := snd (decode_Q q).

Definition Z_to_Qpositive : forall x : Z, (0 < x)%Z -> Qpositive.

Definition Z_to_Q (x : Z) : Q :=
  match x with
  | Z0 => Zero
  | Zpos p => Qpos (Qpositive_c (nat_of_P p) 1 (S (nat_of_P p)))
  | Zneg p => Qneg (Qpositive_c (nat_of_P p) 1 (S (nat_of_P p)))
  end.
 
Definition Qpositive_tail (z : Qpositive) :=
  match z with
  | nR p => p
  | dL p => p
  | One => One
  end.
 
Definition Q_tail (z : Q) :=
  match z with
  | Zero => One
  | Qpos p => p
  | Qneg p => p
  end.
 
Definition Qsgn (q : Q) :=
  match q with
  | Zero => 0%Z
  | Qpos _ => 1%Z
  | Qneg _ => (-1)%Z
  end.

Fixpoint length_of_Qpositive_to_positive (qp : Qpositive) : positive :=
  match qp with
  | One => 1%positive
  | dL qp' => Pos.succ (length_of_Qpositive_to_positive qp')
  | nR qp' => Pos.succ (length_of_Qpositive_to_positive qp')
  end.

Fixpoint length_of_Qpositive (qp : Qpositive) : Z :=
  match qp with
  | One => 0%Z
  | dL qp' => (1 + length_of_Qpositive qp')%Z
  | nR qp' => (1 + length_of_Qpositive qp')%Z
  end.

Fixpoint Qpositive_to_Z (qp : Qpositive) : Z :=
  match qp with
  | One => 1%Z
  | dL qp' => 0%Z
  | nR qp' => (1 + Qpositive_to_Z qp')%Z
  end.

Definition Q_to_Z (x : Q) : Z :=
  match x with
  | Zero => 0%Z
  | Qpos qp => Qpositive_to_Z qp
  | Qneg qp => (- Qpositive_to_Z qp)%Z
  end.

Coercion Z_to_Q : Z >-> Q.

Definition Qlt (x y : Q) : Prop := Qgt y x.

Definition Qle (x y : Q) : Prop := ~ Qlt y x. 

Lemma Qlt_zero_pos : forall x' : Qpositive, Qlt Zero (Qpos x').

Lemma Qlt_neg_pos : forall x' y' : Qpositive, Qlt (Qneg y') (Qpos x').

Lemma Qlt_neg_zero : forall x' : Qpositive, Qlt (Qneg x') Zero.

Hint Resolve Qlt_neg_pos Qlt_neg_zero Qlt_zero_pos.

Ltac QltCleanAbsurdCases :=
  match goal with
  | id1:(Qlt Zero (Qneg _)) |- _ => inversion id1
  | id1:(Qlt (Qpos _) Zero) |- _ =>
      inversion id1
  | id1:(Qlt (Qpos _) (Qneg _)) |- _ =>
      inversion id1
  | id1:(Qle Zero (Qneg _)) |- _ =>
      apply False_ind; apply id1; auto with *
  | id1:(Qle (Qpos _) Zero) |- _ =>
      apply False_ind; apply id1; auto with *
  | id1:(Qle (Qpos _) (Qneg _)) |- _ =>
      apply False_ind; apply id1; auto with *
  end.
 
Functional Scheme Qpositive_c_ind := Induction for Qpositive_c Sort Prop.

Lemma Qpositive_c_0 : forall p q n : nat, n = 0 -> Qpositive_c p q n = One.

Lemma Qpositive_c_1_0_0 :
 forall p q n' : nat, p - q = 0 -> q - p = 0 -> Qpositive_c p q (S n') = One.

Lemma Qpositive_c_equal_One :
 forall m n p : nat, m = n -> Qpositive_c m n p = One.

Lemma Qpositive_c_1_0_1 :
 forall p q n' : nat,
 p - q = 0 ->
 q - p <> 0 -> Qpositive_c p q (S n') = dL (Qpositive_c p (q - p) n').

Lemma Qpositive_c_dL :
 forall p q n' : nat,
 p < q -> Qpositive_c p q (S n') = dL (Qpositive_c p (q - p) n').

Lemma Qpositive_c_1_1 :
 forall p q n' : nat,
 p - q <> 0 -> Qpositive_c p q (S n') = nR (Qpositive_c (p - q) q n').

Lemma Qpositive_c_nR :
 forall p q n' : nat,
 q < p -> Qpositive_c p q (S n') = nR (Qpositive_c (p - q) q n').

Functional Scheme Qpositive_i_ind := Induction for Qpositive_i Sort Prop.
Lemma Qpositive_i_nR_with_let :
 forall w : Qpositive,
 let (p, q) := Qpositive_i w in Qpositive_i (nR w) = (p + q, q).

Lemma Qpositive_i_nR :
 forall (w : Qpositive) (p q : nat),
 Qpositive_i w = (p, q) -> Qpositive_i (nR w) = (p + q, q).

Lemma Qpositive_i_c :
 forall m p : nat,
 0 < m -> S m <= p -> Qpositive_i (Qpositive_c m 1 p) = (m, 1).

Lemma Qpositive_c_equal :
 forall m n p p' : nat,
 0 < m ->
 0 < n -> m + n <= p -> m + n <= p' -> Qpositive_c m n p = Qpositive_c m n p'.

Lemma Qpositive_c_equal_strong :
 forall m1 m2 n1 n2 p1 p2 : nat,
 m1 = m2 ->
 n1 = n2 ->
 0 < m1 ->
 0 < n1 ->
 m1 + n1 <= p1 ->
 m2 + n2 <= p2 -> Qpositive_c m1 n1 p1 = Qpositive_c m2 n2 p2.

Functional Scheme Qpositive_plus_ind := Induction for Qpositive_plus Sort Prop.

Lemma what_nR_does : forall p : Qpositive, nR p = Qpositive_plus p One.

Functional Scheme Qpositive_mult_ind := Induction for Qpositive_mult Sort Prop.

Lemma what_dL_does :
 forall p : Qpositive,
 dL p = Qpositive_mult p (Qpositive_inv (Qpositive_plus p One)).

Lemma Qpos_nR : forall p : Qpositive, Qpos (nR p) = Qplus (Qpos p) Qone.

Lemma Qmult_Z_nR :
 forall (a : Z) (p : Qpositive),
 Qmult (Z_to_Q a) (Qpos (nR p)) =
 Qplus (Qmult (Z_to_Q a) (Qpos p)) (Z_to_Q a).

Lemma Qpos_dL :
 forall p : Qpositive,
 Qpos (dL p) = Qmult (Qpos p) (Qinv (Qplus (Qpos p) Qone)).

Lemma Qmult_Z_dL :
 forall (a : Z) (p : Qpositive),
 Qmult (Z_to_Q a) (Qpos (dL p)) =
 Qmult (Qmult (Z_to_Q a) (Qpos p)) (Qinv (Qplus (Qpos p) Qone)).

Lemma length_of_Qpositive_is_length :
 forall p : positive,
 length_of_Qpositive (Qpositive_c (nat_of_P p) 1 (S (nat_of_P p))) =
 (Zpos p - 1)%Z.

Lemma Qpositive_to_Z_is_integer_part :
 forall x : positive,
 Qpositive_to_Z (Qpositive_c (nat_of_P x) 1 (S (nat_of_P x))) = Zpos x.
 
Lemma Q_to_Z_to_Q : forall x : Z, Q_to_Z (Z_to_Q x) = x.
  
Lemma eq_Z_to_Q : forall x y : Z, Z_to_Q x = Z_to_Q y -> x = y.

Lemma Z_to_Qpositive_equal :
 forall (m1 m2 : Z) (Hm1 : (0 < m1)%Z) (Hm2 : (0 < m2)%Z),
 m1 = m2 -> Z_to_Qpositive m1 Hm1 = Z_to_Qpositive m2 Hm2.

Functional Scheme Z_to_Q_ind := Induction for Z_to_Q Sort Prop.

Lemma Z_to_Qpositive_to_Q :
 forall (m : Z) (Hm : (0 < m)%Z), Z_to_Q m = Qpos (Z_to_Qpositive m Hm).

Lemma Qpos_injective :
 forall qp1 qp2 : Qpositive, Qpos qp1 = Qpos qp2 -> qp1 = qp2.

Lemma Qneg_injective :
 forall qp1 qp2 : Qpositive, Qneg qp1 = Qneg qp2 -> qp1 = qp2.

Lemma Q_tail_Q_pos : forall q : Q, Qlt Zero q -> q = Qpos (Q_tail q).

Lemma Q_tail_Q_neg : forall q : Q, Qlt q Zero -> q = Qneg (Q_tail q).

Lemma Qpositive_to_Z_nonneg : forall x : Qpositive, (0 <= Qpositive_to_Z x)%Z.
 
Functional Scheme Qpositive_le_bool_ind := 
  Induction for Qpositive_le_bool Sort Prop.

Lemma Qpositive_to_Z_Qpositive_le :
 forall x y : Qpositive,
 (Qpositive_to_Z x < Qpositive_to_Z y)%Z -> Qpositive_le x y.

Lemma Q_to_Z_monotone : forall x y : Q, Qlt x y -> (Q_to_Z x <= Q_to_Z y)%Z.

Lemma Qlt_irreflexive : forall x : Q, ~ Qlt x x.

Hint Resolve Qlt_irreflexive.

Lemma Qlt_not_eq : forall x y : Q, Qlt x y -> y <> x.

Hint Resolve Qlt_not_eq.

Lemma Qlt_transitive : forall x y z : Q, Qlt x y -> Qlt y z -> Qlt x z.

Lemma Z_to_Qopp : forall x : Z, Z_to_Q (- x) = Qopp (Z_to_Q x).

Lemma Z_to_Qplus_POS :
 forall p1 p2 : positive,
 Z_to_Q (Zpos p1 + Zpos p2) = Qplus (Z_to_Q (Zpos p1)) (Z_to_Q (Zpos p2)).

Lemma Z_to_Qplus_POS_NEG :
 forall p1 p2 : positive,
 Z_to_Q (Zpos p1 + Zneg p2) = Qplus (Z_to_Q (Zpos p1)) (Z_to_Q (Zneg p2)).
 
Lemma Z_to_Qplus_NEG :
 forall p1 p2 : positive,
 Z_to_Q (Zneg p1 + Zneg p2) = Qplus (Z_to_Q (Zneg p1)) (Z_to_Q (Zneg p2)).

Lemma Z_to_Qplus :
 forall x y : Z, Z_to_Q (x + y) = Qplus (Z_to_Q x) (Z_to_Q y).

Lemma Z_to_Qminus :
 forall x y : Z, Z_to_Q (x - y) = Qminus (Z_to_Q x) (Z_to_Q y).

Lemma Z_to_Qmult_POS :
 forall p1 p2 : positive,
 Z_to_Q (Zpos p1 * Zpos p2) = Qmult (Z_to_Q (Zpos p1)) (Z_to_Q (Zpos p2)).

Lemma Z_to_Qmult_POS_NEG :
 forall p1 p2 : positive,
 Z_to_Q (Zpos p1 * Zneg p2) = Qmult (Z_to_Q (Zpos p1)) (Z_to_Q (Zneg p2)).

Lemma Z_to_Qmult_NEG :
 forall p1 p2 : positive,
 Z_to_Q (Zneg p1 * Zneg p2) = Qmult (Z_to_Q (Zneg p1)) (Z_to_Q (Zneg p2)).

Lemma Z_to_Qmult :
 forall x y : Z, Z_to_Q (x * y) = Qmult (Z_to_Q x) (Z_to_Q y).

Lemma Z_to_Q_S:forall k, Z_to_Q (Z_of_nat (S k))=Qplus k Qone.

Lemma Z_to_Q_min_one:Z_to_Q (-1)%Z= Qopp Qone.

Lemma Qlt_Zero_Qminus : forall x y : Q, Qlt Zero (Qminus y x) -> Qlt x y. 

Lemma Z_to_Qlt : forall x y : Z, (x < y)%Z -> Qlt x y.

Lemma lt_Z_to_Q : forall x y : Z, Qlt (Z_to_Q x) (Z_to_Q y) -> (x < y)%Z.
 
Lemma pos_Z_to_Q : forall x : Z, Qlt Zero (Z_to_Q x) -> (0 < x)%Z.

Lemma neg_Z_to_Q : forall x : Z, Qlt (Z_to_Q x) Zero -> (x < 0)%Z.

Lemma Qlt_le_weak : forall x y : Q, Qlt x y -> Qle x y.

Lemma Z_to_Qle : forall x y : Z, (x <= y)%Z -> Qle x y.

Lemma Z_to_Q_pos : forall x : Z, (0 < x)%Z -> Qlt Zero x.

Lemma Z_to_Q_neg : forall x : Z, (x < 0)%Z -> Qlt x Zero.

Lemma Z_to_Q_nonneg : forall x : Z, (0 <= x)%Z -> Qle Zero x.

Lemma Z_to_Q_nonpos : forall x : Z, (x <= 0)%Z -> Qle x Zero.

Lemma Z_to_Q_not_eq : forall a b : Z, a <> b -> Z_to_Q a <> Z_to_Q b.

Lemma Qmult_Z_plus_Z_dL :
 forall (a b : Z) (p : Qpositive),
 Qplus (Qmult (Z_to_Q a) (Qpos (dL p))) (Z_to_Q b) =
 Qmult (Qplus (Qmult (Z_to_Q (a + b)) (Qpos p)) (Z_to_Q b))
   (Qinv (Qplus (Qpos p) Qone)).

Lemma Qinv_0 : forall q : Q, Qinv q = Zero -> q = Zero. 

Lemma Qmult_resp_nonzero :
 forall x y : Q, x <> Zero -> y <> Zero -> Qmult x y <> Zero.

Hint Resolve Qmult_resp_nonzero.

Lemma Qlt_mult_pos_pos :
 forall x y : Q, Qlt Zero x -> Qlt Zero y -> Qlt Zero (Qmult x y).

Lemma Qlt_mult_neg_pos :
 forall x y : Q, Qlt x Zero -> Qlt Zero y -> Qlt (Qmult x y) Zero.

Hint Resolve Qlt_mult_pos_pos Qlt_mult_neg_pos.

Lemma Qlt_plus_pos_pos :
 forall x y : Q, Qlt Zero x -> Qlt Zero y -> Qlt Zero (Qplus x y).

Hint Resolve Qlt_plus_pos_pos.

Lemma Qdiv_num_denom :
 forall q1 q2 p : Q,
 p <> Zero -> Qmult q1 (Qinv q2) = Qmult (Qmult q1 p) (Qinv (Qmult q2 p)).

Lemma Qinv_1 : forall q : Q, Qlt Zero (Qinv q) -> Qlt Zero q.

Lemma Qinv_2 : forall q : Q, Qlt (Qinv q) Zero -> Qlt q Zero.

Lemma Qinv_pos : forall q : Q, Qlt Zero q -> Qlt Zero (Qinv q).

Lemma Qmult_one_right : forall x : Q, Qmult x Qone = x.

Lemma Qpos_POS_1 :
 forall (m : Z) (qp : Qpositive), Z_to_Q m = Qpos qp -> (0 < m)%Z.

Lemma Qneg_NEG_1 :
 forall (m : Z) (qp : Qpositive), Z_to_Q m = Qneg qp -> (m < 0)%Z.

Lemma Qopp_Qpos : forall q : Qpositive, Qneg q = Qopp (Qpos q).

Lemma Qopp_Qneg : forall q : Qpositive, Qpos q = Qopp (Qneg q).

Lemma Qopp_linear :
 forall (a b : Z) (q : Qpositive),
 Qplus (Qmult (Z_to_Q (- a)) (Qpos q)) (Z_to_Q (- b)) =
 Qopp (Qplus (Qmult (Z_to_Q a) (Qpos q)) (Z_to_Q b)).

Lemma Qopp_resp_nonzero : forall x : Q, x <> Zero -> Qopp x <> Zero.

Lemma Qinv_Qopp : forall q : Q, Qinv (Qopp q) = Qopp (Qinv q).

Lemma Qmult_Qopp_left : forall x y : Q, Qmult (Qopp x) y = Qopp (Qmult x y).

Lemma Qpositive_dec_One : forall p : Qpositive, {p = One} + {p <> One}.

Lemma Q_zerop : forall x : Q, {x = Zero} + {x <> Zero}.
 
Lemma Qinv_resp_nonzero : forall x : Q, x <> Zero -> Qinv x <> Zero.

Lemma Qlt_zero_one : Qlt Zero Qone.

Hint Resolve Qlt_zero_one.

Lemma Z_to_Qpositive_Q_tail_pos :
 forall (a : Z) (Ha : (0 < a)%Z), Z_to_Qpositive a Ha = Q_tail a.

Lemma Q_tail_Qinv : forall x : Q, Q_tail (Qinv x) = Qpositive_inv (Q_tail x).

Lemma Q_tail_Qmult :
 forall x y : Q,
 x <> Zero ->
 y <> Zero -> Q_tail (Qmult x y) = Qpositive_mult (Q_tail x) (Q_tail y). 

Lemma Q_tail_Qplus_pos :
 forall x y : Q,
 Qlt Zero x ->
 Qlt Zero y -> Q_tail (Qplus x y) = Qpositive_plus (Q_tail x) (Q_tail y). 

Lemma Q_tail_Qplus_neg :
 forall x y : Q,
 Qlt x Zero ->
 Qlt y Zero -> Q_tail (Qplus x y) = Qpositive_plus (Q_tail x) (Q_tail y). 

Lemma Qplus_zero_right : forall n : Q, Qplus n Zero = n.

Lemma Qmult_zero_right : forall x : Q, Qmult x Zero = Zero.

Lemma Qle_Qpositive_le_pos :
 forall x y : Qpositive, Qle (Qpos x) (Qpos y) -> Qpositive_le x y.

Lemma Qle_Qpositive_le_neg :
 forall x y : Qpositive, Qle (Qneg x) (Qneg y) -> Qpositive_le y x.

Lemma Qle_lt_eq_dec : forall x y : Q, Qle x y -> {Qlt x y} + {x = y}.

Lemma Qle_lt_trans : forall x y z : Q, Qle x y -> Qlt y z -> Qlt x z.

Lemma Qlt_le_trans : forall x y z : Q, Qlt x y -> Qle y z -> Qlt x z.

Lemma Qle_trans : forall x y z : Q, Qle x y -> Qle y z -> Qle x z.

Lemma Qlt_plus_plus :
 forall a b c d : Q, Qlt a b -> Qlt c d -> Qlt (Qplus a c) (Qplus b d).

Lemma Qle_lt_reg :
 forall a b c d : Q, Qle a b -> Qlt c d -> Qlt (Qplus a c) (Qplus b d).

Lemma Qlt_le_reg :
 forall a b c d : Q, Qlt a b -> Qle c d -> Qlt (Qplus a c) (Qplus b d).

Lemma Qlt_le_reg_pos :
 forall b d : Q, Qlt Zero b -> Qle Zero d -> Qlt Zero (Qplus b d).

Lemma Qle_lt_reg_pos :
 forall b d : Q, Qle Zero b -> Qlt Zero d -> Qlt Zero (Qplus b d).

Lemma Qlt_le_reg_neg :
 forall b d : Q, Qlt b Zero -> Qle d Zero -> Qlt (Qplus b d) Zero.
 
Lemma Qle_lt_reg_neg :
 forall b d : Q, Qle b Zero -> Qlt d Zero -> Qlt (Qplus b d) Zero.

Lemma Qle_plus_plus :
 forall a b c d : Q, Qle a b -> Qle c d -> Qle (Qplus a c) (Qplus b d).

Lemma Qle_plus_pos_pos :
 forall x y : Q, Qle Zero x -> Qle Zero y -> Qle Zero (Qplus x y).

Lemma Qle_plus_neg_neg :
 forall x y : Q, Qle x Zero -> Qle y Zero -> Qle (Qplus x y) Zero.

Lemma Qle_mult_nonneg_nonneg :
 forall x y : Q, Qle Zero x -> Qle Zero y -> Qle Zero (Qmult x y).

Lemma Qle_mult_nonpos_nonneg :
 forall x y : Q, Qle x Zero -> Qle Zero y -> Qle (Qmult x y) Zero.

Lemma Qle_mult_nonneg_nonpos :
 forall x y : Q, Qle Zero x -> Qle y Zero -> Qle (Qmult x y) Zero.

Lemma Qle_mult_nonpos_pos:
 forall x y : Q, Qle x Zero -> Qlt Zero y -> Qle (Qmult x y) Zero.

Lemma Qle_mult_neg_nonneg :
 forall x y : Q, Qlt x Zero -> Qle Zero y -> Qle (Qmult x y) Zero.

Lemma Qle_reflexive:forall x, Qle x x.

Hint Resolve Qplus_zero_right Qlt_le_reg_pos Qle_lt_reg_pos Qlt_le_reg
  Qle_lt_reg Qlt_le_weak Qlt_le_reg_neg Qle_lt_reg_neg Qle_plus_pos_pos
  Qle_plus_neg_neg Qle_mult_nonneg_nonneg Qle_mult_nonneg_nonpos
  Qle_mult_nonpos_nonneg Qle_mult_nonpos_pos Qle_mult_neg_nonneg
  Qle_reflexive.

Lemma Qpos_not_lt_Zero : forall x, ~ Qlt (Qpos x) Zero.

Lemma Qlt_dec_Qpos : forall x y, {~ Qlt (Qpos y) (Qpos x)} + {Qlt (Qpos y) (Qpos x)}.

Lemma Zero_not_lt_Qneg : forall x, ~ Qlt Zero (Qneg x).

Lemma Qpos_not_lt_Qneg : forall x y, ~ Qlt (Qpos y) (Qneg x).

Lemma Qlt_dec_Qneg : forall x y, {~ Qlt (Qneg y) (Qneg x)} + {Qlt (Qneg y) (Qneg x)}.

Lemma Q_le_lt_dec:forall (x y:Q), {Qle x y}+{Qlt y x}.

Lemma Qle_dec:forall (x y:Q), {Qle x y}+{~(Qle x y)}.

Lemma Qlt_dec:forall (x y:Q), {Qlt x y}+{~(Qlt x y)}.

Lemma Qtrichotomy_inf:forall x y,{Qlt x y}+{x=y}+{Qlt y x}.

Lemma Qle_dec_weak:forall (x y:Q), {Qle x y}+{(Qle y x)}.

Lemma not_Qeq_inf : forall x y : Q, x <> y -> {Qlt x y} + {Qlt y x}.

Lemma Qlt_stepl:forall x y z, Qlt x y -> x=z -> Qlt z y.

Lemma Qlt_stepr:forall x y z, Qlt x y -> y=z -> Qlt x z.

Lemma Qle_stepl:forall x y z, Qle x y -> x=z -> Qle z y.

Lemma Qle_stepr:forall x y z, Qle x y -> y=z -> Qle x z.

Lemma Qneq_stepl:forall (x y z:Q), x<>y -> x=z -> z<>y.

Lemma Qneq_stepr:forall (x y z:Q), x<>y -> y=z -> x<>z.

Declare Left Step Qlt_stepl.
Declare Right Step Qlt_stepr.
Declare Left Step Qle_stepl.
Declare Right Step Qle_stepr.
Declare Left Step Qneq_stepl.
Declare Right Step Qneq_stepr.

Lemma Qsgn_1: forall x:Q,{(Qsgn x) = 0}+{(Qsgn x) = 1}+{(Qsgn x) = (-1)%Z}. 

Lemma Qsgn_2 : forall x : Q, Qsgn x = 0%Z -> x = Zero.

Lemma Qsgn_7 : forall x : Q, Qlt Zero x -> Qsgn x = 1%Z.

Lemma Qsgn_8 : forall x : Q, Qlt x Zero -> Qsgn x = (-1)%Z.

Lemma Qsgn_9 : forall x : Q, Qsgn x = 1%Z -> Qlt Zero x.

Lemma Qsgn_10 : forall x : Q, Qsgn x = (-1)%Z -> Qlt x Zero.

Lemma Qsgn_15 : forall x y : Q, Qsgn (Qmult x y) = (Qsgn x * Qsgn y)%Z.
 
Lemma Qsgn_25 : forall x : Q, Qsgn (Qopp x) = (- Qsgn x)%Z.

Lemma Qsgn_28 : forall x : Q, Qsgn (Qinv x) = Qsgn x.

Lemma Qsgn_29 : forall x : Z, Qsgn (Z_to_Q x) = Z.sgn x. 

Lemma Qsgn_30 : forall x y : Q, Qsgn (Qdiv x y) = (Qsgn x * Qsgn y)%Z.

Lemma Qsgn_31:forall x:Q, Qle x Zero-> Qsgn x <> 1.

Lemma Qsgn_32:forall x:Q, Qsgn x <> 1 -> Qle x  Zero.

Lemma Qsgn_33:forall x:Q, Qle Zero x -> Qsgn x <> (-1)%Z.

Lemma Qsgn_34:forall x:Q, Qsgn x <> (-1)%Z -> Qle Zero x.

Hint Resolve Qsgn_2 Qsgn_7 Qsgn_8 Qsgn_9 Qsgn_10 Qsgn_15 Qsgn_25 Qsgn_28
  Qsgn_29 Qsgn_30.

Ltac qnat_zero :=  replace (Z_to_Q (Z_of_nat 0)) with Zero;  trivial.
Ltac natq_zero :=  replace Zero with (Z_to_Q (Z_of_nat 0));  trivial.
Ltac qnat_one :=  replace (Z_to_Q (Z_of_nat (S 0))) with Qone;  trivial.
Ltac natq_one :=  replace Qone with (Z_to_Q (Z_of_nat (S 0)));  trivial.
Ltac qnat_S k :=  replace (Z_to_Q (Z_of_nat (S k))) with (Qplus k Qone); [idtac | rewrite Z_to_Q_S; trivial].
Ltac natq_S k :=  try qnat_one; replace (Qplus k Qone) with (Z_to_Q (Z_of_nat (S k))); [idtac | rewrite <- Z_to_Q_S; trivial].
Ltac qnat_S_rec k :=  
             try qnat_one; replace (Qplus k Qone) with (Z_to_Q (Z_of_nat (S k))); [idtac | rewrite <- Z_to_Q_S; trivial];
             try qnat_S_rec (k-1).

Ltac natZ_numerals  := 
 match goal with 
 | [ |- context [Z0] ] => replace Z0 with (Z_of_nat O); trivial; natZ_numerals
 | [ |- context [(Zpos ?X1)] ] => let v:= eval compute in (Z.abs_nat (Z.pred (Zpos X1))) in 
         replace (Zpos X1) with (Z_of_nat (S v)); trivial; natZ_numerals
 | [ |- context [(Zneg ?X1)] ] => let v:= eval compute in (Z.abs_nat (Z.succ (Zpos X1))) in 
         replace (Zneg X1) with (Z.opp (Z_of_nat (S v))); trivial; natZ_numerals
 | [ |- _ ] => idtac
 end. *)
Require Export positive_fraction_encoding.
(* positive_fraction_encoding:
Require Export Zaux.
Require Import ZArithRing.
Require Export Qpositive.
Require Export Q_field.
Require Import FunInd.

Inductive fractionalAcc : Z -> Z -> Prop :=
  | fractionalacc0 : forall m n : Z, m = n -> fractionalAcc m n
  | fractionalacc1 :
      forall m n : Z,
      (0 < m)%Z ->
      (m < n)%Z -> fractionalAcc m (n - m)%Z -> fractionalAcc m n
  | fractionalacc2 :
      forall m n : Z,
      (0 < n)%Z ->
      (n < m)%Z -> fractionalAcc (m - n)%Z n -> fractionalAcc m n.

Lemma fractionalacc_0 : forall m : Z, fractionalAcc m m.

Lemma fractionalacc_1 :
 forall m n : Z,
 fractionalAcc m n -> (0 < m)%Z -> (m < n)%Z -> fractionalAcc m (n - m).

Lemma fractionalacc_2 :
 forall m n : Z,
 fractionalAcc m n -> (0 < n)%Z -> (n < m)%Z -> fractionalAcc (m - n) n.

Definition encoding_algorithm :
  forall (x y : Z) (h1 : (0 < x)%Z) (h2 : (0 < y)%Z) (H : fractionalAcc x y),
  Qpositive.

Theorem Zminus2_wf :
 forall x y : Z, (0%nat < x)%Z -> (0 < y)%Z -> fractionalAcc x y.

Definition positive_fraction_encoding (x y : Z) (Hx : (0 < x)%Z)
  (Hy : (0 < y)%Z) := encoding_algorithm x y Hx Hy (Zminus2_wf x y Hx Hy). 

Definition fraction_encoding (m n : Z) (Hn : n <> 0%Z) : Q.

Ltac Irreflex :=
  try solve
   [ elimtype False;
      match goal with
      | id1:(?X1 <> ?X1) |- _ => apply id1; reflexivity
      | id1:(?X1 < ?X1)%Z |- _ =>
          apply (Z.lt_irrefl X1); assumption
      | id1:(?X1 < ?X2)%Z,id2:(?X1 = ?X2) |- _ =>
          rewrite id2 in id1; apply (Z.lt_irrefl X2); assumption
      | id1:(?X1 < ?X2)%Z,id2:(?X2 = ?X1) |- _ =>
          rewrite id2 in id1; apply (Z.lt_irrefl X1); assumption
      | id1:(?X1 < ?X2)%Z,id2:(?X2 < ?X1)%Z |- _ =>
          apply (Z.lt_irrefl X2); apply Z.lt_trans with X1; assumption
      | id1:_ |- _ => idtac
      end ]. 

Scheme fractionalAcc_ind_dep := Induction for fractionalAcc Sort Prop.

Functional Scheme encoding_algorithm_ind := Induction for encoding_algorithm Sort Prop.

Lemma encoding_algorithm_equal_1 :
 forall (a b : Z) (Ha : (0 < a)%Z) (Hb : (0 < b)%Z)
   (H1 H2 : fractionalAcc a b),
 encoding_algorithm a b Ha Hb H1 = encoding_algorithm a b Ha Hb H2.
 
Lemma encoding_algorithm_equal :
 forall (a b : Z) (Ha1 Ha2 : (0 < a)%Z) (Hb1 Hb2 : (0 < b)%Z)
   (H1 H2 : fractionalAcc a b),
 encoding_algorithm a b Ha1 Hb1 H1 = encoding_algorithm a b Ha2 Hb2 H2.

Lemma encoding_algorithm_equal_strong :
 forall (a1 a2 b1 b2 : Z) (Ha1 : (0 < a1)%Z) (Ha2 : (0 < a2)%Z)
   (Hb1 : (0 < b1)%Z) (Hb2 : (0 < b2)%Z) (H1 : fractionalAcc a1 b1)
   (H2 : fractionalAcc a2 b2),
 a1 = a2 ->
 b1 = b2 ->
 encoding_algorithm a1 b1 Ha1 Hb1 H1 = encoding_algorithm a2 b2 Ha2 Hb2 H2.

Lemma encoding_algorithm_0 :
 forall (m n : Z) (Hm : (0 < m)%Z) (Hn : (0 < n)%Z) (H : fractionalAcc m n),
 m = n -> encoding_algorithm m n Hm Hn H = One.
 
Lemma encoding_algorithm_1 :
 forall (m n : Z) (Hm : (0 < m)%Z) (Hn : (0 < n)%Z) (H : fractionalAcc m n),
 (m < n)%Z ->
 forall (H'm : (0 < m)%Z) (H'nm : (0 < n - m)%Z)
   (H' : fractionalAcc m (n - m)),
 encoding_algorithm m n Hm Hn H =
 dL (encoding_algorithm m (n - m) H'm H'nm H'). 

Lemma encoding_algorithm_2 :
 forall (m n : Z) (Hm : (0 < m)%Z) (Hn : (0 < n)%Z) (H : fractionalAcc m n),
 (n < m)%Z ->
 forall (H'mn : (0 < m - n)%Z) (H'n : (0 < n)%Z)
   (H' : fractionalAcc (m - n) n),
 encoding_algorithm m n Hm Hn H =
 nR (encoding_algorithm (m - n) n H'mn H'n H'). 

Lemma positive_fraction_encoding_equal :
 forall (a b : Z) (Ha1 Ha2 : (0 < a)%Z) (Hb1 Hb2 : (0 < b)%Z),
 positive_fraction_encoding a b Ha1 Hb1 =
 positive_fraction_encoding a b Ha2 Hb2.

Lemma positive_fraction_encoding_equal_strong :
 forall (a1 a2 b1 b2 : Z) (Ha1 : (0 < a1)%Z) (Ha2 : (0 < a2)%Z)
   (Hb1 : (0 < b1)%Z) (Hb2 : (0 < b2)%Z),
 a1 = a2 ->
 b1 = b2 ->
 positive_fraction_encoding a1 b1 Ha1 Hb1 =
 positive_fraction_encoding a2 b2 Ha2 Hb2.

Lemma positive_fraction_encoding_0 :
 forall (m n : Z) (Hm : (0 < m)%Z) (Hn : (0 < n)%Z),
 m = n -> positive_fraction_encoding m n Hm Hn = One.
 
Lemma positive_fraction_encoding_1 :
 forall (m n : Z) (Hm : (0 < m)%Z) (Hn : (0 < n)%Z),
 (m < n)%Z ->
 forall (H'm : (0 < m)%Z) (H'nm : (0 < n - m)%Z),
 positive_fraction_encoding m n Hm Hn =
 dL (positive_fraction_encoding m (n - m) H'm H'nm). 

Lemma positive_fraction_encoding_2 :
 forall (m n : Z) (Hm : (0 < m)%Z) (Hn : (0 < n)%Z),
 (n < m)%Z ->
 forall (H'mn : (0 < m - n)%Z) (H'n : (0 < n)%Z),
 positive_fraction_encoding m n Hm Hn =
 nR (positive_fraction_encoding (m - n) n H'mn H'n). *)
Require Import Merge_Order.
(* Merge_Order:
Section General_Order.
Variable S : Set.
Variable O : S -> S -> Prop.
Variable E : S -> S -> Prop.

Definition is_order :=
  (forall x : S, ~ O x x) /\ (forall x y z : S, O x y -> O y z -> O x z).

Definition wf_ind :=
  forall P : S -> Prop,
  (forall q : S, (forall r : S, O r q -> P r) -> P q) -> forall q : S, P q.

Definition is_equality :=
  (forall x : S, E x x) /\
  (forall x y : S, E x y -> E y x) /\
  (forall x y z : S, E x y -> E y z -> E x z).

Definition is_well_def_rht :=
  forall x y : S, O x y -> forall z : S, E y z -> O x z.

Definition is_well_def_lft :=
  forall x y : S, O x y -> forall z : S, E x z -> O z y.

End General_Order.

Record well_ordering : Type := 
  {wfcrr :> Set;
   order : wfcrr -> wfcrr -> Prop;
   equality : wfcrr -> wfcrr -> Prop;
   is_ord : is_order wfcrr order;
   is_eq : is_equality wfcrr equality;
   ord_is_wf : wf_ind wfcrr order;
   ord_wd_rht : is_well_def_rht wfcrr order equality}.

Section Negation_Order.
Variable S : well_ordering.

Let O := order S.

Lemma order_lt_le_weak : forall n m : S, O m n -> ~ O n m.

End Negation_Order.

Section Merge_Order.

Variable S1 S2 : well_ordering.
Let O1 := order S1.
Let O2 := order S2.
Let E1 := equality S1.
Let E2 := equality S2.

Definition merge_lt (x1 : S1) (p1 : S2) (x2 : S1) (p2 : S2) :=
  O1 x1 x2 \/ E1 x1 x2 /\ O2 p1 p2.

Definition merge_le (x1 : S1) (p1 : S2) (x2 : S1) (p2 : S2) :=
  merge_lt x1 p1 x2 p2 \/ E1 x1 x2 /\ E2 p1 p2.

Let S1ind_wf := ord_is_wf S1.
Let S2ind_wf := ord_is_wf S2.

Lemma merge_lt_wf :
 forall P : S1 -> S2 -> Prop,
 (forall (q : S1) (t : S2),
  (forall (r : S1) (u : S2), merge_lt r u q t -> P r u) -> P q t) ->
 forall (x : S1) (p : S2), P x p.

End Merge_Order. *)
Require Import Wf_nat.

Definition top_more (a b c d : Z) :=
  (c <= a)%Z /\ (d < b)%Z \/ (c < a)%Z /\ (d <= b)%Z.

Lemma top_more_informative :
 forall a b c d : Z, {top_more a b c d} + {~ top_more a b c d}.
Proof.
 intros.
 case (quadro_leq_inf a b c d). 
 intro.
 elim a0.
 intros. 
 case (Z_le_lt_eq_dec c a H).
 intro. 
 left.
 right.
 split.
 assumption.
 assumption.
 intro. 
 case (Z_le_lt_eq_dec d b H0).
 intro.
 left.
 left.
 split.
 assumption.
 assumption.
 intro.
 right.  
 intro.
 case H1.
 intro.
 elim H2.
 intros.
 rewrite e0 in H4.
 apply (Zgt_irrefl b).
 Flip.
 intro.
 elim H2.
 intros.
 rewrite e in H3.
 apply (Zgt_irrefl a).
 Flip.

 unfold top_more in |- *. 
 intro.
 right.
 intro.
 case H.
 intro. 
 apply n.
 elim H0. 
 intros.
 split.
 assumption.
 apply Zlt_le_weak. 
 assumption.
 intro.
 apply n.
 elim H0. 
 intros.
 split.
 apply Zlt_le_weak.
 assumption.
 assumption. 
Defined.

Lemma top_more_1 :
 forall a b c d : Z, top_more a b c d -> (0 < a - c + (b - d))%Z.
Proof.
 intros.
 case H.
 intros.
 elim H0.
 intros.
 replace 0%Z with (0 + 0)%Z.
 apply Zplus_le_lt_compat.
 unfold Zminus in |- *.
 apply Zle_left.
 assumption.
 apply Zlt_minus.
 assumption.    
 constructor.
 intro.
 elim H0.   
 intros.
 replace 0%Z with (0 + 0)%Z.
 apply Zplus_lt_le_compat.
 apply Zlt_minus.
 assumption.
 unfold Zminus in |- *.
 apply Zle_left.
 assumption.
 constructor.
Defined.

Lemma top_more_2 : forall a b c d : Z, top_more a b c d -> (c + d < a + b)%Z.
Proof. 
 intros.
 case H.
 intros.
 elim H0.
 intros.
 apply Zplus_le_lt_compat. 
 assumption.
 assumption.
 intros.
 elim H0.
 intros.
 apply Zplus_lt_le_compat. 
 assumption.
 assumption.
Defined.

Lemma top_more_3 :
 forall a b c d : Z, (0 < c + d)%Z -> (a - c + (b - d) < a + b)%Z.
Proof.
 intros.
 apply Zplus_lt_reg_l with (c + d)%Z.
 apply Zplus_lt_reg_l with (- a - b)%Z.
 replace (- a - b + (c + d + (a - c + (b - d))))%Z with 0%Z.
 replace (- a - b + (c + d + (a + b)))%Z with (c + d)%Z.
 assumption.
 ring.
 ring.
Defined.

Lemma top_more_4 : forall a b c d : Z, top_more a b c d -> (c <= a)%Z.
Proof. 
 intros.
 case H.
 intros.
 elim H0.
 intros.
 assumption.
 intros.
 elim H0.
 intros.
 apply Zlt_le_weak.
 assumption.
Defined.

Lemma top_more_4' : forall a b c d : Z, top_more a b c d -> (d <= b)%Z.
Proof. 
 intros.
 case H.
 intros.
 elim H0.
 intros.
 apply Zlt_le_weak.
 assumption.
 intros.
 elim H0.
 intros.
 assumption.
Defined.

Lemma top_more_5 :
 forall a b c d : Z,
 (0 < c + d)%Z -> (a - c + (b - d) + c + d < a + b + c + d)%Z.
Proof.
 intros.
 assert ((a - c + (b - d) + c + d)%Z = (a + b + 0)%Z).
 ring.
 rewrite H0.
 rewrite Zplus_assoc_reverse with (n := (a + b)%Z).
 apply Zplus_le_lt_compat.  
 apply Z.le_refl.
 assumption.
Defined.

Lemma top_more_5' :
 forall a b c d : Z,
 (0 < a + b)%Z -> (a + b + (c - a) + (d - b) < a + b + c + d)%Z.
Proof.
 intros.
 assert ((a + b + (c - a) + (d - b))%Z = (0 + (c + d))%Z).
 ring.
 rewrite H0.
 rewrite Zplus_assoc_reverse with (n := (a + b)%Z).
 apply Zplus_lt_le_compat.  
 assumption.
 apply Z.le_refl.
Defined.

Inductive homographicAcc : Z -> Z -> Z -> Z -> Qpositive -> Prop :=
  | homographicacc0 :
      forall (a b c d : Z) (p : Qpositive),
      p = One -> (0 < a + b)%Z -> (0 < c + d)%Z -> homographicAcc a b c d p
  | homographicacc1 :
      forall (a b c d : Z) (p : Qpositive),
      p <> One ->
      top_more a b c d ->
      homographicAcc (a - c)%Z (b - d)%Z c d p -> homographicAcc a b c d p
  | homographicacc2 :
      forall (a b c d : Z) (p : Qpositive),
      p <> One ->
      ~ top_more a b c d ->
      top_more c d a b ->
      homographicAcc a b (c - a)%Z (d - b)%Z p -> homographicAcc a b c d p
  | homographicacc3 :
      forall (a b c d : Z) (xs : Qpositive),
      ~ top_more a b c d ->
      ~ top_more c d a b ->
      homographicAcc a (a + b)%Z c (c + d)%Z xs ->
      homographicAcc a b c d (nR xs)
  | homographicacc3' :
      forall (a b c d : Z) (xs : Qpositive),
      ~ top_more a b c d ->
      ~ top_more c d a b ->
      homographicAcc (a + b)%Z b (c + d)%Z d xs ->
      homographicAcc a b c d (dL xs).

Lemma homographicacc_0_num :
 forall a b c d : Z, homographicAcc a b c d One -> (0 < a + b)%Z.
Proof.
 intros.
 abstract (inversion H; trivial; Irreflex; discriminate H0).
Defined.

Lemma homographicacc_0_denom :
 forall a b c d : Z, homographicAcc a b c d One -> (0 < c + d)%Z.
Proof.
 intros.
 abstract (inversion H; trivial; Irreflex; discriminate H0).
Defined.

Lemma homographicacc_1 :
 forall (a b c d : Z) (p : Qpositive),
 homographicAcc a b c d p ->
 p <> One -> top_more a b c d -> homographicAcc (a - c) (b - d) c d p.
Proof.
 simple destruct 1; intros; trivial; Falsum.
Defined.  

Lemma homographicacc_2 :
 forall (a b c d : Z) (p : Qpositive),
 homographicAcc a b c d p ->
 p <> One ->
 ~ top_more a b c d ->
 top_more c d a b -> homographicAcc a b (c - a) (d - b) p.
Proof.
 simple destruct 1; intros; trivial; Falsum.
Defined.  

Lemma homographicacc_3 :
 forall (a b c d : Z) (p : Qpositive),
 homographicAcc a b c d p ->
 forall xs : Qpositive,
 p = nR xs ->
 ~ top_more a b c d ->
 ~ top_more c d a b -> homographicAcc a (a + b) c (c + d) xs.
Proof.
 intros a b c d p HAcc; case HAcc; intros; try solve [ Falsum ];
  [ rewrite H2 in H; clear H2; discriminate H
  | let T_local := eval compute in (f_equal Qpositive_tail H2) in
    (rewrite <- T_local; assumption)
  | discriminate H2 ].
Defined.  

Lemma homographicacc_3' :
 forall (a b c d : Z) (p : Qpositive),
 homographicAcc a b c d p ->
 forall xs : Qpositive,
 p = dL xs ->
 ~ top_more a b c d ->
 ~ top_more c d a b -> homographicAcc (a + b) b (c + d) d xs.
Proof.
 intros a b c d p HAcc xs.
 case HAcc; intros; try solve [ Falsum ];
  [ rewrite H2 in H; clear H2; discriminate H
  | discriminate H2
  | let T_local := eval compute in (f_equal Qpositive_tail H2) in
    (rewrite <- T_local; assumption) ].
Defined.  

Fixpoint Qhomographic_Qpositive_to_Qpositive (a b c d : Z) 
 (p : Qpositive) (hyp : homographicAcc a b c d p) {struct hyp} : Qpositive :=
  match Qpositive_dec_One p with
  | left H_p_is_One =>
      let H :=
        eq_ind p (fun p : Qpositive => homographicAcc a b c d p) hyp One
          H_p_is_One in
      (fun hyp0 : homographicAcc a b c d One =>
       (fun (Hab : (0 < a + b)%Z) (Hcd : (0 < c + d)%Z) =>
        positive_fraction_encoding (a + b) (c + d) Hab Hcd)
         (homographicacc_0_num a b c d hyp0)
         (homographicacc_0_denom a b c d hyp0)) H
  | right H_p_not_One =>
      match top_more_informative a b c d with
      | left H_abcd =>
          nR
            (Qhomographic_Qpositive_to_Qpositive (a - c)%Z 
               (b - d)%Z c d p
               (homographicacc_1 a b c d p hyp H_p_not_One H_abcd))
      | right H_abcd =>
          match top_more_informative c d a b with
          | left H_cdab =>
              dL
                (Qhomographic_Qpositive_to_Qpositive a b 
                   (c - a)%Z (d - b)%Z p
                   (homographicacc_2 a b c d p hyp H_p_not_One H_abcd H_cdab))
          | right H_cdab =>
              match p as q return (p = q -> Qpositive) with
              | nR q =>
                  fun H : p = nR q =>
                  Qhomographic_Qpositive_to_Qpositive a 
                    (a + b)%Z c (c + d)%Z q
                    (homographicacc_3 a b c d p hyp q H H_abcd H_cdab)
              | dL q =>
                  fun H : p = dL q =>
                  Qhomographic_Qpositive_to_Qpositive 
                    (a + b)%Z b (c + d)%Z d q
                    (homographicacc_3' a b c d p hyp q H H_abcd H_cdab)
              | One =>
                  fun q : p = One =>
                  False_rec Qpositive (False_ind False (H_p_not_One q))
              end (refl_equal p)
          end
      end
  end.

Fixpoint Qpositive_length (qp : Qpositive) : nat :=
  match qp with
  | One => 0
  | dL qp1 => S (Qpositive_length qp1)
  | nR qp1 => S (Qpositive_length qp1)
  end.

Definition bin_lt (qp1 qp2 : Qpositive) : Prop :=
  Qpositive_length qp1 < Qpositive_length qp2.

Definition bin_eq (x y : Qpositive) := x = y.

Lemma bin_lt_compat_via_length :
 forall x y : Qpositive,
 bin_lt x y -> Qpositive_length x < Qpositive_length y.
Proof.
 trivial.
Defined.

Lemma compare_dL : forall x : Qpositive, bin_lt x (dL x). 
Proof.
 unfold bin_lt in |- *.
 simpl in |- *.
 auto with arith.
Defined.

Lemma compare_nR : forall x : Qpositive, bin_lt x (nR x). 
Proof.
 unfold bin_lt in |- *.
 simpl in |- *.
 auto with arith.
Defined.

Record Z_pos : Set :=  {zposcrr :> Z; z4prf_Z_pos : (0 <= zposcrr)%Z}.

Definition qlt (a b c d : Z) (p : Qpositive) (a' b' c' d' : Z)
  (p' : Qpositive) : Prop :=
  bin_lt p p' \/ p = p' /\ (a + b + c + d < a' + b' + c' + d')%Z. 

Definition qle (a b c d : Z) (p : Qpositive) (a' b' c' d' : Z)
  (p' : Qpositive) : Prop :=
  qlt a b c d p a' b' c' d' p' \/
  a = a' /\ b = b' /\ c = c' /\ d = d' /\ p = p'. 

Definition quadrointegral_lt (a b c d a' b' c' d' : Z) :=
  (a + b + c + d < a' + b' + c' + d')%Z.

Definition quadrointegral_eq (a b c d a' b' c' d' : Z) :=
  a = a' /\ b = b' /\ c = c' /\ d = d'.

Record Z4 : Set := 
  {z4crr :> Z * Z * (Z * Z);
   z4prf :
    (0 <= fst (fst z4crr))%Z /\
    (0 <= snd (fst z4crr))%Z /\
    (0 <= fst (snd z4crr))%Z /\ (0 <= snd (snd z4crr))%Z}.

Definition Z4_lt (x y : Z4) :=
  let (V1, V2) := z4crr x in
  let (V3, V4) := z4crr y in
  let (a, b) := V1 in
  let (c, d) := V2 in
  let (a', b') := V3 in
  let (c', d') := V4 in quadrointegral_lt a b c d a' b' c' d'.

Definition Z4_eq (x y : Z4) :=
  let (V1, V2) := z4crr x in
  let (V3, V4) := z4crr y in
  let (a, b) := V1 in
  let (c, d) := V2 in
  let (a', b') := V3 in
  let (c', d') := V4 in quadrointegral_eq a b c d a' b' c' d'.

Lemma Z4_lt_is_irreflexive : forall x : Z4, ~ Z4_lt x x.
Proof.
 intros (((a, b), (c, d)), z4prf0).
 unfold Z4_lt in |- *. 
 unfold quadrointegral_lt in |- *.
 simpl in |- *.
 apply Z.lt_irrefl. 
Defined.

Lemma Z4_lt_is_transitive :
 forall x y z : Z4, Z4_lt x y -> Z4_lt y z -> Z4_lt x z.
Proof.
 intros (((a, b), (c, d)), z4prf0) (((a', b'), (c', d')), z4prf1)
  (((a2, b2), (c2, d2)), z4prf2).
 unfold Z4_lt in |- *.
 unfold quadrointegral_lt in |- *.
 simpl in |- *.
 intros.
 apply Z.lt_trans with (a' + b' + c' + d')%Z; assumption.
Defined.

Lemma Z4_lt_is_order : is_order Z4 Z4_lt.
Proof.
 split.
 apply Z4_lt_is_irreflexive.
 apply Z4_lt_is_transitive.
Defined.

Lemma Z4_eq_is_reflexive : forall x : Z4, Z4_eq x x.
Proof.
 intros (((a, b), (c, d)), z4prf0).
 unfold Z4_eq in |- *. 
 unfold quadrointegral_eq in |- *; repeat split. 
Defined.  

Lemma Z4_eq_is_symmetric : forall x y : Z4, Z4_eq x y -> Z4_eq y x.
Proof.
 intros (((a, b), (c, d)), z4prf0) (((a', b'), (c', d')), z4prf1).
 unfold Z4_eq in |- *.
 unfold quadrointegral_eq in |- *.
 intros (HH1, (HH2, (HH3, HH4))); repeat split; symmetry  in |- *; assumption.
Defined.

Lemma Z4_eq_is_transitive :
 forall x y z : Z4, Z4_eq x y -> Z4_eq y z -> Z4_eq x z.
Proof.
 intros (((a, b), (c, d)), z4prf0) (((a', b'), (c', d')), z4prf1)
  (((a2, b2), (c2, d2)), z4prf2).
 unfold Z4_eq in |- *.
 unfold quadrointegral_eq in |- *.
 simpl in |- *.
 intros (HH2, (HH4, (HH6, HH7))) (HH9, (HH11, (HH13, HH14))); repeat split;
  match goal with
  | id12:(?X1 = ?X2),id23:(?X2 = ?X3) |- (?X1 = ?X3) =>
      try apply (trans_eq id12 id23)
  end.
Defined.

Lemma Z4_eq_is_equality : is_equality Z4 Z4_eq.
Proof.
 split.
 apply Z4_eq_is_reflexive.
 split.
 apply Z4_eq_is_symmetric.
 apply Z4_eq_is_transitive.
Defined.

Lemma Z_pos_lt_is_wf :
 forall P : Z_pos -> Prop,
 (forall q : Z_pos, (forall r : Z_pos, (r < q)%Z -> P r) -> P q) ->
 forall q : Z_pos, P q.
Proof.
 intros.
 destruct q.
 rename zposcrr0 into q.
 set (P2 := fun p : Z => forall Hp : (0 <= p)%Z, P (Build_Z_pos p Hp)) in *. 
 assert (P2 q).
 apply Zind_wf with (p := 0%Z).
 intros.
 unfold P2 in |- *. 
 intro.
 apply H.
 intros.
 destruct r.
 rename zposcrr0 into r.
 assert (P2 r).
 apply H0.
 split.
 assumption.
 assumption.
 apply (H2 z4prf_Z_pos1).
 assumption.
 apply (H0 z4prf_Z_pos0).
Defined. 

Lemma Z4_lt_is_wf : wf_ind Z4 Z4_lt.
Proof.
 red in |- *.
 intros P H (((a, b), (c, d)), p); revert p;
 simpl in |- *.
 intros (Ha, (Hb, (Hc, Hd))).
 assert (H_a_b_c_d : (0 <= a + b + c + d)%Z); repeat apply Zplus_le_0_compat;
  try assumption.
 
 set
  (P4 :=
   fun k : Z_pos =>
   forall (a b c d : Z)
     (Habcd : (0 <= a)%Z /\ (0 <= b)%Z /\ (0 <= c)%Z /\ (0 <= d)%Z)
     (Hk : zposcrr k = (a + b + c + d)%Z), P (Build_Z4 (a, b, (c, d)) Habcd))
  in *.
 assert (P4 (Build_Z_pos (a + b + c + d) H_a_b_c_d)).

 apply Z_pos_lt_is_wf.
 intros q_pos.
 red in |- *.
 intros.
 apply H.
 intros (((r_a, r_b), (r_c, r_d)), p); revert p.
 simpl in |- *.
 intros (H_r_a, (H_r_b, (H_r_c, H_r_d))).
 intro Hq.

 assert (H_r_a_b_c_d : (0 <= r_a + r_b + r_c + r_d)%Z);
  repeat apply Zplus_le_0_compat; try assumption.
 
 assert (P4 (Build_Z_pos (r_a + r_b + r_c + r_d) H_r_a_b_c_d)).

 apply H0.
 rewrite Hk.
 simpl in |- *.
 assumption.

 apply H1.
 reflexivity.
 apply H0.
 reflexivity.
Defined.

Lemma Z4_lt_is_well_def_rht : is_well_def_rht Z4 Z4_lt Z4_eq.
Proof.
 red in |- *.
 intros (((a, b), (c, d)), z4prf0) (((a', b'), (c', d')), z4prf1).
 intro H.
 intros (((a2, b2), (c2, d2)), z4prf2).
 generalize H.
 unfold Z4_lt in |- *.
 unfold Z4_eq in |- *. 
 unfold quadrointegral_lt in |- *.
 unfold quadrointegral_eq in |- *.
 simpl in |- *.
 clear H z4prf0 z4prf1 z4prf2.
 intros H0 (H1, (H2, (H3, H4))).
 repeat
  match goal with
  | id:(?X1 = ?X2) |- _ => try rewrite id in H0; clear id
  end.
 assumption.
Defined.

Definition Z4_as_well_ordering :=
  Build_well_ordering Z4 Z4_lt Z4_eq Z4_lt_is_order Z4_eq_is_equality
    Z4_lt_is_wf Z4_lt_is_well_def_rht.

Lemma bin_lt_is_irreflexive : forall x : Qpositive, ~ bin_lt x x.
Proof.
 intros x.
 unfold bin_lt in |- *.
 apply lt_irrefl.
Defined.

Lemma bin_lt_is_transitive :
 forall x y z : Qpositive, bin_lt x y -> bin_lt y z -> bin_lt x z.
Proof.
 intros x y z; unfold bin_lt in |- *.
 apply lt_trans.
Defined.

Lemma bin_lt_is_order : is_order Qpositive bin_lt.
Proof.
 split.
 apply bin_lt_is_irreflexive.
 apply bin_lt_is_transitive.
Defined.

Lemma bin_eq_is_reflexive : forall x : Qpositive, bin_eq x x.
Proof.
 intros.
 unfold bin_eq in |- *.
 reflexivity.
Defined.  

Lemma bin_eq_is_symmetric : forall x y : Qpositive, bin_eq x y -> bin_eq y x.
Proof.
 intros x y.
 unfold bin_eq in |- *.
 apply sym_eq.
Defined.

Lemma bin_eq_is_transitive :
 forall x y z : Qpositive, bin_eq x y -> bin_eq y z -> bin_eq x z.
Proof.
 intros x y z.
 unfold bin_eq in |- *.
 apply trans_eq.
Defined.

Lemma bin_eq_is_equality : is_equality Qpositive bin_eq.
Proof.
 split.
 apply bin_eq_is_reflexive.
 split.
 apply bin_eq_is_symmetric.
 apply bin_eq_is_transitive.
Defined.

Lemma bin_lt_is_wf : wf_ind Qpositive bin_lt.
Proof.
 generalize
  (well_founded_lt_compat Qpositive Qpositive_length bin_lt
     bin_lt_compat_via_length).
 intro H.
 exact (well_founded_ind H).
Defined.

Lemma bin_lt_is_well_def_rht : is_well_def_rht Qpositive bin_lt bin_eq.
Proof.
 red in |- *.
 intros.
 red in H0.
 rewrite <- H0.
 assumption.
Defined.

Definition Qpositive_as_well_ordering :=
  Build_well_ordering Qpositive bin_lt bin_eq bin_lt_is_order
    bin_eq_is_equality bin_lt_is_wf bin_lt_is_well_def_rht.

Lemma qlt_wf_rec_without_zeros_and_One :
 forall P : Z -> Z -> Z -> Z -> Qpositive -> Prop,
 (forall (a b c d : Z_pos) (p : Qpositive),
  (forall (r s t u : Z_pos) (p1 : Qpositive),
   qlt r s t u p1 a b c d p -> P r s t u p1) -> P a b c d p) ->
 forall (a b c d : Z_pos) (p : Qpositive), P a b c d p.
Proof.
 intros P H (a, Ha) (b, Hb) (c, Hc) (d, Hd) p.
 set
  (P2 :=
   fun (p_i : Qpositive) (x : Z4) =>
   P (fst (fst x)) (snd (fst x)) (fst (snd x)) (snd (snd x)) p_i) 
  in *.
 simpl in |- *.

 assert (z4prf_Z4 : (0 <= a)%Z /\ (0 <= b)%Z /\ (0 <= c)%Z /\ (0 <= d)%Z);
  repeat split; try assumption.

 assert (P2 p (Build_Z4 (a, b, (c, d)) z4prf_Z4)).
 
 apply (merge_lt_wf Qpositive_as_well_ordering Z4_as_well_ordering).
 intro p_i.
 intros (((a_i, b_i), (c_i, d_i)), q); revert q.
 unfold P2 in |- *.
 simpl in |- *.
 intros (Ha_i, (Hb_i, (Hc_i, Hd_i))).
 intros.
 change
   (P (Build_Z_pos a_i Ha_i) (Build_Z_pos b_i Hb_i) 
      (Build_Z_pos c_i Hc_i) (Build_Z_pos d_i Hd_i) p_i) 
  in |- *.
 apply H.
 intros (r_, r_p) (s_, s_p) (t_, t_p) (u_, u_p) p1.
 simpl in |- *.
 intro H1.
 assert
  (z4prf2_Z4 : (0 <= r_)%Z /\ (0 <= s_)%Z /\ (0 <= t_)%Z /\ (0 <= u_)%Z);
  repeat split; try assumption.
 apply (H0 p1 (Build_Z4 (r_, s_, (t_, u_)) z4prf2_Z4)).
 case H1.
 intro.
 left.
 assumption.
 intros (H2, H3).
 right.
 split; assumption.
 assumption.
Defined.

Lemma homographicAcc_wf :
 forall (a b c d : Z) (p : Qpositive),
 (0 < a + b)%Z ->
 (0 < c + d)%Z ->
 (0 <= a)%Z ->
 (0 <= b)%Z -> (0 <= c)%Z -> (0 <= d)%Z -> homographicAcc a b c d p.
Proof.
 intros a b c d p Hab Hcd Ha Hb Hc Hd.
 set (ha := Build_Z_pos a Ha) in *.
 set (hb := Build_Z_pos b Hb) in *.
 set (hc := Build_Z_pos c Hc) in *.
 set (hd := Build_Z_pos d Hd) in *.
 generalize Hab Hcd Ha Hb Hc Hd.
 change
   ((0 < ha + hb)%Z ->
    (0 < hc + hd)%Z ->
    (0 <= ha)%Z ->
    (0 <= hb)%Z -> (0 <= hc)%Z -> (0 <= hd)%Z -> homographicAcc ha hb hc hd p)
  in |- *.

 apply
  qlt_wf_rec_without_zeros_and_One
   with
     (P := fun (r s t u : Z) (p1 : Qpositive) =>
           (0 < r + s)%Z ->
           (0 < t + u)%Z ->
           (0 <= r)%Z ->
           (0 <= s)%Z ->
           (0 <= t)%Z -> (0 <= u)%Z -> homographicAcc r s t u p1).
                       
 intros a0 b0 c0 d0 p0 hyp1_aux.

 assert
  (hyp1 :
   forall (r s t u : Z) (p1 : Qpositive),
   qlt r s t u p1 a0 b0 c0 d0 p0 ->
   (0 < r + s)%Z ->
   (0 < t + u)%Z ->
   (0 <= r)%Z ->
   (0 <= s)%Z -> (0 <= t)%Z -> (0 <= u)%Z -> homographicAcc r s t u p1).
 intros.
 change
   (homographicAcc (Build_Z_pos r H2) (Build_Z_pos s H3) 
      (Build_Z_pos t H4) (Build_Z_pos u H5) p1) in |- *.
 apply hyp1_aux; repeat assumption.

 destruct p0 as [q| q| ].

  case (top_more_informative a0 b0 c0 d0).
  
   intros.
   apply homographicacc1.
   discriminate.
   assumption.
   apply hyp1.
   right.
   split.
   reflexivity.
   apply top_more_5.
   assumption.
   apply top_more_1.
   assumption.
   assumption.
   apply Zle_minus.
   apply (top_more_4 _ _ _ _ t).
   apply Zle_minus.
   apply (top_more_4' _ _ _ _ t).
   assumption.
   assumption.
  
   intro.
   case (top_more_informative c0 d0 a0 b0).
   
    intros.
    apply homographicacc2.
    discriminate.
    assumption.
    assumption.
    apply hyp1.
    right.
    split.
    reflexivity.
    apply top_more_5'.
    assumption.
    assumption.    
    apply top_more_1.
    assumption.
    assumption.
    assumption.   
    apply Zle_minus.
    apply (top_more_4 _ _ _ _ t).
    apply Zle_minus.
    apply (top_more_4' _ _ _ _ t).
   
    intros.
    apply homographicacc3.
    
    assumption.
    assumption.
    apply hyp1.

    left.
    unfold bin_lt in |- *.
    apply compare_nR.    

    replace 0%Z with (0 + 0)%Z.
    apply Zplus_le_lt_compat.
    assumption.
    assumption.
    constructor.
    replace 0%Z with (0 + 0)%Z.
    apply Zplus_le_lt_compat.
    assumption.
    assumption.
    constructor.
    assumption.
    apply Zlt_le_weak.
    assumption.
    assumption.
    apply Zlt_le_weak.
    assumption.
 
  case (top_more_informative a0 b0 c0 d0).
  
   intros.
   apply homographicacc1.
   discriminate.
   assumption.
   apply hyp1.
   right.

   split.
   reflexivity.

   apply top_more_5.
   assumption.

   apply top_more_1.
   assumption.
   assumption.
   apply Zle_minus.
   apply (top_more_4 _ _ _ _ t).
   apply Zle_minus.
   apply (top_more_4' _ _ _ _ t).
   assumption.
   assumption.
  
   intro.
   case (top_more_informative c0 d0 a0 b0).
   
    intros.
    apply homographicacc2.
    discriminate.
    assumption.
    assumption.
    apply hyp1.
    right.

    split.
    reflexivity.

    apply top_more_5'.
    assumption.

    assumption.    
    apply top_more_1.
    assumption.
    assumption.
    assumption.   
    apply Zle_minus.
    apply (top_more_4 _ _ _ _ t).
    apply Zle_minus.
    apply (top_more_4' _ _ _ _ t).
   
    intros.
    apply homographicacc3'.

    assumption.
    assumption.
    apply hyp1.
    left.

    unfold bin_lt in |- *.
    apply compare_dL.  
    replace 0%Z with (0 + 0)%Z.
    apply Zplus_lt_le_compat.
    assumption.
    assumption.
    constructor.
    replace 0%Z with (0 + 0)%Z.
    apply Zplus_lt_le_compat.
    assumption.
    assumption.
    constructor.
    apply Zlt_le_weak.
    assumption.
    assumption.
    apply Zlt_le_weak.
    assumption.
    assumption.
 
  intros.
  apply homographicacc0.
  reflexivity.
  assumption.
  assumption.
Defined.

Remark one_non_negative : (0 <= 1)%Z.
Proof. 
 apply Zorder.Zle_0_pos. 
Defined.

Remark two_non_negative : (0 <= 2)%Z.
Proof. 
 apply Zorder.Zle_0_pos. 
Defined.

Remark three_non_negative : (0 <= 3)%Z.
Proof.
 apply Zorder.Zle_0_pos.
Defined.

Remark four_non_negative : (0 <= 4)%Z.
Proof.
 apply Zorder.Zle_0_pos.
Defined.

Remark five_non_negative : (0 <= 5)%Z.
Proof.
 apply Zorder.Zle_0_pos.
Defined.

Remark six_non_negative : (0 <= 6)%Z.
Proof.
 apply Zorder.Zle_0_pos.
Defined.

Remark seven_non_negative : (0 <= 7)%Z.
Proof.
 apply Zorder.Zle_0_pos.
Defined.

Remark two_plus_three_positive : (0 < 2 + 3)%Z.
Proof. 
 simpl in |- *.
 apply ZERO_lt_POS. 
Defined.

Remark one_plus_four_positive : (0 < 1 + 4)%Z.
Proof.
 simpl in |- *.
 apply ZERO_lt_POS.
Defined.

Definition homographicacc_wf_for_five_over_five :=
  homographicAcc_wf 2 3 1 4 One two_plus_three_positive
    one_plus_four_positive two_non_negative three_non_negative
    one_non_negative four_non_negative.

Scheme homographicAcc_ind_dep := Induction for homographicAcc Sort Prop.

Lemma Qhomographic_Qpositive_to_Qpositive_equal :
 forall (a b c d : Z) (p : Qpositive) (hyp1 hyp2 : homographicAcc a b c d p),
 Qhomographic_Qpositive_to_Qpositive a b c d p hyp1 =
 Qhomographic_Qpositive_to_Qpositive a b c d p hyp2.
Proof.
 intros a b c d p hyp1 hyp2.
 generalize hyp2.
 clear hyp2.
 pattern a, b, c, d, p, hyp1 in |- *.
 elim hyp1 using homographicAcc_ind_dep; clear a b c d p hyp1.

   intros a b c d p Hp Hab Hcd hyp2; generalize Hp Hab Hcd; clear Hp Hab Hcd.
   pattern a, b, c, d, p, hyp2 in |- *.
   elim hyp2 using homographicAcc_ind_dep; clear a b c d p hyp2; intros.

    simpl in |- *.
    case (Qpositive_dec_One p); intro Hp_; [ idtac | Falsum ].
    apply positive_fraction_encoding_equal. 
    
    Falsum.
    
    Falsum.
    
    discriminate Hp.
    
    discriminate Hp.

   intros a b c d p Hp Habcd hyp1 H_ind hyp2; generalize Hp Habcd hyp1 H_ind;
    clear Hp Habcd H_ind hyp1.
   pattern a, b, c, d, p, hyp2 in |- *.
   elim hyp2 using homographicAcc_ind_dep; clear a b c d p hyp2; intros.

    Falsum.
    
    simpl in |- *; case (Qpositive_dec_One p); intro Hp_; [ Falsum | idtac ];
     case (top_more_informative a b c d); intro Habcd_; 
     [ idtac | Falsum ]; apply f_equal with Qpositive; 
     apply H_ind.
    
    Falsum.
    
    Falsum.
    
    Falsum.

   intros a b c d p Hp Habcd Hcdab hyp1 H_ind hyp2;
    generalize Hp Habcd Hcdab hyp1 H_ind; clear Hp Habcd Hcdab H_ind hyp1.
   pattern a, b, c, d, p, hyp2 in |- *.
   elim hyp2 using homographicAcc_ind_dep; clear a b c d p hyp2; intros.

    Falsum.
    
    Falsum.
    
    simpl in |- *; case (Qpositive_dec_One p); intro Hp_; [ Falsum | idtac ];
     case (top_more_informative a b c d); intro Habcd_; 
     [ Falsum | idtac ]; case (top_more_informative c d a b); 
     intro Hcdab_; [ idtac | Falsum ]; apply f_equal with Qpositive;
     apply H_ind.
    
    Falsum.
    
    Falsum.

   intros a b c d xs Habcd Hcdab hyp1 H_ind hyp2.
   set (P := nR xs) in *; assert (HP : P = nR xs); trivial; generalize HP.
   generalize Habcd Hcdab hyp1 H_ind.
   clear Habcd Hcdab H_ind hyp1.
   
   elim hyp2 using
    homographicAcc_ind_dep
     with
       (P := fun (a b c d : Z) (P : Qpositive)
               (hyp2 : homographicAcc a b c d P) =>
             forall (Habcd : ~ top_more a b c d) (Hcdab : ~ top_more c d a b)
               (hyp1 : homographicAcc a (a + b) c (c + d) xs),
             (forall hyp2 : homographicAcc a (a + b) c (c + d) xs,
              Qhomographic_Qpositive_to_Qpositive a (a + b) c (c + d) xs hyp1 =
              Qhomographic_Qpositive_to_Qpositive a (a + b) c (c + d) xs hyp2) ->
             P = nR xs ->
             Qhomographic_Qpositive_to_Qpositive a b c d 
               (nR xs) (homographicacc3 a b c d xs Habcd Hcdab hyp1) =
             Qhomographic_Qpositive_to_Qpositive a b c d P hyp2);
    clear a b c d hyp2; intros.
    
    Falsum; rewrite H0 in e; discriminate e.
    
    Falsum.
    
    Falsum.
    
    simpl in |- *.
    case (top_more_informative a b c d); intro Habcd_; [ Falsum | idtac ];
     case (top_more_informative c d a b); intro Hcdab_; 
     [ Falsum | idtac ].
    generalize h;
     let T_local := eval compute in (f_equal Qpositive_tail H1) in
     rewrite T_local.
    intro; apply H0.
    
    discriminate H1.

   intros a b c d xs Habcd Hcdab hyp1 H_ind hyp2.
   set (P := dL xs) in *; assert (HP : P = dL xs); trivial; generalize HP.
   generalize Habcd Hcdab hyp1 H_ind.
   clear Habcd Hcdab H_ind hyp1.
   elim hyp2 using
    homographicAcc_ind_dep
     with
       (P := fun (a b c d : Z) (P : Qpositive)
               (hyp2 : homographicAcc a b c d P) =>
             forall (Habcd : ~ top_more a b c d) (Hcdab : ~ top_more c d a b)
               (hyp1 : homographicAcc (a + b) b (c + d) d xs),
             (forall hyp2 : homographicAcc (a + b) b (c + d) d xs,
              Qhomographic_Qpositive_to_Qpositive (a + b) b (c + d) d xs hyp1 =
              Qhomographic_Qpositive_to_Qpositive (a + b) b (c + d) d xs hyp2) ->
             P = dL xs ->
             Qhomographic_Qpositive_to_Qpositive a b c d 
               (dL xs) (homographicacc3' a b c d xs Habcd Hcdab hyp1) =
             Qhomographic_Qpositive_to_Qpositive a b c d P hyp2);
    clear a b c d hyp2; intros.
    
    Falsum; rewrite H0 in e; discriminate e.
    
    Falsum.
    
    Falsum.
    
    discriminate H1.
    
    simpl in |- *.
    case (top_more_informative a b c d); intro Habcd_; [ Falsum | idtac ];
     case (top_more_informative c d a b); intro Hcdab_; 
     [ Falsum | idtac ].
    generalize h;
     let T_local := eval compute in (f_equal Qpositive_tail H1) in
     rewrite T_local.
    intro; apply H0.
Defined. 

Lemma Qhomographic_Qpositive_to_Qpositive_equal_strong :
 forall (a1 a2 b1 b2 c1 c2 d1 d2 : Z) (p1 p2 : Qpositive)
   (hyp1 : homographicAcc a1 b1 c1 d1 p1)
   (hyp2 : homographicAcc a2 b2 c2 d2 p2),
 a1 = a2 ->
 b1 = b2 ->
 c1 = c2 ->
 d1 = d2 ->
 p1 = p2 ->
 Qhomographic_Qpositive_to_Qpositive a1 b1 c1 d1 p1 hyp1 =
 Qhomographic_Qpositive_to_Qpositive a2 b2 c2 d2 p2 hyp2.
Proof.
 intros.
 subst.
 apply Qhomographic_Qpositive_to_Qpositive_equal. 
Defined.

Lemma Qhomographic_Qpositive_to_Qpositive_0 :
 forall (a b c d : Z) (p : Qpositive) (hyp : homographicAcc a b c d p),
 p = One ->
 forall (H1 : (0 < a + b)%Z) (H2 : (0 < c + d)%Z),
 Qhomographic_Qpositive_to_Qpositive a b c d p hyp =
 positive_fraction_encoding (a + b) (c + d) H1 H2. 
Proof. 
 intros. 
 apply
  trans_eq
   with
     (Qhomographic_Qpositive_to_Qpositive a b c d One
        (homographicacc0 a b c d One (refl_equal One) H1 H2)).
 apply Qhomographic_Qpositive_to_Qpositive_equal_strong; repeat reflexivity.
 assumption.
  simpl in |- *.
  apply positive_fraction_encoding_equal.
Defined.

Lemma Qhomographic_Qpositive_to_Qpositive_1 :
 forall (a b c d : Z) (p : Qpositive) (hyp : homographicAcc a b c d p),
 p <> One ->
 top_more a b c d ->
 forall h : homographicAcc (a - c) (b - d) c d p,
 Qhomographic_Qpositive_to_Qpositive a b c d p hyp =
 nR (Qhomographic_Qpositive_to_Qpositive (a - c) (b - d) c d p h).
Proof.
 intros.
 apply
  trans_eq
   with
     (Qhomographic_Qpositive_to_Qpositive a b c d p
        (homographicacc1 a b c d p H H0 h)).
 apply Qhomographic_Qpositive_to_Qpositive_equal.
  simpl in |- *.
  case (Qpositive_dec_One p); intros Hp; [ Falsum | idtac ].
  case (top_more_informative a b c d); intros Habcd; [ idtac | Falsum ].
  apply f_equal with Qpositive; reflexivity.
Defined.

Lemma Qhomographic_Qpositive_to_Qpositive_2 :
 forall (a b c d : Z) (p : Qpositive) (hyp : homographicAcc a b c d p),
 p <> One ->
 ~ top_more a b c d ->
 top_more c d a b ->
 forall h : homographicAcc a b (c - a) (d - b) p,
 Qhomographic_Qpositive_to_Qpositive a b c d p hyp =
 dL (Qhomographic_Qpositive_to_Qpositive a b (c - a) (d - b) p h).
Proof.
 intros.
 apply
  trans_eq
   with
     (Qhomographic_Qpositive_to_Qpositive a b c d p
        (homographicacc2 a b c d p H H0 H1 h)).
 apply Qhomographic_Qpositive_to_Qpositive_equal.
  simpl in |- *.
  case (Qpositive_dec_One p); intros Hp; [ Falsum | idtac ].
  case (top_more_informative a b c d); intros Habcd; [ Falsum | idtac ].
  case (top_more_informative c d a b); intros Hcdab; [ idtac | Falsum ].
  apply f_equal with Qpositive; reflexivity.
Defined.

Lemma Qhomographic_Qpositive_to_Qpositive_3 :
 forall (a b c d : Z) (p : Qpositive) (hyp : homographicAcc a b c d p),
 ~ top_more a b c d ->
 ~ top_more c d a b ->
 forall xs : Qpositive,
 p = nR xs ->
 forall h : homographicAcc a (a + b) c (c + d) xs,
 Qhomographic_Qpositive_to_Qpositive a b c d p hyp =
 Qhomographic_Qpositive_to_Qpositive a (a + b) c (c + d) xs h.
Proof.
 intros.
 apply
  trans_eq
   with
     (Qhomographic_Qpositive_to_Qpositive a b c d (nR xs)
        (homographicacc3 a b c d xs H H0 h)).
 apply Qhomographic_Qpositive_to_Qpositive_equal_strong; trivial.
  simpl in |- *.
  case (top_more_informative a b c d); intros Habcd; [ Falsum | idtac ].
  case (top_more_informative c d a b); intros Hcdab; [ Falsum | idtac ].
  reflexivity.
Defined.

Lemma Qhomographic_Qpositive_to_Qpositive_3' :
 forall (a b c d : Z) (p : Qpositive) (hyp : homographicAcc a b c d p),
 ~ top_more a b c d ->
 ~ top_more c d a b ->
 forall xs : Qpositive,
 p = dL xs ->
 forall h : homographicAcc (a + b) b (c + d) d xs,
 Qhomographic_Qpositive_to_Qpositive a b c d p hyp =
 Qhomographic_Qpositive_to_Qpositive (a + b) b (c + d) d xs h.
Proof.
 intros.
 apply
  trans_eq
   with
     (Qhomographic_Qpositive_to_Qpositive a b c d (dL xs)
        (homographicacc3' a b c d xs H H0 h)).
 apply Qhomographic_Qpositive_to_Qpositive_equal_strong; trivial.
  simpl in |- *.
  case (top_more_informative a b c d); intros Habcd; [ Falsum | idtac ].
  case (top_more_informative c d a b); intros Hcdab; [ Falsum | idtac ].
  reflexivity.
Defined.
