
Require Export Qsyntax.
(* Qsyntax:
Require Export general_Q.

Infix "/" := make_Q : Q_scope. 

Notation "{ x }" := (decode_Q x) : Q_scope.

Open Scope Q_scope.

Infix "+" := Qplus : Q_scope.

Infix "*" := Qmult : Q_scope.

Infix "-" := Qminus : Q_scope.

Infix "/" := Qdiv : Q_scope.

Notation "- x" := (Qopp x) : Q_scope.

Notation "x1 ^" := (Qinv x1) (at level 2, left associativity) : Q_scope.

Delimit Scope Q_scope with Q.

Infix "<" := Qlt : Q_scope.
Infix "<=" := Qle : Q_scope. *)
Require Export Field_Theory_Q.
(* Field_Theory_Q:
Require Import Eqdep_dec.
Require Export Field.
Require Export Q_order.

Lemma Q_Ring_Theory :
    ring_theory Zero Qone Qplus Qmult Qminus Qopp (eq(A:=Q)).

Lemma Qinv_defT : forall n : Q, n <> Zero -> Qmult (Qinv n) n = Qone.

Lemma QField :
  field_theory Zero Qone Qplus Qmult Qminus Qopp Qdiv Qinv (eq(A:=Q)).

Ltac isQcst t :=
  match t with
    Zero => true
  | Qpos ?p => isQcst p
  | Qneg ?p => isQcst p
  | nR ?p => isQcst p
  | dL ?p => isQcst p
  | One => true
  | Qone => true
  | _ => false
  end.
Ltac Qcst t :=
  match isQcst t with
  | true => t
  | _ => InitialRing.NotConstant
  end.
 
Add Field Qfield : QField (decidable Q_eq_prop, constants [Qcst]).

Definition not_eq2eqT (A : Set) (x y : A) (H1 : x <> y) : 
  x <> y := fun H2 : x = y => H1 (H2).

Ltac Field := field. *)
Require Export Q_ordered_field_properties.
(* Q_ordered_field_properties:
Require Export Qsyntax.
Require Export Field_Theory_Q.

Lemma Qmult_absorb_nonzero_r: forall x y : Q, x * y <> Zero -> y <> Zero.

Lemma Qmult_absorb_nonzero_l: forall x y : Q, x * y <> Zero -> x <> Zero.

Lemma Qle_Qminus_Zero: forall x y: Q, x <= y -> Zero <= y-x.

Lemma Qle_Qminus_Zero_neg: forall x y : Q, x <= y -> x-y <= Zero.

Lemma Qle_Zero_Qminus_neg: forall x y : Q, x-y <= Zero -> x <= y.

Lemma Qle_Zero_Qminus: forall x y: Q,  Zero <= y-x -> x <= y.

Lemma Qmult_mult_nonneg: forall x:Q, Zero <= x*x.

Lemma Qmult_mult_pos: forall x:Q, x<> Zero -> Zero < x*x.

Lemma Qlt_opp:forall x y, Qopp x < Qopp y -> y < x.

Lemma Qlt_plus:forall x y z : Q, x < y -> z + x < z + y.

Lemma Qlt_Qminus_Zero: forall x y : Q, x < y -> Zero < y - x.

Lemma Qlt_Qminus_Zero_neg: forall x y : Q, x < y -> x-y < Zero.

Lemma Qlt_Zero_Qminus_neg: forall x y : Q, x-y < Zero -> x < y.

Lemma Qlt_reg_mult_pos_l: forall x y z : Q, Zero < x -> y < z -> x * y < x * z.

Lemma Qlt_reg_mult_pos_r: forall x y z : Q, Zero < x -> y < z -> y * x < z * x.

Lemma Qlt_reg_mult_neg_l: forall x y z : Q, x < Zero -> y < z -> x * z < x * y.

Lemma Qlt_reg_mult_neg_r: forall x y z : Q, x < Zero -> y < z -> z * x < y * x.

Lemma Qdiv_Qmult_pos:forall x y z t: Q, Zero < z*t -> x/z < y/t -> x*t < y*z. 

Lemma Qinv_involutive:forall x:Q, x<>Zero -> Qinv (Qinv x) = x.

Lemma Qmult_Qdiv_pos:forall x y z t: Q, Zero < z*t -> x*t < y*z -> x/z < y/t.

Lemma Qlt_Qopp_pos: forall x: Q, x < Zero -> Zero < - x.

Lemma Qlt_Qopp_neg: forall x: Q, Zero < x -> -x < Zero.

Lemma Qmult_one_left:forall x : Q, Qone * x = x.

Lemma Qdiv_Qone_Qone: Qdiv Qone Qone = Qone.

Lemma Qinv_Qdiv_Qone:forall x, Qinv x = Qone/x. 

Lemma Qminus_Qdiv:forall x y z t, z<>Zero -> t<>Zero -> x/z - y/t = (x*t-y*z)/(z*t).

Lemma Qplus_Qdiv:forall x y z t, z<>Zero -> t<>Zero -> x/z + y/t = (x*t+y*z)/(z*t).

Definition Qmult_Qinv_l:= Qinv_defT. 

Lemma Qmult_Qinv_r:forall x, x <> Zero -> x * (Qinv x) = Qone.

Lemma Qinv_Qmult:forall x y, x<>Zero -> y <> Zero -> Qinv (x*y) = (Qinv x)*(Qinv y).

Lemma Qplus_Qdiv_one:forall p q, q<> Zero -> (p+q) / q = p/q + Qone.

Lemma Qdiv_Qopp_numerator: forall x y : Q, y<> Zero -> Qdiv (-x) y = - (Qdiv x  y).

Lemma Qdiv_Qopp_denomintor: forall x y : Q, y<> Zero -> Qdiv x (-y) = - (Qdiv x  y).

Lemma Qdiv_Qdiv_simplify:forall x y z, z<> Zero -> y<> Zero -> (x/z)/(y/z) = x/y.

Lemma Qdiv_Qmult_Qone_denominator:forall x y z, z<>Zero -> y<>Zero -> x/(y*z) = (x/y)*(Qone/z).

Lemma Qdiv_Qmult_numerator_l: forall (x y z:Q), y<>Zero -> z*(x/y)=(z*x)/y.

Lemma Qdiv_Qmult_numerator_r: forall (x y z:Q), y<>Zero -> (x/y)*z=(x*z)/y.

Lemma Qlt_Qmult_cancel_l: forall x y z : Q, Zero < x -> x * y < x * z -> y < z.

Lemma Qlt_Qmult_cancel_r: forall x y z : Q, Zero < x -> y * x< z * x -> y < z.

Definition Qmult_resp_Qlt_pos_r:= Qlt_Qmult_cancel_r :  forall t x y : Q, Zero < t -> x * t < y * t -> x < y.

Definition Qmult_resp_Qlt_pos_l:= Qlt_Qmult_cancel_l: forall t x y : Q, Zero < t -> t * x < t * y -> x < y.

Lemma Qmult_resp_Qlt_neg_r: forall t x y : Q, t < Zero -> x * t < y * t -> y < x.

Lemma Qmult_resp_Qlt_neg_l: forall t x y : Q, t < Zero -> t * x < t * y -> y < x.

Lemma Qeq_Qminus : forall x y, x=y -> x-y=Zero.

Lemma Qminus_Qeq : forall x y, x-y=Zero -> x=y.

Lemma Qlt_not_eq': forall x y : Q, x < y -> x <> y.

Lemma Qinv_neg: forall q : Q, q<Zero -> Qinv q< Zero.

Lemma Qle_Qopp_pos:forall q : Q, q<= Zero -> Zero<= Qopp q.

Lemma Qopp_Qone_Qlt_Qone: Qopp Qone < Qone.

Hint Resolve Qinv_pos Qinv_resp_nonzero Qminus_Qeq Qeq_Qminus
             Qlt_not_eq' Qinv_neg Qle_Qopp_pos Qlt_Qopp_pos 
             Qlt_Qopp_neg Qopp_Qone_Qlt_Qone.

Lemma Qle_mult_nonneg_pos: forall x y : Q, Zero <= x -> Zero < y -> Zero <= x * y.

Lemma Qle_mult_pos_nonneg: forall x y : Q, Zero<x -> Zero <= y -> Zero <= x * y.

Lemma Qle_mult_nonpos_neg: forall x y : Q, x<=Zero -> y<Zero -> Zero <= x * y.

Lemma Qle_mult_neg_nonpos: forall x y : Q, x<Zero -> y<=Zero -> Zero <= x * y.

Lemma Qle_Qdiv_nonpos_pos: forall x y : Q, x <= Zero -> Zero < y -> x / y <= Zero.

Lemma Qle_Qdiv_nonneg_neg: forall x y : Q, Zero <= x -> y < Zero -> x / y <= Zero.

Lemma Qle_Qdiv_nonneg_pos: forall x y : Q, Zero<=x -> Zero < y -> Zero<=x / y.

Lemma Qle_Qdiv_nonpos_neg: forall x y : Q, x<=Zero -> y<Zero -> Zero<=x / y.

Lemma Qlt_mult_neg_neg: forall x y : Q, x<Zero-> y<Zero -> Zero < x * y.

Lemma Qmult_reg_l: forall x y z: Q, z <> Zero -> z*x = z*y -> x=y.

Lemma Qmult_reg_r: forall x y z: Q, z <> Zero -> x*z = y*z -> x=y.

Lemma Qmult_Qdiv: forall x y z t : Q,  z <> Zero  -> t <> Zero -> x * t = y * z -> x / z = y / t.

Lemma Qdiv_Qmult: forall x y z t : Q,  z <> Zero  -> t <> Zero -> x / z = y / t -> x * t = y * z.

Lemma Qdiv_Qdiv_Qmult_numerator: forall x y z, y<>Zero -> z<>Zero ->(x/y)/z = x/(y*z).

Lemma Qdiv_Qdiv_Qmult_denominator: forall x y z, y<>Zero -> z<>Zero -> x/(y/z) = (x*z)/y.

Lemma Qdiv_Qplus_Qmult: forall x y z, y<>Zero -> x/y + z = (x+y*z)/y.

Lemma Qdiv_Qminus_Qmult: forall x y z, y<>Zero -> x/y - z = (x-y*z)/y.

Lemma Qminus_Qdiv_Qmult: forall x y z, ~(y=Zero)->z-x/y=(y*z-x)/y.

Lemma Qplus_Qdiv_Qmult: forall x y z, ~(y=Zero)->z+x/y=(y*z+x)/y.

Lemma Qle_reg_mult_r: forall x y z : Q, Zero < x -> y <=z -> y * x <=z * x.

Lemma Qle_reg_mult_l: forall x y z : Q, Zero < x -> y <= z -> x * y <= x * z.

Lemma Qmult_resp_Qle_pos_r: forall t x y : Q, Zero < t -> x * t <= y * t -> x <= y.

Lemma Qmult_resp_Qle_pos_l: forall t x y : Q, Zero < t -> t * x <= t * y -> x <= y.

Lemma Qmult_resp_Qle_neg_r: forall t x y : Q, t < Zero -> x * t <= y * t -> y <= x.

Lemma Qmult_resp_Qle_neg_l: forall t x y : Q, t < Zero -> t * x <= t * y -> y <= x.

Lemma Qmult_Qdiv_pos_Qle: forall x y z t : Q, Zero < z -> Zero < t -> x * t <= y * z -> x / z <= y / t.

Lemma Qmult_Qle_compat: forall n m p q : Q, n <= p -> m <= q -> Zero <= n -> Zero <= m -> n * m <= p * q.

Lemma Qdiv_num_denom_explicit: forall q1 q2 p : Q, q2 <> Zero -> p <> Zero -> q1 / q2 = (q1 * p)/ (q2 * p).

Lemma Qle_opp: forall x y : Q, - x <= - y -> y <= x.

Lemma Qmult_pos_Qle_Qdiv: forall x y z : Q, Zero<z -> x * z<=y -> x <= y / z.

Lemma Qmult_neg_Qle_Qdiv: forall x y z : Q, z <Zero -> y <= x * z -> x <= y / z.

Lemma Qmult_pos_Qdiv_Qle: forall x y z : Q, Zero<z -> y<=x*z -> y/z <= x.

Lemma Qmult_neg_Qdiv_Qle: forall x y z : Q, z <Zero -> x*z<=y -> y/z<=x.

Lemma Qmult_pos_Qlt_Qdiv: forall x y z : Q, Zero<z -> x * z<y -> x < y/z.

Lemma Qmult_neg_Qlt_Qdiv: forall x y z : Q, z <Zero -> y < x * z -> x < y / z.

Lemma Qmult_pos_Qdiv_Qlt: forall x y z : Q, Zero<z -> y<x*z -> y/z < x.

Lemma Qmult_neg_Qdiv_Qlt: forall x y z : Q, z <Zero -> x*z<y -> y/z<x.

Lemma Qmult_Qdiv_pos_neg_Qle:forall x y z t : Q,  Zero < z -> t<Zero -> y * z <= x * t -> x / z <= y / t.

Lemma Qmult_Qdiv_neg_pos_Qle:forall x y z t : Q,  z<Zero -> Zero<t -> y * z <= x * t -> x / z <= y / t.

Lemma Qmult_Qdiv_neg_Qle:forall x y z t : Q,  z<Zero -> t<Zero -> x * t<=y * z -> x / z <= y / t.

Lemma Qopp_involutive: forall q, Qopp (Qopp q) = q.

Lemma Qopp_Qle: forall x y, y <= x -> - x <= - y.

Lemma Qopp_Qlt: forall x y, y < x -> - x < - y.

Lemma Qle_reg_mult_r_strong: forall x y z : Q, Zero <= x -> y <= z -> y * x <= z * x.

Lemma Qle_reg_mult_l_strong: forall x y z : Q, Zero <= x -> y <= z -> x * y <= x * z.

Lemma Qlt_Qdiv_denom_neg_neg: forall x y:Q, y<Zero -> x / y < Zero ->  Zero < x.

Lemma Qlt_Qdiv_denom_neg_pos: forall x y:Q, y<Zero ->  Zero< x / y  -> x<Zero.

Lemma Qlt_Qdiv_denom_pos_neg: forall x y:Q, Zero<y -> x / y < Zero ->  x<Zero.

Lemma Qlt_Qdiv_denom_pos_pos: forall x y:Q, Zero<y ->  Zero< x / y  -> Zero<x.

Lemma Qle_Qdiv_denom_neg_nonpos: forall x y:Q, y<Zero -> x / y <= Zero ->  Zero <= x.

Lemma Qle_Qdiv_denom_neg_nonneg: forall x y:Q, y<Zero ->  Zero<= x / y  -> x<=Zero.

Lemma Qle_Qdiv_denom_pos_nonpos: forall x y:Q, Zero<y -> x / y <= Zero ->  x<=Zero.

Lemma Qle_Qdiv_denom_pos_nonneg: forall x y:Q, Zero<y ->  Zero<= x / y  -> Zero<=x.

Lemma Qlt_neg_Qopp: forall x : Q, - x < Zero->Zero < x.

Lemma Qlt_pos_Qopp: forall x : Q, Zero < - x->x<Zero.

Lemma Qmult_mult_Qle_Qone_Qopp_Qone: forall q, -Qone<=q -> q<= Qone -> q*q <= Qone. 

Lemma Qinv_resp_nonzero_Qdiv:forall q, q <> Zero -> (Qone/q)<>Zero. 

Lemma Qmult_Qlt_Qle_nonneg_pos_compat: forall n m p q, n < p -> m <= q -> Zero <= n -> Zero < q -> n * m < p * q.

Lemma Qmult_Qlt_Qle_pos_nonneg_compat: forall n m p q, n <= p -> m < q -> Zero < p -> Zero <= m -> n * m < p * q.

Ltac qZ_numerals_one  :=replace (Z_to_Q 1) with Qone;  trivial. 

Ltac qZ_numerals  := 
 match goal with 
 | [ |- context [(Z_to_Q (Z_of_nat ?X1))] ] => unfold Z_of_nat; qZ_numerals
 | [ |- context [(Z_to_Q Z0)] ] => replace (Z_to_Q Z0) with Zero; trivial; qZ_numerals
 | [ |- context [(Z_to_Q (Zpos ?X1))] ] => progress  let v:= eval compute in (Z.pred (Zpos X1)) in 
         replace (Z_to_Q (Zpos X1)) with (Qplus Qone (Z_to_Q v)); trivial; qZ_numerals
 | [ |- context [(Z_to_Q (Zneg ?X1))] ] => let v:= eval compute in (Z.succ (Zneg X1)) in 
        replace (Z_to_Q (Zneg X1)) with (Qminus (Z_to_Q v) Qone); trivial; qZ_numerals
 | [ |- context [(Qplus Zero ?X1)] ] => rewrite Qplus_zero_left; qZ_numerals
 | [ |- context [(Qplus ?X1 Zero)] ] => rewrite Qplus_zero_right; qZ_numerals
 | [ |- context [(Qminus Zero ?X1)] ] => unfold Qminus; rewrite Qplus_zero_left; qZ_numerals
 | [ |- context [(Qminus ?X1 Zero)] ] => unfold Qminus; rewrite Qplus_zero_right; qZ_numerals
 | [ |- context [(Qmult Qone ?X1)] ] => rewrite Qmult_one_left; qZ_numerals
 | [ |- context [(Qmult ?X1 Qone)] ] => rewrite Qmult_one_right; qZ_numerals
 | [ |- _ ] => idtac
 end.

Ltac ring_exact_Q hyp := 
 match type of hyp with 
 | Qlt ?X1 ?X2 => stepl X1;[|qZ_numerals;ring];stepr X2;[|qZ_numerals;ring]; trivial
 | Qle ?X1 ?X2 => stepl X1;[|qZ_numerals;ring];stepr X2;[|qZ_numerals;ring]; trivial
 | ~(@eq Q ?X1 ?X2) => stepl X1;[|qZ_numerals;ring];stepr X2;[|qZ_numerals;ring]; trivial
 | ?X3 => fail 1
 end. *)

Lemma Qpositive_in_Q_Archimedean_inf:forall qp:Qpositive, {z:Z | (Qpos qp)<=z /\ (z-(Qpos qp))<= Qone}.
Proof.
 induction qp as [qp [z [Hz1 Hz2]]|qp [z [Hz1 Hz2]]|]; simpl.
  exists (z+1)%Z; split;rewrite Qpos_nR; rewrite Z_to_Qplus; qZ_numerals.
   apply Qle_plus_plus; trivial.
   stepl (z-Qpos qp); [assumption|ring].

  exists (1)%Z; split; rewrite Qpos_dL; fold (Qdiv (Qpos qp) (Qpos qp + Qone)); qZ_numerals.
   apply Qmult_pos_Qdiv_Qle; auto; stepr (Qpos qp+Qone); [|ring]; apply Qle_Zero_Qminus; stepr Qone; [auto|ring].
   stepl (Qone/(Qpos qp + Qone)); [|field; auto];
    apply Qmult_pos_Qdiv_Qle; auto;  stepr (Qpos qp+Qone); [|ring]; apply Qle_Zero_Qminus;  stepr (Qpos qp); [auto|ring].
   
 exists (1)%Z; split; auto.
Qed.

Theorem Q_Archimedean_inf:forall q:Q, {z:Z | q<=z /\ (z-q)<= Qone}.
Proof.
 intros [|qp|qp].  
 
 exists (0)%Z; split; auto.
 
 destruct (Qpositive_in_Q_Archimedean_inf qp) as [z Hz]; exists z; assumption.
   
 destruct (Qpositive_in_Q_Archimedean_inf qp) as [z [Hz1 Hz2]]; exists (-(z-1))%Z; rewrite Z_to_Qopp;
           rewrite (Z_to_Qminus); qZ_numerals; split; apply Qle_opp; apply Qle_Zero_Qminus; rewrite Qopp_Qpos.
  stepr (Qone-(z - Qpos qp)); [|ring]; apply Qle_Qminus_Zero; assumption.
  stepr (z-(Qpos qp));[|ring]; apply Qle_Qminus_Zero; assumption.
Qed.

Definition up_Q q:= proj1_sig (Q_Archimedean_inf q).

Definition up_Q_property q := proj2_sig (Q_Archimedean_inf q):  q <= (up_Q q) /\ (up_Q q) - q <= Qone.

Lemma Q_Archimedean_nat_inf:forall q:Q, {n:nat | q<=n }.
Proof.
 intro q.
 destruct (Q_le_lt_dec q Zero).
  exists O; qnat_zero.
  exists (Z.abs_nat (up_Q q)).
  destruct (up_Q_property q) as [H1 H2].  
  stepr (up_Q q); trivial.
   assert (H3:(0<=(up_Q q))%Z).
    assert (H4:Zero<Z_to_Q (up_Q q));[apply Qlt_le_trans with q; auto|];
    generalize (Q_to_Z_monotone _ _ H4); simpl; rewrite Q_to_Z_to_Q; trivial.
   rewrite (Z_of_nat_Zabs_nat_pos _ H3); reflexivity.
Qed.
