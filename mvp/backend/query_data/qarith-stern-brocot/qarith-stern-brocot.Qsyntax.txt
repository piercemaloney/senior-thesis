
Require Export general_Q.
(* general_Q:
Require Import FunInd.
Require Export Qpositive.
Require Export Q_field.
Require Export Q_order.
Require Import Field_Theory_Q. 
Require Export Zaux.

Lemma Z_of_nat_Zabs_nat_pos: forall z, (0<=z)%Z -> Z_of_nat (Z.abs_nat z) = z.

Definition make_Q (m n : Z) :=
  match m, n with
  | Zpos _, Zpos _ =>
      Qpos (Qpositive_c (Z.abs_nat m) (Z.abs_nat n) (Z.abs_nat m + Z.abs_nat n))
  | Zneg _, Zneg _ =>
      Qpos (Qpositive_c (Z.abs_nat m) (Z.abs_nat n) (Z.abs_nat m + Z.abs_nat n))
  | Z0, _ => Zero
  | _, Z0 => Zero  
  | _, _ =>
      Qneg (Qpositive_c (Z.abs_nat m) (Z.abs_nat n) (Z.abs_nat m + Z.abs_nat n))
  end.

Definition decode_Q (q : Q) :=
  match q with
  | Qpos p =>
      (Z_of_nat (fst (Qpositive_i p)), Z_of_nat (snd (Qpositive_i p)))
  | Qneg p =>
      ((- Z_of_nat (fst (Qpositive_i p)))%Z, Z_of_nat (snd (Qpositive_i p)))
  | Zero => (0%Z, 1%Z)
  end.

Definition numerator (q:Q) :Z := fst (decode_Q q).

Definition denominator (q:Q) :Z := snd (decode_Q q).

Definition Z_to_Qpositive : forall x : Z, (0 < x)%Z -> Qpositive.

Definition Z_to_Q (x : Z) : Q :=
  match x with
  | Z0 => Zero
  | Zpos p => Qpos (Qpositive_c (nat_of_P p) 1 (S (nat_of_P p)))
  | Zneg p => Qneg (Qpositive_c (nat_of_P p) 1 (S (nat_of_P p)))
  end.
 
Definition Qpositive_tail (z : Qpositive) :=
  match z with
  | nR p => p
  | dL p => p
  | One => One
  end.
 
Definition Q_tail (z : Q) :=
  match z with
  | Zero => One
  | Qpos p => p
  | Qneg p => p
  end.
 
Definition Qsgn (q : Q) :=
  match q with
  | Zero => 0%Z
  | Qpos _ => 1%Z
  | Qneg _ => (-1)%Z
  end.

Fixpoint length_of_Qpositive_to_positive (qp : Qpositive) : positive :=
  match qp with
  | One => 1%positive
  | dL qp' => Pos.succ (length_of_Qpositive_to_positive qp')
  | nR qp' => Pos.succ (length_of_Qpositive_to_positive qp')
  end.

Fixpoint length_of_Qpositive (qp : Qpositive) : Z :=
  match qp with
  | One => 0%Z
  | dL qp' => (1 + length_of_Qpositive qp')%Z
  | nR qp' => (1 + length_of_Qpositive qp')%Z
  end.

Fixpoint Qpositive_to_Z (qp : Qpositive) : Z :=
  match qp with
  | One => 1%Z
  | dL qp' => 0%Z
  | nR qp' => (1 + Qpositive_to_Z qp')%Z
  end.

Definition Q_to_Z (x : Q) : Z :=
  match x with
  | Zero => 0%Z
  | Qpos qp => Qpositive_to_Z qp
  | Qneg qp => (- Qpositive_to_Z qp)%Z
  end.

Coercion Z_to_Q : Z >-> Q.

Definition Qlt (x y : Q) : Prop := Qgt y x.

Definition Qle (x y : Q) : Prop := ~ Qlt y x. 

Lemma Qlt_zero_pos : forall x' : Qpositive, Qlt Zero (Qpos x').

Lemma Qlt_neg_pos : forall x' y' : Qpositive, Qlt (Qneg y') (Qpos x').

Lemma Qlt_neg_zero : forall x' : Qpositive, Qlt (Qneg x') Zero.

Hint Resolve Qlt_neg_pos Qlt_neg_zero Qlt_zero_pos.

Ltac QltCleanAbsurdCases :=
  match goal with
  | id1:(Qlt Zero (Qneg _)) |- _ => inversion id1
  | id1:(Qlt (Qpos _) Zero) |- _ =>
      inversion id1
  | id1:(Qlt (Qpos _) (Qneg _)) |- _ =>
      inversion id1
  | id1:(Qle Zero (Qneg _)) |- _ =>
      apply False_ind; apply id1; auto with *
  | id1:(Qle (Qpos _) Zero) |- _ =>
      apply False_ind; apply id1; auto with *
  | id1:(Qle (Qpos _) (Qneg _)) |- _ =>
      apply False_ind; apply id1; auto with *
  end.
 
Functional Scheme Qpositive_c_ind := Induction for Qpositive_c Sort Prop.

Lemma Qpositive_c_0 : forall p q n : nat, n = 0 -> Qpositive_c p q n = One.

Lemma Qpositive_c_1_0_0 :
 forall p q n' : nat, p - q = 0 -> q - p = 0 -> Qpositive_c p q (S n') = One.

Lemma Qpositive_c_equal_One :
 forall m n p : nat, m = n -> Qpositive_c m n p = One.

Lemma Qpositive_c_1_0_1 :
 forall p q n' : nat,
 p - q = 0 ->
 q - p <> 0 -> Qpositive_c p q (S n') = dL (Qpositive_c p (q - p) n').

Lemma Qpositive_c_dL :
 forall p q n' : nat,
 p < q -> Qpositive_c p q (S n') = dL (Qpositive_c p (q - p) n').

Lemma Qpositive_c_1_1 :
 forall p q n' : nat,
 p - q <> 0 -> Qpositive_c p q (S n') = nR (Qpositive_c (p - q) q n').

Lemma Qpositive_c_nR :
 forall p q n' : nat,
 q < p -> Qpositive_c p q (S n') = nR (Qpositive_c (p - q) q n').

Functional Scheme Qpositive_i_ind := Induction for Qpositive_i Sort Prop.
Lemma Qpositive_i_nR_with_let :
 forall w : Qpositive,
 let (p, q) := Qpositive_i w in Qpositive_i (nR w) = (p + q, q).

Lemma Qpositive_i_nR :
 forall (w : Qpositive) (p q : nat),
 Qpositive_i w = (p, q) -> Qpositive_i (nR w) = (p + q, q).

Lemma Qpositive_i_c :
 forall m p : nat,
 0 < m -> S m <= p -> Qpositive_i (Qpositive_c m 1 p) = (m, 1).

Lemma Qpositive_c_equal :
 forall m n p p' : nat,
 0 < m ->
 0 < n -> m + n <= p -> m + n <= p' -> Qpositive_c m n p = Qpositive_c m n p'.

Lemma Qpositive_c_equal_strong :
 forall m1 m2 n1 n2 p1 p2 : nat,
 m1 = m2 ->
 n1 = n2 ->
 0 < m1 ->
 0 < n1 ->
 m1 + n1 <= p1 ->
 m2 + n2 <= p2 -> Qpositive_c m1 n1 p1 = Qpositive_c m2 n2 p2.

Functional Scheme Qpositive_plus_ind := Induction for Qpositive_plus Sort Prop.

Lemma what_nR_does : forall p : Qpositive, nR p = Qpositive_plus p One.

Functional Scheme Qpositive_mult_ind := Induction for Qpositive_mult Sort Prop.

Lemma what_dL_does :
 forall p : Qpositive,
 dL p = Qpositive_mult p (Qpositive_inv (Qpositive_plus p One)).

Lemma Qpos_nR : forall p : Qpositive, Qpos (nR p) = Qplus (Qpos p) Qone.

Lemma Qmult_Z_nR :
 forall (a : Z) (p : Qpositive),
 Qmult (Z_to_Q a) (Qpos (nR p)) =
 Qplus (Qmult (Z_to_Q a) (Qpos p)) (Z_to_Q a).

Lemma Qpos_dL :
 forall p : Qpositive,
 Qpos (dL p) = Qmult (Qpos p) (Qinv (Qplus (Qpos p) Qone)).

Lemma Qmult_Z_dL :
 forall (a : Z) (p : Qpositive),
 Qmult (Z_to_Q a) (Qpos (dL p)) =
 Qmult (Qmult (Z_to_Q a) (Qpos p)) (Qinv (Qplus (Qpos p) Qone)).

Lemma length_of_Qpositive_is_length :
 forall p : positive,
 length_of_Qpositive (Qpositive_c (nat_of_P p) 1 (S (nat_of_P p))) =
 (Zpos p - 1)%Z.

Lemma Qpositive_to_Z_is_integer_part :
 forall x : positive,
 Qpositive_to_Z (Qpositive_c (nat_of_P x) 1 (S (nat_of_P x))) = Zpos x.
 
Lemma Q_to_Z_to_Q : forall x : Z, Q_to_Z (Z_to_Q x) = x.
  
Lemma eq_Z_to_Q : forall x y : Z, Z_to_Q x = Z_to_Q y -> x = y.

Lemma Z_to_Qpositive_equal :
 forall (m1 m2 : Z) (Hm1 : (0 < m1)%Z) (Hm2 : (0 < m2)%Z),
 m1 = m2 -> Z_to_Qpositive m1 Hm1 = Z_to_Qpositive m2 Hm2.

Functional Scheme Z_to_Q_ind := Induction for Z_to_Q Sort Prop.

Lemma Z_to_Qpositive_to_Q :
 forall (m : Z) (Hm : (0 < m)%Z), Z_to_Q m = Qpos (Z_to_Qpositive m Hm).

Lemma Qpos_injective :
 forall qp1 qp2 : Qpositive, Qpos qp1 = Qpos qp2 -> qp1 = qp2.

Lemma Qneg_injective :
 forall qp1 qp2 : Qpositive, Qneg qp1 = Qneg qp2 -> qp1 = qp2.

Lemma Q_tail_Q_pos : forall q : Q, Qlt Zero q -> q = Qpos (Q_tail q).

Lemma Q_tail_Q_neg : forall q : Q, Qlt q Zero -> q = Qneg (Q_tail q).

Lemma Qpositive_to_Z_nonneg : forall x : Qpositive, (0 <= Qpositive_to_Z x)%Z.
 
Functional Scheme Qpositive_le_bool_ind := 
  Induction for Qpositive_le_bool Sort Prop.

Lemma Qpositive_to_Z_Qpositive_le :
 forall x y : Qpositive,
 (Qpositive_to_Z x < Qpositive_to_Z y)%Z -> Qpositive_le x y.

Lemma Q_to_Z_monotone : forall x y : Q, Qlt x y -> (Q_to_Z x <= Q_to_Z y)%Z.

Lemma Qlt_irreflexive : forall x : Q, ~ Qlt x x.

Hint Resolve Qlt_irreflexive.

Lemma Qlt_not_eq : forall x y : Q, Qlt x y -> y <> x.

Hint Resolve Qlt_not_eq.

Lemma Qlt_transitive : forall x y z : Q, Qlt x y -> Qlt y z -> Qlt x z.

Lemma Z_to_Qopp : forall x : Z, Z_to_Q (- x) = Qopp (Z_to_Q x).

Lemma Z_to_Qplus_POS :
 forall p1 p2 : positive,
 Z_to_Q (Zpos p1 + Zpos p2) = Qplus (Z_to_Q (Zpos p1)) (Z_to_Q (Zpos p2)).

Lemma Z_to_Qplus_POS_NEG :
 forall p1 p2 : positive,
 Z_to_Q (Zpos p1 + Zneg p2) = Qplus (Z_to_Q (Zpos p1)) (Z_to_Q (Zneg p2)).
 
Lemma Z_to_Qplus_NEG :
 forall p1 p2 : positive,
 Z_to_Q (Zneg p1 + Zneg p2) = Qplus (Z_to_Q (Zneg p1)) (Z_to_Q (Zneg p2)).

Lemma Z_to_Qplus :
 forall x y : Z, Z_to_Q (x + y) = Qplus (Z_to_Q x) (Z_to_Q y).

Lemma Z_to_Qminus :
 forall x y : Z, Z_to_Q (x - y) = Qminus (Z_to_Q x) (Z_to_Q y).

Lemma Z_to_Qmult_POS :
 forall p1 p2 : positive,
 Z_to_Q (Zpos p1 * Zpos p2) = Qmult (Z_to_Q (Zpos p1)) (Z_to_Q (Zpos p2)).

Lemma Z_to_Qmult_POS_NEG :
 forall p1 p2 : positive,
 Z_to_Q (Zpos p1 * Zneg p2) = Qmult (Z_to_Q (Zpos p1)) (Z_to_Q (Zneg p2)).

Lemma Z_to_Qmult_NEG :
 forall p1 p2 : positive,
 Z_to_Q (Zneg p1 * Zneg p2) = Qmult (Z_to_Q (Zneg p1)) (Z_to_Q (Zneg p2)).

Lemma Z_to_Qmult :
 forall x y : Z, Z_to_Q (x * y) = Qmult (Z_to_Q x) (Z_to_Q y).

Lemma Z_to_Q_S:forall k, Z_to_Q (Z_of_nat (S k))=Qplus k Qone.

Lemma Z_to_Q_min_one:Z_to_Q (-1)%Z= Qopp Qone.

Lemma Qlt_Zero_Qminus : forall x y : Q, Qlt Zero (Qminus y x) -> Qlt x y. 

Lemma Z_to_Qlt : forall x y : Z, (x < y)%Z -> Qlt x y.

Lemma lt_Z_to_Q : forall x y : Z, Qlt (Z_to_Q x) (Z_to_Q y) -> (x < y)%Z.
 
Lemma pos_Z_to_Q : forall x : Z, Qlt Zero (Z_to_Q x) -> (0 < x)%Z.

Lemma neg_Z_to_Q : forall x : Z, Qlt (Z_to_Q x) Zero -> (x < 0)%Z.

Lemma Qlt_le_weak : forall x y : Q, Qlt x y -> Qle x y.

Lemma Z_to_Qle : forall x y : Z, (x <= y)%Z -> Qle x y.

Lemma Z_to_Q_pos : forall x : Z, (0 < x)%Z -> Qlt Zero x.

Lemma Z_to_Q_neg : forall x : Z, (x < 0)%Z -> Qlt x Zero.

Lemma Z_to_Q_nonneg : forall x : Z, (0 <= x)%Z -> Qle Zero x.

Lemma Z_to_Q_nonpos : forall x : Z, (x <= 0)%Z -> Qle x Zero.

Lemma Z_to_Q_not_eq : forall a b : Z, a <> b -> Z_to_Q a <> Z_to_Q b.

Lemma Qmult_Z_plus_Z_dL :
 forall (a b : Z) (p : Qpositive),
 Qplus (Qmult (Z_to_Q a) (Qpos (dL p))) (Z_to_Q b) =
 Qmult (Qplus (Qmult (Z_to_Q (a + b)) (Qpos p)) (Z_to_Q b))
   (Qinv (Qplus (Qpos p) Qone)).

Lemma Qinv_0 : forall q : Q, Qinv q = Zero -> q = Zero. 

Lemma Qmult_resp_nonzero :
 forall x y : Q, x <> Zero -> y <> Zero -> Qmult x y <> Zero.

Hint Resolve Qmult_resp_nonzero.

Lemma Qlt_mult_pos_pos :
 forall x y : Q, Qlt Zero x -> Qlt Zero y -> Qlt Zero (Qmult x y).

Lemma Qlt_mult_neg_pos :
 forall x y : Q, Qlt x Zero -> Qlt Zero y -> Qlt (Qmult x y) Zero.

Hint Resolve Qlt_mult_pos_pos Qlt_mult_neg_pos.

Lemma Qlt_plus_pos_pos :
 forall x y : Q, Qlt Zero x -> Qlt Zero y -> Qlt Zero (Qplus x y).

Hint Resolve Qlt_plus_pos_pos.

Lemma Qdiv_num_denom :
 forall q1 q2 p : Q,
 p <> Zero -> Qmult q1 (Qinv q2) = Qmult (Qmult q1 p) (Qinv (Qmult q2 p)).

Lemma Qinv_1 : forall q : Q, Qlt Zero (Qinv q) -> Qlt Zero q.

Lemma Qinv_2 : forall q : Q, Qlt (Qinv q) Zero -> Qlt q Zero.

Lemma Qinv_pos : forall q : Q, Qlt Zero q -> Qlt Zero (Qinv q).

Lemma Qmult_one_right : forall x : Q, Qmult x Qone = x.

Lemma Qpos_POS_1 :
 forall (m : Z) (qp : Qpositive), Z_to_Q m = Qpos qp -> (0 < m)%Z.

Lemma Qneg_NEG_1 :
 forall (m : Z) (qp : Qpositive), Z_to_Q m = Qneg qp -> (m < 0)%Z.

Lemma Qopp_Qpos : forall q : Qpositive, Qneg q = Qopp (Qpos q).

Lemma Qopp_Qneg : forall q : Qpositive, Qpos q = Qopp (Qneg q).

Lemma Qopp_linear :
 forall (a b : Z) (q : Qpositive),
 Qplus (Qmult (Z_to_Q (- a)) (Qpos q)) (Z_to_Q (- b)) =
 Qopp (Qplus (Qmult (Z_to_Q a) (Qpos q)) (Z_to_Q b)).

Lemma Qopp_resp_nonzero : forall x : Q, x <> Zero -> Qopp x <> Zero.

Lemma Qinv_Qopp : forall q : Q, Qinv (Qopp q) = Qopp (Qinv q).

Lemma Qmult_Qopp_left : forall x y : Q, Qmult (Qopp x) y = Qopp (Qmult x y).

Lemma Qpositive_dec_One : forall p : Qpositive, {p = One} + {p <> One}.

Lemma Q_zerop : forall x : Q, {x = Zero} + {x <> Zero}.
 
Lemma Qinv_resp_nonzero : forall x : Q, x <> Zero -> Qinv x <> Zero.

Lemma Qlt_zero_one : Qlt Zero Qone.

Hint Resolve Qlt_zero_one.

Lemma Z_to_Qpositive_Q_tail_pos :
 forall (a : Z) (Ha : (0 < a)%Z), Z_to_Qpositive a Ha = Q_tail a.

Lemma Q_tail_Qinv : forall x : Q, Q_tail (Qinv x) = Qpositive_inv (Q_tail x).

Lemma Q_tail_Qmult :
 forall x y : Q,
 x <> Zero ->
 y <> Zero -> Q_tail (Qmult x y) = Qpositive_mult (Q_tail x) (Q_tail y). 

Lemma Q_tail_Qplus_pos :
 forall x y : Q,
 Qlt Zero x ->
 Qlt Zero y -> Q_tail (Qplus x y) = Qpositive_plus (Q_tail x) (Q_tail y). 

Lemma Q_tail_Qplus_neg :
 forall x y : Q,
 Qlt x Zero ->
 Qlt y Zero -> Q_tail (Qplus x y) = Qpositive_plus (Q_tail x) (Q_tail y). 

Lemma Qplus_zero_right : forall n : Q, Qplus n Zero = n.

Lemma Qmult_zero_right : forall x : Q, Qmult x Zero = Zero.

Lemma Qle_Qpositive_le_pos :
 forall x y : Qpositive, Qle (Qpos x) (Qpos y) -> Qpositive_le x y.

Lemma Qle_Qpositive_le_neg :
 forall x y : Qpositive, Qle (Qneg x) (Qneg y) -> Qpositive_le y x.

Lemma Qle_lt_eq_dec : forall x y : Q, Qle x y -> {Qlt x y} + {x = y}.

Lemma Qle_lt_trans : forall x y z : Q, Qle x y -> Qlt y z -> Qlt x z.

Lemma Qlt_le_trans : forall x y z : Q, Qlt x y -> Qle y z -> Qlt x z.

Lemma Qle_trans : forall x y z : Q, Qle x y -> Qle y z -> Qle x z.

Lemma Qlt_plus_plus :
 forall a b c d : Q, Qlt a b -> Qlt c d -> Qlt (Qplus a c) (Qplus b d).

Lemma Qle_lt_reg :
 forall a b c d : Q, Qle a b -> Qlt c d -> Qlt (Qplus a c) (Qplus b d).

Lemma Qlt_le_reg :
 forall a b c d : Q, Qlt a b -> Qle c d -> Qlt (Qplus a c) (Qplus b d).

Lemma Qlt_le_reg_pos :
 forall b d : Q, Qlt Zero b -> Qle Zero d -> Qlt Zero (Qplus b d).

Lemma Qle_lt_reg_pos :
 forall b d : Q, Qle Zero b -> Qlt Zero d -> Qlt Zero (Qplus b d).

Lemma Qlt_le_reg_neg :
 forall b d : Q, Qlt b Zero -> Qle d Zero -> Qlt (Qplus b d) Zero.
 
Lemma Qle_lt_reg_neg :
 forall b d : Q, Qle b Zero -> Qlt d Zero -> Qlt (Qplus b d) Zero.

Lemma Qle_plus_plus :
 forall a b c d : Q, Qle a b -> Qle c d -> Qle (Qplus a c) (Qplus b d).

Lemma Qle_plus_pos_pos :
 forall x y : Q, Qle Zero x -> Qle Zero y -> Qle Zero (Qplus x y).

Lemma Qle_plus_neg_neg :
 forall x y : Q, Qle x Zero -> Qle y Zero -> Qle (Qplus x y) Zero.

Lemma Qle_mult_nonneg_nonneg :
 forall x y : Q, Qle Zero x -> Qle Zero y -> Qle Zero (Qmult x y).

Lemma Qle_mult_nonpos_nonneg :
 forall x y : Q, Qle x Zero -> Qle Zero y -> Qle (Qmult x y) Zero.

Lemma Qle_mult_nonneg_nonpos :
 forall x y : Q, Qle Zero x -> Qle y Zero -> Qle (Qmult x y) Zero.

Lemma Qle_mult_nonpos_pos:
 forall x y : Q, Qle x Zero -> Qlt Zero y -> Qle (Qmult x y) Zero.

Lemma Qle_mult_neg_nonneg :
 forall x y : Q, Qlt x Zero -> Qle Zero y -> Qle (Qmult x y) Zero.

Lemma Qle_reflexive:forall x, Qle x x.

Hint Resolve Qplus_zero_right Qlt_le_reg_pos Qle_lt_reg_pos Qlt_le_reg
  Qle_lt_reg Qlt_le_weak Qlt_le_reg_neg Qle_lt_reg_neg Qle_plus_pos_pos
  Qle_plus_neg_neg Qle_mult_nonneg_nonneg Qle_mult_nonneg_nonpos
  Qle_mult_nonpos_nonneg Qle_mult_nonpos_pos Qle_mult_neg_nonneg
  Qle_reflexive.

Lemma Qpos_not_lt_Zero : forall x, ~ Qlt (Qpos x) Zero.

Lemma Qlt_dec_Qpos : forall x y, {~ Qlt (Qpos y) (Qpos x)} + {Qlt (Qpos y) (Qpos x)}.

Lemma Zero_not_lt_Qneg : forall x, ~ Qlt Zero (Qneg x).

Lemma Qpos_not_lt_Qneg : forall x y, ~ Qlt (Qpos y) (Qneg x).

Lemma Qlt_dec_Qneg : forall x y, {~ Qlt (Qneg y) (Qneg x)} + {Qlt (Qneg y) (Qneg x)}.

Lemma Q_le_lt_dec:forall (x y:Q), {Qle x y}+{Qlt y x}.

Lemma Qle_dec:forall (x y:Q), {Qle x y}+{~(Qle x y)}.

Lemma Qlt_dec:forall (x y:Q), {Qlt x y}+{~(Qlt x y)}.

Lemma Qtrichotomy_inf:forall x y,{Qlt x y}+{x=y}+{Qlt y x}.

Lemma Qle_dec_weak:forall (x y:Q), {Qle x y}+{(Qle y x)}.

Lemma not_Qeq_inf : forall x y : Q, x <> y -> {Qlt x y} + {Qlt y x}.

Lemma Qlt_stepl:forall x y z, Qlt x y -> x=z -> Qlt z y.

Lemma Qlt_stepr:forall x y z, Qlt x y -> y=z -> Qlt x z.

Lemma Qle_stepl:forall x y z, Qle x y -> x=z -> Qle z y.

Lemma Qle_stepr:forall x y z, Qle x y -> y=z -> Qle x z.

Lemma Qneq_stepl:forall (x y z:Q), x<>y -> x=z -> z<>y.

Lemma Qneq_stepr:forall (x y z:Q), x<>y -> y=z -> x<>z.

Declare Left Step Qlt_stepl.
Declare Right Step Qlt_stepr.
Declare Left Step Qle_stepl.
Declare Right Step Qle_stepr.
Declare Left Step Qneq_stepl.
Declare Right Step Qneq_stepr.

Lemma Qsgn_1: forall x:Q,{(Qsgn x) = 0}+{(Qsgn x) = 1}+{(Qsgn x) = (-1)%Z}. 

Lemma Qsgn_2 : forall x : Q, Qsgn x = 0%Z -> x = Zero.

Lemma Qsgn_7 : forall x : Q, Qlt Zero x -> Qsgn x = 1%Z.

Lemma Qsgn_8 : forall x : Q, Qlt x Zero -> Qsgn x = (-1)%Z.

Lemma Qsgn_9 : forall x : Q, Qsgn x = 1%Z -> Qlt Zero x.

Lemma Qsgn_10 : forall x : Q, Qsgn x = (-1)%Z -> Qlt x Zero.

Lemma Qsgn_15 : forall x y : Q, Qsgn (Qmult x y) = (Qsgn x * Qsgn y)%Z.
 
Lemma Qsgn_25 : forall x : Q, Qsgn (Qopp x) = (- Qsgn x)%Z.

Lemma Qsgn_28 : forall x : Q, Qsgn (Qinv x) = Qsgn x.

Lemma Qsgn_29 : forall x : Z, Qsgn (Z_to_Q x) = Z.sgn x. 

Lemma Qsgn_30 : forall x y : Q, Qsgn (Qdiv x y) = (Qsgn x * Qsgn y)%Z.

Lemma Qsgn_31:forall x:Q, Qle x Zero-> Qsgn x <> 1.

Lemma Qsgn_32:forall x:Q, Qsgn x <> 1 -> Qle x  Zero.

Lemma Qsgn_33:forall x:Q, Qle Zero x -> Qsgn x <> (-1)%Z.

Lemma Qsgn_34:forall x:Q, Qsgn x <> (-1)%Z -> Qle Zero x.

Hint Resolve Qsgn_2 Qsgn_7 Qsgn_8 Qsgn_9 Qsgn_10 Qsgn_15 Qsgn_25 Qsgn_28
  Qsgn_29 Qsgn_30.

Ltac qnat_zero :=  replace (Z_to_Q (Z_of_nat 0)) with Zero;  trivial.
Ltac natq_zero :=  replace Zero with (Z_to_Q (Z_of_nat 0));  trivial.
Ltac qnat_one :=  replace (Z_to_Q (Z_of_nat (S 0))) with Qone;  trivial.
Ltac natq_one :=  replace Qone with (Z_to_Q (Z_of_nat (S 0)));  trivial.
Ltac qnat_S k :=  replace (Z_to_Q (Z_of_nat (S k))) with (Qplus k Qone); [idtac | rewrite Z_to_Q_S; trivial].
Ltac natq_S k :=  try qnat_one; replace (Qplus k Qone) with (Z_to_Q (Z_of_nat (S k))); [idtac | rewrite <- Z_to_Q_S; trivial].
Ltac qnat_S_rec k :=  
             try qnat_one; replace (Qplus k Qone) with (Z_to_Q (Z_of_nat (S k))); [idtac | rewrite <- Z_to_Q_S; trivial];
             try qnat_S_rec (k-1).

Ltac natZ_numerals  := 
 match goal with 
 | [ |- context [Z0] ] => replace Z0 with (Z_of_nat O); trivial; natZ_numerals
 | [ |- context [(Zpos ?X1)] ] => let v:= eval compute in (Z.abs_nat (Z.pred (Zpos X1))) in 
         replace (Zpos X1) with (Z_of_nat (S v)); trivial; natZ_numerals
 | [ |- context [(Zneg ?X1)] ] => let v:= eval compute in (Z.abs_nat (Z.succ (Zpos X1))) in 
         replace (Zneg X1) with (Z.opp (Z_of_nat (S v))); trivial; natZ_numerals
 | [ |- _ ] => idtac
 end. *)

Infix "/" := make_Q : Q_scope. 

Notation "{ x }" := (decode_Q x) : Q_scope.

Open Scope Q_scope.

Infix "+" := Qplus : Q_scope.

Infix "*" := Qmult : Q_scope.

Infix "-" := Qminus : Q_scope.

Infix "/" := Qdiv : Q_scope.

Notation "- x" := (Qopp x) : Q_scope.

Notation "x1 ^" := (Qinv x1) (at level 2, left associativity) : Q_scope.

Delimit Scope Q_scope with Q.

Infix "<" := Qlt : Q_scope.
Infix "<=" := Qle : Q_scope.

