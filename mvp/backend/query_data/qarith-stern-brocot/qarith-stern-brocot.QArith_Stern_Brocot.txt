
Require Export Qsyntax.
(* Qsyntax:
Require Export general_Q.

Infix "/" := make_Q : Q_scope. 

Notation "{ x }" := (decode_Q x) : Q_scope.

Open Scope Q_scope.

Infix "+" := Qplus : Q_scope.

Infix "*" := Qmult : Q_scope.

Infix "-" := Qminus : Q_scope.

Infix "/" := Qdiv : Q_scope.

Notation "- x" := (Qopp x) : Q_scope.

Notation "x1 ^" := (Qinv x1) (at level 2, left associativity) : Q_scope.

Delimit Scope Q_scope with Q.

Infix "<" := Qlt : Q_scope.
Infix "<=" := Qle : Q_scope. *)
Require Export Field_Theory_Q.
(* Field_Theory_Q:
Require Import Eqdep_dec.
Require Export Field.
Require Export Q_order.

Lemma Q_Ring_Theory :
    ring_theory Zero Qone Qplus Qmult Qminus Qopp (eq(A:=Q)).

Lemma Qinv_defT : forall n : Q, n <> Zero -> Qmult (Qinv n) n = Qone.

Lemma QField :
  field_theory Zero Qone Qplus Qmult Qminus Qopp Qdiv Qinv (eq(A:=Q)).

Ltac isQcst t :=
  match t with
    Zero => true
  | Qpos ?p => isQcst p
  | Qneg ?p => isQcst p
  | nR ?p => isQcst p
  | dL ?p => isQcst p
  | One => true
  | Qone => true
  | _ => false
  end.
Ltac Qcst t :=
  match isQcst t with
  | true => t
  | _ => InitialRing.NotConstant
  end.
 
Add Field Qfield : QField (decidable Q_eq_prop, constants [Qcst]).

Definition not_eq2eqT (A : Set) (x y : A) (H1 : x <> y) : 
  x <> y := fun H2 : x = y => H1 (H2).

Ltac Field := field. *)
Require Export Q_ordered_field_properties.
(* Q_ordered_field_properties:
Require Export Qsyntax.
Require Export Field_Theory_Q.

Lemma Qmult_absorb_nonzero_r: forall x y : Q, x * y <> Zero -> y <> Zero.

Lemma Qmult_absorb_nonzero_l: forall x y : Q, x * y <> Zero -> x <> Zero.

Lemma Qle_Qminus_Zero: forall x y: Q, x <= y -> Zero <= y-x.

Lemma Qle_Qminus_Zero_neg: forall x y : Q, x <= y -> x-y <= Zero.

Lemma Qle_Zero_Qminus_neg: forall x y : Q, x-y <= Zero -> x <= y.

Lemma Qle_Zero_Qminus: forall x y: Q,  Zero <= y-x -> x <= y.

Lemma Qmult_mult_nonneg: forall x:Q, Zero <= x*x.

Lemma Qmult_mult_pos: forall x:Q, x<> Zero -> Zero < x*x.

Lemma Qlt_opp:forall x y, Qopp x < Qopp y -> y < x.

Lemma Qlt_plus:forall x y z : Q, x < y -> z + x < z + y.

Lemma Qlt_Qminus_Zero: forall x y : Q, x < y -> Zero < y - x.

Lemma Qlt_Qminus_Zero_neg: forall x y : Q, x < y -> x-y < Zero.

Lemma Qlt_Zero_Qminus_neg: forall x y : Q, x-y < Zero -> x < y.

Lemma Qlt_reg_mult_pos_l: forall x y z : Q, Zero < x -> y < z -> x * y < x * z.

Lemma Qlt_reg_mult_pos_r: forall x y z : Q, Zero < x -> y < z -> y * x < z * x.

Lemma Qlt_reg_mult_neg_l: forall x y z : Q, x < Zero -> y < z -> x * z < x * y.

Lemma Qlt_reg_mult_neg_r: forall x y z : Q, x < Zero -> y < z -> z * x < y * x.

Lemma Qdiv_Qmult_pos:forall x y z t: Q, Zero < z*t -> x/z < y/t -> x*t < y*z. 

Lemma Qinv_involutive:forall x:Q, x<>Zero -> Qinv (Qinv x) = x.

Lemma Qmult_Qdiv_pos:forall x y z t: Q, Zero < z*t -> x*t < y*z -> x/z < y/t.

Lemma Qlt_Qopp_pos: forall x: Q, x < Zero -> Zero < - x.

Lemma Qlt_Qopp_neg: forall x: Q, Zero < x -> -x < Zero.

Lemma Qmult_one_left:forall x : Q, Qone * x = x.

Lemma Qdiv_Qone_Qone: Qdiv Qone Qone = Qone.

Lemma Qinv_Qdiv_Qone:forall x, Qinv x = Qone/x. 

Lemma Qminus_Qdiv:forall x y z t, z<>Zero -> t<>Zero -> x/z - y/t = (x*t-y*z)/(z*t).

Lemma Qplus_Qdiv:forall x y z t, z<>Zero -> t<>Zero -> x/z + y/t = (x*t+y*z)/(z*t).

Definition Qmult_Qinv_l:= Qinv_defT. 

Lemma Qmult_Qinv_r:forall x, x <> Zero -> x * (Qinv x) = Qone.

Lemma Qinv_Qmult:forall x y, x<>Zero -> y <> Zero -> Qinv (x*y) = (Qinv x)*(Qinv y).

Lemma Qplus_Qdiv_one:forall p q, q<> Zero -> (p+q) / q = p/q + Qone.

Lemma Qdiv_Qopp_numerator: forall x y : Q, y<> Zero -> Qdiv (-x) y = - (Qdiv x  y).

Lemma Qdiv_Qopp_denomintor: forall x y : Q, y<> Zero -> Qdiv x (-y) = - (Qdiv x  y).

Lemma Qdiv_Qdiv_simplify:forall x y z, z<> Zero -> y<> Zero -> (x/z)/(y/z) = x/y.

Lemma Qdiv_Qmult_Qone_denominator:forall x y z, z<>Zero -> y<>Zero -> x/(y*z) = (x/y)*(Qone/z).

Lemma Qdiv_Qmult_numerator_l: forall (x y z:Q), y<>Zero -> z*(x/y)=(z*x)/y.

Lemma Qdiv_Qmult_numerator_r: forall (x y z:Q), y<>Zero -> (x/y)*z=(x*z)/y.

Lemma Qlt_Qmult_cancel_l: forall x y z : Q, Zero < x -> x * y < x * z -> y < z.

Lemma Qlt_Qmult_cancel_r: forall x y z : Q, Zero < x -> y * x< z * x -> y < z.

Definition Qmult_resp_Qlt_pos_r:= Qlt_Qmult_cancel_r :  forall t x y : Q, Zero < t -> x * t < y * t -> x < y.

Definition Qmult_resp_Qlt_pos_l:= Qlt_Qmult_cancel_l: forall t x y : Q, Zero < t -> t * x < t * y -> x < y.

Lemma Qmult_resp_Qlt_neg_r: forall t x y : Q, t < Zero -> x * t < y * t -> y < x.

Lemma Qmult_resp_Qlt_neg_l: forall t x y : Q, t < Zero -> t * x < t * y -> y < x.

Lemma Qeq_Qminus : forall x y, x=y -> x-y=Zero.

Lemma Qminus_Qeq : forall x y, x-y=Zero -> x=y.

Lemma Qlt_not_eq': forall x y : Q, x < y -> x <> y.

Lemma Qinv_neg: forall q : Q, q<Zero -> Qinv q< Zero.

Lemma Qle_Qopp_pos:forall q : Q, q<= Zero -> Zero<= Qopp q.

Lemma Qopp_Qone_Qlt_Qone: Qopp Qone < Qone.

Hint Resolve Qinv_pos Qinv_resp_nonzero Qminus_Qeq Qeq_Qminus
             Qlt_not_eq' Qinv_neg Qle_Qopp_pos Qlt_Qopp_pos 
             Qlt_Qopp_neg Qopp_Qone_Qlt_Qone.

Lemma Qle_mult_nonneg_pos: forall x y : Q, Zero <= x -> Zero < y -> Zero <= x * y.

Lemma Qle_mult_pos_nonneg: forall x y : Q, Zero<x -> Zero <= y -> Zero <= x * y.

Lemma Qle_mult_nonpos_neg: forall x y : Q, x<=Zero -> y<Zero -> Zero <= x * y.

Lemma Qle_mult_neg_nonpos: forall x y : Q, x<Zero -> y<=Zero -> Zero <= x * y.

Lemma Qle_Qdiv_nonpos_pos: forall x y : Q, x <= Zero -> Zero < y -> x / y <= Zero.

Lemma Qle_Qdiv_nonneg_neg: forall x y : Q, Zero <= x -> y < Zero -> x / y <= Zero.

Lemma Qle_Qdiv_nonneg_pos: forall x y : Q, Zero<=x -> Zero < y -> Zero<=x / y.

Lemma Qle_Qdiv_nonpos_neg: forall x y : Q, x<=Zero -> y<Zero -> Zero<=x / y.

Lemma Qlt_mult_neg_neg: forall x y : Q, x<Zero-> y<Zero -> Zero < x * y.

Lemma Qmult_reg_l: forall x y z: Q, z <> Zero -> z*x = z*y -> x=y.

Lemma Qmult_reg_r: forall x y z: Q, z <> Zero -> x*z = y*z -> x=y.

Lemma Qmult_Qdiv: forall x y z t : Q,  z <> Zero  -> t <> Zero -> x * t = y * z -> x / z = y / t.

Lemma Qdiv_Qmult: forall x y z t : Q,  z <> Zero  -> t <> Zero -> x / z = y / t -> x * t = y * z.

Lemma Qdiv_Qdiv_Qmult_numerator: forall x y z, y<>Zero -> z<>Zero ->(x/y)/z = x/(y*z).

Lemma Qdiv_Qdiv_Qmult_denominator: forall x y z, y<>Zero -> z<>Zero -> x/(y/z) = (x*z)/y.

Lemma Qdiv_Qplus_Qmult: forall x y z, y<>Zero -> x/y + z = (x+y*z)/y.

Lemma Qdiv_Qminus_Qmult: forall x y z, y<>Zero -> x/y - z = (x-y*z)/y.

Lemma Qminus_Qdiv_Qmult: forall x y z, ~(y=Zero)->z-x/y=(y*z-x)/y.

Lemma Qplus_Qdiv_Qmult: forall x y z, ~(y=Zero)->z+x/y=(y*z+x)/y.

Lemma Qle_reg_mult_r: forall x y z : Q, Zero < x -> y <=z -> y * x <=z * x.

Lemma Qle_reg_mult_l: forall x y z : Q, Zero < x -> y <= z -> x * y <= x * z.

Lemma Qmult_resp_Qle_pos_r: forall t x y : Q, Zero < t -> x * t <= y * t -> x <= y.

Lemma Qmult_resp_Qle_pos_l: forall t x y : Q, Zero < t -> t * x <= t * y -> x <= y.

Lemma Qmult_resp_Qle_neg_r: forall t x y : Q, t < Zero -> x * t <= y * t -> y <= x.

Lemma Qmult_resp_Qle_neg_l: forall t x y : Q, t < Zero -> t * x <= t * y -> y <= x.

Lemma Qmult_Qdiv_pos_Qle: forall x y z t : Q, Zero < z -> Zero < t -> x * t <= y * z -> x / z <= y / t.

Lemma Qmult_Qle_compat: forall n m p q : Q, n <= p -> m <= q -> Zero <= n -> Zero <= m -> n * m <= p * q.

Lemma Qdiv_num_denom_explicit: forall q1 q2 p : Q, q2 <> Zero -> p <> Zero -> q1 / q2 = (q1 * p)/ (q2 * p).

Lemma Qle_opp: forall x y : Q, - x <= - y -> y <= x.

Lemma Qmult_pos_Qle_Qdiv: forall x y z : Q, Zero<z -> x * z<=y -> x <= y / z.

Lemma Qmult_neg_Qle_Qdiv: forall x y z : Q, z <Zero -> y <= x * z -> x <= y / z.

Lemma Qmult_pos_Qdiv_Qle: forall x y z : Q, Zero<z -> y<=x*z -> y/z <= x.

Lemma Qmult_neg_Qdiv_Qle: forall x y z : Q, z <Zero -> x*z<=y -> y/z<=x.

Lemma Qmult_pos_Qlt_Qdiv: forall x y z : Q, Zero<z -> x * z<y -> x < y/z.

Lemma Qmult_neg_Qlt_Qdiv: forall x y z : Q, z <Zero -> y < x * z -> x < y / z.

Lemma Qmult_pos_Qdiv_Qlt: forall x y z : Q, Zero<z -> y<x*z -> y/z < x.

Lemma Qmult_neg_Qdiv_Qlt: forall x y z : Q, z <Zero -> x*z<y -> y/z<x.

Lemma Qmult_Qdiv_pos_neg_Qle:forall x y z t : Q,  Zero < z -> t<Zero -> y * z <= x * t -> x / z <= y / t.

Lemma Qmult_Qdiv_neg_pos_Qle:forall x y z t : Q,  z<Zero -> Zero<t -> y * z <= x * t -> x / z <= y / t.

Lemma Qmult_Qdiv_neg_Qle:forall x y z t : Q,  z<Zero -> t<Zero -> x * t<=y * z -> x / z <= y / t.

Lemma Qopp_involutive: forall q, Qopp (Qopp q) = q.

Lemma Qopp_Qle: forall x y, y <= x -> - x <= - y.

Lemma Qopp_Qlt: forall x y, y < x -> - x < - y.

Lemma Qle_reg_mult_r_strong: forall x y z : Q, Zero <= x -> y <= z -> y * x <= z * x.

Lemma Qle_reg_mult_l_strong: forall x y z : Q, Zero <= x -> y <= z -> x * y <= x * z.

Lemma Qlt_Qdiv_denom_neg_neg: forall x y:Q, y<Zero -> x / y < Zero ->  Zero < x.

Lemma Qlt_Qdiv_denom_neg_pos: forall x y:Q, y<Zero ->  Zero< x / y  -> x<Zero.

Lemma Qlt_Qdiv_denom_pos_neg: forall x y:Q, Zero<y -> x / y < Zero ->  x<Zero.

Lemma Qlt_Qdiv_denom_pos_pos: forall x y:Q, Zero<y ->  Zero< x / y  -> Zero<x.

Lemma Qle_Qdiv_denom_neg_nonpos: forall x y:Q, y<Zero -> x / y <= Zero ->  Zero <= x.

Lemma Qle_Qdiv_denom_neg_nonneg: forall x y:Q, y<Zero ->  Zero<= x / y  -> x<=Zero.

Lemma Qle_Qdiv_denom_pos_nonpos: forall x y:Q, Zero<y -> x / y <= Zero ->  x<=Zero.

Lemma Qle_Qdiv_denom_pos_nonneg: forall x y:Q, Zero<y ->  Zero<= x / y  -> Zero<=x.

Lemma Qlt_neg_Qopp: forall x : Q, - x < Zero->Zero < x.

Lemma Qlt_pos_Qopp: forall x : Q, Zero < - x->x<Zero.

Lemma Qmult_mult_Qle_Qone_Qopp_Qone: forall q, -Qone<=q -> q<= Qone -> q*q <= Qone. 

Lemma Qinv_resp_nonzero_Qdiv:forall q, q <> Zero -> (Qone/q)<>Zero. 

Lemma Qmult_Qlt_Qle_nonneg_pos_compat: forall n m p q, n < p -> m <= q -> Zero <= n -> Zero < q -> n * m < p * q.

Lemma Qmult_Qlt_Qle_pos_nonneg_compat: forall n m p q, n <= p -> m < q -> Zero < p -> Zero <= m -> n * m < p * q.

Ltac qZ_numerals_one  :=replace (Z_to_Q 1) with Qone;  trivial. 

Ltac qZ_numerals  := 
 match goal with 
 | [ |- context [(Z_to_Q (Z_of_nat ?X1))] ] => unfold Z_of_nat; qZ_numerals
 | [ |- context [(Z_to_Q Z0)] ] => replace (Z_to_Q Z0) with Zero; trivial; qZ_numerals
 | [ |- context [(Z_to_Q (Zpos ?X1))] ] => progress  let v:= eval compute in (Z.pred (Zpos X1)) in 
         replace (Z_to_Q (Zpos X1)) with (Qplus Qone (Z_to_Q v)); trivial; qZ_numerals
 | [ |- context [(Z_to_Q (Zneg ?X1))] ] => let v:= eval compute in (Z.succ (Zneg X1)) in 
        replace (Z_to_Q (Zneg X1)) with (Qminus (Z_to_Q v) Qone); trivial; qZ_numerals
 | [ |- context [(Qplus Zero ?X1)] ] => rewrite Qplus_zero_left; qZ_numerals
 | [ |- context [(Qplus ?X1 Zero)] ] => rewrite Qplus_zero_right; qZ_numerals
 | [ |- context [(Qminus Zero ?X1)] ] => unfold Qminus; rewrite Qplus_zero_left; qZ_numerals
 | [ |- context [(Qminus ?X1 Zero)] ] => unfold Qminus; rewrite Qplus_zero_right; qZ_numerals
 | [ |- context [(Qmult Qone ?X1)] ] => rewrite Qmult_one_left; qZ_numerals
 | [ |- context [(Qmult ?X1 Qone)] ] => rewrite Qmult_one_right; qZ_numerals
 | [ |- _ ] => idtac
 end.

Ltac ring_exact_Q hyp := 
 match type of hyp with 
 | Qlt ?X1 ?X2 => stepl X1;[|qZ_numerals;ring];stepr X2;[|qZ_numerals;ring]; trivial
 | Qle ?X1 ?X2 => stepl X1;[|qZ_numerals;ring];stepr X2;[|qZ_numerals;ring]; trivial
 | ~(@eq Q ?X1 ?X2) => stepl X1;[|qZ_numerals;ring];stepr X2;[|qZ_numerals;ring]; trivial
 | ?X3 => fail 1
 end. *)
Require Export QArithSternBrocot.Qabs.
Require Export Qmax_min.
(* Qmax_min:
Require Export Qsyntax.
Require Export Field_Theory_Q.
Require Export Q_ordered_field_properties.

Definition Qmax p q := if Q_le_lt_dec p q then q else p.

Definition Qmin p q := if Q_le_lt_dec p q then p else q.

Lemma Qle_max_l: forall p q, p <= Qmax p q.

Lemma Qle_max_r: forall p q, q <= Qmax p q.

Lemma Qmax_lub: forall q1 q2 p, q1 <= p -> q2 <= p -> Qmax q1 q2 <= p.

Lemma Qmax_Qlt_upper_bound:forall p q1 q2, p<q1 -> p<q2 ->p < Qmax q1 q2.

Lemma Qmax_nondecreasing: forall q1 q2 p1 p2, q1 <= p1 -> q2 <= p2 -> Qmax q1 q2 <= Qmax p1 p2.

Lemma Qmin_Qmax_Qle:forall q1 q2, Qmin q1 q2 <= Qmax q1 q2.

Lemma Qmin_nondecreasing: forall q1 q2 p1 p2, q1 <= p1 -> q2 <= p2 -> Qmin q1 q2 <= Qmin p1 p2.

Lemma Qmin_glb: forall q1 q2 p, p<=q1 -> p<=q2 -> p<=Qmin q1 q2.

Lemma Qmin_Qlt_upper_bound:forall p q1 q2, p<q1 -> p<q2 ->p < Qmin q1 q2.

Lemma Qle_min_l: forall p q : Q, Qmin p q <= p.

Lemma Qle_min_r: forall p q : Q, Qmin p q <= q.

Lemma Qmax_or_informative:forall p q, {Qmax p q = p} + {Qmax p q = q}.

Lemma Qmin_or_informative:forall p q, {Qmin p q = p} + {Qmin p q = q}.

Definition Qmax4 q1 q2 q3 q4 := Qmax (Qmax q1 q2) (Qmax q3 q4).
Definition Qmin4 q1 q2 q3 q4 := Qmin (Qmin q1 q2) (Qmin q3 q4).

Lemma Qmax4_informative:forall q1 q2 q3 q4, {Qmax4 q1 q2 q3 q4=q1} + {Qmax4 q1 q2 q3 q4=q2} + {Qmax4 q1 q2 q3 q4=q3} + {Qmax4 q1 q2 q3 q4=q4}.

Lemma Qmin4_informative:forall q1 q2 q3 q4, {Qmin4 q1 q2 q3 q4=q1} + {Qmin4 q1 q2 q3 q4=q2} + {Qmin4 q1 q2 q3 q4=q3} + {Qmin4 q1 q2 q3 q4=q4}.

Lemma Qmin4_Qmax4_Qle:forall q1 q2 q3 q4, Qmin4 q1 q2 q3 q4<= Qmax4 q1 q2 q3 q4.

Lemma Qle_Qmax4_1:forall q1 q2 q3 q4, q1<=Qmax4 q1 q2 q3 q4.

Lemma Qle_Qmax4_2:forall q1 q2 q3 q4, q2<=Qmax4 q1 q2 q3 q4.

Lemma Qle_Qmax4_3:forall q1 q2 q3 q4, q3<=Qmax4 q1 q2 q3 q4.

Lemma Qle_Qmax4_4:forall q1 q2 q3 q4, q4<=Qmax4 q1 q2 q3 q4.

Lemma Qle_Qmin4_1:forall q1 q2 q3 q4, Qmin4 q1 q2 q3 q4<= q1.

Lemma Qle_Qmin4_2:forall q1 q2 q3 q4, Qmin4 q1 q2 q3 q4<= q2.

Lemma Qle_Qmin4_3:forall q1 q2 q3 q4, Qmin4 q1 q2 q3 q4<= q3.

Lemma Qle_Qmin4_4:forall q1 q2 q3 q4, Qmin4 q1 q2 q3 q4<= q4.

Lemma Qmax4_Qlt_upper_bound:forall p q1 q2 q3 q4, p<q1 -> p<q2 -> p<q3 -> p<q4 -> p < Qmax4 q1 q2 q3 q4.

Lemma Qlt_Qmin_upper_bound: forall p q1 q2 : Q, p < Qmin q1 q2 -> p < q1 /\ p < q2.

Definition Qlt_Qmin_upper_bound_l p q1 q2 (hyp:p < Qmin q1 q2) : p < q1 :=proj1 (Qlt_Qmin_upper_bound p q1 q2 hyp).
Definition Qlt_Qmin_upper_bound_r p q1 q2 (hyp:p < Qmin q1 q2) : p < q2 :=proj2 (Qlt_Qmin_upper_bound p q1 q2 hyp).

Lemma Qmax_Qlt_lower_bound: forall p q1 q2 : Q, q1 < p  -> q2 < p -> Qmax q1 q2 < p.

Lemma Qlt_Qmax_lower_bound: forall p q1 q2 : Q, Qmax q1 q2 < p -> q1 < p /\ q2 < p.

Definition Qlt_Qmax_lower_bound_l p q1 q2 (hyp:Qmax q1 q2 < p) := proj1 (Qlt_Qmax_lower_bound p q1 q2 hyp).
Definition Qlt_Qmax_lower_bound_r p q1 q2 (hyp:Qmax q1 q2 < p) := proj2 (Qlt_Qmax_lower_bound p q1 q2 hyp).

Lemma Qmin_involutive : forall q, Qmin q q = q.

Lemma Qmax_involutive : forall q, Qmax q q = q.

Definition Qmean (x y:Q):Q := (x+y) / (Qone + Qone).

Lemma Qmean_property:forall (x y:Q), x < y -> x < Qmean x y /\ Qmean x y < y.

Definition Qmean_property_l x y (hyp:x<y) := proj1 (Qmean_property x y hyp).
Definition Qmean_property_r x y (hyp:x<y) := proj2 (Qmean_property x y hyp).

Lemma Qmean_incr: forall x1 x2 y1 y2, x1< x2 -> y1 < y2 ->  Qmean x1 y1 < Qmean x2 y2.

Theorem Q_is_dense:forall x y, x<y -> {z:Q | x<z /\ z<y}. *)
Require Export Q_Archimedean.
(* Q_Archimedean:
Require Export Qsyntax.
Require Export Field_Theory_Q.
Require Export Q_ordered_field_properties.

Lemma Qpositive_in_Q_Archimedean_inf:forall qp:Qpositive, {z:Z | (Qpos qp)<=z /\ (z-(Qpos qp))<= Qone}.

Theorem Q_Archimedean_inf:forall q:Q, {z:Z | q<=z /\ (z-q)<= Qone}.

Definition up_Q q:= proj1_sig (Q_Archimedean_inf q).

Definition up_Q_property q := proj2_sig (Q_Archimedean_inf q):  q <= (up_Q q) /\ (up_Q q) - q <= Qone.

Lemma Q_Archimedean_nat_inf:forall q:Q, {n:nat | q<=n }. *)
Require Export Q_denumerable.
(* Q_denumerable:
Definition identity (A:Set) := fun a:A=> a.
Definition compose (A B C:Set) (g:B->C) (f:A->B) := fun a:A=>g(f a).

Section Denumerability.

Definition same_cardinality (A:Set) (B:Set) := {f:A->B & { g:B->A | (forall b,(compose _ _ _ f g) b= (identity B) b)
                                                                /\ forall a,(compose _ _ _ g f) a = (identity A) a}}. 

Definition is_denumerable A := same_cardinality A nat.

Lemma same_cardinality_transitive:forall A B C, same_cardinality A B -> same_cardinality B C -> same_cardinality A C.

Lemma is_denumerable_transitive:forall A B, is_denumerable A -> same_cardinality B A -> is_denumerable B.

End Denumerability.

Require Div2.
Require Import ZArith.

Definition Z_to_nat_i (z:Z) :nat :=
   match z with 
   | Z0 => O
   | Zpos p => Div2.double (nat_of_P p)
   | Zneg p => pred (Div2.double (nat_of_P p))
   end. 

Lemma odd_pred2n: forall n : nat, Even.odd n -> {p : nat | n = pred (Div2.double p)}.

Lemma even_odd_exists_dec:forall n, {p : nat | n = Div2.double p} + {p : nat | n = pred (Div2.double p)}.

Definition nat_to_Z_i (n:nat) := 
  match even_odd_exists_dec n with
  | inl s => let (k, _) := s in Z_of_nat k
  | inr s => let (k, _) := s in Z.opp (Z_of_nat k)
  end.

Lemma double_eq_half_eq:forall m n, Div2.double m = Div2.double n -> m =n.

Lemma parity_mismatch_not_eq:forall m n, Even.even m -> Even.odd n -> ~m=n.

Lemma even_double:forall n, Even.even (Div2.double n).

Lemma double_S_neq_pred:forall m n, ~Div2.double (S m) = pred (Div2.double n).

Lemma eq_add_pred : forall n m : nat, pred n = pred m -> {n = m} + {n<2/\m<2}.

Lemma nat_to_Z_to_nat_i : forall (z:Z), nat_to_Z_i (Z_to_nat_i z) = z.

Lemma Z_to_nat_to_Z_i : forall (n:nat), Z_to_nat_i (nat_to_Z_i n) = n.

Theorem Z_is_denumerable:is_denumerable Z.

Require Import Q_field.

Fixpoint positive_to_Qpositive_i (p:positive) : Qpositive := 
   match p with 
   | xI p => nR (positive_to_Qpositive_i p)
   | xO p => dL (positive_to_Qpositive_i p)
   | xH => One
   end. 

Definition Z_to_Q_i (z:Z) :=
   match z with 
   | Z0 => Zero
   | Zpos p => Qpos (positive_to_Qpositive_i p)
   | Zneg p => Qneg (positive_to_Qpositive_i p)
   end. 

Fixpoint Qpositive_to_positive_i (qp:Qpositive) : positive := 
   match qp with 
   | nR qp => xI (Qpositive_to_positive_i qp)
   | dL qp => xO (Qpositive_to_positive_i qp)
   | One => xH
   end. 

Definition Q_to_Z_i (q:Q) :=
   match q with 
   | Zero => Z0
   | Qpos qp => Zpos (Qpositive_to_positive_i qp)
   | Qneg qp => Zneg (Qpositive_to_positive_i qp)
   end. 

Lemma Qpositive_to_positive_to_Qpositive_i : forall (p:positive), Qpositive_to_positive_i (positive_to_Qpositive_i p) = p.

Lemma positive_to_Qpositive_to_positive_i : forall qp, positive_to_Qpositive_i (Qpositive_to_positive_i qp) = qp.

Lemma Q_to_Z_to_Q_i : forall (z:Z), Q_to_Z_i (Z_to_Q_i z) = z.

Lemma Z_to_Q_to_Z_i : forall (q:Q), Z_to_Q_i (Q_to_Z_i q) = q.

Theorem Q_is_denumerable: is_denumerable Q. *)
Require Export Q_to_R.
(* Q_to_R:
Require Import Q_ordered_field_properties.
Require Import R_addenda.
Require Import Raxioms.
Require Import RIneq.

Definition Q_to_R (q:Q) : R := ((IZR (numerator q))/(IZR (denominator q)))%R.

Coercion Q_to_R : Q>->R.

Lemma Q_to_Req: forall x y, @eq Q  x y -> ((Q_to_R x)=(Q_to_R y))%R.

Lemma Q_to_R_Zero: (Q_to_R Zero=0)%R.

Lemma Q_to_R_Qone: (Q_to_R Qone=1)%R.

Lemma Q_to_R_Qneg_One: (Q_to_R (Qneg One)=(-1))%R.

Lemma Q_to_Ropp: forall x, Q_to_R (Qopp x) = Ropp (Q_to_R x).

Lemma Q_to_Rplus: forall x y, Q_to_R (Qplus x y) = (Rplus (Q_to_R x) (Q_to_R y)).

Lemma Q_to_Rmult: forall x y, Q_to_R (Qmult x y) = (Rmult (Q_to_R x) (Q_to_R y)).

Lemma Q_to_Rinv: forall x, ~(x=Zero) -> Q_to_R (Qinv x) = Rinv (Q_to_R x).

Lemma Q_to_Rminus: forall x y, Q_to_R (Qminus x y) = (Rminus (Q_to_R x) (Q_to_R y)).

Lemma Q_to_Rdiv: forall x y, ~(y=Zero) -> Q_to_R (Qdiv x y) = (Rdiv (Q_to_R x) (Q_to_R y)).

Lemma not_Qlt:forall x y, ~(Qlt y x) -> (Qle x y).
 
Lemma Q_to_Rle: forall x y, Qle x y -> Rle (Q_to_R x) (Q_to_R y).

Lemma Q_to_Rlt: forall x y, Qlt x y -> Rlt (Q_to_R x) (Q_to_R y).

Lemma Q_to_R_not_eq: forall x y, ~(x=y)->~(Q_to_R x = Q_to_R y).

Lemma Q_to_R_Qle:forall x y : Q, Rle (Q_to_R x) (Q_to_R y) -> Qle x y. 

Lemma Q_to_R_Qlt:forall x y : Q, Rlt (Q_to_R x) (Q_to_R y) -> Qlt x y. 

Lemma Q_to_R_Qneq:forall x y : Q,  (Q_to_R x)<>(Q_to_R y) ->  x<>y. 

Lemma Q_to_R_Qeq:forall x y : Q,  (Q_to_R x)=(Q_to_R y) ->  x=y. 
  
Lemma Z_to_Q_to_R_IZR: forall z, Q_to_R (Z_to_Q z) = IZR z.

Ltac realify_Q_assumptions :=
 repeat 
 match goal with 
 | [ id : (Qlt ?X1 ?X2) |- _ ] => generalize (Q_to_Rlt _ _ id); clear id; try unfold fst, snd
 | [ id : (Qle ?Xe ?X2) |- _ ] => generalize (Q_to_Rle _ _ id); clear id; try unfold fst, snd
 | [ id : (@eq Q ?Xe ?X2) |- _ ] => generalize (Q_to_Req _ _ id); clear id; try unfold fst, snd
 | [ id : ~(@eq Q ?Xe ?X2) |- _ ] => generalize (Q_to_R_not_eq _ _ id); clear id; try unfold fst, snd
 end.

Ltac realify_Q_goal :=   
 match goal with 
 | [ |- context [(Q_to_R (Qplus ?X1 ?X2))] ] => rewrite Q_to_Rplus; realify_Q_goal
 | [ |- context [(Q_to_R (Qminus ?X1 ?X2))] ] => rewrite Q_to_Rminus; realify_Q_goal
 | [ |- context [(Q_to_R (Qmult ?X1 ?X2))] ] => rewrite Q_to_Rmult; realify_Q_goal
 | [ |- context [(Q_to_R (Qdiv ?X1 ?X2))] ] => rewrite Q_to_Rdiv; realify_Q_goal
 | [ |- context [(Q_to_R (Qopp ?X1))] ] => rewrite Q_to_Ropp; realify_Q_goal
 | [ |- context [(Q_to_R (Qinv ?X1))] ] => rewrite Q_to_Rinv; realify_Q_goal
 | [ |- context [(Q_to_R Zero)] ] => rewrite Q_to_R_Zero; realify_Q_goal
 | [ |- context [(Q_to_R Qone)] ] => rewrite Q_to_R_Qone; realify_Q_goal
 | [ |- context [(Q_to_R (Qneg One))] ] => rewrite Q_to_R_Qneg_One; realify_Q_goal
 | [ |- context [(Q_to_R (Z_to_Q ?X1))] ] => rewrite Z_to_Q_to_R_IZR; realify_Q_goal
 | [ |- _ ] => idtac
 end.

Ltac realify_Q := try realify_Q_assumptions; realify_Q_goal.

Ltac rationalify_R_goal :=   
 match goal with 
 | [ |- context [(Rplus (Q_to_R ?X1) (Q_to_R ?X2))] ] => rewrite <- Q_to_Rplus; rationalify_R_goal
 | [ |- context [(Rminus (Q_to_R ?X1) (Q_to_R ?X2))] ] => rewrite <- Q_to_Rminus; rationalify_R_goal
 | [ |- context [(Rmult (Q_to_R ?X1) (Q_to_R ?X2))] ] => rewrite <- Q_to_Rmult; rationalify_R_goal
 | [ |- context [(Rdiv (Q_to_R ?X1) (Q_to_R ?X2))] ] => rewrite <- Q_to_Rdiv; auto; rationalify_R_goal
 | [ |- context [(Ropp (Q_to_R ?X1)) ]] => rewrite <- Q_to_Ropp; rationalify_R_goal
 | [ |- context [(Rinv (Q_to_R ?X1))] ] => rewrite <- Q_to_Rinv; auto; rationalify_R_goal
 | [ |- context [R0] ] => rewrite <- Q_to_R_Zero; rationalify_R_goal
 | [ |- context [R1] ] => rewrite <- Q_to_R_Qone; rationalify_R_goal
 | [ |- context [(IZR ?X1)] ] => rewrite <- Z_to_Q_to_R_IZR; realify_Q_goal
 | [ |- _ ] => idtac
 end.

Ltac rationalify_R := rationalify_R_goal;
 match goal with 
 | [ |- Rlt (Q_to_R ?X1) (Q_to_R ?X2)] => apply Q_to_Rlt
 | [ |- Rle (Q_to_R ?X1) (Q_to_R ?X2)] => apply Q_to_Rle
 | [ |- @eq Q (Q_to_R ?X1) (Q_to_R ?X2)] => apply (f_equal Q_to_R)
 | [ |- ~(@eq Q (Q_to_R ?X1) (Q_to_R ?X2))] => apply Q_to_R_not_eq
 | [ |- ~(@eq Q ?X1 Zero)] => idtac
 | [ |- _ ] => fail 1
 end. *)

