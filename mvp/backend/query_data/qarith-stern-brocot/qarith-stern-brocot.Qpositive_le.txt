
Require Export Qpositive.
(* Qpositive:
Require Export Arith.
Require Export Compare_dec.
Require Export ArithRing.
Require Export Omega.
Require Export ZArith.
Require Export ZArithRing.
 
Ltac CaseEq f := generalize (refl_equal f); pattern f at -1 in |- *; case f.
 
Inductive Qpositive : Set :=
  | nR : Qpositive -> Qpositive
  | dL : Qpositive -> Qpositive
  | One : Qpositive.
 
Fixpoint Qpositive_i (w : Qpositive) : nat * nat :=
  match w with
  | One => (1, 1)
  | nR w' => match Qpositive_i w' with
             | (p, q) => (p + q, q)
             end
  | dL w' => match Qpositive_i w' with
             | (p, q) => (p, p + q)
             end
  end.
Coercion Z_of_nat : nat >-> Z.
 
Theorem interp_reduced_fraction :
 forall w : Qpositive,
 exists a : Z,
   (exists b : Z, (a * fst (Qpositive_i w) + b * snd (Qpositive_i w))%Z = 1%Z).
 
Fixpoint Qpositive_inv (w : Qpositive) : Qpositive :=
  match w with
  | One => One
  | nR w' => dL (Qpositive_inv w')
  | dL w' => nR (Qpositive_inv w')
  end.
 
Theorem inv_correct :
 forall (w : Qpositive) (p q : nat),
 Qpositive_i w = (p, q) -> Qpositive_i (Qpositive_inv w) = (q, p).
 
Theorem interp_non_zero :
 forall w : Qpositive,
 exists p : nat, (exists q : nat, Qpositive_i w = (S p, S q)).
 
Fixpoint Qpositive_c (p q n : nat) {struct n} : Qpositive :=
  match n with
  | O => One
  | S n' =>
      match p - q with
      | O => match q - p with
             | O => One
             | v => dL (Qpositive_c p v n')
             end
      | v => nR (Qpositive_c v q n')
      end
  end.
 
Theorem minus_O_le : forall n m : nat, n - m = 0 -> n <= m.
 
Theorem le_minus_O : forall n m : nat, n <= m -> n - m = 0.
 
Theorem minus_le : forall m n : nat, m - n <= m.
 
Theorem mult_reg_l : forall n m p : nat, S n * m = S n * p -> m = p.
 
Theorem absolu_inj_nat : forall x : nat, Z.abs_nat (Z_of_nat x) = x.
 
Theorem absolu_mult :
 forall x y : Z, Z.abs_nat (x * y) = Z.abs_nat x * Z.abs_nat y.
 
Theorem Qpositive_c_unfold1 :
 forall p q n : nat,
 S p + S q + S q <= S n ->
 Qpositive_c (S p + S q) (S q) (S n) = nR (Qpositive_c (S p) (S q) n).
 
Theorem Qpositive_c_unfold2 :
 forall p q n : nat,
 S p + (S p + S q) <= S n ->
 Qpositive_c (S p) (S p + S q) (S n) = dL (Qpositive_c (S p) (S q) n).
 
Theorem construct_correct :
 forall (w : Qpositive) (p q n : nat),
 Qpositive_i w = (p, q) -> p + q <= n -> Qpositive_c p q n = w.
 
Theorem construct_correct2 :
 forall n p q : nat,
 S p + S q <= n ->
 exists d : nat,
   S p = fst (Qpositive_i (Qpositive_c (S p) (S q) n)) * S d /\
   S q = snd (Qpositive_i (Qpositive_c (S p) (S q) n)) * S d.
 
Theorem construct_correct2' :
 forall n p q : nat,
 1 <= p ->
 1 <= q ->
 p + q <= n ->
 exists d : nat,
   p = fst (Qpositive_i (Qpositive_c p q n)) * S d /\
   q = snd (Qpositive_i (Qpositive_c p q n)) * S d.
 
Theorem construct_correct3 :
 forall n n' p q p' q' d : nat,
 S p = S d * p' ->
 S q = S d * q' ->
 S p + S q <= S n ->
 p' + q' <= S n' -> Qpositive_c (S p) (S q) (S n) = Qpositive_c p' q' (S n').
 
Theorem construct_correct4 :
 forall p q p' q' n n' : nat,
 S p + S q <= S n ->
 S p' + S q' <= S n' ->
 S p * S q' = S p' * S q ->
 Qpositive_c (S p) (S q) (S n) = Qpositive_c (S p') (S q') (S n').
 
Theorem construct_correct4' :
 forall p q p' q' n n' : nat,
 1 <= p ->
 1 <= q ->
 1 <= p' ->
 1 <= q' ->
 p + q <= n ->
 p' + q' <= n' -> p * q' = p' * q -> Qpositive_c p q n = Qpositive_c p' q' n'.
 
Theorem interp_inject :
 forall w w' : Qpositive, Qpositive_i w = Qpositive_i w' -> w = w'.
 
Theorem minus_decompose :
 forall a b c d : nat, a = b -> c = d -> a - c = b - d.
 
Theorem Qpositive_c_equiv :
 forall n p q n' p' q' : nat,
 S p + S q <= n ->
 S p' + S q' <= n' ->
 Qpositive_c (S p) (S q) n = Qpositive_c (S p') (S q') n' ->
 S p * S q' = S p' * S q.
 
Theorem Qpositive_c_equiv' :
 forall n p q n' p' q' : nat,
 1 <= p ->
 1 <= q ->
 1 <= p' ->
 1 <= q' ->
 p + q <= n ->
 p' + q' <= n' -> Qpositive_c p q n = Qpositive_c p' q' n' -> p * q' = p' * q. *)
 
Fixpoint Qpositive_le_bool (w w' : Qpositive) {struct w'} : bool :=
  match w with
  | One => match w' with
           | dL y => false
           | _ => true
           end
  | dL y => match w' with
            | dL y' => Qpositive_le_bool y y'
            | _ => true
            end
  | nR y => match w' with
            | nR y' => Qpositive_le_bool y y'
            | _ => false
            end
  end.
 
Definition Qpositive_le (w w' : Qpositive) := Qpositive_le_bool w w' = true.
 
Definition Qpositive_le' (w w' : Qpositive) :=
  match Qpositive_i w, Qpositive_i w' with
  | (p, q), (p', q') => p * q' <= p' * q
  end.
 
Theorem Qpositive_le_to_Qpositive_le' :
 forall w w' : Qpositive, Qpositive_le w w' -> Qpositive_le' w w'.
intros w w'; generalize w; elim w'; clear w w'.

intros w'1 Hrec w; case w.

unfold Qpositive_le in |- *; simpl in |- *.
intros w1 H; generalize (Hrec w1 H).
unfold Qpositive_le' in |- *.
simpl in |- *.
case (Qpositive_i w1); case (Qpositive_i w'1).
intros p' q' p q Hle; repeat rewrite mult_plus_distr_r.
rewrite (mult_comm q').
apply plus_le_compat_r.
auto.

intros w1; unfold Qpositive_le in |- *.
simpl in |- *.
unfold Qpositive_le' in |- *; simpl in |- *; intros H; case (Qpositive_i w1);
 case (Qpositive_i w'1); intros p' q' p q.
rewrite mult_plus_distr_r.
repeat rewrite <- (mult_comm (p + q)).
repeat rewrite mult_plus_distr_r.
rewrite (plus_comm (p * p' + q * p')).
repeat rewrite <- plus_assoc.
auto with arith.

unfold Qpositive_le, Qpositive_le' in |- *.
simpl in |- *.
case (Qpositive_i w'1).
intros; omega.

intros w'1 Hrec w; case w; clear w; unfold Qpositive_le in |- *;
 simpl in |- *.

intros q H; discriminate H.

intros w1 H; generalize (Hrec w1 H); unfold Qpositive_le' in |- *.
simpl in |- *; case (Qpositive_i w1); case (Qpositive_i w'1);
 intros p' q' p q.
repeat rewrite (mult_comm p); repeat rewrite (mult_comm p');
 repeat rewrite mult_plus_distr_r.
intros H1.
rewrite (mult_comm p').
apply plus_le_compat_l.
auto.

intros H; discriminate H.

unfold Qpositive_le, Qpositive_le' in |- *.
intros w; case w.
3: simpl in |- *; auto.
intros w1; simpl in |- *.
intros Heq; discriminate Heq.
 intros w'; simpl in |- *.
 case (Qpositive_i w').
 intros; omega.

Qed.
 
Theorem Qpositive_le'_to_Qpositive_le :
 forall w w' : Qpositive, Qpositive_le' w w' -> Qpositive_le w w'.
intros w w'; generalize w; elim w'; clear w w'.

intros w'1 Hrec w; case w; clear w.

intros w; unfold Qpositive_le', Qpositive_le in |- *; simpl in |- *.
generalize (Hrec w); clear Hrec; unfold Qpositive_le, Qpositive_le' in |- *;
 simpl in |- *.
elim (interp_non_zero w); intros p Hex; elim Hex; intros q Heq; clear Hex;
 rewrite Heq.
elim (interp_non_zero w'1); intros p' Hex; elim Hex; intros q' Heq1;
 clear Hex; rewrite Heq1.
intros H H1; (lapply H; [ intros H0; try exact H0 | idtac ]).
apply (fun p n m : nat => plus_le_reg_l n m p) with (S q * S q').
replace (S q * S q' + S p * S q') with ((S p + S q) * S q').
replace (S q * S q' + S p' * S q) with ((S p' + S q') * S q).
auto.
ring.
ring.

unfold Qpositive_le in |- *; simpl in |- *; auto.

unfold Qpositive_le in |- *; simpl in |- *.
auto.

intros w'1 Hrec w; case w; clear w; unfold Qpositive_le in |- *;
 simpl in |- *; auto.
 
intros w1; unfold Qpositive_le' in |- *; simpl in |- *.
elim (interp_non_zero w1); intros p Hex; elim Hex; intros q Heq; clear Hex;
 rewrite Heq.
elim (interp_non_zero w'1); intros p' Hex; elim Hex; intros q' Heq1;
 clear Hex; rewrite Heq1.
rewrite mult_plus_distr_r.
repeat rewrite <- (mult_comm (S p' + S q')).
repeat rewrite mult_plus_distr_r.
repeat rewrite <- (plus_comm (S p' * S q)) || rewrite plus_assoc;
 repeat rewrite <- plus_assoc.
pattern (S p' * S q) at 2 in |- *; rewrite plus_n_O.
intros H; generalize (plus_le_reg_l _ _ _ H); simpl in |- *; intros H1;
 inversion H1.

intros w; unfold Qpositive_le', Qpositive_le in |- *; simpl in |- *.
generalize (Hrec w); clear Hrec; unfold Qpositive_le, Qpositive_le' in |- *;
 simpl in |- *.
elim (interp_non_zero w); intros p Hex; elim Hex; intros q Heq; clear Hex;
 rewrite Heq.
elim (interp_non_zero w'1); intros p' Hex; elim Hex; intros q' Heq1;
 clear Hex; rewrite Heq1.
intros H H1; (lapply H; [ intros H0; try exact H0 | idtac ]).
apply (fun p n m : nat => plus_le_reg_l n m p) with (S p * S p').
replace (S p * S p' + S p * S q') with (S p * (S p' + S q')).
replace (S p * S p' + S p' * S q) with (S p' * (S p + S q)).
auto.
ring.
ring.

unfold Qpositive_le' in |- *; simpl in |- *.
elim (interp_non_zero w'1); intros p' Hex; elim Hex; intros q' Heq1;
 clear Hex; rewrite Heq1.
rewrite <- plus_n_O; rewrite <- (mult_comm 1); simpl in |- *; intros H;
 generalize (plus_le_reg_l _ _ _ (le_S_n _ _ H)).
intros H1; inversion H1.

intros w; case w; clear w; unfold Qpositive_le', Qpositive_le in |- *;
 simpl in |- *.

intros w; elim (interp_non_zero w).
intros p Hex; elim Hex; intros q Heq; rewrite Heq.
rewrite mult_1_r.
rewrite (plus_comm (S p)).
intros H; generalize (plus_le_reg_l _ _ _ H); intros H1; inversion H1.

auto.

auto.

Qed.
 
Theorem Qpositive_le_trans :
 forall w w' w'' : Qpositive,
 Qpositive_le w w' -> Qpositive_le w' w'' -> Qpositive_le w w''.
intros w w'; generalize w; elim w'; unfold Qpositive_le in |- *;
 simpl in |- *; clear w w'.

intros w' Hrec w; case w.

3: intros w''; case w''; simpl in |- *; auto.

intros w0 w''; case w''; simpl in |- *; auto.

intros w0 w''; case w''; simpl in |- *; auto.
intros w''0 H H1; discriminate H1.

intros w' Hrec w; case w.

3: intros w'' H; discriminate H.

intros w0 w'' H; discriminate H.

intros w0 w''; case w''; simpl in |- *; auto.

intros w; case w; clear w; simpl in |- *.

3: auto.

intros w w'' H; discriminate H.
 
intros w w''; case w''; simpl in |- *; auto.
intros w''0 H H1; discriminate H1.

Qed.
 
Theorem Qpositive_le_antisym :
 forall w w' : Qpositive, Qpositive_le w w' -> Qpositive_le w' w -> w = w'.
intros w; elim w; unfold Qpositive_le in |- *; simpl in |- *.
intros w0 Hrec w'; case w'; simpl in |- *.
3: intros H; discriminate H.
intros; apply f_equal with (f := nR); auto.
intros w'0 H; discriminate H.
intros w0 Hrec w'; case w'; simpl in |- *.
3: intros H H1; discriminate H1.
intros w'1 H H1; discriminate H1.
intros; apply f_equal with (f := dL); auto.

intros w'; case w'; auto with *.
intros w'0 H H1; discriminate H1.
intros w'0 H; discriminate H.

Qed.
 
Theorem Qpositive_le_refl : forall w : Qpositive, Qpositive_le w w.
intros w; unfold Qpositive_le in |- *; elim w; simpl in |- *; auto.
Qed.
 
Theorem Qpositive_le_total :
 forall w w' : Qpositive, Qpositive_le w w' \/ Qpositive_le w' w.
intros w w'; cut (Qpositive_le' w w' \/ Qpositive_le' w' w).
intros H; elim H; intros H1;
 generalize (Qpositive_le'_to_Qpositive_le _ _ H1); 
 auto.
unfold Qpositive_le' in |- *.
case (Qpositive_i w'); case (Qpositive_i w); intros p q p' q'.
elim (le_or_lt (p * q') (p' * q)); auto with arith.
Qed.
 
Theorem not_Qpositive_le_not_eq :
 forall n m : Qpositive, ~ Qpositive_le n m -> n <> m.
intros n m H; red in |- *; intros H1; elim H; rewrite H1;
 apply Qpositive_le_refl.
Qed.
 
Theorem not_Qpositive_le_Qpositive_le' :
 forall n m : Qpositive, ~ Qpositive_le n m -> Qpositive_le m n.
intros n m Hle; elim (Qpositive_le_total n m); auto.
intros H; elim Hle; auto.
Qed.

Lemma Qpositive_le_noneq_explicit: forall qp qp', Qpositive_le qp qp' -> ~ qp=qp' -> 
  let (p, q) := Qpositive_i qp in
    let (p', q') := Qpositive_i qp' in (p * q' < p' * q)%nat.
Proof.
 intros qp qp' H_le H_neq; generalize (Qpositive_le_to_Qpositive_le' qp qp' H_le); unfold Qpositive_le';
 destruct (interp_non_zero qp) as [p [q H]];
 destruct (interp_non_zero qp') as [p' [q' H']];
 rewrite H; rewrite H'; intros H_le_unfold; destruct (le_lt_eq_dec _ _ H_le_unfold) as [H1|H1]; trivial;
 apply False_ind; apply H_neq;
 rewrite <- (construct_correct qp (S p) (S q) (S p+S q)%nat H); auto with arith;
 rewrite <- (construct_correct qp' (S p') (S q') (S p'+S q')%nat H'); auto with arith;
 apply construct_correct4'; auto with arith.
Qed.
