
Require Export Qhomographic_sign.
(* Qhomographic_sign:
Require Export positive_fraction_encoding.
Require Import ZArithRing.

Definition outside_interval (a b : Z) := (Z.sgn a + Z.sgn b)%Z.

Definition inside_interval_1 (o1 o2 : Z) :=
  (0 < o1)%Z /\ (0 < o2)%Z \/ (o1 < 0)%Z /\ (o2 < 0)%Z.

Definition inside_interval_2 (o1 o2 : Z) :=
  (0 < o1)%Z /\ (o2 < 0)%Z \/ (o1 < 0)%Z /\ (0 < o2)%Z.

Lemma inside_interval_1_dec_inf :
 forall o1 o2 : Z, {inside_interval_1 o1 o2} + {~ inside_interval_1 o1 o2}.

Lemma inside_interval_2_dec_inf :
 forall o1 o2 : Z, {inside_interval_2 o1 o2} + {~ inside_interval_2 o1 o2}.

Inductive Qhomographic_sg_denom_nonzero : Z -> Z -> Qpositive -> Prop :=
  | Qhomographic_signok0 :
      forall (c d : Z) (p : Qpositive),
      p = One -> (c + d)%Z <> 0%Z -> Qhomographic_sg_denom_nonzero c d p
  | Qhomographic_signok1 :
      forall (c d : Z) (xs : Qpositive),
      Qhomographic_sg_denom_nonzero c (c + d)%Z xs ->
      Qhomographic_sg_denom_nonzero c d (nR xs)
  | Qhomographic_signok2 :
      forall (c d : Z) (xs : Qpositive),
      Qhomographic_sg_denom_nonzero (c + d)%Z d xs ->
      Qhomographic_sg_denom_nonzero c d (dL xs).

Lemma Qhomographic_signok_1 :
 forall c d : Z, Qhomographic_sg_denom_nonzero c d One -> (c + d)%Z <> 0%Z.

Lemma Qhomographic_signok_2 :
 forall (c d : Z) (xs : Qpositive),
 Qhomographic_sg_denom_nonzero c d (nR xs) ->
 Qhomographic_sg_denom_nonzero c (c + d) xs.

Lemma Qhomographic_signok_3 :
 forall (c d : Z) (xs : Qpositive),
 Qhomographic_sg_denom_nonzero c d (dL xs) ->
 Qhomographic_sg_denom_nonzero (c + d) d xs.

Fixpoint Qhomographic_sign (a b c d : Z) (p : Qpositive) {struct p} :
  forall (H_Qhomographic_sg_denom_nonzero : Qhomographic_sg_denom_nonzero c d p),
  Z * (Z * (Z * (Z * Z)) * Qpositive).

Functional Scheme Qhomographic_sign_ind :=
  Induction for Qhomographic_sign Sort Prop.

Scheme Qhomographic_sg_denom_nonzero_inv_dep :=
  Induction for Qhomographic_sg_denom_nonzero Sort Prop.

Lemma Qhomographic_sign_equal :
 forall (a b c d : Z) (p : Qpositive)
   (H1 H2 : Qhomographic_sg_denom_nonzero c d p),
 Qhomographic_sign a b c d p H1 = Qhomographic_sign a b c d p H2.

Lemma Qhomographic_sign_equal_strong :
 forall (a1 a2 b1 b2 c1 c2 d1 d2 : Z) (p1 p2 : Qpositive)
   (H_ok_1 : Qhomographic_sg_denom_nonzero c1 d1 p1)
   (H_ok_2 : Qhomographic_sg_denom_nonzero c2 d2 p2),
 a1 = a2 ->
 b1 = b2 ->
 c1 = c2 ->
 d1 = d2 ->
 p1 = p2 ->
 Qhomographic_sign a1 b1 c1 d1 p1 H_ok_1 =
 Qhomographic_sign a2 b2 c2 d2 p2 H_ok_2.

Lemma sg_One_2 :
 forall (a b c d : Z) (p : Qpositive)
   (H_Qhomographic_sg_denom_nonzero : Qhomographic_sg_denom_nonzero c d p),
 p = One ->
 Z.sgn (a + b) = 0%Z ->

Lemma sg_One_3 :
 forall (a b c d : Z) (p : Qpositive)
   (H_Qhomographic_sg_denom_nonzero : Qhomographic_sg_denom_nonzero c d p),
 p = One ->
 Z.sgn (a + b) <> 0%Z ->

Lemma sg_One_4 :
 forall (a b c d : Z) (p : Qpositive)
   (H_Qhomographic_sg_denom_nonzero : Qhomographic_sg_denom_nonzero c d p),
 p = One ->
 Z.sgn (a + b) <> 0%Z ->

Lemma Qhomographic_sign_nR_1 :
 forall (a b c d : Z) (p xs : Qpositive)
   (H_Qhomographic_sg_denom_nonzero : Qhomographic_sg_denom_nonzero c d p),
 p = nR xs ->
 b = 0%Z ->
 d = 0%Z ->
 Qhomographic_sign a b c d p H_Qhomographic_sg_denom_nonzero =
 ((Z.sgn a * Z.sgn c)%Z, (a, (b, (c, d)), p)).

Lemma Qhomographic_sign_nR_2 :
 forall (a b c d : Z) (p xs : Qpositive)
   (H_Qhomographic_sg_denom_nonzero : Qhomographic_sg_denom_nonzero c d p),
 p = nR xs ->
 b = 0%Z ->
 d <> 0%Z ->
 (0 < outside_interval c d)%Z ->
 Qhomographic_sign a b c d p H_Qhomographic_sg_denom_nonzero =
 (Z.sgn a, (a, (b, (c, d)), p)).

Lemma Qhomographic_sign_nR_3 :
 forall (a b c d : Z) (p xs : Qpositive)
   (H_Qhomographic_sg_denom_nonzero : Qhomographic_sg_denom_nonzero c d p),
 p = nR xs ->
 b = 0%Z ->
 d <> 0%Z ->
 ~ (0 < outside_interval c d)%Z ->
 (outside_interval c d < 0)%Z ->
 Qhomographic_sign a b c d p H_Qhomographic_sg_denom_nonzero =
 ((- Z.sgn a)%Z, (a, (b, (c, d)), p)).

Lemma Qhomographic_sign_nR_4 :
 forall (a b c d : Z) (p xs : Qpositive)
   (H_Qhomographic_sg_denom_nonzero : Qhomographic_sg_denom_nonzero c 
                                        (c + d) xs)
   (H_Qhomographic_sg_denom_nonzero_nR : Qhomographic_sg_denom_nonzero c d
                                           (nR xs)),
 b = 0%Z ->
 d <> 0%Z ->
 ~ (0 < outside_interval c d)%Z ->
 ~ (outside_interval c d < 0)%Z ->
 Qhomographic_sign a b c d (nR xs) H_Qhomographic_sg_denom_nonzero_nR =
 Qhomographic_sign a (a + b) c (c + d) xs H_Qhomographic_sg_denom_nonzero.

Lemma Qhomographic_sign_nR_5 :
 forall (a b c d : Z) (p xs : Qpositive)
   (H_Qhomographic_sg_denom_nonzero : Qhomographic_sg_denom_nonzero c d p),
 p = nR xs ->
 b <> 0%Z ->
 d = 0%Z ->
 (0 < outside_interval a b)%Z ->
 Qhomographic_sign a b c d p H_Qhomographic_sg_denom_nonzero =
 (Z.sgn c, (a, (b, (c, d)), p)).

Lemma Qhomographic_sign_nR_6 :
 forall (a b c d : Z) (p xs : Qpositive)
   (H_Qhomographic_sg_denom_nonzero : Qhomographic_sg_denom_nonzero c d p),
 p = nR xs ->
 b <> 0%Z ->
 d = 0%Z ->
 ~ (0 < outside_interval a b)%Z ->
 (outside_interval a b < 0)%Z ->
 Qhomographic_sign a b c d p H_Qhomographic_sg_denom_nonzero =
 ((- Z.sgn c)%Z, (a, (b, (c, d)), p)).

Lemma Qhomographic_sign_nR_7 :
 forall (a b c d : Z) (p xs : Qpositive)
   (H_Qhomographic_sg_denom_nonzero : Qhomographic_sg_denom_nonzero c 
                                        (c + d) xs)
   (H_Qhomographic_sg_denom_nonzero_nR : Qhomographic_sg_denom_nonzero c d
                                           (nR xs)),
 b <> 0%Z ->
 d = 0%Z ->
 ~ (0 < outside_interval a b)%Z ->
 ~ (outside_interval a b < 0)%Z ->
 Qhomographic_sign a b c d (nR xs) H_Qhomographic_sg_denom_nonzero_nR =
 Qhomographic_sign a (a + b) c (c + d) xs H_Qhomographic_sg_denom_nonzero.

Lemma Qhomographic_sign_nR_8 :
 forall (a b c d : Z) (p xs : Qpositive)
   (H_Qhomographic_sg_denom_nonzero : Qhomographic_sg_denom_nonzero c d p),
 p = nR xs ->
 b <> 0%Z ->
 d <> 0%Z ->
 inside_interval_1 (outside_interval a b) (outside_interval c d) ->
 Qhomographic_sign a b c d p H_Qhomographic_sg_denom_nonzero =
 (1%Z, (a, (b, (c, d)), p)).

Lemma Qhomographic_sign_nR_9 :
 forall (a b c d : Z) (p xs : Qpositive)
   (H_Qhomographic_sg_denom_nonzero : Qhomographic_sg_denom_nonzero c d p),
 p = nR xs ->
 b <> 0%Z ->
 d <> 0%Z ->
 ~ inside_interval_1 (outside_interval a b) (outside_interval c d) ->
 inside_interval_2 (outside_interval a b) (outside_interval c d) ->
 Qhomographic_sign a b c d p H_Qhomographic_sg_denom_nonzero =
 ((-1)%Z, (a, (b, (c, d)), p)).

Lemma Qhomographic_sign_nR_10 :
 forall (a b c d : Z) (p xs : Qpositive)
   (H_Qhomographic_sg_denom_nonzero : Qhomographic_sg_denom_nonzero c 
                                        (c + d) xs)
   (H_Qhomographic_sg_denom_nonzero_nR : Qhomographic_sg_denom_nonzero c d
                                           (nR xs)),
 b <> 0%Z ->
 d <> 0%Z ->
 ~ inside_interval_1 (outside_interval a b) (outside_interval c d) ->
 ~ inside_interval_2 (outside_interval a b) (outside_interval c d) ->
 Qhomographic_sign a b c d (nR xs) H_Qhomographic_sg_denom_nonzero_nR =
 Qhomographic_sign a (a + b) c (c + d) xs H_Qhomographic_sg_denom_nonzero.

Lemma Qhomographic_sign_dL_1 :
 forall (a b c d : Z) (p xs : Qpositive)
   (H_Qhomographic_sg_denom_nonzero : Qhomographic_sg_denom_nonzero c d p),
 p = dL xs ->
 b = 0%Z ->
 d = 0%Z ->
 Qhomographic_sign a b c d p H_Qhomographic_sg_denom_nonzero =
 ((Z.sgn a * Z.sgn c)%Z, (a, (b, (c, d)), p)).

Lemma Qhomographic_sign_dL_2 :
 forall (a b c d : Z) (p xs : Qpositive)
   (H_Qhomographic_sg_denom_nonzero : Qhomographic_sg_denom_nonzero c d p),
 p = dL xs ->
 b = 0%Z ->
 d <> 0%Z ->
 (0 < outside_interval c d)%Z ->
 Qhomographic_sign a b c d p H_Qhomographic_sg_denom_nonzero =
 (Z.sgn a, (a, (b, (c, d)), p)).

Lemma Qhomographic_sign_dL_3 :
 forall (a b c d : Z) (p xs : Qpositive)
   (H_Qhomographic_sg_denom_nonzero : Qhomographic_sg_denom_nonzero c d p),
 p = dL xs ->
 b = 0%Z ->
 d <> 0%Z ->
 ~ (0 < outside_interval c d)%Z ->
 (outside_interval c d < 0)%Z ->
 Qhomographic_sign a b c d p H_Qhomographic_sg_denom_nonzero =
 ((- Z.sgn a)%Z, (a, (b, (c, d)), p)).

Lemma Qhomographic_sign_dL_4 :
 forall (a b c d : Z) (p xs : Qpositive)
   (H_Qhomographic_sg_denom_nonzero : Qhomographic_sg_denom_nonzero 
                                        (c + d) d xs)
   (H_Qhomographic_sg_denom_nonzero_dL : Qhomographic_sg_denom_nonzero c d
                                           (dL xs)),
 b = 0%Z ->
 d <> 0%Z ->
 ~ (0 < outside_interval c d)%Z ->
 ~ (outside_interval c d < 0)%Z ->
 Qhomographic_sign a b c d (dL xs) H_Qhomographic_sg_denom_nonzero_dL =
 Qhomographic_sign (a + b) b (c + d) d xs H_Qhomographic_sg_denom_nonzero.

Lemma Qhomographic_sign_dL_5 :
 forall (a b c d : Z) (p xs : Qpositive)
   (H_Qhomographic_sg_denom_nonzero : Qhomographic_sg_denom_nonzero c d p),
 p = dL xs ->
 b <> 0%Z ->
 d = 0%Z ->
 (0 < outside_interval a b)%Z ->
 Qhomographic_sign a b c d p H_Qhomographic_sg_denom_nonzero =
 (Z.sgn c, (a, (b, (c, d)), p)).

Lemma Qhomographic_sign_dL_6 :
 forall (a b c d : Z) (p xs : Qpositive)
   (H_Qhomographic_sg_denom_nonzero : Qhomographic_sg_denom_nonzero c d p),
 p = dL xs ->
 b <> 0%Z ->
 d = 0%Z ->
 ~ (0 < outside_interval a b)%Z ->
 (outside_interval a b < 0)%Z ->
 Qhomographic_sign a b c d p H_Qhomographic_sg_denom_nonzero =
 ((- Z.sgn c)%Z, (a, (b, (c, d)), p)).

Lemma Qhomographic_sign_dL_7 :
 forall (a b c d : Z) (p xs : Qpositive)
   (H_Qhomographic_sg_denom_nonzero : Qhomographic_sg_denom_nonzero 
                                        (c + d) d xs)
   (H_Qhomographic_sg_denom_nonzero_dL : Qhomographic_sg_denom_nonzero c d
                                           (dL xs)),
 b <> 0%Z ->
 d = 0%Z ->
 ~ (0 < outside_interval a b)%Z ->
 ~ (outside_interval a b < 0)%Z ->
 Qhomographic_sign a b c d (dL xs) H_Qhomographic_sg_denom_nonzero_dL =
 Qhomographic_sign (a + b) b (c + d) d xs H_Qhomographic_sg_denom_nonzero.

Lemma Qhomographic_sign_dL_8 :
 forall (a b c d : Z) (p xs : Qpositive)
   (H_Qhomographic_sg_denom_nonzero : Qhomographic_sg_denom_nonzero c d p),
 p = dL xs ->
 b <> 0%Z ->
 d <> 0%Z ->
 inside_interval_1 (outside_interval a b) (outside_interval c d) ->
 Qhomographic_sign a b c d p H_Qhomographic_sg_denom_nonzero =
 (1%Z, (a, (b, (c, d)), p)).

Lemma Qhomographic_sign_dL_9 :
 forall (a b c d : Z) (p xs : Qpositive)
   (H_Qhomographic_sg_denom_nonzero : Qhomographic_sg_denom_nonzero c d p),
 p = dL xs ->
 b <> 0%Z ->
 d <> 0%Z ->
 ~ inside_interval_1 (outside_interval a b) (outside_interval c d) ->
 inside_interval_2 (outside_interval a b) (outside_interval c d) ->
 Qhomographic_sign a b c d p H_Qhomographic_sg_denom_nonzero =
 ((-1)%Z, (a, (b, (c, d)), p)).

Lemma Qhomographic_sign_dL_10 :
 forall (a b c d : Z) (p xs : Qpositive)
   (H_Qhomographic_sg_denom_nonzero : Qhomographic_sg_denom_nonzero 
                                        (c + d) d xs)
   (H_Qhomographic_sg_denom_nonzero_dL : Qhomographic_sg_denom_nonzero c d
                                           (dL xs)),
 b <> 0%Z ->
 d <> 0%Z ->
 ~ inside_interval_1 (outside_interval a b) (outside_interval c d) ->
 ~ inside_interval_2 (outside_interval a b) (outside_interval c d) ->
 Qhomographic_sign a b c d (dL xs) H_Qhomographic_sg_denom_nonzero_dL =
 Qhomographic_sign (a + b) b (c + d) d xs H_Qhomographic_sg_denom_nonzero.

Lemma sg_sign :
 forall (a b c d : Z) (qp : Qpositive)
   (H_Qhomographic_sg_denom_nonzero : Qhomographic_sg_denom_nonzero c d qp),
 let (l1, L2) :=
     Qhomographic_sign a b c d qp H_Qhomographic_sg_denom_nonzero in
 {l1 = 0%Z} + {l1 = 1%Z} + {l1 = (-1)%Z}.

Definition h_sign (a b c d : Z) (p : Qpositive)
  (H_Qhomographic_sg_denom_nonzero : Qhomographic_sg_denom_nonzero c d p) :=
  let (l1, L2) :=
      Qhomographic_sign a b c d p H_Qhomographic_sg_denom_nonzero in
  l1.

Lemma sg_sign_dec :
 forall (a b c d : Z) (p : Qpositive)
   (H_Qhomographic_sg_denom_nonzero : Qhomographic_sg_denom_nonzero c d p),
 {h_sign a b c d p H_Qhomographic_sg_denom_nonzero = 0%Z} +
 {h_sign a b c d p H_Qhomographic_sg_denom_nonzero = 1%Z} +
 {h_sign a b c d p H_Qhomographic_sg_denom_nonzero = (-1)%Z}. *)
Require Export Qhomographic_Qpositive_to_Qpositive.
(* Qhomographic_Qpositive_to_Qpositive:
Require Export general_Q.
Require Export positive_fraction_encoding.
Require Import Merge_Order.
Require Import Wf_nat.

Definition top_more (a b c d : Z) :=
  (c <= a)%Z /\ (d < b)%Z \/ (c < a)%Z /\ (d <= b)%Z.

Lemma top_more_informative :
 forall a b c d : Z, {top_more a b c d} + {~ top_more a b c d}.

Lemma top_more_1 :
 forall a b c d : Z, top_more a b c d -> (0 < a - c + (b - d))%Z.

Lemma top_more_2 : forall a b c d : Z, top_more a b c d -> (c + d < a + b)%Z.

Lemma top_more_3 :
 forall a b c d : Z, (0 < c + d)%Z -> (a - c + (b - d) < a + b)%Z.

Lemma top_more_4 : forall a b c d : Z, top_more a b c d -> (c <= a)%Z.

Lemma top_more_4' : forall a b c d : Z, top_more a b c d -> (d <= b)%Z.

Lemma top_more_5 :
 forall a b c d : Z,
 (0 < c + d)%Z -> (a - c + (b - d) + c + d < a + b + c + d)%Z.

Lemma top_more_5' :
 forall a b c d : Z,
 (0 < a + b)%Z -> (a + b + (c - a) + (d - b) < a + b + c + d)%Z.

Inductive homographicAcc : Z -> Z -> Z -> Z -> Qpositive -> Prop :=
  | homographicacc0 :
      forall (a b c d : Z) (p : Qpositive),
      p = One -> (0 < a + b)%Z -> (0 < c + d)%Z -> homographicAcc a b c d p
  | homographicacc1 :
      forall (a b c d : Z) (p : Qpositive),
      p <> One ->
      top_more a b c d ->
      homographicAcc (a - c)%Z (b - d)%Z c d p -> homographicAcc a b c d p
  | homographicacc2 :
      forall (a b c d : Z) (p : Qpositive),
      p <> One ->
      ~ top_more a b c d ->
      top_more c d a b ->
      homographicAcc a b (c - a)%Z (d - b)%Z p -> homographicAcc a b c d p
  | homographicacc3 :
      forall (a b c d : Z) (xs : Qpositive),
      ~ top_more a b c d ->
      ~ top_more c d a b ->
      homographicAcc a (a + b)%Z c (c + d)%Z xs ->
      homographicAcc a b c d (nR xs)
  | homographicacc3' :
      forall (a b c d : Z) (xs : Qpositive),
      ~ top_more a b c d ->
      ~ top_more c d a b ->
      homographicAcc (a + b)%Z b (c + d)%Z d xs ->
      homographicAcc a b c d (dL xs).

Lemma homographicacc_0_num :
 forall a b c d : Z, homographicAcc a b c d One -> (0 < a + b)%Z.

Lemma homographicacc_0_denom :
 forall a b c d : Z, homographicAcc a b c d One -> (0 < c + d)%Z.

Lemma homographicacc_1 :
 forall (a b c d : Z) (p : Qpositive),
 homographicAcc a b c d p ->
 p <> One -> top_more a b c d -> homographicAcc (a - c) (b - d) c d p.

Lemma homographicacc_2 :
 forall (a b c d : Z) (p : Qpositive),
 homographicAcc a b c d p ->
 p <> One ->
 ~ top_more a b c d ->
 top_more c d a b -> homographicAcc a b (c - a) (d - b) p.

Lemma homographicacc_3 :
 forall (a b c d : Z) (p : Qpositive),
 homographicAcc a b c d p ->
 forall xs : Qpositive,
 p = nR xs ->
 ~ top_more a b c d ->
 ~ top_more c d a b -> homographicAcc a (a + b) c (c + d) xs.

Lemma homographicacc_3' :
 forall (a b c d : Z) (p : Qpositive),
 homographicAcc a b c d p ->
 forall xs : Qpositive,
 p = dL xs ->
 ~ top_more a b c d ->
 ~ top_more c d a b -> homographicAcc (a + b) b (c + d) d xs.

Fixpoint Qhomographic_Qpositive_to_Qpositive (a b c d : Z) 
 (p : Qpositive) (hyp : homographicAcc a b c d p) {struct hyp} : Qpositive :=
  match Qpositive_dec_One p with
  | left H_p_is_One =>
      let H :=
        eq_ind p (fun p : Qpositive => homographicAcc a b c d p) hyp One
          H_p_is_One in
      (fun hyp0 : homographicAcc a b c d One =>
       (fun (Hab : (0 < a + b)%Z) (Hcd : (0 < c + d)%Z) =>
        positive_fraction_encoding (a + b) (c + d) Hab Hcd)
         (homographicacc_0_num a b c d hyp0)
         (homographicacc_0_denom a b c d hyp0)) H
  | right H_p_not_One =>
      match top_more_informative a b c d with
      | left H_abcd =>
          nR
            (Qhomographic_Qpositive_to_Qpositive (a - c)%Z 
               (b - d)%Z c d p
               (homographicacc_1 a b c d p hyp H_p_not_One H_abcd))
      | right H_abcd =>
          match top_more_informative c d a b with
          | left H_cdab =>
              dL
                (Qhomographic_Qpositive_to_Qpositive a b 
                   (c - a)%Z (d - b)%Z p
                   (homographicacc_2 a b c d p hyp H_p_not_One H_abcd H_cdab))
          | right H_cdab =>
              match p as q return (p = q -> Qpositive) with
              | nR q =>
                  fun H : p = nR q =>
                  Qhomographic_Qpositive_to_Qpositive a 
                    (a + b)%Z c (c + d)%Z q
                    (homographicacc_3 a b c d p hyp q H H_abcd H_cdab)
              | dL q =>
                  fun H : p = dL q =>
                  Qhomographic_Qpositive_to_Qpositive 
                    (a + b)%Z b (c + d)%Z d q
                    (homographicacc_3' a b c d p hyp q H H_abcd H_cdab)
              | One =>
                  fun q : p = One =>
                  False_rec Qpositive (False_ind False (H_p_not_One q))
              end (refl_equal p)
          end
      end
  end.

Fixpoint Qpositive_length (qp : Qpositive) : nat :=
  match qp with
  | One => 0
  | dL qp1 => S (Qpositive_length qp1)
  | nR qp1 => S (Qpositive_length qp1)
  end.

Definition bin_lt (qp1 qp2 : Qpositive) : Prop :=
  Qpositive_length qp1 < Qpositive_length qp2.

Definition bin_eq (x y : Qpositive) := x = y.

Lemma bin_lt_compat_via_length :
 forall x y : Qpositive,
 bin_lt x y -> Qpositive_length x < Qpositive_length y.

Lemma compare_dL : forall x : Qpositive, bin_lt x (dL x). 

Lemma compare_nR : forall x : Qpositive, bin_lt x (nR x). 

Record Z_pos : Set :=  {zposcrr :> Z; z4prf_Z_pos : (0 <= zposcrr)%Z}.

Definition qlt (a b c d : Z) (p : Qpositive) (a' b' c' d' : Z)
  (p' : Qpositive) : Prop :=
  bin_lt p p' \/ p = p' /\ (a + b + c + d < a' + b' + c' + d')%Z. 

Definition qle (a b c d : Z) (p : Qpositive) (a' b' c' d' : Z)
  (p' : Qpositive) : Prop :=
  qlt a b c d p a' b' c' d' p' \/
  a = a' /\ b = b' /\ c = c' /\ d = d' /\ p = p'. 

Definition quadrointegral_lt (a b c d a' b' c' d' : Z) :=
  (a + b + c + d < a' + b' + c' + d')%Z.

Definition quadrointegral_eq (a b c d a' b' c' d' : Z) :=
  a = a' /\ b = b' /\ c = c' /\ d = d'.

Record Z4 : Set := 
  {z4crr :> Z * Z * (Z * Z);
   z4prf :
    (0 <= fst (fst z4crr))%Z /\
    (0 <= snd (fst z4crr))%Z /\
    (0 <= fst (snd z4crr))%Z /\ (0 <= snd (snd z4crr))%Z}.

Definition Z4_lt (x y : Z4) :=
  let (V1, V2) := z4crr x in
  let (V3, V4) := z4crr y in
  let (a, b) := V1 in
  let (c, d) := V2 in
  let (a', b') := V3 in
  let (c', d') := V4 in quadrointegral_lt a b c d a' b' c' d'.

Definition Z4_eq (x y : Z4) :=
  let (V1, V2) := z4crr x in
  let (V3, V4) := z4crr y in
  let (a, b) := V1 in
  let (c, d) := V2 in
  let (a', b') := V3 in
  let (c', d') := V4 in quadrointegral_eq a b c d a' b' c' d'.

Lemma Z4_lt_is_irreflexive : forall x : Z4, ~ Z4_lt x x.

Lemma Z4_lt_is_transitive :
 forall x y z : Z4, Z4_lt x y -> Z4_lt y z -> Z4_lt x z.

Lemma Z4_lt_is_order : is_order Z4 Z4_lt.

Lemma Z4_eq_is_reflexive : forall x : Z4, Z4_eq x x.

Lemma Z4_eq_is_symmetric : forall x y : Z4, Z4_eq x y -> Z4_eq y x.

Lemma Z4_eq_is_transitive :
 forall x y z : Z4, Z4_eq x y -> Z4_eq y z -> Z4_eq x z.

Lemma Z4_eq_is_equality : is_equality Z4 Z4_eq.

Lemma Z_pos_lt_is_wf :
 forall P : Z_pos -> Prop,
 (forall q : Z_pos, (forall r : Z_pos, (r < q)%Z -> P r) -> P q) ->
 forall q : Z_pos, P q.

Lemma Z4_lt_is_wf : wf_ind Z4 Z4_lt.

Lemma Z4_lt_is_well_def_rht : is_well_def_rht Z4 Z4_lt Z4_eq.

Definition Z4_as_well_ordering :=
  Build_well_ordering Z4 Z4_lt Z4_eq Z4_lt_is_order Z4_eq_is_equality
    Z4_lt_is_wf Z4_lt_is_well_def_rht.

Lemma bin_lt_is_irreflexive : forall x : Qpositive, ~ bin_lt x x.

Lemma bin_lt_is_transitive :
 forall x y z : Qpositive, bin_lt x y -> bin_lt y z -> bin_lt x z.

Lemma bin_lt_is_order : is_order Qpositive bin_lt.

Lemma bin_eq_is_reflexive : forall x : Qpositive, bin_eq x x.

Lemma bin_eq_is_symmetric : forall x y : Qpositive, bin_eq x y -> bin_eq y x.

Lemma bin_eq_is_transitive :
 forall x y z : Qpositive, bin_eq x y -> bin_eq y z -> bin_eq x z.

Lemma bin_eq_is_equality : is_equality Qpositive bin_eq.

Lemma bin_lt_is_wf : wf_ind Qpositive bin_lt.

Lemma bin_lt_is_well_def_rht : is_well_def_rht Qpositive bin_lt bin_eq.

Definition Qpositive_as_well_ordering :=
  Build_well_ordering Qpositive bin_lt bin_eq bin_lt_is_order
    bin_eq_is_equality bin_lt_is_wf bin_lt_is_well_def_rht.

Lemma qlt_wf_rec_without_zeros_and_One :
 forall P : Z -> Z -> Z -> Z -> Qpositive -> Prop,
 (forall (a b c d : Z_pos) (p : Qpositive),
  (forall (r s t u : Z_pos) (p1 : Qpositive),
   qlt r s t u p1 a b c d p -> P r s t u p1) -> P a b c d p) ->
 forall (a b c d : Z_pos) (p : Qpositive), P a b c d p.

Lemma homographicAcc_wf :
 forall (a b c d : Z) (p : Qpositive),
 (0 < a + b)%Z ->
 (0 < c + d)%Z ->
 (0 <= a)%Z ->
 (0 <= b)%Z -> (0 <= c)%Z -> (0 <= d)%Z -> homographicAcc a b c d p.

Remark one_non_negative : (0 <= 1)%Z.

Remark two_non_negative : (0 <= 2)%Z.

Remark three_non_negative : (0 <= 3)%Z.

Remark four_non_negative : (0 <= 4)%Z.

Remark five_non_negative : (0 <= 5)%Z.

Remark six_non_negative : (0 <= 6)%Z.

Remark seven_non_negative : (0 <= 7)%Z.

Remark two_plus_three_positive : (0 < 2 + 3)%Z.

Remark one_plus_four_positive : (0 < 1 + 4)%Z.

Definition homographicacc_wf_for_five_over_five :=
  homographicAcc_wf 2 3 1 4 One two_plus_three_positive
    one_plus_four_positive two_non_negative three_non_negative
    one_non_negative four_non_negative.

Scheme homographicAcc_ind_dep := Induction for homographicAcc Sort Prop.

Lemma Qhomographic_Qpositive_to_Qpositive_equal :
 forall (a b c d : Z) (p : Qpositive) (hyp1 hyp2 : homographicAcc a b c d p),
 Qhomographic_Qpositive_to_Qpositive a b c d p hyp1 =
 Qhomographic_Qpositive_to_Qpositive a b c d p hyp2.

Lemma Qhomographic_Qpositive_to_Qpositive_equal_strong :
 forall (a1 a2 b1 b2 c1 c2 d1 d2 : Z) (p1 p2 : Qpositive)
   (hyp1 : homographicAcc a1 b1 c1 d1 p1)
   (hyp2 : homographicAcc a2 b2 c2 d2 p2),
 a1 = a2 ->
 b1 = b2 ->
 c1 = c2 ->
 d1 = d2 ->
 p1 = p2 ->
 Qhomographic_Qpositive_to_Qpositive a1 b1 c1 d1 p1 hyp1 =
 Qhomographic_Qpositive_to_Qpositive a2 b2 c2 d2 p2 hyp2.

Lemma Qhomographic_Qpositive_to_Qpositive_0 :
 forall (a b c d : Z) (p : Qpositive) (hyp : homographicAcc a b c d p),
 p = One ->
 forall (H1 : (0 < a + b)%Z) (H2 : (0 < c + d)%Z),
 Qhomographic_Qpositive_to_Qpositive a b c d p hyp =
 positive_fraction_encoding (a + b) (c + d) H1 H2. 

Lemma Qhomographic_Qpositive_to_Qpositive_1 :
 forall (a b c d : Z) (p : Qpositive) (hyp : homographicAcc a b c d p),
 p <> One ->
 top_more a b c d ->
 forall h : homographicAcc (a - c) (b - d) c d p,
 Qhomographic_Qpositive_to_Qpositive a b c d p hyp =
 nR (Qhomographic_Qpositive_to_Qpositive (a - c) (b - d) c d p h).

Lemma Qhomographic_Qpositive_to_Qpositive_2 :
 forall (a b c d : Z) (p : Qpositive) (hyp : homographicAcc a b c d p),
 p <> One ->
 ~ top_more a b c d ->
 top_more c d a b ->
 forall h : homographicAcc a b (c - a) (d - b) p,
 Qhomographic_Qpositive_to_Qpositive a b c d p hyp =
 dL (Qhomographic_Qpositive_to_Qpositive a b (c - a) (d - b) p h).

Lemma Qhomographic_Qpositive_to_Qpositive_3 :
 forall (a b c d : Z) (p : Qpositive) (hyp : homographicAcc a b c d p),
 ~ top_more a b c d ->
 ~ top_more c d a b ->
 forall xs : Qpositive,
 p = nR xs ->
 forall h : homographicAcc a (a + b) c (c + d) xs,
 Qhomographic_Qpositive_to_Qpositive a b c d p hyp =
 Qhomographic_Qpositive_to_Qpositive a (a + b) c (c + d) xs h.

Lemma Qhomographic_Qpositive_to_Qpositive_3' :
 forall (a b c d : Z) (p : Qpositive) (hyp : homographicAcc a b c d p),
 ~ top_more a b c d ->
 ~ top_more c d a b ->
 forall xs : Qpositive,
 p = dL xs ->
 forall h : homographicAcc (a + b) b (c + d) d xs,
 Qhomographic_Qpositive_to_Qpositive a b c d p hyp =
 Qhomographic_Qpositive_to_Qpositive (a + b) b (c + d) d xs h. *)
Require Export Qhomographic_sign_properties.
(* Qhomographic_sign_properties:
Require Export Qhomographic_sign.
Require Import ZArithRing Zaux.

Lemma sg_tuple_equal :
 forall (l1 a1 b1 c1 d1 : Z) (p1 : Qpositive) (l2 a2 b2 c2 d2 : Z)
   (p2 : Qpositive),
 (l1, (a1, (b1, (c1, d1)), p1)) = (l2, (a2, (b2, (c2, d2)), p2)) ->
 l1 = l2 /\ (a1 = a2 /\ b1 = b2 /\ c1 = c2 /\ d1 = d2) /\ p1 = p2.

Lemma inside_interval_1_inf :
 forall o1 o2 : Z,
 inside_interval_1 o1 o2 ->
 {(0 < o1)%Z /\ (0 < o2)%Z} + {(o1 < 0)%Z /\ (o2 < 0)%Z}.
   
Lemma inside_interval_2_inf :
 forall o1 o2 : Z,
 inside_interval_2 o1 o2 ->
 {(0 < o1)%Z /\ (o2 < 0)%Z} + {(o1 < 0)%Z /\ (0 < o2)%Z}.
   
Lemma sg_pos_1 :
 forall (a b c d : Z) (p : Qpositive)
   (H_Qhomographic_sg_denom_nonzero : Qhomographic_sg_denom_nonzero c d p)
   (na nb nc nd : Z) (np : Qpositive),
 Qhomographic_sign a b c d p H_Qhomographic_sg_denom_nonzero =
 (1%Z, (na, (nb, (nc, nd)), np)) ->
 {(0 < na + nb)%Z /\ (0 < nc + nd)%Z} + {(na + nb < 0)%Z /\ (nc + nd < 0)%Z}.

Lemma sg_pos_2 :
 forall (a b c d : Z) (p : Qpositive)
   (H_Qhomographic_sg_denom_nonzero : Qhomographic_sg_denom_nonzero c d p)
   (na nb nc nd : Z) (np : Qpositive),
 Qhomographic_sign a b c d p H_Qhomographic_sg_denom_nonzero =
 (1%Z, (na, (nb, (nc, nd)), np)) ->
 {(0 <= na)%Z /\ (0 <= nb)%Z /\ (0 <= nc)%Z /\ (0 <= nd)%Z} +
 {(na <= 0)%Z /\ (nb <= 0)%Z /\ (nc <= 0)%Z /\ (nd <= 0)%Z} + 
 {np = One}.

Lemma sg_neg_1 :
 forall (a b c d : Z) (p : Qpositive)
   (H_Qhomographic_sg_denom_nonzero : Qhomographic_sg_denom_nonzero c d p)
   (na nb nc nd : Z) (np : Qpositive),
 Qhomographic_sign a b c d p H_Qhomographic_sg_denom_nonzero =
 ((-1)%Z, (na, (nb, (nc, nd)), np)) ->
 {(0 < na + nb)%Z /\ (nc + nd < 0)%Z} + {(na + nb < 0)%Z /\ (0 < nc + nd)%Z}.

Lemma sg_neg_2 :
 forall (a b c d : Z) (p : Qpositive)
   (H_Qhomographic_sg_denom_nonzero : Qhomographic_sg_denom_nonzero c d p)
   (na nb nc nd : Z) (np : Qpositive),
 Qhomographic_sign a b c d p H_Qhomographic_sg_denom_nonzero =
 ((-1)%Z, (na, (nb, (nc, nd)), np)) ->
 {(0 <= na)%Z /\ (0 <= nb)%Z /\ (nc <= 0)%Z /\ (nd <= 0)%Z} +
 {(na <= 0)%Z /\ (nb <= 0)%Z /\ (0 <= nc)%Z /\ (0 <= nd)%Z} + 
 {np = One}. *)

Definition new_a (a b c d : Z) (p : Qpositive)
  (H_Qhomographic_sg_denom_nonzero : Qhomographic_sg_denom_nonzero c d p) :=
  fst
    (fst (snd (Qhomographic_sign a b c d p H_Qhomographic_sg_denom_nonzero))).

Definition new_b (a b c d : Z) (p : Qpositive)
  (H_Qhomographic_sg_denom_nonzero : Qhomographic_sg_denom_nonzero c d p) :=
  fst
    (snd
       (fst
          (snd (Qhomographic_sign a b c d p H_Qhomographic_sg_denom_nonzero)))).

Definition new_c (a b c d : Z) (p : Qpositive)
  (H_Qhomographic_sg_denom_nonzero : Qhomographic_sg_denom_nonzero c d p) :=
  fst
    (snd
       (snd
          (fst
             (snd
                (Qhomographic_sign a b c d p H_Qhomographic_sg_denom_nonzero))))).

Definition new_d (a b c d : Z) (p : Qpositive)
  (H_Qhomographic_sg_denom_nonzero : Qhomographic_sg_denom_nonzero c d p) :=
  snd
    (snd
       (snd
          (fst
             (snd
                (Qhomographic_sign a b c d p H_Qhomographic_sg_denom_nonzero))))).

Definition new_p (a b c d : Z) (p : Qpositive)
  (H_Qhomographic_sg_denom_nonzero : Qhomographic_sg_denom_nonzero c d p) :=
  snd (snd (Qhomographic_sign a b c d p H_Qhomographic_sg_denom_nonzero)).

Lemma Qhomographic_Qpositive_to_Q_homographicAcc_pos_1 :
 forall (a b c d : Z) (p : Qpositive)
   (H_Qhomographic_sg_denom_nonzero : Qhomographic_sg_denom_nonzero c d p),
 (a * d)%Z <> (b * c)%Z ->
 h_sign a b c d p H_Qhomographic_sg_denom_nonzero = 1%Z ->
 (0 <
  Z.sgn
    (new_a a b c d p H_Qhomographic_sg_denom_nonzero +
     new_b a b c d p H_Qhomographic_sg_denom_nonzero))%Z ->
 homographicAcc (new_a a b c d p H_Qhomographic_sg_denom_nonzero)
   (new_b a b c d p H_Qhomographic_sg_denom_nonzero)
   (new_c a b c d p H_Qhomographic_sg_denom_nonzero)
   (new_d a b c d p H_Qhomographic_sg_denom_nonzero)
   (new_p a b c d p H_Qhomographic_sg_denom_nonzero).
Proof.
 intros a b c d p H_hsign ad_neq_bc l1_eq_one z.
 set (na := new_a a b c d p H_hsign) in *.
 set (nb := new_b a b c d p H_hsign) in *.
 set (nc := new_c a b c d p H_hsign) in *.
 set (nd := new_d a b c d p H_hsign) in *.
 set (l3 := new_p a b c d p H_hsign) in *.
 assert
  (H : Qhomographic_sign a b c d p H_hsign = (1%Z, (na, (nb, (nc, nd)), l3))).
 unfold na, nb, nc, nd, l3 in |- *.
 rewrite <- l1_eq_one.
 unfold new_a, new_b, new_c, new_d, new_p in |- *.
 replace (h_sign a b c d p H_hsign) with
  (fst (Qhomographic_sign a b c d p H_hsign)); [ idtac | reflexivity ];
  repeat rewrite <- pair_1; reflexivity.
      destruct l3 as [p0| p0| ].
      
      apply homographicAcc_wf.
      apply Zsgn_12.
      assumption.
     
      generalize (sg_pos_1 a b c d p H_hsign na nb nc nd (nR p0) H).        
      intros.
      case H0.             
      intro.
      elim a0.
      intros.     
      assumption.
      intros.
      apply False_ind.      
      elim a0.
      intros.
      generalize (Zsgn_12 (na + nb) z).
      intro.
      apply Z.lt_irrefl with 0%Z.
      apply Z.lt_trans with (na + nb)%Z.
      assumption.
      assumption.
      generalize (sg_pos_2 a b c d p H_hsign na nb nc nd (nR p0) H). 
      intro.
      case H0.         
      intro.
      case s.
      intro.
      elim a0. 
      intros; assumption.
      intro.
      apply False_ind.
      elim a0.
      intros.
      elim H2.
      intros.
      apply Z.lt_irrefl with 0%Z.
      apply Z.lt_le_trans with (na + nb)%Z.
      apply Zsgn_12.
      assumption.
      rewrite Zplus_0_r_reverse with 0%Z.
      apply Zplus_le_compat.
      assumption.      
      assumption.
      intro.      
      discriminate e.
      generalize (sg_pos_2 a b c d p H_hsign na nb nc nd (nR p0) H). 
      intro.
      case H0.         
      intro.
      case s.
      intro.
      elim a0. 
      intros.
      elim H2.
      intros.
      assumption.
      intro.
      apply False_ind.
      elim a0.
      intros.
      elim H2.
      intros.
      apply Z.lt_irrefl with 0%Z.
      apply Z.lt_le_trans with (na + nb)%Z.
      apply Zsgn_12.
      assumption.
      rewrite Zplus_0_r_reverse with 0%Z.
      apply Zplus_le_compat.
      assumption.      
      assumption.
      intro.      
      discriminate e.
      generalize (sg_pos_2 a b c d p H_hsign na nb nc nd (nR p0) H). 
      intro.
      case H0.         
      intro.
      case s.
      intro.
      elim a0. 
      intros.
      elim H2.
      intros.
      elim H4.
      intros.
      assumption.
      intro.
      apply False_ind.
      elim a0.
      intros.
      elim H2.
      intros.
      apply Z.lt_irrefl with 0%Z.
      apply Z.lt_le_trans with (na + nb)%Z.
      apply Zsgn_12.
      assumption.
      rewrite Zplus_0_r_reverse with 0%Z.
      apply Zplus_le_compat.
      assumption.      
      assumption.
      intro.      
      discriminate e.
      generalize (sg_pos_2 a b c d p H_hsign na nb nc nd (nR p0) H). 
      intro.
      case H0.         
      intro.
      case s.
      intro.
      elim a0. 
      intros.
      elim H2.
      intros.
      elim H4.
      intros.
      assumption.
      intro.
      apply False_ind.
      elim a0.
      intros.
      elim H2.
      intros.
      apply Z.lt_irrefl with 0%Z.
      apply Z.lt_le_trans with (na + nb)%Z.
      apply Zsgn_12.
      assumption.
      rewrite Zplus_0_r_reverse with 0%Z.
      apply Zplus_le_compat.
      assumption.      
      assumption.
      intro.      
      discriminate e.
      
      apply homographicAcc_wf.
      apply Zsgn_12.
      assumption.
     
      generalize (sg_pos_1 a b c d p H_hsign na nb nc nd (dL p0) H).        
      intros.
      case H0.             
      intro.
      elim a0.
      intros.     
      assumption.
      intros.
      apply False_ind.      
      elim a0.
      intros.
      generalize (Zsgn_12 (na + nb) z).
      intro.
      apply Z.lt_irrefl with 0%Z.
      apply Z.lt_trans with (na + nb)%Z.
      assumption.
      assumption.
      generalize (sg_pos_2 a b c d p H_hsign na nb nc nd (dL p0) H). 
      intro.
      case H0.         
      intro.
      case s.
      intro.
      elim a0. 
      intros; assumption.
      intro.
      apply False_ind.
      elim a0.
      intros.
      elim H2.
      intros.
      apply Z.lt_irrefl with 0%Z.
      apply Z.lt_le_trans with (na + nb)%Z.
      apply Zsgn_12.
      assumption.
      rewrite Zplus_0_r_reverse with 0%Z.
      apply Zplus_le_compat.
      assumption.      
      assumption.
      intro.      
      discriminate e.
      generalize (sg_pos_2 a b c d p H_hsign na nb nc nd (dL p0) H). 
      intro.
      case H0.         
      intro.
      case s.
      intro.
      elim a0. 
      intros.
      elim H2.
      intros.
      assumption.
      intro.
      apply False_ind.
      elim a0.
      intros.
      elim H2.
      intros.
      apply Z.lt_irrefl with 0%Z.
      apply Z.lt_le_trans with (na + nb)%Z.
      apply Zsgn_12.
      assumption.
      rewrite Zplus_0_r_reverse with 0%Z.
      apply Zplus_le_compat.
      assumption.      
      assumption.
      intro.      
      discriminate e.
      generalize (sg_pos_2 a b c d p H_hsign na nb nc nd (dL p0) H). 
      intro.
      case H0.         
      intro.
      case s.
      intro.
      elim a0. 
      intros.
      elim H2.
      intros.
      elim H4.
      intros.
      assumption.
      intro.
      apply False_ind.
      elim a0.
      intros.
      elim H2.
      intros.
      apply Z.lt_irrefl with 0%Z.
      apply Z.lt_le_trans with (na + nb)%Z.
      apply Zsgn_12.
      assumption.
      rewrite Zplus_0_r_reverse with 0%Z.
      apply Zplus_le_compat.
      assumption.      
      assumption.
      intro.      
      discriminate e.
      generalize (sg_pos_2 a b c d p H_hsign na nb nc nd (dL p0) H). 
      intro.
      case H0.         
      intro.
      case s.
      intro.
      elim a0. 
      intros.
      elim H2.
      intros.
      elim H4.
      intros.
      assumption.
      intro.
      apply False_ind.
      elim a0.
      intros.
      elim H2.
      intros.
      apply Z.lt_irrefl with 0%Z.
      apply Z.lt_le_trans with (na + nb)%Z.
      apply Zsgn_12.
      assumption.
      rewrite Zplus_0_r_reverse with 0%Z.
      apply Zplus_le_compat.
      assumption.      
      assumption.
      intro.      
      discriminate e.
      
      apply homographicacc0.
      reflexivity.
      apply Zsgn_12.
      assumption.
      generalize (sg_pos_1 a b c d p H_hsign na nb nc nd One H).        
      intros.
      case H0.             
      intro.
      elim a0.
      intros.     
      assumption.
      intros.
      apply False_ind.      
      elim a0.
      intros.
      generalize (Zsgn_12 (na + nb) z).
      intro.
      apply Z.lt_irrefl with 0%Z.
      apply Z.lt_trans with (na + nb)%Z.
      assumption.
      assumption.
Defined.

Lemma Qhomographic_Qpositive_to_Q_homographicAcc_pos_2 :
 forall (a b c d : Z) (p : Qpositive)
   (H_Qhomographic_sg_denom_nonzero : Qhomographic_sg_denom_nonzero c d p),
 (a * d)%Z <> (b * c)%Z ->
 h_sign a b c d p H_Qhomographic_sg_denom_nonzero = 1%Z ->
 (Z.sgn
    (new_a a b c d p H_Qhomographic_sg_denom_nonzero +
     new_b a b c d p H_Qhomographic_sg_denom_nonzero) <= 0)%Z ->
 homographicAcc (- new_a a b c d p H_Qhomographic_sg_denom_nonzero)
   (- new_b a b c d p H_Qhomographic_sg_denom_nonzero)
   (- new_c a b c d p H_Qhomographic_sg_denom_nonzero)
   (- new_d a b c d p H_Qhomographic_sg_denom_nonzero)
   (new_p a b c d p H_Qhomographic_sg_denom_nonzero).
Proof.
 intros a b c d p H_hsign ad_neq_bc l1_eq_one z.
 set (na := new_a a b c d p H_hsign) in *.
 set (nb := new_b a b c d p H_hsign) in *.
 set (nc := new_c a b c d p H_hsign) in *.
 set (nd := new_d a b c d p H_hsign) in *.
 set (l3 := new_p a b c d p H_hsign) in *.
 assert
  (H : Qhomographic_sign a b c d p H_hsign = (1%Z, (na, (nb, (nc, nd)), l3))).
 unfold na, nb, nc, nd, l3 in |- *.
 rewrite <- l1_eq_one.
 unfold new_a, new_b, new_c, new_d, new_p in |- *.
 replace (h_sign a b c d p H_hsign) with
  (fst (Qhomographic_sign a b c d p H_hsign)); [ idtac | reflexivity ];
  repeat rewrite <- pair_1; reflexivity.
      destruct l3 as [p0| p0| ].
      
      apply homographicAcc_wf.
      generalize (sg_pos_1 a b c d p H_hsign na nb nc nd (nR p0) H).
      intro.
      case H0. 
      intros.
      apply False_ind.
      elim a0.
      intros.      
      generalize (Zsgn_14 _ z).
      intro.
      apply Z.lt_irrefl with 0%Z.
      apply Z.lt_le_trans with (na + nb)%Z.
      assumption.
      assumption.
      intro.
      elim a0.
      intros.
      rewrite <- Zopp_plus_distr.
      apply Zlt_neg_opp.
      assumption.
      generalize (sg_pos_1 a b c d p H_hsign na nb nc nd (nR p0) H).
      intro.
      case H0. 
      intros.
      apply False_ind.
      elim a0.
      intros.      
      generalize (Zsgn_14 _ z).
      intro.
      apply Z.lt_irrefl with 0%Z.
      apply Z.lt_le_trans with (na + nb)%Z.
      assumption.
      assumption.
      intro.
      elim a0.
      intros.
      rewrite <- Zopp_plus_distr.
      apply Zlt_neg_opp.
      assumption.
      generalize (sg_pos_2 a b c d p H_hsign na nb nc nd (nR p0) H). 
      intro.
      case H0.         
      intro.
      case s.
      intro.
      elim a0.
      intros.
      case (Z_le_lt_eq_dec 0 na H1).
      intro.
      apply False_ind.
      elim H2.
      intros.
      apply Z.lt_irrefl with 0%Z.
      apply Z.lt_le_trans with (na + nb)%Z.
      rewrite Zplus_0_r_reverse with 0%Z.
      apply Zplus_lt_le_compat.
      assumption.      
      assumption.
      apply (Zsgn_14 _ z).
      intro.
      rewrite <- e.
      simpl in |- *.
      apply Z.le_refl.
      intro.
      elim a0.
      intros.
      apply Zle_neg_opp.      
      assumption.
      intro.      
      discriminate e.
      generalize (sg_pos_2 a b c d p H_hsign na nb nc nd (nR p0) H). 
      intro.
      case H0.         
      intro.
      case s.
      intro.
      elim a0.
      intros.
      elim H2.
      intros.
      case (Z_le_lt_eq_dec 0 nb H3).
      intro.
      apply False_ind.
      apply Z.lt_irrefl with 0%Z.
      apply Z.lt_le_trans with (na + nb)%Z.
      rewrite Zplus_0_r_reverse with 0%Z.
      apply Zplus_le_lt_compat.
      assumption.      
      assumption.
      apply (Zsgn_14 _ z).
      intro.
      rewrite <- e.
      simpl in |- *.
      apply Z.le_refl.
      intro.
      elim a0.
      intros.
      elim H2.
      intros.
      apply Zle_neg_opp.      
      assumption.
      intro.      
      discriminate e.
      generalize (sg_pos_2 a b c d p H_hsign na nb nc nd (nR p0) H). 
      intro.
      case H0.         
      intro.
      case s.
      intro.
      elim a0.
      intros.
      elim H2.
      intros.
      elim H4.
      intros.
      case (Z_le_lt_eq_dec 0 nc H5).
      intro.
      apply False_ind.
      apply Z.lt_irrefl with 0%Z.
      apply Z.lt_le_trans with (nc + nd)%Z.
      rewrite Zplus_0_r_reverse with 0%Z.
      apply Zplus_lt_le_compat.
      assumption.      
      assumption.
      case (sg_pos_1 a b c d p H_hsign na nb nc nd (nR p0) H).
      intro. 
      apply False_ind.
      elim a1.
      intros.
      apply Z.lt_irrefl with 0%Z.
      apply Z.lt_le_trans with (na + nb)%Z.
      assumption.
      apply (Zsgn_14 _ z).
      intros.
      elim a1.
      intros.
      apply Zlt_le_weak.      
      assumption.
      intro.
      rewrite <- e.
      simpl in |- *.
      apply Z.le_refl.
      intro.
      elim a0.
      intros.
      elim H2.
      intros.
      elim H4. 
      intros.
      apply Zle_neg_opp.      
      assumption.
      intro.      
      discriminate e.
      generalize (sg_pos_2 a b c d p H_hsign na nb nc nd (nR p0) H). 
      intro.
      case H0.         
      intro.
      case s.
      intro.
      elim a0.
      intros.
      elim H2.
      intros.
      elim H4.
      intros.
      case (Z_le_lt_eq_dec 0 nd H6).
      intro.
      apply False_ind.
      apply Z.lt_irrefl with 0%Z.
      apply Z.lt_le_trans with (nc + nd)%Z.
      rewrite Zplus_0_r_reverse with 0%Z.
      apply Zplus_le_lt_compat.
      assumption.      
      assumption.
      case (sg_pos_1 a b c d p H_hsign na nb nc nd (nR p0) H).
      intro. 
      apply False_ind.
      elim a1.
      intros.
      apply Z.lt_irrefl with 0%Z.
      apply Z.lt_le_trans with (na + nb)%Z.
      assumption.
      apply (Zsgn_14 _ z).
      intros.
      elim a1.
      intros.
      apply Zlt_le_weak.      
      assumption.
      intro.
      rewrite <- e.
      simpl in |- *.
      apply Z.le_refl.
      intro.
      elim a0.
      intros.
      elim H2.
      intros.
      elim H4. 
      intros.
      apply Zle_neg_opp.      
      assumption.
      intro.      
      discriminate e.
      
      apply homographicAcc_wf.
      generalize (sg_pos_1 a b c d p H_hsign na nb nc nd (dL p0) H).
      intro.
      case H0. 
      intros.
      apply False_ind.
      elim a0.
      intros.      
      generalize (Zsgn_14 _ z).
      intro.
      apply Z.lt_irrefl with 0%Z.
      apply Z.lt_le_trans with (na + nb)%Z.
      assumption.
      assumption.
      intro.
      elim a0.
      intros.
      rewrite <- Zopp_plus_distr.
      apply Zlt_neg_opp.
      assumption.
      generalize (sg_pos_1 a b c d p H_hsign na nb nc nd (dL p0) H).
      intro.
      case H0. 
      intros.
      apply False_ind.
      elim a0.
      intros.      
      generalize (Zsgn_14 _ z).
      intro.
      apply Z.lt_irrefl with 0%Z.
      apply Z.lt_le_trans with (na + nb)%Z.
      assumption.
      assumption.
      intro.
      elim a0.
      intros.
      rewrite <- Zopp_plus_distr.
      apply Zlt_neg_opp.
      assumption.
      generalize (sg_pos_2 a b c d p H_hsign na nb nc nd (dL p0) H). 
      intro.
      case H0.         
      intro.
      case s.
      intro.
      elim a0.
      intros.
      case (Z_le_lt_eq_dec 0 na H1).
      intro.
      apply False_ind.
      elim H2.
      intros.
      apply Z.lt_irrefl with 0%Z.
      apply Z.lt_le_trans with (na + nb)%Z.
      rewrite Zplus_0_r_reverse with 0%Z.
      apply Zplus_lt_le_compat.
      assumption.      
      assumption.
      apply (Zsgn_14 _ z).
      intro.
      rewrite <- e.
      simpl in |- *.
      apply Z.le_refl.
      intro.
      elim a0.
      intros.
      apply Zle_neg_opp.      
      assumption.
      intro.      
      discriminate e.
      generalize (sg_pos_2 a b c d p H_hsign na nb nc nd (dL p0) H). 
      intro.
      case H0.         
      intro.
      case s.
      intro.
      elim a0.
      intros.
      elim H2.
      intros.
      case (Z_le_lt_eq_dec 0 nb H3).
      intro.
      apply False_ind.
      apply Z.lt_irrefl with 0%Z.
      apply Z.lt_le_trans with (na + nb)%Z.
      rewrite Zplus_0_r_reverse with 0%Z.
      apply Zplus_le_lt_compat.
      assumption.      
      assumption.
      apply (Zsgn_14 _ z).
      intro.
      rewrite <- e.
      simpl in |- *.
      apply Z.le_refl.
      intro.
      elim a0.
      intros.
      elim H2.
      intros.
      apply Zle_neg_opp.      
      assumption.
      intro.      
      discriminate e.
      generalize (sg_pos_2 a b c d p H_hsign na nb nc nd (dL p0) H). 
      intro.
      case H0.         
      intro.
      case s.
      intro.
      elim a0.
      intros.
      elim H2.
      intros.
      elim H4.
      intros.
      case (Z_le_lt_eq_dec 0 nc H5).
      intro.
      apply False_ind.
      apply Z.lt_irrefl with 0%Z.
      apply Z.lt_le_trans with (nc + nd)%Z.
      rewrite Zplus_0_r_reverse with 0%Z.
      apply Zplus_lt_le_compat.
      assumption.      
      assumption.
      case (sg_pos_1 a b c d p H_hsign na nb nc nd (dL p0) H).
      intro. 
      apply False_ind.
      elim a1.
      intros.
      apply Z.lt_irrefl with 0%Z.
      apply Z.lt_le_trans with (na + nb)%Z.
      assumption.
      apply (Zsgn_14 _ z).
      intros.
      elim a1.
      intros.
      apply Zlt_le_weak.      
      assumption.
      intro.
      rewrite <- e.
      simpl in |- *.
      apply Z.le_refl.
      intro.
      elim a0.
      intros.
      elim H2.
      intros.
      elim H4. 
      intros.
      apply Zle_neg_opp.      
      assumption.
      intro.      
      discriminate e.
      generalize (sg_pos_2 a b c d p H_hsign na nb nc nd (dL p0) H). 
      intro.
      case H0.         
      intro.
      case s.
      intro.
      elim a0.
      intros.
      elim H2.
      intros.
      elim H4.
      intros.
      case (Z_le_lt_eq_dec 0 nd H6).
      intro.
      apply False_ind.
      apply Z.lt_irrefl with 0%Z.
      apply Z.lt_le_trans with (nc + nd)%Z.
      rewrite Zplus_0_r_reverse with 0%Z.
      apply Zplus_le_lt_compat.
      assumption.      
      assumption.
      case (sg_pos_1 a b c d p H_hsign na nb nc nd (dL p0) H).
      intro. 
      apply False_ind.
      elim a1.
      intros.
      apply Z.lt_irrefl with 0%Z.
      apply Z.lt_le_trans with (na + nb)%Z.
      assumption.
      apply (Zsgn_14 _ z).
      intros.
      elim a1.
      intros.
      apply Zlt_le_weak.      
      assumption.
      intro.
      rewrite <- e.
      simpl in |- *.
      apply Z.le_refl.
      intro.
      elim a0.
      intros.
      elim H2.
      intros.
      elim H4. 
      intros.
      apply Zle_neg_opp.      
      assumption.
      intro.      
      discriminate e.
      
      apply homographicacc0.
      reflexivity.
      generalize (sg_pos_1 a b c d p H_hsign na nb nc nd One H).
      intro.
      case H0. 
      intros.
      apply False_ind.
      elim a0.
      intros.      
      generalize (Zsgn_14 _ z).
      intro.
      apply Z.lt_irrefl with 0%Z.
      apply Z.lt_le_trans with (na + nb)%Z.
      assumption.
      assumption.
      intro.
      elim a0.
      intros.
      rewrite <- Zopp_plus_distr.
      apply Zlt_neg_opp.
      assumption.
      generalize (sg_pos_1 a b c d p H_hsign na nb nc nd One H).
      intro.
      case H0. 
      intros.
      apply False_ind.
      elim a0.
      intros.      
      generalize (Zsgn_14 _ z).
      intro.
      apply Z.lt_irrefl with 0%Z.
      apply Z.lt_le_trans with (na + nb)%Z.
      assumption.
      assumption.
      intro.
      elim a0.
      intros.
      rewrite <- Zopp_plus_distr.
      apply Zlt_neg_opp.
      assumption.
Defined.

Lemma Qhomographic_Qpositive_to_Q_homographicAcc_neg_1 :
 forall (a b c d : Z) (p : Qpositive)
   (H_hsign : Qhomographic_sg_denom_nonzero c d p),
 (a * d)%Z <> (b * c)%Z ->
 h_sign a b c d p H_hsign = (-1)%Z ->
 (Z.sgn (new_a a b c d p H_hsign + new_b a b c d p H_hsign) < 0)%Z ->
 homographicAcc (- new_a a b c d p H_hsign) (- new_b a b c d p H_hsign)
   (new_c a b c d p H_hsign) (new_d a b c d p H_hsign)
   (new_p a b c d p H_hsign).
Proof.
 intros a b c d p H_hsign ad_neq_bc l1_eq__minus_one z.
 set (na := new_a a b c d p H_hsign) in *.
 set (nb := new_b a b c d p H_hsign) in *.
 set (nc := new_c a b c d p H_hsign) in *.
 set (nd := new_d a b c d p H_hsign) in *.
 set (l3 := new_p a b c d p H_hsign) in *.
 assert
  (H :
   Qhomographic_sign a b c d p H_hsign = ((-1)%Z, (na, (nb, (nc, nd)), l3))).
 unfold na, nb, nc, nd, l3 in |- *.
 rewrite <- l1_eq__minus_one.
 unfold new_a, new_b, new_c, new_d, new_p in |- *.
 replace (h_sign a b c d p H_hsign) with
  (fst (Qhomographic_sign a b c d p H_hsign)); [ idtac | reflexivity ];
  repeat rewrite <- pair_1; reflexivity.
      destruct l3 as [p0| p0| ].
      
      apply homographicAcc_wf.
      rewrite <- Zopp_plus_distr.
      apply Zlt_neg_opp.
      apply Zsgn_11.
      assumption.
     
      generalize (sg_neg_1 a b c d p H_hsign na nb nc nd (nR p0) H).        
      intros.
      case H0.             
      intro.
      elim a0.
      intros.     
      apply False_ind.      
      generalize (Zsgn_11 (na + nb) z).
      intro.
      apply Z.lt_irrefl with 0%Z.
      apply Z.lt_trans with (na + nb)%Z.
      assumption.
      assumption.
      intros.
      elim a0.    
      intros.  
      assumption.
      generalize (sg_neg_2 a b c d p H_hsign na nb nc nd (nR p0) H). 
      intro.
      case H0.         
      intro.
      case s.
      intro.
      apply False_ind.
      elim a0.
      intros.
      elim H2.
      intros.
      apply Z.lt_irrefl with 0%Z.
      apply Z.le_lt_trans with (na + nb)%Z.
      rewrite Zplus_0_r_reverse with 0%Z.
      apply Zplus_le_compat.
      assumption.      
      assumption.
      apply Zsgn_11.
      assumption.
      intro.
      elim a0.
      intros.
      apply Zle_neg_opp.
      assumption.
      intro.      
      discriminate e.
      generalize (sg_neg_2 a b c d p H_hsign na nb nc nd (nR p0) H). 
      intro.
      case H0.         
      intro.
      case s.
      intro.
      elim a0. 
      intros.
      elim H2.
      intros.
      apply False_ind.
      apply Z.lt_irrefl with 0%Z.
      apply Z.le_lt_trans with (na + nb)%Z.
      rewrite Zplus_0_r_reverse with 0%Z.
      apply Zplus_le_compat.
      assumption.      
      assumption.
      apply Zsgn_11.
      assumption.
      intros.
      elim a0.
      intros.
      elim H2.
      intros.
      apply Zle_neg_opp.
      assumption.
      intro.
      discriminate e.
      generalize (sg_neg_2 a b c d p H_hsign na nb nc nd (nR p0) H). 
      intro.
      case H0.         
      intro.
      case s.
      intro.
      elim a0. 
      intros.
      elim H2.
      intros.
      apply False_ind.
      apply Z.lt_irrefl with 0%Z.
      apply Z.le_lt_trans with (na + nb)%Z.
      rewrite Zplus_0_r_reverse with 0%Z.
      apply Zplus_le_compat.
      assumption.      
      assumption.
      apply Zsgn_11.
      assumption.
      intros.
      elim a0.
      intros.
      elim H2.
      intros.
      elim H4.
      intros.
      assumption.
      intro.      
      discriminate e.
      generalize (sg_neg_2 a b c d p H_hsign na nb nc nd (nR p0) H). 
      intro.
      case H0.         
      intro.
      case s.
      intro.
      elim a0. 
      intros.
      elim H2.
      intros.
      apply False_ind.
      apply Z.lt_irrefl with 0%Z.
      apply Z.le_lt_trans with (na + nb)%Z.
      rewrite Zplus_0_r_reverse with 0%Z.
      apply Zplus_le_compat.
      assumption.      
      assumption.
      apply Zsgn_11.
      assumption.
      intro.
      elim a0. 
      intros.
      elim H2.
      intros.
      elim H4.
      intros.
      assumption.
      intro.      
      discriminate e.
      
      apply homographicAcc_wf.
      rewrite <- Zopp_plus_distr.
      apply Zlt_neg_opp.
      apply Zsgn_11.
      assumption.
     
      generalize (sg_neg_1 a b c d p H_hsign na nb nc nd (dL p0) H).        
      intros.
      case H0.             
      intro.
      elim a0.
      intros.     
      apply False_ind.      
      generalize (Zsgn_11 (na + nb) z).
      intro.
      apply Z.lt_irrefl with 0%Z.
      apply Z.lt_trans with (na + nb)%Z.
      assumption.
      assumption.
      intros.
      elim a0.    
      intros.  
      assumption.
      generalize (sg_neg_2 a b c d p H_hsign na nb nc nd (dL p0) H). 
      intro.
      case H0.         
      intro.
      case s.
      intro.
      apply False_ind.
      elim a0.
      intros.
      elim H2.
      intros.
      apply Z.lt_irrefl with 0%Z.
      apply Z.le_lt_trans with (na + nb)%Z.
      rewrite Zplus_0_r_reverse with 0%Z.
      apply Zplus_le_compat.
      assumption.      
      assumption.
      apply Zsgn_11.
      assumption.
      intro.
      elim a0.
      intros.
      apply Zle_neg_opp.
      assumption.
      intro.      
      discriminate e.
      generalize (sg_neg_2 a b c d p H_hsign na nb nc nd (dL p0) H). 
      intro.
      case H0.         
      intro.
      case s.
      intro.
      elim a0. 
      intros.
      elim H2.
      intros.
      apply False_ind.
      apply Z.lt_irrefl with 0%Z.
      apply Z.le_lt_trans with (na + nb)%Z.
      rewrite Zplus_0_r_reverse with 0%Z.
      apply Zplus_le_compat.
      assumption.      
      assumption.
      apply Zsgn_11.
      assumption.
      intros.
      elim a0.
      intros.
      elim H2.
      intros.
      apply Zle_neg_opp.
      assumption.
      intro.
      discriminate e.
      generalize (sg_neg_2 a b c d p H_hsign na nb nc nd (dL p0) H). 
      intro.
      case H0.         
      intro.
      case s.
      intro.
      elim a0. 
      intros.
      elim H2.
      intros.
      apply False_ind.
      apply Z.lt_irrefl with 0%Z.
      apply Z.le_lt_trans with (na + nb)%Z.
      rewrite Zplus_0_r_reverse with 0%Z.
      apply Zplus_le_compat.
      assumption.      
      assumption.
      apply Zsgn_11.
      assumption.
      intros.
      elim a0.
      intros.
      elim H2.
      intros.
      elim H4.
      intros.
      assumption.
      intro.      
      discriminate e.
      generalize (sg_neg_2 a b c d p H_hsign na nb nc nd (dL p0) H). 
      intro.
      case H0.         
      intro.
      case s.
      intro.
      elim a0. 
      intros.
      elim H2.
      intros.
      apply False_ind.
      apply Z.lt_irrefl with 0%Z.
      apply Z.le_lt_trans with (na + nb)%Z.
      rewrite Zplus_0_r_reverse with 0%Z.
      apply Zplus_le_compat.
      assumption.      
      assumption.
      apply Zsgn_11.
      assumption.
      intro.
      elim a0. 
      intros.
      elim H2.
      intros.
      elim H4.
      intros.
      assumption.
      intro.      
      discriminate e.
      
      apply homographicacc0.
      reflexivity.
      rewrite <- Zopp_plus_distr.
      apply Zlt_neg_opp.
      apply Zsgn_11.
      assumption.
      generalize (sg_neg_1 a b c d p H_hsign na nb nc nd One H).        
      intros.
      case H0.             
      intro.
      elim a0.
      intros.     
      apply False_ind.      
      generalize (Zsgn_11 (na + nb) z).
      intro.
      apply Z.lt_irrefl with 0%Z.
      apply Z.lt_trans with (na + nb)%Z.
      assumption.
      assumption.
      intro.
      elim a0.
      intros.
      assumption.
Defined.

Lemma Qhomographic_Qpositive_to_Q_homographicAcc_neg_2 :
 forall (a b c d : Z) (p : Qpositive)
   (H_hsign : Qhomographic_sg_denom_nonzero c d p),
 (a * d)%Z <> (b * c)%Z ->
 h_sign a b c d p H_hsign = (-1)%Z ->
 (0 <= Z.sgn (new_a a b c d p H_hsign + new_b a b c d p H_hsign))%Z ->
 homographicAcc (new_a a b c d p H_hsign) (new_b a b c d p H_hsign)
   (- new_c a b c d p H_hsign) (- new_d a b c d p H_hsign)
   (new_p a b c d p H_hsign).
Proof.
 intros a b c d p H_hsign ad_neq_bc l1_eq__minus_one z.
 set (na := new_a a b c d p H_hsign) in *.
 set (nb := new_b a b c d p H_hsign) in *.
 set (nc := new_c a b c d p H_hsign) in *.
 set (nd := new_d a b c d p H_hsign) in *.
 set (l3 := new_p a b c d p H_hsign) in *.
 assert
  (H :
   Qhomographic_sign a b c d p H_hsign = ((-1)%Z, (na, (nb, (nc, nd)), l3))).
 unfold na, nb, nc, nd, l3 in |- *.
 rewrite <- l1_eq__minus_one.
 unfold new_a, new_b, new_c, new_d, new_p in |- *.
 replace (h_sign a b c d p H_hsign) with
  (fst (Qhomographic_sign a b c d p H_hsign)); [ idtac | reflexivity ];
  repeat rewrite <- pair_1; reflexivity.
      destruct l3 as [p0| p0| ].
      
      apply homographicAcc_wf.
      generalize (sg_neg_1 a b c d p H_hsign na nb nc nd (nR p0) H).
      intro.
      case H0. 
      intros.
      elim a0.
      intros.
      assumption.
      intros.
      apply False_ind.
      elim a0.
      intros.      
      generalize (Zsgn_13 _ z).
      intro.
      apply Z.lt_irrefl with 0%Z.
      apply Z.le_lt_trans with (na + nb)%Z.
      assumption.
      assumption.
      generalize (sg_neg_1 a b c d p H_hsign na nb nc nd (nR p0) H).
      intro.
      case H0. 
      intros.
      elim a0.
      intros.
      rewrite <- Zopp_plus_distr.      
      apply Zlt_neg_opp.
      assumption.
      intros.
      apply False_ind.
      elim a0.
      intros.      
      generalize (Zsgn_13 _ z).
      intro.
      apply Z.lt_irrefl with 0%Z.
      apply Z.le_lt_trans with (na + nb)%Z.
      assumption.
      assumption.
      generalize (sg_neg_2 a b c d p H_hsign na nb nc nd (nR p0) H). 
      intro.
      case H0.         
      intro.
      case s.
      intro.
      elim a0.
      intros.
      assumption.
      intros.
      elim a0.
      intros.
      case (Z_le_lt_eq_dec na 0 H1).
      intro.
      apply False_ind.
      elim H2.
      intros.
      apply Z.lt_irrefl with 0%Z.
      apply Z.le_lt_trans with (na + nb)%Z.
      apply (Zsgn_13 _ z).
      rewrite Zplus_0_r_reverse with 0%Z.
      apply Zplus_lt_le_compat.
      assumption.      
      assumption.
      intro.
      rewrite e.
      apply Z.le_refl.
      intro.      
      discriminate e.
      generalize (sg_neg_2 a b c d p H_hsign na nb nc nd (nR p0) H). 
      intro.
      case H0.         
      intro.
      case s.
      intro.
      elim a0.
      intros.
      elim H2.
      intros.
      assumption.
      intros.
      elim a0.
      intros.
      elim H2.
      intros.
      case (Z_le_lt_eq_dec nb 0 H3).
      intro.
      apply False_ind.
      apply Z.lt_irrefl with 0%Z.
      apply Z.le_lt_trans with (na + nb)%Z.
      apply (Zsgn_13 _ z).
      rewrite Zplus_0_r_reverse with 0%Z.
      apply Zplus_le_lt_compat.
      assumption.      
      assumption.
      intro.
      rewrite e.
      apply Z.le_refl.
      intro.      
      discriminate e.
      generalize (sg_neg_2 a b c d p H_hsign na nb nc nd (nR p0) H). 
      intro.
      case H0.         
      intro.
      case s.
      intro.
      elim a0.
      intros.
      elim H2.
      intros.
      elim H4.
      intros.
      apply Zle_neg_opp.
      assumption.
      intro.
      elim a0.
      intros.
      elim H2.
      intros.
      elim H4.
      intros.
      case (Z_le_lt_eq_dec 0 nc H5).
      intro.
      apply False_ind.
      apply Z.lt_irrefl with 0%Z.
      apply Z.lt_trans with (nc + nd)%Z.
      rewrite Zplus_0_r_reverse with 0%Z.
      apply Zplus_lt_le_compat.
      assumption.      
      assumption.
      case (sg_neg_1 a b c d p H_hsign na nb nc nd (nR p0) H).
      intro. 
      elim a1.
      intros.
      assumption.
      intro.
      apply False_ind.
      apply Z.lt_irrefl with 0%Z.
      apply Z.le_lt_trans with (na + nb)%Z.
      apply (Zsgn_13 _ z). 
      elim a1.
      intros.
      assumption.
      intro.
      rewrite <- e.
      simpl in |- *.
      apply Z.le_refl.
      intro.      
      discriminate e.
      generalize (sg_neg_2 a b c d p H_hsign na nb nc nd (nR p0) H). 
      intro.
      case H0.         
      intro.
      case s.
      intro.
      elim a0.
      intros.
      elim H2.
      intros.
      elim H4.
      intros.
      apply Zle_neg_opp.
      assumption.
      intro.
      elim a0.
      intros.
      elim H2.
      intros.
      elim H4.
      intros.
      case (Z_le_lt_eq_dec 0 nd H6).
      intro.
      apply False_ind.
      apply Z.lt_irrefl with 0%Z.
      apply Z.lt_trans with (nc + nd)%Z.
      rewrite Zplus_0_r_reverse with 0%Z.
      apply Zplus_le_lt_compat.
      assumption.      
      assumption.
      case (sg_neg_1 a b c d p H_hsign na nb nc nd (nR p0) H).
      intro. 
      elim a1.
      intros.
      assumption.
      intro.
      apply False_ind.
      apply Z.lt_irrefl with 0%Z.
      apply Z.le_lt_trans with (na + nb)%Z.
      apply (Zsgn_13 _ z). 
      elim a1.
      intros.
      assumption.
      intro.
      rewrite <- e.
      simpl in |- *.
      apply Z.le_refl.
      intro.      
      discriminate e.
      
      apply homographicAcc_wf.
      generalize (sg_neg_1 a b c d p H_hsign na nb nc nd (dL p0) H).
      intro.
      case H0. 
      intros.
      elim a0.
      intros.
      assumption.
      intros.
      apply False_ind.
      elim a0.
      intros.      
      generalize (Zsgn_13 _ z).
      intro.
      apply Z.lt_irrefl with 0%Z.
      apply Z.le_lt_trans with (na + nb)%Z.
      assumption.
      assumption.
      generalize (sg_neg_1 a b c d p H_hsign na nb nc nd (dL p0) H).
      intro.
      case H0. 
      intros.
      elim a0.
      intros.
      rewrite <- Zopp_plus_distr.      
      apply Zlt_neg_opp.
      assumption.
      intros.
      apply False_ind.
      elim a0.
      intros.      
      generalize (Zsgn_13 _ z).
      intro.
      apply Z.lt_irrefl with 0%Z.
      apply Z.le_lt_trans with (na + nb)%Z.
      assumption.
      assumption.
      generalize (sg_neg_2 a b c d p H_hsign na nb nc nd (dL p0) H). 
      intro.
      case H0.         
      intro.
      case s.
      intro.
      elim a0.
      intros.
      assumption.
      intros.
      elim a0.
      intros.
      case (Z_le_lt_eq_dec na 0 H1).
      intro.
      apply False_ind.
      elim H2.
      intros.
      apply Z.lt_irrefl with 0%Z.
      apply Z.le_lt_trans with (na + nb)%Z.
      apply (Zsgn_13 _ z).
      rewrite Zplus_0_r_reverse with 0%Z.
      apply Zplus_lt_le_compat.
      assumption.      
      assumption.
      intro.
      rewrite e.
      apply Z.le_refl.
      intro.      
      discriminate e.
      generalize (sg_neg_2 a b c d p H_hsign na nb nc nd (dL p0) H). 
      intro.
      case H0.         
      intro.
      case s.
      intro.
      elim a0.
      intros.
      elim H2.
      intros.
      assumption.
      intros.
      elim a0.
      intros.
      elim H2.
      intros.
      case (Z_le_lt_eq_dec nb 0 H3).
      intro.
      apply False_ind.
      apply Z.lt_irrefl with 0%Z.
      apply Z.le_lt_trans with (na + nb)%Z.
      apply (Zsgn_13 _ z).
      rewrite Zplus_0_r_reverse with 0%Z.
      apply Zplus_le_lt_compat.
      assumption.      
      assumption.
      intro.
      rewrite e.
      apply Z.le_refl.
      intro.      
      discriminate e.
      generalize (sg_neg_2 a b c d p H_hsign na nb nc nd (dL p0) H). 
      intro.
      case H0.         
      intro.
      case s.
      intro.
      elim a0.
      intros.
      elim H2.
      intros.
      elim H4.
      intros.
      apply Zle_neg_opp.
      assumption.
      intro.
      elim a0.
      intros.
      elim H2.
      intros.
      elim H4.
      intros.
      case (Z_le_lt_eq_dec 0 nc H5).
      intro.
      apply False_ind.
      apply Z.lt_irrefl with 0%Z.
      apply Z.lt_trans with (nc + nd)%Z.
      rewrite Zplus_0_r_reverse with 0%Z.
      apply Zplus_lt_le_compat.
      assumption.      
      assumption.
      case (sg_neg_1 a b c d p H_hsign na nb nc nd (dL p0) H).
      intro. 
      elim a1.
      intros.
      assumption.
      intro.
      apply False_ind.
      apply Z.lt_irrefl with 0%Z.
      apply Z.le_lt_trans with (na + nb)%Z.
      apply (Zsgn_13 _ z). 
      elim a1.
      intros.
      assumption.
      intro.
      rewrite <- e.
      simpl in |- *.
      apply Z.le_refl.
      intro.      
      discriminate e.
      generalize (sg_neg_2 a b c d p H_hsign na nb nc nd (dL p0) H). 
      intro.
      case H0.         
      intro.
      case s.
      intro.
      elim a0.
      intros.
      elim H2.
      intros.
      elim H4.
      intros.
      apply Zle_neg_opp.
      assumption.
      intro.
      elim a0.
      intros.
      elim H2.
      intros.
      elim H4.
      intros.
      case (Z_le_lt_eq_dec 0 nd H6).
      intro.
      apply False_ind.
      apply Z.lt_irrefl with 0%Z.
      apply Z.lt_trans with (nc + nd)%Z.
      rewrite Zplus_0_r_reverse with 0%Z.
      apply Zplus_le_lt_compat.
      assumption.      
      assumption.
      case (sg_neg_1 a b c d p H_hsign na nb nc nd (dL p0) H).
      intro. 
      elim a1.
      intros.
      assumption.
      intro.
      apply False_ind.
      apply Z.lt_irrefl with 0%Z.
      apply Z.le_lt_trans with (na + nb)%Z.
      apply (Zsgn_13 _ z). 
      elim a1.
      intros.
      assumption.
      intro.
      rewrite <- e.
      simpl in |- *.
      apply Z.le_refl.
      intro.      
      discriminate e.
      
      apply homographicacc0.
      reflexivity.
      generalize (sg_neg_1 a b c d p H_hsign na nb nc nd One H).
      intro.
      case H0. 
      intros.
      elim a0.
      intros.
      assumption.
      intro.
      apply False_ind.
      elim a0.
      intros.      
      generalize (Zsgn_13 _ z).
      intro.
      apply Z.lt_irrefl with 0%Z.
      apply Z.le_lt_trans with (na + nb)%Z.
      assumption.
      assumption.
      rewrite <- Zopp_plus_distr.
      apply Zlt_neg_opp.
      generalize (sg_neg_1 a b c d p H_hsign na nb nc nd One H).
      intro.
      case H0. 
      intros.
      elim a0.
      intros.
      assumption.
      intro.
      apply False_ind.
      elim a0.
      intros.      
      generalize (Zsgn_13 _ z).
      intro.
      apply Z.lt_irrefl with 0%Z.
      apply Z.le_lt_trans with (na + nb)%Z.
      assumption.
      assumption.
Defined.
