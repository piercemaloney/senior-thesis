
Require Import Eqdep_dec.
Require Export Field.
Require Export Q_order.
(* Q_order:
Require Export Q_field.
 
Theorem Qmult_sym : forall n m : Q, Qmult n m = Qmult m n.
 
Theorem Qmult_assoc :
 forall n m p : Q, Qmult n (Qmult m p) = Qmult (Qmult n m) p.
 
Theorem Qplus_zero_left : forall n : Q, Qplus Zero n = n.
 
Theorem Qmult_one_left : forall n : Q, Qmult (Qpos One) n = n.
 
Theorem Q_opp_def : forall n : Q, Qplus n (Qopp n) = Zero.
 
Definition Q_eq (n m : Q) :=
  match n, m with
  | Zero, Zero => true
  | Qpos n', Qpos m' =>
      match Qpositive_eq_dec n' m' with
      | left h => true
      | right h => false
      end
  | Qneg n', Qneg m' =>
      match Qpositive_eq_dec n' m' with
      | left h => true
      | right h => false
      end
  | _, _ => false
  end.
 
Theorem Q_eq_prop : forall x y : Q, Q_eq x y = true -> x = y.
 
Theorem not_one_zero : Qpos One <> Zero.
 
Definition Qinv (x : Q) :=
  match x with
  | Qpos x => Qpos (Qpositive_inv x)
  | Qneg x => Qneg (Qpositive_inv x)
  | Zero => Zero
  end.
 
Theorem Qinv_def : forall x : Q, x <> Zero -> Qmult x (Qinv x) = Qpos One.
 
Theorem Q_integral : forall x y : Q, Qmult x y = Zero -> x = Zero \/ y = Zero.
 
Inductive Qgt : Q -> Q -> Prop :=
  | Qgt_pos_pos :
      forall x' y' : Qpositive,
      ~ Qpositive_le x' y' -> Qgt (Qpos x') (Qpos y')
  | Qgt_neg_neg :
      forall x' y' : Qpositive,
      ~ Qpositive_le y' x' -> Qgt (Qneg x') (Qneg y')
  | Qgt_pos_zero : forall x' : Qpositive, Qgt (Qpos x') Zero
  | Qgt_pos_neg : forall x' y' : Qpositive, Qgt (Qpos x') (Qneg y')
  | Qgt_zero_neg : forall x' : Qpositive, Qgt Zero (Qneg x').
Hint Resolve Qgt_pos_pos Qgt_neg_neg Qgt_pos_zero Qgt_pos_neg Qgt_zero_neg.
 
Theorem Qgt_total : forall x y : Q, Qgt x y \/ x = y \/ Qgt y x.
 
Definition Q_eq_dec : forall x y : Q, {x = y} + {x <> y}.
 
Theorem Qgt_antisym : forall x y : Q, Qgt x y -> ~ Qgt y x.
 
Theorem Qgt_trans : forall x y z : Q, Qgt x y -> Qgt y z -> Qgt x z.
 
Theorem Qpositive_le_plus_simpl :
 forall x y z : Qpositive,
 Qpositive_le (Qpositive_plus x z) (Qpositive_plus y z) -> Qpositive_le x y.
 
Theorem Qpositive_le_sub_simpl_r :
 forall x y z : Qpositive,
 Qpositive_le z x ->
 Qpositive_le z y ->
 z <> x ->
 z <> y ->
 Qpositive_le (Qpositive_sub x z) (Qpositive_sub y z) -> Qpositive_le x y.
 
Theorem Qpositive_le_sub_simpl_l :
 forall x y z : Qpositive,
 Qpositive_le x z ->
 Qpositive_le y z ->
 z <> x ->
 z <> y ->
 Qpositive_le (Qpositive_sub z x) (Qpositive_sub z y) -> Qpositive_le y x.
 
Theorem Qgt_plus : forall x y z : Q, Qgt x y -> Qgt (Qplus z x) (Qplus z y).
 
Theorem Qgt_mult :
 forall x y z : Q, Qgt z Zero -> Qgt x y -> Qgt (Qmult z x) (Qmult z y).
 
Theorem Qpositive_mult_simpl :
 forall w w' w'' : Qpositive,
 Qpositive_mult w w'' = Qpositive_mult w' w'' -> w = w'.
 
Theorem Q_distr_left_aux :
 forall (x y : Q) (z' : Qpositive),
 Qmult (Qplus x y) (Qpos z') = Qplus (Qmult x (Qpos z')) (Qmult y (Qpos z')).
 
Theorem Qmult_zero : forall x : Q, Qmult Zero x = Zero.
 
Theorem Qmult_neg :
 forall (x : Q) (y' : Qpositive),
 Qopp (Qmult x (Qneg y')) = Qmult x (Qpos y').
 
Theorem Qopp_plus :
 forall x y : Q, Qopp (Qplus x y) = Qplus (Qopp x) (Qopp y).
 
Theorem Q_distr_left :
 forall x y z : Q, Qmult (Qplus x y) z = Qplus (Qmult x z) (Qmult y z).

Definition Qminus (q1 q2 : Q) : Q := Qplus q1 (Qopp q2).
Definition Qdiv (q1 q2 : Q) : Q := Qmult q1 (Qinv q2). *)

Lemma Q_Ring_Theory :
    ring_theory Zero Qone Qplus Qmult Qminus Qopp (eq(A:=Q)).
  split; intros n m p || intros n m || intros n; solve
   [ first
      [ apply Qplus_sym
      | apply Qplus_assoc
      | apply Qmult_sym
      | apply Qmult_assoc
      | apply Qplus_zero_left
      | apply Qmult_one_left
      | apply Q_opp_def
      | apply Q_distr_left
      | reflexivity ]].
Defined.

Lemma Qinv_defT : forall n : Q, n <> Zero -> Qmult (Qinv n) n = Qone.
Proof.
 intros n Hn; rewrite Qmult_sym; apply Qinv_def; intro;
  apply Hn; assumption.
Defined.

Lemma QField :
  field_theory Zero Qone Qplus Qmult Qminus Qopp Qdiv Qinv (eq(A:=Q)).
constructor.
 apply Q_Ring_Theory.
 discriminate.
 reflexivity.
 exact Qinv_defT.
Defined.

Ltac isQcst t :=
  match t with
    Zero => true
  | Qpos ?p => isQcst p
  | Qneg ?p => isQcst p
  | nR ?p => isQcst p
  | dL ?p => isQcst p
  | One => true
  | Qone => true
  | _ => false
  end.
Ltac Qcst t :=
  match isQcst t with
  | true => t
  | _ => InitialRing.NotConstant
  end.
 
Add Field Qfield : QField (decidable Q_eq_prop, constants [Qcst]).

Definition not_eq2eqT (A : Set) (x y : A) (H1 : x <> y) : 
  x <> y := fun H2 : x = y => H1 (H2).

Ltac Field := field.
