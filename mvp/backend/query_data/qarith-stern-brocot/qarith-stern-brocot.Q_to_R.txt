

Require Import Q_ordered_field_properties.
(* Q_ordered_field_properties:
Require Export Qsyntax.
Require Export Field_Theory_Q.

Lemma Qmult_absorb_nonzero_r: forall x y : Q, x * y <> Zero -> y <> Zero.

Lemma Qmult_absorb_nonzero_l: forall x y : Q, x * y <> Zero -> x <> Zero.

Lemma Qle_Qminus_Zero: forall x y: Q, x <= y -> Zero <= y-x.

Lemma Qle_Qminus_Zero_neg: forall x y : Q, x <= y -> x-y <= Zero.

Lemma Qle_Zero_Qminus_neg: forall x y : Q, x-y <= Zero -> x <= y.

Lemma Qle_Zero_Qminus: forall x y: Q,  Zero <= y-x -> x <= y.

Lemma Qmult_mult_nonneg: forall x:Q, Zero <= x*x.

Lemma Qmult_mult_pos: forall x:Q, x<> Zero -> Zero < x*x.

Lemma Qlt_opp:forall x y, Qopp x < Qopp y -> y < x.

Lemma Qlt_plus:forall x y z : Q, x < y -> z + x < z + y.

Lemma Qlt_Qminus_Zero: forall x y : Q, x < y -> Zero < y - x.

Lemma Qlt_Qminus_Zero_neg: forall x y : Q, x < y -> x-y < Zero.

Lemma Qlt_Zero_Qminus_neg: forall x y : Q, x-y < Zero -> x < y.

Lemma Qlt_reg_mult_pos_l: forall x y z : Q, Zero < x -> y < z -> x * y < x * z.

Lemma Qlt_reg_mult_pos_r: forall x y z : Q, Zero < x -> y < z -> y * x < z * x.

Lemma Qlt_reg_mult_neg_l: forall x y z : Q, x < Zero -> y < z -> x * z < x * y.

Lemma Qlt_reg_mult_neg_r: forall x y z : Q, x < Zero -> y < z -> z * x < y * x.

Lemma Qdiv_Qmult_pos:forall x y z t: Q, Zero < z*t -> x/z < y/t -> x*t < y*z. 

Lemma Qinv_involutive:forall x:Q, x<>Zero -> Qinv (Qinv x) = x.

Lemma Qmult_Qdiv_pos:forall x y z t: Q, Zero < z*t -> x*t < y*z -> x/z < y/t.

Lemma Qlt_Qopp_pos: forall x: Q, x < Zero -> Zero < - x.

Lemma Qlt_Qopp_neg: forall x: Q, Zero < x -> -x < Zero.

Lemma Qmult_one_left:forall x : Q, Qone * x = x.

Lemma Qdiv_Qone_Qone: Qdiv Qone Qone = Qone.

Lemma Qinv_Qdiv_Qone:forall x, Qinv x = Qone/x. 

Lemma Qminus_Qdiv:forall x y z t, z<>Zero -> t<>Zero -> x/z - y/t = (x*t-y*z)/(z*t).

Lemma Qplus_Qdiv:forall x y z t, z<>Zero -> t<>Zero -> x/z + y/t = (x*t+y*z)/(z*t).

Definition Qmult_Qinv_l:= Qinv_defT. 

Lemma Qmult_Qinv_r:forall x, x <> Zero -> x * (Qinv x) = Qone.

Lemma Qinv_Qmult:forall x y, x<>Zero -> y <> Zero -> Qinv (x*y) = (Qinv x)*(Qinv y).

Lemma Qplus_Qdiv_one:forall p q, q<> Zero -> (p+q) / q = p/q + Qone.

Lemma Qdiv_Qopp_numerator: forall x y : Q, y<> Zero -> Qdiv (-x) y = - (Qdiv x  y).

Lemma Qdiv_Qopp_denomintor: forall x y : Q, y<> Zero -> Qdiv x (-y) = - (Qdiv x  y).

Lemma Qdiv_Qdiv_simplify:forall x y z, z<> Zero -> y<> Zero -> (x/z)/(y/z) = x/y.

Lemma Qdiv_Qmult_Qone_denominator:forall x y z, z<>Zero -> y<>Zero -> x/(y*z) = (x/y)*(Qone/z).

Lemma Qdiv_Qmult_numerator_l: forall (x y z:Q), y<>Zero -> z*(x/y)=(z*x)/y.

Lemma Qdiv_Qmult_numerator_r: forall (x y z:Q), y<>Zero -> (x/y)*z=(x*z)/y.

Lemma Qlt_Qmult_cancel_l: forall x y z : Q, Zero < x -> x * y < x * z -> y < z.

Lemma Qlt_Qmult_cancel_r: forall x y z : Q, Zero < x -> y * x< z * x -> y < z.

Definition Qmult_resp_Qlt_pos_r:= Qlt_Qmult_cancel_r :  forall t x y : Q, Zero < t -> x * t < y * t -> x < y.

Definition Qmult_resp_Qlt_pos_l:= Qlt_Qmult_cancel_l: forall t x y : Q, Zero < t -> t * x < t * y -> x < y.

Lemma Qmult_resp_Qlt_neg_r: forall t x y : Q, t < Zero -> x * t < y * t -> y < x.

Lemma Qmult_resp_Qlt_neg_l: forall t x y : Q, t < Zero -> t * x < t * y -> y < x.

Lemma Qeq_Qminus : forall x y, x=y -> x-y=Zero.

Lemma Qminus_Qeq : forall x y, x-y=Zero -> x=y.

Lemma Qlt_not_eq': forall x y : Q, x < y -> x <> y.

Lemma Qinv_neg: forall q : Q, q<Zero -> Qinv q< Zero.

Lemma Qle_Qopp_pos:forall q : Q, q<= Zero -> Zero<= Qopp q.

Lemma Qopp_Qone_Qlt_Qone: Qopp Qone < Qone.

Hint Resolve Qinv_pos Qinv_resp_nonzero Qminus_Qeq Qeq_Qminus
             Qlt_not_eq' Qinv_neg Qle_Qopp_pos Qlt_Qopp_pos 
             Qlt_Qopp_neg Qopp_Qone_Qlt_Qone.

Lemma Qle_mult_nonneg_pos: forall x y : Q, Zero <= x -> Zero < y -> Zero <= x * y.

Lemma Qle_mult_pos_nonneg: forall x y : Q, Zero<x -> Zero <= y -> Zero <= x * y.

Lemma Qle_mult_nonpos_neg: forall x y : Q, x<=Zero -> y<Zero -> Zero <= x * y.

Lemma Qle_mult_neg_nonpos: forall x y : Q, x<Zero -> y<=Zero -> Zero <= x * y.

Lemma Qle_Qdiv_nonpos_pos: forall x y : Q, x <= Zero -> Zero < y -> x / y <= Zero.

Lemma Qle_Qdiv_nonneg_neg: forall x y : Q, Zero <= x -> y < Zero -> x / y <= Zero.

Lemma Qle_Qdiv_nonneg_pos: forall x y : Q, Zero<=x -> Zero < y -> Zero<=x / y.

Lemma Qle_Qdiv_nonpos_neg: forall x y : Q, x<=Zero -> y<Zero -> Zero<=x / y.

Lemma Qlt_mult_neg_neg: forall x y : Q, x<Zero-> y<Zero -> Zero < x * y.

Lemma Qmult_reg_l: forall x y z: Q, z <> Zero -> z*x = z*y -> x=y.

Lemma Qmult_reg_r: forall x y z: Q, z <> Zero -> x*z = y*z -> x=y.

Lemma Qmult_Qdiv: forall x y z t : Q,  z <> Zero  -> t <> Zero -> x * t = y * z -> x / z = y / t.

Lemma Qdiv_Qmult: forall x y z t : Q,  z <> Zero  -> t <> Zero -> x / z = y / t -> x * t = y * z.

Lemma Qdiv_Qdiv_Qmult_numerator: forall x y z, y<>Zero -> z<>Zero ->(x/y)/z = x/(y*z).

Lemma Qdiv_Qdiv_Qmult_denominator: forall x y z, y<>Zero -> z<>Zero -> x/(y/z) = (x*z)/y.

Lemma Qdiv_Qplus_Qmult: forall x y z, y<>Zero -> x/y + z = (x+y*z)/y.

Lemma Qdiv_Qminus_Qmult: forall x y z, y<>Zero -> x/y - z = (x-y*z)/y.

Lemma Qminus_Qdiv_Qmult: forall x y z, ~(y=Zero)->z-x/y=(y*z-x)/y.

Lemma Qplus_Qdiv_Qmult: forall x y z, ~(y=Zero)->z+x/y=(y*z+x)/y.

Lemma Qle_reg_mult_r: forall x y z : Q, Zero < x -> y <=z -> y * x <=z * x.

Lemma Qle_reg_mult_l: forall x y z : Q, Zero < x -> y <= z -> x * y <= x * z.

Lemma Qmult_resp_Qle_pos_r: forall t x y : Q, Zero < t -> x * t <= y * t -> x <= y.

Lemma Qmult_resp_Qle_pos_l: forall t x y : Q, Zero < t -> t * x <= t * y -> x <= y.

Lemma Qmult_resp_Qle_neg_r: forall t x y : Q, t < Zero -> x * t <= y * t -> y <= x.

Lemma Qmult_resp_Qle_neg_l: forall t x y : Q, t < Zero -> t * x <= t * y -> y <= x.

Lemma Qmult_Qdiv_pos_Qle: forall x y z t : Q, Zero < z -> Zero < t -> x * t <= y * z -> x / z <= y / t.

Lemma Qmult_Qle_compat: forall n m p q : Q, n <= p -> m <= q -> Zero <= n -> Zero <= m -> n * m <= p * q.

Lemma Qdiv_num_denom_explicit: forall q1 q2 p : Q, q2 <> Zero -> p <> Zero -> q1 / q2 = (q1 * p)/ (q2 * p).

Lemma Qle_opp: forall x y : Q, - x <= - y -> y <= x.

Lemma Qmult_pos_Qle_Qdiv: forall x y z : Q, Zero<z -> x * z<=y -> x <= y / z.

Lemma Qmult_neg_Qle_Qdiv: forall x y z : Q, z <Zero -> y <= x * z -> x <= y / z.

Lemma Qmult_pos_Qdiv_Qle: forall x y z : Q, Zero<z -> y<=x*z -> y/z <= x.

Lemma Qmult_neg_Qdiv_Qle: forall x y z : Q, z <Zero -> x*z<=y -> y/z<=x.

Lemma Qmult_pos_Qlt_Qdiv: forall x y z : Q, Zero<z -> x * z<y -> x < y/z.

Lemma Qmult_neg_Qlt_Qdiv: forall x y z : Q, z <Zero -> y < x * z -> x < y / z.

Lemma Qmult_pos_Qdiv_Qlt: forall x y z : Q, Zero<z -> y<x*z -> y/z < x.

Lemma Qmult_neg_Qdiv_Qlt: forall x y z : Q, z <Zero -> x*z<y -> y/z<x.

Lemma Qmult_Qdiv_pos_neg_Qle:forall x y z t : Q,  Zero < z -> t<Zero -> y * z <= x * t -> x / z <= y / t.

Lemma Qmult_Qdiv_neg_pos_Qle:forall x y z t : Q,  z<Zero -> Zero<t -> y * z <= x * t -> x / z <= y / t.

Lemma Qmult_Qdiv_neg_Qle:forall x y z t : Q,  z<Zero -> t<Zero -> x * t<=y * z -> x / z <= y / t.

Lemma Qopp_involutive: forall q, Qopp (Qopp q) = q.

Lemma Qopp_Qle: forall x y, y <= x -> - x <= - y.

Lemma Qopp_Qlt: forall x y, y < x -> - x < - y.

Lemma Qle_reg_mult_r_strong: forall x y z : Q, Zero <= x -> y <= z -> y * x <= z * x.

Lemma Qle_reg_mult_l_strong: forall x y z : Q, Zero <= x -> y <= z -> x * y <= x * z.

Lemma Qlt_Qdiv_denom_neg_neg: forall x y:Q, y<Zero -> x / y < Zero ->  Zero < x.

Lemma Qlt_Qdiv_denom_neg_pos: forall x y:Q, y<Zero ->  Zero< x / y  -> x<Zero.

Lemma Qlt_Qdiv_denom_pos_neg: forall x y:Q, Zero<y -> x / y < Zero ->  x<Zero.

Lemma Qlt_Qdiv_denom_pos_pos: forall x y:Q, Zero<y ->  Zero< x / y  -> Zero<x.

Lemma Qle_Qdiv_denom_neg_nonpos: forall x y:Q, y<Zero -> x / y <= Zero ->  Zero <= x.

Lemma Qle_Qdiv_denom_neg_nonneg: forall x y:Q, y<Zero ->  Zero<= x / y  -> x<=Zero.

Lemma Qle_Qdiv_denom_pos_nonpos: forall x y:Q, Zero<y -> x / y <= Zero ->  x<=Zero.

Lemma Qle_Qdiv_denom_pos_nonneg: forall x y:Q, Zero<y ->  Zero<= x / y  -> Zero<=x.

Lemma Qlt_neg_Qopp: forall x : Q, - x < Zero->Zero < x.

Lemma Qlt_pos_Qopp: forall x : Q, Zero < - x->x<Zero.

Lemma Qmult_mult_Qle_Qone_Qopp_Qone: forall q, -Qone<=q -> q<= Qone -> q*q <= Qone. 

Lemma Qinv_resp_nonzero_Qdiv:forall q, q <> Zero -> (Qone/q)<>Zero. 

Lemma Qmult_Qlt_Qle_nonneg_pos_compat: forall n m p q, n < p -> m <= q -> Zero <= n -> Zero < q -> n * m < p * q.

Lemma Qmult_Qlt_Qle_pos_nonneg_compat: forall n m p q, n <= p -> m < q -> Zero < p -> Zero <= m -> n * m < p * q.

Ltac qZ_numerals_one  :=replace (Z_to_Q 1) with Qone;  trivial. 

Ltac qZ_numerals  := 
 match goal with 
 | [ |- context [(Z_to_Q (Z_of_nat ?X1))] ] => unfold Z_of_nat; qZ_numerals
 | [ |- context [(Z_to_Q Z0)] ] => replace (Z_to_Q Z0) with Zero; trivial; qZ_numerals
 | [ |- context [(Z_to_Q (Zpos ?X1))] ] => progress  let v:= eval compute in (Z.pred (Zpos X1)) in 
         replace (Z_to_Q (Zpos X1)) with (Qplus Qone (Z_to_Q v)); trivial; qZ_numerals
 | [ |- context [(Z_to_Q (Zneg ?X1))] ] => let v:= eval compute in (Z.succ (Zneg X1)) in 
        replace (Z_to_Q (Zneg X1)) with (Qminus (Z_to_Q v) Qone); trivial; qZ_numerals
 | [ |- context [(Qplus Zero ?X1)] ] => rewrite Qplus_zero_left; qZ_numerals
 | [ |- context [(Qplus ?X1 Zero)] ] => rewrite Qplus_zero_right; qZ_numerals
 | [ |- context [(Qminus Zero ?X1)] ] => unfold Qminus; rewrite Qplus_zero_left; qZ_numerals
 | [ |- context [(Qminus ?X1 Zero)] ] => unfold Qminus; rewrite Qplus_zero_right; qZ_numerals
 | [ |- context [(Qmult Qone ?X1)] ] => rewrite Qmult_one_left; qZ_numerals
 | [ |- context [(Qmult ?X1 Qone)] ] => rewrite Qmult_one_right; qZ_numerals
 | [ |- _ ] => idtac
 end.

Ltac ring_exact_Q hyp := 
 match type of hyp with 
 | Qlt ?X1 ?X2 => stepl X1;[|qZ_numerals;ring];stepr X2;[|qZ_numerals;ring]; trivial
 | Qle ?X1 ?X2 => stepl X1;[|qZ_numerals;ring];stepr X2;[|qZ_numerals;ring]; trivial
 | ~(@eq Q ?X1 ?X2) => stepl X1;[|qZ_numerals;ring];stepr X2;[|qZ_numerals;ring]; trivial
 | ?X3 => fail 1
 end. *)

Require Import R_addenda.
(* R_addenda:
Require Import Reals.
Require Import Lra.
Require Import Fourier.
Require Import Euclid. 
Require Import Omega.

Lemma Rlt_stepl:forall x y z, Rlt x y -> x=z -> Rlt z y.

Lemma Rlt_stepr:forall x y z, Rlt x y -> y=z -> Rlt x z.

Declare Left Step Rlt_stepl.
Declare Right Step Rlt_stepr.

Lemma Rle_stepl:forall x y z, Rle x y -> x=z -> Rle z y.

Lemma Rle_stepr:forall x y z, Rle x y -> y=z -> Rle x z.

Declare Left Step Rle_stepl.
Declare Right Step Rle_stepr.

Lemma Rneq_stepl:forall x y z:R, x<>y -> x=z -> z<>y.

Lemma Rneq_stepr:forall x y z:R, x<>y -> y=z -> x<>z.

Declare Left Step Rneq_stepl.
Declare Right Step Rneq_stepr.

Lemma Rlt_zero_Rminus : forall r1 r2:R , 0 < r1-r2  -> r2 < r1.

Lemma Rle_zero_Rminus : forall r1 r2:R , 0 <= r1-r2  -> r2 <= r1.

Lemma Rle_Rminus_zero : forall r1 r2:R , r2 <= r1 -> 0 <= r1-r2.

Lemma Rlt_Rminus_zero : forall r1 r2:R , r2 < r1 -> 0 < r1-r2.

Lemma Rlt_not_eq': forall r1 r2 : R, r1 < r2 -> r2 <> r1.

Lemma Rmult_reg_nonzero_r: forall r1 r2 : R, r1 * r2 <> 0 -> r2 <> 0.
 
Lemma Rmult_reg_nonzero_l: forall r1 r2 : R, r1 * r2 <> 0 -> r1 <> 0.

Lemma Rlt_Ropp_pos: forall r : R, r < 0 -> 0 < - r.

Lemma Rlt_mult_neg_neg: forall r1 r2 : R, r1<0 -> r2<0 -> 0 < r1 * r2.

Definition Rinv_pos:= Rinv_0_lt_compat.
Definition Rle_mult_nonneg_nonneg:=Rmult_le_pos.
Definition Rlt_mult_pos_pos:=Rmult_lt_0_compat.
Definition Rmult_resp_nonzero:=RIneq.prod_neq_R0.
Definition Rinv_resp_nonzero:=Rinv_neq_0_compat.
Definition Ropp_resp_nonzero:=RIneq.Ropp_neq_0_compat.

Hint Resolve Rlt_Ropp_pos Rinv_pos R1_neq_R0 Rle_mult_nonneg_nonneg
             Rlt_mult_pos_pos Rlt_mult_neg_neg Rlt_not_eq' Rlt_not_eq
             Rmult_resp_nonzero Rinv_resp_nonzero Ropp_resp_nonzero.

Lemma Rmult_mult_nonneg: forall r, 0<=r*r.

Lemma Rmult_mult_Ropp_nonpos: forall r, -(r*r)<=0.

Lemma Rlt_mult_pos_neg: forall r1 r2 : R, r1 < 0 -> 0<r2 -> r1 * r2<0.

Lemma Rlt_mult_neg_pos: forall r1 r2 : R, 0<r1 -> r2<0 -> r1 * r2<0.

Lemma Rdiv_Rmult_pos_neg_Rle: forall x y z t, R0 < z -> t < R0 -> x / z <= y / t -> y * z <= x * t.

Lemma Rdiv_Rmult_pos_neg_Rle': forall x y z t, R0 < z -> t < R0 -> x / z <= y / t -> z*y <= t*x.

Lemma Rdiv_Rmult_neg_pos_Rle: forall x y z t, z<0 -> 0<t -> x / z <= y / t -> y * z <= x * t.

Lemma Rdiv_Rmult_neg_pos_Rle': forall x y z t, z<0 -> 0<t -> x / z <= y / t -> z*y <= t*x.

Lemma Rdiv_Rmult_neg_neg_Rle: forall x y z t, z<0 -> t<0 -> x / z <= y / t -> x * t<=y * z.

Lemma Rdiv_Rmult_neg_neg_Rle': forall x y z t, z<0 -> t<0 -> x / z <= y / t -> t*x<=z*y.

Lemma Rdiv_Rmult_pos_pos_Rle: forall x y z t, 0<z -> 0<t -> x / z <= y / t -> x * t<=y * z.

Lemma Rdiv_Rmult_pos_pos_Rle': forall x y z t, 0<z -> 0<t -> x / z <= y / t -> t*x<=z*y.

Lemma Rdiv_Ropp_numerator: forall x y, y <> R0 -> (- x / y = - (x / y))%R.

Lemma Rdiv_Ropp_denomintor: forall x y, y <> R0 -> (x / - y = - (x / y))%R. 

Lemma Rdiv_Rmult_numerator: forall (x y z:R), y<>R0 -> (z*(x/y)=(z*x)/y)%R.

Lemma Rdiv_Rmult_numerator_r: forall (x y z:R), y<>R0 -> ((x/y)*z=(x*z)/y)%R.

Lemma Rdiv_Rplus_Rmult: forall (x y z:R), y<>R0 -> (x/y + z = (x+y*z)/y)%R.

Lemma Rdiv_Rminus_Rmult: forall x y z, y<>R0 -> (x/y - z = (x-y*z)/y)%R.

Lemma Rminus_Rdiv_Rmult: forall x y z, ~(y=R0)->(z-x/y=(y*z-x)/y)%R.

Lemma Rplus_Rdiv_Rmult: forall x y z, ~(y=R0)->(z+x/y=(y*z+x)/y)%R.

Lemma Rminus_Rdiv:forall x y z t, z<>R0 -> t<>R0 -> (x/z - y/t = (x*t-y*z)/(z*t))%R.

Lemma Rplus_Rdiv:forall x y z t, z<>R0 -> t<>R0 -> (x/z + y/t = (x*t+y*z)/(z*t))%R.

Lemma Ropp_mult_distr: forall r1 r2 : R, - (r1 * r2) = (- r1 * r2).

Lemma Rle_pos_nonneg_Rmult: forall r1 r2 : R, 0 < r1 ->  0 <= r2 * r1 -> 0<= r2.

Lemma Rle_pos_nonneg_Rdiv: forall r1 r2 : R, 0 < r1 ->  0 <= r2 / r1 -> 0<= r2.

Lemma Rle_mult_nonpos_nonpos: forall r1 r2 : R, r1<=0 -> r2<=0 -> 0 <= r1 * r2.

Lemma Rlt_pos_pos_Rmult: forall r1 r2 : R, 0 < r1 ->  0 < r2 * r1 -> 0< r2.

Lemma Rlt_pos_pos_Rdiv: forall r1 r2 : R, 0 < r1 ->  0 < r2 / r1 -> 0< r2.

Lemma Rdiv_Rdiv_simplify: forall x y z : R, z <> R0 -> y <> R0 -> x / z / (y / z) = x / y.

Definition Rmult_reg_l := RIneq.Rmult_eq_reg_l.

Lemma Rmult_reg_r : forall r r1 r2 : R, r1 * r = r2 * r -> r <> 0 -> r1 = r2.

Lemma Rmult_Rdiv: forall x y z t : R, z <> R0 -> t <> R0 -> x * t = y * z -> x / z = y / t.

Lemma Rmult_Rdiv_pos_Rle: forall x y z t, (R0 < z)%R -> (R0 < t)%R -> (x * t <= y * z)%R -> (x / z <= y / t)%R.

Lemma Rmult_Rdiv_neg_Rle: forall x y z t, (z < R0)%R -> (t < R0)%R -> (x * t <= y * z)%R -> (x / z <= y / t)%R.

Lemma Rdiv_Rmult_simplify: forall x y z : R, z <> 0%R -> y <> 0%R -> (x * z / (y * z))%R = (x / y)%R.

Lemma Rdiv_Rmult_numerator_denominator: forall x y z t: R, t <> 0%R -> y <> 0%R -> ((x/y)*(z/t))%R=((x*z)/(y*t))%R.

Lemma Rdiv_Rdiv_Rmult_numerator: forall x y z : R, y <> 0 -> z <> 0 -> (x / y / z) = (x / (y * z)).

Lemma Rdiv_Rdiv_Rmult_denominator: forall x y z : R, y <> 0 -> z <> 0 -> (x / (y / z)) = (x*z / y ).

Lemma Rmult_Rdiv_pos_Rlt: forall x y z t, (R0 < z)%R -> (R0 < t)%R -> (x * t < y * z)%R -> (x / z < y / t)%R.

Lemma Rmult_Rdiv_neg_Rlt: forall x y z t, (z < R0)%R -> (t < R0)%R -> (x * t < y * z)%R -> (x / z < y / t)%R.

Lemma Rlinear_non_zero_1:forall a b x y, (y<>0)%R -> (a*x+b*y<>0)%R -> (a*(x/y)+b<>0)%R.

Lemma Rlinear_non_zero_2:forall a b x y, (y<>0)%R -> (a*(x/y)+b<>0)%R -> (a*x+b*y<>0)%R.
 
Lemma Rlinear_non_zero_3: forall a b x : R, a <> 0 -> x <> -b/a -> a * x + b <> 0.

Lemma Rbilinear_non_zero_2:forall a b c d x y x' y', y<>0 -> y'<>0 -> 
   (a*(x/y)*(x'/y')+b*(x/y)+c*(x'/y')+d<>0)%R -> (a*x*x'+b*x*y'+c*y*x'+d*y*y'<>0)%R.

Lemma Rle_dec_weak:forall (x y:R), {Rle x y}+{(Rle y x)}.

Lemma Rtrichotomy_inf:forall r1 r2 : R, {(r1 < r2)%R} + {r1 = r2} + {(r2<r1)%R}.

Lemma not_O_S_INR: forall n : nat, INR (S n) <> 0%R.

Lemma pos_S_INR: forall n : nat, (0 < INR (S n))%R.

Hint Resolve not_O_S_INR pos_S_INR pos_INR.

Lemma Req_Rdiv_Rone:forall x y, y<>0 -> x=y -> x/y =1.

Lemma Req_Ropp_Rdiv_minus_Rone:forall x y, y<>0 -> x=-y -> x/y =-1.

Lemma Rmax_involutive: forall q, Rmax q q = q.

Lemma Rabs_Rle: forall q p : R, (- p <= q)%R -> (q <= p)%R -> (Rabs q <= p)%R.

Lemma Rabs_Rle_1: forall q, (- 1 <= q)%R -> (q <= 1)%R -> (Rabs q <= 1)%R.

Lemma pow_Rle_r : forall (x y : R) (n : nat),  - x <= y -> y <= x -> pow y n <= pow x n.

Lemma pow_Rle_r_1 : forall (y: R) (n : nat),  - 1 <= y -> y <= 1 -> pow y n <= 1.

Lemma pow_even_nonneg:forall (y: R) (n : nat), 0 <= pow y (2*n)%nat.

Lemma pow_Rle_l_1 : forall (y: R) (n : nat),  - 1 <= y -> y <= 1 -> -1 <= pow y n.

Lemma conjL_range_l:forall r, -1 <= r -> -1<= (r-1)/(r+3).

Lemma conjL_range_r:forall r, -1<=r -> r <= 1 -> (r-1)/(r+3) <= 0.

Lemma conjL_range_weak:forall r, -1 <= r <= 1-> -1<= (r-1)/(r+3)<=1.

Lemma conjR_range_l:forall r, -1 <= r -> r <= 1 -> 0<= (r+1)/(-r+3).

Lemma conjR_range_r:forall r, r <= 1 -> (r+1)/(-r+3)<=1.

Lemma conjR_range_weak:forall r, -1 <= r <= 1-> -1<= (r+1)/(-r+3)<=1.

Lemma conjM_range_l:forall r, -1 <= r -> -1/3<= r/3.

Lemma conjM_range_r:forall r, r <= 1 -> r/3<=1/3.

Lemma conjM_range_weak:forall r, -1 <= r <= 1-> -1<= r/3 <=1.

Lemma conjLinv_range_r:forall r, r <= 0 -> (3*r+1)/(-r+1)<=1.

Lemma conjLinv_range_l:forall r, -1<=r -> r <= 0 -> -1<=(3*r+1)/(-r+1).

Lemma conjRinv_range_r:forall r, 0<=r-> r <= 1 -> (3*r-1)/(r+1)<=1.

Lemma conjRinv_range_l:forall r, 0<=r -> -1<=(3*r-1)/(r+1).

Lemma conjMinv_range_r:forall r, r <= 1/3 -> 3*r<=1.

Lemma conjMinv_range_l:forall r, -1/3<=r -> -1<=3*r.

Lemma CV_const:  forall const, Un_cv (fun i : nat => const) const.

Lemma CV_shift_S' : forall Un l,  Un_cv (fun n => Un (S n)) l -> Un_cv Un l.

Lemma CV_shift_S : forall Un l,  Un_cv Un l -> Un_cv (fun n => Un (S n)) l.

Lemma CV_extensionality : forall Un Un', (forall n, Un n = Un' n) ->  forall l, Un_cv Un l -> Un_cv Un' l.

Ltac ring_exact_R hyp := 
 match type of hyp with 
 | Rlt ?X1 ?X2 => (stepr X2; trivial; ring) || (stepl X1; trivial; ring)
 | Rle ?X1 ?X2 => (stepr X2; trivial; ring) || (stepl X1; trivial; ring)
 | ~(@eq R ?X1 ?X2) => (stepr X2; trivial; ring) || (stepl X1; trivial; ring)
 | ?X3 => fail 1
 end. *)

Require Import Raxioms.

Require Import RIneq.



Definition Q_to_R (q:Q) : R := ((IZR (numerator q))/(IZR (denominator q)))%R.



Coercion Q_to_R : Q>->R.



Lemma Q_to_Req: forall x y, @eq Q  x y -> ((Q_to_R x)=(Q_to_R y))%R.

Proof.

 exact (f_equal Q_to_R).

Qed.



Lemma Q_to_R_Zero: (Q_to_R Zero=0)%R.

Proof.

 unfold Q_to_R, numerator, denominator, decode_Q; simpl; field; apply R1_neq_R0. 

Qed.



Lemma Q_to_R_Qone: (Q_to_R Qone=1)%R.

Proof.

 unfold Q_to_R, numerator, denominator, decode_Q; simpl; field; apply R1_neq_R0. 

Qed.



Lemma Q_to_R_Qneg_One: (Q_to_R (Qneg One)=(-1))%R.

Proof.

 unfold Q_to_R, numerator, denominator, decode_Q; simpl; field; apply R1_neq_R0. 

Qed.



Lemma Q_to_Ropp: forall x, Q_to_R (Qopp x) = Ropp (Q_to_R x).

 intros [ |p|p]. 

  simpl; rewrite Q_to_R_Zero; ring.

  

  unfold Q_to_R, numerator, denominator, decode_Q, Qopp, fst, snd.

  destruct (interp_non_zero p) as [p0 [q0 H]].

  rewrite H.

  repeat rewrite Ropp_Ropp_IZR; repeat rewrite <- INR_IZR_INZ.

  field; auto.  

  

  unfold Q_to_R, numerator, denominator, decode_Q, Qopp, fst, snd.

  destruct (interp_non_zero p) as [p0 [q0 H]].

  rewrite H.

  repeat rewrite Ropp_Ropp_IZR; repeat rewrite <- INR_IZR_INZ.

  field; auto.  

Qed.



Lemma Q_to_Rplus: forall x y, Q_to_R (Qplus x y) = (Rplus (Q_to_R x) (Q_to_R y)).

Proof.

 intros [ |p|p] [ |p'|p']; try rewrite Q_to_R_Zero; try rewrite Qplus_zero_left; 

 try rewrite Qplus_zero_right; try rewrite Rplus_0_r;

 try rewrite Rplus_0_l; trivial.

  

  unfold Q_to_R, numerator, denominator, decode_Q; simpl; field; apply R1_neq_R0...

  

  unfold Q_to_R, numerator, denominator, decode_Q, Qplus, fst, snd;

  unfold Qpositive_plus.

  destruct (interp_non_zero p) as [p0 [q0 H]].

  destruct (interp_non_zero p') as [p0' [q0' H']].

  rewrite H; rewrite H'.

  replace (S p0 * S q0' + S p0' * S q0)%nat with (S (q0'+p0*(S q0')+S (q0+p0'*(S q0))))%nat; auto with arith.

  replace (S q0 * S q0')%nat with (S (q0'+q0*(S q0')))%nat; auto with arith.

  set (m:=((q0' + p0 * S q0') + S (q0 + p0' * S q0))%nat).

  set (n:=(q0' + q0 * S q0')%nat).

  destruct (construct_correct2  (S m+S n) m n  (le_n _)) as [factor [H_factor1 H_factor2]].

  generalize H_factor1 H_factor2; clear H_factor1 H_factor2.

  set (P:=(Qpositive_c  (S m) (S n) (S m + S n))).

  destruct (interp_non_zero P) as [P0 [Q0 H'']].

  rewrite H''.

  unfold fst, snd. 

  intros H_factor1  H_factor2.

  repeat rewrite <- INR_IZR_INZ.

  rewrite Rplus_Rdiv; auto.

  rewrite <- (Rdiv_Rmult_simplify (INR (S P0)) (INR (S Q0)) (INR (S factor))); auto.

  do 2 rewrite <- mult_INR.

  rewrite <- H_factor1; rewrite <- H_factor2.

  apply Rmult_Rdiv; auto.

  subst m n.

  repeat rewrite S_INR.

  repeat rewrite plus_INR.

  repeat rewrite S_INR.

  repeat rewrite mult_INR.

  repeat rewrite plus_INR.

  repeat rewrite mult_INR.

  repeat rewrite S_INR.

  ring.

  

  unfold Q_to_R at 1, numerator, denominator, decode_Q, Qplus, fst, snd.

  destruct (Qpositive_le_dec p p') as [H_le_dec|H_le_dec].

  destruct (Qpositive_eq_dec p p') as [H_eq_dec|H_eq_dec].

   

   subst p; rewrite Qopp_Qpos; rewrite Q_to_Ropp; rewrite Rplus_opp_r; simpl; field; auto.

   

   unfold Q_to_R, numerator, denominator, decode_Q, fst, snd.

   unfold Qpositive_sub.

   generalize (Qpositive_le_to_Qpositive_le' p p' H_le_dec); unfold Qpositive_le'.

   generalize (Qpositive_le_noneq_explicit p p' H_le_dec H_eq_dec).

   destruct (interp_non_zero p) as [p0 [q0 H]].

   destruct (interp_non_zero p') as [p0' [q0' H']].

   rewrite H; rewrite H'; intros H_le_dec_unfolded H_let.

   assert (H_le_unfold:   (S q0' + p0 * S q0' <= q0 + p0' * S q0)%nat); auto with arith. 

   replace (S p0' * S q0 - S p0 * S q0')%nat with (S (q0+p0'*(S q0)- (S q0'+p0*(S q0'))))%nat;

   [| rewrite (minus_Sn_m _ _ H_le_unfold); auto with arith ].

   replace (S q0' * S q0)%nat with (S (q0+q0'*(S q0)))%nat; auto with arith.

   replace (S p0' * S q0 + S p0 * S q0')%nat with (S (q0+p0'*(S q0)+S (q0'+p0*(S q0'))))%nat; auto with arith.

   set (m':=((q0 + p0' * S q0) + S (q0' + p0 * S q0'))%nat).

   set (m:=((q0 + p0' * S q0) - (S q0' + p0 * S q0'))%nat).

   set (n:=(q0 + q0' * S q0)%nat).

   assert (H_m':(S m + S n <= S m' + S n)%nat);

    [ subst m m' n; apply plus_le_compat_r; apply le_n_S; apply le_trans with (q0 + p0' * S q0)%nat; auto with arith;

      apply le_minus |].

   destruct (construct_correct2  (S m'+S n) m n H_m') as [factor [H_factor1 H_factor2]].

   generalize H_factor1 H_factor2; clear H_factor1 H_factor2.

   set (P:=(Qpositive_c  (S m) (S n) (S m' + S n))).

   destruct (interp_non_zero P) as [P0 [Q0 H'']].

   rewrite H''.

   unfold fst, snd. 

   intros H_factor1  H_factor2.

   repeat rewrite Ropp_Ropp_IZR; repeat rewrite <- INR_IZR_INZ.

   rewrite Rplus_Rdiv; auto.

   rewrite <- (Rdiv_Rmult_simplify (- INR (S P0)) (INR (S Q0)) (INR (S factor))); auto.

   rewrite Ropp_mult_distr_l_reverse; do 2 rewrite <- mult_INR.

   rewrite <- H_factor1; rewrite <- H_factor2.

   apply Rmult_Rdiv; auto.

   subst m n.

   repeat rewrite S_INR.

   rewrite minus_INR; trivial.

   repeat rewrite plus_INR.

   repeat rewrite mult_INR.

   repeat rewrite S_INR.

   ring.

   

   unfold Q_to_R, numerator, denominator, decode_Q, fst, snd.

   unfold Qpositive_sub.

   generalize (sym_not_eq (not_Qpositive_le_not_eq _ _ H_le_dec)).

   generalize (not_Qpositive_le_Qpositive_le' _ _ H_le_dec); 

   clear H_le_dec; intros H_le_dec H_eq_dec.

   generalize (Qpositive_le_to_Qpositive_le' p' p H_le_dec); unfold Qpositive_le'.

   generalize (Qpositive_le_noneq_explicit p' p H_le_dec H_eq_dec).

   destruct (interp_non_zero p) as [p0 [q0 H]].

   destruct (interp_non_zero p') as [p0' [q0' H']].

   rewrite H; rewrite H'; intros H_le_dec_unfolded H_lt.

   assert (H_le_unfold:   (S q0 + p0' * S q0 <= q0' + p0 * S q0')%nat); auto with arith. 

   replace (S p0 * S q0' - S p0' * S q0)%nat with (S (q0'+p0*(S q0')- (S q0+p0'*(S q0))))%nat;

   [| rewrite (minus_Sn_m _ _ H_le_unfold); auto with arith ].

   replace (S q0 * S q0')%nat with (S (q0'+q0*(S q0')))%nat; auto with arith.

   replace (S p0 * S q0' + S p0' * S q0)%nat with (S (q0'+p0*(S q0')+S (q0+p0'*(S q0))))%nat; auto with arith.

   set (m':=((q0' + p0 * S q0') + S (q0 + p0' * S q0))%nat).

   set (m:=((q0' + p0 * S q0') - (S q0 + p0' * S q0))%nat).

   set (n:=(q0' + q0 * S q0')%nat).

   assert (H_m':(S m + S n <= S m' + S n)%nat);

    [ subst m m' n; apply plus_le_compat_r; apply le_n_S; apply le_trans with (q0' + p0 * S q0')%nat; auto with arith;

      apply le_minus |].

   destruct (construct_correct2  (S m'+S n) m n H_m') as [factor [H_factor1 H_factor2]].

   generalize H_factor1 H_factor2; clear H_factor1 H_factor2.

   set (P:=(Qpositive_c  (S m) (S n) (S m' + S n))).

   destruct (interp_non_zero P) as [P0 [Q0 H'']].

   rewrite H''.

   unfold fst, snd. 

   intros H_factor1  H_factor2.

   repeat rewrite Ropp_Ropp_IZR; repeat rewrite <- INR_IZR_INZ.

   rewrite Rplus_Rdiv; auto.

   rewrite <- (Rdiv_Rmult_simplify (INR (S P0)) (INR (S Q0)) (INR (S factor))); auto.

   rewrite Ropp_mult_distr_l_reverse; do 2 rewrite <- mult_INR.

   rewrite <- H_factor1; rewrite <- H_factor2.

   apply Rmult_Rdiv; auto.

   subst m n.

   repeat rewrite S_INR.

   rewrite minus_INR; trivial.

   repeat rewrite plus_INR.

   repeat rewrite mult_INR.

   repeat rewrite S_INR.

   ring.

  

  unfold Q_to_R at 1, numerator, denominator, decode_Q, Qplus, fst, snd.

  destruct (Qpositive_le_dec p p') as [H_le_dec|H_le_dec].

  destruct (Qpositive_eq_dec p p') as [H_eq_dec|H_eq_dec].

   

   subst p; rewrite Qopp_Qpos; rewrite Q_to_Ropp; rewrite Rplus_opp_l; simpl; field; auto.

   

   unfold Q_to_R, numerator, denominator, decode_Q, fst, snd.

   unfold Qpositive_sub.

   generalize (Qpositive_le_to_Qpositive_le' p p' H_le_dec); unfold Qpositive_le'.

   generalize (Qpositive_le_noneq_explicit p p' H_le_dec H_eq_dec).

   destruct (interp_non_zero p) as [p0 [q0 H]].

   destruct (interp_non_zero p') as [p0' [q0' H']].

   rewrite H; rewrite H'; intros H_le_dec_unfolded H_let.

   assert (H_le_unfold:   (S q0' + p0 * S q0' <= q0 + p0' * S q0)%nat); auto with arith. 

   replace (S p0' * S q0 - S p0 * S q0')%nat with (S (q0+p0'*(S q0)- (S q0'+p0*(S q0'))))%nat;

   [| rewrite (minus_Sn_m _ _ H_le_unfold); auto with arith ].

   replace (S q0' * S q0)%nat with (S (q0+q0'*(S q0)))%nat; auto with arith.

   replace (S p0' * S q0 + S p0 * S q0')%nat with (S (q0+p0'*(S q0)+S (q0'+p0*(S q0'))))%nat; auto with arith.

   set (m':=((q0 + p0' * S q0) + S (q0' + p0 * S q0'))%nat).

   set (m:=((q0 + p0' * S q0) - (S q0' + p0 * S q0'))%nat).

   set (n:=(q0 + q0' * S q0)%nat).

   assert (H_m':(S m + S n <= S m' + S n)%nat);

    [ subst m m' n; apply plus_le_compat_r; apply le_n_S; apply le_trans with (q0 + p0' * S q0)%nat; auto with arith;

      apply le_minus |].

   destruct (construct_correct2  (S m'+S n) m n H_m') as [factor [H_factor1 H_factor2]].

   generalize H_factor1 H_factor2; clear H_factor1 H_factor2.

   set (P:=(Qpositive_c  (S m) (S n) (S m' + S n))).

   destruct (interp_non_zero P) as [P0 [Q0 H'']].

   rewrite H''.

   unfold fst, snd. 

   intros H_factor1  H_factor2.

   repeat rewrite Ropp_Ropp_IZR; repeat rewrite <- INR_IZR_INZ.

   rewrite Rplus_Rdiv; auto.

   rewrite <- (Rdiv_Rmult_simplify (INR (S P0)) (INR (S Q0)) (INR (S factor))); auto.

   rewrite Ropp_mult_distr_l_reverse; do 2 rewrite <- mult_INR.

   rewrite <- H_factor1; rewrite <- H_factor2.

   apply Rmult_Rdiv; auto.

   subst m n.

   repeat rewrite S_INR.

   rewrite minus_INR; trivial.

   repeat rewrite plus_INR.

   repeat rewrite mult_INR.

   repeat rewrite S_INR.

   ring.

   

   unfold Q_to_R, numerator, denominator, decode_Q, fst, snd.

   unfold Qpositive_sub.

   generalize (sym_not_eq (not_Qpositive_le_not_eq _ _ H_le_dec)).

   generalize (not_Qpositive_le_Qpositive_le' _ _ H_le_dec); 

   clear H_le_dec; intros H_le_dec H_eq_dec.

   generalize (Qpositive_le_to_Qpositive_le' p' p H_le_dec); unfold Qpositive_le'.

   generalize (Qpositive_le_noneq_explicit p' p H_le_dec H_eq_dec).

   destruct (interp_non_zero p) as [p0 [q0 H]].

   destruct (interp_non_zero p') as [p0' [q0' H']].

   rewrite H; rewrite H'; intros H_le_dec_unfolded H_lt.

   assert (H_le_unfold:   (S q0 + p0' * S q0 <= q0' + p0 * S q0')%nat); auto with arith. 

   replace (S p0 * S q0' - S p0' * S q0)%nat with (S (q0'+p0*(S q0')- (S q0+p0'*(S q0))))%nat;

   [| rewrite (minus_Sn_m _ _ H_le_unfold); auto with arith ].

   replace (S q0 * S q0')%nat with (S (q0'+q0*(S q0')))%nat; auto with arith.

   replace (S p0 * S q0' + S p0' * S q0)%nat with (S (q0'+p0*(S q0')+S (q0+p0'*(S q0))))%nat; auto with arith.

   set (m':=((q0' + p0 * S q0') + S (q0 + p0' * S q0))%nat).

   set (m:=((q0' + p0 * S q0') - (S q0 + p0' * S q0))%nat).

   set (n:=(q0' + q0 * S q0')%nat).

   assert (H_m':(S m + S n <= S m' + S n)%nat);

    [ subst m m' n; apply plus_le_compat_r; apply le_n_S; apply le_trans with (q0' + p0 * S q0')%nat; auto with arith;

      apply le_minus |].

   destruct (construct_correct2  (S m'+S n) m n H_m') as [factor [H_factor1 H_factor2]].

   generalize H_factor1 H_factor2; clear H_factor1 H_factor2.

   set (P:=(Qpositive_c  (S m) (S n) (S m' + S n))).

   destruct (interp_non_zero P) as [P0 [Q0 H'']].

   rewrite H''.

   unfold fst, snd. 

   intros H_factor1  H_factor2.

   repeat rewrite Ropp_Ropp_IZR; repeat rewrite <- INR_IZR_INZ.

   rewrite Rplus_Rdiv; auto.

   rewrite <- (Rdiv_Rmult_simplify (-INR (S P0)) (INR (S Q0)) (INR (S factor))); auto.

   rewrite Ropp_mult_distr_l_reverse; do 2 rewrite <- mult_INR.

   rewrite <- H_factor1; rewrite <- H_factor2.

   apply Rmult_Rdiv; auto.

   subst m n.

   repeat rewrite S_INR.

   rewrite minus_INR; trivial.

   repeat rewrite plus_INR.

   repeat rewrite mult_INR.

   repeat rewrite S_INR.

   ring.

  

  unfold Q_to_R, numerator, denominator, decode_Q, Qplus, fst, snd;

  unfold Qpositive_plus.

  destruct (interp_non_zero p) as [p0 [q0 H]].

  destruct (interp_non_zero p') as [p0' [q0' H']].

  rewrite H; rewrite H'.

  replace (S p0 * S q0' + S p0' * S q0)%nat with (S (q0'+p0*(S q0')+S (q0+p0'*(S q0))))%nat; auto with arith.

  replace (S q0 * S q0')%nat with (S (q0'+q0*(S q0')))%nat; auto with arith.

  set (m:=((q0' + p0 * S q0') + S (q0 + p0' * S q0))%nat).

  set (n:=(q0' + q0 * S q0')%nat).

  destruct (construct_correct2  (S m+S n) m n  (le_n _)) as [factor [H_factor1 H_factor2]].

  generalize H_factor1 H_factor2; clear H_factor1 H_factor2.

  set (P:=(Qpositive_c  (S m) (S n) (S m + S n))).

  destruct (interp_non_zero P) as [P0 [Q0 H'']].

  rewrite H''.

  unfold fst, snd. 

  intros H_factor1  H_factor2.

  repeat rewrite Ropp_Ropp_IZR; repeat rewrite <- INR_IZR_INZ.

  rewrite Rplus_Rdiv; auto.

  rewrite <- (Rdiv_Rmult_simplify (-INR (S P0)) (INR (S Q0)) (INR (S factor))); auto.

  rewrite Ropp_mult_distr_l_reverse; do 2 rewrite <- mult_INR.

  rewrite <- H_factor1; rewrite <- H_factor2.

  apply Rmult_Rdiv; auto.

  subst m n.

  repeat rewrite S_INR.

  repeat rewrite plus_INR.

  repeat rewrite S_INR.

  repeat rewrite mult_INR.

  repeat rewrite plus_INR.

  repeat rewrite mult_INR.

  repeat rewrite S_INR.

  ring.

Qed.



Lemma Q_to_Rmult: forall x y, Q_to_R (Qmult x y) = (Rmult (Q_to_R x) (Q_to_R y)).

Proof.

 intros [ |p|p] [ |p'|p']; try rewrite Q_to_R_Zero; try rewrite Qmult_zero;

 try rewrite Qmult_zero_right; try rewrite Rmult_0_r;

 try rewrite Rmult_0_l; try rewrite Q_to_R_Zero; trivial.

  

  unfold Q_to_R, numerator, denominator, decode_Q, Qmult, fst, snd;

  unfold Qpositive_mult.

  destruct (interp_non_zero p) as [p0 [q0 H]].

  destruct (interp_non_zero p') as [p0' [q0' H']].

  rewrite H; rewrite H'.

  replace (S p0 * S p0')%nat with (S (p0'+p0*(S p0')))%nat; trivial.

  replace (S q0 * S q0')%nat with (S (q0'+q0*(S q0')))%nat; trivial.

  set (m:=((p0' + p0 * S p0')%nat)).

  set (n:=((q0' + q0 * S q0')%nat)).

  destruct (construct_correct2  (S m+S n) m n  (le_n _)) as [factor [H_factor1 H_factor2]].

  generalize H_factor1 H_factor2; clear H_factor1 H_factor2.

  set (P:=(Qpositive_c (S m) (S n) (S m + S n))).

  destruct (interp_non_zero P) as [P0 [Q0 H'']].

  rewrite H''.

  unfold fst, snd. 

  intros H_factor1  H_factor2.

  repeat rewrite <- INR_IZR_INZ.

  rewrite Rdiv_Rmult_numerator_denominator; auto.

  rewrite <- (Rdiv_Rmult_simplify (INR (S P0)) (INR (S Q0)) (INR (S factor))); auto.

  do 2 rewrite <- mult_INR.

  rewrite <- H_factor1; rewrite <- H_factor2.

  apply Rmult_Rdiv; auto.

  subst m n.

  repeat rewrite S_INR.

  repeat rewrite plus_INR.

  repeat rewrite mult_INR.

  repeat rewrite S_INR.

  ring.

  

  unfold Q_to_R, numerator, denominator, decode_Q, Qmult, fst, snd;

  unfold Qpositive_mult.

  destruct (interp_non_zero p) as [p0 [q0 H]].

  destruct (interp_non_zero p') as [p0' [q0' H']].

  rewrite H; rewrite H'.

  replace (S p0 * S p0')%nat with (S (p0'+p0*(S p0')))%nat; trivial.

  replace (S q0 * S q0')%nat with (S (q0'+q0*(S q0')))%nat; trivial.

  set (m:=((p0' + p0 * S p0')%nat)).

  set (n:=((q0' + q0 * S q0')%nat)).

  destruct (construct_correct2  (S m+S n) m n  (le_n _)) as [factor [H_factor1 H_factor2]].

  generalize H_factor1 H_factor2; clear H_factor1 H_factor2.

  set (P:=(Qpositive_c (S m) (S n) (S m + S n))).

  destruct (interp_non_zero P) as [P0 [Q0 H'']].

  rewrite H''.

  unfold fst, snd. 

  intros H_factor1  H_factor2.

  repeat rewrite Ropp_Ropp_IZR; repeat rewrite <- INR_IZR_INZ.

  rewrite Rdiv_Rmult_numerator_denominator; auto.

  rewrite <- (Rdiv_Rmult_simplify (- INR (S P0)) (INR (S Q0)) (INR (S factor))); auto.

  rewrite Ropp_mult_distr_l_reverse; do 2 rewrite <- mult_INR.

  rewrite <- H_factor1; rewrite <- H_factor2.

  apply Rmult_Rdiv; auto.

  subst m n.

  repeat rewrite S_INR.

  repeat rewrite plus_INR.

  repeat rewrite mult_INR.

  repeat rewrite S_INR.

  ring.

  

  unfold Q_to_R, numerator, denominator, decode_Q, Qmult, fst, snd;

  unfold Qpositive_mult.

  destruct (interp_non_zero p) as [p0 [q0 H]].

  destruct (interp_non_zero p') as [p0' [q0' H']].

  rewrite H; rewrite H'.

  replace (S p0 * S p0')%nat with (S (p0'+p0*(S p0')))%nat; trivial.

  replace (S q0 * S q0')%nat with (S (q0'+q0*(S q0')))%nat; trivial.

  set (m:=((p0' + p0 * S p0')%nat)).

  set (n:=((q0' + q0 * S q0')%nat)).

  destruct (construct_correct2  (S m+S n) m n  (le_n _)) as [factor [H_factor1 H_factor2]].

  generalize H_factor1 H_factor2; clear H_factor1 H_factor2.

  set (P:=(Qpositive_c (S m) (S n) (S m + S n))).

  destruct (interp_non_zero P) as [P0 [Q0 H'']].

  rewrite H''.

  unfold fst, snd. 

  intros H_factor1  H_factor2.

  repeat rewrite Ropp_Ropp_IZR; repeat rewrite <- INR_IZR_INZ.

  rewrite Rdiv_Rmult_numerator_denominator; auto.

  rewrite <- (Rdiv_Rmult_simplify (- INR (S P0)) (INR (S Q0)) (INR (S factor))); auto.

  rewrite Ropp_mult_distr_l_reverse; do 2 rewrite <- mult_INR.

  rewrite <- H_factor1; rewrite <- H_factor2.

  apply Rmult_Rdiv; auto.

  subst m n.

  repeat rewrite S_INR.

  repeat rewrite plus_INR.

  repeat rewrite mult_INR.

  repeat rewrite S_INR.

  ring.

  

  unfold Q_to_R, numerator, denominator, decode_Q, Qmult, fst, snd;

  unfold Qpositive_mult.

  destruct (interp_non_zero p) as [p0 [q0 H]].

  destruct (interp_non_zero p') as [p0' [q0' H']].

  rewrite H; rewrite H'.

  replace (S p0 * S p0')%nat with (S (p0'+p0*(S p0')))%nat; trivial.

  replace (S q0 * S q0')%nat with (S (q0'+q0*(S q0')))%nat; trivial.

  set (m:=((p0' + p0 * S p0')%nat)).

  set (n:=((q0' + q0 * S q0')%nat)).

  destruct (construct_correct2  (S m+S n) m n  (le_n _)) as [factor [H_factor1 H_factor2]].

  generalize H_factor1 H_factor2; clear H_factor1 H_factor2.

  set (P:=(Qpositive_c (S m) (S n) (S m + S n))).

  destruct (interp_non_zero P) as [P0 [Q0 H'']].

  rewrite H''.

  unfold fst, snd. 

  intros H_factor1  H_factor2.

  repeat rewrite Ropp_Ropp_IZR; repeat rewrite <- INR_IZR_INZ.

  rewrite Rdiv_Rmult_numerator_denominator; auto.

  rewrite <- (Rdiv_Rmult_simplify (INR (S P0)) (INR (S Q0)) (INR (S factor))); auto.

  rewrite Ropp_mult_distr_l_reverse; do 2 rewrite <- mult_INR.

  rewrite <- H_factor1; rewrite <- H_factor2.

  apply Rmult_Rdiv; auto.

  subst m n.

  repeat rewrite S_INR.

  repeat rewrite plus_INR.

  repeat rewrite mult_INR.

  repeat rewrite S_INR.

  ring.

Qed.



Lemma Q_to_Rinv: forall x, ~(x=Zero) -> Q_to_R (Qinv x) = Rinv (Q_to_R x).

Proof.

 intros [ |p|p] H_zero.

  apply False_ind; auto.

  

  unfold Q_to_R, numerator, denominator, decode_Q, Qinv, fst, snd.

  destruct (interp_non_zero p) as [p0 [q0 H]].

  rewrite (inv_correct p _ _ H); rewrite H.

  repeat rewrite <- INR_IZR_INZ.

  rewrite Rpower.Rinv_Rdiv; auto.

  

  unfold Q_to_R, numerator, denominator, decode_Q, Qinv, fst, snd.

  destruct (interp_non_zero p) as [p0 [q0 H]].

  rewrite (inv_correct p _ _ H); rewrite H.

  repeat rewrite Ropp_Ropp_IZR; repeat rewrite <- INR_IZR_INZ.

  rewrite Rpower.Rinv_Rdiv; auto.

  unfold Rdiv; rewrite <- Rmult_opp_opp;

  rewrite Ropp_involutive;

  rewrite Ropp_inv_permute; auto.

Qed.



Lemma Q_to_Rminus: forall x y, Q_to_R (Qminus x y) = (Rminus (Q_to_R x) (Q_to_R y)).

Proof.

 intros x y; unfold Qminus; rewrite Q_to_Rplus; rewrite Q_to_Ropp; trivial.

Qed.



Lemma Q_to_Rdiv: forall x y, ~(y=Zero) -> Q_to_R (Qdiv x y) = (Rdiv (Q_to_R x) (Q_to_R y)).

Proof.

 intros x y Hy; unfold Qdiv; rewrite Q_to_Rmult; rewrite Q_to_Rinv; trivial.

Qed.



Lemma not_Qlt:forall x y, ~(Qlt y x) -> (Qle x y).

Proof.

 intros x y.

 destruct (Q_le_lt_dec x y); trivial.

Qed.

 

Lemma Q_to_Rle: forall x y, Qle x y -> Rle (Q_to_R x) (Q_to_R y).

Proof.

 intros [ |p|p] [ |p'|p'] H_Q_le; 

 try solve [ apply Rle_refl

           | apply False_ind; apply (Qlt_irreflexive Zero); apply Qle_lt_trans with (Qneg p'); trivial

           | apply False_ind; apply (Qlt_irreflexive Zero); apply Qlt_le_trans with (Qpos p); trivial

           | apply False_ind; apply (Qlt_irreflexive (Qpos p)); apply Qle_lt_trans with (Qneg p'); trivial

           ].

  

  unfold Q_to_R, numerator, denominator, decode_Q, fst, snd.

  simpl; destruct (interp_non_zero p') as [p0 [q0 H]].

  rewrite H;

  repeat rewrite <- INR_IZR_INZ.

  stepl R0; try field; auto.

  unfold Rdiv; apply Fourier_util.Rle_mult_inv_pos; auto.  

  

  unfold Q_to_R, numerator, denominator, decode_Q, fst, snd.

  generalize (Qpositive_le_to_Qpositive_le' _ _ (Qle_Qpositive_le_pos _ _ H_Q_le)); unfold Qpositive_le'.

  destruct (interp_non_zero p) as [p0 [q0 H]].

  destruct (interp_non_zero p') as [p0' [q0' H']].

  rewrite H; rewrite H'; intro H_Q_le_unfold.

  repeat rewrite <- INR_IZR_INZ.

  apply Rmult_Rdiv_pos_Rle; auto.

  repeat rewrite <- mult_INR.

  apply le_INR; trivial.

  

  unfold Q_to_R, numerator, denominator, decode_Q, fst, snd.

  simpl; destruct (interp_non_zero p) as [p0 [q0 H]].

  rewrite H.

  rewrite Ropp_Ropp_IZR; repeat rewrite <- INR_IZR_INZ.

  apply Ropp_le_cancel. 

  stepl R0; try field; auto.

  stepr (INR (S p0) / INR (S q0))%R; [|field; auto].

  unfold Rdiv; apply Fourier_util.Rle_mult_inv_pos; auto.  

  

  unfold Q_to_R, numerator, denominator, decode_Q, fst, snd.

  destruct (interp_non_zero p) as [p0 [q0 H]].

  destruct (interp_non_zero p') as [p0' [q0' H']].

  rewrite H; rewrite H'.

  rewrite Ropp_Ropp_IZR; repeat rewrite <- INR_IZR_INZ.

  apply Rle_trans with R0.

   apply Ropp_le_cancel; stepl R0; try field; auto; stepr (INR (S p0) / INR (S q0))%R; [|field; auto]; 

                                               unfold Rdiv; apply Fourier_util.Rle_mult_inv_pos; auto.  

   stepl R0; try field; auto; unfold Rdiv; apply Fourier_util.Rle_mult_inv_pos; auto.  

  

  unfold Q_to_R, numerator, denominator, decode_Q, fst, snd.

  generalize (Qpositive_le_to_Qpositive_le' _ _ (Qle_Qpositive_le_neg _ _ H_Q_le)); unfold Qpositive_le'.

  destruct (interp_non_zero p) as [p0 [q0 H]].

  destruct (interp_non_zero p') as [p0' [q0' H']].

  rewrite H; rewrite H'; intro H_Q_le_unfold.

  repeat rewrite Ropp_Ropp_IZR; repeat rewrite <- INR_IZR_INZ.

  apply Rmult_Rdiv_pos_Rle; auto.

  apply Ropp_le_cancel.

  stepr (INR (S p0) * INR (S q0'))%R; [|field; auto].

  stepl (INR (S p0') * INR (S q0))%R; [|field; auto].

  repeat rewrite <- mult_INR.

  apply le_INR; trivial.

Qed.



Lemma Q_to_Rlt: forall x y, Qlt x y -> Rlt (Q_to_R x) (Q_to_R y).

Proof.

 intros [ |p|p] [ |p'|p'] H_Q_lt;

 try solve [ apply False_ind; apply (Qlt_irreflexive Zero); trivial

           | apply False_ind; apply (Qlt_irreflexive Zero); apply Qlt_transitive with (Qneg p'); trivial

           | apply False_ind; apply (Qlt_irreflexive Zero); apply Qlt_transitive with (Qpos p); trivial

           | apply False_ind; apply (Qlt_irreflexive (Qpos p)); apply Qlt_transitive with (Qneg p'); trivial

           ].

  

  unfold Q_to_R, numerator, denominator, decode_Q, fst, snd.

  simpl; destruct (interp_non_zero p') as [p0 [q0 H]].

  rewrite H;

  repeat rewrite <- INR_IZR_INZ.

  stepl R0; try field; auto.

  unfold Rdiv; apply Fourier_util.Rlt_mult_inv_pos; auto.  

  

  unfold Q_to_R, numerator, denominator, decode_Q, fst, snd.

  inversion_clear H_Q_lt as [x y H_not_le| | | | ].

  generalize (sym_not_eq (not_Qpositive_le_not_eq _ _ H_not_le)).

  generalize (not_Qpositive_le_Qpositive_le' _ _ H_not_le).

  intros H_Q_le H_neq.

  generalize (Qpositive_le_noneq_explicit _ _ H_Q_le H_neq).

  destruct (interp_non_zero p) as [p0 [q0 H]].

  destruct (interp_non_zero p') as [p0' [q0' H']].

  rewrite H; rewrite H'; intro H_Q_lt_unfold.

  repeat rewrite <- INR_IZR_INZ.

  apply Rmult_Rdiv_pos_Rlt; auto.

  repeat rewrite <- mult_INR.

  apply lt_INR; trivial.

  

  unfold Q_to_R, numerator, denominator, decode_Q, fst, snd.

  simpl; destruct (interp_non_zero p) as [p0 [q0 H]].

  rewrite H;

  rewrite Ropp_Ropp_IZR; repeat rewrite <- INR_IZR_INZ.

  apply Ropp_lt_cancel. 

  stepl R0; try field; auto.

  stepr (INR (S p0) / INR (S q0))%R; [|field; auto].

  unfold Rdiv; apply Fourier_util.Rlt_mult_inv_pos; auto.  

  

  unfold Q_to_R, numerator, denominator, decode_Q, fst, snd.

  destruct (interp_non_zero p) as [p0 [q0 H]].

  destruct (interp_non_zero p') as [p0' [q0' H']].

  rewrite H; rewrite H'.

  rewrite Ropp_Ropp_IZR; repeat rewrite <- INR_IZR_INZ.

  apply Rlt_trans with R0.

   apply Ropp_lt_cancel; stepl R0; try field; auto; stepr (INR (S p0) / INR (S q0))%R; [|field; auto]; 

                                               unfold Rdiv; apply Fourier_util.Rlt_mult_inv_pos; auto.  

   stepl R0; try field; auto; unfold Rdiv; apply Fourier_util.Rlt_mult_inv_pos; auto.  

  

  unfold Q_to_R, numerator, denominator, decode_Q, fst, snd.

  inversion_clear H_Q_lt as [ |x y H_not_le| | | ].

  generalize (sym_not_eq (not_Qpositive_le_not_eq _ _ H_not_le)).

  generalize (not_Qpositive_le_Qpositive_le' _ _ H_not_le).

  intros H_Q_le H_neq.

  generalize (Qpositive_le_noneq_explicit _ _ H_Q_le H_neq).

  destruct (interp_non_zero p) as [p0 [q0 H]].

  destruct (interp_non_zero p') as [p0' [q0' H']].

  rewrite H; rewrite H'; intro H_Q_lt_unfold.

  repeat rewrite Ropp_Ropp_IZR; repeat rewrite <- INR_IZR_INZ.

  apply Rmult_Rdiv_pos_Rlt; auto.

  apply Ropp_lt_cancel.

  stepr (INR (S p0) * INR (S q0'))%R; [|field; auto].

  stepl (INR (S p0') * INR (S q0))%R; [|field; auto].

  repeat rewrite <- mult_INR.

  apply lt_INR; trivial.

Qed.



Lemma Q_to_R_not_eq: forall x y, ~(x=y)->~(Q_to_R x = Q_to_R y).

Proof.

 intros [ |p|p] [ |p'|p'] H_not_eq.

  

  apply False_ind; apply H_not_eq; trivial.

  

  unfold Q_to_R, numerator, denominator, decode_Q, fst, snd.

  destruct (interp_non_zero p') as [p0 [q0 H]].

  rewrite H.

  repeat rewrite <- INR_IZR_INZ.

  apply Rlt_not_eq;

  stepl R0; [|simpl; field];

  unfold Rdiv; apply Fourier_util.Rlt_mult_inv_pos; auto.  

  

  unfold Q_to_R, numerator, denominator, decode_Q, fst, snd.

  destruct (interp_non_zero p') as [p0 [q0 H]].

  rewrite H.

  repeat rewrite Ropp_Ropp_IZR; repeat rewrite <- INR_IZR_INZ.

  apply Rlt_not_eq'.

  apply Ropp_lt_cancel. 

  stepl R0; [|simpl; field];

  stepr (INR (S p0) / INR (S q0))%R; [|field; auto].

  unfold Rdiv; apply Fourier_util.Rlt_mult_inv_pos; auto.  

  

  unfold Q_to_R, numerator, denominator, decode_Q, fst, snd.

  destruct (interp_non_zero p) as [p0 [q0 H]].

  rewrite H.

  repeat rewrite <- INR_IZR_INZ.

  apply Rlt_not_eq'.

  stepl R0; [|simpl; field];

  unfold Rdiv; apply Fourier_util.Rlt_mult_inv_pos; auto.  

  

  unfold Q_to_R, numerator, denominator, decode_Q, fst, snd.

  destruct (not_Qeq_inf _ _ H_not_eq) as [H_Q_lt|H_Q_lt];

  inversion_clear H_Q_lt as [x y H_not_le| | | | ];

  generalize (sym_not_eq (not_Qpositive_le_not_eq _ _ H_not_le));

  generalize (not_Qpositive_le_Qpositive_le' _ _ H_not_le); intros H_Q_le H_neq;

  generalize (Qpositive_le_noneq_explicit _ _ H_Q_le H_neq);

  destruct (interp_non_zero p) as [p0 [q0 H]];

  destruct (interp_non_zero p') as [p0' [q0' H']];

  rewrite H; rewrite H'; intro H_Q_lt_unfold;

  [ apply Rlt_not_eq | apply Rlt_not_eq'];

  repeat rewrite <- INR_IZR_INZ; apply Rmult_Rdiv_pos_Rlt; auto; repeat rewrite <- mult_INR; apply lt_INR; trivial.

  

  unfold Q_to_R, numerator, denominator, decode_Q, fst, snd.

  destruct (interp_non_zero p) as [p0 [q0 H]].

  destruct (interp_non_zero p') as [p0' [q0' H']].

  rewrite H; rewrite H'.

  repeat rewrite Ropp_Ropp_IZR; repeat rewrite <- INR_IZR_INZ.

  apply Rlt_not_eq'.

  apply Rlt_trans with R0.

   apply Ropp_lt_cancel;

    stepl R0; try field; auto;

    stepr (INR (S p0') / INR (S q0'))%R; [|field; auto]; unfold Rdiv; apply Fourier_util.Rlt_mult_inv_pos; auto.  

   stepl R0; try field; auto; unfold Rdiv; apply Fourier_util.Rlt_mult_inv_pos; auto.  

   

  unfold Q_to_R, numerator, denominator, decode_Q, fst, snd.

  destruct (interp_non_zero p) as [p0 [q0 H]].

  rewrite H.

  repeat rewrite Ropp_Ropp_IZR; repeat rewrite <- INR_IZR_INZ.

  apply Rlt_not_eq.

  apply Ropp_lt_cancel. 

  stepl R0; [|simpl; field];

  stepr (INR (S p0) / INR (S q0))%R; [|field; auto].

  unfold Rdiv; apply Fourier_util.Rlt_mult_inv_pos; auto.  

  

  unfold Q_to_R, numerator, denominator, decode_Q, fst, snd.

  destruct (interp_non_zero p) as [p0 [q0 H]].

  destruct (interp_non_zero p') as [p0' [q0' H']].

  rewrite H; rewrite H'.

  repeat rewrite Ropp_Ropp_IZR; repeat rewrite <- INR_IZR_INZ.

  apply Rlt_not_eq.

  apply Rlt_trans with R0.

   apply Ropp_lt_cancel;

    stepl R0; try field; auto;

    stepr (INR (S p0) / INR (S q0))%R; [|field; auto]; unfold Rdiv; apply Fourier_util.Rlt_mult_inv_pos; auto.  

   stepl R0; try field; auto; unfold Rdiv; apply Fourier_util.Rlt_mult_inv_pos; auto.  

  

  unfold Q_to_R, numerator, denominator, decode_Q, fst, snd.

  destruct (not_Qeq_inf _ _ H_not_eq) as [H_Q_lt|H_Q_lt];

  inversion_clear H_Q_lt as [ |x y H_not_le| | | ];

  generalize (sym_not_eq (not_Qpositive_le_not_eq _ _ H_not_le));

  generalize (not_Qpositive_le_Qpositive_le' _ _ H_not_le); intros H_Q_le H_neq;

  generalize (Qpositive_le_noneq_explicit _ _ H_Q_le H_neq);

  destruct (interp_non_zero p) as [p0 [q0 H]];

  destruct (interp_non_zero p') as [p0' [q0' H']];

  rewrite H; rewrite H'; intro H_Q_lt_unfold;

  [ apply Rlt_not_eq | apply Rlt_not_eq'];

  repeat rewrite Ropp_Ropp_IZR; repeat rewrite <- INR_IZR_INZ;

  apply Rmult_Rdiv_pos_Rlt; auto; apply Ropp_lt_cancel. 

    stepr (INR (S p0) * INR (S q0'))%R; [|field; auto];

    stepl (INR (S p0') * INR (S q0))%R; [|field; auto]; repeat rewrite <- mult_INR;

    apply lt_INR; trivial...

    stepr (INR (S p0') * INR (S q0))%R; [|field; auto];

    stepl (INR (S p0) * INR (S q0'))%R; [|field; auto]; repeat rewrite <- mult_INR;

    apply lt_INR; trivial...

Qed.



Lemma Q_to_R_Qle:forall x y : Q, Rle (Q_to_R x) (Q_to_R y) -> Qle x y. 

Proof.

 intros x y H_Rle; destruct (Q_le_lt_dec x y) as [Hxy|Hxy]; trivial; apply False_ind; generalize (Q_to_Rlt _ _ Hxy);

 apply RIneq.Rle_not_lt; assumption.

Qed.



Lemma Q_to_R_Qlt:forall x y : Q, Rlt (Q_to_R x) (Q_to_R y) -> Qlt x y. 

Proof.

 intros x y H_Rlt; destruct (Q_le_lt_dec y x) as [Hxy|Hxy]; trivial;

 apply False_ind; generalize (Q_to_Rle _ _ Hxy); apply RIneq.Rlt_not_le; assumption.

Qed.



Lemma Q_to_R_Qneq:forall x y : Q,  (Q_to_R x)<>(Q_to_R y) ->  x<>y. 

Proof.

  intros x y H_Rneq; contradict H_Rneq; rewrite H_Rneq; trivial.

Qed.



Lemma Q_to_R_Qeq:forall x y : Q,  (Q_to_R x)=(Q_to_R y) ->  x=y. 

Proof.

 intros x y H_Req; destruct (Q_eq_dec x y) as [Hxy|Hxy]; trivial;

 apply False_ind; apply (Q_to_R_not_eq _ _ Hxy); assumption.

Qed.

  

Lemma Z_to_Q_to_R_IZR: forall z, Q_to_R (Z_to_Q z) = IZR z.

Proof.

 intros [|p|p].

  

  simpl; rewrite <- Q_to_R_Zero; trivial.

  

  unfold Z_to_Q, Q_to_R, numerator, denominator, decode_Q, fst, snd.

  rewrite (Qpositive_i_c (nat_of_P p) (S (nat_of_P p)) (lt_O_nat_of_P _)); trivial;

  repeat rewrite <- INR_IZR_INZ; unfold IZR, INR at 2; rewrite <- INR_IPR; field; auto.

  

  unfold Z_to_Q, Q_to_R, numerator, denominator, decode_Q, fst, snd.

  rewrite (Qpositive_i_c (nat_of_P p) (S (nat_of_P p)) (lt_O_nat_of_P _)); trivial.

  repeat rewrite Ropp_Ropp_IZR; repeat rewrite <- INR_IZR_INZ; unfold IZR, INR at 2; rewrite <- INR_IPR; field; auto.

Qed.



Ltac realify_Q_assumptions :=

 repeat 

 match goal with 

 | [ id : (Qlt ?X1 ?X2) |- _ ] => generalize (Q_to_Rlt _ _ id); clear id; try unfold fst, snd

 | [ id : (Qle ?Xe ?X2) |- _ ] => generalize (Q_to_Rle _ _ id); clear id; try unfold fst, snd

 | [ id : (@eq Q ?Xe ?X2) |- _ ] => generalize (Q_to_Req _ _ id); clear id; try unfold fst, snd

 | [ id : ~(@eq Q ?Xe ?X2) |- _ ] => generalize (Q_to_R_not_eq _ _ id); clear id; try unfold fst, snd

 end.



Ltac realify_Q_goal :=   

 match goal with 

 | [ |- context [(Q_to_R (Qplus ?X1 ?X2))] ] => rewrite Q_to_Rplus; realify_Q_goal

 | [ |- context [(Q_to_R (Qminus ?X1 ?X2))] ] => rewrite Q_to_Rminus; realify_Q_goal

 | [ |- context [(Q_to_R (Qmult ?X1 ?X2))] ] => rewrite Q_to_Rmult; realify_Q_goal

 | [ |- context [(Q_to_R (Qdiv ?X1 ?X2))] ] => rewrite Q_to_Rdiv; realify_Q_goal

 | [ |- context [(Q_to_R (Qopp ?X1))] ] => rewrite Q_to_Ropp; realify_Q_goal

 | [ |- context [(Q_to_R (Qinv ?X1))] ] => rewrite Q_to_Rinv; realify_Q_goal

 | [ |- context [(Q_to_R Zero)] ] => rewrite Q_to_R_Zero; realify_Q_goal

 | [ |- context [(Q_to_R Qone)] ] => rewrite Q_to_R_Qone; realify_Q_goal

 | [ |- context [(Q_to_R (Qneg One))] ] => rewrite Q_to_R_Qneg_One; realify_Q_goal

 | [ |- context [(Q_to_R (Z_to_Q ?X1))] ] => rewrite Z_to_Q_to_R_IZR; realify_Q_goal

 | [ |- _ ] => idtac

 end.



Ltac realify_Q := try realify_Q_assumptions; realify_Q_goal.



Ltac rationalify_R_goal :=   

 match goal with 

 | [ |- context [(Rplus (Q_to_R ?X1) (Q_to_R ?X2))] ] => rewrite <- Q_to_Rplus; rationalify_R_goal

 | [ |- context [(Rminus (Q_to_R ?X1) (Q_to_R ?X2))] ] => rewrite <- Q_to_Rminus; rationalify_R_goal

 | [ |- context [(Rmult (Q_to_R ?X1) (Q_to_R ?X2))] ] => rewrite <- Q_to_Rmult; rationalify_R_goal

 | [ |- context [(Rdiv (Q_to_R ?X1) (Q_to_R ?X2))] ] => rewrite <- Q_to_Rdiv; auto; rationalify_R_goal

 | [ |- context [(Ropp (Q_to_R ?X1)) ]] => rewrite <- Q_to_Ropp; rationalify_R_goal

 | [ |- context [(Rinv (Q_to_R ?X1))] ] => rewrite <- Q_to_Rinv; auto; rationalify_R_goal

 | [ |- context [R0] ] => rewrite <- Q_to_R_Zero; rationalify_R_goal

 | [ |- context [R1] ] => rewrite <- Q_to_R_Qone; rationalify_R_goal

 | [ |- context [(IZR ?X1)] ] => rewrite <- Z_to_Q_to_R_IZR; realify_Q_goal

 | [ |- _ ] => idtac

 end.



Ltac rationalify_R := rationalify_R_goal;

 match goal with 

 | [ |- Rlt (Q_to_R ?X1) (Q_to_R ?X2)] => apply Q_to_Rlt

 | [ |- Rle (Q_to_R ?X1) (Q_to_R ?X2)] => apply Q_to_Rle

 | [ |- @eq Q (Q_to_R ?X1) (Q_to_R ?X2)] => apply (f_equal Q_to_R)

 | [ |- ~(@eq Q (Q_to_R ?X1) (Q_to_R ?X2))] => apply Q_to_R_not_eq

 | [ |- ~(@eq Q ?X1 Zero)] => idtac

 | [ |- _ ] => fail 1

 end.

