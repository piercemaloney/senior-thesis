
Require Export Qsyntax.
(* Qsyntax:
Require Export general_Q.

Infix "/" := make_Q : Q_scope. 

Notation "{ x }" := (decode_Q x) : Q_scope.

Open Scope Q_scope.

Infix "+" := Qplus : Q_scope.

Infix "*" := Qmult : Q_scope.

Infix "-" := Qminus : Q_scope.

Infix "/" := Qdiv : Q_scope.

Notation "- x" := (Qopp x) : Q_scope.

Notation "x1 ^" := (Qinv x1) (at level 2, left associativity) : Q_scope.

Delimit Scope Q_scope with Q.

Infix "<" := Qlt : Q_scope.
Infix "<=" := Qle : Q_scope. *)
Require Export Field_Theory_Q.
(* Field_Theory_Q:
Require Import Eqdep_dec.
Require Export Field.
Require Export Q_order.

Lemma Q_Ring_Theory :
    ring_theory Zero Qone Qplus Qmult Qminus Qopp (eq(A:=Q)).

Lemma Qinv_defT : forall n : Q, n <> Zero -> Qmult (Qinv n) n = Qone.

Lemma QField :
  field_theory Zero Qone Qplus Qmult Qminus Qopp Qdiv Qinv (eq(A:=Q)).

Ltac isQcst t :=
  match t with
    Zero => true
  | Qpos ?p => isQcst p
  | Qneg ?p => isQcst p
  | nR ?p => isQcst p
  | dL ?p => isQcst p
  | One => true
  | Qone => true
  | _ => false
  end.
Ltac Qcst t :=
  match isQcst t with
  | true => t
  | _ => InitialRing.NotConstant
  end.
 
Add Field Qfield : QField (decidable Q_eq_prop, constants [Qcst]).

Definition not_eq2eqT (A : Set) (x y : A) (H1 : x <> y) : 
  x <> y := fun H2 : x = y => H1 (H2).

Ltac Field := field. *)
Require Export Q_ordered_field_properties.
(* Q_ordered_field_properties:
Require Export Qsyntax.
Require Export Field_Theory_Q.

Lemma Qmult_absorb_nonzero_r: forall x y : Q, x * y <> Zero -> y <> Zero.

Lemma Qmult_absorb_nonzero_l: forall x y : Q, x * y <> Zero -> x <> Zero.

Lemma Qle_Qminus_Zero: forall x y: Q, x <= y -> Zero <= y-x.

Lemma Qle_Qminus_Zero_neg: forall x y : Q, x <= y -> x-y <= Zero.

Lemma Qle_Zero_Qminus_neg: forall x y : Q, x-y <= Zero -> x <= y.

Lemma Qle_Zero_Qminus: forall x y: Q,  Zero <= y-x -> x <= y.

Lemma Qmult_mult_nonneg: forall x:Q, Zero <= x*x.

Lemma Qmult_mult_pos: forall x:Q, x<> Zero -> Zero < x*x.

Lemma Qlt_opp:forall x y, Qopp x < Qopp y -> y < x.

Lemma Qlt_plus:forall x y z : Q, x < y -> z + x < z + y.

Lemma Qlt_Qminus_Zero: forall x y : Q, x < y -> Zero < y - x.

Lemma Qlt_Qminus_Zero_neg: forall x y : Q, x < y -> x-y < Zero.

Lemma Qlt_Zero_Qminus_neg: forall x y : Q, x-y < Zero -> x < y.

Lemma Qlt_reg_mult_pos_l: forall x y z : Q, Zero < x -> y < z -> x * y < x * z.

Lemma Qlt_reg_mult_pos_r: forall x y z : Q, Zero < x -> y < z -> y * x < z * x.

Lemma Qlt_reg_mult_neg_l: forall x y z : Q, x < Zero -> y < z -> x * z < x * y.

Lemma Qlt_reg_mult_neg_r: forall x y z : Q, x < Zero -> y < z -> z * x < y * x.

Lemma Qdiv_Qmult_pos:forall x y z t: Q, Zero < z*t -> x/z < y/t -> x*t < y*z. 

Lemma Qinv_involutive:forall x:Q, x<>Zero -> Qinv (Qinv x) = x.

Lemma Qmult_Qdiv_pos:forall x y z t: Q, Zero < z*t -> x*t < y*z -> x/z < y/t.

Lemma Qlt_Qopp_pos: forall x: Q, x < Zero -> Zero < - x.

Lemma Qlt_Qopp_neg: forall x: Q, Zero < x -> -x < Zero.

Lemma Qmult_one_left:forall x : Q, Qone * x = x.

Lemma Qdiv_Qone_Qone: Qdiv Qone Qone = Qone.

Lemma Qinv_Qdiv_Qone:forall x, Qinv x = Qone/x. 

Lemma Qminus_Qdiv:forall x y z t, z<>Zero -> t<>Zero -> x/z - y/t = (x*t-y*z)/(z*t).

Lemma Qplus_Qdiv:forall x y z t, z<>Zero -> t<>Zero -> x/z + y/t = (x*t+y*z)/(z*t).

Definition Qmult_Qinv_l:= Qinv_defT. 

Lemma Qmult_Qinv_r:forall x, x <> Zero -> x * (Qinv x) = Qone.

Lemma Qinv_Qmult:forall x y, x<>Zero -> y <> Zero -> Qinv (x*y) = (Qinv x)*(Qinv y).

Lemma Qplus_Qdiv_one:forall p q, q<> Zero -> (p+q) / q = p/q + Qone.

Lemma Qdiv_Qopp_numerator: forall x y : Q, y<> Zero -> Qdiv (-x) y = - (Qdiv x  y).

Lemma Qdiv_Qopp_denomintor: forall x y : Q, y<> Zero -> Qdiv x (-y) = - (Qdiv x  y).

Lemma Qdiv_Qdiv_simplify:forall x y z, z<> Zero -> y<> Zero -> (x/z)/(y/z) = x/y.

Lemma Qdiv_Qmult_Qone_denominator:forall x y z, z<>Zero -> y<>Zero -> x/(y*z) = (x/y)*(Qone/z).

Lemma Qdiv_Qmult_numerator_l: forall (x y z:Q), y<>Zero -> z*(x/y)=(z*x)/y.

Lemma Qdiv_Qmult_numerator_r: forall (x y z:Q), y<>Zero -> (x/y)*z=(x*z)/y.

Lemma Qlt_Qmult_cancel_l: forall x y z : Q, Zero < x -> x * y < x * z -> y < z.

Lemma Qlt_Qmult_cancel_r: forall x y z : Q, Zero < x -> y * x< z * x -> y < z.

Definition Qmult_resp_Qlt_pos_r:= Qlt_Qmult_cancel_r :  forall t x y : Q, Zero < t -> x * t < y * t -> x < y.

Definition Qmult_resp_Qlt_pos_l:= Qlt_Qmult_cancel_l: forall t x y : Q, Zero < t -> t * x < t * y -> x < y.

Lemma Qmult_resp_Qlt_neg_r: forall t x y : Q, t < Zero -> x * t < y * t -> y < x.

Lemma Qmult_resp_Qlt_neg_l: forall t x y : Q, t < Zero -> t * x < t * y -> y < x.

Lemma Qeq_Qminus : forall x y, x=y -> x-y=Zero.

Lemma Qminus_Qeq : forall x y, x-y=Zero -> x=y.

Lemma Qlt_not_eq': forall x y : Q, x < y -> x <> y.

Lemma Qinv_neg: forall q : Q, q<Zero -> Qinv q< Zero.

Lemma Qle_Qopp_pos:forall q : Q, q<= Zero -> Zero<= Qopp q.

Lemma Qopp_Qone_Qlt_Qone: Qopp Qone < Qone.

Hint Resolve Qinv_pos Qinv_resp_nonzero Qminus_Qeq Qeq_Qminus
             Qlt_not_eq' Qinv_neg Qle_Qopp_pos Qlt_Qopp_pos 
             Qlt_Qopp_neg Qopp_Qone_Qlt_Qone.

Lemma Qle_mult_nonneg_pos: forall x y : Q, Zero <= x -> Zero < y -> Zero <= x * y.

Lemma Qle_mult_pos_nonneg: forall x y : Q, Zero<x -> Zero <= y -> Zero <= x * y.

Lemma Qle_mult_nonpos_neg: forall x y : Q, x<=Zero -> y<Zero -> Zero <= x * y.

Lemma Qle_mult_neg_nonpos: forall x y : Q, x<Zero -> y<=Zero -> Zero <= x * y.

Lemma Qle_Qdiv_nonpos_pos: forall x y : Q, x <= Zero -> Zero < y -> x / y <= Zero.

Lemma Qle_Qdiv_nonneg_neg: forall x y : Q, Zero <= x -> y < Zero -> x / y <= Zero.

Lemma Qle_Qdiv_nonneg_pos: forall x y : Q, Zero<=x -> Zero < y -> Zero<=x / y.

Lemma Qle_Qdiv_nonpos_neg: forall x y : Q, x<=Zero -> y<Zero -> Zero<=x / y.

Lemma Qlt_mult_neg_neg: forall x y : Q, x<Zero-> y<Zero -> Zero < x * y.

Lemma Qmult_reg_l: forall x y z: Q, z <> Zero -> z*x = z*y -> x=y.

Lemma Qmult_reg_r: forall x y z: Q, z <> Zero -> x*z = y*z -> x=y.

Lemma Qmult_Qdiv: forall x y z t : Q,  z <> Zero  -> t <> Zero -> x * t = y * z -> x / z = y / t.

Lemma Qdiv_Qmult: forall x y z t : Q,  z <> Zero  -> t <> Zero -> x / z = y / t -> x * t = y * z.

Lemma Qdiv_Qdiv_Qmult_numerator: forall x y z, y<>Zero -> z<>Zero ->(x/y)/z = x/(y*z).

Lemma Qdiv_Qdiv_Qmult_denominator: forall x y z, y<>Zero -> z<>Zero -> x/(y/z) = (x*z)/y.

Lemma Qdiv_Qplus_Qmult: forall x y z, y<>Zero -> x/y + z = (x+y*z)/y.

Lemma Qdiv_Qminus_Qmult: forall x y z, y<>Zero -> x/y - z = (x-y*z)/y.

Lemma Qminus_Qdiv_Qmult: forall x y z, ~(y=Zero)->z-x/y=(y*z-x)/y.

Lemma Qplus_Qdiv_Qmult: forall x y z, ~(y=Zero)->z+x/y=(y*z+x)/y.

Lemma Qle_reg_mult_r: forall x y z : Q, Zero < x -> y <=z -> y * x <=z * x.

Lemma Qle_reg_mult_l: forall x y z : Q, Zero < x -> y <= z -> x * y <= x * z.

Lemma Qmult_resp_Qle_pos_r: forall t x y : Q, Zero < t -> x * t <= y * t -> x <= y.

Lemma Qmult_resp_Qle_pos_l: forall t x y : Q, Zero < t -> t * x <= t * y -> x <= y.

Lemma Qmult_resp_Qle_neg_r: forall t x y : Q, t < Zero -> x * t <= y * t -> y <= x.

Lemma Qmult_resp_Qle_neg_l: forall t x y : Q, t < Zero -> t * x <= t * y -> y <= x.

Lemma Qmult_Qdiv_pos_Qle: forall x y z t : Q, Zero < z -> Zero < t -> x * t <= y * z -> x / z <= y / t.

Lemma Qmult_Qle_compat: forall n m p q : Q, n <= p -> m <= q -> Zero <= n -> Zero <= m -> n * m <= p * q.

Lemma Qdiv_num_denom_explicit: forall q1 q2 p : Q, q2 <> Zero -> p <> Zero -> q1 / q2 = (q1 * p)/ (q2 * p).

Lemma Qle_opp: forall x y : Q, - x <= - y -> y <= x.

Lemma Qmult_pos_Qle_Qdiv: forall x y z : Q, Zero<z -> x * z<=y -> x <= y / z.

Lemma Qmult_neg_Qle_Qdiv: forall x y z : Q, z <Zero -> y <= x * z -> x <= y / z.

Lemma Qmult_pos_Qdiv_Qle: forall x y z : Q, Zero<z -> y<=x*z -> y/z <= x.

Lemma Qmult_neg_Qdiv_Qle: forall x y z : Q, z <Zero -> x*z<=y -> y/z<=x.

Lemma Qmult_pos_Qlt_Qdiv: forall x y z : Q, Zero<z -> x * z<y -> x < y/z.

Lemma Qmult_neg_Qlt_Qdiv: forall x y z : Q, z <Zero -> y < x * z -> x < y / z.

Lemma Qmult_pos_Qdiv_Qlt: forall x y z : Q, Zero<z -> y<x*z -> y/z < x.

Lemma Qmult_neg_Qdiv_Qlt: forall x y z : Q, z <Zero -> x*z<y -> y/z<x.

Lemma Qmult_Qdiv_pos_neg_Qle:forall x y z t : Q,  Zero < z -> t<Zero -> y * z <= x * t -> x / z <= y / t.

Lemma Qmult_Qdiv_neg_pos_Qle:forall x y z t : Q,  z<Zero -> Zero<t -> y * z <= x * t -> x / z <= y / t.

Lemma Qmult_Qdiv_neg_Qle:forall x y z t : Q,  z<Zero -> t<Zero -> x * t<=y * z -> x / z <= y / t.

Lemma Qopp_involutive: forall q, Qopp (Qopp q) = q.

Lemma Qopp_Qle: forall x y, y <= x -> - x <= - y.

Lemma Qopp_Qlt: forall x y, y < x -> - x < - y.

Lemma Qle_reg_mult_r_strong: forall x y z : Q, Zero <= x -> y <= z -> y * x <= z * x.

Lemma Qle_reg_mult_l_strong: forall x y z : Q, Zero <= x -> y <= z -> x * y <= x * z.

Lemma Qlt_Qdiv_denom_neg_neg: forall x y:Q, y<Zero -> x / y < Zero ->  Zero < x.

Lemma Qlt_Qdiv_denom_neg_pos: forall x y:Q, y<Zero ->  Zero< x / y  -> x<Zero.

Lemma Qlt_Qdiv_denom_pos_neg: forall x y:Q, Zero<y -> x / y < Zero ->  x<Zero.

Lemma Qlt_Qdiv_denom_pos_pos: forall x y:Q, Zero<y ->  Zero< x / y  -> Zero<x.

Lemma Qle_Qdiv_denom_neg_nonpos: forall x y:Q, y<Zero -> x / y <= Zero ->  Zero <= x.

Lemma Qle_Qdiv_denom_neg_nonneg: forall x y:Q, y<Zero ->  Zero<= x / y  -> x<=Zero.

Lemma Qle_Qdiv_denom_pos_nonpos: forall x y:Q, Zero<y -> x / y <= Zero ->  x<=Zero.

Lemma Qle_Qdiv_denom_pos_nonneg: forall x y:Q, Zero<y ->  Zero<= x / y  -> Zero<=x.

Lemma Qlt_neg_Qopp: forall x : Q, - x < Zero->Zero < x.

Lemma Qlt_pos_Qopp: forall x : Q, Zero < - x->x<Zero.

Lemma Qmult_mult_Qle_Qone_Qopp_Qone: forall q, -Qone<=q -> q<= Qone -> q*q <= Qone. 

Lemma Qinv_resp_nonzero_Qdiv:forall q, q <> Zero -> (Qone/q)<>Zero. 

Lemma Qmult_Qlt_Qle_nonneg_pos_compat: forall n m p q, n < p -> m <= q -> Zero <= n -> Zero < q -> n * m < p * q.

Lemma Qmult_Qlt_Qle_pos_nonneg_compat: forall n m p q, n <= p -> m < q -> Zero < p -> Zero <= m -> n * m < p * q.

Ltac qZ_numerals_one  :=replace (Z_to_Q 1) with Qone;  trivial. 

Ltac qZ_numerals  := 
 match goal with 
 | [ |- context [(Z_to_Q (Z_of_nat ?X1))] ] => unfold Z_of_nat; qZ_numerals
 | [ |- context [(Z_to_Q Z0)] ] => replace (Z_to_Q Z0) with Zero; trivial; qZ_numerals
 | [ |- context [(Z_to_Q (Zpos ?X1))] ] => progress  let v:= eval compute in (Z.pred (Zpos X1)) in 
         replace (Z_to_Q (Zpos X1)) with (Qplus Qone (Z_to_Q v)); trivial; qZ_numerals
 | [ |- context [(Z_to_Q (Zneg ?X1))] ] => let v:= eval compute in (Z.succ (Zneg X1)) in 
        replace (Z_to_Q (Zneg X1)) with (Qminus (Z_to_Q v) Qone); trivial; qZ_numerals
 | [ |- context [(Qplus Zero ?X1)] ] => rewrite Qplus_zero_left; qZ_numerals
 | [ |- context [(Qplus ?X1 Zero)] ] => rewrite Qplus_zero_right; qZ_numerals
 | [ |- context [(Qminus Zero ?X1)] ] => unfold Qminus; rewrite Qplus_zero_left; qZ_numerals
 | [ |- context [(Qminus ?X1 Zero)] ] => unfold Qminus; rewrite Qplus_zero_right; qZ_numerals
 | [ |- context [(Qmult Qone ?X1)] ] => rewrite Qmult_one_left; qZ_numerals
 | [ |- context [(Qmult ?X1 Qone)] ] => rewrite Qmult_one_right; qZ_numerals
 | [ |- _ ] => idtac
 end.

Ltac ring_exact_Q hyp := 
 match type of hyp with 
 | Qlt ?X1 ?X2 => stepl X1;[|qZ_numerals;ring];stepr X2;[|qZ_numerals;ring]; trivial
 | Qle ?X1 ?X2 => stepl X1;[|qZ_numerals;ring];stepr X2;[|qZ_numerals;ring]; trivial
 | ~(@eq Q ?X1 ?X2) => stepl X1;[|qZ_numerals;ring];stepr X2;[|qZ_numerals;ring]; trivial
 | ?X3 => fail 1
 end. *)

Definition Qabs (q:Q):Q:= 
  match q with 
  | Zero => Zero
  | Qpos qp => Qpos qp
  | Qneg qp => Qpos qp
  end.

Lemma Qabs_eq: forall q, Zero<=q -> Qabs q = q. 
Proof.
 intros [|q|q] Hq; simpl; trivial; unfold Qle in Hq; contradiction Hq; auto.
Qed.

Lemma Qabs_non_eq: forall q, q<=Zero -> Qabs q = (-q).
Proof.
 intros [|q|q] Hq; simpl; trivial; unfold Qle in Hq; contradiction Hq; auto.
Qed.

Lemma Qabs_eq_pos: forall q, Zero<q -> Qabs q = q. 
Proof.
 intros [|q|q] Hq; simpl; trivial; contradiction (Zero_not_lt_Qneg q). 
Qed.

Lemma Qabs_non_eq_neg: forall q, q<Zero -> Qabs q = (-q).
Proof.
 intros [|q|q] Hq; simpl; trivial; contradiction (Qpos_not_lt_Zero q). 
Qed.

Lemma Qabs_Qmult: forall q1 q2, Qabs (q1*q2) = (Qabs q1) * (Qabs q2).
Proof.
 intros [|q1|q1] [|q2|q2]; simpl; trivial.  
Qed.

Lemma Qabs_5: forall q p, Qabs q <= p -> (- p <= q)/\ (q<= p).
Proof.
 intros [|q|q] [|p|p]; simpl; unfold Qle; intros Hqp; split; auto;
 solve [ apply Zero_not_lt_Qneg|apply Qpos_not_lt_Qneg|apply Qle_opp; simpl; assumption].
Qed.  

Lemma Qabs_6: forall q p, Qabs q <= p -> q<= p.
Proof.
 intros q p H; apply (proj2 (Qabs_5 _ _ H)).
Qed.

Lemma Qabs_7: forall q p, Qabs q <= p -> - p <= q.
 intros q p H; apply (proj1 (Qabs_5 _ _ H)).
Qed.

Lemma Qabs_8: forall q p, - p <= q -> q <= p -> Qabs q <= p.
Proof.
 intros [|q|q] [|p|p]; simpl; unfold Qle; intros H1 H2; auto; apply Qle_opp; simpl; assumption.
Qed.

Lemma Qabs_nonneg: forall q, Zero <= Qabs q.
Proof.
 intros [|q|q]; simpl; auto. 
Qed.

Lemma Qle_Qabs: forall q, q <= Qabs q.
Proof.
 intros [|q|q]; simpl; auto. 
Qed.

Lemma Qle_Qabs_Qopp: forall q, -q <= Qabs q.
Proof.
 intros [|q|q]; simpl; auto. 
Qed.

Lemma Qabs_Qle_Qopp: forall q, - (Qabs q) <= q.
Proof.
 intros [|qp|qp]; simpl; auto.
Qed.

Lemma Qabs_triangle: forall p q, Qabs (p + q) <= Qabs p + Qabs q.
Proof.
 intros p q. 
 destruct (Q_le_lt_dec Zero p) as [Hp|Hp]; destruct (Q_le_lt_dec Zero q) as [Hq|Hq].
  repeat rewrite Qabs_eq; auto.

  assert (Hp1:=Qabs_eq _ Hp); assert (Hq1:=Qabs_non_eq_neg _ Hq); rewrite Hp1; rewrite Hq1;
  destruct (Q_le_lt_dec Zero (p+q)) as [Hpq|Hpq].
   rewrite Qabs_eq; trivial; apply Qle_Zero_Qminus_neg; stepl (q+q);[|ring]; auto.
   rewrite Qabs_non_eq_neg; trivial; apply Qle_Zero_Qminus; stepr (p+p);[|ring]; auto.
   
  assert (Hp1:=Qabs_non_eq_neg _ Hp); assert (Hq1:=Qabs_eq _ Hq); rewrite Hp1; rewrite Hq1;
  destruct (Q_le_lt_dec Zero (p+q)) as [Hpq|Hpq].
   rewrite Qabs_eq; trivial; apply Qle_Zero_Qminus_neg; stepl (p+p);[|ring]; auto.
   rewrite Qabs_non_eq_neg; trivial; apply Qle_Zero_Qminus; stepr (q+q);[|ring]; auto.

  repeat rewrite Qabs_non_eq_neg; auto; (stepr (-(p+q)) by ring); trivial.
Qed.
   
Lemma Qabs_Qopp:forall q, Qabs q = Qabs (-q).
Proof.
 intros [|qp|qp]; trivial.
Qed.

Lemma Qabs_Qminus_sym:forall q1 q2, Qabs (q1-q2) = Qabs (q2-q1).
Proof.
 intros q1 q2; rewrite Qabs_Qopp; apply (f_equal Qabs); ring.
Qed.

Lemma Qabs_nonzero_pos:forall q, q<> Zero -> Zero < Qabs q.
Proof.
 intros [|qp|qp] H; simpl; trivial; contradiction H; trivial. 
Qed.

Lemma Qabs_Qminus_Zero_eq:forall q1 q2, Qabs (q1-q2) = Zero -> q1=q2.
Proof.
 intros q1 q2 Hq; destruct (Q_zerop (q1-q2)) as [H|H]; auto; contradiction (Qlt_irreflexive Zero);
 stepr (Qabs (q1 - q2)); trivial; apply Qabs_nonzero_pos; trivial.
Qed.

Lemma Qabs_Zero_Qminus_eq:forall q1 q2, q1=q2 -> Qabs (q1-q2) = Zero.
Proof.
 intros q1 q2 Hq; rewrite Hq; replace (q2-q2) with Zero by ring; reflexivity. 
Qed.

Lemma Qabs_Qminus_bound:forall low up q1 q2, low <= q1 -> q1 <= up -> low <= q2 -> q2 <= up -> Qabs (q1-q2) <= up-low.  
Proof.
 intros l u q1 q2 Hq1l Hq1u Hq2l Hq2u.
 destruct (Q_le_lt_dec q2 q1) as [H|H];
 [ rewrite Qabs_eq;
  [ 
  | apply Qle_Qminus_Zero
  ]
 | rewrite Qabs_non_eq_neg;
   [ stepl (q2-q1);[|ring]
   | apply Qlt_Qminus_Zero_neg
   ]
 ]; trivial; unfold Qminus; apply Qle_plus_plus; try apply Qopp_Qle; trivial.
Qed.

Lemma upper_bound_affine_base_interval_twice:forall a b c d x, -Qone<=x -> x<=Qone -> 
 (a*x+b)*(c*x+d) <= Qabs (a*c) + Qabs (a*d+c*b)+b*d.
Proof.
 intros a b c d x Hxl Hxu.
 assert (Hxx0:=Qmult_mult_nonneg x).
 assert (Hxx1:=Qmult_mult_Qle_Qone_Qopp_Qone _ Hxl Hxu). 
 stepl ((a*c)*(x*x)+(a*d+c*b)*x+b*d); [|ring].
 repeat apply Qle_plus_plus; trivial.
  stepr (Qabs (a*c)*Qone); [|ring];
  apply Qle_trans with (Qabs (a*c)*(x*x));
  [apply Qle_reg_mult_r_strong; trivial; apply Qle_Qabs| apply Qle_reg_mult_l_strong; trivial; apply Qabs_nonneg]...
  apply Qle_trans with (Qabs((a*d+c*b)*x)); [apply Qle_Qabs|];
  rewrite Qabs_Qmult; stepr (Qabs(a*d+c*b)*Qone); [|ring];
  apply Qle_reg_mult_l_strong; [apply Qabs_nonneg|];
  apply Qabs_8; trivial...
Qed.

Lemma lower_bound_affine_base_interval_twice:forall a b c d x, -Qone<=x -> x<=Qone -> 
        -Qabs (a*c) + -Qabs (a*d+c*b)+b*d <= (a*x+b)*(c*x+d).
Proof.
 intros a b c d x Hxl Hxu.
 assert (Hxx0:=Qmult_mult_nonneg x).
 assert (Hxx1:=Qmult_mult_Qle_Qone_Qopp_Qone _ Hxl Hxu). 
 stepr ((a*c)*(x*x)+(a*d+c*b)*x+b*d); [|ring].
 repeat apply Qle_plus_plus; trivial.
  stepl (-Qabs (a*c)*Qone); [|ring];
  apply Qle_trans with (-Qabs (a*c)*(x*x));
  [ apply Qle_opp; 
    repeat rewrite <- Qmult_Qopp_left; apply Qle_reg_mult_l_strong; trivial; rewrite Qopp_involutive; apply Qabs_nonneg
  | apply Qle_reg_mult_r_strong; trivial; apply Qabs_Qle_Qopp
  ]...
  apply Qle_trans with (-Qabs((a*d+c*b)*x)); [|apply Qabs_Qle_Qopp];
  apply Qopp_Qle;
  rewrite Qabs_Qmult; stepr (Qabs(a*d+c*b)*Qone); [|ring];
  apply Qle_reg_mult_l_strong; [apply Qabs_nonneg|];
  apply Qabs_8; trivial...
Qed.
