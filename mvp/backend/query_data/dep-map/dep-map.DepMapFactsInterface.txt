

Require Import Utf8.

Require Import Orders.

Require Import Coqlib.
(* Coqlib:
Definition full_relation {A : Type} : relation A := fun x y : A => True.

Module OTconvert (O : OrderedType) : OrderedType.OrderedType
          with Definition t := O.t
          with Definition eq := O.eq
          with Definition lt := O.lt.
  
  Definition t := O.t.
  Definition eq := O.eq.
  Definition lt := O.lt.
  
  Definition eq_refl : forall x, eq x x := reflexivity.
  Lemma eq_sym : forall x y : t, eq x y -> eq y x.
  Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.

  Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.
  Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.

  Lemma compare : forall x y : t, OrderedType.Compare lt eq x y.
  
  Definition eq_dec := O.eq_dec.
End OTconvert. *)

Require Import DepMapInterface.
(* DepMapInterface:
Require Import Utf8.
Require Import MSets.
Require Import Coqlib.

Set Implicit Arguments.

Module Type DepMap (X : OrderedType).

Declare Module Dom : MSetInterface.SetsOn(X) with Definition elt := X.t.

Definition key := X.t.
Parameter t : forall (A : Type) (dom : Dom.t), Type.

Parameter empty : forall {A}, t A Dom.empty.

Parameter is_empty : forall {A} {dom}, t A dom -> bool.

Parameter mem : forall {A} {dom}, key -> t A dom -> bool.

Parameter find : forall {A} {dom}, key -> t A dom -> option A.

Parameter domain : forall {A} {dom}, t A dom -> Dom.t.

Parameter add : forall {A} {dom} (x : key) (v : A) (m : t A dom), t A (Dom.add x dom).

Parameter set : forall {A} {dom} (x : key) (v : A) (m : t A dom), Dom.In x dom -> t A dom.

Parameter remove : forall {A} {dom} x (m : t A dom), t A (Dom.remove x dom).

Parameter singleton : forall {A} (x : key), A -> t A (Dom.singleton x).

Parameter constant : forall {A} dom, A -> t A dom.

Parameter fold : forall {A B : Type}, (key -> A -> B -> B) -> forall {dom}, t A dom -> B -> B.

Parameter map : forall A B, (A -> B) -> forall dom, t A dom -> t B dom.

Parameter combine : forall A B C, (A -> B -> C) -> (A -> C) -> (B -> C) ->
  forall dom₁ dom₂, t A dom₁ -> t B dom₂ -> t C (Dom.union dom₁ dom₂).

Parameter cast : forall {A} {dom₁} {dom₂}, Dom.eq dom₁ dom₂ -> t A dom₁ -> t A dom₂.

Parameter elements : forall {A} {dom}, t A dom -> list (key * A).

Parameter from_elements : forall {A} (l : list (key * A)),
  t A (List.fold_left (fun acc xv => Dom.add (fst xv) acc) l Dom.empty).

Parameter empty_spec : forall A x, find x (@empty A) = None.

Parameter is_empty_spec : forall A dom (m : t A dom), is_empty m = true <-> forall x, find x m = None.

Parameter mem_spec : forall A x dom (m : t A dom), mem x m = true <-> exists v, find x m = Some v.

Declare Instance find_elt_compat A dom (m : t A dom) : Proper (X.eq ==> Logic.eq) (fun x => find x m).
Parameter find_spec : forall A x dom (m : t A dom), (exists v, find x m = Some v) <-> Dom.In x dom.

Parameter domain_spec : forall A dom (m : t A dom), domain m = dom.

Parameter set_same : forall A x v dom (m : t A dom) Hin, find x (@set A dom x v m Hin) = Some v.
Parameter set_other : forall A x y v dom (m : t A dom) Hin, ¬X.eq y x -> find y (@set A dom x v m Hin) = find y m.

Parameter add_same : forall A x v dom (m : t A dom), find x (add x v m) = Some v.
Parameter add_other : forall A x y v dom (m : t A dom), ¬X.eq y x -> find y (add x v m) = find y m.

Parameter singleton_same : forall A x (v : A), find x (singleton x v) = Some v.
Parameter singleton_other : forall A x y (v : A), ¬X.eq y x -> find y (singleton x v) = None.

Parameter remove_same : forall A x dom (m : t A dom), find x (remove x m) = None.
Parameter remove_other : forall A x y dom (m : t A dom), ¬X.eq y x -> find y (remove x m) = find y m.

Parameter constant_Some : forall A dom (v : A) x u, find x (constant dom v) = Some u <-> Dom.In x dom ∧ u = v.
Parameter constant_None : forall A dom (v : A) x, find x (constant dom v) = None <-> ¬Dom.In x dom.

Parameter fold_spec : forall A B (f : key -> A -> B -> B) dom (m : t A dom) (i : B),
  fold f m i = List.fold_left (fun acc xv => f (fst xv) (snd xv) acc) (elements m) i.

Parameter map_spec : forall A B (f : A -> B) dom (m : t A dom) x v,
  find x (map f m) = Some v <-> exists u, find x m = Some u ∧ f u = v.

Parameter combine_spec : forall A B C (f : A -> B -> C) g₁ g₂ dom₁ dom₂ (m₁ : t A dom₁) (m₂ : t B dom₂) x v,
  find x (combine f g₁ g₂ m₁ m₂) = Some v <->
  (exists v₁ v₂, find x m₁ = Some v₁ ∧ find x m₂ = Some v₂ ∧ v = f v₁ v₂)
  ∨ (exists v₁, find x m₁ = Some v₁ ∧ find x m₂ = None ∧ v = g₁ v₁)
  ∨ (exists v₂, find x m₁ = None ∧ find x m₂ = Some v₂ ∧ v = g₂ v₂).

Parameter cast_spec_find : forall A dom₁ dom₂ (Heq : Dom.eq dom₁ dom₂) (m : t A dom₁) x,
  find x (cast Heq m) = find x m.

Parameter elements_spec : forall A dom (m : t A dom) xv,
  InA (X.eq * eq)%signature xv (elements m) <-> find (fst xv) m = Some (snd xv).

Parameter elements_Sorted : forall A dom (m : t A dom), Sorted (X.lt@@1)%signature (elements m).

Parameter from_elements_spec : forall A (l : list (key * A)), NoDupA (X.eq@@1)%signature l ->
  forall x v, find x (from_elements l) = Some v <-> InA (X.eq * eq)%signature (x, v) l.

End DepMap. *)



Set Implicit Arguments.



Module Type DepMapFacts (X : OrderedType).



Include DepMap(X).



Definition eq {A : Type} {dom₁ dom₂} (m₁ : t A dom₁) (m₂ : t A dom₂) := forall x, find x m₁ = find x m₂.

Definition incl {A : Type} {dom₁ dom₂} (m₁ : t A dom₁) (m₂ : t A dom₂) :=

  forall x v, find x m₁ = Some v -> find x m₂ = Some v.



Declare Instance eq_refl : forall A dom, Reflexive (@eq A dom dom).

Parameter eq_sym : forall A dom₁ dom₂ (m₁ : t A dom₁) (m₂ : t A dom₂), eq m₁ m₂ -> eq m₂ m₁.

Parameter eq_trans : forall A dom₁ dom₂ dom3 (m₁ : t A dom₁) (m₂ : t A dom₂) (m3 : t A dom3),

  eq m₁ m₂ -> eq m₂ m3 -> eq m₁ m3.

Declare Instance eq_equiv : forall A dom, Equivalence (@eq A dom dom).



Declare Instance incl_refl : forall A dom (m : t A dom), Reflexive (@incl A dom dom).

Parameter incl_trans : forall A dom₁ dom₂ dom3 (m₁ : t A dom₁) (m₂ : t A dom₂) (m3 : t A dom3),

  incl m₁ m₂ -> incl m₂ m3 -> incl m₁ m3.

Declare Instance incl_preorder : forall A dom, PreOrder (@incl A dom dom).

Declare Instance eq_incl_compat : forall A dom, PartialOrder (@eq A dom dom) (@incl A dom dom).



Declare Instance mem_compat (A : Type) dom : Proper (X.eq ==> @eq A dom dom ==> Logic.eq) (@mem A dom).

Parameter find_compat : forall A x y dom₁ dom₂ (m₁ : t A dom₁) (m₂ : t A dom₂),

  X.eq x y -> eq m₁ m₂ -> find x m₁ = find y m₂.

Declare Instance find_compat2 (A : Type) dom : Proper (X.eq ==> @eq A dom dom ==> Logic.eq) (@find A dom).



Arguments set {A} {dom} x v m _.

Parameter set_compat :

  forall A x y v dom₁ dom₂ (m₁ : t A dom₁) (m₂ : t A dom₂) (Hin₁ : Dom.In x dom₁) (Hin₂ : Dom.In y dom₂),

  X.eq x y -> eq m₁ m₂ -> eq (set x v m₁ Hin₁) (set y v m₂ Hin₂).

Declare Instance set_compat2 (A : Type) x dom :

  Proper (Logic.eq ==> @eq A dom dom ==> full_relation ==> @eq A dom dom) (@set A dom x).



Parameter add_compat : forall A x y v dom₁ dom₂ (m₁ : t A dom₁) (m₂ : t A dom₂),

  X.eq x y -> eq m₁ m₂ -> eq (add x v m₁) (add y v m₂).

Declare Instance add_compat2 (A : Type) x dom :

  Proper (Logic.eq ==> @eq A dom dom ==> @eq A (Dom.add x dom) (Dom.add x dom)) (@add A dom x).



Parameter remove_compat : forall A x y dom₁ dom₂ (m₁ : t A dom₁) (m₂ : t A dom₂),

  X.eq x y -> eq m₁ m₂ -> eq (remove x m₁) (remove y m₂).

Declare Instance remove_compat2 (A : Type) x dom :

  Proper (@eq A dom dom ==> @eq A (Dom.remove x dom) (Dom.remove x dom)) (@remove A dom x).



Parameter find_None : forall A dom x (m : t A dom), find x m = None <-> ¬Dom.In x dom.

Parameter find_dom : forall A x v dom (m : t A dom), find x m = Some v -> Dom.In x dom.



Parameter set_Some : forall A x y v u dom (m : t A dom) (Hin : Dom.In x dom),

  find y (set x v m Hin) = Some u <-> X.eq y x ∧ u = v ∨ ¬X.eq y x ∧ find y m = Some u.

Parameter set_None : forall A x y v dom (m : t A dom) (Hin : Dom.In x dom),

  find y (set x v m Hin) = None <-> ¬X.eq y x ∧ find y m = None.



Parameter add_Some : forall A x y v u dom (m : t A dom),

  find y (add x v m) = Some u <-> X.eq y x ∧ u = v ∨ ¬X.eq y x ∧ find y m = Some u.

Parameter add_None : forall A x y v dom (m : t A dom),

  find y (add x v m) = None <-> ¬X.eq y x ∧ find y m = None.



Parameter remove_Some : forall A x y u dom (m : t A dom),

  find y (remove x m) = Some u <-> ¬X.eq y x ∧ find y m = Some u.

Parameter remove_None : forall A x y dom (m : t A dom),

  find y (remove x m) = None <-> X.eq y x ∨ find y m = None.



Parameter add_cancel : forall A x v dom (m : t A dom), find x m = Some v -> eq (add x v m) m.

Parameter remove_cancel : forall A x dom (m : t A dom), find x m = None -> eq (remove x m) m.



Parameter add_merge : forall A x v₁ v₂ dom (m : t A dom), eq (add x v₂ (add x v₁ m)) (add x v₂ m).

Parameter add_comm : forall A x y v₁ v₂ dom (m : t A dom),

  ¬X.eq x y -> eq (add y v₂ (add x v₁ m)) (add x v₁ (add y v₂ m)).



Parameter remove_add_cancel : forall A s v dom (m : t A dom), eq (remove s (add s v m)) (remove s m).



Parameter map_None : forall A B (f : A -> B) dom (m : t A dom) x, find x (map f m) = None <-> ¬Dom.In x dom.



Parameter combine_None : forall A B C (f : A -> B -> C) g₁ g₂ dom₁ dom₂ (m₁ : t A dom₁) (m₂ : t B dom₂) x,

  find x (combine f g₁ g₂ m₁ m₂) = None <-> find x m₁ = None ∧ find x m₂ = None.



Parameter add_incl : forall A x v dom (m : t A dom), ¬Dom.In x dom -> incl m (add x v m).

Parameter remove_incl : forall A x dom (m : t A dom), incl (remove x m) m.



Parameter cast_spec : forall A dom₁ dom₂ (Heq : Dom.eq dom₁ dom₂) (m : t A dom₁), eq (cast Heq m) m.



Parameter eq_dom : forall A dom₁ dom₂ (m₁ : t A dom₁) (m₂ : t A dom₂), eq m₁ m₂ -> Dom.eq dom₁ dom₂.



Parameter for_all : forall {A}, (key -> A -> bool) -> forall {dom}, t A dom -> bool.



Parameter for_all_spec : forall A f, Proper (X.eq ==> Logic.eq ==> Logic.eq) f -> forall dom (m : t A dom),

  for_all f m = true <-> forall x v, find x m = Some v -> f x v = true.



Parameter exists_ : forall {A}, (key -> A -> bool) -> forall {dom}, t A dom -> bool.



Parameter exists_spec : forall A f, Proper (X.eq ==> Logic.eq ==> Logic.eq) f -> forall dom (m : t A dom),

  exists_ f m = true <-> exists x v, find x m = Some v ∧ f x v = true.



End DepMapFacts.

