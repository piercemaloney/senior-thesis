
Require Import Orders.

Require Export DepMapInterface.
(* DepMapInterface:
Require Import Utf8.
Require Import MSets.
Require Import Coqlib.

Set Implicit Arguments.

Module Type DepMap (X : OrderedType).

Declare Module Dom : MSetInterface.SetsOn(X) with Definition elt := X.t.

Definition key := X.t.
Parameter t : forall (A : Type) (dom : Dom.t), Type.

Parameter empty : forall {A}, t A Dom.empty.

Parameter is_empty : forall {A} {dom}, t A dom -> bool.

Parameter mem : forall {A} {dom}, key -> t A dom -> bool.

Parameter find : forall {A} {dom}, key -> t A dom -> option A.

Parameter domain : forall {A} {dom}, t A dom -> Dom.t.

Parameter add : forall {A} {dom} (x : key) (v : A) (m : t A dom), t A (Dom.add x dom).

Parameter set : forall {A} {dom} (x : key) (v : A) (m : t A dom), Dom.In x dom -> t A dom.

Parameter remove : forall {A} {dom} x (m : t A dom), t A (Dom.remove x dom).

Parameter singleton : forall {A} (x : key), A -> t A (Dom.singleton x).

Parameter constant : forall {A} dom, A -> t A dom.

Parameter fold : forall {A B : Type}, (key -> A -> B -> B) -> forall {dom}, t A dom -> B -> B.

Parameter map : forall A B, (A -> B) -> forall dom, t A dom -> t B dom.

Parameter combine : forall A B C, (A -> B -> C) -> (A -> C) -> (B -> C) ->
  forall dom₁ dom₂, t A dom₁ -> t B dom₂ -> t C (Dom.union dom₁ dom₂).

Parameter cast : forall {A} {dom₁} {dom₂}, Dom.eq dom₁ dom₂ -> t A dom₁ -> t A dom₂.

Parameter elements : forall {A} {dom}, t A dom -> list (key * A).

Parameter from_elements : forall {A} (l : list (key * A)),
  t A (List.fold_left (fun acc xv => Dom.add (fst xv) acc) l Dom.empty).

Parameter empty_spec : forall A x, find x (@empty A) = None.

Parameter is_empty_spec : forall A dom (m : t A dom), is_empty m = true <-> forall x, find x m = None.

Parameter mem_spec : forall A x dom (m : t A dom), mem x m = true <-> exists v, find x m = Some v.

Declare Instance find_elt_compat A dom (m : t A dom) : Proper (X.eq ==> Logic.eq) (fun x => find x m).
Parameter find_spec : forall A x dom (m : t A dom), (exists v, find x m = Some v) <-> Dom.In x dom.

Parameter domain_spec : forall A dom (m : t A dom), domain m = dom.

Parameter set_same : forall A x v dom (m : t A dom) Hin, find x (@set A dom x v m Hin) = Some v.
Parameter set_other : forall A x y v dom (m : t A dom) Hin, ¬X.eq y x -> find y (@set A dom x v m Hin) = find y m.

Parameter add_same : forall A x v dom (m : t A dom), find x (add x v m) = Some v.
Parameter add_other : forall A x y v dom (m : t A dom), ¬X.eq y x -> find y (add x v m) = find y m.

Parameter singleton_same : forall A x (v : A), find x (singleton x v) = Some v.
Parameter singleton_other : forall A x y (v : A), ¬X.eq y x -> find y (singleton x v) = None.

Parameter remove_same : forall A x dom (m : t A dom), find x (remove x m) = None.
Parameter remove_other : forall A x y dom (m : t A dom), ¬X.eq y x -> find y (remove x m) = find y m.

Parameter constant_Some : forall A dom (v : A) x u, find x (constant dom v) = Some u <-> Dom.In x dom ∧ u = v.
Parameter constant_None : forall A dom (v : A) x, find x (constant dom v) = None <-> ¬Dom.In x dom.

Parameter fold_spec : forall A B (f : key -> A -> B -> B) dom (m : t A dom) (i : B),
  fold f m i = List.fold_left (fun acc xv => f (fst xv) (snd xv) acc) (elements m) i.

Parameter map_spec : forall A B (f : A -> B) dom (m : t A dom) x v,
  find x (map f m) = Some v <-> exists u, find x m = Some u ∧ f u = v.

Parameter combine_spec : forall A B C (f : A -> B -> C) g₁ g₂ dom₁ dom₂ (m₁ : t A dom₁) (m₂ : t B dom₂) x v,
  find x (combine f g₁ g₂ m₁ m₂) = Some v <->
  (exists v₁ v₂, find x m₁ = Some v₁ ∧ find x m₂ = Some v₂ ∧ v = f v₁ v₂)
  ∨ (exists v₁, find x m₁ = Some v₁ ∧ find x m₂ = None ∧ v = g₁ v₁)
  ∨ (exists v₂, find x m₁ = None ∧ find x m₂ = Some v₂ ∧ v = g₂ v₂).

Parameter cast_spec_find : forall A dom₁ dom₂ (Heq : Dom.eq dom₁ dom₂) (m : t A dom₁) x,
  find x (cast Heq m) = find x m.

Parameter elements_spec : forall A dom (m : t A dom) xv,
  InA (X.eq * eq)%signature xv (elements m) <-> find (fst xv) m = Some (snd xv).

Parameter elements_Sorted : forall A dom (m : t A dom), Sorted (X.lt@@1)%signature (elements m).

Parameter from_elements_spec : forall A (l : list (key * A)), NoDupA (X.eq@@1)%signature l ->
  forall x v, find x (from_elements l) = Some v <-> InA (X.eq * eq)%signature (x, v) l.

End DepMap. *)
Require Export DepMapFactsInterface.
(* DepMapFactsInterface:
Require Import Utf8.
Require Import Orders.
Require Import Coqlib.
Require Import DepMapInterface.

Set Implicit Arguments.

Module Type DepMapFacts (X : OrderedType).

Include DepMap(X).

Definition eq {A : Type} {dom₁ dom₂} (m₁ : t A dom₁) (m₂ : t A dom₂) := forall x, find x m₁ = find x m₂.
Definition incl {A : Type} {dom₁ dom₂} (m₁ : t A dom₁) (m₂ : t A dom₂) :=
  forall x v, find x m₁ = Some v -> find x m₂ = Some v.

Declare Instance eq_refl : forall A dom, Reflexive (@eq A dom dom).
Parameter eq_sym : forall A dom₁ dom₂ (m₁ : t A dom₁) (m₂ : t A dom₂), eq m₁ m₂ -> eq m₂ m₁.
Parameter eq_trans : forall A dom₁ dom₂ dom3 (m₁ : t A dom₁) (m₂ : t A dom₂) (m3 : t A dom3),
  eq m₁ m₂ -> eq m₂ m3 -> eq m₁ m3.
Declare Instance eq_equiv : forall A dom, Equivalence (@eq A dom dom).

Declare Instance incl_refl : forall A dom (m : t A dom), Reflexive (@incl A dom dom).
Parameter incl_trans : forall A dom₁ dom₂ dom3 (m₁ : t A dom₁) (m₂ : t A dom₂) (m3 : t A dom3),
  incl m₁ m₂ -> incl m₂ m3 -> incl m₁ m3.
Declare Instance incl_preorder : forall A dom, PreOrder (@incl A dom dom).
Declare Instance eq_incl_compat : forall A dom, PartialOrder (@eq A dom dom) (@incl A dom dom).

Declare Instance mem_compat (A : Type) dom : Proper (X.eq ==> @eq A dom dom ==> Logic.eq) (@mem A dom).
Parameter find_compat : forall A x y dom₁ dom₂ (m₁ : t A dom₁) (m₂ : t A dom₂),
  X.eq x y -> eq m₁ m₂ -> find x m₁ = find y m₂.
Declare Instance find_compat2 (A : Type) dom : Proper (X.eq ==> @eq A dom dom ==> Logic.eq) (@find A dom).

Arguments set {A} {dom} x v m _.
Parameter set_compat :
  forall A x y v dom₁ dom₂ (m₁ : t A dom₁) (m₂ : t A dom₂) (Hin₁ : Dom.In x dom₁) (Hin₂ : Dom.In y dom₂),
  X.eq x y -> eq m₁ m₂ -> eq (set x v m₁ Hin₁) (set y v m₂ Hin₂).
Declare Instance set_compat2 (A : Type) x dom :
  Proper (Logic.eq ==> @eq A dom dom ==> full_relation ==> @eq A dom dom) (@set A dom x).

Parameter add_compat : forall A x y v dom₁ dom₂ (m₁ : t A dom₁) (m₂ : t A dom₂),
  X.eq x y -> eq m₁ m₂ -> eq (add x v m₁) (add y v m₂).
Declare Instance add_compat2 (A : Type) x dom :
  Proper (Logic.eq ==> @eq A dom dom ==> @eq A (Dom.add x dom) (Dom.add x dom)) (@add A dom x).

Parameter remove_compat : forall A x y dom₁ dom₂ (m₁ : t A dom₁) (m₂ : t A dom₂),
  X.eq x y -> eq m₁ m₂ -> eq (remove x m₁) (remove y m₂).
Declare Instance remove_compat2 (A : Type) x dom :
  Proper (@eq A dom dom ==> @eq A (Dom.remove x dom) (Dom.remove x dom)) (@remove A dom x).

Parameter find_None : forall A dom x (m : t A dom), find x m = None <-> ¬Dom.In x dom.
Parameter find_dom : forall A x v dom (m : t A dom), find x m = Some v -> Dom.In x dom.

Parameter set_Some : forall A x y v u dom (m : t A dom) (Hin : Dom.In x dom),
  find y (set x v m Hin) = Some u <-> X.eq y x ∧ u = v ∨ ¬X.eq y x ∧ find y m = Some u.
Parameter set_None : forall A x y v dom (m : t A dom) (Hin : Dom.In x dom),
  find y (set x v m Hin) = None <-> ¬X.eq y x ∧ find y m = None.

Parameter add_Some : forall A x y v u dom (m : t A dom),
  find y (add x v m) = Some u <-> X.eq y x ∧ u = v ∨ ¬X.eq y x ∧ find y m = Some u.
Parameter add_None : forall A x y v dom (m : t A dom),
  find y (add x v m) = None <-> ¬X.eq y x ∧ find y m = None.

Parameter remove_Some : forall A x y u dom (m : t A dom),
  find y (remove x m) = Some u <-> ¬X.eq y x ∧ find y m = Some u.
Parameter remove_None : forall A x y dom (m : t A dom),
  find y (remove x m) = None <-> X.eq y x ∨ find y m = None.

Parameter add_cancel : forall A x v dom (m : t A dom), find x m = Some v -> eq (add x v m) m.
Parameter remove_cancel : forall A x dom (m : t A dom), find x m = None -> eq (remove x m) m.

Parameter add_merge : forall A x v₁ v₂ dom (m : t A dom), eq (add x v₂ (add x v₁ m)) (add x v₂ m).
Parameter add_comm : forall A x y v₁ v₂ dom (m : t A dom),
  ¬X.eq x y -> eq (add y v₂ (add x v₁ m)) (add x v₁ (add y v₂ m)).

Parameter remove_add_cancel : forall A s v dom (m : t A dom), eq (remove s (add s v m)) (remove s m).

Parameter map_None : forall A B (f : A -> B) dom (m : t A dom) x, find x (map f m) = None <-> ¬Dom.In x dom.

Parameter combine_None : forall A B C (f : A -> B -> C) g₁ g₂ dom₁ dom₂ (m₁ : t A dom₁) (m₂ : t B dom₂) x,
  find x (combine f g₁ g₂ m₁ m₂) = None <-> find x m₁ = None ∧ find x m₂ = None.

Parameter add_incl : forall A x v dom (m : t A dom), ¬Dom.In x dom -> incl m (add x v m).
Parameter remove_incl : forall A x dom (m : t A dom), incl (remove x m) m.

Parameter cast_spec : forall A dom₁ dom₂ (Heq : Dom.eq dom₁ dom₂) (m : t A dom₁), eq (cast Heq m) m.

Parameter eq_dom : forall A dom₁ dom₂ (m₁ : t A dom₁) (m₂ : t A dom₂), eq m₁ m₂ -> Dom.eq dom₁ dom₂.

Parameter for_all : forall {A}, (key -> A -> bool) -> forall {dom}, t A dom -> bool.

Parameter for_all_spec : forall A f, Proper (X.eq ==> Logic.eq ==> Logic.eq) f -> forall dom (m : t A dom),
  for_all f m = true <-> forall x v, find x m = Some v -> f x v = true.

Parameter exists_ : forall {A}, (key -> A -> bool) -> forall {dom}, t A dom -> bool.

Parameter exists_spec : forall A f, Proper (X.eq ==> Logic.eq ==> Logic.eq) f -> forall dom (m : t A dom),
  exists_ f m = true <-> exists x v, find x m = Some v ∧ f x v = true.

End DepMapFacts. *)

Require Export DepMapImplementation.
(* DepMapImplementation:
Require Import Utf8.
Require Import MSets.
Require Import FMaps.
Require Import Orders.
Require Import Coqlib.
Require Import DepMapInterface.

Set Implicit Arguments.

Module DepMapImpl (X : OrderedType) : (DepMap X) with Definition key := X.t.

Module Dom := MSetAVL.Make(X).
Module Ddec := Decide(Dom).
Module DProp := EqProperties(Dom).
Ltac fsetdec := Ddec.fsetdec.

Module XOT := OTconvert X.
Module S := FMapList.Make(XOT).

Definition key := X.t.
Definition OK {A} dom (map : S.t A) := ∀ x, S.In x map <-> Dom.In x dom.
Definition t := fun A dom => { map : S.t A | OK dom map}.

Lemma empty_OK : forall A, OK Dom.empty (S.empty A).

Definition empty : forall A, t A Dom.empty := fun A => exist (OK Dom.empty) (@S.empty A) (empty_OK A).

Definition is_empty (A : Type) dom (m : t A dom) := Dom.equal dom Dom.empty.

Definition mem (A : Type) dom (x : key) (m : t A dom) := Dom.mem x dom.

Definition find (A : Type) dom (x : key) (m : t A dom) := S.find x (proj1_sig m).

Definition domain (A : Type) dom (m : t A dom) := dom.

Lemma add_OK : forall A dom x v (m : t A dom), OK (Dom.add x dom) (S.add x v (proj1_sig m)).

Definition add {A : Type} {dom : Dom.t} (x : key) (v : A) (m : @t A dom) : @t A (Dom.add x dom) :=
  exist (OK (Dom.add x dom)) (S.add x v (proj1_sig m)) (add_OK x v m).

Lemma set_OK : forall A dom x v (m : t A dom), Dom.In x dom -> OK dom (S.add x v (proj1_sig m)).

Definition set {A : Type} {dom : Dom.t} (x : key) (v : A) (m : @t A dom) (Hin : Dom.In x dom) :=
  exist (OK dom) (S.add x v (proj1_sig m)) (@set_OK _ _ x v m Hin).
Arguments set {A} {dom} x v m _.

Lemma singleton_OK : forall A x v, OK (Dom.singleton x) (S.add x v (S.empty A)).

Definition singleton {A : Type} (x : key) (v : A) : t A (Dom.singleton x) :=
  exist (OK (Dom.singleton x)) (S.add x v (@S.empty A)) (singleton_OK x v).

Lemma remove_OK : forall A dom x (m : t A dom), OK (Dom.remove x dom) (S.remove (elt:=A) x (proj1_sig m)).

Definition remove {A : Type} {dom : Dom.t} (x : key) (m : @t A dom) : @t A (Dom.remove x dom) :=
  exist (OK (Dom.remove x dom)) (S.remove x (proj1_sig m)) (remove_OK x m).

Lemma constant_OK_aux : forall A v (m : S.t A) l x,

Corollary constant_OK : forall A dom v, OK dom (Dom.fold (fun x m => S.add x v m) dom (S.empty A)).

Definition constant (A : Type) dom (v : A) : t A dom :=
  exist (OK dom) (Dom.fold (fun x m => S.add x v m) dom (@S.empty A)) (constant_OK dom v).

Definition fold {A B : Type} (f : key -> A -> B -> B) dom (m : t A dom) (i : B) : B := S.fold f (proj1_sig m) i.

Lemma map_OK : forall A B (f : A -> B) dom (m : t A dom), OK dom (S.map f (proj1_sig m)).

Definition map {A B : Type} (f : A -> B) dom (m : t A dom) : t B dom :=
  exist (OK dom) (S.map f (proj1_sig m)) (map_OK f m).

Definition Scombine {A B C : Type} (f : A -> B -> C) (g : A -> C) (h : B -> C) (m₁ : S.t A) (m₂ : S.t B) : S.t C :=
  Dom.fold (fun x acc => match S.find x m₁, S.find x m₂ with
                           | Some v₁, Some v₂ => S.add x (f v₁ v₂) acc
                           | Some v, None => S.add x (g v) acc
                           | None, Some v => S.add x (h v) acc
                           | None, None => acc
                         end)
           (Dom.union (S.fold (fun x _ acc => Dom.add x acc) m₁ Dom.empty)
                      (S.fold (fun x _ acc => Dom.add x acc) m₂ Dom.empty)) (S.empty C).

Lemma Sdom_aux : forall A x (m : S.t A) s,

Corollary Sdom : forall A x (m : S.t A), Dom.In x (S.fold (fun x _ acc => Dom.add x acc) m Dom.empty) <-> S.In x m.

Lemma Sfind_compat : forall {A x y} {m : S.t A}, X.eq x y -> S.find x m = S.find y m.

Lemma Scombine_spec_aux : forall A B C (f : A -> B -> C) g h x v m₁ m₂ l m, NoDupA X.eq l ->

Theorem Scombine_spec : forall A B C (f : A -> B -> C) g h x v m₁ m₂,
  S.find x (Scombine f g h m₁ m₂) = Some v <->

Lemma combine_OK : forall A B C (f : A -> B -> C) g₁ g₂ dom₁ dom₂ (m₁ : t A dom₁) (m₂ : t B dom₂),
  OK (Dom.union dom₁ dom₂) (Scombine f g₁ g₂ (proj1_sig m₁) (proj1_sig m₂)).

Definition combine A B C f g₁ g₂ dom₁ dom₂ (m₁ : t A dom₁) (m₂ : t B dom₂) : t C (Dom.union dom₁ dom₂) :=
  exist (OK (Dom.union dom₁ dom₂)) (Scombine f g₁ g₂ (proj1_sig m₁) (proj1_sig m₂)) (combine_OK f g₁ g₂ m₁ m₂).

Lemma cast_OK : forall A dom₁ dom₂ (Heq : Dom.eq dom₁ dom₂) (m : S.t A), OK dom₁ m -> OK dom₂ m.

Definition cast {A : Type} dom₁ dom₂ (Heq : Dom.eq dom₁ dom₂) (m : t A dom₁) : t A dom₂ :=
  exist (OK dom₂) (proj1_sig m) (cast_OK Heq (proj2_sig m)).

Definition elements A dom (m : t A dom) := S.elements (proj1_sig m).

Lemma pre_from_elements_OK : forall A l dom (m : t A dom), 
  OK (fold_left (fun acc xv => Dom.add (fst xv) acc) l (domain m))

Corollary from_elements_OK : forall A l,
  OK (fold_left (fun acc xv => Dom.add (fst xv) acc) l Dom.empty)

Definition from_elements A (l : list (key * A))
  : t A (List.fold_left (fun acc xv => Dom.add (fst xv) acc) l Dom.empty) :=
  exist (OK (List.fold_left (fun acc xv => Dom.add (fst xv) acc) l Dom.empty))
        (List.fold_left (fun acc xv => S.add (fst xv) (snd xv) acc) l (@S.empty A))
        (from_elements_OK l).

Lemma empty_spec : forall A x, find x (@empty A) = None.

Lemma is_empty_spec : forall A dom (m : t A dom), is_empty m = true <-> forall x, find x m = None.

Lemma mem_spec : forall A x dom (m : t A dom), mem x m = true <-> exists v, find x m = Some v.

Lemma find_spec : forall A x dom (m : t A dom), (exists v, find x m = Some v) <-> Dom.In x dom.

Lemma domain_spec : forall A dom (m : t A dom), domain m = dom.

Lemma set_same : forall A x v dom (m : t A dom) Hin, find x (@set A dom x v m Hin) = Some v.

Lemma set_other : forall A x y v dom (m : t A dom) Hin, ¬X.eq y x -> find y (@set A dom x v m Hin) = find y m.

Lemma add_same : forall A x v dom (m : t A dom), find x (add x v m) = Some v.

Lemma add_other : forall A x y v dom (m : t A dom), ¬X.eq y x -> find y (add x v m) = find y m.

Lemma singleton_same : forall A x (v : A), find x (singleton x v) = Some v.

Lemma singleton_other : forall A x y (v : A), ¬X.eq y x -> find y (singleton x v) = None.

Lemma remove_same : forall A x dom (m : t A dom), find x (remove x m) = None.

Lemma remove_other : forall A x y dom (m : t A dom), ¬X.eq y x -> find y (remove x m) = find y m.

Lemma constant_aux : forall A v x u l (m : S.t A), NoDupA X.eq l ->

Lemma constant_Some : forall A dom (v : A) x u, find x (constant dom v) = Some u <-> Dom.In x dom ∧ u = v.

Lemma constant_None : forall A dom (v : A) x, find x (constant dom v) = None <-> ¬Dom.In x dom.

Lemma map_spec : forall A B (f : A -> B) dom (m : t A dom) x v,
  find x (map f m) = Some v <-> exists u, find x m = Some u ∧ f u = v.

Lemma combine_spec : forall A B C (f : A -> B -> C) g₁ g₂ dom₁ dom₂ (m₁ : t A dom₁) (m₂ : t B dom₂) x v,
  find x (combine f g₁ g₂ m₁ m₂) = Some v <->
  (exists v₁ v₂, find x m₁ = Some v₁ ∧ find x m₂ = Some v₂ ∧ v = f v₁ v₂)
  ∨ (exists v₁, find x m₁ = Some v₁ ∧ find x m₂ = None ∧ v = g₁ v₁)
  ∨ (exists v₂, find x m₁ = None ∧ find x m₂ = Some v₂ ∧ v = g₂ v₂).

Lemma cast_spec_find : forall A dom₁ dom₂ (Heq : Dom.eq dom₁ dom₂) (m : t A dom₁) x, find x (cast Heq m) = find x m.

Lemma elements_spec : forall A dom (m : t A dom) xv,
  InA (X.eq * eq)%signature xv (elements m) <-> find (fst xv) m = Some (snd xv).

Lemma elements_Sorted : forall A dom (m : t A dom), Sorted (X.lt@@1)%signature (elements m).

Lemma pre_from_elements_spec : forall A l (m : S.t A), NoDupA (X.eq@@1)%signature l ->

Lemma from_elements_spec : forall A (l : list (key * A)), NoDupA (X.eq@@1)%signature l ->

Lemma fold_spec : forall A B (f : key -> A -> B -> B) dom (m : t A dom) (i : B),
  fold f m i = List.fold_left (fun acc xv => f (fst xv) (snd xv) acc) (elements m) i.

End DepMapImpl. *)
Require Export DepMapFactsImplementation.
(* DepMapFactsImplementation:
Require Import Utf8.
Require Import Bool.
Require Import SetoidList.
Require Import RelationPairs.
Require Import Orders.
Require Import Coqlib.
Require Import DepMapInterface.
Require Import DepMapFactsInterface.

Set Implicit Arguments.

Module DepMapFactsOn (X : OrderedType) (S : DepMap X) : DepMapFacts(X) with Definition key := X.t.

Include S.

Definition eq {A : Type} dom₁ dom₂ (m₁ : t A dom₁) (m₂ : t A dom₂) := forall x, find x m₁ = find x m₂.

Lemma eq_sym : forall A dom₁ dom₂ (m₁ : t A dom₁) (m₂ : t A dom₂), eq m₁ m₂ -> eq m₂ m₁.

Lemma eq_trans : forall A dom₁ dom₂ dom3 (m₁ : t A dom₁) (m₂ : t A dom₂) (m3 : t A dom3),
  eq m₁ m₂ -> eq m₂ m3 -> eq m₁ m3.

Definition incl {A : Type} dom₁ dom₂ (m₁ : t A dom₁) (m₂ : t A dom₂) :=
  forall x v, find x m₁ = Some v -> find x m₂ = Some v.

Lemma incl_trans : forall A dom₁ dom₂ dom3 (m₁ : t A dom₁) (m₂ : t A dom₂) (m3 : t A dom3),
  incl m₁ m₂ -> incl m₂ m3 -> incl m₁ m3.

Theorem find_compat : forall A x y dom₁ dom₂ (m₁ : t A dom₁) (m₂ : t A dom₂),
  X.eq x y -> eq m₁ m₂ -> find x m₁ = find y m₂.

Arguments set {A} {dom} x v m _.
Theorem set_compat :
  forall A x y v dom₁ dom₂ (m₁ : t A dom₁) (m₂ : t A dom₂) (Hin₁ : Dom.In x dom₁) (Hin₂ : Dom.In y dom₂),

Theorem add_compat : forall A x y v dom₁ dom₂ (m₁ : t A dom₁) (m₂ : t A dom₂),
  X.eq x y -> eq m₁ m₂ -> eq (add x v m₁) (add y v m₂).

Theorem remove_compat : forall A x y dom₁ dom₂ (m₁ : t A dom₁) (m₂ : t A dom₂),
  X.eq x y -> eq m₁ m₂ -> eq (remove x m₁) (remove y m₂).

Theorem find_None : forall A dom x (m : t A dom), find x m = None <-> ¬Dom.In x dom.

Corollary find_dom : forall A x v dom (m : t A dom), find x m = Some v -> Dom.In x dom.

Theorem set_Some : forall A x y v u dom (m : t A dom) (Hin : Dom.In x dom),

Theorem set_None : forall A x y v dom (m : t A dom) (Hin : Dom.In x dom),

Theorem add_Some : forall A x y v u dom (m : t A dom),
  find y (add x v m) = Some u <-> X.eq y x ∧ u = v ∨ ¬X.eq y x ∧ find y m = Some u.

Theorem add_None : forall A x y v dom (m : t A dom), find y (add x v m) = None <-> ¬X.eq y x ∧ find y m = None.

Theorem remove_Some : forall A x y u dom (m : t A dom),
  find y (remove x m) = Some u <-> ¬X.eq y x ∧ find y m = Some u.

Theorem remove_None : forall A x y dom (m : t A dom),
  find y (remove x m) = None <-> X.eq y x ∨ find y m = None.

Theorem add_cancel : forall A x v dom (m : t A dom), find x m = Some v -> eq (add x v m) m.

Theorem remove_cancel : forall A x dom (m : t A dom), find x m = None -> eq (remove x m) m.

Theorem add_merge : forall A x v₁ v₂ dom (m : t A dom), eq (add x v₂ (add x v₁ m)) (add x v₂ m).

Theorem add_comm : forall A x y v₁ v₂ dom (m : t A dom),
  ¬X.eq x y -> eq (add y v₂ (add x v₁ m)) (add x v₁ (add y v₂ m)).

Theorem remove_add_cancel : forall A x v dom (m : t A dom), eq (remove x (add x v m)) (remove x m).

Theorem map_None : forall A B (f : A -> B) dom (m : t A dom) x, find x (map f m) = None <-> ¬Dom.In x dom.

Theorem combine_None : forall A B C (f : A -> B -> C) g₁ g₂ dom₁ dom₂ (m₁ : t A dom₁) (m₂ : t B dom₂) x,
  find x (combine f g₁ g₂ m₁ m₂) = None <-> find x m₁ = None ∧ find x m₂ = None.

Theorem add_incl : forall A x v dom (m : t A dom), ¬Dom.In x dom -> incl m (add x v m).

Theorem remove_incl : forall A x dom (m : t A dom), incl (remove x m) m.

Theorem cast_spec : forall A dom₁ dom₂ (Heq : Dom.eq dom₁ dom₂) (m : t A dom₁), eq (cast Heq m) m.

Lemma eq_dom : forall A dom₁ dom₂ (m₁ : t A dom₁) (m₂ : t A dom₂), eq m₁ m₂ -> Dom.eq dom₁ dom₂.

Definition for_all {A : Type} (f : key -> A -> bool) dom (m : t A dom) :=
  fold (fun x v b => b && f x v) m true.

Lemma for_all_spec_aux : forall dom A f, Proper (X.eq ==> Logic.eq ==> Logic.eq) f -> forall (m : t A dom) l b,

Lemma for_all_spec : forall A f, Proper (X.eq ==> Logic.eq ==> Logic.eq) f -> forall dom (m : t A dom),

Definition exists_ {A : Type} (f : key -> A -> bool) dom (m : t A dom) :=
  fold (fun x v b => b || f x v) m false.

Lemma exists_spec_aux : forall dom A f, Proper (X.eq ==> Logic.eq ==> Logic.eq) f -> forall (m : t A dom) l b,

Lemma exists_spec : forall A f, Proper (X.eq ==> Logic.eq ==> Logic.eq) f -> forall dom (m : t A dom),

End DepMapFactsOn. *)

Module Make (X : OrderedType) : DepMapFacts (X).
  Module Map := DepMapImpl(X).
  Module Facts := DepMapFactsOn(X)(Map).
  Include Facts.
End Make.