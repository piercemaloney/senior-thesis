

Require Import ZArith.



Require Import preparation.
(* preparation:
Require Import ZArith.

Open Scope Z_scope.

Definition in_Z_ (m x : Z) := 0 <= x < m.

Definition Z_ (m : Z) := sig (in_Z_ m).

Coercion Z_from_Z_ (m : Z) (x : Z_ m) := proj1_sig (P := in_Z_ m) x.

Notation _Z := (Z_from_Z_ _).

Definition in_Zpls (x : Z) := 0 < x.

Definition Zpls := sig in_Zpls.

Coercion Zpls_ (x : Zpls) := proj1_sig (P := in_Zpls) x.

Lemma le_0__Z : forall (n : Z) (i : Z_ n), 0 <= i.

Lemma lt_z__Z : forall (n : Z) (i : Z_ n), i < n.

Lemma Zmod_le_0_z : forall x m : Z, 0 < m -> 0 <= x mod m.

Lemma Zmod_lt_z_m : forall x m : Z, 0 < m -> x mod m < m.

Lemma Zdiv_small_0 : forall x m : Z, 0 <= x -> x < m -> x / m = 0.

Lemma Zle_0_div : forall a m : Z, 0 <= a -> 0 < m -> 0 <= a / m.

Lemma Zdiv_le : forall a b m : Z, 0 < m -> a <= b -> a / m <= b / m.

Lemma Zmod_plus_m : forall x m : Z, 0 < m -> (x + m) mod m = x mod m.

Lemma Zmod_minus_m : forall x m : Z, 0 < m -> (x - m) mod m = x mod m.

Lemma Zmod_km_plus : forall x k m : Z, 0 < m -> (k * m + x) mod m = x mod m.

Lemma Zmod_minus_km : forall x k m : Z, 0 < m -> (x - k * m) mod m = x mod m.

Lemma Zdivmod_split : forall x m : Z, 0 < m -> x / m * m + x mod m = x.

Lemma Zmod_plus_distr_l : forall a b m : Z, 0 < m -> (a + b) mod m = (a mod m + b) mod m.

Lemma Zmod_mult_distr_l : forall a b m : Z, 0 < m -> (a * b) mod m = (a mod m * b) mod m.

Lemma Zmod_minus_distr_l : forall a b m : Z, 0 < m -> (a - b) mod m = (a mod m - b) mod m.

Lemma Zmod_minus_distr_r : forall a b m : Z, 0 < m -> (a - b) mod m = (a - b mod m) mod m.

Lemma modred : forall x m : Z, 0 <= x -> x < m -> x mod m = x.

Lemma Zdiv_a_b_b_Zmod : forall a b : Z, 0 < b -> a / b * b = a - a mod b.

Lemma Zminus_Zdiv_Zmult : forall a b : Z, 0 < b -> a - a / b * b = a mod b.

Lemma Zmod_prod_Zmod : forall x y z : Z, 0 < y -> 0 < z -> x mod (y * z) mod z = x mod z.

Lemma Zdiv_mult_plus : forall a b m : Z, 0 < m -> 0 <= b -> b < m -> (a * m + b) / m = a.

Lemma Zdiv_mult_minus : forall a b m : Z, 0 < m -> 0 < b -> b <= m -> (a * m - b) / m = a - 1.

Lemma Zdiv_times_plus : forall x y m : Z, 0 < m -> (x * m + y) / m = (x + y / m).

Lemma div_1_id : forall a : Z, a / 1 = a.

Lemma mod_1_0 : forall z : Z, z mod 1 = 0.

Set Implicit Arguments.
Unset Strict Implicit.

Definition If (T : Set) (b : bool) (t e : T) :=
   
  match b with
  | true => t
  | false => e
  end.

Set Strict Implicit.
Unset Implicit Arguments.

Lemma Z_to_inject_nat : forall x : Z, 0 <= x -> Z_of_nat (Zabs_nat x) = x.

Lemma Zlt_0_power_nat : forall i : nat, 0 < Zpower_nat 2 i.

Lemma Zpower_nat_Zpower : forall i : nat, Zpower_nat 2 i = 2 ^ Z_of_nat i.

Lemma Zpower_Zpower_nat : forall i : Z, 0 <= i -> 2 ^ i = Zpower_nat 2 (Zabs_nat i).

Lemma lt_0_Zpow : forall x : Z, 0 <= x -> 0 < 2 ^ x.

Lemma Zlt_pow_lt :
  forall i j : Z, 0 <= i -> i < j -> 2 ^ i < 2 ^ j.

Lemma Zle_pow_le :
  forall i j : Z, 0 <= i -> i <= j -> 2 ^ i <= 2 ^ j.

Lemma lt_pow_lt :
  forall i j : Z, 0 <= i -> 0 <= j -> 2 ^ i < 2 ^ j -> i < j.

Definition Zlog_sup (M : Z) :=
  match M with
  | Zpos p => log_sup p
  | _ => 0
  end.

Lemma Zlog_sup_pow : forall i : Z, 0 <= i -> Zlog_sup (2 ^ i) = i.

Lemma two_p_pow : forall z : Z, 0 <= z -> two_p z = 2 ^ z.

Lemma Zlog_sup_correct1 : forall z : Z, 0 < z -> 0 <= Zlog_sup z. 

Lemma Zlog_sup_correct2 : forall z : Z, 0 < z -> 2 ^ (Zlog_sup z - 1) < z <= 2 ^ Zlog_sup z.

Lemma Zlog_sup_unique : forall z : Z, 0 < z -> forall i j : Z, 0 <= i -> 0 <= j ->
  2 ^ (i - 1) < z -> z <= 2 ^ i -> 2 ^ (j - 1) < z -> z <= 2 ^ j -> i = j.

Lemma Zlog_sup_from_interval : forall z : Z, 0 < z -> forall i : Z, 0 <= i -> 2 ^ (i - 1) < z ->
  z <= 2 ^ i -> Zlog_sup z = i.

Lemma Zlog_sup_seq : forall p q : Z, p <= q -> Zlog_sup p <= Zlog_sup q.
  
Lemma Z_pow_plus : forall x : Z, 0 <= x -> 2 ^ x + 2 ^ x = 2 ^ (x + 1).

Lemma Zdivdivdiv : forall x y z : Z, 0 < y -> 0 < z -> x / y / z = x / (y * z).

Lemma Zdiv_simpl : forall x y z : Z, 0 < y -> 0 < z -> (x * z) / (y * z) = x / y.

Lemma Zdiv_den_le : forall x y z : Z, 0 <= x -> 0 < z -> z <= y -> x / y <= x / z.

Lemma approx_cz : forall c y z : Z, 0 < c -> 0 < y -> 0 <= z -> z <= c ->
  z / y - c / y * z / c <= 1.

Lemma approx_le1 : forall a b y x : Z, 0 < a -> 0 < b -> 0 < y -> 0 <= x -> x < a * b + a ->
  x / a * a / y - x / a * (a * b / y) / b <= 1.

Lemma approx_m1_one : forall a b y x : Z, 0 < a -> 0 < b -> 0 < y -> 0 <= x -> x < a * b + a ->
  x / a * a / y - 1 <= x / a * (a * b / y) / b.

Lemma approx_cz0 : forall c y z : Z, 0 < c -> 0 < y -> 0 <= z ->
  c / y * z / c <= z / y.

Lemma approx_ab_le : forall a b y x : Z, 0 < a -> 0 < b -> 0 < y -> 0 <= x ->
  x / a * (a * b / y) / b <= x / a * a / y.

Lemma approx_m1_two : forall y a b x : Z, 0 < y -> 0 < a -> a <= y -> 0 < b -> 0 <= x ->
  x / y - 1 <= x / a * a / y.

Lemma approx_m2 : forall y a b x : Z, 0 < y -> 0 < a -> a <= y -> 0 < b -> 0 <= x ->
  x < a * b + a -> x / y - 2 <= x / a * (a * b / y) / b.

Lemma approx_0_one : forall y a b x : Z, 0 < y -> 0 < a -> 0 < b -> 0 <= x ->
  x / a * (a * b / y) / b <= x / a * a / y.

Lemma approx_0_two : forall y a b x : Z, 0 < y -> 0 < a -> 0 < b -> 0 <= x ->
  x / a * a / y <= x / y.

Lemma approx_0 : forall y a b x : Z, 0 < y -> 0 < a -> 0 < b -> 0 <= x ->
  x / a * (a * b / y) / b <= x / y.

Lemma mod_over_div : forall a b c m : Z, 0 < b -> 0 < m -> (a * b + c) / b * b mod m = (a mod m * b + c) / b * b mod m.

Lemma sum_r'_i : forall a b m : Z, 0 < m -> (a mod m + b mod m) / m = 0 \/ (a mod m + b mod m) / m = 1.

Lemma mod_plus : forall a b m : Z, 0 < m -> a mod m + b mod m = (a + b) mod m \/ a mod m + b mod m = (a + b) mod m + m.

Lemma div_m_1 : forall m : Z, 0 < m -> 2 ^ Zlog_sup m / m = 1.

Lemma div_r'_i : forall a m : Z, 0 < m -> a mod 2 ^ Zlog_sup m / m = 0 \/ a mod 2 ^ Zlog_sup m / m = 1.

Theorem approx_0_m2 : forall (y b : Zpls) (a : Z_ y) (x : Z_ (a * b + a)),
  x / y - 2 <= x / a * (a * b / y) / b <= x / y.

Theorem div_approx1 : forall (y : Zpls) (a : Zpls) (b : Zpls)
  (x : Z_ (a * b + a)),
    x / a * a / y - 1 <= x / a * (a * b / y) / b <= 
    x / a * a / y.

Close Scope Z_scope. *)



Open Scope Z_scope.



Variable w_def : Zpls.



Definition w := proj1_sig w_def.



Lemma lt_0_w : 0 < w.



  unfold w. case w_def. trivial. Qed.



Lemma le_0_w : 0 <= w.



  apply Zlt_le_weak. exact lt_0_w. Qed.



Lemma lt02w : 0 < 2 ^ w.



  apply lt_0_Zpow. exact le_0_w. Qed.



Lemma zero_is_in_Z_ : in_Z_ (2 ^ w) 0.



  unfold in_Z_. split. omega. exact lt02w. Qed.



Definition zero_in_Z_ := exist (in_Z_ (2 ^ w)) 0 zero_is_in_Z_.



Lemma Zpow_2_w_is_2Zpow_2_wm1 : 2 ^ w = 2 ^ (w - 1) + 2 ^ (w - 1).



  transitivity (2 ^ (1 + (w - 1))). rewrite Zplus_minus. trivial. rewrite Zpower_exp.

  ring. omega. cut (0 < w). omega. exact lt_0_w. Qed.



Lemma lt_2wm1_2w : 2 ^ (w - 1) < 2 ^ w.



  rewrite Zpow_2_w_is_2Zpow_2_wm1. cut (0 < 2 ^ (w - 1)). omega. apply lt_0_Zpow. cut (0 < w). omega.

  exact lt_0_w. Qed.



Lemma mod_in_Z__ : forall z : Z, in_Z_ (2 ^ w) (z mod 2 ^ w).



  intro z. unfold in_Z_. split. apply Zmod_le_0_z. exact lt02w. apply Zmod_lt_z_m.

  exact lt02w. Qed.



Lemma is_in_Z_R_ursh : forall (x : Z_ (2 ^ w)) (i : Z_ w), in_Z_ (2 ^ w) (x / 2 ^ i).



  intros x i. unfold in_Z_. split. apply Zle_0_div. apply le_0__Z. apply lt_0_Zpow. apply le_0__Z. 

  apply Zle_lt_trans with ((2 ^ w - 1) / 2 ^ i). apply Zdiv_le. apply lt_0_Zpow. apply le_0__Z. 

  cut (x < 2 ^ w). omega. apply lt_z__Z. apply Zle_lt_trans with ((2 ^ w - 1) / 2 ^ 0). 

  apply Zdiv_den_le. cut (0 < 2 ^ w). omega. exact lt02w. replace (2 ^ 0) with 1. omega. trivial. 

  apply Zle_pow_le. omega. apply le_0__Z. replace (2 ^ 0) with 1.

  replace (2 ^ w - 1) with ((2 ^ w - 1) * 1). rewrite Z_div_mult. omega. omega. ring. trivial. Qed.



Lemma is_in_Z_R_uhwm : forall x y : Z_ (2 ^ w), in_Z_ (2 ^ w) (x * y / 2 ^ w).



  intros x y. unfold in_Z_. split. apply Zle_0_div. apply Zmult_le_0_compat; apply le_0__Z. 

  exact lt02w. apply Zle_lt_trans with (x * 2 ^ w / 2 ^ w). apply Zdiv_le. exact lt02w.

  apply Zmult_le_compat_l. apply Zlt_le_weak. apply lt_z__Z. apply le_0__Z. rewrite Z_div_mult.

  apply lt_z__Z. apply Zlt_gt. exact lt02w. Qed.



Definition plusw (x y : Z_ (2 ^ w)) :=

  exist (in_Z_ (2 ^ w)) ((x + y) mod 2 ^ w)

             (mod_in_Z__ (x + y)).



Definition minusw (x y : Z_ (2 ^ w)) :=

  exist (in_Z_ (2 ^ w)) ((x - y) mod 2 ^ w) (mod_in_Z__ (x - y)).



Definition multw (x y : Z_ (2 ^ w)) :=

  exist (in_Z_ (2 ^ w)) (x * y mod 2 ^ w) (mod_in_Z__ (x * y)).



Definition uhwm (x y : Z_ (2 ^ w)) :=

  exist (in_Z_ (2 ^ w)) (x * y / 2 ^ w) (is_in_Z_R_uhwm x y).



Definition multp2 (x : Z_ (2 ^ w)) (i : Z_ w) := 

  exist (in_Z_ (2 ^ w)) (2 ^ i * x mod 2 ^ w) (mod_in_Z__ (2 ^ i * x)).



Definition ursh (x : Z_ (2 ^ w)) (i : Z_ w) := 

  exist (in_Z_ (2 ^ w)) (x / 2 ^ i) (is_in_Z_R_ursh x i).



Definition ltw (x y t e : Z_ (2 ^ w)) :=

  If (Zlt_bool x y) t e.



Lemma Z_from_plusw : forall (x y : Z_ (2 ^ w)), _Z (plusw x y) = (x + y) mod (2 ^ w).



  trivial. Qed.



Lemma Z_from_multw : forall x y : Z_ (2 ^ w), _Z (multw x y) = x * y mod 2 ^ w.



  trivial. Qed.



Lemma Z_from_minusw : forall x y : Z_ (2 ^ w), _Z (minusw x y) = Zmod (x - y) (2 ^ w).



  trivial. Qed.



Lemma Z_from_multp2 : forall (x : Z_ (2 ^ w)) (i : Z_ w),

  _Z (multp2 x i) = Zmod (2 ^ i * x) (2 ^ w).



  trivial. Qed.



Lemma uhwm_eq : forall x y : Z_ (2 ^ w), _Z (uhwm x y) = (x * y) / 2 ^ w.



  trivial. Qed.



Lemma ltw_true : forall x y t e : Z_ (2 ^ w), x < y -> ltw x y t e = t.



  unfold ltw. unfold Zlt_bool. unfold Zlt. intros x y t e H. rewrite H.

  trivial. Qed.



Lemma ltw_false : forall x y t e : Z_ (2 ^ w), y <= x -> ltw x y t e = e.



  intros x y t e H. unfold ltw. unfold Zlt_bool. cut (x >= y). unfold Zge.

  case (x ?= y). trivial. intro H0. absurd (Lt <> Lt). auto. assumption.

  trivial. omega. Qed.



Close Scope Z_scope.

