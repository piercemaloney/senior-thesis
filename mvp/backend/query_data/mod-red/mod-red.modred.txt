
Require Import ZArith.

Require Import preparation.
(* preparation:
Require Import ZArith.

Open Scope Z_scope.

Definition in_Z_ (m x : Z) := 0 <= x < m.

Definition Z_ (m : Z) := sig (in_Z_ m).

Coercion Z_from_Z_ (m : Z) (x : Z_ m) := proj1_sig (P := in_Z_ m) x.

Notation _Z := (Z_from_Z_ _).

Definition in_Zpls (x : Z) := 0 < x.

Definition Zpls := sig in_Zpls.

Coercion Zpls_ (x : Zpls) := proj1_sig (P := in_Zpls) x.

Lemma le_0__Z : forall (n : Z) (i : Z_ n), 0 <= i.

Lemma lt_z__Z : forall (n : Z) (i : Z_ n), i < n.

Lemma Zmod_le_0_z : forall x m : Z, 0 < m -> 0 <= x mod m.

Lemma Zmod_lt_z_m : forall x m : Z, 0 < m -> x mod m < m.

Lemma Zdiv_small_0 : forall x m : Z, 0 <= x -> x < m -> x / m = 0.

Lemma Zle_0_div : forall a m : Z, 0 <= a -> 0 < m -> 0 <= a / m.

Lemma Zdiv_le : forall a b m : Z, 0 < m -> a <= b -> a / m <= b / m.

Lemma Zmod_plus_m : forall x m : Z, 0 < m -> (x + m) mod m = x mod m.

Lemma Zmod_minus_m : forall x m : Z, 0 < m -> (x - m) mod m = x mod m.

Lemma Zmod_km_plus : forall x k m : Z, 0 < m -> (k * m + x) mod m = x mod m.

Lemma Zmod_minus_km : forall x k m : Z, 0 < m -> (x - k * m) mod m = x mod m.

Lemma Zdivmod_split : forall x m : Z, 0 < m -> x / m * m + x mod m = x.

Lemma Zmod_plus_distr_l : forall a b m : Z, 0 < m -> (a + b) mod m = (a mod m + b) mod m.

Lemma Zmod_mult_distr_l : forall a b m : Z, 0 < m -> (a * b) mod m = (a mod m * b) mod m.

Lemma Zmod_minus_distr_l : forall a b m : Z, 0 < m -> (a - b) mod m = (a mod m - b) mod m.

Lemma Zmod_minus_distr_r : forall a b m : Z, 0 < m -> (a - b) mod m = (a - b mod m) mod m.

Lemma modred : forall x m : Z, 0 <= x -> x < m -> x mod m = x.

Lemma Zdiv_a_b_b_Zmod : forall a b : Z, 0 < b -> a / b * b = a - a mod b.

Lemma Zminus_Zdiv_Zmult : forall a b : Z, 0 < b -> a - a / b * b = a mod b.

Lemma Zmod_prod_Zmod : forall x y z : Z, 0 < y -> 0 < z -> x mod (y * z) mod z = x mod z.

Lemma Zdiv_mult_plus : forall a b m : Z, 0 < m -> 0 <= b -> b < m -> (a * m + b) / m = a.

Lemma Zdiv_mult_minus : forall a b m : Z, 0 < m -> 0 < b -> b <= m -> (a * m - b) / m = a - 1.

Lemma Zdiv_times_plus : forall x y m : Z, 0 < m -> (x * m + y) / m = (x + y / m).

Lemma div_1_id : forall a : Z, a / 1 = a.

Lemma mod_1_0 : forall z : Z, z mod 1 = 0.

Set Implicit Arguments.
Unset Strict Implicit.

Definition If (T : Set) (b : bool) (t e : T) :=
   
  match b with
  | true => t
  | false => e
  end.

Set Strict Implicit.
Unset Implicit Arguments.

Lemma Z_to_inject_nat : forall x : Z, 0 <= x -> Z_of_nat (Zabs_nat x) = x.

Lemma Zlt_0_power_nat : forall i : nat, 0 < Zpower_nat 2 i.

Lemma Zpower_nat_Zpower : forall i : nat, Zpower_nat 2 i = 2 ^ Z_of_nat i.

Lemma Zpower_Zpower_nat : forall i : Z, 0 <= i -> 2 ^ i = Zpower_nat 2 (Zabs_nat i).

Lemma lt_0_Zpow : forall x : Z, 0 <= x -> 0 < 2 ^ x.

Lemma Zlt_pow_lt :
  forall i j : Z, 0 <= i -> i < j -> 2 ^ i < 2 ^ j.

Lemma Zle_pow_le :
  forall i j : Z, 0 <= i -> i <= j -> 2 ^ i <= 2 ^ j.

Lemma lt_pow_lt :
  forall i j : Z, 0 <= i -> 0 <= j -> 2 ^ i < 2 ^ j -> i < j.

Definition Zlog_sup (M : Z) :=
  match M with
  | Zpos p => log_sup p
  | _ => 0
  end.

Lemma Zlog_sup_pow : forall i : Z, 0 <= i -> Zlog_sup (2 ^ i) = i.

Lemma two_p_pow : forall z : Z, 0 <= z -> two_p z = 2 ^ z.

Lemma Zlog_sup_correct1 : forall z : Z, 0 < z -> 0 <= Zlog_sup z. 

Lemma Zlog_sup_correct2 : forall z : Z, 0 < z -> 2 ^ (Zlog_sup z - 1) < z <= 2 ^ Zlog_sup z.

Lemma Zlog_sup_unique : forall z : Z, 0 < z -> forall i j : Z, 0 <= i -> 0 <= j ->
  2 ^ (i - 1) < z -> z <= 2 ^ i -> 2 ^ (j - 1) < z -> z <= 2 ^ j -> i = j.

Lemma Zlog_sup_from_interval : forall z : Z, 0 < z -> forall i : Z, 0 <= i -> 2 ^ (i - 1) < z ->
  z <= 2 ^ i -> Zlog_sup z = i.

Lemma Zlog_sup_seq : forall p q : Z, p <= q -> Zlog_sup p <= Zlog_sup q.
  
Lemma Z_pow_plus : forall x : Z, 0 <= x -> 2 ^ x + 2 ^ x = 2 ^ (x + 1).

Lemma Zdivdivdiv : forall x y z : Z, 0 < y -> 0 < z -> x / y / z = x / (y * z).

Lemma Zdiv_simpl : forall x y z : Z, 0 < y -> 0 < z -> (x * z) / (y * z) = x / y.

Lemma Zdiv_den_le : forall x y z : Z, 0 <= x -> 0 < z -> z <= y -> x / y <= x / z.

Lemma approx_cz : forall c y z : Z, 0 < c -> 0 < y -> 0 <= z -> z <= c ->
  z / y - c / y * z / c <= 1.

Lemma approx_le1 : forall a b y x : Z, 0 < a -> 0 < b -> 0 < y -> 0 <= x -> x < a * b + a ->
  x / a * a / y - x / a * (a * b / y) / b <= 1.

Lemma approx_m1_one : forall a b y x : Z, 0 < a -> 0 < b -> 0 < y -> 0 <= x -> x < a * b + a ->
  x / a * a / y - 1 <= x / a * (a * b / y) / b.

Lemma approx_cz0 : forall c y z : Z, 0 < c -> 0 < y -> 0 <= z ->
  c / y * z / c <= z / y.

Lemma approx_ab_le : forall a b y x : Z, 0 < a -> 0 < b -> 0 < y -> 0 <= x ->
  x / a * (a * b / y) / b <= x / a * a / y.

Lemma approx_m1_two : forall y a b x : Z, 0 < y -> 0 < a -> a <= y -> 0 < b -> 0 <= x ->
  x / y - 1 <= x / a * a / y.

Lemma approx_m2 : forall y a b x : Z, 0 < y -> 0 < a -> a <= y -> 0 < b -> 0 <= x ->
  x < a * b + a -> x / y - 2 <= x / a * (a * b / y) / b.

Lemma approx_0_one : forall y a b x : Z, 0 < y -> 0 < a -> 0 < b -> 0 <= x ->
  x / a * (a * b / y) / b <= x / a * a / y.

Lemma approx_0_two : forall y a b x : Z, 0 < y -> 0 < a -> 0 < b -> 0 <= x ->
  x / a * a / y <= x / y.

Lemma approx_0 : forall y a b x : Z, 0 < y -> 0 < a -> 0 < b -> 0 <= x ->
  x / a * (a * b / y) / b <= x / y.

Lemma mod_over_div : forall a b c m : Z, 0 < b -> 0 < m -> (a * b + c) / b * b mod m = (a mod m * b + c) / b * b mod m.

Lemma sum_r'_i : forall a b m : Z, 0 < m -> (a mod m + b mod m) / m = 0 \/ (a mod m + b mod m) / m = 1.

Lemma mod_plus : forall a b m : Z, 0 < m -> a mod m + b mod m = (a + b) mod m \/ a mod m + b mod m = (a + b) mod m + m.

Lemma div_m_1 : forall m : Z, 0 < m -> 2 ^ Zlog_sup m / m = 1.

Lemma div_r'_i : forall a m : Z, 0 < m -> a mod 2 ^ Zlog_sup m / m = 0 \/ a mod 2 ^ Zlog_sup m / m = 1.

Theorem approx_0_m2 : forall (y b : Zpls) (a : Z_ y) (x : Z_ (a * b + a)),
  x / y - 2 <= x / a * (a * b / y) / b <= x / y.

Theorem div_approx1 : forall (y : Zpls) (a : Zpls) (b : Zpls)
  (x : Z_ (a * b + a)),
    x / a * a / y - 1 <= x / a * (a * b / y) / b <= 
    x / a * a / y.

Close Scope Z_scope. *)
Require Import unsigned.
(* unsigned:
Require Import ZArith.

Require Import preparation.

Open Scope Z_scope.

Variable w_def : Zpls.

Definition w := proj1_sig w_def.

Lemma lt_0_w : 0 < w.

Lemma le_0_w : 0 <= w.

Lemma lt02w : 0 < 2 ^ w.

Lemma zero_is_in_Z_ : in_Z_ (2 ^ w) 0.

Definition zero_in_Z_ := exist (in_Z_ (2 ^ w)) 0 zero_is_in_Z_.

Lemma Zpow_2_w_is_2Zpow_2_wm1 : 2 ^ w = 2 ^ (w - 1) + 2 ^ (w - 1).

Lemma lt_2wm1_2w : 2 ^ (w - 1) < 2 ^ w.

Lemma mod_in_Z__ : forall z : Z, in_Z_ (2 ^ w) (z mod 2 ^ w).

Lemma is_in_Z_R_ursh : forall (x : Z_ (2 ^ w)) (i : Z_ w), in_Z_ (2 ^ w) (x / 2 ^ i).

Lemma is_in_Z_R_uhwm : forall x y : Z_ (2 ^ w), in_Z_ (2 ^ w) (x * y / 2 ^ w).

Definition plusw (x y : Z_ (2 ^ w)) :=
  exist (in_Z_ (2 ^ w)) ((x + y) mod 2 ^ w)
             (mod_in_Z__ (x + y)).

Definition minusw (x y : Z_ (2 ^ w)) :=
  exist (in_Z_ (2 ^ w)) ((x - y) mod 2 ^ w) (mod_in_Z__ (x - y)).

Definition multw (x y : Z_ (2 ^ w)) :=
  exist (in_Z_ (2 ^ w)) (x * y mod 2 ^ w) (mod_in_Z__ (x * y)).

Definition uhwm (x y : Z_ (2 ^ w)) :=
  exist (in_Z_ (2 ^ w)) (x * y / 2 ^ w) (is_in_Z_R_uhwm x y).

Definition multp2 (x : Z_ (2 ^ w)) (i : Z_ w) := 
  exist (in_Z_ (2 ^ w)) (2 ^ i * x mod 2 ^ w) (mod_in_Z__ (2 ^ i * x)).

Definition ursh (x : Z_ (2 ^ w)) (i : Z_ w) := 
  exist (in_Z_ (2 ^ w)) (x / 2 ^ i) (is_in_Z_R_ursh x i).

Definition ltw (x y t e : Z_ (2 ^ w)) :=
  If (Zlt_bool x y) t e.

Lemma Z_from_plusw : forall (x y : Z_ (2 ^ w)), _Z (plusw x y) = (x + y) mod (2 ^ w).

Lemma Z_from_multw : forall x y : Z_ (2 ^ w), _Z (multw x y) = x * y mod 2 ^ w.

Lemma Z_from_minusw : forall x y : Z_ (2 ^ w), _Z (minusw x y) = Zmod (x - y) (2 ^ w).

Lemma Z_from_multp2 : forall (x : Z_ (2 ^ w)) (i : Z_ w),
  _Z (multp2 x i) = Zmod (2 ^ i * x) (2 ^ w).

Lemma uhwm_eq : forall x y : Z_ (2 ^ w), _Z (uhwm x y) = (x * y) / 2 ^ w.

Lemma ltw_true : forall x y t e : Z_ (2 ^ w), x < y -> ltw x y t e = t.

Lemma ltw_false : forall x y t e : Z_ (2 ^ w), y <= x -> ltw x y t e = e.

Close Scope Z_scope. *)

Open Scope Z_scope.

Section parm_sec.

Variable M_in_Z_ : Z_ (2 ^ w).
Variable ptM' : Z_ w * Z_ w * Z_ (2 ^ w).
Variables v_in_Z_ u_in_Z_ : Z_ (2 ^ w).

Let p_in_Z_w := fst (fst ptM').
Let t_in_Z_w := snd (fst ptM').
Let M'_in_Z_ := snd ptM'.

Let M := _Z M_in_Z_.
Let p := _Z p_in_Z_w.
Let t := _Z t_in_Z_w.
Let M' := _Z M'_in_Z_.
Let v := _Z v_in_Z_.
Let u := _Z u_in_Z_.

Hypothesis le_1_M : 1 <= M.
Hypothesis le_M_max : M <= 2 ^ (w - 1).
Hypothesis p_M : p = Zlog_sup M.
Hypothesis t_M : t = w - p \/ M = 1.
Hypothesis M'_M : M' = 2 ^ (p + w) / M mod 2 ^ w.
Hypothesis v_M : v < 2 ^ p.

Let x := v * 2 ^ w + u.

Lemma le_0_p : 0 <= p.

  unfold p. apply le_0__Z. Qed.

Lemma le_0_l : 0 <= u.
  
  unfold u. apply le_0__Z. Qed.

Lemma lt_l_2w : u < 2 ^ w.

  unfold u. apply lt_z__Z. Qed.

Lemma le_0_v : 0 <= v.

  unfold v. apply le_0__Z. Qed.

Lemma lt_v_2w : v < 2 ^ w.

  unfold v. apply lt_z__Z. Qed.

Lemma le02w : 0 <= 2 ^ w.

  apply Zlt_le_weak. exact lt02w. Qed.

Local Hint Resolve le_0_w lt02w le02w : a.
Local Hint Resolve le_0_p le_0_l lt_l_2w le_0_v lt_v_2w : a.

Lemma le_0_x : 0 <= x.

  unfold x. fold (0 + 0). apply Zplus_le_compat; auto with a. apply Zmult_le_0_compat; auto with a. Qed.

Local Hint Resolve le_0_x : a.

Let s := ursh u_in_Z_ p_in_Z_w.

Let s' := multp2 s p_in_Z_w.

Let h := multp2 v_in_Z_ t_in_Z_w.

Let h' := plusw h s.

Let q := uhwm h' M'_in_Z_.

Let q' := plusw q h'.

Let y := multw q' M_in_Z_.

Let d := minusw s' y.

Let r := minusw u_in_Z_ y.

Let r' := ltw d M_in_Z_ r (minusw r M_in_Z_).

Let r'' := ltw r' M_in_Z_ r' (minusw r' M_in_Z_).

Let r''' := ltw r'' M_in_Z_ r'' (minusw r'' M_in_Z_).

Definition ModRed := _Z r'''. 

Lemma l_eq : u = x mod 2 ^ w.

  unfold x. rewrite Zmod_km_plus. symmetry. apply modred. auto with a. auto with a. auto with a. Qed.

Lemma v_eq : v = x / 2 ^ w.

  unfold x. rewrite Zdiv_times_plus. rewrite Zdiv_small_0. ring. auto with a. auto with a. auto with a. Qed.

Lemma s_eq : _Z s = x mod 2 ^ w / 2 ^ p.

  simpl. fold u. fold p. rewrite l_eq. trivial. Qed.

Lemma lt_0_2ppw : 0 < 2 ^ (p + w).

  apply lt_0_Zpow. fold (0 + 0). apply Zplus_le_compat; auto with a. Qed.

Lemma lt_0_2pp : 0 < 2 ^ p.

  apply lt_0_Zpow. auto with a. Qed.

Local Hint Resolve lt_0_2pp : a.

Lemma lt_x_xmax : x < 2 ^ (p + w).

  unfold x. apply Zle_lt_trans with ((2 ^ p - 1) * 2 ^ w + (2 ^ w - 1)). apply Zplus_le_compat. 
  apply Zmult_le_compat. auto with a. auto with a. cut (v < 2 ^ p). omega. auto with a. omega. auto with a.
  auto with a. cut (u < 2 ^ w). omega. auto with a. rewrite Zmult_minus_distr_r. rewrite <- Zpower_exp.
  omega. auto with a. apply Zle_ge. auto with a. apply Zle_ge. auto with a. Qed.

Lemma le_x_xmax : x <= 2 ^ (p + w) - 1.

  cut (x < 2 ^ (p + w)). omega. exact lt_x_xmax. Qed.

Local Hint Resolve lt_x_xmax le_x_xmax : a.

Lemma le_0_wm1 : 0 <= w - 1.

  cut (0 < w). omega. exact lt_0_w. Qed.

Local Hint Resolve le_0_wm1 lt_0_w : a.

Lemma lt_p_w : p < w.

  rewrite p_M. apply Zle_lt_trans with (w - 1). rewrite <- Zlog_sup_pow. apply Zlog_sup_seq.
  assumption. auto with a. omega. Qed.

Lemma le_p_w : p <= w.

  apply Zlt_le_weak. exact lt_p_w. Qed.

Lemma le_0_wmp : 0 <= w - p.

  cut (p <= w). omega. exact le_p_w. Qed.

Local Hint Resolve lt_p_w le_p_w le_0_wmp : a.

Lemma s'_eq : _Z s' = x mod 2 ^ w - x mod 2 ^ p.

  unfold s'. rewrite Z_from_multp2. fold p. rewrite s_eq. rewrite Zmult_comm. rewrite modred.
  replace (x mod 2 ^ p) with (x mod 2 ^ w mod 2 ^ p). apply Zdiv_a_b_b_Zmod. auto with a.
  replace (2 ^ w) with (2 ^ (w - p) * 2 ^ p). apply Zmod_prod_Zmod. apply lt_0_Zpow. auto with a.
  auto with a. rewrite <- Zpower_exp. apply f_equal2 with (f := Zpower). trivial. ring. apply Zle_ge.
  auto with a. apply Zle_ge. auto with a. fold (0 * 0). apply Zmult_le_compat. apply Zle_0_div. 
  apply Zmod_le_0_z. auto with a. auto with a. apply Zlt_le_weak. auto with a. omega. omega. 
  apply Zle_lt_trans with (x mod 2 ^ w). rewrite Zmult_comm. apply Z_mult_div_ge. apply Zlt_gt.
  auto with a. apply Zmod_lt_z_m. auto with a. Qed.

Lemma h_eq : _Z h = x / 2 ^ w * 2 ^ (w - p).

  simpl. fold t v. elim t_M; intro H. rewrite H. rewrite <- v_eq. rewrite Zmult_comm. apply modred. 
  fold (0 * 0). apply Zmult_le_compat. auto with a. apply Zlt_le_weak. apply lt_0_Zpow. auto with a. omega.
  omega. apply Zlt_le_trans with (2 ^ p * 2 ^ (w - p)). apply Zmult_lt_compat_r. auto with a. 
  apply lt_0_Zpow. auto with a. assumption. rewrite <- Zpower_exp. replace (p + (w - p)) with w. omega. 
  ring. apply Zle_ge. auto with a. apply Zle_ge. auto with a. rewrite H in p_M. simpl in p_M.
  rewrite p_M in v_M. replace (2 ^ 0) with 1 in v_M. cut (v = 0). intro H0. unfold x. rewrite H0.
  replace (2 ^ t * 0) with 0. simpl. rewrite Zdiv_small_0. simpl. apply modred. omega. auto with a.
  auto with a. auto with a. ring. cut (0 <= v). omega. unfold v. apply le_0__Z. ring. Qed.

Lemma h'_eq : _Z h' = x / 2 ^ p.

  unfold h'. rewrite Z_from_plusw. rewrite h_eq. simpl. fold u p. rewrite l_eq. rewrite <- Zdiv_times_plus.
  rewrite <- Zmult_assoc. rewrite <- Zpower_exp. replace (w - p + p) with w. rewrite Zdivmod_split.
  apply modred. apply Zle_0_div. auto with a. auto with a. apply Zlt_le_trans with (2 ^ (p + w) / 2 ^ p).
  apply Zle_lt_trans with ((2 ^ (p + w) - 1) / 2 ^ p). apply Zdiv_le. auto with a. cut (x < 2 ^ (p + w)).
  omega. auto with a. rewrite Zpower_exp. rewrite Zmult_comm. rewrite Zdiv_mult_minus. rewrite Z_div_mult.
  omega. apply Zlt_gt. auto with a. auto with a. omega. cut (0 < 2 ^ p). omega. auto with a. apply Zle_ge.
  auto with a. apply Zle_ge. auto with a. rewrite Zpower_exp. rewrite Zmult_comm. rewrite Z_div_mult. 
  omega. apply Zlt_gt. auto with a. apply Zle_ge. auto with a. apply Zle_ge. auto with a. auto with a. 
  ring. apply Zle_ge. auto with a. apply Zle_ge. auto with a. auto with a. Qed.

Lemma q_eq : 
  _Z q = x / 2 ^ p * (2 ^ (p + w) / M mod 2 ^ w) / 2 ^ w.

  unfold q. rewrite uhwm_eq. rewrite h'_eq. fold M'. rewrite M'_M. trivial. Qed.

Lemma le_M_2pp : M <= 2 ^ p.

  rewrite p_M. generalize le_1_M. case M. intro. absurd (2 <= 0); omega. intros q0 H.
  elim (Zlog_sup_correct2 (Zpos q0)). omega. omega. intros q0 H. absurd (2 <= Zneg q0). apply Zlt_not_le.
  unfold Zlt. trivial. assumption. Qed.

Lemma le_1_p : 1 <= p \/ M = 1.

  rewrite p_M. elim (Zle_lt_or_eq 1 M). intro H. left. apply Zle_trans with (Zlog_sup 2). simpl. omega. 
  apply Zlog_sup_seq. omega. intro H. right. symmetry. trivial. assumption. Qed.

Lemma lt_0_p : 0 < p \/ M = 1. 

  elim le_1_p; intro H; omega. Qed.

Lemma le_0_pm1 : 0 <= p - 1 \/ M = 1.

  elim lt_0_p; intro H; omega. Qed.

Local Hint Resolve le_M_2pp le_1_p lt_0_p le_0_pm1 : a.

Lemma lt_2pm1_M : 2 ^ (p - 1) < M \/ M = 1.

  elim (Zle_lt_or_eq 1 M). intro H. rewrite p_M. generalize le_1_M. case M. intro. absurd (2 <= 0); omega. 
  intros q0 H0. elim (Zlog_sup_correct2 (Zpos q0)). omega. omega. intros q0 H0. absurd (1 <= Zneg q0). 
  apply Zlt_not_le. unfold Zlt. trivial. assumption. omega. assumption. Qed.

Local Hint Resolve lt_2pm1_M : a.

Lemma div_M_1 : 2 ^ p / M = 1.

  elim (Zle_lt_or_eq 1 M). intro H. replace (2 ^ p) with (1 * M + (2 ^ p - M)). apply Zdiv_mult_plus. omega.
  cut (M <= 2 ^ p). omega. auto with a. cut (2 ^ p < M + M). omega. 
  apply Zlt_le_trans with (2 ^ (p - 1) + 1 + (2 ^ (p - 1) + 1)).
  replace (2 ^ (p - 1) + 1 + (2 ^ (p - 1) + 1)) with (2 ^ (p - 1) + 2 ^ (p - 1) + 2). rewrite Z_pow_plus.
  replace (p - 1 + 1) with p. omega. ring. elim le_0_pm1. omega. intro H0. absurd (1 < M). omega.
  assumption. ring. cut (2 ^ (p - 1) < M). omega. elim lt_2pm1_M. omega. intro H0. absurd (1 < M). omega.
  assumption. ring. intro H0. rewrite p_M. rewrite <- H0. trivial. assumption. Qed.

Lemma large_M'_eq : 2 ^ w + (2 ^ (p + w) / M) mod 2 ^ w = 2 ^ (p + w) / M.

  transitivity (2 ^ (p + w) / M / 2 ^ w * 2 ^ w + (2 ^ (p + w) / M) mod 2 ^ w).
  apply f_equal2 with (f := Zplus). replace (2 ^ (p + w) / M / 2 ^ w) with 1. ring.
  rewrite Zdivdivdiv. rewrite Zmult_comm. rewrite <- Zdivdivdiv. rewrite Zpower_exp; auto with a. 
  rewrite Z_div_mult. symmetry. exact div_M_1. apply Zlt_gt. auto with a. apply Zle_ge. auto with a. 
  apply Zle_ge. auto with a. auto with a. omega. omega. auto with a. trivial. apply Zdivmod_split. 
  auto with a. Qed.

Lemma q'_eq_pre : 
  _Z q' = (x / 2 ^ p * (2 ^ (p + w) / M) / 2 ^ w) mod 2 ^ w.

  unfold q'. rewrite Z_from_plusw. rewrite q_eq. rewrite h'_eq. rewrite Zplus_comm. 
  rewrite <- Zdiv_times_plus. rewrite <- Zmult_plus_distr_r. rewrite large_M'_eq. trivial. auto with a. Qed.

Lemma mod_ab_mod : forall z a b m : Z, 0 < m ->
  z = a \/ z = b -> z mod m = a mod m \/ z mod m = b mod m.

  intros z a b m H H0. elim H0; intro H1; rewrite H1; tauto. Qed.

Lemma q'_eq :
  _Z q' = (x / 2 ^ p * 2 ^ p / M) mod 2 ^ w \/
  _Z q' = (x / 2 ^ p * 2 ^ p / M - 1) mod 2 ^ w.

  rewrite q'_eq_pre. apply mod_ab_mod. auto with a.
  cut (x / 2 ^ p * (2 ^ p * 2 ^ w / M) / 2 ^ w = x / 2 ^ p * 2 ^ p / M - 1 \/
       x / 2 ^ p * (2 ^ p * 2 ^ w / M) / 2 ^ w = x / 2 ^ p * 2 ^ p / M).
  rewrite Zpower_exp. tauto. apply Zle_ge. auto with a. apply Zle_ge. auto with a.
  cut (x / 2 ^ p * 2 ^ p / M - 1 <= x / 2 ^ p * (2 ^ p * 2 ^ w / M) / 2 ^ w).
  cut (x / 2 ^ p * (2 ^ p * 2 ^ w / M) / 2 ^ w <= x / 2 ^ p * 2 ^ p / M). intros H H0.
  elim (Zle_lt_or_eq (x / 2 ^ p * (2 ^ p * 2 ^ w / M) / 2 ^ w) (x / 2 ^ p * 2 ^ p / M)). intro H1. left.
  omega. intro H1. right. omega. assumption. apply approx_0_one. omega. auto with a. auto with a.
  auto with a. apply approx_m1_one. auto with a. auto with a. omega. auto with a. 
  cut (x < 2 ^ p * 2 ^ w). cut (0 < 2 ^ p). omega. auto with a. rewrite <- Zpower_exp. auto with a. 
  apply Zle_ge. auto with a. apply Zle_ge. auto with a. Qed.

Lemma y_eq :
  _Z y = x / 2 ^ p * 2 ^ p / M * M mod 2 ^ w \/
  _Z y = (x / 2 ^ p * 2 ^ p / M * M - M) mod 2 ^ w.

  unfold y. rewrite Z_from_multw. fold M. elim q'_eq; intro H; rewrite H. left. 
  rewrite <- Zmod_mult_distr_l. trivial. auto with a. right. rewrite <- Zmod_mult_distr_l.
  apply f_equal2 with (f := Zmod). ring. trivial. auto with a. Qed.

Lemma lt_M_2pw : M < 2 ^ w.

  unfold M. apply lt_z__Z. Qed.

Lemma le_M_2pw : M <= 2 ^ w.

  apply Zlt_le_weak. exact lt_M_2pw. Qed.

Hint Resolve lt_M_2pw le_M_2pw : a.

Lemma d_eq :
  _Z d = x / 2 ^ p * 2 ^ p mod M \/
  _Z d = x / 2 ^ p * 2 ^ p mod M + M.

  unfold d. rewrite Z_from_minusw. rewrite s'_eq. rewrite Zmod_minus_distr_l.
  rewrite <- Zmod_minus_distr_l with (b := x mod 2 ^ p). rewrite <- Zmod_minus_distr_l.
  rewrite <- Zdiv_a_b_b_Zmod. elim y_eq; intro H. left. rewrite H. rewrite <- Zmod_minus_distr_r.
  rewrite Zminus_Zdiv_Zmult. apply modred. apply Zmod_le_0_z. omega. apply Zlt_le_trans with M.
  apply Zmod_lt_z_m. omega. auto with a. omega. auto with a. right. rewrite H. 
  rewrite <- Zmod_minus_distr_r. 
  replace (x / 2 ^ p * 2 ^ p - (x / 2 ^ p * 2 ^ p / M * M - M))
     with (x / 2 ^ p * 2 ^ p - x / 2 ^ p * 2 ^ p / M * M + M). rewrite Zminus_Zdiv_Zmult. apply modred.
  fold (0 + 0). apply Zplus_le_compat. apply Zmod_le_0_z. omega. omega. apply Zlt_le_trans with (M + M).
  apply Zplus_lt_le_compat. apply Zmod_lt_z_m. omega. omega. rewrite Zpow_2_w_is_2Zpow_2_wm1. omega. omega.
  ring. auto with a. auto with a. auto with a. auto with a. auto with a. Qed.

Lemma r_eq : _Z r = (_Z d + x mod 2 ^ p) mod 2 ^ w.

  unfold r. unfold d. rewrite Z_from_minusw. rewrite Z_from_minusw. fold u. rewrite s'_eq.
  rewrite Zmod_minus_distr_l with (a := x mod 2 ^ w - x mod 2 ^ p).
  rewrite <- Zmod_minus_distr_l with (a := x). rewrite <- Zmod_minus_distr_l. rewrite <- Zmod_plus_distr_l.
  replace (x - x mod 2 ^ p - _Z y + x mod 2 ^ p) with (x - _Z y). rewrite l_eq. 
  rewrite <- Zmod_minus_distr_l. trivial. auto with a. ring. auto with a. auto with a. auto with a.
  auto with a. Qed.

Lemma r'_eq : _Z r' = x / 2 ^ p * 2 ^ p mod M + x mod 2 ^ p.

  unfold r'. elim d_eq; intro H. rewrite ltw_true. rewrite r_eq. rewrite H. apply modred. fold (0 + 0).
  apply Zplus_le_compat. apply Zmod_le_0_z. omega. apply Zmod_le_0_z. auto with a.
  rewrite Zpow_2_w_is_2Zpow_2_wm1. apply Zplus_lt_le_compat. apply Zlt_le_trans with M. apply Zmod_lt_z_m. omega.
  assumption. apply Zlt_le_weak. apply Zlt_le_trans with (2 ^ p). apply Zmod_lt_z_m. auto with a. apply Zle_pow_le.
  auto with a. cut (p < w). omega. auto with a. fold M. rewrite H. apply Zmod_lt_z_m. omega. 
  rewrite ltw_false. rewrite Z_from_minusw. rewrite r_eq. rewrite H. fold M. rewrite <- Zmod_minus_distr_l.
  replace ((x / 2 ^ p * 2 ^ p) mod M + M + x mod 2 ^ p - M)
     with ((x / 2 ^ p * 2 ^ p) mod M + x mod 2 ^ p). apply modred. fold (0 + 0). apply Zplus_le_compat.
  apply Zmod_le_0_z. omega. apply Zmod_le_0_z. auto with a. rewrite Zpow_2_w_is_2Zpow_2_wm1. 
  apply Zplus_lt_le_compat. apply Zlt_le_trans with M. apply Zmod_lt_z_m. omega. assumption. 
  apply Zlt_le_weak. apply Zlt_le_trans with (2 ^ p). apply Zmod_lt_z_m. auto with a. apply Zle_pow_le. auto with a. 
  cut (p < w). omega. auto with a. ring. auto with a. fold M. rewrite H. cut (0 <= x / 2 ^ p * 2 ^ p mod M).
  omega. apply Zmod_le_0_z. omega. Qed.

Lemma r'_small : _Z r' < M + 2 ^ p.

  rewrite r'_eq. apply Zplus_lt_compat. apply Zmod_lt_z_m. omega. apply Zmod_lt_z_m. auto with a. Qed.

Lemma r'_x : _Z r' = x mod M \/ _Z r' = x mod M + M \/ _Z r' = x mod M + M + M.

  rewrite r'_eq. rewrite <- Zdivmod_split with (x := x mod 2 ^ p) (m := M). rewrite Zdiv_a_b_b_Zmod.
  rewrite Zplus_comm with (m := x mod 2 ^ p mod M). rewrite Zplus_assoc. elim (mod_plus (x - x mod 2 ^ p) (x mod 2 ^ p) M).
  intro H. rewrite H. replace (x - x mod 2 ^ p + x mod 2 ^ p) with x. elim (div_r'_i x M). intro H0. rewrite <- p_M in H0.
  rewrite H0. left. ring. intro H0. rewrite <- p_M in H0. rewrite H0. right. left. ring. omega. ring. intro H. rewrite H.
  replace (x - x mod 2 ^ p + x mod 2 ^ p) with x. elim (div_r'_i x M). intro H0. rewrite <- p_M in H0. rewrite H0. right. left.
  ring. intro H0. rewrite <- p_M in H0. rewrite H0. right. right. ring. omega. ring. omega. auto with a. omega. Qed.

Lemma r''_small : _Z r'' < 2 ^ p.

  unfold r''. elim (Zle_or_lt M r'); intro H. rewrite ltw_false. simpl. fold M. rewrite modred. cut (r' < M + 2 ^ p).
  omega. exact r'_small. omega. apply Zle_lt_trans with (_Z r'). omega. apply lt_z__Z. fold M. assumption. rewrite ltw_true.
  apply Zlt_le_trans with M. assumption. exact le_M_2pp. fold M. assumption. Qed.

Lemma r''_eq : _Z r'' = x mod M \/ _Z r'' = x mod M + M.

  unfold r''. elim (Zle_or_lt M r'); intro H. rewrite ltw_false. simpl. fold M. rewrite modred. elim r'_x. intro H0.
  rewrite H0 in H. absurd (M <= x mod M). apply Zlt_not_le. apply Zmod_lt_z_m. omega. assumption. intro H0; elim H0; intro H1.
  rewrite H1. left. ring. rewrite H1. right. ring. omega. apply Zle_lt_trans with (_Z r'). omega. apply lt_z__Z. fold M.
  assumption. rewrite ltw_true. elim r'_x. tauto. intro H0; elim H0; intro H1. tauto. absurd (x mod M + M + M < M).
  apply Zle_not_lt. cut (0 <= x mod M). omega. apply Zmod_le_0_z. omega. rewrite <- H1. assumption. fold M. assumption. Qed.

Lemma r'''_eq : _Z r''' = x mod M.

  unfold r'''. elim r''_eq; intro H. rewrite ltw_true. assumption. rewrite H. fold M. apply Zmod_lt_z_m. 
  omega. rewrite ltw_false. rewrite Z_from_minusw. fold M. rewrite H.
  replace (x mod M + M - M) with (x mod M). apply modred. apply Zmod_le_0_z. omega. apply Zlt_trans with M.
  apply Zmod_lt_z_m. omega. auto with a. ring. fold M. rewrite H. cut (0 <= x mod M). omega.
  apply Zmod_le_0_z. omega. Qed.

End parm_sec.

Definition in_Mset (M : Z) := 1 <= M <= 2 ^ (w - 1).

Definition Mset := sig in_Mset.

Coercion Z_from_Mset (M : Mset) := proj1_sig (P := in_Mset) M.

Lemma Mset_l : forall M : Mset, 1 <= M.

  intro M. unfold Z_from_Mset. case M. unfold in_Mset. simpl. tauto. Qed.

Lemma Mset_r : forall M : Mset, M <= 2 ^ (w - 1).

  intro M. unfold Z_from_Mset. case M. unfold in_Mset. simpl. tauto. Qed.

Lemma logsuplew : forall (M : Mset), Zlog_sup M <= w.

  intro M. replace w with (Zlog_sup (2 ^ w)). apply Zlog_sup_seq. apply Zlt_le_weak. case M. unfold in_Mset.
  simpl. intros. cut (2 ^ (w - 1) < 2 ^ w). omega. exact lt_2wm1_2w. apply Zlog_sup_pow. exact le_0_w. Qed.

Lemma xhex : forall (M : Mset) (x : Z_ (2 ^ (Zlog_sup M + w))),
  in_Z_ (2 ^ w) (x / 2 ^ w).

  intros M x. unfold in_Z_. split. apply Zle_0_div. apply le_0__Z. exact lt02w. 
  apply Zle_lt_trans with ((2 ^ (Zlog_sup M + w) - 1) / 2 ^ w). apply Zdiv_le. exact lt02w.
  cut (x < 2 ^ (Zlog_sup M + w)). omega. apply lt_z__Z. rewrite Zpower_exp. 
  rewrite Zdiv_mult_minus. cut (2 ^ Zlog_sup M <= 2 ^ w). omega. apply Zle_pow_le. 
  apply Zlog_sup_correct1. apply Zlt_le_trans with 1. omega. apply Mset_l. apply logsuplew.
  exact lt02w. omega. cut (0 < 2 ^ w). omega. exact lt02w. apply Zle_ge. apply Zlog_sup_correct1. 
  apply Zlt_le_trans with 1. omega. apply Mset_l. apply Zle_ge. exact le_0_w. Qed.

Lemma xlex : forall x : Z, in_Z_ (2 ^ w) (x mod 2 ^ w).

  intro. unfold in_Z_. split. apply Zmod_le_0_z. exact lt02w. apply Zmod_lt_z_m. exact lt02w. Qed.

Lemma M'ex : forall M : Mset, in_Z_ (2 ^ w) (2 ^ (Zlog_sup M + w) / M - 2 ^ w).

  intro M. unfold in_Z_. elim (Zle_lt_or_eq 1 M). intro H0. cut (1 <= Zlog_sup M). intro H1.
  split. cut (2 ^ w <= 2 ^ (Zlog_sup M + w) / M). omega. rewrite Zpower_exp. 
  apply Zle_trans with (M * 2 ^ w / M). rewrite Zmult_comm. rewrite Z_div_mult. omega. omega. 
  apply Zdiv_le. omega. apply Zmult_le_compat_r. elim (Zlog_sup_correct2 M). omega. omega. 
  apply Zlt_le_weak. exact lt02w. omega. apply Zle_ge. exact le_0_w. 
  cut (2 ^ (Zlog_sup M + w) / M < 2 ^ w + 2 ^ w). omega. rewrite Zpower_exp.
  apply Zle_lt_trans with (((2 * M - 1) * 2 ^ w) / M). apply Zdiv_le. omega. apply Zmult_le_compat_r.
  replace (Zlog_sup M) with (Zlog_sup M - 1 + 1). rewrite Zpower_exp. 
  apply Zle_trans with ((M - 1) * 2). apply Zmult_le_compat. elim (Zlog_sup_correct2 M). omega.
  omega. simpl. unfold Zpower_pos. simpl. omega. apply Zle_trans with (2 ^ (1 - 1)). simpl. omega.
  apply Zle_pow_le. omega. omega. simpl. unfold Zpower_pos. simpl. omega. omega. omega. omega. ring.
  apply Zlt_le_weak. exact lt02w. replace ((2 * M - 1) * 2 ^ w) with ((2 ^ w + 2 ^ w) * M + - 2 ^ w).
  rewrite Zdiv_times_plus. cut (- 2 ^ w / M < 0). omega. apply Zle_lt_trans with (-1 / M).
  apply Zdiv_le. omega. cut (0 < 2 ^ w). omega. exact lt02w. replace (-1) with (0 * M - 1).
  rewrite Zdiv_mult_minus. omega. omega. omega. omega. ring. omega. ring. omega. apply Zle_ge. exact le_0_w.
  replace 1 with (Zlog_sup 2). apply Zlog_sup_seq. omega. trivial. intro H0. rewrite <- H0. simpl.
  replace (2 ^ w) with (2 ^ w * 1). rewrite Z_div_mult. split. omega. cut (0 < 2 ^ w). omega. exact lt02w.
  omega. ring. apply Mset_l. Qed.

Lemma p1ex_2le : forall M : Mset, in_Z_ w (Zlog_sup M).

  intro M. unfold in_Z_. split. apply Zle_trans with (Zlog_sup 1). simpl. omega. 
  apply Zlog_sup_seq. apply Mset_l. apply Zle_lt_trans with (w - 1).
  rewrite <- Zlog_sup_pow with (i := w - 1). apply Zlog_sup_seq. apply Mset_r. cut (0 < w). omega.
  exact lt_0_w. omega. Qed.

Lemma pex : forall M : Mset, in_Z_ w (Zlog_sup M).

  intros. apply p1ex_2le; omega. Qed.

Lemma tex : forall M : Mset, in_Z_ w (w - Zlog_sup M - 1 / M).

  intro M. unfold in_Z_. elim (Zle_lt_or_eq 1 M). intro H0. replace (1 / M) with 0. split.
  cut (Zlog_sup M <= w). omega. rewrite <- Zlog_sup_pow with (i := w). apply Zlog_sup_seq.
  apply Zle_trans with (2 ^ (w - 1)). apply Mset_r. apply Zlt_le_weak. apply lt_2wm1_2w.
  exact le_0_w. cut (1 <= Zlog_sup M). omega. 
  replace 1 with  (Zlog_sup 2). apply Zlog_sup_seq. omega. trivial. replace 1 with (0 * M + 1).
  symmetry. apply Zdiv_mult_plus. omega. omega. omega. ring. intro H0. rewrite <- H0. simpl. 
  replace (1 / 1) with 1. cut (0 < w). omega. exact lt_0_w. trivial. apply Mset_l. Qed.

Lemma in_Z__if_in_Mset : forall M : Mset, in_Z_ (2 ^ w) M.

  intro M. unfold in_Z_. case M. unfold in_Mset. simpl. intros. cut (2 ^ (w - 1) < 2 ^ w). omega.
  exact lt_2wm1_2w. Qed.

Definition Z__from_Mset (M : Mset) := exist (in_Z_ (2 ^ w)) M (in_Z__if_in_Mset M).

Coercion Z__from_Mset : Mset >-> sig.

Definition C (M : Mset) :=
      ( exist (in_Z_ w)       (Zlog_sup M)                       (pex M),
        exist (in_Z_ w)       (w - Zlog_sup M - 1 / M)           (tex M),
        exist (in_Z_ (2 ^ w)) (2 ^ (Zlog_sup M + w) / M - 2 ^ w) (M'ex M)).

Theorem ModRed_eq : forall (M : Mset)
                           (x : Z_ (2 ^ (Zlog_sup M + w))),
  ModRed M
         (C M)
         (exist (in_Z_ (2 ^ w)) (x / 2 ^ w)   (xhex M x))
         (exist (in_Z_ (2 ^ w)) (x mod 2 ^ w) (xlex x))     =
  x mod M.

  intros M x. unfold ModRed. rewrite r'''_eq; simpl. rewrite Zdivmod_split. trivial.
  exact lt02w. apply Mset_l. apply Mset_r. trivial. elim (Zle_lt_or_eq 1 M). intro H. left.
  replace 1 with (0 * M + 1). rewrite Zdiv_mult_plus. ring. omega. omega. omega. ring. intro H. right.
  auto. apply Mset_l. rewrite <- modred with (x := 2 ^ (Zlog_sup M + w) / M - 2 ^ w) (m := 2 ^ w).
  rewrite Zmod_minus_distr_r. rewrite Z_mod_same. apply f_equal2 with (f := Zmod). ring. trivial.
  apply Zlt_gt. exact lt02w. exact lt02w. elim (M'ex M). omega. elim (M'ex M). omega. 
  apply Zle_lt_trans with ((2 ^ (Zlog_sup M + w) - 1) / 2 ^ w). apply Zdiv_le. exact lt02w.
  cut (x < 2 ^ (Zlog_sup M + w)). omega. apply lt_z__Z. rewrite Zpower_exp. rewrite Zdiv_mult_minus.
  omega. exact lt02w. omega. cut (0 < 2 ^ w). omega. exact lt02w. apply Zle_ge. apply Zlog_sup_correct1.
  apply Zlt_le_trans with 1. omega. apply Mset_l. apply Zle_ge. exact le_0_w. Qed.

Lemma xheex : forall (M : Mset) (h : Z_ (2 ^ Zlog_sup M)),
  in_Z_ (2 ^ w) h.

  intros M h. unfold in_Z_. split. apply le_0__Z. apply Zlt_le_trans with (2 ^ (Zlog_sup M)).
  apply lt_z__Z. apply Zle_pow_le. apply Zlog_sup_correct1. apply Zlt_le_trans with 1. omega. apply Mset_l.
  apply Zle_trans with (Zlog_sup (2 ^ w)).
  apply Zlog_sup_seq. apply Zlt_le_weak. apply Zle_lt_trans with (2 ^ (w - 1)). apply Mset_r.
  exact lt_2wm1_2w. rewrite Zlog_sup_pow. omega. exact le_0_w. Qed.

Lemma xleex : forall (u : Z_ (2 ^ w)),
  in_Z_ (2 ^ w) u.

  intro. unfold in_Z_. split. apply le_0__Z. apply lt_z__Z. Qed.

Theorem ModRed_eq2 : forall (M : Mset) (v : Z_ (2 ^ Zlog_sup M)) (u : Z_ (2 ^ w)),
  ModRed M
        (C M)
        (exist (in_Z_ (2 ^ w)) v (xheex M v))
        (exist (in_Z_ (2 ^ w)) u (xleex u))     =
  (2 ^ w * v + u) mod M.

  intros M v u. unfold ModRed. rewrite r'''_eq; simpl. rewrite Zmult_comm. trivial. apply Mset_l. apply Mset_r. trivial.
  elim (Zle_lt_or_eq 1 M). intro H. left. replace 1 with (0 * M + 1). 
  rewrite Zdiv_mult_plus. ring. omega. omega. omega. ring. intro H. right. auto. apply Mset_l.
  rewrite <- modred with (x := 2 ^ (Zlog_sup M + w) / M - 2 ^ w) (m := 2 ^ w).
  rewrite Zmod_minus_distr_r. rewrite Z_mod_same. apply f_equal2 with (f := Zmod). ring. trivial.
  apply Zlt_gt. exact lt02w. exact lt02w. elim (M'ex M). omega. elim (M'ex M). omega. apply lt_z__Z. Qed.

Close Scope Z_scope.
