
Require Import Arith.
Require Export Divides.
(* Divides:
Require Import Arith.
Require Import Peano_dec.
Require Import Compare_dec.
Require Import Wf_nat.
Require Export MiscRsa.

Inductive divides : nat -> nat -> Prop :=
    dividesDef : forall a b q : nat, b = q * a -> divides a b.
 
Lemma div_ref : forall a : nat, divides a a.
 
Lemma div_divides :
 forall x y : nat, (exists q : _, is_div x y q 0) -> divides y x.
 
Lemma divides_div :
 forall x y : nat, 0 < y -> divides y x -> exists q : _, is_div x y q 0.
 
Lemma divides_dec' :
 forall x y : nat,
 {(exists q : _, is_div x y q 0)} + {~ (exists q : _, is_div x y q 0)}.
 
Lemma divides_dec : forall x y : nat, {divides x y} + {~ divides x y}.
 
Lemma all_divides_O : forall n : nat, divides n 0.
 
Lemma SO_divides_all : forall n : nat, divides 1 n.
 
Lemma divides_plus1 :
 forall a b c : nat, divides a b -> divides a c -> divides a (b + c).
 
Lemma divides_plus2 :
 forall a b c : nat, divides a b -> divides a (b + c) -> divides a c.
 
Theorem divides_le : forall a b : nat, b <> 0 -> divides a b -> a <= b.
 
Lemma divides_antisym : forall a b : nat, divides a b -> divides b a -> a = b.
 
Lemma not_lt_div : forall a b : nat, 0 < b -> b < a -> ~ divides a b.

Inductive prime : nat -> Prop :=
    primeDef :
      forall a : nat,
      a <> 1 -> (forall b : nat, divides b a -> b <> 1 -> a = b) -> prime a.
 
Lemma not_prime_O : ~ prime 0.
 
Lemma not_prime_1 : ~ prime 1.
Hint Resolve div_ref all_divides_O SO_divides_all not_prime_O not_prime_1.
 
Lemma lt_prime : forall p : nat, prime p -> 1 < p.

Inductive is_gcd (a b c : nat) : Prop :=
    is_gcd_intro :
      divides c a ->
      divides c b ->
      (forall d : nat, divides d a -> divides d b -> divides d c) ->
      is_gcd a b c.
 
Lemma is_gcd_unic :
 forall a b c d : nat, is_gcd a b c -> is_gcd a b d -> c = d.
 
Lemma is_gcd_ref : forall x : nat, is_gcd x x x.
 
Lemma is_gcd_sym : forall a b c : nat, is_gcd a b c -> is_gcd b a c.
 
Lemma is_gcd_O' : forall a r : nat, is_gcd a 0 r -> a = r.
 
Lemma is_gcd_Ol : forall a : nat, is_gcd a 0 a.
 
Lemma is_gcd_Or : forall a : nat, is_gcd 0 a a.
 
Lemma prime_gcd : forall p n : nat, prime p -> ~ divides p n -> is_gcd n p 1.
 
Lemma gcd_rec :
 forall P : nat -> nat -> Set,
 (forall x : nat, P 0 x) ->
 (forall x : nat, P x 0) ->
 (forall a b : nat, P a b -> P a (b + a)) ->
 (forall a b : nat, P a b -> P (a + b) b) -> forall a b : nat, P a b.
 
Lemma gcd_ind :
 forall P : nat -> nat -> Prop,
 (forall x : nat, P 0 x) ->
 (forall x : nat, P x 0) ->
 (forall a b : nat, P a b -> P a (b + a)) ->
 (forall a b : nat, P a b -> P (a + b) b) -> forall a b : nat, P a b.
 
Inductive gcd_spec : nat -> nat -> nat -> Prop :=
  | gcd_spec_ex0 : forall a : nat, gcd_spec a 0 a
  | gcd_spec_ex1 : forall b : nat, gcd_spec 0 b b
  | gcd_spec_ex2 :
      forall a b c : nat, a < b -> gcd_spec a (b - a) c -> gcd_spec a b c
  | gcd_spec_ex3 :
      forall a b c : nat, b <= a -> gcd_spec (a - b) b c -> gcd_spec a b c.
Hint Resolve gcd_spec_ex0 gcd_spec_ex1.
 
Theorem gcd_inv_Or_aux : forall a b c : nat, gcd_spec a b c -> b = 0 -> a = c.
 
Theorem gcd_inv_Or : forall a b : nat, gcd_spec a 0 b -> a = b.
 
Theorem gcd_inv_Ol_aux : forall a b c : nat, gcd_spec a b c -> a = 0 -> b = c.
 
Theorem gcd_inv_Ol : forall a b : nat, gcd_spec 0 a b -> a = b.
 
Definition gcd' :=
  gcd_rec (fun _ _ : nat => nat) (fun x : nat => x) 
    (fun x : nat => x) (fun x y r : nat => r) (fun x y r : nat => r).
 
Lemma gcd_ex : forall a b : nat, {r : nat | gcd_spec a b r}.
 
Definition gcd (a b : nat) := proj1_sig (gcd_ex a b).
 
Lemma gcd_correct : forall a b : nat, gcd_spec a b (gcd a b).
Hint Resolve gcd_correct.
 
Lemma gcd_spec_uniq :
 forall a b r1 r2 : nat, gcd_spec a b r1 -> gcd_spec a b r2 -> r1 = r2.
 
Lemma gcd_correct2 : forall a b r : nat, gcd_spec a b r -> gcd a b = r.
 
Lemma gcd_def0l : forall x : nat, gcd 0 x = x.
 
Lemma gcd_def0r : forall x : nat, gcd x 0 = x.
 
Lemma gcd_def1 : forall x : nat, gcd x x = x.
 
Lemma gcd_def2 : forall a b : nat, gcd a b = gcd a (b + a).
 
Lemma gcd_def3 : forall a b : nat, gcd a b = gcd (a + b) b.
 
Lemma gcd_is_gcd : forall a b : nat, is_gcd a b (gcd a b).
 
Lemma preEuclid :
 forall a b c m : nat,
 divides c (m * a) -> divides c (m * b) -> divides c (m * gcd a b).
 
Theorem L_Euclides :
 forall x a b : nat, is_gcd x a 1 -> divides x (a * b) -> divides x b.
 
Lemma L_Euclides1 :
 forall p a b : nat,
 prime p -> divides p (a * b) -> ~ divides p a -> divides p b.
 
Lemma L_Euclides2 :
 forall p a b : nat,
 prime p -> divides p (a * b) -> divides p a \/ divides p b.
 
Theorem div_power_prime :
 forall p w n : nat, prime p -> divides p (power w n) -> divides p w.
Section CD.
Variable n : nat.

Inductive congruent : nat -> nat -> Prop :=
    congruentDef :
      forall a b u v : nat, a + u * n = b + v * n -> congruent a b.
 
Lemma cong_ref : forall a : nat, congruent a a.
 
Lemma cong_sym : forall a b : nat, congruent a b -> congruent b a.
 
Lemma cong_trans :
 forall a b c : nat, congruent a b -> congruent b c -> congruent a c.
 
Lemma cong_mult_O : forall a b : nat, congruent a 0 -> congruent (a * b) 0.
 
Lemma cong_plus :
 forall a b c d : nat,
 congruent a b -> congruent c d -> congruent (a + c) (b + d).
 
Lemma cong_add :
 forall a b c : nat, congruent a b -> congruent (a + c) (b + c).
 
Lemma cong_times :
 forall a b c : nat, congruent a b -> congruent (a * c) (b * c).
 
Lemma cong_mult :
 forall a b c d : nat,
 congruent a b -> congruent c d -> congruent (a * c) (b * d).
 
Lemma cong_pow :
 forall a b c : nat, congruent a b -> congruent (power a c) (power b c).
 
Theorem congruent' :
 forall a b : nat, b <= a -> congruent a b -> exists k : nat, a = k * n + b.
 
Lemma cong1_le : forall x : nat, 1 < n -> congruent x 1 -> 1 <= x.
 
Lemma divides_cong : forall x : nat, divides n x -> congruent 0 x.
 
Theorem cong_divides :
 forall a b : nat, b <= a -> congruent a b -> divides n (a - b).
End CD. *)
Require Export Binomials.
(* Binomials:
Require Import Arith.
Require Import Wf_nat.
Require Export MiscRsa.

Fixpoint sum_nm (n : nat) : nat -> (nat -> nat) -> nat :=
  fun (m : nat) (f : nat -> nat) =>
  match n with
  | O => f m
  | S n' => f m + sum_nm n' (S m) f
  end.

Lemma sum_nm_i :
 forall (m n : nat) (f : nat -> nat),
 sum_nm (S n) m f = f m + sum_nm n (S m) f.

Lemma sum_nm_f :
 forall (m n : nat) (f : nat -> nat),
 sum_nm (S n) m f = sum_nm n m f + f (m + S n).

Lemma sum_nm_ext :
 forall (m n : nat) (f g : nat -> nat),
 (forall x : nat, x <= n -> f (m + x) = g (m + x)) ->
 sum_nm n m f = sum_nm n m g.

Lemma sum_nm_add :
 forall (m n : nat) (f g : nat -> nat),
 sum_nm n m f + sum_nm n m g = sum_nm n m (fun i : nat => f i + g i).

Lemma sum_nm_times :
 forall (m n x : nat) (f : nat -> nat),
 x * sum_nm n m f = sum_nm n m (fun i : nat => x * f i).

Lemma inv_sum_nm :
 forall (P : nat -> Prop) (i n : nat) (f : nat -> nat),
 (forall a b : nat, P a -> P b -> P (a + b)) ->
 (forall x : nat, x <= n -> P (f (i + x))) -> P (sum_nm n i f).

Lemma t_sum_Svars :
 forall (n k : nat) (f : nat -> nat),
 sum_nm k n f = sum_nm k (S n) (fun i : nat => f (pred i)).

Fixpoint binomial (a : nat) : nat -> nat :=
  fun b : nat =>
  match a, b with
  | _, O => 1
  | O, S b' => 0
  | S a', S b' => binomial a' (S b') + binomial a' b'
  end.

Lemma binomial_def1 : forall n : nat, binomial n 0 = 1.

Lemma binomial_def2 : forall n m : nat, n < m -> binomial n m = 0.

Lemma binomial_def3 : forall n : nat, binomial n n = 1.

Lemma binomial_def4 :
 forall n k : nat,
 k < n -> binomial (S n) (S k) = binomial n (S k) + binomial n k.

Lemma binomial_fact :
 forall m n : nat,
 binomial (n + m) n * (factorial n * factorial m) = factorial (n + m).

Theorem exp_Pascal :
 forall a b n : nat,
 power (a + b) n =
 sum_nm n 0 (fun k : nat => binomial n k * (power a (n - k) * power b k)). *)

Lemma div_fact :
 forall p k : nat,
 prime p ->
 0 < k ->
 divides p (factorial k) -> exists j : nat, 0 < j /\ j <= k /\ divides p j.
Proof.
simple induction k.
simpl in |- *; intros H' H'0; absurd (0 < 0); auto with arith.
intros k' H' H'0 H'1 H'2; case (L_Euclides2 p (S k') (factorial k')); auto.
intros H'3; exists (S k'); auto.
intros H'3.
elim H';
 [ intros j E; elim E; intros H'7 H'8; elim H'8; intros H'9 H'10;
    try exact H'10
 | clear H'
 | clear H'
 | clear H' ]; auto.
exists j; split; auto.
generalize H'3; case k'; simpl in |- *; auto with arith.
intros H'4; absurd (prime 1); auto.
rewrite (divides_antisym 1 p); auto.
Qed.

Lemma p_div_bin :
 forall k p : nat, prime p -> 0 < k -> k < p -> divides p (binomial p k).
Proof.
intros k p; case p; auto.
intros H'; absurd (prime 0); auto.
intros p' H' H'0 H'1.
apply L_Euclides1 with (factorial k); auto.
apply L_Euclides1 with (factorial (S p' - k)); auto.
rewrite mult_assoc.
rewrite mult_comm.
pattern (S p') at 2 in |- *; rewrite (le_plus_minus k (S p'));
 auto with arith.
rewrite mult_comm with (m := factorial k); auto.
rewrite binomial_fact; auto.
rewrite <- le_plus_minus; auto with arith.
apply dividesDef with (q := factorial p'); rewrite mult_comm; auto.
red in |- *; intros H'2; elim (div_fact (S p') (S p' - k));
 [ intros j E; elim E; intros H'7 H'8; elim H'8; intros H'9 H'10; clear H'8 E
 | idtac
 | idtac
 | idtac ]; auto with arith.
absurd (divides (S p') j); auto.
apply not_lt_div; auto.
apply le_lt_trans with (m := S p' - k); auto with arith.
apply lt_minus_O_lt; auto.
red in |- *; intros H'2.
elim (div_fact (S p') k);
 [ intros j E; elim E; intros H'8 H'9; elim H'9; intros H'10 H'11;
    clear H'9 E
 | idtac
 | idtac
 | idtac ]; auto.
absurd (divides (S p') j); auto.
apply not_lt_div; auto.
apply le_lt_trans with (m := k); auto with arith.
Qed.

Lemma Fermat1 :
 forall x p : nat, prime p -> congruent p (power (x + 1) p) (power x p + 1).
Proof.
intros x p; case p; auto.
intros H'; absurd (prime 0); auto.
intros n; case n.
intros H'; absurd (prime 1); auto.
intros n0 H'.
rewrite (exp_Pascal x 1).
rewrite sum_nm_i.
rewrite sum_nm_f.
replace (binomial (S (S n0)) 0 * (power x (S (S n0) - 0) * power 1 0)) with
 (power x (S (S n0))).
replace
 (binomial (S (S n0)) (1 + S n0) *
  (power x (S (S n0) - (1 + S n0)) * power 1 (1 + S n0))) with 1.
rewrite plus_comm with (m := 1).
replace (power x (S (S n0)) + 1) with (power x (S (S n0)) + 1 + 0);
 auto with arith.
rewrite plus_assoc.
apply cong_plus; auto.
apply cong_ref; auto.
apply inv_sum_nm.
replace 0 with (0 + 0); auto.
intros; apply cong_plus; auto.
intros.
apply cong_mult_O.
apply cong_sym.
apply divides_cong.
apply p_div_bin; auto with arith.
simpl in |- *; auto with arith.
simpl in |- *; rewrite binomial_def3; simpl in |- *; auto.
repeat (rewrite binomial_def2; simpl in |- *; auto with arith).
rewrite <- minus_n_n; auto.
rewrite power_SO.
simpl in |- *; auto.
simpl in |- *; auto.
rewrite <- plus_n_O.
rewrite mult_1_r; auto.
Qed.

Lemma Fermat2 : forall x p : nat, prime p -> congruent p (power x p) x.
Proof.
intros x; elim x; auto.
intros p; case p; simpl in |- *; auto.
intros H'; absurd (prime 0); auto.
intros n H'; apply cong_ref; auto.
intros n H' p H'0.
apply (cong_trans p) with (b := power n p + 1).
replace (S n) with (n + 1); auto with arith.
apply Fermat1; auto.
rewrite plus_comm; simpl in |- *; auto.
replace (S n) with (n + 1).
apply cong_plus; auto.
apply cong_ref.
rewrite plus_comm; simpl in |- *; auto.
Qed.

Theorem Fermat :
 forall x p : nat,
 prime p -> ~ divides p x -> congruent p (power x (p - 1)) 1.
Proof.
intros x p H' H'0.
cut (x <= power x p); [ intros Lex | idtac ].
cut (divides p (power x p - x)); [ intros H'1; inversion_clear H'1 | idtac ].
cut (power x p = x * power x (p - 1)); [ intros Eqp | idtac ].
cut (x <> 0); [ intros nx | idtac ].
cut (divides x q); [ intros H2; inversion_clear H2 | idtac ].
apply congruentDef with (u := 0) (v := q0); simpl in |- *; auto.
rewrite <- plus_n_O.
apply eq_mult with x; auto.
rewrite <- Eqp; auto.
rewrite mult_comm; simpl in |- *.
rewrite mult_comm with (m := x).
rewrite mult_assoc.
rewrite (mult_comm x).
rewrite <- H0.
rewrite <- H.
apply le_plus_minus; auto.
apply L_Euclides with (a := p); auto.
apply prime_gcd; auto.
rewrite mult_comm; rewrite <- H.
apply dividesDef with (q := power x (p - 1) - 1); auto.
rewrite mult_minus_distr_r.
apply f_equal2 with (A1 := nat) (A2 := nat); simpl in |- *; auto.
rewrite mult_comm; auto.
red in |- *; intros H'1; case H'0; rewrite H'1; auto.
generalize H'; case p; simpl in |- *; auto with arith.
intros H'1; absurd (prime 0); auto.
apply cong_divides; auto.
apply Fermat2; auto.
generalize H'; case p; auto.
intros H'1; absurd (prime 0); auto.
intros n H'1.
apply power_le; auto with arith.
Qed.
