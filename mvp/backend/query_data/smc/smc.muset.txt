
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import ZArith NArith Nnat Ndec Ndigits.
From IntMap Require Import Map.
From IntMap Require Import Allmaps.
Require Import Wf_nat.
Require Import EqNat.
Require Import Peano_dec.
Require Import List.
Require Import Ensembles.
Require Import Finite_sets.
Require Import Finite_sets_facts.
Require Import Image.
Require Import Compare.
 
Require Import misc.
(* misc:
Require Import Compare.
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import ZArith NArith Nnat Ndec Ndigits.
From IntMap Require Import Allmaps.
Require Import List.

Section BDDmisc.

Definition BDDvar := ad.

Definition BDDcompare (x y : BDDvar) :=
  match x, y with
  | N0, N0 => Datatypes.Eq
  | N0, Npos _ => Datatypes.Lt
  | Npos _, N0 => Datatypes.Gt
  | Npos p1, Npos p2 => Pcompare p1 p2 Datatypes.Eq
  end.

Definition ad_S (a : ad) :=
  match a with
  | N0 => Npos 1
  | Npos p => Npos (Psucc p)
  end.

Definition max (m n : nat) := if leb m n then n else m.

Definition BDDvar_max (x y : BDDvar) := if Nleb x y then y else x.

Inductive no_dup_list (A : Set) : list A -> Prop :=
  | no_dup_nil : no_dup_list A nil
  | no_dup_cons :
      forall (a : A) (l : list A),
      ~ In a l -> no_dup_list _ l -> no_dup_list _ (a :: l).

Lemma ad_S_is_S : forall a : ad, nat_of_N (ad_S a) = S (nat_of_N a).

Lemma relation_sum :
 forall r : Datatypes.comparison,

Lemma BDD_EGAL_complete :
 forall x y : BDDvar, BDDcompare x y = Datatypes.Eq -> x = y.

Lemma BDDcompare_lt :
 forall x y : BDDvar,
 BDDcompare x y = Datatypes.Lt -> nat_of_N x < nat_of_N y.

Lemma BDDlt_compare :
 forall x y : BDDvar,
 nat_of_N x < nat_of_N y -> BDDcompare x y = Datatypes.Lt.

Lemma BDDcompare_trans :
 forall x y z : BDDvar,
 BDDcompare x y = Datatypes.Lt ->

Lemma BDDcompare_sup_inf :
 forall x y : BDDvar,
 BDDcompare x y = Datatypes.Gt -> BDDcompare y x = Datatypes.Lt.

Lemma lt_trans_1 : forall x y z : nat, x < y -> y < S z -> x < z.

Lemma BDDcompare_1 :
 forall x y : BDDvar,
 BDDcompare x y = Datatypes.Lt ->

Lemma andb3_lemma :
 forall b1 b2 b3 : bool,
 b1 && (b2 && b3) = true -> b1 = true /\ b2 = true /\ b3 = true.

Lemma andb3_lemma_1 :
 forall x x0 y y0 z z0 : ad,
 (x, (y, z)) <> (x0, (y0, z0)) ->
 Neqb x x0 && (Neqb y y0 && Neqb z z0) = false.

Lemma ad_S_le_then_neq :
 forall x y : ad, Nleb (ad_S x) y = true -> Neqb x y = false.

Lemma BDD_EGAL_correct : forall x : BDDvar, BDDcompare x x = Datatypes.Eq.

Lemma BDDcompare_inf_sup :
 forall x y : BDDvar,
 BDDcompare x y = Datatypes.Lt -> BDDcompare y x = Datatypes.Gt.

Lemma ad_S_compare :
 forall x y : ad, BDDcompare x y = BDDcompare (ad_S x) (ad_S y).

Lemma prod_sum :
 forall (A B : Set) (p : A * B), exists a : A, (exists b : B, p = (a, b)).

Lemma lt_max_1_2 :
 forall x1 y1 x2 y2 : nat, x1 < x2 -> y1 < y2 -> max x1 y1 < max x2 y2.

Lemma lt_max_1 :
 forall x1 y1 x2 y2 : nat, x1 < x2 -> y1 < x2 -> max x1 y1 < max x2 y2.

Lemma lt_max_2 :
 forall x1 y1 x2 y2 : nat, x1 < y2 -> y1 < y2 -> max x1 y1 < max x2 y2.

Lemma max_x_x_eq_x : forall x : nat, max x x = x.

Lemma BDDvar_le_max_2 : forall x y : BDDvar, Nleb x (BDDvar_max y x) = true.

Lemma BDDvar_max_max :
 forall x y : BDDvar,
 nat_of_N (BDDvar_max x y) = max (nat_of_N x) (nat_of_N y).

Lemma BDDvar_le_max_1 : forall x y : BDDvar, Nleb x (BDDvar_max x y) = true.

Lemma BDDvar_max_inf :
 forall x y : BDDvar, BDDcompare x y = Datatypes.Lt -> BDDvar_max x y = y.

Lemma BDDvar_max_comm : forall x y : BDDvar, BDDvar_max x y = BDDvar_max y x.

Lemma nat_gt_1_lemma : forall n : nat, n <> 0 -> n <> 1 -> 2 <= n.

Lemma ad_gt_1_lemma :
 forall x : ad, x <> N0 -> x <> Npos 1 -> Nleb (Npos 2) x = true.

Lemma Nltb_lebmma :
 forall a b : ad, Nleb a b = false -> Nleb (ad_S b) a = true.

Lemma eq_ad_S_eq :
 forall a b : ad, Neqb (ad_S a) (ad_S b) = true -> Neqb a b = true.

Lemma ad_S_neq_N0 : forall a : ad, Neqb (ad_S a) N0 = false.

Lemma list_sum :
 forall (A : Set) (l : list A),
 l = nil \/ (exists a : A, (exists l' : list A, l = a :: l')).

Lemma no_dup_sum :
 forall (A : Set) (l : list A) (H : no_dup_list _ l),
 l = nil \/
 (exists a : A,
    (exists l0 : list A, ~ In a l0 /\ no_dup_list _ l0 /\ l = a :: l0)).

Lemma no_dup_cons_no_dup :
 forall (A : Set) (l : list A) (a : A),
 no_dup_list _ (a :: l) -> no_dup_list _ l.

Lemma no_dup_cons_no_in :
 forall (A : Set) (l : list A) (a : A), no_dup_list _ (a :: l) -> ~ In a l.

End BDDmisc. *)
Require Import bool_fun.
(* bool_fun:
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import ZArith NArith Nnat Ndec Ndigits.
From IntMap Require Import Allmaps.

Require Import misc.

Section Bool_fun.

Definition var_env := BDDvar -> bool.

Definition bool_fun := var_env -> bool.

Definition bool_fun_eq (bf1 bf2 : bool_fun) :=
  forall vb : var_env, bf1 vb = bf2 vb.

Definition bool_fun_zero (vb : var_env) := false.

Definition bool_fun_one (vb : var_env) := true.

Definition bool_fun_neg (bf : bool_fun) : bool_fun :=
  fun vb : var_env => negb (bf vb).

Definition bool_fun_or (bf1 bf2 : bool_fun) : bool_fun :=
  fun vb : var_env => bf1 vb || bf2 vb.

Definition bool_fun_and (bf1 bf2 : bool_fun) : bool_fun :=
  fun vb : var_env => bf1 vb && bf2 vb.

Definition bool_fun_impl (bf1 bf2 : bool_fun) : bool_fun :=
  fun vb : var_env => implb (bf1 vb) (bf2 vb).

Definition bool_fun_iff (bf1 bf2 : bool_fun) : bool_fun :=
  fun vb : var_env => eqb (bf1 vb) (bf2 vb).

Definition bool_fun_if (x : BDDvar) (bf1 bf2 : bool_fun) : bool_fun :=
  fun vb : var_env => ifb (vb x) (bf1 vb) (bf2 vb). 

Definition bool_fun_var (x : BDDvar) : bool_fun := fun vb : var_env => vb x.

Definition augment (vb : var_env) (x : BDDvar) (b : bool) : var_env :=
  fun y : BDDvar => if Neqb x y then b else vb y.

Definition bool_fun_restrict (bf : bool_fun) (x : BDDvar) 
  (b : bool) : bool_fun := fun vb : var_env => bf (augment vb x b).

Definition bool_fun_independent (bf : bool_fun) (x : BDDvar) :=
  forall b : bool, bool_fun_eq (bool_fun_restrict bf x b) bf.

Definition bool_fun_forall (x : BDDvar) (bf : bool_fun) :=
  bool_fun_and (bool_fun_restrict bf x true) (bool_fun_restrict bf x false).

Definition bool_fun_ex (x : BDDvar) (bf : bool_fun) :=
  bool_fun_or (bool_fun_restrict bf x true) (bool_fun_restrict bf x false).

Definition bool_fun_ext (bf : bool_fun) :=
  forall vb vb' : var_env,
  (forall x : BDDvar, vb x = vb' x) -> bf vb = bf vb'.

Inductive bool_expr : Set :=
  | Zero : bool_expr
  | One : bool_expr
  | Var : BDDvar -> bool_expr
  | Neg : bool_expr -> bool_expr
  | Or : bool_expr -> bool_expr -> bool_expr
  | ANd : bool_expr -> bool_expr -> bool_expr
  | Impl : bool_expr -> bool_expr -> bool_expr
  | Iff : bool_expr -> bool_expr -> bool_expr.

Fixpoint bool_fun_of_bool_expr (be : bool_expr) : bool_fun :=
  match be with
  | Zero => bool_fun_zero
  | One => bool_fun_one
  | Var x => bool_fun_var x
  | Neg be' => bool_fun_neg (bool_fun_of_bool_expr be')
  | Or be1 be2 =>
      bool_fun_or (bool_fun_of_bool_expr be1) (bool_fun_of_bool_expr be2)
  | ANd be1 be2 =>
      bool_fun_and (bool_fun_of_bool_expr be1) (bool_fun_of_bool_expr be2)
  | Impl be1 be2 =>
      bool_fun_impl (bool_fun_of_bool_expr be1) (bool_fun_of_bool_expr be2)
  | Iff be1 be2 =>
      bool_fun_iff (bool_fun_of_bool_expr be1) (bool_fun_of_bool_expr be2)
  end.

Lemma bool_fun_eq_refl : forall bf : bool_fun, bool_fun_eq bf bf.

Lemma bool_fun_eq_sym :
 forall bf1 bf2 : bool_fun, bool_fun_eq bf1 bf2 -> bool_fun_eq bf2 bf1.

Lemma bool_fun_eq_trans :
 forall bf1 bf2 bf3 : bool_fun,
 bool_fun_eq bf1 bf2 -> bool_fun_eq bf2 bf3 -> bool_fun_eq bf1 bf3.

Lemma bool_fun_neg_preserves_eq :
 forall bf1 bf2 : bool_fun,
 bool_fun_eq bf1 bf2 -> bool_fun_eq (bool_fun_neg bf1) (bool_fun_neg bf2).

Lemma bool_fun_or_preserves_eq :
 forall bf1 bf1' bf2 bf2' : bool_fun,
 bool_fun_eq bf1 bf1' ->
 bool_fun_eq bf2 bf2' ->
 bool_fun_eq (bool_fun_or bf1 bf2) (bool_fun_or bf1' bf2').

Lemma bool_fun_if_preserves_eq :
 forall (x : BDDvar) (bf1 bf2 bf1' bf2' : bool_fun),
 bool_fun_eq bf1 bf1' ->
 bool_fun_eq bf2 bf2' ->
 bool_fun_eq (bool_fun_if x bf1 bf2) (bool_fun_if x bf1' bf2').

Lemma bool_fun_and_preserves_eq :
 forall bf1 bf1' bf2 bf2' : bool_fun,
 bool_fun_eq bf1 bf1' ->
 bool_fun_eq bf2 bf2' ->
 bool_fun_eq (bool_fun_and bf1 bf2) (bool_fun_and bf1' bf2').

Lemma bool_fun_impl_preserves_eq :
 forall bf1 bf1' bf2 bf2' : bool_fun,
 bool_fun_eq bf1 bf1' ->
 bool_fun_eq bf2 bf2' ->
 bool_fun_eq (bool_fun_impl bf1 bf2) (bool_fun_impl bf1' bf2').

Lemma bool_fun_iff_preserves_eq :
 forall bf1 bf1' bf2 bf2' : bool_fun,
 bool_fun_eq bf1 bf1' ->
 bool_fun_eq bf2 bf2' ->
 bool_fun_eq (bool_fun_iff bf1 bf2) (bool_fun_iff bf1' bf2').

Lemma bool_fun_forall_preserves_eq :
 forall (bf1 bf2 : bool_fun) (x : BDDvar),
 bool_fun_eq bf1 bf2 ->
 bool_fun_eq (bool_fun_forall x bf1) (bool_fun_forall x bf2).

Lemma bool_fun_ex_preserves_eq :
 forall (bf1 bf2 : bool_fun) (x : BDDvar),
 bool_fun_eq bf1 bf2 -> bool_fun_eq (bool_fun_ex x bf1) (bool_fun_ex x bf2).

Lemma bool_fun_neg_zero :
 bool_fun_eq (bool_fun_neg bool_fun_zero) bool_fun_one.

Lemma bool_fun_neg_one :
 bool_fun_eq (bool_fun_neg bool_fun_one) bool_fun_zero.

Lemma bool_fun_and_lemma :
 forall bf1 bf2 : bool_fun,
 bool_fun_eq (bool_fun_and bf1 bf2)
   (bool_fun_neg (bool_fun_or (bool_fun_neg bf1) (bool_fun_neg bf2))).

Lemma bool_fun_impl_lemma :
 forall bf1 bf2 : bool_fun,
 bool_fun_eq (bool_fun_impl bf1 bf2) (bool_fun_or (bool_fun_neg bf1) bf2).

Lemma bool_fun_iff_lemma :
 forall bf1 bf2 : bool_fun,
 bool_fun_eq (bool_fun_iff bf1 bf2)
   (bool_fun_impl (bool_fun_or bf1 bf2) (bool_fun_and bf1 bf2)).

Lemma bool_fun_ex_lemma :
 forall (bf : bool_fun) (x : BDDvar),
 bool_fun_eq (bool_fun_ex x bf)
   (bool_fun_neg (bool_fun_forall x (bool_fun_neg bf))).

Lemma bool_fun_var_lemma :
 forall x : BDDvar,
 bool_fun_eq (bool_fun_var x) (bool_fun_if x bool_fun_one bool_fun_zero).

Lemma bool_fun_eq_neg_eq :
 forall bf1 bf2 : bool_fun,
 bool_fun_eq (bool_fun_neg bf1) (bool_fun_neg bf2) -> bool_fun_eq bf1 bf2.

Lemma bool_fun_neg_orthogonal :
 forall (x : BDDvar) (bf1 bf2 : bool_fun),
 bool_fun_eq (bool_fun_neg (bool_fun_if x bf1 bf2))
   (bool_fun_if x (bool_fun_neg bf1) (bool_fun_neg bf2)).

Lemma bool_fun_or_zero :
 forall bf : bool_fun, bool_fun_eq (bool_fun_or bf bool_fun_zero) bf.

Lemma bool_fun_or_one :
 forall bf : bool_fun, bool_fun_eq (bool_fun_or bf bool_fun_one) bool_fun_one.

Lemma bool_fun_or_comm :
 forall bf1 bf2 : bool_fun,
 bool_fun_eq (bool_fun_or bf1 bf2) (bool_fun_or bf2 bf1).

Lemma bool_fun_and_comm :
 forall bf1 bf2 : bool_fun,
 bool_fun_eq (bool_fun_and bf1 bf2) (bool_fun_and bf2 bf1).

Lemma bool_fun_and_idempotent :
 forall bf : bool_fun, bool_fun_eq (bool_fun_and bf bf) bf.

Lemma bool_fun_or_orthogonal :
 forall (x : BDDvar) (bf1 bf2 bf1' bf2' : bool_fun),
 bool_fun_eq (bool_fun_or (bool_fun_if x bf1 bf2) (bool_fun_if x bf1' bf2'))
   (bool_fun_if x (bool_fun_or bf1 bf1') (bool_fun_or bf2 bf2')).

Lemma bool_fun_or_orthogonal_right :
 forall (x : BDDvar) (bf bf1' bf2' : bool_fun),
 bool_fun_eq (bool_fun_or bf (bool_fun_if x bf1' bf2'))
   (bool_fun_if x (bool_fun_or bf bf1') (bool_fun_or bf bf2')).

Lemma bool_fun_or_orthogonal_left :
 forall (x : BDDvar) (bf1 bf2 bf' : bool_fun),
 bool_fun_eq (bool_fun_or (bool_fun_if x bf1 bf2) bf')
   (bool_fun_if x (bool_fun_or bf1 bf') (bool_fun_or bf2 bf')).

Lemma bool_fun_and_orthogonal :
 forall (x : BDDvar) (bf1 bf2 bf1' bf2' : bool_fun),
 bool_fun_eq (bool_fun_and (bool_fun_if x bf1 bf2) (bool_fun_if x bf1' bf2'))
   (bool_fun_if x (bool_fun_and bf1 bf1') (bool_fun_and bf2 bf2')).

Lemma bool_fun_forall_independent :
 forall (x : BDDvar) (bf : bool_fun),
 bool_fun_independent bf x -> bool_fun_eq (bool_fun_forall x bf) bf.

Lemma bool_fun_forall_zero :
 forall x : BDDvar,
 bool_fun_eq (bool_fun_forall x bool_fun_zero) bool_fun_zero.

Lemma bool_fun_forall_one :
 forall x : BDDvar, bool_fun_eq (bool_fun_forall x bool_fun_one) bool_fun_one.

Lemma bool_fun_restrict_zero :
 forall (x : BDDvar) (b : bool),
 bool_fun_eq (bool_fun_restrict bool_fun_zero x b) bool_fun_zero.

Lemma bool_fun_restrict_one :
 forall (x : BDDvar) (b : bool),
 bool_fun_eq (bool_fun_restrict bool_fun_one x b) bool_fun_one.

Lemma bool_fun_restrict_preserves_eq :
 forall (bf1 bf2 : bool_fun) (x : BDDvar) (b : bool),
 bool_fun_eq bf1 bf2 ->
 bool_fun_eq (bool_fun_restrict bf1 x b) (bool_fun_restrict bf2 x b).

Lemma bool_fun_independent_zero :
 forall x : BDDvar, bool_fun_independent bool_fun_zero x.

Lemma bool_fun_independent_one :
 forall x : BDDvar, bool_fun_independent bool_fun_one x.

Lemma bool_fun_eq_independent :
 forall (bf1 bf2 : bool_fun) (x : BDDvar),
 bool_fun_eq bf1 bf2 ->
 bool_fun_independent bf1 x -> bool_fun_independent bf2 x.

Lemma bool_fun_if_restrict_true :
 forall (bf1 bf2 : bool_fun) (x : BDDvar),
 bool_fun_eq (bool_fun_restrict (bool_fun_if x bf1 bf2) x true)
   (bool_fun_restrict bf1 x true).

Lemma bool_fun_if_restrict_false :
 forall (bf1 bf2 : bool_fun) (x : BDDvar),
 bool_fun_eq (bool_fun_restrict (bool_fun_if x bf1 bf2) x false)
   (bool_fun_restrict bf2 x false).

Lemma bool_fun_if_restrict :
 forall (bf1 bf2 : bool_fun) (x y : BDDvar) (b : bool),
 Neqb x y = false ->
 bool_fun_eq (bool_fun_restrict (bool_fun_if x bf1 bf2) y b)
   (bool_fun_if x (bool_fun_restrict bf1 y b) (bool_fun_restrict bf2 y b)).

Lemma bool_fun_if_restrict_true_independent :
 forall (bf1 bf2 : bool_fun) (x : BDDvar),
 bool_fun_independent bf1 x ->
 bool_fun_eq (bool_fun_restrict (bool_fun_if x bf1 bf2) x true) bf1.

Lemma bool_fun_if_restrict_false_independent :
 forall (bf1 bf2 : bool_fun) (x : BDDvar),
 bool_fun_independent bf2 x ->
 bool_fun_eq (bool_fun_restrict (bool_fun_if x bf1 bf2) x false) bf2.

Lemma bool_fun_forall_orthogonal :
 forall (x u : BDDvar) (bf1 bf2 : bool_fun),
 Neqb x u = false ->
 bool_fun_eq (bool_fun_forall u (bool_fun_if x bf1 bf2))
   (bool_fun_if x (bool_fun_forall u bf1) (bool_fun_forall u bf2)).

Lemma bool_fun_independent_if :
 forall (x y : BDDvar) (bf1 bf2 : bool_fun),
 bool_fun_independent bf1 x ->
 bool_fun_independent bf2 x ->
 Neqb x y = false -> bool_fun_independent (bool_fun_if y bf1 bf2) x.

Lemma bool_fun_forall_if_egal :
 forall (x : BDDvar) (bf1 bf2 : bool_fun),
 bool_fun_independent bf1 x ->
 bool_fun_independent bf2 x ->
 bool_fun_eq (bool_fun_forall x (bool_fun_if x bf1 bf2))
   (bool_fun_and bf1 bf2).

Lemma bool_fun_if_eq_1 :
 forall (bf1 bf2 : bool_fun) (x : BDDvar),
 bool_fun_eq bf1 bf2 -> bool_fun_eq (bool_fun_if x bf1 bf2) bf1.

Lemma bool_fun_if_eq_2 :
 forall (bf1 bf2 : bool_fun) (x : BDDvar),
 bool_fun_eq bf1 bf2 -> bool_fun_eq (bool_fun_if x bf1 bf2) bf2.

Lemma bool_fun_ext_zero : bool_fun_ext bool_fun_zero.

Lemma bool_fun_ext_one : bool_fun_ext bool_fun_one.

Lemma bool_fun_ext_if :
 forall (bf1 bf2 : bool_fun) (x : BDDvar),
 bool_fun_ext bf1 -> bool_fun_ext bf2 -> bool_fun_ext (bool_fun_if x bf1 bf2).

End Bool_fun. *)
Require Import myMap.
(* myMap:
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import ZArith NArith Nnat Ndec Ndigits.
From IntMap Require Import Map.
From IntMap Require Import Allmaps.
Require Import Relation_Definitions.
Require Import List.

Require Import misc.

Section my_MapFold.

Variable M : Set.
Variable neutral : M.
Variable op : M -> M -> M.
Variable R : relation M.

Definition F (A : Set) (f : ad -> A -> M) (r : ad * A) 
  (m : M) := let (a, y) := r in op (f a y) m.

Hypothesis eq_R : equiv _ R.
Hypothesis op_assoc : forall a b c : M, R (op (op a b) c) (op a (op b c)).
Hypothesis op_neutral_left : forall a : M, R (op neutral a) a.
Hypothesis op_neutral_right : forall a : M, R (op a neutral) a.
Hypothesis
  op_eq : forall a b a1 b1 : M, R a a1 -> R b b1 -> R (op a b) (op a1 b1).

Lemma op_eq_2 : forall a b b1 : M, R b b1 -> R (op a b) (op a b1).

Lemma my_fold_right_aapp :
 forall (A : Set) (f : ad -> A -> M) (l l' : alist A),
 R (fold_right (F A f) neutral (aapp _ l l'))
   (op (fold_right (F A f) neutral l) (fold_right (F A f) neutral l')).

Lemma myMapFold_as_fold_1 :
 forall (A : Set) (f : ad -> A -> M) (m : Map A) (pf : ad -> ad),
 R (MapFold1 _ M neutral op f pf m)
   (fold_right (fun (r : ad * A) (m : M) => let (a, y) := r in op (f a y) m)
      neutral
      (MapFold1 _ (alist A) (anil A) (aapp A)
         (fun (a : ad) (y : A) => acons _ (a, y) (anil _)) pf m)).

Lemma myMapFold_as_fold :
 forall (A : Set) (f : ad -> A -> M) (m : Map A),
 R (MapFold _ M neutral op f m)
   (fold_right (fun (r : ad * A) (m : M) => let (a, y) := r in op (f a y) m)
      neutral (alist_of_Map _ m)).

End my_MapFold.

Lemma eqmap_equiv : forall A : Set, equiv _ (eqmap A).

Lemma MapMerge_assoc :
 forall (A : Set) (a b c : Map A),
 eqmap _ (MapMerge _ (MapMerge _ a b) c) (MapMerge _ a (MapMerge _ b c)).

Lemma MapMerge_neutral_left :
 forall (A : Set) (m : Map A), eqmap _ (MapMerge _ (M0 A) m) m.

Lemma MapMerge_neutral_right :
 forall (A : Set) (m : Map A), eqmap _ (MapMerge _ m (M0 _)) m.

Lemma MapMerge_eq :
 forall (A : Set) (a a1 b b1 : Map A),
 eqmap _ a a1 -> eqmap _ b b1 -> eqmap _ (MapMerge _ a b) (MapMerge _ a1 b1).

Lemma myMapFold_as_fold_2 :
 forall (A B : Set) (f : ad -> A -> Map B) (m : Map A),
 eqmap _ (MapFold _ (Map B) (M0 _) (MapMerge _) f m)
   (fold_right
      (fun (r : ad * A) (m : Map B) =>
       let (a, y) := r in MapMerge _ (f a y) m) (M0 _) 
      (alist_of_Map _ m)).

Lemma my_alist_of_map_lemma_1 :
 forall (A : Set) (m : Map A) (a : ad) (y : A),
 MapGet _ m a = Some y -> In (a, y) (alist_of_Map _ m).

Lemma my_alist_of_map_lemma_2 :
 forall (A : Set) (m : Map A) (pf fp : ad -> ad),
 (forall a : ad, fp (pf a) = a) ->
 forall (a : ad) (y : A),
 In (a, y)
   (MapFold1 _ _ (anil _) (aapp _)
      (fun (a : ad) (y : A) => acons _ (a, y) (anil _)) pf m) ->
 MapGet _ m (fp a) = Some y /\ pf (fp a) = a.

Lemma my_alist_of_map_lemma_3 :
 forall (A : Set) (m : Map A) (a : ad) (y : A),
 In (a, y) (alist_of_Map _ m) -> MapGet _ m a = Some y.

Definition f_OK (A B : Set) (f : ad -> A -> Map B) :=
  forall (a a1 a2 : ad) (y1 y2 : A),
  in_dom _ a (f a1 y1) = true -> in_dom _ a (f a2 y2) = true -> a1 = a2.

Definition no_dup_alist (A : Set) (l : alist A) :=
  forall (a : ad) (y1 y2 : A), In (a, y1) l -> In (a, y2) l -> y1 = y2.

Lemma no_dup_alist_of_Map :
 forall (A : Set) (m : Map A), no_dup_alist _ (alist_of_Map _ m).

Lemma my_fold_right_lemma :
 forall (A B : Set) (f : ad -> A -> Map B) (l : alist A),
 f_OK _ _ f ->
 no_dup_alist _ l ->
 forall (a : ad) (y : B),
 MapGet _
   (fold_right
      (fun (r : ad * A) (m0 : Map B) =>
       let (a0, y0) := r in MapMerge B (f a0 y0) m0) 
      (M0 B) l) a = Some y <->
 (exists a1 : ad,
    (exists y1 : A, In (a1, y1) l /\ MapGet _ (f a1 y1) a = Some y)).

Lemma myMapFold_lemma :
 forall (A B : Set) (f : ad -> A -> Map B) (m : Map A),
 f_OK _ _ f ->
 forall (a : ad) (y : B),
 MapGet _ (MapFold _ _ (M0 _) (MapMerge _) f m) a = Some y <->
 (exists a1 : ad,
    (exists y1 : A,
       MapGet _ m a1 = Some y1 /\ MapGet _ (f a1 y1) a = Some y)).

Section My_Map.

Variable A B : Set.

Fixpoint Mapn (n : nat) : Set :=
  match n with
  | O => A
  | S m => Map (Mapn m)
  end.

Definition MapGet2 (m : Map (Map A)) (a b : ad) :=
  match MapGet _ m a with
  | None => None 
  | Some m' => MapGet _ m' b
  end.

Definition MapGet3 (m : Map (Map (Map A))) (a b c : ad) :=
  match MapGet _ m a with
  | None => None
  | Some m' => MapGet2 m' b c
  end.

Definition MapPut2 (m : Map (Map A)) (a b : ad) (c : A) :=
  match MapGet _ m a with
  | Some m' => MapPut _ m a (MapPut _ m' b c)
  | None => MapPut _ m a (M1 _ b c)
  end.

Definition MapPut3 (m : Map (Map (Map A))) (a b c : ad) 
  (d : A) :=
  match MapGet _ m a with
  | Some m' => MapPut _ m a (MapPut2 m' b c d)
  | None => MapPut _ m a (M1 _ b (M1 _ c d))
  end.

Lemma MapPut2_semantics :
 forall (m : Map (Map A)) (a b a1 b1 : ad) (c : A),
 MapGet2 (MapPut2 m a b c) a1 b1 =
 (if Neqb a a1 && Neqb b b1 then Some c else MapGet2 m a1 b1).
 
Lemma MapPut3_semantics :
 forall (m : Map (Map (Map A))) (a b c a1 b1 c1 : ad) (d : A),
 MapGet3 (MapPut3 m a b c d) a1 b1 c1 =
 (if Neqb a a1 && (Neqb b b1 && Neqb c c1)
  then Some d
  else MapGet3 m a1 b1 c1).

Lemma makeM2_MapDom_lemma :
 forall (A : Set) (m1 m2 : Map A),
 makeM2 unit (MapDom A m1) (MapDom A m2) = MapDom A (makeM2 A m1 m2).

Fixpoint MapDomRestrTo_DomBy (m : Map A) : Map B -> Map A * Map unit :=
  match m with
  | M0 => fun _ : Map B => (M0 A, M0 unit)
  | M1 a y =>
      fun m' : Map B =>
      match MapGet B m' a with
      | None => (M0 A, M1 unit a tt)
      | _ => (m, M0 unit)
      end
  | M2 m1 m2 =>
      fun m' : Map B =>
      match m' with
      | M0 => (M0 A, MapDom A m)
      | M1 a' y' =>
          (match MapGet A m a' with
           | None => M0 A
           | Some y => M1 A a' y
           end, MapDom A (MapRemove A m a'))
      | M2 m'1 m'2 =>
          match MapDomRestrTo_DomBy m1 m'1 with
          | (x1, y1) =>
              match MapDomRestrTo_DomBy m2 m'2 with
              | (x2, y2) => (makeM2 A x1 x2, makeM2 unit y1 y2)
              end
          end
      end
  end.

Lemma MapDomRestrTo_DomBy_lemma_1 :
 forall (m : Map A) (m' : Map B),
 fst (MapDomRestrTo_DomBy m m') = MapDomRestrTo A B m m'.

Lemma MapDomRestrTo_DomBy_lemma_2 :
 forall (m : Map A) (m' : Map B),
 snd (MapDomRestrTo_DomBy m m') = MapDom A (MapDomRestrBy A B m m').

Fixpoint map_app_list1 (pf : ad -> ad) (l : list ad) 
 (m : Map A) {struct m} : list ad :=
  match m with
  | M0 => l
  | M1 a y => pf a :: l
  | M2 m1 m2 =>
      map_app_list1 (fun a0 : ad => pf (Ndouble_plus_one a0))
        (map_app_list1 (fun a0 : ad => pf (Ndouble a0)) l m1) m2
  end.

Lemma map_app_list1_lemma_1 :
 forall (m : Map A) (pf : ad -> ad) (l : list ad) (a : ad),
 In a l -> In a (map_app_list1 pf l m).

Lemma map_app_list1_lemma_2 :
 forall (m : Map A) (pf fp : ad -> ad) (l : list ad),
 (forall a0 : ad, fp (pf a0) = a0) ->
 forall a : ad,
 In a (map_app_list1 pf l m) ->
 In a l \/ in_dom _ (fp a) m = true /\ pf (fp a) = a.

Lemma map_app_list1_lemma_3 :
 forall (m : Map A) (pf fp : ad -> ad) (l : list ad),
 (forall a0 : ad, fp (pf a0) = a0) ->
 no_dup_list _ l ->
 (forall a : ad, in_dom _ a m = true -> ~ In (pf a) l) ->
 no_dup_list _ (map_app_list1 pf l m).

Lemma map_app_list1_lemma_4 :
 forall (m : Map A) (pf : ad -> ad) (l : list ad) (a : ad),
 in_dom _ a m = true -> In (pf a) (map_app_list1 pf l m).

Fixpoint MapDomRestrByApp1 (pf : ad -> ad) (l : list ad) 
 (m : Map A) {struct m} : Map B -> list ad :=
  match m with
  | M0 => fun _ : Map B => l
  | M1 a y =>
      fun m' : Map B =>
      match MapGet B m' a with
      | None => pf a :: l
      | _ => l
      end
  | M2 m1 m2 =>
      fun m' : Map B =>
      match m' with
      | M0 => map_app_list1 pf l m
      | M1 a' y' => map_app_list1 pf l (MapRemove A m a')
      | M2 m'1 m'2 =>
          MapDomRestrByApp1 (fun a0 : ad => pf (Ndouble_plus_one a0))
            (MapDomRestrByApp1 (fun a0 : ad => pf (Ndouble a0)) l m1 m'1)
            m2 m'2
      end
  end.

Lemma MapDomRestrByApp1_lemma_1 :
 forall (m : Map A) (m' : Map B) (l : list ad) (pf : ad -> ad) (a : ad),
 In a l -> In a (MapDomRestrByApp1 pf l m m').

Lemma MapDomRestrByApp1_lemma_2 :
 forall (m : Map A) (m' : Map B) (l : list ad) (pf : ad -> ad) (a : ad),
 in_dom _ a m = true ->
 in_dom _ a m' = false -> In (pf a) (MapDomRestrByApp1 pf l m m').

Lemma MapDomRestrByApp1_lemma_3 :
 forall (m : Map A) (m' : Map B) (l : list ad) (pf fp : ad -> ad),
 (forall a : ad, fp (pf a) = a) ->
 forall a : ad,
 In a (MapDomRestrByApp1 pf l m m') ->
 In a l \/
 in_dom _ (fp a) m = true /\ in_dom _ (fp a) m' = false /\ pf (fp a) = a.

Lemma MapDomRestrByApp1_lemma_4 :
 forall (m : Map A) (m' : Map B) (l : list ad) (pf fp : ad -> ad),
 (forall a : ad, fp (pf a) = a) ->
 (forall a : ad,
  in_dom _ a m = true -> in_dom _ a m' = false -> ~ In (pf a) l) ->
 no_dup_list _ l -> no_dup_list _ (MapDomRestrByApp1 pf l m m').

End My_Map. *)
Require Import config.
(* config:
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import ZArith NArith Nnat Ndec Ndigits.
From IntMap Require Import Map.
From IntMap Require Import Allmaps.
Require Import Wf_nat.
Require Import List.

Require Import misc.
Require Import bool_fun.
Require Import myMap.

Section BDD_config_1.

Definition BDDzero := N0.
Definition BDDone := Npos 1.
Definition BDDstate := Map (BDDvar * (ad * ad)).
Definition BDDsharing_map := Map (Map (Map ad)).
Definition BDDfree_list := list ad.
Definition BDDneg_memo := Map ad.
Definition BDDor_memo := Map (Map ad).
Definition BDDuniv_memo := Map (Map ad).
Definition BDDconfig :=
  (BDDstate *
   (BDDsharing_map *
    (BDDfree_list * (ad * (BDDneg_memo * (BDDor_memo * BDDuniv_memo))))))%type.

Definition initBDDstate := newMap (BDDvar * (ad * ad)).
Definition initBDDsharing_map := newMap (Map (Map ad)).
Definition initBDDfree_list := nil (A:=ad).
Definition initBDDneg_memo := newMap ad.
Definition initBDDor_memo := newMap (Map ad).
Definition initBDDuniv_memo := newMap (Map ad).
Definition initBDDconfig :=
  (initBDDstate,
  (initBDDsharing_map,
  (initBDDfree_list,
  (Npos 2, (initBDDneg_memo, (initBDDor_memo, initBDDuniv_memo)))))).

Definition bs_node_height (bs : BDDstate) (node : ad) :=
  match MapGet _ bs node with
  | None => N0
  | Some (x, (l, r)) => ad_S x
  end.

Definition node_height (cfg : BDDconfig) (node : ad) :=
  bs_node_height (fst cfg) node.

Fixpoint bool_fun_of_BDD_1 (bs : BDDstate) (node : ad) 
 (bound : nat) {struct bound} : bool_fun :=
  match bound with
  | O =>   bool_fun_zero
  | S bound' =>
      match MapGet _ bs node with
      | None => if Neqb node BDDzero then bool_fun_zero else bool_fun_one
      | Some (x, (l, r)) =>
          bool_fun_if x (bool_fun_of_BDD_1 bs r bound')
            (bool_fun_of_BDD_1 bs l bound')
      end
  end.

Definition bool_fun_of_BDD_bs (bs : BDDstate) (node : ad) :=
  bool_fun_of_BDD_1 bs node (S (nat_of_N (bs_node_height bs node))).

Definition bool_fun_of_BDD (cfg : BDDconfig) := bool_fun_of_BDD_bs (fst cfg).

Definition nodes_preserved_bs (bs bs' : BDDstate) :=
  forall (x : BDDvar) (l r node : ad),
  MapGet _ bs node = Some (x, (l, r)) ->
  MapGet _ bs' node = Some (x, (l, r)).

Definition nodes_preserved (cfg cfg' : BDDconfig) :=
  nodes_preserved_bs (fst cfg) (fst cfg').

Inductive nodes_reachable (bs : BDDstate) : ad -> ad -> Prop :=
  | nodes_reachable_0 : forall node : ad, nodes_reachable bs node node
  | nodes_reachable_1 :
      forall (node node' l r : ad) (x : BDDvar),
      MapGet _ bs node = Some (x, (l, r)) ->
      nodes_reachable bs l node' -> nodes_reachable bs node node'
  | nodes_reachable_2 :
      forall (node node' l r : ad) (x : BDDvar),
      MapGet _ bs node = Some (x, (l, r)) ->
      nodes_reachable bs r node' -> nodes_reachable bs node node'.

Definition node_preserved_bs (bs bs' : BDDstate) (node : ad) :=
  forall (x : BDDvar) (l r node' : ad),
  nodes_reachable bs node node' ->
  MapGet _ bs node' = Some (x, (l, r)) ->
  MapGet _ bs' node' = Some (x, (l, r)).

Definition node_preserved (cfg cfg' : BDDconfig) :=
  node_preserved_bs (fst cfg) (fst cfg').

Definition used_node_bs (bs : BDDstate) (ul : list ad) 
  (node : ad) :=
  exists node' : ad, In node' ul /\ nodes_reachable bs node' node. 

Definition used_node'_bs (bs : BDDstate) (ul : list ad) 
  (node : ad) := node = BDDzero \/ node = BDDone \/ used_node_bs bs ul node. 

Definition used_node (cfg : BDDconfig) := used_node_bs (fst cfg).

Definition used_node' (cfg : BDDconfig) := used_node'_bs (fst cfg).

Definition node_OK (bs : BDDstate) (node : ad) :=
  node = BDDzero \/ node = BDDone \/ in_dom _ node bs = true.

Definition config_node_OK (cfg : BDDconfig) := node_OK (fst cfg).

Definition no_new_node_bs (bs bs' : BDDstate) :=
  forall (x : BDDvar) (l r node : ad),
  MapGet _ bs' node = Some (x, (l, r)) ->
  MapGet _ bs node = Some (x, (l, r)).

Definition no_new_node (cfg cfg' : BDDconfig) :=
  no_new_node_bs (fst cfg) (fst cfg').

Inductive BDDbounded (bs : BDDstate) : ad -> BDDvar -> Prop :=
  | BDDbounded_0 : forall n : BDDvar, BDDbounded bs BDDzero n
  | BDDbounded_1 : forall n : BDDvar, BDDbounded bs BDDone n
  | BDDbounded_2 :
      forall (node : ad) (n x : BDDvar) (l r : ad),
      MapGet _ bs node = Some (x, (l, r)) ->
      BDDcompare x n = Datatypes.Lt ->
      Neqb l r = false ->
      BDDbounded bs l x -> BDDbounded bs r x -> BDDbounded bs node n.

Definition BDD_OK (bs : BDDstate) (node : ad) :=
  match MapGet _ bs node with
  | None => node = BDDzero \/ node = BDDone
  | Some (n, _) => BDDbounded bs node (ad_S n)
  end.

Definition BDDstate_OK (bs : BDDstate) :=
  MapGet _ bs BDDzero = None /\
  MapGet _ bs BDDone = None /\
  (forall a : ad, in_dom _ a bs = true -> BDD_OK bs a).

Definition BDDsharing_OK (bs : BDDstate) (share : BDDsharing_map) :=
  forall (x : BDDvar) (l r a : ad),
  MapGet3 _ share l r x = Some a <-> MapGet _ bs a = Some (x, (l, r)).

Definition BDDfree_list_OK (bs : BDDstate) (fl : BDDfree_list) 
  (cnt : ad) :=
  no_dup_list _ fl /\
  (forall node : ad,
   In node fl <->
   Nleb (Npos 2) node = true /\
   Nleb (ad_S node) cnt = true /\ MapGet _ bs node = None).

Definition cnt_OK (bs : BDDstate) (cnt : ad) :=
  Nleb (Npos 2) cnt = true /\
  (forall a : ad, Nleb cnt a = true -> MapGet _ bs a = None).

Definition BDDneg_memo_OK (bs : BDDstate) (negm : BDDneg_memo) :=
  forall node node' : ad,
  MapGet _ negm node = Some node' ->
  node_OK bs node /\
  node_OK bs node' /\
  Neqb (bs_node_height bs node') (bs_node_height bs node) = true /\
  bool_fun_eq (bool_fun_of_BDD_bs bs node')
    (bool_fun_neg (bool_fun_of_BDD_bs bs node)).

Definition BDDor_memo_OK (bs : BDDstate) (orm : BDDor_memo) :=
  forall node1 node2 node : ad,
  MapGet2 _ orm node1 node2 = Some node ->
  node_OK bs node1 /\
  node_OK bs node2 /\
  node_OK bs node /\
  Nleb (bs_node_height bs node)
    (BDDvar_max (bs_node_height bs node1) (bs_node_height bs node2)) = true /\
  bool_fun_eq (bool_fun_of_BDD_bs bs node)
    (bool_fun_or (bool_fun_of_BDD_bs bs node1) (bool_fun_of_BDD_bs bs node2)).

Definition BDDuniv_memo_OK (bs : BDDstate) (um : BDDuniv_memo) :=
  forall (x : BDDvar) (node node' : ad),
  MapGet2 _ um node x = Some node' ->
  node_OK bs node /\
  node_OK bs node' /\
  Nleb (bs_node_height bs node') (bs_node_height bs node) = true /\
  bool_fun_eq (bool_fun_of_BDD_bs bs node')
    (bool_fun_forall x (bool_fun_of_BDD_bs bs node)).

Definition BDDconfig_OK (cfg : BDDconfig) :=
  BDDstate_OK (fst cfg) /\
  BDDsharing_OK (fst cfg) (fst (snd cfg)) /\
  BDDfree_list_OK (fst cfg) (fst (snd (snd cfg))) (fst (snd (snd (snd cfg)))) /\
  cnt_OK (fst cfg) (fst (snd (snd (snd cfg)))) /\
  BDDneg_memo_OK (fst cfg) (fst (snd (snd (snd (snd cfg))))) /\
  BDDor_memo_OK (fst cfg) (fst (snd (snd (snd (snd (snd cfg)))))) /\
  BDDuniv_memo_OK (fst cfg) (snd (snd (snd (snd (snd (snd cfg)))))).

Definition used_list_OK_bs (bs : BDDstate) (ul : list ad) :=
  forall node : ad, In node ul -> node_OK bs node.

Definition used_list_OK (cfg : BDDconfig) := used_list_OK_bs (fst cfg).

Definition used_nodes_preserved_bs (bs bs' : BDDstate) 
  (ul : list ad) :=
  forall node : ad, In node ul -> node_preserved_bs bs bs' node.

Definition used_nodes_preserved (cfg cfg' : BDDconfig) :=
  used_nodes_preserved_bs (fst cfg) (fst cfg').

Definition gc_OK (gc : BDDconfig -> list ad -> BDDconfig) :=
  forall (cfg : BDDconfig) (ul : list ad),
  BDDconfig_OK cfg ->
  used_list_OK cfg ul ->
  BDDconfig_OK (gc cfg ul) /\
  used_nodes_preserved cfg (gc cfg ul) ul /\ no_new_node cfg (gc cfg ul).

Lemma initBDDstate_OK : BDDstate_OK initBDDstate.

Lemma initBDDsharing_map_OK : BDDsharing_OK initBDDstate initBDDsharing_map.

Lemma initBDDfree_list_OK :
 BDDfree_list_OK initBDDstate initBDDfree_list (Npos 2).

Lemma initBDDneg_memo_OK :
 forall bs : BDDstate, BDDneg_memo_OK bs initBDDneg_memo.

Lemma initBDDor_memo_OK :
 forall bs : BDDstate, BDDor_memo_OK bs initBDDor_memo.

Lemma initBDDuniv_memo_OK :
 forall bs : BDDstate, BDDuniv_memo_OK bs initBDDuniv_memo.

Lemma initBDDconfig_OK : BDDconfig_OK initBDDconfig.

Lemma config_OK_zero :
 forall cfg : BDDconfig,
 BDDconfig_OK cfg -> MapGet _ (fst cfg) BDDzero = None.

Lemma config_OK_one :
 forall cfg : BDDconfig,
 BDDconfig_OK cfg -> MapGet _ (fst cfg) BDDone = None.

Lemma zero_OK : forall cfg : BDDconfig, config_node_OK cfg BDDzero.

Lemma one_OK : forall cfg : BDDconfig, config_node_OK cfg BDDone.

Lemma node_height_zero :
 forall cfg : BDDconfig,
 BDDconfig_OK cfg -> Neqb (node_height cfg BDDzero) N0 = true.

Lemma node_height_one :
 forall cfg : BDDconfig,
 BDDconfig_OK cfg -> Neqb (node_height cfg BDDone) N0 = true.

Lemma nodes_preserved_bs_trans :
 forall bs1 bs2 bs3 : BDDstate,
 nodes_preserved_bs bs1 bs2 ->
 nodes_preserved_bs bs2 bs3 -> nodes_preserved_bs bs1 bs3.

Lemma nodes_preserved_bs_refl :
 forall bs : BDDstate, nodes_preserved_bs bs bs.

Lemma nodes_preserved_trans :
 forall cfg1 cfg2 cfg3 : BDDconfig,
 nodes_preserved cfg1 cfg2 ->
 nodes_preserved cfg2 cfg3 -> nodes_preserved cfg1 cfg3.

Lemma nodes_preserved_refl : forall cfg : BDDconfig, nodes_preserved cfg cfg.

Lemma increase_bound :
 forall (bs : BDDstate) (n n' : BDDvar) (node : ad),
 BDDbounded bs node n ->
 BDDcompare n n' = Datatypes.Lt -> BDDbounded bs node n'.

Lemma nodes_preserved_bounded :
 forall (bs bs' : BDDstate) (n : BDDvar) (node : ad),
 nodes_preserved_bs bs bs' -> BDDbounded bs node n -> BDDbounded bs' node n.

Lemma BDDbounded_lemma :
 forall (bs : BDDstate) (node : ad) (n : BDDvar),
 BDDbounded bs node n ->
 node = BDDzero \/
 node = BDDone \/
 (exists x : BDDvar,
    (exists l : BDDvar,
       (exists r : BDDvar,
          MapGet _ bs node = Some (x, (l, r)) /\
          BDDcompare x n = Datatypes.Lt /\

Lemma BDD_OK_node_OK :
 forall (bs : BDDstate) (node : ad), BDD_OK bs node -> node_OK bs node.

Lemma node_OK_BDD_OK :
 forall (bs : BDDstate) (node : ad),
 BDDstate_OK bs -> node_OK bs node -> BDD_OK bs node.

Lemma bs_node_height_left :
 forall (bs : BDDstate) (node l r : ad) (x : BDDvar),
 BDDstate_OK bs ->
 MapGet _ bs node = Some (x, (l, r)) ->
 BDDcompare (bs_node_height bs l) (bs_node_height bs node) = Datatypes.Lt.

Lemma bs_node_height_right :
 forall (bs : BDDstate) (node l r : ad) (x : BDDvar),
 BDDstate_OK bs ->
 MapGet _ bs node = Some (x, (l, r)) ->
 BDDcompare (bs_node_height bs r) (bs_node_height bs node) = Datatypes.Lt.

Lemma internal_node_lemma :
 forall (bs : BDDstate) (x : BDDvar) (l r node : ad),
 BDDstate_OK bs ->
 MapGet _ bs node = Some (x, (l, r)) ->
 Neqb l r = false /\ BDDbounded bs l x /\ BDDbounded bs r x.

Lemma high_bounded :
 forall (bs : BDDstate) (x : BDDvar) (l r node : ad),
 BDDstate_OK bs -> MapGet _ bs node = Some (x, (l, r)) -> BDDbounded bs r x.

Lemma low_bounded :
 forall (bs : BDDstate) (x : BDDvar) (l r node : ad),
 BDDstate_OK bs -> MapGet _ bs node = Some (x, (l, r)) -> BDDbounded bs l x.

Lemma BDDbounded_node_OK :
 forall (bs : BDDstate) (node : ad) (n : BDDvar),
 BDDbounded bs node n -> node_OK bs node.

Lemma high_OK :
 forall (bs : BDDstate) (x : BDDvar) (l r node : ad),
 BDDstate_OK bs -> MapGet _ bs node = Some (x, (l, r)) -> node_OK bs r.

Lemma low_OK :
 forall (bs : BDDstate) (x : BDDvar) (l r node : ad),
 BDDstate_OK bs -> MapGet _ bs node = Some (x, (l, r)) -> node_OK bs l.

Lemma low_high_neq :
 forall (cfg : BDDconfig) (x : BDDvar) (l r node : ad),
 BDDconfig_OK cfg ->
 MapGet _ (fst cfg) node = Some (x, (l, r)) -> Neqb l r = false.

Lemma bs_node_height_left_le :
 forall bs : BDDstate,
 BDDstate_OK bs ->
 forall (x : BDDvar) (l r node : ad),
 MapGet _ bs node = Some (x, (l, r)) ->
 Nleb (bs_node_height bs l) x = true.

Lemma bs_node_height_right_le :
 forall bs : BDDstate,
 BDDstate_OK bs ->
 forall (x : BDDvar) (l r node : ad),
 MapGet _ bs node = Some (x, (l, r)) ->
 Nleb (bs_node_height bs r) x = true.

Lemma no_duplicate_node :
 forall (bs : BDDstate) (share : BDDsharing_map),
 BDDstate_OK bs ->
 BDDsharing_OK bs share ->
 forall (x : BDDvar) (l r node1 node2 : ad),
 MapGet _ bs node1 = Some (x, (l, r)) ->
 MapGet _ bs node2 = Some (x, (l, r)) -> node1 = node2.

Lemma int_node_gt_1 :
 forall (bs : BDDstate) (node : ad),
 BDDstate_OK bs -> in_dom _ node bs = true -> Nleb (Npos 2) node = true.

Lemma int_node_lt_cnt :
 forall (bs : BDDstate) (cnt node : ad),
 cnt_OK bs cnt -> in_dom _ node bs = true -> Nleb (ad_S node) cnt = true.

Lemma nodes_preserved_bs_node_OK :
 forall (bs1 bs2 : BDDstate) (node : ad),
 nodes_preserved_bs bs1 bs2 -> node_OK bs1 node -> node_OK bs2 node.

Lemma nodes_preserved_config_node_OK :
 forall (cfg1 cfg2 : BDDconfig) (node : ad),
 nodes_preserved cfg1 cfg2 ->
 config_node_OK cfg1 node -> config_node_OK cfg2 node.

Lemma nodes_preserved_bs_node_height_eq :
 forall (bs1 bs2 : BDDstate) (node : ad),
 nodes_preserved_bs bs1 bs2 ->
 BDDstate_OK bs1 ->
 BDDstate_OK bs2 ->
 node_OK bs1 node ->
 Neqb (bs_node_height bs2 node) (bs_node_height bs1 node) = true.

Lemma nodes_preserved_node_height_eq :
 forall (cfg1 cfg2 : BDDconfig) (node : ad),
 BDDconfig_OK cfg1 ->
 BDDconfig_OK cfg2 ->
 nodes_preserved cfg1 cfg2 ->
 config_node_OK cfg1 node ->
 Neqb (node_height cfg2 node) (node_height cfg1 node) = true.

  Section Components.

  Variable cfg : BDDconfig.
  Hypothesis cfg_OK : BDDconfig_OK cfg.

  Definition bs_of_cfg := fst cfg.
  Definition share_of_cfg := fst (snd cfg).
  Definition fl_of_cfg := fst (snd (snd cfg)).
  Definition cnt_of_cfg := fst (snd (snd (snd cfg))).
  Definition negm_of_cfg := fst (snd (snd (snd (snd cfg)))).
  Definition orm_of_cfg := fst (snd (snd (snd (snd (snd cfg))))).
  Definition um_of_cfg := snd (snd (snd (snd (snd (snd cfg))))).

  Lemma cfg_comp :
   cfg =
   (bs_of_cfg,
   (share_of_cfg,
   (fl_of_cfg, (cnt_of_cfg, (negm_of_cfg, (orm_of_cfg, um_of_cfg)))))).

  Lemma bs_of_cfg_OK : BDDstate_OK bs_of_cfg.

  Lemma share_of_cfg_OK : BDDsharing_OK bs_of_cfg share_of_cfg.

  Lemma fl_of_cfg_OK : BDDfree_list_OK bs_of_cfg fl_of_cfg cnt_of_cfg.

  Lemma cnt_of_cfg_OK : cnt_OK bs_of_cfg cnt_of_cfg.

  Lemma negm_of_cfg_OK : BDDneg_memo_OK bs_of_cfg negm_of_cfg.

  Lemma orm_of_cfg_OK : BDDor_memo_OK bs_of_cfg orm_of_cfg.
 
  Lemma um_of_cfg_OK : BDDuniv_memo_OK bs_of_cfg um_of_cfg.

  End Components.

Lemma nodes_reachable_lemma_1 :
 forall (bs : BDDstate) (node node' : ad),
 nodes_reachable bs node node' ->
 node = node' \/
 (exists x : BDDvar,
    (exists l : ad,
       (exists r : ad,
          MapGet _ bs node = Some (x, (l, r)) /\
          (nodes_reachable bs l node' \/ nodes_reachable bs r node')))).

Lemma nodes_reachable_trans :
 forall (bs : BDDstate) (node1 node2 node3 : ad),
 nodes_reachable bs node1 node2 ->
 nodes_reachable bs node2 node3 -> nodes_reachable bs node1 node3.

Lemma reachable_node_OK_1 :
 forall (bs : BDDstate) (n : nat) (node1 node2 : ad),
 BDDstate_OK bs ->
 n = nat_of_N (bs_node_height bs node1) ->
 node_OK bs node1 -> nodes_reachable bs node1 node2 -> node_OK bs node2.

Lemma reachable_node_OK :
 forall (bs : BDDstate) (node1 node2 : ad),
 BDDstate_OK bs ->
 node_OK bs node1 -> nodes_reachable bs node1 node2 -> node_OK bs node2.

Lemma nodes_reachableBDDzero :
 forall (bs : BDDstate) (node : ad),
 BDDstate_OK bs -> nodes_reachable bs BDDzero node -> node = BDDzero.

Lemma nodes_reachableBDDone :
 forall (bs : BDDstate) (node : ad),
 BDDstate_OK bs -> nodes_reachable bs BDDone node -> node = BDDone.

Lemma used_node'_used_node_bs :
 forall (bs : BDDstate) (ul : list ad) (node : ad),
 used_node_bs bs ul node -> used_node'_bs bs ul node.

Lemma high_used_bs :
 forall (bs : BDDstate) (ul : list ad) (x : BDDvar) (l r node : ad),
 used_node_bs bs ul node ->
 MapGet _ bs node = Some (x, (l, r)) -> used_node_bs bs ul r.

Lemma high_used'_bs :
 forall (bs : BDDstate) (ul : list ad) (x : BDDvar) (l r node : ad),
 BDDstate_OK bs ->
 used_node'_bs bs ul node ->
 MapGet _ bs node = Some (x, (l, r)) -> used_node'_bs bs ul r.

Lemma low_used_bs :
 forall (bs : BDDstate) (ul : list ad) (x : BDDvar) (l r node : ad),
 used_node_bs bs ul node ->
 MapGet _ bs node = Some (x, (l, r)) -> used_node_bs bs ul l.

Lemma low_used'_bs :
 forall (bs : BDDstate) (ul : list ad) (x : BDDvar) (l r node : ad),
 BDDstate_OK bs ->
 used_node'_bs bs ul node ->
 MapGet _ bs node = Some (x, (l, r)) -> used_node'_bs bs ul l.

Lemma high_used :
 forall (cfg : BDDconfig) (ul : list ad) (x : BDDvar) (l r node : ad),
 used_node cfg ul node ->
 MapGet _ (fst cfg) node = Some (x, (l, r)) -> used_node cfg ul r.

Lemma high_used' :
 forall (cfg : BDDconfig) (ul : list ad) (x : BDDvar) (l r node : ad),
 BDDconfig_OK cfg ->
 used_node' cfg ul node ->
 MapGet _ (fst cfg) node = Some (x, (l, r)) -> used_node' cfg ul r.

Lemma low_used :
 forall (cfg : BDDconfig) (ul : list ad) (x : BDDvar) (l r node : ad),
 used_node cfg ul node ->
 MapGet _ (fst cfg) node = Some (x, (l, r)) -> used_node cfg ul l.

Lemma low_used' :
 forall (cfg : BDDconfig) (ul : list ad) (x : BDDvar) (l r node : ad),
 BDDconfig_OK cfg ->
 used_node' cfg ul node ->
 MapGet _ (fst cfg) node = Some (x, (l, r)) -> used_node' cfg ul l.

Lemma used_node_OK_bs :
 forall (bs : BDDstate) (ul : list ad) (node : ad),
 BDDstate_OK bs ->
 used_list_OK_bs bs ul -> used_node_bs bs ul node -> node_OK bs node.

Lemma used_node'_OK_bs :
 forall (bs : BDDstate) (ul : list ad) (node : ad),
 BDDstate_OK bs ->
 used_list_OK_bs bs ul -> used_node'_bs bs ul node -> node_OK bs node.

Lemma used_node_OK :
 forall (cfg : BDDconfig) (ul : list ad) (node : ad),
 BDDconfig_OK cfg ->
 used_list_OK cfg ul -> used_node cfg ul node -> config_node_OK cfg node.

Lemma used_node'_OK :
 forall (cfg : BDDconfig) (ul : list ad) (node : ad),
 BDDconfig_OK cfg ->
 used_list_OK cfg ul -> used_node' cfg ul node -> config_node_OK cfg node.

Lemma nodes_preserved_used_nodes_preserved :
 forall (cfg cfg' : BDDconfig) (ul : list ad),
 nodes_preserved cfg cfg' -> used_nodes_preserved cfg cfg' ul.

Lemma node_preserved_bs_reachable_1 :
 forall bs bs' : BDDstate,
 BDDstate_OK bs ->
 forall (n : nat) (node node' : ad),
 n = nat_of_N (bs_node_height bs node) ->
 node_preserved_bs bs bs' node ->
 nodes_reachable bs node node' -> nodes_reachable bs' node node'.

Lemma node_preserved_bs_reachable :
 forall (bs bs' : BDDstate) (node node' : ad),
 BDDstate_OK bs ->
 node_preserved_bs bs bs' node ->
 nodes_reachable bs node node' -> nodes_reachable bs' node node'.

Lemma node_preserved_bs_trans :
 forall (bs1 bs2 bs3 : BDDstate) (node : ad),
 BDDstate_OK bs1 ->
 node_preserved_bs bs1 bs2 node ->
 node_preserved_bs bs2 bs3 node -> node_preserved_bs bs1 bs3 node.

Lemma used_nodes_preserved_trans :
 forall (cfg1 cfg2 cfg3 : BDDconfig) (ul : list ad),
 BDDconfig_OK cfg1 ->
 used_nodes_preserved cfg1 cfg2 ul ->
 used_nodes_preserved cfg2 cfg3 ul -> used_nodes_preserved cfg1 cfg3 ul.

Lemma used_nodes_preserved_refl :
 forall (cfg : BDDconfig) (ul : list ad), used_nodes_preserved cfg cfg ul.

Lemma BDDzero_preserved :
 forall bs bs' : BDDstate, BDDstate_OK bs -> node_preserved_bs bs bs' BDDzero.

Lemma BDDone_preserved :
 forall bs bs' : BDDstate, BDDstate_OK bs -> node_preserved_bs bs bs' BDDone.

Lemma used_nodes_preserved_preserved_bs :
 forall (bs bs' : BDDstate) (ul : list ad) (node : ad),
 used_nodes_preserved_bs bs bs' ul ->
 used_node_bs bs ul node -> node_preserved_bs bs bs' node.

Lemma used_nodes_preserved_preserved'_bs :
 forall (bs bs' : BDDstate) (ul : list ad) (node : ad),
 BDDstate_OK bs ->
 used_nodes_preserved_bs bs bs' ul ->
 used_node'_bs bs ul node -> node_preserved_bs bs bs' node.

Lemma node_preserved_OK_bs :
 forall (bs bs' : BDDstate) (node : ad),
 node_OK bs node -> node_preserved_bs bs bs' node -> node_OK bs' node.

Lemma used_nodes_preserved_list_OK_bs :
 forall (bs bs' : BDDstate) (ul : list ad),
 used_list_OK_bs bs ul ->
 used_nodes_preserved_bs bs bs' ul -> used_list_OK_bs bs' ul.

Lemma used_nodes_preserved_list_OK :
 forall (cfg cfg' : BDDconfig) (ul : list ad),
 used_list_OK cfg ul ->
 used_nodes_preserved cfg cfg' ul -> used_list_OK cfg' ul.

Lemma used_node_cons_node_ul :
 forall (cfg : BDDconfig) (ul : list ad) (node : ad),
 used_node cfg (node :: ul) node.

Lemma used_node'_cons_node_ul :
 forall (cfg : BDDconfig) (ul : list ad) (node : ad),
 used_node' cfg (node :: ul) node.

Lemma used_node_cons_node'_ul :
 forall (cfg : BDDconfig) (ul : list ad) (node node' : ad),
 used_node cfg ul node -> used_node cfg (node' :: ul) node.

Lemma used_node'_cons_node'_ul :
 forall (cfg : BDDconfig) (ul : list ad) (node node' : ad),
 used_node' cfg ul node -> used_node' cfg (node' :: ul) node.

Lemma used_nodes_preserved_bs_cons :
 forall (bs bs' : BDDstate) (ul : list ad) (node : ad),
 used_nodes_preserved_bs bs bs' (node :: ul) ->
 used_nodes_preserved_bs bs bs' ul.

Lemma used_nodes_preserved_cons :
 forall (cfg cfg' : BDDconfig) (ul : list ad) (node : ad),
 used_nodes_preserved cfg cfg' (node :: ul) ->
 used_nodes_preserved cfg cfg' ul.

Lemma node_OK_list_OK_bs :
 forall (bs : BDDstate) (ul : list ad) (node : ad),
 node_OK bs node -> used_list_OK_bs bs ul -> used_list_OK_bs bs (node :: ul).

Lemma node_OK_list_OK :
 forall (cfg : BDDconfig) (ul : list ad) (node : ad),
 config_node_OK cfg node ->
 used_list_OK cfg ul -> used_list_OK cfg (node :: ul).

Lemma used_nodes_preserved_node_OK :
 forall (cfg cfg' : BDDconfig) (ul : list ad) (node : ad),
 BDDconfig_OK cfg ->
 used_list_OK cfg ul ->
 used_node cfg ul node ->
 used_nodes_preserved cfg cfg' ul -> config_node_OK cfg' node.

Lemma used_nodes_preserved_node_OK' :
 forall (cfg cfg' : BDDconfig) (ul : list ad) (node : ad),
 BDDconfig_OK cfg ->
 used_list_OK cfg ul ->
 used_node' cfg ul node ->
 used_nodes_preserved cfg cfg' ul -> config_node_OK cfg' node.

Lemma used_nodes_preserved_used_node :
 forall (cfg cfg' : BDDconfig) (ul : list ad) (node : ad),
 BDDconfig_OK cfg ->
 used_nodes_preserved cfg cfg' ul ->
 used_node cfg ul node -> used_node cfg' ul node.

Lemma used_nodes_preserved_used_node' :
 forall (cfg cfg' : BDDconfig) (ul : list ad) (node : ad),
 BDDconfig_OK cfg ->
 used_nodes_preserved cfg cfg' ul ->
 used_node' cfg ul node -> used_node' cfg' ul node.

Lemma bool_fun_of_BDD_1_change_bound :
 forall bs : BDDstate,
 BDDstate_OK bs ->
 forall (bound : nat) (node : ad),
 nat_of_N (bs_node_height bs node) < bound ->
 bool_fun_eq (bool_fun_of_BDD_1 bs node bound)
   (bool_fun_of_BDD_1 bs node (S (nat_of_N (bs_node_height bs node)))).

Lemma bool_fun_of_BDD_bs_zero :
 forall bs : BDDstate,
 BDDstate_OK bs -> bool_fun_eq (bool_fun_of_BDD_bs bs BDDzero) bool_fun_zero.

Lemma bool_fun_of_BDD_bs_one :
 forall bs : BDDstate,
 BDDstate_OK bs -> bool_fun_eq (bool_fun_of_BDD_bs bs BDDone) bool_fun_one.

Lemma bool_fun_of_BDD_bs_int :
 forall bs : BDDstate,
 BDDstate_OK bs ->
 forall (x : BDDvar) (l r node : ad),
 MapGet _ bs node = Some (x, (l, r)) ->
 bool_fun_eq (bool_fun_of_BDD_bs bs node)
   (bool_fun_if x (bool_fun_of_BDD_bs bs r) (bool_fun_of_BDD_bs bs l)).

Lemma bool_fun_of_BDD_one :
 forall cfg : BDDconfig,
 BDDconfig_OK cfg -> bool_fun_eq (bool_fun_of_BDD cfg BDDone) bool_fun_one.

Lemma bool_fun_of_BDD_zero :
 forall cfg : BDDconfig,
 BDDconfig_OK cfg -> bool_fun_eq (bool_fun_of_BDD cfg BDDzero) bool_fun_zero.

Lemma bool_fun_of_BDD_int :
 forall (cfg : BDDconfig) (x : BDDvar) (l r node : ad),
 BDDconfig_OK cfg ->
 MapGet _ (fst cfg) node = Some (x, (l, r)) ->
 bool_fun_eq (bool_fun_of_BDD cfg node)
   (bool_fun_if x (bool_fun_of_BDD cfg r) (bool_fun_of_BDD cfg l)).

Lemma bool_fun_of_BDD_1_ext :
 forall (bound : nat) (bs : BDDstate) (node : ad),
 bool_fun_ext (bool_fun_of_BDD_1 bs node bound).

Lemma bool_fun_of_BDD_bs_ext :
 forall (bs : BDDstate) (node : ad),
 bool_fun_ext (bool_fun_of_BDD_bs bs node).

Lemma BDDvar_independent_1 :
 forall bs : BDDstate,
 BDDstate_OK bs ->
 forall (n : nat) (node : ad) (x : BDDvar),
 n = nat_of_N (bs_node_height bs node) ->
 node_OK bs node ->
 Nleb (bs_node_height bs node) x = true ->
 bool_fun_independent (bool_fun_of_BDD_bs bs node) x.

Lemma BDDvar_independent_bs :
 forall bs : BDDstate,
 BDDstate_OK bs ->
 forall (node : ad) (x : BDDvar),
 node_OK bs node ->
 Nleb (bs_node_height bs node) x = true ->
 bool_fun_independent (bool_fun_of_BDD_bs bs node) x.

Lemma BDDvar_independent_low :
 forall bs : BDDstate,
 BDDstate_OK bs ->
 forall (x : BDDvar) (l r node : ad),
 MapGet _ bs node = Some (x, (l, r)) ->
 bool_fun_independent (bool_fun_of_BDD_bs bs l) x.

Lemma BDDvar_independent_high :
 forall bs : BDDstate,
 BDDstate_OK bs ->
 forall (x : BDDvar) (l r node : ad),
 MapGet _ bs node = Some (x, (l, r)) ->
 bool_fun_independent (bool_fun_of_BDD_bs bs r) x.

Lemma bool_fun_of_BDD_bs_high :
 forall bs : BDDstate,
 BDDstate_OK bs ->
 forall (x : BDDvar) (l r node : ad),
 MapGet _ bs node = Some (x, (l, r)) ->
 bool_fun_eq (bool_fun_of_BDD_bs bs r)
   (bool_fun_restrict (bool_fun_of_BDD_bs bs node) x true).

Lemma bool_fun_of_BDD_bs_low :
 forall bs : BDDstate,
 BDDstate_OK bs ->
 forall (x : BDDvar) (l r node : ad),
 MapGet _ bs node = Some (x, (l, r)) ->
 bool_fun_eq (bool_fun_of_BDD_bs bs l)
   (bool_fun_restrict (bool_fun_of_BDD_bs bs node) x false).

Lemma BDDunique_1 :
 forall (bs : BDDstate) (share : BDDsharing_map),
 BDDstate_OK bs ->
 BDDsharing_OK bs share ->
 forall (n : nat) (node1 node2 : ad),
 n =
 max (nat_of_N (bs_node_height bs node1))
   (nat_of_N (bs_node_height bs node2)) ->
 node_OK bs node1 ->
 node_OK bs node2 ->
 bool_fun_eq (bool_fun_of_BDD_bs bs node1) (bool_fun_of_BDD_bs bs node2) ->
 node1 = node2.

Lemma BDDunique :
 forall (cfg : BDDconfig) (node1 node2 : ad),
 BDDconfig_OK cfg ->
 config_node_OK cfg node1 ->
 config_node_OK cfg node2 ->
 bool_fun_eq (bool_fun_of_BDD cfg node1) (bool_fun_of_BDD cfg node2) ->
 Neqb node1 node2 = true.

Lemma nodes_preserved_bs_bool_fun_1 :
 forall (bs1 bs2 : BDDstate) (n : nat) (node : ad),
 n = nat_of_N (bs_node_height bs1 node) ->
 BDDstate_OK bs1 ->
 BDDstate_OK bs2 ->
 nodes_preserved_bs bs1 bs2 ->
 node_OK bs1 node ->
 bool_fun_eq (bool_fun_of_BDD_bs bs2 node) (bool_fun_of_BDD_bs bs1 node).

Lemma nodes_preserved_bs_bool_fun :
 forall (bs1 bs2 : BDDstate) (node : ad),
 BDDstate_OK bs1 ->
 BDDstate_OK bs2 ->
 nodes_preserved_bs bs1 bs2 ->
 node_OK bs1 node ->
 bool_fun_eq (bool_fun_of_BDD_bs bs2 node) (bool_fun_of_BDD_bs bs1 node).

Lemma nodes_preserved_bool_fun :
 forall (cfg1 cfg2 : BDDconfig) (node : ad),
 BDDconfig_OK cfg1 ->
 BDDconfig_OK cfg2 ->
 nodes_preserved cfg1 cfg2 ->
 config_node_OK cfg1 node ->
 bool_fun_eq (bool_fun_of_BDD cfg2 node) (bool_fun_of_BDD cfg1 node).

Lemma nodes_preserved_neg_memo_OK :
 forall (bs bs' : BDDstate) (negm : BDDneg_memo),
 nodes_preserved_bs bs bs' ->
 BDDstate_OK bs ->
 BDDstate_OK bs' -> BDDneg_memo_OK bs negm -> BDDneg_memo_OK bs' negm.

Lemma nodes_preserved_or_memo_OK :
 forall (bs bs' : BDDstate) (orm : BDDor_memo),
 nodes_preserved_bs bs bs' ->
 BDDstate_OK bs ->
 BDDstate_OK bs' -> BDDor_memo_OK bs orm -> BDDor_memo_OK bs' orm.

Lemma nodes_preserved_um_OK :
 forall (bs bs' : BDDstate) (um : BDDuniv_memo),
 nodes_preserved_bs bs bs' ->
 BDDstate_OK bs ->
 BDDstate_OK bs' -> BDDuniv_memo_OK bs um -> BDDuniv_memo_OK bs' um.

Lemma node_preserved_bs_bool_fun_1 :
 forall (n : nat) (bs bs' : BDDstate) (node : ad),
 BDDstate_OK bs ->
 BDDstate_OK bs' ->
 node_preserved_bs bs bs' node ->
 node_OK bs node ->
 n = nat_of_N (bs_node_height bs node) ->
 bool_fun_eq (bool_fun_of_BDD_bs bs' node) (bool_fun_of_BDD_bs bs node).

Lemma node_preserved_bs_bool_fun :
 forall (bs bs' : BDDstate) (node : ad),
 BDDstate_OK bs ->
 BDDstate_OK bs' ->
 node_preserved_bs bs bs' node ->
 node_OK bs node ->
 bool_fun_eq (bool_fun_of_BDD_bs bs' node) (bool_fun_of_BDD_bs bs node).

Lemma node_preserved_bs_node_height_eq :
 forall (bs bs' : BDDstate) (node : ad),
 BDDstate_OK bs ->
 BDDstate_OK bs' ->
 node_preserved_bs bs bs' node ->
 node_OK bs node ->
 Neqb (bs_node_height bs' node) (bs_node_height bs node) = true.

Lemma node_preserved_node_height_eq :
 forall (cfg cfg' : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 BDDconfig_OK cfg' ->
 node_preserved cfg cfg' node ->
 config_node_OK cfg node ->
 Neqb (node_height cfg' node) (node_height cfg node) = true.

Lemma used_nodes_preserved_node_height_eq :
 forall (cfg cfg' : BDDconfig) (ul : list ad) (node : ad),
 BDDconfig_OK cfg ->
 BDDconfig_OK cfg' ->
 used_nodes_preserved cfg cfg' ul ->
 used_list_OK cfg ul ->
 used_node cfg ul node ->
 Neqb (node_height cfg' node) (node_height cfg node) = true.

Lemma used_nodes_preserved'_node_height_eq :
 forall (cfg cfg' : BDDconfig) (ul : list ad) (node : ad),
 BDDconfig_OK cfg ->
 BDDconfig_OK cfg' ->
 used_nodes_preserved cfg cfg' ul ->
 used_list_OK cfg ul ->
 used_node' cfg ul node ->
 Neqb (node_height cfg' node) (node_height cfg node) = true.

Lemma used_nodes_preserved_bs_bool_fun :
 forall (bs bs' : BDDstate) (ul : list ad) (node : ad),
 BDDstate_OK bs ->
 BDDstate_OK bs' ->
 used_nodes_preserved_bs bs bs' ul ->
 used_list_OK_bs bs ul ->
 used_node_bs bs ul node ->
 bool_fun_eq (bool_fun_of_BDD_bs bs' node) (bool_fun_of_BDD_bs bs node).

Lemma used_nodes_preserved'_bs_bool_fun :
 forall (bs bs' : BDDstate) (ul : list ad) (node : ad),
 BDDstate_OK bs ->
 BDDstate_OK bs' ->
 used_nodes_preserved_bs bs bs' ul ->
 used_list_OK_bs bs ul ->
 used_node'_bs bs ul node ->
 bool_fun_eq (bool_fun_of_BDD_bs bs' node) (bool_fun_of_BDD_bs bs node).

Lemma used_nodes_preserved_bool_fun :
 forall (cfg cfg' : BDDconfig) (ul : list ad) (node : ad),
 BDDconfig_OK cfg ->
 BDDconfig_OK cfg' ->
 used_nodes_preserved cfg cfg' ul ->
 used_list_OK cfg ul ->
 used_node cfg ul node ->
 bool_fun_eq (bool_fun_of_BDD cfg' node) (bool_fun_of_BDD cfg node).

Lemma used_nodes_preserved'_bool_fun :
 forall (cfg cfg' : BDDconfig) (ul : list ad) (node : ad),
 BDDconfig_OK cfg ->
 BDDconfig_OK cfg' ->
 used_nodes_preserved cfg cfg' ul ->
 used_list_OK cfg ul ->
 used_node' cfg ul node ->
 bool_fun_eq (bool_fun_of_BDD cfg' node) (bool_fun_of_BDD cfg node).

Definition BDDneg_memo_put (cfg : BDDconfig) (node node' : ad) :=
  match cfg with
  | (bs, (share, (fl, (cnt, (negm, z))))) =>
      (bs, (share, (fl, (cnt, (MapPut _ negm node node', z)))))
  end.

Lemma BDDnegm_put_OK :
 forall (cfg : BDDconfig) (node node' : ad),
 BDDconfig_OK cfg ->
 config_node_OK cfg node ->
 config_node_OK cfg node' ->
 Neqb (node_height cfg node') (node_height cfg node) = true ->
 bool_fun_eq (bool_fun_of_BDD cfg node')
   (bool_fun_neg (bool_fun_of_BDD cfg node)) ->
 BDDconfig_OK (BDDneg_memo_put cfg node node').

Definition BDDor_memo_put (cfg : BDDconfig) (node1 node2 node' : ad) :=
  match cfg with
  | (bs, (share, (fl, (cnt, (negm, (orm, um)))))) =>
      (bs,
      (share, (fl, (cnt, (negm, (MapPut2 _ orm node1 node2 node', um))))))
  end.

Lemma BDDorm_put_nodes_preserved :
 forall (cfg : BDDconfig) (node1 node2 node' : ad),
 nodes_preserved cfg (BDDor_memo_put cfg node1 node2 node').

Lemma BDDorm_put_OK :
 forall (cfg : BDDconfig) (node1 node2 node' : ad),
 BDDconfig_OK cfg ->
 config_node_OK cfg node1 ->
 config_node_OK cfg node2 ->
 config_node_OK cfg node' ->
 Nleb (node_height cfg node')
   (BDDvar_max (node_height cfg node1) (node_height cfg node2)) = true ->
 bool_fun_eq (bool_fun_of_BDD cfg node')
   (bool_fun_or (bool_fun_of_BDD cfg node1) (bool_fun_of_BDD cfg node2)) ->
 BDDconfig_OK (BDDor_memo_put cfg node1 node2 node').

Lemma BDDnegm_put_nodes_preserved :
 forall (cfg : BDDconfig) (node node' : ad),
 nodes_preserved cfg (BDDneg_memo_put cfg node node').

Definition BDDuniv_memo_put (cfg : BDDconfig) (x : BDDvar)
  (node node' : ad) :=
  match cfg with
  | (bs, (share, (fl, (cnt, (negm, (orm, um)))))) =>
      (bs, (share, (fl, (cnt, (negm, (orm, MapPut2 ad um node x node'))))))
  end.

Lemma BDDum_put_nodes_preserved :
 forall (cfg : BDDconfig) (x : BDDvar) (node node' : ad),
 nodes_preserved cfg (BDDuniv_memo_put cfg x node node').

Lemma BDDum_put_OK :
 forall (cfg : BDDconfig) (x : BDDvar) (node node' : ad),
 BDDconfig_OK cfg ->
 config_node_OK cfg node ->
 config_node_OK cfg node' ->
 Nleb (node_height cfg node') (node_height cfg node) = true ->
 bool_fun_eq (bool_fun_of_BDD cfg node')
   (bool_fun_forall x (bool_fun_of_BDD cfg node)) ->
 BDDconfig_OK (BDDuniv_memo_put cfg x node node').

Lemma not_zero_is_one :
 forall (cfg : BDDconfig) (node : ad),
 config_node_OK cfg node ->
 in_dom _ node (fst cfg) = false ->
 Neqb node BDDzero = false -> Neqb node BDDone = true.

Lemma used'_zero :
 forall (cfg : BDDconfig) (ul : list ad), used_node' cfg ul BDDzero.

Lemma used'_one :
 forall (cfg : BDDconfig) (ul : list ad), used_node' cfg ul BDDone.

Lemma cons_OK_list_OK :
 forall (cfg : BDDconfig) (ul : list ad) (node : ad),
 used_list_OK cfg (node :: ul) -> used_list_OK cfg ul.

End BDD_config_1. *)
Require Import alloc.
(* alloc:
Require Import Bool.	
Require Import Sumbool.
Require Import Arith.
Require Import ZArith NArith Nnat Ndec Ndigits.		
From IntMap Require Import Map.
From IntMap Require Import Allmaps.			
Require Import List.
Require Import Wf_nat.
  
Require Import misc.
Require Import bool_fun.
Require Import myMap.
Require Import config.

Section BDD_alloc.

Variable gc : BDDconfig -> list ad -> BDDconfig.
Hypothesis gc_is_OK : gc_OK gc.

Variable cfg : BDDconfig.
Variable x : BDDvar.
Variable l r : ad.
Variable ul : list ad.

Hypothesis cfg_OK : BDDconfig_OK cfg.
Hypothesis ul_OK : used_list_OK cfg ul.
Hypothesis l_used' : used_node' cfg ul l.
Hypothesis r_used' : used_node' cfg ul r.
Hypothesis l_neq_r : Neqb l r = false.
Hypothesis
  xl_lt_x :
    forall (xl : BDDvar) (ll rl : ad),
    MapGet _ (bs_of_cfg cfg) l = Some (xl, (ll, rl)) ->
    BDDcompare xl x = Datatypes.Lt.
Hypothesis
  xr_lt_x :
    forall (xr : BDDvar) (lr rr : ad),
    MapGet _ (bs_of_cfg cfg) r = Some (xr, (lr, rr)) ->
    BDDcompare xr x = Datatypes.Lt.
Hypothesis
  no_dup :
    forall (x' : BDDvar) (l' r' a : ad),
    MapGet _ (bs_of_cfg cfg) a = Some (x', (l', r')) ->
    (x, (l, r)) <> (x', (l', r')).

Let new_cfg := gc cfg ul.

Lemma no_dup_new :
 forall (x' : BDDvar) (l' r' a : ad),
 MapGet _ (bs_of_cfg new_cfg) a = Some (x', (l', r')) ->
 (x, (l, r)) <> (x', (l', r')).

Lemma new_cfg_OK : BDDconfig_OK new_cfg.

Lemma new_cfg_nodes_preserved : used_nodes_preserved cfg new_cfg ul.

Lemma new_l_OK : node_OK (bs_of_cfg new_cfg) l.

Lemma new_r_OK : node_OK (bs_of_cfg new_cfg) r.

Lemma BDD_OK_l : BDD_OK (bs_of_cfg new_cfg) l.

Lemma BDD_OK_r : BDD_OK (bs_of_cfg new_cfg) r.

Lemma new_xl_lt_x :
 forall (xl : BDDvar) (ll rl : ad),
 MapGet _ (bs_of_cfg new_cfg) l = Some (xl, (ll, rl)) ->
 BDDcompare xl x = Datatypes.Lt.

Lemma new_xr_lt_x :
 forall (xr : BDDvar) (lr rr : ad),
 MapGet _ (bs_of_cfg new_cfg) r = Some (xr, (lr, rr)) ->
 BDDcompare xr x = Datatypes.Lt.

Definition BDDalloc : BDDconfig * ad :=
  match new_cfg with
  | (bs, (share, (fl, (cnt, (negm, orm))))) =>
      match fl with
      | a :: fl' =>
          (MapPut _ bs a (x, (l, r)),
          (MapPut3 _ share l r x a, (fl', (cnt, (negm, orm)))), a)
      | nil =>
          (MapPut _ bs cnt (x, (l, r)),
          (MapPut3 _ share l r x cnt, (fl, (ad_S cnt, (negm, orm)))), cnt)
      end
  end.
  
Lemma BDDalloc_lemma_1 :
 forall a : ad,
 MapGet _ (fst (fst BDDalloc)) a =
 (if Neqb a (snd BDDalloc)
  then Some (x, (l, r))
  else MapGet _ (fst new_cfg) a).

Lemma BDDalloc_lemma_2 :
 In (snd BDDalloc) (fl_of_cfg new_cfg) \/ cnt_of_cfg new_cfg = snd BDDalloc.

Lemma BDDalloc_lemma_3 : MapGet _ (bs_of_cfg new_cfg) (snd BDDalloc) = None.

Lemma BDDalloc_lemma_4 :
 fst (fst BDDalloc) = MapPut _ (bs_of_cfg new_cfg) (snd BDDalloc) (x, (l, r)).

Lemma BDDalloc_lemma_5 :
 fst (snd (fst BDDalloc)) =
 MapPut3 _ (share_of_cfg new_cfg) l r x (snd BDDalloc).

Lemma BDDalloc_preserves_nodes :
 nodes_preserved_bs (bs_of_cfg new_cfg) (fst (fst BDDalloc)).

Lemma BDDalloc_zero : MapGet _ (fst (fst BDDalloc)) BDDzero = None.

Lemma BDDalloc_one : MapGet _ (fst (fst BDDalloc)) BDDone = None.

Lemma BDDalloc_BDD_OK : BDD_OK (fst (fst BDDalloc)) (snd BDDalloc).

Lemma BDDalloc_keeps_state_OK : BDDstate_OK (fst (fst BDDalloc)).

Lemma BDDsharing_OK_1 :
 forall a : ad,
 MapGet _ (bs_of_cfg new_cfg) a = None ->
 BDDsharing_OK (MapPut _ (bs_of_cfg new_cfg) a (x, (l, r)))
   (MapPut3 _ (share_of_cfg new_cfg) l r x a).

Lemma BDDalloc_keeps_sharing_OK :
 BDDsharing_OK (fst (fst BDDalloc)) (fst (snd (fst BDDalloc))).

Lemma BDDalloc_keeps_cnt_OK :
 cnt_OK (fst (fst BDDalloc)) (fst (snd (snd (snd (fst BDDalloc))))).

Lemma BDDalloc_keeps_free_list_OK :
 BDDfree_list_OK (fst (fst BDDalloc)) (fst (snd (snd (fst BDDalloc))))
   (fst (snd (snd (snd (fst BDDalloc))))).

Lemma BDDalloc_orm_same : orm_of_cfg (fst BDDalloc) = orm_of_cfg new_cfg.

Lemma BDDalloc_negm_same : negm_of_cfg (fst BDDalloc) = negm_of_cfg new_cfg.

Lemma BDDalloc_um_same : um_of_cfg (fst BDDalloc) = um_of_cfg new_cfg.

Lemma BDDalloc_keeps_neg_memo_OK :
 BDDneg_memo_OK (bs_of_cfg (fst BDDalloc)) (negm_of_cfg (fst BDDalloc)).

Lemma BDDalloc_keeps_or_memo_OK :
 BDDor_memo_OK (bs_of_cfg (fst BDDalloc)) (orm_of_cfg (fst BDDalloc)).

Lemma BDDalloc_keeps_univ_memo_OK :
 BDDuniv_memo_OK (bs_of_cfg (fst BDDalloc)) (um_of_cfg (fst BDDalloc)).

Lemma BDDalloc_keeps_config_OK : BDDconfig_OK (fst BDDalloc).
 
Lemma BDDalloc_preserves_used_nodes :
 used_nodes_preserved cfg (fst BDDalloc) ul.

Lemma BDDalloc_node_OK : config_node_OK (fst BDDalloc) (snd BDDalloc).

Lemma BDDallocGet :
 MapGet _ (fst (fst BDDalloc)) (snd BDDalloc) = Some (x, (l, r)).

End BDD_alloc. *)
Require Import make.
(* make:
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import ZArith NArith Nnat Ndec Ndigits.
From IntMap Require Import Map.
From IntMap Require Import Allmaps.
Require Import List.
Require Import Wf_nat.

Require Import misc.
Require Import bool_fun.
Require Import myMap.
Require Import config.
Require Import alloc.

Section BDD_make.

Variable gc : BDDconfig -> list ad -> BDDconfig.
Hypothesis gc_is_OK : gc_OK gc.

Variable cfg : BDDconfig.
Variable x : BDDvar.
Variable l r : ad.
Variable ul : list ad.

Hypothesis cfg_OK : BDDconfig_OK cfg.
Hypothesis ul_OK : used_list_OK cfg ul.
Hypothesis l_used' : used_node' cfg ul l.
Hypothesis r_used' : used_node' cfg ul r.
Hypothesis
  xl_lt_x :
    forall (xl : BDDvar) (ll rl : ad),
    MapGet _ (bs_of_cfg cfg) l = Some (xl, (ll, rl)) ->
    BDDcompare xl x = Datatypes.Lt.
Hypothesis
  xr_lt_x :
    forall (xr : BDDvar) (lr rr : ad),
    MapGet _ (bs_of_cfg cfg) r = Some (xr, (lr, rr)) ->
    BDDcompare xr x = Datatypes.Lt.

Lemma no_dup :
 MapGet3 ad (fst (snd cfg)) l r x = None ->
 forall (x' : BDDvar) (l' r' a : ad),
 MapGet (BDDvar * (ad * ad)) (bs_of_cfg cfg) a =
 Some (x', (l', r')) -> (x, (l, r)) <> (x', (l', r')).

Definition BDDmake :=
  if Neqb l r
  then (cfg, l)
  else
   match MapGet3 _ (fst (snd cfg)) l r x with
   | Some y => (cfg, y)
   | None => BDDalloc gc cfg x l r ul
   end.

Lemma BDDmake_keeps_config_OK : BDDconfig_OK (fst BDDmake).

Lemma BDDmake_preserves_used_nodes :
 used_nodes_preserved cfg (fst BDDmake) ul.

Lemma BDDmake_node_OK : config_node_OK (fst BDDmake) (snd BDDmake).

Lemma BDDmake_bool_fun :
 bool_fun_eq (bool_fun_of_BDD (fst BDDmake) (snd BDDmake))
   (bool_fun_if x (bool_fun_of_BDD cfg r) (bool_fun_of_BDD cfg l)).

Lemma BDDmake_node_height_eq :
 Neqb l r = false ->
 Neqb (node_height (fst BDDmake) (snd BDDmake)) (ad_S x) = true.

Lemma BDDmake_node_height_eq_1 :
 Neqb l r = true ->
 Neqb (node_height (fst BDDmake) (snd BDDmake)) (node_height cfg l) = true.

Lemma BDDmake_node_height_le :
 Nleb (node_height (fst BDDmake) (snd BDDmake)) (ad_S x) = true.

End BDD_make. *)
Require Import neg.
(* neg:
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import ZArith NArith Nnat Ndec Ndigits.
From IntMap Require Import Map.
From IntMap Require Import Allmaps.
Require Import List.
Require Import Wf_nat.

Require Import misc.
Require Import bool_fun.
Require Import myMap.
Require Import config.
Require Import alloc.
Require Import make.

Section BDD_neg.

Variable gc : BDDconfig -> list ad -> BDDconfig.
Hypothesis gc_is_OK : gc_OK gc.

Fixpoint BDDneg_1 (cfg : BDDconfig) (ul : list ad) 
 (node : ad) (bound : nat) {struct bound} : BDDconfig * ad :=
  match bound with
  | O =>   (initBDDconfig, BDDzero)
  | S bound' =>
      match MapGet _ (negm_of_cfg cfg) node with
      | Some node' => (cfg, node')
      | None =>
          match MapGet _ (fst cfg) node with
          | None =>
              if Neqb node BDDzero
              then (BDDneg_memo_put cfg BDDzero BDDone, BDDone)
              else (BDDneg_memo_put cfg BDDone BDDzero, BDDzero)
          | Some (x, (l, r)) =>
              match BDDneg_1 cfg ul l bound' with
              | (cfgl, nodel) =>
                  match BDDneg_1 cfgl (nodel :: ul) r bound' with
                  | (cfgr, noder) =>
                      match
                        BDDmake gc cfgr x nodel noder (noder :: nodel :: ul)
                      with
                      | (cfg', node') =>
                          (BDDneg_memo_put cfg' node node', node')
                      end
                  end
              end
          end
      end
  end.
  
Lemma BDDneg_1_lemma :
 forall (bound : nat) (cfg : BDDconfig) (ul : list ad) (node : ad),
 nat_of_N (node_height cfg node) < bound ->
 BDDconfig_OK cfg ->
 used_list_OK cfg ul ->
 used_node' cfg ul node ->
 BDDconfig_OK (fst (BDDneg_1 cfg ul node bound)) /\
 config_node_OK (fst (BDDneg_1 cfg ul node bound))
   (snd (BDDneg_1 cfg ul node bound)) /\
 used_nodes_preserved cfg (fst (BDDneg_1 cfg ul node bound)) ul /\
 Neqb
   (node_height (fst (BDDneg_1 cfg ul node bound))
      (snd (BDDneg_1 cfg ul node bound))) (node_height cfg node) = true /\
 bool_fun_eq
   (bool_fun_of_BDD (fst (BDDneg_1 cfg ul node bound))
      (snd (BDDneg_1 cfg ul node bound)))
   (bool_fun_neg (bool_fun_of_BDD cfg node)).

End BDD_neg. *)
Require Import or.
(* or:
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import ZArith NArith Nnat Ndec Ndigits.
From IntMap Require Import Map.
From IntMap Require Import Allmaps.
Require Import List.
Require Import Wf_nat.

Require Import misc.
Require Import bool_fun.
Require Import myMap.
Require Import config.
Require Import alloc.
Require Import make.

Section BDD_or.

Variable gc : BDDconfig -> list ad -> BDDconfig.
Hypothesis gc_is_OK : gc_OK gc.

Fixpoint BDDor_1 (cfg : BDDconfig) (ul : list ad) (node1 node2 : ad)
 (bound : nat) {struct bound} : BDDconfig * ad :=
  match bound with
  | O =>   (initBDDconfig, BDDzero)
  | S bound' =>
      match MapGet2 _ (orm_of_cfg cfg) node1 node2 with
      | Some node' => (cfg, node')
      | None =>
          match MapGet _ (fst cfg) node1 with
          | None =>
              if Neqb node1 BDDzero
              then (BDDor_memo_put cfg node1 node2 node2, node2)
              else (BDDor_memo_put cfg node1 node2 node1, node1)
          | Some (x1, (l1, r1)) =>
              match MapGet _ (fst cfg) node2 with
              | None =>
                  if Neqb node2 BDDzero
                  then (BDDor_memo_put cfg node1 node2 node1, node1)
                  else (BDDor_memo_put cfg node1 node2 node2, node2)
              | Some (x2, (l2, r2)) =>
                  match BDDcompare x1 x2 with
                  | Datatypes.Eq =>
                      match BDDor_1 cfg ul l1 l2 bound' with
                      | (cfgl, nodel) =>
                          match BDDor_1 cfgl (nodel :: ul) r1 r2 bound' with
                          | (cfgr, noder) =>
                              match
                                BDDmake gc cfgr x1 nodel noder
                                  (noder :: nodel :: ul)
                              with
                              | (cfg', node') =>
                                  (BDDor_memo_put cfg' node1 node2 node',
                                  node')
                              end
                          end
                      end
                  | Datatypes.Gt =>
                      match BDDor_1 cfg ul l1 node2 bound' with
                      | (cfgl, nodel) =>
                          match
                            BDDor_1 cfgl (nodel :: ul) r1 node2 bound'
                          with
                          | (cfgr, noder) =>
                              match
                                BDDmake gc cfgr x1 nodel noder
                                  (noder :: nodel :: ul)
                              with
                              | (cfg', node') =>
                                  (BDDor_memo_put cfg' node1 node2 node',
                                  node')
                              end
                          end
                      end
                  | Datatypes.Lt =>
                      match BDDor_1 cfg ul node1 l2 bound' with
                      | (cfgl, nodel) =>
                          match
                            BDDor_1 cfgl (nodel :: ul) node1 r2 bound'
                          with
                          | (cfgr, noder) =>
                              match
                                BDDmake gc cfgr x2 nodel noder
                                  (noder :: nodel :: ul)
                              with
                              | (cfg', node') =>
                                  (BDDor_memo_put cfg' node1 node2 node',
                                  node')
                              end
                          end
                      end
                  end
              end
          end
      end
  end.

Lemma BDDor_1_lemma :
 forall (bound : nat) (cfg : BDDconfig) (ul : list ad) (node1 node2 : ad),
 max (nat_of_N (node_height cfg node1)) (nat_of_N (node_height cfg node2)) <
 bound ->
 BDDconfig_OK cfg ->
 used_list_OK cfg ul ->
 used_node' cfg ul node1 ->
 used_node' cfg ul node2 ->
 BDDconfig_OK (fst (BDDor_1 cfg ul node1 node2 bound)) /\
 config_node_OK (fst (BDDor_1 cfg ul node1 node2 bound))
   (snd (BDDor_1 cfg ul node1 node2 bound)) /\
 used_nodes_preserved cfg (fst (BDDor_1 cfg ul node1 node2 bound)) ul /\
 Nleb
   (node_height (fst (BDDor_1 cfg ul node1 node2 bound))
      (snd (BDDor_1 cfg ul node1 node2 bound)))
   (BDDvar_max (node_height cfg node1) (node_height cfg node2)) = true /\
 bool_fun_eq
   (bool_fun_of_BDD (fst (BDDor_1 cfg ul node1 node2 bound))
      (snd (BDDor_1 cfg ul node1 node2 bound)))
   (bool_fun_or (bool_fun_of_BDD cfg node1) (bool_fun_of_BDD cfg node2)).

End BDD_or. *)
Require Import univ.
(* univ:
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import ZArith NArith Nnat Ndec Ndigits.
From IntMap Require Import Map.
From IntMap Require Import Allmaps.
Require Import List.
Require Import Wf_nat.

Require Import misc.
Require Import bool_fun.
Require Import myMap.
Require Import config.
Require Import alloc.
Require Import make.
Require Import op.

Section BDDuniv_sec.

Variable gc : BDDconfig -> list ad -> BDDconfig.
Hypothesis gc_is_OK : gc_OK gc.

Fixpoint BDDuniv_1 (cfg : BDDconfig) (ul : list ad) 
 (node : ad) (y : BDDvar) (bound : nat) {struct bound} : 
 BDDconfig * ad :=
  match bound with
  | O =>   (initBDDconfig, BDDzero)
  | S bound' =>
      match MapGet2 _ (um_of_cfg cfg) node y with
      | Some node' => (cfg, node')
      | None =>
          match MapGet _ (fst cfg) node with
          | None => (cfg, node)
          | Some (x, (l, r)) =>
              match BDDcompare x y with
              | Datatypes.Lt => (cfg, node)
              | Datatypes.Eq => BDDand gc cfg ul l r
              | Datatypes.Gt =>
                  match BDDuniv_1 cfg ul l y bound' with
                  | (cfgl, nodel) =>
                      match BDDuniv_1 cfgl (nodel :: ul) r y bound' with
                      | (cfgr, noder) =>
                          match
                            BDDmake gc cfgr x nodel noder
                              (noder :: nodel :: ul)
                          with
                          | (cfg', node') =>
                              (BDDuniv_memo_put cfg' y node node', node')
                          end
                      end
                  end
              end
          end
      end
  end.

Lemma BDDuniv_1_lemma :
 forall (bound : nat) (cfg : BDDconfig) (ul : list ad) 
   (u : BDDvar) (node : ad),
 nat_of_N (node_height cfg node) < bound ->
 BDDconfig_OK cfg ->
 used_list_OK cfg ul ->
 used_node' cfg ul node ->
 BDDconfig_OK (fst (BDDuniv_1 cfg ul node u bound)) /\
 config_node_OK (fst (BDDuniv_1 cfg ul node u bound))
   (snd (BDDuniv_1 cfg ul node u bound)) /\
 used_nodes_preserved cfg (fst (BDDuniv_1 cfg ul node u bound)) ul /\
 Nleb
   (node_height (fst (BDDuniv_1 cfg ul node u bound))
      (snd (BDDuniv_1 cfg ul node u bound))) (node_height cfg node) = true /\
 bool_fun_eq
   (bool_fun_of_BDD (fst (BDDuniv_1 cfg ul node u bound))
      (snd (BDDuniv_1 cfg ul node u bound)))
   (bool_fun_forall u (bool_fun_of_BDD cfg node)).

End BDDuniv_sec. *)
Require Import op.
(* op:
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import ZArith NArith Nnat Ndec Ndigits.
From IntMap Require Import Map.
From IntMap Require Import Allmaps.
Require Import List.
Require Import Wf_nat.

Require Import misc.
Require Import bool_fun.
Require Import myMap.
Require Import config.
Require Import alloc.
Require Import make.
Require Import neg.
Require Import or.

Section BDDop.

Variable gc : BDDconfig -> list ad -> BDDconfig.
Hypothesis gc_is_OK : gc_OK gc.

                         Section BDDneg_results.

Variable cfg : BDDconfig.
Variable ul : list ad.
Variable node : ad.

Hypothesis cfg_OK : BDDconfig_OK cfg.
Hypothesis ul_OK : used_list_OK cfg ul.
Hypothesis used : used_node' cfg ul node.

Definition BDDneg :=
  BDDneg_1 gc cfg ul node (S (nat_of_N (node_height cfg node))).

Let lt_1 :
  nat_of_N (node_height cfg node) < S (nat_of_N (node_height cfg node)).

Lemma BDDneg_config_OK : BDDconfig_OK (fst BDDneg).

Lemma BDDneg_node_OK : config_node_OK (fst BDDneg) (snd BDDneg).

Lemma BDDneg_used_nodes_preserved : used_nodes_preserved cfg (fst BDDneg) ul.

Lemma BDDneg_is_neg :
 bool_fun_eq (bool_fun_of_BDD (fst BDDneg) (snd BDDneg))
   (bool_fun_neg (bool_fun_of_BDD cfg node)).

Lemma BDDneg_list_OK : used_list_OK (fst BDDneg) ul.

Lemma BDDneg_list_OK_cons : used_list_OK (fst BDDneg) (snd BDDneg :: ul).

Lemma BDDneg_var_eq :
 Neqb (node_height (fst BDDneg) (snd BDDneg)) (node_height cfg node) = true.

                         End BDDneg_results.

                        Section BDDor_results.

Variable cfg : BDDconfig.
Variable ul : list ad.
Variable node1 node2 : ad.

Hypothesis cfg_OK : BDDconfig_OK cfg.
Hypothesis ul_OK : used_list_OK cfg ul.
Hypothesis used1 : used_node' cfg ul node1.
Hypothesis used2 : used_node' cfg ul node2.

Definition BDDor :=
  BDDor_1 gc cfg ul node1 node2
    (S
       (max (nat_of_N (node_height cfg node1))
          (nat_of_N (node_height cfg node2)))).
Let lt_1 :
  max (nat_of_N (node_height cfg node1)) (nat_of_N (node_height cfg node2)) <
  S
    (max (nat_of_N (node_height cfg node1))
       (nat_of_N (node_height cfg node2))).

Lemma BDDor_config_OK : BDDconfig_OK (fst BDDor).

Lemma BDDor_node_OK : config_node_OK (fst BDDor) (snd BDDor).

Lemma BDDor_used_nodes_preserved : used_nodes_preserved cfg (fst BDDor) ul.

Lemma BDDor_is_or :
 bool_fun_eq (bool_fun_of_BDD (fst BDDor) (snd BDDor))
   (bool_fun_or (bool_fun_of_BDD cfg node1) (bool_fun_of_BDD cfg node2)).

Lemma BDDor_list_OK : used_list_OK (fst BDDor) ul.

Lemma BDDor_list_OK_cons : used_list_OK (fst BDDor) (snd BDDor :: ul).

Lemma BDDor_var_le :
 Nleb (node_height (fst BDDor) (snd BDDor))
   (BDDvar_max (node_height cfg node1) (node_height cfg node2)) = true.

                          End BDDor_results.

                       Section BDDimpl_results.

Variable cfg : BDDconfig.
Variable ul : list ad.
Variable node1 node2 : ad.

Hypothesis cfg_OK : BDDconfig_OK cfg.
Hypothesis ul_OK : used_list_OK cfg ul.
Hypothesis used1 : used_node' cfg ul node1.
Hypothesis used2 : used_node' cfg ul node2.

Definition BDDimpl :=
  match BDDneg cfg ul node1 with
  | (cfg1, node1') => BDDor cfg1 (node1' :: ul) node1' node2
  end.

Lemma BDDimpl_config_OK : BDDconfig_OK (fst BDDimpl).

Lemma BDDimpl_node_OK : config_node_OK (fst BDDimpl) (snd BDDimpl).

Lemma BDDimpl_used_nodes_preserved :
 used_nodes_preserved cfg (fst BDDimpl) ul.

Lemma BDDimpl_is_impl :
 bool_fun_eq (bool_fun_of_BDD (fst BDDimpl) (snd BDDimpl))
   (bool_fun_impl (bool_fun_of_BDD cfg node1) (bool_fun_of_BDD cfg node2)).

Lemma BDDimpl_list_OK : used_list_OK (fst BDDimpl) ul.

Lemma BDDimpl_list_OK_cons : used_list_OK (fst BDDimpl) (snd BDDimpl :: ul).

                         End BDDimpl_results.

                        Section BDDand_results.

Variable cfg : BDDconfig.
Variable ul : list ad.
Variable node1 node2 : ad.

Hypothesis cfg_OK : BDDconfig_OK cfg.
Hypothesis ul_OK : used_list_OK cfg ul.
Hypothesis used1 : used_node' cfg ul node1.
Hypothesis used2 : used_node' cfg ul node2.

Definition BDDand :=
  match BDDneg cfg ul node1 with
  | (cfg1, node1') =>
      match BDDneg cfg1 (node1' :: ul) node2 with
      | (cfg2, node2') =>
          match BDDor cfg2 (node2' :: node1' :: ul) node1' node2' with
          | (cfg3, node3) => BDDneg cfg3 (node3 :: ul) node3
          end
      end
  end.

Lemma BDDand_config_OK : BDDconfig_OK (fst BDDand).

Lemma BDDand_node_OK : config_node_OK (fst BDDand) (snd BDDand).

Lemma BDDand_used_nodes_preserved : used_nodes_preserved cfg (fst BDDand) ul.

Lemma BDDand_is_and :
 bool_fun_eq (bool_fun_of_BDD (fst BDDand) (snd BDDand))
   (bool_fun_and (bool_fun_of_BDD cfg node1) (bool_fun_of_BDD cfg node2)).

Lemma BDDand_list_OK : used_list_OK (fst BDDand) ul.

Lemma BDDand_list_OK_cons : used_list_OK (fst BDDand) (snd BDDand :: ul).

Lemma BDDand_var_le :
 Nleb (node_height (fst BDDand) (snd BDDand))
   (BDDvar_max (node_height cfg node1) (node_height cfg node2)) = true.

                         End BDDand_results.

                       Section BDDiff_results.

Variable cfg : BDDconfig.
Variable ul : list ad.
Variable node1 node2 : ad.

Hypothesis cfg_OK : BDDconfig_OK cfg.
Hypothesis ul_OK : used_list_OK cfg ul.
Hypothesis used1 : used_node' cfg ul node1.
Hypothesis used2 : used_node' cfg ul node2.

Definition BDDiff :=
  match BDDor cfg ul node1 node2 with
  | (cfg1, node3) =>
      match BDDand cfg1 (node3 :: ul) node1 node2 with
      | (cfg2, node4) => BDDimpl cfg2 (node4 :: node3 :: ul) node3 node4
      end
  end.

Lemma BDDiff_config_OK : BDDconfig_OK (fst BDDiff).

Lemma BDDiff_node_OK : config_node_OK (fst BDDiff) (snd BDDiff).

Lemma BDDiff_used_nodes_preserved : used_nodes_preserved cfg (fst BDDiff) ul.

Lemma BDDiff_is_iff :
 bool_fun_eq (bool_fun_of_BDD (fst BDDiff) (snd BDDiff))
   (bool_fun_iff (bool_fun_of_BDD cfg node1) (bool_fun_of_BDD cfg node2)).

Lemma BDDiff_list_OK : used_list_OK (fst BDDiff) ul.

Lemma BDDiff_list_OK_cons : used_list_OK (fst BDDiff) (snd BDDiff :: ul).

                         End BDDiff_results.

                     Section BDDvar_make_results.

Variable cfg : BDDconfig.
Variable ul : list ad.
Variable x : BDDvar.

Hypothesis cfg_OK : BDDconfig_OK cfg.
Hypothesis ul_OK : used_list_OK cfg ul.

Definition BDDvar_make := BDDmake gc cfg x BDDzero BDDone ul.

Lemma BDDvar_make_config_OK : BDDconfig_OK (fst BDDvar_make).

Lemma BDDvar_make_node_OK :
 config_node_OK (fst BDDvar_make) (snd BDDvar_make).

Lemma BDDvar_make_used_nodes_preserved :
 used_nodes_preserved cfg (fst BDDvar_make) ul.

Lemma BDDvar_make_list_OK : used_list_OK (fst BDDvar_make) ul.

Lemma BDDvar_make_list_OK_cons :
 used_list_OK (fst BDDvar_make) (snd BDDvar_make :: ul).

Lemma BDDvar_make_is_var :
 bool_fun_eq (bool_fun_of_BDD (fst BDDvar_make) (snd BDDvar_make))
   (bool_fun_var x).

                          End BDDvar_make_results.

End BDDop. *)
Require Import tauto.
(* tauto:
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import ZArith NArith Nnat Ndec Ndigits.
From IntMap Require Import Allmaps.
Require Import List.
Require Import Wf_nat.

Require Import misc.
Require Import bool_fun.
Require Import myMap.
Require Import config.
Require Import alloc.
Require Import make.
Require Import neg.
Require Import or.
Require Import op.

Section tauto.

Variable gc : BDDconfig -> list ad -> BDDconfig.
Hypothesis gc_is_OK : gc_OK gc.

Fixpoint BDDof_bool_expr (cfg : BDDconfig) (ul : list ad) 
 (be : bool_expr) {struct be} : BDDconfig * ad :=
  match be with
  | Zero => (cfg, BDDzero)
  | One => (cfg, BDDone)
  | Var x => BDDvar_make gc cfg ul x
  | Neg be1 =>
      match BDDof_bool_expr cfg ul be1 with
      | (cfg1, node1) => BDDneg gc cfg1 (node1 :: ul) node1
      end
  | Or be1 be2 =>
      match BDDof_bool_expr cfg ul be1 with
      | (cfg1, node1) =>
          match BDDof_bool_expr cfg1 (node1 :: ul) be2 with
          | (cfg2, node2) => BDDor gc cfg2 (node2 :: node1 :: ul) node1 node2
          end
      end
  | ANd be1 be2 =>
      match BDDof_bool_expr cfg ul be1 with
      | (cfg1, node1) =>
          match BDDof_bool_expr cfg1 (node1 :: ul) be2 with
          | (cfg2, node2) =>
              BDDand gc cfg2 (node2 :: node1 :: ul) node1 node2
          end
      end
  | Impl be1 be2 =>
      match BDDof_bool_expr cfg ul be1 with
      | (cfg1, node1) =>
          match BDDof_bool_expr cfg1 (node1 :: ul) be2 with
          | (cfg2, node2) =>
              BDDimpl gc cfg2 (node2 :: node1 :: ul) node1 node2
          end
      end
  | Iff be1 be2 =>
      match BDDof_bool_expr cfg ul be1 with
      | (cfg1, node1) =>
          match BDDof_bool_expr cfg1 (node1 :: ul) be2 with
          | (cfg2, node2) =>
              BDDiff gc cfg2 (node2 :: node1 :: ul) node1 node2
          end
      end
  end.

Lemma BDDof_bool_expr_correct :
 forall (be : bool_expr) (cfg : BDDconfig) (ul : list ad),
 BDDconfig_OK cfg ->
 used_list_OK cfg ul ->
 BDDconfig_OK (fst (BDDof_bool_expr cfg ul be)) /\
 used_nodes_preserved cfg (fst (BDDof_bool_expr cfg ul be)) ul /\
 config_node_OK (fst (BDDof_bool_expr cfg ul be))
   (snd (BDDof_bool_expr cfg ul be)) /\
 bool_fun_eq
   (bool_fun_of_BDD (fst (BDDof_bool_expr cfg ul be))
      (snd (BDDof_bool_expr cfg ul be))) (bool_fun_of_bool_expr be).

Lemma init_list_OK : forall cfg : BDDconfig, used_list_OK cfg nil.

Definition is_tauto (be : bool_expr) :=
  Neqb BDDone (snd (BDDof_bool_expr initBDDconfig nil be)).

Lemma is_tauto_lemma :
 forall be : bool_expr,
 is_tauto be = true <-> bool_fun_eq bool_fun_one (bool_fun_of_bool_expr be).

End tauto. *)
Require Import quant.
(* quant:
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import ZArith NArith Nnat Ndec Ndigits.
From IntMap Require Import Map.
From IntMap Require Import Allmaps.
Require Import List.
Require Import Wf_nat.
Require Import Compare.
Require Import Peano_dec.

Require Import misc.
Require Import bool_fun.
Require Import myMap.
Require Import config.
Require Import alloc.
Require Import make.
Require Import or.
Require Import op.
Require Import tauto.
Require Import gc.
Require Import univ.

Fixpoint ad_list_neq (l1 l2 : list ad) {struct l2} : bool :=
  match l1, l2 with
  | nil, _ => true
  | _, nil => true
  | a1 :: l1', a2 :: l2' => negb (Neqb a1 a2) && ad_list_neq l1' l2'
  end.

Definition bool_to_be (b : bool) :=
  match b with
  | true => One
  | false => Zero
  end.
Definition bool_to_bf (b : bool) :=
  match b with
  | true => bool_fun_one
  | false => bool_fun_zero
  end.

Definition bool_fun_subst (x : BDDvar) (bfx bf : bool_fun) : bool_fun :=
  fun ve : var_env => bf (augment ve x (bfx ve)).

Definition bool_fun_subst1 (x : BDDvar) (bfx bf : bool_fun) : bool_fun :=
  bool_fun_forall x (bool_fun_impl (bool_fun_iff (bool_fun_var x) bfx) bf).

Definition bool_fun_replace (x y : BDDvar) (bf : bool_fun) :=
  bool_fun_subst x (bool_fun_var y) bf.

Definition bool_fun_restrict1 (x : BDDvar) (b : bool) 
  (bf : bool_fun) := bool_fun_subst x (bool_to_bf b) bf.

Lemma bool_fun_restrict1_eq_restrict :
 forall (bf : bool_fun) (x : BDDvar) (b : bool),
 bool_fun_eq (bool_fun_restrict1 x b bf) (bool_fun_restrict bf x b).

Lemma bool_fun_subst_preserves_eq :
 forall (bf bf' bfx bfx' : bool_fun) (x : BDDvar),
 bool_fun_eq bf bf' ->
 bool_fun_eq bfx bfx' ->
 bool_fun_eq (bool_fun_subst x bfx bf) (bool_fun_subst x bfx' bf').

Lemma bool_fun_replace_preserves_eq :
 forall (bf1 bf2 : bool_fun) (x y : BDDvar),
 bool_fun_eq bf1 bf2 ->
 bool_fun_eq (bool_fun_replace x y bf1) (bool_fun_replace x y bf2).

Fixpoint subst (x : BDDvar) (bex be : bool_expr) {struct be} : bool_expr :=
  match be with
  | Zero => Zero
  | One => One
  | Var y => if Neqb x y then bex else be
  | Neg be1 => Neg (subst x bex be1)
  | Or be1 be2 => Or (subst x bex be1) (subst x bex be2)
  | ANd be1 be2 => ANd (subst x bex be1) (subst x bex be2)
  | Impl be1 be2 => Impl (subst x bex be1) (subst x bex be2)
  | Iff be1 be2 => Iff (subst x bex be1) (subst x bex be2)
  end.

Lemma subst_ok :
 forall (be bex : bool_expr) (x : BDDvar),
 bool_fun_eq (bool_fun_of_bool_expr (subst x bex be))
   (bool_fun_subst x (bool_fun_of_bool_expr bex) (bool_fun_of_bool_expr be)).

Fixpoint bool_fun_univl (bf : bool_fun) (la : list ad) {struct la} :
 bool_fun :=
  match la with
  | nil => bf
  | a :: la' => bool_fun_forall a (bool_fun_univl bf la')
  end.

Fixpoint bool_fun_exl (bf : bool_fun) (la : list ad) {struct la} :
 bool_fun :=
  match la with
  | nil => bf
  | a :: la' => bool_fun_ex a (bool_fun_exl bf la')
  end.

Lemma bool_fun_subst1_eq_subst :
 forall (x : BDDvar) bfx (bf : bool_fun),
 bool_fun_independent bfx x ->
 bool_fun_eq (bool_fun_subst1 x bfx bf) (bool_fun_subst x bfx bf).

Definition restrict (x : BDDvar) (b : bool) (be : bool_expr) :=
  subst x (bool_to_be b) be.

Lemma bool_fun_restrict_eq_subst :
 forall (x : BDDvar) (b : bool) (bf : bool_fun),
 bool_fun_eq (bool_fun_restrict bf x b) (bool_fun_subst x (bool_to_bf b) bf).

Lemma bool_to_be_to_bf :
 forall b : bool, bool_fun_of_bool_expr (bool_to_be b) = bool_to_bf b.

Lemma restrict_OK :
 forall (x : BDDvar) (b : bool) (be : bool_expr),
 bool_fun_eq (bool_fun_of_bool_expr (restrict x b be))
   (bool_fun_restrict (bool_fun_of_bool_expr be) x b).

Definition forall_ (x : BDDvar) (be : bool_expr) : bool_expr :=
  ANd (restrict x true be) (restrict x false be).

Definition be_ex (x : BDDvar) (be : bool_expr) : bool_expr :=
  Or (restrict x true be) (restrict x false be).

Lemma forall_OK :
 forall (x : BDDvar) (be : bool_expr),
 bool_fun_eq (bool_fun_of_bool_expr (forall_ x be))
   (bool_fun_forall x (bool_fun_of_bool_expr be)).
 
Lemma ex_OK :
 forall (x : BDDvar) (be : bool_expr),
 bool_fun_eq (bool_fun_of_bool_expr (be_ex x be))
   (bool_fun_ex x (bool_fun_of_bool_expr be)).
 
Fixpoint univl (be : bool_expr) (la : list ad) {struct la} : bool_expr :=
  match la with
  | nil => be
  | a :: la' => forall_ a (univl be la')
  end.

Fixpoint exl (be : bool_expr) (la : list ad) {struct la} : bool_expr :=
  match la with
  | nil => be
  | a :: la' => be_ex a (exl be la')
  end.

Lemma univl_OK :
 forall (la : list ad) (be : bool_expr),
 bool_fun_eq (bool_fun_of_bool_expr (univl be la))
   (bool_fun_univl (bool_fun_of_bool_expr be) la).

Lemma exl_OK :
 forall (la : list ad) (be : bool_expr),
 bool_fun_eq (bool_fun_of_bool_expr (exl be la))
   (bool_fun_exl (bool_fun_of_bool_expr be) la).

Definition replace (x y : BDDvar) (be : bool_expr) := subst x (Var y) be.

Lemma replace_OK :
 forall (x y : BDDvar) (be : bool_expr),
 bool_fun_eq (bool_fun_of_bool_expr (replace x y be))
   (bool_fun_replace x y (bool_fun_of_bool_expr be)).

Fixpoint replacel (be : bool_expr) (lx ly : list ad) {struct ly} :
 bool_expr :=
  match lx, ly with
  | nil, _ => be
  | _ :: _, nil =>   be
  | x :: lx', y :: ly' => replace x y (replacel be lx' ly')
  end.

Fixpoint bool_fun_replacel (bf : bool_fun) (lx ly : list ad) {struct ly} :
 bool_fun :=
  match lx, ly with
  | nil, _ => bf
  | _ :: _, nil =>   bf
  | x :: lx', y :: ly' => bool_fun_replace x y (bool_fun_replacel bf lx' ly')
  end.

Lemma replacel_OK :
 forall (lx ly : list ad) (be : bool_expr),
 bool_fun_eq (bool_fun_of_bool_expr (replacel be lx ly))
   (bool_fun_replacel (bool_fun_of_bool_expr be) lx ly).

Section BDDquant.

Variable gc : BDDconfig -> list ad -> BDDconfig.
Hypothesis gc_is_OK : gc_OK gc.

                          Section BDDuniv_results.

Variable cfg : BDDconfig.
Variable ul : list ad.
Variable y : BDDvar.
Variable node : ad.

Hypothesis cfg_OK : BDDconfig_OK cfg.
Hypothesis ul_OK : used_list_OK cfg ul.
Hypothesis used : used_node' cfg ul node.

Definition BDDuniv :=
  BDDuniv_1 gc cfg ul node y (S (nat_of_N (node_height cfg node))).

Let lt_1 :
  nat_of_N (node_height cfg node) < S (nat_of_N (node_height cfg node)).

Lemma BDDuniv_config_OK : BDDconfig_OK (fst BDDuniv).

Lemma BDDuniv_node_OK : config_node_OK (fst BDDuniv) (snd BDDuniv).

Lemma BDDuniv_used_nodes_preserved :
 used_nodes_preserved cfg (fst BDDuniv) ul.

Lemma BDDuniv_is_univ :
 bool_fun_eq (bool_fun_of_BDD (fst BDDuniv) (snd BDDuniv))
   (bool_fun_forall y (bool_fun_of_BDD cfg node)).

Lemma BDDuniv_list_OK : used_list_OK (fst BDDuniv) ul.

Lemma BDDuniv_list_OK_cons : used_list_OK (fst BDDuniv) (snd BDDuniv :: ul).

Lemma BDDuniv_var_le :
 Nleb (node_height (fst BDDuniv) (snd BDDuniv)) (node_height cfg node) =
 true.

                          End BDDuniv_results.

                         Section BDDex_results.

Variable cfg : BDDconfig.
Variable ul : list ad.
Variable y : BDDvar.
Variable node : ad.
 
Hypothesis cfg_OK : BDDconfig_OK cfg.
Hypothesis ul_OK : used_list_OK cfg ul.
Hypothesis used : used_node' cfg ul node.

Definition BDDex :=
  match BDDneg gc cfg ul node with
  | (cfg1, node1) =>
      match BDDuniv cfg1 (node1 :: ul) y node1 with
      | (cfg2, node2) => BDDneg gc cfg2 (node2 :: ul) node2
      end
  end.

Lemma BDDex_config_OK : BDDconfig_OK (fst BDDex).

Lemma BDDex_node_OK : config_node_OK (fst BDDex) (snd BDDex).

Lemma BDDex_used_nodes_preserved : used_nodes_preserved cfg (fst BDDex) ul.

Lemma BDDex_is_ex :
 bool_fun_eq (bool_fun_of_BDD (fst BDDex) (snd BDDex))
   (bool_fun_ex y (bool_fun_of_BDD cfg node)).

Lemma BDDex_list_OK : used_list_OK (fst BDDex) ul.
 
Lemma BDDex_list_OK_cons : used_list_OK (fst BDDex) (snd BDDex :: ul).

                           End BDDex_results.
                          
Fixpoint BDDunivl (cfg : BDDconfig) (ul : list ad) 
 (node : ad) (ly : list BDDvar) {struct ly} : BDDconfig * ad :=
  match ly with
  | nil => (cfg, node)
  | y :: ly' =>
      match BDDunivl cfg ul node ly' with
      | (cfg1, node1) => BDDuniv cfg1 (node1 :: ul) y node1
      end
  end.

Lemma BDDunivl_lemma :
 forall (ly : list BDDvar) (cfg : BDDconfig) (ul : list ad) (node : ad),
 BDDconfig_OK cfg ->
 used_list_OK cfg ul ->
 used_node' cfg ul node ->
 BDDconfig_OK (fst (BDDunivl cfg ul node ly)) /\
 config_node_OK (fst (BDDunivl cfg ul node ly))
   (snd (BDDunivl cfg ul node ly)) /\
 used_nodes_preserved cfg (fst (BDDunivl cfg ul node ly)) ul /\
 bool_fun_eq
   (bool_fun_of_BDD (fst (BDDunivl cfg ul node ly))
      (snd (BDDunivl cfg ul node ly)))
   (bool_fun_univl (bool_fun_of_BDD cfg node) ly).

                          Section BDDunivl_results.

Variable cfg : BDDconfig.
Variable ul : list ad.
Variable node : ad.
Variable ly : list BDDvar.

Hypothesis cfg_OK : BDDconfig_OK cfg.
Hypothesis ul_OK : used_list_OK cfg ul.
Hypothesis used : used_node' cfg ul node.

Lemma BDDunivl_config_OK : BDDconfig_OK (fst (BDDunivl cfg ul node ly)).

Lemma BDDunivl_node_OK :
 config_node_OK (fst (BDDunivl cfg ul node ly))
   (snd (BDDunivl cfg ul node ly)).

Lemma BDDunivl_used_nodes_preserved :
 used_nodes_preserved cfg (fst (BDDunivl cfg ul node ly)) ul.

Lemma BDDunivl_list_OK : used_list_OK (fst (BDDunivl cfg ul node ly)) ul.

Lemma BDDunivl_list_OK_cons :
 used_list_OK (fst (BDDunivl cfg ul node ly))
   (snd (BDDunivl cfg ul node ly) :: ul).

Lemma BDDunivl_is_univl :
 bool_fun_eq
   (bool_fun_of_BDD (fst (BDDunivl cfg ul node ly))
      (snd (BDDunivl cfg ul node ly)))
   (bool_fun_univl (bool_fun_of_BDD cfg node) ly).

                          End BDDunivl_results.

Fixpoint BDDexl (cfg : BDDconfig) (ul : list ad) (node : ad)
 (ly : list BDDvar) {struct ly} : BDDconfig * ad :=
  match ly with
  | nil => (cfg, node)
  | y :: ly' =>
      match BDDexl cfg ul node ly' with
      | (cfg1, node1) => BDDex cfg1 (node1 :: ul) y node1
      end
  end.

Lemma BDDexl_lemma :
 forall (ly : list BDDvar) (cfg : BDDconfig) (ul : list ad) (node : ad),
 BDDconfig_OK cfg ->
 used_list_OK cfg ul ->
 used_node' cfg ul node ->
 BDDconfig_OK (fst (BDDexl cfg ul node ly)) /\
 config_node_OK (fst (BDDexl cfg ul node ly)) (snd (BDDexl cfg ul node ly)) /\
 used_nodes_preserved cfg (fst (BDDexl cfg ul node ly)) ul /\
 bool_fun_eq
   (bool_fun_of_BDD (fst (BDDexl cfg ul node ly))
      (snd (BDDexl cfg ul node ly)))
   (bool_fun_exl (bool_fun_of_BDD cfg node) ly).

                          Section BDDexl_results.

Variable cfg : BDDconfig.
Variable ul : list ad.
Variable node : ad.
Variable ly : list BDDvar.

Hypothesis cfg_OK : BDDconfig_OK cfg.
Hypothesis ul_OK : used_list_OK cfg ul.
Hypothesis used : used_node' cfg ul node.

Lemma BDDexl_config_OK : BDDconfig_OK (fst (BDDexl cfg ul node ly)).

Lemma BDDexl_node_OK :
 config_node_OK (fst (BDDexl cfg ul node ly)) (snd (BDDexl cfg ul node ly)).

Lemma BDDexl_used_nodes_preserved :
 used_nodes_preserved cfg (fst (BDDexl cfg ul node ly)) ul.

Lemma BDDexl_list_OK : used_list_OK (fst (BDDexl cfg ul node ly)) ul.

Lemma BDDexl_list_OK_cons :
 used_list_OK (fst (BDDexl cfg ul node ly))
   (snd (BDDexl cfg ul node ly) :: ul).

Lemma BDDexl_is_exl :
 bool_fun_eq
   (bool_fun_of_BDD (fst (BDDexl cfg ul node ly))
      (snd (BDDexl cfg ul node ly)))
   (bool_fun_exl (bool_fun_of_BDD cfg node) ly).

                          End BDDexl_results.

Definition BDDsubst (cfg : BDDconfig) (ul : list ad) 
  (node1 : ad) (x : BDDvar) (node2 : ad) :=
  match BDDvar_make gc cfg ul x with
  | (cfg1, nodex) =>
      match BDDiff gc cfg1 (nodex :: ul) nodex node2 with
      | (cfg2, node3) =>
          match BDDimpl gc cfg2 (node3 :: ul) node3 node1 with
          | (cfg3, node4) => BDDuniv cfg3 (node4 :: ul) x node4
          end
      end
  end.

Lemma BDDsubst_lemma :
 forall (cfg : BDDconfig) (ul : list ad) (node1 : ad) 
   (x : BDDvar) (node2 : ad),
 BDDconfig_OK cfg ->
 used_list_OK cfg ul ->
 used_node' cfg ul node1 ->
 used_node' cfg ul node2 ->
 BDDconfig_OK (fst (BDDsubst cfg ul node1 x node2)) /\
 config_node_OK (fst (BDDsubst cfg ul node1 x node2))
   (snd (BDDsubst cfg ul node1 x node2)) /\
 used_nodes_preserved cfg (fst (BDDsubst cfg ul node1 x node2)) ul /\
 bool_fun_eq
   (bool_fun_of_BDD (fst (BDDsubst cfg ul node1 x node2))
      (snd (BDDsubst cfg ul node1 x node2)))
   (bool_fun_subst1 x (bool_fun_of_BDD cfg node2) (bool_fun_of_BDD cfg node1)).

Section BDDsubst_results.

Variable cfg : BDDconfig.
Variable ul : list ad.
Variable node1 node2 : ad.
Variable x : ad.

Hypothesis cfg_OK : BDDconfig_OK cfg.
Hypothesis ul_OK : used_list_OK cfg ul.
Hypothesis used1 : used_node' cfg ul node1.
Hypothesis used2 : used_node' cfg ul node2.

Hypothesis node2_ind : bool_fun_independent (bool_fun_of_BDD cfg node2) x.

Lemma BDDsubst_config_OK : BDDconfig_OK (fst (BDDsubst cfg ul node1 x node2)).

Lemma BDDsubst_node_OK :
 config_node_OK (fst (BDDsubst cfg ul node1 x node2))
   (snd (BDDsubst cfg ul node1 x node2)).

Lemma BDDsubst_used_nodes_preserved :
 used_nodes_preserved cfg (fst (BDDsubst cfg ul node1 x node2)) ul.

Lemma BDDsubst_list_OK :
 used_list_OK (fst (BDDsubst cfg ul node1 x node2)) ul.

Lemma BDDsubst_list_OK_cons :
 used_list_OK (fst (BDDsubst cfg ul node1 x node2))
   (snd (BDDsubst cfg ul node1 x node2) :: ul).

Lemma BDDsubst_is_subst1 :
 bool_fun_eq
   (bool_fun_of_BDD (fst (BDDsubst cfg ul node1 x node2))
      (snd (BDDsubst cfg ul node1 x node2)))
   (bool_fun_subst1 x (bool_fun_of_BDD cfg node2) (bool_fun_of_BDD cfg node1)).

Lemma BDDsubst_is_subst :
 bool_fun_eq
   (bool_fun_of_BDD (fst (BDDsubst cfg ul node1 x node2))
      (snd (BDDsubst cfg ul node1 x node2)))
   (bool_fun_subst x (bool_fun_of_BDD cfg node2) (bool_fun_of_BDD cfg node1)).

End BDDsubst_results.

Section BDDreplace_results.

Variable cfg : BDDconfig.
Variable ul : list ad.
Variable node : ad.
Variable x y : ad.

Hypothesis cfg_OK : BDDconfig_OK cfg.
Hypothesis ul_OK : used_list_OK cfg ul.
Hypothesis used : used_node' cfg ul node.

Hypothesis xy_neq : Neqb x y = false.

Definition BDDreplace :=
  match BDDvar_make gc cfg ul y with
  | (cfg1, nodey) => BDDsubst cfg1 (nodey :: ul) node x nodey
  end.

Lemma BDDreplace_config_OK : BDDconfig_OK (fst BDDreplace).

Lemma BDDreplace_node_OK : config_node_OK (fst BDDreplace) (snd BDDreplace).

Lemma BDDreplace_used_nodes_preserved :
 used_nodes_preserved cfg (fst BDDreplace) ul.

Lemma BDDreplace_list_OK : used_list_OK (fst BDDreplace) ul.

Lemma BDDreplace_list_OK_cons :
 used_list_OK (fst BDDreplace) (snd BDDreplace :: ul).

Lemma BDDreplace_is_replace :
 bool_fun_eq (bool_fun_of_BDD (fst BDDreplace) (snd BDDreplace))
   (bool_fun_replace x y (bool_fun_of_BDD cfg node)).

End BDDreplace_results.

Fixpoint BDDreplacel (cfg : BDDconfig) (ul : list ad) 
 (node : ad) (lx ly : list BDDvar) {struct ly} : BDDconfig * ad :=
  match lx, ly with
  | nil, _ => (cfg, node)
  | _ :: _, nil => (cfg, node)
  | x :: lx', y :: ly' =>
      match BDDreplacel cfg ul node lx' ly' with
      | (cfg1, node1) => BDDreplace cfg1 (node1 :: ul) node1 x y
      end
  end.

Lemma BDDreplacel_lemma :
 forall (lx ly : list ad) (cfg : BDDconfig) (ul : list ad) (node : ad),
 BDDconfig_OK cfg ->
 used_list_OK cfg ul ->
 used_node' cfg ul node ->
 ad_list_neq lx ly = true ->
 BDDconfig_OK (fst (BDDreplacel cfg ul node lx ly)) /\
 config_node_OK (fst (BDDreplacel cfg ul node lx ly))
   (snd (BDDreplacel cfg ul node lx ly)) /\
 used_nodes_preserved cfg (fst (BDDreplacel cfg ul node lx ly)) ul /\
 bool_fun_eq
   (bool_fun_of_BDD (fst (BDDreplacel cfg ul node lx ly))
      (snd (BDDreplacel cfg ul node lx ly)))
   (bool_fun_replacel (bool_fun_of_BDD cfg node) lx ly).

Section BDDreplacel_results.

Variable cfg : BDDconfig.
Variable ul : list ad.
Variable node : ad.
Variable lx ly : list BDDvar.

Hypothesis cfg_OK : BDDconfig_OK cfg.
Hypothesis ul_OK : used_list_OK cfg ul.
Hypothesis used : used_node' cfg ul node.

Hypothesis lxy_neq : ad_list_neq lx ly = true.

Lemma BDDreplacel_config_OK :
 BDDconfig_OK (fst (BDDreplacel cfg ul node lx ly)).

Lemma BDDreplacel_node_OK :
 config_node_OK (fst (BDDreplacel cfg ul node lx ly))
   (snd (BDDreplacel cfg ul node lx ly)).

Lemma BDDreplacel_used_nodes_preserved :
 used_nodes_preserved cfg (fst (BDDreplacel cfg ul node lx ly)) ul.

Lemma BDDreplacel_list_OK :
 used_list_OK (fst (BDDreplacel cfg ul node lx ly)) ul.

Lemma BDDreplacel_list_OK_cons :
 used_list_OK (fst (BDDreplacel cfg ul node lx ly))
   (snd (BDDreplacel cfg ul node lx ly) :: ul).

Lemma BDDreplacel_is_replacel :
 bool_fun_eq
   (bool_fun_of_BDD (fst (BDDreplacel cfg ul node lx ly))
      (snd (BDDreplacel cfg ul node lx ly)))
   (bool_fun_replacel (bool_fun_of_BDD cfg node) lx ly).

End BDDreplacel_results.

End BDDquant.

Fixpoint be_x_free (x : BDDvar) (be : bool_expr) {struct be} : bool :=
  match be with
  | Zero => false
  | One => false
  | Var y => Neqb x y
  | Neg be1 => be_x_free x be1
  | Or be1 be2 => be_x_free x be1 || be_x_free x be2
  | ANd be1 be2 => be_x_free x be1 || be_x_free x be2
  | Impl be1 be2 => be_x_free x be1 || be_x_free x be2
  | Iff be1 be2 => be_x_free x be1 || be_x_free x be2
  end.

Lemma subst_x_free :
 forall (be bex : bool_expr) (x y : BDDvar),
 be_x_free y (subst x bex be) = true ->
 be_x_free y be = true /\ Neqb x y = false \/ be_x_free y bex = true.

Lemma restrict_x_free :
 forall (be : bool_expr) (x y : BDDvar) (b : bool),
 be_x_free y (restrict x b be) = true ->
 be_x_free y be = true /\ Neqb x y = false.

Lemma replace_x_free :
 forall (be : bool_expr) (x y z : BDDvar),
 be_x_free z (replace x y be) = true ->
 be_x_free z be = true /\ Neqb x z = false \/ Neqb y z = true.

Lemma replacel_x_free :
 forall (lx ly : list ad) (be : bool_expr) (x : BDDvar),
 length lx = length ly ->
 be_x_free x (replacel be lx ly) = true ->
 be_x_free x be = true /\ ~ In x lx \/ In x ly.

Lemma impl_x_free :
 forall (be1 be2 : bool_expr) (x : BDDvar),
 be_x_free x (Impl be1 be2) = true ->
 be_x_free x be1 = true \/ be_x_free x be2 = true.

Lemma and_x_free :
 forall (be1 be2 : bool_expr) (x : BDDvar),
 be_x_free x (ANd be1 be2) = true ->
 be_x_free x be1 = true \/ be_x_free x be2 = true.

Lemma univ_x_free :
 forall (be : bool_expr) (x y : BDDvar),
 be_x_free y (forall_ x be) = true ->
 be_x_free y be = true /\ Neqb x y = false.

Lemma ex_x_free :
 forall (be : bool_expr) (x y : BDDvar),
 be_x_free y (be_ex x be) = true ->
 be_x_free y be = true /\ Neqb x y = false.

Lemma univl_x_free :
 forall (lx : list ad) (be : bool_expr) (x : BDDvar),
 be_x_free x (univl be lx) = true -> be_x_free x be = true /\ ~ In x lx.

Lemma exl_x_free :
 forall (lx : list ad) (be : bool_expr) (x : BDDvar),
 be_x_free x (exl be lx) = true -> be_x_free x be = true /\ ~ In x lx.

Definition var_env' := nat -> bool.
Definition var_env_to_env' (ve : var_env) : var_env' :=
  fun n : nat => ve (N_of_nat n).
Definition var_env'_to_env (ve : var_env') : var_env :=
  fun x : BDDvar => ve (nat_of_N x).
Definition eval_be' (be : bool_expr) (ve : var_env') :=
  bool_fun_of_bool_expr be (var_env'_to_env ve).
Definition var_env'' := Map unit.
Definition var_env''_to_env (ve : var_env'') : var_env :=
  fun x : ad => in_dom _ x ve.
Definition var_env''_to_env' (ve : var_env'') : var_env' :=
  fun n : nat => in_dom _ (N_of_nat n) ve.

Definition be_eq (be1 be2 : bool_expr) :=
  forall ve : var_env', eval_be' be1 ve = eval_be' be2 ve.
Definition be_eq_dec (be1 be2 : bool_expr) :=
  is_tauto (fun x _ => x) (Iff be1 be2).

Definition be_le (be1 be2 : bool_expr) :=
  forall ve : var_env', eval_be' be1 ve = true -> eval_be' be2 ve = true.

Lemma be_eq_refl : forall be : bool_expr, be_eq be be.

Lemma be_eq_sym : forall be1 be2 : bool_expr, be_eq be1 be2 -> be_eq be2 be1.

Lemma be_eq_le : forall be1 be2 : bool_expr, be_eq be1 be2 -> be_le be1 be2.

Lemma be_eq_dec_correct :
 forall be1 be2 : bool_expr,
 bool_fun_eq (bool_fun_of_bool_expr be1) (bool_fun_of_bool_expr be2) ->
 be_eq_dec be1 be2 = true.

Lemma be_eq_dec_complete :
 forall be1 be2 : bool_expr,
 be_eq_dec be1 be2 = true ->
 bool_fun_eq (bool_fun_of_bool_expr be1) (bool_fun_of_bool_expr be2).

Lemma be_eq_dec_eq :
 forall be1 be2 : bool_expr, be_eq_dec be1 be2 = true -> be_eq be1 be2.

Lemma bool_fun_var_ext : forall x : BDDvar, bool_fun_ext (bool_fun_var x).

Lemma bool_fun_neg_ext :
 forall bf1 : bool_fun, bool_fun_ext bf1 -> bool_fun_ext (bool_fun_neg bf1).

Lemma bool_fun_and_ext :
 forall bf1 bf2 : bool_fun,
 bool_fun_ext bf1 -> bool_fun_ext bf2 -> bool_fun_ext (bool_fun_and bf1 bf2).

Lemma bool_fun_or_ext :
 forall bf1 bf2 : bool_fun,
 bool_fun_ext bf1 -> bool_fun_ext bf2 -> bool_fun_ext (bool_fun_or bf1 bf2).

Lemma bool_fun_impl_ext :
 forall bf1 bf2 : bool_fun,
 bool_fun_ext bf1 -> bool_fun_ext bf2 -> bool_fun_ext (bool_fun_impl bf1 bf2).

Lemma bool_fun_iff_ext :
 forall bf1 bf2 : bool_fun,
 bool_fun_ext bf1 -> bool_fun_ext bf2 -> bool_fun_ext (bool_fun_iff bf1 bf2).

Lemma bool_fun_of_be_ext :
 forall be : bool_expr, bool_fun_ext (bool_fun_of_bool_expr be).

Lemma be_le_refl : forall be : bool_expr, be_le be be.

Lemma be_le_trans :
 forall be1 be2 be3 : bool_expr,
 be_le be1 be2 -> be_le be2 be3 -> be_le be1 be3.

Lemma be_le_antisym :
 forall be1 be2 : bool_expr, be_le be1 be2 -> be_le be2 be1 -> be_eq be1 be2.

Lemma be_eq_trans :
 forall be1 be2 be3 : bool_expr,
 be_eq be1 be2 -> be_eq be2 be3 -> be_eq be1 be3.

Lemma be_eq_eq_dec :
 forall be1 be2 : bool_expr, be_eq be1 be2 -> be_eq_dec be1 be2 = true.

Lemma be_le_not_1 :
 forall be1 be2 : bool_expr, be_le be1 be2 -> be_le (Neg be2) (Neg be1).

Lemma and_le :
 forall be1 be2 be1' be2' : bool_expr,
 be_le be1 be1' -> be_le be2 be2' -> be_le (ANd be1 be2) (ANd be1' be2').

Lemma or_le :
 forall be1 be2 be1' be2' : bool_expr,
 be_le be1 be1' -> be_le be2 be2' -> be_le (Or be1 be2) (Or be1' be2').

Lemma impl_le :
 forall be1 be2 be1' be2' : bool_expr,
 be_le be1' be1 -> be_le be2 be2' -> be_le (Impl be1 be2) (Impl be1' be2').

Lemma and_eq :
 forall be1 be2 be1' be2' : bool_expr,
 be_eq be1 be1' -> be_eq be2 be2' -> be_eq (ANd be1 be2) (ANd be1' be2').

Lemma or_eq :
 forall be1 be2 be1' be2' : bool_expr,
 be_eq be1 be1' -> be_eq be2 be2' -> be_eq (Or be1 be2) (Or be1' be2').

Lemma impl_eq :
 forall be1 be2 be1' be2' : bool_expr,
 be_eq be1 be1' -> be_eq be2 be2' -> be_eq (Impl be1 be2) (Impl be1' be2').

Lemma iff_eq :
 forall be1 be2 be1' be2' : bool_expr,
 be_eq be1 be1' -> be_eq be2 be2' -> be_eq (Iff be1 be2) (Iff be1' be2').

Lemma neg_eq_eq :
 forall be1 be2 : bool_expr, be_eq (Neg be1) (Neg be2) -> be_eq be1 be2.

Lemma eq_neg_eq :
 forall be1 be2 : bool_expr, be_eq be1 be2 -> be_eq (Neg be1) (Neg be2).

Section Nsec.

Variable N : nat.

Definition ap (n : nat) := N_of_nat n.
Definition ap' (n : nat) := N_of_nat (N + n).

Fixpoint lx_1 (n : nat) : list ad :=
  match n with
  | O => nil
  | S m => ap m :: lx_1 m
  end.

Fixpoint lx'_1 (n : nat) : list ad :=
  match n with
  | O => nil (A:=ad)
  | S m => ap' m :: lx'_1 m
  end.

Definition lx := lx_1 N.
Definition lx' := lx'_1 N.
Lemma ap_neq_ap' : forall n : nat, n < N -> Neqb (ap n) (ap' n) = false.

Lemma lx_1_neg_lx'_1 :
 forall n : nat, n <= N -> ad_list_neq (lx_1 n) (lx'_1 n) = true.

Lemma lx_neq_lx' : ad_list_neq lx lx' = true.

Lemma lt_O_n_lx'_1 : forall n : nat, 0 < n -> In (ap' 0) (lx'_1 n).

Definition bool_fun_mu_all (bft bfg : bool_fun) : bool_fun :=
  bool_fun_univl (bool_fun_impl bft (bool_fun_replacel bfg lx lx')) lx'.

Definition bool_fun_mu_ex (bft bfg : bool_fun) : bool_fun :=
  bool_fun_exl (bool_fun_and bft (bool_fun_replacel bfg lx lx')) lx'.

Definition mu_all_eval (t be : bool_expr) : bool_expr :=
  univl (Impl t (replacel be lx lx')) lx'.

Definition mu_ex_eval (t be : bool_expr) : bool_expr :=
  exl (ANd t (replacel be lx lx')) lx'.

Definition BDDmu_all (gc : BDDconfig -> list ad -> BDDconfig)
  (cfg : BDDconfig) (ul : list ad) (nodet nodeg : ad) :=
  match BDDreplacel gc cfg ul nodeg lx lx' with
  | (cfgr, noder) =>
      match BDDimpl gc cfgr (noder :: ul) nodet noder with
      | (cfgi, nodei) => BDDunivl gc cfgi (nodei :: ul) nodei lx'
      end
  end.

Definition BDDmu_ex (gc : BDDconfig -> list ad -> BDDconfig)
  (cfg : BDDconfig) (ul : list ad) (nodet nodeg : ad) :=
  match BDDreplacel gc cfg ul nodeg lx lx' with
  | (cfgr, noder) =>
      match BDDand gc cfgr (noder :: ul) nodet noder with
      | (cfga, nodea) => BDDexl gc cfga (nodea :: ul) nodea lx'
      end
  end.

Lemma bool_fun_univl_preserves_eq :
 forall (l : list ad) (bf1 bf2 : bool_fun),
 bool_fun_eq bf1 bf2 ->
 bool_fun_eq (bool_fun_univl bf1 l) (bool_fun_univl bf2 l).

Lemma bool_fun_exl_preserves_eq :
 forall (l : list ad) (bf1 bf2 : bool_fun),
 bool_fun_eq bf1 bf2 -> bool_fun_eq (bool_fun_exl bf1 l) (bool_fun_exl bf2 l).

Lemma mu_all_eval_ok :
 forall t be : bool_expr,
 bool_fun_eq (bool_fun_of_bool_expr (mu_all_eval t be))
   (bool_fun_mu_all (bool_fun_of_bool_expr t) (bool_fun_of_bool_expr be)).

Lemma mu_ex_eval_ok :
 forall t be : bool_expr,
 bool_fun_eq (bool_fun_of_bool_expr (mu_ex_eval t be))
   (bool_fun_mu_ex (bool_fun_of_bool_expr t) (bool_fun_of_bool_expr be)).

Lemma bool_fun_replacel_preserves_eq :
 forall (lz ly : list ad) (bf1 bf2 : bool_fun),
 bool_fun_eq bf1 bf2 ->
 bool_fun_eq (bool_fun_replacel bf1 lz ly) (bool_fun_replacel bf2 lz ly).

Lemma bool_fun_mu_all_preserves_eq :
 forall bft1 bft2 bfg1 bfg2 : bool_fun,
 bool_fun_eq bft1 bft2 ->
 bool_fun_eq bfg1 bfg2 ->
 bool_fun_eq (bool_fun_mu_all bft1 bfg1) (bool_fun_mu_all bft2 bfg2).

Lemma bool_fun_mu_ex_preserves_eq :
 forall bft1 bft2 bfg1 bfg2 : bool_fun,
 bool_fun_eq bft1 bft2 ->
 bool_fun_eq bfg1 bfg2 ->
 bool_fun_eq (bool_fun_mu_ex bft1 bfg1) (bool_fun_mu_ex bft2 bfg2).

Lemma mu_all_eq :
 forall t be1 be2 : bool_expr,
 be_eq be1 be2 -> be_eq (mu_all_eval t be1) (mu_all_eval t be2).

Lemma mu_ex_eq :
 forall t be1 be2 : bool_expr,
 be_eq be1 be2 -> be_eq (mu_ex_eval t be1) (mu_ex_eval t be2).

Lemma length_lx_1_eq_lx'_1 :
 forall n : nat, length (lx_1 n) = length (lx'_1 n).

Lemma length_lx_eq_lx' : length lx = length lx'.

Lemma ap'_eq_ap : forall n : nat, ap' n = ap (N + n).

Lemma in_lx'_1 : forall n m : nat, m < n -> In (ap' m) (lx'_1 n).

Lemma in_lx' : forall n : nat, N <= n -> S n <= 2 * N -> In (N_of_nat n) lx'.

Lemma in_lx'_1_conv :
 forall n m : nat, In (N_of_nat m) (lx'_1 n) -> N <= m /\ m < N + n.

Lemma mu_all_x_free :
 forall (t be : bool_expr) (x : BDDvar),
 be_x_free x (mu_all_eval t be) = true ->
 ~ In x lx' /\ (be_x_free x t = true \/ be_x_free x be = true /\ ~ In x lx).
 
Lemma mu_ex_x_free :
 forall (t be : bool_expr) (x : BDDvar),
 be_x_free x (mu_ex_eval t be) = true ->
 ~ In x lx' /\ (be_x_free x t = true \/ be_x_free x be = true /\ ~ In x lx).

Definition be_le2 (be1 be2 : bool_expr) :=
  forall ve : var_env,
  bool_fun_of_bool_expr be1 ve = true -> bool_fun_of_bool_expr be2 ve = true.

Lemma subst_le2 :
 forall (x : BDDvar) (bex be1 be2 : bool_expr),
 be_le2 be1 be2 -> be_le2 (subst x bex be1) (subst x bex be2).

Lemma replace_le2 :
 forall (x y : BDDvar) (be1 be2 : bool_expr),
 be_le2 be1 be2 -> be_le2 (replace x y be1) (replace x y be2).

Lemma replacel_le2 :
 forall (lz ly : list ad) (be1 be2 : bool_expr),
 be_le2 be1 be2 -> be_le2 (replacel be1 lz ly) (replacel be2 lz ly).

Lemma impl_le2 :
 forall be be1 be2 : bool_expr,
 be_le2 be1 be2 -> be_le2 (Impl be be1) (Impl be be2).

Lemma and_le2 :
 forall be1 be2 be1' be2' : bool_expr,
 be_le2 be1 be2 -> be_le2 be1' be2' -> be_le2 (ANd be1 be1') (ANd be2 be2').

Lemma or_le2 :
 forall be1 be2 be1' be2' : bool_expr,
 be_le2 be1 be2 -> be_le2 be1' be2' -> be_le2 (Or be1 be1') (Or be2 be2').

Lemma univ_le2 :
 forall (x : BDDvar) (be1 be2 : bool_expr),
 be_le2 be1 be2 -> be_le2 (forall_ x be1) (forall_ x be2).

Lemma ex_le2 :
 forall (x : BDDvar) (be1 be2 : bool_expr),
 be_le2 be1 be2 -> be_le2 (be_ex x be1) (be_ex x be2).

Lemma univl_le2 :
 forall (lz : list ad) (be1 be2 : bool_expr),
 be_le2 be1 be2 -> be_le2 (univl be1 lz) (univl be2 lz).
 
Lemma exl_le2 :
 forall (lz : list ad) (be1 be2 : bool_expr),
 be_le2 be1 be2 -> be_le2 (exl be1 lz) (exl be2 lz).

Lemma mu_all_le2 :
 forall t be1 be2 : bool_expr,
 be_le2 be1 be2 -> be_le2 (mu_all_eval t be1) (mu_all_eval t be2).
 
Lemma mu_ex_le2 :
 forall t be1 be2 : bool_expr,
 be_le2 be1 be2 -> be_le2 (mu_ex_eval t be1) (mu_ex_eval t be2).

Lemma be_le_le2 : forall be1 be2 : bool_expr, be_le be1 be2 -> be_le2 be1 be2.

Lemma be_le2_le : forall be1 be2 : bool_expr, be_le2 be1 be2 -> be_le be1 be2.

Lemma mu_all_le :
 forall t be1 be2 : bool_expr,
 be_le be1 be2 -> be_le (mu_all_eval t be1) (mu_all_eval t be2).

Lemma mu_ex_le :
 forall t be1 be2 : bool_expr,
 be_le be1 be2 -> be_le (mu_ex_eval t be1) (mu_ex_eval t be2).

Lemma BDDmu_all_lemma :
 forall gc : BDDconfig -> list ad -> BDDconfig,
 gc_OK gc ->
 forall (cfg : BDDconfig) (ul : list ad) (nodet nodeg : ad),
 BDDconfig_OK cfg ->
 used_list_OK cfg ul ->
 used_node' cfg ul nodet ->
 used_node' cfg ul nodeg ->
 BDDconfig_OK (fst (BDDmu_all gc cfg ul nodet nodeg)) /\
 config_node_OK (fst (BDDmu_all gc cfg ul nodet nodeg))
   (snd (BDDmu_all gc cfg ul nodet nodeg)) /\
 used_nodes_preserved cfg (fst (BDDmu_all gc cfg ul nodet nodeg)) ul /\
 bool_fun_eq
   (bool_fun_of_BDD (fst (BDDmu_all gc cfg ul nodet nodeg))
      (snd (BDDmu_all gc cfg ul nodet nodeg)))
   (bool_fun_mu_all (bool_fun_of_BDD cfg nodet) (bool_fun_of_BDD cfg nodeg)).

Section BDDmu_all_results.

Variable gc : BDDconfig -> list ad -> BDDconfig.
Hypothesis gc_is_OK : gc_OK gc.

Variable cfg : BDDconfig.
Variable ul : list ad.
Variable nodet nodeg : ad.

Hypothesis cfg_OK : BDDconfig_OK cfg.
Hypothesis ul_OK : used_list_OK cfg ul.
Hypothesis usedt : used_node' cfg ul nodet.
Hypothesis usedg : used_node' cfg ul nodeg.

Lemma BDDmu_all_config_OK :
 BDDconfig_OK (fst (BDDmu_all gc cfg ul nodet nodeg)).

Lemma BDDmu_all_node_OK :
 config_node_OK (fst (BDDmu_all gc cfg ul nodet nodeg))
   (snd (BDDmu_all gc cfg ul nodet nodeg)).

Lemma BDDmu_all_used_nodes_preserved :
 used_nodes_preserved cfg (fst (BDDmu_all gc cfg ul nodet nodeg)) ul.

Lemma BDDmu_all_list_OK :
 used_list_OK (fst (BDDmu_all gc cfg ul nodet nodeg)) ul.
Lemma BDDmu_all_list_OK_cons :
 used_list_OK (fst (BDDmu_all gc cfg ul nodet nodeg))
   (snd (BDDmu_all gc cfg ul nodet nodeg) :: ul).

Lemma BDDmu_all_is_mu_all :
 bool_fun_eq
   (bool_fun_of_BDD (fst (BDDmu_all gc cfg ul nodet nodeg))
      (snd (BDDmu_all gc cfg ul nodet nodeg)))
   (bool_fun_mu_all (bool_fun_of_BDD cfg nodet) (bool_fun_of_BDD cfg nodeg)).

End BDDmu_all_results.

Lemma BDDmu_ex_lemma :
 forall gc : BDDconfig -> list ad -> BDDconfig,
 gc_OK gc ->
 forall (cfg : BDDconfig) (ul : list ad) (nodet nodeg : ad),
 BDDconfig_OK cfg ->
 used_list_OK cfg ul ->
 used_node' cfg ul nodet ->
 used_node' cfg ul nodeg ->
 BDDconfig_OK (fst (BDDmu_ex gc cfg ul nodet nodeg)) /\
 config_node_OK (fst (BDDmu_ex gc cfg ul nodet nodeg))
   (snd (BDDmu_ex gc cfg ul nodet nodeg)) /\
 used_nodes_preserved cfg (fst (BDDmu_ex gc cfg ul nodet nodeg)) ul /\
 bool_fun_eq
   (bool_fun_of_BDD (fst (BDDmu_ex gc cfg ul nodet nodeg))
      (snd (BDDmu_ex gc cfg ul nodet nodeg)))
   (bool_fun_mu_ex (bool_fun_of_BDD cfg nodet) (bool_fun_of_BDD cfg nodeg)).

Section BDDmu_ex_results.

Variable gc : BDDconfig -> list ad -> BDDconfig.
Hypothesis gc_is_OK : gc_OK gc.

Variable cfg : BDDconfig.
Variable ul : list ad.
Variable nodet nodeg : ad.

Hypothesis cfg_OK : BDDconfig_OK cfg.
Hypothesis ul_OK : used_list_OK cfg ul.
Hypothesis usedt : used_node' cfg ul nodet.
Hypothesis usedg : used_node' cfg ul nodeg.

Lemma BDDmu_ex_config_OK :
 BDDconfig_OK (fst (BDDmu_ex gc cfg ul nodet nodeg)).

Lemma BDDmu_ex_node_OK :
 config_node_OK (fst (BDDmu_ex gc cfg ul nodet nodeg))
   (snd (BDDmu_ex gc cfg ul nodet nodeg)).

Lemma BDDmu_ex_used_nodes_preserved :
 used_nodes_preserved cfg (fst (BDDmu_ex gc cfg ul nodet nodeg)) ul.

Lemma BDDmu_ex_list_OK :
 used_list_OK (fst (BDDmu_ex gc cfg ul nodet nodeg)) ul.
Lemma BDDmu_ex_list_OK_cons :
 used_list_OK (fst (BDDmu_ex gc cfg ul nodet nodeg))
   (snd (BDDmu_ex gc cfg ul nodet nodeg) :: ul).

Lemma BDDmu_ex_is_mu_ex :
 bool_fun_eq
   (bool_fun_of_BDD (fst (BDDmu_ex gc cfg ul nodet nodeg))
      (snd (BDDmu_ex gc cfg ul nodet nodeg)))
   (bool_fun_mu_ex (bool_fun_of_BDD cfg nodet) (bool_fun_of_BDD cfg nodeg)).

End BDDmu_ex_results.
End Nsec.

Section Be_ok.

Variable vf : ad -> bool.

Inductive be_ok : bool_expr -> Prop :=
  | zero_ok : be_ok Zero
  | one_ok : be_ok One
  | var_ok : forall x : BDDvar, vf x = true -> be_ok (Var x)
  | neg_ok : forall be : bool_expr, be_ok be -> be_ok (Neg be)
  | or_ok :
      forall be1 be2 : bool_expr,
      be_ok be1 -> be_ok be2 -> be_ok (Or be1 be2)
  | and_ok :
      forall be1 be2 : bool_expr,
      be_ok be1 -> be_ok be2 -> be_ok (ANd be1 be2)
  | impl_ok :
      forall be1 be2 : bool_expr,
      be_ok be1 -> be_ok be2 -> be_ok (Impl be1 be2)
  | iff_ok :
      forall be1 be2 : bool_expr,
      be_ok be1 -> be_ok be2 -> be_ok (Iff be1 be2).

Lemma var_ok_inv : forall x : BDDvar, be_ok (Var x) -> vf x = true.

Lemma neg_ok_inv : forall be : bool_expr, be_ok (Neg be) -> be_ok be.

Lemma or_ok_inv :
 forall be1 be2 : bool_expr, be_ok (Or be1 be2) -> be_ok be1 /\ be_ok be2.

Lemma and_ok_inv :
 forall be1 be2 : bool_expr, be_ok (ANd be1 be2) -> be_ok be1 /\ be_ok be2.
Lemma impl_ok_inv :
 forall be1 be2 : bool_expr, be_ok (Impl be1 be2) -> be_ok be1 /\ be_ok be2.

Lemma iff_ok_inv :
 forall be1 be2 : bool_expr, be_ok (Iff be1 be2) -> be_ok be1 /\ be_ok be2.

Lemma be_x_free_be_ok :
 forall be : bool_expr,
 (forall x : BDDvar, be_x_free x be = true -> vf x = true) -> be_ok be.

Lemma be_ok_be_x_free :
 forall be : bool_expr,
 be_ok be -> forall x : BDDvar, be_x_free x be = true -> vf x = true.

End Be_ok. *)
Require Import gc.
(* gc:
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import ZArith NArith Nnat Ndec Ndigits.
From IntMap Require Import Map.
From IntMap Require Import Allmaps.
Require Import List.
Require Import Wf_nat.

Require Import misc.
Require Import bool_fun.
Require Import config.
Require Import myMap.

Section BDDgc.

Definition set_closed (bs : BDDstate) (marked : Map unit) :=
  forall node node' : ad,
  in_dom _ node marked = true ->
  nodes_reachable bs node node' ->
  in_dom _ node' bs = true -> in_dom _ node' marked = true.

Fixpoint add_used_nodes_1 (bs : BDDstate) (node : ad) 
 (marked : Map unit) (bound : nat) {struct bound} : 
 Map unit :=
  match bound with
  | O =>   M0 unit
  | S bound' =>
      match MapGet _ marked node with
      | None =>
          match MapGet _ bs node with
          | None => marked
          | Some (x, (l, r)) =>
              MapPut _
                (add_used_nodes_1 bs r (add_used_nodes_1 bs l marked bound')
                   bound') node tt
          end
      | Some tt => marked
      end
  end.

Definition add_used_nodes (bs : BDDstate) (node : ad) 
  (marked : Map unit) :=
  add_used_nodes_1 bs node marked (S (nat_of_N (bs_node_height bs node))).

Definition mark (bs : BDDstate) (used : list ad) :=
  fold_right (add_used_nodes bs) (M0 unit) used.

Definition new_bs (bs : BDDstate) (used : list ad) :=
  MapDomRestrTo _ _ bs (mark bs used).

Definition new_fl (bs : BDDstate) (used : list ad) 
  (fl : BDDfree_list) :=
  MapDomRestrByApp1 _ _ (fun a0 : ad => a0) fl bs (mark bs used).

Definition used_node_bs_1 (marked : Map unit) (node : ad) :=
  match MapGet _ marked node with
  | Some _ => true
  | None => Neqb node BDDzero || Neqb node BDDone
  end.

Fixpoint clean'1_1 (pf : ad -> ad) (m' : Map unit) 
 (m : Map ad) {struct m} : Map ad :=
  match m with
  | M0 => m
  | M1 a a' =>
      if used_node_bs_1 m' (pf a) && used_node_bs_1 m' a' then m else M0 _
  | M2 m1 m2 =>
      makeM2 _ (clean'1_1 (fun a0 : ad => pf (Ndouble a0)) m' m1)
        (clean'1_1 (fun a0 : ad => pf (Ndouble_plus_one a0)) m' m2)
  end.

Definition clean'1 (m : Map ad) (m' : Map unit) :=
  clean'1_1 (fun a : ad => a) m' m.

Fixpoint clean'2_1 (pf : ad -> ad) (m' : Map unit) 
 (m : Map (Map ad)) {struct m} : Map (Map ad) :=
  match m with
  | M0 => m
  | M1 a y =>
      if used_node_bs_1 m' (pf a) then M1 _ a (clean'1 y m') else M0 _
  | M2 m1 m2 =>
      makeM2 _ (clean'2_1 (fun a0 : ad => pf (Ndouble a0)) m' m1)
        (clean'2_1 (fun a0 : ad => pf (Ndouble_plus_one a0)) m' m2)
  end.

Definition clean'2 (m : Map (Map ad)) (m' : Map unit) :=
  clean'2_1 (fun a : ad => a) m' m.

Fixpoint clean1 (m' : Map unit) (m : Map ad) {struct m} : 
 Map ad :=
  match m with
  | M0 => m
  | M1 a a' => if used_node_bs_1 m' a' then m else M0 _
  | M2 m1 m2 => makeM2 _ (clean1 m' m1) (clean1 m' m2)
  end.

Fixpoint clean2_1 (pf : ad -> ad) (m' : Map unit) (m : Map (Map ad))
 {struct m} : Map (Map ad) :=
  match m with
  | M0 => m
  | M1 a y => if used_node_bs_1 m' (pf a) then M1 _ a (clean1 m' y) else M0 _
  | M2 m1 m2 =>
      makeM2 _ (clean2_1 (fun a0 : ad => pf (Ndouble a0)) m' m1)
        (clean2_1 (fun a0 : ad => pf (Ndouble_plus_one a0)) m' m2)
  end.

Definition clean2 (m : Map (Map ad)) (m' : Map unit) :=
  clean2_1 (fun a : ad => a) m' m.

Fixpoint clean3_1 (pf : ad -> ad) (m' : Map unit) (m : Map (Map (Map ad)))
 {struct m} : Map (Map (Map ad)) :=
  match m with
  | M0 => m
  | M1 a y => if used_node_bs_1 m' (pf a) then M1 _ a (clean2 y m') else M0 _
  | M2 m1 m2 =>
      makeM2 _ (clean3_1 (fun a0 : ad => pf (Ndouble a0)) m' m1)
        (clean3_1 (fun a0 : ad => pf (Ndouble_plus_one a0)) m' m2)
  end.

Definition clean3 (m : Map (Map (Map ad))) (m' : Map unit) :=
  clean3_1 (fun a : ad => a) m' m.

Inductive dummy_mark : Set :=
    DM : Map unit -> dummy_mark.

Definition gc_0 (cfg : BDDconfig) (used : list ad) :=
  match cfg with
  | (bs, (share, (fl, (cnt, (negm, (orm, um)))))) =>
      match DM (mark bs used) with
      | DM marked =>
          let bs' := MapDomRestrTo _ _ bs marked in
          let fl' :=
            MapDomRestrByApp1 _ _ (fun a0 : ad => a0) fl bs marked in
          let share' := clean3 share marked in
          let negm' := clean'1 negm marked in
          let orm' := clean'2 orm marked in
          let um' := clean2 um marked in
          (bs', (share', (fl', (cnt, (negm', (orm', um'))))))
      end
  end.

Definition gc_inf (cfg : BDDconfig) (used : list ad) := cfg.

Definition is_nil (A : Set) (l : list A) :=
  match l with
  | nil => true
  | _ => false
  end.

Definition gc_x (x : ad) (cfg : BDDconfig) :=
  if is_nil _ (fst (snd (snd cfg))) && Nleb x (fst (snd (snd (snd cfg))))
  then gc_0 cfg
  else gc_inf cfg.

Definition gc_x_opt (x : ad) (cfg : BDDconfig) :=
  match fl_of_cfg cfg with
  | nil =>
      match BDDcompare x (cnt_of_cfg cfg) with
      | Datatypes.Lt => gc_0 cfg
      | _ => gc_inf cfg
      end
  | _ => gc_inf cfg
  end.

Lemma add_used_nodes_1_lemma_1 :
 forall (bound : nat) (bs : BDDstate) (node : ad) (marked : Map unit),
 BDDstate_OK bs ->
 nat_of_N (bs_node_height bs node) < bound ->
 forall node' : ad,
 in_dom _ node' marked = true ->
 in_dom _ node' (add_used_nodes_1 bs node marked bound) = true.

Lemma add_used_nodes_1_lemma_2 :
 forall (bound : nat) (bs : BDDstate) (node : ad) (marked : Map unit),
 BDDstate_OK bs ->
 nat_of_N (bs_node_height bs node) < bound ->
 set_closed bs marked ->
 (forall node' : ad,
  nodes_reachable bs node node' /\ in_dom _ node' bs = true ->
  in_dom _ node' (add_used_nodes_1 bs node marked bound) = true) /\
 (forall node' : ad,
  in_dom _ node' (add_used_nodes_1 bs node marked bound) = true ->
  in_dom _ node' marked = true \/
  in_dom _ node' bs = true /\ nodes_reachable bs node node') /\
 set_closed bs (add_used_nodes_1 bs node marked bound).

Lemma add_used_nodes_lemma_1 :
 forall (bs : BDDstate) (node : ad) (marked : Map unit),
 BDDstate_OK bs ->
 forall node' : ad,
 in_dom _ node' marked = true ->
 in_dom _ node' (add_used_nodes bs node marked) = true.

Lemma add_used_nodes_lemma_2 :
 forall (bs : BDDstate) (node : ad) (marked : Map unit),
 BDDstate_OK bs ->
 set_closed bs marked ->
 (forall node' : ad,
  nodes_reachable bs node node' /\ in_dom _ node' bs = true ->
  in_dom _ node' (add_used_nodes bs node marked) = true) /\
 (forall node' : ad,
  in_dom _ node' (add_used_nodes bs node marked) = true ->
  in_dom _ node' marked = true \/
  in_dom _ node' bs = true /\ nodes_reachable bs node node') /\
 set_closed bs (add_used_nodes bs node marked).

Lemma mark_lemma_1 :
 forall (used : list ad) (bs : BDDstate),
 BDDstate_OK bs ->
 set_closed bs (fold_right (add_used_nodes bs) (M0 unit) used) /\
 (forall node : ad,
  in_dom _ node (fold_right (add_used_nodes bs) (M0 unit) used) = true <->
  (exists node' : ad,
     In node' used /\
     nodes_reachable bs node' node /\ in_dom _ node bs = true)).

Lemma mark_lemma_2 :
 forall (bs : BDDstate) (used : list ad),
 BDDstate_OK bs ->
 forall node : ad,
 in_dom _ node (mark bs used) = true <->
 (exists node' : ad,
    In node' used /\ nodes_reachable bs node' node /\ in_dom _ node bs = true).

Lemma mark_lemma_3 :
 forall (bs : BDDstate) (used : list ad),
 BDDstate_OK bs ->
 forall node : ad,
 in_dom _ node (mark bs used) = true <->
 used_node_bs bs used node /\ in_dom _ node bs = true.

Lemma new_bs_lemma_1 :
 forall (bs : BDDstate) (used : list ad),
 BDDstate_OK bs ->
 forall node : ad,
 used_node_bs bs used node ->
 MapGet _ bs node = MapGet _ (new_bs bs used) node.

Lemma new_bs_lemma_2 :
 forall (bs : BDDstate) (used : list ad),
 BDDstate_OK bs ->
 forall node : ad,
 in_dom _ node (new_bs bs used) = true -> used_node_bs bs used node.

Lemma no_new_node_new_bs :
 forall (bs : BDDstate) (used : list ad),
 BDDstate_OK bs -> no_new_node_bs bs (new_bs bs used).

Lemma new_bs_zero :
 forall (bs : BDDstate) (used : list ad),
 BDDstate_OK bs -> in_dom _ BDDzero (new_bs bs used) = false.

Lemma new_bs_one :
 forall (bs : BDDstate) (used : list ad),
 BDDstate_OK bs -> in_dom _ BDDone (new_bs bs used) = false.

Lemma new_bs_BDDhigh :
 forall (bs : BDDstate) (used : list ad) (x : BDDvar) (l r node : ad),
 BDDstate_OK bs ->
 MapGet _ (new_bs bs used) node = Some (x, (l, r)) ->
 in_dom _ r (new_bs bs used) = in_dom _ r bs.

Lemma new_bs_BDDlow :
 forall (bs : BDDstate) (used : list ad) (x : BDDvar) (l r node : ad),
 BDDstate_OK bs ->
 MapGet _ (new_bs bs used) node = Some (x, (l, r)) ->
 in_dom _ l (new_bs bs used) = in_dom _ l bs.

Lemma new_bs_used_nodes_preserved :
 forall (bs : BDDstate) (used : list ad) (node : ad),
 BDDstate_OK bs ->
 used_node_bs bs used node -> node_preserved_bs bs (new_bs bs used) node.

Lemma new_bsBDDbounded_1 :
 forall (n : nat) (bs : BDDstate) (used : list ad) (node : ad) (x : BDDvar),
 BDDstate_OK bs ->
 n = nat_of_N x ->
 in_dom _ node (new_bs bs used) = true ->
 BDDbounded bs node x -> BDDbounded (new_bs bs used) node x.

Lemma new_bs_OK :
 forall (bs : BDDstate) (used : list ad),
 BDDstate_OK bs -> BDDstate_OK (new_bs bs used).

Lemma new_cnt_OK :
 forall (bs : BDDstate) (used : list ad) (cnt : ad),
 BDDstate_OK bs -> cnt_OK bs cnt -> cnt_OK (new_bs bs used) cnt.

Lemma new_fl_OK :
 forall (bs : BDDstate) (used : list ad) (fl : BDDfree_list) (cnt : ad),
 BDDstate_OK bs ->
 BDDfree_list_OK bs fl cnt ->
 cnt_OK bs cnt -> BDDfree_list_OK (new_bs bs used) (new_fl bs used fl) cnt.

Lemma used_node_bs_1_preserved :
 forall (bs : BDDstate) (used : list ad) (node : ad),
 BDDstate_OK bs ->
 used_node_bs_1 (mark bs used) node = true ->
 node_preserved_bs bs (new_bs bs used) node.

Lemma clean'1_1_lemma :
 forall (m : Map ad) (m' : Map unit) (pf : ad -> ad) (a a' : ad),
 MapGet _ (clean'1_1 pf m' m) a = Some a' <->
 used_node_bs_1 m' (pf a) && used_node_bs_1 m' a' = true /\
 MapGet _ m a = Some a'.

Lemma clean'1_lemma :
 forall (m : Map ad) (m' : Map unit) (a a' : ad),
 MapGet _ (clean'1 m m') a = Some a' <->
 used_node_bs_1 m' a && used_node_bs_1 m' a' = true /\
 MapGet _ m a = Some a'.

Lemma clean'2_1_lemma :
 forall (m : Map (Map ad)) (m' : Map unit) (pf : ad -> ad) (a b c : ad),
 MapGet2 _ (clean'2_1 pf m' m) a b = Some c <->
 used_node_bs_1 m' (pf a) && (used_node_bs_1 m' b && used_node_bs_1 m' c) =
 true /\ MapGet2 _ m a b = Some c.

Lemma clean'2_lemma :
 forall (m : Map (Map ad)) (m' : Map unit) (a b c : ad),
 MapGet2 _ (clean'2 m m') a b = Some c <->
 used_node_bs_1 m' a && (used_node_bs_1 m' b && used_node_bs_1 m' c) = true /\
 MapGet2 _ m a b = Some c.

Lemma clean1_lemma :
 forall (m' : Map unit) (m : Map ad) (a a' : ad),
 MapGet _ (clean1 m' m) a = Some a' <->
 used_node_bs_1 m' a' = true /\ MapGet _ m a = Some a'.

Lemma clean2_1_lemma :
 forall (m' : Map unit) (m : Map (Map ad)) (pf : ad -> ad) (a b c : ad),
 MapGet2 _ (clean2_1 pf m' m) a b = Some c <->
 used_node_bs_1 m' (pf a) && used_node_bs_1 m' c = true /\
 MapGet2 _ m a b = Some c.

Lemma clean2_lemma :
 forall (m : Map (Map ad)) (m' : Map unit) (a b c : ad),
 MapGet2 _ (clean2 m m') a b = Some c <->
 used_node_bs_1 m' a && used_node_bs_1 m' c = true /\
 MapGet2 _ m a b = Some c.

Lemma clean3_1_lemma :
 forall (m' : Map unit) (m : Map (Map (Map ad))) (pf : ad -> ad)
   (a b c d : ad),
 MapGet3 _ (clean3_1 pf m' m) a b c = Some d <->
 used_node_bs_1 m' (pf a) && (used_node_bs_1 m' b && used_node_bs_1 m' d) =
 true /\ MapGet3 _ m a b c = Some d.

Lemma clean3_lemma :
 forall (m : Map (Map (Map ad))) (m' : Map unit) (a b c d : ad),
 MapGet3 _ (clean3 m m') a b c = Some d <->
 used_node_bs_1 m' a && (used_node_bs_1 m' b && used_node_bs_1 m' d) = true /\
 MapGet3 _ m a b c = Some d.

Lemma new_negm_OK :
 forall (bs : BDDstate) (used : list ad) (negm : BDDneg_memo),
 BDDstate_OK bs ->
 BDDneg_memo_OK bs negm ->
 BDDneg_memo_OK (new_bs bs used) (clean'1 negm (mark bs used)).

Lemma new_orm_OK :
 forall (bs : BDDstate) (used : list ad) (orm : BDDor_memo),
 BDDstate_OK bs ->
 BDDor_memo_OK bs orm ->
 BDDor_memo_OK (new_bs bs used) (clean'2 orm (mark bs used)).

Lemma new_univm_OK :
 forall (bs : BDDstate) (used : list ad) (univm : BDDuniv_memo),
 BDDstate_OK bs ->
 BDDuniv_memo_OK bs univm ->
 BDDuniv_memo_OK (new_bs bs used) (clean2 univm (mark bs used)).

Lemma new_share_OK :
 forall (bs : BDDstate) (used : list ad) (share : BDDsharing_map),
 BDDstate_OK bs ->
 BDDsharing_OK bs share ->
 BDDsharing_OK (new_bs bs used) (clean3 share (mark bs used)).

Lemma new_cfg_OK :
 forall (bs : BDDstate) (share : BDDsharing_map) (fl : BDDfree_list)
   (cnt : ad) (negm : BDDneg_memo) (orm : BDDor_memo) 
   (um : BDDuniv_memo) (used : list ad),
 BDDconfig_OK (bs, (share, (fl, (cnt, (negm, (orm, um)))))) ->
 BDDconfig_OK
   (new_bs bs used,
   (clean3 share (mark bs used),
   (new_fl bs used fl,
   (cnt,
   (clean'1 negm (mark bs used),
   (clean'2 orm (mark bs used), clean2 um (mark bs used))))))).
 
Lemma gc_0_OK : gc_OK gc_0.

Lemma gc_inf_OK : gc_OK gc_inf.

Lemma gc_x_OK : forall x : ad, gc_OK (gc_x x).

Lemma gc_x_opt_OK : forall x : ad, gc_OK (gc_x_opt x).

End BDDgc. *)
Require Import mu.
(* mu:
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import ZArith NArith Nnat Ndec Ndigits.
From IntMap Require Import Map.
From IntMap Require Import Allmaps.
Require Import List.
Require Import myMap.
Require Import Wf_nat.
Require Import EqNat.
Require Import Peano_dec.
Require Import Ensembles.
Require Import Finite_sets.
Require Import Finite_sets_facts.
Require Import Image.

Require Import misc.
Require Import bool_fun.
Require Import config.
Require Import alloc.
Require Import make.
Require Import neg.
Require Import or.
Require Import univ.
Require Import op.
Require Import tauto.
Require Import quant.
Require Import gc.
Require Import Compare.

Fixpoint two_power (m : nat) : nat :=
  match m with
  | O => 1
  | S n => 2 * two_power n
  end.
Lemma zero_lt_pow : forall a : nat, 0 < two_power a.

Definition be_to_be_inc (f : bool_expr -> bool_expr) :=
  forall be1 be2 : bool_expr, be_le be1 be2 -> be_le (f be1) (f be2).

Definition fp (bef : bool_expr -> bool_expr) (be : bool_expr) :=
  be_eq be (bef be).

Definition lfp_be (bef : bool_expr -> bool_expr) (be1 be : bool_expr) :=
  fp bef be /\
  be_le be1 be /\
  (forall be' : bool_expr, fp bef be' -> be_le be1 be' -> be_le be be').

Definition lfp (bef : bool_expr -> bool_expr) (be : bool_expr) :=
  fp bef be /\ (forall be' : bool_expr, fp bef be' -> be_le be be').

Lemma lt_mn_minus : forall n m : nat, m < n -> 0 < n - m.

Lemma le_minus_minus : forall m n : nat, n <= m -> n = m - (m - n).

Lemma minus_n_m_le_n : forall n m : nat, n - m <= n.

Lemma le_minus_le : forall p n m : nat, n <= m -> p - m <= p - n.

Section Nsec.
Variable N : nat.

Definition lxN := lx N.
Definition lx'N := lx' N.

Lemma Splus_nm : forall n m : nat, S (n + m) = S n + m.

Lemma empty_map_card :
 forall (A : Set) (m : Map A),
 (forall x : ad, in_dom _ x m = false) -> MapCard _ m = 0.

Fixpoint Map_eq (m1 m2 : Map unit) {struct m2} : bool :=
  match m1, m2 with
  | M0, M0 => true
  | M1 a1 _, M1 a2 _ => Neqb a1 a2
  | M2 m1 m1', M2 m2 m2' => Map_eq m1 m2 && Map_eq m1' m2'
  | _, _ => false
  end.

Lemma Map_eq_complete :
 forall m1 m2 : Map unit, Map_eq m1 m2 = true -> m1 = m2.

Lemma Map_eq_correct : forall m : Map unit, Map_eq m m = true.

Lemma Map_eq_dec : forall m1 m2 : Map unit, m1 = m2 \/ m1 <> m2.

Section Intervals.

Variable L U : nat.
Definition nat_lu (n : nat) := leb L n && leb (S n) U.
Definition var_lu (x : ad) :=
  leb L (nat_of_N x) && leb (S (nat_of_N x)) U.
Definition var_env_eq (e1 e2 : var_env) :=
  forall x : BDDvar, var_lu x = true -> e1 x = e2 x.

Section Sequence.
  Variable A : Set.
  Variable A_eq : A -> A -> Prop.
  Definition seq := nat -> A.
  Definition seq_eq (s1 s2 : seq) :=
    forall n : nat, nat_lu n = true -> A_eq (s1 n) (s2 n).
  Definition seq_inj (s : seq) :=
    forall i j : nat,
    nat_lu i = true -> nat_lu j = true -> A_eq (s i) (s j) -> i = j.
  Definition seq_surj (s : seq) :=
    forall a : A, exists i : nat, nat_lu i = true /\ A_eq (s i) a.
End Sequence.

Lemma var_lu_nat_lu :
 forall x : ad, var_lu x = true -> nat_lu (nat_of_N x) = true.

Lemma nat_lu_var_lu :
 forall n : nat, nat_lu n = true -> var_lu (N_of_nat n) = true.

Lemma eval_be_independent :
 forall ve1 ve2 : var_env',
 seq_eq _ (eq (A:=_)) ve1 ve2 ->
 forall be : bool_expr, be_ok var_lu be -> eval_be' be ve1 = eval_be' be ve2.

Definition Evar_env' : Ensemble var_env' :=
  fun ve : var_env' => forall n : nat, nat_lu n = false -> ve n = false.
Definition Evar_env'' : Ensemble var_env'' :=
  fun ve : var_env'' =>
  mapcanon _ ve /\ (forall x : ad, var_lu x = false -> in_dom _ x ve = false).

Lemma cardinal_Union :
 forall (U : Type) (X : Ensemble U) (m : nat),
 cardinal U X m ->
 forall (Y : Ensemble U) (n : nat),
 cardinal U Y n -> forall p : nat, cardinal U (Union U X Y) p -> p <= m + n.

End Intervals.

Definition Evar_env'ntoSn (U : nat) (ve : var_env') : var_env' :=
  fun n : nat => if beq_nat n U then true else ve n.
Definition Evar_env''ntoSn (U : nat) (ve : var_env'') : var_env'' :=
  MapPut _ ve (N_of_nat U) tt.

Lemma beq_Eq_true : forall m n : nat, beq_nat m n = true <-> eq_nat m n.

Lemma beq_complete : forall m n : nat, beq_nat m n = true -> m = n.

Lemma beq_correct : forall n : nat, beq_nat n n = true.

Lemma Evar_env'ntoSn_lemma :
 forall (L U : nat) (ve : var_env'),
 L <= U ->
 In _ (Evar_env' L U) ve -> In _ (Evar_env' L (S U)) (Evar_env'ntoSn U ve).

Lemma Evar_env''ntoSn_lemma :
 forall (L U : nat) (ve : var_env''),
 L <= U ->
 In _ (Evar_env'' L U) ve -> In _ (Evar_env'' L (S U)) (Evar_env''ntoSn U ve).

Section Evar_env''LULSU.

Variable L U : nat.
Definition Evar_env'LU : Ensemble var_env' := Evar_env' L U.
Definition Evar_env''LU : Ensemble var_env'' := Evar_env'' L U.
Definition Evar_env'LSU : Ensemble var_env' := Evar_env' L (S U).
Definition Evar_env''LSU : Ensemble var_env'' := Evar_env'' L (S U).
Definition f1 : var_env' -> var_env' := Evar_env'ntoSn U.
Definition f1' : var_env'' -> var_env'' := Evar_env''ntoSn U.
Definition imagef1 : Ensemble var_env' := Im _ _ Evar_env'LU f1.
Definition imagef1' : Ensemble var_env'' := Im _ _ Evar_env''LU f1'.
Definition f2 (x : var_env') : var_env' := x.
Definition f2' (x : var_env'') : var_env'' := x.
Definition imagef2 : Ensemble var_env' := Im _ _ Evar_env'LU f2.
Definition imagef2' : Ensemble var_env'' := Im _ _ Evar_env''LU f2'.
Definition imagef1orf2 : Ensemble var_env' := Union _ imagef1 imagef2.
Definition imagef1'orf2' : Ensemble var_env'' := Union _ imagef1' imagef2'.

Lemma var_env''M0 :
 forall ve : var_env'', U - L = 0 -> In _ Evar_env''LU ve -> ve = M0 _.

Lemma same_set_same_cardinal :
 forall (U : Type) (X Y : Ensemble U) (n m : nat),
 cardinal U X n -> cardinal U Y m -> Same_set U X Y -> n = m.

Lemma same_set_finite :
 forall (U : Type) (X Y : Ensemble U),
 Finite U X -> Same_set U X Y -> Finite U Y.

Lemma singleton_add_empty :
 forall (U : Type) (x : U),
 Same_set _ (Singleton _ x) (Add _ (Empty_set _) x).

Lemma singleton_cardinal_one :
 forall (U : Type) (x : U), cardinal _ (Singleton _ x) 1.

Lemma M0inEvar_env'' : In (Map unit) Evar_env''LU (M0 unit).

Lemma var_env''singleton :
 U - L = 0 -> Same_set _ Evar_env''LU (Singleton _ (M0 _)).

Lemma var_env''cardinal_one : U - L = 0 -> cardinal _ Evar_env''LU 1.

Lemma imagef1lemma' :
 forall ve : var_env'',
 In _ Evar_env''LSU ve ->
 in_dom _ (N_of_nat U) ve = true ->
 exists ve' : var_env'', In _ Evar_env''LU ve' /\ f1' ve' = ve.

Lemma imagef2lemma' :
 forall ve : var_env'',
 In _ Evar_env''LSU ve ->
 in_dom _ (N_of_nat U) ve = false ->
 exists ve' : var_env'', In _ Evar_env''LU ve' /\ f2' ve' = ve.

Lemma imagef1'orf2'lemma :
 forall ve : var_env'', In _ Evar_env''LSU ve -> In _ imagef1'orf2' ve.

Section CardImage.

Variable n : nat.
Hypothesis H : cardinal _ Evar_env''LU n.

Lemma card_imagef1'lemma : forall m : nat, cardinal _ imagef1' m -> m <= n.

Lemma card_imagef2'lemma : forall m : nat, cardinal _ imagef2' m -> m <= n.

Lemma imagef1'finite : Finite _ imagef1'.

Lemma imagef2'finite : Finite _ imagef2'.

Lemma card_imagef1'orf2'lemma :
 forall m : nat, cardinal _ imagef1'orf2' m -> m <= 2 * n.

Lemma imagef1'orf2'finite : Finite _ imagef1'orf2'.

Lemma card_Evar_env''LSU_lemma :
 forall m : nat, cardinal _ Evar_env''LSU m -> m <= 2 * n.

Lemma Evar_env''LSU_finite : Finite _ Evar_env''LSU.

End CardImage.
End Evar_env''LULSU.

Lemma Evar_env''LSULU :
 forall L U : nat, Evar_env''LSU L U = Evar_env''LU L (S U).

Lemma Eenv_var''LU_finite :
 forall n L U : nat, n = U - L -> Finite _ (Evar_env''LU L U).

Lemma Eenv_var''LU_card :
 forall n L U c : nat,
 n = U - L -> cardinal _ (Evar_env''LU L U) c -> c <= two_power n.

Lemma Eenv''_var''finite : forall L U : nat, Finite _ (Evar_env'' L U).

Lemma Eenv''_var''card :
 forall L U n : nat,
 cardinal _ (Evar_env''LU L U) n -> n <= two_power (U - L).

Lemma minusUL0_var_lu :
 forall L U : nat, U - L = 0 -> forall x : ad, var_lu L U x = false.

Definition bool_expr_to_var_env'' (L U : nat) (be : bool_expr) :
  Ensemble var_env'' :=
  fun ve =>
  eval_be' be (var_env''_to_env' ve) = true /\ In _ (Evar_env'' L U) ve.

Definition be_le1 (L U : nat) (be1 be2 : bool_expr) :=
  forall ve : var_env'',
  In _ (bool_expr_to_var_env'' L U be1) ve ->
  In _ (bool_expr_to_var_env'' L U be2) ve.

Lemma var_env'_to_var_env''_lemma1 :
 forall (n L U : nat) (ve : var_env'),
 n = U - L ->
 exists ve'' : var_env'',
   In _ (Evar_env'' L U) ve'' /\
   (forall x : ad, var_lu L U x = true -> in_dom _ x ve'' = ve (nat_of_N x)).

Lemma var_env'_to_var_env''_lemma2 :
 forall (n L U : nat) (ve : var_env'),
 n = U - L ->
 {ve'' : var_env'' |
 In _ (Evar_env'' L U) ve'' /\
 (forall x : ad, var_lu L U x = true -> in_dom _ x ve'' = ve (nat_of_N x))}.

Definition var_env'_to_env'' (L U : nat) (ve : var_env') :=
  match var_env'_to_var_env''_lemma2 (U - L) L U ve (refl_equal _) with
  | exist ve'' _ => ve''
  end.

Lemma var_env'_to_env''_lemma3 :
 forall (L U : nat) (ve : var_env'),
 In _ (Evar_env'' L U) (var_env'_to_env'' L U ve) /\
 (forall x : ad,
  var_lu L U x = true ->
  in_dom _ x (var_env'_to_env'' L U ve) = ve (nat_of_N x)).

Lemma be_le1_le :
 forall (L U : nat) (be1 be2 : bool_expr),
 be_ok (var_lu L U) be1 ->
 be_ok (var_lu L U) be2 -> be_le1 L U be1 be2 -> be_le be1 be2.

Lemma be_le_le1 :
 forall (L U : nat) (be1 be2 : bool_expr),
 be_le be1 be2 -> be_le1 L U be1 be2.

Definition var_env''le (ve1 ve2 : var_env'') :=
  forall x : ad, in_dom _ x ve1 = true -> in_dom _ x ve2 = true.

Lemma var_env''le_refl : forall ve : var_env'', var_env''le ve ve.

Lemma var_env''le_trans :
 forall ve1 ve2 ve3 : var_env'',
 var_env''le ve1 ve2 -> var_env''le ve2 ve3 -> var_env''le ve1 ve3.

Lemma be_le_ens_inc :
 forall (be1 be2 : bool_expr) (L U : nat),
 be_le be1 be2 ->
 Included _ (bool_expr_to_var_env'' L U be1) (bool_expr_to_var_env'' L U be2).

Lemma incl_eq :
 forall (U : Type) (A B : Ensemble U) (n : nat),
 Included _ A B -> cardinal _ A n -> cardinal _ B n -> Included _ B A.

Lemma decreasing_seq :
 forall (n : nat) (f : nat -> nat),
 f 0 = n ->
 (forall n : nat, f (S n) <= f n) -> exists m : nat, m <= n /\ f m = f (S m).

Lemma decreasing_ens_seq :
 forall (U : Type) (n : nat) (f : nat -> Ensemble U),
 cardinal _ (f 0) n ->
 (forall k : nat, Finite _ (f k)) ->
 (forall k : nat, Included _ (f (S k)) (f k)) ->
 exists m : nat,
   (exists c : nat, m <= n /\ cardinal _ (f m) c /\ cardinal _ (f (S m)) c).

Lemma bool_expr_to_var_env''_finite :
 forall (L U : nat) (be : bool_expr),
 be_ok (var_lu L U) be -> Finite _ (bool_expr_to_var_env'' L U be).

Lemma bool_expr_to_var_env''_card :
 forall (L U n : nat) (be : bool_expr),
 be_ok (var_lu L U) be ->
 cardinal _ (bool_expr_to_var_env'' L U be) n -> n <= two_power (U - L).

Lemma decreasing_be_seq :
 forall (n L U : nat) (f : nat -> bool_expr),
 cardinal _ (bool_expr_to_var_env'' L U (f 0)) n ->
 (forall k : nat, be_le (f (S k)) (f k)) ->
 (forall k : nat, be_ok (var_lu L U) (f k)) ->
 exists m : nat, m <= n /\ be_le (f m) (f (S m)).

Lemma decreasing_be_seq_1 :
 forall (L U : nat) (f : nat -> bool_expr),
 (forall k : nat, be_ok (var_lu L U) (f k)) ->
 (forall k : nat, be_le (f (S k)) (f k)) ->
 exists m : nat, m <= two_power (U - L) /\ be_eq (f m) (f (S m)).

Lemma increasing_be_seq_1 :
 forall (L U : nat) (f : nat -> bool_expr),
 (forall k : nat, be_ok (var_lu L U) (f k)) ->
 (forall k : nat, be_le (f k) (f (S k))) ->
 exists m : nat, m <= two_power (U - L) /\ be_eq (f m) (f (S m)).

Lemma increasing_seq :
 forall (n : nat) (f : nat -> nat),
 (forall k : nat, f k <= n) ->
 (forall k : nat, f k <= f (S k)) ->
 exists m : nat, m <= n - f 0 /\ f m = f (S m).

Definition unprimed_var := var_lu 0 N.

Definition rel_env := ad -> bool_expr.
Definition Brel_env := Map ad.
Definition trans_env := ad -> bool_expr.
Definition Btrans_env := Map ad.
Definition re_put (re : rel_env) (x : ad) (be : bool_expr) : rel_env :=
  fun y => if Neqb x y then be else re y.

Inductive mu_form : Set :=
  | mu_0 : mu_form
  | mu_1 : mu_form
  | mu_ap : ad -> mu_form
  | mu_rel_var : ad -> mu_form
  | mu_neg : mu_form -> mu_form
  | mu_and : mu_form -> mu_form -> mu_form
  | mu_or : mu_form -> mu_form -> mu_form
  | mu_impl : mu_form -> mu_form -> mu_form
  | mu_iff : mu_form -> mu_form -> mu_form
  | mu_all : ad -> mu_form -> mu_form
  | mu_ex : ad -> mu_form -> mu_form
  | mu_mu : ad -> mu_form -> mu_form.

Fixpoint mu_rel_free (P : ad) (f : mu_form) {struct f} : bool :=
  match f with
  | mu_0 => false
  | mu_1 => false
  | mu_ap _ => false
  | mu_rel_var Q => Neqb P Q
  | mu_neg g => mu_rel_free P g
  | mu_and g h => mu_rel_free P g || mu_rel_free P h
  | mu_or g h => mu_rel_free P g || mu_rel_free P h
  | mu_impl g h => mu_rel_free P g || mu_rel_free P h
  | mu_iff g h => mu_rel_free P g || mu_rel_free P h
  | mu_all t g => mu_rel_free P g
  | mu_ex t g => mu_rel_free P g
  | mu_mu Q g => negb (Neqb P Q) && mu_rel_free P g
  end.

Fixpoint mu_t_free (t : ad) (f : mu_form) {struct f} : bool :=
  match f with
  | mu_0 => false
  | mu_1 => false
  | mu_ap _ => false
  | mu_rel_var P => false
  | mu_neg g => mu_t_free t g
  | mu_and g h => mu_t_free t g || mu_t_free t h
  | mu_or g h => mu_t_free t g || mu_t_free t h
  | mu_impl g h => mu_t_free t g || mu_t_free t h
  | mu_iff g h => mu_t_free t g || mu_t_free t h
  | mu_all u g => Neqb t u || mu_t_free t g
  | mu_ex u g => Neqb t u || mu_t_free t g
  | mu_mu Q g => mu_t_free t g
  end.

Fixpoint iter (A : Type) (A_eq : A -> A -> bool) (f : A -> A) 
 (a : A) (n : nat) {struct n} : A :=
  match n with
  | O => a
  | S m => if A_eq a (f a) then f a else iter _ A_eq f (f a) m
  end.

Definition be_iter (f : bool_expr -> bool_expr) (be : bool_expr) 
  (n : nat) := iter _ be_eq_dec f be n.

Fixpoint iter2n (A : Set) (A_eq : A -> A -> bool) (f : A -> A) 
 (a : A) (n : nat) {struct n} : A * bool :=
  match n with
  | O => (f a, A_eq a (f a))
  | S m =>
      match iter2n _ A_eq f a m with
      | (b, true) => (b, true)
      | (b, false) => iter2n _ A_eq f b m
      end
  end.

Definition be_iter2n := iter2n _ be_eq_dec.

Lemma be_iter_prop_preserved :
 forall (n : nat) (be : bool_expr) (f : bool_expr -> bool_expr)
   (pr : bool_expr -> Prop),
 pr be ->
 (forall be' : bool_expr, pr be' -> pr (f be')) -> pr (be_iter f be n).

Lemma be_iter2n_prop_preserved :
 forall (n : nat) (be : bool_expr) (f : bool_expr -> bool_expr)
   (pr : bool_expr -> Prop),
 pr be ->
 (forall be' : bool_expr, pr be' -> pr (f be')) ->
 pr (fst (be_iter2n f be n)).

Lemma be_iter_eq_preserved :
 forall (n : nat) (be : bool_expr) (f1 f2 : bool_expr -> bool_expr),
 (forall be' : bool_expr, f1 be' = f2 be') ->
 be_iter f1 be n = be_iter f2 be n.

Lemma be_iter2n_eq_preserved :
 forall (n : nat) (be : bool_expr) (f1 f2 : bool_expr -> bool_expr),
 (forall be' : bool_expr, f1 be' = f2 be') ->
 be_iter2n f1 be n = be_iter2n f2 be n.

Lemma be_iter_eq_1 :
 forall (n : nat) (be : bool_expr) (f : bool_expr -> bool_expr),
 be_eq (f be) be -> be_eq (be_iter f be n) be.

Lemma be_iter_eq_preserved_1 :
 forall (n : nat) (be1 be2 : bool_expr) (f1 f2 : bool_expr -> bool_expr),
 be_eq be1 be2 ->
 (forall be1' be2' : bool_expr, be_eq be1' be2' -> be_eq (f1 be1') (f1 be2')) ->
 (forall be1' be2' : bool_expr, be_eq be1' be2' -> be_eq (f2 be1') (f2 be2')) ->
 (forall be1' be2' : bool_expr, be_eq be1' be2' -> be_eq (f1 be1') (f2 be2')) ->
 be_eq (be_iter f1 be1 n) (be_iter f2 be2 n).

Lemma be_iter2n_eq_preserved_1 :
 forall (n : nat) (be1 be2 : bool_expr) (f1 f2 : bool_expr -> bool_expr),
 be_eq be1 be2 ->
 (forall be1' be2' : bool_expr, be_eq be1' be2' -> be_eq (f1 be1') (f1 be2')) ->
 (forall be1' be2' : bool_expr, be_eq be1' be2' -> be_eq (f2 be1') (f2 be2')) ->
 (forall be1' be2' : bool_expr, be_eq be1' be2' -> be_eq (f1 be1') (f2 be2')) ->
 be_eq (fst (be_iter2n f1 be1 n)) (fst (be_iter2n f2 be2 n)) /\
 snd (be_iter2n f1 be1 n) = snd (be_iter2n f2 be2 n).

Lemma be_iter2n_eq_preserved_2 :
 forall (n : nat) (be1 be2 : bool_expr) (f1 f2 : bool_expr -> bool_expr),
 be_eq be1 be2 ->
 (forall be1' be2' : bool_expr, be_eq be1' be2' -> be_eq (f1 be1') (f1 be2')) ->
 (forall be1' be2' : bool_expr, be_eq be1' be2' -> be_eq (f2 be1') (f2 be2')) ->
 (forall be1' be2' : bool_expr, be_eq be1' be2' -> be_eq (f1 be1') (f2 be2')) ->
 be_eq (fst (be_iter2n f1 be1 n)) (fst (be_iter2n f2 be2 n)).

Lemma be_iter_le_preserved :
 forall (n : nat) (be1 be2 : bool_expr) (f1 f2 : bool_expr -> bool_expr),
 be_le be1 be2 ->
 (forall be1' be2' : bool_expr, be_eq be1' be2' -> be_eq (f1 be1') (f1 be2')) ->
 (forall be1' be2' : bool_expr, be_eq be1' be2' -> be_eq (f2 be1') (f2 be2')) ->
 (forall be1' be2' : bool_expr, be_le be1' be2' -> be_le (f1 be1') (f2 be2')) ->
 be_le (be_iter f1 be1 n) (be_iter f2 be2 n).

Lemma be_iter2n_true :
 forall (n : nat) (be : bool_expr) (f : bool_expr -> bool_expr),
 (forall be1 be2 : bool_expr, be_eq be1 be2 -> be_eq (f be1) (f be2)) ->
 snd (be_iter2n f be n) = true -> fp f (fst (be_iter2n f be n)).

Lemma be_iter2n_0 :
 forall (n : nat) (be : bool_expr) (f : bool_expr -> bool_expr),
 (forall be1 be2 : bool_expr, be_eq be1 be2 -> be_eq (f be1) (f be2)) ->
 fp f be -> be_eq be (fst (be_iter2n f be n)).

  Section Be_iter1.

  Variable bef : bool_expr -> bool_expr.
  Hypothesis bef_inc : be_to_be_inc bef.
  Hypothesis
    bef_ok :
      forall be : bool_expr,
      be_ok (var_lu 0 N) be -> be_ok (var_lu 0 N) (bef be).

  Fixpoint be_iter1 (be : bool_expr) (n : nat) {struct n} : bool_expr :=
    match n with
    | O => be
    | S m => be_iter1 (bef be) m
    end.

  Fixpoint be_iter2 (be : bool_expr) (n : nat) {struct n} : bool_expr :=
    match n with
    | O => be
    | S m => bef (be_iter2 be m)
    end.

  Lemma be_iter1_plus :
   forall (m n : nat) (be : bool_expr),
   be_iter1 (be_iter1 be m) n = be_iter1 be (m + n).

  Lemma be_iter1eq2 :
   forall (n : nat) (be : bool_expr), be_iter1 be n = be_iter2 be n.

  Lemma be_iter1_inc :
   forall (k : nat) (be : bool_expr),
   be_le be (bef be) -> be_le (be_iter1 be k) (be_iter1 be (S k)).

  Lemma be_iter1_ok :
   forall (k : nat) (be : bool_expr),
   be_ok (var_lu 0 N) be -> be_ok (var_lu 0 N) (be_iter1 be k).

  Lemma be_iter1_fix_ex :
   forall be : bool_expr,
   be_ok (var_lu 0 N) be ->
   be_le be (bef be) ->
   exists m : nat,
     m <= two_power N /\ be_eq (be_iter1 be m) (be_iter1 be (S m)).
  
End Be_iter1.

Lemma be_iter1_preserves_eq :
 forall (n : nat) (be1 be2 : bool_expr) (f : bool_expr -> bool_expr),
 (forall be1 be2 : bool_expr, be_eq be1 be2 -> be_eq (f be1) (f be2)) ->
 be_eq be1 be2 -> be_eq (be_iter1 f be1 n) (be_iter1 f be2 n).

Lemma be_iter1_plus1 :
 forall (m n : nat) (be : bool_expr) (f : bool_expr -> bool_expr),
 be_eq (be_iter1 f (be_iter1 f be m) n) (be_iter1 f be (m + n)).

Lemma be_iter2n_false :
 forall (n : nat) (be : bool_expr) (f : bool_expr -> bool_expr),
 (forall be1 be2 : bool_expr, be_eq be1 be2 -> be_eq (f be1) (f be2)) ->
 snd (be_iter2n f be n) = false ->
 be_eq (fst (be_iter2n f be n)) (be_iter1 f be (two_power n)).

Lemma be_iter2n_2n :
 forall (n : nat) (be : bool_expr) (f : bool_expr -> bool_expr),
 (forall be1 be2 : bool_expr, be_eq be1 be2 -> be_eq (f be1) (f be2)) ->
 be_eq (fst (be_iter2n f be n)) (be_iter1 f be (two_power n)).

Lemma be_iter1_le_preserved :
 forall (n : nat) (be1 be2 : bool_expr) (f1 f2 : bool_expr -> bool_expr),
 be_le be1 be2 ->
 (forall be1' be2' : bool_expr, be_le be1' be2' -> be_le (f1 be1') (f2 be2')) ->
 be_le (be_iter1 f1 be1 n) (be_iter1 f2 be2 n).

Lemma be_iter2n_le_preserved :
 forall (n : nat) (be1 be2 : bool_expr) (f1 f2 : bool_expr -> bool_expr),
 be_le be1 be2 ->
 (forall be1' be2' : bool_expr, be_eq be1' be2' -> be_eq (f1 be1') (f1 be2')) ->
 (forall be1' be2' : bool_expr, be_eq be1' be2' -> be_eq (f2 be1') (f2 be2')) ->
 (forall be1' be2' : bool_expr, be_le be1' be2' -> be_le (f1 be1') (f2 be2')) ->
 be_le (fst (be_iter2n f1 be1 n)) (fst (be_iter2n f2 be2 n)).

Fixpoint BDDiter (f : BDDconfig -> ad -> BDDconfig * ad) 
 (cfg : BDDconfig) (node : ad) (n : nat) {struct n} : 
 BDDconfig * ad :=
  match n with
  | O => (cfg, node)
  | S m =>
      match f cfg node with
      | (cfg1, node1) =>
          if Neqb node node1 then (cfg1, node1) else BDDiter f cfg1 node1 m
      end
  end.

Fixpoint BDDiter2n (f : BDDconfig -> ad -> BDDconfig * ad) 
 (cfg : BDDconfig) (node : ad) (n : nat) {struct n} :
 BDDconfig * ad * bool :=
  match n with
  | O =>
      match f cfg node with
      | (cfg1, node1) => (cfg1, node1, Neqb node node1)
      end
  | S m =>
      match BDDiter2n f cfg node m with
      | ((cfg1, node1), true) => (cfg1, node1, true)
      | ((cfg1, node1), false) => BDDiter2n f cfg1 node1 m
      end
  end.

Definition cfgnode_eq (cfgnode1 cfgnode2 : BDDconfig * ad) :=
  Neqb (snd cfgnode1) (snd cfgnode2).

Lemma BDDiter_as_iter :
 forall (n : nat) (cfg : BDDconfig) (node : ad)
   (f : BDDconfig -> ad -> BDDconfig * ad),
 BDDiter f cfg node n =
 iter _ cfgnode_eq (fun x => f (fst x) (snd x)) (cfg, node) n.

Inductive mu_form_ap_ok (vf : ad -> bool) : mu_form -> Prop :=
  | mu_0_ok : mu_form_ap_ok vf mu_0
  | mu_1_ok : mu_form_ap_ok vf mu_1
  | mu_ap_ok : forall p : ad, vf p = true -> mu_form_ap_ok vf (mu_ap p)
  | mu_rel_var_ok : forall P : ad, mu_form_ap_ok vf (mu_rel_var P)
  | mu_neg_ok :
      forall f : mu_form, mu_form_ap_ok vf f -> mu_form_ap_ok vf (mu_neg f)
  | mu_and_ok :
      forall f g : mu_form,
      mu_form_ap_ok vf f ->
      mu_form_ap_ok vf g -> mu_form_ap_ok vf (mu_and f g)
  | mu_or_ok :
      forall f g : mu_form,
      mu_form_ap_ok vf f ->
      mu_form_ap_ok vf g -> mu_form_ap_ok vf (mu_or f g)
  | mu_impl_ok :
      forall f g : mu_form,
      mu_form_ap_ok vf f ->
      mu_form_ap_ok vf g -> mu_form_ap_ok vf (mu_impl f g)
  | mu_iff_ok :
      forall f g : mu_form,
      mu_form_ap_ok vf f ->
      mu_form_ap_ok vf g -> mu_form_ap_ok vf (mu_iff f g)
  | mu_all_ok :
      forall (t : ad) (f : mu_form),
      mu_form_ap_ok vf f -> mu_form_ap_ok vf (mu_all t f)
  | mu_ex_ok :
      forall (t : ad) (f : mu_form),
      mu_form_ap_ok vf f -> mu_form_ap_ok vf (mu_ex t f)
  | mu_mu_ok :
      forall (P : ad) (f : mu_form),
      mu_form_ap_ok vf f -> mu_form_ap_ok vf (mu_mu P f).

Lemma mu_ap_ok_inv :
 forall (vf : ad -> bool) (p : ad), mu_form_ap_ok vf (mu_ap p) -> vf p = true.

Inductive f_P_even (P : ad) : mu_form -> bool -> Prop :=
  | mu_0_even : f_P_even P mu_0 true
  | mu_0_odd : f_P_even P mu_0 false
  | mu_1_even : f_P_even P mu_1 true
  | mu_1_odd : f_P_even P mu_1 false
  | mu_ap_even : forall p : ad, f_P_even P (mu_ap p) true
  | mu_ap_odd : forall p : ad, f_P_even P (mu_ap p) false
  | mu_rel_var_even :
      forall Q : ad,
      f_P_even P (mu_rel_var Q) true
      
  | mu_rel_var_odd :
      forall Q : ad, Neqb P Q = false -> f_P_even P (mu_rel_var Q) false
  | mu_neg_odd :
      forall f : mu_form, f_P_even P f true -> f_P_even P (mu_neg f) false
  | mu_neg_even :
      forall f : mu_form, f_P_even P f false -> f_P_even P (mu_neg f) true
  | mu_and_even :
      forall f g : mu_form,
      f_P_even P f true -> f_P_even P g true -> f_P_even P (mu_and f g) true
  | mu_and_odd :
      forall f g : mu_form,
      f_P_even P f false ->
      f_P_even P g false -> f_P_even P (mu_and f g) false
  | mu_or_even :
      forall f g : mu_form,
      f_P_even P f true -> f_P_even P g true -> f_P_even P (mu_or f g) true
  | mu_or_odd :
      forall f g : mu_form,
      f_P_even P f false ->
      f_P_even P g false -> f_P_even P (mu_or f g) false
  | mu_impl_even :
      forall f g : mu_form,
      f_P_even P f false ->
      f_P_even P g true -> f_P_even P (mu_impl f g) true
  | mu_impl_odd :
      forall f g : mu_form,
      f_P_even P f true ->
      f_P_even P g false -> f_P_even P (mu_impl f g) false
  | mu_iff_even :
      forall f g : mu_form,
      f_P_even P f true ->
      f_P_even P g true ->
      f_P_even P f false ->
      f_P_even P g false -> f_P_even P (mu_iff f g) true
  | mu_iff_odd :
      forall f g : mu_form,
      f_P_even P f true ->
      f_P_even P g true ->
      f_P_even P f false ->
      f_P_even P g false -> f_P_even P (mu_iff f g) false
  | mu_all_even :
      forall (t : ad) (f : mu_form),
      f_P_even P f true -> f_P_even P (mu_all t f) true
  | mu_all_odd :
      forall (t : ad) (f : mu_form),
      f_P_even P f false -> f_P_even P (mu_all t f) false
  | mu_ex_even :
      forall (t : ad) (f : mu_form),
      f_P_even P f true -> f_P_even P (mu_ex t f) true
  | mu_ex_odd :
      forall (t : ad) (f : mu_form),
      f_P_even P f false -> f_P_even P (mu_ex t f) false
  | mu_mu_P_even : forall f : mu_form, f_P_even P (mu_mu P f) true
  | mu_mu_P_odd : forall f : mu_form, f_P_even P (mu_mu P f) false
  | mu_mu_Q_even :
      forall (Q : ad) (f : mu_form),
      Neqb P Q = false -> f_P_even P f true -> f_P_even P (mu_mu Q f) true
  | mu_mu_Q_odd :
      forall (Q : ad) (f : mu_form),
      Neqb P Q = false -> f_P_even P f false -> f_P_even P (mu_mu Q f) false.

Inductive f_ok : mu_form -> Prop :=
  | mu_0_f_ok : f_ok mu_0
  | mu_1_f_ok : f_ok mu_1
  | mu_ap_f_ok : forall p : ad, f_ok (mu_ap p)
  | mu_rel_var_f_ok : forall P : ad, f_ok (mu_rel_var P)
  | mu_neg_f_ok : forall f : mu_form, f_ok f -> f_ok (mu_neg f)
  | mu_and_f_ok : forall f g : mu_form, f_ok f -> f_ok g -> f_ok (mu_and f g)
  | mu_or_f_ok : forall f g : mu_form, f_ok f -> f_ok g -> f_ok (mu_or f g)
  | mu_impl_f_ok :
      forall f g : mu_form, f_ok f -> f_ok g -> f_ok (mu_impl f g)
  | mu_iff_f_ok : forall f g : mu_form, f_ok f -> f_ok g -> f_ok (mu_iff f g)
  | mu_all_f_ok : forall (t : ad) (f : mu_form), f_ok f -> f_ok (mu_all t f)
  | mu_ex_f_ok : forall (t : ad) (f : mu_form), f_ok f -> f_ok (mu_ex t f)
  | mu_mu_f_ok :
      forall (P : ad) (f : mu_form),
      f_ok f -> f_P_even P f true -> f_ok (mu_mu P f).

Definition cfg_ul_bre_ok (cfg : BDDconfig) (ul : list ad) 
  (bre : Brel_env) :=
  forall P node : ad, MapGet _ bre P = Some node -> used_node' cfg ul node.

Definition cfg_ul_bte_ok (cfg : BDDconfig) (ul : list ad)
  (bte : Btrans_env) :=
  forall t node : ad, MapGet _ bte t = Some node -> used_node' cfg ul node.

Definition cfg_re_bre_ok (cfg : BDDconfig) (re : rel_env) 
  (bre : Brel_env) :=
  forall P node : ad,
  MapGet _ bre P = Some node ->
  bool_fun_eq (bool_fun_of_BDD cfg node) (bool_fun_of_bool_expr (re P)).

Definition cfg_te_bte_ok (cfg : BDDconfig) (te : trans_env)
  (bte : Btrans_env) :=
  forall t node : ad,
  MapGet _ bte t = Some node ->
  bool_fun_eq (bool_fun_of_BDD cfg node) (bool_fun_of_bool_expr (te t)).

Definition f_bre_ok (f : mu_form) (bre : Brel_env) :=
  forall P : ad, mu_rel_free P f = true -> in_dom _ P bre = true.

Definition f_bte_ok (f : mu_form) (bte : Btrans_env) :=
  forall t : ad, mu_t_free t f = true -> in_dom _ t bte = true.

Lemma mu_and_bre_ok :
 forall (g h : mu_form) (bre : Brel_env),
 f_bre_ok (mu_and g h) bre -> f_bre_ok g bre /\ f_bre_ok h bre.

Lemma mu_or_bre_ok :
 forall (g h : mu_form) (bre : Brel_env),
 f_bre_ok (mu_or g h) bre -> f_bre_ok g bre /\ f_bre_ok h bre.

Lemma mu_impl_bre_ok :
 forall (g h : mu_form) (bre : Brel_env),
 f_bre_ok (mu_impl g h) bre -> f_bre_ok g bre /\ f_bre_ok h bre.

Lemma mu_iff_bre_ok :
 forall (g h : mu_form) (bre : Brel_env),
 f_bre_ok (mu_iff g h) bre -> f_bre_ok g bre /\ f_bre_ok h bre.

Lemma mu_and_bte_ok :
 forall (g h : mu_form) (bte : Btrans_env),
 f_bte_ok (mu_and g h) bte -> f_bte_ok g bte /\ f_bte_ok h bte.

Lemma mu_or_bte_ok :
 forall (g h : mu_form) (bte : Btrans_env),
 f_bte_ok (mu_or g h) bte -> f_bte_ok g bte /\ f_bte_ok h bte.

Lemma mu_impl_bte_ok :
 forall (g h : mu_form) (bte : Btrans_env),
 f_bte_ok (mu_impl g h) bte -> f_bte_ok g bte /\ f_bte_ok h bte.

Lemma mu_iff_bte_ok :
 forall (g h : mu_form) (bte : Btrans_env),
 f_bte_ok (mu_iff g h) bte -> f_bte_ok g bte /\ f_bte_ok h bte.

Lemma mu_all_bre_ok :
 forall (t : ad) (g : mu_form) (bre : Brel_env),
 f_bre_ok (mu_all t g) bre -> f_bre_ok g bre.

Lemma mu_all_bte_ok :
 forall (t : ad) (g : mu_form) (bte : Btrans_env),
 f_bte_ok (mu_all t g) bte -> f_bte_ok g bte.

Lemma mu_ex_bre_ok :
 forall (t : ad) (g : mu_form) (bre : Brel_env),
 f_bre_ok (mu_ex t g) bre -> f_bre_ok g bre.
 
Lemma mu_ex_bte_ok :
 forall (t : ad) (g : mu_form) (bte : Btrans_env),
 f_bte_ok (mu_ex t g) bte -> f_bte_ok g bte.

Lemma mu_mu_bre_ok :
 forall (P node : ad) (g : mu_form) (bre : Brel_env),
 f_bre_ok (mu_mu P g) bre -> f_bre_ok g (MapPut _ bre P node).

Lemma cfg_ul_re_bre_ok_preserved :
 forall (cfg cfg1 : BDDconfig) (ul : list ad) (re : rel_env) (bre : Brel_env),
 BDDconfig_OK cfg ->
 BDDconfig_OK cfg1 ->
 used_list_OK cfg ul ->
 cfg_ul_bre_ok cfg ul bre ->
 cfg_re_bre_ok cfg re bre ->
 used_nodes_preserved cfg cfg1 ul ->
 cfg_ul_bre_ok cfg1 ul bre /\ cfg_re_bre_ok cfg1 re bre.

Lemma cfg_ul_te_bte_ok_preserved :
 forall (cfg cfg1 : BDDconfig) (ul : list ad) (te : trans_env)
   (bte : Btrans_env),
 BDDconfig_OK cfg ->
 BDDconfig_OK cfg1 ->
 used_list_OK cfg ul ->
 cfg_ul_bte_ok cfg ul bte ->
 cfg_te_bte_ok cfg te bte ->
 used_nodes_preserved cfg cfg1 ul ->
 cfg_ul_bte_ok cfg1 ul bte /\ cfg_te_bte_ok cfg1 te bte.

Lemma cfg_ul_bre_cons_ok :
 forall (cfg : BDDconfig) (ul : list ad) (bre : Brel_env) (node : ad),
 cfg_ul_bre_ok cfg ul bre -> cfg_ul_bre_ok cfg (node :: ul) bre.

Lemma cfg_ul_bte_cons_ok :
 forall (cfg : BDDconfig) (ul : list ad) (bte : Btrans_env) (node : ad),
 cfg_ul_bte_ok cfg ul bte -> cfg_ul_bte_ok cfg (node :: ul) bte.

Lemma cfg_re_bre_ok_put :
 forall (cfg : BDDconfig) (re : rel_env) (bre : Brel_env) 
   (be : bool_expr) (P node : ad),
 cfg_re_bre_ok cfg re bre ->
 bool_fun_eq (bool_fun_of_BDD cfg node) (bool_fun_of_bool_expr be) ->
 cfg_re_bre_ok cfg (re_put re P be) (MapPut _ bre P node).

Lemma cfg_ul_bre_ok_put :
 forall (cfg : BDDconfig) (ul : list ad) (bre : Brel_env) (P node : ad),
 cfg_ul_bre_ok cfg ul bre ->
 cfg_ul_bre_ok cfg (node :: ul) (MapPut _ bre P node).

Lemma BDDiter2n_lemma2 :
 forall (te : trans_env) (bte : Btrans_env) (g : mu_form)
   (Bf : mu_form -> BDDconfig -> list ad -> Brel_env -> BDDconfig * ad)
   (f : mu_form -> rel_env -> bool_expr),
 (forall (cfg : BDDconfig) (ul : list ad) (re : rel_env) (bre : Brel_env),
  BDDconfig_OK cfg ->
  used_list_OK cfg ul ->
  cfg_ul_bre_ok cfg ul bre ->
  cfg_re_bre_ok cfg re bre ->
  cfg_ul_bte_ok cfg ul bte ->
  cfg_te_bte_ok cfg te bte ->
  f_bre_ok g bre ->
  f_bte_ok g bte ->
  BDDconfig_OK (fst (Bf g cfg ul bre)) /\
  config_node_OK (fst (Bf g cfg ul bre)) (snd (Bf g cfg ul bre)) /\
  used_nodes_preserved cfg (fst (Bf g cfg ul bre)) ul /\
  bool_fun_eq
    (bool_fun_of_BDD (fst (Bf g cfg ul bre)) (snd (Bf g cfg ul bre)))
    (bool_fun_of_bool_expr (f g re))) ->
 forall (n : nat) (P : ad) (cfg : BDDconfig) (node : ad) 
   (ul : list ad) (be : bool_expr) (re : rel_env) (bre : Brel_env),
 BDDconfig_OK cfg ->
 config_node_OK cfg node ->
 used_list_OK cfg ul ->
 cfg_ul_bre_ok cfg ul bre ->
 cfg_re_bre_ok cfg re bre ->
 cfg_ul_bte_ok cfg ul bte ->
 cfg_te_bte_ok cfg te bte ->
 (forall x : ad, f_bre_ok g (MapPut _ bre P x)) ->
 f_bte_ok g bte ->
 bool_fun_eq (bool_fun_of_BDD cfg node) (bool_fun_of_bool_expr be) ->
 BDDconfig_OK
   (fst
      (fst
         (BDDiter2n
            (fun (cfg0 : BDDconfig) (node0 : ad) =>
             Bf g cfg0 (node0 :: ul) (MapPut ad bre P node0)) cfg node n))) /\
 config_node_OK
   (fst
      (fst
         (BDDiter2n
            (fun (cfg0 : BDDconfig) (node0 : ad) =>
             Bf g cfg0 (node0 :: ul) (MapPut ad bre P node0)) cfg node n)))
   (snd
      (fst
         (BDDiter2n
            (fun (cfg0 : BDDconfig) (node0 : ad) =>
             Bf g cfg0 (node0 :: ul) (MapPut ad bre P node0)) cfg node n))) /\
 used_nodes_preserved cfg
   (fst
      (fst
         (BDDiter2n
            (fun (cfg0 : BDDconfig) (node0 : ad) =>
             Bf g cfg0 (node0 :: ul) (MapPut ad bre P node0)) cfg node n)))
   ul /\
 bool_fun_eq
   (bool_fun_of_BDD
      (fst
         (fst
            (BDDiter2n
               (fun (cfg0 : BDDconfig) (node0 : ad) =>
                Bf g cfg0 (node0 :: ul) (MapPut ad bre P node0)) cfg node n)))
      (snd
         (fst
            (BDDiter2n
               (fun (cfg0 : BDDconfig) (node0 : ad) =>
                Bf g cfg0 (node0 :: ul) (MapPut ad bre P node0)) cfg node n))))
   (bool_fun_of_bool_expr
      (fst
         (iter2n _ be_eq_dec (fun be : bool_expr => f g (re_put re P be)) be
            n))) /\
 snd
   (BDDiter2n
      (fun (cfg0 : BDDconfig) (node0 : ad) =>
       Bf g cfg0 (node0 :: ul) (MapPut ad bre P node0)) cfg node n) =
 snd (iter2n _ be_eq_dec (fun be : bool_expr => f g (re_put re P be)) be n).

Lemma BDDiter2n_lemma1 :
 forall (te : trans_env) (bte : Btrans_env) (g : mu_form)
   (Bf : mu_form -> BDDconfig -> list ad -> Brel_env -> BDDconfig * ad)
   (f : mu_form -> rel_env -> bool_expr),
 (forall (cfg : BDDconfig) (ul : list ad) (re : rel_env) (bre : Brel_env),
  BDDconfig_OK cfg ->
  used_list_OK cfg ul ->
  cfg_ul_bre_ok cfg ul bre ->
  cfg_re_bre_ok cfg re bre ->
  cfg_ul_bte_ok cfg ul bte ->
  cfg_te_bte_ok cfg te bte ->
  f_bre_ok g bre ->
  f_bte_ok g bte ->
  BDDconfig_OK (fst (Bf g cfg ul bre)) /\
  config_node_OK (fst (Bf g cfg ul bre)) (snd (Bf g cfg ul bre)) /\
  used_nodes_preserved cfg (fst (Bf g cfg ul bre)) ul /\
  bool_fun_eq
    (bool_fun_of_BDD (fst (Bf g cfg ul bre)) (snd (Bf g cfg ul bre)))
    (bool_fun_of_bool_expr (f g re))) ->
 forall (n : nat) (P : ad) (cfg : BDDconfig) (node : ad) 
   (ul : list ad) (be : bool_expr) (re : rel_env) (bre : Brel_env),
 BDDconfig_OK cfg ->
 config_node_OK cfg node ->
 used_list_OK cfg ul ->
 cfg_ul_bre_ok cfg ul bre ->
 cfg_re_bre_ok cfg re bre ->
 cfg_ul_bte_ok cfg ul bte ->
 cfg_te_bte_ok cfg te bte ->
 (forall x : ad, f_bre_ok g (MapPut _ bre P x)) ->
 f_bte_ok g bte ->
 bool_fun_eq (bool_fun_of_BDD cfg node) (bool_fun_of_bool_expr be) ->
 BDDconfig_OK
   (fst
      (fst
         (BDDiter2n
            (fun (cfg0 : BDDconfig) (node0 : ad) =>
             Bf g cfg0 (node0 :: ul) (MapPut ad bre P node0)) cfg node n))) /\
 config_node_OK
   (fst
      (fst
         (BDDiter2n
            (fun (cfg0 : BDDconfig) (node0 : ad) =>
             Bf g cfg0 (node0 :: ul) (MapPut ad bre P node0)) cfg node n)))
   (snd
      (fst
         (BDDiter2n
            (fun (cfg0 : BDDconfig) (node0 : ad) =>
             Bf g cfg0 (node0 :: ul) (MapPut ad bre P node0)) cfg node n))) /\
 used_nodes_preserved cfg
   (fst
      (fst
         (BDDiter2n
            (fun (cfg0 : BDDconfig) (node0 : ad) =>
             Bf g cfg0 (node0 :: ul) (MapPut ad bre P node0)) cfg node n)))
   ul /\
 bool_fun_eq
   (bool_fun_of_BDD
      (fst
         (fst
            (BDDiter2n
               (fun (cfg0 : BDDconfig) (node0 : ad) =>
                Bf g cfg0 (node0 :: ul) (MapPut ad bre P node0)) cfg node n)))
      (snd
         (fst
            (BDDiter2n
               (fun (cfg0 : BDDconfig) (node0 : ad) =>
                Bf g cfg0 (node0 :: ul) (MapPut ad bre P node0)) cfg node n))))
   (bool_fun_of_bool_expr
      (fst
         (iter2n _ be_eq_dec (fun be : bool_expr => f g (re_put re P be)) be
            n))).

Section MuEval.

Variable gc : BDDconfig -> list ad -> BDDconfig.
Hypothesis gc_is_OK : gc_OK gc.

Variable te : trans_env.
Variable bte : Btrans_env.

Fixpoint mu_eval (f : mu_form) : rel_env -> bool_expr :=
  fun re =>
  match f with
  | mu_0 => Zero
  | mu_1 => One
  | mu_ap p => Var p
  | mu_rel_var P => re P
  | mu_neg g => Neg (mu_eval g re)
  | mu_and g h => ANd (mu_eval g re) (mu_eval h re)
  | mu_or g h => Or (mu_eval g re) (mu_eval h re)
  | mu_impl g h => Impl (mu_eval g re) (mu_eval h re)
  | mu_iff g h => Iff (mu_eval g re) (mu_eval h re)
  | mu_all t g => mu_all_eval N (te t) (mu_eval g re)
  | mu_ex t g => mu_ex_eval N (te t) (mu_eval g re)
  | mu_mu P g =>
      fst (iter2n _ be_eq_dec (fun be => mu_eval g (re_put re P be)) Zero N)
  end.

Definition re_to_be_inc (f : rel_env -> bool_expr) 
  (P : ad) :=
  forall (re : rel_env) (be1 be2 : bool_expr),
  be_le be1 be2 -> be_le (f (re_put re P be1)) (f (re_put re P be2)).

Definition re_to_be_dec (f : rel_env -> bool_expr) 
  (P : ad) :=
  forall (re : rel_env) (be1 be2 : bool_expr),
  be_le be1 be2 -> be_le (f (re_put re P be2)) (f (re_put re P be1)).

Definition ad_to_be_ok (vf : ad -> bool) (abe : ad -> bool_expr) :=
  forall x : ad, be_ok vf (abe x).

Definition ad_to_be_eq (f1 f2 : ad -> bool_expr) :=
  forall x : ad, be_eq (f1 x) (f2 x).

Hypothesis te_ok : ad_to_be_ok (var_lu 0 (2 * N)) te.

Lemma mu_all_eval_lu :
 forall t be : bool_expr,
 be_ok (var_lu 0 (2 * N)) t ->
 be_ok (var_lu 0 N) be -> be_ok (var_lu 0 N) (mu_all_eval N t be). 

Lemma mu_ex_eval_lu :
 forall t be : bool_expr,
 be_ok (var_lu 0 (2 * N)) t ->
 be_ok (var_lu 0 N) be -> be_ok (var_lu 0 N) (mu_ex_eval N t be).

Definition ad_to_be_eq1 (f : mu_form) (f1 f2 : ad -> bool_expr) :=
  forall x : ad, mu_rel_free x f = true -> be_eq (f1 x) (f2 x).

Lemma mu_eval_lemma2 :
 forall f : mu_form,
 f_ok f ->
 mu_form_ap_ok (var_lu 0 N) f ->
 (forall re : rel_env,
  ad_to_be_ok (var_lu 0 N) re -> be_ok (var_lu 0 N) (mu_eval f re)) /\
 (forall P : ad, f_P_even P f true -> re_to_be_inc (mu_eval f) P) /\
 (forall P : ad, f_P_even P f false -> re_to_be_dec (mu_eval f) P) /\
 (forall re1 re2 : rel_env,
  ad_to_be_eq1 f re1 re2 -> be_eq (mu_eval f re1) (mu_eval f re2)).

Lemma mu_eval_lemma1 :
 forall f : mu_form,
 f_ok f ->
 mu_form_ap_ok (var_lu 0 N) f ->
 (forall re : rel_env,
  ad_to_be_ok (var_lu 0 N) re -> be_ok (var_lu 0 N) (mu_eval f re)) /\
 (forall P : ad, f_P_even P f true -> re_to_be_inc (mu_eval f) P) /\
 (forall P : ad, f_P_even P f false -> re_to_be_dec (mu_eval f) P) /\
 (forall re1 re2 : rel_env,
  ad_to_be_eq re1 re2 -> be_eq (mu_eval f re1) (mu_eval f re2)).

Lemma lfp_be_lfp :
 forall (bef : bool_expr -> bool_expr) (be : bool_expr),
 lfp bef be <-> lfp_be bef Zero be.

Lemma be_iter_is_lfp_be :
 forall (bef : bool_expr -> bool_expr) (n : nat) (be : bool_expr),
 be_le be (bef be) ->
 (forall be1 be2 : bool_expr, be_eq be1 be2 -> be_eq (bef be1) (bef be2)) ->
 (forall be1 be2 : bool_expr, be_le be1 be2 -> be_le (bef be1) (bef be2)) ->
 (exists m : nat, m <= n /\ be_eq (be_iter1 bef be m) (be_iter1 bef be (S m))) ->
 lfp_be bef be (be_iter bef be n).

Lemma be_iter1_n_le :
 forall (n : nat) (be : bool_expr) (bef : bool_expr -> bool_expr),
 n <> 0 ->
 (forall be1 be2 : bool_expr, be_le be1 be2 -> be_le (bef be1) (bef be2)) ->
 be_le be (bef be) -> be_le be (be_iter1 bef be n).

Lemma be_iter2n_is_lfp_be :
 forall (bef : bool_expr -> bool_expr) (n : nat) (be : bool_expr),
 be_le be (bef be) ->
 (forall be1 be2 : bool_expr, be_eq be1 be2 -> be_eq (bef be1) (bef be2)) ->
 (forall be1 be2 : bool_expr, be_le be1 be2 -> be_le (bef be1) (bef be2)) ->
 (exists m : nat,
    m <= two_power n /\ be_eq (be_iter1 bef be m) (be_iter1 bef be (S m))) ->
 lfp_be bef be (fst (be_iter2n bef be n)).

Lemma be_le_zero : forall be : bool_expr, be_le Zero be.

Section Mu_eval_as_fix.

  Variable P : ad.
  Variable f : mu_form.
  Variable re : rel_env.

  Hypothesis f_is_ok : f_ok f.
  Hypothesis f_ap_ok : mu_form_ap_ok (var_lu 0 N) f.
  Hypothesis f_even : f_P_even P f true.
  Hypothesis re_ok : ad_to_be_ok (var_lu 0 N) re.

  Definition mf (be : bool_expr) := mu_eval f (re_put re P be).
  Definition mfs (n : nat) := fst (be_iter2n mf Zero n).

  Lemma mf_inc : be_to_be_inc mf.

  Lemma mf_be_ok :
   forall be : bool_expr, be_ok (var_lu 0 N) be -> be_ok (var_lu 0 N) (mf be).

  Lemma mf_preserves_eq :
   forall be1 be2 : bool_expr, be_eq be1 be2 -> be_eq (mf be1) (mf be2).
 
  Lemma mf_fix_ex :
   exists m : nat,
     m <= two_power N /\ be_eq (be_iter1 mf Zero m) (be_iter1 mf Zero (S m)).

  Lemma mf_lfp : lfp mf (fst (be_iter2n mf Zero N)).

End Mu_eval_as_fix.

Lemma mu_eval_mu_is_lfp :
 forall (P : ad) (f : mu_form) (re : rel_env),
 f_ok (mu_mu P f) ->
 mu_form_ap_ok (var_lu 0 N) (mu_mu P f) ->
 ad_to_be_ok (var_lu 0 N) re ->
 lfp (fun be : bool_expr => mu_eval f (re_put re P be))
   (mu_eval (mu_mu P f) re).

Fixpoint BDDmu_eval (f : mu_form) :
 BDDconfig -> list ad -> Brel_env -> BDDconfig * ad :=
  fun cfg ul bre =>
  match f with
  | mu_0 => (cfg, BDDzero)
  | mu_1 => (cfg, BDDone)
  | mu_ap p => BDDvar_make gc cfg ul p
  | mu_rel_var P =>
      match MapGet _ bre P with
      | None => (cfg, BDDzero)
      | Some node => (cfg, node)
      end
  | mu_neg g =>
      match BDDmu_eval g cfg ul bre with
      | (cfgg, nodeg) => BDDneg gc cfgg (nodeg :: ul) nodeg
      end
  | mu_and g h =>
      match BDDmu_eval g cfg ul bre with
      | (cfgg, nodeg) =>
          match BDDmu_eval h cfgg (nodeg :: ul) bre with
          | (cfgh, nodeh) =>
              BDDand gc cfgh (nodeh :: nodeg :: ul) nodeg nodeh
          end
      end
  | mu_or g h =>
      match BDDmu_eval g cfg ul bre with
      | (cfgg, nodeg) =>
          match BDDmu_eval h cfgg (nodeg :: ul) bre with
          | (cfgh, nodeh) => BDDor gc cfgh (nodeh :: nodeg :: ul) nodeg nodeh
          end
      end
  | mu_impl g h =>
      match BDDmu_eval g cfg ul bre with
      | (cfgg, nodeg) =>
          match BDDmu_eval h cfgg (nodeg :: ul) bre with
          | (cfgh, nodeh) =>
              BDDimpl gc cfgh (nodeh :: nodeg :: ul) nodeg nodeh
          end
      end
  | mu_iff g h =>
      match BDDmu_eval g cfg ul bre with
      | (cfgg, nodeg) =>
          match BDDmu_eval h cfgg (nodeg :: ul) bre with
          | (cfgh, nodeh) =>
              BDDiff gc cfgh (nodeh :: nodeg :: ul) nodeg nodeh
          end
      end
  | mu_all t g =>
      match MapGet _ bte t with
      | None => (cfg, BDDzero)
      | Some nodet =>
          match BDDmu_eval g cfg ul bre with
          | (cfgg, nodeg) => BDDmu_all N gc cfgg (nodeg :: ul) nodet nodeg
          end
      end
  | mu_ex t g =>
      match MapGet _ bte t with
      | None => (cfg, BDDzero)
      | Some nodet =>
          match BDDmu_eval g cfg ul bre with
          | (cfgg, nodeg) => BDDmu_ex N gc cfgg (nodeg :: ul) nodet nodeg
          end
      end
  | mu_mu P g =>
      fst
        (BDDiter2n
           (fun cfg node =>
            BDDmu_eval g cfg (node :: ul) (MapPut _ bre P node)) cfg BDDzero
           N)
  end.

Lemma BDDmu_eval_ok :
 forall (f : mu_form) (cfg : BDDconfig) (ul : list ad) 
   (re : rel_env) (bre : Brel_env),
 BDDconfig_OK cfg ->
 used_list_OK cfg ul ->
 cfg_ul_bre_ok cfg ul bre ->
 cfg_re_bre_ok cfg re bre ->
 cfg_ul_bte_ok cfg ul bte ->
 cfg_te_bte_ok cfg te bte ->
 f_bre_ok f bre ->
 f_bte_ok f bte ->
 BDDconfig_OK (fst (BDDmu_eval f cfg ul bre)) /\
 config_node_OK (fst (BDDmu_eval f cfg ul bre))
   (snd (BDDmu_eval f cfg ul bre)) /\
 used_nodes_preserved cfg (fst (BDDmu_eval f cfg ul bre)) ul /\
 bool_fun_eq
   (bool_fun_of_BDD (fst (BDDmu_eval f cfg ul bre))
      (snd (BDDmu_eval f cfg ul bre))) (bool_fun_of_bool_expr (mu_eval f re)).

End MuEval.

End Nsec. *)
Require Import munew.
(* munew:
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import ZArith NArith Nnat Ndec Ndigits.
From IntMap Require Import Map.
From IntMap Require Import Allmaps.
Require Import Wf_nat.
Require Import EqNat.
Require Import Peano_dec.
Require Import Ensembles.
Require Import Finite_sets.
Require Import Finite_sets_facts.
Require Import Image.
Require Import List.
Require Import Compare.
 
Require Import misc.
Require Import bool_fun.
Require Import myMap.
Require Import config.
Require Import alloc.
Require Import make.
Require Import neg.
Require Import or.
Require Import univ.
Require Import op.
Require Import tauto.
Require Import quant.
Require Import gc.
Require Import mu.

Section New.

Variable N : nat.

Definition var_env'_dash (ve : var_env') (n : nat) :=
  if leb N n then ve (n - N) else false.

Definition var_env''_dash (ve : var_env'') :=
  var_env'_to_env'' N (2 * N) (var_env'_dash (var_env''_to_env' ve)).
 
Fixpoint be_dash (be : bool_expr) : bool_expr :=
  match be with
  | Zero => Zero
  | One => One
  | Var x => Var (N_of_nat (N + nat_of_N x))
  | Neg be' => Neg (be_dash be')
  | Or be1 be2 => Or (be_dash be1) (be_dash be2)
  | ANd be1 be2 => ANd (be_dash be1) (be_dash be2)
  | Impl be1 be2 => Impl (be_dash be1) (be_dash be2)
  | Iff be1 be2 => Iff (be_dash be1) (be_dash be2)
  end.
 
Fixpoint renamef (f : ad -> ad) (be : bool_expr) {struct be} : bool_expr :=
  match be with
  | Zero => Zero
  | One => One
  | Var x => Var (f x)
  | Neg be' => Neg (renamef f be')
  | Or be1 be2 => Or (renamef f be1) (renamef f be2)
  | ANd be1 be2 => ANd (renamef f be1) (renamef f be2)
  | Impl be1 be2 => Impl (renamef f be1) (renamef f be2)
  | Iff be1 be2 => Iff (renamef f be1) (renamef f be2)
  end.

Definition renfnat (n m : nat) := if leb n m then m else m + N.

Definition renfnad (n : nat) (x : ad) := N_of_nat (renfnat n (nat_of_N x)). 

Lemma dash_renf :
 forall be : bool_expr,
 be_ok (var_lu 0 N) be -> be_dash be = renamef (renfnad N) be.

Lemma dash_be_ok :
 forall be : bool_expr,
 be_ok (var_lu 0 N) be -> be_ok (var_lu N (2 * N)) (be_dash be).

Lemma eval_dash_lemma1 :
 forall (be : bool_expr) (ve : var_env'),
 eval_be' be ve = eval_be' (be_dash be) (var_env'_dash ve).
 
Definition var_env_or (ve1 ve2 : var_env) (x : ad) := ve1 x || ve2 x.
Definition var_env'_or (ve1 ve2 : var_env') (x : nat) := ve1 x || ve2 x.
 
Lemma forall_lemma1 :
 forall (be : bool_expr) (ve : var_env) (a : ad),
 bool_fun_of_bool_expr (forall_ a be) ve = true ->
 bool_fun_of_bool_expr be ve = true.

Lemma renamef_ext :
 forall (be : bool_expr) (f g : ad -> ad),
 (forall x : ad, f x = g x) -> renamef f be = renamef g be.

Lemma renamef_id : forall be : bool_expr, renamef (fun x => x) be = be.

Lemma renamefS :
 forall (be : bool_expr) (n : nat),
 n < N ->
 renamef (renfnad (S n)) be =
 subst (ap n) (Var (ap' N n)) (renamef (renfnad n) be).

Lemma replacel_lemma :
 forall (n : nat) (be : bool_expr),
 n <= N -> replacel be (lx_1 n) (lx'_1 N n) = renamef (renfnad n) be.

Lemma replacel_lemma2 :
 forall be : bool_expr,
 be_ok (var_lu 0 N) be -> replacel be (lx N) (lx' N) = be_dash be.

Lemma exl_semantics :
 forall (lx : list ad) (be : bool_expr) (ve : var_env'),
 (forall n : nat, ve n = true -> ~ In (N_of_nat n) lx) ->
 no_dup_list _ lx ->
 (eval_be' (exl be lx) ve = true <->
  (exists ve' : var_env',
     (forall n : nat, ve' n = true -> In (N_of_nat n) lx) /\
     eval_be' be (var_env'_or ve ve') = true)).

Lemma univl_semantics :
 forall (lx : list ad) (be : bool_expr) (ve : var_env'),
 (forall n : nat, ve n = true -> ~ In (N_of_nat n) lx) ->
 no_dup_list _ lx ->
 (eval_be' (univl be lx) ve = true <->
  (forall ve' : var_env',
   (forall n : nat, ve' n = true -> In (N_of_nat n) lx) ->
   eval_be' be (var_env'_or ve ve') = true)).

Lemma bool_fun_of_be_ext1 :
 forall (be : bool_expr) (ve ve' : var_env'),
 (forall x : ad,
  be_x_free x be = true -> ve (nat_of_N x) = ve' (nat_of_N x)) ->
 eval_be' be ve = eval_be' be ve'.

Lemma no_dup_lx'_1 : forall n : nat, no_dup_list _ (lx'_1 N n).

Lemma mu_all_eval_semantics1 :
 forall t be : bool_expr,
 be_ok (var_lu 0 N) be ->
 forall ve : var_env',
 (forall n : nat, ve n = true -> var_lu 0 N (N_of_nat n) = true) ->
 eval_be' (mu_all_eval N t be) ve = true ->
 forall ve' : var_env',
 (forall n : nat, ve' n = true -> var_lu 0 N (N_of_nat n) = true) ->
 eval_be' t (var_env'_or ve (var_env'_dash ve')) = true ->
 eval_be' be ve' = true.

Lemma mu_ex_eval_semantics1 :
 forall t be : bool_expr,
 be_ok (var_lu 0 N) be ->
 forall ve : var_env',
 (forall n : nat, ve n = true -> var_lu 0 N (N_of_nat n) = true) ->
 eval_be' (mu_ex_eval N t be) ve = true ->
 exists ve' : var_env',
   (forall n : nat, ve' n = true -> var_lu 0 N (N_of_nat n) = true) /\
   eval_be' t (var_env'_or ve (var_env'_dash ve')) = true /\
   eval_be' be ve' = true.

Lemma mu_ex_eval_semantics2 :
 forall t be : bool_expr,
 be_ok (var_lu 0 N) be ->
 forall ve : var_env',
 (forall n : nat, ve n = true -> var_lu 0 N (N_of_nat n) = true) ->
 (exists ve' : var_env',
    (forall n : nat, ve' n = true -> var_lu 0 N (N_of_nat n) = true) /\
    eval_be' t (var_env'_or ve (var_env'_dash ve')) = true /\
    eval_be' be ve' = true) -> eval_be' (mu_ex_eval N t be) ve = true.

Lemma mu_all_eval_semantics2 :
 forall t be : bool_expr,
 be_ok (var_lu 0 N) be ->
 forall ve : var_env',
 (forall n : nat, ve n = true -> var_lu 0 N (N_of_nat n) = true) ->
 (forall ve' : var_env',
  (forall n : nat, ve' n = true -> var_lu 0 N (N_of_nat n) = true) ->
  eval_be' t (var_env'_or ve (var_env'_dash ve')) = true ->
  eval_be' be ve' = true) -> eval_be' (mu_all_eval N t be) ve = true.

End New. *)

Lemma relfreeeven :
 forall (f : mu_form) (P : ad) (b : bool),
 mu_rel_free P f = false -> f_P_even P f b.
Proof.
  simple induction f.  intros.  elim b; [ apply mu_0_even | apply mu_0_odd ].  intros.
  elim b; [ apply mu_1_even | apply mu_1_odd ].  intros.
  elim b; [ apply mu_ap_even | apply mu_ap_odd ].  intros.
  simpl in H.  elim b.  apply mu_rel_var_even.  apply mu_rel_var_odd.
  assumption.  intros.  simpl in H0.  elim b.  apply mu_neg_even.  apply H.
  assumption.  apply mu_neg_odd.  apply H.  assumption.  intros.  simpl in H1.
  elim (orb_false_elim _ _ H1); intros.  elim b.  apply mu_and_even.  apply H.
  assumption.  apply H0.  assumption.  apply mu_and_odd.  apply H.  assumption.
  apply H0.  assumption.  intros.  simpl in H1.
  elim (orb_false_elim _ _ H1); intros.  elim b.  apply mu_or_even.  apply H.
  assumption.  apply H0.  assumption.  apply mu_or_odd.  apply H.  assumption.
  apply H0.  assumption.  intros.  simpl in H1.
  elim (orb_false_elim _ _ H1); intros.  elim b.  apply mu_impl_even.  apply H.
  assumption.  apply H0.  assumption.  apply mu_impl_odd.  apply H.  assumption.
  apply H0.  assumption.  intros.  simpl in H1.
  elim (orb_false_elim _ _ H1); intros.  elim b.  apply mu_iff_even.  apply H.
  assumption.  apply H0.  assumption.  apply H.  assumption.  apply H0.
  assumption.  apply mu_iff_odd.  apply H.  assumption.  apply H0.  assumption.
  apply H.  assumption.  apply H0.  assumption.  intros.  simpl in H0.  elim b.
  apply mu_all_even.  apply H.  assumption.  apply mu_all_odd.  apply H.
  assumption.  intros.  simpl in H0.  elim b.  apply mu_ex_even.  apply H.
  assumption.  apply mu_ex_odd.  apply H.  assumption.  intros.  simpl in H0.
  elim (sumbool_of_bool (Neqb P a)).  intro y.
  rewrite <- (Neqb_complete _ _ y).  elim b.  apply mu_mu_P_even.
  apply mu_mu_P_odd.  intro y.  rewrite y in H0.  simpl in H0.  elim b.
  apply mu_mu_Q_even.  assumption.  apply H.  assumption.  apply mu_mu_Q_odd.
  assumption.  apply H.  assumption.
Qed.

Section mu2set.

Variable N : nat.

Definition set_1 := Evar_env'' 0 N.
Definition rel_1 (s t : var_env'') := In _ set_1 s /\ In _ set_1 t.

Definition t_to_rel1 (t : bool_expr) (ve1 ve2 : var_env') :=
  eval_be' t (var_env'_or ve1 (var_env'_dash N ve2)).
Definition t_to_rel (t : bool_expr) (ve1 ve2 : var_env'') :=
  t_to_rel1 t (var_env''_to_env' ve1) (var_env''_to_env' ve2).
Definition new_t_to_rel (t : bool_expr) (ve1 ve2 : var_env'') :=
  t_to_rel t ve1 ve2 = true /\ rel_1 ve1 ve2.

Definition state_set (S : Ensemble var_env'') := Included _ S set_1.
Definition state_rel (R : Relation var_env'') :=
  forall s t : var_env'', R s t -> rel_1 s t.  

Definition set_0 := Empty_set var_env''.
Definition set_ap (x : ad) (s : var_env'') :=
  In _ set_1 s /\ in_dom _ x s = true.
Definition set_or := Union var_env''.
Definition set_and := Intersection var_env''.
Definition set_neg := Setminus _ set_1.
Definition set_impl (S1 S2 : Ensemble var_env'') := set_or (set_neg S1) S2.
Definition set_iff (S1 S2 : Ensemble var_env'') :=
  set_and (set_impl S1 S2) (set_impl S2 S1).
Inductive set_ex (R : Relation var_env'') (S : Ensemble var_env'') :
Ensemble var_env'' :=
    setex_intro :
      forall s t : var_env'',
      In _ set_1 s -> R s t -> In _ S t -> In _ (set_ex R S) s.
Definition set_all (R : Relation var_env'') (S : Ensemble var_env'')
  (s : var_env'') :=
  In _ set_1 s /\ (forall t : var_env'', R s t -> In _ S t).
Definition set_mu (f : Ensemble var_env'' -> Ensemble var_env'')
  (s : var_env'') :=
  forall X : Ensemble var_env'',
  state_set X -> Included _ (f X) X -> In _ X s.

Definition set_renv := ad -> Ensemble var_env''.
Definition set_tenv := ad -> Relation var_env''.
Definition sre_put (sre : set_renv) (P : ad) (S : Ensemble var_env'')
  (Q : ad) := if Neqb P Q then S else sre Q.
Definition te_ste_ok (te : trans_env) (ste : set_tenv) :=
  forall (a : ad) (ve1 ve2 : var_env''),
  new_t_to_rel (te a) ve1 ve2 <-> ste a ve1 ve2.
Definition re_sre_ok (re : rel_env) (sre : set_renv) :=
  forall P : ad, bool_expr_to_var_env'' 0 N (re P) = sre P.

Fixpoint mu_form2set (ste : set_tenv) (f : mu_form) {struct f} :
 set_renv -> Ensemble var_env'' :=
  fun sre =>
  match f with
  | mu_0 => set_0
  | mu_1 => set_1
  | mu_ap p => set_ap p
  | mu_rel_var P => sre P
  | mu_neg g => set_neg (mu_form2set ste g sre)
  | mu_and g1 g2 => set_and (mu_form2set ste g1 sre) (mu_form2set ste g2 sre)
  | mu_or g1 g2 => set_or (mu_form2set ste g1 sre) (mu_form2set ste g2 sre)
  | mu_impl g1 g2 =>
      set_impl (mu_form2set ste g1 sre) (mu_form2set ste g2 sre)
  | mu_iff g1 g2 => set_iff (mu_form2set ste g1 sre) (mu_form2set ste g2 sre)
  | mu_all t g => set_all (ste t) (mu_form2set ste g sre)
  | mu_ex t g => set_ex (ste t) (mu_form2set ste g sre)
  | mu_mu P g => set_mu (fun S => mu_form2set ste g (sre_put sre P S))
  end.

Lemma set_ap_state_set : forall x : ad, state_set (set_ap x).
Proof.
  unfold state_set, set_ap in |- *.  unfold Included in |- *.  unfold In in |- *.  tauto.
Qed.

Lemma var_env'_to_env''_to_env' :
 forall (L U : nat) (ve : var_env') (x : ad),
 var_lu L U x = true ->
 var_env''_to_env' (var_env'_to_env'' L U ve) (nat_of_N x) =
 ve (nat_of_N x).
Proof.
  intros.  unfold var_env''_to_env', var_env'_to_env'' in |- *.
  elim (var_env'_to_var_env''_lemma2 (U - L) L U ve (refl_equal (U - L))).
  intros x0 y.  rewrite (N_of_nat_of_N x).  apply (proj2 y).  assumption.
Qed.

Lemma le_minus_le1 : forall m n p : nat, m <= n -> m - p <= n - p.
Proof.
  simple induction 1.  auto with arith.  intros.  apply le_trans with (m := m0 - p).
  assumption.  generalize p.  generalize m0.  simple induction m1.  simpl in |- *.
  auto with arith.  intros.  elim p0.  auto with arith.  intros.
  replace (S n0 - S n1) with (n0 - n1).
  replace (S (S n0) - S n1) with (S n0 - n1).  apply H2.  
  reflexivity.  reflexivity.
Qed.

Fixpoint ve''_to_be (ve : var_env'') (n : nat) {struct n} : bool_expr :=
  match n with
  | O => One
  | S m =>
      match in_dom _ (N_of_nat m) ve with
      | true => ANd (ve''_to_be ve m) (Var (N_of_nat m))
      | false => ANd (ve''_to_be ve m) (Neg (Var (N_of_nat m)))
      end
  end.

Lemma ve''_to_be_ok :
 forall (n : nat) (ve ve' : var_env''),
 bool_fun_of_bool_expr (ve''_to_be ve n) (var_env''_to_env ve') = true ->
 forall m : nat,
 m < n -> MapGet _ ve (N_of_nat m) = MapGet _ ve' (N_of_nat m).
Proof.
  simple induction n.  intros.  elim (lt_n_O _ H0).  intros.  simpl in H0.
  elim (option_sum _ (MapGet unit ve (N_of_nat n0))).  intro y.  elim y.  intro x.
  elim x.  intros y0.  unfold in_dom in H0.  clear y.  rewrite y0 in H0.
  simpl in H0.  unfold bool_fun_and in H0.  elim (andb_prop _ _ H0).  clear H0.
  intros.  unfold bool_fun_var in H2.  unfold var_env''_to_env in H2.
  unfold lt in H1.  elim (le_lt_eq_dec m n0).  intros y.
  rewrite (H ve ve' H0 m y).  reflexivity.  intro y.  rewrite y.  rewrite y0.
  unfold in_dom in H2.  elim (option_sum _ (MapGet unit ve' (N_of_nat n0))).
  intro y1.  inversion y1.  rewrite H3.  elim x0.  reflexivity.  intro y1.
  rewrite y1 in H2.  discriminate.  apply le_S_n.  assumption.  intro y.
  unfold in_dom in H0.  rewrite y in H0.  simpl in H0.
  unfold bool_fun_and in H0.  elim (andb_prop _ _ H0).  intros.
  unfold bool_fun_neg, bool_fun_var, var_env''_to_env in H3.  unfold in_dom in H3.
  unfold lt in H1.  elim (le_lt_eq_dec m n0).  intro y0.  apply (H ve ve').
  assumption.  assumption.  intro y0.  rewrite y0.  rewrite y.
  elim (option_sum _ (MapGet unit ve' (N_of_nat n0))).  intro y1.  inversion y1.
  rewrite H4 in H3.  simpl in H3.  discriminate.  intro y1.  rewrite y1.
  reflexivity.  apply le_S_n.  assumption.
Qed.

Lemma ve''_to_be_ok1 :
 forall (n : nat) (ve ve' : var_env''),
 Evar_env'' 0 n ve ->
 bool_expr_to_var_env'' 0 n (ve''_to_be ve n) ve' -> ve = ve'.
Proof.
  intros.  unfold Evar_env'' in H.  unfold bool_expr_to_var_env'' in H0.
  elim H; clear H; intros H2 H3.  elim H0; clear H0; intros H4 H5.

  apply (mapcanon_unique unit).  assumption.  unfold Evar_env'' in H5.
  unfold In in H5.  exact (proj1 H5).  unfold Evar_env'' in H5.
  unfold In in H5.
  elim H5; intros H0 H1.
  unfold var_lu in H1, H3.  unfold eqmap in |- *.
  unfold eqm in |- *.  intro.  elim (le_lt_dec n (nat_of_N a)).
  unfold in_dom in H3, H1.  intro.  lapply (H3 a).  lapply (H1 a).
  elim (MapGet unit ve' a).  Focus 2. elim (MapGet unit ve a);  try reflexivity.  intros.
  discriminate.  intros.  discriminate.
  replace (leb (S (nat_of_N a)) n) with false.  simpl in |- *.  reflexivity.
  symmetry  in |- *.  apply not_true_is_false.  unfold not in |- *; intro.  elim (le_Sn_n n).
  apply le_trans with (m := S (nat_of_N a)).  apply le_n_S.  assumption.  
  apply leb_complete.  assumption.  
  replace (leb (S (nat_of_N a)) n) with false.  simpl in |- *.  reflexivity.  
  symmetry  in |- *.  apply not_true_is_false.  unfold not in |- *; intro.  elim (le_Sn_n n).
  apply le_trans with (m := S (nat_of_N a)).  apply le_n_S.  assumption.  
  apply leb_complete.  assumption.  intro.  rewrite <- (N_of_nat_of_N a).
  apply (ve''_to_be_ok n ve ve').  unfold eval_be' in H4.  rewrite <- H4.
  apply (bool_fun_of_be_ext (ve''_to_be ve n)).
  unfold var_env''_to_env, var_env'_to_env, var_env''_to_env' in |- *.  intros.
  rewrite (N_of_nat_of_N x).  reflexivity.  assumption.  
Qed.

Lemma ve''_to_be_ok2 :
 forall (n : nat) (ve : var_env''),
 eval_be' (ve''_to_be ve n) (var_env''_to_env' ve) = true.
Proof.
  simple induction n.  simpl in |- *.  unfold eval_be' in |- *.  simpl in |- *.  unfold bool_fun_one in |- *.
  reflexivity.  simpl in |- *.  intros.  unfold in_dom in |- *.
  elim (option_sum _ (MapGet unit ve (N_of_nat n0))).  intro y.  elim y; clear y.
  intro x.  elim x.  clear x.  intros y.  rewrite y.  unfold eval_be' in |- *.  simpl in |- *.
  unfold eval_be' in H.  unfold bool_fun_and in |- *.  apply andb_true_intro.  split.
  apply H.  unfold bool_fun_var, var_env'_to_env, var_env''_to_env' in |- *.
  rewrite (nat_of_N_of_nat n0).  unfold in_dom in |- *.  rewrite y.  reflexivity.  
  intro y.  rewrite y.  unfold eval_be' in |- *.  simpl in |- *.  unfold eval_be' in H.
  unfold bool_fun_and in |- *.  apply andb_true_intro.  split.  apply H.  
  unfold bool_fun_var, var_env'_to_env, var_env''_to_env', bool_fun_neg
   in |- *.
  rewrite (nat_of_N_of_nat n0).  unfold in_dom in |- *.  rewrite y.  reflexivity.
Qed.

Lemma ve''_to_be_ok3 :
 forall (n : nat) (ve : var_env''),
 n <= N -> be_ok (var_lu 0 N) (ve''_to_be ve n).
Proof.
  simple induction n.  intros.  simpl in |- *.  apply one_ok.  simpl in |- *.  intros.
  elim (in_dom unit (N_of_nat n0) ve).  apply and_ok.  apply H.
  apply lt_le_weak.  assumption.  apply var_ok.  unfold var_lu in |- *.
  apply andb_true_intro.  split.  auto with arith.  
  rewrite (nat_of_N_of_nat n0).  apply leb_correct.  assumption.  
  apply and_ok.  apply H.  apply lt_le_weak.  assumption.  apply neg_ok.
  apply var_ok.  unfold var_lu in |- *.  apply andb_true_intro.  split.
  auto with arith.  rewrite (nat_of_N_of_nat n0).  apply leb_correct.
  assumption. 
Qed.

Lemma env_to_be_lemma :
 forall S : Ensemble var_env'',
 Finite _ S ->
 Included _ S (Evar_env'' 0 N) ->
 exists be : bool_expr,
   bool_expr_to_var_env'' 0 N be = S /\ be_ok (var_lu 0 N) be.
Proof.
  intro.  simple induction 1.
  unfold Included, bool_expr_to_var_env'', Evar_env'' in |- *.  unfold In in |- *.  intros.
  split with Zero. split.
  apply Extensionality_Ensembles.  split.  unfold Included in |- *.
  intros.  unfold In in H1.  unfold eval_be' in H1.  simpl in H1.
  unfold bool_fun_zero in H1.  decompose [and] H1.  discriminate.  
  unfold Included in |- *.  unfold In in |- *.  intros.  elim H1.  apply zero_ok.
  intros.  elim H1.  clear H1.
  intros.  split with (Or x0 (ve''_to_be x N)).  unfold bool_expr_to_var_env'' in |- *.
  split.  elim H1.  clear H1.  intros y H00.
  apply Extensionality_Ensembles.  split.  unfold Included in |- *.  unfold In in |- *.
  unfold Evar_env'', eval_be' in |- *.  unfold bool_expr_to_var_env'' in y.
  unfold eval_be', In, Evar_env'' in y.  intros.  simpl in H1.
  elim H1; clear H1; intros H5 H4; elim H4; clear H4; intros H4 H7.
  unfold bool_fun_or in H5.
  elim (orb_prop _ _ H5).  clear H5.  intro.  unfold Add in |- *.
  apply (Union_introl _ A (Singleton var_env'' x) x1).  rewrite <- y.
  unfold In in |- *.  split.  assumption.  split.  assumption.  assumption.  intro.
  clear H5.  unfold Add in |- *.  apply (Union_intror _ A (Singleton var_env'' x) x1).
  replace x with x1.  apply In_singleton.  symmetry  in |- *.
  apply (ve''_to_be_ok1 N x x1).  unfold Included in H3.  unfold In at 2 in H3.
  apply H3.  unfold Add in |- *.  apply Union_intror.  apply In_singleton.  
  unfold bool_expr_to_var_env'' in |- *.  unfold eval_be' in |- *.  split.  assumption.  split.
  assumption.  assumption.  unfold Included in |- *.  intros.  unfold Add in H1.
  elim H1.  intros.  split.  unfold eval_be' in |- *.  simpl in |- *.  unfold bool_fun_or in |- *.
  apply orb_true_intro.  left.  unfold bool_expr_to_var_env'' in y.
  rewrite <- y in H4.  unfold In in H4.  unfold eval_be' in H4.
  exact (proj1 H4).  rewrite <- y in H4.
  unfold bool_expr_to_var_env'' in H4.  unfold In in H4.  unfold In in |- *.
  exact (proj2 H4).  intros.  elim H4.  unfold In in |- *.  split.  unfold eval_be' in |- *.
  simpl in |- *.  unfold bool_fun_or in |- *.  apply orb_true_intro.  right.
  apply (ve''_to_be_ok2 N x).  unfold Included in H3.  unfold In in H3.
  apply H3.  unfold Add in |- *.  apply (Union_intror _ A (Singleton var_env'' x) x).
  apply In_singleton.  apply or_ok.  exact (proj2 H1).  apply ve''_to_be_ok3.
  apply le_n.  unfold Included in |- *.  intros.  apply H3.  unfold Add in |- *.
  apply Union_introl.  assumption.
Qed.

Lemma env_to_be_lemma1 :
 forall S : Ensemble var_env'',
 Included _ S (Evar_env'' 0 N) ->
 exists be : bool_expr,
   bool_expr_to_var_env'' 0 N be = S /\ be_ok (var_lu 0 N) be.
Proof.
  intros.  apply env_to_be_lemma. 
  apply Finite_downward_closed with (A := Evar_env'' 0 N).
  apply Eenv''_var''finite.  assumption.  assumption.
Qed.

Lemma muevaleqset :
 forall (te : trans_env) (ste : set_tenv),
 ad_to_be_ok (var_lu 0 (2 * N)) te ->
 te_ste_ok te ste ->
 forall (f : mu_form) (re : rel_env) (sre : set_renv),
 f_ok f ->
 mu_form_ap_ok (var_lu 0 N) f ->
 ad_to_be_ok (var_lu 0 N) re ->
 re_sre_ok re sre ->
 mu_form2set ste f sre = bool_expr_to_var_env'' 0 N (mu_eval N te f re).
Proof.
  intro.  intro.  intro te_ok.  intro.  simple induction f.  simpl in |- *.
  unfold set_0, bool_expr_to_var_env'' in |- *.  intros.  apply Extensionality_Ensembles.
  split.  auto with sets.  unfold Included in |- *.  unfold eval_be' in |- *.  simpl in |- *.
  unfold In, bool_fun_zero in |- *.  intros.  decompose [and] H4.  discriminate.  simpl in |- *.
  intros.  apply Extensionality_Ensembles.  unfold set_1 in |- *.  simpl in |- *.  split.
  unfold Included in |- *.  unfold Evar_env'', bool_expr_to_var_env'' in |- *.  unfold In in |- *.
  unfold eval_be' in |- *.  simpl in |- *.  unfold Evar_env'' in |- *.  tauto.  
  unfold bool_expr_to_var_env'', Evar_env'' in |- *.  unfold Included in |- *.  unfold eval_be' in |- *.
  simpl in |- *.  unfold In in |- *.  tauto.  simpl in |- *.  unfold set_ap in |- *.
  unfold bool_expr_to_var_env'' in |- *.  unfold eval_be' in |- *.  simpl in |- *.  unfold bool_fun_var in |- *.
  unfold In in |- *.  unfold Evar_env'' in |- *.  unfold set_1 in |- *.  unfold Evar_env'' in |- *.  intros.
  apply Extensionality_Ensembles.  split.  unfold Included in |- *.  unfold In in |- *.  intros.
  elim H4; intros H5 H7; elim H5; clear H5; intros H5 H8.

  split.  unfold var_env'_to_env, var_env''_to_env' in |- *.
  rewrite (N_of_nat_of_N a).  assumption.  split.  assumption.  assumption.
  unfold var_env'_to_env, var_env''_to_env' in |- *.  rewrite (N_of_nat_of_N a).
  unfold Included in |- *.  unfold In in |- *.  tauto.
  simpl in |- *.  unfold re_sre_ok in |- *.  intros.  symmetry  in |- *.  apply H3.  
  intros.  simpl in |- *.  inversion H2.  rewrite (H0 re sre).
  unfold set_neg, bool_expr_to_var_env'' in |- *.  unfold Setminus in |- *.  unfold eval_be' in |- *.
  simpl in |- *.  apply Extensionality_Ensembles.  unfold Same_set in |- *.  unfold Included in |- *.
  unfold In in |- *.  unfold var_env'_to_env, var_env''_to_env' in |- *.  unfold set_1 in |- *.
  unfold Evar_env'' in |- *.  split.  intros.
  elim H7; intros H8 H10; elim H8; clear H8; intros H8 H11.

  unfold bool_fun_neg in |- *.
  split.  elim
   (sumbool_of_bool
      (bool_fun_of_bool_expr (mu_eval N te m re)
         (fun x0 : BDDvar => in_dom unit (N_of_nat (nat_of_N x0)) x))).
  intro y.  rewrite y in H10.  elim H10.  tauto.  intro y.  rewrite y.  reflexivity.
  split.  assumption.  assumption.  unfold bool_fun_neg in |- *.  intros.
  elim H7; intros H9 H8; elim H8; clear H8; intros H8 H11.
  split.  split.  assumption.  assumption.  
  unfold not in |- *; intro.
  elim H10; intros H13 H12; elim H12; clear H12; intros H12 H15.

  rewrite H13 in H9.  discriminate.
  inversion H1.  assumption.  assumption.  assumption.  assumption.  
  simpl in |- *.  intros.  inversion H3.  rewrite (H0 re sre).  rewrite (H1 re sre).
  unfold set_and, bool_expr_to_var_env'' in |- *.  unfold eval_be' in |- *.
  unfold var_env'_to_env, var_env''_to_env' in |- *.  apply Extensionality_Ensembles.
  unfold Same_set in |- *.  unfold Included in |- *.  split.  intros.  inversion H10.
  simpl in |- *.  unfold bool_fun_and in |- *.  unfold In in H11, H12.  unfold In in |- *.
  rewrite (proj1 H11).  rewrite (proj1 H12).  split.  reflexivity.  
  exact (proj2 H12).  intros.  simpl in H10.  unfold bool_fun_and in H10.
  unfold In in H10.
  elim H10; clear H10; intros H12 H13.

  elim (andb_prop _ _ H12).
  intros.  apply Intersection_intro.  unfold In in |- *.  rewrite H10.
  split; [ reflexivity | assumption ].  unfold In in |- *.  rewrite H11.
  split; [ reflexivity | assumption ].  inversion H2.  assumption.  assumption.
  assumption.  assumption.  inversion H2.  assumption.  assumption.  assumption.
  assumption.
  simpl in |- *.  intros.  rewrite (H0 re sre).  rewrite (H1 re sre).
  unfold set_or, bool_expr_to_var_env'' in |- *.  unfold eval_be' in |- *.
  unfold var_env'_to_env, var_env''_to_env' in |- *.  apply Extensionality_Ensembles.
  unfold Same_set in |- *.  unfold Included in |- *.  split.  intros.  inversion H6.  unfold In in |- *.
  simpl in |- *.  unfold bool_fun_or in |- *.  unfold In in H7.
  elim H7; intros H10 H11.

  rewrite H10.  auto with bool.  unfold In in |- *.  unfold In in H7.  simpl in |- *.
  unfold bool_fun_or in |- *.
  elim H7; intros H10 H11.
  rewrite H10.  auto with bool.  
  intros.  simpl in H6.  unfold In in H6.  unfold bool_fun_or in H6.
  elim H6; clear H6; intros H8 H9.

  elim (orb_true_elim _ _ H8).  intros y.
  apply Union_introl.  unfold In in |- *.  rewrite y.  auto with bool.  intro y.
  apply Union_intror.  unfold In in |- *.  rewrite y.  auto with bool.  inversion H2.
  assumption.  inversion H3.  assumption.  assumption.  assumption.  
  inversion H2.  assumption.  inversion H3.  assumption.  assumption.  
  assumption.
  simpl in |- *.  intros.  rewrite (H0 re sre).  rewrite (H1 re sre).
  unfold set_impl, bool_expr_to_var_env'' in |- *.  unfold eval_be' in |- *.
  unfold var_env'_to_env, var_env''_to_env' in |- *.  apply Extensionality_Ensembles.
  unfold Same_set in |- *.  unfold Included in |- *.  split.  intros.  unfold In in |- *.  simpl in |- *.
  unfold bool_fun_impl in |- *.  inversion H6.  unfold set_neg in H7.
  unfold Setminus in H7.  unfold In in H7.
  elim H7; intros H10 H11.
  unfold implb in |- *.
  unfold ifb in |- *.  elim
   (sumbool_of_bool
      (bool_fun_of_bool_expr (mu_eval N te m re)
         (fun x1 : BDDvar => in_dom unit (N_of_nat (nat_of_N x1)) x))).
  intro y.  rewrite y in H11.  unfold set_1 in H10.  elim H11.  auto with bool.  
  intro y.  rewrite y.  auto with bool.  unfold In in H7.
  elim H7; intros H10 H11.

  rewrite H10.  unfold implb in |- *.  unfold ifb in |- *.
  elim
   (bool_fun_of_bool_expr (mu_eval N te m re)
      (fun x1 : BDDvar => in_dom unit (N_of_nat (nat_of_N x1)) x));
   auto with bool.  unfold set_or, set_neg in |- *.  unfold Setminus in |- *.  simpl in |- *.
  unfold bool_fun_impl in |- *.  unfold set_1 in |- *.  intros.  unfold In in H6.
  elim H6; clear H6; intros H8 H9.

  unfold implb in H8.  unfold ifb in H8.
  elim
   (sumbool_of_bool
      (bool_fun_of_bool_expr (mu_eval N te m re)
         (fun x0 : BDDvar => in_dom unit (N_of_nat (nat_of_N x0)) x))).
  intro y.  rewrite y in H8.  apply Union_intror.  unfold In in |- *.  rewrite H8.
  auto with bool.  intro y.  apply Union_introl.  unfold In in |- *.  split.  assumption.
  unfold not in |- *; intro.
  elim H6; intros H10 H11.

  rewrite y in H10.  discriminate.  
  inversion H2.  assumption.  inversion H3.  assumption.  assumption.  
  assumption.  inversion H2.  assumption.  inversion H3.  assumption.  
  assumption.  assumption.  
  simpl in |- *.  intros.  rewrite (H0 re sre).  rewrite (H1 re sre).
  unfold set_iff, bool_expr_to_var_env'' in |- *.  unfold eval_be' in |- *.
  unfold var_env'_to_env, var_env''_to_env' in |- *.  unfold set_and, set_impl in |- *.
  apply Extensionality_Ensembles.  split.  unfold Included in |- *.  intros.  unfold In in |- *.
  simpl in |- *.  unfold bool_fun_iff in |- *.  inversion H6.  clear H6.
  unfold set_or, set_neg in H7.  unfold Setminus in H7.
  unfold set_or, set_neg in H8.  unfold Setminus in H8.  unfold set_1 in H7.
  unfold set_1 in H8.  inversion H7.  unfold In in H6.  clear H7.
  elim H6; clear H6; intros H11 H12.

  split.  inversion H8.  clear H8.
  unfold In in H6.
  elim H6; clear H6; intros H13 H14.

  replace
   (bool_fun_of_bool_expr (mu_eval N te m re)
      (fun x0 : BDDvar => in_dom unit (N_of_nat (nat_of_N x0)) x)) with
   false.
  replace
   (bool_fun_of_bool_expr (mu_eval N te m0 re)
      (fun x0 : BDDvar => in_dom unit (N_of_nat (nat_of_N x0)) x)) with
   false.
  reflexivity.  symmetry  in |- *.  apply not_true_is_false.
  exact (fun x => H14 (conj x H13)).  symmetry  in |- *.  apply not_true_is_false.
  exact (fun x => H12 (conj x H13)).  unfold In in H6.
  elim H6; intros H14 H15.
  rewrite H14 in H12.  elim H12; auto with bool.  assumption.  unfold In in H6.
  elim H6; clear H6; intros H12 H13.
  inversion H8.  clear H8.  unfold In in H6.
  elim H6; clear H6; intros H14 H15.
  rewrite H12 in H15.  elim H15; auto with bool.
  unfold In in H6.
  elim H6; intros H15 H16.

  rewrite H12.  rewrite H15.  split.
  reflexivity.  assumption.  unfold Included in |- *.  intros.  unfold In in H6.
  simpl in H6.  unfold bool_fun_iff in H6.
  elim H6; intros H8 H9.
  elim
   (sumbool_of_bool
      (bool_fun_of_bool_expr (mu_eval N te m re)
         (fun x0 : BDDvar => in_dom unit (N_of_nat (nat_of_N x0)) x))).
  intro y.  apply Intersection_intro.  unfold set_or, set_neg in |- *.  unfold Setminus in |- *.
  apply Union_intror.  unfold In in |- *.  rewrite (eqb_prop _ _ H8) in y.  rewrite y.
  auto with bool.  unfold set_or, set_neg in |- *.  apply Union_intror.  unfold In in |- *.
  rewrite y.  auto with bool.  intro y.  apply Intersection_intro.
  unfold set_or, set_neg in |- *.  apply Union_introl.  unfold Setminus, In in |- *.  rewrite y.
  unfold set_1 in |- *.  split.  assumption.  unfold not in |- *; intros.  decompose [and] H7.
  discriminate.  unfold set_or, set_neg in |- *.  apply Union_introl.
  unfold Setminus, In in |- *.  unfold set_1 in |- *.  split.  assumption.  
  rewrite <- (eqb_prop _ _ H8).  rewrite y.  unfold not in |- *; intro.
  decompose [and] H7.  discriminate.  inversion H2.  assumption.  inversion H3.
  assumption.  assumption.  assumption.  inversion H2.  assumption.  
  inversion H3.  assumption.  assumption.  assumption.  
  intros.  simpl in |- *.  unfold set_all in |- *.  inversion H1.  inversion H2.
  rewrite (H0 re sre).  apply Extensionality_Ensembles.  split.
  unfold Included in |- *.  intros.  unfold In in |- *.  unfold bool_expr_to_var_env'' in |- *.
  unfold te_ste_ok in H.  unfold In in H11.
  elim H11; clear H11; intros H13 H14.
  unfold set_1 in H13.  split.  apply mu_all_eval_semantics2.
  elim (mu_eval_lemma1 N te te_ok m H6).  intros.  apply H11.  assumption.  
  assumption.  unfold Evar_env'' in H13.  unfold var_env''_to_env' in |- *.  intros.
  apply not_false_is_true.  unfold not in |- *; intro.
  rewrite (proj2 H13 _ H12) in H11.  discriminate.  
  unfold new_t_to_rel in H.  unfold t_to_rel in H.  unfold t_to_rel1 in H.
  intros.  unfold bool_expr_to_var_env'' in H14.
  replace (eval_be' (mu_eval N te m re) ve') with
   (eval_be' (mu_eval N te m re)
      (var_env''_to_env' (var_env'_to_env'' 0 N ve'))).
  elim (H14 (var_env'_to_env'' 0 N ve')).  intros.  apply H15.  clear H14.
  apply (proj1 (H a x (var_env'_to_env'' 0 N ve'))).  rewrite <- H12.  
  split.  apply bool_fun_of_be_ext1.  intros.  unfold ad_to_be_ok in te_ok.
  cut (var_lu 0 (2 * N) x0 = true).  intro.  unfold var_lu in H15.
  elim (andb_prop _ _ H15).  intros.  unfold var_env'_or in |- *.
  unfold var_env'_to_env'' in |- *.  unfold var_env''_to_env' at 2 in |- *.
  elim (var_env'_to_var_env''_lemma2 (N - 0) 0 N ve' (refl_equal (N - 0))).
  intros x1 y.
  elim y; intros H19 H20.

  elim (var_env''_to_env' x (nat_of_N x0)).
  reflexivity.  simpl in |- *.  unfold var_env'_dash in |- *.
  elim (sumbool_of_bool (leb N (nat_of_N x0))).  intro y0.  rewrite y0.
  rewrite (H20 (N_of_nat (nat_of_N x0 - N))).
  rewrite (nat_of_N_of_nat (nat_of_N x0 - N)).  reflexivity.  
  unfold var_lu in |- *.  apply andb_true_intro.  split.  auto with arith.  
  rewrite (nat_of_N_of_nat (nat_of_N x0 - N)).  apply leb_correct.
  rewrite (minus_Sn_m (nat_of_N x0) N).  cut (N = 2 * N - N).  intro.
  replace (S (nat_of_N x0) - N <= N) with
   (S (nat_of_N x0) - N <= 2 * N - N).
  apply le_minus_le1.  apply leb_complete.  assumption.  unfold mult at 1 in |- *.
  replace (N + (N + 0) - N) with N.  reflexivity.  simpl in |- *.
  replace (N + 0) with N.  apply plus_minus.  reflexivity.  
  auto with arith.  apply leb_complete; assumption.  intro y0.  rewrite y0.
  reflexivity.  apply be_ok_be_x_free with (be := te t).  apply te_ok.  
  rewrite H5.  assumption.  
  unfold rel_1 in |- *.  unfold set_1 in |- *.  split.  assumption.  unfold In in |- *.
  unfold Evar_env'' in |- *.  unfold var_env'_to_env'' in |- *.
  elim (var_env'_to_var_env''_lemma2 (N - 0) 0 N ve' (refl_equal (N - 0))).
  unfold Evar_env'' in |- *.  unfold In in |- *.  intros x0 y.
  elim y; intros H14 H16; elim H14; clear H14; intros H14 H17.

  split.
  assumption.  assumption.  apply bool_fun_of_be_ext1.  intros.
  elim (mu_eval_lemma1 N te te_ok m H6 H9).  intros.  clear H17.
  rewrite (var_env'_to_env''_to_env' 0 N ve' x0).  reflexivity.  
  apply be_ok_be_x_free with (be := mu_eval N te m re).  apply H16.  assumption.
  assumption.  assumption.  unfold Included in |- *.  unfold In in |- *.  intros.
  unfold bool_expr_to_var_env'' in H11.
  elim H11; clear H11; intros H13 H14. 

  split.  unfold set_1 in |- *.  assumption.  intros.  unfold te_ste_ok in H.
  unfold bool_expr_to_var_env'' in |- *.  split.
  apply
   mu_all_eval_semantics1
    with (N := N) (t := te t) (ve := var_env''_to_env' x).
  elim (mu_eval_lemma1 N te te_ok m H6).  intros.  apply H12.  assumption.  
  assumption.  intros.  unfold Evar_env'', In in H14.
  unfold var_env''_to_env' in H12.
  elim H14; intros H16 H17.  
  unfold var_lu in |- *.
  rewrite (nat_of_N_of_nat n).  apply andb_true_intro.  split.
  auto with arith.  unfold var_lu in H17.
  cut (leb 0 n && leb (S n) N = true).  intros.
  elim (andb_prop _ _ H15).  intros.  assumption.  apply not_false_is_true.
  unfold not in |- *.  replace n with (nat_of_N (N_of_nat n)).  intro.
  rewrite (H17 _ H15) in H12.  discriminate.  apply nat_of_N_of_nat.  
  rewrite H5.  assumption.  unfold new_t_to_rel in H.
  elim (proj2 (H a x t1) H11).  intros.  unfold rel_1 in H15.
  unfold set_1 in H15.  unfold Evar_env'' in H15.  unfold In in H15.
  unfold var_env''_to_env' in H16.
  elim H15; intros H17 H18; elim H17; clear H17; intros H17 H20; elim H18;
   clear H18; intros H18 H21.

  apply not_false_is_true.  unfold not in |- *; intro.  rewrite (H21 _ H19) in H16.
  discriminate.  unfold new_t_to_rel in H.  unfold t_to_rel in H.
  unfold t_to_rel1 in H.  elim (H t x t1).  intros.  rewrite <- H5 in H11.
  elim (H15 H11).  intros.  assumption.  elim (H t x t1).  intros.
  rewrite <- H5 in H11.  elim (H15 H11).  intros.  unfold rel_1, set_1 in H17.
  exact (proj2 H17).  assumption.  assumption.  assumption.  assumption.  
  intros.  simpl in |- *.    inversion H1.  inversion H2.
  rewrite (H0 re sre).  apply Extensionality_Ensembles.  split.
  unfold Included in |- *.  intros.  unfold In in |- *.  unfold bool_expr_to_var_env'' in |- *.
  unfold te_ste_ok in H.  unfold In in H11.    elim H11.
  intros.  elim (proj2 (H a s t1) H13).  intros.  unfold rel_1, set_1 in H16.
  split.  apply mu_ex_eval_semantics2.
  elim (mu_eval_lemma1 N te te_ok m H6 H9).  intros.  apply H17.  assumption.  
  unfold set_1, In in H12.  unfold Evar_env'' in H12.  intros.
  unfold var_env''_to_env' in H17.  apply not_false_is_true.  unfold not in |- *; intro.
  rewrite (proj2 H12 _ H18) in H17.  discriminate.  
  split with (var_env''_to_env' t1).  unfold In, Evar_env'' in H16.
  elim H16; intros H17 H18; elim H17; clear H17; intros H17 H20; elim H18;
   clear H18; intros H18 H21.

  split.  intros.  apply not_false_is_true.
  unfold not in |- *; intro.  unfold var_env''_to_env' in H19.
  rewrite (H21 _ H22) in H19.  discriminate.  split.  unfold t_to_rel in H15.
  unfold t_to_rel1 in H15.  assumption.  unfold eval_be' in |- *.  unfold In in H14.
  unfold bool_expr_to_var_env'' in H14.  unfold eval_be' in H14.
  exact (proj1 H14).  exact (proj1 H16).  unfold Included in |- *.  unfold In in |- *.
  unfold bool_expr_to_var_env'' in |- *.  intros.
  elim H11; clear H11; intros H13 H14.

  elim
   mu_ex_eval_semantics1
    with
      (N := N)
      (t := te a)
      (be := mu_eval N te m re)
      (ve := var_env''_to_env' x).
  intros.
  elim H11; clear H11; intros H15 H12; elim H12; clear H12; intros H12 H17.

  cut
   (forall s t0 : var_env'',
    In var_env'' set_1 s ->
    ste a s t0 ->
    In var_env''
      (fun ve : var_env'' =>
       eval_be' (mu_eval N te m re) (var_env''_to_env' ve) = true /\
       In var_env'' (Evar_env'' 0 N) ve) t0 ->
    In var_env''
      (set_ex (ste a)
         (fun ve : var_env'' =>
          eval_be' (mu_eval N te m re) (var_env''_to_env' ve) = true /\
          In var_env'' (Evar_env'' 0 N) ve)) s).
  unfold In in |- *.  intros.  apply H11 with (s := x) (t0 := var_env'_to_env'' 0 N x0).
  unfold set_1 in |- *.  assumption.  unfold te_ste_ok in H.
  apply (proj1 (H a x (var_env'_to_env'' 0 N x0))).  unfold new_t_to_rel in |- *.
  unfold t_to_rel in |- *.  unfold t_to_rel1 in |- *.  split.  rewrite <- H12.
  apply bool_fun_of_be_ext1.  intros.
  unfold var_env'_or, var_env''_to_env', var_env'_dash in |- *.
  rewrite (N_of_nat_of_N x1).  elim (sumbool_of_bool (in_dom unit x1 x)).
  intro y.  rewrite y.  simpl in |- *.  reflexivity.  intro y.  rewrite y.  simpl in |- *.
  elim (sumbool_of_bool (leb N (nat_of_N x1))).  intro y0.  rewrite y0.
  unfold var_env'_to_env'' in |- *.
  elim (var_env'_to_var_env''_lemma2 (N - 0) 0 N x0 (refl_equal (N - 0))).
  intros x2 y1.
  elim y1; intros H19 H20.

  rewrite (H20 (N_of_nat (nat_of_N x1 - N))).
  rewrite (nat_of_N_of_nat (nat_of_N x1 - N)).
  reflexivity.  unfold var_lu in |- *.  apply andb_true_intro.  split.
  apply leb_correct.  apply le_O_n.  
  rewrite (nat_of_N_of_nat (nat_of_N x1 - N)).
  cut (var_lu 0 (2 * N) x1 = true).  intro.  unfold var_lu in H18.
  elim (andb_prop _ _ H18).  intros.  clear H21.  apply leb_correct.
  rewrite (minus_Sn_m (nat_of_N x1) N).
  replace (S (nat_of_N x1) - N <= N) with
   (S (nat_of_N x1) - N <= 2 * N - N).
  apply le_minus_le1.  apply leb_complete.  assumption.  unfold mult at 1 in |- *.
  replace (N + (N + 0) - N) with N.  reflexivity.  simpl in |- *.
  replace (N + 0) with N.  apply plus_minus.  reflexivity.  
  auto with arith.  apply leb_complete; assumption.  
  apply be_ok_be_x_free with (be := te a).  apply te_ok.  assumption.  intro y0.
  rewrite y0.  reflexivity.  unfold rel_1 in |- *.  unfold set_1 in |- *.  split.  assumption.
  unfold var_env'_to_env'' in |- *.
  elim (var_env'_to_var_env''_lemma2 (N - 0) 0 N x0 (refl_equal (N - 0))).
  intros x1 y.  exact (proj1 y).  split.  rewrite <- H17.
  apply bool_fun_of_be_ext1.  intros.  apply var_env'_to_env''_to_env'.
  apply be_ok_be_x_free with (be := mu_eval N te m re).
  elim (mu_eval_lemma1 N te te_ok m H6 H9).  intros.  apply H18.  assumption.  
  assumption.  unfold Evar_env'', var_env'_to_env'' in |- *.
  elim (var_env'_to_var_env''_lemma2 (N - 0) 0 N x0 (refl_equal (N - 0))).
  intros x1 y.  unfold Evar_env'' in y.  unfold In in y.
  elim y; intros H16 H19; elim H16; clear H16; intros H16 H20.

  split.
  assumption.  assumption.  
  exact
   (setex_intro (ste a)
      (fun ve : var_env'' =>
       eval_be' (mu_eval N te m re) (var_env''_to_env' ve) = true /\
       In var_env'' (Evar_env'' 0 N) ve)).
  elim (mu_eval_lemma1 N te te_ok m H6 H9).  intros.  apply H11.  assumption.  
  unfold In, Evar_env'' in H14.
  elim H14; intros H12 H15.

  intros.
  apply not_false_is_true.  unfold not in |- *; intro.  unfold var_env''_to_env' in H11.
  rewrite (H15 _ H16) in H11.  discriminate.  assumption.  assumption.  
  assumption.  assumption.  assumption.  
  intros.  unfold bool_expr_to_var_env'' in |- *.  inversion H1.  inversion H2.
  apply Extensionality_Ensembles.  split.  unfold Included in |- *.  intros.
  simpl in H12.  unfold In in H12.  unfold set_mu in H12.  unfold In in |- *.
  cut (bool_expr_to_var_env'' 0 N (mu_eval N te (mu_mu a m) re) x).
  unfold bool_expr_to_var_env'' in |- *.  trivial.  unfold In in H12.  apply H12.
  unfold state_set in |- *.  unfold set_1, Included in |- *.
  unfold bool_expr_to_var_env'', Evar_env'', In in |- *.  intros.  exact (proj2 H13).
  unfold Included in |- *.  intros.  unfold In in |- *.  unfold In in H13.  
  cut
   (mu_form2set ste m
      (sre_put sre a
         (fun v : var_env'' =>
          bool_expr_to_var_env'' 0 N (mu_eval N te (mu_mu a m) re) v)) x0).
  rewrite
   (H0 (re_put re a (mu_eval N te (mu_mu a m) re))
      (sre_put sre a
         (fun v : var_env'' =>
          bool_expr_to_var_env'' 0 N (mu_eval N te (mu_mu a m) re) v)))
   .
  unfold bool_expr_to_var_env'' in |- *.  intros.
  elim H14; clear H14; intros H16 H17.

  elim (mu_eval_mu_is_lfp N te te_ok a m re).  intros.  unfold fp in H14.
  unfold be_eq in H14.  rewrite (H14 (var_env''_to_env' x0)).  split.  
  assumption.  assumption.  assumption.  assumption.  assumption.  assumption.
  assumption.  unfold ad_to_be_ok in |- *.  intros.  unfold re_put in |- *.
  elim (sumbool_of_bool (Neqb a x1)).  intro y.  rewrite y.
  elim (mu_eval_lemma1 N te te_ok (mu_mu a m)).  intros.  apply H14.
  assumption.  assumption.  assumption.  intro y.  rewrite y.  apply H3.  
  unfold re_sre_ok in |- *.  unfold re_put, sre_put in |- *.  intro.
  elim (sumbool_of_bool (Neqb a P1)).  intro y.  rewrite y.
  unfold bool_expr_to_var_env'' in |- *.  reflexivity.  intro y.  rewrite y.  apply H4. 
  assumption.
  unfold Included in |- *.  unfold In in |- *.  intros.  simpl in |- *.  unfold set_mu in |- *.  intros.
  elim H12; clear H12; intros H16 H17.

  elim (env_to_be_lemma1 X H13).  intro Be.
  intro.  elim H12.  clear H12.  intros y H00.
  rewrite (H0 (re_put re a Be) (sre_put sre a X)) in H14.  simpl in H16.
  elim (mu_eval_lemma1 N te te_ok m).  intros.
  elim H15; intros H19 H18; elim H18; clear H18; intros H18 H21.

  clear H15 H18.  rewrite <- y.  unfold bool_expr_to_var_env'' in |- *.  split.
  cut
   (be_le
      (fst
         (iter2n bool_expr be_eq_dec
            (fun be : bool_expr => mu_eval N te m (re_put re a be)) Zero N))
      Be).
  intro.  unfold be_le in H15.  apply H15.  assumption.  
  apply
   be_le_trans
    with
      (be2 := fst
                (iter2n bool_expr be_eq_dec
                   (fun be : bool_expr => mu_eval N te m (re_put re a be)) Be
                   N)).
  apply
   be_le_trans
    with
      (be2 := be_iter1
                (fun be : bool_expr => mu_eval N te m (re_put re a be)) Zero
                (two_power N)).
  apply be_eq_le.  apply be_iter2n_2n.  intros.  apply H21.
  unfold ad_to_be_eq, re_put in |- *.  intros.  elim (Neqb a x0).  assumption.  
  apply be_eq_refl.  
  apply
   be_le_trans
    with
      (be2 := be_iter1
                (fun be : bool_expr => mu_eval N te m (re_put re a be)) Be
                (two_power N)).
  apply be_iter1_le_preserved.  apply be_le_zero.  intros.
  unfold re_to_be_inc in H19.  apply H19.  assumption.  assumption.  
  apply be_eq_le.  apply be_eq_sym.  apply be_iter2n_2n.  intros.  apply H21.
  unfold ad_to_be_eq, re_put in |- *.  intro.  elim (Neqb a x0).  assumption.  
  apply be_eq_refl.  
  apply
   be_le_trans
    with
      (be2 := be_iter1
                (fun be : bool_expr => mu_eval N te m (re_put re a be)) Be
                (two_power N)).
  apply be_eq_le.  apply be_iter2n_2n.  intros.  apply H21.
  unfold ad_to_be_eq, re_put in |- *.  intro.  elim (Neqb a x0).  assumption.  
  apply be_eq_refl.  
  rewrite
   (be_iter1eq2 (fun be : bool_expr => mu_eval N te m (re_put re a be))
      (two_power N) Be).
  generalize (two_power N).  simple induction n.  simpl in |- *.  apply be_le_refl.  intros.
  simpl in |- *.  apply be_le_trans with (be2 := mu_eval N te m (re_put re a Be)).
  unfold re_to_be_inc in H19.  apply H19.  assumption.  assumption.  
  unfold be_le in |- *.  intro.
  replace (eval_be' (mu_eval N te m (re_put re a Be)) ve) with
   (eval_be' (mu_eval N te m (re_put re a Be))
      (var_env''_to_env' (var_env'_to_env'' 0 N ve))).
  replace (eval_be' Be ve) with
   (eval_be' Be (var_env''_to_env' (var_env'_to_env'' 0 N ve))).
  rewrite <- y in H14.  unfold Included, bool_expr_to_var_env'' in H14.
  unfold In in H14.  intros.  elim (H14 (var_env'_to_env'' 0 N ve)).  intros.
  assumption.  split.  assumption.  unfold var_env'_to_env'' in |- *.
  elim (var_env'_to_var_env''_lemma2 (N - 0) 0 N ve (refl_equal (N - 0))).
  intros x0 y0.  exact (proj1 y0).  apply bool_fun_of_be_ext1.  intros.
  unfold var_env''_to_env', var_env'_to_env'' in |- *.
  elim (var_env'_to_var_env''_lemma2 (N - 0) 0 N ve (refl_equal (N - 0))).
  intros x1 y0.
  elim y0; intros H22 H23.

  rewrite <- (H23 _ (be_ok_be_x_free _ _ H00 _ H18)).
  rewrite (N_of_nat_of_N x0).  reflexivity.  apply bool_fun_of_be_ext1.
  intros.  unfold var_env''_to_env', var_env'_to_env'' in |- *.
  elim (var_env'_to_var_env''_lemma2 (N - 0) 0 N ve (refl_equal (N - 0))).
  intros x1 y0.
  elim y0; intros H22 H23.

  rewrite (N_of_nat_of_N x0).
  rewrite <- (H23 x0).  reflexivity.  
  apply be_ok_be_x_free with (be := mu_eval N te m (re_put re a Be)).
  elim (mu_eval_lemma1 N te te_ok m).  intros.  apply H20.
  unfold ad_to_be_ok, re_put in |- *.  intros.  elim (Neqb a x2).  assumption.  
  apply H3.  assumption.  assumption.  assumption.  assumption.  assumption.
  assumption.  assumption.  assumption.  unfold ad_to_be_ok, re_put in |- *.  intros.
  elim (Neqb a x0).  assumption.  apply H3.  unfold re_sre_ok, re_put, sre_put in |- *.
  intros.  elim (sumbool_of_bool (Neqb a P1)).  intro y0.  rewrite y0.
  assumption.  intro y0.  rewrite y0.  apply H4.  
Qed.

End mu2set.