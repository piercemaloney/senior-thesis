

Require Import Bool.

Require Import Sumbool.

Require Import Arith.

Require Import ZArith NArith Nnat Ndec Ndigits.

From IntMap Require Import Map.

From IntMap Require Import Allmaps.

Require Import List.

Require Import Wf_nat.



Require Import misc.
(* misc:
Require Import Compare.
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import ZArith NArith Nnat Ndec Ndigits.
From IntMap Require Import Allmaps.
Require Import List.

Section BDDmisc.

Definition BDDvar := ad.

Definition BDDcompare (x y : BDDvar) :=
  match x, y with
  | N0, N0 => Datatypes.Eq
  | N0, Npos _ => Datatypes.Lt
  | Npos _, N0 => Datatypes.Gt
  | Npos p1, Npos p2 => Pcompare p1 p2 Datatypes.Eq
  end.

Definition ad_S (a : ad) :=
  match a with
  | N0 => Npos 1
  | Npos p => Npos (Psucc p)
  end.

Definition max (m n : nat) := if leb m n then n else m.

Definition BDDvar_max (x y : BDDvar) := if Nleb x y then y else x.

Inductive no_dup_list (A : Set) : list A -> Prop :=
  | no_dup_nil : no_dup_list A nil
  | no_dup_cons :
      forall (a : A) (l : list A),
      ~ In a l -> no_dup_list _ l -> no_dup_list _ (a :: l).

Lemma ad_S_is_S : forall a : ad, nat_of_N (ad_S a) = S (nat_of_N a).

Lemma relation_sum :
 forall r : Datatypes.comparison,

Lemma BDD_EGAL_complete :
 forall x y : BDDvar, BDDcompare x y = Datatypes.Eq -> x = y.

Lemma BDDcompare_lt :
 forall x y : BDDvar,
 BDDcompare x y = Datatypes.Lt -> nat_of_N x < nat_of_N y.

Lemma BDDlt_compare :
 forall x y : BDDvar,
 nat_of_N x < nat_of_N y -> BDDcompare x y = Datatypes.Lt.

Lemma BDDcompare_trans :
 forall x y z : BDDvar,
 BDDcompare x y = Datatypes.Lt ->

Lemma BDDcompare_sup_inf :
 forall x y : BDDvar,
 BDDcompare x y = Datatypes.Gt -> BDDcompare y x = Datatypes.Lt.

Lemma lt_trans_1 : forall x y z : nat, x < y -> y < S z -> x < z.

Lemma BDDcompare_1 :
 forall x y : BDDvar,
 BDDcompare x y = Datatypes.Lt ->

Lemma andb3_lemma :
 forall b1 b2 b3 : bool,
 b1 && (b2 && b3) = true -> b1 = true /\ b2 = true /\ b3 = true.

Lemma andb3_lemma_1 :
 forall x x0 y y0 z z0 : ad,
 (x, (y, z)) <> (x0, (y0, z0)) ->
 Neqb x x0 && (Neqb y y0 && Neqb z z0) = false.

Lemma ad_S_le_then_neq :
 forall x y : ad, Nleb (ad_S x) y = true -> Neqb x y = false.

Lemma BDD_EGAL_correct : forall x : BDDvar, BDDcompare x x = Datatypes.Eq.

Lemma BDDcompare_inf_sup :
 forall x y : BDDvar,
 BDDcompare x y = Datatypes.Lt -> BDDcompare y x = Datatypes.Gt.

Lemma ad_S_compare :
 forall x y : ad, BDDcompare x y = BDDcompare (ad_S x) (ad_S y).

Lemma prod_sum :
 forall (A B : Set) (p : A * B), exists a : A, (exists b : B, p = (a, b)).

Lemma lt_max_1_2 :
 forall x1 y1 x2 y2 : nat, x1 < x2 -> y1 < y2 -> max x1 y1 < max x2 y2.

Lemma lt_max_1 :
 forall x1 y1 x2 y2 : nat, x1 < x2 -> y1 < x2 -> max x1 y1 < max x2 y2.

Lemma lt_max_2 :
 forall x1 y1 x2 y2 : nat, x1 < y2 -> y1 < y2 -> max x1 y1 < max x2 y2.

Lemma max_x_x_eq_x : forall x : nat, max x x = x.

Lemma BDDvar_le_max_2 : forall x y : BDDvar, Nleb x (BDDvar_max y x) = true.

Lemma BDDvar_max_max :
 forall x y : BDDvar,
 nat_of_N (BDDvar_max x y) = max (nat_of_N x) (nat_of_N y).

Lemma BDDvar_le_max_1 : forall x y : BDDvar, Nleb x (BDDvar_max x y) = true.

Lemma BDDvar_max_inf :
 forall x y : BDDvar, BDDcompare x y = Datatypes.Lt -> BDDvar_max x y = y.

Lemma BDDvar_max_comm : forall x y : BDDvar, BDDvar_max x y = BDDvar_max y x.

Lemma nat_gt_1_lemma : forall n : nat, n <> 0 -> n <> 1 -> 2 <= n.

Lemma ad_gt_1_lemma :
 forall x : ad, x <> N0 -> x <> Npos 1 -> Nleb (Npos 2) x = true.

Lemma Nltb_lebmma :
 forall a b : ad, Nleb a b = false -> Nleb (ad_S b) a = true.

Lemma eq_ad_S_eq :
 forall a b : ad, Neqb (ad_S a) (ad_S b) = true -> Neqb a b = true.

Lemma ad_S_neq_N0 : forall a : ad, Neqb (ad_S a) N0 = false.

Lemma list_sum :
 forall (A : Set) (l : list A),
 l = nil \/ (exists a : A, (exists l' : list A, l = a :: l')).

Lemma no_dup_sum :
 forall (A : Set) (l : list A) (H : no_dup_list _ l),
 l = nil \/
 (exists a : A,
    (exists l0 : list A, ~ In a l0 /\ no_dup_list _ l0 /\ l = a :: l0)).

Lemma no_dup_cons_no_dup :
 forall (A : Set) (l : list A) (a : A),
 no_dup_list _ (a :: l) -> no_dup_list _ l.

Lemma no_dup_cons_no_in :
 forall (A : Set) (l : list A) (a : A), no_dup_list _ (a :: l) -> ~ In a l.

End BDDmisc. *)

Require Import bool_fun.
(* bool_fun:
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import ZArith NArith Nnat Ndec Ndigits.
From IntMap Require Import Allmaps.

Require Import misc.

Section Bool_fun.

Definition var_env := BDDvar -> bool.

Definition bool_fun := var_env -> bool.

Definition bool_fun_eq (bf1 bf2 : bool_fun) :=
  forall vb : var_env, bf1 vb = bf2 vb.

Definition bool_fun_zero (vb : var_env) := false.

Definition bool_fun_one (vb : var_env) := true.

Definition bool_fun_neg (bf : bool_fun) : bool_fun :=
  fun vb : var_env => negb (bf vb).

Definition bool_fun_or (bf1 bf2 : bool_fun) : bool_fun :=
  fun vb : var_env => bf1 vb || bf2 vb.

Definition bool_fun_and (bf1 bf2 : bool_fun) : bool_fun :=
  fun vb : var_env => bf1 vb && bf2 vb.

Definition bool_fun_impl (bf1 bf2 : bool_fun) : bool_fun :=
  fun vb : var_env => implb (bf1 vb) (bf2 vb).

Definition bool_fun_iff (bf1 bf2 : bool_fun) : bool_fun :=
  fun vb : var_env => eqb (bf1 vb) (bf2 vb).

Definition bool_fun_if (x : BDDvar) (bf1 bf2 : bool_fun) : bool_fun :=
  fun vb : var_env => ifb (vb x) (bf1 vb) (bf2 vb). 

Definition bool_fun_var (x : BDDvar) : bool_fun := fun vb : var_env => vb x.

Definition augment (vb : var_env) (x : BDDvar) (b : bool) : var_env :=
  fun y : BDDvar => if Neqb x y then b else vb y.

Definition bool_fun_restrict (bf : bool_fun) (x : BDDvar) 
  (b : bool) : bool_fun := fun vb : var_env => bf (augment vb x b).

Definition bool_fun_independent (bf : bool_fun) (x : BDDvar) :=
  forall b : bool, bool_fun_eq (bool_fun_restrict bf x b) bf.

Definition bool_fun_forall (x : BDDvar) (bf : bool_fun) :=
  bool_fun_and (bool_fun_restrict bf x true) (bool_fun_restrict bf x false).

Definition bool_fun_ex (x : BDDvar) (bf : bool_fun) :=
  bool_fun_or (bool_fun_restrict bf x true) (bool_fun_restrict bf x false).

Definition bool_fun_ext (bf : bool_fun) :=
  forall vb vb' : var_env,
  (forall x : BDDvar, vb x = vb' x) -> bf vb = bf vb'.

Inductive bool_expr : Set :=
  | Zero : bool_expr
  | One : bool_expr
  | Var : BDDvar -> bool_expr
  | Neg : bool_expr -> bool_expr
  | Or : bool_expr -> bool_expr -> bool_expr
  | ANd : bool_expr -> bool_expr -> bool_expr
  | Impl : bool_expr -> bool_expr -> bool_expr
  | Iff : bool_expr -> bool_expr -> bool_expr.

Fixpoint bool_fun_of_bool_expr (be : bool_expr) : bool_fun :=
  match be with
  | Zero => bool_fun_zero
  | One => bool_fun_one
  | Var x => bool_fun_var x
  | Neg be' => bool_fun_neg (bool_fun_of_bool_expr be')
  | Or be1 be2 =>
      bool_fun_or (bool_fun_of_bool_expr be1) (bool_fun_of_bool_expr be2)
  | ANd be1 be2 =>
      bool_fun_and (bool_fun_of_bool_expr be1) (bool_fun_of_bool_expr be2)
  | Impl be1 be2 =>
      bool_fun_impl (bool_fun_of_bool_expr be1) (bool_fun_of_bool_expr be2)
  | Iff be1 be2 =>
      bool_fun_iff (bool_fun_of_bool_expr be1) (bool_fun_of_bool_expr be2)
  end.

Lemma bool_fun_eq_refl : forall bf : bool_fun, bool_fun_eq bf bf.

Lemma bool_fun_eq_sym :
 forall bf1 bf2 : bool_fun, bool_fun_eq bf1 bf2 -> bool_fun_eq bf2 bf1.

Lemma bool_fun_eq_trans :
 forall bf1 bf2 bf3 : bool_fun,
 bool_fun_eq bf1 bf2 -> bool_fun_eq bf2 bf3 -> bool_fun_eq bf1 bf3.

Lemma bool_fun_neg_preserves_eq :
 forall bf1 bf2 : bool_fun,
 bool_fun_eq bf1 bf2 -> bool_fun_eq (bool_fun_neg bf1) (bool_fun_neg bf2).

Lemma bool_fun_or_preserves_eq :
 forall bf1 bf1' bf2 bf2' : bool_fun,
 bool_fun_eq bf1 bf1' ->
 bool_fun_eq bf2 bf2' ->
 bool_fun_eq (bool_fun_or bf1 bf2) (bool_fun_or bf1' bf2').

Lemma bool_fun_if_preserves_eq :
 forall (x : BDDvar) (bf1 bf2 bf1' bf2' : bool_fun),
 bool_fun_eq bf1 bf1' ->
 bool_fun_eq bf2 bf2' ->
 bool_fun_eq (bool_fun_if x bf1 bf2) (bool_fun_if x bf1' bf2').

Lemma bool_fun_and_preserves_eq :
 forall bf1 bf1' bf2 bf2' : bool_fun,
 bool_fun_eq bf1 bf1' ->
 bool_fun_eq bf2 bf2' ->
 bool_fun_eq (bool_fun_and bf1 bf2) (bool_fun_and bf1' bf2').

Lemma bool_fun_impl_preserves_eq :
 forall bf1 bf1' bf2 bf2' : bool_fun,
 bool_fun_eq bf1 bf1' ->
 bool_fun_eq bf2 bf2' ->
 bool_fun_eq (bool_fun_impl bf1 bf2) (bool_fun_impl bf1' bf2').

Lemma bool_fun_iff_preserves_eq :
 forall bf1 bf1' bf2 bf2' : bool_fun,
 bool_fun_eq bf1 bf1' ->
 bool_fun_eq bf2 bf2' ->
 bool_fun_eq (bool_fun_iff bf1 bf2) (bool_fun_iff bf1' bf2').

Lemma bool_fun_forall_preserves_eq :
 forall (bf1 bf2 : bool_fun) (x : BDDvar),
 bool_fun_eq bf1 bf2 ->
 bool_fun_eq (bool_fun_forall x bf1) (bool_fun_forall x bf2).

Lemma bool_fun_ex_preserves_eq :
 forall (bf1 bf2 : bool_fun) (x : BDDvar),
 bool_fun_eq bf1 bf2 -> bool_fun_eq (bool_fun_ex x bf1) (bool_fun_ex x bf2).

Lemma bool_fun_neg_zero :
 bool_fun_eq (bool_fun_neg bool_fun_zero) bool_fun_one.

Lemma bool_fun_neg_one :
 bool_fun_eq (bool_fun_neg bool_fun_one) bool_fun_zero.

Lemma bool_fun_and_lemma :
 forall bf1 bf2 : bool_fun,
 bool_fun_eq (bool_fun_and bf1 bf2)
   (bool_fun_neg (bool_fun_or (bool_fun_neg bf1) (bool_fun_neg bf2))).

Lemma bool_fun_impl_lemma :
 forall bf1 bf2 : bool_fun,
 bool_fun_eq (bool_fun_impl bf1 bf2) (bool_fun_or (bool_fun_neg bf1) bf2).

Lemma bool_fun_iff_lemma :
 forall bf1 bf2 : bool_fun,
 bool_fun_eq (bool_fun_iff bf1 bf2)
   (bool_fun_impl (bool_fun_or bf1 bf2) (bool_fun_and bf1 bf2)).

Lemma bool_fun_ex_lemma :
 forall (bf : bool_fun) (x : BDDvar),
 bool_fun_eq (bool_fun_ex x bf)
   (bool_fun_neg (bool_fun_forall x (bool_fun_neg bf))).

Lemma bool_fun_var_lemma :
 forall x : BDDvar,
 bool_fun_eq (bool_fun_var x) (bool_fun_if x bool_fun_one bool_fun_zero).

Lemma bool_fun_eq_neg_eq :
 forall bf1 bf2 : bool_fun,
 bool_fun_eq (bool_fun_neg bf1) (bool_fun_neg bf2) -> bool_fun_eq bf1 bf2.

Lemma bool_fun_neg_orthogonal :
 forall (x : BDDvar) (bf1 bf2 : bool_fun),
 bool_fun_eq (bool_fun_neg (bool_fun_if x bf1 bf2))
   (bool_fun_if x (bool_fun_neg bf1) (bool_fun_neg bf2)).

Lemma bool_fun_or_zero :
 forall bf : bool_fun, bool_fun_eq (bool_fun_or bf bool_fun_zero) bf.

Lemma bool_fun_or_one :
 forall bf : bool_fun, bool_fun_eq (bool_fun_or bf bool_fun_one) bool_fun_one.

Lemma bool_fun_or_comm :
 forall bf1 bf2 : bool_fun,
 bool_fun_eq (bool_fun_or bf1 bf2) (bool_fun_or bf2 bf1).

Lemma bool_fun_and_comm :
 forall bf1 bf2 : bool_fun,
 bool_fun_eq (bool_fun_and bf1 bf2) (bool_fun_and bf2 bf1).

Lemma bool_fun_and_idempotent :
 forall bf : bool_fun, bool_fun_eq (bool_fun_and bf bf) bf.

Lemma bool_fun_or_orthogonal :
 forall (x : BDDvar) (bf1 bf2 bf1' bf2' : bool_fun),
 bool_fun_eq (bool_fun_or (bool_fun_if x bf1 bf2) (bool_fun_if x bf1' bf2'))
   (bool_fun_if x (bool_fun_or bf1 bf1') (bool_fun_or bf2 bf2')).

Lemma bool_fun_or_orthogonal_right :
 forall (x : BDDvar) (bf bf1' bf2' : bool_fun),
 bool_fun_eq (bool_fun_or bf (bool_fun_if x bf1' bf2'))
   (bool_fun_if x (bool_fun_or bf bf1') (bool_fun_or bf bf2')).

Lemma bool_fun_or_orthogonal_left :
 forall (x : BDDvar) (bf1 bf2 bf' : bool_fun),
 bool_fun_eq (bool_fun_or (bool_fun_if x bf1 bf2) bf')
   (bool_fun_if x (bool_fun_or bf1 bf') (bool_fun_or bf2 bf')).

Lemma bool_fun_and_orthogonal :
 forall (x : BDDvar) (bf1 bf2 bf1' bf2' : bool_fun),
 bool_fun_eq (bool_fun_and (bool_fun_if x bf1 bf2) (bool_fun_if x bf1' bf2'))
   (bool_fun_if x (bool_fun_and bf1 bf1') (bool_fun_and bf2 bf2')).

Lemma bool_fun_forall_independent :
 forall (x : BDDvar) (bf : bool_fun),
 bool_fun_independent bf x -> bool_fun_eq (bool_fun_forall x bf) bf.

Lemma bool_fun_forall_zero :
 forall x : BDDvar,
 bool_fun_eq (bool_fun_forall x bool_fun_zero) bool_fun_zero.

Lemma bool_fun_forall_one :
 forall x : BDDvar, bool_fun_eq (bool_fun_forall x bool_fun_one) bool_fun_one.

Lemma bool_fun_restrict_zero :
 forall (x : BDDvar) (b : bool),
 bool_fun_eq (bool_fun_restrict bool_fun_zero x b) bool_fun_zero.

Lemma bool_fun_restrict_one :
 forall (x : BDDvar) (b : bool),
 bool_fun_eq (bool_fun_restrict bool_fun_one x b) bool_fun_one.

Lemma bool_fun_restrict_preserves_eq :
 forall (bf1 bf2 : bool_fun) (x : BDDvar) (b : bool),
 bool_fun_eq bf1 bf2 ->
 bool_fun_eq (bool_fun_restrict bf1 x b) (bool_fun_restrict bf2 x b).

Lemma bool_fun_independent_zero :
 forall x : BDDvar, bool_fun_independent bool_fun_zero x.

Lemma bool_fun_independent_one :
 forall x : BDDvar, bool_fun_independent bool_fun_one x.

Lemma bool_fun_eq_independent :
 forall (bf1 bf2 : bool_fun) (x : BDDvar),
 bool_fun_eq bf1 bf2 ->
 bool_fun_independent bf1 x -> bool_fun_independent bf2 x.

Lemma bool_fun_if_restrict_true :
 forall (bf1 bf2 : bool_fun) (x : BDDvar),
 bool_fun_eq (bool_fun_restrict (bool_fun_if x bf1 bf2) x true)
   (bool_fun_restrict bf1 x true).

Lemma bool_fun_if_restrict_false :
 forall (bf1 bf2 : bool_fun) (x : BDDvar),
 bool_fun_eq (bool_fun_restrict (bool_fun_if x bf1 bf2) x false)
   (bool_fun_restrict bf2 x false).

Lemma bool_fun_if_restrict :
 forall (bf1 bf2 : bool_fun) (x y : BDDvar) (b : bool),
 Neqb x y = false ->
 bool_fun_eq (bool_fun_restrict (bool_fun_if x bf1 bf2) y b)
   (bool_fun_if x (bool_fun_restrict bf1 y b) (bool_fun_restrict bf2 y b)).

Lemma bool_fun_if_restrict_true_independent :
 forall (bf1 bf2 : bool_fun) (x : BDDvar),
 bool_fun_independent bf1 x ->
 bool_fun_eq (bool_fun_restrict (bool_fun_if x bf1 bf2) x true) bf1.

Lemma bool_fun_if_restrict_false_independent :
 forall (bf1 bf2 : bool_fun) (x : BDDvar),
 bool_fun_independent bf2 x ->
 bool_fun_eq (bool_fun_restrict (bool_fun_if x bf1 bf2) x false) bf2.

Lemma bool_fun_forall_orthogonal :
 forall (x u : BDDvar) (bf1 bf2 : bool_fun),
 Neqb x u = false ->
 bool_fun_eq (bool_fun_forall u (bool_fun_if x bf1 bf2))
   (bool_fun_if x (bool_fun_forall u bf1) (bool_fun_forall u bf2)).

Lemma bool_fun_independent_if :
 forall (x y : BDDvar) (bf1 bf2 : bool_fun),
 bool_fun_independent bf1 x ->
 bool_fun_independent bf2 x ->
 Neqb x y = false -> bool_fun_independent (bool_fun_if y bf1 bf2) x.

Lemma bool_fun_forall_if_egal :
 forall (x : BDDvar) (bf1 bf2 : bool_fun),
 bool_fun_independent bf1 x ->
 bool_fun_independent bf2 x ->
 bool_fun_eq (bool_fun_forall x (bool_fun_if x bf1 bf2))
   (bool_fun_and bf1 bf2).

Lemma bool_fun_if_eq_1 :
 forall (bf1 bf2 : bool_fun) (x : BDDvar),
 bool_fun_eq bf1 bf2 -> bool_fun_eq (bool_fun_if x bf1 bf2) bf1.

Lemma bool_fun_if_eq_2 :
 forall (bf1 bf2 : bool_fun) (x : BDDvar),
 bool_fun_eq bf1 bf2 -> bool_fun_eq (bool_fun_if x bf1 bf2) bf2.

Lemma bool_fun_ext_zero : bool_fun_ext bool_fun_zero.

Lemma bool_fun_ext_one : bool_fun_ext bool_fun_one.

Lemma bool_fun_ext_if :
 forall (bf1 bf2 : bool_fun) (x : BDDvar),
 bool_fun_ext bf1 -> bool_fun_ext bf2 -> bool_fun_ext (bool_fun_if x bf1 bf2).

End Bool_fun. *)

Require Import config.
(* config:
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import ZArith NArith Nnat Ndec Ndigits.
From IntMap Require Import Map.
From IntMap Require Import Allmaps.
Require Import Wf_nat.
Require Import List.

Require Import misc.
Require Import bool_fun.
Require Import myMap.

Section BDD_config_1.

Definition BDDzero := N0.
Definition BDDone := Npos 1.
Definition BDDstate := Map (BDDvar * (ad * ad)).
Definition BDDsharing_map := Map (Map (Map ad)).
Definition BDDfree_list := list ad.
Definition BDDneg_memo := Map ad.
Definition BDDor_memo := Map (Map ad).
Definition BDDuniv_memo := Map (Map ad).
Definition BDDconfig :=
  (BDDstate *
   (BDDsharing_map *
    (BDDfree_list * (ad * (BDDneg_memo * (BDDor_memo * BDDuniv_memo))))))%type.

Definition initBDDstate := newMap (BDDvar * (ad * ad)).
Definition initBDDsharing_map := newMap (Map (Map ad)).
Definition initBDDfree_list := nil (A:=ad).
Definition initBDDneg_memo := newMap ad.
Definition initBDDor_memo := newMap (Map ad).
Definition initBDDuniv_memo := newMap (Map ad).
Definition initBDDconfig :=
  (initBDDstate,
  (initBDDsharing_map,
  (initBDDfree_list,
  (Npos 2, (initBDDneg_memo, (initBDDor_memo, initBDDuniv_memo)))))).

Definition bs_node_height (bs : BDDstate) (node : ad) :=
  match MapGet _ bs node with
  | None => N0
  | Some (x, (l, r)) => ad_S x
  end.

Definition node_height (cfg : BDDconfig) (node : ad) :=
  bs_node_height (fst cfg) node.

Fixpoint bool_fun_of_BDD_1 (bs : BDDstate) (node : ad) 
 (bound : nat) {struct bound} : bool_fun :=
  match bound with
  | O =>   bool_fun_zero
  | S bound' =>
      match MapGet _ bs node with
      | None => if Neqb node BDDzero then bool_fun_zero else bool_fun_one
      | Some (x, (l, r)) =>
          bool_fun_if x (bool_fun_of_BDD_1 bs r bound')
            (bool_fun_of_BDD_1 bs l bound')
      end
  end.

Definition bool_fun_of_BDD_bs (bs : BDDstate) (node : ad) :=
  bool_fun_of_BDD_1 bs node (S (nat_of_N (bs_node_height bs node))).

Definition bool_fun_of_BDD (cfg : BDDconfig) := bool_fun_of_BDD_bs (fst cfg).

Definition nodes_preserved_bs (bs bs' : BDDstate) :=
  forall (x : BDDvar) (l r node : ad),
  MapGet _ bs node = Some (x, (l, r)) ->
  MapGet _ bs' node = Some (x, (l, r)).

Definition nodes_preserved (cfg cfg' : BDDconfig) :=
  nodes_preserved_bs (fst cfg) (fst cfg').

Inductive nodes_reachable (bs : BDDstate) : ad -> ad -> Prop :=
  | nodes_reachable_0 : forall node : ad, nodes_reachable bs node node
  | nodes_reachable_1 :
      forall (node node' l r : ad) (x : BDDvar),
      MapGet _ bs node = Some (x, (l, r)) ->
      nodes_reachable bs l node' -> nodes_reachable bs node node'
  | nodes_reachable_2 :
      forall (node node' l r : ad) (x : BDDvar),
      MapGet _ bs node = Some (x, (l, r)) ->
      nodes_reachable bs r node' -> nodes_reachable bs node node'.

Definition node_preserved_bs (bs bs' : BDDstate) (node : ad) :=
  forall (x : BDDvar) (l r node' : ad),
  nodes_reachable bs node node' ->
  MapGet _ bs node' = Some (x, (l, r)) ->
  MapGet _ bs' node' = Some (x, (l, r)).

Definition node_preserved (cfg cfg' : BDDconfig) :=
  node_preserved_bs (fst cfg) (fst cfg').

Definition used_node_bs (bs : BDDstate) (ul : list ad) 
  (node : ad) :=
  exists node' : ad, In node' ul /\ nodes_reachable bs node' node. 

Definition used_node'_bs (bs : BDDstate) (ul : list ad) 
  (node : ad) := node = BDDzero \/ node = BDDone \/ used_node_bs bs ul node. 

Definition used_node (cfg : BDDconfig) := used_node_bs (fst cfg).

Definition used_node' (cfg : BDDconfig) := used_node'_bs (fst cfg).

Definition node_OK (bs : BDDstate) (node : ad) :=
  node = BDDzero \/ node = BDDone \/ in_dom _ node bs = true.

Definition config_node_OK (cfg : BDDconfig) := node_OK (fst cfg).

Definition no_new_node_bs (bs bs' : BDDstate) :=
  forall (x : BDDvar) (l r node : ad),
  MapGet _ bs' node = Some (x, (l, r)) ->
  MapGet _ bs node = Some (x, (l, r)).

Definition no_new_node (cfg cfg' : BDDconfig) :=
  no_new_node_bs (fst cfg) (fst cfg').

Inductive BDDbounded (bs : BDDstate) : ad -> BDDvar -> Prop :=
  | BDDbounded_0 : forall n : BDDvar, BDDbounded bs BDDzero n
  | BDDbounded_1 : forall n : BDDvar, BDDbounded bs BDDone n
  | BDDbounded_2 :
      forall (node : ad) (n x : BDDvar) (l r : ad),
      MapGet _ bs node = Some (x, (l, r)) ->
      BDDcompare x n = Datatypes.Lt ->
      Neqb l r = false ->
      BDDbounded bs l x -> BDDbounded bs r x -> BDDbounded bs node n.

Definition BDD_OK (bs : BDDstate) (node : ad) :=
  match MapGet _ bs node with
  | None => node = BDDzero \/ node = BDDone
  | Some (n, _) => BDDbounded bs node (ad_S n)
  end.

Definition BDDstate_OK (bs : BDDstate) :=
  MapGet _ bs BDDzero = None /\
  MapGet _ bs BDDone = None /\
  (forall a : ad, in_dom _ a bs = true -> BDD_OK bs a).

Definition BDDsharing_OK (bs : BDDstate) (share : BDDsharing_map) :=
  forall (x : BDDvar) (l r a : ad),
  MapGet3 _ share l r x = Some a <-> MapGet _ bs a = Some (x, (l, r)).

Definition BDDfree_list_OK (bs : BDDstate) (fl : BDDfree_list) 
  (cnt : ad) :=
  no_dup_list _ fl /\
  (forall node : ad,
   In node fl <->
   Nleb (Npos 2) node = true /\
   Nleb (ad_S node) cnt = true /\ MapGet _ bs node = None).

Definition cnt_OK (bs : BDDstate) (cnt : ad) :=
  Nleb (Npos 2) cnt = true /\
  (forall a : ad, Nleb cnt a = true -> MapGet _ bs a = None).

Definition BDDneg_memo_OK (bs : BDDstate) (negm : BDDneg_memo) :=
  forall node node' : ad,
  MapGet _ negm node = Some node' ->
  node_OK bs node /\
  node_OK bs node' /\
  Neqb (bs_node_height bs node') (bs_node_height bs node) = true /\
  bool_fun_eq (bool_fun_of_BDD_bs bs node')
    (bool_fun_neg (bool_fun_of_BDD_bs bs node)).

Definition BDDor_memo_OK (bs : BDDstate) (orm : BDDor_memo) :=
  forall node1 node2 node : ad,
  MapGet2 _ orm node1 node2 = Some node ->
  node_OK bs node1 /\
  node_OK bs node2 /\
  node_OK bs node /\
  Nleb (bs_node_height bs node)
    (BDDvar_max (bs_node_height bs node1) (bs_node_height bs node2)) = true /\
  bool_fun_eq (bool_fun_of_BDD_bs bs node)
    (bool_fun_or (bool_fun_of_BDD_bs bs node1) (bool_fun_of_BDD_bs bs node2)).

Definition BDDuniv_memo_OK (bs : BDDstate) (um : BDDuniv_memo) :=
  forall (x : BDDvar) (node node' : ad),
  MapGet2 _ um node x = Some node' ->
  node_OK bs node /\
  node_OK bs node' /\
  Nleb (bs_node_height bs node') (bs_node_height bs node) = true /\
  bool_fun_eq (bool_fun_of_BDD_bs bs node')
    (bool_fun_forall x (bool_fun_of_BDD_bs bs node)).

Definition BDDconfig_OK (cfg : BDDconfig) :=
  BDDstate_OK (fst cfg) /\
  BDDsharing_OK (fst cfg) (fst (snd cfg)) /\
  BDDfree_list_OK (fst cfg) (fst (snd (snd cfg))) (fst (snd (snd (snd cfg)))) /\
  cnt_OK (fst cfg) (fst (snd (snd (snd cfg)))) /\
  BDDneg_memo_OK (fst cfg) (fst (snd (snd (snd (snd cfg))))) /\
  BDDor_memo_OK (fst cfg) (fst (snd (snd (snd (snd (snd cfg)))))) /\
  BDDuniv_memo_OK (fst cfg) (snd (snd (snd (snd (snd (snd cfg)))))).

Definition used_list_OK_bs (bs : BDDstate) (ul : list ad) :=
  forall node : ad, In node ul -> node_OK bs node.

Definition used_list_OK (cfg : BDDconfig) := used_list_OK_bs (fst cfg).

Definition used_nodes_preserved_bs (bs bs' : BDDstate) 
  (ul : list ad) :=
  forall node : ad, In node ul -> node_preserved_bs bs bs' node.

Definition used_nodes_preserved (cfg cfg' : BDDconfig) :=
  used_nodes_preserved_bs (fst cfg) (fst cfg').

Definition gc_OK (gc : BDDconfig -> list ad -> BDDconfig) :=
  forall (cfg : BDDconfig) (ul : list ad),
  BDDconfig_OK cfg ->
  used_list_OK cfg ul ->
  BDDconfig_OK (gc cfg ul) /\
  used_nodes_preserved cfg (gc cfg ul) ul /\ no_new_node cfg (gc cfg ul).

Lemma initBDDstate_OK : BDDstate_OK initBDDstate.

Lemma initBDDsharing_map_OK : BDDsharing_OK initBDDstate initBDDsharing_map.

Lemma initBDDfree_list_OK :
 BDDfree_list_OK initBDDstate initBDDfree_list (Npos 2).

Lemma initBDDneg_memo_OK :
 forall bs : BDDstate, BDDneg_memo_OK bs initBDDneg_memo.

Lemma initBDDor_memo_OK :
 forall bs : BDDstate, BDDor_memo_OK bs initBDDor_memo.

Lemma initBDDuniv_memo_OK :
 forall bs : BDDstate, BDDuniv_memo_OK bs initBDDuniv_memo.

Lemma initBDDconfig_OK : BDDconfig_OK initBDDconfig.

Lemma config_OK_zero :
 forall cfg : BDDconfig,
 BDDconfig_OK cfg -> MapGet _ (fst cfg) BDDzero = None.

Lemma config_OK_one :
 forall cfg : BDDconfig,
 BDDconfig_OK cfg -> MapGet _ (fst cfg) BDDone = None.

Lemma zero_OK : forall cfg : BDDconfig, config_node_OK cfg BDDzero.

Lemma one_OK : forall cfg : BDDconfig, config_node_OK cfg BDDone.

Lemma node_height_zero :
 forall cfg : BDDconfig,
 BDDconfig_OK cfg -> Neqb (node_height cfg BDDzero) N0 = true.

Lemma node_height_one :
 forall cfg : BDDconfig,
 BDDconfig_OK cfg -> Neqb (node_height cfg BDDone) N0 = true.

Lemma nodes_preserved_bs_trans :
 forall bs1 bs2 bs3 : BDDstate,
 nodes_preserved_bs bs1 bs2 ->
 nodes_preserved_bs bs2 bs3 -> nodes_preserved_bs bs1 bs3.

Lemma nodes_preserved_bs_refl :
 forall bs : BDDstate, nodes_preserved_bs bs bs.

Lemma nodes_preserved_trans :
 forall cfg1 cfg2 cfg3 : BDDconfig,
 nodes_preserved cfg1 cfg2 ->
 nodes_preserved cfg2 cfg3 -> nodes_preserved cfg1 cfg3.

Lemma nodes_preserved_refl : forall cfg : BDDconfig, nodes_preserved cfg cfg.

Lemma increase_bound :
 forall (bs : BDDstate) (n n' : BDDvar) (node : ad),
 BDDbounded bs node n ->
 BDDcompare n n' = Datatypes.Lt -> BDDbounded bs node n'.

Lemma nodes_preserved_bounded :
 forall (bs bs' : BDDstate) (n : BDDvar) (node : ad),
 nodes_preserved_bs bs bs' -> BDDbounded bs node n -> BDDbounded bs' node n.

Lemma BDDbounded_lemma :
 forall (bs : BDDstate) (node : ad) (n : BDDvar),
 BDDbounded bs node n ->
 node = BDDzero \/
 node = BDDone \/
 (exists x : BDDvar,
    (exists l : BDDvar,
       (exists r : BDDvar,
          MapGet _ bs node = Some (x, (l, r)) /\
          BDDcompare x n = Datatypes.Lt /\

Lemma BDD_OK_node_OK :
 forall (bs : BDDstate) (node : ad), BDD_OK bs node -> node_OK bs node.

Lemma node_OK_BDD_OK :
 forall (bs : BDDstate) (node : ad),
 BDDstate_OK bs -> node_OK bs node -> BDD_OK bs node.

Lemma bs_node_height_left :
 forall (bs : BDDstate) (node l r : ad) (x : BDDvar),
 BDDstate_OK bs ->
 MapGet _ bs node = Some (x, (l, r)) ->
 BDDcompare (bs_node_height bs l) (bs_node_height bs node) = Datatypes.Lt.

Lemma bs_node_height_right :
 forall (bs : BDDstate) (node l r : ad) (x : BDDvar),
 BDDstate_OK bs ->
 MapGet _ bs node = Some (x, (l, r)) ->
 BDDcompare (bs_node_height bs r) (bs_node_height bs node) = Datatypes.Lt.

Lemma internal_node_lemma :
 forall (bs : BDDstate) (x : BDDvar) (l r node : ad),
 BDDstate_OK bs ->
 MapGet _ bs node = Some (x, (l, r)) ->
 Neqb l r = false /\ BDDbounded bs l x /\ BDDbounded bs r x.

Lemma high_bounded :
 forall (bs : BDDstate) (x : BDDvar) (l r node : ad),
 BDDstate_OK bs -> MapGet _ bs node = Some (x, (l, r)) -> BDDbounded bs r x.

Lemma low_bounded :
 forall (bs : BDDstate) (x : BDDvar) (l r node : ad),
 BDDstate_OK bs -> MapGet _ bs node = Some (x, (l, r)) -> BDDbounded bs l x.

Lemma BDDbounded_node_OK :
 forall (bs : BDDstate) (node : ad) (n : BDDvar),
 BDDbounded bs node n -> node_OK bs node.

Lemma high_OK :
 forall (bs : BDDstate) (x : BDDvar) (l r node : ad),
 BDDstate_OK bs -> MapGet _ bs node = Some (x, (l, r)) -> node_OK bs r.

Lemma low_OK :
 forall (bs : BDDstate) (x : BDDvar) (l r node : ad),
 BDDstate_OK bs -> MapGet _ bs node = Some (x, (l, r)) -> node_OK bs l.

Lemma low_high_neq :
 forall (cfg : BDDconfig) (x : BDDvar) (l r node : ad),
 BDDconfig_OK cfg ->
 MapGet _ (fst cfg) node = Some (x, (l, r)) -> Neqb l r = false.

Lemma bs_node_height_left_le :
 forall bs : BDDstate,
 BDDstate_OK bs ->
 forall (x : BDDvar) (l r node : ad),
 MapGet _ bs node = Some (x, (l, r)) ->
 Nleb (bs_node_height bs l) x = true.

Lemma bs_node_height_right_le :
 forall bs : BDDstate,
 BDDstate_OK bs ->
 forall (x : BDDvar) (l r node : ad),
 MapGet _ bs node = Some (x, (l, r)) ->
 Nleb (bs_node_height bs r) x = true.

Lemma no_duplicate_node :
 forall (bs : BDDstate) (share : BDDsharing_map),
 BDDstate_OK bs ->
 BDDsharing_OK bs share ->
 forall (x : BDDvar) (l r node1 node2 : ad),
 MapGet _ bs node1 = Some (x, (l, r)) ->
 MapGet _ bs node2 = Some (x, (l, r)) -> node1 = node2.

Lemma int_node_gt_1 :
 forall (bs : BDDstate) (node : ad),
 BDDstate_OK bs -> in_dom _ node bs = true -> Nleb (Npos 2) node = true.

Lemma int_node_lt_cnt :
 forall (bs : BDDstate) (cnt node : ad),
 cnt_OK bs cnt -> in_dom _ node bs = true -> Nleb (ad_S node) cnt = true.

Lemma nodes_preserved_bs_node_OK :
 forall (bs1 bs2 : BDDstate) (node : ad),
 nodes_preserved_bs bs1 bs2 -> node_OK bs1 node -> node_OK bs2 node.

Lemma nodes_preserved_config_node_OK :
 forall (cfg1 cfg2 : BDDconfig) (node : ad),
 nodes_preserved cfg1 cfg2 ->
 config_node_OK cfg1 node -> config_node_OK cfg2 node.

Lemma nodes_preserved_bs_node_height_eq :
 forall (bs1 bs2 : BDDstate) (node : ad),
 nodes_preserved_bs bs1 bs2 ->
 BDDstate_OK bs1 ->
 BDDstate_OK bs2 ->
 node_OK bs1 node ->
 Neqb (bs_node_height bs2 node) (bs_node_height bs1 node) = true.

Lemma nodes_preserved_node_height_eq :
 forall (cfg1 cfg2 : BDDconfig) (node : ad),
 BDDconfig_OK cfg1 ->
 BDDconfig_OK cfg2 ->
 nodes_preserved cfg1 cfg2 ->
 config_node_OK cfg1 node ->
 Neqb (node_height cfg2 node) (node_height cfg1 node) = true.

  Section Components.

  Variable cfg : BDDconfig.
  Hypothesis cfg_OK : BDDconfig_OK cfg.

  Definition bs_of_cfg := fst cfg.
  Definition share_of_cfg := fst (snd cfg).
  Definition fl_of_cfg := fst (snd (snd cfg)).
  Definition cnt_of_cfg := fst (snd (snd (snd cfg))).
  Definition negm_of_cfg := fst (snd (snd (snd (snd cfg)))).
  Definition orm_of_cfg := fst (snd (snd (snd (snd (snd cfg))))).
  Definition um_of_cfg := snd (snd (snd (snd (snd (snd cfg))))).

  Lemma cfg_comp :
   cfg =
   (bs_of_cfg,
   (share_of_cfg,
   (fl_of_cfg, (cnt_of_cfg, (negm_of_cfg, (orm_of_cfg, um_of_cfg)))))).

  Lemma bs_of_cfg_OK : BDDstate_OK bs_of_cfg.

  Lemma share_of_cfg_OK : BDDsharing_OK bs_of_cfg share_of_cfg.

  Lemma fl_of_cfg_OK : BDDfree_list_OK bs_of_cfg fl_of_cfg cnt_of_cfg.

  Lemma cnt_of_cfg_OK : cnt_OK bs_of_cfg cnt_of_cfg.

  Lemma negm_of_cfg_OK : BDDneg_memo_OK bs_of_cfg negm_of_cfg.

  Lemma orm_of_cfg_OK : BDDor_memo_OK bs_of_cfg orm_of_cfg.
 
  Lemma um_of_cfg_OK : BDDuniv_memo_OK bs_of_cfg um_of_cfg.

  End Components.

Lemma nodes_reachable_lemma_1 :
 forall (bs : BDDstate) (node node' : ad),
 nodes_reachable bs node node' ->
 node = node' \/
 (exists x : BDDvar,
    (exists l : ad,
       (exists r : ad,
          MapGet _ bs node = Some (x, (l, r)) /\
          (nodes_reachable bs l node' \/ nodes_reachable bs r node')))).

Lemma nodes_reachable_trans :
 forall (bs : BDDstate) (node1 node2 node3 : ad),
 nodes_reachable bs node1 node2 ->
 nodes_reachable bs node2 node3 -> nodes_reachable bs node1 node3.

Lemma reachable_node_OK_1 :
 forall (bs : BDDstate) (n : nat) (node1 node2 : ad),
 BDDstate_OK bs ->
 n = nat_of_N (bs_node_height bs node1) ->
 node_OK bs node1 -> nodes_reachable bs node1 node2 -> node_OK bs node2.

Lemma reachable_node_OK :
 forall (bs : BDDstate) (node1 node2 : ad),
 BDDstate_OK bs ->
 node_OK bs node1 -> nodes_reachable bs node1 node2 -> node_OK bs node2.

Lemma nodes_reachableBDDzero :
 forall (bs : BDDstate) (node : ad),
 BDDstate_OK bs -> nodes_reachable bs BDDzero node -> node = BDDzero.

Lemma nodes_reachableBDDone :
 forall (bs : BDDstate) (node : ad),
 BDDstate_OK bs -> nodes_reachable bs BDDone node -> node = BDDone.

Lemma used_node'_used_node_bs :
 forall (bs : BDDstate) (ul : list ad) (node : ad),
 used_node_bs bs ul node -> used_node'_bs bs ul node.

Lemma high_used_bs :
 forall (bs : BDDstate) (ul : list ad) (x : BDDvar) (l r node : ad),
 used_node_bs bs ul node ->
 MapGet _ bs node = Some (x, (l, r)) -> used_node_bs bs ul r.

Lemma high_used'_bs :
 forall (bs : BDDstate) (ul : list ad) (x : BDDvar) (l r node : ad),
 BDDstate_OK bs ->
 used_node'_bs bs ul node ->
 MapGet _ bs node = Some (x, (l, r)) -> used_node'_bs bs ul r.

Lemma low_used_bs :
 forall (bs : BDDstate) (ul : list ad) (x : BDDvar) (l r node : ad),
 used_node_bs bs ul node ->
 MapGet _ bs node = Some (x, (l, r)) -> used_node_bs bs ul l.

Lemma low_used'_bs :
 forall (bs : BDDstate) (ul : list ad) (x : BDDvar) (l r node : ad),
 BDDstate_OK bs ->
 used_node'_bs bs ul node ->
 MapGet _ bs node = Some (x, (l, r)) -> used_node'_bs bs ul l.

Lemma high_used :
 forall (cfg : BDDconfig) (ul : list ad) (x : BDDvar) (l r node : ad),
 used_node cfg ul node ->
 MapGet _ (fst cfg) node = Some (x, (l, r)) -> used_node cfg ul r.

Lemma high_used' :
 forall (cfg : BDDconfig) (ul : list ad) (x : BDDvar) (l r node : ad),
 BDDconfig_OK cfg ->
 used_node' cfg ul node ->
 MapGet _ (fst cfg) node = Some (x, (l, r)) -> used_node' cfg ul r.

Lemma low_used :
 forall (cfg : BDDconfig) (ul : list ad) (x : BDDvar) (l r node : ad),
 used_node cfg ul node ->
 MapGet _ (fst cfg) node = Some (x, (l, r)) -> used_node cfg ul l.

Lemma low_used' :
 forall (cfg : BDDconfig) (ul : list ad) (x : BDDvar) (l r node : ad),
 BDDconfig_OK cfg ->
 used_node' cfg ul node ->
 MapGet _ (fst cfg) node = Some (x, (l, r)) -> used_node' cfg ul l.

Lemma used_node_OK_bs :
 forall (bs : BDDstate) (ul : list ad) (node : ad),
 BDDstate_OK bs ->
 used_list_OK_bs bs ul -> used_node_bs bs ul node -> node_OK bs node.

Lemma used_node'_OK_bs :
 forall (bs : BDDstate) (ul : list ad) (node : ad),
 BDDstate_OK bs ->
 used_list_OK_bs bs ul -> used_node'_bs bs ul node -> node_OK bs node.

Lemma used_node_OK :
 forall (cfg : BDDconfig) (ul : list ad) (node : ad),
 BDDconfig_OK cfg ->
 used_list_OK cfg ul -> used_node cfg ul node -> config_node_OK cfg node.

Lemma used_node'_OK :
 forall (cfg : BDDconfig) (ul : list ad) (node : ad),
 BDDconfig_OK cfg ->
 used_list_OK cfg ul -> used_node' cfg ul node -> config_node_OK cfg node.

Lemma nodes_preserved_used_nodes_preserved :
 forall (cfg cfg' : BDDconfig) (ul : list ad),
 nodes_preserved cfg cfg' -> used_nodes_preserved cfg cfg' ul.

Lemma node_preserved_bs_reachable_1 :
 forall bs bs' : BDDstate,
 BDDstate_OK bs ->
 forall (n : nat) (node node' : ad),
 n = nat_of_N (bs_node_height bs node) ->
 node_preserved_bs bs bs' node ->
 nodes_reachable bs node node' -> nodes_reachable bs' node node'.

Lemma node_preserved_bs_reachable :
 forall (bs bs' : BDDstate) (node node' : ad),
 BDDstate_OK bs ->
 node_preserved_bs bs bs' node ->
 nodes_reachable bs node node' -> nodes_reachable bs' node node'.

Lemma node_preserved_bs_trans :
 forall (bs1 bs2 bs3 : BDDstate) (node : ad),
 BDDstate_OK bs1 ->
 node_preserved_bs bs1 bs2 node ->
 node_preserved_bs bs2 bs3 node -> node_preserved_bs bs1 bs3 node.

Lemma used_nodes_preserved_trans :
 forall (cfg1 cfg2 cfg3 : BDDconfig) (ul : list ad),
 BDDconfig_OK cfg1 ->
 used_nodes_preserved cfg1 cfg2 ul ->
 used_nodes_preserved cfg2 cfg3 ul -> used_nodes_preserved cfg1 cfg3 ul.

Lemma used_nodes_preserved_refl :
 forall (cfg : BDDconfig) (ul : list ad), used_nodes_preserved cfg cfg ul.

Lemma BDDzero_preserved :
 forall bs bs' : BDDstate, BDDstate_OK bs -> node_preserved_bs bs bs' BDDzero.

Lemma BDDone_preserved :
 forall bs bs' : BDDstate, BDDstate_OK bs -> node_preserved_bs bs bs' BDDone.

Lemma used_nodes_preserved_preserved_bs :
 forall (bs bs' : BDDstate) (ul : list ad) (node : ad),
 used_nodes_preserved_bs bs bs' ul ->
 used_node_bs bs ul node -> node_preserved_bs bs bs' node.

Lemma used_nodes_preserved_preserved'_bs :
 forall (bs bs' : BDDstate) (ul : list ad) (node : ad),
 BDDstate_OK bs ->
 used_nodes_preserved_bs bs bs' ul ->
 used_node'_bs bs ul node -> node_preserved_bs bs bs' node.

Lemma node_preserved_OK_bs :
 forall (bs bs' : BDDstate) (node : ad),
 node_OK bs node -> node_preserved_bs bs bs' node -> node_OK bs' node.

Lemma used_nodes_preserved_list_OK_bs :
 forall (bs bs' : BDDstate) (ul : list ad),
 used_list_OK_bs bs ul ->
 used_nodes_preserved_bs bs bs' ul -> used_list_OK_bs bs' ul.

Lemma used_nodes_preserved_list_OK :
 forall (cfg cfg' : BDDconfig) (ul : list ad),
 used_list_OK cfg ul ->
 used_nodes_preserved cfg cfg' ul -> used_list_OK cfg' ul.

Lemma used_node_cons_node_ul :
 forall (cfg : BDDconfig) (ul : list ad) (node : ad),
 used_node cfg (node :: ul) node.

Lemma used_node'_cons_node_ul :
 forall (cfg : BDDconfig) (ul : list ad) (node : ad),
 used_node' cfg (node :: ul) node.

Lemma used_node_cons_node'_ul :
 forall (cfg : BDDconfig) (ul : list ad) (node node' : ad),
 used_node cfg ul node -> used_node cfg (node' :: ul) node.

Lemma used_node'_cons_node'_ul :
 forall (cfg : BDDconfig) (ul : list ad) (node node' : ad),
 used_node' cfg ul node -> used_node' cfg (node' :: ul) node.

Lemma used_nodes_preserved_bs_cons :
 forall (bs bs' : BDDstate) (ul : list ad) (node : ad),
 used_nodes_preserved_bs bs bs' (node :: ul) ->
 used_nodes_preserved_bs bs bs' ul.

Lemma used_nodes_preserved_cons :
 forall (cfg cfg' : BDDconfig) (ul : list ad) (node : ad),
 used_nodes_preserved cfg cfg' (node :: ul) ->
 used_nodes_preserved cfg cfg' ul.

Lemma node_OK_list_OK_bs :
 forall (bs : BDDstate) (ul : list ad) (node : ad),
 node_OK bs node -> used_list_OK_bs bs ul -> used_list_OK_bs bs (node :: ul).

Lemma node_OK_list_OK :
 forall (cfg : BDDconfig) (ul : list ad) (node : ad),
 config_node_OK cfg node ->
 used_list_OK cfg ul -> used_list_OK cfg (node :: ul).

Lemma used_nodes_preserved_node_OK :
 forall (cfg cfg' : BDDconfig) (ul : list ad) (node : ad),
 BDDconfig_OK cfg ->
 used_list_OK cfg ul ->
 used_node cfg ul node ->
 used_nodes_preserved cfg cfg' ul -> config_node_OK cfg' node.

Lemma used_nodes_preserved_node_OK' :
 forall (cfg cfg' : BDDconfig) (ul : list ad) (node : ad),
 BDDconfig_OK cfg ->
 used_list_OK cfg ul ->
 used_node' cfg ul node ->
 used_nodes_preserved cfg cfg' ul -> config_node_OK cfg' node.

Lemma used_nodes_preserved_used_node :
 forall (cfg cfg' : BDDconfig) (ul : list ad) (node : ad),
 BDDconfig_OK cfg ->
 used_nodes_preserved cfg cfg' ul ->
 used_node cfg ul node -> used_node cfg' ul node.

Lemma used_nodes_preserved_used_node' :
 forall (cfg cfg' : BDDconfig) (ul : list ad) (node : ad),
 BDDconfig_OK cfg ->
 used_nodes_preserved cfg cfg' ul ->
 used_node' cfg ul node -> used_node' cfg' ul node.

Lemma bool_fun_of_BDD_1_change_bound :
 forall bs : BDDstate,
 BDDstate_OK bs ->
 forall (bound : nat) (node : ad),
 nat_of_N (bs_node_height bs node) < bound ->
 bool_fun_eq (bool_fun_of_BDD_1 bs node bound)
   (bool_fun_of_BDD_1 bs node (S (nat_of_N (bs_node_height bs node)))).

Lemma bool_fun_of_BDD_bs_zero :
 forall bs : BDDstate,
 BDDstate_OK bs -> bool_fun_eq (bool_fun_of_BDD_bs bs BDDzero) bool_fun_zero.

Lemma bool_fun_of_BDD_bs_one :
 forall bs : BDDstate,
 BDDstate_OK bs -> bool_fun_eq (bool_fun_of_BDD_bs bs BDDone) bool_fun_one.

Lemma bool_fun_of_BDD_bs_int :
 forall bs : BDDstate,
 BDDstate_OK bs ->
 forall (x : BDDvar) (l r node : ad),
 MapGet _ bs node = Some (x, (l, r)) ->
 bool_fun_eq (bool_fun_of_BDD_bs bs node)
   (bool_fun_if x (bool_fun_of_BDD_bs bs r) (bool_fun_of_BDD_bs bs l)).

Lemma bool_fun_of_BDD_one :
 forall cfg : BDDconfig,
 BDDconfig_OK cfg -> bool_fun_eq (bool_fun_of_BDD cfg BDDone) bool_fun_one.

Lemma bool_fun_of_BDD_zero :
 forall cfg : BDDconfig,
 BDDconfig_OK cfg -> bool_fun_eq (bool_fun_of_BDD cfg BDDzero) bool_fun_zero.

Lemma bool_fun_of_BDD_int :
 forall (cfg : BDDconfig) (x : BDDvar) (l r node : ad),
 BDDconfig_OK cfg ->
 MapGet _ (fst cfg) node = Some (x, (l, r)) ->
 bool_fun_eq (bool_fun_of_BDD cfg node)
   (bool_fun_if x (bool_fun_of_BDD cfg r) (bool_fun_of_BDD cfg l)).

Lemma bool_fun_of_BDD_1_ext :
 forall (bound : nat) (bs : BDDstate) (node : ad),
 bool_fun_ext (bool_fun_of_BDD_1 bs node bound).

Lemma bool_fun_of_BDD_bs_ext :
 forall (bs : BDDstate) (node : ad),
 bool_fun_ext (bool_fun_of_BDD_bs bs node).

Lemma BDDvar_independent_1 :
 forall bs : BDDstate,
 BDDstate_OK bs ->
 forall (n : nat) (node : ad) (x : BDDvar),
 n = nat_of_N (bs_node_height bs node) ->
 node_OK bs node ->
 Nleb (bs_node_height bs node) x = true ->
 bool_fun_independent (bool_fun_of_BDD_bs bs node) x.

Lemma BDDvar_independent_bs :
 forall bs : BDDstate,
 BDDstate_OK bs ->
 forall (node : ad) (x : BDDvar),
 node_OK bs node ->
 Nleb (bs_node_height bs node) x = true ->
 bool_fun_independent (bool_fun_of_BDD_bs bs node) x.

Lemma BDDvar_independent_low :
 forall bs : BDDstate,
 BDDstate_OK bs ->
 forall (x : BDDvar) (l r node : ad),
 MapGet _ bs node = Some (x, (l, r)) ->
 bool_fun_independent (bool_fun_of_BDD_bs bs l) x.

Lemma BDDvar_independent_high :
 forall bs : BDDstate,
 BDDstate_OK bs ->
 forall (x : BDDvar) (l r node : ad),
 MapGet _ bs node = Some (x, (l, r)) ->
 bool_fun_independent (bool_fun_of_BDD_bs bs r) x.

Lemma bool_fun_of_BDD_bs_high :
 forall bs : BDDstate,
 BDDstate_OK bs ->
 forall (x : BDDvar) (l r node : ad),
 MapGet _ bs node = Some (x, (l, r)) ->
 bool_fun_eq (bool_fun_of_BDD_bs bs r)
   (bool_fun_restrict (bool_fun_of_BDD_bs bs node) x true).

Lemma bool_fun_of_BDD_bs_low :
 forall bs : BDDstate,
 BDDstate_OK bs ->
 forall (x : BDDvar) (l r node : ad),
 MapGet _ bs node = Some (x, (l, r)) ->
 bool_fun_eq (bool_fun_of_BDD_bs bs l)
   (bool_fun_restrict (bool_fun_of_BDD_bs bs node) x false).

Lemma BDDunique_1 :
 forall (bs : BDDstate) (share : BDDsharing_map),
 BDDstate_OK bs ->
 BDDsharing_OK bs share ->
 forall (n : nat) (node1 node2 : ad),
 n =
 max (nat_of_N (bs_node_height bs node1))
   (nat_of_N (bs_node_height bs node2)) ->
 node_OK bs node1 ->
 node_OK bs node2 ->
 bool_fun_eq (bool_fun_of_BDD_bs bs node1) (bool_fun_of_BDD_bs bs node2) ->
 node1 = node2.

Lemma BDDunique :
 forall (cfg : BDDconfig) (node1 node2 : ad),
 BDDconfig_OK cfg ->
 config_node_OK cfg node1 ->
 config_node_OK cfg node2 ->
 bool_fun_eq (bool_fun_of_BDD cfg node1) (bool_fun_of_BDD cfg node2) ->
 Neqb node1 node2 = true.

Lemma nodes_preserved_bs_bool_fun_1 :
 forall (bs1 bs2 : BDDstate) (n : nat) (node : ad),
 n = nat_of_N (bs_node_height bs1 node) ->
 BDDstate_OK bs1 ->
 BDDstate_OK bs2 ->
 nodes_preserved_bs bs1 bs2 ->
 node_OK bs1 node ->
 bool_fun_eq (bool_fun_of_BDD_bs bs2 node) (bool_fun_of_BDD_bs bs1 node).

Lemma nodes_preserved_bs_bool_fun :
 forall (bs1 bs2 : BDDstate) (node : ad),
 BDDstate_OK bs1 ->
 BDDstate_OK bs2 ->
 nodes_preserved_bs bs1 bs2 ->
 node_OK bs1 node ->
 bool_fun_eq (bool_fun_of_BDD_bs bs2 node) (bool_fun_of_BDD_bs bs1 node).

Lemma nodes_preserved_bool_fun :
 forall (cfg1 cfg2 : BDDconfig) (node : ad),
 BDDconfig_OK cfg1 ->
 BDDconfig_OK cfg2 ->
 nodes_preserved cfg1 cfg2 ->
 config_node_OK cfg1 node ->
 bool_fun_eq (bool_fun_of_BDD cfg2 node) (bool_fun_of_BDD cfg1 node).

Lemma nodes_preserved_neg_memo_OK :
 forall (bs bs' : BDDstate) (negm : BDDneg_memo),
 nodes_preserved_bs bs bs' ->
 BDDstate_OK bs ->
 BDDstate_OK bs' -> BDDneg_memo_OK bs negm -> BDDneg_memo_OK bs' negm.

Lemma nodes_preserved_or_memo_OK :
 forall (bs bs' : BDDstate) (orm : BDDor_memo),
 nodes_preserved_bs bs bs' ->
 BDDstate_OK bs ->
 BDDstate_OK bs' -> BDDor_memo_OK bs orm -> BDDor_memo_OK bs' orm.

Lemma nodes_preserved_um_OK :
 forall (bs bs' : BDDstate) (um : BDDuniv_memo),
 nodes_preserved_bs bs bs' ->
 BDDstate_OK bs ->
 BDDstate_OK bs' -> BDDuniv_memo_OK bs um -> BDDuniv_memo_OK bs' um.

Lemma node_preserved_bs_bool_fun_1 :
 forall (n : nat) (bs bs' : BDDstate) (node : ad),
 BDDstate_OK bs ->
 BDDstate_OK bs' ->
 node_preserved_bs bs bs' node ->
 node_OK bs node ->
 n = nat_of_N (bs_node_height bs node) ->
 bool_fun_eq (bool_fun_of_BDD_bs bs' node) (bool_fun_of_BDD_bs bs node).

Lemma node_preserved_bs_bool_fun :
 forall (bs bs' : BDDstate) (node : ad),
 BDDstate_OK bs ->
 BDDstate_OK bs' ->
 node_preserved_bs bs bs' node ->
 node_OK bs node ->
 bool_fun_eq (bool_fun_of_BDD_bs bs' node) (bool_fun_of_BDD_bs bs node).

Lemma node_preserved_bs_node_height_eq :
 forall (bs bs' : BDDstate) (node : ad),
 BDDstate_OK bs ->
 BDDstate_OK bs' ->
 node_preserved_bs bs bs' node ->
 node_OK bs node ->
 Neqb (bs_node_height bs' node) (bs_node_height bs node) = true.

Lemma node_preserved_node_height_eq :
 forall (cfg cfg' : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 BDDconfig_OK cfg' ->
 node_preserved cfg cfg' node ->
 config_node_OK cfg node ->
 Neqb (node_height cfg' node) (node_height cfg node) = true.

Lemma used_nodes_preserved_node_height_eq :
 forall (cfg cfg' : BDDconfig) (ul : list ad) (node : ad),
 BDDconfig_OK cfg ->
 BDDconfig_OK cfg' ->
 used_nodes_preserved cfg cfg' ul ->
 used_list_OK cfg ul ->
 used_node cfg ul node ->
 Neqb (node_height cfg' node) (node_height cfg node) = true.

Lemma used_nodes_preserved'_node_height_eq :
 forall (cfg cfg' : BDDconfig) (ul : list ad) (node : ad),
 BDDconfig_OK cfg ->
 BDDconfig_OK cfg' ->
 used_nodes_preserved cfg cfg' ul ->
 used_list_OK cfg ul ->
 used_node' cfg ul node ->
 Neqb (node_height cfg' node) (node_height cfg node) = true.

Lemma used_nodes_preserved_bs_bool_fun :
 forall (bs bs' : BDDstate) (ul : list ad) (node : ad),
 BDDstate_OK bs ->
 BDDstate_OK bs' ->
 used_nodes_preserved_bs bs bs' ul ->
 used_list_OK_bs bs ul ->
 used_node_bs bs ul node ->
 bool_fun_eq (bool_fun_of_BDD_bs bs' node) (bool_fun_of_BDD_bs bs node).

Lemma used_nodes_preserved'_bs_bool_fun :
 forall (bs bs' : BDDstate) (ul : list ad) (node : ad),
 BDDstate_OK bs ->
 BDDstate_OK bs' ->
 used_nodes_preserved_bs bs bs' ul ->
 used_list_OK_bs bs ul ->
 used_node'_bs bs ul node ->
 bool_fun_eq (bool_fun_of_BDD_bs bs' node) (bool_fun_of_BDD_bs bs node).

Lemma used_nodes_preserved_bool_fun :
 forall (cfg cfg' : BDDconfig) (ul : list ad) (node : ad),
 BDDconfig_OK cfg ->
 BDDconfig_OK cfg' ->
 used_nodes_preserved cfg cfg' ul ->
 used_list_OK cfg ul ->
 used_node cfg ul node ->
 bool_fun_eq (bool_fun_of_BDD cfg' node) (bool_fun_of_BDD cfg node).

Lemma used_nodes_preserved'_bool_fun :
 forall (cfg cfg' : BDDconfig) (ul : list ad) (node : ad),
 BDDconfig_OK cfg ->
 BDDconfig_OK cfg' ->
 used_nodes_preserved cfg cfg' ul ->
 used_list_OK cfg ul ->
 used_node' cfg ul node ->
 bool_fun_eq (bool_fun_of_BDD cfg' node) (bool_fun_of_BDD cfg node).

Definition BDDneg_memo_put (cfg : BDDconfig) (node node' : ad) :=
  match cfg with
  | (bs, (share, (fl, (cnt, (negm, z))))) =>
      (bs, (share, (fl, (cnt, (MapPut _ negm node node', z)))))
  end.

Lemma BDDnegm_put_OK :
 forall (cfg : BDDconfig) (node node' : ad),
 BDDconfig_OK cfg ->
 config_node_OK cfg node ->
 config_node_OK cfg node' ->
 Neqb (node_height cfg node') (node_height cfg node) = true ->
 bool_fun_eq (bool_fun_of_BDD cfg node')
   (bool_fun_neg (bool_fun_of_BDD cfg node)) ->
 BDDconfig_OK (BDDneg_memo_put cfg node node').

Definition BDDor_memo_put (cfg : BDDconfig) (node1 node2 node' : ad) :=
  match cfg with
  | (bs, (share, (fl, (cnt, (negm, (orm, um)))))) =>
      (bs,
      (share, (fl, (cnt, (negm, (MapPut2 _ orm node1 node2 node', um))))))
  end.

Lemma BDDorm_put_nodes_preserved :
 forall (cfg : BDDconfig) (node1 node2 node' : ad),
 nodes_preserved cfg (BDDor_memo_put cfg node1 node2 node').

Lemma BDDorm_put_OK :
 forall (cfg : BDDconfig) (node1 node2 node' : ad),
 BDDconfig_OK cfg ->
 config_node_OK cfg node1 ->
 config_node_OK cfg node2 ->
 config_node_OK cfg node' ->
 Nleb (node_height cfg node')
   (BDDvar_max (node_height cfg node1) (node_height cfg node2)) = true ->
 bool_fun_eq (bool_fun_of_BDD cfg node')
   (bool_fun_or (bool_fun_of_BDD cfg node1) (bool_fun_of_BDD cfg node2)) ->
 BDDconfig_OK (BDDor_memo_put cfg node1 node2 node').

Lemma BDDnegm_put_nodes_preserved :
 forall (cfg : BDDconfig) (node node' : ad),
 nodes_preserved cfg (BDDneg_memo_put cfg node node').

Definition BDDuniv_memo_put (cfg : BDDconfig) (x : BDDvar)
  (node node' : ad) :=
  match cfg with
  | (bs, (share, (fl, (cnt, (negm, (orm, um)))))) =>
      (bs, (share, (fl, (cnt, (negm, (orm, MapPut2 ad um node x node'))))))
  end.

Lemma BDDum_put_nodes_preserved :
 forall (cfg : BDDconfig) (x : BDDvar) (node node' : ad),
 nodes_preserved cfg (BDDuniv_memo_put cfg x node node').

Lemma BDDum_put_OK :
 forall (cfg : BDDconfig) (x : BDDvar) (node node' : ad),
 BDDconfig_OK cfg ->
 config_node_OK cfg node ->
 config_node_OK cfg node' ->
 Nleb (node_height cfg node') (node_height cfg node) = true ->
 bool_fun_eq (bool_fun_of_BDD cfg node')
   (bool_fun_forall x (bool_fun_of_BDD cfg node)) ->
 BDDconfig_OK (BDDuniv_memo_put cfg x node node').

Lemma not_zero_is_one :
 forall (cfg : BDDconfig) (node : ad),
 config_node_OK cfg node ->
 in_dom _ node (fst cfg) = false ->
 Neqb node BDDzero = false -> Neqb node BDDone = true.

Lemma used'_zero :
 forall (cfg : BDDconfig) (ul : list ad), used_node' cfg ul BDDzero.

Lemma used'_one :
 forall (cfg : BDDconfig) (ul : list ad), used_node' cfg ul BDDone.

Lemma cons_OK_list_OK :
 forall (cfg : BDDconfig) (ul : list ad) (node : ad),
 used_list_OK cfg (node :: ul) -> used_list_OK cfg ul.

End BDD_config_1. *)

Require Import myMap.
(* myMap:
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import ZArith NArith Nnat Ndec Ndigits.
From IntMap Require Import Map.
From IntMap Require Import Allmaps.
Require Import Relation_Definitions.
Require Import List.

Require Import misc.

Section my_MapFold.

Variable M : Set.
Variable neutral : M.
Variable op : M -> M -> M.
Variable R : relation M.

Definition F (A : Set) (f : ad -> A -> M) (r : ad * A) 
  (m : M) := let (a, y) := r in op (f a y) m.

Hypothesis eq_R : equiv _ R.
Hypothesis op_assoc : forall a b c : M, R (op (op a b) c) (op a (op b c)).
Hypothesis op_neutral_left : forall a : M, R (op neutral a) a.
Hypothesis op_neutral_right : forall a : M, R (op a neutral) a.
Hypothesis
  op_eq : forall a b a1 b1 : M, R a a1 -> R b b1 -> R (op a b) (op a1 b1).

Lemma op_eq_2 : forall a b b1 : M, R b b1 -> R (op a b) (op a b1).

Lemma my_fold_right_aapp :
 forall (A : Set) (f : ad -> A -> M) (l l' : alist A),
 R (fold_right (F A f) neutral (aapp _ l l'))
   (op (fold_right (F A f) neutral l) (fold_right (F A f) neutral l')).

Lemma myMapFold_as_fold_1 :
 forall (A : Set) (f : ad -> A -> M) (m : Map A) (pf : ad -> ad),
 R (MapFold1 _ M neutral op f pf m)
   (fold_right (fun (r : ad * A) (m : M) => let (a, y) := r in op (f a y) m)
      neutral
      (MapFold1 _ (alist A) (anil A) (aapp A)
         (fun (a : ad) (y : A) => acons _ (a, y) (anil _)) pf m)).

Lemma myMapFold_as_fold :
 forall (A : Set) (f : ad -> A -> M) (m : Map A),
 R (MapFold _ M neutral op f m)
   (fold_right (fun (r : ad * A) (m : M) => let (a, y) := r in op (f a y) m)
      neutral (alist_of_Map _ m)).

End my_MapFold.

Lemma eqmap_equiv : forall A : Set, equiv _ (eqmap A).

Lemma MapMerge_assoc :
 forall (A : Set) (a b c : Map A),
 eqmap _ (MapMerge _ (MapMerge _ a b) c) (MapMerge _ a (MapMerge _ b c)).

Lemma MapMerge_neutral_left :
 forall (A : Set) (m : Map A), eqmap _ (MapMerge _ (M0 A) m) m.

Lemma MapMerge_neutral_right :
 forall (A : Set) (m : Map A), eqmap _ (MapMerge _ m (M0 _)) m.

Lemma MapMerge_eq :
 forall (A : Set) (a a1 b b1 : Map A),
 eqmap _ a a1 -> eqmap _ b b1 -> eqmap _ (MapMerge _ a b) (MapMerge _ a1 b1).

Lemma myMapFold_as_fold_2 :
 forall (A B : Set) (f : ad -> A -> Map B) (m : Map A),
 eqmap _ (MapFold _ (Map B) (M0 _) (MapMerge _) f m)
   (fold_right
      (fun (r : ad * A) (m : Map B) =>
       let (a, y) := r in MapMerge _ (f a y) m) (M0 _) 
      (alist_of_Map _ m)).

Lemma my_alist_of_map_lemma_1 :
 forall (A : Set) (m : Map A) (a : ad) (y : A),
 MapGet _ m a = Some y -> In (a, y) (alist_of_Map _ m).

Lemma my_alist_of_map_lemma_2 :
 forall (A : Set) (m : Map A) (pf fp : ad -> ad),
 (forall a : ad, fp (pf a) = a) ->
 forall (a : ad) (y : A),
 In (a, y)
   (MapFold1 _ _ (anil _) (aapp _)
      (fun (a : ad) (y : A) => acons _ (a, y) (anil _)) pf m) ->
 MapGet _ m (fp a) = Some y /\ pf (fp a) = a.

Lemma my_alist_of_map_lemma_3 :
 forall (A : Set) (m : Map A) (a : ad) (y : A),
 In (a, y) (alist_of_Map _ m) -> MapGet _ m a = Some y.

Definition f_OK (A B : Set) (f : ad -> A -> Map B) :=
  forall (a a1 a2 : ad) (y1 y2 : A),
  in_dom _ a (f a1 y1) = true -> in_dom _ a (f a2 y2) = true -> a1 = a2.

Definition no_dup_alist (A : Set) (l : alist A) :=
  forall (a : ad) (y1 y2 : A), In (a, y1) l -> In (a, y2) l -> y1 = y2.

Lemma no_dup_alist_of_Map :
 forall (A : Set) (m : Map A), no_dup_alist _ (alist_of_Map _ m).

Lemma my_fold_right_lemma :
 forall (A B : Set) (f : ad -> A -> Map B) (l : alist A),
 f_OK _ _ f ->
 no_dup_alist _ l ->
 forall (a : ad) (y : B),
 MapGet _
   (fold_right
      (fun (r : ad * A) (m0 : Map B) =>
       let (a0, y0) := r in MapMerge B (f a0 y0) m0) 
      (M0 B) l) a = Some y <->
 (exists a1 : ad,
    (exists y1 : A, In (a1, y1) l /\ MapGet _ (f a1 y1) a = Some y)).

Lemma myMapFold_lemma :
 forall (A B : Set) (f : ad -> A -> Map B) (m : Map A),
 f_OK _ _ f ->
 forall (a : ad) (y : B),
 MapGet _ (MapFold _ _ (M0 _) (MapMerge _) f m) a = Some y <->
 (exists a1 : ad,
    (exists y1 : A,
       MapGet _ m a1 = Some y1 /\ MapGet _ (f a1 y1) a = Some y)).

Section My_Map.

Variable A B : Set.

Fixpoint Mapn (n : nat) : Set :=
  match n with
  | O => A
  | S m => Map (Mapn m)
  end.

Definition MapGet2 (m : Map (Map A)) (a b : ad) :=
  match MapGet _ m a with
  | None => None 
  | Some m' => MapGet _ m' b
  end.

Definition MapGet3 (m : Map (Map (Map A))) (a b c : ad) :=
  match MapGet _ m a with
  | None => None
  | Some m' => MapGet2 m' b c
  end.

Definition MapPut2 (m : Map (Map A)) (a b : ad) (c : A) :=
  match MapGet _ m a with
  | Some m' => MapPut _ m a (MapPut _ m' b c)
  | None => MapPut _ m a (M1 _ b c)
  end.

Definition MapPut3 (m : Map (Map (Map A))) (a b c : ad) 
  (d : A) :=
  match MapGet _ m a with
  | Some m' => MapPut _ m a (MapPut2 m' b c d)
  | None => MapPut _ m a (M1 _ b (M1 _ c d))
  end.

Lemma MapPut2_semantics :
 forall (m : Map (Map A)) (a b a1 b1 : ad) (c : A),
 MapGet2 (MapPut2 m a b c) a1 b1 =
 (if Neqb a a1 && Neqb b b1 then Some c else MapGet2 m a1 b1).
 
Lemma MapPut3_semantics :
 forall (m : Map (Map (Map A))) (a b c a1 b1 c1 : ad) (d : A),
 MapGet3 (MapPut3 m a b c d) a1 b1 c1 =
 (if Neqb a a1 && (Neqb b b1 && Neqb c c1)
  then Some d
  else MapGet3 m a1 b1 c1).

Lemma makeM2_MapDom_lemma :
 forall (A : Set) (m1 m2 : Map A),
 makeM2 unit (MapDom A m1) (MapDom A m2) = MapDom A (makeM2 A m1 m2).

Fixpoint MapDomRestrTo_DomBy (m : Map A) : Map B -> Map A * Map unit :=
  match m with
  | M0 => fun _ : Map B => (M0 A, M0 unit)
  | M1 a y =>
      fun m' : Map B =>
      match MapGet B m' a with
      | None => (M0 A, M1 unit a tt)
      | _ => (m, M0 unit)
      end
  | M2 m1 m2 =>
      fun m' : Map B =>
      match m' with
      | M0 => (M0 A, MapDom A m)
      | M1 a' y' =>
          (match MapGet A m a' with
           | None => M0 A
           | Some y => M1 A a' y
           end, MapDom A (MapRemove A m a'))
      | M2 m'1 m'2 =>
          match MapDomRestrTo_DomBy m1 m'1 with
          | (x1, y1) =>
              match MapDomRestrTo_DomBy m2 m'2 with
              | (x2, y2) => (makeM2 A x1 x2, makeM2 unit y1 y2)
              end
          end
      end
  end.

Lemma MapDomRestrTo_DomBy_lemma_1 :
 forall (m : Map A) (m' : Map B),
 fst (MapDomRestrTo_DomBy m m') = MapDomRestrTo A B m m'.

Lemma MapDomRestrTo_DomBy_lemma_2 :
 forall (m : Map A) (m' : Map B),
 snd (MapDomRestrTo_DomBy m m') = MapDom A (MapDomRestrBy A B m m').

Fixpoint map_app_list1 (pf : ad -> ad) (l : list ad) 
 (m : Map A) {struct m} : list ad :=
  match m with
  | M0 => l
  | M1 a y => pf a :: l
  | M2 m1 m2 =>
      map_app_list1 (fun a0 : ad => pf (Ndouble_plus_one a0))
        (map_app_list1 (fun a0 : ad => pf (Ndouble a0)) l m1) m2
  end.

Lemma map_app_list1_lemma_1 :
 forall (m : Map A) (pf : ad -> ad) (l : list ad) (a : ad),
 In a l -> In a (map_app_list1 pf l m).

Lemma map_app_list1_lemma_2 :
 forall (m : Map A) (pf fp : ad -> ad) (l : list ad),
 (forall a0 : ad, fp (pf a0) = a0) ->
 forall a : ad,
 In a (map_app_list1 pf l m) ->
 In a l \/ in_dom _ (fp a) m = true /\ pf (fp a) = a.

Lemma map_app_list1_lemma_3 :
 forall (m : Map A) (pf fp : ad -> ad) (l : list ad),
 (forall a0 : ad, fp (pf a0) = a0) ->
 no_dup_list _ l ->
 (forall a : ad, in_dom _ a m = true -> ~ In (pf a) l) ->
 no_dup_list _ (map_app_list1 pf l m).

Lemma map_app_list1_lemma_4 :
 forall (m : Map A) (pf : ad -> ad) (l : list ad) (a : ad),
 in_dom _ a m = true -> In (pf a) (map_app_list1 pf l m).

Fixpoint MapDomRestrByApp1 (pf : ad -> ad) (l : list ad) 
 (m : Map A) {struct m} : Map B -> list ad :=
  match m with
  | M0 => fun _ : Map B => l
  | M1 a y =>
      fun m' : Map B =>
      match MapGet B m' a with
      | None => pf a :: l
      | _ => l
      end
  | M2 m1 m2 =>
      fun m' : Map B =>
      match m' with
      | M0 => map_app_list1 pf l m
      | M1 a' y' => map_app_list1 pf l (MapRemove A m a')
      | M2 m'1 m'2 =>
          MapDomRestrByApp1 (fun a0 : ad => pf (Ndouble_plus_one a0))
            (MapDomRestrByApp1 (fun a0 : ad => pf (Ndouble a0)) l m1 m'1)
            m2 m'2
      end
  end.

Lemma MapDomRestrByApp1_lemma_1 :
 forall (m : Map A) (m' : Map B) (l : list ad) (pf : ad -> ad) (a : ad),
 In a l -> In a (MapDomRestrByApp1 pf l m m').

Lemma MapDomRestrByApp1_lemma_2 :
 forall (m : Map A) (m' : Map B) (l : list ad) (pf : ad -> ad) (a : ad),
 in_dom _ a m = true ->
 in_dom _ a m' = false -> In (pf a) (MapDomRestrByApp1 pf l m m').

Lemma MapDomRestrByApp1_lemma_3 :
 forall (m : Map A) (m' : Map B) (l : list ad) (pf fp : ad -> ad),
 (forall a : ad, fp (pf a) = a) ->
 forall a : ad,
 In a (MapDomRestrByApp1 pf l m m') ->
 In a l \/
 in_dom _ (fp a) m = true /\ in_dom _ (fp a) m' = false /\ pf (fp a) = a.

Lemma MapDomRestrByApp1_lemma_4 :
 forall (m : Map A) (m' : Map B) (l : list ad) (pf fp : ad -> ad),
 (forall a : ad, fp (pf a) = a) ->
 (forall a : ad,
  in_dom _ a m = true -> in_dom _ a m' = false -> ~ In (pf a) l) ->
 no_dup_list _ l -> no_dup_list _ (MapDomRestrByApp1 pf l m m').

End My_Map. *)



Section BDDgc.



Definition set_closed (bs : BDDstate) (marked : Map unit) :=

  forall node node' : ad,

  in_dom _ node marked = true ->

  nodes_reachable bs node node' ->

  in_dom _ node' bs = true -> in_dom _ node' marked = true.



Fixpoint add_used_nodes_1 (bs : BDDstate) (node : ad) 

 (marked : Map unit) (bound : nat) {struct bound} : 

 Map unit :=

  match bound with

  | O =>   M0 unit

  | S bound' =>

      match MapGet _ marked node with

      | None =>

          match MapGet _ bs node with

          | None => marked

          | Some (x, (l, r)) =>

              MapPut _

                (add_used_nodes_1 bs r (add_used_nodes_1 bs l marked bound')

                   bound') node tt

          end

      | Some tt => marked

      end

  end.



Definition add_used_nodes (bs : BDDstate) (node : ad) 

  (marked : Map unit) :=

  add_used_nodes_1 bs node marked (S (nat_of_N (bs_node_height bs node))).



Definition mark (bs : BDDstate) (used : list ad) :=

  fold_right (add_used_nodes bs) (M0 unit) used.



Definition new_bs (bs : BDDstate) (used : list ad) :=

  MapDomRestrTo _ _ bs (mark bs used).



Definition new_fl (bs : BDDstate) (used : list ad) 

  (fl : BDDfree_list) :=

  MapDomRestrByApp1 _ _ (fun a0 : ad => a0) fl bs (mark bs used).



Definition used_node_bs_1 (marked : Map unit) (node : ad) :=

  match MapGet _ marked node with

  | Some _ => true

  | None => Neqb node BDDzero || Neqb node BDDone

  end.



Fixpoint clean'1_1 (pf : ad -> ad) (m' : Map unit) 

 (m : Map ad) {struct m} : Map ad :=

  match m with

  | M0 => m

  | M1 a a' =>

      if used_node_bs_1 m' (pf a) && used_node_bs_1 m' a' then m else M0 _

  | M2 m1 m2 =>

      makeM2 _ (clean'1_1 (fun a0 : ad => pf (Ndouble a0)) m' m1)

        (clean'1_1 (fun a0 : ad => pf (Ndouble_plus_one a0)) m' m2)

  end.



Definition clean'1 (m : Map ad) (m' : Map unit) :=

  clean'1_1 (fun a : ad => a) m' m.



Fixpoint clean'2_1 (pf : ad -> ad) (m' : Map unit) 

 (m : Map (Map ad)) {struct m} : Map (Map ad) :=

  match m with

  | M0 => m

  | M1 a y =>

      if used_node_bs_1 m' (pf a) then M1 _ a (clean'1 y m') else M0 _

  | M2 m1 m2 =>

      makeM2 _ (clean'2_1 (fun a0 : ad => pf (Ndouble a0)) m' m1)

        (clean'2_1 (fun a0 : ad => pf (Ndouble_plus_one a0)) m' m2)

  end.



Definition clean'2 (m : Map (Map ad)) (m' : Map unit) :=

  clean'2_1 (fun a : ad => a) m' m.



Fixpoint clean1 (m' : Map unit) (m : Map ad) {struct m} : 

 Map ad :=

  match m with

  | M0 => m

  | M1 a a' => if used_node_bs_1 m' a' then m else M0 _

  | M2 m1 m2 => makeM2 _ (clean1 m' m1) (clean1 m' m2)

  end.



Fixpoint clean2_1 (pf : ad -> ad) (m' : Map unit) (m : Map (Map ad))

 {struct m} : Map (Map ad) :=

  match m with

  | M0 => m

  | M1 a y => if used_node_bs_1 m' (pf a) then M1 _ a (clean1 m' y) else M0 _

  | M2 m1 m2 =>

      makeM2 _ (clean2_1 (fun a0 : ad => pf (Ndouble a0)) m' m1)

        (clean2_1 (fun a0 : ad => pf (Ndouble_plus_one a0)) m' m2)

  end.



Definition clean2 (m : Map (Map ad)) (m' : Map unit) :=

  clean2_1 (fun a : ad => a) m' m.



Fixpoint clean3_1 (pf : ad -> ad) (m' : Map unit) (m : Map (Map (Map ad)))

 {struct m} : Map (Map (Map ad)) :=

  match m with

  | M0 => m

  | M1 a y => if used_node_bs_1 m' (pf a) then M1 _ a (clean2 y m') else M0 _

  | M2 m1 m2 =>

      makeM2 _ (clean3_1 (fun a0 : ad => pf (Ndouble a0)) m' m1)

        (clean3_1 (fun a0 : ad => pf (Ndouble_plus_one a0)) m' m2)

  end.



Definition clean3 (m : Map (Map (Map ad))) (m' : Map unit) :=

  clean3_1 (fun a : ad => a) m' m.



Inductive dummy_mark : Set :=

    DM : Map unit -> dummy_mark.



Definition gc_0 (cfg : BDDconfig) (used : list ad) :=

  match cfg with

  | (bs, (share, (fl, (cnt, (negm, (orm, um)))))) =>

      match DM (mark bs used) with

      | DM marked =>

          let bs' := MapDomRestrTo _ _ bs marked in

          let fl' :=

            MapDomRestrByApp1 _ _ (fun a0 : ad => a0) fl bs marked in

          let share' := clean3 share marked in

          let negm' := clean'1 negm marked in

          let orm' := clean'2 orm marked in

          let um' := clean2 um marked in

          (bs', (share', (fl', (cnt, (negm', (orm', um'))))))

      end

  end.



Definition gc_inf (cfg : BDDconfig) (used : list ad) := cfg.



Definition is_nil (A : Set) (l : list A) :=

  match l with

  | nil => true

  | _ => false

  end.



Definition gc_x (x : ad) (cfg : BDDconfig) :=

  if is_nil _ (fst (snd (snd cfg))) && Nleb x (fst (snd (snd (snd cfg))))

  then gc_0 cfg

  else gc_inf cfg.



Definition gc_x_opt (x : ad) (cfg : BDDconfig) :=

  match fl_of_cfg cfg with

  | nil =>

      match BDDcompare x (cnt_of_cfg cfg) with

      | Datatypes.Lt => gc_0 cfg

      | _ => gc_inf cfg

      end

  | _ => gc_inf cfg

  end.



Lemma add_used_nodes_1_lemma_1 :

 forall (bound : nat) (bs : BDDstate) (node : ad) (marked : Map unit),

 BDDstate_OK bs ->

 nat_of_N (bs_node_height bs node) < bound ->

 forall node' : ad,

 in_dom _ node' marked = true ->

 in_dom _ node' (add_used_nodes_1 bs node marked bound) = true.

Proof.

  simple induction bound.  intros bs node marked H00.  intros.

  absurd (nat_of_N (bs_node_height bs node) < 0).  apply lt_n_O.  assumption.

  intros n H bs node marked H00.  intros.  simpl in |- *.  elim (option_sum _ (MapGet _ marked node)).

  intro y.  elim y; clear y.  intros u H2.  rewrite H2.  simpl in |- *.  elim u.

  assumption.  intro y.  rewrite y.  elim (option_sum _ (MapGet (BDDvar * (ad * ad)) bs node)).

  intro y0.  elim y0; clear y0.  intro x.  elim x; clear x.  intros x y0.

  elim y0; clear y0; intros l r.  intro y0.  rewrite y0.  unfold in_dom in |- *.

  rewrite

   (MapPut_semantics unit

      (add_used_nodes_1 bs r (add_used_nodes_1 bs l marked n) n) node tt

      node').

  elim (sumbool_of_bool (Neqb node node')).  intro y1.  rewrite y1.  reflexivity.

  intro y1.  rewrite y1.  cut (in_dom _ node' (add_used_nodes_1 bs l marked n) = true).

  intro.  cut

   (in_dom _ node' (add_used_nodes_1 bs r (add_used_nodes_1 bs l marked n) n) =

    true).

  intro.  unfold in_dom in H3.  elim

   (option_sum _

      (MapGet unit (add_used_nodes_1 bs r (add_used_nodes_1 bs l marked n) n)

         node')).

  intro y2.  elim y2; intros x0 y3.  rewrite y3.  reflexivity.  intro y2.  rewrite y2 in H3.

  discriminate.  apply H.  assumption.  apply lt_trans_1 with (y := nat_of_N (bs_node_height bs node)).

  apply BDDcompare_lt.  apply bs_node_height_right with (bs := bs) (x := x) (l := l) (r := r).

  assumption.  assumption.  assumption.  assumption.  apply H.  assumption.

  apply lt_trans_1 with (y := nat_of_N (bs_node_height bs node)).  apply BDDcompare_lt.

  apply bs_node_height_left with (bs := bs) (x := x) (l := l) (r := r).  assumption.  assumption.

  assumption.  assumption.  intro y0.  rewrite y0.  assumption.

Qed.



Lemma add_used_nodes_1_lemma_2 :

 forall (bound : nat) (bs : BDDstate) (node : ad) (marked : Map unit),

 BDDstate_OK bs ->

 nat_of_N (bs_node_height bs node) < bound ->

 set_closed bs marked ->

 (forall node' : ad,

  nodes_reachable bs node node' /\ in_dom _ node' bs = true ->

  in_dom _ node' (add_used_nodes_1 bs node marked bound) = true) /\

 (forall node' : ad,

  in_dom _ node' (add_used_nodes_1 bs node marked bound) = true ->

  in_dom _ node' marked = true \/

  in_dom _ node' bs = true /\ nodes_reachable bs node node') /\

 set_closed bs (add_used_nodes_1 bs node marked bound).

Proof.

  simple induction bound.  intros.  absurd (nat_of_N (bs_node_height bs node) < 0).

  apply lt_n_O.  assumption.  intros n H bs node marked H00.  intros.  simpl in |- *.

  elim (option_sum _ (MapGet _ marked node)).

  intro y.  elim y; clear y.  intros u H2.  rewrite H2.  simpl in |- *.  elim u.  split.

  intros.  unfold set_closed in H1.  apply H1 with (node := node).  unfold in_dom in |- *.

  rewrite H2.  reflexivity.  exact (proj1 H3).  exact (proj2 H3).

  split.  intros.  left; assumption.  assumption.  intro y.  rewrite y.

  elim (option_sum _ (MapGet (BDDvar * (ad * ad)) bs node)).  intro y0.  elim y0; clear y0.

  intro x.  elim x; clear x.  intros x y0.  elim y0; clear y0; intros l r.

  intros y0.  rewrite y0.  cut (exists markedl : Map unit, markedl = add_used_nodes_1 bs l marked n).

  intro.  elim H2; clear H2.  intro markedl.  intros.  rewrite <- H2.

  cut (exists markedr : Map unit, markedr = add_used_nodes_1 bs r markedl n).

  intro.  elim H3; clear H3.  intros markedr H3.  rewrite <- H3.

  cut

   ((forall node' : ad,

     nodes_reachable bs l node' /\ in_dom _ node' bs = true ->

     in_dom _ node' markedl = true) /\

    (forall node' : ad,

     in_dom _ node' markedl = true ->

     in_dom _ node' marked = true \/

     in_dom _ node' bs = true /\ nodes_reachable bs l node') /\

    set_closed bs markedl).

  intro.  elim H4; clear H4; intros.  elim H5; clear H5; intros.

  cut

   ((forall node' : ad,

     nodes_reachable bs r node' /\ in_dom _ node' bs = true ->

     in_dom _ node' markedr = true) /\

    (forall node' : ad,

     in_dom _ node' markedr = true ->

     in_dom _ node' markedl = true \/

     in_dom _ node' bs = true /\ nodes_reachable bs r node') /\

    set_closed bs markedr).

  intros.  elim H7; clear H7; intros.  elim H8; clear H8; intros.

  cut

   (forall node' : ad,

    nodes_reachable bs node node' /\

    in_dom (BDDvar * (ad * ad)) node' bs = true ->

    in_dom unit node' (MapPut unit markedr node tt) = true).

  intro.  cut

   (forall node' : ad,

    in_dom unit node' (MapPut unit markedr node tt) = true ->

    in_dom unit node' marked = true \/

    in_dom (BDDvar * (ad * ad)) node' bs = true /\

    nodes_reachable bs node node').

  intros.  split.  assumption.  split.  assumption.  unfold set_closed in |- *.

  intros.  unfold in_dom in H12.  rewrite (MapPut_semantics unit markedr node tt node0) in H12.

  elim (sumbool_of_bool (Neqb node node0)).  intro y1.  rewrite <- (Neqb_complete _ _ y1) in H13.

  apply H10.  split.  assumption.  assumption.  intro y1.  rewrite y1 in H12.

  unfold set_closed in H9.  unfold in_dom in |- *.  rewrite (MapPut_semantics unit markedr node tt node').

  elim (sumbool_of_bool (Neqb node node')).  intro y2.  rewrite y2.  reflexivity.

  intro y2.  rewrite y2.  fold (in_dom _ node' markedr) in |- *.  apply H9 with (node := node0).

  assumption.  assumption.  assumption.  intros.  unfold in_dom in H11.

  rewrite (MapPut_semantics unit markedr node tt node') in H11.

  elim (sumbool_of_bool (Neqb node node')).  intro y1.  rewrite y1 in H11.

  rewrite <- (Neqb_complete _ _ y1).  right.  split.  unfold in_dom in |- *.

  rewrite y0.  reflexivity.  apply nodes_reachable_0.  intro y1.  rewrite y1 in H11.

  fold (in_dom _ node' markedr) in H11.  elim (H8 node' H11).  intro.

  elim (H5 node' H12).  intro.  left; assumption.  intro.  elim H13; clear H13; intros.

  right.  split.  assumption.  apply nodes_reachable_1 with (x := x) (l := l) (r := r).

  assumption.  assumption.  intro.  right.  split.  exact (proj1 H12).

  apply nodes_reachable_2 with (x := x) (l := l) (r := r).  assumption.  exact (proj2 H12).

  intros.  unfold in_dom in |- *.  rewrite (MapPut_semantics unit markedr node tt node').

  elim (sumbool_of_bool (Neqb node node')).  intro y1.  rewrite y1.  reflexivity.

  intro y1.  rewrite y1.  fold (in_dom _ node' markedr) in |- *.  elim H10; clear H10; intros.

  elim (nodes_reachable_lemma_1 bs node node' H10).  intro.  rewrite H12 in y1.

  rewrite (Neqb_correct node') in y1.  discriminate.  intro.  inversion H12.

  inversion H13.  inversion H14.  clear H12 H13 H14.  inversion H15.  clear H15.

  elim H13; clear H13; intro.  rewrite y0 in H12.  injection H12.  clear H12; intros.

  rewrite <- H14 in H13.  rewrite H3.  apply add_used_nodes_1_lemma_1. assumption.

  apply lt_trans_1 with (y := nat_of_N (bs_node_height bs node)).  apply BDDcompare_lt.

  apply bs_node_height_right with (bs := bs) (x := x) (l := l) (r := r).  assumption.  assumption.

  assumption.  apply H4.  split.  assumption.  assumption.  apply H7.  split.

  rewrite y0 in H12.  injection H12; intros.  rewrite H14.  assumption.

  assumption.  rewrite H3.  apply H.  assumption.

  apply lt_trans_1 with (y := nat_of_N (bs_node_height bs node)).

  apply BDDcompare_lt.  apply bs_node_height_right with (bs := bs) (x := x) (l := l) (r := r).

  assumption.  assumption.  assumption.  assumption.  rewrite H2.  apply H.

  assumption.  apply lt_trans_1 with (y := nat_of_N (bs_node_height bs node)).

  apply BDDcompare_lt.  apply bs_node_height_left with (bs := bs) (x := x) (l := l) (r := r).

  assumption.  assumption.  assumption.  assumption.  split with (add_used_nodes_1 bs r markedl n).

  reflexivity.  split with (add_used_nodes_1 bs l marked n).  intros.

  reflexivity.  intro y0.  rewrite y0.  split.  intros.  elim H2; intros.

  elim (nodes_reachable_lemma_1 bs node node' H3).  intro.  rewrite <- H5 in H4.

  unfold in_dom in H4.  rewrite y0 in H4.  discriminate.  intro.  inversion H5.

  inversion H6.  inversion H7.  inversion H8.  rewrite y0 in H9.  discriminate.

  split.  intros.  left; assumption.  assumption.

Qed.



Lemma add_used_nodes_lemma_1 :

 forall (bs : BDDstate) (node : ad) (marked : Map unit),

 BDDstate_OK bs ->

 forall node' : ad,

 in_dom _ node' marked = true ->

 in_dom _ node' (add_used_nodes bs node marked) = true.

Proof.

  intros.  unfold add_used_nodes in |- *.  apply add_used_nodes_1_lemma_1.  assumption.

  unfold lt in |- *.  apply le_n.  assumption.

Qed.



Lemma add_used_nodes_lemma_2 :

 forall (bs : BDDstate) (node : ad) (marked : Map unit),

 BDDstate_OK bs ->

 set_closed bs marked ->

 (forall node' : ad,

  nodes_reachable bs node node' /\ in_dom _ node' bs = true ->

  in_dom _ node' (add_used_nodes bs node marked) = true) /\

 (forall node' : ad,

  in_dom _ node' (add_used_nodes bs node marked) = true ->

  in_dom _ node' marked = true \/

  in_dom _ node' bs = true /\ nodes_reachable bs node node') /\

 set_closed bs (add_used_nodes bs node marked).

Proof.

  intros.  unfold add_used_nodes in |- *.  apply add_used_nodes_1_lemma_2.  assumption.

  unfold lt in |- *.  apply le_n.  assumption.

Qed.



Lemma mark_lemma_1 :

 forall (used : list ad) (bs : BDDstate),

 BDDstate_OK bs ->

 set_closed bs (fold_right (add_used_nodes bs) (M0 unit) used) /\

 (forall node : ad,

  in_dom _ node (fold_right (add_used_nodes bs) (M0 unit) used) = true <->

  (exists node' : ad,

     In node' used /\

     nodes_reachable bs node' node /\ in_dom _ node bs = true)).

Proof.

  simple induction used.  intros.  simpl in |- *.  split.  unfold set_closed in |- *.  unfold in_dom in |- *.

  simpl in |- *.  intros; discriminate.  unfold in_dom in |- *.  simpl in |- *.  split.

  intro; discriminate.  intro.  inversion H0.  absurd False.

  unfold not in |- *; trivial.  exact (proj1 H1).  intros.  simpl in |- *.  split.

  refine

   (proj2

      (proj2

         (add_used_nodes_lemma_2 bs a

            (fold_right (add_used_nodes bs) (M0 unit) l) _ _))).

  assumption.  exact (proj1 (H bs H0)).  split.  intro.

  elim

   (add_used_nodes_lemma_2 bs a (fold_right (add_used_nodes bs) (M0 unit) l)

      H0).

  intros.  elim H3; clear H3; intros.  elim (H3 node H1).  intro.

  elim (proj1 (proj2 (H bs H0) node)).  intros.  split with x.  split.

  right.  exact (proj1 H6).  exact (proj2 H6).  assumption.  intro.

  split with a.  split.  left; reflexivity.  split.  exact (proj2 H5).

  exact (proj1 H5).  exact (proj1 (H bs H0)).  intro.

  elim H1; clear H1.  intros.  elim H1; clear H1; intros.

  elim H1; clear H1.  intros.  rewrite <- H1 in H2.

  apply

   (proj1

      (add_used_nodes_lemma_2 bs a

         (fold_right (add_used_nodes bs) (M0 unit) l) H0 

         (proj1 (H bs H0)))).

  assumption.  intro.  lapply (proj2 (proj2 (H bs H0) node)).  intro.

  refine (add_used_nodes_lemma_1 _ _ _ _ _ _).  assumption.  assumption.

  split with x.  split.  assumption.  assumption.

Qed.



Lemma mark_lemma_2 :

 forall (bs : BDDstate) (used : list ad),

 BDDstate_OK bs ->

 forall node : ad,

 in_dom _ node (mark bs used) = true <->

 (exists node' : ad,

    In node' used /\ nodes_reachable bs node' node /\ in_dom _ node bs = true).

Proof.

  intros.  unfold mark in |- *.  apply (proj2 (mark_lemma_1 used bs H)).

Qed.



Lemma mark_lemma_3 :

 forall (bs : BDDstate) (used : list ad),

 BDDstate_OK bs ->

 forall node : ad,

 in_dom _ node (mark bs used) = true <->

 used_node_bs bs used node /\ in_dom _ node bs = true.

Proof.

  split.  intro.  elim (proj1 (mark_lemma_2 _ _ H _) H0).  intros.

  split.  unfold used_node_bs in |- *.  split with x.  split.  exact (proj1 H1).

  exact (proj1 (proj2 H1)).  exact (proj2 (proj2 H1)).  intro.

  apply (proj2 (mark_lemma_2 bs used H node)).  elim H0; intros.

  elim H1; intros.  split with x.  split.  exact (proj1 H3).  split.

  exact (proj2 H3).  assumption.

Qed.



Lemma new_bs_lemma_1 :

 forall (bs : BDDstate) (used : list ad),

 BDDstate_OK bs ->

 forall node : ad,

 used_node_bs bs used node ->

 MapGet _ bs node = MapGet _ (new_bs bs used) node.

Proof.

  intros.  unfold new_bs in |- *.  rewrite (MapDomRestrTo_semantics _ _ bs (mark bs used) node).

  elim (option_sum _ (MapGet unit (mark bs used) node)).  intro y.

  elim y; clear y; intros x y.  rewrite y.  reflexivity.  intro y.  rewrite y.

  elim (option_sum _ (MapGet (BDDvar * (ad * ad)) bs node)).  intro y0.

  elim y0; clear y0; intros x y0.  cut (in_dom _ node (mark bs used) = true).

  unfold in_dom in |- *.  rewrite y.  intro.  discriminate.  

  apply (proj2 (mark_lemma_3 bs used H node)).  split.  assumption.  

  unfold in_dom in |- *.  rewrite y0.  reflexivity.  tauto.

Qed.



Lemma new_bs_lemma_2 :

 forall (bs : BDDstate) (used : list ad),

 BDDstate_OK bs ->

 forall node : ad,

 in_dom _ node (new_bs bs used) = true -> used_node_bs bs used node.

Proof.

  intros.  unfold new_bs in H0.  unfold in_dom in H0.

  rewrite

   (MapDomRestrTo_semantics (BDDvar * (ad * ad)) unit bs (mark bs used) node)

    in H0.

  elim (option_sum _ (MapGet unit (mark bs used) node)).  intro y.

  elim y; clear y; intros x y.  cut (in_dom _ node (mark bs used) = true).  intro.

  elim (proj1 (mark_lemma_3 bs used H node) H1).  tauto.  unfold in_dom in |- *.

  rewrite y.  reflexivity.  intro y.  rewrite y in H0.  discriminate.  

Qed.



Lemma no_new_node_new_bs :

 forall (bs : BDDstate) (used : list ad),

 BDDstate_OK bs -> no_new_node_bs bs (new_bs bs used).

Proof.

  intros.  unfold no_new_node_bs in |- *.  intros.  cut (used_node_bs bs used node).

  intro.  rewrite (new_bs_lemma_1 bs used H node H1).  assumption.

  apply new_bs_lemma_2.  assumption.  unfold in_dom in |- *.  rewrite H0.  reflexivity.

Qed.



Lemma new_bs_zero :

 forall (bs : BDDstate) (used : list ad),

 BDDstate_OK bs -> in_dom _ BDDzero (new_bs bs used) = false.

Proof.

  intros.  apply not_true_is_false.  unfold not in |- *; intro.

  cut (MapGet _ bs BDDzero = MapGet _ (new_bs bs used) BDDzero).

  rewrite (proj1 H).  intro.  unfold in_dom in H0.  rewrite <- H1 in H0.

  discriminate.  apply new_bs_lemma_1.  assumption.  apply new_bs_lemma_2.

  assumption.  assumption.

Qed.



Lemma new_bs_one :

 forall (bs : BDDstate) (used : list ad),

 BDDstate_OK bs -> in_dom _ BDDone (new_bs bs used) = false.

Proof.

  intros.  apply not_true_is_false.  unfold not in |- *; intro.

  cut (MapGet _ bs BDDone = MapGet _ (new_bs bs used) BDDone).

  rewrite (proj1 (proj2 H)).  intro.  unfold in_dom in H0.

  rewrite <- H1 in H0.  discriminate.  apply new_bs_lemma_1.  assumption.

  apply new_bs_lemma_2.  assumption.  assumption.

Qed.



Lemma new_bs_BDDhigh :

 forall (bs : BDDstate) (used : list ad) (x : BDDvar) (l r node : ad),

 BDDstate_OK bs ->

 MapGet _ (new_bs bs used) node = Some (x, (l, r)) ->

 in_dom _ r (new_bs bs used) = in_dom _ r bs.

Proof.

  intros.  cut (MapGet _ (new_bs bs used) r = MapGet _ bs r).  intro.

  unfold in_dom in |- *.  rewrite H1.  reflexivity.  symmetry  in |- *.  apply new_bs_lemma_1.

  assumption.  unfold used_node_bs in |- *.  cut (used_node_bs bs used node).  intro.

  elim H1.  intros.  split with x0.  split.  exact (proj1 H2).  

  apply nodes_reachable_trans with (node2 := node).  exact (proj2 H2).

  apply nodes_reachable_2 with (x := x) (l := l) (r := r).  rewrite <- H0.

  apply new_bs_lemma_1.  assumption.  assumption.  apply nodes_reachable_0.

  apply new_bs_lemma_2.  assumption.  unfold in_dom in |- *.  rewrite H0.  reflexivity.

Qed.



Lemma new_bs_BDDlow :

 forall (bs : BDDstate) (used : list ad) (x : BDDvar) (l r node : ad),

 BDDstate_OK bs ->

 MapGet _ (new_bs bs used) node = Some (x, (l, r)) ->

 in_dom _ l (new_bs bs used) = in_dom _ l bs.

Proof.

  intros.  cut (MapGet _ (new_bs bs used) l = MapGet _ bs l).  intro.

  unfold in_dom in |- *.  rewrite H1.  reflexivity.  symmetry  in |- *.  apply new_bs_lemma_1.

  assumption.  unfold used_node_bs in |- *.  cut (used_node_bs bs used node).  intro.

  elim H1.  intros.  split with x0.  split.  exact (proj1 H2).

  apply nodes_reachable_trans with (node2 := node).  exact (proj2 H2).

  apply nodes_reachable_1 with (x := x) (l := l) (r := r).  rewrite <- H0.

  apply new_bs_lemma_1.  assumption.  assumption.  apply nodes_reachable_0.

  apply new_bs_lemma_2.  assumption.  unfold in_dom in |- *.  rewrite H0.  reflexivity.

Qed.



Lemma new_bs_used_nodes_preserved :

 forall (bs : BDDstate) (used : list ad) (node : ad),

 BDDstate_OK bs ->

 used_node_bs bs used node -> node_preserved_bs bs (new_bs bs used) node.

Proof.

  intros.  unfold node_preserved_bs in |- *.  intros.

  rewrite <- (new_bs_lemma_1 _ used H node').  assumption.  elim H0.  intros.

  split with x0.  split.  exact (proj1 H3).  

  apply nodes_reachable_trans with (node2 := node).  exact (proj2 H3).

  assumption.

Qed.



Lemma new_bsBDDbounded_1 :

 forall (n : nat) (bs : BDDstate) (used : list ad) (node : ad) (x : BDDvar),

 BDDstate_OK bs ->

 n = nat_of_N x ->

 in_dom _ node (new_bs bs used) = true ->

 BDDbounded bs node x -> BDDbounded (new_bs bs used) node x.

Proof.

  intro.  apply

   lt_wf_ind

    with

      (P := fun n : nat =>

            forall (bs : BDDstate) (used : list ad) (node : ad) (x : BDDvar),

            BDDstate_OK bs ->

            n = nat_of_N x ->

            in_dom (BDDvar * (ad * ad)) node (new_bs bs used) = true ->

            BDDbounded bs node x -> BDDbounded (new_bs bs used) node x).

  clear n.  intro.  intro H00.  intros.  elim (BDDbounded_lemma bs node x H2).

  intro.  rewrite H3.  apply BDDbounded_0.  intro.  elim H3; clear H3; intro.

  rewrite H3.  apply BDDbounded_1.  elim H3; clear H3.  intros x0 H3.

  elim H3; clear H3.  intros l H3.  elim H3; clear H3.  intros r H3.

  elim H3; clear H3; intros.  elim H4; clear H4; intros.

  elim H5; clear H5; intros.  elim H6; clear H6; intros.

  cut (MapGet _ (new_bs bs used) node = Some (x0, (l, r))).  intro.

  cut (BDDbounded (new_bs bs used) l x0).  cut (BDDbounded (new_bs bs used) r x0).

  intros.  apply BDDbounded_2 with (x := x0) (l := l) (r := r).  assumption.  assumption.

  assumption.  assumption.  assumption.  cut (node_OK bs r).  intro.

  unfold node_OK in H9.  elim H9; intro.  rewrite H10.  apply BDDbounded_0.

  elim H10; intro.  rewrite H11.  apply BDDbounded_1.

  apply H00 with (m := nat_of_N x0).  rewrite H0.  apply BDDcompare_lt.

  assumption.  assumption.  reflexivity.  rewrite <- H11.

  apply new_bs_BDDhigh with (x := x0) (l := l) (node := node).  assumption.  assumption.

  assumption.  apply BDDbounded_node_OK with (n := x0).  assumption.

  cut (node_OK bs l).  intro.  unfold node_OK in H9.  elim H9; intro.

  rewrite H10.  apply BDDbounded_0.  elim H10; intro.  rewrite H11.

  apply BDDbounded_1.  apply H00 with (m := nat_of_N x0).  rewrite H0.

  apply BDDcompare_lt.  assumption.  assumption.  reflexivity.  rewrite <- H11.

  apply new_bs_BDDlow with (x := x0) (r := r) (node := node).  assumption.  assumption.

  assumption.  apply BDDbounded_node_OK with (n := x0).  assumption.

  elim (option_sum _ (MapGet (BDDvar * (ad * ad)) (new_bs bs used) node)).  intro y.

  elim y; clear y; intro x1.  elim x1; clear x1.  intro y.  intro y0.

  elim y0; intros y1 y2 y3.  rewrite <- H3.  symmetry  in |- *.  apply new_bs_lemma_1.

   assumption.  apply new_bs_lemma_2.  assumption.  unfold in_dom in |- *.  rewrite y3.

  unfold in_dom in |- *.  reflexivity.  intro y.  unfold in_dom in H1.  rewrite y in H1.  

  discriminate.

Qed.



Lemma new_bs_OK :

 forall (bs : BDDstate) (used : list ad),

 BDDstate_OK bs -> BDDstate_OK (new_bs bs used).

Proof.

  intros.  unfold BDDstate_OK in |- *.  unfold BDDstate_OK in H.  split.

  lapply (new_bs_zero bs used).  unfold in_dom in |- *.

  elim (MapGet (BDDvar * (ad * ad)) (new_bs bs used) BDDzero).  Focus 2. reflexivity.  intros.

  discriminate.  assumption.  split.  lapply (new_bs_one bs used).

  unfold in_dom in |- *.  elim (MapGet (BDDvar * (ad * ad)) (new_bs bs used) BDDone).

  Focus 2.

  reflexivity.  intros.  discriminate.  assumption.  intros a H0.  unfold BDD_OK in |- *.

  cut (BDD_OK bs a).  unfold BDD_OK in |- *.

  cut

   (MapGet (BDDvar * (ad * ad)) (new_bs bs used) a =

    MapGet (BDDvar * (ad * ad)) bs a).

  intro.  rewrite H1.  elim (MapGet (BDDvar * (ad * ad)) bs a).  Focus 2. tauto.  intro a0.

  elim a0.  intros y y0 H2.  apply new_bsBDDbounded_1 with (n := nat_of_N (ad_S y)).

  assumption.  reflexivity.  assumption.  assumption.  symmetry  in |- *.

  apply new_bs_lemma_1.  assumption.  apply new_bs_lemma_2.  assumption.

  assumption.  apply (proj2 (proj2 H)).

  cut (MapGet _ bs a = MapGet _ (new_bs bs used) a).  intro.  unfold in_dom in |- *.

  rewrite H1.  assumption.  apply new_bs_lemma_1.  assumption.  

  apply new_bs_lemma_2.  assumption.  assumption.

Qed.



Lemma new_cnt_OK :

 forall (bs : BDDstate) (used : list ad) (cnt : ad),

 BDDstate_OK bs -> cnt_OK bs cnt -> cnt_OK (new_bs bs used) cnt.

Proof.

  intros.  unfold cnt_OK in |- *.  unfold cnt_OK in H0.

  elim H0; clear H0; intros.  split.  assumption.  intros.

  elim (option_sum _ (MapGet (BDDvar * (ad * ad)) (new_bs bs used) a)).  intro y.

  elim y; clear y; intros x y.  cut (used_node_bs bs used a).  intro.

  rewrite <- (new_bs_lemma_1 bs used H a H3).  apply H1.  assumption.

  apply new_bs_lemma_2.  assumption.  unfold in_dom in |- *.  rewrite y.  reflexivity.

  tauto.

Qed.



Lemma new_fl_OK :

 forall (bs : BDDstate) (used : list ad) (fl : BDDfree_list) (cnt : ad),

 BDDstate_OK bs ->

 BDDfree_list_OK bs fl cnt ->

 cnt_OK bs cnt -> BDDfree_list_OK (new_bs bs used) (new_fl bs used fl) cnt.

Proof.

  unfold BDDfree_list_OK in |- *.  intros bs used fl cnt H H0 H00.

  elim H0; clear H0; intros.  split.  unfold new_fl in |- *.

  apply MapDomRestrByApp1_lemma_4 with (fp := fun a0 : ad => a0).  reflexivity.

  intros.  unfold not in |- *.  intro.  unfold in_dom in H2.

  rewrite (proj2 (proj2 (proj1 (H1 a) H4))) in H2.  discriminate.

  assumption.  split.  intros.  unfold new_fl in H2.  unfold BDDfree_list in fl.

  unfold BDDstate in bs.  cut (forall a : ad, (fun a0 : ad => a0) ((fun a0 : ad => a0) a) = a).  intro.

  elim

   (MapDomRestrByApp1_lemma_3 (BDDvar * (ad * ad)) unit bs 

      (mark bs used) fl (fun a : ad => a) (fun a : ad => a) H3 node H2).

  intro.  elim (proj1 (H1 node) H4).  intros.  elim H6; clear H6; intros.

  split.  assumption.  split.  assumption.  

  elim (option_sum _ (MapGet (BDDvar * (ad * ad)) (new_bs bs used) node)).  intro y.

  elim y; clear y; intro x.  elim x.  intro y.  intro y0.  elim y0.  intros y1 y2 y3.

  rewrite (no_new_node_new_bs bs used H y y1 y2 node) in H7.  discriminate.

  assumption.  tauto.  intro.  elim H4; clear H4; intros.

  elim H5; clear H5; intros.  clear H6.  unfold cnt_OK in H00.  split.

  apply ad_gt_1_lemma.  unfold not in |- *; intro.  unfold BDDstate_OK in H.

  unfold BDDzero in H.  rewrite <- H6 in H.  unfold in_dom in H4.

  rewrite (proj1 H) in H4.  discriminate.  unfold not in |- *; intro.

  unfold BDDstate_OK in H.  unfold BDDone in H.  rewrite <- H6 in H.

  unfold in_dom in H4.  rewrite (proj1 (proj2 H)) in H4.  discriminate.

  split.  apply Nltb_lebmma.  apply not_true_is_false.  unfold not in |- *; intro.

  unfold in_dom in H4.  rewrite (proj2 H00 _ H6) in H4.  discriminate.

  elim (option_sum _ (MapGet (BDDvar * (ad * ad)) (new_bs bs used) node)).  intro y.

  elim y; clear y; intros x y.  cut (used_node_bs bs used node).  intro.  elim H6.

  intros.  cut (in_dom unit node (mark bs used) = true).  intro.

  rewrite H8 in H5.  discriminate.  apply (proj2 (mark_lemma_2 bs used H node)).

  split with x0.  split.  exact (proj1 H7).  split.  exact (proj2 H7).

  assumption.  apply new_bs_lemma_2.  assumption.  unfold in_dom in |- *.  rewrite y.

  reflexivity.  tauto.  reflexivity.  intro.



  elim H2; intros H3 H4; elim H4; intros H5 H6; clear H4.

  elim (option_sum _ (MapGet (BDDvar * (ad * ad)) bs node)).  intro y.  elim y; clear y.

  intro x.  elim x; clear x.  intros x y.  elim y; clear y; intros l r H7.

  unfold new_fl in |- *.  apply MapDomRestrByApp1_lemma_2 with (pf := fun a0 : ad => a0).

  unfold in_dom in |- *.  rewrite H7.  reflexivity.  apply not_true_is_false.

  unfold not in |- *.  intro.  cut (used_node_bs bs used node).  intro.

  rewrite (new_bs_lemma_1 bs used H node H8) in H7.  rewrite H6 in H7.

  discriminate.  exact (proj1 (proj1 (mark_lemma_3 bs used H node) H4)).

  intro.  unfold new_fl in |- *.  apply MapDomRestrByApp1_lemma_1.

  apply (proj2 (H1 node)).  split.  assumption.  split.  assumption.

  assumption.

Qed.



Lemma used_node_bs_1_preserved :

 forall (bs : BDDstate) (used : list ad) (node : ad),

 BDDstate_OK bs ->

 used_node_bs_1 (mark bs used) node = true ->

 node_preserved_bs bs (new_bs bs used) node.

Proof.

  intros.  unfold used_node_bs_1 in H0.

  elim (option_sum _ (MapGet unit (mark bs used) node)).  intro y.  inversion y.

  apply new_bs_used_nodes_preserved.  assumption.

  refine (proj1 (proj1 (mark_lemma_3 bs used H node) _)).

  unfold in_dom in |- *.  rewrite H1.  reflexivity.  intro y.  rewrite y in H0.

  elim (orb_prop _ _ H0).  intro.  rewrite (Neqb_complete _ _ H1).

  apply BDDzero_preserved.  assumption.  intro.

  rewrite (Neqb_complete _ _ H1).  apply BDDone_preserved.  assumption.

Qed.



Lemma clean'1_1_lemma :

 forall (m : Map ad) (m' : Map unit) (pf : ad -> ad) (a a' : ad),

 MapGet _ (clean'1_1 pf m' m) a = Some a' <->

 used_node_bs_1 m' (pf a) && used_node_bs_1 m' a' = true /\

 MapGet _ m a = Some a'.

Proof.

  simple induction m.  simpl in |- *.  intros.  split.  intro.  discriminate.  tauto.  intros.

  simpl in |- *.  split.  intro.

  elim (sumbool_of_bool (used_node_bs_1 m' (pf a) && used_node_bs_1 m' a0)).

  intro y.  rewrite y in H.  simpl in H.  elim (sumbool_of_bool (Neqb a a1)).

  intro y0.  rewrite y0 in H.  injection H.  intro.  split.  rewrite H0 in y.

  rewrite (Neqb_complete _ _ y0) in y.  assumption.  rewrite y0.  assumption.

  intro y0.  rewrite y0 in H.  discriminate.  intro y.  rewrite y in H.  simpl in H.

  discriminate.  intro.  elim H; clear H; intros.  elim (sumbool_of_bool (Neqb a a1)).

  intro y.  rewrite y in H0.  injection H0.  intro.  rewrite H1.

  rewrite (Neqb_complete _ _ y).  rewrite H.  simpl in |- *.

  rewrite (Neqb_correct a1).  reflexivity.  intro y.  rewrite y in H0.

  discriminate.  intros.  split.  intro.  simpl in H1.

  rewrite

   (makeM2_M2 _ (clean'1_1 (fun a0 : ad => pf (Ndouble a0)) m' m0)

      (clean'1_1 (fun a0 : ad => pf (Ndouble_plus_one a0)) m' m1) a)

    in H1.

  rewrite

   (MapGet_M2_bit_0_if _ (clean'1_1 (fun a0 : ad => pf (Ndouble a0)) m' m0)

      (clean'1_1 (fun a0 : ad => pf (Ndouble_plus_one a0)) m' m1) a)

    in H1.

  elim (sumbool_of_bool (Nbit0 a)).  intro y.  rewrite y in H1.

  rewrite (MapGet_M2_bit_0_if _ m0 m1 a).  rewrite y.

  lapply

   (proj1 (H0 m' (fun a0 : ad => pf (Ndouble_plus_one a0)) (Ndiv2 a) a')).

  intro.  rewrite (Ndiv2_double_plus_one a) in H2.  assumption.  assumption.

  assumption.  intro y.  rewrite y in H1.  rewrite (MapGet_M2_bit_0_if _ m0 m1 a).

  rewrite y.  lapply (proj1 (H m' (fun a0 : ad => pf (Ndouble a0)) (Ndiv2 a) a')).

  intro.  rewrite (Ndiv2_double a) in H2.  assumption.  assumption.

  assumption.  intro.  simpl in |- *.

  rewrite

   (makeM2_M2 _ (clean'1_1 (fun a0 : ad => pf (Ndouble a0)) m' m0)

      (clean'1_1 (fun a0 : ad => pf (Ndouble_plus_one a0)) m' m1) a)

   .

  rewrite

   (MapGet_M2_bit_0_if _ (clean'1_1 (fun a0 : ad => pf (Ndouble a0)) m' m0)

      (clean'1_1 (fun a0 : ad => pf (Ndouble_plus_one a0)) m' m1) a)

   .

  elim (sumbool_of_bool (Nbit0 a)).  intro y.  rewrite y.

  rewrite (MapGet_M2_bit_0_if _ m0 m1 a) in H1.  rewrite y in H1.

  apply

   (proj2 (H0 m' (fun a0 : ad => pf (Ndouble_plus_one a0)) (Ndiv2 a) a')).

  rewrite (Ndiv2_double_plus_one _ y).  assumption.  intro y.  rewrite y.

  rewrite (MapGet_M2_bit_0_if _ m0 m1 a) in H1.  rewrite y in H1.

  apply (proj2 (H m' (fun a0 : ad => pf (Ndouble a0)) (Ndiv2 a) a')).

  rewrite (Ndiv2_double _ y).  assumption.

Qed.



Lemma clean'1_lemma :

 forall (m : Map ad) (m' : Map unit) (a a' : ad),

 MapGet _ (clean'1 m m') a = Some a' <->

 used_node_bs_1 m' a && used_node_bs_1 m' a' = true /\

 MapGet _ m a = Some a'.

Proof.

  intros.  unfold clean'1 in |- *.  apply clean'1_1_lemma with (pf := fun a : ad => a).

Qed.



Lemma clean'2_1_lemma :

 forall (m : Map (Map ad)) (m' : Map unit) (pf : ad -> ad) (a b c : ad),

 MapGet2 _ (clean'2_1 pf m' m) a b = Some c <->

 used_node_bs_1 m' (pf a) && (used_node_bs_1 m' b && used_node_bs_1 m' c) =

 true /\ MapGet2 _ m a b = Some c.

Proof.

  simple induction m.  simpl in |- *.  intros.  split.  intro.  unfold MapGet2 in H.

  simpl in H.  discriminate.  tauto.  intros.  unfold MapGet2 in |- *.  simpl in |- *.  split.

  intro.  elim (sumbool_of_bool (used_node_bs_1 m' (pf a))).  intro y.

  rewrite y in H.  simpl in H.  elim (sumbool_of_bool (Neqb a a1)).  intro y0.

  rewrite y0 in H.  rewrite y0.  rewrite <- (Neqb_complete _ _ y0).

  rewrite y.  simpl in |- *.  apply (proj1 (clean'1_lemma a0 m' b c)).  assumption.

  intro y0.  rewrite y0 in H.  discriminate.  intro y.  rewrite y in H.  simpl in H.

  discriminate.  intro.  elim H; clear H; intros.  elim (andb_prop _ _ H).

  clear H; intros.  elim (sumbool_of_bool (Neqb a a1)).  intro y.

  rewrite y in H0.  rewrite <- (Neqb_complete _ _ y) in H.  rewrite H.

  simpl in |- *.  rewrite y.  apply (proj2 (clean'1_lemma a0 m' b c)).  split.

  assumption.  assumption.  intro y.  rewrite y in H0.  discriminate.  intros.

  split.  intro.  unfold MapGet2 in H1.  simpl in H1.

  rewrite

   (makeM2_M2 _ (clean'2_1 (fun a0 : ad => pf (Ndouble a0)) m' m0)

      (clean'2_1 (fun a0 : ad => pf (Ndouble_plus_one a0)) m' m1) a)

    in H1.

  rewrite

   (MapGet_M2_bit_0_if _ (clean'2_1 (fun a0 : ad => pf (Ndouble a0)) m' m0)

      (clean'2_1 (fun a0 : ad => pf (Ndouble_plus_one a0)) m' m1) a)

    in H1.

  unfold MapGet2 in |- *.  rewrite (MapGet_M2_bit_0_if _ m0 m1 a).

  elim (sumbool_of_bool (Nbit0 a)).  intro y.  rewrite y.  rewrite y in H1.

  lapply

   (proj1 (H0 m' (fun a0 : ad => pf (Ndouble_plus_one a0)) (Ndiv2 a) b c)).

  intro.  elim H2; intros.  unfold MapGet2 in H4.  split.

  rewrite (Ndiv2_double_plus_one a y) in H3.  assumption.  assumption.

  assumption.  intro y.  rewrite y in H1.  rewrite y.

  lapply (proj1 (H m' (fun a0 : ad => pf (Ndouble a0)) (Ndiv2 a) b c)).  intro.

  rewrite (Ndiv2_double a y) in H2.  assumption.  assumption.  intros.

  simpl in |- *.  unfold MapGet2 in |- *.

  rewrite

   (makeM2_M2 _ (clean'2_1 (fun a0 : ad => pf (Ndouble a0)) m' m0)

      (clean'2_1 (fun a0 : ad => pf (Ndouble_plus_one a0)) m' m1) a)

   .

  rewrite

   (MapGet_M2_bit_0_if _ (clean'2_1 (fun a0 : ad => pf (Ndouble a0)) m' m0)

      (clean'2_1 (fun a0 : ad => pf (Ndouble_plus_one a0)) m' m1) a)

   .

  unfold MapGet2 in H1.  rewrite (MapGet_M2_bit_0_if _ m0 m1 a) in H1.

  elim (sumbool_of_bool (Nbit0 a)).  intro y.  rewrite y.  rewrite y in H1.

  lapply

   (proj2 (H0 m' (fun a0 : ad => pf (Ndouble_plus_one a0)) (Ndiv2 a) b c)).

  intro.  assumption.  rewrite (Ndiv2_double_plus_one _ y).  assumption.

  intro y.  rewrite y in H1.  rewrite y.

  apply (proj2 (H m' (fun a0 : ad => pf (Ndouble a0)) (Ndiv2 a) b c)).

  rewrite (Ndiv2_double _ y).  assumption.

Qed.



Lemma clean'2_lemma :

 forall (m : Map (Map ad)) (m' : Map unit) (a b c : ad),

 MapGet2 _ (clean'2 m m') a b = Some c <->

 used_node_bs_1 m' a && (used_node_bs_1 m' b && used_node_bs_1 m' c) = true /\

 MapGet2 _ m a b = Some c.

Proof.

  unfold clean'2 in |- *.  intros.  apply clean'2_1_lemma with (pf := fun a : ad => a).

Qed.



Lemma clean1_lemma :

 forall (m' : Map unit) (m : Map ad) (a a' : ad),

 MapGet _ (clean1 m' m) a = Some a' <->

 used_node_bs_1 m' a' = true /\ MapGet _ m a = Some a'.

Proof.

  simple induction m.  simpl in |- *.  split.  intro.  discriminate.  intro.  elim H.  intros.

  discriminate.  simpl in |- *.  split.  intros.

  elim (sumbool_of_bool (used_node_bs_1 m' a0)).  intro y.  rewrite y in H.

  simpl in H.  elim (sumbool_of_bool (Neqb a a1)).  intro y0.  rewrite y0 in H.

  injection H.  intro.  rewrite y0.  rewrite H0.  rewrite H0 in y.  split.

  assumption.  reflexivity.  intro y0.  rewrite y0 in H.  discriminate.  intro y.

  rewrite y in H.  simpl in H.  discriminate.  intro.  elim H; intros.

  elim (sumbool_of_bool (Neqb a a1)).  intro y.  rewrite y in H1.  injection H1.

  intro.  rewrite H2.  rewrite H0.  simpl in |- *.  rewrite y.  reflexivity.  intro y.

  rewrite y in H1.  discriminate.  intros.  split.  intro.  simpl in H1.

  rewrite (makeM2_M2 _ (clean1 m' m0) (clean1 m' m1) a) in H1.

  rewrite (MapGet_M2_bit_0_if _ (clean1 m' m0) (clean1 m' m1) a) in H1.

  rewrite (MapGet_M2_bit_0_if _ m0 m1 a).  elim (sumbool_of_bool (Nbit0 a)).

  intro y.  rewrite y.  apply (proj1 (H0 (Ndiv2 a) a')).  rewrite y in H1.

  assumption.  intro y.  rewrite y.  rewrite y in H1.

  apply (proj1 (H (Ndiv2 a) a')).  assumption.  intro.

  rewrite (MapGet_M2_bit_0_if _ m0 m1 a) in H1.  simpl in |- *.

  rewrite (makeM2_M2 _ (clean1 m' m0) (clean1 m' m1) a).

  rewrite (MapGet_M2_bit_0_if _ (clean1 m' m0) (clean1 m' m1) a).

  elim (sumbool_of_bool (Nbit0 a)).  intro y.  rewrite y.  rewrite y in H1.

  apply (proj2 (H0 (Ndiv2 a) a')).  assumption.  intro y.  rewrite y in H1.

  rewrite y.  apply (proj2 (H (Ndiv2 a) a')).  assumption.

Qed.



Lemma clean2_1_lemma :

 forall (m' : Map unit) (m : Map (Map ad)) (pf : ad -> ad) (a b c : ad),

 MapGet2 _ (clean2_1 pf m' m) a b = Some c <->

 used_node_bs_1 m' (pf a) && used_node_bs_1 m' c = true /\

 MapGet2 _ m a b = Some c.

Proof.

  simple induction m.  unfold MapGet2 in |- *.  simpl in |- *.  split.  intro.  discriminate.  tauto.

  simpl in |- *.  split.  intro.  unfold MapGet2 in |- *.  simpl in |- *.  unfold MapGet2 in H.

  elim (sumbool_of_bool (used_node_bs_1 m' (pf a))).  intro y.  rewrite y in H.

  simpl in H.  elim (sumbool_of_bool (Neqb a a1)).  intro y0.  rewrite y0 in H.

  rewrite y0.  rewrite <- (Neqb_complete _ _ y0).  rewrite y.  simpl in |- *.

  apply (proj1 (clean1_lemma m' a0 b c)).  assumption.  intro y0.

  rewrite y0 in H.  discriminate.  intro y.  rewrite y in H.  simpl in H.

  discriminate.  intro.  unfold MapGet2 in |- *.  unfold MapGet2 in H.  simpl in H.

  elim (sumbool_of_bool (Neqb a a1)).  intro y.  rewrite y in H.

  elim H; intros.  rewrite <- (Neqb_complete _ _ y).

  rewrite <- (Neqb_complete _ _ y) in H0.  elim (andb_prop _ _ H0).  intros.

  rewrite H2.  simpl in |- *.  rewrite (Neqb_correct a).

  apply (proj2 (clean1_lemma m' a0 b c)).  split.  assumption.  assumption.

  intro y.  rewrite y in H.  elim H; intros.  discriminate.  intros.  split.

  intro.  simpl in H1.  unfold MapGet2 in H1.

  rewrite

   (makeM2_M2 (Map ad) (clean2_1 (fun a0 : ad => pf (Ndouble a0)) m' m0)

      (clean2_1 (fun a0 : ad => pf (Ndouble_plus_one a0)) m' m1) a)

    in H1.

  rewrite

   (MapGet_M2_bit_0_if _ (clean2_1 (fun a0 : ad => pf (Ndouble a0)) m' m0)

      (clean2_1 (fun a0 : ad => pf (Ndouble_plus_one a0)) m' m1) a)

    in H1.

  unfold MapGet2 in |- *.  rewrite (MapGet_M2_bit_0_if _ m0 m1 a).

  elim (sumbool_of_bool (Nbit0 a)).  intro y.  rewrite y.  rewrite y in H1.

  lapply

   (proj1 (H0 (fun a0 : ad => pf (Ndouble_plus_one a0)) (Ndiv2 a) b c)).

  intro.  rewrite (Ndiv2_double_plus_one a y) in H2.  assumption.  

  assumption.  intro y.  rewrite y.  rewrite y in H1.

  lapply (proj1 (H (fun a0 : ad => pf (Ndouble a0)) (Ndiv2 a) b c)).

  rewrite (Ndiv2_double a y).  tauto.  assumption.  intro.  simpl in |- *.

  unfold MapGet2 in |- *.  unfold MapGet2 in H1.

  rewrite

   (makeM2_M2 _ (clean2_1 (fun a0 : ad => pf (Ndouble a0)) m' m0)

      (clean2_1 (fun a0 : ad => pf (Ndouble_plus_one a0)) m' m1) a)

   .

  rewrite

   (MapGet_M2_bit_0_if _ (clean2_1 (fun a0 : ad => pf (Ndouble a0)) m' m0)

      (clean2_1 (fun a0 : ad => pf (Ndouble_plus_one a0)) m' m1) a)

   .

  rewrite (MapGet_M2_bit_0_if _ m0 m1 a) in H1.

  elim (sumbool_of_bool (Nbit0 a)).  intro y.  rewrite y.  rewrite y in H1.

  apply

   (proj2 (H0 (fun a0 : ad => pf (Ndouble_plus_one a0)) (Ndiv2 a) b c)).

  rewrite (Ndiv2_double_plus_one _ y).  assumption.  intro y.  rewrite y in H1.

  rewrite y.  apply (proj2 (H (fun a0 : ad => pf (Ndouble a0)) (Ndiv2 a) b c)).

  rewrite (Ndiv2_double _ y).  assumption.

Qed.



Lemma clean2_lemma :

 forall (m : Map (Map ad)) (m' : Map unit) (a b c : ad),

 MapGet2 _ (clean2 m m') a b = Some c <->

 used_node_bs_1 m' a && used_node_bs_1 m' c = true /\

 MapGet2 _ m a b = Some c.

Proof.

  intros.  unfold clean2 in |- *.  apply clean2_1_lemma with (pf := fun a : ad => a).

Qed.



Lemma clean3_1_lemma :

 forall (m' : Map unit) (m : Map (Map (Map ad))) (pf : ad -> ad)

   (a b c d : ad),

 MapGet3 _ (clean3_1 pf m' m) a b c = Some d <->

 used_node_bs_1 m' (pf a) && (used_node_bs_1 m' b && used_node_bs_1 m' d) =

 true /\ MapGet3 _ m a b c = Some d.

Proof.

  simple induction m.  unfold MapGet3 in |- *.  simpl in |- *.  split.  intro.  discriminate.  tauto.

  simpl in |- *.  split.  intro.  unfold MapGet3 in |- *.  simpl in |- *.  unfold MapGet3 in H.

  elim (sumbool_of_bool (used_node_bs_1 m' (pf a))).  intro y.  rewrite y in H.

  simpl in H.  elim (sumbool_of_bool (Neqb a a1)).  intro y0.  rewrite y0 in H.

  rewrite y0.  rewrite <- (Neqb_complete _ _ y0).  rewrite y.  simpl in |- *.

  apply (proj1 (clean2_lemma a0 m' b c d)).  assumption.  intro y0.

  rewrite y0 in H.  discriminate.  intro y.  rewrite y in H.  simpl in H.

  discriminate.  intro.  unfold MapGet3 in |- *.  unfold MapGet3 in H.  simpl in H.

  elim (sumbool_of_bool (Neqb a a1)).  intro y.  rewrite y in H.

  elim H; intros.  rewrite <- (Neqb_complete _ _ y).

  rewrite <- (Neqb_complete _ _ y) in H0.  elim (andb_prop _ _ H0).  intros.

  rewrite H2.  simpl in |- *.  rewrite (Neqb_correct a).

  apply (proj2 (clean2_lemma a0 m' b c d)).  split.  assumption.

  assumption.  intro y.  rewrite y in H.  elim H; intros.  discriminate.

  intros.  split.  intro.  simpl in H1.  unfold MapGet3 in H1.

  rewrite

   (makeM2_M2 _ (clean3_1 (fun a0 : ad => pf (Ndouble a0)) m' m0)

      (clean3_1 (fun a0 : ad => pf (Ndouble_plus_one a0)) m' m1) a)

    in H1.

  rewrite

   (MapGet_M2_bit_0_if _ (clean3_1 (fun a0 : ad => pf (Ndouble a0)) m' m0)

      (clean3_1 (fun a0 : ad => pf (Ndouble_plus_one a0)) m' m1) a)

    in H1.

  unfold MapGet3 in |- *.  rewrite (MapGet_M2_bit_0_if _ m0 m1 a).

  elim (sumbool_of_bool (Nbit0 a)).  intro y.  rewrite y.  rewrite y in H1.

  lapply

   (proj1 (H0 (fun a0 : ad => pf (Ndouble_plus_one a0)) (Ndiv2 a) b c d)).

  intro.  rewrite (Ndiv2_double_plus_one a y) in H2.  assumption.  assumption.

  intro y.  rewrite y.  rewrite y in H1.

  lapply (proj1 (H (fun a0 : ad => pf (Ndouble a0)) (Ndiv2 a) b c d)).

  rewrite (Ndiv2_double a y).  tauto.  assumption.  intro.  simpl in |- *.

  unfold MapGet3 in |- *.  unfold MapGet3 in H1.

  rewrite

   (makeM2_M2 _ (clean3_1 (fun a0 : ad => pf (Ndouble a0)) m' m0)

      (clean3_1 (fun a0 : ad => pf (Ndouble_plus_one a0)) m' m1) a)

   .

  rewrite

   (MapGet_M2_bit_0_if _ (clean3_1 (fun a0 : ad => pf (Ndouble a0)) m' m0)

      (clean3_1 (fun a0 : ad => pf (Ndouble_plus_one a0)) m' m1) a)

   .

  rewrite (MapGet_M2_bit_0_if _ m0 m1 a) in H1.

  elim (sumbool_of_bool (Nbit0 a)).  intro y.  rewrite y.  rewrite y in H1.

  apply

   (proj2 (H0 (fun a0 : ad => pf (Ndouble_plus_one a0)) (Ndiv2 a) b c d)).

   rewrite (Ndiv2_double_plus_one _ y).  assumption.  intro y.  rewrite y in H1.

  rewrite y.

  apply (proj2 (H (fun a0 : ad => pf (Ndouble a0)) (Ndiv2 a) b c d)).

  rewrite (Ndiv2_double _ y).  assumption.

Qed.



Lemma clean3_lemma :

 forall (m : Map (Map (Map ad))) (m' : Map unit) (a b c d : ad),

 MapGet3 _ (clean3 m m') a b c = Some d <->

 used_node_bs_1 m' a && (used_node_bs_1 m' b && used_node_bs_1 m' d) = true /\

 MapGet3 _ m a b c = Some d.

Proof.

  intros.  unfold clean3 in |- *.  apply clean3_1_lemma with (pf := fun a : ad => a).

Qed.



Lemma new_negm_OK :

 forall (bs : BDDstate) (used : list ad) (negm : BDDneg_memo),

 BDDstate_OK bs ->

 BDDneg_memo_OK bs negm ->

 BDDneg_memo_OK (new_bs bs used) (clean'1 negm (mark bs used)).

Proof.

  unfold BDDneg_memo_OK in |- *.  intros.  elim (proj1 (clean'1_lemma _ _ _ _) H1).

  intros.  elim (H0 node node' H3).  clear H0.  intros.

  elim H4; clear H4; intros.  elim H5; clear H5; intros.

  elim (andb_prop _ _ H2).  intros.

  cut (node_preserved_bs bs (new_bs bs used) node).

  cut (node_preserved_bs bs (new_bs bs used) node').  intros.  split.

  apply node_preserved_OK_bs with (bs := bs).  assumption.  assumption.  split.

  apply node_preserved_OK_bs with (bs := bs).  assumption.  assumption.  split.

  rewrite

   (Neqb_complete (bs_node_height (new_bs bs used) node)

      (bs_node_height bs node)).

  rewrite

   (Neqb_complete (bs_node_height (new_bs bs used) node')

      (bs_node_height bs node')).

  assumption.  apply node_preserved_bs_node_height_eq.  assumption.  apply new_bs_OK.

  assumption.  assumption.  assumption.  apply node_preserved_bs_node_height_eq.

  assumption.  apply new_bs_OK.  assumption.  assumption.  assumption.

  apply bool_fun_eq_trans with (bf2 := bool_fun_of_BDD_bs bs node').

  apply node_preserved_bs_bool_fun.  assumption.  apply new_bs_OK.  assumption.

  assumption.  assumption.

  apply

   bool_fun_eq_trans with (bf2 := bool_fun_neg (bool_fun_of_BDD_bs bs node)).

  assumption.  apply bool_fun_neg_preserves_eq.  apply bool_fun_eq_sym.

  apply node_preserved_bs_bool_fun.  assumption.  apply new_bs_OK.  assumption.

  assumption.  assumption.  apply used_node_bs_1_preserved.  assumption.  

  assumption.  apply used_node_bs_1_preserved.  assumption.  assumption.

Qed.



Lemma new_orm_OK :

 forall (bs : BDDstate) (used : list ad) (orm : BDDor_memo),

 BDDstate_OK bs ->

 BDDor_memo_OK bs orm ->

 BDDor_memo_OK (new_bs bs used) (clean'2 orm (mark bs used)).

Proof.

  unfold BDDor_memo_OK in |- *.  intros.  elim (proj1 (clean'2_lemma _ _ _ _ _) H1).

  intros.  elim (H0 node1 node2 node H3).  intros.  elim H5; clear H5; intros.

  elim H6; clear H6; intros.  elim H7; clear H7; intros.

  elim (andb_prop _ _ H2).  intros.

  cut (node_preserved_bs bs (new_bs bs used) node).

  cut (node_preserved_bs bs (new_bs bs used) node1).

  cut (node_preserved_bs bs (new_bs bs used) node2).  intros.  split.

  apply node_preserved_OK_bs with (bs := bs).  assumption.  assumption.  split.

  apply node_preserved_OK_bs with (bs := bs).  assumption.  assumption.  split.

  apply node_preserved_OK_bs with (bs := bs).  assumption.  assumption.  split.

  rewrite

   (Neqb_complete (bs_node_height (new_bs bs used) node)

      (bs_node_height bs node)).

  rewrite

   (Neqb_complete (bs_node_height (new_bs bs used) node1)

      (bs_node_height bs node1)).

  rewrite

   (Neqb_complete (bs_node_height (new_bs bs used) node2)

      (bs_node_height bs node2)).

  assumption.  apply node_preserved_bs_node_height_eq.  assumption.  apply new_bs_OK.

  assumption.  assumption.  assumption.  apply node_preserved_bs_node_height_eq.

  assumption.  apply new_bs_OK.  assumption.  assumption.  assumption.

  apply node_preserved_bs_node_height_eq.  assumption.  apply new_bs_OK.  assumption.  

  assumption.  assumption.

  apply bool_fun_eq_trans with (bf2 := bool_fun_of_BDD_bs bs node).

  apply node_preserved_bs_bool_fun.  assumption.  apply new_bs_OK.  assumption.

  assumption.  assumption.  apply

   bool_fun_eq_trans

    with

      (bf2 := bool_fun_or (bool_fun_of_BDD_bs bs node1)

                (bool_fun_of_BDD_bs bs node2)).

  assumption.  apply bool_fun_eq_sym.  apply bool_fun_or_preserves_eq.

  apply node_preserved_bs_bool_fun.  assumption.  apply new_bs_OK.  assumption.

  assumption.  assumption.  apply node_preserved_bs_bool_fun.  assumption.

  apply new_bs_OK.  assumption.  assumption.  assumption.  

  apply used_node_bs_1_preserved.  assumption.  elim (andb_prop _ _ H10).  tauto.

  apply used_node_bs_1_preserved.  assumption.  assumption.

  apply used_node_bs_1_preserved.  assumption.  elim (andb_prop _ _ H10).  tauto.

Qed.



Lemma new_univm_OK :

 forall (bs : BDDstate) (used : list ad) (univm : BDDuniv_memo),

 BDDstate_OK bs ->

 BDDuniv_memo_OK bs univm ->

 BDDuniv_memo_OK (new_bs bs used) (clean2 univm (mark bs used)).

Proof.

  unfold BDDuniv_memo_OK in |- *.  intros.

  elim (clean2_lemma univm (mark bs used) node x node').  intros.  elim H2.

  intros.  elim (andb_prop _ _ H4).  intros.

  cut (node_preserved_bs bs (new_bs bs used) node).

  cut (node_preserved_bs bs (new_bs bs used) node').  intros.

  decompose [and] (H0 x node node' H5).  split.

  apply node_preserved_OK_bs with (bs := bs).  assumption.  assumption.  split.

  apply node_preserved_OK_bs with (bs := bs).  assumption.  assumption.  split.

  rewrite

   (Neqb_complete (bs_node_height (new_bs bs used) node)

      (bs_node_height bs node)).

  rewrite

   (Neqb_complete (bs_node_height (new_bs bs used) node')

      (bs_node_height bs node')).

  assumption.  apply node_preserved_bs_node_height_eq.  assumption.  apply new_bs_OK.

  assumption.  assumption.  assumption.  apply node_preserved_bs_node_height_eq.

  assumption.  apply new_bs_OK.  assumption.  assumption.  assumption.  

  apply bool_fun_eq_trans with (bf2 := bool_fun_of_BDD_bs bs node').

  apply node_preserved_bs_bool_fun.  assumption.  apply new_bs_OK.  assumption.

  assumption.  assumption.  apply

   bool_fun_eq_trans

    with (bf2 := bool_fun_forall x (bool_fun_of_BDD_bs bs node)).

  assumption.  apply bool_fun_forall_preserves_eq.  apply bool_fun_eq_sym.

  apply node_preserved_bs_bool_fun.  assumption.  apply new_bs_OK.  assumption.

  assumption.  assumption.  apply used_node_bs_1_preserved.  assumption.  tauto.

  apply used_node_bs_1_preserved.  assumption.  assumption.  assumption.  

Qed.



Lemma new_share_OK :

 forall (bs : BDDstate) (used : list ad) (share : BDDsharing_map),

 BDDstate_OK bs ->

 BDDsharing_OK bs share ->

 BDDsharing_OK (new_bs bs used) (clean3 share (mark bs used)).

Proof.

  unfold BDDsharing_OK in |- *.  intros.  elim (H0 x l r a).  intros.  split.  intro.

  elim (proj1 (clean3_lemma share (mark bs used) l r x a) H3).  intros.

  elim (andb_prop _ _ H4).  intros.  elim (andb_prop _ _ H7).  intros.

  cut (node_preserved_bs bs (new_bs bs used) a).  intro.

  unfold node_preserved_bs in H10.  apply H10.  apply nodes_reachable_0.

  apply H1.  assumption.  apply used_node_bs_1_preserved.  assumption.

  assumption.  intro.

  apply (proj2 (clean3_lemma share (mark bs used) l r x a)).

  cut (MapGet _ bs a = Some (x, (l, r))).  intro.  cut (node_OK bs l).

  cut (node_OK bs r).  intros.  split.  apply andb_true_intro.

  cut

   (forall a : ad,

    MapGet _ bs a = None -> MapGet _ (mark bs used) a = None).

  intro.  split.  elim H6.  intro.  rewrite H8.  unfold used_node_bs_1 in |- *.

  rewrite (H7 BDDzero).  apply orb_true_intro.  left.  reflexivity.

  exact (proj1 H).  intro.  elim H8.  intro.  rewrite H9.

  unfold used_node_bs_1 in |- *.  rewrite (H7 BDDone).  apply orb_true_intro.  right.

  reflexivity.  exact (proj1 (proj2 H)).  intro.  unfold used_node_bs_1 in |- *.

  lapply (proj2 (mark_lemma_3 bs used H l)).  unfold in_dom in |- *.

  elim (MapGet unit (mark bs used) l).  Focus 2. intro. discriminate.  reflexivity.

  split.  unfold used_node_bs in |- *.  cut (used_node_bs bs used a).  intro.  elim H10.

  intros.  split with x0.  split.  exact (proj1 H11).  

  apply nodes_reachable_trans with (node2 := a).  exact (proj2 H11).

  apply nodes_reachable_1 with (x := x) (l := l) (r := r).  assumption.

  apply nodes_reachable_0.  apply new_bs_lemma_2.  assumption.  unfold in_dom in |- *.

  rewrite H3.  reflexivity.  assumption.  apply andb_true_intro.  split.

  elim H5.  intro.  rewrite H8.  unfold used_node_bs_1 in |- *.  rewrite (H7 BDDzero).

  apply orb_true_intro.  left.  reflexivity.  exact (proj1 H).  intro.

  elim H8.  intro.  rewrite H9.  unfold used_node_bs_1 in |- *.  rewrite (H7 BDDone).

  apply orb_true_intro.  right.  reflexivity.  exact (proj1 (proj2 H)).

  intro.  unfold used_node_bs_1 in |- *.  lapply (proj2 (mark_lemma_3 bs used H r)).

  unfold in_dom in |- *.  elim (MapGet unit (mark bs used) r). Focus 2. intro.  discriminate.

  reflexivity.  split.  unfold used_node_bs in |- *.  cut (used_node_bs bs used a).

  intro.  elim H10.  intros.  split with x0.  split.  exact (proj1 H11).

  apply nodes_reachable_trans with (node2 := a).  exact (proj2 H11).  

  apply nodes_reachable_2 with (x := x) (l := l) (r := r).  assumption.

  apply nodes_reachable_0.  apply new_bs_lemma_2.  assumption.  unfold in_dom in |- *.

  rewrite H3.  reflexivity.  assumption.

  cut (in_dom unit a (mark bs used) = true).  unfold in_dom in |- *.

  unfold used_node_bs_1 in |- *.  elim (MapGet unit (mark bs used) a).  Focus 2. intro.

  discriminate.  reflexivity.  apply (proj2 (mark_lemma_3 bs used H a)).

  split.  apply new_bs_lemma_2.  assumption.  unfold in_dom in |- *.  rewrite H3.

  reflexivity.  unfold in_dom in |- *.  rewrite H4.  reflexivity.  intros.

  elim (sumbool_of_bool (in_dom _ a0 (mark bs used))).  intro y.

  elim (proj1 (mark_lemma_3 bs used H a0) y).  intros.  unfold in_dom in H9.

  rewrite H7 in H9.  discriminate.  unfold in_dom in |- *.

  elim (MapGet unit (mark bs used) a0).  Focus 2. reflexivity.  intros.  discriminate.

  apply H2.  assumption.  apply high_OK with (node := a) (x := x) (l := l).  assumption.

  assumption.  apply low_OK with (node := a) (x := x) (r := r).  assumption.  assumption.

  rewrite (new_bs_lemma_1 bs used H a).  assumption.  apply new_bs_lemma_2.

  assumption.  unfold in_dom in |- *.  rewrite H3.  reflexivity.  

Qed.



Lemma new_cfg_OK :

 forall (bs : BDDstate) (share : BDDsharing_map) (fl : BDDfree_list)

   (cnt : ad) (negm : BDDneg_memo) (orm : BDDor_memo) 

   (um : BDDuniv_memo) (used : list ad),

 BDDconfig_OK (bs, (share, (fl, (cnt, (negm, (orm, um)))))) ->

 BDDconfig_OK

   (new_bs bs used,

   (clean3 share (mark bs used),

   (new_fl bs used fl,

   (cnt,

   (clean'1 negm (mark bs used),

   (clean'2 orm (mark bs used), clean2 um (mark bs used))))))).

Proof.

  intros.  unfold BDDconfig_OK in |- *.  simpl in |- *.  unfold BDDconfig_OK in H.  simpl in H.

  elim H; intros.  elim H1; intros.  elim H3; intros.  elim H5; intros.

  split.  apply new_bs_OK.  assumption.  split.  apply new_share_OK.

  assumption.  assumption.  split.  apply new_fl_OK.  assumption.  assumption.

  assumption.  split.  apply new_cnt_OK.  assumption.  assumption.  split.

  apply new_negm_OK.  assumption.  exact (proj1 H7).  split.

  apply new_orm_OK.  assumption.  exact (proj1 (proj2 H7)).

  apply new_univm_OK.  assumption.  exact (proj2 (proj2 H7)).

Qed.

 

Lemma gc_0_OK : gc_OK gc_0.

Proof.

  unfold gc_0 in |- *.  unfold gc_OK in |- *.  intro.  elim cfg.  intro y.  intro y0.  elim y0.

  intro y1.  intro y2.  elim y2.  intro y3.  intro y4.  elim y4.  intro y5.  intro y6.  elim y6.

  intro y7.  intro y8.  elim y8.

  intros y9 y10 ul H H0.  split.  fold (new_bs y ul) in |- *.  fold (new_fl y ul y3) in |- *.

  apply new_cfg_OK with (um := y10).  assumption.  unfold used_nodes_preserved in |- *.

  simpl in |- *.  split.

  unfold used_nodes_preserved_bs in |- *.  intros.  fold (new_bs y ul) in |- *.

  apply new_bs_used_nodes_preserved.  exact (proj1 H).  unfold used_node_bs in |- *.

  split with node.  split.  assumption.  apply nodes_reachable_0.  

  unfold no_new_node in |- *.  simpl in |- *.  fold (new_bs y ul) in |- *.  apply no_new_node_new_bs.

  exact (proj1 H).

Qed.



Lemma gc_inf_OK : gc_OK gc_inf.

Proof.

  unfold gc_inf in |- *.  unfold gc_OK in |- *.  intros.  split.  assumption.  split.

  apply used_nodes_preserved_refl.  unfold no_new_node in |- *.  unfold no_new_node_bs in |- *.

  tauto.

Qed.



Lemma gc_x_OK : forall x : ad, gc_OK (gc_x x).

Proof.

  intros.  unfold gc_x in |- *.  unfold gc_OK in |- *.  intros.

  elim

   (is_nil ad (fst (snd (snd cfg))) && Nleb x (fst (snd (snd (snd cfg))))).

  apply gc_0_OK.  assumption.  assumption.  apply gc_inf_OK.  assumption.

  assumption.  

Qed.



Lemma gc_x_opt_OK : forall x : ad, gc_OK (gc_x_opt x).

Proof.

  intros.  unfold gc_x_opt in |- *.  unfold gc_OK in |- *.  intros.  elim (fl_of_cfg cfg).

  elim (BDDcompare x (cnt_of_cfg cfg)).  apply gc_inf_OK.  assumption.

  assumption.  apply gc_0_OK.  assumption.  assumption.  apply gc_inf_OK.

  assumption.  assumption.  intros.  apply gc_inf_OK.  assumption.  assumption.

Qed.



End BDDgc.
