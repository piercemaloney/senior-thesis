
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import ZArith NArith Nnat Ndec Ndigits.
From IntMap Require Import Map.
From IntMap Require Import Allmaps.
Require Import List.
Require Import Wf_nat.

Require Import misc.
(* misc:
Require Import Compare.
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import ZArith NArith Nnat Ndec Ndigits.
From IntMap Require Import Allmaps.
Require Import List.

Section BDDmisc.

Definition BDDvar := ad.

Definition BDDcompare (x y : BDDvar) :=
  match x, y with
  | N0, N0 => Datatypes.Eq
  | N0, Npos _ => Datatypes.Lt
  | Npos _, N0 => Datatypes.Gt
  | Npos p1, Npos p2 => Pcompare p1 p2 Datatypes.Eq
  end.

Definition ad_S (a : ad) :=
  match a with
  | N0 => Npos 1
  | Npos p => Npos (Psucc p)
  end.

Definition max (m n : nat) := if leb m n then n else m.

Definition BDDvar_max (x y : BDDvar) := if Nleb x y then y else x.

Inductive no_dup_list (A : Set) : list A -> Prop :=
  | no_dup_nil : no_dup_list A nil
  | no_dup_cons :
      forall (a : A) (l : list A),
      ~ In a l -> no_dup_list _ l -> no_dup_list _ (a :: l).

Lemma ad_S_is_S : forall a : ad, nat_of_N (ad_S a) = S (nat_of_N a).

Lemma relation_sum :
 forall r : Datatypes.comparison,

Lemma BDD_EGAL_complete :
 forall x y : BDDvar, BDDcompare x y = Datatypes.Eq -> x = y.

Lemma BDDcompare_lt :
 forall x y : BDDvar,
 BDDcompare x y = Datatypes.Lt -> nat_of_N x < nat_of_N y.

Lemma BDDlt_compare :
 forall x y : BDDvar,
 nat_of_N x < nat_of_N y -> BDDcompare x y = Datatypes.Lt.

Lemma BDDcompare_trans :
 forall x y z : BDDvar,
 BDDcompare x y = Datatypes.Lt ->

Lemma BDDcompare_sup_inf :
 forall x y : BDDvar,
 BDDcompare x y = Datatypes.Gt -> BDDcompare y x = Datatypes.Lt.

Lemma lt_trans_1 : forall x y z : nat, x < y -> y < S z -> x < z.

Lemma BDDcompare_1 :
 forall x y : BDDvar,
 BDDcompare x y = Datatypes.Lt ->

Lemma andb3_lemma :
 forall b1 b2 b3 : bool,
 b1 && (b2 && b3) = true -> b1 = true /\ b2 = true /\ b3 = true.

Lemma andb3_lemma_1 :
 forall x x0 y y0 z z0 : ad,
 (x, (y, z)) <> (x0, (y0, z0)) ->
 Neqb x x0 && (Neqb y y0 && Neqb z z0) = false.

Lemma ad_S_le_then_neq :
 forall x y : ad, Nleb (ad_S x) y = true -> Neqb x y = false.

Lemma BDD_EGAL_correct : forall x : BDDvar, BDDcompare x x = Datatypes.Eq.

Lemma BDDcompare_inf_sup :
 forall x y : BDDvar,
 BDDcompare x y = Datatypes.Lt -> BDDcompare y x = Datatypes.Gt.

Lemma ad_S_compare :
 forall x y : ad, BDDcompare x y = BDDcompare (ad_S x) (ad_S y).

Lemma prod_sum :
 forall (A B : Set) (p : A * B), exists a : A, (exists b : B, p = (a, b)).

Lemma lt_max_1_2 :
 forall x1 y1 x2 y2 : nat, x1 < x2 -> y1 < y2 -> max x1 y1 < max x2 y2.

Lemma lt_max_1 :
 forall x1 y1 x2 y2 : nat, x1 < x2 -> y1 < x2 -> max x1 y1 < max x2 y2.

Lemma lt_max_2 :
 forall x1 y1 x2 y2 : nat, x1 < y2 -> y1 < y2 -> max x1 y1 < max x2 y2.

Lemma max_x_x_eq_x : forall x : nat, max x x = x.

Lemma BDDvar_le_max_2 : forall x y : BDDvar, Nleb x (BDDvar_max y x) = true.

Lemma BDDvar_max_max :
 forall x y : BDDvar,
 nat_of_N (BDDvar_max x y) = max (nat_of_N x) (nat_of_N y).

Lemma BDDvar_le_max_1 : forall x y : BDDvar, Nleb x (BDDvar_max x y) = true.

Lemma BDDvar_max_inf :
 forall x y : BDDvar, BDDcompare x y = Datatypes.Lt -> BDDvar_max x y = y.

Lemma BDDvar_max_comm : forall x y : BDDvar, BDDvar_max x y = BDDvar_max y x.

Lemma nat_gt_1_lemma : forall n : nat, n <> 0 -> n <> 1 -> 2 <= n.

Lemma ad_gt_1_lemma :
 forall x : ad, x <> N0 -> x <> Npos 1 -> Nleb (Npos 2) x = true.

Lemma Nltb_lebmma :
 forall a b : ad, Nleb a b = false -> Nleb (ad_S b) a = true.

Lemma eq_ad_S_eq :
 forall a b : ad, Neqb (ad_S a) (ad_S b) = true -> Neqb a b = true.

Lemma ad_S_neq_N0 : forall a : ad, Neqb (ad_S a) N0 = false.

Lemma list_sum :
 forall (A : Set) (l : list A),
 l = nil \/ (exists a : A, (exists l' : list A, l = a :: l')).

Lemma no_dup_sum :
 forall (A : Set) (l : list A) (H : no_dup_list _ l),
 l = nil \/
 (exists a : A,
    (exists l0 : list A, ~ In a l0 /\ no_dup_list _ l0 /\ l = a :: l0)).

Lemma no_dup_cons_no_dup :
 forall (A : Set) (l : list A) (a : A),
 no_dup_list _ (a :: l) -> no_dup_list _ l.

Lemma no_dup_cons_no_in :
 forall (A : Set) (l : list A) (a : A), no_dup_list _ (a :: l) -> ~ In a l.

End BDDmisc. *)
Require Import bool_fun.
(* bool_fun:
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import ZArith NArith Nnat Ndec Ndigits.
From IntMap Require Import Allmaps.

Require Import misc.

Section Bool_fun.

Definition var_env := BDDvar -> bool.

Definition bool_fun := var_env -> bool.

Definition bool_fun_eq (bf1 bf2 : bool_fun) :=
  forall vb : var_env, bf1 vb = bf2 vb.

Definition bool_fun_zero (vb : var_env) := false.

Definition bool_fun_one (vb : var_env) := true.

Definition bool_fun_neg (bf : bool_fun) : bool_fun :=
  fun vb : var_env => negb (bf vb).

Definition bool_fun_or (bf1 bf2 : bool_fun) : bool_fun :=
  fun vb : var_env => bf1 vb || bf2 vb.

Definition bool_fun_and (bf1 bf2 : bool_fun) : bool_fun :=
  fun vb : var_env => bf1 vb && bf2 vb.

Definition bool_fun_impl (bf1 bf2 : bool_fun) : bool_fun :=
  fun vb : var_env => implb (bf1 vb) (bf2 vb).

Definition bool_fun_iff (bf1 bf2 : bool_fun) : bool_fun :=
  fun vb : var_env => eqb (bf1 vb) (bf2 vb).

Definition bool_fun_if (x : BDDvar) (bf1 bf2 : bool_fun) : bool_fun :=
  fun vb : var_env => ifb (vb x) (bf1 vb) (bf2 vb). 

Definition bool_fun_var (x : BDDvar) : bool_fun := fun vb : var_env => vb x.

Definition augment (vb : var_env) (x : BDDvar) (b : bool) : var_env :=
  fun y : BDDvar => if Neqb x y then b else vb y.

Definition bool_fun_restrict (bf : bool_fun) (x : BDDvar) 
  (b : bool) : bool_fun := fun vb : var_env => bf (augment vb x b).

Definition bool_fun_independent (bf : bool_fun) (x : BDDvar) :=
  forall b : bool, bool_fun_eq (bool_fun_restrict bf x b) bf.

Definition bool_fun_forall (x : BDDvar) (bf : bool_fun) :=
  bool_fun_and (bool_fun_restrict bf x true) (bool_fun_restrict bf x false).

Definition bool_fun_ex (x : BDDvar) (bf : bool_fun) :=
  bool_fun_or (bool_fun_restrict bf x true) (bool_fun_restrict bf x false).

Definition bool_fun_ext (bf : bool_fun) :=
  forall vb vb' : var_env,
  (forall x : BDDvar, vb x = vb' x) -> bf vb = bf vb'.

Inductive bool_expr : Set :=
  | Zero : bool_expr
  | One : bool_expr
  | Var : BDDvar -> bool_expr
  | Neg : bool_expr -> bool_expr
  | Or : bool_expr -> bool_expr -> bool_expr
  | ANd : bool_expr -> bool_expr -> bool_expr
  | Impl : bool_expr -> bool_expr -> bool_expr
  | Iff : bool_expr -> bool_expr -> bool_expr.

Fixpoint bool_fun_of_bool_expr (be : bool_expr) : bool_fun :=
  match be with
  | Zero => bool_fun_zero
  | One => bool_fun_one
  | Var x => bool_fun_var x
  | Neg be' => bool_fun_neg (bool_fun_of_bool_expr be')
  | Or be1 be2 =>
      bool_fun_or (bool_fun_of_bool_expr be1) (bool_fun_of_bool_expr be2)
  | ANd be1 be2 =>
      bool_fun_and (bool_fun_of_bool_expr be1) (bool_fun_of_bool_expr be2)
  | Impl be1 be2 =>
      bool_fun_impl (bool_fun_of_bool_expr be1) (bool_fun_of_bool_expr be2)
  | Iff be1 be2 =>
      bool_fun_iff (bool_fun_of_bool_expr be1) (bool_fun_of_bool_expr be2)
  end.

Lemma bool_fun_eq_refl : forall bf : bool_fun, bool_fun_eq bf bf.

Lemma bool_fun_eq_sym :
 forall bf1 bf2 : bool_fun, bool_fun_eq bf1 bf2 -> bool_fun_eq bf2 bf1.

Lemma bool_fun_eq_trans :
 forall bf1 bf2 bf3 : bool_fun,
 bool_fun_eq bf1 bf2 -> bool_fun_eq bf2 bf3 -> bool_fun_eq bf1 bf3.

Lemma bool_fun_neg_preserves_eq :
 forall bf1 bf2 : bool_fun,
 bool_fun_eq bf1 bf2 -> bool_fun_eq (bool_fun_neg bf1) (bool_fun_neg bf2).

Lemma bool_fun_or_preserves_eq :
 forall bf1 bf1' bf2 bf2' : bool_fun,
 bool_fun_eq bf1 bf1' ->
 bool_fun_eq bf2 bf2' ->
 bool_fun_eq (bool_fun_or bf1 bf2) (bool_fun_or bf1' bf2').

Lemma bool_fun_if_preserves_eq :
 forall (x : BDDvar) (bf1 bf2 bf1' bf2' : bool_fun),
 bool_fun_eq bf1 bf1' ->
 bool_fun_eq bf2 bf2' ->
 bool_fun_eq (bool_fun_if x bf1 bf2) (bool_fun_if x bf1' bf2').

Lemma bool_fun_and_preserves_eq :
 forall bf1 bf1' bf2 bf2' : bool_fun,
 bool_fun_eq bf1 bf1' ->
 bool_fun_eq bf2 bf2' ->
 bool_fun_eq (bool_fun_and bf1 bf2) (bool_fun_and bf1' bf2').

Lemma bool_fun_impl_preserves_eq :
 forall bf1 bf1' bf2 bf2' : bool_fun,
 bool_fun_eq bf1 bf1' ->
 bool_fun_eq bf2 bf2' ->
 bool_fun_eq (bool_fun_impl bf1 bf2) (bool_fun_impl bf1' bf2').

Lemma bool_fun_iff_preserves_eq :
 forall bf1 bf1' bf2 bf2' : bool_fun,
 bool_fun_eq bf1 bf1' ->
 bool_fun_eq bf2 bf2' ->
 bool_fun_eq (bool_fun_iff bf1 bf2) (bool_fun_iff bf1' bf2').

Lemma bool_fun_forall_preserves_eq :
 forall (bf1 bf2 : bool_fun) (x : BDDvar),
 bool_fun_eq bf1 bf2 ->
 bool_fun_eq (bool_fun_forall x bf1) (bool_fun_forall x bf2).

Lemma bool_fun_ex_preserves_eq :
 forall (bf1 bf2 : bool_fun) (x : BDDvar),
 bool_fun_eq bf1 bf2 -> bool_fun_eq (bool_fun_ex x bf1) (bool_fun_ex x bf2).

Lemma bool_fun_neg_zero :
 bool_fun_eq (bool_fun_neg bool_fun_zero) bool_fun_one.

Lemma bool_fun_neg_one :
 bool_fun_eq (bool_fun_neg bool_fun_one) bool_fun_zero.

Lemma bool_fun_and_lemma :
 forall bf1 bf2 : bool_fun,
 bool_fun_eq (bool_fun_and bf1 bf2)
   (bool_fun_neg (bool_fun_or (bool_fun_neg bf1) (bool_fun_neg bf2))).

Lemma bool_fun_impl_lemma :
 forall bf1 bf2 : bool_fun,
 bool_fun_eq (bool_fun_impl bf1 bf2) (bool_fun_or (bool_fun_neg bf1) bf2).

Lemma bool_fun_iff_lemma :
 forall bf1 bf2 : bool_fun,
 bool_fun_eq (bool_fun_iff bf1 bf2)
   (bool_fun_impl (bool_fun_or bf1 bf2) (bool_fun_and bf1 bf2)).

Lemma bool_fun_ex_lemma :
 forall (bf : bool_fun) (x : BDDvar),
 bool_fun_eq (bool_fun_ex x bf)
   (bool_fun_neg (bool_fun_forall x (bool_fun_neg bf))).

Lemma bool_fun_var_lemma :
 forall x : BDDvar,
 bool_fun_eq (bool_fun_var x) (bool_fun_if x bool_fun_one bool_fun_zero).

Lemma bool_fun_eq_neg_eq :
 forall bf1 bf2 : bool_fun,
 bool_fun_eq (bool_fun_neg bf1) (bool_fun_neg bf2) -> bool_fun_eq bf1 bf2.

Lemma bool_fun_neg_orthogonal :
 forall (x : BDDvar) (bf1 bf2 : bool_fun),
 bool_fun_eq (bool_fun_neg (bool_fun_if x bf1 bf2))
   (bool_fun_if x (bool_fun_neg bf1) (bool_fun_neg bf2)).

Lemma bool_fun_or_zero :
 forall bf : bool_fun, bool_fun_eq (bool_fun_or bf bool_fun_zero) bf.

Lemma bool_fun_or_one :
 forall bf : bool_fun, bool_fun_eq (bool_fun_or bf bool_fun_one) bool_fun_one.

Lemma bool_fun_or_comm :
 forall bf1 bf2 : bool_fun,
 bool_fun_eq (bool_fun_or bf1 bf2) (bool_fun_or bf2 bf1).

Lemma bool_fun_and_comm :
 forall bf1 bf2 : bool_fun,
 bool_fun_eq (bool_fun_and bf1 bf2) (bool_fun_and bf2 bf1).

Lemma bool_fun_and_idempotent :
 forall bf : bool_fun, bool_fun_eq (bool_fun_and bf bf) bf.

Lemma bool_fun_or_orthogonal :
 forall (x : BDDvar) (bf1 bf2 bf1' bf2' : bool_fun),
 bool_fun_eq (bool_fun_or (bool_fun_if x bf1 bf2) (bool_fun_if x bf1' bf2'))
   (bool_fun_if x (bool_fun_or bf1 bf1') (bool_fun_or bf2 bf2')).

Lemma bool_fun_or_orthogonal_right :
 forall (x : BDDvar) (bf bf1' bf2' : bool_fun),
 bool_fun_eq (bool_fun_or bf (bool_fun_if x bf1' bf2'))
   (bool_fun_if x (bool_fun_or bf bf1') (bool_fun_or bf bf2')).

Lemma bool_fun_or_orthogonal_left :
 forall (x : BDDvar) (bf1 bf2 bf' : bool_fun),
 bool_fun_eq (bool_fun_or (bool_fun_if x bf1 bf2) bf')
   (bool_fun_if x (bool_fun_or bf1 bf') (bool_fun_or bf2 bf')).

Lemma bool_fun_and_orthogonal :
 forall (x : BDDvar) (bf1 bf2 bf1' bf2' : bool_fun),
 bool_fun_eq (bool_fun_and (bool_fun_if x bf1 bf2) (bool_fun_if x bf1' bf2'))
   (bool_fun_if x (bool_fun_and bf1 bf1') (bool_fun_and bf2 bf2')).

Lemma bool_fun_forall_independent :
 forall (x : BDDvar) (bf : bool_fun),
 bool_fun_independent bf x -> bool_fun_eq (bool_fun_forall x bf) bf.

Lemma bool_fun_forall_zero :
 forall x : BDDvar,
 bool_fun_eq (bool_fun_forall x bool_fun_zero) bool_fun_zero.

Lemma bool_fun_forall_one :
 forall x : BDDvar, bool_fun_eq (bool_fun_forall x bool_fun_one) bool_fun_one.

Lemma bool_fun_restrict_zero :
 forall (x : BDDvar) (b : bool),
 bool_fun_eq (bool_fun_restrict bool_fun_zero x b) bool_fun_zero.

Lemma bool_fun_restrict_one :
 forall (x : BDDvar) (b : bool),
 bool_fun_eq (bool_fun_restrict bool_fun_one x b) bool_fun_one.

Lemma bool_fun_restrict_preserves_eq :
 forall (bf1 bf2 : bool_fun) (x : BDDvar) (b : bool),
 bool_fun_eq bf1 bf2 ->
 bool_fun_eq (bool_fun_restrict bf1 x b) (bool_fun_restrict bf2 x b).

Lemma bool_fun_independent_zero :
 forall x : BDDvar, bool_fun_independent bool_fun_zero x.

Lemma bool_fun_independent_one :
 forall x : BDDvar, bool_fun_independent bool_fun_one x.

Lemma bool_fun_eq_independent :
 forall (bf1 bf2 : bool_fun) (x : BDDvar),
 bool_fun_eq bf1 bf2 ->
 bool_fun_independent bf1 x -> bool_fun_independent bf2 x.

Lemma bool_fun_if_restrict_true :
 forall (bf1 bf2 : bool_fun) (x : BDDvar),
 bool_fun_eq (bool_fun_restrict (bool_fun_if x bf1 bf2) x true)
   (bool_fun_restrict bf1 x true).

Lemma bool_fun_if_restrict_false :
 forall (bf1 bf2 : bool_fun) (x : BDDvar),
 bool_fun_eq (bool_fun_restrict (bool_fun_if x bf1 bf2) x false)
   (bool_fun_restrict bf2 x false).

Lemma bool_fun_if_restrict :
 forall (bf1 bf2 : bool_fun) (x y : BDDvar) (b : bool),
 Neqb x y = false ->
 bool_fun_eq (bool_fun_restrict (bool_fun_if x bf1 bf2) y b)
   (bool_fun_if x (bool_fun_restrict bf1 y b) (bool_fun_restrict bf2 y b)).

Lemma bool_fun_if_restrict_true_independent :
 forall (bf1 bf2 : bool_fun) (x : BDDvar),
 bool_fun_independent bf1 x ->
 bool_fun_eq (bool_fun_restrict (bool_fun_if x bf1 bf2) x true) bf1.

Lemma bool_fun_if_restrict_false_independent :
 forall (bf1 bf2 : bool_fun) (x : BDDvar),
 bool_fun_independent bf2 x ->
 bool_fun_eq (bool_fun_restrict (bool_fun_if x bf1 bf2) x false) bf2.

Lemma bool_fun_forall_orthogonal :
 forall (x u : BDDvar) (bf1 bf2 : bool_fun),
 Neqb x u = false ->
 bool_fun_eq (bool_fun_forall u (bool_fun_if x bf1 bf2))
   (bool_fun_if x (bool_fun_forall u bf1) (bool_fun_forall u bf2)).

Lemma bool_fun_independent_if :
 forall (x y : BDDvar) (bf1 bf2 : bool_fun),
 bool_fun_independent bf1 x ->
 bool_fun_independent bf2 x ->
 Neqb x y = false -> bool_fun_independent (bool_fun_if y bf1 bf2) x.

Lemma bool_fun_forall_if_egal :
 forall (x : BDDvar) (bf1 bf2 : bool_fun),
 bool_fun_independent bf1 x ->
 bool_fun_independent bf2 x ->
 bool_fun_eq (bool_fun_forall x (bool_fun_if x bf1 bf2))
   (bool_fun_and bf1 bf2).

Lemma bool_fun_if_eq_1 :
 forall (bf1 bf2 : bool_fun) (x : BDDvar),
 bool_fun_eq bf1 bf2 -> bool_fun_eq (bool_fun_if x bf1 bf2) bf1.

Lemma bool_fun_if_eq_2 :
 forall (bf1 bf2 : bool_fun) (x : BDDvar),
 bool_fun_eq bf1 bf2 -> bool_fun_eq (bool_fun_if x bf1 bf2) bf2.

Lemma bool_fun_ext_zero : bool_fun_ext bool_fun_zero.

Lemma bool_fun_ext_one : bool_fun_ext bool_fun_one.

Lemma bool_fun_ext_if :
 forall (bf1 bf2 : bool_fun) (x : BDDvar),
 bool_fun_ext bf1 -> bool_fun_ext bf2 -> bool_fun_ext (bool_fun_if x bf1 bf2).

End Bool_fun. *)
Require Import myMap.
(* myMap:
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import ZArith NArith Nnat Ndec Ndigits.
From IntMap Require Import Map.
From IntMap Require Import Allmaps.
Require Import Relation_Definitions.
Require Import List.

Require Import misc.

Section my_MapFold.

Variable M : Set.
Variable neutral : M.
Variable op : M -> M -> M.
Variable R : relation M.

Definition F (A : Set) (f : ad -> A -> M) (r : ad * A) 
  (m : M) := let (a, y) := r in op (f a y) m.

Hypothesis eq_R : equiv _ R.
Hypothesis op_assoc : forall a b c : M, R (op (op a b) c) (op a (op b c)).
Hypothesis op_neutral_left : forall a : M, R (op neutral a) a.
Hypothesis op_neutral_right : forall a : M, R (op a neutral) a.
Hypothesis
  op_eq : forall a b a1 b1 : M, R a a1 -> R b b1 -> R (op a b) (op a1 b1).

Lemma op_eq_2 : forall a b b1 : M, R b b1 -> R (op a b) (op a b1).

Lemma my_fold_right_aapp :
 forall (A : Set) (f : ad -> A -> M) (l l' : alist A),
 R (fold_right (F A f) neutral (aapp _ l l'))
   (op (fold_right (F A f) neutral l) (fold_right (F A f) neutral l')).

Lemma myMapFold_as_fold_1 :
 forall (A : Set) (f : ad -> A -> M) (m : Map A) (pf : ad -> ad),
 R (MapFold1 _ M neutral op f pf m)
   (fold_right (fun (r : ad * A) (m : M) => let (a, y) := r in op (f a y) m)
      neutral
      (MapFold1 _ (alist A) (anil A) (aapp A)
         (fun (a : ad) (y : A) => acons _ (a, y) (anil _)) pf m)).

Lemma myMapFold_as_fold :
 forall (A : Set) (f : ad -> A -> M) (m : Map A),
 R (MapFold _ M neutral op f m)
   (fold_right (fun (r : ad * A) (m : M) => let (a, y) := r in op (f a y) m)
      neutral (alist_of_Map _ m)).

End my_MapFold.

Lemma eqmap_equiv : forall A : Set, equiv _ (eqmap A).

Lemma MapMerge_assoc :
 forall (A : Set) (a b c : Map A),
 eqmap _ (MapMerge _ (MapMerge _ a b) c) (MapMerge _ a (MapMerge _ b c)).

Lemma MapMerge_neutral_left :
 forall (A : Set) (m : Map A), eqmap _ (MapMerge _ (M0 A) m) m.

Lemma MapMerge_neutral_right :
 forall (A : Set) (m : Map A), eqmap _ (MapMerge _ m (M0 _)) m.

Lemma MapMerge_eq :
 forall (A : Set) (a a1 b b1 : Map A),
 eqmap _ a a1 -> eqmap _ b b1 -> eqmap _ (MapMerge _ a b) (MapMerge _ a1 b1).

Lemma myMapFold_as_fold_2 :
 forall (A B : Set) (f : ad -> A -> Map B) (m : Map A),
 eqmap _ (MapFold _ (Map B) (M0 _) (MapMerge _) f m)
   (fold_right
      (fun (r : ad * A) (m : Map B) =>
       let (a, y) := r in MapMerge _ (f a y) m) (M0 _) 
      (alist_of_Map _ m)).

Lemma my_alist_of_map_lemma_1 :
 forall (A : Set) (m : Map A) (a : ad) (y : A),
 MapGet _ m a = Some y -> In (a, y) (alist_of_Map _ m).

Lemma my_alist_of_map_lemma_2 :
 forall (A : Set) (m : Map A) (pf fp : ad -> ad),
 (forall a : ad, fp (pf a) = a) ->
 forall (a : ad) (y : A),
 In (a, y)
   (MapFold1 _ _ (anil _) (aapp _)
      (fun (a : ad) (y : A) => acons _ (a, y) (anil _)) pf m) ->
 MapGet _ m (fp a) = Some y /\ pf (fp a) = a.

Lemma my_alist_of_map_lemma_3 :
 forall (A : Set) (m : Map A) (a : ad) (y : A),
 In (a, y) (alist_of_Map _ m) -> MapGet _ m a = Some y.

Definition f_OK (A B : Set) (f : ad -> A -> Map B) :=
  forall (a a1 a2 : ad) (y1 y2 : A),
  in_dom _ a (f a1 y1) = true -> in_dom _ a (f a2 y2) = true -> a1 = a2.

Definition no_dup_alist (A : Set) (l : alist A) :=
  forall (a : ad) (y1 y2 : A), In (a, y1) l -> In (a, y2) l -> y1 = y2.

Lemma no_dup_alist_of_Map :
 forall (A : Set) (m : Map A), no_dup_alist _ (alist_of_Map _ m).

Lemma my_fold_right_lemma :
 forall (A B : Set) (f : ad -> A -> Map B) (l : alist A),
 f_OK _ _ f ->
 no_dup_alist _ l ->
 forall (a : ad) (y : B),
 MapGet _
   (fold_right
      (fun (r : ad * A) (m0 : Map B) =>
       let (a0, y0) := r in MapMerge B (f a0 y0) m0) 
      (M0 B) l) a = Some y <->
 (exists a1 : ad,
    (exists y1 : A, In (a1, y1) l /\ MapGet _ (f a1 y1) a = Some y)).

Lemma myMapFold_lemma :
 forall (A B : Set) (f : ad -> A -> Map B) (m : Map A),
 f_OK _ _ f ->
 forall (a : ad) (y : B),
 MapGet _ (MapFold _ _ (M0 _) (MapMerge _) f m) a = Some y <->
 (exists a1 : ad,
    (exists y1 : A,
       MapGet _ m a1 = Some y1 /\ MapGet _ (f a1 y1) a = Some y)).

Section My_Map.

Variable A B : Set.

Fixpoint Mapn (n : nat) : Set :=
  match n with
  | O => A
  | S m => Map (Mapn m)
  end.

Definition MapGet2 (m : Map (Map A)) (a b : ad) :=
  match MapGet _ m a with
  | None => None 
  | Some m' => MapGet _ m' b
  end.

Definition MapGet3 (m : Map (Map (Map A))) (a b c : ad) :=
  match MapGet _ m a with
  | None => None
  | Some m' => MapGet2 m' b c
  end.

Definition MapPut2 (m : Map (Map A)) (a b : ad) (c : A) :=
  match MapGet _ m a with
  | Some m' => MapPut _ m a (MapPut _ m' b c)
  | None => MapPut _ m a (M1 _ b c)
  end.

Definition MapPut3 (m : Map (Map (Map A))) (a b c : ad) 
  (d : A) :=
  match MapGet _ m a with
  | Some m' => MapPut _ m a (MapPut2 m' b c d)
  | None => MapPut _ m a (M1 _ b (M1 _ c d))
  end.

Lemma MapPut2_semantics :
 forall (m : Map (Map A)) (a b a1 b1 : ad) (c : A),
 MapGet2 (MapPut2 m a b c) a1 b1 =
 (if Neqb a a1 && Neqb b b1 then Some c else MapGet2 m a1 b1).
 
Lemma MapPut3_semantics :
 forall (m : Map (Map (Map A))) (a b c a1 b1 c1 : ad) (d : A),
 MapGet3 (MapPut3 m a b c d) a1 b1 c1 =
 (if Neqb a a1 && (Neqb b b1 && Neqb c c1)
  then Some d
  else MapGet3 m a1 b1 c1).

Lemma makeM2_MapDom_lemma :
 forall (A : Set) (m1 m2 : Map A),
 makeM2 unit (MapDom A m1) (MapDom A m2) = MapDom A (makeM2 A m1 m2).

Fixpoint MapDomRestrTo_DomBy (m : Map A) : Map B -> Map A * Map unit :=
  match m with
  | M0 => fun _ : Map B => (M0 A, M0 unit)
  | M1 a y =>
      fun m' : Map B =>
      match MapGet B m' a with
      | None => (M0 A, M1 unit a tt)
      | _ => (m, M0 unit)
      end
  | M2 m1 m2 =>
      fun m' : Map B =>
      match m' with
      | M0 => (M0 A, MapDom A m)
      | M1 a' y' =>
          (match MapGet A m a' with
           | None => M0 A
           | Some y => M1 A a' y
           end, MapDom A (MapRemove A m a'))
      | M2 m'1 m'2 =>
          match MapDomRestrTo_DomBy m1 m'1 with
          | (x1, y1) =>
              match MapDomRestrTo_DomBy m2 m'2 with
              | (x2, y2) => (makeM2 A x1 x2, makeM2 unit y1 y2)
              end
          end
      end
  end.

Lemma MapDomRestrTo_DomBy_lemma_1 :
 forall (m : Map A) (m' : Map B),
 fst (MapDomRestrTo_DomBy m m') = MapDomRestrTo A B m m'.

Lemma MapDomRestrTo_DomBy_lemma_2 :
 forall (m : Map A) (m' : Map B),
 snd (MapDomRestrTo_DomBy m m') = MapDom A (MapDomRestrBy A B m m').

Fixpoint map_app_list1 (pf : ad -> ad) (l : list ad) 
 (m : Map A) {struct m} : list ad :=
  match m with
  | M0 => l
  | M1 a y => pf a :: l
  | M2 m1 m2 =>
      map_app_list1 (fun a0 : ad => pf (Ndouble_plus_one a0))
        (map_app_list1 (fun a0 : ad => pf (Ndouble a0)) l m1) m2
  end.

Lemma map_app_list1_lemma_1 :
 forall (m : Map A) (pf : ad -> ad) (l : list ad) (a : ad),
 In a l -> In a (map_app_list1 pf l m).

Lemma map_app_list1_lemma_2 :
 forall (m : Map A) (pf fp : ad -> ad) (l : list ad),
 (forall a0 : ad, fp (pf a0) = a0) ->
 forall a : ad,
 In a (map_app_list1 pf l m) ->
 In a l \/ in_dom _ (fp a) m = true /\ pf (fp a) = a.

Lemma map_app_list1_lemma_3 :
 forall (m : Map A) (pf fp : ad -> ad) (l : list ad),
 (forall a0 : ad, fp (pf a0) = a0) ->
 no_dup_list _ l ->
 (forall a : ad, in_dom _ a m = true -> ~ In (pf a) l) ->
 no_dup_list _ (map_app_list1 pf l m).

Lemma map_app_list1_lemma_4 :
 forall (m : Map A) (pf : ad -> ad) (l : list ad) (a : ad),
 in_dom _ a m = true -> In (pf a) (map_app_list1 pf l m).

Fixpoint MapDomRestrByApp1 (pf : ad -> ad) (l : list ad) 
 (m : Map A) {struct m} : Map B -> list ad :=
  match m with
  | M0 => fun _ : Map B => l
  | M1 a y =>
      fun m' : Map B =>
      match MapGet B m' a with
      | None => pf a :: l
      | _ => l
      end
  | M2 m1 m2 =>
      fun m' : Map B =>
      match m' with
      | M0 => map_app_list1 pf l m
      | M1 a' y' => map_app_list1 pf l (MapRemove A m a')
      | M2 m'1 m'2 =>
          MapDomRestrByApp1 (fun a0 : ad => pf (Ndouble_plus_one a0))
            (MapDomRestrByApp1 (fun a0 : ad => pf (Ndouble a0)) l m1 m'1)
            m2 m'2
      end
  end.

Lemma MapDomRestrByApp1_lemma_1 :
 forall (m : Map A) (m' : Map B) (l : list ad) (pf : ad -> ad) (a : ad),
 In a l -> In a (MapDomRestrByApp1 pf l m m').

Lemma MapDomRestrByApp1_lemma_2 :
 forall (m : Map A) (m' : Map B) (l : list ad) (pf : ad -> ad) (a : ad),
 in_dom _ a m = true ->
 in_dom _ a m' = false -> In (pf a) (MapDomRestrByApp1 pf l m m').

Lemma MapDomRestrByApp1_lemma_3 :
 forall (m : Map A) (m' : Map B) (l : list ad) (pf fp : ad -> ad),
 (forall a : ad, fp (pf a) = a) ->
 forall a : ad,
 In a (MapDomRestrByApp1 pf l m m') ->
 In a l \/
 in_dom _ (fp a) m = true /\ in_dom _ (fp a) m' = false /\ pf (fp a) = a.

Lemma MapDomRestrByApp1_lemma_4 :
 forall (m : Map A) (m' : Map B) (l : list ad) (pf fp : ad -> ad),
 (forall a : ad, fp (pf a) = a) ->
 (forall a : ad,
  in_dom _ a m = true -> in_dom _ a m' = false -> ~ In (pf a) l) ->
 no_dup_list _ l -> no_dup_list _ (MapDomRestrByApp1 pf l m m').

End My_Map. *)
Require Import config.
(* config:
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import ZArith NArith Nnat Ndec Ndigits.
From IntMap Require Import Map.
From IntMap Require Import Allmaps.
Require Import Wf_nat.
Require Import List.

Require Import misc.
Require Import bool_fun.
Require Import myMap.

Section BDD_config_1.

Definition BDDzero := N0.
Definition BDDone := Npos 1.
Definition BDDstate := Map (BDDvar * (ad * ad)).
Definition BDDsharing_map := Map (Map (Map ad)).
Definition BDDfree_list := list ad.
Definition BDDneg_memo := Map ad.
Definition BDDor_memo := Map (Map ad).
Definition BDDuniv_memo := Map (Map ad).
Definition BDDconfig :=
  (BDDstate *
   (BDDsharing_map *
    (BDDfree_list * (ad * (BDDneg_memo * (BDDor_memo * BDDuniv_memo))))))%type.

Definition initBDDstate := newMap (BDDvar * (ad * ad)).
Definition initBDDsharing_map := newMap (Map (Map ad)).
Definition initBDDfree_list := nil (A:=ad).
Definition initBDDneg_memo := newMap ad.
Definition initBDDor_memo := newMap (Map ad).
Definition initBDDuniv_memo := newMap (Map ad).
Definition initBDDconfig :=
  (initBDDstate,
  (initBDDsharing_map,
  (initBDDfree_list,
  (Npos 2, (initBDDneg_memo, (initBDDor_memo, initBDDuniv_memo)))))).

Definition bs_node_height (bs : BDDstate) (node : ad) :=
  match MapGet _ bs node with
  | None => N0
  | Some (x, (l, r)) => ad_S x
  end.

Definition node_height (cfg : BDDconfig) (node : ad) :=
  bs_node_height (fst cfg) node.

Fixpoint bool_fun_of_BDD_1 (bs : BDDstate) (node : ad) 
 (bound : nat) {struct bound} : bool_fun :=
  match bound with
  | O =>   bool_fun_zero
  | S bound' =>
      match MapGet _ bs node with
      | None => if Neqb node BDDzero then bool_fun_zero else bool_fun_one
      | Some (x, (l, r)) =>
          bool_fun_if x (bool_fun_of_BDD_1 bs r bound')
            (bool_fun_of_BDD_1 bs l bound')
      end
  end.

Definition bool_fun_of_BDD_bs (bs : BDDstate) (node : ad) :=
  bool_fun_of_BDD_1 bs node (S (nat_of_N (bs_node_height bs node))).

Definition bool_fun_of_BDD (cfg : BDDconfig) := bool_fun_of_BDD_bs (fst cfg).

Definition nodes_preserved_bs (bs bs' : BDDstate) :=
  forall (x : BDDvar) (l r node : ad),
  MapGet _ bs node = Some (x, (l, r)) ->
  MapGet _ bs' node = Some (x, (l, r)).

Definition nodes_preserved (cfg cfg' : BDDconfig) :=
  nodes_preserved_bs (fst cfg) (fst cfg').

Inductive nodes_reachable (bs : BDDstate) : ad -> ad -> Prop :=
  | nodes_reachable_0 : forall node : ad, nodes_reachable bs node node
  | nodes_reachable_1 :
      forall (node node' l r : ad) (x : BDDvar),
      MapGet _ bs node = Some (x, (l, r)) ->
      nodes_reachable bs l node' -> nodes_reachable bs node node'
  | nodes_reachable_2 :
      forall (node node' l r : ad) (x : BDDvar),
      MapGet _ bs node = Some (x, (l, r)) ->
      nodes_reachable bs r node' -> nodes_reachable bs node node'.

Definition node_preserved_bs (bs bs' : BDDstate) (node : ad) :=
  forall (x : BDDvar) (l r node' : ad),
  nodes_reachable bs node node' ->
  MapGet _ bs node' = Some (x, (l, r)) ->
  MapGet _ bs' node' = Some (x, (l, r)).

Definition node_preserved (cfg cfg' : BDDconfig) :=
  node_preserved_bs (fst cfg) (fst cfg').

Definition used_node_bs (bs : BDDstate) (ul : list ad) 
  (node : ad) :=
  exists node' : ad, In node' ul /\ nodes_reachable bs node' node. 

Definition used_node'_bs (bs : BDDstate) (ul : list ad) 
  (node : ad) := node = BDDzero \/ node = BDDone \/ used_node_bs bs ul node. 

Definition used_node (cfg : BDDconfig) := used_node_bs (fst cfg).

Definition used_node' (cfg : BDDconfig) := used_node'_bs (fst cfg).

Definition node_OK (bs : BDDstate) (node : ad) :=
  node = BDDzero \/ node = BDDone \/ in_dom _ node bs = true.

Definition config_node_OK (cfg : BDDconfig) := node_OK (fst cfg).

Definition no_new_node_bs (bs bs' : BDDstate) :=
  forall (x : BDDvar) (l r node : ad),
  MapGet _ bs' node = Some (x, (l, r)) ->
  MapGet _ bs node = Some (x, (l, r)).

Definition no_new_node (cfg cfg' : BDDconfig) :=
  no_new_node_bs (fst cfg) (fst cfg').

Inductive BDDbounded (bs : BDDstate) : ad -> BDDvar -> Prop :=
  | BDDbounded_0 : forall n : BDDvar, BDDbounded bs BDDzero n
  | BDDbounded_1 : forall n : BDDvar, BDDbounded bs BDDone n
  | BDDbounded_2 :
      forall (node : ad) (n x : BDDvar) (l r : ad),
      MapGet _ bs node = Some (x, (l, r)) ->
      BDDcompare x n = Datatypes.Lt ->
      Neqb l r = false ->
      BDDbounded bs l x -> BDDbounded bs r x -> BDDbounded bs node n.

Definition BDD_OK (bs : BDDstate) (node : ad) :=
  match MapGet _ bs node with
  | None => node = BDDzero \/ node = BDDone
  | Some (n, _) => BDDbounded bs node (ad_S n)
  end.

Definition BDDstate_OK (bs : BDDstate) :=
  MapGet _ bs BDDzero = None /\
  MapGet _ bs BDDone = None /\
  (forall a : ad, in_dom _ a bs = true -> BDD_OK bs a).

Definition BDDsharing_OK (bs : BDDstate) (share : BDDsharing_map) :=
  forall (x : BDDvar) (l r a : ad),
  MapGet3 _ share l r x = Some a <-> MapGet _ bs a = Some (x, (l, r)).

Definition BDDfree_list_OK (bs : BDDstate) (fl : BDDfree_list) 
  (cnt : ad) :=
  no_dup_list _ fl /\
  (forall node : ad,
   In node fl <->
   Nleb (Npos 2) node = true /\
   Nleb (ad_S node) cnt = true /\ MapGet _ bs node = None).

Definition cnt_OK (bs : BDDstate) (cnt : ad) :=
  Nleb (Npos 2) cnt = true /\
  (forall a : ad, Nleb cnt a = true -> MapGet _ bs a = None).

Definition BDDneg_memo_OK (bs : BDDstate) (negm : BDDneg_memo) :=
  forall node node' : ad,
  MapGet _ negm node = Some node' ->
  node_OK bs node /\
  node_OK bs node' /\
  Neqb (bs_node_height bs node') (bs_node_height bs node) = true /\
  bool_fun_eq (bool_fun_of_BDD_bs bs node')
    (bool_fun_neg (bool_fun_of_BDD_bs bs node)).

Definition BDDor_memo_OK (bs : BDDstate) (orm : BDDor_memo) :=
  forall node1 node2 node : ad,
  MapGet2 _ orm node1 node2 = Some node ->
  node_OK bs node1 /\
  node_OK bs node2 /\
  node_OK bs node /\
  Nleb (bs_node_height bs node)
    (BDDvar_max (bs_node_height bs node1) (bs_node_height bs node2)) = true /\
  bool_fun_eq (bool_fun_of_BDD_bs bs node)
    (bool_fun_or (bool_fun_of_BDD_bs bs node1) (bool_fun_of_BDD_bs bs node2)).

Definition BDDuniv_memo_OK (bs : BDDstate) (um : BDDuniv_memo) :=
  forall (x : BDDvar) (node node' : ad),
  MapGet2 _ um node x = Some node' ->
  node_OK bs node /\
  node_OK bs node' /\
  Nleb (bs_node_height bs node') (bs_node_height bs node) = true /\
  bool_fun_eq (bool_fun_of_BDD_bs bs node')
    (bool_fun_forall x (bool_fun_of_BDD_bs bs node)).

Definition BDDconfig_OK (cfg : BDDconfig) :=
  BDDstate_OK (fst cfg) /\
  BDDsharing_OK (fst cfg) (fst (snd cfg)) /\
  BDDfree_list_OK (fst cfg) (fst (snd (snd cfg))) (fst (snd (snd (snd cfg)))) /\
  cnt_OK (fst cfg) (fst (snd (snd (snd cfg)))) /\
  BDDneg_memo_OK (fst cfg) (fst (snd (snd (snd (snd cfg))))) /\
  BDDor_memo_OK (fst cfg) (fst (snd (snd (snd (snd (snd cfg)))))) /\
  BDDuniv_memo_OK (fst cfg) (snd (snd (snd (snd (snd (snd cfg)))))).

Definition used_list_OK_bs (bs : BDDstate) (ul : list ad) :=
  forall node : ad, In node ul -> node_OK bs node.

Definition used_list_OK (cfg : BDDconfig) := used_list_OK_bs (fst cfg).

Definition used_nodes_preserved_bs (bs bs' : BDDstate) 
  (ul : list ad) :=
  forall node : ad, In node ul -> node_preserved_bs bs bs' node.

Definition used_nodes_preserved (cfg cfg' : BDDconfig) :=
  used_nodes_preserved_bs (fst cfg) (fst cfg').

Definition gc_OK (gc : BDDconfig -> list ad -> BDDconfig) :=
  forall (cfg : BDDconfig) (ul : list ad),
  BDDconfig_OK cfg ->
  used_list_OK cfg ul ->
  BDDconfig_OK (gc cfg ul) /\
  used_nodes_preserved cfg (gc cfg ul) ul /\ no_new_node cfg (gc cfg ul).

Lemma initBDDstate_OK : BDDstate_OK initBDDstate.

Lemma initBDDsharing_map_OK : BDDsharing_OK initBDDstate initBDDsharing_map.

Lemma initBDDfree_list_OK :
 BDDfree_list_OK initBDDstate initBDDfree_list (Npos 2).

Lemma initBDDneg_memo_OK :
 forall bs : BDDstate, BDDneg_memo_OK bs initBDDneg_memo.

Lemma initBDDor_memo_OK :
 forall bs : BDDstate, BDDor_memo_OK bs initBDDor_memo.

Lemma initBDDuniv_memo_OK :
 forall bs : BDDstate, BDDuniv_memo_OK bs initBDDuniv_memo.

Lemma initBDDconfig_OK : BDDconfig_OK initBDDconfig.

Lemma config_OK_zero :
 forall cfg : BDDconfig,
 BDDconfig_OK cfg -> MapGet _ (fst cfg) BDDzero = None.

Lemma config_OK_one :
 forall cfg : BDDconfig,
 BDDconfig_OK cfg -> MapGet _ (fst cfg) BDDone = None.

Lemma zero_OK : forall cfg : BDDconfig, config_node_OK cfg BDDzero.

Lemma one_OK : forall cfg : BDDconfig, config_node_OK cfg BDDone.

Lemma node_height_zero :
 forall cfg : BDDconfig,
 BDDconfig_OK cfg -> Neqb (node_height cfg BDDzero) N0 = true.

Lemma node_height_one :
 forall cfg : BDDconfig,
 BDDconfig_OK cfg -> Neqb (node_height cfg BDDone) N0 = true.

Lemma nodes_preserved_bs_trans :
 forall bs1 bs2 bs3 : BDDstate,
 nodes_preserved_bs bs1 bs2 ->
 nodes_preserved_bs bs2 bs3 -> nodes_preserved_bs bs1 bs3.

Lemma nodes_preserved_bs_refl :
 forall bs : BDDstate, nodes_preserved_bs bs bs.

Lemma nodes_preserved_trans :
 forall cfg1 cfg2 cfg3 : BDDconfig,
 nodes_preserved cfg1 cfg2 ->
 nodes_preserved cfg2 cfg3 -> nodes_preserved cfg1 cfg3.

Lemma nodes_preserved_refl : forall cfg : BDDconfig, nodes_preserved cfg cfg.

Lemma increase_bound :
 forall (bs : BDDstate) (n n' : BDDvar) (node : ad),
 BDDbounded bs node n ->
 BDDcompare n n' = Datatypes.Lt -> BDDbounded bs node n'.

Lemma nodes_preserved_bounded :
 forall (bs bs' : BDDstate) (n : BDDvar) (node : ad),
 nodes_preserved_bs bs bs' -> BDDbounded bs node n -> BDDbounded bs' node n.

Lemma BDDbounded_lemma :
 forall (bs : BDDstate) (node : ad) (n : BDDvar),
 BDDbounded bs node n ->
 node = BDDzero \/
 node = BDDone \/
 (exists x : BDDvar,
    (exists l : BDDvar,
       (exists r : BDDvar,
          MapGet _ bs node = Some (x, (l, r)) /\
          BDDcompare x n = Datatypes.Lt /\

Lemma BDD_OK_node_OK :
 forall (bs : BDDstate) (node : ad), BDD_OK bs node -> node_OK bs node.

Lemma node_OK_BDD_OK :
 forall (bs : BDDstate) (node : ad),
 BDDstate_OK bs -> node_OK bs node -> BDD_OK bs node.

Lemma bs_node_height_left :
 forall (bs : BDDstate) (node l r : ad) (x : BDDvar),
 BDDstate_OK bs ->
 MapGet _ bs node = Some (x, (l, r)) ->
 BDDcompare (bs_node_height bs l) (bs_node_height bs node) = Datatypes.Lt.

Lemma bs_node_height_right :
 forall (bs : BDDstate) (node l r : ad) (x : BDDvar),
 BDDstate_OK bs ->
 MapGet _ bs node = Some (x, (l, r)) ->
 BDDcompare (bs_node_height bs r) (bs_node_height bs node) = Datatypes.Lt.

Lemma internal_node_lemma :
 forall (bs : BDDstate) (x : BDDvar) (l r node : ad),
 BDDstate_OK bs ->
 MapGet _ bs node = Some (x, (l, r)) ->
 Neqb l r = false /\ BDDbounded bs l x /\ BDDbounded bs r x.

Lemma high_bounded :
 forall (bs : BDDstate) (x : BDDvar) (l r node : ad),
 BDDstate_OK bs -> MapGet _ bs node = Some (x, (l, r)) -> BDDbounded bs r x.

Lemma low_bounded :
 forall (bs : BDDstate) (x : BDDvar) (l r node : ad),
 BDDstate_OK bs -> MapGet _ bs node = Some (x, (l, r)) -> BDDbounded bs l x.

Lemma BDDbounded_node_OK :
 forall (bs : BDDstate) (node : ad) (n : BDDvar),
 BDDbounded bs node n -> node_OK bs node.

Lemma high_OK :
 forall (bs : BDDstate) (x : BDDvar) (l r node : ad),
 BDDstate_OK bs -> MapGet _ bs node = Some (x, (l, r)) -> node_OK bs r.

Lemma low_OK :
 forall (bs : BDDstate) (x : BDDvar) (l r node : ad),
 BDDstate_OK bs -> MapGet _ bs node = Some (x, (l, r)) -> node_OK bs l.

Lemma low_high_neq :
 forall (cfg : BDDconfig) (x : BDDvar) (l r node : ad),
 BDDconfig_OK cfg ->
 MapGet _ (fst cfg) node = Some (x, (l, r)) -> Neqb l r = false.

Lemma bs_node_height_left_le :
 forall bs : BDDstate,
 BDDstate_OK bs ->
 forall (x : BDDvar) (l r node : ad),
 MapGet _ bs node = Some (x, (l, r)) ->
 Nleb (bs_node_height bs l) x = true.

Lemma bs_node_height_right_le :
 forall bs : BDDstate,
 BDDstate_OK bs ->
 forall (x : BDDvar) (l r node : ad),
 MapGet _ bs node = Some (x, (l, r)) ->
 Nleb (bs_node_height bs r) x = true.

Lemma no_duplicate_node :
 forall (bs : BDDstate) (share : BDDsharing_map),
 BDDstate_OK bs ->
 BDDsharing_OK bs share ->
 forall (x : BDDvar) (l r node1 node2 : ad),
 MapGet _ bs node1 = Some (x, (l, r)) ->
 MapGet _ bs node2 = Some (x, (l, r)) -> node1 = node2.

Lemma int_node_gt_1 :
 forall (bs : BDDstate) (node : ad),
 BDDstate_OK bs -> in_dom _ node bs = true -> Nleb (Npos 2) node = true.

Lemma int_node_lt_cnt :
 forall (bs : BDDstate) (cnt node : ad),
 cnt_OK bs cnt -> in_dom _ node bs = true -> Nleb (ad_S node) cnt = true.

Lemma nodes_preserved_bs_node_OK :
 forall (bs1 bs2 : BDDstate) (node : ad),
 nodes_preserved_bs bs1 bs2 -> node_OK bs1 node -> node_OK bs2 node.

Lemma nodes_preserved_config_node_OK :
 forall (cfg1 cfg2 : BDDconfig) (node : ad),
 nodes_preserved cfg1 cfg2 ->
 config_node_OK cfg1 node -> config_node_OK cfg2 node.

Lemma nodes_preserved_bs_node_height_eq :
 forall (bs1 bs2 : BDDstate) (node : ad),
 nodes_preserved_bs bs1 bs2 ->
 BDDstate_OK bs1 ->
 BDDstate_OK bs2 ->
 node_OK bs1 node ->
 Neqb (bs_node_height bs2 node) (bs_node_height bs1 node) = true.

Lemma nodes_preserved_node_height_eq :
 forall (cfg1 cfg2 : BDDconfig) (node : ad),
 BDDconfig_OK cfg1 ->
 BDDconfig_OK cfg2 ->
 nodes_preserved cfg1 cfg2 ->
 config_node_OK cfg1 node ->
 Neqb (node_height cfg2 node) (node_height cfg1 node) = true.

  Section Components.

  Variable cfg : BDDconfig.
  Hypothesis cfg_OK : BDDconfig_OK cfg.

  Definition bs_of_cfg := fst cfg.
  Definition share_of_cfg := fst (snd cfg).
  Definition fl_of_cfg := fst (snd (snd cfg)).
  Definition cnt_of_cfg := fst (snd (snd (snd cfg))).
  Definition negm_of_cfg := fst (snd (snd (snd (snd cfg)))).
  Definition orm_of_cfg := fst (snd (snd (snd (snd (snd cfg))))).
  Definition um_of_cfg := snd (snd (snd (snd (snd (snd cfg))))).

  Lemma cfg_comp :
   cfg =
   (bs_of_cfg,
   (share_of_cfg,
   (fl_of_cfg, (cnt_of_cfg, (negm_of_cfg, (orm_of_cfg, um_of_cfg)))))).

  Lemma bs_of_cfg_OK : BDDstate_OK bs_of_cfg.

  Lemma share_of_cfg_OK : BDDsharing_OK bs_of_cfg share_of_cfg.

  Lemma fl_of_cfg_OK : BDDfree_list_OK bs_of_cfg fl_of_cfg cnt_of_cfg.

  Lemma cnt_of_cfg_OK : cnt_OK bs_of_cfg cnt_of_cfg.

  Lemma negm_of_cfg_OK : BDDneg_memo_OK bs_of_cfg negm_of_cfg.

  Lemma orm_of_cfg_OK : BDDor_memo_OK bs_of_cfg orm_of_cfg.
 
  Lemma um_of_cfg_OK : BDDuniv_memo_OK bs_of_cfg um_of_cfg.

  End Components.

Lemma nodes_reachable_lemma_1 :
 forall (bs : BDDstate) (node node' : ad),
 nodes_reachable bs node node' ->
 node = node' \/
 (exists x : BDDvar,
    (exists l : ad,
       (exists r : ad,
          MapGet _ bs node = Some (x, (l, r)) /\
          (nodes_reachable bs l node' \/ nodes_reachable bs r node')))).

Lemma nodes_reachable_trans :
 forall (bs : BDDstate) (node1 node2 node3 : ad),
 nodes_reachable bs node1 node2 ->
 nodes_reachable bs node2 node3 -> nodes_reachable bs node1 node3.

Lemma reachable_node_OK_1 :
 forall (bs : BDDstate) (n : nat) (node1 node2 : ad),
 BDDstate_OK bs ->
 n = nat_of_N (bs_node_height bs node1) ->
 node_OK bs node1 -> nodes_reachable bs node1 node2 -> node_OK bs node2.

Lemma reachable_node_OK :
 forall (bs : BDDstate) (node1 node2 : ad),
 BDDstate_OK bs ->
 node_OK bs node1 -> nodes_reachable bs node1 node2 -> node_OK bs node2.

Lemma nodes_reachableBDDzero :
 forall (bs : BDDstate) (node : ad),
 BDDstate_OK bs -> nodes_reachable bs BDDzero node -> node = BDDzero.

Lemma nodes_reachableBDDone :
 forall (bs : BDDstate) (node : ad),
 BDDstate_OK bs -> nodes_reachable bs BDDone node -> node = BDDone.

Lemma used_node'_used_node_bs :
 forall (bs : BDDstate) (ul : list ad) (node : ad),
 used_node_bs bs ul node -> used_node'_bs bs ul node.

Lemma high_used_bs :
 forall (bs : BDDstate) (ul : list ad) (x : BDDvar) (l r node : ad),
 used_node_bs bs ul node ->
 MapGet _ bs node = Some (x, (l, r)) -> used_node_bs bs ul r.

Lemma high_used'_bs :
 forall (bs : BDDstate) (ul : list ad) (x : BDDvar) (l r node : ad),
 BDDstate_OK bs ->
 used_node'_bs bs ul node ->
 MapGet _ bs node = Some (x, (l, r)) -> used_node'_bs bs ul r.

Lemma low_used_bs :
 forall (bs : BDDstate) (ul : list ad) (x : BDDvar) (l r node : ad),
 used_node_bs bs ul node ->
 MapGet _ bs node = Some (x, (l, r)) -> used_node_bs bs ul l.

Lemma low_used'_bs :
 forall (bs : BDDstate) (ul : list ad) (x : BDDvar) (l r node : ad),
 BDDstate_OK bs ->
 used_node'_bs bs ul node ->
 MapGet _ bs node = Some (x, (l, r)) -> used_node'_bs bs ul l.

Lemma high_used :
 forall (cfg : BDDconfig) (ul : list ad) (x : BDDvar) (l r node : ad),
 used_node cfg ul node ->
 MapGet _ (fst cfg) node = Some (x, (l, r)) -> used_node cfg ul r.

Lemma high_used' :
 forall (cfg : BDDconfig) (ul : list ad) (x : BDDvar) (l r node : ad),
 BDDconfig_OK cfg ->
 used_node' cfg ul node ->
 MapGet _ (fst cfg) node = Some (x, (l, r)) -> used_node' cfg ul r.

Lemma low_used :
 forall (cfg : BDDconfig) (ul : list ad) (x : BDDvar) (l r node : ad),
 used_node cfg ul node ->
 MapGet _ (fst cfg) node = Some (x, (l, r)) -> used_node cfg ul l.

Lemma low_used' :
 forall (cfg : BDDconfig) (ul : list ad) (x : BDDvar) (l r node : ad),
 BDDconfig_OK cfg ->
 used_node' cfg ul node ->
 MapGet _ (fst cfg) node = Some (x, (l, r)) -> used_node' cfg ul l.

Lemma used_node_OK_bs :
 forall (bs : BDDstate) (ul : list ad) (node : ad),
 BDDstate_OK bs ->
 used_list_OK_bs bs ul -> used_node_bs bs ul node -> node_OK bs node.

Lemma used_node'_OK_bs :
 forall (bs : BDDstate) (ul : list ad) (node : ad),
 BDDstate_OK bs ->
 used_list_OK_bs bs ul -> used_node'_bs bs ul node -> node_OK bs node.

Lemma used_node_OK :
 forall (cfg : BDDconfig) (ul : list ad) (node : ad),
 BDDconfig_OK cfg ->
 used_list_OK cfg ul -> used_node cfg ul node -> config_node_OK cfg node.

Lemma used_node'_OK :
 forall (cfg : BDDconfig) (ul : list ad) (node : ad),
 BDDconfig_OK cfg ->
 used_list_OK cfg ul -> used_node' cfg ul node -> config_node_OK cfg node.

Lemma nodes_preserved_used_nodes_preserved :
 forall (cfg cfg' : BDDconfig) (ul : list ad),
 nodes_preserved cfg cfg' -> used_nodes_preserved cfg cfg' ul.

Lemma node_preserved_bs_reachable_1 :
 forall bs bs' : BDDstate,
 BDDstate_OK bs ->
 forall (n : nat) (node node' : ad),
 n = nat_of_N (bs_node_height bs node) ->
 node_preserved_bs bs bs' node ->
 nodes_reachable bs node node' -> nodes_reachable bs' node node'.

Lemma node_preserved_bs_reachable :
 forall (bs bs' : BDDstate) (node node' : ad),
 BDDstate_OK bs ->
 node_preserved_bs bs bs' node ->
 nodes_reachable bs node node' -> nodes_reachable bs' node node'.

Lemma node_preserved_bs_trans :
 forall (bs1 bs2 bs3 : BDDstate) (node : ad),
 BDDstate_OK bs1 ->
 node_preserved_bs bs1 bs2 node ->
 node_preserved_bs bs2 bs3 node -> node_preserved_bs bs1 bs3 node.

Lemma used_nodes_preserved_trans :
 forall (cfg1 cfg2 cfg3 : BDDconfig) (ul : list ad),
 BDDconfig_OK cfg1 ->
 used_nodes_preserved cfg1 cfg2 ul ->
 used_nodes_preserved cfg2 cfg3 ul -> used_nodes_preserved cfg1 cfg3 ul.

Lemma used_nodes_preserved_refl :
 forall (cfg : BDDconfig) (ul : list ad), used_nodes_preserved cfg cfg ul.

Lemma BDDzero_preserved :
 forall bs bs' : BDDstate, BDDstate_OK bs -> node_preserved_bs bs bs' BDDzero.

Lemma BDDone_preserved :
 forall bs bs' : BDDstate, BDDstate_OK bs -> node_preserved_bs bs bs' BDDone.

Lemma used_nodes_preserved_preserved_bs :
 forall (bs bs' : BDDstate) (ul : list ad) (node : ad),
 used_nodes_preserved_bs bs bs' ul ->
 used_node_bs bs ul node -> node_preserved_bs bs bs' node.

Lemma used_nodes_preserved_preserved'_bs :
 forall (bs bs' : BDDstate) (ul : list ad) (node : ad),
 BDDstate_OK bs ->
 used_nodes_preserved_bs bs bs' ul ->
 used_node'_bs bs ul node -> node_preserved_bs bs bs' node.

Lemma node_preserved_OK_bs :
 forall (bs bs' : BDDstate) (node : ad),
 node_OK bs node -> node_preserved_bs bs bs' node -> node_OK bs' node.

Lemma used_nodes_preserved_list_OK_bs :
 forall (bs bs' : BDDstate) (ul : list ad),
 used_list_OK_bs bs ul ->
 used_nodes_preserved_bs bs bs' ul -> used_list_OK_bs bs' ul.

Lemma used_nodes_preserved_list_OK :
 forall (cfg cfg' : BDDconfig) (ul : list ad),
 used_list_OK cfg ul ->
 used_nodes_preserved cfg cfg' ul -> used_list_OK cfg' ul.

Lemma used_node_cons_node_ul :
 forall (cfg : BDDconfig) (ul : list ad) (node : ad),
 used_node cfg (node :: ul) node.

Lemma used_node'_cons_node_ul :
 forall (cfg : BDDconfig) (ul : list ad) (node : ad),
 used_node' cfg (node :: ul) node.

Lemma used_node_cons_node'_ul :
 forall (cfg : BDDconfig) (ul : list ad) (node node' : ad),
 used_node cfg ul node -> used_node cfg (node' :: ul) node.

Lemma used_node'_cons_node'_ul :
 forall (cfg : BDDconfig) (ul : list ad) (node node' : ad),
 used_node' cfg ul node -> used_node' cfg (node' :: ul) node.

Lemma used_nodes_preserved_bs_cons :
 forall (bs bs' : BDDstate) (ul : list ad) (node : ad),
 used_nodes_preserved_bs bs bs' (node :: ul) ->
 used_nodes_preserved_bs bs bs' ul.

Lemma used_nodes_preserved_cons :
 forall (cfg cfg' : BDDconfig) (ul : list ad) (node : ad),
 used_nodes_preserved cfg cfg' (node :: ul) ->
 used_nodes_preserved cfg cfg' ul.

Lemma node_OK_list_OK_bs :
 forall (bs : BDDstate) (ul : list ad) (node : ad),
 node_OK bs node -> used_list_OK_bs bs ul -> used_list_OK_bs bs (node :: ul).

Lemma node_OK_list_OK :
 forall (cfg : BDDconfig) (ul : list ad) (node : ad),
 config_node_OK cfg node ->
 used_list_OK cfg ul -> used_list_OK cfg (node :: ul).

Lemma used_nodes_preserved_node_OK :
 forall (cfg cfg' : BDDconfig) (ul : list ad) (node : ad),
 BDDconfig_OK cfg ->
 used_list_OK cfg ul ->
 used_node cfg ul node ->
 used_nodes_preserved cfg cfg' ul -> config_node_OK cfg' node.

Lemma used_nodes_preserved_node_OK' :
 forall (cfg cfg' : BDDconfig) (ul : list ad) (node : ad),
 BDDconfig_OK cfg ->
 used_list_OK cfg ul ->
 used_node' cfg ul node ->
 used_nodes_preserved cfg cfg' ul -> config_node_OK cfg' node.

Lemma used_nodes_preserved_used_node :
 forall (cfg cfg' : BDDconfig) (ul : list ad) (node : ad),
 BDDconfig_OK cfg ->
 used_nodes_preserved cfg cfg' ul ->
 used_node cfg ul node -> used_node cfg' ul node.

Lemma used_nodes_preserved_used_node' :
 forall (cfg cfg' : BDDconfig) (ul : list ad) (node : ad),
 BDDconfig_OK cfg ->
 used_nodes_preserved cfg cfg' ul ->
 used_node' cfg ul node -> used_node' cfg' ul node.

Lemma bool_fun_of_BDD_1_change_bound :
 forall bs : BDDstate,
 BDDstate_OK bs ->
 forall (bound : nat) (node : ad),
 nat_of_N (bs_node_height bs node) < bound ->
 bool_fun_eq (bool_fun_of_BDD_1 bs node bound)
   (bool_fun_of_BDD_1 bs node (S (nat_of_N (bs_node_height bs node)))).

Lemma bool_fun_of_BDD_bs_zero :
 forall bs : BDDstate,
 BDDstate_OK bs -> bool_fun_eq (bool_fun_of_BDD_bs bs BDDzero) bool_fun_zero.

Lemma bool_fun_of_BDD_bs_one :
 forall bs : BDDstate,
 BDDstate_OK bs -> bool_fun_eq (bool_fun_of_BDD_bs bs BDDone) bool_fun_one.

Lemma bool_fun_of_BDD_bs_int :
 forall bs : BDDstate,
 BDDstate_OK bs ->
 forall (x : BDDvar) (l r node : ad),
 MapGet _ bs node = Some (x, (l, r)) ->
 bool_fun_eq (bool_fun_of_BDD_bs bs node)
   (bool_fun_if x (bool_fun_of_BDD_bs bs r) (bool_fun_of_BDD_bs bs l)).

Lemma bool_fun_of_BDD_one :
 forall cfg : BDDconfig,
 BDDconfig_OK cfg -> bool_fun_eq (bool_fun_of_BDD cfg BDDone) bool_fun_one.

Lemma bool_fun_of_BDD_zero :
 forall cfg : BDDconfig,
 BDDconfig_OK cfg -> bool_fun_eq (bool_fun_of_BDD cfg BDDzero) bool_fun_zero.

Lemma bool_fun_of_BDD_int :
 forall (cfg : BDDconfig) (x : BDDvar) (l r node : ad),
 BDDconfig_OK cfg ->
 MapGet _ (fst cfg) node = Some (x, (l, r)) ->
 bool_fun_eq (bool_fun_of_BDD cfg node)
   (bool_fun_if x (bool_fun_of_BDD cfg r) (bool_fun_of_BDD cfg l)).

Lemma bool_fun_of_BDD_1_ext :
 forall (bound : nat) (bs : BDDstate) (node : ad),
 bool_fun_ext (bool_fun_of_BDD_1 bs node bound).

Lemma bool_fun_of_BDD_bs_ext :
 forall (bs : BDDstate) (node : ad),
 bool_fun_ext (bool_fun_of_BDD_bs bs node).

Lemma BDDvar_independent_1 :
 forall bs : BDDstate,
 BDDstate_OK bs ->
 forall (n : nat) (node : ad) (x : BDDvar),
 n = nat_of_N (bs_node_height bs node) ->
 node_OK bs node ->
 Nleb (bs_node_height bs node) x = true ->
 bool_fun_independent (bool_fun_of_BDD_bs bs node) x.

Lemma BDDvar_independent_bs :
 forall bs : BDDstate,
 BDDstate_OK bs ->
 forall (node : ad) (x : BDDvar),
 node_OK bs node ->
 Nleb (bs_node_height bs node) x = true ->
 bool_fun_independent (bool_fun_of_BDD_bs bs node) x.

Lemma BDDvar_independent_low :
 forall bs : BDDstate,
 BDDstate_OK bs ->
 forall (x : BDDvar) (l r node : ad),
 MapGet _ bs node = Some (x, (l, r)) ->
 bool_fun_independent (bool_fun_of_BDD_bs bs l) x.

Lemma BDDvar_independent_high :
 forall bs : BDDstate,
 BDDstate_OK bs ->
 forall (x : BDDvar) (l r node : ad),
 MapGet _ bs node = Some (x, (l, r)) ->
 bool_fun_independent (bool_fun_of_BDD_bs bs r) x.

Lemma bool_fun_of_BDD_bs_high :
 forall bs : BDDstate,
 BDDstate_OK bs ->
 forall (x : BDDvar) (l r node : ad),
 MapGet _ bs node = Some (x, (l, r)) ->
 bool_fun_eq (bool_fun_of_BDD_bs bs r)
   (bool_fun_restrict (bool_fun_of_BDD_bs bs node) x true).

Lemma bool_fun_of_BDD_bs_low :
 forall bs : BDDstate,
 BDDstate_OK bs ->
 forall (x : BDDvar) (l r node : ad),
 MapGet _ bs node = Some (x, (l, r)) ->
 bool_fun_eq (bool_fun_of_BDD_bs bs l)
   (bool_fun_restrict (bool_fun_of_BDD_bs bs node) x false).

Lemma BDDunique_1 :
 forall (bs : BDDstate) (share : BDDsharing_map),
 BDDstate_OK bs ->
 BDDsharing_OK bs share ->
 forall (n : nat) (node1 node2 : ad),
 n =
 max (nat_of_N (bs_node_height bs node1))
   (nat_of_N (bs_node_height bs node2)) ->
 node_OK bs node1 ->
 node_OK bs node2 ->
 bool_fun_eq (bool_fun_of_BDD_bs bs node1) (bool_fun_of_BDD_bs bs node2) ->
 node1 = node2.

Lemma BDDunique :
 forall (cfg : BDDconfig) (node1 node2 : ad),
 BDDconfig_OK cfg ->
 config_node_OK cfg node1 ->
 config_node_OK cfg node2 ->
 bool_fun_eq (bool_fun_of_BDD cfg node1) (bool_fun_of_BDD cfg node2) ->
 Neqb node1 node2 = true.

Lemma nodes_preserved_bs_bool_fun_1 :
 forall (bs1 bs2 : BDDstate) (n : nat) (node : ad),
 n = nat_of_N (bs_node_height bs1 node) ->
 BDDstate_OK bs1 ->
 BDDstate_OK bs2 ->
 nodes_preserved_bs bs1 bs2 ->
 node_OK bs1 node ->
 bool_fun_eq (bool_fun_of_BDD_bs bs2 node) (bool_fun_of_BDD_bs bs1 node).

Lemma nodes_preserved_bs_bool_fun :
 forall (bs1 bs2 : BDDstate) (node : ad),
 BDDstate_OK bs1 ->
 BDDstate_OK bs2 ->
 nodes_preserved_bs bs1 bs2 ->
 node_OK bs1 node ->
 bool_fun_eq (bool_fun_of_BDD_bs bs2 node) (bool_fun_of_BDD_bs bs1 node).

Lemma nodes_preserved_bool_fun :
 forall (cfg1 cfg2 : BDDconfig) (node : ad),
 BDDconfig_OK cfg1 ->
 BDDconfig_OK cfg2 ->
 nodes_preserved cfg1 cfg2 ->
 config_node_OK cfg1 node ->
 bool_fun_eq (bool_fun_of_BDD cfg2 node) (bool_fun_of_BDD cfg1 node).

Lemma nodes_preserved_neg_memo_OK :
 forall (bs bs' : BDDstate) (negm : BDDneg_memo),
 nodes_preserved_bs bs bs' ->
 BDDstate_OK bs ->
 BDDstate_OK bs' -> BDDneg_memo_OK bs negm -> BDDneg_memo_OK bs' negm.

Lemma nodes_preserved_or_memo_OK :
 forall (bs bs' : BDDstate) (orm : BDDor_memo),
 nodes_preserved_bs bs bs' ->
 BDDstate_OK bs ->
 BDDstate_OK bs' -> BDDor_memo_OK bs orm -> BDDor_memo_OK bs' orm.

Lemma nodes_preserved_um_OK :
 forall (bs bs' : BDDstate) (um : BDDuniv_memo),
 nodes_preserved_bs bs bs' ->
 BDDstate_OK bs ->
 BDDstate_OK bs' -> BDDuniv_memo_OK bs um -> BDDuniv_memo_OK bs' um.

Lemma node_preserved_bs_bool_fun_1 :
 forall (n : nat) (bs bs' : BDDstate) (node : ad),
 BDDstate_OK bs ->
 BDDstate_OK bs' ->
 node_preserved_bs bs bs' node ->
 node_OK bs node ->
 n = nat_of_N (bs_node_height bs node) ->
 bool_fun_eq (bool_fun_of_BDD_bs bs' node) (bool_fun_of_BDD_bs bs node).

Lemma node_preserved_bs_bool_fun :
 forall (bs bs' : BDDstate) (node : ad),
 BDDstate_OK bs ->
 BDDstate_OK bs' ->
 node_preserved_bs bs bs' node ->
 node_OK bs node ->
 bool_fun_eq (bool_fun_of_BDD_bs bs' node) (bool_fun_of_BDD_bs bs node).

Lemma node_preserved_bs_node_height_eq :
 forall (bs bs' : BDDstate) (node : ad),
 BDDstate_OK bs ->
 BDDstate_OK bs' ->
 node_preserved_bs bs bs' node ->
 node_OK bs node ->
 Neqb (bs_node_height bs' node) (bs_node_height bs node) = true.

Lemma node_preserved_node_height_eq :
 forall (cfg cfg' : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 BDDconfig_OK cfg' ->
 node_preserved cfg cfg' node ->
 config_node_OK cfg node ->
 Neqb (node_height cfg' node) (node_height cfg node) = true.

Lemma used_nodes_preserved_node_height_eq :
 forall (cfg cfg' : BDDconfig) (ul : list ad) (node : ad),
 BDDconfig_OK cfg ->
 BDDconfig_OK cfg' ->
 used_nodes_preserved cfg cfg' ul ->
 used_list_OK cfg ul ->
 used_node cfg ul node ->
 Neqb (node_height cfg' node) (node_height cfg node) = true.

Lemma used_nodes_preserved'_node_height_eq :
 forall (cfg cfg' : BDDconfig) (ul : list ad) (node : ad),
 BDDconfig_OK cfg ->
 BDDconfig_OK cfg' ->
 used_nodes_preserved cfg cfg' ul ->
 used_list_OK cfg ul ->
 used_node' cfg ul node ->
 Neqb (node_height cfg' node) (node_height cfg node) = true.

Lemma used_nodes_preserved_bs_bool_fun :
 forall (bs bs' : BDDstate) (ul : list ad) (node : ad),
 BDDstate_OK bs ->
 BDDstate_OK bs' ->
 used_nodes_preserved_bs bs bs' ul ->
 used_list_OK_bs bs ul ->
 used_node_bs bs ul node ->
 bool_fun_eq (bool_fun_of_BDD_bs bs' node) (bool_fun_of_BDD_bs bs node).

Lemma used_nodes_preserved'_bs_bool_fun :
 forall (bs bs' : BDDstate) (ul : list ad) (node : ad),
 BDDstate_OK bs ->
 BDDstate_OK bs' ->
 used_nodes_preserved_bs bs bs' ul ->
 used_list_OK_bs bs ul ->
 used_node'_bs bs ul node ->
 bool_fun_eq (bool_fun_of_BDD_bs bs' node) (bool_fun_of_BDD_bs bs node).

Lemma used_nodes_preserved_bool_fun :
 forall (cfg cfg' : BDDconfig) (ul : list ad) (node : ad),
 BDDconfig_OK cfg ->
 BDDconfig_OK cfg' ->
 used_nodes_preserved cfg cfg' ul ->
 used_list_OK cfg ul ->
 used_node cfg ul node ->
 bool_fun_eq (bool_fun_of_BDD cfg' node) (bool_fun_of_BDD cfg node).

Lemma used_nodes_preserved'_bool_fun :
 forall (cfg cfg' : BDDconfig) (ul : list ad) (node : ad),
 BDDconfig_OK cfg ->
 BDDconfig_OK cfg' ->
 used_nodes_preserved cfg cfg' ul ->
 used_list_OK cfg ul ->
 used_node' cfg ul node ->
 bool_fun_eq (bool_fun_of_BDD cfg' node) (bool_fun_of_BDD cfg node).

Definition BDDneg_memo_put (cfg : BDDconfig) (node node' : ad) :=
  match cfg with
  | (bs, (share, (fl, (cnt, (negm, z))))) =>
      (bs, (share, (fl, (cnt, (MapPut _ negm node node', z)))))
  end.

Lemma BDDnegm_put_OK :
 forall (cfg : BDDconfig) (node node' : ad),
 BDDconfig_OK cfg ->
 config_node_OK cfg node ->
 config_node_OK cfg node' ->
 Neqb (node_height cfg node') (node_height cfg node) = true ->
 bool_fun_eq (bool_fun_of_BDD cfg node')
   (bool_fun_neg (bool_fun_of_BDD cfg node)) ->
 BDDconfig_OK (BDDneg_memo_put cfg node node').

Definition BDDor_memo_put (cfg : BDDconfig) (node1 node2 node' : ad) :=
  match cfg with
  | (bs, (share, (fl, (cnt, (negm, (orm, um)))))) =>
      (bs,
      (share, (fl, (cnt, (negm, (MapPut2 _ orm node1 node2 node', um))))))
  end.

Lemma BDDorm_put_nodes_preserved :
 forall (cfg : BDDconfig) (node1 node2 node' : ad),
 nodes_preserved cfg (BDDor_memo_put cfg node1 node2 node').

Lemma BDDorm_put_OK :
 forall (cfg : BDDconfig) (node1 node2 node' : ad),
 BDDconfig_OK cfg ->
 config_node_OK cfg node1 ->
 config_node_OK cfg node2 ->
 config_node_OK cfg node' ->
 Nleb (node_height cfg node')
   (BDDvar_max (node_height cfg node1) (node_height cfg node2)) = true ->
 bool_fun_eq (bool_fun_of_BDD cfg node')
   (bool_fun_or (bool_fun_of_BDD cfg node1) (bool_fun_of_BDD cfg node2)) ->
 BDDconfig_OK (BDDor_memo_put cfg node1 node2 node').

Lemma BDDnegm_put_nodes_preserved :
 forall (cfg : BDDconfig) (node node' : ad),
 nodes_preserved cfg (BDDneg_memo_put cfg node node').

Definition BDDuniv_memo_put (cfg : BDDconfig) (x : BDDvar)
  (node node' : ad) :=
  match cfg with
  | (bs, (share, (fl, (cnt, (negm, (orm, um)))))) =>
      (bs, (share, (fl, (cnt, (negm, (orm, MapPut2 ad um node x node'))))))
  end.

Lemma BDDum_put_nodes_preserved :
 forall (cfg : BDDconfig) (x : BDDvar) (node node' : ad),
 nodes_preserved cfg (BDDuniv_memo_put cfg x node node').

Lemma BDDum_put_OK :
 forall (cfg : BDDconfig) (x : BDDvar) (node node' : ad),
 BDDconfig_OK cfg ->
 config_node_OK cfg node ->
 config_node_OK cfg node' ->
 Nleb (node_height cfg node') (node_height cfg node) = true ->
 bool_fun_eq (bool_fun_of_BDD cfg node')
   (bool_fun_forall x (bool_fun_of_BDD cfg node)) ->
 BDDconfig_OK (BDDuniv_memo_put cfg x node node').

Lemma not_zero_is_one :
 forall (cfg : BDDconfig) (node : ad),
 config_node_OK cfg node ->
 in_dom _ node (fst cfg) = false ->
 Neqb node BDDzero = false -> Neqb node BDDone = true.

Lemma used'_zero :
 forall (cfg : BDDconfig) (ul : list ad), used_node' cfg ul BDDzero.

Lemma used'_one :
 forall (cfg : BDDconfig) (ul : list ad), used_node' cfg ul BDDone.

Lemma cons_OK_list_OK :
 forall (cfg : BDDconfig) (ul : list ad) (node : ad),
 used_list_OK cfg (node :: ul) -> used_list_OK cfg ul.

End BDD_config_1. *)
Require Import alloc.
(* alloc:
Require Import Bool.	
Require Import Sumbool.
Require Import Arith.
Require Import ZArith NArith Nnat Ndec Ndigits.		
From IntMap Require Import Map.
From IntMap Require Import Allmaps.			
Require Import List.
Require Import Wf_nat.
  
Require Import misc.
Require Import bool_fun.
Require Import myMap.
Require Import config.

Section BDD_alloc.

Variable gc : BDDconfig -> list ad -> BDDconfig.
Hypothesis gc_is_OK : gc_OK gc.

Variable cfg : BDDconfig.
Variable x : BDDvar.
Variable l r : ad.
Variable ul : list ad.

Hypothesis cfg_OK : BDDconfig_OK cfg.
Hypothesis ul_OK : used_list_OK cfg ul.
Hypothesis l_used' : used_node' cfg ul l.
Hypothesis r_used' : used_node' cfg ul r.
Hypothesis l_neq_r : Neqb l r = false.
Hypothesis
  xl_lt_x :
    forall (xl : BDDvar) (ll rl : ad),
    MapGet _ (bs_of_cfg cfg) l = Some (xl, (ll, rl)) ->
    BDDcompare xl x = Datatypes.Lt.
Hypothesis
  xr_lt_x :
    forall (xr : BDDvar) (lr rr : ad),
    MapGet _ (bs_of_cfg cfg) r = Some (xr, (lr, rr)) ->
    BDDcompare xr x = Datatypes.Lt.
Hypothesis
  no_dup :
    forall (x' : BDDvar) (l' r' a : ad),
    MapGet _ (bs_of_cfg cfg) a = Some (x', (l', r')) ->
    (x, (l, r)) <> (x', (l', r')).

Let new_cfg := gc cfg ul.

Lemma no_dup_new :
 forall (x' : BDDvar) (l' r' a : ad),
 MapGet _ (bs_of_cfg new_cfg) a = Some (x', (l', r')) ->
 (x, (l, r)) <> (x', (l', r')).

Lemma new_cfg_OK : BDDconfig_OK new_cfg.

Lemma new_cfg_nodes_preserved : used_nodes_preserved cfg new_cfg ul.

Lemma new_l_OK : node_OK (bs_of_cfg new_cfg) l.

Lemma new_r_OK : node_OK (bs_of_cfg new_cfg) r.

Lemma BDD_OK_l : BDD_OK (bs_of_cfg new_cfg) l.

Lemma BDD_OK_r : BDD_OK (bs_of_cfg new_cfg) r.

Lemma new_xl_lt_x :
 forall (xl : BDDvar) (ll rl : ad),
 MapGet _ (bs_of_cfg new_cfg) l = Some (xl, (ll, rl)) ->
 BDDcompare xl x = Datatypes.Lt.

Lemma new_xr_lt_x :
 forall (xr : BDDvar) (lr rr : ad),
 MapGet _ (bs_of_cfg new_cfg) r = Some (xr, (lr, rr)) ->
 BDDcompare xr x = Datatypes.Lt.

Definition BDDalloc : BDDconfig * ad :=
  match new_cfg with
  | (bs, (share, (fl, (cnt, (negm, orm))))) =>
      match fl with
      | a :: fl' =>
          (MapPut _ bs a (x, (l, r)),
          (MapPut3 _ share l r x a, (fl', (cnt, (negm, orm)))), a)
      | nil =>
          (MapPut _ bs cnt (x, (l, r)),
          (MapPut3 _ share l r x cnt, (fl, (ad_S cnt, (negm, orm)))), cnt)
      end
  end.
  
Lemma BDDalloc_lemma_1 :
 forall a : ad,
 MapGet _ (fst (fst BDDalloc)) a =
 (if Neqb a (snd BDDalloc)
  then Some (x, (l, r))
  else MapGet _ (fst new_cfg) a).

Lemma BDDalloc_lemma_2 :
 In (snd BDDalloc) (fl_of_cfg new_cfg) \/ cnt_of_cfg new_cfg = snd BDDalloc.

Lemma BDDalloc_lemma_3 : MapGet _ (bs_of_cfg new_cfg) (snd BDDalloc) = None.

Lemma BDDalloc_lemma_4 :
 fst (fst BDDalloc) = MapPut _ (bs_of_cfg new_cfg) (snd BDDalloc) (x, (l, r)).

Lemma BDDalloc_lemma_5 :
 fst (snd (fst BDDalloc)) =
 MapPut3 _ (share_of_cfg new_cfg) l r x (snd BDDalloc).

Lemma BDDalloc_preserves_nodes :
 nodes_preserved_bs (bs_of_cfg new_cfg) (fst (fst BDDalloc)).

Lemma BDDalloc_zero : MapGet _ (fst (fst BDDalloc)) BDDzero = None.

Lemma BDDalloc_one : MapGet _ (fst (fst BDDalloc)) BDDone = None.

Lemma BDDalloc_BDD_OK : BDD_OK (fst (fst BDDalloc)) (snd BDDalloc).

Lemma BDDalloc_keeps_state_OK : BDDstate_OK (fst (fst BDDalloc)).

Lemma BDDsharing_OK_1 :
 forall a : ad,
 MapGet _ (bs_of_cfg new_cfg) a = None ->
 BDDsharing_OK (MapPut _ (bs_of_cfg new_cfg) a (x, (l, r)))
   (MapPut3 _ (share_of_cfg new_cfg) l r x a).

Lemma BDDalloc_keeps_sharing_OK :
 BDDsharing_OK (fst (fst BDDalloc)) (fst (snd (fst BDDalloc))).

Lemma BDDalloc_keeps_cnt_OK :
 cnt_OK (fst (fst BDDalloc)) (fst (snd (snd (snd (fst BDDalloc))))).

Lemma BDDalloc_keeps_free_list_OK :
 BDDfree_list_OK (fst (fst BDDalloc)) (fst (snd (snd (fst BDDalloc))))
   (fst (snd (snd (snd (fst BDDalloc))))).

Lemma BDDalloc_orm_same : orm_of_cfg (fst BDDalloc) = orm_of_cfg new_cfg.

Lemma BDDalloc_negm_same : negm_of_cfg (fst BDDalloc) = negm_of_cfg new_cfg.

Lemma BDDalloc_um_same : um_of_cfg (fst BDDalloc) = um_of_cfg new_cfg.

Lemma BDDalloc_keeps_neg_memo_OK :
 BDDneg_memo_OK (bs_of_cfg (fst BDDalloc)) (negm_of_cfg (fst BDDalloc)).

Lemma BDDalloc_keeps_or_memo_OK :
 BDDor_memo_OK (bs_of_cfg (fst BDDalloc)) (orm_of_cfg (fst BDDalloc)).

Lemma BDDalloc_keeps_univ_memo_OK :
 BDDuniv_memo_OK (bs_of_cfg (fst BDDalloc)) (um_of_cfg (fst BDDalloc)).

Lemma BDDalloc_keeps_config_OK : BDDconfig_OK (fst BDDalloc).
 
Lemma BDDalloc_preserves_used_nodes :
 used_nodes_preserved cfg (fst BDDalloc) ul.

Lemma BDDalloc_node_OK : config_node_OK (fst BDDalloc) (snd BDDalloc).

Lemma BDDallocGet :
 MapGet _ (fst (fst BDDalloc)) (snd BDDalloc) = Some (x, (l, r)).

End BDD_alloc. *)
Require Import make.
(* make:
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import ZArith NArith Nnat Ndec Ndigits.
From IntMap Require Import Map.
From IntMap Require Import Allmaps.
Require Import List.
Require Import Wf_nat.

Require Import misc.
Require Import bool_fun.
Require Import myMap.
Require Import config.
Require Import alloc.

Section BDD_make.

Variable gc : BDDconfig -> list ad -> BDDconfig.
Hypothesis gc_is_OK : gc_OK gc.

Variable cfg : BDDconfig.
Variable x : BDDvar.
Variable l r : ad.
Variable ul : list ad.

Hypothesis cfg_OK : BDDconfig_OK cfg.
Hypothesis ul_OK : used_list_OK cfg ul.
Hypothesis l_used' : used_node' cfg ul l.
Hypothesis r_used' : used_node' cfg ul r.
Hypothesis
  xl_lt_x :
    forall (xl : BDDvar) (ll rl : ad),
    MapGet _ (bs_of_cfg cfg) l = Some (xl, (ll, rl)) ->
    BDDcompare xl x = Datatypes.Lt.
Hypothesis
  xr_lt_x :
    forall (xr : BDDvar) (lr rr : ad),
    MapGet _ (bs_of_cfg cfg) r = Some (xr, (lr, rr)) ->
    BDDcompare xr x = Datatypes.Lt.

Lemma no_dup :
 MapGet3 ad (fst (snd cfg)) l r x = None ->
 forall (x' : BDDvar) (l' r' a : ad),
 MapGet (BDDvar * (ad * ad)) (bs_of_cfg cfg) a =
 Some (x', (l', r')) -> (x, (l, r)) <> (x', (l', r')).

Definition BDDmake :=
  if Neqb l r
  then (cfg, l)
  else
   match MapGet3 _ (fst (snd cfg)) l r x with
   | Some y => (cfg, y)
   | None => BDDalloc gc cfg x l r ul
   end.

Lemma BDDmake_keeps_config_OK : BDDconfig_OK (fst BDDmake).

Lemma BDDmake_preserves_used_nodes :
 used_nodes_preserved cfg (fst BDDmake) ul.

Lemma BDDmake_node_OK : config_node_OK (fst BDDmake) (snd BDDmake).

Lemma BDDmake_bool_fun :
 bool_fun_eq (bool_fun_of_BDD (fst BDDmake) (snd BDDmake))
   (bool_fun_if x (bool_fun_of_BDD cfg r) (bool_fun_of_BDD cfg l)).

Lemma BDDmake_node_height_eq :
 Neqb l r = false ->
 Neqb (node_height (fst BDDmake) (snd BDDmake)) (ad_S x) = true.

Lemma BDDmake_node_height_eq_1 :
 Neqb l r = true ->
 Neqb (node_height (fst BDDmake) (snd BDDmake)) (node_height cfg l) = true.

Lemma BDDmake_node_height_le :
 Nleb (node_height (fst BDDmake) (snd BDDmake)) (ad_S x) = true.

End BDD_make. *)

Section BDD_or.

Variable gc : BDDconfig -> list ad -> BDDconfig.
Hypothesis gc_is_OK : gc_OK gc.

Fixpoint BDDor_1 (cfg : BDDconfig) (ul : list ad) (node1 node2 : ad)
 (bound : nat) {struct bound} : BDDconfig * ad :=
  match bound with
  | O =>   (initBDDconfig, BDDzero)
  | S bound' =>
      match MapGet2 _ (orm_of_cfg cfg) node1 node2 with
      | Some node' => (cfg, node')
      | None =>
          match MapGet _ (fst cfg) node1 with
          | None =>
              if Neqb node1 BDDzero
              then (BDDor_memo_put cfg node1 node2 node2, node2)
              else (BDDor_memo_put cfg node1 node2 node1, node1)
          | Some (x1, (l1, r1)) =>
              match MapGet _ (fst cfg) node2 with
              | None =>
                  if Neqb node2 BDDzero
                  then (BDDor_memo_put cfg node1 node2 node1, node1)
                  else (BDDor_memo_put cfg node1 node2 node2, node2)
              | Some (x2, (l2, r2)) =>
                  match BDDcompare x1 x2 with
                  | Datatypes.Eq =>
                      match BDDor_1 cfg ul l1 l2 bound' with
                      | (cfgl, nodel) =>
                          match BDDor_1 cfgl (nodel :: ul) r1 r2 bound' with
                          | (cfgr, noder) =>
                              match
                                BDDmake gc cfgr x1 nodel noder
                                  (noder :: nodel :: ul)
                              with
                              | (cfg', node') =>
                                  (BDDor_memo_put cfg' node1 node2 node',
                                  node')
                              end
                          end
                      end
                  | Datatypes.Gt =>
                      match BDDor_1 cfg ul l1 node2 bound' with
                      | (cfgl, nodel) =>
                          match
                            BDDor_1 cfgl (nodel :: ul) r1 node2 bound'
                          with
                          | (cfgr, noder) =>
                              match
                                BDDmake gc cfgr x1 nodel noder
                                  (noder :: nodel :: ul)
                              with
                              | (cfg', node') =>
                                  (BDDor_memo_put cfg' node1 node2 node',
                                  node')
                              end
                          end
                      end
                  | Datatypes.Lt =>
                      match BDDor_1 cfg ul node1 l2 bound' with
                      | (cfgl, nodel) =>
                          match
                            BDDor_1 cfgl (nodel :: ul) node1 r2 bound'
                          with
                          | (cfgr, noder) =>
                              match
                                BDDmake gc cfgr x2 nodel noder
                                  (noder :: nodel :: ul)
                              with
                              | (cfg', node') =>
                                  (BDDor_memo_put cfg' node1 node2 node',
                                  node')
                              end
                          end
                      end
                  end
              end
          end
      end
  end.

Lemma BDDor_1_lemma :
 forall (bound : nat) (cfg : BDDconfig) (ul : list ad) (node1 node2 : ad),
 max (nat_of_N (node_height cfg node1)) (nat_of_N (node_height cfg node2)) <
 bound ->
 BDDconfig_OK cfg ->
 used_list_OK cfg ul ->
 used_node' cfg ul node1 ->
 used_node' cfg ul node2 ->
 BDDconfig_OK (fst (BDDor_1 cfg ul node1 node2 bound)) /\
 config_node_OK (fst (BDDor_1 cfg ul node1 node2 bound))
   (snd (BDDor_1 cfg ul node1 node2 bound)) /\
 used_nodes_preserved cfg (fst (BDDor_1 cfg ul node1 node2 bound)) ul /\
 Nleb
   (node_height (fst (BDDor_1 cfg ul node1 node2 bound))
      (snd (BDDor_1 cfg ul node1 node2 bound)))
   (BDDvar_max (node_height cfg node1) (node_height cfg node2)) = true /\
 bool_fun_eq
   (bool_fun_of_BDD (fst (BDDor_1 cfg ul node1 node2 bound))
      (snd (BDDor_1 cfg ul node1 node2 bound)))
   (bool_fun_or (bool_fun_of_BDD cfg node1) (bool_fun_of_BDD cfg node2)).
Proof.
  simple induction bound.  intros.
  absurd
   (max (nat_of_N (node_height cfg node1))
      (nat_of_N (node_height cfg node2)) < 0).
  apply lt_n_O.  assumption.  simpl in |- *.  intros.
  elim (option_sum _ (MapGet2 ad (orm_of_cfg cfg) node1 node2)).  intro y.
  elim y; clear y; intros node' H5.  rewrite H5.  simpl in |- *.
  elim (orm_of_cfg_OK _ H1 _ _ _ H5).  intros.  elim H7; intros.
  elim H9; intros.  elim H11; intros.  split.  assumption.  split.
  assumption.  split.  apply used_nodes_preserved_refl.  split.  assumption.
  assumption.  intro y.  rewrite y.
  elim (option_sum _ (MapGet (BDDvar * (ad * ad)) (fst cfg) node1)).  intro y0.
  elim y0; clear y0.
  intro x; elim x; clear x; intros x1 x0; elim x0; clear x0; intros l1 r1 H5.
  rewrite H5.  elim (option_sum _ (MapGet (BDDvar * (ad * ad)) (fst cfg) node2)).
  intro y0.  elim y0; clear y0.
  intro x; elim x; clear x; intros x2 x0; elim x0; clear x0; intros l2 r2 H6.
  rewrite H6.  elim (relation_sum (BDDcompare x1 x2)).  intro y0.
  elim y0; clear y0; intro y0.  rewrite y0.  elim (prod_sum _ _ (BDDor_1 cfg ul l1 l2 n)).
  intros cfgl H7.  elim H7; clear H7.  intros nodel H7.  rewrite H7.
  elim (prod_sum _ _ (BDDor_1 cfgl (nodel :: ul) r1 r2 n)).  intros cfgr H8.
  elim H8; clear H8.  intros noder H8.  rewrite H8.
  elim (prod_sum _ _ (BDDmake gc cfgr x1 nodel noder (noder :: nodel :: ul))).
  intros cfg' H9.  elim H9; clear H9.  intros node' H9.  rewrite H9.  simpl in |- *.
  cut (used_node' cfg ul l1).  cut (used_node' cfg ul r1).
  cut (used_node' cfg ul l2).  cut (used_node' cfg ul r2).  intros.  
  cut
   (BDDconfig_OK cfgl /\
    config_node_OK cfgl nodel /\
    used_nodes_preserved cfg cfgl ul /\
    Nleb (node_height cfgl nodel)
      (BDDvar_max (node_height cfg l1) (node_height cfg l2)) = true /\
    bool_fun_eq (bool_fun_of_BDD cfgl nodel)
      (bool_fun_or (bool_fun_of_BDD cfg l1) (bool_fun_of_BDD cfg l2))).
  intro.  elim H14; clear H14; intros.  elim H15; clear H15; intros.
  elim H16; clear H16; intros.  elim H17; clear H17; intros.
  cut (used_list_OK cfgl ul).  intro.  cut (used_list_OK cfgl (nodel :: ul)).
  intro.  cut (used_node' cfgl ul r1).  cut (used_node' cfgl ul r2).  intros.
  cut (used_node' cfgl (nodel :: ul) r1).  cut (used_node' cfgl (nodel :: ul) r2).
  intros.  cut
   (BDDconfig_OK cfgr /\
    config_node_OK cfgr noder /\
    used_nodes_preserved cfgl cfgr (nodel :: ul) /\
    Nleb (node_height cfgr noder)
      (BDDvar_max (node_height cfgl r1) (node_height cfgl r2)) = true /\
    bool_fun_eq (bool_fun_of_BDD cfgr noder)
      (bool_fun_or (bool_fun_of_BDD cfgl r1) (bool_fun_of_BDD cfgl r2))).

  intro.  elim H25; clear H25; intros.  elim H26; clear H26; intros.
  elim H27; clear H27; intros.  elim H28; clear H28; intros.
  cut (used_list_OK cfgr (nodel :: ul)).  intro.
  cut (used_list_OK cfgr (noder :: nodel :: ul)).  intro.
  cut (used_node' cfgr (noder :: nodel :: ul) nodel).
  cut (used_node' cfgr (noder :: nodel :: ul) noder).  intros.
  cut
   (forall (xl : BDDvar) (ll rl : ad),
    MapGet _ (fst cfgr) nodel = Some (xl, (ll, rl)) ->
    BDDcompare xl x1 = Datatypes.Lt).
  cut
   (forall (xr : BDDvar) (lr rr : ad),
    MapGet _ (fst cfgr) noder = Some (xr, (lr, rr)) ->
    BDDcompare xr x1 = Datatypes.Lt).
  intros.  cut (BDDconfig_OK cfg').
  cut (used_nodes_preserved cfgr cfg' (noder :: nodel :: ul)).
  cut (config_node_OK cfg' node').
  cut
   (bool_fun_eq (bool_fun_of_BDD cfg' node')
      (bool_fun_if x1 (bool_fun_of_BDD cfgr noder)
         (bool_fun_of_BDD cfgr nodel))).
  cut (Nleb (node_height cfg' node') (ad_S x1) = true).  intros.
  cut (config_node_OK cfg' node1).  cut (config_node_OK cfg' node2).  intros.
  cut (nodes_preserved cfg' (BDDor_memo_put cfg' node1 node2 node')).  intro.
  cut (BDDconfig_OK (BDDor_memo_put cfg' node1 node2 node')).  intro.  split.
  assumption.  split.  apply nodes_preserved_config_node_OK with (cfg1 := cfg').
  assumption.  assumption.  split.
  apply used_nodes_preserved_trans with (cfg2 := cfgr).  assumption.  
  apply used_nodes_preserved_trans with (cfg2 := cfgl).  assumption.  assumption.
  apply used_nodes_preserved_cons with (node := nodel).  assumption.
  apply used_nodes_preserved_trans with (cfg2 := cfg').  assumption.
  apply used_nodes_preserved_cons with (node := nodel).
  apply used_nodes_preserved_cons with (node := noder).  assumption.
  apply nodes_preserved_used_nodes_preserved.  assumption.  
  rewrite
   (Neqb_complete
      (node_height (BDDor_memo_put cfg' node1 node2 node') node')
      (node_height cfg' node')).
  split.  unfold node_height at 2 3 in |- *.  unfold bs_node_height in |- *.  rewrite H5.  rewrite H6.
  rewrite <- (BDD_EGAL_complete _ _ y0).  apply Nleb_trans with (b := ad_S x1).
  assumption.  apply BDDvar_le_max_1.
  apply bool_fun_eq_trans with (bf2 := bool_fun_of_BDD cfg' node').
  apply nodes_preserved_bool_fun.  assumption.  assumption.  assumption.  
  assumption.  apply
   bool_fun_eq_trans
    with
      (bf2 := bool_fun_if x1 (bool_fun_of_BDD cfgr noder)
                (bool_fun_of_BDD cfgr nodel)).
  assumption.  apply
   bool_fun_eq_trans
    with
      (bf2 := bool_fun_if x1
                (bool_fun_or (bool_fun_of_BDD cfg r1)
                   (bool_fun_of_BDD cfg r2))
                (bool_fun_or (bool_fun_of_BDD cfg l1)
                   (bool_fun_of_BDD cfg l2))).
  apply bool_fun_if_preserves_eq.  apply
   bool_fun_eq_trans
    with
      (bf2 := bool_fun_or (bool_fun_of_BDD cfgl r1) (bool_fun_of_BDD cfgl r2)).
  assumption.  apply bool_fun_or_preserves_eq.
  apply used_nodes_preserved'_bool_fun with (ul := ul).  assumption.  assumption.
  assumption.  assumption.  assumption.
  apply used_nodes_preserved'_bool_fun with (ul := ul).  assumption.  assumption.
  assumption.  assumption.  assumption.
  apply bool_fun_eq_trans with (bf2 := bool_fun_of_BDD cfgl nodel).
  apply used_nodes_preserved'_bool_fun with (ul := nodel :: ul).  assumption.
  assumption.  assumption.  assumption.  apply used_node'_cons_node_ul.
  assumption.  apply bool_fun_eq_sym.
  apply
   bool_fun_eq_trans
    with
      (bf2 := bool_fun_or
                (bool_fun_if x1 (bool_fun_of_BDD cfg r1)
                   (bool_fun_of_BDD cfg l1))
                (bool_fun_if x1 (bool_fun_of_BDD cfg r2)
                   (bool_fun_of_BDD cfg l2))).
  apply bool_fun_or_preserves_eq.  apply bool_fun_of_BDD_int.  assumption.
  assumption.  apply bool_fun_of_BDD_int.  assumption.
  rewrite (BDD_EGAL_complete _ _ y0).  assumption.
  apply bool_fun_or_orthogonal.  apply nodes_preserved_node_height_eq.  assumption.
  assumption.  assumption.  assumption.  apply BDDorm_put_OK.  assumption.
  assumption.  assumption.  assumption.  
  rewrite (Neqb_complete (node_height cfg' node1) (node_height cfg node1)).
  rewrite (Neqb_complete (node_height cfg' node2) (node_height cfg node2)).
  unfold node_height at 2 3 in |- *.  unfold bs_node_height in |- *.  rewrite H5.  rewrite H6.
  apply Nleb_trans with (b := ad_S x1).  assumption.
  rewrite (BDD_EGAL_complete _ _ y0).  apply BDDvar_le_max_1.  
  apply used_nodes_preserved'_node_height_eq with (ul := ul).  assumption.  assumption.
  apply used_nodes_preserved_trans with (cfg2 := cfgl).  assumption.  assumption.
  apply used_nodes_preserved_trans with (cfg2 := cfgr).  assumption.
  apply used_nodes_preserved_cons with (node := nodel).  assumption.
  apply used_nodes_preserved_cons with (node := nodel).
  apply used_nodes_preserved_cons with (node := noder).  assumption.  assumption.
  assumption.  apply used_nodes_preserved'_node_height_eq with (ul := ul).  assumption.
  assumption.  apply used_nodes_preserved_trans with (cfg2 := cfgl).  assumption.
  assumption.  apply used_nodes_preserved_trans with (cfg2 := cfgr).  assumption.
  apply used_nodes_preserved_cons with (node := nodel).  assumption.  
  apply used_nodes_preserved_cons with (node := nodel).
  apply used_nodes_preserved_cons with (node := noder).  assumption.  assumption.
  assumption.  apply
   bool_fun_eq_trans
    with
      (bf2 := bool_fun_if x1 (bool_fun_of_BDD cfgr noder)
                (bool_fun_of_BDD cfgr nodel)).
  assumption.  apply
   bool_fun_eq_trans
    with
      (bf2 := bool_fun_if x1
                (bool_fun_or (bool_fun_of_BDD cfg r1)
                   (bool_fun_of_BDD cfg r2))
                (bool_fun_or (bool_fun_of_BDD cfg l1)
                   (bool_fun_of_BDD cfg l2))).
  apply bool_fun_if_preserves_eq.
  apply
   bool_fun_eq_trans
    with
      (bf2 := bool_fun_or (bool_fun_of_BDD cfgl r1) (bool_fun_of_BDD cfgl r2)).
  assumption.  apply bool_fun_or_preserves_eq.
  apply used_nodes_preserved'_bool_fun with (ul := ul).  assumption.  assumption.
  assumption.  assumption.  assumption.  
  apply used_nodes_preserved'_bool_fun with (ul := ul).  assumption.  assumption.  
  assumption.  assumption.  assumption.  
  apply bool_fun_eq_trans with (bf2 := bool_fun_of_BDD cfgl nodel).
  apply used_nodes_preserved'_bool_fun with (ul := nodel :: ul).  assumption.
  assumption.  assumption.  assumption.  apply used_node'_cons_node_ul.  
  assumption.  apply bool_fun_eq_sym.
  apply
   bool_fun_eq_trans
    with
      (bf2 := bool_fun_or
                (bool_fun_if x1 (bool_fun_of_BDD cfg r1)
                   (bool_fun_of_BDD cfg l1))
                (bool_fun_if x1 (bool_fun_of_BDD cfg r2)
                   (bool_fun_of_BDD cfg l2))).
  apply bool_fun_or_preserves_eq.
  apply bool_fun_eq_trans with (bf2 := bool_fun_of_BDD cfg node1).
  apply used_nodes_preserved'_bool_fun with (ul := ul).  assumption.  assumption.
  apply used_nodes_preserved_trans with (cfg2 := cfgl).  assumption.  assumption.
  apply used_nodes_preserved_trans with (cfg2 := cfgr).  assumption.  
  apply used_nodes_preserved_cons with (node := nodel).  assumption.
  apply used_nodes_preserved_cons with (node := nodel).
  apply used_nodes_preserved_cons with (node := noder).  assumption.  assumption.
  assumption.  apply bool_fun_of_BDD_int.  assumption.  assumption.  
  apply bool_fun_eq_trans with (bf2 := bool_fun_of_BDD cfg node2).
  apply used_nodes_preserved'_bool_fun with (ul := ul).  assumption.  assumption.
  apply used_nodes_preserved_trans with (cfg2 := cfgl).  assumption.  assumption.
  apply used_nodes_preserved_trans with (cfg2 := cfgr).  assumption.  
  apply used_nodes_preserved_cons with (node := nodel).  assumption.  
  apply used_nodes_preserved_cons with (node := nodel).
  apply used_nodes_preserved_cons with (node := noder).  assumption.  assumption.
  assumption.  apply bool_fun_of_BDD_int.  assumption.
  rewrite (BDD_EGAL_complete _ _ y0).  assumption.
  apply bool_fun_or_orthogonal.  apply BDDorm_put_nodes_preserved.  
  apply used_nodes_preserved_node_OK' with (ul := ul) (cfg := cfg).  assumption.
  assumption.  assumption.  apply used_nodes_preserved_trans with (cfg2 := cfgl).
  assumption.  assumption.  apply used_nodes_preserved_trans with (cfg2 := cfgr).
  assumption.  apply used_nodes_preserved_cons with (node := nodel).  assumption.
  apply used_nodes_preserved_cons with (node := nodel).
  apply used_nodes_preserved_cons with (node := noder).  assumption.
  apply used_nodes_preserved_node_OK' with (ul := ul) (cfg := cfg).  assumption.  
  assumption.  assumption.  apply used_nodes_preserved_trans with (cfg2 := cfgl).
  assumption.  assumption.  apply used_nodes_preserved_trans with (cfg2 := cfgr).
  assumption.  apply used_nodes_preserved_cons with (node := nodel).  assumption.
  apply used_nodes_preserved_cons with (node := nodel).
  apply used_nodes_preserved_cons with (node := noder).  assumption.
  replace cfg' with
   (fst (BDDmake gc cfgr x1 nodel noder (noder :: nodel :: ul))).
  replace node' with
   (snd (BDDmake gc cfgr x1 nodel noder (noder :: nodel :: ul))).
  apply BDDmake_node_height_le.  assumption.  assumption.  rewrite H9.  reflexivity.
  rewrite H9.  reflexivity.
  replace node' with
   (snd (BDDmake gc cfgr x1 nodel noder (noder :: nodel :: ul))).
  replace cfg' with
   (fst (BDDmake gc cfgr x1 nodel noder (noder :: nodel :: ul))).
  apply BDDmake_bool_fun.  assumption.  assumption.  assumption.  assumption.
  assumption.  assumption.  assumption.  rewrite H9.  reflexivity.  rewrite H9.
  reflexivity.  replace cfg' with
   (fst (BDDmake gc cfgr x1 nodel noder (noder :: nodel :: ul))).
  replace node' with
   (snd (BDDmake gc cfgr x1 nodel noder (noder :: nodel :: ul))).
  apply BDDmake_node_OK.  assumption.  assumption.  assumption.  assumption.
  assumption.  assumption.  assumption.  rewrite H9.  reflexivity.  rewrite H9.
  reflexivity.  replace cfg' with
   (fst (BDDmake gc cfgr x1 nodel noder (noder :: nodel :: ul))).
  apply BDDmake_preserves_used_nodes.  assumption.  assumption.  assumption.
  rewrite H9.  reflexivity.
  replace cfg' with
   (fst (BDDmake gc cfgr x1 nodel noder (noder :: nodel :: ul))).
  apply BDDmake_keeps_config_OK.  assumption.  assumption.  assumption.
  assumption.  assumption.  assumption.  assumption.  rewrite H9.  reflexivity.
  intros.  rewrite (ad_S_compare xr x1).
  replace (ad_S xr) with (node_height cfgr noder).
  replace (ad_S x1) with (node_height cfg node1).  apply BDDlt_compare.
  apply
   le_lt_trans
    with
      (m := nat_of_N
              (BDDvar_max (node_height cfgl r1) (node_height cfgl r2))).
  apply leb_complete.  assumption.  
  rewrite (Neqb_complete (node_height cfgl r1) (node_height cfg r1)).
  rewrite (Neqb_complete (node_height cfgl r2) (node_height cfg r2)).
  rewrite (BDDvar_max_max (node_height cfg r1) (node_height cfg r2)).
  rewrite <- (max_x_x_eq_x (nat_of_N (node_height cfg node1))).  apply lt_max_1.
  apply BDDcompare_lt.  unfold node_height in |- *.  apply bs_node_height_right with (x := x1) (l := l1).
  exact (proj1 H1).  assumption.  apply BDDcompare_lt.
  replace (node_height cfg node1) with (node_height cfg node2).  unfold node_height in |- *.
  apply bs_node_height_right with (x := x2) (l := l2).  exact (proj1 H1).
  assumption.  unfold node_height in |- *.  unfold bs_node_height in |- *.  rewrite H5.  rewrite H6.
  rewrite (BDD_EGAL_complete _ _ y0).  reflexivity.  
  apply used_nodes_preserved'_node_height_eq with (ul := ul).  assumption.  assumption.
  assumption.  assumption.  assumption.
  apply used_nodes_preserved'_node_height_eq with (ul := ul).  assumption.  assumption.
  assumption.  assumption.  assumption.  unfold node_height in |- *.  unfold bs_node_height in |- *.
  rewrite H5.  reflexivity.  unfold node_height in |- *.  unfold bs_node_height in |- *.  rewrite H34.
  reflexivity.  intros.  rewrite (ad_S_compare xl x1).
  replace (ad_S xl) with (node_height cfgr nodel).
  replace (ad_S x1) with (node_height cfg node1).
  rewrite (Neqb_complete (node_height cfgr nodel) (node_height cfgl nodel)).
  apply BDDlt_compare.
  apply
   le_lt_trans
    with
      (m := nat_of_N (BDDvar_max (node_height cfg l1) (node_height cfg l2))).
  apply leb_complete.  assumption.
  rewrite (BDDvar_max_max (node_height cfg l1) (node_height cfg l2)).
  rewrite <- (max_x_x_eq_x (nat_of_N (node_height cfg node1))).  apply lt_max_1.
  apply BDDcompare_lt.  unfold node_height in |- *.  apply bs_node_height_left with (x := x1) (r := r1).
  exact (proj1 H1).  assumption.  apply BDDcompare_lt.
  replace (node_height cfg node1) with (node_height cfg node2).  unfold node_height in |- *.
  apply bs_node_height_left with (x := x2) (r := r2).  exact (proj1 H1).  assumption.
  unfold node_height in |- *.  unfold bs_node_height in |- *.  rewrite H5.  rewrite H6.
  rewrite (BDD_EGAL_complete _ _ y0).  reflexivity.  
  apply used_nodes_preserved'_node_height_eq with (ul := nodel :: ul).  assumption.
  assumption.  assumption.  assumption.  apply used_node'_cons_node_ul.
  unfold node_height in |- *.  unfold bs_node_height in |- *.  rewrite H5.  reflexivity.  unfold node_height in |- *.
  unfold bs_node_height in |- *.  rewrite H34.  reflexivity.  apply used_node'_cons_node_ul.
  apply used_node'_cons_node'_ul.  apply used_node'_cons_node_ul.
  apply node_OK_list_OK.  assumption.  assumption.
  apply used_nodes_preserved_list_OK with (cfg := cfgl).  assumption.  assumption.
  replace cfgr with (fst (BDDor_1 cfgl (nodel :: ul) r1 r2 n)).
  replace noder with (snd (BDDor_1 cfgl (nodel :: ul) r1 r2 n)).  apply H.
  apply
   lt_trans_1
    with
      (y := max (nat_of_N (node_height cfg node1))
              (nat_of_N (node_height cfg node2))).
  apply lt_max_1.  rewrite (Neqb_complete (node_height cfgl r1) (node_height cfg r1)).
  unfold node_height in |- *.  apply BDDcompare_lt.  apply bs_node_height_right with (x := x1) (l := l1).
  exact (proj1 H1).  assumption.
  apply used_nodes_preserved'_node_height_eq with (ul := ul).  assumption.  assumption.
  assumption.  assumption.  assumption.
  rewrite (Neqb_complete (node_height cfgl r2) (node_height cfg r2)).
  replace (node_height cfg node1) with (node_height cfg node2).  apply BDDcompare_lt.
  unfold node_height in |- *.  apply bs_node_height_right with (x := x2) (l := l2).  exact (proj1 H1).
  assumption.  unfold node_height in |- *.  unfold bs_node_height in |- *.  rewrite H5.  rewrite H6.
  rewrite (BDD_EGAL_complete _ _ y0).  reflexivity.
  apply used_nodes_preserved'_node_height_eq with (ul := ul).  assumption.  assumption.
  assumption.  assumption.  assumption.  assumption.  assumption.  assumption.
  assumption.  assumption.  rewrite H8.  reflexivity.  rewrite H8.  reflexivity.
  apply used_node'_cons_node'_ul.  assumption.  apply used_node'_cons_node'_ul.
  assumption.  apply used_nodes_preserved_used_node' with (cfg := cfg).  assumption.
  assumption.  apply high_used' with (node := node2) (x := x2) (l := l2).  assumption.
  assumption.  assumption.  apply used_nodes_preserved_used_node' with (cfg := cfg).
  assumption.  assumption.  apply high_used' with (node := node1) (x := x1) (l := l1).
  assumption.  assumption.  assumption.  apply node_OK_list_OK.  assumption.
  assumption.  apply used_nodes_preserved_list_OK with (cfg := cfg).  assumption.
  assumption.  replace cfgl with (fst (BDDor_1 cfg ul l1 l2 n)).
  replace nodel with (snd (BDDor_1 cfg ul l1 l2 n)).  apply H.
  apply
   lt_trans_1
    with
      (y := max (nat_of_N (node_height cfg node1))
              (nat_of_N (node_height cfg node2))).
  apply lt_max_1.  unfold node_height in |- *.  apply BDDcompare_lt.
  apply bs_node_height_left with (x := x1) (r := r1).  exact (proj1 H1).  assumption.
  replace (node_height cfg node1) with (node_height cfg node2).  apply BDDcompare_lt.
  unfold node_height in |- *.  apply bs_node_height_left with (x := x2) (r := r2).  exact (proj1 H1).
  assumption.  unfold node_height in |- *.  unfold bs_node_height in |- *.  rewrite H5.  rewrite H6.
  rewrite (BDD_EGAL_complete _ _ y0).  reflexivity.  assumption.  assumption.
  assumption.  assumption.  assumption.  rewrite H7.  reflexivity.  rewrite H7.
  reflexivity.  apply high_used' with (node := node2) (x := x2) (l := l2).  assumption.
  assumption.  assumption.  apply low_used' with (node := node2) (x := x2) (r := r2).
  assumption.  assumption.  assumption.
  apply high_used' with (node := node1) (x := x1) (l := l1).  assumption.  assumption.
  assumption.  apply low_used' with (node := node1) (x := x1) (r := r1).  assumption.
  assumption.  assumption.  rewrite y0.
  elim (prod_sum _ _ (BDDor_1 cfg ul node1 l2 n)).  intros cfgl H7.
  elim H7; clear H7.  intros nodel H7.  rewrite H7.
  elim (prod_sum _ _ (BDDor_1 cfgl (nodel :: ul) node1 r2 n)).
  intros cfgr H8.  elim H8; clear H8.  intros noder H8.  rewrite H8.
  elim (prod_sum _ _ (BDDmake gc cfgr x2 nodel noder (noder :: nodel :: ul))).
  intros cfg' H9.  elim H9; clear H9.  intros node' H9.  rewrite H9.  simpl in |- *.
  cut (used_node' cfg ul l2).  cut (used_node' cfg ul r2).  intros.  
  cut
   (BDDconfig_OK cfgl /\
    config_node_OK cfgl nodel /\
    used_nodes_preserved cfg cfgl ul /\
    Nleb (node_height cfgl nodel)
      (BDDvar_max (node_height cfg node1) (node_height cfg l2)) = true /\
    bool_fun_eq (bool_fun_of_BDD cfgl nodel)
      (bool_fun_or (bool_fun_of_BDD cfg node1) (bool_fun_of_BDD cfg l2))).
  intro.  elim H12; clear H12; intros.  elim H13; clear H13; intros.
  elim H14; clear H14; intros.  elim H15; clear H15; intros.
  cut (used_list_OK cfgl ul).  intro.
  cut (used_list_OK cfgl (nodel :: ul)).  intro.
  cut (used_node' cfgl ul node1).  cut (used_node' cfgl ul r2).  intros.
  cut (used_node' cfgl (nodel :: ul) node1).
  cut (used_node' cfgl (nodel :: ul) r2).  intros.
  cut
   (BDDconfig_OK cfgr /\
    config_node_OK cfgr noder /\
    used_nodes_preserved cfgl cfgr (nodel :: ul) /\
    Nleb (node_height cfgr noder)
      (BDDvar_max (node_height cfgl node1) (node_height cfgl r2)) = true /\
    bool_fun_eq (bool_fun_of_BDD cfgr noder)
      (bool_fun_or (bool_fun_of_BDD cfgl node1) (bool_fun_of_BDD cfgl r2))).

  intro.  elim H23; clear H23; intros.  elim H24; clear H24; intros.
  elim H25; clear H25; intros.  elim H26; clear H26; intros.
  cut (used_list_OK cfgr (nodel :: ul)).  intro.
  cut (used_list_OK cfgr (noder :: nodel :: ul)).  intro.
  cut (used_node' cfgr (noder :: nodel :: ul) nodel).
  cut (used_node' cfgr (noder :: nodel :: ul) noder).  intros.
  cut
   (forall (xl : BDDvar) (ll rl : ad),
    MapGet _ (fst cfgr) nodel = Some (xl, (ll, rl)) ->
    BDDcompare xl x2 = Datatypes.Lt).
  cut
   (forall (xr : BDDvar) (lr rr : ad),
    MapGet _ (fst cfgr) noder = Some (xr, (lr, rr)) ->
    BDDcompare xr x2 = Datatypes.Lt).
  intros.  cut (BDDconfig_OK cfg').
  cut (used_nodes_preserved cfgr cfg' (noder :: nodel :: ul)).
  cut (config_node_OK cfg' node').
  cut
   (bool_fun_eq (bool_fun_of_BDD cfg' node')
      (bool_fun_if x2 (bool_fun_of_BDD cfgr noder)
         (bool_fun_of_BDD cfgr nodel))).
  cut (Nleb (node_height cfg' node') (ad_S x2) = true).  intros.
  cut (config_node_OK cfg' node1).  cut (config_node_OK cfg' node2).  intros.
  cut (nodes_preserved cfg' (BDDor_memo_put cfg' node1 node2 node')).  intro.
  cut (BDDconfig_OK (BDDor_memo_put cfg' node1 node2 node')).  intro.  split.
  assumption.  split.  apply nodes_preserved_config_node_OK with (cfg1 := cfg').
  assumption.  assumption.  split.
  apply used_nodes_preserved_trans with (cfg2 := cfgr).  assumption.  
  apply used_nodes_preserved_trans with (cfg2 := cfgl).  assumption.  assumption.
  apply used_nodes_preserved_cons with (node := nodel).  assumption.
  apply used_nodes_preserved_trans with (cfg2 := cfg').  assumption.
  apply used_nodes_preserved_cons with (node := nodel).
  apply used_nodes_preserved_cons with (node := noder).  assumption.  
  apply nodes_preserved_used_nodes_preserved.  assumption.  
  rewrite
   (Neqb_complete
      (node_height (BDDor_memo_put cfg' node1 node2 node') node')
      (node_height cfg' node')).
  split.  unfold node_height at 2 3 in |- *.  unfold bs_node_height in |- *.  rewrite H5.  rewrite H6.
  rewrite (BDDvar_max_inf (ad_S x1) (ad_S x2)).  assumption.  
  rewrite <- (ad_S_compare x1 x2).  assumption.
  apply bool_fun_eq_trans with (bf2 := bool_fun_of_BDD cfg' node').
  apply nodes_preserved_bool_fun.  assumption.  assumption.  assumption.
  assumption.  apply
   bool_fun_eq_trans
    with
      (bf2 := bool_fun_if x2 (bool_fun_of_BDD cfgr noder)
                (bool_fun_of_BDD cfgr nodel)).
  assumption.  apply
   bool_fun_eq_trans
    with
      (bf2 := bool_fun_if x2
                (bool_fun_or (bool_fun_of_BDD cfg node1)
                   (bool_fun_of_BDD cfg r2))
                (bool_fun_or (bool_fun_of_BDD cfg node1)
                   (bool_fun_of_BDD cfg l2))).
  apply bool_fun_if_preserves_eq.  apply
   bool_fun_eq_trans
    with
      (bf2 := bool_fun_or (bool_fun_of_BDD cfgl node1)
                (bool_fun_of_BDD cfgl r2)).
  assumption.  apply bool_fun_or_preserves_eq.
  apply used_nodes_preserved'_bool_fun with (ul := ul).  assumption.  assumption.
  assumption.  assumption.  assumption.
  apply used_nodes_preserved'_bool_fun with (ul := ul).  assumption.  assumption.
  assumption.  assumption.  assumption.  
  apply bool_fun_eq_trans with (bf2 := bool_fun_of_BDD cfgl nodel).
  apply used_nodes_preserved'_bool_fun with (ul := nodel :: ul).  assumption.
  assumption.  assumption.  assumption.  apply used_node'_cons_node_ul.  
  assumption.  apply bool_fun_eq_sym.
  apply
   bool_fun_eq_trans
    with
      (bf2 := bool_fun_or (bool_fun_of_BDD cfg node1)
                (bool_fun_if x2 (bool_fun_of_BDD cfg r2)
                   (bool_fun_of_BDD cfg l2))).
  apply bool_fun_or_preserves_eq.  apply bool_fun_eq_refl.
  apply bool_fun_of_BDD_int.  assumption.  assumption.
  apply bool_fun_or_orthogonal_right.  apply nodes_preserved_node_height_eq.
  assumption.  assumption.  assumption.  assumption.  apply BDDorm_put_OK.
  assumption.  assumption.  assumption.  assumption.  
  rewrite (Neqb_complete (node_height cfg' node1) (node_height cfg node1)).
  rewrite (Neqb_complete (node_height cfg' node2) (node_height cfg node2)).
  unfold node_height at 2 3 in |- *.  unfold bs_node_height in |- *.  rewrite H5.  rewrite H6.
  rewrite (BDDvar_max_inf (ad_S x1) (ad_S x2)).  assumption.
  rewrite <- (ad_S_compare x1 x2).  assumption.
  apply used_nodes_preserved'_node_height_eq with (ul := ul).  assumption.  assumption.
  apply used_nodes_preserved_trans with (cfg2 := cfgl).  assumption.  assumption.
  apply used_nodes_preserved_trans with (cfg2 := cfgr).  assumption.  
  apply used_nodes_preserved_cons with (node := nodel).  assumption.
  apply used_nodes_preserved_cons with (node := nodel).
  apply used_nodes_preserved_cons with (node := noder).  assumption.  assumption.
  assumption.  apply used_nodes_preserved'_node_height_eq with (ul := ul).  assumption.
  assumption.  apply used_nodes_preserved_trans with (cfg2 := cfgl).  assumption.
  assumption.  apply used_nodes_preserved_trans with (cfg2 := cfgr).  assumption.
  apply used_nodes_preserved_cons with (node := nodel).  assumption.  
  apply used_nodes_preserved_cons with (node := nodel).
  apply used_nodes_preserved_cons with (node := noder).  assumption.  assumption.
  assumption.
  apply
   bool_fun_eq_trans
    with
      (bf2 := bool_fun_if x2 (bool_fun_of_BDD cfgr noder)
                (bool_fun_of_BDD cfgr nodel)).
  assumption.  apply
   bool_fun_eq_trans
    with
      (bf2 := bool_fun_if x2
                (bool_fun_or (bool_fun_of_BDD cfg node1)
                   (bool_fun_of_BDD cfg r2))
                (bool_fun_or (bool_fun_of_BDD cfg node1)
                   (bool_fun_of_BDD cfg l2))).
  apply bool_fun_if_preserves_eq.
  apply
   bool_fun_eq_trans
    with
      (bf2 := bool_fun_or (bool_fun_of_BDD cfgl node1)
                (bool_fun_of_BDD cfgl r2)).
  assumption.  apply bool_fun_or_preserves_eq.
  apply used_nodes_preserved'_bool_fun with (ul := ul).  assumption.
  assumption.  assumption.  assumption.  assumption.  
  apply used_nodes_preserved'_bool_fun with (ul := ul).  assumption.
  assumption.  assumption.  assumption.  assumption.
  apply bool_fun_eq_trans with (bf2 := bool_fun_of_BDD cfgl nodel).
  apply used_nodes_preserved'_bool_fun with (ul := nodel :: ul).  assumption.
  assumption.  assumption.  assumption.  apply used_node'_cons_node_ul.  
  assumption.  apply bool_fun_eq_sym.
  apply
   bool_fun_eq_trans
    with
      (bf2 := bool_fun_or (bool_fun_of_BDD cfg node1)
                (bool_fun_if x2 (bool_fun_of_BDD cfg r2)
                   (bool_fun_of_BDD cfg l2))).
  apply bool_fun_or_preserves_eq.
  apply used_nodes_preserved'_bool_fun with (ul := ul).  assumption.  assumption.
  apply used_nodes_preserved_trans with (cfg2 := cfgl).  assumption.  assumption.
  apply used_nodes_preserved_trans with (cfg2 := cfgr).  assumption.  
  apply used_nodes_preserved_cons with (node := nodel).  assumption.
  apply used_nodes_preserved_cons with (node := nodel).
  apply used_nodes_preserved_cons with (node := noder).  assumption.  assumption.
  assumption.  apply bool_fun_eq_trans with (bf2 := bool_fun_of_BDD cfg node2).
  apply used_nodes_preserved'_bool_fun with (ul := ul).  assumption.  assumption.
  apply used_nodes_preserved_trans with (cfg2 := cfgl).  assumption.  assumption.
  apply used_nodes_preserved_trans with (cfg2 := cfgr).  assumption.
  apply used_nodes_preserved_cons with (node := nodel).  assumption.  
  apply used_nodes_preserved_cons with (node := nodel).
  apply used_nodes_preserved_cons with (node := noder).  assumption.  assumption.
  assumption.  apply bool_fun_of_BDD_int.  assumption.  assumption.  
  apply bool_fun_or_orthogonal_right.  apply BDDorm_put_nodes_preserved.  
  apply used_nodes_preserved_node_OK' with (ul := ul) (cfg := cfg).  assumption.  
  assumption.  assumption.  apply used_nodes_preserved_trans with (cfg2 := cfgl).
  assumption.  assumption.  apply used_nodes_preserved_trans with (cfg2 := cfgr).
  assumption.  apply used_nodes_preserved_cons with (node := nodel).  assumption.
  apply used_nodes_preserved_cons with (node := nodel).
  apply used_nodes_preserved_cons with (node := noder).  assumption.  
  apply used_nodes_preserved_node_OK' with (ul := ul) (cfg := cfg).  assumption.  
  assumption.  assumption.  apply used_nodes_preserved_trans with (cfg2 := cfgl).
  assumption.  assumption.  apply used_nodes_preserved_trans with (cfg2 := cfgr).
  assumption.  apply used_nodes_preserved_cons with (node := nodel).  assumption.
  apply used_nodes_preserved_cons with (node := nodel).
  apply used_nodes_preserved_cons with (node := noder).  assumption.
  replace cfg' with
   (fst (BDDmake gc cfgr x2 nodel noder (noder :: nodel :: ul))).
  replace node' with
   (snd (BDDmake gc cfgr x2 nodel noder (noder :: nodel :: ul))).
  apply BDDmake_node_height_le.  assumption.  assumption.  rewrite H9.  reflexivity.
  rewrite H9.  reflexivity.  replace node' with
   (snd (BDDmake gc cfgr x2 nodel noder (noder :: nodel :: ul))).
  replace cfg' with
   (fst (BDDmake gc cfgr x2 nodel noder (noder :: nodel :: ul))).
  apply BDDmake_bool_fun.  assumption.  assumption.  assumption.  assumption.
  assumption.  assumption.  assumption.  rewrite H9.  reflexivity.  rewrite H9.
  reflexivity.  replace cfg' with
   (fst (BDDmake gc cfgr x2 nodel noder (noder :: nodel :: ul))).
  replace node' with
   (snd (BDDmake gc cfgr x2 nodel noder (noder :: nodel :: ul))).
  apply BDDmake_node_OK.  assumption.  assumption.  assumption.  assumption.
  assumption.  assumption.  assumption.  rewrite H9.  reflexivity.  rewrite H9.
  reflexivity.  replace cfg' with
   (fst (BDDmake gc cfgr x2 nodel noder (noder :: nodel :: ul))).
  apply BDDmake_preserves_used_nodes.  assumption.  assumption.  assumption.
  rewrite H9.  reflexivity.
  replace cfg' with
   (fst (BDDmake gc cfgr x2 nodel noder (noder :: nodel :: ul))).
  apply BDDmake_keeps_config_OK.  assumption.  assumption.  assumption.  
  assumption.  assumption.  assumption.  assumption.  rewrite H9.  reflexivity.
  intros.  rewrite (ad_S_compare xr x2).
  replace (ad_S xr) with (node_height cfgr noder).
  replace (ad_S x2) with (node_height cfg node2).  apply BDDlt_compare.
  apply
   le_lt_trans
    with
      (m := nat_of_N
              (BDDvar_max (node_height cfgl node1) (node_height cfgl r2))).
  apply leb_complete.  assumption.
  rewrite (Neqb_complete (node_height cfgl node1) (node_height cfg node1)).
  rewrite (Neqb_complete (node_height cfgl r2) (node_height cfg r2)).
  rewrite (BDDvar_max_max (node_height cfg node1) (node_height cfg r2)).
  rewrite <- (max_x_x_eq_x (nat_of_N (node_height cfg node2))).  apply lt_max_1.
  apply BDDcompare_lt.  unfold node_height in |- *.  unfold bs_node_height in |- *.  rewrite H5.  rewrite H6.
  rewrite <- (ad_S_compare x1 x2).  assumption.  apply BDDcompare_lt.
  unfold node_height in |- *.  apply bs_node_height_right with (x := x2) (l := l2).  exact (proj1 H1).  
  assumption.  apply used_nodes_preserved'_node_height_eq with (ul := ul).
  assumption.  assumption.  assumption.  assumption.  assumption.
  apply used_nodes_preserved'_node_height_eq with (ul := ul).  assumption.  assumption.
  assumption.  assumption.  assumption.  unfold node_height in |- *.  unfold bs_node_height in |- *.
  rewrite H6.  reflexivity.  unfold node_height in |- *.  unfold bs_node_height in |- *.  rewrite H32.
  reflexivity.  intros.  rewrite (ad_S_compare xl x2).
  replace (ad_S xl) with (node_height cfgr nodel).
  replace (ad_S x2) with (node_height cfg node2).
  rewrite (Neqb_complete (node_height cfgr nodel) (node_height cfgl nodel)).
  apply BDDlt_compare.
  apply
   le_lt_trans
    with
      (m := nat_of_N
              (BDDvar_max (node_height cfg node1) (node_height cfg l2))).
  apply leb_complete.  assumption.
  rewrite (BDDvar_max_max (node_height cfg node1) (node_height cfg l2)).
  rewrite <- (max_x_x_eq_x (nat_of_N (node_height cfg node2))).  apply lt_max_1.
  apply BDDcompare_lt.  unfold node_height in |- *.  unfold bs_node_height in |- *.  rewrite H5.  rewrite H6.
  rewrite <- (ad_S_compare x1 x2).  assumption.  apply BDDcompare_lt.
  unfold node_height in |- *.  apply bs_node_height_left with (x := x2) (r := r2).  exact (proj1 H1).
  assumption.  apply used_nodes_preserved'_node_height_eq with (ul := nodel :: ul).
  assumption.  assumption.  assumption.  assumption.
  apply used_node'_cons_node_ul.  unfold node_height in |- *.  unfold bs_node_height in |- *.  rewrite H6.
  reflexivity.  unfold node_height in |- *.  unfold bs_node_height in |- *.  rewrite H32.  reflexivity.
  apply used_node'_cons_node_ul.  apply used_node'_cons_node'_ul.
  apply used_node'_cons_node_ul.  apply node_OK_list_OK.  assumption.
  assumption.  apply used_nodes_preserved_list_OK with (cfg := cfgl).  assumption.
  assumption.  replace cfgr with (fst (BDDor_1 cfgl (nodel :: ul) node1 r2 n)).
  replace noder with (snd (BDDor_1 cfgl (nodel :: ul) node1 r2 n)).  apply H.
  apply
   lt_trans_1
    with
      (y := max (nat_of_N (node_height cfg node1))
              (nat_of_N (node_height cfg node2))).
  rewrite <- (BDDvar_max_max (node_height cfg node1) (node_height cfg node2)).
  rewrite (BDDvar_max_inf (node_height cfg node1) (node_height cfg node2)).
  rewrite <- (max_x_x_eq_x (nat_of_N (node_height cfg node2))).  apply lt_max_1.
  rewrite (Neqb_complete (node_height cfgl node1) (node_height cfg node1)).  unfold node_height in |- *.
  apply BDDcompare_lt.  unfold bs_node_height in |- *.  rewrite H5.  rewrite H6.
  rewrite <- (ad_S_compare x1 x2).  assumption.
  apply used_nodes_preserved'_node_height_eq with (ul := ul).  assumption.  assumption.
  assumption.  assumption.  assumption.
  rewrite (Neqb_complete (node_height cfgl r2) (node_height cfg r2)).  apply BDDcompare_lt.
  unfold node_height in |- *.  apply bs_node_height_right with (x := x2) (l := l2).  exact (proj1 H1).
  assumption.  apply used_nodes_preserved'_node_height_eq with (ul := ul).  assumption.
  assumption.  assumption.  assumption.  assumption.  unfold node_height in |- *.
  unfold bs_node_height in |- *.  rewrite H5.  rewrite H6.  rewrite <- (ad_S_compare x1 x2).
  assumption.  assumption.  assumption.  assumption.  assumption.  assumption.
  rewrite H8.  reflexivity.  rewrite H8.  reflexivity.
  apply used_node'_cons_node'_ul.  assumption.  apply used_node'_cons_node'_ul.
  assumption.  apply used_nodes_preserved_used_node' with (cfg := cfg).  assumption.
  assumption.  assumption.  apply used_nodes_preserved_used_node' with (cfg := cfg).
  assumption.  assumption.  assumption.  apply node_OK_list_OK.  assumption.
  assumption.  apply used_nodes_preserved_list_OK with (cfg := cfg).  assumption.
  assumption.  replace cfgl with (fst (BDDor_1 cfg ul node1 l2 n)).
  replace nodel with (snd (BDDor_1 cfg ul node1 l2 n)).  apply H.
  apply
   lt_trans_1
    with
      (y := max (nat_of_N (node_height cfg node1))
              (nat_of_N (node_height cfg node2))).
  rewrite <- (BDDvar_max_max (node_height cfg node1) (node_height cfg node2)).
  rewrite (BDDvar_max_inf (node_height cfg node1) (node_height cfg node2)).
  rewrite <- (max_x_x_eq_x (nat_of_N (node_height cfg node2))).  apply lt_max_1.
  unfold node_height in |- *.  apply BDDcompare_lt.  unfold bs_node_height in |- *.  rewrite H5.  rewrite H6.
  rewrite <- (ad_S_compare x1 x2).  assumption.  apply BDDcompare_lt.
  unfold node_height in |- *.  apply bs_node_height_left with (x := x2) (r := r2).  exact (proj1 H1).
  assumption.  unfold node_height in |- *.  unfold bs_node_height in |- *.  rewrite H5.  rewrite H6.
  rewrite <- (ad_S_compare x1 x2).  assumption.  assumption.  assumption.
  assumption.  assumption.  assumption.  rewrite H7.  reflexivity.  rewrite H7.
  reflexivity.  apply high_used' with (node := node2) (x := x2) (l := l2).  assumption.
  assumption.  assumption.  apply low_used' with (node := node2) (x := x2) (r := r2).
  assumption.  assumption.  assumption.  intro y0.  rewrite y0.
  cut (BDDcompare x2 x1 = Datatypes.Lt).  intro y00.
  elim (prod_sum _ _ (BDDor_1 cfg ul l1 node2 n)).  intros cfgl H7.
  elim H7; clear H7.  intros nodel H7.  rewrite H7.
  elim (prod_sum _ _ (BDDor_1 cfgl (nodel :: ul) r1 node2 n)).
  intros cfgr H8.  elim H8; clear H8.  intros noder H8.  rewrite H8.
  elim (prod_sum _ _ (BDDmake gc cfgr x1 nodel noder (noder :: nodel :: ul))).
  intros cfg' H9.  elim H9; clear H9.  intros node' H9.  rewrite H9.
  simpl in |- *.  cut (used_node' cfg ul l1).  cut (used_node' cfg ul r1).  intros.
  cut
   (BDDconfig_OK cfgl /\
    config_node_OK cfgl nodel /\
    used_nodes_preserved cfg cfgl ul /\
    Nleb (node_height cfgl nodel)
      (BDDvar_max (node_height cfg l1) (node_height cfg node2)) = true /\
    bool_fun_eq (bool_fun_of_BDD cfgl nodel)
      (bool_fun_or (bool_fun_of_BDD cfg l1) (bool_fun_of_BDD cfg node2))).
  intro.  elim H12; clear H12; intros.  elim H13; clear H13; intros.
  elim H14; clear H14; intros.  elim H15; clear H15; intros.
  cut (used_list_OK cfgl ul).  intro.  cut (used_list_OK cfgl (nodel :: ul)).
  intro.  cut (used_node' cfgl ul node2).  cut (used_node' cfgl ul r1).  intros.
  cut (used_node' cfgl (nodel :: ul) node2).
  cut (used_node' cfgl (nodel :: ul) r1).  intros.
  cut
   (BDDconfig_OK cfgr /\
    config_node_OK cfgr noder /\
    used_nodes_preserved cfgl cfgr (nodel :: ul) /\
    Nleb (node_height cfgr noder)
      (BDDvar_max (node_height cfgl r1) (node_height cfgl node2)) = true /\
    bool_fun_eq (bool_fun_of_BDD cfgr noder)
      (bool_fun_or (bool_fun_of_BDD cfgl r1) (bool_fun_of_BDD cfgl node2))).

  intro.  elim H23; clear H23; intros.  elim H24; clear H24; intros.
  elim H25; clear H25; intros.  elim H26; clear H26; intros.
  cut (used_list_OK cfgr (nodel :: ul)).  intro.
  cut (used_list_OK cfgr (noder :: nodel :: ul)).  intro.
  cut (used_node' cfgr (noder :: nodel :: ul) nodel).
  cut (used_node' cfgr (noder :: nodel :: ul) noder).  intros.
  cut
   (forall (xl : BDDvar) (ll rl : ad),
    MapGet _ (fst cfgr) nodel = Some (xl, (ll, rl)) ->
    BDDcompare xl x1 = Datatypes.Lt).
  cut
   (forall (xr : BDDvar) (lr rr : ad),
    MapGet _ (fst cfgr) noder = Some (xr, (lr, rr)) ->
    BDDcompare xr x1 = Datatypes.Lt).
  intros.  cut (BDDconfig_OK cfg').
  cut (used_nodes_preserved cfgr cfg' (noder :: nodel :: ul)).
  cut (config_node_OK cfg' node').
  cut
   (bool_fun_eq (bool_fun_of_BDD cfg' node')
      (bool_fun_if x1 (bool_fun_of_BDD cfgr noder)
         (bool_fun_of_BDD cfgr nodel))).
  cut (Nleb (node_height cfg' node') (ad_S x1) = true).  intros.
  cut (config_node_OK cfg' node1).  cut (config_node_OK cfg' node2).  intros.
  cut (nodes_preserved cfg' (BDDor_memo_put cfg' node1 node2 node')).  intro.
  cut (BDDconfig_OK (BDDor_memo_put cfg' node1 node2 node')).  intro.  split.
  assumption.  split.  apply nodes_preserved_config_node_OK with (cfg1 := cfg').
  assumption.  assumption.  split.
  apply used_nodes_preserved_trans with (cfg2 := cfgr).  assumption.  
  apply used_nodes_preserved_trans with (cfg2 := cfgl).  assumption.  assumption.
  apply used_nodes_preserved_cons with (node := nodel).  assumption.
  apply used_nodes_preserved_trans with (cfg2 := cfg').  assumption.
  apply used_nodes_preserved_cons with (node := nodel).
  apply used_nodes_preserved_cons with (node := noder).  assumption.  
  apply nodes_preserved_used_nodes_preserved.  assumption.  
  rewrite
   (Neqb_complete
      (node_height (BDDor_memo_put cfg' node1 node2 node') node')
      (node_height cfg' node')).
  split.  unfold node_height at 2 3 in |- *.  unfold bs_node_height in |- *.  rewrite H5.  rewrite H6.
  rewrite (BDDvar_max_comm (ad_S x1) (ad_S x2)).
  rewrite (BDDvar_max_inf (ad_S x2) (ad_S x1)).  assumption.
  rewrite <- (ad_S_compare x2 x1).  assumption.
  apply bool_fun_eq_trans with (bf2 := bool_fun_of_BDD cfg' node').
  apply nodes_preserved_bool_fun.  assumption.  assumption.  assumption.  
  assumption.
  apply
   bool_fun_eq_trans
    with
      (bf2 := bool_fun_if x1 (bool_fun_of_BDD cfgr noder)
                (bool_fun_of_BDD cfgr nodel)).
  assumption.  apply
   bool_fun_eq_trans
    with
      (bf2 := bool_fun_if x1
                (bool_fun_or (bool_fun_of_BDD cfg r1)
                   (bool_fun_of_BDD cfg node2))
                (bool_fun_or (bool_fun_of_BDD cfg l1)
                   (bool_fun_of_BDD cfg node2))).
  apply bool_fun_if_preserves_eq.
  apply
   bool_fun_eq_trans
    with
      (bf2 := bool_fun_or (bool_fun_of_BDD cfgl r1)
                (bool_fun_of_BDD cfgl node2)).
  assumption.  apply bool_fun_or_preserves_eq.
  apply used_nodes_preserved'_bool_fun with (ul := ul).  assumption.  assumption.
  assumption.  assumption.  assumption.
  apply used_nodes_preserved'_bool_fun with (ul := ul).  assumption.  assumption.
  assumption.  assumption.  assumption.
  apply bool_fun_eq_trans with (bf2 := bool_fun_of_BDD cfgl nodel).
  apply used_nodes_preserved'_bool_fun with (ul := nodel :: ul).  assumption.  
  assumption.  assumption.  assumption.  apply used_node'_cons_node_ul.  
  assumption.  apply bool_fun_eq_sym.
  apply
   bool_fun_eq_trans
    with
      (bf2 := bool_fun_or
                (bool_fun_if x1 (bool_fun_of_BDD cfg r1)
                   (bool_fun_of_BDD cfg l1)) (bool_fun_of_BDD cfg node2)).
  apply bool_fun_or_preserves_eq.  apply bool_fun_of_BDD_int.  assumption.  
  assumption.  apply bool_fun_eq_refl.  apply bool_fun_or_orthogonal_left.  
  apply nodes_preserved_node_height_eq.  assumption.  assumption.  assumption.
  assumption.  apply BDDorm_put_OK.  assumption.  assumption.  assumption.
  assumption.  rewrite (Neqb_complete (node_height cfg' node1) (node_height cfg node1)).
  rewrite (Neqb_complete (node_height cfg' node2) (node_height cfg node2)).  unfold node_height at 2 3 in |- *.
  unfold bs_node_height in |- *.  rewrite H5.  rewrite H6.
  rewrite (BDDvar_max_comm (ad_S x1) (ad_S x2)).
  rewrite (BDDvar_max_inf (ad_S x2) (ad_S x1)).  assumption.
  rewrite <- (ad_S_compare x2 x1).  assumption.  
  apply used_nodes_preserved'_node_height_eq with (ul := ul).  assumption.  assumption.
  apply used_nodes_preserved_trans with (cfg2 := cfgl).  assumption.  assumption.
  apply used_nodes_preserved_trans with (cfg2 := cfgr).  assumption.  
  apply used_nodes_preserved_cons with (node := nodel).  assumption.  
  apply used_nodes_preserved_cons with (node := nodel).
  apply used_nodes_preserved_cons with (node := noder).  assumption.  assumption.
  assumption.  apply used_nodes_preserved'_node_height_eq with (ul := ul).  assumption.
  assumption.  apply used_nodes_preserved_trans with (cfg2 := cfgl).  assumption.
  assumption.  apply used_nodes_preserved_trans with (cfg2 := cfgr).  assumption.
  apply used_nodes_preserved_cons with (node := nodel).  assumption.  
  apply used_nodes_preserved_cons with (node := nodel).
  apply used_nodes_preserved_cons with (node := noder).  assumption.  assumption.
  assumption.  
  apply
   bool_fun_eq_trans
    with
      (bf2 := bool_fun_if x1 (bool_fun_of_BDD cfgr noder)
                (bool_fun_of_BDD cfgr nodel)).
  assumption.  apply
   bool_fun_eq_trans
    with
      (bf2 := bool_fun_if x1
                (bool_fun_or (bool_fun_of_BDD cfg r1)
                   (bool_fun_of_BDD cfg node2))
                (bool_fun_or (bool_fun_of_BDD cfg l1)
                   (bool_fun_of_BDD cfg node2))).
  apply bool_fun_if_preserves_eq.
  apply
   bool_fun_eq_trans
    with
      (bf2 := bool_fun_or (bool_fun_of_BDD cfgl r1)
                (bool_fun_of_BDD cfgl node2)).
  assumption.  apply bool_fun_or_preserves_eq.
  apply used_nodes_preserved'_bool_fun with (ul := ul).  assumption.  assumption.
  assumption.  assumption.  assumption.  
  apply used_nodes_preserved'_bool_fun with (ul := ul).  assumption.  assumption.
  assumption.  assumption.  assumption.  
  apply bool_fun_eq_trans with (bf2 := bool_fun_of_BDD cfgl nodel).
  apply used_nodes_preserved'_bool_fun with (ul := nodel :: ul).  assumption.
  assumption.  assumption.  assumption.  apply used_node'_cons_node_ul.  
  assumption.  apply bool_fun_eq_sym.
  apply
   bool_fun_eq_trans
    with
      (bf2 := bool_fun_or
                (bool_fun_if x1 (bool_fun_of_BDD cfg r1)
                   (bool_fun_of_BDD cfg l1)) (bool_fun_of_BDD cfg node2)).
  apply bool_fun_or_preserves_eq.
  apply bool_fun_eq_trans with (bf2 := bool_fun_of_BDD cfg node1).
  apply used_nodes_preserved'_bool_fun with (ul := ul).  assumption.  assumption.
  apply used_nodes_preserved_trans with (cfg2 := cfgl).  assumption.  assumption.
  apply used_nodes_preserved_trans with (cfg2 := cfgr).  assumption.  
  apply used_nodes_preserved_cons with (node := nodel).  assumption.  
  apply used_nodes_preserved_cons with (node := nodel).
  apply used_nodes_preserved_cons with (node := noder).  assumption.  assumption.
  assumption.  apply bool_fun_of_BDD_int.  assumption.  assumption.  
  apply used_nodes_preserved'_bool_fun with (ul := ul).  assumption.  assumption.
  apply used_nodes_preserved_trans with (cfg2 := cfgl).  assumption.  assumption.
  apply used_nodes_preserved_trans with (cfg2 := cfgr).  assumption.  
  apply used_nodes_preserved_cons with (node := nodel).  assumption.
  apply used_nodes_preserved_cons with (node := nodel).
  apply used_nodes_preserved_cons with (node := noder).  assumption.  assumption.
  assumption.  apply bool_fun_or_orthogonal_left.
  apply BDDorm_put_nodes_preserved.
  apply used_nodes_preserved_node_OK' with (ul := ul) (cfg := cfg).  assumption.
  assumption.  assumption.  apply used_nodes_preserved_trans with (cfg2 := cfgl).
  assumption.  assumption.  apply used_nodes_preserved_trans with (cfg2 := cfgr).
  assumption.  apply used_nodes_preserved_cons with (node := nodel).  assumption.
  apply used_nodes_preserved_cons with (node := nodel).
  apply used_nodes_preserved_cons with (node := noder).  assumption.  
  apply used_nodes_preserved_node_OK' with (ul := ul) (cfg := cfg).  assumption.
  assumption.  assumption.  apply used_nodes_preserved_trans with (cfg2 := cfgl).
  assumption.  assumption.  apply used_nodes_preserved_trans with (cfg2 := cfgr).
  assumption.  apply used_nodes_preserved_cons with (node := nodel).  assumption.
  apply used_nodes_preserved_cons with (node := nodel).
  apply used_nodes_preserved_cons with (node := noder).  assumption.
  replace cfg' with
   (fst (BDDmake gc cfgr x1 nodel noder (noder :: nodel :: ul))).
  replace node' with
   (snd (BDDmake gc cfgr x1 nodel noder (noder :: nodel :: ul))).
  apply BDDmake_node_height_le.  assumption.  assumption.  rewrite H9.  reflexivity.
  rewrite H9.  reflexivity.
  replace node' with
   (snd (BDDmake gc cfgr x1 nodel noder (noder :: nodel :: ul))).
  replace cfg' with
   (fst (BDDmake gc cfgr x1 nodel noder (noder :: nodel :: ul))).
  apply BDDmake_bool_fun.  assumption.  assumption.  assumption.  assumption.
  assumption.  assumption.  assumption.  rewrite H9.  reflexivity.  rewrite H9.
  reflexivity.  replace cfg' with
   (fst (BDDmake gc cfgr x1 nodel noder (noder :: nodel :: ul))).
  replace node' with
   (snd (BDDmake gc cfgr x1 nodel noder (noder :: nodel :: ul))).
  apply BDDmake_node_OK.  assumption.  assumption.  assumption.  assumption.
  assumption.  assumption.  assumption.  rewrite H9.  reflexivity.  rewrite H9.
  reflexivity.  replace cfg' with
   (fst (BDDmake gc cfgr x1 nodel noder (noder :: nodel :: ul))).
  apply BDDmake_preserves_used_nodes.  assumption.  assumption.  assumption.  
  rewrite H9.  reflexivity.
  replace cfg' with
   (fst (BDDmake gc cfgr x1 nodel noder (noder :: nodel :: ul))).
  apply BDDmake_keeps_config_OK.  assumption.  assumption.  assumption.  
  assumption.  assumption.  assumption.  assumption.  rewrite H9.  reflexivity.
  intros.  rewrite (ad_S_compare xr x1).
  replace (ad_S xr) with (node_height cfgr noder).
  replace (ad_S x1) with (node_height cfg node1).  apply BDDlt_compare.
  apply
   le_lt_trans
    with
      (m := nat_of_N
              (BDDvar_max (node_height cfgl r1) (node_height cfgl node2))).
  apply leb_complete.  assumption.  
  rewrite (Neqb_complete (node_height cfgl r1) (node_height cfg r1)).
  rewrite (Neqb_complete (node_height cfgl node2) (node_height cfg node2)).
  rewrite (BDDvar_max_max (node_height cfg r1) (node_height cfg node2)).
  rewrite <- (max_x_x_eq_x (nat_of_N (node_height cfg node1))).  apply lt_max_1.  
  apply BDDcompare_lt.  unfold node_height in |- *.  apply bs_node_height_right with (x := x1) (l := l1).
  exact (proj1 H1).  assumption.  apply BDDcompare_lt.  unfold node_height in |- *.
  unfold bs_node_height in |- *.  rewrite H5.  rewrite H6.  rewrite <- (ad_S_compare x2 x1).
  assumption.  apply used_nodes_preserved'_node_height_eq with (ul := ul).  assumption.
  assumption.  assumption.  assumption.  assumption.
  apply used_nodes_preserved'_node_height_eq with (ul := ul).  assumption.  assumption.  
  assumption.  assumption.  assumption.  unfold node_height in |- *.  unfold bs_node_height in |- *.
  rewrite H5.  reflexivity.  unfold node_height in |- *.  unfold bs_node_height in |- *.  rewrite H32.
  reflexivity.  intros.  rewrite (ad_S_compare xl x1).
  replace (ad_S xl) with (node_height cfgr nodel).
  replace (ad_S x1) with (node_height cfg node1).
  rewrite (Neqb_complete (node_height cfgr nodel) (node_height cfgl nodel)).
  apply BDDlt_compare.
  apply
   le_lt_trans
    with
      (m := nat_of_N
              (BDDvar_max (node_height cfg l1) (node_height cfg node2))).
  apply leb_complete.  assumption.
  rewrite (BDDvar_max_max (node_height cfg l1) (node_height cfg node2)).
  rewrite <- (max_x_x_eq_x (nat_of_N (node_height cfg node1))).  apply lt_max_1.
  apply BDDcompare_lt.  unfold node_height in |- *.  apply bs_node_height_left with (x := x1) (r := r1).
  exact (proj1 H1).  assumption.  apply BDDcompare_lt.  unfold node_height in |- *.
  unfold bs_node_height in |- *.  rewrite H5.  rewrite H6.  rewrite <- (ad_S_compare x2 x1).
  assumption.  apply used_nodes_preserved'_node_height_eq with (ul := nodel :: ul).
  assumption.  assumption.  assumption.  assumption.
  apply used_node'_cons_node_ul.  unfold node_height in |- *.  unfold bs_node_height in |- *.  rewrite H5.
  reflexivity.  unfold node_height in |- *.  unfold bs_node_height in |- *.  rewrite H32.  reflexivity.
  apply used_node'_cons_node_ul.  apply used_node'_cons_node'_ul.
  apply used_node'_cons_node_ul.  apply node_OK_list_OK.  assumption.
  assumption.  apply used_nodes_preserved_list_OK with (cfg := cfgl).  assumption.
  assumption.  replace cfgr with (fst (BDDor_1 cfgl (nodel :: ul) r1 node2 n)).
  replace noder with (snd (BDDor_1 cfgl (nodel :: ul) r1 node2 n)).  apply H.
  apply
   lt_trans_1
    with
      (y := max (nat_of_N (node_height cfg node1))
              (nat_of_N (node_height cfg node2))).
  rewrite <- (BDDvar_max_max (node_height cfg node1) (node_height cfg node2)).
  rewrite (BDDvar_max_comm (node_height cfg node1) (node_height cfg node2)).
  rewrite (BDDvar_max_inf (node_height cfg node2) (node_height cfg node1)).
  rewrite <- (max_x_x_eq_x (nat_of_N (node_height cfg node1))).  apply lt_max_1.
  rewrite (Neqb_complete (node_height cfgl r1) (node_height cfg r1)).  apply BDDcompare_lt.
  unfold node_height in |- *.  apply bs_node_height_right with (x := x1) (l := l1).  exact (proj1 H1).
  assumption.  apply used_nodes_preserved'_node_height_eq with (ul := ul).  assumption.
  assumption.  assumption.  assumption.  assumption.
  rewrite (Neqb_complete (node_height cfgl node2) (node_height cfg node2)).  unfold node_height in |- *.
  apply BDDcompare_lt.  unfold bs_node_height in |- *.  rewrite H5.  rewrite H6.
  rewrite <- (ad_S_compare x2 x1).  assumption.
  apply used_nodes_preserved'_node_height_eq with (ul := ul).  assumption.  assumption.
  assumption.  assumption.  assumption.  unfold node_height in |- *.  unfold bs_node_height in |- *.
  rewrite H5.  rewrite H6.  rewrite <- (ad_S_compare x2 x1).  assumption.
  assumption.  assumption.  assumption.  assumption.  assumption.  rewrite H8.
  reflexivity.  rewrite H8.  reflexivity.  apply used_node'_cons_node'_ul.
  assumption.  apply used_node'_cons_node'_ul.  assumption.
  apply used_nodes_preserved_used_node' with (cfg := cfg).  assumption.
  assumption.  assumption.  apply used_nodes_preserved_used_node' with (cfg := cfg).
  assumption.  assumption.  assumption.  apply node_OK_list_OK.  assumption.  
  assumption.  apply used_nodes_preserved_list_OK with (cfg := cfg).  assumption.  
  assumption.  replace cfgl with (fst (BDDor_1 cfg ul l1 node2 n)).
  replace nodel with (snd (BDDor_1 cfg ul l1 node2 n)).  apply H.
  apply
   lt_trans_1
    with
      (y := max (nat_of_N (node_height cfg node1))
              (nat_of_N (node_height cfg node2))).
  rewrite <- (BDDvar_max_max (node_height cfg node1) (node_height cfg node2)).
  rewrite (BDDvar_max_comm (node_height cfg node1) (node_height cfg node2)).
  rewrite (BDDvar_max_inf (node_height cfg node2) (node_height cfg node1)).
  rewrite <- (max_x_x_eq_x (nat_of_N (node_height cfg node1))).  apply lt_max_1.
  apply BDDcompare_lt.  unfold node_height in |- *.  apply bs_node_height_left with (x := x1) (r := r1).
  exact (proj1 H1).  assumption.  unfold node_height in |- *.  apply BDDcompare_lt.
  unfold bs_node_height in |- *.  rewrite H5.  rewrite H6.  rewrite <- (ad_S_compare x2 x1).
  assumption.  unfold node_height in |- *.  unfold bs_node_height in |- *.  rewrite H5.  rewrite H6.
  rewrite <- (ad_S_compare x2 x1).  assumption.  assumption.  assumption.
  assumption.  assumption.  assumption.  rewrite H7.  reflexivity.  rewrite H7.
  reflexivity.  apply high_used' with (node := node1) (x := x1) (l := l1).  assumption.
  assumption.  assumption.  apply low_used' with (node := node1) (x := x1) (r := r1).
  assumption.  assumption.  assumption.  apply BDDcompare_sup_inf.  assumption.
  intro y0.  rewrite y0.  elim (sumbool_of_bool (Neqb node2 BDDzero)).  intro y1.
  rewrite y1.  cut (nodes_preserved cfg (BDDor_memo_put cfg node1 node2 node1)).
  intro.  cut (BDDconfig_OK (BDDor_memo_put cfg node1 node2 node1)).  intro.
  split.  assumption.  split.
  apply nodes_preserved_config_node_OK with (cfg1 := cfg).  assumption.  
  apply used_node'_OK with (ul := ul).  assumption.  assumption.  assumption.
  split.  apply nodes_preserved_used_nodes_preserved.  assumption.  split.
  simpl in |- *.  rewrite (Neqb_complete _ _ y1).
  rewrite (Neqb_complete _ _ (node_height_zero cfg H1)).
  rewrite (BDDvar_max_comm (node_height cfg node1) N0).  unfold BDDvar_max in |- *.  simpl in |- *.
  rewrite
   (Neqb_complete
      (node_height (BDDor_memo_put cfg node1 BDDzero node1) node1)
      (node_height cfg node1)).
  apply Nleb_refl.  apply nodes_preserved_node_height_eq.  assumption.
  rewrite <- (Neqb_complete _ _ y1).  assumption.
  rewrite <- (Neqb_complete _ _ y1).  assumption.
  apply used_node'_OK with (ul := ul).  assumption.  assumption.  assumption.
  simpl in |- *.  apply bool_fun_eq_trans with (bf2 := bool_fun_of_BDD cfg node1).
  apply nodes_preserved_bool_fun.  assumption.  assumption.  assumption.
  apply used_node'_OK with (ul := ul).  assumption.  assumption.  assumption.
  rewrite (Neqb_complete _ _ y1).
  apply
   bool_fun_eq_trans
    with (bf2 := bool_fun_or (bool_fun_of_BDD cfg node1) bool_fun_zero).
  apply bool_fun_eq_sym.  apply bool_fun_or_zero.
  apply bool_fun_or_preserves_eq.  apply bool_fun_eq_refl.
  apply bool_fun_eq_sym.  apply bool_fun_of_BDD_zero.  assumption.  
  apply BDDorm_put_OK.  assumption.  apply used_node'_OK with (ul := ul).
  assumption.  assumption.  assumption.  apply used_node'_OK with (ul := ul).
  assumption.  assumption.  assumption.  apply used_node'_OK with (ul := ul).
  assumption.  assumption.  assumption.  apply BDDvar_le_max_1.
  apply
   bool_fun_eq_trans
    with (bf2 := bool_fun_or (bool_fun_of_BDD cfg node1) bool_fun_zero).
  apply bool_fun_eq_sym.  apply bool_fun_or_zero.
  apply bool_fun_or_preserves_eq.  apply bool_fun_eq_refl.
  apply bool_fun_eq_sym.  rewrite (Neqb_complete _ _ y1).
  apply bool_fun_of_BDD_zero.  assumption.  apply BDDorm_put_nodes_preserved.
  intro y1.  rewrite y1.  cut (Neqb node2 BDDone = true).  intro.
  cut (config_node_OK cfg node1).  cut (config_node_OK cfg node2).  intros.
  cut (nodes_preserved cfg (BDDor_memo_put cfg node1 node2 node2)).  intro.
  cut (BDDconfig_OK (BDDor_memo_put cfg node1 node2 node2)).  intro.  split.
  assumption.  split.  apply nodes_preserved_config_node_OK with (cfg1 := cfg).
  assumption.  assumption.  split.  apply nodes_preserved_used_nodes_preserved.
  assumption.  split.  simpl in |- *.
  rewrite
   (Neqb_complete (node_height (BDDor_memo_put cfg node1 node2 node2) node2)
      (node_height cfg node2)).
  apply BDDvar_le_max_2.  apply nodes_preserved_node_height_eq.  assumption.
  assumption.  assumption.  assumption.  simpl in |- *.
  apply bool_fun_eq_trans with (bf2 := bool_fun_of_BDD cfg node2).
  apply nodes_preserved_bool_fun.  assumption.  assumption.  assumption.  
  assumption.  rewrite (Neqb_complete _ _ H6).
  apply
   bool_fun_eq_trans
    with (bf2 := bool_fun_or (bool_fun_of_BDD cfg node1) bool_fun_one).
  apply bool_fun_eq_sym.  apply bool_fun_eq_trans with (bf2 := bool_fun_one).
  apply bool_fun_or_one.  apply bool_fun_eq_sym.  apply bool_fun_of_BDD_one.
  assumption.  apply bool_fun_or_preserves_eq.  apply bool_fun_eq_refl.  
  apply bool_fun_eq_sym.  apply bool_fun_of_BDD_one.  assumption.
  apply BDDorm_put_OK.  assumption.  assumption.  assumption.  assumption.  
  apply BDDvar_le_max_2.
  apply
   bool_fun_eq_trans
    with (bf2 := bool_fun_or (bool_fun_of_BDD cfg node1) bool_fun_one).
  apply bool_fun_eq_sym.  rewrite (Neqb_complete _ _ H6).
  apply bool_fun_eq_trans with (bf2 := bool_fun_one).  apply bool_fun_or_one.
  apply bool_fun_eq_sym.  apply bool_fun_of_BDD_one.  assumption.
  apply bool_fun_or_preserves_eq.  apply bool_fun_eq_refl.
  apply bool_fun_eq_sym.  rewrite (Neqb_complete _ _ H6).
  apply bool_fun_of_BDD_one.  assumption.  apply BDDorm_put_nodes_preserved.
  apply used_node'_OK with (ul := ul).  assumption.  assumption.  assumption.
  apply used_node'_OK with (ul := ul).  assumption.  assumption.  assumption.  
  apply not_zero_is_one with (cfg := cfg).  apply used_node'_OK with (ul := ul).
  assumption.  assumption.  assumption.  unfold in_dom in |- *.  rewrite y0.
  reflexivity.  assumption.  intro y0.  rewrite y0.
  cut (config_node_OK cfg node1).  cut (config_node_OK cfg node2).
  intros H00 H01.  elim (sumbool_of_bool (Neqb node1 BDDzero)).  intro y1.
  rewrite y1.  cut (nodes_preserved cfg (BDDor_memo_put cfg node1 node2 node2)).
  intro.  cut (BDDconfig_OK (BDDor_memo_put cfg node1 node2 node2)).  intro.
  split.  assumption.  split.
  apply nodes_preserved_config_node_OK with (cfg1 := cfg).  assumption.  assumption.
  split.  apply nodes_preserved_used_nodes_preserved.  assumption.  split.
  simpl in |- *.  rewrite
   (Neqb_complete (node_height (BDDor_memo_put cfg node1 node2 node2) node2)
      (node_height cfg node2)).
  apply BDDvar_le_max_2.  apply nodes_preserved_node_height_eq.  assumption.  
  assumption.  assumption.  assumption.  simpl in |- *.
  apply bool_fun_eq_trans with (bf2 := bool_fun_of_BDD cfg node2).
  apply nodes_preserved_bool_fun.  assumption.  assumption.  assumption.  
  assumption.  rewrite (Neqb_complete _ _ y1).
  apply
   bool_fun_eq_trans
    with (bf2 := bool_fun_or bool_fun_zero (bool_fun_of_BDD cfg node2)).
  apply bool_fun_eq_sym.
  apply
   bool_fun_eq_trans
    with (bf2 := bool_fun_or (bool_fun_of_BDD cfg node2) bool_fun_zero).
  apply bool_fun_or_comm.  apply bool_fun_or_zero.
  apply bool_fun_or_preserves_eq.  apply bool_fun_eq_sym.
  apply bool_fun_of_BDD_zero.  assumption.  apply bool_fun_eq_refl.
  apply BDDorm_put_OK.  assumption.  assumption.  assumption.  assumption.
  apply BDDvar_le_max_2.  apply
   bool_fun_eq_trans
    with (bf2 := bool_fun_or bool_fun_zero (bool_fun_of_BDD cfg node2)).
  apply
   bool_fun_eq_trans
    with (bf2 := bool_fun_or (bool_fun_of_BDD cfg node2) bool_fun_zero).
  apply bool_fun_eq_sym.  apply bool_fun_or_zero.  apply bool_fun_or_comm.  
  apply bool_fun_or_preserves_eq.  apply bool_fun_eq_sym.
  rewrite (Neqb_complete _ _ y1).  apply bool_fun_of_BDD_zero.  assumption.
  apply bool_fun_eq_refl.  apply BDDorm_put_nodes_preserved.  intro y1.
  rewrite y1.  cut (Neqb node1 BDDone = true).  intro.
  cut (nodes_preserved cfg (BDDor_memo_put cfg node1 node2 node1)).  intro.
  cut (BDDconfig_OK (BDDor_memo_put cfg node1 node2 node1)).  intro.  split.
  assumption.  split.  apply nodes_preserved_config_node_OK with (cfg1 := cfg).
  assumption.  assumption.  split.  apply nodes_preserved_used_nodes_preserved.
  assumption.  split.  simpl in |- *.  
  rewrite
   (Neqb_complete (node_height (BDDor_memo_put cfg node1 node2 node1) node1)
      (node_height cfg node1)).
  apply BDDvar_le_max_1.  apply nodes_preserved_node_height_eq.  assumption.  
  assumption.  assumption.  assumption.  simpl in |- *.
  apply bool_fun_eq_trans with (bf2 := bool_fun_of_BDD cfg node1).
  apply nodes_preserved_bool_fun.  assumption.  assumption.  assumption.  
  assumption.  rewrite (Neqb_complete _ _ H5).
  apply
   bool_fun_eq_trans
    with (bf2 := bool_fun_or (bool_fun_of_BDD cfg node2) bool_fun_one).
  apply bool_fun_eq_sym.  apply bool_fun_eq_trans with (bf2 := bool_fun_one).
  apply bool_fun_or_one.  apply bool_fun_eq_sym.  apply bool_fun_of_BDD_one.
  assumption.  apply
   bool_fun_eq_trans
    with (bf2 := bool_fun_or bool_fun_one (bool_fun_of_BDD cfg node2)).
  apply bool_fun_or_comm.  apply bool_fun_or_preserves_eq.
  apply bool_fun_eq_sym.  apply bool_fun_of_BDD_one.  assumption.  
  apply bool_fun_eq_refl.  apply BDDorm_put_OK.  assumption.  assumption.
  assumption.  assumption.  apply BDDvar_le_max_1.
  rewrite (Neqb_complete _ _ H5).  apply
   bool_fun_eq_trans
    with (bf2 := bool_fun_or (bool_fun_of_BDD cfg node2) bool_fun_one).
  apply bool_fun_eq_sym.  apply bool_fun_eq_trans with (bf2 := bool_fun_one).
  apply bool_fun_or_one.  apply bool_fun_eq_sym.  apply bool_fun_of_BDD_one.
  assumption.  apply
   bool_fun_eq_trans
    with (bf2 := bool_fun_or bool_fun_one (bool_fun_of_BDD cfg node2)).
  apply bool_fun_or_comm.  apply bool_fun_or_preserves_eq.
  apply bool_fun_eq_sym.  apply bool_fun_of_BDD_one.  assumption.  
  apply bool_fun_eq_refl.  apply BDDorm_put_nodes_preserved.  
  apply not_zero_is_one with (cfg := cfg).  assumption.  unfold in_dom in |- *.
  rewrite y0.  reflexivity.  assumption.  apply used_node'_OK with (ul := ul).
  assumption.  assumption.  assumption.  apply used_node'_OK with (ul := ul).
  assumption.  assumption.  assumption.  
Qed.

End BDD_or.