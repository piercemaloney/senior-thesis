Require Export Assoc.
(* Assoc:
Require Import Coq.Lists.List.

Import ListNotations.

Fixpoint add {A B} (eqb : A -> A -> bool) (l : list (A * B)) (k : A) (v : B)
  : list (A * B) :=
  match l with
  | [] => [(k, v)]
  | (k', v') :: l =>
    if eqb k k' then
      (k, v) :: l
    else
      (k', v') :: add eqb l k v
  end.

Fixpoint find {A B} (eqb : A -> A -> bool) (l : list (A * B)) (k : A)
  : option B :=
  match l with
  | [] => None
  | (k', v) :: l =>
    if eqb k k' then
      Some v
    else
      find eqb l k
  end.

Fixpoint remove {A B} (eqb : A -> A -> bool) (l : list (A * B)) (k : A)
  : list (A * B) :=
  match l with
  | [] => l
  | (k', v) :: l =>
    if eqb k k' then
      l
    else
      (k', v) :: remove eqb l k
  end.

Module Test.
  Require Import Coq.Arith.EqNat.

  Definition add_nil {A B} (eqb : A -> A -> bool) (k : A) (v : B)
    : add eqb [] k v = [(k, v)] :=
    eq_refl.

  Definition add_nat_1
    : add beq_nat [(2, 4); (3, 6)] 3 7 = [(2, 4); (3, 7)] :=
    eq_refl.

  Definition add_nat_2
    : add beq_nat [(2, 4); (3, 6)] 4 7 = [(2, 4); (3, 6); (4, 7)] :=
    eq_refl.

  Definition find_nil {A B} (eqb : A -> A -> bool) (k : A)
    : find (B := B) eqb [] k = None :=
    eq_refl.

  Definition find_nat_1 : find beq_nat [(2, 4); (3, 6)] 3 = Some 6 :=
    eq_refl.

  Definition find_nat_2 : find beq_nat [(2, 4); (3, 6)] 4 = None :=
    eq_refl.

  Definition remove_nil {A B} (eqb : A -> A -> bool) (k : A)
    : remove (B := B) eqb [] k = [] :=
    eq_refl.

  Definition remove_nat_1
    : remove beq_nat [(2, 4); (3, 6)] 3 = [(2, 4)] :=
    eq_refl.

  Definition remove_nat_2
    : remove beq_nat [(2, 4); (3, 6)] 4 = [(2, 4); (3, 6)] :=
    eq_refl.
End Test. *)
Require Export List.
(* List:
Require Import Coq.Lists.List.

Import ListNotations.

Fixpoint repeat_aux {A : Type} (x : A) (n : nat) (l : list A) : list A :=
  match n with
  | O => l
  | S n => repeat_aux x n (x :: l)
  end.

Definition repeat {A : Type} (x : A) (n : nat) : list A :=
  repeat_aux x n [].

Fixpoint remove_nones {A : Type} (l : list (option A)) : list A :=
  match l with
  | [] => []
  | None :: l => remove_nones l
  | Some x :: l => x :: remove_nones l
  end.

Fixpoint map_filter {A B : Type} (f : A -> option B) (l : list A) : list B :=
  match l with
  | [] => []
  | x :: l =>
    match f x with
    | None => map_filter f l
    | Some y => y :: map_filter f l
    end
  end. *)
Require Export Sort.
(* Sort:
Require Import Coq.Lists.List.

Import ListNotations.

Fixpoint merge {A : Type} (leb : A -> A -> bool) (l1 l2 : list A) : list A :=
  let fix aux (l2 : list A) : list A :=
    match (l1, l2) with
    | ([], _) => l2
    | (_, []) => l1
    | (x1 :: l1, x2 :: l2) =>
      if leb x1 x2 then
        x1 :: merge leb l1 (x2 :: l2)
      else
        x2 :: aux l2
    end in
  aux l2.

Module Stack.
  Definition t (A : Type) := list (option (list A)).

  Fixpoint add {A : Type} (leb : A -> A -> bool) (s : t A) (l : list A) : t A :=
    match s with
    | [] => [Some l]
    | None :: s => Some l :: s
    | Some l' :: s => None :: add leb s (merge leb l l')
    end.

  Fixpoint of_list {A : Type} (leb : A -> A -> bool) (l : list A) : t A :=
    match l with
    | [] => []
    | x :: l => add leb (of_list leb l) [x]
    end.

  Fixpoint to_list {A : Type} (leb : A -> A -> bool) (s : t A) : list A :=
    match s with
    | [] => []
    | None :: s => to_list leb s
    | Some l :: s => merge leb l (to_list leb s)
    end.
End Stack.

Definition sort {A : Type} (leb : A -> A -> bool) (l : list A) : list A :=
  Stack.to_list leb (Stack.of_list leb l).

Module Test.
  Require Import Coq.Arith.Compare_dec.

  Definition l := [5; 1; 3; 7; 8 ;0; 0; 3 ;6 ;5 ;4].
  Definition sorted_l := [0; 0; 1; 3; 3; 4; 5; 5; 6; 7; 8].
  
  Definition ok : sort leb l = sorted_l :=
    eq_refl.
End Test. *)
