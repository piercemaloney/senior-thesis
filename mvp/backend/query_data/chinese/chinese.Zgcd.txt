
Require Export misc.
(* misc:
Require Export Lci.

Definition antisym (A : Set) (R : A -> A -> Prop) :=
  forall x y : A, R x y -> R y x -> x = y :>A.

Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.

Lemma pi2 :
 forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).

Definition inversible (S : Set) (Mult : S -> S -> S) 
  (I x : S) := exists y : S, Mult x y = I /\ Mult y x = I.

Lemma inv_com :
 forall (S : Set) (Mult : S -> S -> S) (I x : S),
 commutativity S Mult ->
 (exists y : S, Mult x y = I) -> inversible S Mult I x. *)
Require Export Zadd.
(* Zadd:
Require Export Arith.
Require Export Nat_complements.
Require Export Lci.
Require Export groups.
Require Export rings.
Require Export Zbase.
Require Export Z_succ_pred.

Fixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=
  match n with
  | O => succZ x2
  | S n0 => succZ (addpos x2 n0)
  end.

Fixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=
  match n with
  | O => predZ x2
  | S n0 => predZ (addneg x2 n0)
  end.

Definition addZ (x1 x2 : Z) :=
  match x1 with
  | OZ => x2
  | pos n => addpos x2 n
  | neg n => addneg x2 n
  end.

Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.

Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.

Lemma addZ_eq3 :
 forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).

Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.

Lemma addZ_eq5 :
 forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).

Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).

Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).

Lemma tech_add_pos_succZ :
 forall (x : nat) (y : Z), addZ (pos (S x)) y = succZ (addZ (pos x) y).
Proof addZ_eq3.

Lemma tech_add_neg_predZ :
 forall (x : nat) (y : Z), addZ (neg (S x)) y = predZ (addZ (neg x) y).
Proof addZ_eq5.

Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).

Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).

Lemma add_OZ : forall x : Z, addZ x OZ = x.

Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.

Lemma add_mIZ_predZ : forall x : Z, addZ x (neg 0) = predZ x.

Theorem addZ_commutativity : commutativity Z addZ.

Lemma tech_add_pos_neg_posZ :
 forall n1 n2 : nat, n2 < n1 -> addZ (pos n1) (neg n2) = pos (n1 - S n2).

Theorem addZ_associativity : associativity Z addZ.

Definition IdZ (x : Z) := True.

Theorem addZ_neutral : neutral Z IdZ addZ OZ.

Definition oppZ (x : Z) :=
  match x return Z with
  | OZ =>
        OZ
       
  | pos n => neg n
       
  | neg n => pos n
  end.

Lemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).

Lemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).

Lemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.

Lemma tech_add_neg_posZ : forall n : nat, addZ (neg n) (pos n) = OZ.

Lemma tech_add_pos_posZ :
 forall n m : nat, addZ (pos n) (pos m) = pos (S (n + m)).

Lemma tech_add_neg_negZ :
 forall n m : nat, addZ (neg n) (neg m) = neg (S (n + m)).

Theorem addZ_opposite : opposite Z IdZ addZ OZ oppZ.

Theorem Z_group : is_group Z IdZ addZ OZ oppZ.

Theorem abs_eq_or_oppZ : forall x : Z, {absZ x = x} + {absZ x = oppZ x}.

Lemma tech_opp_pos_negZ :
 forall n : nat, oppZ (pos n) = neg n /\ oppZ (neg n) = pos n. *)
Require Export Zle.
(* Zle:
Require Export Arith.
Require Export misc.
Require Export groups.
Require Export Zbase.
Require Export Z_succ_pred.
Require Export Zadd.

Definition leZ (x y : Z) :=
  match x return Prop with
  | OZ =>
      match y return Prop with
      | OZ => True
      | pos n => True
      | neg n => False
      end
  | pos n =>
      match y return Prop with
      | OZ => False
      | pos m => n <= m
      | neg m => False
      end
  | neg n =>
      match y return Prop with
      | OZ => True
      | pos m => True
      | neg m => m <= n
      end
  end.

Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).

Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.

Theorem leZ_antisymmetric : antisym Z leZ.

Definition ltZ (x y : Z) := leZ (succZ x) y.

Definition lt_absZ (x y : Z) := ltZ (absZ x) (absZ y).

Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.

Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).

Lemma le_opp_OZ_l : forall x : Z, leZ OZ x -> leZ (oppZ x) OZ.

Lemma le_opp_OZ :
 forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = OZ.

Lemma le_opp_OZ2 :
 forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = y. *)
Require Export Euclid.
Require Export Peano_dec.
Require Export Zrec.
(* Zrec:
Require Export Arith.
Require Export Nat_complements.
Require Export misc.
Require Export Zbase.
Require Export Zle.

Lemma lt_OZ : forall m : Z, ~ ltZ (absZ m) OZ.

Lemma Zrec1 :
 forall P : Z -> Set,
 (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> P OZ.

Inductive and_set_set_set (S1 S2 : Set) : Set :=
    and_set_set_set_i : S2 -> S1 -> and_set_set_set S1 S2.

Definition and_recZ (p : nat) (P : Z -> Set) :=
  forall n : nat, n <= p -> and_set_set_set (P (pos n)) (P (neg n)).

Lemma Zrec2 :
 forall P : Z -> Set,
 (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ 0 P.

Lemma Zrec3 :
 forall (P : Z -> Set) (p : nat),
 (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) ->
 and_recZ p P -> and_recZ (S p) P.

Theorem Zrec4 :
 forall P : Z -> Set,
 (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) ->
 forall p : nat, and_recZ p P.

Theorem recZ :
 forall P : Z -> Set,
 (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) ->
 forall p : Z, P p. *)
Require Export Zmult.
(* Zmult:
Require Export Lci.
Require Export misc.
Require Export Arith.
Require Export Nat_complements.
Require Export groups.
Require Export rings.
Require Export Zbase.
Require Export Z_succ_pred.
Require Export Zadd.

Fixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=
  match n with
  | O => x2
  | S n0 => addZ (multpos x2 n0) x2
  end.

Fixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=
  match n with
  | O => oppZ x2
  | S n0 => addZ (multneg x2 n0) (oppZ x2)
  end. 

Definition multZ (x1 x2 : Z) :=
  match x1 with
  | OZ => OZ
  | pos n => multpos x2 n
  | neg n => multneg x2 n
  end.

Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.

Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.

Lemma multZ_eq3 :
 forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.

Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.

Lemma multZ_eq5 :
 forall (n1 : nat) (n : Z),
 multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).

Lemma tech_mult_posZ :
 forall (x : nat) (y : Z), multZ (pos (S x)) y = addZ (multZ (pos x) y) y.

Proof multZ_eq3.

Lemma tech_mult_negZ :
 forall (x : nat) (y : Z),
 multZ (neg (S x)) y = addZ (multZ (neg x) y) (oppZ y).

Proof multZ_eq5.

Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.

Lemma mult_predZ_l :
 forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).

Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.

Lemma mult_predZ_r :
 forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).

Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.

Lemma mult_IZ : forall x : Z, multZ x IZ = x.

Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.

Theorem multZ_commutativity : commutativity Z multZ.

Theorem multZ_neutral : neutral Z IdZ multZ IZ.

Theorem mult_add_distributivity : distributivity Z addZ multZ.

Lemma mult_oppZ_r : forall x y : Z, multZ x (oppZ y) = oppZ (multZ x y).

Lemma mult_oppZ_l : forall x y : Z, multZ (oppZ x) y = oppZ (multZ x y).

Lemma tech_multZ_negO : forall x : Z, multZ (neg 0) x = oppZ x.

Proof multZ_eq4.

Lemma tech_mult_pos_posZ :
 forall n m : nat, multZ (pos n) (pos m) = pos (n * m + (n + m)).

Lemma tech_mult_neg_negZ :
 forall n m : nat, multZ (neg n) (neg m) = pos (n * m + (n + m)).

Lemma tech_mult_pos_negZ :
 forall n m : nat, multZ (pos n) (neg m) = neg (n * m + (n + m)).

Lemma tech_mult_neg_posZ :
 forall n m : nat, multZ (neg n) (pos m) = neg (n * m + (n + m)).

Theorem multZ_associativity : associativity Z multZ.

Theorem Z_ring : is_ring Z IdZ addZ multZ OZ oppZ.

Theorem Z_unitary_commutative_ring :
 is_unitary_commutative_ring Z IdZ addZ multZ OZ IZ oppZ.

Lemma tech_integ_posZ :
 forall (n : nat) (x : Z), multZ (pos n) x = OZ -> x = OZ.

Lemma tech_integ_negZ :
 forall (n : nat) (x : Z), multZ (neg n) x = OZ -> x = OZ.

Theorem integrityZ : integrity Z multZ OZ.

Lemma tech_mult_pos_succZ :
 forall n m : nat, posOZ (S n * S m) = multZ (pos n) (pos m).

Lemma tech_mult_pos_succZ2 :
 forall n m : nat, multZ (pos n) (pos m) = pos (S n * m + n).

Lemma tech_div1 :
 forall n0 n q r : nat,
 S n0 = q * S n + r -> pos n0 = addZ (multZ (pos n) (posOZ q)) (posOZ r).

Lemma tech_div2 :
 forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (pos n) (negOZ q).

Lemma tech_div31 :
 forall n q : nat,
 addZ (oppZ (multZ (pos n) (pos q))) (pos n) = oppZ (multZ (pos n) (posOZ q)).

Lemma tech_div32 :
 forall n q r : nat, S n > r -> pos (n - r) = addZ (pos n) (oppZ (posOZ r)).

Lemma tech_div3 :
 forall n0 n q r : nat,
 S n0 = q * S n + r ->
 S n > r -> neg n0 = addZ (multZ (pos n) (neg q)) (pos (n - r)).

Lemma tech_div4 :
 forall n0 n q r : nat,
 S n0 = q * S n + r -> pos n0 = addZ (multZ (neg n) (negOZ q)) (posOZ r).

Lemma tech_div5 :
 forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (neg n) (posOZ q).

Lemma tech_div6 :
 forall n0 n q r : nat,
 S n0 = q * S n + r ->
 S n > r -> neg n0 = addZ (multZ (neg n) (pos q)) (pos (n - r)).

Lemma inversibleZ :
 forall x : Z, inversible Z multZ IZ x -> x = IZ \/ x = oppZ IZ.

Lemma sgn_abs : forall x : Z, multZ x (sgnZ x) = absZ x. *)
Require Export Zdiv.
(* Zdiv:
Require Export Zbase.
Require Export Zadd.
Require Export Zmult.
Require Export Zle.
Require Export Euclid.

Unset Standard Proposition Elimination Names.

Definition is_diveuclZ (a b q r : Z) :=
  b <> OZ /\ leZ OZ r /\ ltZ r (absZ b) /\ a = addZ (multZ b q) r.

Inductive diveuclZ (a b : Z) : Set :=
    divexZ : forall q r : Z, is_diveuclZ a b q r -> diveuclZ a b.

Lemma divZ : forall a b : Z, b <> OZ -> diveuclZ a b. *)

Unset Standard Proposition Elimination Names.

Lemma gcd_unicity_apart_sign :
 forall a b d1 d2 : Z,
 is_gcd Z IdZ multZ OZ a b d1 ->
 is_gcd Z IdZ multZ OZ a b d2 -> d2 = d1 \/ d2 = oppZ d1.

intros.
elim
 (gcd_unicity_apart_unities Z IdZ addZ multZ OZ IZ oppZ
    Z_unitary_commutative_ring integrityZ a b d1 d2 H H0).
intros.
elim (inversibleZ x); intros.
left. elim H1; intros; elim H4; intros. rewrite H6. rewrite H2. 
exact (mult_IZ d1).
right. elim H1; intros; elim H4; intros. rewrite H6. rewrite H2.
simpl in |- *; exact (mult_mIZ d1).
elim H1; intros; exact H2.
Qed.

Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ multZ OZ OZ b (absZ b).

intros. elim (abs_eq_or_oppZ b); intro y.

rewrite y.
unfold is_gcd in |- *; split.
unfold divide in |- *; unfold IdZ in |- *; split. exact I. split. exact I. left; reflexivity.
split; unfold divide in |- *; unfold IdZ in |- *. split. exact I. split. exact I.
elim (eq_OZ_dec b); intro y0. 
left; exact y0.
right. split. exact y0. exists IZ. split. exact I. symmetry  in |- *; exact (mult_IZ b).
intros; exact H0.

rewrite y.
unfold is_gcd in |- *; split.
unfold divide in |- *; unfold IdZ in |- *; split. exact I. split. exact I. left; reflexivity.
split; unfold divide in |- *; unfold IdZ in |- *; split. exact I. split. exact I.
elim (eq_OZ_dec b); intro y0. 
left; exact y0.
right. split.
unfold not in |- *; intros; elim y0.
exact (opp_O Z IdZ addZ multZ OZ oppZ Z_ring b I H).
exists (oppZ IZ); split. exact I.
rewrite (mult_opp_opp Z IdZ addZ multZ OZ oppZ Z_ring b IZ I I).
symmetry  in |- *; exact (mult_IZ b). exact I. split. exact I.
elim H0; intros; elim H2; intros; elim H4; intros. rewrite H5. 
left; reflexivity.
right; split. elim H5; intros; exact H6. elim H5; intros; elim H7; intros.
exists (oppZ x). split. exact I. elim H8; intros; rewrite H10.
symmetry  in |- *; exact (mult_opp_r Z IdZ addZ multZ OZ oppZ Z_ring q x I I).
Qed.

Inductive is_gcdZ : Z -> Z -> Z -> Prop :=
  | gcd_OZ : forall b : Z, is_gcdZ OZ b (absZ b)
  | gcd_mod :
      forall b a d q r : Z,
      b <> OZ -> is_diveuclZ a b q r -> is_gcdZ r b d -> is_gcdZ b a d.

Definition have_gcdZ (a b : Z) := {d : Z | is_gcdZ a b d}.

Definition gcdZ_i (a b : Z) := exist (is_gcdZ a b).

Definition P (a : Z) := forall b : Z, have_gcdZ a b.

Lemma acc_P : forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n.
Proof.
  intros. case (eq_OZ_dec n); intro. unfold P in |- *. intro.
  split with (absZ b). rewrite e. apply (gcd_OZ b).
  unfold P in |- *; intro. elim (divZ b n). intros. cut (lt_absZ r n); intros.
  elim (H r H0 n). intros. split with x.
  apply gcd_mod with (2 := i); trivial. inversion i. decompose [and] H1.
  unfold lt_absZ in |- *. rewrite (tech_le_pos_abs r H2). exact H4. exact n0.
Qed.

Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.
Proof.
  exact (recZ P acc_P).
Qed.

Lemma gcdZ_is_gcd :
 forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ multZ OZ a b d.

intros. elim H; intros. apply (gcd_OZ_absZ b0). unfold is_gcd in |- *.
split. elim H3; intros; elim H5; intros; exact H6.
split. elim H1; intros; elim H5; intros; elim H7; intros; rewrite H9.
apply (div_add Z IdZ addZ multZ OZ oppZ Z_ring (multZ b0 q) r d0).
elim H3; intros; elim H11; intros. 
exact (div_mult Z IdZ addZ multZ OZ oppZ Z_ring b0 q d0 H12 I).
elim H3; intros; exact H10.
intros. elim H3; intros; elim H7; intros. apply (H9 q0).
cut (r = addZ a0 (oppZ (multZ b0 q))); intros. rewrite H10.
apply (div_add Z IdZ addZ multZ OZ oppZ Z_ring a0 (oppZ (multZ b0 q)) q0 H5).
apply (div_opp Z IdZ addZ multZ OZ oppZ Z_ring (multZ b0 q) q0).
exact (div_mult Z IdZ addZ multZ OZ oppZ Z_ring b0 q q0 H4 I).
elim H1; intros; elim H11; intros; elim H13; intros; rewrite H15.
elim (addZ_commutativity r (multZ b0 q)).
elim (addZ_associativity r (multZ b0 q) (oppZ (multZ b0 q))).
elim (addZ_opposite (multZ b0 q) I); intros. 
elim H17; intros. elim H19; intros. rewrite H20. symmetry  in |- *. exact (add_OZ r).
exact H4.
Qed.

Definition gcdZ (a b : Z) := pi1 Z (is_gcdZ a b) (gcdZ_exists a b).

Theorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).
Proof fun a b : Z => pi2 Z (is_gcdZ a b) (gcdZ_exists a b).

Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> leZ OZ d.

intros; elim H; intros. apply (sign_absZ b0). exact H3.
Qed.

Lemma unicity_is_gcdZ :
 forall a b d1 d2 : Z, is_gcdZ a b d1 -> is_gcdZ a b d2 -> d2 = d1.

intros.
elim
 (gcd_unicity_apart_sign a b d1 d2 (gcdZ_is_gcd a b d1 H)
    (gcdZ_is_gcd a b d2 H0)).
intros; exact H1.
intros;
 apply
  (le_opp_OZ2 d2 d1 H1 (positive_is_gcdZ a b d2 H0)
     (positive_is_gcdZ a b d1 H)).
Qed.

Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.

intros. apply (unicity_is_gcdZ a b (gcdZ a b) d (gcdZ_correct a b) H).
Qed.

Lemma gcd_modZ :
 forall a b q r : Z, b <> OZ -> is_diveuclZ a b q r -> gcdZ r b = gcdZ b a. 

intros. apply (gcdZ_is_gcdZ b a (gcdZ r b)).
apply (gcd_mod b a (gcdZ r b) q r H H0 (gcdZ_correct r b)).
Qed.

Inductive verify_BezoutZ (a b : Z) : Set :=
    Bezout_i :
      forall u v : Z,
      addZ (multZ a u) (multZ b v) = gcdZ a b -> verify_BezoutZ a b.

Definition Q (a : Z) := forall b : Z, verify_BezoutZ a b.

Lemma acc_Q : forall n : Z, (forall m : Z, lt_absZ m n -> Q m) -> Q n.
Proof.
  intros q f. case (eq_OZ_dec q); intro. unfold Q in |- *; intro b.
  split with IZ (sgnZ b). rewrite e. simpl in |- *. rewrite (sgn_abs b).
  apply (gcdZ_is_gcdZ OZ b (absZ b)); apply gcd_OZ. unfold Q in |- *; intro b.
  elim (divZ b q). intros div rem; intros. cut (lt_absZ rem q); intros.
  elim (f rem H q). intros. split with (addZ v (oppZ (multZ div u))) u.
  elim i. intros. elim H1. intros. elim H3. intros. pattern b at 1 in |- *.
  rewrite H5. elim (mult_add_distributivity q v (oppZ (multZ div u))); intros.
  rewrite H7. elim (mult_add_distributivity (multZ q div) rem u); intros.
  rewrite H8. rewrite (mult_opp_r Z IdZ addZ multZ OZ oppZ Z_ring q (multZ div u) I I).
  elim (addZ_commutativity (multZ rem u) (multZ (multZ q div) u)).
  rewrite
   (add_add Z addZ addZ_commutativity addZ_associativity 
      (multZ q v) (oppZ (multZ q (multZ div u))) (multZ rem u)
      (multZ (multZ q div) u)).
    elim (addZ_commutativity (multZ rem u) (multZ q v)). rewrite e.
    elim (multZ_associativity q div u).
    elim (addZ_opposite (multZ q (multZ div u)) I); intros.
    elim H11; intros; elim H13; intros. rewrite H15.
    rewrite (add_OZ (gcdZ rem q)).
    exact (gcd_modZ b q div rem n i). unfold lt_absZ in |- *.
    elim i; intros; elim H0; intros. rewrite (tech_le_pos_abs rem H1).
    elim H2; trivial. exact n.
Qed.

Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.
Proof.
  exact (recZ Q acc_Q).
Qed.

Definition congruentZ (x y n : Z) :=
  divide Z IdZ multZ OZ n (addZ x (oppZ y)).

Lemma divide_selfZ : forall x : Z, divide Z IdZ multZ OZ x x.

intros. unfold divide in |- *. split. exact I. split. exact I.
elim (eq_OZ_dec x); intros. left; exact a.
right; split. exact b. exists IZ. split. exact I. symmetry  in |- *; exact (mult_IZ x).
Qed.

Theorem chinese_remaindering_theorem :
 forall a b x y : Z,
 gcdZ a b = IZ -> {z : Z | congruentZ z x a /\ congruentZ z y b}.

intros. elim (Bezout_exists a b); intros.
exists (addZ (multZ x (multZ b v)) (multZ y (multZ a u))).
unfold congruentZ in |- *; split.

replace (multZ b v) with (addZ IZ (oppZ (multZ a u))).
elim (mult_add_distributivity x IZ (oppZ (multZ a u))); intros.
rewrite H1; clear H0 H1. rewrite (mult_IZ x).
elim (mult_opp_r Z IdZ addZ multZ OZ oppZ Z_ring a u I I).
rewrite (multZ_associativity x a (oppZ u)). elim (multZ_commutativity a x).
elim (multZ_associativity a x (oppZ u)). rewrite (multZ_associativity y a u).
elim (multZ_commutativity a y). elim (multZ_associativity a y u).
elim
 (addZ_associativity x (multZ a (multZ x (oppZ u))) (multZ a (multZ y u))).
elim
 (addZ_commutativity
    (addZ (multZ a (multZ x (oppZ u))) (multZ a (multZ y u))) x).
elim
 (addZ_associativity
    (addZ (multZ a (multZ x (oppZ u))) (multZ a (multZ y u))) x 
    (oppZ x)).
elim (addZ_opposite x I); intros. elim H1; intros. elim H3; intros. 
rewrite H4; clear H0 H1 H2 H3 H4 H5.
rewrite (add_OZ (addZ (multZ a (multZ x (oppZ u))) (multZ a (multZ y u)))).
apply
 (div_add Z IdZ addZ multZ OZ oppZ Z_ring (multZ a (multZ x (oppZ u)))
    (multZ a (multZ y u)) a).
apply
 (div_mult Z IdZ addZ multZ OZ oppZ Z_ring a (multZ x (oppZ u)) a
    (divide_selfZ a) I).
apply
 (div_mult Z IdZ addZ multZ OZ oppZ Z_ring a (multZ y u) a (divide_selfZ a) I).
elim H. elim e.
elim (addZ_commutativity (multZ b v) (multZ a u)).
elim (addZ_associativity (multZ b v) (multZ a u) (oppZ (multZ a u))).
elim (addZ_opposite (multZ a u) I); intros. elim H1; intros. elim H3; intros.
rewrite H4; clear H0 H1 H2 H3 H4 H5. exact (add_OZ (multZ b v)).

cut (multZ a u = addZ IZ (oppZ (multZ b v))); intros.
rewrite H0; clear H0.
elim (mult_add_distributivity y IZ (oppZ (multZ b v))); intros.
rewrite H1; clear H0 H1. rewrite (mult_IZ y).
elim (mult_opp_r Z IdZ addZ multZ OZ oppZ Z_ring b v I I).
rewrite (multZ_associativity y b (oppZ v)). elim (multZ_commutativity b y).
elim (multZ_associativity b y (oppZ v)). rewrite (multZ_associativity x b v).
elim (multZ_commutativity b x). elim (multZ_associativity b x v).
elim (addZ_commutativity (multZ b (multZ y (oppZ v))) y).
rewrite
 (addZ_associativity (multZ b (multZ x v)) (multZ b (multZ y (oppZ v))) y)
 .
elim
 (addZ_associativity
    (addZ (multZ b (multZ x v)) (multZ b (multZ y (oppZ v)))) y 
    (oppZ y)).
elim (addZ_opposite y I); intros. elim H1; intros. elim H3; intros.
rewrite H4; clear H0 H1 H2 H3 H4 H5.
rewrite (add_OZ (addZ (multZ b (multZ x v)) (multZ b (multZ y (oppZ v))))).
apply
 (div_add Z IdZ addZ multZ OZ oppZ Z_ring (multZ b (multZ x v))
    (multZ b (multZ y (oppZ v))) b).
apply
 (div_mult Z IdZ addZ multZ OZ oppZ Z_ring b (multZ x v) b (divide_selfZ b) I).
apply
 (div_mult Z IdZ addZ multZ OZ oppZ Z_ring b (multZ y (oppZ v)) b
    (divide_selfZ b) I).
elim H. elim e.
elim (addZ_associativity (multZ a u) (multZ b v) (oppZ (multZ b v))).
elim (addZ_opposite (multZ b v) I); intros. elim H1; intros. elim H3; intros.
rewrite H4; clear H0 H1 H2 H3 H4 H5. symmetry  in |- *; exact (add_OZ (multZ a u)).
Qed.
