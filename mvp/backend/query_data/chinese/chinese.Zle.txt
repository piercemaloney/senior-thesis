
Require Export Arith.
Require Export misc.
(* misc:
Require Export Lci.

Definition antisym (A : Set) (R : A -> A -> Prop) :=
  forall x y : A, R x y -> R y x -> x = y :>A.

Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.

Lemma pi2 :
 forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).

Definition inversible (S : Set) (Mult : S -> S -> S) 
  (I x : S) := exists y : S, Mult x y = I /\ Mult y x = I.

Lemma inv_com :
 forall (S : Set) (Mult : S -> S -> S) (I x : S),
 commutativity S Mult ->
 (exists y : S, Mult x y = I) -> inversible S Mult I x. *)
Require Export groups.
(* groups:
Require Export Lci.
Require Export misc.

Section groups.

Variable S : Set.
Variable G : S -> Prop.
Variable Add : S -> S -> S.
Variable O : S.
Variable Opp : S -> S.

Definition is_group :=
  intern S G Add /\
  associativity S Add /\ neutral S G Add O /\ opposite S G Add O Opp. 

Lemma regular_l :
 is_group ->
 forall y z : S,
 G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.

Lemma add_add :
 commutativity S Add ->
 associativity S Add ->
 forall x1 y1 x2 y2 : S,
 Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).

Lemma opp_unicity :
 is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.

Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).

Lemma opp_add :
 is_group ->
 commutativity S Add ->
 forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).

Lemma opp_neutral : is_group -> Opp O = O.

End groups. *)
Require Export Zbase.
(* Zbase:
Inductive Z : Set :=
  | OZ : Z
  | pos : nat -> Z
  | neg : nat -> Z.

Definition IZ := pos 0.

Definition is_posn (x z : Z) :=
  match x, z with
  | pos n, pos m => n = m :>nat
  | _, _ => False
  end.

Lemma tech_pos_not_posZ : forall n m : nat, n <> m -> pos n <> pos m.

Lemma eq_OZ_dec : forall x : Z, {x = OZ} + {x <> OZ}.

Definition posOZ (n : nat) :=
  match n return Z with
  | O =>
        OZ
       
  | S n' => pos n'
  end.

Definition negOZ (n : nat) :=
  match n return Z with
  | O =>
        OZ
       
  | S n' => neg n'
  end.

Definition absZ (x : Z) :=
  match x return Z with
  | OZ =>
        OZ 
       
  | pos n => pos n
       
  | neg n => pos n
  end.

Definition sgnZ (x : Z) :=
  match x return Z with
  | OZ =>
        OZ
       
  | pos n => pos 0
       
  | neg n => neg 0
  end. *)
Require Export Z_succ_pred.
(* Z_succ_pred:
Require Export Arith.
Require Export Zbase.

Definition succZ (x : Z) :=
  match x return Z with
  | OZ =>
        IZ 
       
  | pos n => pos (S n)
       
  | neg n =>
      match n return Z with
      | O =>
            OZ
           
      | S m => neg m
      end
  end.

Definition predZ (x : Z) :=
  match x return Z with
  | OZ =>
        neg 0
       
  | pos n =>
      match n return Z with
      | O =>
            OZ
           
      | S m => pos m
      end
       
  | neg n => neg (S n)
  end.
    
Lemma pred_succZ : forall x : Z, predZ (succZ x) = x.

Lemma succ_predZ : forall x : Z, succZ (predZ x) = x.

Lemma succ_pred_pred_succZ : forall x : Z, succZ (predZ x) = predZ (succZ x).

Lemma tech_pred_posZ : forall n : nat, 0 < n -> predZ (pos n) = pos (pred n).

Lemma tech_succ_posOZ : forall n : nat, succZ (posOZ n) = pos n. *)
Require Export Zadd.
(* Zadd:
Require Export Arith.
Require Export Nat_complements.
Require Export Lci.
Require Export groups.
Require Export rings.
Require Export Zbase.
Require Export Z_succ_pred.

Fixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=
  match n with
  | O => succZ x2
  | S n0 => succZ (addpos x2 n0)
  end.

Fixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=
  match n with
  | O => predZ x2
  | S n0 => predZ (addneg x2 n0)
  end.

Definition addZ (x1 x2 : Z) :=
  match x1 with
  | OZ => x2
  | pos n => addpos x2 n
  | neg n => addneg x2 n
  end.

Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.

Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.

Lemma addZ_eq3 :
 forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).

Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.

Lemma addZ_eq5 :
 forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).

Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).

Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).

Lemma tech_add_pos_succZ :
 forall (x : nat) (y : Z), addZ (pos (S x)) y = succZ (addZ (pos x) y).
Proof addZ_eq3.

Lemma tech_add_neg_predZ :
 forall (x : nat) (y : Z), addZ (neg (S x)) y = predZ (addZ (neg x) y).
Proof addZ_eq5.

Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).

Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).

Lemma add_OZ : forall x : Z, addZ x OZ = x.

Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.

Lemma add_mIZ_predZ : forall x : Z, addZ x (neg 0) = predZ x.

Theorem addZ_commutativity : commutativity Z addZ.

Lemma tech_add_pos_neg_posZ :
 forall n1 n2 : nat, n2 < n1 -> addZ (pos n1) (neg n2) = pos (n1 - S n2).

Theorem addZ_associativity : associativity Z addZ.

Definition IdZ (x : Z) := True.

Theorem addZ_neutral : neutral Z IdZ addZ OZ.

Definition oppZ (x : Z) :=
  match x return Z with
  | OZ =>
        OZ
       
  | pos n => neg n
       
  | neg n => pos n
  end.

Lemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).

Lemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).

Lemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.

Lemma tech_add_neg_posZ : forall n : nat, addZ (neg n) (pos n) = OZ.

Lemma tech_add_pos_posZ :
 forall n m : nat, addZ (pos n) (pos m) = pos (S (n + m)).

Lemma tech_add_neg_negZ :
 forall n m : nat, addZ (neg n) (neg m) = neg (S (n + m)).

Theorem addZ_opposite : opposite Z IdZ addZ OZ oppZ.

Theorem Z_group : is_group Z IdZ addZ OZ oppZ.

Theorem abs_eq_or_oppZ : forall x : Z, {absZ x = x} + {absZ x = oppZ x}.

Lemma tech_opp_pos_negZ :
 forall n : nat, oppZ (pos n) = neg n /\ oppZ (neg n) = pos n. *)

Definition leZ (x y : Z) :=
  match x return Prop with
  | OZ =>
      match y return Prop with
      | OZ => True
      | pos n => True
      | neg n => False
      end
  | pos n =>
      match y return Prop with
      | OZ => False
      | pos m => n <= m
      | neg m => False
      end
  | neg n =>
      match y return Prop with
      | OZ => True
      | pos m => True
      | neg m => m <= n
      end
  end.

Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).

Proof.
intros; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.
Qed.

Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.

Proof.
intros x; elim x. 
unfold absZ in |- *; reflexivity. unfold absZ in |- *; reflexivity. intros; elim H.
Qed.

Theorem leZ_antisymmetric : antisym Z leZ.

Proof.
unfold antisym in |- *; intros x y; elim x.

elim y.

reflexivity.

intros; elim H0.

intros; elim H.

intros n; elim y.

intros; elim H.

simpl in |- *; intros; elim (le_antisym n n0 H H0); reflexivity.

intros; elim H.

intros n; elim y.

intros; elim H0.

intros; elim H0.

simpl in |- *; intros; elim (le_antisym n0 n H H0); reflexivity.
Qed.

Definition ltZ (x y : Z) := leZ (succZ x) y.

Definition lt_absZ (x y : Z) := ltZ (absZ x) (absZ y).

Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.

Proof.
simple induction x.

reflexivity.

unfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;
 unfold leZ in |- *; intros. 
elim (le_Sn_O n H).

unfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;
 unfold leZ in |- *; intros. 
elim (le_Sn_O n H).
Qed.

Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).

Proof.
intros; elim n. simpl in |- *; exact I. simpl in |- *; intros; exact I.
Qed.

Lemma le_opp_OZ_l : forall x : Z, leZ OZ x -> leZ (oppZ x) OZ.

Proof.
intros x; elim x. simpl in |- *; intros; exact I. simpl in |- *; intros; exact I. 
intros; elim H.
Qed.

Lemma le_opp_OZ :
 forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = OZ.

Proof.
intros. apply (leZ_antisymmetric x OZ). rewrite H. exact (le_opp_OZ_l y H1).
exact H0.
Qed.

Lemma le_opp_OZ2 :
 forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = y.

Proof.
intros.
rewrite (le_opp_OZ x y H H0 H1). 
rewrite (opp_opp Z IdZ addZ OZ oppZ Z_group y I); elim H.
rewrite (le_opp_OZ x y H H0 H1); simpl in |- *; reflexivity.
Qed.
