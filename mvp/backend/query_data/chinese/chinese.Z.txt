
Require Export rings.
(* rings:
Require Export Lci.
Require Export misc.
Require Export groups.
Require Export Compare_dec.

Section ring.

Variable S : Set.
Variable A : S -> Prop.
Variable Add Mult : S -> S -> S.
Variable O I : S.
Variable Opp : S -> S.
Variable v : S -> nat.

Definition is_ring :=
  commutativity S Add /\
  is_group S A Add O Opp /\
  intern S A Mult /\ associativity S Mult /\ distributivity S Add Mult.

Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\ Mult O x = O.

Lemma mult_opp_r :
 is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).

Lemma mult_opp_l :
 is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).

Lemma mult_opp_opp :
 is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.

Definition integrity := forall a b : S, Mult a b = O -> {a = O} + {b = O}.

Definition is_unitary_commutative_ring :=
  is_ring /\ commutativity S Mult /\ neutral S A Mult I.

Definition divide (a b : S) :=
  A a /\ A b /\ (b = O \/ a <> O /\ (exists q : S, A q /\ b = Mult a q)).

Theorem div_O_O : is_ring -> divide O O.

Theorem div_add :
 is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).

Theorem div_mult :
 is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).

Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).

Definition is_gcd (a b d : S) :=
  divide d a /\
  divide d b /\ (forall q : S, divide q a -> divide q b -> divide q d).

Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\ b = O.

Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.

Lemma simplification_integrity :
 is_unitary_commutative_ring ->
 integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.

Lemma gcd_unicity_apart_unities :
 is_unitary_commutative_ring ->
 integrity ->
 forall a b d1 d2 : S,
 is_gcd a b d1 ->
 is_gcd a b d2 ->
 exists x : S, inversible S Mult I x /\ A x /\ d2 = Mult d1 x.

Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.

End ring. *)
Require Export Nat_complements.
(* Nat_complements:
Require Import Arith.
Require Import Compare_dec.

Lemma eq_gt_O_dec : forall n : nat, {n = 0} + {n > 0}.

Lemma mult_commut : forall n m : nat, n * m = m * n.

Lemma mult_neutr : forall n : nat, 1 * n = n.

Lemma technical_lemma :
 forall y m : nat, S (y * m + (y + m) + m) = S y * m + (S y + m).

Lemma lt_minus2 : forall n m : nat, n < m -> 0 < m - n.

Lemma minus_n_Sm : forall n m : nat, m < n -> pred (n - m) = n - S m.

Lemma lt_succ : forall n m : nat, n <= S m -> {n <= m} + {n = S m}. *)
Require Export Zbase.
(* Zbase:
Inductive Z : Set :=
  | OZ : Z
  | pos : nat -> Z
  | neg : nat -> Z.

Definition IZ := pos 0.

Definition is_posn (x z : Z) :=
  match x, z with
  | pos n, pos m => n = m :>nat
  | _, _ => False
  end.

Lemma tech_pos_not_posZ : forall n m : nat, n <> m -> pos n <> pos m.

Lemma eq_OZ_dec : forall x : Z, {x = OZ} + {x <> OZ}.

Definition posOZ (n : nat) :=
  match n return Z with
  | O =>
        OZ
       
  | S n' => pos n'
  end.

Definition negOZ (n : nat) :=
  match n return Z with
  | O =>
        OZ
       
  | S n' => neg n'
  end.

Definition absZ (x : Z) :=
  match x return Z with
  | OZ =>
        OZ 
       
  | pos n => pos n
       
  | neg n => pos n
  end.

Definition sgnZ (x : Z) :=
  match x return Z with
  | OZ =>
        OZ
       
  | pos n => pos 0
       
  | neg n => neg 0
  end. *)
Require Export Z_succ_pred.
(* Z_succ_pred:
Require Export Arith.
Require Export Zbase.

Definition succZ (x : Z) :=
  match x return Z with
  | OZ =>
        IZ 
       
  | pos n => pos (S n)
       
  | neg n =>
      match n return Z with
      | O =>
            OZ
           
      | S m => neg m
      end
  end.

Definition predZ (x : Z) :=
  match x return Z with
  | OZ =>
        neg 0
       
  | pos n =>
      match n return Z with
      | O =>
            OZ
           
      | S m => pos m
      end
       
  | neg n => neg (S n)
  end.
    
Lemma pred_succZ : forall x : Z, predZ (succZ x) = x.

Lemma succ_predZ : forall x : Z, succZ (predZ x) = x.

Lemma succ_pred_pred_succZ : forall x : Z, succZ (predZ x) = predZ (succZ x).

Lemma tech_pred_posZ : forall n : nat, 0 < n -> predZ (pos n) = pos (pred n).

Lemma tech_succ_posOZ : forall n : nat, succZ (posOZ n) = pos n. *)
Require Export Zadd.
(* Zadd:
Require Export Arith.
Require Export Nat_complements.
Require Export Lci.
Require Export groups.
Require Export rings.
Require Export Zbase.
Require Export Z_succ_pred.

Fixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=
  match n with
  | O => succZ x2
  | S n0 => succZ (addpos x2 n0)
  end.

Fixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=
  match n with
  | O => predZ x2
  | S n0 => predZ (addneg x2 n0)
  end.

Definition addZ (x1 x2 : Z) :=
  match x1 with
  | OZ => x2
  | pos n => addpos x2 n
  | neg n => addneg x2 n
  end.

Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.

Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.

Lemma addZ_eq3 :
 forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).

Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.

Lemma addZ_eq5 :
 forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).

Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).

Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).

Lemma tech_add_pos_succZ :
 forall (x : nat) (y : Z), addZ (pos (S x)) y = succZ (addZ (pos x) y).
Proof addZ_eq3.

Lemma tech_add_neg_predZ :
 forall (x : nat) (y : Z), addZ (neg (S x)) y = predZ (addZ (neg x) y).
Proof addZ_eq5.

Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).

Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).

Lemma add_OZ : forall x : Z, addZ x OZ = x.

Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.

Lemma add_mIZ_predZ : forall x : Z, addZ x (neg 0) = predZ x.

Theorem addZ_commutativity : commutativity Z addZ.

Lemma tech_add_pos_neg_posZ :
 forall n1 n2 : nat, n2 < n1 -> addZ (pos n1) (neg n2) = pos (n1 - S n2).

Theorem addZ_associativity : associativity Z addZ.

Definition IdZ (x : Z) := True.

Theorem addZ_neutral : neutral Z IdZ addZ OZ.

Definition oppZ (x : Z) :=
  match x return Z with
  | OZ =>
        OZ
       
  | pos n => neg n
       
  | neg n => pos n
  end.

Lemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).

Lemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).

Lemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.

Lemma tech_add_neg_posZ : forall n : nat, addZ (neg n) (pos n) = OZ.

Lemma tech_add_pos_posZ :
 forall n m : nat, addZ (pos n) (pos m) = pos (S (n + m)).

Lemma tech_add_neg_negZ :
 forall n m : nat, addZ (neg n) (neg m) = neg (S (n + m)).

Theorem addZ_opposite : opposite Z IdZ addZ OZ oppZ.

Theorem Z_group : is_group Z IdZ addZ OZ oppZ.

Theorem abs_eq_or_oppZ : forall x : Z, {absZ x = x} + {absZ x = oppZ x}.

Lemma tech_opp_pos_negZ :
 forall n : nat, oppZ (pos n) = neg n /\ oppZ (neg n) = pos n. *)
Require Export Zmult.
(* Zmult:
Require Export Lci.
Require Export misc.
Require Export Arith.
Require Export Nat_complements.
Require Export groups.
Require Export rings.
Require Export Zbase.
Require Export Z_succ_pred.
Require Export Zadd.

Fixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=
  match n with
  | O => x2
  | S n0 => addZ (multpos x2 n0) x2
  end.

Fixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=
  match n with
  | O => oppZ x2
  | S n0 => addZ (multneg x2 n0) (oppZ x2)
  end. 

Definition multZ (x1 x2 : Z) :=
  match x1 with
  | OZ => OZ
  | pos n => multpos x2 n
  | neg n => multneg x2 n
  end.

Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.

Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.

Lemma multZ_eq3 :
 forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.

Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.

Lemma multZ_eq5 :
 forall (n1 : nat) (n : Z),
 multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).

Lemma tech_mult_posZ :
 forall (x : nat) (y : Z), multZ (pos (S x)) y = addZ (multZ (pos x) y) y.

Proof multZ_eq3.

Lemma tech_mult_negZ :
 forall (x : nat) (y : Z),
 multZ (neg (S x)) y = addZ (multZ (neg x) y) (oppZ y).

Proof multZ_eq5.

Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.

Lemma mult_predZ_l :
 forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).

Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.

Lemma mult_predZ_r :
 forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).

Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.

Lemma mult_IZ : forall x : Z, multZ x IZ = x.

Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.

Theorem multZ_commutativity : commutativity Z multZ.

Theorem multZ_neutral : neutral Z IdZ multZ IZ.

Theorem mult_add_distributivity : distributivity Z addZ multZ.

Lemma mult_oppZ_r : forall x y : Z, multZ x (oppZ y) = oppZ (multZ x y).

Lemma mult_oppZ_l : forall x y : Z, multZ (oppZ x) y = oppZ (multZ x y).

Lemma tech_multZ_negO : forall x : Z, multZ (neg 0) x = oppZ x.

Proof multZ_eq4.

Lemma tech_mult_pos_posZ :
 forall n m : nat, multZ (pos n) (pos m) = pos (n * m + (n + m)).

Lemma tech_mult_neg_negZ :
 forall n m : nat, multZ (neg n) (neg m) = pos (n * m + (n + m)).

Lemma tech_mult_pos_negZ :
 forall n m : nat, multZ (pos n) (neg m) = neg (n * m + (n + m)).

Lemma tech_mult_neg_posZ :
 forall n m : nat, multZ (neg n) (pos m) = neg (n * m + (n + m)).

Theorem multZ_associativity : associativity Z multZ.

Theorem Z_ring : is_ring Z IdZ addZ multZ OZ oppZ.

Theorem Z_unitary_commutative_ring :
 is_unitary_commutative_ring Z IdZ addZ multZ OZ IZ oppZ.

Lemma tech_integ_posZ :
 forall (n : nat) (x : Z), multZ (pos n) x = OZ -> x = OZ.

Lemma tech_integ_negZ :
 forall (n : nat) (x : Z), multZ (neg n) x = OZ -> x = OZ.

Theorem integrityZ : integrity Z multZ OZ.

Lemma tech_mult_pos_succZ :
 forall n m : nat, posOZ (S n * S m) = multZ (pos n) (pos m).

Lemma tech_mult_pos_succZ2 :
 forall n m : nat, multZ (pos n) (pos m) = pos (S n * m + n).

Lemma tech_div1 :
 forall n0 n q r : nat,
 S n0 = q * S n + r -> pos n0 = addZ (multZ (pos n) (posOZ q)) (posOZ r).

Lemma tech_div2 :
 forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (pos n) (negOZ q).

Lemma tech_div31 :
 forall n q : nat,
 addZ (oppZ (multZ (pos n) (pos q))) (pos n) = oppZ (multZ (pos n) (posOZ q)).

Lemma tech_div32 :
 forall n q r : nat, S n > r -> pos (n - r) = addZ (pos n) (oppZ (posOZ r)).

Lemma tech_div3 :
 forall n0 n q r : nat,
 S n0 = q * S n + r ->
 S n > r -> neg n0 = addZ (multZ (pos n) (neg q)) (pos (n - r)).

Lemma tech_div4 :
 forall n0 n q r : nat,
 S n0 = q * S n + r -> pos n0 = addZ (multZ (neg n) (negOZ q)) (posOZ r).

Lemma tech_div5 :
 forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (neg n) (posOZ q).

Lemma tech_div6 :
 forall n0 n q r : nat,
 S n0 = q * S n + r ->
 S n > r -> neg n0 = addZ (multZ (neg n) (pos q)) (pos (n - r)).

Lemma inversibleZ :
 forall x : Z, inversible Z multZ IZ x -> x = IZ \/ x = oppZ IZ.

Lemma sgn_abs : forall x : Z, multZ x (sgnZ x) = absZ x. *)
Require Export Zle.
(* Zle:
Require Export Arith.
Require Export misc.
Require Export groups.
Require Export Zbase.
Require Export Z_succ_pred.
Require Export Zadd.

Definition leZ (x y : Z) :=
  match x return Prop with
  | OZ =>
      match y return Prop with
      | OZ => True
      | pos n => True
      | neg n => False
      end
  | pos n =>
      match y return Prop with
      | OZ => False
      | pos m => n <= m
      | neg m => False
      end
  | neg n =>
      match y return Prop with
      | OZ => True
      | pos m => True
      | neg m => m <= n
      end
  end.

Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).

Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.

Theorem leZ_antisymmetric : antisym Z leZ.

Definition ltZ (x y : Z) := leZ (succZ x) y.

Definition lt_absZ (x y : Z) := ltZ (absZ x) (absZ y).

Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.

Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).

Lemma le_opp_OZ_l : forall x : Z, leZ OZ x -> leZ (oppZ x) OZ.

Lemma le_opp_OZ :
 forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = OZ.

Lemma le_opp_OZ2 :
 forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = y. *)
Require Export Euclid.
Require Export Peano_dec.
Require Export Zdiv.
(* Zdiv:
Require Export Zbase.
Require Export Zadd.
Require Export Zmult.
Require Export Zle.
Require Export Euclid.

Unset Standard Proposition Elimination Names.

Definition is_diveuclZ (a b q r : Z) :=
  b <> OZ /\ leZ OZ r /\ ltZ r (absZ b) /\ a = addZ (multZ b q) r.

Inductive diveuclZ (a b : Z) : Set :=
    divexZ : forall q r : Z, is_diveuclZ a b q r -> diveuclZ a b.

Lemma divZ : forall a b : Z, b <> OZ -> diveuclZ a b. *)
Require Export Zrec.
(* Zrec:
Require Export Arith.
Require Export Nat_complements.
Require Export misc.
Require Export Zbase.
Require Export Zle.

Lemma lt_OZ : forall m : Z, ~ ltZ (absZ m) OZ.

Lemma Zrec1 :
 forall P : Z -> Set,
 (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> P OZ.

Inductive and_set_set_set (S1 S2 : Set) : Set :=
    and_set_set_set_i : S2 -> S1 -> and_set_set_set S1 S2.

Definition and_recZ (p : nat) (P : Z -> Set) :=
  forall n : nat, n <= p -> and_set_set_set (P (pos n)) (P (neg n)).

Lemma Zrec2 :
 forall P : Z -> Set,
 (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ 0 P.

Lemma Zrec3 :
 forall (P : Z -> Set) (p : nat),
 (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) ->
 and_recZ p P -> and_recZ (S p) P.

Theorem Zrec4 :
 forall P : Z -> Set,
 (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) ->
 forall p : nat, and_recZ p P.

Theorem recZ :
 forall P : Z -> Set,
 (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) ->
 forall p : Z, P p. *)
Require Export Zgcd.
(* Zgcd:
Require Export misc.
Require Export Zadd.
Require Export Zle.
Require Export Euclid.
Require Export Peano_dec.
Require Export Zrec.
Require Export Zmult.
Require Export Zdiv.

Unset Standard Proposition Elimination Names.

Lemma gcd_unicity_apart_sign :
 forall a b d1 d2 : Z,
 is_gcd Z IdZ multZ OZ a b d1 ->
 is_gcd Z IdZ multZ OZ a b d2 -> d2 = d1 \/ d2 = oppZ d1.

Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ multZ OZ OZ b (absZ b).

Inductive is_gcdZ : Z -> Z -> Z -> Prop :=
  | gcd_OZ : forall b : Z, is_gcdZ OZ b (absZ b)
  | gcd_mod :
      forall b a d q r : Z,
      b <> OZ -> is_diveuclZ a b q r -> is_gcdZ r b d -> is_gcdZ b a d.

Definition have_gcdZ (a b : Z) := {d : Z | is_gcdZ a b d}.

Definition gcdZ_i (a b : Z) := exist (is_gcdZ a b).

Definition P (a : Z) := forall b : Z, have_gcdZ a b.

Lemma acc_P : forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n.

Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.

Lemma gcdZ_is_gcd :
 forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ multZ OZ a b d.

Definition gcdZ (a b : Z) := pi1 Z (is_gcdZ a b) (gcdZ_exists a b).

Theorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).
Proof fun a b : Z => pi2 Z (is_gcdZ a b) (gcdZ_exists a b).

Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> leZ OZ d.

Lemma unicity_is_gcdZ :
 forall a b d1 d2 : Z, is_gcdZ a b d1 -> is_gcdZ a b d2 -> d2 = d1.

Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.

Lemma gcd_modZ :
 forall a b q r : Z, b <> OZ -> is_diveuclZ a b q r -> gcdZ r b = gcdZ b a. 

Inductive verify_BezoutZ (a b : Z) : Set :=
    Bezout_i :
      forall u v : Z,
      addZ (multZ a u) (multZ b v) = gcdZ a b -> verify_BezoutZ a b.

Definition Q (a : Z) := forall b : Z, verify_BezoutZ a b.

Lemma acc_Q : forall n : Z, (forall m : Z, lt_absZ m n -> Q m) -> Q n.

Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.

Definition congruentZ (x y n : Z) :=
  divide Z IdZ multZ OZ n (addZ x (oppZ y)).

Lemma divide_selfZ : forall x : Z, divide Z IdZ multZ OZ x x.

Theorem chinese_remaindering_theorem :
 forall a b x y : Z,
 gcdZ a b = IZ -> {z : Z | congruentZ z x a /\ congruentZ z y b}. *)
