
Require Export Arith.
Require Export Nat_complements.
(* Nat_complements:
Require Import Arith.
Require Import Compare_dec.

Lemma eq_gt_O_dec : forall n : nat, {n = 0} + {n > 0}.

Lemma mult_commut : forall n m : nat, n * m = m * n.

Lemma mult_neutr : forall n : nat, 1 * n = n.

Lemma technical_lemma :
 forall y m : nat, S (y * m + (y + m) + m) = S y * m + (S y + m).

Lemma lt_minus2 : forall n m : nat, n < m -> 0 < m - n.

Lemma minus_n_Sm : forall n m : nat, m < n -> pred (n - m) = n - S m.

Lemma lt_succ : forall n m : nat, n <= S m -> {n <= m} + {n = S m}. *)
Require Export Lci.
(* Lci:
Section Internal.

Variable S : Set.
Variable G : S -> Prop.
Variable Add : S -> S -> S.
Variable O I : S.
Variable Opp Inv : S -> S.

Definition intern := forall x y : S, G x -> G y -> G (Add x y).

Definition commutativity := forall x y : S, Add x y = Add y x.

Definition associativity :=
  forall x y z : S, Add x (Add y z) = Add (Add x y) z :>S.

Definition neutral (S : Set) (G : S -> Prop) (Add : S -> S -> S) 
  (O : S) := G O /\ (forall x : S, G x -> Add x O = x /\ Add O x = x).

Lemma neutral_add : neutral S G Add O -> O = Add O O.

Definition is_opposite (x y : S) := G x /\ G y /\ Add x y = O /\ Add y x = O.

Lemma opp_com :
 commutativity ->
 forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.

Definition opposite := forall x : S, G x -> is_opposite x (Opp x).

Definition distributivity (S : Set) (Add Mult : S -> S -> S) :=
  forall x y z : S,
  Mult (Add x y) z = Add (Mult x z) (Mult y z) /\
  Mult x (Add y z) = Add (Mult x y) (Mult x z).

End Internal. *)
Require Export groups.
(* groups:
Require Export Lci.
Require Export misc.

Section groups.

Variable S : Set.
Variable G : S -> Prop.
Variable Add : S -> S -> S.
Variable O : S.
Variable Opp : S -> S.

Definition is_group :=
  intern S G Add /\
  associativity S Add /\ neutral S G Add O /\ opposite S G Add O Opp. 

Lemma regular_l :
 is_group ->
 forall y z : S,
 G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.

Lemma add_add :
 commutativity S Add ->
 associativity S Add ->
 forall x1 y1 x2 y2 : S,
 Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).

Lemma opp_unicity :
 is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.

Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).

Lemma opp_add :
 is_group ->
 commutativity S Add ->
 forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).

Lemma opp_neutral : is_group -> Opp O = O.

End groups. *)
Require Export rings.
(* rings:
Require Export Lci.
Require Export misc.
Require Export groups.
Require Export Compare_dec.

Section ring.

Variable S : Set.
Variable A : S -> Prop.
Variable Add Mult : S -> S -> S.
Variable O I : S.
Variable Opp : S -> S.
Variable v : S -> nat.

Definition is_ring :=
  commutativity S Add /\
  is_group S A Add O Opp /\
  intern S A Mult /\ associativity S Mult /\ distributivity S Add Mult.

Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\ Mult O x = O.

Lemma mult_opp_r :
 is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).

Lemma mult_opp_l :
 is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).

Lemma mult_opp_opp :
 is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.

Definition integrity := forall a b : S, Mult a b = O -> {a = O} + {b = O}.

Definition is_unitary_commutative_ring :=
  is_ring /\ commutativity S Mult /\ neutral S A Mult I.

Definition divide (a b : S) :=
  A a /\ A b /\ (b = O \/ a <> O /\ (exists q : S, A q /\ b = Mult a q)).

Theorem div_O_O : is_ring -> divide O O.

Theorem div_add :
 is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).

Theorem div_mult :
 is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).

Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).

Definition is_gcd (a b d : S) :=
  divide d a /\
  divide d b /\ (forall q : S, divide q a -> divide q b -> divide q d).

Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\ b = O.

Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.

Lemma simplification_integrity :
 is_unitary_commutative_ring ->
 integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.

Lemma gcd_unicity_apart_unities :
 is_unitary_commutative_ring ->
 integrity ->
 forall a b d1 d2 : S,
 is_gcd a b d1 ->
 is_gcd a b d2 ->
 exists x : S, inversible S Mult I x /\ A x /\ d2 = Mult d1 x.

Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.

End ring. *)
Require Export Zbase.
(* Zbase:
Inductive Z : Set :=
  | OZ : Z
  | pos : nat -> Z
  | neg : nat -> Z.

Definition IZ := pos 0.

Definition is_posn (x z : Z) :=
  match x, z with
  | pos n, pos m => n = m :>nat
  | _, _ => False
  end.

Lemma tech_pos_not_posZ : forall n m : nat, n <> m -> pos n <> pos m.

Lemma eq_OZ_dec : forall x : Z, {x = OZ} + {x <> OZ}.

Definition posOZ (n : nat) :=
  match n return Z with
  | O =>
        OZ
       
  | S n' => pos n'
  end.

Definition negOZ (n : nat) :=
  match n return Z with
  | O =>
        OZ
       
  | S n' => neg n'
  end.

Definition absZ (x : Z) :=
  match x return Z with
  | OZ =>
        OZ 
       
  | pos n => pos n
       
  | neg n => pos n
  end.

Definition sgnZ (x : Z) :=
  match x return Z with
  | OZ =>
        OZ
       
  | pos n => pos 0
       
  | neg n => neg 0
  end. *)
Require Export Z_succ_pred.
(* Z_succ_pred:
Require Export Arith.
Require Export Zbase.

Definition succZ (x : Z) :=
  match x return Z with
  | OZ =>
        IZ 
       
  | pos n => pos (S n)
       
  | neg n =>
      match n return Z with
      | O =>
            OZ
           
      | S m => neg m
      end
  end.

Definition predZ (x : Z) :=
  match x return Z with
  | OZ =>
        neg 0
       
  | pos n =>
      match n return Z with
      | O =>
            OZ
           
      | S m => pos m
      end
       
  | neg n => neg (S n)
  end.
    
Lemma pred_succZ : forall x : Z, predZ (succZ x) = x.

Lemma succ_predZ : forall x : Z, succZ (predZ x) = x.

Lemma succ_pred_pred_succZ : forall x : Z, succZ (predZ x) = predZ (succZ x).

Lemma tech_pred_posZ : forall n : nat, 0 < n -> predZ (pos n) = pos (pred n).

Lemma tech_succ_posOZ : forall n : nat, succZ (posOZ n) = pos n. *)

Fixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=
  match n with
  | O => succZ x2
  | S n0 => succZ (addpos x2 n0)
  end.

Fixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=
  match n with
  | O => predZ x2
  | S n0 => predZ (addneg x2 n0)
  end.

Definition addZ (x1 x2 : Z) :=
  match x1 with
  | OZ => x2
  | pos n => addpos x2 n
  | neg n => addneg x2 n
  end.

Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.
Proof.
auto with arith.
Qed.

Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.
Proof.
auto with arith.
Qed.

Lemma addZ_eq3 :
 forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).
Proof.
auto with arith.
Qed.

Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.
Proof.
auto with arith.
Qed.

Lemma addZ_eq5 :
 forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).
Proof.
auto with arith.
Qed.

Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).

intros; elim x.

reflexivity.

trivial.

simple destruct n.

simpl in |- *; symmetry  in |- *; exact (succ_predZ y). 

intros; symmetry  in |- *; rewrite addZ_eq5.
apply succ_predZ.
Qed.

Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).

intros; elim x.

reflexivity.

simple destruct n.
simpl in |- *; rewrite pred_succZ; trivial.
intros; rewrite addZ_eq3; rewrite pred_succZ; trivial.
trivial.
Qed.

Lemma tech_add_pos_succZ :
 forall (x : nat) (y : Z), addZ (pos (S x)) y = succZ (addZ (pos x) y).
Proof addZ_eq3.

Lemma tech_add_neg_predZ :
 forall (x : nat) (y : Z), addZ (neg (S x)) y = predZ (addZ (neg x) y).
Proof addZ_eq5.

Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).

intros; elim x.

reflexivity.

simple induction n.

reflexivity.

intros.
do 2 rewrite (tech_add_pos_succZ n0).
elim H; reflexivity.

simple induction n.

simpl in |- *; symmetry  in |- *; apply succ_pred_pred_succZ.

intros.
do 2 rewrite (tech_add_neg_predZ n0).
rewrite H.
symmetry  in |- *; apply succ_pred_pred_succZ.
Qed.

Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).

intros; elim x.

reflexivity.

simple induction n.

simpl in |- *; apply succ_pred_pred_succZ.

intros.
do 2 rewrite (tech_add_pos_succZ n0).
rewrite H; apply succ_pred_pred_succZ.

simple induction n.

reflexivity.

intros.
do 2 rewrite (tech_add_neg_predZ n0).
elim H; reflexivity.
Qed.

Lemma add_OZ : forall x : Z, addZ x OZ = x.

simple induction x.

reflexivity.

simple induction n.
reflexivity.
intros; rewrite tech_add_pos_succZ; rewrite H; reflexivity.

simple induction n.
reflexivity.
intros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.
Qed.

Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.

intros.
cut (succZ OZ = IZ); intros. elim H.
rewrite (succ_addZ_r x OZ); rewrite (add_OZ x); reflexivity.
reflexivity.
Qed.

Lemma add_mIZ_predZ : forall x : Z, addZ x (neg 0) = predZ x.

intros.
cut (predZ OZ = neg 0); intros. elim H.
rewrite (pred_addZ_r x OZ); rewrite (add_OZ x); reflexivity.
reflexivity.
Qed.

Theorem addZ_commutativity : commutativity Z addZ.

unfold commutativity in |- *; intros; elim x.

simpl in |- *; symmetry  in |- *; exact (add_OZ y).

simple induction n.

simpl in |- *; symmetry  in |- *; exact (add_IZ_succZ y).

intros; rewrite (tech_add_pos_succZ n0 y). rewrite H.
cut (succZ (pos n0) = pos (S n0)); intros. elim H0.
rewrite (succ_addZ_r y (pos n0)); reflexivity.
reflexivity.

simple induction n.

simpl in |- *; symmetry  in |- *; exact (add_mIZ_predZ y).

intros; rewrite (tech_add_neg_predZ n0 y). rewrite H.
cut (predZ (neg n0) = neg (S n0)); intros. elim H0.
rewrite (pred_addZ_r y (neg n0)); reflexivity.
reflexivity.
Qed.

Lemma tech_add_pos_neg_posZ :
 forall n1 n2 : nat, n2 < n1 -> addZ (pos n1) (neg n2) = pos (n1 - S n2).

simple induction n2.

intros; elim (addZ_commutativity (neg 0) (pos n1)).
rewrite addZ_eq4.
elim minus_n_Sm; trivial.
elim minus_n_O.
apply tech_pred_posZ; trivial.

intros; elim (addZ_commutativity (neg (S n)) (pos n1)).
rewrite tech_add_neg_predZ.
elim (addZ_commutativity (pos n1) (neg n)).
rewrite H; auto with arith.
elim (minus_n_Sm n1 (S n) H0).
apply tech_pred_posZ.
apply lt_minus2; trivial.
Qed.

Theorem addZ_associativity : associativity Z addZ.

unfold associativity in |- *; intros; elim x.

unfold addZ in |- *; reflexivity.

intros; elim n.

simpl in |- *; symmetry  in |- *; exact (succ_addZ_l y z).

intros.
do 2 rewrite (tech_add_pos_succZ n0).
rewrite (succ_addZ_l (addZ (pos n0) y) z); elim H; reflexivity.

simple induction n.

simpl in |- *; symmetry  in |- *; exact (pred_addZ_l y z).

intros.
do 2 rewrite (tech_add_neg_predZ n0).
rewrite (pred_addZ_l (addZ (neg n0) y) z); elim H; reflexivity.
Qed.

Definition IdZ (x : Z) := True.

Theorem addZ_neutral : neutral Z IdZ addZ OZ.

unfold neutral in |- *; intros.
split. exact I.
intros. split. exact (add_OZ x). unfold addZ in |- *; reflexivity.
Qed.

Definition oppZ (x : Z) :=
  match x return Z with
  | OZ =>
        OZ
       
  | pos n => neg n
       
  | neg n => pos n
  end.

Lemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).

simple destruct x.

reflexivity.

intros; reflexivity.

simple destruct n; intros; reflexivity. 
Qed.

Lemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).

simple destruct x.

reflexivity.

simple destruct n; intros; reflexivity. 

intros; reflexivity.
Qed.

Lemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.

simple induction n.

reflexivity.

intros; rewrite (tech_add_pos_succZ n0).
elim succ_addZ_r; exact H.
Qed.

Lemma tech_add_neg_posZ : forall n : nat, addZ (neg n) (pos n) = OZ.

intros; elim (addZ_commutativity (pos n) (neg n));
 exact (tech_add_pos_negZ n).
Qed.

Lemma tech_add_pos_posZ :
 forall n m : nat, addZ (pos n) (pos m) = pos (S (n + m)).

intros; elim n.

reflexivity.

intros; rewrite (tech_add_pos_succZ n0 (pos m)); rewrite H; reflexivity.
Qed.

Lemma tech_add_neg_negZ :
 forall n m : nat, addZ (neg n) (neg m) = neg (S (n + m)).

simple induction n.

reflexivity.

intros; rewrite (tech_add_neg_predZ n0 (neg m)); rewrite H; reflexivity.
Qed.

Theorem addZ_opposite : opposite Z IdZ addZ OZ oppZ.

repeat split; trivial.

case x.

reflexivity.

intros; exact (tech_add_pos_negZ n).

intros; exact (tech_add_neg_posZ n).

case x.

reflexivity.

intros; exact (tech_add_neg_posZ n).

intros; exact (tech_add_pos_negZ n).
Qed.

Theorem Z_group : is_group Z IdZ addZ OZ oppZ.

split.
red in |- *; trivial.
split. exact addZ_associativity.
split. exact addZ_neutral.
exact addZ_opposite.
Qed.

Theorem abs_eq_or_oppZ : forall x : Z, {absZ x = x} + {absZ x = oppZ x}.

simple destruct x; auto with arith.
Qed.

Lemma tech_opp_pos_negZ :
 forall n : nat, oppZ (pos n) = neg n /\ oppZ (neg n) = pos n.

simple induction n; auto with arith.
Qed.