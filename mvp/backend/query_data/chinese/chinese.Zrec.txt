
Require Export Arith.
Require Export Nat_complements.
(* Nat_complements:
Require Import Arith.
Require Import Compare_dec.

Lemma eq_gt_O_dec : forall n : nat, {n = 0} + {n > 0}.

Lemma mult_commut : forall n m : nat, n * m = m * n.

Lemma mult_neutr : forall n : nat, 1 * n = n.

Lemma technical_lemma :
 forall y m : nat, S (y * m + (y + m) + m) = S y * m + (S y + m).

Lemma lt_minus2 : forall n m : nat, n < m -> 0 < m - n.

Lemma minus_n_Sm : forall n m : nat, m < n -> pred (n - m) = n - S m.

Lemma lt_succ : forall n m : nat, n <= S m -> {n <= m} + {n = S m}. *)
Require Export misc.
(* misc:
Require Export Lci.

Definition antisym (A : Set) (R : A -> A -> Prop) :=
  forall x y : A, R x y -> R y x -> x = y :>A.

Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.

Lemma pi2 :
 forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).

Definition inversible (S : Set) (Mult : S -> S -> S) 
  (I x : S) := exists y : S, Mult x y = I /\ Mult y x = I.

Lemma inv_com :
 forall (S : Set) (Mult : S -> S -> S) (I x : S),
 commutativity S Mult ->
 (exists y : S, Mult x y = I) -> inversible S Mult I x. *)
Require Export Zbase.
(* Zbase:
Inductive Z : Set :=
  | OZ : Z
  | pos : nat -> Z
  | neg : nat -> Z.

Definition IZ := pos 0.

Definition is_posn (x z : Z) :=
  match x, z with
  | pos n, pos m => n = m :>nat
  | _, _ => False
  end.

Lemma tech_pos_not_posZ : forall n m : nat, n <> m -> pos n <> pos m.

Lemma eq_OZ_dec : forall x : Z, {x = OZ} + {x <> OZ}.

Definition posOZ (n : nat) :=
  match n return Z with
  | O =>
        OZ
       
  | S n' => pos n'
  end.

Definition negOZ (n : nat) :=
  match n return Z with
  | O =>
        OZ
       
  | S n' => neg n'
  end.

Definition absZ (x : Z) :=
  match x return Z with
  | OZ =>
        OZ 
       
  | pos n => pos n
       
  | neg n => pos n
  end.

Definition sgnZ (x : Z) :=
  match x return Z with
  | OZ =>
        OZ
       
  | pos n => pos 0
       
  | neg n => neg 0
  end. *)
Require Export Zle.
(* Zle:
Require Export Arith.
Require Export misc.
Require Export groups.
Require Export Zbase.
Require Export Z_succ_pred.
Require Export Zadd.

Definition leZ (x y : Z) :=
  match x return Prop with
  | OZ =>
      match y return Prop with
      | OZ => True
      | pos n => True
      | neg n => False
      end
  | pos n =>
      match y return Prop with
      | OZ => False
      | pos m => n <= m
      | neg m => False
      end
  | neg n =>
      match y return Prop with
      | OZ => True
      | pos m => True
      | neg m => m <= n
      end
  end.

Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).

Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.

Theorem leZ_antisymmetric : antisym Z leZ.

Definition ltZ (x y : Z) := leZ (succZ x) y.

Definition lt_absZ (x y : Z) := ltZ (absZ x) (absZ y).

Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.

Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).

Lemma le_opp_OZ_l : forall x : Z, leZ OZ x -> leZ (oppZ x) OZ.

Lemma le_opp_OZ :
 forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = OZ.

Lemma le_opp_OZ2 :
 forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = y. *)

Lemma lt_OZ : forall m : Z, ~ ltZ (absZ m) OZ.

intros; unfold ltZ in |- *; elim m.
unfold not in |- *; simpl in |- *; intros; exact H.
unfold not in |- *; simpl in |- *; intros; exact H.
unfold not in |- *; simpl in |- *; intros; exact H.
Qed.

Lemma Zrec1 :
 forall P : Z -> Set,
 (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> P OZ.

intros; apply (H OZ); intros.
unfold lt_absZ in H0; unfold absZ at 2 in H0; elim (lt_OZ m); assumption.
Qed.

Inductive and_set_set_set (S1 S2 : Set) : Set :=
    and_set_set_set_i : S2 -> S1 -> and_set_set_set S1 S2.

Definition and_recZ (p : nat) (P : Z -> Set) :=
  forall n : nat, n <= p -> and_set_set_set (P (pos n)) (P (neg n)).

Lemma Zrec2 :
 forall P : Z -> Set,
 (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ 0 P.

unfold and_recZ in |- *; intros; apply and_set_set_set_i.

elim (le_n_O_eq n H0). apply (H (neg 0)); intros.
rewrite (tech_lt_abs_OZ m). apply (Zrec1 P H). exact H1.

elim (le_n_O_eq n H0). apply (H (pos 0)); intros.
rewrite (tech_lt_abs_OZ m). apply (Zrec1 P H). exact H1.
Qed.

Lemma Zrec3 :
 forall (P : Z -> Set) (p : nat),
 (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) ->
 and_recZ p P -> and_recZ (S p) P.

split.

elim (lt_succ n p H1); intros. elim (H0 n a); intros; trivial with arith.
rewrite b. apply (H (neg (S p))).
simple destruct m. intros; apply (Zrec1 P H).
unfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;
 unfold leZ in |- *; intros.
elim (H0 n0); auto with arith.
unfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;
 unfold leZ in |- *; intros.
elim (H0 n0); auto with arith.

elim (lt_succ n p H1); intros. elim (H0 n); intros; trivial with arith.
rewrite b. apply (H (pos (S p))).
simple destruct m. intros; apply (Zrec1 P H).
unfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;
 unfold leZ in |- *; intros.
elim (H0 n0); auto with arith.
unfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;
 unfold leZ in |- *; intros.
elim (H0 n0); auto with arith.
Qed.

Theorem Zrec4 :
 forall P : Z -> Set,
 (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) ->
 forall p : nat, and_recZ p P.

intros; elim p. 
exact (Zrec2 P H). 
intros; apply Zrec3; trivial with arith.
Qed.

Theorem recZ :
 forall P : Z -> Set,
 (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) ->
 forall p : Z, P p.

intros; elim p.

exact (Zrec1 P H).

intro n; cut (and_recZ n P). intros.
elim (H0 n); auto with arith.
apply Zrec4; trivial with arith.

intro n; cut (and_recZ n P). intros.
elim (H0 n); auto with arith.
apply Zrec4; trivial with arith.
Qed.