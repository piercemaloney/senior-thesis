
Require Export Zbase.
(* Zbase:
Inductive Z : Set :=
  | OZ : Z
  | pos : nat -> Z
  | neg : nat -> Z.

Definition IZ := pos 0.

Definition is_posn (x z : Z) :=
  match x, z with
  | pos n, pos m => n = m :>nat
  | _, _ => False
  end.

Lemma tech_pos_not_posZ : forall n m : nat, n <> m -> pos n <> pos m.

Lemma eq_OZ_dec : forall x : Z, {x = OZ} + {x <> OZ}.

Definition posOZ (n : nat) :=
  match n return Z with
  | O =>
        OZ
       
  | S n' => pos n'
  end.

Definition negOZ (n : nat) :=
  match n return Z with
  | O =>
        OZ
       
  | S n' => neg n'
  end.

Definition absZ (x : Z) :=
  match x return Z with
  | OZ =>
        OZ 
       
  | pos n => pos n
       
  | neg n => pos n
  end.

Definition sgnZ (x : Z) :=
  match x return Z with
  | OZ =>
        OZ
       
  | pos n => pos 0
       
  | neg n => neg 0
  end. *)
Require Export Zadd.
(* Zadd:
Require Export Arith.
Require Export Nat_complements.
Require Export Lci.
Require Export groups.
Require Export rings.
Require Export Zbase.
Require Export Z_succ_pred.

Fixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=
  match n with
  | O => succZ x2
  | S n0 => succZ (addpos x2 n0)
  end.

Fixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=
  match n with
  | O => predZ x2
  | S n0 => predZ (addneg x2 n0)
  end.

Definition addZ (x1 x2 : Z) :=
  match x1 with
  | OZ => x2
  | pos n => addpos x2 n
  | neg n => addneg x2 n
  end.

Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.

Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.

Lemma addZ_eq3 :
 forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).

Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.

Lemma addZ_eq5 :
 forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).

Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).

Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).

Lemma tech_add_pos_succZ :
 forall (x : nat) (y : Z), addZ (pos (S x)) y = succZ (addZ (pos x) y).
Proof addZ_eq3.

Lemma tech_add_neg_predZ :
 forall (x : nat) (y : Z), addZ (neg (S x)) y = predZ (addZ (neg x) y).
Proof addZ_eq5.

Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).

Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).

Lemma add_OZ : forall x : Z, addZ x OZ = x.

Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.

Lemma add_mIZ_predZ : forall x : Z, addZ x (neg 0) = predZ x.

Theorem addZ_commutativity : commutativity Z addZ.

Lemma tech_add_pos_neg_posZ :
 forall n1 n2 : nat, n2 < n1 -> addZ (pos n1) (neg n2) = pos (n1 - S n2).

Theorem addZ_associativity : associativity Z addZ.

Definition IdZ (x : Z) := True.

Theorem addZ_neutral : neutral Z IdZ addZ OZ.

Definition oppZ (x : Z) :=
  match x return Z with
  | OZ =>
        OZ
       
  | pos n => neg n
       
  | neg n => pos n
  end.

Lemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).

Lemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).

Lemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.

Lemma tech_add_neg_posZ : forall n : nat, addZ (neg n) (pos n) = OZ.

Lemma tech_add_pos_posZ :
 forall n m : nat, addZ (pos n) (pos m) = pos (S (n + m)).

Lemma tech_add_neg_negZ :
 forall n m : nat, addZ (neg n) (neg m) = neg (S (n + m)).

Theorem addZ_opposite : opposite Z IdZ addZ OZ oppZ.

Theorem Z_group : is_group Z IdZ addZ OZ oppZ.

Theorem abs_eq_or_oppZ : forall x : Z, {absZ x = x} + {absZ x = oppZ x}.

Lemma tech_opp_pos_negZ :
 forall n : nat, oppZ (pos n) = neg n /\ oppZ (neg n) = pos n. *)
Require Export Zmult.
(* Zmult:
Require Export Lci.
Require Export misc.
Require Export Arith.
Require Export Nat_complements.
Require Export groups.
Require Export rings.
Require Export Zbase.
Require Export Z_succ_pred.
Require Export Zadd.

Fixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=
  match n with
  | O => x2
  | S n0 => addZ (multpos x2 n0) x2
  end.

Fixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=
  match n with
  | O => oppZ x2
  | S n0 => addZ (multneg x2 n0) (oppZ x2)
  end. 

Definition multZ (x1 x2 : Z) :=
  match x1 with
  | OZ => OZ
  | pos n => multpos x2 n
  | neg n => multneg x2 n
  end.

Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.

Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.

Lemma multZ_eq3 :
 forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.

Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.

Lemma multZ_eq5 :
 forall (n1 : nat) (n : Z),
 multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).

Lemma tech_mult_posZ :
 forall (x : nat) (y : Z), multZ (pos (S x)) y = addZ (multZ (pos x) y) y.

Proof multZ_eq3.

Lemma tech_mult_negZ :
 forall (x : nat) (y : Z),
 multZ (neg (S x)) y = addZ (multZ (neg x) y) (oppZ y).

Proof multZ_eq5.

Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.

Lemma mult_predZ_l :
 forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).

Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.

Lemma mult_predZ_r :
 forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).

Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.

Lemma mult_IZ : forall x : Z, multZ x IZ = x.

Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.

Theorem multZ_commutativity : commutativity Z multZ.

Theorem multZ_neutral : neutral Z IdZ multZ IZ.

Theorem mult_add_distributivity : distributivity Z addZ multZ.

Lemma mult_oppZ_r : forall x y : Z, multZ x (oppZ y) = oppZ (multZ x y).

Lemma mult_oppZ_l : forall x y : Z, multZ (oppZ x) y = oppZ (multZ x y).

Lemma tech_multZ_negO : forall x : Z, multZ (neg 0) x = oppZ x.

Proof multZ_eq4.

Lemma tech_mult_pos_posZ :
 forall n m : nat, multZ (pos n) (pos m) = pos (n * m + (n + m)).

Lemma tech_mult_neg_negZ :
 forall n m : nat, multZ (neg n) (neg m) = pos (n * m + (n + m)).

Lemma tech_mult_pos_negZ :
 forall n m : nat, multZ (pos n) (neg m) = neg (n * m + (n + m)).

Lemma tech_mult_neg_posZ :
 forall n m : nat, multZ (neg n) (pos m) = neg (n * m + (n + m)).

Theorem multZ_associativity : associativity Z multZ.

Theorem Z_ring : is_ring Z IdZ addZ multZ OZ oppZ.

Theorem Z_unitary_commutative_ring :
 is_unitary_commutative_ring Z IdZ addZ multZ OZ IZ oppZ.

Lemma tech_integ_posZ :
 forall (n : nat) (x : Z), multZ (pos n) x = OZ -> x = OZ.

Lemma tech_integ_negZ :
 forall (n : nat) (x : Z), multZ (neg n) x = OZ -> x = OZ.

Theorem integrityZ : integrity Z multZ OZ.

Lemma tech_mult_pos_succZ :
 forall n m : nat, posOZ (S n * S m) = multZ (pos n) (pos m).

Lemma tech_mult_pos_succZ2 :
 forall n m : nat, multZ (pos n) (pos m) = pos (S n * m + n).

Lemma tech_div1 :
 forall n0 n q r : nat,
 S n0 = q * S n + r -> pos n0 = addZ (multZ (pos n) (posOZ q)) (posOZ r).

Lemma tech_div2 :
 forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (pos n) (negOZ q).

Lemma tech_div31 :
 forall n q : nat,
 addZ (oppZ (multZ (pos n) (pos q))) (pos n) = oppZ (multZ (pos n) (posOZ q)).

Lemma tech_div32 :
 forall n q r : nat, S n > r -> pos (n - r) = addZ (pos n) (oppZ (posOZ r)).

Lemma tech_div3 :
 forall n0 n q r : nat,
 S n0 = q * S n + r ->
 S n > r -> neg n0 = addZ (multZ (pos n) (neg q)) (pos (n - r)).

Lemma tech_div4 :
 forall n0 n q r : nat,
 S n0 = q * S n + r -> pos n0 = addZ (multZ (neg n) (negOZ q)) (posOZ r).

Lemma tech_div5 :
 forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (neg n) (posOZ q).

Lemma tech_div6 :
 forall n0 n q r : nat,
 S n0 = q * S n + r ->
 S n > r -> neg n0 = addZ (multZ (neg n) (pos q)) (pos (n - r)).

Lemma inversibleZ :
 forall x : Z, inversible Z multZ IZ x -> x = IZ \/ x = oppZ IZ.

Lemma sgn_abs : forall x : Z, multZ x (sgnZ x) = absZ x. *)
Require Export Zle.
(* Zle:
Require Export Arith.
Require Export misc.
Require Export groups.
Require Export Zbase.
Require Export Z_succ_pred.
Require Export Zadd.

Definition leZ (x y : Z) :=
  match x return Prop with
  | OZ =>
      match y return Prop with
      | OZ => True
      | pos n => True
      | neg n => False
      end
  | pos n =>
      match y return Prop with
      | OZ => False
      | pos m => n <= m
      | neg m => False
      end
  | neg n =>
      match y return Prop with
      | OZ => True
      | pos m => True
      | neg m => m <= n
      end
  end.

Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).

Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.

Theorem leZ_antisymmetric : antisym Z leZ.

Definition ltZ (x y : Z) := leZ (succZ x) y.

Definition lt_absZ (x y : Z) := ltZ (absZ x) (absZ y).

Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.

Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).

Lemma le_opp_OZ_l : forall x : Z, leZ OZ x -> leZ (oppZ x) OZ.

Lemma le_opp_OZ :
 forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = OZ.

Lemma le_opp_OZ2 :
 forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = y. *)
Require Export Euclid.

Unset Standard Proposition Elimination Names.

Definition is_diveuclZ (a b q r : Z) :=
  b <> OZ /\ leZ OZ r /\ ltZ r (absZ b) /\ a = addZ (multZ b q) r.

Inductive diveuclZ (a b : Z) : Set :=
    divexZ : forall q r : Z, is_diveuclZ a b q r -> diveuclZ a b.

Lemma divZ : forall a b : Z, b <> OZ -> diveuclZ a b.

Proof.
  intros a b; case b; intros. elim H; reflexivity.
  case a; intros. apply (divexZ OZ (pos n) OZ OZ).
  split. discriminate. split. exact I. split.
  exact (le_O_n n). rewrite (mult_OZ (pos n)).
  reflexivity.
  elim (eucl_dev (S n) (gt_Sn_O n) (S n0)). intros.
  apply (divexZ (pos n0) (pos n) (posOZ q) (posOZ r)).
  split. discriminate. split. apply (tech_posOZ_pos r).
  split. unfold ltZ in |- *; rewrite (tech_succ_posOZ r).
  exact (gt_S_le r n g). exact (tech_div1 n0 n q r e).
  elim (eucl_dev (S n) (gt_Sn_O n) (S n0)); intros.
  case (eq_gt_O_dec r); intro. 
  apply (divexZ (neg n0) (pos n) (negOZ q) OZ). split.
  discriminate. split. exact I. split. exact (le_O_n n).
  rewrite (add_OZ (multZ (pos n) (negOZ q))).
  apply (tech_div2 n0 n q). rewrite e; rewrite e0; auto with arith.
  apply (divexZ (neg n0) (pos n) (neg q) (pos (n - r))).
  split. discriminate. split. exact I. split.
  exact (lt_le_S (n - r) n (lt_minus n r (gt_S_le r n g) g0)).
  exact (tech_div3 n0 n q r e g). case a; intros.
  apply (divexZ OZ (neg n) OZ OZ). split. discriminate.
  split. exact I. split. exact (le_O_n n).
  rewrite (mult_OZ (neg n)); reflexivity.
  elim (eucl_dev (S n) (gt_Sn_O n) (S n0)); intros.
  apply (divexZ (pos n0) (neg n) (negOZ q) (posOZ r)).
  split. discriminate. split. apply (tech_posOZ_pos r).
  split. unfold ltZ in |- *; rewrite (tech_succ_posOZ r); exact (gt_S_le r n g).
  exact (tech_div4 n0 n q r e). elim (eucl_dev (S n) (gt_Sn_O n) (S n0)); intros. case (eq_gt_O_dec r); intro. 
  apply (divexZ (neg n0) (neg n) (posOZ q) OZ). unfold is_diveuclZ in |- *.
  split. discriminate. split. exact I. split. exact (le_O_n n).
  rewrite (add_OZ (multZ (neg n) (posOZ q))). apply (tech_div5 n0 n q).
  rewrite e; rewrite e0; auto with arith.
  apply (divexZ (neg n0) (neg n) (pos q) (pos (n - r))).
  split. discriminate. split. exact I. split.
  exact (lt_le_S (n - r) n (lt_minus n r (gt_S_le r n g) g0)).
  exact (tech_div6 n0 n q r e g).
Qed.
