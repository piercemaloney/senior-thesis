Require Import Cecoa.Lib.
(* Cecoa.Lib:
Require Import Bool Arith Max Omega Psatz List NPeano Permutation.
Import List.ListNotations.

Require Import Unicode.Utf8_core.
Require Import Unicode.Utf8.
Notation "x ≤ y ≤ z" := (x ≤ y ∧ y ≤ z) (at level 70, y at next level).
Notation "x < y ≤ z" := (x < y ∧ y ≤ z) (at level 70, y at next level).
Notation "x ≤ y < z" := (x ≤ y ∧ y < z) (at level 70, y at next level).

Infix "∈" := In (at level 70).

Infix "=?" := beq_nat (at level 70, no associativity).

Obligation Tactic := idtac.

Scheme Equality for prod.
Scheme Equality for list.

Set Implicit Arguments.

Section Trivial.
Lemma S_is_suc n: S n = n+1.
Lemma or_idem: ∀ A, A ↔ A ∨ A.
Lemma and_idem: ∀ A, A ↔ A ∧ A.
Lemma and_left: ∀ A B, A ∧ B → A.
Lemma or_false_idem: ∀ A, A ↔ A ∨ False.

Definition fmono (f: nat → nat):= ∀ x y, x ≤ y → f x ≤ f y.

Lemma forall_and {A:Type} (P Q:A→Prop):
  (∀ x, P x ∧ Q x) ↔ ((∀ x, P x) ∧ (∀ x, Q x)).
Lemma forall_impl_and {A:Type} (R:A→Prop) (P Q:A→Prop):
  (∀ x, R x → P x ∧ Q x) ↔
  ((∀ x, R x → P x) ∧ (∀ x, R x → Q x)).
Lemma forall_impl2_and {A B:Type} (P Q R : A → B → Prop):
  (∀ x y, R x y → P x y ∧ Q x y) ↔ 
  ((∀ x y, R x y → P x y) ∧ (∀ x y, R x y → Q x y)).

Lemma eqb_subst_neq x y:
  x ≠ y → (x =? y) = false.
Lemma neq_lt_gt_iff (m n:nat):
  m ≠ n ↔ (m < n ∨ n < m).

Lemma length_nil : forall A (l : list A),
  length l = 0 -> l = nil.
End Trivial.

Lemma prod_beq_eq A B
  (A_beq : A -> A -> bool) (B_beq : B -> B -> bool)
  (A_beq_eq : forall a1 a2, A_beq a1 a2 = true <-> a1 = a2) (B_beq_eq : forall b1 b2, B_beq b1 b2 = true <-> b1 = b2)
  p1 p2 : prod_beq _ _ A_beq B_beq p1 p2 = true <-> p1 = p2.

Lemma list_beq_eq A
  (A_beq : A -> A -> bool) l1 l2 (A_beq_eq : forall a1 a2, In a1 l1 -> In a2 l2 -> (A_beq a1 a2 = true <-> a1 = a2)) :
  list_beq _ A_beq l1 l2 = true <-> l1 = l2.

Lemma list_beq_refl (A : Type) (A_beq : A -> A -> bool) l :
  (forall a1 a2 : A, In a1 l -> In a2 l -> (A_beq a1 a2 = true <-> a1 = a2)) ->
  list_beq _ A_beq l l = true.

Lemma eq_None_neq_Some (A : Type) (x : option A) :
  x = None <-> forall v, x <> Some v.

Lemma neq_None_eq_Some :
  forall (A: Type) (x: option A), x <> None <-> (exists a, x = Some a).

Lemma app_insert_r (A : Type) (l1 l1' l l2 l2' : list A):
  l1 ++ l2 = l1' ++ l2' -> length l2 = length l2' -> l1 ++ l ++ l2 = l1' ++ l ++ l2'.

Section assoc.

Fixpoint assoc {A B : Type}(eq : A -> A -> bool)(x : A)(l : list (A * B)) : option B :=
  match l with
  | nil => None
  | (x', y) :: l' => if eq x x' then Some y else assoc eq x l'
  end.

Definition assoc_default {A B : Type}
  (eqA : A -> A -> bool) (d : B) (l : list (A * B)) (x : A) : B :=
  match assoc eqA x l with
  | None => d
  | Some b => b
  end.

Lemma assoc_in {A B:Type} beq k (l: list (A * B)) {v}:
  (∀ a b:A, beq a b = true ↔ a=b) →
  assoc beq k l = Some v → (k,v) ∈ l.

Lemma assoc_None_not_in {A B:Type} beq k (l:list (A*B)):
  (∀ a b : A, beq a b = true ↔ a = b) →
  assoc beq k l = None ↔ ¬ k ∈ map fst l.

Lemma in_assoc_neq_None (A B: Type) (beq: A -> A -> bool) (k: A) (l: list (A * B)):
  (forall a b:A, a = b -> beq a b = true) ->
  In k (map (@fst _ _) l) ->
  assoc beq k l <> None.

Lemma assoc_in_Some {A B:Type} (beq:A→A→bool) (k:A) (l: list (A*B)):
  (∀ a b, beq a b = true ↔ a=b) →
  k ∈ map fst l ↔ ∃ v, v ∈ map snd l ∧ assoc beq k l = Some v.

Lemma assoc_in_Some_simple {A B:Type} beq k (l: list (A*B)):
  (∀ a b:A, beq a b = true ↔ a = b) →
  k ∈ map fst l ↔ (∃ v, assoc beq k l = Some v).

Lemma assoc_app_eq_None (A B:Type) (eq: A -> A -> bool) (x: A) (l1 l2: list (A * B)) :
  assoc eq x (l1 ++ l2) = None <-> (assoc eq x l1 = None /\ assoc eq x l2 = None).

Lemma assoc_app_neq_None (A B:Type) (eq: A -> A -> bool) (x: A) (l1 l2: list (A * B)) :
  assoc eq x (l1 ++ l2) <> None <-> (assoc eq x l1 <> None \/ assoc eq x l2 <> None).

Lemma assoc_app_eq_Some (A B:Type) (eq: A -> A -> bool) (x: A) (v : B) (l1 l2: list (A * B)) :
  assoc eq x (l1 ++ l2) = Some v <->
  (assoc eq x l1 = Some v \/ (assoc eq x l1 = None /\ assoc eq x l2 = Some v)).

Lemma assoc_app_in {K V:Type} beq k (l1 l2: list (K*V)):
  (∀ a b : K, beq a b = true ↔ a = b) →
  k ∈ map fst l1 → assoc beq k (l1++l2) = assoc beq k l1.

Lemma assoc_app_out {K V:Type} beq k (l1 l2: list (K*V)):
  (∀ a b : K, beq a b = true ↔ a = b) →
  ¬ k ∈ map fst l1 → assoc beq k (l1++l2) = assoc beq k l2.

Lemma assoc_in_concat {K V:Type} beq (k:K) ll (v:V):
  assoc beq k (concat ll) = Some v →
  ∃ l : list (K * V), l ∈ ll ∧ assoc beq k l = Some v.

End assoc.

Lemma map_in_ext :
  forall (A B : Type) (f g : A -> B) (l : list A),
  (forall a : A, In a l -> f a = g a) -> map f l = map g l.

Lemma incl_cons_cons A: forall (a:A) (l1 l2: list A), incl l1 l2 -> incl (a::l1) (a::l2).

Lemma map_incl A B (f : A -> B) l1 l2 : incl l1 l2 -> incl (map f l1) (map f l2).

Lemma map_flat_map (A B C : Type) (f : A -> list B) (g : B -> C) (l : list A) :
map g (flat_map f l) = flat_map (fun a => map g (f a)) l.

Lemma incl_filter (A : Type) (f : A -> bool) l:
  incl (filter f l) l.

Lemma filter_ext_In {A : Type} f g (l : list A): (forall a , In a l -> f a = g a)-> filter f l = filter g l.

Lemma filter_app A (f : A -> bool) l1 l2 : filter f (l1 ++ l2) = filter f l1 ++ filter f l2.

Lemma filter_flat_map A B f (g : A -> list B) l : filter f (flat_map g l) = flat_map (fun x => filter f (g x)) l.

Lemma flat_map_in_ext  A B (f g : A -> list B) l : 
  (forall a : A, In a l -> f a = g a) -> flat_map f l = flat_map g l.

Lemma NoDup_filter A f (l : list A) : NoDup l -> NoDup (filter f l).

Lemma map_cons (A B : Type)(f : A -> B) a l : map f (a :: l) = f a :: map f l.

Lemma length_remove A eq_A_dec (a: A) l :
  length (remove eq_A_dec a l) <= length l.

Lemma length_cons_remove A eq_A_dec (a: A) l :
  In a l -> length (a :: remove eq_A_dec a l) <= length l.

Lemma neq_in_in_remove A eq_A_dec (a a': A) l:
  a' <> a -> In a l -> In a (remove eq_A_dec a' l).

Lemma incl_remove_app A l l1 l2 (x : A) : ~ In x l -> incl l (l1 ++ x :: l2) -> incl l (l1 ++ l2).

Lemma flat_map_nil (A B: Type) (f: A -> list B) (xs: list A):
  (forall x, In x xs -> f x = []) ->
  flat_map f xs = [].

Lemma flat_map_comp (A B C : Type) (f : A -> B) (g : B -> list C) (h : A -> list C) (l : list A) :
  (forall x, In x l -> h x = g (f x)) -> flat_map h l = flat_map g (map f l).

Lemma flat_map_app (A B : Type) (f : A -> list B) l1 l2 :
  flat_map f (l1 ++ l2) = flat_map f l1 ++ flat_map f l2.

Lemma comp_flat_map (A B C : Type) (f : A -> list B) (g : B -> list C) h l :
  (forall a, In a l -> h a = flat_map g (f a)) -> flat_map h l = flat_map g (flat_map f l).

Fixpoint andl (l : list Prop) : Prop :=
  match l with
  | nil => True
  | P :: l' => P /\ andl l'
  end.

Lemma andl_cons: forall a l, andl (a::l) <-> a /\ (andl l).

Lemma andl_in : forall l P, andl l -> In P l -> P.

Lemma andl_in_map (A:Type): forall l (a:A) P, andl (map P l) -> In a l -> P a.

Lemma andl_map (A : Type) (f g : A -> Prop) l :
  andl (map f l) -> (forall a, In a l -> f a -> g a) -> andl (map g l).

Lemma andl_app l1 l2 : andl (l1 ++ l2) <-> andl l1 /\ andl l2.

Fixpoint orl (l : list Prop) : Prop :=
  match l with
  | nil => False
  | P :: l' => P \/ orl l'
  end.

Lemma andl_concat l:
  andl (concat l) <-> forall l', In l' l -> andl l'.

Lemma orl_map (A : Type) (P : A -> Prop) l : orl (map P l) <-> exists x, In x l /\ P x.

Section Maxl.
Fixpoint maxl (l : list nat) : nat :=
  match l with
  | nil => 0
  | n :: l' => max n (maxl l')
  end.

Lemma maxl_is_max :
  forall l n, In n l -> n <= maxl l.

Lemma all_max_le l y :
  (forall x, In x l -> x <= y) -> maxl l <= y.

Lemma maxl_app : forall (l1 l2 : list nat), maxl (l1 ++ l2) = max (maxl l1) (maxl l2).

Lemma in_maxl (l : list nat) : l<>nil -> In (maxl l) l.

Lemma all_maxl P xs: xs <> [] -> (forall x, In x xs -> P x) -> P (maxl xs).

Lemma maxl_le_maxl A f g (l : list A) :
(forall x, In x l -> f x <= g x) -> maxl (map f l) <= maxl (map g l).

Lemma maxl_map_const {A:Type} l (f: A → nat) n:
  (∀ x, x ∈ l → (f x) = n) →
  l ≠ [] → maxl (map f l) = n.

Lemma maxl_map_0 A l (f : A -> nat) : 
  (forall x, In x l -> (f x) = 0) ->
  maxl (map f l) = 0.

Lemma maxl_map_plus_le A f g (l : list A) :
  maxl (map (fun x => f x + g x) l) <= maxl (map f l) + maxl (map g l).

Lemma maxl_concat: forall l,
  maxl (concat l) = maxl (map maxl l).

Lemma maxl_map_lt_iff (A:Type): forall (l:list A) f n,
  0<n -> maxl (map f l) < n <-> (forall m, In m l -> (f m) < n).

Lemma maxl_map_le_iff (A:Type): forall (l:list A) f n,
  maxl (map f l) <= n <-> (forall m, In m l -> (f m) <= n).

Lemma maxl_map_is_max_map (A:Type): forall (l:list A) f a,
  In a l -> (f a) <= maxl (map f l).

Lemma maxl_eq_maxl {A:Type} f g (l:list A):
  (∀ x : A, x ∈ l → f x = g x) →
  maxl (map f l) = maxl (map g l).
End Maxl.

Lemma in_concat_iff (A:Type) x (l:list (list A)):
  x ∈ concat l <-> exists l', l' ∈ l /\ x ∈ l'.

Lemma incl_le_maxl :
  forall (l1 l2 : list nat), incl l1 l2 -> maxl l1 <= maxl l2.

Lemma maxl_cons : forall n l, maxl (n::l) = max n (maxl l).

Lemma forall2_le_maxl :
  forall (l1 l2 : list nat), Forall2 le l1 l2 -> maxl l1 <= maxl l2.

Lemma incl_flat_map (A B : Type) (f g : A -> list B) l :
  (forall a, In a l -> incl (f a) (g a)) ->
  incl (flat_map f l) (flat_map g l).

Section suml.

Fixpoint suml (l : list nat) : nat :=
  match l with
  | nil => 0
  | n :: l' => n + suml l'
  end.

Lemma suml_cons n l : suml (n :: l) = n + suml l.

Lemma suml_map_const A n (l : list A) : suml (map (fun _ => n) l) = n * length l.

Lemma mult_suml_r m l : m * suml l = suml (map (fun n => m * n) l).

Lemma suml_app l1 l2 : suml (l1 ++ l2) = suml l1 + suml l2.

Lemma suml_flat_map (A : Type)(f : A -> list nat)(l :list A) :
  suml (flat_map f l) = suml (map suml (map f l)).

Lemma suml_flat_map_map (A B : Type) (f : A -> list B) (g : B -> nat) l :
  suml (flat_map (fun x => map g (f x)) l) = suml (map (fun x => suml (map g (f x))) l).

Lemma suml_map_plus (A : Type)(f g : A -> nat)(l : list A) : suml (map (fun x => f x + g x) l) = suml (map f l) + suml (map g l).

Lemma suml_map_le :
  forall (A : Type)(f g : A -> nat)(l : list A),
  (forall x, In x l -> f x <= g x) -> suml (map f l) <= suml (map g l).

Lemma suml_map_eq :
  forall (A : Type)(f g : A -> nat)(l : list A),
  (forall x, In x l -> f x = g x) -> suml (map f l) = suml (map g l).

Lemma suml_map_le_plus_length :
  forall (A : Type)(f g : A -> nat)(l : list A),
  (forall x, In x l -> f x <= g x + 1) -> suml (map f l) <= suml (map g l) + length l.

Lemma suml_le_len_times_bound l b :
  (forall x, In x l -> x <= b) -> suml l <= length l * b.

Lemma in_le_suml :
  forall (n : nat)(l : list nat),
  In n l -> n <= suml l.

Lemma maxl_le_suml l: maxl l <= suml l.

Lemma forall2_le_suml :
  forall (l1 l2 : list nat), Forall2 le l1 l2 -> suml l1 <= suml l2.

Lemma maxl_le_suml_map (A B : Type) (f : A -> list B) (g : B -> nat) (h : A -> nat) (l : list A) :
  (forall a, In a l -> maxl (map g (f a)) <= h a) ->
  maxl (map g (flat_map f l)) <= suml (map h l).

Lemma suml_map_mult_le_suml_mult_maxl (A : Type) f g (l : list A) :
  suml (map (fun x => f x * g x) l) <= suml (map f l) * maxl (map g l).

Lemma suml_map_mult_le_suml_mult_suml (A : Type) f g (l : list A) :
  suml (map (fun x => f x * g x) l) <= suml (map f l) * suml (map g l).

Lemma length_flat_map (A B : Type) ( f : A -> list B) (l : list A) :
  length (flat_map f l) = suml (map (@length _) (map f l)).

Lemma seq_Succ n m : seq n (S m) = seq n m ++ [m + n].

Lemma Permutation_filter {A : Type} f (l : list A) : Permutation l (filter f l ++ filter (fun x => negb (f x)) l).

Lemma filter_compose {A : Type} f g (l : list A) : 
  (forall x, In x l -> ( f x = true -> g x = true)) ->
  filter f (filter g l) = filter f l.

Lemma in_seq : forall len start n : nat,
       In n (seq start len) <-> start <= n < start + len.

Lemma Permutation_partition_list_nat b n l :
 (forall x, In x l -> b <= x < b + n) ->
 Permutation l (flat_map (fun n => filter (beq_nat n) l) (seq b n)).

Lemma length_suml_filter b n l:
 (forall x, In x l -> b <= x < b + n) ->
 suml (map (fun r => length(filter (beq_nat r) l )) (seq b n)) = length l.

End suml.

Section prodl.

Fixpoint prodl (l : list nat) : nat :=
  match l with
  | nil => 1
  | n :: l' => n * prodl l'
  end.

Lemma prodl_bound (l : list nat) (b : nat) : 
  (forall x, In x l -> x <= b) -> prodl l <= Nat.pow b  (length l).

End prodl.

Definition clos_refl {A : Type} (R : A -> A -> Prop) (x y : A) : Prop :=
  R x y \/ x = y.

Lemma clos_refl_trans (A: Type) (R: A -> A -> Prop) t1 t2 t3:
    (R t1 t2 -> R t2 t3 -> R t1 t3) ->
    clos_refl R t1 t2 -> clos_refl R t2 t3 -> clos_refl R t1 t3.

Lemma Forall2_eq_clos_refl (A:Type) (R: A -> A -> Prop) (l1 :list A) :
  Forall2 (clos_refl R) l1 l1.

Lemma Forall_In_l (A : Type) (P : A -> Prop) x xs:
  Forall P xs -> In x xs -> P x.

Lemma Forall2_In_l (A B : Type) (R : A -> B -> Prop) x xs ys :
  Forall2 R xs ys -> In x xs -> exists y, In y ys /\ R x y.

Lemma Forall2_In_r (A B : Type) (R : A -> B -> Prop) y xs ys :
  Forall2 R xs ys -> In y ys -> exists x, In x xs /\ R x y.

Lemma Forall2_conj (A B : Type) (R1 R2 : A -> B -> Prop) xs ys :
  Forall2 R1 xs ys -> Forall2 R2 xs ys -> Forall2 (fun x y => R1 x y /\ R2 x y) xs ys.

Lemma Forall2_trans (A: Type) (R: A -> A -> Prop) xs ys zs :
    (forall x y z, In x xs -> In y ys -> In z zs -> R x y -> R y z -> R x z) ->
    Forall2 R xs ys -> Forall2 R ys zs -> Forall2 R xs zs.

Lemma Forall2_length A B (R : A -> B -> Prop) xs ys :
  Forall2 R xs ys -> length xs = length ys.

Lemma Forall2_map (A:Type) (B:Type): forall l f g (R:B->B->Prop),
  (forall (x:A), In x l -> R (f x) (g x)) -> Forall2 R (map f l) (map g l).

Lemma Forall2_flat_map (A B C D: Type) (R: C -> D -> Prop) (f: A -> list C) (g: B -> list D) (xs: list A) (ys: list B) :
  Forall2 (fun x y => Forall2 R (f x) (g y)) xs ys ->
  Forall2 R (flat_map f xs) (flat_map g ys).

Lemma Forall2_forall A (d: A) (R: A -> A -> Prop) (xs ys: list A) :
  Forall2 R xs ys ->
  forall i, i < length xs -> R (nth i xs d) (nth i ys d).

Inductive Exists2 {A B} (R: A -> B -> Prop) : list A -> list B -> Prop :=
 | Exists2_cons_hd : forall x xs y ys, R x y -> Exists2 R (x::xs) (y::ys)
 | Exists2_cons_tl : forall x xs y ys, Exists2 R xs ys -> Exists2 R (x::xs) (y::ys).
Hint Constructors Exists2.

Lemma Exists2_exists A (d: A) (R: A -> A -> Prop) (xs ys: list A) :
  Exists2 R xs ys ->
  exists i, i < length xs /\ R (nth i xs d) (nth i ys d).

Lemma app_eq_compat_l {A: Type} (xs ys zs: list A) : ys = zs -> xs ++ ys = xs ++ zs.

Lemma In_prefix_suffix (A : Type) (a : A) l :
  In a l -> exists l1 l2, l = l1 ++ a :: l2.

Lemma forall_exists_list (A B : Type) (P : A -> Prop) (Q : A -> B -> Prop) (l : list A) :
  (forall a, In a l -> P a -> exists b, Q a b) ->
  (Forall P l -> exists l', Forall2 Q l l').

Lemma forall_andl (A: Type) (P: A -> Prop) (l: list A):
  Forall P l <-> andl (map P l).

Fixpoint revflatten {A: Type} (xss: list (list A)) : list A :=
  match xss with
  | []       => []
  | xs::xss' => revflatten xss' ++ xs
  end.

Lemma Permutation_flat_map_ext A B  : forall l (f g : A -> list B),
  (forall x, In x l -> Permutation (f x) (g x)) -> Permutation (flat_map f l) (flat_map g l).

Lemma Permutation_revflatten A B (f : A -> list B) l : Permutation(revflatten (map f l)) (flat_map f l).

Lemma In_seq n start len : In n (seq start len) <-> start <= n < start+len.

Lemma seq_S start len : seq start (S len) = seq start len ++ [start + len].

Lemma plus_eq_compat_l x y1 y2 : y1 = y2 -> x + y1 = x + y2.

Lemma plus_eq_compat_r x1 x2 y : x1 = x2 -> x1 + y = x2 + y.

Section count_occ.

Lemma count_occ_remove_O A eq_dec (a: A) l :
  count_occ eq_dec (remove eq_dec a l) a = 0.

Lemma count_occ_remove_neq A eq_dec (a a': A) l :
  a<>a' -> count_occ eq_dec (remove eq_dec a' l) a = count_occ eq_dec l a.

Lemma suml_map_count_occ_remove A eq_dec (a: A) l1 l2 :
  ~In a l2 ->
  suml (map (count_occ eq_dec (remove eq_dec a l1)) l2) =
  suml (map (count_occ eq_dec l1) l2).

Lemma length_remove_count_occ A eq_dec (a: A) l:
  length l = length (remove eq_dec a l) + count_occ eq_dec l a.

Lemma in_remove_neq A eq_dec (a a': A) l :
  In a' (remove eq_dec a l) -> In a' l.

Lemma length_count_occ a b l :
  (forall n, In n l -> a <= n < a + b) ->
  length l = suml (map (count_occ eq_nat_dec l) (seq a b)).

Lemma count_occ_cons A eq_dec (a a': A) l :
  count_occ eq_dec (a::l) a' =
  if eq_dec a a' then S (count_occ eq_dec l a') else count_occ eq_dec l a'.

Lemma count_occ_app A eq_dec (a :A) l l' :
  count_occ eq_dec (l ++ l') a = count_occ eq_dec l a + count_occ eq_dec l' a.

Lemma count_occ_flat_map A B eq_B_dec (f: A -> list B) b l :
  count_occ eq_B_dec (flat_map f l) b =
  suml (map (fun a => count_occ eq_B_dec (f a) b) l).

End count_occ.

Lemma tl_incl (A:Type): forall (a:A) l l', incl (a::l') l -> incl l' l.

Section NoDup.

Lemma NoDup_app (A: Type) (l1 l2: list A):
  (forall x, In x l1 -> ~ In x l2) ->
  NoDup l1 ->
  NoDup l2 ->
  NoDup (l1 ++ l2).

Lemma NoDup_split (A: Type) (l1 l2: list A):
  NoDup (l1 ++ l2) ->
  NoDup l1.

Lemma NoDup_split_right : forall (A : Type) (l1 l2 : list A), NoDup (l1 ++ l2) -> NoDup l2.

Theorem NoDup_cons_iff {A:Type} (a: A) (l: list A):
  NoDup (a::l) <-> ~ In a l /\ NoDup l.

Lemma NoDup_app_in_l A l l' :
  NoDup (l ++ l') -> forall x : A, (In x l) -> ~ (In x l').

Lemma NoDup_Permutation_NoDup A l l' : @NoDup A l -> Permutation.Permutation l l' -> NoDup l'.

Lemma NoDup_incl_le_length (A: Type)
  (l1 l2: list A):
  NoDup l1 -> incl l1 l2 -> length l1 <= length l2.

Lemma NoDup_flat_map A B (f : A -> list B) l :
  (forall x, In x l -> NoDup (f x)) ->
  NoDup l ->
  (forall x y, In x l -> In y l -> x <> y -> (forall z, In z (f x) <-> ~ In z (f y))) ->
  NoDup (flat_map f l).

End NoDup.

Definition uniquify A (d : forall a b : A, { a = b} + { a <> b}) (l:list A) : list A :=
list_rect (fun _ : list A => list A) []
  (fun (a : A) (_ l' : list A) => let s := in_dec d a l' in if s then l' else a :: l') l.

Section pow.

Lemma lt_0_pow x n : 0 < x ->  0 < Nat.pow x n.

Lemma pow_le_compat x y n:
  x <= y -> Nat.pow x n <= Nat.pow y n.

End pow.

Lemma length_filter (A B : Type) (c : B -> bool) (f : A -> B) (xs : list A) :
  length (filter (fun x => c (f x)) xs) =
  length (filter c (map f xs)).

Section Sublist.

Inductive sublist (A : Type) : (list A) -> (list A) -> Prop :=
| sublist_refl : forall l, sublist l l
| sublist_skip : forall l1 h t, sublist l1 t -> sublist l1 (h :: t)
| sublist_cons : forall h t1 t2, sublist t1 t2 -> sublist (h :: t1) (h :: t2).

Hint Constructors sublist.

Lemma sublist_nil A (l : list A) : sublist [] l.

Lemma sublist_incl A (l1 l2 : list A) : sublist l1 l2 -> incl l1 l2.

Lemma sublist_app_skip A (l1 l2 l3 : list A) : sublist l1 l3 -> sublist l1 (l2 ++ l3).

Lemma sublist_app_left A (l1 l2 l3 : list A) : sublist l1 l3 -> sublist (l2 ++ l1) (l2 ++ l3).

Lemma sublist_app_compat A (l1 l2 l3 l4 : list A) :
  sublist l1 l3 -> 
  sublist l2 l4 ->
  sublist (l1 ++ l2) (l3 ++ l4).

Lemma sublist_flatmap_in_ext A B (f : A -> list B) g l: 
  (forall x : A , In x l -> sublist (f x) (g x)) ->
  sublist (flat_map f l) (flat_map g l).

Lemma NoDup_sublist A (l1 l2 : list A) : sublist l1 l2 -> NoDup l2 -> NoDup l1.

End Sublist.

Section Compat.

Lemma NoDup_map_inv A B (f:A->B) l : NoDup (map f l) -> NoDup l.

End Compat.

Lemma In_In_list_decompose {A} (x y : A) l : In x l -> In y l ->
  x = y \/
  exists l1 l2 l3, (l = l1 ++ x :: l2 ++ y :: l3) \/ (l = l1 ++ y :: l2 ++ x :: l3).

Section Lexicographic_Product.

Variables A B : Type.

Variable ltA : A -> A -> Prop.

Variable ltB : B -> B -> Prop.

Hypothesis wf_ltA : well_founded ltA.

Hypothesis wf_ltB : well_founded ltB.

Inductive lexprod : A*B -> A*B -> Prop :=
| lex_l : forall a a' b b', ltA a a' -> lexprod (a, b) (a', b')
| lex_r : forall a    b b', ltB b b' -> lexprod (a, b) (a,  b').

Lemma acc_lex a b : Acc ltA a -> Acc ltB b -> Acc lexprod (a, b).

Lemma lexprod_trans :
  (forall a1 a2 a3, ltA a1 a2 -> ltA a2 a3 -> ltA a1 a3) ->
  (forall b1 b2 b3, ltB b1 b2 -> ltB b2 b3 -> ltB b1 b3) ->
  forall x1 x2 x3, lexprod x1 x2 -> lexprod x2 x3 -> lexprod x1 x3.

Lemma wf_lexprod : well_founded lexprod.

Definition lex_prod_dec: 
  (forall a1 a2 : A, {a1 = a2} + {a1 <> a2}) ->
  (forall a1 a2, {ltA a1 a2} + {~ltA a1 a2}) ->
  (forall b1 b2, {ltB b1 b2} + {~ltB b1 b2}) ->
  (forall x y, {lexprod x y} + {~ lexprod x y}).

End Lexicographic_Product.

Section Last.

Lemma non_empty_last (A:Type) d d' (l:list A):
  l <> [] -> (last l d) = (last l d').

Lemma cons_cons_last (A:Type) (a b:A) l x:
  last (a::b::l) x = last (b::l) x.

Lemma cons_last (A:Type) (a:A) l x:
  last (a::l) x = last l a.

Lemma last_in (A:Type) (l:list A) x:
  (last l x = x) \/ (In (last l x) l).

End Last.

Lemma beq_eq_dec {A : Type} {beq : A -> A -> bool} (Hbeq : forall x y, beq x y = true <-> x = y) : forall (x y : A), {x = y} + {~ x = y}.

Section Firstn_skipn.
Lemma firstn_map {A B : Type} (f : A -> B) l n : 
  firstn n (map f l) = map f (firstn n l).

Lemma skipn_map {A B : Type} (f : A -> B) l n : 
  skipn n (map f l) = map f (skipn n l).

Lemma skipn_app_length {A : Type} (l1 l2 : list A) : skipn (length l1) (l1 ++ l2) = l2.

Lemma firstn_app_length {A : Type} (l1 l2 : list A) : firstn (length l1) (l1 ++ l2) = l1.

Lemma skipn_nil : forall {A} n (x : list A),
  length x <= n -> skipn n x = nil.

Lemma firstn_seq n start len :
  firstn n (seq start len) = seq start (min n len).

Lemma skipn_seq n start len :
  skipn n (seq start len) = seq (start+n) (len-n).

Lemma skipn_firstn {A:Type} n (l:list A):
  skipn n (firstn n l) = [].

Lemma skipn_incl {A:Type} (l:list A) n:
  incl (skipn n l) l.

Lemma skipn_app2 {A : Type} (l l' : list A) n:
  length l = n → skipn n (l ++ l') = l'.

Lemma firstn_app {A} (l l' : list A) : 
  firstn (length l) (l ++ l') = l.

Lemma firstn_app2 : forall (A : Type) (l l' : list A) n, 
 length l = n -> firstn n (l ++ l') = l .
End Firstn_skipn.

Section Ints.
Definition ints (n m:nat):list nat := seq n (m-n). 
Lemma ints_bounded : ∀ (x n m:nat),
  n ≤ m → x ∈ (ints n m) → n ≤ x < m.

Lemma ints_bounds : ∀ (x n m:nat),
  n ≤ x < m → x ∈ (ints n m).

Lemma ints_bounds_iff: ∀ x n m,
  n ≤ m → (n ≤ x < m ↔ x ∈ (ints n m)).

Lemma ints_length : ∀ n m,
  n ≤ m → length (ints n m) = m-n.
End Ints.

Section Forall.
Lemma Forall_cons_iff {A:Type} (x:A) (xs:list A) (P:A→Prop):
  Forall P (x::xs) ↔ P x ∧ Forall P xs.
Lemma Forall_map_iff {A B:Type} (f: A → B) l (P: B → Prop):
  (∀ x, x ∈ l → P (f x)) ↔ Forall P (map f l).
Lemma Forall_app_iff {A:Type} (P:A→Prop) l1 l2:
  Forall P (l1++l2) ↔ Forall P l1 ∧ Forall P l2.

Lemma Forall_unary {A:Type} (P:A→Prop) a:
  Forall P [a] ↔ P a.

Lemma Forall_flat_map {A B:Type} (P:B → Prop) (f:A → list B) l:
  Forall P (flat_map f l) ↔ Forall (λ x, Forall P (f x)) l.
End Forall.

Section Concat.
Lemma concat_unary_is_map {A B:Type}: ∀ l (f:A→B),
  concat (map (λ x, [f x]) l) = map f l.
Lemma in_concat_const_is_in {A B:Type} (a:A) lfix l:
  a ∈ concat (map (λ _ : B, lfix) l) ↔ l ≠ [] ∧ a ∈ lfix.
End Concat.

Section Incl.
Lemma incl_nil {A:Type} (l:list A): incl [] l.

Lemma incl_map_flat_map {A B:Type} (xs:list A) (f:A → B) g:
  (∀ x : A, x ∈ xs → f x ∈ g x) →
  incl (map f xs) (flat_map g xs).

Lemma incl_flat_map_incl {A B C:Type} (xs:list A) (r:A→list B) (rh:B→list C) lh:
  (∀ x : A, x ∈ xs → incl (flat_map rh (r x)) (lh x)) →
  incl (flat_map rh (concat (map r xs))) (flat_map lh xs).
End Incl.

Section Append.
Lemma app_length_eq {A:Type}:
  ∀ (l1 l2 l1' l2': list A),
  length l1 = length l1' → (l1++l2) = (l1'++l2') →
  l1 = l1' ∧ l2 = l2'.
End Append.

Section Forall2.
Lemma Forall2_le_refl l: Forall2 le l l.

Lemma Forall2_app_inv {A B:Type} (P:A→B→Prop) la1 la2 lb1 lb2:
  length la1 = length lb1 → Forall2 P (la1++la2) (lb1++lb2) →
  Forall2 P la1 lb1 ∧ Forall2 P la2 lb2.

Lemma Forall2_firstn {A B:Type} (P:A→B→Prop) la lb n:
  Forall2 P la lb → Forall2 P (firstn n la) (firstn n lb).

Lemma Forall2_skipn {A B:Type} (P:A→B→Prop) la lb n:
  Forall2 P la lb → Forall2 P (skipn n la) (skipn n lb).

Lemma Forall2_firstn_skipn_iff {A B:Type} (P:A→B→Prop) la lb n:
  Forall2 P la lb ↔ Forall2 P (firstn n la) (firstn n lb) ∧ Forall2 P (skipn n la) (skipn n lb).

Lemma Forall2_tail {A B:Type} (P:A→B→Prop) la lb:
  Forall2 P la lb → Forall2 P (tl la) (tl lb).
End Forall2. *)
Require Import BellantoniCook.BC.
Require Import Le Max List Bool Cecoa.Syntax NPeano Omega Cecoa.Ordering Cecoa.QI.
(* Cecoa.Syntax:
Require Import Bool Arith Max List.
Import List.ListNotations.
Require Import Omega.
Require Import Cecoa.Lib.

Set Implicit Arguments.
Unset Strict Implicit.

Section Syntax.

Variables variable function constructor : Type.
Variable max_arity : nat.

Inductive value : Type :=
| c_capply : constructor -> list value -> value.

Inductive term : Type :=
| var : variable -> term
| capply : constructor -> list term -> term
| fapply : function -> list term -> term.

Inductive pattern : Type :=
| p_var : variable -> pattern
| p_capply : constructor -> list pattern -> pattern.

Inductive rule : Type :=
| rule_intro : function -> list pattern -> term -> rule.

Lemma value_ind2_gen :
  forall (P : value -> Type)(Q : list value -> Type),
  Q nil ->
  (forall v l, P v -> Q l -> Q (v :: l)) ->
  (forall c l, Q l -> P (c_capply c l)) ->
  forall v, P v.

Lemma term_ind2_gen :
  forall (P : term -> Prop)(Q : list term -> Prop),
  Q nil ->
  (forall t l, P t -> Q l -> Q (t :: l)) ->
  (forall x, P (var x)) ->
  (forall c l, Q l -> P (capply c l)) ->
  (forall f l, Q l -> P (fapply f l)) ->
  forall t, P t.

Lemma term_ind2 :
  forall (P : term -> Prop),
  (forall x, P (var x)) ->
  (forall c l, (forall t, In t l -> P t) -> P (capply c l)) ->
  (forall f l, (forall t, In t l -> P t) -> P (fapply f l)) ->
  forall t, P t.

Lemma pattern_ind2_gen :
  forall (P : pattern -> Prop)(Q : list pattern -> Prop),
  Q nil ->
  (forall p l, P p -> Q l -> Q (p :: l)) ->
  (forall x, P (p_var x)) ->
  (forall c l, Q l -> P (p_capply c l)) ->
  forall p, P p.

Lemma pattern_ind2 :
  forall (P : pattern -> Prop),
  (forall x, P (p_var x)) ->
  (forall c l, (forall p, In p l -> P p) -> P (p_capply c l)) ->
  forall p, P p.

Variable variable_eq_dec : forall (x1 x2 : variable), {x1=x2}+{x1<>x2}.

Definition variable_beq (x1 x2 : variable) : bool :=
  if variable_eq_dec x1 x2 then true else false.

Lemma variable_beq_eq : forall x1 x2, variable_beq x1 x2 = true <-> x1 = x2.

Variable function_eq_dec : forall (x1 x2 : function), {x1=x2}+{x1<>x2}.

Definition function_beq (x1 x2 : function) : bool :=
  if function_eq_dec x1 x2 then true else false.

Lemma function_beq_eq : forall x1 x2, function_beq x1 x2 = true <-> x1 = x2.

Variable constructor_eq_dec : forall (x1 x2 : constructor), {x1=x2}+{x1<>x2}.

Definition constructor_beq (x1 x2 : constructor) : bool :=
  if constructor_eq_dec x1 x2 then true else false.

Lemma constructor_beq_eq : forall x1 x2, constructor_beq x1 x2 = true <-> x1 = x2.

Fixpoint value_beq (v1 v2 : value) : bool :=
  match v1, v2 with
  | c_capply c lv, c_capply c' lv' => constructor_beq c c' && list_beq _ value_beq lv lv'
  end.

Lemma value_ind2 :
  forall (P : value -> Prop),
  (forall c l, (forall v, In v l -> P v) -> P (c_capply c l)) ->
  forall v, P v.

Lemma value_beq_eq v1 v2 : value_beq v1 v2 = true <-> v1 = v2.

Fixpoint term_beq (t1 t2 : term) : bool :=
  match t1, t2 with
  | var x, var x' => variable_beq x x'
  | capply c lt, capply c' lt' => constructor_beq c c' && list_beq _ term_beq lt lt'
  | fapply f lt, fapply f' lt' => function_beq f f' && list_beq _ term_beq lt lt'
  | _, _ => false
  end.

Lemma term_beq_eq t1 t2 : term_beq t1 t2 = true <-> t1 = t2.

Fixpoint pattern_from_value (v : value) : pattern  :=
  match v with
    | c_capply c lv => p_capply c (map pattern_from_value lv)
  end.

Fixpoint term_from_value (v : value) : term :=
  match v with
  | c_capply c lc => capply c (map term_from_value lc)
  end.

Coercion term_from_value : value >-> term.

Lemma term_from_value_not_var : forall v x, ~ term_from_value v = var x.

Lemma term_from_value_not_fapply : forall v f lt, ~ term_from_value v = fapply f lt.

Lemma term_from_value_injective (v v': value) :
  term_from_value v = term_from_value v' -> v = v'.

Fixpoint term_from_pattern (p : pattern) : term :=
  match p with
  | p_var v => var v
  | p_capply c lp => capply c (map term_from_pattern lp)
  end.

Coercion term_from_pattern : pattern >-> term.

Lemma term_from_pattern_not_fapply : forall v f lt, ~ term_from_pattern v = fapply f lt.

Fixpoint term_value (t: term) : Prop :=
  match t with
    | capply _ lt => andl (map term_value lt)
    | _ => False
  end.

Lemma term_value_eqv (t: term) :
  term_value t <-> exists (v: value), t = term_from_value v.

Fixpoint vars_of_term (t : term) : list variable :=
  match t with
  | var x => [x]
  | capply _ lt => flat_map vars_of_term lt
  | fapply _ lt => flat_map vars_of_term lt
  end.

Fixpoint vars_of_pattern (p : pattern) : list variable :=
  match p with
  | p_var x => [x]
  | p_capply _ lp => flat_map vars_of_pattern lp
  end.

Lemma vars_of_pattern_term p : vars_of_pattern p = vars_of_term (term_from_pattern p).

Fixpoint functions_of_term (t:term) : list function :=
  match t with
    | var _       => []
    | capply _ lt => flat_map functions_of_term lt
    | fapply f lt => f :: flat_map functions_of_term lt
  end.

Fixpoint fapplies_in_term (t: term) : list term :=
  match t with
  | var _       => []
  | capply _ lt =>      flat_map fapplies_in_term lt
  | fapply _ lt => t :: flat_map fapplies_in_term lt
  end.

Lemma fapplies_in_term_are_fapplies t1 t2 :
  In t1 (fapplies_in_term t2) ->
  exists f lt, t1 = fapply f lt.

Lemma fapplies_in_value_nil (v: value) :
  fapplies_in_term (@term_from_value v) = [].

Fixpoint max_arity_pattern (p : pattern) : nat :=
  match p with
  | p_var _ => 0
  | p_capply _ lp => max (length lp) (maxl (map max_arity_pattern lp))
  end.

Fixpoint max_arity_term (t : term) : nat :=
  match t with
    | var _ => 0
    | capply _ lt => max (length lt) (maxl (map max_arity_term lt))
    | fapply _ lt => max (length lt) (maxl (map max_arity_term lt))
  end.

Definition max_arity_rule (r : rule) : nat :=
  match r with
  | rule_intro _ lp t => max (max_arity_term t) (max (length lp) (maxl (map max_arity_pattern lp)))
  end.

Definition max_arity_prog (prog : list rule) : nat :=
  maxl (map max_arity_rule prog).

Definition rule_vars_defined (r : rule) : Prop :=
  match r with
  | rule_intro _ lp t => incl (vars_of_term t) (flat_map vars_of_pattern lp)
  end.

Definition wf_prog (prog : list rule) : Prop :=
  andl (map rule_vars_defined prog) /\ max_arity_prog prog <= max_arity.

Fixpoint subst (s : variable -> value)(t : term) : term :=
  match t with
  | var x => s x
  | capply c lt => capply c (map (subst s) lt)
  | fapply f lt => fapply f (map (subst s) lt)
  end.

Fixpoint psubst (s : variable -> value)(p : pattern) : value :=
  match p with
  | p_var x => s x
  | p_capply c lp => c_capply c (map (psubst s) lp)
  end.

Lemma subst_not_var : forall s t x, ~ subst s t = var x.

Lemma subst_psubst s p : subst s (term_from_pattern p) = term_from_value (psubst s p).

Fixpoint value_size (v : value) : nat :=
  match v with
  | c_capply _ lv => 1 + suml (map value_size lv)
  end.

Fixpoint term_size (t : term) :=
  match t with
  | var _ => 1
  | capply _ lt => 1 + suml (map term_size lt)
  | fapply _ lt => 1 + suml (map term_size lt)
  end.

Lemma gt_term_size_O t : term_size t > 0.

Lemma in_capply_term_size_lt c (t : term) lt :
  In t lt ->
  term_size t < term_size (capply c lt).

Lemma in_fapply_term_size_lt f (t : term) lt :
  In t lt ->
  term_size t < term_size (fapply f lt).

Definition rhs_of_rule (r : rule) : term :=
  match r with rule_intro _ _ t => t end.

Definition lhs_of_rule (r : rule) : term :=
  match r with rule_intro f lp _ => fapply f (map term_from_pattern lp) end.

Definition max_rhs (prog : list rule) : nat :=
  maxl (map term_size (map rhs_of_rule prog)).

Lemma compatible_sizes: forall v, term_size (term_from_value v) = value_size v.

Definition max_size_image_subst (t : term) (s : variable -> value) : nat :=
  maxl (map value_size (map s (vars_of_term t))).

Lemma incl_le_max_size_image_subst :
  forall s t u,
  incl (vars_of_term t) (vars_of_term u) -> max_size_image_subst t s <= max_size_image_subst u s.

Lemma step_one: forall s t, term_size (subst s t) <= term_size t * (1 + max_size_image_subst t s).

Lemma size_subst_var_le_size_value:
  forall p s (x:variable) v, v = psubst s p -> In x (vars_of_pattern p) -> value_size (s x) <= value_size v.

Lemma max_size_image_subst_bounded :
  forall t s, max_size_image_subst t s <= term_size (subst s t).

Definition activation_bound (prog : list rule) : nat -> nat :=
  fun x => max_rhs prog * (1 + x).

Lemma activation_bound_monotone (prog : list rule) :
  forall x y, x <= y -> activation_bound prog x <= activation_bound prog y.

Definition nb_rhs_functions (r: rule) :=
  match r with
    | rule_intro _ _ t => length (functions_of_term t)
  end.

Definition max_nb_rhs_functions (prog : list rule) : nat :=
  maxl (map nb_rhs_functions prog).

Lemma no_func_in_pattern p:
  functions_of_term (term_from_pattern p) = [].

Lemma no_funcs_in_patterns l:
  flat_map functions_of_term (map term_from_pattern l) = [].

End Syntax.

Arguments var [variable function constructor].

Arguments p_var [variable constructor]. *)
(* Cecoa.Ordering:
Require Import Arith NPeano List Bool Psatz.
Require Import Cecoa.Lib Cecoa.Syntax Cecoa.CBV_cache.
Require Import Omega.

Import List.ListNotations.
Infix "∈" := In (at level 70).

Section Ordering.

Set Implicit Arguments.

Variables variable function constructor : Type.

Notation value := (Syntax.value constructor).
Notation term := (Syntax.term variable function constructor).
Notation pattern := (Syntax.pattern variable constructor).
Notation rule := (Syntax.rule variable function constructor).
Notation cbv := (CBV_cache.cbv variable function constructor).
Notation cache := (CBV_cache.cache variable function constructor).

Variable variable_eq_dec : forall (x1 x2 : variable), {x1=x2}+{x1<>x2}.

Variable function_eq_dec : forall (x1 x2 : function), {x1=x2}+{x1<>x2}.

Variable constructor_eq_dec : forall (x1 x2 : constructor), {x1=x2}+{x1<>x2}.

Variable rule_default : rule.

Variable prog : list rule.

Variable max_arity : nat.

Notation wf :=
  (CBV_cache.wf variable_eq_dec function_eq_dec constructor_eq_dec rule_default prog max_arity).

Variable rank: function -> nat.

Inductive product {A: Type} (R : A -> A -> Prop) : list A -> list A -> Prop :=
| product_conseq : forall x y xs ys, x = y -> product R xs ys   -> product R (x::xs) (y::ys)
| product_consst : forall x y xs ys, R x y -> Forall2 (clos_refl R) xs ys -> product R (x::xs) (y::ys).

Inductive PPO: term -> term -> Prop :=
| ppo_constr_in    : forall s c lt,    In s lt            -> PPO s (capply c lt)
| ppo_fun_in       : forall s f lt,    In s lt            -> PPO s (fapply f lt)
| ppo_constr_sub   : forall s t c lt,  In t lt -> PPO s t -> PPO s (capply c lt)
| ppo_fun_sub      : forall s t f lt,  In t lt -> PPO s t -> PPO s (fapply f lt)
| ppo_constr_split : forall c ls f lt, (forall s, In s ls -> PPO s (fapply f lt))
                                       -> PPO (capply c ls) (fapply f lt)
| ppo_funlt_split  : forall g ls f lt, rank g < rank f
                                       -> (forall s, In s ls -> PPO s (fapply f lt))
                                       -> PPO (fapply g ls) (fapply f lt)
| ppo_funeqv_split : forall g ls f lt, rank g = rank f
                                       -> product PPO ls lt
                                       -> PPO (fapply g ls) (fapply f lt).

Infix "≺ppo" := PPO (at level 80).
Infix "≼ppo" := (clos_refl PPO) (at level 80).

Hint Constructors product PPO.

Definition lt_wf_rect (n : nat) (P : nat -> Type)
  (F : forall n, (forall m, m < n -> P m) -> P n) : P n :=
  well_founded_induction_type (well_founded_ltof nat (fun m => m)) P F n.

Definition term_dec (t1 t2 : term) : {t1=t2}+{t1<>t2}.

Lemma Exists_dec_gen :
  forall {A : Type} (P : A -> Prop) (l : list A),
  (forall x : A, In x l -> {P x} + {~ P x}) -> {Exists P l} + {~ Exists P l}.

Lemma Forall_dec_gen :
  forall {A : Type} (P : A -> Prop) (l : list A),
  (forall x : A, In x l -> {P x} + {~ P x}) -> {Forall P l} + {~ Forall P l}.

Lemma Forall2_dec_gen :
  forall {A B : Type} (R : A -> B -> Prop) (xs : list A) (ys : list B),
  (forall x y, In x xs -> In y ys -> {R x y}+{~R x y}) ->
  {Forall2 R xs ys}+{~Forall2 R xs ys}.

Lemma clos_refl_dec {A : Type} (A_dec : forall x y:A, {x=y}+{x<>y})
  (R : A -> A -> Prop) (x y : A) (R_dec : {R x y}+{~R x y}) :
  {clos_refl R x y}+{~(clos_refl R) x y}.

Lemma product_dec (A : Type) (A_dec : forall x y:A, {x=y}+{x<>y})
  (R : A -> A -> Prop) (xs ys : list A)
  (R_dec : forall x y, In x xs -> In y ys -> {R x y}+{~R x y}) :
  {product R xs ys}+{~product R xs ys}.

Lemma PPO_dec t1 t2: {PPO t1 t2}+{~PPO t1 t2}.

Lemma product_length A (R: A -> A -> Prop) xs ys :
  product R xs ys -> length xs = length ys.

Lemma product_Forall2 A (R: A -> A -> Prop) ls lt : product R ls lt -> Forall2 (clos_refl R) ls lt.

Lemma product_Exists2 A (R: A -> A -> Prop) ls lt : product R ls lt -> Exists2 R ls lt.

Definition PPO_rule (r: rule) : Prop :=
  match r with
    | rule_intro f lp t => PPO t (fapply f (map (@term_from_pattern _ _ _) lp))
  end.

Definition PPO_prog : Prop :=
  forall r, In r prog -> PPO_rule r.

Lemma value_PPO_function (v: value) (f: function) (lt: list term) :
  PPO (@term_from_value _ _ _ v) (fapply f lt).

Lemma product_trans (A: Type) (R : A -> A -> Prop) lt1 lt2 lt3 :
    (forall t1 t2 t3, In t1 lt1 -> In t2 lt2 -> In t3 lt3 -> R t1 t2 -> R t2 t3 -> R t1 t3) ->
    product R lt1 lt2 -> product R lt2 lt3 -> product R lt1 lt3.

Lemma PPO_trans t1 t2 t3 : PPO t1 t2 -> PPO t2 t3 -> PPO t1 t3.

Lemma PPO_trans_eq t1 t2 t3 : clos_refl PPO t1 t2 -> PPO t2 t3 -> PPO t1 t3.

Lemma PPO_trans_eq_r t1 t2 t3 : PPO t1 t2 -> clos_refl PPO t2 t3 -> PPO t1 t3.

Lemma PPO_asym t1 t2 : PPO t1 t2 -> ~ PPO t2 t1.

Lemma PPO_irrefl t : ~PPO t t.

Lemma PPO_term_pattern_subst p t s :
  PPO t (@term_from_pattern _ _ _ p) ->
  PPO (subst s t) (@term_from_value _ _ _ (psubst s p)).

Lemma fapply_not_PPO_value f lt v :
  term_value v -> ~ PPO (fapply f lt) v.

Lemma fapply_not_PPO_pattern f lt p :
  ~ PPO (fapply f lt) (@term_from_pattern _ _ _ p).

Lemma PPO_rule_PPO_instance s f lp t :
  PPO_rule (rule_intro f lp t) ->
  PPO (subst s t) (fapply f (map (@term_from_value _ _ _) (map (psubst s) lp))).

Lemma PPO_rule_instance i s p c1 t c2 v :
  PPO_prog ->
  wf (cbv_update i s p c1 t c2 v) ->
  PPO (proj_left p) t.

Definition activation_rank (p : cbv) : nat :=
  match p with
  | cbv_update _ _ _ _ (fapply f _) _ _ => rank f
  | _                                   => 0
  end.

Lemma fapplies_rec_PPO t t': In t (fapplies_in_term t') -> clos_refl PPO t t'.

Lemma PPO_value_is_value t v : PPO t v -> term_value v -> term_value t.

Lemma PPO_activation_le_rank f1 lt1 f2 lv2 :
  PPO (fapply f1 lt1) (fapply f2 (map (@term_from_value _ _ _) lv2)) -> rank f1 <= rank f2.

Lemma PPO_pattern_le_rank f1 lt1 f2 lp2 :
  PPO (fapply f1 lt1) (fapply f2 (map (@term_from_pattern _ _ _) lp2)) -> rank f1 <= rank f2.

Lemma subfapplies_activation_le_rank i s p c1 f lt c2 v f' lt' :
  let proof_tree := cbv_update i s p c1 (fapply f lt) c2 v in
  PPO_prog -> wf proof_tree ->
  In (fapply f' lt') (fapplies_in_term (proj_left p)) ->
  rank f' <= rank f.

Lemma le_rank_first_activation i s p c1 t c2 v p' :
  let proof_tree := cbv_update i s p c1 t c2 v in
  PPO_prog -> wf proof_tree ->
  In p' (first_activations proof_tree) ->
  activation_rank p' <= activation_rank proof_tree.

Lemma PPO_first_activations i s p c1 t c2 v p' :
  let proof_tree := cbv_update i s p c1 t c2 v in
  PPO_prog -> wf proof_tree ->
  In p' (first_activations proof_tree) ->
  PPO (proj_left p') (proj_left proof_tree).

Lemma PPO_activations i s p c1 t c2 v p' :
  let proof_tree := cbv_update i s p c1 t c2 v in
  PPO_prog -> wf proof_tree ->
  In p' (activations proof_tree) ->
  p' = proof_tree \/ PPO (proj_left p') (proj_left proof_tree).

End Ordering.

Lemma same_rank_same_prod vv ff cc lt ls rk rk':
  (forall t s, In t lt -> In s ls ->
      (forall f, In f (functions_of_term t) -> rk f = rk' f) ->
      (forall f, In f (functions_of_term s) -> rk f = rk' f) ->
      PPO rk t s -> PPO rk' t s) ->
  (forall f, In f (flat_map (@functions_of_term vv ff cc) lt) -> rk f = rk' f) ->
  (forall f, In f (flat_map (@functions_of_term _ _ _) ls) -> rk f = rk' f) ->
  product (PPO rk) lt ls -> product (PPO rk') lt ls.

Hint Constructors PPO.

Lemma same_rank_same_ppo vv ff cc (t : term vv ff cc) s rk rk':
  (forall f, In f (functions_of_term t) -> rk f = rk' f) ->
  (forall f, In f (functions_of_term s) -> rk f = rk' f) ->
  PPO rk t s -> PPO rk' t s.

Lemma same_rank_same_ppo_rule vv ff cc f lp (t : term vv ff cc) rk rk':
  rk f = rk' f ->
  (forall g, g ∈ (functions_of_term t) -> rk g = rk' g) ->
  PPO rk t (fapply f (map (@term_from_pattern _ _ _) lp)) ->
  PPO rk' t (fapply f (map (@term_from_pattern _ _ _) lp)).

Ltac ppo variable_eq_dec function_eq_dec constructor_eq_dec :=
match goal with
| |- PPO ?rk ?t1 ?t2 =>
    let t := eval compute in (@PPO_dec _ _ _ variable_eq_dec function_eq_dec constructor_eq_dec rk t1 t2) in
    match t with
    | left ?H => try exact H
    | _ => let t := constr:(pair t1 t2) in idtac t
    end
end. *)
(* Cecoa.QI:
Require Import Le Max List Bool Cecoa.Lib Cecoa.Syntax Cecoa.CBV_cache NPeano Omega Cecoa.OptionMonad.

Section QI.

Variables variable function constructor : Type.

Notation value := (Syntax.value constructor).
Notation term := (Syntax.term variable function constructor).
Notation pattern := (Syntax.pattern variable constructor).
Notation rule := (Syntax.rule variable function constructor).
Notation term_from_value := (Syntax.term_from_value variable function (constructor:=constructor)).
Notation term_from_pattern := (Syntax.term_from_pattern (variable:=variable) function (constructor:=constructor)).
Variable prog : list rule.
Variable max_arity:nat.
Variable rule_default : rule.

Variable variable_eq_dec : forall (x1 x2 : variable), {x1=x2}+{x1<>x2}.
Variable function_eq_dec : forall (x1 x2 : function), {x1=x2}+{x1<>x2}.
Variable constructor_eq_dec : forall (x1 x2 : constructor), {x1=x2}+{x1<>x2}.

Notation cache := (CBV_cache.cache variable function constructor).
Notation cache_path := (CBV_cache.cache_path variable_eq_dec function_eq_dec constructor_eq_dec).

Notation cache_path_transitivity := 
           (@CBV_cache.cache_path_transitivity _ _ _ variable_eq_dec function_eq_dec constructor_eq_dec).
Notation cache_path_transitivity_left :=
           (@CBV_cache.cache_path_transitivity_left _ _ _ variable_eq_dec function_eq_dec constructor_eq_dec).
Notation cbv := (CBV_cache.cbv variable function constructor).
Notation wf := (CBV_cache.wf variable_eq_dec  function_eq_dec constructor_eq_dec rule_default
                prog max_arity).

Definition assignment_constructor := constructor -> list nat -> nat.
Definition assignment_function := function -> list nat -> nat.

Variable mcs: nat.

Definition constructor_non_zero cs :=
   forall c:constructor, cs  c > 0. 

Definition additive (qic:assignment_constructor) cs :=
   forall c:constructor, forall l, qic c l=(suml l)+(cs c).

Definition mcs_is_max_constructor_size cs :=
    forall c:constructor, cs c <= mcs.

Lemma monotonicity_qic qic cs: additive qic cs -> forall c:constructor,
  forall lx ly, Forall2 le lx ly -> qic c lx <= qic c ly.

Fixpoint value_assignment (qic:assignment_constructor) (v:value) {struct v}:=
   match v with
  | c_capply c lv => qic c (map (value_assignment qic) lv)
   end.

Lemma value_size_le_QI qic cs: 
  additive qic cs -> constructor_non_zero cs ->
  forall v:value, value_size v <= value_assignment qic v.

Lemma QI_le_value_size qic cs: 
  additive qic cs -> mcs_is_max_constructor_size cs ->
  forall v:value, 
  value_assignment qic v <= mcs*(value_size v).

Definition subterm (qif:assignment_function) := forall f l x, In x l -> x <= qif f l.

Definition monotonicity_qif (qif:assignment_function) :=
  forall f lx ly, Forall2 le lx ly -> qif f lx <= qif f ly.

Fixpoint term_assignment (qic:assignment_constructor) (qif:assignment_function)
(t:term) {struct t}:=
   match t with
  | var v=> 0 
  | capply c lt => qic c (map (term_assignment qic qif) lt)
  | fapply f lt=> qif f (map (term_assignment qic qif)  lt) 
 end.

Definition compatible_QI qic qif := forall f lp t, forall s:variable -> value,
  let ru := rule_intro f lp t in 
  (In ru prog) -> 
  term_assignment qic qif (subst s t) <= term_assignment qic qif (subst s (lhs_of_rule ru)). 
  
Definition valid_QI qic qif cs :=
  (additive qic cs) /\ (mcs_is_max_constructor_size cs) /\ (constructor_non_zero cs) /\
  (subterm qif) /\ (monotonicity_qif qif) /\ (compatible_QI qic qif).

Definition cache_bounded qic qif (c:cache): Prop  := 
  Forall (fun t => value_assignment qic (snd t) <= term_assignment qic qif (fst t)) c.

Lemma value_as_term_assignment qic qif: forall v:value,
  (term_assignment qic qif (term_from_value v)) = (value_assignment qic v).

Lemma qi_fapply_right_le_qi_fapply_left qic qif : forall proof_tree lp f c1,
  monotonicity_qif qif ->
  let l := map (proj_left (constructor:=constructor)) lp in
  let l' := map term_from_value (map (proj_right (constructor:=constructor)) lp) in
  let c := cache_left proof_tree in let v := proj_right proof_tree in
  (forall p, In p lp -> cache_bounded qic qif (cache_left p) -> 
             value_assignment qic (proj_right p) <= term_assignment qic qif (proj_left p) /\ 
             cache_bounded qic qif (cache_right p)) ->
  cache_bounded qic qif c1 -> cache_path c1 c lp = true -> andl (map wf lp) -> 
  (term_assignment qic qif (fapply f l')) <= (term_assignment qic qif (fapply f l)).

Lemma qi_right_le_qi_fapply_left qic qif: forall proof_tree lp f c1,
  monotonicity_qif qif -> wf proof_tree ->
  let l := map (proj_left (constructor:=constructor)) lp in
  let l' := map term_from_value (map (proj_right (constructor:=constructor)) lp) in
  let c := cache_left proof_tree in let c' := cache_right proof_tree in
  let v := proj_right proof_tree in
  proj_left proof_tree = fapply f l' -> 
  (forall p, In p lp -> cache_bounded qic qif (cache_left p) -> wf p ->
             value_assignment qic (proj_right p) <= term_assignment qic qif (proj_left p) /\ 
             cache_bounded qic qif (cache_right p)) ->
  (cache_bounded qic qif c -> value_assignment qic v <= term_assignment qic qif (fapply f l')) ->
  cache_bounded qic qif c1 -> cache_bounded qic qif c' -> cache_path c1 c lp = true ->
    andl (map wf lp) -> 
  value_assignment qic v <= term_assignment qic qif (fapply f l).

Lemma left_bound_to_right_bound qic qif cs:forall pi:cbv,
    valid_QI qic qif cs -> (wf pi) ->
    cache_bounded qic qif (cache_left pi) ->
    (value_assignment qic (proj_right pi) <= term_assignment qic qif (proj_left pi)
     /\ cache_bounded qic qif (cache_right pi)).

Lemma QI_never_increase_global qic qif cs: forall pi proof_tree:cbv, 
  valid_QI qic qif cs -> wf proof_tree -> 
  cache_bounded qic qif (cache_left proof_tree) -> InCBV pi proof_tree -> 
  term_assignment qic qif (proj_left pi) <= term_assignment qic qif (proj_left proof_tree).

Lemma cache_left_bounded_global qic qif cs: forall pi proof_tree:cbv,
  valid_QI qic qif cs -> wf proof_tree -> 
  cache_bounded qic qif (cache_left proof_tree) -> InCBV pi proof_tree ->
  cache_bounded qic qif (cache_left pi).

Definition judgsize (p:cbv) := term_size (proj_left p) + value_size (proj_right p).

Lemma qi_active_bounded_by_size qic qif cs: forall f lval lt,
  valid_QI qic qif cs ->
  let t :=  (fapply f lt) in
  let l := (map (fun x=> mcs * (term_size t)) lt) in
    lt = map term_from_value lval ->
  term_assignment qic qif t <= (qif f l).

Lemma active_size_bound qic qif cs: forall i sub p c f lv d v, forall pi,
  valid_QI qic qif cs ->
  let t :=  (fapply f lv) in
  let proof_tree := cbv_update i sub p c t d v in 
  let l:= (map (fun x=> mcs * (term_size t)) lv) in
  wf proof_tree -> In pi (activations proof_tree) -> cache_bounded qic qif c -> 
  judgsize pi <= (max_arity + 1) * (qif f l) + 1.

Lemma active_size_bound_max qic qif cs: forall i s p c f lv d v,
  valid_QI qic qif cs ->
  let t :=  (fapply f lv) in
  let pi := cbv_update i s p c t d v in 
  let la := (activations pi)  in
  let l:= (map (fun x=> mcs * (term_size t)) lv) in
  wf pi -> cache_bounded qic qif c -> forall la', incl la' la -> 
  maxl (map judgsize la') <= (max_arity + 1) * qif f l + 1.

Lemma max_active_size_sublist: forall c c' lp lp',
  andl (map wf lp) -> cache_path c c' lp = true -> incl lp' lp ->
  (forall p : cbv, In p lp -> wf p ->
   max_active_size p <= maxl (map judgsize (activations p))) ->
   maxl (map (@max_active_size _ _ _) lp') <= 
   maxl (map judgsize (flat_map (activations (constructor:=constructor)) lp')).

Lemma max_active_size_is_max: forall pi,
   let S := max_active_size pi in
   wf pi -> S <= maxl (map judgsize (activations pi)).

Theorem max_active_size_bound qic qif cs: forall i s p c f lv d v,
  valid_QI qic qif cs ->
  let t :=  (fapply f lv) in
  let pi := cbv_update i s p c t d v in 
  let l:= (map (fun x=> mcs * (term_size t)) lv) in
  let S := max_active_size pi in
  wf pi -> cache_bounded qic qif c -> S <= (max_arity + 1) * (qif f l) + 1.

Definition p_assignment_function := function -> option(list nat -> nat).

Fixpoint p_term_assignment (qic:assignment_constructor) (qif:p_assignment_function)
(t:term) {struct t} : option nat:=
   match t with
  | var v=> Some 0 
  | capply c lt => option_map (qic c) (option_list_map(map (p_term_assignment qic qif) lt))
  | fapply f lt=> option_bind (fun g => option_map g (option_list_map(map (p_term_assignment qic qif)  lt)))
                              (qif f)
end.

Definition complete_p_QI (qif : p_assignment_function) f := 
  complete_option maxl (qif f).

Lemma p_term_assignment_term_assignment qic qif t v:
  p_term_assignment qic qif t = Some v ->
  term_assignment qic (complete_p_QI qif) t = v.

Definition p_compatible_QI qic qif:= forall f lp t, forall s:variable -> value,
  let ru := rule_intro f lp t in
  (In ru prog) -> 
    p_term_assignment qic qif (subst s t) ≤p 
    p_term_assignment qic qif (subst s (lhs_of_rule ru)).

Lemma p_compatible_compatible qic:
  {pqif | p_compatible_QI qic pqif} -> {qif | compatible_QI qic qif}.

Lemma p_term_assignment_ext qic f f': 
 (forall x, f x = f' x) ->
 forall t, p_term_assignment qic f t= p_term_assignment qic f' t.

Lemma p_compatible_QI_ext qic f f': 
 (forall x, f x = f' x) ->
 p_compatible_QI qic f ->
 p_compatible_QI qic f'.

Lemma p_compatible_QI_split qic f h:
  {g | p_compatible_QI qic (f;;h;;g)} -> {g | p_compatible_QI qic (f;;g)}.

Lemma p_term_assignment_first_choice qic f t v:
  p_term_assignment qic f t = Some v ->
  forall g, p_term_assignment qic (f;;g) t = Some v.

Lemma value_as_p_term_assignment qic qif: forall v:value,
  (p_term_assignment qic qif (term_from_value v)) = Some (value_assignment qic v).

Definition p_subterm (qif : p_assignment_function) : Prop :=
forall (f : function) (l : list nat) (x : nat), x ∈ l ->
  match qif f with 
  | None => True 
  | Some f0 => (x <= f0 l)
  end.

Definition p_monotonicity (qif : p_assignment_function) : Prop :=
  forall (f : function) (lx ly : list nat),
    Forall2 le lx ly -> 
    match qif f with 
    | None => True 
    | Some f0 => f0 lx <= f0 ly
    end.

Definition p_smc qic (qif : p_assignment_function) : Prop :=
 p_subterm qif /\ p_monotonicity qif /\ p_compatible_QI qic qif.

Lemma p_smc_split f h qic:
  {g | p_smc qic (f;;h;;g)} -> {g | p_smc qic (f;;g)}.

Lemma p_smc_smc qic :
  {pqif | p_smc qic ((fun _ => None);; pqif)} -> 
  {qif | subterm qif /\ monotonicity_qif qif /\ compatible_QI qic qif}.

End QI.

Section Partial_QI.

Variables variable function constructor : Type.

Notation p_compatible_QI := (p_compatible_QI variable function constructor).
Notation term_from_value := (Syntax.term_from_value variable function (constructor:=constructor)).
Notation p_smc := (p_smc variable function constructor).

Lemma p_compatible_QI_app f prog1 prog2 qic:
  p_compatible_QI prog1 qic f ->
  {g | p_compatible_QI prog2 qic (f;;g)} ->
  {g | p_compatible_QI (prog1 ++ prog2) qic (f;;g)}.

Lemma p_smc_QI_app f prog1 prog2 qic:
  p_compatible_QI prog1 qic f ->
  {g | p_smc prog2 qic (f;;g)} ->
  {g | p_smc (prog1 ++ prog2) qic (f;;g)}.

End Partial_QI. *)
Require Import Cecoa.CBV_cache Cecoa.Final.
(* Cecoa.CBV_cache:
Require Import Omega Psatz.
Require Import Bool Arith Compare_dec Max List Permutation.
Import List.ListNotations.
Require Import Cecoa.Lib Cecoa.Syntax.

Set Implicit Arguments.
Unset Strict Implicit.

Section CBV.

Variables variable function constructor : Type.

Variable variable_eq_dec : forall (x1 x2 : variable), {x1=x2}+{x1<>x2}.

Variable function_eq_dec : forall (x1 x2 : function), {x1=x2}+{x1<>x2}.

Variable constructor_eq_dec : forall (x1 x2 : constructor), {x1=x2}+{x1<>x2}.

Notation value := (Syntax.value constructor).
Notation term := (Syntax.term variable function constructor).
Notation pattern := (Syntax.pattern variable constructor).
Notation rule := (Syntax.rule variable function constructor).
Notation term_beq := (term_beq variable_eq_dec function_eq_dec constructor_eq_dec).

Definition cache : Type := list (term * value).

Notation assoc_cache := (assoc term_beq).

Definition cache_beq (C C' : cache) : bool :=
  list_beq _ (prod_beq _ _ term_beq (value_beq constructor_eq_dec)) C C'.

Lemma cache_beq_eq c1 c2 : cache_beq c1 c2 = true <-> c1 = c2.

Lemma function_beq_refl (f : function) :
  forall p, function_beq p f f = true.

Lemma value_beq_refl (v : value) :
  value_beq constructor_eq_dec v v = true.

Lemma cache_beq_refl C :
  cache_beq C C = true.

Inductive cbv : Type :=
| cbv_constr : list cbv -> cache -> term -> cache -> value -> cbv
| cbv_split : list cbv -> cbv -> cache -> term -> cache -> value -> cbv
| cbv_update : nat -> (variable -> value) -> cbv -> cache -> term -> cache -> value -> cbv
| cbv_read : cache -> term -> value -> cbv.

Lemma cbv_ind2_gen :
  forall (P : cbv -> Prop)(Q : list cbv -> Prop),
  Q nil ->
  (forall p lp, P p -> Q lp -> Q (p :: lp)) ->
  (forall lp c1 t c2 v, Q lp -> P (cbv_constr lp c1 t c2 v)) ->
  (forall lp p c1 t c2 v, Q lp -> P p -> P (cbv_split lp p c1 t c2 v)) ->
  (forall n s p c1 t c2 v, P p -> P (cbv_update n s p c1 t c2 v)) ->
  (forall c t v, P (cbv_read c t v)) ->
  forall p, P p.

Lemma cbv_ind2 :
  forall (P : cbv -> Prop),
  (forall lp c1 t c2 v, (forall p, In p lp -> P p) -> P (cbv_constr lp c1 t c2 v)) ->
  (forall lp p c1 t c2 v, (forall p, In p lp -> P p) -> P p -> P (cbv_split lp p c1 t c2 v)) ->
  (forall n s p c1 t c2 v, P p -> P (cbv_update n s p c1 t c2 v)) ->
  (forall c t v, P (cbv_read c t v)) ->
  forall p, P p.

Fixpoint InCBV p proof_tree : Prop :=
  p = proof_tree \/
  match proof_tree with
      | cbv_constr lp _ _ _ _ => orl (map (InCBV p) lp)
      | cbv_split lp p' _ _ _ _ => InCBV p p' \/ orl (map (InCBV p) lp)
      | cbv_update _ _ p' _ _ _ _ => InCBV p p'
      | cbv_read _ _ _ => False
  end.

Lemma InCBV_refl p : InCBV p p.

Lemma InCBV_trans p p' p'': InCBV p p' -> InCBV p' p'' -> InCBV p p''.

Lemma cbv_reverse_induction :
  forall (P : cbv -> Prop) proof_tree,
  P proof_tree ->
  (forall lp c1 t c2 v, InCBV (cbv_constr lp c1 t c2 v) proof_tree -> P (cbv_constr lp c1 t c2 v) -> forall p, In p lp -> P p) ->
  (forall lp p c1 t c2 v, InCBV (cbv_split lp p c1 t c2 v) proof_tree -> P (cbv_split lp p c1 t c2 v) -> forall p', (p' = p \/ In p' lp) -> P p') ->
  (forall i s p c1 t c2 v, InCBV (cbv_update i s p c1 t c2 v) proof_tree -> P (cbv_update i s p c1 t c2 v) -> P p) ->
  forall p, InCBV p proof_tree -> P p.

Definition rule_subst_of_cbv_update ( subst_default : variable -> value) (proof_tree : cbv) : nat * (variable -> value) :=
  match proof_tree with
  | cbv_update i s _ _ _ _ _ => (i, s)
  | _ => (0, subst_default) 
  end.

Definition proj_left (proof_tree : cbv) : term :=
  match proof_tree with
    | cbv_constr _ _ t _ _ => t
    | cbv_split _ _ _ t _ _ => t
    | cbv_update _ _ _ _ t _ _ => t
    | cbv_read _ t _ => t
  end.

Definition proj_right (proof_tree : cbv) : value :=
  match proof_tree with
    | cbv_constr _ _ _ _ v => v
    | cbv_split _ _ _ _ _ v => v
    | cbv_update _ _ _ _ _ _ v => v
    | cbv_read _ _ v => v
  end.

Definition cache_left (proof_tree : cbv) : cache :=
  match proof_tree with
    | cbv_constr _ c _ _ _ => c
    | cbv_split _ _ c _ _ _ => c
    | cbv_update _ _ _ c _ _ _ => c
    | cbv_read c _ _ => c
  end.

Definition cache_right (proof_tree : cbv) : cache :=
  match proof_tree with
    | cbv_constr _ _ _ c _ => c
    | cbv_split _ _ _ _ c _ => c
    | cbv_update _ _ _ _ _ c _ => c
    | cbv_read c _ _ => c
  end.

Fixpoint cache_path (C C' : cache)(l : list cbv) : bool :=
  match l with
  | nil => cache_beq C C' 
  | p :: l' => cache_beq C (cache_left p) && cache_path (cache_right p) C' l'
  end.

Lemma cache_path_cons c1 c2 p lp :
  cache_path c1 c2 (p :: lp) = true <->
  cache_path c1 (cache_right p) [p] = true /\ cache_path (cache_right p) c2 lp = true.

Lemma cache_path_app c1 c2 lp p lp' :
  cache_path c1 c2 (lp ++ p :: lp') = true <-> 
  cache_path c1 (cache_left p) lp = true /\ cache_path (cache_left p) c2 (p :: lp') = true.

Lemma cache_path_ind (P : cache -> cache -> list cbv -> Prop) C :
  (P C C []) ->
  (forall p lp, cache_path (cache_left p) C (p :: lp) = true -> P (cache_right p) C lp ->
   P (cache_left p) C (p :: lp)) ->
  forall lp C', cache_path C' C lp = true -> P C' C lp.

Lemma cache_path_revflatten c1 c2 lp Clp :
  cache_path c1 c2 lp = true ->
  Forall2 (fun p C => cache_right p = C ++ cache_left p) lp Clp ->
  c2 = revflatten Clp ++ c1.

Lemma cache_path_transitivity_left c c' l: forall P:cache-> Prop, 
      cache_path c c' l = true ->
      P c ->(forall p, In p l -> 
      P (cache_left p) ->  
      P (cache_right p)) -> 
     (forall p, In p l -> P (cache_left p)).

Lemma cache_path_transitivity c c' l: forall P:cache-> Prop, 
      cache_path c c' l = true ->
      P c ->(forall p, In p l -> 
      P (cache_left p) ->  
      P (cache_right p)) -> P c'.

Fixpoint cache_lookup (C: cache) (t: term) : term :=
  match t with
  | var _       => t
  | capply c lt => capply c (map (cache_lookup C) lt)
  | fapply f lt => match assoc_cache (fapply f (map (cache_lookup C) lt)) C with
                   | Some v => @term_from_value _ _ _ v
                   | None   => t
                   end
  end.

Lemma cache_lookup_value (C: cache) (v: value):
  let t := @term_from_value _ _ _ v in cache_lookup C t = t.

Lemma map_cache_lookup_value (C: cache) (lv: list value):
  let lt := map (@term_from_value _ _ _) lv in map (cache_lookup C) lt = lt.

Variable rule_default : rule.

Variable prog : list rule.

Variable max_arity : nat.

Fixpoint wf (proof_tree : cbv) : Prop :=
  match proof_tree with
    | cbv_constr l C (capply c lt) C' (c_capply c' lv) =>
        cache_path C C' l = true /\
        c = c' /\
        lt = map proj_left l /\ lv = map proj_right l /\
        andl (map wf  l) /\ List.length l <= max_arity
    | cbv_split l ((cbv_update _ _ _ C' (fapply f lv) C'' v) as p) C (fapply f' lt) C''' v' =>
        C''' = C'' /\
        cache_path C C' l = true /\
        lt = map proj_left l /\ lv = map (@term_from_value _ _ _) (map proj_right l) /\
        andl (map wf  l) /\
        f = f' /\ v = v' /\
        wf  p /\ length l <= max_arity
    | cbv_split l ((cbv_read C' (fapply f lv) v) as p) C (fapply f' lt) C'' v' =>
        C'' = C' /\
        cache_path C C' l = true /\
        lt = map proj_left l /\ lv = map (@term_from_value _ _ _) (map proj_right l) /\
        andl (map wf  l) /\
        f = f' /\ v = v' /\
        wf  p /\ length l <= max_arity
    | cbv_update i s p C (fapply f lv as t0) C' v =>
        assoc term_beq t0 C = None /\
        exists lp t,
        i < length prog /\
        nth i prog rule_default = rule_intro f lp t /\
        lv = map (@term_from_value _ _ _) (map (psubst s) lp) /\
        proj_left p = subst s t /\ proj_right p = v /\
        cache_left p = C /\  True /\
        C' = (t0, v) :: cache_right p /\ 
        wf  p /\ length lv <= max_arity
    | cbv_read C (fapply _ lv as t) v =>
        assoc term_beq t C = Some v /\
        exists lv', lv = map (@term_from_value _ _ _) lv'
    | _ => False
  end.

Lemma wf_cbv_update i s p c1 t c2 v : wf (cbv_update i s p c1 t c2 v) -> wf p.

Lemma wf_InCBV_wf p proof_tree: wf proof_tree -> InCBV p proof_tree -> wf p.

Definition cache_size (c : cache) : nat :=
  suml (map (fun tv => term_size (fst tv) + value_size (snd tv)) c).

Fixpoint size_rec (proof_tree : cbv) : nat :=
  match proof_tree with
  | cbv_constr l c1 t c2 v => term_size t + value_size v + suml (map size_rec l)
  | cbv_split l p c1 t c2 v => term_size t + value_size v + size_rec p + suml (map size_rec l)
  | cbv_update _ _ p c1 t c2 v => size_rec p + term_size t + value_size v
  | cbv_read c t v => term_size t + value_size v
  end.

Definition size (proof_tree : cbv) : nat :=
  size_rec proof_tree + cache_size (cache_left proof_tree).

Fixpoint max_active_size (proof_tree : cbv) : nat :=
  match proof_tree with
  | cbv_constr lp _ _ _ _ => maxl (map max_active_size lp)
  | cbv_split lp p _ _ _ _ => max (max_active_size p) (maxl (map max_active_size lp)) 
  | cbv_update _ _ p _ t _ v => max (term_size t + value_size v) (max_active_size p)
  | cbv_read c t v => 0
  end.

Fixpoint max_judgement_size (proof_tree : cbv) : nat :=
  match proof_tree with
  | cbv_constr lp c1 t c2 v => max (term_size t + value_size v) (maxl (map max_judgement_size lp))
  | cbv_split lp p c1 t c2 v => max (term_size t + value_size v) (max (max_judgement_size p) (maxl (map max_judgement_size lp)))
  | cbv_update _ _ p c1 t c2 v => max (term_size t + value_size v) (max_judgement_size p)
  | cbv_read c t v => term_size t + value_size v
  end.

Fixpoint sub_trees (proof_tree : cbv) : list cbv :=
  proof_tree :: (
    match proof_tree with
    | cbv_constr lp _ _ _ _ => flat_map sub_trees lp
    | cbv_split lp p _ _ _ _ => flat_map sub_trees (p :: lp)
    | cbv_update _ _ p _ _ _ _ => sub_trees p
    | cbv_read _ _ _ => []
    end ).

Lemma sub_trees_neq_nil : forall p, sub_trees p <> [].

Lemma InCBV_In_sub_trees p p' : InCBV p p' <-> In p (sub_trees p').

Lemma sub_trees_size_rec_le p proof_tree :
  In p (sub_trees proof_tree) -> size_rec p <= size_rec proof_tree.

Fixpoint proj_left_max_size_list (default : cbv) (proof_trees : list cbv) : cbv :=
  match proof_trees with
    | [] => default
    | [p] => p
    | p :: ps =>
      let p' := proj_left_max_size_list default ps in
      if leb (term_size (proj_left p)) (term_size (proj_left p')) then p' else p
  end.

Lemma In_proj_left_max_size_list p lp : lp <> [] -> In (proj_left_max_size_list p lp) lp.

Lemma proj_left_size_le_max_gen default proof_trees proof_tree:
  In proof_tree proof_trees ->
  term_size (proj_left proof_tree) <= term_size (proj_left (proj_left_max_size_list default proof_trees)).

Definition proj_left_max_size (proof_tree : cbv) : cbv :=
  proj_left_max_size_list (proof_tree) (sub_trees proof_tree).

Lemma proj_left_size_le_max proof_tree:
  forall p, InCBV p proof_tree ->
  term_size (proj_left p) <= term_size (proj_left (proj_left_max_size proof_tree)).

Lemma InCBV_proj_left_max_size p : InCBV (proj_left_max_size p) p.

Fixpoint max_proj_right_size (proof_tree : cbv) : nat :=
  match proof_tree with
  | cbv_constr lp _ t _ v => max (value_size v) (maxl (map max_proj_right_size lp))
  | cbv_split lp p _ t _ v => max (value_size v) (max (max_proj_right_size p) (maxl (map max_proj_right_size lp)))
  | cbv_update _ _ p _ t _ v => max (value_size v) (max_proj_right_size p)
  | cbv_read _ t v => value_size v
  end.

Lemma judgement_size_le_projs_size p :
  max_judgement_size p <= term_size (proj_left (proj_left_max_size p)) + max_proj_right_size p.

Fixpoint activations (proof_tree : cbv) : list cbv :=
  match proof_tree with
  | cbv_constr lp _ _ _ _ => flat_map activations lp
  | cbv_split lp p _ _ _ _ => activations p ++ flat_map activations lp
  | cbv_update _ _ p _ _ _ _ as p' => p' :: activations p
  | cbv_read _ _ _ => []
  end.

Fixpoint activations_cache_order (proof_tree : cbv) : list cbv :=
  match proof_tree with
  | cbv_constr lp _ _ _ _ => revflatten (map activations_cache_order lp)
  | cbv_split lp p _ _ _ _ => activations_cache_order p ++ revflatten (map activations_cache_order lp)
  | cbv_update _ _ p _ _ _ _ as p' => p' :: activations_cache_order p
  | cbv_read _ _ _ => []
  end.

Lemma activations_cache_order_are_activations (p: cbv) :
  Permutation (activations p) (activations_cache_order p).

Lemma activations_are_subtrees: forall p pi:cbv,
   In p (activations pi) -> In p (sub_trees pi).

Corollary activations_inCBV: forall p pi:cbv,
   In p (activations pi) -> InCBV p pi.

Definition functions_of_prog : list function :=
  map (fun x => match x with | rule_intro f _ _ => f end) prog.

Lemma activation_is_function :
  forall proof_tree p,
  In p (activations proof_tree) -> exists i s p' c1 t c2 v, p = cbv_update i s p' c1 t c2 v.

Lemma cbv_update_in_activations_InCBV proof_tree sub_proof_tree i s p c1 t c2 v:
  sub_proof_tree = cbv_update i s p c1 t c2 v ->
  InCBV sub_proof_tree proof_tree ->
  In sub_proof_tree (activations proof_tree).

Lemma activations_wf : forall proof_tree p, wf proof_tree -> In p (activations proof_tree) -> wf p.

Lemma le_max_active_size proof_tree p :
  In p (activations proof_tree) ->
  term_size (proj_left p) + value_size (proj_right p) <= max_active_size proof_tree.

Hypothesis prog_is_wf : wf_prog max_arity prog.

Lemma activation_bound_spec ( subst_default : variable -> value) :
  forall proof_tree, wf proof_tree -> forall p, In p (activations proof_tree) ->
  let (i, s) := rule_subst_of_cbv_update subst_default p in
  term_size (subst s (rhs_of_rule (nth i prog rule_default))) <= activation_bound prog (term_size (proj_left p)).

Fixpoint nb_judgements (proof_tree : cbv) : nat :=
  match proof_tree with
  | cbv_constr lp _ _ _ _ => 1 + suml (map nb_judgements lp)
  | cbv_split lp p _ _ _ _ => 1 + nb_judgements p + suml (map nb_judgements lp)
  | cbv_update _ _ p _ _ _ _ => 1 + nb_judgements p
  | cbv_read _ _ _=> 1
  end.

Fixpoint nb_judgements_sub_rec (proof_tree : cbv) : nat :=
  match proof_tree with
  | cbv_constr lp _ _ _ _ => 1 + suml (map nb_judgements_sub_rec lp)
  | cbv_split lp p _ _ _ _ => 1 + nb_judgements_sub_rec p + suml (map nb_judgements_sub_rec lp)
  | cbv_update _ _ _ _ _ _ _ => 0
  | cbv_read _ _ _ => 0
  end.

Definition nb_judgements_sub (proof_tree : cbv) : nat :=
  match proof_tree with
  | cbv_constr _ _ _ _ _ => 0
  | cbv_split _ _ _ _ _ _ => 0
  | cbv_update _ _ p _ _ _ _ => nb_judgements_sub_rec p
 | cbv_read _ _ _ => 0
  end.

Fixpoint nb_nodes (proof_tree : cbv) : nat :=
  match proof_tree with
  | cbv_constr [] _ _ _ _ => 0
  | cbv_constr lp _ _ _ _ => 1 + suml (map nb_nodes lp)
  | cbv_split lp p _ _ _ _ => 1 + nb_nodes p + suml (map nb_nodes lp)
  | cbv_update _ _ p _ _ _ _ => 1 + nb_nodes p
  | cbv_read _ _ _ => 0
  end.

Fixpoint nb_read (proof_tree : cbv) : nat :=
  match proof_tree with
  | cbv_constr lp _ _ _ _ => suml (map nb_read lp)
  | cbv_split lp p _ _ _ _ => nb_read p + suml (map nb_read lp)
  | cbv_update _ _ p _ _ _ _ => nb_read p
  | cbv_read _ _ _ => 1
  end.

Definition arity_cbv (proof_tree : cbv) : nat :=
  match proof_tree with
  | cbv_constr lp _ _ _ _  => length lp
  | cbv_split lp p _ _ _ _ => 1 + length lp
  | cbv_update _ _ p _ _ _ _ => 1
  | cbv_read _ _ _ => 0
  end.

Lemma wf_arity p : wf p -> arity_cbv p <= S max_arity.

Lemma nb_read_bound : forall p,
   wf p ->
  nb_read p <= S (max_arity * nb_nodes p).

Fixpoint first_activations_rec (proof_tree : cbv) : list cbv :=
  match proof_tree with
  | cbv_constr lp _ _ _ _ => flat_map first_activations_rec lp
  | cbv_split lp p _ _ _ _ => first_activations_rec p ++ flat_map first_activations_rec lp
  | cbv_update _ _ _ _ _ _ _ as p' => [p']
  | cbv_read _ _ _ => []
  end.

Definition first_activations (proof_tree : cbv) : list cbv :=
  match proof_tree with
  | cbv_constr lp _ _ _ _ => []
  | cbv_split lp p _ _ _ _ => []
  | cbv_update _ _ p _ _ _ _ => first_activations_rec p
  | cbv_read _ _ _ => []
  end.

Definition strict_activations (proof_tree: cbv) :=
  flat_map activations (first_activations proof_tree).

Lemma first_activation_rec_is_update proof_tree p :
  In p (first_activations_rec proof_tree) -> exists i s p' c1 t c2 v, p = cbv_update i s p' c1 t c2 v.

Lemma first_activation_is_update proof_tree p :
  In p (first_activations proof_tree) -> exists i s p' c1 t c2 v, p = cbv_update i s p' c1 t c2 v.

Lemma in_first_activations_rec_nb_judgements_le p proof_tree :
  In p (first_activations_rec proof_tree) -> nb_judgements p <= nb_judgements proof_tree.

Lemma in_first_activations_nb_judgements_lt p proof_tree :
  In p (first_activations proof_tree) -> nb_judgements p < nb_judgements proof_tree.

Lemma first_activations_rec_incl_activations (p: cbv) :
  incl (first_activations_rec p) (activations p).

Lemma first_activations_incl_activations (p: cbv) :
  incl (first_activations p) (activations p).

Fixpoint first_activations_and_semi_rec (proof_tree : cbv) : list cbv :=
  match proof_tree with
  | cbv_constr lp _ _ _ _          => flat_map first_activations_and_semi_rec lp
  | cbv_split lp p _ _ _ _         => first_activations_and_semi_rec p ++ flat_map first_activations_and_semi_rec lp
  | cbv_update _ _ _ _ _ _ _ as p' => [p']
  | cbv_read _ _ _ as p'           => [p']
  end.

Definition first_activations_and_semi (proof_tree : cbv) : list cbv :=
  match proof_tree with
  | cbv_constr lp _ _ _ _    => []
  | cbv_split lp p _ _ _ _   => []
  | cbv_update _ _ p _ _ _ _ => first_activations_and_semi_rec p
  | cbv_read _ _ _           => []
  end.

Lemma incl_first_activations_semi p :
  incl (first_activations p) (first_activations_and_semi p).

Lemma first_activations_and_semi_rec_incl_sub_trees p :
  incl (first_activations_and_semi_rec p) (sub_trees p).

Lemma first_activations_and_semi_incl_sub_trees p :
  incl (first_activations_and_semi p) (sub_trees p).

Lemma cbv_big_induction :
  forall (P : cbv -> Prop),
  (forall i s p c1 t c2 v, (forall p', In p' (first_activations (cbv_update i s p c1 t c2 v)) -> P p') -> P (cbv_update i s p c1 t c2 v)) ->
  forall i s p c1 t c2 v, P (cbv_update i s p c1 t c2 v).

Lemma activations_first_activations i s p' c1 t c2 v :
  let p := cbv_update i s p' c1 t c2 v in
  activations p = p :: flat_map activations (first_activations p).

Lemma cache_consistent p :
  wf p ->
  exists C,
    cache_beq (cache_right p) (C ++ cache_left p) = true /\
    (forall t, assoc_cache t C <> None -> assoc_cache t (cache_left p) = None).

Lemma cache_path_consistent c1 c2 lp :
  andl (map wf lp) ->
  cache_path c1 c2 lp = true ->
  forall p, In p lp ->
    exists c3,
      c2 = c3 ++ cache_right p /\
      (forall t, assoc_cache t c3 <> None -> assoc_cache t (cache_right p) = None).

Lemma cache_path_consistent_head C p lp :
  wf p -> andl (map wf lp) ->
  cache_path (cache_right p) C lp = true ->
    exists C',
      C = C' ++ cache_right p /\
      (forall t, assoc_cache t C' <> None -> assoc_cache t (cache_right p) = None).

Lemma assoc_cache_hd (f: function) (lv: list term) (v: value) (C: cache) :
  assoc_cache (fapply f lv) ((fapply f lv, v) :: C) = Some v.

Definition valid_cache_extension (ext base: cache) : Prop :=
  forall t: term, assoc_cache t ext <> None -> assoc_cache t base = None.

Lemma cache_extension_app (ext' ext base: cache) :
  valid_cache_extension ext' (ext ++ base) ->
  valid_cache_extension ext base ->
  valid_cache_extension (ext' ++ ext) base.

Definition cbv_cache_entry (proof_tree : cbv) := (proj_left proof_tree, proj_right proof_tree).

Lemma cache_content (proof_tree : cbv) :
  wf proof_tree ->
  cache_right proof_tree =
  map cbv_cache_entry (activations_cache_order proof_tree) ++
      cache_left proof_tree.

Lemma cache_content_on_path c1 c2 lp:
  andl (map wf lp) ->
  cache_path c1 c2 lp = true ->
  c2 = map cbv_cache_entry (revflatten (map activations_cache_order lp)) ++ c1.

Lemma cache_path_proj_left_in_tail_not_in_head t p lp c1 c2 :
  cache_path c1 c2 (p :: lp) = true ->
  andl (map wf (p :: lp)) ->
  In t (map proj_left (revflatten (map activations_cache_order lp))) ->
  ~ In t (map proj_left (activations_cache_order p)).

Lemma whole_cache_path_consistent lp : forall c1 c2,
  cache_path c1 c2 lp = true ->
  andl (map wf lp) ->
  exists C,
    cache_beq c2 (C ++ c1) = true /\
    (forall t, assoc_cache t C <> None -> assoc_cache t c1 = None).

Lemma cache_path_proj_left_not_in_init t lp c1 c2 :
  cache_path c1 c2 lp = true ->
  andl (map wf lp) ->
  In t (map proj_left (revflatten (map activations_cache_order lp))) ->
  ~ In t (map fst c1).

Lemma cache_lookup_term (p: cbv) (ext: cache):
  wf p ->
  (forall t: term, assoc_cache t ext <> None -> assoc_cache t (cache_right p) = None) ->
  cache_lookup (ext ++ cache_right p) (proj_left p) = @term_from_value _ _ _ (proj_right p).

Lemma first_activations_residues_activation i s p c1 t c2 v :
  let proof_tree := cbv_update i s p c1 t c2 v in
  wf proof_tree ->
  Forall2 (fun p' t' =>
    match (proj_left p', t') with
    | (fapply f lv, fapply f' lt) =>
      f = f' /\
      Forall2 (fun t v => cache_lookup (cache_left p') t = v) lt lv
    | _ => False
    end)
    (first_activations_and_semi proof_tree)
    (fapplies_in_term (proj_left p)).

Lemma nb_nodes_bound i s p' c1 t c2 v :
  let p := cbv_update i s p' c1 t c2 v in
  nb_nodes p <= suml (map nb_judgements_sub (activations p)) + length (activations p).

Lemma nb_judgements_bound i s p' c1 t c2 v :
  let p := cbv_update i s p' c1 t c2 v in
  nb_judgements p <= suml (map nb_judgements_sub (activations p)) + length (activations p) + nb_read p.

Lemma nb_judgements_sub_rec_bound p :
  wf p -> nb_judgements_sub_rec p <= term_size (proj_left p).

Lemma nb_judgements_sub_bound i s p c1 t c2 v :
  wf (cbv_update i s p c1 t c2 v) ->
  nb_judgements_sub (cbv_update i s p c1 t c2 v) <= activation_bound prog (term_size t).

Lemma right_from_activation_or_from_left p : wf p ->
  maxl (map (fun tv : term * value => value_size (snd tv)) (cache_right p)) <=
  max (max_active_size p) (maxl (map (fun tv : term * value => value_size (snd tv)) (cache_left p))).

Lemma right_from_activation_or_from_left_path lp c1 c2 : andl (map wf lp) ->
  cache_path c1 c2 lp = true ->
  maxl (map (fun tv : term * value => value_size (snd tv)) c2) <=
  max (maxl (map max_active_size lp)) (maxl (map (fun tv : term * value => value_size (snd tv)) c1)).

Lemma value_size_bounded_by_nb_judgements p :
  wf p -> value_size (proj_right p) <= (1 + max (max_active_size p) (maxl (map (fun tv => value_size (snd tv)) (cache_left p)))) * nb_judgements p.

Lemma size_bounded_nb_size_judgements p :
  size p <= nb_judgements p * max_judgement_size p + cache_size (cache_left p).

Lemma nb_judgements_sub_bound_gen : forall p p',
  let S := max_active_size p in
  wf p ->
  In p' (activations p) -> nb_judgements_sub p' <= activation_bound prog S.

Lemma nb_judgements_bound_gen : forall i s p' c1 t c2 v,
  let p := cbv_update i s p' c1 t c2 v in
  let A := length (activations p) in
  let S := max_active_size p in
  wf p ->
  nb_judgements p <= A * activation_bound prog S + A + (Datatypes.S (max_arity * nb_nodes p)).

Lemma cache_path_incl : forall lp c1 c2, 
  andl (map wf lp) -> cache_path c1 c2 lp = true -> incl c1 c2.

Lemma InCBV_cache_right_incl p proof_tree :
  wf proof_tree ->
  InCBV p proof_tree ->
  incl (cache_right p) (cache_right proof_tree).

Lemma InCBV_read_cache_right c t v p:
  wf p ->
  InCBV (cbv_read c t v) p ->
  In (t, v) (cache_right p).

Lemma term_size_proj_left_bound : forall i s p' c1 t c2 v,
  let p := cbv_update i s p' c1 t c2 v in
  let S := max_active_size p in
  wf p ->
  forall p',
  InCBV p' p -> term_size (proj_left p') <= activation_bound prog S + S + cache_size c1.

Lemma nb_nodes_bound_gen i s p' c1 t c2 v :
  let p := cbv_update i s p' c1 t c2 v in
  let A := length (activations p) in
  let S := max_active_size p in
  wf p ->
  nb_nodes p <= A * (1 + activation_bound prog S).

Lemma size_judgement : forall i s p' c1 t c2 v,
  let p := cbv_update i s p' c1 t c2 v in
  let A := length (activations p) in
  let S := max_active_size p in
  let C := maxl (map (fun tv : term * value => value_size (snd tv)) c1) in
  wf p ->
  max_judgement_size p <=
  activation_bound prog S + S + cache_size c1 +
  (1 + max S C) * (1 + (A * activation_bound prog S + A) + max_arity * (A * activation_bound prog S + A)).

Theorem size_bound_gen : forall i s p' c1 t c2 v,
  let p := cbv_update i s p' c1 t c2 v in
  let A := length (activations p) in
  let S := max_active_size p in
  wf p ->
  size p <=
  (A * activation_bound prog S + A + 1 + (max_arity * A * (1 + activation_bound prog S))) *
  (activation_bound prog S + S + cache_size c1 +
  (1 + max S (maxl (map (fun tv : term * value => value_size (snd tv)) c1))) *
  (1 + (A * activation_bound prog S + A) + max_arity * (A * activation_bound prog S + A))) +
  cache_size c1.

Corollary size_bound : forall i s p' t c v,
  let p := cbv_update i s p' [] t c v in
  let A := length (activations p) in
  let S := max_active_size p in
  wf p ->
  size p <=
  (A * activation_bound prog S + A + 1 + (max_arity * A * (1 + activation_bound prog S))) *
  (activation_bound prog S + S +
  (1 + S) *
  (1 + (A * activation_bound prog S + A) + max_arity * (A * activation_bound prog S + A))).

End CBV. *)
(* Cecoa.Final:
Require Import Le Max List Bool NPeano Omega.
Require Import Cecoa.Lib Cecoa.Syntax Cecoa.CBV_cache Cecoa.Bounds Cecoa.Ordering Cecoa.QI.

Section Main.

Variables variable function constructor : Type.
Notation value := (Syntax.value constructor).
Notation term := (Syntax.term variable function constructor).
Notation pattern := (Syntax.pattern variable constructor).
Notation rule := (Syntax.rule variable function constructor).
Variable prog : list rule.
Variable max_arity:nat.
Variable rule_default : rule.

Hypothesis prog_is_wf: wf_prog max_arity prog.

Variable variable_eq_dec : forall (x1 x2 : variable), {x1=x2}+{x1<>x2}.
Variable function_eq_dec : forall (x1 x2 : function), {x1=x2}+{x1<>x2}.
Variable constructor_eq_dec : forall (x1 x2 : constructor), {x1=x2}+{x1<>x2}.

Notation cache := (CBV_cache.cache variable function constructor).
Notation cbv := (CBV_cache.cbv variable function constructor).
Notation wf := (CBV_cache.wf variable_eq_dec function_eq_dec constructor_eq_dec rule_default
                prog max_arity).

Variable rank: function -> nat.
Variable max_rank : nat.
Hypothesis pos_max_rank : 0 < max_rank.
Hypothesis max_rank_is_max_rank : forall f, rank f <= max_rank.
Hypothesis prog_is_ppo : PPO_prog prog rank.

Definition gsp := (Bounds.gary_seven_poly variable function constructor prog max_rank).
Definition bep := (Bounds.bobby_eight_poly variable function constructor max_arity prog).

Variable cs: constructor -> nat.  
Variable mcs: nat. 
Variable qic: constructor -> list nat -> nat.
Variable qif: function -> list nat -> nat.
Hypothesis prog_has_QI: valid_QI variable function constructor prog mcs qic qif cs.
Notation cache_bounded := (QI.cache_bounded variable function constructor qic qif).

Definition CBV_bound A S C :=  
    (A * activation_bound prog S + A + 1 + (max_arity * A * (1 + activation_bound prog S))) *
  (activation_bound prog S + S + cache_size C +
  (1 + max S (maxl (map (fun tv : term * value => value_size (snd tv)) C))) *
  (1 + (A * activation_bound prog S + A) + max_arity * (A * activation_bound prog S + A))) +
  cache_size C.

Definition PPO_bound S := gsp (bep S).

Definition QI_bound (f:function) (lv: list term) := 
    (max_arity + 1) * (qif f (map (fun x=> mcs * (term_size (fapply f lv))) lv)) + 1.

Definition global_bound f lv C :=
  let S:= QI_bound f lv in
  let A:= PPO_bound S in
  CBV_bound A S C.

Lemma gary_increase: 
  forall x y, x <=y -> gsp x <= gsp y.

Lemma PPO_bound_increase:
  forall x y, x <= y -> PPO_bound x <= PPO_bound y.

Lemma activation_bound_increase:
  forall x y, x <= y -> activation_bound prog x <= activation_bound prog y.

Lemma CBV_bound_increase:
  forall x1 y1 x2 y2 C, x1 <= y1 -> x2 <= y2 -> CBV_bound x1 x2 C <= CBV_bound y1 y2 C.

Theorem P_criterion: forall i s p c f lv d v,
  let t :=  (fapply f lv) in
  let pi := cbv_update i s p c t d v in
  wf pi -> cache_bounded c ->
  size pi <= global_bound f lv c.

End Main. *)
Require Import FunctionalExtensionality.
Import List.ListNotations.

Require Import Unicode.Utf8_core.
Require Import Unicode.Utf8.
Notation "x ≤ y ≤ z" := (x ≤ y ∧ y ≤ z) (at level 70, y at next level).
Notation "x < y ≤ z" := (x < y ∧ y ≤ z) (at level 70, y at next level).
Notation "x ≤ y < z" := (x ≤ y ∧ y < z) (at level 70, y at next level).

Section Monad.
Definition state := nat.
Definition monad (A:Type) := state → state * A.

Definition Meval {A:Type} (m:monad A) st := m st.

Definition Meq {A:Type} (m:monad A) := ∀ st, st = fst (Meval m st).
Definition Mlt {A:Type} (m:monad A) := ∀ st, st < fst (Meval m st).
Definition Mle {A:Type} (m:monad A) := ∀ st, st ≤ fst (Meval m st).
Lemma Mlt_Mle_incl {A:Type} (m:monad A): Mlt m → Mle m.
Proof. unfold Mle. intros. now apply Nat.lt_le_incl. Qed.
Lemma Meq_Mle_incl {A:Type} (m:monad A): Meq m → Mle m.
Proof. unfold Mle. intros. now apply Nat.eq_le_incl. Qed.

Definition Mmono {A:Type} (m:monad A) :=
forall st st', st ≤ st' → fst (Meval m st) ≤ fst (Meval m st').

Definition Mmono_one {A B:Type} (f: A → monad B) :=
(∀ a, Mmono (f a)) ∧
(∀ ma st st' n, st ≤ st' → Mmono ma →
  fst (Meval (f (snd (Meval ma st))) n) ≤ fst (Meval (f (snd (Meval ma st'))) n)).
Definition Mmono_two {A B C:Type} (f: A → B → monad C) :=
(∀ a b, Mmono (f a b)) ∧
(∀ {D:Type} (mab: monad (A*D)) b st st' n, st ≤ st' → Mmono mab →
  fst (Meval (f (fst (snd (Meval mab st))) b) n) ≤ fst (Meval (f (fst (snd (Meval mab st'))) b) n)) ∧ 
(∀ {D:Type} a (mab: monad (D*B)) st st' n, st ≤ st' → Mmono mab →
  fst (Meval (f a (snd (snd (Meval mab st)))) n) ≤ fst (Meval (f a (snd (snd (Meval mab st')))) n)).

Definition Mreturn {A:Type} (x:A) := (λ s, (s, x)):monad A.
Lemma Mreturn_eq {A:Type} (x:A): Meq (Mreturn x).
Proof. unfold Meq, Mreturn, Meval. now simpl. Qed.
Lemma Mreturn_le  {A:Type} (x:A): Mle (Mreturn x).
Proof. apply Meq_Mle_incl. apply Mreturn_eq. Qed.
Lemma Mreturn_mono {A:Type} (x:A): Mmono (Mreturn x).
Proof. unfold Mmono, Mreturn, Meval. now simpl. Qed.

Definition Mbind {A B:Type} (m:monad A) f :=
  (λ st, let (st',x) := Meval m st in
         let m' := f x in Meval m' st'):monad B.
Infix ">>=" := Mbind (at level 15, left associativity) : monad_scope. 
Open Scope monad_scope. 
Lemma le_lt_Mbind_lt {A B:Type} (ma:monad A) (f:A → monad B):
  Mle ma → (∀ a, Mlt (f a)) → Mlt (ma >>= f).
Proof.
unfold Mbind, Mle, Mlt, Meval. intros.
rewrite (surjective_pairing (ma st)). 
apply Nat.le_lt_trans with (m:= fst (ma st)); trivial.
Qed.
Lemma lt_le_Mbind_lt {A B:Type} (ma:monad A) (f:A → monad B):
  Mlt ma → (∀ a, Mle (f a)) → Mlt (ma >>= f).
Proof.
unfold Mbind, Mle, Mlt, Meval. intros.
rewrite (surjective_pairing (ma st)). 
apply Nat.lt_le_trans with (m:= fst (ma st)); trivial.
Qed.
Lemma eq_eq_Mbind_eq {A B:Type} (ma:monad A) (f:A → monad B):
  Meq ma → (∀ a, Meq (f a)) → Meq (ma >>= f).
Proof.
unfold Meq, Mbind, Meval. intros.
rewrite (surjective_pairing (ma st)). now rewrite <- H.
Qed.
Lemma lt_lt_Mbind_lt {A B:Type} (ma:monad A) (f:A → monad B):
  Mlt ma → (∀ a, Mlt (f a)) → Mlt (ma >>= f).
Proof.
intros. apply le_lt_Mbind_lt; try trivial. now apply Mlt_Mle_incl.
Qed.
Lemma mono_mono_Mbind_mono {A B:Type} (ma:monad A) (f:A → monad B):
  Mmono ma → Mmono_one f → Mmono (ma >>= f).
Proof.
unfold Mbind, Mmono, Mmono_one, Meval. intros. destruct H0.
rewrite (surjective_pairing (ma st)).
rewrite (surjective_pairing (ma st')).
apply le_trans with (m:=fst (f (snd (ma st)) (fst (ma st')))).
- apply H0. auto.
- apply H2; auto.
Qed.

Lemma Mbind_ind {A:Type} (ma:monad A) (f:A→monad A) (P:A → Prop):
  (∀ st, P (snd (ma st))) → (∀ (a:A), P a → ∀ st, P (snd ((f a) st))) → 
  ∀ st, P (snd ((ma>>=f) st)).
Proof.
intros. unfold Mbind, Meval. rewrite (surjective_pairing (ma st)). now apply H0.
Qed.

Definition Mdo {A B:Type} (ma:monad A) (mb:monad B) := ma >>= (λ _, mb).
Infix ">>" := Mdo (at level 15, left associativity) : monad_scope. 

Lemma le_lt_Mdo_lt {A B:Type} (ma:monad A) (mb:monad B):
  Mle ma → Mlt mb → Mlt (ma >> mb).
Proof.
unfold Mdo, Mbind, Mle, Mlt, Meval. intros.
rewrite (surjective_pairing (ma st)).
apply Nat.le_lt_trans with (m:= fst (ma st)); trivial.
Qed.
Lemma lt_le_Mdo_lt {A B:Type} (ma:monad A) (mb:monad B):
  Mlt ma → Mle mb → Mlt (ma >> mb).
Proof.
unfold Mdo, Mbind, Mle, Mlt, Meval. intros.
rewrite (surjective_pairing (ma st)).
apply Nat.lt_le_trans with (m:= fst (ma st)); trivial.
Qed.
Lemma eq_eq_Mdo_eq {A B:Type} (ma:monad A) (mb:monad B):
  Meq ma → Meq mb → Meq (ma >> mb).
Proof.
unfold Meq, Mdo, Mbind, Meval. intros.
rewrite (surjective_pairing (ma st)). now rewrite <- H.
Qed.
Lemma lt_lt_Mdo_lt {A B:Type} (ma:monad A) (mb:monad B):
  Mlt ma → (Mlt mb) → Mlt (ma >> mb).
Proof.
intros. apply le_lt_Mdo_lt; try trivial. now apply Mlt_Mle_incl.
Qed.
Lemma mono_mono_Mdo_mono  {A B:Type} (ma:monad A) (mb:monad B):
  Mmono ma → (Mmono mb) → Mmono (ma >> mb).
Proof.
intros. apply mono_mono_Mbind_mono; auto.
now unfold Mmono_one.
Qed.

Definition Mupdate (f:nat→nat) := (λ st, ((f st),tt)):monad unit.
Lemma lt_Mupdate_lt (f:nat→nat):
  (∀ n, n < f n) → Mlt (Mupdate f).
Proof. auto. Qed.
Lemma mono_Mupdate_mono f:
  (∀ x y, x ≤ y → f x ≤ f y) → Mmono (Mupdate f).
Proof. auto. Qed.

Definition Mread := (λ n, (n,n)):monad nat.
Lemma Mread_le: Mle Mread.
Proof. left. Qed.
Lemma Mread_mono: Mmono Mread.
Proof. unfold Mmono. now simpl. Qed.

Definition Mnew_fun := (Mupdate S) >> Mread.
Lemma Mnew_fun_lt: Mlt Mnew_fun.
Proof.
apply lt_le_Mdo_lt.
- apply lt_Mupdate_lt. auto.
- apply Mread_le.
Qed.
Lemma Mnew_fun_mono: Mmono Mnew_fun.
Proof.
apply mono_mono_Mdo_mono.
- apply mono_Mupdate_mono. apply Nat.succ_le_mono.
- apply Mread_mono.
Qed.

Definition Mmap2 {A B C:Type} (f:A→B→C) (ma:monad A) (mb:monad B):=
  (λ s0, let (s1,a) := ma s0 in let (s2,b) := mb s1 in (s2,(f a b))):monad C.
Lemma le_lt_Mmap2_lt {A B C:Type} (f:A→B→C) (ma:monad A) (mb:monad B):
  Mle ma → Mlt mb → Mlt (Mmap2 f ma mb).  
Proof.
unfold Mle, Mlt, Mmap2, Meval. intros.
rewrite (surjective_pairing (ma st)).
rewrite (surjective_pairing (mb (fst (ma st)))).
unfold fst at 1.
apply Nat.le_lt_trans with (m:=fst (ma st)); trivial.
Qed.
Lemma lt_le_Mmap2_lt {A B C:Type} (f:A→B→C) (ma:monad A) (mb:monad B):
  Mlt ma → Mle mb → Mlt (Mmap2 f ma mb).
Proof.
unfold Mle, Mlt, Mmap2, Meval. intros.
rewrite (surjective_pairing (ma st)).
rewrite (surjective_pairing (mb (fst (ma st)))).
unfold fst at 1.
apply Nat.lt_le_trans with (m:=fst (ma st)); trivial.
Qed.
Lemma eq_eq_Mmap2_eq {A B C:Type} (f:A→B→C) (ma:monad A) (mb:monad B):
  Meq ma → Meq mb → Meq (Mmap2 f ma mb).
Proof.
unfold Meq, Mmap2, Meval. intros.
rewrite (surjective_pairing (ma st)).
rewrite (surjective_pairing (mb (fst (ma st)))).
unfold fst at 1. now rewrite <- H.
Qed.
Lemma lt_lt_Mmap2_lt {A B C:Type} (f:A→B→C) (ma:monad A) (mb:monad B):
  Mlt ma → Mlt mb → Mlt (Mmap2 f ma mb).
Proof.
intros. apply le_lt_Mmap2_lt; try trivial. now apply Mlt_Mle_incl.
Qed.
Lemma mono_mono_Mmap2_mono {A B C:Type} (f: A → B → C) ma mb:
  Mmono ma → Mmono mb → Mmono (Mmap2 f ma mb).
Proof.
unfold Mmap2, Mmono, Meval. intros.
rewrite (surjective_pairing (ma st)), (surjective_pairing (ma st')).
rewrite (surjective_pairing (mb (fst (ma st)))), (surjective_pairing (mb (fst (ma st')))).
simpl. apply H0. auto.
Qed.

Definition triple {A B C:Type} (x:A*B) (c:C) := (fst x,snd x,c):A*B*C.
Notation "ma >>+ mb" := (Mmap2 pair ma mb) (at level 15, left associativity):monad_scope.
Notation "mab >>++ mc" := (Mmap2 triple mab mc) (at level 15, left associativity):monad_scope.
Notation "mx >>:: mxs" :=  (Mmap2 cons mx mxs) (at level 15, left associativity):monad_scope.

Lemma Mpair_on_first {A B:Type} (ma:monad A) (mb:monad B) (P:A→Prop):
  (∀ st, P (snd (ma st))) →
  ∀ st, P (fst (snd ((ma >>+ mb) st))).
Proof.
intros. unfold Mmap2.
rewrite (surjective_pairing (ma st)). rewrite (surjective_pairing (mb (fst (ma st)))). now simpl.
Qed.
Lemma Mtriple_on_all {A:Type} (m1 m2 m3:monad A) (P:A→Prop):
  (∀ st, P (snd (m1 st))) → (∀ st, P (snd (m2 st))) → (∀ st, P (snd (m3 st))) →
  ∀ st,
  P (fst (fst (snd ((m1>>+m2>>++m3) st)))) ∧
  P (snd (fst (snd ((m1>>+m2>>++m3) st)))) ∧
  P (snd (snd ((m1>>+m2>>++m3) st))).
Proof.
intros. unfold Mmap2.
rewrite (surjective_pairing (m1 st)). rewrite (surjective_pairing (m2 (fst (m1 st)))).
rewrite (surjective_pairing (m3 (fst (m2 (fst (m1 st)))))). now simpl.
Qed.

Lemma Mcons_forall {A:Type} (m:monad A) (ms:monad (list A)) (P:A→Prop):
  (∀ st, P (snd (m st))) →
  (∀ st, Forall P (snd (ms st))) →
  ∀ st, Forall P (snd ((m >>:: ms) st)).
Proof.
intros. unfold Mmap2. rewrite (surjective_pairing (m st)). rewrite (surjective_pairing (ms (fst (m st)))).
simpl. now apply Forall_cons.
Qed.

Definition Mbind2 {A B C:Type} (mab:monad (A*B)) (f:A→B→monad C) :=
  (λ st, let (st',ab):= Meval mab st in let m':=f (fst ab) (snd ab) in m' st'):monad C.
Infix ">>==" := Mbind2 (at level 15, left associativity) : monad_scope.
Lemma le_lt_Mbind2_lt {A B C:Type} (mab:monad (A*B)) (f:A→B→monad C):
  Mle mab → (∀ a b, Mlt (f a b)) → Mlt (mab >>== f).
Proof.
unfold Mle, Mlt, Mbind2, Meval. intros.
rewrite (surjective_pairing (mab st)).
apply Nat.le_lt_trans with (m:=fst (mab st)); trivial.
Qed.
Lemma lt_le_Mbind2_lt {A B C:Type} (mab:monad (A*B)) (f:A→B→monad C):
  Mlt mab → (∀ a b, Mle (f a b)) → Mlt (mab >>== f).
Proof.
unfold Mle, Mlt, Mbind2, Meval. intros.
rewrite (surjective_pairing (mab st)).
generalize (H0 (fst (snd (mab st))) (snd (snd (mab st)))). intro.
apply Nat.lt_le_trans with (m:=fst (mab st)); trivial.
Qed.
Lemma eq_eq_Mbind2_eq {A B C:Type} (mab:monad (A*B)) (f:A→B→monad C):
  Meq mab → (∀ a b, Meq (f a b)) → Meq (mab >>== f).
Proof.
unfold Mle, Mlt, Meq, Mbind2, Meval. intros.
rewrite (surjective_pairing (mab st)).
generalize (H0 (fst (snd (mab st))) (snd (snd (mab st)))). intro.
now rewrite <- H1.
Qed.
Lemma lt_lt_Mbind2_lt {A B C:Type} (mab:monad (A*B)) (f:A→B→monad C):
  Mlt mab → (∀ a b, Mlt (f a b)) → Mlt (mab >>== f).
Proof.
intros. apply le_lt_Mbind2_lt; try trivial. now apply Mlt_Mle_incl.
Qed.
Lemma mono_mono_Mbind2_mono {A B C:Type} (mab:monad (A*B)) (f:A→B→monad C):
  Mmono mab → Mmono_two f → Mmono (mab >>== f).
Proof.
unfold Mbind2, Mmono_two, Mmono, Meval. intros. destruct H0. destruct H2.
rewrite (surjective_pairing (mab st)), (surjective_pairing (mab st')).
apply le_trans with (m:=fst (f (fst (snd (mab st'))) (snd (snd (mab st))) (fst (mab st)))); auto.
apply le_trans with (m:=fst (f (fst (snd (mab st'))) (snd (snd (mab st'))) (fst (mab st)))); auto.
Qed.

Lemma Mbind2_triple {A B:Type} (ma1 ma2 ma3:monad A) (mb:monad B) (f:(A*A*A)→B→monad A) (P:A→Prop):
  (∀ st, P (snd (ma1 st))) →
  (∀ st, P (snd (ma2 st))) →
  (∀ st, P (snd (ma3 st))) →
  (∀ xyz, P (fst (fst xyz)) → P (snd (fst xyz)) → P (snd xyz) →
    (∀ b st, P (snd ((f xyz b) st)))) →
  ∀ st, P (snd ((ma1 >>+ ma2 >>++ ma3 >>+ mb >>== f) st)).
Proof.
intros. unfold Mbind2, Meval. rewrite (surjective_pairing ((ma1 >>+ ma2 >>++ ma3 >>+ mb) st)).
apply H2; apply Mpair_on_first; now apply Mtriple_on_all.
Qed.

Lemma Mbind2_list {A B:Type} (ma1:monad A) (mal2 mal3:monad (list A)) (mb:monad B) (f:(A*(list A)*(list A))→B→monad A) (P:A→Prop):
  (∀ st, P (snd (ma1 st))) →
  (∀ st, Forall P (snd (mal2 st))) →
  (∀ st, Forall P (snd (mal3 st))) →
  (∀ xyz, P (fst (fst xyz)) → Forall P (snd (fst xyz)) → Forall P (snd xyz) → 
    (∀ b st, P (snd ((f xyz b) st)))) →
  ∀ st, P (snd ((ma1 >>+ mal2 >>++ mal3 >>+ mb >>== f) st)).
Proof.
intros. unfold Mbind2, Meval. rewrite (surjective_pairing ((ma1 >>+ mal2 >>++ mal3 >>+ mb) st)).

apply H2; apply Mpair_on_first; intro;
  unfold Mmap2; rewrite (surjective_pairing (ma1 st0));
  rewrite (surjective_pairing (mal2 (fst (ma1 st0))));
  rewrite (surjective_pairing (mal3 (fst (mal2 (fst (ma1 st0)))))); now simpl.
Qed.

Fixpoint lm_to_ml {A:Type} (lm:list (monad A)) : monad (list A):=
  match lm with
  | [] => Mreturn []
  | m::ms => m >>::(lm_to_ml ms)
  end.
Lemma empty_lm_to_ml_eq {A:Type}: Meq (@lm_to_ml A []).
Proof. apply Mreturn_eq. Qed.
Lemma non_empty_all_lt_lm_to_ml_lt {A:Type} (lm:list (monad A)):
  lm ≠ [] → Forall Mlt lm → Mlt (lm_to_ml lm).
Proof.
intros. induction lm; try tauto.
simpl. destruct lm.
- apply lt_le_Mmap2_lt; try apply Mreturn_le.
  rewrite Forall_forall in H0. apply H0. now left.
- rewrite Forall_cons_iff in H0. apply lt_lt_Mmap2_lt; try tauto.
  apply IHlm; try tauto. discriminate.
Qed.
Lemma all_le_lm_to_ml_le {A:Type} (lm:list (monad A)):
  Forall Mle lm → Mle (lm_to_ml lm).
Proof.
intros. induction lm; simpl; try apply Mreturn_le.
unfold Mmap2, Mle, Meval. intro.
rewrite (surjective_pairing (a st)).
rewrite (surjective_pairing (lm_to_ml lm (fst (a st)))).
simpl.
rewrite Forall_cons_iff in H. destruct H.
apply le_trans with (m:=fst (a st)); auto.
now apply IHlm.
Qed.
Lemma all_lt_lm_to_ml_le {A:Type} (lm:list (monad A)):
  (Forall Mlt lm) → Mle (lm_to_ml lm).
Proof.
intros. destruct lm.
- apply Meq_Mle_incl. apply empty_lm_to_ml_eq.
- apply Mlt_Mle_incl. now apply non_empty_all_lt_lm_to_ml_lt.
Qed.

Lemma lm_to_ml_length {A:Type} (lm: list (monad A))  st:
  length (snd (lm_to_ml lm st)) = length lm.
Proof.
revert st. induction lm; simpl; auto. unfold Mmap2. intro.
rewrite (surjective_pairing (a st)).
rewrite (surjective_pairing (lm_to_ml lm (fst (a st)))).
simpl. now rewrite IHlm.
Qed.

Lemma lm_to_ml_ind {A:Type} (P:A→Prop) (lm:list (monad A)):
  (∀ ma, ma ∈ lm → ∀ st, P (snd (ma st))) →
  ∀ st, Forall P (snd ((lm_to_ml lm) st)).
Proof.
intro. induction lm; simpl.
- intro. apply Forall_nil.
- apply Mcons_forall.
  + apply H. simpl. now left.
  + apply IHlm. intros. apply H. simpl. now right.
Qed.

Lemma all_mono_lm_to_ml_mono {A:Type} (lm: list (monad A)):
  Forall Mmono lm → Mmono (lm_to_ml lm).
Proof.
induction lm; simpl.
- apply Mreturn_mono.
- rewrite Forall_cons_iff. intro. destruct H.
  apply mono_mono_Mmap2_mono; auto.
Qed.

Lemma in_lm_to_ml {A:Type} (a:A) mal st:
  a ∈ snd ((lm_to_ml mal) st) → ∃ ma st', ma ∈ mal ∧ a = snd (ma st').
Proof.
revert st. induction mal; simpl; try tauto.
unfold Mmap2. intro.
rewrite (surjective_pairing (a0 st)).
rewrite (surjective_pairing (lm_to_ml mal (fst (a0 st)))).
simpl. intro. destruct H.
- exists a0, st. auto.
- generalize (IHmal (fst (a0 st)) H). intro. destruct H0. destruct H0.
  exists x, x0. tauto.
Qed.

Lemma lm_to_ml_incl {A B:Type} (mal:list (monad A)) (f:A→B) g st:
  (∀ st ma, ma ∈ mal → f (snd (ma st)) ∈ g (snd (ma st))) →
  incl (map f (snd ((lm_to_ml mal) st)))
       (concat (map g (snd ((lm_to_ml mal) st)))).
Proof.
unfold incl. intros. rewrite in_map_iff in H0. repeat destruct H0.
generalize (in_lm_to_ml x mal st H1). intro.
repeat destruct H0. subst.
rewrite in_concat_iff. exists (g (snd (x0 x1))).
split; auto. now apply in_map.
Qed.
Lemma lm_to_ml_incl_incl {A B C:Type} mal f1 (f2 : A → list B) (g : A → list C) st:
  (∀ st ma, ma ∈ mal → incl (flat_map f1 (f2 (snd (ma st)))) (g (snd (ma st)))) →
  incl (flat_map f1 (concat (map f2 (snd (lm_to_ml mal st)))))
       (concat (map g (snd (lm_to_ml mal st)))).
Proof.
unfold incl. intros H a.
rewrite flat_map_concat_map, concat_map, map_map.
repeat rewrite <- flat_map_concat_map. intro.
rewrite in_concat_iff in H0. repeat destruct H0.
rewrite in_flat_map in *. repeat destruct H0.
generalize (in_lm_to_ml x0 mal st H0). intro.
repeat destruct H3. subst.
exists (snd (x1 x2)). split; auto.
apply H; auto. rewrite in_flat_map.
rewrite in_map_iff in H2. repeat destruct H2.
eauto.
Qed.

Lemma lm_to_ml_bounds {R T:Type} n (mtl:list (monad T)) f_low f_up f_in (r: T → list R):
 fmono f_low → fmono f_up → Forall Mle mtl →
 (∀ mt s n', mt ∈ mtl → n' ∈ map f_in (r (snd (mt s))) → f_low s ≤ n' ≤ f_up (fst (mt s))) →
 ∀ st st', st ≤ st' →  
 n ∈ map f_in (concat (map r (snd (lm_to_ml mtl st')))) →
 f_low st ≤ n ≤ f_up (fst (lm_to_ml mtl st')).
Proof.
intros Hmono_low Hmono_up HMle Hforall.
induction mtl; simpl in *; try tauto.
unfold Mmap2. intros st st' Hle.
rewrite (surjective_pairing (a st')).
rewrite (surjective_pairing (lm_to_ml mtl (fst (a st')))).
simpl.
rewrite map_app, in_app_iff. intro.
rewrite Forall_cons_iff in HMle. destruct HMle.
destruct H; split.
- apply le_trans with (m:=f_low st'); auto.
  apply (Hforall a); auto.
- apply le_trans with (m:=f_up (fst (a st'))).
  + apply (Hforall a); auto.
  + apply Hmono_up. now apply all_le_lm_to_ml_le.
- apply IHmtl with (st':=fst (a st')); auto.
  apply le_trans with (m:=st'); auto.
- apply IHmtl with (st':=fst (a st')) (st:=st); auto.
  apply le_trans with (m:=st'); auto.
Qed.
End Monad.

Section Completness.
Infix ">>=" := Mbind (at level 15, left associativity) : monad_scope. 
Open Scope monad_scope.
Infix ">>" := Mdo (at level 15, left associativity) : monad_scope.
Notation "ma >>+ mb" := (Mmap2 pair ma mb) (at level 15, left associativity):monad_scope.
Notation "mab >>++ mc" := (Mmap2 triple mab mc) (at level 15, left associativity):monad_scope.
Notation "mx >>:: mxs" :=  (Mmap2 cons mx mxs) (at level 15, left associativity):monad_scope.
Infix ">>==" := Mbind2 (at level 15, left associativity) : monad_scope.

Hint Immediate Nat.eqb_eq. 

Definition variable := nat.
Definition function := nat.
Inductive constructor := Zero | Succ0 | Succ1.

Scheme Equality for constructor.

Notation value := (Syntax.value constructor).
Notation term := (Syntax.term variable function constructor).
Notation pattern := (Syntax.pattern variable constructor).
Notation rule := (Syntax.rule variable function constructor).

Notation term_from_value := (Syntax.term_from_value variable function (constructor:=constructor)).
Notation term_from_pattern := (Syntax.term_from_pattern (variable:=variable) function (constructor:=constructor)).
Notation rule_vars_defined := (Syntax.rule_vars_defined (variable:=variable) (function:=function) (constructor:=constructor)).
Notation functions_of_term := (Syntax.functions_of_term (variable:=variable) (function:=function) (constructor:=constructor)).

Definition assig := list nat → nat.
Definition Err_assig: assig :=  λ _, 0.
Record fun_info := info {rank: nat; asg: assig; norm :nat}.
Definition Err_info := {| rank := 0; asg := Err_assig; norm := 0 |}.

Record trs_prog:= trs {
  main: function; 
  first: nat; 
  last: nat;  
  maxar: nat; 
  maxrank: nat; 
  infos: list (function * fun_info);
  rules: list rule;
}.

Definition px:pattern := p_var 0.
Definition tx:term := var 0.
Definition pnul:pattern := p_var 1.  
Definition tnul:term := var 1.
Definition pfalse:pattern := p_var 2. 
Definition tfalse:term := var 2.
Definition ptrue:pattern := p_var 3. 
Definition ttrue:term := var 3.
Definition pz:pattern := p_capply Zero [].
Definition tz:term := capply Zero [].
Definition ps0 (p:pattern):pattern := p_capply Succ0 [p].
Definition ts0 (t:term):term := capply Succ0 [t].
Definition ps1 (p:pattern):pattern := p_capply Succ1 [p].
Definition ts1 (t:term):term := capply Succ1 [t].

Definition mk_pv (i:nat):pattern := p_var i.
Definition mk_tv (i:nat):term := var i.
Definition mk_pvl (n m:nat):list pattern := map mk_pv (ints n m).
Definition mk_tvl (n m:nat):list term := map mk_tv (ints n m).

Definition simple_rule nf args rhs := (rule_intro nf args rhs):rule.
Definition sr_uncurry nf ru := simple_rule nf (fst ru) (snd ru).
Definition simple_prog rules infos ma mr nf :=
  {| main:=nf ; first := nf ; last := nf ; maxar:=ma ; maxrank:=mr ;
     infos:=infos; rules:=rules|}.
Definition one_rule_prog args rhs info ma mr nf :=
  simple_prog [(simple_rule nf args rhs)] [(nf,info)] ma mr nf.
Definition Morp args rhs info ma mr nf := Mreturn (one_rule_prog args rhs info ma mr nf).
Definition multi_rules_prog argsl rhsl info ma mr nf:=
  simple_prog (List.map (sr_uncurry nf) (List.combine argsl rhsl)) [(nf,info)] ma mr nf.
Definition Mmrp argsl rhsl info ma mr nf := Mreturn (multi_rules_prog argsl rhsl info ma mr nf).

Definition get_rules trsl := concat (map rules trsl).

Definition get_info trs f :=
  match assoc Nat.eqb f trs.(infos) with
  | Some inf => inf
  | None => Err_info
  end.
Definition get_infos trsl := concat (List.map infos trsl).
Definition get_info_l trsl f :=
  match assoc Nat.eqb f (get_infos trsl) with
  | Some inf => inf
  | None => Err_info
  end.
Definition asg_main trs := (get_info trs trs.(main)).(asg). 

Definition get_rank trs f := (get_info trs f).(rank).

Definition rank_main trs := get_rank trs trs.(main).

Definition mcs:=1. 
Definition cs:= λ c:constructor, 1. 
Definition qic c l:= suml l + cs c. 
Definition qif trs f l:= 
  let inf := get_info trs f in
  let q := inf.(asg) in let norm := inf.(norm) in
  let l1 := firstn norm l in let l2 := skipn norm l in
  (q l1) + (maxl l2).

Definition mk_call args nf := fapply nf (mk_tvl 0 args).
Definition mk_call_trs args trs := mk_call args trs.(main).
Definition mk_args_h n s cf := (mk_tvl 0 n)++(cf::(mk_tvl n (n+s))).

Definition max_rank3 p1 p2 p3 := max (rank_main p1) (max (rank_main p2) (rank_main p3)).

Definition make_rec n s trs_g trs_h0 trs_h1 nf :=
  let pvl := mk_pvl 1 (n+s) in
  let args_h := mk_args_h n s (mk_call (n+s) nf) in
  let rk := (max_rank3 trs_g trs_h0 trs_h1)+1 in
  let mr := max (max rk trs_g.(maxrank)) (max trs_h0.(maxrank) trs_h1.(maxrank)) in
  let asg := λ l, (hd 0 l) * ((asg_main trs_h0 l) + (asg_main trs_h1 l)) + (asg_main trs_g (tl l)) in
  let trs_f :=
    multi_rules_prog [ pz::pvl ; (ps0 px)::pvl ; (ps1 px)::pvl ]
                     [ fapply trs_g.(main) (mk_tvl 1 (n+s)) ;
                       fapply trs_h0.(main) args_h ;
                       fapply trs_h1.(main) args_h ]
                     {| rank := rk ; asg:= asg;norm:=n|} (max (max (n+s+1) trs_g.(maxar)) (max trs_h0.(maxar) trs_h1.(maxar))) rk nf
  in
  {| main:=nf ; first:= trs_g.(first) ; last := nf ; maxar := trs_f.(maxar) ;
     maxrank := mr ; infos := trs_f.(infos)++trs_g.(infos)++trs_h0.(infos)++trs_h1.(infos) ;
     rules := trs_f.(rules)++trs_g.(rules)++trs_h0.(rules)++trs_h1.(rules) |}.
Definition Mmr n s trss nf :=
  Mreturn (make_rec n s (fst (fst trss)) (snd (fst trss)) (snd trss) nf).

Definition max_rankl trsl := maxl (map rank_main trsl).
Definition max_arl trsl := maxl (map maxar trsl).

Definition make_comp n s trs_h trs_gN trs_gS nf :=
  let call_gN := map (mk_call_trs n) trs_gN in
  let call_gS := map (mk_call_trs (n+s)) trs_gS in
  let args_h := call_gN++call_gS in
  let rules_gN := get_rules trs_gN in
  let rules_gS := get_rules trs_gS in
  let infos_gN := get_infos trs_gN in
  let infos_gS := get_infos trs_gS in
  let rk := (max (rank_main trs_h) (max (max_rankl trs_gN) (max_rankl trs_gS)))+1 in
  let mr := max (max rk trs_h.(maxrank)) (max (maxl (map maxrank trs_gN)) (maxl (map maxrank trs_gS))) in

  let asg := λ l, (asg_main trs_h (map (λ trs, asg_main trs l) trs_gN)) + (suml (map (λ trs, asg_main trs l) trs_gS)) + 
             maxl l in
  let trs_f :=
    one_rule_prog (mk_pvl 0 (n+s)) (fapply trs_h.(main) args_h) {| rank:= rk; asg:=asg;norm:=n|}
    (max (max (n+s) (length trs_gN + length trs_gS)) (max (max (max_arl trs_gN) (max_arl trs_gS)) trs_h.(maxar)))
    rk nf
  in
  {| main := nf ; first := trs_h.(first) ; last := nf ; maxar := trs_f.(maxar) ; maxrank := mr ;
     infos := trs_f.(infos)++trs_h.(infos)++infos_gN++infos_gS ;
     rules := trs_f.(rules)++trs_h.(rules)++rules_gN++rules_gS |}.
Definition Mmc n s trss nf :=
  Mreturn (make_comp n s (fst (fst trss)) (snd (fst trss)) (snd trss) nf).

Definition rule_error nf := (rule_intro nf [p_var 0] (var 0)):rule.
Definition trs_error nf := Mreturn {| main:=nf ; first:= nf ; last:=nf ; maxar:=0 ; maxrank:=1;
                                      infos:=[(nf,{|rank:=0;asg:=Err_assig;norm:=0|})]; rules:=[rule_error nf]|}.
Definition base_info n := {| rank:=1 ; asg:=λ l, 1 + (suml l); norm:=n|}.

Fixpoint BC_to_TRS (bc:BC) :=
  match bc with
  | zero => Mnew_fun >>= (Morp [] tz (base_info 0) 0 1)
  | proj n s i => Mnew_fun >>= (Morp (mk_pvl 0 (n+s)) (var i) (base_info n) (n+s) 1)
  | succ true => Mnew_fun >>= (Morp [px] (ts1 tx) (base_info 0) 1 1)
  | succ false => Mnew_fun >>= (Morp [px] (ts0 tx) (base_info 0) 1 1)
  | pred => Mnew_fun >>= (Mmrp [ [pz] ; [ps0 px] ; [ps1 px] ] [tz ; tx ; tx] (base_info 0) 1 1)
  | cond => Mnew_fun >>= (Mmrp [ [pz; pnul; pfalse ; ptrue] ; [ps0 px ; pnul ; pfalse ; ptrue ] ; [ps1 px ; pnul ; pfalse ; ptrue ] ]
                               [ tnul ; tfalse ; ttrue ] (base_info 0) 4 1)
  | rec g h0 h1 => 
      match (arities bc) with
      | ok_arities n s => let mg:=BC_to_TRS g in let mh0:=BC_to_TRS h0 in let mh1:=BC_to_TRS h1 in
            (mg >>+ mh0 >>++ mh1) >>+ Mnew_fun >>== (Mmr n s)
      | _ =>  Mnew_fun >>= trs_error
      end
  | comp n s h gN gS => 
      let mh := BC_to_TRS h in
      let mgN := lm_to_ml (List.map BC_to_TRS gN) in
      let mgS := lm_to_ml (List.map BC_to_TRS gS) in
      (mh >>+ mgN >>++ mgS) >>+ Mnew_fun >>== (Mmc n s)
  end.

Ltac case_rec bc1 bc2 bc3 := 
  destruct (match arities bc1 with
    | error_rec a a0 a1 => error_rec (error_rec a a0 a1) (arities bc2) (arities bc3)
    | error_comp a l l0 => error_rec (error_comp a l l0) (arities bc2) (arities bc3)
    | error_proj n n0 n1 => error_rec (error_proj n n0 n1) (arities bc2) (arities bc3)
    | ok_arities gn gs =>
        match arities bc2 with
        | error_rec a a0 a1 => error_rec (ok_arities gn gs) (error_rec a a0 a1) (arities bc3)
        | error_comp a l l0 => error_rec (ok_arities gn gs) (error_comp a l l0) (arities bc3)
        | error_proj n n0 n1 => error_rec (ok_arities gn gs) (error_proj n n0 n1) (arities bc3)
        | ok_arities h0n h0s =>
            match arities bc3 with
            | error_rec a a0 a1 => error_rec (ok_arities gn gs) (ok_arities h0n h0s) (error_rec a a0 a1)
            | error_comp a l l0 => error_rec (ok_arities gn gs) (ok_arities h0n h0s) (error_comp a l l0)
            | error_proj n n0 n1 => error_rec (ok_arities gn gs) (ok_arities h0n h0s) (error_proj n n0 n1)
            | ok_arities h1n h1s =>
                if
                 match h0n with
                 | 0 => false
                 | S m' => gn =? m'
                 end && (h0n =? h1n) && match h0s with
                                        | 0 => false
                                        | S m' => gs =? m'
                                        end && (h0s =? h1s)
                then ok_arities h0n gs
                else error_rec (ok_arities gn gs) (ok_arities h0n h0s) (ok_arities h1n h1s)
            end
        end
    end).

Ltac open_rec Hg Hh0 Hh1 := rewrite Hg, Hh0, Hh1; repeat (rewrite Nat.eqb_refl); simpl.

Ltac finish_comp Hfinal :=
  intros m Hm_in; rewrite in_map_iff in Hm_in; destruct Hm_in as [X Hm_in]; destruct Hm_in;
  subst m; intros; apply Hfinal; auto.

Ltac open_monads_rec bc1 bc2 bc3 st:=
  unfold Mbind2, Mmap2, Mnew_fun, Mupdate, Mread, Mmr, Mreturn, Mdo, Mbind, Meval, triple;
  rewrite (surjective_pairing (BC_to_TRS bc1 st));
  rewrite (surjective_pairing (BC_to_TRS bc2 (fst (BC_to_TRS bc1 st))));
  rewrite (surjective_pairing (BC_to_TRS bc3 (fst (BC_to_TRS bc2 (fst (BC_to_TRS bc1 st))))));
  simpl.
Ltac open_monads_comp h gN gS st:=
  unfold Mbind2, Mmap2, Mnew_fun, Mupdate, Mread, Mmc, Mreturn, Mdo, Mbind, Meval, triple;
  rewrite (surjective_pairing (BC_to_TRS h st));
  rewrite (surjective_pairing (lm_to_ml (map BC_to_TRS gN) (fst (BC_to_TRS h st))));
  rewrite (surjective_pairing (lm_to_ml (map BC_to_TRS gS)
                (fst (lm_to_ml (map BC_to_TRS gN) (fst (BC_to_TRS h st))))));
  simpl.

Lemma Mnf_Morp_lt pl t i ma mr:
  Mlt (Mnew_fun >>= (Morp pl t i ma mr)).
Proof.
apply lt_le_Mbind_lt; [ apply Mnew_fun_lt | apply Mreturn_le ].
Qed.
Lemma Mnf_Mmrp_lt pll tl i ma mr:
  Mlt (Mnew_fun >>= (Mmrp pll tl i ma mr)).
Proof.
apply lt_le_Mbind_lt; [ apply Mnew_fun_lt | apply Mreturn_le ].
Qed.
Lemma Mnf_Merr_lt:
  Mlt (Mnew_fun >>= trs_error).
Proof.
apply lt_le_Mbind_lt; [apply Mnew_fun_lt | apply Mreturn_le].
Qed.

Lemma BC_to_TRS_Mlt bc: Mlt (BC_to_TRS bc).
Proof.
induction bc using BC_ind2; try case b; simpl;
  try apply Mnf_Morp_lt; try apply Mnf_Mmrp_lt.
- case_rec bc1 bc2 bc3; try (apply Mnf_Merr_lt).
  apply lt_le_Mbind2_lt; [idtac | intros; apply Mreturn_le].
  apply lt_lt_Mmap2_lt; [idtac | apply Mnew_fun_lt].
  repeat (apply lt_lt_Mmap2_lt; auto).
- apply lt_le_Mbind2_lt; [idtac | intros; apply Mreturn_le].
  apply lt_lt_Mmap2_lt; [idtac | apply Mnew_fun_lt].
  apply lt_le_Mmap2_lt. apply lt_le_Mmap2_lt; auto.
  + apply all_lt_lm_to_ml_le. rewrite Forall_forall. finish_comp H.
  + apply all_lt_lm_to_ml_le. rewrite Forall_forall. finish_comp H0.
Qed.

Proposition BC_to_TRS_Mle bc: Mle (BC_to_TRS bc).
Proof. apply Mlt_Mle_incl. apply BC_to_TRS_Mlt. Qed.
Lemma map_BC_to_TRS_Mle bcl: Mle (lm_to_ml (map BC_to_TRS bcl)).
Proof.
apply all_le_lm_to_ml_le. rewrite Forall_forall. intro. rewrite in_map_iff. intro.
repeat destruct H. apply BC_to_TRS_Mle.
Qed.

Lemma Mnf_Morp_mono pl t i ma mr:
  Mmono (Mnew_fun >>= (Morp pl t i ma mr)).
Proof.
apply mono_mono_Mbind_mono; try apply Mnew_fun_mono. now simpl.
Qed.
Lemma Mnf_Mmrp_mono pll tl i ma mr:
  Mmono (Mnew_fun >>= (Mmrp pll tl i ma mr)).
Proof.
apply mono_mono_Mbind_mono; try apply Mnew_fun_mono. now simpl.
Qed.
Lemma Mnf_Merr_mono:
  Mmono (Mnew_fun >>= trs_error).
Proof.
apply mono_mono_Mbind_mono; try apply Mnew_fun_mono. now simpl.
Qed.

Lemma Mmr_mono_two n s: Mmono_two (Mmr n s).
Proof. now unfold Mmr. Qed.
Lemma Mmc_mono_two n s: Mmono_two (Mmc n s).
Proof. now unfold Mmc. Qed.

Proposition BC_to_TRS_Mmono bc: Mmono (BC_to_TRS bc).
Proof.
induction bc using BC_ind2; try case b; simpl;
  try apply Mnf_Morp_mono; try apply Mnf_Mmrp_mono.
- case_rec bc1 bc2 bc3; try apply Mnf_Merr_mono.
  apply mono_mono_Mbind2_mono; try apply Mmr_mono_two.
  apply mono_mono_Mmap2_mono; try apply Mnew_fun_mono.
  repeat (apply mono_mono_Mmap2_mono; auto).
- apply mono_mono_Mbind2_mono; try apply Mmc_mono_two.
  apply mono_mono_Mmap2_mono; try apply Mnew_fun_mono.
  apply mono_mono_Mmap2_mono. apply mono_mono_Mmap2_mono; auto.
  + apply all_mono_lm_to_ml_mono. rewrite Forall_forall. finish_comp H.
  + apply all_mono_lm_to_ml_mono. rewrite Forall_forall. finish_comp H0.
Qed.
Lemma map_BC_to_TRS_Mmono bcl: Mmono (lm_to_ml (map BC_to_TRS bcl)).
Proof.
apply all_mono_lm_to_ml_mono. rewrite Forall_forall. intro. rewrite in_map_iff.
intro. destruct H. destruct H. subst. apply BC_to_TRS_Mmono.
Qed.

Lemma get_rules_eq trsl: 
  concat (map rules trsl) = get_rules trsl.
Proof. auto. Qed.
Lemma get_rules_cons trs trsl:
  get_rules (trs::trsl) = (rules trs)++(get_rules trsl).
Proof.
unfold get_rules. simpl map. now rewrite concat_cons.
Qed.

Lemma map_mk_tv_is_mk_tvl n m:
  map mk_tv (seq n m) = mk_tvl n (m+n).
Proof.
unfold mk_tvl, ints. apply f_equal2; auto. apply f_equal2; [auto | omega].
Qed.

Lemma tvl_incl n0 m0 n1 m1:
  n1 ≤ n0 ∧ m0 ≤ m1 → incl (mk_tvl n0 m0) (mk_tvl n1 m1).
Proof.
unfold incl, mk_tvl, ints. intros.
rewrite in_map_iff in *. repeat destruct H0.
exists x. split; auto. rewrite in_seq in *.
omega.
Qed.

Lemma pvl_arity : ∀ n m,
  maxl (map (max_arity_pattern (constructor:=constructor)) (mk_pvl n m)) = 0.
Proof.
intros. unfold mk_pvl. rewrite map_map. now rewrite maxl_map_0.
Qed.

Lemma pvl_length : ∀ n m,
  n≤m → length (mk_pvl n m) = m-n.
Proof.
intros. unfold mk_pvl. rewrite map_length. now apply ints_length.
Qed.

Lemma tvl_arity : ∀ n m,
  maxl (map (max_arity_term (constructor:=constructor)) (mk_tvl n m)) = 0.
Proof.
intros. unfold mk_tvl. rewrite map_map. now rewrite maxl_map_0.
Qed.

Lemma tvl_length : ∀ n m,
  n≤m → length (mk_tvl n m) = m-n.
Proof.
intros. unfold mk_tvl. rewrite map_length. now apply ints_length.
Qed.

Lemma tfp_pv_cancelation: ∀ l,
  map term_from_pattern (map mk_pv l) = map mk_tv l.
Proof.
induction l; simpl; auto. now apply f_equal2.
Qed.

Lemma tfp_pvl_is_tvl: ∀ n m,
  map term_from_pattern (mk_pvl n m) = mk_tvl n m.
Proof.
unfold mk_pvl, mk_tvl. intros. apply tfp_pv_cancelation.
Qed.

Lemma no_func_in_tv n:
  functions_of_term (mk_tv n) = [].
Proof. unfold mk_tv. now simpl. Qed.

Lemma no_funcs_in_tvl n m:
  flat_map functions_of_term (mk_tvl n m) = [].
Proof.
unfold mk_tvl. rewrite flat_map_concat_map. rewrite map_map.
replace (map (λ x, functions_of_term (mk_tv x)) (ints n m)) with
        (map (λ x, ([]:list function)) (ints n m)).
- induction (ints n m); simpl; auto.
- now apply f_equal2.
Qed.

Lemma vot_tvl_cancellation m n:
  flat_map (vars_of_term (constructor:=constructor)) (mk_tvl m n) = ints m n.
Proof.
unfold mk_tvl. rewrite flat_map_concat_map. rewrite map_map.
simpl. rewrite concat_unary_is_map. now rewrite map_id.
Qed.

Lemma firstn_tvl p n m:
  firstn p (mk_tvl n m) = mk_tvl n (min (n+p) (m)).
Proof.
unfold mk_tvl, ints. rewrite firstn_map. rewrite firstn_seq.
apply f_equal2; auto. apply f_equal2; auto.
rewrite <- Nat.sub_min_distr_r. apply f_equal2; omega.
Qed.

Lemma skipn_tvl p n m:
  skipn p (mk_tvl n m) = mk_tvl (n+p) m.
Proof.
unfold mk_tvl, ints. rewrite skipn_map. rewrite skipn_seq.
apply f_equal2; auto. apply f_equal2; auto. omega.
Qed.

Lemma pattern_term_list_cast: ∀ m n,
  map (vars_of_pattern (constructor:=constructor)) (mk_pvl m n) =
  map (vars_of_term (constructor:=constructor)) (mk_tvl m n).
Proof.
intros. unfold mk_pvl, mk_tvl, mk_pv, mk_tv.
repeat (rewrite map_map). now simpl.
Qed.

Lemma vop_vot_flat_map_cast m n:
  flat_map (vars_of_pattern (constructor:=constructor)) (mk_pvl m n) =
  flat_map (vars_of_term (constructor:=constructor)) (mk_tvl m n).
Proof.
repeat (rewrite flat_map_concat_map). now rewrite pattern_term_list_cast.
Qed.

Lemma funcs_in_mk_args a b c f:
  flat_map functions_of_term (mk_args_h a b (mk_call c f)) = [f].
Proof.
unfold mk_args_h, mk_call.
rewrite flat_map_app. simpl flat_map.
repeat rewrite no_funcs_in_tvl. now simpl.
Qed.

Lemma funcs_in_mk_call trsl n:
  flat_map functions_of_term (map (mk_call_trs n) trsl) = map main trsl.
Proof.
unfold mk_call_trs, mk_call.
rewrite flat_map_concat_map, map_map. simpl.
now rewrite no_funcs_in_tvl, concat_unary_is_map.
Qed.

Definition lhs_func (r:rule):= 
  match r with
  | rule_intro f _ _ => f
  end.
Definition all_lhs_funcs x := map lhs_func (rules x).
Lemma lhs_funcs_eq x: 
  map lhs_func (rules x) = all_lhs_funcs x.
Proof. auto. Qed.

Lemma lhs_get_rules trsl:
  map lhs_func (get_rules trsl) = flat_map all_lhs_funcs trsl.
Proof.
unfold get_rules, all_lhs_funcs. rewrite flat_map_concat_map.
now rewrite concat_map, map_map.
Qed.

Lemma rule_intro_is_lhs f trs:
  (∃ lp t, rule_intro f lp t ∈ rules trs) ↔ f ∈ all_lhs_funcs trs.
Proof.
unfold all_lhs_funcs, lhs_func. rewrite in_map_iff.
split; intro; repeat destruct H.
- now exists (rule_intro f x x0).
- destruct x. eauto.
Qed.

Definition rhs_funcs ru :=  
  match ru with
  | rule_intro _ _ t => functions_of_term t
  end.
Definition all_rhs_funcs prg := flat_map rhs_funcs prg.
Lemma rhs_funcs_eq prg: 
  flat_map rhs_funcs prg = all_rhs_funcs prg.
Proof. auto. Qed.

Lemma get_info_main_eq trs:
  match assoc Nat.eqb trs.(main) trs.(infos)
  with
  | Some inf => inf
  | None => Err_info
  end = get_info trs trs.(main).
Proof. auto. Qed.

Lemma get_info_l_eq trsl f:
  match assoc Nat.eqb f (concat (map infos trsl)) with
  | Some inf => inf
  | None => Err_info
  end = get_info_l trsl f.
Proof. now unfold get_info_l, get_infos. Qed.

Lemma get_rank_eq f trs inf:
  assoc Nat.eqb f (infos trs) = Some inf →
  rank inf = get_rank trs f.
Proof. intro. unfold get_rank, get_info. now rewrite H. Qed.

Lemma asg_main_eq trs:
  asg (get_info trs trs.(main)) = asg_main trs.
Proof. auto. Qed.

Lemma qif_eq trs:
  (λ f l,
  let inf := get_info trs f in
  let q := inf.(asg) in let norm := inf.(norm) in
  let l1 := firstn norm l in let l2 := skipn norm l in
  (q l1) + (maxl l2)) =  qif trs.
Proof. now unfold qif. Qed.

Lemma qif_eq_eta trs f l:
  let inf := get_info trs f in
  let q := inf.(asg) in let norm := inf.(norm) in
  let l1 := firstn norm l in let l2 := skipn norm l in
  (q l1) + (maxl l2) =  qif trs f l.
Proof. now unfold qif. Qed.

Lemma rvd_make_rec n s g h0 h1 f:

  Forall rule_vars_defined g.(rules) →
  Forall rule_vars_defined h0.(rules) →
  Forall rule_vars_defined h1.(rules) →
  Forall rule_vars_defined (make_rec (S n) s g h0 h1 f).(rules).
Proof.
intros. unfold make_rec, rules at 1.
unfold multi_rules_prog, simple_prog, rules at 1.
simpl. unfold sr_uncurry, simple_rule.
repeat rewrite Forall_cons_iff. repeat rewrite Forall_app_iff.
unfold rule_vars_defined at 1 2 3. simpl.
repeat rewrite vop_vot_flat_map_cast. split; try apply incl_refl.
rewrite <- and_assoc, <- and_idem. intuition.
unfold mk_call. rewrite flat_map_app. simpl flat_map at 2.
repeat rewrite map_mk_tv_is_mk_tvl.
repeat rewrite vot_tvl_cancellation.
unfold incl. simpl. intuition.
rewrite in_app_iff in H3. simpl in H3. rewrite in_app_iff in H3.
rewrite <- ints_bounds_iff; [idtac | omega].
repeat (rewrite <- ints_bounds_iff in H3; [idtac | omega]).
intuition.
Qed.

Lemma rvd_make_comp n s h gN gS f:

  Forall rule_vars_defined h.(rules) →
  Forall rule_vars_defined (flat_map rules gN) →
  Forall rule_vars_defined (flat_map rules gS) →
  Forall rule_vars_defined (make_comp n s h gN gS f).(rules).
Proof.
intros. unfold make_comp, rules at 1, get_rules.
unfold one_rule_prog, simple_prog, rules at 1, simple_rule.
repeat rewrite <- flat_map_concat_map.
repeat rewrite Forall_app_iff. repeat split; auto.
rewrite Forall_unary. unfold rule_vars_defined, incl.
unfold mk_call_trs, mk_call. simpl.
rewrite flat_map_app. rewrite vop_vot_flat_map_cast.
rewrite vot_tvl_cancellation. intro.
repeat (rewrite flat_map_concat_map).
repeat (rewrite map_map). simpl vars_of_term.
repeat (rewrite flat_map_concat_map). rewrite in_app_iff.
repeat (rewrite in_concat_const_is_in).
repeat (rewrite <- flat_map_concat_map).
repeat (rewrite vot_tvl_cancellation).
repeat (rewrite <- ints_bounds_iff; [idtac | omega]).
intuition.
Qed.

Proposition BC_to_TRS_rules_vars_defined bc n s st:
  let trs := snd (BC_to_TRS bc st) in
  arities bc = ok_arities n s →
  Forall rule_vars_defined trs.(rules).
Proof.
intro trs. subst trs.
intro Har. revert st. generalize Har. 
apply BC_ind_inf with (e:=bc) (n:=n) (s:=s); intros; try case b; auto; simpl;
  unfold sr_uncurry, simple_rule; rewrite Forall_forall; simpl; intros x Hin;
  repeat destruct Hin as [Hin | Hin]; try tauto; try inversion Hin; simpl;
  try apply incl_refl; unfold incl; simpl; try tauto.
- rewrite vop_vot_flat_map_cast, vot_tvl_cancellation.
  intros. repeat destruct H1. rewrite <- ints_bounds_iff; omega.
- revert Hin. open_rec H H0 H1. revert x. rewrite <- Forall_forall.
  apply Mbind2_triple; auto. intros.
  unfold Mmr, Mreturn, snd at 1.
  now apply rvd_make_rec.
- revert Hin. revert x. rewrite <- Forall_forall.
  apply Mbind2_list; auto; intros.
  + apply lm_to_ml_ind. finish_comp H3.
  + apply lm_to_ml_ind. finish_comp H4.
  + unfold Mmc, Mreturn, snd at 1.
    rewrite <- Forall_flat_map in H6, H7.
    now apply rvd_make_comp.
Qed.

Lemma max_arity_prog_cons (r:rule) rl: 
  max_arity_prog (r::rl) =
  max (max_arity_rule r) (max_arity_prog rl).
Proof. unfold max_arity_prog. now rewrite map_cons, maxl_cons. Qed.
Lemma max_arity_prog_app (prg1 prg2: list rule): 
  max_arity_prog (prg1++prg2) = 
  max (max_arity_prog prg1) (max_arity_prog prg2).
Proof.
unfold max_arity_prog. rewrite map_app. now rewrite maxl_app.
Qed.

Lemma max_arity_fapply_app f (l1 l2: list term): 
  max_arity_term (fapply f (l1++l2)) = 
  max (length (l1++l2))
      (max (maxl (map (@max_arity_term _ _ _) l1))
           (maxl (map (@max_arity_term _ _ _) l2))).
Proof. simpl. now rewrite map_app, maxl_app. Qed.

Lemma max_arity_fapply_tvl f n m:
  n≤m → max_arity_term (fapply f (mk_tvl n m)) = m-n.
Proof. intro. simpl. rewrite tvl_length, tvl_arity; auto. now rewrite Nat.max_0_r. Qed.

Lemma max_arity_fapply_args f h n s:
  max_arity_term (fapply h (mk_args_h (S n) s (mk_call (S (n + s)) f))) =
  n+s+2.
Proof.
unfold mk_args_h, mk_call.
rewrite max_arity_fapply_app, map_cons, maxl_cons, app_length, max_arity_fapply_tvl.
simpl length at 2. repeat rewrite tvl_arity, tvl_length. simpl.
zify; omega. omega. omega. omega.
Qed.

Lemma max_arity_map_mk_call n (l: list trs_prog):
  l ≠ [] → (maxl (map (@max_arity_term _ _ _) (map (mk_call_trs n) l))) = n.
Proof.
unfold mk_call_trs, mk_call. rewrite map_map.
replace (λ x, max_arity_term (fapply (main x) (mk_tvl 0 n)))
   with (λ x : trs_prog, n).
- now apply maxl_map_const.
- simpl. rewrite tvl_arity, tvl_length.
  + rewrite Nat.max_0_r. replace (n-0) with n; auto. omega.
  + omega.
Qed.

Lemma max_arity_make_rec n s g h0 h1 f:
  max_arity_prog (rules g) ≤ maxar g →
  max_arity_prog (rules h0) ≤ maxar h0 →
  max_arity_prog (rules h1) ≤ maxar h1 →
  max_arity_prog (rules (make_rec (S n) s g h0 h1 f)) ≤
    maxar (make_rec (S n) s g h0 h1 f).
Proof.
intros. unfold make_rec, rules at 1, maxar at 4, multi_rules_prog, sr_uncurry, simple_prog.
unfold rules at 1, maxar at 1. simpl map. unfold simple_rule.
repeat rewrite max_arity_prog_app.
repeat rewrite Nat.max_lub_iff. repeat rewrite Nat.max_le_iff.
intuition. left. left. clear H H0 H1.
unfold max_arity_prog, map, maxl, max_arity_rule. repeat rewrite Nat.max_lub_iff.
simpl length. simpl map. simpl maxl. rewrite pvl_arity.
rewrite max_arity_fapply_tvl. repeat rewrite max_arity_fapply_args.
repeat rewrite pvl_length. omega. omega. omega.
Qed.

Lemma max_arity_make_comp n s h gN gS f:
  max_arity_prog (rules h) ≤ maxar h →
  (max_arity_prog (concat (map rules gN))) ≤ maxl (map maxar gN) →
  (max_arity_prog (concat (map rules gS))) ≤ maxl (map maxar gS) →
  max_arity_prog (rules (make_comp n s h gN gS f)) ≤ maxar (make_comp n s h gN gS f).
Proof.
intros. simpl. rewrite max_arity_prog_cons.
repeat rewrite max_arity_prog_app.
unfold simple_rule, max_arity_rule.
rewrite pvl_arity, pvl_length; [idtac | omega].
rewrite max_arity_fapply_app, app_length.
repeat rewrite map_length. destruct gN; destruct gS.
- simpl. unfold max_arity_prog at 2, get_rules, map at 2, concat, max_arl, map, maxl.
  repeat rewrite Nat.max_lub_iff. repeat rewrite Nat.max_le_iff.
  intuition.
- simpl map at 2. simpl map at 1. simpl maxl at 1.
  rewrite max_arity_map_mk_call; try discriminate.
  simpl length at 1 3.
  unfold get_rules at 1, map, concat, max_arity_prog at 2, max_arl at 1, map, maxl.
  repeat rewrite Nat.max_lub_iff. repeat rewrite Nat.max_le_iff.
  intuition.
- simpl map at 4. simpl map at 3. simpl maxl at 2.
  rewrite max_arity_map_mk_call; try discriminate.
  simpl length at 2 4.
  unfold get_rules at 2, map, concat, max_arity_prog at 3, max_arl at 2, map, maxl.
  repeat rewrite Nat.max_lub_iff. repeat rewrite Nat.max_le_iff.
  intuition.
- repeat rewrite max_arity_map_mk_call; try discriminate.
  repeat rewrite Nat.max_lub_iff. repeat rewrite Nat.max_le_iff.
  intuition.
Qed.

Lemma max_arity_prog_forall l:
  Forall (λ prg, max_arity_prog (rules prg) ≤ maxar prg) l →
  (max_arity_prog (concat (map rules l))) ≤ maxl (map maxar l).
Proof.
induction l; simpl; intros; unfold max_arity_prog; auto.
rewrite map_app, maxl_app. rewrite Forall_forall in H, IHl.
apply Nat.max_le_compat.
- apply H. now left.
- apply IHl. intros. apply H. now right.
Qed.

Proposition BC_to_TRS_arity bc n s st:
  let trs := snd (BC_to_TRS bc st) in
  arities bc = ok_arities n s →
  max_arity_prog trs.(rules) ≤ trs.(maxar).
Proof.
intro trs. subst trs. intro Har. revert st. generalize Har.
apply BC_ind_inf with (e:=bc) (n:=n) (s:=s); auto; intros; try case b; simpl; intuition.
- unfold simple_rule, max_arity_prog, max_arity_rule.
  simpl. rewrite pvl_length; [idtac | omega]. rewrite pvl_arity.
  repeat rewrite Nat.max_0_r. omega.
- open_rec H H0 H1. apply Mbind2_triple; auto.
  intros. unfold Mmr, Mreturn, snd at 1 4.
  now apply max_arity_make_rec.
- apply Mbind2_list; auto; intros.
  + apply lm_to_ml_ind. finish_comp H3.
  + apply lm_to_ml_ind. finish_comp H4.
  + unfold Mmc, Mreturn. unfold snd at 1 4.
    apply max_arity_make_comp; auto using max_arity_prog_forall.
Qed.

Theorem BC_to_TRS_wf bc n s st:
  let trs := snd (BC_to_TRS bc st) in
  arities bc = ok_arities n s →
  wf_prog trs.(maxar) trs.(rules).
Proof.
intros. split.
- rewrite <- forall_andl. now apply (BC_to_TRS_rules_vars_defined bc n s).
- now apply (BC_to_TRS_arity bc n s).
Qed.

Lemma BC_to_TRS_state_bounds bc st:
  let (st',trs) := BC_to_TRS bc st in
  st+1 = trs.(first) ∧ trs.(last) = st'.
Proof.
rewrite (surjective_pairing (BC_to_TRS bc st)). revert st.
induction bc using BC_ind2; try case b; simpl; auto with *; intro.

- case_rec bc1 bc2 bc3; simpl; auto with *.
  rewrite forall_and in IHbc1, IHbc2, IHbc3. destruct IHbc1, IHbc2, IHbc3.
  open_monads_rec bc1 bc2 bc3 st. auto.
- rewrite forall_and in IHbc. destruct IHbc.
  open_monads_comp bc rl tl st. auto.
Qed.

Lemma BC_to_TRS_first bc st:
  (snd (BC_to_TRS bc st)).(first) = st+1.
Proof.
generalize (BC_to_TRS_state_bounds bc st).
now rewrite (surjective_pairing (BC_to_TRS bc st)).
Qed.
Lemma BC_to_TRS_last bc st:
  (snd (BC_to_TRS bc st)).(last) = fst (BC_to_TRS bc st).
Proof.
generalize (BC_to_TRS_state_bounds bc st).
now rewrite (surjective_pairing (BC_to_TRS bc st)).
Qed.

Lemma BC_to_TRS_first_le_last bc st:
  let trs := snd (BC_to_TRS bc st) in
  trs.(first) ≤ trs.(last).
Proof.
intro. subst trs0.
rewrite BC_to_TRS_first, BC_to_TRS_last.
generalize (BC_to_TRS_Mlt bc st). unfold Meval. omega.
Qed.

Lemma funcs_bounds_aux bcl st st' f f_up:
  fmono f_up →
  (∀ bc, bc ∈ bcl → ∀ s f', f' ∈ all_lhs_funcs (snd (BC_to_TRS bc s)) →
   s+1 <= f' <= f_up (fst (BC_to_TRS bc s))) →
  st <= st' →
  f ∈ map lhs_func (get_rules (snd (lm_to_ml (map BC_to_TRS bcl) st'))) → 
  st+1 <= f <= f_up (fst (lm_to_ml (map BC_to_TRS bcl) st')).
Proof.
intros.
apply lm_to_ml_bounds with (f_in:=lhs_func) (r:=rules)
  (f_low:=λ x, x+1); auto.
- unfold fmono. intros. now apply Nat.add_le_mono.
- rewrite <- Forall_map_iff. intros. now apply BC_to_TRS_Mle.
- intros mtrs s0 n'.
  rewrite in_map_iff. intros. repeat destruct H3.
  split; try apply (H0 x); auto.
Qed.

Proposition BC_to_TRS_func_bounds bc st f:
  let trs := snd (BC_to_TRS bc st) in
  f ∈ all_lhs_funcs trs → trs.(first) ≤ f ≤ trs.(last).
Proof.
intro. subst trs0. rewrite BC_to_TRS_first, BC_to_TRS_last. revert st f.
induction bc using BC_ind2; try case b; simpl; try (case_rec bc1 bc2 bc3);
  simpl; auto with *; intros st f.
- 
  open_monads_rec bc1 bc2 bc3 st.
  repeat (rewrite <- or_assoc, <- or_idem). repeat rewrite map_app, in_app_iff.
  repeat rewrite lhs_funcs_eq.
  generalize BC_to_TRS_Mle as HMle. unfold Mle, Meval. intro.
  generalize (HMle bc1 st).
  generalize (HMle bc2 (fst (BC_to_TRS bc1 st))).
  generalize (HMle bc3 (fst (BC_to_TRS bc2 (fst (BC_to_TRS bc1 st))))).
  intuition.
  + now apply IHbc1.
  + apply le_trans with (m:=fst (BC_to_TRS bc2 (fst (BC_to_TRS bc1 st)))); auto.
    apply le_trans with (m:=fst (BC_to_TRS bc1 st)); auto. now apply IHbc1.
  + generalize (IHbc2 (fst (BC_to_TRS bc1 st)) f H3). intro. omega.
  + apply le_trans with (m:=fst (BC_to_TRS bc2 (fst (BC_to_TRS bc1 st)))); auto.
    now apply IHbc2.
  + generalize (IHbc3 (fst (BC_to_TRS bc2 (fst (BC_to_TRS bc1 st)))) f H3). intro. omega.
  + apply le_trans with (m:=fst (BC_to_TRS bc3 (fst (BC_to_TRS bc2 (fst (BC_to_TRS bc1 st)))))); auto.
    now apply IHbc3.
- open_monads_comp bc rl tl st.
  repeat rewrite map_app, in_app_iff. rewrite lhs_funcs_eq.
  intro. repeat destruct H1.
  + split; auto. rewrite <- S_is_suc, <- Nat.succ_le_mono.
    apply le_trans with (m:=fst (BC_to_TRS bc st)); try apply BC_to_TRS_Mle.
    apply le_trans with (m:=fst (lm_to_ml (map BC_to_TRS rl) (fst (BC_to_TRS bc st))));
      apply map_BC_to_TRS_Mle.
  + split; try apply IHbc; auto.
    apply le_trans with (m:=fst (BC_to_TRS bc st)); try apply IHbc; auto.
    apply le_trans with (m:=fst (lm_to_ml (map BC_to_TRS tl)
          (fst (lm_to_ml (map BC_to_TRS rl) (fst (BC_to_TRS bc st)))))); auto.
    apply le_trans with (m:=fst (lm_to_ml (map BC_to_TRS rl) (fst (BC_to_TRS bc st))));
      apply map_BC_to_TRS_Mle.
  + apply funcs_bounds_aux with (bcl:=rl) (st':=(fst (BC_to_TRS bc st)))
          (f_up:=λ x, S (fst (lm_to_ml (map BC_to_TRS tl) x))); auto.
    * unfold fmono. intros. rewrite <- Nat.succ_le_mono. now apply map_BC_to_TRS_Mmono.
    * intros. split; try apply (H bc0); auto.
      apply le_trans with (m:=fst (BC_to_TRS bc0 s0)); try apply H; auto.
      apply le_trans with (m:=fst (lm_to_ml (map BC_to_TRS tl) (fst (BC_to_TRS bc0 s0)))); auto.
      apply map_BC_to_TRS_Mle.
    * apply BC_to_TRS_Mle.
  + apply funcs_bounds_aux with (bcl:=tl) (f_up:=S)
      (st':=(fst (lm_to_ml (map BC_to_TRS rl) (fst (BC_to_TRS bc st))))); auto.
    * unfold fmono. now apply Nat.succ_le_mono.
    * intros. split; try apply (H0 bc0); auto.
      apply le_trans with (m:=fst (BC_to_TRS bc0 s0)); auto. now apply (H0 bc0).
    * apply le_trans with (m:= fst (BC_to_TRS bc st)); try apply BC_to_TRS_Mle.
      apply map_BC_to_TRS_Mle.
Qed.

Lemma BC_to_TRS_main_is_last bc st:
  let trs := snd (BC_to_TRS bc st) in
  trs.(main) = trs.(last).
Proof.
intro trs. subst trs. revert st.
induction bc using BC_ind2; try case b; simpl; auto; intro.
- case_rec bc1 bc2 bc3; unfold trs_error, Mnew_fun, Mupdate, Mread;
    simpl; auto.
  now open_monads_rec bc1 bc2 bc3 st.
- now open_monads_comp bc rl tl st.
Qed.

Lemma map_BC_to_TRS_func_bounds bcl st f:
  let lm := map BC_to_TRS bcl in
  let trsl := snd ((lm_to_ml lm) st) in
  let lst := fst ((lm_to_ml lm) st) in
  f ∈ flat_map all_lhs_funcs trsl → st+1 ≤ f ≤ lst.
Proof.
intros. subst lm trsl lst.
unfold all_lhs_funcs in H. 
apply lm_to_ml_bounds with (r:=rules) (f_in:=lhs_func) (f_low:=λ x, x+1) (f_up:=λ x, x); auto.
- unfold fmono. intros. omega.
- now unfold fmono.
- rewrite Forall_forall. intros. rewrite in_map_iff in H0.
  repeat destruct H0. apply BC_to_TRS_Mle.
- intros. rewrite in_map_iff in H0. repeat destruct H0.
  rewrite <- (BC_to_TRS_first x). rewrite <- BC_to_TRS_last.
  apply BC_to_TRS_func_bounds. apply H1.
- rewrite concat_map, map_map. now rewrite flat_map_concat_map in H.
Qed.

Lemma BC_to_TRS_all_funs_have_info bc st f:
  let trs := snd (BC_to_TRS bc st) in
  f ∈ all_lhs_funcs trs → f ∈ map fst trs.(infos).
Proof.
intro trs. subst trs. revert st.
induction bc using BC_ind2; try case b; simpl; try tauto; intro.
- case_rec bc1 bc2 bc3; simpl in *; try tauto.
  apply Mbind2_triple; auto. intros. revert H2.
  unfold Mmr, Mreturn, snd at 1 4.
  simpl. repeat rewrite map_app, in_app_iff.
  intuition.
- apply Mbind2_list; auto; intros.
  + apply lm_to_ml_ind. finish_comp H.
  + apply lm_to_ml_ind. finish_comp H0.
  + revert H4. unfold Mmc, Mreturn, snd at 1 4.
    simpl. repeat rewrite map_app, in_app_iff.
    unfold get_rules, get_infos. repeat rewrite concat_map, map_map.
    rewrite Forall_forall in H2, H3. repeat rewrite in_concat_iff.
    intuition; right; right; repeat destruct H5;
      rewrite in_map_iff in H4; repeat destruct H4.
    * left. exists (map fst (infos x0)).
      split; try apply in_map with (f:=λ x, map fst (infos x)); auto.
    * right. exists (map fst (infos x0)).
      split; try apply in_map with (f:=λ x, map fst (infos x)); auto.
Qed.

Lemma BC_to_TRS_only_funs_have_info bc st f:
  let trs := snd (BC_to_TRS bc st) in
  f ∈ map fst trs.(infos) → f ∈ all_lhs_funcs trs.
Proof.
intro trs. subst trs. revert st.
induction bc using BC_ind2; try case b; simpl; try tauto; intro.
- case_rec bc1 bc2 bc3; simpl; try tauto.
  apply Mbind2_triple; auto. intros. revert H2.
  unfold Mmr, Mreturn, snd at 1 4.
  simpl. repeat rewrite map_app, in_app_iff.
  intuition.
- apply Mbind2_list; auto; intros.
  + apply lm_to_ml_ind. finish_comp H.
  + apply lm_to_ml_ind. finish_comp H0.
  + revert H4. unfold Mmc, Mreturn, snd at 1 4.
    simpl. repeat rewrite map_app, in_app_iff.
    unfold get_rules, get_infos. repeat rewrite concat_map, map_map.
    rewrite Forall_forall in H2, H3. repeat rewrite in_concat_iff.
    replace (λ x, map lhs_func (rules x)) with (all_lhs_funcs); auto.
    intuition; right; right; repeat destruct H5;
      rewrite in_map_iff in H4; repeat destruct H4.
    * left. exists (all_lhs_funcs x0).
      split; try apply in_map; auto.
    * right. exists (all_lhs_funcs x0).
      split; try apply in_map; auto.
Qed.

Proposition BC_to_TRS_infos_iff bc st f:
  let trs := snd (BC_to_TRS bc st) in
  f ∈ map fst trs.(infos) ↔ f ∈ all_lhs_funcs trs.
Proof.
intro trs. subst trs. split;
auto using BC_to_TRS_only_funs_have_info, BC_to_TRS_all_funs_have_info.
Qed.

Lemma BC_to_TRS_info_explicit bc st f:
  let trs := snd (BC_to_TRS bc st) in
  f ∈ all_lhs_funcs (snd (BC_to_TRS bc st)) →
  (f, get_info trs f) ∈ trs.(infos).
Proof.
intro trs. subst trs. intro.
apply assoc_in with (beq := Nat.eqb); auto.
unfold get_info.
case_eq (assoc Nat.eqb f (infos (snd (BC_to_TRS bc st)))); auto.
intro. exfalso.
rewrite <- BC_to_TRS_infos_iff in H.
rewrite (assoc_in_Some_simple Nat.eqb) in H; auto.
destruct H. rewrite H in H0. discriminate.
Qed.

Lemma map_BC_to_TRS_infos_iff bcl st f:
  f ∈ flat_map all_lhs_funcs (snd (lm_to_ml (map BC_to_TRS bcl) st)) ↔
  f ∈ map fst (get_infos (snd (lm_to_ml (map BC_to_TRS bcl) st))).
Proof.
split; intro.
- rewrite in_flat_map in H. repeat destruct H.
  generalize (in_lm_to_ml x (map BC_to_TRS bcl) st H).
  intro. repeat destruct H1.
  rewrite in_map_iff in *. repeat destruct H1.
  exists (f, (get_info x f)). simpl. split; auto.
  unfold get_infos. rewrite in_concat_iff. exists (infos x). split.
  + rewrite in_map_iff. eauto.
  + subst x. now apply BC_to_TRS_info_explicit.
- rewrite in_map_iff in H. repeat destruct H. unfold get_infos in H0.
  rewrite in_concat_iff in H0. repeat destruct H0. destruct H.
  rewrite in_map_iff in H. repeat destruct H.
  rewrite in_flat_map. exists x1. split; auto.
  generalize (in_lm_to_ml x1 (map BC_to_TRS bcl) st H1). intro.
  repeat destruct H. rewrite in_map_iff in H. repeat destruct H.
  subst x1. apply BC_to_TRS_infos_iff. now apply in_map.
Qed.

Lemma BC_to_TRS_main_defined bc st:
  let trs := snd (BC_to_TRS bc st) in
  trs.(main) ∈ all_lhs_funcs trs.
Proof.
intro trs. subst trs. revert st.
induction bc using BC_ind2; try case b; simpl; auto; intro.
- case_rec bc1 bc2 bc3; unfold trs_error, Mnew_fun, Mupdate, Mread;
    simpl; auto.
  open_monads_rec bc1 bc2 bc3 st. now left.
- open_monads_comp bc rl tl st. now left.
Qed.

Lemma BC_to_TRS_rhs_funcs_defined bc st:
  let trs := snd (BC_to_TRS bc st) in
  incl (all_rhs_funcs trs.(rules)) (all_lhs_funcs trs).
Proof.
intros trs. subst trs. revert st.
induction bc using BC_ind2; intro; try case b; simpl; try apply incl_nil.
- case_rec bc1 bc2 bc3; unfold trs_error; simpl; try apply incl_nil.
    apply and_left with (B := main (snd
           ((BC_to_TRS bc1 >>+ BC_to_TRS bc2 >>++ BC_to_TRS bc3 >>+
             Mnew_fun >>== Mmr n n0) st))
     ∈ all_lhs_funcs (snd
           ((BC_to_TRS bc1 >>+ BC_to_TRS bc2 >>++ BC_to_TRS bc3 >>+
             Mnew_fun >>== Mmr n n0) st))).
    apply Mbind2_triple with (P :=
      (λ trs, (incl (all_rhs_funcs trs.(rules)) (all_lhs_funcs trs) ∧
              trs.(main) ∈ all_lhs_funcs trs)));
      split; auto using BC_to_TRS_main_defined.
  + unfold incl, all_rhs_funcs, all_lhs_funcs. intro. simpl.
    rewrite no_funcs_in_tvl. repeat rewrite funcs_in_mk_args. simpl.
    repeat rewrite flat_map_app, map_app.
    repeat rewrite in_app_iff, lhs_funcs_eq. rewrite in_app_iff.
    intuition; right; right; right.
    * left. now rewrite H1 in H4.
    * right. left. now rewrite H2 in H5.
    * right. right. now rewrite H2 in H6.
  + now left.
- apply and_left with (B:= main (snd
           ((BC_to_TRS bc >>+ lm_to_ml (map BC_to_TRS rl) >>++
             lm_to_ml (map BC_to_TRS tl) >>+ Mnew_fun >>== Mmc n s) st))
   ∈ all_lhs_funcs (snd
           ((BC_to_TRS bc >>+ lm_to_ml (map BC_to_TRS rl) >>++
             lm_to_ml (map BC_to_TRS tl) >>+ Mnew_fun >>== Mmc n s) st))).
  apply Mbind2_list with (P :=
    (λ trs, (incl (all_rhs_funcs trs.(rules)) (all_lhs_funcs trs) ∧
              trs.(main) ∈ all_lhs_funcs trs)));
    try apply lm_to_ml_ind; split; auto using BC_to_TRS_main_defined;
    try revert ma H1.
  + finish_comp H.
  + finish_comp BC_to_TRS_main_defined.
  + finish_comp H0.
  + finish_comp BC_to_TRS_main_defined.
  + simpl. unfold all_rhs_funcs. repeat rewrite flat_map_app.
    repeat rewrite funcs_in_mk_call. unfold incl.
    intro. simpl. repeat rewrite map_app. repeat rewrite in_app_iff.
    repeat rewrite lhs_get_rules. rewrite lhs_funcs_eq. rewrite rhs_funcs_eq.
    rewrite (rhs_funcs_eq (get_rules (snd (fst xyz)))). rewrite (rhs_funcs_eq (get_rules (snd xyz))).
    rewrite Forall_forall in H2, H3.
    intuition; right.
    * left. now rewrite H1 in H6.
    * right. left. apply incl_map_flat_map with (f:=main); auto. intros.
      now apply H2.
    * right. right. apply incl_map_flat_map with (f:=main); auto. intros.
      now apply H3.
    * right. left. apply incl_flat_map_incl with (r:=rules) (rh:=rhs_funcs); auto.
      intros. now apply H2.
    * right. right. apply incl_flat_map_incl with (r:=rules) (rh:=rhs_funcs); auto.
      intros. now apply H3.
  + now left.
Qed.

Lemma map_BC_to_TRS_lhs_in bcl st r:
  r ∈ get_rules (snd ((lm_to_ml (map BC_to_TRS bcl)) st)) →
  (lhs_func r) ∈ flat_map all_lhs_funcs (snd (lm_to_ml (map BC_to_TRS bcl) st)).
Proof.
unfold get_rules. rewrite flat_map_concat_map. intros.
rewrite in_concat_iff in *. repeat destruct H. exists (map lhs_func x). split.
- rewrite in_map_iff in *. repeat destruct H. exists x0. auto.
- now apply in_map.
Qed.

Lemma BC_to_TRS_pos_maxrank bc st:
  let trs := snd (BC_to_TRS bc st) in
  0 < trs.(maxrank).
Proof.
intro trs. subst trs.
induction bc using BC_ind2; try case b; simpl; auto.
- case_rec bc1 bc2 bc3; simpl; auto.
  open_monads_rec bc1 bc2 bc3 st. zify; omega.
- open_monads_comp bc rl tl st. zify; omega.
Qed.

Lemma BC_to_TRS_maxrank bc st:
  let trs := snd (BC_to_TRS bc st) in
  maxl (map rank (map snd trs.(infos))) ≤ trs.(maxrank).
Proof.
intro trs. subst trs. revert st.
induction bc using BC_ind2; try case b; simpl; auto; intro.
- case_rec bc1 bc2 bc3; simpl; auto.
  apply Mbind2_triple; auto. intros.
  unfold Mmr, Mreturn, snd at 2 5.
  simpl. unfold max_rank3.
  repeat rewrite map_app. repeat rewrite maxl_app.
  repeat rewrite Nat.max_lub_iff. repeat rewrite Nat.max_le_iff.
  intuition.
- apply Mbind2_list; auto; intros.
  + apply lm_to_ml_ind. finish_comp H.
  + apply lm_to_ml_ind. finish_comp H0.
  + unfold Mmc, Mreturn, snd at 2 5.
    simpl. unfold max_rankl. rewrite Forall_forall in H2, H3.
    repeat rewrite map_app. repeat rewrite maxl_app.
    repeat rewrite Nat.max_lub_iff. repeat rewrite Nat.max_le_iff.
    unfold get_infos. intuition; right.
    * left. repeat rewrite concat_map, map_map.
      rewrite maxl_concat, maxl_map_le_iff. intros.
      rewrite in_map_iff in H4. repeat destruct H4.
      apply le_trans with (m:=maxrank x); auto.
      now apply maxl_map_is_max_map.
    * right. repeat rewrite concat_map, map_map.
      rewrite maxl_concat, maxl_map_le_iff. intros.
      rewrite in_map_iff in H4. repeat destruct H4.
      apply le_trans with (m:=maxrank x); auto.
      now apply maxl_map_is_max_map.
Qed.

Lemma BC_to_TRS_maxrank_is_max_rank bc st:
  let trs := snd (BC_to_TRS bc st) in
  ∀ f, f ∈ all_lhs_funcs trs →
  get_rank trs f <= trs.(maxrank).
Proof.
intro trs. subst trs. intros.
rewrite <- BC_to_TRS_infos_iff in H.
rewrite assoc_in_Some in H; auto.
repeat destruct H.
unfold get_rank, get_info.
replace (assoc Nat.eqb f (infos (snd (BC_to_TRS bc st)))) with (Some x).
apply le_trans with (m:=maxl (map rank (map snd (infos (snd (BC_to_TRS bc st)))))).
- now apply maxl_map_is_max_map.
- apply BC_to_TRS_maxrank.
Qed.

Lemma BC_to_TRS_maxrank_is_max_rank_error bc st:
  let trs := snd (BC_to_TRS bc st) in
  ∀ f, get_rank trs f <= trs.(maxrank).
Proof.
intro trs. subst trs. intro.
case_eq (assoc Nat.eqb f (infos (snd (BC_to_TRS bc st)))).
- intros. apply BC_to_TRS_maxrank_is_max_rank. rewrite <- BC_to_TRS_infos_iff.
  rewrite assoc_in_Some_simple; eauto.
- intro. unfold get_rank, get_info. rewrite H. simpl. omega.
Qed.

Lemma BC_to_TRS_main_has_maxrank bc st n s:
  let trs := snd (BC_to_TRS bc st) in
  arities bc = ok_arities n s →
  get_rank trs trs.(main) = trs.(maxrank).
Proof.
intro trs. subst trs. intro Har. generalize Har. revert st.
apply BC_ind_inf with (e:=bc) (n:=n) (s:=s); intros; try case b; simpl;
  unfold multi_rules_prog, one_rule_prog, simple_prog; auto.
1, 2, 3, 4, 5, 6: unfold get_rank, get_info; simpl;
  try rewrite Nat.eqb_refl; auto.
- open_rec H H0 H1.
  apply Mbind2_triple; auto. clear. intros.
  unfold Mmr. simpl.
  unfold make_rec, get_rank, get_info. simpl.
  rewrite Nat.eqb_refl. simpl.
  unfold max_rank3, rank_main. rewrite H, H0, H1.
  zify; omega.
- apply Mbind2_list; auto.
  + apply lm_to_ml_ind. finish_comp H3.
  + apply lm_to_ml_ind. finish_comp H4.
  + intros. unfold Mmc. simpl.
    unfold make_comp, get_rank, get_info. simpl.
    rewrite Nat.eqb_refl. simpl.
    unfold max_rankl, rank_main.
    rewrite Forall_forall in H6, H7.
    rewrite <- H5.
    repeat rewrite maxl_eq_maxl with (g:=maxrank) (f:=λ x, get_rank x (main x)); auto.
    zify; omega.
Qed.

Lemma BC_to_TRS_rank_main_aux f bc st inf n s:
  let trs := snd (BC_to_TRS bc st) in
  arities bc = ok_arities n s →
  assoc Nat.eqb f trs.(infos) = Some inf →
  rank inf ≤ rank_main trs.
Proof.
intro trs. subst trs. intros. unfold rank_main.
rewrite (get_rank_eq f (snd (BC_to_TRS bc st))); auto.
rewrite BC_to_TRS_main_has_maxrank with (n:=n) (s:=s); auto. apply BC_to_TRS_maxrank_is_max_rank.
rewrite <- BC_to_TRS_infos_iff.
rewrite assoc_in_Some_simple; eauto.
Qed.

Lemma BC_to_TRS_lm_to_ml_rank_aux f inf st bcl n s:
  let trsl := snd (lm_to_ml (map BC_to_TRS bcl) st) in
  (∀ bc : BC, bc ∈ bcl → arities bc = ok_arities n s) →
  assoc Nat.eqb f (get_infos trsl) = Some inf →
  rank inf ≤ maxl (map rank_main trsl).
Proof.
intros. unfold get_infos in H.
generalize (assoc_in_concat Nat.eqb f (map infos trsl) H0).
intro. repeat destruct H1.
rewrite in_map_iff in H1. repeat destruct H1.
subst trsl.
generalize (in_lm_to_ml x0 (map BC_to_TRS bcl) st H3). intro.
repeat destruct H1. rewrite in_map_iff in H1. repeat destruct H1.
rewrite (get_rank_eq f x0); auto. apply le_trans with (m:=rank_main x0).
- subst. unfold rank_main.
  rewrite BC_to_TRS_main_has_maxrank with (n:=n) (s:=s); auto. apply BC_to_TRS_maxrank_is_max_rank.
  rewrite <- BC_to_TRS_infos_iff. rewrite in_map_iff. exists (f, inf).
  split; auto. apply assoc_in with (beq:=Nat.eqb); auto.
- subst. apply maxl_is_max. now apply in_map.
Qed.

Lemma BC_to_TRS_main_has_unique_max_rank bc n s:
  arities bc = ok_arities n s → ∀ st f,
  let trs := snd (BC_to_TRS bc st) in
  f < trs.(main) → get_rank trs f < get_rank trs trs.(main).
Proof.
intros Har st f trs. subst trs. revert st. generalize Har.
apply BC_ind_inf with (e:=bc) (n:=n) (s:=s); auto; intro; try case b; simpl;
  unfold multi_rules_prog, one_rule_prog, simple_prog; intros.
1, 2, 3, 4, 5, 6: unfold get_rank, get_info; simpl;
  rewrite Nat.eqb_refl; rewrite eqb_subst_neq; auto; omega.
- revert Har0 H5. open_rec H H0 H1. intro.
  open_monads_rec g h0 h1 st. intro.
  unfold make_rec, get_rank, get_info. simpl.
  rewrite Nat.eqb_refl. simpl.
  rewrite eqb_subst_neq; try omega. unfold Err_info.
  case_eq (assoc Nat.eqb f (infos (snd (BC_to_TRS g st)) ++
     infos (snd (BC_to_TRS h0 (fst (BC_to_TRS g st)))) ++
     infos (snd (BC_to_TRS h1 (fst (BC_to_TRS h0 (fst (BC_to_TRS g st))))))));
  intros; simpl; try omega.
  apply le_lt_trans with (m:=max_rank3 (snd (BC_to_TRS g st)) (snd (BC_to_TRS h0 (fst (BC_to_TRS g st))))
        (snd (BC_to_TRS h1 (fst (BC_to_TRS h0 (fst (BC_to_TRS g st))))))); try omega.
  unfold max_rank3. repeat rewrite Nat.max_le_iff.
  repeat rewrite assoc_app_eq_Some in H6.
  intuition; eauto using (BC_to_TRS_rank_main_aux f).
- clear Har0. revert H5. open_monads_comp h rl tl st. intro.
  unfold make_comp, get_rank, get_info, Err_info. simpl.
  rewrite Nat.eqb_refl. simpl.
  rewrite eqb_subst_neq; try omega.
  case_eq (assoc Nat.eqb f (infos (snd (BC_to_TRS h st)) ++
     get_infos (snd (lm_to_ml (map BC_to_TRS rl) (fst (BC_to_TRS h st)))) ++
     get_infos (snd (lm_to_ml (map BC_to_TRS tl)
             (fst (lm_to_ml (map BC_to_TRS rl) (fst (BC_to_TRS h st))))))));
  intros; simpl; try omega.
  apply le_lt_trans with (m:=Nat.max (rank_main (snd (BC_to_TRS h st)))
      (Nat.max (max_rankl (snd (lm_to_ml (map BC_to_TRS rl) (fst (BC_to_TRS h st)))))
      (max_rankl (snd (lm_to_ml (map BC_to_TRS tl)
              (fst (lm_to_ml (map BC_to_TRS rl) (fst (BC_to_TRS h st))))))))); try omega.
  unfold max_rankl. repeat rewrite Nat.max_le_iff.
  repeat rewrite assoc_app_eq_Some in H6.
  intuition; eauto using (BC_to_TRS_rank_main_aux f), (BC_to_TRS_lm_to_ml_rank_aux f).
Qed.

Lemma get_info_in_list trs bcl st f:
  let trsl:=snd (lm_to_ml (map BC_to_TRS bcl) st) in
  trs ∈ trsl → f ∈ all_lhs_funcs trs →
  get_info_l trsl f = get_info trs f.
Proof.
intro trsl. subst trsl. revert st. induction bcl; simpl; try tauto.
intro. unfold Mmap2.
rewrite (surjective_pairing (BC_to_TRS a st)).
rewrite (surjective_pairing (lm_to_ml (map BC_to_TRS bcl) (fst (BC_to_TRS a st)))).
simpl. intros. unfold get_info_l, get_infos. destruct H.
- rewrite <- H. simpl. rewrite assoc_app_in; auto.
  rewrite BC_to_TRS_infos_iff. now subst trs.
- simpl. rewrite assoc_app_out; auto.
  + rewrite get_info_l_eq. now apply IHbcl.
  + rewrite BC_to_TRS_infos_iff. intro.
    assert (f ∈ flat_map all_lhs_funcs (snd (lm_to_ml (map BC_to_TRS bcl) (fst (BC_to_TRS a st))))).
    * rewrite in_flat_map. exists trs. split; auto.
    * generalize (map_BC_to_TRS_func_bounds _ _ _ H2). intro.
      generalize (BC_to_TRS_func_bounds _ _ _ H1).
      rewrite BC_to_TRS_first, BC_to_TRS_last. intro.
      omega.
Qed.

Lemma get_info_main_list trs bcl st:
  let trsl := snd (lm_to_ml (map BC_to_TRS bcl) st) in
  trs ∈ trsl → get_info_l trsl trs.(main) = get_info trs trs.(main).
Proof.
intros. apply get_info_in_list; auto.
generalize (in_lm_to_ml _ _ _ H). intro. repeat destruct H0.
subst trs. rewrite in_map_iff in H0. repeat destruct H0.
apply BC_to_TRS_main_defined.
Qed.

Lemma BC_to_TRS_infos_subst_rec_first g h0 h1 st n s f:
  f ∈ all_lhs_funcs (snd (BC_to_TRS g st)) →
  get_info (snd ((BC_to_TRS g >>+ BC_to_TRS h0 >>++ BC_to_TRS h1
                     >>+ Mnew_fun >>== Mmr (S n) s) st)) f =
  get_info (snd (BC_to_TRS g st)) f.
Proof.
open_monads_rec g h0 h1 st. unfold make_rec, get_info. simpl.
generalize BC_to_TRS_Mlt as HMlt. unfold Mlt, Meval. intro.
generalize (HMlt g st) as Hg.
generalize (HMlt h0 (fst (BC_to_TRS g st))) as Hh0.
generalize (HMlt h1 (fst (BC_to_TRS h0 (fst (BC_to_TRS g st))))) as Hh1.
intros. rewrite eqb_subst_neq.
- rewrite assoc_app_in; auto.
  now rewrite BC_to_TRS_infos_iff.
- generalize (BC_to_TRS_func_bounds g st f H).
  rewrite BC_to_TRS_first, BC_to_TRS_last. intro. omega.
Qed.

Lemma BC_to_TRS_infos_subst_rec_second g h0 h1 st n s f:
  f ∈ all_lhs_funcs (snd (BC_to_TRS h0 (fst (BC_to_TRS g st)))) →
  get_info (snd ((BC_to_TRS g >>+ BC_to_TRS h0 >>++ BC_to_TRS h1
                     >>+ Mnew_fun >>== Mmr (S n) s) st)) f =
  get_info (snd (BC_to_TRS h0 (fst (BC_to_TRS g st)))) f.
Proof.
open_monads_rec g h0 h1 st. unfold make_rec, get_info. simpl.
generalize BC_to_TRS_Mle as HMle. unfold Mle, Meval. intro.
generalize (HMle g st).
generalize (HMle h0 (fst (BC_to_TRS g st))).
generalize (HMle h1 (fst (BC_to_TRS h0 (fst (BC_to_TRS g st))))).
intros.
rewrite eqb_subst_neq. rewrite assoc_app_out; auto. rewrite assoc_app_in; auto.
- now rewrite BC_to_TRS_infos_iff.
- rewrite BC_to_TRS_infos_iff. intro.
  generalize (BC_to_TRS_func_bounds _ _ _ H3).
  generalize (BC_to_TRS_func_bounds _ _ _ H2).
  repeat rewrite BC_to_TRS_first, BC_to_TRS_last. omega.
- generalize (BC_to_TRS_func_bounds _ _ _ H2).
  rewrite BC_to_TRS_first, BC_to_TRS_last. omega.
Qed.

Lemma BC_to_TRS_infos_subst_rec_third g h0 h1 st n s f:
  f ∈ all_lhs_funcs (snd (BC_to_TRS h1 (fst (BC_to_TRS h0 (fst (BC_to_TRS g st)))))) →
  get_info (snd ((BC_to_TRS g >>+ BC_to_TRS h0 >>++ BC_to_TRS h1
                     >>+ Mnew_fun >>== Mmr (S n) s) st)) f =
  get_info (snd (BC_to_TRS h1 (fst (BC_to_TRS h0 (fst (BC_to_TRS g st)))))) f.
Proof.
open_monads_rec g h0 h1 st. unfold make_rec, get_info. simpl.
generalize BC_to_TRS_Mle as HMle. unfold Mle, Meval. intro.
generalize (HMle g st).
generalize (HMle h0 (fst (BC_to_TRS g st))).
generalize (HMle h1 (fst (BC_to_TRS h0 (fst (BC_to_TRS g st))))).
intros.
rewrite eqb_subst_neq. rewrite assoc_app_out; auto. rewrite assoc_app_out; auto.
- rewrite BC_to_TRS_infos_iff. intro.
  generalize (BC_to_TRS_func_bounds _ _ _ H2).
  generalize (BC_to_TRS_func_bounds _ _ _ H3).
  repeat rewrite BC_to_TRS_first, BC_to_TRS_last. omega.
- rewrite BC_to_TRS_infos_iff. intro.
  generalize (BC_to_TRS_func_bounds _ _ _ H2).
  generalize (BC_to_TRS_func_bounds _ _ _ H3).
  repeat rewrite BC_to_TRS_first, BC_to_TRS_last. omega.
- generalize (BC_to_TRS_func_bounds _ _ _ H2).
  rewrite BC_to_TRS_first, BC_to_TRS_last. omega.
Qed.

Lemma BC_to_TRS_infos_subst_comp_first h rl tl st n s f:
  f ∈ all_lhs_funcs (snd (BC_to_TRS h st)) →
  get_info (snd ((BC_to_TRS h >>+ lm_to_ml (map BC_to_TRS rl) >>++
             lm_to_ml (map BC_to_TRS tl) >>+ Mnew_fun >>== Mmc n s) st)) f =
  get_info (snd (BC_to_TRS h st)) f.
Proof.
open_monads_comp h rl tl st. unfold make_comp, get_info. simpl.
generalize BC_to_TRS_Mle as HMle. generalize map_BC_to_TRS_Mle as HMle'.
unfold Mle, Meval. intros.
generalize (HMle h st).
generalize (HMle' rl (fst (BC_to_TRS h st))).
generalize (HMle' tl (fst (lm_to_ml (map BC_to_TRS rl) (fst (BC_to_TRS h st))))).
intros. rewrite eqb_subst_neq.
- rewrite assoc_app_in; auto. now rewrite BC_to_TRS_infos_iff.
- rewrite neq_lt_gt_iff. left.
  generalize (BC_to_TRS_func_bounds h st f H).
  rewrite BC_to_TRS_first, BC_to_TRS_last. omega.
Qed.

Lemma BC_to_TRS_infos_subst_comp_second h rl tl st n s f:
  f ∈ flat_map all_lhs_funcs (snd (lm_to_ml (map BC_to_TRS rl) (fst (BC_to_TRS h st)))) →
  get_info (snd ((BC_to_TRS h >>+ lm_to_ml (map BC_to_TRS rl) >>++
             lm_to_ml (map BC_to_TRS tl) >>+ Mnew_fun >>== Mmc n s) st)) f =
  get_info_l (snd (lm_to_ml (map BC_to_TRS rl) (fst (BC_to_TRS h st)))) f.
Proof.
open_monads_comp h rl tl st.
unfold make_comp, get_info, get_info_l. simpl.
generalize BC_to_TRS_Mle as HMle. generalize map_BC_to_TRS_Mle as HMle'.
unfold Mle, Meval. intros.
generalize (HMle h st).
generalize (HMle' rl (fst (BC_to_TRS h st))).
generalize (HMle' tl (fst (lm_to_ml (map BC_to_TRS rl) (fst (BC_to_TRS h st))))).
generalize (map_BC_to_TRS_func_bounds _ _ _ H).
intros. rewrite eqb_subst_neq. rewrite assoc_app_out; auto.
- rewrite assoc_app_in; auto.
  now rewrite <- map_BC_to_TRS_infos_iff.
- intro. rewrite BC_to_TRS_infos_iff in H4.
  generalize (BC_to_TRS_func_bounds h st f H4).
  rewrite BC_to_TRS_first, BC_to_TRS_last.
  intros. omega.
- apply neq_lt_gt_iff. left. omega.
Qed.

Lemma BC_to_TRS_infos_subst_comp_third h rl tl st n s f:
  let st' := fst (lm_to_ml (map BC_to_TRS rl) (fst (BC_to_TRS h st))) in
  f ∈ flat_map all_lhs_funcs (snd (lm_to_ml (map BC_to_TRS tl) st')) →
  get_info (snd ((BC_to_TRS h >>+ lm_to_ml (map BC_to_TRS rl) >>++
             lm_to_ml (map BC_to_TRS tl) >>+ Mnew_fun >>== Mmc n s) st)) f =
  get_info_l (snd (lm_to_ml (map BC_to_TRS tl) st')) f.
Proof.
open_monads_comp h rl tl st.
unfold make_comp, get_info, get_info_l. simpl.
generalize BC_to_TRS_Mle as HMle. generalize map_BC_to_TRS_Mle as HMle'.
unfold Mle, Meval. intros.
generalize (HMle h st).
generalize (HMle' rl (fst (BC_to_TRS h st))).
generalize (HMle' tl (fst (lm_to_ml (map BC_to_TRS rl) (fst (BC_to_TRS h st))))).
generalize (map_BC_to_TRS_func_bounds _ _ _ H).
intros. rewrite eqb_subst_neq. rewrite assoc_app_out; auto. rewrite assoc_app_out; auto.
- intro. rewrite <- map_BC_to_TRS_infos_iff in H4.
  generalize (map_BC_to_TRS_func_bounds _ _ _ H4).
  intros. omega.
- intro. rewrite BC_to_TRS_infos_iff in H4.
  generalize (BC_to_TRS_func_bounds _ _ _ H4).
  rewrite BC_to_TRS_first, BC_to_TRS_last.
  intros. omega.
- apply neq_lt_gt_iff. left. omega.
Qed.

Ltac ppo := Ordering.ppo Nat.eq_dec Nat.eq_dec constructor_eq_dec.

Lemma same_rank_same_ppo_iff s t rk rk':   
  (∀ f, f ∈ functions_of_term t → rk f = rk' f) →
  (∀ f, f ∈ functions_of_term s → rk f = rk' f) →
  PPO rk t s ↔ PPO rk' t s.
Proof.
split; apply same_rank_same_ppo; auto; intros; symmetry; auto.
Qed.

Lemma same_rank_same_ppo_rule_iff r rk rk': 
  (rk (lhs_func r) = rk' (lhs_func r)) → 
  (∀ f : function, f ∈ (rhs_funcs r) → rk f = rk' f) →
  PPO_rule rk r ↔ PPO_rule rk' r.
Proof.
destruct r. simpl. intros.
rewrite same_rank_same_ppo_iff with (rk:=rk); auto; try tauto.
simpl. intros. repeat destruct H1; auto.
rewrite no_funcs_in_patterns in H1.
now simpl in H1.
Qed.

Lemma BC_to_TRS_same_rank_same_ppo_rule_iff bc st r rk rk':
  let trs := snd (BC_to_TRS bc st) in
  (∀ ru, ru ∈ trs.(rules) → rk (lhs_func ru) = rk' (lhs_func ru)) →
  r ∈ trs.(rules) → PPO_rule rk r ↔ PPO_rule rk' r.
Proof.
intro trs. subst trs. intros Hrk Hin.
rewrite same_rank_same_ppo_rule_iff; auto; try tauto.
intros. assert (f ∈ all_rhs_funcs (rules (snd (BC_to_TRS bc st)))).
- unfold all_rhs_funcs. rewrite in_flat_map. eauto.
- generalize (BC_to_TRS_rhs_funcs_defined bc st f H0).
  unfold all_lhs_funcs. intro. rewrite in_map_iff in H1.
  repeat destruct H1. auto.
Qed.

Lemma map_BC_to_TRS_same_rank_same_ppo_rule bcl st r rk rk':
  let trsl := snd ((lm_to_ml (map BC_to_TRS bcl)) st) in
  (∀ ru, ru ∈ get_rules trsl → rk (lhs_func ru) = rk' (lhs_func ru)) →
  r ∈ get_rules trsl → PPO_rule rk r → PPO_rule rk' r.
Proof.
intro. subst trsl. intros.
case_eq r. simpl. intros.
apply same_rank_same_ppo with (rk:=rk).
- intros. assert (f0 ∈ rhs_funcs r); [subst r | idtac]; auto.
  unfold get_rules in H0. rewrite in_concat_iff in H0. repeat destruct H0.
  rewrite in_map_iff in H0. repeat destruct H0.
  assert (f0 ∈ all_rhs_funcs x0.(rules)).
  + unfold all_rhs_funcs. rewrite in_flat_map. exists r; auto.
  + generalize (in_lm_to_ml x0 (map BC_to_TRS bcl) st H6). intro.
    repeat destruct H7. subst x0. rewrite in_map_iff in H7. repeat destruct H7.
    generalize (BC_to_TRS_rhs_funcs_defined x0 x1 f0 H0). intro.
    unfold all_lhs_funcs in H7. rewrite in_map_iff in H7. repeat destruct H7.
    apply H. unfold get_rules. rewrite in_concat_iff.
    exists (rules (snd (BC_to_TRS x0 x1))). split; auto.
    now apply in_map.
- simpl. intros. repeat destruct H3.
  + generalize (H r H0). now subst r.
  + now rewrite no_funcs_in_patterns in H3.
- now subst r.
Qed.

Lemma ppo_rec_calls f g rk (Suc:constructor) n s:
  rk g < rk f →
  PPO rk
  (fapply g (mk_args_h (S n) s (mk_call (S (n + s)) f)))
  (fapply f (capply Suc [var 0] :: map term_from_pattern (mk_pvl 1 (S (n + s))))).
Proof.
intro.
apply ppo_funlt_split; auto.
intro. unfold mk_call, mk_args_h. rewrite in_app_iff. simpl.
rewrite tfp_pvl_is_tvl. intuition.
- apply ppo_fun_sub with (t:=capply Suc [var 0]); try left; auto.
  apply ppo_constr_in. now left.
- apply ppo_fun_in. right. revert s0 H0.
  replace (map mk_tv (seq 1 n)) with (mk_tvl 1 (n+1)).
  + apply tvl_incl. omega.
  + unfold mk_tvl, ints. replace (n+1-1) with (n); auto. omega.
- subst s0. apply ppo_funeqv_split; auto.
  unfold mk_tvl, ints. simpl. unfold mk_tv at 1. apply product_consst.
  + apply ppo_constr_in. now left.
  + rewrite Nat.sub_0_r. apply Forall2_eq_clos_refl.
- apply ppo_fun_in. right. revert s0 H0. apply tvl_incl. omega.
Qed.

Lemma ppo_comp_calls trsl f rk n m t:
  n ≤ m → (∀ g : function, g ∈ map main trsl → rk g < rk f) →
  t ∈ map (mk_call_trs n) trsl → PPO rk t (fapply f (mk_tvl 0 m)).
Proof.
unfold mk_call_trs, mk_call. intros.
rewrite in_map_iff in H1. repeat destruct H1.
apply ppo_funlt_split.
- apply H0. now apply in_map.
- intros. apply ppo_fun_in. revert s H1. now apply tvl_incl.
Qed.

Lemma map_BC_to_TRS_ppo_rule bcl st: 
  let rk := λ f : nat, rank (get_info_l (snd (lm_to_ml (map BC_to_TRS bcl) st)) f) in
  (∀ (bc : BC) (st0 : state), bc ∈ bcl →
     Forall (PPO_rule (get_rank (snd (BC_to_TRS bc st0)))) (rules (snd (BC_to_TRS bc st0)))) →
     Forall (PPO_rule rk) (get_rules (snd (lm_to_ml (map BC_to_TRS bcl) st))).
Proof.
revert st.
induction bcl; simpl; intros; try apply Forall_nil.
unfold Mmap2.
rewrite (surjective_pairing (BC_to_TRS a st)).
rewrite (surjective_pairing (lm_to_ml (map BC_to_TRS bcl) (fst (BC_to_TRS a st)))).
simpl. rewrite Forall_forall. unfold get_rules. simpl.
intros. rewrite in_app_iff in H0. destruct H0.
- rewrite same_rank_same_ppo_rule_iff with (rk' := get_rank (snd (BC_to_TRS a st))).
  + revert x H0. rewrite <- Forall_forall. apply H. now left.
  + unfold get_info_l, get_infos. simpl.
    rewrite assoc_app_in; auto.
    rewrite BC_to_TRS_infos_iff. unfold all_lhs_funcs. now apply in_map.
  + intros. unfold get_info_l, get_infos. simpl.
    rewrite assoc_app_in; auto.
    rewrite BC_to_TRS_infos_iff. apply BC_to_TRS_rhs_funcs_defined.
    unfold all_rhs_funcs. rewrite in_flat_map. eauto.
- rewrite same_rank_same_ppo_rule_iff with
          (rk' := (λ f, rank (get_info_l (snd (lm_to_ml (map BC_to_TRS bcl) (fst (BC_to_TRS a st)))) f))).
  + revert x H0. rewrite get_rules_eq. rewrite <- Forall_forall. simpl in *.
    apply IHbcl. intros. apply H. now right.
  + unfold get_info_l, get_infos. simpl.
    rewrite assoc_app_out; auto.
    intro. rewrite BC_to_TRS_infos_iff in H1.
    generalize (BC_to_TRS_func_bounds a st (lhs_func x) H1).
    rewrite BC_to_TRS_first, BC_to_TRS_last. intro.
    rewrite get_rules_eq in H0.
    assert ((lhs_func x) ∈ flat_map all_lhs_funcs
            (snd (lm_to_ml (map BC_to_TRS bcl) (fst (BC_to_TRS a st))))).
    * rewrite in_flat_map. unfold get_rules in H0.
      rewrite in_concat_iff in H0. repeat destruct H0.
      rewrite in_map_iff in H0. repeat destruct H0.
      exists x1. split; auto. unfold all_lhs_funcs. now apply in_map.
    * generalize (map_BC_to_TRS_func_bounds bcl (fst (BC_to_TRS a st)) (lhs_func x) H3).
      intro. omega.
  + intros. unfold get_info_l, get_infos. simpl.
    rewrite assoc_app_out; auto.
    intro. rewrite BC_to_TRS_infos_iff in H2.
    generalize (BC_to_TRS_func_bounds a st f H2).
    rewrite BC_to_TRS_first, BC_to_TRS_last. intro.
    rewrite get_rules_eq in H0.
    assert (f ∈ flat_map all_lhs_funcs
           (snd (lm_to_ml (map BC_to_TRS bcl) (fst (BC_to_TRS a st))))).
    * rewrite in_flat_map. unfold get_rules in H0.
      rewrite in_concat_iff in H0. repeat destruct H0.
      rewrite in_map_iff in H0. repeat destruct H0.
      exists x1. split; auto.
      generalize (in_lm_to_ml x1 (map BC_to_TRS bcl) (fst (BC_to_TRS a st)) H5).
      intro. repeat destruct H0. subst x1.
      rewrite in_map_iff in H0. repeat destruct H0.
      apply BC_to_TRS_rhs_funcs_defined.
      unfold all_rhs_funcs. rewrite in_flat_map. eauto.
    * generalize (map_BC_to_TRS_func_bounds bcl (fst (BC_to_TRS a st)) f H4).
      intro. omega.
Qed.

Theorem BC_to_TRS_PPO bc st n s:
  let trs := snd (BC_to_TRS bc st) in
  arities bc = ok_arities n s →
  PPO_prog trs.(rules) (get_rank trs).
Proof.
intro trs. subst trs. intro Har.
generalize (BC_to_TRS_main_has_unique_max_rank bc n s Har st) as Hmain.
revert st. generalize Har.
apply BC_ind_inf with (e:=bc) (n:=n) (s:=s); auto; intros; try case b; simpl;
  unfold multi_rules_prog, one_rule_prog, simple_prog, sr_uncurry, simple_rule;
  unfold PPO_prog in *; simpl in *; intros.
  1, 3, 4, 5, 6: repeat destruct H; simpl; ppo.
- repeat destruct H0. simpl.
  rewrite tfp_pvl_is_tvl. 
  apply ppo_fun_in. unfold mk_tvl, mk_tv.
  apply in_map. apply ints_bounds. omega.
- clear Har0 Har. revert Hmain H5. open_rec H H0 H1.
  set (rk:=get_rank (snd ((BC_to_TRS g >>+ BC_to_TRS h0 >>++ BC_to_TRS h1
                           >>+ Mnew_fun >>== Mmr (S n0) s0) st))).
  open_monads_rec g h0 h1 st.
  generalize BC_to_TRS_Mle as HMle. unfold Mle, Meval. intro.
  generalize (HMle g st).
  generalize (HMle h0 (fst (BC_to_TRS g st))).
  generalize (HMle h1 (fst (BC_to_TRS h0 (fst (BC_to_TRS g st))))).
  unfold make_rec, sr_uncurry, simple_rule. simpl. intros Hh1 Hh0 Hg Hmain.
  repeat rewrite in_app_iff.
  repeat rewrite BC_to_TRS_main_is_last, BC_to_TRS_last.
  intuition; try subst r; simpl.
  + apply ppo_funlt_split.
    * apply Hmain. omega.
    * intros. apply ppo_fun_in. right. now rewrite tfp_pvl_is_tvl.
  + apply ppo_rec_calls. apply Hmain. omega.
  + apply ppo_rec_calls. apply Hmain. omega.
  + rewrite (BC_to_TRS_same_rank_same_ppo_rule_iff g st) with (rk':=get_rank (snd (BC_to_TRS g st))); auto.
    * apply H6; eauto using BC_to_TRS_main_has_unique_max_rank.
    * intros. subst rk. unfold get_rank. rewrite BC_to_TRS_infos_subst_rec_first; auto.
      unfold all_lhs_funcs. now apply in_map.
  + rewrite (BC_to_TRS_same_rank_same_ppo_rule_iff h0 (fst (BC_to_TRS g st))) with 
          (rk':=get_rank (snd (BC_to_TRS h0 (fst (BC_to_TRS g st))))); auto.
    * apply H2; auto. apply BC_to_TRS_main_has_unique_max_rank with (n:=S n0) (s:=S s0); auto.
    * intros. subst rk. unfold get_rank. rewrite BC_to_TRS_infos_subst_rec_second; auto.
      unfold all_lhs_funcs. now apply in_map.
  + rewrite (BC_to_TRS_same_rank_same_ppo_rule_iff h1 (fst (BC_to_TRS h0 (fst (BC_to_TRS g st))))) with 
          (rk':=get_rank (snd (BC_to_TRS h1 (fst (BC_to_TRS h0 (fst (BC_to_TRS g st))))))); auto.
    * apply H3; auto. apply BC_to_TRS_main_has_unique_max_rank with (n:=S n0) (s:=S s0); auto.
    * intros. subst rk. unfold get_rank. rewrite BC_to_TRS_infos_subst_rec_third; auto.
      unfold all_lhs_funcs. now apply in_map.
- clear Har0 Har. revert Hmain H5.
  set (rk:=get_rank (snd ((BC_to_TRS h >>+ lm_to_ml (map BC_to_TRS rl) >>++
          lm_to_ml (map BC_to_TRS tl) >>+ Mnew_fun >>== Mmc n0 s0) st))).
  open_monads_comp h rl tl st. unfold simple_rule. intro.
  repeat rewrite in_app_iff. rewrite BC_to_TRS_main_is_last, BC_to_TRS_last.
  intuition; try subst r; simpl.
  + clear H H0 H1 H3 H4 H5.
    generalize BC_to_TRS_Mle as HMle. generalize map_BC_to_TRS_Mle as HMle'.
    unfold Mle, Meval. intros.
    generalize (HMle h st).
    generalize (HMle' rl (fst (BC_to_TRS h st))).
    generalize (HMle' tl (fst (lm_to_ml (map BC_to_TRS rl) (fst (BC_to_TRS h st))))).
    intros. apply ppo_funlt_split.
    * apply Hmain. omega.
    * intro. rewrite tfp_pvl_is_tvl. rewrite in_app_iff. intro.
      { destruct H2.
        - apply ppo_comp_calls with (n:=n0)
                (trsl:=snd (lm_to_ml (map BC_to_TRS rl) (fst (BC_to_TRS h st))));
                auto; try omega.
          intros. apply Hmain. 
          assert (g ∈ flat_map all_lhs_funcs
                  (snd (lm_to_ml (map BC_to_TRS rl) (fst (BC_to_TRS h st))))).
          + rewrite in_map_iff in H3. repeat destruct H3.
            rewrite in_flat_map. exists x. split; auto.
            generalize (in_lm_to_ml x (map BC_to_TRS rl) (fst (BC_to_TRS h st))).
            intros. repeat destruct H3; auto. subst x.
            rewrite in_map_iff in H3. repeat destruct H3.
            apply BC_to_TRS_main_defined.
          + generalize (map_BC_to_TRS_func_bounds rl (fst (BC_to_TRS h st)) g H4).
            intro. omega.
        - apply ppo_comp_calls with (n:=n0+s0)
                (trsl:=snd  (lm_to_ml (map BC_to_TRS tl)
                (fst (lm_to_ml (map BC_to_TRS rl) (fst (BC_to_TRS h st)))))); auto.
          intros. apply Hmain.
          assert (g ∈ flat_map all_lhs_funcs
                  (snd (lm_to_ml (map BC_to_TRS tl)
                       (fst (lm_to_ml (map BC_to_TRS rl) (fst (BC_to_TRS h st))))))).
          + rewrite in_map_iff in H3. repeat destruct H3.
            rewrite in_flat_map. exists x. split; auto.
            generalize (in_lm_to_ml x (map BC_to_TRS tl)
                        (fst (lm_to_ml (map BC_to_TRS rl) (fst (BC_to_TRS h st))))).
            intros. repeat destruct H3; auto. subst x.
            rewrite in_map_iff in H3. repeat destruct H3.
            apply BC_to_TRS_main_defined.
          + generalize (map_BC_to_TRS_func_bounds tl (fst (lm_to_ml (map BC_to_TRS rl) (fst (BC_to_TRS h st)))) g H4).
            intro. omega.
     }
  + rewrite (BC_to_TRS_same_rank_same_ppo_rule_iff h st) with 
            (rk':=get_rank (snd (BC_to_TRS h st))); auto.
    * apply H6; auto. exact (BC_to_TRS_main_has_unique_max_rank h (length rl) (length tl) H st).
    * intros. subst rk. unfold get_rank. rewrite BC_to_TRS_infos_subst_comp_first; auto.
      unfold all_lhs_funcs. now apply in_map.
  + apply (map_BC_to_TRS_same_rank_same_ppo_rule rl (fst (BC_to_TRS h st))) with
          (rk:=λ f,rank (get_info_l (snd (lm_to_ml (map BC_to_TRS rl) (fst (BC_to_TRS h st)))) f)); auto.
    * intros. subst rk. unfold get_rank. rewrite BC_to_TRS_infos_subst_comp_second; auto.
      now apply map_BC_to_TRS_lhs_in.
    * revert r H6. rewrite <- Forall_forall. apply map_BC_to_TRS_ppo_rule.
      intros. rewrite Forall_forall. intros. apply H3; auto.
      apply BC_to_TRS_main_has_unique_max_rank with (n:=n0) (s:=0).
      now apply H0.
  + apply (map_BC_to_TRS_same_rank_same_ppo_rule tl (fst (lm_to_ml (map BC_to_TRS rl) (fst (BC_to_TRS h st))))) with
          (rk:=λ f,rank (get_info_l (snd (lm_to_ml (map BC_to_TRS tl)
               (fst (lm_to_ml (map BC_to_TRS rl) (fst (BC_to_TRS h st)))))) f)); auto.
    * intros. subst rk. unfold get_rank. rewrite BC_to_TRS_infos_subst_comp_third; auto.
      now apply map_BC_to_TRS_lhs_in.
    * revert r H6. rewrite <- Forall_forall. apply map_BC_to_TRS_ppo_rule.
      intros. rewrite Forall_forall. intros. apply H4; auto.
      apply BC_to_TRS_main_has_unique_max_rank with (n:=n0) (s:=s0).
      now apply H1.
Qed.

Definition  valid_QI_prog trs := valid_QI variable function constructor
  trs.(rules) mcs qic (qif trs) cs.
Definition subterm_QI_prog trs := subterm function (qif trs).
Definition monotonicity_QI_prog trs := monotonicity_qif function (qif trs).
Definition compatible_QI_prog trs := compatible_QI variable function constructor 
  trs.(rules) qic (qif trs).

Definition noqif:=λ (f:function) (l:list nat), 0.

Lemma term_assignment_of_value qif2 v qic qif1:
  term_assignment variable function constructor qic qif1 (term_from_value v) =
  term_assignment variable function constructor qic qif2 (term_from_value v).
Proof.
induction v using value_ind2. simpl.
apply f_equal2; auto.
apply map_ext_in. intros.
rewrite in_map_iff in H0. repeat destruct H0.
auto.
Qed.

Lemma ta_of_p_subst qif2 p qic s qif1:
  term_assignment variable function constructor qic qif1 (subst s (term_from_pattern p)) =
  term_assignment variable function constructor qic qif2 (subst s (term_from_pattern p)).
Proof.
induction p using pattern_ind2; simpl; auto using term_assignment_of_value.
apply f_equal2; auto.
apply map_ext_in. intros.
rewrite in_map_iff in H0. repeat destruct H0.
rewrite in_map_iff in H1. destruct H1. destruct H0.
subst x. auto.
Qed.

Lemma ta_of_pl qif2 lp qic s qif1:
  (map (term_assignment variable function constructor qic qif1))
       (map (subst s) (map term_from_pattern lp)) =
  (map (term_assignment variable function constructor qic qif2))
       (map (subst s) (map term_from_pattern lp)).
Proof.
intros. apply map_ext_in. intros.
rewrite in_map_iff in H. repeat destruct H.
rewrite in_map_iff in H0. destruct H0. destruct H. subst x.
apply ta_of_p_subst.
Qed.

Lemma ta_of_tvl qif2 n m qic s qif1:
  (map (term_assignment variable function constructor qic qif1))
       (map (subst s) (mk_tvl n m)) =
  (map (term_assignment variable function constructor qic qif2))
       (map (subst s) (mk_tvl n m)).
Proof.
intros. rewrite <- tfp_pvl_is_tvl. apply ta_of_pl.
Qed.

Lemma qif_swap t qic s:
  ∀ qif1 qif2,
  (∀ f, f ∈ (functions_of_term t) → qif1 f = qif2 f) →
  term_assignment variable function constructor qic qif1 (subst s t) =
  term_assignment variable function constructor qic qif2 (subst s t).
Proof.
induction t using term_ind2; simpl; intros.
- apply term_assignment_of_value.
- apply f_equal2; auto. apply map_ext_in. intros.
  rewrite in_map_iff in H1. repeat destruct H1.
  apply H; auto. intros.
  apply H0. rewrite in_flat_map. eauto.
- rewrite H0; auto.
  apply f_equal2; auto. apply map_ext_in. intros.
  rewrite in_map_iff in H1. repeat destruct H1.
  apply H; auto. intros.
  apply H0. right. rewrite in_flat_map. eauto.
Qed.

Lemma BC_to_TRS_arity_norm bc st n s:
  let trs := snd (BC_to_TRS bc st) in
  arities bc = ok_arities n s →
  (get_info trs trs.(main)).(norm) = n.
Proof.
intro trs. subst trs. intro Har. revert st. generalize Har.
apply BC_ind_inf with (e:=bc) (n:=n) (s:=s); auto; intros; try case b; simpl;
  unfold one_rule_prog, multi_rules_prog, simple_prog;
  unfold qif, get_info; simpl; intros; try rewrite Nat.eqb_refl;
  unfold base_info; simpl; auto.
- open_rec H H0 H1. open_monads_rec g h0 h1 st.
  rewrite Nat.eqb_refl. now simpl.
- open_monads_comp h rl tl st.
  rewrite Nat.eqb_refl. now simpl.
Qed.

Lemma map_BC_to_TRS_arity_norm bcl st trs n s:
  let trsl := snd (lm_to_ml (map BC_to_TRS bcl) st) in
  (∀ bc, bc ∈ bcl → arities bc = ok_arities n s) →
  trs ∈ trsl →
  norm (get_info_l trsl trs.(main)) = n.
Proof.
intro trsl. subst trsl. intros.
rewrite get_info_main_list; auto.
revert trs H0.
rewrite <- Forall_forall. apply lm_to_ml_ind.
intros. rewrite in_map_iff in H0. repeat destruct H0.
rewrite BC_to_TRS_arity_norm with (n:=n) (s:=s); auto.
Qed.

Lemma BC_to_TRS_main_asg_non_zero bc st n s l:
  let trs := snd (BC_to_TRS bc st) in
  arities bc = ok_arities n s → hd 0 l ≠ 0 →
  0 < asg_main trs l.
Proof.
intro trs. subst trs. intros Har. revert l st. generalize Har.
apply BC_ind_inf with (e:=bc) (n:=n) (s:=s); auto; intros; try case b; simpl;
  unfold one_rule_prog, multi_rules_prog, simple_prog, asg_main, qif, get_info; simpl; intros.
1, 2, 3, 4, 5, 6: rewrite Nat.eqb_refl; unfold base_info; simpl; omega.
- clear Har0. open_rec H H0 H1. open_monads_rec g h0 h1 st.
  rewrite Nat.eqb_refl. simpl. destruct l; simpl in *; try tauto.
  destruct n1; try tauto. simpl.
  apply lt_le_trans with (m:=asg_main (snd (BC_to_TRS h0 (fst (BC_to_TRS g st)))) (S n1 :: l)); auto.
  repeat rewrite <- Nat.add_assoc. apply Nat.le_add_r.
- clear Har0. open_monads_comp h rl tl st. rewrite Nat.eqb_refl. simpl.
  apply lt_le_trans with (m:=maxl l); try omega.
  destruct l; simpl in *; try tauto.
  destruct n1; try tauto. rewrite Nat.max_lt_iff.
  left. omega.
Qed.

Lemma BC_to_TRS_subterm bc st n s:
  let trs := snd (BC_to_TRS bc st) in
  arities bc = ok_arities n s →
  subterm_QI_prog trs.
Proof.
intro trs. subst trs. unfold subterm_QI_prog, subterm.
intro Har. revert st. generalize Har.
apply BC_ind_inf with (e:=bc) (n:=n) (s:=s); auto; intros; try case b; simpl.
1, 2, 3, 4, 5, 6: unfold one_rule_prog, multi_rules_prog, simple_prog, qif, get_info; simpl; intros.
1, 2, 3, 4, 5, 6: case (f=?S st); unfold base_info, Err_info; simpl;
  auto using maxl_is_max.
- rewrite <- (firstn_skipn n0) in H0. rewrite in_app_iff in H0. destruct H0.
  + apply le_trans with (m:=suml (firstn n0 l)); try omega.
    now apply in_le_suml.
  + apply le_trans with (m:=maxl (skipn n0 l)); try omega.
    now apply maxl_is_max.
- open_rec H H0 H1. open_monads_rec g h0 h1 st.
  unfold make_rec, qif, get_info. simpl infos. simpl assoc.
  case (f =? S (fst (BC_to_TRS h1 (fst (BC_to_TRS h0 (fst (BC_to_TRS g st))))))).
  + unfold asg, norm.
    rewrite <- (firstn_skipn (S n0)) in H5. rewrite in_app_iff in H5. destruct H5.
    * destruct l; simpl in H5; try tauto. simpl.
      { destruct H5.
        - subst n1. destruct x; try omega. rewrite Nat.mul_add_distr_l.
          apply le_trans with (m:=S x * asg_main (snd (BC_to_TRS h0 (fst (BC_to_TRS g st)))) (S x :: firstn n0 l)).
          + rewrite <- Nat.mul_1_r at 1. apply Nat.mul_le_mono_pos_l; try omega.
            apply BC_to_TRS_main_asg_non_zero with (n:=S n0) (s:=S s0); auto.
            now simpl.
          + repeat rewrite <- Nat.add_assoc. apply Nat.le_add_r.
        - apply le_trans with (m:=asg_main (snd (BC_to_TRS g st)) (firstn n0 l)).
          + unfold qif in H2. unfold asg_main.
            generalize (H2 H st (main (snd (BC_to_TRS g st))) (firstn n0 l) x H5).
            rewrite BC_to_TRS_arity_norm with (n:=n0) (s:=s0); auto.
            rewrite firstn_firstn. rewrite Nat.min_id.
            rewrite skipn_firstn. simpl. intro. omega.
          + set (toto:=n1 *
                (asg_main (snd (BC_to_TRS h0 (fst (BC_to_TRS g st)))) (n1 :: firstn n0 l) +
                 asg_main (snd (BC_to_TRS h1 (fst (BC_to_TRS h0 (fst (BC_to_TRS g st))))))
                 (n1 :: firstn n0 l))). omega.
      }
    * apply le_trans with (m:=maxl (skipn (S n0) l)); auto using maxl_is_max.
      rewrite Nat.add_comm. apply Nat.le_add_r.
  + case_eq (assoc Nat.eqb f (infos (snd (BC_to_TRS g st)))); intros.
    2: case_eq (assoc Nat.eqb f (infos (snd (BC_to_TRS h0 (fst (BC_to_TRS g st)))))); intros.
    3: case_eq (assoc Nat.eqb f (infos (snd (BC_to_TRS h1 (fst (BC_to_TRS h0 (fst (BC_to_TRS g st)))))))); intros.
    * unfold qif, get_info in H2. rewrite assoc_app_in; auto.
      rewrite assoc_in_Some_simple; eauto.
    * unfold qif, get_info in H3. rewrite assoc_None_not_in in H6; auto.
      rewrite assoc_app_out; auto. rewrite assoc_app_in; auto.
      rewrite assoc_in_Some_simple; eauto.
    * unfold qif, get_info in H4. rewrite assoc_None_not_in in H6, H7; auto.
      repeat (rewrite assoc_app_out; auto).
    * rewrite assoc_None_not_in in H6, H7; auto.
      do 2 (rewrite assoc_app_out; auto). rewrite H8.
      unfold Err_info, Err_assig. simpl. now apply maxl_is_max.
- open_monads_comp h rl tl st. unfold make_comp, qif, get_info. simpl infos. simpl assoc.
  case (f =? S (fst (lm_to_ml (map BC_to_TRS tl) (fst (lm_to_ml (map BC_to_TRS rl) (fst (BC_to_TRS h st))))))).
  + simpl. rewrite <- (firstn_skipn n0) in H5. rewrite in_app_iff in H5. destruct H5.
    * apply le_trans with (m:=maxl (firstn n0 l)); auto using maxl_is_max. omega.
    * apply le_trans with (m:=maxl (skipn n0 l)); auto using maxl_is_max. omega.
  + case_eq (assoc Nat.eqb f (infos (snd (BC_to_TRS h st)))); intros.
    2: case_eq (assoc Nat.eqb f (get_infos (snd (lm_to_ml (map BC_to_TRS rl) (fst (BC_to_TRS h st)))))); intros.
    3: case_eq (assoc Nat.eqb f (get_infos (snd (lm_to_ml (map BC_to_TRS tl)
                 (fst (lm_to_ml (map BC_to_TRS rl) (fst (BC_to_TRS h st)))))))); intros.
    * unfold qif, get_info in H2. rewrite assoc_app_in; auto.
      rewrite assoc_in_Some_simple; eauto.
    * rewrite assoc_None_not_in in H6; auto. rewrite assoc_app_out; auto.
      rewrite assoc_app_in; auto.
      2: rewrite assoc_in_Some_simple; eauto.
      rewrite H7. unfold get_infos in H7.
      generalize (assoc_in_concat _ _ _ H7). intro. repeat destruct H8.
      rewrite in_map_iff in H8. repeat destruct H8.
      generalize (in_lm_to_ml _ _ _ H10). intro. repeat destruct H8. subst x1.
      rewrite in_map_iff in H8. repeat destruct H8.
      generalize (H3 x1 H11 (H0 x1 H11) x2 f l x H5).
      unfold qif, get_info. now rewrite H9.
    * rewrite assoc_None_not_in in H6, H7; auto.
      do 2 (rewrite assoc_app_out; auto).
      rewrite H8. unfold get_infos in H8.
      generalize (assoc_in_concat _ _ _ H8). intro. repeat destruct H9.
      rewrite in_map_iff in H9. repeat destruct H9.
      generalize (in_lm_to_ml _ _ _ H11). intro. repeat destruct H9. subst x1.
      rewrite in_map_iff in H9. repeat destruct H9.
      generalize (H4 x1 H12 (H1 x1 H12) x2 f l x H5).
      unfold qif, get_info. now rewrite H10.
    * rewrite assoc_None_not_in in H6, H7; auto.
      do 2 (rewrite assoc_app_out; auto). rewrite H8.
      apply le_trans with (m:=maxl l); auto using maxl_is_max.
Qed.

Lemma BC_to_TRS_qf_monotonicity_main bc st n s lx ly:
  let trs := snd (BC_to_TRS bc st) in
  arities bc = ok_arities n s →
  Forall2 le lx ly →
  asg_main trs lx ≤ asg_main trs ly.
Proof.
intro trs. subst trs. intro Har. revert st lx ly. generalize Har.
apply BC_ind_inf with (e:=bc) (n:=n) (s:=s); auto; intros; try case b; simpl;
  unfold one_rule_prog, multi_rules_prog, simple_prog;
  unfold asg_main, get_info; simpl; intros.
1, 2, 3, 4, 5, 6: rewrite Nat.eqb_refl; unfold base_info; simpl; auto.
1, 2, 3, 4, 5, 6: rewrite <- Nat.succ_le_mono; auto using forall2_le_suml.
- open_rec H H0 H1. open_monads_rec g h0 h1 st.
  rewrite Nat.eqb_refl. simpl.
  apply Nat.add_le_mono. apply Nat.mul_le_mono.
  + inversion H5; auto.
  + apply Nat.add_le_mono; auto.
  + apply H2; auto. inversion H5; simpl; auto.
- open_monads_comp h rl tl st.
  rewrite Nat.eqb_refl. simpl.
  apply Nat.add_le_mono; auto using forall2_le_maxl.
  apply Nat.add_le_mono.
  + apply H2; auto.
    apply Forall2_map. rewrite <- Forall_forall.
    apply lm_to_ml_ind. intros.
    rewrite in_map_iff in H6. repeat destruct H6.
    apply H3; auto.
  + apply suml_map_le. rewrite <- Forall_forall.
    apply lm_to_ml_ind. intros.
    rewrite in_map_iff in H6. repeat destruct H6.
    apply H4; auto.
Qed.

Lemma BC_to_TRS_monotonicity_comp_aux f inf bcl st lx ly:
  (∀ bc s, bc ∈ bcl →
    qif (snd (BC_to_TRS bc s)) f lx ≤ qif (snd (BC_to_TRS bc s)) f ly) →
  assoc Nat.eqb f (get_infos (snd (lm_to_ml (map BC_to_TRS bcl) st))) = Some inf →
    asg inf (firstn (norm inf) lx) + maxl (skipn (norm inf) lx) ≤
    asg inf (firstn (norm inf) ly) + maxl (skipn (norm inf) ly).
Proof.
intros Hrec Hassoc.
unfold get_infos in Hassoc.
generalize (assoc_in_concat _ _ _ Hassoc).
intro. repeat destruct H.
rewrite in_map_iff in H. repeat destruct H.
generalize (in_lm_to_ml _ _ _ H1).
intro. repeat destruct H. subst x0.
rewrite in_map_iff in H. repeat destruct H.
generalize (Hrec x0 x1 H2). intro.
unfold qif, get_info in H. now rewrite H0 in H.
Qed.

Lemma  BC_to_TRS_monotonicity bc st n s:
  let trs := snd (BC_to_TRS bc st) in
  arities bc = ok_arities n s →
  monotonicity_QI_prog trs.
Proof.
intro trs. subst trs. unfold monotonicity_QI_prog, monotonicity_qif.
intro Har. revert st. generalize Har.
apply BC_ind_inf with (e:=bc) (n:=n) (s:=s); auto; intros; try case b; simpl;
  unfold one_rule_prog, multi_rules_prog, simple_prog;
  unfold qif, get_info; simpl; intros.
1, 2, 3, 4, 5, 6: case (f=?S st); unfold base_info, Err_info; simpl;
  auto using forall2_le_maxl.
1, 2, 3, 4, 5, 6: rewrite <- Nat.succ_le_mono; auto using forall2_le_maxl, forall2_le_suml.
- rewrite Forall2_firstn_skipn_iff with (n1:=n0) in H0. destruct H0.
  apply Nat.add_le_mono; auto using forall2_le_maxl, forall2_le_suml.
- open_rec H H0 H1. open_monads_rec g h0 h1 st.
  case (f =? S (fst (BC_to_TRS h1 (fst (BC_to_TRS h0 (fst (BC_to_TRS g st))))))).
  + unfold asg, norm.
    apply Nat.add_le_mono. apply Nat.add_le_mono. apply Nat.mul_le_mono.
    2: apply Nat.add_le_mono.
    * now inversion H5.
    * apply BC_to_TRS_qf_monotonicity_main with (n:=S n0) (s:=S s0); auto.
      now apply Forall2_firstn.
    * apply BC_to_TRS_qf_monotonicity_main with (n:=S n0) (s:=S s0); auto.
      now apply Forall2_firstn.
    * apply BC_to_TRS_qf_monotonicity_main with (n:=n0) (s:=s0); auto.
      apply Forall2_tail. now apply Forall2_firstn.
    * apply forall2_le_maxl. now apply Forall2_skipn.
  + case_eq (assoc Nat.eqb f (infos (snd (BC_to_TRS g st)))); intros.
    2: case_eq (assoc Nat.eqb f (infos (snd (BC_to_TRS h0 (fst (BC_to_TRS g st)))))); intros.
    3: case_eq (assoc Nat.eqb f (infos (snd (BC_to_TRS h1 (fst (BC_to_TRS h0 (fst (BC_to_TRS g st)))))))); intros.
    * unfold qif, get_info in H2. rewrite assoc_app_in; auto.
      rewrite assoc_in_Some_simple; eauto.
    * unfold qif, get_info in H3. rewrite assoc_None_not_in in H6; auto.
      rewrite assoc_app_out; auto. rewrite assoc_app_in; auto.
      rewrite assoc_in_Some_simple; eauto.
    * unfold qif, get_info in H4. rewrite assoc_None_not_in in H6, H7; auto.
      repeat (rewrite assoc_app_out; auto).
    * rewrite assoc_None_not_in in H6, H7; auto.
      do 2 (rewrite assoc_app_out; auto). rewrite H8.
      unfold Err_info, Err_assig. simpl. now apply forall2_le_maxl.
- open_monads_comp h rl tl st.
  case (f =? S (fst (lm_to_ml (map BC_to_TRS tl) (fst (lm_to_ml (map BC_to_TRS rl) (fst (BC_to_TRS h st))))))).
  + simpl. apply Nat.add_le_mono. apply Nat.add_le_mono. apply Nat.add_le_mono.
    * apply BC_to_TRS_qf_monotonicity_main with (n:=length rl) (s:=length tl); auto.
      apply Forall2_map. rewrite <- Forall_forall.
      apply lm_to_ml_ind. intros. rewrite in_map_iff in H6. repeat destruct H6.
      apply BC_to_TRS_qf_monotonicity_main with (n:=n0) (s:=0); auto using Forall2_firstn.
    * apply suml_map_le. intros.
      generalize (in_lm_to_ml x (map BC_to_TRS tl) (fst (lm_to_ml (map BC_to_TRS rl) (fst (BC_to_TRS h st)))) H6).
      intro. repeat destruct H7. rewrite in_map_iff in H7. repeat destruct H7. subst x.
      apply BC_to_TRS_qf_monotonicity_main with (n:=n0) (s:=s0); auto using Forall2_firstn.
    * apply forall2_le_maxl. now apply Forall2_firstn.
    * apply forall2_le_maxl. now apply Forall2_skipn.
  + case_eq (assoc Nat.eqb f (infos (snd (BC_to_TRS h st)))); intros.
    2: case_eq (assoc Nat.eqb f (get_infos (snd (lm_to_ml (map BC_to_TRS rl) (fst (BC_to_TRS h st)))))); intros.
    3: case_eq (assoc Nat.eqb f (get_infos (snd (lm_to_ml (map BC_to_TRS tl)
                 (fst (lm_to_ml (map BC_to_TRS rl) (fst (BC_to_TRS h st)))))))); intros.
    * unfold qif, get_info in H2. rewrite assoc_app_in; auto.
      rewrite assoc_in_Some_simple; eauto.
    * rewrite assoc_None_not_in in H6; auto. rewrite assoc_app_out; auto.
      rewrite assoc_app_in; auto.
      2: rewrite assoc_in_Some_simple; eauto.
      rewrite H7.
      apply BC_to_TRS_monotonicity_comp_aux with (f:=f) (bcl:=rl) (st:=fst (BC_to_TRS h st)); auto.
    * rewrite assoc_None_not_in in H6, H7; auto. do 2 (rewrite assoc_app_out; auto).
      rewrite H8.
      apply BC_to_TRS_monotonicity_comp_aux with (f:=f) (bcl:=tl)
            (st:=fst (lm_to_ml (map BC_to_TRS rl) (fst (BC_to_TRS h st)))); auto.
    * rewrite assoc_None_not_in in H6, H7; auto.
      do 2 (rewrite assoc_app_out; auto). rewrite H8.
      unfold Err_info, Err_assig. simpl. now apply forall2_le_maxl.
Qed.

Lemma BC_to_TRS_comp_rec_rec_aux g h0 h1 st n s sub h mh ps:
  let myqif := qif (snd ((BC_to_TRS g >>+ BC_to_TRS h0 >>++ BC_to_TRS h1 >>+ Mnew_fun >>==
                Mmr (S n) s) st)) in
  arities h0 = ok_arities (S n) (S s) →
  arities h1 = ok_arities (S n) (S s) →
  mh = asg_main (snd (BC_to_TRS h0 (fst (BC_to_TRS g st)))) ∨
  mh = asg_main (snd (BC_to_TRS h1 (fst (BC_to_TRS h0 (fst (BC_to_TRS g st)))))) →
  (∀ l, myqif h l = mh (firstn (n+1) l) + maxl (skipn (n+1) l)) →
  term_assignment variable function constructor qic noqif (subst sub (term_from_pattern (ps px))) =
  (term_assignment variable function constructor qic noqif (subst sub (term_from_pattern px))) +1 →
  term_assignment variable function constructor qic myqif
  (subst sub (fapply h (mk_args_h (S n) s (mk_call (S (n + s))
              (S (fst (BC_to_TRS h1 (fst (BC_to_TRS h0 (fst (BC_to_TRS g st)))))))))))
  ≤ myqif (S (fst (BC_to_TRS h1 (fst (BC_to_TRS h0 (fst (BC_to_TRS g st)))))))
    (map (term_assignment variable function constructor qic myqif)
       (map (subst sub) (map term_from_pattern (ps px :: mk_pvl 1 (S (n + s)))))).
Proof.
intros. simpl. rewrite (ta_of_pl noqif).
rewrite (term_assignment_of_value noqif). rewrite (ta_of_p_subst noqif).
rewrite H3.
unfold myqif at 3. open_monads_rec g h0 h1 st.
unfold make_rec, qif, get_info. simpl infos.
simpl assoc. rewrite Nat.eqb_refl; auto. simpl.
unfold mk_call, mk_args_h. repeat rewrite map_app. simpl.
repeat rewrite map_mk_tv_is_mk_tvl.
rewrite (ta_of_tvl noqif). rewrite (ta_of_tvl noqif) with (n:=S n).
rewrite (ta_of_tvl noqif) with (m:=n+s+1).
rewrite (term_assignment_of_value noqif) with (qif1:=myqif).
unfold myqif at 2. open_monads_rec g h0 h1 st.
unfold make_rec, qif, get_info. simpl infos.
simpl assoc. rewrite Nat.eqb_refl; auto. simpl.
rewrite (S_is_suc (n+s)). rewrite (S_is_suc n).
rewrite tfp_pvl_is_tvl.
repeat rewrite firstn_map. rewrite firstn_tvl.
replace (Init.Nat.min (1 + n) (n + s + 1)) with (n+1); try (zify;omega).
set (X:=term_assignment variable function constructor qic noqif (term_from_value (sub 0))).
set (L:=map (term_assignment variable function constructor qic noqif) (map (subst sub) (mk_tvl 1 (n + 1)))).
set (L':=map (term_assignment variable function constructor qic noqif) (map (subst sub) (mk_tvl 1 (n + s + 1)))).
set (L'':=map (term_assignment variable function constructor qic noqif) (map (subst sub) (mk_tvl (n + 1) (n + s + 1)))).
set (MG:=asg_main (snd (BC_to_TRS g st)) L).
set (mh0:=asg_main (snd (BC_to_TRS h0 (fst (BC_to_TRS g st))))).
set (mh1:=asg_main (snd (BC_to_TRS h1 (fst (BC_to_TRS h0 (fst (BC_to_TRS g st))))))).
rewrite H2.
rewrite <- (S_is_suc n). rewrite firstn_cons. simpl.
rewrite firstn_app2, skipn_app2.
enough (mh0 (X :: L) ≤ mh0 (X + 1 :: L)).
enough (mh1 (X :: L) ≤ mh1 (X + 1 :: L)).
enough (maxl L'' ≤ maxl L').
enough (maxl L ≤ maxl L').
enough (skipn n L'=L'').
enough (mh(X::L) ≤ mh0(X::L) + mh1(X::L)).
- rewrite H8. rewrite maxl_cons. repeat rewrite Nat.mul_add_distr_l.
  repeat rewrite Nat.mul_add_distr_r. repeat rewrite Nat.mul_1_l.
  apply le_trans with (m:=mh (X :: L) + X * mh0 (X :: L) + X * mh1 (X :: L) + MG + maxl L''); try (zify; omega).
  do 2 apply Nat.add_le_mono_r. rewrite Nat.add_assoc.
  apply le_trans with (m:=mh0 (X + 1 :: L) + mh1 (X + 1 :: L) + X * mh0 (X + 1 :: L) + X * mh1 (X + 1 :: L)); try omega.
  apply Nat.add_le_mono. apply Nat.add_le_mono.
  + apply le_trans with (m:=mh0 (X :: L) + mh1 (X :: L)); omega.
  + now apply Nat.mul_le_mono_l.
  + now apply Nat.mul_le_mono_l.
- repeat destruct H1.
  + subst mh0. omega.
  + subst mh1. omega.
- subst L' L''. unfold mk_tvl, ints.
  repeat rewrite skipn_map. rewrite skipn_seq.
  do 4 (apply f_equal2; auto); omega.
- apply incl_le_maxl. do 2 apply map_incl. apply tvl_incl. omega.
- apply incl_le_maxl. do 2 apply map_incl. apply tvl_incl. omega.
- apply BC_to_TRS_qf_monotonicity_main with (n:=S n) (s:=S s); auto.
  apply Forall2_cons; try omega. apply Forall2_le_refl.
- apply BC_to_TRS_qf_monotonicity_main with (n:=S n) (s:=S s); auto.
  apply Forall2_cons; try omega. apply Forall2_le_refl.
- subst L. do 2 rewrite map_length. rewrite tvl_length; omega.
- subst L. do 2 rewrite map_length. rewrite tvl_length; omega.
Qed.

Lemma BC_to_TRS_comp_rec_rec g h0 h1 st n s sub trs_h ps:
  let myqif := qif (snd ((BC_to_TRS g >>+ BC_to_TRS h0 >>++ BC_to_TRS h1 >>+ Mnew_fun >>==
                Mmr (S n) s) st)) in
  arities h0 = ok_arities (S n) (S s) →
  arities h1 = ok_arities (S n) (S s) →
  trs_h=snd (BC_to_TRS h0 (fst (BC_to_TRS g st))) ∨
  trs_h=snd (BC_to_TRS h1 (fst (BC_to_TRS h0 (fst (BC_to_TRS g st))))) →
  ps=ps0 ∨ ps=ps1 →
  term_assignment variable function constructor qic myqif
  (subst sub (fapply trs_h.(main) (mk_args_h (S n) s (mk_call (S (n + s))
              (S (fst (BC_to_TRS h1 (fst (BC_to_TRS h0 (fst (BC_to_TRS g st)))))))))))
  ≤ myqif (S (fst (BC_to_TRS h1 (fst (BC_to_TRS h0 (fst (BC_to_TRS g st)))))))
    (map (term_assignment variable function constructor qic myqif)
       (map (subst sub) (map term_from_pattern (ps px :: mk_pvl 1 (S (n + s)))))).
Proof.
intros. apply BC_to_TRS_comp_rec_rec_aux with (mh:=asg_main trs_h); auto.
- repeat destruct H1; auto.
- intro. open_monads_rec g h0 h1 st.
  unfold make_rec, qif, get_info. simpl infos.
  generalize BC_to_TRS_Mlt as HMlt. unfold Mlt, Meval. intro.
  generalize (HMlt g st) as Hg.
  generalize (HMlt h0 (fst (BC_to_TRS g st))) as Hh0.
  generalize (HMlt h1 (fst (BC_to_TRS h0 (fst (BC_to_TRS g st))))) as Hh1.
  intros.
  simpl assoc. destruct H1; rewrite H1.
  + rewrite eqb_subst_neq. rewrite assoc_app_out; auto. rewrite assoc_app_in; auto.
    * rewrite get_info_main_eq, asg_main_eq.
      rewrite BC_to_TRS_arity_norm with (n:=S n) (s:=S s); auto.
      now rewrite S_is_suc.
    * rewrite BC_to_TRS_infos_iff. apply BC_to_TRS_main_defined.
    * intro. rewrite BC_to_TRS_infos_iff in H3.
      generalize (BC_to_TRS_func_bounds g _ _ H3). rewrite BC_to_TRS_main_is_last.
      rewrite BC_to_TRS_first. repeat rewrite BC_to_TRS_last. intro. omega.
    * rewrite BC_to_TRS_main_is_last. rewrite BC_to_TRS_last. omega.
  + rewrite eqb_subst_neq. rewrite assoc_app_out; auto. rewrite assoc_app_out; auto.
    * rewrite get_info_main_eq, asg_main_eq.
      rewrite BC_to_TRS_arity_norm with (n:=S n) (s:=S s); auto.
      now rewrite S_is_suc.
    * intro. rewrite BC_to_TRS_infos_iff in H3.
      generalize (BC_to_TRS_func_bounds h0 _ _ H3). rewrite BC_to_TRS_main_is_last.
      rewrite BC_to_TRS_first. repeat rewrite BC_to_TRS_last. intro. omega.
    * intro. rewrite BC_to_TRS_infos_iff in H3.
      generalize (BC_to_TRS_func_bounds g _ _ H3). rewrite BC_to_TRS_main_is_last.
      rewrite BC_to_TRS_first. repeat rewrite BC_to_TRS_last. intro. omega.
    * rewrite BC_to_TRS_main_is_last. rewrite BC_to_TRS_last. omega.
- destruct H2; rewrite H2; unfold qic, cs; simpl; omega.
Qed.

Lemma max_match x y z:
  x ≤ match max x (max y z) with
      | 0 => 1
      | S n => S n
      end.
Proof. case x, y, z; simpl; zify; omega. Qed.

Lemma In_cons_eq_dec_iff {A:Type} a x (xs:list A):
  (∀ n m : A, {n = m} + {n ≠ m}) →
  a ∈ x::xs ↔ a = x ∨ (x ≠ a ∧ a ∈ xs).
Proof.
intro eq_dec. split; intro.
- case (eq_dec x a) as [Heq | Hneq].
  + now left.
  + simpl in H. destruct H; tauto.
- simpl. destruct H.
  + now left.
  + now right.
Qed.

Lemma  BC_to_TRS_compatible bc st n s:
  let trs := snd (BC_to_TRS bc st) in
  arities bc = ok_arities n s → compatible_QI_prog trs.
Proof.
intros trs Har. subst trs. unfold compatible_QI_prog, compatible_QI.
revert st. generalize Har.
apply BC_ind_inf with (e:=bc) (n:=n) (s:=s); auto; simpl; intro; try case b;
  unfold Morp, sr_uncurry; simpl;
  unfold one_rule_prog, multi_rules_prog, simple_prog, simple_rule; intros.
2: destruct H0; try tauto; inversion H0.
1, 3, 4: destruct H; try tauto; inversion H.
1, 2, 3, 4: unfold qif, get_info; simpl; rewrite Nat.eqb_refl; simpl.
1, 2, 3: unfold base_info, qic, cs; simpl; auto.
1, 2: rewrite Nat.max_0_r; omega.
- 
  rewrite (term_assignment_of_value noqif), (ta_of_pl noqif).
  rewrite tfp_pvl_is_tvl.
  apply le_trans with (m:=suml (firstn n0 (map (term_assignment variable function constructor qic noqif)
             (map (subst s1) (mk_tvl 0 (n0 + s0))))) +
                          maxl (skipn n0 (map (term_assignment variable function constructor qic noqif)
             (map (subst s1) (mk_tvl 0 (n0 + s0)))))); auto.
  repeat rewrite firstn_map, skipn_map.
  rewrite firstn_tvl, skipn_tvl.
  case_eq (i <? n0); try rewrite Nat.ltb_lt; try rewrite Nat.ltb_ge; intro.
  + apply le_trans with (m:=suml (map (term_assignment variable function constructor qic noqif)
       (map (subst s1) (mk_tvl 0 (Init.Nat.min (0 + n0) (n0 + s0)))))); try omega.
    apply in_le_suml. apply in_map. unfold mk_tvl. rewrite map_map.
    simpl. rewrite in_map_iff. exists i. split; auto.
    rewrite <- ints_bounds_iff; try split; zify; omega.
  + apply le_trans with (m:=maxl (map (term_assignment variable function constructor qic noqif)
       (map (subst s1) (mk_tvl (0 + n0) (n0 + s0))))); try omega.
    apply maxl_is_max. apply in_map. unfold mk_tvl. rewrite map_map.
    simpl. rewrite in_map_iff. exists i. split; auto.
    rewrite <- ints_bounds_iff; try split; zify; omega.
- 
  unfold sr_uncurry, simple_rule. simpl.
  destruct H as [H | [H | [H | Hf]]]; try tauto; inversion H.
  1, 2, 3: unfold qif, get_info; simpl; rewrite Nat.eqb_refl.
  2, 3: unfold base_info; simpl; rewrite Nat.max_0_r.
  1, 2, 3: unfold qic, cs; simpl; omega.
- 
  destruct H as [H | [H | [H | Hf]]]; try tauto; inversion H.
  1, 2, 3: unfold qif, get_info, base_info; simpl.
  1, 2, 3: rewrite Nat.eqb_refl; simpl.
  2, 3: zify; omega.
  rewrite Nat.max_0_r. auto using max_match.
- 
  clear Har0. revert H5. open_rec H H0 H1.
  set (myqif:=qif (snd ((BC_to_TRS g >>+ BC_to_TRS h0 >>++ BC_to_TRS h1 >>+ Mnew_fun >>==
            Mmr (S n0) s0) st))).
  open_monads_rec g h0 h1 st.
  unfold sr_uncurry, simple_rule. intros.
  repeat rewrite in_app_iff in H5. destruct H5 as [Hrule | [Hrule | [Hrule | [Hrec | [Hrec | Hrec]]]]].
  2, 3: inversion Hrule; apply BC_to_TRS_comp_rec_rec; auto. 
  + inversion Hrule. clear Har H0 H1 H2 H3 H4 H6 H7 H8 Hrule. 
    simpl. unfold qic at 2, cs. simpl.
    rewrite (ta_of_pl noqif). rewrite (ta_of_tvl noqif).
    unfold myqif at 1, qif.
    rewrite BC_to_TRS_infos_subst_rec_first; auto using BC_to_TRS_main_defined.
    rewrite asg_main_eq. rewrite BC_to_TRS_arity_norm with (n:=n0) (s:=s0); auto.
    rewrite tfp_pvl_is_tvl.
    subst myqif. open_monads_rec g h0 h1 st.
    unfold make_rec, qif, get_info. simpl infos. simpl assoc.
    rewrite Nat.eqb_refl; auto. simpl.
    case (maxl (map (term_assignment variable function constructor qic noqif)
                 (map (subst s1) (mk_tvl 1 (S (n0 + s0)))))); intros; omega.
  + clear H0 H1 H3 H4 Har. 
    rewrite (ta_of_pl (qif (snd (BC_to_TRS g st)))).
    rewrite qif_swap with (qif2:=qif (snd (BC_to_TRS g st))); intros;
      subst myqif; unfold qif; rewrite BC_to_TRS_infos_subst_rec_first; auto.
    * apply H2; auto.
    * rewrite <- rule_intro_is_lhs. eauto.
    * apply BC_to_TRS_rhs_funcs_defined. unfold all_rhs_funcs.
      rewrite in_flat_map. exists (rule_intro f lp t). split; auto.
  + clear H H1 H2 H4 Har. 
    rewrite (ta_of_pl (qif (snd (BC_to_TRS h0 (fst (BC_to_TRS g st)))))).
    rewrite qif_swap with (qif2:=qif (snd (BC_to_TRS h0 (fst (BC_to_TRS g st))))); intros;
      subst myqif; unfold qif; rewrite BC_to_TRS_infos_subst_rec_second; auto.
    * apply H3; auto.
    * rewrite <- rule_intro_is_lhs. eauto.
    * apply BC_to_TRS_rhs_funcs_defined. unfold all_rhs_funcs.
      rewrite in_flat_map. exists (rule_intro f lp t). split; auto.
  + clear H H0 H2 H3 Har. 
    rewrite (ta_of_pl (qif (snd (BC_to_TRS h1 (fst (BC_to_TRS h0 (fst (BC_to_TRS g st)))))))).
    rewrite qif_swap with (qif2:=qif (snd (BC_to_TRS h1 (fst (BC_to_TRS h0 (fst (BC_to_TRS g st))))))); intros;
      subst myqif; unfold qif; rewrite BC_to_TRS_infos_subst_rec_third; auto.
    * apply H4; auto.
    * rewrite <- rule_intro_is_lhs. eauto.
    * apply BC_to_TRS_rhs_funcs_defined. unfold all_rhs_funcs.
      rewrite in_flat_map. exists (rule_intro f lp t). split; auto.
- 
  clear Har0. revert H5.
  set (myqif:=qif (snd ((BC_to_TRS h >>+ lm_to_ml (map BC_to_TRS rl) >>++
            lm_to_ml (map BC_to_TRS tl) >>+ Mnew_fun >>== Mmc n0 s0) st))).
  open_monads_comp h rl tl st. unfold simple_rule. intro.
  repeat rewrite in_app_iff in H5.
  destruct H5 as [Hr | [ Hh | [Hrl | Htl]]].
  + inversion Hr. clear Har H2 H3 H4 H6 H7 H8 Hr. 
    rewrite (ta_of_pl noqif). rewrite tfp_pvl_is_tvl.
    unfold mk_call_trs, mk_call. simpl.
    unfold myqif at 1 3, qif. rewrite BC_to_TRS_infos_subst_comp_first; auto using BC_to_TRS_main_defined.
    rewrite asg_main_eq. rewrite BC_to_TRS_arity_norm with (n:=length rl) (s:=length tl); auto.
    repeat rewrite firstn_map, skipn_map. rewrite firstn_app2, skipn_app2.
    2, 3: now rewrite map_length, lm_to_ml_length, map_length.
    open_monads_comp h rl tl st.
    unfold make_comp, get_info. simpl infos. simpl assoc.
    rewrite Nat.eqb_refl. simpl.
    repeat rewrite firstn_map, skipn_map.
    rewrite firstn_tvl, skipn_tvl.
    replace (min (0+n0) (n0+s0)) with (n0); try (zify;omega).
    repeat rewrite map_map. simpl.
    repeat rewrite (ta_of_tvl noqif) with (qif1:=myqif).
    repeat rewrite map_map.

    set (Ln:=map (λ x, term_assignment variable function constructor qic noqif
              (subst s1 x)) (mk_tvl 0 n0)).
    set (Lns:=map (λ x, term_assignment variable function constructor qic noqif
              (subst s1 x)) (mk_tvl 0 (n0+s0))).
    set (Lnns:=map (λ x, term_assignment variable function constructor qic noqif
              (subst s1 x)) (mk_tvl n0 (n0 + s0))).
    set (mh:=asg_main (snd (BC_to_TRS h st))).
    set (RL:=snd (lm_to_ml (map BC_to_TRS rl) (fst (BC_to_TRS h st)))).
    set (TL:=snd (lm_to_ml (map BC_to_TRS tl) (fst (lm_to_ml (map BC_to_TRS rl) (fst (BC_to_TRS h st)))))).

    replace (map (λ x : trs_prog, myqif (main x) Ln) RL) with (map (λ x : trs_prog, asg_main x Ln) RL). 
    replace (map (λ x : trs_prog, myqif (main x) Lns) TL) with (map (λ x : trs_prog, asg_main x Ln + maxl Lnns) TL).
    * repeat rewrite <- Nat.add_assoc. apply Nat.add_le_mono_l.
      rewrite maxl_map_le_iff. intros.
      rewrite Nat.add_assoc. apply Nat.add_le_mono_r.
      apply le_trans with (m:=suml (map (λ trs0 : trs_prog, asg_main trs0 Ln) TL)); try omega.
      apply in_le_suml. rewrite in_map_iff. eauto.
    * apply map_ext_in. intros. unfold myqif, qif.
      { rewrite BC_to_TRS_infos_subst_comp_third.
        rewrite map_BC_to_TRS_arity_norm with (n:=n0) (s:=s0); auto.
        replace (skipn n0 Lns) with (Lnns).
        replace (firstn n0 Lns) with (Ln).
        - rewrite Nat.add_cancel_r.
          rewrite get_info_main_list; auto.
        - subst Ln Lns. rewrite firstn_map. rewrite firstn_tvl.
          replace (min (0+n0) (n0+s0)) with (n0); try (zify; omega). auto.
        - subst Lnns Lns. rewrite skipn_map. rewrite skipn_tvl. apply f_equal2; auto.
        - rewrite in_flat_map. exists a. split; auto.
          generalize (in_lm_to_ml _ _ _ H2). intro. repeat destruct H3. subst a.
          rewrite in_map_iff in H3. repeat destruct H3. apply BC_to_TRS_main_defined.
      }
    * apply map_ext_in. intros. unfold myqif, qif.
      { rewrite BC_to_TRS_infos_subst_comp_second.
        rewrite map_BC_to_TRS_arity_norm with (n:=n0) (s:=0); auto.
        replace (skipn n0 Ln) with ([]:list nat).
        replace (firstn n0 Ln) with (Ln).
        - simpl. rewrite Nat.add_0_r.
          rewrite get_info_main_list; auto.
        - subst Ln. rewrite firstn_map. rewrite firstn_tvl.
          replace (min (0+n0) (n0)) with (n0); try (zify; omega). auto.
        - subst Ln. rewrite skipn_map. rewrite skipn_tvl.
          simpl. unfold mk_tvl, ints. rewrite Nat.sub_diag. now simpl.
        - rewrite in_flat_map. exists a. split; auto.
          generalize (in_lm_to_ml _ _ _ H2). intro. repeat destruct H3. subst a.
          rewrite in_map_iff in H3. repeat destruct H3. apply BC_to_TRS_main_defined.
      }
  + clear H0 H1 H3 H4 Har. 
    rewrite (ta_of_pl (qif (snd (BC_to_TRS h st)))).
    rewrite qif_swap with (qif2:=qif (snd (BC_to_TRS h st))); intros;
      subst myqif; unfold qif; rewrite BC_to_TRS_infos_subst_comp_first; auto.
    * apply H2; auto.
    * rewrite <- rule_intro_is_lhs. eauto.
    * apply BC_to_TRS_rhs_funcs_defined. unfold all_rhs_funcs.
      rewrite in_flat_map. exists (rule_intro f lp t). split; auto.
  + clear H H1 H2 H4 Har. 
    generalize Hrl. unfold get_rules. rewrite in_concat_iff. intro.
    repeat destruct H. rewrite in_map_iff in H. repeat destruct H.
    generalize (in_lm_to_ml _ _ _ H2). intro. repeat destruct H. subst x0.
    rewrite in_map_iff in H. repeat destruct H.
    rewrite (ta_of_pl (qif (snd (BC_to_TRS x0 x1)))).
    rewrite qif_swap with (qif2:=qif (snd (BC_to_TRS x0 x1))); intros;
    subst myqif; unfold qif; rewrite BC_to_TRS_infos_subst_comp_second.
    * rewrite qif_eq. rewrite (get_info_in_list (snd (BC_to_TRS x0 x1))); try apply H3; auto.
      rewrite <- rule_intro_is_lhs. eauto.
    * rewrite in_flat_map. exists (snd (BC_to_TRS x0 x1)). split; auto.
      rewrite <- rule_intro_is_lhs. eauto.
    * rewrite (get_info_in_list (snd (BC_to_TRS x0 x1))); auto.
      apply BC_to_TRS_rhs_funcs_defined.
      unfold all_rhs_funcs. rewrite in_flat_map.
      exists (rule_intro f lp t). split; auto.
    * rewrite in_flat_map. exists (snd (BC_to_TRS x0 x1)). split; auto.
      apply BC_to_TRS_rhs_funcs_defined.
      unfold all_rhs_funcs. rewrite in_flat_map.
      exists (rule_intro f lp t). split; auto.
  + clear H H0 H2 H3 Har. 
    generalize Htl. unfold get_rules. rewrite in_concat_iff. intro.
    repeat destruct H. rewrite in_map_iff in H. repeat destruct H.
    generalize (in_lm_to_ml _ _ _ H2). intro. repeat destruct H. subst x0.
    rewrite in_map_iff in H. repeat destruct H.
    rewrite (ta_of_pl (qif (snd (BC_to_TRS x0 x1)))).
    rewrite qif_swap with (qif2:=qif (snd (BC_to_TRS x0 x1))); intros;
    subst myqif; unfold qif; rewrite BC_to_TRS_infos_subst_comp_third.
    * rewrite qif_eq. rewrite (get_info_in_list (snd (BC_to_TRS x0 x1))); try apply H4; auto.
      rewrite <- rule_intro_is_lhs. eauto.
    * rewrite in_flat_map. exists (snd (BC_to_TRS x0 x1)). split; auto.
      rewrite <- rule_intro_is_lhs. eauto.
    * rewrite (get_info_in_list (snd (BC_to_TRS x0 x1))); auto.
      apply BC_to_TRS_rhs_funcs_defined.
      unfold all_rhs_funcs. rewrite in_flat_map.
      exists (rule_intro f lp t). split; auto.
    * rewrite in_flat_map. exists (snd (BC_to_TRS x0 x1)). split; auto.
      apply BC_to_TRS_rhs_funcs_defined.
      unfold all_rhs_funcs. rewrite in_flat_map.
      exists (rule_intro f lp t). split; auto.
Qed.

Theorem BC_to_TRS_QI st (n s:nat) bc:
   let trs := snd (BC_to_TRS bc st) in arities bc = ok_arities n s →
   valid_QI_prog trs.
Proof.
intro trs. subst trs.
unfold valid_QI_prog, valid_QI, additive, mcs_is_max_constructor_size, constructor_non_zero.
intros. repeat split; auto.
- now apply BC_to_TRS_subterm with (n:=n) (s:=s).
- now apply BC_to_TRS_monotonicity with (n:=n) (s:=s).
- now apply BC_to_TRS_compatible with (n:=n) (s:=s).
Qed.

Variable rule_default:rule.

Theorem BC_to_TRS_P_criterion bc st no sa:
  forall i s p c f lv d v,
  let trs := snd (BC_to_TRS bc st) in
  let t := fapply f lv in
  let pi := cbv_update i s p c t d v in
  arities bc = ok_arities no sa → f ∈ all_lhs_funcs trs →
  wf Nat.eq_dec Nat.eq_dec constructor_eq_dec rule_default trs.(rules) trs.(maxar) pi →
  cache_bounded variable function constructor qic (qif trs) c →
  size pi ≤ global_bound variable function constructor trs.(rules) trs.(maxar) trs.(maxrank) mcs (qif trs) f lv c.
Proof.
intros. subst trs0.
apply P_criterion with (rule_default:=rule_default) (variable_eq_dec:=Nat.eq_dec)
                       (function_eq_dec:=Nat.eq_dec) (constructor_eq_dec:=constructor_eq_dec)
                       (rank:=get_rank (snd (BC_to_TRS bc st))) (cs:=cs) (qic:=qic); auto.
- now apply BC_to_TRS_wf with (n:=no) (s:=sa).
- apply BC_to_TRS_pos_maxrank.
- apply BC_to_TRS_maxrank_is_max_rank_error.
- now apply BC_to_TRS_PPO with (n:=no) (s:=sa).
- now apply BC_to_TRS_QI with (n:=no) (s:=sa).
Qed.

End Completness.
