Require Import List Omega Numbers.BinNums Psatz.

Import List.ListNotations.



Require Import Cecoa.Lib Cecoa.Interface.
(* Cecoa.Lib:
Require Import Bool Arith Max Omega Psatz List NPeano Permutation.
Import List.ListNotations.

Require Import Unicode.Utf8_core.
Require Import Unicode.Utf8.
Notation "x ≤ y ≤ z" := (x ≤ y ∧ y ≤ z) (at level 70, y at next level).
Notation "x < y ≤ z" := (x < y ∧ y ≤ z) (at level 70, y at next level).
Notation "x ≤ y < z" := (x ≤ y ∧ y < z) (at level 70, y at next level).

Infix "∈" := In (at level 70).

Infix "=?" := beq_nat (at level 70, no associativity).

Obligation Tactic := idtac.

Scheme Equality for prod.
Scheme Equality for list.

Set Implicit Arguments.

Section Trivial.
Lemma S_is_suc n: S n = n+1.
Lemma or_idem: ∀ A, A ↔ A ∨ A.
Lemma and_idem: ∀ A, A ↔ A ∧ A.
Lemma and_left: ∀ A B, A ∧ B → A.
Lemma or_false_idem: ∀ A, A ↔ A ∨ False.

Definition fmono (f: nat → nat):= ∀ x y, x ≤ y → f x ≤ f y.

Lemma forall_and {A:Type} (P Q:A→Prop):
  (∀ x, P x ∧ Q x) ↔ ((∀ x, P x) ∧ (∀ x, Q x)).
Lemma forall_impl_and {A:Type} (R:A→Prop) (P Q:A→Prop):
  (∀ x, R x → P x ∧ Q x) ↔
  ((∀ x, R x → P x) ∧ (∀ x, R x → Q x)).
Lemma forall_impl2_and {A B:Type} (P Q R : A → B → Prop):
  (∀ x y, R x y → P x y ∧ Q x y) ↔ 
  ((∀ x y, R x y → P x y) ∧ (∀ x y, R x y → Q x y)).

Lemma eqb_subst_neq x y:
  x ≠ y → (x =? y) = false.
Lemma neq_lt_gt_iff (m n:nat):
  m ≠ n ↔ (m < n ∨ n < m).

Lemma length_nil : forall A (l : list A),
  length l = 0 -> l = nil.
End Trivial.

Lemma prod_beq_eq A B
  (A_beq : A -> A -> bool) (B_beq : B -> B -> bool)
  (A_beq_eq : forall a1 a2, A_beq a1 a2 = true <-> a1 = a2) (B_beq_eq : forall b1 b2, B_beq b1 b2 = true <-> b1 = b2)
  p1 p2 : prod_beq _ _ A_beq B_beq p1 p2 = true <-> p1 = p2.

Lemma list_beq_eq A
  (A_beq : A -> A -> bool) l1 l2 (A_beq_eq : forall a1 a2, In a1 l1 -> In a2 l2 -> (A_beq a1 a2 = true <-> a1 = a2)) :
  list_beq _ A_beq l1 l2 = true <-> l1 = l2.

Lemma list_beq_refl (A : Type) (A_beq : A -> A -> bool) l :
  (forall a1 a2 : A, In a1 l -> In a2 l -> (A_beq a1 a2 = true <-> a1 = a2)) ->
  list_beq _ A_beq l l = true.

Lemma eq_None_neq_Some (A : Type) (x : option A) :
  x = None <-> forall v, x <> Some v.

Lemma neq_None_eq_Some :
  forall (A: Type) (x: option A), x <> None <-> (exists a, x = Some a).

Lemma app_insert_r (A : Type) (l1 l1' l l2 l2' : list A):
  l1 ++ l2 = l1' ++ l2' -> length l2 = length l2' -> l1 ++ l ++ l2 = l1' ++ l ++ l2'.

Section assoc.

Fixpoint assoc {A B : Type}(eq : A -> A -> bool)(x : A)(l : list (A * B)) : option B :=
  match l with
  | nil => None
  | (x', y) :: l' => if eq x x' then Some y else assoc eq x l'
  end.

Definition assoc_default {A B : Type}
  (eqA : A -> A -> bool) (d : B) (l : list (A * B)) (x : A) : B :=
  match assoc eqA x l with
  | None => d
  | Some b => b
  end.

Lemma assoc_in {A B:Type} beq k (l: list (A * B)) {v}:
  (∀ a b:A, beq a b = true ↔ a=b) →
  assoc beq k l = Some v → (k,v) ∈ l.

Lemma assoc_None_not_in {A B:Type} beq k (l:list (A*B)):
  (∀ a b : A, beq a b = true ↔ a = b) →
  assoc beq k l = None ↔ ¬ k ∈ map fst l.

Lemma in_assoc_neq_None (A B: Type) (beq: A -> A -> bool) (k: A) (l: list (A * B)):
  (forall a b:A, a = b -> beq a b = true) ->
  In k (map (@fst _ _) l) ->
  assoc beq k l <> None.

Lemma assoc_in_Some {A B:Type} (beq:A→A→bool) (k:A) (l: list (A*B)):
  (∀ a b, beq a b = true ↔ a=b) →
  k ∈ map fst l ↔ ∃ v, v ∈ map snd l ∧ assoc beq k l = Some v.

Lemma assoc_in_Some_simple {A B:Type} beq k (l: list (A*B)):
  (∀ a b:A, beq a b = true ↔ a = b) →
  k ∈ map fst l ↔ (∃ v, assoc beq k l = Some v).

Lemma assoc_app_eq_None (A B:Type) (eq: A -> A -> bool) (x: A) (l1 l2: list (A * B)) :
  assoc eq x (l1 ++ l2) = None <-> (assoc eq x l1 = None /\ assoc eq x l2 = None).

Lemma assoc_app_neq_None (A B:Type) (eq: A -> A -> bool) (x: A) (l1 l2: list (A * B)) :
  assoc eq x (l1 ++ l2) <> None <-> (assoc eq x l1 <> None \/ assoc eq x l2 <> None).

Lemma assoc_app_eq_Some (A B:Type) (eq: A -> A -> bool) (x: A) (v : B) (l1 l2: list (A * B)) :
  assoc eq x (l1 ++ l2) = Some v <->
  (assoc eq x l1 = Some v \/ (assoc eq x l1 = None /\ assoc eq x l2 = Some v)).

Lemma assoc_app_in {K V:Type} beq k (l1 l2: list (K*V)):
  (∀ a b : K, beq a b = true ↔ a = b) →
  k ∈ map fst l1 → assoc beq k (l1++l2) = assoc beq k l1.

Lemma assoc_app_out {K V:Type} beq k (l1 l2: list (K*V)):
  (∀ a b : K, beq a b = true ↔ a = b) →
  ¬ k ∈ map fst l1 → assoc beq k (l1++l2) = assoc beq k l2.

Lemma assoc_in_concat {K V:Type} beq (k:K) ll (v:V):
  assoc beq k (concat ll) = Some v →
  ∃ l : list (K * V), l ∈ ll ∧ assoc beq k l = Some v.

End assoc.

Lemma map_in_ext :
  forall (A B : Type) (f g : A -> B) (l : list A),
  (forall a : A, In a l -> f a = g a) -> map f l = map g l.

Lemma incl_cons_cons A: forall (a:A) (l1 l2: list A), incl l1 l2 -> incl (a::l1) (a::l2).

Lemma map_incl A B (f : A -> B) l1 l2 : incl l1 l2 -> incl (map f l1) (map f l2).

Lemma map_flat_map (A B C : Type) (f : A -> list B) (g : B -> C) (l : list A) :
map g (flat_map f l) = flat_map (fun a => map g (f a)) l.

Lemma incl_filter (A : Type) (f : A -> bool) l:
  incl (filter f l) l.

Lemma filter_ext_In {A : Type} f g (l : list A): (forall a , In a l -> f a = g a)-> filter f l = filter g l.

Lemma filter_app A (f : A -> bool) l1 l2 : filter f (l1 ++ l2) = filter f l1 ++ filter f l2.

Lemma filter_flat_map A B f (g : A -> list B) l : filter f (flat_map g l) = flat_map (fun x => filter f (g x)) l.

Lemma flat_map_in_ext  A B (f g : A -> list B) l : 
  (forall a : A, In a l -> f a = g a) -> flat_map f l = flat_map g l.

Lemma NoDup_filter A f (l : list A) : NoDup l -> NoDup (filter f l).

Lemma map_cons (A B : Type)(f : A -> B) a l : map f (a :: l) = f a :: map f l.

Lemma length_remove A eq_A_dec (a: A) l :
  length (remove eq_A_dec a l) <= length l.

Lemma length_cons_remove A eq_A_dec (a: A) l :
  In a l -> length (a :: remove eq_A_dec a l) <= length l.

Lemma neq_in_in_remove A eq_A_dec (a a': A) l:
  a' <> a -> In a l -> In a (remove eq_A_dec a' l).

Lemma incl_remove_app A l l1 l2 (x : A) : ~ In x l -> incl l (l1 ++ x :: l2) -> incl l (l1 ++ l2).

Lemma flat_map_nil (A B: Type) (f: A -> list B) (xs: list A):
  (forall x, In x xs -> f x = []) ->
  flat_map f xs = [].

Lemma flat_map_comp (A B C : Type) (f : A -> B) (g : B -> list C) (h : A -> list C) (l : list A) :
  (forall x, In x l -> h x = g (f x)) -> flat_map h l = flat_map g (map f l).

Lemma flat_map_app (A B : Type) (f : A -> list B) l1 l2 :
  flat_map f (l1 ++ l2) = flat_map f l1 ++ flat_map f l2.

Lemma comp_flat_map (A B C : Type) (f : A -> list B) (g : B -> list C) h l :
  (forall a, In a l -> h a = flat_map g (f a)) -> flat_map h l = flat_map g (flat_map f l).

Fixpoint andl (l : list Prop) : Prop :=
  match l with
  | nil => True
  | P :: l' => P /\ andl l'
  end.

Lemma andl_cons: forall a l, andl (a::l) <-> a /\ (andl l).

Lemma andl_in : forall l P, andl l -> In P l -> P.

Lemma andl_in_map (A:Type): forall l (a:A) P, andl (map P l) -> In a l -> P a.

Lemma andl_map (A : Type) (f g : A -> Prop) l :
  andl (map f l) -> (forall a, In a l -> f a -> g a) -> andl (map g l).

Lemma andl_app l1 l2 : andl (l1 ++ l2) <-> andl l1 /\ andl l2.

Fixpoint orl (l : list Prop) : Prop :=
  match l with
  | nil => False
  | P :: l' => P \/ orl l'
  end.

Lemma andl_concat l:
  andl (concat l) <-> forall l', In l' l -> andl l'.

Lemma orl_map (A : Type) (P : A -> Prop) l : orl (map P l) <-> exists x, In x l /\ P x.

Section Maxl.
Fixpoint maxl (l : list nat) : nat :=
  match l with
  | nil => 0
  | n :: l' => max n (maxl l')
  end.

Lemma maxl_is_max :
  forall l n, In n l -> n <= maxl l.

Lemma all_max_le l y :
  (forall x, In x l -> x <= y) -> maxl l <= y.

Lemma maxl_app : forall (l1 l2 : list nat), maxl (l1 ++ l2) = max (maxl l1) (maxl l2).

Lemma in_maxl (l : list nat) : l<>nil -> In (maxl l) l.

Lemma all_maxl P xs: xs <> [] -> (forall x, In x xs -> P x) -> P (maxl xs).

Lemma maxl_le_maxl A f g (l : list A) :
(forall x, In x l -> f x <= g x) -> maxl (map f l) <= maxl (map g l).

Lemma maxl_map_const {A:Type} l (f: A → nat) n:
  (∀ x, x ∈ l → (f x) = n) →
  l ≠ [] → maxl (map f l) = n.

Lemma maxl_map_0 A l (f : A -> nat) : 
  (forall x, In x l -> (f x) = 0) ->
  maxl (map f l) = 0.

Lemma maxl_map_plus_le A f g (l : list A) :
  maxl (map (fun x => f x + g x) l) <= maxl (map f l) + maxl (map g l).

Lemma maxl_concat: forall l,
  maxl (concat l) = maxl (map maxl l).

Lemma maxl_map_lt_iff (A:Type): forall (l:list A) f n,
  0<n -> maxl (map f l) < n <-> (forall m, In m l -> (f m) < n).

Lemma maxl_map_le_iff (A:Type): forall (l:list A) f n,
  maxl (map f l) <= n <-> (forall m, In m l -> (f m) <= n).

Lemma maxl_map_is_max_map (A:Type): forall (l:list A) f a,
  In a l -> (f a) <= maxl (map f l).

Lemma maxl_eq_maxl {A:Type} f g (l:list A):
  (∀ x : A, x ∈ l → f x = g x) →
  maxl (map f l) = maxl (map g l).
End Maxl.

Lemma in_concat_iff (A:Type) x (l:list (list A)):
  x ∈ concat l <-> exists l', l' ∈ l /\ x ∈ l'.

Lemma incl_le_maxl :
  forall (l1 l2 : list nat), incl l1 l2 -> maxl l1 <= maxl l2.

Lemma maxl_cons : forall n l, maxl (n::l) = max n (maxl l).

Lemma forall2_le_maxl :
  forall (l1 l2 : list nat), Forall2 le l1 l2 -> maxl l1 <= maxl l2.

Lemma incl_flat_map (A B : Type) (f g : A -> list B) l :
  (forall a, In a l -> incl (f a) (g a)) ->
  incl (flat_map f l) (flat_map g l).

Section suml.

Fixpoint suml (l : list nat) : nat :=
  match l with
  | nil => 0
  | n :: l' => n + suml l'
  end.

Lemma suml_cons n l : suml (n :: l) = n + suml l.

Lemma suml_map_const A n (l : list A) : suml (map (fun _ => n) l) = n * length l.

Lemma mult_suml_r m l : m * suml l = suml (map (fun n => m * n) l).

Lemma suml_app l1 l2 : suml (l1 ++ l2) = suml l1 + suml l2.

Lemma suml_flat_map (A : Type)(f : A -> list nat)(l :list A) :
  suml (flat_map f l) = suml (map suml (map f l)).

Lemma suml_flat_map_map (A B : Type) (f : A -> list B) (g : B -> nat) l :
  suml (flat_map (fun x => map g (f x)) l) = suml (map (fun x => suml (map g (f x))) l).

Lemma suml_map_plus (A : Type)(f g : A -> nat)(l : list A) : suml (map (fun x => f x + g x) l) = suml (map f l) + suml (map g l).

Lemma suml_map_le :
  forall (A : Type)(f g : A -> nat)(l : list A),
  (forall x, In x l -> f x <= g x) -> suml (map f l) <= suml (map g l).

Lemma suml_map_eq :
  forall (A : Type)(f g : A -> nat)(l : list A),
  (forall x, In x l -> f x = g x) -> suml (map f l) = suml (map g l).

Lemma suml_map_le_plus_length :
  forall (A : Type)(f g : A -> nat)(l : list A),
  (forall x, In x l -> f x <= g x + 1) -> suml (map f l) <= suml (map g l) + length l.

Lemma suml_le_len_times_bound l b :
  (forall x, In x l -> x <= b) -> suml l <= length l * b.

Lemma in_le_suml :
  forall (n : nat)(l : list nat),
  In n l -> n <= suml l.

Lemma maxl_le_suml l: maxl l <= suml l.

Lemma forall2_le_suml :
  forall (l1 l2 : list nat), Forall2 le l1 l2 -> suml l1 <= suml l2.

Lemma maxl_le_suml_map (A B : Type) (f : A -> list B) (g : B -> nat) (h : A -> nat) (l : list A) :
  (forall a, In a l -> maxl (map g (f a)) <= h a) ->
  maxl (map g (flat_map f l)) <= suml (map h l).

Lemma suml_map_mult_le_suml_mult_maxl (A : Type) f g (l : list A) :
  suml (map (fun x => f x * g x) l) <= suml (map f l) * maxl (map g l).

Lemma suml_map_mult_le_suml_mult_suml (A : Type) f g (l : list A) :
  suml (map (fun x => f x * g x) l) <= suml (map f l) * suml (map g l).

Lemma length_flat_map (A B : Type) ( f : A -> list B) (l : list A) :
  length (flat_map f l) = suml (map (@length _) (map f l)).

Lemma seq_Succ n m : seq n (S m) = seq n m ++ [m + n].

Lemma Permutation_filter {A : Type} f (l : list A) : Permutation l (filter f l ++ filter (fun x => negb (f x)) l).

Lemma filter_compose {A : Type} f g (l : list A) : 
  (forall x, In x l -> ( f x = true -> g x = true)) ->
  filter f (filter g l) = filter f l.

Lemma in_seq : forall len start n : nat,
       In n (seq start len) <-> start <= n < start + len.

Lemma Permutation_partition_list_nat b n l :
 (forall x, In x l -> b <= x < b + n) ->
 Permutation l (flat_map (fun n => filter (beq_nat n) l) (seq b n)).

Lemma length_suml_filter b n l:
 (forall x, In x l -> b <= x < b + n) ->
 suml (map (fun r => length(filter (beq_nat r) l )) (seq b n)) = length l.

End suml.

Section prodl.

Fixpoint prodl (l : list nat) : nat :=
  match l with
  | nil => 1
  | n :: l' => n * prodl l'
  end.

Lemma prodl_bound (l : list nat) (b : nat) : 
  (forall x, In x l -> x <= b) -> prodl l <= Nat.pow b  (length l).

End prodl.

Definition clos_refl {A : Type} (R : A -> A -> Prop) (x y : A) : Prop :=
  R x y \/ x = y.

Lemma clos_refl_trans (A: Type) (R: A -> A -> Prop) t1 t2 t3:
    (R t1 t2 -> R t2 t3 -> R t1 t3) ->
    clos_refl R t1 t2 -> clos_refl R t2 t3 -> clos_refl R t1 t3.

Lemma Forall2_eq_clos_refl (A:Type) (R: A -> A -> Prop) (l1 :list A) :
  Forall2 (clos_refl R) l1 l1.

Lemma Forall_In_l (A : Type) (P : A -> Prop) x xs:
  Forall P xs -> In x xs -> P x.

Lemma Forall2_In_l (A B : Type) (R : A -> B -> Prop) x xs ys :
  Forall2 R xs ys -> In x xs -> exists y, In y ys /\ R x y.

Lemma Forall2_In_r (A B : Type) (R : A -> B -> Prop) y xs ys :
  Forall2 R xs ys -> In y ys -> exists x, In x xs /\ R x y.

Lemma Forall2_conj (A B : Type) (R1 R2 : A -> B -> Prop) xs ys :
  Forall2 R1 xs ys -> Forall2 R2 xs ys -> Forall2 (fun x y => R1 x y /\ R2 x y) xs ys.

Lemma Forall2_trans (A: Type) (R: A -> A -> Prop) xs ys zs :
    (forall x y z, In x xs -> In y ys -> In z zs -> R x y -> R y z -> R x z) ->
    Forall2 R xs ys -> Forall2 R ys zs -> Forall2 R xs zs.

Lemma Forall2_length A B (R : A -> B -> Prop) xs ys :
  Forall2 R xs ys -> length xs = length ys.

Lemma Forall2_map (A:Type) (B:Type): forall l f g (R:B->B->Prop),
  (forall (x:A), In x l -> R (f x) (g x)) -> Forall2 R (map f l) (map g l).

Lemma Forall2_flat_map (A B C D: Type) (R: C -> D -> Prop) (f: A -> list C) (g: B -> list D) (xs: list A) (ys: list B) :
  Forall2 (fun x y => Forall2 R (f x) (g y)) xs ys ->
  Forall2 R (flat_map f xs) (flat_map g ys).

Lemma Forall2_forall A (d: A) (R: A -> A -> Prop) (xs ys: list A) :
  Forall2 R xs ys ->
  forall i, i < length xs -> R (nth i xs d) (nth i ys d).

Inductive Exists2 {A B} (R: A -> B -> Prop) : list A -> list B -> Prop :=
 | Exists2_cons_hd : forall x xs y ys, R x y -> Exists2 R (x::xs) (y::ys)
 | Exists2_cons_tl : forall x xs y ys, Exists2 R xs ys -> Exists2 R (x::xs) (y::ys).
Hint Constructors Exists2.

Lemma Exists2_exists A (d: A) (R: A -> A -> Prop) (xs ys: list A) :
  Exists2 R xs ys ->
  exists i, i < length xs /\ R (nth i xs d) (nth i ys d).

Lemma app_eq_compat_l {A: Type} (xs ys zs: list A) : ys = zs -> xs ++ ys = xs ++ zs.

Lemma In_prefix_suffix (A : Type) (a : A) l :
  In a l -> exists l1 l2, l = l1 ++ a :: l2.

Lemma forall_exists_list (A B : Type) (P : A -> Prop) (Q : A -> B -> Prop) (l : list A) :
  (forall a, In a l -> P a -> exists b, Q a b) ->
  (Forall P l -> exists l', Forall2 Q l l').

Lemma forall_andl (A: Type) (P: A -> Prop) (l: list A):
  Forall P l <-> andl (map P l).

Fixpoint revflatten {A: Type} (xss: list (list A)) : list A :=
  match xss with
  | []       => []
  | xs::xss' => revflatten xss' ++ xs
  end.

Lemma Permutation_flat_map_ext A B  : forall l (f g : A -> list B),
  (forall x, In x l -> Permutation (f x) (g x)) -> Permutation (flat_map f l) (flat_map g l).

Lemma Permutation_revflatten A B (f : A -> list B) l : Permutation(revflatten (map f l)) (flat_map f l).

Lemma In_seq n start len : In n (seq start len) <-> start <= n < start+len.

Lemma seq_S start len : seq start (S len) = seq start len ++ [start + len].

Lemma plus_eq_compat_l x y1 y2 : y1 = y2 -> x + y1 = x + y2.

Lemma plus_eq_compat_r x1 x2 y : x1 = x2 -> x1 + y = x2 + y.

Section count_occ.

Lemma count_occ_remove_O A eq_dec (a: A) l :
  count_occ eq_dec (remove eq_dec a l) a = 0.

Lemma count_occ_remove_neq A eq_dec (a a': A) l :
  a<>a' -> count_occ eq_dec (remove eq_dec a' l) a = count_occ eq_dec l a.

Lemma suml_map_count_occ_remove A eq_dec (a: A) l1 l2 :
  ~In a l2 ->
  suml (map (count_occ eq_dec (remove eq_dec a l1)) l2) =
  suml (map (count_occ eq_dec l1) l2).

Lemma length_remove_count_occ A eq_dec (a: A) l:
  length l = length (remove eq_dec a l) + count_occ eq_dec l a.

Lemma in_remove_neq A eq_dec (a a': A) l :
  In a' (remove eq_dec a l) -> In a' l.

Lemma length_count_occ a b l :
  (forall n, In n l -> a <= n < a + b) ->
  length l = suml (map (count_occ eq_nat_dec l) (seq a b)).

Lemma count_occ_cons A eq_dec (a a': A) l :
  count_occ eq_dec (a::l) a' =
  if eq_dec a a' then S (count_occ eq_dec l a') else count_occ eq_dec l a'.

Lemma count_occ_app A eq_dec (a :A) l l' :
  count_occ eq_dec (l ++ l') a = count_occ eq_dec l a + count_occ eq_dec l' a.

Lemma count_occ_flat_map A B eq_B_dec (f: A -> list B) b l :
  count_occ eq_B_dec (flat_map f l) b =
  suml (map (fun a => count_occ eq_B_dec (f a) b) l).

End count_occ.

Lemma tl_incl (A:Type): forall (a:A) l l', incl (a::l') l -> incl l' l.

Section NoDup.

Lemma NoDup_app (A: Type) (l1 l2: list A):
  (forall x, In x l1 -> ~ In x l2) ->
  NoDup l1 ->
  NoDup l2 ->
  NoDup (l1 ++ l2).

Lemma NoDup_split (A: Type) (l1 l2: list A):
  NoDup (l1 ++ l2) ->
  NoDup l1.

Lemma NoDup_split_right : forall (A : Type) (l1 l2 : list A), NoDup (l1 ++ l2) -> NoDup l2.

Theorem NoDup_cons_iff {A:Type} (a: A) (l: list A):
  NoDup (a::l) <-> ~ In a l /\ NoDup l.

Lemma NoDup_app_in_l A l l' :
  NoDup (l ++ l') -> forall x : A, (In x l) -> ~ (In x l').

Lemma NoDup_Permutation_NoDup A l l' : @NoDup A l -> Permutation.Permutation l l' -> NoDup l'.

Lemma NoDup_incl_le_length (A: Type)
  (l1 l2: list A):
  NoDup l1 -> incl l1 l2 -> length l1 <= length l2.

Lemma NoDup_flat_map A B (f : A -> list B) l :
  (forall x, In x l -> NoDup (f x)) ->
  NoDup l ->
  (forall x y, In x l -> In y l -> x <> y -> (forall z, In z (f x) <-> ~ In z (f y))) ->
  NoDup (flat_map f l).

End NoDup.

Definition uniquify A (d : forall a b : A, { a = b} + { a <> b}) (l:list A) : list A :=
list_rect (fun _ : list A => list A) []
  (fun (a : A) (_ l' : list A) => let s := in_dec d a l' in if s then l' else a :: l') l.

Section pow.

Lemma lt_0_pow x n : 0 < x ->  0 < Nat.pow x n.

Lemma pow_le_compat x y n:
  x <= y -> Nat.pow x n <= Nat.pow y n.

End pow.

Lemma length_filter (A B : Type) (c : B -> bool) (f : A -> B) (xs : list A) :
  length (filter (fun x => c (f x)) xs) =
  length (filter c (map f xs)).

Section Sublist.

Inductive sublist (A : Type) : (list A) -> (list A) -> Prop :=
| sublist_refl : forall l, sublist l l
| sublist_skip : forall l1 h t, sublist l1 t -> sublist l1 (h :: t)
| sublist_cons : forall h t1 t2, sublist t1 t2 -> sublist (h :: t1) (h :: t2).

Hint Constructors sublist.

Lemma sublist_nil A (l : list A) : sublist [] l.

Lemma sublist_incl A (l1 l2 : list A) : sublist l1 l2 -> incl l1 l2.

Lemma sublist_app_skip A (l1 l2 l3 : list A) : sublist l1 l3 -> sublist l1 (l2 ++ l3).

Lemma sublist_app_left A (l1 l2 l3 : list A) : sublist l1 l3 -> sublist (l2 ++ l1) (l2 ++ l3).

Lemma sublist_app_compat A (l1 l2 l3 l4 : list A) :
  sublist l1 l3 -> 
  sublist l2 l4 ->
  sublist (l1 ++ l2) (l3 ++ l4).

Lemma sublist_flatmap_in_ext A B (f : A -> list B) g l: 
  (forall x : A , In x l -> sublist (f x) (g x)) ->
  sublist (flat_map f l) (flat_map g l).

Lemma NoDup_sublist A (l1 l2 : list A) : sublist l1 l2 -> NoDup l2 -> NoDup l1.

End Sublist.

Section Compat.

Lemma NoDup_map_inv A B (f:A->B) l : NoDup (map f l) -> NoDup l.

End Compat.

Lemma In_In_list_decompose {A} (x y : A) l : In x l -> In y l ->
  x = y \/
  exists l1 l2 l3, (l = l1 ++ x :: l2 ++ y :: l3) \/ (l = l1 ++ y :: l2 ++ x :: l3).

Section Lexicographic_Product.

Variables A B : Type.

Variable ltA : A -> A -> Prop.

Variable ltB : B -> B -> Prop.

Hypothesis wf_ltA : well_founded ltA.

Hypothesis wf_ltB : well_founded ltB.

Inductive lexprod : A*B -> A*B -> Prop :=
| lex_l : forall a a' b b', ltA a a' -> lexprod (a, b) (a', b')
| lex_r : forall a    b b', ltB b b' -> lexprod (a, b) (a,  b').

Lemma acc_lex a b : Acc ltA a -> Acc ltB b -> Acc lexprod (a, b).

Lemma lexprod_trans :
  (forall a1 a2 a3, ltA a1 a2 -> ltA a2 a3 -> ltA a1 a3) ->
  (forall b1 b2 b3, ltB b1 b2 -> ltB b2 b3 -> ltB b1 b3) ->
  forall x1 x2 x3, lexprod x1 x2 -> lexprod x2 x3 -> lexprod x1 x3.

Lemma wf_lexprod : well_founded lexprod.

Definition lex_prod_dec: 
  (forall a1 a2 : A, {a1 = a2} + {a1 <> a2}) ->
  (forall a1 a2, {ltA a1 a2} + {~ltA a1 a2}) ->
  (forall b1 b2, {ltB b1 b2} + {~ltB b1 b2}) ->
  (forall x y, {lexprod x y} + {~ lexprod x y}).

End Lexicographic_Product.

Section Last.

Lemma non_empty_last (A:Type) d d' (l:list A):
  l <> [] -> (last l d) = (last l d').

Lemma cons_cons_last (A:Type) (a b:A) l x:
  last (a::b::l) x = last (b::l) x.

Lemma cons_last (A:Type) (a:A) l x:
  last (a::l) x = last l a.

Lemma last_in (A:Type) (l:list A) x:
  (last l x = x) \/ (In (last l x) l).

End Last.

Lemma beq_eq_dec {A : Type} {beq : A -> A -> bool} (Hbeq : forall x y, beq x y = true <-> x = y) : forall (x y : A), {x = y} + {~ x = y}.

Section Firstn_skipn.
Lemma firstn_map {A B : Type} (f : A -> B) l n : 
  firstn n (map f l) = map f (firstn n l).

Lemma skipn_map {A B : Type} (f : A -> B) l n : 
  skipn n (map f l) = map f (skipn n l).

Lemma skipn_app_length {A : Type} (l1 l2 : list A) : skipn (length l1) (l1 ++ l2) = l2.

Lemma firstn_app_length {A : Type} (l1 l2 : list A) : firstn (length l1) (l1 ++ l2) = l1.

Lemma skipn_nil : forall {A} n (x : list A),
  length x <= n -> skipn n x = nil.

Lemma firstn_seq n start len :
  firstn n (seq start len) = seq start (min n len).

Lemma skipn_seq n start len :
  skipn n (seq start len) = seq (start+n) (len-n).

Lemma skipn_firstn {A:Type} n (l:list A):
  skipn n (firstn n l) = [].

Lemma skipn_incl {A:Type} (l:list A) n:
  incl (skipn n l) l.

Lemma skipn_app2 {A : Type} (l l' : list A) n:
  length l = n → skipn n (l ++ l') = l'.

Lemma firstn_app {A} (l l' : list A) : 
  firstn (length l) (l ++ l') = l.

Lemma firstn_app2 : forall (A : Type) (l l' : list A) n, 
 length l = n -> firstn n (l ++ l') = l .
End Firstn_skipn.

Section Ints.
Definition ints (n m:nat):list nat := seq n (m-n). 
Lemma ints_bounded : ∀ (x n m:nat),
  n ≤ m → x ∈ (ints n m) → n ≤ x < m.

Lemma ints_bounds : ∀ (x n m:nat),
  n ≤ x < m → x ∈ (ints n m).

Lemma ints_bounds_iff: ∀ x n m,
  n ≤ m → (n ≤ x < m ↔ x ∈ (ints n m)).

Lemma ints_length : ∀ n m,
  n ≤ m → length (ints n m) = m-n.
End Ints.

Section Forall.
Lemma Forall_cons_iff {A:Type} (x:A) (xs:list A) (P:A→Prop):
  Forall P (x::xs) ↔ P x ∧ Forall P xs.
Lemma Forall_map_iff {A B:Type} (f: A → B) l (P: B → Prop):
  (∀ x, x ∈ l → P (f x)) ↔ Forall P (map f l).
Lemma Forall_app_iff {A:Type} (P:A→Prop) l1 l2:
  Forall P (l1++l2) ↔ Forall P l1 ∧ Forall P l2.

Lemma Forall_unary {A:Type} (P:A→Prop) a:
  Forall P [a] ↔ P a.

Lemma Forall_flat_map {A B:Type} (P:B → Prop) (f:A → list B) l:
  Forall P (flat_map f l) ↔ Forall (λ x, Forall P (f x)) l.
End Forall.

Section Concat.
Lemma concat_unary_is_map {A B:Type}: ∀ l (f:A→B),
  concat (map (λ x, [f x]) l) = map f l.
Lemma in_concat_const_is_in {A B:Type} (a:A) lfix l:
  a ∈ concat (map (λ _ : B, lfix) l) ↔ l ≠ [] ∧ a ∈ lfix.
End Concat.

Section Incl.
Lemma incl_nil {A:Type} (l:list A): incl [] l.

Lemma incl_map_flat_map {A B:Type} (xs:list A) (f:A → B) g:
  (∀ x : A, x ∈ xs → f x ∈ g x) →
  incl (map f xs) (flat_map g xs).

Lemma incl_flat_map_incl {A B C:Type} (xs:list A) (r:A→list B) (rh:B→list C) lh:
  (∀ x : A, x ∈ xs → incl (flat_map rh (r x)) (lh x)) →
  incl (flat_map rh (concat (map r xs))) (flat_map lh xs).
End Incl.

Section Append.
Lemma app_length_eq {A:Type}:
  ∀ (l1 l2 l1' l2': list A),
  length l1 = length l1' → (l1++l2) = (l1'++l2') →
  l1 = l1' ∧ l2 = l2'.
End Append.

Section Forall2.
Lemma Forall2_le_refl l: Forall2 le l l.

Lemma Forall2_app_inv {A B:Type} (P:A→B→Prop) la1 la2 lb1 lb2:
  length la1 = length lb1 → Forall2 P (la1++la2) (lb1++lb2) →
  Forall2 P la1 lb1 ∧ Forall2 P la2 lb2.

Lemma Forall2_firstn {A B:Type} (P:A→B→Prop) la lb n:
  Forall2 P la lb → Forall2 P (firstn n la) (firstn n lb).

Lemma Forall2_skipn {A B:Type} (P:A→B→Prop) la lb n:
  Forall2 P la lb → Forall2 P (skipn n la) (skipn n lb).

Lemma Forall2_firstn_skipn_iff {A B:Type} (P:A→B→Prop) la lb n:
  Forall2 P la lb ↔ Forall2 P (firstn n la) (firstn n lb) ∧ Forall2 P (skipn n la) (skipn n lb).

Lemma Forall2_tail {A B:Type} (P:A→B→Prop) la lb:
  Forall2 P la lb → Forall2 P (tl la) (tl lb).
End Forall2. *)
(* Cecoa.Interface:
Require Import List.
Require Cecoa.Syntax Cecoa.Program Cecoa.CBV_cache Cecoa.Ordering Cecoa.QI Cecoa.Final Cecoa.Evaluates.

Module Type SYNTAX.
  Parameters variable function constructor : Type.

  Parameter function_default : function.
  Parameter constructor_default : constructor.

  Parameter variable_eq_dec : forall (x1 x2 : variable), {x1=x2}+{x1<>x2}.
  Parameter function_eq_dec : forall (x1 x2 : function), {x1=x2}+{x1<>x2}.
  Parameter constructor_eq_dec : forall (x1 x2 : constructor), {x1=x2}+{x1<>x2}.
End SYNTAX.

Module MkSyn (S: SYNTAX).
  Definition value := Syntax.value S.constructor.
  Definition term := Syntax.term S.variable S.function S.constructor.
  Definition pattern := Syntax.pattern S.variable S.constructor.
  Definition rule := Syntax.rule S.variable S.function S.constructor.

  Definition var : S.variable -> term := @Syntax.var _ _ _.
  Definition capply : S.constructor -> list term -> term := @Syntax.capply _ _ _.
  Definition fapply : S.function -> list term -> term := @Syntax.fapply _ _ _.

  Definition c_capply : S.constructor -> list value -> value := @Syntax.c_capply _.

  Definition value_default : value := c_capply S.constructor_default nil.
  Definition rule_default : rule :=
    Syntax.rule_intro S.function_default nil (capply S.constructor_default nil).

  Definition term_from_value : value -> term :=
    @Syntax.term_from_value S.variable S.function S.constructor.
  Definition term_from_pattern : pattern -> term :=
    @Syntax.term_from_pattern S.variable S.function S.constructor.

  Definition cbv : Type := CBV_cache.cbv S.variable S.function S.constructor.
  Definition cache : Type := list (term * value).
  Definition cbv_constr : list cbv -> cache -> term -> cache -> value -> cbv :=
    @CBV_cache.cbv_constr S.variable S.function S.constructor.
  Definition cbv_split : list cbv -> cbv -> cache -> term -> cache -> value -> cbv :=
    @CBV_cache.cbv_split S.variable S.function S.constructor.
  Definition cbv_update : nat -> (S.variable -> value) -> cbv -> cache -> term -> cache -> value -> cbv :=
    @CBV_cache.cbv_update S.variable S.function S.constructor.
  Definition cbv_read : cache -> term -> value -> cbv :=
    @CBV_cache.cbv_read S.variable S.function S.constructor.

  Definition cbv_size : cbv -> nat := @CBV_cache.size S.variable S.function S.constructor.

  Definition proj_left : cbv -> term :=
    @CBV_cache.proj_left S.variable S.function S.constructor.
  Definition proj_right : cbv -> value :=
    @CBV_cache.proj_right S.variable S.function S.constructor.

  Module Type PROGRAM.
    Parameter prog : list rule.
  End PROGRAM.

  Module MkProg (P: PROGRAM).
    Definition ranklist := Program.ranklist S.variable S.function S.constructor S.function_eq_dec P.prog.
    Definition max_rank : nat := Program.max_rank S.variable S.function S.constructor S.function_eq_dec P.prog.
    Ltac autorank := TopologicalSort.autorank.

    Definition max_arity : nat := Program.max_arity_prog S.variable S.function S.constructor P.prog.
    Definition wf_prog : Prop := Program.wf_prog S.variable S.function S.constructor P.prog.

    Definition cbv_wf : cbv -> Prop :=
      CBV_cache.wf
        S.variable_eq_dec S.function_eq_dec S.constructor_eq_dec
        rule_default P.prog max_arity.

    Definition PPO_prog (rank: S.function -> nat) : Prop := Ordering.PPO_prog P.prog rank.
    Ltac ppo := Ordering.ppo S.variable_eq_dec S.function_eq_dec S.constructor_eq_dec.

    Module QI.
      Definition constructor_non_zero := @QI.constructor_non_zero S.constructor.
      Definition mcs_is_max_constructor_size := @QI.mcs_is_max_constructor_size S.constructor.
      Definition additive := @QI.additive S.constructor.
      Definition subterm := @QI.subterm S.function.
      Definition monotonicity_qic := @QI.monotonicity_qic S.constructor.
      Definition monotonicity_qif := @QI.monotonicity_qif S.function.
      Definition cache_bounded :=
        @QI.cache_bounded S.variable S.function S.constructor.
      Definition compatible_QI :=
        @QI.compatible_QI S.variable S.function S.constructor P.prog.
      Definition term_assignment :=
        @QI.term_assignment S.variable S.function S.constructor.
      Definition valid_QI :=
        @QI.valid_QI S.variable S.function S.constructor P.prog.
      Definition global_bound :=
        Final.global_bound S.variable S.function S.constructor P.prog max_arity max_rank.
      Definition P_criterion wf_prog rank :=
        Final.P_criterion S.variable S.function S.constructor P.prog max_arity rule_default wf_prog
                          S.variable_eq_dec S.function_eq_dec S.constructor_eq_dec rank max_rank.
    End QI.

    Module Evaluator.
      Definition first_rule := Evaluates.first_rule S.variable_eq_dec S.function_eq_dec S.constructor_eq_dec value_default P.prog.
      Definition evaluates := Evaluates.evaluates S.variable_eq_dec S.function_eq_dec S.constructor_eq_dec value_default P.prog.
      Ltac reduce := Evaluates.reduce.
      Ltac auto_for_auto lemma :=
        let t' := type of lemma in
        let t := eval unfold evaluates in t' in
            exact t.
      Hint Unfold evaluates : eval.
    End Evaluator.
  End MkProg.

  Module ProgramNotations.
    Fixpoint patternify (t: term) : pattern :=
      match t with
      | Syntax.var v         => Syntax.p_var v
      | Syntax.capply cst ys => Syntax.p_capply cst (map patternify ys)
      | _                    => Syntax.p_capply S.constructor_default nil
      end.

    Definition rulify (t e: term) : rule :=
      match t with
        | Syntax.fapply f ys => Syntax.rule_intro f (map patternify ys) e
        | _                  => Syntax.rule_intro S.function_default nil (Syntax.capply S.constructor_default nil)
      end.

    Notation " f '(:' ':)' " := (Syntax.fapply f (@nil term)) (at level 65).
    Notation " f '(:' x ':)' " := (Syntax.fapply f (@cons term x nil)) (at level 65).
    Notation " f '(:' x ',' .. ',' z ':)' " := (Syntax.fapply f (@cons term x .. (@cons term z nil) .. )) (at level 65).
    Notation "fl '-->' e" := (rulify fl e) (at level 70).

    Definition var_coercion_gen : S.variable -> term := @Syntax.var _ _ _.
  End ProgramNotations.
End MkSyn. *)



Inductive variable := x | y | p | q | x0 | m | c | n' | m' | r | r'.

Inductive function := pred_doubleF | succ_double_maskF | double_maskF | double_pred_maskF | sub_maskF | sub_mask_carryF | compare_contEqF | compare_contGtF | compare_contLtF | compareF | succ_doubleF | doubleF | subF | compare0F | lebF | moduloF | errF | sub_auxF | leb_auxF | pos_moduloOF | pos_moduloIF | pos_moduloF | condF | succF | addF | add_carryF | add0F | mul_modF | mul_mod_auxF | exp_modF | exp_mod_auxF | mod_auxF | modF | boundF.

Inductive constructor := TrueC | FalseC | PairC | EqC | LtC | GtC | XIC | XOC | XHC | N0C | NposC | IsNulC | IsPosC | IsNegC | errC.



Scheme Equality for variable.

Scheme Equality for constructor.

Scheme Equality for function.



Module EMSyntax <: Interface.SYNTAX.

  Definition variable := variable.

  Definition function := function.

  Definition constructor := constructor.



  Definition function_default := errF.

  Definition constructor_default := errC.



  Definition variable_eq_dec := variable_eq_dec.

  Definition function_eq_dec := function_eq_dec.

  Definition constructor_eq_dec := constructor_eq_dec.

End EMSyntax.



Module Import Syn := Interface.MkSyn(EMSyntax).

Import Syn.ProgramNotations.



Definition var_coercion : variable -> term := var_coercion_gen.

Coercion var_coercion : variable >-> term.

Notation " x '#' l " := (capply x (map var_coercion l)) (at level 50).



Notation "'XO' a" := (capply XOC [var_coercion a]) (at level 60).

Notation "'XI' a" := (capply XIC [var_coercion a]) (at level 60).

Notation "'Ispos' a" := (capply IsPosC [var_coercion a]) (at level 60).

Notation "'NPos' a" := (capply NposC [var_coercion a]) (at level 60).

Notation "'XH'" := (capply XHC []) (at level 60).

Notation "'Isnul'" := (capply IsNulC []) (at level 60).

Notation "'Isneg'" := (capply IsNegC []) (at level 60).

Notation "'GT'" := (capply GtC []) (at level 60).

Notation "'LT'" := (capply LtC []) (at level 60).

Notation "'EQ'" := (capply EqC []) (at level 60).

Notation "'N0'" := (capply N0C []) (at level 60).

Notation "'TRUE'" := (capply TrueC []) (at level 60).

Notation "'FALSE'" := (capply FalseC []) (at level 60).



Definition em_prog : list rule := [

pred_doubleF (: XI p :) --> capply XIC [XO p];

pred_doubleF (: XO p :) --> capply XIC [pred_doubleF (: p :)];

pred_doubleF (: XH :) --> XH;



succ_double_maskF (: Isnul :) --> capply IsPosC [XH];

succ_double_maskF (: Ispos p :)  --> capply IsPosC [XI p];

succ_double_maskF (: Isneg :) --> Isneg;



double_maskF (: Ispos p :) --> capply IsPosC [XO p];

double_maskF (: x0 :) --> x0;



double_pred_maskF (: XI p :) --> 

  capply IsPosC [capply XOC [XO p]];

double_pred_maskF (: XO p :) --> 

  capply IsPosC [capply XOC [pred_doubleF (: p :)]];

double_pred_maskF (: XH :) --> Isnul;



sub_maskF (: XI p, XI q :) --> double_maskF (: sub_maskF (: p, q :) :);

sub_maskF (: XI p, XO q :) --> succ_double_maskF (: sub_maskF (: p, q :) :);

sub_maskF (: XI p, XH :) --> capply IsPosC [XO p];



sub_maskF (: XO p, XI q :) --> 

  succ_double_maskF (: sub_mask_carryF (: p, q :) :);

sub_maskF (: XO p, XO q :) --> double_maskF (: sub_maskF (: p, q :) :);

sub_maskF (: XO p, XH :) --> capply IsPosC [pred_doubleF (: p :)];

sub_maskF (: XH, XH :) --> Isnul;

sub_maskF (: XH, q :) --> Isneg;



sub_mask_carryF (: XI p, XI q :) --> 

  succ_double_maskF (: sub_mask_carryF (: p, q :) :);

sub_mask_carryF (: XI p, XO q :) --> 

  double_maskF (: sub_maskF (: p, q :) :);

sub_mask_carryF (: XI p, XH :) --> capply IsPosC [pred_doubleF (: p :)];

sub_mask_carryF (: XO p, XI q :) --> 

  double_maskF (: sub_mask_carryF (: p, q :) :);

sub_mask_carryF (: XO p, XO q :) --> 

  succ_double_maskF (: sub_mask_carryF (: p, q :) :);

sub_mask_carryF (: XO p, XH :) --> double_pred_maskF (: p :);

sub_mask_carryF (: XH, q :) --> Isneg;



compare_contEqF (: XI p, XI q :) --> compare_contEqF (: p, q :);

compare_contEqF (: XI p, XO q :) --> compare_contGtF (: p, q :);

compare_contEqF (: XI p, XH :) --> GT;

compare_contEqF (: XO p, XI q :) --> compare_contLtF (: p, q :);

compare_contEqF (: XO p, XO q :) --> compare_contEqF (: p, q :);

compare_contEqF (: XO p, XH :) --> GT;

compare_contEqF (: XH, XH :) --> EQ;

compare_contEqF (: XH, q :) --> LT;



compare_contLtF (: XI p, XI q :) --> compare_contLtF (: p, q :);

compare_contLtF (: XI p, XO q :) --> compare_contGtF (: p, q :);

compare_contLtF (: XI p, XH :) --> GT;

compare_contLtF (: XO p, XI q :) --> compare_contLtF (: p, q :);

compare_contLtF (: XO p, XO q :) --> compare_contLtF (: p, q :);

compare_contLtF (: XO p, XH :) --> GT;

compare_contLtF (: XH, XH :) --> LT;

compare_contLtF (: XH, q :) --> LT;



compare_contGtF (: XI p, XI q :) --> compare_contGtF (: p, q :);

compare_contGtF (: XI p, XO q :) --> compare_contGtF (: p, q :);

compare_contGtF (: XI p, XH :) --> GT;

compare_contGtF (: XO p, XI q :) --> compare_contLtF (: p, q :);

compare_contGtF (: XO p, XO q :) --> compare_contGtF (: p, q :);

compare_contGtF (: XO p, XH :) --> GT;

compare_contGtF (: XH, XH :) --> GT;

compare_contGtF (: XH, q :) --> LT;



compareF (: p, q :) -->  compare_contEqF (: p, q :);



succ_doubleF (: N0 :) --> capply NposC [XH];

succ_doubleF (: NPos p :) --> capply NposC [XI p];



doubleF (: N0 :) --> N0;

doubleF (: NPos p :) --> capply NposC [XO p];



sub_auxF (: Ispos p :) --> NPos p;

sub_auxF (: p :) --> N0;



subF (: N0, m :) --> N0;

subF (: NPos p, N0 :) --> NPos p;

subF (: NPos p, NPos q :) --> sub_auxF (: sub_maskF (: p, q :) :);



compare0F (: N0, N0 :) --> EQ;

compare0F (: N0, NPos q :) --> LT;

compare0F (: NPos n', N0 :) --> GT;

compare0F (: NPos n', NPos m' :) --> compareF (: n', m' :);



leb_auxF (: GT :) --> FALSE;

leb_auxF (: q :) --> TRUE;



lebF (:x, y :) --> leb_auxF (: compare0F (: x, y :) :);



condF (: TRUE, x, y :) --> x;

condF (: FALSE, x, y :) --> y;



mod_auxF (: XH, capply NposC [XH] :) --> N0 ;

mod_auxF (: XH, m :) --> capply NposC [XH] ;

mod_auxF (: XO x, m :) --> 

  condF (: lebF (: m, doubleF (: mod_auxF (: x, m :) :) :), 

           subF (: doubleF (: mod_auxF (: x, m :) :), m :),

           doubleF (: mod_auxF (: x, m :) :) :) ;

mod_auxF (: XI x, m :) --> 

  condF (: lebF (: m, succ_doubleF (: mod_auxF (: x, m :) :) :), 

           subF (: succ_doubleF (: mod_auxF (: x, m :):), m :),

           succ_doubleF (: mod_auxF (: x, m :) :) :) ;



modF (: N0, m :) --> N0;

modF (: NPos x, m :) --> mod_auxF (: x, m :);



succF (: XI p :) --> capply XOC [succF (: p :)];

succF (: XO p :) --> XI p;

succF (: XH :) --> capply XOC [XH];



addF (: XI p, XI q :) --> capply XOC [add_carryF (: p, q :)];

addF (: XI p, XO q :) --> capply XIC [addF (: p, q :)];

addF (: XI p, XH :) --> capply XOC [succF (: p :)];

addF (: XO p, XI q :) --> capply XIC [addF (: p, q :)];

addF (: XO p, XO q :) --> capply XOC [addF (: p, q :)];

addF (: XO p, XH :) --> XI p;

addF (: XH, XI q :) --> capply XOC [succF (: q :)];

addF (: XH, XO q :) --> XI q;

addF (: XH, XH :) --> capply XOC [XH];



add_carryF (: XI p, XI q :) --> capply XIC [add_carryF (: p, q :)];

add_carryF (: XI p, XO q :) --> capply XOC [add_carryF (: p, q :)];

add_carryF (: XI p, XH :) --> capply XIC [succF (: p :)];

add_carryF (: XO p, XI q :) --> capply XOC [add_carryF (: p, q :)];

add_carryF (: XO p, XO q :) --> capply XIC [addF (: p, q :)];

add_carryF (: XO p, XH :) --> capply XOC [succF (: p :)];

add_carryF (: XH, XI q :) --> capply XIC [succF (: q :)];

add_carryF (: XH, XO q :) --> capply XOC [succF (: q :)];

add_carryF (: XH, XH :) --> capply XIC [XH];



add0F (: N0, m :) --> m;

add0F (: NPos p, N0 :) --> NPos p;

add0F (: NPos p, NPos q :)--> capply NposC [addF (: p, q :)];



mul_mod_auxF (: XI p, y, m, XO x :) --> 

  modF (: add0F (: y, doubleF (: mul_mod_auxF (: p, y, m, x :) :):), m :);

mul_mod_auxF (: XO p, y, m, XO x :) --> 

  modF (: doubleF (: mul_mod_auxF (: p, y, m, x :) :), m :);

mul_mod_auxF (: XH, y, m, x :) --> modF (: y, m :);



mul_modF (: N0, y, m, p :) --> N0;

mul_modF (: NPos x , y, m, p :) --> mul_mod_auxF (: x, y, m, p :);



exp_mod_auxF (: x, XH, m, p :) --> modF (: x, m :);

exp_mod_auxF (: x, XO y, m, p :) -->

  mul_modF (: exp_mod_auxF (: x, y, m, p :), exp_mod_auxF (: x, y, m, p :), m, p :) ;

exp_mod_auxF (: x, XI y, m, p :) -->

  mul_modF (: modF (: x, m :), mul_modF (: exp_mod_auxF (: x, y, m, p :), exp_mod_auxF (: x, y, m, p :), m, p :), m, p :);



boundF (: N0 :) --> XH;

boundF (: NPos p :) --> boundF (: p :);

boundF (: XH :) --> capply XOC [XH];

boundF (: XI x :) --> capply XOC [boundF (: x :)];

boundF (: XO x :) --> capply XOC [boundF (: x :)];



exp_modF (: x, N0 , m :) --> modF(: capply NposC [XH], m :) ;

exp_modF (: x, NPos y, m :) --> exp_mod_auxF (: x, y, m, boundF (: m :) :)

].



Module EMProg <: Syn.PROGRAM.

  Definition prog := em_prog.

End EMProg.



Module Import Prog := Syn.MkProg (EMProg).

Import Prog.QI Prog.Evaluator.



Definition rank : function -> nat := ltac:(autorank function_beq ranklist).



Proposition Expmod_is_wf: wf_prog.

Proof. cbv; repeat split; try tauto; auto. Qed.



Proposition expmod_is_ppo : PPO_prog rank.

Proof.

  cbv.

  intros r H.

  decompose sum H; subst; ppo.

Qed.



Definition cs (c : constructor) := 1%nat. 



Lemma qic_nonzero : constructor_non_zero cs.

Proof. cbv; auto. Qed.



Definition mcs := 1.

Lemma qic_bounded : mcs_is_max_constructor_size mcs cs.

Proof. cbv; auto. Qed.



Definition qic (c : constructor) args := suml args + cs c.



Lemma qic_additivity : additive qic cs.

Proof. cbv; auto. Qed.



Lemma cons_app {A : Type}  (h: A) t: h::t = [h] ++t.

Proof. trivial. Qed.



Ltac try_prove_ineq := 

unfold qic, cs;

try tauto; intros; subst; cbn; try omega;

repeat rewrite Nat.add_0_r; repeat rewrite Nat.max_0_r; 

repeat rewrite Nat.add_max_distr_r; repeat rewrite Nat.add_1_r;

repeat rewrite Nat.max_id, Max.max_r;

try (solve [simpl; auto with *]);

try (nia); repeat (case QI.value_assignment); auto with *.



Ltac prove_rule H :=

  rewrite cons_app; apply QI.p_smc_QI_app;

  [ intros f lp t s; cbn; intro H;

    repeat (destruct H as [ H | H ];

      [inversion H; subst; unfold map; simpl; 

       repeat rewrite QI.value_as_p_term_assignment;

        eexists; eexists; repeat split; repeat try_prove_ineq| ]); inversion H

  |].



Definition spec_QI (f : function) (qf : list nat -> nat) :=

 fun g => if function_beq g f then Some qf else None.



Ltac inst f qi := idtac "instantiating" f; apply QI.p_smc_split with (h := spec_QI f qi).



Ltac inst_next qi :=

match goal with 

| |- context[rulify (Syntax.fapply ?ff _) _ ::_] => 

    (idtac "instantiating" ff;

    apply QI.p_smc_split with (h := spec_QI ff qi))

end.



Ltac qif_monotonic_tac :=

  repeat (apply forall2_le_suml || apply forall2_le_maxl ||

          apply Plus.plus_le_compat_r || apply Plus.plus_le_compat_l || apply Plus.plus_le_compat ||

          apply Nat.max_le_compat_r || apply Nat.max_le_compat_l || apply Nat.max_le_compat ||

          apply Mult.mult_le_compat_l || apply Mult.mult_le_compat_r || apply Mult.mult_le_compat

         ); trivial.



Definition qif_proofs : {qif | subterm qif /\ monotonicity_qif qif /\ compatible_QI qic qif}.

Proof.



apply QI.p_smc_smc.

unfold EMProg.prog, em_prog.



inst_next (fun x => maxl x + 1). do 3 (prove_rule H).



inst_next (fun x => maxl x + 1).

inst double_maskF (fun x => maxl x + 1).

do 5 (prove_rule H).



inst_next (fun x => maxl x + 2).

inst sub_maskF (fun x => maxl x + 1).

inst sub_mask_carryF (fun x => maxl x + 1).

do 18 (prove_rule H).



inst_next maxl.

inst compare_contLtF maxl.

inst compare_contGtF maxl.

inst compareF maxl.

do 25 (prove_rule H).



inst_next (fun l => maxl l + 1).

inst doubleF (fun l => maxl l + 1).

do 4 (prove_rule H).



inst_next (fun l => maxl l). prove_rule H.



rewrite cons_app. apply QI.p_smc_QI_app.

{ intros f lp t s. cbn. intro H.

  destruct H; try tauto. inversion H.

  subst. unfold map. simpl.

  rewrite QI.value_as_p_term_assignment. simpl.

  eexists. eexists. repeat split; auto.

  rewrite Nat.max_0_r.

  unfold qic at 1. simpl. unfold cs.

  apply le_trans with (m:=Syntax.value_size (s p)).

  - rewrite <- Syntax.compatible_sizes with (variable:=variable) (function:=function).

    set (v:=Syntax.term_from_value variable function (s p)).

    generalize (Syntax.gt_term_size_O v). intro. omega.

  - apply QI.value_size_le_QI with (cs:=cs).

    + apply qic_additivity.

    + apply qic_nonzero.

}

inst_next (fun l => maxl l).

do 3 (prove_rule H).



inst_next maxl. do 4 (prove_rule H).



inst_next (fun l => maxl l). prove_rule H.



rewrite cons_app. apply QI.p_smc_QI_app.

{ intros f lp t s. cbn. intro H.

  destruct H; try tauto. inversion H.

  subst. unfold map. simpl.

  rewrite QI.value_as_p_term_assignment. simpl.

  eexists. eexists. repeat split; auto.

  rewrite Nat.max_0_r.

  unfold qic at 1. simpl. unfold cs.

  apply le_trans with (m:=Syntax.value_size (s q)).

  - rewrite <- Syntax.compatible_sizes with (variable:=variable) (function:=function).

    set (v:=Syntax.term_from_value variable function (s q)).

    generalize (Syntax.gt_term_size_O v). intro. omega.

  - apply QI.value_size_le_QI with (cs:=cs).

    + apply qic_additivity.

    + apply qic_nonzero.

}



inst_next maxl. prove_rule H.



inst_next maxl. do 2 (prove_rule H).



inst_next (fun l => suml l + 1). do 4 (prove_rule H).

inst_next (fun l => suml l + 1). do 2 (prove_rule H).



inst_next (fun l => maxl l + 1); do 3 (prove_rule H).

inst add_carryF (fun l => maxl l + 1).

inst_next (fun l => maxl l + 1). do 18 (prove_rule H).



inst_next (fun l => maxl l + 1); do 3 (prove_rule H).



inst_next (fun l => match l with [p1;y1;m1;c1] => (m1+3) * (c1+1) + max p1 y1 | _ => maxl l end).

do 3 (prove_rule H).



inst_next (fun l => match l with [p1;y1;m1;c1] => (m1+3) * (c1+1) + max p1 y1 | _ => maxl l end).

do 2 (prove_rule H).



inst_next (fun l => match l with [x1;y1;m1;c1] => 

  x1 + (y1 + 1) * 2 * (m1+3) * (c1+1) | _ => maxl l end).

do 3 (prove_rule H).



inst_next (fun l => maxl l +1).

do 5 (prove_rule H).



inst_next (fun l => match l with [x1;y1;m1] => 

  x1 + (y1+1) * 2 * (m1+3) * (m1+2) | _ => maxl l end).

do 2 (prove_rule H).



eexists (fun x => None).

unfold QI.p_smc, QI.p_compatible_QI, QI.p_subterm, QI.p_monotonicity.

repeat split.



- intros f l x Hin; assert(H' := maxl_is_max _ _ Hin); 

    assert (H'' := maxl_le_suml l); destruct f; simpl; trivial;

  try omega;

  (repeat (destruct l; trivial);

   repeat(destruct Hin as [ H | Hin]; [subst; simpl; try_prove_ineq |]);

   try inversion Hin).

   simpl; nia.



- intros f xs ys Hfor.

  destruct f; qif_monotonic_tac;

  repeat (destruct Hfor; simpl; try qif_monotonic_tac).

- simpl; tauto.

Defined.



Definition qif := proj1_sig qif_proofs.



Proposition qi_is_valid : valid_QI mcs qic qif cs.

Proof.

unfold qif.

destruct qif_proofs as (qif & Hs & Hm & Hc).

repeat split; trivial.

apply qic_bounded.

apply qic_nonzero.

Qed.



Theorem polytime: forall i s p c f lv d v,

  let t := fapply f lv in

  let pi := cbv_update i s p c t d v in

  cbv_wf pi -> cache_bounded qic qif c ->

  cbv_size pi <= global_bound mcs qif f lv c.

Proof.

intros.

apply P_criterion with (rank:=rank) (cs:=cs) (qic:=qic); auto.

- split; [ apply Expmod_is_wf | trivial ].

- cbv; omega.

- intros f0; destruct f0; cbv; omega.

- apply expmod_is_ppo.

- apply qi_is_valid.

Qed.



Fixpoint Pos_of_value (v : value) : positive := match v with

| Syntax.c_capply XHC [] => xH

| Syntax.c_capply XOC [v] => xO (Pos_of_value v)

| Syntax.c_capply XIC [v] => xI (Pos_of_value v)

| _ => xH

end.



Fixpoint N_of_value (v : value) : N := match v with

| Syntax.c_capply N0C [] => 0

| Syntax.c_capply NPosC [v] => N.pos (Pos_of_value v)

| _ => 0

end.



Fixpoint value_of_pos (n : positive) : value := match n with

| xH => c_capply XHC []

| xO a => c_capply XOC [value_of_pos a]

| xI a => c_capply XIC [value_of_pos a]

end.



Fixpoint pos_of_value p := match p with

| Syntax.c_capply XHC [] => xH

| Syntax.c_capply XOC [a] => xO (pos_of_value a)

| Syntax.c_capply XIC [a] => xI (pos_of_value a)

| _ => xH

end.



Definition value_of_N (n : N) : Syntax.value EMSyntax.constructor  :=

  match n with

  | 0%N => c_capply N0C []

  | Npos a => c_capply NposC [value_of_pos a]

  end.



Definition value_of_mask (m : Pos.mask) := match m with

| IsPos a => c_capply IsPosC [value_of_pos a]

| IsNeg => c_capply IsNegC []

| IsNul => c_capply IsNulC []

end.



Definition mask_of_value m := match m with

| Syntax.c_capply IsPosC [a] => IsPos (pos_of_value a)

| Syntax.c_capply IsNegC [] => IsNeg

| Syntax.c_capply IsNulC [] => IsNul

| _ => IsNul

end.



Definition value_of_comp c := match c with

| Eq => c_capply EqC []

| Lt => c_capply LtC []

| Gt => c_capply GtC []

end.



Definition comp_of_value v := match v with

| Syntax.c_capply EqC [] => Eq

| Syntax.c_capply LtC [] => Lt

| Syntax.c_capply GtC [] => Gt

| _ => Eq

end.



Definition value_of_bool b := match b with

| true => c_capply TrueC []

| false => c_capply FalseC []

end.



Definition bool_of_value v := match v with

| Syntax.c_capply TrueC [] => true

| Syntax.c_capply FalseC [] => false

| _ => false

end.



Definition pairN : Type := (N * N).



Definition value_of_pair (x : pairN) := c_capply PairC [value_of_N (fst x); value_of_N (snd x)].



Coercion value_of_N : N >-> Syntax.value.



Coercion value_of_pair : pairN >-> value.



Open Scope N_scope.



Lemma pred_double_correct p : forall t,

evaluates t (value_of_pos p) ->

  evaluates (pred_doubleF (: t :)) (value_of_pos (Pos.pred_double p)).

Proof. induction p; intros; reduce; apply IHp; auto with *. Qed.



Definition pred_double_correct' : ltac:(auto_for_auto pred_double_correct) := pred_double_correct.

Hint Resolve pred_double_correct' : eval.



Lemma succ_double_mask_correct m : forall t,

evaluates t (value_of_mask m) ->

evaluates (succ_double_maskF (: t :)) 

          (value_of_mask (Pos.succ_double_mask m)).

Proof. induction m; reduce. Qed.



Definition succ_double_mask_correct' : ltac:(auto_for_auto succ_double_mask_correct) := succ_double_mask_correct.

Hint Resolve succ_double_mask_correct' : eval.



Lemma double_mask_correct m : forall t,

evaluates t (value_of_mask m) ->

evaluates (double_maskF (: t :)) (value_of_mask (Pos.double_mask m)).

Proof. induction m; reduce. Qed.



Definition double_mask_correct' : ltac:(auto_for_auto double_mask_correct) := double_mask_correct.

Hint Resolve double_mask_correct' : eval.



Lemma double_pred_mask_correct p : forall t,

evaluates t (value_of_pos p) ->

evaluates (double_pred_maskF (: t :)) (value_of_mask (Pos.double_pred_mask p)).

Proof. induction p; reduce. Qed.



Definition double_pred_mask_correct' : ltac:(auto_for_auto double_pred_mask_correct) := double_pred_mask_correct.

Hint Resolve double_pred_mask_correct' : eval.



Lemma sub_mask_correct q : forall p tp tq,

evaluates tp (value_of_pos p) ->

evaluates tq (value_of_pos q) ->

evaluates (sub_maskF (: tp, tq :)) 

          (value_of_mask (Pos.sub_mask p q)) /\

evaluates (sub_mask_carryF (: tp, tq :)) 

          (value_of_mask (Pos.sub_mask_carry p q)).

Proof.

induction q;

intros p tp tq Hp Hq;

destruct p; split; reduce; simpl; fold value_of_pos;

case_eq (Pos.sub_mask p0 q0); 

case_eq (Pos.sub_mask_carry p0 q0); intros;

  (econstructor;

  [ reduce; apply IHq; auto with *

  | try rewrite H; try rewrite H0; tauto

  | try reduce; auto with *]).

Qed.



Definition sub_mask_correct' : ltac:(auto_for_auto sub_mask_correct) := sub_mask_correct.

Hint Resolve sub_mask_correct' : eval.



Lemma compare_cont_correct p: forall tp tq q,

evaluates tp (value_of_pos p) ->

evaluates tq (value_of_pos q) ->

evaluates (compare_contEqF (: term_from_value (value_of_pos p),

                              term_from_value (value_of_pos q) :))

          (value_of_comp (Pos.compare_cont Eq p q)) /\

evaluates (compare_contLtF (: term_from_value (value_of_pos p),

                              term_from_value (value_of_pos q) :))

          (value_of_comp (Pos.compare_cont Lt p q)) /\

evaluates (compare_contGtF (: term_from_value (value_of_pos p),

                              term_from_value (value_of_pos q) :))

          (value_of_comp (Pos.compare_cont Gt p q)).

Proof.

induction p; intros tp tq q; destruct q; intros Hp Hq; repeat reduce;

simpl in *;

fold value_of_pos;

eapply IHp; auto with *.

Qed.



Definition compare_cont_correct' : ltac:(auto_for_auto compare_cont_correct) := compare_cont_correct.

Hint Resolve compare_cont_correct' : eval.



Lemma compare_correct p: forall q tp tq,

evaluates tp (value_of_pos p) ->

evaluates tq (value_of_pos q) ->

evaluates (compareF (: tp, tq :)) (value_of_comp (Pos.compare p q)).

Proof.

intros q tp tq Htp Htq; reduce;

eapply (compare_cont_correct p); auto with *.

Qed.



Definition compare_correct' : ltac:(auto_for_auto compare_correct) := compare_correct.

Hint Resolve compare_correct' : eval.



Lemma succ_double_correct t n :

evaluates t (value_of_N n) ->

evaluates (succ_doubleF (: t :)) (value_of_N (N.succ_double n)).

Proof. destruct n; reduce. Qed.



Definition succ_double_correct' : ltac:(auto_for_auto succ_double_correct) := succ_double_correct.

Hint Resolve succ_double_correct' : eval.



Lemma double_correct n : forall t,

evaluates t (value_of_N n) ->

evaluates (doubleF (: t :)) (value_of_N (N.double n)).

Proof. destruct n; reduce. Qed.



Definition double_correct' : ltac:(auto_for_auto double_correct) := double_correct.

Hint Resolve double_correct' : eval.



Lemma sub_correct n m tn tm:

evaluates tn (value_of_N n) ->

evaluates tm (value_of_N m) ->

evaluates (subF (: tn , tm :)) 

          (value_of_N (N.sub n m)).

Proof.

intros Hn Hm;

destruct n, m; reduce; simpl;

case_eq (Pos.sub_mask p0 p1);

intros;

(econstructor;

[ repeat constructor;

  eapply sub_mask_correct; auto with *

| rewrite H; tauto

| try reduce; auto with eval]).

Qed.



Definition sub_correct' : ltac:(auto_for_auto sub_correct) := sub_correct.

Hint Resolve sub_correct' : eval.



Lemma compare0_correct n: forall m tn tm,

evaluates tn (value_of_N n) ->

evaluates tm (value_of_N m) ->

evaluates (compare0F (: tn, tm :)) 

          (value_of_comp (N.compare n m)).

Proof. induction n; intro m; intros; destruct m; reduce. Qed.



Definition compare0_correct' : ltac:(auto_for_auto compare0_correct) := compare0_correct.

Hint Resolve compare0_correct' : eval.



Lemma leb_aux_correct : forall tc c,

evaluates tc (value_of_comp c) ->

  evaluates (leb_auxF (: tc :)) 

             (value_of_bool (match c with Gt => false | _ => true end)).

Proof. intros tc c; destruct c; repeat split; reduce. Qed.



Definition leb_aux_correct' : ltac:(auto_for_auto leb_aux_correct) := leb_aux_correct.

Hint Resolve leb_aux_correct' : eval.



Lemma leb_correct tn tm (n m : N) :

evaluates tn (value_of_N n) ->

evaluates tm (value_of_N m) ->

evaluates (lebF (: tn, tm :)) (value_of_bool (N.leb n m)).

Proof. reduce. Qed.



Definition leb_correct' : ltac:(auto_for_auto leb_correct) := leb_correct.

Hint Resolve leb_correct' : eval.



Lemma cond_correct {A} f tc ta tb c (a b : A) :

evaluates tc (value_of_bool c) ->

evaluates ta (f a) ->

evaluates tb (f b) ->

 evaluates (condF (: tc, ta, tb :))

           (f (if c then a else b)).

Proof. destruct c; reduce. Qed.



Definition cond_correct' A : ltac:(auto_for_auto (@cond_correct A)) := cond_correct.

Hint Resolve cond_correct' : eval.



Lemma mod_succ_double_compat n m :

(if m <=? N.succ_double (n mod m)

 then N.succ_double (n mod m) - m

 else N.succ_double (n mod m)) = N.succ_double n mod m.

Proof.

destruct n as [| n].

- destruct m as [|[m|m|]]; trivial.

- unfold N.modulo.

  case_eq (N.div_eucl (N.pos n) m); intros q r Hqr.

  simpl.

  destruct m as [|m]; trivial; simpl.

  + now simpl in Hqr; inversion Hqr; subst.

  + simpl in Hqr; rewrite Hqr.

    destruct(N.pos m <=? N.succ_double r); trivial.

Qed.



Lemma mod_double_compat n m :

(if m <=? N.double (n mod m)

 then N.double (n mod m) - m

 else N.double (n mod m)) = N.double n mod m.

Proof.

destruct n as [| n].

- destruct m as [|[m|m|]]; trivial.

- unfold N.modulo.

  case_eq (N.div_eucl (N.pos n) m); intros q r Hqr.

  simpl.

  destruct m as [|m]; trivial; simpl.

  + now simpl in Hqr; inversion Hqr; subst.

  + simpl in Hqr; rewrite Hqr.

    destruct(N.pos m <=? N.double r); trivial.

Qed.



Lemma mod_aux_correct n m tn tm:

evaluates tn (value_of_pos n) ->

evaluates tm (value_of_N m) ->

evaluates (mod_auxF (: tn, tm :)) (value_of_N (N.modulo (N.pos n) m)).

Proof.

revert tn tm.

induction n; intros tn tm Hn Hm.

- reduce; evar (v1: N); evar (v2: N).

  replace (N.pos n~1 mod m) with 

          (if m <=? N.succ_double (N.pos n mod m) then v1 else v2).

  apply cond_correct.

  + apply leb_correct; simpl; auto with *.

    apply succ_double_correct; auto with *.

  + apply sub_correct.

    apply succ_double_correct.

    apply IHn; auto with *.

    simpl; auto with *.

  + apply succ_double_correct.

    apply IHn; auto with *.

  + subst v1 v2.

    apply mod_succ_double_compat.

- reduce; evar (v1: N); evar (v2: N).

  replace (N.pos n~0 mod m) with 

          (if m <=? N.double (N.pos n mod m) then v1 else v2).

  apply cond_correct.

  + apply leb_correct; simpl; auto with *.

    apply double_correct; auto with *.

  + apply sub_correct.

    apply double_correct.

    apply IHn; auto with *.

    simpl; auto with *.

  + apply double_correct.

    apply IHn; auto with *.

  + subst v1 v2.

    apply mod_double_compat.

- destruct m as [| [ m | m |]]; simpl; reduce.

Qed.



Definition mod_aux_correct' : ltac:(auto_for_auto mod_aux_correct) := mod_aux_correct.

Hint Resolve mod_aux_correct' : eval.



Lemma mod_0 n : n mod 0 = n.

Proof.

destruct n; trivial.

Qed.



Lemma mod_correct n m tn tm: 

evaluates tn (value_of_N n) ->

evaluates tm (value_of_N m) ->

evaluates (modF (: tn, tm :)) (value_of_N (N.modulo n m)).

Proof.

destruct n; reduce.

Qed.



Definition mod_correct' : ltac:(auto_for_auto mod_correct) := mod_correct.

Hint Resolve mod_correct' : eval.



Lemma succ_correct p: forall t,

evaluates t (value_of_pos p) ->

evaluates (succF (: t :)) (value_of_pos (Pos.succ p)).

Proof. induction p; intros; reduce; apply IHp; auto with *. Qed.



Lemma add_correct p: forall q tp tq,

evaluates tp (value_of_pos p) ->

evaluates tq (value_of_pos q) ->

evaluates (addF (: tp, tq :)) (value_of_pos (Pos.add p q)) /\

evaluates (add_carryF (: tp, tq :)) (value_of_pos (Pos.add_carry p q)).

Proof.

induction p; intros q tp tq Hp Hq; split; destruct q; reduce;

try (apply IHp || apply succ_correct); auto with *.

Qed.



Lemma add0_correct n m: forall tn tm,

evaluates tn (value_of_N n) ->

evaluates tm (value_of_N m) ->

evaluates (add0F (: tn, tm :)) (value_of_N (N.add n m)).

Proof.

destruct n; intros; [ reduce |];

destruct m; [ reduce | reduce; apply add_correct; auto with * ].

Qed.



Inductive larger_bound : positive -> positive -> Type :=

  | larger_1  : forall b, larger_bound xH b

  | larger_xI : forall x b, larger_bound x b -> larger_bound (xI x) (xO b)

  | larger_xO : forall x b, larger_bound x b -> larger_bound (xO x) (xO b).



Lemma larger_bound_xO p b: 

 larger_bound p b -> larger_bound p b~0.

Proof.

intro H; induction H; constructor; assumption.

Qed.



Lemma mul_mod_aux_correct p1 p2 m: forall n tp1 tp2 tn tm,

m <> 0 ->

larger_bound p1 p2 ->

evaluates tp1 (value_of_pos p1) ->

evaluates tp2 (value_of_pos p2) ->

evaluates tn (value_of_N n) ->

evaluates tm (value_of_N m) ->

evaluates (mul_mod_auxF (: tp1, tn, tm, tp2 :))

          ((N.pos p1 * n) mod m).

Proof.

revert p2.

induction p1 as [ p | p |]; intros p2 n tp1 tp2 tn tm Hpos Hb H1 H2 Hn Hm;

inversion Hb; subst; reduce.

- replace (N.pos p~1 * n) with (n + N.double (N.pos p * n)) by (now destruct n).

  rewrite <- N.add_mod_idemp_r; trivial.

  rewrite N.double_spec.

  rewrite <- N.mul_mod_idemp_r; trivial.

  rewrite <- N.double_spec.

  rewrite N.add_mod_idemp_r; trivial.

  apply mod_correct; auto with *.

  apply add0_correct; auto with *.

  apply double_correct; auto with *.

  apply IHp with (p2 := b); auto with *.

- replace (N.pos p~0 * n) with (N.double (N.pos p * n)) by (now destruct n).

  rewrite N.double_spec.

  rewrite <- N.mul_mod_idemp_r; trivial.

  rewrite <- N.double_spec.

  apply mod_correct; auto with *.

  apply double_correct; auto with *.

  apply IHp with (p2 := b); auto with *.

- apply mod_correct.

  + destruct n; auto with eval.

  + auto with *.

Qed.



Definition N_larger_bound n b := match n with

| 0 => larger_bound xH b

| Npos p0 => larger_bound p0 b

end.



Fixpoint lower_bound p0 := match p0 with

| xH => xH

| xO p0 => xO (lower_bound p0)

| xI p0 => xO (lower_bound p0)

end.



Lemma lower_bound_bound p0 : larger_bound p0 (lower_bound p0).

Proof.

induction p0; now constructor.

Qed.



Lemma lower_bound_pow2 k : (lower_bound (2^ k) = 2^k)%positive.

Proof.

induction k using Pos.peano_ind.

- simpl; trivial.

- simpl.

  rewrite Pos.pow_succ_r.

  simpl; now f_equal.

Qed.



Lemma lower_bound_div_bound (p0 b : positive) :

larger_bound p0 b -> {k | (b = k * lower_bound p0)%positive}.

Proof.

revert b; induction p0; intros b Hb; inversion Hb; subst.

- destruct (IHp0 b0 H0) as (k & Hk).

  exists k; simpl; lia.

- destruct (IHp0 b0 H0) as (k & Hk).

  exists k; simpl; lia.

- exists b; simpl; lia.

Qed.



Lemma lower_bound_le p0 p1 :

(p0 <= p1 -> {k | lower_bound p1 = k * lower_bound p0})%positive.

Proof.

revert p1.

induction p0; intros p1 Hle.

- destruct p1 as [p1|p1|].

  + simpl in Hle.

    assert(Hle' : (p0 <= p1)%positive) by lia.

    apply IHp0 in Hle'.

    destruct Hle' as [k Hk].

    exists k;simpl;lia.

  + simpl in Hle.

    assert(Hle' : (p0 <= p1)%positive) by lia.

    apply IHp0 in Hle'.

    destruct Hle' as [k Hk].

    exists k;simpl;lia.

  + contradict Hle; lia.

- destruct p1 as [p1|p1|].

  + simpl in Hle.

    assert(Hle' : (p0 <= p1)%positive) by lia.

    apply IHp0 in Hle'.

    destruct Hle' as [k Hk].

    exists k;simpl;lia.

  + simpl in Hle.

    assert(Hle' : (p0 <= p1)%positive) by lia.

    apply IHp0 in Hle'.

    destruct Hle' as [k Hk].

    exists k;simpl;lia.

  + contradict Hle; lia.

- exists (lower_bound p1); simpl; lia.

Qed.



Lemma larger_bound_spec p0 k:

  larger_bound p0 (k * lower_bound p0).

Proof.

induction p0.

- simpl; rewrite Pos.mul_xO_r; now constructor.

- simpl; rewrite Pos.mul_xO_r; now constructor.

- constructor.

Qed.



Lemma N_larger_bound_le n n' b :

 n' <= n ->

 N_larger_bound n b ->

 N_larger_bound n' b.

Proof.

intros Hle Hb.

destruct n' as [| n'].

- simpl; constructor.

- destruct n as [| n]; [ now destruct Hle |].

  simpl in *.

  destruct (lower_bound_div_bound n b Hb) as (k & Hk).

  apply lower_bound_le in Hle.

  destruct Hle as (k' & Hk').

  rewrite Hk' in Hk.

  rewrite Hk.

  replace (k * (k' * lower_bound n'))%positive 

    with (k * k' * lower_bound n')%positive by lia.

  apply larger_bound_spec.

Qed.



Lemma N_larger_bound_mod n m b :

 m <> 0 ->

 N_larger_bound m b ->

 N_larger_bound (n mod m) b.

Proof.

intro H; now apply N_larger_bound_le, N.lt_le_incl, N.mod_lt.

Qed.



Hint Resolve N_larger_bound_mod : eval.



Lemma mul_mod_correct n n' m b: forall tn tn' tm tb,

m <> 0 ->

N_larger_bound n b ->

evaluates tn (value_of_N n) ->

evaluates tn' (value_of_N n') ->

evaluates tm (value_of_N m) ->

evaluates tb (value_of_pos b) ->

evaluates (mul_modF (: tn, tn', tm, tb:))

          ((n * n') mod m).

Proof.

intros; destruct n; reduce.

apply mul_mod_aux_correct with (p2 := b); auto with eval.

Qed.



Lemma exp_mod_aux_correct y: forall x m tx ty tm b tb,

m <> 0 ->

N_larger_bound m b ->

evaluates tx (value_of_N x) ->

evaluates ty (value_of_pos y) ->

evaluates tm (value_of_N m) ->

evaluates tb (value_of_pos b) ->

evaluates (exp_mod_auxF (: tx, ty, tm, tb :))

          ( x ^ (Npos y) mod m).

Proof.

induction y as [ y | y | ]; intros x m tx ty tm b tb Hpos Hlarger Hx Hy Hm Hb.

- change (Npos y~1) with (N.succ (N.pos y~0)).

  rewrite N.pow_succ_r; [ | lia].

  change (N.pos y~0) with (2 * (N.pos y)).

  rewrite N.pow_mul_r, <- N.mul_mod_idemp_r; trivial.

  rewrite <- N.mod_mod; trivial.

  rewrite <- N.mul_mod_idemp_l; trivial.

  rewrite N.mod_mod; trivial.

  reduce.

  apply mul_mod_correct with b; auto with *.

  rewrite N.pow_2_r.

  rewrite N.pow_mul_l, N.mul_mod; trivial.

  apply mul_mod_correct with b; auto with *; 

  apply IHy with b; auto with *.

- change (N.pos y~0) with (2 * (N.pos y)).

  rewrite N.pow_mul_r, N.pow_2_r, N.pow_mul_l, N.mul_mod; trivial.

  reduce.

  apply mul_mod_correct with b; auto with *;

  apply IHy with b; auto with *.

- reduce.

  apply mod_correct; simpl; auto with *.

  destruct x; auto with *.

  rewrite Pos.pow_1_r; auto with *.

Qed.



Lemma bound_correct_pos x tx:

evaluates tx (value_of_pos x) ->

evaluates (boundF (: tx :)) (value_of_pos (2^(Pos.size x))).

Proof.

revert tx.

induction x; intros; reduce; simpl;

rewrite Pos.pow_succ_r; reduce; apply IHx; auto with *.

Qed.



Lemma exp_mod_correct x y m tx ty tm:

m <> 0 ->

evaluates tx (value_of_N x) ->

evaluates ty (value_of_N y) ->

evaluates tm (value_of_N m) ->

evaluates (exp_modF (: tx, ty, tm :))

          ( x ^ y mod m).

Proof.

intros.

destruct y as [ | y].

- reduce.

  apply mod_correct; [ reduce | auto with *].

- reduce.

  destruct m as [|m].

  + apply exp_mod_aux_correct with (b := xH); tauto.

  + apply exp_mod_aux_correct with (b := (2^(Pos.size m))%positive); auto with *.

    * assert (m <= 2^ Pos.size m)%positive by

      (apply Pos.lt_le_incl, Pos.size_gt).

      apply N_larger_bound_le with (n := N.pos (2 ^ Pos.size m)); trivial.

      simpl; rewrite <- lower_bound_pow2 at 2.

      apply lower_bound_bound.

    * reduce; apply bound_correct_pos; auto with *.

Qed.

