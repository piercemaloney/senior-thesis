Require Import Recdef Relations Wellfounded.

Require Import Arith NPeano PeanoNat List Bool Psatz.

Require Import Cecoa.Lib Cecoa.Syntax Cecoa.CBV_cache Cecoa.Bounds Cecoa.Ordering.
(* Cecoa.Lib:
Require Import Bool Arith Max Omega Psatz List NPeano Permutation.
Import List.ListNotations.

Require Import Unicode.Utf8_core.
Require Import Unicode.Utf8.
Notation "x ≤ y ≤ z" := (x ≤ y ∧ y ≤ z) (at level 70, y at next level).
Notation "x < y ≤ z" := (x < y ∧ y ≤ z) (at level 70, y at next level).
Notation "x ≤ y < z" := (x ≤ y ∧ y < z) (at level 70, y at next level).

Infix "∈" := In (at level 70).

Infix "=?" := beq_nat (at level 70, no associativity).

Obligation Tactic := idtac.

Scheme Equality for prod.
Scheme Equality for list.

Set Implicit Arguments.

Section Trivial.
Lemma S_is_suc n: S n = n+1.
Lemma or_idem: ∀ A, A ↔ A ∨ A.
Lemma and_idem: ∀ A, A ↔ A ∧ A.
Lemma and_left: ∀ A B, A ∧ B → A.
Lemma or_false_idem: ∀ A, A ↔ A ∨ False.

Definition fmono (f: nat → nat):= ∀ x y, x ≤ y → f x ≤ f y.

Lemma forall_and {A:Type} (P Q:A→Prop):
  (∀ x, P x ∧ Q x) ↔ ((∀ x, P x) ∧ (∀ x, Q x)).
Lemma forall_impl_and {A:Type} (R:A→Prop) (P Q:A→Prop):
  (∀ x, R x → P x ∧ Q x) ↔
  ((∀ x, R x → P x) ∧ (∀ x, R x → Q x)).
Lemma forall_impl2_and {A B:Type} (P Q R : A → B → Prop):
  (∀ x y, R x y → P x y ∧ Q x y) ↔ 
  ((∀ x y, R x y → P x y) ∧ (∀ x y, R x y → Q x y)).

Lemma eqb_subst_neq x y:
  x ≠ y → (x =? y) = false.
Lemma neq_lt_gt_iff (m n:nat):
  m ≠ n ↔ (m < n ∨ n < m).

Lemma length_nil : forall A (l : list A),
  length l = 0 -> l = nil.
End Trivial.

Lemma prod_beq_eq A B
  (A_beq : A -> A -> bool) (B_beq : B -> B -> bool)
  (A_beq_eq : forall a1 a2, A_beq a1 a2 = true <-> a1 = a2) (B_beq_eq : forall b1 b2, B_beq b1 b2 = true <-> b1 = b2)
  p1 p2 : prod_beq _ _ A_beq B_beq p1 p2 = true <-> p1 = p2.

Lemma list_beq_eq A
  (A_beq : A -> A -> bool) l1 l2 (A_beq_eq : forall a1 a2, In a1 l1 -> In a2 l2 -> (A_beq a1 a2 = true <-> a1 = a2)) :
  list_beq _ A_beq l1 l2 = true <-> l1 = l2.

Lemma list_beq_refl (A : Type) (A_beq : A -> A -> bool) l :
  (forall a1 a2 : A, In a1 l -> In a2 l -> (A_beq a1 a2 = true <-> a1 = a2)) ->
  list_beq _ A_beq l l = true.

Lemma eq_None_neq_Some (A : Type) (x : option A) :
  x = None <-> forall v, x <> Some v.

Lemma neq_None_eq_Some :
  forall (A: Type) (x: option A), x <> None <-> (exists a, x = Some a).

Lemma app_insert_r (A : Type) (l1 l1' l l2 l2' : list A):
  l1 ++ l2 = l1' ++ l2' -> length l2 = length l2' -> l1 ++ l ++ l2 = l1' ++ l ++ l2'.

Section assoc.

Fixpoint assoc {A B : Type}(eq : A -> A -> bool)(x : A)(l : list (A * B)) : option B :=
  match l with
  | nil => None
  | (x', y) :: l' => if eq x x' then Some y else assoc eq x l'
  end.

Definition assoc_default {A B : Type}
  (eqA : A -> A -> bool) (d : B) (l : list (A * B)) (x : A) : B :=
  match assoc eqA x l with
  | None => d
  | Some b => b
  end.

Lemma assoc_in {A B:Type} beq k (l: list (A * B)) {v}:
  (∀ a b:A, beq a b = true ↔ a=b) →
  assoc beq k l = Some v → (k,v) ∈ l.

Lemma assoc_None_not_in {A B:Type} beq k (l:list (A*B)):
  (∀ a b : A, beq a b = true ↔ a = b) →
  assoc beq k l = None ↔ ¬ k ∈ map fst l.

Lemma in_assoc_neq_None (A B: Type) (beq: A -> A -> bool) (k: A) (l: list (A * B)):
  (forall a b:A, a = b -> beq a b = true) ->
  In k (map (@fst _ _) l) ->
  assoc beq k l <> None.

Lemma assoc_in_Some {A B:Type} (beq:A→A→bool) (k:A) (l: list (A*B)):
  (∀ a b, beq a b = true ↔ a=b) →
  k ∈ map fst l ↔ ∃ v, v ∈ map snd l ∧ assoc beq k l = Some v.

Lemma assoc_in_Some_simple {A B:Type} beq k (l: list (A*B)):
  (∀ a b:A, beq a b = true ↔ a = b) →
  k ∈ map fst l ↔ (∃ v, assoc beq k l = Some v).

Lemma assoc_app_eq_None (A B:Type) (eq: A -> A -> bool) (x: A) (l1 l2: list (A * B)) :
  assoc eq x (l1 ++ l2) = None <-> (assoc eq x l1 = None /\ assoc eq x l2 = None).

Lemma assoc_app_neq_None (A B:Type) (eq: A -> A -> bool) (x: A) (l1 l2: list (A * B)) :
  assoc eq x (l1 ++ l2) <> None <-> (assoc eq x l1 <> None \/ assoc eq x l2 <> None).

Lemma assoc_app_eq_Some (A B:Type) (eq: A -> A -> bool) (x: A) (v : B) (l1 l2: list (A * B)) :
  assoc eq x (l1 ++ l2) = Some v <->
  (assoc eq x l1 = Some v \/ (assoc eq x l1 = None /\ assoc eq x l2 = Some v)).

Lemma assoc_app_in {K V:Type} beq k (l1 l2: list (K*V)):
  (∀ a b : K, beq a b = true ↔ a = b) →
  k ∈ map fst l1 → assoc beq k (l1++l2) = assoc beq k l1.

Lemma assoc_app_out {K V:Type} beq k (l1 l2: list (K*V)):
  (∀ a b : K, beq a b = true ↔ a = b) →
  ¬ k ∈ map fst l1 → assoc beq k (l1++l2) = assoc beq k l2.

Lemma assoc_in_concat {K V:Type} beq (k:K) ll (v:V):
  assoc beq k (concat ll) = Some v →
  ∃ l : list (K * V), l ∈ ll ∧ assoc beq k l = Some v.

End assoc.

Lemma map_in_ext :
  forall (A B : Type) (f g : A -> B) (l : list A),
  (forall a : A, In a l -> f a = g a) -> map f l = map g l.

Lemma incl_cons_cons A: forall (a:A) (l1 l2: list A), incl l1 l2 -> incl (a::l1) (a::l2).

Lemma map_incl A B (f : A -> B) l1 l2 : incl l1 l2 -> incl (map f l1) (map f l2).

Lemma map_flat_map (A B C : Type) (f : A -> list B) (g : B -> C) (l : list A) :
map g (flat_map f l) = flat_map (fun a => map g (f a)) l.

Lemma incl_filter (A : Type) (f : A -> bool) l:
  incl (filter f l) l.

Lemma filter_ext_In {A : Type} f g (l : list A): (forall a , In a l -> f a = g a)-> filter f l = filter g l.

Lemma filter_app A (f : A -> bool) l1 l2 : filter f (l1 ++ l2) = filter f l1 ++ filter f l2.

Lemma filter_flat_map A B f (g : A -> list B) l : filter f (flat_map g l) = flat_map (fun x => filter f (g x)) l.

Lemma flat_map_in_ext  A B (f g : A -> list B) l : 
  (forall a : A, In a l -> f a = g a) -> flat_map f l = flat_map g l.

Lemma NoDup_filter A f (l : list A) : NoDup l -> NoDup (filter f l).

Lemma map_cons (A B : Type)(f : A -> B) a l : map f (a :: l) = f a :: map f l.

Lemma length_remove A eq_A_dec (a: A) l :
  length (remove eq_A_dec a l) <= length l.

Lemma length_cons_remove A eq_A_dec (a: A) l :
  In a l -> length (a :: remove eq_A_dec a l) <= length l.

Lemma neq_in_in_remove A eq_A_dec (a a': A) l:
  a' <> a -> In a l -> In a (remove eq_A_dec a' l).

Lemma incl_remove_app A l l1 l2 (x : A) : ~ In x l -> incl l (l1 ++ x :: l2) -> incl l (l1 ++ l2).

Lemma flat_map_nil (A B: Type) (f: A -> list B) (xs: list A):
  (forall x, In x xs -> f x = []) ->
  flat_map f xs = [].

Lemma flat_map_comp (A B C : Type) (f : A -> B) (g : B -> list C) (h : A -> list C) (l : list A) :
  (forall x, In x l -> h x = g (f x)) -> flat_map h l = flat_map g (map f l).

Lemma flat_map_app (A B : Type) (f : A -> list B) l1 l2 :
  flat_map f (l1 ++ l2) = flat_map f l1 ++ flat_map f l2.

Lemma comp_flat_map (A B C : Type) (f : A -> list B) (g : B -> list C) h l :
  (forall a, In a l -> h a = flat_map g (f a)) -> flat_map h l = flat_map g (flat_map f l).

Fixpoint andl (l : list Prop) : Prop :=
  match l with
  | nil => True
  | P :: l' => P /\ andl l'
  end.

Lemma andl_cons: forall a l, andl (a::l) <-> a /\ (andl l).

Lemma andl_in : forall l P, andl l -> In P l -> P.

Lemma andl_in_map (A:Type): forall l (a:A) P, andl (map P l) -> In a l -> P a.

Lemma andl_map (A : Type) (f g : A -> Prop) l :
  andl (map f l) -> (forall a, In a l -> f a -> g a) -> andl (map g l).

Lemma andl_app l1 l2 : andl (l1 ++ l2) <-> andl l1 /\ andl l2.

Fixpoint orl (l : list Prop) : Prop :=
  match l with
  | nil => False
  | P :: l' => P \/ orl l'
  end.

Lemma andl_concat l:
  andl (concat l) <-> forall l', In l' l -> andl l'.

Lemma orl_map (A : Type) (P : A -> Prop) l : orl (map P l) <-> exists x, In x l /\ P x.

Section Maxl.
Fixpoint maxl (l : list nat) : nat :=
  match l with
  | nil => 0
  | n :: l' => max n (maxl l')
  end.

Lemma maxl_is_max :
  forall l n, In n l -> n <= maxl l.

Lemma all_max_le l y :
  (forall x, In x l -> x <= y) -> maxl l <= y.

Lemma maxl_app : forall (l1 l2 : list nat), maxl (l1 ++ l2) = max (maxl l1) (maxl l2).

Lemma in_maxl (l : list nat) : l<>nil -> In (maxl l) l.

Lemma all_maxl P xs: xs <> [] -> (forall x, In x xs -> P x) -> P (maxl xs).

Lemma maxl_le_maxl A f g (l : list A) :
(forall x, In x l -> f x <= g x) -> maxl (map f l) <= maxl (map g l).

Lemma maxl_map_const {A:Type} l (f: A → nat) n:
  (∀ x, x ∈ l → (f x) = n) →
  l ≠ [] → maxl (map f l) = n.

Lemma maxl_map_0 A l (f : A -> nat) : 
  (forall x, In x l -> (f x) = 0) ->
  maxl (map f l) = 0.

Lemma maxl_map_plus_le A f g (l : list A) :
  maxl (map (fun x => f x + g x) l) <= maxl (map f l) + maxl (map g l).

Lemma maxl_concat: forall l,
  maxl (concat l) = maxl (map maxl l).

Lemma maxl_map_lt_iff (A:Type): forall (l:list A) f n,
  0<n -> maxl (map f l) < n <-> (forall m, In m l -> (f m) < n).

Lemma maxl_map_le_iff (A:Type): forall (l:list A) f n,
  maxl (map f l) <= n <-> (forall m, In m l -> (f m) <= n).

Lemma maxl_map_is_max_map (A:Type): forall (l:list A) f a,
  In a l -> (f a) <= maxl (map f l).

Lemma maxl_eq_maxl {A:Type} f g (l:list A):
  (∀ x : A, x ∈ l → f x = g x) →
  maxl (map f l) = maxl (map g l).
End Maxl.

Lemma in_concat_iff (A:Type) x (l:list (list A)):
  x ∈ concat l <-> exists l', l' ∈ l /\ x ∈ l'.

Lemma incl_le_maxl :
  forall (l1 l2 : list nat), incl l1 l2 -> maxl l1 <= maxl l2.

Lemma maxl_cons : forall n l, maxl (n::l) = max n (maxl l).

Lemma forall2_le_maxl :
  forall (l1 l2 : list nat), Forall2 le l1 l2 -> maxl l1 <= maxl l2.

Lemma incl_flat_map (A B : Type) (f g : A -> list B) l :
  (forall a, In a l -> incl (f a) (g a)) ->
  incl (flat_map f l) (flat_map g l).

Section suml.

Fixpoint suml (l : list nat) : nat :=
  match l with
  | nil => 0
  | n :: l' => n + suml l'
  end.

Lemma suml_cons n l : suml (n :: l) = n + suml l.

Lemma suml_map_const A n (l : list A) : suml (map (fun _ => n) l) = n * length l.

Lemma mult_suml_r m l : m * suml l = suml (map (fun n => m * n) l).

Lemma suml_app l1 l2 : suml (l1 ++ l2) = suml l1 + suml l2.

Lemma suml_flat_map (A : Type)(f : A -> list nat)(l :list A) :
  suml (flat_map f l) = suml (map suml (map f l)).

Lemma suml_flat_map_map (A B : Type) (f : A -> list B) (g : B -> nat) l :
  suml (flat_map (fun x => map g (f x)) l) = suml (map (fun x => suml (map g (f x))) l).

Lemma suml_map_plus (A : Type)(f g : A -> nat)(l : list A) : suml (map (fun x => f x + g x) l) = suml (map f l) + suml (map g l).

Lemma suml_map_le :
  forall (A : Type)(f g : A -> nat)(l : list A),
  (forall x, In x l -> f x <= g x) -> suml (map f l) <= suml (map g l).

Lemma suml_map_eq :
  forall (A : Type)(f g : A -> nat)(l : list A),
  (forall x, In x l -> f x = g x) -> suml (map f l) = suml (map g l).

Lemma suml_map_le_plus_length :
  forall (A : Type)(f g : A -> nat)(l : list A),
  (forall x, In x l -> f x <= g x + 1) -> suml (map f l) <= suml (map g l) + length l.

Lemma suml_le_len_times_bound l b :
  (forall x, In x l -> x <= b) -> suml l <= length l * b.

Lemma in_le_suml :
  forall (n : nat)(l : list nat),
  In n l -> n <= suml l.

Lemma maxl_le_suml l: maxl l <= suml l.

Lemma forall2_le_suml :
  forall (l1 l2 : list nat), Forall2 le l1 l2 -> suml l1 <= suml l2.

Lemma maxl_le_suml_map (A B : Type) (f : A -> list B) (g : B -> nat) (h : A -> nat) (l : list A) :
  (forall a, In a l -> maxl (map g (f a)) <= h a) ->
  maxl (map g (flat_map f l)) <= suml (map h l).

Lemma suml_map_mult_le_suml_mult_maxl (A : Type) f g (l : list A) :
  suml (map (fun x => f x * g x) l) <= suml (map f l) * maxl (map g l).

Lemma suml_map_mult_le_suml_mult_suml (A : Type) f g (l : list A) :
  suml (map (fun x => f x * g x) l) <= suml (map f l) * suml (map g l).

Lemma length_flat_map (A B : Type) ( f : A -> list B) (l : list A) :
  length (flat_map f l) = suml (map (@length _) (map f l)).

Lemma seq_Succ n m : seq n (S m) = seq n m ++ [m + n].

Lemma Permutation_filter {A : Type} f (l : list A) : Permutation l (filter f l ++ filter (fun x => negb (f x)) l).

Lemma filter_compose {A : Type} f g (l : list A) : 
  (forall x, In x l -> ( f x = true -> g x = true)) ->
  filter f (filter g l) = filter f l.

Lemma in_seq : forall len start n : nat,
       In n (seq start len) <-> start <= n < start + len.

Lemma Permutation_partition_list_nat b n l :
 (forall x, In x l -> b <= x < b + n) ->
 Permutation l (flat_map (fun n => filter (beq_nat n) l) (seq b n)).

Lemma length_suml_filter b n l:
 (forall x, In x l -> b <= x < b + n) ->
 suml (map (fun r => length(filter (beq_nat r) l )) (seq b n)) = length l.

End suml.

Section prodl.

Fixpoint prodl (l : list nat) : nat :=
  match l with
  | nil => 1
  | n :: l' => n * prodl l'
  end.

Lemma prodl_bound (l : list nat) (b : nat) : 
  (forall x, In x l -> x <= b) -> prodl l <= Nat.pow b  (length l).

End prodl.

Definition clos_refl {A : Type} (R : A -> A -> Prop) (x y : A) : Prop :=
  R x y \/ x = y.

Lemma clos_refl_trans (A: Type) (R: A -> A -> Prop) t1 t2 t3:
    (R t1 t2 -> R t2 t3 -> R t1 t3) ->
    clos_refl R t1 t2 -> clos_refl R t2 t3 -> clos_refl R t1 t3.

Lemma Forall2_eq_clos_refl (A:Type) (R: A -> A -> Prop) (l1 :list A) :
  Forall2 (clos_refl R) l1 l1.

Lemma Forall_In_l (A : Type) (P : A -> Prop) x xs:
  Forall P xs -> In x xs -> P x.

Lemma Forall2_In_l (A B : Type) (R : A -> B -> Prop) x xs ys :
  Forall2 R xs ys -> In x xs -> exists y, In y ys /\ R x y.

Lemma Forall2_In_r (A B : Type) (R : A -> B -> Prop) y xs ys :
  Forall2 R xs ys -> In y ys -> exists x, In x xs /\ R x y.

Lemma Forall2_conj (A B : Type) (R1 R2 : A -> B -> Prop) xs ys :
  Forall2 R1 xs ys -> Forall2 R2 xs ys -> Forall2 (fun x y => R1 x y /\ R2 x y) xs ys.

Lemma Forall2_trans (A: Type) (R: A -> A -> Prop) xs ys zs :
    (forall x y z, In x xs -> In y ys -> In z zs -> R x y -> R y z -> R x z) ->
    Forall2 R xs ys -> Forall2 R ys zs -> Forall2 R xs zs.

Lemma Forall2_length A B (R : A -> B -> Prop) xs ys :
  Forall2 R xs ys -> length xs = length ys.

Lemma Forall2_map (A:Type) (B:Type): forall l f g (R:B->B->Prop),
  (forall (x:A), In x l -> R (f x) (g x)) -> Forall2 R (map f l) (map g l).

Lemma Forall2_flat_map (A B C D: Type) (R: C -> D -> Prop) (f: A -> list C) (g: B -> list D) (xs: list A) (ys: list B) :
  Forall2 (fun x y => Forall2 R (f x) (g y)) xs ys ->
  Forall2 R (flat_map f xs) (flat_map g ys).

Lemma Forall2_forall A (d: A) (R: A -> A -> Prop) (xs ys: list A) :
  Forall2 R xs ys ->
  forall i, i < length xs -> R (nth i xs d) (nth i ys d).

Inductive Exists2 {A B} (R: A -> B -> Prop) : list A -> list B -> Prop :=
 | Exists2_cons_hd : forall x xs y ys, R x y -> Exists2 R (x::xs) (y::ys)
 | Exists2_cons_tl : forall x xs y ys, Exists2 R xs ys -> Exists2 R (x::xs) (y::ys).
Hint Constructors Exists2.

Lemma Exists2_exists A (d: A) (R: A -> A -> Prop) (xs ys: list A) :
  Exists2 R xs ys ->
  exists i, i < length xs /\ R (nth i xs d) (nth i ys d).

Lemma app_eq_compat_l {A: Type} (xs ys zs: list A) : ys = zs -> xs ++ ys = xs ++ zs.

Lemma In_prefix_suffix (A : Type) (a : A) l :
  In a l -> exists l1 l2, l = l1 ++ a :: l2.

Lemma forall_exists_list (A B : Type) (P : A -> Prop) (Q : A -> B -> Prop) (l : list A) :
  (forall a, In a l -> P a -> exists b, Q a b) ->
  (Forall P l -> exists l', Forall2 Q l l').

Lemma forall_andl (A: Type) (P: A -> Prop) (l: list A):
  Forall P l <-> andl (map P l).

Fixpoint revflatten {A: Type} (xss: list (list A)) : list A :=
  match xss with
  | []       => []
  | xs::xss' => revflatten xss' ++ xs
  end.

Lemma Permutation_flat_map_ext A B  : forall l (f g : A -> list B),
  (forall x, In x l -> Permutation (f x) (g x)) -> Permutation (flat_map f l) (flat_map g l).

Lemma Permutation_revflatten A B (f : A -> list B) l : Permutation(revflatten (map f l)) (flat_map f l).

Lemma In_seq n start len : In n (seq start len) <-> start <= n < start+len.

Lemma seq_S start len : seq start (S len) = seq start len ++ [start + len].

Lemma plus_eq_compat_l x y1 y2 : y1 = y2 -> x + y1 = x + y2.

Lemma plus_eq_compat_r x1 x2 y : x1 = x2 -> x1 + y = x2 + y.

Section count_occ.

Lemma count_occ_remove_O A eq_dec (a: A) l :
  count_occ eq_dec (remove eq_dec a l) a = 0.

Lemma count_occ_remove_neq A eq_dec (a a': A) l :
  a<>a' -> count_occ eq_dec (remove eq_dec a' l) a = count_occ eq_dec l a.

Lemma suml_map_count_occ_remove A eq_dec (a: A) l1 l2 :
  ~In a l2 ->
  suml (map (count_occ eq_dec (remove eq_dec a l1)) l2) =
  suml (map (count_occ eq_dec l1) l2).

Lemma length_remove_count_occ A eq_dec (a: A) l:
  length l = length (remove eq_dec a l) + count_occ eq_dec l a.

Lemma in_remove_neq A eq_dec (a a': A) l :
  In a' (remove eq_dec a l) -> In a' l.

Lemma length_count_occ a b l :
  (forall n, In n l -> a <= n < a + b) ->
  length l = suml (map (count_occ eq_nat_dec l) (seq a b)).

Lemma count_occ_cons A eq_dec (a a': A) l :
  count_occ eq_dec (a::l) a' =
  if eq_dec a a' then S (count_occ eq_dec l a') else count_occ eq_dec l a'.

Lemma count_occ_app A eq_dec (a :A) l l' :
  count_occ eq_dec (l ++ l') a = count_occ eq_dec l a + count_occ eq_dec l' a.

Lemma count_occ_flat_map A B eq_B_dec (f: A -> list B) b l :
  count_occ eq_B_dec (flat_map f l) b =
  suml (map (fun a => count_occ eq_B_dec (f a) b) l).

End count_occ.

Lemma tl_incl (A:Type): forall (a:A) l l', incl (a::l') l -> incl l' l.

Section NoDup.

Lemma NoDup_app (A: Type) (l1 l2: list A):
  (forall x, In x l1 -> ~ In x l2) ->
  NoDup l1 ->
  NoDup l2 ->
  NoDup (l1 ++ l2).

Lemma NoDup_split (A: Type) (l1 l2: list A):
  NoDup (l1 ++ l2) ->
  NoDup l1.

Lemma NoDup_split_right : forall (A : Type) (l1 l2 : list A), NoDup (l1 ++ l2) -> NoDup l2.

Theorem NoDup_cons_iff {A:Type} (a: A) (l: list A):
  NoDup (a::l) <-> ~ In a l /\ NoDup l.

Lemma NoDup_app_in_l A l l' :
  NoDup (l ++ l') -> forall x : A, (In x l) -> ~ (In x l').

Lemma NoDup_Permutation_NoDup A l l' : @NoDup A l -> Permutation.Permutation l l' -> NoDup l'.

Lemma NoDup_incl_le_length (A: Type)
  (l1 l2: list A):
  NoDup l1 -> incl l1 l2 -> length l1 <= length l2.

Lemma NoDup_flat_map A B (f : A -> list B) l :
  (forall x, In x l -> NoDup (f x)) ->
  NoDup l ->
  (forall x y, In x l -> In y l -> x <> y -> (forall z, In z (f x) <-> ~ In z (f y))) ->
  NoDup (flat_map f l).

End NoDup.

Definition uniquify A (d : forall a b : A, { a = b} + { a <> b}) (l:list A) : list A :=
list_rect (fun _ : list A => list A) []
  (fun (a : A) (_ l' : list A) => let s := in_dec d a l' in if s then l' else a :: l') l.

Section pow.

Lemma lt_0_pow x n : 0 < x ->  0 < Nat.pow x n.

Lemma pow_le_compat x y n:
  x <= y -> Nat.pow x n <= Nat.pow y n.

End pow.

Lemma length_filter (A B : Type) (c : B -> bool) (f : A -> B) (xs : list A) :
  length (filter (fun x => c (f x)) xs) =
  length (filter c (map f xs)).

Section Sublist.

Inductive sublist (A : Type) : (list A) -> (list A) -> Prop :=
| sublist_refl : forall l, sublist l l
| sublist_skip : forall l1 h t, sublist l1 t -> sublist l1 (h :: t)
| sublist_cons : forall h t1 t2, sublist t1 t2 -> sublist (h :: t1) (h :: t2).

Hint Constructors sublist.

Lemma sublist_nil A (l : list A) : sublist [] l.

Lemma sublist_incl A (l1 l2 : list A) : sublist l1 l2 -> incl l1 l2.

Lemma sublist_app_skip A (l1 l2 l3 : list A) : sublist l1 l3 -> sublist l1 (l2 ++ l3).

Lemma sublist_app_left A (l1 l2 l3 : list A) : sublist l1 l3 -> sublist (l2 ++ l1) (l2 ++ l3).

Lemma sublist_app_compat A (l1 l2 l3 l4 : list A) :
  sublist l1 l3 -> 
  sublist l2 l4 ->
  sublist (l1 ++ l2) (l3 ++ l4).

Lemma sublist_flatmap_in_ext A B (f : A -> list B) g l: 
  (forall x : A , In x l -> sublist (f x) (g x)) ->
  sublist (flat_map f l) (flat_map g l).

Lemma NoDup_sublist A (l1 l2 : list A) : sublist l1 l2 -> NoDup l2 -> NoDup l1.

End Sublist.

Section Compat.

Lemma NoDup_map_inv A B (f:A->B) l : NoDup (map f l) -> NoDup l.

End Compat.

Lemma In_In_list_decompose {A} (x y : A) l : In x l -> In y l ->
  x = y \/
  exists l1 l2 l3, (l = l1 ++ x :: l2 ++ y :: l3) \/ (l = l1 ++ y :: l2 ++ x :: l3).

Section Lexicographic_Product.

Variables A B : Type.

Variable ltA : A -> A -> Prop.

Variable ltB : B -> B -> Prop.

Hypothesis wf_ltA : well_founded ltA.

Hypothesis wf_ltB : well_founded ltB.

Inductive lexprod : A*B -> A*B -> Prop :=
| lex_l : forall a a' b b', ltA a a' -> lexprod (a, b) (a', b')
| lex_r : forall a    b b', ltB b b' -> lexprod (a, b) (a,  b').

Lemma acc_lex a b : Acc ltA a -> Acc ltB b -> Acc lexprod (a, b).

Lemma lexprod_trans :
  (forall a1 a2 a3, ltA a1 a2 -> ltA a2 a3 -> ltA a1 a3) ->
  (forall b1 b2 b3, ltB b1 b2 -> ltB b2 b3 -> ltB b1 b3) ->
  forall x1 x2 x3, lexprod x1 x2 -> lexprod x2 x3 -> lexprod x1 x3.

Lemma wf_lexprod : well_founded lexprod.

Definition lex_prod_dec: 
  (forall a1 a2 : A, {a1 = a2} + {a1 <> a2}) ->
  (forall a1 a2, {ltA a1 a2} + {~ltA a1 a2}) ->
  (forall b1 b2, {ltB b1 b2} + {~ltB b1 b2}) ->
  (forall x y, {lexprod x y} + {~ lexprod x y}).

End Lexicographic_Product.

Section Last.

Lemma non_empty_last (A:Type) d d' (l:list A):
  l <> [] -> (last l d) = (last l d').

Lemma cons_cons_last (A:Type) (a b:A) l x:
  last (a::b::l) x = last (b::l) x.

Lemma cons_last (A:Type) (a:A) l x:
  last (a::l) x = last l a.

Lemma last_in (A:Type) (l:list A) x:
  (last l x = x) \/ (In (last l x) l).

End Last.

Lemma beq_eq_dec {A : Type} {beq : A -> A -> bool} (Hbeq : forall x y, beq x y = true <-> x = y) : forall (x y : A), {x = y} + {~ x = y}.

Section Firstn_skipn.
Lemma firstn_map {A B : Type} (f : A -> B) l n : 
  firstn n (map f l) = map f (firstn n l).

Lemma skipn_map {A B : Type} (f : A -> B) l n : 
  skipn n (map f l) = map f (skipn n l).

Lemma skipn_app_length {A : Type} (l1 l2 : list A) : skipn (length l1) (l1 ++ l2) = l2.

Lemma firstn_app_length {A : Type} (l1 l2 : list A) : firstn (length l1) (l1 ++ l2) = l1.

Lemma skipn_nil : forall {A} n (x : list A),
  length x <= n -> skipn n x = nil.

Lemma firstn_seq n start len :
  firstn n (seq start len) = seq start (min n len).

Lemma skipn_seq n start len :
  skipn n (seq start len) = seq (start+n) (len-n).

Lemma skipn_firstn {A:Type} n (l:list A):
  skipn n (firstn n l) = [].

Lemma skipn_incl {A:Type} (l:list A) n:
  incl (skipn n l) l.

Lemma skipn_app2 {A : Type} (l l' : list A) n:
  length l = n → skipn n (l ++ l') = l'.

Lemma firstn_app {A} (l l' : list A) : 
  firstn (length l) (l ++ l') = l.

Lemma firstn_app2 : forall (A : Type) (l l' : list A) n, 
 length l = n -> firstn n (l ++ l') = l .
End Firstn_skipn.

Section Ints.
Definition ints (n m:nat):list nat := seq n (m-n). 
Lemma ints_bounded : ∀ (x n m:nat),
  n ≤ m → x ∈ (ints n m) → n ≤ x < m.

Lemma ints_bounds : ∀ (x n m:nat),
  n ≤ x < m → x ∈ (ints n m).

Lemma ints_bounds_iff: ∀ x n m,
  n ≤ m → (n ≤ x < m ↔ x ∈ (ints n m)).

Lemma ints_length : ∀ n m,
  n ≤ m → length (ints n m) = m-n.
End Ints.

Section Forall.
Lemma Forall_cons_iff {A:Type} (x:A) (xs:list A) (P:A→Prop):
  Forall P (x::xs) ↔ P x ∧ Forall P xs.
Lemma Forall_map_iff {A B:Type} (f: A → B) l (P: B → Prop):
  (∀ x, x ∈ l → P (f x)) ↔ Forall P (map f l).
Lemma Forall_app_iff {A:Type} (P:A→Prop) l1 l2:
  Forall P (l1++l2) ↔ Forall P l1 ∧ Forall P l2.

Lemma Forall_unary {A:Type} (P:A→Prop) a:
  Forall P [a] ↔ P a.

Lemma Forall_flat_map {A B:Type} (P:B → Prop) (f:A → list B) l:
  Forall P (flat_map f l) ↔ Forall (λ x, Forall P (f x)) l.
End Forall.

Section Concat.
Lemma concat_unary_is_map {A B:Type}: ∀ l (f:A→B),
  concat (map (λ x, [f x]) l) = map f l.
Lemma in_concat_const_is_in {A B:Type} (a:A) lfix l:
  a ∈ concat (map (λ _ : B, lfix) l) ↔ l ≠ [] ∧ a ∈ lfix.
End Concat.

Section Incl.
Lemma incl_nil {A:Type} (l:list A): incl [] l.

Lemma incl_map_flat_map {A B:Type} (xs:list A) (f:A → B) g:
  (∀ x : A, x ∈ xs → f x ∈ g x) →
  incl (map f xs) (flat_map g xs).

Lemma incl_flat_map_incl {A B C:Type} (xs:list A) (r:A→list B) (rh:B→list C) lh:
  (∀ x : A, x ∈ xs → incl (flat_map rh (r x)) (lh x)) →
  incl (flat_map rh (concat (map r xs))) (flat_map lh xs).
End Incl.

Section Append.
Lemma app_length_eq {A:Type}:
  ∀ (l1 l2 l1' l2': list A),
  length l1 = length l1' → (l1++l2) = (l1'++l2') →
  l1 = l1' ∧ l2 = l2'.
End Append.

Section Forall2.
Lemma Forall2_le_refl l: Forall2 le l l.

Lemma Forall2_app_inv {A B:Type} (P:A→B→Prop) la1 la2 lb1 lb2:
  length la1 = length lb1 → Forall2 P (la1++la2) (lb1++lb2) →
  Forall2 P la1 lb1 ∧ Forall2 P la2 lb2.

Lemma Forall2_firstn {A B:Type} (P:A→B→Prop) la lb n:
  Forall2 P la lb → Forall2 P (firstn n la) (firstn n lb).

Lemma Forall2_skipn {A B:Type} (P:A→B→Prop) la lb n:
  Forall2 P la lb → Forall2 P (skipn n la) (skipn n lb).

Lemma Forall2_firstn_skipn_iff {A B:Type} (P:A→B→Prop) la lb n:
  Forall2 P la lb ↔ Forall2 P (firstn n la) (firstn n lb) ∧ Forall2 P (skipn n la) (skipn n lb).

Lemma Forall2_tail {A B:Type} (P:A→B→Prop) la lb:
  Forall2 P la lb → Forall2 P (tl la) (tl lb).
End Forall2. *)
(* Cecoa.Syntax:
Require Import Bool Arith Max List.
Import List.ListNotations.
Require Import Omega.
Require Import Cecoa.Lib.

Set Implicit Arguments.
Unset Strict Implicit.

Section Syntax.

Variables variable function constructor : Type.
Variable max_arity : nat.

Inductive value : Type :=
| c_capply : constructor -> list value -> value.

Inductive term : Type :=
| var : variable -> term
| capply : constructor -> list term -> term
| fapply : function -> list term -> term.

Inductive pattern : Type :=
| p_var : variable -> pattern
| p_capply : constructor -> list pattern -> pattern.

Inductive rule : Type :=
| rule_intro : function -> list pattern -> term -> rule.

Lemma value_ind2_gen :
  forall (P : value -> Type)(Q : list value -> Type),
  Q nil ->
  (forall v l, P v -> Q l -> Q (v :: l)) ->
  (forall c l, Q l -> P (c_capply c l)) ->
  forall v, P v.

Lemma term_ind2_gen :
  forall (P : term -> Prop)(Q : list term -> Prop),
  Q nil ->
  (forall t l, P t -> Q l -> Q (t :: l)) ->
  (forall x, P (var x)) ->
  (forall c l, Q l -> P (capply c l)) ->
  (forall f l, Q l -> P (fapply f l)) ->
  forall t, P t.

Lemma term_ind2 :
  forall (P : term -> Prop),
  (forall x, P (var x)) ->
  (forall c l, (forall t, In t l -> P t) -> P (capply c l)) ->
  (forall f l, (forall t, In t l -> P t) -> P (fapply f l)) ->
  forall t, P t.

Lemma pattern_ind2_gen :
  forall (P : pattern -> Prop)(Q : list pattern -> Prop),
  Q nil ->
  (forall p l, P p -> Q l -> Q (p :: l)) ->
  (forall x, P (p_var x)) ->
  (forall c l, Q l -> P (p_capply c l)) ->
  forall p, P p.

Lemma pattern_ind2 :
  forall (P : pattern -> Prop),
  (forall x, P (p_var x)) ->
  (forall c l, (forall p, In p l -> P p) -> P (p_capply c l)) ->
  forall p, P p.

Variable variable_eq_dec : forall (x1 x2 : variable), {x1=x2}+{x1<>x2}.

Definition variable_beq (x1 x2 : variable) : bool :=
  if variable_eq_dec x1 x2 then true else false.

Lemma variable_beq_eq : forall x1 x2, variable_beq x1 x2 = true <-> x1 = x2.

Variable function_eq_dec : forall (x1 x2 : function), {x1=x2}+{x1<>x2}.

Definition function_beq (x1 x2 : function) : bool :=
  if function_eq_dec x1 x2 then true else false.

Lemma function_beq_eq : forall x1 x2, function_beq x1 x2 = true <-> x1 = x2.

Variable constructor_eq_dec : forall (x1 x2 : constructor), {x1=x2}+{x1<>x2}.

Definition constructor_beq (x1 x2 : constructor) : bool :=
  if constructor_eq_dec x1 x2 then true else false.

Lemma constructor_beq_eq : forall x1 x2, constructor_beq x1 x2 = true <-> x1 = x2.

Fixpoint value_beq (v1 v2 : value) : bool :=
  match v1, v2 with
  | c_capply c lv, c_capply c' lv' => constructor_beq c c' && list_beq _ value_beq lv lv'
  end.

Lemma value_ind2 :
  forall (P : value -> Prop),
  (forall c l, (forall v, In v l -> P v) -> P (c_capply c l)) ->
  forall v, P v.

Lemma value_beq_eq v1 v2 : value_beq v1 v2 = true <-> v1 = v2.

Fixpoint term_beq (t1 t2 : term) : bool :=
  match t1, t2 with
  | var x, var x' => variable_beq x x'
  | capply c lt, capply c' lt' => constructor_beq c c' && list_beq _ term_beq lt lt'
  | fapply f lt, fapply f' lt' => function_beq f f' && list_beq _ term_beq lt lt'
  | _, _ => false
  end.

Lemma term_beq_eq t1 t2 : term_beq t1 t2 = true <-> t1 = t2.

Fixpoint pattern_from_value (v : value) : pattern  :=
  match v with
    | c_capply c lv => p_capply c (map pattern_from_value lv)
  end.

Fixpoint term_from_value (v : value) : term :=
  match v with
  | c_capply c lc => capply c (map term_from_value lc)
  end.

Coercion term_from_value : value >-> term.

Lemma term_from_value_not_var : forall v x, ~ term_from_value v = var x.

Lemma term_from_value_not_fapply : forall v f lt, ~ term_from_value v = fapply f lt.

Lemma term_from_value_injective (v v': value) :
  term_from_value v = term_from_value v' -> v = v'.

Fixpoint term_from_pattern (p : pattern) : term :=
  match p with
  | p_var v => var v
  | p_capply c lp => capply c (map term_from_pattern lp)
  end.

Coercion term_from_pattern : pattern >-> term.

Lemma term_from_pattern_not_fapply : forall v f lt, ~ term_from_pattern v = fapply f lt.

Fixpoint term_value (t: term) : Prop :=
  match t with
    | capply _ lt => andl (map term_value lt)
    | _ => False
  end.

Lemma term_value_eqv (t: term) :
  term_value t <-> exists (v: value), t = term_from_value v.

Fixpoint vars_of_term (t : term) : list variable :=
  match t with
  | var x => [x]
  | capply _ lt => flat_map vars_of_term lt
  | fapply _ lt => flat_map vars_of_term lt
  end.

Fixpoint vars_of_pattern (p : pattern) : list variable :=
  match p with
  | p_var x => [x]
  | p_capply _ lp => flat_map vars_of_pattern lp
  end.

Lemma vars_of_pattern_term p : vars_of_pattern p = vars_of_term (term_from_pattern p).

Fixpoint functions_of_term (t:term) : list function :=
  match t with
    | var _       => []
    | capply _ lt => flat_map functions_of_term lt
    | fapply f lt => f :: flat_map functions_of_term lt
  end.

Fixpoint fapplies_in_term (t: term) : list term :=
  match t with
  | var _       => []
  | capply _ lt =>      flat_map fapplies_in_term lt
  | fapply _ lt => t :: flat_map fapplies_in_term lt
  end.

Lemma fapplies_in_term_are_fapplies t1 t2 :
  In t1 (fapplies_in_term t2) ->
  exists f lt, t1 = fapply f lt.

Lemma fapplies_in_value_nil (v: value) :
  fapplies_in_term (@term_from_value v) = [].

Fixpoint max_arity_pattern (p : pattern) : nat :=
  match p with
  | p_var _ => 0
  | p_capply _ lp => max (length lp) (maxl (map max_arity_pattern lp))
  end.

Fixpoint max_arity_term (t : term) : nat :=
  match t with
    | var _ => 0
    | capply _ lt => max (length lt) (maxl (map max_arity_term lt))
    | fapply _ lt => max (length lt) (maxl (map max_arity_term lt))
  end.

Definition max_arity_rule (r : rule) : nat :=
  match r with
  | rule_intro _ lp t => max (max_arity_term t) (max (length lp) (maxl (map max_arity_pattern lp)))
  end.

Definition max_arity_prog (prog : list rule) : nat :=
  maxl (map max_arity_rule prog).

Definition rule_vars_defined (r : rule) : Prop :=
  match r with
  | rule_intro _ lp t => incl (vars_of_term t) (flat_map vars_of_pattern lp)
  end.

Definition wf_prog (prog : list rule) : Prop :=
  andl (map rule_vars_defined prog) /\ max_arity_prog prog <= max_arity.

Fixpoint subst (s : variable -> value)(t : term) : term :=
  match t with
  | var x => s x
  | capply c lt => capply c (map (subst s) lt)
  | fapply f lt => fapply f (map (subst s) lt)
  end.

Fixpoint psubst (s : variable -> value)(p : pattern) : value :=
  match p with
  | p_var x => s x
  | p_capply c lp => c_capply c (map (psubst s) lp)
  end.

Lemma subst_not_var : forall s t x, ~ subst s t = var x.

Lemma subst_psubst s p : subst s (term_from_pattern p) = term_from_value (psubst s p).

Fixpoint value_size (v : value) : nat :=
  match v with
  | c_capply _ lv => 1 + suml (map value_size lv)
  end.

Fixpoint term_size (t : term) :=
  match t with
  | var _ => 1
  | capply _ lt => 1 + suml (map term_size lt)
  | fapply _ lt => 1 + suml (map term_size lt)
  end.

Lemma gt_term_size_O t : term_size t > 0.

Lemma in_capply_term_size_lt c (t : term) lt :
  In t lt ->
  term_size t < term_size (capply c lt).

Lemma in_fapply_term_size_lt f (t : term) lt :
  In t lt ->
  term_size t < term_size (fapply f lt).

Definition rhs_of_rule (r : rule) : term :=
  match r with rule_intro _ _ t => t end.

Definition lhs_of_rule (r : rule) : term :=
  match r with rule_intro f lp _ => fapply f (map term_from_pattern lp) end.

Definition max_rhs (prog : list rule) : nat :=
  maxl (map term_size (map rhs_of_rule prog)).

Lemma compatible_sizes: forall v, term_size (term_from_value v) = value_size v.

Definition max_size_image_subst (t : term) (s : variable -> value) : nat :=
  maxl (map value_size (map s (vars_of_term t))).

Lemma incl_le_max_size_image_subst :
  forall s t u,
  incl (vars_of_term t) (vars_of_term u) -> max_size_image_subst t s <= max_size_image_subst u s.

Lemma step_one: forall s t, term_size (subst s t) <= term_size t * (1 + max_size_image_subst t s).

Lemma size_subst_var_le_size_value:
  forall p s (x:variable) v, v = psubst s p -> In x (vars_of_pattern p) -> value_size (s x) <= value_size v.

Lemma max_size_image_subst_bounded :
  forall t s, max_size_image_subst t s <= term_size (subst s t).

Definition activation_bound (prog : list rule) : nat -> nat :=
  fun x => max_rhs prog * (1 + x).

Lemma activation_bound_monotone (prog : list rule) :
  forall x y, x <= y -> activation_bound prog x <= activation_bound prog y.

Definition nb_rhs_functions (r: rule) :=
  match r with
    | rule_intro _ _ t => length (functions_of_term t)
  end.

Definition max_nb_rhs_functions (prog : list rule) : nat :=
  maxl (map nb_rhs_functions prog).

Lemma no_func_in_pattern p:
  functions_of_term (term_from_pattern p) = [].

Lemma no_funcs_in_patterns l:
  flat_map functions_of_term (map term_from_pattern l) = [].

End Syntax.

Arguments var [variable function constructor].

Arguments p_var [variable constructor]. *)
(* Cecoa.CBV_cache:
Require Import Omega Psatz.
Require Import Bool Arith Compare_dec Max List Permutation.
Import List.ListNotations.
Require Import Cecoa.Lib Cecoa.Syntax.

Set Implicit Arguments.
Unset Strict Implicit.

Section CBV.

Variables variable function constructor : Type.

Variable variable_eq_dec : forall (x1 x2 : variable), {x1=x2}+{x1<>x2}.

Variable function_eq_dec : forall (x1 x2 : function), {x1=x2}+{x1<>x2}.

Variable constructor_eq_dec : forall (x1 x2 : constructor), {x1=x2}+{x1<>x2}.

Notation value := (Syntax.value constructor).
Notation term := (Syntax.term variable function constructor).
Notation pattern := (Syntax.pattern variable constructor).
Notation rule := (Syntax.rule variable function constructor).
Notation term_beq := (term_beq variable_eq_dec function_eq_dec constructor_eq_dec).

Definition cache : Type := list (term * value).

Notation assoc_cache := (assoc term_beq).

Definition cache_beq (C C' : cache) : bool :=
  list_beq _ (prod_beq _ _ term_beq (value_beq constructor_eq_dec)) C C'.

Lemma cache_beq_eq c1 c2 : cache_beq c1 c2 = true <-> c1 = c2.

Lemma function_beq_refl (f : function) :
  forall p, function_beq p f f = true.

Lemma value_beq_refl (v : value) :
  value_beq constructor_eq_dec v v = true.

Lemma cache_beq_refl C :
  cache_beq C C = true.

Inductive cbv : Type :=
| cbv_constr : list cbv -> cache -> term -> cache -> value -> cbv
| cbv_split : list cbv -> cbv -> cache -> term -> cache -> value -> cbv
| cbv_update : nat -> (variable -> value) -> cbv -> cache -> term -> cache -> value -> cbv
| cbv_read : cache -> term -> value -> cbv.

Lemma cbv_ind2_gen :
  forall (P : cbv -> Prop)(Q : list cbv -> Prop),
  Q nil ->
  (forall p lp, P p -> Q lp -> Q (p :: lp)) ->
  (forall lp c1 t c2 v, Q lp -> P (cbv_constr lp c1 t c2 v)) ->
  (forall lp p c1 t c2 v, Q lp -> P p -> P (cbv_split lp p c1 t c2 v)) ->
  (forall n s p c1 t c2 v, P p -> P (cbv_update n s p c1 t c2 v)) ->
  (forall c t v, P (cbv_read c t v)) ->
  forall p, P p.

Lemma cbv_ind2 :
  forall (P : cbv -> Prop),
  (forall lp c1 t c2 v, (forall p, In p lp -> P p) -> P (cbv_constr lp c1 t c2 v)) ->
  (forall lp p c1 t c2 v, (forall p, In p lp -> P p) -> P p -> P (cbv_split lp p c1 t c2 v)) ->
  (forall n s p c1 t c2 v, P p -> P (cbv_update n s p c1 t c2 v)) ->
  (forall c t v, P (cbv_read c t v)) ->
  forall p, P p.

Fixpoint InCBV p proof_tree : Prop :=
  p = proof_tree \/
  match proof_tree with
      | cbv_constr lp _ _ _ _ => orl (map (InCBV p) lp)
      | cbv_split lp p' _ _ _ _ => InCBV p p' \/ orl (map (InCBV p) lp)
      | cbv_update _ _ p' _ _ _ _ => InCBV p p'
      | cbv_read _ _ _ => False
  end.

Lemma InCBV_refl p : InCBV p p.

Lemma InCBV_trans p p' p'': InCBV p p' -> InCBV p' p'' -> InCBV p p''.

Lemma cbv_reverse_induction :
  forall (P : cbv -> Prop) proof_tree,
  P proof_tree ->
  (forall lp c1 t c2 v, InCBV (cbv_constr lp c1 t c2 v) proof_tree -> P (cbv_constr lp c1 t c2 v) -> forall p, In p lp -> P p) ->
  (forall lp p c1 t c2 v, InCBV (cbv_split lp p c1 t c2 v) proof_tree -> P (cbv_split lp p c1 t c2 v) -> forall p', (p' = p \/ In p' lp) -> P p') ->
  (forall i s p c1 t c2 v, InCBV (cbv_update i s p c1 t c2 v) proof_tree -> P (cbv_update i s p c1 t c2 v) -> P p) ->
  forall p, InCBV p proof_tree -> P p.

Definition rule_subst_of_cbv_update ( subst_default : variable -> value) (proof_tree : cbv) : nat * (variable -> value) :=
  match proof_tree with
  | cbv_update i s _ _ _ _ _ => (i, s)
  | _ => (0, subst_default) 
  end.

Definition proj_left (proof_tree : cbv) : term :=
  match proof_tree with
    | cbv_constr _ _ t _ _ => t
    | cbv_split _ _ _ t _ _ => t
    | cbv_update _ _ _ _ t _ _ => t
    | cbv_read _ t _ => t
  end.

Definition proj_right (proof_tree : cbv) : value :=
  match proof_tree with
    | cbv_constr _ _ _ _ v => v
    | cbv_split _ _ _ _ _ v => v
    | cbv_update _ _ _ _ _ _ v => v
    | cbv_read _ _ v => v
  end.

Definition cache_left (proof_tree : cbv) : cache :=
  match proof_tree with
    | cbv_constr _ c _ _ _ => c
    | cbv_split _ _ c _ _ _ => c
    | cbv_update _ _ _ c _ _ _ => c
    | cbv_read c _ _ => c
  end.

Definition cache_right (proof_tree : cbv) : cache :=
  match proof_tree with
    | cbv_constr _ _ _ c _ => c
    | cbv_split _ _ _ _ c _ => c
    | cbv_update _ _ _ _ _ c _ => c
    | cbv_read c _ _ => c
  end.

Fixpoint cache_path (C C' : cache)(l : list cbv) : bool :=
  match l with
  | nil => cache_beq C C' 
  | p :: l' => cache_beq C (cache_left p) && cache_path (cache_right p) C' l'
  end.

Lemma cache_path_cons c1 c2 p lp :
  cache_path c1 c2 (p :: lp) = true <->
  cache_path c1 (cache_right p) [p] = true /\ cache_path (cache_right p) c2 lp = true.

Lemma cache_path_app c1 c2 lp p lp' :
  cache_path c1 c2 (lp ++ p :: lp') = true <-> 
  cache_path c1 (cache_left p) lp = true /\ cache_path (cache_left p) c2 (p :: lp') = true.

Lemma cache_path_ind (P : cache -> cache -> list cbv -> Prop) C :
  (P C C []) ->
  (forall p lp, cache_path (cache_left p) C (p :: lp) = true -> P (cache_right p) C lp ->
   P (cache_left p) C (p :: lp)) ->
  forall lp C', cache_path C' C lp = true -> P C' C lp.

Lemma cache_path_revflatten c1 c2 lp Clp :
  cache_path c1 c2 lp = true ->
  Forall2 (fun p C => cache_right p = C ++ cache_left p) lp Clp ->
  c2 = revflatten Clp ++ c1.

Lemma cache_path_transitivity_left c c' l: forall P:cache-> Prop, 
      cache_path c c' l = true ->
      P c ->(forall p, In p l -> 
      P (cache_left p) ->  
      P (cache_right p)) -> 
     (forall p, In p l -> P (cache_left p)).

Lemma cache_path_transitivity c c' l: forall P:cache-> Prop, 
      cache_path c c' l = true ->
      P c ->(forall p, In p l -> 
      P (cache_left p) ->  
      P (cache_right p)) -> P c'.

Fixpoint cache_lookup (C: cache) (t: term) : term :=
  match t with
  | var _       => t
  | capply c lt => capply c (map (cache_lookup C) lt)
  | fapply f lt => match assoc_cache (fapply f (map (cache_lookup C) lt)) C with
                   | Some v => @term_from_value _ _ _ v
                   | None   => t
                   end
  end.

Lemma cache_lookup_value (C: cache) (v: value):
  let t := @term_from_value _ _ _ v in cache_lookup C t = t.

Lemma map_cache_lookup_value (C: cache) (lv: list value):
  let lt := map (@term_from_value _ _ _) lv in map (cache_lookup C) lt = lt.

Variable rule_default : rule.

Variable prog : list rule.

Variable max_arity : nat.

Fixpoint wf (proof_tree : cbv) : Prop :=
  match proof_tree with
    | cbv_constr l C (capply c lt) C' (c_capply c' lv) =>
        cache_path C C' l = true /\
        c = c' /\
        lt = map proj_left l /\ lv = map proj_right l /\
        andl (map wf  l) /\ List.length l <= max_arity
    | cbv_split l ((cbv_update _ _ _ C' (fapply f lv) C'' v) as p) C (fapply f' lt) C''' v' =>
        C''' = C'' /\
        cache_path C C' l = true /\
        lt = map proj_left l /\ lv = map (@term_from_value _ _ _) (map proj_right l) /\
        andl (map wf  l) /\
        f = f' /\ v = v' /\
        wf  p /\ length l <= max_arity
    | cbv_split l ((cbv_read C' (fapply f lv) v) as p) C (fapply f' lt) C'' v' =>
        C'' = C' /\
        cache_path C C' l = true /\
        lt = map proj_left l /\ lv = map (@term_from_value _ _ _) (map proj_right l) /\
        andl (map wf  l) /\
        f = f' /\ v = v' /\
        wf  p /\ length l <= max_arity
    | cbv_update i s p C (fapply f lv as t0) C' v =>
        assoc term_beq t0 C = None /\
        exists lp t,
        i < length prog /\
        nth i prog rule_default = rule_intro f lp t /\
        lv = map (@term_from_value _ _ _) (map (psubst s) lp) /\
        proj_left p = subst s t /\ proj_right p = v /\
        cache_left p = C /\  True /\
        C' = (t0, v) :: cache_right p /\ 
        wf  p /\ length lv <= max_arity
    | cbv_read C (fapply _ lv as t) v =>
        assoc term_beq t C = Some v /\
        exists lv', lv = map (@term_from_value _ _ _) lv'
    | _ => False
  end.

Lemma wf_cbv_update i s p c1 t c2 v : wf (cbv_update i s p c1 t c2 v) -> wf p.

Lemma wf_InCBV_wf p proof_tree: wf proof_tree -> InCBV p proof_tree -> wf p.

Definition cache_size (c : cache) : nat :=
  suml (map (fun tv => term_size (fst tv) + value_size (snd tv)) c).

Fixpoint size_rec (proof_tree : cbv) : nat :=
  match proof_tree with
  | cbv_constr l c1 t c2 v => term_size t + value_size v + suml (map size_rec l)
  | cbv_split l p c1 t c2 v => term_size t + value_size v + size_rec p + suml (map size_rec l)
  | cbv_update _ _ p c1 t c2 v => size_rec p + term_size t + value_size v
  | cbv_read c t v => term_size t + value_size v
  end.

Definition size (proof_tree : cbv) : nat :=
  size_rec proof_tree + cache_size (cache_left proof_tree).

Fixpoint max_active_size (proof_tree : cbv) : nat :=
  match proof_tree with
  | cbv_constr lp _ _ _ _ => maxl (map max_active_size lp)
  | cbv_split lp p _ _ _ _ => max (max_active_size p) (maxl (map max_active_size lp)) 
  | cbv_update _ _ p _ t _ v => max (term_size t + value_size v) (max_active_size p)
  | cbv_read c t v => 0
  end.

Fixpoint max_judgement_size (proof_tree : cbv) : nat :=
  match proof_tree with
  | cbv_constr lp c1 t c2 v => max (term_size t + value_size v) (maxl (map max_judgement_size lp))
  | cbv_split lp p c1 t c2 v => max (term_size t + value_size v) (max (max_judgement_size p) (maxl (map max_judgement_size lp)))
  | cbv_update _ _ p c1 t c2 v => max (term_size t + value_size v) (max_judgement_size p)
  | cbv_read c t v => term_size t + value_size v
  end.

Fixpoint sub_trees (proof_tree : cbv) : list cbv :=
  proof_tree :: (
    match proof_tree with
    | cbv_constr lp _ _ _ _ => flat_map sub_trees lp
    | cbv_split lp p _ _ _ _ => flat_map sub_trees (p :: lp)
    | cbv_update _ _ p _ _ _ _ => sub_trees p
    | cbv_read _ _ _ => []
    end ).

Lemma sub_trees_neq_nil : forall p, sub_trees p <> [].

Lemma InCBV_In_sub_trees p p' : InCBV p p' <-> In p (sub_trees p').

Lemma sub_trees_size_rec_le p proof_tree :
  In p (sub_trees proof_tree) -> size_rec p <= size_rec proof_tree.

Fixpoint proj_left_max_size_list (default : cbv) (proof_trees : list cbv) : cbv :=
  match proof_trees with
    | [] => default
    | [p] => p
    | p :: ps =>
      let p' := proj_left_max_size_list default ps in
      if leb (term_size (proj_left p)) (term_size (proj_left p')) then p' else p
  end.

Lemma In_proj_left_max_size_list p lp : lp <> [] -> In (proj_left_max_size_list p lp) lp.

Lemma proj_left_size_le_max_gen default proof_trees proof_tree:
  In proof_tree proof_trees ->
  term_size (proj_left proof_tree) <= term_size (proj_left (proj_left_max_size_list default proof_trees)).

Definition proj_left_max_size (proof_tree : cbv) : cbv :=
  proj_left_max_size_list (proof_tree) (sub_trees proof_tree).

Lemma proj_left_size_le_max proof_tree:
  forall p, InCBV p proof_tree ->
  term_size (proj_left p) <= term_size (proj_left (proj_left_max_size proof_tree)).

Lemma InCBV_proj_left_max_size p : InCBV (proj_left_max_size p) p.

Fixpoint max_proj_right_size (proof_tree : cbv) : nat :=
  match proof_tree with
  | cbv_constr lp _ t _ v => max (value_size v) (maxl (map max_proj_right_size lp))
  | cbv_split lp p _ t _ v => max (value_size v) (max (max_proj_right_size p) (maxl (map max_proj_right_size lp)))
  | cbv_update _ _ p _ t _ v => max (value_size v) (max_proj_right_size p)
  | cbv_read _ t v => value_size v
  end.

Lemma judgement_size_le_projs_size p :
  max_judgement_size p <= term_size (proj_left (proj_left_max_size p)) + max_proj_right_size p.

Fixpoint activations (proof_tree : cbv) : list cbv :=
  match proof_tree with
  | cbv_constr lp _ _ _ _ => flat_map activations lp
  | cbv_split lp p _ _ _ _ => activations p ++ flat_map activations lp
  | cbv_update _ _ p _ _ _ _ as p' => p' :: activations p
  | cbv_read _ _ _ => []
  end.

Fixpoint activations_cache_order (proof_tree : cbv) : list cbv :=
  match proof_tree with
  | cbv_constr lp _ _ _ _ => revflatten (map activations_cache_order lp)
  | cbv_split lp p _ _ _ _ => activations_cache_order p ++ revflatten (map activations_cache_order lp)
  | cbv_update _ _ p _ _ _ _ as p' => p' :: activations_cache_order p
  | cbv_read _ _ _ => []
  end.

Lemma activations_cache_order_are_activations (p: cbv) :
  Permutation (activations p) (activations_cache_order p).

Lemma activations_are_subtrees: forall p pi:cbv,
   In p (activations pi) -> In p (sub_trees pi).

Corollary activations_inCBV: forall p pi:cbv,
   In p (activations pi) -> InCBV p pi.

Definition functions_of_prog : list function :=
  map (fun x => match x with | rule_intro f _ _ => f end) prog.

Lemma activation_is_function :
  forall proof_tree p,
  In p (activations proof_tree) -> exists i s p' c1 t c2 v, p = cbv_update i s p' c1 t c2 v.

Lemma cbv_update_in_activations_InCBV proof_tree sub_proof_tree i s p c1 t c2 v:
  sub_proof_tree = cbv_update i s p c1 t c2 v ->
  InCBV sub_proof_tree proof_tree ->
  In sub_proof_tree (activations proof_tree).

Lemma activations_wf : forall proof_tree p, wf proof_tree -> In p (activations proof_tree) -> wf p.

Lemma le_max_active_size proof_tree p :
  In p (activations proof_tree) ->
  term_size (proj_left p) + value_size (proj_right p) <= max_active_size proof_tree.

Hypothesis prog_is_wf : wf_prog max_arity prog.

Lemma activation_bound_spec ( subst_default : variable -> value) :
  forall proof_tree, wf proof_tree -> forall p, In p (activations proof_tree) ->
  let (i, s) := rule_subst_of_cbv_update subst_default p in
  term_size (subst s (rhs_of_rule (nth i prog rule_default))) <= activation_bound prog (term_size (proj_left p)).

Fixpoint nb_judgements (proof_tree : cbv) : nat :=
  match proof_tree with
  | cbv_constr lp _ _ _ _ => 1 + suml (map nb_judgements lp)
  | cbv_split lp p _ _ _ _ => 1 + nb_judgements p + suml (map nb_judgements lp)
  | cbv_update _ _ p _ _ _ _ => 1 + nb_judgements p
  | cbv_read _ _ _=> 1
  end.

Fixpoint nb_judgements_sub_rec (proof_tree : cbv) : nat :=
  match proof_tree with
  | cbv_constr lp _ _ _ _ => 1 + suml (map nb_judgements_sub_rec lp)
  | cbv_split lp p _ _ _ _ => 1 + nb_judgements_sub_rec p + suml (map nb_judgements_sub_rec lp)
  | cbv_update _ _ _ _ _ _ _ => 0
  | cbv_read _ _ _ => 0
  end.

Definition nb_judgements_sub (proof_tree : cbv) : nat :=
  match proof_tree with
  | cbv_constr _ _ _ _ _ => 0
  | cbv_split _ _ _ _ _ _ => 0
  | cbv_update _ _ p _ _ _ _ => nb_judgements_sub_rec p
 | cbv_read _ _ _ => 0
  end.

Fixpoint nb_nodes (proof_tree : cbv) : nat :=
  match proof_tree with
  | cbv_constr [] _ _ _ _ => 0
  | cbv_constr lp _ _ _ _ => 1 + suml (map nb_nodes lp)
  | cbv_split lp p _ _ _ _ => 1 + nb_nodes p + suml (map nb_nodes lp)
  | cbv_update _ _ p _ _ _ _ => 1 + nb_nodes p
  | cbv_read _ _ _ => 0
  end.

Fixpoint nb_read (proof_tree : cbv) : nat :=
  match proof_tree with
  | cbv_constr lp _ _ _ _ => suml (map nb_read lp)
  | cbv_split lp p _ _ _ _ => nb_read p + suml (map nb_read lp)
  | cbv_update _ _ p _ _ _ _ => nb_read p
  | cbv_read _ _ _ => 1
  end.

Definition arity_cbv (proof_tree : cbv) : nat :=
  match proof_tree with
  | cbv_constr lp _ _ _ _  => length lp
  | cbv_split lp p _ _ _ _ => 1 + length lp
  | cbv_update _ _ p _ _ _ _ => 1
  | cbv_read _ _ _ => 0
  end.

Lemma wf_arity p : wf p -> arity_cbv p <= S max_arity.

Lemma nb_read_bound : forall p,
   wf p ->
  nb_read p <= S (max_arity * nb_nodes p).

Fixpoint first_activations_rec (proof_tree : cbv) : list cbv :=
  match proof_tree with
  | cbv_constr lp _ _ _ _ => flat_map first_activations_rec lp
  | cbv_split lp p _ _ _ _ => first_activations_rec p ++ flat_map first_activations_rec lp
  | cbv_update _ _ _ _ _ _ _ as p' => [p']
  | cbv_read _ _ _ => []
  end.

Definition first_activations (proof_tree : cbv) : list cbv :=
  match proof_tree with
  | cbv_constr lp _ _ _ _ => []
  | cbv_split lp p _ _ _ _ => []
  | cbv_update _ _ p _ _ _ _ => first_activations_rec p
  | cbv_read _ _ _ => []
  end.

Definition strict_activations (proof_tree: cbv) :=
  flat_map activations (first_activations proof_tree).

Lemma first_activation_rec_is_update proof_tree p :
  In p (first_activations_rec proof_tree) -> exists i s p' c1 t c2 v, p = cbv_update i s p' c1 t c2 v.

Lemma first_activation_is_update proof_tree p :
  In p (first_activations proof_tree) -> exists i s p' c1 t c2 v, p = cbv_update i s p' c1 t c2 v.

Lemma in_first_activations_rec_nb_judgements_le p proof_tree :
  In p (first_activations_rec proof_tree) -> nb_judgements p <= nb_judgements proof_tree.

Lemma in_first_activations_nb_judgements_lt p proof_tree :
  In p (first_activations proof_tree) -> nb_judgements p < nb_judgements proof_tree.

Lemma first_activations_rec_incl_activations (p: cbv) :
  incl (first_activations_rec p) (activations p).

Lemma first_activations_incl_activations (p: cbv) :
  incl (first_activations p) (activations p).

Fixpoint first_activations_and_semi_rec (proof_tree : cbv) : list cbv :=
  match proof_tree with
  | cbv_constr lp _ _ _ _          => flat_map first_activations_and_semi_rec lp
  | cbv_split lp p _ _ _ _         => first_activations_and_semi_rec p ++ flat_map first_activations_and_semi_rec lp
  | cbv_update _ _ _ _ _ _ _ as p' => [p']
  | cbv_read _ _ _ as p'           => [p']
  end.

Definition first_activations_and_semi (proof_tree : cbv) : list cbv :=
  match proof_tree with
  | cbv_constr lp _ _ _ _    => []
  | cbv_split lp p _ _ _ _   => []
  | cbv_update _ _ p _ _ _ _ => first_activations_and_semi_rec p
  | cbv_read _ _ _           => []
  end.

Lemma incl_first_activations_semi p :
  incl (first_activations p) (first_activations_and_semi p).

Lemma first_activations_and_semi_rec_incl_sub_trees p :
  incl (first_activations_and_semi_rec p) (sub_trees p).

Lemma first_activations_and_semi_incl_sub_trees p :
  incl (first_activations_and_semi p) (sub_trees p).

Lemma cbv_big_induction :
  forall (P : cbv -> Prop),
  (forall i s p c1 t c2 v, (forall p', In p' (first_activations (cbv_update i s p c1 t c2 v)) -> P p') -> P (cbv_update i s p c1 t c2 v)) ->
  forall i s p c1 t c2 v, P (cbv_update i s p c1 t c2 v).

Lemma activations_first_activations i s p' c1 t c2 v :
  let p := cbv_update i s p' c1 t c2 v in
  activations p = p :: flat_map activations (first_activations p).

Lemma cache_consistent p :
  wf p ->
  exists C,
    cache_beq (cache_right p) (C ++ cache_left p) = true /\
    (forall t, assoc_cache t C <> None -> assoc_cache t (cache_left p) = None).

Lemma cache_path_consistent c1 c2 lp :
  andl (map wf lp) ->
  cache_path c1 c2 lp = true ->
  forall p, In p lp ->
    exists c3,
      c2 = c3 ++ cache_right p /\
      (forall t, assoc_cache t c3 <> None -> assoc_cache t (cache_right p) = None).

Lemma cache_path_consistent_head C p lp :
  wf p -> andl (map wf lp) ->
  cache_path (cache_right p) C lp = true ->
    exists C',
      C = C' ++ cache_right p /\
      (forall t, assoc_cache t C' <> None -> assoc_cache t (cache_right p) = None).

Lemma assoc_cache_hd (f: function) (lv: list term) (v: value) (C: cache) :
  assoc_cache (fapply f lv) ((fapply f lv, v) :: C) = Some v.

Definition valid_cache_extension (ext base: cache) : Prop :=
  forall t: term, assoc_cache t ext <> None -> assoc_cache t base = None.

Lemma cache_extension_app (ext' ext base: cache) :
  valid_cache_extension ext' (ext ++ base) ->
  valid_cache_extension ext base ->
  valid_cache_extension (ext' ++ ext) base.

Definition cbv_cache_entry (proof_tree : cbv) := (proj_left proof_tree, proj_right proof_tree).

Lemma cache_content (proof_tree : cbv) :
  wf proof_tree ->
  cache_right proof_tree =
  map cbv_cache_entry (activations_cache_order proof_tree) ++
      cache_left proof_tree.

Lemma cache_content_on_path c1 c2 lp:
  andl (map wf lp) ->
  cache_path c1 c2 lp = true ->
  c2 = map cbv_cache_entry (revflatten (map activations_cache_order lp)) ++ c1.

Lemma cache_path_proj_left_in_tail_not_in_head t p lp c1 c2 :
  cache_path c1 c2 (p :: lp) = true ->
  andl (map wf (p :: lp)) ->
  In t (map proj_left (revflatten (map activations_cache_order lp))) ->
  ~ In t (map proj_left (activations_cache_order p)).

Lemma whole_cache_path_consistent lp : forall c1 c2,
  cache_path c1 c2 lp = true ->
  andl (map wf lp) ->
  exists C,
    cache_beq c2 (C ++ c1) = true /\
    (forall t, assoc_cache t C <> None -> assoc_cache t c1 = None).

Lemma cache_path_proj_left_not_in_init t lp c1 c2 :
  cache_path c1 c2 lp = true ->
  andl (map wf lp) ->
  In t (map proj_left (revflatten (map activations_cache_order lp))) ->
  ~ In t (map fst c1).

Lemma cache_lookup_term (p: cbv) (ext: cache):
  wf p ->
  (forall t: term, assoc_cache t ext <> None -> assoc_cache t (cache_right p) = None) ->
  cache_lookup (ext ++ cache_right p) (proj_left p) = @term_from_value _ _ _ (proj_right p).

Lemma first_activations_residues_activation i s p c1 t c2 v :
  let proof_tree := cbv_update i s p c1 t c2 v in
  wf proof_tree ->
  Forall2 (fun p' t' =>
    match (proj_left p', t') with
    | (fapply f lv, fapply f' lt) =>
      f = f' /\
      Forall2 (fun t v => cache_lookup (cache_left p') t = v) lt lv
    | _ => False
    end)
    (first_activations_and_semi proof_tree)
    (fapplies_in_term (proj_left p)).

Lemma nb_nodes_bound i s p' c1 t c2 v :
  let p := cbv_update i s p' c1 t c2 v in
  nb_nodes p <= suml (map nb_judgements_sub (activations p)) + length (activations p).

Lemma nb_judgements_bound i s p' c1 t c2 v :
  let p := cbv_update i s p' c1 t c2 v in
  nb_judgements p <= suml (map nb_judgements_sub (activations p)) + length (activations p) + nb_read p.

Lemma nb_judgements_sub_rec_bound p :
  wf p -> nb_judgements_sub_rec p <= term_size (proj_left p).

Lemma nb_judgements_sub_bound i s p c1 t c2 v :
  wf (cbv_update i s p c1 t c2 v) ->
  nb_judgements_sub (cbv_update i s p c1 t c2 v) <= activation_bound prog (term_size t).

Lemma right_from_activation_or_from_left p : wf p ->
  maxl (map (fun tv : term * value => value_size (snd tv)) (cache_right p)) <=
  max (max_active_size p) (maxl (map (fun tv : term * value => value_size (snd tv)) (cache_left p))).

Lemma right_from_activation_or_from_left_path lp c1 c2 : andl (map wf lp) ->
  cache_path c1 c2 lp = true ->
  maxl (map (fun tv : term * value => value_size (snd tv)) c2) <=
  max (maxl (map max_active_size lp)) (maxl (map (fun tv : term * value => value_size (snd tv)) c1)).

Lemma value_size_bounded_by_nb_judgements p :
  wf p -> value_size (proj_right p) <= (1 + max (max_active_size p) (maxl (map (fun tv => value_size (snd tv)) (cache_left p)))) * nb_judgements p.

Lemma size_bounded_nb_size_judgements p :
  size p <= nb_judgements p * max_judgement_size p + cache_size (cache_left p).

Lemma nb_judgements_sub_bound_gen : forall p p',
  let S := max_active_size p in
  wf p ->
  In p' (activations p) -> nb_judgements_sub p' <= activation_bound prog S.

Lemma nb_judgements_bound_gen : forall i s p' c1 t c2 v,
  let p := cbv_update i s p' c1 t c2 v in
  let A := length (activations p) in
  let S := max_active_size p in
  wf p ->
  nb_judgements p <= A * activation_bound prog S + A + (Datatypes.S (max_arity * nb_nodes p)).

Lemma cache_path_incl : forall lp c1 c2, 
  andl (map wf lp) -> cache_path c1 c2 lp = true -> incl c1 c2.

Lemma InCBV_cache_right_incl p proof_tree :
  wf proof_tree ->
  InCBV p proof_tree ->
  incl (cache_right p) (cache_right proof_tree).

Lemma InCBV_read_cache_right c t v p:
  wf p ->
  InCBV (cbv_read c t v) p ->
  In (t, v) (cache_right p).

Lemma term_size_proj_left_bound : forall i s p' c1 t c2 v,
  let p := cbv_update i s p' c1 t c2 v in
  let S := max_active_size p in
  wf p ->
  forall p',
  InCBV p' p -> term_size (proj_left p') <= activation_bound prog S + S + cache_size c1.

Lemma nb_nodes_bound_gen i s p' c1 t c2 v :
  let p := cbv_update i s p' c1 t c2 v in
  let A := length (activations p) in
  let S := max_active_size p in
  wf p ->
  nb_nodes p <= A * (1 + activation_bound prog S).

Lemma size_judgement : forall i s p' c1 t c2 v,
  let p := cbv_update i s p' c1 t c2 v in
  let A := length (activations p) in
  let S := max_active_size p in
  let C := maxl (map (fun tv : term * value => value_size (snd tv)) c1) in
  wf p ->
  max_judgement_size p <=
  activation_bound prog S + S + cache_size c1 +
  (1 + max S C) * (1 + (A * activation_bound prog S + A) + max_arity * (A * activation_bound prog S + A)).

Theorem size_bound_gen : forall i s p' c1 t c2 v,
  let p := cbv_update i s p' c1 t c2 v in
  let A := length (activations p) in
  let S := max_active_size p in
  wf p ->
  size p <=
  (A * activation_bound prog S + A + 1 + (max_arity * A * (1 + activation_bound prog S))) *
  (activation_bound prog S + S + cache_size c1 +
  (1 + max S (maxl (map (fun tv : term * value => value_size (snd tv)) c1))) *
  (1 + (A * activation_bound prog S + A) + max_arity * (A * activation_bound prog S + A))) +
  cache_size c1.

Corollary size_bound : forall i s p' t c v,
  let p := cbv_update i s p' [] t c v in
  let A := length (activations p) in
  let S := max_active_size p in
  wf p ->
  size p <=
  (A * activation_bound prog S + A + 1 + (max_arity * A * (1 + activation_bound prog S))) *
  (activation_bound prog S + S +
  (1 + S) *
  (1 + (A * activation_bound prog S + A) + max_arity * (A * activation_bound prog S + A))).

End CBV. *)
(* Cecoa.Bounds:
Require Import FunctionalExtensionality.
Require Import Arith Bool Omega Psatz Cecoa.Lib Cecoa.Syntax List Cecoa.CBV_cache Cecoa.Ordering.
Import List.ListNotations.

Section Bounds.

Variables variable function constructor : Type.

Variable variable_eq_dec : forall (x1 x2 : variable), {x1=x2}+{x1<>x2}.
Variable function_eq_dec : forall (x1 x2 : function), {x1=x2}+{x1<>x2}.
Variable constructor_eq_dec : forall (x1 x2 : constructor), {x1=x2}+{x1<>x2}.

Variable max_arity : nat.

Notation rule := (Syntax.rule variable function constructor).
Notation term := (Syntax.term variable function constructor).
Notation value := (Syntax.value constructor).
Notation cbv := (CBV_cache.cbv variable function constructor).

Variable prog : list rule.
Variable rule_default : rule.
Variable subst_default : variable -> value.

Notation assoc_cache := (assoc (term_beq variable_eq_dec function_eq_dec constructor_eq_dec)).

Notation wf :=
  (CBV_cache.wf variable_eq_dec function_eq_dec constructor_eq_dec rule_default prog max_arity).

Variable rank: function -> nat.

Variable max_rank : nat.

Hypothesis pos_max_rank : 0 < max_rank.

Hypothesis max_rank_is_max_rank : forall f, rank f <= max_rank.

Notation PPO_prog := (Ordering.PPO_prog prog rank).

Lemma NoDup_left_activations_cache_order i s p c1 t c2 v:
  PPO_prog ->
  wf (cbv_update i s p c1 t c2 v) ->
  NoDup (map (@proj_left _ _ _) (activations_cache_order (cbv_update i s p c1 t c2 v))).

Lemma NoDup_left_activations i s p c1 t c2 v:
  PPO_prog ->
  wf (cbv_update i s p c1 t c2 v) ->
  NoDup (map (@proj_left _ _ _) (activations (cbv_update i s p c1 t c2 v))).

Definition activations_at_rank (rk: nat) (p : cbv) : list cbv :=
  filter (fun p => beq_nat rk (activation_rank rank p)) (activations p).

Lemma activations_at_rank_incl_activations (rk: nat) (p: cbv) :
  incl (activations_at_rank rk p) (activations p).

Lemma activations_at_rank_wf (rk: nat) (p p': cbv) :
  wf p ->
  In p' (activations_at_rank rk p) ->
  wf p'.

Definition A_T (proof_tree: cbv) : nat :=
  maxl (map (fun p => length (activations_at_rank (activation_rank rank p) p)) (activations proof_tree)).

Definition activations_at_rank_bound (A_T: nat) (rank: nat) :=
  Nat.pow max_rank (max_rank - rank) *
  Nat.pow (max 1 (max_nb_rhs_functions prog)) (max_rank - rank) *
  Nat.pow A_T (S (max_rank - rank)).

Definition gary_seven_poly (A_T:nat) :=
  suml (map (activations_at_rank_bound A_T) (seq 0 (S max_rank))).

Lemma PPO_activation_rank_decreasing i s p c1 f lt c2 v:
  let proof_tree := cbv_update i s p c1 (fapply f lt) c2 v in
  PPO_prog ->
  wf proof_tree ->
  forall p, In p (activations proof_tree) ->
  activation_rank rank p <= rank f.

Hint Resolve lt_0_pow.

Hint Rewrite mult_1_l.

Fixpoint first_activations_at_given_rank (rk: nat) (proof_tree : cbv) : list cbv :=
  match proof_tree with
  | cbv_constr lp _ _ _ _ => flat_map (first_activations_at_given_rank rk) lp
  | cbv_split lp p _ _ _ _ => first_activations_at_given_rank rk p ++ flat_map (first_activations_at_given_rank rk) lp
  | cbv_update _ _ p _ (fapply f _) _ _ as p' => if eq_nat_dec rk (rank f)
                                                then [ p' ]
                                                else first_activations_at_given_rank rk p
  | _ => [] 
  end.

Definition activation_function (function_default : function) (p: cbv) :=
  match p with
    | cbv_update _ _ _ _ (fapply f _) _ _ => f
    | _                                   => function_default
  end.

Lemma first_activations_at_given_rank_rank rk p p' :
  In p' (first_activations_at_given_rank rk p) ->
  rk = activation_rank rank p'.

Lemma first_activations_at_given_rank_sublist_activations rk p :
  sublist (first_activations_at_given_rank rk p) (activations p).

Lemma NoDup_activations i s p c1 t c2 v : 
  PPO_prog ->
  wf (cbv_update i s p c1 t c2 v) ->
  NoDup (activations (cbv_update i s p c1 t c2 v)).

Lemma NoDup_first_activations_at_given_rank rk i s p c1 t c2 v : 
  PPO_prog ->
  wf (cbv_update i s p c1 t c2 v) ->
  NoDup (first_activations_at_given_rank rk (cbv_update i s p c1 t c2 v)).

Lemma first_activations_at_given_rank_activations rk p: 
  incl (first_activations_at_given_rank rk p) (activations p).

Lemma A_T_activation_rank (p p' : cbv) :
  In p' (first_activations_at_given_rank (activation_rank rank p') p) ->
    length (activations_at_rank (activation_rank rank p') p') <= A_T p.

Lemma activation_eq_dec p i s p0 c1 t c2 v:
  let proof_tree := cbv_update i s p0 c1 t c2 v in
  PPO_prog ->
  wf proof_tree ->
  In p (activations proof_tree) -> p = proof_tree \/ p <> proof_tree.

Lemma activations_trans p p' p'' : wf p'' ->
  In p (activations p') -> In p' (activations p'') -> In p (activations p'').

Lemma first_activation_down p i s p0 c1 t c2 v:
  let proof_tree := cbv_update i s p0 c1 t c2 v in
  PPO_prog ->
  wf proof_tree -> p <> proof_tree ->
  In p (activations proof_tree) ->
  exists p', In p' (activations proof_tree) /\ In p (first_activations p').

Fixpoint FA_path p p' (lp : list cbv) := match lp with
 | [] => p = p'
 | h :: t => In p (first_activations h) /\ FA_path h p' t
end.

Lemma FA_path_app p p' p'' lp1 lp2 : 
  FA_path p p' lp1 /\ FA_path p' p'' lp2 -> FA_path p p'' (lp1 ++ lp2).

Lemma FA_path_right p p' p'' lp : 
  FA_path p p' lp ->
  (In p' (first_activations p'') <->
   FA_path p p'' (lp ++ [p''])).

Lemma FA_path_end p p' x lp : FA_path p p' (lp++[x]) -> x = p'.

Lemma first_activations_at_given_rank_caract rk i s p0 c1 f l c2 v :
  let p := cbv_update i s p0 c1 (fapply f l) c2 v in
  first_activations_at_given_rank rk p =
  if eq_nat_dec rk (activation_rank rank p) then [p] else
    flat_map (first_activations_at_given_rank rk) (first_activations_rec p0).

Lemma first_activations_at_given_rank_path p p' i s p0 c1 t c2 v :
  let proof_tree := cbv_update i s p0 c1 t c2 v in
  In p' (activations proof_tree) ->
  In p (activations p') ->
  exists lp, FA_path p p' lp.

Lemma FA_path_activation p p' i s p0 c1 t c2 v lp :
  let proof_tree := cbv_update i s p0 c1 t c2 v in
  wf proof_tree ->
  In p' (activations proof_tree) ->
  FA_path p p' lp -> In p (activations p').

Lemma first_activations_strict p :
  PPO_prog ->
  wf p ->
 ~ p ∈ first_activations p.

Lemma first_activations_irrefl i s p0 c1 t c2 v p:
  PPO_prog ->
  wf (cbv_update i s p0 c1 t c2 v) ->
   (cbv_update i s p0 c1 t c2 v) ∈ activations p ->
   ~ In p (first_activations  (cbv_update i s p0 c1 t c2 v)).

Lemma FA_path_refl p p' lp : PPO_prog -> wf p' -> FA_path p p' lp -> In p' (activations p) -> lp = [].

Lemma FA_path_app_destruct p p' lp1 lp2 : FA_path p p' (lp1 ++ lp2) ->
  exists p'', FA_path p p'' lp1 /\ FA_path p'' p' lp2.

Lemma FA_path_uniqueness p i s p0 c1 t c2 v lp1 lp2 : PPO_prog -> 
  let p' := (cbv_update i s p0 c1 t c2 v) in
  wf p' ->
  FA_path p p' lp1 -> FA_path p p' lp2 -> lp1 = lp2.

Lemma activations_strict i s p0 c1 t c2 v :
  wf (cbv_update i s p0 c1 t c2 v) ->
  ~ cbv_update i s p0 c1 t c2 v ∈ activations p0.

Lemma first_activation_down_rank_lt p p' i s p0 c1 t c2 v:
  let proof_tree := cbv_update i s p0 c1 t c2 v in
  PPO_prog ->
  wf proof_tree ->
  In p' (activations proof_tree) -> In p (first_activations p') ->
  In p (first_activations_at_given_rank (activation_rank rank p) proof_tree) ->
  activation_rank rank p < activation_rank rank p'.

Lemma first_activations_at_given_rank_lt_previous i s p c1 t c2 v p':
  let proof_tree := cbv_update i s p c1 t c2 v in
  PPO_prog ->
  wf proof_tree ->
  In p' (first_activations_at_given_rank (activation_rank rank p') proof_tree) ->
  activation_rank rank p' < activation_rank rank proof_tree ->
  exists p'', In p'' (activations proof_tree) /\
         In p' (first_activations p'') /\
         activation_rank rank p' < activation_rank rank p''.

Lemma length_fapplies_le_functions s t : length (fapplies_in_term (@subst variable function constructor s t)) <= length (functions_of_term t).

Lemma first_activations_length_le_first_and_semi_activations n s p c1 f l c2 v : length (first_activations (cbv_update n s p c1 (@fapply variable function constructor f l) c2 v)) <=
length (first_activations_and_semi (cbv_update n s p c1 (fapply f l) c2 v)).

Lemma degree_bounded p :
  wf p -> length (first_activations p) <= max_nb_rhs_functions prog.

Lemma split_activations_by_first_activations_at_rank rk p :
  wf p ->
  activations_at_rank rk p = flat_map (activations_at_rank rk) (first_activations_at_given_rank rk p).

Lemma notin_nil (A: Type) (xs: list A):
  (forall x, ~ In x xs) -> [] = xs.

Lemma activations_at_rank_activation_rank proof_tree p:
  In p (activations proof_tree) ->
  In p (activations_at_rank (activation_rank rank p) proof_tree).

Lemma first_activations_at_given_rank_incl i s p c1 t c2 v r :
  let proof_tree := cbv_update i s p c1 t c2 v in
  PPO_prog ->
  wf proof_tree ->
  r < activation_rank rank proof_tree ->
  incl (first_activations_at_given_rank r proof_tree)
       (flat_map (@first_activations _ _ _)
                 (flat_map (fun r' => activations_at_rank r' proof_tree)
                           (seq (1 + r) (max_rank - r)))).

Definition compatible_rule (r:rule) : Prop :=
  match r with
    | rule_intro f _ t => forall f', In f' (functions_of_term t) -> rank f' <= rank f
  end.

Definition compatible_prog : Prop :=
  forall r, In r prog -> compatible_rule r.

Lemma PPO_is_compatible_rule:
  forall r, PPO_rule rank r -> compatible_rule r.

Lemma PPO_is_compatible_prog:
  PPO_prog -> compatible_prog.

Lemma gary_seven i s p c1 f lt c2 v:
  let proof_tree := cbv_update i s p c1 (fapply f lt) c2 v in
  compatible_prog ->
  wf proof_tree ->
  PPO_prog ->
  length (activations proof_tree) <= gary_seven_poly (A_T proof_tree).

Lemma all_functions_in_prog (function_default : function) (proof_tree: cbv) :
  wf proof_tree ->
  forall p, In p (activations proof_tree) ->
       In (activation_function function_default p) (functions_of_prog prog).

Fixpoint sub_terms (t: term) : list term :=
  t :: match t with
         | var _ => []
         | capply _ lt => flat_map sub_terms lt
         | fapply _ lt => flat_map sub_terms lt
       end.

Definition sub_terms_strict (t: term) : list term :=
  match t with
    | var _ => []
    | capply _ lt => flat_map sub_terms lt
    | fapply _ lt => flat_map sub_terms lt
  end.

Lemma sub_term_strict_incl (t: term) :
  incl (sub_terms_strict t) (sub_terms t).

Lemma sub_term_eq_or_strict (t1 t2: term) :
  In t1 (sub_terms t2) <-> t1 = t2 \/ In t1 (sub_terms_strict t2).

Lemma sub_term_le_size (t1 t2: term) :
  In t1 (sub_terms t2) -> t2 = t1 \/ term_size t1 < term_size t2.

Lemma sub_terms_strict_strict (t: term) :
  ~ In t (sub_terms_strict t).

Lemma sub_term_strict_lt_size (t1 t2: term) :
   In t1 (sub_terms_strict t2) -> term_size t1 < term_size t2.

Lemma PPO_value_is_sub_term (t v: term) :
  @term_value _ _ _ v ->
  (PPO rank t v <-> In t (sub_terms_strict v)).

Lemma PPO_value_lt_size (v v': value) :
  PPO rank (@term_from_value variable function constructor v) (@term_from_value _ _ _ v') ->
  value_size v < value_size v'.

Fixpoint all_possible_subarguments (args: list term) : list (list term) :=
  match args with
    | [] => [[]]
    | (x::xs) => let psa := all_possible_subarguments xs in
                let pst := sub_terms x in
                flat_map (fun st => map (fun sa => st::sa) psa) pst
  end.

Lemma length_sub_terms a : length (sub_terms a) = term_size a.

Lemma all_possible_subarguments_length (args: list term) :
  length (all_possible_subarguments args) = prodl (map (@term_size _ _ _) args).

Definition all_possible_sub_activation_same_rank (f: function) (lv: list term) : list term :=
  let psa := all_possible_subarguments lv in
  flat_map (fun g => map (fun sa => fapply g sa) psa) (functions_of_prog prog).

Lemma all_possible_sub_activation_same_rank_bound (f: function) (lv: list term) :
  length (all_possible_sub_activation_same_rank f lv)
  <= length (functions_of_prog prog) * prodl (map (@term_size _ _ _) lv).

Lemma all_possible_subarguments_self lt : lt ∈ all_possible_subarguments lt.

Lemma sub_terms_self a : In a (sub_terms a).

Lemma PPO_value_all_possible_subarguments l lv:
  (forall x, In x lv -> term_value x) ->
  Forall2 (clos_refl (PPO rank)) l lv ->  l ∈ all_possible_subarguments lv.

Lemma  all_possible_sub_activation_same_rank_spec p' i s p c1 f lt c2 v:
  PPO_prog -> 
  let proof_tree := cbv_update i s p c1 (fapply f lt) c2 v in
  wf proof_tree ->
  In p' (activations proof_tree) ->
  activation_rank rank p' = rank f ->
  In (proj_left p') (all_possible_sub_activation_same_rank f lt).

Definition bobby_eight_poly x := length (functions_of_prog prog) * Nat.pow x max_arity.

Lemma bobby_eight i s p c1 f lt c2 v:
  let proof_tree := cbv_update i s p c1 (fapply f lt) c2 v in
  PPO_prog -> wf proof_tree ->
  length (activations_at_rank (rank f) proof_tree) <=
  bobby_eight_poly (term_size (proj_left proof_tree)).

Lemma bobby_increase:
  forall x y, x <= y -> (bobby_eight_poly x) <= (bobby_eight_poly y).

Theorem A_T_bound i s p c1 f lt c2 v: 
  let proof_tree := cbv_update i s p c1 (fapply f lt) c2 v in
  PPO_prog -> wf proof_tree ->
  A_T proof_tree <= bobby_eight_poly (max_active_size proof_tree).

End Bounds. *)
(* Cecoa.Ordering:
Require Import Arith NPeano List Bool Psatz.
Require Import Cecoa.Lib Cecoa.Syntax Cecoa.CBV_cache.
Require Import Omega.

Import List.ListNotations.
Infix "∈" := In (at level 70).

Section Ordering.

Set Implicit Arguments.

Variables variable function constructor : Type.

Notation value := (Syntax.value constructor).
Notation term := (Syntax.term variable function constructor).
Notation pattern := (Syntax.pattern variable constructor).
Notation rule := (Syntax.rule variable function constructor).
Notation cbv := (CBV_cache.cbv variable function constructor).
Notation cache := (CBV_cache.cache variable function constructor).

Variable variable_eq_dec : forall (x1 x2 : variable), {x1=x2}+{x1<>x2}.

Variable function_eq_dec : forall (x1 x2 : function), {x1=x2}+{x1<>x2}.

Variable constructor_eq_dec : forall (x1 x2 : constructor), {x1=x2}+{x1<>x2}.

Variable rule_default : rule.

Variable prog : list rule.

Variable max_arity : nat.

Notation wf :=
  (CBV_cache.wf variable_eq_dec function_eq_dec constructor_eq_dec rule_default prog max_arity).

Variable rank: function -> nat.

Inductive product {A: Type} (R : A -> A -> Prop) : list A -> list A -> Prop :=
| product_conseq : forall x y xs ys, x = y -> product R xs ys   -> product R (x::xs) (y::ys)
| product_consst : forall x y xs ys, R x y -> Forall2 (clos_refl R) xs ys -> product R (x::xs) (y::ys).

Inductive PPO: term -> term -> Prop :=
| ppo_constr_in    : forall s c lt,    In s lt            -> PPO s (capply c lt)
| ppo_fun_in       : forall s f lt,    In s lt            -> PPO s (fapply f lt)
| ppo_constr_sub   : forall s t c lt,  In t lt -> PPO s t -> PPO s (capply c lt)
| ppo_fun_sub      : forall s t f lt,  In t lt -> PPO s t -> PPO s (fapply f lt)
| ppo_constr_split : forall c ls f lt, (forall s, In s ls -> PPO s (fapply f lt))
                                       -> PPO (capply c ls) (fapply f lt)
| ppo_funlt_split  : forall g ls f lt, rank g < rank f
                                       -> (forall s, In s ls -> PPO s (fapply f lt))
                                       -> PPO (fapply g ls) (fapply f lt)
| ppo_funeqv_split : forall g ls f lt, rank g = rank f
                                       -> product PPO ls lt
                                       -> PPO (fapply g ls) (fapply f lt).

Infix "≺ppo" := PPO (at level 80).
Infix "≼ppo" := (clos_refl PPO) (at level 80).

Hint Constructors product PPO.

Definition lt_wf_rect (n : nat) (P : nat -> Type)
  (F : forall n, (forall m, m < n -> P m) -> P n) : P n :=
  well_founded_induction_type (well_founded_ltof nat (fun m => m)) P F n.

Definition term_dec (t1 t2 : term) : {t1=t2}+{t1<>t2}.

Lemma Exists_dec_gen :
  forall {A : Type} (P : A -> Prop) (l : list A),
  (forall x : A, In x l -> {P x} + {~ P x}) -> {Exists P l} + {~ Exists P l}.

Lemma Forall_dec_gen :
  forall {A : Type} (P : A -> Prop) (l : list A),
  (forall x : A, In x l -> {P x} + {~ P x}) -> {Forall P l} + {~ Forall P l}.

Lemma Forall2_dec_gen :
  forall {A B : Type} (R : A -> B -> Prop) (xs : list A) (ys : list B),
  (forall x y, In x xs -> In y ys -> {R x y}+{~R x y}) ->
  {Forall2 R xs ys}+{~Forall2 R xs ys}.

Lemma clos_refl_dec {A : Type} (A_dec : forall x y:A, {x=y}+{x<>y})
  (R : A -> A -> Prop) (x y : A) (R_dec : {R x y}+{~R x y}) :
  {clos_refl R x y}+{~(clos_refl R) x y}.

Lemma product_dec (A : Type) (A_dec : forall x y:A, {x=y}+{x<>y})
  (R : A -> A -> Prop) (xs ys : list A)
  (R_dec : forall x y, In x xs -> In y ys -> {R x y}+{~R x y}) :
  {product R xs ys}+{~product R xs ys}.

Lemma PPO_dec t1 t2: {PPO t1 t2}+{~PPO t1 t2}.

Lemma product_length A (R: A -> A -> Prop) xs ys :
  product R xs ys -> length xs = length ys.

Lemma product_Forall2 A (R: A -> A -> Prop) ls lt : product R ls lt -> Forall2 (clos_refl R) ls lt.

Lemma product_Exists2 A (R: A -> A -> Prop) ls lt : product R ls lt -> Exists2 R ls lt.

Definition PPO_rule (r: rule) : Prop :=
  match r with
    | rule_intro f lp t => PPO t (fapply f (map (@term_from_pattern _ _ _) lp))
  end.

Definition PPO_prog : Prop :=
  forall r, In r prog -> PPO_rule r.

Lemma value_PPO_function (v: value) (f: function) (lt: list term) :
  PPO (@term_from_value _ _ _ v) (fapply f lt).

Lemma product_trans (A: Type) (R : A -> A -> Prop) lt1 lt2 lt3 :
    (forall t1 t2 t3, In t1 lt1 -> In t2 lt2 -> In t3 lt3 -> R t1 t2 -> R t2 t3 -> R t1 t3) ->
    product R lt1 lt2 -> product R lt2 lt3 -> product R lt1 lt3.

Lemma PPO_trans t1 t2 t3 : PPO t1 t2 -> PPO t2 t3 -> PPO t1 t3.

Lemma PPO_trans_eq t1 t2 t3 : clos_refl PPO t1 t2 -> PPO t2 t3 -> PPO t1 t3.

Lemma PPO_trans_eq_r t1 t2 t3 : PPO t1 t2 -> clos_refl PPO t2 t3 -> PPO t1 t3.

Lemma PPO_asym t1 t2 : PPO t1 t2 -> ~ PPO t2 t1.

Lemma PPO_irrefl t : ~PPO t t.

Lemma PPO_term_pattern_subst p t s :
  PPO t (@term_from_pattern _ _ _ p) ->
  PPO (subst s t) (@term_from_value _ _ _ (psubst s p)).

Lemma fapply_not_PPO_value f lt v :
  term_value v -> ~ PPO (fapply f lt) v.

Lemma fapply_not_PPO_pattern f lt p :
  ~ PPO (fapply f lt) (@term_from_pattern _ _ _ p).

Lemma PPO_rule_PPO_instance s f lp t :
  PPO_rule (rule_intro f lp t) ->
  PPO (subst s t) (fapply f (map (@term_from_value _ _ _) (map (psubst s) lp))).

Lemma PPO_rule_instance i s p c1 t c2 v :
  PPO_prog ->
  wf (cbv_update i s p c1 t c2 v) ->
  PPO (proj_left p) t.

Definition activation_rank (p : cbv) : nat :=
  match p with
  | cbv_update _ _ _ _ (fapply f _) _ _ => rank f
  | _                                   => 0
  end.

Lemma fapplies_rec_PPO t t': In t (fapplies_in_term t') -> clos_refl PPO t t'.

Lemma PPO_value_is_value t v : PPO t v -> term_value v -> term_value t.

Lemma PPO_activation_le_rank f1 lt1 f2 lv2 :
  PPO (fapply f1 lt1) (fapply f2 (map (@term_from_value _ _ _) lv2)) -> rank f1 <= rank f2.

Lemma PPO_pattern_le_rank f1 lt1 f2 lp2 :
  PPO (fapply f1 lt1) (fapply f2 (map (@term_from_pattern _ _ _) lp2)) -> rank f1 <= rank f2.

Lemma subfapplies_activation_le_rank i s p c1 f lt c2 v f' lt' :
  let proof_tree := cbv_update i s p c1 (fapply f lt) c2 v in
  PPO_prog -> wf proof_tree ->
  In (fapply f' lt') (fapplies_in_term (proj_left p)) ->
  rank f' <= rank f.

Lemma le_rank_first_activation i s p c1 t c2 v p' :
  let proof_tree := cbv_update i s p c1 t c2 v in
  PPO_prog -> wf proof_tree ->
  In p' (first_activations proof_tree) ->
  activation_rank p' <= activation_rank proof_tree.

Lemma PPO_first_activations i s p c1 t c2 v p' :
  let proof_tree := cbv_update i s p c1 t c2 v in
  PPO_prog -> wf proof_tree ->
  In p' (first_activations proof_tree) ->
  PPO (proj_left p') (proj_left proof_tree).

Lemma PPO_activations i s p c1 t c2 v p' :
  let proof_tree := cbv_update i s p c1 t c2 v in
  PPO_prog -> wf proof_tree ->
  In p' (activations proof_tree) ->
  p' = proof_tree \/ PPO (proj_left p') (proj_left proof_tree).

End Ordering.

Lemma same_rank_same_prod vv ff cc lt ls rk rk':
  (forall t s, In t lt -> In s ls ->
      (forall f, In f (functions_of_term t) -> rk f = rk' f) ->
      (forall f, In f (functions_of_term s) -> rk f = rk' f) ->
      PPO rk t s -> PPO rk' t s) ->
  (forall f, In f (flat_map (@functions_of_term vv ff cc) lt) -> rk f = rk' f) ->
  (forall f, In f (flat_map (@functions_of_term _ _ _) ls) -> rk f = rk' f) ->
  product (PPO rk) lt ls -> product (PPO rk') lt ls.

Hint Constructors PPO.

Lemma same_rank_same_ppo vv ff cc (t : term vv ff cc) s rk rk':
  (forall f, In f (functions_of_term t) -> rk f = rk' f) ->
  (forall f, In f (functions_of_term s) -> rk f = rk' f) ->
  PPO rk t s -> PPO rk' t s.

Lemma same_rank_same_ppo_rule vv ff cc f lp (t : term vv ff cc) rk rk':
  rk f = rk' f ->
  (forall g, g ∈ (functions_of_term t) -> rk g = rk' g) ->
  PPO rk t (fapply f (map (@term_from_pattern _ _ _) lp)) ->
  PPO rk' t (fapply f (map (@term_from_pattern _ _ _) lp)).

Ltac ppo variable_eq_dec function_eq_dec constructor_eq_dec :=
match goal with
| |- PPO ?rk ?t1 ?t2 =>
    let t := eval compute in (@PPO_dec _ _ _ variable_eq_dec function_eq_dec constructor_eq_dec rk t1 t2) in
    match t with
    | left ?H => try exact H
    | _ => let t := constr:(pair t1 t2) in idtac t
    end
end. *)

Require Import Omega.



Import List.ListNotations.



Section Evaluates.



Variables variable function constructor : Type.



Notation value := (Syntax.value constructor).

Notation term := (Syntax.term variable function constructor).

Notation pattern := (Syntax.pattern variable constructor).

Notation rule := (Syntax.rule variable function constructor).

Notation cbv := (CBV_cache.cbv variable function constructor).

Notation cache := (CBV_cache.cache variable function constructor).



Variable variable_eq_dec : forall (x1 x2 : variable), {x1=x2}+{x1<>x2}.



Variable function_eq_dec : forall (x1 x2 : function), {x1=x2}+{x1<>x2}.



Variable constructor_eq_dec : forall (x1 x2 : constructor), {x1=x2}+{x1<>x2}.



Variable term_default : term.



Variable value_default : value.



Variable function_default : function.



Variable rule_default : rule.



Variable prog : list rule.



Variable max_arity : nat.



Notation wf :=

  (CBV_cache.wf variable_eq_dec function_eq_dec constructor_eq_dec rule_default prog max_arity).



Notation assoc_cache := (assoc (term_beq variable_eq_dec function_eq_dec constructor_eq_dec)).



Variable rank: function -> nat.



Hypothesis prog_is_ppo : PPO_prog prog rank.



Hypothesis prog_is_wf : wf_prog max_arity prog.



Definition term_order (t1 t2: term): Prop :=

  In t1 (sub_terms_strict _ _ _ t2).



Set Implicit Arguments.



Lemma term_order_wf : well_founded term_order.

Proof.

intro t.

induction t as [ x | c lt IH | f lt IH ] using term_ind2;

 constructor; unfold term_order; simpl; [ tauto | | ].



- intros t Hin.

  rewrite in_flat_map in Hin.

  destruct Hin as (t' & Hin1 & Hin2).

  apply sub_term_eq_or_strict in Hin2.

  destruct Hin2 as [ Heq | Hin2 ].



  + subst t'.

     apply IH.

     exact Hin1.



  + apply Acc_inv_trans with t'.



    * constructor.

      exact Hin2.



    * apply IH.

      exact Hin1.



- intros t Hin.

  rewrite in_flat_map in Hin.

  destruct Hin as (t' & Hin1 & Hin2).

  apply sub_term_eq_or_strict in Hin2.

  destruct Hin2 as [ Heq | Hin2 ].



  + subst t'.

     apply IH.

     exact Hin1.



  + apply Acc_inv_trans with t'.



    * constructor.

      exact Hin2.



    * apply IH.

      exact Hin1.

Qed.



Definition active_term := prod function (list value).



Definition term_from_active_term (t: active_term) : term :=

  let (f, lv) := t in

  fapply f (map (@term_from_value _ _ _) lv).



Definition value_list_order (lv lv' : list value) : Prop :=

  suml (map (@value_size _) lv) < suml (map (@value_size _) lv').



Lemma value_list_order_wf : well_founded value_list_order.

Proof.

unfold value_list_order.

apply wf_inverse_image.

refine lt_wf.

Defined.



Definition active_term_order_superset t t' :=

  lexprod lt value_list_order (rank (fst t), snd t) (rank (fst t'), snd t').



Definition active_term_order_superset_wf : well_founded active_term_order_superset.

Proof.

unfold active_term_order_superset.

apply wf_inverse_image.

apply wf_lexprod.

- apply lt_wf.

- apply value_list_order_wf.

Defined.



Fixpoint unify (s : list (variable * value)) (v : value) (p : pattern) {struct p} :

  option (list (variable * value)) :=

  let unify_list := fix unify_list

    (s : list (variable * value)) (lv : list value) (lp : list pattern) {struct lp} :

    option (list (variable * value)) :=

    match lv, lp with

    | [], [] => Some s

    | v::lv', p::lp' => match unify s v p with

      | None => None

      | Some s' => unify_list s' lv' lp'

      end

    | _, _ => None

    end in

  match p with

  |  p_var x =>

    match assoc (variable_beq variable_eq_dec) x s with

    | None => Some ((x, v) :: s)

    | Some v' => if value_beq constructor_eq_dec v v' then Some s else None

    end

  | p_capply c' lp =>match v with

      | c_capply c lv => if constructor_beq constructor_eq_dec c c' then unify_list s lv lp else None

      end

  end.



Fixpoint unify_list_aux (s : list (variable * value)) (lv : list value) (lp : list pattern) :

  option (list (variable * value)) :=

  match lv, lp with

  | [], [] => Some s

  | v::lv', p::lp' => match unify s v p with

    | None => None

    | Some s' => unify_list_aux s' lv' lp'

    end

  | _, _ => None

  end.



Lemma unify_equation (s : list (variable * value)) (v : value) (p : pattern) :

  unify s v p =

  match p with

  |  p_var x =>

    match assoc (variable_beq variable_eq_dec) x s with

      | None => Some ((x, v) :: s)

      | Some v' => if value_beq constructor_eq_dec v v' then Some s else None

    end

  | p_capply c' lp =>

    match v with

      | c_capply c lv => if constructor_beq constructor_eq_dec c c' then unify_list_aux s lv lp else None

    end

  end.

Proof.

  revert s v.

  induction p as [ x | c lp IH ] using pattern_ind2;

    [ simpl; trivial | ].

  intros s [ c' lv ].

  simpl.

  case constructor_beq; [ | trivial ].

  clear c c'; revert s lv.

  induction lp as [ | p lp IHlp ];

    intros s lv;

    [ destruct lv; trivial | ].

  destruct lv as [ | [ c lv' ] lv ]; simpl; trivial.

  case unify; trivial.

  intros s'.

  apply IHlp.

  intros; apply IH; right; assumption.

Qed.



Definition unify_list

  (s : list (variable * value)) (lv : list value) (lp : list pattern) :

  option (variable -> value) :=

  option_map (assoc_default (variable_beq variable_eq_dec) value_default) (unify_list_aux s lv lp).



Lemma unify_list_unify_unify_list :

  forall s s' v lv p lp,

    unify_list_aux s (v :: lv) (p :: lp) = Some s' ->

    exists s'', unify s v p = Some s'' /\ unify_list_aux s'' lv lp = Some s'.

Proof.

  intros s s' v lv p lp.

  case_eq (unify s v p); simpl;

  [ intro s'' | ]; intro Huni; rewrite Huni; [ | discriminate ].

  intros Hunis; exists s''.

  now split.

Qed.



Lemma unify_list_length :

  forall s s' lv lp, unify_list_aux s lv lp = Some s' -> length lv = length lp.

Proof.

  intros s s' lv; revert s s';

  induction lv as [ | v lv IH ]; intros s s' lp Hunis;

  destruct lp; [ trivial | discriminate | discriminate | ].

  simpl; f_equal;

  apply unify_list_unify_unify_list in Hunis;

  destruct Hunis as (s'' & _ & Hunis); now apply IH in Hunis.

Qed.



Lemma unify_cons_eq_unify_list :

  forall s s' c lv c' lp',

    unify s (c_capply c lv) (p_capply c' lp') = Some s' ->

    c = c' /\ unify_list_aux s lv lp' = Some s'.

Proof.

  intros s s' c lv c' lp' Huni;

  rewrite unify_equation in Huni;

  case_eq (constructor_beq constructor_eq_dec c c'); intros Hc; rewrite Hc in Huni;

  [ now rewrite constructor_beq_eq in Hc | discriminate Huni ].

Qed.



Lemma unify_list_aux_extension lv lp s s':

  unify_list_aux s lv lp = Some s' ->

  exists s'',

    s' = s'' ++ s /\

    forall x, assoc (variable_beq variable_eq_dec) x s <> None -> assoc (variable_beq variable_eq_dec) x s'' = None.

Proof.

  remember (suml (map (value_size (constructor := constructor)) lv)) as size eqn: Hsize.

  revert lv lp s s' Hsize;

    induction size as [ size IH ] using lt_wf_ind; intros lv lp s s' Hsize Hunis.



  destruct lv as [ | v lv ].



  - exists [].

    assert (Hnil : 0 = length lp) by (now apply unify_list_length in Hunis).

    destruct lp; [ clear Hnil | now contradict Hnil ].

    simpl in Hunis; injection Hunis; clear Hunis; intros; now subst s'.



  - assert (Hlen : length (v :: lv) = length lp) by (apply unify_list_length in Hunis; assumption).

    destruct lp as [ | p lp ]; [ discriminate Hlen | clear Hlen ].

    apply unify_list_unify_unify_list in Hunis; destruct Hunis as (s'' & Huni & Hunis).

    set (size' := suml (map (value_size (constructor := constructor)) lv)).

    assert (Hlt: size' < size)

      by (simpl in Hsize; rewrite Hsize;

          change size' with (0 + size'); unfold size';

          apply plus_lt_compat_r;

          destruct v as [ c' lv' ];

          simpl;

          apply lt_O_Sn).

    apply (IH _ Hlt) in Hunis; [ | easy ];

    destruct Hunis as (s''' & Happ & Hconsistent); clear size' Hlt lp.



    destruct p as [ x | c lp' ].



    + simpl in Huni; case_eq (assoc (variable_beq variable_eq_dec) x s).



      * intros v'' Hsome; rewrite Hsome in Huni.

        destruct value_beq in Huni; [ | discriminate Huni ];

        injection Huni; intros; subst s' s''; clear Huni.

        now exists s'''.



      * intros Hnone; rewrite Hnone in Huni.

        injection Huni; intro; subst s''; clear Huni.

        exists (s''' ++ [(x,v)]); split; [ now rewrite <- app_assoc | ].

        intros y Hsome.

        { rewrite assoc_app_eq_None; split.

          - apply Hconsistent.

            change ((x,v) :: s) with ([(x,v)] ++ s).

            rewrite assoc_app_neq_None; now right.

          - simpl.

            case_eq (variable_beq variable_eq_dec y x); [ | easy ].

            rewrite variable_beq_eq; intro; now subst y.

        }



    + destruct v as [ c' lv' ].

      apply unify_cons_eq_unify_list in Huni; destruct Huni as (Hc' & Hunis); subst c'.

      set (size' := suml (map (value_size (constructor := constructor)) lv')).

      assert (Hlt: size' < size) by (subst size; simpl; unfold size'; omega).

      apply (IH _ Hlt) in Hunis; [ | easy ];

      destruct Hunis as (s'''' & Happ' & Hconsistent'); clear size' Hlt.



      exists (s''' ++ s'''').

      subst s' s''.

      split; [ now rewrite <- app_assoc | ].

      intros x Hsome.

      rewrite assoc_app_eq_None; split.

      * apply Hconsistent.

        rewrite assoc_app_neq_None; right; assumption.

      * apply Hconsistent'; assumption.

Qed.



Lemma unify_all_vars_defined :

  forall (s s': list (variable * value)) (v: value) (p: pattern),

    unify s v p = Some s' ->

    forall x, In x (vars_of_pattern p) -> assoc (variable_beq variable_eq_dec) x s' <> None.

Proof.

  intros s s' v p; revert s s' v.

  induction p as [ x | c lp IH ] using pattern_ind2;

    intros s s' v Huni.



  - 

    intros x' [ Hx' | H ]; [ | tauto ]; subst x'.

    rewrite unify_equation in Huni.

    case_eq (assoc (variable_beq variable_eq_dec) x s).

    + intros v' Heq; rewrite Heq in Huni.

      destruct (value_beq _ _ _) in Huni; [ | discriminate ].

      injection Huni; intros H; subst s'.

      rewrite Heq; discriminate.

    + intros Heq; rewrite Heq in Huni; injection Huni; intros H; subst s'.

      simpl.

      case_eq ((variable_beq variable_eq_dec) x x); [ intros; discriminate | ].

      rewrite <- not_true_iff_false, variable_beq_eq; tauto.



  - simpl; destruct v as [ c' lv ].

    apply unify_cons_eq_unify_list in Huni; destruct Huni as (H & Hunis); subst c'; clear c.

    revert s s' lv Hunis.

    induction lp as [ | p lp IHlp ]; [ easy | ].

    intros s s' [ | v lv ] Hunis;

    [ apply unify_list_length in Hunis; now contradict Hunis | ].

    apply unify_list_unify_unify_list in Hunis.

    destruct Hunis as (s'' & Huni & Hunis).

    intros x; rewrite in_flat_map; intros (p' & [Hp' | Hp'] & Hx).

    + subst p'.

      apply IH with (x := x) in Huni; [ | now left | easy ].

      apply unify_list_aux_extension in Hunis.

      destruct Hunis as (s''' & Heq & _); subst s'.

      rewrite assoc_app_neq_None; now right.

    + apply IHlp with (s := s'') (lv := lv).

      * intros p'' Hin; apply IH; now right.

      * easy.

      * apply in_flat_map.

        now exists p'.

Qed.



Lemma eq_psubst_consistent_assoc_extension :

  forall s s' p,

    (forall x, assoc (variable_beq variable_eq_dec) x s <> None -> assoc (variable_beq variable_eq_dec) x s' = None) ->

    (forall x, In x (vars_of_pattern p) -> assoc (variable_beq variable_eq_dec) x s <> None) ->

    psubst (assoc_default (variable_beq variable_eq_dec) value_default (s' ++ s)) p =

    psubst (assoc_default (variable_beq variable_eq_dec) value_default s) p.

Proof.

  intros s s' p; revert s s'.

  induction p as [ x | c lp IH ] using pattern_ind2;

    intros s s' Hconsistent Hvars.



  - assert (Hsomes : assoc (variable_beq variable_eq_dec) x s <> None)

      by (apply Hvars; simpl; now left).

    assert (Hnones' : assoc (variable_beq variable_eq_dec) x s' = None)

      by (apply Hconsistent, Hsomes).

    assert (H : exists v, assoc (variable_beq variable_eq_dec) x s = Some v)

      by now apply neq_None_eq_Some.

    clear Hsomes.

    destruct H as (v & Hsome's).

    simpl; unfold assoc_default.

    rewrite Hsome's.

    case_eq (assoc (variable_beq variable_eq_dec) x (s' ++ s)).

    + intros v'; rewrite assoc_app_eq_Some.

      intros [ Hsomes' | (_ & Hsome) ];

        [ rewrite Hnones' in Hsomes'; discriminate Hsomes'

        | rewrite Hsome's in Hsome; now injection Hsome ].

    + rewrite assoc_app_eq_None; intros (_ & Himpossible); congruence.



  - simpl; f_equal.

    apply map_ext_in.

    intros p Hin; apply IH; [ assumption | assumption | ].

    simpl in Hvars.

    intros x Hx; apply Hvars.

    apply in_flat_map; now exists p.

Qed.



Lemma unify_sound :

  forall (s s': list (variable * value)) (v: value) (p: pattern),

    unify s v p = Some s' ->

    psubst (assoc_default (variable_beq variable_eq_dec) value_default s') p = v.

Proof.

  intros s s' [ c lv ] p; revert s s' c lv.

  induction p as [ x | c lp IH ] using pattern_ind2.

  - intros s s' c' lv; simpl.

    case_eq (assoc (variable_beq variable_eq_dec) x s).

    + intros [ c'' lv'' ] H'' Hassoc.

      case_eq (constructor_beq constructor_eq_dec c' c'');

        case_eq (list_beq value (value_beq constructor_eq_dec) lv lv'');

        intros Heqc Heqlv;

        rewrite Heqc, Heqlv in Hassoc;

        simpl in Hassoc;

        try discriminate.

      injection Hassoc; intros; subst.

      apply list_beq_eq in Heqc; subst;

      [ | intros; apply value_beq_eq; assumption ].

      apply constructor_beq_eq in Heqlv; subst.

      unfold assoc_default.

      rewrite H''; trivial.

    + intros Hnone Hsome; injection Hsome; intros; subst; clear Hsome.

      unfold assoc_default.

      simpl.

      case_eq ((variable_beq variable_eq_dec) x x); [ intros; trivial | ].

      intros Heq.

      rewrite <- not_true_iff_false, variable_beq_eq in Heq.

      now contradict Heq.

  - intros s s' c' lv.

    rewrite unify_equation.

    case_eq (constructor_beq constructor_eq_dec c' c); [ | intros _ H; discriminate H ].

    rewrite constructor_beq_eq.

    intros Heq; subst.

    revert s s' lv;

    induction lp as [ | p lp IHlp ]; intros s s' lv.

    + destruct lv; [ now simpl | ].

      simpl; intros H; discriminate H.

    + destruct lv as [ | [ c' lv' ] lv ]; [ intros H; discriminate H | ].

      simpl.

      case_eq (unify s (c_capply c' lv') p); [ | intros _ H; discriminate H ].

      intros s'' Hs'' Heq.

      f_equal; simpl; f_equal.

      assert (Hvars' := unify_all_vars_defined _ _ _ Hs'').

      apply IH in Hs''.

      * apply unify_list_aux_extension in Heq;

        destruct Heq as (s''' & Heq & Hconsistent);

        subst s'.

        now rewrite eq_psubst_consistent_assoc_extension.

      * left; trivial.

      * simpl in IHlp.

        assert (Hf_equal : forall lv', c_capply c lv' = c_capply c lv -> lv' = lv)

               by (intros lv'' H''; injection H''; trivial).

        apply Hf_equal.

        apply IHlp with (s := s''); [ | assumption ].

        intros p' Hin.

        apply IH.

        right; assumption.

Qed.



Lemma psubst_app p v (s s' : list (variable * value)) :

  (forall x : variable, assoc (variable_beq variable_eq_dec) x s <> None -> assoc (variable_beq variable_eq_dec) x s' = None) ->

  (forall x, In x (vars_of_pattern p) -> assoc (variable_beq variable_eq_dec) x s <> None) ->

  psubst (assoc_default (variable_beq variable_eq_dec) value_default s        ) p = v ->

  psubst (assoc_default (variable_beq variable_eq_dec) value_default (s' ++ s)) p = v.

Proof.

revert v s s'.

induction p as [ x | c lp IHp ] using pattern_ind2; simpl; intros v s s' Hconsistent Hall Hassoc.



- unfold assoc_default in *.

  case_eq (assoc (variable_beq variable_eq_dec) x (s' ++ s)).



  + intros v' Hx.

    apply assoc_app_eq_Some in Hx.

    destruct Hx as [ Hx | [ Hnone Hx ] ]; [ | rewrite Hx in Hassoc; assumption ].

    case_eq (assoc (variable_beq variable_eq_dec) x s).



    * intros v'' Hx'.

      rewrite Hx' in Hassoc.

      subst v''.

      apply eq_None_neq_Some in Hx; [contradict Hx |].

      apply Hconsistent.

      auto.



    * intro Hx'.

      rewrite Hx' in Hassoc.

      apply eq_None_neq_Some in Hx; [contradict Hx |].

      apply Hconsistent.

      auto.



  + intro Hassoc'.

    apply assoc_app_eq_None in Hassoc'.

    destruct Hassoc' as [_ Hassoc'].

    rewrite Hassoc' in Hassoc.

    assumption.



- rewrite <- Hassoc.

  f_equal.

  apply map_in_ext.

  intros p Hp.

  apply eq_psubst_consistent_assoc_extension; [ assumption | ].

  intros x Hx.

  apply Hall.

  apply in_flat_map.

  eauto.

Qed.



Lemma unify_list_sound :

  forall (lp : list pattern) (lv : list value) (s : variable -> value),

    unify_list [] lv lp = Some s -> map (psubst s) lp = lv.

Proof.

assert (

  Hgen: forall lv lp s0 s, unify_list s0 lv lp = Some s ->

  map (psubst s) lp = lv

).

{

unfold unify_list.

induction lv as [ | v lv IHlv ]; intros [ | p lp ] s0 s Hula;

 [ trivial | simpl in Hula; discriminate Hula | simpl in Hula; discriminate Hula | ].

unfold option_map in Hula.

case_eq (unify_list_aux s0 (v :: lv) (p :: lp));

 [ | intro Hnone; rewrite Hnone in Hula; discriminate Hula ].

intros s' Hs'.

rewrite Hs' in Hula.

injection Hula; clear Hula; intro; subst s.

apply unify_list_unify_unify_list in Hs'.

destruct Hs' as (s'' & Hs'' & Hs').

simpl.

f_equal.



- assert(HHs'' := Hs'').

  apply unify_sound in Hs''.

  assert(HHs' := Hs').

  apply unify_list_aux_extension in Hs'.

  destruct Hs' as (s''' & Hs' & Hconsistent).

  subst s'.

  apply psubst_app; [ assumption | | assumption ].

  intros x Hx.

  eapply unify_all_vars_defined; [ exact HHs'' | exact Hx].



- eapply IHlv with (s0 := s'').

  rewrite Hs'.

  reflexivity.

}

eauto.

Qed.



Fixpoint first_rule_rec (prog': list rule) (t: active_term) :

  option (nat * (variable -> value) * term) :=

  match prog' with

    | [] => None

  | rule_intro f lp t' :: prog'' =>

    if function_beq function_eq_dec (fst t) f

    then

      match unify_list [] (snd t) lp with

        | None =>

          match first_rule_rec prog'' t with

            | None => None

            | Some (i, s, t) => Some (S i, s, t)

            end

        | Some s => Some (0, s, subst s t')

      end

    else

      match first_rule_rec prog'' t with

        | None => None

        | Some (i, s, t) => Some (S i, s, t)

      end

  end.



Definition first_rule (t: active_term) :

  option (nat * (variable -> value) * term) :=

  first_rule_rec prog t.



Global Arguments first_rule t : simpl never.



Lemma first_rule_sound :

  forall (f: function) (lv: list value) (i: nat) (s: variable -> value) (t: term),

  first_rule (f, lv) = Some (i, s, t) ->

  { lpt : (list pattern * term)| let (lp, t') := lpt in

    i < length prog /\

    nth i prog rule_default = rule_intro f lp t' /\

    unify_list [] lv lp = Some s /\

    t = subst s t'}.

Proof.

  clear prog_is_ppo prog_is_wf.

  unfold first_rule.

  induction prog as [ | r0 prog' IHp ];

    simpl; intros f lv i s t; [ intros H; discriminate H | ].

  destruct r0 as [ f0 lp0 t0 ].

  case_eq (function_beq function_eq_dec f f0).

  - intro Heqf; rewrite function_beq_eq in Heqf.

    case_eq (unify_list [] lv lp0).

    + intros s' Hs'.

      intros H; injection H; clear H.

      intros Heqt Heqs Hi.

      subst s' t f0 i.

      exists (lp0, t0).

      repeat split; [ apply lt_O_Sn | assumption ].

    + 

      intros Hnone Hrec.

      case_eq (first_rule_rec prog' (f,lv)); [ | intros H; rewrite H in Hrec; discriminate Hrec ].

      intros [ [i' s'] t'] Heq.

      rewrite Heq in Hrec.

      injection Hrec; clear Hrec; intros; subst.

      apply IHp in Heq.

      destruct Heq as [[lp t'] Hlpt].

      exists (lp, t').

      repeat split; try tauto.

      omega.



  - intros Hneq Hrec.

    case_eq (first_rule_rec prog' (f,lv)); [ | intros H; rewrite H in Hrec; discriminate Hrec ].

    intros [ [i' s'] t'] Heq.

    rewrite Heq in Hrec.

    injection Hrec; clear Hrec; intros; subst.

    apply IHp in Heq.

    destruct Heq as [[lp t'] Hlpt].

    exists (lp, t').

    repeat split; try tauto.

    omega.

Qed.



Definition active_term_order_superset_dec: forall (t t': active_term), {active_term_order_superset t t'} + {~ active_term_order_superset t t'}.

Proof.

intros t t'.

apply lex_prod_dec.

- apply eq_nat_dec.



- apply lt_dec.



- intros x y.

  unfold value_list_order.

  apply lt_dec.

Defined.



Definition lex : (active_term * term) -> (active_term * term) -> Prop :=

  lexprod active_term_order_superset term_order.



Lemma wf_lex : well_founded lex.

Proof.

exact (wf_lexprod active_term_order_superset_wf term_order_wf).

Qed.



Lemma sub_terms_trans t1 t2 t3:

  In t1 (sub_terms variable function constructor t2) ->

  In t2 (sub_terms _ _ _ t3) ->

  In t1 (sub_terms _ _ _ t3).

Proof.

induction t3 using term_ind2; intros H1 H2; simpl in *.

- destruct H2 as [Heq | Hf].

  + subst t2.

    left; now inversion H1.



  + inversion Hf.



- destruct H2 as [Heq |Hin].

  + subst t2.

    exact H1.



  + right.

    rewrite in_flat_map in *.

    destruct Hin as (x & Hin & Hx).

    exists x.

    split; [exact Hin |].

    auto.



- destruct H2 as [Heq |Hin].

  + subst t2.

    exact H1.



  + right.

    rewrite in_flat_map in *.

    destruct Hin as (x & Hin & Hx).

    exists x.

    split; [exact Hin |].

    auto.

Qed.



Lemma sub_terms_strict_trans t1 t2 t3:

  In t1 (sub_terms_strict variable function constructor t2) ->

  In t2 (sub_terms_strict _ _ _ t3) ->

  In t1 (sub_terms_strict _ _ _ t3).

Proof.

intros H1 H2.

destruct t3.

- inversion H2.



- simpl in *.

  apply in_flat_map in H2.

  apply sub_term_strict_incl in H1.

  destruct H2 as (x & Hin & Hx).

  apply in_flat_map.

  exists x; split; [exact Hin | now apply sub_terms_trans with t2].



- simpl in *.

  apply in_flat_map in H2.

  apply sub_term_strict_incl in H1.

  destruct H2 as (x & Hin & Hx).

  apply in_flat_map.

  exists x; split; [exact Hin | now apply sub_terms_trans with t2].

Qed.



Lemma lex_trans a1 a2 a3:

  lex a1 a2 -> lex a2 a3 -> lex a1 a3.

Proof.

intros H1 H2.

refine (lexprod_trans _ _ H1 H2).

- intros x1 x2 x3 Hx1 Hx2. 

  refine (lexprod_trans lt_trans _ Hx1 Hx2).

  intros v1 v2 v3 Hv1 Hv2.

  eapply lt_trans; [exact Hv1 | exact Hv2].

- intros.

  eapply sub_terms_strict_trans; eauto.

Qed.



Inductive list_order {A : Type} (R : A -> A -> Prop) : list A -> list A -> Prop :=

| lo_cons:  forall l1 l2 h, Forall (fun x => R x h) l1 -> list_order R (l1 ++ l2) (h :: l2).



Definition W {A : Type} (R : A -> A -> Prop) (l : list A) : Prop :=

  Acc (list_order R) l.



Lemma deuxpointun (A : Type) (R : A -> A -> Prop) (l : list A) (a : A) :

  (forall b, R b a -> forall l', W R l' -> W R (b :: l')) ->

   W R l 
 ->

  W R (a :: l).

Proof.

  intros H1 H2.

  constructor; intros l' Hlo.

  inversion Hlo; subst.

  induction l1.

  - simpl in *.

    constructor.

    apply H2.



  - constructor.

    assert (Ha0 : R a0 a) by (inversion H3; assumption).

    apply (H1 a0 Ha0).

    unfold W.

    apply IHl1; try constructor; inversion H3; assumption.

Qed.



Lemma deuxpointdeux (A : Type) (R : A -> A -> Prop) (l : list A) (a : A) : 

  (forall b, R b a -> forall l, W R l -> W R (b :: l)) ->

  (forall l, W R l -> W R (a :: l)).

Proof.

intros H l' Hacc.

induction Hacc as [l'' Hl'' _].

apply deuxpointun.

- intros b Hb l' Hl'.

  now apply H.



- now constructor.

Qed.



Lemma deuxpointtrois (A : Type) (R : A -> A -> Prop) (l : list A) (a : A) :

  well_founded R -> W R l -> W R (a :: l).

Proof.

intros HR.

revert l.

induction (HR a).

intros l Hl.

eapply deuxpointdeux; [ exact l | | exact Hl ].

intros b Hb l' Hl'.

now apply H0.

Qed.



Lemma list_order_wf (A : Type) (R : A -> A -> Prop) :

  well_founded R -> well_founded (list_order R).

Proof.

intro HwfR.

intro l.

induction l.

- constructor.

  intros.

  inversion H.



- now apply deuxpointtrois.

Qed.



Lemma product_suml_lt l1 l2 : 

  product lt l1 l2 ->

  suml l1 < suml l2.

Proof.

intro Hprod.

induction Hprod.

- simpl; subst; omega.



- simpl.

  apply plus_lt_le_compat; [assumption|].

  induction H0.

  + trivial.



  + assert (x0 <= y0) by (destruct H0; omega).

     simpl; omega.

Qed.



Lemma PPO_active_term_order_superset act act' :

  PPO rank (term_from_active_term act) (term_from_active_term act') ->

  active_term_order_superset act act'.

Proof.

intro HPPO.

destruct act as (f & lv).

destruct act' as (f' & lv').

simpl in HPPO.

inversion HPPO; subst.

- apply in_map_iff in H1.

  destruct H1 as (v & Hv & _).

  destruct v.

  inversion Hv.



- apply in_map_iff in H2.

  destruct H2 as (v & Hv & _).

  subst t.

  contradict H3.

  apply fapply_not_PPO_value; trivial.

  apply term_value_eqv; eauto.



- now left.



- unfold active_term_order_superset.

  simpl.

  rewrite H2.

  right.

  unfold value_list_order.

  apply product_suml_lt.

  clear f f' H2 HPPO.

  revert H4; intros Hppo.

  assert (Hlen := Hppo).

  apply product_length in Hlen.

  do 2 rewrite map_length in Hlen.

  revert lv' Hppo Hlen;

    induction lv as [ | v lv IH ];

    intros lv' Hppo Hlen;

    destruct lv' as [ | v' lv' ];

    simpl in *;

    try discriminate Hlen.



  + inversion Hppo.



  + revert Hppo;

    set (lt := map (@term_from_value _ _ _) lv : list term);

    set (lt' := map (@term_from_value _ _ _) lv' : list term);

    intros Hppo.

    apply eq_add_S in Hlen.

    inversion Hppo; subst.



    * apply term_from_value_injective in H2; subst v'.

      apply product_conseq; trivial.

      apply IH; assumption.



    * apply product_consst;

      [ apply (PPO_value_lt_size variable function) with (rank := rank); assumption | ].



      { clear Hppo v v' IH H2;

        revert lt lv' lt' Hlen H4;

        induction lv as [ | v lv IH ];

        intros lt lv' lt' Hlen Hfor;

        destruct lv' as [ | v' lv' ];

        [ constructor

        | inversion Hlen

        | inversion Hlen

        | ].



        subst lt lt'.

        simpl in *.

        apply eq_add_S in Hlen.

        constructor.



        - inversion Hfor; subst.

          destruct H2.

          + left.

            apply (PPO_value_lt_size variable function) with (rank := rank); assumption.

          + right.

            f_equal.

            apply (@term_from_value_injective variable function); assumption.

        - apply IH;

          [ | inversion Hfor ];

          assumption.

      }

Qed.



Lemma term_order_PPO t1 t2 : term_order t1 t2 -> PPO rank t1 t2.

Proof.

intro Horder.

unfold term_order in Horder.

induction t2 using term_ind2.

- inversion Horder.



- simpl in Horder.

  apply in_flat_map in Horder.

  destruct Horder as (t' & Hin & Ht').

  apply PPO_trans_eq with t'.

  + apply sub_term_eq_or_strict in Ht'.

    destruct Ht' as [Heq | Ht'].

    * now subst; right.



    * left; apply H; assumption.



  + now apply ppo_constr_in.



- simpl in Horder.

  apply in_flat_map in Horder.

  destruct Horder as (t' & Hin & Ht').

  apply PPO_trans_eq with t'.

  + apply sub_term_eq_or_strict in Ht'.

    destruct Ht' as [Heq | Ht'].

    * now subst; right.



    * left; apply H; assumption.



  + now apply ppo_fun_in.

Qed.



Lemma max_arity_subst s t f lp :

  rule_vars_defined (rule_intro f lp t) ->

  let t' := fapply f (map (fun p => term_from_value variable function (@psubst variable constructor s p)) lp) in

  max_arity_term (subst s t) <= Nat.max (max_arity_rule (rule_intro f lp t)) (max_arity_term t').

Proof.

  intros Hvars t'.

  assert (Hn : forall x, In x (vars_of_term t) ->

                   max_arity_term (term_from_value variable function (s x)) <= max_arity_term t').

  { subst t'.

    intros x Hx; apply Hvars in Hx; simpl.

    rewrite PeanoNat.Nat.max_le_iff; right.

    clear t f Hvars.

    rewrite in_flat_map in Hx; destruct Hx as (p & Hp & Hvars).

    transitivity (max_arity_term (term_from_value variable function (psubst s p))).

    - clear lp Hp; revert x Hvars.

      induction p as [ x | c lp IH ] using pattern_ind2.

      + simpl.

        intros x' H; destruct H; [ subst x' | ]; easy.

      + intros x Hx; simpl in Hx.

        apply in_flat_map in Hx; destruct Hx as (p & Hp & Hvars).

        transitivity (max_arity_term (term_from_value variable function (psubst s p))).

        * now apply IH.

        * simpl.

          rewrite PeanoNat.Nat.max_le_iff; right.

          now apply maxl_is_max, in_map, in_map, in_map.

    - apply maxl_is_max, in_map.

      set (t := term_from_value _ _ _);

      change (term_from_value _ _ _) with ((fun p => term_from_value variable function (psubst s p)) p) in t;

        subst t.

      now apply in_map.

  }



  remember (max_arity_term t') as n eqn: Heq; clear Heq.

  transitivity (Nat.max (max_arity_term t) n).

  - clear f lp t' Hvars.

    induction t as [ x | c lt IH | f lt IH ] using term_ind2.

    + simpl; apply Hn.

      simpl; now left.



    + simpl; rewrite <- Max.max_assoc.

      apply Nat.max_le_compat; [ now rewrite map_length | ].

      simpl in Hn; clear c.

      induction lt as [ | t lt IHlt ]; [ now apply le_O_n | ].

      simpl.

      set (ml := maxl _) at 2.

      replace (Nat.max (Nat.max (max_arity_term t) ml) n)

      with (Nat.max (Nat.max (max_arity_term t) n) (Nat.max ml n));

        [ | now rewrite <- Max.max_assoc, (Max.max_assoc n), (Max.max_comm n),

            <- (Max.max_assoc ml), Max.max_idempotent, Max.max_assoc ].

      subst ml; apply Nat.max_le_compat.



      * apply IH; [ now left | ].

        intros x Hx; apply Hn.

        now simpl; apply in_or_app; left.



      * apply IHlt.

        now intros t' Ht'; apply IH; right.

        now intros x Hx; apply Hn; simpl; apply in_or_app; right.



    + simpl; rewrite <- Max.max_assoc.

      apply Nat.max_le_compat; [ now rewrite map_length | ].

      simpl in Hn; clear f.

      induction lt as [ | t lt IHlt ]; [ now apply le_O_n | ].

      simpl.

      set (ml := maxl _) at 2.

      replace (Nat.max (Nat.max (max_arity_term t) ml) n)

      with (Nat.max (Nat.max (max_arity_term t) n) (Nat.max ml n));

        [ | now rewrite <- Max.max_assoc, (Max.max_assoc n), (Max.max_comm n),

            <- (Max.max_assoc ml), Max.max_idempotent, Max.max_assoc ].

      subst ml; apply Nat.max_le_compat.



      * apply IH; [ now left | ].

        intros x Hx; apply Hn.

        now simpl; apply in_or_app; left.



      * apply IHlt.

        now intros t' Ht'; apply IH; right.

        now intros x Hx; apply Hn; simpl; apply in_or_app; right.



  - simpl.

    apply PeanoNat.Nat.max_le_compat_r.

    now apply PeanoNat.Nat.le_max_l.

Qed.



Lemma first_rule_max_arity act t i s :

  wf_prog max_arity prog ->

  first_rule act = Some (i, s, t) ->

  max_arity_term (term_from_active_term act) <= max_arity ->

  max_arity_term t <= max_arity.

Proof.

intros Hwfprog Hrule.

destruct act as [f lv].

apply first_rule_sound in Hrule.

destruct Hrule as ([lp'  t''] & Hlengthi & Heqi & Hunify_list & Hsubst).

subst t.

etransitivity.

- apply max_arity_subst with (f := f) (lp := lp').

  eapply andl_in; [ apply Hwfprog | ].

  apply in_map.

  rewrite <- Heqi.

  now apply nth_In.

- apply Max.max_lub.

   + etransitivity; [ apply maxl_is_max  | apply Hwfprog].

       apply in_map.

       rewrite <- Heqi.

       apply nth_In; trivial.

   + rewrite <- map_map.

      erewrite unify_list_sound; eauto.

Qed.



Inductive evaluates : term -> value -> Prop :=

| CAPPLY : forall lt lv c, evaluates_list lt lv -> evaluates (capply c lt) (c_capply c lv)

| FAPPLY : forall lt lv f v i s t, evaluates_list lt lv -> 

           first_rule (f, lv) = Some (i, s, t) -> 

           evaluates t v ->

           evaluates (fapply f lt) v

with evaluates_list : list term -> list value -> Prop :=

| E_nil : evaluates_list [] []

| E_cons : forall t v lt lv, evaluates t v -> evaluates_list lt lv -> evaluates_list (t :: lt) (v :: lv).



Scheme evaluates_mut := Induction for evaluates Sort Prop

with evaluates_list_mut := Induction for evaluates_list Sort Prop.



Lemma evaluates_ind2 : forall P,

(forall lt lv c, Forall2 evaluates lt lv ->

                 Forall2 P lt lv ->

                 P (capply c lt) (c_capply c lv)) ->

(forall lt lv f i s v t,

  Forall2 evaluates lt lv -> Forall2 P lt lv ->

  first_rule (f, lv) = Some (i, s, t) ->

  evaluates t v -> P t v ->

  P (fapply f lt) v) ->

forall (t : term) (v : value), evaluates t v -> P t v.

Proof.

intros P Hc Hf t v He.

induction He using evaluates_mut with (P := fun t v H => P t v)

(P0 := fun lt lv H => Forall2 P lt lv /\ Forall2 evaluates lt lv).

- apply Hc; tauto.

- eapply Hf; eauto; tauto.

- auto.

- split; constructor; auto; tauto.

Qed.



Inductive Forall2' (A B : Type) (R : A -> B -> Type) : list A -> list B -> Type :=

    Forall2'_nil : Forall2' R [] []

  | Forall2'_cons : forall (x : A) (y : B) (l : list A) (l' : list B),

                   R x y -> Forall2' R l l' -> Forall2' R (x :: l) (y :: l').



Lemma Forall2_trans_rel (A : Type) (R1 R2 : A -> A -> Prop) (l1 l2 : list A) : (forall x y, R1 x y -> R2 x y) -> Forall2 R1 l1 l2 -> Forall2 R2 l1 l2.

Proof.

intros H Hall.

induction Hall; auto.

Qed.



Lemma Forall2_product (A : Type) (R : A -> A -> Prop) (ls lt : list A) :

  ls <>  [] -> Forall2 R ls lt -> product R ls lt.

Proof.

induction ls; intros Hnil Hall; try tauto.

clear Hnil.

destruct lt as [ | b lt]; [inversion Hall |].

inversion Hall; subst.

constructor 2; trivial.

eapply Forall2_trans_rel.

- intros; constructor; exact H.

- trivial.

Qed.



Lemma Forall2_eq A (l1 l2 : list A) :

  Forall2 eq l1 l2 -> l1 = l2.

Proof.

intro H; induction H; subst; trivial.

Qed.



Lemma evaluates_unique t v1 v2 :

  evaluates t v1 ->

  evaluates t v2 ->

  v1 = v2.

Proof.

intro H1; revert v2.

induction H1 using evaluates_ind2.

- intros v2 H2.

  inversion H2; subst; clear H2.

  f_equal; revert lv0 H5.

  induction H; intros lv0 Hlv0; inversion Hlv0; trivial.

  subst.

  f_equal; inversion H0; subst; auto.

- intros v2 Hv2.

  inversion Hv2; subst; clear Hv2.

  assert (Heq : lv = lv0) by

   (clear H6 H1; revert lv0 H5;

    induction H; intros lv0 Hlv0; inversion Hlv0; trivial;

    subst; f_equal; inversion H0; subst; auto).

  subst lv0.

  rewrite H6 in H1; inversion H1; subst.

  now apply IHevaluates.

Qed.



Lemma evaluates_value v : 

  evaluates (term_from_value _ _ v) v.

Proof.

induction v using value_ind2.

constructor.

induction l as [|v lv]; constructor; auto with *.

Qed.



Lemma In_nth:

  forall (A : Type) (l : list A) (x d : A) n,

  n < length l -> nth n l d = x -> x ∈ l.

Proof.

intros A l x d n.

revert l.

induction n; intros [ | a l];

unfold nth; simpl; intros; try tauto; try omega.

auto with *.

Qed.



Lemma evaluates_sound t v c:

  (forall (t0 : term) (v0 : value), assoc_cache t0 c = Some v0 

    -> evaluates t0 v0 /\ max_arity_term (term_from_value variable function v0) <= max_arity) ->

  evaluates t v ->

  max_arity_term t <= max_arity ->

  exists p, wf p /\ proj_right p = v /\ proj_left p = t /\ cache_left p = c /\

            max_arity_term (term_from_value variable function v) <= max_arity /\

   (forall t0 v0, assoc_cache t0 (cache_right p) = Some v0

      -> evaluates t0 v0 /\ max_arity_term (term_from_value variable function v0) <= max_arity).

Proof.

intros Hc Heval.

revert c Hc.

induction Heval using evaluates_ind2; intros c0 Hc0 Harity.

- assert (Hlp : exists lp c1,

    andl (map wf lp) /\ map (@proj_left _ _ _) lp = lt /\

    map (@proj_right _ _ _) lp = lv /\

    cache_path variable_eq_dec function_eq_dec constructor_eq_dec c0 c1 lp = true /\

    maxl (map (@max_arity_term _ _ _) (map (@term_from_value variable function _) lv)) <= max_arity /\

    forall (t0 : term) (v : value), assoc_cache t0 c1 = Some v -> evaluates t0 v 

        /\ max_arity_term (term_from_value variable function v) <= max_arity

    ).

  { assert (Harityall: forall t, In t lt -> max_arity_term t <= max_arity) by

    ( intros t Ht; simpl in Harity; apply Max.max_lub_r in Harity;

      etransitivity; [ | apply Harity]; now apply maxl_is_max, in_map).

    clear Harity H.

    revert c0 lv H0 Hc0.

    induction lt using rev_ind; intros c0 lv H0 Hc0.

   - exists []; exists c0; simpl.

     inversion H0.

     simpl; intuition.

     now rewrite cache_beq_refl.

   - apply Forall2_app_inv_l in H0.

     destruct H0 as (lv' & ly & Hlt & Hx & Heq).

     subst lv.

     inversion Hx; subst.

     inversion H3; subst; clear H3.

     destruct IHlt with (c0 := c0) (lv := lv') as (lp & c' & Hlp);

     auto with *.

     decompose record Hlp.

     destruct H1  with (c:= c') as [p Hp]; auto with *.

     exists (lp ++ [p]); exists (cache_right p).

     decompose record Hp; subst.

     rewrite map_app, cache_path_app, andl_app.

     repeat rewrite map_app.

     simpl; repeat rewrite cache_beq_refl.

     repeat split; try tauto.

     + rewrite maxl_app.

       apply Nat.max_lub; trivial.

       simpl.

       now rewrite Max.max_0_r.

     + now apply H12.

     + now apply H12 in H0.

  }

  destruct Hlp as [lp Hlp]; decompose record Hlp.

  eexists (cbv_constr  _ _ (capply c lt) _ (c_capply c lv)); simpl.

  repeat split; eauto.

  + erewrite <- map_length; rewrite H1.

    now apply Max.max_lub_l in Harity.

  + apply Nat.max_lub; trivial.

    rewrite map_length.

    apply Max.max_lub_l in Harity.

    subst lv lt.

    now rewrite map_length in *.

  + now apply H7.

  + edestruct H7; eauto.

- assert (Hlp : exists lp c1,

    andl (map wf lp) /\ map (@proj_left _ _ _) lp = lt /\

    map (@proj_right _ _ _) lp = lv /\

    cache_path variable_eq_dec function_eq_dec constructor_eq_dec c0 c1 lp = true /\

    maxl (map (@max_arity_term _ _ _) (map (@term_from_value variable function _) lv)) <= max_arity /\

    forall (t0 : term) (v : value), assoc_cache t0 c1 = Some v -> evaluates t0 v

    /\ max_arity_term (term_from_value variable function v) <= max_arity



    ).

  { assert (Harityall: forall t, In t lt -> max_arity_term t <= max_arity) by

    ( intros t0 Ht; simpl in Harity; apply Max.max_lub_r in Harity;

      etransitivity; [ | apply Harity]; now apply maxl_is_max, in_map).

    clear Harity H1 H.

    revert c0 lv H0 Hc0.

    induction lt using rev_ind; intros c0 lv H0 Hc0.

   - exists []; exists c0; simpl.

     inversion H0.

     simpl; intuition.

     now rewrite cache_beq_refl.

   - apply Forall2_app_inv_l in H0.

     destruct H0 as (lv' & ly & Hlt & Hx & Heq).

     subst lv.

     inversion Hx; subst.

     inversion H3; subst; clear H3.

     destruct IHlt with (c0 := c0) (lv := lv') as (lp & c' & Hlp);

     auto with *.

     decompose record Hlp.

     destruct H1  with (c:= c') as [p Hp]; auto with *.

     exists (lp ++ [p]); exists (cache_right p).

     decompose record Hp; subst.

     rewrite map_app, cache_path_app, andl_app.

     repeat rewrite map_app.

     simpl; repeat rewrite cache_beq_refl.

     repeat split; try tauto.

     + rewrite maxl_app.

       apply Nat.max_lub; trivial.

       simpl.

       now rewrite Max.max_0_r.

     + now apply H12.

     + now apply H12 in H0.

  }

  destruct Hlp as (lp & cr & Hlp); decompose record Hlp.

  case_eq (assoc (term_beq variable_eq_dec function_eq_dec constructor_eq_dec) (fapply f (map (@term_from_value _ _ _) lv)) cr).

  + intros v0 Hv0.

    destruct (H8 _ _ Hv0) as [Heval0 Harity0].

    eexists (cbv_split _ (cbv_read _ (fapply f _) _) _ _ _ _).

    subst.

    assert (v0 = v).

    { eapply evaluates_unique; eauto.

      econstructor; eauto.

      clear H H1 H0 H2 H5 H6 Hv0 H8 Hlp cr IHHeval Harity Heval0.

      induction lp; constructor; trivial.

      apply evaluates_value.

    }

    subst v0.

    repeat split; trivial;simpl; repeat split; eauto.

    * apply Max.max_lub_l in Harity.

      now rewrite map_length in Harity.

    * now apply H8.

    * now apply H8 in H3.

  + assert(Hrule := H1).

    apply first_rule_sound in H1.

    destruct H1 as [[lp' t'] (Hlen & Hnth & Hunify & Hsubst)].

    destruct IHHeval with cr as [p Hp]; trivial.

    * unfold wf_prog in prog_is_wf; destruct prog_is_wf as (Hvars & Hmaxarity).

      subst t.

      apply first_rule_max_arity in Hrule; trivial.

      simpl; rewrite map_length.

      apply Nat.max_lub; trivial.

      subst lv lt.

      apply Nat.max_lub_l in Harity.

      now rewrite map_length in *.

    * intro Hcache.

      decompose record Hp; decompose record Hlp.

      set (tt := fapply f(map (term_from_value variable function (constructor:=constructor)) (map (psubst s) lp'))).

      eexists (cbv_split lp (cbv_update i s p cr (fapply f _) ((tt, v) :: (cache_right p)) v) _ (fapply f lt) ((tt, v):: (cache_right p)) v).

      simpl; subst.

      assert(Hlp_len : length lp <= max_arity) by

      (simpl in Harity; rewrite map_length in Harity; lia).

      apply unify_list_sound in Hunify.

      rewrite <- H7 in *; simpl.

      repeat split; auto.

      -- subst tt; exists lp'; rewrite Hunify.

         eexists; repeat split; eauto; try tauto.

         now repeat rewrite map_length.

      -- intros.

         case_eq (term_beq variable_eq_dec function_eq_dec constructor_eq_dec t0 tt).

         ++ intro Heq; rewrite term_beq_eq in Heq; subst t0.

            replace (term_beq variable_eq_dec function_eq_dec constructor_eq_dec tt tt) with true in H1 by

            (symmetry; now apply term_beq_eq).

            subst tt.

            eapply FAPPLY with (lv := (map (proj_right (constructor:=constructor)) lp)) (i := i) (s := s) (t := proj_left p); trivial.

            ** rewrite Hunify.

               clear H6 H3 H0 H1 Hcache Hlp H5 H6 H7 H11 H12 H13 H16 H14 H2 Harity H Hunify Hlp_len Hrule.

               induction lp; constructor.

               apply evaluates_value.

               apply IHlp; trivial.

               simpl in H17.

               now apply Nat.max_lub_r in H17.

            ** assert( Hbeq : forall t, term_beq variable_eq_dec function_eq_dec constructor_eq_dec t t = true) by

               (now intros; rewrite term_beq_eq).

               rewrite Hbeq in H3.

               now inversion H3.

         ++ intro Heq; rewrite Heq in H3.

            now apply H13.

      -- case_eq (term_beq variable_eq_dec function_eq_dec constructor_eq_dec t0 tt).

         ++ intro Heq; rewrite Heq in H3; inversion H3; now subst.

         ++ intro Hneq; rewrite Hneq in H3.

            now apply H13 in H3.

Qed.



Lemma evaluates_sound' (t : term) (v : value):

  evaluates t v ->

  max_arity_term t <= max_arity ->

  exists p, wf p /\ proj_right p = v /\ proj_left p = t.

Proof.

intros.

destruct (@evaluates_sound t v []); trivial.

- intros t' v' Hf; inversion Hf.

- intuition; eexists; eauto.

Qed.



End Evaluates.



Create HintDb eval.



Ltac reduce := 

  progress (repeat constructor) ||

  (econstructor; [repeat constructor; repeat reduce; eauto with eval

                              | solve [unfold first_rule; simpl; trivial]

                              | unfold assoc_default; repeat constructor; eauto with eval]).



Hint Extern 1 (@evaluates _ _ _ _ _ _ _ _ _ _)  => eapply evaluates_value: eval.

