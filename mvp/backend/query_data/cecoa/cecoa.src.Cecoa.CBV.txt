Require Import Arith Compare_dec Max List Omega.
Import List.ListNotations.
Require Import Cecoa.Lib Cecoa.Syntax.
(* Cecoa.Lib:
Require Import Bool Arith Max Omega Psatz List NPeano Permutation.
Import List.ListNotations.

Require Import Unicode.Utf8_core.
Require Import Unicode.Utf8.
Notation "x ≤ y ≤ z" := (x ≤ y ∧ y ≤ z) (at level 70, y at next level).
Notation "x < y ≤ z" := (x < y ∧ y ≤ z) (at level 70, y at next level).
Notation "x ≤ y < z" := (x ≤ y ∧ y < z) (at level 70, y at next level).

Infix "∈" := In (at level 70).

Infix "=?" := beq_nat (at level 70, no associativity).

Obligation Tactic := idtac.

Scheme Equality for prod.
Scheme Equality for list.

Set Implicit Arguments.

Section Trivial.
Lemma S_is_suc n: S n = n+1.
Lemma or_idem: ∀ A, A ↔ A ∨ A.
Lemma and_idem: ∀ A, A ↔ A ∧ A.
Lemma and_left: ∀ A B, A ∧ B → A.
Lemma or_false_idem: ∀ A, A ↔ A ∨ False.

Definition fmono (f: nat → nat):= ∀ x y, x ≤ y → f x ≤ f y.

Lemma forall_and {A:Type} (P Q:A→Prop):
  (∀ x, P x ∧ Q x) ↔ ((∀ x, P x) ∧ (∀ x, Q x)).
Lemma forall_impl_and {A:Type} (R:A→Prop) (P Q:A→Prop):
  (∀ x, R x → P x ∧ Q x) ↔
  ((∀ x, R x → P x) ∧ (∀ x, R x → Q x)).
Lemma forall_impl2_and {A B:Type} (P Q R : A → B → Prop):
  (∀ x y, R x y → P x y ∧ Q x y) ↔ 
  ((∀ x y, R x y → P x y) ∧ (∀ x y, R x y → Q x y)).

Lemma eqb_subst_neq x y:
  x ≠ y → (x =? y) = false.
Lemma neq_lt_gt_iff (m n:nat):
  m ≠ n ↔ (m < n ∨ n < m).

Lemma length_nil : forall A (l : list A),
  length l = 0 -> l = nil.
End Trivial.

Lemma prod_beq_eq A B
  (A_beq : A -> A -> bool) (B_beq : B -> B -> bool)
  (A_beq_eq : forall a1 a2, A_beq a1 a2 = true <-> a1 = a2) (B_beq_eq : forall b1 b2, B_beq b1 b2 = true <-> b1 = b2)
  p1 p2 : prod_beq _ _ A_beq B_beq p1 p2 = true <-> p1 = p2.

Lemma list_beq_eq A
  (A_beq : A -> A -> bool) l1 l2 (A_beq_eq : forall a1 a2, In a1 l1 -> In a2 l2 -> (A_beq a1 a2 = true <-> a1 = a2)) :
  list_beq _ A_beq l1 l2 = true <-> l1 = l2.

Lemma list_beq_refl (A : Type) (A_beq : A -> A -> bool) l :
  (forall a1 a2 : A, In a1 l -> In a2 l -> (A_beq a1 a2 = true <-> a1 = a2)) ->
  list_beq _ A_beq l l = true.

Lemma eq_None_neq_Some (A : Type) (x : option A) :
  x = None <-> forall v, x <> Some v.

Lemma neq_None_eq_Some :
  forall (A: Type) (x: option A), x <> None <-> (exists a, x = Some a).

Lemma app_insert_r (A : Type) (l1 l1' l l2 l2' : list A):
  l1 ++ l2 = l1' ++ l2' -> length l2 = length l2' -> l1 ++ l ++ l2 = l1' ++ l ++ l2'.

Section assoc.

Fixpoint assoc {A B : Type}(eq : A -> A -> bool)(x : A)(l : list (A * B)) : option B :=
  match l with
  | nil => None
  | (x', y) :: l' => if eq x x' then Some y else assoc eq x l'
  end.

Definition assoc_default {A B : Type}
  (eqA : A -> A -> bool) (d : B) (l : list (A * B)) (x : A) : B :=
  match assoc eqA x l with
  | None => d
  | Some b => b
  end.

Lemma assoc_in {A B:Type} beq k (l: list (A * B)) {v}:
  (∀ a b:A, beq a b = true ↔ a=b) →
  assoc beq k l = Some v → (k,v) ∈ l.

Lemma assoc_None_not_in {A B:Type} beq k (l:list (A*B)):
  (∀ a b : A, beq a b = true ↔ a = b) →
  assoc beq k l = None ↔ ¬ k ∈ map fst l.

Lemma in_assoc_neq_None (A B: Type) (beq: A -> A -> bool) (k: A) (l: list (A * B)):
  (forall a b:A, a = b -> beq a b = true) ->
  In k (map (@fst _ _) l) ->
  assoc beq k l <> None.

Lemma assoc_in_Some {A B:Type} (beq:A→A→bool) (k:A) (l: list (A*B)):
  (∀ a b, beq a b = true ↔ a=b) →
  k ∈ map fst l ↔ ∃ v, v ∈ map snd l ∧ assoc beq k l = Some v.

Lemma assoc_in_Some_simple {A B:Type} beq k (l: list (A*B)):
  (∀ a b:A, beq a b = true ↔ a = b) →
  k ∈ map fst l ↔ (∃ v, assoc beq k l = Some v).

Lemma assoc_app_eq_None (A B:Type) (eq: A -> A -> bool) (x: A) (l1 l2: list (A * B)) :
  assoc eq x (l1 ++ l2) = None <-> (assoc eq x l1 = None /\ assoc eq x l2 = None).

Lemma assoc_app_neq_None (A B:Type) (eq: A -> A -> bool) (x: A) (l1 l2: list (A * B)) :
  assoc eq x (l1 ++ l2) <> None <-> (assoc eq x l1 <> None \/ assoc eq x l2 <> None).

Lemma assoc_app_eq_Some (A B:Type) (eq: A -> A -> bool) (x: A) (v : B) (l1 l2: list (A * B)) :
  assoc eq x (l1 ++ l2) = Some v <->
  (assoc eq x l1 = Some v \/ (assoc eq x l1 = None /\ assoc eq x l2 = Some v)).

Lemma assoc_app_in {K V:Type} beq k (l1 l2: list (K*V)):
  (∀ a b : K, beq a b = true ↔ a = b) →
  k ∈ map fst l1 → assoc beq k (l1++l2) = assoc beq k l1.

Lemma assoc_app_out {K V:Type} beq k (l1 l2: list (K*V)):
  (∀ a b : K, beq a b = true ↔ a = b) →
  ¬ k ∈ map fst l1 → assoc beq k (l1++l2) = assoc beq k l2.

Lemma assoc_in_concat {K V:Type} beq (k:K) ll (v:V):
  assoc beq k (concat ll) = Some v →
  ∃ l : list (K * V), l ∈ ll ∧ assoc beq k l = Some v.

End assoc.

Lemma map_in_ext :
  forall (A B : Type) (f g : A -> B) (l : list A),
  (forall a : A, In a l -> f a = g a) -> map f l = map g l.

Lemma incl_cons_cons A: forall (a:A) (l1 l2: list A), incl l1 l2 -> incl (a::l1) (a::l2).

Lemma map_incl A B (f : A -> B) l1 l2 : incl l1 l2 -> incl (map f l1) (map f l2).

Lemma map_flat_map (A B C : Type) (f : A -> list B) (g : B -> C) (l : list A) :
map g (flat_map f l) = flat_map (fun a => map g (f a)) l.

Lemma incl_filter (A : Type) (f : A -> bool) l:
  incl (filter f l) l.

Lemma filter_ext_In {A : Type} f g (l : list A): (forall a , In a l -> f a = g a)-> filter f l = filter g l.

Lemma filter_app A (f : A -> bool) l1 l2 : filter f (l1 ++ l2) = filter f l1 ++ filter f l2.

Lemma filter_flat_map A B f (g : A -> list B) l : filter f (flat_map g l) = flat_map (fun x => filter f (g x)) l.

Lemma flat_map_in_ext  A B (f g : A -> list B) l : 
  (forall a : A, In a l -> f a = g a) -> flat_map f l = flat_map g l.

Lemma NoDup_filter A f (l : list A) : NoDup l -> NoDup (filter f l).

Lemma map_cons (A B : Type)(f : A -> B) a l : map f (a :: l) = f a :: map f l.

Lemma length_remove A eq_A_dec (a: A) l :
  length (remove eq_A_dec a l) <= length l.

Lemma length_cons_remove A eq_A_dec (a: A) l :
  In a l -> length (a :: remove eq_A_dec a l) <= length l.

Lemma neq_in_in_remove A eq_A_dec (a a': A) l:
  a' <> a -> In a l -> In a (remove eq_A_dec a' l).

Lemma incl_remove_app A l l1 l2 (x : A) : ~ In x l -> incl l (l1 ++ x :: l2) -> incl l (l1 ++ l2).

Lemma flat_map_nil (A B: Type) (f: A -> list B) (xs: list A):
  (forall x, In x xs -> f x = []) ->
  flat_map f xs = [].

Lemma flat_map_comp (A B C : Type) (f : A -> B) (g : B -> list C) (h : A -> list C) (l : list A) :
  (forall x, In x l -> h x = g (f x)) -> flat_map h l = flat_map g (map f l).

Lemma flat_map_app (A B : Type) (f : A -> list B) l1 l2 :
  flat_map f (l1 ++ l2) = flat_map f l1 ++ flat_map f l2.

Lemma comp_flat_map (A B C : Type) (f : A -> list B) (g : B -> list C) h l :
  (forall a, In a l -> h a = flat_map g (f a)) -> flat_map h l = flat_map g (flat_map f l).

Fixpoint andl (l : list Prop) : Prop :=
  match l with
  | nil => True
  | P :: l' => P /\ andl l'
  end.

Lemma andl_cons: forall a l, andl (a::l) <-> a /\ (andl l).

Lemma andl_in : forall l P, andl l -> In P l -> P.

Lemma andl_in_map (A:Type): forall l (a:A) P, andl (map P l) -> In a l -> P a.

Lemma andl_map (A : Type) (f g : A -> Prop) l :
  andl (map f l) -> (forall a, In a l -> f a -> g a) -> andl (map g l).

Lemma andl_app l1 l2 : andl (l1 ++ l2) <-> andl l1 /\ andl l2.

Fixpoint orl (l : list Prop) : Prop :=
  match l with
  | nil => False
  | P :: l' => P \/ orl l'
  end.

Lemma andl_concat l:
  andl (concat l) <-> forall l', In l' l -> andl l'.

Lemma orl_map (A : Type) (P : A -> Prop) l : orl (map P l) <-> exists x, In x l /\ P x.

Section Maxl.
Fixpoint maxl (l : list nat) : nat :=
  match l with
  | nil => 0
  | n :: l' => max n (maxl l')
  end.

Lemma maxl_is_max :
  forall l n, In n l -> n <= maxl l.

Lemma all_max_le l y :
  (forall x, In x l -> x <= y) -> maxl l <= y.

Lemma maxl_app : forall (l1 l2 : list nat), maxl (l1 ++ l2) = max (maxl l1) (maxl l2).

Lemma in_maxl (l : list nat) : l<>nil -> In (maxl l) l.

Lemma all_maxl P xs: xs <> [] -> (forall x, In x xs -> P x) -> P (maxl xs).

Lemma maxl_le_maxl A f g (l : list A) :
(forall x, In x l -> f x <= g x) -> maxl (map f l) <= maxl (map g l).

Lemma maxl_map_const {A:Type} l (f: A → nat) n:
  (∀ x, x ∈ l → (f x) = n) →
  l ≠ [] → maxl (map f l) = n.

Lemma maxl_map_0 A l (f : A -> nat) : 
  (forall x, In x l -> (f x) = 0) ->
  maxl (map f l) = 0.

Lemma maxl_map_plus_le A f g (l : list A) :
  maxl (map (fun x => f x + g x) l) <= maxl (map f l) + maxl (map g l).

Lemma maxl_concat: forall l,
  maxl (concat l) = maxl (map maxl l).

Lemma maxl_map_lt_iff (A:Type): forall (l:list A) f n,
  0<n -> maxl (map f l) < n <-> (forall m, In m l -> (f m) < n).

Lemma maxl_map_le_iff (A:Type): forall (l:list A) f n,
  maxl (map f l) <= n <-> (forall m, In m l -> (f m) <= n).

Lemma maxl_map_is_max_map (A:Type): forall (l:list A) f a,
  In a l -> (f a) <= maxl (map f l).

Lemma maxl_eq_maxl {A:Type} f g (l:list A):
  (∀ x : A, x ∈ l → f x = g x) →
  maxl (map f l) = maxl (map g l).
End Maxl.

Lemma in_concat_iff (A:Type) x (l:list (list A)):
  x ∈ concat l <-> exists l', l' ∈ l /\ x ∈ l'.

Lemma incl_le_maxl :
  forall (l1 l2 : list nat), incl l1 l2 -> maxl l1 <= maxl l2.

Lemma maxl_cons : forall n l, maxl (n::l) = max n (maxl l).

Lemma forall2_le_maxl :
  forall (l1 l2 : list nat), Forall2 le l1 l2 -> maxl l1 <= maxl l2.

Lemma incl_flat_map (A B : Type) (f g : A -> list B) l :
  (forall a, In a l -> incl (f a) (g a)) ->
  incl (flat_map f l) (flat_map g l).

Section suml.

Fixpoint suml (l : list nat) : nat :=
  match l with
  | nil => 0
  | n :: l' => n + suml l'
  end.

Lemma suml_cons n l : suml (n :: l) = n + suml l.

Lemma suml_map_const A n (l : list A) : suml (map (fun _ => n) l) = n * length l.

Lemma mult_suml_r m l : m * suml l = suml (map (fun n => m * n) l).

Lemma suml_app l1 l2 : suml (l1 ++ l2) = suml l1 + suml l2.

Lemma suml_flat_map (A : Type)(f : A -> list nat)(l :list A) :
  suml (flat_map f l) = suml (map suml (map f l)).

Lemma suml_flat_map_map (A B : Type) (f : A -> list B) (g : B -> nat) l :
  suml (flat_map (fun x => map g (f x)) l) = suml (map (fun x => suml (map g (f x))) l).

Lemma suml_map_plus (A : Type)(f g : A -> nat)(l : list A) : suml (map (fun x => f x + g x) l) = suml (map f l) + suml (map g l).

Lemma suml_map_le :
  forall (A : Type)(f g : A -> nat)(l : list A),
  (forall x, In x l -> f x <= g x) -> suml (map f l) <= suml (map g l).

Lemma suml_map_eq :
  forall (A : Type)(f g : A -> nat)(l : list A),
  (forall x, In x l -> f x = g x) -> suml (map f l) = suml (map g l).

Lemma suml_map_le_plus_length :
  forall (A : Type)(f g : A -> nat)(l : list A),
  (forall x, In x l -> f x <= g x + 1) -> suml (map f l) <= suml (map g l) + length l.

Lemma suml_le_len_times_bound l b :
  (forall x, In x l -> x <= b) -> suml l <= length l * b.

Lemma in_le_suml :
  forall (n : nat)(l : list nat),
  In n l -> n <= suml l.

Lemma maxl_le_suml l: maxl l <= suml l.

Lemma forall2_le_suml :
  forall (l1 l2 : list nat), Forall2 le l1 l2 -> suml l1 <= suml l2.

Lemma maxl_le_suml_map (A B : Type) (f : A -> list B) (g : B -> nat) (h : A -> nat) (l : list A) :
  (forall a, In a l -> maxl (map g (f a)) <= h a) ->
  maxl (map g (flat_map f l)) <= suml (map h l).

Lemma suml_map_mult_le_suml_mult_maxl (A : Type) f g (l : list A) :
  suml (map (fun x => f x * g x) l) <= suml (map f l) * maxl (map g l).

Lemma suml_map_mult_le_suml_mult_suml (A : Type) f g (l : list A) :
  suml (map (fun x => f x * g x) l) <= suml (map f l) * suml (map g l).

Lemma length_flat_map (A B : Type) ( f : A -> list B) (l : list A) :
  length (flat_map f l) = suml (map (@length _) (map f l)).

Lemma seq_Succ n m : seq n (S m) = seq n m ++ [m + n].

Lemma Permutation_filter {A : Type} f (l : list A) : Permutation l (filter f l ++ filter (fun x => negb (f x)) l).

Lemma filter_compose {A : Type} f g (l : list A) : 
  (forall x, In x l -> ( f x = true -> g x = true)) ->
  filter f (filter g l) = filter f l.

Lemma in_seq : forall len start n : nat,
       In n (seq start len) <-> start <= n < start + len.

Lemma Permutation_partition_list_nat b n l :
 (forall x, In x l -> b <= x < b + n) ->
 Permutation l (flat_map (fun n => filter (beq_nat n) l) (seq b n)).

Lemma length_suml_filter b n l:
 (forall x, In x l -> b <= x < b + n) ->
 suml (map (fun r => length(filter (beq_nat r) l )) (seq b n)) = length l.

End suml.

Section prodl.

Fixpoint prodl (l : list nat) : nat :=
  match l with
  | nil => 1
  | n :: l' => n * prodl l'
  end.

Lemma prodl_bound (l : list nat) (b : nat) : 
  (forall x, In x l -> x <= b) -> prodl l <= Nat.pow b  (length l).

End prodl.

Definition clos_refl {A : Type} (R : A -> A -> Prop) (x y : A) : Prop :=
  R x y \/ x = y.

Lemma clos_refl_trans (A: Type) (R: A -> A -> Prop) t1 t2 t3:
    (R t1 t2 -> R t2 t3 -> R t1 t3) ->
    clos_refl R t1 t2 -> clos_refl R t2 t3 -> clos_refl R t1 t3.

Lemma Forall2_eq_clos_refl (A:Type) (R: A -> A -> Prop) (l1 :list A) :
  Forall2 (clos_refl R) l1 l1.

Lemma Forall_In_l (A : Type) (P : A -> Prop) x xs:
  Forall P xs -> In x xs -> P x.

Lemma Forall2_In_l (A B : Type) (R : A -> B -> Prop) x xs ys :
  Forall2 R xs ys -> In x xs -> exists y, In y ys /\ R x y.

Lemma Forall2_In_r (A B : Type) (R : A -> B -> Prop) y xs ys :
  Forall2 R xs ys -> In y ys -> exists x, In x xs /\ R x y.

Lemma Forall2_conj (A B : Type) (R1 R2 : A -> B -> Prop) xs ys :
  Forall2 R1 xs ys -> Forall2 R2 xs ys -> Forall2 (fun x y => R1 x y /\ R2 x y) xs ys.

Lemma Forall2_trans (A: Type) (R: A -> A -> Prop) xs ys zs :
    (forall x y z, In x xs -> In y ys -> In z zs -> R x y -> R y z -> R x z) ->
    Forall2 R xs ys -> Forall2 R ys zs -> Forall2 R xs zs.

Lemma Forall2_length A B (R : A -> B -> Prop) xs ys :
  Forall2 R xs ys -> length xs = length ys.

Lemma Forall2_map (A:Type) (B:Type): forall l f g (R:B->B->Prop),
  (forall (x:A), In x l -> R (f x) (g x)) -> Forall2 R (map f l) (map g l).

Lemma Forall2_flat_map (A B C D: Type) (R: C -> D -> Prop) (f: A -> list C) (g: B -> list D) (xs: list A) (ys: list B) :
  Forall2 (fun x y => Forall2 R (f x) (g y)) xs ys ->
  Forall2 R (flat_map f xs) (flat_map g ys).

Lemma Forall2_forall A (d: A) (R: A -> A -> Prop) (xs ys: list A) :
  Forall2 R xs ys ->
  forall i, i < length xs -> R (nth i xs d) (nth i ys d).

Inductive Exists2 {A B} (R: A -> B -> Prop) : list A -> list B -> Prop :=
 | Exists2_cons_hd : forall x xs y ys, R x y -> Exists2 R (x::xs) (y::ys)
 | Exists2_cons_tl : forall x xs y ys, Exists2 R xs ys -> Exists2 R (x::xs) (y::ys).
Hint Constructors Exists2.

Lemma Exists2_exists A (d: A) (R: A -> A -> Prop) (xs ys: list A) :
  Exists2 R xs ys ->
  exists i, i < length xs /\ R (nth i xs d) (nth i ys d).

Lemma app_eq_compat_l {A: Type} (xs ys zs: list A) : ys = zs -> xs ++ ys = xs ++ zs.

Lemma In_prefix_suffix (A : Type) (a : A) l :
  In a l -> exists l1 l2, l = l1 ++ a :: l2.

Lemma forall_exists_list (A B : Type) (P : A -> Prop) (Q : A -> B -> Prop) (l : list A) :
  (forall a, In a l -> P a -> exists b, Q a b) ->
  (Forall P l -> exists l', Forall2 Q l l').

Lemma forall_andl (A: Type) (P: A -> Prop) (l: list A):
  Forall P l <-> andl (map P l).

Fixpoint revflatten {A: Type} (xss: list (list A)) : list A :=
  match xss with
  | []       => []
  | xs::xss' => revflatten xss' ++ xs
  end.

Lemma Permutation_flat_map_ext A B  : forall l (f g : A -> list B),
  (forall x, In x l -> Permutation (f x) (g x)) -> Permutation (flat_map f l) (flat_map g l).

Lemma Permutation_revflatten A B (f : A -> list B) l : Permutation(revflatten (map f l)) (flat_map f l).

Lemma In_seq n start len : In n (seq start len) <-> start <= n < start+len.

Lemma seq_S start len : seq start (S len) = seq start len ++ [start + len].

Lemma plus_eq_compat_l x y1 y2 : y1 = y2 -> x + y1 = x + y2.

Lemma plus_eq_compat_r x1 x2 y : x1 = x2 -> x1 + y = x2 + y.

Section count_occ.

Lemma count_occ_remove_O A eq_dec (a: A) l :
  count_occ eq_dec (remove eq_dec a l) a = 0.

Lemma count_occ_remove_neq A eq_dec (a a': A) l :
  a<>a' -> count_occ eq_dec (remove eq_dec a' l) a = count_occ eq_dec l a.

Lemma suml_map_count_occ_remove A eq_dec (a: A) l1 l2 :
  ~In a l2 ->
  suml (map (count_occ eq_dec (remove eq_dec a l1)) l2) =
  suml (map (count_occ eq_dec l1) l2).

Lemma length_remove_count_occ A eq_dec (a: A) l:
  length l = length (remove eq_dec a l) + count_occ eq_dec l a.

Lemma in_remove_neq A eq_dec (a a': A) l :
  In a' (remove eq_dec a l) -> In a' l.

Lemma length_count_occ a b l :
  (forall n, In n l -> a <= n < a + b) ->
  length l = suml (map (count_occ eq_nat_dec l) (seq a b)).

Lemma count_occ_cons A eq_dec (a a': A) l :
  count_occ eq_dec (a::l) a' =
  if eq_dec a a' then S (count_occ eq_dec l a') else count_occ eq_dec l a'.

Lemma count_occ_app A eq_dec (a :A) l l' :
  count_occ eq_dec (l ++ l') a = count_occ eq_dec l a + count_occ eq_dec l' a.

Lemma count_occ_flat_map A B eq_B_dec (f: A -> list B) b l :
  count_occ eq_B_dec (flat_map f l) b =
  suml (map (fun a => count_occ eq_B_dec (f a) b) l).

End count_occ.

Lemma tl_incl (A:Type): forall (a:A) l l', incl (a::l') l -> incl l' l.

Section NoDup.

Lemma NoDup_app (A: Type) (l1 l2: list A):
  (forall x, In x l1 -> ~ In x l2) ->
  NoDup l1 ->
  NoDup l2 ->
  NoDup (l1 ++ l2).

Lemma NoDup_split (A: Type) (l1 l2: list A):
  NoDup (l1 ++ l2) ->
  NoDup l1.

Lemma NoDup_split_right : forall (A : Type) (l1 l2 : list A), NoDup (l1 ++ l2) -> NoDup l2.

Theorem NoDup_cons_iff {A:Type} (a: A) (l: list A):
  NoDup (a::l) <-> ~ In a l /\ NoDup l.

Lemma NoDup_app_in_l A l l' :
  NoDup (l ++ l') -> forall x : A, (In x l) -> ~ (In x l').

Lemma NoDup_Permutation_NoDup A l l' : @NoDup A l -> Permutation.Permutation l l' -> NoDup l'.

Lemma NoDup_incl_le_length (A: Type)
  (l1 l2: list A):
  NoDup l1 -> incl l1 l2 -> length l1 <= length l2.

Lemma NoDup_flat_map A B (f : A -> list B) l :
  (forall x, In x l -> NoDup (f x)) ->
  NoDup l ->
  (forall x y, In x l -> In y l -> x <> y -> (forall z, In z (f x) <-> ~ In z (f y))) ->
  NoDup (flat_map f l).

End NoDup.

Definition uniquify A (d : forall a b : A, { a = b} + { a <> b}) (l:list A) : list A :=
list_rect (fun _ : list A => list A) []
  (fun (a : A) (_ l' : list A) => let s := in_dec d a l' in if s then l' else a :: l') l.

Section pow.

Lemma lt_0_pow x n : 0 < x ->  0 < Nat.pow x n.

Lemma pow_le_compat x y n:
  x <= y -> Nat.pow x n <= Nat.pow y n.

End pow.

Lemma length_filter (A B : Type) (c : B -> bool) (f : A -> B) (xs : list A) :
  length (filter (fun x => c (f x)) xs) =
  length (filter c (map f xs)).

Section Sublist.

Inductive sublist (A : Type) : (list A) -> (list A) -> Prop :=
| sublist_refl : forall l, sublist l l
| sublist_skip : forall l1 h t, sublist l1 t -> sublist l1 (h :: t)
| sublist_cons : forall h t1 t2, sublist t1 t2 -> sublist (h :: t1) (h :: t2).

Hint Constructors sublist.

Lemma sublist_nil A (l : list A) : sublist [] l.

Lemma sublist_incl A (l1 l2 : list A) : sublist l1 l2 -> incl l1 l2.

Lemma sublist_app_skip A (l1 l2 l3 : list A) : sublist l1 l3 -> sublist l1 (l2 ++ l3).

Lemma sublist_app_left A (l1 l2 l3 : list A) : sublist l1 l3 -> sublist (l2 ++ l1) (l2 ++ l3).

Lemma sublist_app_compat A (l1 l2 l3 l4 : list A) :
  sublist l1 l3 -> 
  sublist l2 l4 ->
  sublist (l1 ++ l2) (l3 ++ l4).

Lemma sublist_flatmap_in_ext A B (f : A -> list B) g l: 
  (forall x : A , In x l -> sublist (f x) (g x)) ->
  sublist (flat_map f l) (flat_map g l).

Lemma NoDup_sublist A (l1 l2 : list A) : sublist l1 l2 -> NoDup l2 -> NoDup l1.

End Sublist.

Section Compat.

Lemma NoDup_map_inv A B (f:A->B) l : NoDup (map f l) -> NoDup l.

End Compat.

Lemma In_In_list_decompose {A} (x y : A) l : In x l -> In y l ->
  x = y \/
  exists l1 l2 l3, (l = l1 ++ x :: l2 ++ y :: l3) \/ (l = l1 ++ y :: l2 ++ x :: l3).

Section Lexicographic_Product.

Variables A B : Type.

Variable ltA : A -> A -> Prop.

Variable ltB : B -> B -> Prop.

Hypothesis wf_ltA : well_founded ltA.

Hypothesis wf_ltB : well_founded ltB.

Inductive lexprod : A*B -> A*B -> Prop :=
| lex_l : forall a a' b b', ltA a a' -> lexprod (a, b) (a', b')
| lex_r : forall a    b b', ltB b b' -> lexprod (a, b) (a,  b').

Lemma acc_lex a b : Acc ltA a -> Acc ltB b -> Acc lexprod (a, b).

Lemma lexprod_trans :
  (forall a1 a2 a3, ltA a1 a2 -> ltA a2 a3 -> ltA a1 a3) ->
  (forall b1 b2 b3, ltB b1 b2 -> ltB b2 b3 -> ltB b1 b3) ->
  forall x1 x2 x3, lexprod x1 x2 -> lexprod x2 x3 -> lexprod x1 x3.

Lemma wf_lexprod : well_founded lexprod.

Definition lex_prod_dec: 
  (forall a1 a2 : A, {a1 = a2} + {a1 <> a2}) ->
  (forall a1 a2, {ltA a1 a2} + {~ltA a1 a2}) ->
  (forall b1 b2, {ltB b1 b2} + {~ltB b1 b2}) ->
  (forall x y, {lexprod x y} + {~ lexprod x y}).

End Lexicographic_Product.

Section Last.

Lemma non_empty_last (A:Type) d d' (l:list A):
  l <> [] -> (last l d) = (last l d').

Lemma cons_cons_last (A:Type) (a b:A) l x:
  last (a::b::l) x = last (b::l) x.

Lemma cons_last (A:Type) (a:A) l x:
  last (a::l) x = last l a.

Lemma last_in (A:Type) (l:list A) x:
  (last l x = x) \/ (In (last l x) l).

End Last.

Lemma beq_eq_dec {A : Type} {beq : A -> A -> bool} (Hbeq : forall x y, beq x y = true <-> x = y) : forall (x y : A), {x = y} + {~ x = y}.

Section Firstn_skipn.
Lemma firstn_map {A B : Type} (f : A -> B) l n : 
  firstn n (map f l) = map f (firstn n l).

Lemma skipn_map {A B : Type} (f : A -> B) l n : 
  skipn n (map f l) = map f (skipn n l).

Lemma skipn_app_length {A : Type} (l1 l2 : list A) : skipn (length l1) (l1 ++ l2) = l2.

Lemma firstn_app_length {A : Type} (l1 l2 : list A) : firstn (length l1) (l1 ++ l2) = l1.

Lemma skipn_nil : forall {A} n (x : list A),
  length x <= n -> skipn n x = nil.

Lemma firstn_seq n start len :
  firstn n (seq start len) = seq start (min n len).

Lemma skipn_seq n start len :
  skipn n (seq start len) = seq (start+n) (len-n).

Lemma skipn_firstn {A:Type} n (l:list A):
  skipn n (firstn n l) = [].

Lemma skipn_incl {A:Type} (l:list A) n:
  incl (skipn n l) l.

Lemma skipn_app2 {A : Type} (l l' : list A) n:
  length l = n → skipn n (l ++ l') = l'.

Lemma firstn_app {A} (l l' : list A) : 
  firstn (length l) (l ++ l') = l.

Lemma firstn_app2 : forall (A : Type) (l l' : list A) n, 
 length l = n -> firstn n (l ++ l') = l .
End Firstn_skipn.

Section Ints.
Definition ints (n m:nat):list nat := seq n (m-n). 
Lemma ints_bounded : ∀ (x n m:nat),
  n ≤ m → x ∈ (ints n m) → n ≤ x < m.

Lemma ints_bounds : ∀ (x n m:nat),
  n ≤ x < m → x ∈ (ints n m).

Lemma ints_bounds_iff: ∀ x n m,
  n ≤ m → (n ≤ x < m ↔ x ∈ (ints n m)).

Lemma ints_length : ∀ n m,
  n ≤ m → length (ints n m) = m-n.
End Ints.

Section Forall.
Lemma Forall_cons_iff {A:Type} (x:A) (xs:list A) (P:A→Prop):
  Forall P (x::xs) ↔ P x ∧ Forall P xs.
Lemma Forall_map_iff {A B:Type} (f: A → B) l (P: B → Prop):
  (∀ x, x ∈ l → P (f x)) ↔ Forall P (map f l).
Lemma Forall_app_iff {A:Type} (P:A→Prop) l1 l2:
  Forall P (l1++l2) ↔ Forall P l1 ∧ Forall P l2.

Lemma Forall_unary {A:Type} (P:A→Prop) a:
  Forall P [a] ↔ P a.

Lemma Forall_flat_map {A B:Type} (P:B → Prop) (f:A → list B) l:
  Forall P (flat_map f l) ↔ Forall (λ x, Forall P (f x)) l.
End Forall.

Section Concat.
Lemma concat_unary_is_map {A B:Type}: ∀ l (f:A→B),
  concat (map (λ x, [f x]) l) = map f l.
Lemma in_concat_const_is_in {A B:Type} (a:A) lfix l:
  a ∈ concat (map (λ _ : B, lfix) l) ↔ l ≠ [] ∧ a ∈ lfix.
End Concat.

Section Incl.
Lemma incl_nil {A:Type} (l:list A): incl [] l.

Lemma incl_map_flat_map {A B:Type} (xs:list A) (f:A → B) g:
  (∀ x : A, x ∈ xs → f x ∈ g x) →
  incl (map f xs) (flat_map g xs).

Lemma incl_flat_map_incl {A B C:Type} (xs:list A) (r:A→list B) (rh:B→list C) lh:
  (∀ x : A, x ∈ xs → incl (flat_map rh (r x)) (lh x)) →
  incl (flat_map rh (concat (map r xs))) (flat_map lh xs).
End Incl.

Section Append.
Lemma app_length_eq {A:Type}:
  ∀ (l1 l2 l1' l2': list A),
  length l1 = length l1' → (l1++l2) = (l1'++l2') →
  l1 = l1' ∧ l2 = l2'.
End Append.

Section Forall2.
Lemma Forall2_le_refl l: Forall2 le l l.

Lemma Forall2_app_inv {A B:Type} (P:A→B→Prop) la1 la2 lb1 lb2:
  length la1 = length lb1 → Forall2 P (la1++la2) (lb1++lb2) →
  Forall2 P la1 lb1 ∧ Forall2 P la2 lb2.

Lemma Forall2_firstn {A B:Type} (P:A→B→Prop) la lb n:
  Forall2 P la lb → Forall2 P (firstn n la) (firstn n lb).

Lemma Forall2_skipn {A B:Type} (P:A→B→Prop) la lb n:
  Forall2 P la lb → Forall2 P (skipn n la) (skipn n lb).

Lemma Forall2_firstn_skipn_iff {A B:Type} (P:A→B→Prop) la lb n:
  Forall2 P la lb ↔ Forall2 P (firstn n la) (firstn n lb) ∧ Forall2 P (skipn n la) (skipn n lb).

Lemma Forall2_tail {A B:Type} (P:A→B→Prop) la lb:
  Forall2 P la lb → Forall2 P (tl la) (tl lb).
End Forall2. *)
(* Cecoa.Syntax:
Require Import Bool Arith Max List.
Import List.ListNotations.
Require Import Omega.
Require Import Cecoa.Lib.

Set Implicit Arguments.
Unset Strict Implicit.

Section Syntax.

Variables variable function constructor : Type.
Variable max_arity : nat.

Inductive value : Type :=
| c_capply : constructor -> list value -> value.

Inductive term : Type :=
| var : variable -> term
| capply : constructor -> list term -> term
| fapply : function -> list term -> term.

Inductive pattern : Type :=
| p_var : variable -> pattern
| p_capply : constructor -> list pattern -> pattern.

Inductive rule : Type :=
| rule_intro : function -> list pattern -> term -> rule.

Lemma value_ind2_gen :
  forall (P : value -> Type)(Q : list value -> Type),
  Q nil ->
  (forall v l, P v -> Q l -> Q (v :: l)) ->
  (forall c l, Q l -> P (c_capply c l)) ->
  forall v, P v.

Lemma term_ind2_gen :
  forall (P : term -> Prop)(Q : list term -> Prop),
  Q nil ->
  (forall t l, P t -> Q l -> Q (t :: l)) ->
  (forall x, P (var x)) ->
  (forall c l, Q l -> P (capply c l)) ->
  (forall f l, Q l -> P (fapply f l)) ->
  forall t, P t.

Lemma term_ind2 :
  forall (P : term -> Prop),
  (forall x, P (var x)) ->
  (forall c l, (forall t, In t l -> P t) -> P (capply c l)) ->
  (forall f l, (forall t, In t l -> P t) -> P (fapply f l)) ->
  forall t, P t.

Lemma pattern_ind2_gen :
  forall (P : pattern -> Prop)(Q : list pattern -> Prop),
  Q nil ->
  (forall p l, P p -> Q l -> Q (p :: l)) ->
  (forall x, P (p_var x)) ->
  (forall c l, Q l -> P (p_capply c l)) ->
  forall p, P p.

Lemma pattern_ind2 :
  forall (P : pattern -> Prop),
  (forall x, P (p_var x)) ->
  (forall c l, (forall p, In p l -> P p) -> P (p_capply c l)) ->
  forall p, P p.

Variable variable_eq_dec : forall (x1 x2 : variable), {x1=x2}+{x1<>x2}.

Definition variable_beq (x1 x2 : variable) : bool :=
  if variable_eq_dec x1 x2 then true else false.

Lemma variable_beq_eq : forall x1 x2, variable_beq x1 x2 = true <-> x1 = x2.

Variable function_eq_dec : forall (x1 x2 : function), {x1=x2}+{x1<>x2}.

Definition function_beq (x1 x2 : function) : bool :=
  if function_eq_dec x1 x2 then true else false.

Lemma function_beq_eq : forall x1 x2, function_beq x1 x2 = true <-> x1 = x2.

Variable constructor_eq_dec : forall (x1 x2 : constructor), {x1=x2}+{x1<>x2}.

Definition constructor_beq (x1 x2 : constructor) : bool :=
  if constructor_eq_dec x1 x2 then true else false.

Lemma constructor_beq_eq : forall x1 x2, constructor_beq x1 x2 = true <-> x1 = x2.

Fixpoint value_beq (v1 v2 : value) : bool :=
  match v1, v2 with
  | c_capply c lv, c_capply c' lv' => constructor_beq c c' && list_beq _ value_beq lv lv'
  end.

Lemma value_ind2 :
  forall (P : value -> Prop),
  (forall c l, (forall v, In v l -> P v) -> P (c_capply c l)) ->
  forall v, P v.

Lemma value_beq_eq v1 v2 : value_beq v1 v2 = true <-> v1 = v2.

Fixpoint term_beq (t1 t2 : term) : bool :=
  match t1, t2 with
  | var x, var x' => variable_beq x x'
  | capply c lt, capply c' lt' => constructor_beq c c' && list_beq _ term_beq lt lt'
  | fapply f lt, fapply f' lt' => function_beq f f' && list_beq _ term_beq lt lt'
  | _, _ => false
  end.

Lemma term_beq_eq t1 t2 : term_beq t1 t2 = true <-> t1 = t2.

Fixpoint pattern_from_value (v : value) : pattern  :=
  match v with
    | c_capply c lv => p_capply c (map pattern_from_value lv)
  end.

Fixpoint term_from_value (v : value) : term :=
  match v with
  | c_capply c lc => capply c (map term_from_value lc)
  end.

Coercion term_from_value : value >-> term.

Lemma term_from_value_not_var : forall v x, ~ term_from_value v = var x.

Lemma term_from_value_not_fapply : forall v f lt, ~ term_from_value v = fapply f lt.

Lemma term_from_value_injective (v v': value) :
  term_from_value v = term_from_value v' -> v = v'.

Fixpoint term_from_pattern (p : pattern) : term :=
  match p with
  | p_var v => var v
  | p_capply c lp => capply c (map term_from_pattern lp)
  end.

Coercion term_from_pattern : pattern >-> term.

Lemma term_from_pattern_not_fapply : forall v f lt, ~ term_from_pattern v = fapply f lt.

Fixpoint term_value (t: term) : Prop :=
  match t with
    | capply _ lt => andl (map term_value lt)
    | _ => False
  end.

Lemma term_value_eqv (t: term) :
  term_value t <-> exists (v: value), t = term_from_value v.

Fixpoint vars_of_term (t : term) : list variable :=
  match t with
  | var x => [x]
  | capply _ lt => flat_map vars_of_term lt
  | fapply _ lt => flat_map vars_of_term lt
  end.

Fixpoint vars_of_pattern (p : pattern) : list variable :=
  match p with
  | p_var x => [x]
  | p_capply _ lp => flat_map vars_of_pattern lp
  end.

Lemma vars_of_pattern_term p : vars_of_pattern p = vars_of_term (term_from_pattern p).

Fixpoint functions_of_term (t:term) : list function :=
  match t with
    | var _       => []
    | capply _ lt => flat_map functions_of_term lt
    | fapply f lt => f :: flat_map functions_of_term lt
  end.

Fixpoint fapplies_in_term (t: term) : list term :=
  match t with
  | var _       => []
  | capply _ lt =>      flat_map fapplies_in_term lt
  | fapply _ lt => t :: flat_map fapplies_in_term lt
  end.

Lemma fapplies_in_term_are_fapplies t1 t2 :
  In t1 (fapplies_in_term t2) ->
  exists f lt, t1 = fapply f lt.

Lemma fapplies_in_value_nil (v: value) :
  fapplies_in_term (@term_from_value v) = [].

Fixpoint max_arity_pattern (p : pattern) : nat :=
  match p with
  | p_var _ => 0
  | p_capply _ lp => max (length lp) (maxl (map max_arity_pattern lp))
  end.

Fixpoint max_arity_term (t : term) : nat :=
  match t with
    | var _ => 0
    | capply _ lt => max (length lt) (maxl (map max_arity_term lt))
    | fapply _ lt => max (length lt) (maxl (map max_arity_term lt))
  end.

Definition max_arity_rule (r : rule) : nat :=
  match r with
  | rule_intro _ lp t => max (max_arity_term t) (max (length lp) (maxl (map max_arity_pattern lp)))
  end.

Definition max_arity_prog (prog : list rule) : nat :=
  maxl (map max_arity_rule prog).

Definition rule_vars_defined (r : rule) : Prop :=
  match r with
  | rule_intro _ lp t => incl (vars_of_term t) (flat_map vars_of_pattern lp)
  end.

Definition wf_prog (prog : list rule) : Prop :=
  andl (map rule_vars_defined prog) /\ max_arity_prog prog <= max_arity.

Fixpoint subst (s : variable -> value)(t : term) : term :=
  match t with
  | var x => s x
  | capply c lt => capply c (map (subst s) lt)
  | fapply f lt => fapply f (map (subst s) lt)
  end.

Fixpoint psubst (s : variable -> value)(p : pattern) : value :=
  match p with
  | p_var x => s x
  | p_capply c lp => c_capply c (map (psubst s) lp)
  end.

Lemma subst_not_var : forall s t x, ~ subst s t = var x.

Lemma subst_psubst s p : subst s (term_from_pattern p) = term_from_value (psubst s p).

Fixpoint value_size (v : value) : nat :=
  match v with
  | c_capply _ lv => 1 + suml (map value_size lv)
  end.

Fixpoint term_size (t : term) :=
  match t with
  | var _ => 1
  | capply _ lt => 1 + suml (map term_size lt)
  | fapply _ lt => 1 + suml (map term_size lt)
  end.

Lemma gt_term_size_O t : term_size t > 0.

Lemma in_capply_term_size_lt c (t : term) lt :
  In t lt ->
  term_size t < term_size (capply c lt).

Lemma in_fapply_term_size_lt f (t : term) lt :
  In t lt ->
  term_size t < term_size (fapply f lt).

Definition rhs_of_rule (r : rule) : term :=
  match r with rule_intro _ _ t => t end.

Definition lhs_of_rule (r : rule) : term :=
  match r with rule_intro f lp _ => fapply f (map term_from_pattern lp) end.

Definition max_rhs (prog : list rule) : nat :=
  maxl (map term_size (map rhs_of_rule prog)).

Lemma compatible_sizes: forall v, term_size (term_from_value v) = value_size v.

Definition max_size_image_subst (t : term) (s : variable -> value) : nat :=
  maxl (map value_size (map s (vars_of_term t))).

Lemma incl_le_max_size_image_subst :
  forall s t u,
  incl (vars_of_term t) (vars_of_term u) -> max_size_image_subst t s <= max_size_image_subst u s.

Lemma step_one: forall s t, term_size (subst s t) <= term_size t * (1 + max_size_image_subst t s).

Lemma size_subst_var_le_size_value:
  forall p s (x:variable) v, v = psubst s p -> In x (vars_of_pattern p) -> value_size (s x) <= value_size v.

Lemma max_size_image_subst_bounded :
  forall t s, max_size_image_subst t s <= term_size (subst s t).

Definition activation_bound (prog : list rule) : nat -> nat :=
  fun x => max_rhs prog * (1 + x).

Lemma activation_bound_monotone (prog : list rule) :
  forall x y, x <= y -> activation_bound prog x <= activation_bound prog y.

Definition nb_rhs_functions (r: rule) :=
  match r with
    | rule_intro _ _ t => length (functions_of_term t)
  end.

Definition max_nb_rhs_functions (prog : list rule) : nat :=
  maxl (map nb_rhs_functions prog).

Lemma no_func_in_pattern p:
  functions_of_term (term_from_pattern p) = [].

Lemma no_funcs_in_patterns l:
  flat_map functions_of_term (map term_from_pattern l) = [].

End Syntax.

Arguments var [variable function constructor].

Arguments p_var [variable constructor]. *)

Set Implicit Arguments.
Unset Strict Implicit.

Section CBV.

Variables variable function constructor : Type.
Variable max_arity : nat.

Notation value := (Syntax.value constructor).
Notation term := (Syntax.term variable function constructor).
Notation pattern := (Syntax.pattern variable constructor).
Notation rule := (Syntax.rule variable function constructor).

Inductive cbv : Type :=
| cbv_constr : list cbv -> term -> value -> cbv
| cbv_split : list cbv -> cbv -> term -> value -> cbv
| cbv_function : nat -> (variable -> value) -> cbv -> term -> value -> cbv.

Lemma cbv_ind2_gen :
  forall (P : cbv -> Set)(Q : list cbv -> Set),
  Q nil ->
  (forall p lp, P p -> Q lp -> Q (p :: lp)) ->
  (forall lp t v, Q lp -> P (cbv_constr lp t v)) ->
  (forall lp p t v, Q lp -> P p -> P (cbv_split lp p t v)) ->
  (forall n s p t v, P p -> P (cbv_function n s p t v)) ->
  forall p, P p.
Proof.
fix H1 8; intros P Q H2 H3 H4 H5 H6 [ lp t v | lp p t v | n s p t v ].

- apply H4; revert lp; fix H7 1; intros [ | p lp].

  + exact H2.

  + apply H3.

    * { apply H1 with (Q:=Q).

      - exact H2.

      - exact H3.

      - exact H4.

      - exact H5.

      - exact H6. }

    * apply H7.

- apply H5; revert lp; fix H7 1; intros [ | p' lp].

  + exact H2.

  + apply  H3.

    * { apply H1 with (Q:=Q).

      - exact H2.

      - exact H3.

      - exact H4.

      - exact H5.

      - exact H6. }

    * apply H7.

  + apply H1 with (Q:=Q).

    * exact H2.

    * exact H3.

    * exact H4.

    * exact H5.

    * exact H6.

  + apply H1 with (Q:=Q).

    * exact H2.

    * exact H3.

    * exact H4.

    * exact H5.

    * exact H6.

- apply H6.
  apply H1 with (Q:=Q).

  + exact H2.

  + exact H3.

  + exact H4.

  + exact H5.

  + exact H6.

Qed.

Lemma cbv_ind2 :
  forall (P : cbv -> Prop),
  (forall lp t v, (forall p, In p lp -> P p) -> P (cbv_constr lp t v)) ->
  (forall lp p t v, (forall p, In p lp -> P p) -> P p -> P (cbv_split lp p t v)) ->
  (forall n s p t v, P p -> P (cbv_function n s p t v)) ->
  forall p, P p.
Proof.
intros P H1 H2 H3 p.
apply cbv_ind2_gen with (Q := fun lp => forall p, In p lp -> P p); simpl; try tauto.
intuition; subst; trivial.
Qed.

Fixpoint InCBV p proof_tree : Prop :=
  p = proof_tree \/
  match proof_tree with
      | cbv_constr lp _ _ => orl (map (InCBV p) lp)
      | cbv_split lp p' _ _ => InCBV p p' \/ orl (map (InCBV p) lp)
      | cbv_function _ _ p' _ _ => InCBV p p'
  end.

Lemma InCBV_refl p : InCBV p p.
Proof.
induction p as [lp t v IH_lp | lp p t v IH_lp IH_p | i s p t v IH_p] using cbv_ind2;
simpl; tauto. 
Qed.

Lemma InCBV_trans p p' p'': InCBV p p' -> InCBV p' p'' -> InCBV p p''.
Proof.
revert p p'.
induction p'' as [lp t v IH_lp | lp p1 t v IH_lp IH_p' | i s p1 t v IH_p'] using cbv_ind2;
intros p p' H1 [H2 | H2]; simpl; subst; trivial.

- right.
  rewrite orl_map in *.
  destruct H2 as (p1 & H2 & H3).
  exists p1.
  split; trivial.
  apply IH_lp with p'; trivial.

- destruct H2 as [H2 | H2].

  + right.
    left.
    apply IH_p' with p'; trivial.

  + right.
    right.
    rewrite orl_map in *.
    destruct H2 as (p2 & H2 & H3).
    exists p2.
    split; trivial.
    apply IH_lp with p'; trivial.

- right.
  apply IH_p' with p'; trivial.
Qed.

Lemma cbv_reverse_induction :
  forall (P : cbv -> Prop) proof_tree,
  P proof_tree ->
  (forall lp t v, InCBV (cbv_constr lp t v) proof_tree -> P (cbv_constr lp t v) -> forall p, In p lp -> P p) ->
  (forall lp p t v, InCBV (cbv_split lp p t v) proof_tree -> P (cbv_split lp p t v) -> forall p', (p' = p \/ In p' lp) -> P p') ->
  (forall i s p t v, InCBV (cbv_function i s p t v) proof_tree -> P (cbv_function i s p t v) -> P p) ->
  forall p, InCBV p proof_tree -> P p.
Proof.
intros P proof_tree H_proof_tree H_constr H_split H_function p H_p.
induction proof_tree as [lp t v IH_lp | lp p' t v IH_lp IH_p' | i s p' t v IH_p'] using cbv_ind2;
simpl in H_p.

- destruct H_p as [H_p | H_p].

  + congruence.

  + apply orl_map in H_p.
    destruct H_p as [p' [H1 H2] ].
    apply IH_lp with p'; trivial.

    * { eapply H_constr.

      - apply InCBV_refl. 

      - exact H_proof_tree.

      - exact H1. }

    * intros lp' t' v' H3 H4 p'' H5.
      apply H_constr with lp' t' v'; trivial.
      simpl.
      right.
      apply orl_map.
      exists p'.
      tauto.

    * intros lp' p'' t' v' H3 H4 p''' H5.
      apply H_split with lp' p'' t' v'; trivial.
      simpl.
      right.
      apply orl_map.
      exists p'.
      tauto.

    * intros i s p'' t' v' H3 H4.
      apply H_function with i s t' v'; trivial.
      simpl.
      right.
      apply orl_map.
      exists p'.
      tauto.

- destruct H_p as [H_p | [H_p | H_p] ].

  + congruence.

  + apply IH_p'.

    * { eapply H_split.

      - apply InCBV_refl.

      - exact H_proof_tree.

      - left; reflexivity. }

    * intros lp' t' v' H3 H4 p'' H5.
      apply H_constr with lp' t' v'; trivial.
      simpl; tauto.

    * intros lp' p'' t' v' H3 H4 p''' H5.
      apply H_split with lp' p'' t' v'; trivial.
      simpl; tauto.

    * intros i s p'' t' v' H3 H4.
      apply H_function with i s t' v'; trivial.
      simpl; tauto.

    * exact H_p.

  + apply orl_map in H_p.
    destruct H_p as [p'' [H1 H2] ].
    apply IH_lp with p''; trivial.
    eapply H_split.

    * apply InCBV_refl.

    * exact H_proof_tree.

    *  right; exact H1.

    * intros lp' t' v' H3 H4 p''' H5.
      apply H_constr with lp' t' v'; trivial.
      simpl.
      right; right.
      apply orl_map.
      exists p''.
      tauto.

    * intros lp' p''' t' v' H3 H4 p'''' H5.
      apply H_split with lp' p''' t' v'; trivial.
      simpl.
      right; right.
      apply orl_map.
      exists p''.
      tauto.

    * intros i s p''' t' v' H3 H4.
      apply H_function with i s t' v'; trivial.
      simpl.
      right; right.
      apply orl_map.
      exists p''.
      tauto.

- destruct H_p as [H_p | H_p].

  + congruence.

  + apply IH_p'.

    * { eapply H_function.

      - apply InCBV_refl.

      - exact H_proof_tree. }

    * intros lp' t' v' H3 H4 p'' H5.
      apply H_constr with lp' t' v'; trivial.
      simpl; tauto.

    * intros lp' p'' t' v' H3 H4 p''' H5.
      apply H_split with lp' p'' t' v'; trivial.
      simpl; tauto.

    * intros i' s' p'' t' v' H3 H4.
      apply H_function with i' s' t' v'; trivial.
      simpl; tauto.

    * exact H_p.
Qed.

Variable subst_default : variable -> value.

Definition rule_subst_of_cbv_function (proof_tree : cbv) : nat * (variable -> value) :=
  match proof_tree with
  | cbv_function i s _ _ _ => (i, s)
  | _ => (0, subst_default) 
  end.

Definition proj_left (proof_tree : cbv) : term :=
  match proof_tree with
    | cbv_constr _ t _ => t
    | cbv_split _ _ t _ => t
    | cbv_function _ _ _ t _ => t
  end.

Definition proj_right (proof_tree : cbv) : value :=
  match proof_tree with
    | cbv_constr _ _ v => v
    | cbv_split _ _ _ v => v
    | cbv_function _ _ _ _ v => v
  end.

Variable prog : list rule.

Variable rule_default : rule.

Fixpoint wf (proof_tree : cbv) : Prop :=
  match proof_tree with
    | cbv_constr l (capply c lt) (c_capply c' lv) =>
        c = c' /\
        lt = map proj_left l /\ lv = map proj_right l /\ 
        andl (map wf l)
    | cbv_split l ((cbv_function _ _ _ (fapply f lv) v) as p) (fapply f' lt) v' =>
        lt = map proj_left l /\ lv = map (@term_from_value _ _ _)(map proj_right l) /\
        andl (map wf l) /\
        f = f' /\ v = v' /\
        wf p
    | cbv_function i s p (fapply f lv) v =>
        exists lp t,
        i < length prog /\
        nth i prog rule_default = rule_intro f lp t /\
        lv = map (@term_from_value _ _ _) (map (psubst s) lp) /\
        proj_left p = subst s t /\ proj_right p = v /\
        wf p
    | _ => False
  end.

Lemma wf_cbv_function i s p t v : wf (cbv_function i s p t v) -> wf p.
Proof.
destruct t; simpl; try tauto.
intros (lp & t & H); tauto.
Qed.

Lemma wf_InCBV_wf p proof_tree: wf proof_tree -> InCBV p proof_tree -> wf p.
Proof.
intro H_proof_tree_wf.
apply cbv_reverse_induction.

- apply H_proof_tree_wf.

- intros lp t v _.
  simpl.
  destruct t; try (intro H_false; destruct H_false).
  destruct v.
  intros [ _ [ _ [ _ H_map_wf ] ] ] p' H_in_p'_lp.
  apply andl_in with (map wf lp).
  
  + apply H_map_wf.

  + apply in_map.
    apply H_in_p'_lp.

- intros lp p' t v _.
  simpl.
  destruct p'; try (intro H_false; destruct H_false).
  destruct t0; try (intro H_false; destruct H_false).
  destruct t; try (intro H_false; destruct H_false).
  generalize H0.
  clear.
  intros [ _ [ H_wf_lp [ _ [ _ H_wf_p' ] ] ] ] p'' H_p''.
  destruct H_p'' as [ H_p'' | H_p'' ].

  + 
    rewrite H_p''.
    apply H_wf_p'.

  + 
    apply andl_in with (map wf lp).
    
    * apply H_wf_lp.

    * apply in_map.
      apply H_p''.

- intros i s p' t v _.
  simpl.
  destruct t; try (intro H_false; destruct H_false).
  generalize H.
  clear.
  intros [ _ [ _ [ _ [ _ [ _ [ _ H_wf ] ] ] ] ] ].
  apply H_wf.
Qed.

Fixpoint size (proof_tree : cbv) : nat :=
  match proof_tree with
  | cbv_constr l t v => term_size t + value_size v + suml (map size l)
  | cbv_split l p t v => term_size t + value_size v + size p + suml (map size l)
  | cbv_function _ _ p t v => size p + term_size t + value_size v
  end.

Fixpoint max_active_size (proof_tree : cbv) : nat :=
  match proof_tree with
  | cbv_constr lp _ _ => maxl (map max_active_size lp)
  | cbv_split lp p _ _ => max (max_active_size p) (maxl (map max_active_size lp)) 
  | cbv_function _ _ p t v => max (term_size t + value_size v) (max_active_size p)
  end.

Fixpoint max_judgement_size (proof_tree : cbv) : nat :=
  match proof_tree with
  | cbv_constr lp t v => max (term_size t + value_size v) (maxl (map max_judgement_size lp))
  | cbv_split lp p t v => max (term_size t + value_size v) (max (max_judgement_size p) (maxl (map max_judgement_size lp)))
  | cbv_function _ _ p t v => max (term_size t + value_size v) (max_judgement_size p)
  end.

Fixpoint sub_trees (proof_tree : cbv) : list cbv :=
  proof_tree :: (
    match proof_tree with
    | cbv_constr lp _ _ => flat_map sub_trees lp
    | cbv_split lp p _ _ => flat_map sub_trees (p :: lp)
    | cbv_function _ _ p _ _ => sub_trees p
    end ).

Lemma sub_trees_neq_nil : forall p, sub_trees p <> [].
Proof.
destruct p; simpl; congruence.
Qed.

Lemma InCBV_In_sub_trees p p' : InCBV p p' <-> In p (sub_trees p').
Proof.
split.

- induction p' as [ lp t v IH_lp | lp p' t v IH_lp IH_p | i s p' t v IH_p ] using cbv_ind2; simpl.

  + intros [H1 | H1].

    * left.
      congruence. 

    * right.
      rewrite in_flat_map.
      rewrite orl_map in H1.
      firstorder.

  + intros [H1 | [ H1 | H1 ] ].

    * left.
      congruence.

    * right.
      rewrite in_app_iff.
      left.
      apply IH_p.
      exact H1.   
      
    * right.
      rewrite in_app_iff.
      right.
      rewrite in_flat_map.
      rewrite orl_map in H1.
      firstorder.

  + intros [H1 | H1].

    * left.
      congruence. 

    * right.
      apply IH_p.
      exact H1.

- induction p' as [ lp t v IH_lp | lp p' t v IH_lp IH_p | i s p' t v IH_p ] using cbv_ind2;
  simpl; (intros [H1 | H1]; [left; congruence | right] ).

  + rewrite orl_map.
    rewrite in_flat_map in H1.
    firstorder.

  + rewrite in_app_iff in H1.
    destruct H1 as [H1 | H1]; [left; tauto | right].
    rewrite orl_map.
    rewrite in_flat_map in H1.
    firstorder.

  + tauto.
Qed.

Fixpoint proj_left_max_size_list (default : cbv) (proof_trees : list cbv) : cbv :=
  match proof_trees with
    | [] => default
    | [p] => p
    | p :: ps =>
      let p' := proj_left_max_size_list default ps in
      if leb (term_size (proj_left p)) (term_size (proj_left p')) then p' else p
  end.

Lemma In_proj_left_max_size_list p lp : lp <> [] -> In (proj_left_max_size_list p lp) lp.
Proof.
induction lp as [ | p1 [ | p2 lp] IH]; simpl; try tauto.
intros _.
match goal with |- context [leb ?x ?y] => case_eq (leb x y); intro H_leb end.

- auto with *.

- tauto.
Qed.

Lemma proj_left_size_le_max_gen default proof_trees proof_tree:
  In proof_tree proof_trees ->
  term_size (proj_left proof_tree) <= term_size (proj_left (proj_left_max_size_list default proof_trees)).
Proof.
induction proof_trees as [ | p1 [ | p2 proof_trees ] IH]; simpl.

- tauto. 

- intros [H1 | H1].

  + subst.
    trivial.

  + tauto.

- intros [H1 | [H1 | H1] ].

  + subst.
    match goal with |- context [leb ?x ?y] => case_eq (leb x y); intro H_leb end.

    * rewrite leb_iff in H_leb.
      exact H_leb.

    * trivial. 

  + subst.
    match goal with |- context [leb ?x ?y] => case_eq (leb x y); intro H_leb end.

    * apply IH.
      simpl; tauto.

    * rewrite leb_iff_conv in H_leb.
      unfold lt in H_leb.
      { etransitivity.

        - apply IH.
          simpl; tauto.

        - simpl. omega.

      }

  + match goal with |- context [leb ?x ?y] => case_eq (leb x y); intro H_leb end.

    * apply IH.
      simpl; tauto.

    * { etransitivity.

        - apply IH.
          simpl; tauto.

        - rewrite leb_iff_conv in H_leb.
          simpl; omega.
      }
Qed.

Definition proj_left_max_size (proof_tree : cbv) : cbv :=
  proj_left_max_size_list (proof_tree) (sub_trees proof_tree).

Lemma proj_left_size_le_max proof_tree:
  forall p, InCBV p proof_tree ->
  term_size (proj_left p) <= term_size (proj_left (proj_left_max_size proof_tree)).
Proof.
intros p H_InCBV.
apply proj_left_size_le_max_gen.
apply InCBV_In_sub_trees.
trivial.
Qed.

Lemma InCBV_proj_left_max_size p : InCBV (proj_left_max_size p) p.
Proof.
unfold proj_left_max_size.
apply InCBV_In_sub_trees.
apply In_proj_left_max_size_list.
apply sub_trees_neq_nil.
Qed.

Fixpoint max_proj_right_size (proof_tree : cbv) : nat :=
  match proof_tree with
  | cbv_constr lp t v => max (value_size v) (maxl (map max_proj_right_size lp))
  | cbv_split lp p t v => max (value_size v) (max (max_proj_right_size p) (maxl (map max_proj_right_size lp)))
  | cbv_function _ _ p t v => max (value_size v) (max_proj_right_size p)
  end.

Lemma judgement_size_le_projs_size p :
  max_judgement_size p <= term_size (proj_left (proj_left_max_size p)) + max_proj_right_size p.
Proof.
induction p as [ lp t v IH_lp | lp p t v IH_lp IH_p | i s p t v IH_p ] using cbv_ind2; simpl.

- destruct (max_dec (term_size t + value_size v) (maxl (map max_judgement_size lp))) as [ H | H ];
  rewrite H.

  + apply plus_le_compat.

    * change t with (proj_left (cbv_constr lp t v)) at 1.
      apply proj_left_size_le_max. 
      apply InCBV_refl.

    * apply le_max_l.

  + apply maxl_le_maxl in IH_lp.
    etransitivity.

    * apply IH_lp.

    * { etransitivity.

      - apply maxl_map_plus_le.

      - apply plus_le_compat.

        + apply all_max_le.
          intros size H1.
          rewrite in_map_iff in H1.
          destruct H1 as (p & H1 & H2).
          subst size.
          apply proj_left_size_le_max.
          eapply InCBV_trans.
          apply InCBV_proj_left_max_size.
          apply InCBV_In_sub_trees.
          simpl.
          right.
          rewrite in_flat_map.
          exists p.
          split; trivial.
          apply InCBV_In_sub_trees.
          apply InCBV_refl.

        + apply le_max_r.

      } 

- destruct (max_dec (term_size t + value_size v) (max (max_judgement_size p) (maxl (map max_judgement_size lp)))) as [ H1 | H1 ];
  rewrite H1.

  + apply plus_le_compat.

    * change t with (proj_left ((cbv_split lp p t v))) at 1.
      apply proj_left_size_le_max.
      apply InCBV_refl.

    * apply le_max_l.

  + destruct (max_dec (max_judgement_size p) (maxl (map max_judgement_size lp))) as [ H2 | H2 ];
    rewrite H2.

    * { etransitivity.

        - apply IH_p.
 
        - apply plus_le_compat.

          + apply proj_left_size_le_max.
            simpl.
            right.
            left.
            apply InCBV_proj_left_max_size.

          + etransitivity; [idtac | apply le_max_r]; apply le_max_l.

      }

    * { apply maxl_le_maxl in IH_lp.
        etransitivity.

        - apply IH_lp.

        - etransitivity.

          + apply maxl_map_plus_le.

          + apply plus_le_compat.

            * apply all_max_le.
              intros size H3.
              rewrite in_map_iff in H3.
              destruct H3 as (p' & H3 & H4).
              subst size.
              apply proj_left_size_le_max.
              eapply InCBV_trans.
              apply InCBV_proj_left_max_size.
              apply InCBV_In_sub_trees.
              simpl.
              right.
              rewrite in_app_iff.
              right.
              rewrite in_flat_map.
              exists p'.
              split; trivial.
              apply InCBV_In_sub_trees.
              apply InCBV_refl.

            * etransitivity; [idtac | apply le_max_r]; apply le_max_r.

      } 

- destruct (max_dec (term_size t + value_size v) (max_judgement_size p)) as [ H | H ];
  rewrite H.

  + apply plus_le_compat.

    * change t with (proj_left ((cbv_function i s p t v))) at 1.
      apply proj_left_size_le_max.
      apply InCBV_refl.

    * apply le_max_l.

  + etransitivity.

    * apply IH_p.

    * { apply plus_le_compat.

        - apply proj_left_size_le_max.
          simpl.
          right.
          apply InCBV_proj_left_max_size.

        - apply le_max_r.
      }

Qed.

Fixpoint activations (proof_tree : cbv) : list cbv :=
  match proof_tree with
  | cbv_constr lp _ _ => flat_map activations lp
  | cbv_split lp p _ _ => activations p ++ flat_map activations lp
  | cbv_function _ _ p _ _ as p' => p' :: activations p
  end.

Lemma activation_is_function :
  forall proof_tree p,
  In p (activations proof_tree) -> exists i s p' t v, p = cbv_function i s p' t v.
Proof.
intros proof_tree p H.
induction proof_tree as [ lp t v IH | lp p' t v IH_lp IH_p' | i s p' t v IH ] using cbv_ind2.

- 
  simpl in H.
  apply in_flat_map in H.
  destruct H as [ x H ].
  destruct H as [ H_x_in H_p_in_x ].
  generalize (IH x H_x_in H_p_in_x).
  trivial.

- 
  simpl in H.
  apply in_app_or in H.
  destruct H as [ H_p' | H_lp ].

  + refine (IH_p' H_p').

  + apply in_flat_map in H_lp.
    destruct H_lp as [ x H ].
    destruct H as [ H_x_in H_p_in_x ].
    generalize (IH_lp x H_x_in H_p_in_x).
    trivial.

- 
  simpl in H.
  destruct H as [ H_base | H_ind ].

  + repeat eexists.
    symmetry.
    apply H_base.

  + generalize (IH H_ind).
    trivial.
Qed.

Lemma cbv_function_in_activations_InCBV proof_tree sub_proof_tree i s p t v:
  sub_proof_tree = cbv_function i s p t v ->
  InCBV sub_proof_tree proof_tree ->
  In sub_proof_tree (activations proof_tree).
Proof.
intros H0 H1.
subst.
induction proof_tree as [ lp t' v' IH | lp p' t' v' IH1 IH2 | i' s' p' t' v' IH ] using cbv_ind2; simpl in *.

- destruct H1 as [H1 | H1]; try discriminate H1.
  rewrite in_flat_map.
  rewrite orl_map in H1.
  firstorder.

- destruct H1 as [H1 | [H1 | H1] ]; try discriminate.

  + firstorder.

  + rewrite in_app_iff, in_flat_map.
    rewrite orl_map in H1.
    firstorder.

- firstorder.
Qed.

Lemma activations_wf : forall proof_tree p, wf proof_tree -> In p (activations proof_tree) -> wf p.
Proof.
intros proof_tree p H1; revert p; induction proof_tree as [ lp t v IH | lp p' t v IH1 IH2 | i s p' t v IH ] using cbv_ind2; intros p H2; simpl in * |-.

- destruct t as [ x | c lt | f lt ]; try tauto.
  destruct v as [ c' lv ].
  destruct H1 as (H1 & H3 & H4 & H5).
  subst c' lt lv.
  rewrite in_flat_map in H2.
  destruct H2 as (p' & H2 & H3).
  apply IH with p'; trivial.
  apply andl_in with (P := wf p') in H5; trivial.
  apply in_map_iff.
  firstorder.

- destruct p' as [ lp' t' v' | lp' p' t' v' | i s p' t' v' ]; try tauto.
  destruct t' as [ x | c lt | f lt ]; try tauto.
  destruct t as [ x | c lt' | f' lt' ]; try tauto.
  destruct H1 as (H1 & H3 & H4 & H5 & H6 & H7).
  subst lt lt' f' v'.
  rewrite in_app_iff in H2.
  destruct H2 as [ H2 | H2 ]; auto.
  rewrite in_flat_map in H2.
  destruct H2 as (p'' & H2 & H5).
  apply (IH1 _ H2); trivial.
  apply (andl_in _ _ H4); rewrite in_map_iff; exists p''; tauto.

- destruct t as [ x | c lt | f lt ]; try tauto.
  destruct H1 as (lp & t & H0 & H1 & H3 & H4 & H5 & H6).
  destruct H2 as [ H2 | H2 ]; auto.
  subst lt v p.
  destruct p' as [ lp' t' v | lp' p t' v | j s' p t' v ]; firstorder.
Qed.

Lemma le_max_active_size proof_tree p :
  In p (activations proof_tree) -> term_size (proj_left p) + value_size (proj_right p) <= max_active_size proof_tree.
Proof.
intro H.
induction proof_tree as [ lp t v IH | lp p' t v IH_lp IH_p' | i s p' t v IH ] using cbv_ind2; simpl in *.

- rewrite in_flat_map in H.
  destruct H as (p' & H1 & H2).
  etransitivity.

  + apply IH.
    eexact H1.
    exact H2.

  + apply maxl_is_max.
    rewrite in_map_iff.
    exists p'; split; trivial.

- rewrite in_app_iff in H.
  destruct H as [H | H].

  + etransitivity.

    * apply IH_p'.
      exact H.

    * apply le_max_l.

  + rewrite in_flat_map in H.
    destruct H as (p'' & H1 & H2).
    etransitivity.
 
    * apply IH_lp.
      eexact H1.
      exact H2.

    * etransitivity; [idtac | apply le_max_r].
      apply maxl_is_max.
      apply in_map_iff.
      exists p''.
      tauto.

- destruct H as [H | H].

  + subst p.
    simpl in *.
    etransitivity; [idtac | apply le_max_l].
    trivial.

  + etransitivity; [idtac | apply le_max_r].
    apply IH.
    exact H.
Qed.

Hypothesis prog_is_wf : wf_prog max_arity prog.

Lemma activation_bound_spec :
  forall proof_tree, wf proof_tree -> forall p, In p (activations proof_tree) ->
  let (i, s) := rule_subst_of_cbv_function p in
  term_size (subst s (rhs_of_rule (nth i prog rule_default))) <= activation_bound prog (term_size (proj_left p)).
Proof.
intros proof_tree H_wf_proof_tree p H_p_activation.
case_eq (rule_subst_of_cbv_function p).
intros i s H_p_fun.
unfold activation_bound.
set (rule_i := nth i prog rule_default);
set (l := lhs_of_rule rule_i);
set (r := rhs_of_rule rule_i);
set (t := proj_left p).
rewrite step_one.
apply mult_le_compat.

- apply maxl_is_max; rewrite map_map, in_map_iff; exists rule_i; split.

  + reflexivity.

  + apply nth_In.
    generalize (activations_wf H_wf_proof_tree H_p_activation); intro H_wf_p.
    generalize (activation_is_function H_p_activation); intros (i' & s' & p' & t' & v & H_p_is_function).
    subst p.
    simpl in H_p_fun.
    injection H_p_fun; clear H_p_fun; intros; subst i' s'.
    simpl in H_wf_p.
    destruct t'; try tauto.
    destruct H_wf_p as (lp & t' & H); tauto.

- apply plus_le_compat_l.
  transitivity (max_size_image_subst l s).

  + 
    apply incl_le_max_size_image_subst.
    assert (rule_vars_defined rule_i) as H_wf_rule_i.
    * { eapply andl_in.

      - destruct prog_is_wf as [ Hwfrule _ ].
        exact Hwfrule.

      - rewrite in_map_iff.
        exists rule_i.
        split; trivial.
        apply nth_In.
        generalize (activations_wf H_wf_proof_tree H_p_activation); intro H_wf_p.
        generalize (activation_is_function H_p_activation); intros (i' & s' & p' & t' & v & H_p_is_function).
        subst p.
        simpl in H_p_fun.
        injection H_p_fun; clear H_p_fun; intros; subst i' s'.
        simpl in H_wf_p.
        destruct t'; try tauto.
        destruct H_wf_p as (lp & t' & H); tauto. }

    * { destruct rule_i as [f lp t'].
        simpl in H_wf_rule_i.
        unfold l, r.
        simpl.
        replace (flat_map (@vars_of_term _ _ _) (map (@term_from_pattern _ _ _) lp)) with (flat_map (@vars_of_pattern _ _) lp).

          - exact H_wf_rule_i.

          - apply flat_map_comp; intros; apply vars_of_pattern_term. }

  + assert (subst s l = t) as H_t_matches_lhs.

    * 
      generalize (activations_wf H_wf_proof_tree H_p_activation); intro H_wf_p.
      generalize (activation_is_function H_p_activation); intros (i' & s' & p' & t' & v & H_p_is_function).
      unfold t; clear t.
      subst p.
      simpl.
      simpl in H_p_fun.
      injection H_p_fun; clear H_p_fun; intros; subst i' s'.
      simpl in H_wf_p.
      destruct t' as [ | | f lt]; try tauto.
      destruct H_wf_p as (lp & t' & H1 & H2 & H3 & H4 & H5 & H6).
      unfold l, r, rule_i in *; clear l r rule_i.
      rewrite H2.
      subst lt v.
      simpl.
      f_equal.
      do 2 rewrite map_map.
      clear.
      induction lp as [ | p lp IH]; simpl; trivial.
      rewrite IH.
      f_equal.
      apply subst_psubst.

    * replace t with (subst s l).
      apply max_size_image_subst_bounded.
Qed.

Fixpoint nb_judgements (proof_tree : cbv) : nat :=
  match proof_tree with
  | cbv_constr lp _ _ => 1 + suml (map nb_judgements lp)
  | cbv_split lp p _ _ => 1 + nb_judgements p + suml (map nb_judgements lp)
  | cbv_function _ _ p _ _ => 1 + nb_judgements p
  end.

Fixpoint nb_judgements_sub_rec (proof_tree : cbv) : nat :=
  match proof_tree with
  | cbv_constr lp _ _ => 1 + suml (map nb_judgements_sub_rec lp)
  | cbv_split lp p _ _ => 1 + nb_judgements_sub_rec p + suml (map nb_judgements_sub_rec lp)
  | cbv_function _ _ _ _ _ => 0
  end.

Definition nb_judgements_sub (proof_tree : cbv) : nat :=
  match proof_tree with
  | cbv_constr _ _ _ => 0
  | cbv_split _ _ _ _ => 0
  | cbv_function _ _ p _ _ => nb_judgements_sub_rec p
  end.

Lemma nb_judgements_bound i s p' t v :
  let p := cbv_function i s p' t v in
  nb_judgements p <= suml (map nb_judgements_sub (activations p)) + length (activations p).
Proof.
induction p' as [ lp t' v' IH1 | lp p t' v' IH1 IH2 | i' s' p t' v' IH ] using cbv_ind2; simpl in *.

- apply le_n_S.
  rewrite length_flat_map.
  induction lp as [ | p lp IH2]; trivial.
  simpl.
  repeat match goal with |- context [ S (?m + ?n) ] => replace (S (m + n)) with (m + S n) by ring end.
  etransitivity.
  
  + apply plus_le_compat.
  
    * { apply le_S_n.
        etransitivity.
        
        - apply IH1; simpl; tauto.
        
        - match goal with |- ?m + S ?n <= _ => instantiate (1 := m + n) end.
          omega. }

    * apply IH2.
      intros p' Hp'; apply IH1; simpl; tauto.

  + rewrite map_app, suml_app.
    omega.

- apply le_n_S.
  rewrite map_app, suml_app, app_length, length_flat_map.
  induction lp as [ | p' lp IH3]; simpl; try omega.
  repeat match goal with |- context [ S (?m + (?n + ?p)) ] => replace (S (m + (n + p))) with (n + S (m + p)) by ring end.
  etransitivity.

  + apply plus_le_compat.

    * { apply le_S_n.
        etransitivity.

        - apply IH1; simpl; tauto.

        - match goal with |- ?m + S ?n <= _ => instantiate (1 := m + n) end.
          omega. }

    * apply IH3.
      intros p'' Hp''; apply IH1; simpl; tauto.

  + rewrite map_app, suml_app.
    omega.

- omega.
Qed.

Lemma nb_judgements_sub_rec_bound p :
  wf p -> nb_judgements_sub_rec p <= term_size (proj_left p).
Proof.
intros H_wf_p.
induction p as [ lp t v IH | lp p t v IH _ | n s p t v _ ] using cbv_ind2; simpl in *.

- destruct t as [ | c lt | ]; try tauto.
  destruct v as [ c' lv ].
  simpl.
  apply le_n_S.
  destruct H_wf_p as (_ & H_lt & _ & H_wf); clear c'.
  subst lt.
  rewrite map_map.
  apply suml_map_le.
  intros p H_p.
  apply IH.
  trivial.
  apply andl_in with (map wf lp).
  trivial.
  rewrite in_map_iff.
  exists p.
  tauto.

- destruct p as [ | | i s p t' v']; try tauto.
  destruct t' as [ | | f lt]; try tauto.
  destruct t as [ | | f' lt']; try tauto.
  simpl in *.
  apply le_n_S.
  destruct H_wf_p as (H1 & H2 & H3 & H4 & H5 & lp' & t & H6 & H7 & H8 & H9 & H10 & H11); subst; subst.
  rewrite map_map.
  apply suml_map_le.
  intros p' H_p'.
  apply IH.
  trivial.
  apply andl_in with (map wf lp).
  trivial.
  rewrite in_map_iff.
  exists p'.
  tauto.

- apply le_0_n.
Qed.

Lemma nb_judgements_sub_bound i s p t v :
  wf (cbv_function i s p t v) ->
  nb_judgements_sub (cbv_function i s p t v) <= activation_bound prog (term_size t).
Proof.
intros H_wf_proof_tree.
assert (In (cbv_function i s p t v) (activations (cbv_function i s p t v))) as H_p_activation.

- simpl; tauto.

- generalize (activations_wf H_wf_proof_tree H_p_activation); intro H_wf_p.
  generalize (activation_bound_spec H_wf_proof_tree H_p_activation).
  simpl; intro H.
  transitivity (term_size (subst s (rhs_of_rule (nth i prog rule_default)))); [clear H | trivial].
  transitivity (term_size (proj_left p)).

  + apply nb_judgements_sub_rec_bound; trivial.
    apply (wf_cbv_function H_wf_p).

  + simpl in H_wf_p.
    destruct t; try tauto.
    destruct H_wf_p as (lp & t & _ & H_rule & _ & H_proj & _).
    rewrite H_rule, H_proj; simpl.
    trivial.
Qed.

Lemma value_size_bounded_by_nb_judgements p :
  wf p -> value_size (proj_right p) <= nb_judgements p.
Proof.
intro H.
induction p as [ lp t v IH | lp p t v _ IH | n s p t v IH ] using cbv_ind2; simpl in *.

- destruct t as [ | c lt | ]; try tauto.
  destruct v as [ c' lv ].
  destruct H as (H1 & H2 & H3 & H4).
  subst c' lt lv.
  simpl.
  apply le_n_S.
  rewrite map_map.
  apply suml_map_le.
  intros p H1; apply IH; trivial.
  apply andl_in with (map wf lp); trivial.
  apply in_map_iff.
  exists p.
  tauto.

- destruct p as [ | | n s p t' v']; try tauto.
  destruct t' as [ | | f lv]; try tauto.
  destruct t as [ | | f' lt]; try tauto.
  destruct H as (H1 & H2 & H3 & H4 & H5 & H6).
  subst lt lv f' v'.
  simpl in *.
  apply IH in H6; clear IH.
  etransitivity.

  + eexact H6.

  + omega.

- destruct t as [ | | f lv]; try tauto.
  destruct H as (lp & t & H1 & H2 & H3 & H4 & H5 & H6).
  subst lv v.
  apply le_S.
  tauto.
Qed.

Lemma term_size_bound_constr lp t v :
  wf (cbv_constr lp t v) ->
  andl (map (fun p => term_size t >= term_size (proj_left p)) lp).
Proof.
simpl; intro H.
destruct t as [ | c lt | ]; try tauto.
destruct v as [ c' lv ].
destruct H as (H1 & H2 & H3 & H4).
subst c' lt lv.
eapply andl_map.

- eexact H4.

- intros p H1 H2.
  simpl.
  unfold ge.
  apply le_S.
  apply in_le_suml.
  apply in_map_iff.
  exists (proj_left p).
  split; trivial.
  apply in_map_iff.
  exists p.
  tauto.
Qed.

Lemma term_size_bound_split lp p t v :
  wf (cbv_split lp p t v) ->
  andl (map (fun p => term_size t >= term_size (proj_left p)) lp).
Proof.
simpl; intro H.
destruct p as [ | | i s p t' v']; try tauto.
destruct t' as [ | | f lv]; try tauto.
destruct t as [ | | f' lt]; try tauto.
destruct H as (H1 & H2 & H3 & H4 & H5 & H6).
subst lt lv f' v'.
simpl in *.
destruct H6 as (lp' & t & H1 & H2 & H4 & H5 & H6 & H7).
subst v.
eapply andl_map.

- eexact H3.

- intros p' H6 H8.
  unfold ge.
  apply le_S.
  apply in_le_suml.
  apply in_map_iff.
  exists (proj_left p').
  split; trivial.
  apply in_map_iff.
  exists p'.
  tauto.
Qed.

Lemma size_bounded_nb_size_judgements p :
  size p <= nb_judgements p * max_judgement_size p.
Proof.
induction p as [ lp t v IH_lp | lp p t v IH_lp IH_p | i s p t v IH_p] using cbv_ind2; simpl.

- etransitivity.

  + apply plus_le_compat_l.
    apply suml_map_le in IH_lp.
    apply IH_lp.

  + set (a := term_size t + value_size v).
    set (f := nb_judgements).
    set (g := max_judgement_size).
    apply plus_le_compat.

    * apply le_max_l.

    * { etransitivity.

        - apply suml_map_mult_le_suml_mult_maxl.

        - apply mult_le_compat_l.
          apply le_max_r.
      }

- etransitivity.

  + rewrite <- plus_assoc.
    apply plus_le_compat_l.
    apply plus_le_compat.

    * apply IH_p.

    * apply suml_map_le in IH_lp.
      apply IH_lp.

  + set (a := term_size t + value_size v).
    set (f := nb_judgements).
    set (g := max_judgement_size).
    apply plus_le_compat.

    * apply le_max_l.

    * { etransitivity.

        - apply plus_le_compat_l.
          apply suml_map_mult_le_suml_mult_maxl.

        - ring_simplify.
          apply plus_le_compat.

          + apply mult_le_compat_l.
            etransitivity; [idtac | apply le_max_r]; apply le_max_l.

          + apply mult_le_compat_l.
            etransitivity; [idtac | apply le_max_r]; apply le_max_r.
      }

- etransitivity.

  + do 2 apply plus_le_compat_r.
    apply IH_p.

  + set (a := nb_judgements p).
    set (b := max_judgement_size p).
    rewrite <- plus_assoc.
    set (c := term_size t + value_size v).
    rewrite plus_comm.
    apply plus_le_compat.

    * apply le_max_l.

    * apply mult_le_compat_l.
      apply le_max_r.
Qed.

Lemma nb_judgements_sub_bound_gen : forall p p',
  let S := max_active_size p in
  wf p ->
  In p' (activations p) -> nb_judgements_sub p' <= activation_bound prog S.
Proof.
intros p p' S H_wf_p Hp'.
assert (wf p') as H1. {
  apply activations_wf with p.
  exact H_wf_p.
  assumption.
}
generalize Hp'; intro H2p'.
apply activation_is_function in Hp'.
apply le_max_active_size in H2p'.
destruct Hp' as (i' & s' & p'' & t' & v' & Hp').
subst p'.
etransitivity.

- apply nb_judgements_sub_bound.
  assumption.

- simpl in H1.
  destruct t' as [ | | f lv]; try omega.
  destruct H1 as (lp & t' & H1 & H2 & H3 & H4 & H5 & H6).
  subst lv v'.
  simpl in H2p'.
  apply activation_bound_monotone.
  etransitivity; [idtac | apply H2p'].
  simpl; omega.
Qed.

Lemma nb_judgements_bound_gen : forall i s p' t v,
  let p := cbv_function i s p' t v in
  let A := length (activations p) in
  let S := max_active_size p in
  wf p ->
  nb_judgements p <= A * activation_bound prog S + A.
Proof.
intros i s p' t v p A S H_wf_p.
etransitivity.
apply nb_judgements_bound.
unfold A, p.
apply plus_le_compat_r.
set (list_activ := activations (cbv_function i s p' t v)).
etransitivity.

- apply suml_le_len_times_bound.
  instantiate (1 := activation_bound prog S).
  intros x H_x.
  apply in_map_iff in H_x.
  destruct H_x as [ p'' [ H_x1 H_x2 ]].
  subst x.
  apply nb_judgements_sub_bound_gen; trivial.

- apply mult_le_compat_r.
  rewrite map_length.
  trivial.
Qed.

Lemma term_size_proj_left_bound : forall i s p' t v,
  let p := cbv_function i s p' t v in
  let S := max_active_size p in
  wf p ->
  forall p',
  InCBV p' p -> term_size (proj_left p') <= activation_bound prog S + S.
Proof.

intros i s p0 t v p S H_wf_p.
apply cbv_reverse_induction.

- 
  transitivity S.

  + unfold p, S.
    simpl.
    transitivity (term_size t + value_size v).

    * apply le_plus_l.

    * apply le_max_l.

      + apply le_plus_r.

- 
  intros lp t' v' H_p'_in_p IH p'' H_p''_in_lp.
  transitivity (term_size (proj_left (cbv_constr lp t' v'))).

  + generalize (wf_InCBV_wf H_wf_p H_p'_in_p).
    simpl.
    destruct t'; try (intro H_false; destruct H_false).
    destruct v'.
    intros [ H_c0 [ H_l_lp [ _ H_wf_lp ] ] ].
    rewrite <- H_c0 in *; clear H_c0.

    simpl.
    rewrite H_l_lp.
    apply le_S.
    apply in_le_suml.
    apply in_map.
    apply in_map.
    apply H_p''_in_lp.

    + apply IH.

- 
  intros lp p' t' v' H_in_p IH p'' H_p''_in.
  destruct H_p''_in as [ H_p''_in | H_p''_in ].

  + 
  { rewrite H_p''_in.
    transitivity S.
    transitivity (term_size (proj_left p') + value_size (proj_right p')).

    - apply le_plus_l.

    - apply le_max_active_size.
      generalize (wf_InCBV_wf H_wf_p H_in_p).
      intro H_wf_split.
      simpl in H_wf_split.
      destruct p'; try tauto.
      apply cbv_function_in_activations_InCBV with n v0 p' t0 v1; try auto.
      apply InCBV_trans with (cbv_split lp (cbv_function n v0 p' t0 v1) t' v').

      * simpl.
        tauto.

      * apply H_in_p.

    - apply le_plus_r.
  }

  + 
    transitivity (term_size (proj_left (cbv_split lp p' t' v'))).

    * generalize (wf_InCBV_wf H_wf_p H_in_p).
      simpl.
      destruct p'; try tauto.
      destruct t0; try tauto.
      destruct t' as [ | | f' lt ]; try tauto.
      intros [ H_lt_lp [ _ [ _ [ H_f [ H_v _ ] ] ] ] ].
      rewrite <- H_f in *; clear H_f.
      rewrite H_v in *; clear H_v.
      rewrite H_lt_lp in *; clear H_lt_lp.
      simpl.
      apply le_S.
      apply in_le_suml.
      apply in_map.
      apply in_map.
      assumption.

    * assumption.

- 
  intros i' s' p' t' v' H_in_p IH.
  transitivity (activation_bound prog (term_size t')).

  + change t' with (proj_left (cbv_function i' s' p' t' v')).
    replace (proj_left p') with (subst s' (rhs_of_rule (nth i' prog rule_default))).

    * generalize (@activation_bound_spec p H_wf_p (cbv_function i' s' p' t' v')).
      simpl.
      intro H.
      apply H.
      simpl in H_in_p.
      {
        destruct H_in_p as [ H_in_p | H_in_p ].

        - left.
          symmetry.
          assumption.

        - right.
          apply (@cbv_function_in_activations_InCBV p0 (cbv_function i' s' p' t' v') i' s' p' t' v'); trivial.
      }

    * generalize (wf_InCBV_wf H_wf_p H_in_p).
      simpl.
      destruct t'; try tauto.
      intros [ lp [ t' [ _ [ H_nth_rule [ _ [ H_proj_subst _ ] ] ] ] ] ].
      rewrite H_proj_subst.
      f_equal.
      rewrite H_nth_rule.
      simpl.
      trivial.

  + apply le_plus_trans.
    apply activation_bound_monotone.
    transitivity (term_size (proj_left (cbv_function i' s' p' t' v')) + value_size (proj_right (cbv_function i' s' p' t' v'))).

    * apply le_plus_trans.
      simpl.
      trivial.

    * apply le_max_active_size.
      apply cbv_function_in_activations_InCBV with i' s' p' t' v'; trivial.
Qed.

Lemma size_judgement : forall i s p' t v,
  let p := cbv_function i s p' t v in
  let A := length (activations p) in
  let S := max_active_size p in
  wf p ->
  max_judgement_size p <= activation_bound prog S + S + A * activation_bound prog S + A.
Proof.
  
  intros i s p0 t v p A S H_wf_p.
  etransitivity.
  apply judgement_size_le_projs_size.
  rewrite <- plus_assoc.
  apply plus_le_compat.

  + 
    apply term_size_proj_left_bound; trivial.
    apply InCBV_proj_left_max_size.

  + transitivity (nb_judgements p).

    * { 
        generalize H_wf_p.
        clear H_wf_p.
        intro H_wf_p.
        induction p as [ lp t' v' IH | lp p' t' v' IH_lp IH_p' | i' s' p' t' v' IH ] using cbv_ind2.

        - simpl max_proj_right_size.
          destruct (max_dec (value_size v') (maxl (map max_proj_right_size lp))) as [ H_max | H_max ]; rewrite H_max.

          + change v' with (proj_right (cbv_constr lp t' v')) at 1.
            apply value_size_bounded_by_nb_judgements.
            assumption.

          + simpl.
            apply le_S.
            transitivity (maxl (map nb_judgements lp)).

            * apply maxl_le_maxl.
              intros p' H_in_lp.
              apply IH.
              assumption.
              apply (wf_InCBV_wf H_wf_p).
              simpl.
              right.
              apply orl_map.
              exists p'.

              split.
              trivial.
              apply InCBV_refl.

            * apply maxl_le_suml.

        - simpl max_proj_right_size.
          destruct (max_dec (value_size v') (max (max_proj_right_size p') (maxl (map max_proj_right_size lp)))) as [H_max | H_max ]; rewrite H_max; clear H_max.
          
          + change v' with (proj_right (cbv_split lp p' t' v')).
            apply value_size_bounded_by_nb_judgements.
            assumption.

          + simpl.
            apply le_S.
            destruct (max_dec (max_proj_right_size p') (maxl (map max_proj_right_size lp))) as [ H_max | H_max ]; rewrite H_max; clear H_max.
            
            * apply le_plus_trans.
              apply IH_p'.
              apply (wf_InCBV_wf H_wf_p).
              simpl; right; left; apply InCBV_refl.

            * rewrite plus_comm.
              apply le_plus_trans.

              { transitivity (maxl (map nb_judgements lp)).

                + apply maxl_le_maxl.
                  intros p'' H_in_lp.
                  apply IH_lp.
                  assumption.
                  apply (wf_InCBV_wf H_wf_p).
                  simpl.
                  right; right.
                  apply orl_map.
                  exists p''.

                  split.
                  trivial.
                  apply InCBV_refl.

                + apply maxl_le_suml.
              }

        - simpl max_proj_right_size.
          destruct (max_dec (value_size v') (max_proj_right_size p')) as [H_max | H_max ]; rewrite H_max; clear H_max.
          
          + change v' with (proj_right (cbv_function i' s' p' t' v')).
            apply value_size_bounded_by_nb_judgements.
            assumption.

          + simpl.
            apply le_S.
            apply IH.
            apply (wf_InCBV_wf H_wf_p).
            simpl; right; apply InCBV_refl.
      }

    * apply nb_judgements_bound_gen; trivial.
Qed.

Theorem size_bound : forall i s p' t v,
  let p := cbv_function i s p' t v in
  let A := length (activations p) in
  let S := max_active_size p in
 wf p ->
  size p <=
  (A * activation_bound prog S + A) * (activation_bound prog S + S + A * activation_bound prog S + A).
Proof.

intros i s p0 t v p A S H_wf_p.
etransitivity.
- apply size_bounded_nb_size_judgements.
- apply mult_le_compat.

  + apply nb_judgements_bound_gen; trivial.

  + apply size_judgement; trivial.
Qed.

End CBV.
