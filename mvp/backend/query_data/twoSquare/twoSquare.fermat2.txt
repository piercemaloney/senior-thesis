From mathcomp Require Import all_ssreflect all_algebra all_field.
Require Import gauss_int.
(* gauss_int:
From mathcomp Require Import all_ssreflect all_algebra all_field.
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Import GRing.Theory Num.Theory UnityRootTheory.
Open Scope ring_scope.

Section PreliminaryLemmas.

Lemma Cnat_mul_eq1 : {in Cnat &, forall x y, (x * y == 1) = (x == 1) && (y == 1)}.

Lemma Cnat_add_eq1 : {in Cnat &, forall x y,
   (x + y == 1) = ((x == 1) && (y == 0)) || ((x == 0) && (y == 1))}.

Lemma algReM (x y : algC) : 
  'Re (x * y) = 'Re x * 'Re y - 'Im x * 'Im y.

Lemma algImM (x y : algC) : 'Im (x * y) = 'Re x * 'Im y + 'Re y * 'Im x.

Lemma algReV (x : algC) : 
  'Re (x^-1) = 'Re x / `|x| ^+ 2.

Lemma algImV (x : algC) : 
  'Im (x^-1) = - ('Im x / `|x| ^+ 2).

Lemma algRe_div (x y : algC) : 
  'Re (x/y) = ('Re x * 'Re y + 'Im x * 'Im y) / `|y| ^+ 2.

Lemma algIm_div (x y : algC) : 
  'Im (x/y) = ('Re y * 'Im x - 'Re x * 'Im y) / `|y| ^+ 2.

Definition cdivz (x y : int) : int :=
  (let q := (x %/ y) in
   if (y == 0) || (2%:R * (x %% y)%Z <= `|y|) then
    q else q + (-1) ^+ (y < 0)%R)%Z.

Infix "%c/" := cdivz (at level 40) : int_scope.

Lemma cdivz0 x : (x %c/ 0)%Z = 0.

Lemma cdiv0z y : (0 %c/ y)%Z = 0.

Lemma cdivz1 x : (x %c/ 1)%Z = x.

Lemma cdivzz x : x != 0 -> (x %c/ x)%Z = 1.

Definition cmodz (x y : int) : int := x - (x %c/ y)%Z * y.
 
Infix "%c%" := cmodz (at level 40) : int_scope.

Lemma cdivz_eq (x y :  int) : x = (x %c/ y)%Z * y + (x %c% y)%Z.

Lemma cmodz0 x : (x %c% 0)%Z = x.

Lemma cmod0z y : (0 %c% y)%Z = 0.

Lemma cmodz1 x : (x %c% 1)%Z = 0.

Lemma cmodzz x : (x %c% x)%Z = 0.

Lemma cmodz_lt (x y : int) : y != 0 -> (2%:R * `|x %c% y| <= `|y|)%Z.

End PreliminaryLemmas.

Section GaussIntegers.

Definition gaussInteger := [qualify a x | ('Re x \in Cint) && ('Im x \in Cint)].

Lemma Cint_GI (x : algC) : x \in Cint -> x \is a gaussInteger.

Lemma GI_subring : subring_closed gaussInteger.
Canonical GI_keyed := KeyedQualifier GI_key.
Canonical GI_opprPred := OpprPred GI_subring.
Canonical GI_addrPred := AddrPred GI_subring.
Canonical GI_mulrPred := MulrPred GI_subring.
Canonical GI_zmodPred := ZmodPred GI_subring.
Canonical GI_semiringPred := SemiringPred GI_subring.
Canonical GI_smulrPred := SmulrPred GI_subring.
Canonical GI_subringPred := SubringPred GI_subring.

Record GI := GIof {
  algGI : algC;
  algGIP : algGI \is a gaussInteger }.

Hint Resolve algGIP.

Canonical GI_subType := [subType for algGI].

Lemma GIRe (x : GI) : 'Re (val x) \in Cint.
Lemma GIIm (x : GI) : 'Im (val x) \in Cint.
Hint Resolve GIRe GIIm.

Canonical ReGI x := GIof (Cint_GI (GIRe x)).
Canonical ImGI x := GIof (Cint_GI (GIIm x)).

Definition eqGIMixin := [eqMixin of GI by <:].
Canonical eqGIType := EqType GI eqGIMixin.
Definition GI_choiceMixin := [choiceMixin of GI by <:].
Canonical GI_choiceType := ChoiceType GI GI_choiceMixin.
Definition GI_countMixin := [countMixin of GI by <:].
Canonical GI_countType := CountType GI GI_countMixin.
Definition GI_zmodMixin := [zmodMixin of GI by <:].
Canonical GI_zmodType := ZmodType GI GI_zmodMixin.
Definition GI_ringMixin := [ringMixin of GI by <:].
Canonical GI_ringType := RingType GI GI_ringMixin.
Definition GI_comRingMixin := [comRingMixin of GI by <:].
Canonical GI_comRingType := ComRingType GI GI_comRingMixin.

Definition invGI (x : GI) := insubd x (val x)^-1.
Definition unitGI (x : GI) :=
  (x != 0) && ((val x)^-1 \is a gaussInteger).

Fact mulGIr : {in unitGI, left_inverse 1 invGI *%R}.

Fact unitGIP (x y : GI) : y * x = 1 -> unitGI x.

Fact unitGI_out : {in [predC unitGI], invGI =1 id}.

Definition GI_comUnitRingMixin :=
  ComUnitRingMixin mulGIr unitGIP unitGI_out.
Canonical GI_unitRingType := UnitRingType GI GI_comUnitRingMixin.
Canonical GI_comUnitRingType := [comUnitRingType of GI].

Lemma conjGIE x : (x^* \is a gaussInteger) = (x \is a gaussInteger).

Fact conjGI_subproof (x : GI) : (val x)^* \is a gaussInteger.

Canonical conjGI x := GIof (conjGI_subproof x).

Fact conjGI_sub : {morph conjGI : a b / a - b}.

Canonical conjGI_additive := Additive conjGI_sub.

Fact conjGI_multiplicative : multiplicative conjGI.

Canonical conjGI_rmorphism := AddRMorphism conjGI_multiplicative.

Lemma algGI_nat n : algGI n%:R = n%:R.

Lemma conjGI_nat n : conjGI n%:R = n%:R.

Lemma conjGIK : involutive conjGI.

Definition gaussNorm (x : algC) := x * x^*.

Lemma gaussNormE x : gaussNorm x = `|x| ^+ 2.

Lemma gaussNormCnat (x : GI) : gaussNorm (val x) \in Cnat.
Hint Resolve gaussNormCnat.

Delimit Scope GI_scope with GI.

Open Scope GI_scope.

Definition normGI (x : GI) := truncC (gaussNorm (val x)).
Local Notation "'N x" := (normGI x%R) (at level 10) : GI_scope.

Lemma gaussNorm0 : gaussNorm 0 = 0.

Lemma normGI0 : 'N 0 = 0%N.

Lemma gaussNorm1 : gaussNorm 1 = 1.

Lemma normGI1 : 'N 1 = 1%N.

Lemma gaussNormM : {morph gaussNorm : x y / x * y}.

Lemma normGIM x y : 'N (x * y) = ('N x * 'N y)%N.

Lemma normGIX x n : 'N (x ^+ n) = ('N x ^ n)%N.

Lemma gaussNorm_eq0 (x : GI) : (gaussNorm (algGI x) == 0) = (x == 0).

Lemma normGI_eq0 (x : GI) : ('N x == 0%N) = (x == 0).

Lemma normGI_gt0 (x : GI) : ('N x > 0)%N = (x != 0).

Lemma normGI_le (x y : GI) : y != 0 -> ('N x <= 'N (x * y))%N.

Lemma normGI_nat n : 'N n%:R = (n ^ 2)%N.

Lemma normGIE (x : GI) : ('N(x) = truncC (`|'Re (val x)|) ^ 2 + truncC (`|'Im (val x)|) ^ 2)%N.

Lemma truncC_Cint (x : algC) :
  x \in Cint -> x = (-1) ^+ (x < 0)%R * (truncC `|x|)%:R.

Lemma normGI_eq1 (x : GI) : ('N(x) == 1)%N = (val x \in [::1;-1;'i;-'i]).

Lemma unitGIE (x : GI) : (x \in GRing.unit) =

Lemma algC_eqE (x y : algC) : (x == y) = (('Re x == 'Re y) && ('Im x == 'Im y)).

Lemma normGI_unit (x : GI) : ('N(x) == 1)%N = (x \in GRing.unit).

Fact GI_idomainAxiom (x y : GI) : x * y = 0 -> (x == 0) || (y == 0).

Canonical GI_idomainType :=
  Eval hnf in IdomainType GI GI_idomainAxiom.

Fact divGI_subproof (x y : int) : x%:~R + 'i * y%:~R \is a gaussInteger.

Definition divGI (x y : GI) : GI :=
  let zr := floorC ('Re (val x) * 'Re (val y) + 'Im (val x) * 'Im (val y)) in
  let zi := floorC ('Re (val y) * 'Im (val x) - 'Re (val x) * 'Im (val y)) in
  let n := 'N y in
  GIof (divGI_subproof (cdivz zr n) (cdivz zi n)).

Notation " x %/ y " := (divGI x y) : GI_scope.

Lemma divGI0 x : x %/ 0 = 0.

Lemma div0GI y : 0 %/ y = 0.

Lemma divGI1 x : x %/ 1 = x.

Lemma divGIxx (x : GI) : x != 0 -> x %/ x = 1.

Definition modGI (x y : GI) : GI := x - (x %/ y)%GI * y.

Notation " x %% y " := (modGI x y) : GI_scope.

Lemma modGI0 x : x %% 0 = x.

Lemma mod0GI y : 0 %% y = 0.

Lemma modGI1 x : x %% 1 = 0.

Lemma divGI_eq (x y : GI) : x = (x %/ y)%GI * y + (x %% y)%GI.

Lemma ltn_modGI(x y : GI) : ('N (x %% y)%GI < 'N y)%N = (y != 0).

Lemma ltn_modGIN0 x y : y != 0 -> ('N (x %% y)%GI < 'N y)%N.

Lemma modGIxx x : (x %% x)%GI = 0.

Lemma divGIKl (x y : GI) : x != 0 -> (y * x %/ x) = y.

Lemma divGIKr (x y : GI) : x != 0 -> (x * y %/ x) = y.

Lemma modGIKl (x y : GI) : (y * x %% x) = 0.

Lemma modGIKr (x y : GI) : (x * y %% x) = 0.

Definition dvdGI x y := (y %% x)%GI == 0.

Notation " x %| y " := (dvdGI x y) : GI_scope.

Lemma dvdGI0 x : (x %| 0)%GI.

Lemma dvdGIP (x y : GI) :
  reflect (exists q : GI, y = q * x) (x %| y)%GI.

Lemma dvd0GI x : (0 %| x) = (x == 0).

Lemma dvdGI_mull z x y : (x %| y) -> (x %| z * y).

Lemma dvdGI_mulr z x y : (x %| y) -> (x %| y * z).

Lemma dvdGIxx x : x %| x.

Lemma dvdGI_norm x y : x %| y -> ('N x %| 'N y)%N.

Lemma dvd1GI x : (1 %| x) .

Lemma dvdGI1 x : (x %| 1) = ('N x == 1%N).

Lemma divGIK (x y : GI) : x %| y -> (y %/ x)%GI * x = y.

Lemma dvdGI_add x y z:  (x %| y) -> (x %| z) -> (x %| y + z).

Lemma dvdGI_nat_dvdz_Re n x :
  n%:R %| x -> (n %| `|floorC ('Re (algGI x))|)%N.

Lemma dvdGI_nat_dvdz_Im n x :
  n%:R %| x -> (n %| `|floorC ('Im (algGI x))|)%N.

Lemma conjGI_dvd x y : x %| y -> (conjGI x) %| (conjGI y).

Fact iGI_proof : 'i \is a gaussInteger.

Definition iGI := GIof iGI_proof.

Lemma dvdGI_norm_even x :  ~~ odd ('N x) = ((1 + iGI) %| x).

Fixpoint gcdGI_rec (n : nat) (xx  yy : GI) {struct n} :=
   let rr := modGI xx yy in
   if rr == 0 then yy else
   if n is n1.+1 then gcdGI_rec n1 yy rr else rr.

Definition gcdGI x y :=
  let: (x1, y1) := if ('N x < 'N y)%N then (y, x) else (x, y) in
  if x1 == 0 then y1 else
  gcdGI_rec ('N x1) x1 y1.

Lemma gcd0GI : left_id 0 gcdGI.

Lemma gcdGI0 : right_id 0 gcdGI.

Lemma gcdGI_recE m n x y : ('N y <= m)%N -> ('N y <= n)%N
      -> ('N y < 'N x)%N -> gcdGI_rec m x y = gcdGI_rec n x y.

Lemma gcdGIE x y :
  gcdGI x y = if ('N x < 'N y)%N
    then gcdGI (y %% x) x else gcdGI (x %% y) y.

Lemma gcd1GIE y :
  gcdGI 1 y = if ('N y == 1)%N then y else 1.

Lemma gcd1GI_norm y : 'N(gcdGI 1 y) = 1%N.

Lemma gcdGI1 y : gcdGI y 1 = 1.

Lemma gcdGIxx : idempotent gcdGI.

Lemma dvdGI_mod d x y : d %| x -> (d %| y) = (d %| y %% x).

Lemma dvdGI_gcdlr x y : (gcdGI x y %| x) && (gcdGI x y %| y).

Lemma dvdGI_gcdl x y : gcdGI x y %| x.

Lemma dvdGI_gcdr x y : gcdGI x y %| y.

Lemma gcdGI_eq0 x y : (gcdGI x y == 0) = ((x == 0) && (y == 0)).

Lemma dvdGI_leq x y : y != 0 -> x %| y -> ('N x <= 'N y)%N.

Lemma leq_gcdGIl (x y : GI) : x != 0 -> ('N (gcdGI x y) <= 'N x)%N.

Lemma leq_gcdGIr (x y : GI) : y != 0 -> ('N (gcdGI x y) <= 'N y)%N.

Lemma dvdGI_trans : transitive dvdGI.

Lemma dvdGI_gcd x y z : x %| gcdGI y z = (x %| y) && (x %| z).

Lemma dvdGI_mul2r (p d x : GI) :  p != 0 ->  (d * p %| x * p) = (d %| x).

Lemma dvdGI_mul2l (p d x : GI) :  p != 0 ->  (p * d %| p * x) = (d %| x).

Definition lcmGI x y := (x * y) %/ gcdGI x y.

Lemma mulGI_lcm_gcd x y : lcmGI x y * gcdGI x y = x * y.

Lemma lcm0GI y : lcmGI 0 y = 0.

Lemma lcmGI0 x : lcmGI x 0 = 0.

Lemma lcmGI_eq0 x y : (lcmGI x y == 0) = ((x == 0) || (y == 0)).

Definition eqGI x y :=  (dvdGI x y) && (dvdGI y x).

Lemma eqGIxx : reflexive eqGI.

Lemma eqGI_sym : symmetric eqGI.

Lemma eqGI_trans : transitive eqGI.

Infix "%=" := eqGI : GI_scope.

Lemma eqGI0 (x : GI) : (x %= 0) = (x == 0).

Lemma eqGI_eq0  x y : x %= y -> (x == 0) = (y == 0).

Lemma eqGI_norm  x y : x %= y -> 'N x = 'N y.

Lemma dvdGI_eq_norm x y : 'N x = 'N y -> x %| y -> x %= y.

Lemma eqGI_nat m n : m%:R %= n%:R -> m = n.

Lemma conjGI_gcd x y : conjGI (gcdGI x y) %= gcdGI (conjGI x) (conjGI y).

Lemma conjGIM_norm x : x * conjGI x = ('N x)%:R.

Lemma eqGIP (x y : GI) :
  reflect (exists2 u, normGI u = 1%N & x = u * y)
          (x %= y).

Lemma gcdGIC x y : gcdGI x y %= gcdGI y x.

Lemma gcd1GI y : gcdGI 1 y %= 1.

Lemma eqGI_dvdr x y1 y2 : y1 %= y2 -> (x %| y1) = (x %| y2).

Lemma eqGI_dvdl y x1 x2 : x1 %= x2 -> (x1 %| y) = (x2 %| y).

Lemma eqGI_gcdr x y1 y2 : y1 %= y2 -> gcdGI x y1 %= gcdGI x y2.

Lemma eqGI_gcdl y x1 x2 : x1 %= x2 -> gcdGI x1 y %= gcdGI x2 y.

Lemma eqGI_mul2r (r p q : GI) : r != 0 -> (p * r %= q * r) = (p %= q).

Lemma eqGI_mul2l (r p q : GI): r != 0 -> (r * p %= r * q) = (p %= q).

Lemma eqGI_mul (p1 p2  q1 q2 : GI) : 
 p1 %= q1 ->  p2 %= q2 ->  p1 * p2 %= q1 * q2.

Fixpoint egcdGI_rec n (x y : GI) := 
  if y == 0 then (1, 0) else
  if n is n1.+1 then
    let: (u, v) := egcdGI_rec n1 y (modGI x y) in
     (v, u - v * (x %/ y)%GI)
  else (1, 0).

Definition egcdGI (x y : GI) :=
  if ('N y <= 'N x)%N then 
    egcdGI_rec ('N x) x y else
  let e := egcdGI_rec ('N y) y x in (e.2, e.1).

Lemma egcdGI_rec0r n x : egcdGI_rec n x 0 = (1, 0).

Lemma egcdGI0 x : egcdGI x 0 = (1, 0).

Lemma egcd0GI y : y != 0 -> egcdGI 0 y = (0, 1).

Lemma egcdGI_recP : 
  forall n x y,  y != 0 -> ('N y <= n)%N -> ('N y <= 'N x)%N ->
  forall (e := egcdGI_rec n x y), gcdGI_rec n x y = e.1 * x + e.2 * y.

Lemma egcdGIP (x y : GI) : gcdGI x y = (egcdGI x y).1 * x + (egcdGI x y).2 * y.

Lemma mulGI_gcdr x y z : x * gcdGI y z %= gcdGI (x * y) (x * z).

Lemma mulGI_gcdl x y z : gcdGI y z * x %= gcdGI (y * x) (z * x).

Lemma dvdGI_lcm d1 d2 x : lcmGI d1 d2 %| x = (d1 %| x) && (d2 %| x).

Section OrdinalGI.

Variable n : nat.

Inductive ordinalGI : predArgType := OrdinalGI x of ('N x < n)%N.

Coercion GI_of_ord i := let: OrdinalGI m _ := i in m.

Canonical ordinalGI_subType := [subType for GI_of_ord].
Definition ordinalGI_eqMixin := Eval hnf in [eqMixin of ordinalGI by <:].
Canonical ordinalGI_eqType := Eval hnf in EqType ordinalGI ordinalGI_eqMixin.
Definition ordinalGI_choiceMixin := [choiceMixin of ordinalGI by <:].
Canonical ordinalGI_choiceType :=
  Eval hnf in ChoiceType ordinalGI ordinalGI_choiceMixin.
Definition ordinalGI_countMixin := [countMixin of ordinalGI by <:].
Canonical ordinalGI_countType :=
  Eval hnf in CountType ordinalGI ordinalGI_countMixin.
Canonical ordinalGI_subCountType := [subCountType of ordinalGI].

Lemma ltn_ordGI (i : ordinalGI) : ('N i < n)%N.

Definition  ordGI_enum : seq ordinalGI :=
 pmap insub
  [seq (let: (n1, n2) := i in 
        (((nat_of_ord n1))%:R - n%:R) + 
              iGI * ((nat_of_ord n2)%:R - n%:R)) |
      i <-  (enum [finType of ('I_n.*2 * 'I_n.*2)%type])].

Lemma ordGI_enum_uniq : uniq ordGI_enum.

Fact int_norm_nat x y m : 
  x \in Cint ->  y \in Cint -> 
  `|x| ^+ 2 + `|y| ^+ 2 < m%:R -> (x + m%:R \in Cnat) && (x + m%:R < m.*2%:R).

Lemma mem_ordGI_enum x : x \in ordGI_enum.

Definition ordinalGI_finMixin :=
  Eval hnf in UniqFinMixin ordGI_enum_uniq mem_ordGI_enum.
Canonical ordinalGI_finType := Eval hnf in FinType ordinalGI ordinalGI_finMixin.
Canonical ordinalGI_subFinType := Eval hnf in [subFinType of ordinalGI].

End OrdinalGI.

Definition primeGI (x : GI) :=
  (1 < 'N x)%N && [forall y : ordinalGI ('N x), (y %| x) ==> ('N y == 1%N)]. 

Lemma nprimeGI0 : ~ primeGI 0.

Lemma primeGIP x :
  reflect ((1 < 'N x)%N /\ 
           forall y, ('N y < 'N x)%N -> (y %| x) -> 'N y = 1%N) (primeGI x).

Lemma primeGIPn x :
  reflect (('N x < 2)%N \/ 
           exists2 y, (1 < 'N y < 'N x)%N & (y %| x)) 
           (~~ primeGI x).

Definition primesGI (x : GI) :=
 [seq i <- [seq GI_of_ord i| i : ordinalGI ('N x).+1] |
      primeGI i && (i %| x)].

Lemma mem_primesGI  (p x : GI) :
   (p \in primesGI x) = [&& primeGI p, x != 0 & p %| x].

Lemma eqGI_prime x y : x %= y -> primeGI x -> primeGI y.

Definition pdivGI x : GI := head 1 (primesGI x).

Lemma pdivGI_prime x : (1 < 'N x)%N -> primeGI (pdivGI x).

Lemma pdivGI_dvd x : pdivGI x %| x.

Lemma pdivGI_leq x : x != 0 -> ('N (pdivGI x) <= 'N x)%N.

Lemma pdivGI_neq0 x : pdivGI x != 0.

Fixpoint logGI_rec p x n := 
  if (p %| x) then 
    if n is n1.+1 then (logGI_rec p (x %/ p) n1).+1 else 0%N
  else 0%N.

Definition logGI p x :=
  if primeGI p then logGI_rec p x ('N x) else 0%N.

Lemma logGI_recE p x m1 m2 :
  primeGI p -> ('N x <= m1)%N -> ('N x <= m2)%N -> x != 0 ->
  logGI_rec p x m1 = logGI_rec p x m2.

Lemma logGIE p x :
  logGI p x = if [&& primeGI p, x != 0 & p %| x] then (logGI p (x %/ p)).+1 else 0%N.

Lemma logGI_gt0 p x : (0 < logGI p x)%N = (p \in primesGI x).

Lemma ltn_log0 p x : ('N x < 'N p)%N -> logGI p x = 0%N.

Lemma logGI0 p : logGI p 0 = 0%N.

Lemma logGI1 p : logGI p 1 = 0%N.

Lemma pfactor_dvdGI p (n : nat) (x : GI) : primeGI p -> x != 0 -> (p ^+ n %| x) = (n <= logGI p x)%N.

Definition coprimeGI (x y : GI) := 'N(gcdGI x y) == 1%N.

Lemma coprimeGI1 x : coprimeGI x 1.

Lemma coprime1GI x : coprimeGI 1 x.

Lemma coprimeGIE x y : coprimeGI x y = (gcdGI x y %= 1).

Lemma coprimeGI_sym: commutative coprimeGI.

Lemma Gauss_dvdGI (x y z : GI) : coprimeGI x y -> (x * y %| z) = (x %| z) && (y %| z).

Lemma coprimeGI_nat m n :
  coprime m n -> coprimeGI (m%:R) (n%:R).

Lemma Gauss_dvdGIr (x y z : GI) :
   coprimeGI x y -> (x %| y * z) = (x %| z).

Lemma Gauss_dvdGIl (x y z : GI) :
   coprimeGI x y -> (x %| z * y) = (x %| z).

Lemma coprimeGI_dvdl x y z : x %| y ->  coprimeGI y z -> coprimeGI x z.

Lemma coprimeGI_dvdr x y z : x %| y ->  coprimeGI z y -> coprimeGI z x.

Lemma Gauss_gcdGIr (x y z : GI) :
   coprimeGI z x -> gcdGI z (x * y) %= gcdGI z y.

Lemma Gauss_gcdGIl x y z :
   coprimeGI z y -> gcdGI z (x * y) %= gcdGI z x.

Lemma coprimeGI_mulr (x y z : GI) :
  coprimeGI x (y * z) = coprimeGI x y && coprimeGI x z.

Lemma coprimeGI_mull (x y z : GI) :
  coprimeGI (y * z) x = coprimeGI y x && coprimeGI z x.

Lemma primeGI_neq0 p : primeGI p -> p != 0.

Lemma coprimeGI_pexpl k (x y : GI) : 
  (0 < k)%N -> coprimeGI (x ^+ k) y = coprimeGI x y.

Lemma coprimeGI_pexpr k (x y : GI) : 
  (0 < k)%N -> coprimeGI x (y ^+ k) = coprimeGI x y.

Lemma coprimeGI_expl k (x y : GI) : coprimeGI x y -> coprimeGI (x ^+ k) y.

Lemma coprimeGI_expr k x y : coprimeGI x y -> coprimeGI x (y ^+ k).

Lemma primeGI_dvd p x : primeGI p -> (x %| p) = (x %= 1) || (x %= p).

Lemma primeGI_coprime p x : primeGI p -> coprimeGI p x = ~~ (p %| x).

Lemma pfactor_coprimeGI (p x : GI) :
  primeGI p -> x != 0 -> {y | coprimeGI p y & x = y * p ^+ logGI p x}.

Lemma dvdGI_leq_log (x y z : GI) : 
  z != 0 -> y %| z -> (logGI x y <= logGI x z)%N.

Lemma pfactorGIK p n : primeGI p -> logGI p (p ^+ n) = n.

Lemma pdivGI_pfactor p k : primeGI p -> pdivGI (p ^+ k.+1) %= p.

Lemma logGI_Gauss x y z : 
   coprimeGI x y -> logGI x (y * z) = logGI x z.

Lemma logGIM x y z : 
  y != 0 -> z != 0 -> logGI x (y * z) = (logGI x y + logGI x z)%N.

Lemma logGIX p x n : logGI p (x ^+ n) = (n * logGI p x)%N.

Lemma gcdGI_mull_equiv (m n p q : GI) :
  coprimeGI m n -> m * n  = p * q -> m %= gcdGI m p * gcdGI m q.

End GaussIntegers.

Delimit Scope GI_scope with GI.

Notation "'N x" := (normGI x%R) (at level 10) : GI_scope.
Notation " x %| y " := (dvdGI x y) : GI_scope.
Notation " x %/ y " := (divGI x y) : GI_scope.
Notation " x %% y " := (modGI x y) : GI_scope.
Notation " x %= y " := (eqGI x y) : GI_scope. *)

Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Import GRing.Theory Num.Theory UnityRootTheory.

Open Scope nat_scope.

Definition sum_of_two_square := 
  [qualify a x |
       [exists a : 'I_x.+1, exists b : 'I_x.+1, x == a ^ 2 + b ^ 2]].

Lemma sum2sP x :
  reflect (exists m, exists n, x = m ^ 2 + n ^ 2) 
          (x \is a sum_of_two_square).
Proof.
apply: (iffP existsP) => [[m /existsP[n /eqP->]]|[m [n ->]]].
  by exists m; exists n.
have F1 : m <  (m ^ 2 + n ^ 2).+1.
  rewrite ltnS (leq_trans _ (leq_addr _ _)) //.
  by case: m => [|[|m]] //; rewrite (leq_exp2l 1).
have F2 : n <  (m ^ 2 + n ^ 2).+1.
  rewrite ltnS (leq_trans _ (leq_addl _ _)) //.
  by case: (n) => [|[|n1]] //; rewrite (leq_exp2l 1).
by exists (Ordinal F1); apply/existsP; exists (Ordinal F2).
Qed.

Fact sum2s0 : 0 \is a sum_of_two_square.
Proof. by apply/sum2sP; exists 0; exists 0. Qed.

Fact sum2s1 : 1 \is a sum_of_two_square.
Proof. by apply/sum2sP; exists 0; exists 1. Qed.

Fact sum2s2 : 2 \is a sum_of_two_square.
Proof. by apply/sum2sP; exists 1; exists 1. Qed.

Fact sum2sX_even x n :
 ~~ odd n  -> x ^ n \is  a sum_of_two_square.
Proof.
move=> En; apply/sum2sP; exists (x ^ n./2); exists 0.
by rewrite addn0 -{1}[n]odd_double_half (negPf En) -expnM muln2.
Qed.

Lemma sum2sGP x :
  reflect (exists m : GI, x = normGI m)
          (x \is a sum_of_two_square).
Proof.
apply: (iffP idP) => [/sum2sP[m [n ->]]|[x1->]].
exists (m%:R + iGI * n%:R)%R.
  by rewrite normGIE /= !algGI_nat Re_rect ?Im_rect 
             ?CrealE ?conjC_nat ?natCK // !normr_nat !natCK.
rewrite normGIE; set m := truncC _; set n := truncC _.
by apply/sum2sP; exists m; exists n.
Qed.

Lemma sum2sM x y :
  x \is  a sum_of_two_square ->
  y \is  a sum_of_two_square ->
  x * y \is  a sum_of_two_square.
Proof.
move=> /sum2sGP[x1->] /sum2sGP[y1->]; rewrite -normGIM.
by apply/sum2sGP; exists (x1 * y1)%R.
Qed.

Lemma sum2s_dvd_prime p a b :
  prime p -> coprime a b -> 
  p %| a ^ 2 + b ^ 2 -> p \is  a sum_of_two_square.
Proof.
move=> Pp Cab pDab.
have /dvdGI_norm := pdivGI_dvd (p%:R); set x := pdivGI _.
have Px : primeGI x.
  apply: pdivGI_prime; rewrite normGI_nat.
  by rewrite -{1}(expn0 p) ltn_exp2l // prime_gt1.
rewrite (normGI_nat p)=> /(dvdn_pfactor _ _ Pp)=> [[[|[|[]]]]] _ //.
- by move=> H; case/andP: Px; rewrite H ltnn.
- by rewrite expn1=> H; apply/sum2sGP; exists x.
rewrite -normGI_nat => H1.
have PGIp : primeGI (p%:R).
 apply: eqGI_prime Px.
 by apply: dvdGI_eq_norm (pdivGI_dvd _).
pose z := (a%:R + iGI * b%:R)%R.
have F : ('N z)%GI = a ^ 2 + b ^ 2.
  by rewrite normGIE /= !algGI_nat !(Re_rect, Im_rect)
            ?Creal_Cnat // !normr_nat !natCK.
have F1 : (p%:R %| z * conjGI z)%GI%R.
  rewrite conjGIM_norm F.
  case/dvdnP: pDab => q1 ->.
  by apply/dvdGIP; exists (q1%:R); rewrite natrM.
have []: ~ (p %| gcdn a b).
  by rewrite (eqP Cab) Euclid_dvd1.
rewrite dvdn_gcd.
have [F2|] := boolP (p%:R %| z)%GI.
  have := dvdGI_nat_dvdz_Re F2.
  rewrite Re_rect /= algGI_nat ?Creal_Cnat //=
           (intCK (Posz a)) /= => ->.
  have := dvdGI_nat_dvdz_Im F2.
  by rewrite Im_rect /= algGI_nat ?Creal_Cnat //=
           (intCK (Posz b)).
rewrite -primeGI_coprime // => HH.
have F2 : (p%:R %| conjGI z)%GI.
  by rewrite -(Gauss_dvdGIr _ HH).
have := dvdGI_nat_dvdz_Re F2.
rewrite Re_conj Re_rect /= algGI_nat ?Creal_Cnat //=
           (intCK (Posz a)) => ->.
have := dvdGI_nat_dvdz_Im F2.
rewrite Im_conj Im_rect /= algGI_nat ?Creal_Cnat //=.
by rewrite floorCN ?Cint_Cnat // abszN (intCK (Posz b)).
Qed.

Lemma sum2sX x n :
  x \is  a sum_of_two_square  -> x ^ n \is  a sum_of_two_square.
Proof.
move=>/sum2sGP[x1->]; rewrite -normGIX.
by apply/sum2sGP; exists (x1 ^+ n)%R.
Qed.

Lemma sum2sX_prime x n :
  prime x -> odd n ->
  x ^ n \is  a sum_of_two_square -> x  \is  a sum_of_two_square.
Proof.
move=> Px On /sum2sP[a [b adE]].
pose u := gcdn a b.
have /(dvdn_pfactor _ _ Px)[m] : u ^ 2 %| x ^ n.
  by rewrite adE dvdn_add // dvdn_exp2r ?(dvdn_gcdr, dvdn_gcdl).
rewrite leq_eqVlt => /orP[/eqP->|nLM] uE.
  move: On; have := congr1 (logn x) uE.
  rewrite (pfactorK _ Px) lognX => <-.
  by rewrite mul2n odd_double.
have /(sum2s_dvd_prime _ _)->//: x %| (a %/ u) ^ 2 + (b %/ u) ^ 2.
  apply/dvdnP; exists (x^(n-m).-1); apply/eqP.
    rewrite -expnSr prednK ?subn_gt0 //.
    have/eqn_pmul2r<- : (0 < x ^ m) by rewrite expn_gt0 prime_gt0.
    by rewrite -{1}uE mulnDl -!expnMn -expnD subnK 1?ltnW //
            !divnK ?(adE, dvdn_gcdr, dvdn_gcdl).
rewrite /coprime.
have/eqn_pmul2r<- : (0 < u).
  have: (0 < u ^ 2) by rewrite uE expn_gt0 prime_gt0.
  by case: (u).
by rewrite muln_gcdl mul1n !divnK ?(adE, dvdn_gcdr, dvdn_gcdl).
Qed.

Lemma sum2sM_coprime x y :
  coprime x y ->
  x * y \is  a sum_of_two_square ->  x \is  a sum_of_two_square.
Proof.
move=> Cxy /sum2sGP[z Hz].
pose t := gcdGI (x%:R) z.
apply/sum2sGP; exists t.
apply: eqGI_nat.
rewrite -conjGIM_norm.
apply: eqGI_trans (_ : eqGI (t * gcdGI (x%:R) (conjGI z))%R _).
  apply: gcdGI_mull_equiv (coprimeGI_nat Cxy) _.
  by rewrite -natrM Hz conjGIM_norm.
apply: eqGI_mul (eqGIxx _) _.
by rewrite -conjGI_nat eqGI_sym conjGI_gcd.
Qed.

Lemma modn_prod I r (P : pred I) F d :
  \prod_(i <- r | P i) (F i %% d) = \prod_(i <- r | P i) F i %[mod d].
Proof.
apply/eqP; elim/big_rec2: _ => // i m n _.
by rewrite modnMml -modnMmr => /eqP->; rewrite modnMmr.
Qed.

Lemma sum2sprime p : 
  odd p -> prime p -> p \is a sum_of_two_square = (p %% 4 == 1).
Proof.
move=> Op Pp; apply/idP/idP=>[/sum2sP[a [b H]]|pM4].
  have F c : (c ^ 2 %% 4 == 0) || (c ^ 2 %% 4 == 1).
    rewrite -modnXm expnS expn1.
    by move: (c %% 4) (ltn_pmod c (isT: 0 < 4)); do 4 case => //.
  have : (p %% 4 == 1) || (p %% 4 == 3).
    rewrite -[p]odd_double_half Op -modnDmr -muln2.
    have /(_ _ 2)<- := muln_modl (isT: 0 < 2).
    by move: (_ %% 2) (ltn_pmod p./2 (isT: 0 < 2)); do 2 case => //.
  rewrite H -modnDm.
  by move: (F a) (F b) => /orP[] /eqP-> /orP[] /eqP->.
pose k := p %/ 4.
have p_gt0 := prime_gt0 Pp.
have p_gt1 := prime_gt1 Pp.
have : (p.-1)`!.+1 %% p == 0 by rewrite -[_ == 0]Wilson.
have : \prod_(1 <= i < (k * 2).+1) (p - 1) = 1 %[mod p].
  rewrite prod_nat_const_nat !subn1 /= mulnC expnM.
  rewrite -modnXm expnS expn1.
  rewrite -[_ * _ %% _]modnDr -{3}[p]prednK -addn1 //.
  by rewrite addnA -mulnSr prednK // modnMDl modnXm exp1n.
have pE : p = (k * 4).+1 by rewrite (divn_eq p 4) (eqP pM4) addn1.
rewrite pE => F.
have [/eqP-> _|] := boolP (k == 0); first exact: sum2s1.
rewrite -leqn0 -ltnNge => Pk.
rewrite fact_prod (big_cat_nat _ _ _ (_ : 1 <= (k * 2).+1)) //=; last first.
  by rewrite ltnS leq_mul2l orbT.
set S1 := \prod_(_ <= _ < _ ) _.
rewrite -addn1 -modnDml -modnMmr big_nat_rev /=.
rewrite -[(k * 2).+1]add1n big_addn.
rewrite subSn ?leq_pmul2l // -mulnBr /=.
set S2 := \prod_(_ <= _ < _ ) _.
rewrite -[S2]muln1 -[S2 * 1 %% _]modnMmr -{}F.
rewrite [S2 * _ %% _]modnMmr.
rewrite -[S2 * _]big_split /=.
set S3 := \prod_(_ <= _ < _ ) _.
suff ->: S3 = S1 %[mod (k * 4).+1].
  rewrite modnMmr modnDml -{1}[S1]expn1 -expnSr -[S1]fact_prod.
  rewrite -pE -{3}[1](exp1n 2) => /sum2s_dvd_prime-> //.
  by rewrite coprimen1.
rewrite -modn_prod -[in RHS]modn_prod.
rewrite big_nat_cond [in RHS]big_nat_cond.
congr (_ %% _).
apply: eq_bigr => i /andP[/andP[H1 H2] _].
rewrite add1n addnC -addnS [i + _]addnC subnDA addnK.
have H3 : i <= (k * 4).+1.
  by rewrite ltnW // (leq_trans H2) // ltnS leq_pmul2l.
rewrite -modnDr -{3}(subnK H3) addnA -mulnSr subn1 prednK //.
by rewrite modnMDl.
Qed.

Lemma sum2stest n :
  reflect
  (forall p,  prime p -> odd p -> p %| n -> odd (logn p n) -> p %% 4 = 1)
  (n \is a sum_of_two_square).
Proof.
apply: (iffP idP) => [Hs p Pp Op Dp OL|HH].
  have Pn : 0 < n by case: (n) OL; rewrite ?logn0.
  have /(pfactor_coprime Pp)[m Cmp mE] := (Pn).
  apply/eqP; rewrite -sum2sprime //.
  apply:  sum2sX_prime OL _ => //.
  rewrite mE mulnC in Hs.
  by apply: sum2sM_coprime Hs; rewrite coprime_pexpl // -pfactor_dvdn.
have [/eqP->|] := boolP (n == 0); first by apply:sum2s0.
rewrite -leqn0 -ltnNge => /prod_prime_decomp->.
rewrite big_seq_cond /=.
elim/big_rec: _ => [|i x /andP[]].
exact: sum2s1.
rewrite prime_decompE => /mapP[p].
rewrite mem_primes => /and3P[Pp Pn pDn] -> _ xS /=.
apply: sum2sM => //.
have [OL|] := boolP (odd (logn p n)); last by exact: sum2sX_even.
apply: sum2sX.
have [Op|/prime_oddPn->//] := boolP (odd p); last by exact: sum2s2.
by rewrite sum2sprime // HH.
Qed.
