
Require Export BV.
(* BV:
Require Export Arith_compl.
Require Export Bool_compl.
Require Export Lists_replace.

Definition BV := list bool.
Definition nilbv : BV := nil.
Definition consbv : bool -> BV -> BV := cons (A:=bool).
Definition appbv : BV -> BV -> BV := app (A:=bool).
Definition lengthbv : BV -> nat := length (A:=bool).
Definition lenbv : BV -> nat -> Prop := len bool.
Definition BV_null (n : nat) : BV := list_const bool n false.
Definition truncbv : BV -> nat -> BV := trunc bool.
Definition stripbv : BV -> nat -> BV := strip bool.
Definition field : BV -> nat -> nat -> BV := sublist bool.
Definition abit : BV -> nat -> BV := elemlist bool.
Definition bitset : BV -> nat -> bool -> BV := replace bool.
Definition BVnot (v : BV) : BV := map bool bool v negb.

Fixpoint BV_to_nat (v : BV) : nat :=
  match v return nat with
  | nil => 0
  | b :: w => bool_to_nat b + (BV_to_nat w + BV_to_nat w)
  end.

Lemma BV_to_nat_eq1 : BV_to_nat nilbv = 0.
Lemma BV_to_nat_eq2 :
 forall (b : bool) (w : BV),
 BV_to_nat (consbv b w) = bool_to_nat b + (BV_to_nat w + BV_to_nat w).

Lemma BV_to_nat_app :
 forall (l n : BV) (ll : nat),
 
 lenbv l ll -> BV_to_nat (appbv l n) = BV_to_nat l + power2 ll * BV_to_nat n.

Lemma BV_to_nat_app2 :
 forall l n : BV,
 
 BV_to_nat (appbv l n) = BV_to_nat l + power2 (lengthbv l) * BV_to_nat n.

Lemma BV_null_nat : forall n : nat, BV_to_nat (BV_null n) = 0.

Lemma length_BV_null : forall n : nat, lengthbv (BV_null n) = n. *)
Require Export Adder.
(* Adder:
Require Export BV.
Require Export FullAdder.

Definition BV_full_adder_sum :=
  (fix F (l : list bool) : list bool -> bool -> BV :=
     match l with
     | nil =>
         (fix F0 (l0 : list bool) : bool -> BV :=
            match l0 with
            | nil => fun _ : bool => nilbv
            | b :: l1 =>
                fun z : bool =>
                consbv (half_adder_sum b z) (F0 l1 (half_adder_carry b z))
            end)
     | b :: l0 =>
         fun x2 : list bool =>
         match x2 with
         | nil =>
             fun y z : bool =>
             consbv (half_adder_sum y z) (F l0 nil (half_adder_carry y z))
         | b0 :: l1 =>
             fun y z : bool =>
             consbv (full_adder_sum y b0 z)
               (F l0 l1 (full_adder_carry y b0 z))
         end b
     end).
    
Lemma BV_full_adder_sum_eq1 :
 forall b : bool, BV_full_adder_sum nil nil b = nilbv.

Lemma BV_full_adder_sum_eq2 :
 forall (vh : bool) (vt : list bool) (b : bool),
 BV_full_adder_sum nil (vh :: vt) b =
 consbv (half_adder_sum vh b)
   (BV_full_adder_sum nil vt (half_adder_carry vh b)).

Lemma BV_full_adder_sum_eq3 :
 forall (vh : bool) (vt : list bool) (b : bool),
 BV_full_adder_sum (vh :: vt) nil b =
 consbv (half_adder_sum vh b)
   (BV_full_adder_sum vt nil (half_adder_carry vh b)).

Lemma BV_full_adder_sum_eq4 :
 forall (vh : bool) (vt : list bool) (wh : bool) (wt : list bool) (b : bool),
 BV_full_adder_sum (vh :: vt) (wh :: wt) b =
 consbv (full_adder_sum vh wh b)
   (BV_full_adder_sum vt wt (full_adder_carry vh wh b)).

Definition BV_full_adder_carry :=
  (fix F (l : list bool) : list bool -> bool -> bool :=
     match l with
     | nil =>
         (fix F0 (l0 : list bool) : bool -> bool :=
            match l0 with
            | nil => fun z : bool => z
            | b :: l1 => fun z : bool => F0 l1 (half_adder_carry b z)
            end)
     | b :: l0 =>
         fun x2 : list bool =>
         match x2 with
         | nil => fun y z : bool => F l0 nil (half_adder_carry y z)
         | b0 :: l1 => fun y z : bool => F l0 l1 (full_adder_carry y b0 z)
         end b
     end).

Lemma BV_full_adder_carry_eq1 :
 forall b : bool, BV_full_adder_carry nil nil b = b.

Lemma BV_full_adder_carry_eq2 :
 forall (vh : bool) (vt : list bool) (b : bool),
 BV_full_adder_carry nil (vh :: vt) b =
 BV_full_adder_carry nil vt (half_adder_carry vh b).

Lemma BV_full_adder_carry_eq3 :
 forall (vh : bool) (vt : list bool) (b : bool),
 BV_full_adder_carry (vh :: vt) nil b =
 BV_full_adder_carry vt nil (half_adder_carry vh b).

Lemma BV_full_adder_carry_eq4 :
 forall (vh : bool) (vt : list bool) (wh : bool) (wt : list bool) (b : bool),
 BV_full_adder_carry (vh :: vt) (wh :: wt) b =
 BV_full_adder_carry vt wt (full_adder_carry vh wh b).

Definition BV_full_adder (v w : BV) (cin : bool) : BV :=
  appbv (BV_full_adder_sum v w cin)
    (consbv (BV_full_adder_carry v w cin) nilbv).

Hint Unfold BV_full_adder.

Lemma BV_full_adder_sum_v_nil_false :
 forall v : BV, BV_full_adder_sum v nilbv false = v.

Lemma BV_full_adder_carry_v_nil_false :
 forall v : BV, BV_full_adder_carry v nilbv false = false.

Lemma BV_full_adder_sum_sym :
 forall (v w : BV) (cin : bool),
 BV_full_adder_sum v w cin = BV_full_adder_sum w v cin.
				       
Lemma length_BV_full_adder_sum :
 forall (v w : BV) (cin : bool),
 lengthbv v = lengthbv w -> lengthbv (BV_full_adder_sum v w cin) = lengthbv v.

Lemma BV_full_adder_carry_sym :
 forall (v w : BV) (cin : bool),
 BV_full_adder_carry v w cin = BV_full_adder_carry w v cin.

Lemma BV_full_adder_sym :
 forall (v w : BV) (cin : bool),
 BV_full_adder v w cin = BV_full_adder w v cin. *)
Require Import Gt.

Definition Mux := If BV.
Hint Unfold Mux.

Definition lowbit (l : list bool) :=
  match l with
  | nil => false
  | b :: _ => b
  end.

Definition highs (l : list bool) :=
  match l with
  | nil => nil (A:=bool)
  | _ :: v => v
  end.

Lemma lowbit_is_trunc :
 forall v : BV, v <> nilbv -> consbv (lowbit v) nilbv = truncbv v 1.
simple induction v. intro. absurd (nil <> nilbv); unfold not in |- *; auto with arith.
intros. simpl in |- *. rewrite (trunc_O bool). trivial with arith.
Qed.

Lemma lowbit_is_abit :
 forall v : BV, v <> nilbv -> consbv (lowbit v) nilbv = abit v 0.
intros. unfold abit in |- *. unfold elemlist in |- *. rewrite strip_O.
apply lowbit_is_trunc. exact H.
Qed.

Lemma highs_is_strip : forall v : BV, highs v = stripbv v 1.
simple induction v. simpl in |- *. auto with arith.
intros. simpl in |- *. rewrite (strip_cons_S bool). rewrite strip_O. trivial with arith.
Qed.

Lemma app_lowbit_highs :
 forall v : BV, v <> nilbv -> appbv (consbv (lowbit v) nilbv) (highs v) = v.
intros. rewrite lowbit_is_trunc. rewrite highs_is_strip.
rewrite (app_trunc_strip bool). trivial with arith. exact H.
Qed.

Lemma length_highs :
 forall v : BV, v <> nilbv -> lengthbv (highs v) = pred (lengthbv v).
intros. rewrite highs_is_strip.
rewrite (length_strip bool). apply minus_n_SO.
apply (v_not_nil_length bool). exact H.
Qed.

Lemma length_abit :
 forall (v : BV) (i : nat), i < lengthbv v -> lengthbv (abit v i) = 1.
unfold abit in |- *. exact (length_elemlist bool).
Qed.

Parameter size : nat. 
Parameter V1 : BV. 
Parameter V2 : BV.

Axiom size_not_O : size <> 0. Hint Resolve size_not_O.
Axiom length_V1_size : lengthbv V1 = size. Hint Resolve length_V1_size.
Axiom length_V2_size : lengthbv V2 = size. Hint Resolve length_V2_size.

Lemma le_SO_size : 1 <= size.
       generalize size_not_O. elim size. intro. absurd (0 <> 0); unfold not in |- *; auto with arith.
       intros. apply le_n_S. auto with arith. Qed. Hint Resolve le_SO_size.

Lemma length_V1 : lengthbv V1 <> 0.
	rewrite length_V1_size. auto with arith. Qed. Hint Resolve length_V1.
Lemma length_V2 : lengthbv V2 <> 0.
	rewrite length_V2_size. auto with arith. Qed. Hint Resolve length_V2.
Lemma length_V2_V1 : lengthbv V2 = lengthbv V1.
	transitivity size; auto with arith. Qed.
Lemma V1_not_nil : V1 <> nilbv.
	apply (not_nil bool). auto with arith. Qed. Hint Resolve V1_not_nil.
Lemma V2_not_nil : V2 <> nilbv.
	apply (not_nil bool). auto with arith. Qed. Hint Resolve V2_not_nil.
Lemma le_SO_length_V1 : 1 <= lengthbv V1.
	apply (le_SO_length_v bool). auto with arith. Qed. Hint Resolve le_SO_length_V1.

Fixpoint R1 (st : nat) : BV :=
  match st return BV with
  | O => V1
  | S t =>
      appbv (highs (R1 t))
        (Mux (lowbit (R1 t))
           (consbv (lowbit (BV_full_adder_sum (R2 t) V2 false)) nilbv)
           (consbv (lowbit (R2 t)) nilbv))
  end
 
 with R2 (st : nat) : BV :=
  match st return BV with
  | O => BV_null size
  | S t =>
      appbv
        (highs
           (Mux (lowbit (R1 t)) (BV_full_adder_sum (R2 t) V2 false) (R2 t)))
        (Mux (lowbit (R1 t))
           (consbv (BV_full_adder_carry (R2 t) V2 false) nilbv)
           (consbv false nilbv))
  end.

Lemma R1_eq1 : R1 0 = V1. auto with arith. Qed.
Lemma R1_eq2 :
 forall t : nat,
 R1 (S t) =
 appbv (highs (R1 t))
   (Mux (lowbit (R1 t))
      (consbv (lowbit (BV_full_adder_sum (R2 t) V2 false)) nilbv)
      (consbv (lowbit (R2 t)) nilbv)).
auto with arith. Qed.

Lemma R2_eq1 : R2 0 = BV_null size. auto with arith. Qed.
Lemma R2_eq2 :
 forall t : nat,
 R2 (S t) =
 appbv
   (highs (Mux (lowbit (R1 t)) (BV_full_adder_sum (R2 t) V2 false) (R2 t)))
   (Mux (lowbit (R1 t)) (consbv (BV_full_adder_carry (R2 t) V2 false) nilbv)
      (consbv false nilbv)).
auto with arith. Qed.

Lemma length_R1 : forall t : nat, t <= size -> lengthbv (R1 t) = size.
simple induction t. auto with arith.
intros. rewrite R1_eq2. rewrite (length_app bool).
unfold Mux in |- *. rewrite (F_If BV nat _ _ _ (@length bool)). simpl in |- *. rewrite If_eq.
rewrite highs_is_strip. rewrite (length_strip bool). unfold lengthbv in H.
rewrite H. symmetry  in |- *. rewrite plus_comm. apply le_plus_minus. auto with arith.
apply le_Sn_le; auto with arith.
unfold lengthbv in H. rewrite H. auto with arith.
apply le_Sn_le. exact H0.
Qed. Hint Resolve length_R1.

Lemma length_R2 : forall t : nat, t <= size -> lengthbv (R2 t) = size.
simple induction t. simpl in |- *.
unfold lengthbv, BV_null in |- *. rewrite (length_list_const bool). trivial with arith.
unfold lengthbv in |- *. intros. rewrite R2_eq2.
rewrite (length_app bool). unfold Mux, consbv. 
rewrite (F_If BV BV _ _ _ highs). 
rewrite (F_If BV nat _ _ _ (@length bool)).
rewrite highs_is_strip. rewrite (length_strip bool).
rewrite length_BV_full_adder_sum. unfold lengthbv in |- *.
rewrite H. rewrite highs_is_strip. rewrite (length_strip bool).
rewrite H. rewrite If_eq. rewrite (F_If BV nat _ _ _ (@length bool)). simpl in |- *.
rewrite If_eq. symmetry  in |- *. rewrite plus_comm. apply le_plus_minus. auto with arith.
auto with arith. rewrite H. auto with arith.
apply le_Sn_le; exact H0. apply le_Sn_le; exact H0.
unfold lengthbv in |- *. rewrite H. auto with arith. apply le_Sn_le; exact H0.
rewrite length_BV_full_adder_sum.
unfold lengthbv in |- *. rewrite H. auto with arith. apply le_Sn_le; exact H0.
unfold lengthbv in |- *. rewrite H. auto with arith. apply le_Sn_le; exact H0.
Qed. Hint Resolve length_R2.

Lemma R1_never_nil : forall t : nat, t <= size -> R1 t <> nilbv.
intros. apply (not_nil bool). rewrite length_R1. auto with arith. exact H.
Qed.

