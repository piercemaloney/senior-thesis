
Require Export Arith_compl.
(* Arith_compl:
Require Export Plus.
Require Export Mult.
Require Import Minus.
Require Export Lt.
Require Export Le.
Require Export Gt.

Lemma plus_n_SO : forall x : nat, x + 1 = S x.

Lemma plus_permute2 : forall x y z : nat, x + y + z = x + z + y.

Lemma mult_sym : forall a b : nat, a * b = b * a.

Lemma mult_permute : forall a b c : nat, a * b * c = a * c * b.

Lemma plus_O_O : forall n m : nat, n + m = 0 -> n = 0.

Lemma mult_plus_distr2 : forall n m p : nat, n * (m + p) = n * m + n * p.

Fixpoint power2 (n : nat) : nat :=
  match n with
  | O => 1
  | S x => power2 x + power2 x
  end.

Lemma power2_eq2 : forall x : nat, power2 (S x) = power2 x + power2 x.

Lemma power2_plus : forall x y : nat, power2 (x + y) = power2 x * power2 y.

Theorem le_plus_n_m : forall n m : nat, n <= m -> n + n <= m + m.

Theorem lt_plus_n_m : forall n m : nat, n < m -> S (n + n) < m + m.

Lemma le_plus_lem1 : forall a b c : nat, a <= b -> c + a <= c + b.

Lemma le_plus_lem2 : forall a b c : nat, c + a <= c + b -> a <= b.

Lemma gt_double : forall a b : nat, a + a > b + b -> a > b. 

Lemma gt_double_inv : forall a b : nat, a > b -> a + a > b + b.

Lemma gt_double_n_S : forall a b : nat, a > b -> a + a > S (b + b).

Lemma gt_double_S_n : forall a b : nat, a > b -> S (a + a) > b + b.

Lemma minus_le_O : forall a b : nat, a <= b -> a - b = 0.

Lemma minus_n_SO : forall n : nat, n - 1 = pred n.

Lemma minus_le_lem2c : forall a b : nat, a - S b <= a - b.

Lemma minus_le_lem2 : forall a b : nat, a - b <= a.

Lemma minus_minus_lem1 : forall a b : nat, a - b - a = 0.

Lemma minus_minus_lem2 : forall a b : nat, b <= a -> a - (a - b) = b.

Lemma le_minus_minus : forall a b c : nat, c <= b -> a - b <= a - c. *)
Require Export Bool_compl.
(* Bool_compl:
Require Export Bool.

Lemma neg_eq : forall a b : bool, negb a = negb b -> a = b.

Lemma false_to_true : false = negb true.

Lemma true_to_false : true = negb false.

Definition xorb (b1 b2 : bool) : bool := b1 && negb b2 || negb b1 && b2.

Lemma xorb_b_b : forall b : bool, xorb b b = false.

Lemma xorb_b_false : forall b : bool, xorb b false = b.

Lemma xorb_b_true : forall b : bool, xorb b true = negb b.

Definition bool_to_nat (b : bool) :=
  match b with
  | true => 1
  | false => 0
  end.

Lemma bool_to_nat_all :
 forall b : bool, bool_to_nat b = 0 \/ bool_to_nat b = 1.

Definition If (T : Set) (b : bool) (x y : T) :=
  match b with
  | true => x
  | false => y
  end.

Lemma If_neg :
 forall (T : Set) (b : bool) (x y : T), If T (negb b) x y = If T b y x.

Lemma If_eq : forall (T : Set) (b : bool) (x : T), If T b x x = x.

Lemma IfIf :
 forall (T : Set) (b1 b2 : bool) (x x' y y' : T),
 If T b1 (If T b2 x y) (If T b2 x' y') =
 If T b2 (If T b1 x x') (If T b1 y y').

Lemma If_cond_true :
 forall (T : Set) (a : bool) (x y : T), x <> y -> If T a x y = x -> a = true.

Lemma If_cond_false :
 forall (T : Set) (a : bool) (x y : T), x <> y -> If T a x y = y -> a = false.

Lemma F_If :
 forall (T T' : Set) (a : bool) (x y : T) (F : T -> T'),
 F (If T a x y) = If T' a (F x) (F y). *)
Require Export Lists_replace.
(* Lists_replace:
Require Export Lists_field.

Section Lists_replace.
Variable A : Set.

Fixpoint replace (l : list A) : nat -> A -> list A :=
  fun (position : nat) (new : A) =>
  match l return (list A) with
  | nil =>
        nil
  | x :: l' =>
      
      match position return (list A) with
      | O =>
            new :: l'
          
      | S n' => x :: replace l' n' new
      end
  end.

Lemma replace_ok :
 forall (l : list A) (i : nat) (x : A),
 
 i < length l -> elemlist A (replace l i x) i = x :: nil.

Lemma replace_keep_others :
 forall (l : list A) (i p : nat) (x : A),
 
 i < length l ->
 p < length l -> i <> p -> elemlist A (replace l p x) i = elemlist A l i.

Lemma length_replace :
 forall (l : list A) (p : nat) (x : A),
 
 p < length l -> length (replace l p x) = length l.

Lemma replace_sym :
 forall (l : list A) (p p' : nat) (x x' : A),
 
 p < length l ->
 p' < length l ->
 p <> p' -> replace (replace l p' x') p x = replace (replace l p x) p' x'.

Lemma replace_newer :
 forall (l : list A) (p : nat) (x x' : A),
 
 p < length l -> replace (replace l p x) p x' = replace l p x'.

End Lists_replace. *)

Definition BV := list bool.
Definition nilbv : BV := nil.
Definition consbv : bool -> BV -> BV := cons (A:=bool).
Definition appbv : BV -> BV -> BV := app (A:=bool).
Definition lengthbv : BV -> nat := length (A:=bool).
Definition lenbv : BV -> nat -> Prop := len bool.
Definition BV_null (n : nat) : BV := list_const bool n false.
Definition truncbv : BV -> nat -> BV := trunc bool.
Definition stripbv : BV -> nat -> BV := strip bool.
Definition field : BV -> nat -> nat -> BV := sublist bool.
Definition abit : BV -> nat -> BV := elemlist bool.
Definition bitset : BV -> nat -> bool -> BV := replace bool.
Definition BVnot (v : BV) : BV := map bool bool v negb.

Fixpoint BV_to_nat (v : BV) : nat :=
  match v return nat with
  | nil => 0
  | b :: w => bool_to_nat b + (BV_to_nat w + BV_to_nat w)
  end.

Lemma BV_to_nat_eq1 : BV_to_nat nilbv = 0.
auto. Qed.
Lemma BV_to_nat_eq2 :
 forall (b : bool) (w : BV),
 BV_to_nat (consbv b w) = bool_to_nat b + (BV_to_nat w + BV_to_nat w).
auto. Qed.

Lemma BV_to_nat_app :
 forall (l n : BV) (ll : nat),
 
 lenbv l ll -> BV_to_nat (appbv l n) = BV_to_nat l + power2 ll * BV_to_nat n.
unfold BV, lenbv, appbv in |- *. simple induction l. intros. inversion H. simpl in |- *. auto.
intros. simpl in |- *. inversion H0. simpl in |- *.
rewrite (H n l1). rewrite mult_plus_distr_r. repeat rewrite plus_assoc.
rewrite
 (plus_permute2 (bool_to_nat a + BV_to_nat l0) (power2 l1 * BV_to_nat n)
    (BV_to_nat l0)).
auto.
exact H4.
Qed. Hint Resolve BV_to_nat_app.

Lemma BV_to_nat_app2 :
 forall l n : BV,
 
 BV_to_nat (appbv l n) = BV_to_nat l + power2 (lengthbv l) * BV_to_nat n.
intros. apply BV_to_nat_app. auto. unfold lenbv, lengthbv in |- *. apply len_length.
Qed. Hint Resolve BV_to_nat_app2.

Lemma BV_null_nat : forall n : nat, BV_to_nat (BV_null n) = 0.

unfold BV_null in |- *.
simple induction n; auto.
intros. simpl in |- *. rewrite H. auto.
Qed. Hint Resolve BV_null_nat.

Lemma length_BV_null : forall n : nat, lengthbv (BV_null n) = n.

unfold lengthbv, BV_null in |- *. intro. apply length_list_const.
Qed. Hint Resolve length_BV_null.
