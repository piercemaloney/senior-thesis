
Require Export Lists_field.
(* Lists_field:
Require Import Arith_compl.
Require Export Minus.
Require Export Lists_compl.

Section Lists_field.
Variable A : Set.

Fixpoint trunc (v : list A) : nat -> list A :=
  fun n : nat =>
  match v return (list A) with
  | nil => nil
  | b :: w =>
      match n return (list A) with
      | O => nil
      | S p => b :: trunc w p
      end
  end.

Definition strip (v : list A) (n : nat) :=
  rev A (trunc (rev A v) (length v - n)).

Definition sublist (v : list A) (start lengt : nat) :=
  trunc (strip v start) lengt.

Definition elemlist (v : list A) (i : nat) := trunc (strip v i) 1.

Lemma length_trunc :
 forall (v : list A) (i : nat),
 
 i <= length v -> length (trunc v i) = i.

Lemma trunc_inv :
 forall (v : list A) (i : nat) (b : A),
 
 b :: trunc v i = trunc (b :: v) (S i).

Lemma trunc_all : forall v : list A, trunc v (length v) = v.

Lemma trunc_max :
 forall (v : list A) (i : nat),
 
 length v <= i -> trunc v i = v.

Lemma trunc_O : forall v : list A, trunc v 0 = nil.

Lemma le_length_trunc :
 forall (v : list A) (i : nat), length (trunc v i) <= i.

Lemma trunc_app :
 forall (v1 v2 : list A) (i : nat),
 
 trunc (v1 ++ v2) i = trunc v1 i ++ trunc v2 (i - length v1).

Lemma app_v_trunc :
 forall (v1 v2 : list A) (i : nat),
 
 v1 ++ trunc v2 i = trunc (v1 ++ v2) (length v1 + i).

Lemma trunc_eq :
 forall (v1 v2 : list A) (i : nat), v1 = v2 -> trunc v1 i = trunc v2 i.

Lemma trunc_sym :
 forall (v : list A) (i j : nat), 
 
 trunc (trunc v i) j = trunc (trunc v j) i.

Lemma trunc_trunc1 :
 forall (v : list A) (i : nat),
 
 trunc (trunc v i) i = trunc v i.

Lemma trunc_trunc2 :
 forall (v : list A) (i j : nat),
 
 i <= j -> trunc (trunc v i) j = trunc v i.

Lemma trunc_trunc3 :
 forall (v : list A) (i j : nat),
 
 j <= i -> trunc (trunc v i) j = trunc v j.

Lemma trunc_plus_petit :
 forall (v1 v2 : list A) (i j : nat),
 
 j <= i -> trunc v1 i = v2 -> trunc v1 j = trunc v2 j.

Lemma strip_nil : forall i : nat, strip nil i = nil.

Lemma strip_cons_S :
 forall (v : list A) (i : nat) (b : A),
 
 strip (b :: v) (S i) = strip v i.

Lemma length_strip :
 forall (v : list A) (i : nat),
 
 i <= length v -> length (strip v i) = length v - i.

Lemma le_length_strip :
 forall (v : list A) (i : nat),
 
 length (strip v i) <= length v - i.

Lemma strip_inv :
 forall (v : list A) (i : nat),
 
 rev A (trunc (rev A v) (length v - i)) = strip v i.

Lemma strip_all : forall v : list A, strip v (length v) = nil.

Lemma strip_max :
 forall (v : list A) (i : nat),
 
 length v <= i -> strip v i = nil.

Lemma strip_O : forall v : list A, strip v 0 = v.

Lemma strip_app :
 forall (v1 v2 : list A) (i : nat),
 
 strip (v1 ++ v2) i = strip v1 i ++ strip v2 (i - length v1).

Lemma strip_strip_S :
 forall (v : list A) (i j : nat),
 
 strip (strip v (S i)) j = strip (strip v i) (S j).

Lemma strip_sym :
 forall (v : list A) (i j : nat),
 
 strip (strip v i) j = strip (strip v j) i.

Lemma strip_eq :
 forall (v1 v2 : list A) (i : nat), v1 = v2 -> strip v1 i = strip v2 i.

Lemma strip_strip :
 forall (v : list A) (i j : nat),
 
 strip (strip v i) j = strip v (i + j).

Lemma app_trunc_strip :
 forall (v : list A) (i : nat),
 
 trunc v i ++ strip v i = v.

Lemma strip_trunc_i :
 forall (v : list A) (i : nat), strip (trunc v i) i = nil.

Lemma strip_trunc :
 forall (v : list A) (i j : nat),
 
 strip (trunc v i) j = trunc (strip v j) (i - j).

Lemma trunc_strip :
 forall (v : list A) (i j : nat),
 
 trunc (strip v i) j = strip (trunc v (i + j)) i.

Lemma elemlist_is_sublist :
 forall (v : list A) (i : nat),
 
 elemlist v i = sublist v i 1.

Lemma elemlist_cons_S :
 forall (v : list A) (i : nat) (b : A),
 
 elemlist (b :: v) (S i) = elemlist v i.

Lemma elemlist_cons_O :
 forall (v : list A) (b : A),
 
 elemlist (b :: v) 0 = b :: nil.

Lemma elemlist_inv :
 forall (l : list A) (i : nat),
 
 trunc (strip l i) 1 = elemlist l i.

Lemma app_trunc_elemlist :
 forall (v : list A) (i : nat),
 
 S i <= length v -> trunc v i ++ elemlist v i = trunc v (S i).

Lemma length_elemlist :
 forall (l : list A) (i : nat),
 
 i < length l -> length (elemlist l i) = 1.

End Lists_field. *)

Section Lists_replace.
Variable A : Set.

Fixpoint replace (l : list A) : nat -> A -> list A :=
  fun (position : nat) (new : A) =>
  match l return (list A) with
  | nil =>
        nil
  | x :: l' =>
      
      match position return (list A) with
      | O =>
            new :: l'
          
      | S n' => x :: replace l' n' new
      end
  end.

Lemma replace_ok :
 forall (l : list A) (i : nat) (x : A),
 
 i < length l -> elemlist A (replace l i x) i = x :: nil.
simple induction l. simpl in |- *. intros. absurd (i < 0). apply lt_n_O.
exact H.
simple induction i. intros. simpl in |- *.
unfold elemlist in |- *. rewrite strip_O. simpl in |- *. rewrite trunc_O; trivial with arith.
intros. simpl in |- *. clear H0. unfold elemlist in |- *. rewrite strip_cons_S.
rewrite elemlist_inv.
apply H. apply lt_S_n. generalize H1. simpl in |- *. trivial with arith.
Qed.

Lemma replace_keep_others :
 forall (l : list A) (i p : nat) (x : A),
 
 i < length l ->
 p < length l -> i <> p -> elemlist A (replace l p x) i = elemlist A l i.
simple induction l. simpl in |- *. intros. absurd (i < 0). apply lt_n_O.
exact H.
simple induction i.
intros. unfold elemlist in |- *. rewrite elemlist_inv. rewrite elemlist_inv.
generalize H1 H2. elim p. intros. absurd (0 <> 0). unfold not in |- *; auto with arith.
exact H4.
intros. simpl in |- *. rewrite elemlist_cons_O. rewrite elemlist_cons_O. trivial with arith.
simple induction p. intros. simpl in |- *.
rewrite elemlist_cons_S. rewrite elemlist_cons_S. trivial with arith.
intros. clear H1. simpl in |- *. do 2 rewrite elemlist_cons_S.
clear H0. apply H. apply lt_S_n. generalize H2; simpl in |- *; trivial with arith.
apply lt_S_n. generalize H3; simpl in |- *; trivial with arith.
generalize H4. red in |- *. auto with arith.
Qed.

Lemma length_replace :
 forall (l : list A) (p : nat) (x : A),
 
 p < length l -> length (replace l p x) = length l.
simple induction l. simpl in |- *. try trivial with arith.
simple induction p. intros. simpl in |- *. apply eq_S. try trivial with arith.
intros. clear H0. simpl in |- *. rewrite H. try trivial with arith.
auto with arith.
Qed.

Lemma replace_sym :
 forall (l : list A) (p p' : nat) (x x' : A),
 
 p < length l ->
 p' < length l ->
 p <> p' -> replace (replace l p' x') p x = replace (replace l p x) p' x'.
simple induction l. simpl in |- *. trivial with arith.
simple induction p. intros. generalize H1 H2.
elim p'. intros. absurd (0 <> 0); unfold not in |- *; auto with arith.
intros. simpl in |- *. trivial with arith.
simple induction p'. intros. simpl in |- *. trivial with arith.
intros. clear H1. clear H0. simpl in |- *. rewrite H. trivial with arith.
auto with arith.
auto with arith.
red in |- *. auto with arith.
Qed.

Lemma replace_newer :
 forall (l : list A) (p : nat) (x x' : A),
 
 p < length l -> replace (replace l p x) p x' = replace l p x'.
simple induction l. simpl in |- *. trivial with arith.
simple induction p. simpl in |- *. intros. trivial with arith.
intros. clear H0. simpl in |- *. rewrite H. trivial with arith.
auto with arith.
Qed.

End Lists_replace.