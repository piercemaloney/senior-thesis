
Require Export Adder.
(* Adder:
Require Export BV.
Require Export FullAdder.

Definition BV_full_adder_sum :=
  (fix F (l : list bool) : list bool -> bool -> BV :=
     match l with
     | nil =>
         (fix F0 (l0 : list bool) : bool -> BV :=
            match l0 with
            | nil => fun _ : bool => nilbv
            | b :: l1 =>
                fun z : bool =>
                consbv (half_adder_sum b z) (F0 l1 (half_adder_carry b z))
            end)
     | b :: l0 =>
         fun x2 : list bool =>
         match x2 with
         | nil =>
             fun y z : bool =>
             consbv (half_adder_sum y z) (F l0 nil (half_adder_carry y z))
         | b0 :: l1 =>
             fun y z : bool =>
             consbv (full_adder_sum y b0 z)
               (F l0 l1 (full_adder_carry y b0 z))
         end b
     end).
    
Lemma BV_full_adder_sum_eq1 :
 forall b : bool, BV_full_adder_sum nil nil b = nilbv.

Lemma BV_full_adder_sum_eq2 :
 forall (vh : bool) (vt : list bool) (b : bool),
 BV_full_adder_sum nil (vh :: vt) b =
 consbv (half_adder_sum vh b)
   (BV_full_adder_sum nil vt (half_adder_carry vh b)).

Lemma BV_full_adder_sum_eq3 :
 forall (vh : bool) (vt : list bool) (b : bool),
 BV_full_adder_sum (vh :: vt) nil b =
 consbv (half_adder_sum vh b)
   (BV_full_adder_sum vt nil (half_adder_carry vh b)).

Lemma BV_full_adder_sum_eq4 :
 forall (vh : bool) (vt : list bool) (wh : bool) (wt : list bool) (b : bool),
 BV_full_adder_sum (vh :: vt) (wh :: wt) b =
 consbv (full_adder_sum vh wh b)
   (BV_full_adder_sum vt wt (full_adder_carry vh wh b)).

Definition BV_full_adder_carry :=
  (fix F (l : list bool) : list bool -> bool -> bool :=
     match l with
     | nil =>
         (fix F0 (l0 : list bool) : bool -> bool :=
            match l0 with
            | nil => fun z : bool => z
            | b :: l1 => fun z : bool => F0 l1 (half_adder_carry b z)
            end)
     | b :: l0 =>
         fun x2 : list bool =>
         match x2 with
         | nil => fun y z : bool => F l0 nil (half_adder_carry y z)
         | b0 :: l1 => fun y z : bool => F l0 l1 (full_adder_carry y b0 z)
         end b
     end).

Lemma BV_full_adder_carry_eq1 :
 forall b : bool, BV_full_adder_carry nil nil b = b.

Lemma BV_full_adder_carry_eq2 :
 forall (vh : bool) (vt : list bool) (b : bool),
 BV_full_adder_carry nil (vh :: vt) b =
 BV_full_adder_carry nil vt (half_adder_carry vh b).

Lemma BV_full_adder_carry_eq3 :
 forall (vh : bool) (vt : list bool) (b : bool),
 BV_full_adder_carry (vh :: vt) nil b =
 BV_full_adder_carry vt nil (half_adder_carry vh b).

Lemma BV_full_adder_carry_eq4 :
 forall (vh : bool) (vt : list bool) (wh : bool) (wt : list bool) (b : bool),
 BV_full_adder_carry (vh :: vt) (wh :: wt) b =
 BV_full_adder_carry vt wt (full_adder_carry vh wh b).

Definition BV_full_adder (v w : BV) (cin : bool) : BV :=
  appbv (BV_full_adder_sum v w cin)
    (consbv (BV_full_adder_carry v w cin) nilbv).

Hint Unfold BV_full_adder.

Lemma BV_full_adder_sum_v_nil_false :
 forall v : BV, BV_full_adder_sum v nilbv false = v.

Lemma BV_full_adder_carry_v_nil_false :
 forall v : BV, BV_full_adder_carry v nilbv false = false.

Lemma BV_full_adder_sum_sym :
 forall (v w : BV) (cin : bool),
 BV_full_adder_sum v w cin = BV_full_adder_sum w v cin.
				       
Lemma length_BV_full_adder_sum :
 forall (v w : BV) (cin : bool),
 lengthbv v = lengthbv w -> lengthbv (BV_full_adder_sum v w cin) = lengthbv v.

Lemma BV_full_adder_carry_sym :
 forall (v w : BV) (cin : bool),
 BV_full_adder_carry v w cin = BV_full_adder_carry w v cin.

Lemma BV_full_adder_sym :
 forall (v w : BV) (cin : bool),
 BV_full_adder v w cin = BV_full_adder w v cin. *)

Lemma BV_full_adder_nil_true_ok :
 forall v : BV, BV_to_nat (BV_full_adder v nilbv true) = S (BV_to_nat v).
unfold nilbv in |- *. simple induction v; auto with arith. unfold BV_full_adder in |- *. intros.
rewrite BV_full_adder_sum_eq3. rewrite BV_full_adder_carry_eq3.
rewrite (app_eq2 bool). rewrite half_adder_carry_true.
simpl in |- *. elim a. unfold appbv in H. rewrite H. simpl in |- *. auto with arith.
rewrite BV_full_adder_sum_v_nil_false.
rewrite BV_full_adder_carry_v_nil_false. rewrite BV_to_nat_app2.
simpl in |- *. elim mult_n_O. elim plus_n_O. trivial with arith.
Qed.

Lemma BV_full_adder_nil_ok :
 forall (v : BV) (cin : bool),
 BV_to_nat (BV_full_adder v nilbv cin) = BV_to_nat v + bool_to_nat cin.

simple induction v. simple induction cin; auto with arith.
simple induction cin. rewrite BV_full_adder_nil_true_ok. simpl in |- *. auto with arith.
unfold BV_full_adder in |- *. rewrite BV_full_adder_sum_v_nil_false.
rewrite BV_full_adder_carry_v_nil_false. rewrite BV_to_nat_app2.
simpl in |- *. elim mult_n_O. elim plus_n_O. trivial with arith.
Qed.

Theorem BV_full_adder_ok :
 forall (v w : BV) (cin : bool),
 BV_to_nat (BV_full_adder v w cin) =
 BV_to_nat v + BV_to_nat w + bool_to_nat cin.
simple induction v.
intros.
rewrite BV_full_adder_sym.
simpl in |- *.
rewrite BV_full_adder_nil_ok.
auto with arith.

unfold BV_full_adder in |- *.
simple induction w.
simpl in |- *.
intro.
rewrite H.
simpl in |- *.
elim plus_n_O.
elim plus_n_O.
replace
 (BV_to_nat l + bool_to_nat (half_adder_carry a cin) +
  (BV_to_nat l + bool_to_nat (half_adder_carry a cin))) with
 (bool_to_nat (half_adder_carry a cin) + bool_to_nat (half_adder_carry a cin) +
  (BV_to_nat l + BV_to_nat l)).
repeat rewrite plus_assoc.
replace
 (bool_to_nat (half_adder_sum a cin) + bool_to_nat (half_adder_carry a cin) +
  bool_to_nat (half_adder_carry a cin)) with
 (bool_to_nat (half_adder_sum a cin) +
  (bool_to_nat (half_adder_carry a cin) +
   bool_to_nat (half_adder_carry a cin))).
rewrite half_adder_ok.
rewrite (plus_permute2 (bool_to_nat a) (bool_to_nat cin) (BV_to_nat l)).
rewrite
 (plus_permute2 (bool_to_nat a + BV_to_nat l) (bool_to_nat cin) (BV_to_nat l))
 .
trivial with arith.

trivial with arith.

repeat rewrite plus_assoc.
rewrite
 (plus_permute2 (bool_to_nat (half_adder_carry a cin))
    (bool_to_nat (half_adder_carry a cin)) (BV_to_nat l))
 .
rewrite (plus_comm (bool_to_nat (half_adder_carry a cin)) (BV_to_nat l)).
rewrite
 (plus_permute2 (BV_to_nat l + bool_to_nat (half_adder_carry a cin))
    (bool_to_nat (half_adder_carry a cin)) (BV_to_nat l))
 .
trivial with arith.

intros.
simpl in |- *.
rewrite H.
clear H.
elim cin; elim a.
rewrite full_adder_carry_sym1.
rewrite full_adder_carry_true.
rewrite full_adder_sum_sym1.
rewrite full_adder_sum_true.
simpl in |- *.
repeat rewrite plus_n_SO.
elim plus_n_Sm.
elim plus_n_Sm.
simpl in |- *.
elim plus_n_Sm.
repeat rewrite plus_assoc.
rewrite
 (plus_permute2 (bool_to_nat a0 + BV_to_nat l) (BV_to_nat l0) (BV_to_nat l))
 .
rewrite (plus_comm (bool_to_nat a0) (BV_to_nat l)).
rewrite (plus_permute2 (BV_to_nat l) (bool_to_nat a0) (BV_to_nat l)).
trivial with arith.

elim a0.
simpl in |- *.
elim plus_n_Sm.
simpl in |- *.
elim plus_n_O.
elim plus_n_Sm.
elim plus_n_Sm.
elim plus_n_Sm.
elim plus_n_O.
repeat rewrite plus_assoc.
rewrite (plus_permute2 (BV_to_nat l) (BV_to_nat l0) (BV_to_nat l)).
trivial with arith.

simpl in |- *.
repeat rewrite <- plus_n_Sm.
repeat rewrite <- plus_n_O.
repeat rewrite plus_assoc.
try trivial with arith.
rewrite (plus_permute2 (BV_to_nat l) (BV_to_nat l0) (BV_to_nat l)).
try trivial with arith.

elim a0.
simpl in |- *.
repeat rewrite <- plus_n_Sm.
repeat rewrite <- plus_n_O.
repeat rewrite plus_assoc.
simpl in |- *.
rewrite (plus_permute2 (BV_to_nat l) (BV_to_nat l0) (BV_to_nat l)).
trivial with arith.

simpl in |- *.
repeat rewrite <- plus_n_O.
repeat rewrite plus_assoc.
rewrite (plus_permute2 (BV_to_nat l) (BV_to_nat l0) (BV_to_nat l)).
trivial with arith.

elim a0; simpl in |- *; repeat rewrite <- plus_n_Sm;
 repeat rewrite <- plus_n_O; repeat rewrite plus_assoc;
 rewrite (plus_permute2 (BV_to_nat l) (BV_to_nat l0) (BV_to_nat l));
 trivial with arith.

Qed.
