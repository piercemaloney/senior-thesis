
Require Export IncrDecr.
(* IncrDecr:
Require Export AdderProof.

Fixpoint BV_increment (l : list bool) : BV :=
  match l with
  | nil => nilbv
  | false :: v => true :: v
  | true :: v => false :: BV_increment v
  end.

Fixpoint BV_increment_carry (l : list bool) : bool :=
  match l with
  | nil => true
  | false :: v => false
  | true :: v => BV_increment_carry v
  end.

Fixpoint BV_decrement (l : list bool) : BV :=
  match l with
  | nil => nilbv
  | false :: v => true :: BV_decrement v
  | true :: v => false :: v
  end.

Fixpoint BV_decrement_carry (l : list bool) : bool :=
  match l with
  | nil => true
  | false :: v => BV_decrement_carry v
  | true :: v => false
  end.

Lemma length_BV_increment :
 forall v : BV, lengthbv (BV_increment v) = lengthbv v.

Lemma length_BV_decrement :
 forall v : BV, lengthbv (BV_decrement v) = lengthbv v.

Lemma BV_increment_limit :
 forall n : nat,
 BV_increment (list_const bool n true) = list_const bool n false.

Lemma BV_decrement_limit :
 forall n : nat,
 BV_decrement (list_const bool n false) = list_const bool n true.

Lemma BV_increment_limit_carry :
 forall n : nat, BV_increment_carry (list_const bool n true) = true.

Lemma BV_decrement_limit_carry :
 forall n : nat, BV_decrement_carry (list_const bool n false) = true.

Lemma BV_increment_adder :
 forall v : BV,
 appbv (BV_increment v) (consbv (BV_increment_carry v) nilbv) =
 BV_full_adder v nilbv true.

Lemma BV_increment_ok :
 forall v : BV,
 BV_to_nat (appbv (BV_increment v) (consbv (BV_increment_carry v) nilbv)) =
 S (BV_to_nat v).

Lemma BV_decr_incr : forall v : BV, BV_decrement (BV_increment v) = v.

Lemma BV_incr_decr : forall v : BV, BV_increment (BV_decrement v) = v. *)
Require Export Memo.
(* Memo:
Require Export Arith_compl.
Require Export Lists_replace.
Require Export BV.

Definition addr := nat.			       
Definition Memo := list BV.                  
Definition MemoSize := length (A:=BV).            

Definition MemoEmpty (n : nat) (v : BV) : Memo := list_const BV n v.

Definition MemoZone : Memo -> addr -> nat -> Memo := sublist BV.

Definition MemoRead : Memo -> addr -> Memo := elemlist BV.
Definition MemoWrite : Memo -> addr -> BV -> Memo := replace BV.

Definition AddrOK (m : Memo) (a : addr) : Prop := a < MemoSize m.

Definition MMemo (v : BV) : Memo := v :: nil.

Lemma read_write :
 forall (m : Memo) (a : addr) (v : BV),
 AddrOK m a -> MemoRead (MemoWrite m a v) a = MMemo v. *)

Parameter a_size d_size : nat.  

Parameter di_init cx_init al_init : BV.
Parameter mem_init : Memo.

Axiom di_initsize : lengthbv di_init = a_size.
Axiom cx_initsize : lengthbv cx_init = a_size.
Axiom al_initsize : lengthbv al_init = d_size.
Axiom mem_initsize : MemoSize mem_init = a_size.

Fixpoint IsNull (v : BV) : bool :=
  match v return bool with
  | nil => true
  | b :: w =>
      match b return bool with
      | true => false
      | false => IsNull w
      end
  end.

Lemma IsNull_nil : IsNull nilbv = true.
auto.
Qed.

Lemma IsNull_false :
 forall (a : bool) (v : BV), IsNull (consbv a v) = true -> a = false.
simple induction a. simpl in |- *. auto. trivial.
Qed.

Lemma IsNull_cons :
 forall (a : bool) (v : BV), IsNull (consbv a v) = true -> IsNull v = true.
simple induction a. simpl in |- *. intros. absurd (false = true).
auto. exact H. intros v. auto.
Qed.

Lemma IsNull_null : forall n : nat, IsNull (BV_null n) = true.
simple induction n. simpl in |- *. trivial.
intros. simpl in |- *. exact H.
Qed.

Lemma IsNull_BV_null :
 forall v : BV, IsNull v = true -> v = BV_null (lengthbv v).
simple induction v. simpl in |- *. unfold BV_null in |- *. auto.
intros a l H. intro.
change (a :: l = false :: BV_null (lengthbv l)) in |- *.
rewrite <- H. generalize H0. replace a with false. trivial.
symmetry  in |- *. apply IsNull_false with (v := l). exact H0.
apply IsNull_cons with (a := a). exact H0.
Qed.

