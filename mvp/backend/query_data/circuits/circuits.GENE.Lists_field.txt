
Require Import Arith_compl.
(* Arith_compl:
Require Export Plus.
Require Export Mult.
Require Import Minus.
Require Export Lt.
Require Export Le.
Require Export Gt.

Lemma plus_n_SO : forall x : nat, x + 1 = S x.

Lemma plus_permute2 : forall x y z : nat, x + y + z = x + z + y.

Lemma mult_sym : forall a b : nat, a * b = b * a.

Lemma mult_permute : forall a b c : nat, a * b * c = a * c * b.

Lemma plus_O_O : forall n m : nat, n + m = 0 -> n = 0.

Lemma mult_plus_distr2 : forall n m p : nat, n * (m + p) = n * m + n * p.

Fixpoint power2 (n : nat) : nat :=
  match n with
  | O => 1
  | S x => power2 x + power2 x
  end.

Lemma power2_eq2 : forall x : nat, power2 (S x) = power2 x + power2 x.

Lemma power2_plus : forall x y : nat, power2 (x + y) = power2 x * power2 y.

Theorem le_plus_n_m : forall n m : nat, n <= m -> n + n <= m + m.

Theorem lt_plus_n_m : forall n m : nat, n < m -> S (n + n) < m + m.

Lemma le_plus_lem1 : forall a b c : nat, a <= b -> c + a <= c + b.

Lemma le_plus_lem2 : forall a b c : nat, c + a <= c + b -> a <= b.

Lemma gt_double : forall a b : nat, a + a > b + b -> a > b. 

Lemma gt_double_inv : forall a b : nat, a > b -> a + a > b + b.

Lemma gt_double_n_S : forall a b : nat, a > b -> a + a > S (b + b).

Lemma gt_double_S_n : forall a b : nat, a > b -> S (a + a) > b + b.

Lemma minus_le_O : forall a b : nat, a <= b -> a - b = 0.

Lemma minus_n_SO : forall n : nat, n - 1 = pred n.

Lemma minus_le_lem2c : forall a b : nat, a - S b <= a - b.

Lemma minus_le_lem2 : forall a b : nat, a - b <= a.

Lemma minus_minus_lem1 : forall a b : nat, a - b - a = 0.

Lemma minus_minus_lem2 : forall a b : nat, b <= a -> a - (a - b) = b.

Lemma le_minus_minus : forall a b c : nat, c <= b -> a - b <= a - c. *)
Require Export Minus.
Require Export Lists_compl.
(* Lists_compl:
Require Export List.
Require Export Arith_compl.

Section Lists_compl.
Variable A B : Set.

Lemma length_eq1 : length (nil:list A) = 0.
Lemma length_eq2 :
 forall (x : A) (l : list A), length (x :: l) = S (length l).

Lemma app_eq1 : forall l' : list A, nil ++ l' = l'. 
Lemma app_eq2 : forall (x : A) (l l' : list A), (x :: l) ++ l' = x :: l ++ l'.

Inductive len : list A -> nat -> Prop :=
 
  | len_nil : len nil 0
  | len_cons :
      forall (b : A) (v : list A) (l : nat), len v l -> len (b :: v) (S l).
Hint Resolve len_nil len_cons.

Lemma nil_cons : forall (b : A) (v : list A), nil <> b :: v.

Lemma not_cons_eq : forall (v : list A) (b : A), v <> b :: v.

Lemma app_v_nil : forall v : list A, v ++ nil = v.

Lemma app_v_nil_idem : forall v v' : list A, v = v' -> v ++ nil = v'.

Lemma app_v_nil_inv : forall v1 v2 : list A, v1 ++ v2 = v1 -> v2 = nil.

Lemma app_v_nil_sym : forall v1 v2 : list A, v1 = nil -> v1 ++ v2 = v2 ++ v1.

Definition app_assoc_r := app_ass.

Definition app_assoc_l := ass_app.

Lemma len_cons_not_O :
 forall (b : A) (v : list A) (l : nat),
 
 len (b :: v) l -> l <> 0.

Lemma len_nil_inv : forall l : nat, len nil l -> l = 0.

Lemma not_len_nil_Sn : forall l : nat, ~ len nil (S l).

Lemma len_app :
 forall (l1 l2 : nat) (v1 v2 : list A),
 
 len v1 l1 -> len v2 l2 -> len (v1 ++ v2) (l1 + l2).

Lemma len_length : forall v : list A, len v (length v).

Lemma length_eq : forall v1 v2 : list A, v1 = v2 -> length v1 = length v2.

Lemma not_nil : forall v : list A, length v <> 0 -> v <> nil.

Lemma length_app :
 forall v1 v2 : list A,
 
 length (v1 ++ v2) = length v1 + length v2.

Lemma v_not_nil_length :
 forall v : list A,
 
 v <> nil -> 1 <= length v.

Lemma le_SO_length_v :
 forall v : list A,
 
 length v <> 0 -> 1 <= length v.

Fixpoint list_const (n : nat) : A -> list A :=
  
 fun x : A =>
 match n return (list A) with
 | O => nil
 | S n' => x :: list_const n' x
 end.

Lemma list_const_eq1 : forall x : A, list_const 0 x = nil.
Lemma list_const_eq2 :
 forall (n' : nat) (x : A), list_const (S n') x = x :: list_const n' x.

Lemma len_list_const : forall (n : nat) (x : A), len (list_const n x) n.

Lemma length_list_const :
 forall (n : nat) (x : A), length (list_const n x) = n.

Fixpoint rev (l : list A) : list A :=
  
 match l return (list A) with
 | nil => nil
 | b :: l' => rev l' ++ b :: nil
 end.

Lemma rev_eq1 : rev nil = nil.
Lemma rev_eq2 :
 forall (b : A) (l' : list A), rev (b :: l') = rev l' ++ b :: nil.

Lemma rev_eq : forall l n : list A, l = n -> rev l = rev n.

Lemma rev_app : forall l n : list A, rev (l ++ n) = rev n ++ rev l.

Lemma rev_rev : forall l : list A, rev (rev l) = l.

Lemma length_rev : forall l : list A, length (rev l) = length l.

Fixpoint map (l : list A) : (A -> B) -> list B :=
  
 fun f : A -> B =>
 match l return (list B) with
 | nil => nil
 | b :: l' => f b :: map l' f
 end.

Lemma length_map :
 forall (l : list A) (f : A -> B), length (map l f) = length l.

Lemma eq_cons :
 forall (l1 l2 : list A) (a1 a2 : A), a1 :: l1 = a2 :: l2 -> l1 = l2.
Hint Immediate eq_cons.

Lemma not_eq_cons :
 forall (l1 l2 : list A) (a1 a2 : A), l1 <> l2 -> a1 :: l1 <> a2 :: l2.

Axiom eq_list_dec : forall l m : list A, {l = m} + {l <> m}.

End Lists_compl. *)

Section Lists_field.
Variable A : Set.

Fixpoint trunc (v : list A) : nat -> list A :=
  fun n : nat =>
  match v return (list A) with
  | nil => nil
  | b :: w =>
      match n return (list A) with
      | O => nil
      | S p => b :: trunc w p
      end
  end.

Definition strip (v : list A) (n : nat) :=
  rev A (trunc (rev A v) (length v - n)).

Definition sublist (v : list A) (start lengt : nat) :=
  trunc (strip v start) lengt.

Definition elemlist (v : list A) (i : nat) := trunc (strip v i) 1.

Lemma length_trunc :
 forall (v : list A) (i : nat),
 
 i <= length v -> length (trunc v i) = i.
simple induction v. simpl in |- *. auto with arith.
intros b b0 H. simple induction i. simpl in |- *. trivial with arith.
simpl in |- *. intros. apply eq_S. apply H. apply le_S_n. exact H1.
Qed.

Lemma trunc_inv :
 forall (v : list A) (i : nat) (b : A),
 
 b :: trunc v i = trunc (b :: v) (S i).
simpl in |- *. trivial with arith.
Qed.

Lemma trunc_all : forall v : list A, trunc v (length v) = v.

simple induction v. simpl in |- *. trivial with arith.
intros. rewrite length_eq2. simpl in |- *. rewrite H. trivial with arith.
Qed. Hint Resolve trunc_all.

Lemma trunc_max :
 forall (v : list A) (i : nat),
 
 length v <= i -> trunc v i = v.
simple induction v. simpl in |- *. trivial with arith.
intros. inversion H0. rewrite trunc_all. trivial with arith.
simpl in |- *. rewrite H. trivial with arith.
apply le_Sn_le. generalize H1. simpl in |- *. trivial with arith.
Qed.

Lemma trunc_O : forall v : list A, trunc v 0 = nil.

simple induction v; auto with arith.
Qed. Hint Resolve trunc_O.

Lemma le_length_trunc :
 forall (v : list A) (i : nat), length (trunc v i) <= i.

simple induction v. simpl in |- *. auto with arith.
intros. case i. rewrite trunc_O. auto with arith.
intro. simpl in |- *. apply le_n_S. apply H.
Qed. Hint Resolve le_length_trunc.

Lemma trunc_app :
 forall (v1 v2 : list A) (i : nat),
 
 trunc (v1 ++ v2) i = trunc v1 i ++ trunc v2 (i - length v1).
simple induction v1. simpl in |- *. auto with arith.
intros. rewrite app_eq2.
rewrite length_eq2. elim i. simpl in |- *. rewrite trunc_O. trivial with arith.
intros. simpl in |- *. rewrite H. trivial with arith.
Qed. Hint Resolve trunc_app.

Lemma app_v_trunc :
 forall (v1 v2 : list A) (i : nat),
 
 v1 ++ trunc v2 i = trunc (v1 ++ v2) (length v1 + i).
intros. rewrite trunc_app. rewrite (trunc_max v1 (length v1 + i)).
replace (length v1 + i - length v1) with i. trivial with arith. auto with arith.
auto with arith.
Qed.

Lemma trunc_eq :
 forall (v1 v2 : list A) (i : nat), v1 = v2 -> trunc v1 i = trunc v2 i.

intros. rewrite H. trivial with arith.
Qed. Hint Resolve trunc_eq.

Lemma trunc_sym :
 forall (v : list A) (i j : nat), 
 
 trunc (trunc v i) j = trunc (trunc v j) i.
simple induction v. simpl in |- *. trivial with arith.
simple induction i; simple induction j. trivial with arith.
repeat rewrite trunc_O. simpl in |- *. trivial with arith.
repeat rewrite trunc_O. simpl in |- *. trivial with arith.
intros. simpl in |- *. rewrite H. trivial with arith.
Qed.

Lemma trunc_trunc1 :
 forall (v : list A) (i : nat),
 
 trunc (trunc v i) i = trunc v i.
simple induction v. simpl in |- *. trivial with arith.
simple induction i. repeat rewrite trunc_O. trivial with arith.
intros. simpl in |- *. rewrite H. trivial with arith.
Qed. Hint Resolve trunc_trunc1.

Lemma trunc_trunc2 :
 forall (v : list A) (i j : nat),
 
 i <= j -> trunc (trunc v i) j = trunc v i.
intros. rewrite (trunc_max (trunc v i) j). trivial with arith.
apply le_trans with i. apply le_length_trunc. exact H.
Qed.

Lemma trunc_trunc3 :
 forall (v : list A) (i j : nat),
 
 j <= i -> trunc (trunc v i) j = trunc v j.
intros. rewrite <- (trunc_max (trunc v j) i). rewrite trunc_sym. trivial with arith.
apply le_trans with j. apply le_length_trunc.
exact H.
Qed.

Lemma trunc_plus_petit :
 forall (v1 v2 : list A) (i j : nat),
 
 j <= i -> trunc v1 i = v2 -> trunc v1 j = trunc v2 j.
intros. rewrite <- H0. rewrite trunc_trunc3. trivial with arith. exact H.
Qed.

Lemma strip_nil : forall i : nat, strip nil i = nil.

intro. auto with arith.
Qed. Hint Resolve strip_nil.

Lemma strip_cons_S :
 forall (v : list A) (i : nat) (b : A),
 
 strip (b :: v) (S i) = strip v i.
unfold strip in |- *. simple induction i. simpl in |- *.
elim minus_n_O. intro. replace (length v) with (length (rev A v)).
rewrite trunc_all. rewrite trunc_app. rewrite trunc_all.
elim minus_n_n. rewrite trunc_O. rewrite app_v_nil. trivial with arith.
apply length_rev.
intros. apply rev_eq. simpl in |- *.
rewrite trunc_app. rewrite length_rev. rewrite minus_minus_lem1.
rewrite trunc_O. rewrite app_v_nil. trivial with arith.
Qed. Hint Resolve strip_cons_S.

Lemma length_strip :
 forall (v : list A) (i : nat),
 
 i <= length v -> length (strip v i) = length v - i.
unfold strip in |- *. intros. rewrite length_rev. rewrite length_trunc. trivial with arith.
rewrite length_rev. apply minus_le_lem2.
Qed.

Lemma le_length_strip :
 forall (v : list A) (i : nat),
 
 length (strip v i) <= length v - i.
unfold strip in |- *. intros. rewrite length_rev. apply le_length_trunc.
Qed.

Lemma strip_inv :
 forall (v : list A) (i : nat),
 
 rev A (trunc (rev A v) (length v - i)) = strip v i.
unfold strip in |- *. trivial with arith.
Qed.

Lemma strip_all : forall v : list A, strip v (length v) = nil.

unfold strip in |- *. intro. rewrite <- minus_n_n. rewrite trunc_O. auto with arith.
Qed. Hint Resolve strip_all.

Lemma strip_max :
 forall (v : list A) (i : nat),
 
 length v <= i -> strip v i = nil.
unfold strip in |- *. intros. rewrite <- rev_eq1.
apply rev_eq. rewrite <- length_rev. rewrite minus_le_O. auto with arith.
rewrite length_rev. exact H.
Qed.

Lemma strip_O : forall v : list A, strip v 0 = v.

intro. unfold strip in |- *. rewrite <- minus_n_O. rewrite <- length_rev.
rewrite trunc_all. rewrite rev_rev. trivial with arith.
Qed. Hint Resolve strip_O.

Lemma strip_app :
 forall (v1 v2 : list A) (i : nat),
 
 strip (v1 ++ v2) i = strip v1 i ++ strip v2 (i - length v1).
simple induction v1. simpl in |- *. intros. elim minus_n_O. trivial with arith.
simple induction v2. intro. simpl in |- *.
rewrite strip_nil. rewrite app_v_nil. rewrite app_v_nil. trivial with arith.
simple induction i.
rewrite strip_O. simpl in |- *. rewrite strip_O. rewrite strip_O. auto with arith.
intros. rewrite app_eq2. rewrite strip_cons_S.
rewrite strip_cons_S. rewrite length_eq2. simpl in |- *. apply H.
Qed.

Lemma strip_strip_S :
 forall (v : list A) (i j : nat),
 
 strip (strip v (S i)) j = strip (strip v i) (S j).
simple induction v. intros. rewrite strip_nil. rewrite strip_nil. trivial with arith.
simple induction i. intros. rewrite strip_O.
do 2 rewrite strip_cons_S. rewrite strip_O. trivial with arith.
simple induction j. rewrite strip_O.
repeat rewrite strip_cons_S. elim n. rewrite strip_O. trivial with arith.
intros. rewrite <- H. rewrite strip_O. trivial with arith.
intros. do 2 rewrite strip_cons_S. apply H.
Qed.

Lemma strip_sym :
 forall (v : list A) (i j : nat),
 
 strip (strip v i) j = strip (strip v j) i.
simple induction v. intros. rewrite strip_nil. rewrite strip_nil. trivial with arith.
simple induction i. intro. rewrite strip_O. rewrite strip_O. trivial with arith.
simple induction j. rewrite strip_O. rewrite strip_O. try trivial with arith.
intros. rewrite strip_cons_S. rewrite strip_cons_S.
replace (strip (strip l n) (S n0)) with (strip (strip l (S n)) n0).
apply H. apply strip_strip_S.
Qed.

Lemma strip_eq :
 forall (v1 v2 : list A) (i : nat), v1 = v2 -> strip v1 i = strip v2 i.

intros. rewrite H. trivial with arith.
Qed. Hint Resolve strip_eq.

Lemma strip_strip :
 forall (v : list A) (i j : nat),
 
 strip (strip v i) j = strip v (i + j).
simple induction v. intros. rewrite strip_nil. rewrite strip_nil. trivial with arith.
simple induction i. intro. simpl in |- *. rewrite strip_O. trivial with arith.
simple induction j. rewrite strip_O. elim plus_n_O. trivial with arith.
intros. rewrite strip_cons_S. simpl in |- *. rewrite strip_cons_S. apply H.
Qed. Hint Resolve strip_strip.

Lemma app_trunc_strip :
 forall (v : list A) (i : nat),
 
 trunc v i ++ strip v i = v.
simple induction v. unfold strip in |- *. simpl in |- *. trivial with arith.
intros. elim i. rewrite trunc_O. rewrite strip_O. simpl in |- *. trivial with arith.
intros. unfold strip in |- *. simpl in |- *.
rewrite trunc_app. rewrite rev_app. rewrite length_rev.
case n. rewrite <- minus_n_O.
rewrite <- minus_n_n. rewrite trunc_O. rewrite trunc_O. simpl in |- *.
rewrite <- length_rev. rewrite trunc_all. rewrite rev_rev. trivial with arith.
intro. replace (length l - S n0 - length l) with 0.
rewrite trunc_O. simpl in |- *.
replace (rev A (trunc (rev A l) (length l - S n0))) with (strip l (S n0)).
rewrite H. trivial with arith.
unfold strip in |- *. trivial with arith.
rewrite minus_minus_lem1. trivial with arith.
Qed.

Lemma strip_trunc_i :
 forall (v : list A) (i : nat), strip (trunc v i) i = nil.

simple induction v. auto with arith.
simple induction i. auto with arith.
intros. simpl in |- *. rewrite strip_cons_S. apply H.
Qed. Hint Resolve strip_trunc_i.

Lemma strip_trunc :
 forall (v : list A) (i j : nat),
 
 strip (trunc v i) j = trunc (strip v j) (i - j).
simple induction v. simpl in |- *. unfold strip in |- *. simpl in |- *. trivial with arith.
simple induction i; simple induction j.
simpl in |- *. rewrite strip_O. rewrite trunc_O. trivial with arith.
rewrite trunc_O.
simpl in |- *. intros. unfold strip in |- *. simpl in |- *. rewrite trunc_O. trivial with arith.
rewrite strip_O. rewrite strip_O. elim minus_n_O. trivial with arith.
intros. rewrite strip_cons_S. simpl in |- *. rewrite strip_cons_S. apply H.
Qed.

Lemma trunc_strip :
 forall (v : list A) (i j : nat),
 
 trunc (strip v i) j = strip (trunc v (i + j)) i.
simple induction v. unfold strip in |- *. simpl in |- *. trivial with arith.
simple induction i; simple induction j. rewrite trunc_O. rewrite strip_O. auto with arith.
intros. rewrite strip_O. rewrite strip_O. auto with arith.
rewrite trunc_O. elim plus_n_O. rewrite strip_trunc_i. trivial with arith.
intros.
rewrite strip_cons_S. replace (S n + S n0) with (S (n + S n0)).
simpl in |- *. rewrite strip_cons_S. apply H.
auto with arith.
Qed.

Lemma elemlist_is_sublist :
 forall (v : list A) (i : nat),
 
 elemlist v i = sublist v i 1.
unfold elemlist, sublist in |- *. trivial with arith.
Qed.

Lemma elemlist_cons_S :
 forall (v : list A) (i : nat) (b : A),
 
 elemlist (b :: v) (S i) = elemlist v i.
unfold elemlist in |- *. intros. rewrite strip_cons_S. trivial with arith.
Qed.

Lemma elemlist_cons_O :
 forall (v : list A) (b : A),
 
 elemlist (b :: v) 0 = b :: nil.
intros.
unfold elemlist in |- *. rewrite strip_O. simpl in |- *. rewrite trunc_O. trivial with arith.
Qed.

Lemma elemlist_inv :
 forall (l : list A) (i : nat),
 
 trunc (strip l i) 1 = elemlist l i.
unfold elemlist in |- *. trivial with arith.
Qed.

Lemma app_trunc_elemlist :
 forall (v : list A) (i : nat),
 
 S i <= length v -> trunc v i ++ elemlist v i = trunc v (S i).
simple induction v. unfold elemlist in |- *. simpl in |- *. trivial with arith.
simple induction i. simpl in |- *. unfold elemlist in |- *. rewrite trunc_O.
rewrite strip_O. simpl in |- *. rewrite trunc_O. trivial with arith.
intros. simpl in |- *. unfold elemlist in |- *.
rewrite strip_cons_S. unfold elemlist in H. rewrite H. trivial with arith.
generalize H1. simpl in |- *. auto with arith.
Qed.

Lemma length_elemlist :
 forall (l : list A) (i : nat),
 
 i < length l -> length (elemlist l i) = 1.
intros. unfold elemlist in |- *. rewrite length_trunc. trivial with arith.
rewrite length_strip. inversion H. rewrite <- minus_Sn_m. auto with arith. auto with arith.
rewrite <- minus_Sn_m. auto with arith. apply le_Sn_le. exact H1. apply lt_le_weak. exact H.
Qed.

End Lists_field.