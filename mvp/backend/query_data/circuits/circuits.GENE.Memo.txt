
Require Export Arith_compl.
(* Arith_compl:
Require Export Plus.
Require Export Mult.
Require Import Minus.
Require Export Lt.
Require Export Le.
Require Export Gt.

Lemma plus_n_SO : forall x : nat, x + 1 = S x.

Lemma plus_permute2 : forall x y z : nat, x + y + z = x + z + y.

Lemma mult_sym : forall a b : nat, a * b = b * a.

Lemma mult_permute : forall a b c : nat, a * b * c = a * c * b.

Lemma plus_O_O : forall n m : nat, n + m = 0 -> n = 0.

Lemma mult_plus_distr2 : forall n m p : nat, n * (m + p) = n * m + n * p.

Fixpoint power2 (n : nat) : nat :=
  match n with
  | O => 1
  | S x => power2 x + power2 x
  end.

Lemma power2_eq2 : forall x : nat, power2 (S x) = power2 x + power2 x.

Lemma power2_plus : forall x y : nat, power2 (x + y) = power2 x * power2 y.

Theorem le_plus_n_m : forall n m : nat, n <= m -> n + n <= m + m.

Theorem lt_plus_n_m : forall n m : nat, n < m -> S (n + n) < m + m.

Lemma le_plus_lem1 : forall a b c : nat, a <= b -> c + a <= c + b.

Lemma le_plus_lem2 : forall a b c : nat, c + a <= c + b -> a <= b.

Lemma gt_double : forall a b : nat, a + a > b + b -> a > b. 

Lemma gt_double_inv : forall a b : nat, a > b -> a + a > b + b.

Lemma gt_double_n_S : forall a b : nat, a > b -> a + a > S (b + b).

Lemma gt_double_S_n : forall a b : nat, a > b -> S (a + a) > b + b.

Lemma minus_le_O : forall a b : nat, a <= b -> a - b = 0.

Lemma minus_n_SO : forall n : nat, n - 1 = pred n.

Lemma minus_le_lem2c : forall a b : nat, a - S b <= a - b.

Lemma minus_le_lem2 : forall a b : nat, a - b <= a.

Lemma minus_minus_lem1 : forall a b : nat, a - b - a = 0.

Lemma minus_minus_lem2 : forall a b : nat, b <= a -> a - (a - b) = b.

Lemma le_minus_minus : forall a b c : nat, c <= b -> a - b <= a - c. *)
Require Export Lists_replace.
(* Lists_replace:
Require Export Lists_field.

Section Lists_replace.
Variable A : Set.

Fixpoint replace (l : list A) : nat -> A -> list A :=
  fun (position : nat) (new : A) =>
  match l return (list A) with
  | nil =>
        nil
  | x :: l' =>
      
      match position return (list A) with
      | O =>
            new :: l'
          
      | S n' => x :: replace l' n' new
      end
  end.

Lemma replace_ok :
 forall (l : list A) (i : nat) (x : A),
 
 i < length l -> elemlist A (replace l i x) i = x :: nil.

Lemma replace_keep_others :
 forall (l : list A) (i p : nat) (x : A),
 
 i < length l ->
 p < length l -> i <> p -> elemlist A (replace l p x) i = elemlist A l i.

Lemma length_replace :
 forall (l : list A) (p : nat) (x : A),
 
 p < length l -> length (replace l p x) = length l.

Lemma replace_sym :
 forall (l : list A) (p p' : nat) (x x' : A),
 
 p < length l ->
 p' < length l ->
 p <> p' -> replace (replace l p' x') p x = replace (replace l p x) p' x'.

Lemma replace_newer :
 forall (l : list A) (p : nat) (x x' : A),
 
 p < length l -> replace (replace l p x) p x' = replace l p x'.

End Lists_replace. *)
Require Export BV.
(* BV:
Require Export Arith_compl.
Require Export Bool_compl.
Require Export Lists_replace.

Definition BV := list bool.
Definition nilbv : BV := nil.
Definition consbv : bool -> BV -> BV := cons (A:=bool).
Definition appbv : BV -> BV -> BV := app (A:=bool).
Definition lengthbv : BV -> nat := length (A:=bool).
Definition lenbv : BV -> nat -> Prop := len bool.
Definition BV_null (n : nat) : BV := list_const bool n false.
Definition truncbv : BV -> nat -> BV := trunc bool.
Definition stripbv : BV -> nat -> BV := strip bool.
Definition field : BV -> nat -> nat -> BV := sublist bool.
Definition abit : BV -> nat -> BV := elemlist bool.
Definition bitset : BV -> nat -> bool -> BV := replace bool.
Definition BVnot (v : BV) : BV := map bool bool v negb.

Fixpoint BV_to_nat (v : BV) : nat :=
  match v return nat with
  | nil => 0
  | b :: w => bool_to_nat b + (BV_to_nat w + BV_to_nat w)
  end.

Lemma BV_to_nat_eq1 : BV_to_nat nilbv = 0.
Lemma BV_to_nat_eq2 :
 forall (b : bool) (w : BV),
 BV_to_nat (consbv b w) = bool_to_nat b + (BV_to_nat w + BV_to_nat w).

Lemma BV_to_nat_app :
 forall (l n : BV) (ll : nat),
 
 lenbv l ll -> BV_to_nat (appbv l n) = BV_to_nat l + power2 ll * BV_to_nat n.

Lemma BV_to_nat_app2 :
 forall l n : BV,
 
 BV_to_nat (appbv l n) = BV_to_nat l + power2 (lengthbv l) * BV_to_nat n.

Lemma BV_null_nat : forall n : nat, BV_to_nat (BV_null n) = 0.

Lemma length_BV_null : forall n : nat, lengthbv (BV_null n) = n. *)

Definition addr := nat.			       
Definition Memo := list BV.                  
Definition MemoSize := length (A:=BV).            

Definition MemoEmpty (n : nat) (v : BV) : Memo := list_const BV n v.

Definition MemoZone : Memo -> addr -> nat -> Memo := sublist BV.

Definition MemoRead : Memo -> addr -> Memo := elemlist BV.
Definition MemoWrite : Memo -> addr -> BV -> Memo := replace BV.

Definition AddrOK (m : Memo) (a : addr) : Prop := a < MemoSize m.

Definition MMemo (v : BV) : Memo := v :: nil.

Lemma read_write :
 forall (m : Memo) (a : addr) (v : BV),
 AddrOK m a -> MemoRead (MemoWrite m a v) a = MMemo v.
unfold Memo, AddrOK, MemoRead, MemoWrite, MMemo in |- *.
unfold MemoSize in |- *. intros. apply replace_ok; auto.
Qed.

