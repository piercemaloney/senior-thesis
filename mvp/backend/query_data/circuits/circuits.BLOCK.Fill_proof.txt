

Require Import Fill_spec.
(* Fill_spec:
Require Export Fill_defs.

Fixpoint di (st : nat) : BV -> BV -> BV -> Memo -> BV :=
  fun (di0 cx0 al0 : BV) (mem0 : Memo) =>
  match st return BV with
  | O => di0
  | S t =>
      match IsNull (cx t di0 cx0 al0 mem0) return BV with
      | true => di t di0 cx0 al0 mem0
      | false => BV_increment (di t di0 cx0 al0 mem0)
      end
  end
 
 with cx (st : nat) : BV -> BV -> BV -> Memo -> BV :=
  fun (di0 cx0 al0 : BV) (mem0 : Memo) =>
  match st return BV with
  | O => cx0
  | S t =>
      match IsNull (cx t di0 cx0 al0 mem0) return BV with
      | true => cx t di0 cx0 al0 mem0
      | false => BV_decrement (cx t di0 cx0 al0 mem0)
      end
  end
 
 with al (st : nat) : BV -> BV -> BV -> Memo -> BV :=
  fun (di0 cx0 al0 : BV) (mem0 : Memo) =>
  match st return BV with
  | O => al0
  | S t =>
      match IsNull (cx t di0 cx0 al0 mem0) return BV with
      | true => al t di0 cx0 al0 mem0
      | false => al t di0 cx0 al0 mem0
      end
  end
 
 with mem (st : nat) : BV -> BV -> BV -> Memo -> Memo :=
  fun (di0 cx0 al0 : BV) (mem0 : Memo) =>
  match st return Memo with
  | O => mem0
  | S t =>
      match IsNull (cx t di0 cx0 al0 mem0) return Memo with
      | true => mem t di0 cx0 al0 mem0
      | false =>
          MemoWrite (mem t di0 cx0 al0 mem0)
            (BV_to_nat (di t di0 cx0 al0 mem0)) (al t di0 cx0 al0 mem0)
      end
  end.

Lemma di_t :
 forall (t : nat) (di0 cx0 al0 : BV) (mem0 : Memo),
 di (S t) di0 cx0 al0 mem0 =
 match IsNull (cx t di0 cx0 al0 mem0) return BV with
 | true => di t di0 cx0 al0 mem0
 | false => BV_increment (di t di0 cx0 al0 mem0)
 end.

Lemma cx_t :
 forall (t : nat) (di0 cx0 al0 : BV) (mem0 : Memo),
 cx (S t) di0 cx0 al0 mem0 =
 match IsNull (cx t di0 cx0 al0 mem0) return BV with
 | true => cx t di0 cx0 al0 mem0
 | false => BV_decrement (cx t di0 cx0 al0 mem0)
 end.

Lemma al_t :
 forall (t : nat) (di0 cx0 al0 : BV) (mem0 : Memo),
 al (S t) di0 cx0 al0 mem0 =
 match IsNull (cx t di0 cx0 al0 mem0) return BV with
 | true => al t di0 cx0 al0 mem0
 | false => al t di0 cx0 al0 mem0
 end.

Lemma al_constant :
 forall (t : nat) (di0 cx0 al0 : BV) (mem0 : Memo),
 al t di0 cx0 al0 mem0 = al0.

Lemma mem_t :
 forall (t : nat) (di0 cx0 al0 : BV) (mem0 : Memo),
 mem (S t) di0 cx0 al0 mem0 =
 match IsNull (cx t di0 cx0 al0 mem0) return Memo with
 | true => mem t di0 cx0 al0 mem0
 | false =>
     MemoWrite (mem t di0 cx0 al0 mem0) (BV_to_nat (di t di0 cx0 al0 mem0))
       (al t di0 cx0 al0 mem0)
 end.

Lemma length_di :
 forall t : nat, lengthbv (di t di_init cx_init al_init mem_init) = a_size.

Lemma length_cx :
 forall t : nat, lengthbv (cx t di_init cx_init al_init mem_init) = a_size.

Lemma length_al :
 forall t : nat, lengthbv (al t di_init cx_init al_init mem_init) = d_size. *)

Require Import Fill_impl.
(* Fill_impl:
Require Export Fill_defs.

Definition di1 (di0 cx0 al0 : BV) (mem0 : Memo) (ad0 da0 : BV) := di0.
Definition cx1 (di0 cx0 al0 : BV) (mem0 : Memo) (ad0 da0 : BV) := cx0.
Definition al1 (di0 cx0 al0 : BV) (mem0 : Memo) (ad0 da0 : BV) := al0.
Definition mem1 (di0 cx0 al0 : BV) (mem0 : Memo) (ad0 da0 : BV) := mem0.
Definition ad1 (di0 cx0 al0 : BV) (mem0 : Memo) (ad0 da0 : BV) := di0.
Definition da1 (di0 cx0 al0 : BV) (mem0 : Memo) (ad0 da0 : BV) := al0.

Fixpoint di2 (st : nat) : BV -> BV -> BV -> Memo -> BV -> BV -> BV :=
  fun (di0 cx0 al0 : BV) (mem0 : Memo) (ad0 da0 : BV) =>
  match st return BV with
  | O => di0
  | S t =>
      match IsNull (cx2 t di0 cx0 al0 mem0 ad0 da0) return BV with
      | true => di2 t di0 cx0 al0 mem0 ad0 da0
      | false => di2 t di0 cx0 al0 mem0 ad0 da0
      end
  end
 
 with cx2 (st : nat) : BV -> BV -> BV -> Memo -> BV -> BV -> BV :=
  fun (di0 cx0 al0 : BV) (mem0 : Memo) (ad0 da0 : BV) =>
  match st return BV with
  | O => cx0
  | S t =>
      match IsNull (cx2 t di0 cx0 al0 mem0 ad0 da0) return BV with
      | true => cx2 t di0 cx0 al0 mem0 ad0 da0
      | false => BV_decrement (cx2 t di0 cx0 al0 mem0 ad0 da0)
      end
  end
 
 with al2 (st : nat) : BV -> BV -> BV -> Memo -> BV -> BV -> BV :=
  fun (di0 cx0 al0 : BV) (mem0 : Memo) (ad0 da0 : BV) =>
  match st return BV with
  | O => al0
  | S t =>
      match IsNull (cx2 t di0 cx0 al0 mem0 ad0 da0) return BV with
      | true => al2 t di0 cx0 al0 mem0 ad0 da0
      | false => al2 t di0 cx0 al0 mem0 ad0 da0
      end
  end
 
 with mem2 (st : nat) : BV -> BV -> BV -> Memo -> BV -> BV -> Memo :=
  fun (di0 cx0 al0 : BV) (mem0 : Memo) (ad0 da0 : BV) =>
  match st return Memo with
  | O => mem0
  | S t =>
      match IsNull (cx2 t di0 cx0 al0 mem0 ad0 da0) return Memo with
      | true => mem2 t di0 cx0 al0 mem0 ad0 da0
      | false =>
          MemoWrite (mem2 t di0 cx0 al0 mem0 ad0 da0)
            (BV_to_nat (ad2 t di0 cx0 al0 mem0 ad0 da0))
            (da2 t di0 cx0 al0 mem0 ad0 da0)
      end
  end
 
 with ad2 (st : nat) : BV -> BV -> BV -> Memo -> BV -> BV -> BV :=
  fun (di0 cx0 al0 : BV) (mem0 : Memo) (ad0 da0 : BV) =>
  match st return BV with
  | O => ad0
  | S t =>
      match IsNull (cx2 t di0 cx0 al0 mem0 ad0 da0) return BV with
      | true => ad2 t di0 cx0 al0 mem0 ad0 da0
      | false => BV_increment (ad2 t di0 cx0 al0 mem0 ad0 da0)
      end
  end
 
 with da2 (st : nat) : BV -> BV -> BV -> Memo -> BV -> BV -> BV :=
  fun (di0 cx0 al0 : BV) (mem0 : Memo) (ad0 da0 : BV) =>
  match st return BV with
  | O => da0
  | S t =>
      match IsNull (cx2 t di0 cx0 al0 mem0 ad0 da0) return BV with
      | true => da2 t di0 cx0 al0 mem0 ad0 da0
      | false => da2 t di0 cx0 al0 mem0 ad0 da0
      end
  end.

Lemma di2_t :
 forall (t : nat) (di0 cx0 al0 : BV) (mem0 : Memo) (ad0 da0 : BV),
 di2 (S t) di0 cx0 al0 mem0 ad0 da0 =
 match IsNull (cx2 t di0 cx0 al0 mem0 ad0 da0) return BV with
 | true => di2 t di0 cx0 al0 mem0 ad0 da0
 | false => di2 t di0 cx0 al0 mem0 ad0 da0
 end.

Lemma di2_constant :
 forall (t : nat) (di0 cx0 al0 : BV) (mem0 : Memo) (ad0 da0 : BV),
 di2 t di0 cx0 al0 mem0 ad0 da0 = di0.

Lemma cx2_t :
 forall (t : nat) (di0 cx0 al0 : BV) (mem0 : Memo) (ad0 da0 : BV),
 cx2 (S t) di0 cx0 al0 mem0 ad0 da0 =
 match IsNull (cx2 t di0 cx0 al0 mem0 ad0 da0) return BV with
 | true => cx2 t di0 cx0 al0 mem0 ad0 da0
 | false => BV_decrement (cx2 t di0 cx0 al0 mem0 ad0 da0)
 end.

Lemma al2_t :
 forall (t : nat) (di0 cx0 al0 : BV) (mem0 : Memo) (ad0 da0 : BV),
 al2 (S t) di0 cx0 al0 mem0 ad0 da0 =
 match IsNull (cx2 t di0 cx0 al0 mem0 ad0 da0) return BV with
 | true => al2 t di0 cx0 al0 mem0 ad0 da0
 | false => al2 t di0 cx0 al0 mem0 ad0 da0
 end.

Lemma al2_constant :
 forall (t : nat) (di0 cx0 al0 : BV) (mem0 : Memo) (ad0 da0 : BV),
 al2 t di0 cx0 al0 mem0 ad0 da0 = al0.

Lemma mem2_t :
 forall (t : nat) (di0 cx0 al0 : BV) (mem0 : Memo) (ad0 da0 : BV),
 mem2 (S t) di0 cx0 al0 mem0 ad0 da0 =
 match IsNull (cx2 t di0 cx0 al0 mem0 ad0 da0) return Memo with
 | true => mem2 t di0 cx0 al0 mem0 ad0 da0
 | false =>
     MemoWrite (mem2 t di0 cx0 al0 mem0 ad0 da0)
       (BV_to_nat (ad2 t di0 cx0 al0 mem0 ad0 da0))
       (da2 t di0 cx0 al0 mem0 ad0 da0)
 end.

Lemma ad2_t :
 forall (t : nat) (di0 cx0 al0 : BV) (mem0 : Memo) (ad0 da0 : BV),
 ad2 (S t) di0 cx0 al0 mem0 ad0 da0 =
 match IsNull (cx2 t di0 cx0 al0 mem0 ad0 da0) return BV with
 | true => ad2 t di0 cx0 al0 mem0 ad0 da0
 | false => BV_increment (ad2 t di0 cx0 al0 mem0 ad0 da0)
 end.

Lemma da2_t :
 forall (t : nat) (di0 cx0 al0 : BV) (mem0 : Memo) (ad0 da0 : BV),
 da2 (S t) di0 cx0 al0 mem0 ad0 da0 =
 match IsNull (cx2 t di0 cx0 al0 mem0 ad0 da0) return BV with
 | true => da2 t di0 cx0 al0 mem0 ad0 da0
 | false => da2 t di0 cx0 al0 mem0 ad0 da0
 end.

Lemma da2_constant :
 forall (t : nat) (di0 cx0 al0 : BV) (mem0 : Memo) (ad0 da0 : BV),
 da2 t di0 cx0 al0 mem0 ad0 da0 = da0.

Definition di3 (di0 cx0 al0 : BV) (mem0 : Memo) (ad0 da0 : BV) := ad0.
Definition cx3 (di0 cx0 al0 : BV) (mem0 : Memo) (ad0 da0 : BV) := cx0.
Definition al3 (di0 cx0 al0 : BV) (mem0 : Memo) (ad0 da0 : BV) := al0.
Definition mem3 (di0 cx0 al0 : BV) (mem0 : Memo) (ad0 da0 : BV) := mem0.
Definition ad3 (di0 cx0 al0 : BV) (mem0 : Memo) (ad0 da0 : BV) := ad0.
Definition da3 (di0 cx0 al0 : BV) (mem0 : Memo) (ad0 da0 : BV) := da0.

Definition compo_2_1 (X : Set)
  (f : nat -> BV -> BV -> BV -> Memo -> BV -> BV -> X) 
  (t : nat) (di0 cx0 al0 : BV) (mem0 : Memo) (ad0 da0 : BV) :=
  f t (di1 di0 cx0 al0 mem0 ad0 da0) (cx1 di0 cx0 al0 mem0 ad0 da0)
    (al1 di0 cx0 al0 mem0 ad0 da0) (mem1 di0 cx0 al0 mem0 ad0 da0)
    (ad1 di0 cx0 al0 mem0 ad0 da0) (da1 di0 cx0 al0 mem0 ad0 da0).

Definition di_2_1 := compo_2_1 BV di2.
Definition cx_2_1 := compo_2_1 BV cx2.
Definition al_2_1 := compo_2_1 BV al2.
Definition mem_2_1 := compo_2_1 Memo mem2.
Definition ad_2_1 := compo_2_1 BV ad2.
Definition da_2_1 := compo_2_1 BV da2.

Definition compo' (X : Set) (f : BV -> BV -> BV -> Memo -> BV -> BV -> X)
  (t : nat) (di0 cx0 al0 : BV) (mem0 : Memo) (ad0 da0 : BV) :=
  f (di_2_1 t di0 cx0 al0 mem0 ad0 da0) (cx_2_1 t di0 cx0 al0 mem0 ad0 da0)
    (al_2_1 t di0 cx0 al0 mem0 ad0 da0) (mem_2_1 t di0 cx0 al0 mem0 ad0 da0)
    (ad_2_1 t di0 cx0 al0 mem0 ad0 da0) (da_2_1 t di0 cx0 al0 mem0 ad0 da0).

Definition di' := compo' BV di3.
Definition cx' := compo' BV cx3.
Definition al' := compo' BV al3.
Definition mem' := compo' Memo mem3.
Definition ad' := compo' BV ad3.
Definition da' := compo' BV da3. *)



Parameter DC_a : BV.	Axiom DC_asize : lengthbv DC_a = a_size.

Parameter DC_d : BV.	Axiom DC_dsize : lengthbv DC_d = d_size.



Lemma cx_cx' :

 forall t : nat,

 cx t di_init cx_init al_init mem_init =

 cx' t di_init cx_init al_init mem_init DC_a DC_d.

unfold cx' in |- *. unfold compo' in |- *. unfold cx3 in |- *. unfold cx_2_1, compo_2_1 in |- *.

unfold di1, cx1, al1, mem1, ad1, da1 in |- *. simple induction t. auto.

intros. rewrite cx_t. rewrite cx2_t. rewrite H. trivial.

Qed.



Lemma di_di' :

 forall t : nat,

 di t di_init cx_init al_init mem_init =

 di' t di_init cx_init al_init mem_init DC_a DC_d.

unfold di' in |- *. unfold compo' in |- *.

unfold di3 in |- *. unfold ad_2_1, compo_2_1 in |- *. unfold di1, cx1, al1, mem1, ad1, da1 in |- *.

simple induction t. auto.

intros. rewrite di_t. rewrite ad2_t. rewrite H.

replace (cx n di_init cx_init al_init mem_init) with

 (cx' n di_init cx_init al_init mem_init DC_a DC_d).

unfold cx', compo' in |- *. unfold cx3 in |- *. unfold cx_2_1, compo_2_1 in |- *.

unfold di1, cx1, al1, mem1, ad1, da1 in |- *.

trivial. rewrite cx_cx'. trivial.

Qed.



Lemma al_al' :

 forall t : nat,

 al t di_init cx_init al_init mem_init =

 al' t di_init cx_init al_init mem_init DC_a DC_d.

intro.

rewrite al_constant.

unfold al' in |- *.

unfold compo' in |- *.

unfold al3 in |- *.

unfold al_2_1 in |- *.

unfold compo_2_1 in |- *.

rewrite al2_constant.

unfold al1 in |- *.

trivial.

Qed.



Lemma mem_mem' :

 forall t : nat,

 mem t di_init cx_init al_init mem_init =

 mem' t di_init cx_init al_init mem_init DC_a DC_d.

unfold mem', compo' in |- *.

unfold mem3 in |- *.

unfold mem_2_1, compo_2_1 in |- *.

unfold di1, cx1, al1, mem1, ad1, da1 in |- *.

simple induction t.

auto.



intros.

rewrite mem2_t.

rewrite mem_t.

rewrite H.

replace (al n di_init cx_init al_init mem_init) with al_init.

replace (da2 n di_init cx_init al_init mem_init di_init al_init) with al_init.

rewrite (di_di' n).

unfold di' in |- *.

unfold compo' in |- *.

unfold di3 in |- *.

unfold ad_2_1, compo_2_1 in |- *.

unfold di1, cx1, al1, mem1, ad1, da1 in |- *.

rewrite (cx_cx' n).

unfold cx', compo', cx3 in |- *.

unfold cx_2_1, compo_2_1 in |- *.

unfold di1, cx1, al1, mem1, ad1, da1 in |- *.

trivial.



rewrite da2_constant.

trivial.



rewrite al_constant.

trivial.

Qed.



Theorem Fill_ok :

 forall t : nat,

 di t di_init cx_init al_init mem_init =

 di' t di_init cx_init al_init mem_init DC_a DC_d /\

 cx t di_init cx_init al_init mem_init =

 cx' t di_init cx_init al_init mem_init DC_a DC_d /\

 al t di_init cx_init al_init mem_init =

 al' t di_init cx_init al_init mem_init DC_a DC_d /\

 mem t di_init cx_init al_init mem_init =

 mem' t di_init cx_init al_init mem_init DC_a DC_d.

split. apply di_di'.

split. apply cx_cx'.

split. apply al_al'. apply mem_mem'.

Qed.

