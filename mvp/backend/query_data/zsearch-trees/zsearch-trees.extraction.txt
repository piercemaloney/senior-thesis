
Require Import search_tree.
(* search_tree:
Global Set Asymmetric Patterns.
Set Implicit Arguments.
Unset Strict Implicit.
Unset Standard Proposition Elimination Names.

Require Extraction.
Require Export ZArith_base.

Inductive Z_btree : Set :=
  | Z_leaf : Z_btree
  | Z_bnode : Z -> Z_btree -> Z_btree -> Z_btree.

Inductive Binp : Z_btree -> Prop :=
    Binp_intro : forall (n : Z) (t1 t2 : Z_btree), Binp (Z_bnode n t1 t2).

Hint Resolve Binp_intro: searchtrees.

Inductive occ (n : Z) : Z_btree -> Prop :=
  | occ_root : forall t1 t2 : Z_btree, occ n (Z_bnode n t1 t2)
  | occ_l :
      forall (p : Z) (t1 t2 : Z_btree), occ n t1 -> occ n (Z_bnode p t1 t2)
  | occ_r :
      forall (p : Z) (t1 t2 : Z_btree), occ n t2 -> occ n (Z_bnode p t1 t2).

Hint Resolve occ_root occ_l occ_r: searchtrees.

Derive Inversion_clear OCC_INV with
 (forall (z z' : Z) (t1 t2 : Z_btree), occ z' (Z_bnode z t1 t2)).

Lemma occ_inv :
 forall (z z' : Z) (t1 t2 : Z_btree),
 occ z' (Z_bnode z t1 t2) -> z = z' \/ occ z' t1 \/ occ z' t2.

Hint Resolve occ_inv: searchtrees.

Lemma not_occ_Leaf : forall z : Z, ~ occ z Z_leaf.

Hint Resolve not_occ_Leaf: searchtrees.

Definition naive_sch : forall (n : Z) (t : Z_btree), {occ n t} + {~ occ n t}.

Extraction naive_sch.

Inductive min (z : Z) (t : Z_btree) : Prop :=
    min_intro : (forall z' : Z, occ z' t -> (z < z')%Z) -> min z t.

Hint Resolve min_intro: searchtrees.

Inductive maj (z : Z) (t : Z_btree) : Prop :=
    maj_intro : (forall z' : Z, occ z' t -> (z' < z)%Z) -> maj z t.

Hint Resolve maj_intro: searchtrees.

Inductive search : Z_btree -> Prop :=
  | leaf_search : search Z_leaf
  | bnode_search :
      forall (z : Z) (t1 t2 : Z_btree),
      search t1 ->
      search t2 -> maj z t1 -> min z t2 -> search (Z_bnode z t1 t2).

Hint Resolve leaf_search bnode_search: searchtrees.

Lemma min_leaf : forall z : Z, min z Z_leaf.

Hint Resolve min_leaf: searchtrees.

Lemma maj_leaf : forall z : Z, maj z Z_leaf.

Hint Resolve maj_leaf: searchtrees.

Lemma maj_not_occ : forall (z : Z) (t : Z_btree), maj z t -> ~ occ z t.

Hint Resolve maj_not_occ: searchtrees.

Lemma min_not_occ : forall (z : Z) (t : Z_btree), min z t -> ~ occ z t.

Hint Resolve min_not_occ: searchtrees.

Section search_tree_basic_properties.

 Variable n : Z.
 Variable t1 t2 : Z_btree.
 Hypothesis se : search (Z_bnode n t1 t2).

 Lemma search_l : search t1.

 Hint Resolve search_l: searchtrees.

 Lemma search_r : search t2.
 Hint Resolve search_r: searchtrees.

 Lemma maj_l : maj n t1.
 Hint Resolve maj_l: searchtrees.

 Lemma min_r : min n t2.
 Hint Resolve min_r: searchtrees.

 Lemma not_right : forall p : Z, (p <= n)%Z -> ~ occ p t2.

 Hint Resolve not_right: searchtrees.
 
 Lemma not_left : forall p : Z, (p >= n)%Z -> ~ occ p t1.

 Hint Resolve not_left: searchtrees.

 Lemma go_left :
  forall p : Z, occ p (Z_bnode n t1 t2) -> (p < n)%Z -> occ p t1.

 Lemma go_right :
  forall p : Z, occ p (Z_bnode n t1 t2) -> (p > n)%Z -> occ p t2.

End search_tree_basic_properties.

Hint Resolve go_left go_right not_left not_right search_l search_r maj_l
  min_r: searchtrees.

Definition sch_spec (p : Z) (t : Z_btree) :=
  search t -> {occ p t} + {~ occ p t}.

Definition sch : forall (p : Z) (t : Z_btree), sch_spec p t.

Extraction sch.

Inductive INSERT (n : Z) (t t' : Z_btree) : Prop :=
    insert_intro :
      (forall p : Z, occ p t -> occ p t') ->
      occ n t' ->
      (forall p : Z, occ p t' -> occ p t \/ n = p) ->
      search t' -> INSERT n t t'.

Hint Resolve insert_intro: searchtrees.

Definition insert_spec (n : Z) (t : Z_btree) :=
  search t -> {t' : Z_btree | INSERT n t t'}.

Lemma insert_leaf : forall n : Z, INSERT n Z_leaf (Z_bnode n Z_leaf Z_leaf).
Hint Resolve insert_leaf: searchtrees.

Lemma insert_l :
 forall (n p : Z) (t1 t'1 t2 : Z_btree),
 (n < p)%Z ->
 search (Z_bnode p t1 t2) ->
 INSERT n t1 t'1 -> INSERT n (Z_bnode p t1 t2) (Z_bnode p t'1 t2).

Lemma insert_r :
 forall (n p : Z) (t1 t2 t'2 : Z_btree),
 (n > p)%Z ->
 search (Z_bnode p t1 t2) ->
 INSERT n t2 t'2 -> INSERT n (Z_bnode p t1 t2) (Z_bnode p t1 t'2).

Lemma insert_eq :
 forall (n : Z) (t1 t2 : Z_btree),
 search (Z_bnode n t1 t2) -> INSERT n (Z_bnode n t1 t2) (Z_bnode n t1 t2).

Hint Resolve insert_l insert_r insert_eq: searchtrees.

Lemma insert : forall (n : Z) (t : Z_btree), insert_spec n t.
Hint Resolve insert: searchtrees.

Extraction insert.

Require Export List.

Hint Resolve in_nil: searchtrees.

Hint Resolve in_inv: searchtrees.

Definition list2trees_spec (l : list Z) :=
  {t : Z_btree | search t /\ (forall p : Z, In p l <-> occ p t)}.
   
Definition list2trees_aux_spec (l : list Z) (t : Z_btree) :=
  search t ->
  {t' : Z_btree |
  search t' /\ (forall p : Z, In p l \/ occ p t <-> occ p t')}.
   
Definition list2trees_aux :
  forall (l : list Z) (t : Z_btree), list2trees_aux_spec l t.

Definition list2trees : forall l : list Z, list2trees_spec l.

Extraction list2trees_aux. 

Extraction list2trees.

Inductive RMAX (t t' : Z_btree) (n : Z) : Prop :=
    rmax_intro :
      occ n t ->
      (forall p : Z, occ p t -> (p <= n)%Z) ->
      (forall q : Z, occ q t' -> occ q t) ->
      (forall q : Z, occ q t -> occ q t' \/ n = q) ->
      ~ occ n t' -> search t' -> RMAX t t' n.

Hint Resolve rmax_intro: searchtrees.

Lemma rmax_leaf_leaf : forall n : Z, RMAX (Z_bnode n Z_leaf Z_leaf) Z_leaf n.

Lemma rmax_t_Z_leaf :
 forall (t : Z_btree) (n : Z),
 search (Z_bnode n t Z_leaf) -> RMAX (Z_bnode n t Z_leaf) t n.

Hint Resolve rmax_t_Z_leaf: searchtrees.

Section RMAX_np.
     Variable n p q : Z.
     Variable t1 t2 t3 t' : Z_btree.
     Hypothesis S1 : search (Z_bnode n t1 (Z_bnode p t2 t3)).
     Hypothesis R1 : RMAX (Z_bnode p t2 t3) t' q.
     Hint Resolve S1 R1: searchtrees.
     
     Remark rmax_1 : occ q (Z_bnode n t1 (Z_bnode p t2 t3)).

     Hint Resolve rmax_1: searchtrees.

     Remark rmax_2 : (n < p)%Z.

     Hint Resolve rmax_2: searchtrees.
     
     Remark rmax_3 : min n t'. 
     Hint Resolve rmax_3: searchtrees.
     
     Remark rmax_4 : search (Z_bnode n t1 t').

     Hint Resolve rmax_4: searchtrees.
     
     Remark rmax_5 : (n < q)%Z.

     Hint Resolve rmax_5: searchtrees.

     Remark rmax_6 :
      forall p0 : Z, occ p0 (Z_bnode n t1 (Z_bnode p t2 t3)) -> (p0 <= q)%Z.

     Hint Resolve rmax_6: searchtrees.
     
     Remark rmax_7 :
      forall q' : Z,
      occ q' (Z_bnode n t1 t') -> occ q' (Z_bnode n t1 (Z_bnode p t2 t3)).

     Hint Resolve rmax_7: searchtrees.
     
     Remark rmax_8 : ~ occ q (Z_bnode n t1 t').

     Hint Resolve rmax_8: searchtrees.

     Remark rmax_9 :
      forall q0 : Z,
      occ q0 (Z_bnode n t1 (Z_bnode p t2 t3)) ->
      occ q0 (Z_bnode n t1 t') \/ q = q0.

     Hint Resolve rmax_9: searchtrees.

     Lemma rmax_t1_t2t3 :
      RMAX (Z_bnode n t1 (Z_bnode p t2 t3)) (Z_bnode n t1 t') q.

End RMAX_np.

Hint Resolve rmax_t1_t2t3: searchtrees.

Definition rmax_sig (t : Z_btree) (q : Z) := {t' : Z_btree | RMAX t t' q}. 

Definition rmax_spec (t : Z_btree) :=
  search t -> Binp t -> {q : Z &  rmax_sig t q}.

Definition rmax : forall t : Z_btree, rmax_spec t.

Inductive RM (n : Z) (t t' : Z_btree) : Prop :=
    rm_intro :
      ~ occ n t' ->
      (forall p : Z, occ p t' -> occ p t) ->
      (forall p : Z, occ p t -> occ p t' \/ n = p) -> search t' -> RM n t t'.

Definition RM_SPEC (n : Z) (t : Z_btree) := {t' : Z_btree | RM n t t'}.

Hint Resolve rm_intro: searchtrees.

Remark RM_0 : forall n : Z, RM n Z_leaf Z_leaf.

Hint Resolve RM_0: searchtrees.

Remark RM_1 : forall n : Z, RM n (Z_bnode n Z_leaf Z_leaf) Z_leaf.

Hint Resolve RM_1: searchtrees.

Remark rm_left :
 forall (n p : Z) (t1 t2 t' : Z_btree),
 (p < n)%Z ->
 search (Z_bnode n t1 t2) ->
 RM p t1 t' -> RM p (Z_bnode n t1 t2) (Z_bnode n t' t2).

Hint Resolve rm_left: searchtrees.

Remark rm_right :
 forall (n p : Z) (t1 t2 t' : Z_btree),
 (n < p)%Z ->
 search (Z_bnode n t1 t2) ->
 RM p t2 t' -> RM p (Z_bnode n t1 t2) (Z_bnode n t1 t').

Hint Resolve rm_right: searchtrees.

Remark rm_root_base_case :
 forall (n : Z) (t : Z_btree),
 search (Z_bnode n Z_leaf t) -> RM n (Z_bnode n Z_leaf t) t.

Hint Resolve rm_root_base_case: searchtrees.

Section rm_root.
     Variable n p : Z.
     Variable t1 t2 t' : Z_btree.
     Hypothesis S : search (Z_bnode n (Z_bnode p t1 t2) t').
     Variable q : Z.
     Variable t0 : Z_btree.
     Hypothesis R : RMAX (Z_bnode p t1 t2) t0 q.
     Hint Resolve S: searchtrees.
     
     Remark rm_2 : (q < n)%Z.

     Hint Resolve rm_2: searchtrees.
     
     Remark rm_3 : ~ occ n (Z_bnode q t0 t').

     Hint Resolve rm_3: searchtrees.

     Remark rm_4 :
      forall p0 : Z,
      occ p0 (Z_bnode q t0 t') -> occ p0 (Z_bnode n (Z_bnode p t1 t2) t').

     Hint Resolve rm_4: searchtrees.

     Remark rm_5 :
      forall p0 : Z,
      occ p0 (Z_bnode n (Z_bnode p t1 t2) t') ->
      occ p0 (Z_bnode q t0 t') \/ n = p0.

     Hint Resolve rm_5: searchtrees.

     Remark rm_6 : search (Z_bnode q t0 t').

     Hint Resolve rm_6: searchtrees.
     
     Lemma rm_root_lemma :
      RM n (Z_bnode n (Z_bnode p t1 t2) t') (Z_bnode q t0 t').
     
End rm_root.

Definition rm : forall (n : Z) (t : Z_btree), search t -> RM_SPEC n t.

Extraction rm. *)

Extraction "searchtrees.ml" insert sch rmax rm list2trees list2trees_aux.
                               
