Require Import List String.
(* String:
Require Import Coq.Strings.String.
Require Import Coq.Program.Program. 
Require Import Coq.Numbers.Natural.Peano.NPeano.
Require Import Coq.Arith.Arith.

Require Import ExtLib.Tactics.Consider.
Require Import ExtLib.Core.RelDec.
Require Import ExtLib.Structures.Reducible.
Require Import ExtLib.Structures.Monoid.
Require Import ExtLib.Data.Char.
Require Import ExtLib.Data.Nat.

Set Implicit Arguments.
Set Strict Implicit.

Local Notation "x >> y" := (match x with
                              | Eq => y
                              | z => z
                            end) (only parsing, at level 30).

Definition bool_cmp (l r : bool) : comparison :=
  match l , r with
    | true , false => Gt
    | false , true => Lt
    | true , true
    | false , false => Eq
  end.

Definition ascii_cmp (l r : Ascii.ascii) : comparison :=
  match l , r with
    | Ascii.Ascii l1 l2 l3 l4 l5 l6 l7 l8 ,
      Ascii.Ascii r1 r2 r3 r4 r5 r6 r7 r8 =>
      bool_cmp l8 r8 >> bool_cmp l7 r7 >> bool_cmp l6 r6 >> bool_cmp l5 r5 >>
      bool_cmp l4 r4 >> bool_cmp l3 r3 >> bool_cmp l2 r2 >> bool_cmp l1 r1
  end.

Fixpoint string_dec (l r : string) : bool :=
  match l , r with
    | EmptyString , EmptyString => true
    | String l ls , String r rs =>
      if ascii_dec l r then string_dec ls rs
      else false
    | _ , _ => false
  end.

Theorem string_dec_sound : forall l r,
  string_dec l r = true <-> l = r.

Global Instance RelDec_string : RelDec (@eq string) :=
{| rel_dec := string_dec |}.

Global Instance RelDec_Correct_string : RelDec_Correct RelDec_string.

Global Instance Reflect_string_dec a b : Reflect (string_dec a b) (a = b) (a <> b).

Fixpoint string_cmp (l r : string) : comparison :=
  match l , r with
    | EmptyString , EmptyString => Eq
    | EmptyString , _ => Lt
    | _ , EmptyString => Gt
    | String l ls , String r rs =>
      ascii_cmp l r >> string_cmp ls rs
  end.

Section Program_Scope.
  Variable modulus : nat.
  Hypothesis one_lt_mod : 1 < modulus.

  Lemma _xxx : forall m n,
                 1 < m -> ~ n < m -> 0 < n.

  Program Fixpoint nat2string (n:nat) {measure n}: string :=
    match NPeano.Nat.ltb n modulus as x return NPeano.Nat.ltb n modulus = x -> string with

End Program_Scope.

Definition nat2string10 : nat -> string.

Definition nat2string2 : nat -> string.

Definition nat2string8 : nat -> string.

Definition nat2string16 : nat -> string.

Global Instance Foldable_string : Foldable string ascii :=
  fun _ f base =>
    fix go ls :=
    match ls with
    | EmptyString => base
    | String l ls =>
      f l (go ls)
    end.

Section string.
  Inductive R_string_len : string -> string -> Prop :=
  | R_s_len : forall n m, length n < length m -> R_string_len n m.

  Theorem wf_R_string_len : well_founded R_string_len.
End string.

Definition Monoid_string_append : Monoid string :=
{| monoid_plus := append
 ; monoid_unit := EmptyString
|}. *)

Require Import ExtLib.Structures.CoMonad.



Set Implicit Arguments.

Set Strict Implicit.



Inductive type : Type :=

| Self : type

| Inj : Type -> type.



Definition product := list type.

Definition variant := list product.



Section denote.

  Variable M : Type.



  Definition typeD (t : type) : Type :=

    match t with

      | Self => M

      | Inj t => t

    end.



  Definition func (T : Type) (v : product) : Type :=

    fold_right (fun x acc => typeD x -> acc) T v.



  Definition data (v : product) : Type :=

    fold_right (fun x acc => typeD x * acc)%type unit v.



  Definition matchD (T : Type) (v : variant) : Type :=

    fold_right (fun x acc => func T x -> acc)%type T v.



  Definition dataD (v : variant) : Type :=

    fold_right (fun x acc => data x + acc)%type Empty_set v.



  Definition recD (T : Type) (c : Type -> Type) (v : variant) : Type :=

    fold_right (fun x acc =>

      fold_right (fun x acc =>

        match x with

          | Inj t => t

          | Self => c T

        end -> acc) (c T) x -> acc) (M -> T) v.



End denote.



Class Data (T : Type) : Type :=

{ repr  : variant

; into  : dataD T repr -> T

; outof : T -> forall A, matchD T A repr

; rec   : forall c {_ : CoMonad c}, forall A, recD T A c repr

}.



Local Open Scope string_scope.



Global Instance Data_nat : Data nat :=

{ repr := nil :: (Self :: nil) :: nil

; outof := fun x _ z s =>

  match x with

    | 0 => z

    | S n => s n

  end

; into := fun d =>

  match d with

    | inl tt => 0

    | inr (inl (n, tt)) => n

    | inr (inr x) => match x with end

  end

; rec := fun c _ A z s d =>

  coret ((fix recur (d : nat) {struct d} : c A :=

    match d with

      | 0 => z

      | S n => s (recur n)

    end) d)

}.



Global Instance Data_list {A} : Data (list A) :=

{ repr := (nil) :: (Inj A :: Self :: nil) :: nil

; outof := fun x _ n c =>

  match x with

    | nil => n

    | x :: xs => c x xs

  end

; into := fun d =>

  match d with

    | inl tt => nil

    | inr (inl (x, (xs, tt))) => x :: xs

    | inr (inr x) => match x with end

  end

; rec := fun c _ T n co d =>

  coret ((fix recur (ds : list A) {struct ds} : c T :=

    match ds with

      | nil => n

      | d :: ds => co d (recur ds)

    end) d)

}.



Require Import ExtLib.Programming.Show.

Require Import ExtLib.Data.Monads.IdentityMonad.

Require Import ExtLib.Structures.Monads.



Global Instance Comoand_Id : CoMonad id :=

{ coret := fun _ x => x

; cobind := fun _ _ f x => x f

}.



Definition ProductResolve (C : Type -> Type) (r : product) : Type :=

  fold_right (fun t acc =>

    match t with

      | Inj t => C t * acc

      | Self => acc

    end)%type unit r.



Definition VariantResolve (C : Type -> Type) (r : variant) : Type :=

  fold_right (fun p acc => ProductResolve C p * acc)%type unit r.



Existing Class VariantResolve.

Ltac all_resolve :=

  simpl VariantResolve; simpl ProductResolve;

    repeat match goal with

             | |- unit => apply tt

             | |- (unit * _)%type => constructor; [ apply tt | ]

             | |- (_ * _)%type => constructor

             | |- _ => solve [ eauto with typeclass_instances ]

           end.



Hint Extern 0 (ProductResolve _ _) => all_resolve : typeclass_instances.

Hint Extern 0 (VariantResolve _ _) => all_resolve : typeclass_instances.



Definition comma_before (b : bool) (s : showM) : showM :=

  if b then

    cat (show_exact ",") s

  else

    s.



Fixpoint show_product (first : bool) (r : list type) {struct r} :

  ProductResolve Show r ->

  (showM -> showM) ->

  (fold_right

     (fun (x : type) (acc : Type) =>

      match x with

      | Self => showM

      | Inj t => t

      end -> acc) (showM) r).

refine (

     match r as r

       return

       ProductResolve Show r ->

       (showM -> showM) ->

       (fold_right

         (fun (x : type) (acc : Type) =>

           match x with

             | Self => showM

             | Inj t => t

           end -> acc) (showM) r)

       with

       | nil => fun _ f => f empty

       | Self :: rs => fun a f s =>

         @show_product false rs a (fun s' => f (cat s (comma_before first s')))

       | Inj t :: rs => fun a f x => @show_product false rs (snd a) (fun s' => f (cat ((fst a) x) (comma_before first s')))

     end); simpl in *.

Defined.



Global Instance Show_data (T : Type) (d : Data T) (AS : VariantResolve Show repr) : Show T :=

{ show :=

  (fix recur (repr : variant) : VariantResolve Show repr -> recD T showM id repr -> T -> showM :=

    match repr as repr return

      VariantResolve Show repr -> recD T showM id repr -> T -> showM

      with

      | nil => fun _ x => x

      | r :: rs => fun a k' =>

        recur rs (snd a) (k' (show_product true _ (fst a)

          (fun s' => cat (show_exact "-") (cat (show_exact "(") (cat s' (show_exact ")"))))))

    end) repr AS (rec (c := id) showM)

}.



Eval compute in

  to_string (M := Show_data _ _) (5 :: 6 :: 7 :: nil).

