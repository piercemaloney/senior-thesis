Require Import List.
(* List:
End type.

Section EqDec.
  Variable T : Type.
  Variable EqDec_T : EquivDec.EqDec _ (@eq T).

  Global Instance EqDec_list : EquivDec.EqDec _ (@eq (list T)).
End EqDec.

Lemma list_ind_singleton
: forall {T : Type} (P : list T -> Prop)
         (Hnil : P nil)
         (Hsingle : forall t, P (t :: nil))
         (Hcons : forall t u us, P (u :: us) -> P (t :: u :: us)),
    forall ls, P ls.

Lemma list_rev_ind
  : forall T (P : list T -> Prop),
    P nil ->
    (forall l ls, P ls -> P (ls ++ l :: nil)) ->
    forall ls, P ls.

Section AllB.
  Variable T : Type.
  Variable p : T -> bool.

  Fixpoint allb (ls : list T) : bool :=
    match ls with
      | nil => true
      | l :: ls =>
        if p l then allb ls else false
    end.

  Fixpoint anyb (ls : list T) : bool :=
    match ls with
      | nil => false
      | l :: ls =>
        if p l then true else anyb ls
    end.
End AllB.

Lemma Forall_map
: forall T U (f : T -> U) P ls,
    Forall P (List.map f ls) <-> Forall (fun x => P (f x)) ls.

Lemma Forall_cons_iff : forall (T : Type) (P : T -> Prop) a b,
    Forall P (a :: b) <-> (P a /\ Forall P b).

Lemma Forall_nil_iff : forall (T : Type) (P : T -> Prop),
    Forall P nil <-> True.

Global Instance Foldable_list {T} : Foldable (list T) T :=
  fun _ f x ls => fold_right f x ls.

Require Import ExtLib.Structures.Traversable.
Require Import ExtLib.Structures.Functor.
Require Import ExtLib.Structures.Monad.
Require Import ExtLib.Structures.Applicative.

Section traversable.
  Polymorphic Context {F : Type -> Type}.
  Polymorphic Context {Applicative_F : Applicative F}.
  Polymorphic Context {A B : Type}.
  Polymorphic Variable f : A -> F B.

  Polymorphic Fixpoint mapT_list (ls : list A) : F (list B) :=
    match ls with
      | nil => pure nil
      | l :: ls => ap (ap (pure (@cons B)) (f l)) (mapT_list ls)
    end.
End traversable.

Global Instance Traversable_list : Traversable list :=
{ mapT := @mapT_list }.

Global Instance Monad_list : Monad list :=
{ ret  := fun _ x => x :: nil
; bind := fun _ _ x f =>
  List.fold_right (fun x acc => f x ++ acc) nil x
}.

Section list.
  Inductive R_list_len {T} : list T -> list T -> Prop :=
  | R_l_len : forall n m, length n < length m -> R_list_len n m.

  Theorem wf_R_list_len T : well_founded (@R_list_len T).
End list.

Definition Monoid_list_app {T} : Monoid (list T) :=
{| monoid_plus := @List.app _
 ; monoid_unit := @nil _
 |}.

Section ListEq.
  Variable T : Type.
  Variable EDT : RelDec (@eq T).

  Fixpoint list_eqb (ls rs : list T) : bool :=
    match ls , rs with
      | nil , nil => true
      | cons l ls , cons r rs =>
        if l ?[ eq ] r then list_eqb ls rs else false
      | _ , _ => false
    end.

  Global Instance RelDec_eq_list : RelDec (@eq (list T)) :=
  { rel_dec := list_eqb }.

  Variable EDCT : RelDec_Correct EDT.

  Global Instance RelDec_Correct_eq_list : RelDec_Correct RelDec_eq_list.

End ListEq.

Global Instance Injective_cons T (a : T) b c d : Injective (a :: b = c :: d).

Global Instance Injective_cons_nil T (a : T) b : Injective (a :: b = nil).

Global Instance Injective_nil_cons T (a : T) b : Injective (nil = a :: b).

Global Instance Injective_nil_nil T : Injective (nil = @nil T).

Global Instance Injective_app_cons {T} (a : list T) b c d
: Injective (a ++ b :: nil = (c ++ d :: nil)).

Global Instance Injective_app_same_L {T} (a : list T) b c
: Injective (b ++ a = b ++ c).

Global Instance Injective_app_same_R {T} (a : list T) b c
: Injective (a ++ b = c ++ b).

Lemma eq_list_eq
: forall T (a b : T) (pf : a = b) (F : _ -> Type) val,
    match pf in _ = x return list (F x) with
      | eq_refl => val
    end = map (fun val => match pf in _ = x return F x with
                            | eq_refl => val
                          end) val.
Hint Rewrite eq_list_eq : eq_rw.

Export Coq.Lists.List. *)
Require Import ExtLib.Structures.Sets.
Require Import ExtLib.Core.RelDec.
Require Import ExtLib.Data.List.
Require Import ExtLib.Structures.Reducible.

Set Implicit Arguments.
Set Strict Implicit.

Section ListSet.

  Definition lset (T : Type) : Type :=
    list T.

  Variable T : Type.
  Variable R_dec : T -> T -> bool.

  Fixpoint lset_contains (v : T) (ls : lset T) : bool :=
    match ls with
      | nil => false
      | l :: ls => if R_dec v l then true else lset_contains v ls
    end.

  Definition lset_empty : lset T := nil.

  Definition lset_add (v : T) (ls : lset T) : lset T :=
    if lset_contains v ls then ls else v :: ls.

  Definition lset_remove (v : T) : lset T -> lset T :=
    List.filter (fun x => negb (R_dec v x)).

  Definition lset_union (l r : lset T) : lset T :=
    fold_left (fun x y => lset_add y x) l r.

  Definition lset_difference (l r : lset T) : lset T :=
    List.filter (fun x => negb (lset_contains x r)) l.

  Definition lset_intersect (l r : lset T) : lset T :=
    List.filter (fun x => lset_contains x r) l.

  Definition lset_subset (l r : lset T) : bool :=
    allb (fun x => lset_contains x r) l.

End ListSet.

Global Instance DSet_weak_listset {T} (R : T -> T -> Prop)
  (R_dec : RelDec R) : DSet (@lset T) T :=
{ contains  := lset_contains rel_dec
; empty     := lset_empty T
; add       := lset_add rel_dec
; singleton := fun x => lset_add rel_dec x (lset_empty T)
; remove    := lset_remove rel_dec
; union     := lset_union rel_dec
; intersect := lset_intersect rel_dec
; difference := lset_difference rel_dec
; subset     := lset_subset rel_dec
; filter     := @List.filter _
}.

Global Instance Foldable_listset {T} (R : T -> T -> Prop)
  : Foldable (lset T) T :=
  fun _ f a t => List.fold_left (fun x y => f y x) t a.

Require Import ExtLib.Structures.Functor.
Require Import ExtLib.Programming.Eqv.

Global Instance PFunctor_listset : PFunctor lset :=
{ FunP := fun t => { eqT : Eqv t & RelDec eqv }
; pfmap := fun _ B eqv_dec f s => 
  List.fold_left (fun acc x => lset_add (@rel_dec B (@eqv B (projT1 eqv_dec)) (projT2 eqv_dec)) (f x) acc) s (@lset_empty _)
}.
