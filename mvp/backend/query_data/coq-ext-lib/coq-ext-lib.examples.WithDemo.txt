Require Import List.
(* List:
End type.

Section EqDec.
  Variable T : Type.
  Variable EqDec_T : EquivDec.EqDec _ (@eq T).

  Global Instance EqDec_list : EquivDec.EqDec _ (@eq (list T)).
End EqDec.

Lemma list_ind_singleton
: forall {T : Type} (P : list T -> Prop)
         (Hnil : P nil)
         (Hsingle : forall t, P (t :: nil))
         (Hcons : forall t u us, P (u :: us) -> P (t :: u :: us)),
    forall ls, P ls.

Lemma list_rev_ind
  : forall T (P : list T -> Prop),
    P nil ->
    (forall l ls, P ls -> P (ls ++ l :: nil)) ->
    forall ls, P ls.

Section AllB.
  Variable T : Type.
  Variable p : T -> bool.

  Fixpoint allb (ls : list T) : bool :=
    match ls with
      | nil => true
      | l :: ls =>
        if p l then allb ls else false
    end.

  Fixpoint anyb (ls : list T) : bool :=
    match ls with
      | nil => false
      | l :: ls =>
        if p l then true else anyb ls
    end.
End AllB.

Lemma Forall_map
: forall T U (f : T -> U) P ls,
    Forall P (List.map f ls) <-> Forall (fun x => P (f x)) ls.

Lemma Forall_cons_iff : forall (T : Type) (P : T -> Prop) a b,
    Forall P (a :: b) <-> (P a /\ Forall P b).

Lemma Forall_nil_iff : forall (T : Type) (P : T -> Prop),
    Forall P nil <-> True.

Global Instance Foldable_list {T} : Foldable (list T) T :=
  fun _ f x ls => fold_right f x ls.

Require Import ExtLib.Structures.Traversable.
Require Import ExtLib.Structures.Functor.
Require Import ExtLib.Structures.Monad.
Require Import ExtLib.Structures.Applicative.

Section traversable.
  Polymorphic Context {F : Type -> Type}.
  Polymorphic Context {Applicative_F : Applicative F}.
  Polymorphic Context {A B : Type}.
  Polymorphic Variable f : A -> F B.

  Polymorphic Fixpoint mapT_list (ls : list A) : F (list B) :=
    match ls with
      | nil => pure nil
      | l :: ls => ap (ap (pure (@cons B)) (f l)) (mapT_list ls)
    end.
End traversable.

Global Instance Traversable_list : Traversable list :=
{ mapT := @mapT_list }.

Global Instance Monad_list : Monad list :=
{ ret  := fun _ x => x :: nil
; bind := fun _ _ x f =>
  List.fold_right (fun x acc => f x ++ acc) nil x
}.

Section list.
  Inductive R_list_len {T} : list T -> list T -> Prop :=
  | R_l_len : forall n m, length n < length m -> R_list_len n m.

  Theorem wf_R_list_len T : well_founded (@R_list_len T).
End list.

Definition Monoid_list_app {T} : Monoid (list T) :=
{| monoid_plus := @List.app _
 ; monoid_unit := @nil _
 |}.

Section ListEq.
  Variable T : Type.
  Variable EDT : RelDec (@eq T).

  Fixpoint list_eqb (ls rs : list T) : bool :=
    match ls , rs with
      | nil , nil => true
      | cons l ls , cons r rs =>
        if l ?[ eq ] r then list_eqb ls rs else false
      | _ , _ => false
    end.

  Global Instance RelDec_eq_list : RelDec (@eq (list T)) :=
  { rel_dec := list_eqb }.

  Variable EDCT : RelDec_Correct EDT.

  Global Instance RelDec_Correct_eq_list : RelDec_Correct RelDec_eq_list.

End ListEq.

Global Instance Injective_cons T (a : T) b c d : Injective (a :: b = c :: d).

Global Instance Injective_cons_nil T (a : T) b : Injective (a :: b = nil).

Global Instance Injective_nil_cons T (a : T) b : Injective (nil = a :: b).

Global Instance Injective_nil_nil T : Injective (nil = @nil T).

Global Instance Injective_app_cons {T} (a : list T) b c d
: Injective (a ++ b :: nil = (c ++ d :: nil)).

Global Instance Injective_app_same_L {T} (a : list T) b c
: Injective (b ++ a = b ++ c).

Global Instance Injective_app_same_R {T} (a : list T) b c
: Injective (a ++ b = c ++ b).

Lemma eq_list_eq
: forall T (a b : T) (pf : a = b) (F : _ -> Type) val,
    match pf in _ = x return list (F x) with
      | eq_refl => val
    end = map (fun val => match pf in _ = x return F x with
                            | eq_refl => val
                          end) val.
Hint Rewrite eq_list_eq : eq_rw.

Export Coq.Lists.List. *)
Require Import ExtLib.Programming.With.

Record RTest : Set := mkRTest {
  a : bool ; b : nat ; c : bool
}.

Bind Scope struct_scope with RTest.

Global Instance Struct_RTest : Struct RTest := {
  fields := ((@existT _ _ _ a) :: (@existT _ _ _ b) :: (@existT _ _ _ c):: nil) ;
  ctor   := mkRTest
}.

Global Instance Acc_RTest_a : Accessor a := { acc := Here }.

Global Instance Acc_RTest_b : Accessor b := { acc := Next Here }.

Global Instance Acc_RTest_c : Accessor c := { acc := Next (Next Here) }.

Eval compute in {$ mkRTest true 1 true with c := false $}%record.

Eval compute in forall x : RTest, c {$ x with c := false $}%record = false.
