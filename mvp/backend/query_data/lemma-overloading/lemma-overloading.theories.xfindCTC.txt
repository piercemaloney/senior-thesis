

From mathcomp

Require Import ssreflect ssrnat seq.

From LemmaOverloading

Require Import prefix.
(* prefix:
From mathcomp
Require Import ssreflect ssrfun ssrbool ssrnat seq.
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Section Prefix.
Variable A : Type.

Fixpoint onth (s : seq A) n : option A :=
  if s is x :: s' then
    if n is n'.+1 then onth s' n' else Some x
  else None.

Definition prefix s1 s2 :=
  forall n x, onth s1 n = some x -> onth s2 n = some x.

Lemma size_onth (s : seq A) n : n < size s -> exists x, onth s n = Some x.

Lemma onth_size (s : seq A) n x : onth s n = Some x -> n < size s.

Lemma prefix_refl s : prefix s s.

Lemma prefix_trans (s2 s1 s3 : seq A) :
        prefix s1 s2 -> prefix s2 s3 -> prefix s1 s3.

Lemma prefix_cons x s1 s2 : prefix (x :: s1) (x :: s2) <-> prefix s1 s2.

Lemma prefix_cons' x y s1 s2 : prefix (x :: s1) (y :: s2) -> x = y /\ prefix s1 s2.

Lemma prefix_size (s t : seq A) : prefix s t -> size s <= size t.

Lemma prefix_onth (s t : seq A) x : x < size s -> prefix s t -> onth s x = onth t x.

End Prefix.

Hint Resolve prefix_refl : core. *)

Set Implicit Arguments.

Unset Strict Implicit.

Unset Printing Implicit Defensive.



Definition invariant A s r i (e : A) := onth r i = Some e /\ prefix s r.



Class XFind A (s : seq A) (e : A) := {

  seq_of : seq A;

  index_of : nat;

  xfind : invariant s seq_of index_of e}.



Arguments XFind [A].



Program Instance found_struct A (x:A) t : XFind (x :: t) x := {| seq_of := (x :: t); index_of := 0|}.

Next Obligation. by split; [|apply: prefix_refl]. Qed.



Program Instance recurse_struct A (y:A) t e (f : XFind t e) :

  XFind (y :: t) e | 2 := {| seq_of := (y :: seq_of); index_of := index_of.+1|}.

Next Obligation.

by case:f=>r i /= [H1 H2]; split; [|apply/prefix_cons].

Qed.



Program Instance extend_struct A (x:A) : XFind [::] x := {| seq_of := [:: x]; index_of := 0|}.

Next Obligation. by []. Qed.



Example unit_test A (x1 x2 x3 x y : A):

   (forall s e (f : XFind s e), nth x1 seq_of index_of = e -> e = x) ->

  x = x.

Proof.

move=>test_form.

apply: (test_form [::]). simpl.

apply: (test_form [:: x1; x]). simpl.

apply: (test_form [:: x1; x2; x; x3]). simpl.

apply: (test_form [:: x1; x2; x3]). rewrite [seq_of]/=. rewrite [index_of]/=. simpl.

Abort.



Lemma bla A (x : A) s (C : XFind s x) : onth seq_of index_of = Some x.

Proof.

by case: xfind.

Qed.



Example ex1 : onth [::1;2;3;4;5] 2 = Some 3.

apply: bla.

Qed.

