
From mathcomp
Require Import ssreflect ssrbool ssrfun ssrnat eqtype seq.
From LemmaOverloading
Require Import prelude heaps rels hprop domains.
(* prelude:
From mathcomp
Require Import ssreflect ssrbool eqtype ssrfun seq.
Require Import Eqdep ClassicalFacts.
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Axiom pext : forall p1 p2 : Prop, (p1 <-> p2) -> p1 = p2.
Axiom fext : forall A (B : A -> Type) (f1 f2 : forall x, B x),
               (forall x, f1 x = f2 x) -> f1 = f2.

Lemma proof_irrelevance (P : Prop) (p1 p2 : P) : p1 = p2.

Lemma eta A (B : A -> Type) (f : forall x, B x) : f = [eta f].

Lemma ext A (B : A -> Type) (f1 f2 : forall x, B x) :
        f1 = f2 -> forall x, f1 x = f2 x.

Ltac add_morphism_tactic := SetoidTactics.add_morphism_tactic.
Notation " R ===> R' " := (@Morphisms.respectful _ _ R R')
  (right associativity, at level 55) : signature_scope.

Definition inj_pair2 := @inj_pair2.
Arguments inj_pair2 {U P p x y}.

Lemma inj_sval A P : injective (@sval A P).

Lemma svalE A (P : A -> Prop) x H : sval (exist P x H) = x.

Lemma sym A (x y : A) : x = y <-> y = x.

Section HasSelect.
Variables (A : eqType) (p : pred A).

CoInductive has_spec (s : seq A) : bool -> Type :=
| has_true x of x \in s & p x : has_spec s true
| has_false of (all (predC p) s) : has_spec s false.

Lemma hasPx : forall s, has_spec s (has p s).

End HasSelect.

Module Dyn.
Record dynamic : Type := dyn {typ : Type; val : typ}.
End Dyn.

Notation dynamic := Dyn.dynamic.
Notation dyn := Dyn.dyn.

Lemma dyn_inj A (x y : A) : dyn x = dyn y -> x = y.

Lemma dyn_eta d : d = dyn (Dyn.val d).

Lemma dyn_injT A1 A2 (x1 : A1) (x2 : A2) : dyn x1 = dyn x2 -> A1 = A2.

Prenex Implicits dyn_inj dyn_injT.

Section Coercions.
Variable (T : Type -> Type).

Definition coerce A B (x : T A) : A = B -> T B := [eta eq_rect A [eta T] x B].

Lemma eqc A (x : T A) (pf : A = A) : coerce x pf = x.

Definition jmeq A B (x : T A) (y : T B) := forall pf, coerce x pf = y.

Lemma jmE A (x y : T A) : jmeq x y <-> x = y.

Lemma jmeq_refl A (x : T A) : jmeq x x.

End Coercions.

Hint Resolve jmeq_refl : core.
Arguments jmeq T [A B] x y.
Notation "a =jm b" := (jmeq id a b) (at level 50).

Lemma contV B (P : B -> B -> Prop) :
        (forall x x', x =jm x' -> P x x') <-> forall x, P x x.

Lemma contVT B (P : B -> B -> Prop) :
        (forall x x', B = B -> x =jm x' -> P x x') <-> forall x, P x x.

Section Coercions2.
Variable (T : Type -> Type -> Type).

Program
Definition coerce2 A1 A2 B1 B2 (x : T A1 A2) :
             (A1, A2) = (B1, B2) -> T B1 B2.

Lemma eqc2 A1 A2 (x : T A1 A2) (pf : (A1, A2) = (A1, A2)) :
        coerce2 x pf = x.

Definition jmeq2 A1 A2 B1 B2 (x : T A1 B1) (y : T A2 B2) :=
             forall pf, coerce2 x pf = y.

Lemma jm2E A B (x y : T A B) : jmeq2 x y <-> x = y.

Lemma refl_jmeq2 A B (x : T A B) : jmeq2 x x.

End Coercions2.

Hint Resolve refl_jmeq2 : core.
Arguments jmeq2 T [A1 A2 B1 B2] x y.

Lemma compA A B C D (h : A -> B) (g : B -> C) (f : C -> D) :
        (f \o g) \o h = f \o (g \o h).

Lemma compf1 A B (f : A -> B) : f = f \o id.

Lemma comp1f A B (f : A -> B) : f = id \o f.

Definition fprod A1 A2 B1 B2 (f1 : A1 -> B1) (f2 : A2 -> B2) :=
  fun (x : A1 * A2) => (f1 x.1, f2 x.2).

Notation "f1 \* f2" := (fprod f1 f2) (at level 45).

Section Reorder.
Variables (A B C : Type).

Definition swap (x : A * B) :=
  let: (x1, x2) := x in (x2, x1).
Definition rCA (x : A * (B * C)) :=
  let: (x1, (x2, x3)) := x in (x2, (x1, x3)).
Definition rAC (x : (A * B) * C) :=
  let: ((x1, x2), x3) := x in ((x1, x3), x2).
Definition rA (x : A * (B * C)) :=
  let: (x1, (x2, x3)) := x in ((x1, x2), x3).
Definition iA (x : (A * B) * C) :=
  let: ((x1, x2), x3) := x in (x1, (x2, x3)).
Definition pL (x : A * B) :=
  let: (x1, x2) := x in x1.
Definition pR (x : A * B) :=
  let: (x1, x2) := x in x2.
End Reorder.

Prenex Implicits swap rCA rAC rA iA pL pR.

Lemma swapI A B : swap \o swap = @id (A * B).

Lemma rCAI A B C : rCA \o (@rCA A B C) = id.

Lemma rACI A B C : rAC \o (@rAC A B C) = id.

Lemma riA A B C : rA \o (@iA A B C) = id.

Lemma irA A B C : iA \o (@rA A B C) = id.

Lemma swap_prod A1 B1 A2 B2 (f1 : A1 -> B1) (f2 : A2 -> B2) :
        swap \o f1 \* f2 = f2 \* f1 \o swap.

Lemma swap_rCA A B C : swap \o (@rCA A B C) = rAC \o rA.

Lemma swap_rAC A B C : swap \o (@rAC A B C) = rCA \o iA.

Ltac rfe1 x1 := let H := fresh "H" in move=>H; move:H x1=>-> x1.
Ltac rfe2 x1 x2 := let H := fresh "H" in move=>H; move:H x1 x2=>-> x1 x2.
Ltac rfjm := move/jmE=>->.
Ltac rfejm1 x1 := rfe1 x1; rfjm.
Ltac rfejm2 x1 x2 := rfe2 x1 x2; rfjm.
Ltac rfp := move/inj_pair2=>->.
Ltac rfep1 x1 := rfe1 x1; rfp.
Ltac rfep2 x1 x2 := rfe1 x2; rfp.

Ltac rbe1 x1 := let H := fresh "H" in move=>H; move:H x1=><- x1.
Ltac rbe2 x1 x2 := let H := fresh "H" in move=>H; move:H x1 x2=><- x1 x2.
Ltac rbjm := move/jmE=><-.
Ltac rbejm1 x1 := rbe1 x1; rbjm.
Ltac rbejm2 x1 x2 := rbe2 x1 x2; rbjm.
Ltac rbp := move/inj_pair2=><-.
Ltac rbep1 x1 := rbe1 x1; rbp.
Ltac rbep2 x1 x2 := rbe1 x2; rbp.

Reserved Notation "[ /\ P1 , P2 , P3 , P4 , P5 & P6 ]" (at level 0, format
  "'[hv' [ /\ '['  P1 , '/'  P2 , '/'  P3 , '/'  P4 , '/'  P5 ']' '/ '  &  P6 ] ']'").

Reserved Notation "[ \/ P1 , P2 , P3 , P4 & P5 ]" (at level 0, format
  "'[hv' [ \/ '['  P1 , '/'  P2 , '/'  P3 , '/'  P4 ']' '/ '  &  P5 ] ']'").
Reserved Notation "[ \/ P1 , P2 , P3 , P4 , P5 & P6 ]" (at level 0, format
  "'[hv' [ \/ '['  P1 , '/'  P2 , '/'  P3 , '/'  P4 , '/'  P5 ']' '/ '  &  P6 ] ']'").

Inductive and6 (P1 P2 P3 P4 P5 P6 : Prop) : Prop :=
  And6 of P1 & P2 & P3 & P4 & P5 & P6.

Inductive or5 (P1 P2 P3 P4 P5 : Prop) : Prop :=
  Or51 of P1 | Or52 of P2 | Or53 of P3 | Or54 of P4 | Or55 of P5.
Inductive or6 (P1 P2 P3 P4 P5 P6 : Prop) : Prop :=
  Or61 of P1 | Or62 of P2 | Or63 of P3 | Or64 of P4 | Or65 of P5 | Or66 of P6.

Notation "[ /\ P1 , P2 , P3 , P4 , P5 & P6 ]" := (and6 P1 P2 P3 P4 P5 P6) : type_scope.
Notation "[ \/ P1 , P2 , P3 , P4 | P5 ]" := (or5 P1 P2 P3 P4 P5) : type_scope.
Notation "[ \/ P1 , P2 , P3 , P4 , P5 | P6 ]" := (or6 P1 P2 P3 P4 P5 P6) : type_scope.

Section ReflectConnectives.

Variable b1 b2 b3 b4 b5 b6 : bool.
Lemma and6P : reflect [/\ b1, b2, b3, b4, b5 & b6] [&& b1, b2, b3, b4, b5 & b6].

Lemma or5P : reflect [\/ b1, b2, b3, b4 | b5] [|| b1, b2, b3, b4 | b5].

Lemma or6P : reflect [\/ b1, b2, b3, b4, b5 | b6] [|| b1, b2, b3, b4, b5 | b6].

End ReflectConnectives.

Arguments and6P {b1 b2 b3 b4 b5 b6}.
Arguments or5P {b1 b2 b3 b4 b5}.
Arguments or6P {b1 b2 b3 b4 b5 b6}. *)
(* heaps:
From mathcomp
Require Import ssreflect ssrfun ssrnat div ssrbool seq.
From LemmaOverloading
Require Import prelude finmap ordtype.
From mathcomp
Require Import path eqtype.
Require Import Eqdep.
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Notation eqn_addl := eqn_add2l.
Notation modn_addl := modnDl.
Notation modn_mulr := modnMr.
Notation modn_add2m := modnDm.
Notation modn_addr := modnDr.

Inductive ptr := ptr_nat of nat.

Definition null := ptr_nat 0.

Definition nat_ptr (x : ptr) := let: ptr_nat y := x in y.

Definition eq_ptr (x y : ptr) :=
  match x, y with ptr_nat m, ptr_nat n => m == n end.

Lemma eq_ptrP : Equality.axiom eq_ptr.

Definition ptr_eqMixin := EqMixin eq_ptrP.
Canonical Structure ptr_eqType := EqType ptr ptr_eqMixin.

Definition ptr_offset x i := ptr_nat (nat_ptr x + i).

Notation "x .+ i" := (ptr_offset x i)
  (at level 3, format "x .+ i").

Lemma ptrE x y : (x == y) = (nat_ptr x == nat_ptr y).

Lemma ptr0 x : x.+0 = x.

Lemma ptrA x i j : x.+i.+j = x.+(i+j).

Lemma ptrK x i j : (x.+i == x.+j) = (i == j).

Lemma ptr_null x m : (x.+m == null) = (x == null) && (m == 0).

Lemma ptrT x y : {m : nat | (x == y.+m) || (y == x.+m)}.

Definition ltn_ptr (x y : ptr) :=
  match x, y with ptr_nat m, ptr_nat n => m < n end.

Lemma ltn_ptr_irr : irreflexive ltn_ptr.

Lemma ltn_ptr_trans : transitive ltn_ptr.

Lemma ltn_ptr_total : forall x y : ptr, [|| ltn_ptr x y, x == y | ltn_ptr y x].

Definition ptr_ordMixin := OrdMixin ltn_ptr_irr ltn_ptr_trans ltn_ptr_total.
Canonical Structure ptr_ordType := OrdType ptr ptr_ordMixin.

Inductive heap :=
  Undef | Def (finmap : {finMap ptr -> dynamic}) of
               null \notin supp finmap.

Section NullLemmas.
Variables (f g : {finMap ptr -> dynamic}) (x : ptr) (d : dynamic).

Lemma upd_nullP :
        x != null -> null \notin supp f -> null \notin supp (ins x d f).

Lemma free_nullP : null \notin supp f -> null \notin supp (rem x f).

Lemma un_nullP :
        null \notin supp f -> null \notin supp g ->
          null \notin supp (fcat f g).

Lemma heapE pf pg : f = g <-> @Def f pf = @Def g pg.

End NullLemmas.

Definition def h := if h is Def _ _ then true else false.

Definition empty := @Def (finmap.nil _ _) is_true_true.

Definition upd h x d := nosimpl
  (if h is Def hs ns then
    if decP (@idP (x != null)) is left pf then
      Def (@upd_nullP _ _ d pf ns)
    else Undef
  else Undef).

Definition dom h : pred ptr := nosimpl
  (if h is Def f _ then mem (supp f) else pred0).

Definition free x h : heap :=
  (if h is Def hs ns then Def (free_nullP x ns) else Undef).

Definition look (x : ptr) h :=
  (if h is Def hs _ then
    if fnd x hs is Some d then d else dyn tt
  else dyn tt).

Definition union2 h1 h2 := nosimpl
  (if (h1, h2) is (Def hs1 ns1, Def hs2 ns2) then
     if disj hs1 hs2 then
        Def (@un_nullP _ _ ns1 ns2)
     else Undef
  else Undef).

Definition empb h :=
  if h is Def hs _ then supp hs == [::] else false.

Definition fresh h :=
  (if h is Def hs _ then last null (supp hs) else null) .+ 1.

Definition subdom h1 h2 :=
  if (h1, h2) is (Def hs1 _, Def hs2 _) then
    all (fun x => x \in supp hs2) (supp hs1)
  else false.

Definition subheap h1 h2 :=
  subdom h1 h2 /\ forall x, x \in dom h1 -> look x h1 = look x h2.

Definition subtract h1 h2 :=
  if h1 is (Def hs1 _) then
    foldl (fun h x => free x h) h2 (supp hs1)
  else Undef.

Definition pick h :=
  if h is Def hs _ then head null (supp hs) else null.

Definition pts A (x : ptr) (v : A) := upd empty x (dyn v).

Notation "h1 :+ h2" := (union2 h1 h2) (at level 43, left associativity).
Notation "h2 :- h1" := (subtract h1 h2) (at level 43, left associativity).
Notation "x :-> v" := (pts x v) (at level 30).

Lemma unC : forall h1 h2, h1 :+ h2 = h2 :+ h1.

Lemma unA : forall h1 h2 h3, h1 :+ (h2 :+ h3) = h1 :+ h2 :+ h3.

Lemma unCA h1 h2 h3 : h1 :+ (h2 :+ h3) = h2 :+ (h1 :+ h3).

Lemma unAC h1 h2 h3 : h1 :+ h2 :+ h3 = h1 :+ h3 :+ h2.

Lemma un0h h : empty :+ h = h.

Lemma unh0 h : h :+ empty = h.

Lemma unKhl h h1 h2 : def (h1 :+ h) -> h1 :+ h = h2 :+ h -> h1 = h2.

Lemma unhKl h h1 h2 : def (h :+ h1) -> h :+ h1 = h :+ h2 -> h1 = h2.

Lemma unKhr h h1 h2 : def (h2 :+ h) -> h1 :+ h = h2 :+ h -> h1 = h2.

Lemma unhKr h h1 h2 : def (h :+ h2) -> h :+ h1 = h :+ h2 -> h1 = h2.

Lemma dom0 : dom empty = pred0.

Lemma domU h y d :
        dom (upd h y d) =i
        [pred x | (y != null) && if x == y then def h else x \in dom h].

Lemma domPt A x (v : A) : dom (x :-> v) =i [pred y | (x == y) && (x != null)].

Lemma domF h x :
        dom (free x h) =i [pred y | if x == y then false else y \in dom h].

Lemma domUn h1 h2 :
        dom (h1 :+ h2) =i
        [pred x | def (h1 :+ h2) && (x \in [predU dom h1 & dom h2])].

Lemma dom_null h x : x \in dom h -> x != null.

Lemma dom_def h x : x \in dom h -> def h.

Lemma dom_free h x : x \notin dom h -> free x h = h.

Lemma dom_look h x : x \notin dom h -> look x h = dyn tt.

Lemma def0 : def empty.

Hint Resolve def0 : core.

Lemma defU h x d : def (upd h x d) = (x != null) && (def h).

Lemma defPt A x (v : A) : def (x :-> v) = (x != null).

Lemma defF h x : def (free x h) = def h.

CoInductive defUn_spec h1 h2 : bool -> Type :=
| def_false1 of ~~ def h1 : defUn_spec h1 h2 false
| def_false2 of ~~ def h2 : defUn_spec h1 h2 false
| def_false3 x of x \in dom h1 & x \in dom h2 : defUn_spec h1 h2 false
| def_true of def h1 & def h2 &
    (forall x, x \in dom h1 -> x \notin dom h2) : defUn_spec h1 h2 true.

Lemma defUn : forall h1 h2, defUn_spec h1 h2 (def (h1 :+ h2)).

Lemma defUnl h1 h2 : def (h1 :+ h2) -> def h1.

Lemma defUnr h1 h2 : def (h1 :+ h2) -> def h2.

Lemma defFUn h1 h2 x : def (h1 :+ h2) -> def (free x h1 :+ h2).

Lemma defUnF h1 h2 x : def (h1 :+ h2) -> def (h1 :+ free x h2).

Lemma undefE x : ~~ def x <-> x = Undef.

Lemma upd_inj h x d1 d2 :
        def h -> x != null -> upd h x d1 = upd h x d2 -> d1 = d2.

Lemma heap_eta h x : x \in dom h -> h = upd (free x h) x (look x h).

Lemma updU h x y d1 d2 :
        upd (upd h x d1) y d2 =
        if x == y then upd h x d2 else upd (upd h y d2) x d1.

Lemma updF h x y d :
        upd (free x h) y d =
        if x == y then upd h x d else free x (upd h y d).

Lemma updUnl h1 h2 x d :
        upd (h1 :+ h2) x d =
        if x \in dom h1 then upd h1 x d :+ h2 else h1 :+ upd h2 x d.

Lemma updUnr h1 h2 x d :
        upd (h1 :+ h2) x d =
        if x \in dom h2 then h1 :+ upd h2 x d else upd h1 x d :+ h2.

Lemma pts_injP A1 A2 x1 x2 (v1 : A1) (v2 : A2) :
        def (x1 :-> v1) -> x1 :-> v1 = x2 :-> v2 -> x1 = x2 /\ A1 = A2.

Lemma pts_injT A1 A2 x (v1 : A1) (v2 : A2) :
        def (x :-> v1) -> x :-> v1 = x :-> v2 -> A1 = A2.

Lemma pts_inj A x (v1 v2 : A) :
        def (x :-> v1) -> x :-> v1 = x :-> v2 -> v1 = v2.

Lemma free0 x : free x empty = empty.

Lemma freeU h x y d :
        free x (upd h y d) = if x == y then
          if y == null then Undef else free x h
        else upd (free x h) y d.

Lemma freeF h x y :
        free x (free y h) = if x == y then free x h else free y (free x h).

Lemma freeUn h1 h2 x :
        free x (h1 :+ h2) =
        if x \in dom (h1 :+ h2) then free x h1 :+ free x h2
        else h1 :+ h2.

Lemma freeUnD h1 h2 x :
        def (h1 :+ h2) -> free x (h1 :+ h2) = free x h1 :+ free x h2.

Lemma freeUnl h1 h2 x : x \notin dom h1 -> free x (h1 :+ h2) = h1 :+ free x h2.

Lemma freeUnr h1 h2 x : x \notin dom h2 -> free x (h1 :+ h2) = free x h1 :+ h2.

Lemma lookU h x y d :
        look x (upd h y d) = if x == y then
          if def h && (y != null) then d else dyn tt
        else if y != null then look x h else dyn tt.

Lemma lookF h x y :
        look x (free y h) = if x == y then dyn tt else look x h.

Lemma lookUnl h1 h2 x :
        def (h1 :+ h2) ->
        look x (h1 :+ h2) = if x \in dom h1 then look x h1 else look x h2.

Lemma lookUnr h1 h2 x :
        def (h1 :+ h2) ->
        look x (h1 :+ h2) = if x \in dom h2 then look x h2 else look x h1.

Lemma empP h : reflect (h = empty) (empb h).

Lemma empU h x d : empb (upd h x d) = false.

Lemma empPt A x (v : A) : empb (x :-> v) = false.

Lemma empUn h1 h2 : empb (h1 :+ h2) = empb h1 && empb h2.

Lemma empbE h : h = empty <-> empb h.

Lemma un0E h1 h2 : h1 :+ h2 = empty <-> h1 = empty /\ h2 = empty.

Lemma defE h : reflect (def h /\ forall x, x \notin dom h)(empb h).

Lemma defUnhh h : def (h :+ h) = empb h.

Lemma path_last n s x : path ord x s -> ord x (last x s).+(n+1).

Lemma path_filter (A : ordType) (s : seq A) (p : pred A) x :
        path ord x s -> path ord x (filter p s).

Lemma dom_fresh h n : (fresh h).+n \notin dom h.

Lemma fresh_null h : fresh h != null.

Opaque fresh.

Hint Resolve dom_fresh fresh_null : core.

Lemma emp_pick h : (pick h == null) = (~~ def h || empb h).

Lemma pickP h : def h && ~~ empb h = (pick h \in dom h).

Lemma subdom_def h1 h2 : subdom h1 h2 -> def h1 && def h2.

Lemma subdomP h1 h2 :
        def h1 -> ~~ empb h1 ->
        reflect (forall x, x \in dom h1 -> x \in dom h2)
                (subdom h1 h2).

Lemma subdomQ x h1 h2 : subdom h1 h2 -> x \in dom h1 -> x \in dom h2.

Lemma subdom_refl h : def h -> subdom h h.

Lemma subdomD h1 h2 h : subdom h1 h2 -> def (h2 :+ h) -> def (h1 :+ h).

Lemma subdomE h1 h2 h :
        def (h2 :+ h) -> subdom h1 h2 -> subdom (h1 :+ h) (h2 :+ h).

Lemma subdomUE h1 h2 h1' h2' :
        def (h2 :+ h2') -> subdom h1 h2 -> subdom h1' h2' ->
          subdom (h1 :+ h1') (h2 :+ h2').

Lemma subdom_emp h : def h -> subdom empty h.

Lemma subdom_emp_inv h : subdom h empty -> h = empty.

Lemma subdomPE A B x (v1 : A) (v2 : B) :
        x != null -> subdom (x :-> v1) (x :-> v2).

Lemma subdom_trans h2 h1 h3 : subdom h1 h2 -> subdom h2 h3 -> subdom h1 h3.

Hint Resolve subdom_emp subdomPE : core.

Lemma subheap_refl h : def h -> subheap h h.

Lemma subheapE h : def h -> subheap empty h.

Lemma subheapUn h1 h2 h1' h2' :
        def (h2 :+ h2') -> subheap h1 h2 -> subheap h1' h2' ->
        subheap (h1 :+ h1') (h2 :+ h2').

Lemma subheapUnl h1 h2 : def (h1 :+ h2) -> subheap h1 (h1 :+ h2).

Lemma subheapUnr h1 h2 : def (h1 :+ h2) -> subheap h2 (h1 :+ h2).

Lemma subheap_def h1 h2 : subheap h1 h2 -> def h1 /\ def h2.

Lemma subheap_trans h2 h1 h3 : subheap h1 h2 -> subheap h2 h3 -> subheap h1 h3.

Lemma subheap_id hp1 hp2: subheap hp1 hp2 -> subheap hp2 hp1 -> hp1 = hp2.

Lemma noalias h1 h2 x1 x2 :
        x1 \in dom h1 -> x2 \in dom h2 -> def (h1 :+ h2) -> x1 != x2.

Lemma defPtUn A h x (v : A) :
        def (x :-> v :+ h) = [&& x != null, def h & x \notin dom h].

Lemma defPt_null A h x (v : A) : def (x :-> v :+ h) -> x != null.

Lemma defPt_def A h x (v : A) : def (x :-> v :+ h) -> def h.

Lemma defPt_dom A h x (v : A) : def (x :-> v :+ h) -> x \notin dom h.

Lemma domPtUn A h x (v : A) :
        dom (x :-> v :+ h) =i
        [pred y | def (x :-> v :+ h) && ((x == y) || (y \in dom h))].

Lemma lookPtUn A h x (v : A) :
        def (x :-> v :+ h) -> look x (x :-> v :+ h) = dyn v.

Lemma freePtUn A h x (v : A) :
        def (x :-> v :+ h) -> free x (x :-> v :+ h) = h.

Lemma updPtUn A1 A2 x i (v1 : A1) (v2 : A2) :
        upd (x :-> v1 :+ i) x (dyn v2) = x :-> v2 :+ i.

Lemma heap_etaP h x : x \in dom h -> h = x :-> Dyn.val (look x h) :+ free x h.

Lemma cancelT A1 A2 h1 h2 x (v1 : A1) (v2 : A2) :
        def (x :-> v1 :+ h1) ->
          x :-> v1 :+ h1 = x :-> v2 :+ h2 -> A1 = A2.

Lemma cancel A h1 h2 x (v1 v2 : A) :
        def (x :-> v1 :+ h1) ->
        x :-> v1 :+ h1 = x :-> v2 :+ h2 -> [/\ v1 = v2, def h1 & h1 = h2].

Lemma domPtUnX A (v : A) x i : def (x :-> v :+ i) -> x \in dom (x :-> v :+ i).

Lemma domPtX A (v : A) x : def (x :-> v) -> x \in dom (x :-> v).

Lemma dom_notin_notin h1 h2 x :
        def (h1 :+ h2) -> x \notin dom (h1 :+ h2) -> x \notin dom h1.

Lemma dom_in_notin h1 h2 x : def (h1 :+ h2) -> x \in dom h1 -> x \notin dom h2.

Section BlockUpdate.
Variable (A : Type).

Fixpoint updi x (vs : seq A) {struct vs} : heap :=
  if vs is v'::vs' then (x :-> v') :+ updi (x .+ 1) vs' else empty.

Lemma updiS x v vs : updi x (v :: vs) = x :-> v :+ updi (x .+ 1) vs.

Lemma updi_last x v vs :
        updi x (rcons vs v) = updi x vs :+ x.+(size vs) :-> v.

Lemma updi_cat x vs1 vs2 :
        updi x (vs1 ++ vs2) = updi x vs1 :+ updi x.+(size vs1) vs2.

Lemma updi_catI x y vs1 vs2 :
        y = x.+(size vs1) -> updi x vs1 :+ updi y vs2 = updi x (vs1 ++ vs2).

Lemma updiVm' x m xs : m > 0 -> x \notin dom (updi x.+m xs).

Lemma updiD x xs : def (updi x xs) = (x != null) || (size xs == 0).

Lemma updiVm x m xs :
        x \in dom (updi x.+m xs) = [&& x != null, m == 0 & size xs > 0].

Lemma updimV x m xs :
        x.+m \in dom (updi x xs) = (x != null) && (m < size xs).

Lemma updiP x y xs :
        reflect (y != null /\ exists m, x = y.+m /\ m < size xs)

Lemma updi_inv x xs1 xs2 :
        def (updi x xs1) -> updi x xs1 = updi x xs2 -> xs1 = xs2.

Lemma updi_iinv x xs1 xs2 h1 h2 :
        size xs1 = size xs2 -> def (updi x xs1 :+ h1) ->
        updi x xs1 :+ h1 = updi x xs2 :+ h2 -> xs1 = xs2 /\ h1 = h2.

End BlockUpdate.

Definition low : pred ptr := fun x => 0 == nat_ptr x %[mod 2].
Definition high : pred ptr := fun x => 1 == nat_ptr x %[mod 2].

Definition get_lows h :=
  if h is Def hs _ then filter low (supp hs) else [::].

Definition get_highs h :=
  if h is Def hs _ then filter high (supp hs) else [::].

Definition ldom h : pred ptr := fun x => x \in get_lows h.
Definition hdom h : pred ptr := fun x => x \in get_highs h.

Lemma ldomP h x : x \in ldom h = (x \in dom h) && low x.

Lemma hdomP h x : x \in hdom h = (x \in dom h) && high x.

Lemma ldomK h1 h2 t1 t2 :
        def (h1 :+ t1) -> def (h2 :+ t2) ->
        ldom h1 =i ldom h2 ->
        ldom (h1 :+ t1) =i ldom (h2 :+ t2) -> ldom t1 =i ldom t2.

Definition lfresh h := (last null (get_lows h)) .+ 2.
Definition hfresh h := (last (null .+ 1) (get_highs h)) .+ 2.

Lemma last_inv A B (f : A -> B) (x1 x2 : A) (h : seq A) :
        f x1 = f x2 -> f (last x1 h) = f (last x2 h).

Lemma lfresh_low h n : low (lfresh h) .+ (2*n).

Lemma hfresh_high h n : high (hfresh h) .+ (2*n).

Lemma dom_lfresh h n : (lfresh h) .+ (2*n) \notin dom h.

Lemma dom_hfresh h n : (hfresh h) .+ (2*n) \notin dom h.

Lemma lfresh_null h : lfresh h != null.

Lemma hfresh_null h : hfresh h != null.

Lemma high_lowD : [predI low & high] =i pred0.

Lemma modnS x1 x2 : (x1 == x2 %[mod 2]) = (x1.+1 == x2.+1 %[mod 2]).

Lemma hlE x : high x = ~~ low x.

Lemma lhE x : low x = ~~ high x.

Lemma ldomUn h1 h2 :
        ldom (h1 :+ h2) =i
        [pred x | def (h1 :+ h2) && (x \in [predU ldom h1 & ldom h2])].

Definition loweq h1 h2 := get_lows h1 == get_lows h2.

Notation "h1 =~ h2" := (loweq h1 h2) (at level 80).

Lemma low_refl h : h =~ h.

Hint Resolve low_refl : core.

Lemma low_sym h1 h2 : (h1 =~ h2) = (h2 =~ h1).

Lemma low_trans h2 h1 h3 : h1 =~ h2 -> h2 =~ h3 -> h1 =~ h3.

Lemma loweqP h1 h2 : reflect (ldom h1 =i ldom h2) (h1 =~ h2).

Lemma loweqK h1 h2 t1 t2 :
        def (h1 :+ t1) -> def (h2 :+ t2) ->
        h1 =~ h2 -> h1 :+ t1 =~ h2 :+ t2 -> t1 =~ t2.

Lemma loweqE h1 h2 : h1 =~ h2 -> lfresh h1 = lfresh h2.

Lemma lowUn h1 h2 t1 t2 :
        def (h1 :+ t1) ->
        def (h2 :+ t2) ->
        h1 =~ h2 -> t1 =~ t2 -> h1 :+ t1 =~ h2 :+ t2.

Lemma lowPn A1 A2 (x : ptr) (v1 : A1) (v2 : A2) : x :-> v1 =~ x :-> v2.

Hint Resolve lowPn : core.

Lemma highPn A1 A2 (x1 x2 : ptr) (v1 : A1) (v2 : A2) :
        high x1 -> high x2 -> x1 :-> v1 =~ x2 :-> v2.

Lemma lowPtUn A1 A2 h1 h2 (x : ptr) (v1 : A1) (v2 : A2) :
        def (x :-> v1 :+ h1) ->
        def (x :-> v2 :+ h2) ->
        (x :-> v1 :+ h1 =~ x :-> v2 :+ h2) = (h1 =~ h2).

Lemma highPtUn A h1 h2 (x : ptr) (v : A) :
        def (x :-> v :+ h1) -> high x ->
        (x :-> v :+ h1 =~ h2) = (h1 =~ h2).

Lemma highPtUn2 A1 A2 h1 h2 (x1 x2 : ptr) (v1 : A1) (v2 : A2) :
        def (x1 :-> v1 :+ h1) ->
        def (x2 :-> v2 :+ h2) ->
        high x1 -> high x2 ->
        h1 =~ h2 -> x1 :-> v1 :+ h1 =~ x2 :-> v2 :+ h2.

Definition plus2 (h1 h2 : heap * heap) : heap * heap :=
  (h1.1 :+ h2.1, h1.2 :+ h2.2).

Definition def2 (h : heap * heap) := def h.1 && def h.2.

Notation "h1 :++ h2" := (plus2 h1 h2) (at level 50).

Lemma unA2 h1 h2 h3 : h1 :++ (h2 :++ h3) = h1 :++ h2 :++ h3.

Lemma unC2 h1 h2 : h1 :++ h2 = h2 :++ h1.

Lemma unKhl2 h h1 h2 : def2 (h1 :++ h) -> h1 :++ h = h2 :++ h -> h1 = h2.

Lemma unKhr2 h h1 h2 : def2 (h2 :++ h) -> h1 :++ h = h2 :++ h -> h1 = h2.

Lemma unDl2 h1 h2 : def2 (h1 :++ h2) -> def2 h1.

Lemma unDr2 h1 h2 : def2 (h1 :++ h2) -> def2 h2.

Lemma un0h2 h : (empty, empty) :++ h = h.

Lemma unh02 h : h :++ (empty, empty) = h.

Lemma injUh A h1 h2 x (v1 v2 : A) :
        def (h1 :+ (x :-> v1)) ->
        h1 :+ (x :-> v1) = h2 :+ (x :-> v2) ->
          def h1 /\ h1 = h2 /\ v1 = v2.

Lemma eqUh h1 h2 h : def (h1 :+ h) -> h1 :+ h = h2 :+ h -> def h1 /\ h1 = h2.

Lemma exit1 h1 h2 h : def (h1 :+ h) -> h1 :+ h = h :+ h2 -> def h1 /\ h1 = h2.

Lemma exit2 h1 h : def (h1 :+ h) -> h1 :+ h = h -> def h1 /\ h1 = empty.

Lemma exit3 h1 h : def h -> h = h :+ h1 -> def empty /\ empty = h1.

Lemma exit4 h : def h -> h = h -> def empty /\ empty = empty.

Ltac cancelator t H :=
  match goal with
  
  | |- ?h1 :+ t = ?h2 -> _ =>
     let j := fresh "j" in
     set j := {1}(h1 :+ t);
     rewrite -1?unA /j {j};
     (move/(exit1 H)=>{H} [H] || move/(exit2 H)=>{H} [H])
  | |- t = ?h2 -> _ =>
     rewrite -?unA;
     (move/(exit3 H)=>{H} [H] || move/(exit4 H)=>{H} [H])
  | |- (?h1 :+ (?x :-> ?v) = ?h2) -> _ =>
    let j := fresh "j" in
    set j := {1}(h1 :+ (x :-> v));
    
    rewrite 1?(unC (x :-> _)) -?(unAC _ _ (x :-> _)) /j {j};
    
    (move/(injUh H)=>{H} [H []] ||
    
     rewrite (unC h1) ?unA in H * );
    
    cancelator t H
  
  | |- (?h1 :+ ?h = ?h2) -> _ =>
    let j := fresh "j" in
    set j := {1}(h1 :+ h);
    
    rewrite 1?(unC h) -?(unAC _ _ h) /j {j};
    
    (move/(eqUh H)=>{H} [H []] ||
    
    rewrite (unC h1) ?unA in H * );
    
    cancelator t H
  | |- _ => idtac
  end.

Ltac heap_cancel :=
  match goal with
  | |- ?h1 = ?h2 -> ?GG =>
    let t1 := fresh "t1" in
    let t2 := fresh "t2" in
    let t := fresh "t" in
    let H := fresh "H" in
    let G := fresh "hidden_goal"
    in
      
      suff : def h1; first (
       
       set t1 := {1 2}h1; set t2 := {1}h2; set G := GG;
       
       rewrite -(un0h t1) -(un0h t2) [empty]lock;
       set t := locked empty; rewrite /t1 /t2 {t1 t2};
       move=>H;
       
       rewrite ?unA in H *;
       
       cancelator t H;
       
       move: H {t}; rewrite /G {G})
  | |- _ => idtac
  end.

Lemma cexit1 h1 h2 h : h1 = h2 -> h1 :+ h = h :+ h2.

Lemma cexit2 h1 h : h1 = empty -> h1 :+ h = h.

Lemma cexit3 h1 h : empty = h1 -> h = h :+ h1.

Lemma congUh A h1 h2 x (v1 v2 : A) :
        h1 = h2 -> v1 = v2 -> h1 :+ (x :-> v1) = h2 :+ (x :-> v2).

Lemma congeqUh h1 h2 h : h1 = h2 -> h1 :+ h = h2 :+ h.

Ltac congruencer t :=
  match goal with
  | |- ?h1 :+ t = ?h2 =>
     let j := fresh "j" in
     set j := {1}(h1 :+ t);
     rewrite -1?unA /j {j};
     (apply: cexit1 || apply: cexit2)
  | |- t = ?h2 =>
     rewrite -1?unA;
     (apply: cexit3 || apply: refl_equal)
  | |- (?h1 :+ (?x :-> ?v) = ?h2) =>
    let j := fresh "j" in
    set j := {1}(h1 :+ (x :-> v));
    
    rewrite 1?(unC (x :-> _)) -?(unAC _ _ (x :-> _)) /j {j};
    
    ((apply: congUh; [congruencer t | idtac]) ||
    
     (rewrite (unC h1) ?unA; congruencer t))
  
  | |- (?h1 :+ ?h = ?h2) =>
    let j := fresh "j" in
    set j := {1}(h1 :+ h);
    
    rewrite 1?(unC h) -?(unAC _ _ h) /j {j};
    
    (apply: congeqUh ||
    
    rewrite (unC h1) ?unA);
    
    congruencer t
  | |- _ => idtac
  end.

Ltac heap_congr :=
  match goal with
  | |- ?h1 = ?h2 =>
    let t1 := fresh "t1" in
    let t2 := fresh "t2" in
    let t := fresh "t" in
      set t1 := {1}h1; set t2 := {1}h2;
      
      rewrite -(un0h t1) -(un0h t2) [empty]lock;
      set t := locked empty; rewrite /t1 /t2 {t1 t2};
      
      rewrite ?unA;
      
      congruencer t=>{t}
  | |- _ => idtac
  end.

Lemma test h1 h2 h3 x (v1 v2 : nat) :
        h3 = h2 -> v1 = v2 ->
        h1 :+ (x :-> v1) :+ h3= h2 :+ h1 :+ (x :-> v2).

Definition supdom h2 h1 := subdom h1 h2.

Lemma sexit1 h1 h2 h :
        def (h2 :+ h) ->
          (def h2 -> supdom h2 h1) -> supdom (h2 :+ h) (h :+ h1).

Lemma sexit2 h1 h :
        def (h1 :+ h) -> (def h1 -> supdom h1 empty) ->
          supdom (h1 :+ h) h.

Lemma sexit3 h1 h :
        def h -> (def empty -> supdom empty h1) ->
          supdom h (h :+ h1).

Lemma sexit4 h : def h -> (def empty -> empty = empty) -> supdom h h.

Lemma supdomUh A B h1 h2 x (v1 : A) (v2 : B) :
        def (h2 :+ (x :-> v2)) ->
          (def h2 -> supdom h2 h1) ->
            supdom (h2 :+ (x :-> v2)) (h1 :+ (x :-> v1)).

Lemma supdomeqUh h1 h2 h :
        def (h2 :+ h) -> (def h2 -> supdom h2 h1) -> supdom (h2 :+ h) (h1 :+ h).

Lemma sup_defdef h1 h2 : def h2 -> supdom h2 h1 -> def h1.

Ltac supdom_checker t H :=
  match goal with
  | |- is_true (supdom (?h1 :+ t) ?h2) =>
     let j := fresh "j" in
     set j := {1}(h1 :+ t);
     rewrite -1?unA /j {j};
     (apply: (sexit1 H)=>{H} H || apply: (sexit2 H)=>{H} H)
  | |- is_true (supdom t ?h1) =>
     rewrite -1?unA;
     (apply: (sexit3 H)=>{H} H || apply: (sexit4 H)=>{H} H)
  | |- is_true (supdom (?h1 :+ (?x :-> ?v)) ?h2) =>
    let j := fresh "j" in
    set j := {1}(h1 :+ (x :-> v));
    
    rewrite 1?(unC (x :-> _)) -?(unAC _ _ (x :-> _)) /j {j};
    
    (apply: (supdomUh _ H)=>{H} H ||
    
     (rewrite (unC h1) ?unA in H * )); supdom_checker t H
  
  | |- is_true (supdom (?h1 :+ ?h) ?h2) =>
    let j := fresh "j" in
    set j := {1}(h1 :+ h);
    
    rewrite 1?(unC h) -?(unAC _ _ h) /j {j};
    
    (apply: (supdomeqUh H)=>{H} H ||
    
    (rewrite (unC h1) ?unA in H * ));
    
    supdom_checker t H
  | |- _ => idtac
  end.

Ltac defcheck :=
  match goal with
  | |- is_true (def ?h2) -> is_true (def ?h1) =>
    let t1 := fresh "t1" in
    let t2 := fresh "t2" in
    let t := fresh "t" in
    let H := fresh "H" in
      set t2 := {1}h2; set t1 := {1}h1;
      
      rewrite -(un0h t1) -(un0h t2) [empty]lock;
      set t := locked empty; rewrite /t1 /t2 {t1 t2};
      
      rewrite ?unA;
      move=>H;
      apply: (sup_defdef H);
      
      supdom_checker t H; move: H {t}; rewrite /supdom
  | |- _ => idtac
  end.

Ltac hhauto := (do ?econstructor=>//; try by [heap_congr])=>//. *)
(* rels:
From mathcomp
Require Import ssreflect ssrfun ssrbool seq.
Require Import Setoid.
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Lemma andTp p : True /\ p <-> p.      Proof. by intuition. Qed.
Lemma andFp p : False /\ p <-> False. Proof. by intuition. Qed.
Lemma orTp p : True \/ p <-> True.    Proof. by intuition. Qed.
Lemma orFp p : False \/ p <-> p.      Proof. by intuition. Qed.

Delimit Scope rel_scope with rel.
Open Scope rel_scope.

Definition Pred T := T -> Prop.
Identity Coercion fun_of_Pred : Pred >-> Funclass.

Notation xPred0 := (fun _ => False).
Notation xPred1 := (fun x y => x = y).
Notation xPredT := (fun _ => True).
Notation xPredI := (fun (p1 p2 : Pred _) x => p1 x /\ p2 x).
Notation xPredU := (fun (p1 p2 : Pred _) x => p1 x \/ p2 x).
Notation xPredC := (fun (p : Pred _) x => ~ p x).
Notation xPredD := (fun (p1 p2 : Pred _) x => ~ p2 x /\ p1 x).
Notation xPreim := (fun f (p : Pred _) x => p (f x)).

Section Predicates.
Variable T : Type.

Definition Simpl_Pred := simpl_fun T Prop.
Definition SimplPred (p : Pred T) : Simpl_Pred := SimplFun p.
Coercion Pred_of_Simpl (p : Simpl_Pred) : Pred T := p : T -> Prop.

Definition Pred0 := SimplPred xPred0.
Definition Pred1 x := SimplPred (xPred1 x).
Definition PredT := SimplPred xPredT.
Definition PredI p1 p2 := SimplPred (xPredI p1 p2).
Definition PredU p1 p2 := SimplPred (xPredU p1 p2).
Definition PredC p := SimplPred (xPredC p).
Definition PredD p1 p2 := SimplPred (xPredD p1 p2).
Definition Preim rT f (d : Pred rT) := SimplPred (xPreim f d).

CoInductive Mem_Pred : Type := MemProp of Pred T.
Definition isMem pT toPred mem := mem = (fun p : pT => MemProp [eta toPred p]).

Structure PredType : Type := PropPredType {
  Pred_Sort :> Type;
  toPred : Pred_Sort -> Pred T;
  _ : {mem | isMem toPred mem}}.

Definition mkPredType pT toP := PropPredType (exist (@isMem pT toP) _ (erefl _)).

Canonical Structure PredPredType := Eval hnf in @mkPredType (Pred T) id.
Canonical Structure SimplPredPredType := Eval hnf in mkPredType Pred_of_Simpl.
Coercion Pred_of_Mem mp : Pred_Sort PredPredType :=
  let: MemProp p := mp in [eta p].
Canonical Structure MemPredType := Eval hnf in mkPredType Pred_of_Mem.
Canonical Structure predPredType := Eval hnf in @mkPredType (pred T) id.
Canonical Structure simplpredPredType :=
  Eval hnf in @mkPredType (simpl_pred T) (fun p x => p x).

End Predicates.

Arguments Pred0 {T}.
Arguments PredT {T}.
Prenex Implicits PredI PredU PredC PredD Preim.

Notation "r1 +p r2" := (PredU r1 r2)
  (at level 55, right associativity) : rel_scope.
Notation "r1 *p r2" := (PredI r1 r2)
  (at level 45, right associativity) : rel_scope.

Notation "[ 'Pred' : T | E ]" := (SimplPred (fun _ : T => E))
  (at level 0, format "[ 'Pred' :  T  |  E ]") : fun_scope.
Notation "[ 'Pred' x | E ]" := (SimplPred (fun x => E))
  (at level 0, x ident, format "[ 'Pred'  x  |  E ]") : fun_scope.
Notation "[ 'Pred' x : T | E ]" := (SimplPred (fun x : T => E))
  (at level 0, x ident, only parsing) : fun_scope.
Notation "[ 'Pred' x y | E ]" := (SimplPred (fun t => let: (x, y) := t in E))
  (at level 0, x ident, y ident, format "[ 'Pred'  x  y  |  E ]") : fun_scope.
Notation "[ 'Pred' x y : T | E ]" :=
  (SimplPred (fun t : (T*T) => let: (x, y) := t in E))
  (at level 0, x ident, y ident, only parsing) : fun_scope.

Definition repack_Pred T pT :=
  let: PropPredType _ a mP := pT return {type of @PropPredType T for pT} -> _ in
   fun k => k a mP.

Notation "[ 'PredType' 'of' T ]" := (repack_Pred (fun a => @PropPredType _ T a))
  (at level 0, format "[ 'PredType'  'of'  T ]") : form_scope.

Notation Pred_Class := (Pred_Sort (PredPredType _)).
Coercion Sort_of_Simpl_Pred T (p : Simpl_Pred T) : Pred_Class := p : Pred T.

Definition PredArgType := Type.
Coercion Pred_of_argType (T : PredArgType) : Simpl_Pred T := PredT.

Notation "{ :: T }" := (T%type : PredArgType)
  (at level 0, format "{ ::  T }") : type_scope.

Definition Mem T (pT : PredType T) : pT -> Mem_Pred T :=
  nosimpl (let: PropPredType _ _ (exist mem _) := pT return pT -> _ in mem).
Definition InMem T x mp := nosimpl Pred_of_Mem T mp x.

Prenex Implicits Mem.

Coercion Pred_of_Mem_Pred T mp := [Pred x : T | InMem x mp].

Definition EqPredType T (pT : PredType T) (p1 p2 : pT) :=
  forall x : T, toPred p1 x <-> toPred p2 x.

Definition SubPredType T (pT : PredType T) (p1 p2 : pT) :=
  forall x : T, toPred p1 x -> toPred p2 x.

Definition EqPred T (p1 p2 : Pred T) := EqPredType p1 p2.
Definition SubPred T (p1 p2 : Pred T) := SubPredType p1 p2.
Definition EqSimplPred T (p1 p2 : Simpl_Pred T) := EqPredType p1 p2.
Definition SubSimplPred T (p1 p2 : Simpl_Pred T) := SubPredType p1 p2.

Definition EqPredFun T1 T2 p1 p2 :=
  forall x : T1, @EqPred T2 (p1 x) (p2 x).
Definition SubPredFun T1 T2 p1 p2 :=
  forall x : T1, @SubPred T2 (p1 x) (p2 x).

Definition EqMem T p1 p2 := forall x : T, InMem x p1 <-> InMem x p2.
Definition SubMem T p1 p2 := forall x : T, InMem x p1 -> InMem x p2.

Notation "A <~> B" := (EqPred A B)
  (at level 70, no associativity) : rel_scope.
Notation "A ~> B" := (SubPred A B)
  (at level 70, no associativity) : rel_scope.
Notation "A <~1> B" := (EqPredFun A B)
  (at level 70, no associativity) : rel_scope.
Notation "A ~1> B" := (SubPredFun A B)
  (at level 70, no associativity) : rel_scope.

Notation "x \In A" := (InMem x (Mem A))
  (at level 70, no associativity) : rel_scope.
Notation "x \Notin A" := (~ (x \In A))
  (at level 70, no associativity) : rel_scope.
Notation "A =p B" := (EqMem (Mem A) (Mem B))
  (at level 70, no associativity) : type_scope.
Notation "A <=p B" := (SubMem (Mem A) (Mem B))
  (at level 70, no associativity) : type_scope.

Notation "[ 'Mem' A ]" := (Pred_of_Simpl (Pred_of_Mem_Pred (Mem A)))
  (at level 0, only parsing) : fun_scope.
Notation "[ 'PredI' A & B ]" := (PredI [Mem A] [Mem B])
  (at level 0, format "[ 'PredI'  A  &  B ]") : fun_scope.
Notation "[ 'PredU' A & B ]" := (PredU [Mem A] [Mem B])
  (at level 0, format "[ 'PredU'  A  &  B ]") : fun_scope.
Notation "[ 'PredD' A & B ]" := (PredD [Mem A] [Mem B])
  (at level 0, format "[ 'PredD'  A  &  B ]") : fun_scope.
Notation "[ 'PredC' A ]" := (PredC [Mem A])
  (at level 0, format "[ 'PredC'  A ]") : fun_scope.
Notation "[ 'Preim' f 'of' A ]" := (Preim f [Mem A])
  (at level 0, format "[ 'Preim'  f  'of'  A ]") : fun_scope.

Notation "[ 'Pred' x \In A ]" := [Pred x | x \In A]
  (at level 0, x ident, format "[ 'Pred'  x  \In  A ]") : fun_scope.
Notation "[ 'Pred' x \In A | E ]" := [Pred x | (x \In A) /\ E]
  (at level 0, x ident, format "[ 'Pred'  x  \In  A  |  E ]") : fun_scope.
Notation "[ 'Pred' x y \In A & B | E ]" :=
  [Pred x y | (x \In A) /\ (y \In B) /\ E]
  (at level 0, x ident, y ident,
   format "[ 'Pred'  x  y  \In  A  &  B  |  E ]") : fun_scope.
Notation "[ 'Pred' x y \In A & B ]" := [Pred x y | (x \In A) /\ (y \In B)]
  (at level 0, x ident, y ident,
   format "[ 'Pred'  x  y  \In  A  &  B ]") : fun_scope.
Notation "[ 'Pred' x y \In A | E ]" := [Pred x y \In A & A | E]
  (at level 0, x ident, y ident,
   format "[ 'Pred'  x  y  \In  A  |  E ]") : fun_scope.
Notation "[ 'Pred' x y \In A ]" := [Pred x y \In A & A]
  (at level 0, x ident, y ident,
   format "[ 'Pred'  x  y  \In  A ]") : fun_scope.

Section Simplifications.
Variables (T : Type) (pT : PredType T).

Lemma Mem_toPred : forall (p : pT), Mem (toPred p) = Mem p.

Lemma toPredE : forall x (p : pT), toPred p x = (x \In p).

Lemma In_Simpl : forall x (p : Simpl_Pred T), (x \In p) = p x.

Lemma Simpl_PredE : forall (p : Pred T), [Pred x | p x] <~> p.

Lemma Mem_Simpl : forall (p : Simpl_Pred T), Mem p = p :> Pred T.

Definition MemE := Mem_Simpl. 

Lemma Mem_Mem : forall p : pT, (Mem (Mem p) = Mem p) * (Mem [Mem p] = Mem p).

End Simplifications.

Section RelProperties.
Variables (T : Type) (pT : PredType T).

Lemma EqPredType_refl (r : pT) : EqPredType r r. Proof. by []. Qed.

Lemma EqPredType_sym (r1 r2 : pT) : EqPredType r1 r2 -> EqPredType r2 r1.

Lemma EqPredType_trans' (r1 r2 r3 : pT) :
  EqPredType r1 r2 -> EqPredType r2 r3 -> EqPredType r1 r3.

Lemma SubPredType_trans' (r1 r2 r3 : pT) :
  SubPredType r1 r2 -> SubPredType r2 r3 -> SubPredType r1 r3.

Definition EqPredType_trans r2 r1 r3 := @EqPredType_trans' r1 r2 r3.
Definition SubPredType_trans r2 r1 r3 := @SubPredType_trans' r1 r2 r3.

Section RelLaws.
Variable (T : Type).

Lemma orrI (r : Pred T) : r +p r <~> r.

Lemma orrC (r1 r2 : Pred T) : r1 +p r2 <~> r2 +p r1.

Lemma orr0 (r : Pred T) : r +p Pred0 <~> r.

Lemma or0r (r : Pred T) : Pred0 +p r <~> r.

Lemma orrCA (r1 r2 r3 : Pred T) : r1 +p r2 +p r3 <~> r2 +p r1 +p r3.

Lemma orrAC (r1 r2 r3 : Pred T) : (r1 +p r2) +p r3 <~> (r1 +p r3) +p r2.

Lemma orrA (r1 r2 r3 : Pred T) : (r1 +p r2) +p r3 <~> r1 +p r2 +p r3.

Lemma orrAb (r1 a : Pred T) : r1 <~> r1 +p a <-> a ~> r1.

Lemma sub_orl (r1 r2 : Pred T) : r1 ~> r1 +p r2. Proof. by left. Qed.

End RelLaws.

Section SubMemLaws.
Variable T : Type.

Lemma subp_refl (p : Pred T) : p <=p p.

Lemma subp_asym (p1 p2 : Pred T) : p1 <=p p2 -> p2 <=p p1 -> p1 =p p2.

Lemma subp_trans (p2 p1 p3 : Pred T) : p1 <=p p2 -> p2 <=p p3 -> p1 <=p p3.

Lemma subp_or (p1 p2 q : Pred T) : p1 <=p q /\ p2 <=p q <-> p1 +p p2 <=p q.

Lemma subp_and (p1 p2 q : Pred T) : q <=p p1 /\ q <=p p2 <-> q <=p p1 *p p2.

Lemma subp_orl (p1 p2 q : Pred T) : p1 <=p p2 -> p1 +p q <=p p2 +p q.

Lemma subp_orr (p1 p2 q : Pred T) : p1 <=p p2 -> q +p p1 <=p q +p p2.

Lemma subp_andl (p1 p2 q : Pred T) : p1 <=p p2 -> p1 *p q <=p p2 *p q.

Lemma subp_andr (p1 p2 q : Pred T) : p1 <=p p2 -> q *p p1 <=p q *p p2.

End SubMemLaws.

Hint Resolve subp_refl : core.

Section ListMembership.
Variable T : Type.

Fixpoint Mem_Seq (s : seq T) :=
  if s is y::s' then (fun x => x = y \/ Mem_Seq s' x) else xPred0.

Definition EqSeq_Class := seq T.
Identity Coercion seq_of_EqSeq : EqSeq_Class >-> seq.

Coercion Pred_of_Eq_Seq (s : EqSeq_Class) : Pred_Class := [eta Mem_Seq s].

Canonical Structure seq_PredType := @mkPredType T (seq T) Pred_of_Eq_Seq.

Canonical Structure Mem_Seq_PredType := mkPredType Mem_Seq.

Lemma In_cons : forall y s x, (x \In y :: s) <-> (x = y) \/ (x \In s).

Lemma In_nil : forall x, (x \In [::]) <-> False.

Lemma Mem_Seq1 : forall x y, (x \In [:: y]) <-> (x = y).

Definition InE := (Mem_Seq1, In_cons, In_Simpl).
Lemma eqfun_sym A B (f1 f2 : A -> B) : f1 =1 f2 -> f2 =1 f1.
Lemma eqfun_trans A B (f1 f2 f3 : A -> B) : f1 =1 f2 -> f2 =1 f3 -> f1 =1 f3.

Add Parametric Relation A B : (A -> B) (@eqfun _ _)
  reflexivity proved by (@eqfun_refl A B)
  symmetry proved by (@eqfun_sym A B)
  transitivity proved by (@eqfun_trans A B) as eqfun_morph. *)
(* hprop:
From mathcomp
Require Import ssreflect ssrfun.
From LemmaOverloading
Require Import rels heaps.
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Ltac add_morphism_tactic := SetoidTactics.add_morphism_tactic.
Notation " R ===> R' " := (@Morphisms.respectful _ _ R R')
  (right associativity, at level 55) : signature_scope.

Definition star (p1 p2 : Pred heap) : Pred heap :=
  [Pred h | exists h1, exists h2, h = h1 :+ h2 /\ h1 \In p1 /\ h2 \In p2].

Definition emp : Pred heap := [Pred i | i = empty].
Definition this i : Pred heap := [Pred h : heap | i = h].
Definition ppts A x (v : A) : Pred heap := [Pred h | locked x :-> v = h].
Definition top : Pred heap := PredT.

Section BasicProperties.

Lemma starC p1 p2 : p1 # p2 <~> p2 # p1.

Lemma starp0 p : p # emp <~> p.

Lemma star0p p : emp # p <~> p.

Lemma starCA p1 p2 p3 : p1 # p2 # p3 <~> p2 # p1 # p3.

Lemma starA p1 p2 p3 : (p1 # p2) # p3 <~> p1 # p2 # p3.

Lemma starAC p1 p2 p3 : (p1 # p2) # p3 <~> (p1 # p3) # p2.

End BasicProperties. *)
(* domains:
From mathcomp
Require Import ssreflect ssrbool ssrfun ssrnat eqtype.
From LemmaOverloading
Require Import rels prelude.
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Module Poset.

Section RawMixin.

Record mixin_of (T : Type) := Mixin {
  mx_leq : T -> T -> Prop;
  mx_bot : T;
  _ : forall x, mx_leq mx_bot x;
  _ : forall x, mx_leq x x;
  _ : forall x y, mx_leq x y -> mx_leq y x -> x = y;
  _ : forall x y z, mx_leq x y -> mx_leq y z -> mx_leq x z}.

End RawMixin.

Section ClassDef.

Record class_of T := Class {mixin : mixin_of T}.

Structure type : Type := Pack {sort : Type; _ : class_of sort; _ : Type}.
Local Coercion sort : type >-> Sortclass.

Variables (T : Type) (cT : type).
Definition class := let: Pack _ c _ as cT' := cT return class_of cT' in c.
Definition clone c of phant_id class c := @Pack T c T.

Definition pack (m0 : mixin_of T) :=
  fun m & phant_id m0 m => Pack (@Class T m) T.

Definition leq := mx_leq (mixin class).
Definition bot := mx_bot (mixin class).

End ClassDef.

Module Exports.
Coercion sort : type >-> Sortclass.
Notation poset := Poset.type.
Notation PosetMixin := Poset.Mixin.
Notation Poset T m := (@pack T _ m id).

Notation "[ 'poset' 'of' T 'for' cT ]" := (@clone T cT _ id)
  (at level 0, format "[ 'poset'  'of'  T  'for'  cT ]") : form_scope.
Notation "[ 'poset' 'of' T ]" := (@clone T _ _ id)
  (at level 0, format "[ 'poset'  'of'  T ]") : form_scope.

Notation "x <== y" := (Poset.leq x y) (at level 70).
Notation bot := Poset.bot.

Arguments Poset.bot [cT].
Prenex Implicits Poset.bot.

Section Laws.
Variable T : poset.

Lemma botP (x : T) : bot <== x.

Lemma poset_refl (x : T) : x <== x.

Lemma poset_asym (x y : T) : x <== y -> y <== x -> x = y.

Lemma poset_trans (y x z : T) : x <== y -> y <== z -> x <== z.

End Laws.

Hint Resolve botP poset_refl : core.

Add Parametric Relation (T : poset) : T (@Poset.leq T)
  reflexivity proved by (@poset_refl _)
  transitivity proved by (fun x y => @poset_trans _ y x) as poset_rel.

End Exports.

End Poset.

Export Poset.Exports.

Definition monotone (T1 T2 : poset) (f : T1 -> T2) :=
  forall x y, x <== y -> f x <== f y.

Section IdealDef.
Variable T : poset.

Structure ideal (P : T) := Ideal {id_val : T; id_pf : id_val <== P}.

Lemma relaxP (P1 P2 : T) : P1 <== P2 -> forall p, p <== P1 -> p <== P2.

Definition relax (P1 P2 : T) (x : ideal P1) (pf : P1 <== P2) :=
  Ideal (relaxP pf (id_pf x)).

End IdealDef.

Section SubPoset.
Variables (T : poset) (s : Pred T) (C : bot \In s).

Local Notation tp := {x : T | x \In s}.

Definition sub_bot : tp := exist _ bot C.
Definition sub_leq (p1 p2 : tp) := sval p1 <== sval p2.

Lemma sub_botP x : sub_leq sub_bot x.

Lemma sub_refl x : sub_leq x x.

Lemma sub_asym x y : sub_leq x y -> sub_leq y x -> x = y.

Lemma sub_trans x y z : sub_leq x y -> sub_leq y z -> sub_leq x z.

Definition subPosetMixin := PosetMixin sub_botP sub_refl sub_asym sub_trans.
Definition subPoset := Eval hnf in Poset tp subPosetMixin.

End SubPoset.

Section PairPoset.
Variable (A B : poset).
Local Notation tp := (A * B)%type.

Definition pair_bot : tp := (bot, bot).
Definition pair_leq (p1 p2 : tp) := p1.1 <== p2.1 /\ p1.2 <== p2.2.

Lemma pair_botP x : pair_leq pair_bot x.

Lemma pair_refl x : pair_leq x x.

Lemma pair_asym x y : pair_leq x y -> pair_leq y x -> x = y.

Lemma pair_trans x y z : pair_leq x y -> pair_leq y z -> pair_leq x z.

Definition pairPosetMixin :=
  PosetMixin pair_botP pair_refl pair_asym pair_trans.
Canonical pairPoset := Eval hnf in Poset tp pairPosetMixin.

End PairPoset.

Section FunPoset.
Variable (A : Type) (B : poset).
Local Notation tp := (A -> B).

Definition fun_bot : tp := fun x => bot.
Definition fun_leq (p1 p2 : tp) := forall x, p1 x <== p2 x.

Lemma fun_botP x : fun_leq fun_bot x.

Lemma fun_refl x : fun_leq x x.

Lemma fun_asym x y : fun_leq x y -> fun_leq y x -> x = y.

Lemma fun_trans x y z : fun_leq x y -> fun_leq y z -> fun_leq x z.

Definition funPosetMixin := PosetMixin fun_botP fun_refl fun_asym fun_trans.
Canonical funPoset := Eval hnf in Poset tp funPosetMixin.

End FunPoset.

Section DFunPoset.
Variables (A : Type) (B : A -> poset).
Local Notation tp := (forall x, B x).

Definition dfun_bot : tp := fun x => bot.
Definition dfun_leq (p1 p2 : tp) := forall x, p1 x <== p2 x.

Lemma dfun_botP x : dfun_leq dfun_bot x.

Lemma dfun_refl x : dfun_leq x x.

Lemma dfun_asym x y : dfun_leq x y -> dfun_leq y x -> x = y.

Lemma dfun_trans x y z : dfun_leq x y -> dfun_leq y z -> dfun_leq x z.

Definition dfunPosetMixin :=
  PosetMixin dfun_botP dfun_refl dfun_asym dfun_trans.
Definition dfunPoset := Eval hnf in Poset tp dfunPosetMixin.

End DFunPoset.

Section IdealPoset.
Variable (T : poset) (P : T).

Definition ideal_bot :=  Ideal (botP P).
Definition ideal_leq (p1 p2 : ideal P) := id_val p1 <== id_val p2.

Lemma ideal_botP x : ideal_leq ideal_bot x.

Lemma ideal_refl x : ideal_leq x x.

Lemma ideal_asym x y : ideal_leq x y -> ideal_leq y x -> x = y.

Lemma ideal_trans x y z : ideal_leq x y -> ideal_leq y z -> ideal_leq x z.

Definition idealPosetMixin :=
  PosetMixin ideal_botP ideal_refl ideal_asym ideal_trans.
Canonical idealPoset := Eval hnf in Poset (ideal P) idealPosetMixin.

End IdealPoset.

Section PropPoset.

Definition prop_bot := False.
Definition prop_leq (p1 p2 : Prop) := p1 -> p2.

Lemma prop_botP x : prop_leq prop_bot x.

Lemma prop_refl x : prop_leq x x.

Lemma prop_asym x y : prop_leq x y -> prop_leq y x -> x = y.

Lemma prop_trans x y z : prop_leq x y -> prop_leq y z -> prop_leq x z.

Definition propPosetMixin :=
  PosetMixin prop_botP prop_refl prop_asym prop_trans.
Canonical propPoset := Eval hnf in Poset Prop propPosetMixin.

End PropPoset.

Section PredPoset.
Variable A : Type.

Definition predPosetMixin : Poset.mixin_of (Pred A) :=
  funPosetMixin A propPoset.
Canonical predPoset := Eval hnf in Poset (Pred A) predPosetMixin.

End PredPoset.

Section NatPoset.

Lemma nat_botP x : 0 <= x. Proof. by []. Qed.

Lemma nat_asym x y : x <= y -> y <= x -> x = y.

Lemma nat_trans x y z : x <= y -> y <= z -> x <= z.

Definition natPosetMixin := PosetMixin nat_botP nat_refl nat_asym nat_trans.
Canonical natPoset := Eval hnf in Poset nat natPosetMixin.

End NatPoset.

Module Lattice.

Section RawMixin.

Variable T : poset.

Record mixin_of := Mixin {
  mx_sup : Pred T -> T;
  _ : forall (s : Pred T) x, x \In s -> x <== mx_sup s;
  _ : forall (s : Pred T) x,
        (forall y, y \In s -> y <== x) -> mx_sup s <== x}.

End RawMixin.

Section ClassDef.

Record class_of (T : Type) := Class {
  base : Poset.class_of T;
  mixin : mixin_of (Poset.Pack base T)}.

Local Coercion base : class_of >-> Poset.class_of.

Structure type : Type := Pack {sort : Type; _ : class_of sort; _ : Type}.
Local Coercion sort : type >-> Sortclass.

Variables (T : Type) (cT : type).
Definition class := let: Pack _ c _ as cT' := cT return class_of cT' in c.
Definition clone c of phant_id class c := @Pack T c T.

Definition pack b0 (m0 : mixin_of (Poset.Pack b0 T)) :=
  fun m & phant_id m0 m => Pack (@Class T b0 m) T.

Definition sup (s : Pred cT) : cT := mx_sup (mixin class) s.

Definition poset := Poset.Pack class cT.

End ClassDef.

Module Exports.
Coercion base : class_of >-> Poset.class_of.
Coercion sort : type >-> Sortclass.
Coercion poset : type >-> Poset.type.
Canonical Structure poset.

Notation lattice := Lattice.type.
Notation LatticeMixin := Lattice.Mixin.
Notation Lattice T m := (@pack T _ _ m id).

Notation "[ 'lattice' 'of' T 'for' cT ]" := (@clone T cT _ id)
  (at level 0, format "[ 'lattice'  'of'  T  'for' cT ]") : form_scope.
Notation "[ 'lattice' 'of' T ]" := (@clone T _ _ id)
  (at level 0, format "[ 'lattice'  'of'  T ]") : form_scope.

Arguments Lattice.sup [cT].
Prenex Implicits Lattice.sup.
Notation sup := Lattice.sup.

Section Laws.
Variable T : lattice.

Lemma supP (s : Pred T) x : x \In s -> x <== sup s.

Lemma supM (s : Pred T) x : (forall y, y \In s -> y <== x) -> sup s <== x.

End Laws.

End Exports.

End Lattice.

Export Lattice.Exports.

Section Infimum.
Variable T : lattice.

Definition inf (s : Pred T) :=
  sup [Pred x : T | forall y, y \In s -> x <== y].

Lemma infP s : forall x, x \In s -> inf s <== x.

Lemma infM s : forall x, (forall y, y \In s -> x <== y) -> x <== inf s.

End Infimum.

Section Lat.
Variable T : lattice.

Definition tarski_lfp (f : T -> T) := inf [Pred x : T | f x <== x].
Definition tarski_gfp (f : T -> T) := sup [Pred x : T | x <== f x].

Definition sup_closed (T : lattice) :=
  [Pred s : Pred T |
     bot \In s /\ forall d, d <=p s -> sup d \In s].

Definition sup_closure (T : lattice) (s : Pred T) :=
  [Pred p : T | forall t : Pred T, s <=p t -> t \In sup_closed T -> p \In t].

End Lat.

Arguments sup_closed [T].
Arguments sup_closure [T].
Prenex Implicits sup_closed sup_closure.

Section BasicProperties.
Variable T : lattice.

Lemma sup_mono (s1 s2 : Pred T) : s1 <=p s2 -> sup s1 <== sup s2.

Lemma supE (s1 s2 : Pred T) : s1 =p s2 -> sup s1 = sup s2.

Lemma tarski_lfp_fixed (f : T -> T) :
        monotone f -> f (tarski_lfp f) = tarski_lfp f.

Lemma tarski_lfp_least f : forall x : T, f x = x -> tarski_lfp f <== x.

Lemma tarski_gfp_fixed (f : T -> T) :
        monotone f -> f (tarski_gfp f) = tarski_gfp f.

Lemma tarski_gfp_greatest f : forall x : T, f x = x -> x <== tarski_gfp f.

Lemma sup_clos_sub (s : Pred T) : s <=p sup_closure s.

Lemma sup_clos_min (s : Pred T) :
        forall t, s <=p t -> sup_closed t -> sup_closure s <=p t.

Lemma sup_closP (s : Pred T) : sup_closed (sup_closure s).

Lemma sup_clos_idemp (s : Pred T) : sup_closed s -> sup_closure s =p s.

Lemma sup_clos_mono (s1 s2 : Pred T) :
        s1 <=p s2 -> sup_closure s1 <=p sup_closure s2.

End BasicProperties.

Section SubLattice.
Variables (T : lattice) (s : Pred T) (C : sup_closed s).
Local Notation tp := (subPoset (proj1 C)).

Definition sub_sup' (u : Pred tp) : T :=
  sup [Pred x : T | exists y, y \In u /\ x = sval y].

Lemma sub_supX (u : Pred tp) : sub_sup' u \In s.

Definition sub_sup (u : Pred tp) : tp :=
  exist _ (sub_sup' u) (sub_supX u).

Lemma sub_supP (u : Pred tp) (x : tp) : x \In u -> x <== sub_sup u.

Lemma sub_supM (u : Pred tp) (x : tp) :
        (forall y, y \In u -> y <== x) -> sub_sup u <== x.

Definition subLatticeMixin := LatticeMixin sub_supP sub_supM.
Definition subLattice := Eval hnf in Lattice {x : T | x \In s} subLatticeMixin.

End SubLattice.

Section PairLattice.
Variables (A B : lattice).
Local Notation tp := (A * B)%type.

Definition pair_sup (s : Pred tp) : tp :=
            (sup [Pred p | exists f, p = f.1 /\ f \In s],
             sup [Pred p | exists f, p = f.2 /\ f \In s]).

Lemma pair_supP (s : Pred tp) (p : tp) : p \In s -> p <== pair_sup s.

Lemma pair_supM (s : Pred tp) (p : tp) :
        (forall q, q \In s -> q <== p) -> pair_sup s <== p.

Definition pairLatticeMixin := LatticeMixin pair_supP pair_supM.
Canonical pairLattice := Eval hnf in Lattice tp pairLatticeMixin.

End PairLattice.

Section FunLattice.
Variables (A : Type) (B : lattice).
Local Notation tp := (A -> B).

Definition fun_sup (s : Pred tp) : tp :=
  fun x => sup [Pred p | exists f, f \In s /\ p = f x].

Lemma fun_supP (s : Pred tp) (p : tp) : p \In s -> p <== fun_sup s.

Lemma fun_supM (s : Pred tp) (p : tp) :
        (forall q, q \In s -> q <== p) -> fun_sup s <== p.

Definition funLatticeMixin := LatticeMixin fun_supP fun_supM.
Canonical funLattice := Eval hnf in Lattice tp funLatticeMixin.

End FunLattice.

Section DFunLattice.
Variables (A : Type) (B : A -> lattice).
Local Notation tp := (dfunPoset B).

Definition dfun_sup (s : Pred tp) : tp :=
  fun x => sup [Pred p | exists f, f \In s /\ p = f x].

Lemma dfun_supP (s : Pred tp) (p : tp) :
        p \In s -> p <== dfun_sup s.

Lemma dfun_supM (s : Pred tp) (p : tp) :
       (forall q, q \In s -> q <== p) -> dfun_sup s <== p.

Definition dfunLatticeMixin := LatticeMixin dfun_supP dfun_supM.
Definition dfunLattice := Eval hnf in Lattice (forall x, B x) dfunLatticeMixin.

End DFunLattice.

Lemma sup_appE A (B : lattice) (s : Pred (A -> B)) (x : A) :
        sup s x = sup [Pred y : B | exists f, f \In s /\ y = f x].

Lemma sup_dappE A (B : A -> lattice) (s : Pred (dfunLattice B)) (x : A) :
        sup s x = sup [Pred y : B x | exists f, f \In s /\ y = f x].

Section IdealLattice.
Variables (T : lattice) (P : T).

Definition ideal_sup' (s : Pred (ideal P)) :=
  sup [Pred x | exists p, p \In s /\ id_val p = x].

Lemma ideal_supP' (s : Pred (ideal P)) : ideal_sup' s <== P.

Definition ideal_sup (s : Pred (ideal P)) := Ideal (ideal_supP' s).

Lemma ideal_supP (s : Pred (ideal P)) p :
        p \In s -> p <== ideal_sup s.

Lemma ideal_supM (s : Pred (ideal P)) p :
        (forall q, q \In s -> q <== p) -> ideal_sup s <== p.

Definition idealLatticeMixin := LatticeMixin ideal_supP ideal_supM.
Canonical idealLattice := Eval hnf in Lattice (ideal P) idealLatticeMixin.

End IdealLattice.

Section PropLattice.

Definition prop_sup (s : Pred Prop) : Prop := exists p, p \In s /\ p.

Lemma prop_supP (s : Pred Prop) p : p \In s -> p <== prop_sup s.

Lemma prop_supM (s : Pred Prop) p :
        (forall q, q \In s -> q <== p) -> prop_sup s <== p.

Definition propLatticeMixin := LatticeMixin prop_supP prop_supM.
Canonical propLattice := Eval hnf in Lattice Prop propLatticeMixin.

End PropLattice.

Section PredLattice.
Variable A : Type.

Definition predLatticeMixin := funLatticeMixin A propLattice.
Canonical predLattice := Eval hnf in Lattice (Pred A) predLatticeMixin.

End PredLattice.

Section Chains.
Variable T : poset.

Definition chain_axiom (s : Pred T) :=
  (exists d, d \In s) /\
  (forall x y, x \In s -> y \In s -> x <== y \/ y <== x).

Structure chain := Chain {
  pred_of :> Pred T;
  _ : chain_axiom pred_of}.

Canonical chainPredType := @mkPredType T chain pred_of.

End Chains.

Lemma chainE (T : poset) (s1 s2 : chain T) :
        s1 = s2 <-> pred_of s1 =p pred_of s2.

Section LiftChain.
Variable (T : poset) (s : chain T).

Lemma lift_chainP : chain_axiom [Pred x : T | x = bot \/ x \In s].

Definition lift_chain := Chain lift_chainP.

End LiftChain.

Section ImageChain.
Variables (T1 T2 : poset) (s : chain T1) (f : T1 -> T2) (M : monotone f).

Lemma image_chainP :
        chain_axiom [Pred x2 : T2 | exists x1, x2 = f x1 /\ x1 \In s].

Definition image_chain := Chain image_chainP.

End ImageChain.

Notation "[ f '^^' s 'by' M ]" := (@image_chain _ _ s f M)
  (at level 0, format "[ f  '^^'  s  'by'  M ]") : form_scope.

Section ChainId.
Variables (T : poset) (s : chain T).

Lemma id_mono : monotone (@id T).

Lemma id_chainE (M : monotone id) : [id ^^ s by M] = s.

End ChainId.

Arguments id_mono [T].
Prenex Implicits id_mono.

Section ChainConst.
Variables (T1 T2 : poset) (y : T2).

Lemma const_mono : monotone (fun x : T1 => y).

Lemma const_chainP : chain_axiom (Pred1 y).

Definition const_chain := Chain const_chainP.

Lemma const_chainE s : [_ ^^ s by const_mono] = const_chain.

End ChainConst.

Arguments const_mono [T1 T2 y].
Prenex Implicits const_mono.

Section ChainCompose.
Variables (T1 T2 T3 : poset) (f1 : T2 -> T1) (f2 : T3 -> T2).
Variables (s : chain T3) (M1 : monotone f1) (M2 : monotone f2).

Lemma comp_mono : monotone (f1 \o f2).

Lemma comp_chainE :
        [f1 ^^ [f2 ^^ s by M2] by M1] = [f1 \o f2 ^^ s by comp_mono].

End ChainCompose.

Arguments comp_mono [T1 T2 T3 f1 f2].
Prenex Implicits comp_mono.

Section ProjChain.
Variables (T1 T2 : poset) (s : chain [poset of T1 * T2]).

Lemma proj1_mono : monotone (@fst T1 T2).

Lemma proj2_mono : monotone (@snd T1 T2).

Definition proj1_chain := [@fst _ _ ^^ s by proj1_mono].
Definition proj2_chain := [@snd _ _ ^^ s by proj2_mono].

End ProjChain.

Arguments proj1_mono [T1 T2].
Arguments proj2_mono [T1 T2].
Prenex Implicits proj1_mono proj2_mono.

Section DiagChain.
Variable (T : poset) (s : chain T).

Lemma diag_mono : monotone (fun x : T => (x, x)).

Definition diag_chain := [_ ^^ s by diag_mono].

Lemma proj1_diagE : proj1_chain diag_chain = s.

Lemma proj2_diagE : proj2_chain diag_chain = s.

End DiagChain.

Arguments diag_mono [T].
Prenex Implicits diag_mono.

Section AppChain.
Variables (A : Type) (T : poset) (s : chain [poset of A -> T]).

Lemma app_mono x : monotone (fun f : A -> T => f x).

Definition app_chain x := [_ ^^ s by app_mono x].

End AppChain.

Arguments app_mono [A T].
Prenex Implicits app_mono.

Section DAppChain.
Variables (A : Type) (T : A -> poset) (s : chain (dfunPoset T)).

Lemma dapp_mono x : monotone (fun f : dfunPoset T => f x).

Definition dapp_chain x := [_ ^^ s by dapp_mono x].

End DAppChain.

Arguments dapp_mono [A T].
Prenex Implicits dapp_mono.

Section ProdChain.
Variables (S1 S2 T1 T2 : poset) (f1 : S1 -> T1) (f2 : S2 -> T2).
Variables (M1 : monotone f1) (M2 : monotone f2).
Variable (s : chain [poset of S1 * S2]).

Lemma prod_mono : monotone (f1 \* f2).

Definition prod_chain := [f1 \* f2 ^^ s by prod_mono].

Lemma proj1_prodE : proj1_chain prod_chain = [f1 ^^ proj1_chain s by M1].

Lemma proj2_prodE : proj2_chain prod_chain = [f2 ^^ proj2_chain s by M2].

End ProdChain.

Arguments prod_mono [S1 S2 T1 T2 f1 f2].
Prenex Implicits prod_mono.

Section NatChain.

Lemma nat_chain_axiom : chain_axiom (@PredT nat).

Definition nat_chain := Chain nat_chain_axiom.

End NatChain.

Module CPO.

Section RawMixin.

Record mixin_of (T : poset) := Mixin {
  mx_lim : chain T -> T;
  _ : forall (s : chain T) x, x \In s -> x <== mx_lim s;
  _ : forall (s : chain T) x,
        (forall y, y \In s -> y <== x) -> mx_lim s <== x}.

End RawMixin.

Section ClassDef.

Record class_of (T : Type) := Class {
  base : Poset.class_of T;
  mixin : mixin_of (Poset.Pack base T)}.

Local Coercion base : class_of >-> Poset.class_of.

Structure type : Type := Pack {sort; _ : class_of sort; _ : Type}.
Local Coercion sort : type >-> Sortclass.

Variables (T : Type) (cT : type).
Definition class := let: Pack _ c _ as cT' := cT return class_of cT' in c.
Definition clone c of phant_id class c := @Pack T c T.

Definition pack b0 (m0 : mixin_of (Poset.Pack b0 T)) :=
  fun m & phant_id m0 m => Pack (@Class T b0 m) T.

Definition poset := Poset.Pack class cT.
Definition lim (s : chain poset) : cT := mx_lim (mixin class) s.

End ClassDef.

Module Import Exports.
Coercion base : class_of >-> Poset.class_of.
Coercion sort : type >-> Sortclass.
Coercion poset : type >-> Poset.type.
Canonical Structure poset.

Notation cpo := type.
Notation CPOMixin := Mixin.
Notation CPO T m := (@pack T _ _ m id).

Notation "[ 'cpo' 'of' T 'for' cT ]" := (@clone T cT _ idfun)
  (at level 0, format "[ 'cpo'  'of'  T  'for'  cT ]") : form_scope.
Notation "[ 'cpo' 'of' T ]" := (@clone T _ _ id)
  (at level 0, format "[ 'cpo'  'of'  T ]") : form_scope.

Arguments CPO.lim {cT}.
Notation lim := CPO.lim.

Section Laws.
Variable D : cpo.

Lemma limP (s : chain D) x : x \In s -> x <== lim s.

Lemma limM (s : chain D) x : (forall y, y \In s -> y <== x) -> lim s <== x.

End Laws.

End Exports.

End CPO.

Export CPO.Exports.

Section PairCPO.
Variables (A B : cpo).
Local Notation tp := [poset of A * B].

Definition pair_lim (s : chain tp) : tp :=
  (lim (proj1_chain s), lim (proj2_chain s)).

Lemma pair_limP (s : chain tp) x : x \In s -> x <== pair_lim s.

Lemma pair_limM (s : chain tp) x :
        (forall y, y \In s -> y <== x) -> pair_lim s <== x.

Definition pairCPOMixin := CPOMixin pair_limP pair_limM.
Canonical pairCPO := Eval hnf in CPO (A * B) pairCPOMixin.

End PairCPO.

Section FunCPO.
Variable (A : Type) (B : cpo).
Local Notation tp := [poset of A -> B].

Definition fun_lim (s : chain tp) : tp :=
  fun x => lim (app_chain s x).

Lemma fun_limP (s : chain tp) x : x \In s -> x <== fun_lim s.

Lemma fun_limM (s : chain tp) x :
        (forall y, y \In s -> y <== x) -> fun_lim s <== x.

Definition funCPOMixin := CPOMixin fun_limP fun_limM.
Canonical funCPO := Eval hnf in CPO (A -> B) funCPOMixin.

End FunCPO.

Section DFunCPO.
Variable (A : Type) (B : A -> cpo).
Local Notation tp := (dfunPoset B).

Definition dfun_lim (s : chain tp) : tp :=
  fun x => lim (dapp_chain s x).

Lemma dfun_limP (s : chain tp) x : x \In s -> x <== dfun_lim s.

Lemma dfun_limM (s : chain tp) x :
        (forall y, y \In s -> y <== x) -> dfun_lim s <== x.

Definition dfunCPOMixin := CPOMixin dfun_limP dfun_limM.
Definition dfunCPO := Eval hnf in CPO (forall x, B x) dfunCPOMixin.

End DFunCPO.

Section PropCPO.
Local Notation tp := [poset of Prop].

Definition prop_lim (s : chain tp) : tp := exists p, p \In s /\ p.

Lemma prop_limP (s : chain tp) p : p \In s -> p <== prop_lim s.

Lemma prop_limM (s : chain tp) p :
        (forall q, q \In s -> q <== p) -> prop_lim s <== p.

Definition propCPOMixin := CPOMixin prop_limP prop_limM.
Canonical propCPO := Eval hnf in CPO Prop propCPOMixin.

End PropCPO.

Section PredCPO.
Variable A : Type.

Definition predCPOMixin := funCPOMixin A propCPO.
Canonical predCPO := Eval hnf in CPO (Pred A) predCPOMixin.

End PredCPO.

Section LatticeCPO.
Variable A : lattice.
Local Notation tp := (Lattice.poset A).

Definition lat_lim (s : chain tp) : tp := sup s.

Lemma lat_limP (s : chain tp) x : x \In s -> x <== lat_lim s.

Lemma lat_limM (s : chain tp) x :
        (forall y, y \In s -> y <== x) -> lat_lim s <== x.

Definition latCPOMixin := CPOMixin lat_limP lat_limM.
Definition latCPO := Eval hnf in CPO tp latCPOMixin.

End LatticeCPO.

Section AdmissibleClosure.
Variable T : cpo.

Definition chain_closed :=
  [Pred s : Pred T |
     bot \In s /\ forall d : chain T, d <=p s -> lim d \In s].

Definition chain_closure (s : Pred T) :=
  [Pred p : T | forall t : Pred T, s <=p t -> chain_closed t -> p \In t].

Lemma chain_clos_sub (s : Pred T) : s <=p chain_closure s.

Lemma chain_clos_min (s : Pred T) t :
        s <=p t -> chain_closed t -> chain_closure s <=p t.

Lemma chain_closP (s : Pred T) : chain_closed (chain_closure s).

Lemma chain_clos_idemp (s : Pred T) :
        chain_closed s -> chain_closure s =p s.

Lemma chain_clos_mono (s1 s2 : Pred T) :
        s1 <=p s2 -> chain_closure s1 <=p chain_closure s2.

Lemma chain_closI (s1 s2 : Pred T) :
       chain_closed s1 -> chain_closed s2 -> chain_closed (PredI s1 s2).

End AdmissibleClosure.

Arguments chain_closed {T}.

Lemma chain_clos_diag (T : cpo) (s : Pred (T * T)) :
        chain_closed s -> chain_closed [Pred t : T | (t, t) \In s].

Section SubCPO.
Variables (D : cpo) (s : Pred D) (C : chain_closed s).

Local Notation tp := (subPoset (proj1 C)).

Lemma sval_mono : monotone (sval : tp -> D).

Lemma sub_limX (u : chain tp) : lim [sval ^^ u by sval_mono] \In s.

Definition sub_lim (u : chain tp) : tp :=
  exist _ (lim [sval ^^ u by sval_mono]) (sub_limX u).

Lemma sub_limP (u : chain tp) x : x \In u -> x <== sub_lim u.

Lemma sub_limM (u : chain tp) x :
        (forall y, y \In u -> y <== x) -> sub_lim u <== x.

Definition subCPOMixin := CPOMixin sub_limP sub_limM.
Definition subCPO := Eval hnf in CPO {x : D | x \In s} subCPOMixin.

End SubCPO.

Lemma lim_mono (D : cpo) (s1 s2 : chain D) :
        s1 <=p s2 -> lim s1 <== lim s2.

Lemma limE (D : cpo) (s1 s2 : chain D) :
        s1 =p s2 -> lim s1 = lim s2.

Lemma lim_liftE (D : cpo) (s : chain D) :
        lim s = lim (lift_chain s).

Lemma lim_appE A (D : cpo) (s : chain [cpo of A -> D]) (x : A) :
        lim s x = lim (app_chain s x).

Lemma lim_dappE A (D : A -> cpo) (s : chain (dfunCPO D)) (x : A) :
        lim s x = lim (dapp_chain s x).

Section Continuity.
Variables (D1 D2 : cpo) (f : D1 -> D2).

Definition continuous :=
  exists M : monotone f,
  forall s : chain D1, f (lim s) = lim [f ^^ s by M].

Lemma cont_mono : continuous -> monotone f.

Lemma contE (s : chain D1) (C : continuous) :
       f (lim s) = lim [f ^^ s by cont_mono C].

End Continuity.

Section Kleene.
Variables (D : cpo) (f : D -> D) (C : continuous f).

Fixpoint pow m := if m is n.+1 then f (pow n) else bot.

Lemma pow_mono : monotone pow.

Definition pow_chain := [pow ^^ nat_chain by pow_mono].

Lemma reindex : pow_chain =p lift_chain [f ^^ pow_chain by cont_mono C].

Definition kleene_lfp := lim pow_chain.

Lemma kleene_lfp_fixed : f kleene_lfp = kleene_lfp.

Lemma kleene_lfp_least : forall x, f x = x -> kleene_lfp <== x.

End Kleene.

Lemma id_cont (D : cpo) : continuous (@id D).

Arguments id_cont {D}.

Lemma const_cont (D1 D2 : cpo) (y : D2) : continuous (fun x : D1 => y).

Arguments const_cont {D1 D2 y}.

Lemma comp_cont (D1 D2 D3 : cpo) (f1 : D2 -> D1) (f2 : D3 -> D2) :
        continuous f1 -> continuous f2 -> continuous (f1 \o f2).

Arguments comp_cont {D1 D2 D3 f1 f2}.

Lemma proj1_cont (D1 D2 : cpo) : continuous (@fst D1 D2).

Lemma proj2_cont (D1 D2 : cpo) : continuous (@snd D1 D2).

Arguments proj1_cont {D1 D2}.
Arguments proj2_cont {D1 D2}.

Lemma diag_cont (D : cpo) : continuous (fun x : D => (x, x)).

Arguments diag_cont {D}.

Lemma app_cont A (D : cpo) x : continuous (fun f : A -> D => f x).

Lemma dapp_cont A (D : A -> cpo) x : continuous (fun f : dfunCPO D => f x).

Arguments app_cont {A D}.
Arguments dapp_cont {A D}.

Lemma prod_cont (S1 S2 T1 T2 : cpo) (f1 : S1 -> T1) (f2 : S2 -> T2) :
        continuous f1 -> continuous f2 -> continuous (f1 \* f2).

Arguments prod_cont {S1 S2 T1 T2 f1 f2}. *)
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Inductive exn : Type := exn_from_nat : nat -> exn.

Definition exn_to_nat (e : exn) : nat :=
  let: exn_from_nat y := e in y.

Definition eqexn (e1 e2 : exn) : bool :=
  match e1, e2 with exn_from_nat m, exn_from_nat n => m == n end.

Lemma eqexnP : Equality.axiom eqexn.
Proof.
move=>[x][y]//=; case: eqP=>[->|*];constructor=>//.
by move=>[*].
Qed.

Canonical Structure exn_eqMixin := EqMixin eqexnP.
Canonical Structure exn_eqType := EqType exn exn_eqMixin.

Inductive ans (A : Type) : Type := Val of A | Exn of exn.
Arguments Exn [A].

Notation pre := (Pred heap).
Notation post A := (ans A -> heap -> heap -> Prop).
Definition spec B := pre * post B : Type.

Definition defed (P : Pred heap) : Pred heap :=
  fun i => i \In P /\ def i.

Notation ideald P := (ideal (defed P)).

Section BasePrograms.
Variables (A : Type) (P : Pred heap).

Lemma singleP i : i \In defed P -> this i <== defed P.
Proof. by move=>[pf1 pf2] h <-; split. Qed.

Definition single i (pf : i \In defed P) := Ideal (singleP pf).

Lemma bound (p : ideald P) i : i \In id_val p -> i \In defed P.
Proof. by case: p=>p H; case/H. Qed.

Definition prog := ideald P -> ans A -> Pred heap.

Definition coherent (e : prog) :=
  forall p x m,
    m \In e p x <-> exists i, exists pf : i \In id_val p,
                    m \In e (single (bound pf)) x.

Definition def_strict (e : prog) := forall p x, Undef \Notin e p x.

Definition runs_of (e : prog) : Pred (heap * ans A * heap) :=
  fun r => exists pf : r.1.1 \In defed P, r.2 \In e (single pf) r.1.2.

End BasePrograms.

Definition has_spec A (s : spec A) :=
  [Pred c : prog A s.1 |
     forall i y m, (i, y, m) \In runs_of c -> s.2 y i m].

Section STDef.
Variables (A : Type) (s : spec A).

Structure ST := STprog {
  model : prog A s.1;
  _ : coherent model;
  _ : def_strict model;
  _ : model \In has_spec s}.

Lemma modelE (e1 e2 : ST) : e1 = e2 <-> model e1 = model e2.
Proof.
move: e1 e2=>[e1 M1 S1 H1][e2 M2 S2 H2] /=; split=>[[//]|E].
rewrite E in M1 S1 H1 *.
by congr STprog; apply: proof_irrelevance.
Qed.

Definition st_leq e1 e2 := model e1 <== model e2.

Lemma st_refl e : st_leq e e.
Proof. by []. Qed.

Lemma st_asym e1 e2 : st_leq e1 e2 -> st_leq e2 e1 -> e1 = e2.
Proof.
move: e1 e2=>[e1 M1 S1 H1][e2 M2 S2 H2]; rewrite /st_leq /= => E1 E2.
rewrite (poset_asym E1 E2) in M1 M2 S1 S2 H1 H2 *; congr STprog;
by apply: proof_irrelevance.
Qed.

Lemma st_trans e1 e2 e3 : st_leq e1 e2 -> st_leq e2 e3 -> st_leq e1 e3.
Proof.
move: e1 e2 e3=>[e1 M1 S1 H1][e2 M2 S2 H2][e3 M3 S3 H3].
by apply: poset_trans.
Qed.

Definition st_bot' := bot : [poset of prog A s.1].

Lemma st_bot_coherent : coherent st_bot'.
Proof. by move=>r x m; split=>//; case=>i []. Qed.

Lemma st_bot_dstrict : def_strict st_bot'.
Proof. by move=>r x. Qed.

Lemma st_bot_has_spec : st_bot' \In has_spec s.
Proof. by move=>i y m [/= H][]. Qed.

Definition st_bot := STprog st_bot_coherent st_bot_dstrict st_bot_has_spec.

Lemma st_botP e : st_leq st_bot e.
Proof. by case: e=>*; apply: botP. Qed.

Definition stPosetMixin := PosetMixin st_botP st_refl st_asym st_trans.
Canonical stPoset := Eval hnf in Poset ST stPosetMixin.

Definition st_sup' (u : Pred ST) :=
  sup [Pred p | exists e, p = model e /\ e \In u].

Lemma st_sup_coherent u : coherent (st_sup' u).
Proof.
move=>r x m; split.
- case=>_ [[_]][[_]][[_]][[]][p] M S H [->] P -> -> -> /=.
  case/M=>i [pf] H1.
  exists i; exists pf; exists (p (single (bound pf)) x m).
  split=>//; do 3![eexists _; split=>//].
  by exists (STprog M S H).
case=>i [pf][_][[_]][[_]][[_]][[]][p] M D H [->] P -> -> -> /= E.
have: exists i, exists pf : i \In id_val r, m \In p (single (bound pf)) x.
- by exists i; exists pf.
move/M=>H3; exists (p r x m); split=>//; do 3![eexists _; split=>//].
by exists (STprog M D H).
Qed.

Lemma st_sup_dstrict u : def_strict (st_sup' u).
Proof.
by move=>p x [_][[_]][[_]][[_]][[]][r] M D H [->] P -> -> -> /=; move/D.
Qed.

Lemma st_sup_has_spec u : st_sup' u \In has_spec s.
Proof.
move=>i y m [/= D].
case=>_ [[_]][[_]][[_]][[]][p] M S H [->] P -> -> -> /= R.
by apply: (H); exists D.
Qed.

Definition st_sup u :=
  STprog (@st_sup_coherent u) (@st_sup_dstrict u) (@st_sup_has_spec u).

Lemma st_supP (u : Pred ST) e : e \In u -> st_leq e (st_sup u).
Proof. by case: e=>p M S H R; apply: supP; exists (STprog M S H). Qed.

Lemma st_supM (u : Pred ST) e :
        (forall e1, e1 \In u -> st_leq e1 e) -> st_leq (st_sup u) e.
Proof. by case: e=>p M S H R; apply: supM=>y [q][->]; apply: R. Qed.

Definition stLatticeMixin := LatticeMixin st_supP st_supM.
Canonical stLattice := Lattice ST stLatticeMixin.

Lemma bot_runs : runs_of (model st_bot) =p Pred0.
Proof. by move=>r; split=>//; case. Qed.

Lemma model_runs p y m (e : ST) :
        m \In model e p y <->
        exists i, i \In id_val p /\ (i, y, m) \In runs_of (model e).
Proof.
case: e=>mod M S H; rewrite M; split; case=>i [H1] H2.
- by exists i; split=>//; exists (bound H1).
exists i; exists H1; case: H2 =>/= H2.
by rewrite (proof_irrelevance H2 (bound H1)).
Qed.

Lemma def_runs i y m (e : ST) :
        (i, y, m) \In runs_of (model e) -> [/\ def i, i \In s.1 & def m].
Proof.
case=>[[/= P D]] R; split=>//.
by case: e R=>p M S H; case: m=>//; move/S.
Qed.

Lemma spec_runs i y m (e : ST) :
        (i, y, m) \In runs_of (model e) -> s.2 y i m.
Proof. by case: e=>p M S; apply. Qed.

End STDef.

Arguments spec_runs {A s i y m}.
Prenex Implicits bot_runs model_runs def_runs.

Module Model.

Section Fix.
Variables (A : Type) (B : A -> Type) (s : forall x, spec (B x)).
Notation tp := (forall x, ST (s x)).
Notation lat := (dfunLattice (fun x => [lattice of ST (s x)])).
Variable (f : tp -> tp).

Definition f' (e : lat) :=
  sup [Pred t : lat | exists e', e' <== e /\ t = f e'].

Definition ffix : tp := tarski_lfp f'.

End Fix.

Section Return.
Variables (A : Type) (x : A).

Definition ret_s : spec A :=
  (fun i => True, fun y i m => m = i /\ y = Val x).

Definition ret_sp (p : ideald ret_s.1) y m :=
  m \In id_val p /\ y = Val x.

Lemma ret_coherent : coherent ret_sp.
Proof.
move=>p y m; split; first by case=>H ->{y}; exists m; exists H.
by case=>i [H1] [<-{m}] ->{y}.
Qed.

Lemma ret_dstrict : def_strict ret_sp.
Proof. by case=>p H y /= []; case/H. Qed.

Lemma ret_has_spec : ret_sp \In has_spec ret_s.
Proof. by move=>i y m; case=>/= T [-> ->]. Qed.

Definition ret := STprog ret_coherent ret_dstrict ret_has_spec.

End Return.

Section Throw.
Variables (A : Type) (e : exn).

Definition throw_s : spec A :=
  (fun i => True, fun y i m => m = i /\ y = Exn e).

Definition throw_sp (p : ideald throw_s.1) y m :=
  m \In id_val p /\ y = @Exn A e.

Lemma throw_coherent : coherent throw_sp.
Proof.
move=>p y m; split; first by case=>H ->{y}; exists m; exists H.
by case=>i [H1] [<-{m}] ->{y}.
Qed.

Lemma throw_dstrict : def_strict throw_sp.
Proof. by case=>p H y /= []; case/H. Qed.

Lemma throw_has_spec : throw_sp \In has_spec throw_s.
Proof. by move=>i y m; case=>/= T [-> ->]. Qed.

Definition throw := STprog throw_coherent throw_dstrict throw_has_spec.

End Throw.

Section Bind.
Variables (A B : Type).
Variables (s1 : spec A) (s2 : A -> spec B).
Variables (e1 : ST s1) (e2 : forall x, ST (s2 x)).

Definition bind_pre : pre :=
  fun i => s1.1 i /\ forall x m, s1.2 (Val x) i m -> (s2 x).1 m.
Definition bind_post : post B :=
  fun y i m => (exists x, exists h, s1.2 (Val x) i h /\ (s2 x).2 y h m) \/
               (exists e, y = Exn e /\ s1.2 (Exn e) i m).
Definition bind_s := (bind_pre, bind_post).

Definition bind_sp (p : ideald bind_s.1) y m :=
   exists i, exists x, exists h, i \In id_val p /\
     (i, x, h) \In runs_of (model e1) /\
     match x with
       Val x' => (h, y, m) \In runs_of (model (e2 x'))
     | Exn e => y = Exn e /\ m = h
     end.

Lemma bind_coherent : coherent bind_sp.
Proof.
case=>p H y m; split.
- case=>i [x][h][/= H1][H2] H3.
  by exists i; exists H1; exists i; exists x; exists h.
case=>i [/= H1][_][x][h][<-][T1 T2].
by exists i; exists x; exists h.
Qed.

Lemma bind_dstrict : def_strict bind_sp.
Proof.
move=>p y [i][x][h][H1][].
case: x=>[x'|e] H2; first by case/def_runs.
by case=>_ E; case/def_runs: H2; rewrite -E.
Qed.

Lemma bind_has_spec : bind_sp \In has_spec bind_s.
Proof.
move=>i y m.
case=>[[[/= S1 S2]]] D [h][x][j][<-][].
case: x=>[x|e] T1; last first.
- case=>->->; right; exists e; split=>//.
  by apply: spec_runs T1.
move=>T2; left; exists x; exists j.
by split; [apply: spec_runs T1 | apply: spec_runs T2].
Qed.

Definition bind := STprog bind_coherent bind_dstrict bind_has_spec.

End Bind.

Section Try.
Variables (A B : Type) (s : spec A) (s1 : A -> spec B) (s2 : exn -> spec B).
Variables (e : ST s) (e1 : forall x, ST (s1 x)) (e2 : forall x, ST (s2 x)).

Definition try_pre : pre :=
  fun i => s.1 i /\ (forall y m, s.2 (Val y) i m -> (s1 y).1 m) /\
                     forall e m, s.2 (Exn e) i m -> (s2 e).1 m.
Definition try_post : post B :=
  fun y i m => (exists x, exists h, s.2 (Val x) i h /\ (s1 x).2 y h m) \/
               (exists e, exists h, s.2 (Exn e) i h /\ (s2 e).2 y h m).
Definition try_s := (try_pre, try_post).

Definition try_sp (p : ideald try_s.1) y m :=
   exists i, exists x, exists h, i \In id_val p /\
     (i, x, h) \In runs_of (model e) /\
     match x with
       Val x' => (h, y, m) \In runs_of (model (e1 x'))
     | Exn e => (h, y, m) \In runs_of (model (e2 e))
     end.

Lemma try_coherent : coherent try_sp.
Proof.
case=>p H y m; split.
- case=>i [x][h][/= H1][H2] H3.
  by exists i; exists H1; exists i; exists x; exists h.
case=>i [/= H1][_][x][h][<-][T1 T2].
by exists i; exists x; exists h.
Qed.

Lemma try_dstrict : def_strict try_sp.
Proof.
move=>p y [i][x][h][H1][].
by case: x=>[x'|e'] H2; case/def_runs.
Qed.

Lemma try_has_spec : try_sp \In has_spec try_s.
Proof.
move=>i y m; case=>[[[/= S1 [S2 S3]]]] D [h][x][j][<-][].
case: x=>[x'|e'] T1 T2; [left; exists x' | right; exists e'];
exists j; by split; [apply: spec_runs T1 | apply: spec_runs T2].
Qed.

Definition try := STprog try_coherent try_dstrict try_has_spec.

End Try.

Definition conseq A (s1 s2 : spec A) :=
  forall i, s2.1 i -> def i ->
    s1.1 i /\ forall y m, s1.2 y i m -> def m -> s2.2 y i m.

Lemma conseq_refl (A : Type) (s : spec A) : conseq s s.
Proof. by []. Qed.

Hint Resolve conseq_refl : core.

Section Consequence.
Variables (A : Type) (s1 s2 : spec A) (e : ST s1) (pf : conseq s1 s2).

Definition do_sp (p : ideald s2.1) y m :=
  exists i, i \In id_val p /\ (i, y, m) \In runs_of (model e).

Lemma do_coherent : coherent do_sp.
Proof.
case=>q H y m; split.
- by case=>i [/= H1 T1]; exists i; exists H1; exists i.
by case=>i [/= H1][_][<-] T1; exists i.
Qed.

Lemma do_dstrict : def_strict do_sp.
Proof. by move=>q y [h][/= H]; case/def_runs. Qed.

Lemma do_has_spec : do_sp \In has_spec s2.
Proof.
move=>i y m [[/= S1 D1]][_][<-] T; case/def_runs: (T)=>_ S2 D2.
by apply: (proj2 (pf S1 D1)) D2; apply: spec_runs T.
Qed.

Definition Do := STprog do_coherent do_dstrict do_has_spec.

End Consequence.

Section Read.
Variable (A : Type) (x : ptr).

Definition read_s : spec A :=
  (fun i => x \in dom i /\ exists v:A, look x i = dyn v,
   fun y i m => m = i /\ forall v, look x i = dyn v -> y = Val v).

Definition read_sp (p : ideald read_s.1) (v : ans A) m :=
  m \In id_val p /\ exists w, v = Val w /\ look x m = dyn w.

Lemma read_coherent : coherent read_sp.
Proof.
move=>p v m; split; last first.
- by case=>i [H1][<-][w][->]; split=>//; exists w.
case=>H1 [w][->] H2.
by exists m; exists H1; split=>//; exists w.
Qed.

Lemma read_dstrict : def_strict read_sp.
Proof. by case=>p H y []; case/H. Qed.

Lemma read_has_spec : read_sp \In has_spec read_s.
Proof.
move=>i y m [[[/= H1]]][v] H2 D [<-][w][->] H3.
by split=>// b1; rewrite H3=>H; move:(dyn_inj H)=>->.
Qed.

Definition read := STprog read_coherent read_dstrict read_has_spec.

End Read.

Section Write.
Variable (A : Type) (x : ptr) (v : A).

Definition write_s : spec unit :=
  (fun i => x \in dom i : Prop,
   fun y i m => y = Val tt /\ upd i x (dyn v) = m).

Definition write_sp (p : ideald write_s.1) (y : ans unit) m :=
  exists i, i \In id_val p /\ x \in dom i /\
            y = Val tt /\ m = upd i x (dyn v).

Lemma write_coherent : coherent write_sp.
Proof.
move=>p y m; split; case=>i [H1].
- by case=>H2 [->->]; exists i; exists H1; exists i.
by case=>_ [<-][H2][->] ->; exists i.
Qed.

Lemma write_dstrict : def_strict write_sp.
Proof.
case=>p H y [i] /= [H1][H2][H3].
suff L: def (upd i x (dyn v)) by move=>H4; rewrite -H4 in L.
by rewrite defU (dom_null H2) (dom_def H2).
Qed.

Lemma write_has_spec : write_sp \In has_spec write_s.
Proof. by move=>i y m [[/= H1 D1]][_][<-][H2][->] ->. Qed.

Definition write := STprog write_coherent write_dstrict write_has_spec.

End Write.

Section Allocation.
Variables (A : Type) (v : A).

Definition alloc_s : spec ptr :=
  (fun i => def i : Prop,
   fun y i m => exists x, x != null /\ y = Val x /\ x \notin dom i /\
                          upd i x (dyn v) = m).

Definition alloc_sp (p : ideald alloc_s.1) y m :=
  exists i, i \In id_val p /\ exists l : ptr, y = Val l /\
    m = i :+ l :-> v /\ l != null /\ l \notin dom i.

Lemma alloc_coherent : coherent alloc_sp.
Proof.
move=>p x m; split.
- case=>i [H1][l][->][->][H2] H3.
  by exists i; exists H1; exists i; split=>//; exists l.
case=>i [H1][_][<-][l][->][->][H2] H3.
by exists i; split=>//; exists l.
Qed.

Lemma alloc_dstrict : def_strict alloc_sp.
Proof.
case=>p H y [m][/= H1][l][H2][H3][H4] H5; case/H: H1=>_ D.
suff {H3}: def (m :+ l :-> v) by rewrite -H3.
by rewrite unC defPtUn H4 D H5.
Qed.

Lemma alloc_has_spec : alloc_sp \In has_spec alloc_s.
Proof.
move=>i y m [[/= H D]][_][<-][l][->][->][H1] H2.
exists l; do !split=>//.
rewrite (_ : i = i :+ empty); last by rewrite unh0.
by rewrite updUnl (negbTE H2) unh0.
Qed.

Definition alloc := STprog alloc_coherent alloc_dstrict alloc_has_spec.

End Allocation.

Section BlockAllocation.
Variables (A : Type) (v : A) (n : nat).

Definition allocb_s : spec ptr :=
  (fun i => def i : Prop,
   fun y i m => exists r, y = Val r /\ m = i :+ updi r (nseq n v)).

Definition allocb_sp (p : ideald allocb_s.1) y m :=
  exists i, i \In id_val p /\ y = Val (fresh i) /\
            m = i :+ updi (fresh i) (nseq n v).

Lemma allocb_coherent : coherent allocb_sp.
Proof.
move=>p x m; split.
- by case=>i [H1][->] ->; exists i; exists H1; exists i.
by case=>i [H1][_][<-][->] ->; exists i.
Qed.

Lemma allocb_dstrict : def_strict allocb_sp.
Proof.
case=>p H y [m][/= H1][_] H2; case/H: H1=>_ D.
suff {H2}: def (m :+ updi (fresh m) (nseq n v)) by rewrite -H2.
elim: n =>[|k IH]; first by rewrite /= unh0.
rewrite (_ : nseq k.+1 v = rcons (nseq k v) v); last first.
- by elim: {IH} k=>[|k IH] //=; rewrite -IH.
rewrite updi_last unA unC defPtUn IH /=.
rewrite ptr_null negb_and fresh_null /=.
rewrite domUn !inE /= negb_and IH negb_or /=.
by rewrite dom_fresh updimV negb_and fresh_null ltnn.
Qed.

Lemma allocb_has_spec : allocb_sp \In has_spec allocb_s.
Proof. by move=>i y m [[/= H D]][_][<-][->] ->; exists (fresh i). Qed.

Definition allocb := STprog allocb_coherent allocb_dstrict allocb_has_spec.

End BlockAllocation.

Section Deallocation.
Variable x : ptr.

Definition dealloc_s : spec unit :=
  (fun i => x \in dom i : Prop,
   fun y i m => y = Val tt /\ free x i = m).

Definition dealloc_sp (p : ideald dealloc_s.1) (y : ans unit) m :=
  exists i, i \In id_val p /\ y = Val tt /\ x \in dom i /\ m = free x i.

Lemma dealloc_coherent : coherent dealloc_sp.
Proof.
move=>p y m; split.
- by case=>i [H1][->][H2] ->; exists i; exists H1; exists i.
by case=>i [H1][_][<-][->][H2] ->; exists i.
Qed.

Lemma dealloc_dstrict : def_strict dealloc_sp.
Proof.
case=>p H y [h][/=]; case/H=>_ H1 [H2][H3] H4.
suff: def (free x h) by rewrite -H4.
by rewrite defF.
Qed.

Lemma dealloc_has_spec : dealloc_sp \In has_spec dealloc_s.
Proof. by move=>i y m [[/= H1 D1]][_][<-][->][H2] ->. Qed.

Definition dealloc :=
  STprog dealloc_coherent dealloc_dstrict dealloc_has_spec.

End Deallocation.

End Model.
