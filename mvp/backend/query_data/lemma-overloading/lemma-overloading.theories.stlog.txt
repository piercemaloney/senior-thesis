

From mathcomp

Require Import ssreflect ssrbool seq ssrfun.

From LemmaOverloading

Require Import heaps rels hprop stmod stsep.
(* heaps:
From mathcomp
Require Import ssreflect ssrfun ssrnat div ssrbool seq.
From LemmaOverloading
Require Import prelude finmap ordtype.
From mathcomp
Require Import path eqtype.
Require Import Eqdep.
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Notation eqn_addl := eqn_add2l.
Notation modn_addl := modnDl.
Notation modn_mulr := modnMr.
Notation modn_add2m := modnDm.
Notation modn_addr := modnDr.

Inductive ptr := ptr_nat of nat.

Definition null := ptr_nat 0.

Definition nat_ptr (x : ptr) := let: ptr_nat y := x in y.

Definition eq_ptr (x y : ptr) :=
  match x, y with ptr_nat m, ptr_nat n => m == n end.

Lemma eq_ptrP : Equality.axiom eq_ptr.

Definition ptr_eqMixin := EqMixin eq_ptrP.
Canonical Structure ptr_eqType := EqType ptr ptr_eqMixin.

Definition ptr_offset x i := ptr_nat (nat_ptr x + i).

Notation "x .+ i" := (ptr_offset x i)
  (at level 3, format "x .+ i").

Lemma ptrE x y : (x == y) = (nat_ptr x == nat_ptr y).

Lemma ptr0 x : x.+0 = x.

Lemma ptrA x i j : x.+i.+j = x.+(i+j).

Lemma ptrK x i j : (x.+i == x.+j) = (i == j).

Lemma ptr_null x m : (x.+m == null) = (x == null) && (m == 0).

Lemma ptrT x y : {m : nat | (x == y.+m) || (y == x.+m)}.

Definition ltn_ptr (x y : ptr) :=
  match x, y with ptr_nat m, ptr_nat n => m < n end.

Lemma ltn_ptr_irr : irreflexive ltn_ptr.

Lemma ltn_ptr_trans : transitive ltn_ptr.

Lemma ltn_ptr_total : forall x y : ptr, [|| ltn_ptr x y, x == y | ltn_ptr y x].

Definition ptr_ordMixin := OrdMixin ltn_ptr_irr ltn_ptr_trans ltn_ptr_total.
Canonical Structure ptr_ordType := OrdType ptr ptr_ordMixin.

Inductive heap :=
  Undef | Def (finmap : {finMap ptr -> dynamic}) of
               null \notin supp finmap.

Section NullLemmas.
Variables (f g : {finMap ptr -> dynamic}) (x : ptr) (d : dynamic).

Lemma upd_nullP :
        x != null -> null \notin supp f -> null \notin supp (ins x d f).

Lemma free_nullP : null \notin supp f -> null \notin supp (rem x f).

Lemma un_nullP :
        null \notin supp f -> null \notin supp g ->
          null \notin supp (fcat f g).

Lemma heapE pf pg : f = g <-> @Def f pf = @Def g pg.

End NullLemmas.

Definition def h := if h is Def _ _ then true else false.

Definition empty := @Def (finmap.nil _ _) is_true_true.

Definition upd h x d := nosimpl
  (if h is Def hs ns then
    if decP (@idP (x != null)) is left pf then
      Def (@upd_nullP _ _ d pf ns)
    else Undef
  else Undef).

Definition dom h : pred ptr := nosimpl
  (if h is Def f _ then mem (supp f) else pred0).

Definition free x h : heap :=
  (if h is Def hs ns then Def (free_nullP x ns) else Undef).

Definition look (x : ptr) h :=
  (if h is Def hs _ then
    if fnd x hs is Some d then d else dyn tt
  else dyn tt).

Definition union2 h1 h2 := nosimpl
  (if (h1, h2) is (Def hs1 ns1, Def hs2 ns2) then
     if disj hs1 hs2 then
        Def (@un_nullP _ _ ns1 ns2)
     else Undef
  else Undef).

Definition empb h :=
  if h is Def hs _ then supp hs == [::] else false.

Definition fresh h :=
  (if h is Def hs _ then last null (supp hs) else null) .+ 1.

Definition subdom h1 h2 :=
  if (h1, h2) is (Def hs1 _, Def hs2 _) then
    all (fun x => x \in supp hs2) (supp hs1)
  else false.

Definition subheap h1 h2 :=
  subdom h1 h2 /\ forall x, x \in dom h1 -> look x h1 = look x h2.

Definition subtract h1 h2 :=
  if h1 is (Def hs1 _) then
    foldl (fun h x => free x h) h2 (supp hs1)
  else Undef.

Definition pick h :=
  if h is Def hs _ then head null (supp hs) else null.

Definition pts A (x : ptr) (v : A) := upd empty x (dyn v).

Notation "h1 :+ h2" := (union2 h1 h2) (at level 43, left associativity).
Notation "h2 :- h1" := (subtract h1 h2) (at level 43, left associativity).
Notation "x :-> v" := (pts x v) (at level 30).

Lemma unC : forall h1 h2, h1 :+ h2 = h2 :+ h1.

Lemma unA : forall h1 h2 h3, h1 :+ (h2 :+ h3) = h1 :+ h2 :+ h3.

Lemma unCA h1 h2 h3 : h1 :+ (h2 :+ h3) = h2 :+ (h1 :+ h3).

Lemma unAC h1 h2 h3 : h1 :+ h2 :+ h3 = h1 :+ h3 :+ h2.

Lemma un0h h : empty :+ h = h.

Lemma unh0 h : h :+ empty = h.

Lemma unKhl h h1 h2 : def (h1 :+ h) -> h1 :+ h = h2 :+ h -> h1 = h2.

Lemma unhKl h h1 h2 : def (h :+ h1) -> h :+ h1 = h :+ h2 -> h1 = h2.

Lemma unKhr h h1 h2 : def (h2 :+ h) -> h1 :+ h = h2 :+ h -> h1 = h2.

Lemma unhKr h h1 h2 : def (h :+ h2) -> h :+ h1 = h :+ h2 -> h1 = h2.

Lemma dom0 : dom empty = pred0.

Lemma domU h y d :
        dom (upd h y d) =i
        [pred x | (y != null) && if x == y then def h else x \in dom h].

Lemma domPt A x (v : A) : dom (x :-> v) =i [pred y | (x == y) && (x != null)].

Lemma domF h x :
        dom (free x h) =i [pred y | if x == y then false else y \in dom h].

Lemma domUn h1 h2 :
        dom (h1 :+ h2) =i
        [pred x | def (h1 :+ h2) && (x \in [predU dom h1 & dom h2])].

Lemma dom_null h x : x \in dom h -> x != null.

Lemma dom_def h x : x \in dom h -> def h.

Lemma dom_free h x : x \notin dom h -> free x h = h.

Lemma dom_look h x : x \notin dom h -> look x h = dyn tt.

Lemma def0 : def empty.

Hint Resolve def0 : core.

Lemma defU h x d : def (upd h x d) = (x != null) && (def h).

Lemma defPt A x (v : A) : def (x :-> v) = (x != null).

Lemma defF h x : def (free x h) = def h.

CoInductive defUn_spec h1 h2 : bool -> Type :=
| def_false1 of ~~ def h1 : defUn_spec h1 h2 false
| def_false2 of ~~ def h2 : defUn_spec h1 h2 false
| def_false3 x of x \in dom h1 & x \in dom h2 : defUn_spec h1 h2 false
| def_true of def h1 & def h2 &
    (forall x, x \in dom h1 -> x \notin dom h2) : defUn_spec h1 h2 true.

Lemma defUn : forall h1 h2, defUn_spec h1 h2 (def (h1 :+ h2)).

Lemma defUnl h1 h2 : def (h1 :+ h2) -> def h1.

Lemma defUnr h1 h2 : def (h1 :+ h2) -> def h2.

Lemma defFUn h1 h2 x : def (h1 :+ h2) -> def (free x h1 :+ h2).

Lemma defUnF h1 h2 x : def (h1 :+ h2) -> def (h1 :+ free x h2).

Lemma undefE x : ~~ def x <-> x = Undef.

Lemma upd_inj h x d1 d2 :
        def h -> x != null -> upd h x d1 = upd h x d2 -> d1 = d2.

Lemma heap_eta h x : x \in dom h -> h = upd (free x h) x (look x h).

Lemma updU h x y d1 d2 :
        upd (upd h x d1) y d2 =
        if x == y then upd h x d2 else upd (upd h y d2) x d1.

Lemma updF h x y d :
        upd (free x h) y d =
        if x == y then upd h x d else free x (upd h y d).

Lemma updUnl h1 h2 x d :
        upd (h1 :+ h2) x d =
        if x \in dom h1 then upd h1 x d :+ h2 else h1 :+ upd h2 x d.

Lemma updUnr h1 h2 x d :
        upd (h1 :+ h2) x d =
        if x \in dom h2 then h1 :+ upd h2 x d else upd h1 x d :+ h2.

Lemma pts_injP A1 A2 x1 x2 (v1 : A1) (v2 : A2) :
        def (x1 :-> v1) -> x1 :-> v1 = x2 :-> v2 -> x1 = x2 /\ A1 = A2.

Lemma pts_injT A1 A2 x (v1 : A1) (v2 : A2) :
        def (x :-> v1) -> x :-> v1 = x :-> v2 -> A1 = A2.

Lemma pts_inj A x (v1 v2 : A) :
        def (x :-> v1) -> x :-> v1 = x :-> v2 -> v1 = v2.

Lemma free0 x : free x empty = empty.

Lemma freeU h x y d :
        free x (upd h y d) = if x == y then
          if y == null then Undef else free x h
        else upd (free x h) y d.

Lemma freeF h x y :
        free x (free y h) = if x == y then free x h else free y (free x h).

Lemma freeUn h1 h2 x :
        free x (h1 :+ h2) =
        if x \in dom (h1 :+ h2) then free x h1 :+ free x h2
        else h1 :+ h2.

Lemma freeUnD h1 h2 x :
        def (h1 :+ h2) -> free x (h1 :+ h2) = free x h1 :+ free x h2.

Lemma freeUnl h1 h2 x : x \notin dom h1 -> free x (h1 :+ h2) = h1 :+ free x h2.

Lemma freeUnr h1 h2 x : x \notin dom h2 -> free x (h1 :+ h2) = free x h1 :+ h2.

Lemma lookU h x y d :
        look x (upd h y d) = if x == y then
          if def h && (y != null) then d else dyn tt
        else if y != null then look x h else dyn tt.

Lemma lookF h x y :
        look x (free y h) = if x == y then dyn tt else look x h.

Lemma lookUnl h1 h2 x :
        def (h1 :+ h2) ->
        look x (h1 :+ h2) = if x \in dom h1 then look x h1 else look x h2.

Lemma lookUnr h1 h2 x :
        def (h1 :+ h2) ->
        look x (h1 :+ h2) = if x \in dom h2 then look x h2 else look x h1.

Lemma empP h : reflect (h = empty) (empb h).

Lemma empU h x d : empb (upd h x d) = false.

Lemma empPt A x (v : A) : empb (x :-> v) = false.

Lemma empUn h1 h2 : empb (h1 :+ h2) = empb h1 && empb h2.

Lemma empbE h : h = empty <-> empb h.

Lemma un0E h1 h2 : h1 :+ h2 = empty <-> h1 = empty /\ h2 = empty.

Lemma defE h : reflect (def h /\ forall x, x \notin dom h)(empb h).

Lemma defUnhh h : def (h :+ h) = empb h.

Lemma path_last n s x : path ord x s -> ord x (last x s).+(n+1).

Lemma path_filter (A : ordType) (s : seq A) (p : pred A) x :
        path ord x s -> path ord x (filter p s).

Lemma dom_fresh h n : (fresh h).+n \notin dom h.

Lemma fresh_null h : fresh h != null.

Opaque fresh.

Hint Resolve dom_fresh fresh_null : core.

Lemma emp_pick h : (pick h == null) = (~~ def h || empb h).

Lemma pickP h : def h && ~~ empb h = (pick h \in dom h).

Lemma subdom_def h1 h2 : subdom h1 h2 -> def h1 && def h2.

Lemma subdomP h1 h2 :
        def h1 -> ~~ empb h1 ->
        reflect (forall x, x \in dom h1 -> x \in dom h2)
                (subdom h1 h2).

Lemma subdomQ x h1 h2 : subdom h1 h2 -> x \in dom h1 -> x \in dom h2.

Lemma subdom_refl h : def h -> subdom h h.

Lemma subdomD h1 h2 h : subdom h1 h2 -> def (h2 :+ h) -> def (h1 :+ h).

Lemma subdomE h1 h2 h :
        def (h2 :+ h) -> subdom h1 h2 -> subdom (h1 :+ h) (h2 :+ h).

Lemma subdomUE h1 h2 h1' h2' :
        def (h2 :+ h2') -> subdom h1 h2 -> subdom h1' h2' ->
          subdom (h1 :+ h1') (h2 :+ h2').

Lemma subdom_emp h : def h -> subdom empty h.

Lemma subdom_emp_inv h : subdom h empty -> h = empty.

Lemma subdomPE A B x (v1 : A) (v2 : B) :
        x != null -> subdom (x :-> v1) (x :-> v2).

Lemma subdom_trans h2 h1 h3 : subdom h1 h2 -> subdom h2 h3 -> subdom h1 h3.

Hint Resolve subdom_emp subdomPE : core.

Lemma subheap_refl h : def h -> subheap h h.

Lemma subheapE h : def h -> subheap empty h.

Lemma subheapUn h1 h2 h1' h2' :
        def (h2 :+ h2') -> subheap h1 h2 -> subheap h1' h2' ->
        subheap (h1 :+ h1') (h2 :+ h2').

Lemma subheapUnl h1 h2 : def (h1 :+ h2) -> subheap h1 (h1 :+ h2).

Lemma subheapUnr h1 h2 : def (h1 :+ h2) -> subheap h2 (h1 :+ h2).

Lemma subheap_def h1 h2 : subheap h1 h2 -> def h1 /\ def h2.

Lemma subheap_trans h2 h1 h3 : subheap h1 h2 -> subheap h2 h3 -> subheap h1 h3.

Lemma subheap_id hp1 hp2: subheap hp1 hp2 -> subheap hp2 hp1 -> hp1 = hp2.

Lemma noalias h1 h2 x1 x2 :
        x1 \in dom h1 -> x2 \in dom h2 -> def (h1 :+ h2) -> x1 != x2.

Lemma defPtUn A h x (v : A) :
        def (x :-> v :+ h) = [&& x != null, def h & x \notin dom h].

Lemma defPt_null A h x (v : A) : def (x :-> v :+ h) -> x != null.

Lemma defPt_def A h x (v : A) : def (x :-> v :+ h) -> def h.

Lemma defPt_dom A h x (v : A) : def (x :-> v :+ h) -> x \notin dom h.

Lemma domPtUn A h x (v : A) :
        dom (x :-> v :+ h) =i
        [pred y | def (x :-> v :+ h) && ((x == y) || (y \in dom h))].

Lemma lookPtUn A h x (v : A) :
        def (x :-> v :+ h) -> look x (x :-> v :+ h) = dyn v.

Lemma freePtUn A h x (v : A) :
        def (x :-> v :+ h) -> free x (x :-> v :+ h) = h.

Lemma updPtUn A1 A2 x i (v1 : A1) (v2 : A2) :
        upd (x :-> v1 :+ i) x (dyn v2) = x :-> v2 :+ i.

Lemma heap_etaP h x : x \in dom h -> h = x :-> Dyn.val (look x h) :+ free x h.

Lemma cancelT A1 A2 h1 h2 x (v1 : A1) (v2 : A2) :
        def (x :-> v1 :+ h1) ->
          x :-> v1 :+ h1 = x :-> v2 :+ h2 -> A1 = A2.

Lemma cancel A h1 h2 x (v1 v2 : A) :
        def (x :-> v1 :+ h1) ->
        x :-> v1 :+ h1 = x :-> v2 :+ h2 -> [/\ v1 = v2, def h1 & h1 = h2].

Lemma domPtUnX A (v : A) x i : def (x :-> v :+ i) -> x \in dom (x :-> v :+ i).

Lemma domPtX A (v : A) x : def (x :-> v) -> x \in dom (x :-> v).

Lemma dom_notin_notin h1 h2 x :
        def (h1 :+ h2) -> x \notin dom (h1 :+ h2) -> x \notin dom h1.

Lemma dom_in_notin h1 h2 x : def (h1 :+ h2) -> x \in dom h1 -> x \notin dom h2.

Section BlockUpdate.
Variable (A : Type).

Fixpoint updi x (vs : seq A) {struct vs} : heap :=
  if vs is v'::vs' then (x :-> v') :+ updi (x .+ 1) vs' else empty.

Lemma updiS x v vs : updi x (v :: vs) = x :-> v :+ updi (x .+ 1) vs.

Lemma updi_last x v vs :
        updi x (rcons vs v) = updi x vs :+ x.+(size vs) :-> v.

Lemma updi_cat x vs1 vs2 :
        updi x (vs1 ++ vs2) = updi x vs1 :+ updi x.+(size vs1) vs2.

Lemma updi_catI x y vs1 vs2 :
        y = x.+(size vs1) -> updi x vs1 :+ updi y vs2 = updi x (vs1 ++ vs2).

Lemma updiVm' x m xs : m > 0 -> x \notin dom (updi x.+m xs).

Lemma updiD x xs : def (updi x xs) = (x != null) || (size xs == 0).

Lemma updiVm x m xs :
        x \in dom (updi x.+m xs) = [&& x != null, m == 0 & size xs > 0].

Lemma updimV x m xs :
        x.+m \in dom (updi x xs) = (x != null) && (m < size xs).

Lemma updiP x y xs :
        reflect (y != null /\ exists m, x = y.+m /\ m < size xs)

Lemma updi_inv x xs1 xs2 :
        def (updi x xs1) -> updi x xs1 = updi x xs2 -> xs1 = xs2.

Lemma updi_iinv x xs1 xs2 h1 h2 :
        size xs1 = size xs2 -> def (updi x xs1 :+ h1) ->
        updi x xs1 :+ h1 = updi x xs2 :+ h2 -> xs1 = xs2 /\ h1 = h2.

End BlockUpdate.

Definition low : pred ptr := fun x => 0 == nat_ptr x %[mod 2].
Definition high : pred ptr := fun x => 1 == nat_ptr x %[mod 2].

Definition get_lows h :=
  if h is Def hs _ then filter low (supp hs) else [::].

Definition get_highs h :=
  if h is Def hs _ then filter high (supp hs) else [::].

Definition ldom h : pred ptr := fun x => x \in get_lows h.
Definition hdom h : pred ptr := fun x => x \in get_highs h.

Lemma ldomP h x : x \in ldom h = (x \in dom h) && low x.

Lemma hdomP h x : x \in hdom h = (x \in dom h) && high x.

Lemma ldomK h1 h2 t1 t2 :
        def (h1 :+ t1) -> def (h2 :+ t2) ->
        ldom h1 =i ldom h2 ->
        ldom (h1 :+ t1) =i ldom (h2 :+ t2) -> ldom t1 =i ldom t2.

Definition lfresh h := (last null (get_lows h)) .+ 2.
Definition hfresh h := (last (null .+ 1) (get_highs h)) .+ 2.

Lemma last_inv A B (f : A -> B) (x1 x2 : A) (h : seq A) :
        f x1 = f x2 -> f (last x1 h) = f (last x2 h).

Lemma lfresh_low h n : low (lfresh h) .+ (2*n).

Lemma hfresh_high h n : high (hfresh h) .+ (2*n).

Lemma dom_lfresh h n : (lfresh h) .+ (2*n) \notin dom h.

Lemma dom_hfresh h n : (hfresh h) .+ (2*n) \notin dom h.

Lemma lfresh_null h : lfresh h != null.

Lemma hfresh_null h : hfresh h != null.

Lemma high_lowD : [predI low & high] =i pred0.

Lemma modnS x1 x2 : (x1 == x2 %[mod 2]) = (x1.+1 == x2.+1 %[mod 2]).

Lemma hlE x : high x = ~~ low x.

Lemma lhE x : low x = ~~ high x.

Lemma ldomUn h1 h2 :
        ldom (h1 :+ h2) =i
        [pred x | def (h1 :+ h2) && (x \in [predU ldom h1 & ldom h2])].

Definition loweq h1 h2 := get_lows h1 == get_lows h2.

Notation "h1 =~ h2" := (loweq h1 h2) (at level 80).

Lemma low_refl h : h =~ h.

Hint Resolve low_refl : core.

Lemma low_sym h1 h2 : (h1 =~ h2) = (h2 =~ h1).

Lemma low_trans h2 h1 h3 : h1 =~ h2 -> h2 =~ h3 -> h1 =~ h3.

Lemma loweqP h1 h2 : reflect (ldom h1 =i ldom h2) (h1 =~ h2).

Lemma loweqK h1 h2 t1 t2 :
        def (h1 :+ t1) -> def (h2 :+ t2) ->
        h1 =~ h2 -> h1 :+ t1 =~ h2 :+ t2 -> t1 =~ t2.

Lemma loweqE h1 h2 : h1 =~ h2 -> lfresh h1 = lfresh h2.

Lemma lowUn h1 h2 t1 t2 :
        def (h1 :+ t1) ->
        def (h2 :+ t2) ->
        h1 =~ h2 -> t1 =~ t2 -> h1 :+ t1 =~ h2 :+ t2.

Lemma lowPn A1 A2 (x : ptr) (v1 : A1) (v2 : A2) : x :-> v1 =~ x :-> v2.

Hint Resolve lowPn : core.

Lemma highPn A1 A2 (x1 x2 : ptr) (v1 : A1) (v2 : A2) :
        high x1 -> high x2 -> x1 :-> v1 =~ x2 :-> v2.

Lemma lowPtUn A1 A2 h1 h2 (x : ptr) (v1 : A1) (v2 : A2) :
        def (x :-> v1 :+ h1) ->
        def (x :-> v2 :+ h2) ->
        (x :-> v1 :+ h1 =~ x :-> v2 :+ h2) = (h1 =~ h2).

Lemma highPtUn A h1 h2 (x : ptr) (v : A) :
        def (x :-> v :+ h1) -> high x ->
        (x :-> v :+ h1 =~ h2) = (h1 =~ h2).

Lemma highPtUn2 A1 A2 h1 h2 (x1 x2 : ptr) (v1 : A1) (v2 : A2) :
        def (x1 :-> v1 :+ h1) ->
        def (x2 :-> v2 :+ h2) ->
        high x1 -> high x2 ->
        h1 =~ h2 -> x1 :-> v1 :+ h1 =~ x2 :-> v2 :+ h2.

Definition plus2 (h1 h2 : heap * heap) : heap * heap :=
  (h1.1 :+ h2.1, h1.2 :+ h2.2).

Definition def2 (h : heap * heap) := def h.1 && def h.2.

Notation "h1 :++ h2" := (plus2 h1 h2) (at level 50).

Lemma unA2 h1 h2 h3 : h1 :++ (h2 :++ h3) = h1 :++ h2 :++ h3.

Lemma unC2 h1 h2 : h1 :++ h2 = h2 :++ h1.

Lemma unKhl2 h h1 h2 : def2 (h1 :++ h) -> h1 :++ h = h2 :++ h -> h1 = h2.

Lemma unKhr2 h h1 h2 : def2 (h2 :++ h) -> h1 :++ h = h2 :++ h -> h1 = h2.

Lemma unDl2 h1 h2 : def2 (h1 :++ h2) -> def2 h1.

Lemma unDr2 h1 h2 : def2 (h1 :++ h2) -> def2 h2.

Lemma un0h2 h : (empty, empty) :++ h = h.

Lemma unh02 h : h :++ (empty, empty) = h.

Lemma injUh A h1 h2 x (v1 v2 : A) :
        def (h1 :+ (x :-> v1)) ->
        h1 :+ (x :-> v1) = h2 :+ (x :-> v2) ->
          def h1 /\ h1 = h2 /\ v1 = v2.

Lemma eqUh h1 h2 h : def (h1 :+ h) -> h1 :+ h = h2 :+ h -> def h1 /\ h1 = h2.

Lemma exit1 h1 h2 h : def (h1 :+ h) -> h1 :+ h = h :+ h2 -> def h1 /\ h1 = h2.

Lemma exit2 h1 h : def (h1 :+ h) -> h1 :+ h = h -> def h1 /\ h1 = empty.

Lemma exit3 h1 h : def h -> h = h :+ h1 -> def empty /\ empty = h1.

Lemma exit4 h : def h -> h = h -> def empty /\ empty = empty.

Ltac cancelator t H :=
  match goal with
  
  | |- ?h1 :+ t = ?h2 -> _ =>
     let j := fresh "j" in
     set j := {1}(h1 :+ t);
     rewrite -1?unA /j {j};
     (move/(exit1 H)=>{H} [H] || move/(exit2 H)=>{H} [H])
  | |- t = ?h2 -> _ =>
     rewrite -?unA;
     (move/(exit3 H)=>{H} [H] || move/(exit4 H)=>{H} [H])
  | |- (?h1 :+ (?x :-> ?v) = ?h2) -> _ =>
    let j := fresh "j" in
    set j := {1}(h1 :+ (x :-> v));
    
    rewrite 1?(unC (x :-> _)) -?(unAC _ _ (x :-> _)) /j {j};
    
    (move/(injUh H)=>{H} [H []] ||
    
     rewrite (unC h1) ?unA in H * );
    
    cancelator t H
  
  | |- (?h1 :+ ?h = ?h2) -> _ =>
    let j := fresh "j" in
    set j := {1}(h1 :+ h);
    
    rewrite 1?(unC h) -?(unAC _ _ h) /j {j};
    
    (move/(eqUh H)=>{H} [H []] ||
    
    rewrite (unC h1) ?unA in H * );
    
    cancelator t H
  | |- _ => idtac
  end.

Ltac heap_cancel :=
  match goal with
  | |- ?h1 = ?h2 -> ?GG =>
    let t1 := fresh "t1" in
    let t2 := fresh "t2" in
    let t := fresh "t" in
    let H := fresh "H" in
    let G := fresh "hidden_goal"
    in
      
      suff : def h1; first (
       
       set t1 := {1 2}h1; set t2 := {1}h2; set G := GG;
       
       rewrite -(un0h t1) -(un0h t2) [empty]lock;
       set t := locked empty; rewrite /t1 /t2 {t1 t2};
       move=>H;
       
       rewrite ?unA in H *;
       
       cancelator t H;
       
       move: H {t}; rewrite /G {G})
  | |- _ => idtac
  end.

Lemma cexit1 h1 h2 h : h1 = h2 -> h1 :+ h = h :+ h2.

Lemma cexit2 h1 h : h1 = empty -> h1 :+ h = h.

Lemma cexit3 h1 h : empty = h1 -> h = h :+ h1.

Lemma congUh A h1 h2 x (v1 v2 : A) :
        h1 = h2 -> v1 = v2 -> h1 :+ (x :-> v1) = h2 :+ (x :-> v2).

Lemma congeqUh h1 h2 h : h1 = h2 -> h1 :+ h = h2 :+ h.

Ltac congruencer t :=
  match goal with
  | |- ?h1 :+ t = ?h2 =>
     let j := fresh "j" in
     set j := {1}(h1 :+ t);
     rewrite -1?unA /j {j};
     (apply: cexit1 || apply: cexit2)
  | |- t = ?h2 =>
     rewrite -1?unA;
     (apply: cexit3 || apply: refl_equal)
  | |- (?h1 :+ (?x :-> ?v) = ?h2) =>
    let j := fresh "j" in
    set j := {1}(h1 :+ (x :-> v));
    
    rewrite 1?(unC (x :-> _)) -?(unAC _ _ (x :-> _)) /j {j};
    
    ((apply: congUh; [congruencer t | idtac]) ||
    
     (rewrite (unC h1) ?unA; congruencer t))
  
  | |- (?h1 :+ ?h = ?h2) =>
    let j := fresh "j" in
    set j := {1}(h1 :+ h);
    
    rewrite 1?(unC h) -?(unAC _ _ h) /j {j};
    
    (apply: congeqUh ||
    
    rewrite (unC h1) ?unA);
    
    congruencer t
  | |- _ => idtac
  end.

Ltac heap_congr :=
  match goal with
  | |- ?h1 = ?h2 =>
    let t1 := fresh "t1" in
    let t2 := fresh "t2" in
    let t := fresh "t" in
      set t1 := {1}h1; set t2 := {1}h2;
      
      rewrite -(un0h t1) -(un0h t2) [empty]lock;
      set t := locked empty; rewrite /t1 /t2 {t1 t2};
      
      rewrite ?unA;
      
      congruencer t=>{t}
  | |- _ => idtac
  end.

Lemma test h1 h2 h3 x (v1 v2 : nat) :
        h3 = h2 -> v1 = v2 ->
        h1 :+ (x :-> v1) :+ h3= h2 :+ h1 :+ (x :-> v2).

Definition supdom h2 h1 := subdom h1 h2.

Lemma sexit1 h1 h2 h :
        def (h2 :+ h) ->
          (def h2 -> supdom h2 h1) -> supdom (h2 :+ h) (h :+ h1).

Lemma sexit2 h1 h :
        def (h1 :+ h) -> (def h1 -> supdom h1 empty) ->
          supdom (h1 :+ h) h.

Lemma sexit3 h1 h :
        def h -> (def empty -> supdom empty h1) ->
          supdom h (h :+ h1).

Lemma sexit4 h : def h -> (def empty -> empty = empty) -> supdom h h.

Lemma supdomUh A B h1 h2 x (v1 : A) (v2 : B) :
        def (h2 :+ (x :-> v2)) ->
          (def h2 -> supdom h2 h1) ->
            supdom (h2 :+ (x :-> v2)) (h1 :+ (x :-> v1)).

Lemma supdomeqUh h1 h2 h :
        def (h2 :+ h) -> (def h2 -> supdom h2 h1) -> supdom (h2 :+ h) (h1 :+ h).

Lemma sup_defdef h1 h2 : def h2 -> supdom h2 h1 -> def h1.

Ltac supdom_checker t H :=
  match goal with
  | |- is_true (supdom (?h1 :+ t) ?h2) =>
     let j := fresh "j" in
     set j := {1}(h1 :+ t);
     rewrite -1?unA /j {j};
     (apply: (sexit1 H)=>{H} H || apply: (sexit2 H)=>{H} H)
  | |- is_true (supdom t ?h1) =>
     rewrite -1?unA;
     (apply: (sexit3 H)=>{H} H || apply: (sexit4 H)=>{H} H)
  | |- is_true (supdom (?h1 :+ (?x :-> ?v)) ?h2) =>
    let j := fresh "j" in
    set j := {1}(h1 :+ (x :-> v));
    
    rewrite 1?(unC (x :-> _)) -?(unAC _ _ (x :-> _)) /j {j};
    
    (apply: (supdomUh _ H)=>{H} H ||
    
     (rewrite (unC h1) ?unA in H * )); supdom_checker t H
  
  | |- is_true (supdom (?h1 :+ ?h) ?h2) =>
    let j := fresh "j" in
    set j := {1}(h1 :+ h);
    
    rewrite 1?(unC h) -?(unAC _ _ h) /j {j};
    
    (apply: (supdomeqUh H)=>{H} H ||
    
    (rewrite (unC h1) ?unA in H * ));
    
    supdom_checker t H
  | |- _ => idtac
  end.

Ltac defcheck :=
  match goal with
  | |- is_true (def ?h2) -> is_true (def ?h1) =>
    let t1 := fresh "t1" in
    let t2 := fresh "t2" in
    let t := fresh "t" in
    let H := fresh "H" in
      set t2 := {1}h2; set t1 := {1}h1;
      
      rewrite -(un0h t1) -(un0h t2) [empty]lock;
      set t := locked empty; rewrite /t1 /t2 {t1 t2};
      
      rewrite ?unA;
      move=>H;
      apply: (sup_defdef H);
      
      supdom_checker t H; move: H {t}; rewrite /supdom
  | |- _ => idtac
  end.

Ltac hhauto := (do ?econstructor=>//; try by [heap_congr])=>//. *)
(* rels:
From mathcomp
Require Import ssreflect ssrfun ssrbool seq.
Require Import Setoid.
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Lemma andTp p : True /\ p <-> p.      Proof. by intuition. Qed.
Lemma andFp p : False /\ p <-> False. Proof. by intuition. Qed.
Lemma orTp p : True \/ p <-> True.    Proof. by intuition. Qed.
Lemma orFp p : False \/ p <-> p.      Proof. by intuition. Qed.

Delimit Scope rel_scope with rel.
Open Scope rel_scope.

Definition Pred T := T -> Prop.
Identity Coercion fun_of_Pred : Pred >-> Funclass.

Notation xPred0 := (fun _ => False).
Notation xPred1 := (fun x y => x = y).
Notation xPredT := (fun _ => True).
Notation xPredI := (fun (p1 p2 : Pred _) x => p1 x /\ p2 x).
Notation xPredU := (fun (p1 p2 : Pred _) x => p1 x \/ p2 x).
Notation xPredC := (fun (p : Pred _) x => ~ p x).
Notation xPredD := (fun (p1 p2 : Pred _) x => ~ p2 x /\ p1 x).
Notation xPreim := (fun f (p : Pred _) x => p (f x)).

Section Predicates.
Variable T : Type.

Definition Simpl_Pred := simpl_fun T Prop.
Definition SimplPred (p : Pred T) : Simpl_Pred := SimplFun p.
Coercion Pred_of_Simpl (p : Simpl_Pred) : Pred T := p : T -> Prop.

Definition Pred0 := SimplPred xPred0.
Definition Pred1 x := SimplPred (xPred1 x).
Definition PredT := SimplPred xPredT.
Definition PredI p1 p2 := SimplPred (xPredI p1 p2).
Definition PredU p1 p2 := SimplPred (xPredU p1 p2).
Definition PredC p := SimplPred (xPredC p).
Definition PredD p1 p2 := SimplPred (xPredD p1 p2).
Definition Preim rT f (d : Pred rT) := SimplPred (xPreim f d).

CoInductive Mem_Pred : Type := MemProp of Pred T.
Definition isMem pT toPred mem := mem = (fun p : pT => MemProp [eta toPred p]).

Structure PredType : Type := PropPredType {
  Pred_Sort :> Type;
  toPred : Pred_Sort -> Pred T;
  _ : {mem | isMem toPred mem}}.

Definition mkPredType pT toP := PropPredType (exist (@isMem pT toP) _ (erefl _)).

Canonical Structure PredPredType := Eval hnf in @mkPredType (Pred T) id.
Canonical Structure SimplPredPredType := Eval hnf in mkPredType Pred_of_Simpl.
Coercion Pred_of_Mem mp : Pred_Sort PredPredType :=
  let: MemProp p := mp in [eta p].
Canonical Structure MemPredType := Eval hnf in mkPredType Pred_of_Mem.
Canonical Structure predPredType := Eval hnf in @mkPredType (pred T) id.
Canonical Structure simplpredPredType :=
  Eval hnf in @mkPredType (simpl_pred T) (fun p x => p x).

End Predicates.

Arguments Pred0 {T}.
Arguments PredT {T}.
Prenex Implicits PredI PredU PredC PredD Preim.

Notation "r1 +p r2" := (PredU r1 r2)
  (at level 55, right associativity) : rel_scope.
Notation "r1 *p r2" := (PredI r1 r2)
  (at level 45, right associativity) : rel_scope.

Notation "[ 'Pred' : T | E ]" := (SimplPred (fun _ : T => E))
  (at level 0, format "[ 'Pred' :  T  |  E ]") : fun_scope.
Notation "[ 'Pred' x | E ]" := (SimplPred (fun x => E))
  (at level 0, x ident, format "[ 'Pred'  x  |  E ]") : fun_scope.
Notation "[ 'Pred' x : T | E ]" := (SimplPred (fun x : T => E))
  (at level 0, x ident, only parsing) : fun_scope.
Notation "[ 'Pred' x y | E ]" := (SimplPred (fun t => let: (x, y) := t in E))
  (at level 0, x ident, y ident, format "[ 'Pred'  x  y  |  E ]") : fun_scope.
Notation "[ 'Pred' x y : T | E ]" :=
  (SimplPred (fun t : (T*T) => let: (x, y) := t in E))
  (at level 0, x ident, y ident, only parsing) : fun_scope.

Definition repack_Pred T pT :=
  let: PropPredType _ a mP := pT return {type of @PropPredType T for pT} -> _ in
   fun k => k a mP.

Notation "[ 'PredType' 'of' T ]" := (repack_Pred (fun a => @PropPredType _ T a))
  (at level 0, format "[ 'PredType'  'of'  T ]") : form_scope.

Notation Pred_Class := (Pred_Sort (PredPredType _)).
Coercion Sort_of_Simpl_Pred T (p : Simpl_Pred T) : Pred_Class := p : Pred T.

Definition PredArgType := Type.
Coercion Pred_of_argType (T : PredArgType) : Simpl_Pred T := PredT.

Notation "{ :: T }" := (T%type : PredArgType)
  (at level 0, format "{ ::  T }") : type_scope.

Definition Mem T (pT : PredType T) : pT -> Mem_Pred T :=
  nosimpl (let: PropPredType _ _ (exist mem _) := pT return pT -> _ in mem).
Definition InMem T x mp := nosimpl Pred_of_Mem T mp x.

Prenex Implicits Mem.

Coercion Pred_of_Mem_Pred T mp := [Pred x : T | InMem x mp].

Definition EqPredType T (pT : PredType T) (p1 p2 : pT) :=
  forall x : T, toPred p1 x <-> toPred p2 x.

Definition SubPredType T (pT : PredType T) (p1 p2 : pT) :=
  forall x : T, toPred p1 x -> toPred p2 x.

Definition EqPred T (p1 p2 : Pred T) := EqPredType p1 p2.
Definition SubPred T (p1 p2 : Pred T) := SubPredType p1 p2.
Definition EqSimplPred T (p1 p2 : Simpl_Pred T) := EqPredType p1 p2.
Definition SubSimplPred T (p1 p2 : Simpl_Pred T) := SubPredType p1 p2.

Definition EqPredFun T1 T2 p1 p2 :=
  forall x : T1, @EqPred T2 (p1 x) (p2 x).
Definition SubPredFun T1 T2 p1 p2 :=
  forall x : T1, @SubPred T2 (p1 x) (p2 x).

Definition EqMem T p1 p2 := forall x : T, InMem x p1 <-> InMem x p2.
Definition SubMem T p1 p2 := forall x : T, InMem x p1 -> InMem x p2.

Notation "A <~> B" := (EqPred A B)
  (at level 70, no associativity) : rel_scope.
Notation "A ~> B" := (SubPred A B)
  (at level 70, no associativity) : rel_scope.
Notation "A <~1> B" := (EqPredFun A B)
  (at level 70, no associativity) : rel_scope.
Notation "A ~1> B" := (SubPredFun A B)
  (at level 70, no associativity) : rel_scope.

Notation "x \In A" := (InMem x (Mem A))
  (at level 70, no associativity) : rel_scope.
Notation "x \Notin A" := (~ (x \In A))
  (at level 70, no associativity) : rel_scope.
Notation "A =p B" := (EqMem (Mem A) (Mem B))
  (at level 70, no associativity) : type_scope.
Notation "A <=p B" := (SubMem (Mem A) (Mem B))
  (at level 70, no associativity) : type_scope.

Notation "[ 'Mem' A ]" := (Pred_of_Simpl (Pred_of_Mem_Pred (Mem A)))
  (at level 0, only parsing) : fun_scope.
Notation "[ 'PredI' A & B ]" := (PredI [Mem A] [Mem B])
  (at level 0, format "[ 'PredI'  A  &  B ]") : fun_scope.
Notation "[ 'PredU' A & B ]" := (PredU [Mem A] [Mem B])
  (at level 0, format "[ 'PredU'  A  &  B ]") : fun_scope.
Notation "[ 'PredD' A & B ]" := (PredD [Mem A] [Mem B])
  (at level 0, format "[ 'PredD'  A  &  B ]") : fun_scope.
Notation "[ 'PredC' A ]" := (PredC [Mem A])
  (at level 0, format "[ 'PredC'  A ]") : fun_scope.
Notation "[ 'Preim' f 'of' A ]" := (Preim f [Mem A])
  (at level 0, format "[ 'Preim'  f  'of'  A ]") : fun_scope.

Notation "[ 'Pred' x \In A ]" := [Pred x | x \In A]
  (at level 0, x ident, format "[ 'Pred'  x  \In  A ]") : fun_scope.
Notation "[ 'Pred' x \In A | E ]" := [Pred x | (x \In A) /\ E]
  (at level 0, x ident, format "[ 'Pred'  x  \In  A  |  E ]") : fun_scope.
Notation "[ 'Pred' x y \In A & B | E ]" :=
  [Pred x y | (x \In A) /\ (y \In B) /\ E]
  (at level 0, x ident, y ident,
   format "[ 'Pred'  x  y  \In  A  &  B  |  E ]") : fun_scope.
Notation "[ 'Pred' x y \In A & B ]" := [Pred x y | (x \In A) /\ (y \In B)]
  (at level 0, x ident, y ident,
   format "[ 'Pred'  x  y  \In  A  &  B ]") : fun_scope.
Notation "[ 'Pred' x y \In A | E ]" := [Pred x y \In A & A | E]
  (at level 0, x ident, y ident,
   format "[ 'Pred'  x  y  \In  A  |  E ]") : fun_scope.
Notation "[ 'Pred' x y \In A ]" := [Pred x y \In A & A]
  (at level 0, x ident, y ident,
   format "[ 'Pred'  x  y  \In  A ]") : fun_scope.

Section Simplifications.
Variables (T : Type) (pT : PredType T).

Lemma Mem_toPred : forall (p : pT), Mem (toPred p) = Mem p.

Lemma toPredE : forall x (p : pT), toPred p x = (x \In p).

Lemma In_Simpl : forall x (p : Simpl_Pred T), (x \In p) = p x.

Lemma Simpl_PredE : forall (p : Pred T), [Pred x | p x] <~> p.

Lemma Mem_Simpl : forall (p : Simpl_Pred T), Mem p = p :> Pred T.

Definition MemE := Mem_Simpl. 

Lemma Mem_Mem : forall p : pT, (Mem (Mem p) = Mem p) * (Mem [Mem p] = Mem p).

End Simplifications.

Section RelProperties.
Variables (T : Type) (pT : PredType T).

Lemma EqPredType_refl (r : pT) : EqPredType r r. Proof. by []. Qed.

Lemma EqPredType_sym (r1 r2 : pT) : EqPredType r1 r2 -> EqPredType r2 r1.

Lemma EqPredType_trans' (r1 r2 r3 : pT) :
  EqPredType r1 r2 -> EqPredType r2 r3 -> EqPredType r1 r3.

Lemma SubPredType_trans' (r1 r2 r3 : pT) :
  SubPredType r1 r2 -> SubPredType r2 r3 -> SubPredType r1 r3.

Definition EqPredType_trans r2 r1 r3 := @EqPredType_trans' r1 r2 r3.
Definition SubPredType_trans r2 r1 r3 := @SubPredType_trans' r1 r2 r3.

Section RelLaws.
Variable (T : Type).

Lemma orrI (r : Pred T) : r +p r <~> r.

Lemma orrC (r1 r2 : Pred T) : r1 +p r2 <~> r2 +p r1.

Lemma orr0 (r : Pred T) : r +p Pred0 <~> r.

Lemma or0r (r : Pred T) : Pred0 +p r <~> r.

Lemma orrCA (r1 r2 r3 : Pred T) : r1 +p r2 +p r3 <~> r2 +p r1 +p r3.

Lemma orrAC (r1 r2 r3 : Pred T) : (r1 +p r2) +p r3 <~> (r1 +p r3) +p r2.

Lemma orrA (r1 r2 r3 : Pred T) : (r1 +p r2) +p r3 <~> r1 +p r2 +p r3.

Lemma orrAb (r1 a : Pred T) : r1 <~> r1 +p a <-> a ~> r1.

Lemma sub_orl (r1 r2 : Pred T) : r1 ~> r1 +p r2. Proof. by left. Qed.

End RelLaws.

Section SubMemLaws.
Variable T : Type.

Lemma subp_refl (p : Pred T) : p <=p p.

Lemma subp_asym (p1 p2 : Pred T) : p1 <=p p2 -> p2 <=p p1 -> p1 =p p2.

Lemma subp_trans (p2 p1 p3 : Pred T) : p1 <=p p2 -> p2 <=p p3 -> p1 <=p p3.

Lemma subp_or (p1 p2 q : Pred T) : p1 <=p q /\ p2 <=p q <-> p1 +p p2 <=p q.

Lemma subp_and (p1 p2 q : Pred T) : q <=p p1 /\ q <=p p2 <-> q <=p p1 *p p2.

Lemma subp_orl (p1 p2 q : Pred T) : p1 <=p p2 -> p1 +p q <=p p2 +p q.

Lemma subp_orr (p1 p2 q : Pred T) : p1 <=p p2 -> q +p p1 <=p q +p p2.

Lemma subp_andl (p1 p2 q : Pred T) : p1 <=p p2 -> p1 *p q <=p p2 *p q.

Lemma subp_andr (p1 p2 q : Pred T) : p1 <=p p2 -> q *p p1 <=p q *p p2.

End SubMemLaws.

Hint Resolve subp_refl : core.

Section ListMembership.
Variable T : Type.

Fixpoint Mem_Seq (s : seq T) :=
  if s is y::s' then (fun x => x = y \/ Mem_Seq s' x) else xPred0.

Definition EqSeq_Class := seq T.
Identity Coercion seq_of_EqSeq : EqSeq_Class >-> seq.

Coercion Pred_of_Eq_Seq (s : EqSeq_Class) : Pred_Class := [eta Mem_Seq s].

Canonical Structure seq_PredType := @mkPredType T (seq T) Pred_of_Eq_Seq.

Canonical Structure Mem_Seq_PredType := mkPredType Mem_Seq.

Lemma In_cons : forall y s x, (x \In y :: s) <-> (x = y) \/ (x \In s).

Lemma In_nil : forall x, (x \In [::]) <-> False.

Lemma Mem_Seq1 : forall x y, (x \In [:: y]) <-> (x = y).

Definition InE := (Mem_Seq1, In_cons, In_Simpl).
Lemma eqfun_sym A B (f1 f2 : A -> B) : f1 =1 f2 -> f2 =1 f1.
Lemma eqfun_trans A B (f1 f2 f3 : A -> B) : f1 =1 f2 -> f2 =1 f3 -> f1 =1 f3.

Add Parametric Relation A B : (A -> B) (@eqfun _ _)
  reflexivity proved by (@eqfun_refl A B)
  symmetry proved by (@eqfun_sym A B)
  transitivity proved by (@eqfun_trans A B) as eqfun_morph. *)
(* hprop:
From mathcomp
Require Import ssreflect ssrfun.
From LemmaOverloading
Require Import rels heaps.
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Ltac add_morphism_tactic := SetoidTactics.add_morphism_tactic.
Notation " R ===> R' " := (@Morphisms.respectful _ _ R R')
  (right associativity, at level 55) : signature_scope.

Definition star (p1 p2 : Pred heap) : Pred heap :=
  [Pred h | exists h1, exists h2, h = h1 :+ h2 /\ h1 \In p1 /\ h2 \In p2].

Definition emp : Pred heap := [Pred i | i = empty].
Definition this i : Pred heap := [Pred h : heap | i = h].
Definition ppts A x (v : A) : Pred heap := [Pred h | locked x :-> v = h].
Definition top : Pred heap := PredT.

Section BasicProperties.

Lemma starC p1 p2 : p1 # p2 <~> p2 # p1.

Lemma starp0 p : p # emp <~> p.

Lemma star0p p : emp # p <~> p.

Lemma starCA p1 p2 p3 : p1 # p2 # p3 <~> p2 # p1 # p3.

Lemma starA p1 p2 p3 : (p1 # p2) # p3 <~> p1 # p2 # p3.

Lemma starAC p1 p2 p3 : (p1 # p2) # p3 <~> (p1 # p3) # p2.

End BasicProperties. *)
(* stmod:
From mathcomp
Require Import ssreflect ssrbool ssrfun ssrnat eqtype seq.
From LemmaOverloading
Require Import prelude heaps rels hprop domains.
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Inductive exn : Type := exn_from_nat : nat -> exn.

Definition exn_to_nat (e : exn) : nat :=
  let: exn_from_nat y := e in y.

Definition eqexn (e1 e2 : exn) : bool :=
  match e1, e2 with exn_from_nat m, exn_from_nat n => m == n end.

Lemma eqexnP : Equality.axiom eqexn.

Canonical Structure exn_eqMixin := EqMixin eqexnP.
Canonical Structure exn_eqType := EqType exn exn_eqMixin.

Inductive ans (A : Type) : Type := Val of A | Exn of exn.
Arguments Exn [A].

Notation pre := (Pred heap).
Notation post A := (ans A -> heap -> heap -> Prop).
Definition spec B := pre * post B : Type.

Definition defed (P : Pred heap) : Pred heap :=
  fun i => i \In P /\ def i.

Notation ideald P := (ideal (defed P)).

Section BasePrograms.
Variables (A : Type) (P : Pred heap).

Lemma singleP i : i \In defed P -> this i <== defed P.

Definition single i (pf : i \In defed P) := Ideal (singleP pf).

Lemma bound (p : ideald P) i : i \In id_val p -> i \In defed P.

Definition prog := ideald P -> ans A -> Pred heap.

Definition coherent (e : prog) :=
  forall p x m,
    m \In e p x <-> exists i, exists pf : i \In id_val p,
                    m \In e (single (bound pf)) x.

Definition def_strict (e : prog) := forall p x, Undef \Notin e p x.

Definition runs_of (e : prog) : Pred (heap * ans A * heap) :=
  fun r => exists pf : r.1.1 \In defed P, r.2 \In e (single pf) r.1.2.

End BasePrograms.

Definition has_spec A (s : spec A) :=
  [Pred c : prog A s.1 |
     forall i y m, (i, y, m) \In runs_of c -> s.2 y i m].

Section STDef.
Variables (A : Type) (s : spec A).

Structure ST := STprog {
  model : prog A s.1;
  _ : coherent model;
  _ : def_strict model;
  _ : model \In has_spec s}.

Lemma modelE (e1 e2 : ST) : e1 = e2 <-> model e1 = model e2.

Definition st_leq e1 e2 := model e1 <== model e2.

Lemma st_refl e : st_leq e e.

Lemma st_asym e1 e2 : st_leq e1 e2 -> st_leq e2 e1 -> e1 = e2.

Lemma st_trans e1 e2 e3 : st_leq e1 e2 -> st_leq e2 e3 -> st_leq e1 e3.

Definition st_bot' := bot : [poset of prog A s.1].

Lemma st_bot_coherent : coherent st_bot'.

Lemma st_bot_dstrict : def_strict st_bot'.

Lemma st_bot_has_spec : st_bot' \In has_spec s.

Definition st_bot := STprog st_bot_coherent st_bot_dstrict st_bot_has_spec.

Lemma st_botP e : st_leq st_bot e.

Definition stPosetMixin := PosetMixin st_botP st_refl st_asym st_trans.
Canonical stPoset := Eval hnf in Poset ST stPosetMixin.

Definition st_sup' (u : Pred ST) :=
  sup [Pred p | exists e, p = model e /\ e \In u].

Lemma st_sup_coherent u : coherent (st_sup' u).

Lemma st_sup_dstrict u : def_strict (st_sup' u).

Lemma st_sup_has_spec u : st_sup' u \In has_spec s.

Definition st_sup u :=
  STprog (@st_sup_coherent u) (@st_sup_dstrict u) (@st_sup_has_spec u).

Lemma st_supP (u : Pred ST) e : e \In u -> st_leq e (st_sup u).

Lemma st_supM (u : Pred ST) e :
        (forall e1, e1 \In u -> st_leq e1 e) -> st_leq (st_sup u) e.

Definition stLatticeMixin := LatticeMixin st_supP st_supM.
Canonical stLattice := Lattice ST stLatticeMixin.

Lemma bot_runs : runs_of (model st_bot) =p Pred0.

Lemma model_runs p y m (e : ST) :
        m \In model e p y <->
        exists i, i \In id_val p /\ (i, y, m) \In runs_of (model e).

Lemma def_runs i y m (e : ST) :
        (i, y, m) \In runs_of (model e) -> [/\ def i, i \In s.1 & def m].

Lemma spec_runs i y m (e : ST) :
        (i, y, m) \In runs_of (model e) -> s.2 y i m.

End STDef.

Arguments spec_runs {A s i y m}.
Prenex Implicits bot_runs model_runs def_runs.

Module Model.

Section Fix.
Variables (A : Type) (B : A -> Type) (s : forall x, spec (B x)).
Notation tp := (forall x, ST (s x)).
Notation lat := (dfunLattice (fun x => [lattice of ST (s x)])).
Variable (f : tp -> tp).

Definition f' (e : lat) :=
  sup [Pred t : lat | exists e', e' <== e /\ t = f e'].

Definition ffix : tp := tarski_lfp f'.

End Fix.

Section Return.
Variables (A : Type) (x : A).

Definition ret_s : spec A :=
  (fun i => True, fun y i m => m = i /\ y = Val x).

Definition ret_sp (p : ideald ret_s.1) y m :=
  m \In id_val p /\ y = Val x.

Lemma ret_coherent : coherent ret_sp.

Lemma ret_dstrict : def_strict ret_sp.

Lemma ret_has_spec : ret_sp \In has_spec ret_s.

Definition ret := STprog ret_coherent ret_dstrict ret_has_spec.

End Return.

Section Throw.
Variables (A : Type) (e : exn).

Definition throw_s : spec A :=
  (fun i => True, fun y i m => m = i /\ y = Exn e).

Definition throw_sp (p : ideald throw_s.1) y m :=
  m \In id_val p /\ y = @Exn A e.

Lemma throw_coherent : coherent throw_sp.

Lemma throw_dstrict : def_strict throw_sp.

Lemma throw_has_spec : throw_sp \In has_spec throw_s.

Definition throw := STprog throw_coherent throw_dstrict throw_has_spec.

End Throw.

Section Bind.
Variables (A B : Type).
Variables (s1 : spec A) (s2 : A -> spec B).
Variables (e1 : ST s1) (e2 : forall x, ST (s2 x)).

Definition bind_pre : pre :=
  fun i => s1.1 i /\ forall x m, s1.2 (Val x) i m -> (s2 x).1 m.
Definition bind_post : post B :=
  fun y i m => (exists x, exists h, s1.2 (Val x) i h /\ (s2 x).2 y h m) \/
               (exists e, y = Exn e /\ s1.2 (Exn e) i m).
Definition bind_s := (bind_pre, bind_post).

Definition bind_sp (p : ideald bind_s.1) y m :=
   exists i, exists x, exists h, i \In id_val p /\
     (i, x, h) \In runs_of (model e1) /\
     match x with
       Val x' => (h, y, m) \In runs_of (model (e2 x'))
     | Exn e => y = Exn e /\ m = h
     end.

Lemma bind_coherent : coherent bind_sp.

Lemma bind_dstrict : def_strict bind_sp.

Lemma bind_has_spec : bind_sp \In has_spec bind_s.

Definition bind := STprog bind_coherent bind_dstrict bind_has_spec.

End Bind.

Section Try.
Variables (A B : Type) (s : spec A) (s1 : A -> spec B) (s2 : exn -> spec B).
Variables (e : ST s) (e1 : forall x, ST (s1 x)) (e2 : forall x, ST (s2 x)).

Definition try_pre : pre :=
  fun i => s.1 i /\ (forall y m, s.2 (Val y) i m -> (s1 y).1 m) /\
                     forall e m, s.2 (Exn e) i m -> (s2 e).1 m.
Definition try_post : post B :=
  fun y i m => (exists x, exists h, s.2 (Val x) i h /\ (s1 x).2 y h m) \/
               (exists e, exists h, s.2 (Exn e) i h /\ (s2 e).2 y h m).
Definition try_s := (try_pre, try_post).

Definition try_sp (p : ideald try_s.1) y m :=
   exists i, exists x, exists h, i \In id_val p /\
     (i, x, h) \In runs_of (model e) /\
     match x with
       Val x' => (h, y, m) \In runs_of (model (e1 x'))
     | Exn e => (h, y, m) \In runs_of (model (e2 e))
     end.

Lemma try_coherent : coherent try_sp.

Lemma try_dstrict : def_strict try_sp.

Lemma try_has_spec : try_sp \In has_spec try_s.

Definition try := STprog try_coherent try_dstrict try_has_spec.

End Try.

Definition conseq A (s1 s2 : spec A) :=
  forall i, s2.1 i -> def i ->
    s1.1 i /\ forall y m, s1.2 y i m -> def m -> s2.2 y i m.

Lemma conseq_refl (A : Type) (s : spec A) : conseq s s.

Hint Resolve conseq_refl : core.

Section Consequence.
Variables (A : Type) (s1 s2 : spec A) (e : ST s1) (pf : conseq s1 s2).

Definition do_sp (p : ideald s2.1) y m :=
  exists i, i \In id_val p /\ (i, y, m) \In runs_of (model e).

Lemma do_coherent : coherent do_sp.

Lemma do_dstrict : def_strict do_sp.

Lemma do_has_spec : do_sp \In has_spec s2.

Definition Do := STprog do_coherent do_dstrict do_has_spec.

End Consequence.

Section Read.
Variable (A : Type) (x : ptr).

Definition read_s : spec A :=
  (fun i => x \in dom i /\ exists v:A, look x i = dyn v,
   fun y i m => m = i /\ forall v, look x i = dyn v -> y = Val v).

Definition read_sp (p : ideald read_s.1) (v : ans A) m :=
  m \In id_val p /\ exists w, v = Val w /\ look x m = dyn w.

Lemma read_coherent : coherent read_sp.

Lemma read_dstrict : def_strict read_sp.

Lemma read_has_spec : read_sp \In has_spec read_s.

Definition read := STprog read_coherent read_dstrict read_has_spec.

End Read.

Section Write.
Variable (A : Type) (x : ptr) (v : A).

Definition write_s : spec unit :=
  (fun i => x \in dom i : Prop,
   fun y i m => y = Val tt /\ upd i x (dyn v) = m).

Definition write_sp (p : ideald write_s.1) (y : ans unit) m :=
  exists i, i \In id_val p /\ x \in dom i /\
            y = Val tt /\ m = upd i x (dyn v).

Lemma write_coherent : coherent write_sp.

Lemma write_dstrict : def_strict write_sp.

Lemma write_has_spec : write_sp \In has_spec write_s.

Definition write := STprog write_coherent write_dstrict write_has_spec.

End Write.

Section Allocation.
Variables (A : Type) (v : A).

Definition alloc_s : spec ptr :=
  (fun i => def i : Prop,
   fun y i m => exists x, x != null /\ y = Val x /\ x \notin dom i /\
                          upd i x (dyn v) = m).

Definition alloc_sp (p : ideald alloc_s.1) y m :=
  exists i, i \In id_val p /\ exists l : ptr, y = Val l /\
    m = i :+ l :-> v /\ l != null /\ l \notin dom i.

Lemma alloc_coherent : coherent alloc_sp.

Lemma alloc_dstrict : def_strict alloc_sp.

Lemma alloc_has_spec : alloc_sp \In has_spec alloc_s.

Definition alloc := STprog alloc_coherent alloc_dstrict alloc_has_spec.

End Allocation.

Section BlockAllocation.
Variables (A : Type) (v : A) (n : nat).

Definition allocb_s : spec ptr :=
  (fun i => def i : Prop,
   fun y i m => exists r, y = Val r /\ m = i :+ updi r (nseq n v)).

Definition allocb_sp (p : ideald allocb_s.1) y m :=
  exists i, i \In id_val p /\ y = Val (fresh i) /\
            m = i :+ updi (fresh i) (nseq n v).

Lemma allocb_coherent : coherent allocb_sp.

Lemma allocb_dstrict : def_strict allocb_sp.

Lemma allocb_has_spec : allocb_sp \In has_spec allocb_s.

Definition allocb := STprog allocb_coherent allocb_dstrict allocb_has_spec.

End BlockAllocation.

Section Deallocation.
Variable x : ptr.

Definition dealloc_s : spec unit :=
  (fun i => x \in dom i : Prop,
   fun y i m => y = Val tt /\ free x i = m).

Definition dealloc_sp (p : ideald dealloc_s.1) (y : ans unit) m :=
  exists i, i \In id_val p /\ y = Val tt /\ x \in dom i /\ m = free x i.

Lemma dealloc_coherent : coherent dealloc_sp.

Lemma dealloc_dstrict : def_strict dealloc_sp.

Lemma dealloc_has_spec : dealloc_sp \In has_spec dealloc_s.

Definition dealloc :=
  STprog dealloc_coherent dealloc_dstrict dealloc_has_spec.

End Deallocation.

End Model. *)
(* stsep:
From mathcomp
Require Import ssreflect ssrbool ssrnat ssrfun seq eqtype.
From LemmaOverloading
Require Import heaps rels hprop stmod.
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Delimit Scope stsep_scope with stsep.
Open Scope stsep_scope.

Definition lolli (p : _ -> Prop) q i m :=
  forall i1 h, i = i1 :+ h -> def i -> p i1 ->
    exists m1, m = m1 :+ h /\ def m /\ q i1 m1.

Notation "p '--o' q"   := (lolli p q) (at level 75) : stsep_scope.

Lemma antiframe p q i m h :
        def (i :+ h) -> (p --o q) (i :+ h) (m :+ h) -> (p --o q) i m.

Lemma locality p q i1 m h :
        def (i1 :+ h) -> (p # top) i1 -> (p --o q) (i1 :+ h) m ->
          exists m1, m = m1 :+ h /\ def m /\ (p --o q) i1 m1.

Lemma fr_pre p i j : (p # top) i -> (p # top) (i :+ j).

Definition fr A (s : spec A) : spec A :=
  (s.1 # top, fun x => s.1 --o s.2 x).

Prenex Implicits fr.

Notation "[ s ]" := (fr s).

Definition STsep A (s : spec A) := ST [s].

Section SepReturn.
Variable (A : Type) (x : A).

Definition ret_s : spec A := (emp, fun y i m => m = i /\ y = Val x).

Lemma retP : Model.conseq (Model.ret_s x) [ret_s].

Definition ret := Model.Do (Model.ret x) retP.

End SepReturn.

Section SepBind.
Variables (A B : Type) (s1 : spec A) (s2 : A -> spec B).
Variables (e1 : STsep s1) (e2 : forall x, STsep (s2 x)).

Definition bind_s : spec B :=
  (Model.bind_pre [s1] (fr \o s2), Model.bind_post [s1] (fr \o s2)).

Lemma bindP : Model.conseq (Model.bind_s [s1] (fr \o s2)) [bind_s].

Definition bind : STsep bind_s := Model.Do (Model.bind e1 e2) bindP.

End SepBind.

Definition verify' A (s : spec A) i (r : ans A -> heap -> Prop) :=
  def i -> s.1 i /\ forall y m, s.2 y i m -> def m -> r y m.

Notation verify s i r := (@verify' _ [s] i r).

Section SepFrame.
Variables (A : Type) (s : spec A).

Lemma frame i j (r : ans A -> heap -> Prop) :
        verify s i (fun y m => def (m :+ j) -> r y (m :+ j)) ->
        verify s (i :+ j) r.

Lemma frame0 i r : verify' s i r -> verify s i r.

Lemma frame1 i (r : ans A -> heap -> Prop) :
        verify' s empty (fun y m => def (m :+ i) -> r y (m :+ i)) ->
        verify s i r.

End SepFrame.

Definition conseq A (s : spec A) (p : pre) (q : post A) :=
  forall i, p i -> verify s i (fun y m => q y i m).

Local Notation conseq1 :=
  (fun A (s1 s2 : spec A) =>
     conseq s1 (let 'pair x _ := s2 in x)
               (let 'pair _ x := s2 in x)).

Lemma conseq_refl A (s : spec A) : conseq1 A s s.

Hint Resolve conseq_refl : core.

Section SepConseq.
Variables (A : Type) (s1 s2 : spec A) (e : STsep s1).
Variables (pf : conseq1 A s1 s2).

Lemma doP : Model.conseq [s1] [s2].

Definition do' : STsep s2 := Model.Do e doP.

End SepConseq.

Notation "'Do' e" := (do' e _) (at level 80).

Section SepRead.
Variables (A : Type) (x : ptr).

Definition read_s : spec A :=
  (fun i => exists v : A, i = x :-> v,
   fun y i m => i = m /\ forall v, i = x :-> v -> y = Val v).

Lemma readP : Model.conseq (Model.read_s A x) [read_s].

Definition read : STsep read_s := Model.Do (Model.read A x) readP.

End SepRead.

Section SepWrite.
Variables (A : Type) (x : ptr) (v : A).

Definition write_s : spec unit :=
  (fun i => exists B : Type, exists y : B, i = x :-> y,
   fun y i m => y = Val tt /\ m = x :-> v).

Lemma writeP : Model.conseq (Model.write_s x v) [write_s].

Definition write : STsep write_s := Model.Do (Model.write x v) writeP.

End SepWrite.

Section SepAlloc.
Variables (A : Type) (v : A).

Definition alloc_s : spec ptr :=
  (emp, fun y i m => exists x, y = Val x /\ m = x :-> v).

Lemma allocP : Model.conseq (Model.alloc_s v) [alloc_s].

Definition alloc : STsep alloc_s := Model.Do (Model.alloc v) allocP.

End SepAlloc.

Section SepBlockAlloc.
Variables (A : Type) (v : A) (n : nat).

Definition allocb_s : spec ptr :=
  (emp, fun y i m => exists x:ptr, y = Val x /\ m = updi x (nseq n v)).

Lemma allocbP : Model.conseq (Model.allocb_s v n) [allocb_s].

Definition allocb : STsep allocb_s := Model.Do (Model.allocb v n) allocbP.

End SepBlockAlloc.

Section SepDealloc.
Variable x : ptr.

Definition dealloc_s : spec unit :=
  (fun i => exists A : Type, exists v:A, i = x :-> v,
   fun y i m => y = Val tt /\ m = empty).

Lemma deallocP : Model.conseq (Model.dealloc_s x) [dealloc_s].

Definition dealloc : STsep dealloc_s := Model.Do (Model.dealloc x) deallocP.

End SepDealloc.

Section SepThrow.
Variables (A : Type) (e : exn).

Definition throw_s : spec A :=
  (emp, fun y i m => m = i /\ y = Exn e).

Lemma throwP : Model.conseq (Model.throw_s A e) [throw_s].

Definition throw : STsep throw_s := Model.Do (Model.throw A e) throwP.

End SepThrow.

Section SepTry.
Variables (A B : Type) (s : spec A) (s1 : A -> spec B) (s2 : exn -> spec B).
Variables (e : STsep s) (e1 : forall x, STsep (s1 x)).
Variables (e2 : forall e, STsep (s2 e)).

Definition try_s : spec B :=
  (Model.try_pre [s] (fr \o s1) (fr \o s2),
   Model.try_post [s] (fr \o s1) (fr \o s2)).

Lemma tryP : Model.conseq (Model.try_s [s] (fr \o s1) (fr \o s2)) [try_s].

Definition try : STsep try_s := Model.Do (Model.try e e1 e2) tryP.

End SepTry.

Section SepFix.
Variables (A : Type) (B : A -> Type) (s : forall x, spec (B x)).
Notation tp := (forall x, STsep (s x)).

Definition Fix (f : tp -> tp) : tp := Model.ffix f.

End SepFix.

Section CondBool.
Variables (A : Type) (b : bool) (s1 s2 : spec A).

Program
Definition If (e1 : STsep s1) (e2 : STsep s2) : STsep (if b then s1 else s2) :=
  match b with true => Do e1 | false => Do e2 end.

End CondBool.

Section CondOption.
Variable (A B : Type) (x : option A) (s1 : spec B) (s2 : A -> spec B).

Program
Definition Match_opt (e1 : STsep s1) (e2 : forall v, STsep (s2 v)) :
             STsep (match x with Some v => s2 v | None => s1 end) :=
  match x with Some v => Do (e2 v) | None => Do e1 end.

End CondOption.

Section CondDecide.
Variable (A : Type) (p1 p2 : Prop) (b : {p1} + {p2})
         (s1 : p1 -> spec A) (s2 : p2 -> spec A).

Program
Definition Match_dec (e1 : forall x, STsep (s1 x))
                     (e2 : forall x, STsep (s2 x)) :
             STsep (match b with left x => s1 x | right x => s2 x end) :=
  match b with left x => Do (e1 x) | right x => Do (e2 x) end.

End CondDecide.

Section CondNat.
Variable (A : Type) (n : nat) (s1 : spec A) (s2 : nat -> spec A).

Program
Definition Match_nat (e1 : STsep s1) (e2 : forall n, STsep (s2 n)) :
             STsep (match n with 0 => s1 | m.+1 => s2 m end) :=
  match n with 0 => Do e1 | m.+1 => Do (e2 m) end.

End CondNat.

Section CondSeq.
Variable (A B : Type) (s : seq A) (s1 : spec B) (s2 : A -> seq A -> spec B).

Program
Definition Match_seq (e1 : STsep s1) (e2 : forall hd tl, STsep (s2 hd tl)) :
             STsep (match s with [::] => s1 | hd::tl => s2 hd tl end) :=
  match s with [::] => Do e1 | hd::tl => Do (e2 hd tl) end.

End CondSeq.

Section Ghosts.
Variables (A : Type) (s : spec A) (p : pre).

Lemma allC (B1 B2 : Type) (q : B1 -> B2 -> post A) :
       conseq s p (fun y i m => forall x1 x2, q x1 x2 y i m) <->
       conseq s p (fun y i m => forall x, q x.1 x.2 y i m).

Lemma impC (B : Type) (q1 q2 : heap -> B -> Prop) (r : B -> post A) :
        conseq s p (fun y i m => forall x, q1 i x -> q2 i x -> r x y i m) <->
        conseq s p (fun y i m => forall x, q1 i x /\ q2 i x -> r x y i m).

Lemma ghE (B : Type) (q : heap -> B -> Prop) (r : B -> post A) :
        (forall i, p i -> def i -> exists x, q i x) ->
        (forall i x, q i x -> p i -> def i ->
           verify s i (fun y m => r x y i m)) ->
        conseq s p (fun y i m => forall x, q i x -> r x y i m).

End Ghosts.

Definition gh := (allC, impC).

Notation "x '<--' c1 ';' c2" := (bind c1 (fun x => c2))
  (at level 78, right associativity) : stsep_scope.
Notation "c1 ';;' c2" := (bind c1 (fun _ => c2))
  (at level 78, right associativity) : stsep_scope.
Notation "'!' x" := (read _ x) (at level 50) : stsep_scope.
Notation "e1 '::=' e2" := (write e1 e2) (at level 60) : stsep_scope.
Notation "'throw' [ t ] E" := (throw t E)
  (at level 70, no associativity) : stsep_scope.
Notation "'ttry' E 'then' [ r ] E1 'else' [ x ] E2" :=
  (try E (fun r => E1) (fun x => E2)) (at level 80) : stsep_scope.
Notation "'ttry' E 'then' [ r ] E1 'else' E2" :=
  (try E (fun r => E1) (fun _ => E2)) (at level 80) : stsep_scope.
Notation "'ttry' E 'then' E1 'else' [ x ] E2" :=
  (try E (fun _ => E1) (fun x => E2)) (at level 80) : stsep_scope.
Notation "'ttry' E 'then' E1 'else' E2" :=
  (try E (fun _ => E1) (fun _ => E2)) (at level 80) : stsep_scope.
Notation "'match_opt' E 'then' E1 'else' [ x ] E2" :=
  (Match_opt E E1 (fun x => E2)) (at level 80) : stsep_scope.
Notation "'match_opt' E 'then' E1 'else' [ x ] E2" :=
  (Match_opt E E1 (fun x => E2)) (at level 80) : stsep_scope.
Notation "'If' E 'then' E1 'else' E2" :=
  (If E E1 E2) (at level 80) : stsep_scope. *)

Set Implicit Arguments.

Unset Strict Implicit.

Unset Printing Implicit Defensive.



Lemma bnd_is_try (A B : Type) (s1 : spec A) (s2 : A -> spec B) i r :

        verify (try_s s1 s2 (fun y => fr (throw_s B y))) i r ->

        verify (bind_s s1 s2) i r.

Proof.

move=>H; apply: frame0=>D.

case: {H D} (H D) (D)=>[[i1]][i2][->][[H1 [H2 H3]]] _ T D.

split=>[|y m].

- split=>[|x m]; first by apply: fr_pre H1.

  by case/(locality D H1)=>m1 [->][_]; move/H2; apply: fr_pre.

move=>{D} H; apply: T=>h1 h2 E.

rewrite {i1 i2 H1 H2 H3}E in H * => D1 [H1][H2] H3.

case: H=>[[x][h][]|[e][->]]; move/(locality D1 H1);

case=>[m1][->][D2] T1; move: (T1); [move/H2 | move/H3]=>H4.

- move=>T2; case/(locality D2 H4): (T2)=>m3 [->][D3].

  by exists m3; do !split=>//; left; exists x; exists m1.

exists m1; do !split=>//; right; exists e; exists m1; split=>//.

move=>j1 j2 E D _; rewrite {m1 D2}E in T1 D H4 *.

exists j1; do !split=>//; move=>k1 k2 -> D2 ->.

by exists empty; rewrite un0h; do !split=>//; apply: defUnr D2.

Qed.



Local Notation cont A := (ans A -> heap -> Prop).



Section EvalDo.

Variables (A B : Type).



Lemma val_do (s : spec A) i j (r : cont A) :

         s.1 i ->

         (forall x m, s.2 (Val x) i m -> def (m :+ j) -> r (Val x) (m :+ j)) ->

         (forall e m, s.2 (Exn e) i m -> def (m :+ j) -> r (Exn e) (m :+ j)) ->

         verify s (i :+ j) r.

Proof.

move=>H1 H2 H3; apply: frame; apply: frame0; split=>//.

by case=>x m H4 D1 D2; [apply: H2 | apply: H3].

Qed.



Lemma try_do (s : spec A) s1 s2 i j (r : cont B) :

        s.1 i ->

        (forall x m, s.2 (Val x) i m -> verify (s1 x) (m :+ j) r) ->

        (forall e m, s.2 (Exn e) i m -> verify (s2 e) (m :+ j) r) ->

        verify (try_s s s1 s2) (i :+ j) r.

Proof.

move=>H1 H2 H3; apply: frame0=>D; split=>[|y m].

- split; first by apply: fr_pre; exists i; exists empty; rewrite unh0.

  by split=>y m; case/(_ i j (erefl _) D H1)=>m1 [->][D2]; [case/H2 | case/H3].

by case=>[[x]|[e]][h][]; case/(_ i j (erefl _) D H1)=>m1 [->][D2];

   [case/H2 | case/H3]=>// _; apply.

Qed.



Lemma bnd_do (s : spec A) s2 i j (r : cont B) :

        s.1 i ->

        (forall x m, s.2 (Val x) i m -> verify (s2 x) (m :+ j) r) ->

        (forall e m, s.2 (Exn e) i m -> def (m :+ j) -> r (Exn e) (m :+ j)) ->

        verify (bind_s s s2) (i :+ j) r.

Proof.

move=>H1 H2 H3; apply: bnd_is_try.

apply: try_do=>// e m H4; apply: frame0; apply: frame1=>_.

by split=>// y m1 [->] -> _; rewrite un0h; apply: H3.

Qed.



End EvalDo.



Section EvalReturn.

Variables (A B : Type).



Lemma val_ret v i (r : cont A) :

       (def i -> r (Val v) i) -> verify (ret_s v) i r.

Proof.

by rewrite -[i]un0h=>H; apply: val_do=>// x m [->] // [->].

Qed.



Lemma try_ret s1 s2 (v : A) i (r : cont B) :

        verify (s1 v) i r -> verify (try_s (ret_s v) s1 s2) i r.

Proof.

by rewrite -[i]un0h=>H; apply: try_do=>// x m [->] // [->].

Qed.



Lemma bnd_ret s (v : A) i (r : cont B) :

        verify (s v) i r -> verify (bind_s (ret_s v) s) i r.

Proof. by move=>H; apply: bnd_is_try; apply: try_ret. Qed.



End EvalReturn.



Section EvalRead.

Variables (A B : Type).



Lemma val_read v x i (r : cont A) :

        (def (x :-> v :+ i) -> r (Val v) (x :-> v :+ i)) ->

        verify (read_s A x) (x :-> v :+ i) r.

Proof.

move=>*; apply: val_do; first by [exists v];

by move=>y m [<-]; move/(_ v (erefl _))=>// [->].

Qed.



Lemma try_read s1 s2 v x i (r : cont B) :

        verify (s1 v) (x :-> v :+ i) r ->

        verify (try_s (read_s A x) s1 s2) (x :-> v :+ i) r.

Proof.

move=>*; apply: try_do; first by [exists v];

by move=>y m [<-]; move/(_ v (erefl _))=>// [->].

Qed.



Lemma bnd_read s v x i (r : cont B) :

        verify (s v) (x :-> v :+ i) r ->

        verify (bind_s (read_s A x) s) (x :-> v :+ i) r.

Proof. by move=>*; apply: bnd_is_try; apply: try_read. Qed.



End EvalRead.



Section EvalWrite.

Variables (A B C : Type).



Lemma val_write (v : A) (w : B) x i (r : cont unit) :

        (def (x :-> v :+ i) -> r (Val tt) (x :-> v :+ i)) ->

        verify (write_s x v) (x :-> w :+ i) r.

Proof.

move=>*; apply: val_do; first by [exists B; exists w];

by move=>y m [// [->] ->].

Qed.



Lemma try_write s1 s2 (v: A) (w : C) x i (r : cont B) :

        verify (s1 tt) (x :-> v :+ i) r ->

        verify (try_s (write_s x v) s1 s2) (x :-> w :+ i) r.

Proof.

move=>*; apply: try_do; first by [exists C; exists w];

by move=>y m [// [->] ->].

Qed.



Lemma bnd_write s (v : A) (w : C) x i (r : cont B) :

        verify (s tt) (x :-> v :+ i) r ->

        verify (bind_s (write_s x v) s) (x :-> w :+ i) r.

Proof. by move=>*; apply: bnd_is_try; apply: try_write. Qed.



End EvalWrite.



Section EvalAlloc.

Variables (A B : Type).



Lemma val_alloc (v : A) i (r : cont ptr) :

        (forall x, def (x :-> v :+ i) -> r (Val x) (x :-> v :+ i)) ->

        verify (alloc_s v) i r.

Proof.

move=>H; rewrite -[i]un0h; apply: val_do=>//;

by move=>y m [x][//][-> ->]; apply: H.

Qed.



Lemma try_alloc s1 s2 (v : A) i (r : cont B) :

        (forall x, verify (s1 x) (x :-> v :+ i) r) ->

        verify (try_s (alloc_s v) s1 s2) i r.

Proof.

move=>H; rewrite -[i]un0h; apply: try_do=>//;

by move=>y m [x][//][-> ->]; apply: H.

Qed.



Lemma bnd_alloc s (v : A) i (r : cont B) :

        (forall x, verify (s x) (x :-> v :+ i) r) ->

        verify (bind_s (alloc_s v) s) i r.

Proof. by move=>*; apply: bnd_is_try; apply: try_alloc. Qed.



End EvalAlloc.



Section EvalBlockAlloc.

Variables (A B : Type).



Lemma val_allocb (v : A) n i (r : cont ptr) :

        (forall x, def (updi x (nseq n v) :+ i) ->

           r (Val x) (updi x (nseq n v) :+ i)) ->

        verify (allocb_s v n) i r.

Proof.

move=>H; rewrite -[i]un0h; apply: val_do=>//;

by move=>y m [x][//][->]->; apply: H.

Qed.



Lemma try_allocb s1 s2 (v : A) n i (r : cont B) :

        (forall x, verify (s1 x) (updi x (nseq n v) :+ i) r) ->

        verify (try_s (allocb_s v n) s1 s2) i r.

Proof.

move=>H; rewrite -[i]un0h; apply: try_do=>//;

by move=>y m [x][//][->]->; apply: H.

Qed.



Lemma bnd_allocb s (v : A) n i (r : cont B) :

        (forall x, verify (s x) (updi x (nseq n v) :+ i) r) ->

        verify (bind_s (allocb_s v n) s) i r.

Proof. by move=>*; apply: bnd_is_try; apply: try_allocb. Qed.



End EvalBlockAlloc.



Section EvalDealloc.

Variables (A B : Type).



Lemma val_dealloc (v : A) x i (r : cont unit) :

        (def i -> r (Val tt) i) ->

        verify (dealloc_s x) (x :-> v :+ i) r.

Proof.

move=>H; apply: val_do; first by [exists A; exists v];

by move=>y m [//][->] ->; rewrite un0h.

Qed.



Lemma try_dealloc s1 s2 (v : B) x i (r : cont A) :

        verify (s1 tt) i r ->

        verify (try_s (dealloc_s x) s1 s2) (x :-> v :+ i) r.

Proof.

move=>H; apply: try_do; first by [exists B; exists v];

by move=>y m [//][->] ->; rewrite un0h.

Qed.



Lemma bnd_dealloc s (v : B) x i (r : cont A) :

        verify (s tt) i r ->

        verify (bind_s (dealloc_s x) s) (x :-> v :+ i) r.

Proof. by move=>*; apply: bnd_is_try; apply: try_dealloc. Qed.



End EvalDealloc.



Section EvalThrow.

Variables (A B : Type).



Lemma val_throw e i (r : cont A) :

        (def i -> r (Exn e) i) -> verify (throw_s A e) i r.

Proof.

move=>H; rewrite -[i]un0h; apply: val_do=>//;

by move=>y m [->] // [->]; rewrite un0h.

Qed.



Lemma try_throw s1 s2 e i (r : cont B) :

        verify (s2 e) i r ->

        verify (try_s (throw_s A e) s1 s2) i r.

Proof.

move=>H; rewrite -[i]un0h; apply: try_do=>//;

by move=>y m [->] // [->]; rewrite un0h.

Qed.



Lemma bnd_throw s e i (r : cont B) :

        (def i -> r (Exn e) i) ->

        verify (bind_s (throw_s A e) s) i r.

Proof.

move=>H; apply: bnd_is_try; apply: try_throw; apply: frame0.

by rewrite -[i]un0h; apply: val_do=>// y m [->] // [->]; rewrite un0h.

Qed.



End EvalThrow.



Section EvalGhost.

Variables (A B C : Type) (t : C) (p : C -> Pred heap) (q : C -> post A).

Variables (s1 : A -> spec B) (s2 : exn -> spec B) (i j : heap) (P : Pred heap).



Lemma val_gh (r : cont A) :

        let: s := (fun i => exists x, i \In p x,

                   fun y i m => forall x, i \In p x -> q x y i m) in

        (forall x m, q t (Val x) i m -> def (m :+ j) -> r (Val x) (m :+ j)) ->

        (forall e m, q t (Exn e) i m -> def (m :+ j) -> r (Exn e) (m :+ j)) ->

        i \In p t ->

        verify s (i :+ j) r.

Proof. by move=>*; apply: val_do=>/=; eauto. Qed.



Lemma val_gh1 (r : cont A) :

        let: Q := fun y i m => forall x, i \In p x -> q x y i m in

        (i \In p t -> P i) ->

        (forall x m, q t (Val x) i m -> def (m :+ j) -> r (Val x) (m :+ j)) ->

        (forall e m, q t (Exn e) i m -> def (m :+ j) -> r (Exn e) (m :+ j)) ->

        i \In p t ->

        verify (P, Q) (i :+ j) r.

Proof. by move=>*; apply: val_do=>/=; eauto. Qed.



Lemma try_gh (r : cont B) :

        let: s := (fun i => exists x, i \In p x,

                   fun y i m => forall x, i \In p x -> q x y i m) in

        (forall x m, q t (Val x) i m -> verify (s1 x) (m :+ j) r) ->

        (forall e m, q t (Exn e) i m -> verify (s2 e) (m :+ j) r) ->

        i \In p t ->

        verify (try_s s s1 s2) (i :+ j) r.

Proof. by move=>*; apply: try_do=>/=; eauto. Qed.



Lemma try_gh1 (r : cont B) :

        let: Q := fun y i m => forall x, i \In p x -> q x y i m in

        (i \In p t -> P i) ->

        (forall x m, q t (Val x) i m -> verify (s1 x) (m :+ j) r) ->

        (forall e m, q t (Exn e) i m -> verify (s2 e) (m :+ j) r) ->

        i \In p t ->

        verify (try_s (P, Q) s1 s2) (i :+ j) r.

Proof. by move=>*; apply: try_do=>/=; eauto. Qed.



Lemma bnd_gh (r : cont B) :

        let: s := (fun i => exists x, i \In p x,

                   fun y i m => forall x, i \In p x -> q x y i m) in

        (forall x m, q t (Val x) i m -> verify (s1 x) (m :+ j) r) ->

        (forall e m, q t (Exn e) i m -> def (m :+ j) -> r (Exn e) (m :+ j)) ->

        i \In p t ->

        verify (bind_s s s1) (i :+ j) r.

Proof. by move=>*; apply: bnd_do=>/=; eauto. Qed.



Lemma bnd_gh1 (r : cont B) :

        let: Q := fun y i m => forall x, i \In p x -> q x y i m in

        (i \In p t -> P i) ->

        (forall x m, q t (Val x) i m -> verify (s1 x) (m :+ j) r) ->

        (forall e m, q t (Exn e) i m -> def (m :+ j) -> r (Exn e) (m :+ j)) ->

        i \In p t ->

        verify (bind_s (P, Q) s1) (i :+ j) r.

Proof. by move=>*; apply: bnd_do=>/=; eauto. Qed.



End EvalGhost.



Definition pull (A : Type) x (v:A) := (unC (x :-> v), unCA (x :-> v)).

Definition push (A : Type) x (v:A) := (unCA (x :-> v), unC (x :-> v)).



Ltac hstep :=

  match goal with

    | |- verify ?h (ret_s _) _ =>

      apply: val_ret

    | |- verify ?h (try_s (ret_s _) _ _) _ =>

      apply: try_ret

    | |- verify ?h (bind_s (ret_s _) _) _ =>

      apply: bnd_ret



    | |- verify ?h (read_s _ ?l) _ =>

      rewrite -?(pull l); apply: val_read

    | |- verify ?h (try_s (read_s _ ?l) _ _) _ =>

      rewrite -?(pull l); apply: try_read

    | |- verify (?h) (bind_s (read_s _ ?l) _) _ =>

      rewrite -?(pull l); apply: bnd_read



    | |- verify (?h) (write_s ?l _) _ =>

      rewrite -?(pull l); apply: val_write

    | |- verify (?h) (try_s (write_s ?l _) _ _) _ =>

      rewrite -?(pull l); apply: try_write

    | |- verify (?h) (bind_s (write_s ?l _) _) _ =>

      rewrite -?(pull l); apply: bnd_write



    | |- verify ?h (alloc_s _) _ =>

      apply: val_alloc

    | |- verify ?h (try_s (alloc_s _) _ _) _ =>

      apply: try_alloc

    | |- verify ?h (bind_s (alloc_s _) _) _ =>

      apply: bnd_alloc



    | |- verify ?h (allocb_s _ _) _ =>

      apply: val_allocb

    | |- verify ?h (try_s (allocb_s _ _) _ _) _ =>

      apply: try_allocb

    | |- verify ?h (bind_s (allocb_s _ _) _) _ =>

      apply: bnd_allocb



    | |- verify ?h (dealloc_s ?l) _ =>

      rewrite -?(pull l); apply: val_dealloc

    | |- verify ?h (try_s (dealloc_s ?l) _ _) _ =>

      rewrite -?(pull l); apply: try_dealloc

    | |- verify ?h (bind_s (dealloc_s ?l) _) _ =>

      rewrite -?(pull l); apply: bnd_dealloc



    | |- verify ?h (throw_s _ _) _ =>

      apply: val_throw

    | |- verify ?h (try_s (throw_s _ _) _ _) _ =>

      apply: try_throw

    | |- verify ?h (bind_s (throw_s _ _) _) _ =>

      apply: bnd_throw

  end.



Lemma swp : forall (A : Type) (v : A) x h, h \In x :--> v <-> h = x :-> v.

Proof. by move=>A v x h; split; rewrite InE /pts /=; unlock. Qed.



Lemma opn : forall (A : Type) (v : A) x h, h \In x :--> v <-> x :-> v = h.

Proof. by move=>A v x h; split=>[|H]; rewrite InE /= /pts; unlock. Qed.



Prenex Implicits swp opn.



Lemma blah (A : Type) (p : ptr) (l : A) : def (p :-> l) -> (p :-> l) \In p :--> l.

Proof. by move=>H; apply/swp. Qed.



Hint Immediate blah : core.



Lemma blah2 (A : Type) (v1 v2 : A) q :

        def (q :-> v1) -> v1 = v2 -> q :-> v1 \In q :--> v2.

Proof. by move=>D E; apply/swp; rewrite E. Qed.



Hint Immediate blah2 : core.



Ltac hauto := (do ?econstructor=>//;

                try by [defcheck; auto |

                       eapply blah2; defcheck; auto])=>//.



Ltac hhauto := (do ?econstructor=>//; try by [heap_congr])=>//.

Ltac hdone := repeat progress hhauto=>//=.

Ltac heval := do ![hstep | by hhauto].

