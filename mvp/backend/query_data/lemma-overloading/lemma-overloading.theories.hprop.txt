
From mathcomp
Require Import ssreflect ssrfun.
From LemmaOverloading
Require Import rels heaps.
(* rels:
From mathcomp
Require Import ssreflect ssrfun ssrbool seq.
Require Import Setoid.
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Lemma andTp p : True /\ p <-> p.      Proof. by intuition. Qed.
Lemma andFp p : False /\ p <-> False. Proof. by intuition. Qed.
Lemma orTp p : True \/ p <-> True.    Proof. by intuition. Qed.
Lemma orFp p : False \/ p <-> p.      Proof. by intuition. Qed.

Delimit Scope rel_scope with rel.
Open Scope rel_scope.

Definition Pred T := T -> Prop.
Identity Coercion fun_of_Pred : Pred >-> Funclass.

Notation xPred0 := (fun _ => False).
Notation xPred1 := (fun x y => x = y).
Notation xPredT := (fun _ => True).
Notation xPredI := (fun (p1 p2 : Pred _) x => p1 x /\ p2 x).
Notation xPredU := (fun (p1 p2 : Pred _) x => p1 x \/ p2 x).
Notation xPredC := (fun (p : Pred _) x => ~ p x).
Notation xPredD := (fun (p1 p2 : Pred _) x => ~ p2 x /\ p1 x).
Notation xPreim := (fun f (p : Pred _) x => p (f x)).

Section Predicates.
Variable T : Type.

Definition Simpl_Pred := simpl_fun T Prop.
Definition SimplPred (p : Pred T) : Simpl_Pred := SimplFun p.
Coercion Pred_of_Simpl (p : Simpl_Pred) : Pred T := p : T -> Prop.

Definition Pred0 := SimplPred xPred0.
Definition Pred1 x := SimplPred (xPred1 x).
Definition PredT := SimplPred xPredT.
Definition PredI p1 p2 := SimplPred (xPredI p1 p2).
Definition PredU p1 p2 := SimplPred (xPredU p1 p2).
Definition PredC p := SimplPred (xPredC p).
Definition PredD p1 p2 := SimplPred (xPredD p1 p2).
Definition Preim rT f (d : Pred rT) := SimplPred (xPreim f d).

CoInductive Mem_Pred : Type := MemProp of Pred T.
Definition isMem pT toPred mem := mem = (fun p : pT => MemProp [eta toPred p]).

Structure PredType : Type := PropPredType {
  Pred_Sort :> Type;
  toPred : Pred_Sort -> Pred T;
  _ : {mem | isMem toPred mem}}.

Definition mkPredType pT toP := PropPredType (exist (@isMem pT toP) _ (erefl _)).

Canonical Structure PredPredType := Eval hnf in @mkPredType (Pred T) id.
Canonical Structure SimplPredPredType := Eval hnf in mkPredType Pred_of_Simpl.
Coercion Pred_of_Mem mp : Pred_Sort PredPredType :=
  let: MemProp p := mp in [eta p].
Canonical Structure MemPredType := Eval hnf in mkPredType Pred_of_Mem.
Canonical Structure predPredType := Eval hnf in @mkPredType (pred T) id.
Canonical Structure simplpredPredType :=
  Eval hnf in @mkPredType (simpl_pred T) (fun p x => p x).

End Predicates.

Arguments Pred0 {T}.
Arguments PredT {T}.
Prenex Implicits PredI PredU PredC PredD Preim.

Notation "r1 +p r2" := (PredU r1 r2)
  (at level 55, right associativity) : rel_scope.
Notation "r1 *p r2" := (PredI r1 r2)
  (at level 45, right associativity) : rel_scope.

Notation "[ 'Pred' : T | E ]" := (SimplPred (fun _ : T => E))
  (at level 0, format "[ 'Pred' :  T  |  E ]") : fun_scope.
Notation "[ 'Pred' x | E ]" := (SimplPred (fun x => E))
  (at level 0, x ident, format "[ 'Pred'  x  |  E ]") : fun_scope.
Notation "[ 'Pred' x : T | E ]" := (SimplPred (fun x : T => E))
  (at level 0, x ident, only parsing) : fun_scope.
Notation "[ 'Pred' x y | E ]" := (SimplPred (fun t => let: (x, y) := t in E))
  (at level 0, x ident, y ident, format "[ 'Pred'  x  y  |  E ]") : fun_scope.
Notation "[ 'Pred' x y : T | E ]" :=
  (SimplPred (fun t : (T*T) => let: (x, y) := t in E))
  (at level 0, x ident, y ident, only parsing) : fun_scope.

Definition repack_Pred T pT :=
  let: PropPredType _ a mP := pT return {type of @PropPredType T for pT} -> _ in
   fun k => k a mP.

Notation "[ 'PredType' 'of' T ]" := (repack_Pred (fun a => @PropPredType _ T a))
  (at level 0, format "[ 'PredType'  'of'  T ]") : form_scope.

Notation Pred_Class := (Pred_Sort (PredPredType _)).
Coercion Sort_of_Simpl_Pred T (p : Simpl_Pred T) : Pred_Class := p : Pred T.

Definition PredArgType := Type.
Coercion Pred_of_argType (T : PredArgType) : Simpl_Pred T := PredT.

Notation "{ :: T }" := (T%type : PredArgType)
  (at level 0, format "{ ::  T }") : type_scope.

Definition Mem T (pT : PredType T) : pT -> Mem_Pred T :=
  nosimpl (let: PropPredType _ _ (exist mem _) := pT return pT -> _ in mem).
Definition InMem T x mp := nosimpl Pred_of_Mem T mp x.

Prenex Implicits Mem.

Coercion Pred_of_Mem_Pred T mp := [Pred x : T | InMem x mp].

Definition EqPredType T (pT : PredType T) (p1 p2 : pT) :=
  forall x : T, toPred p1 x <-> toPred p2 x.

Definition SubPredType T (pT : PredType T) (p1 p2 : pT) :=
  forall x : T, toPred p1 x -> toPred p2 x.

Definition EqPred T (p1 p2 : Pred T) := EqPredType p1 p2.
Definition SubPred T (p1 p2 : Pred T) := SubPredType p1 p2.
Definition EqSimplPred T (p1 p2 : Simpl_Pred T) := EqPredType p1 p2.
Definition SubSimplPred T (p1 p2 : Simpl_Pred T) := SubPredType p1 p2.

Definition EqPredFun T1 T2 p1 p2 :=
  forall x : T1, @EqPred T2 (p1 x) (p2 x).
Definition SubPredFun T1 T2 p1 p2 :=
  forall x : T1, @SubPred T2 (p1 x) (p2 x).

Definition EqMem T p1 p2 := forall x : T, InMem x p1 <-> InMem x p2.
Definition SubMem T p1 p2 := forall x : T, InMem x p1 -> InMem x p2.

Notation "A <~> B" := (EqPred A B)
  (at level 70, no associativity) : rel_scope.
Notation "A ~> B" := (SubPred A B)
  (at level 70, no associativity) : rel_scope.
Notation "A <~1> B" := (EqPredFun A B)
  (at level 70, no associativity) : rel_scope.
Notation "A ~1> B" := (SubPredFun A B)
  (at level 70, no associativity) : rel_scope.

Notation "x \In A" := (InMem x (Mem A))
  (at level 70, no associativity) : rel_scope.
Notation "x \Notin A" := (~ (x \In A))
  (at level 70, no associativity) : rel_scope.
Notation "A =p B" := (EqMem (Mem A) (Mem B))
  (at level 70, no associativity) : type_scope.
Notation "A <=p B" := (SubMem (Mem A) (Mem B))
  (at level 70, no associativity) : type_scope.

Notation "[ 'Mem' A ]" := (Pred_of_Simpl (Pred_of_Mem_Pred (Mem A)))
  (at level 0, only parsing) : fun_scope.
Notation "[ 'PredI' A & B ]" := (PredI [Mem A] [Mem B])
  (at level 0, format "[ 'PredI'  A  &  B ]") : fun_scope.
Notation "[ 'PredU' A & B ]" := (PredU [Mem A] [Mem B])
  (at level 0, format "[ 'PredU'  A  &  B ]") : fun_scope.
Notation "[ 'PredD' A & B ]" := (PredD [Mem A] [Mem B])
  (at level 0, format "[ 'PredD'  A  &  B ]") : fun_scope.
Notation "[ 'PredC' A ]" := (PredC [Mem A])
  (at level 0, format "[ 'PredC'  A ]") : fun_scope.
Notation "[ 'Preim' f 'of' A ]" := (Preim f [Mem A])
  (at level 0, format "[ 'Preim'  f  'of'  A ]") : fun_scope.

Notation "[ 'Pred' x \In A ]" := [Pred x | x \In A]
  (at level 0, x ident, format "[ 'Pred'  x  \In  A ]") : fun_scope.
Notation "[ 'Pred' x \In A | E ]" := [Pred x | (x \In A) /\ E]
  (at level 0, x ident, format "[ 'Pred'  x  \In  A  |  E ]") : fun_scope.
Notation "[ 'Pred' x y \In A & B | E ]" :=
  [Pred x y | (x \In A) /\ (y \In B) /\ E]
  (at level 0, x ident, y ident,
   format "[ 'Pred'  x  y  \In  A  &  B  |  E ]") : fun_scope.
Notation "[ 'Pred' x y \In A & B ]" := [Pred x y | (x \In A) /\ (y \In B)]
  (at level 0, x ident, y ident,
   format "[ 'Pred'  x  y  \In  A  &  B ]") : fun_scope.
Notation "[ 'Pred' x y \In A | E ]" := [Pred x y \In A & A | E]
  (at level 0, x ident, y ident,
   format "[ 'Pred'  x  y  \In  A  |  E ]") : fun_scope.
Notation "[ 'Pred' x y \In A ]" := [Pred x y \In A & A]
  (at level 0, x ident, y ident,
   format "[ 'Pred'  x  y  \In  A ]") : fun_scope.

Section Simplifications.
Variables (T : Type) (pT : PredType T).

Lemma Mem_toPred : forall (p : pT), Mem (toPred p) = Mem p.

Lemma toPredE : forall x (p : pT), toPred p x = (x \In p).

Lemma In_Simpl : forall x (p : Simpl_Pred T), (x \In p) = p x.

Lemma Simpl_PredE : forall (p : Pred T), [Pred x | p x] <~> p.

Lemma Mem_Simpl : forall (p : Simpl_Pred T), Mem p = p :> Pred T.

Definition MemE := Mem_Simpl. 

Lemma Mem_Mem : forall p : pT, (Mem (Mem p) = Mem p) * (Mem [Mem p] = Mem p).

End Simplifications.

Section RelProperties.
Variables (T : Type) (pT : PredType T).

Lemma EqPredType_refl (r : pT) : EqPredType r r. Proof. by []. Qed.

Lemma EqPredType_sym (r1 r2 : pT) : EqPredType r1 r2 -> EqPredType r2 r1.

Lemma EqPredType_trans' (r1 r2 r3 : pT) :
  EqPredType r1 r2 -> EqPredType r2 r3 -> EqPredType r1 r3.

Lemma SubPredType_trans' (r1 r2 r3 : pT) :
  SubPredType r1 r2 -> SubPredType r2 r3 -> SubPredType r1 r3.

Definition EqPredType_trans r2 r1 r3 := @EqPredType_trans' r1 r2 r3.
Definition SubPredType_trans r2 r1 r3 := @SubPredType_trans' r1 r2 r3.

Section RelLaws.
Variable (T : Type).

Lemma orrI (r : Pred T) : r +p r <~> r.

Lemma orrC (r1 r2 : Pred T) : r1 +p r2 <~> r2 +p r1.

Lemma orr0 (r : Pred T) : r +p Pred0 <~> r.

Lemma or0r (r : Pred T) : Pred0 +p r <~> r.

Lemma orrCA (r1 r2 r3 : Pred T) : r1 +p r2 +p r3 <~> r2 +p r1 +p r3.

Lemma orrAC (r1 r2 r3 : Pred T) : (r1 +p r2) +p r3 <~> (r1 +p r3) +p r2.

Lemma orrA (r1 r2 r3 : Pred T) : (r1 +p r2) +p r3 <~> r1 +p r2 +p r3.

Lemma orrAb (r1 a : Pred T) : r1 <~> r1 +p a <-> a ~> r1.

Lemma sub_orl (r1 r2 : Pred T) : r1 ~> r1 +p r2. Proof. by left. Qed.

End RelLaws.

Section SubMemLaws.
Variable T : Type.

Lemma subp_refl (p : Pred T) : p <=p p.

Lemma subp_asym (p1 p2 : Pred T) : p1 <=p p2 -> p2 <=p p1 -> p1 =p p2.

Lemma subp_trans (p2 p1 p3 : Pred T) : p1 <=p p2 -> p2 <=p p3 -> p1 <=p p3.

Lemma subp_or (p1 p2 q : Pred T) : p1 <=p q /\ p2 <=p q <-> p1 +p p2 <=p q.

Lemma subp_and (p1 p2 q : Pred T) : q <=p p1 /\ q <=p p2 <-> q <=p p1 *p p2.

Lemma subp_orl (p1 p2 q : Pred T) : p1 <=p p2 -> p1 +p q <=p p2 +p q.

Lemma subp_orr (p1 p2 q : Pred T) : p1 <=p p2 -> q +p p1 <=p q +p p2.

Lemma subp_andl (p1 p2 q : Pred T) : p1 <=p p2 -> p1 *p q <=p p2 *p q.

Lemma subp_andr (p1 p2 q : Pred T) : p1 <=p p2 -> q *p p1 <=p q *p p2.

End SubMemLaws.

Hint Resolve subp_refl : core.

Section ListMembership.
Variable T : Type.

Fixpoint Mem_Seq (s : seq T) :=
  if s is y::s' then (fun x => x = y \/ Mem_Seq s' x) else xPred0.

Definition EqSeq_Class := seq T.
Identity Coercion seq_of_EqSeq : EqSeq_Class >-> seq.

Coercion Pred_of_Eq_Seq (s : EqSeq_Class) : Pred_Class := [eta Mem_Seq s].

Canonical Structure seq_PredType := @mkPredType T (seq T) Pred_of_Eq_Seq.

Canonical Structure Mem_Seq_PredType := mkPredType Mem_Seq.

Lemma In_cons : forall y s x, (x \In y :: s) <-> (x = y) \/ (x \In s).

Lemma In_nil : forall x, (x \In [::]) <-> False.

Lemma Mem_Seq1 : forall x y, (x \In [:: y]) <-> (x = y).

Definition InE := (Mem_Seq1, In_cons, In_Simpl).
Lemma eqfun_sym A B (f1 f2 : A -> B) : f1 =1 f2 -> f2 =1 f1.
Lemma eqfun_trans A B (f1 f2 f3 : A -> B) : f1 =1 f2 -> f2 =1 f3 -> f1 =1 f3.

Add Parametric Relation A B : (A -> B) (@eqfun _ _)
  reflexivity proved by (@eqfun_refl A B)
  symmetry proved by (@eqfun_sym A B)
  transitivity proved by (@eqfun_trans A B) as eqfun_morph. *)
(* heaps:
From mathcomp
Require Import ssreflect ssrfun ssrnat div ssrbool seq.
From LemmaOverloading
Require Import prelude finmap ordtype.
From mathcomp
Require Import path eqtype.
Require Import Eqdep.
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Notation eqn_addl := eqn_add2l.
Notation modn_addl := modnDl.
Notation modn_mulr := modnMr.
Notation modn_add2m := modnDm.
Notation modn_addr := modnDr.

Inductive ptr := ptr_nat of nat.

Definition null := ptr_nat 0.

Definition nat_ptr (x : ptr) := let: ptr_nat y := x in y.

Definition eq_ptr (x y : ptr) :=
  match x, y with ptr_nat m, ptr_nat n => m == n end.

Lemma eq_ptrP : Equality.axiom eq_ptr.

Definition ptr_eqMixin := EqMixin eq_ptrP.
Canonical Structure ptr_eqType := EqType ptr ptr_eqMixin.

Definition ptr_offset x i := ptr_nat (nat_ptr x + i).

Notation "x .+ i" := (ptr_offset x i)
  (at level 3, format "x .+ i").

Lemma ptrE x y : (x == y) = (nat_ptr x == nat_ptr y).

Lemma ptr0 x : x.+0 = x.

Lemma ptrA x i j : x.+i.+j = x.+(i+j).

Lemma ptrK x i j : (x.+i == x.+j) = (i == j).

Lemma ptr_null x m : (x.+m == null) = (x == null) && (m == 0).

Lemma ptrT x y : {m : nat | (x == y.+m) || (y == x.+m)}.

Definition ltn_ptr (x y : ptr) :=
  match x, y with ptr_nat m, ptr_nat n => m < n end.

Lemma ltn_ptr_irr : irreflexive ltn_ptr.

Lemma ltn_ptr_trans : transitive ltn_ptr.

Lemma ltn_ptr_total : forall x y : ptr, [|| ltn_ptr x y, x == y | ltn_ptr y x].

Definition ptr_ordMixin := OrdMixin ltn_ptr_irr ltn_ptr_trans ltn_ptr_total.
Canonical Structure ptr_ordType := OrdType ptr ptr_ordMixin.

Inductive heap :=
  Undef | Def (finmap : {finMap ptr -> dynamic}) of
               null \notin supp finmap.

Section NullLemmas.
Variables (f g : {finMap ptr -> dynamic}) (x : ptr) (d : dynamic).

Lemma upd_nullP :
        x != null -> null \notin supp f -> null \notin supp (ins x d f).

Lemma free_nullP : null \notin supp f -> null \notin supp (rem x f).

Lemma un_nullP :
        null \notin supp f -> null \notin supp g ->
          null \notin supp (fcat f g).

Lemma heapE pf pg : f = g <-> @Def f pf = @Def g pg.

End NullLemmas.

Definition def h := if h is Def _ _ then true else false.

Definition empty := @Def (finmap.nil _ _) is_true_true.

Definition upd h x d := nosimpl
  (if h is Def hs ns then
    if decP (@idP (x != null)) is left pf then
      Def (@upd_nullP _ _ d pf ns)
    else Undef
  else Undef).

Definition dom h : pred ptr := nosimpl
  (if h is Def f _ then mem (supp f) else pred0).

Definition free x h : heap :=
  (if h is Def hs ns then Def (free_nullP x ns) else Undef).

Definition look (x : ptr) h :=
  (if h is Def hs _ then
    if fnd x hs is Some d then d else dyn tt
  else dyn tt).

Definition union2 h1 h2 := nosimpl
  (if (h1, h2) is (Def hs1 ns1, Def hs2 ns2) then
     if disj hs1 hs2 then
        Def (@un_nullP _ _ ns1 ns2)
     else Undef
  else Undef).

Definition empb h :=
  if h is Def hs _ then supp hs == [::] else false.

Definition fresh h :=
  (if h is Def hs _ then last null (supp hs) else null) .+ 1.

Definition subdom h1 h2 :=
  if (h1, h2) is (Def hs1 _, Def hs2 _) then
    all (fun x => x \in supp hs2) (supp hs1)
  else false.

Definition subheap h1 h2 :=
  subdom h1 h2 /\ forall x, x \in dom h1 -> look x h1 = look x h2.

Definition subtract h1 h2 :=
  if h1 is (Def hs1 _) then
    foldl (fun h x => free x h) h2 (supp hs1)
  else Undef.

Definition pick h :=
  if h is Def hs _ then head null (supp hs) else null.

Definition pts A (x : ptr) (v : A) := upd empty x (dyn v).

Notation "h1 :+ h2" := (union2 h1 h2) (at level 43, left associativity).
Notation "h2 :- h1" := (subtract h1 h2) (at level 43, left associativity).
Notation "x :-> v" := (pts x v) (at level 30).

Lemma unC : forall h1 h2, h1 :+ h2 = h2 :+ h1.

Lemma unA : forall h1 h2 h3, h1 :+ (h2 :+ h3) = h1 :+ h2 :+ h3.

Lemma unCA h1 h2 h3 : h1 :+ (h2 :+ h3) = h2 :+ (h1 :+ h3).

Lemma unAC h1 h2 h3 : h1 :+ h2 :+ h3 = h1 :+ h3 :+ h2.

Lemma un0h h : empty :+ h = h.

Lemma unh0 h : h :+ empty = h.

Lemma unKhl h h1 h2 : def (h1 :+ h) -> h1 :+ h = h2 :+ h -> h1 = h2.

Lemma unhKl h h1 h2 : def (h :+ h1) -> h :+ h1 = h :+ h2 -> h1 = h2.

Lemma unKhr h h1 h2 : def (h2 :+ h) -> h1 :+ h = h2 :+ h -> h1 = h2.

Lemma unhKr h h1 h2 : def (h :+ h2) -> h :+ h1 = h :+ h2 -> h1 = h2.

Lemma dom0 : dom empty = pred0.

Lemma domU h y d :
        dom (upd h y d) =i
        [pred x | (y != null) && if x == y then def h else x \in dom h].

Lemma domPt A x (v : A) : dom (x :-> v) =i [pred y | (x == y) && (x != null)].

Lemma domF h x :
        dom (free x h) =i [pred y | if x == y then false else y \in dom h].

Lemma domUn h1 h2 :
        dom (h1 :+ h2) =i
        [pred x | def (h1 :+ h2) && (x \in [predU dom h1 & dom h2])].

Lemma dom_null h x : x \in dom h -> x != null.

Lemma dom_def h x : x \in dom h -> def h.

Lemma dom_free h x : x \notin dom h -> free x h = h.

Lemma dom_look h x : x \notin dom h -> look x h = dyn tt.

Lemma def0 : def empty.

Hint Resolve def0 : core.

Lemma defU h x d : def (upd h x d) = (x != null) && (def h).

Lemma defPt A x (v : A) : def (x :-> v) = (x != null).

Lemma defF h x : def (free x h) = def h.

CoInductive defUn_spec h1 h2 : bool -> Type :=
| def_false1 of ~~ def h1 : defUn_spec h1 h2 false
| def_false2 of ~~ def h2 : defUn_spec h1 h2 false
| def_false3 x of x \in dom h1 & x \in dom h2 : defUn_spec h1 h2 false
| def_true of def h1 & def h2 &
    (forall x, x \in dom h1 -> x \notin dom h2) : defUn_spec h1 h2 true.

Lemma defUn : forall h1 h2, defUn_spec h1 h2 (def (h1 :+ h2)).

Lemma defUnl h1 h2 : def (h1 :+ h2) -> def h1.

Lemma defUnr h1 h2 : def (h1 :+ h2) -> def h2.

Lemma defFUn h1 h2 x : def (h1 :+ h2) -> def (free x h1 :+ h2).

Lemma defUnF h1 h2 x : def (h1 :+ h2) -> def (h1 :+ free x h2).

Lemma undefE x : ~~ def x <-> x = Undef.

Lemma upd_inj h x d1 d2 :
        def h -> x != null -> upd h x d1 = upd h x d2 -> d1 = d2.

Lemma heap_eta h x : x \in dom h -> h = upd (free x h) x (look x h).

Lemma updU h x y d1 d2 :
        upd (upd h x d1) y d2 =
        if x == y then upd h x d2 else upd (upd h y d2) x d1.

Lemma updF h x y d :
        upd (free x h) y d =
        if x == y then upd h x d else free x (upd h y d).

Lemma updUnl h1 h2 x d :
        upd (h1 :+ h2) x d =
        if x \in dom h1 then upd h1 x d :+ h2 else h1 :+ upd h2 x d.

Lemma updUnr h1 h2 x d :
        upd (h1 :+ h2) x d =
        if x \in dom h2 then h1 :+ upd h2 x d else upd h1 x d :+ h2.

Lemma pts_injP A1 A2 x1 x2 (v1 : A1) (v2 : A2) :
        def (x1 :-> v1) -> x1 :-> v1 = x2 :-> v2 -> x1 = x2 /\ A1 = A2.

Lemma pts_injT A1 A2 x (v1 : A1) (v2 : A2) :
        def (x :-> v1) -> x :-> v1 = x :-> v2 -> A1 = A2.

Lemma pts_inj A x (v1 v2 : A) :
        def (x :-> v1) -> x :-> v1 = x :-> v2 -> v1 = v2.

Lemma free0 x : free x empty = empty.

Lemma freeU h x y d :
        free x (upd h y d) = if x == y then
          if y == null then Undef else free x h
        else upd (free x h) y d.

Lemma freeF h x y :
        free x (free y h) = if x == y then free x h else free y (free x h).

Lemma freeUn h1 h2 x :
        free x (h1 :+ h2) =
        if x \in dom (h1 :+ h2) then free x h1 :+ free x h2
        else h1 :+ h2.

Lemma freeUnD h1 h2 x :
        def (h1 :+ h2) -> free x (h1 :+ h2) = free x h1 :+ free x h2.

Lemma freeUnl h1 h2 x : x \notin dom h1 -> free x (h1 :+ h2) = h1 :+ free x h2.

Lemma freeUnr h1 h2 x : x \notin dom h2 -> free x (h1 :+ h2) = free x h1 :+ h2.

Lemma lookU h x y d :
        look x (upd h y d) = if x == y then
          if def h && (y != null) then d else dyn tt
        else if y != null then look x h else dyn tt.

Lemma lookF h x y :
        look x (free y h) = if x == y then dyn tt else look x h.

Lemma lookUnl h1 h2 x :
        def (h1 :+ h2) ->
        look x (h1 :+ h2) = if x \in dom h1 then look x h1 else look x h2.

Lemma lookUnr h1 h2 x :
        def (h1 :+ h2) ->
        look x (h1 :+ h2) = if x \in dom h2 then look x h2 else look x h1.

Lemma empP h : reflect (h = empty) (empb h).

Lemma empU h x d : empb (upd h x d) = false.

Lemma empPt A x (v : A) : empb (x :-> v) = false.

Lemma empUn h1 h2 : empb (h1 :+ h2) = empb h1 && empb h2.

Lemma empbE h : h = empty <-> empb h.

Lemma un0E h1 h2 : h1 :+ h2 = empty <-> h1 = empty /\ h2 = empty.

Lemma defE h : reflect (def h /\ forall x, x \notin dom h)(empb h).

Lemma defUnhh h : def (h :+ h) = empb h.

Lemma path_last n s x : path ord x s -> ord x (last x s).+(n+1).

Lemma path_filter (A : ordType) (s : seq A) (p : pred A) x :
        path ord x s -> path ord x (filter p s).

Lemma dom_fresh h n : (fresh h).+n \notin dom h.

Lemma fresh_null h : fresh h != null.

Opaque fresh.

Hint Resolve dom_fresh fresh_null : core.

Lemma emp_pick h : (pick h == null) = (~~ def h || empb h).

Lemma pickP h : def h && ~~ empb h = (pick h \in dom h).

Lemma subdom_def h1 h2 : subdom h1 h2 -> def h1 && def h2.

Lemma subdomP h1 h2 :
        def h1 -> ~~ empb h1 ->
        reflect (forall x, x \in dom h1 -> x \in dom h2)
                (subdom h1 h2).

Lemma subdomQ x h1 h2 : subdom h1 h2 -> x \in dom h1 -> x \in dom h2.

Lemma subdom_refl h : def h -> subdom h h.

Lemma subdomD h1 h2 h : subdom h1 h2 -> def (h2 :+ h) -> def (h1 :+ h).

Lemma subdomE h1 h2 h :
        def (h2 :+ h) -> subdom h1 h2 -> subdom (h1 :+ h) (h2 :+ h).

Lemma subdomUE h1 h2 h1' h2' :
        def (h2 :+ h2') -> subdom h1 h2 -> subdom h1' h2' ->
          subdom (h1 :+ h1') (h2 :+ h2').

Lemma subdom_emp h : def h -> subdom empty h.

Lemma subdom_emp_inv h : subdom h empty -> h = empty.

Lemma subdomPE A B x (v1 : A) (v2 : B) :
        x != null -> subdom (x :-> v1) (x :-> v2).

Lemma subdom_trans h2 h1 h3 : subdom h1 h2 -> subdom h2 h3 -> subdom h1 h3.

Hint Resolve subdom_emp subdomPE : core.

Lemma subheap_refl h : def h -> subheap h h.

Lemma subheapE h : def h -> subheap empty h.

Lemma subheapUn h1 h2 h1' h2' :
        def (h2 :+ h2') -> subheap h1 h2 -> subheap h1' h2' ->
        subheap (h1 :+ h1') (h2 :+ h2').

Lemma subheapUnl h1 h2 : def (h1 :+ h2) -> subheap h1 (h1 :+ h2).

Lemma subheapUnr h1 h2 : def (h1 :+ h2) -> subheap h2 (h1 :+ h2).

Lemma subheap_def h1 h2 : subheap h1 h2 -> def h1 /\ def h2.

Lemma subheap_trans h2 h1 h3 : subheap h1 h2 -> subheap h2 h3 -> subheap h1 h3.

Lemma subheap_id hp1 hp2: subheap hp1 hp2 -> subheap hp2 hp1 -> hp1 = hp2.

Lemma noalias h1 h2 x1 x2 :
        x1 \in dom h1 -> x2 \in dom h2 -> def (h1 :+ h2) -> x1 != x2.

Lemma defPtUn A h x (v : A) :
        def (x :-> v :+ h) = [&& x != null, def h & x \notin dom h].

Lemma defPt_null A h x (v : A) : def (x :-> v :+ h) -> x != null.

Lemma defPt_def A h x (v : A) : def (x :-> v :+ h) -> def h.

Lemma defPt_dom A h x (v : A) : def (x :-> v :+ h) -> x \notin dom h.

Lemma domPtUn A h x (v : A) :
        dom (x :-> v :+ h) =i
        [pred y | def (x :-> v :+ h) && ((x == y) || (y \in dom h))].

Lemma lookPtUn A h x (v : A) :
        def (x :-> v :+ h) -> look x (x :-> v :+ h) = dyn v.

Lemma freePtUn A h x (v : A) :
        def (x :-> v :+ h) -> free x (x :-> v :+ h) = h.

Lemma updPtUn A1 A2 x i (v1 : A1) (v2 : A2) :
        upd (x :-> v1 :+ i) x (dyn v2) = x :-> v2 :+ i.

Lemma heap_etaP h x : x \in dom h -> h = x :-> Dyn.val (look x h) :+ free x h.

Lemma cancelT A1 A2 h1 h2 x (v1 : A1) (v2 : A2) :
        def (x :-> v1 :+ h1) ->
          x :-> v1 :+ h1 = x :-> v2 :+ h2 -> A1 = A2.

Lemma cancel A h1 h2 x (v1 v2 : A) :
        def (x :-> v1 :+ h1) ->
        x :-> v1 :+ h1 = x :-> v2 :+ h2 -> [/\ v1 = v2, def h1 & h1 = h2].

Lemma domPtUnX A (v : A) x i : def (x :-> v :+ i) -> x \in dom (x :-> v :+ i).

Lemma domPtX A (v : A) x : def (x :-> v) -> x \in dom (x :-> v).

Lemma dom_notin_notin h1 h2 x :
        def (h1 :+ h2) -> x \notin dom (h1 :+ h2) -> x \notin dom h1.

Lemma dom_in_notin h1 h2 x : def (h1 :+ h2) -> x \in dom h1 -> x \notin dom h2.

Section BlockUpdate.
Variable (A : Type).

Fixpoint updi x (vs : seq A) {struct vs} : heap :=
  if vs is v'::vs' then (x :-> v') :+ updi (x .+ 1) vs' else empty.

Lemma updiS x v vs : updi x (v :: vs) = x :-> v :+ updi (x .+ 1) vs.

Lemma updi_last x v vs :
        updi x (rcons vs v) = updi x vs :+ x.+(size vs) :-> v.

Lemma updi_cat x vs1 vs2 :
        updi x (vs1 ++ vs2) = updi x vs1 :+ updi x.+(size vs1) vs2.

Lemma updi_catI x y vs1 vs2 :
        y = x.+(size vs1) -> updi x vs1 :+ updi y vs2 = updi x (vs1 ++ vs2).

Lemma updiVm' x m xs : m > 0 -> x \notin dom (updi x.+m xs).

Lemma updiD x xs : def (updi x xs) = (x != null) || (size xs == 0).

Lemma updiVm x m xs :
        x \in dom (updi x.+m xs) = [&& x != null, m == 0 & size xs > 0].

Lemma updimV x m xs :
        x.+m \in dom (updi x xs) = (x != null) && (m < size xs).

Lemma updiP x y xs :
        reflect (y != null /\ exists m, x = y.+m /\ m < size xs)

Lemma updi_inv x xs1 xs2 :
        def (updi x xs1) -> updi x xs1 = updi x xs2 -> xs1 = xs2.

Lemma updi_iinv x xs1 xs2 h1 h2 :
        size xs1 = size xs2 -> def (updi x xs1 :+ h1) ->
        updi x xs1 :+ h1 = updi x xs2 :+ h2 -> xs1 = xs2 /\ h1 = h2.

End BlockUpdate.

Definition low : pred ptr := fun x => 0 == nat_ptr x %[mod 2].
Definition high : pred ptr := fun x => 1 == nat_ptr x %[mod 2].

Definition get_lows h :=
  if h is Def hs _ then filter low (supp hs) else [::].

Definition get_highs h :=
  if h is Def hs _ then filter high (supp hs) else [::].

Definition ldom h : pred ptr := fun x => x \in get_lows h.
Definition hdom h : pred ptr := fun x => x \in get_highs h.

Lemma ldomP h x : x \in ldom h = (x \in dom h) && low x.

Lemma hdomP h x : x \in hdom h = (x \in dom h) && high x.

Lemma ldomK h1 h2 t1 t2 :
        def (h1 :+ t1) -> def (h2 :+ t2) ->
        ldom h1 =i ldom h2 ->
        ldom (h1 :+ t1) =i ldom (h2 :+ t2) -> ldom t1 =i ldom t2.

Definition lfresh h := (last null (get_lows h)) .+ 2.
Definition hfresh h := (last (null .+ 1) (get_highs h)) .+ 2.

Lemma last_inv A B (f : A -> B) (x1 x2 : A) (h : seq A) :
        f x1 = f x2 -> f (last x1 h) = f (last x2 h).

Lemma lfresh_low h n : low (lfresh h) .+ (2*n).

Lemma hfresh_high h n : high (hfresh h) .+ (2*n).

Lemma dom_lfresh h n : (lfresh h) .+ (2*n) \notin dom h.

Lemma dom_hfresh h n : (hfresh h) .+ (2*n) \notin dom h.

Lemma lfresh_null h : lfresh h != null.

Lemma hfresh_null h : hfresh h != null.

Lemma high_lowD : [predI low & high] =i pred0.

Lemma modnS x1 x2 : (x1 == x2 %[mod 2]) = (x1.+1 == x2.+1 %[mod 2]).

Lemma hlE x : high x = ~~ low x.

Lemma lhE x : low x = ~~ high x.

Lemma ldomUn h1 h2 :
        ldom (h1 :+ h2) =i
        [pred x | def (h1 :+ h2) && (x \in [predU ldom h1 & ldom h2])].

Definition loweq h1 h2 := get_lows h1 == get_lows h2.

Notation "h1 =~ h2" := (loweq h1 h2) (at level 80).

Lemma low_refl h : h =~ h.

Hint Resolve low_refl : core.

Lemma low_sym h1 h2 : (h1 =~ h2) = (h2 =~ h1).

Lemma low_trans h2 h1 h3 : h1 =~ h2 -> h2 =~ h3 -> h1 =~ h3.

Lemma loweqP h1 h2 : reflect (ldom h1 =i ldom h2) (h1 =~ h2).

Lemma loweqK h1 h2 t1 t2 :
        def (h1 :+ t1) -> def (h2 :+ t2) ->
        h1 =~ h2 -> h1 :+ t1 =~ h2 :+ t2 -> t1 =~ t2.

Lemma loweqE h1 h2 : h1 =~ h2 -> lfresh h1 = lfresh h2.

Lemma lowUn h1 h2 t1 t2 :
        def (h1 :+ t1) ->
        def (h2 :+ t2) ->
        h1 =~ h2 -> t1 =~ t2 -> h1 :+ t1 =~ h2 :+ t2.

Lemma lowPn A1 A2 (x : ptr) (v1 : A1) (v2 : A2) : x :-> v1 =~ x :-> v2.

Hint Resolve lowPn : core.

Lemma highPn A1 A2 (x1 x2 : ptr) (v1 : A1) (v2 : A2) :
        high x1 -> high x2 -> x1 :-> v1 =~ x2 :-> v2.

Lemma lowPtUn A1 A2 h1 h2 (x : ptr) (v1 : A1) (v2 : A2) :
        def (x :-> v1 :+ h1) ->
        def (x :-> v2 :+ h2) ->
        (x :-> v1 :+ h1 =~ x :-> v2 :+ h2) = (h1 =~ h2).

Lemma highPtUn A h1 h2 (x : ptr) (v : A) :
        def (x :-> v :+ h1) -> high x ->
        (x :-> v :+ h1 =~ h2) = (h1 =~ h2).

Lemma highPtUn2 A1 A2 h1 h2 (x1 x2 : ptr) (v1 : A1) (v2 : A2) :
        def (x1 :-> v1 :+ h1) ->
        def (x2 :-> v2 :+ h2) ->
        high x1 -> high x2 ->
        h1 =~ h2 -> x1 :-> v1 :+ h1 =~ x2 :-> v2 :+ h2.

Definition plus2 (h1 h2 : heap * heap) : heap * heap :=
  (h1.1 :+ h2.1, h1.2 :+ h2.2).

Definition def2 (h : heap * heap) := def h.1 && def h.2.

Notation "h1 :++ h2" := (plus2 h1 h2) (at level 50).

Lemma unA2 h1 h2 h3 : h1 :++ (h2 :++ h3) = h1 :++ h2 :++ h3.

Lemma unC2 h1 h2 : h1 :++ h2 = h2 :++ h1.

Lemma unKhl2 h h1 h2 : def2 (h1 :++ h) -> h1 :++ h = h2 :++ h -> h1 = h2.

Lemma unKhr2 h h1 h2 : def2 (h2 :++ h) -> h1 :++ h = h2 :++ h -> h1 = h2.

Lemma unDl2 h1 h2 : def2 (h1 :++ h2) -> def2 h1.

Lemma unDr2 h1 h2 : def2 (h1 :++ h2) -> def2 h2.

Lemma un0h2 h : (empty, empty) :++ h = h.

Lemma unh02 h : h :++ (empty, empty) = h.

Lemma injUh A h1 h2 x (v1 v2 : A) :
        def (h1 :+ (x :-> v1)) ->
        h1 :+ (x :-> v1) = h2 :+ (x :-> v2) ->
          def h1 /\ h1 = h2 /\ v1 = v2.

Lemma eqUh h1 h2 h : def (h1 :+ h) -> h1 :+ h = h2 :+ h -> def h1 /\ h1 = h2.

Lemma exit1 h1 h2 h : def (h1 :+ h) -> h1 :+ h = h :+ h2 -> def h1 /\ h1 = h2.

Lemma exit2 h1 h : def (h1 :+ h) -> h1 :+ h = h -> def h1 /\ h1 = empty.

Lemma exit3 h1 h : def h -> h = h :+ h1 -> def empty /\ empty = h1.

Lemma exit4 h : def h -> h = h -> def empty /\ empty = empty.

Ltac cancelator t H :=
  match goal with
  
  | |- ?h1 :+ t = ?h2 -> _ =>
     let j := fresh "j" in
     set j := {1}(h1 :+ t);
     rewrite -1?unA /j {j};
     (move/(exit1 H)=>{H} [H] || move/(exit2 H)=>{H} [H])
  | |- t = ?h2 -> _ =>
     rewrite -?unA;
     (move/(exit3 H)=>{H} [H] || move/(exit4 H)=>{H} [H])
  | |- (?h1 :+ (?x :-> ?v) = ?h2) -> _ =>
    let j := fresh "j" in
    set j := {1}(h1 :+ (x :-> v));
    
    rewrite 1?(unC (x :-> _)) -?(unAC _ _ (x :-> _)) /j {j};
    
    (move/(injUh H)=>{H} [H []] ||
    
     rewrite (unC h1) ?unA in H * );
    
    cancelator t H
  
  | |- (?h1 :+ ?h = ?h2) -> _ =>
    let j := fresh "j" in
    set j := {1}(h1 :+ h);
    
    rewrite 1?(unC h) -?(unAC _ _ h) /j {j};
    
    (move/(eqUh H)=>{H} [H []] ||
    
    rewrite (unC h1) ?unA in H * );
    
    cancelator t H
  | |- _ => idtac
  end.

Ltac heap_cancel :=
  match goal with
  | |- ?h1 = ?h2 -> ?GG =>
    let t1 := fresh "t1" in
    let t2 := fresh "t2" in
    let t := fresh "t" in
    let H := fresh "H" in
    let G := fresh "hidden_goal"
    in
      
      suff : def h1; first (
       
       set t1 := {1 2}h1; set t2 := {1}h2; set G := GG;
       
       rewrite -(un0h t1) -(un0h t2) [empty]lock;
       set t := locked empty; rewrite /t1 /t2 {t1 t2};
       move=>H;
       
       rewrite ?unA in H *;
       
       cancelator t H;
       
       move: H {t}; rewrite /G {G})
  | |- _ => idtac
  end.

Lemma cexit1 h1 h2 h : h1 = h2 -> h1 :+ h = h :+ h2.

Lemma cexit2 h1 h : h1 = empty -> h1 :+ h = h.

Lemma cexit3 h1 h : empty = h1 -> h = h :+ h1.

Lemma congUh A h1 h2 x (v1 v2 : A) :
        h1 = h2 -> v1 = v2 -> h1 :+ (x :-> v1) = h2 :+ (x :-> v2).

Lemma congeqUh h1 h2 h : h1 = h2 -> h1 :+ h = h2 :+ h.

Ltac congruencer t :=
  match goal with
  | |- ?h1 :+ t = ?h2 =>
     let j := fresh "j" in
     set j := {1}(h1 :+ t);
     rewrite -1?unA /j {j};
     (apply: cexit1 || apply: cexit2)
  | |- t = ?h2 =>
     rewrite -1?unA;
     (apply: cexit3 || apply: refl_equal)
  | |- (?h1 :+ (?x :-> ?v) = ?h2) =>
    let j := fresh "j" in
    set j := {1}(h1 :+ (x :-> v));
    
    rewrite 1?(unC (x :-> _)) -?(unAC _ _ (x :-> _)) /j {j};
    
    ((apply: congUh; [congruencer t | idtac]) ||
    
     (rewrite (unC h1) ?unA; congruencer t))
  
  | |- (?h1 :+ ?h = ?h2) =>
    let j := fresh "j" in
    set j := {1}(h1 :+ h);
    
    rewrite 1?(unC h) -?(unAC _ _ h) /j {j};
    
    (apply: congeqUh ||
    
    rewrite (unC h1) ?unA);
    
    congruencer t
  | |- _ => idtac
  end.

Ltac heap_congr :=
  match goal with
  | |- ?h1 = ?h2 =>
    let t1 := fresh "t1" in
    let t2 := fresh "t2" in
    let t := fresh "t" in
      set t1 := {1}h1; set t2 := {1}h2;
      
      rewrite -(un0h t1) -(un0h t2) [empty]lock;
      set t := locked empty; rewrite /t1 /t2 {t1 t2};
      
      rewrite ?unA;
      
      congruencer t=>{t}
  | |- _ => idtac
  end.

Lemma test h1 h2 h3 x (v1 v2 : nat) :
        h3 = h2 -> v1 = v2 ->
        h1 :+ (x :-> v1) :+ h3= h2 :+ h1 :+ (x :-> v2).

Definition supdom h2 h1 := subdom h1 h2.

Lemma sexit1 h1 h2 h :
        def (h2 :+ h) ->
          (def h2 -> supdom h2 h1) -> supdom (h2 :+ h) (h :+ h1).

Lemma sexit2 h1 h :
        def (h1 :+ h) -> (def h1 -> supdom h1 empty) ->
          supdom (h1 :+ h) h.

Lemma sexit3 h1 h :
        def h -> (def empty -> supdom empty h1) ->
          supdom h (h :+ h1).

Lemma sexit4 h : def h -> (def empty -> empty = empty) -> supdom h h.

Lemma supdomUh A B h1 h2 x (v1 : A) (v2 : B) :
        def (h2 :+ (x :-> v2)) ->
          (def h2 -> supdom h2 h1) ->
            supdom (h2 :+ (x :-> v2)) (h1 :+ (x :-> v1)).

Lemma supdomeqUh h1 h2 h :
        def (h2 :+ h) -> (def h2 -> supdom h2 h1) -> supdom (h2 :+ h) (h1 :+ h).

Lemma sup_defdef h1 h2 : def h2 -> supdom h2 h1 -> def h1.

Ltac supdom_checker t H :=
  match goal with
  | |- is_true (supdom (?h1 :+ t) ?h2) =>
     let j := fresh "j" in
     set j := {1}(h1 :+ t);
     rewrite -1?unA /j {j};
     (apply: (sexit1 H)=>{H} H || apply: (sexit2 H)=>{H} H)
  | |- is_true (supdom t ?h1) =>
     rewrite -1?unA;
     (apply: (sexit3 H)=>{H} H || apply: (sexit4 H)=>{H} H)
  | |- is_true (supdom (?h1 :+ (?x :-> ?v)) ?h2) =>
    let j := fresh "j" in
    set j := {1}(h1 :+ (x :-> v));
    
    rewrite 1?(unC (x :-> _)) -?(unAC _ _ (x :-> _)) /j {j};
    
    (apply: (supdomUh _ H)=>{H} H ||
    
     (rewrite (unC h1) ?unA in H * )); supdom_checker t H
  
  | |- is_true (supdom (?h1 :+ ?h) ?h2) =>
    let j := fresh "j" in
    set j := {1}(h1 :+ h);
    
    rewrite 1?(unC h) -?(unAC _ _ h) /j {j};
    
    (apply: (supdomeqUh H)=>{H} H ||
    
    (rewrite (unC h1) ?unA in H * ));
    
    supdom_checker t H
  | |- _ => idtac
  end.

Ltac defcheck :=
  match goal with
  | |- is_true (def ?h2) -> is_true (def ?h1) =>
    let t1 := fresh "t1" in
    let t2 := fresh "t2" in
    let t := fresh "t" in
    let H := fresh "H" in
      set t2 := {1}h2; set t1 := {1}h1;
      
      rewrite -(un0h t1) -(un0h t2) [empty]lock;
      set t := locked empty; rewrite /t1 /t2 {t1 t2};
      
      rewrite ?unA;
      move=>H;
      apply: (sup_defdef H);
      
      supdom_checker t H; move: H {t}; rewrite /supdom
  | |- _ => idtac
  end.

Ltac hhauto := (do ?econstructor=>//; try by [heap_congr])=>//. *)
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Ltac add_morphism_tactic := SetoidTactics.add_morphism_tactic.
Notation " R ===> R' " := (@Morphisms.respectful _ _ R R')
  (right associativity, at level 55) : signature_scope.

Definition star (p1 p2 : Pred heap) : Pred heap :=
  [Pred h | exists h1, exists h2, h = h1 :+ h2 /\ h1 \In p1 /\ h2 \In p2].

Definition emp : Pred heap := [Pred i | i = empty].
Definition this i : Pred heap := [Pred h : heap | i = h].
Definition ppts A x (v : A) : Pred heap := [Pred h | locked x :-> v = h].
Definition top : Pred heap := PredT.

Notation "p1 '#' p2" := (star p1 p2)
  (at level 57, right associativity) : rel_scope.
Notation "x ':-->' v" := (ppts x v) (at level 50) : rel_scope.

Add Parametric Morphism : star with signature
  @EqPred _ ===> @EqPred _ ===> @EqPred _ as star_morph.
Proof.
by move=>p1 q1 H1 p2 q2 H2 h /=; split; case=>h1 [h2][->][H3] H4;
exists h1; exists h2; [rewrite -H1 -H2 | rewrite H1 H2].
Qed.

Section BasicProperties.

Lemma starC p1 p2 : p1 # p2 <~> p2 # p1.
Proof.
move=>h /=; split; case=>h1 [h2][->][H1] H2;
by exists h2; exists h1; rewrite unC.
Qed.

Lemma starp0 p : p # emp <~> p.
Proof.
move=>h /=; split; first by case=>h1 [h2][->][H1]->; rewrite unh0.
by move=>H1; exists h; exists empty; rewrite unh0.
Qed.

Lemma star0p p : emp # p <~> p.
Proof. by rewrite starC starp0. Qed.

Lemma starCA p1 p2 p3 : p1 # p2 # p3 <~> p2 # p1 # p3.
Proof.
move=>h; split; case=>h1 [_][->][H1][h2][h3][->][H2] H3 /=;
by rewrite unCA; do !esplit.
Qed.

Lemma starA p1 p2 p3 : (p1 # p2) # p3 <~> p1 # p2 # p3.
Proof. by rewrite (starC p2) starCA starC. Qed.

Lemma starAC p1 p2 p3 : (p1 # p2) # p3 <~> (p1 # p3) # p2.
Proof. by rewrite -2!(starC p3) starA. Qed.

End BasicProperties.
