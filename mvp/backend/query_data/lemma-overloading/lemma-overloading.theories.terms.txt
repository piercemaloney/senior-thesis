
From mathcomp
Require Import ssreflect ssrbool ssrnat ssrfun eqtype seq.
From LemmaOverloading
Require Import prelude prefix perms heaps.
(* prelude:
From mathcomp
Require Import ssreflect ssrbool eqtype ssrfun seq.
Require Import Eqdep ClassicalFacts.
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Axiom pext : forall p1 p2 : Prop, (p1 <-> p2) -> p1 = p2.
Axiom fext : forall A (B : A -> Type) (f1 f2 : forall x, B x),
               (forall x, f1 x = f2 x) -> f1 = f2.

Lemma proof_irrelevance (P : Prop) (p1 p2 : P) : p1 = p2.

Lemma eta A (B : A -> Type) (f : forall x, B x) : f = [eta f].

Lemma ext A (B : A -> Type) (f1 f2 : forall x, B x) :
        f1 = f2 -> forall x, f1 x = f2 x.

Ltac add_morphism_tactic := SetoidTactics.add_morphism_tactic.
Notation " R ===> R' " := (@Morphisms.respectful _ _ R R')
  (right associativity, at level 55) : signature_scope.

Definition inj_pair2 := @inj_pair2.
Arguments inj_pair2 {U P p x y}.

Lemma inj_sval A P : injective (@sval A P).

Lemma svalE A (P : A -> Prop) x H : sval (exist P x H) = x.

Lemma sym A (x y : A) : x = y <-> y = x.

Section HasSelect.
Variables (A : eqType) (p : pred A).

CoInductive has_spec (s : seq A) : bool -> Type :=
| has_true x of x \in s & p x : has_spec s true
| has_false of (all (predC p) s) : has_spec s false.

Lemma hasPx : forall s, has_spec s (has p s).

End HasSelect.

Module Dyn.
Record dynamic : Type := dyn {typ : Type; val : typ}.
End Dyn.

Notation dynamic := Dyn.dynamic.
Notation dyn := Dyn.dyn.

Lemma dyn_inj A (x y : A) : dyn x = dyn y -> x = y.

Lemma dyn_eta d : d = dyn (Dyn.val d).

Lemma dyn_injT A1 A2 (x1 : A1) (x2 : A2) : dyn x1 = dyn x2 -> A1 = A2.

Prenex Implicits dyn_inj dyn_injT.

Section Coercions.
Variable (T : Type -> Type).

Definition coerce A B (x : T A) : A = B -> T B := [eta eq_rect A [eta T] x B].

Lemma eqc A (x : T A) (pf : A = A) : coerce x pf = x.

Definition jmeq A B (x : T A) (y : T B) := forall pf, coerce x pf = y.

Lemma jmE A (x y : T A) : jmeq x y <-> x = y.

Lemma jmeq_refl A (x : T A) : jmeq x x.

End Coercions.

Hint Resolve jmeq_refl : core.
Arguments jmeq T [A B] x y.
Notation "a =jm b" := (jmeq id a b) (at level 50).

Lemma contV B (P : B -> B -> Prop) :
        (forall x x', x =jm x' -> P x x') <-> forall x, P x x.

Lemma contVT B (P : B -> B -> Prop) :
        (forall x x', B = B -> x =jm x' -> P x x') <-> forall x, P x x.

Section Coercions2.
Variable (T : Type -> Type -> Type).

Program
Definition coerce2 A1 A2 B1 B2 (x : T A1 A2) :
             (A1, A2) = (B1, B2) -> T B1 B2.

Lemma eqc2 A1 A2 (x : T A1 A2) (pf : (A1, A2) = (A1, A2)) :
        coerce2 x pf = x.

Definition jmeq2 A1 A2 B1 B2 (x : T A1 B1) (y : T A2 B2) :=
             forall pf, coerce2 x pf = y.

Lemma jm2E A B (x y : T A B) : jmeq2 x y <-> x = y.

Lemma refl_jmeq2 A B (x : T A B) : jmeq2 x x.

End Coercions2.

Hint Resolve refl_jmeq2 : core.
Arguments jmeq2 T [A1 A2 B1 B2] x y.

Lemma compA A B C D (h : A -> B) (g : B -> C) (f : C -> D) :
        (f \o g) \o h = f \o (g \o h).

Lemma compf1 A B (f : A -> B) : f = f \o id.

Lemma comp1f A B (f : A -> B) : f = id \o f.

Definition fprod A1 A2 B1 B2 (f1 : A1 -> B1) (f2 : A2 -> B2) :=
  fun (x : A1 * A2) => (f1 x.1, f2 x.2).

Notation "f1 \* f2" := (fprod f1 f2) (at level 45).

Section Reorder.
Variables (A B C : Type).

Definition swap (x : A * B) :=
  let: (x1, x2) := x in (x2, x1).
Definition rCA (x : A * (B * C)) :=
  let: (x1, (x2, x3)) := x in (x2, (x1, x3)).
Definition rAC (x : (A * B) * C) :=
  let: ((x1, x2), x3) := x in ((x1, x3), x2).
Definition rA (x : A * (B * C)) :=
  let: (x1, (x2, x3)) := x in ((x1, x2), x3).
Definition iA (x : (A * B) * C) :=
  let: ((x1, x2), x3) := x in (x1, (x2, x3)).
Definition pL (x : A * B) :=
  let: (x1, x2) := x in x1.
Definition pR (x : A * B) :=
  let: (x1, x2) := x in x2.
End Reorder.

Prenex Implicits swap rCA rAC rA iA pL pR.

Lemma swapI A B : swap \o swap = @id (A * B).

Lemma rCAI A B C : rCA \o (@rCA A B C) = id.

Lemma rACI A B C : rAC \o (@rAC A B C) = id.

Lemma riA A B C : rA \o (@iA A B C) = id.

Lemma irA A B C : iA \o (@rA A B C) = id.

Lemma swap_prod A1 B1 A2 B2 (f1 : A1 -> B1) (f2 : A2 -> B2) :
        swap \o f1 \* f2 = f2 \* f1 \o swap.

Lemma swap_rCA A B C : swap \o (@rCA A B C) = rAC \o rA.

Lemma swap_rAC A B C : swap \o (@rAC A B C) = rCA \o iA.

Ltac rfe1 x1 := let H := fresh "H" in move=>H; move:H x1=>-> x1.
Ltac rfe2 x1 x2 := let H := fresh "H" in move=>H; move:H x1 x2=>-> x1 x2.
Ltac rfjm := move/jmE=>->.
Ltac rfejm1 x1 := rfe1 x1; rfjm.
Ltac rfejm2 x1 x2 := rfe2 x1 x2; rfjm.
Ltac rfp := move/inj_pair2=>->.
Ltac rfep1 x1 := rfe1 x1; rfp.
Ltac rfep2 x1 x2 := rfe1 x2; rfp.

Ltac rbe1 x1 := let H := fresh "H" in move=>H; move:H x1=><- x1.
Ltac rbe2 x1 x2 := let H := fresh "H" in move=>H; move:H x1 x2=><- x1 x2.
Ltac rbjm := move/jmE=><-.
Ltac rbejm1 x1 := rbe1 x1; rbjm.
Ltac rbejm2 x1 x2 := rbe2 x1 x2; rbjm.
Ltac rbp := move/inj_pair2=><-.
Ltac rbep1 x1 := rbe1 x1; rbp.
Ltac rbep2 x1 x2 := rbe1 x2; rbp.

Reserved Notation "[ /\ P1 , P2 , P3 , P4 , P5 & P6 ]" (at level 0, format
  "'[hv' [ /\ '['  P1 , '/'  P2 , '/'  P3 , '/'  P4 , '/'  P5 ']' '/ '  &  P6 ] ']'").

Reserved Notation "[ \/ P1 , P2 , P3 , P4 & P5 ]" (at level 0, format
  "'[hv' [ \/ '['  P1 , '/'  P2 , '/'  P3 , '/'  P4 ']' '/ '  &  P5 ] ']'").
Reserved Notation "[ \/ P1 , P2 , P3 , P4 , P5 & P6 ]" (at level 0, format
  "'[hv' [ \/ '['  P1 , '/'  P2 , '/'  P3 , '/'  P4 , '/'  P5 ']' '/ '  &  P6 ] ']'").

Inductive and6 (P1 P2 P3 P4 P5 P6 : Prop) : Prop :=
  And6 of P1 & P2 & P3 & P4 & P5 & P6.

Inductive or5 (P1 P2 P3 P4 P5 : Prop) : Prop :=
  Or51 of P1 | Or52 of P2 | Or53 of P3 | Or54 of P4 | Or55 of P5.
Inductive or6 (P1 P2 P3 P4 P5 P6 : Prop) : Prop :=
  Or61 of P1 | Or62 of P2 | Or63 of P3 | Or64 of P4 | Or65 of P5 | Or66 of P6.

Notation "[ /\ P1 , P2 , P3 , P4 , P5 & P6 ]" := (and6 P1 P2 P3 P4 P5 P6) : type_scope.
Notation "[ \/ P1 , P2 , P3 , P4 | P5 ]" := (or5 P1 P2 P3 P4 P5) : type_scope.
Notation "[ \/ P1 , P2 , P3 , P4 , P5 | P6 ]" := (or6 P1 P2 P3 P4 P5 P6) : type_scope.

Section ReflectConnectives.

Variable b1 b2 b3 b4 b5 b6 : bool.
Lemma and6P : reflect [/\ b1, b2, b3, b4, b5 & b6] [&& b1, b2, b3, b4, b5 & b6].

Lemma or5P : reflect [\/ b1, b2, b3, b4 | b5] [|| b1, b2, b3, b4 | b5].

Lemma or6P : reflect [\/ b1, b2, b3, b4, b5 | b6] [|| b1, b2, b3, b4, b5 | b6].

End ReflectConnectives.

Arguments and6P {b1 b2 b3 b4 b5 b6}.
Arguments or5P {b1 b2 b3 b4 b5}.
Arguments or6P {b1 b2 b3 b4 b5 b6}. *)
(* prefix:
From mathcomp
Require Import ssreflect ssrfun ssrbool ssrnat seq.
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Section Prefix.
Variable A : Type.

Fixpoint onth (s : seq A) n : option A :=
  if s is x :: s' then
    if n is n'.+1 then onth s' n' else Some x
  else None.

Definition prefix s1 s2 :=
  forall n x, onth s1 n = some x -> onth s2 n = some x.

Lemma size_onth (s : seq A) n : n < size s -> exists x, onth s n = Some x.

Lemma onth_size (s : seq A) n x : onth s n = Some x -> n < size s.

Lemma prefix_refl s : prefix s s.

Lemma prefix_trans (s2 s1 s3 : seq A) :
        prefix s1 s2 -> prefix s2 s3 -> prefix s1 s3.

Lemma prefix_cons x s1 s2 : prefix (x :: s1) (x :: s2) <-> prefix s1 s2.

Lemma prefix_cons' x y s1 s2 : prefix (x :: s1) (y :: s2) -> x = y /\ prefix s1 s2.

Lemma prefix_size (s t : seq A) : prefix s t -> size s <= size t.

Lemma prefix_onth (s t : seq A) x : x < size s -> prefix s t -> onth s x = onth t x.

End Prefix.

Hint Resolve prefix_refl : core. *)
(* perms:
From mathcomp
Require Import ssreflect ssrfun seq.
From LemmaOverloading
Require Import rels.
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Section Permutations.
Variable A : Type.

Lemma in_split (x : A) (s : seq A) :
        x \In s -> exists s1, exists s2, s = s1 ++ x :: s2.

Inductive perm (s1 s2 : seq A) : Prop :=
| permutation_nil of s1 = [::] & s2 = [::]
| permutation_skip x t1 t2 of s1 = x :: t1 & s2 = x :: t2 & perm t1 t2
| permutation_swap x y t of s1 = x :: y :: t & s2 = y :: x :: t
| permutation_trans t of perm s1 t & perm t s2.

Lemma perm_nil (s : seq A) : perm [::] s <-> s = [::].

Lemma perm_refl (s : seq A) : perm s s.

Hint Resolve perm_refl : core.

Lemma perm_sym s1 s2 : perm s1 s2 <-> perm s2 s1.

Lemma perm_trans s2 s1 s3 : perm s1 s2 -> perm s2 s3 -> perm s1 s3.

Lemma perm_in s1 s2 x : perm s1 s2 -> x \In s1 -> x \In s2.

Lemma perm_cat2lL s s1 s2 : perm s1 s2 -> perm (s ++ s1) (s ++ s2).

Lemma perm_cat2rL s s1 s2 : perm s1 s2 -> perm (s1 ++ s) (s2 ++ s).

Lemma perm_catL s1 t1 s2 t2 :
        perm s1 s2 -> perm t1 t2 -> perm (s1 ++ t1) (s2 ++ t2).

Lemma perm_cat_consL s1 t1 s2 t2 x :
        perm s1 s2 -> perm t1 t2 -> perm (s1 ++ x :: t1) (s2 ++ x :: t2).

Lemma perm_catC s1 s2 : perm (s1 ++ s2) (s2 ++ s1).

Hint Resolve perm_catC : core.

Lemma perm_cons_catCA s1 s2 x : perm (x :: s1 ++ s2) (s1 ++ x :: s2).

Lemma perm_cons_catAC s1 s2 x : perm (s1 ++ x :: s2) (x :: s1 ++ s2).

Hint Resolve perm_cons_catCA perm_cons_catAC : core.

Lemma perm_cons_cat_consL s1 s2 s x :
        perm s (s1 ++ s2) -> perm (x :: s) (s1 ++ x :: s2).

Lemma perm_ind2 (P : seq A -> seq A -> Prop) :
        P [::] [::] ->
        (forall x s1 s2, perm s1 s2 -> P s1 s2 ->
           P (x :: s1) (x :: s2)) ->
        (forall x y s1 s2, perm s1 s2 -> P s1 s2 ->
           P (y :: x :: s1) (x :: y :: s2)) ->
        (forall s2 s1 s3, perm s1 s2 -> P s1 s2 ->
           perm s2 s3 -> P s2 s3 -> P s1 s3) ->
        forall s1 s2, perm s1 s2 -> P s1 s2.

Lemma perm_cat_consR s1 t1 s2 t2 x :
        perm (s1 ++ x :: t1) (s2 ++ x :: t2) -> perm (s1 ++ t1) (s2 ++ t2).

Lemma perm_cons x s1 s2 : perm (x :: s1) (x :: s2) <-> perm s1 s2.

Lemma perm_cons_cat_cons x s1 s2 s :
        perm (x :: s) (s1 ++ x :: s2) <-> perm s (s1 ++ s2).

Lemma perm_cat_cons x s1 s2 t1 t2 :
        perm (s1 ++ x :: t1) (s2 ++ x :: t2) <-> perm (s1 ++ t1) (s2 ++ t2).

Lemma perm_cat2l s1 s2 s3: perm (s1 ++ s2) (s1 ++ s3) <-> perm s2 s3.

Lemma perm_cat2r s1 s2 s3 : perm (s2 ++ s1) (s3 ++ s1) <-> perm s2 s3.

Lemma perm_catAC s1 s2 s3 : perm ((s1 ++ s2) ++ s3) ((s1 ++ s3) ++ s2).

Lemma perm_catCA s1 s2 s3 : perm (s1 ++ s2 ++ s3) (s2 ++ s1 ++ s3).

End Permutations.

Hint Resolve perm_refl perm_catC perm_cons_catCA
             perm_cons_catAC perm_catAC perm_catCA : core. *)
(* heaps:
From mathcomp
Require Import ssreflect ssrfun ssrnat div ssrbool seq.
From LemmaOverloading
Require Import prelude finmap ordtype.
From mathcomp
Require Import path eqtype.
Require Import Eqdep.
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Notation eqn_addl := eqn_add2l.
Notation modn_addl := modnDl.
Notation modn_mulr := modnMr.
Notation modn_add2m := modnDm.
Notation modn_addr := modnDr.

Inductive ptr := ptr_nat of nat.

Definition null := ptr_nat 0.

Definition nat_ptr (x : ptr) := let: ptr_nat y := x in y.

Definition eq_ptr (x y : ptr) :=
  match x, y with ptr_nat m, ptr_nat n => m == n end.

Lemma eq_ptrP : Equality.axiom eq_ptr.

Definition ptr_eqMixin := EqMixin eq_ptrP.
Canonical Structure ptr_eqType := EqType ptr ptr_eqMixin.

Definition ptr_offset x i := ptr_nat (nat_ptr x + i).

Notation "x .+ i" := (ptr_offset x i)
  (at level 3, format "x .+ i").

Lemma ptrE x y : (x == y) = (nat_ptr x == nat_ptr y).

Lemma ptr0 x : x.+0 = x.

Lemma ptrA x i j : x.+i.+j = x.+(i+j).

Lemma ptrK x i j : (x.+i == x.+j) = (i == j).

Lemma ptr_null x m : (x.+m == null) = (x == null) && (m == 0).

Lemma ptrT x y : {m : nat | (x == y.+m) || (y == x.+m)}.

Definition ltn_ptr (x y : ptr) :=
  match x, y with ptr_nat m, ptr_nat n => m < n end.

Lemma ltn_ptr_irr : irreflexive ltn_ptr.

Lemma ltn_ptr_trans : transitive ltn_ptr.

Lemma ltn_ptr_total : forall x y : ptr, [|| ltn_ptr x y, x == y | ltn_ptr y x].

Definition ptr_ordMixin := OrdMixin ltn_ptr_irr ltn_ptr_trans ltn_ptr_total.
Canonical Structure ptr_ordType := OrdType ptr ptr_ordMixin.

Inductive heap :=
  Undef | Def (finmap : {finMap ptr -> dynamic}) of
               null \notin supp finmap.

Section NullLemmas.
Variables (f g : {finMap ptr -> dynamic}) (x : ptr) (d : dynamic).

Lemma upd_nullP :
        x != null -> null \notin supp f -> null \notin supp (ins x d f).

Lemma free_nullP : null \notin supp f -> null \notin supp (rem x f).

Lemma un_nullP :
        null \notin supp f -> null \notin supp g ->
          null \notin supp (fcat f g).

Lemma heapE pf pg : f = g <-> @Def f pf = @Def g pg.

End NullLemmas.

Definition def h := if h is Def _ _ then true else false.

Definition empty := @Def (finmap.nil _ _) is_true_true.

Definition upd h x d := nosimpl
  (if h is Def hs ns then
    if decP (@idP (x != null)) is left pf then
      Def (@upd_nullP _ _ d pf ns)
    else Undef
  else Undef).

Definition dom h : pred ptr := nosimpl
  (if h is Def f _ then mem (supp f) else pred0).

Definition free x h : heap :=
  (if h is Def hs ns then Def (free_nullP x ns) else Undef).

Definition look (x : ptr) h :=
  (if h is Def hs _ then
    if fnd x hs is Some d then d else dyn tt
  else dyn tt).

Definition union2 h1 h2 := nosimpl
  (if (h1, h2) is (Def hs1 ns1, Def hs2 ns2) then
     if disj hs1 hs2 then
        Def (@un_nullP _ _ ns1 ns2)
     else Undef
  else Undef).

Definition empb h :=
  if h is Def hs _ then supp hs == [::] else false.

Definition fresh h :=
  (if h is Def hs _ then last null (supp hs) else null) .+ 1.

Definition subdom h1 h2 :=
  if (h1, h2) is (Def hs1 _, Def hs2 _) then
    all (fun x => x \in supp hs2) (supp hs1)
  else false.

Definition subheap h1 h2 :=
  subdom h1 h2 /\ forall x, x \in dom h1 -> look x h1 = look x h2.

Definition subtract h1 h2 :=
  if h1 is (Def hs1 _) then
    foldl (fun h x => free x h) h2 (supp hs1)
  else Undef.

Definition pick h :=
  if h is Def hs _ then head null (supp hs) else null.

Definition pts A (x : ptr) (v : A) := upd empty x (dyn v).

Notation "h1 :+ h2" := (union2 h1 h2) (at level 43, left associativity).
Notation "h2 :- h1" := (subtract h1 h2) (at level 43, left associativity).
Notation "x :-> v" := (pts x v) (at level 30).

Lemma unC : forall h1 h2, h1 :+ h2 = h2 :+ h1.

Lemma unA : forall h1 h2 h3, h1 :+ (h2 :+ h3) = h1 :+ h2 :+ h3.

Lemma unCA h1 h2 h3 : h1 :+ (h2 :+ h3) = h2 :+ (h1 :+ h3).

Lemma unAC h1 h2 h3 : h1 :+ h2 :+ h3 = h1 :+ h3 :+ h2.

Lemma un0h h : empty :+ h = h.

Lemma unh0 h : h :+ empty = h.

Lemma unKhl h h1 h2 : def (h1 :+ h) -> h1 :+ h = h2 :+ h -> h1 = h2.

Lemma unhKl h h1 h2 : def (h :+ h1) -> h :+ h1 = h :+ h2 -> h1 = h2.

Lemma unKhr h h1 h2 : def (h2 :+ h) -> h1 :+ h = h2 :+ h -> h1 = h2.

Lemma unhKr h h1 h2 : def (h :+ h2) -> h :+ h1 = h :+ h2 -> h1 = h2.

Lemma dom0 : dom empty = pred0.

Lemma domU h y d :
        dom (upd h y d) =i
        [pred x | (y != null) && if x == y then def h else x \in dom h].

Lemma domPt A x (v : A) : dom (x :-> v) =i [pred y | (x == y) && (x != null)].

Lemma domF h x :
        dom (free x h) =i [pred y | if x == y then false else y \in dom h].

Lemma domUn h1 h2 :
        dom (h1 :+ h2) =i
        [pred x | def (h1 :+ h2) && (x \in [predU dom h1 & dom h2])].

Lemma dom_null h x : x \in dom h -> x != null.

Lemma dom_def h x : x \in dom h -> def h.

Lemma dom_free h x : x \notin dom h -> free x h = h.

Lemma dom_look h x : x \notin dom h -> look x h = dyn tt.

Lemma def0 : def empty.

Hint Resolve def0 : core.

Lemma defU h x d : def (upd h x d) = (x != null) && (def h).

Lemma defPt A x (v : A) : def (x :-> v) = (x != null).

Lemma defF h x : def (free x h) = def h.

CoInductive defUn_spec h1 h2 : bool -> Type :=
| def_false1 of ~~ def h1 : defUn_spec h1 h2 false
| def_false2 of ~~ def h2 : defUn_spec h1 h2 false
| def_false3 x of x \in dom h1 & x \in dom h2 : defUn_spec h1 h2 false
| def_true of def h1 & def h2 &
    (forall x, x \in dom h1 -> x \notin dom h2) : defUn_spec h1 h2 true.

Lemma defUn : forall h1 h2, defUn_spec h1 h2 (def (h1 :+ h2)).

Lemma defUnl h1 h2 : def (h1 :+ h2) -> def h1.

Lemma defUnr h1 h2 : def (h1 :+ h2) -> def h2.

Lemma defFUn h1 h2 x : def (h1 :+ h2) -> def (free x h1 :+ h2).

Lemma defUnF h1 h2 x : def (h1 :+ h2) -> def (h1 :+ free x h2).

Lemma undefE x : ~~ def x <-> x = Undef.

Lemma upd_inj h x d1 d2 :
        def h -> x != null -> upd h x d1 = upd h x d2 -> d1 = d2.

Lemma heap_eta h x : x \in dom h -> h = upd (free x h) x (look x h).

Lemma updU h x y d1 d2 :
        upd (upd h x d1) y d2 =
        if x == y then upd h x d2 else upd (upd h y d2) x d1.

Lemma updF h x y d :
        upd (free x h) y d =
        if x == y then upd h x d else free x (upd h y d).

Lemma updUnl h1 h2 x d :
        upd (h1 :+ h2) x d =
        if x \in dom h1 then upd h1 x d :+ h2 else h1 :+ upd h2 x d.

Lemma updUnr h1 h2 x d :
        upd (h1 :+ h2) x d =
        if x \in dom h2 then h1 :+ upd h2 x d else upd h1 x d :+ h2.

Lemma pts_injP A1 A2 x1 x2 (v1 : A1) (v2 : A2) :
        def (x1 :-> v1) -> x1 :-> v1 = x2 :-> v2 -> x1 = x2 /\ A1 = A2.

Lemma pts_injT A1 A2 x (v1 : A1) (v2 : A2) :
        def (x :-> v1) -> x :-> v1 = x :-> v2 -> A1 = A2.

Lemma pts_inj A x (v1 v2 : A) :
        def (x :-> v1) -> x :-> v1 = x :-> v2 -> v1 = v2.

Lemma free0 x : free x empty = empty.

Lemma freeU h x y d :
        free x (upd h y d) = if x == y then
          if y == null then Undef else free x h
        else upd (free x h) y d.

Lemma freeF h x y :
        free x (free y h) = if x == y then free x h else free y (free x h).

Lemma freeUn h1 h2 x :
        free x (h1 :+ h2) =
        if x \in dom (h1 :+ h2) then free x h1 :+ free x h2
        else h1 :+ h2.

Lemma freeUnD h1 h2 x :
        def (h1 :+ h2) -> free x (h1 :+ h2) = free x h1 :+ free x h2.

Lemma freeUnl h1 h2 x : x \notin dom h1 -> free x (h1 :+ h2) = h1 :+ free x h2.

Lemma freeUnr h1 h2 x : x \notin dom h2 -> free x (h1 :+ h2) = free x h1 :+ h2.

Lemma lookU h x y d :
        look x (upd h y d) = if x == y then
          if def h && (y != null) then d else dyn tt
        else if y != null then look x h else dyn tt.

Lemma lookF h x y :
        look x (free y h) = if x == y then dyn tt else look x h.

Lemma lookUnl h1 h2 x :
        def (h1 :+ h2) ->
        look x (h1 :+ h2) = if x \in dom h1 then look x h1 else look x h2.

Lemma lookUnr h1 h2 x :
        def (h1 :+ h2) ->
        look x (h1 :+ h2) = if x \in dom h2 then look x h2 else look x h1.

Lemma empP h : reflect (h = empty) (empb h).

Lemma empU h x d : empb (upd h x d) = false.

Lemma empPt A x (v : A) : empb (x :-> v) = false.

Lemma empUn h1 h2 : empb (h1 :+ h2) = empb h1 && empb h2.

Lemma empbE h : h = empty <-> empb h.

Lemma un0E h1 h2 : h1 :+ h2 = empty <-> h1 = empty /\ h2 = empty.

Lemma defE h : reflect (def h /\ forall x, x \notin dom h)(empb h).

Lemma defUnhh h : def (h :+ h) = empb h.

Lemma path_last n s x : path ord x s -> ord x (last x s).+(n+1).

Lemma path_filter (A : ordType) (s : seq A) (p : pred A) x :
        path ord x s -> path ord x (filter p s).

Lemma dom_fresh h n : (fresh h).+n \notin dom h.

Lemma fresh_null h : fresh h != null.

Opaque fresh.

Hint Resolve dom_fresh fresh_null : core.

Lemma emp_pick h : (pick h == null) = (~~ def h || empb h).

Lemma pickP h : def h && ~~ empb h = (pick h \in dom h).

Lemma subdom_def h1 h2 : subdom h1 h2 -> def h1 && def h2.

Lemma subdomP h1 h2 :
        def h1 -> ~~ empb h1 ->
        reflect (forall x, x \in dom h1 -> x \in dom h2)
                (subdom h1 h2).

Lemma subdomQ x h1 h2 : subdom h1 h2 -> x \in dom h1 -> x \in dom h2.

Lemma subdom_refl h : def h -> subdom h h.

Lemma subdomD h1 h2 h : subdom h1 h2 -> def (h2 :+ h) -> def (h1 :+ h).

Lemma subdomE h1 h2 h :
        def (h2 :+ h) -> subdom h1 h2 -> subdom (h1 :+ h) (h2 :+ h).

Lemma subdomUE h1 h2 h1' h2' :
        def (h2 :+ h2') -> subdom h1 h2 -> subdom h1' h2' ->
          subdom (h1 :+ h1') (h2 :+ h2').

Lemma subdom_emp h : def h -> subdom empty h.

Lemma subdom_emp_inv h : subdom h empty -> h = empty.

Lemma subdomPE A B x (v1 : A) (v2 : B) :
        x != null -> subdom (x :-> v1) (x :-> v2).

Lemma subdom_trans h2 h1 h3 : subdom h1 h2 -> subdom h2 h3 -> subdom h1 h3.

Hint Resolve subdom_emp subdomPE : core.

Lemma subheap_refl h : def h -> subheap h h.

Lemma subheapE h : def h -> subheap empty h.

Lemma subheapUn h1 h2 h1' h2' :
        def (h2 :+ h2') -> subheap h1 h2 -> subheap h1' h2' ->
        subheap (h1 :+ h1') (h2 :+ h2').

Lemma subheapUnl h1 h2 : def (h1 :+ h2) -> subheap h1 (h1 :+ h2).

Lemma subheapUnr h1 h2 : def (h1 :+ h2) -> subheap h2 (h1 :+ h2).

Lemma subheap_def h1 h2 : subheap h1 h2 -> def h1 /\ def h2.

Lemma subheap_trans h2 h1 h3 : subheap h1 h2 -> subheap h2 h3 -> subheap h1 h3.

Lemma subheap_id hp1 hp2: subheap hp1 hp2 -> subheap hp2 hp1 -> hp1 = hp2.

Lemma noalias h1 h2 x1 x2 :
        x1 \in dom h1 -> x2 \in dom h2 -> def (h1 :+ h2) -> x1 != x2.

Lemma defPtUn A h x (v : A) :
        def (x :-> v :+ h) = [&& x != null, def h & x \notin dom h].

Lemma defPt_null A h x (v : A) : def (x :-> v :+ h) -> x != null.

Lemma defPt_def A h x (v : A) : def (x :-> v :+ h) -> def h.

Lemma defPt_dom A h x (v : A) : def (x :-> v :+ h) -> x \notin dom h.

Lemma domPtUn A h x (v : A) :
        dom (x :-> v :+ h) =i
        [pred y | def (x :-> v :+ h) && ((x == y) || (y \in dom h))].

Lemma lookPtUn A h x (v : A) :
        def (x :-> v :+ h) -> look x (x :-> v :+ h) = dyn v.

Lemma freePtUn A h x (v : A) :
        def (x :-> v :+ h) -> free x (x :-> v :+ h) = h.

Lemma updPtUn A1 A2 x i (v1 : A1) (v2 : A2) :
        upd (x :-> v1 :+ i) x (dyn v2) = x :-> v2 :+ i.

Lemma heap_etaP h x : x \in dom h -> h = x :-> Dyn.val (look x h) :+ free x h.

Lemma cancelT A1 A2 h1 h2 x (v1 : A1) (v2 : A2) :
        def (x :-> v1 :+ h1) ->
          x :-> v1 :+ h1 = x :-> v2 :+ h2 -> A1 = A2.

Lemma cancel A h1 h2 x (v1 v2 : A) :
        def (x :-> v1 :+ h1) ->
        x :-> v1 :+ h1 = x :-> v2 :+ h2 -> [/\ v1 = v2, def h1 & h1 = h2].

Lemma domPtUnX A (v : A) x i : def (x :-> v :+ i) -> x \in dom (x :-> v :+ i).

Lemma domPtX A (v : A) x : def (x :-> v) -> x \in dom (x :-> v).

Lemma dom_notin_notin h1 h2 x :
        def (h1 :+ h2) -> x \notin dom (h1 :+ h2) -> x \notin dom h1.

Lemma dom_in_notin h1 h2 x : def (h1 :+ h2) -> x \in dom h1 -> x \notin dom h2.

Section BlockUpdate.
Variable (A : Type).

Fixpoint updi x (vs : seq A) {struct vs} : heap :=
  if vs is v'::vs' then (x :-> v') :+ updi (x .+ 1) vs' else empty.

Lemma updiS x v vs : updi x (v :: vs) = x :-> v :+ updi (x .+ 1) vs.

Lemma updi_last x v vs :
        updi x (rcons vs v) = updi x vs :+ x.+(size vs) :-> v.

Lemma updi_cat x vs1 vs2 :
        updi x (vs1 ++ vs2) = updi x vs1 :+ updi x.+(size vs1) vs2.

Lemma updi_catI x y vs1 vs2 :
        y = x.+(size vs1) -> updi x vs1 :+ updi y vs2 = updi x (vs1 ++ vs2).

Lemma updiVm' x m xs : m > 0 -> x \notin dom (updi x.+m xs).

Lemma updiD x xs : def (updi x xs) = (x != null) || (size xs == 0).

Lemma updiVm x m xs :
        x \in dom (updi x.+m xs) = [&& x != null, m == 0 & size xs > 0].

Lemma updimV x m xs :
        x.+m \in dom (updi x xs) = (x != null) && (m < size xs).

Lemma updiP x y xs :
        reflect (y != null /\ exists m, x = y.+m /\ m < size xs)

Lemma updi_inv x xs1 xs2 :
        def (updi x xs1) -> updi x xs1 = updi x xs2 -> xs1 = xs2.

Lemma updi_iinv x xs1 xs2 h1 h2 :
        size xs1 = size xs2 -> def (updi x xs1 :+ h1) ->
        updi x xs1 :+ h1 = updi x xs2 :+ h2 -> xs1 = xs2 /\ h1 = h2.

End BlockUpdate.

Definition low : pred ptr := fun x => 0 == nat_ptr x %[mod 2].
Definition high : pred ptr := fun x => 1 == nat_ptr x %[mod 2].

Definition get_lows h :=
  if h is Def hs _ then filter low (supp hs) else [::].

Definition get_highs h :=
  if h is Def hs _ then filter high (supp hs) else [::].

Definition ldom h : pred ptr := fun x => x \in get_lows h.
Definition hdom h : pred ptr := fun x => x \in get_highs h.

Lemma ldomP h x : x \in ldom h = (x \in dom h) && low x.

Lemma hdomP h x : x \in hdom h = (x \in dom h) && high x.

Lemma ldomK h1 h2 t1 t2 :
        def (h1 :+ t1) -> def (h2 :+ t2) ->
        ldom h1 =i ldom h2 ->
        ldom (h1 :+ t1) =i ldom (h2 :+ t2) -> ldom t1 =i ldom t2.

Definition lfresh h := (last null (get_lows h)) .+ 2.
Definition hfresh h := (last (null .+ 1) (get_highs h)) .+ 2.

Lemma last_inv A B (f : A -> B) (x1 x2 : A) (h : seq A) :
        f x1 = f x2 -> f (last x1 h) = f (last x2 h).

Lemma lfresh_low h n : low (lfresh h) .+ (2*n).

Lemma hfresh_high h n : high (hfresh h) .+ (2*n).

Lemma dom_lfresh h n : (lfresh h) .+ (2*n) \notin dom h.

Lemma dom_hfresh h n : (hfresh h) .+ (2*n) \notin dom h.

Lemma lfresh_null h : lfresh h != null.

Lemma hfresh_null h : hfresh h != null.

Lemma high_lowD : [predI low & high] =i pred0.

Lemma modnS x1 x2 : (x1 == x2 %[mod 2]) = (x1.+1 == x2.+1 %[mod 2]).

Lemma hlE x : high x = ~~ low x.

Lemma lhE x : low x = ~~ high x.

Lemma ldomUn h1 h2 :
        ldom (h1 :+ h2) =i
        [pred x | def (h1 :+ h2) && (x \in [predU ldom h1 & ldom h2])].

Definition loweq h1 h2 := get_lows h1 == get_lows h2.

Notation "h1 =~ h2" := (loweq h1 h2) (at level 80).

Lemma low_refl h : h =~ h.

Hint Resolve low_refl : core.

Lemma low_sym h1 h2 : (h1 =~ h2) = (h2 =~ h1).

Lemma low_trans h2 h1 h3 : h1 =~ h2 -> h2 =~ h3 -> h1 =~ h3.

Lemma loweqP h1 h2 : reflect (ldom h1 =i ldom h2) (h1 =~ h2).

Lemma loweqK h1 h2 t1 t2 :
        def (h1 :+ t1) -> def (h2 :+ t2) ->
        h1 =~ h2 -> h1 :+ t1 =~ h2 :+ t2 -> t1 =~ t2.

Lemma loweqE h1 h2 : h1 =~ h2 -> lfresh h1 = lfresh h2.

Lemma lowUn h1 h2 t1 t2 :
        def (h1 :+ t1) ->
        def (h2 :+ t2) ->
        h1 =~ h2 -> t1 =~ t2 -> h1 :+ t1 =~ h2 :+ t2.

Lemma lowPn A1 A2 (x : ptr) (v1 : A1) (v2 : A2) : x :-> v1 =~ x :-> v2.

Hint Resolve lowPn : core.

Lemma highPn A1 A2 (x1 x2 : ptr) (v1 : A1) (v2 : A2) :
        high x1 -> high x2 -> x1 :-> v1 =~ x2 :-> v2.

Lemma lowPtUn A1 A2 h1 h2 (x : ptr) (v1 : A1) (v2 : A2) :
        def (x :-> v1 :+ h1) ->
        def (x :-> v2 :+ h2) ->
        (x :-> v1 :+ h1 =~ x :-> v2 :+ h2) = (h1 =~ h2).

Lemma highPtUn A h1 h2 (x : ptr) (v : A) :
        def (x :-> v :+ h1) -> high x ->
        (x :-> v :+ h1 =~ h2) = (h1 =~ h2).

Lemma highPtUn2 A1 A2 h1 h2 (x1 x2 : ptr) (v1 : A1) (v2 : A2) :
        def (x1 :-> v1 :+ h1) ->
        def (x2 :-> v2 :+ h2) ->
        high x1 -> high x2 ->
        h1 =~ h2 -> x1 :-> v1 :+ h1 =~ x2 :-> v2 :+ h2.

Definition plus2 (h1 h2 : heap * heap) : heap * heap :=
  (h1.1 :+ h2.1, h1.2 :+ h2.2).

Definition def2 (h : heap * heap) := def h.1 && def h.2.

Notation "h1 :++ h2" := (plus2 h1 h2) (at level 50).

Lemma unA2 h1 h2 h3 : h1 :++ (h2 :++ h3) = h1 :++ h2 :++ h3.

Lemma unC2 h1 h2 : h1 :++ h2 = h2 :++ h1.

Lemma unKhl2 h h1 h2 : def2 (h1 :++ h) -> h1 :++ h = h2 :++ h -> h1 = h2.

Lemma unKhr2 h h1 h2 : def2 (h2 :++ h) -> h1 :++ h = h2 :++ h -> h1 = h2.

Lemma unDl2 h1 h2 : def2 (h1 :++ h2) -> def2 h1.

Lemma unDr2 h1 h2 : def2 (h1 :++ h2) -> def2 h2.

Lemma un0h2 h : (empty, empty) :++ h = h.

Lemma unh02 h : h :++ (empty, empty) = h.

Lemma injUh A h1 h2 x (v1 v2 : A) :
        def (h1 :+ (x :-> v1)) ->
        h1 :+ (x :-> v1) = h2 :+ (x :-> v2) ->
          def h1 /\ h1 = h2 /\ v1 = v2.

Lemma eqUh h1 h2 h : def (h1 :+ h) -> h1 :+ h = h2 :+ h -> def h1 /\ h1 = h2.

Lemma exit1 h1 h2 h : def (h1 :+ h) -> h1 :+ h = h :+ h2 -> def h1 /\ h1 = h2.

Lemma exit2 h1 h : def (h1 :+ h) -> h1 :+ h = h -> def h1 /\ h1 = empty.

Lemma exit3 h1 h : def h -> h = h :+ h1 -> def empty /\ empty = h1.

Lemma exit4 h : def h -> h = h -> def empty /\ empty = empty.

Ltac cancelator t H :=
  match goal with
  
  | |- ?h1 :+ t = ?h2 -> _ =>
     let j := fresh "j" in
     set j := {1}(h1 :+ t);
     rewrite -1?unA /j {j};
     (move/(exit1 H)=>{H} [H] || move/(exit2 H)=>{H} [H])
  | |- t = ?h2 -> _ =>
     rewrite -?unA;
     (move/(exit3 H)=>{H} [H] || move/(exit4 H)=>{H} [H])
  | |- (?h1 :+ (?x :-> ?v) = ?h2) -> _ =>
    let j := fresh "j" in
    set j := {1}(h1 :+ (x :-> v));
    
    rewrite 1?(unC (x :-> _)) -?(unAC _ _ (x :-> _)) /j {j};
    
    (move/(injUh H)=>{H} [H []] ||
    
     rewrite (unC h1) ?unA in H * );
    
    cancelator t H
  
  | |- (?h1 :+ ?h = ?h2) -> _ =>
    let j := fresh "j" in
    set j := {1}(h1 :+ h);
    
    rewrite 1?(unC h) -?(unAC _ _ h) /j {j};
    
    (move/(eqUh H)=>{H} [H []] ||
    
    rewrite (unC h1) ?unA in H * );
    
    cancelator t H
  | |- _ => idtac
  end.

Ltac heap_cancel :=
  match goal with
  | |- ?h1 = ?h2 -> ?GG =>
    let t1 := fresh "t1" in
    let t2 := fresh "t2" in
    let t := fresh "t" in
    let H := fresh "H" in
    let G := fresh "hidden_goal"
    in
      
      suff : def h1; first (
       
       set t1 := {1 2}h1; set t2 := {1}h2; set G := GG;
       
       rewrite -(un0h t1) -(un0h t2) [empty]lock;
       set t := locked empty; rewrite /t1 /t2 {t1 t2};
       move=>H;
       
       rewrite ?unA in H *;
       
       cancelator t H;
       
       move: H {t}; rewrite /G {G})
  | |- _ => idtac
  end.

Lemma cexit1 h1 h2 h : h1 = h2 -> h1 :+ h = h :+ h2.

Lemma cexit2 h1 h : h1 = empty -> h1 :+ h = h.

Lemma cexit3 h1 h : empty = h1 -> h = h :+ h1.

Lemma congUh A h1 h2 x (v1 v2 : A) :
        h1 = h2 -> v1 = v2 -> h1 :+ (x :-> v1) = h2 :+ (x :-> v2).

Lemma congeqUh h1 h2 h : h1 = h2 -> h1 :+ h = h2 :+ h.

Ltac congruencer t :=
  match goal with
  | |- ?h1 :+ t = ?h2 =>
     let j := fresh "j" in
     set j := {1}(h1 :+ t);
     rewrite -1?unA /j {j};
     (apply: cexit1 || apply: cexit2)
  | |- t = ?h2 =>
     rewrite -1?unA;
     (apply: cexit3 || apply: refl_equal)
  | |- (?h1 :+ (?x :-> ?v) = ?h2) =>
    let j := fresh "j" in
    set j := {1}(h1 :+ (x :-> v));
    
    rewrite 1?(unC (x :-> _)) -?(unAC _ _ (x :-> _)) /j {j};
    
    ((apply: congUh; [congruencer t | idtac]) ||
    
     (rewrite (unC h1) ?unA; congruencer t))
  
  | |- (?h1 :+ ?h = ?h2) =>
    let j := fresh "j" in
    set j := {1}(h1 :+ h);
    
    rewrite 1?(unC h) -?(unAC _ _ h) /j {j};
    
    (apply: congeqUh ||
    
    rewrite (unC h1) ?unA);
    
    congruencer t
  | |- _ => idtac
  end.

Ltac heap_congr :=
  match goal with
  | |- ?h1 = ?h2 =>
    let t1 := fresh "t1" in
    let t2 := fresh "t2" in
    let t := fresh "t" in
      set t1 := {1}h1; set t2 := {1}h2;
      
      rewrite -(un0h t1) -(un0h t2) [empty]lock;
      set t := locked empty; rewrite /t1 /t2 {t1 t2};
      
      rewrite ?unA;
      
      congruencer t=>{t}
  | |- _ => idtac
  end.

Lemma test h1 h2 h3 x (v1 v2 : nat) :
        h3 = h2 -> v1 = v2 ->
        h1 :+ (x :-> v1) :+ h3= h2 :+ h1 :+ (x :-> v2).

Definition supdom h2 h1 := subdom h1 h2.

Lemma sexit1 h1 h2 h :
        def (h2 :+ h) ->
          (def h2 -> supdom h2 h1) -> supdom (h2 :+ h) (h :+ h1).

Lemma sexit2 h1 h :
        def (h1 :+ h) -> (def h1 -> supdom h1 empty) ->
          supdom (h1 :+ h) h.

Lemma sexit3 h1 h :
        def h -> (def empty -> supdom empty h1) ->
          supdom h (h :+ h1).

Lemma sexit4 h : def h -> (def empty -> empty = empty) -> supdom h h.

Lemma supdomUh A B h1 h2 x (v1 : A) (v2 : B) :
        def (h2 :+ (x :-> v2)) ->
          (def h2 -> supdom h2 h1) ->
            supdom (h2 :+ (x :-> v2)) (h1 :+ (x :-> v1)).

Lemma supdomeqUh h1 h2 h :
        def (h2 :+ h) -> (def h2 -> supdom h2 h1) -> supdom (h2 :+ h) (h1 :+ h).

Lemma sup_defdef h1 h2 : def h2 -> supdom h2 h1 -> def h1.

Ltac supdom_checker t H :=
  match goal with
  | |- is_true (supdom (?h1 :+ t) ?h2) =>
     let j := fresh "j" in
     set j := {1}(h1 :+ t);
     rewrite -1?unA /j {j};
     (apply: (sexit1 H)=>{H} H || apply: (sexit2 H)=>{H} H)
  | |- is_true (supdom t ?h1) =>
     rewrite -1?unA;
     (apply: (sexit3 H)=>{H} H || apply: (sexit4 H)=>{H} H)
  | |- is_true (supdom (?h1 :+ (?x :-> ?v)) ?h2) =>
    let j := fresh "j" in
    set j := {1}(h1 :+ (x :-> v));
    
    rewrite 1?(unC (x :-> _)) -?(unAC _ _ (x :-> _)) /j {j};
    
    (apply: (supdomUh _ H)=>{H} H ||
    
     (rewrite (unC h1) ?unA in H * )); supdom_checker t H
  
  | |- is_true (supdom (?h1 :+ ?h) ?h2) =>
    let j := fresh "j" in
    set j := {1}(h1 :+ h);
    
    rewrite 1?(unC h) -?(unAC _ _ h) /j {j};
    
    (apply: (supdomeqUh H)=>{H} H ||
    
    (rewrite (unC h1) ?unA in H * ));
    
    supdom_checker t H
  | |- _ => idtac
  end.

Ltac defcheck :=
  match goal with
  | |- is_true (def ?h2) -> is_true (def ?h1) =>
    let t1 := fresh "t1" in
    let t2 := fresh "t2" in
    let t := fresh "t" in
    let H := fresh "H" in
      set t2 := {1}h2; set t1 := {1}h1;
      
      rewrite -(un0h t1) -(un0h t2) [empty]lock;
      set t := locked empty; rewrite /t1 /t2 {t1 t2};
      
      rewrite ?unA;
      move=>H;
      apply: (sup_defdef H);
      
      supdom_checker t H; move: H {t}; rewrite /supdom
  | |- _ => idtac
  end.

Ltac hhauto := (do ?econstructor=>//; try by [heap_congr])=>//. *)
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Structure ctx := Context {heap_ctx : seq heap; ptr_ctx : seq ptr}.

Definition empc := Context [::] [::].

Definition subctx i j :=
  prefix (heap_ctx i) (heap_ctx j) /\ prefix (ptr_ctx i) (ptr_ctx j).

Lemma subctx_refl i: subctx i i.
Proof. by []. Qed.

Lemma subctx_trans j i k :
        subctx i j -> subctx j k -> subctx i k.
Proof.
move=>[H1 P1][H2 P2].
by split; [move: H2|move: P2]; apply: prefix_trans.
Qed.

Inductive elem := Pts of nat & dynamic | Var of nat.
Definition synheap := seq elem.

Fixpoint valid_ptrs i t :=
  match t with
    Pts sx _ :: s => (sx < size (ptr_ctx i)) && valid_ptrs i s
  | Var _ :: s => valid_ptrs i s
  | _ => true
  end.

Fixpoint valid_heaps i t :=
  match t with
    Pts _ _ :: s => valid_heaps i s
  | Var v :: s => (v < size (heap_ctx i)) && valid_heaps i s
  | _ => true
  end.

Definition valid i t := valid_ptrs i t && valid_heaps i t.

Lemma valid_cons i e t : valid i (e :: t) = valid i [:: e] && valid i t.
Proof.
case: e=>[x d|v] /=; rewrite /valid /=;
by [rewrite !andbT andbA | rewrite andbT andbCA].
Qed.

Lemma valid_ptrs_cat j t1 t2 :
        valid_ptrs j (t1 ++ t2) = valid_ptrs j t1 && valid_ptrs j t2.
Proof.
elim: t1 t2=>[//|v t1 IH /=] t2.
by case: v=>[x d | v]; rewrite IH // andbA.
Qed.

Lemma valid_heaps_cat j t1 t2 :
        valid_heaps j (t1 ++ t2) = valid_heaps j t1 && valid_heaps j t2.
Proof.
elim: t1 t2=>[//|v t1 IH /=] t2.
by case: v=>[x d | v]; rewrite IH // andbA.
Qed.

Lemma valid_cat j t1 t2 : valid j (t1 ++ t2) = valid j t1 && valid j t2.
Proof.
rewrite /valid valid_ptrs_cat valid_heaps_cat.
by rewrite -!andbA -!(andbCA (valid_ptrs j t2)).
Qed.

Lemma valid_subctx i j t : subctx i j -> valid i t -> valid j t.
Proof.
case: i j=>hs1 xs1 [hs2 xs2][/= P1 P2].
elim: t=>[//|e t IH]; rewrite -cat1s 2!valid_cat.
case/andP=>H; move/IH=>->.
case: e H=>[x d| v]; rewrite /valid /= !andbT => H; apply: leq_trans H _;
by [apply: (prefix_size P2) | apply: (prefix_size P1)].
Qed.

Definition hlook := [fun i => onth (heap_ctx i)].
Definition plook := [fun i => onth (ptr_ctx i)].

Notation plook' i x := (odflt null (plook i x)).

Definition einterp i e :=
  match e with
    Pts x d =>
      if plook i x is Some x'
        then x' :-> Dyn.val d
      else Undef
  | Var h => if hlook i h is Some h' then h' else Undef
  end.

Fixpoint interp i t :=
  if t is e :: t' then
    if t' is [::] then einterp i e else einterp i e :+ interp i t'
  else empty.

Lemma interp_cons i e t : interp i (e :: t) = einterp i e :+ interp i t.
Proof. by case:t=>//; rewrite unh0. Qed.

Lemma interp_cat i t1 t2 : interp i (t1 ++ t2) = interp i t1 :+ interp i t2.
Proof.
elim:t1 t2=>[/=|e t1 IH] t2; first by rewrite un0h.
by rewrite cat_cons !interp_cons IH unA.
Qed.

Lemma interp_perm i : forall t1 t2, perm t1 t2 -> interp i t1 = interp i t2.
Proof.
apply: perm_ind=>[s1 s2 ->-> //|t1 t2 x t1' t2' ->->|x y t1' t2' t ->->|x y t].
- by rewrite 2!interp_cons=>_ ->.
- by rewrite !interp_cons unCA.
by move=>_ -> _ ->.
Qed.

Lemma interp_subctx j k t: valid j t -> subctx j k -> interp j t = interp k t.
Proof.
move=>I [S1 S2]; elim:t I=>[//|e t IH].
rewrite 2!interp_cons valid_cons; case/andP=>H1.
move/IH=>->; case: e H1=>[x d|v] /=;
rewrite /valid /= !andbT; move/prefix_onth;
by [move/(_ _ S2)=>-> | move/(_ _ S1)=>->].
Qed.

Inductive fact :=
  eqH of synheap & synheap | eqD of dynamic & dynamic | eqX of nat & nat.

Definition eval_fact i f :=
  match f with
  | eqH h1 h2 => interp i h1 = interp i h2
  | eqD d1 d2 => d1 = d2
  | eqX x1 x2 => plook i x1 = plook i x2
  end.

Fixpoint eval i s :=
  match s with
  | [:: f] => eval_fact i f
  | (f :: fs) => eval_fact i f /\ eval i fs
  | [::] => True
  end.

Fixpoint ptrs t : seq nat :=
  if t is e :: t' then
    if e is Pts x _ then x :: (ptrs t')
    else ptrs t'
  else [::].

Fixpoint vars t : seq nat :=
  if t is e :: t' then
    if e is Var h then h :: (vars t')
    else vars t'
  else [::].

Definition ptreq (x : nat) e := if e is Pts y _ then x == y else false.
Definition vareq (h : nat) e := if e is Var k then h == k else false.

Fixpoint pread x t :=
  match t with
    Pts y d :: s => if x == y then some d else pread x s
  | e :: s => pread x s
  | _ => None
  end.

Notation pread' x t := (odflt (dyn tt) (pread x t)).

Definition pfree x t := filter (predC (ptreq x)) t.
Definition hfree h t := filter (predC (vareq h)) t.

Fixpoint cancel' (i : ctx) (t1 t2 r : synheap) (f : seq fact) : seq fact :=
  match t1 with
  | [::] => match r, t2 with
            | [::], [::] => f
            | [:: Pts x d], [:: Pts x' d'] =>
                [:: eqX x x', eqD d d' & f]
            | _ , _ => [:: eqH r t2 & f]
            end
  | Pts x d :: t1' =>
      if x \in ptrs t2
        then cancel' i t1' (pfree x t2) r [:: eqD d (pread' x t2) & f]
      else cancel' i t1' t2 [:: Pts x d & r] f
  | Var h :: t1' =>
      if h \in vars t2 then cancel' i t1' (hfree h t2) r f
      else cancel' i t1' t2 [:: Var h & r] f
  end.

Definition cancel i t1 t2 := cancel' i t1 t2 [::] [::].

Lemma eval_cons i f s : eval i (f :: s) <-> eval_fact i f /\ eval i s.
Proof. by case:s=>//; split=>//; case. Qed.

Lemma eval_cat i s1 s2 : eval i (s1 ++ s2) <-> eval i s1 /\ eval i s2.
Proof.
elim: s1=>[/=|f s1 IH]; first tauto.
by rewrite cat_cons !eval_cons IH; tauto.
Qed.

Lemma eval_rcons i f s : eval i (rcons s f) <-> eval i s /\ eval_fact i f.
Proof. by rewrite -cats1 eval_cat. Qed.

Lemma pfreeE x t :
        pfree x t =
          if t is e :: t' then
            if e is Pts y d then
              if x == y then pfree x t' else e :: pfree x t'
            else e :: pfree x t'
          else [::].
Proof. by elim:t=>[|e t IH] //; case: e=>[y d|] //=; case: eqP. Qed.

Lemma hfreeE h t :
        hfree h t =
          if t is e :: t' then
            if e is Var k then
              if h == k then hfree h t' else e :: hfree h t'
            else e :: hfree h t'
          else [::].
Proof. by elim:t=>[|e t IH] //; case: e=>[| n] //=; case: eqP. Qed.

Lemma ptr_has x t : has (ptreq x) t = (x \in ptrs t).
Proof.
by elim:t=>[//|e t IH]; case: e=>[y d|//]; rewrite /= inE IH.
Qed.

Lemma var_has h t : has (vareq h) t = (h \in vars t).
Proof. by elim:t=>[//|e t IH]; case: e=>[//|n]; rewrite /= inE IH. Qed.

Lemma pfreeN x t : x \notin ptrs t -> pfree x t = t.
Proof.
rewrite -ptr_has; elim: t=>[|e t IH] //=; rewrite negb_or.
by case/andP=>->; move/IH=>->.
Qed.

Lemma pfree_subdom i x t :
        def (interp i t) -> subdom (interp i (pfree x t)) (interp i t).
Proof.
elim:t=>[//|e t IH]; rewrite interp_cons /= => D.
case: ifP=>_; last first.
- rewrite -(un0h (interp _ _)); apply: subdomUE=>//.
  - by apply: subdom_emp; rewrite (defUnl D).
  by apply: IH; rewrite (defUnr D).
rewrite interp_cons; apply: subdomUE=>//.
- by apply: subdom_refl; rewrite (defUnl D).
by apply: IH; rewrite (defUnr D).
Qed.

Lemma pfree_def i x t: def (interp i t) -> def (interp i (pfree x t)).
Proof. by move/(pfree_subdom x); move/subdom_def; move/andP=>[-> _]. Qed.

Lemma hfreeN h t : h \notin vars t -> hfree h t = t.
Proof.
rewrite -var_has; elim: t=>[|e t IH] //=; rewrite negb_or.
by case/andP=>->; move/IH=>->.
Qed.

Lemma vars_hfree (h1 h2 : nat) t :
        has (vareq h1) (hfree h2 t) = (h1 != h2) && (has (vareq h1) t).
Proof.
elim:t=>[|e t IH]; first by rewrite andbF.
case: e=>[//|n /=].
by case: ifP=>/= E; rewrite IH; case: (h1 =P n)=>// ->; rewrite eq_sym E.
Qed.

Lemma hfree_subdom i h t :
        def (interp i t) ->
          {subset dom (interp i (hfree h t)) <= dom (interp i t)}.
Proof.
elim:t=>[_ x //|e t IH]; rewrite interp_cons /= => D.
case: ifP=>_; last first.
- move=>x; move/(IH (defUnr D)).
  by rewrite domUn !inE D orbC => ->.
rewrite interp_cons => x; rewrite !domUn !inE D /=.
case/andP=>D2; case/orP; rewrite ?inE; first by move->.
by move/(IH (defUnr D) x)=>->; rewrite orbT.
Qed.

Lemma hfree_subdom' i h t :
        def (interp i t) ->
          subdom (interp i (hfree h t)) (interp i t).
Proof.
elim:t=>[//|e t IH]; rewrite interp_cons /= => D.
case: ifP=>_; last first.
- rewrite -(un0h (interp _ _)).
  apply: subdomUE=>//.
  - by apply: subdom_emp; rewrite (defUnl D).
  by apply: IH; rewrite (defUnr D).
rewrite interp_cons.
apply: subdomUE=>//.
- by apply: subdom_refl; rewrite (defUnl D).
by apply: IH; rewrite (defUnr D).
Qed.

Lemma hfree_def i h t : def (interp i t) -> def (interp i (hfree h t)).
Proof. by move/(hfree_subdom' h); move/subdom_def; move/andP=>[-> _]. Qed.

Lemma count0_hfree v t: count (pred1 v) (vars t) = 0 -> hfree v t = t.
Proof. by move/eqP; rewrite eqn0Ngt -has_count has_pred1; apply: hfreeN. Qed.

Lemma count1_hfree v t :
        count (pred1 v) (vars t) = 1 -> perm (Var v :: hfree v t) t.
Proof.
elim: t=>[//|w t IH]; case: w=>[x d H|v'] /=.
- rewrite perm_sym -(cat1s (Var v) _).
  apply: perm_cons_cat_consL.
  by rewrite perm_sym; apply: IH.
rewrite eq_sym; case: eqP=>[->|_] /=.
  rewrite -{2}[1]addn0; move/eqP; rewrite eqn_addl; move/eqP.
  by move/count0_hfree=>->.
rewrite add0n; move/IH=>H; rewrite perm_sym -(cat1s (Var v)).
by apply: perm_cons_cat_consL; rewrite perm_sym.
Qed.

Lemma countN_varfree i v t :
        count (pred1 v) (vars t) > 1 -> def (interp i t) ->
        hlook i v = Some empty.
Proof.
elim: t v=>[//|[x d|h] s IH] v H; rewrite interp_cons=>D.
- by apply: IH=>//; apply defUnr in D.
rewrite /= in H.
case: (h =P v) H=>[<-|_]; last by move/IH; apply; apply: defUnr D.
case H2: (count _ _)=>[//|[|n]] _; last first.
- by apply: IH; [rewrite H2 | apply: defUnr D].
move/count1_hfree: H2=>H2.
rewrite -(interp_perm i H2) interp_cons unA in D.
move: (defUnl D); rewrite defUnhh /=.
by case: (onth _ _)=>// a; move/empP=>->.
Qed.

Lemma empty_hfree i v t :
        hlook i v = Some empty -> interp i (hfree v t) = interp i t.
Proof.
elim: t=>[//|[x d|v'] t IH] H1; rewrite [hfree _ _]/=.
- by rewrite 2!interp_cons IH.
case: ifP=>H2; first by rewrite 2!interp_cons IH.
rewrite /= in H1; rewrite -(eqP (negbFE H2)) {}IH //= H1.
by case: t=>[//|e s]; rewrite un0h.
Qed.

Lemma domR i (x : nat) t :
        def (interp i t) -> has (ptreq x) t ->
        plook' i x \in dom (interp i t).
Proof.
elim: t x=>[//|e1 t IH] x; rewrite interp_cons /= => D.
case/orP=>E; last by rewrite domUn !inE D (IH _ (defUnr D) E) orbT.
rewrite domUn !inE D.
case: e1 E D=>//= y d; move/eqP=><-; move/defUnl.
case: (onth _ _)=>[a|] //=.
by rewrite defPt domPt !inE eqxx => ->.
Qed.

Lemma lookR i t x :
        def (interp i t) -> has (ptreq x) t ->
        look (plook' i x) (interp i t) = pread' x t.
Proof.
elim: t x=>[//|e1 t IH] x; rewrite interp_cons /=.
case F: (ptreq x e1)=>/= D E; last first.
- rewrite (lookUnr _ D) (domR (defUnr D) E) (IH _ (defUnr D) E).
  by case: e1 F {D}=>//= y d ->.
case: e1 {E} F D=>// y d; move/eqP=><-{y} D.
rewrite (_ : einterp i _ = interp i [:: Pts x d]) // in D *.
rewrite (lookUnl _ D) (domR (defUnl D)) /= ?eqxx //.
move/defUnl: D=>/=; case: (onth _ x)=>[a|] //.
rewrite defPt lookU /= eqxx => ->.
by rewrite -dyn_eta.
Qed.

Lemma defR i t : def (interp i t) -> uniq (ptrs t).
Proof.
elim: t=>[//|e t IH]; rewrite interp_cons /=.
case: e=>[y d|n] /=; case E: (onth _ _)=>[a|//]; last by move/defUnr.
case: defUn=>// D1 D2 L _.
rewrite (IH D2) andbT -ptr_has.
apply: contra (L a _); first by move/(domR D2); rewrite /= E.
by rewrite defPt domPt !inE eqxx in D1 *.
Qed.

Lemma freeR i t x :
        def (interp i t) -> has (ptreq x) t ->
        free (plook' i x) (interp i t) = interp i (pfree x t).
Proof.
elim: t=>[//|e t IH]; rewrite interp_cons=>D /=.
case E: (ptreq x e)=>/=; last first.
- move=>H; rewrite freeUnl; first by rewrite (IH (defUnr D) H) -{1}interp_cons.
  case: defUn D=>// D1 D2 L _.
  apply: (contra (L (plook' i x))); rewrite negbK.
  by apply: domR.
case: e E D=>//= y d; move/eqP=><-{y}.
case F: (onth _ x)=>[a|//] D _.
rewrite freePtUn //= pfreeN // -ptr_has.
apply: contra (defPt_dom D); move/(domR (defPt_def D)).
by rewrite /= F.
Qed.

Lemma cancel_sound' i sh1 sh2 unm fs :
        interp i sh2 = interp i (sh1 ++ unm) ->
        def (interp i sh2) -> eval i fs ->
        eval i (cancel' i sh1 sh2 unm fs).
Proof.
elim: sh1 sh2 unm fs=>[|[sx sd|sv] sh1 IH] sh2 unm fs.
- case: unm=>[|[sxu sdu|svu] [|[sxu' sud'|svu'] unm']];
  case: sh2=>[|[sx2 sd2|sv2] sh2'] /=; try by case: fs.
  case A: (onth _ sx2)=>[a|]; last by case sh2'.
  case D: (onth _ sxu)=>[d|]; last by move->.
  case: sh2'=>[/= H2 Def|e sh2']; last by rewrite /= A D =>->; case: fs.
  case: (pts_injP Def H2)=>[H3 H4].
  rewrite A D H3; split=>//.
  case: sdu sd2 H4 H2 Def=>b1 b2 [c1 c2] /= H4; move: b2.
  rewrite -H4 H3=> b2 H2 Def.
  by move/(pts_inj Def): H2=>->; case: fs H.
- rewrite [eval _ (cancel' _ _ _ _ _)]/=.
  case: ifP=>H1 H2 D E; last first.
  - apply: (IH _ _ _ _ D E).
    by rewrite H2 2!interp_cat 2!interp_cons unCA unA.
  apply: IH; last 2 first.
  - by apply: pfree_def.
  - rewrite -ptr_has in H1; rewrite /= -(lookR D H1).
    rewrite H2 interp_cons /= in D *.
    case A: (onth _ sx)=>[a|//] in D *.
    by rewrite (lookPtUn D) -dyn_eta; case: fs E.
  rewrite -ptr_has in H1; rewrite -(freeR D H1).
  rewrite H2 cat_cons /= in D *.
  case A: (onth _ sx)=>[a /=|] in D *; last by case: (sh1 ++ unm) D.
  case: (sh1 ++ unm) D=>[|c s D]; last by rewrite (freePtUn D).
  by rewrite freeU defU eq_refl; case/andP; move/negbTE=>-> _; rewrite free0.
rewrite [eval _ (cancel' _ _ _ _ _)]/=.
case: ifP=>H1 H2 D E; last first.
- apply: (IH _ _ _ _ D E).
  by rewrite H2 2!interp_cat 2!interp_cons unCA unA.
apply: IH=>//; last by apply: hfree_def.
rewrite -has_pred1 has_count in H1.
case H1: (count _ _) H1=>[//|[|n]] _; last first.
- have H3: count (pred1 sv) (vars sh2) > 1 by rewrite H1.
  move: (countN_varfree H3 D)=>/= H4.
  by rewrite (empty_hfree sh2 H4) H2 interp_cons /= H4 un0h.
move/(interp_perm i): (count1_hfree H1)=>H6.
rewrite -H6 cat_cons 2!interp_cons in H2.
rewrite -H6 interp_cons H2 in D.
by apply: (unhKr D H2).
Qed.

Lemma cancel_sound i t1 t2 :
        def (interp i t1) -> interp i t1 = interp i t2 ->
        eval i (cancel i t1 t2).
Proof. by move=>D H; apply: cancel_sound'=>//; rewrite -H // cats0. Qed.

