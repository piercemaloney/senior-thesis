

From mathcomp

Require Import ssreflect seq.

From LemmaOverloading

Require Import rels.
(* rels:
From mathcomp
Require Import ssreflect ssrfun ssrbool seq.
Require Import Setoid.
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Lemma andTp p : True /\ p <-> p.      Proof. by intuition. Qed.
Lemma andFp p : False /\ p <-> False. Proof. by intuition. Qed.
Lemma orTp p : True \/ p <-> True.    Proof. by intuition. Qed.
Lemma orFp p : False \/ p <-> p.      Proof. by intuition. Qed.

Delimit Scope rel_scope with rel.
Open Scope rel_scope.

Definition Pred T := T -> Prop.
Identity Coercion fun_of_Pred : Pred >-> Funclass.

Notation xPred0 := (fun _ => False).
Notation xPred1 := (fun x y => x = y).
Notation xPredT := (fun _ => True).
Notation xPredI := (fun (p1 p2 : Pred _) x => p1 x /\ p2 x).
Notation xPredU := (fun (p1 p2 : Pred _) x => p1 x \/ p2 x).
Notation xPredC := (fun (p : Pred _) x => ~ p x).
Notation xPredD := (fun (p1 p2 : Pred _) x => ~ p2 x /\ p1 x).
Notation xPreim := (fun f (p : Pred _) x => p (f x)).

Section Predicates.
Variable T : Type.

Definition Simpl_Pred := simpl_fun T Prop.
Definition SimplPred (p : Pred T) : Simpl_Pred := SimplFun p.
Coercion Pred_of_Simpl (p : Simpl_Pred) : Pred T := p : T -> Prop.

Definition Pred0 := SimplPred xPred0.
Definition Pred1 x := SimplPred (xPred1 x).
Definition PredT := SimplPred xPredT.
Definition PredI p1 p2 := SimplPred (xPredI p1 p2).
Definition PredU p1 p2 := SimplPred (xPredU p1 p2).
Definition PredC p := SimplPred (xPredC p).
Definition PredD p1 p2 := SimplPred (xPredD p1 p2).
Definition Preim rT f (d : Pred rT) := SimplPred (xPreim f d).

CoInductive Mem_Pred : Type := MemProp of Pred T.
Definition isMem pT toPred mem := mem = (fun p : pT => MemProp [eta toPred p]).

Structure PredType : Type := PropPredType {
  Pred_Sort :> Type;
  toPred : Pred_Sort -> Pred T;
  _ : {mem | isMem toPred mem}}.

Definition mkPredType pT toP := PropPredType (exist (@isMem pT toP) _ (erefl _)).

Canonical Structure PredPredType := Eval hnf in @mkPredType (Pred T) id.
Canonical Structure SimplPredPredType := Eval hnf in mkPredType Pred_of_Simpl.
Coercion Pred_of_Mem mp : Pred_Sort PredPredType :=
  let: MemProp p := mp in [eta p].
Canonical Structure MemPredType := Eval hnf in mkPredType Pred_of_Mem.
Canonical Structure predPredType := Eval hnf in @mkPredType (pred T) id.
Canonical Structure simplpredPredType :=
  Eval hnf in @mkPredType (simpl_pred T) (fun p x => p x).

End Predicates.

Arguments Pred0 {T}.
Arguments PredT {T}.
Prenex Implicits PredI PredU PredC PredD Preim.

Notation "r1 +p r2" := (PredU r1 r2)
  (at level 55, right associativity) : rel_scope.
Notation "r1 *p r2" := (PredI r1 r2)
  (at level 45, right associativity) : rel_scope.

Notation "[ 'Pred' : T | E ]" := (SimplPred (fun _ : T => E))
  (at level 0, format "[ 'Pred' :  T  |  E ]") : fun_scope.
Notation "[ 'Pred' x | E ]" := (SimplPred (fun x => E))
  (at level 0, x ident, format "[ 'Pred'  x  |  E ]") : fun_scope.
Notation "[ 'Pred' x : T | E ]" := (SimplPred (fun x : T => E))
  (at level 0, x ident, only parsing) : fun_scope.
Notation "[ 'Pred' x y | E ]" := (SimplPred (fun t => let: (x, y) := t in E))
  (at level 0, x ident, y ident, format "[ 'Pred'  x  y  |  E ]") : fun_scope.
Notation "[ 'Pred' x y : T | E ]" :=
  (SimplPred (fun t : (T*T) => let: (x, y) := t in E))
  (at level 0, x ident, y ident, only parsing) : fun_scope.

Definition repack_Pred T pT :=
  let: PropPredType _ a mP := pT return {type of @PropPredType T for pT} -> _ in
   fun k => k a mP.

Notation "[ 'PredType' 'of' T ]" := (repack_Pred (fun a => @PropPredType _ T a))
  (at level 0, format "[ 'PredType'  'of'  T ]") : form_scope.

Notation Pred_Class := (Pred_Sort (PredPredType _)).
Coercion Sort_of_Simpl_Pred T (p : Simpl_Pred T) : Pred_Class := p : Pred T.

Definition PredArgType := Type.
Coercion Pred_of_argType (T : PredArgType) : Simpl_Pred T := PredT.

Notation "{ :: T }" := (T%type : PredArgType)
  (at level 0, format "{ ::  T }") : type_scope.

Definition Mem T (pT : PredType T) : pT -> Mem_Pred T :=
  nosimpl (let: PropPredType _ _ (exist mem _) := pT return pT -> _ in mem).
Definition InMem T x mp := nosimpl Pred_of_Mem T mp x.

Prenex Implicits Mem.

Coercion Pred_of_Mem_Pred T mp := [Pred x : T | InMem x mp].

Definition EqPredType T (pT : PredType T) (p1 p2 : pT) :=
  forall x : T, toPred p1 x <-> toPred p2 x.

Definition SubPredType T (pT : PredType T) (p1 p2 : pT) :=
  forall x : T, toPred p1 x -> toPred p2 x.

Definition EqPred T (p1 p2 : Pred T) := EqPredType p1 p2.
Definition SubPred T (p1 p2 : Pred T) := SubPredType p1 p2.
Definition EqSimplPred T (p1 p2 : Simpl_Pred T) := EqPredType p1 p2.
Definition SubSimplPred T (p1 p2 : Simpl_Pred T) := SubPredType p1 p2.

Definition EqPredFun T1 T2 p1 p2 :=
  forall x : T1, @EqPred T2 (p1 x) (p2 x).
Definition SubPredFun T1 T2 p1 p2 :=
  forall x : T1, @SubPred T2 (p1 x) (p2 x).

Definition EqMem T p1 p2 := forall x : T, InMem x p1 <-> InMem x p2.
Definition SubMem T p1 p2 := forall x : T, InMem x p1 -> InMem x p2.

Notation "A <~> B" := (EqPred A B)
  (at level 70, no associativity) : rel_scope.
Notation "A ~> B" := (SubPred A B)
  (at level 70, no associativity) : rel_scope.
Notation "A <~1> B" := (EqPredFun A B)
  (at level 70, no associativity) : rel_scope.
Notation "A ~1> B" := (SubPredFun A B)
  (at level 70, no associativity) : rel_scope.

Notation "x \In A" := (InMem x (Mem A))
  (at level 70, no associativity) : rel_scope.
Notation "x \Notin A" := (~ (x \In A))
  (at level 70, no associativity) : rel_scope.
Notation "A =p B" := (EqMem (Mem A) (Mem B))
  (at level 70, no associativity) : type_scope.
Notation "A <=p B" := (SubMem (Mem A) (Mem B))
  (at level 70, no associativity) : type_scope.

Notation "[ 'Mem' A ]" := (Pred_of_Simpl (Pred_of_Mem_Pred (Mem A)))
  (at level 0, only parsing) : fun_scope.
Notation "[ 'PredI' A & B ]" := (PredI [Mem A] [Mem B])
  (at level 0, format "[ 'PredI'  A  &  B ]") : fun_scope.
Notation "[ 'PredU' A & B ]" := (PredU [Mem A] [Mem B])
  (at level 0, format "[ 'PredU'  A  &  B ]") : fun_scope.
Notation "[ 'PredD' A & B ]" := (PredD [Mem A] [Mem B])
  (at level 0, format "[ 'PredD'  A  &  B ]") : fun_scope.
Notation "[ 'PredC' A ]" := (PredC [Mem A])
  (at level 0, format "[ 'PredC'  A ]") : fun_scope.
Notation "[ 'Preim' f 'of' A ]" := (Preim f [Mem A])
  (at level 0, format "[ 'Preim'  f  'of'  A ]") : fun_scope.

Notation "[ 'Pred' x \In A ]" := [Pred x | x \In A]
  (at level 0, x ident, format "[ 'Pred'  x  \In  A ]") : fun_scope.
Notation "[ 'Pred' x \In A | E ]" := [Pred x | (x \In A) /\ E]
  (at level 0, x ident, format "[ 'Pred'  x  \In  A  |  E ]") : fun_scope.
Notation "[ 'Pred' x y \In A & B | E ]" :=
  [Pred x y | (x \In A) /\ (y \In B) /\ E]
  (at level 0, x ident, y ident,
   format "[ 'Pred'  x  y  \In  A  &  B  |  E ]") : fun_scope.
Notation "[ 'Pred' x y \In A & B ]" := [Pred x y | (x \In A) /\ (y \In B)]
  (at level 0, x ident, y ident,
   format "[ 'Pred'  x  y  \In  A  &  B ]") : fun_scope.
Notation "[ 'Pred' x y \In A | E ]" := [Pred x y \In A & A | E]
  (at level 0, x ident, y ident,
   format "[ 'Pred'  x  y  \In  A  |  E ]") : fun_scope.
Notation "[ 'Pred' x y \In A ]" := [Pred x y \In A & A]
  (at level 0, x ident, y ident,
   format "[ 'Pred'  x  y  \In  A ]") : fun_scope.

Section Simplifications.
Variables (T : Type) (pT : PredType T).

Lemma Mem_toPred : forall (p : pT), Mem (toPred p) = Mem p.

Lemma toPredE : forall x (p : pT), toPred p x = (x \In p).

Lemma In_Simpl : forall x (p : Simpl_Pred T), (x \In p) = p x.

Lemma Simpl_PredE : forall (p : Pred T), [Pred x | p x] <~> p.

Lemma Mem_Simpl : forall (p : Simpl_Pred T), Mem p = p :> Pred T.

Definition MemE := Mem_Simpl. 

Lemma Mem_Mem : forall p : pT, (Mem (Mem p) = Mem p) * (Mem [Mem p] = Mem p).

End Simplifications.

Section RelProperties.
Variables (T : Type) (pT : PredType T).

Lemma EqPredType_refl (r : pT) : EqPredType r r. Proof. by []. Qed.

Lemma EqPredType_sym (r1 r2 : pT) : EqPredType r1 r2 -> EqPredType r2 r1.

Lemma EqPredType_trans' (r1 r2 r3 : pT) :
  EqPredType r1 r2 -> EqPredType r2 r3 -> EqPredType r1 r3.

Lemma SubPredType_trans' (r1 r2 r3 : pT) :
  SubPredType r1 r2 -> SubPredType r2 r3 -> SubPredType r1 r3.

Definition EqPredType_trans r2 r1 r3 := @EqPredType_trans' r1 r2 r3.
Definition SubPredType_trans r2 r1 r3 := @SubPredType_trans' r1 r2 r3.

Section RelLaws.
Variable (T : Type).

Lemma orrI (r : Pred T) : r +p r <~> r.

Lemma orrC (r1 r2 : Pred T) : r1 +p r2 <~> r2 +p r1.

Lemma orr0 (r : Pred T) : r +p Pred0 <~> r.

Lemma or0r (r : Pred T) : Pred0 +p r <~> r.

Lemma orrCA (r1 r2 r3 : Pred T) : r1 +p r2 +p r3 <~> r2 +p r1 +p r3.

Lemma orrAC (r1 r2 r3 : Pred T) : (r1 +p r2) +p r3 <~> (r1 +p r3) +p r2.

Lemma orrA (r1 r2 r3 : Pred T) : (r1 +p r2) +p r3 <~> r1 +p r2 +p r3.

Lemma orrAb (r1 a : Pred T) : r1 <~> r1 +p a <-> a ~> r1.

Lemma sub_orl (r1 r2 : Pred T) : r1 ~> r1 +p r2. Proof. by left. Qed.

End RelLaws.

Section SubMemLaws.
Variable T : Type.

Lemma subp_refl (p : Pred T) : p <=p p.

Lemma subp_asym (p1 p2 : Pred T) : p1 <=p p2 -> p2 <=p p1 -> p1 =p p2.

Lemma subp_trans (p2 p1 p3 : Pred T) : p1 <=p p2 -> p2 <=p p3 -> p1 <=p p3.

Lemma subp_or (p1 p2 q : Pred T) : p1 <=p q /\ p2 <=p q <-> p1 +p p2 <=p q.

Lemma subp_and (p1 p2 q : Pred T) : q <=p p1 /\ q <=p p2 <-> q <=p p1 *p p2.

Lemma subp_orl (p1 p2 q : Pred T) : p1 <=p p2 -> p1 +p q <=p p2 +p q.

Lemma subp_orr (p1 p2 q : Pred T) : p1 <=p p2 -> q +p p1 <=p q +p p2.

Lemma subp_andl (p1 p2 q : Pred T) : p1 <=p p2 -> p1 *p q <=p p2 *p q.

Lemma subp_andr (p1 p2 q : Pred T) : p1 <=p p2 -> q *p p1 <=p q *p p2.

End SubMemLaws.

Hint Resolve subp_refl : core.

Section ListMembership.
Variable T : Type.

Fixpoint Mem_Seq (s : seq T) :=
  if s is y::s' then (fun x => x = y \/ Mem_Seq s' x) else xPred0.

Definition EqSeq_Class := seq T.
Identity Coercion seq_of_EqSeq : EqSeq_Class >-> seq.

Coercion Pred_of_Eq_Seq (s : EqSeq_Class) : Pred_Class := [eta Mem_Seq s].

Canonical Structure seq_PredType := @mkPredType T (seq T) Pred_of_Eq_Seq.

Canonical Structure Mem_Seq_PredType := mkPredType Mem_Seq.

Lemma In_cons : forall y s x, (x \In y :: s) <-> (x = y) \/ (x \In s).

Lemma In_nil : forall x, (x \In [::]) <-> False.

Lemma Mem_Seq1 : forall x y, (x \In [:: y]) <-> (x = y).

Definition InE := (Mem_Seq1, In_cons, In_Simpl).
Lemma eqfun_sym A B (f1 f2 : A -> B) : f1 =1 f2 -> f2 =1 f1.
Lemma eqfun_trans A B (f1 f2 f3 : A -> B) : f1 =1 f2 -> f2 =1 f3 -> f1 =1 f3.

Add Parametric Relation A B : (A -> B) (@eqfun _ _)
  reflexivity proved by (@eqfun_refl A B)
  symmetry proved by (@eqfun_sym A B)
  transitivity proved by (@eqfun_trans A B) as eqfun_morph. *)

Set Implicit Arguments.

Unset Strict Implicit.

Unset Printing Implicit Defensive.



Structure tagged_seq := TagS {untags :> seq Prop}.



Definition recurse := TagS.

Canonical Structure found (g : seq Prop) := recurse g.



Structure find (x : Prop) :=

  Find {seq_of :> tagged_seq;

        _ : x \In untags seq_of}.



Program Canonical Structure

  found_struct x g := @Find x (found (x :: g)) _.

Next Obligation. by rewrite InE; left. Qed.



Program Canonical Structure

  recurse_struct x y (g : find x) := @Find x (recurse (y :: g)) _.

Next Obligation. by rewrite InE /=; right; case: g. Qed.



Structure equate_to (x : Prop) := Equate {assign :> Prop}.



Canonical Structure singleton x := Equate x x.



Structure check (x : Prop) (g : seq Prop) :=

  Check {x_of :> equate_to x;

         _ : assign x_of \In g}.



Program  Canonical Structure

  start x (f : find x) := @Check x f (singleton x) _.

Next Obligation. by case: f=>[[]]. Qed.



Structure tagged_prop := Tag {untag :> Prop}.



Definition var_tag := Tag.

Definition all_tag := var_tag.

Definition imp_tag := all_tag.

Definition orL_tag := imp_tag.

Definition orR_tag := orL_tag.

Canonical Structure and_tag p := orR_tag p.



Structure form (g : seq Prop) :=

  Form {prop_of :> tagged_prop;

        _ : foldr and True g -> untag prop_of}.



Program Canonical Structure

  and_struct g (p1 p2 : form g) :=

  @Form g (@and_tag (p1 /\ p2)) _.

Next Obligation.

case: p1 p2=>[[p1]] H1 [[p2]] H2.

by split; [apply: H1 | apply: H2]; apply: H.

Qed.



Program Canonical Structure

  orL_struct g (p1 : form g) (p2 : Prop) :=

  @Form g (@orL_tag (p1 \/ p2)) _.

Next Obligation. by case: p1=>[[p1]] H1; left; apply: H1 H. Qed.



Program Canonical Structure

  orR_struct g (p1 : Prop) (p2 : form g) :=

  @Form g (@orR_tag (p1 \/ p2)) _.

Next Obligation. by case: p2=>[[p2]] H2; right; apply: H2 H. Qed.



Program Canonical Structure

  imp_struct g (p : Prop) (q : form (p :: g)) :=

  @Form g (@imp_tag (p -> q)) _.

Next Obligation. by case: q=>[[q]] H1; apply: H1. Qed.



Program Canonical Structure

  all_struct A g (p : A -> form g) :=

  @Form g (@all_tag (forall x, p x)) _.

Next Obligation. by case: (p x)=>[[q]]; apply. Qed.



Program Canonical Structure

  var_struct x g (c : check x g) :=

  @Form g (@var_tag c) _ .

Next Obligation.

case: c=>[[p]] /=; elim: g H=>[//|t s IH] /=.

case=>H1 H2; rewrite InE /=.

by case; [move=>-> | apply: IH H2].

Qed.



Lemma auto (p : form [::]) : untag p.

Proof. by case: p=>[[s]] H; apply: H. Qed.



Example ex1 (p : Prop) : p -> p.

Proof. by apply: auto. Qed.



Example ex2 (p : nat -> Prop) : (forall x, p x) -> (forall x, p x).

Proof. by apply: auto. Qed.



Example ex3 (p : Prop) : p -> p /\ p.

Proof. by apply: auto. Qed.



Example ex4 (p q : Prop) : p -> p /\ q.

Proof. try apply: auto. Abort.



Example ex5 (p q : Prop) : p -> p \/ q.

Proof. by apply: auto. Qed.



Example ex6 (p q : Prop) : p -> q \/ p.

Proof. by apply: auto. Qed.



Example ex7 (p q : nat -> Prop) : forall x:nat, p x -> p x \/ q x.

Proof. by apply: auto. Qed.



Example ex8 (p q : nat -> Prop) : forall x, p x -> q x -> p x /\ q x.

Proof. by apply: auto. Qed.



Example ex9 (p : nat -> Prop) : (forall x, p x) -> p 3.

Proof. try apply: auto. Abort.

