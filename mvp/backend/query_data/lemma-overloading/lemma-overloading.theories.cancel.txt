

From mathcomp

Require Import ssreflect ssrfun ssrbool ssrnat seq eqtype.

From LemmaOverloading

Require Import prelude prefix xfind heaps terms.
(* prelude:
From mathcomp
Require Import ssreflect ssrbool eqtype ssrfun seq.
Require Import Eqdep ClassicalFacts.
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Axiom pext : forall p1 p2 : Prop, (p1 <-> p2) -> p1 = p2.
Axiom fext : forall A (B : A -> Type) (f1 f2 : forall x, B x),
               (forall x, f1 x = f2 x) -> f1 = f2.

Lemma proof_irrelevance (P : Prop) (p1 p2 : P) : p1 = p2.

Lemma eta A (B : A -> Type) (f : forall x, B x) : f = [eta f].

Lemma ext A (B : A -> Type) (f1 f2 : forall x, B x) :
        f1 = f2 -> forall x, f1 x = f2 x.

Ltac add_morphism_tactic := SetoidTactics.add_morphism_tactic.
Notation " R ===> R' " := (@Morphisms.respectful _ _ R R')
  (right associativity, at level 55) : signature_scope.

Definition inj_pair2 := @inj_pair2.
Arguments inj_pair2 {U P p x y}.

Lemma inj_sval A P : injective (@sval A P).

Lemma svalE A (P : A -> Prop) x H : sval (exist P x H) = x.

Lemma sym A (x y : A) : x = y <-> y = x.

Section HasSelect.
Variables (A : eqType) (p : pred A).

CoInductive has_spec (s : seq A) : bool -> Type :=
| has_true x of x \in s & p x : has_spec s true
| has_false of (all (predC p) s) : has_spec s false.

Lemma hasPx : forall s, has_spec s (has p s).

End HasSelect.

Module Dyn.
Record dynamic : Type := dyn {typ : Type; val : typ}.
End Dyn.

Notation dynamic := Dyn.dynamic.
Notation dyn := Dyn.dyn.

Lemma dyn_inj A (x y : A) : dyn x = dyn y -> x = y.

Lemma dyn_eta d : d = dyn (Dyn.val d).

Lemma dyn_injT A1 A2 (x1 : A1) (x2 : A2) : dyn x1 = dyn x2 -> A1 = A2.

Prenex Implicits dyn_inj dyn_injT.

Section Coercions.
Variable (T : Type -> Type).

Definition coerce A B (x : T A) : A = B -> T B := [eta eq_rect A [eta T] x B].

Lemma eqc A (x : T A) (pf : A = A) : coerce x pf = x.

Definition jmeq A B (x : T A) (y : T B) := forall pf, coerce x pf = y.

Lemma jmE A (x y : T A) : jmeq x y <-> x = y.

Lemma jmeq_refl A (x : T A) : jmeq x x.

End Coercions.

Hint Resolve jmeq_refl : core.
Arguments jmeq T [A B] x y.
Notation "a =jm b" := (jmeq id a b) (at level 50).

Lemma contV B (P : B -> B -> Prop) :
        (forall x x', x =jm x' -> P x x') <-> forall x, P x x.

Lemma contVT B (P : B -> B -> Prop) :
        (forall x x', B = B -> x =jm x' -> P x x') <-> forall x, P x x.

Section Coercions2.
Variable (T : Type -> Type -> Type).

Program
Definition coerce2 A1 A2 B1 B2 (x : T A1 A2) :
             (A1, A2) = (B1, B2) -> T B1 B2.

Lemma eqc2 A1 A2 (x : T A1 A2) (pf : (A1, A2) = (A1, A2)) :
        coerce2 x pf = x.

Definition jmeq2 A1 A2 B1 B2 (x : T A1 B1) (y : T A2 B2) :=
             forall pf, coerce2 x pf = y.

Lemma jm2E A B (x y : T A B) : jmeq2 x y <-> x = y.

Lemma refl_jmeq2 A B (x : T A B) : jmeq2 x x.

End Coercions2.

Hint Resolve refl_jmeq2 : core.
Arguments jmeq2 T [A1 A2 B1 B2] x y.

Lemma compA A B C D (h : A -> B) (g : B -> C) (f : C -> D) :
        (f \o g) \o h = f \o (g \o h).

Lemma compf1 A B (f : A -> B) : f = f \o id.

Lemma comp1f A B (f : A -> B) : f = id \o f.

Definition fprod A1 A2 B1 B2 (f1 : A1 -> B1) (f2 : A2 -> B2) :=
  fun (x : A1 * A2) => (f1 x.1, f2 x.2).

Notation "f1 \* f2" := (fprod f1 f2) (at level 45).

Section Reorder.
Variables (A B C : Type).

Definition swap (x : A * B) :=
  let: (x1, x2) := x in (x2, x1).
Definition rCA (x : A * (B * C)) :=
  let: (x1, (x2, x3)) := x in (x2, (x1, x3)).
Definition rAC (x : (A * B) * C) :=
  let: ((x1, x2), x3) := x in ((x1, x3), x2).
Definition rA (x : A * (B * C)) :=
  let: (x1, (x2, x3)) := x in ((x1, x2), x3).
Definition iA (x : (A * B) * C) :=
  let: ((x1, x2), x3) := x in (x1, (x2, x3)).
Definition pL (x : A * B) :=
  let: (x1, x2) := x in x1.
Definition pR (x : A * B) :=
  let: (x1, x2) := x in x2.
End Reorder.

Prenex Implicits swap rCA rAC rA iA pL pR.

Lemma swapI A B : swap \o swap = @id (A * B).

Lemma rCAI A B C : rCA \o (@rCA A B C) = id.

Lemma rACI A B C : rAC \o (@rAC A B C) = id.

Lemma riA A B C : rA \o (@iA A B C) = id.

Lemma irA A B C : iA \o (@rA A B C) = id.

Lemma swap_prod A1 B1 A2 B2 (f1 : A1 -> B1) (f2 : A2 -> B2) :
        swap \o f1 \* f2 = f2 \* f1 \o swap.

Lemma swap_rCA A B C : swap \o (@rCA A B C) = rAC \o rA.

Lemma swap_rAC A B C : swap \o (@rAC A B C) = rCA \o iA.

Ltac rfe1 x1 := let H := fresh "H" in move=>H; move:H x1=>-> x1.
Ltac rfe2 x1 x2 := let H := fresh "H" in move=>H; move:H x1 x2=>-> x1 x2.
Ltac rfjm := move/jmE=>->.
Ltac rfejm1 x1 := rfe1 x1; rfjm.
Ltac rfejm2 x1 x2 := rfe2 x1 x2; rfjm.
Ltac rfp := move/inj_pair2=>->.
Ltac rfep1 x1 := rfe1 x1; rfp.
Ltac rfep2 x1 x2 := rfe1 x2; rfp.

Ltac rbe1 x1 := let H := fresh "H" in move=>H; move:H x1=><- x1.
Ltac rbe2 x1 x2 := let H := fresh "H" in move=>H; move:H x1 x2=><- x1 x2.
Ltac rbjm := move/jmE=><-.
Ltac rbejm1 x1 := rbe1 x1; rbjm.
Ltac rbejm2 x1 x2 := rbe2 x1 x2; rbjm.
Ltac rbp := move/inj_pair2=><-.
Ltac rbep1 x1 := rbe1 x1; rbp.
Ltac rbep2 x1 x2 := rbe1 x2; rbp.

Reserved Notation "[ /\ P1 , P2 , P3 , P4 , P5 & P6 ]" (at level 0, format
  "'[hv' [ /\ '['  P1 , '/'  P2 , '/'  P3 , '/'  P4 , '/'  P5 ']' '/ '  &  P6 ] ']'").

Reserved Notation "[ \/ P1 , P2 , P3 , P4 & P5 ]" (at level 0, format
  "'[hv' [ \/ '['  P1 , '/'  P2 , '/'  P3 , '/'  P4 ']' '/ '  &  P5 ] ']'").
Reserved Notation "[ \/ P1 , P2 , P3 , P4 , P5 & P6 ]" (at level 0, format
  "'[hv' [ \/ '['  P1 , '/'  P2 , '/'  P3 , '/'  P4 , '/'  P5 ']' '/ '  &  P6 ] ']'").

Inductive and6 (P1 P2 P3 P4 P5 P6 : Prop) : Prop :=
  And6 of P1 & P2 & P3 & P4 & P5 & P6.

Inductive or5 (P1 P2 P3 P4 P5 : Prop) : Prop :=
  Or51 of P1 | Or52 of P2 | Or53 of P3 | Or54 of P4 | Or55 of P5.
Inductive or6 (P1 P2 P3 P4 P5 P6 : Prop) : Prop :=
  Or61 of P1 | Or62 of P2 | Or63 of P3 | Or64 of P4 | Or65 of P5 | Or66 of P6.

Notation "[ /\ P1 , P2 , P3 , P4 , P5 & P6 ]" := (and6 P1 P2 P3 P4 P5 P6) : type_scope.
Notation "[ \/ P1 , P2 , P3 , P4 | P5 ]" := (or5 P1 P2 P3 P4 P5) : type_scope.
Notation "[ \/ P1 , P2 , P3 , P4 , P5 | P6 ]" := (or6 P1 P2 P3 P4 P5 P6) : type_scope.

Section ReflectConnectives.

Variable b1 b2 b3 b4 b5 b6 : bool.
Lemma and6P : reflect [/\ b1, b2, b3, b4, b5 & b6] [&& b1, b2, b3, b4, b5 & b6].

Lemma or5P : reflect [\/ b1, b2, b3, b4 | b5] [|| b1, b2, b3, b4 | b5].

Lemma or6P : reflect [\/ b1, b2, b3, b4, b5 | b6] [|| b1, b2, b3, b4, b5 | b6].

End ReflectConnectives.

Arguments and6P {b1 b2 b3 b4 b5 b6}.
Arguments or5P {b1 b2 b3 b4 b5}.
Arguments or6P {b1 b2 b3 b4 b5 b6}. *)
(* prefix:
From mathcomp
Require Import ssreflect ssrfun ssrbool ssrnat seq.
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Section Prefix.
Variable A : Type.

Fixpoint onth (s : seq A) n : option A :=
  if s is x :: s' then
    if n is n'.+1 then onth s' n' else Some x
  else None.

Definition prefix s1 s2 :=
  forall n x, onth s1 n = some x -> onth s2 n = some x.

Lemma size_onth (s : seq A) n : n < size s -> exists x, onth s n = Some x.

Lemma onth_size (s : seq A) n x : onth s n = Some x -> n < size s.

Lemma prefix_refl s : prefix s s.

Lemma prefix_trans (s2 s1 s3 : seq A) :
        prefix s1 s2 -> prefix s2 s3 -> prefix s1 s3.

Lemma prefix_cons x s1 s2 : prefix (x :: s1) (x :: s2) <-> prefix s1 s2.

Lemma prefix_cons' x y s1 s2 : prefix (x :: s1) (y :: s2) -> x = y /\ prefix s1 s2.

Lemma prefix_size (s t : seq A) : prefix s t -> size s <= size t.

Lemma prefix_onth (s t : seq A) x : x < size s -> prefix s t -> onth s x = onth t x.

End Prefix.

Hint Resolve prefix_refl : core. *)
(* xfind:
From mathcomp
Require Import ssreflect ssrnat seq.
From LemmaOverloading
Require Import prefix.
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Section XFind.

Variable A : Type.

Definition invariant s r i (e : A) := onth r i = Some e /\ prefix s r.

Structure xtagged := XTag {xuntag :> A}.

Definition extend_tag := XTag.
Definition recurse_tag := extend_tag.
Canonical Structure found_tag x := recurse_tag x.

Structure xfind (s r : seq A) (i : nat) := XFind {
  elem_of :> xtagged;
  _ : invariant s r i elem_of}.

Arguments XFind : clear implicits.

Lemma found_pf x t : invariant (x :: t) (x :: t) 0 x.

Canonical Structure found_struct x t :=
  XFind (x :: t) (x :: t) 0 (found_tag x) (found_pf x t).

Lemma recurse_pf (i : nat) (y : A) (s r : seq A) (f : xfind s r i) :
        invariant (y :: s) (y :: r) i.+1 f.

Canonical Structure recurse_struct i y t r (f : xfind t r i) :=
  XFind (y :: t) (y :: r) i.+1 (recurse_tag f) (recurse_pf y f).

Lemma extend_pf x : invariant [::] [:: x] 0 x.

Canonical Structure extend_struct x :=
  XFind [::] [:: x] 0 (extend_tag x) (extend_pf x).

End XFind.

Lemma findme A (r s : seq A) i (f : xfind r s i) : onth s i = Some (xuntag (elem_of f)).

Set Printing Implicit.
Print test.

Example unit_test : forall A (x1 x2 x3 x y : A),
   (forall s r i (f : xfind s r i), nth x1 r i = xuntag f -> xuntag f = x) ->
  x = x.
Proof.
move=>A x1 x2 x3 x y test_form.
apply: (test_form [::]). simpl.
apply: (test_form [:: x1; x]). simpl.
apply: (test_form [:: x1; x2; x; x3]). simpl.
apply: (test_form [:: x1; x2; x3]). simpl.
Abort. *)
(* heaps:
From mathcomp
Require Import ssreflect ssrfun ssrnat div ssrbool seq.
From LemmaOverloading
Require Import prelude finmap ordtype.
From mathcomp
Require Import path eqtype.
Require Import Eqdep.
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Notation eqn_addl := eqn_add2l.
Notation modn_addl := modnDl.
Notation modn_mulr := modnMr.
Notation modn_add2m := modnDm.
Notation modn_addr := modnDr.

Inductive ptr := ptr_nat of nat.

Definition null := ptr_nat 0.

Definition nat_ptr (x : ptr) := let: ptr_nat y := x in y.

Definition eq_ptr (x y : ptr) :=
  match x, y with ptr_nat m, ptr_nat n => m == n end.

Lemma eq_ptrP : Equality.axiom eq_ptr.

Definition ptr_eqMixin := EqMixin eq_ptrP.
Canonical Structure ptr_eqType := EqType ptr ptr_eqMixin.

Definition ptr_offset x i := ptr_nat (nat_ptr x + i).

Notation "x .+ i" := (ptr_offset x i)
  (at level 3, format "x .+ i").

Lemma ptrE x y : (x == y) = (nat_ptr x == nat_ptr y).

Lemma ptr0 x : x.+0 = x.

Lemma ptrA x i j : x.+i.+j = x.+(i+j).

Lemma ptrK x i j : (x.+i == x.+j) = (i == j).

Lemma ptr_null x m : (x.+m == null) = (x == null) && (m == 0).

Lemma ptrT x y : {m : nat | (x == y.+m) || (y == x.+m)}.

Definition ltn_ptr (x y : ptr) :=
  match x, y with ptr_nat m, ptr_nat n => m < n end.

Lemma ltn_ptr_irr : irreflexive ltn_ptr.

Lemma ltn_ptr_trans : transitive ltn_ptr.

Lemma ltn_ptr_total : forall x y : ptr, [|| ltn_ptr x y, x == y | ltn_ptr y x].

Definition ptr_ordMixin := OrdMixin ltn_ptr_irr ltn_ptr_trans ltn_ptr_total.
Canonical Structure ptr_ordType := OrdType ptr ptr_ordMixin.

Inductive heap :=
  Undef | Def (finmap : {finMap ptr -> dynamic}) of
               null \notin supp finmap.

Section NullLemmas.
Variables (f g : {finMap ptr -> dynamic}) (x : ptr) (d : dynamic).

Lemma upd_nullP :
        x != null -> null \notin supp f -> null \notin supp (ins x d f).

Lemma free_nullP : null \notin supp f -> null \notin supp (rem x f).

Lemma un_nullP :
        null \notin supp f -> null \notin supp g ->
          null \notin supp (fcat f g).

Lemma heapE pf pg : f = g <-> @Def f pf = @Def g pg.

End NullLemmas.

Definition def h := if h is Def _ _ then true else false.

Definition empty := @Def (finmap.nil _ _) is_true_true.

Definition upd h x d := nosimpl
  (if h is Def hs ns then
    if decP (@idP (x != null)) is left pf then
      Def (@upd_nullP _ _ d pf ns)
    else Undef
  else Undef).

Definition dom h : pred ptr := nosimpl
  (if h is Def f _ then mem (supp f) else pred0).

Definition free x h : heap :=
  (if h is Def hs ns then Def (free_nullP x ns) else Undef).

Definition look (x : ptr) h :=
  (if h is Def hs _ then
    if fnd x hs is Some d then d else dyn tt
  else dyn tt).

Definition union2 h1 h2 := nosimpl
  (if (h1, h2) is (Def hs1 ns1, Def hs2 ns2) then
     if disj hs1 hs2 then
        Def (@un_nullP _ _ ns1 ns2)
     else Undef
  else Undef).

Definition empb h :=
  if h is Def hs _ then supp hs == [::] else false.

Definition fresh h :=
  (if h is Def hs _ then last null (supp hs) else null) .+ 1.

Definition subdom h1 h2 :=
  if (h1, h2) is (Def hs1 _, Def hs2 _) then
    all (fun x => x \in supp hs2) (supp hs1)
  else false.

Definition subheap h1 h2 :=
  subdom h1 h2 /\ forall x, x \in dom h1 -> look x h1 = look x h2.

Definition subtract h1 h2 :=
  if h1 is (Def hs1 _) then
    foldl (fun h x => free x h) h2 (supp hs1)
  else Undef.

Definition pick h :=
  if h is Def hs _ then head null (supp hs) else null.

Definition pts A (x : ptr) (v : A) := upd empty x (dyn v).

Notation "h1 :+ h2" := (union2 h1 h2) (at level 43, left associativity).
Notation "h2 :- h1" := (subtract h1 h2) (at level 43, left associativity).
Notation "x :-> v" := (pts x v) (at level 30).

Lemma unC : forall h1 h2, h1 :+ h2 = h2 :+ h1.

Lemma unA : forall h1 h2 h3, h1 :+ (h2 :+ h3) = h1 :+ h2 :+ h3.

Lemma unCA h1 h2 h3 : h1 :+ (h2 :+ h3) = h2 :+ (h1 :+ h3).

Lemma unAC h1 h2 h3 : h1 :+ h2 :+ h3 = h1 :+ h3 :+ h2.

Lemma un0h h : empty :+ h = h.

Lemma unh0 h : h :+ empty = h.

Lemma unKhl h h1 h2 : def (h1 :+ h) -> h1 :+ h = h2 :+ h -> h1 = h2.

Lemma unhKl h h1 h2 : def (h :+ h1) -> h :+ h1 = h :+ h2 -> h1 = h2.

Lemma unKhr h h1 h2 : def (h2 :+ h) -> h1 :+ h = h2 :+ h -> h1 = h2.

Lemma unhKr h h1 h2 : def (h :+ h2) -> h :+ h1 = h :+ h2 -> h1 = h2.

Lemma dom0 : dom empty = pred0.

Lemma domU h y d :
        dom (upd h y d) =i
        [pred x | (y != null) && if x == y then def h else x \in dom h].

Lemma domPt A x (v : A) : dom (x :-> v) =i [pred y | (x == y) && (x != null)].

Lemma domF h x :
        dom (free x h) =i [pred y | if x == y then false else y \in dom h].

Lemma domUn h1 h2 :
        dom (h1 :+ h2) =i
        [pred x | def (h1 :+ h2) && (x \in [predU dom h1 & dom h2])].

Lemma dom_null h x : x \in dom h -> x != null.

Lemma dom_def h x : x \in dom h -> def h.

Lemma dom_free h x : x \notin dom h -> free x h = h.

Lemma dom_look h x : x \notin dom h -> look x h = dyn tt.

Lemma def0 : def empty.

Hint Resolve def0 : core.

Lemma defU h x d : def (upd h x d) = (x != null) && (def h).

Lemma defPt A x (v : A) : def (x :-> v) = (x != null).

Lemma defF h x : def (free x h) = def h.

CoInductive defUn_spec h1 h2 : bool -> Type :=
| def_false1 of ~~ def h1 : defUn_spec h1 h2 false
| def_false2 of ~~ def h2 : defUn_spec h1 h2 false
| def_false3 x of x \in dom h1 & x \in dom h2 : defUn_spec h1 h2 false
| def_true of def h1 & def h2 &
    (forall x, x \in dom h1 -> x \notin dom h2) : defUn_spec h1 h2 true.

Lemma defUn : forall h1 h2, defUn_spec h1 h2 (def (h1 :+ h2)).

Lemma defUnl h1 h2 : def (h1 :+ h2) -> def h1.

Lemma defUnr h1 h2 : def (h1 :+ h2) -> def h2.

Lemma defFUn h1 h2 x : def (h1 :+ h2) -> def (free x h1 :+ h2).

Lemma defUnF h1 h2 x : def (h1 :+ h2) -> def (h1 :+ free x h2).

Lemma undefE x : ~~ def x <-> x = Undef.

Lemma upd_inj h x d1 d2 :
        def h -> x != null -> upd h x d1 = upd h x d2 -> d1 = d2.

Lemma heap_eta h x : x \in dom h -> h = upd (free x h) x (look x h).

Lemma updU h x y d1 d2 :
        upd (upd h x d1) y d2 =
        if x == y then upd h x d2 else upd (upd h y d2) x d1.

Lemma updF h x y d :
        upd (free x h) y d =
        if x == y then upd h x d else free x (upd h y d).

Lemma updUnl h1 h2 x d :
        upd (h1 :+ h2) x d =
        if x \in dom h1 then upd h1 x d :+ h2 else h1 :+ upd h2 x d.

Lemma updUnr h1 h2 x d :
        upd (h1 :+ h2) x d =
        if x \in dom h2 then h1 :+ upd h2 x d else upd h1 x d :+ h2.

Lemma pts_injP A1 A2 x1 x2 (v1 : A1) (v2 : A2) :
        def (x1 :-> v1) -> x1 :-> v1 = x2 :-> v2 -> x1 = x2 /\ A1 = A2.

Lemma pts_injT A1 A2 x (v1 : A1) (v2 : A2) :
        def (x :-> v1) -> x :-> v1 = x :-> v2 -> A1 = A2.

Lemma pts_inj A x (v1 v2 : A) :
        def (x :-> v1) -> x :-> v1 = x :-> v2 -> v1 = v2.

Lemma free0 x : free x empty = empty.

Lemma freeU h x y d :
        free x (upd h y d) = if x == y then
          if y == null then Undef else free x h
        else upd (free x h) y d.

Lemma freeF h x y :
        free x (free y h) = if x == y then free x h else free y (free x h).

Lemma freeUn h1 h2 x :
        free x (h1 :+ h2) =
        if x \in dom (h1 :+ h2) then free x h1 :+ free x h2
        else h1 :+ h2.

Lemma freeUnD h1 h2 x :
        def (h1 :+ h2) -> free x (h1 :+ h2) = free x h1 :+ free x h2.

Lemma freeUnl h1 h2 x : x \notin dom h1 -> free x (h1 :+ h2) = h1 :+ free x h2.

Lemma freeUnr h1 h2 x : x \notin dom h2 -> free x (h1 :+ h2) = free x h1 :+ h2.

Lemma lookU h x y d :
        look x (upd h y d) = if x == y then
          if def h && (y != null) then d else dyn tt
        else if y != null then look x h else dyn tt.

Lemma lookF h x y :
        look x (free y h) = if x == y then dyn tt else look x h.

Lemma lookUnl h1 h2 x :
        def (h1 :+ h2) ->
        look x (h1 :+ h2) = if x \in dom h1 then look x h1 else look x h2.

Lemma lookUnr h1 h2 x :
        def (h1 :+ h2) ->
        look x (h1 :+ h2) = if x \in dom h2 then look x h2 else look x h1.

Lemma empP h : reflect (h = empty) (empb h).

Lemma empU h x d : empb (upd h x d) = false.

Lemma empPt A x (v : A) : empb (x :-> v) = false.

Lemma empUn h1 h2 : empb (h1 :+ h2) = empb h1 && empb h2.

Lemma empbE h : h = empty <-> empb h.

Lemma un0E h1 h2 : h1 :+ h2 = empty <-> h1 = empty /\ h2 = empty.

Lemma defE h : reflect (def h /\ forall x, x \notin dom h)(empb h).

Lemma defUnhh h : def (h :+ h) = empb h.

Lemma path_last n s x : path ord x s -> ord x (last x s).+(n+1).

Lemma path_filter (A : ordType) (s : seq A) (p : pred A) x :
        path ord x s -> path ord x (filter p s).

Lemma dom_fresh h n : (fresh h).+n \notin dom h.

Lemma fresh_null h : fresh h != null.

Opaque fresh.

Hint Resolve dom_fresh fresh_null : core.

Lemma emp_pick h : (pick h == null) = (~~ def h || empb h).

Lemma pickP h : def h && ~~ empb h = (pick h \in dom h).

Lemma subdom_def h1 h2 : subdom h1 h2 -> def h1 && def h2.

Lemma subdomP h1 h2 :
        def h1 -> ~~ empb h1 ->
        reflect (forall x, x \in dom h1 -> x \in dom h2)
                (subdom h1 h2).

Lemma subdomQ x h1 h2 : subdom h1 h2 -> x \in dom h1 -> x \in dom h2.

Lemma subdom_refl h : def h -> subdom h h.

Lemma subdomD h1 h2 h : subdom h1 h2 -> def (h2 :+ h) -> def (h1 :+ h).

Lemma subdomE h1 h2 h :
        def (h2 :+ h) -> subdom h1 h2 -> subdom (h1 :+ h) (h2 :+ h).

Lemma subdomUE h1 h2 h1' h2' :
        def (h2 :+ h2') -> subdom h1 h2 -> subdom h1' h2' ->
          subdom (h1 :+ h1') (h2 :+ h2').

Lemma subdom_emp h : def h -> subdom empty h.

Lemma subdom_emp_inv h : subdom h empty -> h = empty.

Lemma subdomPE A B x (v1 : A) (v2 : B) :
        x != null -> subdom (x :-> v1) (x :-> v2).

Lemma subdom_trans h2 h1 h3 : subdom h1 h2 -> subdom h2 h3 -> subdom h1 h3.

Hint Resolve subdom_emp subdomPE : core.

Lemma subheap_refl h : def h -> subheap h h.

Lemma subheapE h : def h -> subheap empty h.

Lemma subheapUn h1 h2 h1' h2' :
        def (h2 :+ h2') -> subheap h1 h2 -> subheap h1' h2' ->
        subheap (h1 :+ h1') (h2 :+ h2').

Lemma subheapUnl h1 h2 : def (h1 :+ h2) -> subheap h1 (h1 :+ h2).

Lemma subheapUnr h1 h2 : def (h1 :+ h2) -> subheap h2 (h1 :+ h2).

Lemma subheap_def h1 h2 : subheap h1 h2 -> def h1 /\ def h2.

Lemma subheap_trans h2 h1 h3 : subheap h1 h2 -> subheap h2 h3 -> subheap h1 h3.

Lemma subheap_id hp1 hp2: subheap hp1 hp2 -> subheap hp2 hp1 -> hp1 = hp2.

Lemma noalias h1 h2 x1 x2 :
        x1 \in dom h1 -> x2 \in dom h2 -> def (h1 :+ h2) -> x1 != x2.

Lemma defPtUn A h x (v : A) :
        def (x :-> v :+ h) = [&& x != null, def h & x \notin dom h].

Lemma defPt_null A h x (v : A) : def (x :-> v :+ h) -> x != null.

Lemma defPt_def A h x (v : A) : def (x :-> v :+ h) -> def h.

Lemma defPt_dom A h x (v : A) : def (x :-> v :+ h) -> x \notin dom h.

Lemma domPtUn A h x (v : A) :
        dom (x :-> v :+ h) =i
        [pred y | def (x :-> v :+ h) && ((x == y) || (y \in dom h))].

Lemma lookPtUn A h x (v : A) :
        def (x :-> v :+ h) -> look x (x :-> v :+ h) = dyn v.

Lemma freePtUn A h x (v : A) :
        def (x :-> v :+ h) -> free x (x :-> v :+ h) = h.

Lemma updPtUn A1 A2 x i (v1 : A1) (v2 : A2) :
        upd (x :-> v1 :+ i) x (dyn v2) = x :-> v2 :+ i.

Lemma heap_etaP h x : x \in dom h -> h = x :-> Dyn.val (look x h) :+ free x h.

Lemma cancelT A1 A2 h1 h2 x (v1 : A1) (v2 : A2) :
        def (x :-> v1 :+ h1) ->
          x :-> v1 :+ h1 = x :-> v2 :+ h2 -> A1 = A2.

Lemma cancel A h1 h2 x (v1 v2 : A) :
        def (x :-> v1 :+ h1) ->
        x :-> v1 :+ h1 = x :-> v2 :+ h2 -> [/\ v1 = v2, def h1 & h1 = h2].

Lemma domPtUnX A (v : A) x i : def (x :-> v :+ i) -> x \in dom (x :-> v :+ i).

Lemma domPtX A (v : A) x : def (x :-> v) -> x \in dom (x :-> v).

Lemma dom_notin_notin h1 h2 x :
        def (h1 :+ h2) -> x \notin dom (h1 :+ h2) -> x \notin dom h1.

Lemma dom_in_notin h1 h2 x : def (h1 :+ h2) -> x \in dom h1 -> x \notin dom h2.

Section BlockUpdate.
Variable (A : Type).

Fixpoint updi x (vs : seq A) {struct vs} : heap :=
  if vs is v'::vs' then (x :-> v') :+ updi (x .+ 1) vs' else empty.

Lemma updiS x v vs : updi x (v :: vs) = x :-> v :+ updi (x .+ 1) vs.

Lemma updi_last x v vs :
        updi x (rcons vs v) = updi x vs :+ x.+(size vs) :-> v.

Lemma updi_cat x vs1 vs2 :
        updi x (vs1 ++ vs2) = updi x vs1 :+ updi x.+(size vs1) vs2.

Lemma updi_catI x y vs1 vs2 :
        y = x.+(size vs1) -> updi x vs1 :+ updi y vs2 = updi x (vs1 ++ vs2).

Lemma updiVm' x m xs : m > 0 -> x \notin dom (updi x.+m xs).

Lemma updiD x xs : def (updi x xs) = (x != null) || (size xs == 0).

Lemma updiVm x m xs :
        x \in dom (updi x.+m xs) = [&& x != null, m == 0 & size xs > 0].

Lemma updimV x m xs :
        x.+m \in dom (updi x xs) = (x != null) && (m < size xs).

Lemma updiP x y xs :
        reflect (y != null /\ exists m, x = y.+m /\ m < size xs)

Lemma updi_inv x xs1 xs2 :
        def (updi x xs1) -> updi x xs1 = updi x xs2 -> xs1 = xs2.

Lemma updi_iinv x xs1 xs2 h1 h2 :
        size xs1 = size xs2 -> def (updi x xs1 :+ h1) ->
        updi x xs1 :+ h1 = updi x xs2 :+ h2 -> xs1 = xs2 /\ h1 = h2.

End BlockUpdate.

Definition low : pred ptr := fun x => 0 == nat_ptr x %[mod 2].
Definition high : pred ptr := fun x => 1 == nat_ptr x %[mod 2].

Definition get_lows h :=
  if h is Def hs _ then filter low (supp hs) else [::].

Definition get_highs h :=
  if h is Def hs _ then filter high (supp hs) else [::].

Definition ldom h : pred ptr := fun x => x \in get_lows h.
Definition hdom h : pred ptr := fun x => x \in get_highs h.

Lemma ldomP h x : x \in ldom h = (x \in dom h) && low x.

Lemma hdomP h x : x \in hdom h = (x \in dom h) && high x.

Lemma ldomK h1 h2 t1 t2 :
        def (h1 :+ t1) -> def (h2 :+ t2) ->
        ldom h1 =i ldom h2 ->
        ldom (h1 :+ t1) =i ldom (h2 :+ t2) -> ldom t1 =i ldom t2.

Definition lfresh h := (last null (get_lows h)) .+ 2.
Definition hfresh h := (last (null .+ 1) (get_highs h)) .+ 2.

Lemma last_inv A B (f : A -> B) (x1 x2 : A) (h : seq A) :
        f x1 = f x2 -> f (last x1 h) = f (last x2 h).

Lemma lfresh_low h n : low (lfresh h) .+ (2*n).

Lemma hfresh_high h n : high (hfresh h) .+ (2*n).

Lemma dom_lfresh h n : (lfresh h) .+ (2*n) \notin dom h.

Lemma dom_hfresh h n : (hfresh h) .+ (2*n) \notin dom h.

Lemma lfresh_null h : lfresh h != null.

Lemma hfresh_null h : hfresh h != null.

Lemma high_lowD : [predI low & high] =i pred0.

Lemma modnS x1 x2 : (x1 == x2 %[mod 2]) = (x1.+1 == x2.+1 %[mod 2]).

Lemma hlE x : high x = ~~ low x.

Lemma lhE x : low x = ~~ high x.

Lemma ldomUn h1 h2 :
        ldom (h1 :+ h2) =i
        [pred x | def (h1 :+ h2) && (x \in [predU ldom h1 & ldom h2])].

Definition loweq h1 h2 := get_lows h1 == get_lows h2.

Notation "h1 =~ h2" := (loweq h1 h2) (at level 80).

Lemma low_refl h : h =~ h.

Hint Resolve low_refl : core.

Lemma low_sym h1 h2 : (h1 =~ h2) = (h2 =~ h1).

Lemma low_trans h2 h1 h3 : h1 =~ h2 -> h2 =~ h3 -> h1 =~ h3.

Lemma loweqP h1 h2 : reflect (ldom h1 =i ldom h2) (h1 =~ h2).

Lemma loweqK h1 h2 t1 t2 :
        def (h1 :+ t1) -> def (h2 :+ t2) ->
        h1 =~ h2 -> h1 :+ t1 =~ h2 :+ t2 -> t1 =~ t2.

Lemma loweqE h1 h2 : h1 =~ h2 -> lfresh h1 = lfresh h2.

Lemma lowUn h1 h2 t1 t2 :
        def (h1 :+ t1) ->
        def (h2 :+ t2) ->
        h1 =~ h2 -> t1 =~ t2 -> h1 :+ t1 =~ h2 :+ t2.

Lemma lowPn A1 A2 (x : ptr) (v1 : A1) (v2 : A2) : x :-> v1 =~ x :-> v2.

Hint Resolve lowPn : core.

Lemma highPn A1 A2 (x1 x2 : ptr) (v1 : A1) (v2 : A2) :
        high x1 -> high x2 -> x1 :-> v1 =~ x2 :-> v2.

Lemma lowPtUn A1 A2 h1 h2 (x : ptr) (v1 : A1) (v2 : A2) :
        def (x :-> v1 :+ h1) ->
        def (x :-> v2 :+ h2) ->
        (x :-> v1 :+ h1 =~ x :-> v2 :+ h2) = (h1 =~ h2).

Lemma highPtUn A h1 h2 (x : ptr) (v : A) :
        def (x :-> v :+ h1) -> high x ->
        (x :-> v :+ h1 =~ h2) = (h1 =~ h2).

Lemma highPtUn2 A1 A2 h1 h2 (x1 x2 : ptr) (v1 : A1) (v2 : A2) :
        def (x1 :-> v1 :+ h1) ->
        def (x2 :-> v2 :+ h2) ->
        high x1 -> high x2 ->
        h1 =~ h2 -> x1 :-> v1 :+ h1 =~ x2 :-> v2 :+ h2.

Definition plus2 (h1 h2 : heap * heap) : heap * heap :=
  (h1.1 :+ h2.1, h1.2 :+ h2.2).

Definition def2 (h : heap * heap) := def h.1 && def h.2.

Notation "h1 :++ h2" := (plus2 h1 h2) (at level 50).

Lemma unA2 h1 h2 h3 : h1 :++ (h2 :++ h3) = h1 :++ h2 :++ h3.

Lemma unC2 h1 h2 : h1 :++ h2 = h2 :++ h1.

Lemma unKhl2 h h1 h2 : def2 (h1 :++ h) -> h1 :++ h = h2 :++ h -> h1 = h2.

Lemma unKhr2 h h1 h2 : def2 (h2 :++ h) -> h1 :++ h = h2 :++ h -> h1 = h2.

Lemma unDl2 h1 h2 : def2 (h1 :++ h2) -> def2 h1.

Lemma unDr2 h1 h2 : def2 (h1 :++ h2) -> def2 h2.

Lemma un0h2 h : (empty, empty) :++ h = h.

Lemma unh02 h : h :++ (empty, empty) = h.

Lemma injUh A h1 h2 x (v1 v2 : A) :
        def (h1 :+ (x :-> v1)) ->
        h1 :+ (x :-> v1) = h2 :+ (x :-> v2) ->
          def h1 /\ h1 = h2 /\ v1 = v2.

Lemma eqUh h1 h2 h : def (h1 :+ h) -> h1 :+ h = h2 :+ h -> def h1 /\ h1 = h2.

Lemma exit1 h1 h2 h : def (h1 :+ h) -> h1 :+ h = h :+ h2 -> def h1 /\ h1 = h2.

Lemma exit2 h1 h : def (h1 :+ h) -> h1 :+ h = h -> def h1 /\ h1 = empty.

Lemma exit3 h1 h : def h -> h = h :+ h1 -> def empty /\ empty = h1.

Lemma exit4 h : def h -> h = h -> def empty /\ empty = empty.

Ltac cancelator t H :=
  match goal with
  
  | |- ?h1 :+ t = ?h2 -> _ =>
     let j := fresh "j" in
     set j := {1}(h1 :+ t);
     rewrite -1?unA /j {j};
     (move/(exit1 H)=>{H} [H] || move/(exit2 H)=>{H} [H])
  | |- t = ?h2 -> _ =>
     rewrite -?unA;
     (move/(exit3 H)=>{H} [H] || move/(exit4 H)=>{H} [H])
  | |- (?h1 :+ (?x :-> ?v) = ?h2) -> _ =>
    let j := fresh "j" in
    set j := {1}(h1 :+ (x :-> v));
    
    rewrite 1?(unC (x :-> _)) -?(unAC _ _ (x :-> _)) /j {j};
    
    (move/(injUh H)=>{H} [H []] ||
    
     rewrite (unC h1) ?unA in H * );
    
    cancelator t H
  
  | |- (?h1 :+ ?h = ?h2) -> _ =>
    let j := fresh "j" in
    set j := {1}(h1 :+ h);
    
    rewrite 1?(unC h) -?(unAC _ _ h) /j {j};
    
    (move/(eqUh H)=>{H} [H []] ||
    
    rewrite (unC h1) ?unA in H * );
    
    cancelator t H
  | |- _ => idtac
  end.

Ltac heap_cancel :=
  match goal with
  | |- ?h1 = ?h2 -> ?GG =>
    let t1 := fresh "t1" in
    let t2 := fresh "t2" in
    let t := fresh "t" in
    let H := fresh "H" in
    let G := fresh "hidden_goal"
    in
      
      suff : def h1; first (
       
       set t1 := {1 2}h1; set t2 := {1}h2; set G := GG;
       
       rewrite -(un0h t1) -(un0h t2) [empty]lock;
       set t := locked empty; rewrite /t1 /t2 {t1 t2};
       move=>H;
       
       rewrite ?unA in H *;
       
       cancelator t H;
       
       move: H {t}; rewrite /G {G})
  | |- _ => idtac
  end.

Lemma cexit1 h1 h2 h : h1 = h2 -> h1 :+ h = h :+ h2.

Lemma cexit2 h1 h : h1 = empty -> h1 :+ h = h.

Lemma cexit3 h1 h : empty = h1 -> h = h :+ h1.

Lemma congUh A h1 h2 x (v1 v2 : A) :
        h1 = h2 -> v1 = v2 -> h1 :+ (x :-> v1) = h2 :+ (x :-> v2).

Lemma congeqUh h1 h2 h : h1 = h2 -> h1 :+ h = h2 :+ h.

Ltac congruencer t :=
  match goal with
  | |- ?h1 :+ t = ?h2 =>
     let j := fresh "j" in
     set j := {1}(h1 :+ t);
     rewrite -1?unA /j {j};
     (apply: cexit1 || apply: cexit2)
  | |- t = ?h2 =>
     rewrite -1?unA;
     (apply: cexit3 || apply: refl_equal)
  | |- (?h1 :+ (?x :-> ?v) = ?h2) =>
    let j := fresh "j" in
    set j := {1}(h1 :+ (x :-> v));
    
    rewrite 1?(unC (x :-> _)) -?(unAC _ _ (x :-> _)) /j {j};
    
    ((apply: congUh; [congruencer t | idtac]) ||
    
     (rewrite (unC h1) ?unA; congruencer t))
  
  | |- (?h1 :+ ?h = ?h2) =>
    let j := fresh "j" in
    set j := {1}(h1 :+ h);
    
    rewrite 1?(unC h) -?(unAC _ _ h) /j {j};
    
    (apply: congeqUh ||
    
    rewrite (unC h1) ?unA);
    
    congruencer t
  | |- _ => idtac
  end.

Ltac heap_congr :=
  match goal with
  | |- ?h1 = ?h2 =>
    let t1 := fresh "t1" in
    let t2 := fresh "t2" in
    let t := fresh "t" in
      set t1 := {1}h1; set t2 := {1}h2;
      
      rewrite -(un0h t1) -(un0h t2) [empty]lock;
      set t := locked empty; rewrite /t1 /t2 {t1 t2};
      
      rewrite ?unA;
      
      congruencer t=>{t}
  | |- _ => idtac
  end.

Lemma test h1 h2 h3 x (v1 v2 : nat) :
        h3 = h2 -> v1 = v2 ->
        h1 :+ (x :-> v1) :+ h3= h2 :+ h1 :+ (x :-> v2).

Definition supdom h2 h1 := subdom h1 h2.

Lemma sexit1 h1 h2 h :
        def (h2 :+ h) ->
          (def h2 -> supdom h2 h1) -> supdom (h2 :+ h) (h :+ h1).

Lemma sexit2 h1 h :
        def (h1 :+ h) -> (def h1 -> supdom h1 empty) ->
          supdom (h1 :+ h) h.

Lemma sexit3 h1 h :
        def h -> (def empty -> supdom empty h1) ->
          supdom h (h :+ h1).

Lemma sexit4 h : def h -> (def empty -> empty = empty) -> supdom h h.

Lemma supdomUh A B h1 h2 x (v1 : A) (v2 : B) :
        def (h2 :+ (x :-> v2)) ->
          (def h2 -> supdom h2 h1) ->
            supdom (h2 :+ (x :-> v2)) (h1 :+ (x :-> v1)).

Lemma supdomeqUh h1 h2 h :
        def (h2 :+ h) -> (def h2 -> supdom h2 h1) -> supdom (h2 :+ h) (h1 :+ h).

Lemma sup_defdef h1 h2 : def h2 -> supdom h2 h1 -> def h1.

Ltac supdom_checker t H :=
  match goal with
  | |- is_true (supdom (?h1 :+ t) ?h2) =>
     let j := fresh "j" in
     set j := {1}(h1 :+ t);
     rewrite -1?unA /j {j};
     (apply: (sexit1 H)=>{H} H || apply: (sexit2 H)=>{H} H)
  | |- is_true (supdom t ?h1) =>
     rewrite -1?unA;
     (apply: (sexit3 H)=>{H} H || apply: (sexit4 H)=>{H} H)
  | |- is_true (supdom (?h1 :+ (?x :-> ?v)) ?h2) =>
    let j := fresh "j" in
    set j := {1}(h1 :+ (x :-> v));
    
    rewrite 1?(unC (x :-> _)) -?(unAC _ _ (x :-> _)) /j {j};
    
    (apply: (supdomUh _ H)=>{H} H ||
    
     (rewrite (unC h1) ?unA in H * )); supdom_checker t H
  
  | |- is_true (supdom (?h1 :+ ?h) ?h2) =>
    let j := fresh "j" in
    set j := {1}(h1 :+ h);
    
    rewrite 1?(unC h) -?(unAC _ _ h) /j {j};
    
    (apply: (supdomeqUh H)=>{H} H ||
    
    (rewrite (unC h1) ?unA in H * ));
    
    supdom_checker t H
  | |- _ => idtac
  end.

Ltac defcheck :=
  match goal with
  | |- is_true (def ?h2) -> is_true (def ?h1) =>
    let t1 := fresh "t1" in
    let t2 := fresh "t2" in
    let t := fresh "t" in
    let H := fresh "H" in
      set t2 := {1}h2; set t1 := {1}h1;
      
      rewrite -(un0h t1) -(un0h t2) [empty]lock;
      set t := locked empty; rewrite /t1 /t2 {t1 t2};
      
      rewrite ?unA;
      move=>H;
      apply: (sup_defdef H);
      
      supdom_checker t H; move: H {t}; rewrite /supdom
  | |- _ => idtac
  end.

Ltac hhauto := (do ?econstructor=>//; try by [heap_congr])=>//. *)
(* terms:
From mathcomp
Require Import ssreflect ssrbool ssrnat ssrfun eqtype seq.
From LemmaOverloading
Require Import prelude prefix perms heaps.
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Structure ctx := Context {heap_ctx : seq heap; ptr_ctx : seq ptr}.

Definition empc := Context [::] [::].

Definition subctx i j :=
  prefix (heap_ctx i) (heap_ctx j) /\ prefix (ptr_ctx i) (ptr_ctx j).

Lemma subctx_refl i: subctx i i.

Lemma subctx_trans j i k :
        subctx i j -> subctx j k -> subctx i k.

Inductive elem := Pts of nat & dynamic | Var of nat.
Definition synheap := seq elem.

Fixpoint valid_ptrs i t :=
  match t with
    Pts sx _ :: s => (sx < size (ptr_ctx i)) && valid_ptrs i s
  | Var _ :: s => valid_ptrs i s
  | _ => true
  end.

Fixpoint valid_heaps i t :=
  match t with
    Pts _ _ :: s => valid_heaps i s
  | Var v :: s => (v < size (heap_ctx i)) && valid_heaps i s
  | _ => true
  end.

Definition valid i t := valid_ptrs i t && valid_heaps i t.

Lemma valid_cons i e t : valid i (e :: t) = valid i [:: e] && valid i t.

Lemma valid_ptrs_cat j t1 t2 :
        valid_ptrs j (t1 ++ t2) = valid_ptrs j t1 && valid_ptrs j t2.

Lemma valid_heaps_cat j t1 t2 :
        valid_heaps j (t1 ++ t2) = valid_heaps j t1 && valid_heaps j t2.

Lemma valid_cat j t1 t2 : valid j (t1 ++ t2) = valid j t1 && valid j t2.

Lemma valid_subctx i j t : subctx i j -> valid i t -> valid j t.

Definition hlook := [fun i => onth (heap_ctx i)].
Definition plook := [fun i => onth (ptr_ctx i)].

Notation plook' i x := (odflt null (plook i x)).

Definition einterp i e :=
  match e with
    Pts x d =>
      if plook i x is Some x'
        then x' :-> Dyn.val d
      else Undef
  | Var h => if hlook i h is Some h' then h' else Undef
  end.

Fixpoint interp i t :=
  if t is e :: t' then
    if t' is [::] then einterp i e else einterp i e :+ interp i t'
  else empty.

Lemma interp_cons i e t : interp i (e :: t) = einterp i e :+ interp i t.

Lemma interp_cat i t1 t2 : interp i (t1 ++ t2) = interp i t1 :+ interp i t2.

Lemma interp_perm i : forall t1 t2, perm t1 t2 -> interp i t1 = interp i t2.

Lemma interp_subctx j k t: valid j t -> subctx j k -> interp j t = interp k t.

Inductive fact :=
  eqH of synheap & synheap | eqD of dynamic & dynamic | eqX of nat & nat.

Definition eval_fact i f :=
  match f with
  | eqH h1 h2 => interp i h1 = interp i h2
  | eqD d1 d2 => d1 = d2
  | eqX x1 x2 => plook i x1 = plook i x2
  end.

Fixpoint eval i s :=
  match s with
  | [:: f] => eval_fact i f
  | (f :: fs) => eval_fact i f /\ eval i fs
  | [::] => True
  end.

Fixpoint ptrs t : seq nat :=
  if t is e :: t' then
    if e is Pts x _ then x :: (ptrs t')
    else ptrs t'
  else [::].

Fixpoint vars t : seq nat :=
  if t is e :: t' then
    if e is Var h then h :: (vars t')
    else vars t'
  else [::].

Definition ptreq (x : nat) e := if e is Pts y _ then x == y else false.
Definition vareq (h : nat) e := if e is Var k then h == k else false.

Fixpoint pread x t :=
  match t with
    Pts y d :: s => if x == y then some d else pread x s
  | e :: s => pread x s
  | _ => None
  end.

Notation pread' x t := (odflt (dyn tt) (pread x t)).

Definition pfree x t := filter (predC (ptreq x)) t.
Definition hfree h t := filter (predC (vareq h)) t.

Fixpoint cancel' (i : ctx) (t1 t2 r : synheap) (f : seq fact) : seq fact :=
  match t1 with
  | [::] => match r, t2 with
            | [::], [::] => f
            | [:: Pts x d], [:: Pts x' d'] =>
                [:: eqX x x', eqD d d' & f]
            | _ , _ => [:: eqH r t2 & f]
            end
  | Pts x d :: t1' =>
      if x \in ptrs t2
        then cancel' i t1' (pfree x t2) r [:: eqD d (pread' x t2) & f]
      else cancel' i t1' t2 [:: Pts x d & r] f
  | Var h :: t1' =>
      if h \in vars t2 then cancel' i t1' (hfree h t2) r f
      else cancel' i t1' t2 [:: Var h & r] f
  end.

Definition cancel i t1 t2 := cancel' i t1 t2 [::] [::].

Lemma eval_cons i f s : eval i (f :: s) <-> eval_fact i f /\ eval i s.

Lemma eval_cat i s1 s2 : eval i (s1 ++ s2) <-> eval i s1 /\ eval i s2.

Lemma eval_rcons i f s : eval i (rcons s f) <-> eval i s /\ eval_fact i f.

Lemma pfreeE x t :
        pfree x t =
          if t is e :: t' then
            if e is Pts y d then
              if x == y then pfree x t' else e :: pfree x t'
            else e :: pfree x t'
          else [::].

Lemma hfreeE h t :
        hfree h t =
          if t is e :: t' then
            if e is Var k then
              if h == k then hfree h t' else e :: hfree h t'
            else e :: hfree h t'
          else [::].

Lemma ptr_has x t : has (ptreq x) t = (x \in ptrs t).

Lemma var_has h t : has (vareq h) t = (h \in vars t).

Lemma pfreeN x t : x \notin ptrs t -> pfree x t = t.

Lemma pfree_subdom i x t :
        def (interp i t) -> subdom (interp i (pfree x t)) (interp i t).

Lemma pfree_def i x t: def (interp i t) -> def (interp i (pfree x t)).

Lemma hfreeN h t : h \notin vars t -> hfree h t = t.

Lemma vars_hfree (h1 h2 : nat) t :
        has (vareq h1) (hfree h2 t) = (h1 != h2) && (has (vareq h1) t).

Lemma hfree_subdom i h t :
        def (interp i t) ->
          {subset dom (interp i (hfree h t)) <= dom (interp i t)}.

Lemma hfree_subdom' i h t :
        def (interp i t) ->
          subdom (interp i (hfree h t)) (interp i t).

Lemma hfree_def i h t : def (interp i t) -> def (interp i (hfree h t)).

Lemma count0_hfree v t: count (pred1 v) (vars t) = 0 -> hfree v t = t.

Lemma count1_hfree v t :
        count (pred1 v) (vars t) = 1 -> perm (Var v :: hfree v t) t.

Lemma countN_varfree i v t :
        count (pred1 v) (vars t) > 1 -> def (interp i t) ->
        hlook i v = Some empty.

Lemma empty_hfree i v t :
        hlook i v = Some empty -> interp i (hfree v t) = interp i t.

Lemma domR i (x : nat) t :
        def (interp i t) -> has (ptreq x) t ->
        plook' i x \in dom (interp i t).

Lemma lookR i t x :
        def (interp i t) -> has (ptreq x) t ->
        look (plook' i x) (interp i t) = pread' x t.

Lemma defR i t : def (interp i t) -> uniq (ptrs t).

Lemma freeR i t x :
        def (interp i t) -> has (ptreq x) t ->
        free (plook' i x) (interp i t) = interp i (pfree x t).

Lemma cancel_sound' i sh1 sh2 unm fs :
        interp i sh2 = interp i (sh1 ++ unm) ->
        def (interp i sh2) -> eval i fs ->
        eval i (cancel' i sh1 sh2 unm fs).

Lemma cancel_sound i t1 t2 :
        def (interp i t1) -> interp i t1 = interp i t2 ->
        eval i (cancel i t1 t2). *)

Set Implicit Arguments.

Unset Strict Implicit.

Unset Printing Implicit Defensive.



Section HeapReflection.



Structure tagged_heap := Tag {untag :> heap}.



Definition var_tag := Tag.

Definition pts_tag := var_tag.

Definition empty_tag := pts_tag.

Canonical Structure union_tag hc := empty_tag hc.



Definition invariant i j t h := [/\ interp j t = h, subctx i j & valid j t].



Structure ast (i j : ctx) (t : synheap) :=

  Ast {heap_of :> tagged_heap;

       _ : invariant i j t heap_of}.



Arguments Ast : clear implicits.



Lemma union_pf i j k t1 t2 (f1 : ast i j t1) (f2 : ast j k t2) :

        invariant i k (t1 ++ t2) (union_tag (f1 :+ f2)).

Proof.

case: f1 f2=>h1 /= [<- S1 D1] [h2 /= [<- S2 D2]].

split; first by rewrite interp_cat (interp_subctx D1 S2).

- by apply: (subctx_trans S1 S2).

by rewrite valid_cat D2 andbT; apply: (valid_subctx S2).

Qed.



Canonical Structure

  union_struct i j k t1 t2 (f1 : ast i j t1) (f2 : ast j k t2) :=

  Ast i k _ (union_tag (f1 :+ f2)) (union_pf f1 f2).



Lemma empty_pf i : invariant i i [::] (empty_tag empty).

Proof. split; by [|apply: subctx_refl|]. Qed.



Canonical Structure empty_struct i :=

  Ast i i [::] (empty_tag empty) (empty_pf i).



Lemma pts_pf A hs xs1 xs2 x (d : A) (xs : xfind xs1 xs2 x):

        invariant (Context hs xs1) (Context hs xs2)

                  [:: Pts x (dyn d)] (pts_tag (xuntag xs :-> d)).

Proof.

case: xs=>[p /= [H P]]; split; first by rewrite /= H.

- by split; [apply: prefix_refl|].

by apply/andP; rewrite /= (onth_size H).

Qed.



Canonical Structure

  pts_struct A hs xs1 xs2 x (d : A)

           (xs : xfind xs1 xs2 x) :=

  Ast (Context hs xs1) (Context hs xs2)

       [:: Pts x (dyn d)]

       (pts_tag (xuntag xs :-> d))

       (pts_pf hs _ xs).



Lemma var_pf hs1 hs2 xs n (f : xfind hs1 hs2 n) :

        invariant (Context hs1 xs) (Context hs2 xs) [:: Var n] (var_tag (xuntag f)).

Proof.

case:f=>p [H1 H2]; split; first by rewrite /= /hlook H1.

- by split; [|apply: prefix_refl].

by apply/andP; rewrite /= (onth_size H1).

Qed.



Canonical Structure var_struct hs1 hs2 xs n (f : xfind hs1 hs2 n) :=

  Ast (Context hs1 xs) (Context hs2 xs) _

      (var_tag (xuntag f))

      (var_pf xs f).



End HeapReflection.



Theorem cancelR j k t1 t2 (f1 : ast empc j t1) (f2 : ast j k t2) :

        def (untag (heap_of f1)) ->

        untag (heap_of f1) = untag (heap_of f2) ->

        eval k (cancel k t1 t2).

Proof.

case: f1 f2=>hp1 /= [<- _ I] [hp2 /= [<- S _]] D H.

by apply: cancel_sound; rewrite -(interp_subctx I S).

Qed.



Example ex0 x (v1 v2:nat):

          def (x :-> v1) -> x :-> v1 = x :-> v2 ->

          v1 = v2.

move=>D H.

Time set H' := (cancelR D H).

Time by rewrite (dyn_inj H').

Time Qed.



Set Printing Implicit.



Example ex1 x h (v1 v2:nat):

          def (x :-> v1 :+ h) -> x :-> v1 :+ h = x :-> v2 ->

          if v1 == v2 then true else false.

move=>D H.

by rewrite (dyn_inj (proj2 (cancelR D H))) eq_refl.

Qed.



Example ex2 h1 h2 h3 h4 x1 x2 (d1 d2 d3 d4 : nat) :

     def ((h3 :+ (x1 :-> d1)) :+ (h1 :+ empty) :+ (x2 :-> d2)) ->

     (h3 :+ (x1 :-> d1)) :+ (h1 :+ empty) :+ (x2 :-> d2) =

     (x2 :-> d3) :+ (h2 :+ empty :+ h3) :+ h4 :+ (x1 :-> d4) ->

     d1 = d4 /\ d2 = d3 /\ h1 = h2 :+ h4.

move=>D.

move/(cancelR D)=>/= [->][].

by move/dyn_inj=>->; move/dyn_inj=>->.

Qed.



Example ex1' x h (v1 v2:nat):

          def (x :-> v1 :+ h) -> x :-> v1 :+ h = x :-> v2 ->

          v1 = v2.

move=>D H.

set H' := cancelR D H.

simpl in H'.

by apply: (dyn_inj (proj2 (cancelR D H))).

Qed.



Example stress

     (h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 : heap)

     (x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 : ptr) :

     def (h1 :+ h2 :+ h3 :+ h4 :+ h5 :+ h6 :+ h7 :+ h8 :+ h9 :+ h10 :+

     x1 :-> 1 :+ x2 :-> 2 :+ x3 :-> 3 :+ x4 :-> 4 :+ x5 :-> 5 :+

     x6 :-> 6 :+ x7 :-> 7 :+ x8 :-> 8 :+ x9 :-> 9 :+ x10 :-> 10) ->

     h1 :+ h2 :+ h3 :+ h4 :+ h5 :+ h6 :+ h7 :+ h8 :+ h9 :+ h10 :+

     x1 :-> 1 :+ x2 :-> 2 :+ x3 :-> 3 :+ x4 :-> 4 :+ x5 :-> 5 :+

     x6 :-> 6 :+ x7 :-> 7 :+ x8 :-> 8 :+ x9 :-> 9 :+ x10 :-> 10 =

     x1 :-> 1 :+ x2 :-> 2 :+ x3 :-> 3 :+ x4 :-> 4 :+ x5 :-> 5 :+

     h1 :+ h2 :+ h3 :+ h4 :+ h5 :+ h6 :+ h7 :+ h8 :+ h9 :+ h10 :+

     x6 :-> 6 :+ x7 :-> 7 :+ x8 :-> 8 :+ x9 :-> 9 :+ x10 :-> 10 ->

     True.

move=>D.

Time move/(cancelR D)=>/=.

by [].

Time Qed.

