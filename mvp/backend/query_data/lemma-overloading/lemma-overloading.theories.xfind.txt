
From mathcomp
Require Import ssreflect ssrnat seq.
From LemmaOverloading
Require Import prefix.
(* prefix:
From mathcomp
Require Import ssreflect ssrfun ssrbool ssrnat seq.
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Section Prefix.
Variable A : Type.

Fixpoint onth (s : seq A) n : option A :=
  if s is x :: s' then
    if n is n'.+1 then onth s' n' else Some x
  else None.

Definition prefix s1 s2 :=
  forall n x, onth s1 n = some x -> onth s2 n = some x.

Lemma size_onth (s : seq A) n : n < size s -> exists x, onth s n = Some x.

Lemma onth_size (s : seq A) n x : onth s n = Some x -> n < size s.

Lemma prefix_refl s : prefix s s.

Lemma prefix_trans (s2 s1 s3 : seq A) :
        prefix s1 s2 -> prefix s2 s3 -> prefix s1 s3.

Lemma prefix_cons x s1 s2 : prefix (x :: s1) (x :: s2) <-> prefix s1 s2.

Lemma prefix_cons' x y s1 s2 : prefix (x :: s1) (y :: s2) -> x = y /\ prefix s1 s2.

Lemma prefix_size (s t : seq A) : prefix s t -> size s <= size t.

Lemma prefix_onth (s t : seq A) x : x < size s -> prefix s t -> onth s x = onth t x.

End Prefix.

Hint Resolve prefix_refl : core. *)
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Section XFind.

Variable A : Type.

Definition invariant s r i (e : A) := onth r i = Some e /\ prefix s r.

Structure xtagged := XTag {xuntag :> A}.

Definition extend_tag := XTag.
Definition recurse_tag := extend_tag.
Canonical Structure found_tag x := recurse_tag x.

Structure xfind (s r : seq A) (i : nat) := XFind {
  elem_of :> xtagged;
  _ : invariant s r i elem_of}.

Arguments XFind : clear implicits.

Lemma found_pf x t : invariant (x :: t) (x :: t) 0 x.
Proof. by split; [|apply: prefix_refl]. Qed.

Canonical Structure found_struct x t :=
  XFind (x :: t) (x :: t) 0 (found_tag x) (found_pf x t).

Lemma recurse_pf (i : nat) (y : A) (s r : seq A) (f : xfind s r i) :
        invariant (y :: s) (y :: r) i.+1 f.
Proof. by case:f=>[q [H1 H2]]; split; [|apply/prefix_cons]. Qed.

Canonical Structure recurse_struct i y t r (f : xfind t r i) :=
  XFind (y :: t) (y :: r) i.+1 (recurse_tag f) (recurse_pf y f).

Lemma extend_pf x : invariant [::] [:: x] 0 x.
Proof. by []. Qed.

Canonical Structure extend_struct x :=
  XFind [::] [:: x] 0 (extend_tag x) (extend_pf x).

End XFind.

Lemma findme A (r s : seq A) i (f : xfind r s i) : onth s i = Some (xuntag (elem_of f)).
by case: f=>e [/= ->].
Qed.

Example test A (x1 x2 x3 : A) : onth [:: x1; x2; x3] 2 = Some x3.
apply: findme.
Defined.

Set Printing Implicit.
Print test.

Example unit_test : forall A (x1 x2 x3 x y : A),
   (forall s r i (f : xfind s r i), nth x1 r i = xuntag f -> xuntag f = x) ->
  x = x.
Proof.
move=>A x1 x2 x3 x y test_form.
apply: (test_form [::]). simpl.
apply: (test_form [:: x1; x]). simpl.
apply: (test_form [:: x1; x2; x; x3]). simpl.
apply: (test_form [:: x1; x2; x3]). simpl.
Abort.
