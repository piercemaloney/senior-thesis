Require Import Procrastination.Procrastination.
Require Import Nat Arith Omega Psatz Eomega.
(* Eomega:
Require Import Omega.
Require Import Arith.

Ltac For n t :=
  match n with
    0 => idtac
  | S ?n' => (For n' t || t n')
  end.

Ltac For_inf n t :=
  t n ||
    let n' := (eval compute in (1 + n)) in
    For_inf n' t.

Ltac forcenat n :=
  match type of n with
    nat => n
  | N => eval compute in (N.to_nat n)
  | Z => eval compute in (Z.to_nat n)
  end.

Ltac explus n := let z := eval compute in (Z.of_nat n) in exists z.
Ltac exminus n := let z := eval compute in (Z.opp (Z.of_nat n)) in exists z.

Ltac match_exists_on_type ty t :=
  lazymatch goal with
  | |- @ex ty ?P => t P
  | |- @sig ty ?P => t P
  | |- @sigT ty ?P => t P
  
  | |- @ex2 ty ?P ?Q => let PQ := constr:(fun x => P x /\ Q x) in t PQ
  | |- @sig2 ty ?P ?Q => let PQ := constr:(fun x => P x /\ Q x) in t PQ
  | |- @sigT2 ty ?P ?Q => let PQ := constr:(fun x => P x /\ Q x) in t PQ
  end.

Ltac if_exists_on_type ty t :=
  match_exists_on_type ty ltac:(fun _ => t).

Ltac iter_cube_new t n :=
  let n := forcenat n in
  
  (if_exists_on_type
     nat
     ltac:(For n ltac:(fun i => exists i; iter_cube_new t n)))
  ||
  
  (if_exists_on_type
     Z
     ltac:(For n ltac:(fun i => (explus i; iter_cube_new t n) ||
                             (exminus i; iter_cube_new t n))))
  
  ||
  t.

Ltac iter_cube t n :=
  let n := forcenat n in
  lazymatch goal with
  | |- @ex    nat _   => For n ltac:(fun i => exists i; iter_cube t n)
  | |- @sig   nat _   => For n ltac:(fun i => exists i; iter_cube t n)
  | |- @sigT  nat _   => For n ltac:(fun i => exists i; iter_cube t n)
  | |- @ex2   nat _ _ => For n ltac:(fun i => exists i; iter_cube t n)
  | |- @sig2  nat _ _ => For n ltac:(fun i => exists i; iter_cube t n)
  | |- @sigT2 nat _ _ => For n ltac:(fun i => exists i; iter_cube t n)
  | |- @ex    Z _   => For n ltac:(fun i => (explus i; iter_cube t n) || (exminus i; iter_cube t n))
  | |- @sig   Z _   => For n ltac:(fun i => (explus i; iter_cube t n) || (exminus i; iter_cube t n))
  | |- @sigT  Z _   => For n ltac:(fun i => (explus i; iter_cube t n) || (exminus i; iter_cube t n))
  | |- @ex2   Z _ _ => For n ltac:(fun i => (explus i; iter_cube t n) || (exminus i; iter_cube t n))
  | |- @sig2  Z _ _ => For n ltac:(fun i => (explus i; iter_cube t n) || (exminus i; iter_cube t n))
  | |- @sigT2 Z _ _ => For n ltac:(fun i => (explus i; iter_cube t n) || (exminus i; iter_cube t n))
  | |- _ => t
  end.

Ltac iter_cone t n :=
  lazymatch goal with
  | |- @ex   nat _ => For n ltac:(fun i => exists i; let n' := eval compute in (n - i) in iter_cone t n')
  | |- @sig  nat _ => For n ltac:(fun i => exists i; let n' := eval compute in (n - i) in iter_cone t n')
  | |- @sigT nat _ => For n ltac:(fun i => exists i; let n' := eval compute in (n - i) in iter_cone t n')
  | |- @ex   Z _ => fail "Bounded sum exploration not yet implemented for Z"
  | |- @sig  Z _ => fail "Bounded sum exploration not yet implemented for Z"
  | |- @sigT Z _ => fail "Bounded sum exploration not yet implemented for Z"
  | |- _ => t
  end.

Ltac iter_plane t n :=
  let Sn := (eval compute in (1 + n)) in
  lazymatch goal with
  | |- @ex   nat _ => For Sn ltac:(fun i => exists i; let n' := eval compute in (n - i) in iter_plane t n')
  | |- @sig  nat _ => For Sn ltac:(fun i => exists i; let n' := eval compute in (n - i) in iter_plane t n')
  | |- @sigT nat _ => For Sn ltac:(fun i => exists i; let n' := eval compute in (n - i) in iter_plane t n')
  | |- @ex   Z _ => fail "Constant-sum exploration not yet implemented for Z"
  | |- @sig  Z _ => fail "Constant-sum exploration not yet implemented for Z"
  | |- @sigT Z _ => fail "Constant-sum exploration not yet implemented for Z"
  | |- _ => match n with 0 => t | _ => fail end
  end.

Tactic Notation "iter_planes" tactic(t) :=
  For_inf 0 ltac:(iter_plane t).

Tactic Notation "iter_planes" tactic(t) constr(n) :=
  For n ltac:(iter_plane t).

Tactic Notation "iter_cubes" tactic(t) constr(n) :=
  For n ltac:(iter_cube t).

Tactic Notation "iter_cubes" tactic(t) :=
  For_inf 1 ltac:(iter_cube t).

Tactic Notation "eomega" :=
  iter_cubes omega.

Tactic Notation "eomega" constr(n) :=
  let n := forcenat n in
  let n' := (eval compute in (1 + n)) in
  iter_cube omega n'.

Tactic Notation "eomega" "sum" :=
  iter_planes omega.

Tactic Notation "eomega" "sum" constr(n) :=
  let n := forcenat n in
  let n' := (eval compute in (1 + n)) in
  iter_cone omega n'.

Section Tests.

Goal exists a b, a = 5 /\ b = 5.

Goal 15 = 15.

Goal exists n, n = 0.

Goal exists n, n = 15.        Proof. eomega. Qed.
Goal { n : nat & n = 15 }. Proof. eomega. Qed.
Goal { x | x * x + 2 = 3 * x & x <> 1 }. Proof. eomega. Qed.

Goal exists a b c, a = 5 /\ b = 6 /\ c = 4 /\ a + c + b = b + a + c.

Goal exists x y, 3 * x * y = 12.

Goal exists x2 x3 x4 : nat, 0 <= x2 /\ 1 <= x4 /\ x4 <= x3 /\ S (S x4) <= x3 /\ 2 <= x2.

Goal forall x2 x3 x4 : nat,
    (0 <= x2 /\ 1 <= x4 /\ x4 <= x3 /\ S (S x4) <= x3 /\ 2 <= x2) ->
    x2 <= 2 ->
    x3 <= 2 ->
    x4 <= 2 ->
    False.

Goal exists a b, forall x, 6 * x + x + x = a * x + b.

Open Scope Z_scope.

Goal exists x1 x2 : Z, x1 = - 5 /\ x2 = 5.

Goal exists x1 x2 : Z, x1 * x2 = 15 /\ x1 < 0 /\ x2 < 0.

Goal exists x1 x2 : Z, 0 <= x1 /\ 0 <= x1 + x2 /\ 1 <= x1 + x2 /\ x2 + 1 <= 0.

Goal exists x1 x2 x3 x4 : Z,
    x1 * x2 * x3 * x4 = 16 /\
    x1 * x2 < 0 /\
    x3 * x4 < 0.

Goal exists x1 x2 : Z,
    x1 * x2 = - 16 /\
    0 < x1 < 5 /\
    -5 < x2 < 0.

Goal exists x1 x2 : Z,
    x1 * x2 = - 16 /\
    0 < x1 < 5 /\
    -5 < x2 < 0.

Goal exists x, x * x * x = - 27.

Goal exists n : nat, exists z : Z, Z.pow z (Z.of_nat n) = - 27.

Definition fifth_root : { x | x * x * x * x * x = 69343957 }.
Print fifth_root. 

Goal { x | x * x * x * x = 81 }%nat.

Goal { x | x * x * x = 81 }%nat.
Proof.
  Fail eomega 100.
Abort. 

End Tests. *)

Goal True.
  begin defer assuming a b c.

  assert (a <= b + 1). defer.
  assert (b = c + 2). defer.
  exact I.

  end defer.
  exists 0, 2, 0. omega.
Qed.

Goal True.
  begin defer.
  assert (H1: 1 + 1 = 2) by defer.
  assert (H2: 1 + 2 = 3) by defer.
    defer H3: (1 + 3 = 4).

  tauto.
  end defer.
  repeat split; reflexivity.
Qed.

Goal True.
    begin defer assuming a b c in g.
  
  assert (a = b) by defer.
  assert (b = c) by (defer in g).
  exact I.

  end defer.
  exists 0, 0, 0. omega.
Qed.

Lemma dup : forall P, P -> P -> P. auto. Qed.

Goal exists (x: nat), x >= 2 /\ x <= 5 /\ x >= 1.
  begin defer assuming x.
  - exists x. 
    repeat split.
    + defer.
    + defer.
    + 
      Fail omega.

      apply dup.
      
      { deferred exploit (fun H => generalize H). omega. }

      apply dup.
      
      { deferred. omega. }

      apply dup.
      
      deferred H: (x >= 2). omega.

      deferred H: (x >= 1).
      { 
        omega. }
      assumption.

  - end defer.
    eomega.
Qed.

Lemma log2_step:
  forall n,
  2 <= n ->
  1 + log2 (n/2) = log2 n.
Admitted.

Definition monotonic (f : nat -> nat) :=
  forall x y, x <= y -> f x <= f y.

Lemma solve_cost_ineqs_clean :
 exists (f: nat -> nat),
  1 <= f 0 /\
  monotonic f /\
  forall n, 0 < n -> 2 + f (n / 2) <= f n.
Proof.
  begin defer assuming a b c.
  exists (fun n => if zerop n then c else a * log2 n + b).
  repeat split.
  { simpl. defer. }
  { intros x y ?. repeat (destruct zerop); try omega.
    - enough (c <= b) by lia. defer.
    - pose proof (Nat.log2_le_mono x y). clear g; nia. }
  { intros n Hn.
    destruct (zerop n) as [|_]; [ exfalso; omega |].
    destruct (zerop (n / 2)) as [E|].
    - assert (n = 1). { rewrite Nat.div_small_iff in E; omega. }
      subst n. change (log2 1) with 0. rewrite Nat.mul_0_r, Nat.add_0_l.
      defer.
    - assert (2 <= n). { rewrite (Nat.div_mod n 2); omega. }
      rewrite <-(log2_step n) by auto. rewrite Nat.mul_add_distr_l.
      enough (2 <= a) by omega. defer. }
  end defer.
  eomega.
Qed.

Lemma solve_cost_ineq :
 exists (f: nat -> nat),
   forall n,
   1 + (if zerop n then 0 else 1 + max (f (n / 2)) (f (n - (n / 2) - 1))) <= f n.
Proof.
  begin defer assuming f. exists f.
  intro n.
  destruct (zerop n) as [|H].
  { subst n. simpl. defer. }
  { rewrite max_l; swap 1 2.
    { defer M: (monotonic f). apply M.
      rewrite (Nat.div_mod n 2) at 1; [| omega].
      pose proof (Nat.mod_upper_bound n 2); omega. }

    { rewrite Nat.add_assoc. change (1+1) with 2.
      revert n H. defer. } }
  end defer.

  apply solve_cost_ineqs_clean.
Qed.
