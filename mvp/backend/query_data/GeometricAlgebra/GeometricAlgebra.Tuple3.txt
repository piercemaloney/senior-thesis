Require Import List Eqdep_dec Compare Bool Field Field_tac ZArith.
(* Field:
Require Import ZArith Aux Even.

Structure fparams: Type := {
 K:> Set;               
 v0: K;                
 v1: K;                
 eqK: K -> K -> bool;  
 oppK: K -> K;         
 addK : K -> K -> K;   
 multK : K -> K -> K;  
 invK : K -> K         
}.

Delimit Scope field_scope with f.

Notation "x ?= y" := (eqK _ x y) (at level 70) : field_scope.
Notation "x + y" := (addK _ x y) : field_scope.
Notation "- x" := (oppK _ x) : field_scope.
Notation "x ^-1" := (invK _ x) (at level 25) : field_scope.
Notation "x * y" := (multK _ x y) : field_scope.
Notation "0" := (v0 _) : field_scope.
Notation "1" := (v1 _) : field_scope.

Section ParamsProp.

Variable p: fparams.
Open Scope field_scope.

Structure fparamsProp: Type := {
 eqK_dec: forall x y: p, if x ?= y then x = y else x <> y;        
          
 addK_assoc: forall x y z: p, (x + y) + z = x + (y + z);
          
 addK_com: forall x y: p, x + y = y + x;
          
 addK0l: forall x: p, 0 + x = x;
          
 oppKr: forall x: p, x + - x = 0;
          
 multK_assoc: forall x y z: p, (x * y) * z = x * (y * z);
          
 multK_com: forall x y: p, x * y = y * x;
          
 multK1l: forall x: p, 1 * x = x;
          
 add_multKl: forall x y z: p, (x + y) * z = x * z + y * z;
          
 one_diff_zero: 1 <> 0 :> p;
          
 invKl: forall x: p, x <> 0 -> x * x^-1 = 1
}.

Fixpoint expK  (k: p) (n:nat) {struct n}: p := 
  match n with O => 1 | (S n1) => k * expK k n1 end.

Notation "x ^ k" := (expK x k) : field_scope.

Variable Hp: fparamsProp.

Implicit Types x y z: p.

Lemma eqKI: forall x, x ?= x = true.

Lemma eqK_spec x y: eq_Spec x y (x ?= y).

Lemma oppKl:  forall x, - x + x = 0.

Lemma addK_cancel x y z: x + y = x + z -> y = z.

Lemma addK_eq_opp: forall x y, x + (-y) = 0 -> x = y.

Lemma addK0r x: x + 0 = x.

Lemma opp_oppK x: - (- x) = x.

Lemma multK1r x: x * 1 = x.

Lemma add_multKr x y z: z * (x + y) = z * x + z * y.

Lemma oppK0: - 0 = 0 :> p.

Lemma opp_addK x y: - (x + y) = - x + - y.

Lemma multK0l x: 0 * x = 0.

Lemma multK0r x: x * 0 = 0.

Lemma opp_multKl x y: - (x * y) = - x * y.

Lemma opp_multKr x y: - (x * y) = x * - y.

Lemma opp_multK1l x: - x  = (-(1)) * x.

Lemma opp_multK1r x: - x  = x * (-(1)).

Lemma multK_m1_m1: -(1) * -(1) = 1 :>p.

Lemma expKS n: (-(1)) ^n.+1 = -(-(1)) ^n.

Lemma expK2m1 n: (-(1)) ^ n * (- (1)) ^  n =1.

Lemma expK_add n1 n2 a: a ^ (n1 + n2) = a ^n1 * a ^ n2.

Lemma expKm1_even n: even n -> (-(1))^ n = 1
with expKm1_odd n: odd n -> (-(1))^ n = -(1).

Lemma expKm1_sub m n: m <= n -> (-(1))^ (n - m) = (-(1))^ (n + m).

Lemma expKm1_2 n: (-(1))^ (2 * n) = 1.

Lemma expKm1_2E n m: (-(1))^ (2 * n + m) = (-(1))^ m.

Lemma invKr x: x <> 0 -> x^-1 * x = 1.

Lemma multK_cancel x y z: x <> 0 -> x * y = x * z -> y = z.

Lemma multK_swap x y z: x * (y * z) = y * (x * z).

Lemma multK_integral x y : x * y = 0 -> x = 0 \/ y = 0.

Lemma expK_integral x n : x^n = 0 -> x = 0.

Lemma expKm1_n0 n : (-(1))^n <> 0.

Fixpoint n_to_K n := 
  match n with O => 0: p | S n => (1 + n_to_K n) end.

Lemma n_to_K0: n_to_K 0 = 0.

Lemma n_to_K1: n_to_K 1 = 1.

Lemma n_to_K_add m n : n_to_K (m + n) = n_to_K m + n_to_K n.

Lemma n_to_K_minus m n : n <= m -> n_to_K (m - n) = n_to_K m + -n_to_K n.

Lemma n_to_K_mult m n : n_to_K (m * n) = n_to_K m * n_to_K n.

Definition Z_to_K (z: Z) :=
  match z with
  | Z0 => 0
  | Zpos _ => n_to_K (Z.abs_nat z)
  | Zneg _ => - (n_to_K (Z.abs_nat z))
  end.

Lemma Z_to_K_opp (z: Z): Z_to_K (-z)%Z = - Z_to_K z.

Lemma Z_to_K_pos (z: Z): (0 <= z)%Z -> Z_to_K z = n_to_K (Z.abs_nat z).

Lemma Z_to_K_add (z1 z2: Z): 
  Z_to_K (z1 + z2)%Z = Z_to_K z1 + Z_to_K z2.

Lemma Z_to_K_minus (z1 z2: Z): 
  Z_to_K (z1 - z2)%Z = Z_to_K z1 + - Z_to_K z2.

Lemma Z_to_K_mult (z1 z2: Z): 
  Z_to_K (z1 * z2)%Z = Z_to_K z1 * Z_to_K z2.

End ParamsProp.

Notation "x ^ k" := (expK _ x%f k) : field_scope.

Ltac Krm0 :=
 repeat ((rewrite multK0l || rewrite multK0r || rewrite oppK0 ||
         rewrite addK0l || rewrite addK0r)); auto.

Ltac Krm1 :=
  Krm0; 
  repeat (rewrite multK1l || rewrite multK1r || rewrite <- opp_multKr ||
          rewrite expK2m1  || rewrite <- opp_multKl || rewrite opp_oppK); auto. *)
Require Import VectorSpace Grassmann G3.
(* VectorSpace:
Require Import Setoid Field Min List Aux.

Structure eparams: Type := {
 E:> Set;                      
 stype:> fparams;              
 E0: E;                        
 eqE: E -> E -> bool;          
 addE : E -> E -> E;          
 scalE : (K stype) -> E -> E   
}.

Delimit Scope vector_scope with v.

Notation "x ?= y" := (eqE _ x y) (at level 70): vector_scope.
Notation "0" := (E0 _): vector_scope.
Notation "x + y" := (addE _ x y): vector_scope.
Notation "x .* y" := (scalE _ x%f y) (at level 31, no associativity): vector_scope.

Arguments scalE _ _%field_scope _%vector_scope.

Section VectorSpace.

Variable p : eparams.

Open Scope vector_scope.

Implicit Type v x y z: p.
Implicit Type k: stype p.

Definition  mprod ks vs :=
   fold2 (fun k v r => k .* v + r) ks vs 0.

Notation " x *X* y " := (mprod x y) (at level 40, no associativity): vector_scope.

Definition free vs := 
  forall ks, length ks = length vs -> ks *X* vs = 0 -> 
    (forall k, In k ks -> k = 0%f).

Inductive cbl (l: list (E p)): (E p) -> Prop :=
  cbl0: cbl l 0
| cbl_in: forall v, In v l -> cbl l v
| cbl_add: forall x y, cbl l x -> cbl l y -> cbl l (x + y)
| cbl_scal: forall k x, cbl l x -> cbl l (k .* x).

Lemma cbl_trans l1 l2 x: 
  (forall i, In i l2 -> cbl l1 i) -> cbl l2 x -> cbl l1 x.
 
Definition is_base vs := free vs /\ forall e, cbl vs e.

Structure vparamsProp: Type := {
 sProp : fparamsProp p;
 eqE_dec: forall x y, if x ?= y then x = y else x <> y;        
          
 addE_assoc: forall x y z, (x + y) + z = x + (y + z);
          
 addE_com: forall x y, x + y = y + x;
          
 addE0l: forall x, 0 + x = x;
          
 scalE0l: forall x, 0 .* x = 0;
          
 scalE1: forall x, 1 .* x = x;
          
 scal_addEl: forall k1 k2 x, (k1 + k2) .* x = (k1.* x) + (k2 .* x);
          
 scal_addEr: forall k x y, k .* (x + y) = k .* x + k .* y;
          
 scal_multE: forall k1 k2 x, (k1 * k2) .* x = k1.* (k2 .* x)
          
}.

Variable Hp: vparamsProp.

Lemma eqE_refl x: (x ?= x) = true.

Lemma addE0r: forall x, x + 0 = x.

Let sfP := sProp Hp.

Lemma addE_cancell x y z : z + x = z + y -> x = y.

Lemma addE_cancelr x y z : x + z = y + z -> x = y.

Lemma scalE0r k : k .* 0 = 0.

Lemma scal_addE0 x : x + (- (1)) .* x = 0.

Lemma addE_eq_opp x y : x + (-(1)) .* y = 0 -> x = y.

Lemma mprod_S k ks v vs : (k :: ks) *X* (v :: vs) = k .* v + ks *X* vs.

Lemma mprod0l vs : nil *X* vs = 0.

Lemma mprod0r ks : ks *X* nil = 0.

Lemma mprod0 vs1 vs2 : map (fun _ : E p => 0%f) vs1 *X* vs2 = 0.

Lemma mprod_app ks1 ks2 vs1 vs2 :
   length ks1 = length vs1 -> 
      (ks1 ++ ks2) *X* (vs1 ++ vs2) = ks1 *X* vs1 + ks2 *X* vs2.

Lemma eqE_spec x y : eq_Spec x y (x ?= y).

Lemma free_nil : free nil.

Lemma free_cons v vs : free (v::vs) -> free vs.

Lemma free_perm vs1 vs2 : perm vs1 vs2 -> free vs2 -> free vs1.

Lemma uniq_free vs : free vs -> uniq vs.

Lemma free_incl vs1 vs2 : incl vs1 vs2 -> uniq vs1 -> free vs2 -> free vs1.

Lemma cbl_incl l1 l2 v : incl l1 l2 -> cbl l1 v -> cbl l2 v.

Lemma cbl0_inv x : cbl nil x -> x = 0.

Lemma mprod_cbl l ks : cbl l (ks *X* l).

Lemma addE_mprod ks1 ks2 vs : length ks1 = length ks2 ->
  map2 (fun k1 k2 => (k1 + k2)%f) ks1 ks2 *X* vs = ks1 *X* vs + ks2 *X* vs.

Lemma scalE_mprod k ks vs : 
 map (fun k1 => (k * k1)%f) ks *X* vs = k .* (ks *X* vs).

Lemma mprod_perm l1 l2 lk1: perm l1 l2 -> length lk1 = length l1 ->
  exists lk2, perm lk1 lk2 /\ lk1 *X* l1 = lk2 *X* l2.

Fixpoint lgenk (n: nat) (k: K p) {struct n} : list (K p) :=
  match n  with
    O => nil
  | 1 => k :: nil
  | S n1 => k::lgenk n1 k
  end.

Lemma lgenk_length n k : length (lgenk n k) = n.

Lemma genk0_mprod vs :  0 = lgenk (length vs) 0%f *X* vs.

Lemma cbl_mprod vs v : cbl vs v -> 
  exists ks, length ks = length vs /\ v = ks *X* vs.

Lemma scalE_add0 x : x + (- (1)) .* x = 0.

Lemma scalE_integral k x : k .* x = 0 -> {k = 0%f} + {x = 0}.

Lemma scalE_opp k1 k2 x : k1 .* ((- (k2)) .* x) = (-k1).* (k2 .* x).

Lemma scalE_swap k1 k2 x : k1 .* (k2 .* x) = k2 .* (k1 .* x).

Lemma addE_swap x1 x2 x3 : x1 + (x2 + x3) = x2 + (x1 + x3).

Lemma cblnil x : cbl nil x -> x = 0.

Lemma cbl1 x y : cbl (x::nil) y -> exists k, y = k .* x.

End VectorSpace.

Notation " x *X* y " := (mprod _ x y) (at level 40, no associativity): vector_scope.

Section Trans.

Variable p p1 : eparams.
Hypothesis Hp: vparamsProp p.
Hypothesis Hp1: vparamsProp p1.
Variable (f: p -> p1).
Variable (g : stype p -> stype p1).
Variable (g1 : stype p1 -> stype p).
Hypothesis Hf0: f 0%v = 0%v.
Hypothesis Hf1: forall x y : p, (f (x + y) = f x + f y)%v.
Hypothesis Hf2: forall (k: stype p) (x : p), (f (k .* x) = g k .* f x)%v.
Hypothesis Hg: forall k, g (g1 k) = k. 

Lemma cbl_map l v : cbl _ l v -> cbl _ (map f l) (f v).

Lemma cbl_map_inv l v :
 cbl _ (map f l) v -> exists v1, cbl _ l v1 /\ v = f v1.

End Trans.

Structure params: Type := {
 dim:> nat;           
 K:> fparams          
}.

Ltac Vrm0 := Krm0;
  repeat (rewrite addE0l ||rewrite addE0r || rewrite scalE0l|| rewrite scalE0r); auto. *)
(* Grassmann:
Require Import ArithRing Div2 Bool Even Setoid Min List Aux Field VectorSpace Kn.

Section Vect.

Variable p : params.

Hypothesis Hp : fparamsProp p.

Delimit Scope g_scope with g.
Open Scope g_scope.
Open Scope vector_scope.

Definition K1 := K.
Notation "'K'" := (K1 p) : g_scope.
Notation "'kn'" := (kn p).
Notation projk := (proj p).

Ltac Kfold n :=
     change (Kn.add p n) with (addE (Kn.vn_eparams p n));
     change (Kn.scal p n) with (scalE (Kn.vn_eparams p n));
     change (Kn.genk p n 0%f) with (E0 (Kn.vn_eparams p n)).

Fixpoint vect (n: nat): Set := 
  match n with O => K | S n1 => (vect n1 * vect n1)%type end.

Fixpoint eq (n : nat) : vect n -> vect n -> bool :=
  match n return (vect n -> vect n -> bool) with
  | 0%nat => fun a b => (a ?= b)%f
  | S n1 =>
      fun l1 l2 =>
      let (l3, l5) := l1 in
      let (l4, l6) := l2 in 
      if eq n1 l3 l4 then eq n1 l5 l6 else false
  end.

Fixpoint add (n : nat) : vect n -> vect n -> vect n :=
  match n return (vect n -> vect n -> vect n) with
  | 0%nat => fun a b => (a + b)%f
  | S n1 =>
      fun l1 l2 =>
      let (l3, l5) := l1 in
      let (l4, l6) := l2 in (add n1 l3 l4, add n1 l5 l6)
  end.

Fixpoint genk (n: nat) (k: K) {struct n}: (vect n) :=
   match n return vect n with 0%nat => k | n1.+1 => (genk n1 0%f, genk n1 k) end.
Notation " [ k ] " := (genk _ k%f) (at level 9): g_scope.
Arguments genk _ _%field_scope.

Fixpoint scal (n : nat) (k: K) {struct n}: vect n -> vect n :=
  match n return (vect n -> vect n) with
  | 0%nat => fun a => (k * a)%f
  | S n1 =>
      fun l1 =>
      let (l2, l3) := l1 in (scal n1 k l2, scal n1 k l3)
  end.

Canonical Structure vn_eparams (n: nat) :=
  Build_eparams (vect n) K [0] (eq n) (add n) (scal n).

Definition fn n : vparamsProp (vn_eparams n).

Hint Resolve fn.

Notation "1" := ([1]): g_scope.

Ltac Vfold n :=
     change (add n) with (addE (vn_eparams n));
     change (scal n) with (scalE (vn_eparams n));
     change (genk n 0) with (E0 (vn_eparams n)).

Hint Rewrite multK0l multK0r oppK0 addK0l addK0r 
             addE0r addE0l scalE0r scalE0l: GRm0.

Ltac Grm0 := autorewrite with GRm0; auto.

Fixpoint sub (n : nat) : vect n -> vect n -> vect n :=
  match n return (vect n -> vect n -> vect n) with
  | 0%nat => fun a b => (a + (- b))%f
  | S n1 =>
      fun v1 v2 =>
      let (x1, y1) := v1 in
      let (x2, y2) := v2 in (sub n1 x1 x2, sub n1 y1 y2)
  end.

Notation "x - y" := (sub _ x y): g_scope.

Lemma sub_add n (v1 v2: vect n) : v1 - v2 = v1 + (-(1)).* v2.

Lemma sub0l n (v: vect n) : 0 - v = (-(1)) .* v.

Hint Rewrite sub0l: GRm0.

Lemma sub0r n (v: vect n) : v - 0 = v.

Hint Rewrite sub0r: GRm0.

Lemma injk n k1 k2 : [k1] = [k2] :> vect n -> k1 = k2.

Lemma oppk n k : [-k] = (-(1)).* [k] :> vect n.

Lemma genkE n k : [k] = k .* 1 :> vect n.

Lemma deck0 n (x: vect n):  x = 0 \/ x <> 0.

Fixpoint gen (n: nat) (p: nat) {struct n} : vect n :=
  match n return vect n with 0 => 1%f | S n1 =>
    match p with
      0 => (genk n1 1%f, genk n1 0%f)
    | S p1 =>  (genk n1 0%f, gen n1 p1) 
    end
  end.

Notation "''e_' p" := (gen _ p) (at level 8, format "''e_' p"): g_scope.

Lemma inj_e n p1 p2 : p1 < n -> p2 < n ->
  'e_p1 = 'e_p2 :> vect n -> p1 = p2.

Fixpoint const (n: nat): (vect n) -> K :=
  match n return vect n -> K with 
  | O => fun a => a
  | S n1 => fun l => let (l1,l2) := l in const n1 l2
  end.

Notation "'C[ x ]" := (const _ x).

Lemma const0 n : 'C[ 0: vect n ] = 0%f.

Hint Rewrite const0: GRm0.

Lemma constk n k : 'C[[k]: vect n] = k.

Lemma const_scal n k (x: vect n): 'C[k .* x] = (k * 'C[x])%f.

Lemma const_add n (x1 x2: vect n): 'C[x1 + x2] = ('C[x1] + 'C[x2])%f.

Fixpoint eq0 (n : nat) : vect n -> bool :=
  match n return (vect n -> bool) with
  | 0%nat => fun a => (a ?= 0)%f
  | S n1 =>
      fun l1 =>
      let (l2, l3) := l1 in
      if eq0 n1 l2 then eq0 n1 l3 else false
  end.

Notation "x ?= 0" := (eq0 _ x) (at level 70): g_scope.

Lemma eq0_dec n (x: vect n) : if x ?= 0 then x = 0 else x <> 0.

Lemma eq0_spec n (x: vect n) : eq_Spec x 0 (x ?= 0).

Lemma eq0I n : ((0: vect n) ?= 0) = true.

Lemma en_def n : 'e_n = 1 :> vect n.

Lemma addk n k1 k2 : [k1] + [k2] = [k1 + k2] :> vect n.

Lemma scal_integral n k (x: vect n) : k .* x = 0 -> k = 0%f \/ x = 0.

Lemma scalk n k1 k2 : k1 .* [k2] = [k1 * k2] :> vect n.

Fixpoint hom (n k : nat) {struct n} : vect n -> bool :=
  match n return (vect n -> bool) with
  | 0%nat => fun a => match k with O => true | S _ => a ?= 0 end
  | S n1 =>
      fun l1 =>
       let (l2, l3) := l1 in
       (match k with O => l2 ?= 0 | S k1 => hom n1 k1 l2 end) && hom n1 k l3
  end.

Lemma homk0 n k : hom n k 0.

Hint Resolve homk0.

Lemma hom0K n k : hom n 0 [k].

Hint Resolve hom0K.

Lemma const_hom n k x : hom n k x -> 0 < k -> 'C[x] = 0%f.

Lemma hom0E n (x: vect n) : hom n 0 x -> x = ['C[x]].

Lemma hom1e n i : i < n -> hom n 1 'e_i.

Lemma homE n k1 k2 (x: vect n) : 
  hom n k1 x -> hom n k2 x -> k1 = k2 \/ x = 0.

Lemma hom_lt n k v : n < k -> hom n k v -> v = 0.

Lemma add_hom n k (x y: vect n) : 
  hom n k x -> hom n k y -> hom n k (x + y).

Hint Resolve add_hom.

Lemma scal_hom n k1 k2 (x: vect n) : 
  hom n k1 x -> hom n k1 (k2 .* x).

Hint Resolve scal_hom.

Fixpoint get_hom (n m : nat) {struct n} : vect n -> vect n :=
  match n return (vect n -> vect n) with
  | 0%nat => fun a => match m with O => a | S _ => 0 end
  | S n1 =>
      fun l1 =>
       let (l2, l3) := l1 in
       ((match m with O => [0] 
                 | S m1 => get_hom n1 m1 l2
         end), get_hom n1 m l3)
  end.

Lemma get_hom0 n m : get_hom n m [0] = [0].

Lemma get_homk0 n k: get_hom n 0 [k] = [k].

Lemma get_homkS n m k: get_hom n m.+1 [k] = [0].

Lemma get_hom_ei n m i :  i < n ->
  get_hom n m 'e_i = match m with 1 => 'e_i | _ => [0] end.

Lemma get_hom_scal n m k x : 
  get_hom n m (k .* x) = k .* get_hom n m x.

Lemma get_hom_add n m x y : 
  get_hom n m (x + y) = get_hom n m x + get_hom n m y.

Lemma get_hom_up n m x : n < m -> get_hom n m x = [0].

Fixpoint sum (n : nat) (f: (nat -> vect n)) (m : nat) {struct m} :
    vect n :=
  match m with
  | 0%nat => f 0%nat
  | S m1 => f m + sum n f m1
  end.

Lemma sumEl n f m : 
  sum n f m.+1 = f 0%nat + sum n (fun m => f m.+1) m.

Lemma sumEr n f m : sum n f m.+1 = f m.+1 + sum n f m.

Lemma sum_ext (n : nat) (f1 f2: (nat -> vect n)) (m : nat) :
  sum n.+1 (fun m => (f1 m, f2 m)) m = (sum n f1 m, sum n f2 m).

Lemma get_hom_sum n (x : vect n) :
   x = sum n (fun m => get_hom n m x) n.

Lemma hom_get_hom n (x : vect n) m : hom n m (get_hom n m x).

Fixpoint first_deg (n : nat) {struct n} : vect n -> nat :=
  match n return (vect n -> nat) with
  | 0%nat => fun a => 0%nat
  | S n1 =>
      fun l1 =>
      let (l2, l3) := l1 in
      if l2 ?= 0 then first_deg n1 l3 else S (first_deg n1 l2)
  end.

Lemma first_deg0 n : first_deg n 0 = 0%nat.

Lemma first_deg0i n v : first_deg n v = 0%nat -> hom n 0 v.

Lemma hom_first_deg n k x : x <> 0 -> hom n k x -> first_deg n x = k.

Definition lift (n: nat) (v: vect n) : (vect n.+1) :=  ((0: vect n), v).

Notation " x ^'l " := (lift _ x) (at level 9, format "x ^'l"): g_scope.

Lemma gen_lift n i : 'e_i.+1 = 'e_i^'l :> vect n.+1.

Lemma lift_k n k : [k] = [k]^'l :> vect n.+1.

Lemma lift_add n x y : (x + y)^'l = x^'l + y^'l :> vect n.+1.

Lemma lift_scal n (k: K) x :  (k .* x)^'l = k .* x^'l :> vect n.+1.

Lemma lift_mprod (n: nat) (ks: list K) vs : ks *X* map (lift n) vs = 
  (ks *X* vs)^'l.

Lemma lift_cbl n l (x: vect n) :
  cbl _ l x -> cbl _ (map (lift n) l) x^'l.

Lemma lift_inj n (x1 x2: vect n) : x1^'l = x2^'l -> x1 = x2.

Definition dlift (n: nat) (v: vect n) : (vect n.+1) := (v,(0: vect n)).

Notation "x ^'dl" := (dlift _ x) (at level 9, format "x ^'dl" ): g_scope.

Lemma dlift_add n x y : (x + y)^'dl = x^'dl + y^'dl :> vect n.+1.

Lemma dlift_scal n (k: K) x : (k .* x)^'dl = k .* x^'dl :> vect n.+1.

Lemma dlift_mprod (n: nat) (ks: list K) vs :
   ks *X* map (dlift n) vs = (ks *X* vs)^'dl.

Fixpoint proj (n: nat) k: (vect n) -> (list K) :=
  match n return vect n -> list  K with 
  | O => fun a  =>
          match k with | O => a::nil | _ => nil end
  | S n1 => fun l => let (l1,l2) := l in 
          match k with | O => proj n1 k l2 | S k1 => 
           (proj n1 k1 l1 ++ proj n1 k l2)%list
          end
  end.

Lemma proj0 n x : proj n 0 x = 'C[x]:: nil.

Lemma proj_hom0_eq n x y : 
  hom n 0 x -> hom n 0 y ->
  nth 0 (proj n 0 x) 0%f = nth 0 (proj n 0 y) 0%f ->  x = y.

Lemma proj_lt n m x : n < m -> proj n m x = nil.

Lemma proj_homn_eq n x y : 
  hom n n x -> hom n n y ->
  nth 0 (proj n n x) 0%f = nth 0 (proj n n y) 0%f ->  x = y.

Fixpoint all (n: nat): vect n :=
  match n return vect n with
  | 0 => 1
  | S n1 => (all n1, 0: vect n1)
  end.

Notation "'E'" := (all _).
 
Lemma all_hom n : hom n n E.

Hint Resolve all_hom.

Fixpoint base (n: nat) k:list (vect n) :=
  match n return list (vect n) with 
  | O =>  match k with | O => 1%f::nil | _ => nil end
  | S n1 => 
          match k with | O => 
                     map (lift n1) (base n1 k) | S k1 => 
           (map (dlift n1) (base n1 k1) ++ 
            map (lift n1) (base n1 k))%list
          end
  end.

Lemma proj_base_length n (x: vect n) k : 
  length (proj n k x) = length (base n k).

Lemma base0 n : base n 0 = 'e_n::nil.

Lemma base_lt_nil m n : m < n -> base m n = nil.

Lemma base_n n : base n n = all n::nil.

Lemma base_length n k : length (base n k) = bin n k.

Lemma base_lift n k :  incl (map (lift n) (base n k)) (base n.+1 k).

Lemma base_hom n k v : k <= n -> In v (base n k) -> hom n k v.

Lemma proj_homk n (x: vect n) k : 
  hom n k x -> proj n k x *X* base n k = x.

Lemma base_free n k : free _ (base n k).

Lemma e_in_base1 n i : i < n -> In 'e_i (base n 1).

Lemma e_in_base1_ex n v : 
  In v (base n 1) -> exists p1, p1 < n /\ v = 'e_p1.

Lemma base1_length n : length (base n 1) = n.

Lemma base1_S n:
  base n.+1 1 = ('e_0: vect n.+1) :: map (lift n) (base n 1).

Lemma base_nil n k : n < k -> base n k = nil.

Lemma cbl1_hom1_equiv n (x: vect n) : cbl _ (base n 1) x <-> hom n 1 x.

Lemma cblk_homk_equiv n k (x: vect n): cbl _ (base n k) x <-> hom n k x.

Lemma cbl_base1_split n x :
 cbl _ (base n.+1 1) x -> exists k, exists y, cbl _ (base n 1) y /\ x = ([k], y).

Lemma cbl_base1_list_split n l:
 (forall x, In x l -> cbl _ (base n.+1 1) x) -> 

Lemma hom_induct n k (P: vect n -> Prop) :
  P 0 -> (forall v, In v (base n k) -> P v) ->
     (forall v1 v2, P v1 -> P v2 -> P (v1 + v2)) ->
     (forall k v, P v -> P (k .* v)) ->
   
Fixpoint conj (n : nat) (b: bool) {struct n}: vect n -> vect n :=
  match n return (vect n -> vect n) with
  | 0%nat => fun a => if b then (- a)%f else a
  | S n1 =>
      fun l1 =>
      let (l2, l3) := l1 in (conj n1 (negb b) l2, conj n1 b l3)
  end.

Notation "x ^_ b" := (conj _ b x)  (at level 30).
Notation "x ^_'t" := (conj _ true x)  (at level 30).
Notation "x ^_'f" := (conj _ false x)  (at level 30).

Lemma conj_add n b (x y: vect n) : (x + y) ^_ b = x ^_ b + y ^_ b.

Lemma conj_invo n b (x: vect n) : x ^_ b ^_ b = x.

Lemma conj0 n b : 0 ^_ b = (0 : vect n).

Hint Rewrite conj0: GRm0.

Lemma conjk n b k : [k] ^_ b=  if b then [-k] else ([k]: vect n).

Lemma conj_neg n b (v: vect n) : v ^_ (negb b) = (-(1)) .*  (v ^_ b).

Lemma conjt n (v: vect n) : v ^_'t = (-(1)) .*  (v ^_'f).

Lemma conj_e n b i : i < n ->
  'e_i ^_ b = if b then ('e_i: vect n) else (- (1)).* 'e_i.

Lemma conj_scal n b k (x: vect n) : (k .* x) ^_ b = k .* x ^_ b.

Lemma conj_hom n b k (x: vect n) : hom n k x -> hom n k (x ^_ b).

Hint Resolve conj_hom.

Lemma conjf_hom n k (M: vect n) : hom n k M -> M ^_'f = (- (1))^k .* M.

Lemma conjt_hom n k (M: vect n) : hom n k M -> M ^_'t = (- (1))^k.+1 .* M.

Lemma conj_const n b (x: vect n) : 'C[x ^_ b] = if b then (-'C[x])%f else 'C[x].

Lemma conj_swap n b1 b2 (x: vect n) : x ^_ b2 ^_ b1 =  x ^_ b1 ^_ b2.

Lemma conj_all n b: (E  ^_ b) = 
   (if b then (-((-(1))^ n))%f else ((-(1))^ n)%f) .* E :> vect n.

Fixpoint join (n : nat) : vect n -> vect n -> vect n :=
  match n return (vect n -> vect n -> vect n) with
  | 0%nat => fun x y => (x * y)%f
  | S n1 =>
      fun x y =>
      let (x1, x2) := x in
      let (y1, y2) := y in (join n1 x1 y2 + join n1 (x2 ^_'f) y1, 
                             join n1 x2 y2)
  end.

Notation "x '∨' y" := (join _ x y) (at level 40, left associativity): type_scope.

Lemma join_scall n k (x y : vect n) : k .* x ∨ y = k .* (x ∨ y).

Lemma join0 (v1 v2: vect 0) : v1 ∨ v2 = (v1 ∨ v2)%f.

Lemma join0l n (x : vect n) : 0 ∨ x = 0.

Hint Rewrite join0l: GRm0.

Lemma join0r n (x : vect n) : x ∨ 0 = 0.

Hint Rewrite join0r: GRm0.

Lemma joinkl n k (x : vect n) : [k] ∨ x = k .* x.

Lemma joinkr n k (x : vect n) : x ∨ [k] = k .* x.

Lemma join1l n (x : vect n) : 1 ∨ x = x.

Lemma join1r n (x : vect n) : x ∨ 1 = x.

Lemma join_alll n (x: vect n) : all n ∨ x = 'C[x] .* all n.

Lemma join_allr n (x: vect n) : x ∨ all n = 'C[x] .* all n.

Lemma join_allhr k n x : hom n k x -> 0 < k -> x ∨ E = 0.

Lemma join_allhl k n x : hom n k x -> 0 < k -> E ∨ x = 0.

Lemma join_scalr n k (x y : vect n) : x ∨ (k .* y) = k .* (x ∨ y).

Lemma joink n k1 k2 : [k1] ∨ [k2] = [k1 * k2] :> vect n.

Lemma join_e0 n (M : vect n.+1) : 'e_0 ∨ M = (snd M, [0]).

Lemma join_ei n i (M : vect n.+1) : i < n ->

Lemma join_es n i j : 
   i < n -> j < n -> 'e_ i ∨ 'e_ j + 'e_ j ∨ 'e_ i = (0: vect n).

Lemma join_e n i : i < n -> 'e_ i ∨ 'e_ i = (0 : vect n).

Lemma join_addl n (x y z : vect n) : (x + y) ∨ z = x ∨ z + y ∨ z.

Lemma join_addr n (x y z : vect n) : z ∨ (x + y) = z ∨ x + z ∨ y.

Lemma conjf_join n (x y: vect n) : (x ∨ y) ^_'f =  x ^_'f ∨ y ^_'f.

Lemma join_assoc n (x y z : vect n) : x ∨ y ∨ z = x ∨ (y ∨ z).

Lemma cbl_join_com n (vs: list (vect n)) :
  (forall x y, In x vs -> In y vs -> y ∨ x = (- (1)).* (x ∨ y)) ->

Lemma cbl_base_join_com n x y :
 cbl _ (base n 1) x -> cbl _ (base n 1) y ->  y ∨ x = (- (1)).* (x ∨ y).

Lemma cbl_join_id n vs : 
  (forall x y, In x vs -> In y vs -> join n y x = (- (1)).* (x ∨ y)) ->

Lemma cbl_base_join_id n x : cbl _ (base n 1) x -> x ∨ x = 0.

Lemma join_hom1_id n x : hom n 1 x -> x ∨ x = 0.

Lemma lift_join n x y : lift n (x ∨ y) = lift n x ∨ lift n y.

Lemma join_hom n k1 k2 (x y: vect n) : 
  hom n k1 x -> hom n k2 y -> hom n (k1 + k2) (x ∨ y).

Hint Resolve join_hom.

Lemma join_big n k1 k2 (x y : vect n) : 
  hom n k1 x -> hom n k2 y -> n < k1 + k2 -> x ∨ y = 0.

Lemma const_join n (x y: vect n): 'C[x ∨ y] = ('C[x] * 'C[y])%f.

Lemma lift_decomp n (x y: vect n) : (x, y) = 'e_0 ∨ x^'l + y^'l.

Lemma base_in n k x: In x (base n k.+1) -> 

Fixpoint all_prods (n: nat) (vs: list (vect n)) {struct vs} : list (vect n) :=
  match vs with
    nil => 1 :: nil
  | v::vs1 => let vs1 := all_prods n vs1 in 
                (map (join n v) vs1 ++ vs1)%list
  end.

Lemma all_prods_nil n : all_prods n nil = 1 :: nil.

Lemma all_prods_cons n v vs : 
  all_prods n (v :: vs) = (map (join n v) (all_prods n vs) ++ (all_prods n vs))%list.

Lemma all_prods1 n vs : In (1) (all_prods n vs).

Lemma all_prods_id n vs : incl vs (all_prods n vs).

Lemma all_prods_length n vs : 
  length (all_prods n vs) = exp 2 (length vs).

Lemma all_prods_lift n vs :
  all_prods n.+1 (map (lift n) vs) = map (lift n) (all_prods n vs).

Lemma all_prods_hom n vs :
  (forall i, In i vs -> exists k, hom n k i) ->
  (forall i, In i (all_prods n vs) -> exists k, hom n k i).

Fixpoint v2l (n: nat) : vect n -> list K :=
  match n return vect n -> list K with
    O => fun k => k :: nil
  | S n1 => fun x => let (x1, x2) := x in
                      (v2l n1 x1 ++ v2l n1 x2)%list
  end.

Lemma v2l_length n v : length (v2l n v) = exp 2 n.

Lemma mprod_2l n (v: vect n) :  v2l n v *X*  all_prods n (base n 1) = v.

Lemma cbl_all_prods n v : cbl _ (all_prods _ (base n 1)) v.

Lemma all_prods_free n: free _ (all_prods _ (base n 1)).

Lemma vect_induct n (P: vect n -> Prop) :
  P (1: vect n) -> (forall v, In v (base n 1) -> P v) ->
     (forall v1 v2, P v1 -> P v2 -> P (v1 ∨ v2)) ->
     (forall v1 v2, P v1 -> P v2 -> P (v1 + v2)) ->
     (forall k v, P v -> P (k .* v)) ->

Lemma vect_hom_induct n (P: vect n -> Prop) :
  (forall k v, hom n k v -> P v) ->
  (forall v1 v2, P v1 -> P v2 -> P (v1 + v2)) ->
     (forall v, P v).
   
Fixpoint joinl n (l: list (vect n)) := match l with
| nil => 0
| a::nil => a
| a::l => a ∨ joinl n l
end.

Lemma joinl0 n : joinl n nil = 0.

Hint Rewrite joinl0 : GRm0.

Lemma joinl1 n x : joinl n (x::nil) = x.

Lemma joinlS n x l : l <> nil -> joinl n (x::l) = x ∨ joinl n l.

Lemma joinl_scal n k (a: vect n) l : 
   joinl _ (k .* a::l) = k .* joinl _ (a::l).

Lemma joinl_app n l1 l2 :
  l1 <> nil -> l2 <> nil -> joinl n (l1 ++ l2)%list = joinl n l1 ∨ joinl n l2.

Lemma joinl_base1_perm n l1 l2 :
 perm l1 l2 ->
 (forall x, In x l1 -> cbl _ (base n 1) x) ->
  (joinl n l1 = joinl n l2) \/ (joinl n l1 = (-(1)).* joinl n l2) .

Lemma joinl0_base1_perm n l1 l2 : perm l1 l2 ->
 (forall x, In x l1 -> cbl _ (base n 1) x) -> joinl n l1 = 0 -> joinl n l2 = 0.

Lemma lift_joinl n l : lift n (joinl n l) = joinl n.+1 (map (lift n) l).

Lemma joinl_hom1 n l :
 (forall x, In x l -> hom n 1 x) -> hom n (length l) (joinl n l).

Hint Resolve joinl_hom1.

Lemma joinl_swap n (a b: vect n) l: 
 cbl _ (base n 1) a ->  cbl _ (base n 1) b ->
   joinl _ (a::b::l) = (-(1)).* joinl _ (b::a::l).

Lemma joinl_top n (a: vect n) l1 l2 : 
 (forall i, In i (a :: l1) -> cbl _ (base n 1) i) ->
   joinl _ (l1 ++ (a::l2)) = (-(1))^length l1 .* joinl _ (a:: (l1 ++ l2)%list).

Lemma joinl_all n : 0 < n -> joinl n (base n 1) = E.

Definition is_vector n v := cbl _ (base n 1) v.

Definition is_vector_space n l := forall x, In x l -> is_vector n x.

Lemma joinl0_mprod n M : M <> nil -> is_vector_space n M ->
   joinl n M = 0 ->
   exists lk, exists i, length lk = length M /\ In i lk /\ i <> 0%f /\ lk *X* M = 0.

Lemma cbl_joinl0_mprod n M x : is_vector_space n M ->  
  cbl _ M x -> joinl n (x::M) = 0.

Definition decomposable n l M := is_vector_space n l /\ M = joinl n l.

Lemma decomp_cbl n M l x : is_vector n x ->
  decomposable n l M -> M <> 0 -> (x ∨ M = 0 <-> cbl _ l x). 

Lemma hom1_decomposable n x : hom n 1 x -> decomposable n (x::nil) x.

Lemma decomp_hom n (l: list (vect n)) M : decomposable n l M -> hom n (length l) M.

Fixpoint contra (n : nat) {struct n}: kn n -> vect n -> vect n :=
  match n return (kn n -> vect n -> vect n) with
  | 0%nat => fun k a => 0
  | S n1 =>
      fun lf l1 =>
      let (k, lf1) := lf in
      let (l2, l3) := l1 in 
         ((- (1)).* (contra n1 lf1 l2),  (k : K) .* l2 + contra n1 lf1 l3)
  end.

Notation "#< l , x ># " := (contra _ l x) (format "#< l ,  x >#").

Lemma contraE n l (M : vect n.+1) :

Lemma contra0r n lf : #<lf, 0># = (0: vect n).

Hint Rewrite contra0r: GRm0.

Lemma contra0l n (x:vect n) : #<0, x># = 0.

Lemma contrak n i lf : #<lf, [i]># = 0 :> vect n.

Lemma contra_e n i lf : i < n -> #<lf, 'e_i># = [projk _ i lf] :> vect n.

Lemma contra_scalr n k lf (x: vect n) : #< lf, k .* x ># = k .* #< lf , x >#.

Lemma contra_addr n lf (x y: vect n) : #< lf, x + y ># = #< lf, x ># + #< lf,  y >#.

Lemma contra_scall n (k : K) (x : kn n)  (M : vect n) :
 #< (scalE (Kn.vn_eparams p n) k x), M># = k .* #<x, M>#.

Lemma contra_addl n (x y : kn n) (M : vect n) :
 #< x + y, M ># =  #< x, M ># + #<y, M >#.

Lemma contra_conj n lf b (x: vect n) : #< lf, x ^_ b ># = #< lf, x ># ^_ (negb b).

Lemma contra_hom n lf k M : hom n k.+1 M -> hom n k #<lf , M>#.

Hint Resolve contra_hom.

Lemma contra_hom0 n lf M : hom n 0 M -> #<lf , M># = 0.

Lemma contra_id n lf (M: vect n) : #<lf, #< lf, M>#  ># = 0.

Lemma contra_swap n lf1 lf2 (M: vect n) :
  #<lf1, #< lf2, M>#  ># = (-(1)).*  #<lf2, #< lf1, M>#  >#.

Fixpoint v2k (n : nat) : vect n -> kn n :=
  match n return vect n -> kn n  with
  | O => fun v : vect 0 => tt
  | S n1  => fun v => let (v1,v2) := v in
             ('C[v1], v2k n1 v2)
  end.

Lemma contra_const n lf M : hom n 1 M -> 
  #<lf, M># = [(lf [.] v2k n M)%Kn].

Lemma contra_join n lf k1 k2 M1 M2 : hom n k1 M1 -> hom n k2 M2 ->
  #<lf, M1 ∨ M2># = #<lf, M1># ∨ M2 + ((- (1))^k1).* M1 ∨ #<lf, M2>#.

Lemma join_hom_com n k1 k2 x y :
 hom n k1 x -> hom n k2 y ->  y ∨ x = ((- (1)) ^(k1 * k2)).* (x ∨ y).

Lemma join_hom_odd n k x : (1+1 <> (0: K))%f -> hom n k x -> odd k -> x ∨ x = 0.

Lemma join_hom_id n k x : hom n k x -> odd k ->  x ∨ x = 0.

Lemma is_vector_space_swap n x l :
  is_vector_space n l -> In x l ->
  exists l1, is_vector_space n (x::l1) /\ joinl n l = joinl n (x::l1).

Fixpoint factor n: (vect n) -> (vect n) -> vect n :=
  match n return vect n -> vect n -> vect n with
  | O => fun x1 x2 => (x2 * x1^-1)%f
  | S n1 =>
        fun x1 x2 =>
        let (x11, x12) := x1 in
        let (x21, x22) := x2 in
        if x12 ?= 0 then
         
        ((0: vect n1), ('C[x11]^-1).* x21: vect n1) else
        let x32 := factor n1 x12 x22 in
          
             (factor n1 x12 (add n1 (('C[x11]) .* x32: vect n1) (scal n1 (-(1))%f  x21: vect n1))
               , x32)
   end.

Lemma factor0 n x : factor n x 0 = 0.

Lemma factor_scal n k x M : factor n x (k .* M) = k .* factor n x M.

Lemma factor_id n x : x <> 0 -> hom n 1 x -> factor n x x = 1.

Lemma factor_hom0E n x1 x2 : x1 <> 0 ->  hom n 1 x1 -> hom n 0 x2 ->
  factor n x1 (x1 ∨ x2) = x2.

Lemma factor_factor n x1 x2 : hom n 1 x1 -> x1 <> 0 ->  
  x1 ∨ x2 = 0 -> x2 = x1 ∨ factor n x1 x2.

Lemma factork n x k : x <> 0 -> hom n 1 x -> factor n x [k] = 0.

Lemma factor0_hom0 n x1 x2 : x1 <> 0 -> hom n 1 x1 -> hom n 0 x2 -> 
  factor n x1 x2 = 0.

Lemma factor_hom n k x1 x2 : x1 <> 0 -> x1 ∨ x2 = 0 -> 
  hom n 1 x1 -> hom n k.+1 x2 -> hom n k (factor n x1 x2).

Lemma factor_add n k x1 x2 x3 : x1 <> 0 ->
  hom n 1 x1 -> hom n k.+1 x2 -> hom n k.+1 x3 ->

Fixpoint fortho n : (vect n) -> (vect n) -> bool :=
  match n return vect n -> vect n -> bool with
  | O => fun x1 x2 => false
  | S n1 =>
        fun x1 x2 =>
        let (x11, x12) := x1 in
        let (x21, x22) := x2 in
        if x12 ?= 0 then x21 ?= 0 else  fortho n1 x12 x21 && fortho n1 x12 x22
   end.

Lemma fortho0 n : 0 < n -> fortho n 0 0.

Lemma fortho_refl n x : fortho n x x -> x = 0.

Lemma forthok n k1 k2 (v: vect n) : v <> 0 -> hom n k1.+1 v -> fortho n v [k2].

Lemma fortho_scal n k v1 v2 : fortho n v1 v2 -> fortho n v1 (k .* v2).

Lemma fortho_add n v1 v2 v3 : 
  fortho n v1 v2 -> fortho n v1 v3 -> fortho n v1 (v2 + v3).

Lemma fortho_conj n b v1 v2 : fortho n v1 v2 -> fortho n v1 (v2 ^_ b).

Lemma fortho_join n v1 v2 v3 : 
  fortho n v1 v2 -> fortho n v1 v3 -> fortho n v1 (v2 ∨ v3).

Lemma fortho_joinl n k v l : v <> 0 -> hom n k.+1 v -> 

Lemma factor_ortho n x1 x2 : x1 <> 0 -> hom n 1 x1 -> 
    fortho n x1 x2 -> factor n x1 (x1 ∨ x2) = x2.

Fixpoint fget n : (vect n) -> (vect n) -> K :=
  match n return vect n -> vect n -> K with
  | O => fun x1 x2 => 0%f
  | S n1 =>
        fun x1 x2 =>
        let (x11, x12) := x1 in
        let (x21, x22) := x2 in
        if x12 ?= 0 then (('C[x11])^-1 * 'C[x21])%f else fget n1 x12 x22
   end.

Lemma fget_scal n k x1 x2 : fget n x1 (k .* x2) = (k *  fget n x1 x2)%f.

Lemma fortho_fget n x1 x2 : x1 <> 0 -> hom n 1 x1 -> hom n 1 x2 ->
    fortho n x1 (x2 + (-(1) * fget n x1 x2)%f .* x1).

Lemma joinl_addmult n (f: vect n -> vect n -> K) x l :
hom n 1 x -> (forall i, In i l -> hom n 1 i) ->
x ∨ joinl n l = x ∨ joinl n (map (fun y => (y + (f x y) .* x)) l).

Lemma mprod_hom n k l1 l2 :
  (forall i, In i l2 -> hom n k i) -> hom n k (l1 *X* l2).

Hint Resolve mprod_hom.

Definition is_decomposable n M := exists l, decomposable n l M.

Lemma joinl_factor n x M : x <> 0 -> hom n 1 x ->
  is_decomposable n M -> x ∨ M = 0 ->
    exists k, exists l, (forall v, In v l -> hom n 1 v) /\ M = k .* joinl n (x::l).

Lemma decomposable_factor n k x M : x <> 0 -> hom n 1 x -> hom n k.+2 M ->

Fixpoint one_factor (n: nat) k : vect n -> vect n :=
  match n return vect n -> vect n with 
  | O => fun a  => a 
  | S n1 => fun l =>
          match k with 
          | O => l
          | S k1 => 
            let (l1,l2) := l in
            let r := one_factor n1 k1 l1 in  
            (0:vect n1, if r ?= 0 then one_factor n1 k l2 else r)
          end
  end.

Lemma one_factor0 n k : one_factor n k 0 = 0.

Lemma one_factor_hom n k1 k2 (x: vect n) :
 k2 < k1 -> hom n k1 x -> hom n (k1 - k2) (one_factor n k2 x).

Hint Resolve one_factor_hom.
 
Lemma one_factor_zero n k1 k2 (x: vect n) :
 k2 < k1 -> hom n k1 x -> one_factor n k2 x = 0 -> x = 0.

Definition mcontra n (ll: list (kn n)) (x: vect n) :=
  fold_left (fun x l => #<l,x>#) ll x.

Notation "#<< l , x >>#" := (mcontra _ l x).

Lemma mcontra_nil n (x: vect n) : #<<nil, x>># = x.

Lemma mcontra_cons n (x: vect n) a l : #<<a::l, x>># = #<<l, #<a,x>#>>#.

Lemma mcontra_app n l1 l2 (M: vect n) :  
  #<< l1 ++ l2, M>># = #<<l2, #<<l1, M>>#>>#.

Lemma mcontra0 n lfs : #<< lfs, 0 >># = (0: vect n).

Hint Rewrite mcontra0: GRm0.

Lemma mcontra_id n a l (M: vect n) : #<< a::a::l, M>># = 0.

Lemma mcontrak n lfs i : lfs <> nil -> #<< lfs, [i] >># = (0: vect n).

Lemma mcontra_scal n k lfs (x: vect n) : #<< lfs, k .* x >># = k .* #<< lfs , x >>#.

Lemma mcontra_swap n a b l (M: vect n) :  
  #<< a::b::l, M>># = (-(1)).*  #<<b::a::l, M>>#.

Lemma mcontra_add n lfs (x y: vect n) :
  #<< lfs, x + y >># = #<< lfs, x >># + #<< lfs,  y >>#.

Lemma mcontra_conj n lfs b (x: vect n) : 
  #<<lfs, x ^_ b >># = #<< lfs, x >># ^_ (iter negb (length lfs) b).

Lemma mcontra_hom n k (x: vect n) l :
  hom n k x -> hom n (k - length l) #<<l, x>>#.

Hint Resolve mcontra_hom.

Lemma mcontra_hom0 n lfs M : lfs <> nil -> hom n 0 M -> #<<lfs , M>># = 0.

Notation liftk := (Kn.lift p).

Lemma lift_contra n lf1 x : #< liftk n lf1, lift n x ># = lift n #<lf1, x>#.

Lemma lift_mcontra n lfs1 x :
  #<< map (liftk n) lfs1, lift n x >># = lift n #<<lfs1, x>>#.

Lemma mcontra_one_factor n k1 k2 (x: vect n) :
  k2 < k1 -> hom n k1 x -> 
 exists lfs, length lfs = k2 /\ #<<lfs , x>># = one_factor n k2 x.

Inductive cbl n (l: list (vect n)): nat -> (vect n) -> Prop :=
| cbl_in: forall v, In v l -> cbl n l 0%nat v
| cbl_add: forall k x y, cbl n l k x -> cbl n l k y -> cbl n l k (x + y)
| cbl_scal: forall k k1 x, cbl n l k x -> cbl n l k (k1 .* x)
| cbl_join: forall k v x, In v l -> cbl n l k x -> cbl n l k.+1 (v ∨ x).

Lemma cbl_cons n (a: vect n) l k x : cbl n l k x -> cbl n (a::l) k x.

Lemma joinl_join n l (v: vect n) : 
  (forall x, In x l -> hom n 1 x) -> In v l -> v ∨ joinl n l = 0.

Lemma cbl_joinl n (l: list (vect n)) :
  l <> nil -> (forall x, In x l -> hom n 1 x) -> cbl n l (pred (length l)) (joinl n l).

Lemma cbl_joinl0 n (l: list (vect n)) k x :
  (forall x, In x l -> hom n 1 x) -> cbl n l k x -> x ∨ joinl n l = 0.

Lemma cbl_hom n (l: list (vect n)) k x :
  (forall x, In x l -> hom n 1 x) -> cbl n l k x -> hom n k.+1 x.

Lemma cbl_contra n (l: list (vect n)) lf k x :
  (forall x, In x l -> hom n 1 x) -> cbl n l k.+1 x -> cbl n l k #<lf, x>#.

Lemma cbl_mcontra n (l: list (vect n)) lfs k x :
  length lfs <= k ->
  (forall x, In x l -> hom n 1 x) -> cbl n l k x -> cbl n l (k - length lfs) #<<lfs, x>>#.

Lemma decomp_one_factor_hom n (l: list (vect n)) M : l <> nil ->
 decomposable n l M -> hom n 1 (one_factor n (pred (length l)) M).

Lemma decomp_one_factor0 n (l: list (vect n)) M :
 decomposable n l M -> one_factor n (pred (length l)) M = 0 -> M = 0.

Lemma decomp_one_factor_join n (l: list (vect n)) M :
 decomposable n l M -> one_factor n (pred (length l)) M ∨ M = 0.

Fixpoint decomposek (n: nat) k (v: vect n) {struct k} : list (vect n) :=
  match k with 
  | O => nil 
  | S O => v::nil 
  | S k1 => let v1 := one_factor n k1 v in
            v1::decomposek n k1 (factor n v1 v)
  end.

Lemma decomposekSS (n: nat) k (v: vect n) :
  decomposek n k.+2 v =  

Lemma decomposek_cor n k v : 
v <> 0 -> is_decomposable n v -> hom n k v -> decomposable n (decomposek n k v) v.

Definition all_hom1 n l := fold_left (fun c x => c && hom n 1 x) l true.

Lemma all_hom1_cor n l :
 if all_hom1 n l then forall i, In i l -> hom n 1 i else 
     exists i, In i l /\ ~ hom n 1 i.

Definition decompose n (v: vect n) : option (list (vect n)) := 
  let d := first_deg n v in
  let l := decomposek n d v in
  if all_hom1 n l then
      if v ?= joinl n l then Some l else None
  else None.

Lemma  decompose_cor n v : 
   match decompose n v with
   | None => ~ is_decomposable n v
   | Some l => decomposable n l v
   end.

Definition grade n k x := hom n k x &&  
  if decompose n x then true else false.

Lemma gradeE n k x : 
  grade n k x <->  hom n k x /\
                   exists l, x = joinl n l /\
                             (forall y, In y l -> hom n 1 y).

Lemma grade0 n k : grade n k 0.

Lemma grade0E n x : grade n 0 x -> x = 0.

Lemma grade_hom n k x : grade n k x -> hom n k x.

Lemma grade1_hom n x : grade n 1 x = hom n 1 x.

Lemma grade_scal n k1 k2 x : grade n k1 x -> grade n k1 (k2 .* x).

Lemma grade_join n k1 k2 x y :
   grade n k1 x -> grade n k2 y -> grade n (k1 + k2) (x ∨ y).

Fixpoint dual n : vect n -> vect n :=
  match n return vect n ->  vect n with
  |    0 => fun a => a
  | S n1 => fun v => let (x,y) := v in (dual n1 (y ^_'f), dual n1 x)
  end.
Notation "'@ x " := (dual _ x) (at level 9).

Lemma dual0 n : '@0 = 0 :> vect n.

Hint Rewrite dual0: GRm0.

Lemma dual0E n (x: vect n) : '@x = 0 -> x = 0.

Lemma dual_hom n k v : hom n k v -> hom n (n - k) '@v.

Hint Resolve dual_hom.

Lemma dual_scal n k (v: vect n) : '@(k .* v) = k .* '@v.

Lemma dual_add n (v1 v2: vect n) : '@(v1 + v2) = '@v1 + '@v2.

Lemma dual_invo n k (v: vect n): hom n k v ->  '@('@v) = (-(1)) ^(k * n.+1) .* v.

Lemma dual_invoE n k (v: vect n) : hom n k v ->  v = ((-(1)) ^(k * n.+1)) .* '@('@v).

Lemma dual_all n : '@E = 1 :> vect n.

Lemma dual1 n : '@1 =  E :> vect n.

Lemma homn_ex n v : hom n n v -> exists k, v = '@[k].

Lemma dual_base n k v :
  In v (base n k) -> In '@v (base n (n - k)) \/ In ((-(1)) .* '@v) (base n (n - k)).

Fixpoint dconj (n : nat) (b: bool) {struct n} : vect n -> vect n :=
  match n return (vect n -> vect n) with
  | 0%nat => fun a => if b then (- a)%f else a
  | S n1 =>
      fun l1 =>
      let (l2, l3) := l1 in (dconj n1 b l2, dconj n1 (negb b) l3)
  end.

Notation "x ^d_ b" := (dconj _ b x)  (at level 29, left associativity).
Notation "x ^d_'t" := (dconj _ true x)  (at level 29, left associativity).
Notation "x ^d_'f" := (dconj _ false x)  (at level 29, left associativity).

Lemma dconj0 n b : 0 ^d_ b = 0 :> vect n.

Hint Rewrite dconj0: GRm0.

Lemma dconj_all n b :
       E ^d_ b = (if b then (-(1)) .* E else E) :> vect n.

Lemma dconj_scal n b k (x: vect n) : (k .* x)^d_ b = k .* x ^d_ b.

Lemma dconj_add n b (x y: vect n) : (x + y) ^d_ b = x ^d_ b + y ^d_ b.

Lemma dconj_invo n b (v: vect n) : v ^d_ b ^d_ b = v.

Lemma dconj_neg n b (v: vect n) : v ^d_ (negb b) = (-(1)) .*  (v ^d_ b).

Lemma dconjt n (v: vect n) : v ^d_'t = (-(1)) .*  (v ^d_'f).

Lemma dconjf_hom n k (M: vect n) : 
  hom n k M -> M ^d_'f = (- (1))^(n + k) .* M.

Lemma dconjt_hom n k (M: vect n) : 
 hom n k M -> M ^d_'t = (- (1))^(n + k).+1 .* M.

Lemma dconj_swap n b1 b2 (x: vect n) : x ^d_ b2 ^d_ b1 = x ^d_ b1 ^d_ b2.

Lemma dconj_conj_swap n b1 b2 (x: vect n) : (x ^_ b2) ^d_  b1 = x ^d_ b1 ^_ b2.

Lemma dconj_conj n b (x: vect n) : (x ^_ b) ^d_ b = (-(1))^n .* x.

Lemma dconj_hom n b k (x: vect n) : hom n k x -> hom n k (x ^d_ b).

Hint Resolve dconj_hom.

Lemma dconjf_joinl n (x y: vect n) : (x ∨ y) ^d_'f = x ^d_'f ∨ y ^_'f.

Lemma dconjf_joinr n (x y: vect n) : (x ∨ y) ^d_'f = x ^_'f ∨ y ^d_'f.

Lemma conj_dual n b (x: vect n): '@(x ^_ b) = '@x ^d_ b.

Lemma dconj_dual n b (x: vect n) : '@(x ^d_ b) = '@x ^_ b.

Lemma dualk n k : '@([k]) = k .* E :> vect n.

Definition dconst n (x: vect n) := 'C['@x].
Notation "'dC[ x ]" := (dconst _ x).

Lemma dconjk n b k :
  [k] ^d_ b = (if b then [(-(1))^n.+1 * k] else [(-(1))^n * k]:vect n).

Lemma dconj_const n b (x: vect n) :
  'C[x ^d_ b] = (if b then ((-(1))^n.+1 * 'C[x])%f else ((-(1))^n * 'C[x])%f).

Lemma conj_dconst n b (x: vect n) :
  'dC[x ^_ b] = (if b then ((-(1))^n.+1 * 'dC[x])%f else  ((-(1))^n * 'dC[x])%f).

Lemma dconj_dconst n b (x: vect n) :
  'dC[x ^d_ b] = (if b then (- 'dC[x])%f else  'dC[x]).

Lemma projn n (x : vect n) : proj n n x = 'dC[x] :: nil.

Lemma dconst_all n : 'dC[(E: vect n)] = 1%f .

Lemma dconst0 n : 'dC[0:vect n] = 0%f.

Hint Rewrite dconst0: GRm0.

Lemma dconst_scal n k (x: vect n) : 'dC[k .* x] = (k * 'dC[x])%f.

Lemma dconst_add n (x1 x2 : vect n) : 'dC[x1 + x2] = ('dC[x1] + 'dC[x2])%f.

Lemma dconst_hom n k x : hom n k x -> n <> k -> 'dC[x] = 0%f.

Lemma homn_all n x : hom n n x -> x = 'dC[x] .* E.

Lemma const_dual n (x: vect n) : 'C['@x] = 'dC[x].

Lemma dconst_dual n (x: vect n) : 'dC['@x] = 'C[x].

Fixpoint meet (n : nat) : vect n -> vect n -> vect n :=
  match n return (vect n -> vect n -> vect n) with
  | 0%nat => fun a b => (a * b)%f
  | S n1 =>
      fun v1 v2 => 
      let (x1, y1) := v1 in
      let (x2, y2) := v2 in (meet n1 x1 x2,
                                meet n1 x1 y2 +
                                meet n1 y1 (x2 ^d_'f))
  end.

Notation "x '∧' y" := (meet _ x y) (at level 45, left associativity).

Lemma meet0l n (x: vect n) : 0 ∧ x = 0.

Hint Rewrite meet0l: GRm0.

Lemma meet0r n (x: vect n) : x ∧ 0 = 0.

Hint Rewrite meet0r: GRm0.

Lemma meet1l n (x: vect n) : 1 ∧ x = ['C['@x]].

Lemma meet1r n (x: vect n) : x ∧ 1 = ['C['@x]].

Lemma meet_scall n k (x y : vect n) : k .* x ∧ y = k .* (x ∧ y).

Lemma meet_scalr n k (x y : vect n) : x ∧ k .* y = k .* (x ∧ y).

Lemma meet0 (v1 v2 : vect 0) : v1 ∧ v2 = (v1 * v2)%f.

Lemma meetS n (x1 x2 y1 y2 : vect n) :
 ((x1,y1): vect n.+1) ∧ (x2,y2) = 

Lemma dual_meet n (v1 v2 : vect n) : '@(v1 ∧ v2) = '@v1 ∨ '@v2.

Lemma conjf_meetl n (x y : vect n) : (x ∧ y) ^_'f = x ^_'f ∧ y ^d_'f.

Lemma conjf_meetr n (x y : vect n) : (x ∧ y) ^_'f = x ^d_'f ∧ y ^_'f.

Lemma dconjf_meet n (x y : vect n) : (x ∧ y) ^d_'f = x ^d_'f ∧ y ^d_'f.
   
Lemma dconjf_meetd n (x y : vect n) : (x ∧ y) ^d_'f = x ^_'f ∧ y ^_'f.

Lemma dconst_meet n (x y: vect n) : 'dC[x ∧ y] = ('dC[x] * 'dC[y])%f.

Lemma dual_join n (v1 v2: vect n) : '@(v1 ∨ v2) = '@v1 ∧ '@v2.

Lemma meet_addl n (x y z : vect n) : (x + y) ∧ z = x ∧ z + y ∧ z.

Lemma meet_addr n (x y z : vect n) : z ∧ (x + y) = z ∧ x + z ∧ y.

Lemma meet_assoc n (x y z : vect n) : x ∧ y ∧ z = x ∧ (y ∧ z).

Lemma meet_alll n (x: vect n) : all n ∧ x = x.

Lemma meet_allr n (x: vect n) : x ∧ all n = x.

Lemma meet_small n k1 k2 (x y : vect n) : 
  hom n k1 x -> hom n k2 y -> k1 + k2 < n -> x ∧ y = 0.

Lemma meet_hom n k1 k2 (x y : vect n) : 
  hom n k1 x -> hom n k2 y -> hom n (k1 + k2 - n) (x ∧ y).

Hint Resolve meet_hom.

Lemma meetkl0 n k1 k2 x : hom n k1 x -> n <> k1 -> [k2] ∧ x = 0.

Lemma meetkl n k x : hom n n x -> [k] ∧ x = [k * 'dC[x]].

Lemma meetkr0 n k1 k2 x : hom n k1 x -> n <> k1 -> x ∧ [k2] = 0.

Lemma meetkr n k x : hom n n x -> x ∧ [k] = ['dC[x] * k].

Lemma meet_hom_com n k1 k2 (x y : vect n) :
  hom n k1 x ->
  hom n k2 y -> y ∧ x = ((- (1))^((n + k1) * (n + k2))).* (x ∧ y).

Lemma meet_hom_id n k x : hom n k x -> odd (n - k) ->  x ∧ x = 0.

Lemma dual_join_compl n k v :
  In v (base n k) -> (v ∨ '@v = all n) \/ v ∨ '@v = (-(1)) .*  all n.

Lemma join01E n x y : hom n 1 x -> hom n 1 y -> 
   x ∨ y = 0 -> exists k, x = k .* y \/ y = k .* x.

Lemma homn_1 n k1 k2 x y : 
  hom n k1 x -> hom n k2 y -> n = (k1 + k2)%nat -> x ∧ y = 'dC[x ∨ y] .* 1.

Lemma join2_meetE n k1 k2 (x y : vect n) : 
  hom n k1 x -> hom n k2 y -> n <= k1 + k2 ->  x ∨ y = (x ∧ y) ∨ E.

Lemma join_meet_swap n k1 k2 k3 (x y z : vect n) : 
   hom n k1 x -> hom n k2 y ->  hom n k3 z -> (k1 + k2 + k3 = n)%nat -> 
    x ∧ (y ∨ z) = (x ∨ y) ∧ z.

Lemma join3_meetE n k1 k2 (x y z : vect n) : 
  hom n n x -> hom n k1 y -> hom n k2 z ->  n <= k1 + k2 ->  
  x ∧ (y ∨ z) = (x ∧ y ∧ z) ∨ E.

Lemma splitlr n k1 k2 x y z : hom n k1 x -> hom n 1 y ->  hom n k2 z ->
  (x ∨ y) ∧ z = (-(1))^(n + (k1 + k2).+1) .* (x ∧ (y ∨ z)) +

Lemma splitll n k1 k2 x y z : hom n k1 x -> hom n 1 y ->  hom n k2 z ->
  (y ∨ x) ∧ z = (-(1))^(n + k2.+1) .* ((x ∧ (y ∨ z)) - y ∨ (x ∧ z)).

Lemma splitrr n k1 k2 x y z : hom n k1 x -> hom n 1 y ->  hom n k2 z ->
  z ∧ (x ∨ y) = (-(1))^(n + k2.+1) .* ((z ∨ y) ∧ x - (z ∧ x) ∨ y).

Lemma splitrl n k1 k2 x y z : hom n k1 x -> hom n 1 y ->  hom n k2 z ->
  z ∧ (y ∨ x) = (-(1))^(n + (k1 + k2).+1) .* (z ∨ y) ∧ x + y ∨ (z ∧ x).

Lemma inter n k1 k2 x y z : hom n 1 x -> hom n k1 y ->  hom n k2 z ->
  x ∨ y = 0 -> x ∨ z = 0 -> x ∨ (y ∧ z) = 0.

Lemma join_meet_distrl n k1 k2 x y z :
   hom n k1 x -> hom n 1 y ->  hom n k2 z ->
    y ∨ (x ∧ z) = (-(1))^(n + k2) .* ((y ∨ x) ∧ z)  +  x ∧ (y ∨ z).

Lemma meet_join_distrl n k1 k2 x y z :
  hom n k1 x -> hom n 1 y ->  hom n k2 z ->
  '@y ∧ (x ∨ z) = (-(1))^k2 .* (('@y ∧ x) ∨ z)  +  x ∨ ('@y ∧ z).
 
Lemma grade_dual n k x : k < n -> grade n k x -> grade n (n - k) '@x.

Lemma grade_meet n k1 k2 x y : n < k1 + k2 ->
  grade n k1 x -> grade n k2 y -> grade n (k1 + k2 - n) (x ∧ y).

Definition Kn := kn p.

Fixpoint k2g (n: nat) {struct n} : kn n ->  vect n :=
  match n return kn n -> vect n with 
    O => fun k => 0%f
  | S n1 => fun v => let (k, v1) := v in ([k], k2g n1 v1)
  end.

Notation "'v_ x" := (k2g _ x) (at level 9). 
Notation "'kn n" := (vn_eparams p (pred n)) (at level 10).

Lemma k2g0 n : 'v_0 = 0 :> vect n.

Lemma k2g_add n x y : 'v_(x + y) = 'v_x + 'v_y :> vect n. 

Lemma k2g_scal n k x : 'v_(k .* x) = (k: K) .* 'v_x :> vect n.

Lemma k2g_unit n i : i < n -> 'v_('e_i)%Kn = 'e_i :> vect n.

Lemma k2g_hom n x : hom n 1 ('v_x).

Lemma hom1E n x : hom n 1 x -> exists y, x = 'v_y.

Lemma k2glift n x : 'v_(Kn.lift p n x) = ('v_x)^'l.

Lemma pscal_join n x y : 'v_x ∨ '@('v_y) =  ((x [.] y)%Kn:K) .* E :> vect n.

Lemma pscal_meet n x y : 'v_x ∧ '@('v_y) =  ((x [.] y)%Kn:K) .* 1 :> vect n.

Definition V0 := genk (dim p) 0.

Definition V1 := genk (dim p) 1.
Definition Vect := vect p.

Definition Veq: Vect -> Vect -> bool := eq p.

Definition Vadd: Vect -> Vect -> Vect := add p.

Definition Vscal: K -> Vect -> Vect := scal (dim p).

Definition Vgen := gen p.
Definition Vgenk := genk p.

Definition Vconj: bool -> Vect -> Vect := conj (dim p).

Definition Vjoin: Vect -> Vect -> Vect := join (dim p).
Definition Vmeet: Vect -> Vect -> Vect := meet (dim p).
Definition Vcontra: Kn -> Vect -> Vect := contra (dim p).
Definition Vdual: Vect -> Vect := dual (dim p).
Definition Vdecompose: Vect -> option (list Vect) := decompose (dim p).
Definition K2G: Kn -> Vect  := k2g p.

Definition v_eparams :=
  Build_eparams Vect K V0 Veq Vadd Vscal.

Definition f: vparamsProp (Kn.v_eparams p) := (Kn.fn p Hp p).

End Vect.

Delimit Scope Gn_scope with Gn.
Notation " 'e_ p" := (gen _  _ p) : Gn_scope.
Notation " [ k ] " := (genk _ _ k) (at level 9) : Gn_scope.

Require Import QArith.

Open Scope Q_scope.

Definition Qparams (n:nat) := Build_params 
   n
  (Build_fparams
  Q 
  0%Q
  1%Q
 Qeq_bool
 Qopp
 Qplus
 Qmult
 Qinv)
.

Module Ex2D.

Local Definition p := Qparams 2.

Notation "[[ X: x , Y: y , X**Y: xy ]]" :=  ((xy,x),(y,0)).

Definition X := (Vgen p 0).
Eval compute in X.
Definition Y := (Vgen p 1).
Eval compute in Y.

Notation "x '∨' y" := (Vjoin p  x y) (at level 40, left associativity).
Notation "x + y" := (Vadd p  x y).
Notation "k .* x" := (Vscal p  k x).
Notation "x '∧' y" := (Vmeet p  x y) (at level 40, left associativity).
Notation "'@  x" := (Vdual p x) (at level 100).

Eval vm_compute in (X ∨ Y) ∧ (X ∨ Y).

Eval vm_compute in '@(X + Y).

Eval vm_compute in (X + Y) ∨ '@(X + Y).

End Ex2D.

Module Ex3D.

Local Definition p := Qparams 3.

Notation "[[ X: x , Y: y ,  Z: z , X**Y: xy , Y**Z: yz  , X**Z: xz , X**Y**Z: xyz ]]" :=
  ((((xyz,xy),(xz,x)), ((yz,y),(z,0)))).

Definition X := (Vgen p 0).
Eval compute in X.
Definition Y := (Vgen p 1).
Eval compute in Y.
Definition Z := (Vgen p 2).
Eval compute in Z.

Notation "x '∨' y" := (Vjoin p  x y) (at level 40, left associativity).
Notation "x + y" := (Vadd p  x y).
Notation "k .* x" := (Vscal p  k x).
Notation "x '∧' y" := (Vmeet p  x y) (at level 40, left associativity).
Notation "'@  x" := (Vdual p x) (at level 100).

Eval vm_compute in '@(Vgen p 3).

Eval vm_compute in (X ∨ Z) ∧ (Y ∨ Z).

Eval vm_compute in '@((X∨Y)∧ ( Z)).

Eval vm_compute in (X + Y) ∨ '@(X + Y).

Eval vm_compute in Vdecompose p ((X ∨ Y) ∧ (Y ∨ Z)).

Eval vm_compute in Vdecompose p ((X + Y) ∨ (X + Z)).

Eval vm_compute in Vdecompose p ((X + Y + Z) ∨ (X + Z) ∨ (X + Y)).

Eval vm_compute in Vdecompose p ((X + Y) ∨ (Y + Z)).

Eval vm_compute in (X + Y) ∨ (X + Z) + 
  (-1#1)%Q .* (((-1#1)%Q .* Y + Z) ∨ ((-1#1)%Q .* (X + Y))).

Eval vm_compute in ((-1#1)%Q .* Y + Z) ∨ (X + Y) ∨ (X + Z).

Eval vm_compute in (X ∨ Y ∨ Z) ∨ (X ∨ Y ∨ Z).
Eval vm_compute in (X + Y + Z) ∨ (X + Y + Z).
Eval vm_compute in Z ∨ Y ∨ X.
Eval vm_compute in X ∨ Z.
Eval vm_compute in Z ∨ X.
Eval vm_compute in X ∨ Y ∨ Z.
Eval vm_compute in Z ∨ X ∨ Y.
Eval vm_compute in Y ∨ X ∨ Z.
Eval vm_compute in Y ∨ X.

End Ex3D.

Module Ex4D.

Local Definition p := Qparams 4.

Notation " '[[' 'X:' x ',' 'Y:' y ','  'Z:' z , 'T:' t ',' 'X**Y:' xy ',' 'X**Z:' xz ',' 'X**T:' xt ',' 'Y**Z:' yz ',' 'Y**T:' yt ',' 'Z**T:' zt ',' 'X**Y**Z:' xyz ',' 'X**Y**T:' xyt ',' 'X**Z**T:' xzt ',' 'Y**Z**T:' yzt ','  'X**Y**Z**T:' xyzt ','  'K:' vv  ']]'" :=
 ((((xyzt, xyz), (xyt, xy)), ((xzt, xz), (xt, x))) , 
  (((yzt, yz), (yt, y)), ((zt,z), (t, vv)))).

Definition X := (Vgen p 0).
Eval compute in X.
Definition Y := (Vgen p 1).
Eval compute in Y.
Definition Z := (Vgen p 2).
Eval compute in Z.
Definition T := (Vgen p 3).
Eval compute in T.

Notation "x '∨' y" := (Vjoin p  x y) (at level 40, left associativity).
Notation "x + y" := (Vadd p  x y).
Notation "k .* x" := (Vscal p  k x).
Notation "x '∧' y" := (Vmeet p  x y) (at level 40, left associativity).
Notation "'@  x" := (Vdual p x) (at level 100).
Notation "#< l , x ># " := (Vcontra p l x).

Eval vm_compute in '@X.

Eval vm_compute in (X + Y) ∨ '@(X + Y).

Definition X' := (1, (0, (0, (0, tt)))).
Definition Y' := (0, (1, (0, (0, tt)))).
Definition Z' := (0, (0, (1, (0, tt)))).
Definition T' := (0, (0, (0, (1, tt)))).

Definition U := (X + Y) ∨ Z.

Eval vm_compute in U.

Definition fxy := #<Y', #< X', U ># >#.
Definition fxz := #<Z', #< X', U ># >#.
Definition fxt := #<T', #< X', U ># >#.
Definition fyz := #<Z', #< Y', U ># >#.
Definition fyt := #<T', #< Y', U ># >#.
Definition fzt := #<T', #< Z', U ># >#.

Eval vm_compute in fxy.

Eval vm_compute in #< Y', X>#.

Eval vm_compute in (X ∨ Y ∨ Z) ∨ (X ∨ Y ∨ Z).

Eval vm_compute in (X + Y + Z) ∨ (X + Y + Z).
Eval vm_compute in Z ∨ Y ∨ X.
Eval vm_compute in X ∨ Z.
Eval vm_compute in Z ∨ X.
Eval vm_compute in X ∨ Y ∨ Z.
Eval vm_compute in Z ∨ X ∨ Y.
Eval vm_compute in Y ∨ X ∨ Z.
Eval vm_compute in Y ∨ X.
Eval vm_compute in X ∨ T.
Eval vm_compute in T ∨ X.

Eval vm_compute in Vconj p false (Z ∨ T) ∨ (X ∨ Y).

Eval vm_compute in (X ∨ Y ∨ Z ∨ T) ∨ (X ∨ Y ∨ Z ∨ T).

End Ex4D.

Module Ex5D.

Local Definition p := Qparams 5.

Notation " [[ X: x , Y: y ,  Z: z , T: t , U: u , X**Y: xy , X**Z: xz , X**T: xt , X**U: xu , Y**Z: yz , Y**T: yt , Y**U: yu , Z**T: zt , Z**U: zu , T**U: tu , X**Y**Z: xyz , X**Y**T: xyt , X**Y**U: xyu , X**Z**T: xzt , X**Z**U: xzu , X**T**U: xtu , Y**Z**T: yzt , Y**Z**U: yzu , Y**T**U: ytu , Z**T**U: ztu , X**Y**Z**T: xyzt , X**Y**Z**U: xyzu , X**Y**T**U: xytu , X**Z**T**U: xztu , Y**Z**T**U: yztu , X**Y**Z**T**U: xyztu , 'K:' vv ]]" :=
(
 ((((xyztu, xyzt), (xyzu, xyz)), ((xytu, xyt), (xyu, xy))) , 
  (((xztu, xzt), (xzu, xz)), ((xtu,xt), (xu, x)))),
 ((((yztu, yzt), (yzu, yz)), ((ytu, yt), (yu, y))) , 
  (((ztu, zt), (zu, z)), ((tu,t), (u, vv))))).

Definition X := (Vgen p 0).
Eval compute in X.
Definition Y := (Vgen p 1).
Eval compute in Y.
Definition Z := (Vgen p 2).
Eval compute in Z.
Definition T := (Vgen p 3).
Eval compute in T.
Definition U := (Vgen p 4).
Eval compute in U.

Notation "x '∨' y" := (Vjoin p  x y) (at level 40, left associativity).
Notation "x + y" := (Vadd p  x y).
Notation "k .* x" := (Vscal p  k x).
Notation "x '∧' y" := (Vmeet p  x y) (at level 40, left associativity).
Notation "'@  x" := (Vdual p x) (at level 100).

Eval vm_compute in Vconj p false (T ∨ U) ∨ (X ∨ Y ∨ Z).
Eval vm_compute in Vconj p false (X ∨ Y ∨ Z ∨ T ∨ U).

End Ex5D.

Module Ex6D.

Local Definition p := Qparams 6.

Definition X := (Vgen p 0).
Eval compute in X.
Definition Y := (Vgen p 1).
Eval compute in Y.
Definition Z := (Vgen p 2).
Eval compute in Z.
Definition T := (Vgen p 3).
Eval compute in T.
Definition U := (Vgen p 4).
Eval compute in U.
Definition K := (Vgen p 5).
Eval compute in K.

Notation "x '∨' y" := (Vjoin p  x y) (at level 40, left associativity).
Notation "x + y" := (Vadd p  x y).
Notation "k .* x" := (Vscal p  k x).
Notation "x '∧' y" := (Vmeet p  x y) (at level 40, left associativity).
Notation "'@  x" := (Vdual p x) (at level 100).

Eval vm_compute in 
  ((X ∨ (Y ∨ Z ∨ T)) + (U ∨ K)) ∨
  ((X ∨ (Y ∨ Z ∨ T)) + (U ∨ K)).

Eval vm_compute in Vconj p false (T ∨ U) ∨ (X ∨ Y ∨ Z).
Eval vm_compute in Vconj p false (X ∨ Y ∨ Z ∨ T ∨ U).

Eval vm_compute in
  ((X ∨ T) + (Y ∨ Z)) ∨ ((X ∨ T) + (Y ∨ Z)).

End Ex6D. *)
(* G3:
Require Import Div2 Bool Even Setoid Min List Aux Field VectorSpace Grassmann.
Require Import Field_tac.

Section Vect.

Variable F: fparams.

Hypothesis FT:
  @field_theory (Field.K F) (v0 F) (v1 F) (addK F) (multK F)
        (fun x y => (addK F) x (oppK F y)) (oppK F) 
        (fun x y => (multK F) x (invK F y)) (invK F) (@Logic.eq F).
Add Field Kfth : FT.

Definition Pp: params :=  {| dim := 3; K := F |}.
Variable HP : fparamsProp Pp.

SubClass point := Kn Pp.
SubClass vect := Vect Pp.

Definition Vjoin (x y : vect): vect := Vjoin Pp x y.
Notation "x '∨' y" := (Vjoin x y) (at level 40, left associativity).
Definition Vadd (x y : vect): vect := Vadd Pp x y.
Notation "x + y" := (Vadd x y).
Definition Vsub (x y : vect): vect := sub Pp Pp x y.
Notation "x - y" := (Vsub x y).
Definition Vscal (k : F) (x : vect): vect := Vscal Pp k x.
Notation "k .* x" := (Vscal k x).
Definition Vmeet (x y : vect): vect := Vmeet Pp x y.
Notation "x '∧' y" := (Vmeet x y) (at level 45, left associativity).
Definition Vdual (x : vect): vect := Vdual Pp x.
Notation "'@  x" := (Vdual x) (at level 9).
Definition Veq (x y : vect): bool := Veq Pp x y.
Notation "x ?= y" := (Veq x y).
Definition Vgenk (k : F): vect := (Vgenk Pp k).
Notation "0" := (Vgenk 0%f).
Notation "1" := (Vgenk 1%f).
Definition hom (n: nat) (x : vect) := (hom Pp Pp n x).
Notation "'dC[ x ]" := (dconst Pp 3 x).
Notation "'C[ x ]" := (const Pp 3 x).
Notation "'E'" := (all Pp 3: vect).

Coercion p2v (x : point) := (K2G Pp x): vect.

Let scal0l x : 0%f .*  x = 0.

Let scal1l x : 1%f .*  x = x.

Let scal_integral k x : k .* x = 0 -> {k = 0%f} + {x = 0}.

Lemma sub_add x y : x - y = x + (-(1))%f .* y.

Lemma join1l x : 1 ∨ x = x.

Lemma join1r x : x ∨ 1 = x.

Lemma join_addl x y z : (x + y) ∨ z = x ∨ z + y ∨ z.

Lemma join_addr x y z : z ∨ (x + y) = z ∨ x + z ∨ y.

Lemma join_scall k x y : k .* x ∨ y = k .* (x ∨ y).

Lemma join_scalr k x y : x ∨ (k .* y) = k .* (x ∨ y).

Theorem join_swap (x y : point) : x ∨ y = (-(1))%f .* (y ∨ x).

Let join_id: forall (x : point), x ∨ x = 0.

Let add_com x y : x + y = y + x.

Let add_assoc x y z : x + y + z = x + (y + z).

Let add0l x : 0 + x = x.

Let add0r x : x + 0 = x.

Let scal_mul k1 k2 x : (k1 * k2)%f .* x = k1.* (k2 .* x).

Let scal0r k : k .*  0 = 0.

Let join0r x : x ∨ 0 = 0.

Let join0l x : 0 ∨ x = 0.

Let join_assoc x y z : (x ∨ y) ∨ z =  x ∨ (y ∨ z).

Let scal_addl k1 k2 x : (k1 + k2)%f .* x = k1.* x + (k2 .* x).

Let scal_addr k x y : k .* (x + y) = k.* x + (k .* y).

Let scal_mult k1 k2 x : (k1 * k2)%f .* x = k1 .* (k2 .* x).

Let meet_assoc x y z : (x ∧ y) ∧ z =  x ∧ (y ∧ z).

Let meet_alll x : (E ∧ x) = x.

Let meet_allr x : (x ∧ E) = x.

Lemma meet_scall k x y : k .* x ∧ y = k .* (x ∧ y).

Lemma meet_scalr k x y : x ∧ k .* y = k .* (x ∧ y).

Lemma meet_addr x y z : z ∧ (x + y) = z ∧ x + z ∧ y.

Lemma meet_addl x y z : (x + y) ∧ z = x ∧ z + y ∧ z.

Lemma hom3_1 k1 k2 x y : hom k1 x -> hom k2 y -> 3 = (k1 + k2)%nat -> 
   x ∧ y = 'dC[ x ∨ y] .* 1.

Lemma splitrr k1 k2 x y z : hom k1 x -> hom 1 y ->  hom k2 z ->
  z ∧ (x ∨ y) = ((-(1))^(3 + k2.+1))%f .* ((z ∨ y) ∧ x - (z ∧ x) ∨ y).

Lemma dual_invoE k v: hom k v ->  v = ((-(1)) ^(k * 3.+1))%f .* '@('@v).

Lemma meet_join_distrl k1 k2 x y z : hom k1 x -> hom 1 y ->  hom k2 z ->
  '@y ∧ (x ∨ z) = ((-(1))^k2)%f .* (('@y ∧ x) ∨ z)  +  x ∨ ('@y ∧ z).

Lemma const1 x : 'C[x .* 1] = x.

Definition bracket x y z : F := 'dC[x ∨ y ∨ z].

Notation "'E'" := (all Pp 3: vect).
Notation "'[ x , y , z ]" := (bracket x y z).

Lemma hom3E: hom 3 E.

Lemma hom3l x y : hom 1 x -> hom 2 y -> hom 3 (x ∨ y).

Lemma hom3r x y : hom 2 x -> hom 1 y -> hom 3 (x ∨ y).

Lemma hom2 x y : hom 1 x -> hom 1 y -> hom 2 (x ∨ y).

Lemma hom1p (x : point) : hom 1 x.

Lemma hom1d x y : hom 2 x -> hom 2 y -> hom 1 (x ∧ y).

Lemma hom0l x y : hom 1 x -> hom 2 y -> hom 0 (x ∧ y).

Lemma hom0r x y : hom 2 x -> hom 1 y -> hom 0 (x ∧ y).

Lemma hom0p x y : hom 0 x -> hom 0 y -> hom 0 (x ∨ y).

Lemma hom01 : hom 0 1.

Lemma hom0_E x : hom 0 x -> x ∨ E = 0 -> x = 0.

Lemma homd k x : hom k x -> hom (3 - k) '@x.

Ltac homt :=
  first [ apply scal_hom; auto; homt | 
          apply add_hom; auto; homt  |
          apply hom3E                 |
          apply hom3l; homt           |
          apply hom3r; homt           |
          apply hom2; homt            |
          apply hom1p                 |
          apply hom1d; homt           |
          apply hom0l; homt           |
          apply hom0r; homt           |
          apply hom0p; homt           |
          apply hom01                 |
          apply homd
   ].

Ltac hom3t :=  
  apply proj_homn_eq; auto; try homt.

Ltac hom0t := 
  apply proj_hom0_eq; auto; try homt. 

Lemma bracket_defE (x y z : point) :
  x ∨ y ∨ z =  '[x,y,z] .* E.

Lemma bracket_defl (x y z : point) :
  x ∧ (y ∨ z) = '[x, y, z] .* 1.

Lemma bracket_defr (x y z : point) :
  (x ∨ y) ∧ z = '[x, y, z] .* 1.

Lemma bracket0l (a b: point) : '[a,a,b] = 0%f.

Lemma bracket0m (a b: point) : '[a,b,a] = 0%f.

Lemma bracket0r (a b: point) : '[a,b,b] = 0%f.

Lemma bracket_swapl (x y z : point) : '[y,x,z] = (- ('[x,y,z]))%f.

Lemma bracket_swapr (x y z : point) : '[x,z,y] = (- ('[x,y,z]))%f.

Lemma bracket_norm (a b c: point) : 
  ('[a,c,b] =  (-(1)) * '[a,b,c] /\
  '[b,a,c] = (-(1))%f * '[a,b,c] /\
  '[b,c,a] = '[a,b,c] /\
  '[c,a,b] = '[a,b,c] /\
  '[c,b,a] = (-(1))%f * '[a,b,c])%f.

Ltac normb a b c :=
 generalize (bracket_norm a b c); 
 intros (Hn1, (Hn2, (Hn3, (Hn4, Hn5))));
 rewrite ?Hn1, ?Hn2, ?Hn3, ?Hn4, ?Hn5;
 clear Hn1 Hn2 Hn3 Hn4 Hn5.

Definition fbracket a b c:= '[a, b, c].

Lemma fbracket_norm (a b c: point) : 
  ('[a,b,c] =  fbracket a b c /\
  '[a,c,b] =  (-(1)) *  (fbracket a b c) /\
  '[b,a,c] = (-(1))%f * (fbracket a b c) /\
  '[b,c,a] = (fbracket a b c) /\
  '[c,a,b] = (fbracket a b c) /\
  '[c,b,a] = (-(1))%f * (fbracket a b c))%f.

Ltac normbs :=
repeat match goal with |- context['[p2v ?a,p2v ?b,p2v ?c]] =>
 generalize (fbracket_norm a b c); 
 intros (Hn1, (Hn2, (Hn3, (Hn4, (Hn5, Hn6)))));
 rewrite ?Hn1, ?Hn2, ?Hn3, ?Hn4, ?Hn5, ?Hn6;
 clear Hn1 Hn2 Hn3 Hn4 Hn5 Hn6
end; unfold fbracket.

Lemma expand_meetr (x y x1 y1: point) :
(x ∨ y1) ∧ (x1 ∨ y) = '[x,y1,y] .* x1 - '[x,y1,x1] .* y.

Lemma meet_swap (x y x1 y1: point) :
  (x ∨ y1) ∧ (x1 ∨ y) =  (-(1))%f .* (x1 ∨ y) ∧ (x ∨ y1).

Lemma expand_meetl (x y x1 y1: point) :
  (x1 ∨ y) ∧ (x ∨ y1) = '[x,y1,x1] .* y - '[x,y1,y] .* x1.

Lemma split_meetl (x1 x2 x3 x4 x5 x6: point) :
  (x1 ∨ x2) ∧ (x3 ∨ x4) ∧ (x5 ∨ x6) =
     (x1 ∧ (x3 ∨ x4)) ∨ (x2 ∧ (x5 ∨ x6)) +
     (-(1))%f .*  ((x2 ∧ (x3 ∨ x4)) ∨ (x1 ∧ (x5 ∨ x6))).

Lemma split_meetr (x1 x2 x3 x4 x5 x6: point) :
  ((x1 ∨ x2) ∧ (x3 ∨ x4)) ∧ (x5 ∨ x6) =
     ((x1 ∨ x2) ∧ x5) ∨ ((x3 ∨ x4) ∧ x6) +
     (-(1))%f .* ((x3 ∨ x4) ∧ x5) ∨ ((x1 ∨ x2) ∧ x6).

Lemma meet_swapr (x y x1 y1: point) :
  (x ∨ x1) ∧ (y ∨ y1) = (x1 ∨ x) ∧ (y1 ∨ y).

Lemma join_meet3l (a b c d e f: point) :
  (a ∨ b) ∨ ((c ∨ d) ∧ (e ∨ f)) = ((a ∨ b) ∧ (c ∨ d) ∧ (e ∨ f)) ∨ E.

Lemma join_meet3r (a b c d e f: point) :
  ((a ∨ b) ∧ (c ∨ d)) ∨ (e ∨ f) = ((a ∨ b) ∧ (c ∨ d) ∧ (e ∨ f)) ∨ E.

Lemma split3l (a b c d : point) :
  (a ∨ b ∨ c) ∧  d = '[b,c,d] .* a - '[a,c,d] .* b + '[a,b,d] .* c.

Lemma split3b (a b c d e f : point) :
  ('[a,b,c] * '[d,e,f] = 
   '[b,c,d] * '[a,e,f] + (-(1)) * '[a,c,d] * '[b,e,f] + '[a,b,d] * '[c,e,f])%f.

Lemma split3b_v1 (a b c d e f : point) :
  ('[a,b,c] * '[d,e,f] = 
   '[a,d,e] * '[b,c,f] + (-(1)) * '[a,d,f] * '[b,c,e] + '[a,e,f] * '[b,c,d])%f.

Lemma split3b_v2 (a b c d e f : point) :
  ('[a,b,c] * '[d,e,f] = 
   '[a,b,d] * '[c,e,f] + (-(1)) * '[a,b,e] * '[c,d,f] + '[a,b,f] * '[c,d,e])%f.

Lemma bracket_expand (x a b c d a1 b1: point) :
 x = (a ∨ b) ∧ (c ∨ d) :> vect ->
 ('[x, a1, b1] =
   (-(1)) * '[a, a1, b1] * '[b, c, d]  + '[b, a1, b1] * '[a, c, d])%f.

Lemma bracket_free (x : point) k1 (a: point) k2 (b a1 b1: point) :
 x = k1 .* a + k2 .* b :> vect ->

Lemma contraction_v0  (a b c d e: point) :
  ('[a, b, c] * '[a, d, e] + -(1) * '[a, b, e] * '[a, d, c] =
   '[a, b, d] * '[a, c, e])%f.

Lemma contraction_v1  (a b c d e: point) :
  ('[a, b, c] * '[b, d, e] + -(1) * '[a, b, e] * '[b, d, c] =
   '[a, b, d] * '[b, c, e])%f.

Lemma contraction_v2  (a b c d e: point) :
  ('[a, b, c] * '[d, b, e] + - (1) * '[a, b, e] * '[d, b, c] =
   '[b, a, d] * '[b, c, e])%f.

Lemma contraction_v3  (a b c d e: point) :
  ('[a, b, c] * '[d, a, e] + - (1) * '[a, b, e] * '[d, a, c] =
   '[a, b, d] * '[c, a, e])%f.

Definition collinear x y z := x ∨ y ∨ z = 0.
Definition line (x y : point) := x ∨ y.
Definition intersection (x y : vect) := x ∧ y.
Definition concur (l1 l2 l3 : vect) := l1 ∧ l2 ∧ l3 = 0.
Definition online (x y z : point) := y ∨ z <> 0 /\ x ∨ y ∨ z = 0.
Definition online1 (x : point) k1 (y : point) k2 (z : point) := 
  x = k1 .* y + k2 .* z :> vect.
Definition inter_lines (x a b c d : point) : Prop :=  
  x = (a ∨ b) ∧ (c ∨ d) :> vect.

Lemma online_def x y z :
  online x y z -> exists pk, online1 x (fst pk) y (snd pk) z.

Lemma collinear_bracket (x y z : point) :
  collinear x y z <-> '[x,y,z] = 0%f.

Lemma collinear_bracket0 (x y z : point) :
  collinear x y z -> '[x,y,z] = 0%f.

Lemma bracket0_collinear (x y z : point) :
  '[x,y,z] = 0%f -> collinear x y z.

Theorem Pappus (a b c a' b' c': point) :
  let AB' := line a b' in
  let A'B := line a' b in
  let p := intersection AB' A'B in
  let BC' := line b c' in
  let B'C := line b' c in
  let q := intersection BC' B'C in
  let CA' := line c a' in
  let C'A := line c' a in
  let r := intersection CA' C'A in
  collinear a b c -> collinear a' b' c' -> collinear p q r.

Theorem Desargues (a b c a' b' c': point) :
  let AB := line a b in
  let A'B' := line a' b' in
  let p := intersection AB A'B' in
  let AC := line a c in
  let A'C' := line a' c' in
  let q := intersection AC A'C' in
  let BC := line b c in
  let B'C' := line b' c' in
  let r := intersection BC B'C' in
  let AA' := line a a' in
  let BB' := line b b' in
  let CC' := line c c' in
  collinear p q r <-> collinear a b c \/ collinear a' b' c' \/ concur AA' BB' CC'.

End Vect.

Notation "x '∨' y" := (Vjoin _ x y) (at level 40, left associativity).
Notation "x + y" := (Vadd _ x y).
Notation "x - y" := (Vsub _ x y).
Notation "k .* x" := (Vscal _ k x).
Notation "x '∧' y" := (Vmeet _ x y) (at level 45, left associativity).
Notation "'@  x" := (Vdual _ x) (at level 9).
Notation "x ?= y" := (Veq _ x y).
Notation "0" := (Vgenk _ 0%f).
Notation "1" := (Vgenk _ 1%f).
Notation "'dC[ x ]" := (dconst _ _ 3 x).
Notation "'C[ x ]" := (const _ _ 3 x).
Notation "'E'" := (all _ _ 3: vect).
Notation "'[ x , y , z ]" := (bracket _ x y z).
Notation " x 'is_the_intersection_of' [ a , b ] 'and' [ c , d ] " := 
  (inter_lines _ x a b c d) (at level 10, format
                " x  'is_the_intersection_of'  [ a , b ]  'and'  [ c , d ]").
Notation " x 'is_free_on' [ a , b ]" := 
  (online _ x a b) (at level 10, format
             " x  'is_free_on'  [ a , b ]").
Notation " x ':=:' 'xfree' 'on' [ a , b ] ( c , d ) " := 
  (online1 _ x c a d b) (at level 10, format
             " x  ':=:'  'xfree'  'on'  [ a , b ]  ( c , d )").

Notation "'[' a , b , c ']' 'are_collinear' " := (collinear _ a b c) (at level 10). *)

Fixpoint natc (m n : nat) :=
match m, n with 0, 0 => Eq | 0, _ => Lt | _, 0 => Gt | S m1, S n1 => natc m1 n1 end.

Lemma natc_correct m n :
  match natc m n with Eq => m = n | Lt => m < n | Gt => n < m end.
Proof.
generalize n; clear n.
induction m as [|m IH]; intros [|n]; simpl; auto with arith.
generalize (IH n); case natc; auto with arith.
Qed.

Lemma natc_eq m n :
  match natc m n with
  | Eq => m = n
  | _ => True
  end.
Proof. generalize (natc_correct m n); case natc; auto. Qed.

Section FF.

Variable K : fparams.
Hypothesis FT :
  @field_theory (Field.K K) (v0 K) (v1 K) (addK K) (multK K)
        (fun x y => (addK K) x (oppK K y)) (oppK K) 
        (fun x y => (multK K) x (invK K y)) (invK K) (@Logic.eq K).
Add Field Kfth : FT.
Definition Pp : params :=  Build_params 2 K.
Variable HP : fparamsProp Pp.

Section Generic.

Variable tvar : Type.
Variable tvcompare : tvar -> tvar -> comparison.

Variable tvarn : tvar -> nat.
Hypothesis tvcompare_inj : forall v1 v2,
  tvarn v1 = tvarn v2 -> v1 = v2.
Hypothesis tvcompare_def : forall v1 v2,
  tvcompare v1 v2 = natc (tvarn v1) (tvarn v2).

Lemma tvcompare_eq v1 v2 :
  match tvcompare v1 v2 with Eq => v1 = v2 | _ => v1 <> v2 end.
Proof.
rewrite tvcompare_def.
generalize (natc_correct (tvarn v1) (tvarn v2)); case natc; auto.
intros H1 H2; contradict H1; rewrite H2; auto with arith.
intros H1 H2; contradict H1; rewrite H2; auto with arith.
Qed.

Lemma tvcompare_refl v : tvcompare v v = Eq.
rewrite tvcompare_def.
generalize (natc_correct (tvarn v) (tvarn v)); case natc; auto.
intros H; contradict H; auto with arith.
intros H; contradict H; auto with arith.
Qed.

Variable interv : tvar -> point K.
Notation "{v[ x ]}" := (interv x).

Variable var : Type.

Variable coef : Type.
Variable cadd : coef -> coef -> coef.
Variable czerop : coef -> bool.
Variable czero : coef.
Variable conep : coef -> bool.
Variable cone : coef.
Variable copp : coef -> coef.
Variable cscale : var -> coef -> coef.

Variable interk : var -> K.
Notation "{k[ x ]}" := (interk x).
Variable interc : coef -> K.
Notation "{c[ x ]}" := (interc x).
Hypothesis cadd_c : forall x y, {c[cadd x y]} = ({c[x]} + {c[y]})%f. 
Hypothesis cone_c : {c[cone]} = (1)%f.
Hypothesis conep_c : forall x,
  if conep x then {c[x]} = (1)%f else True.
Hypothesis czero_c : {c[czero]} = (0)%f.
Hypothesis cscale_c : forall k x, 
  {c[cscale k x]} = ({k[k]} * {c[x]})%f. 
Hypothesis czerop_c : forall x,
  if czerop x then {c[x]} = (0)%f else True.
Hypothesis copp_c : forall x, {c[copp x]} = (- {c[x]})%f. 

Inductive tuple := Tuple (_ _ _: tvar).
Let  line := list tuple.
Let  expr := list (coef * line).

Definition intert (t : tuple) :=
  let (p1,p2,p3) := t in '[{v[p1]},{v[p2]},{v[p3]}]. 
Notation "{t[ x ]}" := (intert x).

Fixpoint interl (l :line) :=
  match l with nil => 1%f | t ::l1 => ({t[t]} * interl l1)%f end.
Notation "{l[ x ]}" := (interl x).

Fixpoint intere (e :expr) :=
  match e with nil => 0%f | (c,l)::e1 =>
  ({c[c]} * {l[l]} + intere e1)%f 
  end.
Notation "{e[ x ]}" := (intere x).

Fixpoint intere1 (e :expr) :=
  match e with nil => 0%f | (c,t ::nil)::nil =>
    if conep c then {t[t]} else intere e 
  | _ => intere e end.
Notation "{e1[ x ]}" := (intere1 x).

Lemma intere1_c e : {e1[e]} = {e[e]}.
Proof.
elim e; simpl; auto.
intros (c,[|a [|b l]]) [|e1] IH; auto.
generalize (conep_c c); case conep; auto.
simpl.
intros HH; rewrite HH; ring.
Qed.

Inductive sign := Sm1 | S0 | S1.
Definition sopp s := match s with Sm1 => S1 | S0 => S0 | S1 => Sm1 end.
Definition smult s1 s2 := 
  match s1 with S0 => S0 | S1 => s2 | Sm1 => sopp s2 end.
Definition smult3 s1 s2 s3 := 
  match s1 with S0 => S0 
 | S1 => smult s2 s3
 | Sm1 => sopp (smult s2 s3) end.

Definition tin i (t : tuple) :=
  let (j1,j2,j3) := t in
  match tvcompare i j1 with Eq => true 
  | _ =>   match tvcompare i j2 with Eq => true 
  | _ =>   match tvcompare i j3 with Eq => true 
  | _ =>  false end end end.

Lemma tin_correct i1 i j k : 
  if tin i1 (Tuple i j k) then
        i1=i \/ i1 = j \/ i1 = k
  else
        i1<>i /\ i1 <> j /\ i1 <> k.
Proof.
unfold tin.
generalize (tvcompare_eq i1 i); case tvcompare; auto.
generalize (tvcompare_eq i1 j); case tvcompare; auto.
generalize (tvcompare_eq i1 k); case tvcompare; auto.
generalize (tvcompare_eq i1 k); case tvcompare; auto.
generalize (tvcompare_eq i1 j); case tvcompare; auto.
generalize (tvcompare_eq i1 k); case tvcompare; auto.
generalize (tvcompare_eq i1 k); case tvcompare; auto.
Qed.

Definition tsubst i j (t : tuple) :=
  let (i1,i2,i3) := t in
  match tvcompare i i1 with
  | Eq => Tuple j i2 i3
  | _ =>
      match tvcompare i i2 with
     | Eq => Tuple i1 j i3
     | _ =>
         match tvcompare i i3 with
         | Eq => Tuple i1 i2 j
         | _ => t
         end
     end
  end.
   
Definition s2k (s: sign) : K :=
  match s with S0 => 0%f | S1 => 1%f | Sm1 => (-(1))%f end.

Lemma tsubst_c i t :
  if tin i t then exists a, exists b, exists s, 
  ({t[t]} = s2k s * {t[Tuple i a b]} /\
   forall j, {t[tsubst i j t]} = s2k s * {t[Tuple j a b]})%f else True.
Proof.
destruct t as [a b c].
unfold tin, tsubst.
generalize (tvcompare_eq i a); case tvcompare; auto.
intros HH; subst.
exists b; exists c; exists S1; simpl s2k; Krm1.
split; try intros; Krm1.
intros HH.
generalize (tvcompare_eq i b); case tvcompare; auto.
intros HH1; subst.
exists a; exists c; exists Sm1; simpl s2k; Krm1.
split.
simpl; rewrite !(bracket_swapl _ HP {v[a]}); Krm1.
intros j; simpl; rewrite !(bracket_swapl _ HP {v[a]}); Krm1.
intros HH1.
generalize (tvcompare_eq i c); case tvcompare; auto.
intros HH2; subst.
exists a; exists b; exists S1; simpl s2k; split.
simpl; rewrite !(fun x => bracket_swapr _ HP {v[a]} x {v[b]}); Krm1.
rewrite !(bracket_swapl _ HP {v[a]}); Krm1.
intros j; simpl; rewrite !(fun x => bracket_swapr _ HP {v[a]} x {v[b]}); Krm1.
rewrite !(bracket_swapl _ HP {v[a]}); Krm1.
intros HH1.
generalize (tvcompare_eq i c); case tvcompare; auto.
intros HH2; subst.
exists a; exists b; exists S1; simpl s2k; Krm1.
split.
simpl.
rewrite !(fun x => bracket_swapr _ HP {v[a]} x {v[b]}); Krm1.
rewrite !(bracket_swapl _ HP {v[a]}); Krm1.
intros j.
simpl.
rewrite !(fun x => bracket_swapr _ HP {v[a]} x {v[b]}); Krm1.
rewrite !(bracket_swapl _ HP {v[a]}); Krm1.
intros HH.
generalize (tvcompare_eq i b); case tvcompare; auto.
intros HH1; subst.
exists a; exists c; exists Sm1; simpl s2k; Krm1.
split.
simpl.
rewrite !(bracket_swapl _ HP {v[a]}); Krm1.
intros j.
simpl.
rewrite !(bracket_swapl _ HP {v[a]}); Krm1.
intros HH1.
generalize (tvcompare_eq i c); case tvcompare; auto.
intros HH2; subst.
exists a; exists b; exists S1; simpl s2k; Krm1.
split.
simpl.
rewrite !(fun x => bracket_swapr _ HP {v[a]} x {v[b]}); Krm1.
rewrite !(bracket_swapl _ HP {v[a]}); Krm1.
intros j; simpl.
rewrite !(fun x => bracket_swapr _ HP {v[a]} x {v[b]}); Krm1.
rewrite !(bracket_swapl _ HP {v[a]}); Krm1.
intros HH1.
generalize (tvcompare_eq i c); case tvcompare; auto.
intros HH2; subst.
exists a; exists b; exists S1; simpl s2k; Krm1.
split.
simpl.
rewrite !(fun x => bracket_swapr _ HP {v[a]} x {v[b]}); Krm1.
rewrite !(bracket_swapl _ HP {v[a]}); Krm1.
intros j; simpl.
rewrite !(fun x => bracket_swapr _ HP {v[a]} x {v[b]}); Krm1.
rewrite !(bracket_swapl _ HP {v[a]}); Krm1.
Qed.

Definition mk_tuplel i1 i2 i3 :=
match tvcompare i1 i2 with
| Eq => (S0, Tuple i1 i2 i3)
| Lt => (S1, Tuple i1 i2 i3)
| Gt => 
  match tvcompare i1 i3 with
  | Eq => ( S0, Tuple i1 i2 i3)
  | Lt => (Sm1, Tuple i2 i1 i3)
  | Gt => ( S1, Tuple i2 i3 i1)
  end
end.

Lemma mk_tuplel_c i1 i2 i3 :
 let (s,t1) := mk_tuplel i1 i2 i3 in
 {t[Tuple i1 i2 i3]} = (s2k s * {t[t1]})%f.
Proof.
unfold mk_tuplel.
generalize (tvcompare_eq i1 i2).
case tvcompare; simpl; Krm1.
intros HH; rewrite HH. 
rewrite bracket0l; Krm0.
intros _; generalize (tvcompare_eq i1 i3).
case tvcompare; simpl; Krm1.
intros HH; rewrite HH.
rewrite bracket0m; auto.
intros HH; rewrite bracket_swapl; auto.
intros HH; rewrite bracket_swapl; auto.
rewrite bracket_swapr; auto; Krm1.
Qed.

Definition mk_tupler i1 i2 i3 :=
match tvcompare i2 i3 with
| Eq => (S0, Tuple i1 i2 i3)
| Lt => (S1, Tuple i1 i2 i3)
| Gt => 
  match tvcompare i1 i3 with
  | Eq => ( S0, Tuple i1 i2 i3)
  | Lt => (Sm1, Tuple i1 i3 i2)
  | Gt => ( S1, Tuple i3 i1 i2)
  end
end.

Lemma mk_tupler_c i1 i2 i3 :
 let (s,t1) := mk_tupler i1 i2 i3 in
 {t[Tuple i1 i2 i3]} = (s2k s * {t[t1]})%f.
Proof.
unfold mk_tupler.
generalize (tvcompare_eq i2 i3).
case tvcompare; simpl; Krm1.
intros HH; rewrite HH. 
rewrite bracket0r; Krm0.
intros _; generalize (tvcompare_eq i1 i3).
case tvcompare; simpl; Krm1.
intros HH; rewrite HH.
rewrite bracket0m; auto.
intros HH; rewrite bracket_swapr; auto.
intros HH; rewrite bracket_swapr; auto.
rewrite bracket_swapl; auto; Krm1.
Qed.

Inductive sprod := SProd (s : sign) (t1 t2 : tuple).

Definition esprod (s : sprod) :=
  let (s,t1,t2) := s in (s2k s * {t[t1]} * {t[t2]})%f.

Definition elsprod (l : list sprod) :=
  fold_left (fun res s => (res + esprod s)%f) l 0%f.

Definition tsplit3 (i1 i2 i3 j1 j2 j3 : tvar) := 
  match tvcompare i2 j2 with
  | Gt => 
          let   (s1,t1) := mk_tuplel i1 j1 j2 in
     let (s'1,t'1) := mk_tupler i2 i3 j3 in
     let   (s2,t2) := mk_tuplel i1 j1 j3 in
     let (s'2,t'2) := mk_tupler i2 i3 j2 in
     let   (s3,t3) := mk_tuplel i1 j2 j3 in
     let (s'3,t'3) := mk_tupler i2 i3 j1 in
       SProd (smult s1 s'1) t1 t'1 ::
       SProd (sopp (smult s2 s'2)) t2 t'2 ::
       SProd (smult s3 s'3) t3 t'3 :: nil
  | _  =>
    match tvcompare i3 j3 with
    | Gt =>
               let   (s1,t1) := mk_tupler i1 i2 j1 in
       let (s'1,t'1) := mk_tuplel i3 j2 j3 in
       let   (s2,t2) := mk_tupler i1 i2 j2 in
       let (s'2,t'2) := mk_tuplel i3 j1 j3 in
       let   (s3,t3) := mk_tupler i1 i2 j3 in
       let (s'3,t'3) := mk_tuplel i3 j1 j2 in
         SProd (smult s1 s'1) t1 t'1 ::
         SProd (sopp (smult s2 s'2)) t2 t'2 ::
         SProd (smult s3 s'3) t3 t'3 :: nil
    | _  => SProd S1 (Tuple i1 i2 i3) (Tuple j1 j2 j3)::nil
    end
  end.

Lemma s2km m1 m2 : s2k (smult m1 m2) = (s2k m1 * s2k m2)%f.
Proof. case m1; case m2; simpl; Krm1. Qed.

Lemma s2ko m : s2k (sopp m) = ((-(1)) * s2k m)%f.
Proof. case m; simpl; Krm1. Qed.

Lemma tsplit3_c a b c d e f :
    ({t[Tuple a b c]} * {t[Tuple d e f]})%f = 
         elsprod (tsplit3 a b c d e f).
Proof.
assert (Hs: forall x y z t : K, (x * y * z * t = (x * z) * (y * t))%f).
  intros; ring.
assert (Hs1: forall x y z t : K,(-(1) * (x * y) * z * t = -(1) * (x * z) * (y * t))%f).
  intros; ring.
simpl; unfold tsplit3.
generalize (tvcompare_eq b e); case tvcompare; intros H1; subst.
generalize (tvcompare_eq c f); case tvcompare; intros H2; subst.
unfold elsprod; simpl; Krm1.
unfold elsprod; simpl; Krm1.
generalize (mk_tupler_c a e d); case mk_tupler; simpl; intros s1 t1 Ht1.
generalize (mk_tuplel_c c e f); case mk_tuplel; simpl; intros s2 t2 Ht2.
generalize (mk_tupler_c a e e); case mk_tupler; simpl; intros s3 t3 Ht3.
generalize (mk_tuplel_c c d f); case mk_tuplel; simpl; intros s4 t4 Ht4.
generalize (mk_tupler_c a e f); case mk_tupler; simpl; intros s5 t5 Ht5.
generalize (mk_tuplel_c c d e); case mk_tuplel; simpl; intros s6 t6 Ht6.
unfold elsprod; simpl; Krm1.
rewrite !s2ko, !s2km.
rewrite Hs, <- Ht1, <-Ht2.
rewrite Hs1, <- Ht3, <-Ht4.
rewrite Hs, <- Ht5, <-Ht6.
apply split3b_v2; auto.
generalize (tvcompare_eq c f); case tvcompare; intros H2; subst.
unfold elsprod; simpl; Krm1.
unfold elsprod; simpl; Krm1.
generalize (mk_tupler_c a b d); case mk_tupler; simpl; intros s1 t1 Ht1.
generalize (mk_tuplel_c c e f); case mk_tuplel; simpl; intros s2 t2 Ht2.
generalize (mk_tupler_c a b e); case mk_tupler; simpl; intros s3 t3 Ht3.
generalize (mk_tuplel_c c d f); case mk_tuplel; simpl; intros s4 t4 Ht4.
generalize (mk_tupler_c a b f); case mk_tupler; simpl; intros s5 t5 Ht5.
generalize (mk_tuplel_c c d e); case mk_tuplel; simpl; intros s6 t6 Ht6.
unfold elsprod; simpl; Krm1.
rewrite !s2ko, !s2km.
rewrite Hs, <- Ht1, <-Ht2.
rewrite Hs1, <- Ht3, <-Ht4.
rewrite Hs, <- Ht5, <-Ht6.
apply split3b_v2; auto.
generalize (mk_tuplel_c a d e); case mk_tuplel; simpl; intros s1 t1 Ht1.
generalize (mk_tupler_c b c f); case mk_tupler; simpl; intros s2 t2 Ht2.
generalize (mk_tuplel_c a d f); case mk_tuplel; simpl; intros s3 t3 Ht3.
generalize (mk_tupler_c b c e); case mk_tupler; simpl; intros s4 t4 Ht4.
generalize (mk_tuplel_c a e f); case mk_tuplel; simpl; intros s5 t5 Ht5.
generalize (mk_tupler_c b c d); case mk_tupler; simpl; intros s6 t6 Ht6.
unfold elsprod; simpl; Krm1.
rewrite !s2ko, !s2km.
rewrite Hs, <- Ht1, <-Ht2.
rewrite Hs1, <- Ht3, <-Ht4.
rewrite Hs, <- Ht5, <-Ht6.
apply split3b_v1; auto.
Qed.

Definition tsplit (t1 t2 : tuple) :=
Eval lazy beta delta [tsplit3] in
  let (i1,i2,i3) := t1 in
  let (j1,j2,j3) := t2 in
  match tvcompare i1 j1 with
  | Gt =>  SProd S1 t2 t1 :: nil 
  | _  => tsplit3 i1 i2 i3 j1 j2 j3
  end.

Lemma tsplit_c t1 t2 :
    ({t[t1]} * {t[t2]})%f = elsprod (tsplit t1 t2).
Proof.
destruct t1; destruct t2; simpl.
case tvcompare.
apply tsplit3_c.
apply tsplit3_c.
rewrite multK_com; unfold elsprod; simpl; Krm1.
Qed.

Fixpoint list_compare (T : Type) (cmp : T -> T -> comparison) 
                                 (l1 l2 : list T) :=
match l1, l2 with
|   nil,   nil => Eq
|   nil,   _   => Lt
|     _,   nil => Gt
| a::l1, b::l2 => match cmp a b with
                  |  Eq => list_compare T cmp l1 l2
                  | res => res
                  end
end.

Lemma list_compare_eq T cmp l1 l2 :
  (forall c1 c2, match cmp c1 c2 with Eq => c1 = c2 | _ => True end) ->
  match list_compare T cmp l1 l2 with Eq => l1 = l2 | _ => True end.
Proof.
intros Hcmp.
generalize l2; elim l1; simpl; auto; clear l1 l2.
intros []; auto.
intros a l1 IH [|b l2]; simpl; auto.
generalize (Hcmp a b); case cmp; auto.
intros H; subst.
generalize (IH l2); case list_compare; auto.
intros H; subst; auto.
Qed.

Definition tcompare (t1 t2 : tuple) := 
  let (i1, i2, i3) := t1 in
  let (j1, j2, j3) := t2 in
  match tvcompare i1 j1 with
  | Eq =>
    match tvcompare i2 j2 with
    | Eq => tvcompare i3 j3
    |  r => r
    end
  |  r => r
  end.

Lemma tcompare_eq t1 t2 :
  match tcompare t1 t2 with Eq => t1 = t2 | _ => True end.
Proof.
destruct t1 as [a b c]; destruct t2 as [d e f]; simpl.
generalize (tvcompare_eq a d); case tvcompare; auto.
intros H; subst.
generalize (tvcompare_eq b e); case tvcompare; auto.
intros H; subst.
generalize (tvcompare_eq c f); case tvcompare; auto.
intros H; subst; auto.
Qed.

Definition lcompare : line -> line -> _ := list_compare _ tcompare.
Lemma lcompare_eq l1 l2 :
  match lcompare l1 l2 with Eq => l1 = l2 | _ => True end.
Proof. apply list_compare_eq. exact tcompare_eq. Qed.

Definition ecompare : expr -> expr -> _ := list_compare _ (fun x y => lcompare (snd x) (snd y)).

Definition tsort (t : tuple) :=
  let (i1, i2, i3) := t in
  match tvcompare i1 i2 with
  | Eq => (S0, t)
  | Lt => match tvcompare i2 i3 with
          | Eq => ( S0, t)
          | Lt => ( S1, t)
          | Gt => 
              match tvcompare i1 i3 with 
              | Eq => ( S0, t)
              | Lt => (Sm1, Tuple i1 i3 i2)
              | Gt => ( S1, Tuple i3 i1 i2) 
              end
          end
  | Gt => match tvcompare i1 i3 with 
          | Eq => ( S0, t)
          | Lt => (Sm1, Tuple i2 i1 i3)
          | Gt =>
              match tvcompare i2 i3 with 
              | Eq => ( S0, t)
              | Lt => ( S1, Tuple i2 i3 i1)
              | Gt => (Sm1, Tuple i3 i2 i1) 
              end
          end
  end.

Lemma tsort_c t : 
  let (s,t1) := tsort t in {t[t]} = (s2k s * {t[t1]})%f.
Proof.
destruct t as [a b c]; unfold tsort.
generalize (tvcompare_eq a b); case tvcompare; intros H1; subst.
simpl; rewrite bracket0l; Krm0.
generalize (tvcompare_eq b c); case tvcompare; intros H2; subst.
simpl; rewrite bracket0r; Krm0.
simpl; Krm1.
generalize (tvcompare_eq a c); case tvcompare; intros H3; subst.
simpl; rewrite bracket0m; Krm0.
simpl; rewrite bracket_swapr; Krm1.
simpl; rewrite bracket_swapr, bracket_swapl; Krm1.
generalize (tvcompare_eq a c); case tvcompare; intros H2; subst.
simpl; rewrite bracket0m; Krm0.
simpl; rewrite bracket_swapl; Krm1.
generalize (tvcompare_eq b c); case tvcompare; intros H3; subst.
simpl; rewrite bracket0r; Krm0.
simpl; rewrite bracket_swapl, bracket_swapr; Krm1.
simpl; rewrite bracket_swapl, bracket_swapr,bracket_swapl; Krm1.
Qed.

Fixpoint linsert (t1 : tuple) (l : line) :=
match l with
|   nil => t1 :: l
| t2::l1 => match tcompare t1 t2 with
                  |  Gt => t2 :: linsert t1 l1
                  | res => t1 :: l
                  end
end.

Lemma linsert_length t l : length (linsert t l) = S (length l).
Proof.
elim l; simpl; auto.
intros a l1 IH; case tcompare; simpl; auto with arith.
Qed.

Lemma linsert_c t l : {l[linsert t l]} = ({t[t]} * {l[l]})%f.
Proof.
elim l; simpl; auto.
intros a l1 IH; case tcompare; simpl; auto.
rewrite IH; auto.
rewrite <-!multK_assoc, (fun y => multK_com _ y {t[a]}); auto.
Qed.

Fixpoint lsort (l : line) :=
match l with
|   nil => l
| t ::l1 => linsert t (lsort l1)
end.

Lemma lsort_c l : {l[lsort l]} = {l[l]}.
Proof.
elim l; simpl; auto.
intros a l1 IH.
rewrite linsert_c, IH; auto.
Qed.

Fixpoint ltsort (c : sign) (l : line) :=
match l with
|   nil => (c,l)
| t ::l1 =>  let (c1,t1) := tsort t in
            let (c2,l2) := ltsort (smult c1 c) l1 in
            (c2, linsert t1 l2)
end.

Lemma ltsort_c c l : 
  let (s,l1) := ltsort c l in
  (s2k s * {l[l1]})%f = (s2k c * {l[l]})%f.
Proof.
generalize c; elim l; simpl; auto.
intros a l1 IH c1.
generalize (tsort_c a); case tsort.
intros s1 t1 Hs1.
generalize (IH (smult s1 c1)); case ltsort.
intros s2 l2 Hs.
rewrite linsert_c, Hs1.
rewrite !multK_assoc, (fun x => multK_com _ x {t[t1]}), <-multK_assoc; auto.
rewrite Hs, s2km.
rewrite !multK_assoc, (fun x => multK_com _ x {l[l1]}), <-multK_assoc; auto.
rewrite <-!multK_assoc, (fun x => multK_com _ x (s2k s1)); auto.
Qed.

Fixpoint einsert (c1 : coef) (l1 : line) (e : expr) :=
match e with
|   nil => (c1,l1) :: e
| (c2,l2)::e1 => match lcompare l1 l2 with
                  | Eq => let c := cadd c1 c2 in
                          if czerop c then e1 else (c,l1)::e1
                  | Gt => (c2,l2) :: einsert c1 l1 e1
                  | Lt => (c1,l1) :: e
                  end
end.

Lemma einsert_length c l e :  length (einsert c l e) <= 1 + length e.
Proof.
elim e; simpl; auto with arith.
intros (c1,l1) e1 IH; simpl.
case lcompare; simpl; auto with zarith.
case czerop; auto with zarith.
Qed.
 
Lemma einsert_c c1 l1 e :
  {e[einsert c1 l1 e]} = ({c[c1]} * {l[l1]} + {e[e]})%f.
Proof.
elim e; simpl; auto.
intros (c2,l2) e1 IH.
generalize (lcompare_eq l1 l2); case lcompare; intros H1; subst.
generalize (czerop_c (cadd c1 c2)); case czerop.
rewrite cadd_c; intros H2.
replace ({c[c1]}) with ({c[c1]} + (-(1)) * 0)%f; try ring.
rewrite <-H2; ring.
simpl; rewrite !cadd_c; intros H2.
ring.
simpl; ring.
simpl; rewrite IH; ring.
Qed.

Definition scmp (s : sign) (c : coef) :=
  match s with S0 => czero | S1 => c | Sm1 => copp c end.

Lemma scmp_c s c :
 {c[scmp s c]} = (s2k s * {c[c]})%f.
Proof. case s; simpl; rewrite ?copp_c; Krm1. Qed.

Definition einsert0 (c1 : coef) (l1 : line) (e : expr) :=
  if czerop c1 then e else einsert c1 l1 e.

Lemma einsert0_c c1 l1 e :
  {e[einsert0 c1 l1 e]} = ({c[c1]} * {l[l1]} + {e[e]})%f.
Proof.
unfold einsert0.
generalize (czerop_c c1); case czerop; intros H1; rewrite ?H1.
ring.
apply einsert_c.
Qed.

Fixpoint etsort (e : expr) :=
match e with
|   nil => nil
| (c,l)::e1 => let (c1, l1) := ltsort S1 l in 
          einsert0 (scmp c1 c) l1 (etsort e1)
end.

Lemma etsort_c e : {e[etsort e]} = {e[e]}.
Proof.
elim e; simpl; auto.
intros (c1,l1) e1 IH.
generalize (ltsort_c S1 l1); case ltsort; simpl.
intros s l Hs.
rewrite einsert0_c, scmp_c, IH.
rewrite multK_assoc, (fun x => multK_com _ x {c[c1]}), <- multK_assoc; auto.
rewrite Hs; ring.
Qed.

Fixpoint rev (T : Type) (t1 t2 : list T) :=
  match t1 with nil => t2 | n1 :: t3 => rev _ t3 (n1 :: t2) end.
Definition lrev: line -> line -> _ := rev tuple.
Lemma lrev_c l1 l2 :
 {l[lrev l1 l2]} = ({l[l1]} * {l[l2]})%f.
Proof.
generalize l2; clear l2.
elim l1; simpl; auto.
intros l2; unfold lrev; simpl; ring.
intros a l2 IH l3.
unfold lrev; simpl; rewrite IH; simpl; ring.
Qed.

Fixpoint iter_split (c1 : coef) (l l1 : line) (accu : line) (e : expr) 
   : expr :=
  if czerop c1 then e else
  match l with 
  | nil => einsert c1 (lrev accu nil) e
  | _ :: l' => 
    match l1 with
    | nil => einsert c1 (lrev accu nil) e
    | t1 ::nil => einsert c1 (lrev accu (t1 ::nil)) e
    | t1 :: t2 :: l2 =>
       fold_left (fun e (v: sprod) => 
                   let (s1, t1, t2) := v in
                   let l3 := linsert t2 l2 in
                     iter_split (scmp s1 c1) l' l3 (t1 ::accu) e)
                  (tsplit t1 t2) e
    end
  end.

Lemma iter_split_c c1 l l1 accu e :
 length l1 <= length l ->
 {e[iter_split c1 l l1 accu e]} =
    ({c[c1]} * {l[lrev accu l1]} + {e[e]})%f.
Proof.
generalize c1 l1 accu e; clear c1 l1 accu e.
elim l; simpl; auto; clear l.
intros c1 [|t1 l1] accu e; simpl.
intros H; generalize (czerop_c c1); case czerop; intros H1.
rewrite H1; ring.
rewrite einsert_c; auto.
intros H; contradict H; auto with arith.
intros _ l IH c1 l1 accu e.
generalize (czerop_c c1); case czerop; intros H1.
intros H; rewrite H1; ring.
case l1.
intros H2; rewrite einsert_c; auto.
intros t1 l2; simpl; intros H2.
generalize H2; case l2; clear H2.
intros H2.
rewrite einsert_c; auto.
simpl; intros t2 l3 H2.
rewrite lrev_c; simpl.
rewrite <-(fun x => multK_assoc _ x {t[t1]}); auto.
rewrite (tsplit_c t1 t2).
generalize e;
elim (tsplit t1 t2); simpl; auto.
intros e1; unfold elsprod; simpl; ring.
intros (s,t3,t4) l4 IH1 e1.
unfold elsprod; simpl.
rewrite IH1; auto.
rewrite IH; auto.
rewrite scmp_c, !lrev_c; simpl.
rewrite linsert_c.
assert (HH1 : forall l k,
 fold_left (fun res s => (res + esprod s)%f) l k =
 (elsprod l + k)%f).
intros ll; elim ll; simpl; auto.
intros k; unfold elsprod; simpl; ring.
intros a ll1 IHll k.
unfold elsprod; simpl.
rewrite !IHll; ring.
rewrite HH1.
ring.
rewrite linsert_length; auto with arith.
Qed.

Definition step (e : expr) : expr :=
  fold_left (fun e l => match l with 
                        | (c, l1) => iter_split c l1 l1 nil e 
                        end
             ) e nil.
Lemma step_c e : {e[step e]} = {e[e]}.
apply trans_equal with ({e[e]} + {e[nil]})%f.
2 : simpl; ring.
unfold step.
generalize (nil : expr); elim e; simpl; auto.
intros; ring.
intros (c,l1) e1 IH e2.
rewrite IH, iter_split_c, lrev_c; simpl; auto.
ring.
Qed.

Inductive rp (T : Type) := Stop (_ : T) | More (_ : T).
Definition rp_val (T : Type) (x : rp T) := 
match x with Stop _ y => y | More _ y => y end.

Fixpoint iter_rp (T : Type) n f (v : rp T) := match v with
| More _ r => match n with
            | O => f r
            | S n1 => iter_rp T n1 f (iter_rp T n1 f v)
            end
| _ => v
end.

Definition iter_step (k : nat) (e : expr) :=
  iter_rp _ k (fun e => let e1 := step e in
                         match ecompare e e1 with 
                          Eq => @Stop _ e  
                         | _ => More _ e1
                         end) (More _ e).

Lemma iter_step_c k e : {e[rp_val _ (iter_step k e)]} = {e[e]}.
Proof.
unfold iter_step.
assert (HH: e = (rp_val _ (More expr e))); auto.
pattern e at 2; rewrite HH.
generalize (More expr e); clear e HH.
elim k; simpl; auto.
intros r; case r; auto.
intros e; case ecompare; simpl; auto.
apply step_c; auto.
apply step_c; auto.
intros k1 IH e; case e.
intros e1; auto.
intros e1; rewrite !IH; auto.
Qed.

Fixpoint inter_elim (cc : coef) (x a b c d: tvar) (l : list tuple) 
               (accu: list tuple) e : expr :=
  match l with 
  | nil =>  einsert cc (rev _ accu l) e
  | t :: l1 =>
     if tin x t then
     let (c1,t1) := tsort (tsubst x a t) in
     let (c2,t2) := tsort (Tuple b c d) in
     let (c3,t3) := tsort (tsubst x b t) in
     let (c4,t4) := tsort (Tuple a c d) in
     einsert0
       (scmp (sopp (smult c1 c2)) cc) 
         (linsert t1 (linsert t2 (rev _ accu l1)))
     (einsert0
       (scmp (smult c3 c4) cc) 
         (linsert t3 (linsert t4 (rev _ accu l1)))
          e)
     else inter_elim cc x a b c d l1 (t ::accu) e
end.

Lemma inter_elim_c cc x a b c d l accu e :
 {v[x]} = ({v[a]} ∨ {v[b]}) ∧({v[c]} ∨ {v[d]}) :> vect K ->
 {e[inter_elim cc x a b c d l accu e]} = 
  ({c[cc]} * {l[l]} * {l[accu]} + {e[e]})%f.
Proof.
intros H.
generalize accu e; clear accu e; elim l; auto.
intros accu e.
simpl; rewrite einsert_c, lrev_c; simpl; ring.
intros t l1 IH accu e.
unfold inter_elim; fold inter_elim.
generalize (tsubst_c x t).
case tin.
2 : intros; rewrite IH; simpl; ring.
intros (a1,(b1,(s, (H1s,H2s)))).
generalize (tsort_c (tsubst x a t)); case tsort.
intros s1 t1 Ht1.
generalize (tsort_c (Tuple b c d)); case tsort.
intros s2 t2 Ht2.
generalize (tsort_c (tsubst x b t)); case tsort.
intros s3 t3 Ht3.
generalize (tsort_c (Tuple a c d)); case tsort.
intros s4 t4 Ht4.
rewrite !einsert0_c, !scmp_c, !s2ko, !s2km, !linsert_c, lrev_c.
simpl.
replace
 (-(1) * (s2k s1 * s2k s2) * {c[cc]} * 
    ({t[t1]} * ({t[t2]} * ({l[accu]} * {l[l1]}))))%f
with
 (-(1) * (s2k s1 * {t[t1]}) * (s2k s2 * 
    {t[t2]}) * {c[cc]} * ({l[accu]} * {l[l1]}))%f;
 try ring.
rewrite H1s; simpl.
rewrite <-Ht1, <-Ht2, !H2s; simpl.
replace
 (s2k s3 * s2k s4 * {c[cc]} *
  ({t[t3]} * ({t[t4]} * ({l[accu]} * {l[l1]}))) + {e[e]})%f 
with
 ( ((s2k s3 * {t[t3]}) * (s2k s4 * {t[t4]})) * {c[cc]} *
  (({l[accu]} * {l[l1]})) + {e[e]})%f; try ring.
rewrite <-Ht3, <-Ht4, !H2s; simpl.
assert (HH: ('[{v[x]}, {v[a1]}, {v[b1]}] =
  (-(1)) * '[{v[a]}, {v[a1]}, {v[b1]}] * 
       '[{v[b]}, {v[c]}, {v[d]}] +
  '[{v[b]}, {v[a1]}, {v[b1]}] * 
       '[{v[a]}, {v[c]}, {v[d]}])%f).
apply bracket_expand; auto.
rewrite HH; ring.
Qed.

Fixpoint ielim (x a b c d: tvar) e accu :=
  match e with 
  | nil => accu
  | (cc,l) :: e1 =>
       ielim x a b c d e1 
         (inter_elim cc x a b c d l nil accu)
  end.

Lemma ielim_c x a b c d e accu:
 {v[x]} = ({v[a]} ∨ {v[b]}) ∧({v[c]} ∨ {v[d]}) :> vect K ->
 {e[ielim x a b c d e accu]} = ({e[accu]} + {e[e]})%f.
Proof.
intros H; generalize accu; clear accu.
elim e; clear e; simpl; auto.
intros; ring.
intros (c1, l1) e1 IH accu.
rewrite IH, inter_elim_c; simpl; auto.
ring.
Qed.

Definition nielim x a b c d e := 
  ielim x a b c d e nil.

Lemma nielim_c x a b c d e :
 {v[x]} = ({v[a]} ∨ {v[b]}) ∧({v[c]} ∨ {v[d]}) :> vect K ->
 {e[nielim x a b c d e]} = {e[e]}.
Proof.
intros; unfold nielim; rewrite ielim_c; auto; simpl; ring.
Qed.

Definition do_elim x a b c d (e : expr) :=
  let e1 := nielim x a b c d e in
  match ecompare e e1 with
  | Eq => Stop _ e1 
  | _ =>  More _ e1
  end.

Lemma do_elim_c x a b c d e :
 {v[x]} = ({v[a]} ∨ {v[b]}) ∧ ({v[c]} ∨ {v[d]}) :> vect K -> 
  {e[rp_val _ (do_elim x a b c d e)]} = {e[e]}.
Proof.
intros H; unfold do_elim.
case ecompare; simpl; auto; apply nielim_c; auto.
Qed.

Definition iter_elim n x a b c d e := 
  iter_rp _ n (do_elim x a b c d) (More _ e).

Lemma iter_elim_c n x a b c d e : 
 {v[x]} = ({v[a]} ∨ {v[b]}) ∧ ({v[c]} ∨ {v[d]}) :> vect K -> 
  {e[rp_val _ (iter_elim n x a b c d e)]} = {e[e]}.
Proof.
unfold iter_elim; intros H.
apply trans_equal with {e[rp_val _ (More expr e)]}; auto.
generalize (More expr e); elim n; simpl; auto.
intros [r|r]; simpl; auto.
apply do_elim_c; auto.
intros n1 IH [e1|e1]; simpl; auto.
rewrite !IH; simpl; auto.
Qed.

Fixpoint free_elim (cc : coef) x a b c d (l : list tuple) 
               (accu: list tuple) e :=
  match l with 
  | nil => einsert cc (rev _ accu l) e
  | t ::l1 =>
     if tin x t then
     let (c1,t1) := tsort (tsubst x b t) in
     let cc1 := cscale a (scmp c1 cc) in
     let (c2,t2) := tsort (tsubst x d t) in
     let cc2 := cscale c (scmp c2 cc) in
     einsert0
       cc1 (linsert t1 (rev _ accu l1))
     (einsert0
       cc2 (linsert t2 (rev _ accu l1))
          e)
     else free_elim cc x a b c d l1 (t ::accu) e
end.

Lemma free_elim_c cc x a b c d l accu e :
 {v[x]} = {k[a]} .* {v[b]} + {k[c]} .* {v[d]} :> vect K ->
 {e[free_elim cc x a b c d l accu e]} = 
   ({c[cc]} * {l[l]} * {l[accu]} + {e[e]})%f.
Proof.
intros H.
generalize accu e; clear accu e; elim l; simpl; auto.
intros accu e; rewrite einsert_c; auto.
rewrite lrev_c; auto; simpl; ring.
intros t1 l1 IH accu e.
generalize (tsubst_c x t1); case tin.
2 : intros _; rewrite IH; simpl; ring.
intros (a1,(b1,(s1,(H1s1,H2s2)))).
generalize (tsort_c (tsubst x b t1)); case tsort.
intros s2 t2 Hs2.
generalize (tsort_c (tsubst x d t1)); case tsort.
intros s3 t3 Hs3.
rewrite !einsert0_c; auto.
rewrite !cscale_c, !scmp_c, !linsert_c, !lrev_c.
replace ({k[a]} * (s2k s2 * {c[cc]}) * ({t[t2]} * ({l[accu]} * {l[l1]})))%f
  with
({k[a]} * (s2k s2 * {t[t2]}) * ({c[cc]} * ({l[accu]} * {l[l1]})))%f; try ring.
rewrite <-Hs2, H2s2; simpl.
replace ({k[c]} * (s2k s3 * {c[cc]}) * ({t[t3]} * ({l[accu]} * {l[l1]})))%f
  with
({k[c]} * (s2k s3 * {t[t3]}) * ({c[cc]} * ({l[accu]} * {l[l1]})))%f; try ring.
rewrite <-Hs3, H2s2; simpl.
rewrite H1s1; simpl.
rewrite (bracket_free _ HP {v[x]} {k[a]} {v[b]} {k[c]} {v[d]}); auto.
change (VectorSpace.K Pp) with K.
ring.
Qed.
 
Fixpoint felim x a b c d e accu :=
  match e with 
  | nil => accu
  | (cc,l)::e1 =>
       felim x a b c d e1 
         (free_elim cc x a b c d l nil accu)
  end.

Lemma felim_c x a b c d e accu :
 {v[x]} = {k[a]} .* {v[b]} + {k[c]} .* {v[d]} :> vect K ->
 {e[felim x a b c d e accu]} = ({e[accu]} + {e[e]})%f.
Proof.
intros H; generalize accu; elim e; simpl; auto; clear accu.
intros; ring.
intros (c1,l1) e1 IH accu.
rewrite IH; auto.
rewrite free_elim_c; auto; simpl; ring.
Qed.

Definition nfelim x a b c d e := 
  felim x a b c d e nil.

Lemma  nfelim_c x a b c d e :
 {v[x]} = {k[a]} .* {v[b]} + {k[c]} .* {v[d]} :> vect K ->
 {e[nfelim x a b c d e]} = {e[e]}.
Proof.
intros H; unfold nfelim; rewrite felim_c; auto.
simpl; ring.
Qed.

Definition do_free x a b c d (e : expr) :=
  let e1 := nfelim x a b c d e in
  match ecompare e e1 with
  | Eq => Stop _ e1 
  | _ =>  More _ e1
  end.

Lemma do_free_c x a b c d e :
 {v[x]} = {k[a]} .* {v[b]} + {k[c]} .* {v[d]} :> vect K ->
  {e[rp_val _ (do_free x a b c d e)]} = {e[e]}.
Proof.
intros H; unfold do_free.
case ecompare; simpl; auto; apply nfelim_c; auto.
Qed.

Definition iter_free n x a b c d e := 
  iter_rp _ n (do_free x a b c d) (More _ e).

Lemma iter_free_c n x a b c d e : 
 {v[x]} = {k[a]} .* {v[b]} + {k[c]} .* {v[d]} :> vect K ->
  {e[rp_val _ (iter_free n x a b c d e)]} = {e[e]}.
Proof.
unfold iter_free; intros H.
apply trans_equal with {e[rp_val _ (More expr e)]}; auto.
generalize (More expr e); elim n; simpl; auto.
intros [r|r]; simpl; auto.
apply do_free_c; auto.
intros n1 IH [e1|e1]; simpl; auto.
rewrite !IH; simpl; auto.
Qed.

Definition reorder (t1 t2 : tuple) :=
 let (m1,m2,m3) := t1 in
 let (n1,n2,n3) := t2 in
 match tvcompare m1 n1 with 
 | Eq => 
      match tvcompare m2 n2 with 
     | Eq => match tvcompare m3 n3 with 
             |Eq => None
             | _ => Some (S1, S1, m1, m2, m3, n3)
             end
     | Lt =>
          match tvcompare m3 n2 with 
          | Eq => Some (Sm1, S1, m1, m3, m2, n3)
          | Lt => None
          | Gt => 
             match tvcompare m3 n3 with 
             | Eq => Some (Sm1, Sm1, m1, m3, m2, n2)
             | _ => None
             end
           end
     | Gt =>
          match tvcompare m2 n3 with 
          | Eq => Some (S1, Sm1, m1, m2, m3, n2)
          | Gt => None
          | Lt => 
             match tvcompare m3 n3 with 
             | Eq => Some (Sm1, Sm1, m1, m3, m2, n2)
             | _ => None
             end
          end
      end
 | Lt => 
      match tvcompare m2 n1 with 
     | Eq =>
          match tvcompare m3 n2 with 
          | Eq => Some (S1, S1, m2, m3, m1, n3)
          | Lt => None
          | Gt => 
             match tvcompare m3 n3 with 
             | Eq => Some (S1, Sm1, m2, m3, m1, n2)
             | _ => None
             end
          end
     | Lt => None
     | Gt =>
          match tvcompare m2 n2 with 
          | Eq => 
             match tvcompare m3 n3 with 
             | Eq => Some (S1, S1, m2, m3, m1, n1)
             | _ => None
             end
          | _ => None
          end
      end
 | Gt => 
      match tvcompare m1 n2 with 
     | Eq =>
          match tvcompare m2 n3 with 
          | Eq => Some (S1, S1, m1, m2, m3, n1)
          | Gt => None
          | Lt => 
             match tvcompare m3 n3 with 
             | Eq => Some (Sm1, S1, m1, m3, m2, n1)
             | _ => None
             end
          end
     | Gt => None
     | Lt =>
          match tvcompare m2 n2 with 
          | Eq => 
             match tvcompare m3 n3 with 
             | Eq => Some (S1, S1, m2, m3, m1, n1)
             | _ => None
             end
          | _ => None
          end
      end
  end.

Lemma reorder_c t1 t2 :
  match reorder t1 t2 with None => True | Some (s1, s2, m1,m2,m3,m4) =>
  ({t[t1]} =  s2k s1 * {t[Tuple m1 m2 m3]} /\
   {t[t2]} =  s2k s2 * {t[Tuple m1 m2 m4]})%f
  end.
Proof.
destruct t1 as (m1,m2,m3); destruct t2 as (n1,n2,n3); simpl.
generalize (tvcompare_eq m1 n1); case_eq (tvcompare m1 n1); intros Hu1; auto.
intros HH; subst.
generalize (tvcompare_eq m2 n2); case_eq (tvcompare m2 n2); intros Hu2; auto.
intros HH; subst.
generalize (tvcompare_eq m3 n3); case_eq (tvcompare m3 n3); intros Hu3; simpl; Krm1.
intros HH.
generalize (tvcompare_eq m3 n2); case_eq (tvcompare m3 n2); intros Hu4; auto.
intros HH1; subst; simpl; Krm1; split; auto.
rewrite <-bracket_swapr; simpl; auto.
intros HH1.
generalize (tvcompare_eq m3 n3); case_eq (tvcompare m3 n3); intros Hu5; auto.
intros HH2; subst; auto.
simpl; Krm1; rewrite <-!bracket_swapr; simpl; auto.
intros HH.
generalize (tvcompare_eq m2 n3); case_eq (tvcompare m2 n3); intros Hu6; auto.
intros HH1; subst; simpl; Krm1; split; auto.
rewrite <-!bracket_swapr; simpl; auto.
intros HH1.
generalize (tvcompare_eq m3 n3); case_eq (tvcompare m3 n3); intros Hu7; auto.
intros HH2; subst; auto.
simpl; Krm1; rewrite <-!bracket_swapr; simpl; auto.
intros HH.
generalize (tvcompare_eq m2 n1); case_eq (tvcompare m2 n1); intros Hu8; auto.
intros HH1; subst.
generalize (tvcompare_eq m3 n3); case_eq (tvcompare m3 n3); intros Hu9; auto.
intros HH2; subst; auto.
generalize (tvcompare_eq n3 n2); case_eq (tvcompare n3 n2); intros Hu10; auto.
intros HH3; subst; auto.
simpl; Krm1; split; auto.
rewrite bracket_swapl, bracket_swapr; auto.
simpl; Krm1; auto.
intros HH1.
simpl; Krm1; split; auto.
rewrite bracket_swapl, bracket_swapr; auto.
simpl; Krm1; auto.
rewrite <-!bracket_swapr; simpl; auto.
intros HH1.
generalize (tvcompare_eq m3 n2); case_eq (tvcompare m3 n2); intros Hu11; auto.
intros HH2; subst; auto.
simpl; Krm1; split; auto.
rewrite bracket_swapl, bracket_swapr; auto.
simpl; Krm1; auto.
intros HH1.
generalize (tvcompare_eq m3 n2); case_eq (tvcompare m3 n2); intros Hu11; auto.
intros HH2; subst; auto.
simpl; Krm1; split; auto.
rewrite bracket_swapl, bracket_swapr; auto.
simpl; Krm1; auto.
intros HH1.
generalize (tvcompare_eq m2 n2); case_eq (tvcompare m2 n2); intros Hu12; auto.
intros HH2; subst; auto.
generalize (tvcompare_eq m3 n3); case_eq (tvcompare m3 n3); intros Hu13; auto.
intros HH3; subst; auto.
simpl; Krm1; split.
rewrite bracket_swapl, bracket_swapr; Krm1.
rewrite (fun x y => @bracket_swapl _ HP x y {v[n3]}); auto.
rewrite (fun x y => @bracket_swapr _ HP x y {v[n1]}); auto.
simpl; Krm1; auto.
intros HH.
generalize (tvcompare_eq m1 n2); case_eq (tvcompare m1 n2); intros Hu14; auto.
intros HH1; subst.
generalize (tvcompare_eq m2 n3); case_eq (tvcompare m2 n3); intros Hu15; auto.
intros HH2; subst; auto.
simpl; Krm1; split; auto.
rewrite (fun x y => @bracket_swapl _ HP x y {v[n3]}); auto.
rewrite (fun x y => @bracket_swapr _ HP x y {v[n1]}); auto.
simpl; Krm1; auto.
intros HH1.
generalize (tvcompare_eq m3 n3); case_eq (tvcompare m3 n3); intros Hu16; auto.
intros HH2; subst; auto.
simpl; Krm1; split; auto.
rewrite <-bracket_swapr; auto.
rewrite bracket_swapl, bracket_swapr; Krm1.
intros HH1.
generalize (tvcompare_eq m2 n2); case tvcompare; auto.
intros HH2; subst; auto.
generalize (tvcompare_eq m3 n3); case tvcompare; auto.
intros HH3; subst; auto.
simpl; Krm1; split; auto.
rewrite bracket_swapl, bracket_swapr; auto; Krm1.
rewrite bracket_swapl, bracket_swapr; auto; Krm1.
Qed.

Definition contraction_rule c t1 t2 t3 t4 :=
  match reorder t1 t2 with
  | None => None
  | Some (s1, s2, m1, m2, m3, m4) =>
  match reorder t3 t4 with
  | None => None
  | Some (s3, s4, n1, n2, n3, n4) =>
  let s1 := smult s1 s3 in
  let s2 := smult c (smult s2 s4) in
  match smult s1 s2 with
  | S0 => None | S1 => None 
  | Sm1 =>
  match tvcompare m3 n4 with
  | Lt => None | Gt => None
  | Eq =>
  match tvcompare m4 n3 with
  | Lt => None | Gt => None
  | Eq =>
  match tvcompare m1 n1 with
  | Eq =>              
           let (s3,t3) := tsort (Tuple m1 m2 n2) in
           let (s4,t4) := tsort (Tuple m1 m3 m4) in
           Some (smult s1 (smult s3 s4), t3, t4) 
  | Lt => match tvcompare m2 n1 with
          | Eq => 
                        let (s3,t3) := tsort (Tuple m1 m2 n2) in
           let (s4,t4) := tsort (Tuple m2 m3 m4) in
           Some (smult s1 (smult s3 s4), t3, t4) 
          | Lt => None
          | Gt =>
             match tvcompare m2 n2 with
             | Eq => 
                            let (s3,t3) := tsort (Tuple m2 m1 n1) in
             let (s4,t4) := tsort (Tuple m2 m3 m4) in
             Some (smult s1 (smult s3 s4), t3, t4) 
             | _ => None
             end
          end
  | Gt => match tvcompare m1 n2 with
          | Eq => 
                          let (s3,t3) := tsort (Tuple m1 m2 n1) in
             let (s4,t4) := tsort (Tuple m3 m1 m4) in
             Some (smult s1 (smult s3 s4), t3, t4) 
          | Gt => None
          | Lt =>
             match tvcompare m2 n2 with
             | Eq => 
                              let (s3,t3) := tsort (Tuple m2 m1 n1) in
               let (s4,t4) := tsort (Tuple m2 m3 m4) in
               Some (smult s1 (smult s3 s4), t3, t4) 
             | _ => None
             end
          end
  end end end end end end.

Lemma contraction_rule_c c t1 t2 t3 t4 :
  match contraction_rule c t1 t2 t3 t4 with
  | None => True 
  | Some (s, t5, t6) =>
    ({t[t1]} * {t[t3]} + s2k c * ({t[t2]} * {t[t4]}) = 
      s2k s * {t[t5]} * {t[t6]})%f
  end.
Proof.
generalize c t1 t2 t3 t4; clear c t1 t2 t3 t4.
assert (F0: forall s s1 s2 s3 s4 a b c d,
smult (smult s1 s3) (smult s (smult s2 s4)) = Sm1 ->
(s2k s1 * a * (s2k s3 * b) + s2k s * (s2k s2 * c * (s2k s4 * d)) =
  s2k s1 * s2k s3 * (a * b + -(1) * c * d))%f).
 intros s s1 s2 s3 s4 a b c d H.
 apply trans_equal with
   ((s2k s1 * s2k s3) * (a * b) + (s2k s * (s2k s2 * s2k s4)) * (c * d))%f. 
 ring.
 replace (s2k s * (s2k s2 * s2k s4))%f  with (-(1) * (s2k s1 * s2k s3))%f; try ring.
 rewrite <-!s2km.
 generalize H; case (smult s1 s3); case (smult s2 s4); case s; simpl; Krm1;
  intros; discriminate.
assert (F1 : forall a b c d e : point K,
  ('[a, b, c] * '[a, d, e] + -(1) * '[a, b, e] * '[a, d, c] =
   '[a, b, d] * '[a, c, e])%f).
intros; apply contraction_v0; auto.
assert (F2 : forall a b c d e : point K,
('[a, b, c] * '[b, d, e] + -(1) * '[a, b, e] * '[b, d, c] =
 '[a, b, d] * '[b, c, e])%f).
intros; apply contraction_v1; auto.
assert (F3: forall a b c d e : point K,
('[a, b, c] * '[d, b, e] + - (1) * '[a, b, e] * '[d, b, c] =
 '[b, a, d] * '[b, c, e])%f).
intros; apply contraction_v2; auto.
assert (F4: forall a b c d e : point K,
('[a, b, c] * '[d, a, e] + - (1) * '[a, b, e] * '[d, a, c] =
 '[a, b, d] * '[c, a, e])%f).
intros; apply contraction_v3; auto.
intros c t1 t2 t3 t4.
unfold contraction_rule.
generalize (reorder_c t1 t2); case reorder; auto.
intros (((((s1, s2),m1),m2), m3), m4); intros (Ht1,Ht2).
generalize (reorder_c t3 t4); case reorder; auto.
intros (((((s3,s4),n1),n2), n3), n4); intros (Ht3,Ht4).
case_eq (smult (smult s1 s3) (smult c (smult s2 s4))); intros Hc; auto.
generalize (tvcompare_eq m3 n4); case_eq (tvcompare m3 n4); intros Hu1 Hm3; subst; auto.
generalize (tvcompare_eq m4 n3); case_eq (tvcompare m4 n3); intros Hu2 Hm4; subst; auto.
generalize (tvcompare_eq m1 n1); case_eq (tvcompare m1 n1); intros Hu3 Hm1; subst; auto.
generalize (tsort_c (Tuple n1 m2 n2)); case tsort; auto.
intros ss1 tt5 Ht5.
generalize (tsort_c (Tuple n1 n4 n3)); case tsort; auto.
intros ss2 tt6 Ht6.
rewrite !s2km.
apply trans_equal with
 (s2k s1 * s2k s3 * (s2k ss1 * {t[tt5]}) * (s2k ss2 * {t[tt6]}))%f.
2 : ring.
rewrite <- Ht5, <-Ht6; simpl.
rewrite Ht1, Ht2, Ht3, Ht4; simpl.
rewrite F0; auto; rewrite F1; simpl; ring.
generalize (tvcompare_eq m2 n1); case_eq (tvcompare m2 n1); intros Hu4 Hm2; subst; auto.
generalize (tsort_c (Tuple m1 n1 n2)); case tsort; auto.
intros ss1 tt5 Ht5.
generalize (tsort_c (Tuple n1 n4 n3)); case tsort; auto.
intros ss2 tt6 Ht6.
rewrite !s2km.
apply trans_equal with
 (s2k s1 * s2k s3 * (s2k ss1 * {t[tt5]}) * (s2k ss2 * {t[tt6]}))%f.
2 : ring.
rewrite <- Ht5, <-Ht6; simpl.
rewrite Ht1, Ht2, Ht3, Ht4; simpl.
rewrite F0; auto; rewrite F2; ring.
generalize (tvcompare_eq m2 n2); case_eq (tvcompare m2 n2); intros Hu5 Hn2; subst; auto.
generalize (tsort_c (Tuple n2 m1 n1)); case tsort; auto.
intros ss1 tt5 Ht5.
generalize (tsort_c (Tuple n2 n4 n3)); case tsort; auto.
intros ss2 tt6 Ht6.
rewrite !s2km.
apply trans_equal with
 (s2k s1 * s2k s3 * (s2k ss1 * {t[tt5]}) * (s2k ss2 * {t[tt6]}))%f.
2 : ring.
rewrite <- Ht5, <-Ht6; simpl.
rewrite Ht1, Ht2, Ht3, Ht4; simpl.
rewrite F0; auto; rewrite F3; ring.
generalize (tvcompare_eq m1 n2); case_eq (tvcompare m1 n2); intros Hu6 Hn1; subst; auto.
generalize (tsort_c (Tuple n2 m2 n1)); case tsort; auto.
intros ss1 tt5 Ht5.
generalize (tsort_c (Tuple n4 n2 n3)); case tsort; auto.
intros ss2 tt6 Ht6.
rewrite !s2km.
apply trans_equal with
 (s2k s1 * s2k s3 * (s2k ss1 * {t[tt5]}) * (s2k ss2 * {t[tt6]}))%f.
2 : ring.
rewrite <- Ht5, <-Ht6; simpl.
rewrite Ht1, Ht2, Ht3, Ht4; simpl.
rewrite F0; auto; rewrite F4; ring.
generalize (tvcompare_eq m2 n2); case_eq (tvcompare m2 n2); intros Hu7 Hn2; subst; auto.
generalize (tsort_c (Tuple n2 m1 n1)); case tsort; auto.
intros ss1 tt5 Ht5.
generalize (tsort_c (Tuple n2 n4 n3)); case tsort; auto.
intros ss2 tt6 Ht6.
rewrite !s2km.
apply trans_equal with
 (s2k s1 * s2k s3 * (s2k ss1 * {t[tt5]}) * (s2k ss2 * {t[tt6]}))%f.
2 : ring.
rewrite <- Ht5, <-Ht6; simpl.
rewrite Ht1, Ht2, Ht3, Ht4; simpl.
rewrite F0; auto; rewrite F3; ring.
Qed.

Fixpoint delta (m n : nat) (l1 l2 al1 al2 al3: line) : 
  option (line * line * line) :=
  match l1 with
  | nil => match natc n (length l2) with
          | Eq => Some (lrev al1 nil, lrev al2 l2, lrev al3 nil) 
          | _ => None 
          end
  | t1 :: l3 =>
      (fix delta1 n (l2 : list tuple) al2 :=
        match  l2 with
        | nil => 
           match natc m (length l1) with
           | Eq => Some (lrev al1 l1, lrev al2 nil, lrev al3 nil) 
           | _ => None 
           end
        | t2 :: l4 =>
            match tcompare t1 t2 with
            | Eq => delta m n l3 l4 al1 al2 (t1 ::al3)
            | Lt => match m with 
                    |    O => None
                    | S m1 => delta m1 n l3 l2 (t1 ::al1) al2 al3
                    end
            | Gt => match n with 
                    |    O => None
                    | S n1 => delta1 n1 l4 (t2 ::al2)
                    end
            end
        end) n l2 al2
  end.

Lemma delta_c m n l1 l2 al1 al2 al3 :
  match delta m n l1 l2 al1 al2 al3 with
  | None => True
  | Some (l3,l4,l5) =>
      ({l[l1]} * {l[al1]} * {l[al3]} = {l[l3]} * {l[l5]} /\
       {l[l2]} * {l[al2]} * {l[al3]} = {l[l4]} * {l[l5]})%f
  end.
Proof.
generalize m n l2 al1 al2 al3; clear m n l2 al1 al2 al3.
elim l1; simpl; auto; clear l1.
intros m n l2 al1 al2 al3; case natc; auto.
rewrite !lrev_c; simpl; auto; split; ring.
intros t l1 IH m n l2.
generalize n; elim l2; simpl; auto; clear n l2.
intros n1 al1 al2 al3; case n1.
case natc; auto.
rewrite !lrev_c; simpl; auto; split; ring.
intros _; case natc; auto.
rewrite !lrev_c; simpl; auto; split; ring.
intros b l2 IH1 [|n] al1 al2 al3.
generalize (tcompare_eq t b); case tcompare; auto.
intros HH; subst.
generalize (IH m 0%nat l2 al1 al2 (b::al3)).
case delta; auto.
intros ((ll1,ll2),ll3); simpl.
intros (HH1,HH2); split.
rewrite <- HH1; ring.
rewrite <- HH2; ring.
intros _; case m; auto.
intros m1.
generalize (IH m1 0%nat (b::l2) (t :: al1) al2 al3).
case delta; auto.
intros ((ll1,ll2),ll3); simpl.
intros (HH1,HH2); split.
rewrite <- HH1; ring.
rewrite <- HH2; ring.
generalize (tcompare_eq t b); case tcompare; auto.
intros HH; subst.
generalize (IH m (S n) l2 al1 al2 (b::al3)).
case delta; auto.
intros ((ll1,ll2),ll3); simpl.
intros (HH1,HH2); split.
rewrite <- HH1; ring.
rewrite <- HH2; ring.
intros; case m; auto; intros m1.
generalize (IH m1 (S n) (b::l2) (t ::al1) al2 al3).
case delta; auto.
intros ((ll1,ll2),ll3); simpl.
intros (HH1,HH2); split.
rewrite <- HH1; ring.
rewrite <- HH2; ring.
intros _.
generalize (IH1 n al1 (b::al2) al3).
match goal with 
 |- context[match ?X with Some _ => _ | None => _ end] =>
 case X
end; auto.
intros ((ll1,ll2),ll3); simpl.
intros (HH1,HH2); split.
rewrite <- HH1; ring.
rewrite <- HH2; ring.
Qed.

Fixpoint has_delta (c : coef) (l : line) (e : expr) :=
  match e with
  | nil => None
  | (c1,l1)::e1  => 
     match delta 2 2 l l1 nil nil nil with
     | Some (t1 :: t2 :: nil, t3 :: t4 :: nil, rl) => 
       let s :=
          if czerop (cadd c c1) then Sm1 else
          if czerop (cadd c (copp c1)) then S1 else
          S0 in
       if match s with S0 => true | _ => false end then
         has_delta c l e1
       else
         match contraction_rule s t1 t3 t2 t4 with
         | None=> has_delta c l e1
         | Some (c5, t5, t6) =>
               Some ((c1,l1), 
                   (scmp c5 c, 
                     linsert t5 (linsert t6 rl)))
         end
     | _ => has_delta c l e1
     end
  end.

Lemma has_delta_in c l e : 
  match has_delta c l e with None => True | Some (p,_) => In p e end.
Proof.
elim e; simpl; auto.
intros (c1,l1) e1 IH.
case delta; auto.
intros (([|t1 [| t2 [|t3 ll1]]],ll2),ll3); auto.
generalize IH; case has_delta; auto.
intros (p1,_); auto.
generalize IH; case has_delta; auto.
intros (p1,_); auto.
case ll2; clear ll2.
generalize IH; case has_delta; auto.
intros (p1,_); auto.
intros t3 [| t4 ll2].
generalize IH; case has_delta; auto.
intros (p1,_); auto.
case ll2; clear ll2.
case czerop; auto.
case contraction_rule; auto.
intros ((s1,t5),(s2,t6,t7)); auto.
generalize IH; case has_delta; auto.
intros (p1,_); auto.
case czerop; auto.
case contraction_rule; auto.
intros ((s1,t5),(s2,t6,t7)); auto.
generalize IH; case has_delta; auto.
intros (p1,_); auto.
generalize IH; case has_delta; auto.
intros (p1,_); auto.
intros.
generalize IH; case has_delta; auto.
intros (p1,_); auto.
generalize IH; case has_delta; auto.
intros (p1,_); auto.
generalize IH; case has_delta; auto.
intros (p1,_); auto.
Qed.

Lemma has_delta_c c l e :
  match has_delta c l e with None => True | Some ((c1,l1),(c2,l2)) => 
  ({c[c]} * {l[l]} + {c[c1]} * {l[l1]} =  {c[c2]} * {l[l2]})%f
  end.
Proof.
elim e; simpl; auto.
intros (c1,l1) e1 IH.
generalize (delta_c 2 2 l l1 nil nil nil); case delta; auto.
intros (([|t1 [|t2 [|t3 ll1]]],ll2),ll3); simpl; Krm1.
intros (H1,H2).
generalize H2; clear H2; case ll2; clear ll2; auto; 
  intros t4 [|t5 [| t6 ll2]]; simpl; Krm1.
generalize (czerop_c (cadd c c1)); case czerop; auto.
rewrite cadd_c; intros Hc.
generalize (contraction_rule_c Sm1 t1 t4 t2 t5);
  case contraction_rule; auto.
intros ((s6,t6),t7).
simpl.
rewrite scmp_c, !linsert_c.
intros HH H2.
rewrite H1, H2.
apply trans_equal with
(s2k s6 * {t[t6]} * {t[t7]} * {c[c]} * {l[ll3]})%f.
rewrite <-HH.
replace {c[c1]} with ({c[c]} + {c[c1]} + (-(1)) * {c[c]})%f.
rewrite Hc; ring.
ring.
ring.
intros HH.
generalize (czerop_c (cadd c (copp c1))); case czerop; auto.
rewrite cadd_c, copp_c; intros HH1.
generalize (contraction_rule_c S1 t1 t4 t2 t5);
  case contraction_rule; auto.
intros ((s6,t6),t7).
simpl.
rewrite scmp_c, !linsert_c.
intros HH3.
intros H2; rewrite H1, H2.
apply trans_equal with
(s2k s6 * {t[t6]} * {t[t7]} * {c[c]} * {l[ll3]})%f.
rewrite <-HH3.
replace {c[c]} with ({c[c]} + -(1) * {c[c1]} + {c[c1]})%f.
Krm1; rewrite HH1; ring.
ring.
ring.
Qed.

Fixpoint edelta (e : expr) :=
  match e with
  | nil => None
  | (c,l) :: e1  => 
     match has_delta c l e1 with 
     | None => edelta e1 
     | Some r => Some ((c,l), r) end
  end.

Lemma edelta_in e : 
  match edelta e with None => True | Some (p,(p1,_)) => 
     In p e /\ In p1 e end.
Proof.
elim e; simpl; auto.
intros (c1,l1) e1 IH.
generalize (has_delta_in c1 l1 e1); case has_delta.
intros (p1,e2); auto.
generalize IH; case edelta; auto.
intros ((c2,l2),((c3,l3),e2)); auto.
intros (H1,H2); auto.
Qed.

Lemma edelta_c e :
  match edelta e with None => True | Some ((c,l),((c1,l1),(c2,l2))) => 
  ({c[c]} * {l[l]} + {c[c1]} * {l[l1]} =  {c[c2]} * {l[l2]})%f
  end.
Proof.
elim e; simpl; auto.
intros (c,l) e1 IH.
generalize (has_delta_c c l e1); case has_delta; auto.
Qed.

Fixpoint eremove c l (e : expr) :=
  match e with
  | nil => None
  | (c1,l1) :: e1  =>
       if czerop (cadd c1 (copp c)) then
       match lcompare l l1 with
       | Eq => Some e1
       | _  => 
          match eremove c l e1 with
          | Some e2 => Some ((c1,l1):: e2)
          | _ => None
          end
       end
       else 
          match eremove c l e1 with
          | Some e2 => Some ((c1,l1):: e2)
          | _ => None
          end
  end.

Lemma eremove_c c l e : 
  match eremove c l e with None => True | Some e1 =>
  {e[e1]} = ({e[e]} + (-(1)) * {c[c]} * {l[l]})%f
  end.
Proof.
elim e; simpl; auto.
intros (c1,l1) e1 IH.
generalize (czerop_c (cadd c1 (copp c))); case czerop; auto.
rewrite cadd_c, copp_c; intros Hc.
generalize (lcompare_eq l l1); case lcompare; auto.
intros HH; subst.
replace {c[c1]} with
  ({c[c1]} + - (1) * {c[c]} + {c[c]})%f; try ring.
Krm1; rewrite Hc; ring.
intros _.
generalize IH; case eremove; auto.
intros e2; simpl.
intros HH; rewrite HH.
ring.
intros _.
generalize IH; case eremove; auto.
intros e2; simpl.
intros HH; rewrite HH.
ring.
intros HH.
generalize IH; case eremove; auto.
intros e2; simpl.
intros HH1; rewrite HH1.
ring.
Qed.

Definition do_contra (e : expr) :=
  match edelta e with
  | None  => Stop _ e
  | Some ((c1,l1),((c2,l2),(c3,l3)))  =>
     match eremove c2 l2 e with
     | Some e1 => 
       match eremove c1 l1 e1 with
       | Some e2 =>
           More _ (einsert c3 l3 e2)
       | _ => Stop _ e
       end
     | _ => Stop _ e
    end
  end.

Lemma do_contra_c e : 
  {e[rp_val _ (do_contra e)]} = {e[e]}.
Proof.
unfold do_contra.
generalize (edelta_c e); case edelta; auto.
intros ((c1,l1),((c2,l2),(c3,l3))); intros Hc1.
generalize (eremove_c c2 l2 e); case eremove; auto.
intros e1 He1.
generalize (eremove_c c1 l1 e1); case eremove; auto.
intros e2 He2; simpl.
rewrite einsert_c, He2, He1, <-Hc1; ring.
Qed.

Definition iter_contra n e := iter_rp _ n do_contra (More _ e).

Lemma iter_contra_c n e : 
  {e[rp_val _ (iter_contra n e)]} = {e[e]}.
Proof.
unfold iter_contra.
apply trans_equal with {e[rp_val _ (More expr e)]}; auto.
generalize (More expr e); elim n; simpl; auto.
intros [r|r]; auto; apply do_contra_c; auto.
intros n1 IH [e1|e1]; simpl; auto.
rewrite !IH; simpl; auto.
Qed.

Inductive action := 
  Inter (_ _ _ _ _: tvar) 
| SFree (_:tvar) (_:var) (_: tvar) (_:var) (_: tvar).

Definition intera (a: action): Prop :=
  match a with
  | Inter x a b c d =>
       {v[x]} = ({v[a]} ∨ {v[b]}) ∧ ({v[c]} ∨ {v[d]}) :> vect K 
  | SFree x a b c d =>
       {v[x]} = {k[a]} .* {v[b]} + {k[c]} .* {v[d]} :> vect K
  end.

Fixpoint interla (l : list action) (c : Prop) : Prop :=
  match l with
  | nil => c
  | a :: l1 => intera a -> interla l1 c
  end.

Definition interla_refine (c1 c2 : Prop) l :
  (c1 -> c2) -> (interla l c1 -> interla l c2).
Proof. elim l; simpl; auto. Qed.

Fixpoint resolve l e :=
  match l with
  | nil => e
  | (Inter x a b c d)::l1 =>
      rp_val _ (iter_elim 10 x a b c d (resolve l1 e))
  | (SFree x a b c d)::l1 =>
      rp_val _ (iter_free 10 x a b c d (resolve l1 e)) 
  end.

Lemma resolve_c l e : interla l ({e[e]} = {e[resolve l e]}).
Proof.
generalize e; clear e.
elim l; simpl; auto.
intros [x a b c d | x a b c d] l1 IH e; simpl.
intros H1.
rewrite (iter_elim_c _ _ _ _ _ _ (resolve l1 e) H1); auto.
intros H1.
rewrite (iter_free_c _ _ _ _ _ _ (resolve l1 e) H1); auto.
Qed.

Definition do_auto n l e :=
  let e1 := resolve l e in
  let e2 := rp_val _ (iter_contra 10 e1) in
  rp_val _ (iter_step n e2).

Lemma do_auto_c n l e : 
  interla l ({e1[e]} = {e1[do_auto n l e]}).
Proof.
unfold do_auto; rewrite !intere1_c.
apply interla_refine with (c1 := {e[e]} =
   {e[rp_val _ (iter_contra 10 (resolve l e))]}).
rewrite iter_step_c; auto.
apply interla_refine with (c1 := {e[e]} =
   {e[resolve l e]}).
rewrite iter_contra_c; auto.
apply resolve_c.
Qed.

End Generic.

Notation "'{' a ',' b ',' c '}'" := (Tuple _ a b c).

Section NatImplem.

Definition tvar := nat.
Definition tvcompare : tvar -> tvar -> comparison := natc.
Definition tvarn : tvar -> nat := id.
Lemma tvcompare_inj v1 v2 : tvarn v1 = tvarn v2 -> v1 = v2.
Proof. auto. Qed.
Lemma tvcompare_def v1 v2 :
  tvcompare v1 v2 = natc (tvarn v1) (tvarn v2).
Proof. auto. Qed.

Definition var := nat.
Variable interk : var -> K.
Notation "{k[ x ]}" := (interk x).

Definition term := (Z * (list var))%type.

Definition intervs (l : list var) : K :=
  (fold_left (fun res v => res * {k[v]}) l 1)%f.
Notation "{vs[ x ]}" := (intervs x).

Lemma intervs_nil : {vs[nil]} = 1%f.
Proof. auto. Qed.

Lemma intervs_cons v l : {vs[v::l]} = ({k[v]} * {vs[l]})%f.
Proof.
unfold intervs; simpl.
Krm1; generalize {k[v]}; elim l; simpl; auto.
intros; ring.
intros v1 l1 IH k.
rewrite IH; apply sym_equal; rewrite IH.
ring.
Qed.
Definition interm (x : term): K :=
  let (z,l) := x in (Z_to_K _ z * {vs[l]})%f.
Notation "{m[ x ]}" := (interm x).

Definition term_add (t1 t2 : term) :=
  let (z1,l) := t1 in
  let (z2,_) := t2 in ((z1 + z2)%Z, l).

Definition term_cmp (t1 t2 : term) :=
  let (_,l1) := t1 in
  let (_,l2) := t2 in list_compare _ natc l1 l2.

Lemma term_add_c t1 t2 :
  match term_cmp t1 t2 with
  | Eq => {m[term_add t1 t2]} = ({m[t1]} + {m[t2]})%f
  | _ => True
  end.
Proof.
destruct t1 as [z1 l1]; destruct t2 as [z2 l2]; simpl.
generalize (list_compare_eq _ natc l1 l2 natc_eq);
  case list_compare; auto.
intros HH; subst.
rewrite Z_to_K_add; auto; ring.
Qed.

Definition term_opp (t : term): term :=
  let (z,l) := t in ((-z)%Z, l).

Lemma term_opp_c t : {m[term_opp t]} = (-{m[t]})%f.
Proof.
destruct t; simpl; rewrite Z_to_K_opp; auto; ring.
Qed. 

Fixpoint list_insert (i: nat) (l : list nat) :=
  match l with
  | nil => (i :: nil)
  | j :: l1 =>
      match natc j i with
      | Lt => j :: list_insert i l1
      | _  => i :: l
      end
   end.

Definition term_scale (v : nat) (t : term) : term :=
  let (z, l) := t in
  (z, list_insert v l).

Lemma term_scale_c v t :
  {m[term_scale v t]} = ({k[v]} * {m[t]})%f.
Proof.
destruct t as [z l]; simpl.
set (f := (fun (res : K) (v0 : var) => res * {k[v0]})%f).
elim l; simpl; auto.
rewrite intervs_cons, !intervs_nil.
change (intervs (@nil nat)) with {vs[nil]}.
rewrite intervs_nil; ring.
intros v1 l1 IH.
case natc; simpl; auto.
rewrite intervs_cons; ring.
rewrite intervs_cons.
rewrite <-!multK_assoc, (multK_com _ HP _ {k[v1]}); auto.
rewrite !multK_assoc; change (VectorSpace.K Pp) with K; auto.
rewrite IH, intervs_cons; ring.
rewrite intervs_cons; ring.
Qed.

Definition term_zerop (t : term) :=
  let (z,l) := t in Zeq_bool 0%Z z.

Lemma term_zerop_c t : if term_zerop t then {m[t]} = 0%f else True.
Proof.
destruct t as [z l]; simpl.
generalize (Zeq_bool_eq 0 z); case Zeq_bool; auto.
intros HH; rewrite <-HH; auto; simpl; ring.
Qed.

Definition coef := list term.

Definition interc (c : coef) :  K :=
 fold_left (fun res v => res + ({m[v]}))%f c 0%f. 
Notation "{c[ x ]}" := (interc x).

Lemma interc_nil : {c[nil]} = 0%f.
Proof. auto. Qed.

Lemma interc_cons t c : {c[t ::c]} = ({m[t]} + {c[c]})%f.
Proof.
unfold interc; simpl.
rewrite addK0l; auto.
generalize {m[t]}; elim c; simpl; auto.
intros; ring.
intros t1 c1 IH k.
rewrite IH; apply sym_equal; rewrite IH; apply sym_equal.
ring.
Qed.

Definition c0 : coef := nil.

Lemma c0_c : {c[c0]} = 0%f.
Proof. auto. Qed.

Definition c1 : coef := (1%Z,@nil var)::nil.

Lemma c1_c : {c[c1]} = 1%f.
Proof.
unfold c1; simpl; rewrite interc_cons; simpl.
rewrite intervs_nil; simpl.
change (Z * list var)%type with term.
rewrite interc_nil; ring.
Qed.

Definition copp (c : coef) : coef := map term_opp c.

Lemma copp_c c : {c[copp c]} = (-{c[c]})%f.
Proof.
elim c; simpl; auto.
rewrite interc_nil; ring.
intros a l IH; rewrite interc_cons, term_opp_c, IH.
rewrite interc_cons; ring.
Qed.

Definition cscale (v : var) (c : coef) : coef := 
  map (term_scale v) c.

Lemma cscale_c v c :
  {c[cscale v c]} = ({k[v]} * {c[c]})%f.
Proof.
elim c; simpl; auto.
rewrite interc_nil; ring.
intros t l IH; rewrite !interc_cons, IH, term_scale_c.
ring.
Qed.

Definition ccons (t : term) (c : coef) :=
  if term_zerop t then c else t :: c.

Lemma ccons_c t c : {c[ccons t c]} = ({m[t]} + {c[c]})%f.
Proof.
unfold ccons.
generalize (term_zerop_c t); case term_zerop; simpl.
intros HH; rewrite HH; ring.
intros _; rewrite interc_cons; auto.
Qed.

Fixpoint cadd (a b : coef) : coef :=
  match a with
  | nil => b
  | t1 :: a1 =>
      (fix cadd1 (b : coef) : coef :=
        match  b with
        | nil => a
        | t2 :: b1 =>
            match term_cmp t1 t2 with
            | Eq => ccons (term_add t1 t2) (cadd a1 b1)
            | Lt => ccons t1 (cadd a1 b)
            | Gt => ccons t2 (cadd1 b1)
            end
        end) b
  end.

Lemma cadd_c c1 c2 : {c[cadd c1 c2]} = ({c[c1]} + {c[c2]})%f.
Proof.
generalize c2; elim c1; simpl; auto; clear c1 c2.
intros; rewrite interc_nil; ring.
intros t1 c1 IH c2.
elim c2; simpl; auto.
rewrite interc_nil; ring.
clear c2; intros t2 c2 IH1.
generalize (term_add_c t1 t2); case term_cmp; auto.
rewrite ccons_c; intros HH; rewrite HH.
rewrite !interc_cons, IH; ring.
intros _.
rewrite !ccons_c, IH, !interc_cons; ring.
intros _.
rewrite !ccons_c, IH1, !interc_cons; ring.
Qed.

Definition ccmp (c1 c2 : coef) :=
  list_compare _ term_cmp c1 c2.

Definition czerop (c : coef) :=
  match c with nil => true | _ => false end.

Lemma czerop_c c : if czerop c then {c[c]} = 0%f else True.
Proof. case c; simpl; auto. Qed.

Definition conep (c : coef) :=
  match c with (Zpos xH,nil) :: nil => true | _ => false end.

Lemma conep_c c : if conep c then {c[c]} = 1%f else True.
Proof.
case c; simpl; auto.
intros ([|[p1|p1|]|[p1|p1|]],[|]) [|]; simpl; auto.
unfold interc; simpl; rewrite intervs_nil; ring.
Qed.

Lemma natc_id n : natc n n = Eq.
Proof. elim n; simpl; auto. Qed.

Lemma list_compare_id l : list_compare _ natc l l = Eq.
Proof.
elim l; simpl; auto.
intros a l1 IH; rewrite natc_id; auto.
Qed.

Lemma cadd_opp a: cadd a (copp a) = nil.
Proof.
elim a; simpl; auto.
intros (z,a2) l; simpl.
intros HH; rewrite list_compare_id.
replace (z + -z)%Z with 0%Z; try auto with zarith.
Qed.

Lemma czerop_opp a : czerop (cadd a (copp a)) = true.
Proof. rewrite cadd_opp. simpl; auto. Qed.

Definition ndo_auto:= do_auto _ natc nat _ cadd czerop c0 copp cscale.

Definition ndo_auto_c i :=
  do_auto_c _ natc tvarn tvcompare_inj tvcompare_def i nat _
  cadd czerop c0 conep copp cscale interk interc cadd_c conep_c c0_c
  cscale_c czerop_c copp_c.

End NatImplem.
         
Inductive TBool : Set :=
 | RBtrue : TBool
 | RBfalse : TBool.
                       
Ltac IN a l :=
 match l with
 | (cons a ?l) => constr:(RBtrue)
 | (cons _ ?l) => IN a l
 |  nil => constr:(RBfalse)
 end.

Ltac AddFv a l :=
 match (IN a l) with
 | RBtrue => constr:(l)
 | _ => constr:(cons a l)
 end.

Ltac Find_at a l :=
 match l with
 | nil  => constr:(O)
 | (cons a _) => constr:(O)
 | (cons _ ?l) => let p := Find_at a l in eval compute in (S p)
 end.

Ltac Cstl a l :=
  match l with (?l1,?l2) => 
   let l3 := AddFv a l1 in constr:((l3 , l2)) end.

Ltac Cstr a l :=
  match l with (?l1,?l2) => 
   let l3 := AddFv a l2 in constr:((l1 , l3)) end.

Ltac FV t fv :=
  match t with
  | (?t1 -> ?t2) => 
    let fv1 := FV t1 fv in let fv2 := FV t2 fv1 in constr:(fv2)
  | (bracket _ (p2v _ ?t1) (p2v _ ?t2) (p2v _ ?t3) = _) => 
    let fv1 := Cstl t1 fv in let fv2 := Cstl t2 fv1 in 
    let fv3 := Cstl t3 fv2 in constr:(fv3)
  | (inter_lines _ ?t1 ?t2 ?t3 ?t4 ?t5) => 
    let fv1 := Cstl t1 fv in let fv2 := Cstl t2 fv1 in 
    let fv3 := Cstl t3 fv2 in let fv4 := Cstl t4 fv3 in
    let fv5 := Cstl t5 fv4 in constr:(fv5)
  | (online1 _ ?t1 ?t2 ?t3 ?t4 ?t5) => 
    let fv1 := Cstl t1 fv in let fv2 := Cstr t2 fv1 in 
    let fv3 := Cstl t3 fv2 in let fv4 := Cstr t4 fv3 in
    let fv5 := Cstl t5 fv4 in constr:(fv5)
  end.
 
Ltac GetHyp t fv1 fv2 :=
  match t with
  | (inter_lines _ ?t1 ?t2 ?t3 ?t4 ?t5) => 
    let n1 := Find_at t1 fv1 in let n2 := Find_at t2 fv1 in 
    let n3 := Find_at t3 fv1 in let n4 := Find_at t4 fv1 in
    let n5 := Find_at t5 fv1 in constr:(Inter tvar var n1 n2 n3 n4 n5)
  | (online1 _ ?t1 ?t2 ?t3 ?t4 ?t5) => 
    let n1 := Find_at t1 fv1 in let n2 := Find_at t2 fv2 in 
    let n3 := Find_at t3 fv1 in let n4 := Find_at t4 fv2 in
    let n5 := Find_at t5 fv1 in constr:(SFree tvar var n1 n2 n3 n4 n5)
  end.

Ltac GetHyps t fv1 fv2 :=
  match t with
  | (?t1 -> ?t2) => 
    let t1 := GetHyp t1 fv1 fv2 in 
    let l1 := GetHyps t2 fv1 fv2 in constr:(t1 :: l1)
  | _ => constr:(@nil (action tvar var))
  end.

Ltac GetConcl t fv :=
  match t with
  | (?t1 -> ?t2) => GetConcl t2 fv
  | (bracket _ (p2v _ ?t1) (p2v _ ?t2) (p2v _ ?t3) = _) => 
    let n1 := Find_at t1 fv in let n2 := Find_at t2 fv in 
    let n3 := Find_at t3 fv in 
     constr:((c1,(Tuple tvar n1 n2 n3) :: nil) :: nil)
  end.

Ltac preProcess :=
intuition;
apply bracket0_collinear; auto;
repeat

match goal with 
  | H: (inter_lines _ _ _ _ _ _) |- _ => 
      generalize H; clear H 
  | H: (online ?F ?t1 ?t2 ?t3) |- _ =>
      let k1 := fresh "k" in
      let k2 := fresh "k" in
      case (online_def F HP t1 t2 t3 H); intros (k1, k2); 
      simpl fst; simpl snd; clear H
end.

Ltac doTac1 :=
match goal with |- ?H  =>
  match FV H (nil : list (point K),nil : list K) with
  | (?fv1,?fv2) =>
    let concl := GetConcl H fv1 in
    let hyps := GetHyps H fv1 fv2 in
    set (cc := concl);
    set (hh := hyps)
  end
end.

Ltac doTac :=
match goal with |- ?H  =>
  match FV H (nil : list (point K),nil : list K) with
  | (?fv1,?fv2) =>
    let concl := GetConcl H fv1 in
    let hyps := GetHyps H fv1 fv2 in
    vm_cast_no_check
      (ndo_auto_c (fun v => nth v fv2 0%f)
                           (fun v => nth v fv1 (0%f,(0%f,(0%f,tt))))
                            10 hyps concl)
  end
end.

Ltac doTac_debug :=
match goal with |- ?H  =>
  match FV H (nil : list (point K),nil : list K) with
  | (?fv1,?fv2) =>
    let concl := GetConcl H fv1 in
    let hyps := GetHyps H fv1 fv2 in
    generalize
      (ndo_auto_c (fun v => nth v fv2 0%f)
                           (fun v => nth v fv1 (0%f,(0%f,(0%f,tt))))
                            10 hyps concl);
    let ff := fresh "ff" in
    (set (ff := do_auto nat natc nat coef cadd czerop c0 copp cscale 10 hyps concl);
    vm_compute in ff;
    unfold ff;
    lazy zeta iota beta delta[interla intera c1 conep intere1 interl intert nth];
    let HH := fresh "HH" in 
      intros HH; apply HH
   )
  end
end.

Ltac mTac := preProcess; doTac.
Ltac mTac_debug := preProcess; doTac_debug.

Section Examples.

Lemma ex1 :
  forall p1 p2 p3 p4 p5 p6 p7 p8 p9 p10: point K,
  p5 is_the_intersection_of [p1, p2] and [p3, p4] ->
  p6 is_the_intersection_of [p1, p3] and [p2, p4] ->
  p7 is_the_intersection_of [p2, p3] and [p1, p4] ->
  p8 is_the_intersection_of [p2, p3] and [p5, p6] ->
  p9 is_the_intersection_of [p2, p4] and [p5, p7] -> 
 p10 is_the_intersection_of [p3, p4] and [p6, p7] ->
 [p8 , p9 , p10] are_collinear.
Proof.
 
 mTac.
Time Qed.

Lemma ex2 :
  forall p1 p2 p3 p4 p5 p6 p7 p8 p9 p10: point K,
 p5 is_the_intersection_of [p1,p2] and [p3,p4] ->
 p6 is_the_intersection_of [p1,p3] and [p2,p4] ->
 p7 is_the_intersection_of [p2,p3] and [p1,p4] ->
 p8 is_the_intersection_of [p1,p3] and [p5,p7] ->
 p9 is_the_intersection_of [p6,p7] and [p4,p8] ->
p10 is_the_intersection_of [p2,p4] and [p5,p7] -> 
 [p3,p9,p10] are_collinear.
Proof. mTac. Time Qed.

Lemma ex3 :  forall p1 p2 p3 p4 p5 p6 p7 p8 p9 p10: point K, 
  p5 is_the_intersection_of [p1,p2] and [p3,p4] ->
  p6 is_the_intersection_of [p1,p3] and [p2,p4] ->
  p7 is_the_intersection_of [p2,p3] and [p1,p4] ->
  p8 is_the_intersection_of [p1,p3] and [p5,p7] ->
  p9 is_the_intersection_of [p1,p4] and [p5,p6] ->
 p10 is_the_intersection_of [p3,p4] and [p6,p7] ->
 [p8,p9,p10] are_collinear.
Proof. mTac. Time Qed.

Lemma ex4 :   forall p1 p2 p3 p4 p5 p6 p7 p8 p9 p10 p11 p12 : point K, 
  p6 is_the_intersection_of [p1,p2] and [p3,p4] ->
  p7 is_the_intersection_of [p1,p3] and [p2,p4] ->
  p8 is_the_intersection_of [p2,p3] and [p1,p4] ->
  p9 is_the_intersection_of [p5,p6] and [p7,p8] ->
 p10 is_the_intersection_of [p5,p7] and [p6,p8] ->
 p11 is_the_intersection_of [p3,p9] and [p2,p10] ->
 p12 is_the_intersection_of [p6,p7] and [p5,p8] ->
 [p1,p11,p12] are_collinear.
Proof. mTac. Time Qed.

Lemma ex5 :   forall p1 p2 p3 p4 p5 p6 p7 p8 p9 p10 p11 p12 p13: point K, 
  p6 is_the_intersection_of [p1,p3] and [p2,p4] ->
  p7 is_the_intersection_of [p2,p3] and [p5,p6] ->
  p8 is_the_intersection_of [p2,p5] and [p3,p4] ->
  p9 is_the_intersection_of [p1,p2] and [p6,p8] ->
 p10 is_the_intersection_of [p7,p9] and [p2,p4] ->
 p11 is_the_intersection_of [p3,p9] and [p6,p7] ->
 p12 is_the_intersection_of [p1,p5] and [p4,p11] ->
 p13 is_the_intersection_of [p2,p8] and [p3,p9] ->
 [p10,p12,p13] are_collinear.
Proof. mTac. Time Qed.

Lemma ex6 :   forall p1 p2 p3 p4 p5 p6 p7 p8 p9: point K, 
  p5 is_free_on [p1,p2] ->
  p6 is_free_on [p3,p4] -> 
  p7 is_the_intersection_of [p2,p3] and [p1,p4] ->
  p8 is_the_intersection_of [p3,p5] and [p1,p6] ->
  p9 is_the_intersection_of [p4,p5] and [p2,p6] ->
  [p7,p8,p9] are_collinear.
Proof. mTac. Time Qed.

Lemma ex7 :   forall p1 p2 p3 p4 p5 p6 p7 p8 p9 p10: point K, 
  p6 is_free_on [p1,p3] ->
  p7 is_the_intersection_of [p1,p2] and [p4,p5] ->
  p8 is_the_intersection_of [p1,p5] and [p2,p4] ->
  p9 is_the_intersection_of [p3,p8] and [p5,p6] ->
 p10 is_the_intersection_of [p2,p3] and [p4,p9] ->
 [p6,p7,p10] are_collinear.
Proof. mTac. Time Qed.

Lemma ex8 :   forall p1 p2 p3 p4 p5 p6 p7 p8 p9 p10 p11 p12 : point K, 
  p4 is_free_on [p1,p2] ->
  p5 is_free_on [p1,p2] ->
  p6 is_free_on [p1,p3] ->
  p7 is_free_on [p2,p3] ->
  p8 is_the_intersection_of [p2,p3] and [p4,p6] ->
  p9 is_the_intersection_of [p2,p3] and [p5,p6] ->
 p10 is_the_intersection_of [p1,p3] and [p5,p7] ->
 p11 is_the_intersection_of [p1,p3] and [p4,p7] ->
 p12 is_the_intersection_of [p1,p2] and [p8,p10] ->
 [p9,p11,p12] are_collinear.
Proof. mTac. Time Qed.

Lemma ex9_1 :
  forall p1 p2 p3 p4 p5 p6 p7 p8 p9 p10 p11 p12 p13 p14 p15: point K, 
  p5 is_free_on [p1,p2] ->
  p6 is_the_intersection_of [p1,p2] and [p3,p4] ->
  p7 is_the_intersection_of [p1,p3] and [p2,p4] ->
  p8 is_the_intersection_of [p2,p3] and [p1,p4] ->
  p9 is_the_intersection_of [p1,p3] and [p4,p5] ->
 p10 is_the_intersection_of [p2,p3] and [p4,p5] ->
 p11 is_the_intersection_of [p1,p4] and [p3,p5] ->
 p12 is_the_intersection_of [p2,p4] and [p3,p5] ->
 p13 is_the_intersection_of [p1,p2] and [p8,p9] ->
 p14 is_the_intersection_of [p1,p2] and [p7,p10] ->
 p15 is_the_intersection_of [p1,p2] and [p10,p11] ->
 [p7,p11,p13] are_collinear.
Proof. mTac. Time Qed.

Lemma ex9_2 :
   forall p1 p2 p3 p4 p5 p6 p7 p8 p9 p10 p11 p12 p13 p14 p15: point K, 
  p5 is_free_on [p1,p2] ->
  p6 is_the_intersection_of [p1,p2] and [p3,p4] ->
  p7 is_the_intersection_of [p1,p3] and [p2,p4] ->
  p8 is_the_intersection_of [p2,p3] and [p1,p4] ->
  p9 is_the_intersection_of [p1,p3] and [p4,p5] ->
 p10 is_the_intersection_of [p2,p3] and [p4,p5] ->
 p11 is_the_intersection_of [p1,p4] and [p3,p5] ->
 p12 is_the_intersection_of [p2,p4] and [p3,p5] ->
 p13 is_the_intersection_of [p1,p2] and [p8,p9] ->
 p14 is_the_intersection_of [p1,p2] and [p7,p10] ->
 p15 is_the_intersection_of [p1,p2] and [p10,p11] ->
 [p8,p12,p14] are_collinear.
Proof. mTac. Time Qed.

Lemma ex9_3 :
  forall p1 p2 p3 p4 p5 p6 p7 p8 p9 p10 p11 p12 p13 p14 p15: point K, 
  p5 is_free_on [p1,p2] ->
  p6 is_the_intersection_of [p1,p2] and [p3,p4] ->
  p7 is_the_intersection_of [p1,p3] and [p2,p4] ->
  p8 is_the_intersection_of [p2,p3] and [p1,p4] ->
  p9 is_the_intersection_of [p1,p3] and [p4,p5] ->
 p10 is_the_intersection_of [p2,p3] and [p4,p5] ->
 p11 is_the_intersection_of [p1,p4] and [p3,p5] ->
 p12 is_the_intersection_of [p2,p4] and [p3,p5] ->
 p13 is_the_intersection_of [p1,p2] and [p8,p9] ->
 p14 is_the_intersection_of [p1,p2] and [p7,p10] ->
 p15 is_the_intersection_of [p1,p2] and [p10,p11] ->
  [p9,p12,p15] are_collinear.
Proof. mTac. Time Qed.

Lemma ex10_1 :
  forall p1 p2 p3 p4 p5 p6 p7 p8 p9 p10 p11 p12 p13: point K, 
  p5 is_free_on [p1,p2] ->
  p6 is_the_intersection_of [p1,p2] and [p3,p4] ->
  p7 is_the_intersection_of [p1,p3] and [p2,p4] ->
  p8 is_the_intersection_of [p1,p3] and [p4,p5] ->
  p9 is_the_intersection_of [p2,p3] and [p6,p7] ->
 p10 is_the_intersection_of [p2,p4] and [p1,p9] ->
 p11 is_the_intersection_of [p3,p4] and [p1,p9] ->
 p12 is_the_intersection_of [p2,p3] and [p8,p10] ->
 p13 is_the_intersection_of [p4,p9] and [p3,p10] ->
 [p5,p11,p12] are_collinear.
Proof. mTac. Time Qed.

Lemma ex10_2 :
  forall p1 p2 p3 p4 p5 p6 p7 p8 p9 p10 p11 p12 p13: point K, 
  p5 is_free_on [p1,p2] ->
  p6 is_the_intersection_of [p1,p2] and [p3,p4] ->
  p7 is_the_intersection_of [p1,p3] and [p2,p4] ->
  p8 is_the_intersection_of [p1,p3] and [p4,p5] ->
  p9 is_the_intersection_of [p2,p3] and [p6,p7] ->
 p10 is_the_intersection_of [p2,p4] and [p1,p9] ->
 p11 is_the_intersection_of [p3,p4] and [p1,p9] ->
 p12 is_the_intersection_of [p2,p3] and [p8,p10] ->
 p13 is_the_intersection_of [p4,p9] and [p3,p10] ->
 [p7,p11,p13] are_collinear.
Proof. mTac. Time Qed.

Lemma ex11 :
  forall p1 p2 p3 p4 p5 p6 p7 p8 p9 p10 p11 p12 p13: point K, 
  p5 is_free_on [p1,p2] ->
  p6 is_the_intersection_of [p1,p2] and [p3,p4] ->
  p7 is_the_intersection_of [p1,p3] and [p2,p4] ->
  p8 is_the_intersection_of [p2,p3] and [p1,p4] ->
  p9 is_the_intersection_of [p1,p3] and [p5,p8] ->
 p10 is_the_intersection_of [p2,p3] and [p6,p9] ->
 p11 is_the_intersection_of [p1,p2] and [p7,p10] ->
 p12 is_the_intersection_of [p1,p3] and [p8,p11] ->
 p13 is_the_intersection_of [p2,p3] and [p6,p12] ->
 [p5,p7,p13] are_collinear.
Proof. mTac. Time Qed.

Lemma ex12 :
  forall p1 p2 p3 p4 p5 p6 p7 p8 p9 p10 p11 p12 p13 p14 p15 
         p16 p17 p18 p19 p20 p21 p22 p23 p24 p25: point K, 
 p10 is_free_on [p1,p9] ->
 p11 is_the_intersection_of [p1,p3] and [p2,p4] -> 
 p12 is_the_intersection_of [p2,p4] and [p3,p5] -> 
 p13 is_the_intersection_of [p3,p5] and [p4,p6] -> 
 p14 is_the_intersection_of [p4,p6] and [p5,p7] -> 
 p15 is_the_intersection_of [p5,p7] and [p6,p8] -> 
 p16 is_the_intersection_of [p6,p8] and [p1,p7] -> 
 p17 is_the_intersection_of [p1,p7] and [p2,p8] -> 
 p18 is_the_intersection_of [p2,p8] and [p1,p3] -> 
 p19 is_the_intersection_of [p2,p9] and [p10,p18] -> 
 p20 is_the_intersection_of [p3,p9] and [p11,p19] -> 
 p21 is_the_intersection_of [p4,p9] and [p12,p20] -> 
 p22 is_the_intersection_of [p5,p9] and [p13,p21] -> 
 p23 is_the_intersection_of [p6,p9] and [p14,p22] -> 
 p24 is_the_intersection_of [p7,p9] and [p15,p23] -> 
 p25 is_the_intersection_of [p8,p9] and [p16,p24] ->  
 [p10,p17,p25] are_collinear.
Proof. mTac. Time Qed.

Lemma ex13 :
  forall p1 p2 p3 p4 p5 p6 p7 p8 p9 p10 p11 p12 p13 p14 p15 p16: point K, 
  p7 is_free_on [p1,p2] ->
  p8 is_the_intersection_of [p1,p3] and [p2,p4] -> 
  p9 is_the_intersection_of [p2,p3] and [p1,p4] -> 
 p10 is_the_intersection_of [p1,p5] and [p4,p6] ->
 p11 is_the_intersection_of [p3,p5] and [p1,p6]   -> 
 p12 is_the_intersection_of [p1,p3] and [p6,p7]   -> 
 p13 is_the_intersection_of [p1,p6] and [p9,p10]  -> 
 p14 is_the_intersection_of [p1,p5] and [p8,p11]  -> 
 p15 is_the_intersection_of [p1,p2] and [p12,p13] -> 
 p16 is_the_intersection_of [p5,p7] and [p1,p4]  -> 
 [p14,p15,p16] are_collinear.
Proof. mTac. Time Qed.

Lemma ex14 :
  forall p1 p2 p3 p4 p5 p6 p7 p8 p9: point K, 
  p6 is_the_intersection_of [p1,p2] and [p3,p4] ->
  p7 is_the_intersection_of [p2,p4] and [p1,p5] ->
  p8 is_the_intersection_of [p1,p3] and [p4,p5] ->
  p9 is_the_intersection_of [p5,p6] and [p3,p7] -> 
  [p2,p8,p9] are_collinear.
Proof. mTac. Time Qed.

Lemma ex15 : 
  forall p1 p2 p3 p4 p5 p6 p7 p8 p9: point K, 
  p6 is_the_intersection_of [p2,p3] and [p1,p4] ->
  p7 is_the_intersection_of [p1,p2] and [p4,p5] ->
  p8 is_the_intersection_of [p3,p4] and [p2,p5] ->
  p9 is_the_intersection_of [p3,p7] and [p1,p8] ->
  [p5,p6,p9] are_collinear.
Proof. mTac. Time Qed.

Lemma ex16 :
  forall p1 p2 p3 p4 p5 p6 p7 p8 p9 p10: point K, 
  p5 is_free_on [p2,p3] ->
  p6 is_the_intersection_of [p1,p2] and [p3,p4] ->
  p7 is_the_intersection_of [p1,p3] and [p2,p4] ->
  p8 is_the_intersection_of [p1,p5] and [p6,p7] ->
  p9 is_the_intersection_of [p4,p5] and [p6,p7] ->
 p10 is_the_intersection_of [p2,p3] and [p4,p8] -> 
[p1,p9,p10] are_collinear.
Proof. mTac. Time Qed.

Lemma ex17 :
  forall p1 p2 p3 p4 p5 p6 p7 p8 p9 p10 p11 p12 : point K, 
  p9 is_free_on [p5,p8]  ->
  p6 is_the_intersection_of [p1,p2] and [p3,p4] ->
  p7 is_the_intersection_of [p2,p3] and [p1,p4] ->
  p8 is_the_intersection_of [p6,p7] and [p1,p3] ->
  p9 is_the_intersection_of [p3,p4] and [p5,p8] ->
 p10 is_the_intersection_of [p7,p9] and [p5,p6] ->
 p11 is_the_intersection_of [p6,p9] and [p5,p7] ->
 p12 is_the_intersection_of [p6,p7] and [p2,p4] -> 
 [p10,p11,p12] are_collinear.
Proof. mTac. Time Qed.

Lemma ex18 :
  forall p1 p2 p3 p4 p5 p6 p7 p8 p9 p10 p11 p12 p13 p14: point K, 
  p7 is_free_on [p1,p2] ->
  p8 is_the_intersection_of [p2,p3] and [p5,p6] ->
  p9 is_the_intersection_of [p1,p3] and [p7,p8] ->
 p10 is_the_intersection_of [p1,p4] and [p7,p8] ->
 p11 is_the_intersection_of [p2,p4] and [p7,p8] ->
 p12 is_the_intersection_of [p3,p4] and [p7,p8] ->
 p13 is_the_intersection_of [p5,p7] and [p6,p9] ->
 p14 is_the_intersection_of [p5,p11] and [p6,p12] -> 
 [p10,p13,p14] are_collinear.
Proof. mTac. Time Qed.

Lemma ex19 :
  forall p1 p2 p3 p4 p5 p6 p7 p8 p9 p10 p11 p12 : point K, 
  p6 is_free_on [p1,p2] ->
  p7 is_the_intersection_of [p1,p5] and [p3,p4] ->
  p8 is_the_intersection_of [p2,p7] and [p4,p6] ->
  p9 is_the_intersection_of [p5,p8] and [p2,p3] ->
 p10 is_the_intersection_of [p1,p9] and [p3,p4] ->
 p11 is_the_intersection_of [p3,p6] and [p1,p5] ->
 p12 is_the_intersection_of [p6,p9] and [p4,p5] -> 
 [p10,p11,p12] are_collinear.
Proof. mTac. Time Qed.

Lemma ex20 :
  forall p1 p2 p3 p4 p5 p6 p7 p8 p9 p10 p11 p12 p13 p14: point K, 
  p7 is_free_on [p1,p2] ->
  p8 is_free_on [p1,p3] ->
  p9 is_the_intersection_of [p1,p4] and [p5,p6] ->
 p10 is_the_intersection_of [p1,p5] and [p4,p6] ->
 p11 is_the_intersection_of [p3,p7] and [p2,p8] ->
 p12 is_the_intersection_of [p3,p4] and [p8,p9] ->
 p13 is_the_intersection_of [p2,p5] and [p7,p10] ->
 p14 is_the_intersection_of [p5,p8] and [p3,p10] -> 
 [p11,p13,p14] are_collinear.
Proof. mTac. Time Qed.

Lemma ex21 :
  forall p1 p2 p3 p4 p5 p6 p7 p8 p9 p10 p11 p12 p13: point K, 
  p5 is_free_on [p2,p3] ->
  p6 is_the_intersection_of [p1,p3] and [p2,p4] ->
  p7 is_the_intersection_of [p2,p3] and [p1,p4] ->
  p8 is_the_intersection_of [p3,p4] and [p6,p7] ->
  p9 is_free_on [p1,p2] ->
 p10 is_the_intersection_of [p5,p6] and [p1,p8] ->
 p11 is_the_intersection_of [p2,p8] and [p9,p10] ->
 p12 is_the_intersection_of [p7,p11] and [p1,p3] ->
 p13 is_the_intersection_of [p3,p9] and [p6,p7] -> 
[p5,p12,p13] are_collinear.
Proof. mTac. Time Qed.

End Examples.

End FF.
