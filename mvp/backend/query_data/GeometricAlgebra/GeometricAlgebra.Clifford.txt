Require Import ArithRing Div2 Bool Even Setoid Min List Aux Wf_nat.
(* Aux:
Require Import List Min Arith Div2.

Notation "n .+1" := (S n)(at level 2, left associativity, format "n .+1"): nat_scope.

Lemma minus_match k1 k2: match k2 - k1 with O => k2 <= k1 | S _ => k1 < k2 end.

Section Exp.

Fixpoint exp (n m: nat) {struct m} : nat := 
  match m with O => 1 | 1 => n | (S m1) => n * exp n m1 end.

Lemma exp0 n: exp n 0 = 1.

Lemma expS n m: exp n (S m) = n * exp n m.

End Exp.

Section Fold2.

Variable A B C: Type.
Variable f: A -> B -> C -> C.

Definition dhead a (l : list A) :=
  match l with nil => a | b :: _ => b end.

Fixpoint fold2 (l1: list A) (l2: list B) (c: C) {struct l1}: C :=
  match l1, l2 with
    a::l3, b::l4 => fold2 l3 l4 (f a b c)
  | _, _ => c
  end.

Variable g: A -> B -> C.

Fixpoint map2 (l1: list A) (l2: list B) {struct l1}: list C :=
  match l1, l2 with
    a::l3, b::l4 => (g a b)::map2 l3 l4
  | _, _ => nil
  end.

Lemma map2_length l1 l2:
  length (map2 l1 l2) = min (length l1) (length l2).

Fixpoint dmap2 (a : A) (l1: list A) (l2: list B) {struct l2}: list C :=
  match l1, l2 with
    a1::l3, b1 :: l4 => g a1 b1 :: dmap2 a l3 l4
  |    nil, b1 :: l4 =>  g a b1 :: dmap2 a nil l4
  | _, _ => nil
  end.

End Fold2.
Arguments dhead[A].
Arguments fold2[A B C].
Arguments map2[A B C].
Arguments dmap2[A B C].

Section Perm.

Variable A: Type.

Inductive perm: list A -> list A -> Prop :=
  perm_id: forall l, perm l l
| perm_swap: forall a b l,  perm (a::b::l) (b::a::l)
| perm_skip: forall a l1 l2,  perm l1 l2 -> perm (a::l1) (a::l2)
| perm_trans: forall l1 l2 l3, perm l1 l2 -> perm l2 l3 -> perm l1 l3.

Lemma perm_sym l1 l2: perm l1 l2 -> perm l2 l1.

Lemma perm_cons_app a l1 l2: perm ((a:: l1) ++ l2) (l1 ++ (a:: l2)).

Lemma perm_length l1 l2: perm l1 l2 -> length l1 = length l2.

Lemma perm_in a l1 l2: perm l1 l2 -> In a l1 -> In a l2.

Lemma perm_in_inv a l1: In a l1 -> exists l2, perm l1 (a:: l2).

Lemma perm_incl_r l1 l2 l3: perm l1 l2 -> incl l1 l3 -> incl l2 l3.

Lemma perm_incl_l l1 l2 l3: perm l1 l2 -> incl l3 l1 -> incl l3 l2.

End Perm.

Arguments perm[A].

Section Uniq.

Variable A: Type.

Inductive uniq: list A -> Prop :=
  uniq_nil: uniq nil
| uniq_cons: forall a l, ~ In a l -> uniq l -> uniq (a::l).

Lemma uniq_perm l1 l2: perm l1 l2 -> uniq l1 -> uniq l2.

Lemma uniq_cons_inv a l: uniq (a::l) -> uniq l.

Lemma uniq_app_inv_l l1 l2: uniq (l1 ++ l2) -> uniq l1.

Lemma uniq_app_inv_r l1 l2: uniq (l1 ++ l2) -> uniq l2.

Lemma perm_incl_inv l1 l2: 
  uniq l1 -> uniq l2 -> incl l1 l2 -> exists l3, perm l2 (l1 ++ l3).

End Uniq.

Lemma list_split (A: Type) n1 n2 (l: list A):
 length l = n1 + n2 ->
   exists l1, exists l2, l = l1 ++ l2 /\ length l1 = n1 /\ length l2 = n2.

Lemma length_split (A B: Type) (a b: A) (lk: list B) l1 l2:
 length lk = length ((a:: l1) ++ b :: l2)%list ->
 exists k1, exists k2, exists lk1, exists lk2,
 lk = ((k1::lk1) ++ k2::lk2)%list /\ length lk1 = length l1 /\ length lk2 = length l2.

Lemma list_app_inj (A: Type) (l1 l2 l3 l4: list A):
 length l1 = length l3 -> l1 ++ l2 = l3 ++ l4 -> l1 = l3 /\ l2 = l4.

Lemma list_case (A:Type) (l: list A): l = nil \/ l <> nil.

Lemma list_dec (A: Type) (P: A -> Prop) l:
 (forall x, P x \/ ~ P x) -> (forall x, In x l -> P x) \/ (exists x, In x l /\ ~ P x).

Arguments uniq[A].

Inductive eq_Spec (A: Type) (x y: A): bool -> Prop :=
 |eq_Spect:  x = y -> eq_Spec A x y true
 |eq_Specf: x <> y -> eq_Spec A x y false.

Arguments eq_Spec[A].

Fixpoint bin (a b : nat) {struct a} : nat :=
 match a, b with
   _, O => 1
  | O, S b' => 0
  | S a', S b' => bin a' (S b') + bin a' b'
 end.

Lemma bin_0: forall (n : nat),  bin n 0 = 1.

Lemma bin_1: forall (n : nat),  bin n 1 = n.

Lemma bin_more: forall (n m : nat), n < m ->  bin n m = 0.
 
Lemma bin_nn: forall (n : nat),  bin n n = 1.
 
Lemma bin_def:
 forall (n k : nat),  bin (S n) (S k) = bin n (S k) + bin n k.
 
Fixpoint iter {A: Type} (f: A -> A) (n: nat) (x: A) :=
  match n with 
  | O => x
  | S n1 => f (iter f n1 x)
  end.

Coercion b2Prop (x : bool) := x = true.

Lemma b2PropT: b2Prop true.

Hint Resolve b2PropT.

Require Import Bool.

Lemma andbP b1 b2: b1 && b2 <-> b1 /\ b2.

Lemma div2_double_p n m : div2 (2 * n + m) = n + div2 m.

Lemma div2_prop n: n + div2 (n * (n - 1)) = div2 (n.+1 * n).

Lemma minus_minus_le m n: n <= m -> m - (m - n) = n.

Lemma minus0_le m n: m <= n -> m - n = 0.

Fixpoint eq_nat (m n: nat) :=
  match m, n with (S m), (S n) => eq_nat m n | 0, 0 => true | _, _ => false end.

Notation "m ?= n" := (eq_nat m n) (at level 70): nat_scope.

Inductive eq_nat_spec: nat -> nat -> bool -> Type := 
  eq_nat_spect: forall m, eq_nat_spec m m true
| eq_nat_specb: forall m n, m <> n -> eq_nat_spec m n false.

Lemma eq_natP m n: eq_nat_spec m n (m ?= n).

Notation "x .+2" := (S (S x))  (at level 9): nat_scope. *)

Require Import Field VectorSpace Kn Grassmann.
(* Field:
Require Import ZArith Aux Even.

Structure fparams: Type := {
 K:> Set;               
 v0: K;                
 v1: K;                
 eqK: K -> K -> bool;  
 oppK: K -> K;         
 addK : K -> K -> K;   
 multK : K -> K -> K;  
 invK : K -> K         
}.

Delimit Scope field_scope with f.

Notation "x ?= y" := (eqK _ x y) (at level 70) : field_scope.
Notation "x + y" := (addK _ x y) : field_scope.
Notation "- x" := (oppK _ x) : field_scope.
Notation "x ^-1" := (invK _ x) (at level 25) : field_scope.
Notation "x * y" := (multK _ x y) : field_scope.
Notation "0" := (v0 _) : field_scope.
Notation "1" := (v1 _) : field_scope.

Section ParamsProp.

Variable p: fparams.
Open Scope field_scope.

Structure fparamsProp: Type := {
 eqK_dec: forall x y: p, if x ?= y then x = y else x <> y;        
          
 addK_assoc: forall x y z: p, (x + y) + z = x + (y + z);
          
 addK_com: forall x y: p, x + y = y + x;
          
 addK0l: forall x: p, 0 + x = x;
          
 oppKr: forall x: p, x + - x = 0;
          
 multK_assoc: forall x y z: p, (x * y) * z = x * (y * z);
          
 multK_com: forall x y: p, x * y = y * x;
          
 multK1l: forall x: p, 1 * x = x;
          
 add_multKl: forall x y z: p, (x + y) * z = x * z + y * z;
          
 one_diff_zero: 1 <> 0 :> p;
          
 invKl: forall x: p, x <> 0 -> x * x^-1 = 1
}.

Fixpoint expK  (k: p) (n:nat) {struct n}: p := 
  match n with O => 1 | (S n1) => k * expK k n1 end.

Notation "x ^ k" := (expK x k) : field_scope.

Variable Hp: fparamsProp.

Implicit Types x y z: p.

Lemma eqKI: forall x, x ?= x = true.

Lemma eqK_spec x y: eq_Spec x y (x ?= y).

Lemma oppKl:  forall x, - x + x = 0.

Lemma addK_cancel x y z: x + y = x + z -> y = z.

Lemma addK_eq_opp: forall x y, x + (-y) = 0 -> x = y.

Lemma addK0r x: x + 0 = x.

Lemma opp_oppK x: - (- x) = x.

Lemma multK1r x: x * 1 = x.

Lemma add_multKr x y z: z * (x + y) = z * x + z * y.

Lemma oppK0: - 0 = 0 :> p.

Lemma opp_addK x y: - (x + y) = - x + - y.

Lemma multK0l x: 0 * x = 0.

Lemma multK0r x: x * 0 = 0.

Lemma opp_multKl x y: - (x * y) = - x * y.

Lemma opp_multKr x y: - (x * y) = x * - y.

Lemma opp_multK1l x: - x  = (-(1)) * x.

Lemma opp_multK1r x: - x  = x * (-(1)).

Lemma multK_m1_m1: -(1) * -(1) = 1 :>p.

Lemma expKS n: (-(1)) ^n.+1 = -(-(1)) ^n.

Lemma expK2m1 n: (-(1)) ^ n * (- (1)) ^  n =1.

Lemma expK_add n1 n2 a: a ^ (n1 + n2) = a ^n1 * a ^ n2.

Lemma expKm1_even n: even n -> (-(1))^ n = 1
with expKm1_odd n: odd n -> (-(1))^ n = -(1).

Lemma expKm1_sub m n: m <= n -> (-(1))^ (n - m) = (-(1))^ (n + m).

Lemma expKm1_2 n: (-(1))^ (2 * n) = 1.

Lemma expKm1_2E n m: (-(1))^ (2 * n + m) = (-(1))^ m.

Lemma invKr x: x <> 0 -> x^-1 * x = 1.

Lemma multK_cancel x y z: x <> 0 -> x * y = x * z -> y = z.

Lemma multK_swap x y z: x * (y * z) = y * (x * z).

Lemma multK_integral x y : x * y = 0 -> x = 0 \/ y = 0.

Lemma expK_integral x n : x^n = 0 -> x = 0.

Lemma expKm1_n0 n : (-(1))^n <> 0.

Fixpoint n_to_K n := 
  match n with O => 0: p | S n => (1 + n_to_K n) end.

Lemma n_to_K0: n_to_K 0 = 0.

Lemma n_to_K1: n_to_K 1 = 1.

Lemma n_to_K_add m n : n_to_K (m + n) = n_to_K m + n_to_K n.

Lemma n_to_K_minus m n : n <= m -> n_to_K (m - n) = n_to_K m + -n_to_K n.

Lemma n_to_K_mult m n : n_to_K (m * n) = n_to_K m * n_to_K n.

Definition Z_to_K (z: Z) :=
  match z with
  | Z0 => 0
  | Zpos _ => n_to_K (Z.abs_nat z)
  | Zneg _ => - (n_to_K (Z.abs_nat z))
  end.

Lemma Z_to_K_opp (z: Z): Z_to_K (-z)%Z = - Z_to_K z.

Lemma Z_to_K_pos (z: Z): (0 <= z)%Z -> Z_to_K z = n_to_K (Z.abs_nat z).

Lemma Z_to_K_add (z1 z2: Z): 
  Z_to_K (z1 + z2)%Z = Z_to_K z1 + Z_to_K z2.

Lemma Z_to_K_minus (z1 z2: Z): 
  Z_to_K (z1 - z2)%Z = Z_to_K z1 + - Z_to_K z2.

Lemma Z_to_K_mult (z1 z2: Z): 
  Z_to_K (z1 * z2)%Z = Z_to_K z1 * Z_to_K z2.

End ParamsProp.

Notation "x ^ k" := (expK _ x%f k) : field_scope.

Ltac Krm0 :=
 repeat ((rewrite multK0l || rewrite multK0r || rewrite oppK0 ||
         rewrite addK0l || rewrite addK0r)); auto.

Ltac Krm1 :=
  Krm0; 
  repeat (rewrite multK1l || rewrite multK1r || rewrite <- opp_multKr ||
          rewrite expK2m1  || rewrite <- opp_multKl || rewrite opp_oppK); auto. *)
(* VectorSpace:
Require Import Setoid Field Min List Aux.

Structure eparams: Type := {
 E:> Set;                      
 stype:> fparams;              
 E0: E;                        
 eqE: E -> E -> bool;          
 addE : E -> E -> E;          
 scalE : (K stype) -> E -> E   
}.

Delimit Scope vector_scope with v.

Notation "x ?= y" := (eqE _ x y) (at level 70): vector_scope.
Notation "0" := (E0 _): vector_scope.
Notation "x + y" := (addE _ x y): vector_scope.
Notation "x .* y" := (scalE _ x%f y) (at level 31, no associativity): vector_scope.

Arguments scalE _ _%field_scope _%vector_scope.

Section VectorSpace.

Variable p : eparams.

Open Scope vector_scope.

Implicit Type v x y z: p.
Implicit Type k: stype p.

Definition  mprod ks vs :=
   fold2 (fun k v r => k .* v + r) ks vs 0.

Notation " x *X* y " := (mprod x y) (at level 40, no associativity): vector_scope.

Definition free vs := 
  forall ks, length ks = length vs -> ks *X* vs = 0 -> 
    (forall k, In k ks -> k = 0%f).

Inductive cbl (l: list (E p)): (E p) -> Prop :=
  cbl0: cbl l 0
| cbl_in: forall v, In v l -> cbl l v
| cbl_add: forall x y, cbl l x -> cbl l y -> cbl l (x + y)
| cbl_scal: forall k x, cbl l x -> cbl l (k .* x).

Lemma cbl_trans l1 l2 x: 
  (forall i, In i l2 -> cbl l1 i) -> cbl l2 x -> cbl l1 x.
 
Definition is_base vs := free vs /\ forall e, cbl vs e.

Structure vparamsProp: Type := {
 sProp : fparamsProp p;
 eqE_dec: forall x y, if x ?= y then x = y else x <> y;        
          
 addE_assoc: forall x y z, (x + y) + z = x + (y + z);
          
 addE_com: forall x y, x + y = y + x;
          
 addE0l: forall x, 0 + x = x;
          
 scalE0l: forall x, 0 .* x = 0;
          
 scalE1: forall x, 1 .* x = x;
          
 scal_addEl: forall k1 k2 x, (k1 + k2) .* x = (k1.* x) + (k2 .* x);
          
 scal_addEr: forall k x y, k .* (x + y) = k .* x + k .* y;
          
 scal_multE: forall k1 k2 x, (k1 * k2) .* x = k1.* (k2 .* x)
          
}.

Variable Hp: vparamsProp.

Lemma eqE_refl x: (x ?= x) = true.

Lemma addE0r: forall x, x + 0 = x.

Let sfP := sProp Hp.

Lemma addE_cancell x y z : z + x = z + y -> x = y.

Lemma addE_cancelr x y z : x + z = y + z -> x = y.

Lemma scalE0r k : k .* 0 = 0.

Lemma scal_addE0 x : x + (- (1)) .* x = 0.

Lemma addE_eq_opp x y : x + (-(1)) .* y = 0 -> x = y.

Lemma mprod_S k ks v vs : (k :: ks) *X* (v :: vs) = k .* v + ks *X* vs.

Lemma mprod0l vs : nil *X* vs = 0.

Lemma mprod0r ks : ks *X* nil = 0.

Lemma mprod0 vs1 vs2 : map (fun _ : E p => 0%f) vs1 *X* vs2 = 0.

Lemma mprod_app ks1 ks2 vs1 vs2 :
   length ks1 = length vs1 -> 
      (ks1 ++ ks2) *X* (vs1 ++ vs2) = ks1 *X* vs1 + ks2 *X* vs2.

Lemma eqE_spec x y : eq_Spec x y (x ?= y).

Lemma free_nil : free nil.

Lemma free_cons v vs : free (v::vs) -> free vs.

Lemma free_perm vs1 vs2 : perm vs1 vs2 -> free vs2 -> free vs1.

Lemma uniq_free vs : free vs -> uniq vs.

Lemma free_incl vs1 vs2 : incl vs1 vs2 -> uniq vs1 -> free vs2 -> free vs1.

Lemma cbl_incl l1 l2 v : incl l1 l2 -> cbl l1 v -> cbl l2 v.

Lemma cbl0_inv x : cbl nil x -> x = 0.

Lemma mprod_cbl l ks : cbl l (ks *X* l).

Lemma addE_mprod ks1 ks2 vs : length ks1 = length ks2 ->
  map2 (fun k1 k2 => (k1 + k2)%f) ks1 ks2 *X* vs = ks1 *X* vs + ks2 *X* vs.

Lemma scalE_mprod k ks vs : 
 map (fun k1 => (k * k1)%f) ks *X* vs = k .* (ks *X* vs).

Lemma mprod_perm l1 l2 lk1: perm l1 l2 -> length lk1 = length l1 ->
  exists lk2, perm lk1 lk2 /\ lk1 *X* l1 = lk2 *X* l2.

Fixpoint lgenk (n: nat) (k: K p) {struct n} : list (K p) :=
  match n  with
    O => nil
  | 1 => k :: nil
  | S n1 => k::lgenk n1 k
  end.

Lemma lgenk_length n k : length (lgenk n k) = n.

Lemma genk0_mprod vs :  0 = lgenk (length vs) 0%f *X* vs.

Lemma cbl_mprod vs v : cbl vs v -> 
  exists ks, length ks = length vs /\ v = ks *X* vs.

Lemma scalE_add0 x : x + (- (1)) .* x = 0.

Lemma scalE_integral k x : k .* x = 0 -> {k = 0%f} + {x = 0}.

Lemma scalE_opp k1 k2 x : k1 .* ((- (k2)) .* x) = (-k1).* (k2 .* x).

Lemma scalE_swap k1 k2 x : k1 .* (k2 .* x) = k2 .* (k1 .* x).

Lemma addE_swap x1 x2 x3 : x1 + (x2 + x3) = x2 + (x1 + x3).

Lemma cblnil x : cbl nil x -> x = 0.

Lemma cbl1 x y : cbl (x::nil) y -> exists k, y = k .* x.

End VectorSpace.

Notation " x *X* y " := (mprod _ x y) (at level 40, no associativity): vector_scope.

Section Trans.

Variable p p1 : eparams.
Hypothesis Hp: vparamsProp p.
Hypothesis Hp1: vparamsProp p1.
Variable (f: p -> p1).
Variable (g : stype p -> stype p1).
Variable (g1 : stype p1 -> stype p).
Hypothesis Hf0: f 0%v = 0%v.
Hypothesis Hf1: forall x y : p, (f (x + y) = f x + f y)%v.
Hypothesis Hf2: forall (k: stype p) (x : p), (f (k .* x) = g k .* f x)%v.
Hypothesis Hg: forall k, g (g1 k) = k. 

Lemma cbl_map l v : cbl _ l v -> cbl _ (map f l) (f v).

Lemma cbl_map_inv l v :
 cbl _ (map f l) v -> exists v1, cbl _ l v1 /\ v = f v1.

End Trans.

Structure params: Type := {
 dim:> nat;           
 K:> fparams          
}.

Ltac Vrm0 := Krm0;
  repeat (rewrite addE0l ||rewrite addE0r || rewrite scalE0l|| rewrite scalE0r); auto. *)
(* Kn:
Require Import Aux List Setoid Field VectorSpace.

Section Kn.

Variable p : params.

Hypothesis Hp : fparamsProp p.

Notation "'K'" := (K p).

Delimit Scope kn_scope with k.
Open Scope vector_scope.
Open Scope kn_scope.

Fixpoint kn (n: nat): Set := 
  match n with O => unit | S n1 => (K * kn n1)%type end.

Fixpoint eq (n : nat) : kn n -> kn n -> bool :=
  match n return (kn n -> kn n -> bool) with
  | 0%nat => fun a b => true
  | S n1 =>
      fun l1 l2 =>
      let (v1, l3) := l1 in
      let (v2, l4) := l2 in 
      if (v1 ?= v2)%f then eq n1 l3 l4 else false
  end.

Fixpoint genk (n: nat) (k: K) {struct n}: (kn n) :=
   match n return kn n with 0%nat => tt |  
                            (S n1) => (k, genk n1 k) end.

Notation " [ k ] " := (genk _ k) (at level 10): kn_scope.

Fixpoint add (n : nat) : kn n -> kn n -> kn n :=
  match n return (kn n -> kn n -> kn n) with
  | 0%nat => fun a b => tt
  | S n1 =>
      fun l1 l2 =>
      let (v1, l3) := l1 in
      let (v2, l4) := l2 in ((v1 + v2)%f, add n1 l3 l4)
  end.

Fixpoint scal (n : nat) (k: K) {struct n}: kn n -> kn n :=
  match n return (kn n -> kn n) with
  | 0%nat => fun a => tt
  | S n1 =>
      fun l1 =>
      let (v1,l2) := l1 in ((k * v1)%f , scal n1 k l2)
  end.

Canonical Structure vn_eparams (n: nat) :=
  Build_eparams (kn n) K (genk n 0%f) (eq n) (add n) (scal n).

Definition fn n : vparamsProp (vn_eparams n).

Hint Resolve fn.

Ltac Kfold n :=
     change (add n) with (addE (vn_eparams n));
     change (scal n) with (scalE (vn_eparams n));
     change (genk n 0%f) with (E0 (vn_eparams n)).

Lemma scal_integral n k (x: kn n) : k .* x = 0 -> k = 0%f \/ x = 0.

Lemma genk_inj n k1 k2 : [k1] = [k2] :> kn n.+1 -> k1 = k2.

Lemma genk0_dec n (x: kn n) :  x = 0 \/ x <> 0.

Fixpoint l2kn (n:nat) (l:list K) {struct l} : kn n:=
  match n return kn n with 
  | 0 => tt 
  | S n1 => match l with 
            | nil => genk (S n1) 0%f
            | a::l1 =>  (a,l2kn n1 l1)
            end
  end.

Fixpoint kn2l (n : nat) : kn n -> list K :=
  match n return (kn n -> list K) with
  | 0 => fun x => nil
  | S n1 => fun v => let (a, v1) := v in a :: kn2l n1 v1
  end.

Lemma kn2ll2knE n x : l2kn n (kn2l n x) = x.

Lemma genk_id0 n i : In i (kn2l n (genk n 0%f)) -> i = 0%f.

Inductive eql_t0 : list K -> list K -> Prop :=
  eql_t0N: eql_t0 nil nil
| eql_t0Nl: forall l, eql_t0 l nil -> eql_t0 (0%f :: l) nil
| eql_t0Nr: forall l, eql_t0 nil l -> eql_t0 nil (0%f :: l) 
| eql_t0R: forall a l1 l2, eql_t0 l1 l2 -> eql_t0 (a :: l1) (a :: l2).

Hint Constructors eql_t0.

Lemma eql_refl l : eql_t0 l l.

Lemma eql_sym l1 l2 : eql_t0 l1 l2 -> eql_t0 l2 l1.

Lemma eql_trans l2 l1 l3 : eql_t0 l1 l2 -> eql_t0 l2 l3 -> eql_t0 l1 l3.

Lemma dmap2_eql a l1 l2 l3 :
  eql_t0 l2 l3 -> 
  eql_t0 (dmap2 (multK K) a l1 l2) (dmap2 (multK K) a l1 l3).

Lemma kn2l_0 n : eql_t0 (kn2l n 0) nil.

Fixpoint gen (n: nat) (p: nat) {struct n} : kn n :=
  match n return kn n with O => tt | S n1 =>
    match p with
      0 => (1%f, genk n1 0%f)
    | S p1 =>  (0%f, gen n1 p1) 
    end
  end.

Notation " 'e_ p" := (gen _ p) (at level 70): kn_scope.

Lemma gen_inj n p1 p2 : p1 < n -> p2 < n ->
  'e_p1 = ('e_p2 : kn n)  -> p1 = p2.

Lemma kn2l_e0 n : eql_t0 (kn2l n.+1 ('e_0)) (1%f :: nil).

Lemma kn2l_ei n i :
  eql_t0 (kn2l n.+1 ('e_i.+1))  (0%f :: kn2l n ('e_i)).

Definition lift (n: nat) (v: kn n) : (kn (S n)) :=  (0%f, v).

Lemma lift0 n : lift n 0 = 0.

Lemma lift_e : forall n i, 'e_(S i) = lift n ('e_i).

Lemma lift_add n x y : lift n (x + y) = lift n x + lift n y.

Lemma lift_scal n k x :  lift n (k .* x) = scalE (vn_eparams (S n)) k (lift n x).

Lemma lift_mprod (n: nat) ks vs : ks *X* map (lift n) vs =
  lift n (mprod (vn_eparams n) ks vs).

Fixpoint base (n : nat) : list (kn n) :=
  match n return list (kn n) with
  | 0 => nil
  | S n1 => ('e_0: kn (S n1)) :: map (lift n1) (base n1)
  end.

Lemma e_in_base n i : i < n -> In ('e_i) (base n).

Lemma e_in_base_ex n v : 
  In v (base n) -> exists p1, p1 < n /\ v = 'e_p1.

Lemma base_length n : length (base n) = n.

Lemma base_free n : free _ (base n).

Lemma k2l_mprod n (v: kn n) : kn2l n v *X* base n = v.

Lemma cbl_base n v : cbl _ (base n) v.

Lemma  kn_induct n (P: kn n -> Prop) :
     P 0 -> 
     (forall p, p < n -> P ('e_p)) ->
     (forall v1 v2, P v1 -> P v2 -> P (v1 + v2)) ->
     (forall k v, P v -> P (k .* v)) ->

Fixpoint proj (n: nat) k : (kn n) -> K :=
  match n return kn n -> K with 
  | O => fun _ => 0%f
  | S n1 => fun l => let (a,l1) := l in 
          match k with | O => a | S k1 => 
           proj n1 k1 l1
          end
  end.

Lemma proj0 n i : proj n i 0 = 0%f.

Lemma proj_e n i j : j < n ->
  proj n i ('e_j) = if (i ?= j)%nat then 1%f else 0%f.

Lemma proj_scal n i k x :  proj n i (k .* x) = (k * proj n i x)%f.

Lemma proj_add n i x y : 
 proj n i (x + y) = (proj n i x + proj n i y)%f.

Fixpoint pscal (n: nat): (kn n) -> (kn n) -> K :=
  match n return kn n -> kn n -> K with 
  | O => fun a b => 0%f
  | S n1 => fun l1 l2 => let (a,l3) := l1 in let (b,l4) := l2 in
                         (a * b + pscal n1 l3 l4)%f
  end.

Notation "a  [.]  b" := (pscal _ a b) (at level 40): kn_scope.

Lemma pscal0l n (x: kn n) : 0 [.] x = 0%f.

Lemma pscal0r n (x: kn n) : x [.] 0 = 0%f.

Lemma pscal_com n (x y: kn n) : x [.] y = y [.] x.

Lemma pscal_e n (i j: nat) : i < n -> j < n ->
  ('e_i: kn n) [.] ('e_j) = if (i ?= j)%nat then 1%f else 0%f.

Lemma pscal_scall n k (x y: kn n) :  
  (k .* x) [.] y = (k * (x [.] y))%f.

Lemma pscal_scalr n k (x y: kn n) :  
  x [.] (k .* y) = (k * (x [.] y))%f.

Lemma pscal_addl n (x y z: kn n) :  
  (x + y) [.] z = (x [.] z + (y [.] z))%f.

Lemma pscal_addr n (x y z: kn n) :  
  z [.] (x + y) = (z [.] x + (z [.] y))%f.

Definition Kn := kn p.
Definition K0 := genk p 0%f.
Definition Keq: Kn -> Kn -> bool := eq p.
Definition Kadd: Kn -> Kn -> Kn := add p.
Definition Kscal: K -> Kn -> Kn := scal p.
Definition Kproj: nat -> Kn -> K := proj p.
Definition Ksprod: Kn -> Kn -> K := pscal p.
Definition Kgen := gen p.

Canonical Structure v_eparams :=
  Build_eparams Kn K K0 Keq Kadd Kscal.
Definition f : vparamsProp v_eparams := fn p.

Fixpoint kprod (n : nat) : kn n -> kn n -> kn n :=
  match n with
  | 0%nat => fun a b => tt
  | S n1 =>
      fun l1 l2 =>
      let (v1, l3) := l1 in
      let (v2, l4) := l2 in ((v1 * v2)%f, kprod n1 l3 l4)
  end.

Local Notation "a  [*]  b" := (kprod _ a b) (at level 40).

Lemma kprod0l n a : 0 [*] a = 0 :> kn n.

Lemma kprod0r n a : a [*] 0 = 0 :> kn n.

Lemma kprodkl n k a : [k] [*] a = k .* a :> kn n.

Lemma kprodkr n k a : a [*] [k] = k .* a :> kn n.

Lemma kprod1l n a : [1%f] [*] a = a :> kn n.

Lemma kprod1r n a : a [*] [1%f] = a :> kn n.

Lemma kprod_addl n a b c : 
  (a + b) [*] c = a [*] c + b [*] c :> kn n.

Lemma kprod_addr n a b c : 
  a [*] (b + c) = a [*] b + a [*] c :> kn n.

Lemma kprod_scall n k a b : 
  (k .* a) [*] b = k .* (a [*] b) :> kn n.

Lemma kprod_scalr n k a b : 
  a [*] (k .* b) = k .* (a [*] b) :> kn n.

Lemma kprod_assoc n a b c : 
  (a [*] b) [*] c = a [*] (b [*] c) :> kn n.

End Kn.

Notation " 'e_ p" := (gen _ _ p) (at level 8) : Kn_scope.
Notation " [ k ] " := (genk _ _ k) (at level 9) : Kn_scope.
Notation "a  [.]  b" := (pscal _ _ a b) (at level 40): Kn_scope.
Notation "a  [*]  b" := (kprod _ _ a b) (at level 40): Kn_scope.

Delimit Scope Kn_scope with Kn.

Hint Constructors eql_t0. *)
(* Grassmann:
Require Import ArithRing Div2 Bool Even Setoid Min List Aux Field VectorSpace Kn.

Section Vect.

Variable p : params.

Hypothesis Hp : fparamsProp p.

Delimit Scope g_scope with g.
Open Scope g_scope.
Open Scope vector_scope.

Definition K1 := K.
Notation "'K'" := (K1 p) : g_scope.
Notation "'kn'" := (kn p).
Notation projk := (proj p).

Ltac Kfold n :=
     change (Kn.add p n) with (addE (Kn.vn_eparams p n));
     change (Kn.scal p n) with (scalE (Kn.vn_eparams p n));
     change (Kn.genk p n 0%f) with (E0 (Kn.vn_eparams p n)).

Fixpoint vect (n: nat): Set := 
  match n with O => K | S n1 => (vect n1 * vect n1)%type end.

Fixpoint eq (n : nat) : vect n -> vect n -> bool :=
  match n return (vect n -> vect n -> bool) with
  | 0%nat => fun a b => (a ?= b)%f
  | S n1 =>
      fun l1 l2 =>
      let (l3, l5) := l1 in
      let (l4, l6) := l2 in 
      if eq n1 l3 l4 then eq n1 l5 l6 else false
  end.

Fixpoint add (n : nat) : vect n -> vect n -> vect n :=
  match n return (vect n -> vect n -> vect n) with
  | 0%nat => fun a b => (a + b)%f
  | S n1 =>
      fun l1 l2 =>
      let (l3, l5) := l1 in
      let (l4, l6) := l2 in (add n1 l3 l4, add n1 l5 l6)
  end.

Fixpoint genk (n: nat) (k: K) {struct n}: (vect n) :=
   match n return vect n with 0%nat => k | n1.+1 => (genk n1 0%f, genk n1 k) end.
Notation " [ k ] " := (genk _ k%f) (at level 9): g_scope.
Arguments genk _ _%field_scope.

Fixpoint scal (n : nat) (k: K) {struct n}: vect n -> vect n :=
  match n return (vect n -> vect n) with
  | 0%nat => fun a => (k * a)%f
  | S n1 =>
      fun l1 =>
      let (l2, l3) := l1 in (scal n1 k l2, scal n1 k l3)
  end.

Canonical Structure vn_eparams (n: nat) :=
  Build_eparams (vect n) K [0] (eq n) (add n) (scal n).

Definition fn n : vparamsProp (vn_eparams n).

Hint Resolve fn.

Notation "1" := ([1]): g_scope.

Ltac Vfold n :=
     change (add n) with (addE (vn_eparams n));
     change (scal n) with (scalE (vn_eparams n));
     change (genk n 0) with (E0 (vn_eparams n)).

Hint Rewrite multK0l multK0r oppK0 addK0l addK0r 
             addE0r addE0l scalE0r scalE0l: GRm0.

Ltac Grm0 := autorewrite with GRm0; auto.

Fixpoint sub (n : nat) : vect n -> vect n -> vect n :=
  match n return (vect n -> vect n -> vect n) with
  | 0%nat => fun a b => (a + (- b))%f
  | S n1 =>
      fun v1 v2 =>
      let (x1, y1) := v1 in
      let (x2, y2) := v2 in (sub n1 x1 x2, sub n1 y1 y2)
  end.

Notation "x - y" := (sub _ x y): g_scope.

Lemma sub_add n (v1 v2: vect n) : v1 - v2 = v1 + (-(1)).* v2.

Lemma sub0l n (v: vect n) : 0 - v = (-(1)) .* v.

Hint Rewrite sub0l: GRm0.

Lemma sub0r n (v: vect n) : v - 0 = v.

Hint Rewrite sub0r: GRm0.

Lemma injk n k1 k2 : [k1] = [k2] :> vect n -> k1 = k2.

Lemma oppk n k : [-k] = (-(1)).* [k] :> vect n.

Lemma genkE n k : [k] = k .* 1 :> vect n.

Lemma deck0 n (x: vect n):  x = 0 \/ x <> 0.

Fixpoint gen (n: nat) (p: nat) {struct n} : vect n :=
  match n return vect n with 0 => 1%f | S n1 =>
    match p with
      0 => (genk n1 1%f, genk n1 0%f)
    | S p1 =>  (genk n1 0%f, gen n1 p1) 
    end
  end.

Notation "''e_' p" := (gen _ p) (at level 8, format "''e_' p"): g_scope.

Lemma inj_e n p1 p2 : p1 < n -> p2 < n ->
  'e_p1 = 'e_p2 :> vect n -> p1 = p2.

Fixpoint const (n: nat): (vect n) -> K :=
  match n return vect n -> K with 
  | O => fun a => a
  | S n1 => fun l => let (l1,l2) := l in const n1 l2
  end.

Notation "'C[ x ]" := (const _ x).

Lemma const0 n : 'C[ 0: vect n ] = 0%f.

Hint Rewrite const0: GRm0.

Lemma constk n k : 'C[[k]: vect n] = k.

Lemma const_scal n k (x: vect n): 'C[k .* x] = (k * 'C[x])%f.

Lemma const_add n (x1 x2: vect n): 'C[x1 + x2] = ('C[x1] + 'C[x2])%f.

Fixpoint eq0 (n : nat) : vect n -> bool :=
  match n return (vect n -> bool) with
  | 0%nat => fun a => (a ?= 0)%f
  | S n1 =>
      fun l1 =>
      let (l2, l3) := l1 in
      if eq0 n1 l2 then eq0 n1 l3 else false
  end.

Notation "x ?= 0" := (eq0 _ x) (at level 70): g_scope.

Lemma eq0_dec n (x: vect n) : if x ?= 0 then x = 0 else x <> 0.

Lemma eq0_spec n (x: vect n) : eq_Spec x 0 (x ?= 0).

Lemma eq0I n : ((0: vect n) ?= 0) = true.

Lemma en_def n : 'e_n = 1 :> vect n.

Lemma addk n k1 k2 : [k1] + [k2] = [k1 + k2] :> vect n.

Lemma scal_integral n k (x: vect n) : k .* x = 0 -> k = 0%f \/ x = 0.

Lemma scalk n k1 k2 : k1 .* [k2] = [k1 * k2] :> vect n.

Fixpoint hom (n k : nat) {struct n} : vect n -> bool :=
  match n return (vect n -> bool) with
  | 0%nat => fun a => match k with O => true | S _ => a ?= 0 end
  | S n1 =>
      fun l1 =>
       let (l2, l3) := l1 in
       (match k with O => l2 ?= 0 | S k1 => hom n1 k1 l2 end) && hom n1 k l3
  end.

Lemma homk0 n k : hom n k 0.

Hint Resolve homk0.

Lemma hom0K n k : hom n 0 [k].

Hint Resolve hom0K.

Lemma const_hom n k x : hom n k x -> 0 < k -> 'C[x] = 0%f.

Lemma hom0E n (x: vect n) : hom n 0 x -> x = ['C[x]].

Lemma hom1e n i : i < n -> hom n 1 'e_i.

Lemma homE n k1 k2 (x: vect n) : 
  hom n k1 x -> hom n k2 x -> k1 = k2 \/ x = 0.

Lemma hom_lt n k v : n < k -> hom n k v -> v = 0.

Lemma add_hom n k (x y: vect n) : 
  hom n k x -> hom n k y -> hom n k (x + y).

Hint Resolve add_hom.

Lemma scal_hom n k1 k2 (x: vect n) : 
  hom n k1 x -> hom n k1 (k2 .* x).

Hint Resolve scal_hom.

Fixpoint get_hom (n m : nat) {struct n} : vect n -> vect n :=
  match n return (vect n -> vect n) with
  | 0%nat => fun a => match m with O => a | S _ => 0 end
  | S n1 =>
      fun l1 =>
       let (l2, l3) := l1 in
       ((match m with O => [0] 
                 | S m1 => get_hom n1 m1 l2
         end), get_hom n1 m l3)
  end.

Lemma get_hom0 n m : get_hom n m [0] = [0].

Lemma get_homk0 n k: get_hom n 0 [k] = [k].

Lemma get_homkS n m k: get_hom n m.+1 [k] = [0].

Lemma get_hom_ei n m i :  i < n ->
  get_hom n m 'e_i = match m with 1 => 'e_i | _ => [0] end.

Lemma get_hom_scal n m k x : 
  get_hom n m (k .* x) = k .* get_hom n m x.

Lemma get_hom_add n m x y : 
  get_hom n m (x + y) = get_hom n m x + get_hom n m y.

Lemma get_hom_up n m x : n < m -> get_hom n m x = [0].

Fixpoint sum (n : nat) (f: (nat -> vect n)) (m : nat) {struct m} :
    vect n :=
  match m with
  | 0%nat => f 0%nat
  | S m1 => f m + sum n f m1
  end.

Lemma sumEl n f m : 
  sum n f m.+1 = f 0%nat + sum n (fun m => f m.+1) m.

Lemma sumEr n f m : sum n f m.+1 = f m.+1 + sum n f m.

Lemma sum_ext (n : nat) (f1 f2: (nat -> vect n)) (m : nat) :
  sum n.+1 (fun m => (f1 m, f2 m)) m = (sum n f1 m, sum n f2 m).

Lemma get_hom_sum n (x : vect n) :
   x = sum n (fun m => get_hom n m x) n.

Lemma hom_get_hom n (x : vect n) m : hom n m (get_hom n m x).

Fixpoint first_deg (n : nat) {struct n} : vect n -> nat :=
  match n return (vect n -> nat) with
  | 0%nat => fun a => 0%nat
  | S n1 =>
      fun l1 =>
      let (l2, l3) := l1 in
      if l2 ?= 0 then first_deg n1 l3 else S (first_deg n1 l2)
  end.

Lemma first_deg0 n : first_deg n 0 = 0%nat.

Lemma first_deg0i n v : first_deg n v = 0%nat -> hom n 0 v.

Lemma hom_first_deg n k x : x <> 0 -> hom n k x -> first_deg n x = k.

Definition lift (n: nat) (v: vect n) : (vect n.+1) :=  ((0: vect n), v).

Notation " x ^'l " := (lift _ x) (at level 9, format "x ^'l"): g_scope.

Lemma gen_lift n i : 'e_i.+1 = 'e_i^'l :> vect n.+1.

Lemma lift_k n k : [k] = [k]^'l :> vect n.+1.

Lemma lift_add n x y : (x + y)^'l = x^'l + y^'l :> vect n.+1.

Lemma lift_scal n (k: K) x :  (k .* x)^'l = k .* x^'l :> vect n.+1.

Lemma lift_mprod (n: nat) (ks: list K) vs : ks *X* map (lift n) vs = 
  (ks *X* vs)^'l.

Lemma lift_cbl n l (x: vect n) :
  cbl _ l x -> cbl _ (map (lift n) l) x^'l.

Lemma lift_inj n (x1 x2: vect n) : x1^'l = x2^'l -> x1 = x2.

Definition dlift (n: nat) (v: vect n) : (vect n.+1) := (v,(0: vect n)).

Notation "x ^'dl" := (dlift _ x) (at level 9, format "x ^'dl" ): g_scope.

Lemma dlift_add n x y : (x + y)^'dl = x^'dl + y^'dl :> vect n.+1.

Lemma dlift_scal n (k: K) x : (k .* x)^'dl = k .* x^'dl :> vect n.+1.

Lemma dlift_mprod (n: nat) (ks: list K) vs :
   ks *X* map (dlift n) vs = (ks *X* vs)^'dl.

Fixpoint proj (n: nat) k: (vect n) -> (list K) :=
  match n return vect n -> list  K with 
  | O => fun a  =>
          match k with | O => a::nil | _ => nil end
  | S n1 => fun l => let (l1,l2) := l in 
          match k with | O => proj n1 k l2 | S k1 => 
           (proj n1 k1 l1 ++ proj n1 k l2)%list
          end
  end.

Lemma proj0 n x : proj n 0 x = 'C[x]:: nil.

Lemma proj_hom0_eq n x y : 
  hom n 0 x -> hom n 0 y ->
  nth 0 (proj n 0 x) 0%f = nth 0 (proj n 0 y) 0%f ->  x = y.

Lemma proj_lt n m x : n < m -> proj n m x = nil.

Lemma proj_homn_eq n x y : 
  hom n n x -> hom n n y ->
  nth 0 (proj n n x) 0%f = nth 0 (proj n n y) 0%f ->  x = y.

Fixpoint all (n: nat): vect n :=
  match n return vect n with
  | 0 => 1
  | S n1 => (all n1, 0: vect n1)
  end.

Notation "'E'" := (all _).
 
Lemma all_hom n : hom n n E.

Hint Resolve all_hom.

Fixpoint base (n: nat) k:list (vect n) :=
  match n return list (vect n) with 
  | O =>  match k with | O => 1%f::nil | _ => nil end
  | S n1 => 
          match k with | O => 
                     map (lift n1) (base n1 k) | S k1 => 
           (map (dlift n1) (base n1 k1) ++ 
            map (lift n1) (base n1 k))%list
          end
  end.

Lemma proj_base_length n (x: vect n) k : 
  length (proj n k x) = length (base n k).

Lemma base0 n : base n 0 = 'e_n::nil.

Lemma base_lt_nil m n : m < n -> base m n = nil.

Lemma base_n n : base n n = all n::nil.

Lemma base_length n k : length (base n k) = bin n k.

Lemma base_lift n k :  incl (map (lift n) (base n k)) (base n.+1 k).

Lemma base_hom n k v : k <= n -> In v (base n k) -> hom n k v.

Lemma proj_homk n (x: vect n) k : 
  hom n k x -> proj n k x *X* base n k = x.

Lemma base_free n k : free _ (base n k).

Lemma e_in_base1 n i : i < n -> In 'e_i (base n 1).

Lemma e_in_base1_ex n v : 
  In v (base n 1) -> exists p1, p1 < n /\ v = 'e_p1.

Lemma base1_length n : length (base n 1) = n.

Lemma base1_S n:
  base n.+1 1 = ('e_0: vect n.+1) :: map (lift n) (base n 1).

Lemma base_nil n k : n < k -> base n k = nil.

Lemma cbl1_hom1_equiv n (x: vect n) : cbl _ (base n 1) x <-> hom n 1 x.

Lemma cblk_homk_equiv n k (x: vect n): cbl _ (base n k) x <-> hom n k x.

Lemma cbl_base1_split n x :
 cbl _ (base n.+1 1) x -> exists k, exists y, cbl _ (base n 1) y /\ x = ([k], y).

Lemma cbl_base1_list_split n l:
 (forall x, In x l -> cbl _ (base n.+1 1) x) -> 

Lemma hom_induct n k (P: vect n -> Prop) :
  P 0 -> (forall v, In v (base n k) -> P v) ->
     (forall v1 v2, P v1 -> P v2 -> P (v1 + v2)) ->
     (forall k v, P v -> P (k .* v)) ->
   
Fixpoint conj (n : nat) (b: bool) {struct n}: vect n -> vect n :=
  match n return (vect n -> vect n) with
  | 0%nat => fun a => if b then (- a)%f else a
  | S n1 =>
      fun l1 =>
      let (l2, l3) := l1 in (conj n1 (negb b) l2, conj n1 b l3)
  end.

Notation "x ^_ b" := (conj _ b x)  (at level 30).
Notation "x ^_'t" := (conj _ true x)  (at level 30).
Notation "x ^_'f" := (conj _ false x)  (at level 30).

Lemma conj_add n b (x y: vect n) : (x + y) ^_ b = x ^_ b + y ^_ b.

Lemma conj_invo n b (x: vect n) : x ^_ b ^_ b = x.

Lemma conj0 n b : 0 ^_ b = (0 : vect n).

Hint Rewrite conj0: GRm0.

Lemma conjk n b k : [k] ^_ b=  if b then [-k] else ([k]: vect n).

Lemma conj_neg n b (v: vect n) : v ^_ (negb b) = (-(1)) .*  (v ^_ b).

Lemma conjt n (v: vect n) : v ^_'t = (-(1)) .*  (v ^_'f).

Lemma conj_e n b i : i < n ->
  'e_i ^_ b = if b then ('e_i: vect n) else (- (1)).* 'e_i.

Lemma conj_scal n b k (x: vect n) : (k .* x) ^_ b = k .* x ^_ b.

Lemma conj_hom n b k (x: vect n) : hom n k x -> hom n k (x ^_ b).

Hint Resolve conj_hom.

Lemma conjf_hom n k (M: vect n) : hom n k M -> M ^_'f = (- (1))^k .* M.

Lemma conjt_hom n k (M: vect n) : hom n k M -> M ^_'t = (- (1))^k.+1 .* M.

Lemma conj_const n b (x: vect n) : 'C[x ^_ b] = if b then (-'C[x])%f else 'C[x].

Lemma conj_swap n b1 b2 (x: vect n) : x ^_ b2 ^_ b1 =  x ^_ b1 ^_ b2.

Lemma conj_all n b: (E  ^_ b) = 
   (if b then (-((-(1))^ n))%f else ((-(1))^ n)%f) .* E :> vect n.

Fixpoint join (n : nat) : vect n -> vect n -> vect n :=
  match n return (vect n -> vect n -> vect n) with
  | 0%nat => fun x y => (x * y)%f
  | S n1 =>
      fun x y =>
      let (x1, x2) := x in
      let (y1, y2) := y in (join n1 x1 y2 + join n1 (x2 ^_'f) y1, 
                             join n1 x2 y2)
  end.

Notation "x '∨' y" := (join _ x y) (at level 40, left associativity): type_scope.

Lemma join_scall n k (x y : vect n) : k .* x ∨ y = k .* (x ∨ y).

Lemma join0 (v1 v2: vect 0) : v1 ∨ v2 = (v1 ∨ v2)%f.

Lemma join0l n (x : vect n) : 0 ∨ x = 0.

Hint Rewrite join0l: GRm0.

Lemma join0r n (x : vect n) : x ∨ 0 = 0.

Hint Rewrite join0r: GRm0.

Lemma joinkl n k (x : vect n) : [k] ∨ x = k .* x.

Lemma joinkr n k (x : vect n) : x ∨ [k] = k .* x.

Lemma join1l n (x : vect n) : 1 ∨ x = x.

Lemma join1r n (x : vect n) : x ∨ 1 = x.

Lemma join_alll n (x: vect n) : all n ∨ x = 'C[x] .* all n.

Lemma join_allr n (x: vect n) : x ∨ all n = 'C[x] .* all n.

Lemma join_allhr k n x : hom n k x -> 0 < k -> x ∨ E = 0.

Lemma join_allhl k n x : hom n k x -> 0 < k -> E ∨ x = 0.

Lemma join_scalr n k (x y : vect n) : x ∨ (k .* y) = k .* (x ∨ y).

Lemma joink n k1 k2 : [k1] ∨ [k2] = [k1 * k2] :> vect n.

Lemma join_e0 n (M : vect n.+1) : 'e_0 ∨ M = (snd M, [0]).

Lemma join_ei n i (M : vect n.+1) : i < n ->

Lemma join_es n i j : 
   i < n -> j < n -> 'e_ i ∨ 'e_ j + 'e_ j ∨ 'e_ i = (0: vect n).

Lemma join_e n i : i < n -> 'e_ i ∨ 'e_ i = (0 : vect n).

Lemma join_addl n (x y z : vect n) : (x + y) ∨ z = x ∨ z + y ∨ z.

Lemma join_addr n (x y z : vect n) : z ∨ (x + y) = z ∨ x + z ∨ y.

Lemma conjf_join n (x y: vect n) : (x ∨ y) ^_'f =  x ^_'f ∨ y ^_'f.

Lemma join_assoc n (x y z : vect n) : x ∨ y ∨ z = x ∨ (y ∨ z).

Lemma cbl_join_com n (vs: list (vect n)) :
  (forall x y, In x vs -> In y vs -> y ∨ x = (- (1)).* (x ∨ y)) ->

Lemma cbl_base_join_com n x y :
 cbl _ (base n 1) x -> cbl _ (base n 1) y ->  y ∨ x = (- (1)).* (x ∨ y).

Lemma cbl_join_id n vs : 
  (forall x y, In x vs -> In y vs -> join n y x = (- (1)).* (x ∨ y)) ->

Lemma cbl_base_join_id n x : cbl _ (base n 1) x -> x ∨ x = 0.

Lemma join_hom1_id n x : hom n 1 x -> x ∨ x = 0.

Lemma lift_join n x y : lift n (x ∨ y) = lift n x ∨ lift n y.

Lemma join_hom n k1 k2 (x y: vect n) : 
  hom n k1 x -> hom n k2 y -> hom n (k1 + k2) (x ∨ y).

Hint Resolve join_hom.

Lemma join_big n k1 k2 (x y : vect n) : 
  hom n k1 x -> hom n k2 y -> n < k1 + k2 -> x ∨ y = 0.

Lemma const_join n (x y: vect n): 'C[x ∨ y] = ('C[x] * 'C[y])%f.

Lemma lift_decomp n (x y: vect n) : (x, y) = 'e_0 ∨ x^'l + y^'l.

Lemma base_in n k x: In x (base n k.+1) -> 

Fixpoint all_prods (n: nat) (vs: list (vect n)) {struct vs} : list (vect n) :=
  match vs with
    nil => 1 :: nil
  | v::vs1 => let vs1 := all_prods n vs1 in 
                (map (join n v) vs1 ++ vs1)%list
  end.

Lemma all_prods_nil n : all_prods n nil = 1 :: nil.

Lemma all_prods_cons n v vs : 
  all_prods n (v :: vs) = (map (join n v) (all_prods n vs) ++ (all_prods n vs))%list.

Lemma all_prods1 n vs : In (1) (all_prods n vs).

Lemma all_prods_id n vs : incl vs (all_prods n vs).

Lemma all_prods_length n vs : 
  length (all_prods n vs) = exp 2 (length vs).

Lemma all_prods_lift n vs :
  all_prods n.+1 (map (lift n) vs) = map (lift n) (all_prods n vs).

Lemma all_prods_hom n vs :
  (forall i, In i vs -> exists k, hom n k i) ->
  (forall i, In i (all_prods n vs) -> exists k, hom n k i).

Fixpoint v2l (n: nat) : vect n -> list K :=
  match n return vect n -> list K with
    O => fun k => k :: nil
  | S n1 => fun x => let (x1, x2) := x in
                      (v2l n1 x1 ++ v2l n1 x2)%list
  end.

Lemma v2l_length n v : length (v2l n v) = exp 2 n.

Lemma mprod_2l n (v: vect n) :  v2l n v *X*  all_prods n (base n 1) = v.

Lemma cbl_all_prods n v : cbl _ (all_prods _ (base n 1)) v.

Lemma all_prods_free n: free _ (all_prods _ (base n 1)).

Lemma vect_induct n (P: vect n -> Prop) :
  P (1: vect n) -> (forall v, In v (base n 1) -> P v) ->
     (forall v1 v2, P v1 -> P v2 -> P (v1 ∨ v2)) ->
     (forall v1 v2, P v1 -> P v2 -> P (v1 + v2)) ->
     (forall k v, P v -> P (k .* v)) ->

Lemma vect_hom_induct n (P: vect n -> Prop) :
  (forall k v, hom n k v -> P v) ->
  (forall v1 v2, P v1 -> P v2 -> P (v1 + v2)) ->
     (forall v, P v).
   
Fixpoint joinl n (l: list (vect n)) := match l with
| nil => 0
| a::nil => a
| a::l => a ∨ joinl n l
end.

Lemma joinl0 n : joinl n nil = 0.

Hint Rewrite joinl0 : GRm0.

Lemma joinl1 n x : joinl n (x::nil) = x.

Lemma joinlS n x l : l <> nil -> joinl n (x::l) = x ∨ joinl n l.

Lemma joinl_scal n k (a: vect n) l : 
   joinl _ (k .* a::l) = k .* joinl _ (a::l).

Lemma joinl_app n l1 l2 :
  l1 <> nil -> l2 <> nil -> joinl n (l1 ++ l2)%list = joinl n l1 ∨ joinl n l2.

Lemma joinl_base1_perm n l1 l2 :
 perm l1 l2 ->
 (forall x, In x l1 -> cbl _ (base n 1) x) ->
  (joinl n l1 = joinl n l2) \/ (joinl n l1 = (-(1)).* joinl n l2) .

Lemma joinl0_base1_perm n l1 l2 : perm l1 l2 ->
 (forall x, In x l1 -> cbl _ (base n 1) x) -> joinl n l1 = 0 -> joinl n l2 = 0.

Lemma lift_joinl n l : lift n (joinl n l) = joinl n.+1 (map (lift n) l).

Lemma joinl_hom1 n l :
 (forall x, In x l -> hom n 1 x) -> hom n (length l) (joinl n l).

Hint Resolve joinl_hom1.

Lemma joinl_swap n (a b: vect n) l: 
 cbl _ (base n 1) a ->  cbl _ (base n 1) b ->
   joinl _ (a::b::l) = (-(1)).* joinl _ (b::a::l).

Lemma joinl_top n (a: vect n) l1 l2 : 
 (forall i, In i (a :: l1) -> cbl _ (base n 1) i) ->
   joinl _ (l1 ++ (a::l2)) = (-(1))^length l1 .* joinl _ (a:: (l1 ++ l2)%list).

Lemma joinl_all n : 0 < n -> joinl n (base n 1) = E.

Definition is_vector n v := cbl _ (base n 1) v.

Definition is_vector_space n l := forall x, In x l -> is_vector n x.

Lemma joinl0_mprod n M : M <> nil -> is_vector_space n M ->
   joinl n M = 0 ->
   exists lk, exists i, length lk = length M /\ In i lk /\ i <> 0%f /\ lk *X* M = 0.

Lemma cbl_joinl0_mprod n M x : is_vector_space n M ->  
  cbl _ M x -> joinl n (x::M) = 0.

Definition decomposable n l M := is_vector_space n l /\ M = joinl n l.

Lemma decomp_cbl n M l x : is_vector n x ->
  decomposable n l M -> M <> 0 -> (x ∨ M = 0 <-> cbl _ l x). 

Lemma hom1_decomposable n x : hom n 1 x -> decomposable n (x::nil) x.

Lemma decomp_hom n (l: list (vect n)) M : decomposable n l M -> hom n (length l) M.

Fixpoint contra (n : nat) {struct n}: kn n -> vect n -> vect n :=
  match n return (kn n -> vect n -> vect n) with
  | 0%nat => fun k a => 0
  | S n1 =>
      fun lf l1 =>
      let (k, lf1) := lf in
      let (l2, l3) := l1 in 
         ((- (1)).* (contra n1 lf1 l2),  (k : K) .* l2 + contra n1 lf1 l3)
  end.

Notation "#< l , x ># " := (contra _ l x) (format "#< l ,  x >#").

Lemma contraE n l (M : vect n.+1) :

Lemma contra0r n lf : #<lf, 0># = (0: vect n).

Hint Rewrite contra0r: GRm0.

Lemma contra0l n (x:vect n) : #<0, x># = 0.

Lemma contrak n i lf : #<lf, [i]># = 0 :> vect n.

Lemma contra_e n i lf : i < n -> #<lf, 'e_i># = [projk _ i lf] :> vect n.

Lemma contra_scalr n k lf (x: vect n) : #< lf, k .* x ># = k .* #< lf , x >#.

Lemma contra_addr n lf (x y: vect n) : #< lf, x + y ># = #< lf, x ># + #< lf,  y >#.

Lemma contra_scall n (k : K) (x : kn n)  (M : vect n) :
 #< (scalE (Kn.vn_eparams p n) k x), M># = k .* #<x, M>#.

Lemma contra_addl n (x y : kn n) (M : vect n) :
 #< x + y, M ># =  #< x, M ># + #<y, M >#.

Lemma contra_conj n lf b (x: vect n) : #< lf, x ^_ b ># = #< lf, x ># ^_ (negb b).

Lemma contra_hom n lf k M : hom n k.+1 M -> hom n k #<lf , M>#.

Hint Resolve contra_hom.

Lemma contra_hom0 n lf M : hom n 0 M -> #<lf , M># = 0.

Lemma contra_id n lf (M: vect n) : #<lf, #< lf, M>#  ># = 0.

Lemma contra_swap n lf1 lf2 (M: vect n) :
  #<lf1, #< lf2, M>#  ># = (-(1)).*  #<lf2, #< lf1, M>#  >#.

Fixpoint v2k (n : nat) : vect n -> kn n :=
  match n return vect n -> kn n  with
  | O => fun v : vect 0 => tt
  | S n1  => fun v => let (v1,v2) := v in
             ('C[v1], v2k n1 v2)
  end.

Lemma contra_const n lf M : hom n 1 M -> 
  #<lf, M># = [(lf [.] v2k n M)%Kn].

Lemma contra_join n lf k1 k2 M1 M2 : hom n k1 M1 -> hom n k2 M2 ->
  #<lf, M1 ∨ M2># = #<lf, M1># ∨ M2 + ((- (1))^k1).* M1 ∨ #<lf, M2>#.

Lemma join_hom_com n k1 k2 x y :
 hom n k1 x -> hom n k2 y ->  y ∨ x = ((- (1)) ^(k1 * k2)).* (x ∨ y).

Lemma join_hom_odd n k x : (1+1 <> (0: K))%f -> hom n k x -> odd k -> x ∨ x = 0.

Lemma join_hom_id n k x : hom n k x -> odd k ->  x ∨ x = 0.

Lemma is_vector_space_swap n x l :
  is_vector_space n l -> In x l ->
  exists l1, is_vector_space n (x::l1) /\ joinl n l = joinl n (x::l1).

Fixpoint factor n: (vect n) -> (vect n) -> vect n :=
  match n return vect n -> vect n -> vect n with
  | O => fun x1 x2 => (x2 * x1^-1)%f
  | S n1 =>
        fun x1 x2 =>
        let (x11, x12) := x1 in
        let (x21, x22) := x2 in
        if x12 ?= 0 then
         
        ((0: vect n1), ('C[x11]^-1).* x21: vect n1) else
        let x32 := factor n1 x12 x22 in
          
             (factor n1 x12 (add n1 (('C[x11]) .* x32: vect n1) (scal n1 (-(1))%f  x21: vect n1))
               , x32)
   end.

Lemma factor0 n x : factor n x 0 = 0.

Lemma factor_scal n k x M : factor n x (k .* M) = k .* factor n x M.

Lemma factor_id n x : x <> 0 -> hom n 1 x -> factor n x x = 1.

Lemma factor_hom0E n x1 x2 : x1 <> 0 ->  hom n 1 x1 -> hom n 0 x2 ->
  factor n x1 (x1 ∨ x2) = x2.

Lemma factor_factor n x1 x2 : hom n 1 x1 -> x1 <> 0 ->  
  x1 ∨ x2 = 0 -> x2 = x1 ∨ factor n x1 x2.

Lemma factork n x k : x <> 0 -> hom n 1 x -> factor n x [k] = 0.

Lemma factor0_hom0 n x1 x2 : x1 <> 0 -> hom n 1 x1 -> hom n 0 x2 -> 
  factor n x1 x2 = 0.

Lemma factor_hom n k x1 x2 : x1 <> 0 -> x1 ∨ x2 = 0 -> 
  hom n 1 x1 -> hom n k.+1 x2 -> hom n k (factor n x1 x2).

Lemma factor_add n k x1 x2 x3 : x1 <> 0 ->
  hom n 1 x1 -> hom n k.+1 x2 -> hom n k.+1 x3 ->

Fixpoint fortho n : (vect n) -> (vect n) -> bool :=
  match n return vect n -> vect n -> bool with
  | O => fun x1 x2 => false
  | S n1 =>
        fun x1 x2 =>
        let (x11, x12) := x1 in
        let (x21, x22) := x2 in
        if x12 ?= 0 then x21 ?= 0 else  fortho n1 x12 x21 && fortho n1 x12 x22
   end.

Lemma fortho0 n : 0 < n -> fortho n 0 0.

Lemma fortho_refl n x : fortho n x x -> x = 0.

Lemma forthok n k1 k2 (v: vect n) : v <> 0 -> hom n k1.+1 v -> fortho n v [k2].

Lemma fortho_scal n k v1 v2 : fortho n v1 v2 -> fortho n v1 (k .* v2).

Lemma fortho_add n v1 v2 v3 : 
  fortho n v1 v2 -> fortho n v1 v3 -> fortho n v1 (v2 + v3).

Lemma fortho_conj n b v1 v2 : fortho n v1 v2 -> fortho n v1 (v2 ^_ b).

Lemma fortho_join n v1 v2 v3 : 
  fortho n v1 v2 -> fortho n v1 v3 -> fortho n v1 (v2 ∨ v3).

Lemma fortho_joinl n k v l : v <> 0 -> hom n k.+1 v -> 

Lemma factor_ortho n x1 x2 : x1 <> 0 -> hom n 1 x1 -> 
    fortho n x1 x2 -> factor n x1 (x1 ∨ x2) = x2.

Fixpoint fget n : (vect n) -> (vect n) -> K :=
  match n return vect n -> vect n -> K with
  | O => fun x1 x2 => 0%f
  | S n1 =>
        fun x1 x2 =>
        let (x11, x12) := x1 in
        let (x21, x22) := x2 in
        if x12 ?= 0 then (('C[x11])^-1 * 'C[x21])%f else fget n1 x12 x22
   end.

Lemma fget_scal n k x1 x2 : fget n x1 (k .* x2) = (k *  fget n x1 x2)%f.

Lemma fortho_fget n x1 x2 : x1 <> 0 -> hom n 1 x1 -> hom n 1 x2 ->
    fortho n x1 (x2 + (-(1) * fget n x1 x2)%f .* x1).

Lemma joinl_addmult n (f: vect n -> vect n -> K) x l :
hom n 1 x -> (forall i, In i l -> hom n 1 i) ->
x ∨ joinl n l = x ∨ joinl n (map (fun y => (y + (f x y) .* x)) l).

Lemma mprod_hom n k l1 l2 :
  (forall i, In i l2 -> hom n k i) -> hom n k (l1 *X* l2).

Hint Resolve mprod_hom.

Definition is_decomposable n M := exists l, decomposable n l M.

Lemma joinl_factor n x M : x <> 0 -> hom n 1 x ->
  is_decomposable n M -> x ∨ M = 0 ->
    exists k, exists l, (forall v, In v l -> hom n 1 v) /\ M = k .* joinl n (x::l).

Lemma decomposable_factor n k x M : x <> 0 -> hom n 1 x -> hom n k.+2 M ->

Fixpoint one_factor (n: nat) k : vect n -> vect n :=
  match n return vect n -> vect n with 
  | O => fun a  => a 
  | S n1 => fun l =>
          match k with 
          | O => l
          | S k1 => 
            let (l1,l2) := l in
            let r := one_factor n1 k1 l1 in  
            (0:vect n1, if r ?= 0 then one_factor n1 k l2 else r)
          end
  end.

Lemma one_factor0 n k : one_factor n k 0 = 0.

Lemma one_factor_hom n k1 k2 (x: vect n) :
 k2 < k1 -> hom n k1 x -> hom n (k1 - k2) (one_factor n k2 x).

Hint Resolve one_factor_hom.
 
Lemma one_factor_zero n k1 k2 (x: vect n) :
 k2 < k1 -> hom n k1 x -> one_factor n k2 x = 0 -> x = 0.

Definition mcontra n (ll: list (kn n)) (x: vect n) :=
  fold_left (fun x l => #<l,x>#) ll x.

Notation "#<< l , x >>#" := (mcontra _ l x).

Lemma mcontra_nil n (x: vect n) : #<<nil, x>># = x.

Lemma mcontra_cons n (x: vect n) a l : #<<a::l, x>># = #<<l, #<a,x>#>>#.

Lemma mcontra_app n l1 l2 (M: vect n) :  
  #<< l1 ++ l2, M>># = #<<l2, #<<l1, M>>#>>#.

Lemma mcontra0 n lfs : #<< lfs, 0 >># = (0: vect n).

Hint Rewrite mcontra0: GRm0.

Lemma mcontra_id n a l (M: vect n) : #<< a::a::l, M>># = 0.

Lemma mcontrak n lfs i : lfs <> nil -> #<< lfs, [i] >># = (0: vect n).

Lemma mcontra_scal n k lfs (x: vect n) : #<< lfs, k .* x >># = k .* #<< lfs , x >>#.

Lemma mcontra_swap n a b l (M: vect n) :  
  #<< a::b::l, M>># = (-(1)).*  #<<b::a::l, M>>#.

Lemma mcontra_add n lfs (x y: vect n) :
  #<< lfs, x + y >># = #<< lfs, x >># + #<< lfs,  y >>#.

Lemma mcontra_conj n lfs b (x: vect n) : 
  #<<lfs, x ^_ b >># = #<< lfs, x >># ^_ (iter negb (length lfs) b).

Lemma mcontra_hom n k (x: vect n) l :
  hom n k x -> hom n (k - length l) #<<l, x>>#.

Hint Resolve mcontra_hom.

Lemma mcontra_hom0 n lfs M : lfs <> nil -> hom n 0 M -> #<<lfs , M>># = 0.

Notation liftk := (Kn.lift p).

Lemma lift_contra n lf1 x : #< liftk n lf1, lift n x ># = lift n #<lf1, x>#.

Lemma lift_mcontra n lfs1 x :
  #<< map (liftk n) lfs1, lift n x >># = lift n #<<lfs1, x>>#.

Lemma mcontra_one_factor n k1 k2 (x: vect n) :
  k2 < k1 -> hom n k1 x -> 
 exists lfs, length lfs = k2 /\ #<<lfs , x>># = one_factor n k2 x.

Inductive cbl n (l: list (vect n)): nat -> (vect n) -> Prop :=
| cbl_in: forall v, In v l -> cbl n l 0%nat v
| cbl_add: forall k x y, cbl n l k x -> cbl n l k y -> cbl n l k (x + y)
| cbl_scal: forall k k1 x, cbl n l k x -> cbl n l k (k1 .* x)
| cbl_join: forall k v x, In v l -> cbl n l k x -> cbl n l k.+1 (v ∨ x).

Lemma cbl_cons n (a: vect n) l k x : cbl n l k x -> cbl n (a::l) k x.

Lemma joinl_join n l (v: vect n) : 
  (forall x, In x l -> hom n 1 x) -> In v l -> v ∨ joinl n l = 0.

Lemma cbl_joinl n (l: list (vect n)) :
  l <> nil -> (forall x, In x l -> hom n 1 x) -> cbl n l (pred (length l)) (joinl n l).

Lemma cbl_joinl0 n (l: list (vect n)) k x :
  (forall x, In x l -> hom n 1 x) -> cbl n l k x -> x ∨ joinl n l = 0.

Lemma cbl_hom n (l: list (vect n)) k x :
  (forall x, In x l -> hom n 1 x) -> cbl n l k x -> hom n k.+1 x.

Lemma cbl_contra n (l: list (vect n)) lf k x :
  (forall x, In x l -> hom n 1 x) -> cbl n l k.+1 x -> cbl n l k #<lf, x>#.

Lemma cbl_mcontra n (l: list (vect n)) lfs k x :
  length lfs <= k ->
  (forall x, In x l -> hom n 1 x) -> cbl n l k x -> cbl n l (k - length lfs) #<<lfs, x>>#.

Lemma decomp_one_factor_hom n (l: list (vect n)) M : l <> nil ->
 decomposable n l M -> hom n 1 (one_factor n (pred (length l)) M).

Lemma decomp_one_factor0 n (l: list (vect n)) M :
 decomposable n l M -> one_factor n (pred (length l)) M = 0 -> M = 0.

Lemma decomp_one_factor_join n (l: list (vect n)) M :
 decomposable n l M -> one_factor n (pred (length l)) M ∨ M = 0.

Fixpoint decomposek (n: nat) k (v: vect n) {struct k} : list (vect n) :=
  match k with 
  | O => nil 
  | S O => v::nil 
  | S k1 => let v1 := one_factor n k1 v in
            v1::decomposek n k1 (factor n v1 v)
  end.

Lemma decomposekSS (n: nat) k (v: vect n) :
  decomposek n k.+2 v =  

Lemma decomposek_cor n k v : 
v <> 0 -> is_decomposable n v -> hom n k v -> decomposable n (decomposek n k v) v.

Definition all_hom1 n l := fold_left (fun c x => c && hom n 1 x) l true.

Lemma all_hom1_cor n l :
 if all_hom1 n l then forall i, In i l -> hom n 1 i else 
     exists i, In i l /\ ~ hom n 1 i.

Definition decompose n (v: vect n) : option (list (vect n)) := 
  let d := first_deg n v in
  let l := decomposek n d v in
  if all_hom1 n l then
      if v ?= joinl n l then Some l else None
  else None.

Lemma  decompose_cor n v : 
   match decompose n v with
   | None => ~ is_decomposable n v
   | Some l => decomposable n l v
   end.

Definition grade n k x := hom n k x &&  
  if decompose n x then true else false.

Lemma gradeE n k x : 
  grade n k x <->  hom n k x /\
                   exists l, x = joinl n l /\
                             (forall y, In y l -> hom n 1 y).

Lemma grade0 n k : grade n k 0.

Lemma grade0E n x : grade n 0 x -> x = 0.

Lemma grade_hom n k x : grade n k x -> hom n k x.

Lemma grade1_hom n x : grade n 1 x = hom n 1 x.

Lemma grade_scal n k1 k2 x : grade n k1 x -> grade n k1 (k2 .* x).

Lemma grade_join n k1 k2 x y :
   grade n k1 x -> grade n k2 y -> grade n (k1 + k2) (x ∨ y).

Fixpoint dual n : vect n -> vect n :=
  match n return vect n ->  vect n with
  |    0 => fun a => a
  | S n1 => fun v => let (x,y) := v in (dual n1 (y ^_'f), dual n1 x)
  end.
Notation "'@ x " := (dual _ x) (at level 9).

Lemma dual0 n : '@0 = 0 :> vect n.

Hint Rewrite dual0: GRm0.

Lemma dual0E n (x: vect n) : '@x = 0 -> x = 0.

Lemma dual_hom n k v : hom n k v -> hom n (n - k) '@v.

Hint Resolve dual_hom.

Lemma dual_scal n k (v: vect n) : '@(k .* v) = k .* '@v.

Lemma dual_add n (v1 v2: vect n) : '@(v1 + v2) = '@v1 + '@v2.

Lemma dual_invo n k (v: vect n): hom n k v ->  '@('@v) = (-(1)) ^(k * n.+1) .* v.

Lemma dual_invoE n k (v: vect n) : hom n k v ->  v = ((-(1)) ^(k * n.+1)) .* '@('@v).

Lemma dual_all n : '@E = 1 :> vect n.

Lemma dual1 n : '@1 =  E :> vect n.

Lemma homn_ex n v : hom n n v -> exists k, v = '@[k].

Lemma dual_base n k v :
  In v (base n k) -> In '@v (base n (n - k)) \/ In ((-(1)) .* '@v) (base n (n - k)).

Fixpoint dconj (n : nat) (b: bool) {struct n} : vect n -> vect n :=
  match n return (vect n -> vect n) with
  | 0%nat => fun a => if b then (- a)%f else a
  | S n1 =>
      fun l1 =>
      let (l2, l3) := l1 in (dconj n1 b l2, dconj n1 (negb b) l3)
  end.

Notation "x ^d_ b" := (dconj _ b x)  (at level 29, left associativity).
Notation "x ^d_'t" := (dconj _ true x)  (at level 29, left associativity).
Notation "x ^d_'f" := (dconj _ false x)  (at level 29, left associativity).

Lemma dconj0 n b : 0 ^d_ b = 0 :> vect n.

Hint Rewrite dconj0: GRm0.

Lemma dconj_all n b :
       E ^d_ b = (if b then (-(1)) .* E else E) :> vect n.

Lemma dconj_scal n b k (x: vect n) : (k .* x)^d_ b = k .* x ^d_ b.

Lemma dconj_add n b (x y: vect n) : (x + y) ^d_ b = x ^d_ b + y ^d_ b.

Lemma dconj_invo n b (v: vect n) : v ^d_ b ^d_ b = v.

Lemma dconj_neg n b (v: vect n) : v ^d_ (negb b) = (-(1)) .*  (v ^d_ b).

Lemma dconjt n (v: vect n) : v ^d_'t = (-(1)) .*  (v ^d_'f).

Lemma dconjf_hom n k (M: vect n) : 
  hom n k M -> M ^d_'f = (- (1))^(n + k) .* M.

Lemma dconjt_hom n k (M: vect n) : 
 hom n k M -> M ^d_'t = (- (1))^(n + k).+1 .* M.

Lemma dconj_swap n b1 b2 (x: vect n) : x ^d_ b2 ^d_ b1 = x ^d_ b1 ^d_ b2.

Lemma dconj_conj_swap n b1 b2 (x: vect n) : (x ^_ b2) ^d_  b1 = x ^d_ b1 ^_ b2.

Lemma dconj_conj n b (x: vect n) : (x ^_ b) ^d_ b = (-(1))^n .* x.

Lemma dconj_hom n b k (x: vect n) : hom n k x -> hom n k (x ^d_ b).

Hint Resolve dconj_hom.

Lemma dconjf_joinl n (x y: vect n) : (x ∨ y) ^d_'f = x ^d_'f ∨ y ^_'f.

Lemma dconjf_joinr n (x y: vect n) : (x ∨ y) ^d_'f = x ^_'f ∨ y ^d_'f.

Lemma conj_dual n b (x: vect n): '@(x ^_ b) = '@x ^d_ b.

Lemma dconj_dual n b (x: vect n) : '@(x ^d_ b) = '@x ^_ b.

Lemma dualk n k : '@([k]) = k .* E :> vect n.

Definition dconst n (x: vect n) := 'C['@x].
Notation "'dC[ x ]" := (dconst _ x).

Lemma dconjk n b k :
  [k] ^d_ b = (if b then [(-(1))^n.+1 * k] else [(-(1))^n * k]:vect n).

Lemma dconj_const n b (x: vect n) :
  'C[x ^d_ b] = (if b then ((-(1))^n.+1 * 'C[x])%f else ((-(1))^n * 'C[x])%f).

Lemma conj_dconst n b (x: vect n) :
  'dC[x ^_ b] = (if b then ((-(1))^n.+1 * 'dC[x])%f else  ((-(1))^n * 'dC[x])%f).

Lemma dconj_dconst n b (x: vect n) :
  'dC[x ^d_ b] = (if b then (- 'dC[x])%f else  'dC[x]).

Lemma projn n (x : vect n) : proj n n x = 'dC[x] :: nil.

Lemma dconst_all n : 'dC[(E: vect n)] = 1%f .

Lemma dconst0 n : 'dC[0:vect n] = 0%f.

Hint Rewrite dconst0: GRm0.

Lemma dconst_scal n k (x: vect n) : 'dC[k .* x] = (k * 'dC[x])%f.

Lemma dconst_add n (x1 x2 : vect n) : 'dC[x1 + x2] = ('dC[x1] + 'dC[x2])%f.

Lemma dconst_hom n k x : hom n k x -> n <> k -> 'dC[x] = 0%f.

Lemma homn_all n x : hom n n x -> x = 'dC[x] .* E.

Lemma const_dual n (x: vect n) : 'C['@x] = 'dC[x].

Lemma dconst_dual n (x: vect n) : 'dC['@x] = 'C[x].

Fixpoint meet (n : nat) : vect n -> vect n -> vect n :=
  match n return (vect n -> vect n -> vect n) with
  | 0%nat => fun a b => (a * b)%f
  | S n1 =>
      fun v1 v2 => 
      let (x1, y1) := v1 in
      let (x2, y2) := v2 in (meet n1 x1 x2,
                                meet n1 x1 y2 +
                                meet n1 y1 (x2 ^d_'f))
  end.

Notation "x '∧' y" := (meet _ x y) (at level 45, left associativity).

Lemma meet0l n (x: vect n) : 0 ∧ x = 0.

Hint Rewrite meet0l: GRm0.

Lemma meet0r n (x: vect n) : x ∧ 0 = 0.

Hint Rewrite meet0r: GRm0.

Lemma meet1l n (x: vect n) : 1 ∧ x = ['C['@x]].

Lemma meet1r n (x: vect n) : x ∧ 1 = ['C['@x]].

Lemma meet_scall n k (x y : vect n) : k .* x ∧ y = k .* (x ∧ y).

Lemma meet_scalr n k (x y : vect n) : x ∧ k .* y = k .* (x ∧ y).

Lemma meet0 (v1 v2 : vect 0) : v1 ∧ v2 = (v1 * v2)%f.

Lemma meetS n (x1 x2 y1 y2 : vect n) :
 ((x1,y1): vect n.+1) ∧ (x2,y2) = 

Lemma dual_meet n (v1 v2 : vect n) : '@(v1 ∧ v2) = '@v1 ∨ '@v2.

Lemma conjf_meetl n (x y : vect n) : (x ∧ y) ^_'f = x ^_'f ∧ y ^d_'f.

Lemma conjf_meetr n (x y : vect n) : (x ∧ y) ^_'f = x ^d_'f ∧ y ^_'f.

Lemma dconjf_meet n (x y : vect n) : (x ∧ y) ^d_'f = x ^d_'f ∧ y ^d_'f.
   
Lemma dconjf_meetd n (x y : vect n) : (x ∧ y) ^d_'f = x ^_'f ∧ y ^_'f.

Lemma dconst_meet n (x y: vect n) : 'dC[x ∧ y] = ('dC[x] * 'dC[y])%f.

Lemma dual_join n (v1 v2: vect n) : '@(v1 ∨ v2) = '@v1 ∧ '@v2.

Lemma meet_addl n (x y z : vect n) : (x + y) ∧ z = x ∧ z + y ∧ z.

Lemma meet_addr n (x y z : vect n) : z ∧ (x + y) = z ∧ x + z ∧ y.

Lemma meet_assoc n (x y z : vect n) : x ∧ y ∧ z = x ∧ (y ∧ z).

Lemma meet_alll n (x: vect n) : all n ∧ x = x.

Lemma meet_allr n (x: vect n) : x ∧ all n = x.

Lemma meet_small n k1 k2 (x y : vect n) : 
  hom n k1 x -> hom n k2 y -> k1 + k2 < n -> x ∧ y = 0.

Lemma meet_hom n k1 k2 (x y : vect n) : 
  hom n k1 x -> hom n k2 y -> hom n (k1 + k2 - n) (x ∧ y).

Hint Resolve meet_hom.

Lemma meetkl0 n k1 k2 x : hom n k1 x -> n <> k1 -> [k2] ∧ x = 0.

Lemma meetkl n k x : hom n n x -> [k] ∧ x = [k * 'dC[x]].

Lemma meetkr0 n k1 k2 x : hom n k1 x -> n <> k1 -> x ∧ [k2] = 0.

Lemma meetkr n k x : hom n n x -> x ∧ [k] = ['dC[x] * k].

Lemma meet_hom_com n k1 k2 (x y : vect n) :
  hom n k1 x ->
  hom n k2 y -> y ∧ x = ((- (1))^((n + k1) * (n + k2))).* (x ∧ y).

Lemma meet_hom_id n k x : hom n k x -> odd (n - k) ->  x ∧ x = 0.

Lemma dual_join_compl n k v :
  In v (base n k) -> (v ∨ '@v = all n) \/ v ∨ '@v = (-(1)) .*  all n.

Lemma join01E n x y : hom n 1 x -> hom n 1 y -> 
   x ∨ y = 0 -> exists k, x = k .* y \/ y = k .* x.

Lemma homn_1 n k1 k2 x y : 
  hom n k1 x -> hom n k2 y -> n = (k1 + k2)%nat -> x ∧ y = 'dC[x ∨ y] .* 1.

Lemma join2_meetE n k1 k2 (x y : vect n) : 
  hom n k1 x -> hom n k2 y -> n <= k1 + k2 ->  x ∨ y = (x ∧ y) ∨ E.

Lemma join_meet_swap n k1 k2 k3 (x y z : vect n) : 
   hom n k1 x -> hom n k2 y ->  hom n k3 z -> (k1 + k2 + k3 = n)%nat -> 
    x ∧ (y ∨ z) = (x ∨ y) ∧ z.

Lemma join3_meetE n k1 k2 (x y z : vect n) : 
  hom n n x -> hom n k1 y -> hom n k2 z ->  n <= k1 + k2 ->  
  x ∧ (y ∨ z) = (x ∧ y ∧ z) ∨ E.

Lemma splitlr n k1 k2 x y z : hom n k1 x -> hom n 1 y ->  hom n k2 z ->
  (x ∨ y) ∧ z = (-(1))^(n + (k1 + k2).+1) .* (x ∧ (y ∨ z)) +

Lemma splitll n k1 k2 x y z : hom n k1 x -> hom n 1 y ->  hom n k2 z ->
  (y ∨ x) ∧ z = (-(1))^(n + k2.+1) .* ((x ∧ (y ∨ z)) - y ∨ (x ∧ z)).

Lemma splitrr n k1 k2 x y z : hom n k1 x -> hom n 1 y ->  hom n k2 z ->
  z ∧ (x ∨ y) = (-(1))^(n + k2.+1) .* ((z ∨ y) ∧ x - (z ∧ x) ∨ y).

Lemma splitrl n k1 k2 x y z : hom n k1 x -> hom n 1 y ->  hom n k2 z ->
  z ∧ (y ∨ x) = (-(1))^(n + (k1 + k2).+1) .* (z ∨ y) ∧ x + y ∨ (z ∧ x).

Lemma inter n k1 k2 x y z : hom n 1 x -> hom n k1 y ->  hom n k2 z ->
  x ∨ y = 0 -> x ∨ z = 0 -> x ∨ (y ∧ z) = 0.

Lemma join_meet_distrl n k1 k2 x y z :
   hom n k1 x -> hom n 1 y ->  hom n k2 z ->
    y ∨ (x ∧ z) = (-(1))^(n + k2) .* ((y ∨ x) ∧ z)  +  x ∧ (y ∨ z).

Lemma meet_join_distrl n k1 k2 x y z :
  hom n k1 x -> hom n 1 y ->  hom n k2 z ->
  '@y ∧ (x ∨ z) = (-(1))^k2 .* (('@y ∧ x) ∨ z)  +  x ∨ ('@y ∧ z).
 
Lemma grade_dual n k x : k < n -> grade n k x -> grade n (n - k) '@x.

Lemma grade_meet n k1 k2 x y : n < k1 + k2 ->
  grade n k1 x -> grade n k2 y -> grade n (k1 + k2 - n) (x ∧ y).

Definition Kn := kn p.

Fixpoint k2g (n: nat) {struct n} : kn n ->  vect n :=
  match n return kn n -> vect n with 
    O => fun k => 0%f
  | S n1 => fun v => let (k, v1) := v in ([k], k2g n1 v1)
  end.

Notation "'v_ x" := (k2g _ x) (at level 9). 
Notation "'kn n" := (vn_eparams p (pred n)) (at level 10).

Lemma k2g0 n : 'v_0 = 0 :> vect n.

Lemma k2g_add n x y : 'v_(x + y) = 'v_x + 'v_y :> vect n. 

Lemma k2g_scal n k x : 'v_(k .* x) = (k: K) .* 'v_x :> vect n.

Lemma k2g_unit n i : i < n -> 'v_('e_i)%Kn = 'e_i :> vect n.

Lemma k2g_hom n x : hom n 1 ('v_x).

Lemma hom1E n x : hom n 1 x -> exists y, x = 'v_y.

Lemma k2glift n x : 'v_(Kn.lift p n x) = ('v_x)^'l.

Lemma pscal_join n x y : 'v_x ∨ '@('v_y) =  ((x [.] y)%Kn:K) .* E :> vect n.

Lemma pscal_meet n x y : 'v_x ∧ '@('v_y) =  ((x [.] y)%Kn:K) .* 1 :> vect n.

Definition V0 := genk (dim p) 0.

Definition V1 := genk (dim p) 1.
Definition Vect := vect p.

Definition Veq: Vect -> Vect -> bool := eq p.

Definition Vadd: Vect -> Vect -> Vect := add p.

Definition Vscal: K -> Vect -> Vect := scal (dim p).

Definition Vgen := gen p.
Definition Vgenk := genk p.

Definition Vconj: bool -> Vect -> Vect := conj (dim p).

Definition Vjoin: Vect -> Vect -> Vect := join (dim p).
Definition Vmeet: Vect -> Vect -> Vect := meet (dim p).
Definition Vcontra: Kn -> Vect -> Vect := contra (dim p).
Definition Vdual: Vect -> Vect := dual (dim p).
Definition Vdecompose: Vect -> option (list Vect) := decompose (dim p).
Definition K2G: Kn -> Vect  := k2g p.

Definition v_eparams :=
  Build_eparams Vect K V0 Veq Vadd Vscal.

Definition f: vparamsProp (Kn.v_eparams p) := (Kn.fn p Hp p).

End Vect.

Delimit Scope Gn_scope with Gn.
Notation " 'e_ p" := (gen _  _ p) : Gn_scope.
Notation " [ k ] " := (genk _ _ k) (at level 9) : Gn_scope.

Require Import QArith.

Open Scope Q_scope.

Definition Qparams (n:nat) := Build_params 
   n
  (Build_fparams
  Q 
  0%Q
  1%Q
 Qeq_bool
 Qopp
 Qplus
 Qmult
 Qinv)
.

Module Ex2D.

Local Definition p := Qparams 2.

Notation "[[ X: x , Y: y , X**Y: xy ]]" :=  ((xy,x),(y,0)).

Definition X := (Vgen p 0).
Eval compute in X.
Definition Y := (Vgen p 1).
Eval compute in Y.

Notation "x '∨' y" := (Vjoin p  x y) (at level 40, left associativity).
Notation "x + y" := (Vadd p  x y).
Notation "k .* x" := (Vscal p  k x).
Notation "x '∧' y" := (Vmeet p  x y) (at level 40, left associativity).
Notation "'@  x" := (Vdual p x) (at level 100).

Eval vm_compute in (X ∨ Y) ∧ (X ∨ Y).

Eval vm_compute in '@(X + Y).

Eval vm_compute in (X + Y) ∨ '@(X + Y).

End Ex2D.

Module Ex3D.

Local Definition p := Qparams 3.

Notation "[[ X: x , Y: y ,  Z: z , X**Y: xy , Y**Z: yz  , X**Z: xz , X**Y**Z: xyz ]]" :=
  ((((xyz,xy),(xz,x)), ((yz,y),(z,0)))).

Definition X := (Vgen p 0).
Eval compute in X.
Definition Y := (Vgen p 1).
Eval compute in Y.
Definition Z := (Vgen p 2).
Eval compute in Z.

Notation "x '∨' y" := (Vjoin p  x y) (at level 40, left associativity).
Notation "x + y" := (Vadd p  x y).
Notation "k .* x" := (Vscal p  k x).
Notation "x '∧' y" := (Vmeet p  x y) (at level 40, left associativity).
Notation "'@  x" := (Vdual p x) (at level 100).

Eval vm_compute in '@(Vgen p 3).

Eval vm_compute in (X ∨ Z) ∧ (Y ∨ Z).

Eval vm_compute in '@((X∨Y)∧ ( Z)).

Eval vm_compute in (X + Y) ∨ '@(X + Y).

Eval vm_compute in Vdecompose p ((X ∨ Y) ∧ (Y ∨ Z)).

Eval vm_compute in Vdecompose p ((X + Y) ∨ (X + Z)).

Eval vm_compute in Vdecompose p ((X + Y + Z) ∨ (X + Z) ∨ (X + Y)).

Eval vm_compute in Vdecompose p ((X + Y) ∨ (Y + Z)).

Eval vm_compute in (X + Y) ∨ (X + Z) + 
  (-1#1)%Q .* (((-1#1)%Q .* Y + Z) ∨ ((-1#1)%Q .* (X + Y))).

Eval vm_compute in ((-1#1)%Q .* Y + Z) ∨ (X + Y) ∨ (X + Z).

Eval vm_compute in (X ∨ Y ∨ Z) ∨ (X ∨ Y ∨ Z).
Eval vm_compute in (X + Y + Z) ∨ (X + Y + Z).
Eval vm_compute in Z ∨ Y ∨ X.
Eval vm_compute in X ∨ Z.
Eval vm_compute in Z ∨ X.
Eval vm_compute in X ∨ Y ∨ Z.
Eval vm_compute in Z ∨ X ∨ Y.
Eval vm_compute in Y ∨ X ∨ Z.
Eval vm_compute in Y ∨ X.

End Ex3D.

Module Ex4D.

Local Definition p := Qparams 4.

Notation " '[[' 'X:' x ',' 'Y:' y ','  'Z:' z , 'T:' t ',' 'X**Y:' xy ',' 'X**Z:' xz ',' 'X**T:' xt ',' 'Y**Z:' yz ',' 'Y**T:' yt ',' 'Z**T:' zt ',' 'X**Y**Z:' xyz ',' 'X**Y**T:' xyt ',' 'X**Z**T:' xzt ',' 'Y**Z**T:' yzt ','  'X**Y**Z**T:' xyzt ','  'K:' vv  ']]'" :=
 ((((xyzt, xyz), (xyt, xy)), ((xzt, xz), (xt, x))) , 
  (((yzt, yz), (yt, y)), ((zt,z), (t, vv)))).

Definition X := (Vgen p 0).
Eval compute in X.
Definition Y := (Vgen p 1).
Eval compute in Y.
Definition Z := (Vgen p 2).
Eval compute in Z.
Definition T := (Vgen p 3).
Eval compute in T.

Notation "x '∨' y" := (Vjoin p  x y) (at level 40, left associativity).
Notation "x + y" := (Vadd p  x y).
Notation "k .* x" := (Vscal p  k x).
Notation "x '∧' y" := (Vmeet p  x y) (at level 40, left associativity).
Notation "'@  x" := (Vdual p x) (at level 100).
Notation "#< l , x ># " := (Vcontra p l x).

Eval vm_compute in '@X.

Eval vm_compute in (X + Y) ∨ '@(X + Y).

Definition X' := (1, (0, (0, (0, tt)))).
Definition Y' := (0, (1, (0, (0, tt)))).
Definition Z' := (0, (0, (1, (0, tt)))).
Definition T' := (0, (0, (0, (1, tt)))).

Definition U := (X + Y) ∨ Z.

Eval vm_compute in U.

Definition fxy := #<Y', #< X', U ># >#.
Definition fxz := #<Z', #< X', U ># >#.
Definition fxt := #<T', #< X', U ># >#.
Definition fyz := #<Z', #< Y', U ># >#.
Definition fyt := #<T', #< Y', U ># >#.
Definition fzt := #<T', #< Z', U ># >#.

Eval vm_compute in fxy.

Eval vm_compute in #< Y', X>#.

Eval vm_compute in (X ∨ Y ∨ Z) ∨ (X ∨ Y ∨ Z).

Eval vm_compute in (X + Y + Z) ∨ (X + Y + Z).
Eval vm_compute in Z ∨ Y ∨ X.
Eval vm_compute in X ∨ Z.
Eval vm_compute in Z ∨ X.
Eval vm_compute in X ∨ Y ∨ Z.
Eval vm_compute in Z ∨ X ∨ Y.
Eval vm_compute in Y ∨ X ∨ Z.
Eval vm_compute in Y ∨ X.
Eval vm_compute in X ∨ T.
Eval vm_compute in T ∨ X.

Eval vm_compute in Vconj p false (Z ∨ T) ∨ (X ∨ Y).

Eval vm_compute in (X ∨ Y ∨ Z ∨ T) ∨ (X ∨ Y ∨ Z ∨ T).

End Ex4D.

Module Ex5D.

Local Definition p := Qparams 5.

Notation " [[ X: x , Y: y ,  Z: z , T: t , U: u , X**Y: xy , X**Z: xz , X**T: xt , X**U: xu , Y**Z: yz , Y**T: yt , Y**U: yu , Z**T: zt , Z**U: zu , T**U: tu , X**Y**Z: xyz , X**Y**T: xyt , X**Y**U: xyu , X**Z**T: xzt , X**Z**U: xzu , X**T**U: xtu , Y**Z**T: yzt , Y**Z**U: yzu , Y**T**U: ytu , Z**T**U: ztu , X**Y**Z**T: xyzt , X**Y**Z**U: xyzu , X**Y**T**U: xytu , X**Z**T**U: xztu , Y**Z**T**U: yztu , X**Y**Z**T**U: xyztu , 'K:' vv ]]" :=
(
 ((((xyztu, xyzt), (xyzu, xyz)), ((xytu, xyt), (xyu, xy))) , 
  (((xztu, xzt), (xzu, xz)), ((xtu,xt), (xu, x)))),
 ((((yztu, yzt), (yzu, yz)), ((ytu, yt), (yu, y))) , 
  (((ztu, zt), (zu, z)), ((tu,t), (u, vv))))).

Definition X := (Vgen p 0).
Eval compute in X.
Definition Y := (Vgen p 1).
Eval compute in Y.
Definition Z := (Vgen p 2).
Eval compute in Z.
Definition T := (Vgen p 3).
Eval compute in T.
Definition U := (Vgen p 4).
Eval compute in U.

Notation "x '∨' y" := (Vjoin p  x y) (at level 40, left associativity).
Notation "x + y" := (Vadd p  x y).
Notation "k .* x" := (Vscal p  k x).
Notation "x '∧' y" := (Vmeet p  x y) (at level 40, left associativity).
Notation "'@  x" := (Vdual p x) (at level 100).

Eval vm_compute in Vconj p false (T ∨ U) ∨ (X ∨ Y ∨ Z).
Eval vm_compute in Vconj p false (X ∨ Y ∨ Z ∨ T ∨ U).

End Ex5D.

Module Ex6D.

Local Definition p := Qparams 6.

Definition X := (Vgen p 0).
Eval compute in X.
Definition Y := (Vgen p 1).
Eval compute in Y.
Definition Z := (Vgen p 2).
Eval compute in Z.
Definition T := (Vgen p 3).
Eval compute in T.
Definition U := (Vgen p 4).
Eval compute in U.
Definition K := (Vgen p 5).
Eval compute in K.

Notation "x '∨' y" := (Vjoin p  x y) (at level 40, left associativity).
Notation "x + y" := (Vadd p  x y).
Notation "k .* x" := (Vscal p  k x).
Notation "x '∧' y" := (Vmeet p  x y) (at level 40, left associativity).
Notation "'@  x" := (Vdual p x) (at level 100).

Eval vm_compute in 
  ((X ∨ (Y ∨ Z ∨ T)) + (U ∨ K)) ∨
  ((X ∨ (Y ∨ Z ∨ T)) + (U ∨ K)).

Eval vm_compute in Vconj p false (T ∨ U) ∨ (X ∨ Y ∨ Z).
Eval vm_compute in Vconj p false (X ∨ Y ∨ Z ∨ T ∨ U).

Eval vm_compute in
  ((X ∨ T) + (Y ∨ Z)) ∨ ((X ∨ T) + (Y ∨ Z)).

End Ex6D. *)



Section Vect.



Variable p : params.



Hypothesis Hp : fparamsProp p.



Delimit Scope g_scope with g.

Open Scope g_scope.

Open Scope vector_scope.



Definition K1 := K.

Notation "'K'" := (K1 p) : g_scope.

Notation projk := (Kn.proj p _).



Notation gvp := (Grassmann.vn_eparams p).



Notation "x '∧' y" := (join p _ x y) (at level 40, left associativity).

Notation "x + y" := (addE _ x y).

Notation "k .* x" := (scalE (gvp _) k x).

Notation "k .* x" := (scalE _ k x) : Kn_scope.

Notation vect := (vect p).

Notation "x ^_'f" := (conj p _ false x)  (at level 30).

Notation "'C[ x ]" := (const p _ x).

Notation " [ k ] " := (genk p  _ k%f) (at level 9).

Notation kn := (kn p).

Notation "#< l , x ># " := (contra p _ l x).

Notation "'v_ x" := (k2g  p _ x) (at level 9). 

Notation "''e_' i" := (gen p _ i).

Notation "'@ x " := (dual p _ x) (at level 9).

Notation E := (all p _).



Canonical Structure vn_eparams (n : nat) :=

  Build_eparams (vect n) K [0] (eq p n) (add p n) (scal p n).



Ltac Vfold n :=

     change (VectorSpace.K p) with (K1 p);

     change (add p n) with (addE (gvp n));

     change (scal p n) with (scalE (gvp n));

     change (genk p n 0%f) with (E0 (gvp n)).



Hint Resolve (fn _ Hp).



Fixpoint gprod (n : nat) : kn n -> vect n -> vect n -> vect n :=

  match n return (kn n -> vect n -> vect n -> vect n) with

  | 0%nat => fun k x y => (x * y)%f

  | S n1 =>

    fun l x y =>

      let (k1, l1) := l in 

      let (x1, x2) := x in

      let (y1, y2) := y in 

     (     gprod n1 l1 x1 y2  +      gprod n1 l1 (x2 ^_'f) y1,

           gprod n1 l1 x2 y2 + k1 .* gprod n1 l1 (x1 ^_'f) y1)

  end.



Notation "a [*  l ]  b " := (gprod _ l a b) (at level 9).



Lemma grpod_l0_join n x y : x [* 0] y = x ∧ y :> vect n.

Proof.

induction n as [|n IH]; simpl; auto.

destruct x; destruct y; Vfold n; rewrite !IH; Vrm0.

Qed.



Lemma gprodE n l (M1 M2 : vect n.+1) :

  M1 [* l] M2 =

     ( (fst M1) [* snd l] (snd M2)  +  ((snd M1) ^_'f) [* snd l]  (fst M2),

           (snd M1) [* snd l] (snd M2) + 

              fst l .* (((fst M1) ^_'f) [* snd l]  (fst M2))).

Proof. destruct l; destruct M1; destruct M2; simpl; auto. Qed.



Lemma gprod0r n l x : x [* l] 0 = 0 :> vect n.

Proof.

induction n as [| n IH]; simpl; try Vfold n; Krm0.

destruct l; destruct x; rewrite !IH; Vrm0.

Qed.



Lemma gprod0l n l y : 0 [* l] y = 0 :> vect n.

Proof.

induction n as [| n IH]; simpl; try Vfold n; Krm0.

destruct l; destruct y; rewrite conj0, !IH; Vrm0.

Qed.



Lemma gprodkl n l k y : [k] [* l] y = k .* y :> vect n.

Proof.

induction n as [| n IH]; simpl; try Vfold n; Krm0.

destruct l; destruct y; rewrite conj0, conjk, !IH; Vrm0.

repeat rewrite gprod0l; Vrm0.

Qed.



Lemma gprodkr n l k x : (x [* l] [k]) = k .* x :> vect n.

Proof.

induction n as [| n IH]; simpl; try Vfold n; Krm0.

rewrite multK_com; auto.

destruct l; destruct x; repeat rewrite gprod0r; Vrm0.

repeat rewrite IH; auto.

Qed.



Lemma gprod_spec1 n l i :

   i < n -> 'e_i [* l] 'e_i =  [projk i l] :> vect n.

Proof.

generalize i; clear i.

induction n as [| n IH]; simpl; try Vfold n; Krm0.

intros i HH; contradict HH; auto with arith.

destruct l; intros [|i] HH ; simpl; Vfold n.

rewrite conj0, !conjk, !gprodkr, !gprod0r; Vrm0.

rewrite !scalk; Krm1.

rewrite !gprod0l, !gprod0r; Vrm0.

rewrite !IH; simpl; Krm0; auto with arith.

Qed.



Lemma gprod_spec2 n l i j : i < n -> j < n -> i <> j -> 

  'e_i [* l] 'e_j =  (-(1))%f .* 'e_j [* l] 'e_i :> vect n.

Proof.

generalize i j; clear i j.

induction n as [| n IH]; simpl; try Vfold n; Krm0.

intros i j HH; contradict HH; auto with arith.

destruct l; intros [|i] [|j]; simpl.

intros H1 H2 []; auto.

intros.

rewrite !conjk, !gprod0l, !gprod0r; Vfold n; Vrm0.

rewrite gprodkr, gprodkl, conj_e, <-!scal_multE; Krm1; auto with arith.

intros.

rewrite !conjk, !gprod0l, !gprod0r; Vfold n; Vrm0.

rewrite gprodkr, gprodkl, conj_e; auto with arith.

rewrite <-!scal_multE; Krm1.

intros.

rewrite!gprod0l, !gprod0r; Vfold n; Vrm0.

rewrite IH; auto with arith.

Qed.



Lemma gprod_scall n l k x y : (k .* x) [* l] y = k .* (x [* l] y) :> vect n.

Proof.

induction n as [| n IH]; simpl; try Vfold n; Krm0.

intros; rewrite multK_assoc; auto.

destruct l; destruct x; destruct y; simpl; auto; Vfold n.

rewrite !conj_scal, !scal_addEr, !IH, <-!scal_multE; auto.

rewrite multK_com; auto.

Qed.



Lemma gprod_scalr n l k x y : x [* l] (k .* y) = k .* (x [* l] y) :> vect n.

Proof.

induction n as [| n IH]; simpl; try Vfold n; Krm0.

intros; rewrite multK_swap; auto.

destruct l; destruct x; destruct y; simpl; auto; Vfold n.

rewrite !scal_addEr, !IH; auto.

rewrite <-!scal_multE; auto.

rewrite multK_com; auto.

Qed.



Lemma gprod_addl n l x y z : 

  (x + y) [* l] z = x [* l] z + y [* l] z :> vect n.

Proof.

induction n as [| n IH]; simpl; try Vfold n; Krm0.

intros; rewrite add_multKl; auto.

destruct l; destruct x; destruct y; destruct z; simpl; Vfold n.

rewrite !conj_add, !IH; auto.

apply f_equal2 with (f := @pair _ _).

  rewrite !addE_assoc; auto.

  apply f_equal2 with (f := addE _); auto.

  rewrite addE_swap; auto.

rewrite !addE_assoc; auto.

apply f_equal2 with (f := addE _); auto.

  rewrite addE_swap; auto.

rewrite scal_addEr; auto.

Qed.



Lemma gprod_addr n l x y z :

   x [* l] (y + z) = x [* l] y + x [* l] z :> vect n.

Proof.

induction n as [| n IH]; simpl; try Vfold n; Krm0.

intros; rewrite add_multKr; auto.

destruct l; destruct x; destruct y; destruct z; simpl; Vfold n.

rewrite !IH; auto.

apply f_equal2 with (f := @pair _ _).

  rewrite !addE_assoc; auto.

  apply f_equal2 with (f := addE _); auto.

  rewrite addE_swap; auto.

rewrite !addE_assoc; auto.

apply f_equal2 with (f := addE _); auto.

rewrite addE_swap, scal_addEr; auto.

Qed.



Lemma conjf_gprod n l (x y: vect n) :

   (x [* l] y) ^_'f = (x ^_'f) [* l] (y ^_'f) :> vect n.

Proof.

induction n as [| n IH]; simpl; try Vfold n; Krm0.

destruct l; destruct x; destruct y; simpl; Vfold n.

rewrite !conj_add, !conjt, !conj_invo, !IH; auto.

rewrite !conj_invo, !conj_scal, !conj_invo, !IH; auto.

rewrite !gprod_scall, !gprod_scalr, !conj_invo; auto.

rewrite <-!scal_multE; Krm1.

Qed.



Lemma gprod_assoc n l x y z :

  (x [* l] y) [* l] z = x [* l] (y [* l] z) :> vect n.

Proof.

induction n as [| n IH]; simpl; try Vfold n; Krm0.

intros; rewrite multK_assoc; auto.

destruct l; destruct x; destruct y; destruct z; simpl; Vfold n.

rewrite !gprod_addl, !gprod_addr, !IH, !gprod_scalr; auto.

rewrite !conj_add, !gprod_addl, gprod_scall, !IH, conj_scal; auto.

rewrite !addE_assoc, !gprod_scall, !conjf_gprod, !IH, !conj_invo; auto.

apply f_equal2 with (f := @pair _ _); auto.

  apply f_equal2 with (f := addE _); auto.

  rewrite <-addE_assoc, addE_com; auto.

apply f_equal2 with (f := addE _); auto.

rewrite !scal_addEr, <-addE_assoc, addE_com; auto.

Qed.



Lemma gprod_e0 n l (M : vect n.+1 ) :

    'e_0 [* l] M = (snd M, fst l .* fst M).

Proof.

destruct l; destruct M; simpl; Vfold n.

rewrite conj0, !gprod0l, !conjk, !gprodkl, !scalE1; Vrm0.

Qed.



Lemma gprod_ei n l i (M : vect n.+1) :

  i < n ->

    'e_i.+1 [* l] M =

       ((-(1))%f .* ('e_i [* snd l] (fst M)), 'e_i [* snd l] (snd M)).

Proof.

destruct l; destruct M; intros HH; simpl; Vfold n.

rewrite conj0, !gprod0l; Vrm0.

rewrite conj_e, !gprod_scall; auto.

Qed.



Lemma gprodE_ei n l i M :

  i < n ->

  'e_i [* l] M =  'e_i ∧ M + #<('e_i [*] l)%Kn, M># :> vect n.

Proof.

generalize i; clear i.

induction n as [|n IH]; intros i Hi.

contradict Hi; auto with arith.

destruct l; destruct M; destruct i as [|i].

  rewrite join_e0, gprod_e0; simpl; auto; Vfold n.

  rewrite kprod0l, !contra0l; simpl; Vfold n; Vrm0; Krm1.

rewrite gprod_ei, join_ei, !IH, scal_addEr; auto with arith.

rewrite contraE; simpl; Vfold n; Krm0; Vrm0.

Qed.



Lemma gprodE_v n l x M :

  'v_x [* l] M = 'v_x ∧ M + #< (x [*] l)%Kn, M ># :> vect n.

Proof.

pattern x; apply kn_induct; auto.

rewrite k2g0, gprod0l, join0l, kprod0l, contra0l; Vrm0.

intros i Hi.

rewrite k2g_unit; auto.

apply gprodE_ei; auto.

intros v1 v2 Hv1 Hv2.

rewrite k2g_add, gprod_addl, join_addl, kprod_addl; auto.

rewrite contra_addl; auto.

rewrite Hv1, Hv2.

rewrite !addE_assoc; auto.

apply f_equal2 with (f := addE _); auto.

rewrite <-!addE_assoc; auto.

apply f_equal2 with (f := addE _); auto.

rewrite addE_com; auto.

intros k v Hv.

rewrite k2g_scal, gprod_scall, join_scall, kprod_scall, contra_scall; auto.

rewrite Hv, scal_addEr; auto.

Qed.



Fixpoint rev n : vect n -> vect n :=

  match n return vect n ->  vect n with

  |    0 => fun a => a

  | S n1 => fun v => let (x,y) := v in (rev n1 x ^_'f, rev n1 y)

  end.



Notation "''R[' x ]" := (rev _ x).



Lemma rev0 n : 'R[0] = 0 :> vect n.

Proof.

induction n as [|n IH]; simpl; auto; Vfold n.

rewrite !IH, conj0; auto.

Qed.



Lemma revk n k : 'R[[k]] = [k] :> vect n.

Proof.

induction n as [|n IH]; simpl; auto; Vfold n.

rewrite rev0, !IH, conj0; auto.

Qed.



Lemma rev_scal n k x : 'R[(k .* x)] =  k .* 'R[x] :> vect n.

Proof.

induction n as [|n IH]; simpl; auto; Vfold n.

destruct x; rewrite !IH, conj_scal; auto.

Qed.



Lemma rev_add n x y : 'R[x + y] =  'R[x] + 'R[y] :> vect n.

Proof.

induction n as [|n IH]; simpl; auto; Vfold n.

destruct x; destruct y.

rewrite !IH, conj_add; auto.

Qed.



Lemma rev_conj n x : 'R[x ^_'f] = 'R[x]^_'f :> vect n.

Proof.

induction n as [|n IH]; simpl; auto; Vfold n.

destruct x.

rewrite !conjt, <-!IH, !conj_scal, rev_scal; auto.

Qed.



Lemma rev_invo n x : 'R['R[x]] = x :> vect n.

Proof.

induction n as [|n IH]; simpl; auto; Vfold n.

destruct x; rewrite !rev_conj, !conj_invo, !IH; auto.

Qed.



Lemma rev_hom  n m x : (m <= n)%nat -> hom p n m x -> 

   'R[x] = ((-(1)) ^ (div2 (m * (m - 1))))%f .* x.

Proof.

generalize m; clear m.

induction n as [|n IH]; simpl; auto; try Vfold n.

intros [|m]; simpl; Krm1.

intros HH; contradict HH; auto with arith.

intros [|m]; destruct x.

  case eq0_spec; simpl; auto.

  intros; subst.

  rewrite rev0, hom0E with (2 := H1), revk, conj0; auto.

  rewrite !scalE1; auto.

intros; discriminate.

rewrite andbP.

intros HH [HH1 HH2].

assert (HH' : m <= n); auto with arith.

case (Lt.le_or_lt m.+1 n); intros HH''.

rewrite IH with (2 := HH1); auto with arith.

rewrite IH with (2 := HH2); auto with arith.

rewrite conj_scal, !conjf_hom  with (2 := HH1); auto.

rewrite <-scal_multE, <-expK_add; auto.

rewrite Plus.plus_comm, div2_prop; simpl; auto.

rewrite <-!Minus.minus_n_O; simpl; auto.

rewrite hom_lt with (3 := HH2); auto with arith.

rewrite rev0, IH with (2 := HH1); Vrm0.

rewrite conj_scal, !conjf_hom  with (2 := HH1); auto.

rewrite <-scal_multE, <-expK_add; auto.

rewrite Plus.plus_comm, div2_prop; simpl; auto.

rewrite <-!Minus.minus_n_O; simpl; auto.

Qed.



Lemma rev_join n x y : 'R[x ∧ y] = 'R[y] ∧ 'R[x] :> vect n.

Proof.

induction n as [|n IH]; simpl; auto; try Vfold n.

rewrite multK_com; auto.

destruct x; destruct y.

rewrite rev_add, !IH, !rev_conj; auto.

rewrite !conj_add, !conjf_join, !conj_invo; auto.

rewrite addE_com; auto.

Qed.



Definition pseudo_inv n l :=

  let a := (E : vect n) in let b := 'R[a] in (a [* l] b) [* l] b.



Notation "''Pi[' l ]" := (pseudo_inv _ l).



Fixpoint prodk n : (kn n -> K) :=

  match n return kn n -> K with

         0 => fun _ => 1%f 

  | (S n1) => fun x => let (a, x1) := x in (a * prodk n1 x1)%f

  end.



Notation "''P[' x ]" := (prodk _ x). 



Lemma gprod_all_rev n l : E [* l] 'R[E] = ['P[l]] :> vect n.

Proof.

generalize l; clear l.

induction n as [|n IH]; simpl; auto; try Vfold n.

 intros; rewrite multK1r; auto.

intros [a l].

rewrite rev0, conj0, !gprod0r, !gprod0l, <-!conjf_gprod; Vrm0.

rewrite IH, conjk, scalk; auto.

Qed.



Lemma pseudo_invE n l : 'Pi[l] = 'P[l] .* 'R[E] :> vect n.

Proof.

unfold pseudo_inv; rewrite gprod_all_rev, gprodkl; auto.

Qed.



Definition cdual n l x : vect n := 'P[l] .* (x [* l] 'R[E]).



Fixpoint cliff_starb n b : kn n -> vect n -> vect n :=

  match n return kn n -> vect n ->  vect n with

  |    0 => fun _ a => a

  | S n1 => fun l v => 

                     let b1 := negb b in

                     let (c, l1) := l in 

                     let  (x, y) := v in

       ((if b then c else (-c)%f) .* cliff_starb n1 b1 l1 y,

        (c * c)%f .* cliff_starb n1 b1 l1 x)

  end.



Definition cliff_star n l := cliff_starb n true l.



Lemma cdual_cliff n l x : cdual n l x = cliff_star n l x.

Proof.

generalize l x; pattern n; apply lt_wf_ind; clear l x n.

unfold cdual, cliff_star;  intros [|[|n]] IH.

intros l x; simpl; Krm1.

intros [l1 l2] [x1 x2]; unfold cdual, cliff_star; simpl; Krm1.

rewrite multK_assoc; auto.

intros [a [b l]] [[x1 x2] [x3 x4]].

unfold cdual, cliff_star; simpl; Krm1; Vfold n.

rewrite !rev0, !conj0, !gprod0r; Vrm0.

rewrite !conjt, !conj_scal, !conj_invo; auto.

rewrite !gprod_scalr, !gprod_scall, <-!scal_multE; auto.

rewrite <-multK_assoc; Krm1.

apply f_equal2 with (f := @pair _ _); apply f_equal2 with (f := @pair _ _); auto.

rewrite  opp_multKl, scal_multE, IH; auto.

rewrite multK_assoc, multK_com with (x := prodk n l); auto.

rewrite <-!multK_assoc, scal_multE, IH; auto.

rewrite !multK_assoc; auto.

rewrite multK_com with (x := prodk n l); auto.

rewrite <-!multK_assoc, opp_multKl, scal_multE, IH; auto.

rewrite !multK_assoc; auto.

rewrite multK_com with (x := b); auto.

rewrite !multK_assoc; auto.

rewrite multK_com with (x := prodk n l); auto.

rewrite <-!multK_assoc, scal_multE, IH; auto.

rewrite multK_assoc with (z := a); auto.

rewrite multK_com with (x := b); auto.

rewrite <-!multK_assoc; auto.

Qed.



Fixpoint l_contra (n : nat) : kn n -> vect n -> vect n -> vect n :=

  match n return (kn n -> vect n -> vect n -> vect n) with

  | 0%nat => fun _ x y => (x * y)%f

  | S n1 =>

    fun l x y =>

      let (k, l1) := l in 

      let (x1, x2) := x in

      let (y1, y2) := y in 

     (l_contra n1 l1 (x2^_'f) y1,

      k .*  l_contra n1 l1 (x1^_'f) y1 + l_contra n1 l1 x2 y2)

  end.



Notation "x ''L[' l ]  y " := (l_contra _ l x y) (at level 40).

Notation hom := (hom p _).



Lemma l_contra_addl n l x y z :

   (x + y) 'L[l] z = x 'L[l] z +  y 'L[l] z :> vect n.

Proof.

induction n as [|n IH]; simpl; auto; try Vfold n.

intros; rewrite add_multKl; auto.

destruct l; destruct x; destruct y; destruct z.

rewrite conj_add, conj_add, !IH; auto.

apply f_equal2 with (f := @pair _ _); auto.

rewrite !scal_addEr, !addE_assoc; auto.

apply f_equal2 with (f := addE _); auto.

rewrite <-!addE_assoc; auto.

apply f_equal2 with (f := addE _); auto.

rewrite addE_com; auto.

Qed.



Lemma l_contra_addr n l x y z :

   x 'L[l] (y + z) = x 'L[l] y + x 'L[l] z :> vect n.

Proof.

induction n as [|n IH]; simpl; auto; try Vfold n.

intros; rewrite add_multKr; auto.

destruct l; destruct x; destruct y; destruct z.

rewrite !IH.

apply f_equal2 with (f := @pair _ _); auto.

rewrite !scal_addEr, !addE_assoc; auto.

apply f_equal2 with (f := addE _); auto.

rewrite <-!addE_assoc; auto.

apply f_equal2 with (f := addE _); auto.

rewrite addE_com; auto.

Qed.



Lemma l_contra_scall n l k x y : 

   (k .* x) 'L[l] y = k .* (x 'L[l] y) :> vect n.

Proof.

induction n as [|n IH]; simpl; auto; try Vfold n.

intros; rewrite multK_assoc; auto.

destruct l; destruct x; destruct y.

rewrite !conj_scal, !IH, scal_addEr, <-!scal_multE; auto.

rewrite multK_com; auto.

Qed.



Lemma l_contra_scalr n l k x y :

   x 'L[l] (k .* y) = k .* (x 'L[l] y) :> vect n.

Proof.

induction n as [|n IH]; simpl; auto; try Vfold n.

intros; rewrite multK_swap; auto.

destruct l; destruct x; destruct y.

rewrite !IH, scal_addEr, <-!scal_multE; auto.

rewrite multK_com; auto.

Qed.



Lemma l_contra_0l n l y : 0 'L[l] y = 0 :> vect n.

Proof.

induction n as [|n IH]; simpl; auto; try Vfold n.

intros; rewrite multK0l; auto.

destruct l; destruct y.

rewrite !conj0, !IH; Vrm0.

Qed.



Lemma l_contra_0r n l x : x 'L[l] 0 = 0 :> vect n.

Proof.

induction n as [|n IH]; simpl; auto; try Vfold n.

intros; rewrite multK0r; auto.

destruct l; destruct x.

rewrite !IH; Vrm0.

Qed.



Lemma l_contra_kl n l k y : [k] 'L[l] y =  k .* y :> vect n.

Proof.

induction n as [|n IH]; simpl; auto; try Vfold n.

destruct l; destruct y.

rewrite !conj0, !conjk, !l_contra_0l, !IH; Vrm0.

Qed.



Lemma l_contra_kr n l k x : x 'L[l] [k] =  ['C[x] * k] :> vect n.

Proof.

induction n as [|n IH]; simpl; auto; try Vfold n.

destruct l; destruct x.

rewrite !l_contra_0r, !IH; Vrm0.

Qed.



Lemma l_contra_joinl n l x y z :

  (x ∧ y) 'L[l] z = x 'L[l] (y 'L[l] z) :> vect n.

Proof.

induction n as [|n IH]; simpl; auto; try Vfold n.

intros; rewrite multK_assoc; auto.

destruct l; destruct x; destruct y; destruct z.

rewrite !conj_add, !conjf_join, !l_contra_addl, !l_contra_addr; auto.

rewrite !IH, !scal_addEr, !l_contra_scalr; auto.

rewrite !conj_invo, <-!addE_assoc; auto.

Qed.



Lemma l_contra_ei n l i :

   i < n -> 'e_i 'L[l] 'e_i = [projk i l] :> vect n.

Proof.

generalize i; clear i.

induction n as [|n IH]; simpl; auto; try Vfold n.

intros i HH; contradict HH; auto with arith.

intros [|i] HH; rewrite !conj0; auto.

destruct l.

rewrite !l_contra_0l, !conjk, !l_contra_kl, !scalE1; Vrm0.

rewrite scalk; simpl; intros; Krm1.

destruct l.

rewrite !l_contra_0l, !l_contra_0r, !IH; auto with arith; Vrm0.

Qed.



Lemma l_contra_eij n l i j :

   i < n -> j < n -> i <> j -> 'e_i 'L[l] 'e_j =  0 :> vect n.

Proof.

generalize i j; clear i j.

induction n as [|n IH]; simpl; auto; try Vfold n.

intros i j HH; contradict HH; auto with arith.

intros [|i] [|j]; simpl; auto.

intros H1 H2 []; auto.

intros; destruct l.

rewrite !conj0, !conjk, !l_contra_0l, !l_contra_0r; Vrm0.

intros; destruct l.

rewrite !conj0, !l_contra_0l, !l_contra_0r; Vrm0.

rewrite !l_contra_kr, const_hom with (k := 1); Krm0.

apply conj_hom; auto.

apply hom1e; auto with arith.

intros; destruct l.

rewrite !conj0, !l_contra_0l, !l_contra_0r; Vrm0.

rewrite IH; auto with arith.

Qed.



Lemma l_contra_conj n l x y :

   (x 'L[l] y)^_'f = (x^_'f) 'L[l] (y^_'f) :> vect n.

Proof.

induction n as [|n IH]; simpl; auto; try Vfold n.

destruct l; destruct x; destruct y.

rewrite !conjt, !conj_invo, !conj_scal; auto.

rewrite !l_contra_scalr, !l_contra_scall, !conj_invo; auto.

rewrite !conj_add, !conj_scal, !IH, !conj_invo; auto.

apply f_equal2 with (f := @pair _ _); auto.

apply f_equal2 with (f := addE _); auto.

rewrite <-!scal_multE; Krm1.

Qed.



Lemma dualE n x : '@x = 'R[x] [* [1%f]%Kn] E :> vect n.

induction n as [|n IH]; simpl; try Vfold n.

intros; rewrite multK1r; auto.

destruct x; rewrite !gprod0r; Vrm0.

rewrite !IH, rev_conj, conj_invo, scalE1; Vrm0.

Qed.



Fixpoint prod_scal (n : nat) : kn n -> vect n -> vect n -> K :=

  match n return (kn n -> vect n -> vect n -> K) with

  | 0%nat => fun _ x y => (x * y)%f

  | S n1 =>

    fun l x y =>

      let (k, l1) := l in 

      let (x1, x2) := x in 

      let (y1, y2) := y in

        (prod_scal n1 l1 x2 y2 + k * prod_scal n1 l1 x1 (y1 ^_'f))%f

  end.



Notation "a '[.'  l ]  b " := (prod_scal _ l a b)

  (at level 40).

 

Lemma prod_scal0r n l (x : vect n) : x [.l] 0 = 0%f.

Proof.

induction n as [| n IH]; simpl; try Vfold n; Krm0.

destruct l; destruct x; rewrite conj0, !IH; Krm0.

Qed.



Lemma prod_scal0l n l (x : vect n) : 0 [.l] x = 0%f.

Proof.

induction n as [| n IH]; simpl; try Vfold n; Krm0.

destruct l; destruct x; rewrite !IH; Vrm0.

Qed.



Lemma prod_scal_scall n l k (x y : vect n) : 

  (k .* x) [.l] y = (k * (x [.l] y))%f.

Proof.

induction n as [| n IH]; simpl; try Vfold n; Krm0.

intros; rewrite multK_assoc; auto.

destruct l; destruct x; destruct y; simpl; auto; Vfold n.

rewrite !IH, add_multKr, <-!multK_assoc; auto.

apply f_equal2 with (f := addK _); auto.

apply f_equal2 with (f := multK _); auto.

rewrite multK_com; auto.

Qed.



Lemma prod_scal_scalr n l k (x y : vect n) : 

  x [.l] (k .* y) = (k * (x [.l] y))%f.

Proof.

induction n as [| n IH]; simpl; try Vfold n; Krm0.

intros; rewrite multK_swap; auto.

destruct l; destruct x; destruct y; simpl; auto; Vfold n.

rewrite conj_scal, !IH, add_multKr, <-!multK_assoc; auto.

apply f_equal2 with (f := addK _); auto.

apply f_equal2 with (f := multK _); auto.

rewrite multK_com; auto.

Qed.



Lemma prod_scal_addl n l (x y z : vect n) : 

  (x + y) [.l] z = (x [.l] z + y [.l] z)%f.

Proof.

induction n as [| n IH]; simpl; try Vfold n; Krm0.

intros; rewrite add_multKl; auto.

destruct l; destruct x; destruct y; destruct z; simpl; Vfold n.

rewrite !IH, !addK_assoc; auto.

apply f_equal2 with (f := addK _); auto.

rewrite addK_com, add_multKr, !addK_assoc; auto.

apply f_equal2 with (f := addK _); auto.

rewrite addK_com; auto.

Qed.



Lemma prod_scal_addr n l (x y z : vect n) : 

  x [.l] (y + z) =  (x [.l] y + x [.l] z)%f.

Proof.

induction n as [| n IH]; simpl; try Vfold n; Krm0.

intros; rewrite add_multKr; auto.

destruct l; destruct x; destruct y; destruct z; simpl; Vfold n.

rewrite conj_add, !IH, !addK_assoc; auto.

apply f_equal2 with (f := addK _); auto.

rewrite addK_com, add_multKr, !addK_assoc; auto.

apply f_equal2 with (f := addK _); auto.

rewrite addK_com; auto.

Qed.



Lemma conjf_prod_scal n l (x y: vect n) :

   (x^_'f) [.l] y = x [.l] (y^_'f).

Proof.

induction n as [| n IH]; simpl; try Vfold n; Krm0.

destruct l; destruct x; destruct y; simpl; Vfold n.

rewrite !conjt, !conj_scal, !prod_scal_scall, !prod_scal_scalr, !IH; auto.

Qed.



Lemma prod_scal_sym n l (x y: vect n) :

   x [.l] y = y [.l] x.

Proof.

induction n as [| n IH]; simpl; try Vfold n; Krm0.

intros; rewrite multK_com; auto.

destruct l; destruct x; destruct y; simpl; Vfold n.

rewrite IH.

apply f_equal2 with (f := addK _); auto.

rewrite IH.

rewrite conjf_prod_scal; auto.

Qed.



End Vect.



