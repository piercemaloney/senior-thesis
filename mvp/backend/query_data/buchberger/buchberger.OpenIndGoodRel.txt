
Require Import List.
Require Import Bar.
(* Bar:
Require Import List.

Definition Pred (A : Set) := A -> Prop.

Definition Rel (A : Set) := A -> A -> Prop.

Inductive ExistsL (A : Set) (P : Pred A) : list A -> Set :=
  | FoundE : forall (a : A) (l : list A), P a -> ExistsL A P (a :: l)
  | SearchE :
      forall (a : A) (l : list A), ExistsL A P l -> ExistsL A P (a :: l).
Hint Resolve FoundE SearchE.

Lemma monExistsL1 :
 forall (A : Set) (P : Pred A) (xs bs : list A),
 ExistsL A P bs -> ExistsL A P (xs ++ bs).
Hint Resolve monExistsL1.

Lemma monExistsL :
 forall (A : Set) (P : Pred A) (xs bs cs : list A),
 ExistsL A P (xs ++ bs) -> ExistsL A P (xs ++ cs ++ bs).
Hint Resolve monExistsL.

Inductive GoodR (A : Set) (R : Rel A) : list A -> Set :=
  | FoundG :
      forall (a : A) (l : list A),
      ExistsL A (fun x : A => R x a) l -> GoodR A R (a :: l)
  | SearchG : forall (a : A) (l : list A), GoodR A R l -> GoodR A R (a :: l).
Hint Resolve FoundG SearchG.

Lemma monGoodR1 :
 forall (A : Set) (R : Rel A) (xs bs : list A),
 GoodR A R bs -> GoodR A R (xs ++ bs).
Hint Resolve monGoodR1.

Lemma monGoodR :
 forall (A : Set) (R : Rel A) (xs bs cs : list A),
 GoodR A R (xs ++ bs) -> GoodR A R (xs ++ cs ++ bs).
Hint Resolve monGoodR.

Lemma subPredExistsL :
 forall (A B : Set) (P : Pred A) (S : Pred B) (f : A -> B),
 (forall a : A, P a -> S (f a)) ->
 forall l : list A, ExistsL A P l -> ExistsL B S (map f l).

Lemma subRelGoodR :
 forall (A B : Set) (R : Rel A) (S : Rel B) (f : A -> B),
 (forall a b : A, R a b -> S (f a) (f b)) ->
 forall l : list A, GoodR A R l -> GoodR B S (map f l).

Inductive Bar (A : Set) (P : list A -> Set) : list A -> Set :=
  | Base : forall l : list A, P l -> Bar A P l
  | Ind : forall l : list A, (forall a : A, Bar A P (a :: l)) -> Bar A P l.
Hint Resolve Base Ind.

Definition GRBar (A : Set) (R : Rel A) := Bar A (GoodR A R).

Definition WR (A : Set) (R : Rel A) := GRBar A R nil.
Hint Unfold GRBar WR.

Lemma subRelGRBar :
 forall (A B : Set) (R : Rel A) (S : Rel B) (f : A -> B),
 (forall a b : A, R a b -> S (f a) (f b)) ->
 (forall b : B, {a : A | b = f a}) ->
 forall l : list A, GRBar A R l -> GRBar B S (map f l).

Lemma consGRBar :
 forall (A : Set) (R : Rel A) (l : list A),
 GRBar A R l -> forall a : A, GRBar A R (a :: l).
Hint Resolve consGRBar.

Lemma nilGRBar :
 forall (A : Set) (R : Rel A),
 GRBar A R nil -> forall l : list A, GRBar A R l.

Lemma monGRBarAux :
 forall (A : Set) (R : Rel A) (l : list A),
 GRBar A R l ->
 forall xs bs cs : list A, l = xs ++ cs -> GRBar A R (xs ++ bs ++ cs).

Lemma monGRBar :
 forall (A : Set) (R : Rel A) (xs bs cs : list A),
 GRBar A R (xs ++ cs) -> GRBar A R (xs ++ bs ++ cs).
Hint Resolve monGRBar.
Section lems.
Variable trm : Set.
Variable tdiv : trm -> trm -> Prop.

Definition Bad (M : list trm) := GoodR trm tdiv M -> False.

Lemma tdivExists_trmHd_lem :
 forall (F : list trm) (f : trm),
 (forall g : trm, In g F -> ~ tdiv g f) ->
 ExistsL trm (fun g : trm => tdiv g f) F -> False.

Lemma tdivGoodP :
 forall (F : list trm) (f : trm),
 Bad F -> (forall g : trm, In g F -> ~ tdiv g f) -> Bad (f :: F).
End lems. *)
Section OpenIndGoodRel.
Variable A : Set.
Variable lt R : Rel A.
Variable wflt : well_founded lt.

Inductive Min : list A -> Set :=
  | nmin : Min nil
  | cmin :
      forall (a : A) (l : list A),
      Min l -> (forall y : A, lt y a -> GRBar A R (y :: l)) -> Min (a :: l).
Hint Resolve nmin cmin.

Lemma OpenInd :
 forall xs : list A,
 Min xs ->
 (forall a : A, Min (a :: xs) -> GRBar A R (a :: xs)) -> GRBar A R xs.
intros; red in |- *.
apply Ind; auto.
intros a; elim (wflt a); auto.
intros x H' H'0; red in H0; auto.
Qed.
End OpenIndGoodRel.
