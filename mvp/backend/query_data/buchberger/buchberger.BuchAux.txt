
Require Export Pcomb.
(* Pcomb:
Require Export Pspoly.
Require Export LetP.

Local Unset Injection On Proofs.

Section Pcomb.
Load "hCoefStructure".
Load "hOrderStructure".
Load "hSpoly".
 
Inductive CombLinear (Q : list (poly A0 eqA ltM)) :
list (Term A n) -> Prop :=
  | CombLinear_0 : CombLinear Q (pO A n)
  | CombLinear_1 :
      forall (a : Term A n) (p q s : list (Term A n)),
      ~ zeroP (A:=A) A0 eqA (n:=n) a ->
      inPolySet A A0 eqA n ltM q Q ->
      CombLinear Q p ->
      eqP A eqA n s
        (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec
           (mults (A:=A) multA (n:=n) a q) p) -> CombLinear Q s.
Hint Resolve CombLinear_0 CombLinear_1.
 
Theorem CombLinear_canonical :
 forall (Q : list (poly A0 eqA ltM)) (p : list (Term A n)),
 CombLinear Q p -> canonical A0 eqA ltM p.
 
Theorem CombLinear_comp :
 forall (Q : list (poly A0 eqA ltM)) (p : list (Term A n)),
 CombLinear Q p ->
 forall q : list (Term A n),
 canonical A0 eqA ltM q -> eqP A eqA n p q -> CombLinear Q q.
Hint Resolve CombLinear_canonical.
 
Theorem CombLinear_pluspf :
 forall (Q : list (poly A0 eqA ltM)) (p : list (Term A n)),
 CombLinear Q p ->
 forall q : list (Term A n),
 CombLinear Q q ->
 CombLinear Q
   (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec p q).
Hint Resolve CombLinear_pluspf.
 
Theorem CombLinear_mults1 :
 forall (Q : list (poly A0 eqA ltM)) (a : Term A n) (p : list (Term A n)),
 ~ zeroP (A:=A) A0 eqA (n:=n) a ->
 CombLinear Q p -> CombLinear Q (mults (A:=A) multA (n:=n) a p).
Hint Resolve CombLinear_mults1.
 
Theorem CombLinear_minuspf :
 forall (Q : list (poly A0 eqA ltM)) (p : list (Term A n)),
 CombLinear Q p ->
 forall q : list (Term A n),
 CombLinear Q q ->
 CombLinear Q
   (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q).
Hint Resolve CombLinear_minuspf.
 
Theorem CombLinear_id :
 forall (Q : list (poly A0 eqA ltM)) (p : list (Term A n)),
 inPolySet A A0 eqA n ltM p Q -> CombLinear Q p.
Hint Resolve CombLinear_id.
 
Theorem CombLinear_spoly :
 forall (Q : list (poly A0 eqA ltM)) (p q : list (Term A n))
   (Cp : canonical A0 eqA ltM p) (Cq : canonical A0 eqA ltM q),
 inPolySet A A0 eqA n ltM p Q ->
 inPolySet A A0 eqA n ltM q Q ->
 CombLinear Q
   (spolyf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec p q Cp Cq).
 
Theorem CombLinear_reduce :
 forall (Q : list (poly A0 eqA ltM)) (p q : list (Term A n)),
 reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p q ->
 canonical A0 eqA ltM p -> CombLinear Q q -> CombLinear Q p.
 
Theorem CombLinear_reduceplus :
 forall (Q : list (poly A0 eqA ltM)) (p q : list (Term A n)),
 reduceplus A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p q ->
 canonical A0 eqA ltM p -> CombLinear Q q -> CombLinear Q p.
 
Theorem CombLinear_reducestar :
 forall (Q : list (poly A0 eqA ltM)) (p q : list (Term A n)),
 reducestar A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p q ->
 canonical A0 eqA ltM p -> CombLinear Q q -> CombLinear Q p.
 
Theorem Reducestar_pO_imp_CombLinear :
 forall (Q : list (poly A0 eqA ltM)) (p q : list (Term A n)),
 reducestar A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p q ->
 canonical A0 eqA ltM p -> eqP A eqA n q (pO A n) -> CombLinear Q p.
 
Inductive Grobner (Q : list (poly A0 eqA ltM)) : Prop :=
    Grobner0 :
      (forall p q : list (Term A n),
       CombLinear Q p ->
       reducestar A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q
         p q -> eqP A eqA n q (pO A n)) -> Grobner Q.
 
Theorem Grobner_imp_SpolyQ :
 forall Q : list (poly A0 eqA ltM),
 Grobner Q ->
 SpolyQ A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q.
 
Inductive ConfluentReduce (Q : list (poly A0 eqA ltM)) : Prop :=
    ConfluentReduce0 :
      (forall p : list (Term A n),
       canonical A0 eqA ltM p ->
       ReduStarConfluent A A0 A1 eqA invA minusA multA divA eqA_dec n ltM
         ltM_dec Q p) -> ConfluentReduce Q.
 
Theorem SpolyQ_imp_ConfluentReduce :
 forall Q : list (poly A0 eqA ltM),
 SpolyQ A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q ->
 ConfluentReduce Q.
 
Theorem ConfluentReduce_imp_Grobner :
 forall Q : list (poly A0 eqA ltM), ConfluentReduce Q -> Grobner Q.
 
Theorem CombLinear_incl :
 forall (a : list (Term A n)) (P Q : list (poly A0 eqA ltM)),
 (forall a : list (Term A n),
  inPolySet A A0 eqA n ltM a P -> inPolySet A A0 eqA n ltM a Q) ->
 CombLinear P a -> CombLinear Q a.
 
Remark CombLinear_trans_cons_lem :
 forall (a : list (Term A n)) (R : list (poly A0 eqA ltM)),
 CombLinear R a ->
 forall (b : poly A0 eqA ltM) (Q : list (poly A0 eqA ltM)),
 R = b :: Q -> CombLinear Q (s2p A A0 eqA n ltM b) -> CombLinear Q a.
 
Theorem reduce_cb :
 forall (a b : list (Term A n)) (Q : list (poly A0 eqA ltM)),
 reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q a b ->
 canonical A0 eqA ltM a -> CombLinear Q a -> CombLinear Q b.
 
Theorem reduceplus_cb :
 forall (a b : list (Term A n)) (Q : list (poly A0 eqA ltM)),
 reduceplus A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q a b ->
 canonical A0 eqA ltM a -> CombLinear Q a -> CombLinear Q b.
 
Theorem reducestar_cb :
 forall (a b : list (Term A n)) (Q : list (poly A0 eqA ltM)),
 reducestar A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q a b ->
 canonical A0 eqA ltM a -> CombLinear Q a -> CombLinear Q b.

Theorem reduce_cb1 :
 forall (a : poly A0 eqA ltM) (b : list (Term A n))
   (Q : list (poly A0 eqA ltM)),
 reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q
   (s2p A A0 eqA n ltM a) b -> CombLinear (a :: Q) b.
 
Theorem CombLinear_compo :
 forall (p : list (Term A n)) (L1 : list (poly A0 eqA ltM)),
 CombLinear L1 p ->
 forall L2 : list (poly A0 eqA ltM),
 (forall q : list (Term A n),
  inPolySet A A0 eqA n ltM q L1 -> CombLinear L2 q) -> 
 CombLinear L2 p.
 
Theorem reduceplus_cb1_lem :
 forall (a b : list (Term A n)) (Q : list (poly A0 eqA ltM)),
 reduceplus A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q a b ->
 forall x : poly A0 eqA ltM,
 s2p A A0 eqA n ltM x = a -> CombLinear (x :: Q) b.
 
Theorem reduceplus_cb1 :
 forall (a : poly A0 eqA ltM) (b : list (Term A n))
   (Q : list (poly A0 eqA ltM)),
 reduceplus A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q
   (s2p A A0 eqA n ltM a) b -> CombLinear (a :: Q) b.
 
Theorem reducestar_cb1 :
 forall (a : poly A0 eqA ltM) (b : list (Term A n))
   (Q : list (poly A0 eqA ltM)),
 reducestar A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q
   (s2p A A0 eqA n ltM a) b -> CombLinear (a :: Q) b.
 
Theorem reduce_cb2 :
 forall (a b : poly A0 eqA ltM) (Q : list (poly A0 eqA ltM)),
 reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q
   (s2p A A0 eqA n ltM a) (s2p A A0 eqA n ltM b) ->
 CombLinear (b :: Q) (s2p A A0 eqA n ltM a).
 
Theorem reduceplus_cb2_lem :
 forall (a b : list (Term A n)) (Q : list (poly A0 eqA ltM)),
 reduceplus A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q a b ->
 canonical A0 eqA ltM a ->
 forall x : poly A0 eqA ltM,
 s2p A A0 eqA n ltM x = b -> CombLinear (x :: Q) a.
 
Theorem reduceplus_cb2 :
 forall (a b : poly A0 eqA ltM) (Q : list (poly A0 eqA ltM)),
 reduceplus A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q
   (s2p A A0 eqA n ltM a) (s2p A A0 eqA n ltM b) ->
 CombLinear (b :: Q) (s2p A A0 eqA n ltM a).
 
Theorem reducestar_cb2 :
 forall (a b : poly A0 eqA ltM) (Q : list (poly A0 eqA ltM)),
 reducestar A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q
   (s2p A A0 eqA n ltM a) (s2p A A0 eqA n ltM b) ->
 CombLinear (b :: Q) (s2p A A0 eqA n ltM a).
End Pcomb. *)
Require Export Pcrit.
(* Pcrit:
Require Export Pspoly.
Require Export Pmult.
Section crit.
Load "hCoefStructure".
Load "hOrderStructure".
Load "hSpoly".
Load "hMult".
 
Definition Rminus :
  forall (a : Term A n) (nZa : ~ zeroP (A:=A) A0 eqA (n:=n) a),
  list (Term A n) -> list (Term A n) -> list (Term A n) -> list (Term A n).
 
Theorem minuspf_in :
 forall (p q : list (Term A n)) (a b : Term A n),
 In a p ->
 ltT ltM b a ->
 canonical A0 eqA ltM p ->
 canonical A0 eqA ltM (pX b q) ->
 In a
   (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p (pX b q)).
 
Theorem minus_is_reduce :
 forall (Q : list (poly A0 eqA ltM)) (a : Term A n)
   (nZa : ~ zeroP (A:=A) A0 eqA (n:=n) a) (q : list (Term A n)),
 inPolySet A A0 eqA n ltM (pX a q) Q ->
 forall u : Term A n,
 divP A A0 eqA multA divA n u a ->
 forall p : list (Term A n),
 canonical A0 eqA ltM p ->
 In u p ->
 reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p
   (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p
      (mults (A:=A) multA (n:=n)
         (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) u (b:=a) nZa)
         (pX a q))).
 
Definition divPp : Term A n -> list (Term A n) -> Prop.
Hint Resolve divP_inv3.
Hint Resolve divP_inv3.
 
Definition divpf :
  forall (a : Term A n) (nZa : ~ zeroP (A:=A) A0 eqA (n:=n) a),
  list (Term A n) -> list (Term A n).
 
Theorem divpf_canonical :
 forall (a : Term A n) (p : list (Term A n))
   (nZa : ~ zeroP (A:=A) A0 eqA (n:=n) a),
 canonical A0 eqA ltM p -> canonical A0 eqA ltM (divpf a nZa p).
Hint Resolve divpf_canonical.
 
Theorem divPp_divpf :
 forall (a : Term A n) (nZa : ~ zeroP (A:=A) A0 eqA (n:=n) a)
   (p : list (Term A n)),
 canonical A0 eqA ltM p ->
 divPp a p -> eqP A eqA n p (mults (A:=A) multA (n:=n) a (divpf a nZa p)).
 
Theorem canonical_Rminus :
 forall (r p q : list (Term A n)) (a : Term A n)
   (nZa : ~ zeroP (A:=A) A0 eqA (n:=n) a),
 canonical A0 eqA ltM p ->
 canonical A0 eqA ltM q ->
 canonical A0 eqA ltM r -> canonical A0 eqA ltM (Rminus a nZa p q r).
Hint Resolve canonical_Rminus.
 
Theorem Rminus_in :
 forall (r p q : list (Term A n)) (a b : Term A n)
   (nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b),
 divPp b r ->
 In a p ->
 canonical A0 eqA ltM p ->
 canonical A0 eqA ltM (pX b q) ->
 canonical A0 eqA ltM (pX a r) -> In a (Rminus b nZb p (pX b q) r).
 
Theorem Rminus_is_reduceplus :
 forall (Q : list (poly A0 eqA ltM)) (a : Term A n) 
   (q : list (Term A n)) (nZa : ~ zeroP (A:=A) A0 eqA (n:=n) a),
 canonical A0 eqA ltM q ->
 inPolySet A A0 eqA n ltM (pX a q) Q ->
 forall r : list (Term A n),
 canonical A0 eqA ltM r ->
 divPp a r ->
 forall p : list (Term A n),
 canonical A0 eqA ltM p ->
 incl r p ->
 reduceplus A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p
   (Rminus a nZa p (pX a q) r).
 
Definition Dmult :
  forall (a : Term A n) (nZa : ~ zeroP (A:=A) A0 eqA (n:=n) a),
  list (Term A n) -> list (Term A n) -> list (Term A n).
 
Theorem canonical_Dmult :
 forall (a : Term A n) (nZa : ~ zeroP (A:=A) A0 eqA (n:=n) a)
   (p q : list (Term A n)),
 canonical A0 eqA ltM p ->
 canonical A0 eqA ltM q -> canonical A0 eqA ltM (Dmult a nZa p q).
Hint Resolve canonical_Dmult.
 
Theorem divp_is_multTerm :
 forall (a b : Term A n) (nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b),
 divP A A0 eqA multA divA n a b ->
 forall p : list (Term A n),
 canonical A0 eqA ltM p ->
 eqP A eqA n
   (mults (A:=A) multA (n:=n)
      (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) a (b:=b) nZb) p)
   (divpf b nZb (mults (A:=A) multA (n:=n) a p)).
 
Theorem Rminus_is_mult :
 forall (r p q : list (Term A n)) (a : Term A n)
   (nZa : ~ zeroP (A:=A) A0 eqA (n:=n) a),
 canonical A0 eqA ltM p ->
 canonical A0 eqA ltM q ->
 canonical A0 eqA ltM r ->
 divPp a r ->
 eqP A eqA n (Rminus a nZa p q r)
   (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p
      (Dmult a nZa r q)).
 
Theorem divpf_comp :
 forall (a b : Term A n) (p q : list (Term A n)),
 eqP A eqA n p q ->
 canonical A0 eqA ltM p ->
 canonical A0 eqA ltM q ->
 eqTerm (A:=A) eqA (n:=n) a b ->
 forall (nZa : ~ zeroP (A:=A) A0 eqA (n:=n) a)
   (nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b),
 eqP A eqA n (divpf a nZa p) (divpf b nZb q).
 
Theorem Dmult_is_mulpf :
 forall (a : Term A n) (nZa : ~ zeroP (A:=A) A0 eqA (n:=n) a)
   (p q : list (Term A n)),
 canonical A0 eqA ltM p ->
 canonical A0 eqA ltM q ->
 eqP A eqA n (Dmult a nZa (mults (A:=A) multA (n:=n) a p) q)
   (multpf A A0 eqA plusA multA eqA_dec n ltM ltM_dec p q).
 
Theorem sp_Rminus :
 forall (a b : Term A n) (nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b)
   (p q : list (Term A n)),
 canonical A0 eqA ltM (pX a p) ->
 canonical A0 eqA ltM (pX b q) ->
 eqP A eqA n
   (Rminus b nZb
      (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec
         (mults (A:=A) multA (n:=n) b p) (mults (A:=A) multA (n:=n) a q))
      (pX b q) (mults (A:=A) multA (n:=n) b p))
   (mults (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n))
      (multpf A A0 eqA plusA multA eqA_dec n ltM ltM_dec (pX a p) q)).
 
Theorem minuspf_spoly_in :
 forall (a b : Term A n) (nZa : ~ zeroP (A:=A) A0 eqA (n:=n) a)
   (nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b),
 eqT (ppc (A:=A) A1 (n:=n) a b) (multTerm (A:=A) multA (n:=n) a b) ->
 forall p q : list (Term A n),
 canonical A0 eqA ltM p ->
 canonical A0 eqA ltM q ->
 (forall c : Term A n,
  In c p ->
  ltT ltM c (multTerm (A:=A) multA (n:=n) a b) /\
  eqT c
    (multTerm (A:=A) multA (n:=n)
       (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) c (b:=b) nZb) b)) ->
 (forall c : Term A n,
  In c q ->
  ltT ltM c (multTerm (A:=A) multA (n:=n) a b) /\
  eqT c
    (multTerm (A:=A) multA (n:=n)
       (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) c (b:=a) nZa) a)) ->
 forall c : Term A n,
 In c p ->
 In c (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q).
 
Theorem multTerm_or_z_d1 :
 forall (a b : Term A n) (nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b)
   (p : list (Term A n)),
 canonical A0 eqA ltM (pX a p) ->
 forall c : Term A n,
 In c (mults (A:=A) multA (n:=n) b p) ->
 ltT ltM c (multTerm (A:=A) multA (n:=n) a b) /\
 eqT c
   (multTerm (A:=A) multA (n:=n)
      (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) c (b:=b) nZb) b).
 
Theorem multTerm_or_z_d2 :
 forall (a b : Term A n) (nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b)
   (p : list (Term A n)),
 canonical A0 eqA ltM (pX a p) ->
 forall c : Term A n,
 In c (mults (A:=A) multA (n:=n) b p) ->
 ltT ltM c (multTerm (A:=A) multA (n:=n) b a) /\
 eqT c
   (multTerm (A:=A) multA (n:=n)
      (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) c (b:=b) nZb) b).
 
Theorem in_minuspf_spoly_in :
 forall a b : Term A n,
 eqT (ppc (A:=A) A1 (n:=n) a b) (multTerm (A:=A) multA (n:=n) a b) ->
 forall p q : list (Term A n),
 canonical A0 eqA ltM (pX a p) ->
 canonical A0 eqA ltM (pX b q) ->
 forall c : Term A n,
 In c (mults (A:=A) multA (n:=n) b p) ->
 In c
   (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec
      (mults (A:=A) multA (n:=n) b p) (mults (A:=A) multA (n:=n) a q)).
 
Theorem divPp_mults1 :
 forall a : Term A n,
 ~ zeroP (A:=A) A0 eqA (n:=n) a ->
 forall p : list (Term A n),
 (forall b : Term A n, In b p -> ~ zeroP (A:=A) A0 eqA (n:=n) b) ->
 divPp a (mults (A:=A) multA (n:=n) a p).
 
Theorem spoly_Reduce :
 forall (Q : list (poly A0 eqA ltM)) (a b : Term A n),
 eqT (ppc (A:=A) A1 (n:=n) a b) (multTerm (A:=A) multA (n:=n) a b) ->
 forall p q : list (Term A n),
 inPolySet A A0 eqA n ltM (pX b q) Q ->
 canonical A0 eqA ltM (pX a p) ->
 reduceplus A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q
   (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec
      (mults (A:=A) multA (n:=n) b p) (mults (A:=A) multA (n:=n) a q))
   (mults (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n))
      (multpf A A0 eqA plusA multA eqA_dec n ltM ltM_dec (pX a p) q)).
 
Theorem spoly_reduceplus_pO :
 forall (Q : list (poly A0 eqA ltM)) (p q : list (Term A n)),
 inPolySet A A0 eqA n ltM q Q ->
 canonical A0 eqA ltM p ->
 reduceplus A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q
   (multpf A A0 eqA plusA multA eqA_dec n ltM ltM_dec p q) 
   (pO A n).
 
Theorem fspoly_Reduceplus_pO :
 forall (Q : list (poly A0 eqA ltM)) (a b : Term A n),
 eqT (ppc (A:=A) A1 (n:=n) a b) (multTerm (A:=A) multA (n:=n) a b) ->
 forall p q : list (Term A n),
 inPolySet A A0 eqA n ltM (pX b q) Q ->
 inPolySet A A0 eqA n ltM (pX a p) Q ->
 reduceplus A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q
   (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec
      (mults (A:=A) multA (n:=n) b p) (mults (A:=A) multA (n:=n) a q))
   (pO A n).
 
Theorem spoly_Reducestar_pO :
 forall (Q : list (poly A0 eqA ltM)) (a b : Term A n),
 eqT (ppc (A:=A) A1 (n:=n) a b) (multTerm (A:=A) multA (n:=n) a b) ->
 forall (p q : list (Term A n)) (Cpxb : canonical A0 eqA ltM (pX b q))
   (Cpxa : canonical A0 eqA ltM (pX a p)),
 inPolySet A A0 eqA n ltM (pX b q) Q ->
 inPolySet A A0 eqA n ltM (pX a p) Q ->
 reduceplus A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q
   (spolyf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec 
      (pX a p) (pX b q) Cpxa Cpxb) (pO A n).
 
Theorem spoly_Reducestar_ppc :
 forall (Q : list (poly A0 eqA ltM)) (a b : Term A n),
 eqT (ppc (A:=A) A1 (n:=n) a b) (multTerm (A:=A) multA (n:=n) a b) ->
 forall (p q : list (Term A n)) (Cpxb : canonical A0 eqA ltM (pX b q))
   (Cpxa : canonical A0 eqA ltM (pX a p)),
 inPolySet A A0 eqA n ltM (pX b q) Q ->
 inPolySet A A0 eqA n ltM (pX a p) Q ->
 reducestar A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q
   (spolyf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec 
      (pX a p) (pX b q) Cpxa Cpxb) (pO A n).
End crit. *)
Require Export Fred.
(* Fred:
Section Reduce.
Variable poly : Set.
Require Import List.
Variable cb : list poly -> poly -> Prop.
Variable divp : poly -> poly -> Prop.
Variable reduce : list poly -> poly -> poly -> Prop.
Variable nf : list poly -> poly -> poly.
Variable stable : list poly -> list poly -> Prop.
Variable grobner : list poly -> Prop.
Variable zero : poly.
Variable zerop : poly -> Prop.
Variable zerop_dec : forall p : poly, {zerop p} + {~ zerop p}.
Require Import LetP.
Hypothesis cb_id : forall (L : list poly) (p : poly), In p L -> cb L p.
Hypothesis cb_zerop : forall (L : list poly) (p : poly), zerop p -> cb L p.
Hypothesis
  cb_incl :
    forall (L1 L2 : list poly) (p : poly), incl L1 L2 -> cb L1 p -> cb L2 p.
Hypothesis nf_cb : forall (p : poly) (L : list poly), cb (p :: L) (nf L p).
Hypothesis
  cb_trans :
    forall (L : list poly) (p q : poly), cb (p :: L) q -> cb L p -> cb L q.
Hypothesis
  cb_comp :
    forall L1 L2 : list poly,
    (forall p : poly, In p L1 -> cb L2 p) ->
    forall q : poly, cb L1 q -> cb L2 q.
Hypothesis cb_nf : forall (p : poly) (L : list poly), cb (nf L p :: L) p.
Hypothesis
  cb_compo :
    forall (p : poly) (L1 : list poly),
    cb L1 p ->
    forall L2 : list poly, (forall q : poly, In q L1 -> cb L2 q) -> cb L2 p.
Hypothesis
  zerop_elim_cb :
    forall (L : list poly) (p q : poly), zerop p -> cb (p :: L) q -> cb L q.
Hypothesis
  grobner_def :
    forall L : list poly,
    grobner L ->
    forall p : poly, cb L p -> zerop p \/ (exists q : poly, reduce L p q).
Hypothesis
  def_grobner :
    forall L : list poly,
    (forall p : poly, cb L p -> zerop p \/ (exists q : poly, reduce L p q)) ->
    grobner L.
Hypothesis
  nf_div :
    forall (p : poly) (L : list poly),
    ~ zerop p ->
    ~ zerop (nf L p) ->
    exists q : poly, In q (nf L p :: L) /\ divp p q /\ ~ zerop q.
Hypothesis
  div_reduce :
    forall (p : poly) (L1 L2 : list poly),
    (forall r1 : poly,
     In r1 L1 -> ~ zerop r1 -> exists r2 : poly, In r2 L2 /\ divp r1 r2) ->
    forall q : poly, reduce L1 p q -> exists r : poly, reduce L2 p r.
Hypothesis divp_id : forall p : poly, divp p p.
Require Import Relation_Definitions.
Hypothesis divp_trans : transitive poly divp.
Hypothesis
  nf_div_zero :
    forall (p : poly) (L : list poly),
    ~ zerop p ->
    zerop (nf L p) -> exists q : poly, In q L /\ divp p q /\ ~ zerop q.

Theorem zerop_nf_cb :
 forall (L : list poly) (p : poly), zerop (nf L p) -> cb L p.
Hint Resolve zerop_nf_cb.

Definition redacc : list poly -> list poly -> list poly.
intros H'; elim H'.
intros L; exact (nil (A:=poly)).
intros a p Rec Acc.
apply LetP with (A := poly) (h := nf (p ++ Acc) a).

Definition red (L : list poly) : list poly := redacc L nil.
Hint Resolve incl_refl incl_tl incl_appr incl_appl incl_cons incl_app
  in_or_app.

Theorem redacc_cb :
 forall (L1 L2 : list poly) (p : poly),
 In p (redacc L1 L2) -> cb (L1 ++ L2) p.
intros L1; elim L1; auto.
simpl in |- *; auto.
simpl in |- *; unfold LetP in |- *; intros a l H' L2 p.

Theorem red_cb : forall (L : list poly) (p : poly), In p (red L) -> cb L p.

Theorem cb_redacc :
 forall (L1 L2 : list poly) (p : poly), In p L1 -> cb (redacc L1 L2 ++ L2) p.
intros L1; elim L1; simpl in |- *; auto.
intros L2 p H'; elim H'; auto.
unfold LetP in |- *.

Theorem cb_red : forall (L : list poly) (p : poly), In p L -> cb (red L) p.

Theorem cb_red_cb1 :
 forall (p : poly) (L : list poly), cb L p -> cb (red L) p.

Theorem cb_red_cb2 :
 forall (p : poly) (L : list poly), cb (red L) p -> cb L p.
Hypothesis
  nf_div_zero1 :
    forall (p : poly) (L : list poly),
    ~ zerop p ->
    zerop (nf L p) -> ex (fun q : poly => In q L /\ divp p q /\ ~ zerop q).

Theorem redacc_divp :
 forall (L1 L2 : list poly) (p : poly),
 ~ zerop p ->
 In p (L1 ++ L2) ->
 exists q : poly, In q (redacc L1 L2 ++ L2) /\ divp p q /\ ~ zerop q.
intros L1; elim L1; simpl in |- *; auto.
intros L2 p H' H'0; exists p; split; auto.
unfold LetP in |- *.

Theorem red_divp :
 forall (L : list poly) (p : poly),
 In p L ->
 ~ zerop p -> exists q : poly, In q (red L) /\ divp p q /\ ~ zerop q.

Theorem red_grobner : forall L : list poly, grobner L -> grobner (red L).
End Reduce. *)
Require Import moreCoefStructure.
(* moreCoefStructure:
Require Export CoefStructure.
Section mCoef.
Load "hCoefStructure".
Load "mCoefStructure".
 
Let eqA_trans := eqA_trans _ _ _ _ _ _ _ _ _ cs.
 
Let eqA_sym := eqA_sym _ _ _ _ _ _ _ _ _ cs.
 
Theorem eqA_A0 : forall a b : A, eqA a A0 -> eqA a b -> eqA b A0.
 
Theorem plusA_eqA_comp_l :
 forall a b c : A, eqA a b -> eqA (plusA a c) (plusA b c).
 
Theorem plusA_eqA_comp_r :
 forall a b c : A, eqA a b -> eqA (plusA c a) (plusA c b).
 
Theorem eqA0_left : forall a b : A, eqA a A0 -> eqA b (plusA a b).
 
Theorem eqA0_right : forall a b : A, eqA b A0 -> eqA a (plusA a b).
 
Theorem invA0 : eqA A0 (invA A0).
 
Theorem invA0_comp : forall a : A, eqA a A0 -> eqA a (invA a).
 
Theorem invA0_inv : forall a : A, eqA a (invA (invA a)).
 
Theorem multA_eqA_comp_l :
 forall a b c : A, eqA a b -> eqA (multA a c) (multA b c).
 
Theorem multA_eqA_comp_r :
 forall a b c : A, eqA a b -> eqA (multA c a) (multA c b).
 
Theorem multA_dist_r :
 forall a b c : A, eqA (plusA (multA a c) (multA b c)) (multA (plusA a b) c).
 
Theorem multA_A0_r : forall a : A, eqA (multA a A0) A0.
 
Theorem multA_A1_r : forall a : A, eqA (multA a A1) a.
Hint Resolve multA_A1_r.
 
Theorem multA_invA_com_l :
 forall a b : A, eqA (multA (invA a) b) (invA (multA a b)).
Hint Resolve multA_invA_com_l.
 
Theorem multA_invA_com_r :
 forall a b : A, eqA (multA a (invA b)) (invA (multA a b)).
Hint Resolve multA_invA_com_r.
 
Theorem divA_multA_comp_l :
 forall (a b c : A) (nZc : ~ eqA c A0),
 eqA (divA (multA a b) c nZc) (multA a (divA b c nZc)).
Hint Resolve divA_multA_comp_l.
 
Theorem invA_is_invA1 : forall a : A, eqA (invA a) (multA (invA A1) a).
 
Theorem divA_A0_l : forall (a : A) (nZa : ~ eqA a A0), eqA (divA A0 a nZa) A0.
Hint Resolve divA_A0_l.
 
Theorem A_sep : forall a b : A, eqA (multA a b) A0 -> eqA a A0 \/ eqA b A0.
Hint Resolve A_sep.
 
Theorem divA_A1 : forall (a : A) (nZa : ~ eqA a A0), eqA (divA a a nZa) A1.
Hint Resolve divA_A1.
 
Theorem divA_nZ :
 forall a b : A,
 ~ eqA b A0 -> forall nZa : ~ eqA a A0, ~ eqA (divA b a nZa) A0.
Hint Resolve divA_nZ.
End mCoef. *)
Section BuchAux.
Load "hCoefStructure".
Load "hOrderStructure".
Load "hComb".
 
Definition red (a : poly A0 eqA ltM) (P : list (poly A0 eqA ltM)) :=
  reducestar A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec P
    (s2p A A0 eqA n ltM a) (pO A n).
 
Definition addEnd :
  poly A0 eqA ltM -> list (poly A0 eqA ltM) -> list (poly A0 eqA ltM).
intros a H'0; elim H'0.
exact (a :: nil).
intros b L1 Rec; exact (b :: Rec).
Defined.
 
Theorem addEnd_cons :
 forall (a b : poly A0 eqA ltM) (aL : list (poly A0 eqA ltM)),
 In a (addEnd b aL) -> a = b \/ In a aL.
intros a b aL; elim aL; simpl in |- *; auto.
intros H'; case H'; [ intros H'0; rewrite <- H'0 | intros H'0; clear H' ];
 auto.
intros a0 l H' H'0; case H'0;
 [ intros H'1; rewrite <- H'1; clear H'0 | intros H'1; clear H'0 ]; 
 auto.
case (H' H'1); auto.
Qed.
 
Theorem addEnd_id1 :
 forall (a : poly A0 eqA ltM) (aL : list (poly A0 eqA ltM)),
 In a (addEnd a aL).
intros a aL; elim aL; simpl in |- *; auto.
Qed.
 
Theorem addEnd_id2 :
 forall (a b : poly A0 eqA ltM) (aL : list (poly A0 eqA ltM)),
 In a aL -> In a (addEnd b aL).
intros a b aL; elim aL; simpl in |- *; auto.
intros a0 l H' H'0; case H'0; auto.
Qed.
 
Lemma addEnd_app :
 forall (a : poly A0 eqA ltM) (P : list (poly A0 eqA ltM)),
 addEnd a P = P ++ a :: nil.
intros a P; elim P; simpl in |- *; auto.
intros a0 l H'; elim H'; auto.
Qed.
 
Definition spolyp : poly A0 eqA ltM -> poly A0 eqA ltM -> poly A0 eqA ltM.
intros p q; case p; case q.
intros x Cpx x0 Cpx0;
 exists
  (spolyf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec x x0 Cpx
     Cpx0); auto.
apply spolyf_canonical with (1 := cs); auto.
Defined.
 
Theorem red_com :
 forall (a b : poly A0 eqA ltM) (aL : list (poly A0 eqA ltM)),
 red (spolyp a b) aL -> red (spolyp b a) aL.
intros a b; case a; case b; simpl in |- *.
unfold red in |- *; simpl in |- *.
intros x Cx x0 Cx0 aL H'1; inversion H'1.
cut
 (canonical A0 eqA ltM
    (spolyf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec x x0 Cx
       Cx0)); [ intros Op1 | apply spolyf_canonical with (1 := cs) ]; 
 auto.
cut
 (canonical A0 eqA ltM
    (spolyf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec x0 x Cx0
       Cx)); [ intros Op2 | apply spolyf_canonical with (1 := cs) ]; 
 auto.
apply reducestar0; auto.
apply
 reduceplus_eqp_com
  with
    (1 := cs)
    (p := mults (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n))
            (spolyf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec
               x x0 Cx Cx0))
    (q := mults (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n))
            (pO A n)); auto.
apply reduceplus_mults with (1 := cs); auto.
inversion H; auto.
apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); auto.
apply spolyf_com with (1 := cs); auto.
apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); auto.
apply spolyf_com with (1 := cs); auto.
Qed.
 
Theorem rstar_rtopO :
 forall (Q : list (poly A0 eqA ltM)) (p : list (Term A n)),
 canonical A0 eqA ltM p ->
 reduceplus A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p
   (pO A n) ->
 reducestar A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p
   (pO A n).
intros Q p H' H'0.
elim
 reduce0_reducestar
  with
    (1 := cs)
    (eqA_dec := eqA_dec)
    (ltM_dec := ltM_dec)
    (Q := Q)
    (p := pO A n); auto.
intros t E; apply reducestar0; auto.
apply pO_irreducible; auto.
Qed.
 
Definition spO : poly A0 eqA ltM.
exists (pO A n); simpl in |- *; auto.
Defined.
 
Definition sp1 : poly A0 eqA ltM.
exists (pX (A1, M1 n) nil); auto.
Defined.
 
Definition sgen : nat -> poly A0 eqA ltM.
intros m; exists (pX (A1, gen_mon n m) (pO A n)).
apply canonicalp1; auto.
Defined.
 
Definition sscal : A -> poly A0 eqA ltM -> poly A0 eqA ltM.
intros a p; case p.
intros x H'1; exists (tmults A0 multA eqA_dec (a, M1 n) x); auto.
unfold tmults in |- *; case (zeroP_dec A A0 eqA eqA_dec n (a, M1 n));
 simpl in |- *; auto.
Qed.
 
Theorem red_cons :
 forall (a : poly A0 eqA ltM) (p : list (poly A0 eqA ltM)), In a p -> red a p.
intros a; case (seqp_dec A A0 eqA eqA_dec n ltM a spO).
case a; unfold red, spO, seqP in |- *; simpl in |- *.
intros x c H' p H'0; inversion H'; auto.
apply reducestar_pO_is_pO with (p := x); auto.
case a; unfold red, spO, seqP in |- *; simpl in |- *.
intros x c H' p H'0.
apply rstar_rtopO; auto.
apply Rstar_n with (y := pO A n); auto.
apply reduce_in_pO with (1 := cs); auto.
change
  (inPolySet A A0 eqA n ltM
     (s2p A A0 eqA n ltM
        (exist (fun l : list (Term A n) => canonical A0 eqA ltM l) x c)) p)
 in |- *; apply In_inp_inPolySet; auto.
red in |- *; intros H'2; apply H'; apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n);
 auto.
apply Rstar_0; auto.
Qed.
 
Theorem red_id :
 forall (a : poly A0 eqA ltM) (aL : list (poly A0 eqA ltM)),
 red (spolyp a a) aL.
intros a P; case a.
unfold red in |- *; simpl in |- *; auto.
intros x H'.
apply rstar_rtopO; auto.
apply spolyf_canonical with (1 := cs); auto.
apply Rstar_0; auto.
apply spolyf_pO with (1 := cs); auto.
Qed.
 
Theorem inP_reduce :
 forall P Q : list (poly A0 eqA ltM),
 (forall a : list (Term A n),
  inPolySet A A0 eqA n ltM a Q -> inPolySet A A0 eqA n ltM a P) ->
 forall a b : list (Term A n),
 reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q a b ->
 reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec P a b.
intros P Q H' a b H'0; elim H'0; auto.
intros a0 b0 nZb p q r H'1 H'2 H'3; auto.
apply reducetop with (b := b0) (nZb := nZb) (q := q); auto.
Qed.
 
Theorem inP_reduceplus :
 forall P Q : list (poly A0 eqA ltM),
 (forall a : list (Term A n),
  inPolySet A A0 eqA n ltM a Q -> inPolySet A A0 eqA n ltM a P) ->
 forall a b : list (Term A n),
 reduceplus A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q a b ->
 reduceplus A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec P a b.
intros P Q H' a b H'0; elim H'0; auto.
intros; apply Rstar_0; auto.
intros x y z H'1 H'2 H'3.
apply Rstar_n with (y := y); auto.
apply inP_reduce with (Q := Q); auto.
Qed.
 
Theorem inP_reducestar :
 forall P Q : list (poly A0 eqA ltM),
 (forall a : list (Term A n),
  inPolySet A A0 eqA n ltM a Q -> inPolySet A A0 eqA n ltM a P) ->
 forall a b : list (Term A n),
 reducestar A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q a b ->
 reduceplus A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec P a b.
intros P Q H' a b H'0; inversion H'0; auto.
apply inP_reduceplus with (Q := Q); auto.
Qed.
 
Theorem red_incl :
 forall (a : poly A0 eqA ltM) (p q : list (poly A0 eqA ltM)),
 incl p q -> red a p -> red a q.
unfold red in |- *.
intros a p q H' H'0.
inversion H'0.
apply rstar_rtopO; auto.
case a; auto.
apply inP_reducestar with (Q := p); auto.
intros a0 H'1.
apply Incl_inp_inPolySet with (P := p); auto.
Qed.
 
Definition zerop : poly A0 eqA ltM -> Prop.
intros H'; case H'.
intros x; case x.
intros H'0; exact True.
intros a l H'0; exact False.
Defined.
 
Theorem zerop_dec : forall a : poly A0 eqA ltM, {zerop a} + {~ zerop a}.
intros H'; case H'.
intros x; case x.
intros c; left; simpl in |- *; auto.
intros a l c; right; red in |- *; intros H'0; inversion H'0.
Qed.
 
Definition divp : poly A0 eqA ltM -> poly A0 eqA ltM -> Prop.
intros H'; case H'.
intros x; case x.
intros H'0 H'1; exact False.
intros a l H'0 H'1; case H'1.
intros x0; case x0.
intros H'2; exact False.
intros a0 l0 H'2.
exact (divP A A0 eqA multA divA n a a0).
Defined.
 
Theorem divp_trans : transitive (poly A0 eqA ltM) divp.
red in |- *.
intros x y z; case x; case y; case z.
intros x0 c x1 c0 x2 c1; generalize c c0 c1; case x0; case x1; case x2;
 simpl in |- *; auto.
intros a l a0 l0 H' H'0 H'1 H'2; elim H'2.
intros a l a0 l0 a1 l1 H' H'0 H'1 H'2 H'3.
apply (divP_trans _ _ _ _ _ _ _ _ _ cs n) with (y := a0); auto.
Qed.
 
Theorem divp_dec : forall a b : poly A0 eqA ltM, {divp a b} + {~ divp a b}.
intros a b; case a; case b.
intros x c x0 c0; generalize c c0; case x; case x0; simpl in |- *.
intros H' H'0; right; red in |- *; intros H'1; elim H'1.
intros a0 l H' H'0; right; red in |- *; intros H'1; elim H'1.
intros a0 l H' H'0; right; red in |- *; intros H'1; elim H'1.
intros a0 l a1 l0 H' H'0.
apply divP_dec with (1 := cs); auto.
apply canonical_nzeroP with (ltM := ltM) (p := l); auto.
apply canonical_nzeroP with (ltM := ltM) (p := l0); auto.
Qed.
 
Definition ppcp : poly A0 eqA ltM -> poly A0 eqA ltM -> poly A0 eqA ltM.
intros H'; case H'.
intros x; case x.
intros H'0 H'1; exists (pO A n); auto.
intros a l H'0 H'1; case H'1.
intros x0; case x0.
intros H'2; exists (pO A n); auto.
intros a0 l0 H'2; exists (ppc (A:=A) A1 (n:=n) a a0 :: pO A n).
change (canonical A0 eqA ltM (pX (ppc (A:=A) A1 (n:=n) a a0) (pO A n)))
 in |- *; apply canonicalp1; auto.
apply ppc_nZ with (1 := cs); auto.
apply canonical_nzeroP with (ltM := ltM) (p := l); auto.
apply canonical_nzeroP with (ltM := ltM) (p := l0); auto.
Defined.
 
Theorem divp_ppc :
 forall a b c : poly A0 eqA ltM, divp (ppcp a b) c -> divp (ppcp b a) c.
intros a b c; (case a; case b; case c).
intros x c0 x0 c1 x1 c2; generalize c0 c1 c2; case x; case x0; case x1;
 simpl in |- *; auto.
intros a0 l a1 l0 a2 l1 H' H'0 H'1 H'2.
apply divP_eqTerm_comp with (1 := cs) (a := ppc (A:=A) A1 (n:=n) a0 a1); auto.
Qed.
 
Theorem zerop_ddivp_ppc :
 forall a b : poly A0 eqA ltM, ~ zerop a -> ~ zerop b -> divp (ppcp a b) b.
intros a b; (case a; case b).
intros x c0 x0 c1; generalize c0 c1; case x; case x0; simpl in |- *; auto.
intros a0 l a1 l0 H' H'0 H'1 H'2.
apply divP_ppcr with (1 := cs); auto.
apply canonical_nzeroP with (ltM := ltM) (p := l); auto.
apply canonical_nzeroP with (ltM := ltM) (p := l0); auto.
Qed.
 
Theorem divp_nzeropl : forall a b : poly A0 eqA ltM, divp a b -> ~ zerop a.
intros a b; (case a; case b).
intros x c0 x0 c1; generalize c0 c1; case x; case x0; simpl in |- *; auto.
Qed.
 
Theorem divp_nzeropr : forall a b : poly A0 eqA ltM, divp a b -> ~ zerop b.
intros a b; (case a; case b).
intros x c0 x0 c1; generalize c0 c1; case x; case x0; simpl in |- *; auto.
Qed.
Hint Resolve pO_irreducible.
 
Theorem reducetopO_pO :
 forall Q : list (poly A0 eqA ltM),
 reducestar A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q
   (pO A n) (pO A n).
intros Q; apply reducestar0; auto.
apply Rstar_0; auto.
Qed.
Hint Resolve reducetopO_pO.
 
Theorem zerop_red_spoly_l :
 forall a b : poly A0 eqA ltM,
 zerop a -> forall Q : list (poly A0 eqA ltM), red (spolyp a b) Q.
intros a b; (case a; case b).
intros x c0 x0 c1; generalize c0 c1; case x; case x0; simpl in |- *; auto.
intros c2 c3 H' Q; unfold red in |- *; simpl in |- *; auto.
intros a0 l c2 c3 H'; elim H'.
intros a0 l c2 c3 H' Q; unfold red in |- *; simpl in |- *; auto.
intros a0 l a1 l0 c2 c3 H'; elim H'.
Qed.
 
Theorem zerop_red_spoly_r :
 forall a b : poly A0 eqA ltM,
 zerop b -> forall Q : list (poly A0 eqA ltM), red (spolyp a b) Q.
intros a b; (case a; case b).
intros x c0 x0 c1; generalize c0 c1; case x; case x0; simpl in |- *; auto.
intros c2 c3 H' Q; unfold red in |- *; simpl in |- *; auto.
intros a0 l c2 c3 H' Q; unfold red in |- *; simpl in |- *; auto.
intros a0 l c2 c3 H'; elim H'.
intros a0 l a1 l0 c2 c3 H'; elim H'.
Qed.
 
Theorem divP_ppc :
 forall a b c : poly A0 eqA ltM, divp a b -> divp a c -> divp a (ppcp b c).
intros a b c; (case a; case b; case c).
intros x c0 x0 c1 x1 c2; generalize c0 c1 c2; case x; case x0; case x1;
 simpl in |- *; auto.
intros a0 l a1 l0 a2 l1 H' H'0 H'1 H'2 H'3.
elim ppc_is_ppcm with (1 := cs) (a := a1) (b := a2); auto.
apply canonical_nzeroP with (ltM := ltM) (p := l0); auto.
apply canonical_nzeroP with (ltM := ltM) (p := l1); auto.
Qed.
 
Definition Cb : poly A0 eqA ltM -> list (poly A0 eqA ltM) -> Prop.
intros H'; case H'.
intros x H'0 Q;
 exact (CombLinear A A0 eqA plusA multA eqA_dec n ltM ltM_dec Q x).
Defined.
 
Theorem Cb_id :
 forall (a : poly A0 eqA ltM) (Q : list (poly A0 eqA ltM)), In a Q -> Cb a Q.
intros a; case a; simpl in |- *.
intros x; case x; auto.
intros c Q H'.
replace (nil (A:=Term A n)) with (pO A n); auto; apply CombLinear_0; auto.
intros a0 l c Q H'.
apply CombLinear_id with (1 := cs); auto.
change
  (inPolySet A A0 eqA n ltM
     (s2p A A0 eqA n ltM (mks A A0 eqA n ltM (pX a0 l) c)) Q) 
 in |- *; apply in_inPolySet; auto.
red in |- *; intros H'4; inversion H'4.
Qed.
 
Theorem inPolySet_addEnd :
 forall (a : list (Term A n)) (p : poly A0 eqA ltM)
   (l : list (poly A0 eqA ltM)),
 inPolySet A A0 eqA n ltM a (addEnd p l) ->
 a = s2p A A0 eqA n ltM p \/ inPolySet A A0 eqA n ltM a l.
intros a p l; elim l; simpl in |- *; auto.
intros H'; inversion H'; auto.
intros a0 l0 H' H'0; inversion H'0; auto.
right.
exact (incons A A0 eqA n ltM a1 p0 H l0).
case H'; auto.
intros H3; right; try assumption.
apply inskip; auto.
Qed.
 
Remark CombLinear_trans1 :
 forall (a : list (Term A n)) (R : list (poly A0 eqA ltM)),
 CombLinear A A0 eqA plusA multA eqA_dec n ltM ltM_dec R a ->
 forall (b : poly A0 eqA ltM) (Q : list (poly A0 eqA ltM)),
 R = addEnd b Q ->
 CombLinear A A0 eqA plusA multA eqA_dec n ltM ltM_dec Q
   (s2p A A0 eqA n ltM b) ->
 CombLinear A A0 eqA plusA multA eqA_dec n ltM ltM_dec Q a.
intros a R H'; elim H'; auto.
intros b Q H'0 H'1.
apply CombLinear_0; auto.
intros a0 p q s H'0 H'1 H'2 H'3 H'4 b Q H'5 H'6.
apply
 CombLinear_comp
  with
    (1 := cs)
    (p := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec
            (mults (A:=A) multA (n:=n) a0 q) p); auto.
2: apply
    eqp_imp_canonical
     with
       (1 := cs)
       (p := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM)
               ltM_dec (mults (A:=A) multA (n:=n) a0 q) p); 
    auto.
2: apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); auto.
2: apply canonical_pluspf with (1 := os); auto.
2: apply canonical_mults with (1 := cs); auto.
2: apply inPolySet_imp_canonical with (L := R); auto.
2: apply
    CombLinear_canonical
     with (eqA_dec := eqA_dec) (ltM_dec := ltM_dec) (1 := cs) (Q := R); 
    auto.
2: apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); auto.
apply CombLinear_pluspf with (1 := cs); auto.
apply CombLinear_mults1 with (1 := cs); auto.
2: apply H'3 with (b := b); auto.
case (inPolySet_addEnd q b Q); auto.
rewrite <- H'5; auto.
intros H'7; rewrite H'7; auto.
intros; (apply CombLinear_id with (1 := cs); auto).
Qed.
 
Theorem Cb_trans :
 forall (a b : poly A0 eqA ltM) (Q : list (poly A0 eqA ltM)),
 Cb a (addEnd b Q) -> Cb b Q -> Cb a Q.
intros a b; case a; case b; simpl in |- *; auto.
intros x c x0 H' Q H'0 H'1.
apply
 CombLinear_trans1
  with
    (R := addEnd
            (exist (fun l : list (Term A n) => canonical A0 eqA ltM l) x c) Q)
    (b := exist (fun l : list (Term A n) => canonical A0 eqA ltM l) x c);
 auto.
Qed.
 
Theorem Cb_incl :
 forall (a : poly A0 eqA ltM) (P Q : list (poly A0 eqA ltM)),
 (forall a : poly A0 eqA ltM, In a P -> In a Q) -> Cb a P -> Cb a Q.
intros a; case a; simpl in |- *; auto.
intros x H' P Q H'0 H'1.
apply CombLinear_incl with (1 := cs) (P := P); auto.
intros a0 H'2.
apply Incl_inp_inPolySet with (P := P); auto.
Qed.
 
Theorem Cb_in1 :
 forall (a b : poly A0 eqA ltM) (Q : list (poly A0 eqA ltM)),
 Cb a Q -> Cb a (b :: Q).
intros a b Q H'.
apply Cb_incl with (P := Q); simpl in |- *; auto.
Qed.
 
Theorem Cb_in :
 forall (a b : poly A0 eqA ltM) (Q : list (poly A0 eqA ltM)),
 Cb a Q -> Cb a (addEnd b Q).
intros a b Q H'.
apply Cb_incl with (P := Q); simpl in |- *; auto.
intros a0 H'0; apply addEnd_id2; auto.
Qed.
 
Theorem Cb_sp :
 forall (a b : poly A0 eqA ltM) (Q : list (poly A0 eqA ltM)),
 Cb a Q -> Cb b Q -> Cb (spolyp a b) Q.
intros a b; case a; case b; simpl in |- *; auto.
intros x; case x; auto.
intros a0 l H' x0; case x0; auto.
intros a1 l0 H'0 Q H'1 H'2.
cut (~ zeroP (A:=A) A0 eqA (n:=n) a0);
 [ intros Z0 | apply canonical_nzeroP with (ltM := ltM) (p := l); auto ].
cut (~ zeroP (A:=A) A0 eqA (n:=n) a1);
 [ intros Z1 | apply canonical_nzeroP with (ltM := ltM) (p := l0); auto ].
apply
 CombLinear_comp
  with
    (1 := cs)
    (p := minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec
            (mults (A:=A) multA (n:=n)
               (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n)
                  (ppc (A:=A) A1 (n:=n) a0 a1) (b:=a0) Z0) 
               (pX a0 l))
            (mults (A:=A) multA (n:=n)
               (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n)
                  (ppc (A:=A) A1 (n:=n) a0 a1) (b:=a1) Z1) 
               (pX a1 l0))); auto.
apply CombLinear_minuspf with (1 := cs); auto.
apply CombLinear_mults1 with (1 := cs); auto.
apply CombLinear_mults1 with (1 := cs); auto.
apply spolyf_canonical with (1 := cs); auto.
apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); auto.
change
  (eqP A eqA n
     (spolyf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec
        (pX a0 l) (pX a1 l0) H' H'0)
     (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec
        (mults (A:=A) multA (n:=n)
           (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n)
              (ppc (A:=A) A1 (n:=n) a0 a1) (b:=a0) Z0) 
           (pX a0 l))
        (mults (A:=A) multA (n:=n)
           (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n)
              (ppc (A:=A) A1 (n:=n) a0 a1) (b:=a1) Z1) 
           (pX a1 l0)))) in |- *.
apply spoly_is_minus with (1 := cs); auto.
Qed.
 
Definition unit : poly A0 eqA ltM -> Term A n.
intros p; case p.
intros x; case x.
intros H'; exact (T1 A1 n).
intros a l; case a.
intros co m H'; cut (~ eqA co A0).
intros H'0; exact (divA A1 co H'0, M1 n).
inversion H'; auto.
simpl in H0.
intuition.
Defined.
 
Theorem unit_T1 : forall p : poly A0 eqA ltM, eqT (unit p) (T1 A1 n).
unfold eqT in |- *; intros p; case p.
intros x; case x; simpl in |- *; auto.
intros a l; case a; simpl in |- *; auto.
Qed.
 
Theorem divA_nZ :
 forall a b : A,
 ~ eqA b A0 -> forall nZa : ~ eqA a A0, ~ eqA (divA b a nZa) A0.
intros a b H' nZa; red in |- *; intros H'1; auto.
case H';
 apply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := multA (divA b a nZa) a);
 auto.
apply divA_is_multA with (1 := cs); auto.
apply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := multA A0 a); auto.
apply multA_eqA_comp with (1 := cs); auto.
apply (eqA_ref _ _ _ _ _ _ _ _ _ cs); auto.
apply multA_A0_l with (1 := cs); auto.
Qed.
Hint Resolve divA_nZ.
 
Theorem unit_nZ :
 forall p : poly A0 eqA ltM, ~ zeroP (A:=A) A0 eqA (n:=n) (unit p).
intros p; case p.
intros x; case x; simpl in |- *; auto.
intros a l; case a; simpl in |- *; auto.
Qed.
 
Definition nf : poly A0 eqA ltM -> list (poly A0 eqA ltM) -> poly A0 eqA ltM.
intros p L.
case
 (Reducef A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec
    os L p).
intros x H'.
apply LetP with (A := poly A0 eqA ltM) (h := x).
intros u H'1; case u.
intros x0 H'2;
 exists (mults (A:=A) multA (n:=n) (unit (mks A A0 eqA n ltM x0 H'2)) x0);
 auto.
apply canonical_mults with (1 := cs); auto.
apply unit_nZ; auto.
Defined.
 
Theorem nf_irreducible :
 forall (p : poly A0 eqA ltM) (aP : list (poly A0 eqA ltM)),
 irreducible A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec aP
   (s2p A A0 eqA n ltM (nf p aP)).
unfold nf in |- *.
intros p aP;
 case
  (Reducef A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec
     os aP p).
intros x; case x; simpl in |- *; auto.
intros x0 c H'; inversion H'.
red in H0.
red in |- *; red in |- *.
intros q0; intros H'0; auto.
cut (~ zeroP (A:=A) A0 eqA (n:=n) (unit (mks A A0 eqA n ltM x0 c)));
 [ intros nZd | idtac ]; auto.
apply
 H0
   with
     (q := mults (A:=A) multA (n:=n)
             (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) 
                (T1 A1 n) (b:=unit (mks A A0 eqA n ltM x0 c)) nZd) q0);
 auto.
apply reduce_mults_invf with (1 := cs); auto.
apply unit_T1; auto.
apply unit_nZ; auto.
Qed.
 
Theorem nf_red :
 forall (a : poly A0 eqA ltM) (aP aQ : list (poly A0 eqA ltM)),
 incl aP aQ -> red (nf a aP) aQ -> red a aQ.
intros a; case a; simpl in |- *.
unfold red in |- *; unfold nf in |- *; simpl in |- *; auto.
intros x c aP aQ H';
 case
  (Reducef A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec
     os aP (exist (fun a => canonical A0 eqA ltM a) x c)); 
 simpl in |- *; auto.
intros x0; case x0; simpl in |- *; auto.
intros x1 c0 H'0 H'1.
apply rstar_rtopO; auto.
apply reduceplus_trans with (Q := aQ) (1 := cs) (y := x1); auto.
inversion H'0; auto.
apply inP_reduceplus with (Q := aP); auto.
intros a0 H'3.
apply Incl_inp_inPolySet with (P := aP); auto.
apply
 reduceplus_mults_inv with (1 := cs) (a := unit (mks A A0 eqA n ltM x1 c0));
 auto.
apply unit_nZ; auto.
apply unit_T1; auto.
inversion H'1; inversion H; auto.
Qed.
 
Theorem red_zerop :
 forall (a : poly A0 eqA ltM) (P : list (poly A0 eqA ltM)),
 red (nf a P) P -> zerop (nf a P).
unfold nf in |- *.
intros p aP; case p.
intros x c.
case
 (Reducef A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec
    os aP (exist (fun l => canonical A0 eqA ltM l) x c)); 
 auto.
unfold red in |- *; auto.
intros x0; case x0.
intros x1; case x1.
simpl in |- *; auto.
intros a l c0 H' H'0; inversion H'.
simpl in |- *.
change
  (reducestar A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec aP
     (mults (A:=A) multA (n:=n) (unit (mks A A0 eqA n ltM (a :: l) c0))
        (a :: l)) (pO A n)) in H'0.
inversion H'0.
inversion H3.
inversion H7.
simpl in H0.
cut (~ zeroP (A:=A) A0 eqA (n:=n) (unit (mks A A0 eqA n ltM (pX a l) c0)));
 [ intros nZd | idtac ]; auto.
case
 (H0
    (mults (A:=A) multA (n:=n)
       (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) 
          (T1 A1 n) (b:=unit (mks A A0 eqA n ltM (pX a l) c0)) nZd) y)); 
 auto.
apply reduce_mults_invf with (1 := cs); auto.
apply unit_T1; auto.
apply unit_nZ; auto.
Qed.
 
Theorem zerop_red :
 forall (a : poly A0 eqA ltM) (aP : list (poly A0 eqA ltM)),
 zerop (nf a aP) -> red a aP.
intros a aP H'.
apply nf_red with (aP := aP); auto with datatypes.
generalize H'; case (nf a aP); simpl in |- *; auto.
intros x; case x; simpl in |- *; auto.
intros c H'0; red in |- *; simpl in |- *; auto.
intros a0 l H'0 H'1; elim H'1; auto.
Qed.
 
Theorem canonical_s2p :
 forall x : poly A0 eqA ltM, canonical A0 eqA ltM (s2p A A0 eqA n ltM x).
intros x; case x; auto.
Qed.
Hint Resolve canonical_s2p.
 
Theorem nf_Cb :
 forall (a : poly A0 eqA ltM) (aP : list (poly A0 eqA ltM)),
 Cb a aP -> Cb (nf a aP) aP.
intros a; case a; unfold nf, Cb in |- *; auto.
intros x c Q H';
 case
  (Reducef A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec
     os Q (exist (fun l : list (Term A n) => canonical A0 eqA ltM l) x c));
 auto.
intros x0; case x0.
intros x1 H'0 H'1.
change
  (CombLinear A A0 eqA plusA multA eqA_dec n ltM ltM_dec Q
     (mults (A:=A) multA (n:=n) (unit (mks A A0 eqA n ltM x1 H'0)) x1))
 in |- *.
apply CombLinear_mults1 with (1 := cs); auto.
apply unit_nZ; auto.
apply reducestar_cb with (a := x) (1 := cs); auto.
Qed.
 
Definition foreigner : poly A0 eqA ltM -> poly A0 eqA ltM -> Prop.
intros a b; case a; case b.
intros x; case x.
intros H' x0 H'0; exact True.
intros a0 l H' x0; case x0.
intros H'0; exact True.
intros a1 l0 H'0;
 exact
  (eqT (ppc (A:=A) A1 (n:=n) a0 a1) (multTerm (A:=A) multA (n:=n) a0 a1)).
Defined.
 
Definition foreigner_dec :
  forall a b : poly A0 eqA ltM, {foreigner a b} + {~ foreigner a b}.
intros a b; case a; case b.
intros x; case x.
simpl in |- *; auto.
intros a0 l c x0; case x0; simpl in |- *; auto.
intros a1 l0 H'.
apply eqT_dec; auto.
Defined.
 
Theorem foreigner_red :
 forall (a b : poly A0 eqA ltM) (P : list (poly A0 eqA ltM)),
 foreigner a b -> In a P -> In b P -> red (spolyp a b) P.
intros a b; case a; case b.
intros x; case x.
simpl in |- *; auto.
unfold red in |- *; simpl in |- *; auto.
intros a0 l c x0; case x0.
unfold red in |- *; simpl in |- *; auto.
unfold red in |- *; simpl in |- *; auto.
intros a1 l0 c0 P H' H'0 H'1.
unfold LetP in |- *; simpl in |- *; auto.
apply
 reducestar_eqp_com
  with
    (1 := cs)
    (p := spolyf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec
            (pX a0 l) (pX a1 l0) c c0)
    (q := pO A n); auto.
apply spoly_Reducestar_ppc with (1 := cs); auto.
change
  (inPolySet A A0 eqA n ltM
     (s2p A A0 eqA n ltM (mks A A0 eqA n ltM (pX a1 l0) c0)) P) 
 in |- *.
apply in_inPolySet; auto.
red in |- *; intros H'3; inversion H'3; auto.
change
  (inPolySet A A0 eqA n ltM
     (s2p A A0 eqA n ltM (mks A A0 eqA n ltM (pX a0 l) c)) P) 
 in |- *.
apply in_inPolySet; auto.
red in |- *; intros H'3; inversion H'3; auto.
apply spolyf_canonical with (1 := cs); auto.
Qed.
End BuchAux.