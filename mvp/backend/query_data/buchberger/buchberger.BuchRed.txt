
Require Export Pcomb.
(* Pcomb:
Require Export Pspoly.
Require Export LetP.

Local Unset Injection On Proofs.

Section Pcomb.
Load "hCoefStructure".
Load "hOrderStructure".
Load "hSpoly".
 
Inductive CombLinear (Q : list (poly A0 eqA ltM)) :
list (Term A n) -> Prop :=
  | CombLinear_0 : CombLinear Q (pO A n)
  | CombLinear_1 :
      forall (a : Term A n) (p q s : list (Term A n)),
      ~ zeroP (A:=A) A0 eqA (n:=n) a ->
      inPolySet A A0 eqA n ltM q Q ->
      CombLinear Q p ->
      eqP A eqA n s
        (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec
           (mults (A:=A) multA (n:=n) a q) p) -> CombLinear Q s.
Hint Resolve CombLinear_0 CombLinear_1.
 
Theorem CombLinear_canonical :
 forall (Q : list (poly A0 eqA ltM)) (p : list (Term A n)),
 CombLinear Q p -> canonical A0 eqA ltM p.
 
Theorem CombLinear_comp :
 forall (Q : list (poly A0 eqA ltM)) (p : list (Term A n)),
 CombLinear Q p ->
 forall q : list (Term A n),
 canonical A0 eqA ltM q -> eqP A eqA n p q -> CombLinear Q q.
Hint Resolve CombLinear_canonical.
 
Theorem CombLinear_pluspf :
 forall (Q : list (poly A0 eqA ltM)) (p : list (Term A n)),
 CombLinear Q p ->
 forall q : list (Term A n),
 CombLinear Q q ->
 CombLinear Q
   (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec p q).
Hint Resolve CombLinear_pluspf.
 
Theorem CombLinear_mults1 :
 forall (Q : list (poly A0 eqA ltM)) (a : Term A n) (p : list (Term A n)),
 ~ zeroP (A:=A) A0 eqA (n:=n) a ->
 CombLinear Q p -> CombLinear Q (mults (A:=A) multA (n:=n) a p).
Hint Resolve CombLinear_mults1.
 
Theorem CombLinear_minuspf :
 forall (Q : list (poly A0 eqA ltM)) (p : list (Term A n)),
 CombLinear Q p ->
 forall q : list (Term A n),
 CombLinear Q q ->
 CombLinear Q
   (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q).
Hint Resolve CombLinear_minuspf.
 
Theorem CombLinear_id :
 forall (Q : list (poly A0 eqA ltM)) (p : list (Term A n)),
 inPolySet A A0 eqA n ltM p Q -> CombLinear Q p.
Hint Resolve CombLinear_id.
 
Theorem CombLinear_spoly :
 forall (Q : list (poly A0 eqA ltM)) (p q : list (Term A n))
   (Cp : canonical A0 eqA ltM p) (Cq : canonical A0 eqA ltM q),
 inPolySet A A0 eqA n ltM p Q ->
 inPolySet A A0 eqA n ltM q Q ->
 CombLinear Q
   (spolyf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec p q Cp Cq).
 
Theorem CombLinear_reduce :
 forall (Q : list (poly A0 eqA ltM)) (p q : list (Term A n)),
 reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p q ->
 canonical A0 eqA ltM p -> CombLinear Q q -> CombLinear Q p.
 
Theorem CombLinear_reduceplus :
 forall (Q : list (poly A0 eqA ltM)) (p q : list (Term A n)),
 reduceplus A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p q ->
 canonical A0 eqA ltM p -> CombLinear Q q -> CombLinear Q p.
 
Theorem CombLinear_reducestar :
 forall (Q : list (poly A0 eqA ltM)) (p q : list (Term A n)),
 reducestar A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p q ->
 canonical A0 eqA ltM p -> CombLinear Q q -> CombLinear Q p.
 
Theorem Reducestar_pO_imp_CombLinear :
 forall (Q : list (poly A0 eqA ltM)) (p q : list (Term A n)),
 reducestar A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p q ->
 canonical A0 eqA ltM p -> eqP A eqA n q (pO A n) -> CombLinear Q p.
 
Inductive Grobner (Q : list (poly A0 eqA ltM)) : Prop :=
    Grobner0 :
      (forall p q : list (Term A n),
       CombLinear Q p ->
       reducestar A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q
         p q -> eqP A eqA n q (pO A n)) -> Grobner Q.
 
Theorem Grobner_imp_SpolyQ :
 forall Q : list (poly A0 eqA ltM),
 Grobner Q ->
 SpolyQ A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q.
 
Inductive ConfluentReduce (Q : list (poly A0 eqA ltM)) : Prop :=
    ConfluentReduce0 :
      (forall p : list (Term A n),
       canonical A0 eqA ltM p ->
       ReduStarConfluent A A0 A1 eqA invA minusA multA divA eqA_dec n ltM
         ltM_dec Q p) -> ConfluentReduce Q.
 
Theorem SpolyQ_imp_ConfluentReduce :
 forall Q : list (poly A0 eqA ltM),
 SpolyQ A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q ->
 ConfluentReduce Q.
 
Theorem ConfluentReduce_imp_Grobner :
 forall Q : list (poly A0 eqA ltM), ConfluentReduce Q -> Grobner Q.
 
Theorem CombLinear_incl :
 forall (a : list (Term A n)) (P Q : list (poly A0 eqA ltM)),
 (forall a : list (Term A n),
  inPolySet A A0 eqA n ltM a P -> inPolySet A A0 eqA n ltM a Q) ->
 CombLinear P a -> CombLinear Q a.
 
Remark CombLinear_trans_cons_lem :
 forall (a : list (Term A n)) (R : list (poly A0 eqA ltM)),
 CombLinear R a ->
 forall (b : poly A0 eqA ltM) (Q : list (poly A0 eqA ltM)),
 R = b :: Q -> CombLinear Q (s2p A A0 eqA n ltM b) -> CombLinear Q a.
 
Theorem reduce_cb :
 forall (a b : list (Term A n)) (Q : list (poly A0 eqA ltM)),
 reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q a b ->
 canonical A0 eqA ltM a -> CombLinear Q a -> CombLinear Q b.
 
Theorem reduceplus_cb :
 forall (a b : list (Term A n)) (Q : list (poly A0 eqA ltM)),
 reduceplus A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q a b ->
 canonical A0 eqA ltM a -> CombLinear Q a -> CombLinear Q b.
 
Theorem reducestar_cb :
 forall (a b : list (Term A n)) (Q : list (poly A0 eqA ltM)),
 reducestar A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q a b ->
 canonical A0 eqA ltM a -> CombLinear Q a -> CombLinear Q b.

Theorem reduce_cb1 :
 forall (a : poly A0 eqA ltM) (b : list (Term A n))
   (Q : list (poly A0 eqA ltM)),
 reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q
   (s2p A A0 eqA n ltM a) b -> CombLinear (a :: Q) b.
 
Theorem CombLinear_compo :
 forall (p : list (Term A n)) (L1 : list (poly A0 eqA ltM)),
 CombLinear L1 p ->
 forall L2 : list (poly A0 eqA ltM),
 (forall q : list (Term A n),
  inPolySet A A0 eqA n ltM q L1 -> CombLinear L2 q) -> 
 CombLinear L2 p.
 
Theorem reduceplus_cb1_lem :
 forall (a b : list (Term A n)) (Q : list (poly A0 eqA ltM)),
 reduceplus A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q a b ->
 forall x : poly A0 eqA ltM,
 s2p A A0 eqA n ltM x = a -> CombLinear (x :: Q) b.
 
Theorem reduceplus_cb1 :
 forall (a : poly A0 eqA ltM) (b : list (Term A n))
   (Q : list (poly A0 eqA ltM)),
 reduceplus A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q
   (s2p A A0 eqA n ltM a) b -> CombLinear (a :: Q) b.
 
Theorem reducestar_cb1 :
 forall (a : poly A0 eqA ltM) (b : list (Term A n))
   (Q : list (poly A0 eqA ltM)),
 reducestar A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q
   (s2p A A0 eqA n ltM a) b -> CombLinear (a :: Q) b.
 
Theorem reduce_cb2 :
 forall (a b : poly A0 eqA ltM) (Q : list (poly A0 eqA ltM)),
 reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q
   (s2p A A0 eqA n ltM a) (s2p A A0 eqA n ltM b) ->
 CombLinear (b :: Q) (s2p A A0 eqA n ltM a).
 
Theorem reduceplus_cb2_lem :
 forall (a b : list (Term A n)) (Q : list (poly A0 eqA ltM)),
 reduceplus A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q a b ->
 canonical A0 eqA ltM a ->
 forall x : poly A0 eqA ltM,
 s2p A A0 eqA n ltM x = b -> CombLinear (x :: Q) a.
 
Theorem reduceplus_cb2 :
 forall (a b : poly A0 eqA ltM) (Q : list (poly A0 eqA ltM)),
 reduceplus A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q
   (s2p A A0 eqA n ltM a) (s2p A A0 eqA n ltM b) ->
 CombLinear (b :: Q) (s2p A A0 eqA n ltM a).
 
Theorem reducestar_cb2 :
 forall (a b : poly A0 eqA ltM) (Q : list (poly A0 eqA ltM)),
 reducestar A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q
   (s2p A A0 eqA n ltM a) (s2p A A0 eqA n ltM b) ->
 CombLinear (b :: Q) (s2p A A0 eqA n ltM a).
End Pcomb. *)
Require Export Pcrit.
(* Pcrit:
Require Export Pspoly.
Require Export Pmult.
Section crit.
Load "hCoefStructure".
Load "hOrderStructure".
Load "hSpoly".
Load "hMult".
 
Definition Rminus :
  forall (a : Term A n) (nZa : ~ zeroP (A:=A) A0 eqA (n:=n) a),
  list (Term A n) -> list (Term A n) -> list (Term A n) -> list (Term A n).
 
Theorem minuspf_in :
 forall (p q : list (Term A n)) (a b : Term A n),
 In a p ->
 ltT ltM b a ->
 canonical A0 eqA ltM p ->
 canonical A0 eqA ltM (pX b q) ->
 In a
   (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p (pX b q)).
 
Theorem minus_is_reduce :
 forall (Q : list (poly A0 eqA ltM)) (a : Term A n)
   (nZa : ~ zeroP (A:=A) A0 eqA (n:=n) a) (q : list (Term A n)),
 inPolySet A A0 eqA n ltM (pX a q) Q ->
 forall u : Term A n,
 divP A A0 eqA multA divA n u a ->
 forall p : list (Term A n),
 canonical A0 eqA ltM p ->
 In u p ->
 reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p
   (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p
      (mults (A:=A) multA (n:=n)
         (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) u (b:=a) nZa)
         (pX a q))).
 
Definition divPp : Term A n -> list (Term A n) -> Prop.
Hint Resolve divP_inv3.
Hint Resolve divP_inv3.
 
Definition divpf :
  forall (a : Term A n) (nZa : ~ zeroP (A:=A) A0 eqA (n:=n) a),
  list (Term A n) -> list (Term A n).
 
Theorem divpf_canonical :
 forall (a : Term A n) (p : list (Term A n))
   (nZa : ~ zeroP (A:=A) A0 eqA (n:=n) a),
 canonical A0 eqA ltM p -> canonical A0 eqA ltM (divpf a nZa p).
Hint Resolve divpf_canonical.
 
Theorem divPp_divpf :
 forall (a : Term A n) (nZa : ~ zeroP (A:=A) A0 eqA (n:=n) a)
   (p : list (Term A n)),
 canonical A0 eqA ltM p ->
 divPp a p -> eqP A eqA n p (mults (A:=A) multA (n:=n) a (divpf a nZa p)).
 
Theorem canonical_Rminus :
 forall (r p q : list (Term A n)) (a : Term A n)
   (nZa : ~ zeroP (A:=A) A0 eqA (n:=n) a),
 canonical A0 eqA ltM p ->
 canonical A0 eqA ltM q ->
 canonical A0 eqA ltM r -> canonical A0 eqA ltM (Rminus a nZa p q r).
Hint Resolve canonical_Rminus.
 
Theorem Rminus_in :
 forall (r p q : list (Term A n)) (a b : Term A n)
   (nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b),
 divPp b r ->
 In a p ->
 canonical A0 eqA ltM p ->
 canonical A0 eqA ltM (pX b q) ->
 canonical A0 eqA ltM (pX a r) -> In a (Rminus b nZb p (pX b q) r).
 
Theorem Rminus_is_reduceplus :
 forall (Q : list (poly A0 eqA ltM)) (a : Term A n) 
   (q : list (Term A n)) (nZa : ~ zeroP (A:=A) A0 eqA (n:=n) a),
 canonical A0 eqA ltM q ->
 inPolySet A A0 eqA n ltM (pX a q) Q ->
 forall r : list (Term A n),
 canonical A0 eqA ltM r ->
 divPp a r ->
 forall p : list (Term A n),
 canonical A0 eqA ltM p ->
 incl r p ->
 reduceplus A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p
   (Rminus a nZa p (pX a q) r).
 
Definition Dmult :
  forall (a : Term A n) (nZa : ~ zeroP (A:=A) A0 eqA (n:=n) a),
  list (Term A n) -> list (Term A n) -> list (Term A n).
 
Theorem canonical_Dmult :
 forall (a : Term A n) (nZa : ~ zeroP (A:=A) A0 eqA (n:=n) a)
   (p q : list (Term A n)),
 canonical A0 eqA ltM p ->
 canonical A0 eqA ltM q -> canonical A0 eqA ltM (Dmult a nZa p q).
Hint Resolve canonical_Dmult.
 
Theorem divp_is_multTerm :
 forall (a b : Term A n) (nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b),
 divP A A0 eqA multA divA n a b ->
 forall p : list (Term A n),
 canonical A0 eqA ltM p ->
 eqP A eqA n
   (mults (A:=A) multA (n:=n)
      (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) a (b:=b) nZb) p)
   (divpf b nZb (mults (A:=A) multA (n:=n) a p)).
 
Theorem Rminus_is_mult :
 forall (r p q : list (Term A n)) (a : Term A n)
   (nZa : ~ zeroP (A:=A) A0 eqA (n:=n) a),
 canonical A0 eqA ltM p ->
 canonical A0 eqA ltM q ->
 canonical A0 eqA ltM r ->
 divPp a r ->
 eqP A eqA n (Rminus a nZa p q r)
   (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p
      (Dmult a nZa r q)).
 
Theorem divpf_comp :
 forall (a b : Term A n) (p q : list (Term A n)),
 eqP A eqA n p q ->
 canonical A0 eqA ltM p ->
 canonical A0 eqA ltM q ->
 eqTerm (A:=A) eqA (n:=n) a b ->
 forall (nZa : ~ zeroP (A:=A) A0 eqA (n:=n) a)
   (nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b),
 eqP A eqA n (divpf a nZa p) (divpf b nZb q).
 
Theorem Dmult_is_mulpf :
 forall (a : Term A n) (nZa : ~ zeroP (A:=A) A0 eqA (n:=n) a)
   (p q : list (Term A n)),
 canonical A0 eqA ltM p ->
 canonical A0 eqA ltM q ->
 eqP A eqA n (Dmult a nZa (mults (A:=A) multA (n:=n) a p) q)
   (multpf A A0 eqA plusA multA eqA_dec n ltM ltM_dec p q).
 
Theorem sp_Rminus :
 forall (a b : Term A n) (nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b)
   (p q : list (Term A n)),
 canonical A0 eqA ltM (pX a p) ->
 canonical A0 eqA ltM (pX b q) ->
 eqP A eqA n
   (Rminus b nZb
      (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec
         (mults (A:=A) multA (n:=n) b p) (mults (A:=A) multA (n:=n) a q))
      (pX b q) (mults (A:=A) multA (n:=n) b p))
   (mults (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n))
      (multpf A A0 eqA plusA multA eqA_dec n ltM ltM_dec (pX a p) q)).
 
Theorem minuspf_spoly_in :
 forall (a b : Term A n) (nZa : ~ zeroP (A:=A) A0 eqA (n:=n) a)
   (nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b),
 eqT (ppc (A:=A) A1 (n:=n) a b) (multTerm (A:=A) multA (n:=n) a b) ->
 forall p q : list (Term A n),
 canonical A0 eqA ltM p ->
 canonical A0 eqA ltM q ->
 (forall c : Term A n,
  In c p ->
  ltT ltM c (multTerm (A:=A) multA (n:=n) a b) /\
  eqT c
    (multTerm (A:=A) multA (n:=n)
       (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) c (b:=b) nZb) b)) ->
 (forall c : Term A n,
  In c q ->
  ltT ltM c (multTerm (A:=A) multA (n:=n) a b) /\
  eqT c
    (multTerm (A:=A) multA (n:=n)
       (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) c (b:=a) nZa) a)) ->
 forall c : Term A n,
 In c p ->
 In c (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q).
 
Theorem multTerm_or_z_d1 :
 forall (a b : Term A n) (nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b)
   (p : list (Term A n)),
 canonical A0 eqA ltM (pX a p) ->
 forall c : Term A n,
 In c (mults (A:=A) multA (n:=n) b p) ->
 ltT ltM c (multTerm (A:=A) multA (n:=n) a b) /\
 eqT c
   (multTerm (A:=A) multA (n:=n)
      (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) c (b:=b) nZb) b).
 
Theorem multTerm_or_z_d2 :
 forall (a b : Term A n) (nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b)
   (p : list (Term A n)),
 canonical A0 eqA ltM (pX a p) ->
 forall c : Term A n,
 In c (mults (A:=A) multA (n:=n) b p) ->
 ltT ltM c (multTerm (A:=A) multA (n:=n) b a) /\
 eqT c
   (multTerm (A:=A) multA (n:=n)
      (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) c (b:=b) nZb) b).
 
Theorem in_minuspf_spoly_in :
 forall a b : Term A n,
 eqT (ppc (A:=A) A1 (n:=n) a b) (multTerm (A:=A) multA (n:=n) a b) ->
 forall p q : list (Term A n),
 canonical A0 eqA ltM (pX a p) ->
 canonical A0 eqA ltM (pX b q) ->
 forall c : Term A n,
 In c (mults (A:=A) multA (n:=n) b p) ->
 In c
   (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec
      (mults (A:=A) multA (n:=n) b p) (mults (A:=A) multA (n:=n) a q)).
 
Theorem divPp_mults1 :
 forall a : Term A n,
 ~ zeroP (A:=A) A0 eqA (n:=n) a ->
 forall p : list (Term A n),
 (forall b : Term A n, In b p -> ~ zeroP (A:=A) A0 eqA (n:=n) b) ->
 divPp a (mults (A:=A) multA (n:=n) a p).
 
Theorem spoly_Reduce :
 forall (Q : list (poly A0 eqA ltM)) (a b : Term A n),
 eqT (ppc (A:=A) A1 (n:=n) a b) (multTerm (A:=A) multA (n:=n) a b) ->
 forall p q : list (Term A n),
 inPolySet A A0 eqA n ltM (pX b q) Q ->
 canonical A0 eqA ltM (pX a p) ->
 reduceplus A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q
   (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec
      (mults (A:=A) multA (n:=n) b p) (mults (A:=A) multA (n:=n) a q))
   (mults (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n))
      (multpf A A0 eqA plusA multA eqA_dec n ltM ltM_dec (pX a p) q)).
 
Theorem spoly_reduceplus_pO :
 forall (Q : list (poly A0 eqA ltM)) (p q : list (Term A n)),
 inPolySet A A0 eqA n ltM q Q ->
 canonical A0 eqA ltM p ->
 reduceplus A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q
   (multpf A A0 eqA plusA multA eqA_dec n ltM ltM_dec p q) 
   (pO A n).
 
Theorem fspoly_Reduceplus_pO :
 forall (Q : list (poly A0 eqA ltM)) (a b : Term A n),
 eqT (ppc (A:=A) A1 (n:=n) a b) (multTerm (A:=A) multA (n:=n) a b) ->
 forall p q : list (Term A n),
 inPolySet A A0 eqA n ltM (pX b q) Q ->
 inPolySet A A0 eqA n ltM (pX a p) Q ->
 reduceplus A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q
   (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec
      (mults (A:=A) multA (n:=n) b p) (mults (A:=A) multA (n:=n) a q))
   (pO A n).
 
Theorem spoly_Reducestar_pO :
 forall (Q : list (poly A0 eqA ltM)) (a b : Term A n),
 eqT (ppc (A:=A) A1 (n:=n) a b) (multTerm (A:=A) multA (n:=n) a b) ->
 forall (p q : list (Term A n)) (Cpxb : canonical A0 eqA ltM (pX b q))
   (Cpxa : canonical A0 eqA ltM (pX a p)),
 inPolySet A A0 eqA n ltM (pX b q) Q ->
 inPolySet A A0 eqA n ltM (pX a p) Q ->
 reduceplus A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q
   (spolyf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec 
      (pX a p) (pX b q) Cpxa Cpxb) (pO A n).
 
Theorem spoly_Reducestar_ppc :
 forall (Q : list (poly A0 eqA ltM)) (a b : Term A n),
 eqT (ppc (A:=A) A1 (n:=n) a b) (multTerm (A:=A) multA (n:=n) a b) ->
 forall (p q : list (Term A n)) (Cpxb : canonical A0 eqA ltM (pX b q))
   (Cpxa : canonical A0 eqA ltM (pX a p)),
 inPolySet A A0 eqA n ltM (pX b q) Q ->
 inPolySet A A0 eqA n ltM (pX a p) Q ->
 reducestar A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q
   (spolyf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec 
      (pX a p) (pX b q) Cpxa Cpxb) (pO A n).
End crit. *)
Require Export Buch.
(* Buch:
Require Export List.
Require Import Inclusion.
Require Import Inverse_Image.
Require Import Wf_nat.
Require Import Relation_Definitions.
Require Import Relation_Operators.
Require Import Relation_Operators_compat.
Require Import Lexicographic_Product.
Require Import LetP.
Require Export WfR0.
Section Buch.
Load "hCoefStructure".
Load "hOrderStructure".
Load "hWfRO".
 
Inductive stable :
list (poly A0 eqA ltM) -> list (poly A0 eqA ltM) -> Prop :=
    stable0 :
      forall P Q : list (poly A0 eqA ltM),
      (forall a : poly A0 eqA ltM,
       Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec a P ->
       Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec a Q) ->
      (forall a : poly A0 eqA ltM,
       Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec a Q ->
       Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec a P) -> 
      stable P Q.
Hint Resolve stable0.
 
Theorem stable_refl : forall Q : list (poly A0 eqA ltM), stable Q Q.
 
Theorem stable_trans :
 forall Q y R : list (poly A0 eqA ltM),
 stable Q y -> stable y R -> stable Q R.
 
Theorem stable_sym :
 forall Q R : list (poly A0 eqA ltM), stable R Q -> stable Q R.
Hint Resolve (Cb_in _ _ _ _ _ _ _ _ _ cs eqA_dec _ _ ltM_dec os).
 
Theorem Cb_stable :
 forall (a : poly A0 eqA ltM) (Q : list (poly A0 eqA ltM)),
 Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec a Q ->
 stable Q (addEnd A A0 eqA n ltM a Q).
 
Theorem in_incl :
 forall (A : Set) (p q : list A) (a b : A), incl p q -> In a p -> In a q.
 
Inductive reds :
poly A0 eqA ltM -> poly A0 eqA ltM -> list (poly A0 eqA ltM) -> Prop :=
  | reds0 :
      forall (P : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM),
      red A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec
        (spolyp A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM
           ltM_dec os a b) P -> reds a b P
  | reds1 :
      forall (P : list (poly A0 eqA ltM)) (a b c : poly A0 eqA ltM),
      In c P ->
      reds a c P ->
      reds c b P ->
      divp A A0 eqA multA divA n ltM
        (ppcp A A0 A1 eqA plusA invA minusA multA divA cs n ltM a b) c ->
      reds a b P.
 
Theorem reds_com :
 forall (P : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM),
 reds a b P -> reds b a P.

Inductive cpRes : Set :=
  | Keep : forall P : list (poly A0 eqA ltM), cpRes
  | DontKeep : forall P : list (poly A0 eqA ltM), cpRes.
 
Definition getRes : cpRes -> list (poly A0 eqA ltM).
 
Definition addRes : poly A0 eqA ltM -> cpRes -> cpRes.
 
Definition slice :
  poly A0 eqA ltM -> poly A0 eqA ltM -> list (poly A0 eqA ltM) -> cpRes.
 
Definition slicef :
  poly A0 eqA ltM ->
  poly A0 eqA ltM -> list (poly A0 eqA ltM) -> list (poly A0 eqA ltM).
 
Theorem slicef_incl :
 forall (a b : poly A0 eqA ltM) (P : list (poly A0 eqA ltM)),
 incl (slicef a b P) P.
 
Theorem slice_inv :
 forall (a b : poly A0 eqA ltM) (P : list (poly A0 eqA ltM))
   (c : poly A0 eqA ltM),
 In c P ->
 In c (getRes (slice a b P)) \/
 divp A A0 eqA multA divA n ltM
   (ppcp A A0 A1 eqA plusA invA minusA multA divA cs n ltM a c) b.
 
Theorem slice_cons :
 forall (i a : poly A0 eqA ltM) (aP Q : list (poly A0 eqA ltM)),
 slice i a aP = DontKeep Q ->
 (exists c : poly A0 eqA ltM,
    In c Q /\
    divp A A0 eqA multA divA n ltM
      (ppcp A A0 A1 eqA plusA invA minusA multA divA cs n ltM i a) c) \/
 foreigner A A0 A1 eqA multA n ltM i a.
 
Definition Tl : list (poly A0 eqA ltM) -> list (poly A0 eqA ltM) -> Prop.
 
Theorem wf_Tl : well_founded Tl.
 
Scheme Sdep := Induction for prod Sort Prop.
Require Import Arith.
 
Theorem slice_Tl :
 forall (a ia : poly A0 eqA ltM) (L : list (poly A0 eqA ltM)),
 Tl (slicef a ia L) (a :: L).
 
Inductive genPcP :
poly A0 eqA ltM ->
list (poly A0 eqA ltM) ->
list (poly A0 eqA ltM) -> list (poly A0 eqA ltM) -> Prop :=
  | genPcP0 :
      forall (i : poly A0 eqA ltM) (L : list (poly A0 eqA ltM)),
      genPcP i nil L L
  | genPcP1 :
      forall (L L1 L2 L3 : list _) (a i : poly A0 eqA ltM),
      slice i a L1 = Keep L2 ->
      genPcP i L2 L L3 ->
      genPcP i (a :: L1) L
        (addEnd A A0 eqA n ltM
           (spolyp A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM
              ltM_dec os i a) L3)
  | genPcP2 :
      forall (L L1 L2 L3 : list _) (a i : poly A0 eqA ltM),
      slice i a L1 = DontKeep L2 ->
      genPcP i L2 L L3 -> genPcP i (a :: L1) L L3.
Hint Resolve genPcP0.
 
Theorem genPcP_spolyp1 :
 forall (i : poly A0 eqA ltM) (L L1 L2 : list _),
 genPcP i L1 L L2 ->
 forall a : poly A0 eqA ltM,
 In a L2 ->
 (exists b : poly A0 eqA ltM,
    In b L1 /\
    a =
    spolyp A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec
      os i b) \/ In a L.
Hint Resolve (addEnd_id2 A A0 eqA n ltM).
Hint Resolve (addEnd_id1 A A0 eqA n ltM).
 
Theorem genPcP_incl :
 forall (i : poly A0 eqA ltM) (L L1 L2 : list _),
 genPcP i L1 L L2 -> incl L L2.
 
Lemma spolyp_cons_genPcP0 :
 forall (aP R Q : list _) (i : poly A0 eqA ltM),
 genPcP i aP R Q ->
 ~ BuchAux.zerop A A0 eqA n ltM i ->
 
Lemma spolyp_cons_genPcP :
 forall (aP R Q : list _) (i : poly A0 eqA ltM),
 genPcP i aP R Q ->
 ~ BuchAux.zerop A A0 eqA n ltM i ->
 
Theorem Cb_genPcP :
 forall (i : poly A0 eqA ltM) (P Q R S : list (poly A0 eqA ltM)),
 genPcP i P R Q ->
 Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec i S ->
 (forall a : poly A0 eqA ltM,
  In a P -> Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec a S) ->
 (forall a : poly A0 eqA ltM,
  In a R -> Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec a S) ->
 forall a : poly A0 eqA ltM,
 In a Q -> Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec a S.
 
Definition genPcPf0 :
  forall (i : poly A0 eqA ltM) (aP R : list (poly A0 eqA ltM)),
  {Q : list (poly A0 eqA ltM) | genPcP i aP R Q}.
 
Definition genPcPf :
  poly A0 eqA ltM ->
  list (poly A0 eqA ltM) -> list (poly A0 eqA ltM) -> list (poly A0 eqA ltM).

Theorem Cb_genPcPf :
 forall (b : poly A0 eqA ltM) (P Q R : list (poly A0 eqA ltM)),
 Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec b R ->
 (forall a : poly A0 eqA ltM,
  In a P -> Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec a R) ->
 (forall a : poly A0 eqA ltM,
  In a Q -> Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec a R) ->
 forall a : poly A0 eqA ltM,
 In a (genPcPf b P Q) -> Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec a R.
 
Theorem genPcPf_incl :
 forall (a : poly A0 eqA ltM) (aL Q : list (poly A0 eqA ltM)),
 incl Q (genPcPf a aL Q).
Hint Resolve genPcPf_incl.
 
Theorem spolyp_addEnd_genPcPf :
 forall (aP R Q : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM),
 ~ BuchAux.zerop A A0 eqA n ltM a ->

Definition genOCPf : list (poly A0 eqA ltM) -> list (poly A0 eqA ltM).

Theorem genOCPf_stable :
 forall (a : poly A0 eqA ltM) (P : list (poly A0 eqA ltM)),
 In a (genOCPf P) -> Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec a P.
 
Inductive OBuch :
list (poly A0 eqA ltM) ->
list (poly A0 eqA ltM) -> list (poly A0 eqA ltM) -> Prop :=
  | OBuch0 : forall aL : list (poly A0 eqA ltM), OBuch aL nil aL
  | OBuch1 :
      forall (a : poly A0 eqA ltM) (aP Q R : list (poly A0 eqA ltM)),
      OBuch
        (addEnd A A0 eqA n ltM
           (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM
              ltM_dec os a aP) aP)
        (genPcPf
           (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM
              ltM_dec os a aP) aP Q) R ->
      ~
      BuchAux.zerop A A0 eqA n ltM
        (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec
           os a aP) -> OBuch aP (a :: Q) R
  | OBuch2 :
      forall (a : poly A0 eqA ltM) (aP Q R : list (poly A0 eqA ltM)),
      OBuch aP Q R ->
      BuchAux.zerop A A0 eqA n ltM
        (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec
           os a aP) -> OBuch aP (a :: Q) R.
Hint Resolve OBuch0 OBuch2.
Hint Resolve incl_refl incl_tl.
 
Theorem incl_addEnd1 :
 forall (a : poly A0 eqA ltM) (L1 L2 : list (poly A0 eqA ltM)),
 incl (addEnd A A0 eqA n ltM a L1) L2 -> incl (a :: L1) L2.
 
Theorem ObuchPincl :
 forall aP R Q : list (poly A0 eqA ltM), OBuch aP Q R -> incl aP R.
 
Theorem ObuchPred :
 forall aP R Q : list (poly A0 eqA ltM),
 OBuch aP Q R ->
 forall a : poly A0 eqA ltM,
 In a aP -> red A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a R.
 
Theorem ObuchQred :
 forall aP R Q : list (poly A0 eqA ltM),
 OBuch aP Q R ->
 forall a : poly A0 eqA ltM,
 In a Q -> red A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a R.
 
Theorem OBuch_Stable :
 forall P Q R : list (poly A0 eqA ltM),
 OBuch P Q R ->
 (forall a : poly A0 eqA ltM,
  In a Q -> Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec a P) -> 
 stable P R.
 
Inductive redIn :
poly A0 eqA ltM ->
poly A0 eqA ltM ->
list (poly A0 eqA ltM) ->
list (poly A0 eqA ltM) -> list (poly A0 eqA ltM) -> Prop :=
  | redIn0b :
      forall (P Q R : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM),
      redIn b a P Q R -> redIn a b P Q R
  | redIn0 :
      forall (P Q R : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM),
      In
        (spolyp A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM
           ltM_dec os a b) Q -> redIn a b P Q R
  | redIn1 :
      forall (P Q R : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM),
      red A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec
        (spolyp A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM
           ltM_dec os a b) R -> redIn a b P Q R
  | redIn2 :
      forall (P Q R : list (poly A0 eqA ltM)) (a b c : poly A0 eqA ltM),
      In c P ->
      redIn a c P Q R ->
      redIn b c P Q R ->
      divp A A0 eqA multA divA n ltM
        (ppcp A A0 A1 eqA plusA invA minusA multA divA cs n ltM a b) c ->
      redIn a b P Q R.
Hint Resolve redIn1 redIn0.
 
Remark lem_redIn_nil :
 forall (aP Q R : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM),
 In a R -> In b R -> redIn a b aP Q R -> Q = nil -> aP = R -> reds a b R.
 
Theorem redIn_nil :
 forall (R : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM),
 In a R -> In b R -> redIn a b R nil R -> reds a b R.
 
Remark lem_redln_cons :
 forall (aP R Q : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM),
 In a aP ->
 In b aP ->
 redIn a b aP Q R ->
 forall (c : poly A0 eqA ltM) (Q1 : list (poly A0 eqA ltM)),
 Q = c :: Q1 ->
 red A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec c R ->
 redIn a b aP Q1 R.
 
Theorem redln_cons :
 forall (aP R Q : list (poly A0 eqA ltM)) (a b c : poly A0 eqA ltM),
 In a aP ->
 In b aP ->
 redIn a b aP (c :: Q) R ->
 red A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec c R ->
 redIn a b aP Q R.
 
Theorem redInclP :
 forall (P Q R : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM),
 redIn a b P Q R ->
 forall P1 : list (poly A0 eqA ltM), incl P P1 -> redIn a b P1 Q R.
 
Theorem redInInclQ :
 forall (P Q R : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM),
 redIn a b P Q R ->
 forall Q1 : list (poly A0 eqA ltM), incl Q Q1 -> redIn a b P Q1 R.
 
Theorem redInclR :
 forall (P Q R : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM),
 redIn a b P Q R ->
 forall R1 : list (poly A0 eqA ltM), incl R R1 -> redIn a b P Q R1.
 
Remark lem_redln_cons_gen :
 forall (aP R Q : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM),
 In a aP ->
 In b aP ->
 redIn a b aP Q R ->
 forall (c : poly A0 eqA ltM) (Q1 : list (poly A0 eqA ltM)),
 incl
   (addEnd A A0 eqA n ltM
      (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec
         os c aP) aP) R ->
 Q = c :: Q1 ->
 redIn a b
   (addEnd A A0 eqA n ltM
      (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec
         os c aP) aP) Q1 R.
 
Theorem redln_cons_gen :
 forall (aP R Q : list (poly A0 eqA ltM)) (a b c : poly A0 eqA ltM),
 In a aP ->
 In b aP ->
 redIn a b aP (c :: Q) R ->
 incl
   (addEnd A A0 eqA n ltM
      (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec
         os c aP) aP) R ->
 redIn a b
   (addEnd A A0 eqA n ltM
      (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec
         os c aP) aP) Q R.
Hint Resolve redln_cons_gen.
Require Import Relation_Operators.
 
Theorem red_gen_in :
 forall (a : poly A0 eqA ltM) (aP R Q : list (poly A0 eqA ltM)),
 ~
 BuchAux.zerop A A0 eqA n ltM
 
Theorem OBuch_Inv :
 forall aP R Q : list (poly A0 eqA ltM),
 OBuch aP Q R ->
 (forall a b : poly A0 eqA ltM, In a aP -> In b aP -> redIn a b aP Q R) ->
 forall a b : poly A0 eqA ltM, In a R -> In b R -> reds a b R.
 
Theorem addEnd_incl :
 forall (a : poly A0 eqA ltM) (L1 L2 : list (poly A0 eqA ltM)),
 incl (a :: L1) L2 -> incl (addEnd A A0 eqA n ltM a L1) L2.
 
Theorem genOCp_redln :
 forall aL1 R : list (poly A0 eqA ltM),
 incl aL1 R ->
 forall a b : poly A0 eqA ltM,
 In a aL1 -> In b aL1 -> redIn a b aL1 (genOCPf aL1) R.
 
Theorem OBuch_Stable_f :
 forall P Q : list (poly A0 eqA ltM), OBuch P (genOCPf P) Q -> stable P Q.
 
Theorem OBuch_Inv_f :
 forall P Q : list (poly A0 eqA ltM),
 OBuch P (genOCPf P) Q ->
 forall a b : poly A0 eqA ltM, In a Q -> In b Q -> reds a b Q.
Require Import Lexicographic_Product.
 
Let FPset (A : list (poly A0 eqA ltM)) := list (poly A0 eqA ltM).
 
Definition Fl : forall x : list (poly A0 eqA ltM), FPset x -> FPset x -> Prop.
 
Theorem wf_Fl : forall x : list (poly A0 eqA ltM), well_founded (Fl x).
 
Let Co :=
  lexprod (list (poly A0 eqA ltM)) FPset
    (RO A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os)
    Fl.
 
Theorem wf_Co : well_founded Co.
 
Definition PtoS :
  list (poly A0 eqA ltM) * list (poly A0 eqA ltM) -> sigS FPset.
 
Definition RL (x y : list (poly A0 eqA ltM) * list (poly A0 eqA ltM)) :
  Prop := Co (PtoS x) (PtoS y).
 
Theorem wf_RL : well_founded RL.
 
Definition pbuchf :
  forall PQ : list (poly A0 eqA ltM) * list (poly A0 eqA ltM),
  {R : list (poly A0 eqA ltM) | OBuch (fst PQ) (snd PQ) R}.
intros pq; pattern pq in |- *.
apply
 well_founded_induction
  with
    (A := (list (poly A0 eqA ltM) * list (poly A0 eqA ltM))%type)
    (R := RL).
try exact wf_RL.
intros x; elim x.
intros P Q; case Q; simpl in |- *.
intros H'; exists P; auto.
intros a Q2 Rec.
apply
 LetP
  with
    (A := poly A0 eqA ltM)
    (h := nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM
            ltM_dec os a P).
 
Definition strip :
  forall P : list (poly A0 eqA ltM) -> Prop, sig P -> list (poly A0 eqA ltM).
 
Theorem pbuchf_Stable :
 forall P R : list (poly A0 eqA ltM),
 R = strip _ (pbuchf (P, genOCPf P)) -> stable P R.
 
Theorem pbuchf_Inv :
 forall P R : list (poly A0 eqA ltM),
 R = strip _ (pbuchf (P, genOCPf P)) ->
 forall a b : poly A0 eqA ltM, In a R -> In b R -> reds a b R.
 
Definition buch : list (poly A0 eqA ltM) -> list (poly A0 eqA ltM).
 
Theorem buch_Stable : forall P : list (poly A0 eqA ltM), stable P (buch P).
 
Theorem buch_reds :
 forall (P : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM),
 In a (buch P) -> In b (buch P) -> reds a b (buch P).
 
Theorem reds_SpolyQ :
 forall (P : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM),
 reds a b P ->
 Spoly_1 A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec P
   (s2p A A0 eqA n ltM a) (s2p A A0 eqA n ltM b).
 
Theorem imp_in :
 forall (P : list (poly A0 eqA ltM)) (a : list (Term A n)),
 inPolySet A A0 eqA n ltM a P ->
 exists b : poly A0 eqA ltM, In b P /\ a = s2p A A0 eqA n ltM b.
 
Theorem reds_SpolyQ1 :
 forall P : list (poly A0 eqA ltM),
 (forall a b : poly A0 eqA ltM, In a P -> In b P -> reds a b P) ->
 SpolyQ A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec P.
 
Theorem buch_spolyQ :
 forall P : list (poly A0 eqA ltM),
 SpolyQ A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec (buch P).
 
Theorem buch_Grobner :
 forall P : list (poly A0 eqA ltM),
 Grobner A A0 A1 eqA plusA invA minusA multA divA eqA_dec n ltM ltM_dec
   (buch P).
End Buch. *)
Require Export Fred.
(* Fred:
Section Reduce.
Variable poly : Set.
Require Import List.
Variable cb : list poly -> poly -> Prop.
Variable divp : poly -> poly -> Prop.
Variable reduce : list poly -> poly -> poly -> Prop.
Variable nf : list poly -> poly -> poly.
Variable stable : list poly -> list poly -> Prop.
Variable grobner : list poly -> Prop.
Variable zero : poly.
Variable zerop : poly -> Prop.
Variable zerop_dec : forall p : poly, {zerop p} + {~ zerop p}.
Require Import LetP.
Hypothesis cb_id : forall (L : list poly) (p : poly), In p L -> cb L p.
Hypothesis cb_zerop : forall (L : list poly) (p : poly), zerop p -> cb L p.
Hypothesis
  cb_incl :
    forall (L1 L2 : list poly) (p : poly), incl L1 L2 -> cb L1 p -> cb L2 p.
Hypothesis nf_cb : forall (p : poly) (L : list poly), cb (p :: L) (nf L p).
Hypothesis
  cb_trans :
    forall (L : list poly) (p q : poly), cb (p :: L) q -> cb L p -> cb L q.
Hypothesis
  cb_comp :
    forall L1 L2 : list poly,
    (forall p : poly, In p L1 -> cb L2 p) ->
    forall q : poly, cb L1 q -> cb L2 q.
Hypothesis cb_nf : forall (p : poly) (L : list poly), cb (nf L p :: L) p.
Hypothesis
  cb_compo :
    forall (p : poly) (L1 : list poly),
    cb L1 p ->
    forall L2 : list poly, (forall q : poly, In q L1 -> cb L2 q) -> cb L2 p.
Hypothesis
  zerop_elim_cb :
    forall (L : list poly) (p q : poly), zerop p -> cb (p :: L) q -> cb L q.
Hypothesis
  grobner_def :
    forall L : list poly,
    grobner L ->
    forall p : poly, cb L p -> zerop p \/ (exists q : poly, reduce L p q).
Hypothesis
  def_grobner :
    forall L : list poly,
    (forall p : poly, cb L p -> zerop p \/ (exists q : poly, reduce L p q)) ->
    grobner L.
Hypothesis
  nf_div :
    forall (p : poly) (L : list poly),
    ~ zerop p ->
    ~ zerop (nf L p) ->
    exists q : poly, In q (nf L p :: L) /\ divp p q /\ ~ zerop q.
Hypothesis
  div_reduce :
    forall (p : poly) (L1 L2 : list poly),
    (forall r1 : poly,
     In r1 L1 -> ~ zerop r1 -> exists r2 : poly, In r2 L2 /\ divp r1 r2) ->
    forall q : poly, reduce L1 p q -> exists r : poly, reduce L2 p r.
Hypothesis divp_id : forall p : poly, divp p p.
Require Import Relation_Definitions.
Hypothesis divp_trans : transitive poly divp.
Hypothesis
  nf_div_zero :
    forall (p : poly) (L : list poly),
    ~ zerop p ->
    zerop (nf L p) -> exists q : poly, In q L /\ divp p q /\ ~ zerop q.

Theorem zerop_nf_cb :
 forall (L : list poly) (p : poly), zerop (nf L p) -> cb L p.
Hint Resolve zerop_nf_cb.

Definition redacc : list poly -> list poly -> list poly.
intros H'; elim H'.
intros L; exact (nil (A:=poly)).
intros a p Rec Acc.
apply LetP with (A := poly) (h := nf (p ++ Acc) a).

Definition red (L : list poly) : list poly := redacc L nil.
Hint Resolve incl_refl incl_tl incl_appr incl_appl incl_cons incl_app
  in_or_app.

Theorem redacc_cb :
 forall (L1 L2 : list poly) (p : poly),
 In p (redacc L1 L2) -> cb (L1 ++ L2) p.
intros L1; elim L1; auto.
simpl in |- *; auto.
simpl in |- *; unfold LetP in |- *; intros a l H' L2 p.

Theorem red_cb : forall (L : list poly) (p : poly), In p (red L) -> cb L p.

Theorem cb_redacc :
 forall (L1 L2 : list poly) (p : poly), In p L1 -> cb (redacc L1 L2 ++ L2) p.
intros L1; elim L1; simpl in |- *; auto.
intros L2 p H'; elim H'; auto.
unfold LetP in |- *.

Theorem cb_red : forall (L : list poly) (p : poly), In p L -> cb (red L) p.

Theorem cb_red_cb1 :
 forall (p : poly) (L : list poly), cb L p -> cb (red L) p.

Theorem cb_red_cb2 :
 forall (p : poly) (L : list poly), cb (red L) p -> cb L p.
Hypothesis
  nf_div_zero1 :
    forall (p : poly) (L : list poly),
    ~ zerop p ->
    zerop (nf L p) -> ex (fun q : poly => In q L /\ divp p q /\ ~ zerop q).

Theorem redacc_divp :
 forall (L1 L2 : list poly) (p : poly),
 ~ zerop p ->
 In p (L1 ++ L2) ->
 exists q : poly, In q (redacc L1 L2 ++ L2) /\ divp p q /\ ~ zerop q.
intros L1; elim L1; simpl in |- *; auto.
intros L2 p H' H'0; exists p; split; auto.
unfold LetP in |- *.

Theorem red_divp :
 forall (L : list poly) (p : poly),
 In p L ->
 ~ zerop p -> exists q : poly, In q (red L) /\ divp p q /\ ~ zerop q.

Theorem red_grobner : forall L : list poly, grobner L -> grobner (red L).
End Reduce. *)
Require Import Buch.
(* Buch:
Require Export List.
Require Import Inclusion.
Require Import Inverse_Image.
Require Import Wf_nat.
Require Import Relation_Definitions.
Require Import Relation_Operators.
Require Import Relation_Operators_compat.
Require Import Lexicographic_Product.
Require Import LetP.
Require Export WfR0.
Section Buch.
Load "hCoefStructure".
Load "hOrderStructure".
Load "hWfRO".
 
Inductive stable :
list (poly A0 eqA ltM) -> list (poly A0 eqA ltM) -> Prop :=
    stable0 :
      forall P Q : list (poly A0 eqA ltM),
      (forall a : poly A0 eqA ltM,
       Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec a P ->
       Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec a Q) ->
      (forall a : poly A0 eqA ltM,
       Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec a Q ->
       Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec a P) -> 
      stable P Q.
Hint Resolve stable0.
 
Theorem stable_refl : forall Q : list (poly A0 eqA ltM), stable Q Q.
 
Theorem stable_trans :
 forall Q y R : list (poly A0 eqA ltM),
 stable Q y -> stable y R -> stable Q R.
 
Theorem stable_sym :
 forall Q R : list (poly A0 eqA ltM), stable R Q -> stable Q R.
Hint Resolve (Cb_in _ _ _ _ _ _ _ _ _ cs eqA_dec _ _ ltM_dec os).
 
Theorem Cb_stable :
 forall (a : poly A0 eqA ltM) (Q : list (poly A0 eqA ltM)),
 Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec a Q ->
 stable Q (addEnd A A0 eqA n ltM a Q).
 
Theorem in_incl :
 forall (A : Set) (p q : list A) (a b : A), incl p q -> In a p -> In a q.
 
Inductive reds :
poly A0 eqA ltM -> poly A0 eqA ltM -> list (poly A0 eqA ltM) -> Prop :=
  | reds0 :
      forall (P : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM),
      red A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec
        (spolyp A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM
           ltM_dec os a b) P -> reds a b P
  | reds1 :
      forall (P : list (poly A0 eqA ltM)) (a b c : poly A0 eqA ltM),
      In c P ->
      reds a c P ->
      reds c b P ->
      divp A A0 eqA multA divA n ltM
        (ppcp A A0 A1 eqA plusA invA minusA multA divA cs n ltM a b) c ->
      reds a b P.
 
Theorem reds_com :
 forall (P : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM),
 reds a b P -> reds b a P.

Inductive cpRes : Set :=
  | Keep : forall P : list (poly A0 eqA ltM), cpRes
  | DontKeep : forall P : list (poly A0 eqA ltM), cpRes.
 
Definition getRes : cpRes -> list (poly A0 eqA ltM).
 
Definition addRes : poly A0 eqA ltM -> cpRes -> cpRes.
 
Definition slice :
  poly A0 eqA ltM -> poly A0 eqA ltM -> list (poly A0 eqA ltM) -> cpRes.
 
Definition slicef :
  poly A0 eqA ltM ->
  poly A0 eqA ltM -> list (poly A0 eqA ltM) -> list (poly A0 eqA ltM).
 
Theorem slicef_incl :
 forall (a b : poly A0 eqA ltM) (P : list (poly A0 eqA ltM)),
 incl (slicef a b P) P.
 
Theorem slice_inv :
 forall (a b : poly A0 eqA ltM) (P : list (poly A0 eqA ltM))
   (c : poly A0 eqA ltM),
 In c P ->
 In c (getRes (slice a b P)) \/
 divp A A0 eqA multA divA n ltM
   (ppcp A A0 A1 eqA plusA invA minusA multA divA cs n ltM a c) b.
 
Theorem slice_cons :
 forall (i a : poly A0 eqA ltM) (aP Q : list (poly A0 eqA ltM)),
 slice i a aP = DontKeep Q ->
 (exists c : poly A0 eqA ltM,
    In c Q /\
    divp A A0 eqA multA divA n ltM
      (ppcp A A0 A1 eqA plusA invA minusA multA divA cs n ltM i a) c) \/
 foreigner A A0 A1 eqA multA n ltM i a.
 
Definition Tl : list (poly A0 eqA ltM) -> list (poly A0 eqA ltM) -> Prop.
 
Theorem wf_Tl : well_founded Tl.
 
Scheme Sdep := Induction for prod Sort Prop.
Require Import Arith.
 
Theorem slice_Tl :
 forall (a ia : poly A0 eqA ltM) (L : list (poly A0 eqA ltM)),
 Tl (slicef a ia L) (a :: L).
 
Inductive genPcP :
poly A0 eqA ltM ->
list (poly A0 eqA ltM) ->
list (poly A0 eqA ltM) -> list (poly A0 eqA ltM) -> Prop :=
  | genPcP0 :
      forall (i : poly A0 eqA ltM) (L : list (poly A0 eqA ltM)),
      genPcP i nil L L
  | genPcP1 :
      forall (L L1 L2 L3 : list _) (a i : poly A0 eqA ltM),
      slice i a L1 = Keep L2 ->
      genPcP i L2 L L3 ->
      genPcP i (a :: L1) L
        (addEnd A A0 eqA n ltM
           (spolyp A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM
              ltM_dec os i a) L3)
  | genPcP2 :
      forall (L L1 L2 L3 : list _) (a i : poly A0 eqA ltM),
      slice i a L1 = DontKeep L2 ->
      genPcP i L2 L L3 -> genPcP i (a :: L1) L L3.
Hint Resolve genPcP0.
 
Theorem genPcP_spolyp1 :
 forall (i : poly A0 eqA ltM) (L L1 L2 : list _),
 genPcP i L1 L L2 ->
 forall a : poly A0 eqA ltM,
 In a L2 ->
 (exists b : poly A0 eqA ltM,
    In b L1 /\
    a =
    spolyp A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec
      os i b) \/ In a L.
Hint Resolve (addEnd_id2 A A0 eqA n ltM).
Hint Resolve (addEnd_id1 A A0 eqA n ltM).
 
Theorem genPcP_incl :
 forall (i : poly A0 eqA ltM) (L L1 L2 : list _),
 genPcP i L1 L L2 -> incl L L2.
 
Lemma spolyp_cons_genPcP0 :
 forall (aP R Q : list _) (i : poly A0 eqA ltM),
 genPcP i aP R Q ->
 ~ BuchAux.zerop A A0 eqA n ltM i ->
 
Lemma spolyp_cons_genPcP :
 forall (aP R Q : list _) (i : poly A0 eqA ltM),
 genPcP i aP R Q ->
 ~ BuchAux.zerop A A0 eqA n ltM i ->
 
Theorem Cb_genPcP :
 forall (i : poly A0 eqA ltM) (P Q R S : list (poly A0 eqA ltM)),
 genPcP i P R Q ->
 Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec i S ->
 (forall a : poly A0 eqA ltM,
  In a P -> Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec a S) ->
 (forall a : poly A0 eqA ltM,
  In a R -> Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec a S) ->
 forall a : poly A0 eqA ltM,
 In a Q -> Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec a S.
 
Definition genPcPf0 :
  forall (i : poly A0 eqA ltM) (aP R : list (poly A0 eqA ltM)),
  {Q : list (poly A0 eqA ltM) | genPcP i aP R Q}.
 
Definition genPcPf :
  poly A0 eqA ltM ->
  list (poly A0 eqA ltM) -> list (poly A0 eqA ltM) -> list (poly A0 eqA ltM).

Theorem Cb_genPcPf :
 forall (b : poly A0 eqA ltM) (P Q R : list (poly A0 eqA ltM)),
 Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec b R ->
 (forall a : poly A0 eqA ltM,
  In a P -> Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec a R) ->
 (forall a : poly A0 eqA ltM,
  In a Q -> Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec a R) ->
 forall a : poly A0 eqA ltM,
 In a (genPcPf b P Q) -> Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec a R.
 
Theorem genPcPf_incl :
 forall (a : poly A0 eqA ltM) (aL Q : list (poly A0 eqA ltM)),
 incl Q (genPcPf a aL Q).
Hint Resolve genPcPf_incl.
 
Theorem spolyp_addEnd_genPcPf :
 forall (aP R Q : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM),
 ~ BuchAux.zerop A A0 eqA n ltM a ->

Definition genOCPf : list (poly A0 eqA ltM) -> list (poly A0 eqA ltM).

Theorem genOCPf_stable :
 forall (a : poly A0 eqA ltM) (P : list (poly A0 eqA ltM)),
 In a (genOCPf P) -> Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec a P.
 
Inductive OBuch :
list (poly A0 eqA ltM) ->
list (poly A0 eqA ltM) -> list (poly A0 eqA ltM) -> Prop :=
  | OBuch0 : forall aL : list (poly A0 eqA ltM), OBuch aL nil aL
  | OBuch1 :
      forall (a : poly A0 eqA ltM) (aP Q R : list (poly A0 eqA ltM)),
      OBuch
        (addEnd A A0 eqA n ltM
           (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM
              ltM_dec os a aP) aP)
        (genPcPf
           (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM
              ltM_dec os a aP) aP Q) R ->
      ~
      BuchAux.zerop A A0 eqA n ltM
        (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec
           os a aP) -> OBuch aP (a :: Q) R
  | OBuch2 :
      forall (a : poly A0 eqA ltM) (aP Q R : list (poly A0 eqA ltM)),
      OBuch aP Q R ->
      BuchAux.zerop A A0 eqA n ltM
        (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec
           os a aP) -> OBuch aP (a :: Q) R.
Hint Resolve OBuch0 OBuch2.
Hint Resolve incl_refl incl_tl.
 
Theorem incl_addEnd1 :
 forall (a : poly A0 eqA ltM) (L1 L2 : list (poly A0 eqA ltM)),
 incl (addEnd A A0 eqA n ltM a L1) L2 -> incl (a :: L1) L2.
 
Theorem ObuchPincl :
 forall aP R Q : list (poly A0 eqA ltM), OBuch aP Q R -> incl aP R.
 
Theorem ObuchPred :
 forall aP R Q : list (poly A0 eqA ltM),
 OBuch aP Q R ->
 forall a : poly A0 eqA ltM,
 In a aP -> red A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a R.
 
Theorem ObuchQred :
 forall aP R Q : list (poly A0 eqA ltM),
 OBuch aP Q R ->
 forall a : poly A0 eqA ltM,
 In a Q -> red A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a R.
 
Theorem OBuch_Stable :
 forall P Q R : list (poly A0 eqA ltM),
 OBuch P Q R ->
 (forall a : poly A0 eqA ltM,
  In a Q -> Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec a P) -> 
 stable P R.
 
Inductive redIn :
poly A0 eqA ltM ->
poly A0 eqA ltM ->
list (poly A0 eqA ltM) ->
list (poly A0 eqA ltM) -> list (poly A0 eqA ltM) -> Prop :=
  | redIn0b :
      forall (P Q R : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM),
      redIn b a P Q R -> redIn a b P Q R
  | redIn0 :
      forall (P Q R : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM),
      In
        (spolyp A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM
           ltM_dec os a b) Q -> redIn a b P Q R
  | redIn1 :
      forall (P Q R : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM),
      red A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec
        (spolyp A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM
           ltM_dec os a b) R -> redIn a b P Q R
  | redIn2 :
      forall (P Q R : list (poly A0 eqA ltM)) (a b c : poly A0 eqA ltM),
      In c P ->
      redIn a c P Q R ->
      redIn b c P Q R ->
      divp A A0 eqA multA divA n ltM
        (ppcp A A0 A1 eqA plusA invA minusA multA divA cs n ltM a b) c ->
      redIn a b P Q R.
Hint Resolve redIn1 redIn0.
 
Remark lem_redIn_nil :
 forall (aP Q R : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM),
 In a R -> In b R -> redIn a b aP Q R -> Q = nil -> aP = R -> reds a b R.
 
Theorem redIn_nil :
 forall (R : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM),
 In a R -> In b R -> redIn a b R nil R -> reds a b R.
 
Remark lem_redln_cons :
 forall (aP R Q : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM),
 In a aP ->
 In b aP ->
 redIn a b aP Q R ->
 forall (c : poly A0 eqA ltM) (Q1 : list (poly A0 eqA ltM)),
 Q = c :: Q1 ->
 red A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec c R ->
 redIn a b aP Q1 R.
 
Theorem redln_cons :
 forall (aP R Q : list (poly A0 eqA ltM)) (a b c : poly A0 eqA ltM),
 In a aP ->
 In b aP ->
 redIn a b aP (c :: Q) R ->
 red A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec c R ->
 redIn a b aP Q R.
 
Theorem redInclP :
 forall (P Q R : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM),
 redIn a b P Q R ->
 forall P1 : list (poly A0 eqA ltM), incl P P1 -> redIn a b P1 Q R.
 
Theorem redInInclQ :
 forall (P Q R : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM),
 redIn a b P Q R ->
 forall Q1 : list (poly A0 eqA ltM), incl Q Q1 -> redIn a b P Q1 R.
 
Theorem redInclR :
 forall (P Q R : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM),
 redIn a b P Q R ->
 forall R1 : list (poly A0 eqA ltM), incl R R1 -> redIn a b P Q R1.
 
Remark lem_redln_cons_gen :
 forall (aP R Q : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM),
 In a aP ->
 In b aP ->
 redIn a b aP Q R ->
 forall (c : poly A0 eqA ltM) (Q1 : list (poly A0 eqA ltM)),
 incl
   (addEnd A A0 eqA n ltM
      (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec
         os c aP) aP) R ->
 Q = c :: Q1 ->
 redIn a b
   (addEnd A A0 eqA n ltM
      (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec
         os c aP) aP) Q1 R.
 
Theorem redln_cons_gen :
 forall (aP R Q : list (poly A0 eqA ltM)) (a b c : poly A0 eqA ltM),
 In a aP ->
 In b aP ->
 redIn a b aP (c :: Q) R ->
 incl
   (addEnd A A0 eqA n ltM
      (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec
         os c aP) aP) R ->
 redIn a b
   (addEnd A A0 eqA n ltM
      (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec
         os c aP) aP) Q R.
Hint Resolve redln_cons_gen.
Require Import Relation_Operators.
 
Theorem red_gen_in :
 forall (a : poly A0 eqA ltM) (aP R Q : list (poly A0 eqA ltM)),
 ~
 BuchAux.zerop A A0 eqA n ltM
 
Theorem OBuch_Inv :
 forall aP R Q : list (poly A0 eqA ltM),
 OBuch aP Q R ->
 (forall a b : poly A0 eqA ltM, In a aP -> In b aP -> redIn a b aP Q R) ->
 forall a b : poly A0 eqA ltM, In a R -> In b R -> reds a b R.
 
Theorem addEnd_incl :
 forall (a : poly A0 eqA ltM) (L1 L2 : list (poly A0 eqA ltM)),
 incl (a :: L1) L2 -> incl (addEnd A A0 eqA n ltM a L1) L2.
 
Theorem genOCp_redln :
 forall aL1 R : list (poly A0 eqA ltM),
 incl aL1 R ->
 forall a b : poly A0 eqA ltM,
 In a aL1 -> In b aL1 -> redIn a b aL1 (genOCPf aL1) R.
 
Theorem OBuch_Stable_f :
 forall P Q : list (poly A0 eqA ltM), OBuch P (genOCPf P) Q -> stable P Q.
 
Theorem OBuch_Inv_f :
 forall P Q : list (poly A0 eqA ltM),
 OBuch P (genOCPf P) Q ->
 forall a b : poly A0 eqA ltM, In a Q -> In b Q -> reds a b Q.
Require Import Lexicographic_Product.
 
Let FPset (A : list (poly A0 eqA ltM)) := list (poly A0 eqA ltM).
 
Definition Fl : forall x : list (poly A0 eqA ltM), FPset x -> FPset x -> Prop.
 
Theorem wf_Fl : forall x : list (poly A0 eqA ltM), well_founded (Fl x).
 
Let Co :=
  lexprod (list (poly A0 eqA ltM)) FPset
    (RO A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os)
    Fl.
 
Theorem wf_Co : well_founded Co.
 
Definition PtoS :
  list (poly A0 eqA ltM) * list (poly A0 eqA ltM) -> sigS FPset.
 
Definition RL (x y : list (poly A0 eqA ltM) * list (poly A0 eqA ltM)) :
  Prop := Co (PtoS x) (PtoS y).
 
Theorem wf_RL : well_founded RL.
 
Definition pbuchf :
  forall PQ : list (poly A0 eqA ltM) * list (poly A0 eqA ltM),
  {R : list (poly A0 eqA ltM) | OBuch (fst PQ) (snd PQ) R}.
intros pq; pattern pq in |- *.
apply
 well_founded_induction
  with
    (A := (list (poly A0 eqA ltM) * list (poly A0 eqA ltM))%type)
    (R := RL).
try exact wf_RL.
intros x; elim x.
intros P Q; case Q; simpl in |- *.
intros H'; exists P; auto.
intros a Q2 Rec.
apply
 LetP
  with
    (A := poly A0 eqA ltM)
    (h := nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM
            ltM_dec os a P).
 
Definition strip :
  forall P : list (poly A0 eqA ltM) -> Prop, sig P -> list (poly A0 eqA ltM).
 
Theorem pbuchf_Stable :
 forall P R : list (poly A0 eqA ltM),
 R = strip _ (pbuchf (P, genOCPf P)) -> stable P R.
 
Theorem pbuchf_Inv :
 forall P R : list (poly A0 eqA ltM),
 R = strip _ (pbuchf (P, genOCPf P)) ->
 forall a b : poly A0 eqA ltM, In a R -> In b R -> reds a b R.
 
Definition buch : list (poly A0 eqA ltM) -> list (poly A0 eqA ltM).
 
Theorem buch_Stable : forall P : list (poly A0 eqA ltM), stable P (buch P).
 
Theorem buch_reds :
 forall (P : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM),
 In a (buch P) -> In b (buch P) -> reds a b (buch P).
 
Theorem reds_SpolyQ :
 forall (P : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM),
 reds a b P ->
 Spoly_1 A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec P
   (s2p A A0 eqA n ltM a) (s2p A A0 eqA n ltM b).
 
Theorem imp_in :
 forall (P : list (poly A0 eqA ltM)) (a : list (Term A n)),
 inPolySet A A0 eqA n ltM a P ->
 exists b : poly A0 eqA ltM, In b P /\ a = s2p A A0 eqA n ltM b.
 
Theorem reds_SpolyQ1 :
 forall P : list (poly A0 eqA ltM),
 (forall a b : poly A0 eqA ltM, In a P -> In b P -> reds a b P) ->
 SpolyQ A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec P.
 
Theorem buch_spolyQ :
 forall P : list (poly A0 eqA ltM),
 SpolyQ A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec (buch P).
 
Theorem buch_Grobner :
 forall P : list (poly A0 eqA ltM),
 Grobner A A0 A1 eqA plusA invA minusA multA divA eqA_dec n ltM ltM_dec
   (buch P).
End Buch. *)

Local Unset Injection On Proofs.

Section BuchRed.
Load "hCoefStructure".
Load "hOrderStructure".
Load "hBuch".
 
Theorem Cb_addEnd_cons :
 forall (L : list (poly A0 eqA ltM)) (p q : poly A0 eqA ltM),
 Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec q (addEnd A A0 eqA n ltM p L) ->
 Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec q (p :: L).
intros L p q H; apply Cb_incl with (1 := cs) (P := addEnd A A0 eqA n ltM p L);
 auto.
elim L; simpl in |- *; auto.
intros a l H0 a0 H1; elim H1; clear H1; intros H1; auto.
case (H0 a0); auto.
Qed.
 
Theorem Cb_cons_addEnd :
 forall (L : list (poly A0 eqA ltM)) (p q : poly A0 eqA ltM),
 Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec q (p :: L) ->
 Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec q (addEnd A A0 eqA n ltM p L).
intros L p q H; apply Cb_incl with (1 := cs) (P := p :: L); auto.
elim L; simpl in |- *; auto.
intros a l H0 a0 H1; elim H1; clear H1; intros H1; auto.
case H1; auto.
Qed.
 
Theorem Cb_trans_cons :
 forall (L : list (poly A0 eqA ltM)) (p q : poly A0 eqA ltM),
 Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec q (p :: L) ->
 Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec p L ->
 Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec q L.
intros L p q H H0.
apply Cb_trans with (1 := cs) (b := p); auto.
apply Cb_cons_addEnd; auto.
Qed.
 
Theorem Cb_cons :
 forall (p : poly A0 eqA ltM) (L : list (poly A0 eqA ltM)),
 Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec
   (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os p
      L) (p :: L).
intros p L; unfold nf, LetP in |- *; auto.
case
 (Reducef A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec
    os L p); simpl in |- *; auto.
intros x0; case x0; simpl in |- *.
intros x c H'.
change
  (CombLinear A A0 eqA plusA multA eqA_dec n ltM ltM_dec 
     (p :: L)
     (mults (A:=A) multA (n:=n)
        (unit A A0 A1 eqA divA n ltM (mks A A0 eqA n ltM x c)) x)) 
 in |- *.
apply CombLinear_mults1 with (1 := cs); auto.
apply unit_nZ with (1 := cs); auto.
apply reducestar_cb1 with (1 := cs); auto.
Qed.
 
Theorem Cb_comp :
 forall L1 L2 : list (poly A0 eqA ltM),
 (forall p : poly A0 eqA ltM,
  In p L1 -> Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec p L2) ->
 forall q : poly A0 eqA ltM,
 Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec q L1 ->
 Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec q L2.
intros L1 L2 H' q; case q; simpl in |- *.
intros x H'0 H'1.
apply CombLinear_compo with (1 := cs) (L1 := L1); auto.
intros q0 H'2.
case inPolySet_inv1 with (1 := H'2); auto.
intros q1 H; elim H; intros H0 H1; clear H.
lapply (H' q1); [ intros H'6 | idtac ]; auto.
generalize H'6 H1; case q1; simpl in |- *; auto.
intros x0 H'5 H'7 H'8; rewrite H'8; auto.
Defined.
 
Theorem Cb_nf :
 forall (p : poly A0 eqA ltM) (L : list (poly A0 eqA ltM)),
 Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec p
   (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os p
      L :: L).
intros p L; unfold nf in |- *.
case
 (Reducef A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec
    os L p); auto.
case p.
unfold LetP in |- *; intros x H' x0; case x0; simpl in |- *.
intros x1 c H'0.
change
  (CombLinear A A0 eqA plusA multA eqA_dec n ltM ltM_dec
     (mks A A0 eqA n ltM
        (mults (A:=A) multA (n:=n)
           (unit A A0 A1 eqA divA n ltM (mks A A0 eqA n ltM x1 c)) x1)
        (canonical_mults A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec
           n ltM os (unit A A0 A1 eqA divA n ltM (mks A A0 eqA n ltM x1 c))
           x1
           (unit_nZ A A0 A1 eqA plusA invA minusA multA divA cs n ltM
              (mks A A0 eqA n ltM x1 c)) c) :: L) x) 
 in |- *.
apply CombLinear_compo with (1 := cs) (L1 := mks A A0 eqA n ltM x1 c :: L);
 auto.
change
  (CombLinear A A0 eqA plusA multA eqA_dec n ltM ltM_dec
     (mks A A0 eqA n ltM x1 c :: L)
     (s2p A A0 eqA n ltM (mks A A0 eqA n ltM x H'))) 
 in |- *.
apply reducestar_cb2 with (1 := cs); auto.
intros q H'1; inversion H'1; auto.
2: apply CombLinear_id with (1 := cs); auto.
2: apply inskip; auto.
generalize c H2; case x1; auto.
intros c0 H'2; inversion H'2.
intros a0 l c0 H'2.
cut
 (~
  zeroP (A:=A) A0 eqA (n:=n)
    (unit A A0 A1 eqA divA n ltM (mks A A0 eqA n ltM (a0 :: l) c0)));
 [ intros nZu | idtac ]; auto.
apply
 CombLinear_1
  with
    (a := divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) 
            (T1 A1 n)
            (b:=unit A A0 A1 eqA divA n ltM (mks A A0 eqA n ltM (pX a0 l) c0))
            nZu)
    (p := pO A n)
    (q := mults (A:=A) multA (n:=n)
            (unit A A0 A1 eqA divA n ltM (mks A A0 eqA n ltM (pX a0 l) c0))
            (pX a0 l)); auto.
simpl in |- *; auto.
change
  (inPolySet A A0 eqA n ltM
     (pX
        (multTerm (A:=A) multA (n:=n)
           (unit A A0 A1 eqA divA n ltM (mks A A0 eqA n ltM (pX a0 l) c0)) a0)
        (mults (A:=A) multA (n:=n)
           (unit A A0 A1 eqA divA n ltM (mks A A0 eqA n ltM (pX a0 l) c0)) l))
     (exist (fun a1 => canonical A0 eqA ltM a1)
        (pX
           (multTerm (A:=A) multA (n:=n)
              (unit A A0 A1 eqA divA n ltM (mks A A0 eqA n ltM (a0 :: l) c0))
              a0)
           (mults (A:=A) multA (n:=n)
              (unit A A0 A1 eqA divA n ltM (mks A A0 eqA n ltM (a0 :: l) c0))
              l))
        (canonical_mults A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec
           n ltM os
           (unit A A0 A1 eqA divA n ltM (mks A A0 eqA n ltM (pX a0 l) c0))
           (pX a0 l)
           (unit_nZ _ _ _ _ _ _ _ _ _ cs _ ltM
              (mks A A0 eqA n ltM (pX a0 l) c0)) c0) :: L)) 
 in |- *.
apply incons; auto.
apply CombLinear_0; auto.
apply
 (eqp_trans _ _ _ _ _ _ _ _ _ cs n)
  with
    (y := mults (A:=A) multA (n:=n)
            (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) 
               (T1 A1 n)
               (b:=unit A A0 A1 eqA divA n ltM
                     (mks A A0 eqA n ltM (a0 :: l) c0)) nZu)
            (mults (A:=A) multA (n:=n)
               (unit A A0 A1 eqA divA n ltM (mks A A0 eqA n ltM (a0 :: l) c0))
               (a0 :: l))); auto.
2: apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); auto.
apply
 (eqp_trans _ _ _ _ _ _ _ _ _ cs n)
  with
    (y := mults (A:=A) multA (n:=n)
            (multTerm (A:=A) multA (n:=n)
               (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) 
                  (T1 A1 n)
                  (b:=unit A A0 A1 eqA divA n ltM
                        (mks A A0 eqA n ltM (a0 :: l) c0)) nZu)
               (unit A A0 A1 eqA divA n ltM (mks A A0 eqA n ltM (a0 :: l) c0)))
            (a0 :: l)); auto.
apply
 (eqp_trans _ _ _ _ _ _ _ _ _ cs n)
  with (y := mults (A:=A) multA (n:=n) (T1 A1 n) (a0 :: l)); 
 auto.
rewrite H'2; auto.
apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); auto.
apply mults_comp with (1 := cs); auto.
apply divTerm_on_eqT with (1 := cs); auto.
apply (eqT_sym A n); auto.
apply unit_T1; auto.
apply unit_nZ with (1 := cs); auto.
Qed.
 
Theorem zerop_elim_Cb :
 forall (L : list (poly A0 eqA ltM)) (p q : poly A0 eqA ltM),
 zerop A A0 eqA n ltM p ->
 Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec q (p :: L) ->
 Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec q L.
intros L p q H' H'0.
apply Cb_comp with (L1 := p :: L); auto.
simpl in |- *; auto.
intros p0 H'1; case H'1;
 [ intros H'2; rewrite <- H'2; clear H'1 | intros H'2; clear H'1 ]; 
 auto.
generalize H'; case p; simpl in |- *; auto.
intros x; case x; simpl in |- *; auto.
intros H'1 H'3; try assumption.
change (CombLinear A A0 eqA plusA multA eqA_dec n ltM ltM_dec L (pO A n))
 in |- *.
apply CombLinear_0; auto.
intros a l H'1 H'3; elim H'3; auto.
apply Cb_id with (1 := cs); auto.
Qed.
 
Theorem Cb_compo :
 forall (p : poly A0 eqA ltM) (L1 : list (poly A0 eqA ltM)),
 Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec p L1 ->
 forall L2 : list (poly A0 eqA ltM),
 (forall q : poly A0 eqA ltM,
  In q L1 -> Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec q L2) ->
 Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec p L2.
intros p L1 H' L2 H'0.
apply Cb_comp with (L1 := L1); auto.
Qed.
 
Definition reducep (L : list (poly A0 eqA ltM)) (p q : poly A0 eqA ltM) :
  Prop :=
  reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec L
    (s2p A A0 eqA n ltM p) (s2p A A0 eqA n ltM q).
 
Theorem grobner_def :
 forall L : list (poly A0 eqA ltM),
 Grobner A A0 A1 eqA plusA invA minusA multA divA eqA_dec n ltM ltM_dec L ->
 forall p : poly A0 eqA ltM,
 Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec p L ->
 zerop A A0 eqA n ltM p \/ (exists q : poly A0 eqA ltM, reducep L p q).
intros L H'; inversion H'; auto.
intros p H'0.
case
 (Reducef A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec
    os L p).
intros x H'1; inversion H'.
lapply (H0 (s2p A A0 eqA n ltM p) (s2p A A0 eqA n ltM x));
 [ intros H'4; lapply H'4; [ clear H'4 | clear H'4 ] | idtac ]; 
 auto.
inversion H'1; auto.
inversion H1; auto.
intros H'2; left.
cut (eqP A eqA n (s2p A A0 eqA n ltM p) (pO A n)); auto.
case p; simpl in |- *; auto.
intros x1; case x1; auto.
intros a l H'3 H'4; inversion H'4.
apply (eqp_trans _ _ _ _ _ _ _ _ _ cs n) with (y := s2p A A0 eqA n ltM x);
 auto.
intros H'2; right; cut (canonical A0 eqA ltM y); auto.
intros H'3; exists (mks A A0 eqA n ltM y H'3); generalize H5; case p;
 simpl in |- *; auto.
apply canonical_reduce with (1 := cs) (3 := H5); auto.
generalize H'0; case p; simpl in |- *; auto.
generalize H'0; case p; simpl in |- *; auto.
Qed.
 
Theorem def_grobner :
 forall L : list (poly A0 eqA ltM),
 (forall p : poly A0 eqA ltM,
  Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec p L ->
  zerop A A0 eqA n ltM p \/ (exists q : poly A0 eqA ltM, reducep L p q)) ->
 Grobner A A0 A1 eqA plusA invA minusA multA divA eqA_dec n ltM ltM_dec L.
intros L H'.
apply Grobner0.
intros p q H'0 H'1.
cut (canonical A0 eqA ltM p).
intros H'2.
cut (canonical A0 eqA ltM q).
intros H'3.
elim (H' (mks A A0 eqA n ltM q H'3)); [ intros H'6 | intros H'6 | idtac ];
 auto.
generalize H'3 H'6; case q; simpl in |- *; auto.
intros a l H'4 H'5; elim H'5; auto.
case H'6; intros q0 E; clear H'6.
inversion H'1.
generalize H0 E; case q0; auto.
simpl in |- *; auto.
intros x H'4 H'5 H'6;
 absurd
  (reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec L q x);
 auto.
simpl in |- *; auto.
apply reducestar_cb with (a := p) (1 := cs); auto.
inversion H'1.
apply canonical_reduceplus with (1 := cs) (3 := H); auto.
apply CombLinear_canonical with (1 := cs) (3 := H'0); auto.
Qed.
 
Theorem reduce_divp :
 forall (p q : poly A0 eqA ltM) (Q : list (poly A0 eqA ltM)),
 reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q
   (s2p A A0 eqA n ltM p) (s2p A A0 eqA n ltM q) ->
 exists r : poly A0 eqA ltM,
   In r (q :: Q) /\
   divp A A0 eqA multA divA n ltM p r /\ ~ zerop A A0 eqA n ltM r.
intros p q; case p; case q; simpl in |- *.
intros x H' x0 c Q H'0; inversion H'0.
generalize c; rewrite <- H2; simpl in |- *; auto.
case inPolySet_inv1 with (1 := H); auto.
intros q1 E; case E; intros H'1 H'2; clear E.
intros c0; exists q1; split; [ right | split ]; auto.
generalize H'2; case q1; simpl in |- *; auto.
intros x1; case x1; auto.
intros H'4 H'5; discriminate H'5; auto.
intros a0 l H'4 H'5; injection H'5; intros.
rewrite <- H5; trivial.
generalize H'1 H'2 c0; case q1; simpl in |- *; auto.
intros x1; case x1; auto.
intros c1 H'3 H'4; discriminate H'4.
exists (exist (fun l : list (Term A n) => canonical A0 eqA ltM l) x H');
 split; [ left | split ]; simpl in |- *; auto.
generalize c; rewrite <- H1; unfold pX in |- *; auto.
generalize H'; rewrite <- H2; unfold pX in |- *; auto.
intros H'1 H'2.
apply divP_eqTerm_comp with (a := b) (1 := cs); auto.
cut (~ zeroP (A:=A) A0 eqA (n:=n) b); [ intros Z | idtac ]; auto.
apply divTerm_def with (nZb := Z); auto.
apply canonical_nzeroP with (ltM := ltM) (p := q0); auto.
apply (eqTerm_sym _ _ _ _ _ _ _ _ _ cs n); auto.
generalize c H'; rewrite <- H2; auto.
Qed.
 
Theorem reduceplus_divp_lem :
 forall (a b : list (Term A n)) (Q : list (poly A0 eqA ltM)),
 reduceplus A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q a b ->
 canonical A0 eqA ltM a ->
 forall x y : poly A0 eqA ltM,
 s2p A A0 eqA n ltM x = a ->
 s2p A A0 eqA n ltM y = b ->
 ~ zerop A A0 eqA n ltM x ->
 exists r : poly A0 eqA ltM,
   In r (y :: Q) /\
   divp A A0 eqA multA divA n ltM x r /\ ~ zerop A A0 eqA n ltM r.
intros a b Q H'; elim H'; auto.
intros x y H'0 H'1 x0 y0 H'2 H'3 H'4; exists y0; split; [ idtac | split ];
 auto with datatypes.
generalize H'0 H'4; clear H'0 H'4; rewrite <- H'3; rewrite <- H'2; case x0;
 case y0; simpl in |- *; auto.
intros x1; case x1; simpl in |- *; auto.
intros H2 x2; case x2; auto.
intros t l H'5 H'6; inversion_clear H'6; auto.
intros t l H'0 x2; case x2; simpl in |- *; auto.
intros t0 l0 H'5 H'6; inversion_clear H'6; auto.
intros H5; apply divP_eqTerm_comp with (a := t) (1 := cs); auto.
cut (~ zeroP (A:=A) A0 eqA (n:=n) t); [ intros Z | idtac ]; auto.
apply divTerm_def with (nZb := Z); auto.
apply canonical_nzeroP with (ltM := ltM) (p := l); auto.
apply (eqTerm_sym _ _ _ _ _ _ _ _ _ cs n); auto.
generalize H'0 H'4; clear H'0 H'4; rewrite <- H'3; rewrite <- H'2; case x0;
 case y0; simpl in |- *; auto.
intros x1; case x1; simpl in |- *; auto.
intros H'0 x2; case x2; simpl in |- *; auto.
intros t l H'4 H'5; inversion_clear H'5.
intros x y z H'0 H'1 H'2 H'3 x0 y0 H'4 H'5 H'6.
cut (canonical A0 eqA ltM y); [ intros Z | idtac ].
2: apply canonical_reduce with (1 := cs) (3 := H'0); auto.
lapply (reduce_divp x0 (mks A A0 eqA n ltM y Z) Q); [ intros H'9 | idtac ];
 auto.
2: rewrite H'4; simpl in |- *; auto.
case H'9; intros r E; case E; simpl in |- *; intros H'7 H'8; case H'8;
 intros H'10 H'11; clear H'8 E H'9.
case H'7; [ intros H'8; clear H'7 | intros H'8; clear H'7 ].
2: exists r; split; [ right | idtac ]; auto.
lapply H'2;
 [ intros H'7; lapply (H'7 (mks A A0 eqA n ltM y Z) y0); simpl in |- *;
    [ intros H'13; lapply H'13;
       [ intros H'14; lapply H'14;
          [ intros H'15; clear H'14 H'13 H'2 | clear H'14 H'13 H'2 ]
       | clear H'13 H'2 ]
    | clear H'2 ]
 | clear H'2 ]; auto.
case H'15; intros r0 E; case E; intros H'2 H'9; case H'9; intros H'12 H'13;
 clear H'9 E H'15.
exists r0; split; [ idtac | split ]; auto.
apply (divp_trans _ _ _ _ _ _ _ _ _ cs n ltM) with (y := r); auto.
rewrite <- H'8; auto.
generalize H'11; rewrite <- H'8.
generalize Z; case y; auto.
Qed.
 
Theorem reduceplus_divp :
 forall (a b : poly A0 eqA ltM) (Q : list (poly A0 eqA ltM)),
 reduceplus A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q
   (s2p A A0 eqA n ltM a) (s2p A A0 eqA n ltM b) ->
 ~ zerop A A0 eqA n ltM a ->
 exists r : poly A0 eqA ltM,
   In r (b :: Q) /\
   divp A A0 eqA multA divA n ltM a r /\ ~ zerop A A0 eqA n ltM r.
intros a b Q H' H'0.
apply
 reduceplus_divp_lem
  with (a := s2p A A0 eqA n ltM a) (b := s2p A A0 eqA n ltM b); 
 auto.
apply canonical_s2p; auto.
Qed.
 
Theorem reducestar_divp :
 forall (a b : poly A0 eqA ltM) (Q : list (poly A0 eqA ltM)),
 reducestar A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q
   (s2p A A0 eqA n ltM a) (s2p A A0 eqA n ltM b) ->
 ~ zerop A A0 eqA n ltM a ->
 exists r : poly A0 eqA ltM,
   In r (b :: Q) /\
   divp A A0 eqA multA divA n ltM a r /\ ~ zerop A A0 eqA n ltM r.
intros a b Q H' H'0; apply reduceplus_divp; auto.
inversion H'; auto.
Qed.
 
Theorem nf_divp :
 forall (p : poly A0 eqA ltM) (L : list (poly A0 eqA ltM)),
 ~ zerop A A0 eqA n ltM p ->
 ~
 zerop A A0 eqA n ltM
   (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os p
      L) ->
 exists q : poly A0 eqA ltM,
   In q
     (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os
        p L :: L) /\
   divp A A0 eqA multA divA n ltM p q /\ ~ zerop A A0 eqA n ltM q.
intros p L; case p; unfold nf in |- *; auto.
unfold nf in |- *; auto.
intros x c;
 case
  (Reducef A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec
     os L (exist (fun l => canonical A0 eqA ltM l) x c)).
unfold LetP in |- *.
intros x0; case x0; auto.
intros x1 c0 H' H'0 H'1.
lapply
 (reducestar_divp (mks A A0 eqA n ltM x c) (mks A A0 eqA n ltM x1 c0) L);
 [ intros H'5; lapply H'5; [ intros H'6; clear H'5 | clear H'5 ] | idtac ];
 auto.
case H'6; intros r E; case E; intros H'2 H'3; case H'3; intros H'4 H'5;
 clear H'3 E H'6.
case H'2; [ intros H'3; clear H'2 | intros H'3; clear H'2 ].
exists
 (mks A A0 eqA n ltM
    (mults (A:=A) multA (n:=n)
       (unit A A0 A1 eqA divA n ltM (mks A A0 eqA n ltM x1 c0)) x1)
    (canonical_mults _ _ _ _ _ _ _ _ _ cs eqA_dec _ _ os
       (unit A A0 A1 eqA divA n ltM (mks A A0 eqA n ltM x1 c0)) x1
       (unit_nZ _ _ _ _ _ _ _ _ _ cs n ltM (mks A A0 eqA n ltM x1 c0)) c0));
 split; [ idtac | split ]; auto.
simpl in |- *; auto.
apply (divp_trans _ _ _ _ _ _ _ _ _ cs n ltM) with (y := r); auto.
generalize H'5; rewrite <- H'3.
generalize c0; case x1; auto.
simpl in |- *; auto.
intros a l c1 H1.
cut (~ zeroP (A:=A) A0 eqA (n:=n) a);
 [ intros nZa | apply canonical_nzeroP with (ltM := ltM) (p := l) ]; 
 auto.
cut
 (~
  zeroP (A:=A) A0 eqA (n:=n)
    (multTerm (A:=A) multA (n:=n)
       (unit A A0 A1 eqA divA n ltM (mks A A0 eqA n ltM (pX a l) c1)) a));
 [ intros nZu | idtac ]; auto.
simpl in |- *; apply divTerm_def with (nZb := nZu); auto.
apply divTerm_on_eqT with (1 := cs) (a := a); auto.
apply (eqT_trans A n) with (y := multTerm (A:=A) multA (n:=n) (T1 A1 n) a);
 auto.
apply (eqTerm_imp_eqT A eqA n); auto.
apply multTerm_eqT; auto.
apply (eqT_sym A n); auto.
apply unit_T1; auto.
apply nzeroP_multTerm with (1 := cs); auto.
apply unit_nZ with (1 := cs); auto.
exists r; split; [ idtac | split ]; auto.
simpl in |- *; auto.
Qed.
 
Theorem divp_reduce1 :
 forall (p : poly A0 eqA ltM) (L1 L2 : list (poly A0 eqA ltM)),
 (forall r1 : poly A0 eqA ltM,
  In r1 L1 ->
  ~ zerop A A0 eqA n ltM r1 ->
  exists r2 : poly A0 eqA ltM,
    In r2 L2 /\ divp A A0 eqA multA divA n ltM r1 r2) ->
 forall q : poly A0 eqA ltM,
 reducep L1 p q -> exists r : poly A0 eqA ltM, reducep L2 p r.
intros p L1 L2 H' q; case p; case q; simpl in |- *; auto.
intros x H'0 x0 c H'1; generalize c; unfold reducep in H'1; simpl in H'1;
 elim H'1; auto.
intros a b nZb p0 q0 r H'2 H'3 H'4 c0.
case inPolySet_inv1 with (1 := H'2).
intros q1 E; case E; intros H4 H5; clear E.
elim (H' q1);
 [ intros r2 E; elim E; intros H'10 H'11; clear E | idtac | idtac ]; 
 auto.
generalize H'10 H'11 H5 c0 H4; case q1; simpl in |- *; auto.
intros x1 c1; case r2; simpl in |- *; auto.
intros x2; case x2; simpl in |- *; auto.
generalize c1; case x1; auto.
intros c2 c3 H'6 H'8 H'9 c4 H'12; discriminate.
intros t l c2 c3 H'6 H'8; elim H'8.
intros a0 l c2; generalize c1; case x1; auto.
intros c3 H'6 H'8; elim H'8.
intros t l0 c3 H'6 H'8 H'9 c4 H'12.
cut (~ zeroP (A:=A) A0 eqA (n:=n) a0); [ intros nZa0 | idtac ].
cut
 (canonical A0 eqA ltM
    (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a a0
       nZa0 p0 l)); [ intros Z | idtac ].
exists
 (mks A A0 eqA n ltM
    (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a a0
       nZa0 p0 l) Z); simpl in |- *; auto.
red in |- *; simpl in |- *; apply reducetop_sp with (1 := cs); auto.
change
  (inPolySet A A0 eqA n ltM
     (s2p A A0 eqA n ltM (mks A A0 eqA n ltM (pX a0 l) c2)) L2) 
 in |- *.
apply in_inPolySet; auto.
simpl in |- *.
red in |- *; intros H'13; inversion H'13.
injection H'9; intros.
apply (divP_trans _ _ _ _ _ _ _ _ _ cs n) with (y := b); auto.
rewrite H0; auto.
apply canonical_spminusf_full with (1 := cs); auto.
injection H'9; intros.
apply (divP_trans _ _ _ _ _ _ _ _ _ cs n) with (y := b); auto.
rewrite H0; auto.
apply canonical_nzeroP with (ltM := ltM) (p := l); auto.
generalize H5; case q1; simpl in |- *; auto.
intros x1; case x1; simpl in |- *; auto.
intros c1 H'6; discriminate.
intros a b p0 q0 H'2 H'3 H'4 c0.
cut (canonical A0 eqA ltM p0);
 [ intro | apply canonical_imp_canonical with (a := a); auto ].
case (H'3 H); intros r; case r.
intros x1 H'6 H'7.
cut (canonical A0 eqA ltM (pX b x1)); [ intros Z | idtac ].
exists (mks A A0 eqA n ltM (pX b x1) Z); simpl in |- *; auto.
red in |- *; simpl in |- *; red in H'7; simpl in H'7; auto.
apply eqp_imp_canonical with (1 := cs) (p := pX a x1); auto.
apply ltP_pX_canonical; auto.
apply canonical_nzeroP with (ltM := ltM) (p := p0); auto.
apply ltP_trans with (y := p0); auto.
apply ltP_reduce with (1 := cs) (3 := H'7); auto.
apply (canonical_pX_ltP A A0 eqA); auto.
Qed.
 
Theorem nf_divp_zero :
 forall (p : poly A0 eqA ltM) (L : list (poly A0 eqA ltM)),
 ~ zerop A A0 eqA n ltM p ->
 zerop A A0 eqA n ltM
   (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os p
      L) ->
 exists q : poly A0 eqA ltM,
   In q L /\ divp A A0 eqA multA divA n ltM p q /\ ~ zerop A A0 eqA n ltM q.
intros p L; case p; unfold nf in |- *; auto.
unfold nf in |- *; auto.
intros x c;
 case
  (Reducef A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec
     os L (exist (fun l : list (Term A n) => canonical A0 eqA ltM l) x c)).
unfold LetP in |- *.
simpl in |- *; intros x0; case x0; simpl in |- *; auto.
intros x1 c0 H' H'0 H'1.
lapply
 (reducestar_divp (mks A A0 eqA n ltM x c) (mks A A0 eqA n ltM x1 c0) L);
 simpl in |- *;
 [ intros H'5; lapply H'5; [ intros H'6; clear H'5 | clear H'5 ] | idtac ];
 auto.
case H'6; intros r E; case E; intros H'2 H'3; case H'3; intros H'4 H'5;
 clear H'3 E H'6.
case H'2; [ intros H'3; clear H'2 | intros H'3; clear H'2 ].
case H'5; rewrite <- H'3.
generalize c0 H'1; case x1; auto.
exists r; split; [ idtac | split ]; auto.
Qed.
 
Theorem zerop_elim_cb :
 forall (L : list (poly A0 eqA ltM)) (p q : poly A0 eqA ltM),
 zerop A A0 eqA n ltM p ->
 Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec q (p :: L) ->
 Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec q L.
intros L p q H' H'0.
apply Cb_comp with (L1 := p :: L); auto.
simpl in |- *; auto.
intros p0 H'1; case H'1;
 [ intros H'2; rewrite <- H'2; clear H'1 | intros H'2; clear H'1 ]; 
 auto.
generalize H'; case p; simpl in |- *; auto.
intros x; case x; simpl in |- *; auto.
intros H'1 H'3; try assumption.
change (CombLinear A A0 eqA plusA multA eqA_dec n ltM ltM_dec L (pO A n))
 in |- *.
apply CombLinear_0; auto.
intros a l H'1 H'3; elim H'3; auto.
apply Cb_id with (1 := cs); auto.
Qed.
 
Theorem zerop_nf_cb :
 forall (L : list (poly A0 eqA ltM)) (p : poly A0 eqA ltM),
 zerop A A0 eqA n ltM
   (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os p
      L) -> Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec p L.
intros L p H'.
apply
 zerop_elim_cb
  with
    (p := nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM
            ltM_dec os p L); auto.
apply Cb_nf.
Qed.
Hint Resolve zerop_nf_cb.
 
Definition redacc :
  list (poly A0 eqA ltM) -> list (poly A0 eqA ltM) -> list (poly A0 eqA ltM).
intros H'; elim H'.
intros L; exact (nil (A:=poly A0 eqA ltM)).
intros a p Rec Acc.
apply
 LetP
  with
    (A := poly A0 eqA ltM)
    (h := nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM
            ltM_dec os a (p ++ Acc)).
intros u H'0; case (zerop_dec A A0 eqA n ltM u); intros Z.
exact (Rec Acc).
exact (u :: Rec (u :: Acc)).
Defined.
 
Theorem redacc_cb :
 forall (L1 L2 : list (poly A0 eqA ltM)) (p : poly A0 eqA ltM),
 In p (redacc L1 L2) ->
 Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec p (L1 ++ L2).
intros L1; elim L1; auto.
simpl in |- *; auto.
intros L2 p H; elim H.
simpl in |- *; unfold LetP in |- *; intros a l H' L2 p.
case
 (zerop_dec A A0 eqA n ltM
    (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os
       a (l ++ L2))).
intros H'0 H'1.
apply Cb_incl with (P := l ++ L2) (1 := cs); auto.
simpl in |- *; auto.
simpl in |- *.
intros H'0 H'1; case H'1;
 [ intros H'2; rewrite <- H'2; clear H'1 | intros H'2; clear H'1 ]; 
 auto.
apply Cb_cons; auto.
apply
 Cb_trans_cons
  with
    (p := nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM
            ltM_dec os a (l ++ L2)); auto.
apply
 Cb_incl
  with
    (1 := cs)
    (P := l ++
          nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM
            ltM_dec os a (l ++ L2) :: L2); auto.
change
  (incl
     (l ++
      nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os
        a (l ++ L2) :: L2)
     (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os
        a (l ++ L2) :: a :: l ++ L2)) in |- *.
apply incl_app; auto with datatypes.
apply Cb_cons; auto.
Qed.
 
Definition Red (L : list (poly A0 eqA ltM)) : list (poly A0 eqA ltM) :=
  redacc L nil.
 
Theorem Red_cb :
 forall (L : list (poly A0 eqA ltM)) (p : poly A0 eqA ltM),
 In p (Red L) -> Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec p L.
unfold Red in |- *.
intros L p H'.
generalize (redacc_cb L nil); simpl in |- *; auto.
rewrite <- app_nil_end; auto.
Qed.
 
Theorem cb_redacc :
 forall (L1 L2 : list (poly A0 eqA ltM)) (p : poly A0 eqA ltM),
 In p L1 ->
 Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec p (redacc L1 L2 ++ L2).
intros L1; elim L1; simpl in |- *; auto.
intros L2 p H'; elim H'; auto.
unfold LetP in |- *.
intros a l H' L2 p H'0; case H'0;
 [ intros H'1; rewrite H'1; clear H'0 | intros H'1; clear H'0 ]; 
 auto.
case
 (zerop_dec A A0 eqA n ltM
    (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os
       p (l ++ L2))); auto.
intros H'0.
apply Cb_comp with (L1 := l ++ L2); auto.
intros p0 H'2.
lapply (in_app_or l L2 p0); auto.
intros H'3; case H'3; auto.
intros H'4; apply Cb_id with (1 := cs); auto with datatypes.
intros H'0.
2: case
    (zerop_dec A A0 eqA n ltM
       (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec
          os a (l ++ L2))); auto.
2: intros H'0.
2: apply
    Cb_incl
     with
       (1 := cs)
       (P := redacc l
               (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM
                  ltM_dec os a (l ++ L2) :: L2) ++
             nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM
               ltM_dec os a (l ++ L2) :: L2); auto with datatypes.
2: intros a0 H; case (in_app_or _ _ _ H); auto with datatypes.
2: simpl in |- *; intros H1; case H1; auto with datatypes.
apply
 Cb_compo
  with
    (L1 := nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM
             ltM_dec os p (l ++ L2) :: l ++ L2); simpl in |- *; 
 auto.
apply Cb_nf; auto.
intros q H'2; case H'2;
 [ intros H'3; rewrite <- H'3; clear H'2 | intros H'3; clear H'2 ];
 auto with datatypes.
apply Cb_id with (1 := cs); auto with datatypes.
case (in_app_or _ _ _ H'3); auto with datatypes.
intros H'2.
apply
 Cb_incl
  with
    (1 := cs)
    (P := redacc l
            (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM
               ltM_dec os p (l ++ L2) :: L2) ++
          nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM
            ltM_dec os p (l ++ L2) :: L2); auto with datatypes.
intros a0 H; case (in_app_or _ _ _ H); auto with datatypes.
simpl in |- *; intros H1; case H1; auto with datatypes.
intros H; apply Cb_id with (1 := cs); auto with datatypes.
Qed.
 
Theorem Cb_Red :
 forall (L : list (poly A0 eqA ltM)) (p : poly A0 eqA ltM),
 In p L -> Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec p (Red L).
intros L p H'.
lapply (cb_redacc L nil p); [ intros H'3; generalize H'3 | idtac ];
 simpl in |- *; auto.
rewrite <- app_nil_end; auto.
Qed.
 
Theorem cb_Red_cb1 :
 forall (p : poly A0 eqA ltM) (L : list (poly A0 eqA ltM)),
 Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec p L ->
 Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec p (Red L).
intros p L H'.
apply Cb_compo with (L1 := L); auto.
intros q H'0.
apply Cb_Red; auto.
Qed.
 
Theorem cb_Red_cb2 :
 forall (p : poly A0 eqA ltM) (L : list (poly A0 eqA ltM)),
 Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec p (Red L) ->
 Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec p L.
intros p L H'.
apply Cb_compo with (L1 := Red L); auto.
intros q H'0.
apply Red_cb; auto.
Qed.
 
Theorem divp_id :
 forall p : poly A0 eqA ltM,
 ~ zerop A A0 eqA n ltM p -> divp A A0 eqA multA divA n ltM p p.
intros p; case p; auto.
intros x; case x; simpl in |- *; auto.
intros a l H' J.
cut (~ zeroP (A:=A) A0 eqA (n:=n) a); [ intros Z | idtac ].
apply divTerm_def with (nZb := Z).
apply canonical_nzeroP with (p := l) (ltM := ltM); auto.
apply
 (eqTerm_trans _ _ _ _ _ _ _ _ _ cs n)
  with (y := multTerm (A:=A) multA (n:=n) (T1 A1 n) a); 
 auto.
apply (eqTerm_sym _ _ _ _ _ _ _ _ _ cs n); auto.
apply canonical_nzeroP with (p := l) (ltM := ltM); auto.
Qed.
 
Theorem redacc_divp :
 forall (L1 L2 : list (poly A0 eqA ltM)) (p : poly A0 eqA ltM),
 ~ zerop A A0 eqA n ltM p ->
 In p (L1 ++ L2) ->
 exists q : poly A0 eqA ltM,
   In q (redacc L1 L2 ++ L2) /\
   divp A A0 eqA multA divA n ltM p q /\ ~ zerop A A0 eqA n ltM q.
intros L1; elim L1; simpl in |- *; auto.
intros L2 p H' H'0; exists p; split; auto.
split; auto.
apply divp_id; auto.
unfold LetP in |- *.
intros a l H' L2 p H'0 H'1; case H'1;
 [ intros H'2; rewrite <- H'2; clear H'1 | intros H'2; clear H'1 ]; 
 auto.
case
 (zerop_dec A A0 eqA n ltM
    (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os
       a (l ++ L2))); simpl in |- *; auto.
intros Z1.
lapply (nf_divp_zero a (l ++ L2));
 [ intros H'5; lapply H'5; [ intros H'6; clear H'5 | clear H'5 ] | idtac ];
 auto.
case H'6; intros q E; case E; intros H'3 H'4; case H'4; intros H'5 H'7;
 clear H'4 E H'6.
lapply (H' L2 q);
 [ intros H'8; lapply H'8; [ intros H'9; clear H'8 | clear H'8 ] | idtac ];
 auto.
case H'9; intros q0 E; case E; intros H'4 H'6; case H'6; intros H'8 H'10;
 clear H'6 E H'9.
exists q0; split; [ idtac | split ]; auto.
apply (divp_trans _ _ _ _ _ _ _ _ _ cs n ltM) with (y := q); auto.
rewrite H'2; auto.
intros Z1.
lapply (nf_divp a (l ++ L2));
 [ intros H'5; lapply H'5; [ intros H'6; clear H'5 | clear H'5 ] | idtac ];
 auto.
case H'6; intros q E; case E; intros H'3 H'4; case H'4; intros H'5 H'7;
 clear H'4 E H'6.
simpl in H'3.
case H'3; [ intros H'4; clear H'3 | intros H'4; clear H'3 ].
exists q; split; [ idtac | split ]; auto.
lapply
 (H'
    (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os
       a (l ++ L2) :: L2) q);
 [ intros H'8; lapply H'8; [ intros H'9; clear H'8 | clear H'8 ] | idtac ];
 auto.
case H'9; intros q0 E; case E; intros H'3 H'6; case H'6; intros H'8 H'10;
 clear H'6 E H'9.
exists q0; split; [ idtac | split ]; auto.
case (in_app_or _ _ _ H'3); auto.
simpl in |- *; auto with datatypes.
simpl in |- *; intros H'6; case H'6;
 [ intros H'9; clear H'6 | intros H'9; clear H'6 ]; 
 auto.
auto with datatypes.
apply (divp_trans _ _ _ _ _ _ _ _ _ cs n ltM) with (y := q); auto.
case (in_app_or _ _ _ H'4); auto with datatypes.
rewrite H'2; auto.
case
 (zerop_dec A A0 eqA n ltM
    (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os
       a (l ++ L2))); simpl in |- *; auto.
intros Z1.
case (in_app_or _ _ _ H'2); auto.
intros H'3.
lapply
 (H'
    (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os
       a (l ++ L2) :: L2) p);
 [ intros H'6; lapply H'6; [ intros H'7; clear H'6 | clear H'6 ] | idtac ];
 auto with datatypes.
case H'7; intros q E; case E; intros H'4 H'5; case H'5; intros H'6 H'8;
 clear H'5 E H'7.
exists q; split; auto.
case (in_app_or _ _ _ H'4); auto with datatypes.
simpl in |- *; auto.
intros H; case H; intros H1; auto with datatypes.
intros H; exists p; split; [ right | idtac ]; auto with datatypes.
split; auto.
apply divp_id; auto.
Qed.
 
Theorem Red_divp :
 forall (L : list (poly A0 eqA ltM)) (p : poly A0 eqA ltM),
 In p L ->
 ~ zerop A A0 eqA n ltM p ->
 exists q : poly A0 eqA ltM,
   In q (Red L) /\
   divp A A0 eqA multA divA n ltM p q /\ ~ zerop A A0 eqA n ltM q.
intros L p H' H'0.
lapply (redacc_divp L nil p); auto.
simpl in |- *; auto.
rewrite <- app_nil_end; auto.
rewrite <- app_nil_end; auto.
Qed.
 
Theorem Red_grobner :
 forall L : list (poly A0 eqA ltM),
 Grobner A A0 A1 eqA plusA invA minusA multA divA eqA_dec n ltM ltM_dec L ->
 Grobner A A0 A1 eqA plusA invA minusA multA divA eqA_dec n ltM ltM_dec
   (Red L).
intros L H'.
apply def_grobner; auto.
intros p H'0.
lapply (grobner_def L);
 [ intros H'2; lapply (H'2 p); [ intros H'4 | idtac ] | idtac ]; 
 auto.
case H'4; auto.
intros H'1; case H'1; intros q E; clear H'1.
right.
apply divp_reduce1 with (L1 := L) (q := q); auto.
intros r1 H'1 H'3.
lapply (Red_divp L r1);
 [ intros H'7; lapply H'7; [ intros H'8; clear H'7 | clear H'7 ] | idtac ];
 auto.
case H'8; intros q0 E0; case E0; intros H'5 H'6; case H'6; intros H'7 H'9;
 clear H'6 E0 H'8.
exists q0; split; auto.
apply cb_Red_cb2; auto.
Qed.
 
Definition redbuch (L : list (poly A0 eqA ltM)) : list (poly A0 eqA ltM) :=
  Red
    (buch A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec
       os L).
 
Theorem redbuch_stable :
 forall P : list (poly A0 eqA ltM),
 stable A A0 eqA plusA multA eqA_dec n ltM ltM_dec P (redbuch P).
intros P.
cut
 (stable A A0 eqA plusA multA eqA_dec n ltM ltM_dec P
    (buch A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec
       os P)).
intros H'0; inversion H'0; auto.
apply stable0; unfold redbuch in |- *; auto.
intros a H'.
apply cb_Red_cb1; auto.
intros a H'.
apply H0; auto.
apply cb_Red_cb2; auto.
apply buch_Stable; auto.
Qed.
 
Theorem redbuch_Grobner :
 forall P : list (poly A0 eqA ltM),
 Grobner A A0 A1 eqA plusA invA minusA multA divA eqA_dec n ltM ltM_dec
   (redbuch P).
intros P.
unfold redbuch in |- *.
apply Red_grobner; auto.
apply buch_Grobner; auto.
Qed.
End BuchRed.