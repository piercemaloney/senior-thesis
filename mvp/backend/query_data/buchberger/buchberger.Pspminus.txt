
Require Export Pminus.
(* Pminus:
Require Export Pmults.
Require Import Arith.
Section Pminus.
Load "hCoefStructure".
Load "hOrderStructure".
Load "hMults".
 
Inductive minusP :
list (Term A n) -> list (Term A n) -> list (Term A n) -> Prop :=
  | mnillu1 :
      forall l1 : list (Term A n),
      minusP (pO A n) l1
        (mults (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n)) l1)
  | mnillu2 : forall l1 : list (Term A n), minusP l1 (pO A n) l1
  | mmainu1 :
      forall (a1 a2 : Term A n) (l1 l2 l3 : list (Term A n)),
      ltT ltM a2 a1 ->
      minusP l1 (pX a2 l2) l3 -> minusP (pX a1 l1) (pX a2 l2) (pX a1 l3)
  | mmainu2a :
      forall (a1 a2 : Term A n) (l1 l2 l3 : list (Term A n)),
      minusP l1 l2 l3 ->
      eqT a1 a2 ->
      zeroP (A:=A) A0 eqA (n:=n) (minusTerm (A:=A) minusA (n:=n) a1 a2) ->
      minusP (pX a1 l1) (pX a2 l2) l3
  | mmainu2b :
      forall (a1 a2 : Term A n) (l1 l2 l3 : list (Term A n)),
      minusP l1 l2 l3 ->
      eqT a1 a2 ->
      ~ zeroP (A:=A) A0 eqA (n:=n) (minusTerm (A:=A) minusA (n:=n) a1 a2) ->
      minusP (pX a1 l1) (pX a2 l2)
        (pX (minusTerm (A:=A) minusA (n:=n) a1 a2) l3)
  | mmainu3 :
      forall (a1 a2 : Term A n) (l1 l2 l3 : list (Term A n)),
      ltT ltM a1 a2 ->
      minusP (pX a1 l1) l2 l3 ->
      minusP (pX a1 l1) (pX a2 l2) (pX (invTerm (A:=A) invA (n:=n) a2) l3).
Hint Resolve mnillu1 mnillu2 mmainu1 mmainu2a mmainu2b mmainu3.
Require Import LetP.
 
Definition minuspp :
  forall l : list (Term A n) * list (Term A n),
  {a : list (Term A n) | minusP (fst l) (snd l) a}.
intros l; pattern l in |- *.
apply
 well_founded_induction
  with (A := (list (Term A n) * list (Term A n))%type) (R := lessP A n); 
 auto.
apply wf_lessP; auto.
intros x; case x; intros l1 l2; simpl in |- *.
case l1.
intros H';
 exists (mults (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n)) l2);
 auto.
intros a1 m1; case l2.
intros H'; exists (pX a1 m1); auto.
intros a2 m2 H'; case (ltT_dec A n ltM ltM_dec a1 a2);
 [ intros P; case P; clear P | idtac ]; intros H1.
lapply (H' (pX a1 m1, m2)); simpl in |- *;
 [ intros Rec; case Rec; clear Rec; intros Orec Prec | idtac ].
exists (pX (invTerm (A:=A) invA (n:=n) a2) Orec); auto.
change
  (minusP (pX a1 m1) (pX a2 m2) (pX (invTerm (A:=A) invA (n:=n) a2) Orec))
 in |- *; auto.
red in |- *; red in |- *; simpl in |- *; rewrite <- plus_n_Sm; auto.
lapply (H' (m1, pX a2 m2)); simpl in |- *;
 [ intros Rec; case Rec; clear Rec; intros Orec Prec | idtac ].
exists (pX a1 Orec); auto.
change (minusP (pX a1 m1) (pX a2 m2) (pX a1 Orec)) in |- *; auto.
red in |- *; red in |- *; simpl in |- *; rewrite <- plus_n_Sm; auto.
lapply (H' (m1, m2)); simpl in |- *;
 [ intros Rec; case Rec; clear Rec; intros Orec Prec | idtac ].
apply LetP with (A := Term A n) (h := minusTerm (A:=A) minusA (n:=n) a1 a2).
 
Definition minuspf (l1 l2 : list (Term A n)) :=
  projsig1 (list (Term A n)) _ (minuspp (l1, l2)).
 
Theorem zerop_is_eqTerm :
 forall a b : Term A n,
 eqT a b ->
 zeroP (A:=A) A0 eqA (n:=n) (minusTerm (A:=A) minusA (n:=n) a b) ->
 eqTerm (A:=A) eqA (n:=n) a b.
Hint Unfold minuspf.
 
Theorem minusTerm_zeroP_r :
 forall a b : Term A n,
 zeroP (A:=A) A0 eqA (n:=n) a ->
 eqT a b ->
 eqTerm (A:=A) eqA (n:=n) (minusTerm (A:=A) minusA (n:=n) a b)
   (invTerm (A:=A) invA (n:=n) b).
 
Theorem minusTerm_zeroP :
 forall a b : Term A n,
 eqT a b ->
 zeroP (A:=A) A0 eqA (n:=n) b ->
 eqTerm (A:=A) eqA (n:=n) (minusTerm (A:=A) minusA (n:=n) a b) a.
Hint Resolve minusTerm_zeroP minusTerm_zeroP_r.
 
Theorem minusP_pO_is_eqP :
 forall p q r : list (Term A n),
 minusP p q r -> eqP A eqA n r (pO A n) -> eqP A eqA n p q.
 
Lemma minusP_inv :
 forall (p q l : list (Term A n)) (a b : Term A n),
 minusP (pX a p) (pX b q) l ->
 exists l1 : list (Term A n),
   ltT ltM b a /\ minusP p (pX b q) l1 /\ l = pX a l1 \/
   ltT ltM a b /\
   minusP (pX a p) q l1 /\ l = pX (invTerm (A:=A) invA (n:=n) b) l1 \/
   eqT a b /\
   (zeroP (A:=A) A0 eqA (n:=n) (minusTerm (A:=A) minusA (n:=n) a b) /\
    minusP p q l \/
    ~ zeroP (A:=A) A0 eqA (n:=n) (minusTerm (A:=A) minusA (n:=n) a b) /\
    minusP p q l1 /\ l = pX (minusTerm (A:=A) minusA (n:=n) a b) l1).
 
Theorem uniq_minusp :
 forall (l : list (Term A n) * list (Term A n)) (l3 l4 : list (Term A n)),
 minusP (fst l) (snd l) l3 -> minusP (fst l) (snd l) l4 -> l3 = l4.
 
Theorem minuspf_is_minusP :
 forall l1 l2 : list (Term A n), minusP l1 l2 (minuspf l1 l2).
Hint Resolve minuspf_is_minusP.
 
Theorem minuspf_pO_is_eqP :
 forall p q : list (Term A n),
 eqP A eqA n (minuspf p q) (pO A n) -> eqP A eqA n p q.
 
Theorem order_minusP :
 forall (l1 l2 l3 : list (Term A n)) (a : Term A n),
 minusP l1 l2 l3 ->
 canonical A0 eqA ltM (pX a l1) ->
 canonical A0 eqA ltM (pX a l2) ->
 canonical A0 eqA ltM l3 -> canonical A0 eqA ltM (pX a l3).
 
Theorem canonical_minusP :
 forall l1 l2 l3 : list (Term A n),
 minusP l1 l2 l3 ->
 canonical A0 eqA ltM l1 ->
 canonical A0 eqA ltM l2 -> canonical A0 eqA ltM l3.
 
Theorem canonical_minuspf :
 forall l1 l2 : list (Term A n),
 canonical A0 eqA ltM l1 ->
 canonical A0 eqA ltM l2 -> canonical A0 eqA ltM (minuspf l1 l2).
 
Lemma invTerm_eqT_comp :
 forall a b : Term A n, eqT a b -> eqT a (invTerm (A:=A) invA (n:=n) b).
 
Lemma invTerm_T1_eqT_comp :
 forall a b : Term A n,
 eqT a b ->
 eqT a
   (invTerm (A:=A) invA (n:=n) (multTerm (A:=A) multA (n:=n) (T1 A1 n) b)).
 
Lemma multTerm_invTerm_T1_eqT_comp :
 forall a b : Term A n,
 eqT a b ->
 eqT a
   (multTerm (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n)) b).
Hint Resolve invTerm_eqT_comp invTerm_T1_eqT_comp
  multTerm_invTerm_T1_eqT_comp.
 
Lemma minusP_is_plusP_mults :
 forall p q r : list (Term A n),
 minusP p q r ->
 eqP A eqA n r
   (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec p
      (mults (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n)) q)).
 
Theorem minuspf_is_pluspf_mults :
 forall p q : list (Term A n),
 eqP A eqA n (minuspf p q)
   (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec p
      (mults (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n)) q)).
Hint Resolve minuspf_is_pluspf_mults.
 
Theorem pO_minusP_inv1 :
 forall p q : list (Term A n),
 minusP (pO A n) p q ->
 q = mults (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n)) p.
 
Theorem pO_minusP_inv2 :
 forall p q : list (Term A n), minusP p (pO A n) q -> p = q.
 
Theorem minusP_inv1 :
 forall (a b : Term A n) (p q s : list (Term A n)),
 minusP (pX a p) (pX b q) s -> ltT ltM b a -> s = pX a (minuspf p (pX b q)).
 
Theorem minusP_inv2 :
 forall (a b : Term A n) (p q s : list (Term A n)),
 minusP (pX a p) (pX b q) s ->
 ltT ltM a b -> s = pX (invTerm (A:=A) invA (n:=n) b) (minuspf (pX a p) q).
 
Theorem minusP_inv3a :
 forall (a b : Term A n) (p q s : list (Term A n)),
 eqT a b ->
 zeroP (A:=A) A0 eqA (n:=n) (minusTerm (A:=A) minusA (n:=n) a b) ->
 minusP (pX a p) (pX b q) s -> s = minuspf p q.
 
Theorem minusP_inv3b :
 forall (a b : Term A n) (p q s : list (Term A n)),
 eqT a b ->
 ~ zeroP (A:=A) A0 eqA (n:=n) (minusTerm (A:=A) minusA (n:=n) a b) ->
 minusP (pX a p) (pX b q) s ->
 s = pX (minusTerm (A:=A) minusA (n:=n) a b) (minuspf p q).
 
Theorem minuspf_inv1_eq :
 forall (a b : Term A n) (p q : list (Term A n)),
 ltT ltM b a -> pX a (minuspf p (pX b q)) = minuspf (pX a p) (pX b q).
 
Theorem minuspf_inv2_eq :
 forall (a b : Term A n) (p q : list (Term A n)),
 ltT ltM a b ->
 pX (invTerm (A:=A) invA (n:=n) b) (minuspf (pX a p) q) =
 minuspf (pX a p) (pX b q).
 
Theorem minuspf_inv3a_eq :
 forall (a b : Term A n) (p q : list (Term A n)),
 eqT a b ->
 zeroP (A:=A) A0 eqA (n:=n) (minusTerm (A:=A) minusA (n:=n) a b) ->
 minuspf p q = minuspf (pX a p) (pX b q).
 
Theorem minuspf_inv3b_eq :
 forall (a b : Term A n) (p q : list (Term A n)),
 eqT a b ->
 ~ zeroP (A:=A) A0 eqA (n:=n) (minusTerm (A:=A) minusA (n:=n) a b) ->
 pX (minusTerm (A:=A) minusA (n:=n) a b) (minuspf p q) =
 minuspf (pX a p) (pX b q).
 
Theorem minuspf_inv1 :
 forall (a b : Term A n) (p q : list (Term A n)),
 ltT ltM b a ->
 eqP A eqA n (pX a (minuspf p (pX b q))) (minuspf (pX a p) (pX b q)).
 
Theorem minuspf_inv2 :
 forall (a b : Term A n) (p q : list (Term A n)),
 ltT ltM a b ->
 eqP A eqA n (pX (invTerm (A:=A) invA (n:=n) b) (minuspf (pX a p) q))
   (minuspf (pX a p) (pX b q)).
 
Theorem minuspf_inv3a :
 forall (a b : Term A n) (p q : list (Term A n)),
 eqT a b ->
 zeroP (A:=A) A0 eqA (n:=n) (minusTerm (A:=A) minusA (n:=n) a b) ->
 eqP A eqA n (minuspf p q) (minuspf (pX a p) (pX b q)).
 
Theorem minuspf_inv3b :
 forall (a b : Term A n) (p q : list (Term A n)),
 eqT a b ->
 ~ zeroP (A:=A) A0 eqA (n:=n) (minusTerm (A:=A) minusA (n:=n) a b) ->
 eqP A eqA n (pX (minusTerm (A:=A) minusA (n:=n) a b) (minuspf p q))
   (minuspf (pX a p) (pX b q)).
Hint Resolve pluspf_inv1 pluspf_inv2 pluspf_inv3a pluspf_inv3b.
Hint Resolve minuspf_inv1 minuspf_inv2 minuspf_inv3a minuspf_inv3b.
 
Theorem minuspf_comp :
 forall p q r s : list (Term A n),
 canonical A0 eqA ltM p ->
 canonical A0 eqA ltM q ->
 canonical A0 eqA ltM r ->
 canonical A0 eqA ltM s ->
 eqP A eqA n p r ->
 eqP A eqA n q s -> eqP A eqA n (minuspf p q) (minuspf r s).
 
Theorem mults_dist_minuspf :
 forall (p q : list (Term A n)) (a : Term A n),
 canonical A0 eqA ltM p ->
 canonical A0 eqA ltM q ->
 ~ zeroP (A:=A) A0 eqA (n:=n) a ->
 eqP A eqA n (mults (A:=A) multA (n:=n) a (minuspf p q))
   (minuspf (mults (A:=A) multA (n:=n) a p) (mults (A:=A) multA (n:=n) a q)).
Hint Resolve mults_dist_minuspf.
 
Theorem minuspf_pO_refl :
 forall p : list (Term A n), eqP A eqA n (minuspf p (pO A n)) p.
Hint Resolve minuspf_pO_refl.
 
Theorem minuspf_pOmults :
 forall p : list (Term A n),
 eqP A eqA n (minuspf (pO A n) p)
   (mults (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n)) p).
Hint Resolve minuspf_pOmults.
 
Theorem mults_pO :
 forall (p : list (Term A n)) (a b : Term A n),
 eqT a b ->
 zeroP (A:=A) A0 eqA (n:=n) (minusTerm (A:=A) minusA (n:=n) a b) ->
 eqP A eqA n (pO A n)
   (minuspf (mults (A:=A) multA (n:=n) a p) (mults (A:=A) multA (n:=n) b p)).
 
Theorem mults_minusTerm :
 forall (p : list (Term A n)) (a b : Term A n),
 eqT a b ->
 ~ zeroP (A:=A) A0 eqA (n:=n) (minusTerm (A:=A) minusA (n:=n) a b) ->
 canonical A0 eqA ltM p ->
 eqP A eqA n
   (mults (A:=A) multA (n:=n) (minusTerm (A:=A) minusA (n:=n) a b) p)
   (minuspf (mults (A:=A) multA (n:=n) a p) (mults (A:=A) multA (n:=n) b p)).
 
Theorem order_pluspf :
 forall (l1 l2 : list (Term A n)) (a : Term A n),
 canonical A0 eqA ltM (pX a l1) ->
 canonical A0 eqA ltM (pX a l2) ->
 canonical A0 eqA ltM
   (pX a
      (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec l1
         l2)).
Hint Resolve order_pluspf.
 
Theorem order_minuspf :
 forall (l1 l2 : list (Term A n)) (a : Term A n),
 canonical A0 eqA ltM (pX a l1) ->
 canonical A0 eqA ltM (pX a l2) ->
 canonical A0 eqA ltM (pX a (minuspf l1 l2)).
 
Theorem minusP_refl :
 forall p q r : list (Term A n), minusP p q r -> p = q -> r = pO A n.
 
Theorem minuspf_refl_eq : forall p : list (Term A n), minuspf p p = pO A n.
 
Theorem minuspf_refl :
 forall p : list (Term A n), eqP A eqA n (minuspf p p) (pO A n).
 
Theorem mults_comp_minuspf :
 forall (a : Term A n) (p q : list (Term A n)),
 canonical A0 eqA ltM p ->
 canonical A0 eqA ltM q ->
 ~ zeroP (A:=A) A0 eqA (n:=n) a ->
 eqP A eqA n
   (minuspf (mults (A:=A) multA (n:=n) a p) (mults (A:=A) multA (n:=n) a q))
   (mults (A:=A) multA (n:=n) a (minuspf p q)).
 
Theorem minuspf_zero :
 forall (a : Term A n) (p q : list (Term A n)),
 eqP A eqA n (minuspf (pX a p) (pX a q)) (minuspf p q).
Hint Resolve canonical_minuspf.
 
Theorem pluspf_minuspf_id :
 forall p q : list (Term A n),
 canonical A0 eqA ltM p ->
 canonical A0 eqA ltM q ->
 eqP A eqA n
   (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec
      (minuspf p q) q) p.
 
Theorem minusP_pO_refl_eq :
 forall p q : list (Term A n), minusP p (pO A n) q -> p = q.
 
Theorem minuspf_pO_refl_eq :
 forall p : list (Term A n), minuspf p (pO A n) = p.
 
Theorem Opm_ind :
 forall (P : list (Term A n) -> list (Term A n) -> Prop)
   (p q : list (Term A n)),
 (forall p : list (Term A n), P (pO A n) p) ->
 (forall p : list (Term A n), P p (pO A n)) ->
 (forall (a b : Term A n) (p q : list (Term A n)),
  P (pX a p) q -> ltT ltM a b -> P (pX a p) (pX b q)) ->
 (forall (a b : Term A n) (p q : list (Term A n)),
  P p (pX b q) -> ltT ltM b a -> P (pX a p) (pX b q)) ->
 (forall (a b : Term A n) (p q : list (Term A n)),
  P p q -> eqT a b -> P (pX a p) (pX b q)) ->
 forall p q : list (Term A n), P p q.
 
Theorem minuspf_eq_inv1 :
 forall (a : Term A n) (p q : list (Term A n)),
 canonical A0 eqA ltM (pX a p) ->
 canonical A0 eqA ltM (pX a q) ->
 eqP A eqA n (pX a (minuspf p q)) (minuspf (pX a p) q).
 
Theorem minuspf_pOmults_eq :
 forall p : list (Term A n),
 minuspf (pO A n) p =
 mults (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n)) p.
 
Theorem minuspf_eq_inv2 :
 forall (a : Term A n) (p q : list (Term A n)),
 canonical A0 eqA ltM (pX a p) ->
 canonical A0 eqA ltM (pX a q) ->
 eqP A eqA n (pX (invTerm (A:=A) invA (n:=n) a) (minuspf p q))
   (minuspf p (pX a q)).
 
Definition inv : list (Term A n) -> Term A n -> Term A n.
 
Theorem inv_prop :
 forall (a : Term A n) (p q : list (Term A n)),
 canonical A0 eqA ltM (pX a p) ->
 minuspf p (pX a q) = pX (inv p a) (minuspf p q).
Hint Resolve inv_prop.
 
Theorem invTerm_T1_multTerm_T1 :
 eqTerm (A:=A) eqA (n:=n)
   (multTerm (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n))
      (invTerm (A:=A) invA (n:=n) (T1 A1 n))) (T1 A1 n).
Hint Resolve invTerm_T1_multTerm_T1.
 
Theorem pluspf_is_minuspf :
 forall p q : list (Term A n),
 canonical A0 eqA ltM p ->
 canonical A0 eqA ltM q ->
 eqP A eqA n
   (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec p q)
   (minuspf p
      (mults (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n)) q)).
 
Definition sminus : poly A0 eqA ltM -> poly A0 eqA ltM -> poly A0 eqA ltM.
End Pminus. *)
Require Export DivTerm.
(* DivTerm:
Require Import Relation_Definitions.
Require Import CoefStructure.
Require Import moreCoefStructure.
Require Import OrderStructure.
Require Import Monomials.
Require Import Term.
Require Import List.
Section DivTerm.
Load "hCoefStructure".
Load "mCoefStructure".
Load "hOrderStructure".
Load "mOrderStructure".
Load "hTerm".
Set Implicit Arguments.
Unset Strict Implicit.
 
Definition divTerm :
  Term A n ->
  forall (b : Term A n) (nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b), Term A n.
Set Strict Implicit.
Unset Implicit Arguments.
 
Theorem eqT_divTerm_plusTerm :
 forall (a b c : Term A n) (nZc : ~ zeroP (A:=A) A0 eqA (n:=n) c),
 eqT a b ->
 eqTerm (A:=A) eqA (n:=n) a (multTerm (A:=A) multA (n:=n) (divTerm a nZc) c) ->
 eqTerm (A:=A) eqA (n:=n) b (multTerm (A:=A) multA (n:=n) (divTerm b nZc) c) ->
 eqTerm (A:=A) eqA (n:=n) (divTerm (plusTerm (A:=A) plusA (n:=n) a b) nZc)
   (plusTerm (A:=A) plusA (n:=n) (divTerm a nZc) (divTerm b nZc)).
 
Theorem divTerm_invTerm_l :
 forall (a b : Term A n) (nZa : ~ zeroP (A:=A) A0 eqA (n:=n) a),
 eqTerm (A:=A) eqA (n:=n) b (multTerm (A:=A) multA (n:=n) (divTerm b nZa) a) ->
 eqTerm (A:=A) eqA (n:=n) (divTerm (invTerm (A:=A) invA (n:=n) b) nZa)
   (invTerm (A:=A) invA (n:=n) (divTerm b nZa)).
 
Theorem divTerm_invTerm_r :
 forall (a b : Term A n) (nZa : ~ zeroP (A:=A) A0 eqA (n:=n) a)
   (nZia : ~ zeroP (A:=A) A0 eqA (n:=n) (invTerm (A:=A) invA (n:=n) a)),
 eqTerm (A:=A) eqA (n:=n) b (multTerm (A:=A) multA (n:=n) (divTerm b nZa) a) ->
 eqTerm (A:=A) eqA (n:=n) (divTerm b nZia)
   (invTerm (A:=A) invA (n:=n) (divTerm b nZa)).
 
Theorem eqT_divTerm :
 forall (a b c d : Term A n) (nZc : ~ zeroP (A:=A) A0 eqA (n:=n) c)
   (nZd : ~ zeroP (A:=A) A0 eqA (n:=n) d),
 eqT a b -> eqT c d -> eqT (divTerm a nZc) (divTerm b nZd).
 
Theorem eqTerm_divTerm_comp :
 forall (a b c d : Term A n) (nZc : ~ zeroP (A:=A) A0 eqA (n:=n) c)
   (nZd : ~ zeroP (A:=A) A0 eqA (n:=n) d),
 eqTerm (A:=A) eqA (n:=n) a b ->
 eqTerm (A:=A) eqA (n:=n) c d ->
 eqTerm (A:=A) eqA (n:=n) (divTerm a nZc) (divTerm b nZd).
Hint Resolve eqTerm_divTerm_comp.
 
Theorem divTerm_multTerm_l :
 forall (a b c : Term A n) (nZa : ~ zeroP (A:=A) A0 eqA (n:=n) a),
 eqTerm (A:=A) eqA (n:=n) b (multTerm (A:=A) multA (n:=n) (divTerm b nZa) a) ->
 eqTerm (A:=A) eqA (n:=n) (divTerm (multTerm (A:=A) multA (n:=n) c b) nZa)
   (multTerm (A:=A) multA (n:=n) c (divTerm b nZa)).
 
Theorem divTerm_multTerm_r :
 forall (a b c : Term A n) (nZa : ~ zeroP (A:=A) A0 eqA (n:=n) a),
 eqTerm (A:=A) eqA (n:=n) b (multTerm (A:=A) multA (n:=n) (divTerm b nZa) a) ->
 eqTerm (A:=A) eqA (n:=n) (divTerm (multTerm (A:=A) multA (n:=n) b c) nZa)
   (multTerm (A:=A) multA (n:=n) (divTerm b nZa) c).
Hint Resolve divTerm_multTerm_l divTerm_multTerm_r.
 
Theorem div_is_T1 :
 forall (a : Term A n) (nZa : ~ zeroP (A:=A) A0 eqA (n:=n) a),
 eqTerm (A:=A) eqA (n:=n) (divTerm a nZa) (T1 A1 n).
Hint Resolve div_is_T1.
 
Theorem divTerm_nZ :
 forall a b : Term A n,
 ~ zeroP (A:=A) A0 eqA (n:=n) a ->
 forall nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b,
 ~ zeroP (A:=A) A0 eqA (n:=n) (divTerm a nZb).
 
Theorem divTerm_eqT :
 forall a b c : Term A n,
 eqT a b ->
 ~ zeroP (A:=A) A0 eqA (n:=n) a ->
 ~ zeroP (A:=A) A0 eqA (n:=n) b ->
 forall nZc : ~ zeroP (A:=A) A0 eqA (n:=n) c,
 eqTerm (A:=A) eqA (n:=n) a (multTerm (A:=A) multA (n:=n) (divTerm a nZc) c) ->
 eqTerm (A:=A) eqA (n:=n) b (multTerm (A:=A) multA (n:=n) (divTerm b nZc) c).
 
Let gb : mon n * bool -> bool.
 
Let gm : mon n * bool -> mon n.
 
Definition mk_clean :
  forall a b : mon n, {c : mon n * bool | c = div_mon_clean n a b}.
 
Theorem divTerm_dec :
 forall a b : Term A n,
 ~ zeroP (A:=A) A0 eqA (n:=n) a ->
 forall nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b,
 {eqTerm (A:=A) eqA (n:=n) a (multTerm (A:=A) multA (n:=n) (divTerm a nZb) b)} +
 {~
  eqTerm (A:=A) eqA (n:=n) a (multTerm (A:=A) multA (n:=n) (divTerm a nZb) b)}.
 
Theorem zeroP_divTerm :
 forall a b : Term A n,
 zeroP (A:=A) A0 eqA (n:=n) a ->
 forall nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b,
 zeroP (A:=A) A0 eqA (n:=n) (divTerm a nZb).
 
Theorem divTerm_on_eqT :
 forall a b : Term A n,
 ~ zeroP (A:=A) A0 eqA (n:=n) a ->
 forall nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b,
 eqT a b ->
 eqTerm (A:=A) eqA (n:=n) a (multTerm (A:=A) multA (n:=n) (divTerm a nZb) b).
 
Theorem divTerm_on_eqT_eqT :
 forall a b : Term A n,
 ~ zeroP (A:=A) A0 eqA (n:=n) a ->
 forall nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b,
 eqT a b -> eqT (divTerm a nZb) (T1 A1 n).
 
Theorem divTerm_on_plusM_minusM :
 forall a b : Term A n,
 ~ zeroP (A:=A) A0 eqA (n:=n) a ->
 forall nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b,
 T2M a = mult_mon n (div_mon n (T2M a) (T2M b)) (T2M b) ->
 eqTerm (A:=A) eqA (n:=n) a (multTerm (A:=A) multA (n:=n) (divTerm a nZb) b).
Set Implicit Arguments.
Unset Strict Implicit.
 
Definition ppc : Term A n -> Term A n -> Term A n.
Set Strict Implicit.
Unset Implicit Arguments.
 
Theorem ppc_com :
 forall a b : Term A n, eqTerm (A:=A) eqA (n:=n) (ppc a b) (ppc b a).
 
Theorem divTerm_ppc :
 forall (a b c : Term A n) (nZa : ~ zeroP (A:=A) A0 eqA (n:=n) a)
   (nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b)
   (nZppab : ~ zeroP (A:=A) A0 eqA (n:=n) (ppc a b)),
 eqTerm (A:=A) eqA (n:=n) c (multTerm (A:=A) multA (n:=n) (divTerm c nZa) a) ->
 eqTerm (A:=A) eqA (n:=n) c (multTerm (A:=A) multA (n:=n) (divTerm c nZb) b) ->
 eqTerm (A:=A) eqA (n:=n) c
   (multTerm (A:=A) multA (n:=n) (divTerm c nZppab) (ppc a b)).
 
Theorem divTerm_ppcl :
 forall (a b : Term A n) (nZa : ~ zeroP (A:=A) A0 eqA (n:=n) a),
 ~ zeroP (A:=A) A0 eqA (n:=n) b ->
 eqTerm (A:=A) eqA (n:=n) (ppc a b)
   (multTerm (A:=A) multA (n:=n) (divTerm (ppc a b) nZa) a).
 
Theorem divTerm_ppcr :
 forall a b : Term A n,
 ~ zeroP (A:=A) A0 eqA (n:=n) a ->
 forall nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b,
 eqTerm (A:=A) eqA (n:=n) (ppc a b)
   (multTerm (A:=A) multA (n:=n) (divTerm (ppc a b) nZb) b).
 
Theorem ppc_nZ :
 forall a b c : Term A n,
 ~ zeroP (A:=A) A0 eqA (n:=n) a ->
 ~ zeroP (A:=A) A0 eqA (n:=n) b -> ~ zeroP (A:=A) A0 eqA (n:=n) (ppc a b).
 
Theorem divTerm_rew :
 forall (a b : Term A n) (nZ1 nZ2 : ~ zeroP (A:=A) A0 eqA (n:=n) b),
 divTerm a nZ1 = divTerm a nZ2.
 
Inductive divP : Term A n -> Term A n -> Prop :=
    divTerm_def :
      forall a b : Term A n,
      ~ zeroP (A:=A) A0 eqA (n:=n) a ->
      forall nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b,
      eqTerm (A:=A) eqA (n:=n) a
        (multTerm (A:=A) multA (n:=n) (divTerm a nZb) b) -> 
      divP a b.
 
Theorem divP_inv1 :
 forall a b : Term A n, divP a b -> ~ zeroP (A:=A) A0 eqA (n:=n) a.
 
Theorem divP_inv2 :
 forall a b : Term A n, divP a b -> ~ zeroP (A:=A) A0 eqA (n:=n) b.
 
Theorem divP_inv3 :
 forall (a b : Term A n) (nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b),
 divP a b ->
 eqTerm (A:=A) eqA (n:=n) a (multTerm (A:=A) multA (n:=n) (divTerm a nZb) b).
Hint Resolve divP_inv1 divP_inv2 divP_inv3.
 
Theorem divP_plusTerm :
 forall a b c : Term A n,
 divP a c ->
 divP b c ->
 eqT a b ->
 ~ zeroP (A:=A) A0 eqA (n:=n) (plusTerm (A:=A) plusA (n:=n) a b) ->
 divP (plusTerm (A:=A) plusA (n:=n) a b) c.
Hint Resolve divP_plusTerm.
 
Theorem divP_invTerm_l :
 forall a b : Term A n, divP a b -> divP (invTerm (A:=A) invA (n:=n) a) b.
Hint Resolve divP_invTerm_l.
 
Theorem divP_invTerm_r :
 forall a b : Term A n, divP a b -> divP a (invTerm (A:=A) invA (n:=n) b).
Hint Resolve divTerm_nZ.
Hint Resolve divP_invTerm_r.
 
Theorem divTerm_multTerml :
 forall a b : Term A n,
 ~ zeroP (A:=A) A0 eqA (n:=n) a ->
 ~ zeroP (A:=A) A0 eqA (n:=n) b -> divP (multTerm (A:=A) multA (n:=n) a b) a.
 
Theorem divTerm_multTermr :
 forall a b : Term A n,
 ~ zeroP (A:=A) A0 eqA (n:=n) a ->
 ~ zeroP (A:=A) A0 eqA (n:=n) b -> divP (multTerm (A:=A) multA (n:=n) a b) b.
Hint Resolve divTerm_multTermr divTerm_multTerml.
 
Theorem divP_trans : transitive (Term A n) divP.
Hint Resolve divP_trans.
 
Theorem divP_nZero :
 forall (a b : Term A n) (nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b),
 divP a b -> ~ zeroP (A:=A) A0 eqA (n:=n) (divTerm a nZb).
Hint Resolve divP_nZero.
 
Theorem divP_eqTerm_comp :
 forall a b c : Term A n,
 divP a c -> eqTerm (A:=A) eqA (n:=n) a b -> divP b c.
 
Theorem divP_on_eqT :
 forall a b : Term A n,
 ~ zeroP (A:=A) A0 eqA (n:=n) a ->
 ~ zeroP (A:=A) A0 eqA (n:=n) b -> eqT a b -> divP a b.
 
Theorem divP_on_eqT_eqT :
 forall a b : Term A n,
 ~ zeroP (A:=A) A0 eqA (n:=n) a ->
 forall nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b,
 eqT a b -> eqT (divTerm a nZb) (T1 A1 n).
Hint Resolve divP_on_eqT divP_on_eqT_eqT.
 
Inductive ppcm (p q : Term A n) : Term A n -> Prop :=
    ppcm0 :
      forall s : Term A n,
      (forall r : Term A n, divP r p -> divP r q -> divP r s) ->
      divP s p -> divP s q -> ppcm p q s.
Hint Resolve ppcm0.
 
Theorem ppc_is_ppcm :
 forall a b : Term A n,
 ~ zeroP (A:=A) A0 eqA (n:=n) a ->
 ~ zeroP (A:=A) A0 eqA (n:=n) b -> ppcm a b (ppc a b).
 
Theorem ppc_multTerm_divP :
 forall a b : Term A n,
 ~ zeroP (A:=A) A0 eqA (n:=n) a ->
 ~ zeroP (A:=A) A0 eqA (n:=n) b ->
 divP (multTerm (A:=A) multA (n:=n) a b) (ppc a b).
Hint Resolve ppc_multTerm_divP.
 
Theorem divP_comp :
 forall a b c d : Term A n,
 divP a c ->
 eqTerm (A:=A) eqA (n:=n) a b -> eqTerm (A:=A) eqA (n:=n) c d -> divP b d.
 
Theorem divP_multTerm_l :
 forall a b c : Term A n,
 ~ zeroP (A:=A) A0 eqA (n:=n) a ->
 ~ zeroP (A:=A) A0 eqA (n:=n) b ->
 eqTerm (A:=A) eqA (n:=n) (multTerm (A:=A) multA (n:=n) a b) c -> divP c a.
 
Theorem divP_multTerm_r :
 forall a b c : Term A n,
 ~ zeroP (A:=A) A0 eqA (n:=n) a ->
 ~ zeroP (A:=A) A0 eqA (n:=n) b ->
 eqTerm (A:=A) eqA (n:=n) (multTerm (A:=A) multA (n:=n) a b) c -> divP c b.
Hint Resolve divP_multTerm_r divP_multTerm_l.
 
Theorem divP_ppcl :
 forall a b : Term A n,
 ~ zeroP (A:=A) A0 eqA (n:=n) a ->
 ~ zeroP (A:=A) A0 eqA (n:=n) b -> divP (ppc a b) a.
 
Theorem divP_ppcr :
 forall a b : Term A n,
 ~ zeroP (A:=A) A0 eqA (n:=n) a ->
 ~ zeroP (A:=A) A0 eqA (n:=n) b -> divP (ppc a b) b.
Hint Resolve divP_ppcl divP_ppcr.
 
Theorem divTerm_compo :
 forall (a b c : Term A n) (nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b)
   (nZc : ~ zeroP (A:=A) A0 eqA (n:=n) c),
 divP a b ->
 divP b c ->
 eqTerm (A:=A) eqA (n:=n) (divTerm a nZc)
   (multTerm (A:=A) multA (n:=n) (divTerm a nZb) (divTerm b nZc)).
Hint Resolve divTerm_compo.
 
Theorem divP_comp_ppc0 :
 forall (a b : Term A n) (nZa : ~ zeroP (A:=A) A0 eqA (n:=n) a)
   (nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b)
   (nZppab : ~ zeroP (A:=A) A0 eqA (n:=n) (ppc a b)) 
   (p : list (Term A n)),
 eqTerm (A:=A) eqA (n:=n) b
   (multTerm (A:=A) multA (n:=n)
      (divTerm (multTerm (A:=A) multA (n:=n) a b) nZppab)
      (divTerm (ppc a b) nZa)).
 
Theorem divP_comp_ppc1 :
 forall (a b : Term A n) (nZa : ~ zeroP (A:=A) A0 eqA (n:=n) a)
   (nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b)
   (nZppab : ~ zeroP (A:=A) A0 eqA (n:=n) (ppc a b)) 
   (p : list (Term A n)),
 eqTerm (A:=A) eqA (n:=n) a
   (multTerm (A:=A) multA (n:=n)
      (divTerm (multTerm (A:=A) multA (n:=n) a b) nZppab)
      (divTerm (ppc a b) nZb)).
 
Theorem divP_dec :
 forall a b : Term A n,
 ~ zeroP (A:=A) A0 eqA (n:=n) a ->
 ~ zeroP (A:=A) A0 eqA (n:=n) b -> {divP a b} + {~ divP a b}.
 
Theorem divP_eqT :
 forall a b c : Term A n,
 eqT a b -> ~ zeroP (A:=A) A0 eqA (n:=n) b -> divP a c -> divP b c.
 
Theorem eqTerm_multTerm_imp_eqTerm :
 forall a b c : Term A n,
 ~ zeroP (A:=A) A0 eqA (n:=n) c ->
 eqTerm (A:=A) eqA (n:=n) (multTerm (A:=A) multA (n:=n) c a)
   (multTerm (A:=A) multA (n:=n) c b) -> eqTerm (A:=A) eqA (n:=n) a b.
 
Theorem multTerm_eqTerm_inv :
 forall a b c : Term A n,
 eqTerm (A:=A) eqA (n:=n) (multTerm (A:=A) multA (n:=n) a b)
   (multTerm (A:=A) multA (n:=n) a c) ->
 ~ zeroP (A:=A) A0 eqA (n:=n) a -> eqTerm (A:=A) eqA (n:=n) b c.
 
Theorem eqT_nzero_divP :
 forall (a b : Term A n) (nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b),
 eqT a (multTerm (A:=A) multA (n:=n) (divTerm a nZb) b) ->
 ~ zeroP (A:=A) A0 eqA (n:=n) a -> divP a b.
Hint Resolve eqT_nzero_divP.
 
Theorem eqT_nzero_eqT_divP :
 forall (a b c : Term A n) (nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b),
 eqT c (multTerm (A:=A) multA (n:=n) (divTerm c nZb) b) ->
 ~ zeroP (A:=A) A0 eqA (n:=n) a -> eqT a c -> divP a b.
Hint Resolve eqT_nzero_eqT_divP.
End DivTerm. *)
Section Pspminus.
Load "hCoefStructure".
Load "hOrderStructure".
Load "hMinus".
 
Theorem divP_is_not_order :
 forall a b : Term A n, divP A A0 eqA multA divA n a b -> ~ ltT ltM a b.
intros a b H'; inversion H'.
case
 (ltT_dec A n ltM ltM_dec (T1 A1 n)
    (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) a (b:=b) nZb));
 [ intros tmp; case tmp; clear tmp | idtac ]; intros H'2; 
 auto.
apply ltT_not_ltT; auto.
apply
 ltT_eqTl
  with
    (a := multTerm (A:=A) multA (n:=n)
            (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) a (b:=b) nZb) b);
 auto.
apply (eqT_sym A n); apply (eqTerm_imp_eqT A eqA); auto.
apply ltT_eqTr with (a := multTerm (A:=A) multA (n:=n) (T1 A1 n) b); auto.
apply (eqT_sym A n); apply (eqTerm_imp_eqT A eqA);
 apply T1_multTerm_l with (1 := cs); auto.
apply multTerm_ltT_r with (1 := os); auto.
elim
 (T1_is_min_ltT A A1)
  with
    (a := divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) a (b:=b) nZb)
    (1 := os); auto.
apply ltT_not_eqT; auto.
apply
 (eqT_trans A n)
  with
    (y := multTerm (A:=A) multA (n:=n)
            (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) a (b:=b) nZb) b);
 auto.
apply (eqTerm_imp_eqT A eqA); auto.
apply (eqT_trans A n) with (y := multTerm (A:=A) multA (n:=n) (T1 A1 n) b);
 auto.
apply (eqT_sym A n); auto.
apply (eqT_sym A n); apply (eqTerm_imp_eqT A eqA); auto.
Qed.
Hint Resolve divP_is_not_order.
 
Theorem divP_ltT_comp :
 forall (a b : Term A n) (p : list (Term A n)),
 canonical A0 eqA ltM (pX b p) ->
 divP A A0 eqA multA divA n a b -> canonical A0 eqA ltM (pX a p).
intros a b p; case p; auto.
intros H' H'0.
change (canonical A0 eqA ltM (pX a (pO A n))) in |- *; apply canonicalp1;
 auto.
apply divP_inv1 with (1 := H'0); auto.
intros a0 l H' H'0; change (canonical A0 eqA ltM (pX a (pX a0 l))) in |- *;
 apply canonical_cons; auto.
case (ltT_dec A n ltM ltM_dec a b);
 [ intros tmp; case tmp; clear tmp | idtac ]; intros H'2; 
 auto.
elim (divP_is_not_order a b); auto.
apply (ltT_trans A _ _ os) with (y := b); auto.
apply (canonical_pX_order _ A0 eqA) with (l := l); auto.
apply eqT_compat_ltTr with (b := b); auto.
apply (eqT_sym A n); auto.
apply (canonical_pX_order _ A0 eqA) with (l := l); auto.
apply divP_inv1 with (1 := H'0); auto.
apply canonical_imp_canonical with (a := b); auto.
Qed.
 
Definition spminusf (a b : Term A n) (nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b)
  (p q : list (Term A n)) :=
  minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p
    (mults (A:=A) multA (n:=n)
       (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) a (b:=b) nZb) q).
 
Theorem sp_rew :
 forall (a b : Term A n) (nZ1 nZ2 : ~ zeroP (A:=A) A0 eqA (n:=n) b)
   (p q : list (Term A n)), spminusf a b nZ1 p q = spminusf a b nZ2 p q.
auto; auto.
intros a b nZ1 nZ2 p q; unfold spminusf in |- *.
change
  (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p
     (mults (A:=A) multA (n:=n)
        (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) a (b:=b) nZ1) q) =
   minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p
     (mults (A:=A) multA (n:=n)
        (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) a (b:=b) nZ2) q))
 in |- *.
rewrite
 divTerm_rew with (1 := cs) (a := a) (b := b) (nZ1 := nZ1) (nZ2 := nZ2); 
 auto.
Qed.

Theorem rew_spminusf :
 forall (a b : Term A n) (nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b)
   (p q : list (Term A n)),
 spminusf a b nZb p q =
 minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p
   (mults (A:=A) multA (n:=n)
      (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) a (b:=b) nZb) q).
simpl in |- *; auto.
Qed.

Theorem canonical_spminusf :
 forall (a b : Term A n) (nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b)
   (p q : list (Term A n)),
 canonical A0 eqA ltM p ->
 canonical A0 eqA ltM q ->
 divP A A0 eqA multA divA n a b ->
 canonical A0 eqA ltM (spminusf a b nZb p q).
unfold spminusf in |- *.
intros a b nZb p q H' H'0 H'1; apply canonical_minuspf with (1 := cs); auto.
Qed.
Hint Resolve canonical_spminusf.
 
Theorem spminusf_extend :
 forall (a b : Term A n) (nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b)
   (p q : list (Term A n)),
 divP A A0 eqA multA divA n a b ->
 canonical A0 eqA ltM (pX a p) ->
 canonical A0 eqA ltM (pX b q) ->
 eqP A eqA n (spminusf a b nZb p q) (spminusf a b nZb (pX a p) (pX b q)).
intros a b nZb p q H'; unfold spminusf in |- *; simpl in |- *; inversion H'.
intros H'0 H'1;
 apply
  (eqp_trans _ _ _ _ _ _ _ _ _ cs n)
   with
     (y := minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec
             (pX a p)
             (pX a
                (mults (A:=A) multA (n:=n)
                   (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) a (b:=b)
                      nZb) q))); auto.
apply minuspf_inv3a with (1 := cs); auto.
apply minuspf_comp with (1 := cs); auto.
apply
 canonical_pX_eqT
  with
    (a := multTerm (A:=A) multA (n:=n)
            (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) a (b:=b) nZb) b);
 auto.
change
  (canonical A0 eqA ltM
     (mults (A:=A) multA (n:=n) (divTerm divA a nZb) (pX b q))) 
 in |- *; auto.
apply (eqT_sym A n); apply (eqTerm_imp_eqT A eqA n); auto.
change
  (canonical A0 eqA ltM
     (mults (A:=A) multA (n:=n) (divTerm divA a nZb) (pX b q))) 
 in |- *; auto.
Qed.
 
Theorem canonical_spminusf_full :
 forall (a b : Term A n) (nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b)
   (p q : list (Term A n)),
 canonical A0 eqA ltM (pX a p) ->
 canonical A0 eqA ltM (pX b q) ->
 divP A A0 eqA multA divA n a b ->
 canonical A0 eqA ltM (spminusf a b nZb p q).
intros a b nZb p q H' H'0 H'1; apply canonical_spminusf; auto.
apply canonical_imp_canonical with (a := a); auto.
apply canonical_imp_canonical with (a := b); auto.
Qed.
Hint Resolve canonical_spminusf_full.
 
Theorem canonical_spminusf_full_t :
 forall (a b : Term A n) (nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b)
   (p q : list (Term A n)),
 canonical A0 eqA ltM (pX a p) ->
 canonical A0 eqA ltM (pX b q) ->
 divP A A0 eqA multA divA n a b ->
 canonical A0 eqA ltM (pX a (spminusf a b nZb p q)).
unfold spminusf in |- *.
intros a b nZb p q H' H'0 H'1; try assumption.
inversion H'1.
apply order_minuspf with (1 := cs); auto.
apply
 canonical_pX_eqT
  with
    (a := multTerm (A:=A) multA (n:=n)
            (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) a (b:=b) nZb) b);
 auto.
change
  (canonical A0 eqA ltM
     (mults (A:=A) multA (n:=n) (divTerm divA a nZb) (pX b q))) 
 in |- *; auto.
apply (eqT_sym A n); apply (eqTerm_imp_eqT A eqA n); auto.
Qed.
Hint Resolve canonical_spminusf_full_t.
 
Theorem spminusf_pluspf :
 forall (a b : Term A n) (nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b)
   (p q r : list (Term A n)),
 canonical A0 eqA ltM p ->
 canonical A0 eqA ltM q ->
 canonical A0 eqA ltM r ->
 divP A A0 eqA multA divA n a b ->
 eqP A eqA n
   (spminusf a b nZb
      (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec p
         q) r)
   (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec
      (spminusf a b nZb p r) q).
intros a b nZb p q r H' H'0 H'1 H'2; unfold spminusf in |- *.
inversion H'2.
apply
 (eqp_trans _ _ _ _ _ _ _ _ _ cs n)
  with
    (y := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec
            (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM)
               ltM_dec p q)
            (mults (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n))
               (mults (A:=A) multA (n:=n)
                  (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) a (b:=b)
                     nZb) r))); auto.
apply
 (eqp_trans _ _ _ _ _ _ _ _ _ cs n)
  with
    (y := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec
            p
            (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM)
               ltM_dec q
               (mults (A:=A) multA (n:=n)
                  (invTerm (A:=A) invA (n:=n) (T1 A1 n))
                  (mults (A:=A) multA (n:=n)
                     (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) a (b:=b)
                        nZb) r)))); auto.
apply
 (eqp_trans _ _ _ _ _ _ _ _ _ cs n)
  with
    (y := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec
            p
            (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM)
               ltM_dec
               (mults (A:=A) multA (n:=n)
                  (invTerm (A:=A) invA (n:=n) (T1 A1 n))
                  (mults (A:=A) multA (n:=n)
                     (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) a (b:=b)
                        nZb) r)) q)); auto.
apply eqp_pluspf_com with (1 := cs); auto.
apply
 (eqp_trans _ _ _ _ _ _ _ _ _ cs n)
  with
    (y := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec
            (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM)
               ltM_dec p
               (mults (A:=A) multA (n:=n)
                  (invTerm (A:=A) invA (n:=n) (T1 A1 n))
                  (mults (A:=A) multA (n:=n)
                     (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) a (b:=b)
                        nZb) r))) q); apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n);
 auto.
apply eqp_pluspf_com with (1 := cs); auto.
Qed.
Hint Resolve spminusf_pluspf.
 
Theorem eqptail_spminusf_com :
 forall (a b : Term A n) (nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b)
   (p q r : list (Term A n)),
 canonical A0 eqA ltM p ->
 canonical A0 eqA ltM q ->
 canonical A0 eqA ltM r ->
 eqP A eqA n p q ->
 divP A A0 eqA multA divA n a b ->
 eqP A eqA n (spminusf a b nZb p r) (spminusf a b nZb q r).
unfold spminusf in |- *; auto.
Qed.
 
Theorem eqTerm_spminusf_com :
 forall (a b c : Term A n) (nZc : ~ zeroP (A:=A) A0 eqA (n:=n) c)
   (p q : list (Term A n)),
 canonical A0 eqA ltM p ->
 canonical A0 eqA ltM q ->
 eqTerm (A:=A) eqA (n:=n) a b ->
 divP A A0 eqA multA divA n a c ->
 eqP A eqA n (spminusf a c nZc p q) (spminusf b c nZc p q).
intros a b c nZc p q H' H'0 H'1 H'2.
cut (divP A A0 eqA multA divA n b c); [ intros H'3 | auto ].
unfold spminusf in |- *; auto.
apply divP_eqTerm_comp with (1 := cs) (a := a); auto.
Qed.
 
Theorem eqp_spminusf_com :
 forall (a b c : Term A n) (nZc : ~ zeroP (A:=A) A0 eqA (n:=n) c)
   (p q r : list (Term A n)),
 canonical A0 eqA ltM p ->
 canonical A0 eqA ltM q ->
 canonical A0 eqA ltM r ->
 eqP A eqA n p q ->
 eqTerm (A:=A) eqA (n:=n) a b ->
 divP A A0 eqA multA divA n a c ->
 eqP A eqA n (spminusf a c nZc p r) (spminusf b c nZc q r).
intros a b c nZc p q r H' H'0 H'1 H'2 H'3 H'4.
apply (eqp_trans _ _ _ _ _ _ _ _ _ cs n) with (y := spminusf b c nZc p r);
 auto.
apply eqTerm_spminusf_com; auto.
apply eqptail_spminusf_com; auto.
apply divP_eqTerm_comp with (1 := cs) (a := a); auto.
Qed.
Hint Resolve eqTerm_spminusf_com eqp_spminusf_com eqp_spminusf_com.
 
Theorem spminusf_minuspf :
 forall (a b : Term A n) (nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b)
   (p q r : list (Term A n)),
 canonical A0 eqA ltM p ->
 canonical A0 eqA ltM q ->
 canonical A0 eqA ltM r ->
 divP A A0 eqA multA divA n a b ->
 eqP A eqA n
   (spminusf a b nZb
      (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q) r)
   (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec
      (spminusf a b nZb p r) q).
intros a b nZb p q r H' H'0 H'1 H'2; try assumption.
apply
 (eqp_trans _ _ _ _ _ _ _ _ _ cs n)
  with
    (y := spminusf a b nZb
            (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM)
               ltM_dec p
               (mults (A:=A) multA (n:=n)
                  (invTerm (A:=A) invA (n:=n) (T1 A1 n)) q)) r); 
 auto.
apply
 (eqp_trans _ _ _ _ _ _ _ _ _ cs n)
  with
    (y := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec
            (spminusf a b nZb p r)
            (mults (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n))
               q)); auto.
apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); auto.
Qed.
 
Theorem spminusf_plusTerm :
 forall (a b c : Term A n) (nZc : ~ zeroP (A:=A) A0 eqA (n:=n) c)
   (p q r : list (Term A n)),
 canonical A0 eqA ltM p ->
 canonical A0 eqA ltM q ->
 canonical A0 eqA ltM r ->
 divP A A0 eqA multA divA n a c ->
 divP A A0 eqA multA divA n b c ->
 eqT a b ->
 ~ zeroP (A:=A) A0 eqA (n:=n) (plusTerm (A:=A) plusA (n:=n) a b) ->
 eqP A eqA n
   (spminusf (plusTerm (A:=A) plusA (n:=n) a b) c nZc
      (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec p
         q) r)
   (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec
      (spminusf a c nZc p r) (spminusf b c nZc q r)).
intros a b c nZc p q r H' H'0 H'1 H'2 H'3 H'4 H'5; unfold spminusf in |- *.
apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n);
 apply
  (eqp_trans _ _ _ _ _ _ _ _ _ cs n)
   with
     (y := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM)
             ltM_dec
             (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM)
                ltM_dec p
                (mults (A:=A) multA (n:=n)
                   (invTerm (A:=A) invA (n:=n) (T1 A1 n))
                   (mults (A:=A) multA (n:=n)
                      (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) a
                         (b:=c) nZc) r)))
             (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM)
                ltM_dec q
                (mults (A:=A) multA (n:=n)
                   (invTerm (A:=A) invA (n:=n) (T1 A1 n))
                   (mults (A:=A) multA (n:=n)
                      (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) b
                         (b:=c) nZc) r)))); [ auto | idtac ].
apply eqp_pluspf_com with (1 := cs); auto.
apply
 (eqp_trans _ _ _ _ _ _ _ _ _ cs n)
  with
    (y := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec
            p
            (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM)
               ltM_dec
               (mults (A:=A) multA (n:=n)
                  (invTerm (A:=A) invA (n:=n) (T1 A1 n))
                  (mults (A:=A) multA (n:=n)
                     (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) a (b:=c)
                        nZc) r))
               (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM)
                  ltM_dec q
                  (mults (A:=A) multA (n:=n)
                     (invTerm (A:=A) invA (n:=n) (T1 A1 n))
                     (mults (A:=A) multA (n:=n)
                        (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) b
                           (b:=c) nZc) r))))); [ auto | idtac ].
apply pluspf_assoc with (1 := cs); auto.
apply
 (eqp_trans _ _ _ _ _ _ _ _ _ cs n)
  with
    (y := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec
            p
            (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM)
               ltM_dec
               (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM)
                  ltM_dec
                  (mults (A:=A) multA (n:=n)
                     (invTerm (A:=A) invA (n:=n) (T1 A1 n))
                     (mults (A:=A) multA (n:=n)
                        (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) a
                           (b:=c) nZc) r)) q)
               (mults (A:=A) multA (n:=n)
                  (invTerm (A:=A) invA (n:=n) (T1 A1 n))
                  (mults (A:=A) multA (n:=n)
                     (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) b (b:=c)
                        nZc) r)))).
apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); auto 8.
apply
 (eqp_trans _ _ _ _ _ _ _ _ _ cs n)
  with
    (y := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec
            p
            (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM)
               ltM_dec
               (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM)
                  ltM_dec q
                  (mults (A:=A) multA (n:=n)
                     (invTerm (A:=A) invA (n:=n) (T1 A1 n))
                     (mults (A:=A) multA (n:=n)
                        (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) a
                           (b:=c) nZc) r)))
               (mults (A:=A) multA (n:=n)
                  (invTerm (A:=A) invA (n:=n) (T1 A1 n))
                  (mults (A:=A) multA (n:=n)
                     (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) b (b:=c)
                        nZc) r)))); [ auto 8 | idtac ].
apply
 (eqp_trans _ _ _ _ _ _ _ _ _ cs n)
  with
    (y := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec
            p
            (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM)
               ltM_dec q
               (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM)
                  ltM_dec
                  (mults (A:=A) multA (n:=n)
                     (invTerm (A:=A) invA (n:=n) (T1 A1 n))
                     (mults (A:=A) multA (n:=n)
                        (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) a
                           (b:=c) nZc) r))
                  (mults (A:=A) multA (n:=n)
                     (invTerm (A:=A) invA (n:=n) (T1 A1 n))
                     (mults (A:=A) multA (n:=n)
                        (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) b
                           (b:=c) nZc) r))))); [ auto 10 | idtac ].
apply
 (eqp_trans _ _ _ _ _ _ _ _ _ cs n)
  with
    (y := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec
            (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM)
               ltM_dec p q)
            (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM)
               ltM_dec
               (mults (A:=A) multA (n:=n)
                  (invTerm (A:=A) invA (n:=n) (T1 A1 n))
                  (mults (A:=A) multA (n:=n)
                     (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) a (b:=c)
                        nZc) r))
               (mults (A:=A) multA (n:=n)
                  (invTerm (A:=A) invA (n:=n) (T1 A1 n))
                  (mults (A:=A) multA (n:=n)
                     (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) b (b:=c)
                        nZc) r)))).
apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); auto.
apply pluspf_assoc with (1 := cs); auto.
apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n);
 apply
  (eqp_trans _ _ _ _ _ _ _ _ _ cs n)
   with
     (y := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM)
             ltM_dec
             (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM)
                ltM_dec p q)
             (mults (A:=A) multA (n:=n)
                (invTerm (A:=A) invA (n:=n) (T1 A1 n))
                (mults (A:=A) multA (n:=n)
                   (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n)
                      (plusTerm (A:=A) plusA (n:=n) a b) (b:=c) nZc) r)));
 [ auto | idtac ].
apply eqp_pluspf_com with (1 := cs); auto.
apply
 (eqp_trans _ _ _ _ _ _ _ _ _ cs n)
  with
    (y := mults (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n))
            (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM)
               ltM_dec
               (mults (A:=A) multA (n:=n)
                  (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) a (b:=c)
                     nZc) r)
               (mults (A:=A) multA (n:=n)
                  (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) b (b:=c)
                     nZc) r))).
apply mults_comp with (1 := cs); auto.
apply
 (eqp_trans _ _ _ _ _ _ _ _ _ cs n)
  with
    (y := mults (A:=A) multA (n:=n)
            (plusTerm (A:=A) plusA (n:=n)
               (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) a (b:=c) nZc)
               (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) b (b:=c) nZc))
            r).
apply mults_comp with (1 := cs); auto.
apply eqT_divTerm_plusTerm with (1 := cs); auto.
inversion H'2; auto.
inversion H'3; auto.
apply mults_dist1 with (1 := cs); auto.
inversion H'2; inversion H'3; auto.
apply
 nzeroP_comp_eqTerm
  with
    (1 := cs)
    (a := divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n)
            (plusTerm (A:=A) plusA (n:=n) a b) (b:=c) nZc); 
 auto.
apply eqT_divTerm_plusTerm with (1 := cs); auto.
inversion H'2; inversion H'3; auto.
Qed.
 
Theorem spminusf_multTerm :
 forall (a b c : Term A n) (nZc : ~ zeroP (A:=A) A0 eqA (n:=n) c)
   (p q : list (Term A n)),
 canonical A0 eqA ltM p ->
 canonical A0 eqA ltM q ->
 divP A A0 eqA multA divA n b c ->
 ~ zeroP (A:=A) A0 eqA (n:=n) a ->
 eqP A eqA n
   (spminusf (multTerm (A:=A) multA (n:=n) a b) c nZc
      (mults (A:=A) multA (n:=n) a p) q)
   (mults (A:=A) multA (n:=n) a (spminusf b c nZc p q)).
intros a b c nZc p q H' H'0 H'1 H'2; unfold spminusf in |- *.
apply
 (eqp_trans _ _ _ _ _ _ _ _ _ cs n)
  with
    (y := minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec
            (mults (A:=A) multA (n:=n) a p)
            (mults (A:=A) multA (n:=n)
               (multTerm (A:=A) multA (n:=n) a
                  (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) b (b:=c)
                     nZc)) q)); [ auto | idtac ].
apply minuspf_comp with (1 := cs); auto.
apply canonical_mults with (1 := cs); auto.
apply
 nzeroP_comp_eqTerm
  with
    (1 := cs)
    (a := multTerm (A:=A) multA (n:=n) a
            (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) b (b:=c) nZc));
 auto.
apply (eqTerm_sym _ _ _ _ _ _ _ _ _ cs n);
 apply divTerm_multTerm_l with (1 := cs).
inversion H'1; auto.
apply
 (eqp_trans _ _ _ _ _ _ _ _ _ cs n)
  with
    (y := minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec
            (mults (A:=A) multA (n:=n) a p)
            (mults (A:=A) multA (n:=n) a
               (mults (A:=A) multA (n:=n)
                  (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) b (b:=c)
                     nZc) q))); [ auto | idtac ].
apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n);
 apply mults_dist_minuspf with (1 := cs); auto.
Qed.
Hint Resolve spminusf_plusTerm spminusf_multTerm.
 
Theorem spminusf_minusTerm_l :
 forall (a b : Term A n) (nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b)
   (p q r : list (Term A n)),
 canonical A0 eqA ltM p ->
 canonical A0 eqA ltM q ->
 canonical A0 eqA ltM r ->
 divP A A0 eqA multA divA n a b ->
 eqP A eqA n
   (spminusf a b nZb
      (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q) r)
   (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec
      (spminusf a b nZb p r) q).
intros a b nZb p q r H' H'0 H'1 H'2.
apply
 (eqp_trans _ _ _ _ _ _ _ _ _ cs n)
  with
    (y := spminusf a b nZb
            (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM)
               ltM_dec p
               (mults (A:=A) multA (n:=n)
                  (invTerm (A:=A) invA (n:=n) (T1 A1 n)) q)) r);
 [ auto | idtac ].
apply
 (eqp_trans _ _ _ _ _ _ _ _ _ cs n)
  with
    (y := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec
            (spminusf a b nZb p r)
            (mults (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n))
               q)); [ auto | idtac ].
apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); auto.
Qed.
 
Theorem spminusf_plusTerm_l :
 forall (a b : Term A n) (nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b)
   (p q r : list (Term A n)),
 canonical A0 eqA ltM p ->
 canonical A0 eqA ltM q ->
 canonical A0 eqA ltM r ->
 divP A A0 eqA multA divA n a b ->
 eqP A eqA n
   (spminusf a b nZb
      (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec p
         q) r)
   (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec
      (spminusf a b nZb p r) q).
intros a b nZb p q r H' H'0 H'1 H'2.
apply
 (eqp_trans _ _ _ _ _ _ _ _ _ cs n)
  with
    (y := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec
            (spminusf a b nZb p r) q); [ auto | idtac ].
apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); auto.
Qed.
 
Theorem spminusf_minusTerm_r :
 forall (a b : Term A n) (nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b)
   (p q r : list (Term A n)),
 canonical A0 eqA ltM p ->
 canonical A0 eqA ltM q ->
 canonical A0 eqA ltM r ->
 divP A A0 eqA multA divA n a b ->
 eqP A eqA n
   (spminusf a b nZb
      (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q) r)
   (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p
      (spminusf (invTerm (A:=A) invA (n:=n) a) b nZb q r)).
intros a b nZb p q r H' H'0 H'1 H'2; try assumption.
apply
 (eqp_trans _ _ _ _ _ _ _ _ _ cs n)
  with
    (y := spminusf a b nZb
            (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM)
               ltM_dec p
               (mults (A:=A) multA (n:=n)
                  (invTerm (A:=A) invA (n:=n) (T1 A1 n)) q)) r);
 [ auto | idtac ].
apply
 (eqp_trans _ _ _ _ _ _ _ _ _ cs n)
  with
    (y := spminusf a b nZb
            (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM)
               ltM_dec
               (mults (A:=A) multA (n:=n)
                  (invTerm (A:=A) invA (n:=n) (T1 A1 n)) q) p) r);
 [ auto | idtac ].
apply
 (eqp_trans _ _ _ _ _ _ _ _ _ cs n)
  with
    (y := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec
            (spminusf a b nZb
               (mults (A:=A) multA (n:=n)
                  (invTerm (A:=A) invA (n:=n) (T1 A1 n)) q) r) p);
 [ auto | idtac ].
apply
 (eqp_trans _ _ _ _ _ _ _ _ _ cs n)
  with
    (y := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec
            p
            (spminusf a b nZb
               (mults (A:=A) multA (n:=n)
                  (invTerm (A:=A) invA (n:=n) (T1 A1 n)) q) r));
 [ auto | idtac ].
apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n);
 apply
  (eqp_trans _ _ _ _ _ _ _ _ _ cs n)
   with
     (y := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM)
             ltM_dec p
             (mults (A:=A) multA (n:=n)
                (invTerm (A:=A) invA (n:=n) (T1 A1 n))
                (spminusf (invTerm (A:=A) invA (n:=n) a) b nZb q r)));
 [ auto | idtac ].
apply eqp_pluspf_com with (1 := cs); auto.
apply
 (eqp_trans _ _ _ _ _ _ _ _ _ cs n)
  with
    (y := spminusf
            (multTerm (A:=A) multA (n:=n)
               (invTerm (A:=A) invA (n:=n) (T1 A1 n))
               (invTerm (A:=A) invA (n:=n) a)) b nZb
            (mults (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n))
               q) r);
 [ apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); auto | idtac ].
apply
 (eqp_trans _ _ _ _ _ _ _ _ _ cs n)
  with
    (y := spminusf
            (invTerm (A:=A) invA (n:=n)
               (multTerm (A:=A) multA (n:=n) (T1 A1 n)
                  (invTerm (A:=A) invA (n:=n) a))) b nZb
            (mults (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n))
               q) r); [ auto | idtac ].
apply eqTerm_spminusf_com; auto.
apply
 (divP_trans _ _ _ _ _ _ _ _ _ cs n) with (y := invTerm (A:=A) invA (n:=n) a);
 auto.
apply divTerm_multTermr with (1 := cs); auto.
apply nZero_invTerm_nZero with (1 := cs); auto.
apply divP_inv1 with (1 := H'2); auto.
apply
 (eqp_trans _ _ _ _ _ _ _ _ _ cs n)
  with
    (y := spminusf
            (invTerm (A:=A) invA (n:=n) (invTerm (A:=A) invA (n:=n) a)) b nZb
            (mults (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n))
               q) r); auto.
apply eqp_spminusf_com; auto.
apply (eqTerm_sym _ _ _ _ _ _ _ _ _ cs n); auto.
apply divP_invTerm_l with (1 := cs); auto.
apply divP_eqTerm_comp with (a := invTerm (A:=A) invA (n:=n) a) (1 := cs);
 auto.
apply eqTerm_spminusf_com; auto.
apply (eqTerm_sym _ _ _ _ _ _ _ _ _ cs n); auto.
Qed.
Hint Resolve spminusf_minusTerm_r.
 
Theorem spminusf_plusTerm_r :
 forall (a b : Term A n) (nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b)
   (p q r : list (Term A n)),
 canonical A0 eqA ltM p ->
 canonical A0 eqA ltM q ->
 canonical A0 eqA ltM r ->
 divP A A0 eqA multA divA n a b ->
 eqP A eqA n
   (spminusf a b nZb
      (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec p
         q) r)
   (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec p
      (spminusf a b nZb q r)).
intros a b nZb p q r H' H'0 H'1 H'2; try assumption.
apply
 (eqp_trans _ _ _ _ _ _ _ _ _ cs n)
  with
    (y := spminusf a b nZb
            (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM)
               ltM_dec q p) r); [ auto | idtac ].
apply
 (eqp_trans _ _ _ _ _ _ _ _ _ cs n)
  with
    (y := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec
            (spminusf a b nZb q r) p); [ auto | idtac ].
apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); auto.
Qed.
Hint Resolve spminusf_plusTerm_r.
 
Theorem divP_minusTerm_comp :
 forall a b c : Term A n,
 divP A A0 eqA multA divA n a c ->
 divP A A0 eqA multA divA n b c ->
 eqT a b ->
 ~ zeroP (A:=A) A0 eqA (n:=n) (minusTerm (A:=A) minusA (n:=n) a b) ->
 divP A A0 eqA multA divA n (minusTerm (A:=A) minusA (n:=n) a b) c.
intros a b c H' H'0 H'1 H'2.
apply
 divP_eqTerm_comp
  with
    (a := plusTerm (A:=A) plusA (n:=n) a (invTerm (A:=A) invA (n:=n) b))
    (1 := cs); auto.
apply divP_plusTerm with (1 := cs); auto.
apply (eqT_trans A n) with (1 := H'1); auto.
apply
 nzeroP_comp_eqTerm with (1 := cs) (a := minusTerm (A:=A) minusA (n:=n) a b);
 auto.
apply (eqTerm_sym _ _ _ _ _ _ _ _ _ cs n); auto.
Qed.
Hint Resolve divP_minusTerm_comp.
 
Theorem spminusf_minusTerm :
 forall (a b c : Term A n) (nZc : ~ zeroP (A:=A) A0 eqA (n:=n) c)
   (p q r : list (Term A n)),
 canonical A0 eqA ltM p ->
 canonical A0 eqA ltM q ->
 canonical A0 eqA ltM r ->
 divP A A0 eqA multA divA n a c ->
 divP A A0 eqA multA divA n b c ->
 eqT a b ->
 ~ zeroP (A:=A) A0 eqA (n:=n) (minusTerm (A:=A) minusA (n:=n) a b) ->
 eqP A eqA n
   (spminusf (minusTerm (A:=A) minusA (n:=n) a b) c nZc
      (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q) r)
   (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec
      (spminusf a c nZc p r) (spminusf b c nZc q r)).
intros a b c nZc p q r H' H'0 H'1 H'2 H'3 H'4 H'5.
apply
 (eqp_trans _ _ _ _ _ _ _ _ _ cs n)
  with
    (y := spminusf
            (plusTerm (A:=A) plusA (n:=n) a (invTerm (A:=A) invA (n:=n) b)) c
            nZc
            (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q)
            r); [ auto | idtac ].
apply
 (eqp_trans _ _ _ _ _ _ _ _ _ cs n)
  with
    (y := spminusf
            (plusTerm (A:=A) plusA (n:=n) a (invTerm (A:=A) invA (n:=n) b)) c
            nZc
            (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM)
               ltM_dec p
               (mults (A:=A) multA (n:=n)
                  (invTerm (A:=A) invA (n:=n) (T1 A1 n)) q)) r);
 [ auto | idtac ].
apply eqp_spminusf_com; auto.
apply
 divP_eqTerm_comp with (a := minusTerm (A:=A) minusA (n:=n) a b) (1 := cs);
 auto.
apply
 (eqp_trans _ _ _ _ _ _ _ _ _ cs n)
  with
    (y := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec
            (spminusf a c nZc p r)
            (spminusf (invTerm (A:=A) invA (n:=n) b) c nZc
               (mults (A:=A) multA (n:=n)
                  (invTerm (A:=A) invA (n:=n) (T1 A1 n)) q) r));
 [ auto | idtac ].
apply spminusf_plusTerm; auto.
apply (eqT_trans A n) with (1 := H'4); auto.
apply
 nzeroP_comp_eqTerm with (1 := cs) (a := minusTerm (A:=A) minusA (n:=n) a b);
 auto.
apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n);
 apply
  (eqp_trans _ _ _ _ _ _ _ _ _ cs n)
   with
     (y := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM)
             ltM_dec (spminusf a c nZc p r)
             (mults (A:=A) multA (n:=n)
                (invTerm (A:=A) invA (n:=n) (T1 A1 n)) 
                (spminusf b c nZc q r))); [ auto | idtac ].
apply eqp_pluspf_com with (1 := cs); auto.
apply
 (eqp_trans _ _ _ _ _ _ _ _ _ cs n)
  with
    (y := spminusf
            (multTerm (A:=A) multA (n:=n)
               (invTerm (A:=A) invA (n:=n) (T1 A1 n)) b) c nZc
            (mults (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n))
               q) r); [ auto | idtac ].
apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); auto.
apply
 (eqp_trans _ _ _ _ _ _ _ _ _ cs n)
  with
    (y := spminusf
            (invTerm (A:=A) invA (n:=n)
               (multTerm (A:=A) multA (n:=n) (T1 A1 n) b)) c nZc
            (mults (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n))
               q) r); [ auto | auto ].
apply eqTerm_spminusf_com; auto.
apply (divP_trans _ _ _ _ _ _ _ _ _ cs n) with (y := b); auto.
apply divTerm_multTermr with (1 := cs); auto.
inversion H'3; auto.
apply eqTerm_spminusf_com; auto.
apply (eqTerm_sym _ _ _ _ _ _ _ _ _ cs n); auto.
apply (divP_trans _ _ _ _ _ _ _ _ _ cs n) with (y := b); auto.
inversion H'3; auto.
Qed.
 
Theorem spminusf_minusTerm_z :
 forall (a b c : Term A n) (nZc : ~ zeroP (A:=A) A0 eqA (n:=n) c)
   (p q r : list (Term A n)),
 canonical A0 eqA ltM p ->
 canonical A0 eqA ltM q ->
 canonical A0 eqA ltM r ->
 divP A A0 eqA multA divA n a c ->
 divP A A0 eqA multA divA n b c ->
 eqT a b ->
 zeroP (A:=A) A0 eqA (n:=n) (minusTerm (A:=A) minusA (n:=n) a b) ->
 eqP A eqA n
   (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q)
   (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec
      (spminusf a c nZc p r) (spminusf b c nZc q r)).
intros a b c nZc p q r H' H'0 H'1 H'2 H'3 H'4 H'5.
apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n);
 apply
  (eqp_trans _ _ _ _ _ _ _ _ _ cs n)
   with
     (y := minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec
             (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p
                (mults (A:=A) multA (n:=n)
                   (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) a (b:=c)
                      nZc) r))
             (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec q
                (mults (A:=A) multA (n:=n)
                   (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) b (b:=c)
                      nZc) r))); [ auto | idtac ].
apply
 (eqp_trans _ _ _ _ _ _ _ _ _ cs n)
  with
    (y := minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec
            (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM)
               ltM_dec p
               (mults (A:=A) multA (n:=n)
                  (invTerm (A:=A) invA (n:=n) (T1 A1 n))
                  (mults (A:=A) multA (n:=n)
                     (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) a (b:=c)
                        nZc) r)))
            (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM)
               ltM_dec q
               (mults (A:=A) multA (n:=n)
                  (invTerm (A:=A) invA (n:=n) (T1 A1 n))
                  (mults (A:=A) multA (n:=n)
                     (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) b (b:=c)
                        nZc) r)))).
apply minuspf_comp with (1 := cs); auto.
apply
 (eqp_trans _ _ _ _ _ _ _ _ _ cs n)
  with
    (y := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec
            (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM)
               ltM_dec p
               (mults (A:=A) multA (n:=n)
                  (invTerm (A:=A) invA (n:=n) (T1 A1 n))
                  (mults (A:=A) multA (n:=n)
                     (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) a (b:=c)
                        nZc) r)))
            (mults (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n))
               (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM)
                  ltM_dec q
                  (mults (A:=A) multA (n:=n)
                     (invTerm (A:=A) invA (n:=n) (T1 A1 n))
                     (mults (A:=A) multA (n:=n)
                        (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) b
                           (b:=c) nZc) r))))); [ auto | idtac ].
apply
 (eqp_trans _ _ _ _ _ _ _ _ _ cs n)
  with
    (y := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec
            (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM)
               ltM_dec p
               (mults (A:=A) multA (n:=n)
                  (invTerm (A:=A) invA (n:=n) (T1 A1 n))
                  (mults (A:=A) multA (n:=n)
                     (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) a (b:=c)
                        nZc) r)))
            (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM)
               ltM_dec
               (mults (A:=A) multA (n:=n)
                  (invTerm (A:=A) invA (n:=n) (T1 A1 n)) q)
               (mults (A:=A) multA (n:=n)
                  (invTerm (A:=A) invA (n:=n) (T1 A1 n))
                  (mults (A:=A) multA (n:=n)
                     (invTerm (A:=A) invA (n:=n) (T1 A1 n))
                     (mults (A:=A) multA (n:=n)
                        (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) b
                           (b:=c) nZc) r))))); [ auto | idtac ].
apply eqp_pluspf_com with (1 := cs); auto.
apply canonical_mults with (1 := cs); auto.
apply canonical_pluspf; auto.
apply
 (eqp_trans _ _ _ _ _ _ _ _ _ cs n)
  with
    (y := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec
            p
            (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM)
               ltM_dec
               (mults (A:=A) multA (n:=n)
                  (invTerm (A:=A) invA (n:=n) (T1 A1 n))
                  (mults (A:=A) multA (n:=n)
                     (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) a (b:=c)
                        nZc) r))
               (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM)
                  ltM_dec
                  (mults (A:=A) multA (n:=n)
                     (invTerm (A:=A) invA (n:=n) (T1 A1 n)) q)
                  (mults (A:=A) multA (n:=n)
                     (invTerm (A:=A) invA (n:=n) (T1 A1 n))
                     (mults (A:=A) multA (n:=n)
                        (invTerm (A:=A) invA (n:=n) (T1 A1 n))
                        (mults (A:=A) multA (n:=n)
                           (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) b
                              (b:=c) nZc) r)))))).
apply pluspf_assoc with (1 := cs); auto.
apply canonical_pluspf; auto.
apply
 (eqp_trans _ _ _ _ _ _ _ _ _ cs n)
  with
    (y := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec
            p
            (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM)
               ltM_dec
               (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM)
                  ltM_dec
                  (mults (A:=A) multA (n:=n)
                     (invTerm (A:=A) invA (n:=n) (T1 A1 n))
                     (mults (A:=A) multA (n:=n)
                        (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) a
                           (b:=c) nZc) r))
                  (mults (A:=A) multA (n:=n)
                     (invTerm (A:=A) invA (n:=n) (T1 A1 n)) q))
               (mults (A:=A) multA (n:=n)
                  (invTerm (A:=A) invA (n:=n) (T1 A1 n))
                  (mults (A:=A) multA (n:=n)
                     (invTerm (A:=A) invA (n:=n) (T1 A1 n))
                     (mults (A:=A) multA (n:=n)
                        (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) b
                           (b:=c) nZc) r))))).
apply eqp_pluspf_com with (1 := cs); auto.
apply canonical_pluspf; auto.
apply canonical_pluspf; auto.
apply canonical_pluspf; auto.
apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); apply pluspf_assoc with (1 := cs);
 auto.
apply
 (eqp_trans _ _ _ _ _ _ _ _ _ cs n)
  with
    (y := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec
            p
            (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM)
               ltM_dec
               (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM)
                  ltM_dec
                  (mults (A:=A) multA (n:=n)
                     (invTerm (A:=A) invA (n:=n) (T1 A1 n)) q)
                  (mults (A:=A) multA (n:=n)
                     (invTerm (A:=A) invA (n:=n) (T1 A1 n))
                     (mults (A:=A) multA (n:=n)
                        (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) a
                           (b:=c) nZc) r)))
               (mults (A:=A) multA (n:=n)
                  (invTerm (A:=A) invA (n:=n) (T1 A1 n))
                  (mults (A:=A) multA (n:=n)
                     (invTerm (A:=A) invA (n:=n) (T1 A1 n))
                     (mults (A:=A) multA (n:=n)
                        (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) b
                           (b:=c) nZc) r))))).
apply eqp_pluspf_com with (1 := cs); auto.
apply canonical_pluspf; auto.
apply canonical_pluspf; auto.
apply eqp_pluspf_com with (1 := cs); auto.
apply
 (eqp_trans _ _ _ _ _ _ _ _ _ cs n)
  with
    (y := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec
            (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM)
               ltM_dec p
               (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM)
                  ltM_dec
                  (mults (A:=A) multA (n:=n)
                     (invTerm (A:=A) invA (n:=n) (T1 A1 n)) q)
                  (mults (A:=A) multA (n:=n)
                     (invTerm (A:=A) invA (n:=n) (T1 A1 n))
                     (mults (A:=A) multA (n:=n)
                        (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) a
                           (b:=c) nZc) r))))
            (mults (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n))
               (mults (A:=A) multA (n:=n)
                  (invTerm (A:=A) invA (n:=n) (T1 A1 n))
                  (mults (A:=A) multA (n:=n)
                     (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) b (b:=c)
                        nZc) r)))).
apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); apply pluspf_assoc with (1 := cs);
 auto.
apply
 (eqp_trans _ _ _ _ _ _ _ _ _ cs n)
  with
    (y := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec
            (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM)
               ltM_dec
               (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p
                  q)
               (mults (A:=A) multA (n:=n)
                  (invTerm (A:=A) invA (n:=n) (T1 A1 n))
                  (mults (A:=A) multA (n:=n)
                     (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) a (b:=c)
                        nZc) r)))
            (mults (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n))
               (mults (A:=A) multA (n:=n)
                  (invTerm (A:=A) invA (n:=n) (T1 A1 n))
                  (mults (A:=A) multA (n:=n)
                     (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) b (b:=c)
                        nZc) r)))).
apply eqp_pluspf_com with (1 := cs); auto.
apply canonical_pluspf; auto.
apply
 (eqp_trans _ _ _ _ _ _ _ _ _ cs n)
  with
    (y := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec
            (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM)
               ltM_dec p
               (mults (A:=A) multA (n:=n)
                  (invTerm (A:=A) invA (n:=n) (T1 A1 n)) q))
            (mults (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n))
               (mults (A:=A) multA (n:=n)
                  (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) a (b:=c)
                     nZc) r))).
apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); apply pluspf_assoc with (1 := cs);
 auto.
apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); auto.
apply
 (eqp_trans _ _ _ _ _ _ _ _ _ cs n)
  with
    (y := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec
            (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q)
            (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM)
               ltM_dec
               (mults (A:=A) multA (n:=n)
                  (invTerm (A:=A) invA (n:=n) (T1 A1 n))
                  (mults (A:=A) multA (n:=n)
                     (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) a (b:=c)
                        nZc) r))
               (mults (A:=A) multA (n:=n)
                  (invTerm (A:=A) invA (n:=n) (T1 A1 n))
                  (mults (A:=A) multA (n:=n)
                     (invTerm (A:=A) invA (n:=n) (T1 A1 n))
                     (mults (A:=A) multA (n:=n)
                        (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) b
                           (b:=c) nZc) r))))).
apply pluspf_assoc with (1 := cs); auto.
apply
 (eqp_trans _ _ _ _ _ _ _ _ _ cs n)
  with
    (y := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec
            (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q)
            (mults (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n))
               (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM)
                  ltM_dec
                  (mults (A:=A) multA (n:=n)
                     (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) a (b:=c)
                        nZc) r)
                  (mults (A:=A) multA (n:=n)
                     (invTerm (A:=A) invA (n:=n) (T1 A1 n))
                     (mults (A:=A) multA (n:=n)
                        (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) b
                           (b:=c) nZc) r))))).
apply eqp_pluspf_com with (1 := cs); auto.
apply canonical_pluspf; auto.
apply canonical_mults with (1 := cs); auto.
apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); auto.
apply
 (eqp_trans _ _ _ _ _ _ _ _ _ cs n)
  with
    (y := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec
            (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q)
            (mults (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n))
               (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec
                  (mults (A:=A) multA (n:=n)
                     (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) a (b:=c)
                        nZc) r)
                  (mults (A:=A) multA (n:=n)
                     (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) b (b:=c)
                        nZc) r)))).
apply eqp_pluspf_com with (1 := cs); auto.
apply canonical_mults with (1 := cs); auto.
apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); auto.
apply
 (eqp_trans _ _ _ _ _ _ _ _ _ cs n)
  with
    (y := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec
            (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q)
            (mults (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n))
               (pO A n))).
apply eqp_pluspf_com with (1 := cs); auto.
apply mults_comp with (1 := cs); auto.
apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); apply mults_pO with (1 := cs); auto.
2: simpl in |- *; auto.
apply
 zeroP_comp_eqTerm
  with
    (1 := cs)
    (a := divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n)
            (minusTerm (A:=A) minusA (n:=n) a b) (b:=c) nZc); 
 auto.
apply zeroP_divTerm with (1 := cs); auto.
apply
 (eqTerm_trans _ _ _ _ _ _ _ _ _ cs n)
  with
    (y := divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n)
            (plusTerm (A:=A) plusA (n:=n) a (invTerm (A:=A) invA (n:=n) b))
            (b:=c) nZc); auto.
apply
 (eqTerm_trans _ _ _ _ _ _ _ _ _ cs n)
  with
    (y := plusTerm (A:=A) plusA (n:=n)
            (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) a (b:=c) nZc)
            (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n)
               (invTerm (A:=A) invA (n:=n) b) (b:=c) nZc)); 
 auto.
apply eqT_divTerm_plusTerm with (1 := cs); auto.
apply (eqT_trans A n) with (1 := H'4); auto.
apply
 (eqTerm_trans _ _ _ _ _ _ _ _ _ cs n)
  with
    (y := plusTerm (A:=A) plusA (n:=n)
            (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) a (b:=c) nZc)
            (invTerm (A:=A) invA (n:=n)
               (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) b (b:=c) nZc)));
 auto.
apply eqTerm_plusTerm_comp with (1 := cs); auto.
apply eqT_divTerm; auto.
apply (eqT_trans A n) with (1 := H'4); auto.
apply
 (eqT_trans A n)
  with (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) b (b:=c) nZc); 
 auto.
apply divTerm_invTerm_l with (1 := cs); auto.
apply (eqTerm_sym _ _ _ _ _ _ _ _ _ cs n); auto.
Qed.
Hint Resolve spminusf_minusTerm.
 
Theorem spminusf_plusTerm_z :
 forall (a b c : Term A n) (nZc : ~ zeroP (A:=A) A0 eqA (n:=n) c)
   (p q r : list (Term A n)),
 canonical A0 eqA ltM p ->
 canonical A0 eqA ltM q ->
 canonical A0 eqA ltM r ->
 divP A A0 eqA multA divA n a c ->
 divP A A0 eqA multA divA n b c ->
 eqT a b ->
 zeroP (A:=A) A0 eqA (n:=n) (plusTerm (A:=A) plusA (n:=n) a b) ->
 eqP A eqA n
   (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec p q)
   (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec
      (spminusf a c nZc p r) (spminusf b c nZc q r)).
intros a b c nZc p q r H' H'0 H'1 H'2 H'3 H'4 H'5.
apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n);
 apply
  (eqp_trans _ _ _ _ _ _ _ _ _ cs n)
   with
     (y := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM)
             ltM_dec
             (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p
                (mults (A:=A) multA (n:=n)
                   (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) a (b:=c)
                      nZc) r))
             (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec q
                (mults (A:=A) multA (n:=n)
                   (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) b (b:=c)
                      nZc) r))); [ auto | idtac ].
apply
 (eqp_trans _ _ _ _ _ _ _ _ _ cs n)
  with
    (y := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec
            (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM)
               ltM_dec p
               (mults (A:=A) multA (n:=n)
                  (invTerm (A:=A) invA (n:=n) (T1 A1 n))
                  (mults (A:=A) multA (n:=n)
                     (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) a (b:=c)
                        nZc) r)))
            (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM)
               ltM_dec q
               (mults (A:=A) multA (n:=n)
                  (invTerm (A:=A) invA (n:=n) (T1 A1 n))
                  (mults (A:=A) multA (n:=n)
                     (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) b (b:=c)
                        nZc) r)))).
apply eqp_pluspf_com with (1 := cs); auto.
apply
 (eqp_trans _ _ _ _ _ _ _ _ _ cs n)
  with
    (y := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec
            p
            (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM)
               ltM_dec
               (mults (A:=A) multA (n:=n)
                  (invTerm (A:=A) invA (n:=n) (T1 A1 n))
                  (mults (A:=A) multA (n:=n)
                     (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) a (b:=c)
                        nZc) r))
               (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM)
                  ltM_dec q
                  (mults (A:=A) multA (n:=n)
                     (invTerm (A:=A) invA (n:=n) (T1 A1 n))
                     (mults (A:=A) multA (n:=n)
                        (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) b
                           (b:=c) nZc) r))))).
apply pluspf_assoc with (1 := cs); auto.
apply
 (eqp_trans _ _ _ _ _ _ _ _ _ cs n)
  with
    (y := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec
            p
            (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM)
               ltM_dec
               (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM)
                  ltM_dec
                  (mults (A:=A) multA (n:=n)
                     (invTerm (A:=A) invA (n:=n) (T1 A1 n))
                     (mults (A:=A) multA (n:=n)
                        (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) a
                           (b:=c) nZc) r)) q)
               (mults (A:=A) multA (n:=n)
                  (invTerm (A:=A) invA (n:=n) (T1 A1 n))
                  (mults (A:=A) multA (n:=n)
                     (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) b (b:=c)
                        nZc) r)))).
apply eqp_pluspf_com with (1 := cs); auto.
apply canonical_pluspf; auto.
apply canonical_pluspf; auto.
apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); apply pluspf_assoc with (1 := cs);
 auto.
apply
 (eqp_trans _ _ _ _ _ _ _ _ _ cs n)
  with
    (y := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec
            p
            (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM)
               ltM_dec
               (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM)
                  ltM_dec q
                  (mults (A:=A) multA (n:=n)
                     (invTerm (A:=A) invA (n:=n) (T1 A1 n))
                     (mults (A:=A) multA (n:=n)
                        (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) a
                           (b:=c) nZc) r)))
               (mults (A:=A) multA (n:=n)
                  (invTerm (A:=A) invA (n:=n) (T1 A1 n))
                  (mults (A:=A) multA (n:=n)
                     (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) b (b:=c)
                        nZc) r)))).
apply eqp_pluspf_com with (1 := cs); auto.
apply canonical_pluspf; auto.
apply canonical_pluspf; auto.
apply eqp_pluspf_com with (1 := cs); auto.
apply
 (eqp_trans _ _ _ _ _ _ _ _ _ cs n)
  with
    (y := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec
            (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM)
               ltM_dec p
               (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM)
                  ltM_dec q
                  (mults (A:=A) multA (n:=n)
                     (invTerm (A:=A) invA (n:=n) (T1 A1 n))
                     (mults (A:=A) multA (n:=n)
                        (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) a
                           (b:=c) nZc) r))))
            (mults (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n))
               (mults (A:=A) multA (n:=n)
                  (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) b (b:=c)
                     nZc) r))).
apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); apply pluspf_assoc with (1 := cs);
 auto.
apply
 (eqp_trans _ _ _ _ _ _ _ _ _ cs n)
  with
    (y := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec
            (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM)
               ltM_dec
               (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM)
                  ltM_dec p q)
               (mults (A:=A) multA (n:=n)
                  (invTerm (A:=A) invA (n:=n) (T1 A1 n))
                  (mults (A:=A) multA (n:=n)
                     (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) a (b:=c)
                        nZc) r)))
            (mults (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n))
               (mults (A:=A) multA (n:=n)
                  (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) b (b:=c)
                     nZc) r))).
apply eqp_pluspf_com with (1 := cs); auto.
apply canonical_pluspf; auto.
apply
 (eqp_trans _ _ _ _ _ _ _ _ _ cs n)
  with
    (y := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec
            (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM)
               ltM_dec p q)
            (mults (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n))
               (mults (A:=A) multA (n:=n)
                  (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) a (b:=c)
                     nZc) r))).
apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); apply pluspf_assoc with (1 := cs);
 auto.
apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); auto.
apply
 (eqp_trans _ _ _ _ _ _ _ _ _ cs n)
  with
    (y := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec
            (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM)
               ltM_dec p q)
            (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM)
               ltM_dec
               (mults (A:=A) multA (n:=n)
                  (invTerm (A:=A) invA (n:=n) (T1 A1 n))
                  (mults (A:=A) multA (n:=n)
                     (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) a (b:=c)
                        nZc) r))
               (mults (A:=A) multA (n:=n)
                  (invTerm (A:=A) invA (n:=n) (T1 A1 n))
                  (mults (A:=A) multA (n:=n)
                     (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) b (b:=c)
                        nZc) r)))).
apply pluspf_assoc with (1 := cs); auto.
apply
 (eqp_trans _ _ _ _ _ _ _ _ _ cs n)
  with
    (y := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec
            (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM)
               ltM_dec p q)
            (mults (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n))
               (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM)
                  ltM_dec
                  (mults (A:=A) multA (n:=n)
                     (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) a (b:=c)
                        nZc) r)
                  (mults (A:=A) multA (n:=n)
                     (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) b (b:=c)
                        nZc) r)))).
apply eqp_pluspf_com with (1 := cs); auto.
apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); auto.
apply
 (eqp_trans _ _ _ _ _ _ _ _ _ cs n)
  with
    (y := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec
            (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM)
               ltM_dec p q)
            (mults (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n))
               (pO A n))).
apply eqp_pluspf_com with (1 := cs); auto.
apply mults_comp with (1 := cs); auto.
2: simpl in |- *; auto.
cut
 (eqTerm (A:=A) eqA (n:=n)
    (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) b (b:=c) nZc)
    (invTerm (A:=A) invA (n:=n)
       (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) a (b:=c) nZc)));
 [ intros eqTerm0 | idtac ].
apply
 (eqp_trans _ _ _ _ _ _ _ _ _ cs n)
  with
    (y := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec
            (mults (A:=A) multA (n:=n)
               (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) a (b:=c) nZc)
               r)
            (mults (A:=A) multA (n:=n)
               (invTerm (A:=A) invA (n:=n)
                  (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) a (b:=c)
                     nZc)) r)).
apply eqp_pluspf_com with (1 := cs); auto.
apply
 (eqp_trans _ _ _ _ _ _ _ _ _ cs n)
  with
    (y := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec
            (mults (A:=A) multA (n:=n)
               (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) a (b:=c) nZc)
               r)
            (mults (A:=A) multA (n:=n)
               (invTerm (A:=A) invA (n:=n)
                  (multTerm (A:=A) multA (n:=n) (T1 A1 n)
                     (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) a (b:=c)
                        nZc))) r)).
apply eqp_pluspf_com with (1 := cs); auto.
apply
 (eqp_trans _ _ _ _ _ _ _ _ _ cs n)
  with
    (y := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec
            (mults (A:=A) multA (n:=n)
               (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) a (b:=c) nZc)
               r)
            (mults (A:=A) multA (n:=n)
               (multTerm (A:=A) multA (n:=n)
                  (invTerm (A:=A) invA (n:=n) (T1 A1 n))
                  (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) a (b:=c)
                     nZc)) r)).
apply eqp_pluspf_com with (1 := cs); auto.
apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); auto.
apply
 (eqp_trans _ _ _ _ _ _ _ _ _ cs n)
  with
    (y := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec
            (mults (A:=A) multA (n:=n)
               (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) a (b:=c) nZc)
               r)
            (mults (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n))
               (mults (A:=A) multA (n:=n)
                  (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) a (b:=c)
                     nZc) r))).
apply eqp_pluspf_com with (1 := cs); auto.
apply mults_invTerm with (1 := cs); auto.
inversion H'2; inversion H'3; auto.
apply
 (eqTerm_trans _ _ _ _ _ _ _ _ _ cs n)
  with
    (y := divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n)
            (invTerm (A:=A) invA (n:=n) a) (b:=c) nZc); 
 auto.
apply eqTerm_divTerm_comp with (1 := cs); auto.
apply zerop_is_eqTerm with (1 := cs); auto.
apply (eqT_sym A n); apply (eqT_trans A n) with (2 := H'4); auto;
 apply (eqT_sym A n); auto.
apply
 zeroP_comp_eqTerm
  with
    (1 := cs)
    (a := plusTerm (A:=A) plusA (n:=n) b
            (invTerm (A:=A) invA (n:=n) (invTerm (A:=A) invA (n:=n) a)));
 auto.
apply
 zeroP_comp_eqTerm with (1 := cs) (a := plusTerm (A:=A) plusA (n:=n) b a);
 auto.
apply
 zeroP_comp_eqTerm with (1 := cs) (a := plusTerm (A:=A) plusA (n:=n) a b);
 auto.
apply plusTerm_com with (1 := cs); auto.
apply eqTerm_plusTerm_comp with (1 := cs); auto.
apply (eqT_sym A n); auto.
apply (eqT_sym A n); apply (eqT_trans A n) with (2 := H'4); auto;
 apply (eqT_sym A n); auto.
apply (eqTerm_imp_eqT A eqA); auto.
apply (eqTerm_sym _ _ _ _ _ _ _ _ _ cs n); auto.
apply divTerm_invTerm_l with (1 := cs); auto.
Qed.
Hint Resolve spminusf_minusTerm.
 
Theorem ltP_divP_pX :
 forall (a b : Term A n) (p q : list (Term A n)),
 canonical A0 eqA ltM (pX a p) ->
 canonical A0 eqA ltM (pX b q) ->
 divP A A0 eqA multA divA n a b -> ltP (A:=A) (n:=n) ltM q (pX a p).
intros a b p; case p; auto.
intros q H' H'0 H'1; try assumption.
change (ltP (A:=A) (n:=n) ltM q (pX a (pO A n))) in |- *; auto.
apply (canonical_pX_ltP A A0 eqA); apply divP_ltT_comp with (b := b); auto.
intros a0 l q H' H'0 H'1; apply ltP_trans with (y := pX a (pO A n)); auto.
apply (canonical_pX_ltP A A0 eqA); apply divP_ltT_comp with (b := b); auto.
change (ltP (A:=A) (n:=n) ltM (pX a (pO A n)) (pX a (pX a0 l))) in |- *; auto.
Qed.
End Pspminus.