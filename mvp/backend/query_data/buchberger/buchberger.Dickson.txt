

Require Import List.

Require Import Bar.
(* Bar:
Require Import List.

Definition Pred (A : Set) := A -> Prop.

Definition Rel (A : Set) := A -> A -> Prop.

Inductive ExistsL (A : Set) (P : Pred A) : list A -> Set :=
  | FoundE : forall (a : A) (l : list A), P a -> ExistsL A P (a :: l)
  | SearchE :
      forall (a : A) (l : list A), ExistsL A P l -> ExistsL A P (a :: l).
Hint Resolve FoundE SearchE.

Lemma monExistsL1 :
 forall (A : Set) (P : Pred A) (xs bs : list A),
 ExistsL A P bs -> ExistsL A P (xs ++ bs).
Hint Resolve monExistsL1.

Lemma monExistsL :
 forall (A : Set) (P : Pred A) (xs bs cs : list A),
 ExistsL A P (xs ++ bs) -> ExistsL A P (xs ++ cs ++ bs).
Hint Resolve monExistsL.

Inductive GoodR (A : Set) (R : Rel A) : list A -> Set :=
  | FoundG :
      forall (a : A) (l : list A),
      ExistsL A (fun x : A => R x a) l -> GoodR A R (a :: l)
  | SearchG : forall (a : A) (l : list A), GoodR A R l -> GoodR A R (a :: l).
Hint Resolve FoundG SearchG.

Lemma monGoodR1 :
 forall (A : Set) (R : Rel A) (xs bs : list A),
 GoodR A R bs -> GoodR A R (xs ++ bs).
Hint Resolve monGoodR1.

Lemma monGoodR :
 forall (A : Set) (R : Rel A) (xs bs cs : list A),
 GoodR A R (xs ++ bs) -> GoodR A R (xs ++ cs ++ bs).
Hint Resolve monGoodR.

Lemma subPredExistsL :
 forall (A B : Set) (P : Pred A) (S : Pred B) (f : A -> B),
 (forall a : A, P a -> S (f a)) ->
 forall l : list A, ExistsL A P l -> ExistsL B S (map f l).

Lemma subRelGoodR :
 forall (A B : Set) (R : Rel A) (S : Rel B) (f : A -> B),
 (forall a b : A, R a b -> S (f a) (f b)) ->
 forall l : list A, GoodR A R l -> GoodR B S (map f l).

Inductive Bar (A : Set) (P : list A -> Set) : list A -> Set :=
  | Base : forall l : list A, P l -> Bar A P l
  | Ind : forall l : list A, (forall a : A, Bar A P (a :: l)) -> Bar A P l.
Hint Resolve Base Ind.

Definition GRBar (A : Set) (R : Rel A) := Bar A (GoodR A R).

Definition WR (A : Set) (R : Rel A) := GRBar A R nil.
Hint Unfold GRBar WR.

Lemma subRelGRBar :
 forall (A B : Set) (R : Rel A) (S : Rel B) (f : A -> B),
 (forall a b : A, R a b -> S (f a) (f b)) ->
 (forall b : B, {a : A | b = f a}) ->
 forall l : list A, GRBar A R l -> GRBar B S (map f l).

Lemma consGRBar :
 forall (A : Set) (R : Rel A) (l : list A),
 GRBar A R l -> forall a : A, GRBar A R (a :: l).
Hint Resolve consGRBar.

Lemma nilGRBar :
 forall (A : Set) (R : Rel A),
 GRBar A R nil -> forall l : list A, GRBar A R l.

Lemma monGRBarAux :
 forall (A : Set) (R : Rel A) (l : list A),
 GRBar A R l ->
 forall xs bs cs : list A, l = xs ++ cs -> GRBar A R (xs ++ bs ++ cs).

Lemma monGRBar :
 forall (A : Set) (R : Rel A) (xs bs cs : list A),
 GRBar A R (xs ++ cs) -> GRBar A R (xs ++ bs ++ cs).
Hint Resolve monGRBar.
Section lems.
Variable trm : Set.
Variable tdiv : trm -> trm -> Prop.

Definition Bad (M : list trm) := GoodR trm tdiv M -> False.

Lemma tdivExists_trmHd_lem :
 forall (F : list trm) (f : trm),
 (forall g : trm, In g F -> ~ tdiv g f) ->
 ExistsL trm (fun g : trm => tdiv g f) F -> False.

Lemma tdivGoodP :
 forall (F : list trm) (f : trm),
 Bad F -> (forall g : trm, In g F -> ~ tdiv g f) -> Bad (f :: F).
End lems. *)

Require Import OpenIndGoodRel.
(* OpenIndGoodRel:
Require Import List.
Require Import Bar.
Section OpenIndGoodRel.
Variable A : Set.
Variable lt R : Rel A.
Variable wflt : well_founded lt.

Inductive Min : list A -> Set :=
  | nmin : Min nil
  | cmin :
      forall (a : A) (l : list A),
      Min l -> (forall y : A, lt y a -> GRBar A R (y :: l)) -> Min (a :: l).
Hint Resolve nmin cmin.

Lemma OpenInd :
 forall xs : list A,
 Min xs ->
 (forall a : A, Min (a :: xs) -> GRBar A R (a :: xs)) -> GRBar A R xs.
End OpenIndGoodRel. *)

Require Import Lt.

Require Import Wf_nat.



Definition DecRel (A : Set) (R : Rel A) :=

  forall x y : A, {R x y} + {~ R x y}.



Theorem nat_double_ind_set :

 forall R : nat -> nat -> Set,

 (forall n : nat, R 0 n) ->

 (forall n : nat, R (S n) 0) ->

 (forall n m : nat, R n m -> R (S n) (S m)) -> forall n m : nat, R n m.

Proof.

simple induction n; simple induction m; auto.

Qed.



Lemma dec_lt : DecRel nat lt.

red in |- *; intros; pattern x, y in |- *.

apply nat_double_ind_set; auto with arith.

intros n; case n; auto with arith.

intros n m H'; case H'; auto with arith.

Qed.



Definition NegRel (A : Set) (R : Rel A) (x y : A) := ~ R x y.



Definition ProdRel (A B : Set) (R : Rel A) (S : Rel B) 

  (x y : A * B) := R (fst x) (fst y) /\ S (snd x) (snd y).

Section Dickson.

Variable A B : Set.

Variable lt : Rel A.

Variable R : Rel B.

Variable wfgt : well_founded lt.

Variable declt : DecRel A lt.

Variable wR : WR B R.



Definition leq (a b : A) := ~ lt b a.



Definition GBarlR := GRBar (A * B) (ProdRel A B leq R).



Definition sndL := map (fun p : A * B => snd p).



Definition MinD :=

  Min (A * B) (fun p q : A * B => lt (fst p) (fst q)) (ProdRel A B leq R).



Definition prod_lt (a b : A * B) := lt (fst a) (fst b).

Require Import Inverse_Image.



Lemma WFlem1 : well_founded prod_lt.

unfold prod_lt in |- *; apply wf_inverse_image with (B := A); auto.

Qed.



Lemma lem0 :

 forall (l : list (A * B)) (a : A * B),

 ExistsL B (fun x : B => R x (snd a)) (sndL l) -> MinD l -> GBarlR (a :: l).

intros l; elim l; simpl in |- *; auto.

intros a H' H'0; inversion H'.

intros a l0 H' a0 H'0 H'1; inversion H'0.

simpl in H0; simpl in H1; simpl in H.

case (declt (fst a0) (fst a)); intros LtE.

change (GBarlR ((a0 :: nil) ++ (a :: nil) ++ l0)) in |- *; auto.

red in |- *; apply monGRBar; simpl in |- *; auto.

inversion H'1; auto.

red in |- *; red in |- *; apply Base.

apply FoundG.

apply FoundE.

unfold ProdRel in |- *; split; auto.

simpl in H0; simpl in H1; simpl in H.

change (GBarlR ((a0 :: nil) ++ (a :: nil) ++ l0)) in |- *; auto.

red in |- *; apply monGRBar; simpl in |- *; auto.

inversion H'1; simpl in |- *; auto.

apply H'; auto.

Qed.



Lemma lem1aux :

 forall l : list B,

 GoodR B R l -> forall us : list (A * B), l = sndL us -> MinD us -> GBarlR us.

intros l; elim l; auto.

intros H'; inversion H'.

intros a l0 H' H'0; inversion H'0; auto.

intros us; elim us; simpl in |- *; auto.

intros; discriminate.

intros a1 l2 H'1 H'2 H'3; inversion H'2.

apply lem0; auto.

rewrite <- H3; rewrite <- H4; auto.

inversion H'3; auto.

intros us; elim us; unfold sndL in |- *; simpl in |- *; auto.

intros; discriminate.

intros a1 l2 H'1 H'2 H'3; inversion H'2.

change (GBarlR (nil ++ (a1 :: nil) ++ l2)) in |- *.

red in |- *; apply monGRBar; simpl in |- *; auto.

apply H'; auto.

inversion H'3; auto.

Qed.



Lemma lem1 :

 forall us : list (A * B), GoodR B R (sndL us) -> MinD us -> GBarlR us.

intros us H' H'0.

apply lem1aux with (l := sndL us); auto.

Qed.



Lemma keylem :

 forall bs : list B,

 GRBar B R bs ->

 forall us : list (A * B), bs = sndL us -> MinD us -> GBarlR us.

intros bs H'; elim H'; auto.

intros l H'0 us H'1 H'2.

apply lem1; auto.

rewrite <- H'1; auto.

intros l H'0 H'1 us H'2 H'3; red in |- *.

apply OpenInd with (lt := prod_lt); auto.

exact WFlem1.

intros a H'4.

apply H'1 with (a := snd a); auto.

rewrite H'2; auto.

Qed.



Lemma keylem_cor : WR (A * B) (ProdRel A B leq R).

red in |- *; apply keylem with (bs := nil (A:=B)); auto.

red in |- *; auto.

apply nmin; auto.

Qed.

End Dickson.



Require Import Monomials.
(* Monomials:
Section Monomials.
Require Import Arith.
Require Import Compare.
Require Import Compare_dec.
Require Import Peano_dec.

Inductive mon : nat -> Set :=
  | n_0 : mon 0
  | c_n : forall d : nat, nat -> mon d -> mon (S d).

Definition pmon1 : forall d : nat, mon d -> nat.

Definition pmon2 : forall d : nat, mon d -> mon (pred d).

Definition recomp : forall d : nat, d <> 0 -> mon d -> mon d.

Lemma recomp_ok : forall (d : nat) (h : d <> 0) (m : mon d), recomp d h m = m.

Lemma proj_ok :
 forall (d : nat) (m : mon (S d)), c_n d (pmon1 (S d) m) (pmon2 (S d) m) = m.

Definition gen_mon : forall d : nat, nat -> mon d.

Definition mult_mon : forall d : nat, mon d -> mon d -> mon d.

Theorem mult_mon_com :
 forall (d : nat) (a b : mon d), mult_mon d a b = mult_mon d b a.

Theorem mult_mon_assoc :
 forall (d : nat) (a b c : mon d),
 mult_mon d a (mult_mon d b c) = mult_mon d (mult_mon d a b) c.

Definition zero_mon : forall d : nat, mon d.

Theorem mult_mon_zero_r :
 forall (d : nat) (a : mon d), mult_mon d a (zero_mon d) = a.

Theorem mult_mon_zero_l :
 forall (d : nat) (a : mon d), mult_mon d (zero_mon d) a = a.

Inductive mdiv : forall d : nat, mon d -> mon d -> Prop :=
  | mdiv_nil : mdiv 0 n_0 n_0
  | mdiv_cons :
      forall (d : nat) (v v' : mon d) (n n' : nat),
      n <= n' -> mdiv d v v' -> mdiv (S d) (c_n d n v) (c_n d n' v').
Hint Resolve mdiv_nil mdiv_cons.

Lemma mdiv_proj :
 forall (d : nat) (m m' : mon (S d)),
 pmon1 (S d) m <= pmon1 (S d) m' ->
 mdiv d (pmon2 (S d) m) (pmon2 (S d) m') -> mdiv (S d) m m'.
Require Import Relation_Definitions.
Require Import Eqdep.

Lemma mdiv_trans : forall d : nat, transitive (mon d) (mdiv d).

Definition div_mon : forall d : nat, mon d -> mon d -> mon d.

Theorem mdiv_div :
 forall (d : nat) (a b : mon d),
 mdiv d b a -> mult_mon d (div_mon d a b) b = a.

Definition div_mon_clean : forall d : nat, mon d -> mon d -> mon d * bool.

Definition is_nil : forall d : nat, mon d -> mon d.

Theorem is_nil_id : forall (d : nat) (a : mon d), a = is_nil d a.

Theorem mon_0 : forall a : mon 0, a = n_0.
Hint Resolve mon_0.

Theorem eqmon_dec : forall (d : nat) (x y : mon d), {x = y} + {x <> y}.

Theorem mult_div_com :
 forall (d : nat) (a b : mon d), div_mon d (mult_mon d a b) b = a.

Theorem mult_div_id :
 forall (d : nat) (a : mon d), div_mon d a a = zero_mon d.

Let gb : forall d : nat, mon d * bool -> bool.

Let gm : forall d : nat, mon d * bool -> mon d.

Theorem minus_lt_0 : forall m n : nat, n < m -> n - m = 0.

Theorem div_clean_dec2 :
 forall (d : nat) (a b : mon d),
 gb d (div_mon_clean d a b) = false -> mult_mon d (div_mon d a b) b <> a.

Theorem div_clean_dec1 :
 forall (d : nat) (a b : mon d),
 gb d (div_mon_clean d a b) = true ->
 gm d (div_mon_clean d a b) = div_mon d a b /\
 mult_mon d (div_mon d a b) b = a.
Require Import Max.

Definition ppcm_mon : forall d : nat, mon d -> mon d -> mon d.

Theorem ppcm_com :
 forall (d : nat) (a b : mon d), ppcm_mon d a b = ppcm_mon d b a.

Theorem ppcm_prop_l :
 forall (d : nat) (a b : mon d),
 ppcm_mon d a b = mult_mon d (div_mon d (ppcm_mon d a b) a) a.

Theorem ppcm_prop_r :
 forall (d : nat) (a b : mon d),
 ppcm_mon d a b = mult_mon d (div_mon d (ppcm_mon d a b) b) b.

Theorem plus_minus_le : forall a b : nat, a - b + b = a -> b <= a.

Theorem ppcm_mom_is_ppcm :
 forall (d : nat) (a b c : mon d),
 c = mult_mon d (div_mon d c a) a ->
 c = mult_mon d (div_mon d c b) b ->
 c = mult_mon d (div_mon d c (ppcm_mon d a b)) (ppcm_mon d a b).
End Monomials. *)



Lemma leq2le : forall a b : nat, leq nat lt a b -> a <= b.

intros.

case (le_or_lt a b).

auto.

intro.

unfold leq in H.

unfold not in H.

case (H H0).

Qed.



Definition jj : forall d : nat, mon d :=

  (fix jj (d : nat) : mon d :=

     match d as n return (mon n) with

     | O => n_0

     | S n => c_n n 0 (jj n)

     end).



Theorem jjProp1 : forall (d : nat) (m : mon d), d = 0 -> m = jj d.

intros d m; elim m.

simpl in |- *; auto.

intros d0 n m0 H' H'0; inversion H'0.

Qed.



Theorem jjProp2 : jj 0 = n_0.

simpl in |- *; auto.

Qed.



Theorem monO_n0 : forall m : mon 0, m = n_0.

intros m; rewrite <- jjProp2.

apply jjProp1; auto.

Qed.



Lemma zRV_WR : WR (mon 0) (mdiv 0).

red in |- *; red in |- *; apply Ind.

intros a; apply Ind.

intros a0; rewrite (monO_n0 a); rewrite (monO_n0 a0).

apply Base; auto.

apply FoundG; auto.

apply FoundE; auto.

apply mdiv_nil; auto.

Qed.



Definition monLift (n : nat) (p : nat * mon n) :=

  match p with

  | (x, m) => c_n n x m

  end.



Lemma monLift_lem :

 forall (n0 : nat) (b : mon (S n0)) (x : nat) (m : mon n0),

 b = c_n n0 x m -> {a : nat * mon n0 | b = monLift n0 a}.

intros.

rewrite H.

exists (x, m).

simpl in |- *.

auto.

Qed.



Lemma dicksonL : forall n : nat, WR (mon n) (mdiv n).

intro.

unfold WR in |- *.

elim n.

apply zRV_WR.

intros.

cut (WR (nat * mon n0) (ProdRel nat (mon n0) (leq nat lt) (mdiv n0)));

 [ intros | exact (keylem_cor nat (mon n0) lt (mdiv n0) lt_wf dec_lt H) ].

unfold WR in H0.

change (GRBar (mon (S n0)) (mdiv (S n0)) (map (monLift n0) nil)) in |- *.

apply subRelGRBar with (R := ProdRel nat (mon n0) (leq nat lt) (mdiv n0));

 auto.

intros a b; case a; case b; simpl in |- *; auto.

intros n1 m n2 m0 H'; inversion H'; auto.

apply mdiv_cons; auto.

apply leq2le; auto.

intros b; exists (pmon1 (S n0) b, pmon2 (S n0) b); simpl in |- *.

apply sym_eq; apply proj_ok; auto.

Qed.

