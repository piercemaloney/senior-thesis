

Require Import LexiOrder.
(* LexiOrder:
Require Import Eqdep.
Section lexi_order.
Require Import Monomials.

Inductive orderc : forall n : nat, mon n -> mon n -> Prop :=
  | lo1 :
      forall (n a b : nat) (p : mon n),
      b < a -> orderc (S n) (c_n n a p) (c_n n b p)
  | lo2 :
      forall (n a b : nat) (p q : mon n),
      orderc n p q -> orderc (S n) (c_n n a p) (c_n n b q).
Hint Resolve lo1 lo2.
Require Import Arith.
Require Import Compare_dec.

Theorem orderc_dec :
 forall (n : nat) (a b : mon n), {orderc n a b} + {orderc n b a} + {a = b}.

Definition degc : forall n : nat, mon n -> nat.

Inductive total_orderc : forall n : nat, mon n -> mon n -> Prop :=
  | total_orderc0 :
      forall (n : nat) (p q : mon n),
      degc n p < degc n q -> total_orderc n p q
  | total_orderc1 :
      forall (n : nat) (p q : mon n),
      degc n p = degc n q -> orderc n p q -> total_orderc n p q.
Hint Resolve total_orderc0 total_orderc1.
Require Import LetP.

Theorem total_orderc_dec :
 forall (n : nat) (a b : mon n),
 {total_orderc n a b} + {total_orderc n b a} + {a = b}.
intros n a b.
apply LetP with (A := nat) (h := degc n a).
intros u H'; apply LetP with (A := nat) (h := degc n b).
End lexi_order. *)

Require Import BuchRed.
(* BuchRed:
Require Export Pcomb.
Require Export Pcrit.
Require Export Buch.
Require Export Fred.
Require Import Buch.

Local Unset Injection On Proofs.

Section BuchRed.
Load "hCoefStructure".
Load "hOrderStructure".
Load "hBuch".
 
Theorem Cb_addEnd_cons :
 forall (L : list (poly A0 eqA ltM)) (p q : poly A0 eqA ltM),
 Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec q (addEnd A A0 eqA n ltM p L) ->
 Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec q (p :: L).
 
Theorem Cb_cons_addEnd :
 forall (L : list (poly A0 eqA ltM)) (p q : poly A0 eqA ltM),
 Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec q (p :: L) ->
 Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec q (addEnd A A0 eqA n ltM p L).
 
Theorem Cb_trans_cons :
 forall (L : list (poly A0 eqA ltM)) (p q : poly A0 eqA ltM),
 Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec q (p :: L) ->
 Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec p L ->
 Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec q L.
 
Theorem Cb_cons :
 forall (p : poly A0 eqA ltM) (L : list (poly A0 eqA ltM)),
 Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec
   (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os p
      L) (p :: L).
intros p L; unfold nf, LetP in |- *; auto.
 
Theorem Cb_comp :
 forall L1 L2 : list (poly A0 eqA ltM),
 (forall p : poly A0 eqA ltM,
  In p L1 -> Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec p L2) ->
 forall q : poly A0 eqA ltM,
 Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec q L1 ->
 Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec q L2.
 
Theorem Cb_nf :
 forall (p : poly A0 eqA ltM) (L : list (poly A0 eqA ltM)),
 Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec p
   (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os p
      L :: L).
intros p L; unfold nf in |- *.
case
 (Reducef A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec
    os L p); auto.
case p.
unfold LetP in |- *; intros x H' x0; case x0; simpl in |- *.
 
Theorem zerop_elim_Cb :
 forall (L : list (poly A0 eqA ltM)) (p q : poly A0 eqA ltM),
 zerop A A0 eqA n ltM p ->
 Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec q (p :: L) ->
 Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec q L.
 
Theorem Cb_compo :
 forall (p : poly A0 eqA ltM) (L1 : list (poly A0 eqA ltM)),
 Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec p L1 ->
 forall L2 : list (poly A0 eqA ltM),
 (forall q : poly A0 eqA ltM,
  In q L1 -> Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec q L2) ->
 Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec p L2.
 
Definition reducep (L : list (poly A0 eqA ltM)) (p q : poly A0 eqA ltM) :
  Prop :=
  reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec L
    (s2p A A0 eqA n ltM p) (s2p A A0 eqA n ltM q).
 
Theorem grobner_def :
 forall L : list (poly A0 eqA ltM),
 Grobner A A0 A1 eqA plusA invA minusA multA divA eqA_dec n ltM ltM_dec L ->
 forall p : poly A0 eqA ltM,
 Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec p L ->
 zerop A A0 eqA n ltM p \/ (exists q : poly A0 eqA ltM, reducep L p q).
 
Theorem def_grobner :
 forall L : list (poly A0 eqA ltM),
 (forall p : poly A0 eqA ltM,
  Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec p L ->
  zerop A A0 eqA n ltM p \/ (exists q : poly A0 eqA ltM, reducep L p q)) ->
 Grobner A A0 A1 eqA plusA invA minusA multA divA eqA_dec n ltM ltM_dec L.
 
Theorem reduce_divp :
 forall (p q : poly A0 eqA ltM) (Q : list (poly A0 eqA ltM)),
 reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q
   (s2p A A0 eqA n ltM p) (s2p A A0 eqA n ltM q) ->
 exists r : poly A0 eqA ltM,
   In r (q :: Q) /\
   divp A A0 eqA multA divA n ltM p r /\ ~ zerop A A0 eqA n ltM r.
 
Theorem reduceplus_divp_lem :
 forall (a b : list (Term A n)) (Q : list (poly A0 eqA ltM)),
 reduceplus A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q a b ->
 canonical A0 eqA ltM a ->
 forall x y : poly A0 eqA ltM,
 s2p A A0 eqA n ltM x = a ->
 s2p A A0 eqA n ltM y = b ->
 ~ zerop A A0 eqA n ltM x ->
 exists r : poly A0 eqA ltM,
   In r (y :: Q) /\
   divp A A0 eqA multA divA n ltM x r /\ ~ zerop A A0 eqA n ltM r.
 
Theorem reduceplus_divp :
 forall (a b : poly A0 eqA ltM) (Q : list (poly A0 eqA ltM)),
 reduceplus A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q
   (s2p A A0 eqA n ltM a) (s2p A A0 eqA n ltM b) ->
 ~ zerop A A0 eqA n ltM a ->
 exists r : poly A0 eqA ltM,
   In r (b :: Q) /\
   divp A A0 eqA multA divA n ltM a r /\ ~ zerop A A0 eqA n ltM r.
 
Theorem reducestar_divp :
 forall (a b : poly A0 eqA ltM) (Q : list (poly A0 eqA ltM)),
 reducestar A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q
   (s2p A A0 eqA n ltM a) (s2p A A0 eqA n ltM b) ->
 ~ zerop A A0 eqA n ltM a ->
 exists r : poly A0 eqA ltM,
   In r (b :: Q) /\
   divp A A0 eqA multA divA n ltM a r /\ ~ zerop A A0 eqA n ltM r.
 
Theorem nf_divp :
 forall (p : poly A0 eqA ltM) (L : list (poly A0 eqA ltM)),
 ~ zerop A A0 eqA n ltM p ->
 ~
 zerop A A0 eqA n ltM
   (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os p
      L) ->
 exists q : poly A0 eqA ltM,
   In q
     (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os
        p L :: L) /\
   divp A A0 eqA multA divA n ltM p q /\ ~ zerop A A0 eqA n ltM q.
intros p L; case p; unfold nf in |- *; auto.
unfold nf in |- *; auto.
intros x c;
 case
  (Reducef A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec
     os L (exist (fun l => canonical A0 eqA ltM l) x c)).
unfold LetP in |- *.
 
Theorem divp_reduce1 :
 forall (p : poly A0 eqA ltM) (L1 L2 : list (poly A0 eqA ltM)),
 (forall r1 : poly A0 eqA ltM,
  In r1 L1 ->
  ~ zerop A A0 eqA n ltM r1 ->
  exists r2 : poly A0 eqA ltM,
    In r2 L2 /\ divp A A0 eqA multA divA n ltM r1 r2) ->
 forall q : poly A0 eqA ltM,
 reducep L1 p q -> exists r : poly A0 eqA ltM, reducep L2 p r.
 
Theorem nf_divp_zero :
 forall (p : poly A0 eqA ltM) (L : list (poly A0 eqA ltM)),
 ~ zerop A A0 eqA n ltM p ->
 zerop A A0 eqA n ltM
   (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os p
      L) ->
 exists q : poly A0 eqA ltM,
   In q L /\ divp A A0 eqA multA divA n ltM p q /\ ~ zerop A A0 eqA n ltM q.
intros p L; case p; unfold nf in |- *; auto.
unfold nf in |- *; auto.
intros x c;
 case
  (Reducef A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec
     os L (exist (fun l : list (Term A n) => canonical A0 eqA ltM l) x c)).
unfold LetP in |- *.
 
Theorem zerop_elim_cb :
 forall (L : list (poly A0 eqA ltM)) (p q : poly A0 eqA ltM),
 zerop A A0 eqA n ltM p ->
 Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec q (p :: L) ->
 Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec q L.
 
Theorem zerop_nf_cb :
 forall (L : list (poly A0 eqA ltM)) (p : poly A0 eqA ltM),
 zerop A A0 eqA n ltM
   (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os p
      L) -> Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec p L.
Hint Resolve zerop_nf_cb.
 
Definition redacc :
  list (poly A0 eqA ltM) -> list (poly A0 eqA ltM) -> list (poly A0 eqA ltM).
intros H'; elim H'.
intros L; exact (nil (A:=poly A0 eqA ltM)).
intros a p Rec Acc.
apply
 LetP
  with
    (A := poly A0 eqA ltM)
    (h := nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM
            ltM_dec os a (p ++ Acc)).
 
Theorem redacc_cb :
 forall (L1 L2 : list (poly A0 eqA ltM)) (p : poly A0 eqA ltM),
 In p (redacc L1 L2) ->
 Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec p (L1 ++ L2).
intros L1; elim L1; auto.
simpl in |- *; auto.
intros L2 p H; elim H.
simpl in |- *; unfold LetP in |- *; intros a l H' L2 p.
 
Definition Red (L : list (poly A0 eqA ltM)) : list (poly A0 eqA ltM) :=
  redacc L nil.
 
Theorem Red_cb :
 forall (L : list (poly A0 eqA ltM)) (p : poly A0 eqA ltM),
 In p (Red L) -> Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec p L.
 
Theorem cb_redacc :
 forall (L1 L2 : list (poly A0 eqA ltM)) (p : poly A0 eqA ltM),
 In p L1 ->
 Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec p (redacc L1 L2 ++ L2).
intros L1; elim L1; simpl in |- *; auto.
intros L2 p H'; elim H'; auto.
unfold LetP in |- *.
 
Theorem Cb_Red :
 forall (L : list (poly A0 eqA ltM)) (p : poly A0 eqA ltM),
 In p L -> Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec p (Red L).
 
Theorem cb_Red_cb1 :
 forall (p : poly A0 eqA ltM) (L : list (poly A0 eqA ltM)),
 Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec p L ->
 Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec p (Red L).
 
Theorem cb_Red_cb2 :
 forall (p : poly A0 eqA ltM) (L : list (poly A0 eqA ltM)),
 Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec p (Red L) ->
 Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec p L.
 
Theorem divp_id :
 forall p : poly A0 eqA ltM,
 ~ zerop A A0 eqA n ltM p -> divp A A0 eqA multA divA n ltM p p.
 
Theorem redacc_divp :
 forall (L1 L2 : list (poly A0 eqA ltM)) (p : poly A0 eqA ltM),
 ~ zerop A A0 eqA n ltM p ->
 In p (L1 ++ L2) ->
 exists q : poly A0 eqA ltM,
   In q (redacc L1 L2 ++ L2) /\
   divp A A0 eqA multA divA n ltM p q /\ ~ zerop A A0 eqA n ltM q.
intros L1; elim L1; simpl in |- *; auto.
intros L2 p H' H'0; exists p; split; auto.
split; auto.
apply divp_id; auto.
unfold LetP in |- *.
 
Theorem Red_divp :
 forall (L : list (poly A0 eqA ltM)) (p : poly A0 eqA ltM),
 In p L ->
 ~ zerop A A0 eqA n ltM p ->
 exists q : poly A0 eqA ltM,
   In q (Red L) /\
   divp A A0 eqA multA divA n ltM p q /\ ~ zerop A A0 eqA n ltM q.
 
Theorem Red_grobner :
 forall L : list (poly A0 eqA ltM),
 Grobner A A0 A1 eqA plusA invA minusA multA divA eqA_dec n ltM ltM_dec L ->
 Grobner A A0 A1 eqA plusA invA minusA multA divA eqA_dec n ltM ltM_dec
   (Red L).
 
Definition redbuch (L : list (poly A0 eqA ltM)) : list (poly A0 eqA ltM) :=
  Red
    (buch A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec
       os L).
 
Theorem redbuch_stable :
 forall P : list (poly A0 eqA ltM),
 stable A A0 eqA plusA multA eqA_dec n ltM ltM_dec P (redbuch P).
 
Theorem redbuch_Grobner :
 forall P : list (poly A0 eqA ltM),
 Grobner A A0 A1 eqA plusA invA minusA multA divA eqA_dec n ltM ltM_dec
   (redbuch P).
End BuchRed. *)

Require Extraction.



Extraction

 "sin_num.ml" redbuch splus smult sscal spO sp1 sgen orderc_dec degc

             total_orderc_dec.



