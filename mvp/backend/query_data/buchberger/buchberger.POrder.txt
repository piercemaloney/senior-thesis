
Require Import Lexicographic_Exponentiation.
Require Import Relation_Definitions.
Require Import Inverse_Image.
Require Import Inclusion.
Require Import List.
Require Import Relation_Operators.
Require Import Relation_Operators_compat.
(* Relation_Operators_compat:
Require Import List.
Require Import Relation_Operators.
Require Import Transitive_Closure.

Local Open Scope list_scope.

Section Lexicographic_Exponentiation.

  Variable A : Set.
  Variable leA : A -> A -> Prop.
  Let Nil := nil (A:=A).
  Let List := list A.

  Inductive Ltl : List -> List -> Prop :=
    | Lt_nil (a:A) (x:List) : Ltl Nil (a :: x)
    | Lt_hd (a b:A) : leA a b -> forall x y:list A, Ltl (a :: x) (b :: y)
    | Lt_tl (a:A) (x y:List) : Ltl x y -> Ltl (a :: x) (a :: y).

  Inductive Desc : List -> Prop :=
    | d_nil : Desc Nil
    | d_one (x:A) : Desc (x :: Nil)
    | d_conc (x y:A) (l:List) :
        leA x y -> Desc (l ++ y :: Nil) -> Desc ((l ++ y :: Nil) ++ x :: Nil).

  Definition Pow : Set := sig Desc.

  Definition lex_exp (a b:Pow) : Prop := Ltl (proj1_sig a) (proj1_sig b).

End Lexicographic_Exponentiation.

Section Wf_Lexicographic_Exponentiation.
  Variable A : Set.
  Variable leA : A -> A -> Prop.

  Notation Power := (Pow A leA).
  Notation Lex_Exp := (lex_exp A leA).
  Notation ltl := (Ltl A leA).
  Notation Descl := (Desc A leA).

  Notation List := (list A).
  Notation Nil := (nil (A:=A)).
  
  Notation Cons := (cons (A:=A)).
  Notation "<< x , y >>" := (exist Descl x y) (at level 0, x, y at level 100).

  Lemma left_prefix : forall x y z:List, ltl (x ++ y) z -> ltl x z.

  Lemma right_prefix :
    forall x y z:List,
      ltl x (y ++ z) -> ltl x y \/ (exists y' : List, x = y ++ y' /\ ltl y' z).

  Lemma desc_prefix : forall (x:List) (a:A), Descl (x ++ Cons a Nil) -> Descl x.

  Lemma desc_tail :
    forall (x:List) (a b:A),
      Descl (Cons b (x ++ Cons a Nil)) -> clos_trans A leA a b.

  Lemma dist_aux :
    forall z:List, Descl z -> forall x y:List, z = x ++ y -> Descl x /\ Descl y.

  Lemma dist_Desc_concat :
    forall x y:List, Descl (x ++ y) -> Descl x /\ Descl y.

  Lemma desc_end :
    forall (a b:A) (x:List),
      Descl (x ++ Cons a Nil) /\ ltl (x ++ Cons a Nil) (Cons b Nil) ->
      clos_trans A leA a b.

  Lemma ltl_unit :
    forall (x:List) (a b:A),
      Descl (x ++ Cons a Nil) ->
      ltl (x ++ Cons a Nil) (Cons b Nil) -> ltl x (Cons b Nil).

  Lemma acc_app :
    forall (x1 x2:List) (y1:Descl (x1 ++ x2)),
      Acc Lex_Exp << x1 ++ x2, y1 >> ->
      forall (x:List) (y:Descl x), ltl x (x1 ++ x2) -> Acc Lex_Exp << x, y >>.

  Theorem wf_lex_exp : well_founded leA -> well_founded Lex_Exp.

End Wf_Lexicographic_Exponentiation. *)
Require Import Monomials.
(* Monomials:
Section Monomials.
Require Import Arith.
Require Import Compare.
Require Import Compare_dec.
Require Import Peano_dec.

Inductive mon : nat -> Set :=
  | n_0 : mon 0
  | c_n : forall d : nat, nat -> mon d -> mon (S d).

Definition pmon1 : forall d : nat, mon d -> nat.

Definition pmon2 : forall d : nat, mon d -> mon (pred d).

Definition recomp : forall d : nat, d <> 0 -> mon d -> mon d.

Lemma recomp_ok : forall (d : nat) (h : d <> 0) (m : mon d), recomp d h m = m.

Lemma proj_ok :
 forall (d : nat) (m : mon (S d)), c_n d (pmon1 (S d) m) (pmon2 (S d) m) = m.

Definition gen_mon : forall d : nat, nat -> mon d.

Definition mult_mon : forall d : nat, mon d -> mon d -> mon d.

Theorem mult_mon_com :
 forall (d : nat) (a b : mon d), mult_mon d a b = mult_mon d b a.

Theorem mult_mon_assoc :
 forall (d : nat) (a b c : mon d),
 mult_mon d a (mult_mon d b c) = mult_mon d (mult_mon d a b) c.

Definition zero_mon : forall d : nat, mon d.

Theorem mult_mon_zero_r :
 forall (d : nat) (a : mon d), mult_mon d a (zero_mon d) = a.

Theorem mult_mon_zero_l :
 forall (d : nat) (a : mon d), mult_mon d (zero_mon d) a = a.

Inductive mdiv : forall d : nat, mon d -> mon d -> Prop :=
  | mdiv_nil : mdiv 0 n_0 n_0
  | mdiv_cons :
      forall (d : nat) (v v' : mon d) (n n' : nat),
      n <= n' -> mdiv d v v' -> mdiv (S d) (c_n d n v) (c_n d n' v').
Hint Resolve mdiv_nil mdiv_cons.

Lemma mdiv_proj :
 forall (d : nat) (m m' : mon (S d)),
 pmon1 (S d) m <= pmon1 (S d) m' ->
 mdiv d (pmon2 (S d) m) (pmon2 (S d) m') -> mdiv (S d) m m'.
Require Import Relation_Definitions.
Require Import Eqdep.

Lemma mdiv_trans : forall d : nat, transitive (mon d) (mdiv d).

Definition div_mon : forall d : nat, mon d -> mon d -> mon d.

Theorem mdiv_div :
 forall (d : nat) (a b : mon d),
 mdiv d b a -> mult_mon d (div_mon d a b) b = a.

Definition div_mon_clean : forall d : nat, mon d -> mon d -> mon d * bool.

Definition is_nil : forall d : nat, mon d -> mon d.

Theorem is_nil_id : forall (d : nat) (a : mon d), a = is_nil d a.

Theorem mon_0 : forall a : mon 0, a = n_0.
Hint Resolve mon_0.

Theorem eqmon_dec : forall (d : nat) (x y : mon d), {x = y} + {x <> y}.

Theorem mult_div_com :
 forall (d : nat) (a b : mon d), div_mon d (mult_mon d a b) b = a.

Theorem mult_div_id :
 forall (d : nat) (a : mon d), div_mon d a a = zero_mon d.

Let gb : forall d : nat, mon d * bool -> bool.

Let gm : forall d : nat, mon d * bool -> mon d.

Theorem minus_lt_0 : forall m n : nat, n < m -> n - m = 0.

Theorem div_clean_dec2 :
 forall (d : nat) (a b : mon d),
 gb d (div_mon_clean d a b) = false -> mult_mon d (div_mon d a b) b <> a.

Theorem div_clean_dec1 :
 forall (d : nat) (a b : mon d),
 gb d (div_mon_clean d a b) = true ->
 gm d (div_mon_clean d a b) = div_mon d a b /\
 mult_mon d (div_mon d a b) b = a.
Require Import Max.

Definition ppcm_mon : forall d : nat, mon d -> mon d -> mon d.

Theorem ppcm_com :
 forall (d : nat) (a b : mon d), ppcm_mon d a b = ppcm_mon d b a.

Theorem ppcm_prop_l :
 forall (d : nat) (a b : mon d),
 ppcm_mon d a b = mult_mon d (div_mon d (ppcm_mon d a b) a) a.

Theorem ppcm_prop_r :
 forall (d : nat) (a b : mon d),
 ppcm_mon d a b = mult_mon d (div_mon d (ppcm_mon d a b) b) b.

Theorem plus_minus_le : forall a b : nat, a - b + b = a -> b <= a.

Theorem ppcm_mom_is_ppcm :
 forall (d : nat) (a b c : mon d),
 c = mult_mon d (div_mon d c a) a ->
 c = mult_mon d (div_mon d c b) b ->
 c = mult_mon d (div_mon d c (ppcm_mon d a b)) (ppcm_mon d a b).
End Monomials. *)
Require Import Term.
(* Term:
Require Import Relation_Definitions.
Require Import CoefStructure.
Require Import moreCoefStructure.
Require Import OrderStructure.
Require Import Monomials.
Section Term.
Load "hCoefStructure".
Load "mCoefStructure".
Load "hOrderStructure".
Load "mOrderStructure".
 
Definition M1 := zero_mon n.
 
Definition Term := (A * mon n)%type.
Set Implicit Arguments.
Unset Strict Implicit.
 
Definition zeroP : Term -> Prop.
 
Definition eqTerm : Term -> Term -> Prop.
Set Strict Implicit.
Unset Implicit Arguments.
 
Theorem eqTerm_refl : reflexive Term eqTerm.
 
Theorem eqTerm_sym : symmetric Term eqTerm.
 
Theorem eqTerm_trans : transitive Term eqTerm.
Set Implicit Arguments.
Unset Strict Implicit.
 
Definition T2M : Term -> mon n.
Set Strict Implicit.
Unset Implicit Arguments.
Set Implicit Arguments.
Unset Strict Implicit.
 
Definition eqT (a b : Term) : Prop := T2M a = T2M b.
Hint Unfold eqT.
Set Strict Implicit.
Unset Implicit Arguments.
 
Lemma eqT_refl : reflexive _ eqT.
 
Lemma eqT_sym : symmetric _ eqT.
 
Lemma eqT_trans : transitive _ eqT.
 
Theorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.
 
Theorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.
 
Theorem eqT_zerop_is_eqTerm :
 forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.
 
Theorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.
 
Theorem zeroP_comp_eqTerm :
 forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.

Theorem nzeroP_comp_eqTerm :
 forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.

Set Implicit Arguments.
Unset Strict Implicit.
 
Definition plusTerm : Term -> Term -> Term.
Set Strict Implicit.
Unset Implicit Arguments.
 
Theorem zeroP_plusTermr :
 forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).
 
Theorem zeroP_plusTerml :
 forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).
 
Theorem plusTerm_comp_l :
 forall a b c : Term,
 eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).
 
Theorem plusTerm_comp_r :
 forall a b c : Term,
 eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).
 
Theorem plusTerm_com :
 forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).
 
Theorem plusTerm_eqT1 :
 forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.
 
Theorem plusTerm_eqT2 :
 forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.
 
Theorem plusTerm_assoc :
 forall a a0 A1 : Term,
 eqT A1 a0 ->
 eqT a a0 ->
 eqTerm (plusTerm (plusTerm A1 a0) a) (plusTerm A1 (plusTerm a0 a)).
 
Theorem eqTerm_plusTerm_comp :
 forall a b c d : Term,
 eqT a c ->
 eqT b d -> eqTerm a b -> eqTerm c d -> eqTerm (plusTerm a c) (plusTerm b d).
Hint Resolve eqTerm_plusTerm_comp.

Set Implicit Arguments.
Unset Strict Implicit.
 
Definition multTerm : Term -> Term -> Term.
Set Strict Implicit.
Unset Implicit Arguments.
 
Theorem zeroP_multTerm_l : forall a b : Term, zeroP a -> zeroP (multTerm a b).
 
Theorem zeroP_multTerm_r : forall a b : Term, zeroP a -> zeroP (multTerm b a).
 
Theorem multTerm_plusTerm_dist_l :
 forall a b c : Term,
 eqTerm (plusTerm (multTerm a c) (multTerm b c)) (multTerm (plusTerm a b) c).
 
Theorem multTerm_plusTerm_dist_r :
 forall a b c : Term,
 eqTerm (plusTerm (multTerm c a) (multTerm c b)) (multTerm c (plusTerm a b)).
 
Theorem multTerm_eqT :
 forall a b c d : Term,
 eqT a b -> eqT c d -> eqT (multTerm a c) (multTerm b d).
 
Theorem multTerm_assoc :
 forall a b c : Term,
 eqTerm (multTerm a (multTerm b c)) (multTerm (multTerm a b) c).
 
Theorem multTerm_com :
 forall a b : Term, eqTerm (multTerm a b) (multTerm b a).
 
Theorem eqTerm_multTerm_comp :
 forall a b c d : Term,
 eqTerm a b -> eqTerm c d -> eqTerm (multTerm a c) (multTerm b d).
Hint Resolve eqTerm_multTerm_comp.
 
Set Implicit Arguments.
Unset Strict Implicit.
 
Definition invTerm : Term -> Term.
Set Strict Implicit.
Unset Implicit Arguments.
 
Theorem plusTerm_invTerm_zeroP :
 forall a : Term, zeroP (plusTerm a (invTerm a)).
 
Theorem zeroP_invTerm_zeroP : forall a : Term, zeroP a -> zeroP (invTerm a).
 
Theorem invTerm_invol : forall a : Term, eqTerm a (invTerm (invTerm a)).
 
Theorem nZero_invTerm_nZero :
 forall a : Term, ~ zeroP a -> ~ zeroP (invTerm a).
Hint Resolve nZero_invTerm_nZero.
Set Implicit Arguments.
Unset Strict Implicit.
 
Definition T1 : Term.
Set Strict Implicit.
Unset Implicit Arguments.
 
Theorem T1_nz : ~ zeroP T1.
 
Theorem T1_multTerm_l :
 forall a b : Term, eqTerm a T1 -> eqTerm b (multTerm a b).
 
Theorem T1_multTerm_r :
 forall a b : Term, eqTerm a T1 -> eqTerm b (multTerm b a).
 
Theorem nZero_invTerm_T1 : ~ zeroP (invTerm T1).
Hint Resolve nZero_invTerm_T1.
 
Theorem mult_invTerm_com :
 forall a b : Term, eqTerm (multTerm (invTerm a) b) (invTerm (multTerm a b)).
 
Theorem mult_invTerm_com_r :
 forall a b : Term, eqTerm (multTerm a (invTerm b)) (invTerm (multTerm a b)).
 
Theorem eqTerm_invTerm_comp :
 forall a b : Term, eqTerm a b -> eqTerm (invTerm a) (invTerm b).
 
Theorem invTerm_eqT : forall a : Term, eqT a (invTerm a).
 
Theorem T1_eqT : forall a b : Term, eqTerm a T1 -> eqT b (multTerm a b).
 
Theorem eqTerm_T1_eqT : forall a : Term, eqTerm a T1 -> eqT a T1.
Set Implicit Arguments.
Unset Strict Implicit.
 
Definition minusTerm : Term -> Term -> Term.
Set Strict Implicit.
Unset Implicit Arguments.
 
Theorem eqTerm_minusTerm_plusTerm_invTerm :
 forall a b : Term, eqTerm (minusTerm a b) (plusTerm a (invTerm b)).
 
Theorem minusTerm_eqT :
 forall m1 m2 : Term, eqT m1 m2 -> eqT (minusTerm m1 m2) m1.
 
Theorem zeroP_minusTerm : forall a : Term, zeroP (minusTerm a a).
 
Theorem multTerm_zeroP_div :
 forall a b : Term, zeroP (multTerm a b) -> zeroP a \/ zeroP b.
 
Theorem multTerm_minusTerm_dist_l :
 forall a b c : Term,
 eqT a b ->
 eqTerm (minusTerm (multTerm a c) (multTerm b c))
   (multTerm (minusTerm a b) c).
Hint Resolve multTerm_minusTerm_dist_l.
 
Theorem nzeroP_multTerm :
 forall a b : Term, ~ zeroP a -> ~ zeroP b -> ~ zeroP (multTerm a b).
End Term. *)
Require Import CoefStructure.
(* CoefStructure:
Require Import Relation_Definitions.

Record CoefStructure (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop)
  (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A)
  (divA : A -> forall b : A, ~ eqA b A0 -> A) : Prop := mkCoefStructure
  {A1_diff_A0 : ~ eqA A1 A0;
   eqA_ref : reflexive A eqA;
   eqA_sym : symmetric A eqA;
   eqA_trans : transitive A eqA;
   plusA_assoc :
    forall a b c : A, eqA (plusA a (plusA b c)) (plusA (plusA a b) c);
   plusA_com : forall a b : A, eqA (plusA a b) (plusA b a);
   plusA_eqA_comp :
    forall a b c d : A, eqA a c -> eqA b d -> eqA (plusA a b) (plusA c d);
   plusA_A0 : forall a : A, eqA a (plusA a A0);
   invA_plusA : forall a : A, eqA A0 (plusA a (invA a));
   invA_eqA_comp : forall a b : A, eqA a b -> eqA (invA a) (invA b);
   minusA_def : forall a b : A, eqA (minusA a b) (plusA a (invA b));
   multA_eqA_comp :
    forall a b c d : A, eqA a c -> eqA b d -> eqA (multA a b) (multA c d);
   multA_assoc :
    forall a b c : A, eqA (multA a (multA b c)) (multA (multA a b) c);
   multA_com : forall a b : A, eqA (multA a b) (multA b a);
   multA_dist_l :
    forall a b c : A,
    eqA (plusA (multA c a) (multA c b)) (multA c (plusA a b));
   multA_A0_l : forall a : A, eqA (multA A0 a) A0;
   multA_A1_l : forall a : A, eqA (multA A1 a) a;
   divA_rew :
    forall (a b : A) (nZ1 nZ2 : ~ eqA b A0), divA a b nZ1 = divA a b nZ2;
   divA_is_multA :
    forall (a b : A) (nZb : ~ eqA b A0), eqA a (multA (divA a b nZb) b);
   divA_eqA_comp :
    forall (a b c d : A) (nZb : ~ eqA b A0) (nZd : ~ eqA d A0),
    eqA a c -> eqA b d -> eqA (divA a b nZb) (divA c d nZd);
   divA_multA_comp_r :
    forall (a b c : A) (nZc : ~ eqA c A0),
    eqA (divA (multA a b) c nZc) (multA (divA a c nZc) b);
   divA_invA_r :
    forall (a b : A) (nZb : ~ eqA b A0) (nZib : ~ eqA (invA b) A0),
    eqA (divA a (invA b) nZib) (invA (divA a b nZb))}. *)
Require Import OrderStructure.
(* OrderStructure:
Require Import Relation_Definitions.

Record OrderStructure (A : Set) (M1 : A) (ltM : A -> A -> Prop)
  (plusM : A -> A -> A) : Prop := mkOrderStructure
  {M1_min : forall x : A, ~ ltM x M1;
   ltM_nonrefl : forall x : A, ~ ltM x x;
   ltM_trans : transitive A ltM;
   ltM_wf : well_founded ltM;
   ltM_plusr : forall x y z : A, ltM x y -> ltM (plusM x z) (plusM y z);
   ltM_plusl : forall x y z : A, ltM x y -> ltM (plusM z x) (plusM z y)}. *)
Section Porder.
Load "hCoefStructure".
Load "hOrderStructure".
Load "hTerm".

Set Implicit Arguments.
Unset Strict Implicit.
 
Definition ltT (a b : Term A n) : Prop := ltM (T2M a) (T2M b).
Hint Unfold ltT.
Set Strict Implicit.
Unset Implicit Arguments.
 
Theorem ltT_trans : transitive (Term A n) ltT.
unfold transitive, ltT in |- *; auto.
intros x y z H' H'0; apply (ltM_trans _ _ _ _ os) with (y := T2M y); auto.
Qed.
 
Lemma eqT_compat_ltTr :
 forall a b c : Term A n, eqT b c -> ltT a b -> ltT a c.
unfold eqT in |- *; unfold ltT in |- *; intros a b c H; rewrite H; auto.
Qed.
 
Lemma eqT_compat_ltTl :
 forall a b c : Term A n, eqT b c -> ltT b a -> ltT c a.
unfold eqT in |- *; unfold ltT in |- *; intros a b c H; rewrite H; auto.
Qed.
 
Theorem eqT_dec : forall x y : Term A n, {eqT x y} + {~ eqT x y}.
intros x y; unfold eqT in |- *; simpl in |- *; auto.
apply eqmon_dec.
Qed.
 
Theorem ltT_dec : forall x y : Term A n, {ltT x y} + {ltT y x} + {eqT x y}.
intros x y; exact (ltM_dec (T2M x) (T2M y)).
Qed.
 
Lemma ltT_not_eqT : forall x y : Term A n, eqT x y -> ~ ltT x y.
unfold eqT, ltT in |- *; simpl in |- *; intros x y H; rewrite H; auto.
apply ltM_nonrefl with (1 := os).
Qed.
 
Lemma eqT_not_ltT : forall x y : Term A n, ltT x y -> ~ eqT x y.
unfold eqT, ltT, not in |- *; simpl in |- *; intros x y H Q;
 absurd (ltM (T2M x) (T2M y)); auto; rewrite Q; auto.
apply ltM_nonrefl with (1 := os).
Qed.
 
Theorem ltT_not_refl : forall x : Term A n, ~ ltT x x.
intros x; unfold ltT in |- *; apply ltM_nonrefl with (1 := os).
Qed.
Hint Resolve ltT_not_eqT eqT_not_ltT ltT_not_refl.
 
Lemma ltT_not_ltT : forall x y : Term A n, ltT x y -> ~ ltT y x.
intros x y H'; red in |- *; intros H'0; absurd (ltT x x); auto.
apply ltT_trans with (y := y); auto.
Qed.
Hint Resolve ltT_not_ltT.
 
Lemma ltT_eqT :
 forall a b c d : Term A n, eqT a b -> eqT c d -> ltT a c -> ltT b d.
unfold eqT, ltT in |- *; intros a b c d R1 R2; rewrite R1; rewrite R2; auto.
Qed.
 
Let eqT_refl := eqT_refl A n.
 
Lemma ltT_eqTr : forall a b c : Term A n, eqT a b -> ltT a c -> ltT b c.
intros a b c H' H'0; apply ltT_eqT with (a := a) (c := c); auto.
Qed.
 
Lemma ltT_eqTl : forall a b c : Term A n, eqT a b -> ltT c a -> ltT c b.
intros a b c H' H'0; apply ltT_eqT with (a := c) (c := a); auto.
Qed.
 
Theorem multTerm_ltT_l :
 forall m1 m2 m3,
 ltT m1 m2 -> ltT (multTerm multA m3 m1) (multTerm multA m3 m2).
intros a b c; case a; case b; case c; unfold ltT in |- *; simpl in |- *; auto.
intros a0 m a1 m0 a2 m1 H.
apply ltM_plusl with (1 := os); auto.
Qed.
 
Theorem multTerm_ltT_r :
 forall m1 m2 m3,
 ltT m1 m2 -> ltT (multTerm multA m1 m3) (multTerm multA m2 m3).
intros a b c; case a; case b; case c; unfold ltT in |- *; simpl in |- *; auto.
intros; apply ltM_plusr with (1 := os); auto.
Qed.
 
Theorem T1_is_min_ltT : forall a, ~ ltT a (T1 A1 n).
intros a; case a; unfold ltT in |- *; simpl in |- *; auto.
intros a0 m; unfold M1 in |- *; apply (M1_min _ _ _ _ os); auto.
Qed.
 
Theorem minusTerm_ltT_l :
 forall a b c, eqT a b -> ltT a c -> ltT (minusTerm minusA a b) c.
intros a b c; case a; case b; case c; unfold ltT in |- *; simpl in |- *; auto.
Qed.
 
Theorem invTerm_ltT_l : forall a c, ltT a c -> ltT (invTerm invA a) c.
intros a b; case a; case b; unfold ltT in |- *; simpl in |- *; auto.
Qed.
Set Implicit Arguments.
Unset Strict Implicit.
 
Definition pX := cons (A:=Term A n).
Set Strict Implicit.
Unset Implicit Arguments.
 
Definition pO := nil (A:=Term A n).
 
Let consA := cons (A:=mon n).
 
Let nilA := nil (A:=mon n).
 
Let listA := list (mon n).
Hint Unfold consA nilA listA.
 
Fixpoint fP (a : list (Term A n)) : listA :=
  match a with
  | nil => nilA
  | b :: p => consA (T2M b) (fP p)
  end.
 
Theorem fP_app : forall p q : list (Term A n), fP (p ++ q) = fP p ++ fP q.
intros p; elim p; simpl in |- *; auto.
intros a l H' q.
rewrite (H' q); auto.
Qed.
 
Let DescA := Desc (mon n) ltM.
Set Implicit Arguments.
Unset Strict Implicit.
 
Definition olist (p : list (Term A n)) := DescA (fP p).
Hint Resolve d_nil d_one.
Hint Unfold olist DescA.
Set Strict Implicit.
Unset Implicit Arguments.
 
Theorem olistOne : forall a b : Term A n, ltT b a -> olist (pX a (pX b pO)).
unfold olist, ltT in |- *; simpl in |- *; auto.
intros a b H'.
generalize (d_conc _ ltM (T2M b) (T2M a) nilA); simpl in |- *; auto.
Qed.
Hint Resolve olistOne.
 
Theorem olistO : olist pO.
unfold olist, ltT in |- *; simpl in |- *; auto.
red in |- *; unfold nilA in |- *; apply d_nil.
Qed.
 
Lemma app2_inv :
 forall (x y z t : mon n) (p : listA),
 (p ++ consA x nilA) ++ consA y nilA = consA z (consA t nilA) ->
 x = z /\ y = t.
intros x y z t p; case p; simpl in |- *; auto.
intros H'; injection H'; simpl in |- *; auto.
intros a l; case l; simpl in |- *; auto.
intros H'; discriminate H'.
intros a0 l0; case l0; simpl in |- *; auto.
intros H'; discriminate H'.
intros a1 l1 H'; discriminate H'.
Qed.
 
Theorem olist_ltT :
 forall (l : list (Term A n)) (a b : Term A n),
 olist (l ++ pX a (pX b pO)) -> ltT b a.
unfold ltT, olist in |- *; simpl in |- *; auto.
intros l a b.
rewrite (fP_app l (pX a (pX b pO))); simpl in |- *; auto.
intros H'.
elim (dist_Desc_concat _ ltM (fP l) (consA (T2M a) (consA (T2M b) nilA)));
 [ intros H'5 H'6; try exact H'6 | idtac ]; auto.
simple inversion H'6.
discriminate H.
discriminate H.
elim (app2_inv y x (T2M a) (T2M b) l0); [ intros H'8 H'9 | idtac ]; auto.
rewrite H'9; rewrite H'8; auto.
Qed.
 
Theorem olist_cons :
 forall (l : list _) a b, ltT b a -> olist (pX b l) -> olist (pX a (pX b l)).
intros l; pattern l in |- *; apply (rev_ind (A:=Term A n)); auto.
intros x l0; case l0.
simpl in |- *.
unfold olist in |- *; simpl in |- *.
intros H' a b H'0 H'1; try assumption.
apply (d_conc _ ltM (T2M x) (T2M b) (consA (T2M a) nilA)).
generalize (olist_ltT pO); unfold ltT, olist in |- *; simpl in |- *; auto.
apply (olistOne a b); auto.
intros b l1 H' a b0 H'0; generalize H'; pattern l1 in |- *;
 apply (rev_ind (A:=Term A n)); unfold ltT, olist in |- *; 
 simpl in |- *; auto.
intros H'2 H'3.
apply (d_conc _ ltM (T2M x) (T2M b) (consA (T2M a) (consA (T2M b0) nilA)));
 auto.
generalize (olist_ltT (b0 :: nil)); unfold ltT, olist in |- *; simpl in |- *;
 auto.
simpl in |- *; apply H'2; auto.
apply (desc_prefix _ ltM (consA (T2M b0) (consA (T2M b) nilA)) (T2M x)); auto.
intros x1 l2; rewrite (fP_app (l2 ++ x1 :: nil) (x :: nil));
 rewrite (fP_app l2 (x1 :: nil)); rewrite (fP_app l2 (x :: nil)).
intros H'2 H'3 H'4;
 apply
  (d_conc _ ltM (T2M x) (T2M x1)
     (consA (T2M a) (consA (T2M b0) (consA (T2M b) (fP l2))))).
generalize (olist_ltT (pX b0 (pX b l2))); unfold olist, ltT in |- *;
 intros H'5; apply H'5.
rewrite (fP_app (pX b0 (pX b l2)) (pX x1 (pX x pO))); simpl in |- *; auto.
generalize (app_ass (fP l2) (consA (T2M x1) nilA) (consA (T2M x) nilA));
 simpl in |- *; auto; unfold consA in |- *.
intros H'6; rewrite <- H'6; simpl in |- *; auto.
simpl in |- *; apply H'3; auto; apply (desc_prefix _ ltM) with (a := T2M x);
 auto.
Qed.
 
Lemma fp_tail : forall x p, fP (p ++ x :: nil) = fP p ++ T2M x :: nil.
intros x p; elim p; simpl in |- *; auto.
intros a l H'; rewrite H'; auto.
Qed.
 
Lemma descA_subst : forall a b : listA, b = a -> DescA a -> DescA b.
intros a b H'; rewrite H'; auto.
Qed.
 
Theorem olist_pX_eqT :
 forall a b p, olist (pX a p) -> eqT a b -> olist (pX b p).
unfold olist, eqT in |- *.
simpl in |- *; auto.
intros a b p H' H'0; rewrite <- H'0; auto.
Qed.
 
Theorem olist_pX_order : forall l a b, olist (pX a (pX b l)) -> ltT b a.
intros l a b H'.
elim (dist_Desc_concat _ ltM (consA (T2M a) (consA (T2M b) nilA)) (fP l));
 [ intros H'5 H'6 | idtac ]; auto.
apply olist_ltT with (l := pO); auto.
Qed.
 
Theorem olist_X : forall (l : list _) a, olist (pX a l) -> olist l.
intros l a H'.
elim (dist_Desc_concat _ ltM (consA (T2M a) nilA) (fP l));
 [ intros H'5 H'6 | idtac ]; auto.
Qed.
 
Theorem olist_imp_olist :
 forall l a b, olist (pX a (pX b l)) -> olist (pX a l).
intros l; case l.
intros a b H'.
elim (dist_Desc_concat _ ltM (consA (T2M a) nilA) (consA (T2M b) nilA));
 [ intros H'5 H'6 | idtac ]; auto.
intros b l0 a b0 H'.
apply olist_cons; auto.
apply ltT_trans with (y := b0).
apply olist_pX_order with (l := l0); auto.
apply olist_X with (a := a); auto.
apply olist_pX_order with (l := b :: l0); auto.
apply olist_X with (a := b0); auto.
apply olist_X with (a := a); auto.
Qed.
Set Implicit Arguments.
Unset Strict Implicit.
 
Inductive ltP : list (Term A n) -> list (Term A n) -> Prop :=
  | ltPO : forall x p, ltP pO (pX x p)
  | ltP_hd : forall x y p q, ltT x y -> ltP (pX x p) (pX y q)
  | ltP_tl : forall x y p q, eqT x y -> ltP p q -> ltP (pX x p) (pX y q).
Set Strict Implicit.
Unset Implicit Arguments.
 
Lemma fltP : forall p q, ltP p q -> Ltl _ ltM (fP p) (fP q).
intros p q H'; elim H'; auto.
simpl in |- *; intros; apply (Lt_nil (mon n)); auto.
simpl in |- *; intros; apply (Lt_hd (mon n)); auto.
simpl in |- *; unfold eqT in |- *; (intros x y p1 q1 H; rewrite H).
simpl in |- *; intros; apply (Lt_tl (mon n)); auto.
Qed.
Hint Resolve fltP.
 
Theorem ltp_not_refl : forall x, ~ ltP x x.
intros x; elim x.
red in |- *; intros H'; inversion H'.
intros a l H'; red in |- *; intros H'0; simple inversion H'0.
discriminate H.
injection H1.
injection H0.
intros H'1 H'2 H'3 H'4; rewrite H'2; rewrite H'4; intros H'5.
apply (ltT_not_refl a); auto.
injection H1; injection H2.
intros H'1 H'2 H'3 H'4; rewrite H'1; rewrite H'3; auto.
Qed.
Hint Resolve ltPO.
 
Theorem ltP_trans : forall x y z, ltP x y -> ltP y z -> ltP x z.
intros x y z H'; generalize z; clear z; elim H'.
intros x0 p z; case z; auto.
intros H'0; inversion H'0.
intros x0 y0 p q H'0 z H'1; simple inversion H'1.
discriminate H.
rewrite <- H1.
intros H'2; try assumption.
apply ltP_hd; auto.
apply ltT_trans with (y := y0); auto.
injection H0.
intros H'3 H'4; rewrite <- H'4; auto.
rewrite <- H2.
intros H'2 H'3; apply ltP_hd; auto.
apply ltT_eqTl with (a := x1); auto.
injection H1.
intros H'4 H'5; rewrite H'5; auto.
intros x0 y0 p q H'0 H'1 H'2 z H'3; simple inversion H'3.
discriminate H.
rewrite <- H1; auto.
intros H'4; apply ltP_hd; auto.
apply ltT_eqTr with (a := y0).
apply (eqT_sym A n); auto.
injection H0.
intros H'5 H'6; rewrite <- H'6; auto.
rewrite <- H2.
intros H'4 H'5; apply ltP_tl; auto.
apply (eqT_trans A n) with (y := x1); auto.
injection H1.
intros H'6 H'7; rewrite H'7; auto.
apply H'2; auto.
injection H1.
intros H'6; rewrite <- H'6; auto.
Qed.
 
Theorem olist_pX_ltP : forall a p, olist (pX a p) -> ltP p (pX a pO).
intros a p; case p; auto.
intros b l H'.
apply ltP_hd; auto.
apply olist_pX_order with (l := l); auto.
Qed.
 
Theorem ltP_pX_olist :
 forall a p, olist p -> ltP p (pX a pO) -> olist (pX a p).
intros a p; case p; auto.
intros H' H'1; unfold olist, DescA, consA in |- *; simpl in |- *;
 unfold consA, nilA in |- *.
apply d_one; auto.
intros b l H' H'0.
apply olist_cons; auto.
simple inversion H'0.
discriminate H.
injection H1; injection H0; intros H'1 H'2 H'3 H'4;
 (rewrite H'2; rewrite H'4); auto.
injection H2; intros H'1 H'2; rewrite H'1; auto.
unfold pO in |- *; intros H'3 H'4; inversion H'4.
Qed.

Theorem ltP_order_comp :
 forall (a b c : Term A n) (p q : list (Term A n)),
 ltP (pX b p) (pX a q) -> ltT a c -> ltT b c.
intros a b c p q H1; inversion_clear H1.
intros; apply ltT_trans with (y := a); auto.
apply eqT_compat_ltTl.
apply eqT_sym; trivial.
Qed.
Hint Resolve ltP_order_comp.

Set Implicit Arguments.
Unset Strict Implicit.
 
Definition nZterm : list (Term A n) -> Prop.
intros H'; elim H'.
exact True.
intros a P1 Rec.
exact (Rec /\ ~ zeroP (A:=A) A0 eqA (n:=n) a).
Defined.
 
Definition canonical (a : list (Term A n)) : Prop := olist a /\ nZterm a.
Set Strict Implicit.
Unset Implicit Arguments.
 
Theorem canonical_imp_olist : forall a, canonical a -> olist a.
intros a H'; elim H'; auto.
Qed.
Hint Resolve canonical_imp_olist.
 
Theorem canonical0 :
 forall a b,
 ltT b a ->
 ~ zeroP (A:=A) A0 eqA (n:=n) a ->
 ~ zeroP (A:=A) A0 eqA (n:=n) b -> canonical (pX a (pX b pO)).
intros a b H' H'0 H'1; simpl in |- *; auto.
split; simpl in |- *; auto.
Qed.
 
Theorem canonical_ltT :
 forall l a b, canonical (l ++ pX a (pX b pO)) -> ltT b a.
intros l a b H'; auto.
apply olist_ltT with (l := l); auto.
Qed.
 
Theorem canonical_nzeroP :
 forall a p, canonical (pX a p) -> ~ zeroP (A:=A) A0 eqA (n:=n) a.
intros a p H'; red in |- *; intros H'0; inversion H'.
generalize H0; simpl in |- *; intuition; auto.
Qed.
 
Theorem canonical_cons :
 forall l a b,
 ltT b a ->
 ~ zeroP (A:=A) A0 eqA (n:=n) a ->
 canonical (pX b l) -> canonical (pX a (pX b l)).
intros l a b H' H'0 H'1; split; simpl in |- *; auto.
apply olist_cons; auto.
repeat split; auto.
inversion H'1; simpl in H0; intuition.
apply canonical_nzeroP with (p := l); auto.
Qed.
 
Theorem canonical_pX_eqT :
 forall a b p,
 canonical (pX a p) ->
 eqT a b -> ~ zeroP (A:=A) A0 eqA (n:=n) b -> canonical (pX b p).
intros a b p H' H'0 H'1.
split; auto.
apply olist_pX_eqT with (a := a); auto.
simpl in |- *; split; auto.
case H'; simpl in |- *; intuition.
Qed.
 
Theorem canonical_pX_order :
 forall l a b, canonical (pX a (pX b l)) -> ltT b a.
intros l a b H'; auto.
apply olist_pX_order with (l := l); auto.
Qed.
 
Theorem canonical_imp_canonical :
 forall l a, canonical (pX a l) -> canonical l.
intros l a H'.
split; auto.
apply olist_X with (a := a); auto.
elim H'; simpl in |- *; intuition.
Qed.
 
Theorem canonical_skip_fst :
 forall l a b, canonical (pX a (pX b l)) -> canonical (pX a l).
intros l a b H'; split; auto.
apply olist_imp_olist with (b := b); auto.
inversion H'.
generalize H0; simpl in |- *; intuition.
Qed.
 
Theorem canonical_pX_ltP : forall a p, canonical (pX a p) -> ltP p (pX a pO).
intros a p H'; auto.
apply olist_pX_ltP; auto.
Qed.
 
Theorem ltP_pX_canonical :
 forall a p,
 canonical p ->
 ~ zeroP (A:=A) A0 eqA (n:=n) a -> ltP p (pX a pO) -> canonical (pX a p).
intros a p H' H'0 H'1; split; auto.
apply ltP_pX_olist; auto.
inversion H'.
generalize H0 H'0; simpl in |- *; case (zeroP_dec A A0 eqA eqA_dec n a); auto.
Qed.
 
Theorem not_double_canonical :
 forall (a : Term A n) (p : list (Term A n)), ~ canonical (pX a (pX a p)).
intros a p; red in |- *; intros H'; try exact H'.
absurd (ltT a a); auto.
apply canonical_pX_order with (l := p); auto.
Qed.

Theorem canonical_imp_in_nzero :
 forall p : list (Term A n),
 canonical p -> forall a : Term A n, In a p -> ~ zeroP (A:=A) A0 eqA (n:=n) a.
intros p; elim p; auto.
intros a l H' H'0 a0 H'1; elim H'1; auto.
intros H'2; rewrite <- H'2.
apply canonical_nzeroP with (p := l); auto.
intros H'2; auto.
apply H'; auto.
apply canonical_imp_canonical with (a := a); auto.
Qed.
 
Set Implicit Arguments.
Unset Strict Implicit.
 
Definition poly := {a : list _ | canonical a}.
 
Definition sltP (sa sb : poly) : Prop :=
  let (p, H1) return Prop := sa in let (q, H2) return Prop := sb in ltP p q.
 
Definition fspoly (sa : poly) : Pow _ ltM :=
  let (p, H) return (Pow _ ltM) := sa in
  exist DescA (fP p) (canonical_imp_olist p H).
Set Strict Implicit.
Unset Implicit Arguments.
 
Theorem fsltP :
 forall p q : poly, sltP p q -> lex_exp _ ltM (fspoly p) (fspoly q).
intros p q; case p; case q; unfold lex_exp in |- *; simpl in |- *; auto.
Qed.
Hint Resolve fsltP.
 
Theorem sltp_wf : well_founded sltP.
lapply (wf_inverse_image poly (Pow _ ltM) (lex_exp _ ltM) fspoly);
 [ intros H'3 | idtac ].
apply
 wf_incl with (R2 := fun x y : poly => lex_exp _ ltM (fspoly x) (fspoly y));
 auto.
red in |- *; auto.
apply (wf_lex_exp _ ltM); auto; apply ltM_wf with (1 := os).
Qed.
End Porder.