
Require Export Relation_Definitions.
Require Import Arith.
Require Import Compare_dec.
Require Export CoefStructure.
(* CoefStructure:
Require Import Relation_Definitions.

Record CoefStructure (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop)
  (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A)
  (divA : A -> forall b : A, ~ eqA b A0 -> A) : Prop := mkCoefStructure
  {A1_diff_A0 : ~ eqA A1 A0;
   eqA_ref : reflexive A eqA;
   eqA_sym : symmetric A eqA;
   eqA_trans : transitive A eqA;
   plusA_assoc :
    forall a b c : A, eqA (plusA a (plusA b c)) (plusA (plusA a b) c);
   plusA_com : forall a b : A, eqA (plusA a b) (plusA b a);
   plusA_eqA_comp :
    forall a b c d : A, eqA a c -> eqA b d -> eqA (plusA a b) (plusA c d);
   plusA_A0 : forall a : A, eqA a (plusA a A0);
   invA_plusA : forall a : A, eqA A0 (plusA a (invA a));
   invA_eqA_comp : forall a b : A, eqA a b -> eqA (invA a) (invA b);
   minusA_def : forall a b : A, eqA (minusA a b) (plusA a (invA b));
   multA_eqA_comp :
    forall a b c d : A, eqA a c -> eqA b d -> eqA (multA a b) (multA c d);
   multA_assoc :
    forall a b c : A, eqA (multA a (multA b c)) (multA (multA a b) c);
   multA_com : forall a b : A, eqA (multA a b) (multA b a);
   multA_dist_l :
    forall a b c : A,
    eqA (plusA (multA c a) (multA c b)) (multA c (plusA a b));
   multA_A0_l : forall a : A, eqA (multA A0 a) A0;
   multA_A1_l : forall a : A, eqA (multA A1 a) a;
   divA_rew :
    forall (a b : A) (nZ1 nZ2 : ~ eqA b A0), divA a b nZ1 = divA a b nZ2;
   divA_is_multA :
    forall (a b : A) (nZb : ~ eqA b A0), eqA a (multA (divA a b nZb) b);
   divA_eqA_comp :
    forall (a b c d : A) (nZb : ~ eqA b A0) (nZd : ~ eqA d A0),
    eqA a c -> eqA b d -> eqA (divA a b nZb) (divA c d nZd);
   divA_multA_comp_r :
    forall (a b c : A) (nZc : ~ eqA c A0),
    eqA (divA (multA a b) c nZc) (multA (divA a c nZc) b);
   divA_invA_r :
    forall (a b : A) (nZb : ~ eqA b A0) (nZib : ~ eqA (invA b) A0),
    eqA (divA a (invA b) nZib) (invA (divA a b nZb))}. *)
Require Export OrderStructure.
(* OrderStructure:
Require Import Relation_Definitions.

Record OrderStructure (A : Set) (M1 : A) (ltM : A -> A -> Prop)
  (plusM : A -> A -> A) : Prop := mkOrderStructure
  {M1_min : forall x : A, ~ ltM x M1;
   ltM_nonrefl : forall x : A, ~ ltM x x;
   ltM_trans : transitive A ltM;
   ltM_wf : well_founded ltM;
   ltM_plusr : forall x y z : A, ltM x y -> ltM (plusM x z) (plusM y z);
   ltM_plusl : forall x y z : A, ltM x y -> ltM (plusM z x) (plusM z y)}. *)
Require Export POrder.
(* POrder:
Require Import Lexicographic_Exponentiation.
Require Import Relation_Definitions.
Require Import Inverse_Image.
Require Import Inclusion.
Require Import List.
Require Import Relation_Operators.
Require Import Relation_Operators_compat.
Require Import Monomials.
Require Import Term.
Require Import CoefStructure.
Require Import OrderStructure.
Section Porder.
Load "hCoefStructure".
Load "hOrderStructure".
Load "hTerm".

Set Implicit Arguments.
Unset Strict Implicit.
 
Definition ltT (a b : Term A n) : Prop := ltM (T2M a) (T2M b).
Hint Unfold ltT.
Set Strict Implicit.
Unset Implicit Arguments.
 
Theorem ltT_trans : transitive (Term A n) ltT.
 
Lemma eqT_compat_ltTr :
 forall a b c : Term A n, eqT b c -> ltT a b -> ltT a c.
 
Lemma eqT_compat_ltTl :
 forall a b c : Term A n, eqT b c -> ltT b a -> ltT c a.
 
Theorem eqT_dec : forall x y : Term A n, {eqT x y} + {~ eqT x y}.
 
Theorem ltT_dec : forall x y : Term A n, {ltT x y} + {ltT y x} + {eqT x y}.
 
Lemma ltT_not_eqT : forall x y : Term A n, eqT x y -> ~ ltT x y.
 
Lemma eqT_not_ltT : forall x y : Term A n, ltT x y -> ~ eqT x y.
 
Theorem ltT_not_refl : forall x : Term A n, ~ ltT x x.
Hint Resolve ltT_not_eqT eqT_not_ltT ltT_not_refl.
 
Lemma ltT_not_ltT : forall x y : Term A n, ltT x y -> ~ ltT y x.
Hint Resolve ltT_not_ltT.
 
Lemma ltT_eqT :
 forall a b c d : Term A n, eqT a b -> eqT c d -> ltT a c -> ltT b d.
 
Let eqT_refl := eqT_refl A n.
 
Lemma ltT_eqTr : forall a b c : Term A n, eqT a b -> ltT a c -> ltT b c.
 
Lemma ltT_eqTl : forall a b c : Term A n, eqT a b -> ltT c a -> ltT c b.
 
Theorem multTerm_ltT_l :
 forall m1 m2 m3,
 ltT m1 m2 -> ltT (multTerm multA m3 m1) (multTerm multA m3 m2).
 
Theorem multTerm_ltT_r :
 forall m1 m2 m3,
 ltT m1 m2 -> ltT (multTerm multA m1 m3) (multTerm multA m2 m3).
 
Theorem T1_is_min_ltT : forall a, ~ ltT a (T1 A1 n).
 
Theorem minusTerm_ltT_l :
 forall a b c, eqT a b -> ltT a c -> ltT (minusTerm minusA a b) c.
 
Theorem invTerm_ltT_l : forall a c, ltT a c -> ltT (invTerm invA a) c.
Set Implicit Arguments.
Unset Strict Implicit.
 
Definition pX := cons (A:=Term A n).
Set Strict Implicit.
Unset Implicit Arguments.
 
Definition pO := nil (A:=Term A n).
 
Let consA := cons (A:=mon n).
 
Let nilA := nil (A:=mon n).
 
Let listA := list (mon n).
Hint Unfold consA nilA listA.
 
Fixpoint fP (a : list (Term A n)) : listA :=
  match a with
  | nil => nilA
  | b :: p => consA (T2M b) (fP p)
  end.
 
Theorem fP_app : forall p q : list (Term A n), fP (p ++ q) = fP p ++ fP q.
 
Let DescA := Desc (mon n) ltM.
Set Implicit Arguments.
Unset Strict Implicit.
 
Definition olist (p : list (Term A n)) := DescA (fP p).
Hint Resolve d_nil d_one.
Hint Unfold olist DescA.
Set Strict Implicit.
Unset Implicit Arguments.
 
Theorem olistOne : forall a b : Term A n, ltT b a -> olist (pX a (pX b pO)).
Hint Resolve olistOne.
 
Theorem olistO : olist pO.
 
Lemma app2_inv :
 forall (x y z t : mon n) (p : listA),
 (p ++ consA x nilA) ++ consA y nilA = consA z (consA t nilA) ->
 x = z /\ y = t.
 
Theorem olist_ltT :
 forall (l : list (Term A n)) (a b : Term A n),
 olist (l ++ pX a (pX b pO)) -> ltT b a.
 
Theorem olist_cons :
 forall (l : list _) a b, ltT b a -> olist (pX b l) -> olist (pX a (pX b l)).
 
Lemma fp_tail : forall x p, fP (p ++ x :: nil) = fP p ++ T2M x :: nil.
 
Lemma descA_subst : forall a b : listA, b = a -> DescA a -> DescA b.
 
Theorem olist_pX_eqT :
 forall a b p, olist (pX a p) -> eqT a b -> olist (pX b p).
 
Theorem olist_pX_order : forall l a b, olist (pX a (pX b l)) -> ltT b a.
 
Theorem olist_X : forall (l : list _) a, olist (pX a l) -> olist l.
 
Theorem olist_imp_olist :
 forall l a b, olist (pX a (pX b l)) -> olist (pX a l).
Set Implicit Arguments.
Unset Strict Implicit.
 
Inductive ltP : list (Term A n) -> list (Term A n) -> Prop :=
  | ltPO : forall x p, ltP pO (pX x p)
  | ltP_hd : forall x y p q, ltT x y -> ltP (pX x p) (pX y q)
  | ltP_tl : forall x y p q, eqT x y -> ltP p q -> ltP (pX x p) (pX y q).
Set Strict Implicit.
Unset Implicit Arguments.
 
Lemma fltP : forall p q, ltP p q -> Ltl _ ltM (fP p) (fP q).
Hint Resolve fltP.
 
Theorem ltp_not_refl : forall x, ~ ltP x x.
Hint Resolve ltPO.
 
Theorem ltP_trans : forall x y z, ltP x y -> ltP y z -> ltP x z.
 
Theorem olist_pX_ltP : forall a p, olist (pX a p) -> ltP p (pX a pO).
 
Theorem ltP_pX_olist :
 forall a p, olist p -> ltP p (pX a pO) -> olist (pX a p).

Theorem ltP_order_comp :
 forall (a b c : Term A n) (p q : list (Term A n)),
 ltP (pX b p) (pX a q) -> ltT a c -> ltT b c.
Hint Resolve ltP_order_comp.

Set Implicit Arguments.
Unset Strict Implicit.
 
Definition nZterm : list (Term A n) -> Prop.
 
Definition canonical (a : list (Term A n)) : Prop := olist a /\ nZterm a.
Set Strict Implicit.
Unset Implicit Arguments.
 
Theorem canonical_imp_olist : forall a, canonical a -> olist a.
Hint Resolve canonical_imp_olist.
 
Theorem canonical0 :
 forall a b,
 ltT b a ->
 ~ zeroP (A:=A) A0 eqA (n:=n) a ->
 ~ zeroP (A:=A) A0 eqA (n:=n) b -> canonical (pX a (pX b pO)).
 
Theorem canonical_ltT :
 forall l a b, canonical (l ++ pX a (pX b pO)) -> ltT b a.
 
Theorem canonical_nzeroP :
 forall a p, canonical (pX a p) -> ~ zeroP (A:=A) A0 eqA (n:=n) a.
 
Theorem canonical_cons :
 forall l a b,
 ltT b a ->
 ~ zeroP (A:=A) A0 eqA (n:=n) a ->
 canonical (pX b l) -> canonical (pX a (pX b l)).
 
Theorem canonical_pX_eqT :
 forall a b p,
 canonical (pX a p) ->
 eqT a b -> ~ zeroP (A:=A) A0 eqA (n:=n) b -> canonical (pX b p).
 
Theorem canonical_pX_order :
 forall l a b, canonical (pX a (pX b l)) -> ltT b a.
 
Theorem canonical_imp_canonical :
 forall l a, canonical (pX a l) -> canonical l.
 
Theorem canonical_skip_fst :
 forall l a b, canonical (pX a (pX b l)) -> canonical (pX a l).
 
Theorem canonical_pX_ltP : forall a p, canonical (pX a p) -> ltP p (pX a pO).
 
Theorem ltP_pX_canonical :
 forall a p,
 canonical p ->
 ~ zeroP (A:=A) A0 eqA (n:=n) a -> ltP p (pX a pO) -> canonical (pX a p).
 
Theorem not_double_canonical :
 forall (a : Term A n) (p : list (Term A n)), ~ canonical (pX a (pX a p)).

Theorem canonical_imp_in_nzero :
 forall p : list (Term A n),
 canonical p -> forall a : Term A n, In a p -> ~ zeroP (A:=A) A0 eqA (n:=n) a.
 
Set Implicit Arguments.
Unset Strict Implicit.
 
Definition poly := {a : list _ | canonical a}.
 
Definition sltP (sa sb : poly) : Prop :=
  let (p, H1) return Prop := sa in let (q, H2) return Prop := sb in ltP p q.
 
Definition fspoly (sa : poly) : Pow _ ltM :=
  let (p, H) return (Pow _ ltM) := sa in
  exist DescA (fP p) (canonical_imp_olist p H).
Set Strict Implicit.
Unset Implicit Arguments.
 
Theorem fsltP :
 forall p q : poly, sltP p q -> lex_exp _ ltM (fspoly p) (fspoly q).
Hint Resolve fsltP.
 
Theorem sltp_wf : well_founded sltP.
End Porder. *)
Require Export Monomials.
(* Monomials:
Section Monomials.
Require Import Arith.
Require Import Compare.
Require Import Compare_dec.
Require Import Peano_dec.

Inductive mon : nat -> Set :=
  | n_0 : mon 0
  | c_n : forall d : nat, nat -> mon d -> mon (S d).

Definition pmon1 : forall d : nat, mon d -> nat.

Definition pmon2 : forall d : nat, mon d -> mon (pred d).

Definition recomp : forall d : nat, d <> 0 -> mon d -> mon d.

Lemma recomp_ok : forall (d : nat) (h : d <> 0) (m : mon d), recomp d h m = m.

Lemma proj_ok :
 forall (d : nat) (m : mon (S d)), c_n d (pmon1 (S d) m) (pmon2 (S d) m) = m.

Definition gen_mon : forall d : nat, nat -> mon d.

Definition mult_mon : forall d : nat, mon d -> mon d -> mon d.

Theorem mult_mon_com :
 forall (d : nat) (a b : mon d), mult_mon d a b = mult_mon d b a.

Theorem mult_mon_assoc :
 forall (d : nat) (a b c : mon d),
 mult_mon d a (mult_mon d b c) = mult_mon d (mult_mon d a b) c.

Definition zero_mon : forall d : nat, mon d.

Theorem mult_mon_zero_r :
 forall (d : nat) (a : mon d), mult_mon d a (zero_mon d) = a.

Theorem mult_mon_zero_l :
 forall (d : nat) (a : mon d), mult_mon d (zero_mon d) a = a.

Inductive mdiv : forall d : nat, mon d -> mon d -> Prop :=
  | mdiv_nil : mdiv 0 n_0 n_0
  | mdiv_cons :
      forall (d : nat) (v v' : mon d) (n n' : nat),
      n <= n' -> mdiv d v v' -> mdiv (S d) (c_n d n v) (c_n d n' v').
Hint Resolve mdiv_nil mdiv_cons.

Lemma mdiv_proj :
 forall (d : nat) (m m' : mon (S d)),
 pmon1 (S d) m <= pmon1 (S d) m' ->
 mdiv d (pmon2 (S d) m) (pmon2 (S d) m') -> mdiv (S d) m m'.
Require Import Relation_Definitions.
Require Import Eqdep.

Lemma mdiv_trans : forall d : nat, transitive (mon d) (mdiv d).

Definition div_mon : forall d : nat, mon d -> mon d -> mon d.

Theorem mdiv_div :
 forall (d : nat) (a b : mon d),
 mdiv d b a -> mult_mon d (div_mon d a b) b = a.

Definition div_mon_clean : forall d : nat, mon d -> mon d -> mon d * bool.

Definition is_nil : forall d : nat, mon d -> mon d.

Theorem is_nil_id : forall (d : nat) (a : mon d), a = is_nil d a.

Theorem mon_0 : forall a : mon 0, a = n_0.
Hint Resolve mon_0.

Theorem eqmon_dec : forall (d : nat) (x y : mon d), {x = y} + {x <> y}.

Theorem mult_div_com :
 forall (d : nat) (a b : mon d), div_mon d (mult_mon d a b) b = a.

Theorem mult_div_id :
 forall (d : nat) (a : mon d), div_mon d a a = zero_mon d.

Let gb : forall d : nat, mon d * bool -> bool.

Let gm : forall d : nat, mon d * bool -> mon d.

Theorem minus_lt_0 : forall m n : nat, n < m -> n - m = 0.

Theorem div_clean_dec2 :
 forall (d : nat) (a b : mon d),
 gb d (div_mon_clean d a b) = false -> mult_mon d (div_mon d a b) b <> a.

Theorem div_clean_dec1 :
 forall (d : nat) (a b : mon d),
 gb d (div_mon_clean d a b) = true ->
 gm d (div_mon_clean d a b) = div_mon d a b /\
 mult_mon d (div_mon d a b) b = a.
Require Import Max.

Definition ppcm_mon : forall d : nat, mon d -> mon d -> mon d.

Theorem ppcm_com :
 forall (d : nat) (a b : mon d), ppcm_mon d a b = ppcm_mon d b a.

Theorem ppcm_prop_l :
 forall (d : nat) (a b : mon d),
 ppcm_mon d a b = mult_mon d (div_mon d (ppcm_mon d a b) a) a.

Theorem ppcm_prop_r :
 forall (d : nat) (a b : mon d),
 ppcm_mon d a b = mult_mon d (div_mon d (ppcm_mon d a b) b) b.

Theorem plus_minus_le : forall a b : nat, a - b + b = a -> b <= a.

Theorem ppcm_mom_is_ppcm :
 forall (d : nat) (a b c : mon d),
 c = mult_mon d (div_mon d c a) a ->
 c = mult_mon d (div_mon d c b) b ->
 c = mult_mon d (div_mon d c (ppcm_mon d a b)) (ppcm_mon d a b).
End Monomials. *)
Require Export Term.
(* Term:
Require Import Relation_Definitions.
Require Import CoefStructure.
Require Import moreCoefStructure.
Require Import OrderStructure.
Require Import Monomials.
Section Term.
Load "hCoefStructure".
Load "mCoefStructure".
Load "hOrderStructure".
Load "mOrderStructure".
 
Definition M1 := zero_mon n.
 
Definition Term := (A * mon n)%type.
Set Implicit Arguments.
Unset Strict Implicit.
 
Definition zeroP : Term -> Prop.
 
Definition eqTerm : Term -> Term -> Prop.
Set Strict Implicit.
Unset Implicit Arguments.
 
Theorem eqTerm_refl : reflexive Term eqTerm.
 
Theorem eqTerm_sym : symmetric Term eqTerm.
 
Theorem eqTerm_trans : transitive Term eqTerm.
Set Implicit Arguments.
Unset Strict Implicit.
 
Definition T2M : Term -> mon n.
Set Strict Implicit.
Unset Implicit Arguments.
Set Implicit Arguments.
Unset Strict Implicit.
 
Definition eqT (a b : Term) : Prop := T2M a = T2M b.
Hint Unfold eqT.
Set Strict Implicit.
Unset Implicit Arguments.
 
Lemma eqT_refl : reflexive _ eqT.
 
Lemma eqT_sym : symmetric _ eqT.
 
Lemma eqT_trans : transitive _ eqT.
 
Theorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.
 
Theorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.
 
Theorem eqT_zerop_is_eqTerm :
 forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.
 
Theorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.
 
Theorem zeroP_comp_eqTerm :
 forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.

Theorem nzeroP_comp_eqTerm :
 forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.

Set Implicit Arguments.
Unset Strict Implicit.
 
Definition plusTerm : Term -> Term -> Term.
Set Strict Implicit.
Unset Implicit Arguments.
 
Theorem zeroP_plusTermr :
 forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).
 
Theorem zeroP_plusTerml :
 forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).
 
Theorem plusTerm_comp_l :
 forall a b c : Term,
 eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).
 
Theorem plusTerm_comp_r :
 forall a b c : Term,
 eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).
 
Theorem plusTerm_com :
 forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).
 
Theorem plusTerm_eqT1 :
 forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.
 
Theorem plusTerm_eqT2 :
 forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.
 
Theorem plusTerm_assoc :
 forall a a0 A1 : Term,
 eqT A1 a0 ->
 eqT a a0 ->
 eqTerm (plusTerm (plusTerm A1 a0) a) (plusTerm A1 (plusTerm a0 a)).
 
Theorem eqTerm_plusTerm_comp :
 forall a b c d : Term,
 eqT a c ->
 eqT b d -> eqTerm a b -> eqTerm c d -> eqTerm (plusTerm a c) (plusTerm b d).
Hint Resolve eqTerm_plusTerm_comp.

Set Implicit Arguments.
Unset Strict Implicit.
 
Definition multTerm : Term -> Term -> Term.
Set Strict Implicit.
Unset Implicit Arguments.
 
Theorem zeroP_multTerm_l : forall a b : Term, zeroP a -> zeroP (multTerm a b).
 
Theorem zeroP_multTerm_r : forall a b : Term, zeroP a -> zeroP (multTerm b a).
 
Theorem multTerm_plusTerm_dist_l :
 forall a b c : Term,
 eqTerm (plusTerm (multTerm a c) (multTerm b c)) (multTerm (plusTerm a b) c).
 
Theorem multTerm_plusTerm_dist_r :
 forall a b c : Term,
 eqTerm (plusTerm (multTerm c a) (multTerm c b)) (multTerm c (plusTerm a b)).
 
Theorem multTerm_eqT :
 forall a b c d : Term,
 eqT a b -> eqT c d -> eqT (multTerm a c) (multTerm b d).
 
Theorem multTerm_assoc :
 forall a b c : Term,
 eqTerm (multTerm a (multTerm b c)) (multTerm (multTerm a b) c).
 
Theorem multTerm_com :
 forall a b : Term, eqTerm (multTerm a b) (multTerm b a).
 
Theorem eqTerm_multTerm_comp :
 forall a b c d : Term,
 eqTerm a b -> eqTerm c d -> eqTerm (multTerm a c) (multTerm b d).
Hint Resolve eqTerm_multTerm_comp.
 
Set Implicit Arguments.
Unset Strict Implicit.
 
Definition invTerm : Term -> Term.
Set Strict Implicit.
Unset Implicit Arguments.
 
Theorem plusTerm_invTerm_zeroP :
 forall a : Term, zeroP (plusTerm a (invTerm a)).
 
Theorem zeroP_invTerm_zeroP : forall a : Term, zeroP a -> zeroP (invTerm a).
 
Theorem invTerm_invol : forall a : Term, eqTerm a (invTerm (invTerm a)).
 
Theorem nZero_invTerm_nZero :
 forall a : Term, ~ zeroP a -> ~ zeroP (invTerm a).
Hint Resolve nZero_invTerm_nZero.
Set Implicit Arguments.
Unset Strict Implicit.
 
Definition T1 : Term.
Set Strict Implicit.
Unset Implicit Arguments.
 
Theorem T1_nz : ~ zeroP T1.
 
Theorem T1_multTerm_l :
 forall a b : Term, eqTerm a T1 -> eqTerm b (multTerm a b).
 
Theorem T1_multTerm_r :
 forall a b : Term, eqTerm a T1 -> eqTerm b (multTerm b a).
 
Theorem nZero_invTerm_T1 : ~ zeroP (invTerm T1).
Hint Resolve nZero_invTerm_T1.
 
Theorem mult_invTerm_com :
 forall a b : Term, eqTerm (multTerm (invTerm a) b) (invTerm (multTerm a b)).
 
Theorem mult_invTerm_com_r :
 forall a b : Term, eqTerm (multTerm a (invTerm b)) (invTerm (multTerm a b)).
 
Theorem eqTerm_invTerm_comp :
 forall a b : Term, eqTerm a b -> eqTerm (invTerm a) (invTerm b).
 
Theorem invTerm_eqT : forall a : Term, eqT a (invTerm a).
 
Theorem T1_eqT : forall a b : Term, eqTerm a T1 -> eqT b (multTerm a b).
 
Theorem eqTerm_T1_eqT : forall a : Term, eqTerm a T1 -> eqT a T1.
Set Implicit Arguments.
Unset Strict Implicit.
 
Definition minusTerm : Term -> Term -> Term.
Set Strict Implicit.
Unset Implicit Arguments.
 
Theorem eqTerm_minusTerm_plusTerm_invTerm :
 forall a b : Term, eqTerm (minusTerm a b) (plusTerm a (invTerm b)).
 
Theorem minusTerm_eqT :
 forall m1 m2 : Term, eqT m1 m2 -> eqT (minusTerm m1 m2) m1.
 
Theorem zeroP_minusTerm : forall a : Term, zeroP (minusTerm a a).
 
Theorem multTerm_zeroP_div :
 forall a b : Term, zeroP (multTerm a b) -> zeroP a \/ zeroP b.
 
Theorem multTerm_minusTerm_dist_l :
 forall a b c : Term,
 eqT a b ->
 eqTerm (minusTerm (multTerm a c) (multTerm b c))
   (multTerm (minusTerm a b) c).
Hint Resolve multTerm_minusTerm_dist_l.
 
Theorem nzeroP_multTerm :
 forall a b : Term, ~ zeroP a -> ~ zeroP b -> ~ zeroP (multTerm a b).
End Term. *)
Require Export List.
Section Peq.
Load "hCoefStructure".
Load "hOrderStructure".
Load "hOrder".
 
Definition size := length (A:=Term A n).
 
Definition sizel m := match m with
                      | (l1, l2) => size l1 + size l2
                      end.
 
Definition lessP m1 m2 := sizel m1 < sizel m2.
Hint Unfold lessP.
 
Lemma wf_lessP : well_founded lessP.
red in |- *.
cut (forall (m : nat) a, sizel a < m -> Acc lessP a).
intros H' a.
apply H' with (m := S (sizel a)); auto.
intros m; elim m; clear m.
intros a H; inversion H.
intros m H' a H'0.
apply Acc_intro.
intros y H'1; apply H'.
unfold lessP in H'1.
apply lt_le_trans with (sizel a); auto with arith.
Qed.
Hint Resolve wf_lessP.
 
Theorem pX_inj :
 forall (n1 n2 : Term A n) l1 l2, n1 = n2 -> l1 = l2 -> pX n1 l1 = pX n2 l2.
intros n1 n2 l1 l2 H' H'0; rewrite H'0; rewrite H'; auto.
Qed.
Hint Resolve pX_inj.
 
Lemma pX_invl : forall (a b : Term A n) p q, pX a p = pX b q -> a = b.
intros a b p q H'; inversion H'; auto.
Qed.
Hint Unfold pX.
 
Lemma pX_invr : forall p q (a b : Term A n), pX a p = pX b q -> p = q.
unfold pX, pX in |- *.
intros p q a b H'; inversion H'; auto.
Qed.
 
Theorem canonicalpO : canonical A0 eqA ltM (pO A n).
split; auto.
apply olistO.
red in |- *; simpl in |- *; auto.
Qed.
 
Theorem canonicalp1 :
 forall a,
 ~ zeroP (A:=A) A0 eqA (n:=n) a -> canonical A0 eqA ltM (pX a (pO A n)).
intros a H; split; simpl in |- *; auto.
red in |- *; simpl in |- *; apply Relation_Operators_compat.d_one.
Qed.
Hint Resolve canonicalp1 canonical0.
 
Inductive eqP : list (Term A n) -> list (Term A n) -> Prop :=
  | eqP0 : eqP (pO A n) (pO A n)
  | eqpP1 :
      forall ma mb p q,
      eqTerm (A:=A) eqA (n:=n) ma mb -> eqP p q -> eqP (pX ma p) (pX mb q).
Hint Resolve eqP0 eqpP1.
 
Theorem eqp_refl : reflexive _ eqP.
red in |- *.
intros x; elim x; auto.
intros a l H; change (eqP (pX a l) (pX a l)) in |- *; apply eqpP1; auto.
Qed.
 
Theorem eqp_sym : symmetric _ eqP.
red in |- *.
intros x y H'; elim H'; auto.
intros ma mb p q H H0 H1.
apply eqpP1; auto.
apply (eqTerm_sym _ _ _ _ _ _ _ _ _ cs n); auto.
Qed.
 
Lemma eqp_inv1 : forall p, eqP (pO A n) p -> p = pO A n.
unfold pO in |- *; intros p H'; inversion H'; auto.
Qed.
 
Theorem eqp_inv2 : forall p, eqP p (pO A n) -> p = pO A n.
unfold pO in |- *; intros p H'; inversion H'; auto.
Qed.
 
Theorem eqp_inv3l :
 forall a b p q, eqP (pX a p) (pX b q) -> eqTerm (A:=A) eqA (n:=n) a b.
intros a b p q H'; simple inversion H'; auto.
unfold pO in H0; inversion H0.
rewrite (pX_invl ma a p0 p); auto; rewrite (pX_invl mb b q0 q); auto.
Qed.
 
Theorem eqp_inv3r : forall a b p q, eqP (pX a p) (pX b q) -> eqP p q.
intros a b p q H'; simple inversion H'; auto.
unfold pO in H0; inversion H0.
rewrite (pX_invr p0 p ma a); auto; rewrite (pX_invr q0 q mb b); auto.
Qed.
 
Theorem eqp_trans : transitive _ eqP.
red in |- *.
intros x; elim x; auto.
intros y z H'; inversion_clear H'.
intros H'0; inversion_clear H'0; auto.
intros a l H' y z H'0; inversion_clear H'0.
intros H4; inversion_clear H4.
change (eqP (pX a l) (pX mb0 q0)) in |- *; apply eqpP1; eauto.
apply (eqTerm_trans _ _ _ _ _ _ _ _ _ cs n) with (y := mb); auto.
Qed.
Hint Resolve eqp_refl.
 
Let eqTerm_imp_eqT := eqTerm_imp_eqT A eqA n.
 
Theorem ltP_refl_pX :
 forall (a : Term A n) (p : list (Term A n)),
 canonical A0 eqA ltM (pX a p) -> ltP (A:=A) (n:=n) ltM p (pX a p).
intros a p; case p; auto.
intros a0 l H'.
apply ltP_trans with (y := pX a (pO A n)); auto.
change (ltP (A:=A) (n:=n) ltM (pX a0 l) (pX a (pO A n))) in |- *.
apply ltP_hd; auto.
apply (canonical_pX_order A A0) with (eqA := eqA) (l := l); auto.
apply ltP_tl; auto.
change (ltP (A:=A) (n:=n) ltM (pO A n) (pX a0 l)) in |- *; apply ltPO.
Qed.
 
Theorem eqp_eqTerm :
 forall a b p q, eqP (pX a p) (pX b q) -> eqTerm (A:=A) eqA (n:=n) a b.
intros a b p q H'; inversion_clear H'; trivial.
Qed.
 
Theorem ltp_eqp_comp :
 forall p q r s,
 ltP (A:=A) (n:=n) ltM p q ->
 canonical A0 eqA ltM p ->
 canonical A0 eqA ltM q -> eqP p r -> eqP q s -> ltP (A:=A) (n:=n) ltM r s.
intros p q r s H'; generalize r s; elim H'; clear r s H'; auto.
intros x p0 r s H H0 H1; inversion H1.
intros H4; inversion H4; apply ltPO.
intros x y p0 q0 H r s H0 H1 H2 H3; inversion_clear H2; try discriminate;
 inversion_clear H3; try discriminate; auto.
apply ltP_hd.
apply ltT_eqTl with (a := y); auto.
apply ltT_eqTr with (a := x); auto.
intros x y p0 q0 H H0 H1 r s H2 H3 H4 H5; inversion_clear H4;
 try discriminate; inversion_clear H5; try discriminate.
apply ltP_tl; auto.
apply (eqT_trans A n) with (y := y); auto.
apply (eqT_trans A n) with (y := x); auto.
apply (eqT_sym A n); auto.
apply H1; auto.
apply canonical_imp_canonical with (a := x); auto.
apply canonical_imp_canonical with (a := y); auto.
Qed.
 
Theorem eqp_imp_canonical :
 forall p q, eqP p q -> canonical A0 eqA ltM p -> canonical A0 eqA ltM q.
intros p q H'; elim H'; auto.
intros ma mb p0 q0 H'0 H'1 H'2 H'3.
apply canonical_pX_eqT with (a := ma); auto.
apply ltP_pX_canonical; auto.
apply H'2.
apply canonical_imp_canonical with (a := ma); auto.
apply (canonical_nzeroP A A0 eqA n ltM ma p0); auto.
apply ltp_eqp_comp with (p := p0) (q := pX ma (pO A n)); auto.
apply canonical_pX_ltP with (1 := H'3).
apply canonical_imp_canonical with (a := ma); auto.
apply canonicalp1; auto.
apply (canonical_nzeroP A A0 eqA n ltM ma p0); auto.
apply nzeroP_comp_eqTerm with (1 := cs) (a := ma); auto.
apply (canonical_nzeroP A A0 eqA n ltM ma p0); auto.
Qed.
 
Definition sizel3
  (m : list (Term A n) * (list (Term A n) * list (Term A n))) :=
  match m with
  | (l1, (l2, l3)) => size l1 + (size l2 + size l3)
  end.
 
Definition lessP3
  (m1 m2 : list (Term A n) * (list (Term A n) * list (Term A n))) :=
  sizel3 m1 < sizel3 m2.
 
Lemma wf_lessP3 : well_founded lessP3.
red in |- *.
cut (forall (m : nat) a, sizel3 a < m -> Acc lessP3 a).
intros H' a.
apply H' with (m := S (sizel3 a)); auto.
intros m; elim m; clear m.
intros a H; inversion H.
intros p H' a H'0; apply Acc_intro.
intros y H'1; apply H'.
unfold lessP in H'1; apply lt_le_trans with (sizel3 a); auto with arith.
Qed.
Hint Resolve wf_lessP3.
Set Implicit Arguments.
Unset Strict Implicit.
 
Definition eqPf :
  forall pq, {eqP (fst pq) (snd pq)} + {~ eqP (fst pq) (snd pq)}.
intros pq; pattern pq in |- *;
 apply well_founded_induction with (R := lessP) (1 := wf_lessP); 
 clear pq.
intros pq; case pq; simpl in |- *; clear pq.
intros p; case p; clear p.
intros q; case q; clear q.
intros H'; left; constructor.
intros b q H'; right; red in |- *; intros H'0; inversion H'0.
intros a p q; case q; clear q.
intros H'; right; red in |- *; intros H'0; inversion H'0.
intros b q Rec; case (eqTerm_dec _ _ eqA_dec n a b); simpl in Rec;
 intros eqTerm0.
case (Rec (p, q)); unfold lessP in |- *; simpl in |- *; auto with arith.
intros H'; left; auto.
change (eqP (pX a p) (pX b q)) in |- *; auto.
intros H'; right; red in |- *; intros H'0.
apply H'.
apply eqp_inv3r with (a := a) (b := b); auto.
right; red in |- *; intros H'.
apply eqTerm0.
apply eqp_eqTerm with (p := p) (q := q); auto.
Defined.
 
Definition seqP : poly A0 eqA ltM -> poly A0 eqA ltM -> Prop.
intros sp1 sp2; case sp1; case sp2.
intros p1 H'1 p2 H'2; exact (eqP p1 p2).
Defined.
Set Strict Implicit.
Unset Implicit Arguments.
 
Theorem seqp_dec : forall p q : poly A0 eqA ltM, {seqP p q} + {~ seqP p q}.
intros p q; case p; case q; simpl in |- *.
intros x H' x0 H'0.
apply (eqPf (x, x0)).
Qed.
 
Theorem seqp_refl : reflexive (poly A0 eqA ltM) seqP.
red in |- *.
intros p; case p; simpl in |- *.
intros x H'.
apply eqp_refl.
Qed.
 
Theorem seqp_sym : symmetric (poly A0 eqA ltM) seqP.
red in |- *.
intros p q; case p; case q; simpl in |- *.
intros x H' x0 H'0 H'1.
apply eqp_sym; auto.
Qed.
 
Theorem seqp_trans : transitive (poly A0 eqA ltM) seqP.
red in |- *.
intros p q r; case p; case q; case r; simpl in |- *.
intros x H' x0 H'0 x1 H'1 H'2 H'3.
apply eqp_trans with (y := x0); auto.
Qed.
End Peq.