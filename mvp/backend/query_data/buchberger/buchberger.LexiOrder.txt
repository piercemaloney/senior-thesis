

Require Import Eqdep.

Section lexi_order.

Require Import Monomials.
(* Monomials:
Section Monomials.
Require Import Arith.
Require Import Compare.
Require Import Compare_dec.
Require Import Peano_dec.

Inductive mon : nat -> Set :=
  | n_0 : mon 0
  | c_n : forall d : nat, nat -> mon d -> mon (S d).

Definition pmon1 : forall d : nat, mon d -> nat.

Definition pmon2 : forall d : nat, mon d -> mon (pred d).

Definition recomp : forall d : nat, d <> 0 -> mon d -> mon d.

Lemma recomp_ok : forall (d : nat) (h : d <> 0) (m : mon d), recomp d h m = m.

Lemma proj_ok :
 forall (d : nat) (m : mon (S d)), c_n d (pmon1 (S d) m) (pmon2 (S d) m) = m.

Definition gen_mon : forall d : nat, nat -> mon d.

Definition mult_mon : forall d : nat, mon d -> mon d -> mon d.

Theorem mult_mon_com :
 forall (d : nat) (a b : mon d), mult_mon d a b = mult_mon d b a.

Theorem mult_mon_assoc :
 forall (d : nat) (a b c : mon d),
 mult_mon d a (mult_mon d b c) = mult_mon d (mult_mon d a b) c.

Definition zero_mon : forall d : nat, mon d.

Theorem mult_mon_zero_r :
 forall (d : nat) (a : mon d), mult_mon d a (zero_mon d) = a.

Theorem mult_mon_zero_l :
 forall (d : nat) (a : mon d), mult_mon d (zero_mon d) a = a.

Inductive mdiv : forall d : nat, mon d -> mon d -> Prop :=
  | mdiv_nil : mdiv 0 n_0 n_0
  | mdiv_cons :
      forall (d : nat) (v v' : mon d) (n n' : nat),
      n <= n' -> mdiv d v v' -> mdiv (S d) (c_n d n v) (c_n d n' v').
Hint Resolve mdiv_nil mdiv_cons.

Lemma mdiv_proj :
 forall (d : nat) (m m' : mon (S d)),
 pmon1 (S d) m <= pmon1 (S d) m' ->
 mdiv d (pmon2 (S d) m) (pmon2 (S d) m') -> mdiv (S d) m m'.
Require Import Relation_Definitions.
Require Import Eqdep.

Lemma mdiv_trans : forall d : nat, transitive (mon d) (mdiv d).

Definition div_mon : forall d : nat, mon d -> mon d -> mon d.

Theorem mdiv_div :
 forall (d : nat) (a b : mon d),
 mdiv d b a -> mult_mon d (div_mon d a b) b = a.

Definition div_mon_clean : forall d : nat, mon d -> mon d -> mon d * bool.

Definition is_nil : forall d : nat, mon d -> mon d.

Theorem is_nil_id : forall (d : nat) (a : mon d), a = is_nil d a.

Theorem mon_0 : forall a : mon 0, a = n_0.
Hint Resolve mon_0.

Theorem eqmon_dec : forall (d : nat) (x y : mon d), {x = y} + {x <> y}.

Theorem mult_div_com :
 forall (d : nat) (a b : mon d), div_mon d (mult_mon d a b) b = a.

Theorem mult_div_id :
 forall (d : nat) (a : mon d), div_mon d a a = zero_mon d.

Let gb : forall d : nat, mon d * bool -> bool.

Let gm : forall d : nat, mon d * bool -> mon d.

Theorem minus_lt_0 : forall m n : nat, n < m -> n - m = 0.

Theorem div_clean_dec2 :
 forall (d : nat) (a b : mon d),
 gb d (div_mon_clean d a b) = false -> mult_mon d (div_mon d a b) b <> a.

Theorem div_clean_dec1 :
 forall (d : nat) (a b : mon d),
 gb d (div_mon_clean d a b) = true ->
 gm d (div_mon_clean d a b) = div_mon d a b /\
 mult_mon d (div_mon d a b) b = a.
Require Import Max.

Definition ppcm_mon : forall d : nat, mon d -> mon d -> mon d.

Theorem ppcm_com :
 forall (d : nat) (a b : mon d), ppcm_mon d a b = ppcm_mon d b a.

Theorem ppcm_prop_l :
 forall (d : nat) (a b : mon d),
 ppcm_mon d a b = mult_mon d (div_mon d (ppcm_mon d a b) a) a.

Theorem ppcm_prop_r :
 forall (d : nat) (a b : mon d),
 ppcm_mon d a b = mult_mon d (div_mon d (ppcm_mon d a b) b) b.

Theorem plus_minus_le : forall a b : nat, a - b + b = a -> b <= a.

Theorem ppcm_mom_is_ppcm :
 forall (d : nat) (a b c : mon d),
 c = mult_mon d (div_mon d c a) a ->
 c = mult_mon d (div_mon d c b) b ->
 c = mult_mon d (div_mon d c (ppcm_mon d a b)) (ppcm_mon d a b).
End Monomials. *)



Inductive orderc : forall n : nat, mon n -> mon n -> Prop :=

  | lo1 :

      forall (n a b : nat) (p : mon n),

      b < a -> orderc (S n) (c_n n a p) (c_n n b p)

  | lo2 :

      forall (n a b : nat) (p q : mon n),

      orderc n p q -> orderc (S n) (c_n n a p) (c_n n b q).

Hint Resolve lo1 lo2.

Require Import Arith.

Require Import Compare_dec.



Theorem orderc_dec :

 forall (n : nat) (a b : mon n), {orderc n a b} + {orderc n b a} + {a = b}.

intros n a; elim a; auto.

intro b.

rewrite <- (mon_0 b); auto.

intros d n0 m H' b; try assumption.

rewrite <- (proj_ok d b).

case (H' (pmon2 (S d) b)).

intro H'0; case H'0.

intro H'1.

left; left; auto.

intro H'1; left; right; auto.

intro H'0.

elim (lt_eq_lt_dec n0 (pmon1 (S d) b)); [ intro H'1; elim H'1 | idtac ];

 intro H'2; auto.

left; right; auto.

rewrite H'0; auto.

right; rewrite H'0; rewrite H'2; auto.

left; left; rewrite H'0; auto.

Qed.



Definition degc : forall n : nat, mon n -> nat.

intros n H'; elim H'.

exact 0.

intros d n1 M n2; exact (n1 + n2).

Defined.



Inductive total_orderc : forall n : nat, mon n -> mon n -> Prop :=

  | total_orderc0 :

      forall (n : nat) (p q : mon n),

      degc n p < degc n q -> total_orderc n p q

  | total_orderc1 :

      forall (n : nat) (p q : mon n),

      degc n p = degc n q -> orderc n p q -> total_orderc n p q.

Hint Resolve total_orderc0 total_orderc1.

Require Import LetP.
(* LetP:
Definition LetP : forall (A B : Set) (h : A), (forall u : A, u = h -> B) -> B. *)



Theorem total_orderc_dec :

 forall (n : nat) (a b : mon n),

 {total_orderc n a b} + {total_orderc n b a} + {a = b}.

intros n a b.

apply LetP with (A := nat) (h := degc n a).

intros u H'; apply LetP with (A := nat) (h := degc n b).

intros u0 H'0.

case (le_lt_dec u u0); auto.

intro H'1; case (le_lt_eq_dec u u0); auto.

rewrite H'0; rewrite H'; auto.

rewrite H'0; rewrite H'; intro H'2; case (orderc_dec n a b); auto.

intro H'3; case H'3; auto.

rewrite H'0; rewrite H'; auto.

Qed.

End lexi_order.
