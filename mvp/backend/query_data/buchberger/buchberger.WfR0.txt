

Require Import List.

Require Import ListProps.
(* ListProps:
Require Import List.

Lemma map_in :
 forall (A B : Set) (f : A -> B) (b : B) (xs : list A),
 In b (map f xs) -> ex (fun a : A => b = f a /\ In a xs).

Lemma map_app :
 forall (A B : Set) (f : A -> B) (l1 l2 : list A),
 map f (l1 ++ l2) = map f l1 ++ map f l2.

Lemma map_rev :
 forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).

Lemma rev_in : forall (A : Set) (a : A) (l : list A), In a (rev l) -> In a l.

Lemma in_rev : forall (A : Set) (a : A) (l : list A), In a l -> In a (rev l). *)

Require Import Bar.
(* Bar:
Require Import List.

Definition Pred (A : Set) := A -> Prop.

Definition Rel (A : Set) := A -> A -> Prop.

Inductive ExistsL (A : Set) (P : Pred A) : list A -> Set :=
  | FoundE : forall (a : A) (l : list A), P a -> ExistsL A P (a :: l)
  | SearchE :
      forall (a : A) (l : list A), ExistsL A P l -> ExistsL A P (a :: l).
Hint Resolve FoundE SearchE.

Lemma monExistsL1 :
 forall (A : Set) (P : Pred A) (xs bs : list A),
 ExistsL A P bs -> ExistsL A P (xs ++ bs).
Hint Resolve monExistsL1.

Lemma monExistsL :
 forall (A : Set) (P : Pred A) (xs bs cs : list A),
 ExistsL A P (xs ++ bs) -> ExistsL A P (xs ++ cs ++ bs).
Hint Resolve monExistsL.

Inductive GoodR (A : Set) (R : Rel A) : list A -> Set :=
  | FoundG :
      forall (a : A) (l : list A),
      ExistsL A (fun x : A => R x a) l -> GoodR A R (a :: l)
  | SearchG : forall (a : A) (l : list A), GoodR A R l -> GoodR A R (a :: l).
Hint Resolve FoundG SearchG.

Lemma monGoodR1 :
 forall (A : Set) (R : Rel A) (xs bs : list A),
 GoodR A R bs -> GoodR A R (xs ++ bs).
Hint Resolve monGoodR1.

Lemma monGoodR :
 forall (A : Set) (R : Rel A) (xs bs cs : list A),
 GoodR A R (xs ++ bs) -> GoodR A R (xs ++ cs ++ bs).
Hint Resolve monGoodR.

Lemma subPredExistsL :
 forall (A B : Set) (P : Pred A) (S : Pred B) (f : A -> B),
 (forall a : A, P a -> S (f a)) ->
 forall l : list A, ExistsL A P l -> ExistsL B S (map f l).

Lemma subRelGoodR :
 forall (A B : Set) (R : Rel A) (S : Rel B) (f : A -> B),
 (forall a b : A, R a b -> S (f a) (f b)) ->
 forall l : list A, GoodR A R l -> GoodR B S (map f l).

Inductive Bar (A : Set) (P : list A -> Set) : list A -> Set :=
  | Base : forall l : list A, P l -> Bar A P l
  | Ind : forall l : list A, (forall a : A, Bar A P (a :: l)) -> Bar A P l.
Hint Resolve Base Ind.

Definition GRBar (A : Set) (R : Rel A) := Bar A (GoodR A R).

Definition WR (A : Set) (R : Rel A) := GRBar A R nil.
Hint Unfold GRBar WR.

Lemma subRelGRBar :
 forall (A B : Set) (R : Rel A) (S : Rel B) (f : A -> B),
 (forall a b : A, R a b -> S (f a) (f b)) ->
 (forall b : B, {a : A | b = f a}) ->
 forall l : list A, GRBar A R l -> GRBar B S (map f l).

Lemma consGRBar :
 forall (A : Set) (R : Rel A) (l : list A),
 GRBar A R l -> forall a : A, GRBar A R (a :: l).
Hint Resolve consGRBar.

Lemma nilGRBar :
 forall (A : Set) (R : Rel A),
 GRBar A R nil -> forall l : list A, GRBar A R l.

Lemma monGRBarAux :
 forall (A : Set) (R : Rel A) (l : list A),
 GRBar A R l ->
 forall xs bs cs : list A, l = xs ++ cs -> GRBar A R (xs ++ bs ++ cs).

Lemma monGRBar :
 forall (A : Set) (R : Rel A) (xs bs cs : list A),
 GRBar A R (xs ++ cs) -> GRBar A R (xs ++ bs ++ cs).
Hint Resolve monGRBar.
Section lems.
Variable trm : Set.
Variable tdiv : trm -> trm -> Prop.

Definition Bad (M : list trm) := GoodR trm tdiv M -> False.

Lemma tdivExists_trmHd_lem :
 forall (F : list trm) (f : trm),
 (forall g : trm, In g F -> ~ tdiv g f) ->
 ExistsL trm (fun g : trm => tdiv g f) F -> False.

Lemma tdivGoodP :
 forall (F : list trm) (f : trm),
 Bad F -> (forall g : trm, In g F -> ~ tdiv g f) -> Bad (f :: F).
End lems. *)

Require Import Dickson.
(* Dickson:
Require Import List.
Require Import Bar.
Require Import OpenIndGoodRel.
Require Import Lt.
Require Import Wf_nat.

Definition DecRel (A : Set) (R : Rel A) :=
  forall x y : A, {R x y} + {~ R x y}.

Theorem nat_double_ind_set :
 forall R : nat -> nat -> Set,
 (forall n : nat, R 0 n) ->
 (forall n : nat, R (S n) 0) ->
 (forall n m : nat, R n m -> R (S n) (S m)) -> forall n m : nat, R n m.

Lemma dec_lt : DecRel nat lt.

Definition NegRel (A : Set) (R : Rel A) (x y : A) := ~ R x y.

Definition ProdRel (A B : Set) (R : Rel A) (S : Rel B) 
  (x y : A * B) := R (fst x) (fst y) /\ S (snd x) (snd y).
Section Dickson.
Variable A B : Set.
Variable lt : Rel A.
Variable R : Rel B.
Variable wfgt : well_founded lt.
Variable declt : DecRel A lt.
Variable wR : WR B R.

Definition leq (a b : A) := ~ lt b a.

Definition GBarlR := GRBar (A * B) (ProdRel A B leq R).

Definition sndL := map (fun p : A * B => snd p).

Definition MinD :=
  Min (A * B) (fun p q : A * B => lt (fst p) (fst q)) (ProdRel A B leq R).

Definition prod_lt (a b : A * B) := lt (fst a) (fst b).
Require Import Inverse_Image.

Lemma WFlem1 : well_founded prod_lt.

Lemma lem0 :
 forall (l : list (A * B)) (a : A * B),
 ExistsL B (fun x : B => R x (snd a)) (sndL l) -> MinD l -> GBarlR (a :: l).

Lemma lem1aux :
 forall l : list B,
 GoodR B R l -> forall us : list (A * B), l = sndL us -> MinD us -> GBarlR us.

Lemma lem1 :
 forall us : list (A * B), GoodR B R (sndL us) -> MinD us -> GBarlR us.

Lemma keylem :
 forall bs : list B,
 GRBar B R bs ->
 forall us : list (A * B), bs = sndL us -> MinD us -> GBarlR us.

Lemma keylem_cor : WR (A * B) (ProdRel A B leq R).
End Dickson.

Require Import Monomials.

Lemma leq2le : forall a b : nat, leq nat lt a b -> a <= b.

Definition jj : forall d : nat, mon d :=
  (fix jj (d : nat) : mon d :=
     match d as n return (mon n) with
     | O => n_0
     | S n => c_n n 0 (jj n)
     end).

Theorem jjProp1 : forall (d : nat) (m : mon d), d = 0 -> m = jj d.

Theorem jjProp2 : jj 0 = n_0.

Theorem monO_n0 : forall m : mon 0, m = n_0.

Lemma zRV_WR : WR (mon 0) (mdiv 0).

Definition monLift (n : nat) (p : nat * mon n) :=
  match p with
  | (x, m) => c_n n x m
  end.

Lemma monLift_lem :
 forall (n0 : nat) (b : mon (S n0)) (x : nat) (m : mon n0),
 b = c_n n0 x m -> {a : nat * mon n0 | b = monLift n0 a}.

Lemma dicksonL : forall n : nat, WR (mon n) (mdiv n). *)

Require Import Monomials.
(* Monomials:
Section Monomials.
Require Import Arith.
Require Import Compare.
Require Import Compare_dec.
Require Import Peano_dec.

Inductive mon : nat -> Set :=
  | n_0 : mon 0
  | c_n : forall d : nat, nat -> mon d -> mon (S d).

Definition pmon1 : forall d : nat, mon d -> nat.

Definition pmon2 : forall d : nat, mon d -> mon (pred d).

Definition recomp : forall d : nat, d <> 0 -> mon d -> mon d.

Lemma recomp_ok : forall (d : nat) (h : d <> 0) (m : mon d), recomp d h m = m.

Lemma proj_ok :
 forall (d : nat) (m : mon (S d)), c_n d (pmon1 (S d) m) (pmon2 (S d) m) = m.

Definition gen_mon : forall d : nat, nat -> mon d.

Definition mult_mon : forall d : nat, mon d -> mon d -> mon d.

Theorem mult_mon_com :
 forall (d : nat) (a b : mon d), mult_mon d a b = mult_mon d b a.

Theorem mult_mon_assoc :
 forall (d : nat) (a b c : mon d),
 mult_mon d a (mult_mon d b c) = mult_mon d (mult_mon d a b) c.

Definition zero_mon : forall d : nat, mon d.

Theorem mult_mon_zero_r :
 forall (d : nat) (a : mon d), mult_mon d a (zero_mon d) = a.

Theorem mult_mon_zero_l :
 forall (d : nat) (a : mon d), mult_mon d (zero_mon d) a = a.

Inductive mdiv : forall d : nat, mon d -> mon d -> Prop :=
  | mdiv_nil : mdiv 0 n_0 n_0
  | mdiv_cons :
      forall (d : nat) (v v' : mon d) (n n' : nat),
      n <= n' -> mdiv d v v' -> mdiv (S d) (c_n d n v) (c_n d n' v').
Hint Resolve mdiv_nil mdiv_cons.

Lemma mdiv_proj :
 forall (d : nat) (m m' : mon (S d)),
 pmon1 (S d) m <= pmon1 (S d) m' ->
 mdiv d (pmon2 (S d) m) (pmon2 (S d) m') -> mdiv (S d) m m'.
Require Import Relation_Definitions.
Require Import Eqdep.

Lemma mdiv_trans : forall d : nat, transitive (mon d) (mdiv d).

Definition div_mon : forall d : nat, mon d -> mon d -> mon d.

Theorem mdiv_div :
 forall (d : nat) (a b : mon d),
 mdiv d b a -> mult_mon d (div_mon d a b) b = a.

Definition div_mon_clean : forall d : nat, mon d -> mon d -> mon d * bool.

Definition is_nil : forall d : nat, mon d -> mon d.

Theorem is_nil_id : forall (d : nat) (a : mon d), a = is_nil d a.

Theorem mon_0 : forall a : mon 0, a = n_0.
Hint Resolve mon_0.

Theorem eqmon_dec : forall (d : nat) (x y : mon d), {x = y} + {x <> y}.

Theorem mult_div_com :
 forall (d : nat) (a b : mon d), div_mon d (mult_mon d a b) b = a.

Theorem mult_div_id :
 forall (d : nat) (a : mon d), div_mon d a a = zero_mon d.

Let gb : forall d : nat, mon d * bool -> bool.

Let gm : forall d : nat, mon d * bool -> mon d.

Theorem minus_lt_0 : forall m n : nat, n < m -> n - m = 0.

Theorem div_clean_dec2 :
 forall (d : nat) (a b : mon d),
 gb d (div_mon_clean d a b) = false -> mult_mon d (div_mon d a b) b <> a.

Theorem div_clean_dec1 :
 forall (d : nat) (a b : mon d),
 gb d (div_mon_clean d a b) = true ->
 gm d (div_mon_clean d a b) = div_mon d a b /\
 mult_mon d (div_mon d a b) b = a.
Require Import Max.

Definition ppcm_mon : forall d : nat, mon d -> mon d -> mon d.

Theorem ppcm_com :
 forall (d : nat) (a b : mon d), ppcm_mon d a b = ppcm_mon d b a.

Theorem ppcm_prop_l :
 forall (d : nat) (a b : mon d),
 ppcm_mon d a b = mult_mon d (div_mon d (ppcm_mon d a b) a) a.

Theorem ppcm_prop_r :
 forall (d : nat) (a b : mon d),
 ppcm_mon d a b = mult_mon d (div_mon d (ppcm_mon d a b) b) b.

Theorem plus_minus_le : forall a b : nat, a - b + b = a -> b <= a.

Theorem ppcm_mom_is_ppcm :
 forall (d : nat) (a b c : mon d),
 c = mult_mon d (div_mon d c a) a ->
 c = mult_mon d (div_mon d c b) b ->
 c = mult_mon d (div_mon d c (ppcm_mon d a b)) (ppcm_mon d a b).
End Monomials. *)

Require Export BuchAux.

Section thRO.

Load "hCoefStructure".

Load "hOrderStructure".

Load "hBuchAux".

 

Definition get_mon : poly A0 eqA ltM -> mon n.

intros sp; case sp.

intros x H'; case x.

exact (M1 n).

intros a H'1; exact (T2M a).

Defined.

 

Theorem get_is_correct :

 forall (a b : poly A0 eqA ltM) (P : list (poly A0 eqA ltM)),

 ~

 zerop A A0 eqA n ltM

   (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a

      P) ->

 In b P ->

 ~ zerop A A0 eqA n ltM b ->

 ~

 mdiv n (get_mon b)

   (get_mon

      (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec

         os a P)).

intros a b P H' H'0 H'1.

cut

 (irreducible A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec P

    (s2p A A0 eqA n ltM

       (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec

          os a P))).

2: try exact (nf_irreducible a P); auto.

generalize H';

 case

  (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a

     P); simpl in |- *; auto.

intros x; case x; simpl in |- *.

intros H'2 H'3; elim H'3; auto.

intros a0 l H'2 H'3 H'4; red in |- *; intros H'5; red in H'4.

red in H'4.

generalize H'0 H'1 H'5; case b.

intros x0; case x0; simpl in |- *.

intros o H'6 H'7; elim H'7; auto.

intros a1 l0 o H'6 H'7 H'8.

cut (~ zeroP (A:=A) A0 eqA (n:=n) a1); [ intros nZa1 | idtac ].

apply 

 H'4

   with

     (q := spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec

             a0 a1 nZa1 l l0); auto.

change

  (reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec P

     (pX a0 l)

     (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a0 a1

        nZa1 l l0)) in |- *.

apply reducetop_sp with (1 := cs) (b := a1) (nZb := nZa1) (q := l0); auto.

change

  (inPolySet A A0 eqA n ltM

     (s2p A A0 eqA n ltM (mks A A0 eqA n ltM (pX a1 l0) o)) P) 

 in |- *.

apply in_inPolySet; auto.

simpl in |- *; auto.

red in |- *; intros H'9; inversion H'9.

apply divTerm_def with (nZb := nZa1); auto.

apply canonical_nzeroP with (ltM := ltM) (p := l); auto.

apply divTerm_on_plusM_minusM with (1 := cs); auto.

apply canonical_nzeroP with (ltM := ltM) (p := l); auto.

simpl in |- *; auto.

apply sym_equal; auto.

apply mdiv_div; auto.

apply canonical_nzeroP with (ltM := ltM) (p := l0); auto.

apply nf_irreducible; auto.

Qed.

 

Definition get_monL : list (poly A0 eqA ltM) -> list (mon n) := map get_mon.

 

Inductive RO : list (poly A0 eqA ltM) -> list (poly A0 eqA ltM) -> Prop :=

    RO0 :

      forall (a : poly A0 eqA ltM) (P : list (poly A0 eqA ltM)),

      ~

      zerop A A0 eqA n ltM

        (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec

           os a P) ->

      RO

        (P ++

         nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec

           os a P :: nil) P.

 

Definition BadM (l : list (mon n)) := GoodR (mon n) (mdiv n) l -> False.

 

Lemma l1 :

 forall (cs : list (poly A0 eqA ltM)) (ms : list (mon n)),

 Bar (mon n) (GoodR (mon n) (mdiv n)) ms ->

 forall bs : list (poly A0 eqA ltM),

 ms = get_monL bs ->

 (forall f : poly A0 eqA ltM, In f bs -> ~ zerop A A0 eqA n ltM f) ->

 BadM ms -> Acc RO (cs ++ rev bs).

intros cs1 ms1 H; elim H; auto.

intros l H' bs H'0 H'1 H'2.

case H'2; auto.

intros l H' H'0 bs Heq Hnz H'1; auto.

apply Acc_intro; auto.

intros y H'2; inversion H'2; auto.

rewrite <- ass_app.

change

  (Acc RO

     (cs1 ++

      rev bs ++

      rev

        (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec

           os a (cs1 ++ rev bs) :: nil))) in |- *.

rewrite <- distr_rev; simpl in |- *.

change

  (Acc RO

     (cs1 ++

      rev

        (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec

           os a (cs1 ++ rev bs) :: bs))) in |- *.

apply

 H'0

  with

    (a := get_mon

            (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM

               ltM_dec os a (cs1 ++ rev bs))); unfold get_monL in |- *;

 try rewrite Heq; simpl in |- *; auto.

intros f H'3; elim H'3;

 [ intros H'4; rewrite <- H'4; clear H'3 | intros H'4; clear H'3 ]; 

 auto.

apply tdivGoodP with (trm := mon n) (tdiv := mdiv n); auto.

rewrite <- Heq; auto.

intros g.

intros H'3; cut (ex (fun b : poly A0 eqA ltM => g = get_mon b /\ In b bs)).

intros H'4; elim H'4; intros b E; elim E; intros H'5 H'6; rewrite H'5;

 clear E H'4; auto.

apply get_is_correct; auto.

apply in_or_app; apply or_intror; apply in_rev; auto.

apply map_in; auto.

Qed.

 

Theorem wf_incl : well_founded RO.

unfold well_founded in |- *; intros.

apply Acc_intro; intros.

inversion H.

apply

 l1

  with

    (bs := nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM

             ltM_dec os a0 a :: nil)

    (ms := get_monL

             (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM

                ltM_dec os a0 a :: nil)); auto.

change

  (GRBar (mon n) (mdiv n)

     (get_mon

        (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec

           os a0 a) :: nil)) in |- *.

apply nilGRBar; auto.

apply dicksonL with (n := n); auto.

simpl in |- *; intros f H3; case H3; intros.

rewrite <- H4; auto.

elim H4.

red in |- *; intros H4; inversion H4; inversion H5.

Qed.

 

Lemma RO_lem :

 forall (a : poly A0 eqA ltM) (P : list (poly A0 eqA ltM)),

 ~

 zerop A A0 eqA n ltM

   (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a

      P) ->

 RO

   (addEnd A A0 eqA n ltM

      (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec

         os a P) P) P.

intros a P H'; rewrite addEnd_app.

apply RO0; auto.

Qed.

End thRO.
