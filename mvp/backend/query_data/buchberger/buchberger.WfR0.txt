
Require Import List.
Require Import ListProps.
(* ListProps:
Require Import List.

Lemma map_in :
 forall (A B : Set) (f : A -> B) (b : B) (xs : list A),
 In b (map f xs) -> ex (fun a : A => b = f a /\ In a xs).

Lemma map_app :
 forall (A B : Set) (f : A -> B) (l1 l2 : list A),
 map f (l1 ++ l2) = map f l1 ++ map f l2.

Lemma map_rev :
 forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).

Lemma rev_in : forall (A : Set) (a : A) (l : list A), In a (rev l) -> In a l.

Lemma in_rev : forall (A : Set) (a : A) (l : list A), In a l -> In a (rev l). *)
Require Import Bar.
(* Bar:
Require Import List.

Definition Pred (A : Set) := A -> Prop.

Definition Rel (A : Set) := A -> A -> Prop.

Inductive ExistsL (A : Set) (P : Pred A) : list A -> Set :=
  | FoundE : forall (a : A) (l : list A), P a -> ExistsL A P (a :: l)
  | SearchE :
      forall (a : A) (l : list A), ExistsL A P l -> ExistsL A P (a :: l).
Hint Resolve FoundE SearchE.

Lemma monExistsL1 :
 forall (A : Set) (P : Pred A) (xs bs : list A),
 ExistsL A P bs -> ExistsL A P (xs ++ bs).
Hint Resolve monExistsL1.

Lemma monExistsL :
 forall (A : Set) (P : Pred A) (xs bs cs : list A),
 ExistsL A P (xs ++ bs) -> ExistsL A P (xs ++ cs ++ bs).
Hint Resolve monExistsL.

Inductive GoodR (A : Set) (R : Rel A) : list A -> Set :=
  | FoundG :
      forall (a : A) (l : list A),
      ExistsL A (fun x : A => R x a) l -> GoodR A R (a :: l)
  | SearchG : forall (a : A) (l : list A), GoodR A R l -> GoodR A R (a :: l).
Hint Resolve FoundG SearchG.

Lemma monGoodR1 :
 forall (A : Set) (R : Rel A) (xs bs : list A),
 GoodR A R bs -> GoodR A R (xs ++ bs).
Hint Resolve monGoodR1.

Lemma monGoodR :
 forall (A : Set) (R : Rel A) (xs bs cs : list A),
 GoodR A R (xs ++ bs) -> GoodR A R (xs ++ cs ++ bs).
Hint Resolve monGoodR.

Lemma subPredExistsL :
 forall (A B : Set) (P : Pred A) (S : Pred B) (f : A -> B),
 (forall a : A, P a -> S (f a)) ->
 forall l : list A, ExistsL A P l -> ExistsL B S (map f l).

Lemma subRelGoodR :
 forall (A B : Set) (R : Rel A) (S : Rel B) (f : A -> B),
 (forall a b : A, R a b -> S (f a) (f b)) ->
 forall l : list A, GoodR A R l -> GoodR B S (map f l).

Inductive Bar (A : Set) (P : list A -> Set) : list A -> Set :=
  | Base : forall l : list A, P l -> Bar A P l
  | Ind : forall l : list A, (forall a : A, Bar A P (a :: l)) -> Bar A P l.
Hint Resolve Base Ind.

Definition GRBar (A : Set) (R : Rel A) := Bar A (GoodR A R).

Definition WR (A : Set) (R : Rel A) := GRBar A R nil.
Hint Unfold GRBar WR.

Lemma subRelGRBar :
 forall (A B : Set) (R : Rel A) (S : Rel B) (f : A -> B),
 (forall a b : A, R a b -> S (f a) (f b)) ->
 (forall b : B, {a : A | b = f a}) ->
 forall l : list A, GRBar A R l -> GRBar B S (map f l).

Lemma consGRBar :
 forall (A : Set) (R : Rel A) (l : list A),
 GRBar A R l -> forall a : A, GRBar A R (a :: l).
Hint Resolve consGRBar.

Lemma nilGRBar :
 forall (A : Set) (R : Rel A),
 GRBar A R nil -> forall l : list A, GRBar A R l.

Lemma monGRBarAux :
 forall (A : Set) (R : Rel A) (l : list A),
 GRBar A R l ->
 forall xs bs cs : list A, l = xs ++ cs -> GRBar A R (xs ++ bs ++ cs).

Lemma monGRBar :
 forall (A : Set) (R : Rel A) (xs bs cs : list A),
 GRBar A R (xs ++ cs) -> GRBar A R (xs ++ bs ++ cs).
Hint Resolve monGRBar.
Section lems.
Variable trm : Set.
Variable tdiv : trm -> trm -> Prop.

Definition Bad (M : list trm) := GoodR trm tdiv M -> False.

Lemma tdivExists_trmHd_lem :
 forall (F : list trm) (f : trm),
 (forall g : trm, In g F -> ~ tdiv g f) ->
 ExistsL trm (fun g : trm => tdiv g f) F -> False.

Lemma tdivGoodP :
 forall (F : list trm) (f : trm),
 Bad F -> (forall g : trm, In g F -> ~ tdiv g f) -> Bad (f :: F).
End lems. *)
Require Import Dickson.
(* Dickson:
Require Import List.
Require Import Bar.
Require Import OpenIndGoodRel.
Require Import Lt.
Require Import Wf_nat.

Definition DecRel (A : Set) (R : Rel A) :=
  forall x y : A, {R x y} + {~ R x y}.

Theorem nat_double_ind_set :
 forall R : nat -> nat -> Set,
 (forall n : nat, R 0 n) ->
 (forall n : nat, R (S n) 0) ->
 (forall n m : nat, R n m -> R (S n) (S m)) -> forall n m : nat, R n m.

Lemma dec_lt : DecRel nat lt.

Definition NegRel (A : Set) (R : Rel A) (x y : A) := ~ R x y.

Definition ProdRel (A B : Set) (R : Rel A) (S : Rel B) 
  (x y : A * B) := R (fst x) (fst y) /\ S (snd x) (snd y).
Section Dickson.
Variable A B : Set.
Variable lt : Rel A.
Variable R : Rel B.
Variable wfgt : well_founded lt.
Variable declt : DecRel A lt.
Variable wR : WR B R.

Definition leq (a b : A) := ~ lt b a.

Definition GBarlR := GRBar (A * B) (ProdRel A B leq R).

Definition sndL := map (fun p : A * B => snd p).

Definition MinD :=
  Min (A * B) (fun p q : A * B => lt (fst p) (fst q)) (ProdRel A B leq R).

Definition prod_lt (a b : A * B) := lt (fst a) (fst b).
Require Import Inverse_Image.

Lemma WFlem1 : well_founded prod_lt.

Lemma lem0 :
 forall (l : list (A * B)) (a : A * B),
 ExistsL B (fun x : B => R x (snd a)) (sndL l) -> MinD l -> GBarlR (a :: l).

Lemma lem1aux :
 forall l : list B,
 GoodR B R l -> forall us : list (A * B), l = sndL us -> MinD us -> GBarlR us.

Lemma lem1 :
 forall us : list (A * B), GoodR B R (sndL us) -> MinD us -> GBarlR us.

Lemma keylem :
 forall bs : list B,
 GRBar B R bs ->
 forall us : list (A * B), bs = sndL us -> MinD us -> GBarlR us.

Lemma keylem_cor : WR (A * B) (ProdRel A B leq R).
End Dickson.

Require Import Monomials.

Lemma leq2le : forall a b : nat, leq nat lt a b -> a <= b.

Definition jj : forall d : nat, mon d :=
  (fix jj (d : nat) : mon d :=
     match d as n return (mon n) with
     | O => n_0
     | S n => c_n n 0 (jj n)
     end).

Theorem jjProp1 : forall (d : nat) (m : mon d), d = 0 -> m = jj d.

Theorem jjProp2 : jj 0 = n_0.

Theorem monO_n0 : forall m : mon 0, m = n_0.

Lemma zRV_WR : WR (mon 0) (mdiv 0).

Definition monLift (n : nat) (p : nat * mon n) :=
  match p with
  | (x, m) => c_n n x m
  end.

Lemma monLift_lem :
 forall (n0 : nat) (b : mon (S n0)) (x : nat) (m : mon n0),
 b = c_n n0 x m -> {a : nat * mon n0 | b = monLift n0 a}.

Lemma dicksonL : forall n : nat, WR (mon n) (mdiv n). *)
Require Import Monomials.
(* Monomials:
Section Monomials.
Require Import Arith.
Require Import Compare.
Require Import Compare_dec.
Require Import Peano_dec.

Inductive mon : nat -> Set :=
  | n_0 : mon 0
  | c_n : forall d : nat, nat -> mon d -> mon (S d).

Definition pmon1 : forall d : nat, mon d -> nat.

Definition pmon2 : forall d : nat, mon d -> mon (pred d).

Definition recomp : forall d : nat, d <> 0 -> mon d -> mon d.

Lemma recomp_ok : forall (d : nat) (h : d <> 0) (m : mon d), recomp d h m = m.

Lemma proj_ok :
 forall (d : nat) (m : mon (S d)), c_n d (pmon1 (S d) m) (pmon2 (S d) m) = m.

Definition gen_mon : forall d : nat, nat -> mon d.

Definition mult_mon : forall d : nat, mon d -> mon d -> mon d.

Theorem mult_mon_com :
 forall (d : nat) (a b : mon d), mult_mon d a b = mult_mon d b a.

Theorem mult_mon_assoc :
 forall (d : nat) (a b c : mon d),
 mult_mon d a (mult_mon d b c) = mult_mon d (mult_mon d a b) c.

Definition zero_mon : forall d : nat, mon d.

Theorem mult_mon_zero_r :
 forall (d : nat) (a : mon d), mult_mon d a (zero_mon d) = a.

Theorem mult_mon_zero_l :
 forall (d : nat) (a : mon d), mult_mon d (zero_mon d) a = a.

Inductive mdiv : forall d : nat, mon d -> mon d -> Prop :=
  | mdiv_nil : mdiv 0 n_0 n_0
  | mdiv_cons :
      forall (d : nat) (v v' : mon d) (n n' : nat),
      n <= n' -> mdiv d v v' -> mdiv (S d) (c_n d n v) (c_n d n' v').
Hint Resolve mdiv_nil mdiv_cons.

Lemma mdiv_proj :
 forall (d : nat) (m m' : mon (S d)),
 pmon1 (S d) m <= pmon1 (S d) m' ->
 mdiv d (pmon2 (S d) m) (pmon2 (S d) m') -> mdiv (S d) m m'.
Require Import Relation_Definitions.
Require Import Eqdep.

Lemma mdiv_trans : forall d : nat, transitive (mon d) (mdiv d).

Definition div_mon : forall d : nat, mon d -> mon d -> mon d.

Theorem mdiv_div :
 forall (d : nat) (a b : mon d),
 mdiv d b a -> mult_mon d (div_mon d a b) b = a.

Definition div_mon_clean : forall d : nat, mon d -> mon d -> mon d * bool.

Definition is_nil : forall d : nat, mon d -> mon d.

Theorem is_nil_id : forall (d : nat) (a : mon d), a = is_nil d a.

Theorem mon_0 : forall a : mon 0, a = n_0.
Hint Resolve mon_0.

Theorem eqmon_dec : forall (d : nat) (x y : mon d), {x = y} + {x <> y}.

Theorem mult_div_com :
 forall (d : nat) (a b : mon d), div_mon d (mult_mon d a b) b = a.

Theorem mult_div_id :
 forall (d : nat) (a : mon d), div_mon d a a = zero_mon d.

Let gb : forall d : nat, mon d * bool -> bool.

Let gm : forall d : nat, mon d * bool -> mon d.

Theorem minus_lt_0 : forall m n : nat, n < m -> n - m = 0.

Theorem div_clean_dec2 :
 forall (d : nat) (a b : mon d),
 gb d (div_mon_clean d a b) = false -> mult_mon d (div_mon d a b) b <> a.

Theorem div_clean_dec1 :
 forall (d : nat) (a b : mon d),
 gb d (div_mon_clean d a b) = true ->
 gm d (div_mon_clean d a b) = div_mon d a b /\
 mult_mon d (div_mon d a b) b = a.
Require Import Max.

Definition ppcm_mon : forall d : nat, mon d -> mon d -> mon d.

Theorem ppcm_com :
 forall (d : nat) (a b : mon d), ppcm_mon d a b = ppcm_mon d b a.

Theorem ppcm_prop_l :
 forall (d : nat) (a b : mon d),
 ppcm_mon d a b = mult_mon d (div_mon d (ppcm_mon d a b) a) a.

Theorem ppcm_prop_r :
 forall (d : nat) (a b : mon d),
 ppcm_mon d a b = mult_mon d (div_mon d (ppcm_mon d a b) b) b.

Theorem plus_minus_le : forall a b : nat, a - b + b = a -> b <= a.

Theorem ppcm_mom_is_ppcm :
 forall (d : nat) (a b c : mon d),
 c = mult_mon d (div_mon d c a) a ->
 c = mult_mon d (div_mon d c b) b ->
 c = mult_mon d (div_mon d c (ppcm_mon d a b)) (ppcm_mon d a b).
End Monomials. *)
Require Export BuchAux.
(* BuchAux:
Require Export Pcomb.
Require Export Pcrit.
Require Export Fred.
Require Import moreCoefStructure.
Section BuchAux.
Load "hCoefStructure".
Load "hOrderStructure".
Load "hComb".
 
Definition red (a : poly A0 eqA ltM) (P : list (poly A0 eqA ltM)) :=
  reducestar A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec P
    (s2p A A0 eqA n ltM a) (pO A n).
 
Definition addEnd :
  poly A0 eqA ltM -> list (poly A0 eqA ltM) -> list (poly A0 eqA ltM).
 
Theorem addEnd_cons :
 forall (a b : poly A0 eqA ltM) (aL : list (poly A0 eqA ltM)),
 In a (addEnd b aL) -> a = b \/ In a aL.
 
Theorem addEnd_id1 :
 forall (a : poly A0 eqA ltM) (aL : list (poly A0 eqA ltM)),
 In a (addEnd a aL).
 
Theorem addEnd_id2 :
 forall (a b : poly A0 eqA ltM) (aL : list (poly A0 eqA ltM)),
 In a aL -> In a (addEnd b aL).
 
Lemma addEnd_app :
 forall (a : poly A0 eqA ltM) (P : list (poly A0 eqA ltM)),
 addEnd a P = P ++ a :: nil.
 
Definition spolyp : poly A0 eqA ltM -> poly A0 eqA ltM -> poly A0 eqA ltM.
 
Theorem red_com :
 forall (a b : poly A0 eqA ltM) (aL : list (poly A0 eqA ltM)),
 red (spolyp a b) aL -> red (spolyp b a) aL.
 
Theorem rstar_rtopO :
 forall (Q : list (poly A0 eqA ltM)) (p : list (Term A n)),
 canonical A0 eqA ltM p ->
 reduceplus A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p
   (pO A n) ->
 reducestar A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p
   (pO A n).
 
Definition spO : poly A0 eqA ltM.
 
Definition sp1 : poly A0 eqA ltM.
 
Definition sgen : nat -> poly A0 eqA ltM.
 
Definition sscal : A -> poly A0 eqA ltM -> poly A0 eqA ltM.
 
Theorem red_cons :
 forall (a : poly A0 eqA ltM) (p : list (poly A0 eqA ltM)), In a p -> red a p.
 
Theorem red_id :
 forall (a : poly A0 eqA ltM) (aL : list (poly A0 eqA ltM)),
 red (spolyp a a) aL.
 
Theorem inP_reduce :
 forall P Q : list (poly A0 eqA ltM),
 (forall a : list (Term A n),
  inPolySet A A0 eqA n ltM a Q -> inPolySet A A0 eqA n ltM a P) ->
 forall a b : list (Term A n),
 reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q a b ->
 reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec P a b.
 
Theorem inP_reduceplus :
 forall P Q : list (poly A0 eqA ltM),
 (forall a : list (Term A n),
  inPolySet A A0 eqA n ltM a Q -> inPolySet A A0 eqA n ltM a P) ->
 forall a b : list (Term A n),
 reduceplus A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q a b ->
 reduceplus A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec P a b.
 
Theorem inP_reducestar :
 forall P Q : list (poly A0 eqA ltM),
 (forall a : list (Term A n),
  inPolySet A A0 eqA n ltM a Q -> inPolySet A A0 eqA n ltM a P) ->
 forall a b : list (Term A n),
 reducestar A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q a b ->
 reduceplus A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec P a b.
 
Theorem red_incl :
 forall (a : poly A0 eqA ltM) (p q : list (poly A0 eqA ltM)),
 incl p q -> red a p -> red a q.
 
Definition zerop : poly A0 eqA ltM -> Prop.
 
Theorem zerop_dec : forall a : poly A0 eqA ltM, {zerop a} + {~ zerop a}.
 
Definition divp : poly A0 eqA ltM -> poly A0 eqA ltM -> Prop.
 
Theorem divp_trans : transitive (poly A0 eqA ltM) divp.
 
Theorem divp_dec : forall a b : poly A0 eqA ltM, {divp a b} + {~ divp a b}.
 
Definition ppcp : poly A0 eqA ltM -> poly A0 eqA ltM -> poly A0 eqA ltM.
 
Theorem divp_ppc :
 forall a b c : poly A0 eqA ltM, divp (ppcp a b) c -> divp (ppcp b a) c.
 
Theorem zerop_ddivp_ppc :
 forall a b : poly A0 eqA ltM, ~ zerop a -> ~ zerop b -> divp (ppcp a b) b.
 
Theorem divp_nzeropl : forall a b : poly A0 eqA ltM, divp a b -> ~ zerop a.
 
Theorem divp_nzeropr : forall a b : poly A0 eqA ltM, divp a b -> ~ zerop b.
Hint Resolve pO_irreducible.
 
Theorem reducetopO_pO :
 forall Q : list (poly A0 eqA ltM),
 reducestar A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q
   (pO A n) (pO A n).
Hint Resolve reducetopO_pO.
 
Theorem zerop_red_spoly_l :
 forall a b : poly A0 eqA ltM,
 zerop a -> forall Q : list (poly A0 eqA ltM), red (spolyp a b) Q.
 
Theorem zerop_red_spoly_r :
 forall a b : poly A0 eqA ltM,
 zerop b -> forall Q : list (poly A0 eqA ltM), red (spolyp a b) Q.
 
Theorem divP_ppc :
 forall a b c : poly A0 eqA ltM, divp a b -> divp a c -> divp a (ppcp b c).
 
Definition Cb : poly A0 eqA ltM -> list (poly A0 eqA ltM) -> Prop.
 
Theorem Cb_id :
 forall (a : poly A0 eqA ltM) (Q : list (poly A0 eqA ltM)), In a Q -> Cb a Q.
 
Theorem inPolySet_addEnd :
 forall (a : list (Term A n)) (p : poly A0 eqA ltM)
   (l : list (poly A0 eqA ltM)),
 inPolySet A A0 eqA n ltM a (addEnd p l) ->
 a = s2p A A0 eqA n ltM p \/ inPolySet A A0 eqA n ltM a l.
 
Remark CombLinear_trans1 :
 forall (a : list (Term A n)) (R : list (poly A0 eqA ltM)),
 CombLinear A A0 eqA plusA multA eqA_dec n ltM ltM_dec R a ->
 forall (b : poly A0 eqA ltM) (Q : list (poly A0 eqA ltM)),
 R = addEnd b Q ->
 CombLinear A A0 eqA plusA multA eqA_dec n ltM ltM_dec Q
   (s2p A A0 eqA n ltM b) ->
 CombLinear A A0 eqA plusA multA eqA_dec n ltM ltM_dec Q a.
 
Theorem Cb_trans :
 forall (a b : poly A0 eqA ltM) (Q : list (poly A0 eqA ltM)),
 Cb a (addEnd b Q) -> Cb b Q -> Cb a Q.
 
Theorem Cb_incl :
 forall (a : poly A0 eqA ltM) (P Q : list (poly A0 eqA ltM)),
 (forall a : poly A0 eqA ltM, In a P -> In a Q) -> Cb a P -> Cb a Q.
 
Theorem Cb_in1 :
 forall (a b : poly A0 eqA ltM) (Q : list (poly A0 eqA ltM)),
 Cb a Q -> Cb a (b :: Q).
 
Theorem Cb_in :
 forall (a b : poly A0 eqA ltM) (Q : list (poly A0 eqA ltM)),
 Cb a Q -> Cb a (addEnd b Q).
 
Theorem Cb_sp :
 forall (a b : poly A0 eqA ltM) (Q : list (poly A0 eqA ltM)),
 Cb a Q -> Cb b Q -> Cb (spolyp a b) Q.
 
Definition unit : poly A0 eqA ltM -> Term A n.
 
Theorem unit_T1 : forall p : poly A0 eqA ltM, eqT (unit p) (T1 A1 n).
 
Theorem divA_nZ :
 forall a b : A,
 ~ eqA b A0 -> forall nZa : ~ eqA a A0, ~ eqA (divA b a nZa) A0.
Hint Resolve divA_nZ.
 
Theorem unit_nZ :
 forall p : poly A0 eqA ltM, ~ zeroP (A:=A) A0 eqA (n:=n) (unit p).
 
Definition nf : poly A0 eqA ltM -> list (poly A0 eqA ltM) -> poly A0 eqA ltM.
intros p L.
case
 (Reducef A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec
    os L p).
intros x H'.
apply LetP with (A := poly A0 eqA ltM) (h := x).
 
Theorem nf_irreducible :
 forall (p : poly A0 eqA ltM) (aP : list (poly A0 eqA ltM)),
 irreducible A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec aP
   (s2p A A0 eqA n ltM (nf p aP)).
 
Theorem nf_red :
 forall (a : poly A0 eqA ltM) (aP aQ : list (poly A0 eqA ltM)),
 incl aP aQ -> red (nf a aP) aQ -> red a aQ.
 
Theorem red_zerop :
 forall (a : poly A0 eqA ltM) (P : list (poly A0 eqA ltM)),
 red (nf a P) P -> zerop (nf a P).
 
Theorem zerop_red :
 forall (a : poly A0 eqA ltM) (aP : list (poly A0 eqA ltM)),
 zerop (nf a aP) -> red a aP.
 
Theorem canonical_s2p :
 forall x : poly A0 eqA ltM, canonical A0 eqA ltM (s2p A A0 eqA n ltM x).
Hint Resolve canonical_s2p.
 
Theorem nf_Cb :
 forall (a : poly A0 eqA ltM) (aP : list (poly A0 eqA ltM)),
 Cb a aP -> Cb (nf a aP) aP.
 
Definition foreigner : poly A0 eqA ltM -> poly A0 eqA ltM -> Prop.
 
Definition foreigner_dec :
  forall a b : poly A0 eqA ltM, {foreigner a b} + {~ foreigner a b}.
 
Theorem foreigner_red :
 forall (a b : poly A0 eqA ltM) (P : list (poly A0 eqA ltM)),
 foreigner a b -> In a P -> In b P -> red (spolyp a b) P.
intros a b; case a; case b.
intros x; case x.
simpl in |- *; auto.
unfold red in |- *; simpl in |- *; auto.
intros a0 l c x0; case x0.
unfold red in |- *; simpl in |- *; auto.
unfold red in |- *; simpl in |- *; auto.
intros a1 l0 c0 P H' H'0 H'1.
unfold LetP in |- *; simpl in |- *; auto.
End BuchAux. *)
Section thRO.
Load "hCoefStructure".
Load "hOrderStructure".
Load "hBuchAux".
 
Definition get_mon : poly A0 eqA ltM -> mon n.
intros sp; case sp.
intros x H'; case x.
exact (M1 n).
intros a H'1; exact (T2M a).
Defined.
 
Theorem get_is_correct :
 forall (a b : poly A0 eqA ltM) (P : list (poly A0 eqA ltM)),
 ~
 zerop A A0 eqA n ltM
   (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a
      P) ->
 In b P ->
 ~ zerop A A0 eqA n ltM b ->
 ~
 mdiv n (get_mon b)
   (get_mon
      (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec
         os a P)).
intros a b P H' H'0 H'1.
cut
 (irreducible A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec P
    (s2p A A0 eqA n ltM
       (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec
          os a P))).
2: try exact (nf_irreducible a P); auto.
generalize H';
 case
  (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a
     P); simpl in |- *; auto.
intros x; case x; simpl in |- *.
intros H'2 H'3; elim H'3; auto.
intros a0 l H'2 H'3 H'4; red in |- *; intros H'5; red in H'4.
red in H'4.
generalize H'0 H'1 H'5; case b.
intros x0; case x0; simpl in |- *.
intros o H'6 H'7; elim H'7; auto.
intros a1 l0 o H'6 H'7 H'8.
cut (~ zeroP (A:=A) A0 eqA (n:=n) a1); [ intros nZa1 | idtac ].
apply 
 H'4
   with
     (q := spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec
             a0 a1 nZa1 l l0); auto.
change
  (reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec P
     (pX a0 l)
     (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a0 a1
        nZa1 l l0)) in |- *.
apply reducetop_sp with (1 := cs) (b := a1) (nZb := nZa1) (q := l0); auto.
change
  (inPolySet A A0 eqA n ltM
     (s2p A A0 eqA n ltM (mks A A0 eqA n ltM (pX a1 l0) o)) P) 
 in |- *.
apply in_inPolySet; auto.
simpl in |- *; auto.
red in |- *; intros H'9; inversion H'9.
apply divTerm_def with (nZb := nZa1); auto.
apply canonical_nzeroP with (ltM := ltM) (p := l); auto.
apply divTerm_on_plusM_minusM with (1 := cs); auto.
apply canonical_nzeroP with (ltM := ltM) (p := l); auto.
simpl in |- *; auto.
apply sym_equal; auto.
apply mdiv_div; auto.
apply canonical_nzeroP with (ltM := ltM) (p := l0); auto.
apply nf_irreducible; auto.
Qed.
 
Definition get_monL : list (poly A0 eqA ltM) -> list (mon n) := map get_mon.
 
Inductive RO : list (poly A0 eqA ltM) -> list (poly A0 eqA ltM) -> Prop :=
    RO0 :
      forall (a : poly A0 eqA ltM) (P : list (poly A0 eqA ltM)),
      ~
      zerop A A0 eqA n ltM
        (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec
           os a P) ->
      RO
        (P ++
         nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec
           os a P :: nil) P.
 
Definition BadM (l : list (mon n)) := GoodR (mon n) (mdiv n) l -> False.
 
Lemma l1 :
 forall (cs : list (poly A0 eqA ltM)) (ms : list (mon n)),
 Bar (mon n) (GoodR (mon n) (mdiv n)) ms ->
 forall bs : list (poly A0 eqA ltM),
 ms = get_monL bs ->
 (forall f : poly A0 eqA ltM, In f bs -> ~ zerop A A0 eqA n ltM f) ->
 BadM ms -> Acc RO (cs ++ rev bs).
intros cs1 ms1 H; elim H; auto.
intros l H' bs H'0 H'1 H'2.
case H'2; auto.
intros l H' H'0 bs Heq Hnz H'1; auto.
apply Acc_intro; auto.
intros y H'2; inversion H'2; auto.
rewrite <- ass_app.
change
  (Acc RO
     (cs1 ++
      rev bs ++
      rev
        (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec
           os a (cs1 ++ rev bs) :: nil))) in |- *.
rewrite <- distr_rev; simpl in |- *.
change
  (Acc RO
     (cs1 ++
      rev
        (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec
           os a (cs1 ++ rev bs) :: bs))) in |- *.
apply
 H'0
  with
    (a := get_mon
            (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM
               ltM_dec os a (cs1 ++ rev bs))); unfold get_monL in |- *;
 try rewrite Heq; simpl in |- *; auto.
intros f H'3; elim H'3;
 [ intros H'4; rewrite <- H'4; clear H'3 | intros H'4; clear H'3 ]; 
 auto.
apply tdivGoodP with (trm := mon n) (tdiv := mdiv n); auto.
rewrite <- Heq; auto.
intros g.
intros H'3; cut (ex (fun b : poly A0 eqA ltM => g = get_mon b /\ In b bs)).
intros H'4; elim H'4; intros b E; elim E; intros H'5 H'6; rewrite H'5;
 clear E H'4; auto.
apply get_is_correct; auto.
apply in_or_app; apply or_intror; apply in_rev; auto.
apply map_in; auto.
Qed.
 
Theorem wf_incl : well_founded RO.
unfold well_founded in |- *; intros.
apply Acc_intro; intros.
inversion H.
apply
 l1
  with
    (bs := nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM
             ltM_dec os a0 a :: nil)
    (ms := get_monL
             (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM
                ltM_dec os a0 a :: nil)); auto.
change
  (GRBar (mon n) (mdiv n)
     (get_mon
        (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec
           os a0 a) :: nil)) in |- *.
apply nilGRBar; auto.
apply dicksonL with (n := n); auto.
simpl in |- *; intros f H3; case H3; intros.
rewrite <- H4; auto.
elim H4.
red in |- *; intros H4; inversion H4; inversion H5.
Qed.
 
Lemma RO_lem :
 forall (a : poly A0 eqA ltM) (P : list (poly A0 eqA ltM)),
 ~
 zerop A A0 eqA n ltM
   (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a
      P) ->
 RO
   (addEnd A A0 eqA n ltM
      (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec
         os a P) P) P.
intros a P H'; rewrite addEnd_app.
apply RO0; auto.
Qed.
End thRO.