Require Import InfSeqExt.infseq.
(* InfSeqExt.infseq:
Ltac genclear H := generalize H; clear H.

Ltac clearall :=
   repeat
        match goal with [H : _ |- _ ] => clear H end
     || match goal with [H : _ |- _ ] => genclear H end. 

Section sec_infseq.

Variable T: Type. 

CoInductive infseq : Type := Cons : T -> infseq -> infseq.

Definition hd (s:infseq) : T := match s with Cons x _ => x end.

Definition tl (s:infseq) : infseq := match s with Cons _ s => s end.

Lemma recons : forall s, Cons (hd s) (tl s) = s.

End sec_infseq.

Arguments Cons [T] _ _.
Arguments hd [T] _.
Arguments tl [T] _.
Arguments recons [T] _.

Section sec_modal_op_defn.

Variable T : Type.

Definition now (P: T->Prop) (s: infseq T) : Prop :=
  match s with Cons x s => P x end.

Definition next (P: infseq T -> Prop) (s: infseq T) : Prop :=
  match s with Cons x s => P s end.

Definition consecutive  (R: T -> T -> Prop) (s: infseq T) : Prop :=
  match s with Cons x1 (Cons x2 s) => R x1 x2 end. 

CoInductive always1 (P: T->Prop) : infseq T -> Prop :=
  | Always1 : forall x s, P x -> always1 P s -> always1 P (Cons x s).

CoInductive always (P: infseq T->Prop) : infseq T -> Prop :=
  | Always : forall s, P s -> always P (tl s) -> always P s.

CoInductive weak_until (J P: infseq T->Prop) : infseq T -> Prop :=
  | W0 : forall s, P s -> weak_until J P s
  | W_tl : forall s, J s -> weak_until J P (tl s) -> weak_until J P s.

Inductive until (J P: infseq T->Prop) : infseq T -> Prop :=
  | U0 : forall s, P s -> until J P s
  | U_next : forall x s, J (Cons x s) -> until J P s -> until J P (Cons x s).

CoInductive release (J P: infseq T->Prop) : infseq T -> Prop :=
  | R0 : forall s, P s -> J s -> release J P s
  | R_tl : forall s, P s -> release J P (tl s) -> release J P s.

Inductive eventually (P: infseq T->Prop) : infseq T -> Prop :=
  | E0 : forall s, P s -> eventually P s
  | E_next : forall x s, eventually P s -> eventually P (Cons x s).

Definition inf_often (P: infseq T->Prop) (s: infseq T) : Prop :=
  always (eventually P) s.

Definition continuously (P: infseq T->Prop) (s: infseq T) : Prop :=  
  eventually (always P) s.

Definition impl_tl (P Q: infseq T -> Prop) : infseq T -> Prop :=
  fun s => P s -> Q s. 
Definition and_tl (P Q: infseq T -> Prop) : infseq T -> Prop :=
  fun s => P s /\ Q s. 
Definition or_tl (P Q: infseq T -> Prop) : infseq T -> Prop :=
  fun s => P s \/ Q s. 
Definition not_tl (P : infseq T -> Prop) : infseq T -> Prop := 
  fun s => ~ P s.

Definition True_tl : infseq T -> Prop := fun _ => True.
Definition False_tl : infseq T -> Prop := fun _ => False.

End sec_modal_op_defn.

Hint Unfold True_tl False_tl : core.

Arguments now [T] _ _.
Arguments next [T] _ _.
Arguments consecutive [T] _ _.
Arguments always [T] _ _.
Arguments always1 [T] _ _.
Arguments eventually [T] _ _.
Arguments weak_until [T] _ _ _.
Arguments until [T] _ _ _.
Arguments release [T] _ _ _.
Arguments inf_often [T] _ _.
Arguments continuously [T] _ _.

Arguments impl_tl [T] _ _ _.
Arguments and_tl [T] _ _ _.
Arguments or_tl [T] _ _ _.
Arguments not_tl [T] _ _.

Arguments True_tl {T} _.
Arguments False_tl {T} _.

Notation "A ->_ B" := (impl_tl A B) (right associativity, at level 90).
Notation "A /\_ B" := (and_tl A B) (right associativity, at level 80).
Notation "A \/_ B" := (or_tl A B) (right associativity, at level 85).
Notation "~_ A" := (not_tl A) (right associativity, at level 75).

Section sec_modal_op_lemmas.

Variable T : Type.

Lemma now_hd :
  forall (P : T -> Prop) ex,
    now P ex ->
    P (hd ex).

Lemma always_inv :
  forall (inv: infseq T -> Prop),
    (forall x s, inv (Cons x s) -> inv s) -> forall s, inv s -> always inv s.

Lemma always_Cons :
  forall (x: T) (s: infseq T) P,
  always P (Cons x s) -> P (Cons x s) /\ always P s.

Lemma always_now :
  forall (x: T) (s: infseq T) P, always P (Cons x s) -> P (Cons x s).

Lemma always_now' :
  forall (P : infseq T -> Prop) ex,
    always P ex ->
    P ex.

Lemma always_invar :
  forall (x: T) (s: infseq T) P, always P (Cons x s) -> always P s.

Lemma always_tl :
  forall (s: infseq T) P, always P s -> always P (tl s).

Lemma always_not_false :
  forall s : infseq T, always (~_ False_tl) s.

Lemma always_true :
  forall s : infseq T, always True_tl s.

Lemma always_and_tl :
  forall (P Q : infseq T -> Prop),
    forall s, always P s -> always Q s -> always (P /\_ Q) s.

Lemma always_always :
  forall (P : infseq T -> Prop) s,
    always P s ->
    always (always P) s.

Lemma always_always1 :
   forall P (s: infseq T), always (now P) s -> always1 P s.

Lemma always1_always :
   forall P (s: infseq T), always1 P s -> always (now P) s.

Lemma always_weak_until :
  forall (J P : infseq T -> Prop) (s : infseq T), always J s -> weak_until J P s.

Lemma always_release :
  forall (J P : infseq T -> Prop) (s : infseq T), always P s -> release J P s.

Lemma always_inf_often :
   forall (P: infseq T -> Prop) (s : infseq T), always P s -> inf_often P s.

Lemma always_continuously :
   forall (P: infseq T -> Prop) (s : infseq T), always P s -> continuously P s.

Lemma weak_until_Cons :
  forall (x: T) (s: infseq T) J P,
  weak_until J P (Cons x s) -> P (Cons x s) \/ (J (Cons x s) /\ weak_until J P s).

Lemma weak_until_always :
  forall (J J' P : infseq T -> Prop) s,
    weak_until J P s ->
    always J' s ->
    weak_until (J' /\_ J) P s.

Lemma until_weak_until :
  forall (J P : infseq T -> Prop) (s : infseq T),
  until J P s -> weak_until J P s.

Lemma eventually_Cons :
  forall (x: T) (s: infseq T) P,
  eventually P (Cons x s) -> P (Cons x s) \/ eventually P s.

Lemma eventually_trans :
  forall (P Q inv: infseq T -> Prop),
  (forall x s, inv (Cons x s) -> inv s) ->
  (forall s, inv s -> P s -> eventually Q s) ->
  forall s, inv s -> eventually P s -> eventually Q s.

Lemma not_eventually :
  forall (P : infseq T -> Prop),
  forall x s, ~ eventually P (Cons x s) -> ~ eventually P s.

Lemma eventually_next : 
  forall (s: infseq T) P, eventually (next P) s -> eventually P s. 

Lemma eventually_always_cumul :
  forall (s: infseq T) P Q,
  eventually P s -> always Q s -> eventually (P /\_ always Q) s.

Lemma eventually_weak_until_cumul :
  forall (s: infseq T) P J,
  eventually P s -> weak_until J P s -> eventually (P /\_ weak_until J P) s.

Lemma weak_until_eventually :
  forall (P Q J: infseq T -> Prop),
  (forall s, J s -> P s -> Q s) ->
  forall s, J s -> weak_until J Q s -> eventually P s -> eventually Q s.

Lemma eventually_or_tl_intror :
  forall (P Q : infseq T -> Prop) s,
    eventually Q s ->
    eventually (P \/_ Q) s.

Lemma eventually_or_tl_introl :
  forall (P Q : infseq T -> Prop) s,
    eventually P s ->
    eventually (P \/_ Q) s.

Lemma eventually_or_tl_or :
  forall (P Q : infseq T -> Prop) s,
    eventually (P \/_ Q) s ->
    eventually P s \/ eventually Q s.

Lemma until_Cons :
  forall (x: T) (s: infseq T) J P,
  until J P (Cons x s) -> P (Cons x s) \/ (J (Cons x s) /\ until J P s).

Lemma until_eventually :
  forall (J P : infseq T -> Prop),
  forall s, until J P s -> eventually P s.

Lemma release_Cons :
  forall (x: T) (s: infseq T) J P,
  release J P (Cons x s) -> P (Cons x s) /\ (J (Cons x s) \/ release J P s).

Lemma inf_often_invar :
  forall (x: T) (s: infseq T) P, inf_often P (Cons x s) -> inf_often P s.

Lemma continuously_invar :
  forall (x: T) (s: infseq T) P, continuously P (Cons x s) -> continuously P s.

Lemma continuously_and_tl :
  forall (P Q : infseq T -> Prop) (s : infseq T),
  continuously P s -> continuously Q s -> continuously (P /\_ Q) s.

Lemma continuously_inf_often : 
  forall (P : infseq T -> Prop) (s : infseq T),
    continuously P s -> inf_often P s.

Lemma now_monotonic :
  forall (P Q: T -> Prop), 
  (forall x, P x -> Q x) -> forall s, now P s -> now Q s.

Lemma next_monotonic :
  forall (P Q: infseq T -> Prop),
  (forall s, P s -> Q s) -> forall s, next P s -> next Q s.

Lemma consecutive_monotonic :
  forall (P Q: T -> T -> Prop), 
  (forall x y, P x y -> Q x y) -> forall s, consecutive P s -> consecutive Q s.

Lemma always_monotonic :
  forall (P Q: infseq T -> Prop),
  (forall s, P s -> Q s) -> forall s, always P s -> always Q s.

Lemma weak_until_monotonic :
  forall (P Q J K: infseq T -> Prop),
  (forall s, P s -> Q s) -> (forall s, J s -> K s) ->
  forall s, weak_until J P s -> weak_until K Q s.

Lemma until_monotonic :
  forall (P Q J K: infseq T -> Prop),
  (forall s, P s -> Q s) -> (forall s, J s -> K s) ->
  forall s, until J P s -> until K Q s.

Lemma release_monotonic :
  forall (P Q J K: infseq T -> Prop),
  (forall s, P s -> Q s) -> (forall s, J s -> K s) ->
  forall s, release J P s -> release K Q s.

Lemma eventually_monotonic :
  forall (P Q J: infseq T -> Prop), 
  (forall x s, J (Cons x s) -> J s) ->
  (forall s, J s -> P s -> Q s) -> 
  forall s, J s -> eventually P s -> eventually Q s.

Lemma eventually_monotonic_simple :
  forall (P Q: infseq T -> Prop), 
  (forall s, P s -> Q s) -> 
  forall s, eventually P s -> eventually Q s.

Lemma inf_often_monotonic :
  forall (P Q : infseq T -> Prop),
  (forall s, P s -> Q s) ->
  forall s, inf_often P s -> inf_often Q s.

Lemma cumul_eventually_always :
  forall (P Q : infseq T -> Prop) s,
    always P s ->
    eventually Q s ->
    eventually (P /\_ Q) s.

Lemma cumul_inf_often_always :
  forall (P Q : infseq T -> Prop) s,
    always P s ->
    inf_often Q s ->
    inf_often (P /\_ Q) s.

Lemma inf_often_monotonic_invar :
  forall (invariant P Q : infseq T -> Prop),
    (forall s,
        invariant s ->
        P s ->
        Q s) ->
    forall ex,
      always invariant ex ->
      inf_often P ex ->
      inf_often Q ex.

Lemma continuously_monotonic :
  forall (P Q : infseq T -> Prop),
  (forall s, P s -> Q s) ->
  forall s, continuously P s -> continuously Q s.

Lemma not_eventually_always_not :
  forall (P : infseq T -> Prop) (s : infseq T),
  ~ eventually P s -> always (~_ P) s.

Lemma always_not_eventually :
  forall (P : infseq T -> Prop) (s : infseq T),
  always (~_ P) s -> ~ eventually P s.

Lemma eventually_not_always :
  forall (P : infseq T -> Prop) (s : infseq T),
    eventually (~_ P) s -> ~ always P s.

Lemma weak_until_always_not_always :
  forall (J P : infseq T -> Prop) (s : infseq T),
  weak_until J P s -> always (~_ P) s -> always J s.

Lemma weak_until_latch_eventually :
  forall (P Q : infseq T -> Prop) ex,
    weak_until (P /\_ ~_ Q) (P /\_ Q) ex ->
    eventually Q ex ->
    eventually (P /\_ Q) ex.

Lemma always_not_eventually_not :
  forall (P : infseq T -> Prop) (s : infseq T),
    always P s -> ~ eventually (~_ P) s.

Lemma continuously_not_inf_often :
  forall (P : infseq T -> Prop) (s : infseq T),
  continuously (~_ P) s -> ~ inf_often P s.

Lemma inf_often_not_continuously :
  forall (P : infseq T -> Prop) (s : infseq T),
  inf_often (~_ P) s -> ~ continuously P s.

Lemma release_not_until : 
  forall (J P : infseq T -> Prop) (s : infseq T),
  release J P s -> ~ until (~_ J) (~_ P) s.

Lemma until_not_release :
  forall (J P : infseq T -> Prop) (s : infseq T),
  until J P s -> ~ release (~_ J) (~_ P) s.

Lemma weak_until_not_until :
  forall (J P : infseq T -> Prop) (s : infseq T),
    weak_until (J /\_ ~_ P) (~_ J /\_ ~_ P) s -> ~ until J P s.

Lemma until_not_weak_until :
  forall (J P : infseq T -> Prop) (s : infseq T),
    until (J /\_ ~_ P) (~_ J /\_ ~_ P) s -> ~ weak_until J P s.

Lemma and_tl_comm : 
  forall (P Q : infseq T -> Prop) (s : infseq T),
  (P /\_ Q) s <-> (Q /\_ P) s.

Lemma and_tl_assoc : 
  forall (P Q R : infseq T -> Prop) (s : infseq T),
  ((P /\_ Q) /\_ R) s <-> (P /\_ Q /\_ R) s.

Lemma or_tl_comm :
  forall (P Q : infseq T -> Prop) (s : infseq T),
  (P \/_ Q) s <-> (Q \/_ P) s.

Lemma or_tl_assoc : 
  forall (P Q R : infseq T -> Prop) (s : infseq T),
  ((P \/_ Q) \/_ R) s <-> (P \/_ Q \/_ R) s.

Lemma not_tl_or_tl : 
  forall (P Q : infseq T -> Prop) (s : infseq T),
  (~_ (P \/_ Q)) s <-> ((~_ P) /\_ (~_ Q)) s.

Lemma not_tl_or_tl_and_tl : 
  forall (P Q : infseq T -> Prop) (s : infseq T),
    ((~_ P) \/_ (~_ Q)) s -> (~_ (P /\_ Q)) s.

End sec_modal_op_lemmas.

Arguments always_inv [T inv] _ [s] _.
Arguments always_Cons [T x s P] _.
Arguments always_now [T x s P] _.
Arguments always_invar [T x s P] _.
Arguments always_tl [T s P] _.
Arguments always_not_false [T s].
Arguments always_true [T s].
Arguments always_and_tl [T P Q s] _ _.
Arguments always_always1 [T P s] _.
Arguments always1_always [T P s] _.
Arguments always_weak_until [T J P s] _.
Arguments always_release [T J P s] _.
Arguments always_inf_often [T P s] _.
Arguments always_continuously [T P s] _.

Arguments weak_until_Cons [T x s J P] _.
Arguments weak_until_always [T J J' P s] _ _.
Arguments until_weak_until [T J P s] _.
Arguments eventually_Cons [T x s P] _.
Arguments eventually_trans [T P Q inv] _ _ [s] _ _.
Arguments not_eventually [T P x s] _ _.
Arguments eventually_next [T s P] _.
Arguments eventually_always_cumul [T s P Q] _ _.
Arguments eventually_weak_until_cumul [T s P J] _ _.
Arguments weak_until_eventually [T P Q J] _ [s] _ _ _.
Arguments until_Cons [T x s J P] _.
Arguments until_eventually [T J P s] _.
Arguments release_Cons [T x s J P] _.
Arguments inf_often_invar [T x s P] _.
Arguments continuously_invar [T x s P] _.
Arguments continuously_and_tl [T P Q s] _ _.
Arguments continuously_inf_often [T P s] _.

Arguments now_monotonic [T P Q] _ [s] _.
Arguments next_monotonic [T P Q] _ [s] _.
Arguments consecutive_monotonic [T P Q] _ [s] _.
Arguments always_monotonic [T P Q] _ [s] _.
Arguments weak_until_monotonic [T P Q J K] _ _ [s] _.
Arguments until_monotonic [T P Q J K] _ _ [s] _.
Arguments release_monotonic [T P Q J K] _ _ [s] _.
Arguments eventually_monotonic [T P Q] _ _ _ [s] _ _.
Arguments eventually_monotonic_simple [T P Q] _ [s] _.
Arguments inf_often_monotonic [T P Q] _ [s] _.
Arguments continuously_monotonic [T P Q] _ [s] _.

Arguments not_eventually_always_not [T P s] _.
Arguments always_not_eventually [T P s] _ _.
Arguments eventually_not_always [T P s] _ _.
Arguments weak_until_always_not_always [T J P s] _ _.
Arguments always_not_eventually_not [T P s] _ _.
Arguments continuously_not_inf_often [T P s] _ _.
Arguments inf_often_not_continuously [T P s] _ _.
Arguments release_not_until [T J P s] _ _.
Arguments until_not_release [T J P s] _ _.
Arguments weak_until_not_until [T J P s] _ _.
Arguments until_not_weak_until [T J P s] _ _.

Arguments and_tl_comm [T P Q s].
Arguments and_tl_assoc [T P Q R s].
Arguments or_tl_comm [T P Q s].
Arguments or_tl_assoc [T P Q R s].
Arguments not_tl_or_tl [T P Q s].
Arguments not_tl_or_tl_and_tl [T P Q s] _ _.

Ltac monotony := 
  match goal with 
     | [ |- now ?P ?s -> now ?Q ?s ] =>
       apply now_monotonic
     | [ |- next ?P ?s -> next ?Q ?s ] =>
       apply next_monotonic
     | [ |- consecutive ?P ?s -> consecutive ?Q ?s ] =>
       apply consecutive_monotonic
     | [ |- always ?P ?s -> always ?Q ?s ] =>
       apply always_monotonic
     | [ |- weak_until ?J ?P ?s -> weak_until ?K ?Q ?s ] =>
       apply weak_until_monotonic
     | [ |- until ?J ?P ?s -> until ?K ?Q ?s ] =>
       apply until_monotonic
     | [ |- release ?J ?P ?s -> release ?K ?Q ?s ] =>
       apply release_monotonic
     | [ |- ?J ?s -> eventually ?P ?s -> eventually ?Q ?s ] =>
       apply eventually_monotonic
     | [ |- continuously ?P ?s -> continuously ?Q ?s ] =>
       apply continuously_monotonic
     | [ |- inf_often ?P ?s -> inf_often ?Q ?s ] =>
       apply inf_often_monotonic
  end. *)



Section sec_exteq.



Variable T: Type. 



CoInductive exteq : infseq T -> infseq T -> Prop :=

  exteq_intro :

    forall x s1 s2, exteq s1 s2 -> exteq (Cons x s1) (Cons x s2).



Lemma exteq_inversion :

  forall (x1:T) s1 x2 s2, 

  exteq (Cons x1 s1) (Cons x2 s2) -> x1 = x2 /\ exteq s1 s2.

Proof using.

intros x1 s1 x2 s2 e. 

change (hd (Cons x1 s1) = hd (Cons x2 s2) /\

        exteq (tl (Cons x1 s1)) (tl (Cons x2 s2))).

case e; clear e x1 s1 x2 s2. simpl. intros; split; trivial. 

Qed.



Lemma exteq_refl : forall s, exteq s s. 

Proof using.

cofix cf. intros (x, s). constructor. apply cf. 

Qed.



Lemma exteq_sym : forall s1 s2, exteq s1 s2 -> exteq s2 s1.

Proof using.

cofix cf. destruct 1. constructor. apply cf. assumption. 

Qed.



Lemma exteq_trans :

   forall s1 s2 s3, exteq s1 s2 -> exteq s2 s3 -> exteq s1 s3.

Proof using.

cofix cf.

intros (x1, s1) (x2, s2) (x3, s3) e12 e23. 

case (exteq_inversion _ _ _ _ e12); clear e12; intros e12 ex12. 

case (exteq_inversion _ _ _ _ e23); clear e23; intros e23 ex23. 

rewrite e12; rewrite e23. constructor. apply cf with s2; assumption. 

Qed.



End sec_exteq.



Arguments exteq [T] _ _.

Arguments exteq_inversion [T x1 s1 x2 s2] _.

Arguments exteq_refl [T] _.

Arguments exteq_sym [T] _ _ _.

Arguments exteq_trans [T] _ _ _ _ _.



Section sec_exteq_congruence.



Variable T: Type. 



Definition extensional (P: infseq T -> Prop) :=

  forall s1 s2, exteq s1 s2 -> P s1 -> P s2.



Lemma extensional_True_tl :

  extensional True_tl.

Proof using.

intros s1 s2 eq; auto.

Qed.



Lemma extensional_False_tl :

  extensional False_tl.

Proof using.

intros s1 s2 eq; auto.

Qed.



Lemma extensional_and_tl :

  forall (P Q: infseq T -> Prop), 

  extensional P -> extensional Q -> extensional (P /\_ Q).

Proof using. 

intros P Q eP eQ s1 s2 e. destruct e; simpl. unfold and_tl. intuition.

- apply eP with (Cons x s1); [constructor; assumption | assumption].

- apply eQ with (Cons x s1); [constructor; assumption | assumption].

Qed.



Lemma extensional_or_tl :

  forall (P Q: infseq T -> Prop),

  extensional P -> extensional Q -> extensional (P \/_ Q).

Proof using. 

intros P Q eP eQ s1 s2 e. destruct e; simpl. unfold or_tl. intuition.

- left; apply eP with (Cons x s1); [constructor; assumption | assumption]. 

- right; apply eQ with (Cons x s1); [constructor; assumption | assumption]. 

Qed.



Lemma extensional_impl_tl :

  forall (P Q: infseq T -> Prop),

  extensional P -> extensional Q -> extensional (P ->_ Q).

Proof using. 

intros P Q eP eQ s1 s2 e. destruct e; simpl. unfold impl_tl. 

intros PQ1 P2. 

apply eQ with (Cons x s1); [constructor; assumption | idtac].

apply PQ1. apply eP with (Cons x s2). 

- constructor. apply exteq_sym. assumption.

- assumption.

Qed.



Lemma extensional_not_tl :

  forall (P: infseq T -> Prop),

  extensional P -> extensional (~_ P).

Proof using.

intros P eP s1 s2 e; destruct e; simpl. unfold not_tl.

intros P1 nP2.

contradict P1.

apply eP with (Cons x s2); trivial.

apply exteq_sym.

apply exteq_intro.

assumption.

Qed.



Lemma extensional_now :

  forall (P: T -> Prop), extensional (now P).

Proof using. 

intros P s1 s2 e. destruct e; simpl. trivial.

Qed.



Lemma extensional_next :

  forall (P: infseq T -> Prop), 

  extensional P -> extensional (next P).

Proof using.

intros P eP s1 s2 exP; destruct exP; simpl.

apply eP; assumption.

Qed.



Lemma extensional_consecutive :

  forall (P: T -> T -> Prop), extensional (consecutive P).

Proof using. 

intros P s1 s2 e. do 2 destruct e; simpl. trivial.

Qed.



Lemma extensional_always :

  forall (P: infseq T -> Prop),

  extensional P -> extensional (always P).

Proof using.

intros P eP. cofix cf.

intros (x1, s1) (x2, s2) e al1. case (always_Cons al1); intros Px1s1 als1. constructor.

- eapply eP; eassumption. 

- simpl. apply cf with s1; try assumption. case (exteq_inversion e); trivial.

Qed.



Lemma extensional_weak_until :

  forall (P Q: infseq T -> Prop),

  extensional P -> extensional Q -> extensional (weak_until P Q).

Proof using.

intros P Q eP eQ. cofix cf. 

intros (x1, s1) (x2, s2) e un1. case (weak_until_Cons un1).

- intro Q1. constructor 1. eapply eQ; eassumption.

- intros (Px1s1, uns1). constructor 2.

  * eapply eP; eassumption. 

  * simpl. apply cf with s1; try assumption. case (exteq_inversion e); trivial.

Qed.



Lemma extensional_until :

  forall (P Q: infseq T -> Prop),

  extensional P -> extensional Q -> extensional (until P Q).

Proof using.

intros P Q eP eQ s1 s2 e un1; genclear e; genclear s2.

induction un1.

- intros s2 e; apply U0; apply eQ with s; assumption.

- intros (x2, s2) e.

  apply U_next.

  * apply eP with (Cons x s); assumption.

  * apply IHun1.

    case (exteq_inversion e). trivial.

Qed.



Lemma extensional_release :

  forall (P Q: infseq T -> Prop),

  extensional P -> extensional Q -> extensional (release P Q).

Proof using.

intros P Q eP eQ. cofix cf. 

intros (x1, s1) (x2, s2) e rl1. case (release_Cons rl1). intros Qx orR. case orR; intro orRx.

- apply R0.

  * eapply eQ; eassumption.

  * eapply eP; eassumption.

- apply R_tl.

  * eapply eQ; eassumption.

  * simpl. apply cf with s1; trivial. case (exteq_inversion e); trivial.

Qed.



Lemma extensional_eventually :

  forall (P: infseq T -> Prop),

  extensional P -> extensional (eventually P).

Proof using.

intros P eP s1 s2 e ev1. genclear e; genclear s2.

induction ev1 as [s1 ev1 | x1 s1 ev1 induc_hyp].

- intros s2 e. constructor 1. apply eP with s1; assumption.

- intros (x2, s2) e. constructor 2. apply induc_hyp.

  case (exteq_inversion e). trivial.

Qed.



Lemma extensional_inf_often :

forall (P: infseq T -> Prop),

  extensional P -> extensional (inf_often P).

Proof using.

intros P eP; apply extensional_always; apply extensional_eventually; assumption.

Qed.



Lemma extensional_continuously :

forall (P: infseq T -> Prop),

  extensional P -> extensional (continuously P).

Proof using.

intros P eP; apply extensional_eventually; apply extensional_always; assumption.

Qed.



End sec_exteq_congruence.



Arguments extensional [T] _.

Arguments extensional_True_tl [T] _ _ _ _.

Arguments extensional_False_tl [T] _ _ _ _.

Arguments extensional_and_tl [T P Q] _ _ _ _ _ _.

Arguments extensional_or_tl [T P Q] _ _ _ _ _ _.

Arguments extensional_impl_tl [T P Q] _ _ _ _ _ _ _.

Arguments extensional_not_tl [T P] _ _ _ _ _ _.

Arguments extensional_now [T P] _ _ _ _.

Arguments extensional_next [T P] _ _ _ _ _.

Arguments extensional_consecutive [T P] _ _ _ _.

Arguments extensional_always [T P] _ _ _ _ _.

Arguments extensional_weak_until [T P Q] _ _ _ _ _ _.

Arguments extensional_until [T P Q] _ _ _ _ _ _.

Arguments extensional_release [T P Q] _ _ _ _ _ _.

Arguments extensional_eventually [T P] _ _ _ _ _.

Arguments extensional_inf_often [T P] _ _ _ _ _.

Arguments extensional_continuously [T P] _ _ _ _ _.

