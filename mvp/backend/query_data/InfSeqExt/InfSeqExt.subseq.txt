Require Import InfSeqExt.infseq.
(* InfSeqExt.infseq:
Ltac genclear H := generalize H; clear H.

Ltac clearall :=
   repeat
        match goal with [H : _ |- _ ] => clear H end
     || match goal with [H : _ |- _ ] => genclear H end. 

Section sec_infseq.

Variable T: Type. 

CoInductive infseq : Type := Cons : T -> infseq -> infseq.

Definition hd (s:infseq) : T := match s with Cons x _ => x end.

Definition tl (s:infseq) : infseq := match s with Cons _ s => s end.

Lemma recons : forall s, Cons (hd s) (tl s) = s.

End sec_infseq.

Arguments Cons [T] _ _.
Arguments hd [T] _.
Arguments tl [T] _.
Arguments recons [T] _.

Section sec_modal_op_defn.

Variable T : Type.

Definition now (P: T->Prop) (s: infseq T) : Prop :=
  match s with Cons x s => P x end.

Definition next (P: infseq T -> Prop) (s: infseq T) : Prop :=
  match s with Cons x s => P s end.

Definition consecutive  (R: T -> T -> Prop) (s: infseq T) : Prop :=
  match s with Cons x1 (Cons x2 s) => R x1 x2 end. 

CoInductive always1 (P: T->Prop) : infseq T -> Prop :=
  | Always1 : forall x s, P x -> always1 P s -> always1 P (Cons x s).

CoInductive always (P: infseq T->Prop) : infseq T -> Prop :=
  | Always : forall s, P s -> always P (tl s) -> always P s.

CoInductive weak_until (J P: infseq T->Prop) : infseq T -> Prop :=
  | W0 : forall s, P s -> weak_until J P s
  | W_tl : forall s, J s -> weak_until J P (tl s) -> weak_until J P s.

Inductive until (J P: infseq T->Prop) : infseq T -> Prop :=
  | U0 : forall s, P s -> until J P s
  | U_next : forall x s, J (Cons x s) -> until J P s -> until J P (Cons x s).

CoInductive release (J P: infseq T->Prop) : infseq T -> Prop :=
  | R0 : forall s, P s -> J s -> release J P s
  | R_tl : forall s, P s -> release J P (tl s) -> release J P s.

Inductive eventually (P: infseq T->Prop) : infseq T -> Prop :=
  | E0 : forall s, P s -> eventually P s
  | E_next : forall x s, eventually P s -> eventually P (Cons x s).

Definition inf_often (P: infseq T->Prop) (s: infseq T) : Prop :=
  always (eventually P) s.

Definition continuously (P: infseq T->Prop) (s: infseq T) : Prop :=  
  eventually (always P) s.

Definition impl_tl (P Q: infseq T -> Prop) : infseq T -> Prop :=
  fun s => P s -> Q s. 
Definition and_tl (P Q: infseq T -> Prop) : infseq T -> Prop :=
  fun s => P s /\ Q s. 
Definition or_tl (P Q: infseq T -> Prop) : infseq T -> Prop :=
  fun s => P s \/ Q s. 
Definition not_tl (P : infseq T -> Prop) : infseq T -> Prop := 
  fun s => ~ P s.

Definition True_tl : infseq T -> Prop := fun _ => True.
Definition False_tl : infseq T -> Prop := fun _ => False.

End sec_modal_op_defn.

Hint Unfold True_tl False_tl : core.

Arguments now [T] _ _.
Arguments next [T] _ _.
Arguments consecutive [T] _ _.
Arguments always [T] _ _.
Arguments always1 [T] _ _.
Arguments eventually [T] _ _.
Arguments weak_until [T] _ _ _.
Arguments until [T] _ _ _.
Arguments release [T] _ _ _.
Arguments inf_often [T] _ _.
Arguments continuously [T] _ _.

Arguments impl_tl [T] _ _ _.
Arguments and_tl [T] _ _ _.
Arguments or_tl [T] _ _ _.
Arguments not_tl [T] _ _.

Arguments True_tl {T} _.
Arguments False_tl {T} _.

Notation "A ->_ B" := (impl_tl A B) (right associativity, at level 90).
Notation "A /\_ B" := (and_tl A B) (right associativity, at level 80).
Notation "A \/_ B" := (or_tl A B) (right associativity, at level 85).
Notation "~_ A" := (not_tl A) (right associativity, at level 75).

Section sec_modal_op_lemmas.

Variable T : Type.

Lemma now_hd :
  forall (P : T -> Prop) ex,
    now P ex ->
    P (hd ex).

Lemma always_inv :
  forall (inv: infseq T -> Prop),
    (forall x s, inv (Cons x s) -> inv s) -> forall s, inv s -> always inv s.

Lemma always_Cons :
  forall (x: T) (s: infseq T) P,
  always P (Cons x s) -> P (Cons x s) /\ always P s.

Lemma always_now :
  forall (x: T) (s: infseq T) P, always P (Cons x s) -> P (Cons x s).

Lemma always_now' :
  forall (P : infseq T -> Prop) ex,
    always P ex ->
    P ex.

Lemma always_invar :
  forall (x: T) (s: infseq T) P, always P (Cons x s) -> always P s.

Lemma always_tl :
  forall (s: infseq T) P, always P s -> always P (tl s).

Lemma always_not_false :
  forall s : infseq T, always (~_ False_tl) s.

Lemma always_true :
  forall s : infseq T, always True_tl s.

Lemma always_and_tl :
  forall (P Q : infseq T -> Prop),
    forall s, always P s -> always Q s -> always (P /\_ Q) s.

Lemma always_always :
  forall (P : infseq T -> Prop) s,
    always P s ->
    always (always P) s.

Lemma always_always1 :
   forall P (s: infseq T), always (now P) s -> always1 P s.

Lemma always1_always :
   forall P (s: infseq T), always1 P s -> always (now P) s.

Lemma always_weak_until :
  forall (J P : infseq T -> Prop) (s : infseq T), always J s -> weak_until J P s.

Lemma always_release :
  forall (J P : infseq T -> Prop) (s : infseq T), always P s -> release J P s.

Lemma always_inf_often :
   forall (P: infseq T -> Prop) (s : infseq T), always P s -> inf_often P s.

Lemma always_continuously :
   forall (P: infseq T -> Prop) (s : infseq T), always P s -> continuously P s.

Lemma weak_until_Cons :
  forall (x: T) (s: infseq T) J P,
  weak_until J P (Cons x s) -> P (Cons x s) \/ (J (Cons x s) /\ weak_until J P s).

Lemma weak_until_always :
  forall (J J' P : infseq T -> Prop) s,
    weak_until J P s ->
    always J' s ->
    weak_until (J' /\_ J) P s.

Lemma until_weak_until :
  forall (J P : infseq T -> Prop) (s : infseq T),
  until J P s -> weak_until J P s.

Lemma eventually_Cons :
  forall (x: T) (s: infseq T) P,
  eventually P (Cons x s) -> P (Cons x s) \/ eventually P s.

Lemma eventually_trans :
  forall (P Q inv: infseq T -> Prop),
  (forall x s, inv (Cons x s) -> inv s) ->
  (forall s, inv s -> P s -> eventually Q s) ->
  forall s, inv s -> eventually P s -> eventually Q s.

Lemma not_eventually :
  forall (P : infseq T -> Prop),
  forall x s, ~ eventually P (Cons x s) -> ~ eventually P s.

Lemma eventually_next : 
  forall (s: infseq T) P, eventually (next P) s -> eventually P s. 

Lemma eventually_always_cumul :
  forall (s: infseq T) P Q,
  eventually P s -> always Q s -> eventually (P /\_ always Q) s.

Lemma eventually_weak_until_cumul :
  forall (s: infseq T) P J,
  eventually P s -> weak_until J P s -> eventually (P /\_ weak_until J P) s.

Lemma weak_until_eventually :
  forall (P Q J: infseq T -> Prop),
  (forall s, J s -> P s -> Q s) ->
  forall s, J s -> weak_until J Q s -> eventually P s -> eventually Q s.

Lemma eventually_or_tl_intror :
  forall (P Q : infseq T -> Prop) s,
    eventually Q s ->
    eventually (P \/_ Q) s.

Lemma eventually_or_tl_introl :
  forall (P Q : infseq T -> Prop) s,
    eventually P s ->
    eventually (P \/_ Q) s.

Lemma eventually_or_tl_or :
  forall (P Q : infseq T -> Prop) s,
    eventually (P \/_ Q) s ->
    eventually P s \/ eventually Q s.

Lemma until_Cons :
  forall (x: T) (s: infseq T) J P,
  until J P (Cons x s) -> P (Cons x s) \/ (J (Cons x s) /\ until J P s).

Lemma until_eventually :
  forall (J P : infseq T -> Prop),
  forall s, until J P s -> eventually P s.

Lemma release_Cons :
  forall (x: T) (s: infseq T) J P,
  release J P (Cons x s) -> P (Cons x s) /\ (J (Cons x s) \/ release J P s).

Lemma inf_often_invar :
  forall (x: T) (s: infseq T) P, inf_often P (Cons x s) -> inf_often P s.

Lemma continuously_invar :
  forall (x: T) (s: infseq T) P, continuously P (Cons x s) -> continuously P s.

Lemma continuously_and_tl :
  forall (P Q : infseq T -> Prop) (s : infseq T),
  continuously P s -> continuously Q s -> continuously (P /\_ Q) s.

Lemma continuously_inf_often : 
  forall (P : infseq T -> Prop) (s : infseq T),
    continuously P s -> inf_often P s.

Lemma now_monotonic :
  forall (P Q: T -> Prop), 
  (forall x, P x -> Q x) -> forall s, now P s -> now Q s.

Lemma next_monotonic :
  forall (P Q: infseq T -> Prop),
  (forall s, P s -> Q s) -> forall s, next P s -> next Q s.

Lemma consecutive_monotonic :
  forall (P Q: T -> T -> Prop), 
  (forall x y, P x y -> Q x y) -> forall s, consecutive P s -> consecutive Q s.

Lemma always_monotonic :
  forall (P Q: infseq T -> Prop),
  (forall s, P s -> Q s) -> forall s, always P s -> always Q s.

Lemma weak_until_monotonic :
  forall (P Q J K: infseq T -> Prop),
  (forall s, P s -> Q s) -> (forall s, J s -> K s) ->
  forall s, weak_until J P s -> weak_until K Q s.

Lemma until_monotonic :
  forall (P Q J K: infseq T -> Prop),
  (forall s, P s -> Q s) -> (forall s, J s -> K s) ->
  forall s, until J P s -> until K Q s.

Lemma release_monotonic :
  forall (P Q J K: infseq T -> Prop),
  (forall s, P s -> Q s) -> (forall s, J s -> K s) ->
  forall s, release J P s -> release K Q s.

Lemma eventually_monotonic :
  forall (P Q J: infseq T -> Prop), 
  (forall x s, J (Cons x s) -> J s) ->
  (forall s, J s -> P s -> Q s) -> 
  forall s, J s -> eventually P s -> eventually Q s.

Lemma eventually_monotonic_simple :
  forall (P Q: infseq T -> Prop), 
  (forall s, P s -> Q s) -> 
  forall s, eventually P s -> eventually Q s.

Lemma inf_often_monotonic :
  forall (P Q : infseq T -> Prop),
  (forall s, P s -> Q s) ->
  forall s, inf_often P s -> inf_often Q s.

Lemma cumul_eventually_always :
  forall (P Q : infseq T -> Prop) s,
    always P s ->
    eventually Q s ->
    eventually (P /\_ Q) s.

Lemma cumul_inf_often_always :
  forall (P Q : infseq T -> Prop) s,
    always P s ->
    inf_often Q s ->
    inf_often (P /\_ Q) s.

Lemma inf_often_monotonic_invar :
  forall (invariant P Q : infseq T -> Prop),
    (forall s,
        invariant s ->
        P s ->
        Q s) ->
    forall ex,
      always invariant ex ->
      inf_often P ex ->
      inf_often Q ex.

Lemma continuously_monotonic :
  forall (P Q : infseq T -> Prop),
  (forall s, P s -> Q s) ->
  forall s, continuously P s -> continuously Q s.

Lemma not_eventually_always_not :
  forall (P : infseq T -> Prop) (s : infseq T),
  ~ eventually P s -> always (~_ P) s.

Lemma always_not_eventually :
  forall (P : infseq T -> Prop) (s : infseq T),
  always (~_ P) s -> ~ eventually P s.

Lemma eventually_not_always :
  forall (P : infseq T -> Prop) (s : infseq T),
    eventually (~_ P) s -> ~ always P s.

Lemma weak_until_always_not_always :
  forall (J P : infseq T -> Prop) (s : infseq T),
  weak_until J P s -> always (~_ P) s -> always J s.

Lemma weak_until_latch_eventually :
  forall (P Q : infseq T -> Prop) ex,
    weak_until (P /\_ ~_ Q) (P /\_ Q) ex ->
    eventually Q ex ->
    eventually (P /\_ Q) ex.

Lemma always_not_eventually_not :
  forall (P : infseq T -> Prop) (s : infseq T),
    always P s -> ~ eventually (~_ P) s.

Lemma continuously_not_inf_often :
  forall (P : infseq T -> Prop) (s : infseq T),
  continuously (~_ P) s -> ~ inf_often P s.

Lemma inf_often_not_continuously :
  forall (P : infseq T -> Prop) (s : infseq T),
  inf_often (~_ P) s -> ~ continuously P s.

Lemma release_not_until : 
  forall (J P : infseq T -> Prop) (s : infseq T),
  release J P s -> ~ until (~_ J) (~_ P) s.

Lemma until_not_release :
  forall (J P : infseq T -> Prop) (s : infseq T),
  until J P s -> ~ release (~_ J) (~_ P) s.

Lemma weak_until_not_until :
  forall (J P : infseq T -> Prop) (s : infseq T),
    weak_until (J /\_ ~_ P) (~_ J /\_ ~_ P) s -> ~ until J P s.

Lemma until_not_weak_until :
  forall (J P : infseq T -> Prop) (s : infseq T),
    until (J /\_ ~_ P) (~_ J /\_ ~_ P) s -> ~ weak_until J P s.

Lemma and_tl_comm : 
  forall (P Q : infseq T -> Prop) (s : infseq T),
  (P /\_ Q) s <-> (Q /\_ P) s.

Lemma and_tl_assoc : 
  forall (P Q R : infseq T -> Prop) (s : infseq T),
  ((P /\_ Q) /\_ R) s <-> (P /\_ Q /\_ R) s.

Lemma or_tl_comm :
  forall (P Q : infseq T -> Prop) (s : infseq T),
  (P \/_ Q) s <-> (Q \/_ P) s.

Lemma or_tl_assoc : 
  forall (P Q R : infseq T -> Prop) (s : infseq T),
  ((P \/_ Q) \/_ R) s <-> (P \/_ Q \/_ R) s.

Lemma not_tl_or_tl : 
  forall (P Q : infseq T -> Prop) (s : infseq T),
  (~_ (P \/_ Q)) s <-> ((~_ P) /\_ (~_ Q)) s.

Lemma not_tl_or_tl_and_tl : 
  forall (P Q : infseq T -> Prop) (s : infseq T),
    ((~_ P) \/_ (~_ Q)) s -> (~_ (P /\_ Q)) s.

End sec_modal_op_lemmas.

Arguments always_inv [T inv] _ [s] _.
Arguments always_Cons [T x s P] _.
Arguments always_now [T x s P] _.
Arguments always_invar [T x s P] _.
Arguments always_tl [T s P] _.
Arguments always_not_false [T s].
Arguments always_true [T s].
Arguments always_and_tl [T P Q s] _ _.
Arguments always_always1 [T P s] _.
Arguments always1_always [T P s] _.
Arguments always_weak_until [T J P s] _.
Arguments always_release [T J P s] _.
Arguments always_inf_often [T P s] _.
Arguments always_continuously [T P s] _.

Arguments weak_until_Cons [T x s J P] _.
Arguments weak_until_always [T J J' P s] _ _.
Arguments until_weak_until [T J P s] _.
Arguments eventually_Cons [T x s P] _.
Arguments eventually_trans [T P Q inv] _ _ [s] _ _.
Arguments not_eventually [T P x s] _ _.
Arguments eventually_next [T s P] _.
Arguments eventually_always_cumul [T s P Q] _ _.
Arguments eventually_weak_until_cumul [T s P J] _ _.
Arguments weak_until_eventually [T P Q J] _ [s] _ _ _.
Arguments until_Cons [T x s J P] _.
Arguments until_eventually [T J P s] _.
Arguments release_Cons [T x s J P] _.
Arguments inf_often_invar [T x s P] _.
Arguments continuously_invar [T x s P] _.
Arguments continuously_and_tl [T P Q s] _ _.
Arguments continuously_inf_often [T P s] _.

Arguments now_monotonic [T P Q] _ [s] _.
Arguments next_monotonic [T P Q] _ [s] _.
Arguments consecutive_monotonic [T P Q] _ [s] _.
Arguments always_monotonic [T P Q] _ [s] _.
Arguments weak_until_monotonic [T P Q J K] _ _ [s] _.
Arguments until_monotonic [T P Q J K] _ _ [s] _.
Arguments release_monotonic [T P Q J K] _ _ [s] _.
Arguments eventually_monotonic [T P Q] _ _ _ [s] _ _.
Arguments eventually_monotonic_simple [T P Q] _ [s] _.
Arguments inf_often_monotonic [T P Q] _ [s] _.
Arguments continuously_monotonic [T P Q] _ [s] _.

Arguments not_eventually_always_not [T P s] _.
Arguments always_not_eventually [T P s] _ _.
Arguments eventually_not_always [T P s] _ _.
Arguments weak_until_always_not_always [T J P s] _ _.
Arguments always_not_eventually_not [T P s] _ _.
Arguments continuously_not_inf_often [T P s] _ _.
Arguments inf_often_not_continuously [T P s] _ _.
Arguments release_not_until [T J P s] _ _.
Arguments until_not_release [T J P s] _ _.
Arguments weak_until_not_until [T J P s] _ _.
Arguments until_not_weak_until [T J P s] _ _.

Arguments and_tl_comm [T P Q s].
Arguments and_tl_assoc [T P Q R s].
Arguments or_tl_comm [T P Q s].
Arguments or_tl_assoc [T P Q R s].
Arguments not_tl_or_tl [T P Q s].
Arguments not_tl_or_tl_and_tl [T P Q s] _ _.

Ltac monotony := 
  match goal with 
     | [ |- now ?P ?s -> now ?Q ?s ] =>
       apply now_monotonic
     | [ |- next ?P ?s -> next ?Q ?s ] =>
       apply next_monotonic
     | [ |- consecutive ?P ?s -> consecutive ?Q ?s ] =>
       apply consecutive_monotonic
     | [ |- always ?P ?s -> always ?Q ?s ] =>
       apply always_monotonic
     | [ |- weak_until ?J ?P ?s -> weak_until ?K ?Q ?s ] =>
       apply weak_until_monotonic
     | [ |- until ?J ?P ?s -> until ?K ?Q ?s ] =>
       apply until_monotonic
     | [ |- release ?J ?P ?s -> release ?K ?Q ?s ] =>
       apply release_monotonic
     | [ |- ?J ?s -> eventually ?P ?s -> eventually ?Q ?s ] =>
       apply eventually_monotonic
     | [ |- continuously ?P ?s -> continuously ?Q ?s ] =>
       apply continuously_monotonic
     | [ |- inf_often ?P ?s -> inf_often ?Q ?s ] =>
       apply inf_often_monotonic
  end. *)

Require Import InfSeqExt.exteq.
(* InfSeqExt.exteq:
Require Import InfSeqExt.infseq.

Section sec_exteq.

Variable T: Type. 

CoInductive exteq : infseq T -> infseq T -> Prop :=
  exteq_intro :
    forall x s1 s2, exteq s1 s2 -> exteq (Cons x s1) (Cons x s2).

Lemma exteq_inversion :
  forall (x1:T) s1 x2 s2, 
  exteq (Cons x1 s1) (Cons x2 s2) -> x1 = x2 /\ exteq s1 s2.

Lemma exteq_refl : forall s, exteq s s. 

Lemma exteq_sym : forall s1 s2, exteq s1 s2 -> exteq s2 s1.

Lemma exteq_trans :
   forall s1 s2 s3, exteq s1 s2 -> exteq s2 s3 -> exteq s1 s3.

End sec_exteq.

Arguments exteq [T] _ _.
Arguments exteq_inversion [T x1 s1 x2 s2] _.
Arguments exteq_refl [T] _.
Arguments exteq_sym [T] _ _ _.
Arguments exteq_trans [T] _ _ _ _ _.

Section sec_exteq_congruence.

Variable T: Type. 

Definition extensional (P: infseq T -> Prop) :=
  forall s1 s2, exteq s1 s2 -> P s1 -> P s2.

Lemma extensional_True_tl :
  extensional True_tl.

Lemma extensional_False_tl :
  extensional False_tl.

Lemma extensional_and_tl :
  forall (P Q: infseq T -> Prop), 
  extensional P -> extensional Q -> extensional (P /\_ Q).

Lemma extensional_or_tl :
  forall (P Q: infseq T -> Prop),
  extensional P -> extensional Q -> extensional (P \/_ Q).

Lemma extensional_impl_tl :
  forall (P Q: infseq T -> Prop),
  extensional P -> extensional Q -> extensional (P ->_ Q).

Lemma extensional_not_tl :
  forall (P: infseq T -> Prop),
  extensional P -> extensional (~_ P).

Lemma extensional_now :
  forall (P: T -> Prop), extensional (now P).

Lemma extensional_next :
  forall (P: infseq T -> Prop), 
  extensional P -> extensional (next P).

Lemma extensional_consecutive :
  forall (P: T -> T -> Prop), extensional (consecutive P).

Lemma extensional_always :
  forall (P: infseq T -> Prop),
  extensional P -> extensional (always P).

Lemma extensional_weak_until :
  forall (P Q: infseq T -> Prop),
  extensional P -> extensional Q -> extensional (weak_until P Q).

Lemma extensional_until :
  forall (P Q: infseq T -> Prop),
  extensional P -> extensional Q -> extensional (until P Q).

Lemma extensional_release :
  forall (P Q: infseq T -> Prop),
  extensional P -> extensional Q -> extensional (release P Q).

Lemma extensional_eventually :
  forall (P: infseq T -> Prop),
  extensional P -> extensional (eventually P).

Lemma extensional_inf_often :
forall (P: infseq T -> Prop),
  extensional P -> extensional (inf_often P).

Lemma extensional_continuously :
forall (P: infseq T -> Prop),
  extensional P -> extensional (continuously P).

End sec_exteq_congruence.

Arguments extensional [T] _.
Arguments extensional_True_tl [T] _ _ _ _.
Arguments extensional_False_tl [T] _ _ _ _.
Arguments extensional_and_tl [T P Q] _ _ _ _ _ _.
Arguments extensional_or_tl [T P Q] _ _ _ _ _ _.
Arguments extensional_impl_tl [T P Q] _ _ _ _ _ _ _.
Arguments extensional_not_tl [T P] _ _ _ _ _ _.
Arguments extensional_now [T P] _ _ _ _.
Arguments extensional_next [T P] _ _ _ _ _.
Arguments extensional_consecutive [T P] _ _ _ _.
Arguments extensional_always [T P] _ _ _ _ _.
Arguments extensional_weak_until [T P Q] _ _ _ _ _ _.
Arguments extensional_until [T P Q] _ _ _ _ _ _.
Arguments extensional_release [T P Q] _ _ _ _ _ _.
Arguments extensional_eventually [T P] _ _ _ _ _.
Arguments extensional_inf_often [T P] _ _ _ _ _.
Arguments extensional_continuously [T P] _ _ _ _ _. *)



Section sec_subseq.



Variable T: Type.



Inductive suff (s : infseq T) : infseq T -> Prop :=

  | sp_eq : suff s s

  | sp_next : forall x s0, suff s s0 -> suff s (Cons x s0).



CoInductive subseq : infseq T -> infseq T -> Prop :=

  | Subseq : forall s s0 s1,

             suff s1 s0 -> subseq s (tl s1) -> subseq (Cons (hd s1) s) s0.



CoInductive subseqs' : infseq (infseq T) -> infseq T -> Prop :=

  | Subseqs' : forall si s0 s1,

             suff s1 s0 -> subseqs' si (tl s1) -> subseqs' (Cons s1 si) s0. 



CoInductive subseqs : infseq (infseq T) -> infseq T -> Prop :=

  | Subseqs : forall si s,

             suff (hd si) s -> subseqs (tl si) (tl (hd si)) -> subseqs si s. 



Lemma subseqs_subseqs' : forall si s, subseqs si s -> subseqs' si s.

Proof using.

cofix subsub. 

intros si s su. case su; clear su si s.

intros (s1, si) s0. simpl. intros su sb. constructor.

- assumption.

- apply subsub. assumption.

Qed.



Lemma subseqs'_subseqs : forall si s, subseqs' si s -> subseqs si s.

cofix subsub.

intros si s su. case su; clear su si s.

intros si s0 s1 su sb. constructor; simpl.

- assumption. 

- apply subsub. assumption. 

Qed.



Lemma subseqs_eventually : 

  forall P si s, subseqs si s -> always1 P si -> eventually P s.

Proof using.

intros P si s su. destruct su as [si s sf _].

induction sf as [ | x s0 _ Hrec]; intro a. 

- constructor 1. case a; simpl. intros; assumption.

- constructor 2. apply Hrec. apply a.

Qed.



Lemma subseqs_tl : forall si s, subseqs si (tl s) -> subseqs si s. 

Proof using.

intros si (x, s) su. simpl in su.

case su. clear su si s; intros si s sf su.

constructor.

- constructor 2. exact sf.

- exact su.

Qed.



Theorem subseq_inf_often :

  forall P si s, subseqs si s -> always1 P si -> inf_often P s.

Proof using.

intros P. red. cofix sio.

intros si s su a.

constructor.

- apply subseqs_eventually with si; assumption.

- genclear a. case su. 

  clear su si s; intros (s0, si) s sf su a; simpl in * |- * . 

  apply (sio si); clear sio.

  * induction sf; simpl.

    trivial. 

    apply subseqs_tl. assumption . 

  * change (always1 P (tl (Cons s0 si))). case a; simpl; trivial. 

Qed.



Inductive ex_suff (P: infseq T -> Prop) (s' : infseq T) : Prop :=

  Esp : forall s, suff s s' -> P s -> ex_suff P s'.



Theorem eventually_suff :

   forall P s', eventually P s' -> ex_suff P s'.

Proof using.

intros P s ev. induction ev.   

- exists s; [ constructor | assumption]. 

- destruct IHev. exists s0. 

  * constructor; assumption.

  * assumption.

Qed.



Inductive suff_exteq (s : infseq T) : infseq T -> Prop :=

  | sb_eq : forall s', exteq s s' -> suff_exteq s s'

  | sb_next : forall x s', suff_exteq s s' -> suff_exteq s (Cons x s').



Inductive suffb (x : T) (s : infseq T) : infseq T -> Prop :=

  | sp_eqb : forall s', exteq (Cons x s) s' -> suffb x s s'

  | sp_nextb : forall y s', suffb x s s' -> suffb x s (Cons y s').



CoInductive subseqb : infseq T -> infseq T -> Prop :=

  | Subseqb : forall x s s', suffb x s s' -> subseqb s s' -> subseqb (Cons x s) s'.



Inductive mem (x : T) : infseq T -> Prop :=

  | mem0 : forall s, mem x (Cons x s)

  | mem_next : forall y s, mem x s -> mem x (Cons y s).



Lemma subseqb_included : forall x s, mem x s -> forall s', subseqb s s' -> mem x s'.

Proof using.

induction 1 as [| y s M IHmem].

- inversion_clear 1 as [a b c ssp _]. induction ssp as [s' ssp | ].

  inversion_clear ssp. constructor.

  constructor. assumption.

- inversion_clear 1. apply IHmem; assumption.

Qed.



End sec_subseq. 

