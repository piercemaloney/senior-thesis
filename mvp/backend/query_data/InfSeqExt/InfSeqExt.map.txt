Require Import InfSeqExt.infseq.
(* InfSeqExt.infseq:
Ltac genclear H := generalize H; clear H.

Ltac clearall :=
   repeat
        match goal with [H : _ |- _ ] => clear H end
     || match goal with [H : _ |- _ ] => genclear H end. 

Section sec_infseq.

Variable T: Type. 

CoInductive infseq : Type := Cons : T -> infseq -> infseq.

Definition hd (s:infseq) : T := match s with Cons x _ => x end.

Definition tl (s:infseq) : infseq := match s with Cons _ s => s end.

Lemma recons : forall s, Cons (hd s) (tl s) = s.

End sec_infseq.

Arguments Cons [T] _ _.
Arguments hd [T] _.
Arguments tl [T] _.
Arguments recons [T] _.

Section sec_modal_op_defn.

Variable T : Type.

Definition now (P: T->Prop) (s: infseq T) : Prop :=
  match s with Cons x s => P x end.

Definition next (P: infseq T -> Prop) (s: infseq T) : Prop :=
  match s with Cons x s => P s end.

Definition consecutive  (R: T -> T -> Prop) (s: infseq T) : Prop :=
  match s with Cons x1 (Cons x2 s) => R x1 x2 end. 

CoInductive always1 (P: T->Prop) : infseq T -> Prop :=
  | Always1 : forall x s, P x -> always1 P s -> always1 P (Cons x s).

CoInductive always (P: infseq T->Prop) : infseq T -> Prop :=
  | Always : forall s, P s -> always P (tl s) -> always P s.

CoInductive weak_until (J P: infseq T->Prop) : infseq T -> Prop :=
  | W0 : forall s, P s -> weak_until J P s
  | W_tl : forall s, J s -> weak_until J P (tl s) -> weak_until J P s.

Inductive until (J P: infseq T->Prop) : infseq T -> Prop :=
  | U0 : forall s, P s -> until J P s
  | U_next : forall x s, J (Cons x s) -> until J P s -> until J P (Cons x s).

CoInductive release (J P: infseq T->Prop) : infseq T -> Prop :=
  | R0 : forall s, P s -> J s -> release J P s
  | R_tl : forall s, P s -> release J P (tl s) -> release J P s.

Inductive eventually (P: infseq T->Prop) : infseq T -> Prop :=
  | E0 : forall s, P s -> eventually P s
  | E_next : forall x s, eventually P s -> eventually P (Cons x s).

Definition inf_often (P: infseq T->Prop) (s: infseq T) : Prop :=
  always (eventually P) s.

Definition continuously (P: infseq T->Prop) (s: infseq T) : Prop :=  
  eventually (always P) s.

Definition impl_tl (P Q: infseq T -> Prop) : infseq T -> Prop :=
  fun s => P s -> Q s. 
Definition and_tl (P Q: infseq T -> Prop) : infseq T -> Prop :=
  fun s => P s /\ Q s. 
Definition or_tl (P Q: infseq T -> Prop) : infseq T -> Prop :=
  fun s => P s \/ Q s. 
Definition not_tl (P : infseq T -> Prop) : infseq T -> Prop := 
  fun s => ~ P s.

Definition True_tl : infseq T -> Prop := fun _ => True.
Definition False_tl : infseq T -> Prop := fun _ => False.

End sec_modal_op_defn.

Hint Unfold True_tl False_tl : core.

Arguments now [T] _ _.
Arguments next [T] _ _.
Arguments consecutive [T] _ _.
Arguments always [T] _ _.
Arguments always1 [T] _ _.
Arguments eventually [T] _ _.
Arguments weak_until [T] _ _ _.
Arguments until [T] _ _ _.
Arguments release [T] _ _ _.
Arguments inf_often [T] _ _.
Arguments continuously [T] _ _.

Arguments impl_tl [T] _ _ _.
Arguments and_tl [T] _ _ _.
Arguments or_tl [T] _ _ _.
Arguments not_tl [T] _ _.

Arguments True_tl {T} _.
Arguments False_tl {T} _.

Notation "A ->_ B" := (impl_tl A B) (right associativity, at level 90).
Notation "A /\_ B" := (and_tl A B) (right associativity, at level 80).
Notation "A \/_ B" := (or_tl A B) (right associativity, at level 85).
Notation "~_ A" := (not_tl A) (right associativity, at level 75).

Section sec_modal_op_lemmas.

Variable T : Type.

Lemma now_hd :
  forall (P : T -> Prop) ex,
    now P ex ->
    P (hd ex).

Lemma always_inv :
  forall (inv: infseq T -> Prop),
    (forall x s, inv (Cons x s) -> inv s) -> forall s, inv s -> always inv s.

Lemma always_Cons :
  forall (x: T) (s: infseq T) P,
  always P (Cons x s) -> P (Cons x s) /\ always P s.

Lemma always_now :
  forall (x: T) (s: infseq T) P, always P (Cons x s) -> P (Cons x s).

Lemma always_now' :
  forall (P : infseq T -> Prop) ex,
    always P ex ->
    P ex.

Lemma always_invar :
  forall (x: T) (s: infseq T) P, always P (Cons x s) -> always P s.

Lemma always_tl :
  forall (s: infseq T) P, always P s -> always P (tl s).

Lemma always_not_false :
  forall s : infseq T, always (~_ False_tl) s.

Lemma always_true :
  forall s : infseq T, always True_tl s.

Lemma always_and_tl :
  forall (P Q : infseq T -> Prop),
    forall s, always P s -> always Q s -> always (P /\_ Q) s.

Lemma always_always :
  forall (P : infseq T -> Prop) s,
    always P s ->
    always (always P) s.

Lemma always_always1 :
   forall P (s: infseq T), always (now P) s -> always1 P s.

Lemma always1_always :
   forall P (s: infseq T), always1 P s -> always (now P) s.

Lemma always_weak_until :
  forall (J P : infseq T -> Prop) (s : infseq T), always J s -> weak_until J P s.

Lemma always_release :
  forall (J P : infseq T -> Prop) (s : infseq T), always P s -> release J P s.

Lemma always_inf_often :
   forall (P: infseq T -> Prop) (s : infseq T), always P s -> inf_often P s.

Lemma always_continuously :
   forall (P: infseq T -> Prop) (s : infseq T), always P s -> continuously P s.

Lemma weak_until_Cons :
  forall (x: T) (s: infseq T) J P,
  weak_until J P (Cons x s) -> P (Cons x s) \/ (J (Cons x s) /\ weak_until J P s).

Lemma weak_until_always :
  forall (J J' P : infseq T -> Prop) s,
    weak_until J P s ->
    always J' s ->
    weak_until (J' /\_ J) P s.

Lemma until_weak_until :
  forall (J P : infseq T -> Prop) (s : infseq T),
  until J P s -> weak_until J P s.

Lemma eventually_Cons :
  forall (x: T) (s: infseq T) P,
  eventually P (Cons x s) -> P (Cons x s) \/ eventually P s.

Lemma eventually_trans :
  forall (P Q inv: infseq T -> Prop),
  (forall x s, inv (Cons x s) -> inv s) ->
  (forall s, inv s -> P s -> eventually Q s) ->
  forall s, inv s -> eventually P s -> eventually Q s.

Lemma not_eventually :
  forall (P : infseq T -> Prop),
  forall x s, ~ eventually P (Cons x s) -> ~ eventually P s.

Lemma eventually_next : 
  forall (s: infseq T) P, eventually (next P) s -> eventually P s. 

Lemma eventually_always_cumul :
  forall (s: infseq T) P Q,
  eventually P s -> always Q s -> eventually (P /\_ always Q) s.

Lemma eventually_weak_until_cumul :
  forall (s: infseq T) P J,
  eventually P s -> weak_until J P s -> eventually (P /\_ weak_until J P) s.

Lemma weak_until_eventually :
  forall (P Q J: infseq T -> Prop),
  (forall s, J s -> P s -> Q s) ->
  forall s, J s -> weak_until J Q s -> eventually P s -> eventually Q s.

Lemma eventually_or_tl_intror :
  forall (P Q : infseq T -> Prop) s,
    eventually Q s ->
    eventually (P \/_ Q) s.

Lemma eventually_or_tl_introl :
  forall (P Q : infseq T -> Prop) s,
    eventually P s ->
    eventually (P \/_ Q) s.

Lemma eventually_or_tl_or :
  forall (P Q : infseq T -> Prop) s,
    eventually (P \/_ Q) s ->
    eventually P s \/ eventually Q s.

Lemma until_Cons :
  forall (x: T) (s: infseq T) J P,
  until J P (Cons x s) -> P (Cons x s) \/ (J (Cons x s) /\ until J P s).

Lemma until_eventually :
  forall (J P : infseq T -> Prop),
  forall s, until J P s -> eventually P s.

Lemma release_Cons :
  forall (x: T) (s: infseq T) J P,
  release J P (Cons x s) -> P (Cons x s) /\ (J (Cons x s) \/ release J P s).

Lemma inf_often_invar :
  forall (x: T) (s: infseq T) P, inf_often P (Cons x s) -> inf_often P s.

Lemma continuously_invar :
  forall (x: T) (s: infseq T) P, continuously P (Cons x s) -> continuously P s.

Lemma continuously_and_tl :
  forall (P Q : infseq T -> Prop) (s : infseq T),
  continuously P s -> continuously Q s -> continuously (P /\_ Q) s.

Lemma continuously_inf_often : 
  forall (P : infseq T -> Prop) (s : infseq T),
    continuously P s -> inf_often P s.

Lemma now_monotonic :
  forall (P Q: T -> Prop), 
  (forall x, P x -> Q x) -> forall s, now P s -> now Q s.

Lemma next_monotonic :
  forall (P Q: infseq T -> Prop),
  (forall s, P s -> Q s) -> forall s, next P s -> next Q s.

Lemma consecutive_monotonic :
  forall (P Q: T -> T -> Prop), 
  (forall x y, P x y -> Q x y) -> forall s, consecutive P s -> consecutive Q s.

Lemma always_monotonic :
  forall (P Q: infseq T -> Prop),
  (forall s, P s -> Q s) -> forall s, always P s -> always Q s.

Lemma weak_until_monotonic :
  forall (P Q J K: infseq T -> Prop),
  (forall s, P s -> Q s) -> (forall s, J s -> K s) ->
  forall s, weak_until J P s -> weak_until K Q s.

Lemma until_monotonic :
  forall (P Q J K: infseq T -> Prop),
  (forall s, P s -> Q s) -> (forall s, J s -> K s) ->
  forall s, until J P s -> until K Q s.

Lemma release_monotonic :
  forall (P Q J K: infseq T -> Prop),
  (forall s, P s -> Q s) -> (forall s, J s -> K s) ->
  forall s, release J P s -> release K Q s.

Lemma eventually_monotonic :
  forall (P Q J: infseq T -> Prop), 
  (forall x s, J (Cons x s) -> J s) ->
  (forall s, J s -> P s -> Q s) -> 
  forall s, J s -> eventually P s -> eventually Q s.

Lemma eventually_monotonic_simple :
  forall (P Q: infseq T -> Prop), 
  (forall s, P s -> Q s) -> 
  forall s, eventually P s -> eventually Q s.

Lemma inf_often_monotonic :
  forall (P Q : infseq T -> Prop),
  (forall s, P s -> Q s) ->
  forall s, inf_often P s -> inf_often Q s.

Lemma cumul_eventually_always :
  forall (P Q : infseq T -> Prop) s,
    always P s ->
    eventually Q s ->
    eventually (P /\_ Q) s.

Lemma cumul_inf_often_always :
  forall (P Q : infseq T -> Prop) s,
    always P s ->
    inf_often Q s ->
    inf_often (P /\_ Q) s.

Lemma inf_often_monotonic_invar :
  forall (invariant P Q : infseq T -> Prop),
    (forall s,
        invariant s ->
        P s ->
        Q s) ->
    forall ex,
      always invariant ex ->
      inf_often P ex ->
      inf_often Q ex.

Lemma continuously_monotonic :
  forall (P Q : infseq T -> Prop),
  (forall s, P s -> Q s) ->
  forall s, continuously P s -> continuously Q s.

Lemma not_eventually_always_not :
  forall (P : infseq T -> Prop) (s : infseq T),
  ~ eventually P s -> always (~_ P) s.

Lemma always_not_eventually :
  forall (P : infseq T -> Prop) (s : infseq T),
  always (~_ P) s -> ~ eventually P s.

Lemma eventually_not_always :
  forall (P : infseq T -> Prop) (s : infseq T),
    eventually (~_ P) s -> ~ always P s.

Lemma weak_until_always_not_always :
  forall (J P : infseq T -> Prop) (s : infseq T),
  weak_until J P s -> always (~_ P) s -> always J s.

Lemma weak_until_latch_eventually :
  forall (P Q : infseq T -> Prop) ex,
    weak_until (P /\_ ~_ Q) (P /\_ Q) ex ->
    eventually Q ex ->
    eventually (P /\_ Q) ex.

Lemma always_not_eventually_not :
  forall (P : infseq T -> Prop) (s : infseq T),
    always P s -> ~ eventually (~_ P) s.

Lemma continuously_not_inf_often :
  forall (P : infseq T -> Prop) (s : infseq T),
  continuously (~_ P) s -> ~ inf_often P s.

Lemma inf_often_not_continuously :
  forall (P : infseq T -> Prop) (s : infseq T),
  inf_often (~_ P) s -> ~ continuously P s.

Lemma release_not_until : 
  forall (J P : infseq T -> Prop) (s : infseq T),
  release J P s -> ~ until (~_ J) (~_ P) s.

Lemma until_not_release :
  forall (J P : infseq T -> Prop) (s : infseq T),
  until J P s -> ~ release (~_ J) (~_ P) s.

Lemma weak_until_not_until :
  forall (J P : infseq T -> Prop) (s : infseq T),
    weak_until (J /\_ ~_ P) (~_ J /\_ ~_ P) s -> ~ until J P s.

Lemma until_not_weak_until :
  forall (J P : infseq T -> Prop) (s : infseq T),
    until (J /\_ ~_ P) (~_ J /\_ ~_ P) s -> ~ weak_until J P s.

Lemma and_tl_comm : 
  forall (P Q : infseq T -> Prop) (s : infseq T),
  (P /\_ Q) s <-> (Q /\_ P) s.

Lemma and_tl_assoc : 
  forall (P Q R : infseq T -> Prop) (s : infseq T),
  ((P /\_ Q) /\_ R) s <-> (P /\_ Q /\_ R) s.

Lemma or_tl_comm :
  forall (P Q : infseq T -> Prop) (s : infseq T),
  (P \/_ Q) s <-> (Q \/_ P) s.

Lemma or_tl_assoc : 
  forall (P Q R : infseq T -> Prop) (s : infseq T),
  ((P \/_ Q) \/_ R) s <-> (P \/_ Q \/_ R) s.

Lemma not_tl_or_tl : 
  forall (P Q : infseq T -> Prop) (s : infseq T),
  (~_ (P \/_ Q)) s <-> ((~_ P) /\_ (~_ Q)) s.

Lemma not_tl_or_tl_and_tl : 
  forall (P Q : infseq T -> Prop) (s : infseq T),
    ((~_ P) \/_ (~_ Q)) s -> (~_ (P /\_ Q)) s.

End sec_modal_op_lemmas.

Arguments always_inv [T inv] _ [s] _.
Arguments always_Cons [T x s P] _.
Arguments always_now [T x s P] _.
Arguments always_invar [T x s P] _.
Arguments always_tl [T s P] _.
Arguments always_not_false [T s].
Arguments always_true [T s].
Arguments always_and_tl [T P Q s] _ _.
Arguments always_always1 [T P s] _.
Arguments always1_always [T P s] _.
Arguments always_weak_until [T J P s] _.
Arguments always_release [T J P s] _.
Arguments always_inf_often [T P s] _.
Arguments always_continuously [T P s] _.

Arguments weak_until_Cons [T x s J P] _.
Arguments weak_until_always [T J J' P s] _ _.
Arguments until_weak_until [T J P s] _.
Arguments eventually_Cons [T x s P] _.
Arguments eventually_trans [T P Q inv] _ _ [s] _ _.
Arguments not_eventually [T P x s] _ _.
Arguments eventually_next [T s P] _.
Arguments eventually_always_cumul [T s P Q] _ _.
Arguments eventually_weak_until_cumul [T s P J] _ _.
Arguments weak_until_eventually [T P Q J] _ [s] _ _ _.
Arguments until_Cons [T x s J P] _.
Arguments until_eventually [T J P s] _.
Arguments release_Cons [T x s J P] _.
Arguments inf_often_invar [T x s P] _.
Arguments continuously_invar [T x s P] _.
Arguments continuously_and_tl [T P Q s] _ _.
Arguments continuously_inf_often [T P s] _.

Arguments now_monotonic [T P Q] _ [s] _.
Arguments next_monotonic [T P Q] _ [s] _.
Arguments consecutive_monotonic [T P Q] _ [s] _.
Arguments always_monotonic [T P Q] _ [s] _.
Arguments weak_until_monotonic [T P Q J K] _ _ [s] _.
Arguments until_monotonic [T P Q J K] _ _ [s] _.
Arguments release_monotonic [T P Q J K] _ _ [s] _.
Arguments eventually_monotonic [T P Q] _ _ _ [s] _ _.
Arguments eventually_monotonic_simple [T P Q] _ [s] _.
Arguments inf_often_monotonic [T P Q] _ [s] _.
Arguments continuously_monotonic [T P Q] _ [s] _.

Arguments not_eventually_always_not [T P s] _.
Arguments always_not_eventually [T P s] _ _.
Arguments eventually_not_always [T P s] _ _.
Arguments weak_until_always_not_always [T J P s] _ _.
Arguments always_not_eventually_not [T P s] _ _.
Arguments continuously_not_inf_often [T P s] _ _.
Arguments inf_often_not_continuously [T P s] _ _.
Arguments release_not_until [T J P s] _ _.
Arguments until_not_release [T J P s] _ _.
Arguments weak_until_not_until [T J P s] _ _.
Arguments until_not_weak_until [T J P s] _ _.

Arguments and_tl_comm [T P Q s].
Arguments and_tl_assoc [T P Q R s].
Arguments or_tl_comm [T P Q s].
Arguments or_tl_assoc [T P Q R s].
Arguments not_tl_or_tl [T P Q s].
Arguments not_tl_or_tl_and_tl [T P Q s] _ _.

Ltac monotony := 
  match goal with 
     | [ |- now ?P ?s -> now ?Q ?s ] =>
       apply now_monotonic
     | [ |- next ?P ?s -> next ?Q ?s ] =>
       apply next_monotonic
     | [ |- consecutive ?P ?s -> consecutive ?Q ?s ] =>
       apply consecutive_monotonic
     | [ |- always ?P ?s -> always ?Q ?s ] =>
       apply always_monotonic
     | [ |- weak_until ?J ?P ?s -> weak_until ?K ?Q ?s ] =>
       apply weak_until_monotonic
     | [ |- until ?J ?P ?s -> until ?K ?Q ?s ] =>
       apply until_monotonic
     | [ |- release ?J ?P ?s -> release ?K ?Q ?s ] =>
       apply release_monotonic
     | [ |- ?J ?s -> eventually ?P ?s -> eventually ?Q ?s ] =>
       apply eventually_monotonic
     | [ |- continuously ?P ?s -> continuously ?Q ?s ] =>
       apply continuously_monotonic
     | [ |- inf_often ?P ?s -> inf_often ?Q ?s ] =>
       apply inf_often_monotonic
  end. *)

Require Import InfSeqExt.exteq.
(* InfSeqExt.exteq:
Require Import InfSeqExt.infseq.

Section sec_exteq.

Variable T: Type. 

CoInductive exteq : infseq T -> infseq T -> Prop :=
  exteq_intro :
    forall x s1 s2, exteq s1 s2 -> exteq (Cons x s1) (Cons x s2).

Lemma exteq_inversion :
  forall (x1:T) s1 x2 s2, 
  exteq (Cons x1 s1) (Cons x2 s2) -> x1 = x2 /\ exteq s1 s2.

Lemma exteq_refl : forall s, exteq s s. 

Lemma exteq_sym : forall s1 s2, exteq s1 s2 -> exteq s2 s1.

Lemma exteq_trans :
   forall s1 s2 s3, exteq s1 s2 -> exteq s2 s3 -> exteq s1 s3.

End sec_exteq.

Arguments exteq [T] _ _.
Arguments exteq_inversion [T x1 s1 x2 s2] _.
Arguments exteq_refl [T] _.
Arguments exteq_sym [T] _ _ _.
Arguments exteq_trans [T] _ _ _ _ _.

Section sec_exteq_congruence.

Variable T: Type. 

Definition extensional (P: infseq T -> Prop) :=
  forall s1 s2, exteq s1 s2 -> P s1 -> P s2.

Lemma extensional_True_tl :
  extensional True_tl.

Lemma extensional_False_tl :
  extensional False_tl.

Lemma extensional_and_tl :
  forall (P Q: infseq T -> Prop), 
  extensional P -> extensional Q -> extensional (P /\_ Q).

Lemma extensional_or_tl :
  forall (P Q: infseq T -> Prop),
  extensional P -> extensional Q -> extensional (P \/_ Q).

Lemma extensional_impl_tl :
  forall (P Q: infseq T -> Prop),
  extensional P -> extensional Q -> extensional (P ->_ Q).

Lemma extensional_not_tl :
  forall (P: infseq T -> Prop),
  extensional P -> extensional (~_ P).

Lemma extensional_now :
  forall (P: T -> Prop), extensional (now P).

Lemma extensional_next :
  forall (P: infseq T -> Prop), 
  extensional P -> extensional (next P).

Lemma extensional_consecutive :
  forall (P: T -> T -> Prop), extensional (consecutive P).

Lemma extensional_always :
  forall (P: infseq T -> Prop),
  extensional P -> extensional (always P).

Lemma extensional_weak_until :
  forall (P Q: infseq T -> Prop),
  extensional P -> extensional Q -> extensional (weak_until P Q).

Lemma extensional_until :
  forall (P Q: infseq T -> Prop),
  extensional P -> extensional Q -> extensional (until P Q).

Lemma extensional_release :
  forall (P Q: infseq T -> Prop),
  extensional P -> extensional Q -> extensional (release P Q).

Lemma extensional_eventually :
  forall (P: infseq T -> Prop),
  extensional P -> extensional (eventually P).

Lemma extensional_inf_often :
forall (P: infseq T -> Prop),
  extensional P -> extensional (inf_often P).

Lemma extensional_continuously :
forall (P: infseq T -> Prop),
  extensional P -> extensional (continuously P).

End sec_exteq_congruence.

Arguments extensional [T] _.
Arguments extensional_True_tl [T] _ _ _ _.
Arguments extensional_False_tl [T] _ _ _ _.
Arguments extensional_and_tl [T P Q] _ _ _ _ _ _.
Arguments extensional_or_tl [T P Q] _ _ _ _ _ _.
Arguments extensional_impl_tl [T P Q] _ _ _ _ _ _ _.
Arguments extensional_not_tl [T P] _ _ _ _ _ _.
Arguments extensional_now [T P] _ _ _ _.
Arguments extensional_next [T P] _ _ _ _ _.
Arguments extensional_consecutive [T P] _ _ _ _.
Arguments extensional_always [T P] _ _ _ _ _.
Arguments extensional_weak_until [T P Q] _ _ _ _ _ _.
Arguments extensional_until [T P Q] _ _ _ _ _ _.
Arguments extensional_release [T P Q] _ _ _ _ _ _.
Arguments extensional_eventually [T P] _ _ _ _ _.
Arguments extensional_inf_often [T P] _ _ _ _ _.
Arguments extensional_continuously [T P] _ _ _ _ _. *)



Section sec_map.



Variable A B: Type.



CoFixpoint map (f: A->B) (s: infseq A): infseq B :=

  match s with

    | Cons x s => Cons (f x) (map f s)

  end.



Lemma map_Cons: forall (f:A->B) x s, map f (Cons x s) = Cons (f x) (map f s).

Proof using.

intros. pattern (map f (Cons x s)). rewrite <- recons. simpl. reflexivity.

Qed.



End sec_map.



Arguments map [A B] _ _.

Arguments map_Cons [A B] _ _ _.



Section sec_zip.



Variable A B: Type.



CoFixpoint zip (sA: infseq A) (sB: infseq B) : infseq (A*B) := 

  match sA, sB with

    | Cons a sA0, Cons b sB0 => Cons (a, b) (zip sA0 sB0)

  end.



Lemma zip_Cons: forall (a:A) (b:B) sA sB, zip (Cons a sA) (Cons b sB) = Cons (a, b) (zip sA sB). 

Proof using.

intros. pattern (zip (Cons a sA) (Cons b sB)); rewrite <- recons. simpl. reflexivity. 

Qed.



End sec_zip.



Arguments zip [A B] _ _.

Arguments zip_Cons [A B] _ _ _ _.



Section sec_map_modalop.



Variable A B: Type.



Lemma and_tl_map :

   forall (f: A->B) (P P': infseq A->Prop) (Q Q': infseq B->Prop),

   (forall s, P s -> Q (map f s)) ->

   (forall s, P' s -> Q' (map f s)) ->

   forall (s: infseq A),

   (P /\_ P') s -> (Q /\_ Q') (map f s).

Proof using.

unfold and_tl; intuition. 

Qed.



Lemma and_tl_map_conv :

   forall (f: A->B) (P P': infseq A->Prop) (Q Q': infseq B->Prop),

   (forall s, Q (map f s) -> P s) ->

   (forall s, Q' (map f s) -> P' s) ->

   forall (s: infseq A),

   (Q /\_ Q') (map f s) -> (P /\_ P') s.

Proof using.

unfold and_tl; intuition. 

Qed.



Lemma or_tl_map :

   forall (f: A->B) (P P': infseq A->Prop) (Q Q': infseq B->Prop),

   (forall s, P s -> Q (map f s)) ->

   (forall s, P' s -> Q' (map f s)) ->

   forall (s: infseq A),

   (P \/_ P') s -> (Q \/_ Q') (map f s).

Proof using.

unfold or_tl; intuition. 

Qed.



Lemma or_tl_map_conv :

   forall (f: A->B) (P P': infseq A->Prop) (Q Q': infseq B->Prop),

   (forall s, Q (map f s) -> P s) ->

   (forall s, Q' (map f s) -> P' s) ->

   forall (s: infseq A),

   (Q \/_ Q') (map f s) -> (P \/_ P') s.

Proof using.

unfold or_tl; intuition. 

Qed.



Lemma impl_tl_map :

   forall (f: A->B) (P P': infseq A->Prop) (Q Q': infseq B->Prop),

   (forall s, Q (map f s) -> P s) ->

   (forall s, P' s -> Q' (map f s)) ->

   forall (s: infseq A),

   (P ->_ P') s -> (Q ->_ Q') (map f s).

Proof using.

unfold impl_tl; intuition. 

Qed.



Lemma impl_tl_map_conv :

   forall (f: A->B) (P P': infseq A->Prop) (Q Q': infseq B->Prop),

   (forall s, P s -> Q (map f s)) ->

   (forall s, Q' (map f s) -> P' s) ->

   forall (s: infseq A),

   (Q ->_ Q') (map f s) -> (P ->_ P') s.

Proof using.

unfold impl_tl; intuition. 

Qed.



Lemma not_tl_map :

   forall (f: A->B) (P : infseq A->Prop) (Q: infseq B->Prop),

   (forall s, Q (map f s) -> P s) ->

   forall (s: infseq A), (~_ P) s -> (~_ Q) (map f s).

Proof using.

unfold not_tl; intuition. 

Qed.



Lemma not_tl_map_conv :

   forall (f: A->B) (P: infseq A->Prop) (Q: infseq B->Prop),

   (forall s, P s -> Q (map f s)) ->

   forall (s: infseq A), (~_ Q) (map f s) -> (~_ P) s.

Proof using.

unfold not_tl; intuition. 

Qed.



Lemma now_map :

   forall (f: A->B) (P: B->Prop) (s: infseq A),

   now (fun x => P (f x)) s -> now P (map f s).

Proof using.

intros f P (x, s) nP; assumption. 

Qed.



Lemma now_map_conv :

   forall (f: A->B) (P: B->Prop) (s: infseq A),

   now P (map f s) -> now (fun x => P (f x)) s.

Proof using.

intros f P (x, s) nP; assumption. 

Qed.



Lemma next_map :

   forall (f: A->B) (P: infseq A->Prop) (Q: infseq B->Prop),

   (forall s, P s -> Q (map f s)) ->

   forall (s: infseq A), next P s -> next Q (map f s).

Proof using.

intros f P Q PQ [x s]; apply PQ.

Qed.



Lemma next_map_conv :

   forall (f: A->B) (P: infseq A->Prop) (Q: infseq B->Prop),

   (forall s, Q (map f s) -> P s) ->

   forall (s: infseq A), next Q (map f s) -> next P s.

Proof using.

intros f P Q QP [x s]; apply QP.

Qed.



Lemma consecutive_map :

   forall (f: A->B) (P: B->B->Prop) (s: infseq A),

   consecutive (fun x y => P (f x) (f y)) s -> consecutive P (map f s).

Proof using.

intros f P (x, (y, s)) nP; assumption. 

Qed.



Lemma consecutive_map_conv :

   forall (f: A->B) (P: B->B->Prop) (s: infseq A),

   consecutive P (map f s) -> consecutive (fun x y => P (f x) (f y)) s.

Proof using.

intros f P (x, (y, s)) nP; assumption. 

Qed.



Lemma always_map :

   forall (f: A->B) (P: infseq A->Prop) (Q: infseq B->Prop),

   (forall s, P s -> Q (map f s)) ->

   forall (s: infseq A), always P s -> always Q (map f s).

Proof using.

intros f P Q PQ. cofix cf.

intros (x, s) a. case (always_Cons a); intros a1 a2. constructor.

- apply PQ. assumption.

- rewrite map_Cons; simpl. apply cf; assumption.

Qed.



Lemma always_map_conv_ext :

  forall (f: A->B) (P: infseq A->Prop) (Q: infseq B->Prop) (J : infseq A -> Prop),

    (forall x s, J (Cons x s) -> J s) ->

    (forall s, J s -> Q (map f s) -> P s) ->

    forall s, J s -> always Q (map f s) -> always P s.

Proof using.

intros f J P Q inv JQP. cofix c.

intros [x s] Js a.

rewrite map_Cons in a. case (always_Cons a); intros a1 a2. constructor.

- apply JQP. assumption.

  rewrite map_Cons; assumption.

- simpl. apply c.

  * apply (inv x). assumption.

  * assumption.

Qed.



Lemma always_map_conv :

   forall (f: A->B) (P: infseq A->Prop) (Q: infseq B->Prop),

   (forall s, Q (map f s) -> P s) ->

   forall (s: infseq A), always Q (map f s) -> always P s.

Proof using.

intros f P Q QP s.

apply (always_map_conv_ext f P Q True_tl); auto.

Qed.



Lemma weak_until_map :

   forall (f: A->B) (J P: infseq A->Prop) (K Q: infseq B->Prop),

   (forall s, J s -> K (map f s)) ->

   (forall s, P s -> Q (map f s)) ->

   forall (s: infseq A),

   weak_until J P s -> weak_until K Q (map f s).

Proof using.

intros f J P K Q JK PQ. cofix cf.

intros (x, s) un. case (weak_until_Cons un); clear un.

- intro Pxs; constructor 1. apply PQ. assumption.

- intros (Jxs, un). rewrite map_Cons. constructor 2.

  * rewrite <- map_Cons. auto.

  * simpl. auto.

Qed.



Lemma weak_until_map_conv :

   forall (f: A->B) (J P: infseq A->Prop) (K Q: infseq B->Prop),

   (forall s, K (map f s) -> J s) ->

   (forall s, Q (map f s) -> P s) ->

   forall (s: infseq A),

   weak_until K Q (map f s) -> weak_until J P s.

Proof using.

intros f J P K Q KJ QP. cofix cf.

intros (x, s) un.

rewrite map_Cons in un; case (weak_until_Cons un); clear un; rewrite <- map_Cons.

- intro Qxs; constructor 1. apply QP. assumption.

- intros (Kxs, un). constructor 2; simpl; auto.

Qed.



Lemma until_map :

   forall (f: A->B) (J P: infseq A->Prop) (K Q: infseq B->Prop),

   (forall s, J s -> K (map f s)) ->

   (forall s, P s -> Q (map f s)) ->

   forall (s: infseq A),

   until J P s -> until K Q (map f s).

Proof using.

intros f J P K Q JK PQ s un.

induction un.

- apply U0, PQ. assumption.

- rewrite map_Cons.

  apply U_next.

  * rewrite <- map_Cons.

    apply JK.

    assumption.

  * assumption.

Qed.



Lemma release_map :

   forall (f: A->B) (J P: infseq A->Prop) (K Q: infseq B->Prop),

   (forall s, J s -> K (map f s)) ->

   (forall s, P s -> Q (map f s)) ->

   forall (s: infseq A),

   release J P s -> release K Q (map f s).

Proof using.

intros f J P K Q JK PQ. cofix cf.

intros (x, s) rl. case (release_Cons rl); clear rl.

intros Pxs orR.

case orR; intro cR.

- apply R0.

  * apply PQ. assumption.

  * apply JK. assumption.

- apply R_tl.

  * apply PQ. assumption.

  * apply cf. assumption.

Qed.



Lemma release_map_conv :

   forall (f: A->B) (J P: infseq A->Prop) (K Q: infseq B->Prop),

   (forall s, K (map f s) -> J s) ->

   (forall s, Q (map f s) -> P s) ->

   forall (s: infseq A),

   release K Q (map f s) -> release J P s.

Proof using.

intros f J P K Q KJ QP. cofix cf.

intros (x, s) rl.

rewrite map_Cons in rl; case (release_Cons rl); clear rl; rewrite <- map_Cons; intros QC orR; case orR; intro cR.

- apply R0.

  * apply QP. assumption.

  * apply KJ. assumption.

- apply R_tl.

  * apply QP. assumption.

  * apply cf. assumption.

Qed.



Lemma eventually_map :

   forall (f: A->B) (P: infseq A->Prop) (Q: infseq B->Prop),

   (forall s, P s -> Q (map f s)) ->

   forall s, eventually P s -> eventually Q (map f s).

Proof using.

intros f P Q PQ s e. induction e as [s ok | x s e induc_hyp].

- destruct s as (x, s); simpl in *. rewrite map_Cons. constructor 1.

  rewrite <- map_Cons. apply PQ. exact ok.

- rewrite map_Cons. constructor 2. exact induc_hyp.

Qed.



Definition fstAB := fst (A:=A) (B:=B).



Lemma exteq_fst_zip:

  forall sA sB, exteq (map fstAB (zip sA sB)) sA.

Proof using.

cofix cf. intros (a, sA) (b, sB). 

rewrite zip_Cons. rewrite map_Cons. constructor. apply cf.

Qed.



Lemma exteq_zip_map :

   forall (f: A->B) (sA: infseq A) (sB: infseq B),

   always (now (fun c: A*B => let (x, y) := c in y = f x)) (zip sA sB) ->

   exteq sB (map f (map fstAB (zip sA (map f sA)))).

Proof using. 

intros f. cofix cf. 

intros (a, sA) (b, sB).

repeat rewrite map_Cons; repeat rewrite zip_Cons; repeat rewrite map_Cons; simpl. 

intro al; case (always_Cons al); clear al; simpl. intros e al. case e. constructor. 

apply cf. exact al. 

Qed.



Lemma eventually_map_conv_aux :

   forall (f: A->B) (Q: infseq B->Prop), extensional Q ->

   forall (s: infseq A) (sB: infseq B),

   always (now (fun c: A*B => let (x, y) := c in y = f x)) (zip s sB) ->

   eventually Q sB ->

   eventually (fun sc => Q (map f (map fstAB sc))) (zip s (map f s)).

Proof using.

intros f Q extQ s sB al ev. genclear al; genclear s.

induction ev as [(b, sB) QbsB | b sB ev induc_hyp].

- intros (a, sA) al.

  constructor 1. apply extQ with (Cons b sB); try assumption.

  apply exteq_zip_map. apply al.

- intros (a, sA). repeat rewrite map_Cons. repeat rewrite zip_Cons.

  intro al. case (always_Cons al); simpl. clear al; intros e al. 

  constructor 2. apply induc_hyp. exact al. 

Qed.



Lemma eventually_map_conv_ext :

   forall (f: A->B) (P: infseq A->Prop) (Q: infseq B->Prop) (J : infseq A -> Prop),

   extensional P -> extensional Q -> extensional J ->

   (forall x s, J (Cons x s) -> J s) ->

   (forall s, J s -> Q (map f s) -> eventually P s) ->

   forall s, J s -> eventually Q (map f s) -> eventually P s.

Proof using.

intros f P Q J extP extQ extJ inv QP s Js ev.

revert Js.

assert (efst: J (map fstAB (zip s (map f s))) -> eventually P (map fstAB (zip s (map f s)))).

- assert (evzip : eventually (fun sc => Q (map f (map fstAB sc))) (zip s (map f s))).

  * clear extP QP P.

     assert (alzip : (always (now (fun c : A * B => let (x, y) := c in y = f x)) (zip s (map f s)))).

     + clear ev extQ. generalize s. cofix cf. intros (x, s0). constructor.

       -- simpl. reflexivity.

       -- simpl. apply cf.

     + apply (eventually_map_conv_aux f Q extQ s (map f s) alzip ev).

  * clear ev. induction evzip as [((a, b), sAB) QabsAB | c sAB _ induc_hyp].

    + intros Js.

      apply QP; assumption.

    + intros Js.

      rewrite map_Cons.

      apply E_next.

      apply induc_hyp.

      rewrite map_Cons in Js.

      apply (inv (fstAB c)).

      assumption.

- intros Js.

  assert (emJ: J (map fstAB (zip s (map f s)))).

  * unfold extensional in extJ.

    apply (extJ s).

    + apply exteq_sym. apply exteq_fst_zip.

    + assumption.

  * apply efst in emJ.

    genclear emJ.

    apply extensional_eventually.

    + exact extP.

    + apply exteq_fst_zip.

Qed.



Lemma eventually_map_conv :

   forall (f: A->B) (P: infseq A->Prop) (Q: infseq B->Prop),

   extensional P -> extensional Q ->

   (forall s, Q (map f s) -> P s) ->

   forall s, eventually Q (map f s) -> eventually P s.

Proof using.

intros f P Q extP extQ QP s.

apply eventually_map_conv_ext with (J := True_tl); auto.

- apply extensional_True_tl.

- intros. apply E0. apply QP. assumption.

Qed.



Lemma eventually_map_monotonic :

   forall (f: A->B) (P Q J: infseq A->Prop) (K : infseq B -> Prop),

   (forall x s, J (Cons x s) -> J s) ->

   (forall x s, K (map f (Cons x s)) -> K (map f s)) ->

   (forall s, J s -> K (map f s) -> Q s -> P s) ->

   forall s, J s -> K (map f s) -> eventually Q s -> eventually P s.

Proof using.

intros f P Q J K Jinv Kinv JKQP s invJ invK ev.

induction ev as [s Qs | x s ev IHev].

- apply E0.

  apply JKQP; assumption.

- apply E_next.

  apply IHev.

  * apply (Jinv x); assumption.

  * apply (Kinv x); assumption.

Qed.



Lemma inf_often_map :

   forall (f: A->B) (P: infseq A->Prop) (Q: infseq B->Prop),

   (forall s, P s -> Q (map f s)) ->

   forall (s: infseq A), inf_often P s -> inf_often Q (map f s).

Proof using.

intros f P Q PQ.

apply always_map; apply eventually_map; assumption.

Qed.



Lemma inf_often_map_conv :

   forall (f: A->B) (P: infseq A->Prop) (Q: infseq B->Prop),

   extensional P -> extensional Q -> 

   (forall s, Q (map f s) -> P s) ->

   forall (s: infseq A), inf_often Q (map f s) -> inf_often P s.

Proof using.

intros f P Q eP eQ QP.

apply always_map_conv; apply eventually_map_conv; trivial.

Qed.



Lemma continuously_map :

   forall (f: A->B) (P: infseq A->Prop) (Q: infseq B->Prop),

   (forall s, P s -> Q (map f s)) ->

   forall (s: infseq A), continuously P s -> continuously Q (map f s).

Proof using.

intros f P Q PQ.

apply eventually_map; apply always_map; assumption.

Qed.



Lemma continuously_map_conv :

   forall (f: A->B) (P: infseq A->Prop) (Q: infseq B->Prop),

   extensional P -> extensional Q -> 

   (forall s, Q (map f s) -> P s) ->

   forall (s: infseq A), continuously Q (map f s) -> continuously P s.

Proof using.

intros f P Q eP eQ QP.

apply eventually_map_conv.

- apply extensional_always; assumption.

- apply extensional_always; assumption.

- apply always_map_conv; assumption.

Qed.



Lemma eventually_now_map :

   forall (f: A->B) (P: B->Prop) (s: infseq A),

   eventually (now (fun x => P (f x))) s -> eventually (now P) (map f s).

Proof using.

intros f P. apply eventually_map. apply now_map.

Qed.



Lemma eventually_now_map_conv :

   forall (f: A->B) (P: B->Prop) (s: infseq A),

   eventually (now P) (map f s) -> eventually (now (fun x => P (f x))) s.

Proof using.

intros f P s. apply eventually_map_conv.

- apply extensional_now. 

- apply extensional_now. 

- clear s. intros (x, s). repeat rewrite map_Cons. simpl. trivial.

Qed.



Lemma eventually_map_now_eq :

  forall (f: A -> B) a s, eventually (now (eq a)) s -> 

  eventually (now (eq (f a))) (map f s).

Proof using.

intros f a. apply eventually_map.

intros s noa. apply now_map.

genclear noa. monotony. apply f_equal.

Qed.



End sec_map_modalop. 



Arguments and_tl_map [A B f P P' Q Q'] _ _ [s] _.

Arguments and_tl_map_conv [A B f P P' Q Q'] _ _ [s] _.

Arguments or_tl_map [A B f P P' Q Q'] _ _ [s] _.

Arguments or_tl_map_conv [A B f P P' Q Q'] _ _ [s] _.

Arguments impl_tl_map [A B f P P' Q Q'] _ _ [s] _ _.

Arguments impl_tl_map_conv [A B f P P' Q Q'] _ _ [s] _ _.

Arguments not_tl_map [A B f P Q] _ [s] _ _.

Arguments not_tl_map_conv [A B f P Q] _ [s] _ _.

Arguments now_map [A B f P s] _.

Arguments now_map_conv [A B f P s] _.

Arguments next_map [A B f P Q] _ [s] _.

Arguments next_map_conv [A B f P Q] _ [s] _.

Arguments consecutive_map [A B f P s] _.

Arguments consecutive_map_conv [A B f P s] _.

Arguments always_map [A B f P Q] _ [s] _.

Arguments always_map_conv_ext [A B f P Q J] _ _ [s] _ _.

Arguments always_map_conv [A B f P Q] _ [s] _.

Arguments weak_until_map [A B f J P K Q] _ _ [s] _.

Arguments weak_until_map_conv [A B f J P K Q] _ _ [s] _.

Arguments until_map [A B f J P K Q] _ _ [s] _.

Arguments release_map [A B f J P K Q] _ _ [s] _.

Arguments release_map_conv [A B f J P K Q] _ _ [s] _.

Arguments eventually_map [A B f P Q] _ [s] _.

Arguments eventually_map_conv_ext [A B f P Q J] _ _ _ _ _ [s] _ _.

Arguments eventually_map_conv [A B f P Q] _ _ _ [s] _.

Arguments eventually_map_monotonic [A B f P Q] _ _ _ _ _ [s] _ _ _.

Arguments inf_often_map [A B f P Q] _ [s] _.

Arguments inf_often_map_conv [A B f P Q] _ _ _ [s] _.

Arguments continuously_map [A B f P Q] _ [s] _.

Arguments continuously_map_conv [A B f P Q] _ _ _ [s] _.

Arguments eventually_now_map [A B f P s] _.

Arguments eventually_now_map_conv [A B f P s] _.

Arguments eventually_map_now_eq [A B f a s] _.

