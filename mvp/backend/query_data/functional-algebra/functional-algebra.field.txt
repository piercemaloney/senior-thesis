

Require Import Eqdep.

Require Import Description.



Require Import base.
(* base:
Notation "A || B @ X 'by' E"
  := (eq_ind_r (fun X => B) A E) (at level 40, left associativity).

Notation "A || B @ X 'by' <- H"
  := (eq_ind_r (fun X => B) A (eq_sym H)) (at level 40, left associativity).

Notation "A =:= B"
  := (eq_refl A : A = B) (at level 90).

Definition bool_dec0
  :  forall b : bool, {b = true}+{b = false}
  := bool_rect
      (fun b => {b = true}+{b = false})
         (left (true = false) (eq_refl true))
         (right (false = true) (eq_refl false)). *)

Require Import function.
(* function:
Definition is_injective (A B : Type) (f : A -> B) : Prop
  := forall x y : A, f x = f y -> x = y.

Definition is_onto (A B : Type) (f : A -> B) : Prop
  := forall y : B, exists x : A, f x = y.

Definition is_bijective (A B : Type) (f : A -> B) : Prop
  := is_injective A B f /\ is_onto A B f. *)

Require Import monoid.
(* monoid:
Require Import Description.
Require Import base.
Require Import function.
Require Import ProofIrrelevance.
Require Import Bool.

Require Import Arith.
Require Import Wf.
Require Import Wellfounded.
Require Import Wf_nat.

Module Monoid.

Definition is_assoc (T : Type) (f : T -> T -> T) : Prop := forall x y z : T, f x (f y z) = f (f x y) z.

Definition is_id_l (T : Type) (f : T -> T -> T) (E : T) : Prop := forall x : T, f E x = x.

Definition is_id_r (T : Type) (f : T -> T -> T) (E : T) : Prop := forall x : T, f x E = x.

Definition is_id (T : Type) (f : T -> T -> T) (E : T) : Prop := is_id_l T f E /\ is_id_r T f E.

Definition is_inv_l (T : Type) (f : T -> T -> T) (E : T) (_ : is_id T f E) (x y : T) : Prop := f y x = E.

Definition is_inv_r (T : Type) (f : T -> T -> T) (E : T) (_ : is_id T f E) (x y : T) : Prop := f x y = E.

Definition is_inv (T : Type) (f : T -> T -> T) (E : T) (H : is_id T f E) (x y : T) : Prop := is_inv_l T f E H x y /\ is_inv_r T f E H x y.

Structure Monoid : Type := monoid {

  E: Set;

  E_0: E;

  op: E -> E -> E;

  op_is_assoc : is_assoc E op;

  op_id_l : is_id_l E op E_0;

  op_id_r : is_id_r E op E_0
}.

Arguments E_0 {m}.

Arguments op {m} x y.

Arguments op_is_assoc {m} x y z.

Arguments op_id_l {m} x.

Arguments op_id_r {m} x.

Notation "0" := E_0 : monoid_scope.

Notation "x + y" := (op x y) (at level 50, left associativity) : monoid_scope.

Notation "{+}" := op : monoid_scope.

Open Scope monoid_scope.

Section Theorems.

Variable m : Monoid.

Let M := E m.

Definition op_is_id_l := is_id_l M {+}.

Definition op_is_id_r := is_id_r M {+}.

Definition op_is_id := is_id M {+}.

Theorem op_id
  :  is_id M {+} 0.
Proof conj op_id_l op_id_r.

Theorem op_id_l_uniq
  :  forall x : M, (op_is_id_l x) -> x = 0.
Proof
  fun x H
    => H 0 || a = 0 @a by <- op_id_r x.

Theorem op_id_r_uniq
  :  forall x : M, (op_is_id_r x) -> x = 0.
Proof
  fun x H
    => H 0 || a = 0 @a by <- op_id_l x.

Theorem op_id_uniq
  :  forall x : M, (op_is_id x) -> x = 0.
Proof
  fun x
    => and_ind (fun H _ => op_id_l_uniq x H).

Theorem op_intro_l
  :  forall x y z : M, x = y -> z + x = z + y.
Proof
  fun x y z H
    => f_equal ({+} z) H.

Theorem op_intro_r
  :  forall x y z : M, x = y -> x + z = y + z.
Proof
  fun x y z H
    =>  eq_refl (x + z)
       || x + z = a + z @a by <- H.

Definition op_is_inv_l := is_inv_l M {+} 0 op_id.

Definition op_is_inv_r := is_inv_r M {+} 0 op_id.

Definition op_is_inv := is_inv M {+} 0 op_id.

Definition has_inv_l
  := fun x => exists y : M, op_is_inv_l x y.

Definition has_inv_r
  := fun x => exists y : M, op_is_inv_r x y.

Definition has_inv
  := fun x => exists y : M, op_is_inv x y.

Theorem op_inv_l_r_eq
  :  forall x y : M, op_is_inv_l x y -> forall z : M, op_is_inv_r x z -> y = z.
Proof
  fun x y H1 z H2
    => op_is_assoc y x z
          || y + a = (y + x) + z @a by <- H2
          || a = (y + x) + z     @a by <- op_id_r y
          || y = a + z           @a by <- H1
          || y = a               @a by <- op_id_l z.

Theorem op_inv_sym
  :  forall x y : M, op_is_inv x y <-> op_is_inv y x.
Proof
  fun x y
    => conj
            (fun H : op_is_inv x y
              => conj (proj2 H) (proj1 H))
            (fun H : op_is_inv y x
              => conj (proj2 H) (proj1 H)).

Theorem op_cancel_l
  :  forall x y z : M, has_inv_l z -> z + x = z + y -> x = y.
Proof
  fun x y z H H0
    => ex_ind 
            (fun u H1
              => op_intro_l (z + x) (z + y) u H0
              || a = u + (z + y) @a by <- op_is_assoc u z x
              || (u + z) + x = a @a by <- op_is_assoc u z y
              || a + x = a + y   @a by <- H1
              || a = 0 + y       @a by <- op_id_l x
              || x = a           @a by <- op_id_l y)
            H.

Theorem op_cancel_r
  :  forall x y z : M, has_inv_r z -> x + z = y + z -> x = y.
Proof
  fun x y z H H0
    => ex_ind
            (fun u H1
              =>  op_intro_r (x + z) (y + z) u H0
              || a = (y + z) + u @a by op_is_assoc x z u
              || x + (z + u) = a @a by op_is_assoc y z u
              || x + a = y + a   @a by <- H1
              || a = y + 0       @a by <- op_id_r x
              || x = a           @a by <- op_id_r y)
            H.

Theorem op_inv_l_uniq
  :  forall x : M, has_inv_r x -> forall y z : M, op_is_inv_l x y -> op_is_inv_l x z -> z = y.
Proof
  fun x H y z H0 H1
    => let H2
            :  z + x = y + x
            := H1 || z + x = a @a by H0 in
          let H3
            :  z = y
            := op_cancel_r z y x H H2 in
          H3.

Theorem op_inv_r_uniq
  :  forall x : M, has_inv_l x -> forall y z : M, op_is_inv_r x y -> op_is_inv_r x z -> z = y.
Proof
  fun x H y z H0 H1
    => let H2
            :  x + z = x + y
            := H1 || x + z = a @a by H0 in
          let H3
            :  z = y
            := op_cancel_l z y x H H2 in
          H3.

Theorem op_inv_uniq
  :  forall x y z : M, op_is_inv x y -> op_is_inv x z -> z = y.
Proof
  fun x y z H H0
    => op_inv_l_uniq x
            (ex_intro (fun y => op_is_inv_r x y) y (proj2 H))
            y z (proj1 H) (proj1 H0).

Theorem op_inv_0_l
  :  op_is_inv_l 0 0.
Proof op_id_l 0 : 0 + 0 = 0.

Theorem op_inv_0_r
  :  op_is_inv_r 0 0.
Proof op_id_r 0 : 0 + 0 = 0.

Theorem op_inv_0
  :  op_is_inv 0 0.
Proof conj op_inv_0_l op_inv_0_r.

Theorem op_has_inv_l_0
  :  has_inv_l 0.
Proof ex_intro (op_is_inv_l 0) 0 op_inv_0_l.

Theorem op_has_inv_r_0
  :  has_inv_r 0.
Proof ex_intro (op_is_inv_r 0) 0 op_inv_0_r.

Theorem op_has_inv_0
  :  has_inv 0.
Proof ex_intro (op_is_inv 0) 0 op_inv_0.

Theorem op_inv_0_eq_0
  :  forall x : M, op_is_inv x 0 -> x = 0.
Proof
  fun x H
    => proj1 H
       || a = 0 @a by <- op_id_l x.

Theorem op_inv_0_uniq
  :  unique (fun x => op_is_inv x 0) 0.
Proof
  conj op_inv_0
    (fun x H => eq_sym (op_inv_0_eq_0 x H)).

Definition op_neg_strong
  :  forall x : M, has_inv x -> { y | op_is_inv x y }
  := fun x H
       => constructive_definite_description (op_is_inv x) 
            (ex_ind
              (fun y (H0 : op_is_inv x y)
                => ex_intro
                     (fun y => op_is_inv x y /\ forall z, op_is_inv x z -> y = z)
                     y
                     (conj H0 (fun z H1 => eq_sym (op_inv_uniq x y z H0 H1))))
              H).

Definition op_neg
  :  forall x : M, has_inv x -> M
  := fun x H => proj1_sig (op_neg_strong x H).

Notation "{-}" := (op_neg) : monoid_scope.

Theorem op_neg_def
  :  forall (x : M) (H : has_inv x), op_is_inv x ({-} x H).
Proof
  fun x H
    => proj2_sig (op_neg_strong x H).

Theorem op_neg_inv
  :  forall (x : M) (H : has_inv x), op_is_inv ({-} x H) x.
Proof
  fun x H
    => (proj1 (op_inv_sym x ({-} x H))) (op_neg_def x H).

Theorem op_neg_inv_ex
  :  forall (x : M) (H : has_inv x), has_inv ({-} x H).
Proof
  fun x H
    => ex_intro
         (op_is_inv ({-} x H))
         x
         (op_neg_inv x H).

Theorem op_neg_inj
  :  forall (x : M) (H : has_inv x) (y : M) (H0 : has_inv y),
     {-} x H = {-} y H0 ->
     x = y.
Proof
  fun x H y H0 H1
    => let H2
         :  x + ({-} x H) = y + ({-} x H) 
         := (proj2 (op_neg_def x H) : x + ({-} x H) = 0)
            || x + ({-} x H) = a     @a by proj2 (op_neg_def y H0)
            || x + ({-} x H) = y + a @a by H1 in
       let H3
         :  x = y
         := op_cancel_r x y ({-} x H)
            (ex_intro
              (op_is_inv_r ({-} x H))
              x
              (proj2 (proj1 (op_inv_sym x ({-} x H)) (op_neg_def x H))))
            H2 in
       H3.

Theorem op_cancel_neg_gen
  :  forall (x : M) (H : has_inv x) (H0 : has_inv ({-} x H)), {-} ({-} x H) H0 = x.
Proof
  fun x H H0
    => let H1
         :  op_is_inv ({-} x H) ({-} ({-} x H) H0)
         := op_neg_def ({-} x H) H0 in
       let H3
         :  op_is_inv ({-} x H) x
         := op_neg_inv x H in
       op_inv_uniq ({-} x H) x ({-} ({-} x H) H0) H3 H1.

Theorem op_cancel_neg
  :  forall (x : M) (H : has_inv x), {-} ({-} x H) (op_neg_inv_ex x H) = x.
Proof
  fun x H
    => op_cancel_neg_gen x H (op_neg_inv_ex x H).

Theorem op_neg_onto
  :  forall (y : M) (H : has_inv y), exists (x : M) (H0 : has_inv x), {-} x H0 = y.
Proof
  fun y H
    => ex_intro
            (fun x => exists H0 : has_inv x, {-} x H0 = y)
            ({-} y H)
            (ex_intro
              (fun H0 => {-} ({-} y H) H0 = y)
              (op_neg_inv_ex y H)
              (op_cancel_neg y H)).

Theorem op_inv_closed
  :  forall (x : M) (H : has_inv x) (y : M) (H0 : has_inv y), has_inv (x + y).
Proof
  fun x H y H0
    => ex_ind
         (fun u (H1 : op_is_inv x u)
           => ex_ind
                (fun v (H2 : op_is_inv y v)
                  => ex_intro
                       (op_is_inv (x + y))
                       (v + u)
                       (conj
                         (op_is_assoc (v + u) x y
                           || (v + u) + (x + y) = a + y @a by op_is_assoc v u x
                           || (v + u) + (x + y) = (v + a) + y @a by <- proj1 H1
                           || (v + u) + (x + y) = a + y @a by <- op_id_r v
                           || (v + u) + (x + y) = a @a by <- proj1 H2
                         ) 
                         (op_is_assoc (x + y) v u
                           || (x + y) + (v + u) = a + u @a by op_is_assoc x y v
                           || (x + y) + (v + u) = (x + a) + u @a by <- proj2 H2
                           || (x + y) + (v + u) = a + u @a by <- op_id_r x
                           || (x + y) + (v + u) = a @a by <- proj2 H1
                         )))
                H0)
         H.

End Theorems.

End Monoid.

Notation "0" := (Monoid.E_0) : monoid_scope.

Notation "x + y" := (Monoid.op x y) (at level 50, left associativity) : monoid_scope.

Notation "{+}" := (Monoid.op) : monoid_scope.

Notation "{-}" := (Monoid.op_neg _) : monoid_scope. *)

Require Import monoid_group.
(* monoid_group:
Require Import base.
Require Import monoid.
Require Import group.
Require Import Eqdep.

Module Monoid_Group.

Structure Monoid_Group : Type := monoid_group {

  E : Set;

  E_0 : E;

  monoid_op: E -> E -> E;

  monoid_op_is_assoc : Monoid.is_assoc E monoid_op;

  monoid_op_is_id_l := Monoid.is_id_l E monoid_op;

  monoid_op_is_id_r := Monoid.is_id_r E monoid_op;

  monoid_op_is_id := Monoid.is_id E monoid_op;

  monoid_op_id_l : Monoid.is_id_l E monoid_op E_0;

  monoid_op_id_r : Monoid.is_id_r E monoid_op E_0;

  m := Monoid.monoid E E_0 monoid_op monoid_op_is_assoc monoid_op_id_l monoid_op_id_r;

  D : Set
    := { x : E | Monoid.has_inv m x };

  D_cons
    :  forall x : E, Monoid.has_inv m x -> D
    := exist (Monoid.has_inv m);

  D_eq_dep
    : forall (x : E) (H : Monoid.has_inv m x) (y : E) (H0 : Monoid.has_inv m y), y = x -> eq_dep E (Monoid.has_inv m) y H0 x H;

  D_eq
    :  forall (x : E) (H : Monoid.has_inv m x) (y : E) (H0 : Monoid.has_inv m y), y = x -> D_cons y H0 = D_cons x H
    := fun x H y H0 H1
         => eq_dep_ind E (Monoid.has_inv m) y H0
              (fun (z : E) (H2 : Monoid.has_inv m z)
                => D_cons y H0 = D_cons z H2)
              (eq_refl (D_cons y H0)) x H (D_eq_dep x H y H0 H1);

  D_0 := D_cons E_0 (Monoid.op_has_inv_0 m);

  group_op
    :  D -> D -> D
    := sig_rec
         (fun _ => D -> D)
         (fun (u : E) (H : Monoid.has_inv m u)
           => sig_rec
                (fun _ => D)
                (fun (v : E) (H0 : Monoid.has_inv m v)
                  => D_cons
                       (monoid_op u v)
                       (Monoid.op_inv_closed m u H v H0)));

  group_op_is_id_l := Monoid.is_id_l D group_op;

  group_op_is_id_r := Monoid.is_id_r D group_op;

  group_op_is_id := Monoid.is_id D group_op;

  group_op_id_l
    :  group_op_is_id_l D_0
    := sig_ind
         (fun x => group_op D_0 x = x)
         (fun (u : E) (H : Monoid.has_inv m u)
            => D_eq u H (monoid_op E_0 u) (Monoid.op_inv_closed m E_0 (Monoid.op_has_inv_0 m) u H)
                 (monoid_op_id_l u));

  group_op_id_r
    :  group_op_is_id_r D_0
    := sig_ind
         (fun x => group_op x D_0 = x)
         (fun (u : E) (H : Monoid.has_inv m u)
            => D_eq u H (monoid_op u E_0) (Monoid.op_inv_closed m u H E_0 (Monoid.op_has_inv_0 m))
                 (monoid_op_id_r u));

  group_op_id
    :  group_op_is_id D_0
    := conj group_op_id_l group_op_id_r;

  group_op_assoc
    :  Monoid.is_assoc D group_op
    := sig_ind
         (fun x => forall y z : D, group_op x (group_op y z) = group_op (group_op x y) z)
         (fun (u : E) (H : Monoid.has_inv m u)
           => sig_ind
                (fun y => forall z : D, group_op (D_cons u H) (group_op y z) = group_op (group_op (D_cons u H) y) z)
                (fun (v : E) (H0 : Monoid.has_inv m v)
                  => sig_ind
                       (fun z => group_op (D_cons u H) (group_op (D_cons v H0) z) = group_op (group_op (D_cons u H) (D_cons v H0)) z)
                       (fun (w : E) (H1 : Monoid.has_inv m w)
                         => let a
                              :  E
                              := monoid_op u (monoid_op v w) in
                            let H2
                              :  Monoid.has_inv m a
                              := Monoid.op_inv_closed m u H (monoid_op v w) (Monoid.op_inv_closed m v H0 w H1) in
                            let b
                              :  E
                              := monoid_op (monoid_op u v) w in
                            let H3
                              :  Monoid.has_inv m b
                              := Monoid.op_inv_closed m (monoid_op u v) (Monoid.op_inv_closed m u H v H0) w H1 in
                            let X
                              :  D
                              := D_cons a H2 in
                            let Y
                              :  D
                              := D_cons b H3 in
                            D_eq b H3 a H2
                              (monoid_op_is_assoc u v w)
                )));

  group_op_is_inv_l := Monoid.is_inv_l D group_op D_0 group_op_id;

  group_op_is_inv_r := Monoid.is_inv_r D group_op D_0 group_op_id;

  group_op_is_inv := Monoid.is_inv D group_op D_0 group_op_id;

  group_op_inv_l
    :  forall (u : E) (H : Monoid.has_inv m u) (v : E) (H0 : Monoid.has_inv m v),
         Monoid.op_is_inv_l m u v ->
         group_op_is_inv_l (D_cons u H) (D_cons v H0)
    := fun (u : E) (H : Monoid.has_inv m u) (v : E) (H0 : Monoid.has_inv m v)
         => D_eq E_0 (Monoid.op_has_inv_0 m) (monoid_op v u) (Monoid.op_inv_closed m v H0 u H);
        
  group_op_inv_r
    :  forall (u : E) (H : Monoid.has_inv m u) (v : E) (H0 : Monoid.has_inv m v),
         Monoid.op_is_inv_r m u v ->
         group_op_is_inv_r (D_cons u H) (D_cons v H0)
    := fun (u : E) (H : Monoid.has_inv m u) (v : E) (H0 : Monoid.has_inv m v)
         => D_eq E_0 (Monoid.op_has_inv_0 m) (monoid_op u v) (Monoid.op_inv_closed m u H v H0);

  group_op_inv
    :  forall (u : E) (H : Monoid.has_inv m u) (v : E) (H0 : Monoid.has_inv m v),
         Monoid.op_is_inv m u v ->
         group_op_is_inv (D_cons u H) (D_cons v H0)
    := fun (u : E) (H : Monoid.has_inv m u) (v : E) (H0 : Monoid.has_inv m v) (H1 : Monoid.op_is_inv m u v)
         => conj (group_op_inv_l u H v H0 (proj1 H1))
                 (group_op_inv_r u H v H0 (proj2 H1));

  group_op_neg_strong
    :  forall x : D, { y : D | group_op_is_inv x y }
    := sig_rec
         (fun x => { y : D | group_op_is_inv x y })
         (fun (u : E) (H : Monoid.has_inv m u)
           => let v
                :  E
                := Monoid.op_neg m u H in
              let H0
                :  Monoid.op_is_inv m u v
                := Monoid.op_neg_def m u H in
              let H1
                :  Monoid.has_inv m v
                := Monoid.op_neg_inv_ex m u H in
              exist
                (fun y : D => group_op_is_inv (D_cons u H) y)
                (D_cons v H1)
                (group_op_inv u H v H1 H0));

  group_op_inv_ex 
    :  forall x : D, exists y : D, group_op_is_inv x y
    := fun x
         => let (y, H) := group_op_neg_strong x in
            ex_intro
              (fun y => group_op_is_inv x y)
              y H;

  group_op_inv_l_ex
    :  forall x : D, exists y : D, group_op_is_inv_l x y
    := fun x
         => ex_ind
              (fun y (H : group_op_is_inv x y)
                => ex_intro (fun z => group_op_is_inv_l x z) y (proj1 H))
              (group_op_inv_ex x);

  group_op_inv_r_ex
    :  forall x : D, exists y : D, group_op_is_inv_r x y
    := fun x
         => ex_ind
              (fun y (H : group_op_is_inv x y)
                => ex_intro (fun z => group_op_is_inv_r x z) y (proj2 H))
              (group_op_inv_ex x);

  g := Group.group D D_0 group_op group_op_assoc
    group_op_id_l group_op_id_r group_op_inv_l_ex
    group_op_inv_r_ex
}.

End Monoid_Group. *)

Require Import group.

Require Import abelian_group.
(* abelian_group:
Require Import Description.
Require Import base.
Require Import function.
Require Import monoid.
Require Import group.

Module Abelian_Group.

Definition is_comm (T : Type) (f : T -> T -> T)
  :  Prop
  := forall x y : T, f x y = f y x.

Structure Abelian_Group : Type := abelian_group {

  E : Set;

  E_0 : E;

  op : E -> E -> E;

  op_is_assoc : Monoid.is_assoc E op;

  op_is_comm : is_comm E op;

  op_id_l : Monoid.is_id_l E op E_0;

  op_inv_l_ex : forall x : E, exists y : E, op y x = E_0
}.

Arguments E_0 {a}.

Arguments op {a} x y.

Arguments op_is_assoc {a} x y z.

Arguments op_is_comm {a} x y.

Arguments op_id_l {a} x.

Arguments op_inv_l_ex {a} x.

Notation "0" := E_0 : abelian_group_scope.

Notation "x + y" := (op x y) (at level 50, left associativity) : abelian_group_scope.

Notation "{+}" := op : abelian_group_scope.

Open Scope abelian_group_scope.

Section Theorems.

Variable g : Abelian_Group.

Let E := E g.

Definition op_is_id_l := Monoid.is_id_l E {+}.

Definition op_is_id_r := Monoid.is_id_r E {+}.

Definition op_is_id := Monoid.is_id E {+}.

Theorem op_is_id_lr
  :  forall x : E, op_is_id_l x -> op_is_id_r x.
Proof
  fun x H y
    => H y
    || a = y @a by op_is_comm y x.

Theorem op_is_id_lid
  : forall x : E, op_is_id_l x -> op_is_id x.
Proof
  fun x H
    => conj H (op_is_id_lr x H).

Theorem op_id_r
  :  op_is_id_r 0.
Proof op_is_id_lr 0 op_id_l.

Theorem op_id
  :  op_is_id 0.
Proof conj op_id_l op_id_r.

Definition op_is_inv_l := Monoid.is_inv_l E {+} 0 op_id.

Definition op_is_inv_r := Monoid.is_inv_r E {+} 0 op_id.

Definition op_is_inv := Monoid.is_inv E {+} 0 op_id.

Theorem op_inv_r_ex
  :  forall x : E, exists y : E, op_is_inv_r x y.
Proof
  fun x
    => ex_ind
         (fun (y : E) (H : op_is_inv_l x y)
           => ex_intro
                (op_is_inv_r x)
                y
                (H || a = 0 @a by op_is_comm x y))
         (op_inv_l_ex x).

Definition op_group := Group.group E 0 {+} op_is_assoc op_id_l op_id_r op_inv_l_ex op_inv_r_ex.

Definition op_monoid := Group.op_monoid op_group.

Definition has_inv_l := Group.has_inv_l op_group.

Definition has_inv_r := Group.has_inv_r op_group.

Definition has_inv := Group.has_inv op_group.

Theorem op_id_l_uniq
  :  forall x : E, Monoid.is_id_l E {+} x -> x = 0.
Proof Group.op_id_l_uniq op_group.

Theorem op_id_r_uniq
  :  forall x : E, Monoid.is_id_r E {+} x -> x = 0.
Proof Group.op_id_r_uniq op_group.

Theorem op_id_uniq
  :  forall x : E, Monoid.is_id E {+} x -> x = 0.
Proof Group.op_id_uniq op_group.

Theorem op_inv_l_r_eq
  :  forall x y : E, op_is_inv_l x y -> forall z : E, op_is_inv_r x z -> y = z.
Proof Group.op_inv_l_r_eq op_group.

Theorem op_inv_sym
  :  forall x y : E, op_is_inv x y <-> op_is_inv y x.
Proof Group.op_inv_sym op_group.

Theorem op_inv_ex
  :  forall x : E, exists y : E, op_is_inv x y.
Proof Group.op_inv_ex op_group.

Theorem op_intro_l
  :  forall x y z : E, x = y -> z + x = z + y.
Proof Group.op_intro_l op_group.

Theorem op_intro_r
  :  forall x y z : E, x = y -> x + z = y + z.
Proof Group.op_intro_r op_group.

Theorem op_cancel_l
  :   forall x y z : E, z + x = z + y -> x = y.
Proof Group.op_cancel_l op_group.

Theorem op_cancel_r
  :   forall x y z : E, x + z = y + z -> x = y.
Proof Group.op_cancel_r op_group.

Theorem op_inv_l_uniq
  :  forall x y z : E, op_is_inv_l x y -> op_is_inv_l x z -> z = y.
Proof Group.op_inv_l_uniq op_group.

Theorem op_inv_r_uniq
  :  forall x y z : E, op_is_inv_r x y -> op_is_inv_r x z -> z = y.
Proof Group.op_inv_r_uniq op_group.

Theorem op_inv_uniq
  :  forall x y z : E, op_is_inv x y -> op_is_inv x z -> z = y.
Proof Group.op_inv_uniq op_group.

Theorem op_inv_uniq_ex
  :  forall x : E, exists! y : E, op_is_inv x y.
Proof Group.op_inv_uniq_ex op_group.

Theorem op_inv_0_l
  :  op_is_inv_l 0 0.
Proof Group.op_inv_0_l op_group.

Theorem op_inv_0_r
  :  op_is_inv_r 0 0.
Proof Group.op_inv_0_r op_group.

Theorem op_inv_0
  :  op_is_inv 0 0.
Proof Group.op_inv_0 op_group.

Theorem op_has_inv_l_0
  :  has_inv_l 0.
Proof Group.op_has_inv_l_0 op_group.

Theorem op_has_inv_r_0
  :  has_inv_r 0.
Proof Group.op_has_inv_r_0 op_group.

Theorem op_has_inv_0
  :  has_inv 0.
Proof Group.op_has_inv_0 op_group.

Theorem op_inv_0_eq_0
  :  forall x : E, op_is_inv x 0 -> x = 0.
Proof Group.op_inv_0_eq_0 op_group.

Theorem op_inv_0_uniq
  :  unique (fun x => op_is_inv x 0) 0.
Proof Group.op_inv_0_uniq op_group.
 
Definition op_neg_strong
  :  forall x : E, { y | op_is_inv x y }
  := Group.op_neg_strong op_group.

Definition op_neg
  :  E -> E
  := Group.op_neg op_group.

Close Scope nat_scope.

Notation "{-}" := (op_neg) : abelian_group_scope.

Notation "- x" := (op_neg x) : abelian_group_scope.

Theorem op_neg_def
  :  forall x : E, op_is_inv x (- x).
Proof Group.op_neg_def op_group.

Theorem op_neg_inj
  :  is_injective E E op_neg.
Proof Group.op_neg_inj op_group.

Theorem op_cancel_neg
  :  forall x : E, op_neg (- x) = x.
Proof Group.op_cancel_neg op_group.

Theorem op_neg_onto
  :  is_onto E E op_neg.
Proof Group.op_neg_onto op_group.

Theorem op_neg_bijective
  :  is_bijective E E op_neg.
Proof Group.op_neg_bijective op_group.

Theorem op_neg_rev
  :  forall x y : E, - x = y -> - y = x.
Proof Group.op_neg_rev op_group.

Theorem op_neg_distrib_inv_l
  :  forall x y : E, op_is_inv_l (x + y) (- y + - x).
Proof Group.op_neg_distrib_inv_l op_group.

Theorem op_neg_distrib_inv_r
  :  forall x y : E, op_is_inv_r (x + y) (- y + - x).
Proof Group.op_neg_distrib_inv_r op_group.

Theorem op_neg_distrib_inv
  :  forall x y : E, op_is_inv (x + y) (- y + - x).
Proof Group.op_neg_distrib_inv op_group.

Theorem op_neg_distrib
  :  forall x y : E, - (x + y) = - y + - x.
Proof Group.op_neg_distrib op_group.

End Theorems.

End Abelian_Group.

Notation "0" := (Abelian_Group.E_0) : abelian_group_scope.

Notation "x + y" := (Abelian_Group.op x y) (at level 50, left associativity) : abelian_group_scope.

Notation "{+}" := (Abelian_Group.op) : abelian_group_scope.

Notation "{-}" := (Abelian_Group.op_neg _) : abelian_group_scope.

Notation "- x" := (Abelian_Group.op_neg _ x) : abelian_group_scope. *)

Require Import ring.

Require Import commutative_ring.
(* commutative_ring:
Require Import Description.
Require Import FunctionalExtensionality.
Require Import base.
Require Import function.
Require Import monoid.
Require Import group.
Require Import abelian_group.
Require Import ring.

Module Commutative_Ring.

Structure Commutative_Ring : Type := commutative_ring {

  E : Set;

  E_0 : E;

  E_1 : E;

  sum : E -> E -> E;

  prod : E -> E -> E;

  distinct_0_1: E_0 <> E_1;

  sum_is_assoc : Monoid.is_assoc E sum;

  sum_is_comm : Abelian_Group.is_comm E sum;

  sum_id_l : Monoid.is_id_l E sum E_0;

  sum_inv_l_ex : forall x : E, exists y : E, sum y x = E_0;

  prod_is_assoc : Monoid.is_assoc E prod;

  prod_is_comm : Abelian_Group.is_comm E prod;

   prod_id_l : Monoid.is_id_l E prod E_1;

  prod_sum_distrib_l : Ring.is_distrib_l E prod sum
}.
 
Arguments E_0 {c}.

Arguments E_1 {c}.

Arguments sum {c} x y.

Arguments prod {c} x y.

Arguments distinct_0_1 {c} _.

Arguments sum_is_assoc {c} x y z.

Arguments sum_is_comm {c} x y.

Arguments sum_id_l {c} x.

Arguments sum_inv_l_ex {c} x.

Arguments prod_is_assoc {c} x y z.

Arguments prod_id_l {c} x.

Arguments prod_sum_distrib_l {c} x y z.

Arguments prod_is_comm {c} x y.

Notation "0" := E_0 : commutative_ring_scope.

Notation "1" := E_1 : commutative_ring_scope.

Notation "x + y" := (sum x y) (at level 50, left associativity) : commutative_ring_scope.

Notation "{+}" := sum : commutative_ring_scope.

Notation "x # y" := (prod x y) (at level 50, left associativity) : commutative_ring_scope.

Notation "{#}" := prod : commutative_ring_scope.

Open Scope commutative_ring_scope.

Section Theorems.

Variable r : Commutative_Ring.

Let E := E r.

Definition sum_is_id_l := Monoid.is_id_l E {+}.

Definition sum_is_id_r := Monoid.is_id_r E {+}.

Definition sum_is_id := Monoid.is_id E {+}.

Definition prod_is_id_l := Monoid.is_id_l E {#}.

Definition prod_is_id_r := Monoid.is_id_r E {#}.

Definition prod_is_id := Monoid.is_id E {#}.

Theorem prod_id_r
  :  prod_is_id_r 1.
Proof
  fun x : E
    => eq_ind_r
         (fun a => a = x)
         (prod_id_l x)
         (prod_is_comm x 1).
 
Theorem prod_sum_distrib_r
  :  Ring.is_distrib_r E {#} {+}.
Proof
  fun x y z : E
    =>  prod_sum_distrib_l x y z
        || x # (y + z) = a + (x # z) @a by <- prod_is_comm x y
        || x # (y + z) = (y # x) + a @a by <- prod_is_comm x z
        || a = (y # x) + (z # x)     @a by <- prod_is_comm x (y + z).

Definition ring := Ring.ring E 0 1 {+} {#} distinct_0_1 sum_is_assoc sum_is_comm sum_id_l sum_inv_l_ex prod_is_assoc prod_id_l prod_id_r prod_sum_distrib_l prod_sum_distrib_r.

Definition sum_abelian_group := Ring.sum_abelian_group ring.

Definition sum_group := Ring.sum_group ring.

Definition sum_monoid := Ring.sum_monoid ring.

Definition prod_monoid := Ring.prod_monoid ring.

Theorem distinct_1_0
  :  E_1 (c := r) <> E_0 (c := r).
Proof
  fun H : E_1 = E_0
    => distinct_0_1 (eq_sym H).  

Definition nonzero
  : E -> Prop
  := Ring.nonzero ring.

Theorem sum_id_r
  :  sum_is_id_r 0.
Proof Ring.sum_id_r ring.

Theorem sum_id
  :  sum_is_id 0.
Proof Ring.sum_id ring.

Definition sum_is_inv_l
  := Ring.sum_is_inv_l ring.

Definition sum_is_inv_r
  := Ring.sum_is_inv_r ring.

Definition sum_is_inv
  := Ring.sum_is_inv ring.

Definition sum_has_inv_l := Ring.sum_has_inv_l ring.

Definition sum_has_inv_r := Ring.sum_has_inv_r ring.

Definition sum_has_inv := Ring.sum_has_inv ring.

Theorem sum_inv_r_ex
  :  forall x : E, exists y : E, sum_is_inv_r x y.
Proof Ring.sum_inv_r_ex ring.

Theorem sum_id_l_uniq
  :  forall x : E, Monoid.is_id_l E {+} x -> x = 0.
Proof Ring.sum_id_l_uniq ring.

Theorem sum_id_r_uniq
  :  forall x : E, Monoid.is_id_r E {+} x -> x = 0.
Proof Ring.sum_id_r_uniq ring.

Theorem sum_id_uniq
  :  forall x : E, Monoid.is_id E {+} x -> x = 0.
Proof Ring.sum_id_uniq ring.

Theorem sum_inv_l_r_eq
  :  forall x y : E, sum_is_inv_l x y -> forall z : E, sum_is_inv_r x z -> y = z.
Proof Ring.sum_inv_l_r_eq ring.

Theorem sum_inv_sym
  :  forall x y : E, sum_is_inv x y <-> sum_is_inv y x.
Proof Ring.sum_inv_sym ring.

Theorem sum_inv_uniq
  :  forall x y z :  E, sum_is_inv x y -> sum_is_inv x z -> z = y.
Proof Ring.sum_inv_uniq ring.

Theorem sum_inv_ex
  :  forall x : E, exists y : E, sum_is_inv x y.
Proof Ring.sum_inv_ex ring.

Theorem sum_inv_uniq_ex
  :  forall x : E, exists! y : E, sum_is_inv x y.
Proof Ring.sum_inv_uniq_ex ring.

Theorem sum_intro_l
  :  forall x y z : E, x = y -> z + x = z + y.
Proof Ring.sum_intro_l ring.

Theorem sum_intro_r
  :  forall x y z : E, x = y -> x + z = y + z.
Proof Ring.sum_intro_r ring.

Theorem sum_cancel_l
  :   forall x y z : E, z + x = z + y -> x = y.
Proof Ring.sum_cancel_l ring.

Theorem sum_cancel_r
  :   forall x y z : E, x + z = y + z -> x = y.
Proof Ring.sum_cancel_r ring.

Theorem sum_inv_l_uniq
  :  forall x y z : E, sum_is_inv_l x y -> sum_is_inv_l x z -> z = y.
Proof Ring.sum_inv_l_uniq ring.

Theorem sum_inv_r_uniq
  :  forall x y z : E, sum_is_inv_r x y -> sum_is_inv_r x z -> z = y.
Proof Ring.sum_inv_r_uniq ring.

Theorem sum_0_inv_l
  :  sum_is_inv_l 0 0.
Proof Ring.sum_0_inv_l ring.

Theorem sum_0_inv_r
  :  sum_is_inv_r 0 0.
Proof Ring.sum_0_inv_r ring.

Theorem sum_0_inv
  :  sum_is_inv 0 0.
Proof Ring.sum_0_inv ring.

Theorem sum_has_inv_l_0
  :  sum_has_inv_l 0.
Proof Ring.sum_has_inv_l_0 ring.

Theorem sum_has_inv_r_0
  :  sum_has_inv_r 0.
Proof Ring.sum_has_inv_r_0 ring.

Theorem sum_has_inv_0
  :  sum_has_inv 0.
Proof Ring.sum_has_inv_0 ring.

Theorem sum_inv_0_eq_0
  :  forall x : E, sum_is_inv x 0 -> x = 0.
Proof Ring.sum_inv_0_eq_0 ring.

Theorem sum_inv_0_uniq
  :  unique (fun x => sum_is_inv x 0) 0.
Proof Ring.sum_inv_0_uniq ring.

Definition sum_neg_strong
  :  forall x : E, { y | sum_is_inv x y }
  := Ring.sum_neg_strong ring.

Definition sum_neg 
  :  E -> E
  := Ring.sum_neg ring.

Notation "{-}" := (sum_neg) : commutative_ring_scope.

Notation "- x" := (sum_neg x) : commutative_ring_scope.

Definition sum_neg_def 
  :  forall x : E, sum_is_inv x (- x)
  := Ring.sum_neg_def ring.

Theorem sum_neg_inj
  :  is_injective E E sum_neg.
Proof Ring.sum_neg_inj ring.

Theorem sum_cancel_neg
  :  forall x : E, sum_neg (- x) = x.
Proof Ring.sum_cancel_neg ring.

Theorem sum_neg_onto
  :  is_onto E E sum_neg.
Proof Ring.sum_neg_onto ring.

Theorem sum_neg_bijective
  :  is_bijective E E sum_neg.
Proof Ring.sum_neg_bijective ring.

Theorem sum_neg_rev
  :  forall x y : E, - x = y -> - y = x.
Proof Ring.sum_neg_rev ring.

Theorem sum_neg_distrib_inv_l
  :  forall x y : E, sum_is_inv_l (x + y) (- y + - x).
Proof Ring.sum_neg_distrib_inv_l ring.

Theorem sum_neg_distrib_inv_r
  :  forall x y : E, sum_is_inv_r (x + y) (- y + - x).
Proof Ring.sum_neg_distrib_inv_r ring.

Theorem sum_neg_distrib_inv
  :  forall x y : E, sum_is_inv (x + y) (- y + - x).
Proof Ring.sum_neg_distrib_inv ring.

Theorem sum_neg_distrib
  :  forall x y : E, - (x + y) = - y + - x.
Proof Ring.sum_neg_distrib ring.

Theorem sum_0_neg
  :  - 0 = 0.
Proof Ring.sum_0_neg ring.

Theorem sum_neg_0
  :  forall x : E, - x = 0 -> x = 0.
Proof Ring.sum_neg_0 ring.

Theorem sum_neg_0_uniq
  :  unique (fun x => - x = 0) 0.
Proof Ring.sum_neg_0_uniq ring.

Theorem prod_id
  :  prod_is_id 1.
Proof Ring.prod_id ring.

Theorem prod_id_l_uniq
  :  forall x : E, (Monoid.is_id_l E {#} x) -> x = 1.
Proof Ring.prod_id_l_uniq ring.

Theorem prod_id_r_uniq
  :  forall x : E, (Monoid.is_id_r E {#} x) -> x = 1.
Proof Ring.prod_id_r_uniq ring.

Theorem prod_id_uniq
  :  forall x : E, (Monoid.is_id E {#} x) -> x = 1.
Proof Ring.prod_id_uniq ring.

Theorem prod_intro_l
  :  forall x y z : E, x = y -> z # x = z # y.
Proof Ring.prod_intro_l ring.

Theorem prod_intro_r
  :  forall x y z : E, x = y -> x # z = y # z.
Proof Ring.prod_intro_r ring.

Definition prod_is_inv_l := Ring.prod_is_inv_l ring.

Definition prod_is_inv_r := Ring.prod_is_inv_r ring.

Definition prod_is_inv := Ring.prod_is_inv ring.

Definition prod_has_inv_l := Ring.prod_has_inv_l ring.

Definition prod_has_inv_r := Ring.prod_has_inv_r ring.

Definition prod_has_inv := Ring.prod_has_inv ring.

Theorem prod_is_inv_lr 
  :  forall x y : E, prod_is_inv_l x y -> prod_is_inv_r x y.
Proof
  fun x y H
    => H || a = 1 @a by prod_is_comm x y.

Theorem prod_inv_l_r_eq
  :  forall x y : E, prod_is_inv_l x y -> forall z : E, prod_is_inv_r x z -> y = z.
Proof Ring.prod_inv_l_r_eq ring.

Theorem prod_inv_sym
  :  forall x y : E, prod_is_inv x y <-> prod_is_inv y x.
Proof Ring.prod_inv_sym ring.

Theorem prod_cancel_l
  :  forall x y z : E, prod_has_inv_l z -> z # x = z # y -> x = y.
Proof Ring.prod_cancel_l ring.

Theorem prod_cancel_r
  :  forall x y z : E, prod_has_inv_r z -> x # z = y # z -> x = y.
Proof Ring.prod_cancel_r ring.

Theorem prod_inv_l_uniq
  :  forall x : E, prod_has_inv_r x -> forall y z : E, prod_is_inv_l x y -> prod_is_inv_l x z -> z = y.
Proof Ring.prod_inv_l_uniq ring.

Theorem prod_inv_r_uniq
  :  forall x : E, prod_has_inv_l x -> forall y z : E, prod_is_inv_r x y -> prod_is_inv_r x z -> z = y.
Proof Ring.prod_inv_r_uniq ring.

Definition prod_inv_uniq
  :  forall x y z : E, prod_is_inv x y -> prod_is_inv x z -> z = y
  := Ring.prod_inv_uniq ring.

Theorem prod_inv_1_l
  :  prod_is_inv_l 1 1.
Proof Ring.prod_inv_1_l ring.

Theorem prod_inv_1_r
  :  prod_is_inv_r 1 1.
Proof Ring.prod_inv_1_l ring.

Theorem prod_inv_1
  :  prod_is_inv 1 1.
Proof Ring.prod_inv_1 ring.

Theorem prod_has_inv_l_1
  :  prod_has_inv_l 1.
Proof Ring.prod_has_inv_l_1 ring.

Theorem prod_has_inv_r_1
  :  prod_has_inv_r 1.
Proof Ring.prod_has_inv_r_1 ring.

Theorem prod_has_inv_1
  :  prod_has_inv 1.
Proof Ring.prod_has_inv_1 ring.

Theorem prod_inv_1_eq_1
  :  forall x : E, prod_is_inv x 1 -> x = 1.
Proof Ring.prod_inv_1_eq_1 ring.

Theorem prod_inv_1_uniq
  :  unique (fun x => prod_is_inv x 1) 1.
Proof Ring.prod_inv_1_uniq ring.

Theorem recipr_1_l
  :  prod_is_inv_l 1 1.
Proof Ring.recipr_1_l ring.

Theorem recipr_1_r
  :  prod_is_inv_r 1 1.
Proof Ring.recipr_1_r ring.

Theorem recipr_1
  :  prod_is_inv 1 1.
Proof Ring.recipr_1 ring.

Theorem prod_sum_distrib
  :  Ring.is_distrib E {#} {+}.
Proof Ring.prod_sum_distrib ring.

Theorem prod_0_l
  :  forall x : E, 0 # x = 0.
Proof Ring.prod_0_l ring.

Theorem prod_0_r
  :  forall x : E, x # 0 = 0.
Proof Ring.prod_0_r ring.

Theorem prod_0_inv_l
  :  ~ prod_has_inv_l 0.
Proof Ring.prod_0_inv_l ring.

Theorem prod_0_inv_r
  :  ~ prod_has_inv_r 0.
Proof Ring.prod_0_inv_r ring.

Theorem prod_0_inv
  :  ~ prod_has_inv 0.
Proof Ring.prod_0_inv ring.

Theorem prod_inv_0
  :  forall x y : E, prod_is_inv x y -> nonzero y.
Proof Ring.prod_inv_0 ring.

Definition E_n1_strong
  :  { x : E | sum_is_inv 1 x }
  := Ring.E_n1_strong ring.

Definition E_n1 : E := Ring.E_n1 ring.

Notation "{-1}" := E_n1 : commutative_ring_scope.

Definition E_n1_def
  :  sum_is_inv 1 {-1}
  := Ring.E_n1_def ring.
      
Theorem E_n1_inv_l
  :  sum_is_inv_l 1 {-1}.
Proof Ring.E_n1_inv_l ring.

Theorem E_n1_inv_r
  :  sum_is_inv_r 1 {-1}.
Proof Ring.E_n1_inv_r ring.

Theorem E_n1_uniq
  :  forall x : E, sum_is_inv 1 x -> x = {-1}.
Proof Ring.E_n1_uniq ring.

Theorem prod_n1_x_inv_l
  :  forall x : E, sum_is_inv_l x ({-1} # x).
Proof Ring.prod_n1_x_inv_l ring.

Theorem prod_x_n1_inv_l
  :  forall x : E, sum_is_inv_l x (x # {-1}).
Proof Ring.prod_x_n1_inv_l ring.

Theorem prod_n1_x_inv_r
  :  forall x : E, sum_is_inv_r x ({-1} # x).
Proof Ring.prod_n1_x_inv_r ring.

Theorem prod_x_n1_inv_r
  :  forall x : E, sum_is_inv_r x (x # {-1}).
Proof Ring.prod_x_n1_inv_r ring.

Theorem prod_n1_x_inv
  :  forall x : E, sum_is_inv x ({-1} # x).
Proof Ring.prod_n1_x_inv ring.

Theorem prod_x_n1_inv
  :  forall x : E, sum_is_inv x (x # {-1}).
Proof Ring.prod_x_n1_inv ring.

Theorem prod_n1_neg
  :  {#} {-1} = sum_neg.
Proof Ring.prod_n1_neg ring.

Theorem prod_x_n1_neg
  :  forall x : E, x # {-1} = - x.
Proof Ring.prod_x_n1_neg ring.

Theorem prod_n1_x_neg
  :  forall x : E, {-1} # x = - x.
Proof Ring.prod_n1_x_neg ring.

Theorem prod_n1_eq
  :  forall x : E, {-1} # x = x # {-1} .
Proof Ring.prod_n1_eq ring.

Theorem neg_1
  :  {-} 1 = {-1}.
Proof Ring.neg_1 ring.

Theorem neg_n1
  :  sum_neg {-1} = 1.
Proof Ring.neg_n1 ring.

Theorem prod_n1_n1
  :  {-1} # {-1} = 1.
Proof Ring.prod_n1_n1 ring.

Theorem E_n1_inv
  :  prod_is_inv {-1} {-1}.
Proof Ring.E_n1_inv ring.

End Theorems.

End Commutative_Ring.

Notation "0" := (Commutative_Ring.E_0) : commutative_ring_scope.

Notation "1" := (Commutative_Ring.E_1) : commutative_ring_scope.

Notation "x + y" := (Commutative_Ring.sum x y) (at level 50, left associativity) : commutative_ring_scope.

Notation "{+}" := (Commutative_Ring.sum) : commutative_ring_scope.

Notation "{-}" := (Commutative_Ring.sum_neg _) : commutative_ring_scope.

Notation "- x" := (Commutative_Ring.sum_neg _ x) : commutative_ring_scope.

Notation "x # y" := (Commutative_Ring.prod x y) (at level 50, left associativity) : commutative_ring_scope.

Notation "{#}" := (Commutative_Ring.prod) : commutative_ring_scope. *)



Module Field.



Structure Field : Type := field {



  E: Set;



  E_0: E;



  E_1: E;



  sum: E -> E -> E;



  prod: E -> E -> E;



  distinct_0_1: E_0 <> E_1;



  sum_is_assoc : Monoid.is_assoc E sum;



  sum_is_comm : Abelian_Group.is_comm E sum;



  sum_id_l : Monoid.is_id_l E sum E_0;



  sum_inv_l_ex : forall x : E, exists y : E, sum y x = E_0;



  prod_is_assoc : Monoid.is_assoc E prod;



  prod_is_comm : Abelian_Group.is_comm E prod;

  

  prod_id_l : Monoid.is_id_l E prod E_1;



  prod_inv_l_ex : forall x : E, x <> E_0 -> exists y : E, prod y x = E_1;



  prod_sum_distrib_l : Ring.is_distrib_l E prod sum

}.



Arguments E_0 {f}.



Arguments E_1 {f}.



Arguments sum {f} x y.



Arguments prod {f} x y.



Arguments distinct_0_1 {f} _.



Arguments sum_is_assoc {f} x y z.



Arguments sum_is_comm {f} x y.



Arguments sum_id_l {f} x.



Arguments sum_inv_l_ex {f} x.



Arguments prod_is_assoc {f} x y z.



Arguments prod_is_comm {f} x y.



Arguments prod_id_l {f} x.



Arguments prod_inv_l_ex {f} x _.



Arguments prod_sum_distrib_l {f} x y z.



Notation "0" := E_0 : field_scope.



Notation "1" := E_1 : field_scope.



Notation "x + y" := (sum x y) (at level 50, left associativity) : field_scope.



Notation "{+}" := sum : field_scope.



Notation "x # y" := (prod x y) (at level 50, left associativity) : field_scope.



Notation "{#}" := prod : field_scope.



Open Scope field_scope.



Section Theorems.



Variable f : Field.



Let E := E f.



Definition sum_is_id_l := Monoid.is_id_l E {+}.



Definition sum_is_id_r := Monoid.is_id_r E {+}.



Definition sum_is_id := Monoid.is_id E {+}.



Definition prod_is_id_l := Monoid.is_id_l E {#}.



Definition prod_is_id_r := Monoid.is_id_r E {#}.



Definition prod_is_id := Monoid.is_id E {#}.



Definition commutative_ring

  := Commutative_Ring.commutative_ring E 0 1 {+} {#}

       distinct_0_1 sum_is_assoc sum_is_comm sum_id_l sum_inv_l_ex

       prod_is_assoc prod_is_comm prod_id_l prod_sum_distrib_l.



Definition ring := Commutative_Ring.ring commutative_ring.



Definition sum_abelian_group := Commutative_Ring.sum_abelian_group commutative_ring.



Definition sum_group := Commutative_Ring.sum_group commutative_ring.



Definition sum_monoid := Commutative_Ring.sum_monoid commutative_ring.



Definition prod_monoid := Commutative_Ring.prod_monoid commutative_ring.



Definition distinct_1_0

  :  1 <> 0

  := Commutative_Ring.distinct_1_0 commutative_ring.



Definition nonzero

  :  E -> Prop

  := Commutative_Ring.nonzero commutative_ring.



Definition sum_id_r

  :  sum_is_id_r 0

  := Commutative_Ring.sum_id_r commutative_ring.



Definition sum_id := Commutative_Ring.sum_id commutative_ring.



Definition sum_is_inv_l := Monoid.is_inv_l E {+} 0 sum_id. 



Definition sum_is_inv_r := Monoid.is_inv_r E {+} 0 sum_id.



Definition sum_is_inv := Monoid.is_inv E {+} 0 sum_id.



Definition sum_inv_r_ex

  :  forall x : E, exists y : E, sum_is_inv_r x y

  := Commutative_Ring.sum_inv_r_ex commutative_ring.



Definition sum_id_l_uniq

  :  forall x : E, Monoid.is_id_l E {+} x -> x = 0

  := Commutative_Ring.sum_id_l_uniq commutative_ring.



Definition sum_id_r_uniq

  :  forall x : E, Monoid.is_id_r E {+} x -> x = 0

  := Commutative_Ring.sum_id_r_uniq commutative_ring.



Definition sum_id_uniq

  :  forall x : E, Monoid.is_id E {+} x -> x = 0

  := Commutative_Ring.sum_id_uniq commutative_ring.



Definition sum_inv_l_r_eq

  :  forall x y : E, sum_is_inv_l x y -> forall z : E, sum_is_inv_r x z -> y = z

  := Commutative_Ring.sum_inv_l_r_eq commutative_ring.



Definition sum_inv_sym

  :  forall x y : E, sum_is_inv x y <-> sum_is_inv y x

  := Commutative_Ring.sum_inv_sym commutative_ring.



Definition sum_inv_uniq

  :  forall x y z :  E, sum_is_inv x y -> sum_is_inv x z -> z = y

  := Commutative_Ring.sum_inv_uniq commutative_ring.



Definition sum_inv_ex

  :  forall x : E, exists y : E, sum_is_inv x y

  := Commutative_Ring.sum_inv_ex commutative_ring.



Definition sum_inv_uniq_ex

  :  forall x : E, exists! y : E, sum_is_inv x y

  := Commutative_Ring.sum_inv_uniq_ex commutative_ring.



Definition sum_intro_l

  :  forall x y z : E, x = y -> z + x = z + y

  := Commutative_Ring.sum_intro_l commutative_ring.



Definition sum_intro_r

  :  forall x y z : E, x = y -> x + z = y + z

  := Commutative_Ring.sum_intro_r commutative_ring.



Definition sum_cancel_l

  :   forall x y z : E, z + x = z + y -> x = y

  := Commutative_Ring.sum_cancel_l commutative_ring.



Definition sum_cancel_r

  :   forall x y z : E, x + z = y + z -> x = y

  := Commutative_Ring.sum_cancel_r commutative_ring.



Definition sum_inv_l_uniq

  :  forall x y z : E, sum_is_inv_l x y -> sum_is_inv_l x z -> z = y

  := Commutative_Ring.sum_inv_l_uniq commutative_ring.



Definition sum_inv_r_uniq

  :  forall x y z : E, sum_is_inv_r x y -> sum_is_inv_r x z -> z = y

  := Commutative_Ring.sum_inv_r_uniq commutative_ring.



Definition sum_neg_strong

  :  forall x : E, { y | sum_is_inv x y }

  := Commutative_Ring.sum_neg_strong commutative_ring.



Definition sum_neg

  :  E -> E

  := Commutative_Ring.sum_neg commutative_ring.



Notation "{-}" := (sum_neg) : field_scope.



Notation "- x" := (sum_neg x) : field_scope.



Definition sum_neg_def

  :  forall x : E, sum_is_inv x (- x)

  := Commutative_Ring.sum_neg_def commutative_ring.



Definition sum_neg_inj

  :  is_injective E E {-}

  := Commutative_Ring.sum_neg_inj commutative_ring.



Definition sum_cancel_neg

  :  forall x : E, {-} (- x) = x

  := Commutative_Ring.sum_cancel_neg commutative_ring.



Definition sum_neg_onto

  :  is_onto E E {-}

  := Commutative_Ring.sum_neg_onto commutative_ring.



Definition sum_neg_bijective

  :  is_bijective E E {-}

  := Commutative_Ring.sum_neg_bijective commutative_ring.



Definition prod_id_r

  :  prod_is_id_r 1

  := Commutative_Ring.prod_id_r commutative_ring.



Definition prod_id

  :  prod_is_id 1

  := Commutative_Ring.prod_id commutative_ring.



Definition prod_id_l_uniq

  :  forall x : E, (Monoid.is_id_l E {#} x) -> x = 1

  := Commutative_Ring.prod_id_l_uniq commutative_ring.



Definition prod_id_r_uniq

  :  forall x : E, (Monoid.is_id_r E {#} x) -> x = 1

  := Commutative_Ring.prod_id_r_uniq commutative_ring.



Definition prod_id_uniq

  :  forall x : E, (Monoid.is_id E {#} x) -> x = 1

  := Commutative_Ring.prod_id_uniq commutative_ring.



Definition prod_intro_l

  :  forall x y z : E, x = y -> z # x = z # y

  := Commutative_Ring.prod_intro_l commutative_ring.



Definition prod_intro_r

  :  forall x y z : E, x = y -> x # z = y # z

  := Commutative_Ring.prod_intro_r commutative_ring.



Definition prod_is_inv_l := Commutative_Ring.prod_is_inv_l commutative_ring.



Definition prod_is_inv_r := Commutative_Ring.prod_is_inv_r commutative_ring.



Definition prod_is_inv := Commutative_Ring.prod_is_inv commutative_ring.



Definition prod_has_inv_l := Commutative_Ring.prod_has_inv_l commutative_ring.



Definition prod_has_inv_r := Commutative_Ring.prod_has_inv_r commutative_ring.



Definition prod_has_inv := Commutative_Ring.prod_has_inv commutative_ring.



Definition prod_is_inv_lr := Commutative_Ring.prod_is_inv_lr commutative_ring.



Definition prod_inv_r_ex

  :  forall x : E, x <> 0 -> prod_has_inv_r x

  := fun x H

       => ex_ind

            (fun y H0

              => ex_intro (prod_is_inv_r x) y

                   (prod_is_inv_lr x y H0))

            (prod_inv_l_ex x H).



Definition prod_inv_ex 

  :  forall x : E, nonzero x -> prod_has_inv x

  := fun x H

       => ex_ind

            (fun y H0

              => ex_intro (prod_is_inv x) y

                   (conj H0

                     (prod_is_inv_lr x y H0)))

            (prod_inv_l_ex x H).



Definition prod_inv_l_r_eq

  :  forall x y : E, prod_is_inv_l x y -> forall z : E, prod_is_inv_r x z -> y = z

  := Commutative_Ring.prod_inv_l_r_eq commutative_ring.



Definition prod_inv_sym

  :  forall x y : E, prod_is_inv x y <-> prod_is_inv y x

  := Commutative_Ring.prod_inv_sym commutative_ring.



Definition prod_cancel_l

  :   forall x y z : E, nonzero z -> z # x = z # y -> x = y

  := fun x y z H

       => Commutative_Ring.prod_cancel_l commutative_ring x y z (prod_inv_l_ex z H).



Definition prod_cancel_r

  :   forall x y z : E, nonzero z -> x # z = y # z -> x = y

  := fun x y z H

       => Commutative_Ring.prod_cancel_r commutative_ring x y z (prod_inv_r_ex z H).



Definition prod_inv_l_uniq

  :  forall x : E, nonzero x -> forall y z : E, prod_is_inv_l x y -> prod_is_inv_l x z -> z = y

  := fun x H

       => Commutative_Ring.prod_inv_l_uniq commutative_ring x (prod_inv_r_ex x H).



Definition prod_inv_r_uniq

  :  forall x : E, nonzero x -> forall y z : E, prod_is_inv_r x y -> prod_is_inv_r x z -> z = y

  := fun x H

       => Commutative_Ring.prod_inv_r_uniq commutative_ring x (prod_inv_l_ex x H).



Definition prod_inv_uniq

  :  forall x y z : E, prod_is_inv x y -> prod_is_inv x z -> z = y

  := Commutative_Ring.prod_inv_uniq commutative_ring.



Definition prod_uniq_inv_ex

  :  forall x : E, nonzero x -> exists! y : E, prod_is_inv x y

  := fun x H

       => ex_ind

            (fun y (H0 : prod_is_inv x y)

              => ex_intro

                   (unique (prod_is_inv x))

                   y

                   (conj H0 (fun z H1 => eq_sym (prod_inv_uniq x y z H0 H1))))

            (prod_inv_ex x H).



Definition recipr_1_l

  :  prod_is_inv_l 1 1

  := Commutative_Ring.recipr_1_l commutative_ring.



Definition recipr_1_r

  :  prod_is_inv_r 1 1

  := Commutative_Ring.recipr_1_r commutative_ring.



Definition recipr_1

  :  prod_is_inv 1 1

  := Commutative_Ring.recipr_1 commutative_ring.



Definition prod_has_inv_l_1

  :  prod_has_inv_l 1

  := Commutative_Ring.prod_has_inv_l_1 commutative_ring.



Definition prod_has_inv_r_1

  :  prod_has_inv_r 1

  := Commutative_Ring.prod_has_inv_r_1 commutative_ring.



Definition prod_has_inv_1

  :  prod_has_inv 1

  := Commutative_Ring.prod_has_inv_1 commutative_ring.



Definition prod_sum_distrib_r

  :  Ring.is_distrib_r E {#} {+}

  := Commutative_Ring.prod_sum_distrib_r commutative_ring.



Definition prod_sum_distrib

  :  Ring.is_distrib E {#} {+}

  := Commutative_Ring.prod_sum_distrib commutative_ring.



Definition prod_0_l

  :  forall x : E, 0 # x = 0

  := Commutative_Ring.prod_0_l commutative_ring.



Definition prod_0_r

  :  forall x : E, x # 0 = 0

  := Commutative_Ring.prod_0_r commutative_ring.



Definition prod_0_inv_l

  :  ~ prod_has_inv_l 0

  := Commutative_Ring.prod_0_inv_l commutative_ring.



Definition prod_0_inv_r

  :  ~ prod_has_inv_r 0

  := Commutative_Ring.prod_0_inv_r commutative_ring.



Definition prod_0_inv

  :  ~ prod_has_inv 0

  := Commutative_Ring.prod_0_inv commutative_ring.



Definition prod_inv_0

  :  forall x y : E, prod_is_inv x y -> nonzero y

  := Commutative_Ring.prod_inv_0 commutative_ring.



Definition prod_nonzero_closed

  :  forall x : E, nonzero x -> forall y : E, nonzero y -> nonzero (x # y)

  := fun x H y H0 (H1 : x # y = 0)

       => ex_ind 

            (fun z (H2 : prod_is_inv_l x z)

              => H0 (prod_intro_l (x # y) 0 z H1 

                     || z # (x # y) = a @a by <- prod_0_r z 

                     || a           = 0 @a by <- prod_is_assoc z x y

                     || a # y       = 0 @a by <- H2

                     || a           = 0 @a by <- prod_id_l y))

            (prod_inv_l_ex x H).



Definition E_n1_strong

  :  { x : E | sum_is_inv 1 x }

  := Commutative_Ring.E_n1_strong commutative_ring.



Definition E_n1 : E := Commutative_Ring.E_n1 commutative_ring.



Notation "{-1}" := E_n1 : field_scope.



Definition E_n1_def

  :  sum_is_inv 1 {-1}

  := Commutative_Ring.E_n1_def commutative_ring.

      

Definition E_n1_inv_l

  :  sum_is_inv_l 1 {-1}

  := Commutative_Ring.E_n1_inv_l commutative_ring.



Definition E_n1_inv_r

  :  sum_is_inv_r 1 {-1}

  := Commutative_Ring.E_n1_inv_r commutative_ring.



Definition E_n1_uniq

  :  forall x : E, sum_is_inv 1 x -> x = {-1}

  := Commutative_Ring.E_n1_uniq commutative_ring.



Definition prod_n1_x_inv_l

  :  forall x : E, sum_is_inv_l x ({-1} # x)

  := Commutative_Ring.prod_n1_x_inv_l commutative_ring.



Definition prod_x_n1_inv_l

  :  forall x : E, sum_is_inv_l x (x # {-1})

  := Commutative_Ring.prod_x_n1_inv_l commutative_ring.



Definition prod_n1_x_inv_r

  :  forall x : E, sum_is_inv_r x ({-1} # x)

  := Commutative_Ring.prod_n1_x_inv_r commutative_ring.



Definition prod_x_n1_inv_r

  :  forall x : E, sum_is_inv_r x (x # {-1})

  := Commutative_Ring.prod_x_n1_inv_r commutative_ring.



Definition prod_n1_x_inv

  :  forall x : E, sum_is_inv x ({-1} # x)

  := Commutative_Ring.prod_n1_x_inv commutative_ring.



Definition prod_x_n1_inv

  :  forall x : E, sum_is_inv x (x # {-1})

  := Commutative_Ring.prod_x_n1_inv commutative_ring.



Definition prod_n1_neg

  :  {#} {-1} = {-}

  := Commutative_Ring.prod_n1_neg commutative_ring.



Definition prod_x_n1_neg

  :  forall x : E, x # {-1} = - x

  := Commutative_Ring.prod_x_n1_neg commutative_ring.



Definition prod_n1_x_neg

  :  forall x : E, {-1} # x = - x

  := Commutative_Ring.prod_n1_x_neg commutative_ring.



Definition prod_n1_eq

  :  forall x : E, {-1} # x = x # {-1} 

  := Commutative_Ring.prod_n1_eq commutative_ring.



Definition neg_1

  :  {-} 1 = {-1}

  := Commutative_Ring.neg_1 commutative_ring.



Definition neg_n1

  :  - {-1} = 1

  := Commutative_Ring.neg_n1 commutative_ring.



Definition prod_n1_n1

  :  {-1} # {-1} = 1

  := Commutative_Ring.prod_n1_n1 commutative_ring.



Definition E_n1_inv

  :  prod_is_inv {-1} {-1}

  := Commutative_Ring.E_n1_inv commutative_ring.



Definition nonzero_n1

  :  nonzero {-1}

  := fun H : {-1} = 0

       => distinct_1_0

            (prod_intro_l {-1} 0 {-1} H

              || a = {-1} # 0 @a by <- prod_n1_n1

              || 1 = a        @a by <- prod_0_r {-1}).



Definition recipr_strong

  :  forall x : E, nonzero x -> {y | prod_is_inv x y}

  := fun x H

       => constructive_definite_description (prod_is_inv x)

            (prod_uniq_inv_ex x H).



Definition recipr

  :  forall x : E, nonzero x -> E

  := fun x H

       => proj1_sig (recipr_strong x H).



Notation "{1/ x }" := (recipr x) : field_scope.



Definition recipr_def

  :  forall (x : E) (H : nonzero x), prod_is_inv x ({1/x} H)

  := fun x H

       => proj2_sig (recipr_strong x H).



Definition recipr_n1

  :  ({1/{-1}} nonzero_n1) = {-1}

  := prod_inv_uniq {-1} {-1} ({1/{-1}} nonzero_n1)

       E_n1_inv

       (recipr_def {-1} nonzero_n1).



Definition recipr_nonzero

  :  forall (x : E) (H : nonzero x), nonzero ({1/x} H)

  := fun x H

       => prod_inv_0 x ({1/x} H) (recipr_def x H).



Definition recipr_cancel

  :  forall (x : E) (H : nonzero x), ({1/({1/x} H)} (recipr_nonzero x H)) = x

  := fun x H

       => Monoid.op_cancel_neg_gen prod_monoid x

            (prod_inv_ex x H)

            (prod_inv_ex ({1/x} H) (recipr_nonzero x H)).



Definition div

  :  E -> forall x : E, nonzero x -> E

  := fun x y H

       => x # ({1/y} H).



Notation "x / y" := (div x y) : field_scope.



Definition div_cancel_l

  :  forall (x : E) (H : nonzero x) (y : E), x # ((y/x) H) = y

  := fun x H y

       => eq_refl (x # ((y/x) H))

          || x # ((y/x) H) = x # a @a by <- prod_is_comm y ({1/x} H)

          || x # ((y/x) H) = a     @a by <- prod_is_assoc x ({1/x} H) y

          || x # ((y/x) H) = a # y @a by <- proj2 (recipr_def x H)

          || x # ((y/x) H) = a     @a by <- prod_id_l y.



Definition div_cancel_r

  :  forall (x : E) (H : nonzero x) (y : E), ((y/x) H) # x = y

  := fun x H y

       => div_cancel_l x H y

          || a = y @a by <- prod_is_comm x ((y/x) H).



Definition D : Set := {x : E | nonzero x}.



Definition D_cons

  :  forall x : E, nonzero x -> D

  := exist nonzero.



Axiom D_eq_dep

  : forall (x : E) (H : nonzero x) (y : E) (H0 : nonzero y), y = x -> eq_dep E nonzero y H0 x H.



Definition D_eq

  :  forall (x : E) (H : nonzero x) (y : E) (H0 : nonzero y), y = x -> D_cons y H0 = D_cons x H

  := fun x H y H0 H1

       => eq_dep_ind E nonzero y H0

            (fun (z : E) (H2 : nonzero z)

              => D_cons y H0 = D_cons z H2)

            (eq_refl (D_cons y H0)) x H (D_eq_dep x H y H0 H1).



Definition D_1 := D_cons 1 distinct_1_0.



Definition D_prod

  :  D -> D -> D

  := sig_rec

       (fun _ => D -> D)

       (fun (u : E) (H : nonzero u)

         => sig_rec

              (fun _ => D)

              (fun (v : E) (H0 : nonzero v)

                => D_cons

                     (u # v)

                     (prod_nonzero_closed u H v H0))).



Definition D_prod_is_id_l := Monoid.is_id_l D D_prod.



Definition D_prod_is_id_r := Monoid.is_id_r D D_prod.



Definition D_prod_is_id := Monoid.is_id D D_prod.



Definition D_prod_id_l

  :  D_prod_is_id_l D_1

  := sig_ind

       (fun x => D_prod D_1 x = x)

       (fun (u : E) (H : nonzero u)

          => D_eq u H (1 # u) (prod_nonzero_closed 1 distinct_1_0 u H)

               (prod_id_l u)).



Definition D_prod_id_r

  :  D_prod_is_id_r D_1

  := sig_ind

       (fun x => D_prod x D_1 = x)

       (fun (u : E) (H : nonzero u)

          => D_eq u H (u # 1) (prod_nonzero_closed u H 1 distinct_1_0)

               (prod_id_r u)).



Definition D_prod_id

  :  D_prod_is_id D_1

  := conj D_prod_id_l D_prod_id_r.



Definition D_prod_assoc

  :  Monoid.is_assoc D D_prod

  := sig_ind

       (fun x => forall y z : D, D_prod x (D_prod y z) = D_prod (D_prod x y) z)

       (fun (u : E) (H : nonzero u)

         => sig_ind

              (fun y => forall z : D, D_prod (D_cons u H) (D_prod y z) = D_prod (D_prod (D_cons u H) y) z)

              (fun (v : E) (H0 : nonzero v)

                => sig_ind

                     (fun z => D_prod (D_cons u H) (D_prod (D_cons v H0) z) = D_prod (D_prod (D_cons u H) (D_cons v H0)) z)

                     (fun (w : E) (H1 : nonzero w)

                       => let a

                            :  E

                            := u # (v # w) in

                          let H2

                            :  nonzero a

                            := prod_nonzero_closed u H (v # w) (prod_nonzero_closed v H0 w H1) in

                          let b

                            :  E

                            := prod (u # v) w in

                          let H3

                            :  nonzero b

                            := prod_nonzero_closed (u # v) (prod_nonzero_closed u H v H0) w H1 in

                          let X

                            :  D

                            := D_cons a H2 in

                          let Y

                            :  D

                            := D_cons b H3 in

                          D_eq b H3 a H2

                            (prod_is_assoc u v w)

              ))).



Definition D_prod_is_inv_l := Monoid.is_inv_l D D_prod D_1 D_prod_id.



Definition D_prod_is_inv_r := Monoid.is_inv_r D D_prod D_1 D_prod_id.



Definition D_prod_is_inv := Monoid.is_inv D D_prod D_1 D_prod_id.



Definition D_prod_inv_l

  :  forall (u : E) (H : nonzero u) (v : E) (H0 : nonzero v),

       prod_is_inv_l u v ->

       D_prod_is_inv_l (D_cons u H) (D_cons v H0)

  := fun (u : E) (H : nonzero u) (v : E) (H0 : nonzero v)

       => D_eq 1 distinct_1_0 (v # u) (prod_nonzero_closed v H0 u H).

      

Definition D_prod_inv_r

  :  forall (u : E) (H : nonzero u) (v : E) (H0 : nonzero v),

       prod_is_inv_r u v ->

       D_prod_is_inv_r (D_cons u H) (D_cons v H0)

  := fun (u : E) (H : nonzero u) (v : E) (H0 : nonzero v)

       => D_eq 1 distinct_1_0 (u # v) (prod_nonzero_closed u H v H0).



Definition D_prod_inv

  :  forall (u : E) (H : nonzero u) (v : E) (H0 : nonzero v),

       prod_is_inv u v ->

       D_prod_is_inv (D_cons u H) (D_cons v H0)

  := fun (u : E) (H : nonzero u) (v : E) (H0 : nonzero v) (H1 : prod_is_inv u v)

       => conj (D_prod_inv_l u H v H0 (proj1 H1))

               (D_prod_inv_r u H v H0 (proj2 H1)).



Definition D_prod_neg_strong

  :  forall x : D, { y : D | D_prod_is_inv x y }

  := sig_rec

       (fun x => { y : D | D_prod_is_inv x y })

       (fun (u : E) (H : nonzero u)

         => let v

              :  E

              := Monoid.op_neg prod_monoid u (prod_inv_ex u H) in

            let H0

              :  prod_is_inv u v

              := Monoid.op_neg_def prod_monoid u (prod_inv_ex u H) in

            let H1

              :  nonzero v

              := prod_inv_0 u v H0 in

            exist

              (fun y : D => D_prod_is_inv (D_cons u H) y)

              (D_cons v H1)

              (D_prod_inv u H v H1 H0)).



Definition D_prod_inv_ex 

  :  forall x : D, exists y : D, D_prod_is_inv x y

  := fun x

       => let (y, H) := D_prod_neg_strong x in

          ex_intro

            (fun y => D_prod_is_inv x y)

            y H.



Definition D_prod_inv_l_ex

  :  forall x : D, exists y : D, D_prod_is_inv_l x y

  := fun x

       => ex_ind

            (fun y (H : D_prod_is_inv x y)

              => ex_intro (fun z => D_prod_is_inv_l x z) y (proj1 H))

            (D_prod_inv_ex x).



Definition D_prod_inv_r_ex

  :  forall x : D, exists y : D, D_prod_is_inv_r x y

  := fun x

       => ex_ind

            (fun y (H : D_prod_is_inv x y)

              => ex_intro (fun z => D_prod_is_inv_r x z) y (proj2 H))

            (D_prod_inv_ex x).



Definition nonzero_group := Group.group D D_1 D_prod D_prod_assoc

  D_prod_id_l D_prod_id_r D_prod_inv_l_ex

  D_prod_inv_r_ex.



End Theorems.



End Field.

