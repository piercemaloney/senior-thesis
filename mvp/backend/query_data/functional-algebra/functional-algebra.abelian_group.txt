
Require Import Description.
Require Import base.
(* base:
Notation "A || B @ X 'by' E"
  := (eq_ind_r (fun X => B) A E) (at level 40, left associativity).

Notation "A || B @ X 'by' <- H"
  := (eq_ind_r (fun X => B) A (eq_sym H)) (at level 40, left associativity).

Notation "A =:= B"
  := (eq_refl A : A = B) (at level 90).

Definition bool_dec0
  :  forall b : bool, {b = true}+{b = false}
  := bool_rect
      (fun b => {b = true}+{b = false})
         (left (true = false) (eq_refl true))
         (right (false = true) (eq_refl false)). *)
Require Import function.
(* function:
Definition is_injective (A B : Type) (f : A -> B) : Prop
  := forall x y : A, f x = f y -> x = y.

Definition is_onto (A B : Type) (f : A -> B) : Prop
  := forall y : B, exists x : A, f x = y.

Definition is_bijective (A B : Type) (f : A -> B) : Prop
  := is_injective A B f /\ is_onto A B f. *)
Require Import monoid.
(* monoid:
Require Import Description.
Require Import base.
Require Import function.
Require Import ProofIrrelevance.
Require Import Bool.

Require Import Arith.
Require Import Wf.
Require Import Wellfounded.
Require Import Wf_nat.

Module Monoid.

Definition is_assoc (T : Type) (f : T -> T -> T) : Prop := forall x y z : T, f x (f y z) = f (f x y) z.

Definition is_id_l (T : Type) (f : T -> T -> T) (E : T) : Prop := forall x : T, f E x = x.

Definition is_id_r (T : Type) (f : T -> T -> T) (E : T) : Prop := forall x : T, f x E = x.

Definition is_id (T : Type) (f : T -> T -> T) (E : T) : Prop := is_id_l T f E /\ is_id_r T f E.

Definition is_inv_l (T : Type) (f : T -> T -> T) (E : T) (_ : is_id T f E) (x y : T) : Prop := f y x = E.

Definition is_inv_r (T : Type) (f : T -> T -> T) (E : T) (_ : is_id T f E) (x y : T) : Prop := f x y = E.

Definition is_inv (T : Type) (f : T -> T -> T) (E : T) (H : is_id T f E) (x y : T) : Prop := is_inv_l T f E H x y /\ is_inv_r T f E H x y.

Structure Monoid : Type := monoid {

  E: Set;

  E_0: E;

  op: E -> E -> E;

  op_is_assoc : is_assoc E op;

  op_id_l : is_id_l E op E_0;

  op_id_r : is_id_r E op E_0
}.

Arguments E_0 {m}.

Arguments op {m} x y.

Arguments op_is_assoc {m} x y z.

Arguments op_id_l {m} x.

Arguments op_id_r {m} x.

Notation "0" := E_0 : monoid_scope.

Notation "x + y" := (op x y) (at level 50, left associativity) : monoid_scope.

Notation "{+}" := op : monoid_scope.

Open Scope monoid_scope.

Section Theorems.

Variable m : Monoid.

Let M := E m.

Definition op_is_id_l := is_id_l M {+}.

Definition op_is_id_r := is_id_r M {+}.

Definition op_is_id := is_id M {+}.

Theorem op_id
  :  is_id M {+} 0.
Proof conj op_id_l op_id_r.

Theorem op_id_l_uniq
  :  forall x : M, (op_is_id_l x) -> x = 0.
Proof
  fun x H
    => H 0 || a = 0 @a by <- op_id_r x.

Theorem op_id_r_uniq
  :  forall x : M, (op_is_id_r x) -> x = 0.
Proof
  fun x H
    => H 0 || a = 0 @a by <- op_id_l x.

Theorem op_id_uniq
  :  forall x : M, (op_is_id x) -> x = 0.
Proof
  fun x
    => and_ind (fun H _ => op_id_l_uniq x H).

Theorem op_intro_l
  :  forall x y z : M, x = y -> z + x = z + y.
Proof
  fun x y z H
    => f_equal ({+} z) H.

Theorem op_intro_r
  :  forall x y z : M, x = y -> x + z = y + z.
Proof
  fun x y z H
    =>  eq_refl (x + z)
       || x + z = a + z @a by <- H.

Definition op_is_inv_l := is_inv_l M {+} 0 op_id.

Definition op_is_inv_r := is_inv_r M {+} 0 op_id.

Definition op_is_inv := is_inv M {+} 0 op_id.

Definition has_inv_l
  := fun x => exists y : M, op_is_inv_l x y.

Definition has_inv_r
  := fun x => exists y : M, op_is_inv_r x y.

Definition has_inv
  := fun x => exists y : M, op_is_inv x y.

Theorem op_inv_l_r_eq
  :  forall x y : M, op_is_inv_l x y -> forall z : M, op_is_inv_r x z -> y = z.
Proof
  fun x y H1 z H2
    => op_is_assoc y x z
          || y + a = (y + x) + z @a by <- H2
          || a = (y + x) + z     @a by <- op_id_r y
          || y = a + z           @a by <- H1
          || y = a               @a by <- op_id_l z.

Theorem op_inv_sym
  :  forall x y : M, op_is_inv x y <-> op_is_inv y x.
Proof
  fun x y
    => conj
            (fun H : op_is_inv x y
              => conj (proj2 H) (proj1 H))
            (fun H : op_is_inv y x
              => conj (proj2 H) (proj1 H)).

Theorem op_cancel_l
  :  forall x y z : M, has_inv_l z -> z + x = z + y -> x = y.
Proof
  fun x y z H H0
    => ex_ind 
            (fun u H1
              => op_intro_l (z + x) (z + y) u H0
              || a = u + (z + y) @a by <- op_is_assoc u z x
              || (u + z) + x = a @a by <- op_is_assoc u z y
              || a + x = a + y   @a by <- H1
              || a = 0 + y       @a by <- op_id_l x
              || x = a           @a by <- op_id_l y)
            H.

Theorem op_cancel_r
  :  forall x y z : M, has_inv_r z -> x + z = y + z -> x = y.
Proof
  fun x y z H H0
    => ex_ind
            (fun u H1
              =>  op_intro_r (x + z) (y + z) u H0
              || a = (y + z) + u @a by op_is_assoc x z u
              || x + (z + u) = a @a by op_is_assoc y z u
              || x + a = y + a   @a by <- H1
              || a = y + 0       @a by <- op_id_r x
              || x = a           @a by <- op_id_r y)
            H.

Theorem op_inv_l_uniq
  :  forall x : M, has_inv_r x -> forall y z : M, op_is_inv_l x y -> op_is_inv_l x z -> z = y.
Proof
  fun x H y z H0 H1
    => let H2
            :  z + x = y + x
            := H1 || z + x = a @a by H0 in
          let H3
            :  z = y
            := op_cancel_r z y x H H2 in
          H3.

Theorem op_inv_r_uniq
  :  forall x : M, has_inv_l x -> forall y z : M, op_is_inv_r x y -> op_is_inv_r x z -> z = y.
Proof
  fun x H y z H0 H1
    => let H2
            :  x + z = x + y
            := H1 || x + z = a @a by H0 in
          let H3
            :  z = y
            := op_cancel_l z y x H H2 in
          H3.

Theorem op_inv_uniq
  :  forall x y z : M, op_is_inv x y -> op_is_inv x z -> z = y.
Proof
  fun x y z H H0
    => op_inv_l_uniq x
            (ex_intro (fun y => op_is_inv_r x y) y (proj2 H))
            y z (proj1 H) (proj1 H0).

Theorem op_inv_0_l
  :  op_is_inv_l 0 0.
Proof op_id_l 0 : 0 + 0 = 0.

Theorem op_inv_0_r
  :  op_is_inv_r 0 0.
Proof op_id_r 0 : 0 + 0 = 0.

Theorem op_inv_0
  :  op_is_inv 0 0.
Proof conj op_inv_0_l op_inv_0_r.

Theorem op_has_inv_l_0
  :  has_inv_l 0.
Proof ex_intro (op_is_inv_l 0) 0 op_inv_0_l.

Theorem op_has_inv_r_0
  :  has_inv_r 0.
Proof ex_intro (op_is_inv_r 0) 0 op_inv_0_r.

Theorem op_has_inv_0
  :  has_inv 0.
Proof ex_intro (op_is_inv 0) 0 op_inv_0.

Theorem op_inv_0_eq_0
  :  forall x : M, op_is_inv x 0 -> x = 0.
Proof
  fun x H
    => proj1 H
       || a = 0 @a by <- op_id_l x.

Theorem op_inv_0_uniq
  :  unique (fun x => op_is_inv x 0) 0.
Proof
  conj op_inv_0
    (fun x H => eq_sym (op_inv_0_eq_0 x H)).

Definition op_neg_strong
  :  forall x : M, has_inv x -> { y | op_is_inv x y }
  := fun x H
       => constructive_definite_description (op_is_inv x) 
            (ex_ind
              (fun y (H0 : op_is_inv x y)
                => ex_intro
                     (fun y => op_is_inv x y /\ forall z, op_is_inv x z -> y = z)
                     y
                     (conj H0 (fun z H1 => eq_sym (op_inv_uniq x y z H0 H1))))
              H).

Definition op_neg
  :  forall x : M, has_inv x -> M
  := fun x H => proj1_sig (op_neg_strong x H).

Notation "{-}" := (op_neg) : monoid_scope.

Theorem op_neg_def
  :  forall (x : M) (H : has_inv x), op_is_inv x ({-} x H).
Proof
  fun x H
    => proj2_sig (op_neg_strong x H).

Theorem op_neg_inv
  :  forall (x : M) (H : has_inv x), op_is_inv ({-} x H) x.
Proof
  fun x H
    => (proj1 (op_inv_sym x ({-} x H))) (op_neg_def x H).

Theorem op_neg_inv_ex
  :  forall (x : M) (H : has_inv x), has_inv ({-} x H).
Proof
  fun x H
    => ex_intro
         (op_is_inv ({-} x H))
         x
         (op_neg_inv x H).

Theorem op_neg_inj
  :  forall (x : M) (H : has_inv x) (y : M) (H0 : has_inv y),
     {-} x H = {-} y H0 ->
     x = y.
Proof
  fun x H y H0 H1
    => let H2
         :  x + ({-} x H) = y + ({-} x H) 
         := (proj2 (op_neg_def x H) : x + ({-} x H) = 0)
            || x + ({-} x H) = a     @a by proj2 (op_neg_def y H0)
            || x + ({-} x H) = y + a @a by H1 in
       let H3
         :  x = y
         := op_cancel_r x y ({-} x H)
            (ex_intro
              (op_is_inv_r ({-} x H))
              x
              (proj2 (proj1 (op_inv_sym x ({-} x H)) (op_neg_def x H))))
            H2 in
       H3.

Theorem op_cancel_neg_gen
  :  forall (x : M) (H : has_inv x) (H0 : has_inv ({-} x H)), {-} ({-} x H) H0 = x.
Proof
  fun x H H0
    => let H1
         :  op_is_inv ({-} x H) ({-} ({-} x H) H0)
         := op_neg_def ({-} x H) H0 in
       let H3
         :  op_is_inv ({-} x H) x
         := op_neg_inv x H in
       op_inv_uniq ({-} x H) x ({-} ({-} x H) H0) H3 H1.

Theorem op_cancel_neg
  :  forall (x : M) (H : has_inv x), {-} ({-} x H) (op_neg_inv_ex x H) = x.
Proof
  fun x H
    => op_cancel_neg_gen x H (op_neg_inv_ex x H).

Theorem op_neg_onto
  :  forall (y : M) (H : has_inv y), exists (x : M) (H0 : has_inv x), {-} x H0 = y.
Proof
  fun y H
    => ex_intro
            (fun x => exists H0 : has_inv x, {-} x H0 = y)
            ({-} y H)
            (ex_intro
              (fun H0 => {-} ({-} y H) H0 = y)
              (op_neg_inv_ex y H)
              (op_cancel_neg y H)).

Theorem op_inv_closed
  :  forall (x : M) (H : has_inv x) (y : M) (H0 : has_inv y), has_inv (x + y).
Proof
  fun x H y H0
    => ex_ind
         (fun u (H1 : op_is_inv x u)
           => ex_ind
                (fun v (H2 : op_is_inv y v)
                  => ex_intro
                       (op_is_inv (x + y))
                       (v + u)
                       (conj
                         (op_is_assoc (v + u) x y
                           || (v + u) + (x + y) = a + y @a by op_is_assoc v u x
                           || (v + u) + (x + y) = (v + a) + y @a by <- proj1 H1
                           || (v + u) + (x + y) = a + y @a by <- op_id_r v
                           || (v + u) + (x + y) = a @a by <- proj1 H2
                         ) 
                         (op_is_assoc (x + y) v u
                           || (x + y) + (v + u) = a + u @a by op_is_assoc x y v
                           || (x + y) + (v + u) = (x + a) + u @a by <- proj2 H2
                           || (x + y) + (v + u) = a + u @a by <- op_id_r x
                           || (x + y) + (v + u) = a @a by <- proj2 H1
                         )))
                H0)
         H.

End Theorems.

End Monoid.

Notation "0" := (Monoid.E_0) : monoid_scope.

Notation "x + y" := (Monoid.op x y) (at level 50, left associativity) : monoid_scope.

Notation "{+}" := (Monoid.op) : monoid_scope.

Notation "{-}" := (Monoid.op_neg _) : monoid_scope. *)
Require Import group.
(* group:
Require Import ProofIrrelevance.
Require Import Description.
Require Import base.
Require Import function.
Require Import monoid.

Module Group.

Structure Group : Type := group {

  E: Set;

  E_0: E;

  op: E -> E -> E;

  op_is_assoc : Monoid.is_assoc E op;

  op_id_l : Monoid.is_id_l E op E_0;

  op_id_r : Monoid.is_id_r E op E_0;

  op_inv_l_ex : forall x : E, exists y : E, Monoid.is_inv_l E op E_0 (conj op_id_l op_id_r) x y;

  op_inv_r_ex : forall x : E, exists y : E, Monoid.is_inv_r E op E_0 (conj op_id_l op_id_r) x y
}.

Arguments E_0 {g}.

Arguments op {g} x y.

Arguments op_is_assoc {g} x y z.

Arguments op_id_l {g} x.

Arguments op_id_r {g} x.

Arguments op_inv_l_ex {g} x.

Arguments op_inv_r_ex {g} x.

Notation "0" := E_0 : group_scope.

Notation "x + y" := (op x y) (at level 50, left associativity) : group_scope.

Notation "{+}" := op : group_scope.

Open Scope group_scope.

Section Theorems.

Variable g : Group.

Let E := E g.

Definition op_monoid := Monoid.monoid E 0 {+} op_is_assoc op_id_l op_id_r.

Definition op_is_id_l := Monoid.op_is_id_l op_monoid.

Definition op_is_id_r := Monoid.op_is_id_r op_monoid.

Definition op_is_id := Monoid.op_is_id op_monoid.

Theorem op_id
  :  op_is_id 0.
Proof Monoid.op_id op_monoid.

Definition op_is_inv_l := Monoid.op_is_inv_l op_monoid.

Definition op_is_inv_r := Monoid.op_is_inv_r op_monoid.

Theorem op_id_l_uniq
  :  forall x : E, (op_is_id_l x) -> x = 0.
Proof Monoid.op_id_l_uniq op_monoid.

Theorem op_id_r_uniq 
  :  forall x : E, (op_is_id_r x) -> x = 0.
Proof Monoid.op_id_r_uniq op_monoid.

Theorem op_id_uniq
  :  forall x : E, (op_is_id x) -> x = 0.
Proof Monoid.op_id_uniq op_monoid.

Theorem op_intro_l
  :  forall x y z : E, x = y -> z + x = z + y.
Proof Monoid.op_intro_l op_monoid.

Theorem op_intro_r
  :  forall x y z : E, x = y -> x + z = y + z.
Proof Monoid.op_intro_r op_monoid.

Definition op_is_inv := Monoid.op_is_inv op_monoid.

Definition has_inv_l := Monoid.has_inv_l op_monoid.

Definition has_inv_r := Monoid.has_inv_r op_monoid.

Definition has_inv := Monoid.has_inv op_monoid.

Theorem op_inv_l_r_eq
  :  forall x y : E, op_is_inv_l x y -> forall z : E, op_is_inv_r x z -> y = z.
Proof Monoid.op_inv_l_r_eq op_monoid.

Theorem op_inv_sym
  :  forall x y : E, op_is_inv x y <-> op_is_inv y x.
Proof Monoid.op_inv_sym op_monoid.

Theorem op_inv_ex
  :  forall x : E, exists y : E, op_is_inv x y.
Proof
  fun x : E
    => ex_ind
            (fun y H
              => ex_ind
                   (fun z H0
                     => let H1
                          :  op_is_inv_r x y
                          :=  H0
                          || op_is_inv_r x a @a
                             by op_inv_l_r_eq x y H z H0 in
                        ex_intro
                          (fun a => op_is_inv x a)
                          y
                          (conj H H1))
                   (op_inv_r_ex x))
            (op_inv_l_ex x).

Theorem op_cancel_l
  :  forall x y z : E, z + x = z + y -> x = y.
Proof
  fun x y z H 
    => Monoid.op_cancel_l op_monoid x y z (op_inv_l_ex z) H.

Theorem op_cancel_r
  :  forall x y z : E, x + z = y + z -> x = y.
Proof
  fun x y z
    => Monoid.op_cancel_r op_monoid x y z (op_inv_r_ex z).

Theorem op_inv_l_uniq
  :  forall x y z : E, op_is_inv_l x y -> op_is_inv_l x z -> z = y.
Proof
  fun x
    => Monoid.op_inv_l_uniq op_monoid x (op_inv_r_ex x).

Theorem op_inv_r_uniq
  :  forall x y z : E, op_is_inv_r x y -> op_is_inv_r x z -> z = y.
Proof
  fun x
    => Monoid.op_inv_r_uniq op_monoid x (op_inv_l_ex x).

Theorem op_inv_uniq
  :  forall x y z : E, op_is_inv x y -> op_is_inv x z -> z = y.
Proof Monoid.op_inv_uniq op_monoid.

Theorem op_inv_uniq_ex
  :  forall x : E, exists! y : E, op_is_inv x y.
Proof
  fun x
    => ex_ind
            (fun y (H : op_is_inv x y)
              => ex_intro 
                   (fun y => op_is_inv x y /\ forall z, op_is_inv x z -> y = z)
                   y
                   (conj H (fun z H0 => eq_sym (op_inv_uniq x y z H H0))))
            (op_inv_ex x).

Theorem op_inv_0_l
  :  op_is_inv_l 0 0.
Proof Monoid.op_inv_0_l op_monoid.

Theorem op_inv_0_r
  :  op_is_inv_r 0 0.
Proof Monoid.op_inv_0_r op_monoid.

Theorem op_inv_0
  :  op_is_inv 0 0.
Proof Monoid.op_inv_0 op_monoid.

Theorem op_has_inv_l_0
  :  has_inv_l 0.
Proof Monoid.op_has_inv_l_0 op_monoid.

Theorem op_has_inv_r_0
  :  has_inv_r 0.
Proof Monoid.op_has_inv_r_0 op_monoid.

Theorem op_has_inv_0
  :  has_inv 0.
Proof Monoid.op_has_inv_0 op_monoid.

Theorem op_inv_0_eq_0
  :  forall x : E, op_is_inv x 0 -> x = 0.
Proof Monoid.op_inv_0_eq_0 op_monoid.

Theorem op_inv_0_uniq
  :  unique (fun x => op_is_inv x 0) 0.
Proof Monoid.op_inv_0_uniq op_monoid.
 
Definition op_neg_strong
  :  forall x : E, { y | op_is_inv x y }
  := fun x => Monoid.op_neg_strong op_monoid x (op_inv_ex x).

Definition op_neg
  :  E -> E
  := fun x => Monoid.op_neg op_monoid x (op_inv_ex x).

Notation "{-}" := (op_neg) : group_scope.

Notation "- x" := (op_neg x) : group_scope.

Theorem op_neg_def
  :  forall x : E, op_is_inv x (- x).
Proof
  fun x
    => Monoid.op_neg_def op_monoid x (op_inv_ex x).

Theorem op_neg_inj
  :  is_injective E E op_neg.
Proof
  fun x y
    => Monoid.op_neg_inj op_monoid x (op_inv_ex x) y (op_inv_ex y).

Theorem op_cancel_neg
  :  forall x : E, - (- x) = x.
Proof
  fun x
    => Monoid.op_cancel_neg_gen op_monoid x (op_inv_ex x) (op_inv_ex (- x)).

Theorem op_neg_onto
  :  is_onto E E {-}.
Proof
  fun x => ex_intro (fun y => - y = x) (- x) (op_cancel_neg x).

Theorem op_neg_bijective
  :  is_bijective E E {-}.
Proof
  conj op_neg_inj op_neg_onto.

Theorem op_neg_rev
  :  forall x y : E, - x = y -> - y = x.
Proof
  fun x y H
    => eq_sym
            (f_equal {-} H
             || a = - y @a by <- op_cancel_neg x).

Theorem op_neg_distrib_inv_l
  :  forall x y : E, op_is_inv_l (x + y) (- y + - x).
Proof
  fun x y
    => ((proj2 (op_neg_def (- y)))
            || - y + a = 0                 @a by <- op_cancel_neg y
            || - y + a = 0                 @a by op_id_l y
            || - y + (a + y) = 0           @a by proj2 (op_neg_def (- x))
            || - y + ((- x + a) + y) = 0 @a by <- op_cancel_neg x
            || - y + a = 0                 @a by op_is_assoc (- x) x y
            || a = 0                         @a by <- op_is_assoc (- y) (- x) (x + y)).

Theorem op_neg_distrib_inv_r
  :  forall x y : E, op_is_inv_r (x + y) (- y + - x).
Proof
  fun x y
    => ((proj2 (op_neg_def x))
            || x + a = 0           @a by op_id_l (- x)
            || x + (a + - x) = 0 @a by proj2 (op_neg_def y)
            || x + a = 0           @a by op_is_assoc y (- y) (- x)
            || a = 0               @a by <- op_is_assoc x y (- y + - x)).

Theorem op_neg_distrib_inv
  :  forall x y : E, op_is_inv (x + y) (- y + - x).
Proof
  fun x y
    => conj
            (op_neg_distrib_inv_l x y)
            (op_neg_distrib_inv_r x y).

Theorem op_neg_distrib
  :  forall x y : E, - (x + y) = - y + - x.
Proof
  fun x y
    => ex_ind
            (fun z (H : unique (op_is_inv (x + y)) z)
              => let H0
                   :  z = - (x + y)
                   := (proj2 H) 
                       (- (x + y))
                       (op_neg_def (x + y)) in
                 let H1
                   :  z = (- y + - x)
                   := (proj2 H)
                        (- y + - x)
                        (op_neg_distrib_inv x y) in
                 (H1 || a = - y + - x @a by <- H0))
            (op_inv_uniq_ex (x + y)).

End Theorems.

End Group.

Notation "0" := (Group.E_0) : group_scope.

Notation "x + y" := (Group.op x y) (at level 50, left associativity) : group_scope.

Notation "{+}" := (Group.op) : group_scope.

Notation "{-}" := (Group.op_neg _) : group_scope.

Notation "- x" := (Group.op_neg _ x) : group_scope. *)

Module Abelian_Group.

Definition is_comm (T : Type) (f : T -> T -> T)
  :  Prop
  := forall x y : T, f x y = f y x.

Structure Abelian_Group : Type := abelian_group {

  E : Set;

  E_0 : E;

  op : E -> E -> E;

  op_is_assoc : Monoid.is_assoc E op;

  op_is_comm : is_comm E op;

  op_id_l : Monoid.is_id_l E op E_0;

  op_inv_l_ex : forall x : E, exists y : E, op y x = E_0
}.

Arguments E_0 {a}.

Arguments op {a} x y.

Arguments op_is_assoc {a} x y z.

Arguments op_is_comm {a} x y.

Arguments op_id_l {a} x.

Arguments op_inv_l_ex {a} x.

Notation "0" := E_0 : abelian_group_scope.

Notation "x + y" := (op x y) (at level 50, left associativity) : abelian_group_scope.

Notation "{+}" := op : abelian_group_scope.

Open Scope abelian_group_scope.

Section Theorems.

Variable g : Abelian_Group.

Let E := E g.

Definition op_is_id_l := Monoid.is_id_l E {+}.

Definition op_is_id_r := Monoid.is_id_r E {+}.

Definition op_is_id := Monoid.is_id E {+}.

Theorem op_is_id_lr
  :  forall x : E, op_is_id_l x -> op_is_id_r x.
Proof
  fun x H y
    => H y
    || a = y @a by op_is_comm y x.

Theorem op_is_id_lid
  : forall x : E, op_is_id_l x -> op_is_id x.
Proof
  fun x H
    => conj H (op_is_id_lr x H).

Theorem op_id_r
  :  op_is_id_r 0.
Proof op_is_id_lr 0 op_id_l.

Theorem op_id
  :  op_is_id 0.
Proof conj op_id_l op_id_r.

Definition op_is_inv_l := Monoid.is_inv_l E {+} 0 op_id.

Definition op_is_inv_r := Monoid.is_inv_r E {+} 0 op_id.

Definition op_is_inv := Monoid.is_inv E {+} 0 op_id.

Theorem op_inv_r_ex
  :  forall x : E, exists y : E, op_is_inv_r x y.
Proof
  fun x
    => ex_ind
         (fun (y : E) (H : op_is_inv_l x y)
           => ex_intro
                (op_is_inv_r x)
                y
                (H || a = 0 @a by op_is_comm x y))
         (op_inv_l_ex x).

Definition op_group := Group.group E 0 {+} op_is_assoc op_id_l op_id_r op_inv_l_ex op_inv_r_ex.

Definition op_monoid := Group.op_monoid op_group.

Definition has_inv_l := Group.has_inv_l op_group.

Definition has_inv_r := Group.has_inv_r op_group.

Definition has_inv := Group.has_inv op_group.

Theorem op_id_l_uniq
  :  forall x : E, Monoid.is_id_l E {+} x -> x = 0.
Proof Group.op_id_l_uniq op_group.

Theorem op_id_r_uniq
  :  forall x : E, Monoid.is_id_r E {+} x -> x = 0.
Proof Group.op_id_r_uniq op_group.

Theorem op_id_uniq
  :  forall x : E, Monoid.is_id E {+} x -> x = 0.
Proof Group.op_id_uniq op_group.

Theorem op_inv_l_r_eq
  :  forall x y : E, op_is_inv_l x y -> forall z : E, op_is_inv_r x z -> y = z.
Proof Group.op_inv_l_r_eq op_group.

Theorem op_inv_sym
  :  forall x y : E, op_is_inv x y <-> op_is_inv y x.
Proof Group.op_inv_sym op_group.

Theorem op_inv_ex
  :  forall x : E, exists y : E, op_is_inv x y.
Proof Group.op_inv_ex op_group.

Theorem op_intro_l
  :  forall x y z : E, x = y -> z + x = z + y.
Proof Group.op_intro_l op_group.

Theorem op_intro_r
  :  forall x y z : E, x = y -> x + z = y + z.
Proof Group.op_intro_r op_group.

Theorem op_cancel_l
  :   forall x y z : E, z + x = z + y -> x = y.
Proof Group.op_cancel_l op_group.

Theorem op_cancel_r
  :   forall x y z : E, x + z = y + z -> x = y.
Proof Group.op_cancel_r op_group.

Theorem op_inv_l_uniq
  :  forall x y z : E, op_is_inv_l x y -> op_is_inv_l x z -> z = y.
Proof Group.op_inv_l_uniq op_group.

Theorem op_inv_r_uniq
  :  forall x y z : E, op_is_inv_r x y -> op_is_inv_r x z -> z = y.
Proof Group.op_inv_r_uniq op_group.

Theorem op_inv_uniq
  :  forall x y z : E, op_is_inv x y -> op_is_inv x z -> z = y.
Proof Group.op_inv_uniq op_group.

Theorem op_inv_uniq_ex
  :  forall x : E, exists! y : E, op_is_inv x y.
Proof Group.op_inv_uniq_ex op_group.

Theorem op_inv_0_l
  :  op_is_inv_l 0 0.
Proof Group.op_inv_0_l op_group.

Theorem op_inv_0_r
  :  op_is_inv_r 0 0.
Proof Group.op_inv_0_r op_group.

Theorem op_inv_0
  :  op_is_inv 0 0.
Proof Group.op_inv_0 op_group.

Theorem op_has_inv_l_0
  :  has_inv_l 0.
Proof Group.op_has_inv_l_0 op_group.

Theorem op_has_inv_r_0
  :  has_inv_r 0.
Proof Group.op_has_inv_r_0 op_group.

Theorem op_has_inv_0
  :  has_inv 0.
Proof Group.op_has_inv_0 op_group.

Theorem op_inv_0_eq_0
  :  forall x : E, op_is_inv x 0 -> x = 0.
Proof Group.op_inv_0_eq_0 op_group.

Theorem op_inv_0_uniq
  :  unique (fun x => op_is_inv x 0) 0.
Proof Group.op_inv_0_uniq op_group.
 
Definition op_neg_strong
  :  forall x : E, { y | op_is_inv x y }
  := Group.op_neg_strong op_group.

Definition op_neg
  :  E -> E
  := Group.op_neg op_group.

Close Scope nat_scope.

Notation "{-}" := (op_neg) : abelian_group_scope.

Notation "- x" := (op_neg x) : abelian_group_scope.

Theorem op_neg_def
  :  forall x : E, op_is_inv x (- x).
Proof Group.op_neg_def op_group.

Theorem op_neg_inj
  :  is_injective E E op_neg.
Proof Group.op_neg_inj op_group.

Theorem op_cancel_neg
  :  forall x : E, op_neg (- x) = x.
Proof Group.op_cancel_neg op_group.

Theorem op_neg_onto
  :  is_onto E E op_neg.
Proof Group.op_neg_onto op_group.

Theorem op_neg_bijective
  :  is_bijective E E op_neg.
Proof Group.op_neg_bijective op_group.

Theorem op_neg_rev
  :  forall x y : E, - x = y -> - y = x.
Proof Group.op_neg_rev op_group.

Theorem op_neg_distrib_inv_l
  :  forall x y : E, op_is_inv_l (x + y) (- y + - x).
Proof Group.op_neg_distrib_inv_l op_group.

Theorem op_neg_distrib_inv_r
  :  forall x y : E, op_is_inv_r (x + y) (- y + - x).
Proof Group.op_neg_distrib_inv_r op_group.

Theorem op_neg_distrib_inv
  :  forall x y : E, op_is_inv (x + y) (- y + - x).
Proof Group.op_neg_distrib_inv op_group.

Theorem op_neg_distrib
  :  forall x y : E, - (x + y) = - y + - x.
Proof Group.op_neg_distrib op_group.

End Theorems.

End Abelian_Group.

Notation "0" := (Abelian_Group.E_0) : abelian_group_scope.

Notation "x + y" := (Abelian_Group.op x y) (at level 50, left associativity) : abelian_group_scope.

Notation "{+}" := (Abelian_Group.op) : abelian_group_scope.

Notation "{-}" := (Abelian_Group.op_neg _) : abelian_group_scope.

Notation "- x" := (Abelian_Group.op_neg _ x) : abelian_group_scope.
