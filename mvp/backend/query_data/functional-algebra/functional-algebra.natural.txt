

Require Import base.
(* base:
Notation "A || B @ X 'by' E"
  := (eq_ind_r (fun X => B) A E) (at level 40, left associativity).

Notation "A || B @ X 'by' <- H"
  := (eq_ind_r (fun X => B) A (eq_sym H)) (at level 40, left associativity).

Notation "A =:= B"
  := (eq_refl A : A = B) (at level 90).

Definition bool_dec0
  :  forall b : bool, {b = true}+{b = false}
  := bool_rect
      (fun b => {b = true}+{b = false})
         (left (true = false) (eq_refl true))
         (right (false = true) (eq_refl false)). *)

Require Import group.

Require Import abelian_group.
(* abelian_group:
Require Import Description.
Require Import base.
Require Import function.
Require Import monoid.
Require Import group.

Module Abelian_Group.

Definition is_comm (T : Type) (f : T -> T -> T)
  :  Prop
  := forall x y : T, f x y = f y x.

Structure Abelian_Group : Type := abelian_group {

  E : Set;

  E_0 : E;

  op : E -> E -> E;

  op_is_assoc : Monoid.is_assoc E op;

  op_is_comm : is_comm E op;

  op_id_l : Monoid.is_id_l E op E_0;

  op_inv_l_ex : forall x : E, exists y : E, op y x = E_0
}.

Arguments E_0 {a}.

Arguments op {a} x y.

Arguments op_is_assoc {a} x y z.

Arguments op_is_comm {a} x y.

Arguments op_id_l {a} x.

Arguments op_inv_l_ex {a} x.

Notation "0" := E_0 : abelian_group_scope.

Notation "x + y" := (op x y) (at level 50, left associativity) : abelian_group_scope.

Notation "{+}" := op : abelian_group_scope.

Open Scope abelian_group_scope.

Section Theorems.

Variable g : Abelian_Group.

Let E := E g.

Definition op_is_id_l := Monoid.is_id_l E {+}.

Definition op_is_id_r := Monoid.is_id_r E {+}.

Definition op_is_id := Monoid.is_id E {+}.

Theorem op_is_id_lr
  :  forall x : E, op_is_id_l x -> op_is_id_r x.
Proof
  fun x H y
    => H y
    || a = y @a by op_is_comm y x.

Theorem op_is_id_lid
  : forall x : E, op_is_id_l x -> op_is_id x.
Proof
  fun x H
    => conj H (op_is_id_lr x H).

Theorem op_id_r
  :  op_is_id_r 0.
Proof op_is_id_lr 0 op_id_l.

Theorem op_id
  :  op_is_id 0.
Proof conj op_id_l op_id_r.

Definition op_is_inv_l := Monoid.is_inv_l E {+} 0 op_id.

Definition op_is_inv_r := Monoid.is_inv_r E {+} 0 op_id.

Definition op_is_inv := Monoid.is_inv E {+} 0 op_id.

Theorem op_inv_r_ex
  :  forall x : E, exists y : E, op_is_inv_r x y.
Proof
  fun x
    => ex_ind
         (fun (y : E) (H : op_is_inv_l x y)
           => ex_intro
                (op_is_inv_r x)
                y
                (H || a = 0 @a by op_is_comm x y))
         (op_inv_l_ex x).

Definition op_group := Group.group E 0 {+} op_is_assoc op_id_l op_id_r op_inv_l_ex op_inv_r_ex.

Definition op_monoid := Group.op_monoid op_group.

Definition has_inv_l := Group.has_inv_l op_group.

Definition has_inv_r := Group.has_inv_r op_group.

Definition has_inv := Group.has_inv op_group.

Theorem op_id_l_uniq
  :  forall x : E, Monoid.is_id_l E {+} x -> x = 0.
Proof Group.op_id_l_uniq op_group.

Theorem op_id_r_uniq
  :  forall x : E, Monoid.is_id_r E {+} x -> x = 0.
Proof Group.op_id_r_uniq op_group.

Theorem op_id_uniq
  :  forall x : E, Monoid.is_id E {+} x -> x = 0.
Proof Group.op_id_uniq op_group.

Theorem op_inv_l_r_eq
  :  forall x y : E, op_is_inv_l x y -> forall z : E, op_is_inv_r x z -> y = z.
Proof Group.op_inv_l_r_eq op_group.

Theorem op_inv_sym
  :  forall x y : E, op_is_inv x y <-> op_is_inv y x.
Proof Group.op_inv_sym op_group.

Theorem op_inv_ex
  :  forall x : E, exists y : E, op_is_inv x y.
Proof Group.op_inv_ex op_group.

Theorem op_intro_l
  :  forall x y z : E, x = y -> z + x = z + y.
Proof Group.op_intro_l op_group.

Theorem op_intro_r
  :  forall x y z : E, x = y -> x + z = y + z.
Proof Group.op_intro_r op_group.

Theorem op_cancel_l
  :   forall x y z : E, z + x = z + y -> x = y.
Proof Group.op_cancel_l op_group.

Theorem op_cancel_r
  :   forall x y z : E, x + z = y + z -> x = y.
Proof Group.op_cancel_r op_group.

Theorem op_inv_l_uniq
  :  forall x y z : E, op_is_inv_l x y -> op_is_inv_l x z -> z = y.
Proof Group.op_inv_l_uniq op_group.

Theorem op_inv_r_uniq
  :  forall x y z : E, op_is_inv_r x y -> op_is_inv_r x z -> z = y.
Proof Group.op_inv_r_uniq op_group.

Theorem op_inv_uniq
  :  forall x y z : E, op_is_inv x y -> op_is_inv x z -> z = y.
Proof Group.op_inv_uniq op_group.

Theorem op_inv_uniq_ex
  :  forall x : E, exists! y : E, op_is_inv x y.
Proof Group.op_inv_uniq_ex op_group.

Theorem op_inv_0_l
  :  op_is_inv_l 0 0.
Proof Group.op_inv_0_l op_group.

Theorem op_inv_0_r
  :  op_is_inv_r 0 0.
Proof Group.op_inv_0_r op_group.

Theorem op_inv_0
  :  op_is_inv 0 0.
Proof Group.op_inv_0 op_group.

Theorem op_has_inv_l_0
  :  has_inv_l 0.
Proof Group.op_has_inv_l_0 op_group.

Theorem op_has_inv_r_0
  :  has_inv_r 0.
Proof Group.op_has_inv_r_0 op_group.

Theorem op_has_inv_0
  :  has_inv 0.
Proof Group.op_has_inv_0 op_group.

Theorem op_inv_0_eq_0
  :  forall x : E, op_is_inv x 0 -> x = 0.
Proof Group.op_inv_0_eq_0 op_group.

Theorem op_inv_0_uniq
  :  unique (fun x => op_is_inv x 0) 0.
Proof Group.op_inv_0_uniq op_group.
 
Definition op_neg_strong
  :  forall x : E, { y | op_is_inv x y }
  := Group.op_neg_strong op_group.

Definition op_neg
  :  E -> E
  := Group.op_neg op_group.

Close Scope nat_scope.

Notation "{-}" := (op_neg) : abelian_group_scope.

Notation "- x" := (op_neg x) : abelian_group_scope.

Theorem op_neg_def
  :  forall x : E, op_is_inv x (- x).
Proof Group.op_neg_def op_group.

Theorem op_neg_inj
  :  is_injective E E op_neg.
Proof Group.op_neg_inj op_group.

Theorem op_cancel_neg
  :  forall x : E, op_neg (- x) = x.
Proof Group.op_cancel_neg op_group.

Theorem op_neg_onto
  :  is_onto E E op_neg.
Proof Group.op_neg_onto op_group.

Theorem op_neg_bijective
  :  is_bijective E E op_neg.
Proof Group.op_neg_bijective op_group.

Theorem op_neg_rev
  :  forall x y : E, - x = y -> - y = x.
Proof Group.op_neg_rev op_group.

Theorem op_neg_distrib_inv_l
  :  forall x y : E, op_is_inv_l (x + y) (- y + - x).
Proof Group.op_neg_distrib_inv_l op_group.

Theorem op_neg_distrib_inv_r
  :  forall x y : E, op_is_inv_r (x + y) (- y + - x).
Proof Group.op_neg_distrib_inv_r op_group.

Theorem op_neg_distrib_inv
  :  forall x y : E, op_is_inv (x + y) (- y + - x).
Proof Group.op_neg_distrib_inv op_group.

Theorem op_neg_distrib
  :  forall x y : E, - (x + y) = - y + - x.
Proof Group.op_neg_distrib op_group.

End Theorems.

End Abelian_Group.

Notation "0" := (Abelian_Group.E_0) : abelian_group_scope.

Notation "x + y" := (Abelian_Group.op x y) (at level 50, left associativity) : abelian_group_scope.

Notation "{+}" := (Abelian_Group.op) : abelian_group_scope.

Notation "{-}" := (Abelian_Group.op_neg _) : abelian_group_scope.

Notation "- x" := (Abelian_Group.op_neg _ x) : abelian_group_scope. *)

Require Import ring.

Require Import commutative_ring.
(* commutative_ring:
Require Import Description.
Require Import FunctionalExtensionality.
Require Import base.
Require Import function.
Require Import monoid.
Require Import group.
Require Import abelian_group.
Require Import ring.

Module Commutative_Ring.

Structure Commutative_Ring : Type := commutative_ring {

  E : Set;

  E_0 : E;

  E_1 : E;

  sum : E -> E -> E;

  prod : E -> E -> E;

  distinct_0_1: E_0 <> E_1;

  sum_is_assoc : Monoid.is_assoc E sum;

  sum_is_comm : Abelian_Group.is_comm E sum;

  sum_id_l : Monoid.is_id_l E sum E_0;

  sum_inv_l_ex : forall x : E, exists y : E, sum y x = E_0;

  prod_is_assoc : Monoid.is_assoc E prod;

  prod_is_comm : Abelian_Group.is_comm E prod;

   prod_id_l : Monoid.is_id_l E prod E_1;

  prod_sum_distrib_l : Ring.is_distrib_l E prod sum
}.
 
Arguments E_0 {c}.

Arguments E_1 {c}.

Arguments sum {c} x y.

Arguments prod {c} x y.

Arguments distinct_0_1 {c} _.

Arguments sum_is_assoc {c} x y z.

Arguments sum_is_comm {c} x y.

Arguments sum_id_l {c} x.

Arguments sum_inv_l_ex {c} x.

Arguments prod_is_assoc {c} x y z.

Arguments prod_id_l {c} x.

Arguments prod_sum_distrib_l {c} x y z.

Arguments prod_is_comm {c} x y.

Notation "0" := E_0 : commutative_ring_scope.

Notation "1" := E_1 : commutative_ring_scope.

Notation "x + y" := (sum x y) (at level 50, left associativity) : commutative_ring_scope.

Notation "{+}" := sum : commutative_ring_scope.

Notation "x # y" := (prod x y) (at level 50, left associativity) : commutative_ring_scope.

Notation "{#}" := prod : commutative_ring_scope.

Open Scope commutative_ring_scope.

Section Theorems.

Variable r : Commutative_Ring.

Let E := E r.

Definition sum_is_id_l := Monoid.is_id_l E {+}.

Definition sum_is_id_r := Monoid.is_id_r E {+}.

Definition sum_is_id := Monoid.is_id E {+}.

Definition prod_is_id_l := Monoid.is_id_l E {#}.

Definition prod_is_id_r := Monoid.is_id_r E {#}.

Definition prod_is_id := Monoid.is_id E {#}.

Theorem prod_id_r
  :  prod_is_id_r 1.
Proof
  fun x : E
    => eq_ind_r
         (fun a => a = x)
         (prod_id_l x)
         (prod_is_comm x 1).
 
Theorem prod_sum_distrib_r
  :  Ring.is_distrib_r E {#} {+}.
Proof
  fun x y z : E
    =>  prod_sum_distrib_l x y z
        || x # (y + z) = a + (x # z) @a by <- prod_is_comm x y
        || x # (y + z) = (y # x) + a @a by <- prod_is_comm x z
        || a = (y # x) + (z # x)     @a by <- prod_is_comm x (y + z).

Definition ring := Ring.ring E 0 1 {+} {#} distinct_0_1 sum_is_assoc sum_is_comm sum_id_l sum_inv_l_ex prod_is_assoc prod_id_l prod_id_r prod_sum_distrib_l prod_sum_distrib_r.

Definition sum_abelian_group := Ring.sum_abelian_group ring.

Definition sum_group := Ring.sum_group ring.

Definition sum_monoid := Ring.sum_monoid ring.

Definition prod_monoid := Ring.prod_monoid ring.

Theorem distinct_1_0
  :  E_1 (c := r) <> E_0 (c := r).
Proof
  fun H : E_1 = E_0
    => distinct_0_1 (eq_sym H).  

Definition nonzero
  : E -> Prop
  := Ring.nonzero ring.

Theorem sum_id_r
  :  sum_is_id_r 0.
Proof Ring.sum_id_r ring.

Theorem sum_id
  :  sum_is_id 0.
Proof Ring.sum_id ring.

Definition sum_is_inv_l
  := Ring.sum_is_inv_l ring.

Definition sum_is_inv_r
  := Ring.sum_is_inv_r ring.

Definition sum_is_inv
  := Ring.sum_is_inv ring.

Definition sum_has_inv_l := Ring.sum_has_inv_l ring.

Definition sum_has_inv_r := Ring.sum_has_inv_r ring.

Definition sum_has_inv := Ring.sum_has_inv ring.

Theorem sum_inv_r_ex
  :  forall x : E, exists y : E, sum_is_inv_r x y.
Proof Ring.sum_inv_r_ex ring.

Theorem sum_id_l_uniq
  :  forall x : E, Monoid.is_id_l E {+} x -> x = 0.
Proof Ring.sum_id_l_uniq ring.

Theorem sum_id_r_uniq
  :  forall x : E, Monoid.is_id_r E {+} x -> x = 0.
Proof Ring.sum_id_r_uniq ring.

Theorem sum_id_uniq
  :  forall x : E, Monoid.is_id E {+} x -> x = 0.
Proof Ring.sum_id_uniq ring.

Theorem sum_inv_l_r_eq
  :  forall x y : E, sum_is_inv_l x y -> forall z : E, sum_is_inv_r x z -> y = z.
Proof Ring.sum_inv_l_r_eq ring.

Theorem sum_inv_sym
  :  forall x y : E, sum_is_inv x y <-> sum_is_inv y x.
Proof Ring.sum_inv_sym ring.

Theorem sum_inv_uniq
  :  forall x y z :  E, sum_is_inv x y -> sum_is_inv x z -> z = y.
Proof Ring.sum_inv_uniq ring.

Theorem sum_inv_ex
  :  forall x : E, exists y : E, sum_is_inv x y.
Proof Ring.sum_inv_ex ring.

Theorem sum_inv_uniq_ex
  :  forall x : E, exists! y : E, sum_is_inv x y.
Proof Ring.sum_inv_uniq_ex ring.

Theorem sum_intro_l
  :  forall x y z : E, x = y -> z + x = z + y.
Proof Ring.sum_intro_l ring.

Theorem sum_intro_r
  :  forall x y z : E, x = y -> x + z = y + z.
Proof Ring.sum_intro_r ring.

Theorem sum_cancel_l
  :   forall x y z : E, z + x = z + y -> x = y.
Proof Ring.sum_cancel_l ring.

Theorem sum_cancel_r
  :   forall x y z : E, x + z = y + z -> x = y.
Proof Ring.sum_cancel_r ring.

Theorem sum_inv_l_uniq
  :  forall x y z : E, sum_is_inv_l x y -> sum_is_inv_l x z -> z = y.
Proof Ring.sum_inv_l_uniq ring.

Theorem sum_inv_r_uniq
  :  forall x y z : E, sum_is_inv_r x y -> sum_is_inv_r x z -> z = y.
Proof Ring.sum_inv_r_uniq ring.

Theorem sum_0_inv_l
  :  sum_is_inv_l 0 0.
Proof Ring.sum_0_inv_l ring.

Theorem sum_0_inv_r
  :  sum_is_inv_r 0 0.
Proof Ring.sum_0_inv_r ring.

Theorem sum_0_inv
  :  sum_is_inv 0 0.
Proof Ring.sum_0_inv ring.

Theorem sum_has_inv_l_0
  :  sum_has_inv_l 0.
Proof Ring.sum_has_inv_l_0 ring.

Theorem sum_has_inv_r_0
  :  sum_has_inv_r 0.
Proof Ring.sum_has_inv_r_0 ring.

Theorem sum_has_inv_0
  :  sum_has_inv 0.
Proof Ring.sum_has_inv_0 ring.

Theorem sum_inv_0_eq_0
  :  forall x : E, sum_is_inv x 0 -> x = 0.
Proof Ring.sum_inv_0_eq_0 ring.

Theorem sum_inv_0_uniq
  :  unique (fun x => sum_is_inv x 0) 0.
Proof Ring.sum_inv_0_uniq ring.

Definition sum_neg_strong
  :  forall x : E, { y | sum_is_inv x y }
  := Ring.sum_neg_strong ring.

Definition sum_neg 
  :  E -> E
  := Ring.sum_neg ring.

Notation "{-}" := (sum_neg) : commutative_ring_scope.

Notation "- x" := (sum_neg x) : commutative_ring_scope.

Definition sum_neg_def 
  :  forall x : E, sum_is_inv x (- x)
  := Ring.sum_neg_def ring.

Theorem sum_neg_inj
  :  is_injective E E sum_neg.
Proof Ring.sum_neg_inj ring.

Theorem sum_cancel_neg
  :  forall x : E, sum_neg (- x) = x.
Proof Ring.sum_cancel_neg ring.

Theorem sum_neg_onto
  :  is_onto E E sum_neg.
Proof Ring.sum_neg_onto ring.

Theorem sum_neg_bijective
  :  is_bijective E E sum_neg.
Proof Ring.sum_neg_bijective ring.

Theorem sum_neg_rev
  :  forall x y : E, - x = y -> - y = x.
Proof Ring.sum_neg_rev ring.

Theorem sum_neg_distrib_inv_l
  :  forall x y : E, sum_is_inv_l (x + y) (- y + - x).
Proof Ring.sum_neg_distrib_inv_l ring.

Theorem sum_neg_distrib_inv_r
  :  forall x y : E, sum_is_inv_r (x + y) (- y + - x).
Proof Ring.sum_neg_distrib_inv_r ring.

Theorem sum_neg_distrib_inv
  :  forall x y : E, sum_is_inv (x + y) (- y + - x).
Proof Ring.sum_neg_distrib_inv ring.

Theorem sum_neg_distrib
  :  forall x y : E, - (x + y) = - y + - x.
Proof Ring.sum_neg_distrib ring.

Theorem sum_0_neg
  :  - 0 = 0.
Proof Ring.sum_0_neg ring.

Theorem sum_neg_0
  :  forall x : E, - x = 0 -> x = 0.
Proof Ring.sum_neg_0 ring.

Theorem sum_neg_0_uniq
  :  unique (fun x => - x = 0) 0.
Proof Ring.sum_neg_0_uniq ring.

Theorem prod_id
  :  prod_is_id 1.
Proof Ring.prod_id ring.

Theorem prod_id_l_uniq
  :  forall x : E, (Monoid.is_id_l E {#} x) -> x = 1.
Proof Ring.prod_id_l_uniq ring.

Theorem prod_id_r_uniq
  :  forall x : E, (Monoid.is_id_r E {#} x) -> x = 1.
Proof Ring.prod_id_r_uniq ring.

Theorem prod_id_uniq
  :  forall x : E, (Monoid.is_id E {#} x) -> x = 1.
Proof Ring.prod_id_uniq ring.

Theorem prod_intro_l
  :  forall x y z : E, x = y -> z # x = z # y.
Proof Ring.prod_intro_l ring.

Theorem prod_intro_r
  :  forall x y z : E, x = y -> x # z = y # z.
Proof Ring.prod_intro_r ring.

Definition prod_is_inv_l := Ring.prod_is_inv_l ring.

Definition prod_is_inv_r := Ring.prod_is_inv_r ring.

Definition prod_is_inv := Ring.prod_is_inv ring.

Definition prod_has_inv_l := Ring.prod_has_inv_l ring.

Definition prod_has_inv_r := Ring.prod_has_inv_r ring.

Definition prod_has_inv := Ring.prod_has_inv ring.

Theorem prod_is_inv_lr 
  :  forall x y : E, prod_is_inv_l x y -> prod_is_inv_r x y.
Proof
  fun x y H
    => H || a = 1 @a by prod_is_comm x y.

Theorem prod_inv_l_r_eq
  :  forall x y : E, prod_is_inv_l x y -> forall z : E, prod_is_inv_r x z -> y = z.
Proof Ring.prod_inv_l_r_eq ring.

Theorem prod_inv_sym
  :  forall x y : E, prod_is_inv x y <-> prod_is_inv y x.
Proof Ring.prod_inv_sym ring.

Theorem prod_cancel_l
  :  forall x y z : E, prod_has_inv_l z -> z # x = z # y -> x = y.
Proof Ring.prod_cancel_l ring.

Theorem prod_cancel_r
  :  forall x y z : E, prod_has_inv_r z -> x # z = y # z -> x = y.
Proof Ring.prod_cancel_r ring.

Theorem prod_inv_l_uniq
  :  forall x : E, prod_has_inv_r x -> forall y z : E, prod_is_inv_l x y -> prod_is_inv_l x z -> z = y.
Proof Ring.prod_inv_l_uniq ring.

Theorem prod_inv_r_uniq
  :  forall x : E, prod_has_inv_l x -> forall y z : E, prod_is_inv_r x y -> prod_is_inv_r x z -> z = y.
Proof Ring.prod_inv_r_uniq ring.

Definition prod_inv_uniq
  :  forall x y z : E, prod_is_inv x y -> prod_is_inv x z -> z = y
  := Ring.prod_inv_uniq ring.

Theorem prod_inv_1_l
  :  prod_is_inv_l 1 1.
Proof Ring.prod_inv_1_l ring.

Theorem prod_inv_1_r
  :  prod_is_inv_r 1 1.
Proof Ring.prod_inv_1_l ring.

Theorem prod_inv_1
  :  prod_is_inv 1 1.
Proof Ring.prod_inv_1 ring.

Theorem prod_has_inv_l_1
  :  prod_has_inv_l 1.
Proof Ring.prod_has_inv_l_1 ring.

Theorem prod_has_inv_r_1
  :  prod_has_inv_r 1.
Proof Ring.prod_has_inv_r_1 ring.

Theorem prod_has_inv_1
  :  prod_has_inv 1.
Proof Ring.prod_has_inv_1 ring.

Theorem prod_inv_1_eq_1
  :  forall x : E, prod_is_inv x 1 -> x = 1.
Proof Ring.prod_inv_1_eq_1 ring.

Theorem prod_inv_1_uniq
  :  unique (fun x => prod_is_inv x 1) 1.
Proof Ring.prod_inv_1_uniq ring.

Theorem recipr_1_l
  :  prod_is_inv_l 1 1.
Proof Ring.recipr_1_l ring.

Theorem recipr_1_r
  :  prod_is_inv_r 1 1.
Proof Ring.recipr_1_r ring.

Theorem recipr_1
  :  prod_is_inv 1 1.
Proof Ring.recipr_1 ring.

Theorem prod_sum_distrib
  :  Ring.is_distrib E {#} {+}.
Proof Ring.prod_sum_distrib ring.

Theorem prod_0_l
  :  forall x : E, 0 # x = 0.
Proof Ring.prod_0_l ring.

Theorem prod_0_r
  :  forall x : E, x # 0 = 0.
Proof Ring.prod_0_r ring.

Theorem prod_0_inv_l
  :  ~ prod_has_inv_l 0.
Proof Ring.prod_0_inv_l ring.

Theorem prod_0_inv_r
  :  ~ prod_has_inv_r 0.
Proof Ring.prod_0_inv_r ring.

Theorem prod_0_inv
  :  ~ prod_has_inv 0.
Proof Ring.prod_0_inv ring.

Theorem prod_inv_0
  :  forall x y : E, prod_is_inv x y -> nonzero y.
Proof Ring.prod_inv_0 ring.

Definition E_n1_strong
  :  { x : E | sum_is_inv 1 x }
  := Ring.E_n1_strong ring.

Definition E_n1 : E := Ring.E_n1 ring.

Notation "{-1}" := E_n1 : commutative_ring_scope.

Definition E_n1_def
  :  sum_is_inv 1 {-1}
  := Ring.E_n1_def ring.
      
Theorem E_n1_inv_l
  :  sum_is_inv_l 1 {-1}.
Proof Ring.E_n1_inv_l ring.

Theorem E_n1_inv_r
  :  sum_is_inv_r 1 {-1}.
Proof Ring.E_n1_inv_r ring.

Theorem E_n1_uniq
  :  forall x : E, sum_is_inv 1 x -> x = {-1}.
Proof Ring.E_n1_uniq ring.

Theorem prod_n1_x_inv_l
  :  forall x : E, sum_is_inv_l x ({-1} # x).
Proof Ring.prod_n1_x_inv_l ring.

Theorem prod_x_n1_inv_l
  :  forall x : E, sum_is_inv_l x (x # {-1}).
Proof Ring.prod_x_n1_inv_l ring.

Theorem prod_n1_x_inv_r
  :  forall x : E, sum_is_inv_r x ({-1} # x).
Proof Ring.prod_n1_x_inv_r ring.

Theorem prod_x_n1_inv_r
  :  forall x : E, sum_is_inv_r x (x # {-1}).
Proof Ring.prod_x_n1_inv_r ring.

Theorem prod_n1_x_inv
  :  forall x : E, sum_is_inv x ({-1} # x).
Proof Ring.prod_n1_x_inv ring.

Theorem prod_x_n1_inv
  :  forall x : E, sum_is_inv x (x # {-1}).
Proof Ring.prod_x_n1_inv ring.

Theorem prod_n1_neg
  :  {#} {-1} = sum_neg.
Proof Ring.prod_n1_neg ring.

Theorem prod_x_n1_neg
  :  forall x : E, x # {-1} = - x.
Proof Ring.prod_x_n1_neg ring.

Theorem prod_n1_x_neg
  :  forall x : E, {-1} # x = - x.
Proof Ring.prod_n1_x_neg ring.

Theorem prod_n1_eq
  :  forall x : E, {-1} # x = x # {-1} .
Proof Ring.prod_n1_eq ring.

Theorem neg_1
  :  {-} 1 = {-1}.
Proof Ring.neg_1 ring.

Theorem neg_n1
  :  sum_neg {-1} = 1.
Proof Ring.neg_n1 ring.

Theorem prod_n1_n1
  :  {-1} # {-1} = 1.
Proof Ring.prod_n1_n1 ring.

Theorem E_n1_inv
  :  prod_is_inv {-1} {-1}.
Proof Ring.E_n1_inv ring.

End Theorems.

End Commutative_Ring.

Notation "0" := (Commutative_Ring.E_0) : commutative_ring_scope.

Notation "1" := (Commutative_Ring.E_1) : commutative_ring_scope.

Notation "x + y" := (Commutative_Ring.sum x y) (at level 50, left associativity) : commutative_ring_scope.

Notation "{+}" := (Commutative_Ring.sum) : commutative_ring_scope.

Notation "{-}" := (Commutative_Ring.sum_neg _) : commutative_ring_scope.

Notation "- x" := (Commutative_Ring.sum_neg _ x) : commutative_ring_scope.

Notation "x # y" := (Commutative_Ring.prod x y) (at level 50, left associativity) : commutative_ring_scope.

Notation "{#}" := (Commutative_Ring.prod) : commutative_ring_scope. *)

Require Import field.
(* field:
Require Import Eqdep.
Require Import Description.

Require Import base.
Require Import function.
Require Import monoid.
Require Import monoid_group.
Require Import group.
Require Import abelian_group.
Require Import ring.
Require Import commutative_ring.

Module Field.

Structure Field : Type := field {

  E: Set;

  E_0: E;

  E_1: E;

  sum: E -> E -> E;

  prod: E -> E -> E;

  distinct_0_1: E_0 <> E_1;

  sum_is_assoc : Monoid.is_assoc E sum;

  sum_is_comm : Abelian_Group.is_comm E sum;

  sum_id_l : Monoid.is_id_l E sum E_0;

  sum_inv_l_ex : forall x : E, exists y : E, sum y x = E_0;

  prod_is_assoc : Monoid.is_assoc E prod;

  prod_is_comm : Abelian_Group.is_comm E prod;
  
  prod_id_l : Monoid.is_id_l E prod E_1;

  prod_inv_l_ex : forall x : E, x <> E_0 -> exists y : E, prod y x = E_1;

  prod_sum_distrib_l : Ring.is_distrib_l E prod sum
}.

Arguments E_0 {f}.

Arguments E_1 {f}.

Arguments sum {f} x y.

Arguments prod {f} x y.

Arguments distinct_0_1 {f} _.

Arguments sum_is_assoc {f} x y z.

Arguments sum_is_comm {f} x y.

Arguments sum_id_l {f} x.

Arguments sum_inv_l_ex {f} x.

Arguments prod_is_assoc {f} x y z.

Arguments prod_is_comm {f} x y.

Arguments prod_id_l {f} x.

Arguments prod_inv_l_ex {f} x _.

Arguments prod_sum_distrib_l {f} x y z.

Notation "0" := E_0 : field_scope.

Notation "1" := E_1 : field_scope.

Notation "x + y" := (sum x y) (at level 50, left associativity) : field_scope.

Notation "{+}" := sum : field_scope.

Notation "x # y" := (prod x y) (at level 50, left associativity) : field_scope.

Notation "{#}" := prod : field_scope.

Open Scope field_scope.

Section Theorems.

Variable f : Field.

Let E := E f.

Definition sum_is_id_l := Monoid.is_id_l E {+}.

Definition sum_is_id_r := Monoid.is_id_r E {+}.

Definition sum_is_id := Monoid.is_id E {+}.

Definition prod_is_id_l := Monoid.is_id_l E {#}.

Definition prod_is_id_r := Monoid.is_id_r E {#}.

Definition prod_is_id := Monoid.is_id E {#}.

Definition commutative_ring
  := Commutative_Ring.commutative_ring E 0 1 {+} {#}
       distinct_0_1 sum_is_assoc sum_is_comm sum_id_l sum_inv_l_ex
       prod_is_assoc prod_is_comm prod_id_l prod_sum_distrib_l.

Definition ring := Commutative_Ring.ring commutative_ring.

Definition sum_abelian_group := Commutative_Ring.sum_abelian_group commutative_ring.

Definition sum_group := Commutative_Ring.sum_group commutative_ring.

Definition sum_monoid := Commutative_Ring.sum_monoid commutative_ring.

Definition prod_monoid := Commutative_Ring.prod_monoid commutative_ring.

Definition distinct_1_0
  :  1 <> 0
  := Commutative_Ring.distinct_1_0 commutative_ring.

Definition nonzero
  :  E -> Prop
  := Commutative_Ring.nonzero commutative_ring.

Definition sum_id_r
  :  sum_is_id_r 0
  := Commutative_Ring.sum_id_r commutative_ring.

Definition sum_id := Commutative_Ring.sum_id commutative_ring.

Definition sum_is_inv_l := Monoid.is_inv_l E {+} 0 sum_id. 

Definition sum_is_inv_r := Monoid.is_inv_r E {+} 0 sum_id.

Definition sum_is_inv := Monoid.is_inv E {+} 0 sum_id.

Definition sum_inv_r_ex
  :  forall x : E, exists y : E, sum_is_inv_r x y
  := Commutative_Ring.sum_inv_r_ex commutative_ring.

Definition sum_id_l_uniq
  :  forall x : E, Monoid.is_id_l E {+} x -> x = 0
  := Commutative_Ring.sum_id_l_uniq commutative_ring.

Definition sum_id_r_uniq
  :  forall x : E, Monoid.is_id_r E {+} x -> x = 0
  := Commutative_Ring.sum_id_r_uniq commutative_ring.

Definition sum_id_uniq
  :  forall x : E, Monoid.is_id E {+} x -> x = 0
  := Commutative_Ring.sum_id_uniq commutative_ring.

Definition sum_inv_l_r_eq
  :  forall x y : E, sum_is_inv_l x y -> forall z : E, sum_is_inv_r x z -> y = z
  := Commutative_Ring.sum_inv_l_r_eq commutative_ring.

Definition sum_inv_sym
  :  forall x y : E, sum_is_inv x y <-> sum_is_inv y x
  := Commutative_Ring.sum_inv_sym commutative_ring.

Definition sum_inv_uniq
  :  forall x y z :  E, sum_is_inv x y -> sum_is_inv x z -> z = y
  := Commutative_Ring.sum_inv_uniq commutative_ring.

Definition sum_inv_ex
  :  forall x : E, exists y : E, sum_is_inv x y
  := Commutative_Ring.sum_inv_ex commutative_ring.

Definition sum_inv_uniq_ex
  :  forall x : E, exists! y : E, sum_is_inv x y
  := Commutative_Ring.sum_inv_uniq_ex commutative_ring.

Definition sum_intro_l
  :  forall x y z : E, x = y -> z + x = z + y
  := Commutative_Ring.sum_intro_l commutative_ring.

Definition sum_intro_r
  :  forall x y z : E, x = y -> x + z = y + z
  := Commutative_Ring.sum_intro_r commutative_ring.

Definition sum_cancel_l
  :   forall x y z : E, z + x = z + y -> x = y
  := Commutative_Ring.sum_cancel_l commutative_ring.

Definition sum_cancel_r
  :   forall x y z : E, x + z = y + z -> x = y
  := Commutative_Ring.sum_cancel_r commutative_ring.

Definition sum_inv_l_uniq
  :  forall x y z : E, sum_is_inv_l x y -> sum_is_inv_l x z -> z = y
  := Commutative_Ring.sum_inv_l_uniq commutative_ring.

Definition sum_inv_r_uniq
  :  forall x y z : E, sum_is_inv_r x y -> sum_is_inv_r x z -> z = y
  := Commutative_Ring.sum_inv_r_uniq commutative_ring.

Definition sum_neg_strong
  :  forall x : E, { y | sum_is_inv x y }
  := Commutative_Ring.sum_neg_strong commutative_ring.

Definition sum_neg
  :  E -> E
  := Commutative_Ring.sum_neg commutative_ring.

Notation "{-}" := (sum_neg) : field_scope.

Notation "- x" := (sum_neg x) : field_scope.

Definition sum_neg_def
  :  forall x : E, sum_is_inv x (- x)
  := Commutative_Ring.sum_neg_def commutative_ring.

Definition sum_neg_inj
  :  is_injective E E {-}
  := Commutative_Ring.sum_neg_inj commutative_ring.

Definition sum_cancel_neg
  :  forall x : E, {-} (- x) = x
  := Commutative_Ring.sum_cancel_neg commutative_ring.

Definition sum_neg_onto
  :  is_onto E E {-}
  := Commutative_Ring.sum_neg_onto commutative_ring.

Definition sum_neg_bijective
  :  is_bijective E E {-}
  := Commutative_Ring.sum_neg_bijective commutative_ring.

Definition prod_id_r
  :  prod_is_id_r 1
  := Commutative_Ring.prod_id_r commutative_ring.

Definition prod_id
  :  prod_is_id 1
  := Commutative_Ring.prod_id commutative_ring.

Definition prod_id_l_uniq
  :  forall x : E, (Monoid.is_id_l E {#} x) -> x = 1
  := Commutative_Ring.prod_id_l_uniq commutative_ring.

Definition prod_id_r_uniq
  :  forall x : E, (Monoid.is_id_r E {#} x) -> x = 1
  := Commutative_Ring.prod_id_r_uniq commutative_ring.

Definition prod_id_uniq
  :  forall x : E, (Monoid.is_id E {#} x) -> x = 1
  := Commutative_Ring.prod_id_uniq commutative_ring.

Definition prod_intro_l
  :  forall x y z : E, x = y -> z # x = z # y
  := Commutative_Ring.prod_intro_l commutative_ring.

Definition prod_intro_r
  :  forall x y z : E, x = y -> x # z = y # z
  := Commutative_Ring.prod_intro_r commutative_ring.

Definition prod_is_inv_l := Commutative_Ring.prod_is_inv_l commutative_ring.

Definition prod_is_inv_r := Commutative_Ring.prod_is_inv_r commutative_ring.

Definition prod_is_inv := Commutative_Ring.prod_is_inv commutative_ring.

Definition prod_has_inv_l := Commutative_Ring.prod_has_inv_l commutative_ring.

Definition prod_has_inv_r := Commutative_Ring.prod_has_inv_r commutative_ring.

Definition prod_has_inv := Commutative_Ring.prod_has_inv commutative_ring.

Definition prod_is_inv_lr := Commutative_Ring.prod_is_inv_lr commutative_ring.

Definition prod_inv_r_ex
  :  forall x : E, x <> 0 -> prod_has_inv_r x
  := fun x H
       => ex_ind
            (fun y H0
              => ex_intro (prod_is_inv_r x) y
                   (prod_is_inv_lr x y H0))
            (prod_inv_l_ex x H).

Definition prod_inv_ex 
  :  forall x : E, nonzero x -> prod_has_inv x
  := fun x H
       => ex_ind
            (fun y H0
              => ex_intro (prod_is_inv x) y
                   (conj H0
                     (prod_is_inv_lr x y H0)))
            (prod_inv_l_ex x H).

Definition prod_inv_l_r_eq
  :  forall x y : E, prod_is_inv_l x y -> forall z : E, prod_is_inv_r x z -> y = z
  := Commutative_Ring.prod_inv_l_r_eq commutative_ring.

Definition prod_inv_sym
  :  forall x y : E, prod_is_inv x y <-> prod_is_inv y x
  := Commutative_Ring.prod_inv_sym commutative_ring.

Definition prod_cancel_l
  :   forall x y z : E, nonzero z -> z # x = z # y -> x = y
  := fun x y z H
       => Commutative_Ring.prod_cancel_l commutative_ring x y z (prod_inv_l_ex z H).

Definition prod_cancel_r
  :   forall x y z : E, nonzero z -> x # z = y # z -> x = y
  := fun x y z H
       => Commutative_Ring.prod_cancel_r commutative_ring x y z (prod_inv_r_ex z H).

Definition prod_inv_l_uniq
  :  forall x : E, nonzero x -> forall y z : E, prod_is_inv_l x y -> prod_is_inv_l x z -> z = y
  := fun x H
       => Commutative_Ring.prod_inv_l_uniq commutative_ring x (prod_inv_r_ex x H).

Definition prod_inv_r_uniq
  :  forall x : E, nonzero x -> forall y z : E, prod_is_inv_r x y -> prod_is_inv_r x z -> z = y
  := fun x H
       => Commutative_Ring.prod_inv_r_uniq commutative_ring x (prod_inv_l_ex x H).

Definition prod_inv_uniq
  :  forall x y z : E, prod_is_inv x y -> prod_is_inv x z -> z = y
  := Commutative_Ring.prod_inv_uniq commutative_ring.

Definition prod_uniq_inv_ex
  :  forall x : E, nonzero x -> exists! y : E, prod_is_inv x y
  := fun x H
       => ex_ind
            (fun y (H0 : prod_is_inv x y)
              => ex_intro
                   (unique (prod_is_inv x))
                   y
                   (conj H0 (fun z H1 => eq_sym (prod_inv_uniq x y z H0 H1))))
            (prod_inv_ex x H).

Definition recipr_1_l
  :  prod_is_inv_l 1 1
  := Commutative_Ring.recipr_1_l commutative_ring.

Definition recipr_1_r
  :  prod_is_inv_r 1 1
  := Commutative_Ring.recipr_1_r commutative_ring.

Definition recipr_1
  :  prod_is_inv 1 1
  := Commutative_Ring.recipr_1 commutative_ring.

Definition prod_has_inv_l_1
  :  prod_has_inv_l 1
  := Commutative_Ring.prod_has_inv_l_1 commutative_ring.

Definition prod_has_inv_r_1
  :  prod_has_inv_r 1
  := Commutative_Ring.prod_has_inv_r_1 commutative_ring.

Definition prod_has_inv_1
  :  prod_has_inv 1
  := Commutative_Ring.prod_has_inv_1 commutative_ring.

Definition prod_sum_distrib_r
  :  Ring.is_distrib_r E {#} {+}
  := Commutative_Ring.prod_sum_distrib_r commutative_ring.

Definition prod_sum_distrib
  :  Ring.is_distrib E {#} {+}
  := Commutative_Ring.prod_sum_distrib commutative_ring.

Definition prod_0_l
  :  forall x : E, 0 # x = 0
  := Commutative_Ring.prod_0_l commutative_ring.

Definition prod_0_r
  :  forall x : E, x # 0 = 0
  := Commutative_Ring.prod_0_r commutative_ring.

Definition prod_0_inv_l
  :  ~ prod_has_inv_l 0
  := Commutative_Ring.prod_0_inv_l commutative_ring.

Definition prod_0_inv_r
  :  ~ prod_has_inv_r 0
  := Commutative_Ring.prod_0_inv_r commutative_ring.

Definition prod_0_inv
  :  ~ prod_has_inv 0
  := Commutative_Ring.prod_0_inv commutative_ring.

Definition prod_inv_0
  :  forall x y : E, prod_is_inv x y -> nonzero y
  := Commutative_Ring.prod_inv_0 commutative_ring.

Definition prod_nonzero_closed
  :  forall x : E, nonzero x -> forall y : E, nonzero y -> nonzero (x # y)
  := fun x H y H0 (H1 : x # y = 0)
       => ex_ind 
            (fun z (H2 : prod_is_inv_l x z)
              => H0 (prod_intro_l (x # y) 0 z H1 
                     || z # (x # y) = a @a by <- prod_0_r z 
                     || a           = 0 @a by <- prod_is_assoc z x y
                     || a # y       = 0 @a by <- H2
                     || a           = 0 @a by <- prod_id_l y))
            (prod_inv_l_ex x H).

Definition E_n1_strong
  :  { x : E | sum_is_inv 1 x }
  := Commutative_Ring.E_n1_strong commutative_ring.

Definition E_n1 : E := Commutative_Ring.E_n1 commutative_ring.

Notation "{-1}" := E_n1 : field_scope.

Definition E_n1_def
  :  sum_is_inv 1 {-1}
  := Commutative_Ring.E_n1_def commutative_ring.
      
Definition E_n1_inv_l
  :  sum_is_inv_l 1 {-1}
  := Commutative_Ring.E_n1_inv_l commutative_ring.

Definition E_n1_inv_r
  :  sum_is_inv_r 1 {-1}
  := Commutative_Ring.E_n1_inv_r commutative_ring.

Definition E_n1_uniq
  :  forall x : E, sum_is_inv 1 x -> x = {-1}
  := Commutative_Ring.E_n1_uniq commutative_ring.

Definition prod_n1_x_inv_l
  :  forall x : E, sum_is_inv_l x ({-1} # x)
  := Commutative_Ring.prod_n1_x_inv_l commutative_ring.

Definition prod_x_n1_inv_l
  :  forall x : E, sum_is_inv_l x (x # {-1})
  := Commutative_Ring.prod_x_n1_inv_l commutative_ring.

Definition prod_n1_x_inv_r
  :  forall x : E, sum_is_inv_r x ({-1} # x)
  := Commutative_Ring.prod_n1_x_inv_r commutative_ring.

Definition prod_x_n1_inv_r
  :  forall x : E, sum_is_inv_r x (x # {-1})
  := Commutative_Ring.prod_x_n1_inv_r commutative_ring.

Definition prod_n1_x_inv
  :  forall x : E, sum_is_inv x ({-1} # x)
  := Commutative_Ring.prod_n1_x_inv commutative_ring.

Definition prod_x_n1_inv
  :  forall x : E, sum_is_inv x (x # {-1})
  := Commutative_Ring.prod_x_n1_inv commutative_ring.

Definition prod_n1_neg
  :  {#} {-1} = {-}
  := Commutative_Ring.prod_n1_neg commutative_ring.

Definition prod_x_n1_neg
  :  forall x : E, x # {-1} = - x
  := Commutative_Ring.prod_x_n1_neg commutative_ring.

Definition prod_n1_x_neg
  :  forall x : E, {-1} # x = - x
  := Commutative_Ring.prod_n1_x_neg commutative_ring.

Definition prod_n1_eq
  :  forall x : E, {-1} # x = x # {-1} 
  := Commutative_Ring.prod_n1_eq commutative_ring.

Definition neg_1
  :  {-} 1 = {-1}
  := Commutative_Ring.neg_1 commutative_ring.

Definition neg_n1
  :  - {-1} = 1
  := Commutative_Ring.neg_n1 commutative_ring.

Definition prod_n1_n1
  :  {-1} # {-1} = 1
  := Commutative_Ring.prod_n1_n1 commutative_ring.

Definition E_n1_inv
  :  prod_is_inv {-1} {-1}
  := Commutative_Ring.E_n1_inv commutative_ring.

Definition nonzero_n1
  :  nonzero {-1}
  := fun H : {-1} = 0
       => distinct_1_0
            (prod_intro_l {-1} 0 {-1} H
              || a = {-1} # 0 @a by <- prod_n1_n1
              || 1 = a        @a by <- prod_0_r {-1}).

Definition recipr_strong
  :  forall x : E, nonzero x -> {y | prod_is_inv x y}
  := fun x H
       => constructive_definite_description (prod_is_inv x)
            (prod_uniq_inv_ex x H).

Definition recipr
  :  forall x : E, nonzero x -> E
  := fun x H
       => proj1_sig (recipr_strong x H).

Notation "{1/ x }" := (recipr x) : field_scope.

Definition recipr_def
  :  forall (x : E) (H : nonzero x), prod_is_inv x ({1/x} H)
  := fun x H
       => proj2_sig (recipr_strong x H).

Definition recipr_n1
  :  ({1/{-1}} nonzero_n1) = {-1}
  := prod_inv_uniq {-1} {-1} ({1/{-1}} nonzero_n1)
       E_n1_inv
       (recipr_def {-1} nonzero_n1).

Definition recipr_nonzero
  :  forall (x : E) (H : nonzero x), nonzero ({1/x} H)
  := fun x H
       => prod_inv_0 x ({1/x} H) (recipr_def x H).

Definition recipr_cancel
  :  forall (x : E) (H : nonzero x), ({1/({1/x} H)} (recipr_nonzero x H)) = x
  := fun x H
       => Monoid.op_cancel_neg_gen prod_monoid x
            (prod_inv_ex x H)
            (prod_inv_ex ({1/x} H) (recipr_nonzero x H)).

Definition div
  :  E -> forall x : E, nonzero x -> E
  := fun x y H
       => x # ({1/y} H).

Notation "x / y" := (div x y) : field_scope.

Definition div_cancel_l
  :  forall (x : E) (H : nonzero x) (y : E), x # ((y/x) H) = y
  := fun x H y
       => eq_refl (x # ((y/x) H))
          || x # ((y/x) H) = x # a @a by <- prod_is_comm y ({1/x} H)
          || x # ((y/x) H) = a     @a by <- prod_is_assoc x ({1/x} H) y
          || x # ((y/x) H) = a # y @a by <- proj2 (recipr_def x H)
          || x # ((y/x) H) = a     @a by <- prod_id_l y.

Definition div_cancel_r
  :  forall (x : E) (H : nonzero x) (y : E), ((y/x) H) # x = y
  := fun x H y
       => div_cancel_l x H y
          || a = y @a by <- prod_is_comm x ((y/x) H).

Definition D : Set := {x : E | nonzero x}.

Definition D_cons
  :  forall x : E, nonzero x -> D
  := exist nonzero.

Axiom D_eq_dep
  : forall (x : E) (H : nonzero x) (y : E) (H0 : nonzero y), y = x -> eq_dep E nonzero y H0 x H.

Definition D_eq
  :  forall (x : E) (H : nonzero x) (y : E) (H0 : nonzero y), y = x -> D_cons y H0 = D_cons x H
  := fun x H y H0 H1
       => eq_dep_ind E nonzero y H0
            (fun (z : E) (H2 : nonzero z)
              => D_cons y H0 = D_cons z H2)
            (eq_refl (D_cons y H0)) x H (D_eq_dep x H y H0 H1).

Definition D_1 := D_cons 1 distinct_1_0.

Definition D_prod
  :  D -> D -> D
  := sig_rec
       (fun _ => D -> D)
       (fun (u : E) (H : nonzero u)
         => sig_rec
              (fun _ => D)
              (fun (v : E) (H0 : nonzero v)
                => D_cons
                     (u # v)
                     (prod_nonzero_closed u H v H0))).

Definition D_prod_is_id_l := Monoid.is_id_l D D_prod.

Definition D_prod_is_id_r := Monoid.is_id_r D D_prod.

Definition D_prod_is_id := Monoid.is_id D D_prod.

Definition D_prod_id_l
  :  D_prod_is_id_l D_1
  := sig_ind
       (fun x => D_prod D_1 x = x)
       (fun (u : E) (H : nonzero u)
          => D_eq u H (1 # u) (prod_nonzero_closed 1 distinct_1_0 u H)
               (prod_id_l u)).

Definition D_prod_id_r
  :  D_prod_is_id_r D_1
  := sig_ind
       (fun x => D_prod x D_1 = x)
       (fun (u : E) (H : nonzero u)
          => D_eq u H (u # 1) (prod_nonzero_closed u H 1 distinct_1_0)
               (prod_id_r u)).

Definition D_prod_id
  :  D_prod_is_id D_1
  := conj D_prod_id_l D_prod_id_r.

Definition D_prod_assoc
  :  Monoid.is_assoc D D_prod
  := sig_ind
       (fun x => forall y z : D, D_prod x (D_prod y z) = D_prod (D_prod x y) z)
       (fun (u : E) (H : nonzero u)
         => sig_ind
              (fun y => forall z : D, D_prod (D_cons u H) (D_prod y z) = D_prod (D_prod (D_cons u H) y) z)
              (fun (v : E) (H0 : nonzero v)
                => sig_ind
                     (fun z => D_prod (D_cons u H) (D_prod (D_cons v H0) z) = D_prod (D_prod (D_cons u H) (D_cons v H0)) z)
                     (fun (w : E) (H1 : nonzero w)
                       => let a
                            :  E
                            := u # (v # w) in
                          let H2
                            :  nonzero a
                            := prod_nonzero_closed u H (v # w) (prod_nonzero_closed v H0 w H1) in
                          let b
                            :  E
                            := prod (u # v) w in
                          let H3
                            :  nonzero b
                            := prod_nonzero_closed (u # v) (prod_nonzero_closed u H v H0) w H1 in
                          let X
                            :  D
                            := D_cons a H2 in
                          let Y
                            :  D
                            := D_cons b H3 in
                          D_eq b H3 a H2
                            (prod_is_assoc u v w)
              ))).

Definition D_prod_is_inv_l := Monoid.is_inv_l D D_prod D_1 D_prod_id.

Definition D_prod_is_inv_r := Monoid.is_inv_r D D_prod D_1 D_prod_id.

Definition D_prod_is_inv := Monoid.is_inv D D_prod D_1 D_prod_id.

Definition D_prod_inv_l
  :  forall (u : E) (H : nonzero u) (v : E) (H0 : nonzero v),
       prod_is_inv_l u v ->
       D_prod_is_inv_l (D_cons u H) (D_cons v H0)
  := fun (u : E) (H : nonzero u) (v : E) (H0 : nonzero v)
       => D_eq 1 distinct_1_0 (v # u) (prod_nonzero_closed v H0 u H).
      
Definition D_prod_inv_r
  :  forall (u : E) (H : nonzero u) (v : E) (H0 : nonzero v),
       prod_is_inv_r u v ->
       D_prod_is_inv_r (D_cons u H) (D_cons v H0)
  := fun (u : E) (H : nonzero u) (v : E) (H0 : nonzero v)
       => D_eq 1 distinct_1_0 (u # v) (prod_nonzero_closed u H v H0).

Definition D_prod_inv
  :  forall (u : E) (H : nonzero u) (v : E) (H0 : nonzero v),
       prod_is_inv u v ->
       D_prod_is_inv (D_cons u H) (D_cons v H0)
  := fun (u : E) (H : nonzero u) (v : E) (H0 : nonzero v) (H1 : prod_is_inv u v)
       => conj (D_prod_inv_l u H v H0 (proj1 H1))
               (D_prod_inv_r u H v H0 (proj2 H1)).

Definition D_prod_neg_strong
  :  forall x : D, { y : D | D_prod_is_inv x y }
  := sig_rec
       (fun x => { y : D | D_prod_is_inv x y })
       (fun (u : E) (H : nonzero u)
         => let v
              :  E
              := Monoid.op_neg prod_monoid u (prod_inv_ex u H) in
            let H0
              :  prod_is_inv u v
              := Monoid.op_neg_def prod_monoid u (prod_inv_ex u H) in
            let H1
              :  nonzero v
              := prod_inv_0 u v H0 in
            exist
              (fun y : D => D_prod_is_inv (D_cons u H) y)
              (D_cons v H1)
              (D_prod_inv u H v H1 H0)).

Definition D_prod_inv_ex 
  :  forall x : D, exists y : D, D_prod_is_inv x y
  := fun x
       => let (y, H) := D_prod_neg_strong x in
          ex_intro
            (fun y => D_prod_is_inv x y)
            y H.

Definition D_prod_inv_l_ex
  :  forall x : D, exists y : D, D_prod_is_inv_l x y
  := fun x
       => ex_ind
            (fun y (H : D_prod_is_inv x y)
              => ex_intro (fun z => D_prod_is_inv_l x z) y (proj1 H))
            (D_prod_inv_ex x).

Definition D_prod_inv_r_ex
  :  forall x : D, exists y : D, D_prod_is_inv_r x y
  := fun x
       => ex_ind
            (fun y (H : D_prod_is_inv x y)
              => ex_intro (fun z => D_prod_is_inv_r x z) y (proj2 H))
            (D_prod_inv_ex x).

Definition nonzero_group := Group.group D D_1 D_prod D_prod_assoc
  D_prod_id_l D_prod_id_r D_prod_inv_l_ex
  D_prod_inv_r_ex.

End Theorems.

End Field. *)



Inductive Natural_Number : Set

  := E_0  : Natural_Number

  |  succ : Natural_Number -> Natural_Number.



Structure Natural : Type := natural {

  E

    :  Set

    := Natural_Number;



  E_1

    :  E

    := succ E_0;



  E_rect 

    :  forall P : E -> Type, P E_0 -> (forall n : E, P n -> P (succ n)) -> forall n : E, P n

    := fun (P : E -> Type) (f : P E_0) (f0 : forall n : E, P n -> P (succ n))

         => fix F (n : E) : P n

              := match n as n0 return (P n0) with

                   | E_0 => f

                   | succ n0 => f0 n0 (F n0)

                 end;



  E_ind 

    : forall P : E -> Prop, P E_0 -> (forall x : E, P x -> P (succ x)) -> forall x : E, P x

    := fun P : E -> Prop

         => E_rect P;



  E_rec 

    :  forall F : E -> Set, F E_0 -> (forall x : E, F x -> F (succ x)) -> forall x : E, F x

    := fun P : E -> Set

         => E_rect P;

        

  sum

    :  E -> E -> E

    := fun x y => E_rec (fun _ => E) y (fun _ F => succ F) x;



  sum_is_id_l

    :  E -> Prop

    := fun x : E => is_id_l E sum x;



  sum_is_id_r

    :  E -> Prop

    := fun x : E => is_id_r E sum x;



  sum_is_id

    :  E -> Prop

    := fun x : E => is_id E sum x;



  sum_id_l

    :  sum_is_id_l E_0

    := fun x => eq_refl x;



  sum_id_r

    :  sum_is_id_r E_0

    := E_ind

         (fun x => sum x E_0 = x)

         (eq_refl E_0)

         (fun x (H : sum x E_0 = x)

           => eq_ind_r

                (fun a => succ a = succ x)

                (eq_refl (succ x))

                H);



  sum_comm

    :  is_comm E sum

    := E_rec

         (fun x => forall y : E, sum x y = sum y x)

         (fun y

            => let H : sum E_0 y = y

                 := eq_ind_r

                      (fun a => a = y)

                      (eq_refl y)

                      (sum_id_l y) in

               let H0 : sum E_0 y = sum y E_0

                 := eq_ind_r

                      (fun a => sum E_0 y = a)

                      H

                      (sum_id_r y) in

               H0)

         (fun x (H : forall y : E, sum x y = sum y x)

           => E_rec

                (fun y => sum (succ x) y = sum y (succ x))

                (let H0 :  sum (succ x) E_0 = succ x

                   := sum_id_r (succ x) in

                 let H1 :  sum (succ x) E_0 = sum E_0 (succ x)

                   := eq_ind_r

                        (fun a => sum (succ x) E_0 = a)

                        H0

                        (sum_id_l (succ x)) in

                 H1)

                (fun y (H0 : sum (succ x) y = sum y (succ x))

                  => let H1 : succ (succ (sum y x)) = succ (succ (sum x y))

                           

                       := eq_ind

                            (sum x y)

                            (fun a => succ (succ a) = succ (succ (sum x y)))

                            (eq_refl (succ (succ (sum x y))))

                            (sum y x)

                            (H y) in

                     let H2 : succ (sum x (succ y)) = succ (sum (succ x) y) 

                       := eq_ind_r

                            (fun a => succ a = succ (sum (succ x) y))

                            H1

                            (H (succ y)) in

                     let H3 : succ (sum x (succ y)) = succ (sum y (succ x))

                           

                       := eq_ind

                            (sum (succ x) y)

                            (fun a => succ (sum x (succ y)) = succ a)

                            H2

                            (sum y (succ x))

                            H0 in

                     H3));



  sum_assoc

    :  is_assoc E sum

    := fun x

         => E_ind

              (fun y => forall z : E, sum x (sum y z) = sum (sum x y) z)

              (fun z

                => let H  :  sum x (sum E_0 z) = sum x z

                          := eq_ind_r

                               (fun a => sum x a = sum x z)

                               (eq_refl (sum x z))

                               (sum_id_l z) in

                   let H0 :  sum x (sum E_0 z) = sum (sum x E_0) z

                          := eq_ind_r

                               (fun a => sum x (sum E_0 z) = sum a z)

                             H

                             (sum_id_r x) in

                   H0)

              (fun y (H : forall z : E, sum x (sum y z) = sum (sum x y) z) z

                => 


                   let H0 :  succ (sum x (sum y z)) = succ (sum (sum x y) z)

                          := eq_ind_r

                               (fun a => succ a = succ (sum (sum x y) z))

                               (eq_refl (succ (sum (sum x y) z)))

                               (H z) in

                   let H1 :  succ (sum (sum y z) x) = succ (sum (sum x y) z)

                          

                          := eq_ind_r

                               (fun a => succ a = succ (sum (sum x y) z))

                               H0

                               (sum_comm (sum y z) x) in

                   let H2 :  sum x (succ (sum y z)) = succ (sum (sum x y) z)

                          

                          := eq_ind_r

                               (fun a => a = succ (sum (sum x y) z))

                               H1

                               (sum_comm x (succ (sum y z))) in

                   let H3 :  sum x (succ (sum y z)) = sum (succ (sum y x)) z

                          

                          := eq_ind_r

                               (fun a => sum x (succ (sum y z)) = sum (succ a) z)

                               H2

                               (sum_comm y x) in

                   let H4 :  sum x (sum (succ y) z) = sum (sum x (succ y)) z

                          := eq_ind_r

                               (fun a => sum x (sum (succ y) z) = sum a z)

                               H3

                               (sum_comm x (succ y)) in

                   H4);



  sum_1_succ_l

    :  forall x : E, sum E_1 x = succ x

    := fun x

         => eq_ind_r

              (fun a => succ a = succ x)

              (eq_refl (succ x))

              (sum_id_l x);



  sum_1_succ_r

    :  forall x : E, sum x E_1 = succ x

    := fun x

         => eq_ind_r

              (fun a => a = succ x)

              (sum_1_succ_l x)

              (sum_comm x E_1);



  sum_1_succ

    :  forall x : E, (sum E_1 x = succ x /\ sum x E_1 = succ x)

    := fun x

         => conj (sum_1_succ_l x) (sum_1_succ_r x);



  prod

    :  E -> E -> E

    := fun x y => E_rec (fun _ => E) E_0 (fun _ F => sum y F) x;



  prod_0_l

    :  forall x : E, prod E_0 x = E_0

    := fun x

         => eq_refl E_0;



  prod_0_r

    :  forall x : E, prod x E_0 = E_0

    := E_ind

         (fun x => prod x E_0 = E_0)

         (eq_refl E_0)

         (fun x (H : prod x E_0 = E_0)

           => eq_ind_r

                (fun a => a = E_0)

                H

                (sum_id_l (prod x E_0)));



  prod_is_id_l

    :  E -> Prop

    := fun x : E => is_id_l E prod x;



  prod_is_id_r

    :  E -> Prop

    := fun x : E => is_id_r E prod x;



  prod_is_id

    :  E -> Prop

    := fun x : E => is_id E prod x;



  prod_id_l

    :  prod_is_id_l E_1

    := fun x

         => eq_ind_r

              (fun a => sum x a = x)

              (sum_id_r x)

              (prod_0_l x);



  prod_id_r

    :  prod_is_id_r E_1

    := E_ind

         (fun x => prod x E_1 = x)

         (prod_0_l E_1)

         (fun x (H : prod x E_1 = x)

           => 


              eq_ind_r

                (fun a => sum E_1 a = succ x)

                (sum_1_succ_l x)

                (prod_id_l x));



  prod_comm

    :  is_comm E prod

    := E_ind

         (fun x => forall y : E, prod x y = prod y x)

         (E_ind

           (fun y => prod E_0 y = prod y E_0)

           (eq_refl E_0)

           (fun y (H : prod E_0 y = prod y E_0)

             => H

                =|= (fun a => a = prod y E_0) by (prod_0_l y)

                =|= (fun a => E_0 = a) by (sum_id_l (prod y E_0))

                =|= (fun a => a = prod (succ y) E_0) by (prod_0_l (succ y))))

         (fun x (H : forall y : E, prod x y = prod y x)

           => E_ind

                (fun y => prod (succ x) y = prod y (succ x))

                (prod_0_r (succ x))

                (fun y (H0 : prod (succ x) y = prod y (succ x))

                  => (eq_refl (sum (succ (sum x y)) (prod x y)))

                     =|= [[ (prod y x) | (prod x y) ]]

                         (fun a => sum (succ (sum x y)) a = sum (succ (sum x y)) (prod x y))

                         by (H y)

                     =|= (fun a => sum (succ a) (prod y x) = sum (succ (sum x y)) (prod x y))

                         by (sum_comm y x)

                     =|= (fun a => a = sum (sum (succ x) y) (prod x y))

                         by (sum_assoc (succ y) x (prod y x))

                     =|= (fun a => sum (succ y) (sum x (prod y x)) = a)

                         by (sum_assoc (succ x) y (prod x y))

                     =|= [[ (prod y (succ x)) | (prod (succ x) y) ]]

                         (fun a => sum (succ y) (sum x (prod y x)) = sum (succ x) a)

                         by H0

                     =|= (fun a => sum (succ y) a = sum (succ x) (prod y (succ x)))

                         by (H (succ y))));



  prod_succ_l

    :  forall x y : E, prod (succ x) y = sum y (prod x y)



  prod_succ_r

    :  forall x y : E, prod y (succ x) = sum (prod y x) y

    := fun x y

         => eq_refl (prod (succ x) y)

            =|= (fun a => a = sum y (prod x y))

                by (prod_comm y (succ x))

            =|= (fun a => prod y (succ x) = a)

                by (sum_comm (prod x y) y)

            =|= (fun a => prod y (succ x) = sum a y)

                by (prod_comm y x);



  prod_distrib_l

    :  is_distrib_l E prod sum

    := E_ind

         (fun x => forall y z : E, prod x (sum y z) = sum (prod x y) (prod x z))

         (fun y z => eq_refl E_0)

         (fun x (H : forall y z : E, prod x (sum y z) = sum (prod x y) (prod x z)) y z

           => (eq_refl (sum (sum y z) (sum (prod x y) (prod x z))))

              =|= [[ (sum (sum (sum y z) (prod x y)) (prod x z)) | (sum (sum y z) (sum (prod x y) (prod x z))) ]]

                  (fun a => sum (sum y z) (sum (prod x y) (prod x z)) = a)

                  by (sum_assoc (sum y z) (prod x y) (prod x z))

              =|= (fun a => sum (sum y z) (sum (prod x y) (prod x z)) = sum a (prod x z))

                  by (sum_assoc y z (prod x y))

              =|= (fun a => sum (sum y z) (sum (prod x y) (prod x z)) = sum (sum y a) (prod x z))

                  by (sum_comm (prod x y) z)

              =|= [[ (sum (sum y (prod x y)) z) | (sum y (sum (prod x y) z)) ]]

                  (fun a => sum (sum y z) (sum (prod x y) (prod x z)) = sum a (prod x z))

                  by (sum_assoc y (prod x y) z)

              =|= (fun a => sum (sum y z) (sum (prod x y) (prod x z)) = a)

                  by (sum_assoc (sum y (prod x y)) z (prod x z))

              =|= (fun a => sum (sum y z) a = sum (prod (succ x) y) (prod (succ x) z))

                  by (H y z));



  prod_distrib_r

    :  is_distrib_r E prod sum

    := fun x y z

         => (prod_distrib_l x y z)

            =|= (fun a => a = sum (prod x y) (prod x z)) by (prod_comm (sum y z) x)

            =|= (fun a => prod (sum y z) x = sum a (prod x z)) by (prod_comm y x)

            =|= (fun a => prod (sum y z) x = sum (prod y x) a) by (prod_comm z x);



  prod_assoc

    :  is_assoc E prod



}.

