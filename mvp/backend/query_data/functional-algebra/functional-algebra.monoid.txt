

Require Import Description.

Require Import base.
(* base:
Notation "A || B @ X 'by' E"
  := (eq_ind_r (fun X => B) A E) (at level 40, left associativity).

Notation "A || B @ X 'by' <- H"
  := (eq_ind_r (fun X => B) A (eq_sym H)) (at level 40, left associativity).

Notation "A =:= B"
  := (eq_refl A : A = B) (at level 90).

Definition bool_dec0
  :  forall b : bool, {b = true}+{b = false}
  := bool_rect
      (fun b => {b = true}+{b = false})
         (left (true = false) (eq_refl true))
         (right (false = true) (eq_refl false)). *)

Require Import function.
(* function:
Definition is_injective (A B : Type) (f : A -> B) : Prop
  := forall x y : A, f x = f y -> x = y.

Definition is_onto (A B : Type) (f : A -> B) : Prop
  := forall y : B, exists x : A, f x = y.

Definition is_bijective (A B : Type) (f : A -> B) : Prop
  := is_injective A B f /\ is_onto A B f. *)

Require Import ProofIrrelevance.

Require Import Bool.



Require Import Arith.

Require Import Wf.

Require Import Wellfounded.

Require Import Wf_nat.



Module Monoid.



Definition is_assoc (T : Type) (f : T -> T -> T) : Prop := forall x y z : T, f x (f y z) = f (f x y) z.



Definition is_id_l (T : Type) (f : T -> T -> T) (E : T) : Prop := forall x : T, f E x = x.



Definition is_id_r (T : Type) (f : T -> T -> T) (E : T) : Prop := forall x : T, f x E = x.



Definition is_id (T : Type) (f : T -> T -> T) (E : T) : Prop := is_id_l T f E /\ is_id_r T f E.



Definition is_inv_l (T : Type) (f : T -> T -> T) (E : T) (_ : is_id T f E) (x y : T) : Prop := f y x = E.



Definition is_inv_r (T : Type) (f : T -> T -> T) (E : T) (_ : is_id T f E) (x y : T) : Prop := f x y = E.



Definition is_inv (T : Type) (f : T -> T -> T) (E : T) (H : is_id T f E) (x y : T) : Prop := is_inv_l T f E H x y /\ is_inv_r T f E H x y.



Structure Monoid : Type := monoid {



  E: Set;



  E_0: E;



  op: E -> E -> E;



  op_is_assoc : is_assoc E op;



  op_id_l : is_id_l E op E_0;



  op_id_r : is_id_r E op E_0

}.



Arguments E_0 {m}.



Arguments op {m} x y.



Arguments op_is_assoc {m} x y z.



Arguments op_id_l {m} x.



Arguments op_id_r {m} x.



Notation "0" := E_0 : monoid_scope.



Notation "x + y" := (op x y) (at level 50, left associativity) : monoid_scope.



Notation "{+}" := op : monoid_scope.



Open Scope monoid_scope.



Section Theorems.



Variable m : Monoid.



Let M := E m.



Definition op_is_id_l := is_id_l M {+}.



Definition op_is_id_r := is_id_r M {+}.



Definition op_is_id := is_id M {+}.



Theorem op_id

  :  is_id M {+} 0.

Proof conj op_id_l op_id_r.



Theorem op_id_l_uniq

  :  forall x : M, (op_is_id_l x) -> x = 0.

Proof

  fun x H

    => H 0 || a = 0 @a by <- op_id_r x.



Theorem op_id_r_uniq

  :  forall x : M, (op_is_id_r x) -> x = 0.

Proof

  fun x H

    => H 0 || a = 0 @a by <- op_id_l x.



Theorem op_id_uniq

  :  forall x : M, (op_is_id x) -> x = 0.

Proof

  fun x

    => and_ind (fun H _ => op_id_l_uniq x H).



Theorem op_intro_l

  :  forall x y z : M, x = y -> z + x = z + y.

Proof

  fun x y z H

    => f_equal ({+} z) H.



Theorem op_intro_r

  :  forall x y z : M, x = y -> x + z = y + z.

Proof

  fun x y z H

    =>  eq_refl (x + z)

       || x + z = a + z @a by <- H.



Definition op_is_inv_l := is_inv_l M {+} 0 op_id.



Definition op_is_inv_r := is_inv_r M {+} 0 op_id.



Definition op_is_inv := is_inv M {+} 0 op_id.



Definition has_inv_l

  := fun x => exists y : M, op_is_inv_l x y.



Definition has_inv_r

  := fun x => exists y : M, op_is_inv_r x y.



Definition has_inv

  := fun x => exists y : M, op_is_inv x y.



Theorem op_inv_l_r_eq

  :  forall x y : M, op_is_inv_l x y -> forall z : M, op_is_inv_r x z -> y = z.

Proof

  fun x y H1 z H2

    => op_is_assoc y x z

          || y + a = (y + x) + z @a by <- H2

          || a = (y + x) + z     @a by <- op_id_r y

          || y = a + z           @a by <- H1

          || y = a               @a by <- op_id_l z.



Theorem op_inv_sym

  :  forall x y : M, op_is_inv x y <-> op_is_inv y x.

Proof

  fun x y

    => conj

            (fun H : op_is_inv x y

              => conj (proj2 H) (proj1 H))

            (fun H : op_is_inv y x

              => conj (proj2 H) (proj1 H)).



Theorem op_cancel_l

  :  forall x y z : M, has_inv_l z -> z + x = z + y -> x = y.

Proof

  fun x y z H H0

    => ex_ind 

            (fun u H1

              => op_intro_l (z + x) (z + y) u H0

              || a = u + (z + y) @a by <- op_is_assoc u z x

              || (u + z) + x = a @a by <- op_is_assoc u z y

              || a + x = a + y   @a by <- H1

              || a = 0 + y       @a by <- op_id_l x

              || x = a           @a by <- op_id_l y)

            H.



Theorem op_cancel_r

  :  forall x y z : M, has_inv_r z -> x + z = y + z -> x = y.

Proof

  fun x y z H H0

    => ex_ind

            (fun u H1

              =>  op_intro_r (x + z) (y + z) u H0

              || a = (y + z) + u @a by op_is_assoc x z u

              || x + (z + u) = a @a by op_is_assoc y z u

              || x + a = y + a   @a by <- H1

              || a = y + 0       @a by <- op_id_r x

              || x = a           @a by <- op_id_r y)

            H.



Theorem op_inv_l_uniq

  :  forall x : M, has_inv_r x -> forall y z : M, op_is_inv_l x y -> op_is_inv_l x z -> z = y.

Proof

  fun x H y z H0 H1

    => let H2

            :  z + x = y + x

            := H1 || z + x = a @a by H0 in

          let H3

            :  z = y

            := op_cancel_r z y x H H2 in

          H3.



Theorem op_inv_r_uniq

  :  forall x : M, has_inv_l x -> forall y z : M, op_is_inv_r x y -> op_is_inv_r x z -> z = y.

Proof

  fun x H y z H0 H1

    => let H2

            :  x + z = x + y

            := H1 || x + z = a @a by H0 in

          let H3

            :  z = y

            := op_cancel_l z y x H H2 in

          H3.



Theorem op_inv_uniq

  :  forall x y z : M, op_is_inv x y -> op_is_inv x z -> z = y.

Proof

  fun x y z H H0

    => op_inv_l_uniq x

            (ex_intro (fun y => op_is_inv_r x y) y (proj2 H))

            y z (proj1 H) (proj1 H0).



Theorem op_inv_0_l

  :  op_is_inv_l 0 0.

Proof op_id_l 0 : 0 + 0 = 0.



Theorem op_inv_0_r

  :  op_is_inv_r 0 0.

Proof op_id_r 0 : 0 + 0 = 0.



Theorem op_inv_0

  :  op_is_inv 0 0.

Proof conj op_inv_0_l op_inv_0_r.



Theorem op_has_inv_l_0

  :  has_inv_l 0.

Proof ex_intro (op_is_inv_l 0) 0 op_inv_0_l.



Theorem op_has_inv_r_0

  :  has_inv_r 0.

Proof ex_intro (op_is_inv_r 0) 0 op_inv_0_r.



Theorem op_has_inv_0

  :  has_inv 0.

Proof ex_intro (op_is_inv 0) 0 op_inv_0.



Theorem op_inv_0_eq_0

  :  forall x : M, op_is_inv x 0 -> x = 0.

Proof

  fun x H

    => proj1 H

       || a = 0 @a by <- op_id_l x.



Theorem op_inv_0_uniq

  :  unique (fun x => op_is_inv x 0) 0.

Proof

  conj op_inv_0

    (fun x H => eq_sym (op_inv_0_eq_0 x H)).



Definition op_neg_strong

  :  forall x : M, has_inv x -> { y | op_is_inv x y }

  := fun x H

       => constructive_definite_description (op_is_inv x) 

            (ex_ind

              (fun y (H0 : op_is_inv x y)

                => ex_intro

                     (fun y => op_is_inv x y /\ forall z, op_is_inv x z -> y = z)

                     y

                     (conj H0 (fun z H1 => eq_sym (op_inv_uniq x y z H0 H1))))

              H).



Definition op_neg

  :  forall x : M, has_inv x -> M

  := fun x H => proj1_sig (op_neg_strong x H).



Notation "{-}" := (op_neg) : monoid_scope.



Theorem op_neg_def

  :  forall (x : M) (H : has_inv x), op_is_inv x ({-} x H).

Proof

  fun x H

    => proj2_sig (op_neg_strong x H).



Theorem op_neg_inv

  :  forall (x : M) (H : has_inv x), op_is_inv ({-} x H) x.

Proof

  fun x H

    => (proj1 (op_inv_sym x ({-} x H))) (op_neg_def x H).



Theorem op_neg_inv_ex

  :  forall (x : M) (H : has_inv x), has_inv ({-} x H).

Proof

  fun x H

    => ex_intro

         (op_is_inv ({-} x H))

         x

         (op_neg_inv x H).



Theorem op_neg_inj

  :  forall (x : M) (H : has_inv x) (y : M) (H0 : has_inv y),

     {-} x H = {-} y H0 ->

     x = y.

Proof

  fun x H y H0 H1

    => let H2

         :  x + ({-} x H) = y + ({-} x H) 

         := (proj2 (op_neg_def x H) : x + ({-} x H) = 0)

            || x + ({-} x H) = a     @a by proj2 (op_neg_def y H0)

            || x + ({-} x H) = y + a @a by H1 in

       let H3

         :  x = y

         := op_cancel_r x y ({-} x H)

            (ex_intro

              (op_is_inv_r ({-} x H))

              x

              (proj2 (proj1 (op_inv_sym x ({-} x H)) (op_neg_def x H))))

            H2 in

       H3.



Theorem op_cancel_neg_gen

  :  forall (x : M) (H : has_inv x) (H0 : has_inv ({-} x H)), {-} ({-} x H) H0 = x.

Proof

  fun x H H0

    => let H1

         :  op_is_inv ({-} x H) ({-} ({-} x H) H0)

         := op_neg_def ({-} x H) H0 in

       let H3

         :  op_is_inv ({-} x H) x

         := op_neg_inv x H in

       op_inv_uniq ({-} x H) x ({-} ({-} x H) H0) H3 H1.



Theorem op_cancel_neg

  :  forall (x : M) (H : has_inv x), {-} ({-} x H) (op_neg_inv_ex x H) = x.

Proof

  fun x H

    => op_cancel_neg_gen x H (op_neg_inv_ex x H).



Theorem op_neg_onto

  :  forall (y : M) (H : has_inv y), exists (x : M) (H0 : has_inv x), {-} x H0 = y.

Proof

  fun y H

    => ex_intro

            (fun x => exists H0 : has_inv x, {-} x H0 = y)

            ({-} y H)

            (ex_intro

              (fun H0 => {-} ({-} y H) H0 = y)

              (op_neg_inv_ex y H)

              (op_cancel_neg y H)).



Theorem op_inv_closed

  :  forall (x : M) (H : has_inv x) (y : M) (H0 : has_inv y), has_inv (x + y).

Proof

  fun x H y H0

    => ex_ind

         (fun u (H1 : op_is_inv x u)

           => ex_ind

                (fun v (H2 : op_is_inv y v)

                  => ex_intro

                       (op_is_inv (x + y))

                       (v + u)

                       (conj

                         (op_is_assoc (v + u) x y

                           || (v + u) + (x + y) = a + y @a by op_is_assoc v u x

                           || (v + u) + (x + y) = (v + a) + y @a by <- proj1 H1

                           || (v + u) + (x + y) = a + y @a by <- op_id_r v

                           || (v + u) + (x + y) = a @a by <- proj1 H2

                         ) 

                         (op_is_assoc (x + y) v u

                           || (x + y) + (v + u) = a + u @a by op_is_assoc x y v

                           || (x + y) + (v + u) = (x + a) + u @a by <- proj2 H2

                           || (x + y) + (v + u) = a + u @a by <- op_id_r x

                           || (x + y) + (v + u) = a @a by <- proj2 H1

                         )))

                H0)

         H.



End Theorems.



End Monoid.



Notation "0" := (Monoid.E_0) : monoid_scope.



Notation "x + y" := (Monoid.op x y) (at level 50, left associativity) : monoid_scope.



Notation "{+}" := (Monoid.op) : monoid_scope.



Notation "{-}" := (Monoid.op_neg _) : monoid_scope.

