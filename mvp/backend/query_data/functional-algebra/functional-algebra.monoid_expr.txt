

Require Import Description.

Require Import base.
(* base:
Notation "A || B @ X 'by' E"
  := (eq_ind_r (fun X => B) A E) (at level 40, left associativity).

Notation "A || B @ X 'by' <- H"
  := (eq_ind_r (fun X => B) A (eq_sym H)) (at level 40, left associativity).

Notation "A =:= B"
  := (eq_refl A : A = B) (at level 90).

Definition bool_dec0
  :  forall b : bool, {b = true}+{b = false}
  := bool_rect
      (fun b => {b = true}+{b = false})
         (left (true = false) (eq_refl true))
         (right (false = true) (eq_refl false)). *)

Require Import function.
(* function:
Definition is_injective (A B : Type) (f : A -> B) : Prop
  := forall x y : A, f x = f y -> x = y.

Definition is_onto (A B : Type) (f : A -> B) : Prop
  := forall y : B, exists x : A, f x = y.

Definition is_bijective (A B : Type) (f : A -> B) : Prop
  := is_injective A B f /\ is_onto A B f. *)

Require Import ProofIrrelevance.

Require Import Bool.

Require Import List.

Import ListNotations.

Require Import monoid.
(* monoid:
Require Import Description.
Require Import base.
Require Import function.
Require Import ProofIrrelevance.
Require Import Bool.

Require Import Arith.
Require Import Wf.
Require Import Wellfounded.
Require Import Wf_nat.

Module Monoid.

Definition is_assoc (T : Type) (f : T -> T -> T) : Prop := forall x y z : T, f x (f y z) = f (f x y) z.

Definition is_id_l (T : Type) (f : T -> T -> T) (E : T) : Prop := forall x : T, f E x = x.

Definition is_id_r (T : Type) (f : T -> T -> T) (E : T) : Prop := forall x : T, f x E = x.

Definition is_id (T : Type) (f : T -> T -> T) (E : T) : Prop := is_id_l T f E /\ is_id_r T f E.

Definition is_inv_l (T : Type) (f : T -> T -> T) (E : T) (_ : is_id T f E) (x y : T) : Prop := f y x = E.

Definition is_inv_r (T : Type) (f : T -> T -> T) (E : T) (_ : is_id T f E) (x y : T) : Prop := f x y = E.

Definition is_inv (T : Type) (f : T -> T -> T) (E : T) (H : is_id T f E) (x y : T) : Prop := is_inv_l T f E H x y /\ is_inv_r T f E H x y.

Structure Monoid : Type := monoid {

  E: Set;

  E_0: E;

  op: E -> E -> E;

  op_is_assoc : is_assoc E op;

  op_id_l : is_id_l E op E_0;

  op_id_r : is_id_r E op E_0
}.

Arguments E_0 {m}.

Arguments op {m} x y.

Arguments op_is_assoc {m} x y z.

Arguments op_id_l {m} x.

Arguments op_id_r {m} x.

Notation "0" := E_0 : monoid_scope.

Notation "x + y" := (op x y) (at level 50, left associativity) : monoid_scope.

Notation "{+}" := op : monoid_scope.

Open Scope monoid_scope.

Section Theorems.

Variable m : Monoid.

Let M := E m.

Definition op_is_id_l := is_id_l M {+}.

Definition op_is_id_r := is_id_r M {+}.

Definition op_is_id := is_id M {+}.

Theorem op_id
  :  is_id M {+} 0.
Proof conj op_id_l op_id_r.

Theorem op_id_l_uniq
  :  forall x : M, (op_is_id_l x) -> x = 0.
Proof
  fun x H
    => H 0 || a = 0 @a by <- op_id_r x.

Theorem op_id_r_uniq
  :  forall x : M, (op_is_id_r x) -> x = 0.
Proof
  fun x H
    => H 0 || a = 0 @a by <- op_id_l x.

Theorem op_id_uniq
  :  forall x : M, (op_is_id x) -> x = 0.
Proof
  fun x
    => and_ind (fun H _ => op_id_l_uniq x H).

Theorem op_intro_l
  :  forall x y z : M, x = y -> z + x = z + y.
Proof
  fun x y z H
    => f_equal ({+} z) H.

Theorem op_intro_r
  :  forall x y z : M, x = y -> x + z = y + z.
Proof
  fun x y z H
    =>  eq_refl (x + z)
       || x + z = a + z @a by <- H.

Definition op_is_inv_l := is_inv_l M {+} 0 op_id.

Definition op_is_inv_r := is_inv_r M {+} 0 op_id.

Definition op_is_inv := is_inv M {+} 0 op_id.

Definition has_inv_l
  := fun x => exists y : M, op_is_inv_l x y.

Definition has_inv_r
  := fun x => exists y : M, op_is_inv_r x y.

Definition has_inv
  := fun x => exists y : M, op_is_inv x y.

Theorem op_inv_l_r_eq
  :  forall x y : M, op_is_inv_l x y -> forall z : M, op_is_inv_r x z -> y = z.
Proof
  fun x y H1 z H2
    => op_is_assoc y x z
          || y + a = (y + x) + z @a by <- H2
          || a = (y + x) + z     @a by <- op_id_r y
          || y = a + z           @a by <- H1
          || y = a               @a by <- op_id_l z.

Theorem op_inv_sym
  :  forall x y : M, op_is_inv x y <-> op_is_inv y x.
Proof
  fun x y
    => conj
            (fun H : op_is_inv x y
              => conj (proj2 H) (proj1 H))
            (fun H : op_is_inv y x
              => conj (proj2 H) (proj1 H)).

Theorem op_cancel_l
  :  forall x y z : M, has_inv_l z -> z + x = z + y -> x = y.
Proof
  fun x y z H H0
    => ex_ind 
            (fun u H1
              => op_intro_l (z + x) (z + y) u H0
              || a = u + (z + y) @a by <- op_is_assoc u z x
              || (u + z) + x = a @a by <- op_is_assoc u z y
              || a + x = a + y   @a by <- H1
              || a = 0 + y       @a by <- op_id_l x
              || x = a           @a by <- op_id_l y)
            H.

Theorem op_cancel_r
  :  forall x y z : M, has_inv_r z -> x + z = y + z -> x = y.
Proof
  fun x y z H H0
    => ex_ind
            (fun u H1
              =>  op_intro_r (x + z) (y + z) u H0
              || a = (y + z) + u @a by op_is_assoc x z u
              || x + (z + u) = a @a by op_is_assoc y z u
              || x + a = y + a   @a by <- H1
              || a = y + 0       @a by <- op_id_r x
              || x = a           @a by <- op_id_r y)
            H.

Theorem op_inv_l_uniq
  :  forall x : M, has_inv_r x -> forall y z : M, op_is_inv_l x y -> op_is_inv_l x z -> z = y.
Proof
  fun x H y z H0 H1
    => let H2
            :  z + x = y + x
            := H1 || z + x = a @a by H0 in
          let H3
            :  z = y
            := op_cancel_r z y x H H2 in
          H3.

Theorem op_inv_r_uniq
  :  forall x : M, has_inv_l x -> forall y z : M, op_is_inv_r x y -> op_is_inv_r x z -> z = y.
Proof
  fun x H y z H0 H1
    => let H2
            :  x + z = x + y
            := H1 || x + z = a @a by H0 in
          let H3
            :  z = y
            := op_cancel_l z y x H H2 in
          H3.

Theorem op_inv_uniq
  :  forall x y z : M, op_is_inv x y -> op_is_inv x z -> z = y.
Proof
  fun x y z H H0
    => op_inv_l_uniq x
            (ex_intro (fun y => op_is_inv_r x y) y (proj2 H))
            y z (proj1 H) (proj1 H0).

Theorem op_inv_0_l
  :  op_is_inv_l 0 0.
Proof op_id_l 0 : 0 + 0 = 0.

Theorem op_inv_0_r
  :  op_is_inv_r 0 0.
Proof op_id_r 0 : 0 + 0 = 0.

Theorem op_inv_0
  :  op_is_inv 0 0.
Proof conj op_inv_0_l op_inv_0_r.

Theorem op_has_inv_l_0
  :  has_inv_l 0.
Proof ex_intro (op_is_inv_l 0) 0 op_inv_0_l.

Theorem op_has_inv_r_0
  :  has_inv_r 0.
Proof ex_intro (op_is_inv_r 0) 0 op_inv_0_r.

Theorem op_has_inv_0
  :  has_inv 0.
Proof ex_intro (op_is_inv 0) 0 op_inv_0.

Theorem op_inv_0_eq_0
  :  forall x : M, op_is_inv x 0 -> x = 0.
Proof
  fun x H
    => proj1 H
       || a = 0 @a by <- op_id_l x.

Theorem op_inv_0_uniq
  :  unique (fun x => op_is_inv x 0) 0.
Proof
  conj op_inv_0
    (fun x H => eq_sym (op_inv_0_eq_0 x H)).

Definition op_neg_strong
  :  forall x : M, has_inv x -> { y | op_is_inv x y }
  := fun x H
       => constructive_definite_description (op_is_inv x) 
            (ex_ind
              (fun y (H0 : op_is_inv x y)
                => ex_intro
                     (fun y => op_is_inv x y /\ forall z, op_is_inv x z -> y = z)
                     y
                     (conj H0 (fun z H1 => eq_sym (op_inv_uniq x y z H0 H1))))
              H).

Definition op_neg
  :  forall x : M, has_inv x -> M
  := fun x H => proj1_sig (op_neg_strong x H).

Notation "{-}" := (op_neg) : monoid_scope.

Theorem op_neg_def
  :  forall (x : M) (H : has_inv x), op_is_inv x ({-} x H).
Proof
  fun x H
    => proj2_sig (op_neg_strong x H).

Theorem op_neg_inv
  :  forall (x : M) (H : has_inv x), op_is_inv ({-} x H) x.
Proof
  fun x H
    => (proj1 (op_inv_sym x ({-} x H))) (op_neg_def x H).

Theorem op_neg_inv_ex
  :  forall (x : M) (H : has_inv x), has_inv ({-} x H).
Proof
  fun x H
    => ex_intro
         (op_is_inv ({-} x H))
         x
         (op_neg_inv x H).

Theorem op_neg_inj
  :  forall (x : M) (H : has_inv x) (y : M) (H0 : has_inv y),
     {-} x H = {-} y H0 ->
     x = y.
Proof
  fun x H y H0 H1
    => let H2
         :  x + ({-} x H) = y + ({-} x H) 
         := (proj2 (op_neg_def x H) : x + ({-} x H) = 0)
            || x + ({-} x H) = a     @a by proj2 (op_neg_def y H0)
            || x + ({-} x H) = y + a @a by H1 in
       let H3
         :  x = y
         := op_cancel_r x y ({-} x H)
            (ex_intro
              (op_is_inv_r ({-} x H))
              x
              (proj2 (proj1 (op_inv_sym x ({-} x H)) (op_neg_def x H))))
            H2 in
       H3.

Theorem op_cancel_neg_gen
  :  forall (x : M) (H : has_inv x) (H0 : has_inv ({-} x H)), {-} ({-} x H) H0 = x.
Proof
  fun x H H0
    => let H1
         :  op_is_inv ({-} x H) ({-} ({-} x H) H0)
         := op_neg_def ({-} x H) H0 in
       let H3
         :  op_is_inv ({-} x H) x
         := op_neg_inv x H in
       op_inv_uniq ({-} x H) x ({-} ({-} x H) H0) H3 H1.

Theorem op_cancel_neg
  :  forall (x : M) (H : has_inv x), {-} ({-} x H) (op_neg_inv_ex x H) = x.
Proof
  fun x H
    => op_cancel_neg_gen x H (op_neg_inv_ex x H).

Theorem op_neg_onto
  :  forall (y : M) (H : has_inv y), exists (x : M) (H0 : has_inv x), {-} x H0 = y.
Proof
  fun y H
    => ex_intro
            (fun x => exists H0 : has_inv x, {-} x H0 = y)
            ({-} y H)
            (ex_intro
              (fun H0 => {-} ({-} y H) H0 = y)
              (op_neg_inv_ex y H)
              (op_cancel_neg y H)).

Theorem op_inv_closed
  :  forall (x : M) (H : has_inv x) (y : M) (H0 : has_inv y), has_inv (x + y).
Proof
  fun x H y H0
    => ex_ind
         (fun u (H1 : op_is_inv x u)
           => ex_ind
                (fun v (H2 : op_is_inv y v)
                  => ex_intro
                       (op_is_inv (x + y))
                       (v + u)
                       (conj
                         (op_is_assoc (v + u) x y
                           || (v + u) + (x + y) = a + y @a by op_is_assoc v u x
                           || (v + u) + (x + y) = (v + a) + y @a by <- proj1 H1
                           || (v + u) + (x + y) = a + y @a by <- op_id_r v
                           || (v + u) + (x + y) = a @a by <- proj1 H2
                         ) 
                         (op_is_assoc (x + y) v u
                           || (x + y) + (v + u) = a + u @a by op_is_assoc x y v
                           || (x + y) + (v + u) = (x + a) + u @a by <- proj2 H2
                           || (x + y) + (v + u) = a + u @a by <- op_id_r x
                           || (x + y) + (v + u) = a @a by <- proj2 H1
                         )))
                H0)
         H.

End Theorems.

End Monoid.

Notation "0" := (Monoid.E_0) : monoid_scope.

Notation "x + y" := (Monoid.op x y) (at level 50, left associativity) : monoid_scope.

Notation "{+}" := (Monoid.op) : monoid_scope.

Notation "{-}" := (Monoid.op_neg _) : monoid_scope. *)

Import Monoid.



Module MonoidExpr.



Open Scope monoid_scope.



Section binary_trees.



Variable Term : Set.



Inductive BTree : Set

  := leaf : Term -> BTree

  |  node : BTree -> BTree -> BTree.



Definition BTree_is_node

  :  BTree -> bool

  := BTree_rec

       (fun _ => bool)

       (fun _ => false)

       (fun _ _ _ _ => true).



Definition BTree_is_leaf

  :  BTree -> bool

  := BTree_rec

       (fun _ => bool)

       (fun _ => true)

       (fun _ _ _ _ => false).



Definition BTree_is_rassoc

  :  BTree -> bool

  := BTree_rec

       (fun _ => bool)

       (fun _ => true)

       (fun t _ _ f

         => BTree_is_leaf t && f).



Theorem BTree_rassoc_thm

  :  forall t u : BTree, BTree_is_rassoc (node t u) = true -> BTree_is_rassoc u = true.

Proof

  fun t u H

    => proj2 (

            andb_prop 

              (BTree_is_leaf t)

              (BTree_is_rassoc u)

              H).



End binary_trees.



Arguments leaf {Term} x.



Arguments node {Term} t u.



Arguments BTree_is_leaf {Term} t.



Arguments BTree_is_node {Term} t.



Arguments BTree_is_rassoc {Term} t.



Arguments BTree_rassoc_thm {Term} t u H.



Structure Term_map : Type := term_map {

  
  term_map_m: Monoid;



  term_map_term : Set;



  term_map_eval : term_map_term -> E term_map_m;



  term_map_is_zero : term_map_term -> bool;



  term_map_is_zero_thm : forall t, term_map_is_zero t = true -> term_map_eval t = 0

}.



Arguments term_map_eval {t} x.



Arguments term_map_is_zero {t} x.



Arguments term_map_is_zero_thm {t} t0 H.



Section term_tree_functs.



Variable map : Term_map.



Let E := E (term_map_m map).



Let Term := term_map_term map.



Definition Term_is_nonzero

  :  Term -> bool

  := fun t => negb (term_map_is_zero t).



Definition BTree_eval

  :  BTree Term -> E

  := BTree_rec Term

       (fun _ => E)

       (fun t => term_map_eval t)

       (fun _ f _ g => f + g).



Definition BTree_eq

  :  BTree Term -> BTree Term -> Prop

  := fun t u => BTree_eval t = BTree_eval u.



Definition BTree_shift

  :  forall (t u : BTree Term), BTree_is_rassoc u = true -> { v : BTree Term | BTree_is_rassoc v = true /\ BTree_eq (node t u) v }

  := let P t u v

       := BTree_is_rassoc v = true /\ BTree_eq (node t u) v in

     let T t u

       := BTree_is_rassoc u = true -> { v | P t u v } in

     BTree_rec Term

       (fun t => forall u, T t u)

       (fun x u H

         => let v := node (leaf x) u in

            exist

              (P (leaf x) u)

              v

              (conj

                (andb_true_intro

                  (conj

                    (eq_refl true : BTree_is_leaf (leaf x) = true)

                    H))

                (eq_refl (BTree_eval v))))

       (fun t f u g v H

         => let (w, H0) := g v H in

            let (x, H1) := f w (proj1 H0) in

            exist

              (P (node t u) v)

              x

              (conj

                (proj1 H1)

                (proj2 H1

                  || BTree_eval t + a = BTree_eval x @a by proj2 H0

                  || a = BTree_eval x @a by <- op_is_assoc (BTree_eval t) (BTree_eval u) (BTree_eval v)))).



Definition BTree_rassoc

  :  forall t : BTree Term, { u : BTree Term | BTree_is_rassoc u = true /\ BTree_eq t u }

  := let P t u

       := BTree_is_rassoc u = true /\ BTree_eq t u in

     let T t

       := { u | P t u } in

     BTree_rec Term

       (fun t => T t)

       (fun x

         => let t := leaf x in

            exist

              (P t)

              t

              (conj

                (eq_refl true : BTree_is_leaf t = true) 

                (eq_refl (BTree_eval t))))

       (fun t _ u g

         => let (v, H) := g in

            let (w, H0) := BTree_shift t v (proj1 H) in

            exist

              (P (node t u))

              w

              (conj

                (proj1 H0)

                (proj2 H0

                  || BTree_eval t + a = BTree_eval w @a by (proj2 H)))).



Definition list_eval

  :  forall xs : list Term, E

  := list_rec

       (fun _ => E)

       0

       (fun x _ f => (term_map_eval x) + f).



Definition list_eq : list Term -> list Term -> Prop

  := fun xs ys : list Term

       => list_eval xs = list_eval ys.



Definition RABTree_list

  :  forall t : BTree Term, BTree_is_rassoc t = true -> { xs : list Term | BTree_eval t = list_eval xs }

  := let P t xs := BTree_eval t = list_eval xs in

     let T t := BTree_is_rassoc t = true -> { xs | P t xs } in

     BTree_rect Term

       (fun t => T t)

       (fun x _

         => let xs := [x] in

            exist

              (P (leaf x))

              xs

              (eq_sym (op_id_r (term_map_eval x))))

       (BTree_rect Term

         (fun t => T t -> forall u, T u -> T (node t u))

         (fun x _ u (g : T u) H

           => let H0

                :  BTree_is_rassoc u = true

                := BTree_rassoc_thm (leaf x) u H in

              let (ys, H1) := g H0 in

              let xs := x :: ys in

              exist

                (P (node (leaf x) u))

                xs

                (eq_refl ((term_map_eval x) + (BTree_eval u))

                  || (term_map_eval x) + (BTree_eval u) = (term_map_eval x) + a @a by <- H1))

         (fun t _ u _ _ v _ H

           => False_rec

                { xs | P (node (node t u) v) xs }

                (diff_false_true H))).



Definition list_filter_0

  :  forall xs : list Term, {ys : list Term | list_eq xs ys /\ Is_true (forallb Term_is_nonzero ys)}

  := let P xs ys := list_eq xs ys /\ Is_true (forallb Term_is_nonzero ys) in

     let T xs := { ys | P xs ys } in

     list_rec

       T

       (exist

         (P [])

         []

         (conj

           (eq_refl E_0)

           I))

       (fun x

         => (sumbool_rec

              (fun _ => forall xs : list Term, T xs -> T (cons x xs))

              (fun (H : term_map_is_zero x = true) xs f

                => let H0

                     :  term_map_eval x = 0

                     := term_map_is_zero_thm x H in

                   let (ys, H1) := f in

                   exist

                     (P (x :: xs))

                     ys

                     (conj

                       (op_id_l (list_eval xs)

                         || 0 + (list_eval xs) = a @a by <- (proj1 H1)

                         || a + (list_eval xs) = list_eval ys @a by H0)

                       (proj2 H1)))

              (fun (H : term_map_is_zero x = false) xs f

                => let (ys, H0) := f in

                   let zs := x :: ys in

                   exist

                     (P (x :: xs))

                     zs

                     (conj

                       (eq_refl (list_eval (x :: xs))

                         || term_map_eval x + (list_eval xs) = term_map_eval x + a @a by <- (proj1 H0))

                       (Is_true_eq_left

                         (forallb Term_is_nonzero zs)

                         (andb_true_intro

                           (conj

                             (eq_refl (Term_is_nonzero x)

                               || Term_is_nonzero x = negb a @a by <- H)

                             (Is_true_eq_true

                               (forallb Term_is_nonzero ys)

                               (proj2 H0)))))))

              (bool_dec0 (term_map_is_zero x)))).



Definition reduce

  :  forall t : BTree Term, { xs : list Term | BTree_eval t = list_eval xs }

  := fun t

       => let (u, H) := BTree_rassoc t in

          let (xs, H0) := RABTree_list u (proj1 H) in

          let (ys, H1) := list_filter_0 xs in

          exist

            (fun ys => BTree_eval t = list_eval ys)

            ys

            ((proj2 H)

              || BTree_eval t = a @a by <- H0

              || BTree_eval t = a @a by <- (proj1 H1)).



End term_tree_functs.



Section monoid_term_map.



Variable m : Monoid.



Let E := E m.



Inductive Term : Set

  := term_0 : Term

  |  term_const : E -> Term.



Definition Term_eval

  :  Term -> E

  := Term_rec

       (fun _ => E)

       0

       (fun x => x).



Definition Term_is_zero

  :  Term -> bool

  := Term_rec

       (fun _ => bool)

       true

       (fun _ => false).



Theorem Term_is_zero_thm

  :  forall t, Term_is_zero t = true -> Term_eval t = 0.

Proof

  Term_ind

    (fun t => Term_is_zero t = true -> Term_eval t = 0)

       (fun _ => eq_refl 0)

       (fun x H

         => False_ind

              (Term_eval (term_const x) = 0)

              (diff_false_true H)).



Definition MTerm_map

  :  Term_map

  := term_map m Term Term_eval Term_is_zero Term_is_zero_thm.



End monoid_term_map.



Arguments term_0 {m}.



Arguments term_const {m} x.



Ltac encode m x 

  := lazymatch x with

       | (0)

         => exact (MonoidExpr.leaf (MonoidExpr.term_0 (m:=m)))

       | ({+} ?X ?Y)

         => exact

              (MonoidExpr.node

                (ltac:(encode m X))

                (ltac:(encode m Y)))

       | (?X)

         => exact (MonoidExpr.leaf (MonoidExpr.term_const X))

     end.



End MonoidExpr.



Notation "'reflect' x 'as' t ==> y 'as' u 'using' m"

  := (let r := MonoidExpr.reduce m t in

      let s := MonoidExpr.reduce m u in

      let v := proj1_sig r in

      let w := proj1_sig s in

      let H

        :  MonoidExpr.list_eval m v = MonoidExpr.list_eval m w

        := eq_refl (MonoidExpr.list_eval m v) : MonoidExpr.list_eval m v = MonoidExpr.list_eval m w in

      let H0

        :  MonoidExpr.BTree_eval m t = MonoidExpr.list_eval m v

        := proj2_sig r in

      let H1

        :  MonoidExpr.BTree_eval m u = MonoidExpr.list_eval m w

        := proj2_sig s in

      let H2

        :  MonoidExpr.BTree_eval m t = x

        := eq_refl (MonoidExpr.BTree_eval m t) : MonoidExpr.BTree_eval m t = x in

      let H3

        :  MonoidExpr.BTree_eval m u = y

        := eq_refl (MonoidExpr.BTree_eval m u) : MonoidExpr.BTree_eval m u = y in

      H

      || a = MonoidExpr.list_eval m w @a by H0

      || a = MonoidExpr.list_eval m w @a by H2

      || x = a @a by H1

      || x = a @a by H3

      : x = y)

      (at level 40, left associativity).



Notation "'rewrite' A ==> B 'using' C"

  := (reflect A

       as (ltac:(MonoidExpr.encode (MonoidExpr.term_map_m C) A))

      ==> B

       as (ltac:(MonoidExpr.encode (MonoidExpr.term_map_m C) B)) using C

      : A = B)

     (at level 40, left associativity).



Section Unittests.



Variable m : Monoid.



Variables a b c d : E m.



Let map := MonoidExpr.MTerm_map m.



Let reflect_test_0

  :  (a + 0) = (0 + a)

  := rewrite (a + 0) ==> (0 + a) using map.



Let reflect_test_1

  :  (a + 0) + (0 + b) = a + b

  := rewrite ((a + 0) + (0 + b)) ==> (a + b) using map.



Let reflect_test_2

  :  (0 + a) + b = (a + b)

  := rewrite ((0 + a) + b) ==> (a + b) using map.



Let reflect_test_3

  :  (a + b) + (c + d) = a + ((b + c) + d)

  := rewrite (a + b) + (c + d) ==> a + ((b + c) + d) using map.



Let reflect_test_4

  :  (a + b) + (0 + c) = (a + 0) + (b + c)

  := rewrite (a + b) + (0 + c) ==> (a + 0) + (b + c) using map.



Let reflect_test_5

  :  (((a + b) + c) + 0) = (((0 + a) + b) + c)

  := rewrite (((a + b) + c) + 0) ==> (((0 + a) + b) + c) using map.



End Unittests.

