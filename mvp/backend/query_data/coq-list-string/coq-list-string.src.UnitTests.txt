Require Import Coq.Lists.List.

Require Import Coq.NArith.NArith.

Require Import Coq.ZArith.ZArith.

Require Import Coq.Strings.Ascii.

Require Import Coq.Strings.String.

Require Import CUnit.All.

Require Conversion.



Import ListNotations.

Local Open Scope char.

Local Open Scope N.



Definition s := Conversion.s.



Module Case.

  Require Import Case.
(* Case:
Require Import Coq.Lists.List.
Require Char.
Require Import LString.

Import ListNotations.
Import LString.

Definition capitalize (s : t) : t :=
  match s with
  | [] => []
  | c :: s => Char.up_case c :: s
  end.

Definition down_case (s : t) : t :=
  List.map Char.down_case s.

Definition up_case (s : t) : t :=
  List.map Char.up_case s. *)



  Definition test_capitalize :

    List.map capitalize [s ""; s "A"; s "aAgZ,3%"] = [s ""; s "A"; s "AAgZ,3%"] :=

    eq_refl.



  Definition test_down_case :

    List.map down_case [s ""; s "aAgZ,3%"] = [s ""; s "aagz,3%"] :=

    eq_refl.



  Definition test_up_case :

    List.map up_case [s ""; s "aAgZ,3%"] = [s ""; s "AAGZ,3%"] :=

    eq_refl.

End Case.



Module Char.

  Require Import Char.
(* Char:
Require Import Coq.NArith.NArith.
Require Import Coq.Strings.Ascii.
Require Bool.

Local Open Scope char.
Local Open Scope N.

Definition compare (x y : Ascii.ascii) : comparison :=
  N.compare (Ascii.N_of_ascii x) (Ascii.N_of_ascii y).

Lemma compare_implies_eq : forall (x y : Ascii.ascii),

Lemma compare_same_is_eq : forall (x : Ascii.ascii), compare x x = Eq.

Definition eqb (x y : Ascii.ascii) : bool :=
  match compare x y with
  | Eq => true
  | _ => false
  end.

Definition of_N (n : N) : Ascii.ascii :=
  if N.leb n 9 then
    Ascii.ascii_of_N (Ascii.N_of_ascii "0" + n)
  else
    Ascii.ascii_of_N (Ascii.N_of_ascii "A" + n - 10).

Definition to_N (c : Ascii.ascii) : option N :=
  let n := Ascii.N_of_ascii c in
  if andb (N.leb (Ascii.N_of_ascii "0") n) (N.leb n (Ascii.N_of_ascii "9")) then
    Some (n - Ascii.N_of_ascii "0")
  else if N.leb (Ascii.N_of_ascii "A") n then
    Some (n - Ascii.N_of_ascii "A" + 10)
  else
    None.

Definition is_ascii (c : Ascii.ascii) : bool :=
  match c with
  | Ascii.Ascii _ _ _ _ _ _ _ false => true
  | _ => false
  end.

Definition is_white_space (c : Ascii.ascii) : bool :=
  match c with
  | "009" | "010" | "011" | "012" | "013" | " " => true
  | _ => false
  end.

Definition down_case (c : Ascii.ascii) : Ascii.ascii :=
  let n := Ascii.N_of_ascii c in
  let n_A := Ascii.N_of_ascii "A" in
  let n_Z := Ascii.N_of_ascii "Z" in
  let n_a := Ascii.N_of_ascii "a" in
  if andb (N.leb n_A n) (N.leb n n_Z) then
    Ascii.ascii_of_N ((n + n_a) - n_A)
  else
    c.

Definition up_case (c : Ascii.ascii) : Ascii.ascii :=
  let n := Ascii.N_of_ascii c in
  let n_a := Ascii.N_of_ascii "a" in
  let n_z := Ascii.N_of_ascii "z" in
  let n_A := Ascii.N_of_ascii "A" in
  if andb (N.leb n_a n) (N.leb n n_z) then
    Ascii.ascii_of_N ((n + n_A) - n_a)
  else
    c.

Definition a : Ascii.ascii := "007".

Definition b : Ascii.ascii := "008".

Definition t : Ascii.ascii := "009".

Definition n : Ascii.ascii := "010".

Definition v : Ascii.ascii := "011".

Definition f : Ascii.ascii := "012".

Definition r : Ascii.ascii := "013".

Definition e : Ascii.ascii := "027". *)



  Definition test_of_N :

    List.map of_N [0; 1; 5; 9; 10; 12; 23] =

      ["0"; "1"; "5"; "9"; "A"; "C" ; "N"] :=

    eq_refl.



  Definition test_to_N :

    List.map to_N ["0"; "1"; "5"; "9"; "A"; "C" ; "N"; "."] =

      [Some 0; Some 1; Some 5; Some 9; Some 10; Some 12; Some 23; None] :=

    eq_refl.



  Definition test_is_ascii :

    List.map is_ascii ["A"; "?"; """"; "010"; "127"; "128"; "255"] =

      [true; true; true; true; true; false; false] :=

      eq_refl.



  Definition test_is_white_space :

    List.map is_white_space [" "; "010"; "r"; ","] =

      [true; true; false; false] :=

      eq_refl.



  Definition test_down_case :

    List.map down_case ["a"; "A"; "g"; "Z"; ","; """"; "128"; "255"] =

      ["a"; "a"; "g"; "z"; ","; """"; "128"; "255"] :=

      eq_refl.



  Definition test_up_case :

    List.map up_case ["a"; "A"; "g"; "Z"; ","; """"; "128"; "255"] =

      ["A"; "A"; "G"; "Z"; ","; """"; "128"; "255"] :=

      eq_refl.

End Char.



Module Comparison.

  

End Comparison.



Module Conversion.

  Require Import Conversion.
(* Conversion:
Require Import Coq.Lists.List.
Require Import Coq.NArith.NArith.
Require Import Coq.ZArith.ZArith.
Require Import Coq.Strings.Ascii.
Require Import Coq.Strings.String.
Require Import ErrorHandlers.All.
Require Import ListPlus.All.
Require Char.
Require Import LString.

Import ListNotations.
Import LString.
Local Open Scope char.

Fixpoint to_string (s : t) : String.string :=
  match s with
  | [] => String.EmptyString
  | c :: s => String.String c (to_string s)
  end.

Fixpoint of_string (s : String.string) : t :=
  match s with
  | String.EmptyString => []
  | String.String c s => c :: of_string s
  end.

Definition s := of_string.

Fixpoint of_N_aux (base : N) (digits : nat) (padding : option Ascii.ascii)
  (n : N) : t :=
  match n with
  | 0%N =>
    match padding with
    | None => []
    | Some padding => List.repeat padding digits
    end
  | _ =>
    match digits with
    | O => []
    | S digits =>
      Char.of_N (N.modulo n base) ::
        of_N_aux base digits padding (N.div n base)
    end
  end.

Definition of_N (base : N) (digits : nat) (padding : option Ascii.ascii) (n : N)
  : t :=
  match n with
  | 0%N =>
    match digits with
    | O => []
    | S digits =>
      match padding with
      | None => ["0"]
      | Some padding => List.repeat padding digits ++ ["0"]
      end
    end
  | _ => List.rev' (of_N_aux base digits padding n)
  end.

Definition of_Z (base : N) (digits : nat) (n : Z) : t :=
  (if Z.leb 0 n then s "" else s "-") ++
  of_N base digits None (Z.to_N (Z.abs n)).

Fixpoint to_N_aux (base : N) (s : t) : option N :=
  match s with
  | [] => Some 0%N
  | c :: s =>
    Option.bind (Char.to_N c) (fun d =>
    if andb (N.leb 0 d) (N.ltb d base) then
      Option.bind (to_N_aux base s) (fun n =>
      Some (d + base * n)%N)
    else
      None)
  end.

Definition to_N (base : N) (s : t) : option N :=
  to_N_aux base (List.rev' s). *)



  Definition test_to_string :

    List.map to_string [

      [];

      ["h"; "e"; "l"; "l"; "o"]] = [

      "";

      "hello"] % string :=

    eq_refl.



  Definition test_of_string :

    List.map of_string [

      "";

      "hello"] % string = [

      [];

      ["h"; "e"; "l"; "l"; "o"]] :=

    eq_refl.



  Definition test_of_N :

    List.map_quad of_N [

      (10, 0%nat, None, 0);

      (10, 0%nat, None, 10);



      (2, 10%nat, None, 0);

      (2, 10%nat, None, 1);

      (2, 10%nat, None, 2);

      (2, 10%nat, None, 3);

      (2, 10%nat, None, 12);

      (2, 10%nat, None, 23);



      (8, 10%nat, None, 0);

      (8, 10%nat, None, 1);

      (8, 10%nat, None, 2);

      (8, 10%nat, None, 3);

      (8, 10%nat, None, 12);

      (8, 10%nat, None, 23);



      (10, 10%nat, None, 0);

      (10, 10%nat, None, 1);

      (10, 10%nat, None, 2);

      (10, 10%nat, None, 3);

      (10, 10%nat, None, 12);

      (10, 10%nat, None, 23);



      (16, 10%nat, None, 0);

      (16, 10%nat, None, 1);

      (16, 10%nat, None, 2);

      (16, 10%nat, None, 3);

      (16, 10%nat, None, 12);

      (16, 10%nat, None, 23);



      (2, 3%nat, None, 0);

      (2, 3%nat, None, 1);

      (2, 3%nat, None, 2);

      (2, 3%nat, None, 3);

      (2, 3%nat, None, 12);

      (2, 3%nat, None, 23);



      (10, 0%nat, Some "*", 0);

      (10, 0%nat, Some "*", 10);



      (2, 5%nat, Some "*", 0);

      (2, 5%nat, Some "*", 1);

      (2, 5%nat, Some "*", 2);

      (2, 5%nat, Some "*", 3);

      (2, 5%nat, Some "*", 12);

      (2, 5%nat, Some "*", 23);



      (8, 5%nat, Some "*", 0);

      (8, 5%nat, Some "*", 1);

      (8, 5%nat, Some "*", 2);

      (8, 5%nat, Some "*", 3);

      (8, 5%nat, Some "*", 12);

      (8, 5%nat, Some "*", 23);



      (10, 5%nat, Some "*", 0);

      (10, 5%nat, Some "*", 1);

      (10, 5%nat, Some "*", 2);

      (10, 5%nat, Some "*", 3);

      (10, 5%nat, Some "*", 12);

      (10, 5%nat, Some "*", 23);



      (16, 5%nat, Some "*", 0);

      (16, 5%nat, Some "*", 1);

      (16, 5%nat, Some "*", 2);

      (16, 5%nat, Some "*", 3);

      (16, 5%nat, Some "*", 12);

      (16, 5%nat, Some "*", 23);



      (2, 3%nat, Some "0", 0);

      (2, 3%nat, Some "0", 1);

      (2, 3%nat, Some "0", 2);

      (2, 3%nat, Some "0", 3);

      (2, 3%nat, Some "0", 12);

      (2, 3%nat, Some "0", 23)] = [

      s "";

      s "";



      s "0";

      s "1";

      s "10";

      s "11";

      s "1100";

      s "10111";



      s "0";

      s "1";

      s "2";

      s "3";

      s "14";

      s "27";



      s "0";

      s "1";

      s "2";

      s "3";

      s "12";

      s "23";



      s "0";

      s "1";

      s "2";

      s "3";

      s "C";

      s "17";



      s "0";

      s "1";

      s "10";

      s "11";

      s "100";

      s "111";



      s "";

      s "";



      s "****0";

      s "****1";

      s "***10";

      s "***11";

      s "*1100";

      s "10111";



      s "****0";

      s "****1";

      s "****2";

      s "****3";

      s "***14";

      s "***27";



      s "****0";

      s "****1";

      s "****2";

      s "****3";

      s "***12";

      s "***23";



      s "****0";

      s "****1";

      s "****2";

      s "****3";

      s "****C";

      s "***17";



      s "000";

      s "001";

      s "010";

      s "011";

      s "100";

      s "111"] :=

    eq_refl.



  Definition test_of_Z :

    List.map_triple of_Z [

      (2, 10%nat, 0%Z);

      (2, 10%nat, 1%Z);

      (2, 10%nat, 2%Z);

      (2, 10%nat, (-3)%Z);

      (2, 10%nat, (-12)%Z);

      (2, 10%nat, 23%Z);



      (8, 10%nat, 0%Z);

      (8, 10%nat, 1%Z);

      (8, 10%nat, 2%Z);

      (8, 10%nat, (-3)%Z);

      (8, 10%nat, (-12)%Z);

      (8, 10%nat, 23%Z);



      (10, 10%nat, 0%Z);

      (10, 10%nat, 1%Z);

      (10, 10%nat, 2%Z);

      (10, 10%nat, (-3)%Z);

      (10, 10%nat, (-12)%Z);

      (10, 10%nat, 23%Z);



      (16, 10%nat, 0%Z);

      (16, 10%nat, 1%Z);

      (16, 10%nat, 2%Z);

      (16, 10%nat, (-3)%Z);

      (16, 10%nat, (-12)%Z);

      (16, 10%nat, 23%Z);



      (2, 3%nat, 0%Z);

      (2, 3%nat, 1%Z);

      (2, 3%nat, 2%Z);

      (2, 3%nat, (-3)%Z);

      (2, 3%nat, (-12)%Z);

      (2, 3%nat, 23%Z)] = [

      s "0";

      s "1";

      s "10";

      s "-11";

      s "-1100";

      s "10111";



      s "0";

      s "1";

      s "2";

      s "-3";

      s "-14";

      s "27";



      s "0";

      s "1";

      s "2";

      s "-3";

      s "-12";

      s "23";



      s "0";

      s "1";

      s "2";

      s "-3";

      s "-C";

      s "17";



      s "0";

      s "1";

      s "10";

      s "-11";

      s "-100";

      s "111"] :=

    eq_refl.



  Definition test_to_N :

    List.map_pair to_N [

      (2, s "0");

      (2, s "1");

      (2, s "10");

      (2, s "11");

      (2, s "1100");

      (2, s "10111");



      (8, s "0");

      (8, s "1");

      (8, s "2");

      (8, s "3");

      (8, s "14");

      (8, s "27");



      (10, s "0");

      (10, s "1");

      (10, s "2");

      (10, s "3");

      (10, s "12");

      (10, s "23");



      (16, s "0");

      (16, s "1");

      (16, s "2");

      (16, s "3");

      (16, s "C");

      (16, s "17");



      (2, s "2");

      (8, s "8");

      (10, s "A");

      (16, s "G");

      (10, s "G")] = [

      Some 0; Some 1; Some 2; Some 3; Some 12; Some 23;

      Some 0; Some 1; Some 2; Some 3; Some 12; Some 23;

      Some 0; Some 1; Some 2; Some 3; Some 12; Some 23;

      Some 0; Some 1; Some 2; Some 3; Some 12; Some 23;

      None; None; None; None; None] :=

    eq_refl.

End Conversion.



Module Etc.

  Require Import Etc.



  Definition test_is_ascii :

    List.map is_ascii [s ""; s "ahah"; "128" :: s "ahah"] = [true; true; false] :=

    eq_refl.



  Definition test_is_empty :

    List.map is_empty [s ""; s "aAgZ"] = [true; false] :=

    eq_refl.



  Definition test_repeat :

    List.map_pair repeat [(s "", 0); (s "", 2); (s "ab", 0); (s "ab", 2)] % nat =

      [s ""; s ""; s ""; s "abab"] :=

      eq_refl.



  Definition test_center :

    List.map_pair center [(s "", 4); (s "a", 4); (s "ab", 4); (s "abcd", 4);

      (s "abcde", 4); (s "ab", 0)] % nat = [

      s "    "; s " a  "; s " ab "; s "abcd"; s "abcde"; s "ab"] :=

    eq_refl.



  Definition test_join :

    List.map_pair join [

      (s "", []);

      (s ", ", []);

      (s "", [s "hello"; s "world"]);

      (s ", ", [s "hello"; s "world"])] = [

      s "";

      s "";

      s "helloworld";

      s "hello, world"] :=

    eq_refl.



  Definition test_split :

    List.map_pair split [

      (s "", " ");

      (s "go stop go", " ");

      (s "go stop go ", " ");

      (s "go stop go  ", " ");

      (s "grr", " ")] = [

      [s ""];

      [s "go"; s "stop"; s "go"];

      [s "go"; s "stop"; s "go"; s ""];

      [s "go"; s "stop"; s "go"; s ""; s ""];

      [s "grr"]] :=

    eq_refl.



  Definition test_split_limit :

    List.map_triple split_limit [

      (s "", " ", 2);

      (s "go stop go", " ", 0);

      (s "go stop go ", " ", 3);

      (s "go stop go  ", " ", 1);

      (s "grr", " ", 4)] % nat = [

      [s ""];

      [];

      [s "go"; s "stop"; s "go "];

      [s "go stop go  "];

      [s "grr"]] :=

    eq_refl.



  Definition test_escape_html :

    List.map escape_html [

      s "";

      s "hello";

      s "&";

      s "'""&<>"] = [

      s "";

      s "hello";

      s "&amp;";

      s "&apos;&quot;&amp;&lt;&gt;"] :=

    eq_refl.

End Etc.



Module Trim.

  Require Import Trim.
(* Trim:
Require Import Coq.Lists.List.
Require Import Coq.Strings.Ascii.
Require Char.
Require Import LString.

Import ListNotations.
Import LString.
Local Open Scope char.

Fixpoint chomp (s : t) : t :=
  match s with
  | [] => []
  | ["010"] | ["013"] | ["013"; "010"] => []
  | c :: s => c :: chomp s
  end.

Fixpoint trim_head (s : t) : t :=
  match s with
  | [] => []
  | c :: s' =>
    if Char.is_white_space c then
      trim_head s'
    else
      s
  end.

Fixpoint trim_tail (s : t) : t :=
  match s with
  | [] => []
  | c :: s =>
    match trim_tail s with
    | [] =>
      if Char.is_white_space c then
        []
      else
        [c]
    | s => c :: s
    end
  end.

Definition trim (s : t) : t :=
  trim_head (trim_tail s). *)



  Definition test_chomp :

    List.map chomp [s ""; s "aa"; s "aa "; s "aa" ++ ["010"];

      s "aa" ++ ["010"; "013"]; s "aa" ++ ["013"; "010"]] =

      [s ""; s "aa"; s "aa "; s "aa"; s "aa" ++ ["010"]; s "aa"] :=

    eq_refl.



  Definition test_trim_head :

    List.map trim_head [s ""; s "aa"; s "a "; s " aa"; s "  a"; "011" :: s "aa"] =

      [s ""; s "aa"; s "a "; s "aa"; s "a"; s "aa"] :=

    eq_refl.



  Definition test_trim_tail :

    List.map trim_tail [s ""; s "aa"; s "a "; s " aa"; s "a  "; "011" :: s "aa"] =

      [s ""; s "aa"; s "a"; s " aa"; s "a"; "011" :: s "aa"] :=

    eq_refl.



  Definition test_trim :

    List.map trim [s ""; s "aa"; s "a "; s " aa"; s "a  "; "011" :: s "aa"] =

      [s ""; s "aa"; s "a"; s "aa"; s "a"; s "aa"] :=

    eq_refl.

End Trim.
