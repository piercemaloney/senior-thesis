
Require Export freepoints.
(* freepoints:
Set Nested Proofs Allowed.
Require Export area_elimination_lemmas.
Require Import Classical.

Lemma parallel_dec : forall A B C D, parallel A B C D \/ ~ parallel A B C D.

Ltac cases_parallel A B C D := elim (parallel_dec A B C D);intros.

Definition Det3 (x1 x2 x3 y1 y2 y3 z1 z2 z3 : F) : F :=
  x1 * (y2 * z3) - x1 * (y3 * z2) - x2 * (y1 * z3) + x2 * (y3 * z1) +
  x3 * (y1 * z2) - x3 * (y2 * z1).

Lemma freepoint_elimination_aux : forall O U V B Y:Point, ~ Col O U V ->
S O B Y = 1/ (S O U V) * (S O B V * S O U Y + S O B U * S O Y V).

Lemma  free_points_area_elimination :
    forall O U V A B Y : Point, 
    S O U V <> 0 ->
    S A B Y =
    Det3 (S O U A) (S O V A) 1 (S O U B) (S O V B) 1 (S O U Y) (S O V Y) 1 /
    S O U V.

Lemma free_points_ratio_elimination_1 : forall O U V A B C D : Point,
  parallel A B C D ->
  C<>D ->
  S O U V <> 0 ->
  S U A B <> 0 ->
  A**B / C**D = (S O U A * S O V B + S O U A * S O U V - S O V A * S O U B -
 S O U B * S O U V) /
(S O U A * S O V D - S O U A * S O V C + S O V A * S O U C -
 S O V A * S O U D + S O U V * S O U C - S O U V * S O U D).

Lemma free_point_ratio_elimination_2 : forall O U V A B C D : Point,
  parallel A B C D ->
  C<>D ->
  S O U V <> 0 ->
  S V A B <> 0 ->
  A**B / C**D = (S O V A * S O U B + S O V A * S O V U - S O U A * S O V B -
 S O V B * S O V U) /
(S O V A * S O U D - S O V A * S O U C + S O U A * S O V C -
 S O U A * S O V D + S O V U * S O V C - S O V U * S O V D).

Lemma free_points_ratio_elimination_3 : forall O U V A B C D : Point,
  parallel A B C D ->
  A<>B ->
  C<>D ->
  S O U V <> 0 ->
  S U C D <> 0 ->
  A**B / C**D = (S O U C * S O V B - S O U C * S O V A + S O V C * S O U A -
  S O V C * S O U B + S O U V * S O U A - S O U V * S O U B)/
  (S O U C * S O V D + S O U C * S O U V - S O V C * S O U D -
  S O U D * S O U V).

Lemma free_points_ratio_elimination_4 : forall O U V A B C D : Point,
  parallel A B C D ->
  A<>B ->
  C<>D ->
  S O U V <> 0 ->
  S V C D <> 0 ->
  A**B / C**D = (S O V C * S O U B - S O V C * S O U A + S O U C * S O V A -
 S O U C * S O V B + S O V U * S O V A - S O V U * S O V B) /
(S O V C * S O U D + S O V C * S O V U - S O U C * S O V D -
 S O V D * S O V U).

Lemma free_points_ratio_elimination_5 : forall O U V A B C D: Point,
  parallel A B C D ->
  C<>D ->
  ~ Col O U V ->
  ~ Col A C D ->
  A**B / C**D = (S O U C * S O V A - S O U C * S O V B - S O V A * S O U B +
 S O V B * S O U A - S O V C * S O U A + S O V C * S O U B) /
(S O U C * S O V A - S O U C * S O V D - S O V A * S O U D -
 S O V C * S O U A + S O V C * S O U D + S O U A * S O V D) .

Lemma free_points_ratio_elimination_6 : forall O U V A B C D: Point,
  parallel A B C D ->
  C<>D ->
  ~ Col O U V ->
  ~ Col O A C ->
  Col A C D ->
  A**B / C**D = (S O U A * S O V B - S O V A * S O U B) /
(S O U C * S O V D - S O V C * S O U D).

Lemma free_points_ratio_elimination_6_non_zero_denom: forall O U V A B C D: Point,
  parallel A B C D ->
  C<>D ->
  ~ Col O U V ->
  ~ Col O A C ->
  Col A C D ->
  S O U C * S O V D - S O V C * S O U D <> 0.

Lemma free_points_ratio_elimination_7 : forall O U V A B C D: Point,
  parallel A B C D ->
  C<>D ->
  ~ Col O U V ->
  ~ Col U A C ->
  Col A C D ->
  A**B / C**D = 
 (S O U V * (S O U B - S O U A) - S O U A * S O V B + S O U B * S O V A) /
 (S O U V * (S O U D - S O U C) - S O U C * S O V D + S O U D * S O V C).

Lemma free_points_ratio_elimination_7_non_zero_denom : 
  forall O U V A B C D: Point,
  parallel A B C D ->
  C<>D ->
  ~ Col O U V ->
  ~ Col U A C ->
  Col A C D ->
  (S O U V * (S O U D - S O U C) - S O U C * S O V D + S O U D * S O V C) <> 0.

Lemma free_points_ratio_elimination_8 : forall O U V A B C D: Point,
  parallel A B C D ->
  C<>D ->
  ~ Col O U V ->
  ~ Col V A C ->
  Col A C D ->
  A**B / C**D = 
    ( S O U V * (S O V B - S O V A) + S O V A * S O U B - S O V B * S O U A) /
    ( S O U V * (S O V D - S O V C) + S O V C * S O U D - S O V D * S O U C).
Proof.
intros.

rewrite (free_points_ratio_elimination_7 O V U A B C D) by auto with Geom.
replace (S O V U) with (- S O U V) by auto with Geom.
field.
replace (- S O U V) with (S O V U) by auto with Geom.
split.
replace (S O U V) with (- S O V U) by auto with Geom.
replace (- S O V U * (S O V D - S O V C) + S O V C * S O U D - S O V D * S O U C)
with    (- (S O V U * (S O V D - S O V C) - S O V C * S O U D + S O V D * S O U C))
 by ring.
Lemma aux: forall x, x<>0 -> -x<>0. *)

Ltac freepoints_independant A B C H D E F :=
  rewrite (free_points_area_elimination A B C D E F H) in *.

Ltac iter_coord_expr A B C H E :=
  match constr:(E) with
  | (?X1 = ?X2) =>
      iter_coord_expr A B C H X1; iter_coord_expr A B C H X2
  | (?X1 + ?X2) =>
      iter_coord_expr A B C H X1; iter_coord_expr A B C H X2
  | (?X1 * ?X2) =>
      iter_coord_expr A B C H X1; iter_coord_expr A B C H X2
  | (?X1 / ?X2) =>
      iter_coord_expr A B C H X1; iter_coord_expr A B C H X2
  | (?X1 - ?X2) =>
      iter_coord_expr A B C H X1; iter_coord_expr A B C H X2
  | (- ?X1) => iter_coord_expr A B C H X1
  | (/ ?X1) => iter_coord_expr A B C H X1
  | ?X5 =>
      match constr:(X5) with
      | (S ?X1 ?X2 ?X3) =>
          match constr:(X1) with
          | A =>
              match constr:(X2) with
              | B => idtac
              | C => idtac
              | _ =>
                  match constr:(X3) with
                  | B => idtac
                  | C => idtac
                  | _ => freepoints_independant A B C H X1 X2 X3
                  end
              end
          | B =>
              match constr:(X2) with
              | A => idtac
              | _ =>
                  match constr:(X3) with
                  | A => idtac
                  | _ => freepoints_independant A B C H X1 X2 X3
                  end
              end
          | C =>
              match constr:(X2) with
              | A => idtac
              | _ =>
                  match constr:(X3) with
                  | A => idtac
                  | _ => freepoints_independant A B C H X1 X2 X3
                  end
              end
          | _ =>
              match constr:(X2) with
              | A =>
                  match constr:(X3) with
                  | C => idtac
                  | B => idtac
                  | _ => freepoints_independant A B C H X1 X2 X3
                  end
              | B =>
                  match constr:(X3) with
                  | A => idtac
                  | _ => freepoints_independant A B C H X1 X2 X3
                  end
              | C =>
                  match constr:(X3) with
                  | A => idtac
                  | _ => freepoints_independant A B C H X1 X2 X3
                  end
              | _ => freepoints_independant A B C H X1 X2 X3
              end
          end
      | _ => idtac
      end
  end.

Ltac only_use_area_coordinates :=
  unfold Det3,Col in *;
   match goal with
   | H:(S ?X1 ?X2 ?X3 <> 0) |- ?X4 =>
       
       iter_coord_expr X1 X2 X3 H X4; unfold Det3 in *; basic_simpl;
        uniformize_signed_areas; basic_simpl
   | A:Point, B:Point, H:?A<>?B |- ?X4 =>
       
       let T := fresh in 
       (assert (T:=(build_point_not_collinear_1 A B H));
       decompose [ex] T;clear T);only_use_area_coordinates  
    | A:Point |- ?X4 =>
       let T := fresh in 
       (assert (T:=(build_point_not_collinear_2 A));
       decompose [ex] T;clear T);only_use_area_coordinates  
   end.

Lemma test_only_use_area_coordinates_1 : forall A B C D, S A B C <> 0 -> S D B C + S A D C  + S A B D = S A B C.
Proof.
intros.
only_use_area_coordinates.
uniformize_signed_areas.
field.
auto.
Qed.

Lemma test_only_use_area_coordinates_2 : forall A B C D,  A<> B -> S D B C + S A D C  + S A B D = S A B C.
Proof.
intros.
only_use_area_coordinates.
field.
auto.
Qed.

Lemma test_only_use_area_coordinates_3 : forall A B C D,   S D B C + S A D C  + S A B D = S A B C.
Proof.
intros.
only_use_area_coordinates.
field.
auto.
Qed.

