
Require Export field_variable_isolation_tactic.
(* field_variable_isolation_tactic:
Require Export field.
Require Export general_tactics.

Ltac NormalizeRing H :=
  match goal with
  | i:(?X1 = ?X2) |- _ =>
      match constr:(i) with
      | H => generalize H; ring_simplify X1 X2; clear H; intro H
      | _ => fail
      end
  end. 

Lemma Lc : forall a b : F, a = b -> a - b = 0.

Lemma Lcinv : forall a b : F, a - b = 0 -> a = b.

Lemma Lcp1 : forall a b c : F, a + b = c -> a = c - b.

Lemma Lcp2 : forall a b c : F, a + b = c -> b = c - a.

Lemma Lcm1 : forall a b c : F, a - b = c -> a = c + b.

Lemma Lcm2 : forall a b c : F, a - b = c -> b = a - c.

Lemma Lcop1 : forall a b : F, - a = b -> a = - b.

Lemma Lcmult1 : forall a b c : F, b <> 0 -> a * b = c -> a = c / b.

Lemma Lcmult2 : forall a b c : F, a <> 0 -> a * b = c -> b = c / a.

Lemma Lcdiv1 : forall a b c : F, b <> 0 -> a / b = c -> a = b * c.

Lemma Lcdiv2 : forall a b c : F, b <> 0 -> c <> 0 -> a / b = c -> b = a / c.

Ltac IsoleVarAux1 var H T Hyp :=
  match constr:(T) with
  | (var = ?X2 :>?X1) =>
      assert (Hypazerty : T);
       [ exact H | clear Hyp; rename Hypazerty into Hyp ]
  | (?X1 + ?X2 = ?X3 :>?X4) =>
      IsoleVarAux1 var (Lcp1 X1 X2 X3 H) (X1 = X3 - X2 :>X4) Hyp ||
        IsoleVarAux1 var (Lcp2 X1 X2 X3 H) (X2 = X3 - X1 :>X4) Hyp
  | (?X1 - ?X2 = ?X3 :>?X4) =>
      IsoleVarAux1 var (Lcm1 X1 X2 X3 H) (X1 = X3 + X2 :>X4) Hyp ||
        IsoleVarAux1 var (Lcm2 X1 X2 X3 H) (X2 = X1 - X3 :>X4) Hyp
  | (?X1 / ?X2 = ?X3 :>?X4) =>
      match goal with
      | Hop:(?X2 <> 0) |- _ =>
          IsoleVarAux1 var (Lcdiv1 X1 X2 X3 Hop H) (X1 = X2 * X3 :>X4) Hyp
      | _ =>
          cut (X2 <> 0);
           [ intro;
              match goal with
              | Hop:(?X2 <> 0) |- _ =>
                  IsoleVarAux1 var (Lcdiv1 X1 X2 X3 Hop H)
                   (X1 = X2 * X3 :>X4) Hyp
              end
           | idtac ]
      end ||
        match goal with
        | Hop1:(?X2 <> 0),Hop2:(?X3 <> 0) |- _ =>
            IsoleVarAux1 var (Lcdiv2 X1 X2 X3 Hop1 Hop2 H)
             (X2 = X1 / X3 :>X4) Hyp
        | Hop1:(?X2 <> 0) |- _ =>
            cut (X3 <> 0);
             [ intro;
                match goal with
                | Hop2:(?X3 <> 0) |- _ =>
                    IsoleVarAux1 var (Lcdiv2 X1 X2 X3 Hop1 Hop2 H)
                     (X2 = X1 / X3 :>X4) Hyp
                end
             | idtac ]
        | Hop2:(?X3 <> 0) |- _ =>
            cut (X2 <> 0);
             [ intro;
                match goal with
                | Hop1:(?X2 <> 0) |- _ =>
                    IsoleVarAux1 var (Lcdiv2 X1 X2 X3 Hop1 Hop2 H)
                     (X2 = X1 / X3 :>X4) Hyp
                end
             | idtac ]
        | _ =>
            cut (X2 <> 0);
             [ intro; cut (X3 <> 0);
                [ intro;
                   match goal with
                   | Hop1:(?X2 <> 0),Hop2:(?X3 <> 0) |- _ =>
                       IsoleVarAux1 var (Lcdiv2 X1 X2 X3 Hop1 Hop2 H)
                        (X2 = X1 / X3 :>X4) Hyp
                   end
                | trivial ]
             | trivial ]
        end
  | (?X1 * ?X2 = ?X3 :>?X4) =>
      match goal with
      | Hop:(?X2 <> 0) |- _ =>
          IsoleVarAux1 var (Lcmult1 X1 X2 X3 Hop H) (X1 = X3 / X2 :>X4) Hyp
      | _ =>
          cut (X2 <> 0);
           [ intro;
              match goal with
              | Hop:(?X2 <> 0) |- _ =>
                  IsoleVarAux1 var (Lcmult1 X1 X2 X3 Hop H)
                   (X1 = X3 / X2 :>X4) Hyp
              end
           | idtac ]
      end ||
        match goal with
        | Hop:(?X1 <> 0) |- _ =>
            IsoleVarAux1 var (Lcmult2 X1 X2 X3 Hop H) (X2 = X3 / X1 :>X4) Hyp
        | _ =>
            cut (X1 <> 0);
             [ intro;
                match goal with
                | Hop:(?X1 <> 0) |- _ =>
                    IsoleVarAux1 var (Lcmult2 X1 X2 X3 Hop H)
                     (X2 = X3 / X1 :>X4) Hyp
                end
             | idtac ]
        end
  | (- ?X1 = ?X3 :>?X4) =>
      IsoleVarAux1 var (Lcop1 X1 X3 H) (X1 = - X3 :>X4) Hyp
  | _ => fail
  end.

Ltac IsoleVarAux var H T Hyp :=
  match constr:(T) with
  | (?X2 = ?X3 :>?X1) =>
      IsoleVarAux1 var H T Hyp ||
        IsoleVarAux1 var (sym_eq H) (X3 = X2 :>X1) Hyp
  end.

Ltac TypeOf H :=
  match goal with
  | id:?X1 |- _ => match constr:(id) with
                   | H => constr:(X1)
                   | _ => fail
                   end
  end.

Ltac IsoleVar var H := let T := TypeOf H in
                       IsoleVarAux var H T H.

Ltac IsoleVarRing var H := IsoleVar var H; NormalizeRing H.

Ltac RewriteVar var H := IsoleVarRing var H; try rewrite H in *. *)

Lemma field_prop_1 : forall a b : F, a + b = a -> b = 0.
Proof with try solve [ ring | congruence ].
intros...
assert (a + b - a = a - a)...
assert (a - a = 0)...
rewrite H1 in H0...
assert (a + b - a = b)...
Qed.

Lemma field_prop_3 : forall a : F, a = 0 -> - a = 0.
intros.
rewrite H.
ring.
Qed.

Lemma field_prop_4 : forall a : F, - a = 0 -> a = 0.
Proof with try solve [ ring | congruence ].
intros...
assert (a + - a = a + 0)...
assert (a + - a = 0)...
rewrite H1 in H0...
assert (a + 0 = a)...
Qed.

Lemma field_prop_5 : forall a b : F, - a = - b -> a = b.
Proof with try solve [ ring | congruence ].
intros...
assert (- - a = - - b)...
assert (- - a = a)...
assert (- - b = b)...
Qed.

Lemma nonzeromult : forall a b : F, a <> 0 -> b <> 0 -> a * b <> 0.
Proof with try solve [ auto with field_hints | congruence ].
intros...
assert (a * b / b = a)...
field...
intuition...
assert (a * b / b = 0 / b)...
rewrite H1 in H3...
assert (a = 0)...
assert (0 / b = 0)...
field...
Qed.

Lemma nonzerodiv : forall a b : F, a <> 0 -> b <> 0 -> a / b <> 0.
Proof with try solve [ auto with field_hints | congruence ].
intros...
unfold not in |- *; intro...
IsoleVarRing a H1...
Qed.

Lemma nonzeroinv : forall a : F, a <> 0 -> / a <> 0.
Proof with try solve [ auto with field_hints | congruence ].
intros...
unfold not in |- *; intro...
assert (a * / a = 1)...
field...
assert (a * / a = a * 0)...
rewrite H1 in H2...
assert (a * 0 = 0)...
ring...
rewrite H3 in H2...
Qed.

Lemma opzero : forall a : F, a <> 0 -> - a <> 0.
Proof with try solve [ congruence ].
intros...
assert (a + - a = 0)...
apply Fplus_Fopp_r...
intuition...
rewrite H1 in H0...
assert (a = 0)...
assert (a + 0 = 0 + a)...
apply Fplus_sym...
rewrite H2 in H0...
assert (0 + a = a)...
apply Fplus_Ol...
Qed.

Theorem divnonzero: forall a b: F, a / b <> 0 -> a<>0.
  intros a b H1 H2; case H1; unfold Fdiv; rewrite H2; ring.
Qed.

Theorem multnonzero: forall a b: F, a*b<>0 -> a<>0 /\ b<>0.
  intros a b H1; split; intros H2; case H1; rewrite H2;ring.
Qed.

Theorem multnonzero_l: forall a b: F, a*b<>0 -> a<>0. 
  intros a b H1; intros H2; case H1; rewrite H2;ring.
Qed.

Theorem multnonzero_r: forall a b: F, a*b<>0 -> b<>0. 
  intros a b H1; intros H2; case H1; rewrite H2;ring.
Qed.

Lemma inverse_ratio : forall a b, a<>0 -> b<>0 -> a/b = 1 / (b/a).
Proof.
intros.
field; auto.
Qed.

Hint Resolve field_prop_1 field_prop_3 field_prop_4 field_prop_5 opzero
  nonzeromult nonzerodiv nonzeroinv inverse_ratio : field_hints.
