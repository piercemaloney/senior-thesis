
Require Import geometry_tools.
(* geometry_tools:
Require Export geometry_tools_lemmas.
Require Export my_field_tac.

Ltac uniformize_signed_areas_goal :=
  repeat
   match goal with
   |  |- context [(- - ?X1)] =>
       replace (- - X1) with X1 by apply simplring1
   |  |- context [(S ?X1 ?X1 ?X2)] =>
       replace (S X1 X1 X2) with 0 by apply trivial_col1
   |  |- context [(S ?X2 ?X1 ?X1)] =>
       replace (S X2 X1 X1) with 0 by apply trivial_col2
   |  |- context [(S ?X1 ?X2 ?X1)] =>
       replace (S X1 X2 X1) with 0 by apply trivial_col3
   |  |- context [(S ?X1 ?X2 ?X3)] =>
    ( let Truc := fresh in
    match goal with
       |  |- context [(S ?X4 ?X5 ?X6)] =>
            (assert (Truc : S X4 X5 X6 = - S X1 X2 X3);
             [ apply S_3 || apply S_2 || apply S_4
             | rewrite Truc; clear Truc ]) ||
             (assert (Truc : S X4 X5 X6 = S X1 X2 X3);
               [ apply S_0 || apply S_1 | rewrite Truc; clear Truc ])
       end)
   end.

Ltac generalize_all_areas :=
   repeat match goal with
          H: context [(S ?X1 ?X2 ?X3)] |- _=> revert H
 end.

Ltac uniformize_signed_areas :=
  generalize_all_areas;uniformize_signed_areas_goal;intros.

Lemma S4Simpl_1 : forall A B C : Point, S4 A B B C = S A B C.

Lemma S4Simpl_2 : forall A B C : Point, S4 A B C C = S A B C.

Lemma S4Simpl_3 : forall A B C : Point, S4 A A B C = S A B C.

Lemma S4Simpl_4 : forall A B C : Point, S4 A B C A = S A B C.

Lemma S4Simpl_5 : forall A C D : Point, S4 C A D A = 0.

Lemma S4Simpl_6 : forall A C D : Point, S4 A C A D = 0.

Lemma half : 1- 1/2 = 1/2.

Ltac uniformize_signed_areas4_goal :=
  repeat
   match goal with
   |  |- context [(- - ?X1)] =>      
       replace (- - X1) with X1; [ idtac | apply simplring1 ]
   |  |- context [(S4 ?X1 ?X2 ?X1 ?X3)] =>
	rewrite (S4Simpl_6 X1 X2 X3)
   |  |- context [(S4 ?X2 ?X1 ?X3 ?X1)] =>
        rewrite (S4Simpl_5 X1 X2 X3)
   |  |- context [(S4 ?X1 ?X2 ?X2 ?X3)] =>
        rewrite (S4Simpl_1 X1 X2 X3)
   |  |- context [(S4 ?X1 ?X2 ?X3 ?X3)] =>
        rewrite (S4Simpl_2 X1 X2 X3)
   |  |- context [(S4 ?X1 ?X1 ?X2 ?X3)] =>
        rewrite (S4Simpl_3 X1 X2 X3)
   |  |- context [(S4 ?X1 ?X2 ?X3 ?X1)] =>
        rewrite (S4Simpl_4 X1 X2 X3)
   |  |- context [(S4 ?X1 ?X2 ?X3 ?X4)] =>
       match goal with
       |  |- context [(S4 ?X5 ?X6 ?X7 ?X8)] =>
           (assert (Truc : S4 X5 X6 X7 X8 = - S4 X1 X2 X3 X4);
             [ apply S4_5 || apply S4_6 || apply S4_7 || apply S4_8
             | rewrite Truc; clear Truc ]) ||
             (assert (Truc : S4 X5 X6 X7 X8 = S4 X1 X2 X3 X4);
               [ apply S4_2 || apply S4_3 || apply S4_4
               | rewrite Truc; clear Truc ])
       end
   end.

Ltac generalize_all_areas4 :=
   repeat match goal with
          H: context [(S4 ?X1 ?X2 ?X3 ?X4)] |- _=> revert H
 end.

Ltac uniformize_signed_areas4 :=
  generalize_all_areas4;uniformize_signed_areas4_goal;intros.

Ltac uniformize_dir_seg_goal :=
  repeat
   match goal with
   |  |- context [(- - ?X1)] =>
       replace (- - X1) with X1; [ idtac | apply simplring1 ]
   |  |- context [(?X1 ** ?X1)] =>
       rewrite <- (nuldirseg X1)
   |  |- context [(?X1 ** ?X2)] =>
       match goal with
       |  |- context [(?X3 ** ?X4)] =>
           match constr:((X3, X4)) with
           | (?X2, ?X1) => rewrite (A1a X1 X2)
           end
       end
   end.

Ltac generalize_all_seg :=
   repeat match goal with
          H: context [(?X1 ** ?X2)] |- _=> revert H
 end.

Ltac uniformize_dir_seg_general :=
  generalize_all_seg;uniformize_dir_seg_goal;intros.

Ltac try_rw A B := try rewrite <- (A1a B A) in *;
                   try rewrite    (A1a A B) in *.

Ltac uniformize_dir_seg_spec := match reverse goal with

 | [A : Point, B : Point, C : Point, 
    D : Point, E : Point, F : Point,
    G : Point |- _ ] => fail 1

 | [A : Point, B : Point, C : Point, D: Point, E: Point, F: Point |- _ ] => 
     try_rw A B; try_rw A C; try_rw A D; try_rw A E; try_rw A F; 
     try_rw B C; try_rw B D; try_rw B E; try_rw B F;
     try_rw C D; try_rw C E; try_rw C F;
     try_rw D E; try_rw D F;
     try_rw E F

 | [A : Point, B : Point, C : Point, D: Point, E: Point |- _ ] => 
     try_rw A B; try_rw A C; try_rw A D; try_rw A E; 
     try_rw B C; try_rw B D; try_rw B E;
     try_rw C D; try_rw C E;
     try_rw D E

 | [A : Point, B : Point, C : Point, D: Point |- _ ] => 
     try_rw A B; try_rw A C; try_rw A D; try_rw B C; try_rw B D; try_rw C D

 | [A : Point, B : Point, C : Point |- _ ] => 
     try_rw A B; try_rw A C;try_rw B C

 | [A : Point, B : Point |- _ ] => 
     try_rw A B
end.
 
Ltac uniformize_dir_seg := uniformize_dir_seg_spec || uniformize_dir_seg_general.

Lemma test_uniformize_dir_seg_1 : forall A B,
A ** B = - B**A.

Lemma test_uniformize_dir_seg_2 : forall A B,
A ** B = - B**A ->
A ** B = - B**A.

Lemma test_uniformize_dir_seg_3 : forall A B C,
A ** B = - B**A + A**C + C**A + B**C + C**A ->
A ** B = - B**A.

Lemma test_uniformize_dir_seg_4 : forall A B C D,
A ** B = - B**A + A**C + C**A + B**C + C**A + D**A + A**D->
A ** B = - B**A.

Lemma test_uniformize_dir_seg_5 : forall A B C D, forall  E F G H I : Point,
A ** B = - B**A + A**C + C**A + B**C + C**A + D**A + A**D->
A ** B = - B**A.

Hint Rewrite S4Simpl_1  S4Simpl_2 S4Simpl_3 S4Simpl_4 S4Simpl_5 S4Simpl_6 : S4_simplifications.
Hint Rewrite <- trivial_col1: S_simplifications.
Hint Rewrite <- trivial_col2: S_simplifications.
Hint Rewrite <- trivial_col3: S_simplifications.
Hint Rewrite <- nuldirseg : seg_simplifications.
Hint Rewrite half  : seg_simplifications.

Ltac basic_non_field_simpl:= autorewrite with ring_simplification 
                               S4_simplifications 
                             S_simplifications
          seg_simplifications in *.

Ltac basic_simpl := repeat (progress (basic_non_field_simpl;basic_field_simpl)). *)
Require Import Rgeometry_tools.
(* Rgeometry_tools:
Require Export geometry_tools_lemmas.
Require Export general_tactics.
Require Import List.
Require Import Quote.

Inductive AVars : Type :=  
  | PVar : Point -> AVars
  | FVar : F -> AVars.

Inductive AP : Type := 
  | APvar : nat -> AP.

Inductive AF : Type :=
  | AS : nat -> nat -> nat -> AF
  | AD : nat -> nat -> AF
  | AFvar : nat -> AF
  | AF0 : AF
  | AF1 : AF
  | AFplus : AF -> AF -> AF
  | AFmult : AF -> AF -> AF
  | AFopp : AF -> AF
  | AFinv : AF -> AF.

Ltac List_mem var lvar :=
  match constr:(lvar) with
  | nil => constr:(false)
  | cons ?X1 ?X2 =>
      match constr:(X1 = var) with
      | (?X1 = ?X1) => constr:(true)
      | _ => List_mem var X2
      end
  end.

Ltac build_var_point_list_aux lvar point :=
     let res := List_mem (PVar point) lvar in
      match constr:(res) with
      | true => lvar
      | false => constr:(cons (PVar point) lvar)
      end.

Ltac build_var_list_aux lvar trm :=
  match constr:(trm) with
  | F0 => lvar
  | F1 => lvar
  | (Fplus ?X1 ?X2) =>
      let l2 := build_var_list_aux lvar X2 in
      build_var_list_aux  l2 X1
  | (Fmult ?X1 ?X2) =>
      let l2 := build_var_list_aux  lvar X2 in
      build_var_list_aux l2 X1
  | (Fopp ?X1) => build_var_list_aux lvar X1
  | (Finv ?X1) => build_var_list_aux lvar X1
  | (S ?X1 ?X2 ?X3) =>  
  let l1 := build_var_point_list_aux lvar X3 in
  let l2 := build_var_point_list_aux l1 X2 in
  build_var_point_list_aux l2 X1
  | (DSeg ?X1 ?X2) => 
  let l1 := build_var_point_list_aux lvar X2 in
  build_var_point_list_aux l1 X1
  | (?X1 = ?X2) => 
  let l2 := build_var_point_list_aux lvar X2 in
  build_var_point_list_aux l2 X1

  | ?X1 =>
    let res := List_mem (FVar X1) lvar in
      match constr:(res) with
      | true => lvar
      | false => constr:(cons (FVar X1) lvar)
      end
  end.

Ltac build_var_list trm :=
  build_var_list_aux (@nil AVars) trm.

Ltac List_assoc elt lst :=
  match constr:(lst) with
  | nil => fail
  | (cons (@pairT AVars nat ?X1 ?X2) ?X3) =>
      match constr:(elt = X1) with
      | (?X1 = ?X1) => constr:(X2)
      | _ => List_assoc elt X3
      end
  end.

Ltac number_aux lvar cpt :=
  match constr:(lvar) with
  | nil => constr:(@nil (prodT AVars nat))
  | cons ?X2 ?X3 =>
      let l2 := number_aux X3 (Datatypes.S cpt) in
      constr:(cons (@pairT  AVars nat X2 cpt) l2)
  end.

Ltac number lvar := number_aux lvar (Datatypes.O).

Ltac build_numbered_var_list trm := let lvar := build_var_list trm in
                             number lvar.

Definition list_assoc_inv :=
  (fix list_assoc_inv_rec (A:Type) (B:Set)
                     (eq_dec:forall e1 e2:B, {e1 = e2} + {e1 <> e2})
                     (lst:list (prodT A B)) {struct lst} :
   B -> A -> A :=
     fun (key:B) (default:A) =>
       match lst with
       | nil => default
       | cons (pairT v e) l =>
           match eq_dec e key with
           | left _ => v
           | right _ => list_assoc_inv_rec A B eq_dec l key default
           end
       end).

Parameter SomeValue :AVars.
Parameter SomePoint :Point.

Definition interp_AP_to_Point (lvar:list (prodT AVars nat)) (e:nat) : Point :=
 match(list_assoc_inv  AVars nat eq_nat_dec lvar e SomeValue) with
    | PVar p => p
    | _ => SomePoint
  end
.

Fixpoint interp_AF_to_F (lvar:list (prodT AVars nat)) (e:AF) {struct e} : F :=
  match e with
  | AF0 => F0
  | AF1 => F1
  | AS e1 e2 e3 => let idx1 := (interp_AP_to_Point lvar e1) in 
S idx1 (interp_AP_to_Point lvar e2) (interp_AP_to_Point lvar e3)
  | AD e1 e2 => DSeg (interp_AP_to_Point lvar e1) (interp_AP_to_Point lvar e2) 
  | AFplus e1 e2 => Fplus (interp_AF_to_F lvar e1) (interp_AF_to_F lvar e2)
  | AFmult e1 e2 => Fmult (interp_AF_to_F lvar e1) (interp_AF_to_F lvar e2)
  | AFopp e => Fopp (interp_AF_to_F lvar e)
  | AFinv e => Finv (interp_AF_to_F lvar e)
  | AFvar n => 
  match(list_assoc_inv  AVars nat eq_nat_dec lvar n SomeValue) with
    | FVar f => f
    | _ => F0
  end
  end.

Ltac interp_A lvar trm :=
  match constr:(trm) with
  | F0 => constr:(AF0)
  | F1 => constr:(AF1)
  | (Fplus ?X1 ?X2) =>
      let e1 := interp_A lvar X1 with e2 := interp_A lvar X2 in
      constr:(AFplus e1 e2)
  | (Fmult ?X1 ?X2) =>
      let e1 := interp_A lvar X1 with e2 := interp_A lvar X2 in
      constr:(AFmult e1 e2)
  | (Fopp ?X1) =>
      let e := interp_A lvar X1 in
      constr:(AFopp e)
  | (Finv ?X1) => 
      let e := interp_A lvar X1 in
      constr:(AFinv e)
 | (S ?X1 ?X2 ?X3) =>
   let idx1 := List_assoc (PVar X1) lvar with 
   idx2 := List_assoc (PVar X2) lvar with 
   idx3 := List_assoc (PVar X3) lvar in 
   constr:(AS idx1 idx2 idx3)
 | (DSeg ?X1 ?X2) =>
  let idx1 := List_assoc (PVar X1) lvar with
  idx2 := List_assoc (PVar X2) lvar in 
  constr:(AD idx1 idx2)
 | ?X1 => let idx := List_assoc (FVar X1) lvar in
           constr:(AFvar idx)
  end.

Fixpoint nateq (n m:nat) {struct m} : bool :=
  match n, m with
  | O, O => true
  | Datatypes.S n', Datatypes.S m' => nateq n' m'
  | _, _ => false
  end.

Lemma nateq_prop : forall n m:nat, (Is_true (nateq n m))-> n=m.

Fixpoint simplif (e:AF) {struct e} : AF :=
  match e with 
   | AFplus e1 e2 => 
   let s1 := (simplif e1) in 
   let s2 := (simplif e2) in 
   match s1 with 
     AF0 => s2
     |_ => match s2 with 
        AF0 => s1
        |_ =>  AFplus s1 s2
        end
     end
   | AFmult e1 e2 =>
    let s1 := (simplif e1) in 
    let s2 := (simplif e2) in 
    match s1 with 
      AF0 => AF0
      |AF1 => s2
      |_ => match s2 with 
        AF0 => AF0
        |AF1 => s1
        |_ =>  AFmult s1 s2
        end
    end
  | AFopp e =>    
    let s := (simplif e) in 
    match s with 
       AF0 => AF0
       | AFopp e1 => e1
       | _ => AFopp s
    end
  | AS e1 e2 e3 => if (nateq e1 e2) then AF0 else
  (if (nateq e1 e3) then AF0 else (if (nateq e2 e3) then AF0 else e))
  | AD e1 e2 => if (nateq e1 e2) then AF0 else e
  | _ => e
end.

Lemma simplif_correct : 
forall (e:AF) (lvar:list (prodT AVars nat)),
   interp_AF_to_F lvar (simplif e) =
   interp_AF_to_F lvar e.

Ltac simplif_term exp :=
  let lvar := build_numbered_var_list exp in 
  let trm := interp_A lvar exp in 
  let trm2 :=constr:(interp_AF_to_F lvar (simplif trm)) in 
 (replace exp with trm2 in *;[simpl|rewrite simplif_correct;trivial]).

Ltac Rbasic_simpl := match goal with 
_:_ |- ?X1 = ?X2 => simplif_term X1;simplif_term X2;unfold interp_AP_to_Point;simpl
end.

Fixpoint natle (n m:nat) {struct m} : bool :=
  match n, m with
  | O, O => true
  | O, Datatypes.S n' => true
  | Datatypes.S n', Datatypes.S m' => natle n' m'
  | _, _ => false
  end.

Fixpoint uniformize_areas (e:AF) {struct e} : AF :=
match e with 
  | AFplus e1 e2 => 
    let s1 := (uniformize_areas e1) in 
    let s2 := (uniformize_areas e2) in 
    AFplus s1 s2
  | AFmult e1 e2 =>
    let s1 := (uniformize_areas e1) in 
    let s2 := (uniformize_areas e2) in 
    AFmult s1 s2
  | AFopp e1 =>
    let s1 := (uniformize_areas e1) in 
    AFopp s1
  | AFinv e1 =>
    let s1 := (uniformize_areas e1) in 
    AFinv s1
  | AS e1 e2 e3 => if (natle e1 e2) then 
                                 (if (natle e2 e3) then (AS e1 e2 e3) else 
                                            (if (natle e1 e3)  then  (AFopp (AS e1 e3 e2)) else (AS e3 e1 e2))) 
                               else (if (natle e2 e3) then 
						(if (natle e1 e3) then (AFopp (AS e2 e1 e3)) else (AS e2 e3 e1)) 
					else (AFopp (AS e3 e2 e1))) 
  | AD e1 e2 => if (natle e1 e2) then (AD e1 e2) else  (AFopp (AD e2 e1))
  | _ => e
end.

Lemma uniformize_areas_correct : 
forall (e:AF) (lvar:list (prodT AVars nat)),
   interp_AF_to_F lvar (uniformize_areas e) =
   interp_AF_to_F lvar e.

Ltac generalize_all := 
   repeat match goal with
          H:_ |- _ => revert H
end.

Ltac uniformize_term exp lvar :=
  let trm := interp_A lvar exp in 
  let trm2 :=constr:(interp_AF_to_F lvar (uniformize_areas trm)) in
(replace exp with trm2;[idtac|rewrite uniformize_areas_correct;trivial]).

Inductive formula : Type :=
  | f_imp : formula -> formula -> formula 
  | f_const : Prop -> formula .

Inductive formula2 : Type :=
  | f_imp2 : formula2 -> formula2 -> formula2 
  | f_neq : AF -> AF -> formula2 
  | f_eq : AF -> AF -> formula2.

Fixpoint uniformize_areas_formula2 (e:formula2) {struct e} : formula2 :=
match e with 
  | f_imp2 e1 e2 => 
    let s1 := (uniformize_areas_formula2 e1) in 
    let s2 := (uniformize_areas_formula2 e2) in 
    f_imp2 s1 s2
  | f_neq e1 e2 =>
    let s1 := (uniformize_areas e1) in 
    let s2 := (uniformize_areas e2) in 
    f_neq s1 s2
  | f_eq e1 e2 =>
    let s1 := (uniformize_areas e1) in 
    let s2 := (uniformize_areas e2) in 
    f_eq s1 s2
end.

Fixpoint interp_formula2_to_prop (lvar:list (prodT AVars nat)) (e:formula2) {struct e} : Prop :=
  match e with
  | f_imp2 e1 e2 => 
        let s1 := interp_formula2_to_prop lvar e1 in
        let s2 := interp_formula2_to_prop lvar e2 in
      s1 -> s2
  | f_neq e1 e2 => 
        let s1 := interp_AF_to_F lvar e1 in
        let s2 := interp_AF_to_F lvar e2 in
        s1 <> s2
 | f_eq e1 e2 => 
        let s1 := interp_AF_to_F lvar e1 in
        let s2 := interp_AF_to_F lvar e2 in
        s1 = s2
end.

Lemma uniformize_areas_formula2_correct_gen : 
forall (e:formula2) (lvar:list (prodT AVars nat)),
   interp_formula2_to_prop lvar (uniformize_areas_formula2 e) <->
   interp_formula2_to_prop lvar e.

Lemma uniformize_areas_formula2_correct :
forall (e:formula2) (lvar:list (prodT AVars nat)),
   interp_formula2_to_prop lvar (uniformize_areas_formula2 e) ->
   interp_formula2_to_prop lvar e.

Definition implies := fun A B :Prop => A->B. 
Definition neqF := fun A B : F => A<>B.
Definition eqF := fun A B : F => A=B.

Fixpoint interp_f (f: formula) : Prop :=
   match f with
   | f_imp f1 f2 => implies (interp_f f1) (interp_f f2)
   | f_const c => c
   end.

Ltac put_implies :=
 repeat
 match goal with 
  _:_ |- context [?X1 -> ?X2] => replace (X1 -> X2) with (implies X1 X2);[idtac|auto]
end.

Ltac put_eq_neqF :=
 repeat
 match goal with 
  _:_ |- context [?X1 <> ?X2] => replace (X1 <> X2) with (neqF X1 X2);[idtac|auto]
  |H:context [?X1 <> ?X2] |- _ => replace (X1 <> X2) with (neqF X1 X2) in H;[idtac|auto]
  |_:_ |- context [?X1 = ?X2] => replace (X1 = X2) with (eqF X1 X2);[idtac|auto]
  |H:context [?X1 = ?X2] |- _ => replace (X1 = X2) with (eqF X1 X2) in H;[idtac|auto]

end.

Ltac generalize_all_eq :=
   repeat match goal with
   H: context [?X1 = ?X2] |- _=> revert H
end.

Ltac generalize_all_eq_neqF :=
   repeat match goal with
   H: context [eqF ?X1 ?X2] |- _=> revert H
   | H: context [neqF ?X1 ?X2] |- _=> revert H
 end.

Ltac interp_formula2 lvar trm :=
match constr:(trm) with
  | (implies ?X1 ?X2) =>
      let e1 := interp_formula2 lvar X1 in
      let e2 := interp_formula2 lvar X2 in
      constr:(f_imp2 e1 e2)
 | (eqF ?X1 ?X2) =>
      let e1 := interp_A lvar X1 in
      let e2 := interp_A lvar X2 in
      constr:(f_eq e1 e2)
 | (neqF ?X1 ?X2) =>
     let e1 := interp_A lvar X1 in
     let e2 := interp_A lvar X2 in
     constr:(f_neq e1 e2)
end.

Ltac interp_formula2_goal lvar := 
 match goal with
 _:_ |- ?X1 => interp_formula2 lvar X1
end.

Ltac uniformize_formula2_goal lvar :=
  let trm := interp_formula2_goal lvar in
  let trm2 :=constr:(interp_formula2_to_prop lvar (uniformize_areas_formula2 trm)) in
  let id := fresh in (
assert (id:(trm2-> interp_formula2_to_prop lvar trm));
[apply uniformize_areas_formula2_correct|idtac];
simpl in id;
 
unfold interp_AP_to_Point in id;simpl in id;unfold implies;
apply id;clear id
).

Ltac prepare_goal2 lvar := generalize_all_eq_neqF;put_implies;interp_formula2_goal lvar.

Ltac prepare_goal := generalize_all_eq;put_implies;quote interp_f.
Ltac un_prepare_goal := simpl;unfold implies;intros.

Ltac build_var_list_eq varlist x :=
 match constr:(x) with 
     	?X2=?X3 => 
           let l1 := build_var_list_aux varlist X2 in
   	   let l2 := build_var_list_aux l1 X3 in
           constr:(l2) 
       | ?X2<>?X3 => 
          let l1 := build_var_list_aux varlist X2 in
          let l2 := build_var_list_aux l1 X3 in
          constr:(l2)
   | _ => varlist
end.

Ltac union_vars_aux varlist trm :=  
  match constr:(trm) with
   | interp_f ?X1 => union_vars_aux varlist X1 
   | f_imp ?X1 ?X2 => 
        let lvar1 := union_vars_aux varlist X1 in 
        let lvar2 := union_vars_aux lvar1 X2 in
        constr:(lvar2)
   | f_const ?X1 => build_var_list_eq varlist X1
 end.

Ltac union_vars trm :=  union_vars_aux (@nil AVars) trm .
      
Ltac compute_vars_of_the_goal :=
  match goal with 
  _:_ |- ?X1 => 
        let lvar := union_vars X1 in
        let varlist := number lvar in
       varlist
end.

Ltac uniformize_quantities varlist trm :=
  match constr:(trm) with
   | interp_f ?X1 => uniformize_quantities varlist X1 
   | f_imp ?X1 ?X2 => uniformize_quantities varlist X1;uniformize_quantities varlist X2
   | f_const ?X1 => 
                (match constr:(X1) with 
                    ?X1 = ?X2 => uniformize_term X1 varlist;uniformize_term X2 varlist
                  | ?X1 <> ?X2 => uniformize_term X1 varlist;uniformize_term X2 varlist
                    |_ => idtac
                   end)
   end.

Ltac uniformize_quantities_of_the_goal varlist :=
 match goal with 
  _:_ |- ?XG => uniformize_quantities varlist  XG
end.

Ltac uniformize_quantities_of_all varlist :=
 repeat
  match goal with 
	  _:_ |- context [?X1 = ?X2] => progress uniformize_term X1 varlist
          |_:_ |- context [?X1 = ?X2] => progress uniformize_term X2 varlist
	  |H: context [?X1 <> ?X2] |- _ => progress uniformize_term X1 varlist
          |H: context [?X1 <> ?X2] |- _ => progress uniformize_term X2 varlist
	  |H: context [?X1 = ?X2] |- _ => progress uniformize_term X1 varlist
	  |H: context [?X1 = ?X2] |- _ => progress uniformize_term X2 varlist
end.

Ltac Runiformize_signed_areas := 
  unfold Fminus, Fdiv in *;   
  prepare_goal;
  let varlist := compute_vars_of_the_goal in
  (un_prepare_goal; put_eq_neqF;generalize_all_eq_neqF;put_implies;
    uniformize_formula2_goal varlist;intros). *)

Ltac local_uniformize_signed_areas := Runiformize_signed_areas.

Ltac local_basic_simpl := Rbasic_simpl.

Ltac local_uniformize_signed_areas4 := uniformize_signed_areas4.

Lemma test1 : forall A B C :Point, S A B C = S B C A.
Proof.
intros.
local_uniformize_signed_areas.
auto.
Qed.

Lemma test2 : forall A B C :Point, S A B C + S B A C = 0.
Proof.
intros.
local_uniformize_signed_areas.
ring.
Qed.

Lemma test3 : forall A B C :Point, S A B C + S A C B = 0.
Proof.
intros.
local_uniformize_signed_areas.
ring.
Qed.

Lemma test4 : forall A B C :Point, S A B C +- S B C A = 0.
Proof.
intros.
local_uniformize_signed_areas.
ring.
Qed.

Lemma test5 : forall A B C :Point, S A B C - S C A B = 0.
Proof.
intros.
local_uniformize_signed_areas.
basic_simpl.
ring.
Qed.

Lemma test6 : forall A B C :Point, S A B C + S C B A = 0.
Proof.
intros.
local_uniformize_signed_areas.
ring.
Qed.

Lemma test7 : forall A B C :Point, S A B C + S B A C = 0 -> 0=0.
Proof.
intros.
 progress local_uniformize_signed_areas.
ring.
Qed.

Lemma test8 : forall A B C :Point, S A B C + S A C B = 0 -> 0=0.
Proof.
intros.
progress local_uniformize_signed_areas.
ring.
Qed.

Lemma test9 : forall A B C :Point, S A B C - S B C A = 0 -> 0=0.
Proof.
intros.
progress local_uniformize_signed_areas.
ring.
Qed.

Lemma test10 : forall A B C :Point, S A B C - S C A B = 0 -> 0=0.
Proof.
intros.
progress local_uniformize_signed_areas.
ring.
Qed.

Lemma test11 : forall A B C :Point, S A B C + S C B A = 0 -> 0=0.
Proof.
intros.
progress local_uniformize_signed_areas.
ring.
Qed.

Lemma test12 : forall A B C :Point, S A B C - S C A B = 0 -> S A B C + S C B A = 0.
Proof.
intros.
progress local_uniformize_signed_areas.
ring.
Qed.

Lemma test13 : forall A B C :Point, S A B C + S C B A = 0 ->
S A B C + S B A C = 0 -> S A B C - S B C A = 0 .
Proof.
intros.
progress local_uniformize_signed_areas.
ring.
Qed.

Lemma test15 : forall A B C : Point,
S A B C = 0 -> S B A C = 0.
Proof.
intros.
progress local_uniformize_signed_areas.
rewrite H.
ring.
Qed.

Lemma test16 : forall A B C : Point,
S A B C + S B A C = S A B C -> 0=0.
Proof.
intros.
progress local_uniformize_signed_areas.
ring.
Qed.

Lemma test172 : forall A B C, S A B C <> 0 -> S C B A = 0 -> S B C A =0 -> 0=1.
Proof.
intros.
local_uniformize_signed_areas.
rewrite H1 in H.
intuition.
Qed.

Lemma test173 : forall A B C P, 
 - (S A C P / S B C P * (S B A P / S C A P * (S C B P / S A B P))) = 1 -> 0=0.
Proof.
intros.
progress local_uniformize_signed_areas.
auto.
Qed.

Lemma test174 : forall A B C P, 
  S B C P <> 0 ->
  S A B P <> 0 ->
  S C A P <> 0 ->
 False ->
- (S A C P / S B C P * (S B A P / S C A P * (S C B P / S A B P))) = 1.
Proof.
intros.
local_uniformize_signed_areas.
intuition.
Qed.

Lemma test18 : forall A B C D, S4 A B C D = S4 B C D A.
Proof.
intros.
local_uniformize_signed_areas4.
auto.
Qed.

Lemma test19 : forall A B C D, S4 A B C D = S4 C D A B.
Proof.
intros.
local_uniformize_signed_areas4.
auto.
Qed.

Lemma test20 : forall A B C D, S4 A B C D = S4 D A B C.
Proof.
intros.
local_uniformize_signed_areas4.
auto.
Qed.

Lemma test21 : forall A B C D, S4 A B C D = - S4 A D C B.
Proof.
intros.
local_uniformize_signed_areas4.
auto.
Qed. 

Lemma test22 : forall A B C D, S4 A B C D = - S4  D C B A.
Proof.
intros.
local_uniformize_signed_areas4.
auto.
Qed. 

Lemma test23 : forall A B C D, S4 A B C D = - S4 C B A D.
Proof.
intros.
local_uniformize_signed_areas4.
auto.
Qed. 

Lemma test24 : forall A B C D, S4 A B C D = - S4 B A D C.
Proof.
intros.
local_uniformize_signed_areas4.
auto.
Qed. 

Lemma test25 : forall A B C D, S4 A B C D = - S4 B A D C -> 0=0.
Proof.
intros.
progress local_uniformize_signed_areas4.
auto.
Qed. 

Lemma test26 : forall A B C D, S4 A B C D = - S4 B A D C -> S4 A B C D = - S4 B A D C.
Proof.
intros.
progress local_uniformize_signed_areas4.
auto.
Qed. 

Lemma test27 : forall A C D, S4 A A C D = 0 -> 0=0.
Proof.
intros.
progress local_uniformize_signed_areas4.
auto.
Qed. 

Lemma test28 : forall A C D, S4 C D A A = 0 -> 0=0.
Proof.
intros.
progress local_uniformize_signed_areas4.
auto.
Qed. 

Lemma test29 : forall A C D, S4 A C D A = 0 -> 0=0.
Proof.
intros.
progress local_uniformize_signed_areas4.
auto.
Qed. 

Lemma test30 : forall A C D, S4 C A A D = 0 -> 0=0.
Proof.
intros.
progress local_uniformize_signed_areas4.
auto.
Qed. 

Lemma test31 : forall A C D, S4 C A D A = 0 -> 0=0.
Proof.
intros.
progress local_uniformize_signed_areas4.
auto.
Qed. 

Lemma test32 : forall A C D, S4 A C A D = 0 -> 0=0.
Proof.
intros.
progress local_uniformize_signed_areas4.
auto.
Qed. 

Lemma test35 : forall A B, A**B=-B**A.
Proof.
intros.
uniformize_dir_seg.
ring.
Qed.

Lemma test36 : forall A B, A**B=-B**A -> 0=0.
Proof.
intros.
progress uniformize_dir_seg.
auto.
Qed.

Lemma test40 : forall A C, S A A C + S A C C + S A C A = 0.
Proof.
intros.
basic_simpl.
auto.
Qed.

Lemma test41 : forall A , A**A = 0.
Proof.
intros.
basic_simpl.
auto.
Qed.

Lemma test42 : forall A B, 0*A**B + (1*A**B -1*A**B) = 0.
Proof.
intros.
basic_simpl.
auto.
Qed.

Lemma test43 : forall A B, -A**B + - - A**B + (1*A**B -1*A**B) = 0.
Proof.
intros.
basic_simpl.
auto.
Qed.

Lemma test44 : forall A B, A**B + (-A**B) = 0.
Proof.
intros.
basic_simpl.
auto.
Qed.

Lemma test45 : forall A B, - A**B + (A**B) = 0.
Proof.
intros.
basic_simpl.
auto.
Qed.

Lemma test46 : forall A B, - - A**B + -(A**B) = 0.
Proof.
intros.
basic_simpl.
auto.
Qed.

Lemma test47 : forall A B C D, A**B + -(C**D) + (C**D) - (A**B)= 0.
Proof.
intros.
basic_simpl.
ring.
Qed.

Lemma test48 : forall A B C D,  S4 A B A C + A**B + -(C**D) + (C**D) - (A**B)= 0.
Proof.
intros.
basic_simpl.
ring.
Qed.

Lemma test49 : forall A B C D,  S4 A B A C + S A A C + 1* S A B C - - S B A C +  A**B + -(C**D) + (C**D) - (A**B)= 0.
Proof.
intros.
local_uniformize_signed_areas.
basic_simpl.
ring.
Qed.

Lemma test50 : forall A , A<>0 -> A/ A = 1.
Proof.
intros.
basic_field_simpl.
auto.

Qed.

Lemma test51 : forall A , A<>0 -> A/ A = 0 -> 0=1.
Proof.
intros.
basic_field_simpl.
auto.
Qed.

Lemma test52 : forall A B C D,  S4 A B A C + S A A C + 1* S A B C - - S B A C +  A**B + -(C**D) + (C**D) - (A**B)= 0 -> 0=0.
Proof.
intros.
progress local_uniformize_signed_areas.
progress basic_simpl.
auto.
Qed.

Lemma test53 : forall A, A<>0 -> (0+A)/A+(-A)/A=0.
Proof.
intros.
basic_simpl.
auto.
Qed.

Lemma test54 : forall x, -x*-x=x*x.
Proof.
intros.
basic_simpl.
auto.
Qed.

Lemma test55 : forall x y, -x*y=-(x*y).
Proof.
intros.
basic_simpl.
auto.
Qed.

Lemma test56 : forall x y, y<>0 -> (-x)/y=-(x/y).
Proof.
intros.
basic_simpl.
auto.
Qed.

Lemma test57 : forall y, y<>0 -> 0/y=0.
Proof.
intros.
basic_simpl.
auto.
Qed.

Lemma test58 : forall x y, y<>0 -> (x*y)/y =x.
Proof.
intros.
basic_simpl.
auto.
Qed.

Lemma test59 : forall x y, x<>0 -> (x*y)/x =y.
Proof.
intros.
basic_simpl.
auto.
Qed.

Lemma test60 : forall x y, x<>0 -> (x*y)/x =y -> 0=0.
Proof.
intros.
progress basic_simpl.
auto.
Qed.

Lemma test61 : forall A B C, False -> S A B C=0.
Proof.
intros.
local_uniformize_signed_areas.
intuition.
Qed.

Lemma test62 : forall A B C, False ->  0 = S A B C.
Proof.
intros.
local_uniformize_signed_areas.
intuition.
Qed.

Lemma test65 : forall A B C D E F:Point, S A C D <> 0 ->
S B A F + S A B F = 0.
Proof.
intros.
local_uniformize_signed_areas.
ring.
Qed.

