
Require Export geometry_tools_lemmas.
(* geometry_tools_lemmas:
Require Export field_general_properties.
Require Export chou_gao_zhang_axioms.

Lemma S_0 : forall A B C : Point, S A B C = S C A B.

Lemma S_1 : forall A B C : Point, S A B C = S B C A.
Hint Resolve S_1: Geom. 

Lemma S_2 : forall A B C : Point, S A B C = - S C B A.
Hint Resolve S_2: Geom.

Lemma S_3 : forall A B C : Point, S A B C = - S A C B.
Hint Resolve S_3: Geom.

Lemma S_4 : forall A B C : Point, S A B C = - S B A C.

Lemma S4_1 : forall A B C D : Point, S4 A B C D = S A B D - S C B D.
Hint Resolve S4_1: Geom.

Lemma S4_2 : forall A B C D : Point, S4 A B C D = S4 B C D A. 
Hint Resolve S4_2: Geom.

Lemma S4_3 : forall A B C D : Point, S4 A B C D = S4 C D A B. 
Hint Resolve S4_3: Geom.

Lemma S4_4 : forall A B C D : Point, S4 A B C D = S4 D A B C. 
Hint Resolve S4_4: Geom.

Lemma S4_5 : forall A B C D : Point, S4 A B C D = - S4 A D C B. 
Hint Resolve S4_5: Geom.

Lemma S4_6 : forall A B C D : Point, S4 A B C D = - S4 D C B A. 
Hint Resolve S4_6: Geom.

Lemma S4_7 : forall A B C D : Point, S4 A B C D = - S4 C B A D. 
Hint Resolve S4_7: Geom.

Lemma S4_8 : forall A B C D : Point, S4 A B C D = - S4 B A D C. 
Hint Resolve S4_8: Geom.

Lemma lpar1 : forall A B C D : Point, parallel A B C D -> parallel A B D C.

Lemma lpar2 : forall A B C D : Point, parallel A B C D -> parallel B A C D.

Lemma lpar3 : forall A B C D : Point, parallel A B C D -> parallel B A D C.
 
Lemma ldiff : forall A B : Point, A <> B -> B <> A.

Lemma simplring1 : forall x : F, x = - - x. 

Lemma zeroegal : forall A B : Point, A = B -> A ** B = 0.

Lemma egalzero : forall A B : Point, A ** B = 0 -> A = B.

Hint Resolve zeroegal egalzero: Geom.

Lemma nuldirseg : forall A : Point, 0 = A ** A.

Lemma neq_not_zero : forall A B:Point, 
  A<>B -> A**B<>0.

Lemma field_prop_2 : forall a : F, a = - a -> a = 0.

Hint Resolve field_prop_2: Geom.

Lemma trivial_col1 : forall A B : Point, 0 = S A A B.

Lemma trivial_col2 : forall A B : Point, 0 = S A B B.

Lemma trivial_col3 : forall A B : Point, 0 = S A B A.

Lemma A1a : forall A B : Point, A ** B = - B ** A.

Lemma degenerated_ratio : forall A B C D, 
  A=B -> C<>D -> A**B/C**D=0.

Hint Immediate A1a: Geom. *)
Require Export my_field_tac.
(* my_field_tac:
Require Export field_general_properties.
Require Import field.
Require Import chou_gao_zhang_axioms.

Ltac assumption_or_ax := assumption || apply chara_not_2.

Ltac solve_conds :=  
repeat split;
repeat (assumption_or_ax || 
           apply nonzeromult || 
           apply nonzerodiv ||
           apply nonzeroinv).

Ltac smart_field := field; solve_conds.

Ltac smart_field_simplify_eq := field_simplify_eq;solve_conds.

Lemma same_denom_add_1 : forall a b c d : F, 
  b<>0 ->
  d<>0 -> 
 a/b + c/d = (a*d+c*b) / (b*d).

Lemma same_denom_add_2 : forall a b c : F, 
  b<>0 ->
  a/b + c = (a+c*b) / b.

Lemma same_denom_add_3 : forall a c d : F, 
  d<>0 -> 
  a + c/d = (a*d+c) / d.

Lemma same_denom_min_1 : forall a b c d : F, 
  b<>0 ->
  d<>0 -> 
 a/b - c/d = (a*d-c*b) / (b*d).

Lemma same_denom_min_2 : forall a b c : F, 
  b<>0 ->
 a/b - c = (a-c*b) / b.

Lemma same_denom_min_3 : forall a  c d : F, 
  d<>0 ->
 a - (c/d) = (a*d-c) / d.

Lemma same_denom_mul_1 : forall a b c d : F, 
  b<>0 ->
  d<>0 -> 
 a/b * c/d = (a*c) / (b*d).

Lemma same_denom_mul_2 : forall a b c : F, 
  b<>0 -> 
 a/b * c = (a*c) / b.

Lemma same_denom_mul_3 : forall a c d : F, 
  d<>0 -> 
 a * (c/d) = (a*c) / d.

Lemma same_denom_div_1 : forall a b c d : F, 
  b<>0 ->
  c/d<>0 ->
  d<>0 -> 
 (a/b) / (c/d) = (a*d) / (b*c).

Lemma invariant_div_1 : forall b c d,
  b<>0 ->
  c/d<>0 ->
  d<>0 ->
  b*c <> 0.

Lemma same_denom_div_3 : forall a c d : F, 
  c/d<>0 ->
  d<>0 -> 
 a / (c/d) = (a*d) / c.

Lemma invariant_div_3 : forall c d,
  c/d<>0 ->
  d<>0 ->
  c <> 0.

Lemma same_denom_div_2 : forall a b c : F, 
  b<>0 ->
  c<>0 -> 
 (a/b) / c = a / (b*c).

Lemma remove_inv : forall a : F, 
 Finv a = 1/a.

Lemma remove_opp : forall a : F,
 -a = 0-a.

Lemma simp_1 : forall a : F,
a*0 = 0.

Lemma simp_2 : forall a : F,
0*a = 0.

Lemma simp_3 : forall a : F,
1*a = a.

Lemma simp_4 : forall a : F,
a*1 = a.

Lemma simp_5 : forall a : F,
0+a = a.

Lemma simp_6: forall a : F,
a+0 = a.

Lemma simp_7: forall a : F,
a-0 = a.

Lemma simp_8: forall a : F,
a-a = 0.

Lemma simp_9: forall a : F,
-a+a = 0.

Lemma simp_10: forall a b : F,
a+ -(b)= a-b.

Lemma simp_11 : -0=0.

Lemma simp_12 : forall a, - - a=a.

Lemma simp_13 : forall a b, - a * -b=a*b.

Lemma simp_14 : forall a b, (- a) * b=-(a*b).

Lemma simp_15 : forall a b, a * (- b)=-(a*b).

Hint Rewrite 
simp_1 simp_2 simp_3 simp_4 simp_5 
simp_6 simp_7 simp_8 simp_9 simp_10 
simp_11 simp_12 simp_13 simp_14 simp_15 
: ring_simplification.

Hint Rewrite 
same_denom_add_1
same_denom_add_2
same_denom_add_3
same_denom_min_1
same_denom_min_2
same_denom_min_3
same_denom_mul_1
same_denom_mul_2
same_denom_mul_3
same_denom_div_1
same_denom_div_2 
same_denom_div_3 
: same_denom.

Lemma simp_frac_1: forall a : F,
a<>0 ->
a/a = 1.

Lemma simp_frac_2: forall a : F,
a<>0 ->
a * Finv a = 1.

Lemma simp_frac_3: forall a : F,
a<>0 ->
a * - Finv a = - (1).

Lemma simp_frac_4: forall a : F,
a<>0 ->
(-a) * - Finv a = 1.

Lemma simp_frac_5: forall a : F,
a<>0 ->
(-a) / a = - (1).

Lemma simp_frac_6: forall a : F,
-a<>0 ->
a / -a = - (1).

Lemma simp_frac_7: forall a : F,
-a<>0 ->
(-a) / -a = 1.

Lemma simp_frac_8: forall a b c : F,
a*c<>0 ->
(a*b) / (a*c) = b/c.

Lemma simp_frac_9: forall a b c : F,
c*a<>0 ->
(b*a) / (c*a) = b/c.

Lemma simp_frac_10 : forall a, a<>0 ->
0/a=0. 

Lemma simp_frac_11 : forall a, a<>0 ->
a*(1/a)=1. 

Lemma simp_frac_12: forall a b : F,
b<>0 ->
(a*b) / b = a.

Lemma simp_frac_13: forall a b : F,
a<>0 ->
(a*b) / a = b.

Lemma simp_frac_14: forall a b : F,
b<>0 ->
(-a) / b = -(a/b).

Lemma simp_frac_15: forall a : F,
a / 1 = a.

Lemma simp_frac_16: forall a b : F,
-b<>0 -> a/(-b) = - (a/b).

Lemma simp_frac_16_inv : forall a, -a<>0 -> a<>0.

Hint Rewrite 
simp_frac_1
simp_frac_2
simp_frac_3
simp_frac_4
simp_frac_5
simp_frac_6
simp_frac_7
simp_frac_8 
simp_frac_9 
simp_frac_10
simp_frac_11
simp_frac_12
simp_frac_13
simp_frac_14
simp_frac_15
simp_frac_16
: field_simplification.

Ltac basic_field_simpl_goal :=
  repeat
   match goal with
  | H:?X1<>0 |- context [?X1 / ?X1] =>
           rewrite (simp_frac_1 X1 H) in * 
  | H:?X1<>0 |- context [(- ?X1) / ?X1] =>
           rewrite (simp_frac_5 X1 H) in *
  | H:- ?X1<>0 |- context [?X1 / - ?X1] =>
           rewrite (simp_frac_6 X1 H) in *
  | H:- ?X1<>0 |- context [(-?X1) / - ?X1] =>
           rewrite (simp_frac_7 X1 H) in *
  | H: ?X1<>0 |- context [0 / ?X1] =>
           rewrite (simp_frac_10 X1 H) in *
  | H: ?X1<>0 |- context [?X1 * (1 / ?X1)] =>
           rewrite (simp_frac_11 X1 H) in *
  | H: ?X2<>0 |- context [(?X1 * ?X2) / ?X2] =>
           rewrite (simp_frac_12 X1 X2 H) in *
  | H: ?X1<>0 |- context [(?X1 * ?X2) / ?X1] =>
           rewrite (simp_frac_13 X1 X2 H) in *
  | H: ?X2<>0 |- context [(- ?X1) / ?X2] =>
           rewrite (simp_frac_14 X1 X2 H) in *
 | H: - ?X2<>0 |- context [ ?X1 / (- ?X2)] =>
           rewrite (simp_frac_16 X1 X2 H) in *;
           let T:=fresh in 
           assert (T:= simp_frac_16_inv X2 H)
  | H:_ |- context [?X1 / 1] =>
           rewrite (simp_frac_15 X1) in *
end.

Ltac basic_field_simpl_hyps :=
  repeat
   match goal with
  | H:?X1<>0, Hc: context [?X1 / ?X1] |- _ =>
           rewrite (simp_frac_1 X1 H) in *|-
  | H:?X1<>0, Hc: context [(- ?X1) / ?X1] |- _ =>
           rewrite (simp_frac_5 X1 H) in *|-
  | H:- ?X1<>0, Hc: context [?X1 / - ?X1] |- _ =>
           rewrite (simp_frac_6 X1 H) in *|-
  | H:- ?X1<>0, Hc: context [(- ?X1) / - ?X1] |- _ =>
           rewrite (simp_frac_7 X1 H) in *|-
  | H: ?X1<>0, Hc: context [0 / ?X1] |- _ =>
           rewrite (simp_frac_10 X1 H) in *|-
  | H: ?X1<>0, Hc: context [?X1 * (1 / ?X1)] |- _ =>
           rewrite (simp_frac_11 X1 H) in *|-
  | H: ?X2<>0, Hc: context [(?X1 * ?X2) / ?X2] |- _ =>
           rewrite (simp_frac_12 X1 X2 H) in *|-
  | H: ?X1<>0, Hc: context [(?X1 * ?X2) / ?X1] |- _ =>
           rewrite (simp_frac_13 X1 X2 H) in *|-
 | H: ?X2<>0, Hc: context [(-?X1) / ?X2] |- _ =>
           rewrite (simp_frac_14 X1 X2 H) in *|-
 | H: - ?X2<>0, Hc: context [ ?X1 / (- ?X2)] |- _ =>
           rewrite (simp_frac_16 X1 X2 H) in *|-;
           let T:=fresh in 
           assert (T:= simp_frac_16_inv X2 H)
 | Hc: context [?X1 / 1] |- _ =>
           rewrite (simp_frac_15 X1) in *|-
end.

Ltac basic_field_simpl := basic_field_simpl_goal;basic_field_simpl_hyps.

Goal forall a b , a<>0 -> b<>0 -> -a<>0 -> -b<>0 ->
 a/a + (-a)/a + a/(-a) + (-a)/(-a) + 0/a + a*(1/a) + (a*b)/a +(a*b)/b -a/1 +a/(-b)= 1  -> 
 b/b + (-b)/b + b/(-b) + (-b)/(-b) +0/b + b*(1/b) +(b*a)/b + (b*a)/a -b/1 + (-a)/1 = 1.

Lemma same_denom_conclude_1 : forall a b c d :F,
 a*d = c*b ->
 b<>0 ->
 d<>0 ->
 a/b = c/d. 

Lemma same_denom_conclude_2 : forall a b c :F,
 a = c*b ->
 b<>0 ->
 a/b = c. 

Lemma same_denom_conclude_3 : forall a c d :F,
 a*d = c ->
 d<>0 ->
 a = c/d. 

Lemma same_denom_conclude_4 : forall a b : F,
 a=0 -> 
 b<>0 ->
 a/b = 0.

Lemma same_denom_conclude_5 : forall a b : F,
 0=a -> 
 b<>0 ->
 0 = a/b.

Ltac split_hyp_not_eq_zero  :=
   repeat 
   match goal with
         |  H: (Fmult _ _) <> F0 |- _ =>
                   case (multnonzero  _ _ H); clear H; intros
         | H: (Fdiv ?X ?Y) <> F0 |- _ =>
                 let T:=fresh in 
               assert (T:= (divnonzero X Y H));clear H
   end.

Goal forall x y : F,
 x*y<>0 -> x/y <> 0 -> True.

Ltac removes_inv_opp :=
 repeat rewrite remove_opp in *;
 repeat rewrite remove_inv in *.

Ltac rewrite_for_same_denom :=
match goal with 
 | H:_ |- context[?X*0] => rewrite simp_1 in *
 | H:_ |- context[0*?X] => rewrite simp_2 in *
 | H:_ |- context[1*?X] => rewrite simp_3 in *
 | H:_ |- context[?X*1] => rewrite simp_4 in *
 | H:_ |- context[0+?X] => rewrite simp_5 in *
 | H:_ |- context[?X+0] => rewrite simp_6 in * 
 | H:_ |- context[?X-0] => rewrite simp_7 in *

 | H1:?B<>0, H2: ?C/?D<>0, H3:?D<>0 |- context[?A/?B / ?C/?D ] =>
     rewrite (same_denom_div_1 A B C D H1 H2 H3) in *;
        let T:=fresh in assert (T:=(invariant_div_1 B C D H1 H2 H3))
 | H1:?B<>0, H2:?C<>0 |- context[(?A/?B) / ?C ] =>
     rewrite (same_denom_div_2 A B C H1 H2) in *;
    let T:=fresh in assert (T:=(nonzeromult B C H1 H2))
 | H1: ?C/?D<>0, H2: ?D<>0 |- context[?A / (?C/?D) ] =>
     rewrite (same_denom_div_3 A C D H1 H2) in *;
      let T:=fresh in assert (T:=(invariant_div_3 C D H1 H2))

 | H1:?B<>0, H2: ?D<>0 |- context[?A/?B + ?C/?D ] =>
     rewrite (same_denom_add_1 A B C D H1 H2) in *;
     let T:=fresh in assert (T:=(nonzeromult B D H1 H2))
 | H1:?B<>0 |- context[?A/?B + ?C ] =>
     rewrite (same_denom_add_2 A B C H1) in *
 | H2: ?D<>0 |- context[?A + ?C/?D ] =>
     rewrite (same_denom_add_3 A C D H2) in *

 | H1:?B<>0, H2: ?D<>0 |- context[?A/?B - ?C/?D ] =>
     rewrite (same_denom_min_1 A B C D H1 H2) in *;
     let T:=fresh in assert (T:=(nonzeromult B D H1 H2))
 | H1:?B<>0 |- context[?A/?B - ?C ] =>
     rewrite (same_denom_min_2 A B C H1) in *
 | H2: ?D<>0 |- context[?A - ?C/?D ] =>
     rewrite (same_denom_min_3 A C D H2) in *

 | H1:?B<>0, H2: ?D<>0 |- context[(?A/?B) * (?C/?D) ] =>
     rewrite (same_denom_mul_1 A B C D H1 H2) in *;
     let T:=fresh in assert (T:=(nonzeromult B D H1 H2))
 | H1:?B<>0 |- context[(?A/?B) * ?C ] =>
     rewrite (same_denom_mul_2 A B C H1) in *
 | H2: ?D<>0 |- context[?A * (?C/?D) ] =>
     rewrite (same_denom_mul_3 A C D H2) in *
end.

Goal forall a b c d, 
b<>0 -> d<>0 -> (a/b) + (c/d) <> 0 ->
(a/b) + (c/d) = (a * d + c * b) / (b * d) .

Goal forall a b c d, 
d<>0 -> (a/b) + (c/d) <> 0 ->
a + (c/d) = (a * d + c) / d.

Ltac same_denom := 
 let H:=fresh in assert (H:=chara_not_2);
 removes_inv_opp;try assumption_or_ax;
 repeat rewrite_for_same_denom.

Ltac same_denom_prepare_for_ring:=  repeat (
  
             apply same_denom_conclude_4 || 
             apply same_denom_conclude_5 || 
 
             apply same_denom_conclude_1 || 
             apply same_denom_conclude_2 || 
             apply same_denom_conclude_3);
  try assumption;same_denom.

Ltac Ffield_before_ring := 
 let H:=fresh in assert (H:=chara_not_2);
  same_denom;
  same_denom_prepare_for_ring.

Ltac Ffield := Ffield_before_ring;Fring.

Goal  forall f f0, 
 f0 <> 0 ->
 f * f0 - (- f0 + f * f0) * (f * f0) * / f0 <> 0 ->
 / (f * f0 - (- f0 + f * f0) * (f * f0) * / f0) * 
     (f * f0 * ((1 - f) * f0) * / f0 * f0) <> 0 ->

/ (f * f0 - (- f0 + f * f0) * (f * f0) * / f0) *
(f * f0 * ((- f0 + f * f0) * f0 * / f0)) *
/
(/ (f * f0 - (- f0 + f * f0) * (f * f0) * / f0) *
 (f * f0 * ((1 - f) * f0) * / f0 * f0)) = - (1).

Goal forall x y z t,  x<>0 -> -x <> 0 -> False ->
- (y * / x) - z * / - x + t * / x = 1.

Goal forall f,  / 2 * f + / 2 * (/ 2 * f) <> 0 ->
- (/ 2 * (/ (/ 2 * f + / 2 * (/ 2 * f)) * (/ 2 * (/ 2 * f) * f))) +
/ 2 * (/ (/ 2 * f + / 2 * (/ 2 * f)) * (/ 2 * f * (/ 2 * f))) = 0.

Goal forall x,  / 2 * x + / 2 * (/ 2 * x) <> 0 -> / 2 * x + / 2 * (/ 2 * x) <> 0 ->
-
(/ 2 *
 (/ (/ 2 * x + / 2 * (/ 2 * x)) *
  (/ 2 * (/ 2 * x) * x))) +
/ 2 *
(/ (/ 2 * x + / 2 * (/ 2 * x)) *
 (/ 2 * x * (/ 2 * x))) = 0.

Goal forall f f1 f0, 
- (f * f1 + (1 - f) * (f0 * f1)) <> 0 ->
-
((f * f1 + (1 - f) * (f0 * f1) - f * f1) * f1 *
 / - (f * f1 + (1 - f) * (f0 * f1))) +
(f * f1 * ((1 - f) * (f0 * f1)) -
 - ((f * f1 + (1 - f) * (f0 * f1) - f * f1) * ((1 - f) * f1))) *
/ - (f * f1 + (1 - f) * (f0 * f1)) = 0.

Goal forall x,  / 2 * (/ 2 * x) <> 0 ->
/ 2 * x * / (/ 2 * (/ 2 * x)) = 2.

Goal forall x y z, z<>0 -> x * (y/z) = (x*y)/z.

Goal forall a b c d : F,
b <> 0 ->
d <> 0 ->
a/b+c/d+a/b = a/b+c/d+a/b.

Goal forall x, -x<>0 -> -x + x = 0.

Goal forall x,  x - x = 0.

Goal forall x, x*x <> 0 -> 1<>0 ->  1/(x*x)<> 0 -> 1 / (1 / (x * x)) = x * x.

Goal forall x, 1/x<>0 -> x <> 0 -> 1 <> 0 ->  1 / (1 / x) = x.

Goal forall x, x <> 0 -> x <> 0 -> x <> 0 ->  1 / x  + 1 /x  = 2/x.

Goal forall x, 2*x <> 0 -> 2*x <> 0 -> x<>0 ->  1 / (2*x)  + 1 /(2*x)  = 1/x.

Goal forall x, 1*x <> 0 -> 1*x <> 0 -> 1/2*x<>0 -> 1 / (1*x)  + 1 /(1*x)  = 1/(1/2*x).

Goal forall x,  x - (1 - - (1)) * (/ 2 * x) = 0.

Goal forall x, x <> 0 -> 
2*2*2*2*2*2*2*2*x<>0 ->
2*2*2*2*2*2*2*2*x<>0 -> 
2*2*2*2*2*2*2*x<>0 ->
 1 / (2*2*2*2*2*2*2*2*x)  + 1 /(2*2*2*2*2*2*2*2*x)  = 1/(2*2*2*2*2*2*2*x).

Lemma eq_simpl: forall a b : F,
a-b = 0 -> a =b .

Ltac ring_simplify_eq := apply eq_simpl;ring_simplify. *)

Ltac uniformize_signed_areas_goal :=
  repeat
   match goal with
   |  |- context [(- - ?X1)] =>
       replace (- - X1) with X1 by apply simplring1
   |  |- context [(S ?X1 ?X1 ?X2)] =>
       replace (S X1 X1 X2) with 0 by apply trivial_col1
   |  |- context [(S ?X2 ?X1 ?X1)] =>
       replace (S X2 X1 X1) with 0 by apply trivial_col2
   |  |- context [(S ?X1 ?X2 ?X1)] =>
       replace (S X1 X2 X1) with 0 by apply trivial_col3
   |  |- context [(S ?X1 ?X2 ?X3)] =>
    ( let Truc := fresh in
    match goal with
       |  |- context [(S ?X4 ?X5 ?X6)] =>
            (assert (Truc : S X4 X5 X6 = - S X1 X2 X3);
             [ apply S_3 || apply S_2 || apply S_4
             | rewrite Truc; clear Truc ]) ||
             (assert (Truc : S X4 X5 X6 = S X1 X2 X3);
               [ apply S_0 || apply S_1 | rewrite Truc; clear Truc ])
       end)
   end.

Ltac generalize_all_areas :=
   repeat match goal with
          H: context [(S ?X1 ?X2 ?X3)] |- _=> revert H
 end.

Ltac uniformize_signed_areas :=
  generalize_all_areas;uniformize_signed_areas_goal;intros.

Lemma S4Simpl_1 : forall A B C : Point, S4 A B B C = S A B C.
intros.
unfold S4 in |- *.
uniformize_signed_areas.
ring.
Qed.

Lemma S4Simpl_2 : forall A B C : Point, S4 A B C C = S A B C.
intros.
unfold S4 in |- *.
uniformize_signed_areas.
ring.
Qed.

Lemma S4Simpl_3 : forall A B C : Point, S4 A A B C = S A B C.
intros.
unfold S4 in |- *.
uniformize_signed_areas.
ring.
Qed.

Lemma S4Simpl_4 : forall A B C : Point, S4 A B C A = S A B C.
intros.
unfold S4 in |- *.
uniformize_signed_areas.
ring.
Qed.

Lemma S4Simpl_5 : forall A C D : Point, S4 C A D A = 0.
Proof.
intros.
unfold S4 in |- *.
uniformize_signed_areas.
ring.
Qed.

Lemma S4Simpl_6 : forall A C D : Point, S4 A C A D = 0.
Proof.
intros.
unfold S4 in |- *.
uniformize_signed_areas.
ring.
Qed.

Lemma half : 1- 1/2 = 1/2.
Proof.
field.
auto with Geom.
Qed.

Ltac uniformize_signed_areas4_goal :=
  repeat
   match goal with
   |  |- context [(- - ?X1)] =>      
       replace (- - X1) with X1; [ idtac | apply simplring1 ]
   |  |- context [(S4 ?X1 ?X2 ?X1 ?X3)] =>
	rewrite (S4Simpl_6 X1 X2 X3)
   |  |- context [(S4 ?X2 ?X1 ?X3 ?X1)] =>
        rewrite (S4Simpl_5 X1 X2 X3)
   |  |- context [(S4 ?X1 ?X2 ?X2 ?X3)] =>
        rewrite (S4Simpl_1 X1 X2 X3)
   |  |- context [(S4 ?X1 ?X2 ?X3 ?X3)] =>
        rewrite (S4Simpl_2 X1 X2 X3)
   |  |- context [(S4 ?X1 ?X1 ?X2 ?X3)] =>
        rewrite (S4Simpl_3 X1 X2 X3)
   |  |- context [(S4 ?X1 ?X2 ?X3 ?X1)] =>
        rewrite (S4Simpl_4 X1 X2 X3)
   |  |- context [(S4 ?X1 ?X2 ?X3 ?X4)] =>
       match goal with
       |  |- context [(S4 ?X5 ?X6 ?X7 ?X8)] =>
           (assert (Truc : S4 X5 X6 X7 X8 = - S4 X1 X2 X3 X4);
             [ apply S4_5 || apply S4_6 || apply S4_7 || apply S4_8
             | rewrite Truc; clear Truc ]) ||
             (assert (Truc : S4 X5 X6 X7 X8 = S4 X1 X2 X3 X4);
               [ apply S4_2 || apply S4_3 || apply S4_4
               | rewrite Truc; clear Truc ])
       end
   end.

Ltac generalize_all_areas4 :=
   repeat match goal with
          H: context [(S4 ?X1 ?X2 ?X3 ?X4)] |- _=> revert H
 end.

Ltac uniformize_signed_areas4 :=
  generalize_all_areas4;uniformize_signed_areas4_goal;intros.

Ltac uniformize_dir_seg_goal :=
  repeat
   match goal with
   |  |- context [(- - ?X1)] =>
       replace (- - X1) with X1; [ idtac | apply simplring1 ]
   |  |- context [(?X1 ** ?X1)] =>
       rewrite <- (nuldirseg X1)
   |  |- context [(?X1 ** ?X2)] =>
       match goal with
       |  |- context [(?X3 ** ?X4)] =>
           match constr:((X3, X4)) with
           | (?X2, ?X1) => rewrite (A1a X1 X2)
           end
       end
   end.

Ltac generalize_all_seg :=
   repeat match goal with
          H: context [(?X1 ** ?X2)] |- _=> revert H
 end.

Ltac uniformize_dir_seg_general :=
  generalize_all_seg;uniformize_dir_seg_goal;intros.

Ltac try_rw A B := try rewrite <- (A1a B A) in *;
                   try rewrite    (A1a A B) in *.

Ltac uniformize_dir_seg_spec := match reverse goal with

 | [A : Point, B : Point, C : Point, 
    D : Point, E : Point, F : Point,
    G : Point |- _ ] => fail 1

 | [A : Point, B : Point, C : Point, D: Point, E: Point, F: Point |- _ ] => 
     try_rw A B; try_rw A C; try_rw A D; try_rw A E; try_rw A F; 
     try_rw B C; try_rw B D; try_rw B E; try_rw B F;
     try_rw C D; try_rw C E; try_rw C F;
     try_rw D E; try_rw D F;
     try_rw E F

 | [A : Point, B : Point, C : Point, D: Point, E: Point |- _ ] => 
     try_rw A B; try_rw A C; try_rw A D; try_rw A E; 
     try_rw B C; try_rw B D; try_rw B E;
     try_rw C D; try_rw C E;
     try_rw D E

 | [A : Point, B : Point, C : Point, D: Point |- _ ] => 
     try_rw A B; try_rw A C; try_rw A D; try_rw B C; try_rw B D; try_rw C D

 | [A : Point, B : Point, C : Point |- _ ] => 
     try_rw A B; try_rw A C;try_rw B C

 | [A : Point, B : Point |- _ ] => 
     try_rw A B
end.
 
Ltac uniformize_dir_seg := uniformize_dir_seg_spec || uniformize_dir_seg_general.

Lemma test_uniformize_dir_seg_1 : forall A B,
A ** B = - B**A.
Proof.
intros.
uniformize_dir_seg.
ring.
Qed.

Lemma test_uniformize_dir_seg_2 : forall A B,
A ** B = - B**A ->
A ** B = - B**A.
Proof.
intros.
uniformize_dir_seg.
ring.
Qed.

Lemma test_uniformize_dir_seg_3 : forall A B C,
A ** B = - B**A + A**C + C**A + B**C + C**A ->
A ** B = - B**A.
Proof.
intros.
uniformize_dir_seg.
ring.
Qed.

Lemma test_uniformize_dir_seg_4 : forall A B C D,
A ** B = - B**A + A**C + C**A + B**C + C**A + D**A + A**D->
A ** B = - B**A.
Proof.
intros.
uniformize_dir_seg.
ring.
Qed.

Lemma test_uniformize_dir_seg_5 : forall A B C D, forall  E F G H I : Point,
A ** B = - B**A + A**C + C**A + B**C + C**A + D**A + A**D->
A ** B = - B**A.
Proof.
intros.
uniformize_dir_seg.
ring.
Qed.

Hint Rewrite S4Simpl_1  S4Simpl_2 S4Simpl_3 S4Simpl_4 S4Simpl_5 S4Simpl_6 : S4_simplifications.
Hint Rewrite <- trivial_col1: S_simplifications.
Hint Rewrite <- trivial_col2: S_simplifications.
Hint Rewrite <- trivial_col3: S_simplifications.
Hint Rewrite <- nuldirseg : seg_simplifications.
Hint Rewrite half  : seg_simplifications.

Ltac basic_non_field_simpl:= autorewrite with ring_simplification 
                               S4_simplifications 
                             S_simplifications
          seg_simplifications in *.

Ltac basic_simpl := repeat (progress (basic_non_field_simpl;basic_field_simpl)).

