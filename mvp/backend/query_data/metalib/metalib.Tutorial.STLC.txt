
Require Import Metalib.Metatheory.
(* Metalib.Metatheory:
Require Export Coq.Arith.Arith.
Require Export Coq.FSets.FSets.
Require Export Coq.Lists.List.

Require Export Metalib.AssocList.
Require Export Metalib.CoqListFacts.
Require Export Metalib.LibTactics.
Require Export Metalib.MetatheoryAtom.

Notation "E [=] F" :=
  (AtomSetImpl.Equal E F)
  (at level 70, no associativity)
  : set_scope.

Notation "E [<=] F" :=
  (AtomSetImpl.Subset E F)
  (at level 70, no associativity)
  : set_scope.

Notation "{}" :=
  (AtomSetImpl.empty)
  : set_scope.

Notation "{{  x  }}" :=
  (AtomSetImpl.singleton x)
  : set_scope.

Notation "x `in` E" :=
  (AtomSetImpl.In x E)
  (at level 70)
  : set_hs_scope.

Notation "x `notin` E" :=
  (~ AtomSetImpl.In x E)
  (at level 70)
  : set_hs_scope.

Notation "E `union` F" :=
  (AtomSetImpl.union E F)
  (at level 65, right associativity, format "E  `union`  '/' F")
  : set_hs_scope.

Notation add := AtomSetImpl.add.
Notation empty := AtomSetImpl.empty.
Notation remove := AtomSetImpl.remove.
Notation singleton := AtomSetImpl.singleton.
Notation union := AtomSetImpl.union.

Open Scope set_scope.
Open Scope set_hs_scope.

Module Export EnvImpl := AssocList.Make Atom AtomSetImpl.

Ltac simpl_env :=
  simpl_alist.

Tactic Notation "simpl_env" "in" hyp(H) :=
  simpl_alist in H.

Tactic Notation "simpl_env" "in" "*" :=
  simpl_alist in *.

Tactic Notation "rewrite_env" constr(E) :=
  rewrite_alist E.

Tactic Notation "rewrite_env" constr(E) "in" hyp(H) :=
  rewrite_alist E in H.

Tactic Notation "env" "induction" ident(E) :=
  alist induction E.

Tactic Notation "env" "induction" ident(E) "as" simple_intropattern(P) :=
  alist induction E as P.

Notation "[ x ]" := (EnvImpl.one x) : env_scope.

Open Scope env_scope.

Tactic Notation
  "pick" "fresh" ident(atom_name)
  "excluding" constr(L)
  "and" "apply" constr(H)
  :=
    first [apply (@H L) | eapply (@H L)];
      match goal with
        | |- forall _, _ `notin` _ -> _ =>
          let Fr := fresh "Fr" in intros atom_name Fr
        | |- forall _, _ `notin` _ -> _ =>
          fail 1 "because" atom_name "is already defined"
        | _ =>
          idtac
      end.

Tactic Notation
  "pick" "fresh" ident(atom_name)
  "and" "apply" constr(H)
  :=
    let L := gather_atoms in
    let L := beautify_fset L in
    pick fresh atom_name excluding L and apply H.

Notation uniq_one := uniq_one_1.
Notation uniq_cons := uniq_cons_3.
Notation uniq_app := uniq_app_4.
Notation uniq_map := uniq_map_2.

Notation binds_one := binds_one_3.
Notation binds_cons := binds_cons_3.
Notation binds_app_l := binds_app_2.
Notation binds_app_r := binds_app_3.
Notation binds_map := binds_map_2.

Notation notin_empty := notin_empty_1.
Notation notin_add := notin_add_3.
Notation notin_singleton := notin_singleton_2.
Notation notin_union := notin_union_3.

Ltac hint_extern_solve_notin :=
  try eassumption;
  autorewrite with rewr_dom in *;
  destruct_notin;
  repeat first [ apply notin_union_3
               | apply notin_add_3
               | apply notin_singleton_2
               | apply notin_empty_1
               ];
  try tauto.

Hint Extern 1 (_ <> _ :> _) => hint_extern_solve_notin.

Hint Extern 1 (_ `notin` _) => hint_extern_solve_notin.

Hint Resolve
  AtomSetImpl.add_1 AtomSetImpl.add_2 AtomSetImpl.remove_1
  AtomSetImpl.remove_2 AtomSetImpl.singleton_2 AtomSetImpl.union_2
  AtomSetImpl.union_3 AtomSetImpl.inter_3 AtomSetImpl.diff_3.

Require Export Metalib.CoqEqDec.

Notation " x  == y " := (eq_dec x y) (at level 70) : coqeqdec_scope.

Open Scope coqeqdec_scope.

Notation var := atom (only parsing).

Notation vars := atoms (only parsing).

Notation eq_var := eq_dec (only parsing).

Notation "x  ===  y" :=
  (x == y)
  (at level 70, only parsing)
  : coqeqdec_scope.

Notation "x \in s" :=
  (x `in` s)
  (at level 70, only parsing)
  : set_sl_scope.

Notation "x \notin s" :=
  (x `notin` s)
  (at level 70, only parsing)
  : set_sl_scope.

Notation "s \u t" :=
  (s `union` t)
  (at level 65, right associativity, only parsing)
  : set_sl_scope.

Open Scope set_sl_scope.

Ltac gather_vars_with F := gather_atoms_with.

Ltac pick_fresh_gen L Y := pick fresh Y for L.

Tactic Notation "auto" "*" := auto.

Ltac apply_fresh_base H gather_vars atom_name :=
  let L := gather_vars in
  let L := beautify_fset L in
  pick fresh x excluding L and apply H.

Set Implicit Arguments.
Definition union_map (A:Set) (f:A -> vars) (l:list A) :=
 (List.fold_right (fun t acc => f t \u acc) {}) l. *)

Inductive typ : Set :=
  | typ_base  : typ
  | typ_arrow : typ -> typ -> typ.

Inductive exp : Set :=
  | bvar : nat  -> exp
  | fvar : atom -> exp
  | abs  : typ -> exp  -> exp
  | app  : exp  -> exp -> exp.

Coercion bvar : nat >-> exp.
Coercion fvar : atom >-> exp.

Parameter Y : atom.
Definition demo_rep1 := abs typ_base (app Y 0).

Definition demo_rep2 := abs typ_base (abs typ_base (app 0 1)).

Fixpoint subst (z : atom) (u : exp) (e : exp)
  {struct e} : exp :=
  match e with
    | bvar i => bvar i
    | fvar x => if x == z then u else (fvar x)
    | abs t e1 => abs t (subst z u e1)
    | app e1 e2 => app (subst z u e1) (subst z u e2)
  end.

Notation "[ z ~> u ] e" := (subst z u e) (at level 68).

Parameter Z : atom.

Lemma demo_subst1:
  [Y ~> Z] (abs typ_base (app 0 Y)) = (abs typ_base (app 0 Z)).
Proof.
  simpl.
  destruct (Y==Y).
  Case "left".
    auto.
  Case "right".
    destruct n. auto.
Qed.

Lemma subst_eq_var: forall (x : atom) u,
  [x ~> u]x = u.
Proof.
   Admitted.

Lemma subst_neq_var : forall (x y : atom) u,
  y <> x -> [x ~> u]y = y.
Proof.
   Admitted.

Fixpoint fv (e : exp) {struct e} : atoms :=
  match e with
    | bvar i => empty
    | fvar x => singleton x
    | abs t e1 => fv e1
    | app e1 e2 => (fv e1) `union` (fv e2)
  end.

Lemma f_equal_demo : forall e1 e2, e1 = e2 -> fv e1 = fv e2.
Proof.
  intros e1 e2 EQ.
  f_equal.
  assumption.
Qed.

Lemma fsetdec_demo : forall (x :atom) (S : atoms),
  x `in` (singleton x `union` S).
Proof.
  fsetdec.
Qed.

Lemma subst_fresh : forall (x : atom) e u,
  x `notin` fv e -> [x ~> u] e = e.
Proof.
   Admitted.

Lemma subst_notin_fv : forall x y u e,
   x `notin` fv e -> x `notin` fv u ->
   x `notin` fv ([y ~> u]e).
Proof.
  intros x y u e Fr1 Fr2.
  induction e; simpl in *.
  Case "bvar".
    assumption.
  Case "fvar".
  destruct (a == y).
      assumption.
      simpl. assumption.
  Case "abs".
    apply IHe. assumption.
  Case "app".
    destruct_notin.
    apply notin_union.
    apply IHe1.
    assumption.
    apply IHe2.
    assumption.
Qed.

Fixpoint open_rec (k : nat) (u : exp)(e : exp)
  {struct e} : exp :=
  match e with
    | bvar i => if k == i then u else (bvar i)
    | fvar x => fvar x
    | abs t e1 => abs t (open_rec (S k) u e1)
    | app e1 e2 => app (open_rec k u e1) (open_rec k u e2)
  end.

Definition open e u := open_rec 0 u e.

Lemma demo_open :
  open (app (abs typ_base (app 1 0)) 0) Y =
       (app (abs typ_base (app Y 0)) Y).
Proof.
Admitted.

Inductive lc : exp -> Prop :=
  | lc_var : forall (x:atom),
      lc x
  | lc_abs : forall (x : atom) e t,
      x `notin` fv e -> lc (open e x) ->
      lc (abs t e)
  | lc_app : forall e1 e2,
      lc e1 -> lc e2 ->
      lc (app e1 e2).

Hint Constructors lc.

Section BasicOperations.
Local Notation "{ k ~> u } t" := (open_rec k u t) (at level 67).

Lemma open_rec_lc_0 : forall k u e,
  lc e ->
  e = {k ~> u} e.
Proof.
  intros k u e LC.
  induction LC.
  Case "lc_fvar".
    simpl.
    auto.
  Case "lc_abs".
    simpl.
    f_equal.
Admitted.

Lemma open_rec_lc_1 : forall k u e,
  lc e ->
  e = {k ~> u} e.
Proof.
  intros k u e LC.
  generalize dependent k.
  induction LC.
  Case "lc_fvar".
    simpl. auto.
  Case "lc_abs".
    simpl.
    intro k.
    f_equal.
Admitted.

Lemma open_rec_lc_core : forall e j v i u,
  i <> j ->
  {j ~> v} e = {i ~> u} ({j ~> v} e) ->
  e = {i ~> u} e.
Proof.
  induction e; intros j v i u Neq H; simpl in *.
  Case "bvar".
    destruct (j == n);  destruct (i == n).
      SCase "j = n = i".
        subst n. destruct Neq. auto.
      SCase "j = n, i <> n".
        auto.
      SCase "j <> n, i = n".
        subst n. simpl in H.
        destruct (i == i).
           SSCase "i=i".
             auto.
           SSCase "i<>i".
             destruct n. auto.
      SCase "j <> n, i <> n".
        auto.
  Case "fvar".
    auto.
  Case "abs".
    f_equal.
    inversion H.
    apply  IHe with (j := S j) (u := u) (i := S i) (v := v).
    auto.
    auto.
  Case "app".
    inversion H.
    f_equal.
    eapply IHe1; eauto.
    eapply IHe2; eauto.
Qed.

Lemma open_rec_lc : forall k u e,
  lc e -> e = {k ~> u} e.
Proof.
  intros k u e LC.
  generalize dependent k.
  induction LC.
  Case "lc_fvar".
    simpl.
    auto.
  Case "lc_abs".
    simpl.
    intro k.
    f_equal.
    unfold open in *.
    apply open_rec_lc_core with
      (i := S k) (j := 0) (u := u) (v := fvar x).
    auto.
    auto.
  Case "lc_app".
    intro k.
    simpl.
    f_equal.
    auto.
    auto.
Qed.

Lemma subst_open_rec : forall e1 e2 u (x : atom) k,
  lc u ->
  [x ~> u] ({k ~> e2} e1) = {k ~> [x ~> u] e2} ([x ~> u] e1).
Proof.
   Admitted.

Lemma subst_open_var : forall (x y : atom) u e,
  y <> x ->
  lc u ->
  open ([x ~> u] e) y = [x ~> u] (open e y).
Proof.
   Admitted.

Lemma subst_intro : forall (x : atom) u e,
  x `notin` (fv e) ->
  open e u = [x ~> u](open e x).
Proof.
   Admitted.

End BasicOperations.

Lemma subst_lc_0 : forall (x : atom) u e,
  lc e ->
  lc u ->
  lc ([x ~> u] e).
Proof.
  intros x u e He Hu.
  induction He.
  Case "lc_fvar".
    simpl.
    destruct (x0 == x).
      auto.
      auto.
  Case "lc_abs".
    simpl.
    
    apply lc_abs with (x:=x0).
    apply subst_notin_fv.
    auto.
Admitted.

Inductive lc_c : exp -> Prop :=
  | lc_var_c : forall (x:atom),
      lc_c x
  | lc_abs_c : forall (L : atoms) e T,
      (forall x : atom, x `notin` L -> lc_c (open e x)) ->
      lc_c (abs T e)
  | lc_app_c : forall e1 e2,
      lc_c e1 ->
      lc_c e2 ->
      lc_c (app e1 e2).

Hint Constructors lc_c.

Section CofiniteQuantification.
Local Notation "{ k ~> u } t" := (open_rec k u t) (at level 67).

Lemma open_rec_lc_c : forall k u e,
  lc_c e ->
  e = {k ~> u} e.
Proof.
  intros k u e LC.
  generalize dependent k.
  induction LC.
  Case "lc_fvar".
    simpl.
    auto.
  Case "lc_abs".
    simpl.
    intro k.
    f_equal.
    unfold open in *.
    pick fresh x for L.  
    apply open_rec_lc_core with
      (i := S k) (j := 0) (u := u) (v := fvar x).
    auto.
    auto.
  Case "lc_app".
    intro k.
    simpl.
    f_equal.
    auto.
    auto.
Qed.

Lemma subst_open_rec_c : forall e1 e2 u (x : atom) k,
  lc_c u ->
  [x ~> u] ({k ~> e2} e1) = {k ~> [x ~> u] e2} ([x ~> u] e1).
Proof.
 Admitted.

Lemma subst_open_var_c : forall (x y : atom) u e,
  y <> x ->
  lc_c u ->
  open ([x ~> u] e) y = [x ~> u] (open e y).
Proof.
   Admitted.

Lemma subst_lc_c : forall (x : atom) u e,
  lc_c e ->
  lc_c u ->
  lc_c ([x ~> u] e).
Proof.
  intros x u e He Hu.
  induction He.
  Case "lc_var_c".
   simpl.
   destruct (x0 == x).
     auto.
     auto.
  Case "lc_abs_c".
    simpl.
     Admitted.

End CofiniteQuantification.

Ltac gather_atoms ::=
  let A := gather_atoms_with (fun x : atoms => x) in
  let B := gather_atoms_with (fun x : atom => singleton x) in
  let C := gather_atoms_with (fun x : list (atom * typ) => dom x) in
  let D := gather_atoms_with (fun x : exp => fv x) in
  constr:(A `union` B `union` C `union` D).

Lemma subst_lc_c_alternate_proof : forall (x : atom) u e,
  lc_c e ->
  lc_c u ->
  lc_c ([x ~> u] e).
Proof.
  intros x u e He Hu.
  induction He.
  Case "fvar".
   simpl.
   destruct (x0 == x).
     auto.
     auto.
  Case "abs".
    simpl.
    pick fresh y and apply lc_abs_c.
    
    rewrite subst_open_var_c. auto. auto. auto.
  Case "app".
     simpl. auto.
Qed.

Notation env := (list (atom * typ)).

Lemma append_assoc_demo : forall (E0 E1 E2 E3:env),
  E0 ++ (E1 ++ E2) ++ E3 = E0 ++ E1 ++ E2 ++ E3.
Proof.
  intros.
  auto. 
  simpl_env.
  reflexivity.
Qed.

Lemma simpl_env_demo : forall (x y:atom) (T1 T2:typ) (E F:env),
   ((x ~ T1) ++ nil) ++ (y,T2) :: (nil ++ E) ++ F =
   (x ~ T1) ++ (y ~ T2) ++ E ++ F.
Proof.
   intros.
   
   simpl_env.
   reflexivity.
Qed.

Lemma rewrite_env_demo : forall (x y:atom) (T:typ) P,
  (forall E, P ((x,T):: E) -> True) ->
  P (x ~ T) ->
  True.
Proof.
  intros x y T P H.
  
  rewrite_env ((x,T) :: nil).
  apply H.
Qed.

Lemma binds_demo : forall (x:atom) (T:typ) (E F:env),
  binds x T (E ++ (x ~ T) ++ F).
Proof.
  auto.
Qed.

Lemma dom_demo : forall (x y : atom) (T : typ),
  dom (x ~ T) [=] singleton x.
Proof.
  auto.
Qed.

Lemma uniq_demo : forall (x y : atom) (T : typ),
  x <> y -> uniq ((x ~ T) ++ (y ~ T)).
Proof.
  auto.
Qed.

Inductive typing_c : env -> exp -> typ -> Prop :=
  | typing_var_c : forall E (x : atom) T,
      uniq E ->
      binds x T E ->
      typing_c E (fvar x) T
  | typing_abs_c : forall (L : atoms) E e T1 T2,
      (forall (x:atom), x `notin` L ->
        typing_c ((x ~ T1) ++ E) (open e x) T2) ->
      typing_c E (abs T1 e) (typ_arrow T1 T2)
  | typing_app_c : forall E e1 e2 T1 T2,
      typing_c E e1 (typ_arrow T1 T2) ->
      typing_c E e2 T1 ->
      typing_c E (app e1 e2) T2.

Hint Constructors typing_c.

Lemma typing_weakening_0 : forall E F e T,
  typing_c E e T ->
  uniq (F ++ E) ->
  typing_c (F ++ E) e T.
Proof.
  intros E F e T H J.
  induction H; eauto.
  Case "typing_abs_c".
    pick fresh x and apply typing_abs_c.
    
Admitted.

Lemma typing_weakening_strengthened_0 : forall (E F G : env) e T,
  typing_c (G ++ E) e T ->
  uniq (G ++ F ++ E) ->
  typing_c (G ++ F ++ E) e T.
Proof.
  intros E F G e T H J.
  induction H.
  Case "typing_var_c".
    
  Focus 2.
  Case "typing_abs_c".
    
Admitted.

Lemma typing_c_weakening_strengthened :  forall (E F G : env) e T,
  typing_c (G ++ E) e T ->
  uniq (G ++ F ++ E) ->
  typing_c (G ++ F ++ E) e T.
Proof.
  intros E F G e T H.
  remember (G ++ E) as E'.
  generalize dependent G.
  induction H; intros G Eq Uniq; subst.
  Admitted.

Lemma typing_c_weakening : forall (E F : env) e T,
    typing_c E e T ->
    uniq (F ++ E) ->
    typing_c (F ++ E) e T.
Proof.
  intros E F e T H J.
  rewrite_env (nil ++ F ++ E).
  apply typing_c_weakening_strengthened; auto.
Qed.

Lemma typing_subst_var_case : forall (E F : env) u S T (z x : atom),
  binds x T (F ++ (z ~ S) ++ E) ->
  uniq (F ++ (z ~ S) ++ E) ->
  typing_c E u S ->
  typing_c (F ++ E) ([z ~> u] x) T.
Proof.
  intros E F u S T z x H J K.
  simpl.
  Admitted.

Lemma typing_c_to_lc_c : forall E e T,
  typing_c E e T -> lc_c e.
Proof.
  intros E e T H. induction H; eauto.
Qed.

Lemma typing_c_subst : forall (E F : env) e u S T (z : atom),
  typing_c (F ++ (z ~ S) ++ E) e T ->
  typing_c E u S ->
  typing_c (F ++ E) ([z ~> u] e) T.
Proof.
 Admitted.

Lemma typing_c_subst_simple : forall (E : env) e u S T (z : atom),
  typing_c ((z ~ S) ++ E) e T ->
  typing_c E u S ->
  typing_c E ([z ~> u] e) T.
Proof.
 Admitted.

Inductive value_c : exp -> Prop :=
  | value_abs_c : forall e T1,
      lc_c (abs T1 e) ->
      value_c (abs T1 e).

Inductive eval_c : exp -> exp -> Prop :=
  | eval_beta_c : forall e1 e2 T1,
      lc_c (abs T1 e1) ->
      value_c e2 ->
      eval_c (app (abs T1 e1) e2) (open e1 e2)
  | eval_app_1_c : forall e1 e1' e2,
      lc_c e2 ->
      eval_c e1 e1' ->
      eval_c (app e1 e2) (app e1' e2)
  | eval_app_2_c : forall e1 e2 e2',
      value_c e1 ->
      eval_c e2 e2' ->
      eval_c (app e1 e2) (app e1 e2').

Hint Constructors value_c eval_c.

Lemma preservation_c : forall (E : env) e e' T,
  typing_c E e T ->
  eval_c e e' ->
  typing_c E e' T.
Proof.
  intros E e e' T H.
  generalize dependent e'.
  induction H; intros e' J.
 Admitted.

Lemma progress_c : forall e T,
  typing_c nil e T ->
  value_c e \/ exists e', eval_c e e'.
Proof.
  intros e T H.

  assert (typing_c nil e T); auto.

  remember (@nil (atom * typ)) as E.

  induction H; subst.

 Admitted.

Lemma typing_c_uniq : forall E e T,
  typing_c E e T -> uniq E.
Proof.
  intros E e T H.
  induction H; auto.
  Case "typing_abs_c".
    pick fresh x.
    assert (uniq ((x ~ T1) ++ E)); auto.
    inversion H1. auto.
Qed.

Lemma typing_c_rename : forall (x y : atom) E e T1 T2,
  x `notin` fv e -> y `notin` (dom E `union` fv e) ->
  typing_c ((x ~ T1) ++ E) (open e x) T2 ->
  typing_c ((y ~ T1) ++ E) (open e y) T2.
Proof.
  intros x y E e T1 T2 Fr1 Fr2 H.
  destruct (x == y).
  Case "x = y".
    subst; eauto.
  Case "x <> y".
    assert (J : uniq ((x ~ T1) ++ E)).
      eapply typing_c_uniq; eauto.
    assert (J' : uniq E).
      inversion J; eauto.
    rewrite (@subst_intro x); eauto.
    rewrite_env (nil ++ (y ~ T1) ++ E).
    apply typing_c_subst with (S := T1).
    simpl_env.
    SCase "(open x s) is well-typed".
      apply typing_c_weakening_strengthened. eauto. auto.
    SCase "y is well-typed".
      eapply typing_var_c; eauto.
Qed.

Inductive typing : env -> exp -> typ -> Prop :=
  | typing_var : forall E (x : atom) T,
      uniq E ->
      binds x T E ->
      typing E (fvar x) T
  | typing_abs : forall E e T1 T2 (x : atom),
      x `notin` fv e ->
      typing ((x ~ T1) ++ E) (open e x) T2 ->
      typing E (abs T1 e) (typ_arrow T1 T2)
  | typing_app : forall E e1 e2 T1 T2,
      typing E e1 (typ_arrow T1 T2) ->
      typing E e2 T1 ->
      typing E (app e1 e2) T2.

Inductive value : exp -> Prop :=
  | value_abs : forall e T1,
      lc (abs T1 e) ->
      value (abs T1 e).

Inductive eval : exp -> exp -> Prop :=
  | eval_beta : forall e1 e2 T1,
      lc (abs T1 e1) ->
      value e2 ->
      eval (app (abs T1 e1) e2) (open e1 e2)
  | eval_app_1 : forall e1 e1' e2,
      lc e2 ->
      eval e1 e1' ->
      eval (app e1 e2) (app e1' e2)
  | eval_app_2 : forall e1 e2 e2',
      value e1 ->
      eval e2 e2' ->
      eval (app e1 e2) (app e1 e2').

Hint Constructors typing value eval.

Lemma lc_rename : forall e (x:atom) (y:atom),
  x `notin` fv e ->
  lc_c (open e x) -> lc_c (open e y).
Proof.
  intros e x y Frx LCx.
  rewrite (@subst_intro x); auto.
  apply subst_lc_c; auto.
Qed.

Lemma lc_to_lc_c : forall e, lc e -> lc_c e.
Proof.
  intros e LC.
  induction LC; auto.
  Case "lc_abs".
    apply lc_abs_c with (L := fv e).
    intros.
    apply lc_rename with (x := x); auto.
Qed.

Lemma lc_c_to_lc : forall e, lc_c e -> lc e.
Proof.
 Admitted.

Lemma typing_to_typing_c : forall E e T,
  typing E e T -> typing_c E e T.
Proof.
intros E e T H.
induction H; eauto.
Case "typing_abs".
  pick fresh y and apply typing_abs_c; auto.
  apply typing_c_rename with (x:=x); auto.
Qed.

Lemma typing_c_to_typing : forall E e T,
  typing_c E e T -> typing E e T.
Proof.
 Admitted.

Lemma value_to_value_c : forall e,
  value e -> value_c e.
Proof.
  intros e H.
  induction H; eauto using lc_to_lc_c.
Qed.

Lemma value_c_to_value : forall e,
  value_c e -> value e.
Proof.
   Admitted.

Lemma eval_to_eval_c : forall e e',
  eval e e' -> eval_c e e'.
Proof.
  intros e e' H.
  induction H; eauto using lc_to_lc_c, value_to_value_c.
Qed.

Lemma eval_c_to_eval : forall e e',
  eval_c e e' -> eval e e'.
Proof.
   Admitted.

Lemma preservation : forall E e e' T,
  typing E e T ->
  eval e e' ->
  typing E e' T.
Proof.
  intros E e e' T HT HE.
  apply typing_c_to_typing.
  eapply preservation_c; eauto.
  eapply typing_to_typing_c. eauto.
  apply eval_to_eval_c. auto.
Qed.

Lemma progress : forall e T,
  typing nil e T ->
  value e \/ exists e', eval e e'.
Proof.
  intros e T HT.
  assert (typing_c nil e T).
  eapply typing_to_typing_c; auto.
  destruct (progress_c e T H) as [V | [e'' EV]].
  left. apply value_c_to_value. auto.
  right. exists e''. apply eval_c_to_eval. auto.
Qed.

Lemma subst_lc : forall (x : atom) u e,
  lc e ->
  lc u ->
  lc ([x ~> u] e).
Proof.
eauto using lc_c_to_lc, subst_lc_c, lc_to_lc_c.
Qed.

Lemma open_abs : forall e u T1,
  lc (abs T1 e) ->
  lc u ->
  lc (open e u).
Proof.
   Admitted.

Lemma value_to_lc : forall e,
  value e -> lc e.
Proof.
   Admitted.

Lemma eval_to_lc : forall e1 e2,
  eval e1 e2 -> lc e1 /\ lc e2.
Proof.
   Admitted.

Lemma typing_to_lc : forall E e T,
  typing E e T -> lc e.
Proof.
   Admitted.

Lemma eq_typ_dec : forall (T T' : typ),
  { T = T' } + { T <> T' }.
Proof.
  decide equality.
Qed.

Lemma typing_c_unique : forall E e T1 T2,
  typing_c E e T1 ->
  typing_c E e T2 ->
  T1 = T2.
Proof.
 Admitted.

Definition decidable (P : Prop) := (P \/ ~ P).

Lemma typing_c_decidable : forall E e,
  lc_c e -> uniq E -> decidable (exists T, typing_c E e T).
Proof.
  intros E e LC Uniq.
  generalize dependent E.
  induction LC; intros E Uniq.
  Case "typing_var_c".
    destruct (@binds_lookup_dec _ x E) as [[T H] | H].
      SCase "variable is in environment".
      left; eauto.
      SCase "variable not in environment".
      right.  intros [T J]. inversion J; subst; eauto.
  Case "typing_abs_c".
            pick fresh x.
    assert (Fr' : x `notin` L) by auto.
    destruct (H0 x Fr' ((x ~ T) ++ E)) as [[S J] | J]; eauto.
    SCase "body typeable".
      left.
      exists (typ_arrow T S).
      
      pick fresh z and apply typing_abs_c.
      apply typing_c_rename with (x := x); eauto.
    SCase "body not typeable".
      right.
      intros [S K].
      inversion K; subst.
      apply J.
      exists T2.
      pick fresh z.
      apply typing_c_rename with (x := z); eauto.
  Case "typing_app_c".
    destruct (IHLC1 E) as [[T H] | H]; eauto.
    SCase "function typeable".
      destruct (IHLC2 E) as [[S J] | J]; eauto.
      SSCase "argument typeable".
        destruct T.
          SSSCase "function has typ_base".
            right.
            intros [S' J'].
            inversion J'; subst.
            assert (K : typ_base = typ_arrow T1 S'); eauto using typing_c_unique.
            inversion K.
          SSSCase "typ_arrow".
            destruct (eq_typ_dec T1 S).
              subst. left; eauto.
              right.
                intros [S' J'].
                inversion J'; subst.
                assert (T0 = S); eauto using typing_c_unique.
                assert (typ_arrow T1 T2 = typ_arrow T0 S'); eauto using typing_c_unique.
                inversion H1; subst; eauto using typing_c_unique.
      SSCase "argument not typeable".
        right. intros [S' J']. inversion J'; subst; eauto.
    SCase "function not typeable".
      right. intros [S' J']. inversion J'; subst; eauto.
Qed.

Lemma typing_weakening_strengthened :  forall E F G e T,
  typing (G ++ E) e T ->
  uniq (G ++ F ++ E) ->
  typing (G ++ F ++ E) e T.
Proof.
  intros E F G e T H.
  remember (G ++ E) as E'.
  generalize dependent G.
  induction H; intros G Eq Ok; subst.
  Case "typing_var".
    apply typing_var.
      apply Ok.
      apply binds_weaken. apply H0.
  Case "typing_abs".
        apply typing_abs with (x:=x). auto.
Admitted.
