

Require Import Coq.FSets.FSets.

Require Import Coq.Lists.List.

Require Import Coq.Logic.Decidable.



Require Import Metalib.CoqFSetDecide.
(* Metalib.CoqFSetDecide:
Require Import Decidable DecidableTypeEx FSetFacts Setoid.

Module WDecide_fun (E : DecidableType)(Import M : WSfun E).
 Module F :=  FSetFacts.WFacts_fun E M.

  Module FSetLogicalFacts.
    Export Decidable.
    Export Setoid.

    Tactic Notation "fold" "any" "not" :=
      repeat (
        match goal with
        | H: context [?P -> False] |- _ =>
          fold (~ P) in H
        | |- context [?P -> False] =>
          fold (~ P)
        end).

    Ltac or_not_l_iff P Q tac :=
      (rewrite (or_not_l_iff_1 P Q) by tac) ||
      (rewrite (or_not_l_iff_2 P Q) by tac).

    Ltac or_not_r_iff P Q tac :=
      (rewrite (or_not_r_iff_1 P Q) by tac) ||
      (rewrite (or_not_r_iff_2 P Q) by tac).

    Ltac or_not_l_iff_in P Q H tac :=
      (rewrite (or_not_l_iff_1 P Q) in H by tac) ||
      (rewrite (or_not_l_iff_2 P Q) in H by tac).

    Ltac or_not_r_iff_in P Q H tac :=
      (rewrite (or_not_r_iff_1 P Q) in H by tac) ||
      (rewrite (or_not_r_iff_2 P Q) in H by tac).

    Tactic Notation "push" "not" "using" ident(db) :=
      let dec := solve_decidable using db in
      unfold not, iff;
      repeat (
        match goal with
        | |- context [True -> False] => rewrite not_true_iff
        | |- context [False -> False] => rewrite not_false_iff
        | |- context [(?P -> False) -> False] => rewrite (not_not_iff P) by dec
        | |- context [(?P -> False) -> (?Q -> False)] =>
            rewrite (contrapositive P Q) by dec
        | |- context [(?P -> False) \/ ?Q] => or_not_l_iff P Q dec
        | |- context [?P \/ (?Q -> False)] => or_not_r_iff P Q dec
        | |- context [(?P -> False) -> ?Q] => rewrite (imp_not_l P Q) by dec
        | |- context [?P \/ ?Q -> False] => rewrite (not_or_iff P Q)
        | |- context [?P /\ ?Q -> False] => rewrite (not_and_iff P Q)
        | |- context [(?P -> ?Q) -> False] => rewrite (not_imp_iff P Q) by dec
        end);
      fold any not.

    Tactic Notation "push" "not" :=
      push not using core.

    Tactic Notation
      "push" "not" "in" "*" "|-" "using" ident(db) :=
      let dec := solve_decidable using db in
      unfold not, iff in * |-;
      repeat (
        match goal with
        | H: context [True -> False] |- _ => rewrite not_true_iff in H
        | H: context [False -> False] |- _ => rewrite not_false_iff in H
        | H: context [(?P -> False) -> False] |- _ =>
          rewrite (not_not_iff P) in H by dec
        | H: context [(?P -> False) -> (?Q -> False)] |- _ =>
          rewrite (contrapositive P Q) in H by dec
        | H: context [(?P -> False) \/ ?Q] |- _ => or_not_l_iff_in P Q H dec
        | H: context [?P \/ (?Q -> False)] |- _ => or_not_r_iff_in P Q H dec
        | H: context [(?P -> False) -> ?Q] |- _ =>
          rewrite (imp_not_l P Q) in H by dec
        | H: context [?P \/ ?Q -> False] |- _ => rewrite (not_or_iff P Q) in H
        | H: context [?P /\ ?Q -> False] |- _ => rewrite (not_and_iff P Q) in H
        | H: context [(?P -> ?Q) -> False] |- _ =>
          rewrite (not_imp_iff P Q) in H by dec
        end);
      fold any not.

    Tactic Notation "push" "not" "in" "*" "|-"  :=
      push not in * |- using core.

    Tactic Notation "push" "not" "in" "*" "using" ident(db) :=
      push not using db; push not in * |- using db.
    Tactic Notation "push" "not" "in" "*" :=
      push not in * using core.

    Lemma test_push : forall P Q R : Prop,
      decidable P ->
      decidable Q ->
      (~ True) ->
      (~ False) ->
      (~ ~ P) ->
      (~ (P /\ Q) -> ~ R) ->
      ((P /\ Q) \/ ~ R) ->
      (~ (P /\ Q) \/ R) ->
      (R \/ ~ (P /\ Q)) ->
      (~ R \/ (P /\ Q)) ->
      (~ P -> R) ->
      (~ ((R -> P) \/ (Q -> R))) ->
      (~ (P /\ R)) ->
      (~ (P -> R)) ->
      True.

    Tactic Notation "pull" "not" "using" ident(db) :=
      let dec := solve_decidable using db in
      unfold not, iff;
      repeat (
        match goal with
        | |- context [True -> False] => rewrite not_true_iff
        | |- context [False -> False] => rewrite not_false_iff
        | |- context [(?P -> False) -> False] => rewrite (not_not_iff P) by dec
        | |- context [(?P -> False) -> (?Q -> False)] =>
          rewrite (contrapositive P Q) by dec
        | |- context [(?P -> False) \/ ?Q] => or_not_l_iff P Q dec
        | |- context [?P \/ (?Q -> False)] => or_not_r_iff P Q dec
        | |- context [(?P -> False) -> ?Q] => rewrite (imp_not_l P Q) by dec
        | |- context [(?P -> False) /\ (?Q -> False)] =>
          rewrite <- (not_or_iff P Q)
        | |- context [?P -> ?Q -> False] => rewrite <- (not_and_iff P Q)
        | |- context [?P /\ (?Q -> False)] => rewrite <- (not_imp_iff P Q) by dec
        | |- context [(?Q -> False) /\ ?P] =>
          rewrite <- (not_imp_rev_iff P Q) by dec
        end);
      fold any not.

    Tactic Notation "pull" "not" :=
      pull not using core.

    Tactic Notation
      "pull" "not" "in" "*" "|-" "using" ident(db) :=
      let dec := solve_decidable using db in
      unfold not, iff in * |-;
      repeat (
        match goal with
        | H: context [True -> False] |- _ => rewrite not_true_iff in H
        | H: context [False -> False] |- _ => rewrite not_false_iff in H
        | H: context [(?P -> False) -> False] |- _ =>
          rewrite (not_not_iff P) in H by dec
        | H: context [(?P -> False) -> (?Q -> False)] |- _ =>
          rewrite (contrapositive P Q) in H by dec
        | H: context [(?P -> False) \/ ?Q] |- _ => or_not_l_iff_in P Q H dec
        | H: context [?P \/ (?Q -> False)] |- _ => or_not_r_iff_in P Q H dec
        | H: context [(?P -> False) -> ?Q] |- _ =>
          rewrite (imp_not_l P Q) in H by dec
        | H: context [(?P -> False) /\ (?Q -> False)] |- _ =>
          rewrite <- (not_or_iff P Q) in H
        | H: context [?P -> ?Q -> False] |- _ =>
          rewrite <- (not_and_iff P Q) in H
        | H: context [?P /\ (?Q -> False)] |- _ =>
          rewrite <- (not_imp_iff P Q) in H by dec
        | H: context [(?Q -> False) /\ ?P] |- _ =>
          rewrite <- (not_imp_rev_iff P Q) in H by dec
        end);
      fold any not.

    Tactic Notation "pull" "not" "in" "*" "|-"  :=
      pull not in * |- using core.

    Tactic Notation "pull" "not" "in" "*" "using" ident(db) :=
      pull not using db; pull not in * |- using db.
    Tactic Notation "pull" "not" "in" "*" :=
      pull not in * using core.

    Lemma test_pull : forall P Q R : Prop,
      decidable P ->
      decidable Q ->
      (~ True) ->
      (~ False) ->
      (~ ~ P) ->
      (~ (P /\ Q) -> ~ R) ->
      ((P /\ Q) \/ ~ R) ->
      (~ (P /\ Q) \/ R) ->
      (R \/ ~ (P /\ Q)) ->
      (~ R \/ (P /\ Q)) ->
      (~ P -> R) ->
      (~ (R -> P) /\ ~ (Q -> R)) ->
      (~ P \/ ~ R) ->
      (P /\ ~ R) ->
      (~ R /\ P) ->
      True.

  End FSetLogicalFacts.
  Import FSetLogicalFacts.

  Module FSetDecideAuxiliary.

    Tactic Notation
      "if" tactic(t)
      "then" tactic(t1)
      "else" tactic(t2) :=
      first [ t; first [ t1 | fail 2 ] | t2 ].

    Tactic Notation "prop" constr(P) "holds" "by" tactic(t) :=
      let H := fresh in
      assert P as H by t;
      clear H.

    Tactic Notation "assert" "new" constr(e) "by" tactic(t) :=
      match goal with
      | H: e |- _ => fail 1
      | _ => assert e by t
      end.

    Tactic Notation "subst" "++" :=
      repeat (
        match goal with
        | x : _ |- _ => subst x
        end);
      cbv zeta beta in *.

    Tactic Notation "decompose" "records" :=
      repeat (
        match goal with
        | H: _ |- _ => progress (decompose record H); clear H
        end).

    Inductive FSet_elt_Prop : Prop -> Prop :=
    | eq_Prop : forall (S : Type) (x y : S),
        FSet_elt_Prop (x = y)
    | eq_elt_prop : forall x y,
        FSet_elt_Prop (E.eq x y)
    | In_elt_prop : forall x s,
        FSet_elt_Prop (In x s)
    | True_elt_prop :
        FSet_elt_Prop True
    | False_elt_prop :
        FSet_elt_Prop False
    | conj_elt_prop : forall P Q,
        FSet_elt_Prop P ->
        FSet_elt_Prop Q ->
        FSet_elt_Prop (P /\ Q)
    | disj_elt_prop : forall P Q,
        FSet_elt_Prop P ->
        FSet_elt_Prop Q ->
        FSet_elt_Prop (P \/ Q)
    | impl_elt_prop : forall P Q,
        FSet_elt_Prop P ->
        FSet_elt_Prop Q ->
        FSet_elt_Prop (P -> Q)
    | not_elt_prop : forall P,
        FSet_elt_Prop P ->
        FSet_elt_Prop (~ P).

    Inductive FSet_Prop : Prop -> Prop :=
    | elt_FSet_Prop : forall P,
        FSet_elt_Prop P ->
        FSet_Prop P
    | Empty_FSet_Prop : forall s,
        FSet_Prop (Empty s)
    | Subset_FSet_Prop : forall s1 s2,
        FSet_Prop (Subset s1 s2)
    | Equal_FSet_Prop : forall s1 s2,
        FSet_Prop (Equal s1 s2).

    Hint Constructors FSet_elt_Prop FSet_Prop : FSet_Prop.
    Ltac discard_nonFSet :=
      repeat (
        match goal with
        | H : ?P |- _ =>
          if prop (FSet_Prop P) holds by
            (auto 100 with FSet_Prop)
          then fail
          else clear H
        end).

    Hint Rewrite
      F.empty_iff F.singleton_iff F.add_iff F.remove_iff
      F.union_iff F.inter_iff F.diff_iff
    : set_simpl.

    Lemma dec_In : forall x s,
      decidable (In x s).

    Lemma dec_eq : forall (x y : E.t),

    Hint Resolve dec_In dec_eq : FSet_decidability.

    Ltac change_to_E_t :=
      repeat (
        match goal with
        | H : ?T |- _ =>
          progress (change T with E.t in H);
          repeat (
            match goal with
            | J : _ |- _ => progress (change T with E.t in J)
            | |- _ => progress (change T with E.t)
            end )
        | H : forall x : ?T, _ |- _ =>
          progress (change T with E.t in H);
          repeat (
            match goal with
            | J : _ |- _ => progress (change T with E.t in J)
            | |- _ => progress (change T with E.t)
            end )
       end).

    Ltac Logic_eq_to_E_eq :=
      repeat (
        match goal with
        | H: _ |- _ =>
          progress (change (@Logic.eq E.t) with E.eq in H)
        | |- _ =>
          progress (change (@Logic.eq E.t) with E.eq)
        end).

    Ltac E_eq_to_Logic_eq :=
      repeat (
        match goal with
        | H: _ |- _ =>
          progress (change E.eq with (@Logic.eq E.t) in H)
        | |- _ =>
          progress (change E.eq with (@Logic.eq E.t))
        end).

    Ltac substFSet :=
      repeat (
        match goal with
        | H: E.eq ?x ?y |- _ => rewrite H in *; clear H
        end).

    Ltac assert_decidability :=
            repeat (
        match goal with
        | H: context [~ E.eq ?x ?y] |- _ =>
          assert new (E.eq x y \/ ~ E.eq x y) by (apply dec_eq)
        | H: context [~ In ?x ?s] |- _ =>
          assert new (In x s \/ ~ In x s) by (apply dec_In)
        | |- context [~ E.eq ?x ?y] =>
          assert new (E.eq x y \/ ~ E.eq x y) by (apply dec_eq)
        | |- context [~ In ?x ?s] =>
          assert new (In x s \/ ~ In x s) by (apply dec_In)
        end);
            repeat (
        match goal with
        | _: ~ ?P, H : ?P \/ ~ ?P |- _ => clear H
        end).

    Ltac inst_FSet_hypotheses :=
      repeat (
        match goal with
        | H : forall a : E.t, _,
          _ : context [ In ?x _ ] |- _ =>
          let P := type of (H x) in
          assert new P by (exact (H x))
        | H : forall a : E.t, _
          |- context [ In ?x _ ] =>
          let P := type of (H x) in
          assert new P by (exact (H x))
        | H : forall a : E.t, _,
          _ : context [ E.eq ?x _ ] |- _ =>
          let P := type of (H x) in
          assert new P by (exact (H x))
        | H : forall a : E.t, _
          |- context [ E.eq ?x _ ] =>
          let P := type of (H x) in
          assert new P by (exact (H x))
        | H : forall a : E.t, _,
          _ : context [ E.eq _ ?x ] |- _ =>
          let P := type of (H x) in
          assert new P by (exact (H x))
        | H : forall a : E.t, _
          |- context [ E.eq _ ?x ] =>
          let P := type of (H x) in
          assert new P by (exact (H x))
        end);
      repeat (
        match goal with
        | H : forall a : E.t, _ |- _ =>
          clear H
        end).

    Hint Resolve E.eq_refl : FSet_Auto.
        Ltac fsetdec_rec :=
      auto with FSet_Auto;
      subst++;
      try (match goal with
      | H: E.eq ?x ?x -> False |- _ => destruct H
      end);
      (reflexivity ||
      contradiction ||
      (progress substFSet; intuition fsetdec_rec)).

    Ltac fsetdec_body :=
      inst_FSet_hypotheses;
      autorewrite with set_simpl in *;
      push not in * using FSet_decidability;
      substFSet;
      assert_decidability;
      auto with FSet_Auto;
      (intuition fsetdec_rec) ||
      fail 1
        "because the goal is beyond the scope of this tactic".

  End FSetDecideAuxiliary.
  Import FSetDecideAuxiliary.

  Ltac fsetdec :=
    
    unfold iff in *;
        fold any not; intros;
        decompose records;
    discard_nonFSet;
        unfold Empty, Subset, Equal in *; intros;

    autorewrite with set_simpl in *;

    change_to_E_t; E_eq_to_Logic_eq; subst++; Logic_eq_to_E_eq;
        pull not using FSet_decidability;
    unfold not in *;
    match goal with
    | H: (In ?x ?r) -> False |- (In ?x ?s) -> False =>
      contradict H; fsetdec_body
    | H: (In ?x ?r) -> False |- (E.eq ?x ?y) -> False =>
      contradict H; fsetdec_body
    | H: (In ?x ?r) -> False |- (E.eq ?y ?x) -> False =>
      contradict H; fsetdec_body
    | H: ?P -> False |- ?Q -> False =>
      if prop (FSet_elt_Prop P) holds by
        (auto 100 with FSet_Prop)
      then (contradict H; fsetdec_body)
      else fsetdec_body
    | |- _ =>
      fsetdec_body
    end.

  Module FSetDecideTestCases.

    Lemma test_eq_trans_1 : forall x y z s,
      E.eq x y ->

    Lemma test_eq_trans_2 : forall x y z r s,
      In x (singleton y) ->
      ~ In z r ->
      ~ ~ In z (add y r) ->
      In x s ->
      In z s.

    Lemma test_eq_neq_trans_1 : forall w x y z s,
      E.eq x w ->

    Lemma test_eq_neq_trans_2 : forall w x y z r1 r2 s,
      In x (singleton w) ->
      ~ In x r1 ->
      In x (add y r1) ->
      In y r2 ->
      In y (remove z r2) ->
      In w s ->
      In w (remove z s).

    Lemma test_In_singleton : forall x,
      In x (singleton x).

    Lemma test_add_In : forall x y s,
      In x (add y s) ->
      ~ E.eq x y ->

    Lemma test_Subset_add_remove : forall x s,
      s [<=] (add x (remove x s)).

    Lemma test_eq_disjunction : forall w x y z,
      In w (add x (add y (singleton z))) ->
      E.eq w x \/ E.eq w y \/ E.eq w z.

    Lemma test_not_In_disj : forall x y s1 s2 s3 s4,
      ~ In x (union s1 (union s2 (union s3 (add y s4)))) ->
      ~ (In x s1 \/ In x s4 \/ E.eq y x).

    Lemma test_not_In_conj : forall x y s1 s2 s3 s4,
      ~ In x (union s1 (union s2 (union s3 (add y s4)))) ->
      ~ In x s1 /\ ~ In x s4 /\ ~ E.eq y x.

    Lemma test_iff_conj : forall a x s s',
    (In a s' <-> E.eq x a \/ In a s) ->

    Lemma test_set_ops_1 : forall x q r s,
      (singleton x) [<=] s ->
      Empty (union q r) ->
      Empty (inter (diff s q) (diff s r)) ->
      ~ In x s.

    Lemma eq_chain_test : forall x1 x2 x3 x4 s1 s2 s3 s4,
      Empty s1 ->
      In x2 (add x1 s1) ->
      In x3 s2 ->
      ~ In x3 (remove x2 s2) ->
      ~ In x4 s3 ->
      In x4 (add x3 s3) ->
      In x1 s4 ->
      Subset (add x4 s4) s4.

    Lemma test_too_complex : forall x y z r s,
      E.eq x y ->

    Lemma function_test_1 :
      forall (f : t -> t),
      forall (g : elt -> elt),
      forall (s1 s2 : t),
      forall (x1 x2 : elt),
      Equal s1 (f s2) ->
      E.eq x1 (g (g x2)) ->

    Lemma function_test_2 :
      forall (f : t -> t),
      forall (g : elt -> elt),
      forall (s1 s2 : t),
      forall (x1 x2 : elt),
      Equal s1 (f s2) ->
      E.eq x1 (g x2) ->

    Lemma test_baydemir :
      forall (f : t -> t),
      forall (s : t),
      forall (x y : elt),
      In x (add y (f s)) ->
      ~ E.eq x y ->

    Lemma test_baydemir_2 :
      forall (x : elt) (s : t),
      Subset (inter (singleton x) s) empty ->
      ~ In x s.

    Lemma test_baydemir_3 :
      forall (x y : elt) (s : t),
      ~ In x (add y s) ->
      x = y ->
      False.

    Lemma test_baydemir_4 :
      forall (x : elt) (s : t),
      Equal (inter (add x empty) s) empty ->
      ~ In x s.

    Lemma test_sweirich :
      forall (x : elt) (s : t),
        In x s -> Subset (singleton x) s.

  End FSetDecideTestCases.

End WDecide_fun.

Require Import CoqFSetInterface.

Module WDecide (M:WS) := !WDecide_fun M.E M.
Module Decide := WDecide. *)

Require Import Metalib.CoqListFacts.
(* Metalib.CoqListFacts:
Require Import Coq.Lists.List.
Require Import Coq.Lists.SetoidList.

Require Import Metalib.CoqUniquenessTac.

Open Scope list_scope.

Lemma cons_eq_app : forall (A : Type) (z : A) (xs ys zs : list A),
  z :: zs = xs ++ ys ->
  (exists qs, xs = z :: qs /\ zs = qs ++ ys) \/
  (xs = nil /\ ys = z :: zs).

Lemma app_eq_cons : forall (A : Type) (z : A) (xs ys zs : list A),
  xs ++ ys = z :: zs ->
  (exists qs, xs = z :: qs /\ zs = qs ++ ys) \/
  (xs = nil /\ ys = z :: zs).

Lemma nil_eq_app : forall (A : Type) (xs ys : list A),
  nil = xs ++ ys ->
  xs = nil /\ ys = nil.

Lemma app_cons_not_nil : forall (A : Type) (y : A) (xs ys : list A),
  xs ++ y :: ys <> nil.

Lemma In_map : forall (A B : Type) (xs : list A) (x : A) (f : A -> B),
  In x xs ->
  In (f x) (map f xs).

Lemma not_In_cons : forall (A : Type) (ys : list A) (x y : A),
  x <> y ->
  ~ In x ys ->
  ~ In x (y :: ys).

Lemma not_In_app : forall (A : Type) (xs ys : list A) (x : A),
  ~ In x xs ->
  ~ In x ys ->
  ~ In x (xs ++ ys).

Lemma elim_not_In_cons : forall (A : Type) (y : A) (ys : list A) (x : A),
  ~ In x (y :: ys) ->
  x <> y /\ ~ In x ys.

Lemma elim_not_In_app : forall (A : Type) (xs ys : list A) (x : A),
  ~ In x (xs ++ ys) ->
  ~ In x xs /\ ~ In x ys.

Lemma incl_nil : forall (A : Type) (xs : list A),
  incl nil xs.

Lemma In_incl : forall (A : Type) (x : A) (ys zs : list A),
  In x ys ->
  incl ys zs ->
  In x zs.

Lemma elim_incl_cons : forall (A : Type) (x : A) (xs zs : list A),
  incl (x :: xs) zs ->
  In x zs /\ incl xs zs.

Lemma elim_incl_app : forall (A : Type) (xs ys zs : list A),
  incl (xs ++ ys) zs ->
  incl xs zs /\ incl ys zs.

Lemma InA_In : forall (A : Type) (x : A) (xs : list A),
  InA (@eq _) x xs -> In x xs.

Lemma InA_iff_In : forall (A : Type) (x : A) (xs : list A),
  InA (@eq _) x xs <-> In x xs.

Section DecidableSorting.

  Variable A : Type.
  Variable leA : relation A.
  Hypothesis leA_dec : forall x y, {leA x y} + {~ leA x y}.

  Theorem lelistA_dec : forall a xs,
    {lelistA leA a xs} + {~ lelistA leA a xs}.

  Theorem sort_dec : forall xs,
    {sort leA xs} + {~ sort leA xs}.

End DecidableSorting.

Section SortedListEquality.

  Variable A : Type.
  Variable ltA : relation A.
  Hypothesis ltA_trans : forall x y z, ltA x y -> ltA y z -> ltA x z.
  Hypothesis ltA_not_eqA : forall x y, ltA x y -> x <> y.
  Hypothesis ltA_eqA : forall x y z, ltA x y -> y = z -> ltA x z.
  Hypothesis eqA_ltA : forall x y z, x = y -> ltA y z -> ltA x z.

  Hint Resolve ltA_trans.
  Hint Immediate ltA_eqA eqA_ltA.

  Notation Inf := (lelistA ltA).
  Notation Sort := (sort ltA).

  Lemma eqlist_eq : forall (xs ys : list A),
    eqlistA (@eq _) xs ys ->
    xs = ys.

  Lemma Sort_InA_eq : forall xs ys,
    Sort xs ->
    Sort ys ->
    (forall a, InA (@eq _) a xs <-> InA (@eq _) a ys) ->
    xs = ys.

  Lemma Sort_In_eq : forall xs ys,
    Sort xs ->
    Sort ys ->
    (forall a, In a xs <-> In a ys) ->
    xs = ys.

End SortedListEquality.

Section Uniqueness_Of_SetoidList_Proofs.

  Variable A : Type.
  Variable R : A -> A -> Prop.

  Hypothesis R_unique : forall (x y : A) (p q : R x y), p = q.
  Hypothesis list_eq_dec : forall (xs ys : list A), {xs = ys} + {xs <> ys}.

  Scheme lelistA_ind' := Induction for lelistA Sort Prop.
  Scheme sort_ind'    := Induction for sort Sort Prop.
  Scheme eqlistA_ind' := Induction for eqlistA Sort Prop.

  Theorem lelistA_unique :
    forall (x : A) (xs : list A) (p q : lelistA R x xs), p = q.

  Theorem sort_unique :
    forall (xs : list A) (p q : sort R xs), p = q.

  Theorem eqlistA_unique :
    forall (xs ys : list A) (p q : eqlistA R xs ys), p = q.

End Uniqueness_Of_SetoidList_Proofs. *)



Require Import Metalib.AssocList.
(* Metalib.AssocList:
Require Import String.
Open Scope string_scope.
Require Import Coq.FSets.FSets.
Require Import Coq.Lists.List.
Require Import Coq.Logic.Decidable.

Require Import Metalib.CoqFSetDecide.
Require Import Metalib.CoqListFacts.
Open Scope coqeqdec_scope.

Import KeySet.

Module Import D := CoqFSetDecide.WDecide_fun X KeySet.
Module KeySetProperties := FSetProperties.WProperties_fun X KeySet.
Module KeySetFacts := FSetFacts.WFacts_fun X KeySet.

Set Implicit Arguments.

Definition one (C : Type) (item : C) : list C := cons item nil.

Notation "x ~ a" := (one (x, a)) (at level 50) : list_scope.

Arguments app _%type_scope _%list_scope _%list_scope.

Open Scope list_scope.

Fixpoint dom
  (C : Type) (E : list (X.t*C))
  : KeySet.t :=
  match E with
    | nil => empty
    | (x, _) :: E' => add x (dom E')
  end.

Fixpoint get
  (C : Type) (x : X.t) (E : list (X.t*C))
  : option C :=
  match E with
    | nil => None
    | (y, c) :: F => if (x == y) then Some c else get x F
  end.

Definition binds
  (A : Type) (x : X.t) (a : A) (E : list (X.t*A))
  : Prop :=
  List.In (x, a) E.

Definition maps
  (A : Type) (x : X.t) (a : A) (E : list (X.t*A))
  : Prop :=
  get x E = Some a.

Definition disjoint
  (A B : Type) (E : list (X.t*A)) (F : list (X.t*B))
  : Prop :=
  inter (dom E) (dom F) [<=] empty.

Definition map
  (A B : Type) (f : A -> B) (E : list (X.t*A))
  : list (X.t*B) :=
  List.map (fun b => match b with (x, a) => (x, f a) end) E.

Inductive uniq (A : Type) : list (X.t*A) -> Prop :=
  | uniq_nil :
      uniq nil
  | uniq_push : forall x a E,
      uniq E ->
      ~ In x (dom E) ->
      uniq (x ~ a ++ E).

Unset Implicit Arguments.

Section ListProperties.
  Variable  X : Type.
  Variables x y : X.
  Variables l l1 l2 l3 : list X.

  Lemma cons_app_one :
    cons x l = one x ++ l.

  Lemma cons_app_assoc :
    (cons x l1) ++ l2 = cons x (l1 ++ l2).

  Lemma app_assoc :
    (l1 ++ l2) ++ l3 = l1 ++ (l2 ++ l3).

  Lemma app_nil_1 :
    nil ++ l = l.

  Lemma app_nil_2 :
    l ++ nil = l.

  Lemma in_nil_iff :
    List.In x nil <-> False.

  Lemma in_one_iff :
    List.In x (one y) <-> x = y.

  Lemma in_app_iff :
    List.In x (l1 ++ l2) <-> List.In x l1 \/ List.In x l2.

End ListProperties.

Section Properties.
  Variables A B key : Type.
  Variable  f       : A -> B.
  Variable  x       : X.t.
  Variable  b       : A.
  Variables E F G   : list (X.t*A).

  Lemma map_nil :
    map f (@nil (X.t*A)) = nil.

  Lemma map_one :
    map f (x ~ b) = (x ~ f b).

  Lemma map_cons :
    map f ((x, b) :: E) = x ~ f b ++ map f E.

  Lemma map_app :
    map f (E ++ F) = map f E ++ map f F.

  Lemma dom_nil :
    dom (@nil (X.t*A)) = empty.

  Lemma dom_one :
    dom (x ~ b) [=] singleton x.

  Lemma dom_cons :
    dom ((x, b) :: E) [=] union (singleton x) (dom E).

  Lemma dom_app :
    dom (E ++ F) [=] union (dom E) (dom F).

  Lemma dom_map :
    dom (map f E) [=] dom E.

End Properties.

Hint Rewrite cons_app_one cons_app_assoc      : rewr_list.
Hint Rewrite app_assoc app_nil_1 app_nil_2    : rewr_list.
Hint Rewrite in_nil_iff in_one_iff in_app_iff : rewr_list_in.

Hint Rewrite map_nil map_one map_cons map_app         : rewr_map.
Hint Rewrite dom_nil dom_one dom_cons dom_app dom_map : rewr_dom.

Ltac simpl_alist :=
  autorewrite with rewr_list rewr_map rewr_dom.
Tactic Notation "simpl_alist" "in" hyp(H) :=
  autorewrite with rewr_list rewr_map rewr_dom in H.
Tactic Notation "simpl_alist" "in" "*" :=
  autorewrite with rewr_list rewr_map rewr_dom in *.

Tactic Notation "rewrite_alist" constr(E) :=
  match goal with
    | |- context[?x] =>
      change x with E
    | |- context[?x] =>
      replace x with E;
        [ | try reflexivity; simpl_alist; reflexivity ]
  end.

Tactic Notation "rewrite_alist" constr(E) "in" hyp(H) :=
  match type of H with
    | context[?x] =>
      change x with E in H
    | context[?x] =>
      replace x with E in H;
        [ | try reflexivity; simpl_alist; reflexivity ]
  end.

Lemma alist_ind : forall (A : Type) (P : list (X.t * A) -> Type),

Tactic Notation "alist" "induction" ident(E) :=
  try (intros until E);
  let T := type of E in
  let T := eval compute in T in
  match T with
    | list (?key * ?A) => induction E using (alist_ind A)
  end.

Tactic Notation "alist" "induction" ident(E) "as" simple_intropattern(P) :=
  try (intros until E);
  let T := type of E in
  let T := eval compute in T in
  match T with
    | list (?key * ?A) => induction E as P using (alist_ind A)
  end.

Section Disjoint.
  Implicit Types A B C : Type.

  Lemma disjoint_sym_1 :
    forall A B (E : list (X.t*A)) (F : list (X.t*B)),

  Lemma disjoint_sym :
    forall A B (E : list (X.t*A)) (F : list (X.t*B)),

  Lemma disjoint_nil_1 :
    forall A B (E : list (X.t*B)),

  Lemma disjoint_one_1 :
    forall A B (x : X.t) (a : A) (F : list (X.t*B)),

  Lemma disjoint_one_2 :
    forall A B (x : X.t) (a : A) (F : list (X.t*B)),

  Lemma disjoint_one_l :
    forall A B (x : X.t) (a : A) (E : list (X.t*B)),

  Lemma disjoint_one_r :
    forall A B (x : X.t) (a : A) (E : list (X.t*B)),

  Lemma disjoint_cons_1 :
    forall A B x a (E : list (X.t*A)) (F : list (X.t*B)),

  Lemma disjoint_cons_2 :
    forall A B x a (E : list (X.t*A)) (F : list (X.t*B)),

  Lemma disjoint_cons_3 :
    forall A B x a (E : list (X.t*A)) (F : list (X.t*B)),

  Lemma disjoint_cons_l :
    forall A B x a (E : list (X.t*A)) (F : list (X.t*B)),

  Lemma disjoint_cons_r :
    forall A B x a (E : list (X.t*A)) (F : list (X.t*B)),

  Lemma disjoint_app_1 :
    forall A B (E F : list (X.t*A)) (G : list (X.t*B)),

  Lemma disjoint_app_2 :
    forall A B (E F : list (X.t*A)) (G : list (X.t*B)),

  Lemma disjoint_app_3 :
    forall A B (E F : list (X.t*A)) (G : list (X.t*B)),

  Lemma disjoint_app_l :
    forall A B (E F : list (X.t*A)) (G : list (X.t*B)),

  Lemma disjoint_app_r :
    forall A B (E F : list (X.t*A)) (G : list (X.t*B)),

  Lemma disjoint_map_1 :
    forall A B C (E : list (X.t*A)) (F : list (X.t*B)) (f:A->C),

  Lemma disjoint_map_2 :
    forall A B C (E : list (X.t*A)) (F : list (X.t*B)) (f:A->C),

  Lemma disjoint_map_l :
    forall A B C (E : list (X.t*A)) (F : list (X.t*B)) (f:A->C),

  Lemma disjoint_map_r :
    forall A B C (E : list (X.t*A)) (F : list (X.t*B)) (f:A->C),

End Disjoint.

Section UniqProperties.
  Variables A B   : Type.
  Variables f     : A -> B.
  Variables x     : X.t.
  Variables a b   : A.
  Variables E F G : list (X.t*A).

  Lemma uniq_one_1 :
    uniq (x ~ b).

  Lemma uniq_cons_1 :
    uniq ((x, a) :: E) ->
    uniq E.

  Lemma uniq_cons_2 :
    uniq ((x, a) :: E) ->
    ~ In x (dom E).

  Lemma uniq_cons_3 :
    uniq E ->
    ~ In x (dom E) ->
    uniq ((x, a) :: E).

  Lemma uniq_cons_iff :
    uniq ((x, a) :: E) <-> uniq E /\ ~ In x (dom E).

  Lemma uniq_app_1 :
    uniq (E ++ F) -> uniq E.

  Lemma uniq_app_2 :
    uniq (E ++ F) -> uniq F.

  Lemma uniq_app_3 :
    uniq (E ++ F) -> disjoint E F.

  Lemma uniq_app_4 :
    uniq E ->
    uniq F ->
    disjoint E F ->
    uniq (E ++ F).

  Lemma uniq_app_iff :
    uniq (E ++ F) <-> uniq E /\ uniq F /\ disjoint E F.

  Lemma uniq_map_1 :
    uniq (map f E) ->
    uniq E.

  Lemma uniq_map_2 :
    uniq E ->
    uniq (map f E).

  Lemma uniq_map_iff :
    uniq (map f E) <-> uniq E.

End UniqProperties.

Section BindsProperties.
  Variable  A B   : Type.
  Variables f     : A -> B.
  Variables x y   : X.t.
  Variables a b   : A.
  Variables b0    : B.
  Variables E F G : list (X.t*A).

  Lemma binds_nil_iff :
    binds x a nil <-> False.

  Lemma binds_one_1 :
    binds x a (y ~ b) ->
    x = y.

  Lemma binds_one_2 :
    binds x a (y ~ b) ->
    a = b.

  Lemma binds_one_3 :
    x = y ->
    a = b ->
    binds x a (y ~ b).

  Lemma binds_one_iff :
    binds x a (y ~ b) <-> x = y /\ a = b.

  Lemma binds_cons_1 :
    binds x a ((y, b) :: E) ->
    (x = y /\ a = b) \/ binds x a E.

  Lemma binds_cons_2 :
    x = y ->
    a = b ->
    binds x a ((y, b) :: E).

  Lemma binds_cons_3 :
    binds x a E ->
    binds x a ((y, b) :: E).

  Lemma binds_cons_iff :
    binds x a ((y, b) :: E) <-> (x = y /\ a = b) \/ binds x a E.

  Lemma binds_app_1 :
    binds x a (E ++ F) ->
    binds x a E \/ binds x a F.

  Lemma binds_app_2 :
    binds x a E ->
    binds x a (E ++ F).

  Lemma binds_app_3 :
    binds x a F ->
    binds x a (E ++ F).

  Lemma binds_app_iff :
    binds x a (E ++ F) <-> binds x a E \/ binds x a F.

  Lemma binds_map_1 :
    (forall a b, f a = f b -> a = b) ->
    binds x (f a) (map f E) ->
    binds x a E.

  Lemma binds_map_2 :
    binds x a E ->
    binds x (f a) (map f E).

  Lemma binds_map_3 :
    binds x b0 (map f E) ->
    exists a, f a = b0 /\ binds x a E.

  Lemma binds_dom_contradiction : forall (E : list (X.t*A)),

  Lemma binds_app_uniq_1 :
    uniq (E ++ F) ->
    binds x a (E ++ F) ->
    (binds x a E /\ ~ In x (dom F)) \/ (binds x a F /\ ~ In x (dom E)).

  Lemma binds_app_uniq_iff :
    uniq (E ++ F) ->
    (binds x a (E ++ F) <->
      (binds x a E /\ ~ In x (dom F)) \/
      (binds x a F /\ ~ In x (dom E))).

End BindsProperties.

Section BindsProperties2.
  Variable  A B   : Type.
  Variables f     : A -> B.
  Variables x y   : X.t.
  Variables a b   : A.
  Variables E F G : list (X.t*A).

  Lemma binds_cons_uniq_1 :
    uniq ((y, b) :: E) ->
    binds x a ((y, b) :: E) ->
    (x = y /\ a = b /\ ~ In x (dom E)) \/ (binds x a E /\ x <> y).

  Lemma binds_cons_uniq_iff :
    uniq ((y, b) :: E) ->
    (binds x a ((y, b) :: E) <->
      (x = y /\ a = b /\ ~ In x (dom E)) \/
      (binds x a E /\ x <> y)).

End BindsProperties2.

Hint Resolve
  @app_assoc @app_nil_2 @map_app @dom_one @dom_cons @dom_app @dom_map.

Hint Resolve
  @disjoint_sym_1 @disjoint_nil_1 @disjoint_one_2 @disjoint_cons_3
  @disjoint_app_3 @disjoint_map_2 @uniq_nil @uniq_push @uniq_one_1
  @uniq_cons_3 @uniq_app_4 @uniq_map_2.

Hint Resolve
  @binds_one_3 @binds_cons_2 @binds_cons_3 @binds_app_2 @binds_app_3
  @binds_map_2.

Section AssortedListProperties.
  Variable  X : Type.
  Variables x : X.
  Variables xs ys zs : list X.

  Lemma one_eq_app :
    one x ++ xs = ys ++ zs ->
    (exists qs, ys = x :: qs /\ xs = qs ++ zs) \/
    (ys = nil /\ zs = x :: xs).

  Lemma app_eq_one :
    ys ++ zs = one x ++ xs ->
    (exists qs, ys = x :: qs /\ xs = qs ++ zs) \/
    (ys = nil /\ zs = x :: xs).

  Lemma nil_neq_one_mid :
    nil <> xs ++ one x ++ ys.

  Lemma one_mid_neq_nil :
    xs ++ one x ++ ys <> nil.

End AssortedListProperties.

Ltac destruct_uniq :=
  match goal with
    | H : uniq nil |- _ =>
      clear H;
      destruct_uniq
    | H : uniq (?x ~ ?a) |- _ =>
      clear H;
      destruct_uniq
    | H : uniq ((?x, ?a) :: ?E) |- _ =>
      let J := fresh "UniqTac" in
      pose proof H as J;
      apply uniq_cons_1 in H;
      apply uniq_cons_2 in J;
      autorewrite with rewr_dom in J;
      destruct_uniq
    | H : uniq (?E ++ ?F) |- _ =>
      let J1 := fresh "UniqTac" in
      let J2 := fresh "UniqTac" in
      pose proof H as J1;
      pose proof H as J2;
      apply uniq_app_1 in H;
      apply uniq_app_2 in J1;
      apply uniq_app_3 in J2;
      destruct_uniq
    | H : uniq (map ?f ?E) |- _ =>
      apply uniq_map_1 in H;
      destruct_uniq
    | H : disjoint nil ?E |- _ =>
      clear H;
      destruct_uniq
    | H : disjoint (?x ~ ?a) ?F |- _ =>
      apply disjoint_one_1 in H;
      autorewrite with rewr_dom in H;
      destruct_uniq
    | H : disjoint ((?x, ?a) :: ?E) ?F |- _ =>
      let J := fresh "UniqTac" in
      pose proof H as J;
      apply disjoint_cons_1 in H;
      apply disjoint_cons_2 in J;
      autorewrite with rewr_dom in H;
      destruct_uniq
    | H : disjoint (?E ++ ?F) ?G |- _ =>
      let J := fresh "UniqTac" in
      pose proof H as J;
      apply disjoint_app_1 in H;
      apply disjoint_app_2 in J;
      destruct_uniq
    | H : disjoint (map ?f ?E) ?F |- _ =>
      apply disjoint_map_1 in H;
      destruct_uniq
    | H : disjoint ?E nil |- _ =>
      clear H;
      destruct_uniq
    | H : disjoint ?F (?x ~ ?a) |- _ =>
      apply disjoint_sym_1 in H;
      destruct_uniq
    | H : disjoint ?F ((?x, ?a) :: ?E) |- _ =>
      apply disjoint_sym_1 in H;
      destruct_uniq
    | H : disjoint ?G (?E ++ ?F) |- _ =>
      apply disjoint_sym_1 in H;
      destruct_uniq
    | H : disjoint ?F (map ?f ?E) |- _ =>
      apply disjoint_sym_1 in H;
      destruct_uniq
    | _ =>
      idtac
  end.

Ltac solve_uniq :=
  intros;
  destruct_uniq;
  repeat first [ apply uniq_push
               | apply uniq_cons_3
               | apply uniq_app_4
               | apply uniq_one_1
               | apply uniq_nil ];
  auto;
  try tauto;
  unfold disjoint in *;
  try fsetdec;
  fail "Not solvable by [solve_uniq]; try [destruct_uniq]".

Section UniqDerived.
  Variable  A     : Type.
  Variables x y   : X.t.
  Variables a b   : A.
  Variables E F G : list (X.t*A).

  Lemma uniq_insert_mid :
    uniq (G ++ E) ->
    ~ In x (dom G) ->
    ~ In x (dom E) ->
    uniq (G ++ (x ~ a) ++ E).

  Lemma uniq_remove_mid :
    uniq (E ++ F ++ G) ->
    uniq (E ++ G).

  Lemma uniq_reorder_1 :
    uniq (E ++ F) ->
    uniq (F ++ E).

  Lemma uniq_reorder_2 :
    uniq (E ++ F ++ G) ->
    uniq (F ++ E ++ G).

  Lemma uniq_map_app_l : forall (f : A -> A),
    uniq (F ++ E) ->
    uniq (map f F ++ E).

  Lemma fresh_mid_tail :
    uniq (F ++ (x ~ a) ++ E) ->
    ~ In x (dom E).

  Lemma fresh_mid_head :
    uniq (F ++ (x ~ a) ++ E) ->
    ~ In x (dom F).

End UniqDerived.

Ltac destruct_binds_hyp H :=
  match type of H with
    | binds ?x ?a nil =>
      inversion H
    | binds ?x ?a (?y ~ ?b) =>
      let J1 := fresh "BindsTacKey" in
      let J2 := fresh "BindsTacVal" in
      rename H into J1;
      pose proof J1 as J2;
      apply binds_one_1 in J1;
      apply binds_one_2 in J2;
      try (subst x);
      try (subst a);
      try (subst y);
      try (subst b)
    | binds ?x ?a ((?y, ?b) :: ?E) =>
      change (binds x a (y ~ b ++ E)) in H;
      destruct_binds_hyp H
    | binds ?x ?a (?E ++ ?F) =>
      let J := fresh "BindsTac" in
      apply binds_app_1 in H;
      destruct H as [J | J];
      destruct_binds_hyp J
    | _ =>
      idtac
  end.

Ltac destruct_binds_hyp_uniq H :=
  match type of H with
    | binds ?x ?a nil =>
      inversion H
    | binds ?x ?a (?y ~ ?b) =>
      let J1 := fresh "BindsTacKey" in
      let J2 := fresh "BindsTacVal" in
      rename H into J1;
      pose proof J1 as J2;
      apply binds_one_1 in J1;
      apply binds_one_2 in J2;
      try (subst x);
      try (subst a);
      try (subst y);
      try (subst b)
    | binds ?x ?a ((?y, ?b) :: ?E) =>
      change (binds x a (y ~ b ++ E)) in H;
      destruct_binds_hyp_uniq H
    | binds ?x ?a (?E ++ ?F) =>
      let J1 := fresh "BindsTacSideCond" in
      assert (J1 : uniq (E ++ F));
        [ destruct_uniq; auto
        | match type of J1 with
            | @uniq ?A _ =>
              let J2 := fresh "BindsTac" in
              destruct (@binds_app_uniq_1 A x a E F J1 H)
                as [[J2 ?] | [J2 ?]];
              clear H;
              destruct_binds_hyp_uniq J2
          end
        ]
    | _ =>
      idtac
  end.

Ltac analyze_binds_cleanup :=
  auto;
  try tauto;
  try discriminate;
  try match goal with
        | J : ~ In ?x ?E |- _ =>
          match E with
            | context [x] => elim J; clear; simpl_alist; auto with set
          end
      end.

Ltac analyze_binds H :=
  destruct_binds_hyp H;
  analyze_binds_cleanup.

Ltac analyze_binds_uniq H :=
  destruct_binds_hyp_uniq H;
  analyze_binds_cleanup.

Section BindsDerived.
  Variables A B   : Type.
  Variables f     : A -> B.
  Variables x y   : X.t.
  Variables a b   : A.
  Variables E F G : list (X.t*A).

  Lemma binds_dec :
    (forall a b : A, {a = b} + {a <> b}) ->
    {binds x a E} + {~ binds x a E}.

  Lemma binds_lookup :
    {a : A | binds x a E} + (forall a, ~ binds x a E).

  Lemma binds_lookup_dec :
    decidable (exists a, binds x a E).

  Lemma binds_weaken :
    binds x a (E ++ G) ->
    binds x a (E ++ F ++ G).

  Lemma binds_mid_eq :
    binds x a (F ++ (x ~ b) ++ E) ->
    uniq (F ++ (x ~ b) ++ E) ->
    a = b.

  Lemma binds_remove_mid :
    binds x a (F ++ (y ~ b) ++ G) ->
    x <> y ->
    binds x a (F ++ G).

  Lemma binds_In : forall x a (E : list (X.t*A)),

  Lemma binds_In_inv : forall x (E : list (X.t*A)),

  Lemma binds_unique :
    binds x a E ->
    binds x b E ->
    uniq E ->
    a = b.

  Lemma fresh_app_l :
    uniq (F ++ E) ->
    binds x a E ->
    ~ In x (dom F).

  Lemma fresh_app_r :
    uniq (F ++ E) ->
    binds x a F ->
    ~ In x (dom E).

End BindsDerived.

Hint Resolve @nil_neq_one_mid @one_mid_neq_nil.

Hint Resolve @uniq_insert_mid @uniq_map_app_l.

Hint Immediate @uniq_remove_mid.

Hint Resolve @binds_weaken.

Hint Immediate @binds_remove_mid @binds_In.

End Make. *)

Require Import Metalib.MetatheoryAtom.
(* Metalib.MetatheoryAtom:
Require Import Coq.Arith.Arith.
Require Import Coq.Arith.Max.
Require Import Coq.Classes.EquivDec.
Require Import Coq.Lists.List.
Require Import Coq.Structures.Equalities.

Require Import Coq.FSets.FSets.
Require Import Metalib.CoqListFacts.
Require Import Metalib.FSetExtra.
Require Import Metalib.FSetWeakNotin.
Require Import Metalib.LibTactics.

Require Import Omega.

Module Type ATOM <: UsualDecidableType.

  Parameter atom : Set.
  Definition t := atom.

  Parameter eq_dec : forall x y : atom, {x = y} + {x <> y}.

  Parameter atom_fresh_for_list :
    forall (xs : list t), {x : atom | ~ List.In x xs}.

  Parameter fresh : list atom -> atom.

  Parameter fresh_not_in : forall l, ~ In (fresh l) l.

  Parameter nat_of : atom -> nat.

  Hint Resolve eq_dec.

  Include HasUsualEq <+ UsualIsEq <+ UsualIsEqOrig.

End ATOM.

Module Atom : ATOM.

  Definition atom := nat.
  Definition t := atom.

  Definition eq_dec := eq_nat_dec.

  Lemma max_lt_r : forall x y z,
    x <= z -> x <= max y z.

  Lemma nat_list_max : forall (xs : list nat),
    { n : nat | forall x, List.In x xs -> x <= n }.

  Lemma atom_fresh_for_list :
    forall (xs : list nat), { n : nat | ~ List.In n xs }.

  Definition fresh (l : list atom) :=
    match atom_fresh_for_list l with
      (exist _ x _) => x
    end.

  Lemma fresh_not_in : forall l, ~ In (fresh l) l.

  Definition nat_of := fun (x : atom) => x.

Module Import AtomSetImpl : FSetExtra.WSfun Atom :=
  FSetExtra.Make Atom.

Notation atoms :=
  AtomSetImpl.t.

Module Export AtomSetDecide := Coq.FSets.FSetDecide.WDecide_fun Atom AtomSetImpl.

Module Export AtomSetNotin := FSetWeakNotin.Notin_fun Atom AtomSetImpl.

Module AtomSetFacts := FSetFacts.WFacts_fun Atom AtomSetImpl.
Module AtomSetProperties := FSetProperties.WProperties_fun Atom AtomSetImpl.

Export AtomSetFacts.

Lemma atom_fresh : forall L : atoms, { x : atom | ~ In x L }.
Proof.
  intros L. destruct (atom_fresh_for_list (elements L)) as [a H].
  exists a. intros J. contradiction H.
  rewrite <- CoqListFacts.InA_iff_In. auto using elements_1.

Ltac simplify_list_of_atom_sets L :=
  let L := eval simpl in L in
  let L := ltac_remove_dups L in
  let L := eval simpl in (List.fold_right union empty L) in
  match L with
    | context C [union ?E empty] => context C [ E ]
  end.

Ltac gather_atoms_with F :=
  let apply_arg x :=
    match type of F with
      | _ -> _ -> _ -> _ => constr:(@F _ _ x)
      | _ -> _ -> _ => constr:(@F _ x)
      | _ -> _ => constr:(@F x)
    end in
  let rec gather V :=
    match goal with
      | H : _ |- _ =>
        let FH := apply_arg H in
        match V with
          | context [FH] => fail 1
          | _ => gather (union FH V)
        end
      | _ => V
    end in
  let L := gather empty in eval simpl in L.

Ltac beautify_fset V :=
  let rec go Acc E :=
     match E with
     | union ?E1 ?E2 => let Acc2 := go Acc E2 in go Acc2 E1
     | empty => Acc
     | ?E1 => match Acc with
                | empty => E1
                | _ => constr:(union E1 Acc)
              end
     end
  in go empty V.

Ltac gather_atoms :=
  constr:(empty).

Tactic Notation "pick" "fresh" ident(Y) "for" constr(L) :=
  let Fr := fresh "Fr" in
  let L := beautify_fset L in
  (destruct (atom_fresh L) as [Y Fr]).

Tactic Notation "pick" "fresh" ident(Y) :=
  let L := gather_atoms in
  pick fresh Y for L.

Ltac pick_fresh y :=
  pick fresh y.

Ltac gather_atoms ::=
  let A := gather_atoms_with (fun x : atoms => x) in
  let B := gather_atoms_with (fun x : atom => singleton x) in
  constr:(union A B).

Lemma example_pick_fresh_use : forall (x y z : atom) (L1 L2 L3: atoms), True. *)

Import AtomSetImpl.

Require Import Metalib.LibTactics.
(* Metalib.LibTactics:
Require Import Coq.Lists.List.
Require Import Coq.Strings.String.

Open Scope string_scope.
Open Scope list_scope.

Tactic Notation "unsimpl" constr(E) :=
  let F := (eval simpl in E) in change F with E.

Tactic Notation "fold" "any" "not" :=
  repeat (
    match goal with
    | H: context [?P -> False] |- _ =>
      fold (~ P) in H
    | |- context [?P -> False] =>
      fold (~ P)
    end).

Ltac apply_first_hyp :=
  match reverse goal with
    | H : _ |- _ => apply H
  end.

Ltac eapply_first_hyp :=
  match reverse goal with
    | H : _ |- _ => eapply H
  end.

Ltac apply_first_lt_hyp :=
  match reverse goal with
  | H : forall m:nat, m < ?a -> ?b |- _ =>  apply H
  end.

Ltac eapply_first_lt_hyp :=
  match reverse goal with
  | H : forall m:nat, m < ?a -> ?b |- _ =>  eapply H
  end.

Tactic Notation "assert_eq" ident(x) constr(v) :=
  let H := fresh in
  assert (x = v) as H by reflexivity;
  clear H.

Tactic Notation "Case_aux" ident(x) constr(name) :=
  first [
    set (x := name); move x at top
  | assert_eq x name
  | fail 1 "because we are working on a different case." ].

Ltac Case name := Case_aux case name.
Ltac SCase name := Case_aux subcase name.
Ltac SSCase name := Case_aux subsubcase name.
Ltac SSSCase name := Case_aux subsubsubcase name.
Ltac SSSSCase name := Case_aux subsubsubsubcase name.

Ltac ltac_map F :=
  let rec map acc :=
    match goal with
      | H : _ |- _ =>
        let FH := constr:(F H) in
          match acc with
            | context [FH] => fail 1
            | _ => map (List.cons FH acc)
          end
      | _ => acc
    end
  in
  let rec ret T :=
    match T with
      | _ -> ?T' => ret T'
      | ?T' => T'
    end
  in
  let T := ret ltac:(type of F) in
  let res := map (@List.nil T) in
  eval simpl in res.

Ltac ltac_map_list tac xs :=
  match xs with
    | List.nil => idtac
    | List.cons ?x ?xs => tac x; ltac_map_list tac xs
  end.

Ltac ltac_remove_dups xs :=
  let rec remove xs acc :=
    match xs with
      | List.nil => acc
      | List.cons ?x ?xs =>
        match acc with
          | context [x] => remove xs acc
          | _ => remove xs (List.cons x acc)
        end
    end
  in
  match type of xs with
    | List.list ?A =>
      let xs := eval simpl in xs in
      let xs := remove xs (@List.nil A) in
      eval simpl in (List.rev xs)
  end. *)



Module Type ENVIRONMENT.



Set Implicit Arguments.



Definition one (C : Type) (item : C) : list C := cons item nil.



Notation "x ~ a" := (one (x, a)) (at level 50) : list_scope.



Arguments Scope app [ type_scope list_scope list_scope ].



Open Scope list_scope.



Fixpoint dom

  (C : Type) (E : list (atom*C))

  : atoms :=

  match E with

    | nil => empty

    | (x, _) :: E' => add x (dom E')

  end.



Fixpoint get

  (C : Type) (x : atom) (E : list (atom*C))

  : option C :=

  match E with

    | nil => None

    | (y, c) :: F => if eq_atom_dec x y then Some c else get x F

  end.



Definition binds

  (A : Type) (x : atom) (a : A) (E : list (atom*A))

  : Prop :=

  List.In (x, a) E.



Definition maps

  (A : Type) (x : atom) (a : A) (E : list (atom*A))

  : Prop :=

  get x E = Some a.



Definition disjoint

  (A B : Type) (E : list (atom*A)) (F : list (atom*B))

  : Prop :=

  inter (dom E) (dom F) [<=] empty.



Definition map

  (A B : Type) (f : A -> B) (E : list (atom*A))

  : list (atom*B) :=

  List.map (fun b => match b with (x, a) => (x, f a) end) E.



Inductive uniq (A : Type) : list (atom*A) -> Prop :=

  | uniq_nil :

      uniq nil

  | uniq_push : forall x a E,

      uniq E ->

      ~ In x (dom E) ->

      uniq (x ~ a ++ E).



Unset Implicit Arguments.



Section ListProperties.

  Variable  X : Type.

  Variables x y : X.

  Variables l l1 l2 l3 : list X.



  Axiom cons_app_one :

    cons x l = one x ++ l.



  Axiom cons_app_assoc :

    (cons x l1) ++ l2 = cons x (l1 ++ l2).



  Axiom app_assoc :

    (l1 ++ l2) ++ l3 = l1 ++ (l2 ++ l3).



  Axiom app_nil_1 :

    nil ++ l = l.



  Axiom app_nil_2 :

    l ++ nil = l.



  Axiom in_nil_iff :

    List.In x nil <-> False.



  Axiom in_one_iff :

    List.In x (one y) <-> x = y.



  Axiom in_app_iff :

    List.In x (l1 ++ l2) <-> List.In x l1 \/ List.In x l2.



End ListProperties.



Section Properties.

  Variables A B key : Type.

  Variable  f       : A -> B.

  Variable  x       : atom.

  Variable  b       : A.

  Variables E F G   : list (atom*A).



  Axiom map_nil :

    map f (@nil (atom*A)) = nil.



  Axiom map_one :

    map f (x ~ b) = (x ~ f b).



  Axiom map_cons :

    map f ((x, b) :: E) = x ~ f b ++ map f E.



  Axiom map_app :

    map f (E ++ F) = map f E ++ map f F.



  Axiom dom_nil :

    dom (@nil (atom*A)) = empty.



  Axiom dom_one :

    dom (x ~ b) [=] singleton x.



  Axiom dom_cons :

    dom ((x, b) :: E) [=] union (singleton x) (dom E).



  Axiom dom_app :

    dom (E ++ F) [=] union (dom E) (dom F).



  Axiom dom_map :

    dom (map f E) [=] dom E.



End Properties.



Hint Rewrite cons_app_one cons_app_assoc      : rewr_list.

Hint Rewrite app_assoc app_nil_1 app_nil_2    : rewr_list.

Hint Rewrite in_nil_iff in_one_iff in_app_iff : rewr_list_in.



Hint Rewrite map_nil map_one map_cons map_app         : rewr_map.

Hint Rewrite dom_nil dom_one dom_cons dom_app dom_map : rewr_dom.



Ltac simpl_env :=

  autorewrite with rewr_list rewr_map rewr_dom.

Tactic Notation "simpl_env" "in" hyp(H) :=

  autorewrite with rewr_list rewr_map rewr_dom in H.

Tactic Notation "simpl_env" "in" "*" :=

  autorewrite with rewr_list rewr_map rewr_dom in *.



Tactic Notation "rewrite_env" constr(E) :=

  match goal with

    | |- context[?x] =>

      change x with E

    | |- context[?x] =>

      replace x with E;

        [ | try reflexivity; simpl_env; reflexivity ]

  end.



Tactic Notation "rewrite_env" constr(E) "in" hyp(H) :=

  match type of H with

    | context[?x] =>

      change x with E in H

    | context[?x] =>

      replace x with E in H;

        [ | try reflexivity; simpl_env; reflexivity ]

  end.



Axiom alist_ind : forall (A : Type) (P : list (atom * A) -> Type),

  (P nil) ->

  (forall x a xs, P xs -> P (x ~ a ++ xs)) ->

  (forall xs, P xs).



Tactic Notation "env" "induction" ident(E) :=

  try (intros until E);

  let T := type of E in

  let T := eval compute in T in

  match T with

    | list (?key * ?A) => induction E using (alist_ind A)

  end.



Tactic Notation "env" "induction" ident(E) "as" simple_intropattern(P) :=

  try (intros until E);

  let T := type of E in

  let T := eval compute in T in

  match T with

    | list (?key * ?A) => induction E as P using (alist_ind A)

  end.



Section Disjoint.

  Implicit Types A B C : Type.



  Axiom disjoint_sym_1 :

    forall A B (E : list (atom*A)) (F : list (atom*B)),

    disjoint E F ->

    disjoint F E.



  Axiom disjoint_sym :

    forall A B (E : list (atom*A)) (F : list (atom*B)),

    disjoint E F <-> disjoint F E.



  Axiom disjoint_nil_1 :

    forall A B (E : list (atom*B)),

    disjoint (@nil (atom*A)) E.



  Axiom disjoint_one_1 :

    forall A B (x : atom) (a : A) (F : list (atom*B)),

    disjoint (x ~ a) F ->

    ~ In x (dom F).



  Axiom disjoint_one_2 :

    forall A B (x : atom) (a : A) (F : list (atom*B)),

    ~ In x (dom F) ->

    disjoint (x ~ a) F.



  Axiom disjoint_one_l :

    forall A B (x : atom) (a : A) (E : list (atom*B)),

    disjoint (x ~ a) E <-> ~ In x (dom E).



  Axiom disjoint_one_r :

    forall A B (x : atom) (a : A) (E : list (atom*B)),

    disjoint E (x ~ a) <-> ~ In x (dom E).



  Axiom disjoint_cons_1 :

    forall A B x a (E : list (atom*A)) (F : list (atom*B)),

    disjoint ((x, a) :: E) F ->

    ~ In x (dom F).



  Axiom disjoint_cons_2 :

    forall A B x a (E : list (atom*A)) (F : list (atom*B)),

    disjoint ((x, a) :: E) F ->

    disjoint E F.



  Axiom disjoint_cons_3 :

    forall A B x a (E : list (atom*A)) (F : list (atom*B)),

    disjoint E F ->

    ~ In x (dom F) ->

    disjoint ((x, a) :: E) F.



  Axiom disjoint_cons_l :

    forall A B x a (E : list (atom*A)) (F : list (atom*B)),

    disjoint ((x, a) :: E) F <-> ~ In x (dom F) /\ disjoint E F.



  Axiom disjoint_cons_r :

    forall A B x a (E : list (atom*A)) (F : list (atom*B)),

    disjoint F ((x, a) :: E) <-> ~ In x (dom F) /\ disjoint E F.



  Axiom disjoint_app_1 :

    forall A B (E F : list (atom*A)) (G : list (atom*B)),

    disjoint (E ++ F) G ->

    disjoint E G.



  Axiom disjoint_app_2 :

    forall A B (E F : list (atom*A)) (G : list (atom*B)),

    disjoint (E ++ F) G ->

    disjoint F G.



  Axiom disjoint_app_3 :

    forall A B (E F : list (atom*A)) (G : list (atom*B)),

    disjoint E G ->

    disjoint F G ->

    disjoint (E ++ F) G.



  Axiom disjoint_app_l :

    forall A B (E F : list (atom*A)) (G : list (atom*B)),

    disjoint (E ++ F) G <-> disjoint E G /\ disjoint F G.



  Axiom disjoint_app_r :

    forall A B (E F : list (atom*A)) (G : list (atom*B)),

    disjoint G (E ++ F) <-> disjoint E G /\ disjoint F G.



  Axiom disjoint_map_1 :

    forall A B C (E : list (atom*A)) (F : list (atom*B)) (f:A->C),

    disjoint (map f E) F ->

    disjoint E F.



  Axiom disjoint_map_2 :

    forall A B C (E : list (atom*A)) (F : list (atom*B)) (f:A->C),

    disjoint E F ->

    disjoint (map f E) F.



  Axiom disjoint_map_l :

    forall A B C (E : list (atom*A)) (F : list (atom*B)) (f:A->C),

    disjoint (map f E) F <-> disjoint E F.



  Axiom disjoint_map_r :

    forall A B C (E : list (atom*A)) (F : list (atom*B)) (f:A->C),

    disjoint F (map f E) <-> disjoint E F.



End Disjoint.



Section UniqProperties.

  Variables A B   : Type.

  Variables f     : A -> B.

  Variables x     : atom.

  Variables a b   : A.

  Variables E F G : list (atom*A).



  Axiom uniq_one_1 :

    uniq (x ~ b).



  Axiom uniq_cons_1 :

    uniq ((x, a) :: E) ->

    uniq E.



  Axiom uniq_cons_2 :

    uniq ((x, a) :: E) ->

    ~ In x (dom E).



  Axiom uniq_cons_3 :

    uniq E ->

    ~ In x (dom E) ->

    uniq ((x, a) :: E).



  Axiom uniq_cons_iff :

    uniq ((x, a) :: E) <-> uniq E /\ ~ In x (dom E).



  Axiom uniq_app_1 :

    uniq (E ++ F) -> uniq E.



  Axiom uniq_app_2 :

    uniq (E ++ F) -> uniq F.



  Axiom uniq_app_3 :

    uniq (E ++ F) -> disjoint E F.



  Axiom uniq_app_4 :

    uniq E ->

    uniq F ->

    disjoint E F ->

    uniq (E ++ F).



  Axiom uniq_app_iff :

    uniq (E ++ F) <-> uniq E /\ uniq F /\ disjoint E F.



  Axiom uniq_map_1 :

    uniq (map f E) ->

    uniq E.



  Axiom uniq_map_2 :

    uniq E ->

    uniq (map f E).



  Axiom uniq_map_iff :

    uniq (map f E) <-> uniq E.



End UniqProperties.



Section BindsProperties.

  Variable  A B   : Type.

  Variables f     : A -> B.

  Variables x y   : atom.

  Variables a b   : A.

  Variables E F G : list (atom*A).



  Axiom binds_nil_iff :

    binds x a nil <-> False.



  Axiom binds_one_1 :

    binds x a (y ~ b) ->

    x = y.



  Axiom binds_one_2 :

    binds x a (y ~ b) ->

    a = b.



  Axiom binds_one_3 :

    x = y ->

    a = b ->

    binds x a (y ~ b).



  Axiom binds_one_iff :

    binds x a (y ~ b) <-> x = y /\ a = b.



  Axiom binds_cons_1 :

    binds x a ((y, b) :: E) ->

    (x = y /\ a = b) \/ binds x a E.



  Axiom binds_cons_2 :

    x = y ->

    a = b ->

    binds x a ((y, b) :: E).



  Axiom binds_cons_3 :

    binds x a E ->

    binds x a ((y, b) :: E).



  Axiom binds_cons_iff :

    binds x a ((y, b) :: E) <-> (x = y /\ a = b) \/ binds x a E.



  Axiom binds_app_1 :

    binds x a (E ++ F) ->

    binds x a E \/ binds x a F.



  Axiom binds_app_2 :

    binds x a E ->

    binds x a (E ++ F).



  Axiom binds_app_3 :

    binds x a F ->

    binds x a (E ++ F).



  Axiom binds_app_iff :

    binds x a (E ++ F) <-> binds x a E \/ binds x a F.



  Axiom binds_map_1 :

    (forall a b, f a = f b -> a = b) ->

    binds x (f a) (map f E) ->

    binds x a E.



  Axiom binds_map_2 :

    binds x a E ->

    binds x (f a) (map f E).



  Axiom binds_dom_contradiction : forall (E : list (atom*A)),

    binds x a E ->

    ~ In x (dom E) ->

    False.



  Axiom binds_app_uniq_1 :

    uniq (E ++ F) ->

    binds x a (E ++ F) ->

    (binds x a E /\ ~ In x (dom F)) \/ (binds x a F /\ ~ In x (dom E)).



  Axiom binds_app_uniq_iff :

    uniq (E ++ F) ->

    (binds x a (E ++ F) <->

      (binds x a E /\ ~ In x (dom F)) \/

      (binds x a F /\ ~ In x (dom E))).



End BindsProperties.



Section BindsProperties2.

  Variable  A B   : Type.

  Variables f     : A -> B.

  Variables x y   : atom.

  Variables a b   : A.

  Variables E F G : list (atom*A).



  Axiom binds_cons_uniq_1 :

    uniq ((y, b) :: E) ->

    binds x a ((y, b) :: E) ->

    (x = y /\ a = b /\ ~ In x (dom E)) \/ (binds x a E /\ x <> y).



  Axiom binds_cons_uniq_iff :

    uniq ((y, b) :: E) ->

    (binds x a ((y, b) :: E) <->

      (x = y /\ a = b /\ ~ In x (dom E)) \/

      (binds x a E /\ x <> y)).



End BindsProperties2.



Hint Resolve

  @app_assoc @app_nil_2 @map_app @dom_one @dom_cons @dom_app @dom_map.



Hint Resolve

  @disjoint_sym_1 @disjoint_nil_1 @disjoint_one_2 @disjoint_cons_3

  @disjoint_app_3 @disjoint_map_2 @uniq_nil @uniq_push @uniq_one_1

  @uniq_cons_3 @uniq_app_4 @uniq_map_2.



Hint Resolve

  @binds_one_3 @binds_cons_3 @binds_app_2 @binds_app_3 @binds_map_2.



Section AssortedListProperties.

  Variable  X : Type.

  Variables x : X.

  Variables xs ys zs : list X.



  Axiom one_eq_app :

    one x ++ xs = ys ++ zs ->

    (exists qs, ys = x :: qs /\ xs = qs ++ zs) \/

    (ys = nil /\ zs = x :: xs).



  Axiom app_eq_one :

    ys ++ zs = one x ++ xs ->

    (exists qs, ys = x :: qs /\ xs = qs ++ zs) \/

    (ys = nil /\ zs = x :: xs).



  Axiom nil_neq_one_mid :

    nil <> xs ++ one x ++ ys.



  Axiom one_mid_neq_nil :

    xs ++ one x ++ ys <> nil.



End AssortedListProperties.



Ltac destruct_uniq :=

  match goal with

    | H : uniq nil |- _ =>

      clear H;

      destruct_uniq

    | H : uniq (?x ~ ?a) |- _ =>

      clear H;

      destruct_uniq

    | H : uniq ((?x, ?a) :: ?E) |- _ =>

      let J := fresh "UniqTac" in

      pose proof H as J;

      apply uniq_cons_1 in H;

      apply uniq_cons_2 in J;

      autorewrite with rewr_dom in J;

      destruct_uniq

    | H : uniq (?E ++ ?F) |- _ =>

      let J1 := fresh "UniqTac" in

      let J2 := fresh "UniqTac" in

      pose proof H as J1;

      pose proof H as J2;

      apply uniq_app_1 in H;

      apply uniq_app_2 in J1;

      apply uniq_app_3 in J2;

      destruct_uniq

    | H : uniq (map ?f ?E) |- _ =>

      apply uniq_map_1 in H;

      destruct_uniq

    | H : disjoint nil ?E |- _ =>

      clear H;

      destruct_uniq

    | H : disjoint (?x ~ ?a) ?F |- _ =>

      apply disjoint_one_1 in H;

      autorewrite with rewr_dom in H;

      destruct_uniq

    | H : disjoint ((?x, ?a) :: ?E) ?F |- _ =>

      let J := fresh "UniqTac" in

      pose proof H as J;

      apply disjoint_cons_1 in H;

      apply disjoint_cons_2 in J;

      autorewrite with rewr_dom in H;

      destruct_uniq

    | H : disjoint (?E ++ ?F) ?G |- _ =>

      let J := fresh "UniqTac" in

      pose proof H as J;

      apply disjoint_app_1 in H;

      apply disjoint_app_2 in J;

      destruct_uniq

    | H : disjoint (map ?f ?E) ?F |- _ =>

      apply disjoint_map_1 in H;

      destruct_uniq

    | H : disjoint ?E nil |- _ =>

      clear H;

      destruct_uniq

    | H : disjoint ?F (?x ~ ?a) |- _ =>

      apply disjoint_sym_1 in H;

      destruct_uniq

    | H : disjoint ?F ((?x, ?a) :: ?E) |- _ =>

      apply disjoint_sym_1 in H;

      destruct_uniq

    | H : disjoint ?G (?E ++ ?F) |- _ =>

      apply disjoint_sym_1 in H;

      destruct_uniq

    | H : disjoint ?F (map ?f ?E) |- _ =>

      apply disjoint_sym_1 in H;

      destruct_uniq

    | _ =>

      idtac

  end.



Ltac solve_uniq :=

  intros;

  destruct_uniq;

  repeat first [ apply uniq_push

               | apply uniq_cons_3

               | apply uniq_app_4

               | apply uniq_one_1

               | apply uniq_nil ];

  auto;

  try tauto;

  unfold disjoint in *;

  try fsetdec;

  fail "Not solvable by [solve_uniq]; try [destruct_uniq]".



Section UniqDerived.

  Variable  A     : Type.

  Variables x y   : atom.

  Variables a b   : A.

  Variables E F G : list (atom*A).



  Axiom uniq_insert_mid :

    uniq (G ++ E) ->

    ~ In x (dom G) ->

    ~ In x (dom E) ->

    uniq (G ++ (x ~ a) ++ E).



  Axiom uniq_remove_mid :

    uniq (E ++ F ++ G) ->

    uniq (E ++ G).



  Axiom uniq_reorder_1 :

    uniq (E ++ F) ->

    uniq (F ++ E).



  Axiom uniq_reorder_2 :

    uniq (E ++ F ++ G) ->

    uniq (F ++ E ++ G).



  Axiom uniq_map_app_l : forall (f : A -> A),

    uniq (F ++ E) ->

    uniq (map f F ++ E).



  Axiom fresh_mid_tail :

    uniq (F ++ (x ~ a) ++ E) ->

    ~ In x (dom E).



  Axiom fresh_mid_head :

    uniq (F ++ (x ~ a) ++ E) ->

    ~ In x (dom F).



End UniqDerived.



Ltac destruct_binds_hyp H :=

  match type of H with

    | binds ?x ?a nil =>

      inversion H

    | binds ?x ?a (?y ~ ?b) =>

      let J1 := fresh "BindsTacKey" in

      let J2 := fresh "BindsTacVal" in

      rename H into J1;

      pose proof J1 as J2;

      apply binds_one_1 in J1;

      apply binds_one_2 in J2;

      try (subst x);

      try (subst a);

      try (subst y);

      try (subst b)

    | binds ?x ?a ((?y, ?b) :: ?E) =>

      change (binds x a (y ~ b ++ E)) in H;

      destruct_binds_hyp H

    | binds ?x ?a (?E ++ ?F) =>

      let J := fresh "BindsTac" in

      apply binds_app_1 in H;

      destruct H as [J | J];

      destruct_binds_hyp J

    | _ =>

      idtac

  end.



Ltac destruct_binds_hyp_uniq H :=

  match type of H with

    | binds ?x ?a nil =>

      inversion H

    | binds ?x ?a (?y ~ ?b) =>

      let J1 := fresh "BindsTacKey" in

      let J2 := fresh "BindsTacVal" in

      rename H into J1;

      pose proof J1 as J2;

      apply binds_one_1 in J1;

      apply binds_one_2 in J2;

      try (subst x);

      try (subst a);

      try (subst y);

      try (subst b)

    | binds ?x ?a ((?y, ?b) :: ?E) =>

      change (binds x a (y ~ b ++ E)) in H;

      destruct_binds_hyp_uniq H

    | binds ?x ?a (?E ++ ?F) =>

      let J1 := fresh "BindsTacSideCond" in

      assert (J1 : uniq (E ++ F));

        [ destruct_uniq; auto

        | match type of J1 with

            | @uniq ?A _ =>

              let J2 := fresh "BindsTac" in

              destruct (@binds_app_uniq_1 A x a E F J1 H)

                as [[J2 ?] | [J2 ?]];

              clear H;

              destruct_binds_hyp_uniq J2

          end

        ]

    | _ =>

      idtac

  end.



Ltac analyze_binds_cleanup :=

  auto;

  try tauto;

  try discriminate;

  try match goal with

        | J : ~ In ?x ?E |- _ =>

          match E with

            | context [x] => elim J; clear; simpl_env; auto with set

          end

      end.



Ltac analyze_binds H :=

  destruct_binds_hyp H;

  analyze_binds_cleanup.



Ltac analyze_binds_uniq H :=

  destruct_binds_hyp_uniq H;

  analyze_binds_cleanup.



Section BindsDerived.

  Variables A B   : Type.

  Variables f     : A -> B.

  Variables x y   : atom.

  Variables a b   : A.

  Variables E F G : list (atom*A).



  Axiom binds_dec :

    (forall a b : A, {a = b} + {a <> b}) ->

    {binds x a E} + {~ binds x a E}.



  Axiom binds_lookup :

    {a : A | binds x a E} + (forall a, ~ binds x a E).



  Axiom binds_lookup_dec :

    decidable (exists a, binds x a E).



  Axiom binds_weaken :

    binds x a (E ++ G) ->

    binds x a (E ++ F ++ G).



  Axiom binds_mid_eq :

    binds x a (F ++ (x ~ b) ++ E) ->

    uniq (F ++ (x ~ b) ++ E) ->

    a = b.



  Axiom binds_remove_mid :

    binds x a (F ++ (y ~ b) ++ G) ->

    x <> y ->

    binds x a (F ++ G).



  Axiom binds_In : forall x a (E : list (atom*A)),

    binds x a E ->

    In x (dom E).



  Axiom binds_In_inv : forall x (E : list (atom*A)),

    In x (dom E) ->

    exists a, binds x a E.



  Axiom binds_unique :

    binds x a E ->

    binds x b E ->

    uniq E ->

    a = b.



  Axiom fresh_app_l :

    uniq (F ++ E) ->

    binds x a E ->

    ~ In x (dom F).



  Axiom fresh_app_r :

    uniq (F ++ E) ->

    binds x a F ->

    ~ In x (dom E).



End BindsDerived.



Hint Resolve @nil_neq_one_mid @one_mid_neq_nil.



Hint Resolve @uniq_insert_mid @uniq_map_app_l.



Hint Immediate @uniq_remove_mid.



Hint Resolve @binds_weaken.



Hint Immediate @binds_remove_mid @binds_In.



End ENVIRONMENT.



Module Export EnvImpl : ENVIRONMENT := AssocList.Make AtomDT AtomSetImpl.

