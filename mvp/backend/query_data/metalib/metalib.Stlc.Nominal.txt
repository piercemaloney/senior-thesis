

Require Export Omega.



Require Export Metalib.Metatheory.



Require Export Metalib.LibLNgen.



Notation X := (fresh nil).

Notation Y := (fresh (X :: nil)).

Notation Z := (fresh (X :: Y :: nil)).



Inductive n_exp : Set :=

 | n_var (x:atom)

 | n_abs (x:atom) (t:n_exp)

 | n_app (t1:n_exp) (t2:n_exp).



Definition demo_rep1 := n_abs X (n_app (n_var Y) (n_var X)).



Definition demo_rep2 := n_abs Z (n_app (n_var Y) (n_var Z)).



Fixpoint fv_nom (n : n_exp) : atoms :=

  match n with

  | n_var x => {{x}}

  | n_abs x n => remove x (fv_nom n)

  | n_app t1 t2 => fv_nom t1 `union` fv_nom t2

  end.



Example fv_nom_rep1 : fv_nom demo_rep1 [=] {{ Y }}.

Proof.

  simpl.

  assert (~ In Y (X :: nil)).     

  apply Atom.fresh_not_in.

  apply elim_not_In_cons in H.

  fsetdec.

Qed.



Definition swap_var (x:atom) (y:atom) (z:atom) :=

  if (z == x) then y else if (z == y) then x else z.



Fixpoint swap (x:atom) (y:atom) (t:n_exp) : n_exp :=

  match t with

  | n_var z     => n_var (swap_var x y z)

  | n_abs z t1  => n_abs (swap_var x y z) (swap x y t1)

  | n_app t1 t2 => n_app (swap x y t1) (swap x y t2)

  end.



Example swap1 : forall x y z, x <> z -> y <> z ->

    swap x y (n_abs z (n_app (n_var x)(n_var y))) = n_abs z (n_app (n_var y) (n_var x)).

Proof.

  intros. simpl; unfold swap_var; default_simp.

Qed.



Example swap2 : forall x y, x <> y ->

    swap x y (n_abs x (n_var x)) = n_abs y (n_var y).

Proof.

  intros. simpl; unfold swap_var; default_simp.

Qed.



Example swap3 : forall x y, x <> y ->

     swap x y (n_abs y (n_var x)) = n_abs x (n_var y).

Proof.

  intros. simpl; unfold swap_var; default_simp.

Qed.



Inductive aeq : n_exp -> n_exp -> Prop :=

 | aeq_var : forall x,

     aeq (n_var x) (n_var x)

 | aeq_abs_same : forall x t1 t2,

     aeq t1 t2 -> aeq (n_abs x t1) (n_abs x t2)

 | aeq_abs_diff : forall x y t1 t2,

     x <> y ->

     x `notin` fv_nom t2 ->

     aeq t1 (swap y x t2) ->

     aeq (n_abs x t1) (n_abs y t2)

 | aeq_app : forall t1 t2 t1' t2',

     aeq t1 t1' -> aeq t2 t2' ->

     aeq (n_app t1 t2) (n_app t1' t2').



Hint Constructors aeq.



Example aeq1 : forall x y, x <> y -> aeq (n_abs x (n_var x)) (n_abs y (n_var y)).

Proof.

  intros.

  eapply aeq_abs_diff; auto.

  simpl; unfold swap_var; default_simp.

Qed.



Lemma swap_id : forall n x,

    swap x x n = n.

Proof.

  induction n; simpl; unfold swap_var;  default_simp.

Qed.



Lemma fv_nom_swap : forall z y n,

  z `notin` fv_nom n ->

  y `notin` fv_nom (swap y z n).

Proof.

  

  induction n; intros; simpl; unfold swap_var; default_simp.

Qed. 



Lemma shuffle_swap : forall w y n z,

    w <> z -> y <> z ->

    (swap w y (swap y z n)) = (swap w z (swap w y n)).

Proof.

  

  induction n; intros; simpl; unfold swap_var; default_simp.

Qed. 



Lemma swap_symmetric : forall t x y,

    swap x y t = swap y x t.

Proof.

  

  induction t;  simpl; unfold swap_var; default_simp.

Qed.   



Lemma swap_involutive : forall t x y,

    swap x y (swap x y t) = t.

Proof.

  

  induction t;  simpl; unfold swap_var; default_simp.

Qed.   



Lemma swap_var_equivariance : forall v x y z w,

    swap_var x y (swap_var z w v) =

    swap_var (swap_var x y z) (swap_var x y w) (swap_var x y v).

Proof.

  

  unfold swap_var; default_simp.

Qed.   



Lemma swap_equivariance : forall t x y z w,

    swap x y (swap z w t) = swap (swap_var x y z) (swap_var x y w) (swap x y t).

Proof.

  

  induction t; intros; simpl.

  - rewrite swap_var_equivariance. auto.

  - rewrite swap_var_equivariance. rewrite IHt. auto.

  - rewrite IHt1. rewrite IHt2. auto.

Qed. 



Lemma notin_fv_nom_equivariance : forall x0 x y t ,

  x0 `notin` fv_nom t ->

  swap_var x y x0  `notin` fv_nom (swap x y t).

Proof.

  

  induction t; intros; simpl in *.

  - unfold swap_var; default_simp.

  - unfold swap_var in *. default_simp.

  - destruct_notin. eauto.

Qed. 



Lemma in_fv_nom_equivariance : forall x y x0 t,

  x0 `in` fv_nom t ->

  swap_var x y x0 `in` fv_nom (swap x y t).

Proof.

  

  induction t; intros; simpl in *.

  - unfold swap_var; default_simp; fsetdec.

  - unfold swap_var in *. default_simp; fsetdec.

  - destruct (AtomSetImpl.union_1 H); fsetdec.

Qed. 



Lemma aeq_equivariance : forall x y t1 t2,

    aeq t1 t2 ->

    aeq (swap x y t1) (swap x y t2).

Proof.

  

  induction 1; intros; simpl in *; auto.

  destruct (swap_var x y x0 == swap_var x y y0).

  - rewrite e. eapply aeq_abs_same.

    rewrite swap_equivariance in IHaeq.

    rewrite e in IHaeq.

    rewrite swap_id in IHaeq.

    auto.

  - rewrite swap_equivariance in IHaeq.

    eapply aeq_abs_diff; auto.

    eapply notin_fv_nom_equivariance; auto.

Qed. 



Definition heap := list (atom * n_exp).



Inductive frame : Set := | n_app2 : n_exp -> frame.

Notation  stack := (list frame).



Definition configuration := (heap * n_exp * stack)%type.



Inductive Step a := Error    : Step a

                  | Done     : Step a

                  | TakeStep : a -> Step a.



Definition isVal (t : n_exp) :=

  match t with

  | n_abs _ _ => true

  | _         => false

  end.



Definition machine_step (avoid : atoms) (c : configuration) : Step configuration :=

  match c with

    (h, t, s) =>

    if isVal t then

      match s with

      | nil => Done _

      | n_app2 t2 :: s' =>

        match t with

        | n_abs x t1 =>

          

          if AtomSetProperties.In_dec x (dom h `union` avoid)  then

            let (y,_) := atom_fresh (dom h `union` avoid) in

             TakeStep _ ((y,t2)::h, swap x y t1, s')

          else

            TakeStep _ ((x,t2)::h, t1, s')

        | _ => Error _ 

        end

      end

    else match t with

         | n_var x => match get x h with

                     | Some t1  => TakeStep _ (h, t1, s)

                     | None    => Error _ 

                     end

         | n_app t1 t2 => TakeStep _ (h, t1, n_app2 t2 :: s)

         | _ => Error _ 

         end

  end.



Definition initconf (t : n_exp) : configuration := (nil,t,nil).



Lemma values_are_done : forall D t,

    isVal t = true -> machine_step D (initconf t) = Done _.

Proof.



  intros D t VV.

  destruct t; simpl in *; try discriminate.

  auto.

Qed. 



Fixpoint size (t : n_exp) : nat :=

  match t with

  | n_var x => 1

  | n_abs x t => 1 + size t

  | n_app t1 t2 => 1 + size t1 + size t2

  end.



Lemma swap_size_eq : forall x y t,

    size (swap x y t) = size t.

Proof.

  induction t; simpl; auto.

Qed.



Hint Rewrite swap_size_eq.



Lemma nominal_induction_size :

     forall n, forall t, size t <= n ->

     forall P : n_exp -> Type,

    (forall x, P (n_var x)) ->

    (forall x t, (forall y, P (swap x y t)) -> P (n_abs x t)) ->

    (forall t1 t2, P t1 -> P t2 -> P (n_app t1 t2)) ->

    P t.

Proof.

  induction n.

  intros t SZ; destruct t; intros; simpl in SZ; omega.

  intros t SZ P VAR ABS APP; destruct t; simpl in *.

  - auto.

  - apply ABS.

    intros y.

    apply IHn; eauto; rewrite swap_size_eq; try omega.

  - apply APP.

    apply IHn; eauto; omega.

    apply IHn; eauto; omega.

Defined.



Definition nominal_induction

  : forall (P : n_exp -> Type),

    (forall x : atom, P (n_var x)) ->

    (forall (x : atom) (t : n_exp),

        (forall y : atom, P (swap x y t)) -> P (n_abs x t)) ->

    (forall t1 t2 : n_exp, P t1 -> P t2 -> P (n_app t1 t2)) ->

    forall t : n_exp, P t :=

  fun P VAR APP ABS t =>

  nominal_induction_size (size t) t ltac:(auto) P VAR APP ABS.



Fixpoint subst_rec (n:nat) (t:n_exp) (u :n_exp) (x:atom)  : n_exp :=

  match n with

  | 0 => t

  | S m => match t with

          | n_var y => if (x == y) then u else t

          | n_abs y t1 => if (x == y) then t

                        else let (z,_) := atom_fresh (fv_nom u \u fv_nom t) in

                             n_abs z (subst_rec m (swap y z t1) u x)

          | n_app t1 t2 => n_app (subst_rec m t1 u x) (subst_rec m t2 u x)

          end

  end.



Definition subst (u : n_exp) (x:atom) (t:n_exp) :=

  subst_rec (size t) t u x.



Lemma subst_size : forall n (u : n_exp) (x:atom) (t:n_exp),

    size t <= n -> subst_rec n t u x = subst_rec (size t) t u x.

Proof.

  intro n. eapply (lt_wf_ind n). clear n.

  intros n IH u x t SZ.

  destruct t; simpl in *; destruct n; try omega.

  - default_simp.

  - default_simp.

    rewrite <- (swap_size_eq x0 x1).

    rewrite <- (swap_size_eq x0 x1) in SZ.

    apply IH. omega. omega.

  - simpl.

    rewrite (IH n); try omega.

    rewrite (IH n); try omega.

    rewrite (IH (size t1 + size t2)); try omega.

    rewrite (IH (size t1 + size t2)); try omega.

    auto.

Qed.



Lemma subst_eq_var : forall u x,

    subst u x (n_var x) = u.

Proof.

  

  intros. unfold subst. default_simp.

Qed. 



Lemma subst_neq_var : forall u x y,

    x <> y ->

    subst u x (n_var y) = n_var y.

Proof.

  

  intros. unfold subst. default_simp.

Qed. 



Lemma subst_app : forall u x t1 t2,

    subst u x (n_app t1 t2) = n_app (subst u x t1) (subst u x t2).

Proof. 

  intros. unfold subst.

  simpl.

  rewrite (subst_size (size t1 + size t2)).

  rewrite (subst_size (size t1 + size t2)).

  auto.

  omega.

  omega.

Qed. 



Lemma subst_abs : forall u x y t1,

    subst u x (n_abs y t1) =

       if (x == y) then (n_abs y t1)

       else let (z,_) := atom_fresh (fv_nom u \u fv_nom (n_abs y t1)) in

       n_abs z (subst u x (swap y z t1)).

Proof. 

  intros. unfold subst. default_simp.

  rewrite swap_size_eq. auto.

Qed. 



Fixpoint aeq_f  (n: nat) (L : atoms) (t1 : n_exp) (t2 : n_exp) : bool :=

  match n with

  | 0 => false

  | S m =>

    match t1 , t2 with

    | n_var x , n_var y => if (x == y) then true else false

    | n_abs x1 t1, n_abs x2 t2 =>

      if (x1 == x2) then aeq_f m L t1 t2

      else let (y,_) := atom_fresh L in

           aeq_f m ({{y}} \u L) (swap y x1 t1) (swap y x2 t2)

  | n_app t1 t2 , n_app t1' t2' =>

    if aeq_f m L t1 t1' then aeq_f m L t2 t2' else false

  | _ , _ => false

    end

end.



Definition is_aeq t1 t2 := aeq_f (size t1) (fv_nom t1 \u fv_nom t2).



Lemma aeq_refl : forall n, aeq n n.

Proof.

  induction n; auto.

Qed.



Lemma subst_equivariance : forall u x y z t,

    swap x y (subst u z t) = subst (swap x y u) (swap_var x y z) (swap x y t).

Proof.

  intros.

  eapply nominal_induction with (t := t).



  Focus 2.

  intros.

  rewrite subst_abs. default_simp.

  rewrite subst_abs. default_simp.

  rewrite subst_abs. default_simp.

  rewrite <- e.

Admitted.



Lemma subst_same : forall t y, aeq (subst (n_var y) y t)  t.

Proof.

  intros t y. eapply nominal_induction with (t := t).

  - intros. destruct (x == y). subst. rewrite subst_eq_var. auto.

  rewrite subst_neq_var. auto. auto.

  - intros.

    rewrite subst_abs. destruct (y == x).

    eapply aeq_abs_same. eapply aeq_refl.

    destruct atom_fresh.

    simpl in n0.

    destruct (x0 == x). subst. rewrite swap_id.

    eapply aeq_abs_same.

Admitted.



Lemma aeq_fv_nom : forall t1 t2,

    aeq t1 t2 ->

    fv_nom t1 [=] fv_nom t2.

Proof.

  induction 1; simpl in *; try fsetdec.

  unfold AtomSetImpl.Equal.

  intro a.

  rewrite remove_iff.

  rewrite remove_iff.

  rewrite IHaeq.

  clear IHaeq H1.

  split.

  + intros [K1 K2].

    apply (in_fv_nom_equivariance y x) in K1.

    rewrite swap_involutive in K1.

    unfold swap_var in K1.

    destruct (a == y); subst. contradiction.

    destruct (a == x); subst. contradiction.

    split. auto. auto.

  + intros [K1 K2].

    apply (in_fv_nom_equivariance y x) in K1.

    pose (J := notin_fv_nom_equivariance x y x t2 H0). clearbody J.

    unfold swap_var in *.

    default_simp.

Qed.



Lemma aeq_sym : forall t1 t2,

    aeq t1 t2 -> aeq t2 t1.

Proof.

  induction 1; auto.

  - eapply aeq_abs_diff; auto.

    rewrite aeq_fv_nom; eauto.

    pose (J := notin_fv_nom_equivariance x y x t2 H0). clearbody J.

    unfold swap_var in J. default_simp.

    eapply aeq_equivariance in IHaeq.

    rewrite swap_involutive in IHaeq.

    rewrite swap_symmetric.

    auto.

Qed.



Lemma swap_fresh : forall t x0 y0 z,

  z `notin` fv_nom t -> x0 `notin` fv_nom t -> z <> y0 -> z <> x0 ->

  aeq (swap z x0 (swap y0 z t)) (swap y0 x0 t).

Proof.

  intro t; induction t.

  intros x0 y0 z; intros; simpl in *; unfold swap_var in *.

  default_simp; try fsetdec.

  intros x0 y0 z; intros; simpl in *; unfold swap_var in *.

Admitted.



Lemma aeq_trans_aux : forall n t2 t1 t3, size t2 <= n -> aeq t1 t2 -> aeq t2 t3 -> aeq t1 t3.

Proof.

  induction n;

  intros t2 t1 t3 SZ A1 A2;

  destruct t2; simpl in *; try omega; intros.

  - inversion A1. inversion A2. subst. auto.

  - inversion A1; inversion A2; subst.

    + eapply aeq_abs_same; eauto.

      eapply IHn; eauto; try omega.

    + eapply aeq_abs_diff; eauto.

      eapply IHn; eauto; try omega.

    + eapply aeq_abs_diff; eauto.

      rewrite <- aeq_fv_nom; eauto.

      assert (aeq (swap x x0 t2) (swap x x0 t6)).

      eapply aeq_equivariance; auto.

      eapply IHn; eauto.

      rewrite swap_size_eq. omega.

    + destruct (x0 == y0).

      ++ subst. eapply aeq_abs_same.

         assert (aeq (swap x y0 t2) (swap x y0 (swap y0 x t6))).

         eapply aeq_equivariance; auto.

         rewrite (swap_symmetric _ y0 x) in H.

         rewrite swap_involutive in H.

         eapply IHn; eauto.

         rewrite swap_size_eq. omega.

      ++ assert (x0 `notin` fv_nom t6).

         { apply (aeq_equivariance y0 x) in H10.

         rewrite swap_involutive in H10.

         rewrite <- (aeq_fv_nom _ _ H10); eauto.

         replace x0 with (swap_var y0 x x0).

         eapply notin_fv_nom_equivariance. auto.

         unfold swap_var; default_simp. }

         eapply aeq_abs_diff; eauto.

         * apply (aeq_equivariance x x0) in H10.

           pose (K := swap_fresh t6 x0 y0 x H8 H H7 ltac:(auto)). clearbody K.

           admit.

  - inversion A1; inversion A2; subst.

    eapply aeq_app. eapply IHn; eauto. omega.

    eapply IHn; eauto. omega.

Admitted.



