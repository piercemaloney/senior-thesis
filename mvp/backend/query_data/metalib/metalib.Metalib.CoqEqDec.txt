

Require Import Coq.Classes.Equivalence.

Require Import Coq.Classes.EquivDec.

Require Import Coq.Logic.Decidable.



Hint Extern 0 (?x === ?x) => reflexivity.

Hint Extern 1 (_ === _) => (symmetry; trivial; fail).

Hint Extern 1 (_ =/= _) => (symmetry; trivial; fail).



Lemma equiv_reflexive' : forall (A : Type) `{EqDec A} (x : A),

  x === x.

Proof. intros. apply equiv_reflexive. Qed.



Lemma equiv_symmetric' : forall (A : Type) `{EqDec A} (x y : A),

  x === y ->

  y === x.

Proof. intros. apply equiv_symmetric; assumption. Qed.



Lemma equiv_transitive' : forall (A : Type) `{EqDec A} (x y z : A),

  x === y ->

  y === z ->

  x === z.

Proof. intros. eapply @equiv_transitive; eassumption. Qed.



Lemma equiv_decidable : forall (A : Type) `{EqDec A} (x y : A),

  decidable (x === y).

Proof. intros. unfold decidable. destruct (x == y); auto. Defined.



Class EqDec_eq (A : Type) :=

  eq_dec : forall (x y : A), {x = y} + {x <> y}.



Instance EqDec_eq_of_EqDec (A : Type) `(@EqDec A eq eq_equivalence) : EqDec_eq A.

Proof. trivial. Defined.



Theorem eq_dec_refl {A : Type} `{EqDec_eq A} (x : A) : eq_dec x x = left eq_refl.

Proof.

  destruct (eq_dec x x); [|contradiction].

  f_equal; apply (Eqdep_dec.UIP_dec eq_dec).

Qed.



Notation " x  == y " := (eq_dec x y) (at level 70) : coqeqdec_scope.



Open Scope coqeqdec_scope.

