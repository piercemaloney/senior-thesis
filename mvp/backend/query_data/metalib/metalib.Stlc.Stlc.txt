Require Import Metalib.Metatheory.
(* Metalib.Metatheory:
Require Export Coq.Arith.Arith.
Require Export Coq.FSets.FSets.
Require Export Coq.Lists.List.

Require Export Metalib.AssocList.
Require Export Metalib.CoqListFacts.
Require Export Metalib.LibTactics.
Require Export Metalib.MetatheoryAtom.

Notation "E [=] F" :=
  (AtomSetImpl.Equal E F)
  (at level 70, no associativity)
  : set_scope.

Notation "E [<=] F" :=
  (AtomSetImpl.Subset E F)
  (at level 70, no associativity)
  : set_scope.

Notation "{}" :=
  (AtomSetImpl.empty)
  : set_scope.

Notation "{{  x  }}" :=
  (AtomSetImpl.singleton x)
  : set_scope.

Notation "x `in` E" :=
  (AtomSetImpl.In x E)
  (at level 70)
  : set_hs_scope.

Notation "x `notin` E" :=
  (~ AtomSetImpl.In x E)
  (at level 70)
  : set_hs_scope.

Notation "E `union` F" :=
  (AtomSetImpl.union E F)
  (at level 65, right associativity, format "E  `union`  '/' F")
  : set_hs_scope.

Notation add := AtomSetImpl.add.
Notation empty := AtomSetImpl.empty.
Notation remove := AtomSetImpl.remove.
Notation singleton := AtomSetImpl.singleton.
Notation union := AtomSetImpl.union.

Open Scope set_scope.
Open Scope set_hs_scope.

Module Export EnvImpl := AssocList.Make Atom AtomSetImpl.

Ltac simpl_env :=
  simpl_alist.

Tactic Notation "simpl_env" "in" hyp(H) :=
  simpl_alist in H.

Tactic Notation "simpl_env" "in" "*" :=
  simpl_alist in *.

Tactic Notation "rewrite_env" constr(E) :=
  rewrite_alist E.

Tactic Notation "rewrite_env" constr(E) "in" hyp(H) :=
  rewrite_alist E in H.

Tactic Notation "env" "induction" ident(E) :=
  alist induction E.

Tactic Notation "env" "induction" ident(E) "as" simple_intropattern(P) :=
  alist induction E as P.

Notation "[ x ]" := (EnvImpl.one x) : env_scope.

Open Scope env_scope.

Tactic Notation
  "pick" "fresh" ident(atom_name)
  "excluding" constr(L)
  "and" "apply" constr(H)
  :=
    first [apply (@H L) | eapply (@H L)];
      match goal with
        | |- forall _, _ `notin` _ -> _ =>
          let Fr := fresh "Fr" in intros atom_name Fr
        | |- forall _, _ `notin` _ -> _ =>
          fail 1 "because" atom_name "is already defined"
        | _ =>
          idtac
      end.

Tactic Notation
  "pick" "fresh" ident(atom_name)
  "and" "apply" constr(H)
  :=
    let L := gather_atoms in
    let L := beautify_fset L in
    pick fresh atom_name excluding L and apply H.

Notation uniq_one := uniq_one_1.
Notation uniq_cons := uniq_cons_3.
Notation uniq_app := uniq_app_4.
Notation uniq_map := uniq_map_2.

Notation binds_one := binds_one_3.
Notation binds_cons := binds_cons_3.
Notation binds_app_l := binds_app_2.
Notation binds_app_r := binds_app_3.
Notation binds_map := binds_map_2.

Notation notin_empty := notin_empty_1.
Notation notin_add := notin_add_3.
Notation notin_singleton := notin_singleton_2.
Notation notin_union := notin_union_3.

Ltac hint_extern_solve_notin :=
  try eassumption;
  autorewrite with rewr_dom in *;
  destruct_notin;
  repeat first [ apply notin_union_3
               | apply notin_add_3
               | apply notin_singleton_2
               | apply notin_empty_1
               ];
  try tauto.

Hint Extern 1 (_ <> _ :> _) => hint_extern_solve_notin.

Hint Extern 1 (_ `notin` _) => hint_extern_solve_notin.

Hint Resolve
  AtomSetImpl.add_1 AtomSetImpl.add_2 AtomSetImpl.remove_1
  AtomSetImpl.remove_2 AtomSetImpl.singleton_2 AtomSetImpl.union_2
  AtomSetImpl.union_3 AtomSetImpl.inter_3 AtomSetImpl.diff_3.

Require Export Metalib.CoqEqDec.

Notation " x  == y " := (eq_dec x y) (at level 70) : coqeqdec_scope.

Open Scope coqeqdec_scope.

Notation var := atom (only parsing).

Notation vars := atoms (only parsing).

Notation eq_var := eq_dec (only parsing).

Notation "x  ===  y" :=
  (x == y)
  (at level 70, only parsing)
  : coqeqdec_scope.

Notation "x \in s" :=
  (x `in` s)
  (at level 70, only parsing)
  : set_sl_scope.

Notation "x \notin s" :=
  (x `notin` s)
  (at level 70, only parsing)
  : set_sl_scope.

Notation "s \u t" :=
  (s `union` t)
  (at level 65, right associativity, only parsing)
  : set_sl_scope.

Open Scope set_sl_scope.

Ltac gather_vars_with F := gather_atoms_with.

Ltac pick_fresh_gen L Y := pick fresh Y for L.

Tactic Notation "auto" "*" := auto.

Ltac apply_fresh_base H gather_vars atom_name :=
  let L := gather_vars in
  let L := beautify_fset L in
  pick fresh x excluding L and apply H.

Set Implicit Arguments.
Definition union_map (A:Set) (f:A -> vars) (l:list A) :=
 (List.fold_right (fun t acc => f t \u acc) {}) l. *)



Definition index := nat.



Inductive typ : Set :=  

 | typ_base : typ 

 | typ_arrow (T1:typ) (T2:typ) .



Inductive exp : Set :=  

 | var_b (_:nat) 

 | var_f (x:var) 

 | abs (e:exp) 

 | app (e1:exp) (e2:exp) .



Definition ctx : Set := list ( atom * typ ).



Fixpoint open_exp_wrt_exp_rec (k:nat) (e_5:exp) (e__6:exp) {struct e__6}: exp :=

  match e__6 with

  | (var_b nat) =>

      match lt_eq_lt_dec nat k with

        | inleft (left _) => var_b nat

        | inleft (right _) => e_5

        | inright _ => var_b (nat - 1)

      end

  | (var_f x) => var_f x

  | (abs e) => abs (open_exp_wrt_exp_rec (S k) e_5 e)

  | (app e1 e2) => app (open_exp_wrt_exp_rec k e_5 e1) (open_exp_wrt_exp_rec k e_5 e2)

end.



Definition open_exp_wrt_exp e_5 e__6 := open_exp_wrt_exp_rec 0 e__6 e_5.



Inductive lc_exp : exp -> Prop :=    

 | lc_var_f : forall (x:var),

     (lc_exp (var_f x))

 | lc_abs : forall (e:exp),

      ( forall x , lc_exp  ( open_exp_wrt_exp e (var_f x) )  )  ->

     (lc_exp (abs e))

 | lc_app : forall (e1 e2:exp),

     (lc_exp e1) ->

     (lc_exp e2) ->

     (lc_exp (app e1 e2)).



Fixpoint fv_exp (e_5:exp) : vars :=

  match e_5 with

  | (var_b nat) => {}

  | (var_f x) => {{x}}

  | (abs e) => (fv_exp e)

  | (app e1 e2) => (fv_exp e1) \u (fv_exp e2)

end.



Fixpoint subst_exp (e_5:exp) (x5:var) (e__6:exp) {struct e__6} : exp :=

  match e__6 with

  | (var_b nat) => var_b nat

  | (var_f x) => (if eq_var x x5 then e_5 else (var_f x))

  | (abs e) => abs (subst_exp e_5 x5 e)

  | (app e1 e2) => app (subst_exp e_5 x5 e1) (subst_exp e_5 x5 e2)

end.



Definition is_value (e : exp) : Prop :=

  match e with

  | abs _   => True

  | _       => False

  end.



Module StlcNotations.

Notation "[ z ~> u ] e" := (subst_exp u z e) (at level 0).

Notation open e1 e2     := (open_exp_wrt_exp e1 e2).

End StlcNotations.



Inductive typing : ctx -> exp -> typ -> Prop :=    

 | typing_var : forall (G:ctx) (x:var) (T:typ),

      uniq  G  ->

      binds  x T G  ->

     typing G (var_f x) T

 | typing_abs : forall (L:vars) (G:ctx) (e:exp) (T1 T2:typ),

      ( forall x , x \notin  L  -> typing  (( x ~ T1 )++ G )   ( open_exp_wrt_exp e (var_f x) )  T2 )  ->

     typing G (abs e) (typ_arrow T1 T2)

 | typing_app : forall (G:ctx) (e1 e2:exp) (T2 T1:typ),

     typing G e1 (typ_arrow T1 T2) ->

     typing G e2 T1 ->

     typing G (app e1 e2) T2.



Inductive step : exp -> exp -> Prop :=    

 | step_beta : forall (e1 e2:exp),

     lc_exp (abs e1) ->

     lc_exp e2 ->

     step (app  ( (abs e1) )  e2)  (open_exp_wrt_exp  e1 e2 )

 | step_app : forall (e1 e2 e1':exp),

     lc_exp e2 ->

     step e1 e1' ->

     step (app e1 e2) (app e1' e2).



Hint Constructors typing step lc_exp.

