

Require Import Decidable DecidableTypeEx FSetFacts Setoid.



Module WDecide_fun (E : DecidableType)(Import M : WSfun E).

 Module F :=  FSetFacts.WFacts_fun E M.



  Module FSetLogicalFacts.

    Export Decidable.

    Export Setoid.



    Tactic Notation "fold" "any" "not" :=

      repeat (

        match goal with

        | H: context [?P -> False] |- _ =>

          fold (~ P) in H

        | |- context [?P -> False] =>

          fold (~ P)

        end).



    Ltac or_not_l_iff P Q tac :=

      (rewrite (or_not_l_iff_1 P Q) by tac) ||

      (rewrite (or_not_l_iff_2 P Q) by tac).



    Ltac or_not_r_iff P Q tac :=

      (rewrite (or_not_r_iff_1 P Q) by tac) ||

      (rewrite (or_not_r_iff_2 P Q) by tac).



    Ltac or_not_l_iff_in P Q H tac :=

      (rewrite (or_not_l_iff_1 P Q) in H by tac) ||

      (rewrite (or_not_l_iff_2 P Q) in H by tac).



    Ltac or_not_r_iff_in P Q H tac :=

      (rewrite (or_not_r_iff_1 P Q) in H by tac) ||

      (rewrite (or_not_r_iff_2 P Q) in H by tac).



    Tactic Notation "push" "not" "using" ident(db) :=

      let dec := solve_decidable using db in

      unfold not, iff;

      repeat (

        match goal with

        | |- context [True -> False] => rewrite not_true_iff

        | |- context [False -> False] => rewrite not_false_iff

        | |- context [(?P -> False) -> False] => rewrite (not_not_iff P) by dec

        | |- context [(?P -> False) -> (?Q -> False)] =>

            rewrite (contrapositive P Q) by dec

        | |- context [(?P -> False) \/ ?Q] => or_not_l_iff P Q dec

        | |- context [?P \/ (?Q -> False)] => or_not_r_iff P Q dec

        | |- context [(?P -> False) -> ?Q] => rewrite (imp_not_l P Q) by dec

        | |- context [?P \/ ?Q -> False] => rewrite (not_or_iff P Q)

        | |- context [?P /\ ?Q -> False] => rewrite (not_and_iff P Q)

        | |- context [(?P -> ?Q) -> False] => rewrite (not_imp_iff P Q) by dec

        end);

      fold any not.



    Tactic Notation "push" "not" :=

      push not using core.



    Tactic Notation

      "push" "not" "in" "*" "|-" "using" ident(db) :=

      let dec := solve_decidable using db in

      unfold not, iff in * |-;

      repeat (

        match goal with

        | H: context [True -> False] |- _ => rewrite not_true_iff in H

        | H: context [False -> False] |- _ => rewrite not_false_iff in H

        | H: context [(?P -> False) -> False] |- _ =>

          rewrite (not_not_iff P) in H by dec

        | H: context [(?P -> False) -> (?Q -> False)] |- _ =>

          rewrite (contrapositive P Q) in H by dec

        | H: context [(?P -> False) \/ ?Q] |- _ => or_not_l_iff_in P Q H dec

        | H: context [?P \/ (?Q -> False)] |- _ => or_not_r_iff_in P Q H dec

        | H: context [(?P -> False) -> ?Q] |- _ =>

          rewrite (imp_not_l P Q) in H by dec

        | H: context [?P \/ ?Q -> False] |- _ => rewrite (not_or_iff P Q) in H

        | H: context [?P /\ ?Q -> False] |- _ => rewrite (not_and_iff P Q) in H

        | H: context [(?P -> ?Q) -> False] |- _ =>

          rewrite (not_imp_iff P Q) in H by dec

        end);

      fold any not.



    Tactic Notation "push" "not" "in" "*" "|-"  :=

      push not in * |- using core.



    Tactic Notation "push" "not" "in" "*" "using" ident(db) :=

      push not using db; push not in * |- using db.

    Tactic Notation "push" "not" "in" "*" :=

      push not in * using core.



    Lemma test_push : forall P Q R : Prop,

      decidable P ->

      decidable Q ->

      (~ True) ->

      (~ False) ->

      (~ ~ P) ->

      (~ (P /\ Q) -> ~ R) ->

      ((P /\ Q) \/ ~ R) ->

      (~ (P /\ Q) \/ R) ->

      (R \/ ~ (P /\ Q)) ->

      (~ R \/ (P /\ Q)) ->

      (~ P -> R) ->

      (~ ((R -> P) \/ (Q -> R))) ->

      (~ (P /\ R)) ->

      (~ (P -> R)) ->

      True.

    Proof.

      intros. push not in *.

       

      tauto.

    Qed.



    Tactic Notation "pull" "not" "using" ident(db) :=

      let dec := solve_decidable using db in

      unfold not, iff;

      repeat (

        match goal with

        | |- context [True -> False] => rewrite not_true_iff

        | |- context [False -> False] => rewrite not_false_iff

        | |- context [(?P -> False) -> False] => rewrite (not_not_iff P) by dec

        | |- context [(?P -> False) -> (?Q -> False)] =>

          rewrite (contrapositive P Q) by dec

        | |- context [(?P -> False) \/ ?Q] => or_not_l_iff P Q dec

        | |- context [?P \/ (?Q -> False)] => or_not_r_iff P Q dec

        | |- context [(?P -> False) -> ?Q] => rewrite (imp_not_l P Q) by dec

        | |- context [(?P -> False) /\ (?Q -> False)] =>

          rewrite <- (not_or_iff P Q)

        | |- context [?P -> ?Q -> False] => rewrite <- (not_and_iff P Q)

        | |- context [?P /\ (?Q -> False)] => rewrite <- (not_imp_iff P Q) by dec

        | |- context [(?Q -> False) /\ ?P] =>

          rewrite <- (not_imp_rev_iff P Q) by dec

        end);

      fold any not.



    Tactic Notation "pull" "not" :=

      pull not using core.



    Tactic Notation

      "pull" "not" "in" "*" "|-" "using" ident(db) :=

      let dec := solve_decidable using db in

      unfold not, iff in * |-;

      repeat (

        match goal with

        | H: context [True -> False] |- _ => rewrite not_true_iff in H

        | H: context [False -> False] |- _ => rewrite not_false_iff in H

        | H: context [(?P -> False) -> False] |- _ =>

          rewrite (not_not_iff P) in H by dec

        | H: context [(?P -> False) -> (?Q -> False)] |- _ =>

          rewrite (contrapositive P Q) in H by dec

        | H: context [(?P -> False) \/ ?Q] |- _ => or_not_l_iff_in P Q H dec

        | H: context [?P \/ (?Q -> False)] |- _ => or_not_r_iff_in P Q H dec

        | H: context [(?P -> False) -> ?Q] |- _ =>

          rewrite (imp_not_l P Q) in H by dec

        | H: context [(?P -> False) /\ (?Q -> False)] |- _ =>

          rewrite <- (not_or_iff P Q) in H

        | H: context [?P -> ?Q -> False] |- _ =>

          rewrite <- (not_and_iff P Q) in H

        | H: context [?P /\ (?Q -> False)] |- _ =>

          rewrite <- (not_imp_iff P Q) in H by dec

        | H: context [(?Q -> False) /\ ?P] |- _ =>

          rewrite <- (not_imp_rev_iff P Q) in H by dec

        end);

      fold any not.



    Tactic Notation "pull" "not" "in" "*" "|-"  :=

      pull not in * |- using core.



    Tactic Notation "pull" "not" "in" "*" "using" ident(db) :=

      pull not using db; pull not in * |- using db.

    Tactic Notation "pull" "not" "in" "*" :=

      pull not in * using core.



    Lemma test_pull : forall P Q R : Prop,

      decidable P ->

      decidable Q ->

      (~ True) ->

      (~ False) ->

      (~ ~ P) ->

      (~ (P /\ Q) -> ~ R) ->

      ((P /\ Q) \/ ~ R) ->

      (~ (P /\ Q) \/ R) ->

      (R \/ ~ (P /\ Q)) ->

      (~ R \/ (P /\ Q)) ->

      (~ P -> R) ->

      (~ (R -> P) /\ ~ (Q -> R)) ->

      (~ P \/ ~ R) ->

      (P /\ ~ R) ->

      (~ R /\ P) ->

      True.

    Proof.

      intros. pull not in *. tauto.

    Qed.



  End FSetLogicalFacts.

  Import FSetLogicalFacts.



  Module FSetDecideAuxiliary.



    Tactic Notation

      "if" tactic(t)

      "then" tactic(t1)

      "else" tactic(t2) :=

      first [ t; first [ t1 | fail 2 ] | t2 ].



    Tactic Notation "prop" constr(P) "holds" "by" tactic(t) :=

      let H := fresh in

      assert P as H by t;

      clear H.



    Tactic Notation "assert" "new" constr(e) "by" tactic(t) :=

      match goal with

      | H: e |- _ => fail 1

      | _ => assert e by t

      end.



    Tactic Notation "subst" "++" :=

      repeat (

        match goal with

        | x : _ |- _ => subst x

        end);

      cbv zeta beta in *.



    Tactic Notation "decompose" "records" :=

      repeat (

        match goal with

        | H: _ |- _ => progress (decompose record H); clear H

        end).



    Inductive FSet_elt_Prop : Prop -> Prop :=

    | eq_Prop : forall (S : Type) (x y : S),

        FSet_elt_Prop (x = y)

    | eq_elt_prop : forall x y,

        FSet_elt_Prop (E.eq x y)

    | In_elt_prop : forall x s,

        FSet_elt_Prop (In x s)

    | True_elt_prop :

        FSet_elt_Prop True

    | False_elt_prop :

        FSet_elt_Prop False

    | conj_elt_prop : forall P Q,

        FSet_elt_Prop P ->

        FSet_elt_Prop Q ->

        FSet_elt_Prop (P /\ Q)

    | disj_elt_prop : forall P Q,

        FSet_elt_Prop P ->

        FSet_elt_Prop Q ->

        FSet_elt_Prop (P \/ Q)

    | impl_elt_prop : forall P Q,

        FSet_elt_Prop P ->

        FSet_elt_Prop Q ->

        FSet_elt_Prop (P -> Q)

    | not_elt_prop : forall P,

        FSet_elt_Prop P ->

        FSet_elt_Prop (~ P).



    Inductive FSet_Prop : Prop -> Prop :=

    | elt_FSet_Prop : forall P,

        FSet_elt_Prop P ->

        FSet_Prop P

    | Empty_FSet_Prop : forall s,

        FSet_Prop (Empty s)

    | Subset_FSet_Prop : forall s1 s2,

        FSet_Prop (Subset s1 s2)

    | Equal_FSet_Prop : forall s1 s2,

        FSet_Prop (Equal s1 s2).



    Hint Constructors FSet_elt_Prop FSet_Prop : FSet_Prop.

    Ltac discard_nonFSet :=

      repeat (

        match goal with

        | H : ?P |- _ =>

          if prop (FSet_Prop P) holds by

            (auto 100 with FSet_Prop)

          then fail

          else clear H

        end).



    Hint Rewrite

      F.empty_iff F.singleton_iff F.add_iff F.remove_iff

      F.union_iff F.inter_iff F.diff_iff

    : set_simpl.



    Lemma dec_In : forall x s,

      decidable (In x s).

    Proof.

      red; intros; generalize (F.mem_iff s x); case (mem x s); intuition.

    Qed.



    Lemma dec_eq : forall (x y : E.t),

      decidable (E.eq x y).

    Proof.

      red; intros x y; destruct (E.eq_dec x y); auto.

    Qed.



    Hint Resolve dec_In dec_eq : FSet_decidability.



    Ltac change_to_E_t :=

      repeat (

        match goal with

        | H : ?T |- _ =>

          progress (change T with E.t in H);

          repeat (

            match goal with

            | J : _ |- _ => progress (change T with E.t in J)

            | |- _ => progress (change T with E.t)

            end )

        | H : forall x : ?T, _ |- _ =>

          progress (change T with E.t in H);

          repeat (

            match goal with

            | J : _ |- _ => progress (change T with E.t in J)

            | |- _ => progress (change T with E.t)

            end )

       end).



    Ltac Logic_eq_to_E_eq :=

      repeat (

        match goal with

        | H: _ |- _ =>

          progress (change (@Logic.eq E.t) with E.eq in H)

        | |- _ =>

          progress (change (@Logic.eq E.t) with E.eq)

        end).



    Ltac E_eq_to_Logic_eq :=

      repeat (

        match goal with

        | H: _ |- _ =>

          progress (change E.eq with (@Logic.eq E.t) in H)

        | |- _ =>

          progress (change E.eq with (@Logic.eq E.t))

        end).



    Ltac substFSet :=

      repeat (

        match goal with

        | H: E.eq ?x ?y |- _ => rewrite H in *; clear H

        end).



    Ltac assert_decidability :=

      
      repeat (

        match goal with

        | H: context [~ E.eq ?x ?y] |- _ =>

          assert new (E.eq x y \/ ~ E.eq x y) by (apply dec_eq)

        | H: context [~ In ?x ?s] |- _ =>

          assert new (In x s \/ ~ In x s) by (apply dec_In)

        | |- context [~ E.eq ?x ?y] =>

          assert new (E.eq x y \/ ~ E.eq x y) by (apply dec_eq)

        | |- context [~ In ?x ?s] =>

          assert new (In x s \/ ~ In x s) by (apply dec_In)

        end);

      
      repeat (

        match goal with

        | _: ~ ?P, H : ?P \/ ~ ?P |- _ => clear H

        end).



    Ltac inst_FSet_hypotheses :=

      repeat (

        match goal with

        | H : forall a : E.t, _,

          _ : context [ In ?x _ ] |- _ =>

          let P := type of (H x) in

          assert new P by (exact (H x))

        | H : forall a : E.t, _

          |- context [ In ?x _ ] =>

          let P := type of (H x) in

          assert new P by (exact (H x))

        | H : forall a : E.t, _,

          _ : context [ E.eq ?x _ ] |- _ =>

          let P := type of (H x) in

          assert new P by (exact (H x))

        | H : forall a : E.t, _

          |- context [ E.eq ?x _ ] =>

          let P := type of (H x) in

          assert new P by (exact (H x))

        | H : forall a : E.t, _,

          _ : context [ E.eq _ ?x ] |- _ =>

          let P := type of (H x) in

          assert new P by (exact (H x))

        | H : forall a : E.t, _

          |- context [ E.eq _ ?x ] =>

          let P := type of (H x) in

          assert new P by (exact (H x))

        end);

      repeat (

        match goal with

        | H : forall a : E.t, _ |- _ =>

          clear H

        end).



    Hint Resolve E.eq_refl : FSet_Auto.

    
    Ltac fsetdec_rec :=

      auto with FSet_Auto;

      subst++;

      try (match goal with

      | H: E.eq ?x ?x -> False |- _ => destruct H

      end);

      (reflexivity ||

      contradiction ||

      (progress substFSet; intuition fsetdec_rec)).



    Ltac fsetdec_body :=

      inst_FSet_hypotheses;

      autorewrite with set_simpl in *;

      push not in * using FSet_decidability;

      substFSet;

      assert_decidability;

      auto with FSet_Auto;

      (intuition fsetdec_rec) ||

      fail 1

        "because the goal is beyond the scope of this tactic".



  End FSetDecideAuxiliary.

  Import FSetDecideAuxiliary.



  Ltac fsetdec :=

    

    unfold iff in *;

    
    fold any not; intros;

    
    decompose records;

    discard_nonFSet;

    
    unfold Empty, Subset, Equal in *; intros;



    autorewrite with set_simpl in *;



    change_to_E_t; E_eq_to_Logic_eq; subst++; Logic_eq_to_E_eq;

    
    pull not using FSet_decidability;

    unfold not in *;

    match goal with

    | H: (In ?x ?r) -> False |- (In ?x ?s) -> False =>

      contradict H; fsetdec_body

    | H: (In ?x ?r) -> False |- (E.eq ?x ?y) -> False =>

      contradict H; fsetdec_body

    | H: (In ?x ?r) -> False |- (E.eq ?y ?x) -> False =>

      contradict H; fsetdec_body

    | H: ?P -> False |- ?Q -> False =>

      if prop (FSet_elt_Prop P) holds by

        (auto 100 with FSet_Prop)

      then (contradict H; fsetdec_body)

      else fsetdec_body

    | |- _ =>

      fsetdec_body

    end.



  Module FSetDecideTestCases.



    Lemma test_eq_trans_1 : forall x y z s,

      E.eq x y ->

      ~ ~ E.eq z y ->

      In x s ->

      In z s.

    Proof. fsetdec. Qed.



    Lemma test_eq_trans_2 : forall x y z r s,

      In x (singleton y) ->

      ~ In z r ->

      ~ ~ In z (add y r) ->

      In x s ->

      In z s.

    Proof. fsetdec. Qed.



    Lemma test_eq_neq_trans_1 : forall w x y z s,

      E.eq x w ->

      ~ ~ E.eq x y ->

      ~ E.eq y z ->

      In w s ->

      In w (remove z s).

    Proof. fsetdec. Qed.



    Lemma test_eq_neq_trans_2 : forall w x y z r1 r2 s,

      In x (singleton w) ->

      ~ In x r1 ->

      In x (add y r1) ->

      In y r2 ->

      In y (remove z r2) ->

      In w s ->

      In w (remove z s).

    Proof. fsetdec. Qed.



    Lemma test_In_singleton : forall x,

      In x (singleton x).

    Proof. fsetdec. Qed.



    Lemma test_add_In : forall x y s,

      In x (add y s) ->

      ~ E.eq x y ->

      In x s.

    Proof. fsetdec. Qed.



    Lemma test_Subset_add_remove : forall x s,

      s [<=] (add x (remove x s)).

    Proof. fsetdec. Qed.



    Lemma test_eq_disjunction : forall w x y z,

      In w (add x (add y (singleton z))) ->

      E.eq w x \/ E.eq w y \/ E.eq w z.

    Proof. fsetdec. Qed.



    Lemma test_not_In_disj : forall x y s1 s2 s3 s4,

      ~ In x (union s1 (union s2 (union s3 (add y s4)))) ->

      ~ (In x s1 \/ In x s4 \/ E.eq y x).

    Proof. fsetdec. Qed.



    Lemma test_not_In_conj : forall x y s1 s2 s3 s4,

      ~ In x (union s1 (union s2 (union s3 (add y s4)))) ->

      ~ In x s1 /\ ~ In x s4 /\ ~ E.eq y x.

    Proof. fsetdec. Qed.



    Lemma test_iff_conj : forall a x s s',

    (In a s' <-> E.eq x a \/ In a s) ->

    (In a s' <-> In a (add x s)).

    Proof. fsetdec. Qed.



    Lemma test_set_ops_1 : forall x q r s,

      (singleton x) [<=] s ->

      Empty (union q r) ->

      Empty (inter (diff s q) (diff s r)) ->

      ~ In x s.

    Proof. fsetdec. Qed.



    Lemma eq_chain_test : forall x1 x2 x3 x4 s1 s2 s3 s4,

      Empty s1 ->

      In x2 (add x1 s1) ->

      In x3 s2 ->

      ~ In x3 (remove x2 s2) ->

      ~ In x4 s3 ->

      In x4 (add x3 s3) ->

      In x1 s4 ->

      Subset (add x4 s4) s4.

    Proof. fsetdec. Qed.



    Lemma test_too_complex : forall x y z r s,

      E.eq x y ->

      (In x (singleton y) -> r [<=] s) ->

      In z r ->

      In z s.

    Proof.

      

      intros until s; intros Heq H Hr; lapply H; fsetdec.

    Qed.



    Lemma function_test_1 :

      forall (f : t -> t),

      forall (g : elt -> elt),

      forall (s1 s2 : t),

      forall (x1 x2 : elt),

      Equal s1 (f s2) ->

      E.eq x1 (g (g x2)) ->

      In x1 s1 ->

      In (g (g x2)) (f s2).

    Proof. fsetdec. Qed.



    Lemma function_test_2 :

      forall (f : t -> t),

      forall (g : elt -> elt),

      forall (s1 s2 : t),

      forall (x1 x2 : elt),

      Equal s1 (f s2) ->

      E.eq x1 (g x2) ->

      In x1 s1 ->

      g x2 = g (g x2) ->

      In (g (g x2)) (f s2).

    Proof.

      

      intros until 3. intros g_eq. rewrite <- g_eq. fsetdec.

    Qed.



    Lemma test_baydemir :

      forall (f : t -> t),

      forall (s : t),

      forall (x y : elt),

      In x (add y (f s)) ->

      ~ E.eq x y ->

      In x (f s).

    Proof.

      fsetdec.

    Qed.



    Lemma test_baydemir_2 :

      forall (x : elt) (s : t),

      Subset (inter (singleton x) s) empty ->

      ~ In x s.

    Proof. fsetdec. Qed.



    Lemma test_baydemir_3 :

      forall (x y : elt) (s : t),

      ~ In x (add y s) ->

      x = y ->

      False.

    Proof. fsetdec. Qed.



    Lemma test_baydemir_4 :

      forall (x : elt) (s : t),

      Equal (inter (add x empty) s) empty ->

      ~ In x s.

    Proof. fsetdec. Qed.



    Lemma test_sweirich :

      forall (x : elt) (s : t),

        In x s -> Subset (singleton x) s.

    Proof. fsetdec. Qed.



  End FSetDecideTestCases.



End WDecide_fun.



Require Import CoqFSetInterface.
(* CoqFSetInterface:
Require Export Bool OrderedType DecidableType.
Set Implicit Arguments.
Unset Strict Implicit.

Module Type WSfun (E : DecidableType).

  Definition elt := E.t.

  Parameter t : Type. 

  Parameter In : E.t -> t -> Prop.
  Definition Equal s s' := forall a : E.t, In a s <-> In a s'.
  Definition Subset s s' := forall a : E.t, In a s -> In a s'.
  Definition Empty s := forall a : E.t, ~ In a s.
  Definition For_all (P : E.t -> Prop) s := forall x, In x s -> P x.
  Definition Exists (P : E.t -> Prop) s := exists x, In x s /\ P x.

  Notation "s  [=]  t" := (Equal s t) (at level 70, no associativity).
  Notation "s  [<=]  t" := (Subset s t) (at level 70, no associativity).

  Parameter empty : t.
  
  Parameter is_empty : t -> bool.
  
  Parameter mem : E.t -> t -> bool.
  
  Parameter add : E.t -> t -> t.
    Parameter singleton : E.t -> t.
  
  Parameter remove : E.t -> t -> t.
    Parameter union : t -> t -> t.
  
  Parameter inter : t -> t -> t.
  
  Parameter diff : t -> t -> t.
  
  Definition eq : t -> t -> Prop := Equal.

  Parameter eq_dec : forall s s', { eq s s' } + { ~ eq s s' }.

  Parameter equal : t -> t -> bool.
    Parameter subset : t -> t -> bool.
    Parameter fold : forall A : Type, (E.t -> A -> A) -> t -> A -> A.
    Parameter for_all : (E.t -> bool) -> t -> bool.
    Parameter exists_ : (E.t -> bool) -> t -> bool.
    Parameter filter : (E.t -> bool) -> t -> t.
    Parameter partition : (E.t -> bool) -> t -> t * t.
    Parameter cardinal : t -> nat.
  
  Parameter elements : t -> list E.t.
  
  Parameter choose : t -> option E.t.
    Section Spec.

  Variable s s' s'': t.
  Variable x y : E.t.

  Parameter In_1 : E.eq x y -> In x s -> In y s.

  Parameter eq_refl : eq s s.
  Parameter eq_sym : eq s s' -> eq s' s.
  Parameter eq_trans : eq s s' -> eq s' s'' -> eq s s''.

  Parameter mem_1 : In x s -> mem x s = true.
  Parameter mem_2 : mem x s = true -> In x s.

  Parameter equal_1 : Equal s s' -> equal s s' = true.
  Parameter equal_2 : equal s s' = true -> Equal s s'.

  Parameter subset_1 : Subset s s' -> subset s s' = true.
  Parameter subset_2 : subset s s' = true -> Subset s s'.

  Parameter empty_1 : Empty empty.

  Parameter is_empty_1 : Empty s -> is_empty s = true.
  Parameter is_empty_2 : is_empty s = true -> Empty s.

  Parameter add_1 : E.eq x y -> In y (add x s).
  Parameter add_2 : In y s -> In y (add x s).
  Parameter add_3 : ~ E.eq x y -> In y (add x s) -> In y s.

  Parameter remove_1 : E.eq x y -> ~ In y (remove x s).
  Parameter remove_2 : ~ E.eq x y -> In y s -> In y (remove x s).
  Parameter remove_3 : In y (remove x s) -> In y s.

  Parameter singleton_1 : In y (singleton x) -> E.eq x y.
  Parameter singleton_2 : E.eq x y -> In y (singleton x).

  Parameter union_1 : In x (union s s') -> In x s \/ In x s'.
  Parameter union_2 : In x s -> In x (union s s').
  Parameter union_3 : In x s' -> In x (union s s').

  Parameter inter_1 : In x (inter s s') -> In x s.
  Parameter inter_2 : In x (inter s s') -> In x s'.
  Parameter inter_3 : In x s -> In x s' -> In x (inter s s').

  Parameter diff_1 : In x (diff s s') -> In x s.
  Parameter diff_2 : In x (diff s s') -> ~ In x s'.
  Parameter diff_3 : In x s -> ~ In x s' -> In x (diff s s').

  Parameter fold_1 : forall (A : Type) (i : A) (f : E.t -> A -> A),
      fold f s i = fold_left (fun a e => f e a) (elements s) i.

  Parameter cardinal_1 : cardinal s = length (elements s).

  Section Filter.

  Variable f : E.t -> bool.

  Parameter filter_1 : compat_bool E.eq f -> In x (filter f s) -> In x s.
  Parameter filter_2 : compat_bool E.eq f -> In x (filter f s) -> f x = true.
  Parameter filter_3 :
      compat_bool E.eq f -> In x s -> f x = true -> In x (filter f s).

  Parameter for_all_1 :
      compat_bool E.eq f ->
      For_all (fun x => f x = true) s -> for_all f s = true.
  Parameter for_all_2 :
      compat_bool E.eq f ->
      for_all f s = true -> For_all (fun x => f x = true) s.

  Parameter exists_1 :
      compat_bool E.eq f ->
      Exists (fun x => f x = true) s -> exists_ f s = true.
  Parameter exists_2 :
      compat_bool E.eq f ->
      exists_ f s = true -> Exists (fun x => f x = true) s.

  Parameter partition_1 :
      compat_bool E.eq f -> Equal (fst (partition f s)) (filter f s).
  Parameter partition_2 :
      compat_bool E.eq f ->
      Equal (snd (partition f s)) (filter (fun x => negb (f x)) s).

  End Filter.

  Parameter elements_1 : In x s -> InA E.eq x (elements s).
  Parameter elements_2 : InA E.eq x (elements s) -> In x s.
    Parameter elements_3w : NoDupA E.eq (elements s).

  Parameter choose_1 : choose s = Some x -> In x s.
  Parameter choose_2 : choose s = None -> Empty s.

  End Spec.

  Hint Resolve mem_1 equal_1 subset_1 empty_1
    is_empty_1 choose_1 choose_2 add_1 add_2 remove_1
    remove_2 singleton_2 union_1 union_2 union_3
    inter_3 diff_3 fold_1 filter_3 for_all_1 exists_1
    partition_1 partition_2 elements_1 elements_3w
    : set.
  Hint Immediate In_1 mem_2 equal_2 subset_2 is_empty_2 add_3
    remove_3 singleton_1 inter_1 inter_2 diff_1 diff_2
    filter_1 filter_2 for_all_2 exists_2 elements_2
    : set.

End WSfun.

Module Type WS.
  Declare Module E : DecidableType.
  Include WSfun E.
End WS.

Module Type Sfun (E : OrderedType).
  Include WSfun E.

  Parameter lt : t -> t -> Prop.
  Parameter compare : forall s s' : t, Compare lt eq s s'.
    Parameter min_elt : t -> option E.t.
    Parameter max_elt : t -> option E.t.
    Section Spec.

  Variable s s' s'' : t.
  Variable x y : E.t.

  Parameter lt_trans : lt s s' -> lt s' s'' -> lt s s''.
  Parameter lt_not_eq : lt s s' -> ~ eq s s'.

  Parameter elements_3 : sort E.lt (elements s).

  Parameter min_elt_1 : min_elt s = Some x -> In x s.
  Parameter min_elt_2 : min_elt s = Some x -> In y s -> ~ E.lt y x.
  Parameter min_elt_3 : min_elt s = None -> Empty s.

  Parameter max_elt_1 : max_elt s = Some x -> In x s.
  Parameter max_elt_2 : max_elt s = Some x -> In y s -> ~ E.lt x y.
  Parameter max_elt_3 : max_elt s = None -> Empty s.

  Parameter choose_3 : choose s = Some x -> choose s' = Some y ->
    Equal s s' -> E.eq x y.

  End Spec.

  Hint Resolve elements_3 : set.
  Hint Immediate
    min_elt_1 min_elt_2 min_elt_3 max_elt_1 max_elt_2 max_elt_3 : set.

End Sfun.

Module Type S.
  Declare Module E : OrderedType.
  Include Sfun E.
End S.

Module Type Sdep.

  Declare Module E : OrderedType.
  Definition elt := E.t.

  Parameter t : Type.

  Parameter In : E.t -> t -> Prop.
  Definition Equal s s' := forall a : E.t, In a s <-> In a s'.
  Definition Subset s s' := forall a : E.t, In a s -> In a s'.
  Definition Add x s s' := forall y, In y s' <-> E.eq x y \/ In y s.
  Definition Empty s := forall a : E.t, ~ In a s.
  Definition For_all (P : E.t -> Prop) s := forall x, In x s -> P x.
  Definition Exists (P : E.t -> Prop) s := exists x, In x s /\ P x.

  Notation "s [=] t" := (Equal s t) (at level 70, no associativity).

  Definition eq : t -> t -> Prop := Equal.
  Parameter lt : t -> t -> Prop.
  Parameter compare : forall s s' : t, Compare lt eq s s'.

  Parameter eq_refl : forall s : t, eq s s.
  Parameter eq_sym : forall s s' : t, eq s s' -> eq s' s.
  Parameter eq_trans : forall s s' s'' : t, eq s s' -> eq s' s'' -> eq s s''.
  Parameter lt_trans : forall s s' s'' : t, lt s s' -> lt s' s'' -> lt s s''.
  Parameter lt_not_eq : forall s s' : t, lt s s' -> ~ eq s s'.

  Parameter eq_In : forall (s : t) (x y : E.t), E.eq x y -> In x s -> In y s.

  Parameter empty : {s : t | Empty s}.

  Parameter is_empty : forall s : t, {Empty s} + {~ Empty s}.

  Parameter mem : forall (x : E.t) (s : t), {In x s} + {~ In x s}.

  Parameter add : forall (x : E.t) (s : t), {s' : t | Add x s s'}.

  Parameter
    singleton : forall x : E.t, {s : t | forall y : E.t, In y s <-> E.eq x y}.

  Parameter
    remove :
      forall (x : E.t) (s : t),
      {s' : t | forall y : E.t, In y s' <-> ~ E.eq x y /\ In y s}.

  Parameter
    union :
      forall s s' : t,
      {s'' : t | forall x : E.t, In x s'' <-> In x s \/ In x s'}.

  Parameter
    inter :
      forall s s' : t,
      {s'' : t | forall x : E.t, In x s'' <-> In x s /\ In x s'}.

  Parameter
    diff :
      forall s s' : t,
      {s'' : t | forall x : E.t, In x s'' <-> In x s /\ ~ In x s'}.

  Parameter equal : forall s s' : t, {s[=]s'} + {~ s[=]s'}.

  Parameter subset : forall s s' : t, {Subset s s'} + {~ Subset s s'}.

  Parameter
    filter :
      forall (P : E.t -> Prop) (Pdec : forall x : E.t, {P x} + {~ P x})
        (s : t),
      {s' : t | compat_P E.eq P -> forall x : E.t, In x s' <-> In x s /\ P x}.

  Parameter
    for_all :
      forall (P : E.t -> Prop) (Pdec : forall x : E.t, {P x} + {~ P x})
        (s : t),
      {compat_P E.eq P -> For_all P s} + {compat_P E.eq P -> ~ For_all P s}.

  Parameter
    exists_ :
      forall (P : E.t -> Prop) (Pdec : forall x : E.t, {P x} + {~ P x})
        (s : t),
      {compat_P E.eq P -> Exists P s} + {compat_P E.eq P -> ~ Exists P s}.

  Parameter
    partition :
      forall (P : E.t -> Prop) (Pdec : forall x : E.t, {P x} + {~ P x})
        (s : t),
      {partition : t * t |
      let (s1, s2) := partition in
      compat_P E.eq P ->
      For_all P s1 /\
      For_all (fun x => ~ P x) s2 /\
      (forall x : E.t, In x s <-> In x s1 \/ In x s2)}.

  Parameter
    elements :
      forall s : t,
      {l : list E.t |
      sort E.lt l /\ (forall x : E.t, In x s <-> InA E.eq x l)}.

  Parameter
    fold :
      forall (A : Type) (f : E.t -> A -> A) (s : t) (i : A),
      {r : A | let (l,_) := elements s in
                  r = fold_left (fun a e => f e a) l i}.

  Parameter
    cardinal :
      forall s : t,
      {r : nat | let (l,_) := elements s in r = length l }.

  Parameter
    min_elt :
      forall s : t,
      {x : E.t | In x s /\ For_all (fun y => ~ E.lt y x) s} + {Empty s}.

  Parameter
    max_elt :
      forall s : t,
      {x : E.t | In x s /\ For_all (fun y => ~ E.lt x y) s} + {Empty s}.

  Parameter choose : forall s : t, {x : E.t | In x s} + {Empty s}.

  Parameter choose_equal : forall s s', Equal s s' ->
     match choose s, choose s' with
       | inleft (exist _ x _), inleft (exist _ x' _) => E.eq x x'
       | inright _, inright _  => True
       | _, _  => False
     end.

End Sdep. *)



Module WDecide (M:WS) := !WDecide_fun M.E M.

Module Decide := WDecide.

