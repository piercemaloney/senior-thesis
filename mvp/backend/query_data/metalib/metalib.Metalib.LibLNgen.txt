

Require Export Metalib.LibDefaultSimp.

Require Import Metalib.Metatheory.
(* Metalib.Metatheory:
Require Export Coq.Arith.Arith.
Require Export Coq.FSets.FSets.
Require Export Coq.Lists.List.

Require Export Metalib.AssocList.
Require Export Metalib.CoqListFacts.
Require Export Metalib.LibTactics.
Require Export Metalib.MetatheoryAtom.

Notation "E [=] F" :=
  (AtomSetImpl.Equal E F)
  (at level 70, no associativity)
  : set_scope.

Notation "E [<=] F" :=
  (AtomSetImpl.Subset E F)
  (at level 70, no associativity)
  : set_scope.

Notation "{}" :=
  (AtomSetImpl.empty)
  : set_scope.

Notation "{{  x  }}" :=
  (AtomSetImpl.singleton x)
  : set_scope.

Notation "x `in` E" :=
  (AtomSetImpl.In x E)
  (at level 70)
  : set_hs_scope.

Notation "x `notin` E" :=
  (~ AtomSetImpl.In x E)
  (at level 70)
  : set_hs_scope.

Notation "E `union` F" :=
  (AtomSetImpl.union E F)
  (at level 65, right associativity, format "E  `union`  '/' F")
  : set_hs_scope.

Notation add := AtomSetImpl.add.
Notation empty := AtomSetImpl.empty.
Notation remove := AtomSetImpl.remove.
Notation singleton := AtomSetImpl.singleton.
Notation union := AtomSetImpl.union.

Open Scope set_scope.
Open Scope set_hs_scope.

Module Export EnvImpl := AssocList.Make Atom AtomSetImpl.

Ltac simpl_env :=
  simpl_alist.

Tactic Notation "simpl_env" "in" hyp(H) :=
  simpl_alist in H.

Tactic Notation "simpl_env" "in" "*" :=
  simpl_alist in *.

Tactic Notation "rewrite_env" constr(E) :=
  rewrite_alist E.

Tactic Notation "rewrite_env" constr(E) "in" hyp(H) :=
  rewrite_alist E in H.

Tactic Notation "env" "induction" ident(E) :=
  alist induction E.

Tactic Notation "env" "induction" ident(E) "as" simple_intropattern(P) :=
  alist induction E as P.

Notation "[ x ]" := (EnvImpl.one x) : env_scope.

Open Scope env_scope.

Tactic Notation
  "pick" "fresh" ident(atom_name)
  "excluding" constr(L)
  "and" "apply" constr(H)
  :=
    first [apply (@H L) | eapply (@H L)];
      match goal with
        | |- forall _, _ `notin` _ -> _ =>
          let Fr := fresh "Fr" in intros atom_name Fr
        | |- forall _, _ `notin` _ -> _ =>
          fail 1 "because" atom_name "is already defined"
        | _ =>
          idtac
      end.

Tactic Notation
  "pick" "fresh" ident(atom_name)
  "and" "apply" constr(H)
  :=
    let L := gather_atoms in
    let L := beautify_fset L in
    pick fresh atom_name excluding L and apply H.

Notation uniq_one := uniq_one_1.
Notation uniq_cons := uniq_cons_3.
Notation uniq_app := uniq_app_4.
Notation uniq_map := uniq_map_2.

Notation binds_one := binds_one_3.
Notation binds_cons := binds_cons_3.
Notation binds_app_l := binds_app_2.
Notation binds_app_r := binds_app_3.
Notation binds_map := binds_map_2.

Notation notin_empty := notin_empty_1.
Notation notin_add := notin_add_3.
Notation notin_singleton := notin_singleton_2.
Notation notin_union := notin_union_3.

Ltac hint_extern_solve_notin :=
  try eassumption;
  autorewrite with rewr_dom in *;
  destruct_notin;
  repeat first [ apply notin_union_3
               | apply notin_add_3
               | apply notin_singleton_2
               | apply notin_empty_1
               ];
  try tauto.

Hint Extern 1 (_ <> _ :> _) => hint_extern_solve_notin.

Hint Extern 1 (_ `notin` _) => hint_extern_solve_notin.

Hint Resolve
  AtomSetImpl.add_1 AtomSetImpl.add_2 AtomSetImpl.remove_1
  AtomSetImpl.remove_2 AtomSetImpl.singleton_2 AtomSetImpl.union_2
  AtomSetImpl.union_3 AtomSetImpl.inter_3 AtomSetImpl.diff_3.

Require Export Metalib.CoqEqDec.

Notation " x  == y " := (eq_dec x y) (at level 70) : coqeqdec_scope.

Open Scope coqeqdec_scope.

Notation var := atom (only parsing).

Notation vars := atoms (only parsing).

Notation eq_var := eq_dec (only parsing).

Notation "x  ===  y" :=
  (x == y)
  (at level 70, only parsing)
  : coqeqdec_scope.

Notation "x \in s" :=
  (x `in` s)
  (at level 70, only parsing)
  : set_sl_scope.

Notation "x \notin s" :=
  (x `notin` s)
  (at level 70, only parsing)
  : set_sl_scope.

Notation "s \u t" :=
  (s `union` t)
  (at level 65, right associativity, only parsing)
  : set_sl_scope.

Open Scope set_sl_scope.

Ltac gather_vars_with F := gather_atoms_with.

Ltac pick_fresh_gen L Y := pick fresh Y for L.

Tactic Notation "auto" "*" := auto.

Ltac apply_fresh_base H gather_vars atom_name :=
  let L := gather_vars in
  let L := beautify_fset L in
  pick fresh x excluding L and apply H.

Set Implicit Arguments.
Definition union_map (A:Set) (f:A -> vars) (l:list A) :=
 (List.fold_right (fun t acc => f t \u acc) {}) l. *)

Require Import Omega.



Definition lt_ge_dec (n m : nat) : {n < m} + {n >= m} :=

  match Compare_dec.le_gt_dec m n with

    | left pf => right pf

    | right pf => left pf

  end.



Ltac generalize_wrt x :=

  repeat (progress (match goal with

    | J : _ |- _ => move J after x; generalize dependent J

    end)).



Ltac apply_mutual_ind ind :=

  let H := fresh in

  first [ 
 intros H; induction H using ind

        | intros ? H; induction H using ind

        | intros ? ? H; induction H using ind

        | intros ? ? ? H; induction H using ind

        | intros ? ? ? ? H; induction H using ind

        | intros ? ? ? ? ? H; induction H using ind

        | intros ? ? ? ? ? ? H; induction H using ind

        | intros ? ? ? ? ? ? ? H; induction H using ind

        | intros ? ? ? ? ? ? ? ? H; induction H using ind

        ].



Ltac rename_last_into H :=

  match goal with

    | J : _ |- _ => rename J into H

  end.



Ltac specialize_all x :=

  repeat (match goal with

            | H : _ |- _ => specialize (H x)

          end).



Lemma remove_union_distrib : forall (s1 s2 : atoms) (x : atom),

  remove x (union s1 s2) [=] union (remove x s1) (remove x s2).

Proof. fsetdec. Qed.



Lemma Equal_union_compat : forall (s1 s2 s3 s4 : atoms),

  s1 [=] s3 ->

  s2 [=] s4 ->

  union s1 s2 [=] union s3 s4.

Proof. fsetdec. Qed.



Lemma Subset_refl : forall (s : atoms),

  s [<=] s.

Proof. fsetdec. Qed.



Lemma Subset_empty_any : forall (s : atoms),

  empty [<=] s.

Proof. fsetdec. Qed.



Lemma Subset_union_compat : forall (s1 s2 s3 s4 : atoms),

  s1 [<=] s3 ->

  s2 [<=] s4 ->

  union s1 s2 [<=] union s3 s4.

Proof. fsetdec. Qed.



Lemma Subset_union_left : forall (s1 s2 s3 : atoms),

  s1 [<=] s2 ->

  s1 [<=] union s2 s3.

Proof. fsetdec. Qed.



Lemma Subset_union_right : forall (s1 s2 s3 : atoms),

  s1 [<=] s3 ->

  s1 [<=] union s2 s3.

Proof. fsetdec. Qed.



Lemma Subset_union_lngen_open_upper :

  forall (s1 s2 s3 s4 s5 : atoms),

  s1 [<=] union s3 s4 ->

  s2 [<=] union s3 s5 ->

  union s1 s2 [<=] union s3 (union s4 s5).

Proof. fsetdec. Qed.



Hint Resolve sym_eq : brute_force.



Hint Extern 5 (_ = _ :> nat) => omega : brute_force.

Hint Extern 5 (_ < _)        => omega : brute_force.

Hint Extern 5 (_ <= _)       => omega : brute_force.



Hint Rewrite @remove_union_distrib : lngen.



Hint Resolve @Equal_union_compat : lngen.

Hint Resolve @Subset_refl : lngen.

Hint Resolve @Subset_empty_any : lngen.

Hint Resolve @Subset_union_compat : lngen.

Hint Resolve @Subset_union_left : lngen.

Hint Resolve @Subset_union_right : lngen.

Hint Resolve @Subset_union_lngen_open_upper : lngen.

