

Require Import List.

Require Import syntax.
(* syntax:
Inductive ty : Set :=
  | nat_ty : ty 
  | bool_ty : ty 
  | arr : ty -> ty -> ty.   

Inductive vari : Set :=
    x : nat -> vari.

Inductive tm : Set :=
  | o : tm 
  | ttt : tm 
  | fff : tm 
  | abs : vari -> ty -> tm -> tm 
  | appl : tm -> tm -> tm 
  | cond : tm -> tm -> tm -> tm 
  | var : vari -> tm 
  | succ : tm -> tm 
  | prd : tm -> tm 
  | is_o : tm -> tm 
  | Fix : vari -> ty -> tm -> tm 
  | clos : tm -> vari -> ty -> tm -> tm. *)

Require Import environments.
(* environments:
Require Import syntax.

Require Import List.

Fixpoint member (A : Set) (b : A) (l : list A) {struct l} : Prop :=
  match l with
  | nil => False
  | a :: m => a = b \/ member A b m
  end.

Definition VT := (vari * ty)%type.
Definition ty_env := list VT.

Definition VTT := (VT * tm)%type.
Definition OS_env := list VTT.

Definition mapsto (indx : vari) (val : ty) (l : list VT) :=
  (fix F (l0 : list VT) : Prop :=
     match l0 with
     | nil => False
     | v :: l1 => IF fst v = indx :>vari then snd v = val :>ty else F l1
     end) l.
 
Inductive config : Set :=
    cfg : tm -> OS_env -> config.

Definition cfgexp (c : config) := let (e, A) return tm := c in e.

Definition cfgenv (c : config) := let (e, A) return OS_env := c in A.

Definition TE_Dom (H : ty_env) :=
  (fix F (l : list VT) : list vari :=
     match l with
     | nil => nil (A:=vari)
     | v :: l0 => cons (fst v) (F l0)
     end) H.
 
Definition OS_Dom (A : OS_env) :=
  (fix F (l : list VTT) : list vari :=
     match l with
     | nil => nil (A:=vari)
     | v :: l0 => cons (fst (fst v)) (F l0)
     end) A.
 
Definition OS_Dom_ty (A : OS_env) :=
  (fix F (l : list VTT) : list VT :=
     match l with
     | nil => nil (A:=VT)
     | v :: l0 => cons (fst v) (F l0)
     end) A. *)



Require Import utils.
(* utils:
Require Import syntax.

Definition valu (v : vari) :=
  match v return nat with
  | x n =>   n
  end.

Goal forall m n : nat, x m = x n :>vari -> m = n :>nat.
intros m n Q.  
replace m with (valu (x m)).
rewrite Q.
simpl in |- *; reflexivity.
simpl in |- *; reflexivity.
Save vari_nat.

Definition Rator_ty (t : ty) :=
  match t with
  | nat_ty => t
  | bool_ty => t
  | arr t0 _ => t0
  end.
Definition Rand_ty (t : ty) :=
  match t with
  | nat_ty => t
  | bool_ty => t
  | arr _ t0 => t0
  end.
Goal
forall s1 t1 s2 t2 : ty,
arr s1 t1 = arr s2 t2 :>ty -> s1 = s2 :>ty /\ t1 = t2 :>ty.
intros s1 t1 s2 t2 Q.
split.
change (Rator_ty (arr s1 t1) = Rator_ty (arr s2 t2) :>ty) in |- *.
apply (f_equal Rator_ty). assumption.
change (Rand_ty (arr s1 t1) = Rand_ty (arr s2 t2) :>ty) in |- *.
apply (f_equal Rand_ty); assumption.
Save subty_eq.

Definition is_nat (t : ty) :=
  match t with
  | nat_ty => True
  | bool_ty => False
  | arr _ _ => False
  end.
Definition is_bool (t : ty) :=
  match t with
  | nat_ty => False
  | bool_ty => True
  | arr _ _ => False
  end.
Definition is_arr (t : ty) :=
  match t with
  | nat_ty => False
  | bool_ty => False
  | arr _ _ => True
  end.

Goal nat_ty <> bool_ty :>ty.
red in |- *; intro H; change (is_nat bool_ty) in |- *; elim H; exact I.
Save nat_not_bool.

Goal forall t s : ty, nat_ty <> arr t s :>ty.
red in |- *; intros t s H; change (is_nat (arr t s)) in |- *; elim H; exact I.
Save nat_not_arr.

Goal forall t s : ty, bool_ty <> arr t s :>ty.
red in |- *; intros t s H; change (is_bool (arr t s)) in |- *; elim H;
 exact I.
Save bool_not_arr.

	Goal forall m n : nat, m = n \/ m <> n.

	simple induction m.
	simple induction n.
	left; reflexivity.
	intros; right; apply O_S.
	intros y H n; elim n.
	right; red in |- *; intro; apply (O_S y); symmetry  in |- *; assumption.
	intros y0 I.
	elim (H y0); intro E. 
	left; elim E; reflexivity.
	right; red in |- *; intro.
	apply E; apply eq_add_S; assumption.
	Save Xmidnat.

Goal forall v w : vari, v = w \/ v <> w.

simple induction v.
simple induction w.
intro. 
specialize (Xmidnat n n0).
simple induction 1.
intro eq; left; elim eq; reflexivity.
intro neq; right; red in |- *; intro; apply neq.
apply vari_nat; assumption.
Save Xmidvar.

Goal forall A B C : Prop, (IF A then B else C) -> A -> B.
unfold IF_then_else in |- *; simple induction 1.
simple induction 1; intros; assumption.
simple induction 1; intros; absurd A; assumption.
Save If_T.

Goal forall A B C : Prop, (IF A then B else C) -> ~ A -> C.
unfold IF_then_else in |- *; simple induction 1.
simple induction 1; intros; absurd A; assumption.
simple induction 1; intros; assumption.
Save If_F.

Goal forall A B C : Prop, A -> B -> IF A then B else C.
unfold IF_then_else in |- *; intros.
left; split; assumption.
Save T_If.

Goal forall A B C : Prop, ~ A -> C -> IF A then B else C.
unfold IF_then_else in |- *; intros.
right; split; assumption.
Save F_If.

Goal
forall A B C D : Prop,
(IF A then B else C) -> IF A then B else (IF A then D else C).

unfold IF_then_else in |- *; simple induction 1.
intro T; left; assumption.
intro F; right; elim F; intros; split.
assumption.
right; split; assumption.
Save IfA_IfAIfA.

Goal forall A B C D : Prop, A \/ D /\ C -> (D -> A \/ B) -> A \/ B /\ C.

intros A B C D A1 A2.
elim A1.
intro; left; assumption.
simple induction 1; intros DH CH.
specialize A2 with (1 := DH); induction A2.
left; assumption.
right; split; assumption.
Save AABC_ABC. *)



Goal

forall (v x : vari) (t s : ty) (HF H : ty_env),

v <> x -> mapsto v t (HF ++ H) -> mapsto v t (HF ++ (x, s) :: H). 



   simple induction HF; simpl in |- *.

   intros H neq M.

   apply F_If.

   red in |- *; intro; apply neq; symmetry  in |- *; assumption.

   assumption.

   simple induction a; simpl in |- *; intros a0 b y IH H0 neq If.

   specialize (Xmidvar a0 v); simple induction 1. intro T.

   specialize If_T with (1 := If) (2 := T); intro B.

   apply T_If; assumption.

   intro F.

   specialize If_F with (1 := If) (2 := F); intro M.

   apply F_If. assumption.

   apply IH; assumption.

Save Mp_nfvExt.



Goal

forall (v x : vari) (t s : ty) (HF H : ty_env),

v <> x -> mapsto v t (HF ++ (x, s) :: H) -> mapsto v t (HF ++ H).



   simple induction HF; simpl in |- *.

   intros H neq If.

   apply If_F with (x = v) (s = t).

   assumption.

   red in |- *; intro; apply neq; symmetry  in |- *; assumption.

   simple induction a; simpl in |- *; intros a0 b y IH H0 neq If.

   specialize (Xmidvar a0 v); simple induction 1. intro T.

   specialize If_T with (1 := If) (2 := T); intro B.

   apply T_If; assumption.

   intro F.

   specialize If_F with (1 := If) (2 := F); intro M.

   apply F_If. assumption.

   apply IH; assumption.

Save Mp_inv_nfvExt.



Goal

forall (x v : vari) (r s t : ty) (H HM H' : ty_env),

mapsto x t (H ++ (v, s) :: HM ++ H') ->

mapsto x t (H ++ (v, s) :: HM ++ (v, r) :: H').



   simple induction H; simpl in |- *.

   simple induction HM; simpl in |- *.  intros.

   apply IfA_IfAIfA.  assumption.

   simple induction a; simpl in |- *; intros.

   specialize (Xmidvar v x); simple induction 1.

   intro T.

   specialize If_T with (1 := H1) (2 := T); intro.

   apply T_If; assumption.

   intro F.

   specialize If_F with (1 := H1) (2 := F); intro I.

   apply F_If.

   assumption. 

   specialize (Xmidvar a0 x); simple induction 1.

   intro Q. 

   specialize If_T with (1 := I) (2 := Q); intro.

   apply T_If; assumption.

   intro nQ.

   specialize If_F with (1 := I) (2 := nQ); intro.

   apply F_If.  assumption.

   apply If_F with (v = x) (s = t).

   apply H0.

   specialize If_F with (1 := H1) (2 := F); intro I2.

   specialize If_F with (1 := I2) (2 := nQ); intro.

   apply F_If; assumption.

   assumption. 

   simple induction a; simpl in |- *; intros.

   specialize (Xmidvar a0 x); simple induction 1.

   intro T.

   specialize If_T with (1 := H1) (2 := T); intro.

   apply T_If; assumption.

   intro F.

   specialize If_F with (1 := H1) (2 := F); intro.

   apply F_If.  assumption.

   apply H0; assumption.

Save Mp_eqExt.



Goal

forall (v x y : vari) (r s t : ty) (HF HM H : ty_env),

v = x ->

mapsto y r (HF ++ (v, s) :: HM ++ (x, t) :: H) ->

mapsto y r (HF ++ (v, s) :: HM ++ H).



   simple induction HF; simpl in |- *. intros HM H Q A.

   specialize (Xmidvar v y); simple induction 1. intro T.

   specialize If_T with (1 := A) (2 := T); intro sr.

   apply T_If; assumption.

   intro F.

   specialize If_F with (1 := A) (2 := F); intro M.

   apply F_If. assumption.

   apply Mp_inv_nfvExt with x t. 

   elim Q; red in |- *; intro; apply F; symmetry  in |- *; assumption.

   assumption.

   simple induction a; simpl in |- *; intros a0 b y0 IH HM H0 Q If.

   specialize (Xmidvar a0 y); simple induction 1. intro T.

   specialize If_T with (1 := If) (2 := T); intro br.

   apply T_If; assumption.

   intro F.

   specialize If_F with (1 := If) (2 := F); intro M.

   apply F_If. assumption.

   apply IH; assumption.

Save Mp_inv_eqExt.



Goal

forall (v x y : vari) (r s t : ty) (H H' : ty_env),

x <> y ->

mapsto v r (H ++ (x, s) :: (y, t) :: H') ->

mapsto v r (H ++ (y, t) :: (x, s) :: H').



	simple induction H.

	simpl in |- *; intros H' neq If.

        specialize (Xmidvar y v); simple induction 1.

        intro T.

        apply T_If. assumption.

        apply If_T with (y = v) (mapsto v r H').

        apply If_F with (x = v) (s = r).

        assumption.

        elim T; assumption.

        assumption.

        intro F.

        apply F_If. assumption.

        specialize (Xmidvar x v); simple induction 1.

        intro TT.

	specialize If_T with (1 := If) (2 := TT); intro sr.

        apply T_If; assumption.

        intro FF.

        specialize If_F with (1 := If) (2 := FF); intro If2.

        specialize If_F with (1 := If2) (2 := F); intro M.

        apply F_If; assumption.

	simple induction a.

	simpl in |- *; intros a0 b y0 IH H' N A.

        specialize (Xmidvar a0 v); simple induction 1.

        intro T.

        specialize If_T with (1 := A) (2 := T); intro br.

        apply T_If; assumption.

        intro F.

        specialize If_F with (1 := A) (2 := F); intro M.

        apply F_If; assumption || apply IH; assumption.

Save Mp_swap.

