

Require Import syntax.
(* syntax:
Inductive ty : Set :=
  | nat_ty : ty 
  | bool_ty : ty 
  | arr : ty -> ty -> ty.   

Inductive vari : Set :=
    x : nat -> vari.

Inductive tm : Set :=
  | o : tm 
  | ttt : tm 
  | fff : tm 
  | abs : vari -> ty -> tm -> tm 
  | appl : tm -> tm -> tm 
  | cond : tm -> tm -> tm -> tm 
  | var : vari -> tm 
  | succ : tm -> tm 
  | prd : tm -> tm 
  | is_o : tm -> tm 
  | Fix : vari -> ty -> tm -> tm 
  | clos : tm -> vari -> ty -> tm -> tm. *)

Require Import utils.
(* utils:
Require Import syntax.

Definition valu (v : vari) :=
  match v return nat with
  | x n =>   n
  end.

Goal forall m n : nat, x m = x n :>vari -> m = n :>nat.
intros m n Q.  
replace m with (valu (x m)).
rewrite Q.
simpl in |- *; reflexivity.
simpl in |- *; reflexivity.
Save vari_nat.

Definition Rator_ty (t : ty) :=
  match t with
  | nat_ty => t
  | bool_ty => t
  | arr t0 _ => t0
  end.
Definition Rand_ty (t : ty) :=
  match t with
  | nat_ty => t
  | bool_ty => t
  | arr _ t0 => t0
  end.
Goal
forall s1 t1 s2 t2 : ty,
arr s1 t1 = arr s2 t2 :>ty -> s1 = s2 :>ty /\ t1 = t2 :>ty.
intros s1 t1 s2 t2 Q.
split.
change (Rator_ty (arr s1 t1) = Rator_ty (arr s2 t2) :>ty) in |- *.
apply (f_equal Rator_ty). assumption.
change (Rand_ty (arr s1 t1) = Rand_ty (arr s2 t2) :>ty) in |- *.
apply (f_equal Rand_ty); assumption.
Save subty_eq.

Definition is_nat (t : ty) :=
  match t with
  | nat_ty => True
  | bool_ty => False
  | arr _ _ => False
  end.
Definition is_bool (t : ty) :=
  match t with
  | nat_ty => False
  | bool_ty => True
  | arr _ _ => False
  end.
Definition is_arr (t : ty) :=
  match t with
  | nat_ty => False
  | bool_ty => False
  | arr _ _ => True
  end.

Goal nat_ty <> bool_ty :>ty.
red in |- *; intro H; change (is_nat bool_ty) in |- *; elim H; exact I.
Save nat_not_bool.

Goal forall t s : ty, nat_ty <> arr t s :>ty.
red in |- *; intros t s H; change (is_nat (arr t s)) in |- *; elim H; exact I.
Save nat_not_arr.

Goal forall t s : ty, bool_ty <> arr t s :>ty.
red in |- *; intros t s H; change (is_bool (arr t s)) in |- *; elim H;
 exact I.
Save bool_not_arr.

	Goal forall m n : nat, m = n \/ m <> n.

	simple induction m.
	simple induction n.
	left; reflexivity.
	intros; right; apply O_S.
	intros y H n; elim n.
	right; red in |- *; intro; apply (O_S y); symmetry  in |- *; assumption.
	intros y0 I.
	elim (H y0); intro E. 
	left; elim E; reflexivity.
	right; red in |- *; intro.
	apply E; apply eq_add_S; assumption.
	Save Xmidnat.

Goal forall v w : vari, v = w \/ v <> w.

simple induction v.
simple induction w.
intro. 
specialize (Xmidnat n n0).
simple induction 1.
intro eq; left; elim eq; reflexivity.
intro neq; right; red in |- *; intro; apply neq.
apply vari_nat; assumption.
Save Xmidvar.

Goal forall A B C : Prop, (IF A then B else C) -> A -> B.
unfold IF_then_else in |- *; simple induction 1.
simple induction 1; intros; assumption.
simple induction 1; intros; absurd A; assumption.
Save If_T.

Goal forall A B C : Prop, (IF A then B else C) -> ~ A -> C.
unfold IF_then_else in |- *; simple induction 1.
simple induction 1; intros; absurd A; assumption.
simple induction 1; intros; assumption.
Save If_F.

Goal forall A B C : Prop, A -> B -> IF A then B else C.
unfold IF_then_else in |- *; intros.
left; split; assumption.
Save T_If.

Goal forall A B C : Prop, ~ A -> C -> IF A then B else C.
unfold IF_then_else in |- *; intros.
right; split; assumption.
Save F_If.

Goal
forall A B C D : Prop,
(IF A then B else C) -> IF A then B else (IF A then D else C).

unfold IF_then_else in |- *; simple induction 1.
intro T; left; assumption.
intro F; right; elim F; intros; split.
assumption.
right; split; assumption.
Save IfA_IfAIfA.

Goal forall A B C D : Prop, A \/ D /\ C -> (D -> A \/ B) -> A \/ B /\ C.

intros A B C D A1 A2.
elim A1.
intro; left; assumption.
simple induction 1; intros DH CH.
specialize A2 with (1 := DH); induction A2.
left; assumption.
right; split; assumption.
Save AABC_ABC. *)



Inductive FV (z : vari) : tm -> Prop :=

  | FV_abs :

      forall e : tm,

      FV z e -> forall v : vari, z <> v -> forall t : ty, FV z (abs v t e)

  | FV_fix :

      forall e : tm,

      FV z e -> forall v : vari, z <> v -> forall t : ty, FV z (Fix v t e)

  | FV_appl1 : forall e_1 e_2 : tm, FV z e_1 -> FV z (appl e_1 e_2)

  | FV_appl2 : forall e_1 e_2 : tm, FV z e_2 -> FV z (appl e_1 e_2)

  | FV_cond1 : forall e_1 e_2 e_3 : tm, FV z e_1 -> FV z (cond e_1 e_2 e_3)

  | FV_cond2 : forall e_1 e_2 e_3 : tm, FV z e_2 -> FV z (cond e_1 e_2 e_3)

  | FV_cond3 : forall e_1 e_2 e_3 : tm, FV z e_3 -> FV z (cond e_1 e_2 e_3)

  | FV_var : forall v : vari, z = v -> FV z (var v)

  | FV_succ : forall e : tm, FV z e -> FV z (succ e)

  | FV_prd : forall e : tm, FV z e -> FV z (prd e)

  | FV_is_o : forall e : tm, FV z e -> FV z (is_o e)

  | FV_closa :

      forall (v : vari) (t : ty) (e e_1 : tm),

      FV z e_1 -> FV z (clos e v t e_1)

  | FV_closb :

      forall (v : vari) (t : ty) (e e_1 : tm),

      FV z e -> z <> v -> FV z (clos e v t e_1).



Goal

forall (x v : vari) (t : ty) (e : tm),

~ FV x (abs v t e) -> x = v \/ ~ FV x e.

intros.

specialize (Xmidvar x v); simple induction 1; intro A.

left; assumption.

right; red in |- *; intro; apply H; apply FV_abs; assumption.

Save notFV_abs.



Goal

forall (v : vari) (e1 e2 : tm), ~ FV v (appl e1 e2) -> ~ FV v e1 /\ ~ FV v e2.

intros v e1 e2 N.

split.

red in |- *; intro; apply N; apply FV_appl1; assumption.

red in |- *; intro; apply N; apply FV_appl2; assumption.

Save notFV_appl.



Goal

forall (v : vari) (e1 e2 e3 : tm),

~ FV v (cond e1 e2 e3) -> ~ FV v e1 /\ ~ FV v e2 /\ ~ FV v e3.

intros v e1 e2 e3 N.

split.

red in |- *; intro; apply N; apply FV_cond1; assumption.

split.

red in |- *; intro; apply N; apply FV_cond2; assumption.

red in |- *; intro; apply N; apply FV_cond3; assumption.

Save notFV_cond.



Goal forall v x : vari, ~ FV v (var x) -> v <> x.

intros v x N.

red in |- *; intro; apply N; apply FV_var; assumption.

Save notFV_var.



Goal forall (v : vari) (e : tm), ~ FV v (succ e) -> ~ FV v e.

intros v e N.

red in |- *; intro; apply N; apply FV_succ; assumption.

Save notFV_succ.



Goal forall (v : vari) (e : tm), ~ FV v (prd e) -> ~ FV v e.

intros v e N.

red in |- *; intro; apply N; apply FV_prd; assumption.

Save notFV_prd.



Goal forall (v : vari) (e : tm), ~ FV v (is_o e) -> ~ FV v e.

intros v e N.

red in |- *; intro; apply N; apply FV_is_o; assumption.

Save notFV_is_o.



Goal

forall (x v : vari) (t : ty) (e : tm),

~ FV x (Fix v t e) -> x = v \/ ~ FV x e.

intros.

specialize (Xmidvar x v); simple induction 1; intro A.

left; assumption.

right; red in |- *; intro; apply H; apply FV_fix; assumption.

Save notFV_fix.



Goal

forall (x v : vari) (t : ty) (e a : tm),

~ FV x (clos e v t a) -> ~ FV x a /\ (x = v \/ ~ FV x e).

intros.

split.

red in |- *; intro; apply H; apply FV_closa; assumption.

specialize (Xmidvar x v); simple induction 1; intro A.

left; assumption.

right; red in |- *; intro; apply H; apply FV_closb; assumption.

Save notFV_clos.



Definition fv (v : vari) (e : tm) :=

  match e return Prop with

  | o =>

      	 False

       

  | ttt => False

       

  | fff => False

       

  | abs y s e => FV v e /\ v <> y

                            

  | appl e1 e2 => FV v e1 \/ FV v e2 

                  

  | cond e1 e2 e3 => FV v e1 \/ FV v e2 \/ FV v e3 

                                	

  | var y => v = y

             	

  | succ n => FV v n

      	

  | prd n => FV v n

      	

  | is_o n => FV v n

      	

  | Fix y s e => FV v e /\ v <> y

                           

  | clos e y s e1 => FV v e1 \/ FV v e /\ v <> y

  end.



Goal forall (v : vari) (e : tm), FV v e -> fv v e.



simple induction 1; simpl in |- *; intros.

split; assumption.

split; assumption.

left; assumption.

right; assumption.

left; assumption.

right; left; assumption.

right; right; assumption.

assumption.

assumption.

assumption.

assumption.

left; assumption.

right; split; assumption.

Save FV_fv.



Goal forall v : vari, ~ FV v o.

intro v; red in |- *; intro F.

change (fv v o) in |- *.

apply FV_fv; assumption.

Save inv_FV_o.



Goal forall v : vari, ~ FV v ttt.

intro v; red in |- *; intro F.

change (fv v ttt) in |- *.

apply FV_fv; assumption.

Save inv_FV_ttt.



Goal forall v : vari, ~ FV v fff.

intro v; red in |- *; intro F.

change (fv v fff) in |- *.

apply FV_fv; assumption.

Save inv_FV_fff.



Goal

forall (v x : vari) (t : ty) (e : tm), FV v (abs x t e) -> FV v e /\ v <> x.

intros v x t e F.

change (fv v (abs x t e)) in |- *.

apply FV_fv; assumption.

Save inv_FV_abs.



Goal

forall (v x : vari) (t : ty) (e : tm), FV v (Fix x t e) -> FV v e /\ v <> x.

intros v x t e F.

change (fv v (Fix x t e)) in |- *.

apply FV_fv; assumption.

Save inv_FV_fix.



Goal forall (v : vari) (e1 e2 : tm), FV v (appl e1 e2) -> FV v e1 \/ FV v e2.

intros v e1 e2 F.

change (fv v (appl e1 e2)) in |- *.

apply FV_fv; assumption.

Save inv_FV_appl.



Goal

forall (v : vari) (e1 e2 e3 : tm),

FV v (cond e1 e2 e3) -> FV v e1 \/ FV v e2 \/ FV v e3.

intros v e1 e2 e3 F.

change (fv v (cond e1 e2 e3)) in |- *.

apply FV_fv; assumption.

Save inv_FV_cond.



Goal forall v x : vari, FV v (var x) -> v = x.

intros v x F.

change (fv v (var x)) in |- *.

apply FV_fv; assumption.

Save inv_FV_var.



Goal forall (v : vari) (e : tm), FV v (succ e) -> FV v e.

intros v e F.

change (fv v (succ e)) in |- *.

apply FV_fv; assumption.

Save inv_FV_succ.



Goal forall (v : vari) (e : tm), FV v (prd e) -> FV v e.

intros v e F.

change (fv v (prd e)) in |- *.

apply FV_fv; assumption.

Save inv_FV_prd.



Goal forall (v : vari) (e : tm), FV v (is_o e) -> FV v e.

intros v e F.

change (fv v (is_o e)) in |- *.

apply FV_fv; assumption.

Save inv_FV_is_o.



Goal

forall (v x : vari) (t : ty) (e a : tm),

FV v (clos e x t a) -> FV v a \/ FV v e /\ v <> x.

intros v x t e a F.

change (fv v (clos e x t a)) in |- *.

apply FV_fv; assumption.

Save inv_FV_clos.



