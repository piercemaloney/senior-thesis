

Require Import syntax.
(* syntax:
Inductive ty : Set :=
  | nat_ty : ty 
  | bool_ty : ty 
  | arr : ty -> ty -> ty.   

Inductive vari : Set :=
    x : nat -> vari.

Inductive tm : Set :=
  | o : tm 
  | ttt : tm 
  | fff : tm 
  | abs : vari -> ty -> tm -> tm 
  | appl : tm -> tm -> tm 
  | cond : tm -> tm -> tm -> tm 
  | var : vari -> tm 
  | succ : tm -> tm 
  | prd : tm -> tm 
  | is_o : tm -> tm 
  | Fix : vari -> ty -> tm -> tm 
  | clos : tm -> vari -> ty -> tm -> tm. *)

Require Import List.

Require Import utils.
(* utils:
Require Import syntax.

Definition valu (v : vari) :=
  match v return nat with
  | x n =>   n
  end.

Goal forall m n : nat, x m = x n :>vari -> m = n :>nat.
intros m n Q.  
replace m with (valu (x m)).
rewrite Q.
simpl in |- *; reflexivity.
simpl in |- *; reflexivity.
Save vari_nat.

Definition Rator_ty (t : ty) :=
  match t with
  | nat_ty => t
  | bool_ty => t
  | arr t0 _ => t0
  end.
Definition Rand_ty (t : ty) :=
  match t with
  | nat_ty => t
  | bool_ty => t
  | arr _ t0 => t0
  end.
Goal
forall s1 t1 s2 t2 : ty,
arr s1 t1 = arr s2 t2 :>ty -> s1 = s2 :>ty /\ t1 = t2 :>ty.
intros s1 t1 s2 t2 Q.
split.
change (Rator_ty (arr s1 t1) = Rator_ty (arr s2 t2) :>ty) in |- *.
apply (f_equal Rator_ty). assumption.
change (Rand_ty (arr s1 t1) = Rand_ty (arr s2 t2) :>ty) in |- *.
apply (f_equal Rand_ty); assumption.
Save subty_eq.

Definition is_nat (t : ty) :=
  match t with
  | nat_ty => True
  | bool_ty => False
  | arr _ _ => False
  end.
Definition is_bool (t : ty) :=
  match t with
  | nat_ty => False
  | bool_ty => True
  | arr _ _ => False
  end.
Definition is_arr (t : ty) :=
  match t with
  | nat_ty => False
  | bool_ty => False
  | arr _ _ => True
  end.

Goal nat_ty <> bool_ty :>ty.
red in |- *; intro H; change (is_nat bool_ty) in |- *; elim H; exact I.
Save nat_not_bool.

Goal forall t s : ty, nat_ty <> arr t s :>ty.
red in |- *; intros t s H; change (is_nat (arr t s)) in |- *; elim H; exact I.
Save nat_not_arr.

Goal forall t s : ty, bool_ty <> arr t s :>ty.
red in |- *; intros t s H; change (is_bool (arr t s)) in |- *; elim H;
 exact I.
Save bool_not_arr.

	Goal forall m n : nat, m = n \/ m <> n.

	simple induction m.
	simple induction n.
	left; reflexivity.
	intros; right; apply O_S.
	intros y H n; elim n.
	right; red in |- *; intro; apply (O_S y); symmetry  in |- *; assumption.
	intros y0 I.
	elim (H y0); intro E. 
	left; elim E; reflexivity.
	right; red in |- *; intro.
	apply E; apply eq_add_S; assumption.
	Save Xmidnat.

Goal forall v w : vari, v = w \/ v <> w.

simple induction v.
simple induction w.
intro. 
specialize (Xmidnat n n0).
simple induction 1.
intro eq; left; elim eq; reflexivity.
intro neq; right; red in |- *; intro; apply neq.
apply vari_nat; assumption.
Save Xmidvar.

Goal forall A B C : Prop, (IF A then B else C) -> A -> B.
unfold IF_then_else in |- *; simple induction 1.
simple induction 1; intros; assumption.
simple induction 1; intros; absurd A; assumption.
Save If_T.

Goal forall A B C : Prop, (IF A then B else C) -> ~ A -> C.
unfold IF_then_else in |- *; simple induction 1.
simple induction 1; intros; absurd A; assumption.
simple induction 1; intros; assumption.
Save If_F.

Goal forall A B C : Prop, A -> B -> IF A then B else C.
unfold IF_then_else in |- *; intros.
left; split; assumption.
Save T_If.

Goal forall A B C : Prop, ~ A -> C -> IF A then B else C.
unfold IF_then_else in |- *; intros.
right; split; assumption.
Save F_If.

Goal
forall A B C D : Prop,
(IF A then B else C) -> IF A then B else (IF A then D else C).

unfold IF_then_else in |- *; simple induction 1.
intro T; left; assumption.
intro F; right; elim F; intros; split.
assumption.
right; split; assumption.
Save IfA_IfAIfA.

Goal forall A B C D : Prop, A \/ D /\ C -> (D -> A \/ B) -> A \/ B /\ C.

intros A B C D A1 A2.
elim A1.
intro; left; assumption.
simple induction 1; intros DH CH.
specialize A2 with (1 := DH); induction A2.
left; assumption.
right; split; assumption.
Save AABC_ABC. *)

Require Import environments.
(* environments:
Require Import syntax.

Require Import List.

Fixpoint member (A : Set) (b : A) (l : list A) {struct l} : Prop :=
  match l with
  | nil => False
  | a :: m => a = b \/ member A b m
  end.

Definition VT := (vari * ty)%type.
Definition ty_env := list VT.

Definition VTT := (VT * tm)%type.
Definition OS_env := list VTT.

Definition mapsto (indx : vari) (val : ty) (l : list VT) :=
  (fix F (l0 : list VT) : Prop :=
     match l0 with
     | nil => False
     | v :: l1 => IF fst v = indx :>vari then snd v = val :>ty else F l1
     end) l.
 
Inductive config : Set :=
    cfg : tm -> OS_env -> config.

Definition cfgexp (c : config) := let (e, A) return tm := c in e.

Definition cfgenv (c : config) := let (e, A) return OS_env := c in A.

Definition TE_Dom (H : ty_env) :=
  (fix F (l : list VT) : list vari :=
     match l with
     | nil => nil (A:=vari)
     | v :: l0 => cons (fst v) (F l0)
     end) H.
 
Definition OS_Dom (A : OS_env) :=
  (fix F (l : list VTT) : list vari :=
     match l with
     | nil => nil (A:=vari)
     | v :: l0 => cons (fst (fst v)) (F l0)
     end) A.
 
Definition OS_Dom_ty (A : OS_env) :=
  (fix F (l : list VTT) : list VT :=
     match l with
     | nil => nil (A:=VT)
     | v :: l0 => cons (fst v) (F l0)
     end) A. *)



Require Import typecheck.
(* typecheck:
Require Import environments.
Require Import List.

Require Import syntax.

Inductive TC : ty_env -> tm -> ty -> Prop :=
  | TC_o : forall H : ty_env, TC H o nat_ty
  | TC_ttt : forall H : ty_env, TC H ttt bool_ty
  | TC_fff : forall H : ty_env, TC H fff bool_ty
  | TC_succ :
      forall (H : ty_env) (e : tm), TC H e nat_ty -> TC H (succ e) nat_ty
  | TC_prd :
      forall (H : ty_env) (e : tm), TC H e nat_ty -> TC H (prd e) nat_ty
  | TC_is_o :
      forall (H : ty_env) (e : tm), TC H e nat_ty -> TC H (is_o e) bool_ty
  | TC_var :
      forall (H : ty_env) (v : vari) (t : ty), mapsto v t H -> TC H (var v) t
  | TC_appl :
      forall (H : ty_env) (e e1 : tm) (s t : ty),
      TC H e (arr s t) -> TC H e1 s -> TC H (appl e e1) t
  | TC_abs :
      forall (H : ty_env) (v : vari) (e : tm) (s t : ty),
      TC ((v, s) :: H) e t -> TC H (abs v s e) (arr s t)
  | TC_cond :
      forall (H : ty_env) (e1 e2 e3 : tm) (t : ty),
      TC H e1 bool_ty -> TC H e2 t -> TC H e3 t -> TC H (cond e1 e2 e3) t
  | TC_fix :
      forall (H : ty_env) (e : tm) (t : ty) (v : vari),
      TC ((v, t) :: H) e t -> TC H (Fix v t e) t
  | TC_clos :
      forall (H : ty_env) (e e1 : tm) (s t : ty) (v : vari),
      TC H e1 s -> TC ((v, s) :: H) e t -> TC H (clos e v s e1) t.
                                
Definition tc (H : ty_env) (e : tm) (t : ty) :=
  match e return Prop with
  | o =>
      	 t = nat_ty
       
  | ttt => t = bool_ty
       
  | fff => t = bool_ty
       
  | abs v s e =>
      exists r : ty, t = arr s r /\ TC ((v, s) :: H) e r
       
  | appl e1 e2 =>
      exists s : ty, TC H e1 (arr s t) /\ TC H e2 s
      
  | cond e1 e2 e3 => TC H e1 bool_ty /\ TC H e2 t /\ TC H e3 t
                                        	
  | var v => mapsto v t H
      	
  | succ n => t = nat_ty /\ TC H n nat_ty
              	
  | prd n => t = nat_ty /\ TC H n nat_ty
             	
  | is_o n => t = bool_ty /\ TC H n nat_ty
              
  | Fix v s e1 => s = t /\ TC ((v, s) :: H) e1 t
      
  | clos e v s e1 => TC H e1 s /\ TC ((v, s) :: H) e t
  end.

Goal forall (H : ty_env) (e : tm) (t : ty), TC H e t -> tc H e t.
simple induction 1; simpl in |- *; intros.
reflexivity.
reflexivity.
reflexivity.
split; reflexivity || assumption.
split; reflexivity || assumption.
split; reflexivity || assumption.
assumption.
exists s; split; assumption.
exists t0; split; reflexivity || assumption.
split; assumption || split; assumption.
split; reflexivity || assumption.
split; assumption.
Save TC_tc.

Goal forall (H : ty_env) (t : ty), TC H o t -> t = nat_ty.
 intros H t HTC.  change (tc H o t) in |- *.
 apply TC_tc; assumption.
Save inv_TC_o.

Goal forall (H : ty_env) (t : ty), TC H ttt t -> t = bool_ty.
 intros H t HTC.  change (tc H ttt t) in |- *.
 apply TC_tc; assumption.
Save inv_TC_ttt.

Goal forall (H : ty_env) (t : ty), TC H fff t -> t = bool_ty.
 intros H t HTC.  change (tc H fff t) in |- *.
 apply TC_tc; assumption.
Save inv_TC_fff.

Goal
forall (H : ty_env) (t : ty) (e0 : tm),
TC H (prd e0) t -> t = nat_ty /\ TC H e0 nat_ty.
 intros H t e0 HTC.  change (tc H (prd e0) t) in |- *.
 apply TC_tc; assumption.
Save inv_TC_prd.

Goal
forall (H : ty_env) (t : ty) (e0 : tm),
TC H (succ e0) t -> t = nat_ty /\ TC H e0 nat_ty.
 intros H t e0 HTC.  change (tc H (succ e0) t) in |- *.
 apply TC_tc; assumption.
Save inv_TC_succ.

Goal
forall (H : ty_env) (t : ty) (e0 : tm),
TC H (is_o e0) t -> t = bool_ty /\ TC H e0 nat_ty.
 intros H t e0 HTC.  change (tc H (is_o e0) t) in |- *.
 apply TC_tc; assumption.
Save inv_TC_is_o.

Goal forall (H : ty_env) (t : ty) (v : vari), TC H (var v) t -> mapsto v t H.
 intros H t v HTC.  change (tc H (var v) t) in |- *.
 apply TC_tc; assumption.
Save inv_TC_var.

Goal
forall (H : ty_env) (t : ty) (e1 e2 : tm),
TC H (appl e1 e2) t -> exists s : ty, TC H e1 (arr s t) /\ TC H e2 s.
 intros H t e1 e2 HTC.  change (tc H (appl e1 e2) t) in |- *.
 apply TC_tc; assumption.
Save inv_TC_appl.

Goal
forall (H : ty_env) (t s : ty) (v : vari) (e : tm),
TC H (abs v s e) t -> exists r : ty, t = arr s r /\ TC ((v, s) :: H) e r.
 intros H t s v e HTC.  change (tc H (abs v s e) t) in |- *.
 apply TC_tc; assumption.
Save inv_TC_abs.

Goal
forall (H : ty_env) (t : ty) (e1 e2 e3 : tm),
TC H (cond e1 e2 e3) t -> TC H e1 bool_ty /\ TC H e2 t /\ TC H e3 t.
 intros H t e1 e2 e3 HTC.  change (tc H (cond e1 e2 e3) t) in |- *.
 apply TC_tc; assumption.
Save inv_TC_cond.

Goal
forall (H : ty_env) (s t : ty) (e : tm) (v : vari),
TC H (Fix v s e) t -> s = t /\ TC ((v, s) :: H) e t.
 intros H s t e v HTC.  change (tc H (Fix v s e) t) in |- *.
 apply TC_tc; assumption.
Save inv_TC_fix.

Goal
forall (H : ty_env) (t s : ty) (e e1 : tm) (v : vari),
TC H (clos e v s e1) t -> TC H e1 s /\ TC ((v, s) :: H) e t.
 intros H t s e e1 v HTC.  change (tc H (clos e v s e1) t) in |- *.
 apply TC_tc; assumption.
Save inv_TC_clos. *)



Inductive valid_env : OS_env -> Prop :=

  | valid_nil : valid_env nil

  | valid_cons :

      forall (v : vari) (t : ty) (e : tm) (A : OS_env),

      TC (OS_Dom_ty A) e t -> valid_env A -> valid_env ((v, t, e) :: A).



Inductive valid_config (c : config) : Prop :=

    valid_cfg :

      valid_env (cfgenv c) ->

      forall t : ty, TC (OS_Dom_ty (cfgenv c)) (cfgexp c) t -> valid_config c.



Definition valid_c (A : OS_env) :=

  match A return Prop with

  | nil =>

        True

       

  | vtt :: A' => valid_env A' /\ TC (OS_Dom_ty A') (snd vtt) (snd (fst vtt))

  end.



Goal

forall (v : vari) (t : ty) (e : tm) (A : OS_env),

valid_env ((v, t, e) :: A) -> valid_env A /\ TC (OS_Dom_ty A) e t.



intros v t e A H.

change (valid_c ((v, t, e) :: A)) in |- *.

elim H; simpl in |- *; exact I || intros; split; assumption.

Save inv_valid_cons.

