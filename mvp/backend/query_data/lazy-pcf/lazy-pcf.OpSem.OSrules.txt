

Require Import List.

Require Import syntax.
(* syntax:
Inductive ty : Set :=
  | nat_ty : ty 
  | bool_ty : ty 
  | arr : ty -> ty -> ty.   

Inductive vari : Set :=
    x : nat -> vari.

Inductive tm : Set :=
  | o : tm 
  | ttt : tm 
  | fff : tm 
  | abs : vari -> ty -> tm -> tm 
  | appl : tm -> tm -> tm 
  | cond : tm -> tm -> tm -> tm 
  | var : vari -> tm 
  | succ : tm -> tm 
  | prd : tm -> tm 
  | is_o : tm -> tm 
  | Fix : vari -> ty -> tm -> tm 
  | clos : tm -> vari -> ty -> tm -> tm. *)

Require Import environments.
(* environments:
Require Import syntax.

Require Import List.

Fixpoint member (A : Set) (b : A) (l : list A) {struct l} : Prop :=
  match l with
  | nil => False
  | a :: m => a = b \/ member A b m
  end.

Definition VT := (vari * ty)%type.
Definition ty_env := list VT.

Definition VTT := (VT * tm)%type.
Definition OS_env := list VTT.

Definition mapsto (indx : vari) (val : ty) (l : list VT) :=
  (fix F (l0 : list VT) : Prop :=
     match l0 with
     | nil => False
     | v :: l1 => IF fst v = indx :>vari then snd v = val :>ty else F l1
     end) l.
 
Inductive config : Set :=
    cfg : tm -> OS_env -> config.

Definition cfgexp (c : config) := let (e, A) return tm := c in e.

Definition cfgenv (c : config) := let (e, A) return OS_env := c in A.

Definition TE_Dom (H : ty_env) :=
  (fix F (l : list VT) : list vari :=
     match l with
     | nil => nil (A:=vari)
     | v :: l0 => cons (fst v) (F l0)
     end) H.
 
Definition OS_Dom (A : OS_env) :=
  (fix F (l : list VTT) : list vari :=
     match l with
     | nil => nil (A:=vari)
     | v :: l0 => cons (fst (fst v)) (F l0)
     end) A.
 
Definition OS_Dom_ty (A : OS_env) :=
  (fix F (l : list VTT) : list VT :=
     match l with
     | nil => nil (A:=VT)
     | v :: l0 => cons (fst v) (F l0)
     end) A. *)



Require Import typecheck.
(* typecheck:
Require Import environments.
Require Import List.

Require Import syntax.

Inductive TC : ty_env -> tm -> ty -> Prop :=
  | TC_o : forall H : ty_env, TC H o nat_ty
  | TC_ttt : forall H : ty_env, TC H ttt bool_ty
  | TC_fff : forall H : ty_env, TC H fff bool_ty
  | TC_succ :
      forall (H : ty_env) (e : tm), TC H e nat_ty -> TC H (succ e) nat_ty
  | TC_prd :
      forall (H : ty_env) (e : tm), TC H e nat_ty -> TC H (prd e) nat_ty
  | TC_is_o :
      forall (H : ty_env) (e : tm), TC H e nat_ty -> TC H (is_o e) bool_ty
  | TC_var :
      forall (H : ty_env) (v : vari) (t : ty), mapsto v t H -> TC H (var v) t
  | TC_appl :
      forall (H : ty_env) (e e1 : tm) (s t : ty),
      TC H e (arr s t) -> TC H e1 s -> TC H (appl e e1) t
  | TC_abs :
      forall (H : ty_env) (v : vari) (e : tm) (s t : ty),
      TC ((v, s) :: H) e t -> TC H (abs v s e) (arr s t)
  | TC_cond :
      forall (H : ty_env) (e1 e2 e3 : tm) (t : ty),
      TC H e1 bool_ty -> TC H e2 t -> TC H e3 t -> TC H (cond e1 e2 e3) t
  | TC_fix :
      forall (H : ty_env) (e : tm) (t : ty) (v : vari),
      TC ((v, t) :: H) e t -> TC H (Fix v t e) t
  | TC_clos :
      forall (H : ty_env) (e e1 : tm) (s t : ty) (v : vari),
      TC H e1 s -> TC ((v, s) :: H) e t -> TC H (clos e v s e1) t.
                                
Definition tc (H : ty_env) (e : tm) (t : ty) :=
  match e return Prop with
  | o =>
      	 t = nat_ty
       
  | ttt => t = bool_ty
       
  | fff => t = bool_ty
       
  | abs v s e =>
      exists r : ty, t = arr s r /\ TC ((v, s) :: H) e r
       
  | appl e1 e2 =>
      exists s : ty, TC H e1 (arr s t) /\ TC H e2 s
      
  | cond e1 e2 e3 => TC H e1 bool_ty /\ TC H e2 t /\ TC H e3 t
                                        	
  | var v => mapsto v t H
      	
  | succ n => t = nat_ty /\ TC H n nat_ty
              	
  | prd n => t = nat_ty /\ TC H n nat_ty
             	
  | is_o n => t = bool_ty /\ TC H n nat_ty
              
  | Fix v s e1 => s = t /\ TC ((v, s) :: H) e1 t
      
  | clos e v s e1 => TC H e1 s /\ TC ((v, s) :: H) e t
  end.

Goal forall (H : ty_env) (e : tm) (t : ty), TC H e t -> tc H e t.
simple induction 1; simpl in |- *; intros.
reflexivity.
reflexivity.
reflexivity.
split; reflexivity || assumption.
split; reflexivity || assumption.
split; reflexivity || assumption.
assumption.
exists s; split; assumption.
exists t0; split; reflexivity || assumption.
split; assumption || split; assumption.
split; reflexivity || assumption.
split; assumption.
Save TC_tc.

Goal forall (H : ty_env) (t : ty), TC H o t -> t = nat_ty.
 intros H t HTC.  change (tc H o t) in |- *.
 apply TC_tc; assumption.
Save inv_TC_o.

Goal forall (H : ty_env) (t : ty), TC H ttt t -> t = bool_ty.
 intros H t HTC.  change (tc H ttt t) in |- *.
 apply TC_tc; assumption.
Save inv_TC_ttt.

Goal forall (H : ty_env) (t : ty), TC H fff t -> t = bool_ty.
 intros H t HTC.  change (tc H fff t) in |- *.
 apply TC_tc; assumption.
Save inv_TC_fff.

Goal
forall (H : ty_env) (t : ty) (e0 : tm),
TC H (prd e0) t -> t = nat_ty /\ TC H e0 nat_ty.
 intros H t e0 HTC.  change (tc H (prd e0) t) in |- *.
 apply TC_tc; assumption.
Save inv_TC_prd.

Goal
forall (H : ty_env) (t : ty) (e0 : tm),
TC H (succ e0) t -> t = nat_ty /\ TC H e0 nat_ty.
 intros H t e0 HTC.  change (tc H (succ e0) t) in |- *.
 apply TC_tc; assumption.
Save inv_TC_succ.

Goal
forall (H : ty_env) (t : ty) (e0 : tm),
TC H (is_o e0) t -> t = bool_ty /\ TC H e0 nat_ty.
 intros H t e0 HTC.  change (tc H (is_o e0) t) in |- *.
 apply TC_tc; assumption.
Save inv_TC_is_o.

Goal forall (H : ty_env) (t : ty) (v : vari), TC H (var v) t -> mapsto v t H.
 intros H t v HTC.  change (tc H (var v) t) in |- *.
 apply TC_tc; assumption.
Save inv_TC_var.

Goal
forall (H : ty_env) (t : ty) (e1 e2 : tm),
TC H (appl e1 e2) t -> exists s : ty, TC H e1 (arr s t) /\ TC H e2 s.
 intros H t e1 e2 HTC.  change (tc H (appl e1 e2) t) in |- *.
 apply TC_tc; assumption.
Save inv_TC_appl.

Goal
forall (H : ty_env) (t s : ty) (v : vari) (e : tm),
TC H (abs v s e) t -> exists r : ty, t = arr s r /\ TC ((v, s) :: H) e r.
 intros H t s v e HTC.  change (tc H (abs v s e) t) in |- *.
 apply TC_tc; assumption.
Save inv_TC_abs.

Goal
forall (H : ty_env) (t : ty) (e1 e2 e3 : tm),
TC H (cond e1 e2 e3) t -> TC H e1 bool_ty /\ TC H e2 t /\ TC H e3 t.
 intros H t e1 e2 e3 HTC.  change (tc H (cond e1 e2 e3) t) in |- *.
 apply TC_tc; assumption.
Save inv_TC_cond.

Goal
forall (H : ty_env) (s t : ty) (e : tm) (v : vari),
TC H (Fix v s e) t -> s = t /\ TC ((v, s) :: H) e t.
 intros H s t e v HTC.  change (tc H (Fix v s e) t) in |- *.
 apply TC_tc; assumption.
Save inv_TC_fix.

Goal
forall (H : ty_env) (t s : ty) (e e1 : tm) (v : vari),
TC H (clos e v s e1) t -> TC H e1 s /\ TC ((v, s) :: H) e t.
 intros H t s e e1 v HTC.  change (tc H (clos e v s e1) t) in |- *.
 apply TC_tc; assumption.
Save inv_TC_clos. *)



Require Import rename.
(* rename:
Require Import syntax.
Require Import freevars.

Inductive rename : vari -> vari -> tm -> tm -> Prop :=
  | ren_o : forall nv v : vari, rename nv v o o
  | ren_ttt : forall nv v : vari, rename nv v ttt ttt
  | ren_fff : forall nv v : vari, rename nv v fff fff
  | ren_abs1 :
      forall (nv v : vari) (t : ty) (e : tm),
      rename nv v (abs v t e) (abs v t e)
  | ren_abs2 :
      forall (nv v x nx : vari) (t : ty) (e1 e2 e3 : tm),
      nv = x ->
      ~ FV nx e1 ->
      nx <> v ->
      nx <> nv ->
      rename nx x e1 e2 ->
      rename nv v e2 e3 -> rename nv v (abs x t e1) (abs nx t e3)
  | ren_abs3 :
      forall (nv v x : vari) (t : ty) (e ne : tm),
      v <> x ->
      nv <> x -> rename nv v e ne -> rename nv v (abs x t e) (abs x t ne)
  | ren_appl :
      forall (nv v : vari) (e1 e2 ne1 ne2 : tm),
      rename nv v e1 ne1 ->
      rename nv v e2 ne2 -> rename nv v (appl e1 e2) (appl ne1 ne2)
  | ren_cond :
      forall (nv v : vari) (e1 ne1 e2 ne2 e3 ne3 : tm),
      rename nv v e1 ne1 ->
      rename nv v e2 ne2 ->
      rename nv v e3 ne3 -> rename nv v (cond e1 e2 e3) (cond ne1 ne2 ne3)
  | ren_var_eq : forall nv v : vari, rename nv v (var v) (var nv)
  | ren_var_not_eq :
      forall nv v x : vari, v <> x -> rename nv v (var x) (var x)
  | ren_succ :
      forall (nv v : vari) (e ne : tm),
      rename nv v e ne -> rename nv v (succ e) (succ ne)
  | ren_prd :
      forall (nv v : vari) (e ne : tm),
      rename nv v e ne -> rename nv v (prd e) (prd ne)
  | ren_is_o :
      forall (nv v : vari) (e ne : tm),
      rename nv v e ne -> rename nv v (is_o e) (is_o ne)
  | ren_fix1 :
      forall (nv v : vari) (t : ty) (e : tm),
      rename nv v (Fix v t e) (Fix v t e)
  | ren_fix2 :
      forall (nv v x nx : vari) (t : ty) (e1 e2 e3 : tm),
      nv = x ->
      ~ FV nx e1 ->
      nx <> v ->
      nx <> nv ->
      rename nx x e1 e2 ->
      rename nv v e2 e3 -> rename nv v (Fix x t e1) (Fix nx t e3)
  | ren_fix3 :
      forall (nv v x : vari) (t : ty) (e ne : tm),
      v <> x ->
      nv <> x -> rename nv v e ne -> rename nv v (Fix x t e) (Fix x t ne)
  | ren_clos1 :
      forall (nv v : vari) (t : ty) (e a na : tm),
      rename nv v a na -> rename nv v (clos e v t a) (clos e v t na)
  | ren_clos2 :
      forall (nv v x nx : vari) (t : ty) (e e' ne a na : tm),
      nv = x ->
      ~ FV nx e ->
      nx <> v ->
      nx <> nv ->
      rename nx x e e' ->
      rename nv v e' ne ->
      rename nv v a na -> rename nv v (clos e x t a) (clos ne nx t na)
  | ren_clos3 :
      forall (nv v x : vari) (t : ty) (e ne a na : tm),
      v <> x ->
      nv <> x ->
      rename nv v e ne ->
      rename nv v a na -> rename nv v (clos e x t a) (clos ne x t na).

Goal
forall (nx x : vari) (e ne : tm), rename nx x e ne -> nx <> x -> ~ FV x ne.

   simple induction 1; simpl in |- *; intros.
   apply inv_FV_o.
   apply inv_FV_ttt.
   apply inv_FV_fff.
   red in |- *; intro F; specialize inv_FV_abs with (1 := F);
    simple induction 1; intros Fe N.
   apply N; reflexivity.
   red in |- *; intro F; specialize inv_FV_abs with (1 := F).
   simple induction 1; intros Fe3 N.
   red in H7; apply H7; assumption.
   red in |- *; intro F; specialize inv_FV_abs with (1 := F).
   simple induction 1; intros Fe N.
   red in H3; apply H3; assumption.
   red in |- *; intro F; specialize inv_FV_appl with (1 := F);
    simple induction 1.
   apply H1; assumption.
   apply H3; assumption.
   red in |- *; intro F; specialize inv_FV_cond with (1 := F);
    simple induction 1. apply H1; assumption.
   simple induction 1.
   apply H3; assumption.
   apply H5; assumption.
   red in |- *; intro F; specialize inv_FV_var with (1 := F).
   intro; apply H0; symmetry  in |- *; assumption.
   red in |- *; intro F; specialize inv_FV_var with (1 := F).  assumption.
   red in |- *; intro F; specialize inv_FV_succ with (1 := F).
   apply H1; assumption.
   red in |- *; intro F; specialize inv_FV_prd with (1 := F); apply H1;
    assumption.
   red in |- *; intro F; specialize inv_FV_is_o with (1 := F); apply H1;
    assumption.
   red in |- *; intro F; specialize inv_FV_fix with (1 := F);
    simple induction 1; intros Fe N.
   apply N; reflexivity.
   red in |- *; intro F; specialize inv_FV_fix with (1 := F).
   simple induction 1; intros Fe3 N.
   red in H7; apply H7; assumption.
   red in |- *; intro F; specialize inv_FV_fix with (1 := F).
   simple induction 1; intros Fe N.
   red in H3; apply H3; assumption.
   red in |- *; intro F; specialize inv_FV_clos with (1 := F).
   simple induction 1. apply H1; assumption.
   simple induction 1; intros Fe N.
   apply N; reflexivity.
   red in |- *; intro F; specialize inv_FV_clos with (1 := F).
   simple induction 1.  apply H9; assumption.
   simple induction 1; intros Fe3 N.
   red in H7; apply H7; assumption.
   red in |- *; intro F; specialize inv_FV_clos with (1 := F).
   simple induction 1.  apply H5; assumption.
   simple induction 1; intros Fe N.
   red in H3; apply H3; assumption.
Save RenNotFree. *)



Definition OScons (v : vari) (t : ty) (e : tm) (A : OS_env) := (v, t, e) :: A.



Inductive Ap (a : tm) : tm -> OS_env -> tm -> vari -> ty -> Prop :=

  | Ap_abs :

      forall (nv v : vari) (t : ty) (e ne : tm) (A : OS_env),

      ~ member vari nv (OS_Dom A) ->

      rename nv v e ne -> Ap a (abs v t e) A ne nv t

  | Ap_clos :

      forall (n v : vari) (s t : ty) (e ne e1 : tm) (A : OS_env),

      Ap a e (OScons v s e1 A) ne n t ->

      Ap a (clos e v s e1) A (clos ne v s e1) n t.



Goal

forall (a fun_ b : tm) (A : OS_env) (n : vari) (t : ty),

Ap a fun_ A b n t -> ~ member vari n (OS_Dom A).



   simple induction 1; intros.

   assumption.

   red in |- *; intro; apply H1; simpl in |- *.

   right; assumption.

Save ApNewVar.



Inductive OSred : config -> config -> Prop :=

  | OS_C0 : forall A : OS_env, OSred (cfg o A) (cfg o A)

  | OS_CT : forall A : OS_env, OSred (cfg ttt A) (cfg ttt A)

  | OS_CF : forall A : OS_env, OSred (cfg fff A) (cfg fff A)

  | OS_L :

      forall (A : OS_env) (e : tm) (t : ty) (x : vari),

      OSred (cfg (abs x t e) A) (cfg (abs x t e) A)

  | OS_P0 :

      forall (A A' : OS_env) (e : tm),

      OSred (cfg e A) (cfg o A') -> OSred (cfg (prd e) A) (cfg o A')

  | OS_P :

      forall (A A' : OS_env) (e e1 : tm),

      OSred (cfg e A) (cfg (succ e1) A') -> OSred (cfg (prd e) A) (cfg e1 A')

  | OS_ZT :

      forall (A A' : OS_env) (e : tm),

      OSred (cfg e A) (cfg o A') -> OSred (cfg (is_o e) A) (cfg ttt A')

  | OS_ZF :

      forall (A A' : OS_env) (e e1 : tm),

      OSred (cfg e A) (cfg (succ e1) A') ->

      OSred (cfg (is_o e) A) (cfg fff A')

  | OS_S :

      forall (A A' : OS_env) (e e1 : tm),

      OSred (cfg e A) (cfg e1 A') ->

      OSred (cfg (succ e) A) (cfg (succ e1) A')

  | OS_Var1 :

      forall (A A' : OS_env) (e en : tm) (t : ty) (x : vari),

      ~ member vari x (OS_Dom A) ->

      OSred (cfg e A) (cfg en A') ->

      OSred (cfg (var x) (OScons x t e A)) (cfg en (OScons x t en A'))

  | OS_Var2 :

      forall (A A' : OS_env) (e en : tm) (t : ty) (x y : vari),

      x <> y ->

      ~ member vari x (OS_Dom A) ->

      OSred (cfg (var y) A) (cfg en A') ->

      OSred (cfg (var y) (OScons x t e A)) (cfg en (OScons x t e A'))

  | OS_Appl :

      forall (A A' A'' : OS_env) (e1 e2 en en' enf : tm) (n : vari) (t : ty),

      OSred (cfg e1 A) (cfg en A') ->

      Ap e2 en A en' n t ->

      OSred (cfg (clos en' n t e2) A') (cfg enf A'') ->

      OSred (cfg (appl e1 e2) A) (cfg enf A'')

  | OS_IfTrue :

      forall (A A' A'' : OS_env) (e1 e2 e3 en : tm),

      OSred (cfg e1 A) (cfg ttt A') ->

      OSred (cfg e2 A') (cfg en A'') ->

      OSred (cfg (cond e1 e2 e3) A) (cfg en A'')

  | OS_IfFalse :

      forall (A A' A'' : OS_env) (e1 e2 e3 en : tm),

      OSred (cfg e1 A) (cfg fff A') ->

      OSred (cfg e3 A') (cfg en A'') ->

      OSred (cfg (cond e1 e2 e3) A) (cfg en A'')

  | OS_Fix :

      forall (A A' : OS_env) (e e' en : tm) (x nx : vari) (t : ty),

      ~ member vari nx (OS_Dom A) ->

      rename nx x e e' ->

      OSred (cfg (clos e' nx t (Fix x t e)) A) (cfg en A') ->

      OSred (cfg (Fix x t e) A) (cfg en A')

  | OS_CL :

      forall (A A' : OS_env) (e e1 en e1' : tm) (x : vari) (t : ty),

      OSred (cfg e (OScons x t e1 A)) (cfg en (OScons x t e1' A')) ->

      forall s : ty,

      TC (OS_Dom_ty (OScons x t e1 A)) en s ->

      ~ (s = nat_ty \/ s = bool_ty) ->

      OSred (cfg (clos e x t e1) A) (cfg (clos en x t e1') A')

  | OS_CL' :

      forall (A A' : OS_env) (e e1 en e1' : tm) (x : vari) (t : ty),

      OSred (cfg e (OScons x t e1 A)) (cfg en (OScons x t e1' A')) ->

      forall s : ty,

      TC (OS_Dom_ty (OScons x t e1 A)) en s ->

      s = nat_ty \/ s = bool_ty -> OSred (cfg (clos e x t e1) A) (cfg en A').

	

