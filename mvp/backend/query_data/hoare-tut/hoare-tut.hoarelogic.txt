
Set Implicit Arguments.

Require Export hoarelogicsemantics.
(* hoarelogicsemantics:
Set Implicit Arguments.

Module Type ExprLang.

  Parameter Var: Type -> Type. 
  Parameter Expr: Type -> Type. 
  Parameter Env: Type.

  Parameter upd: forall (A:Type), (Var A) -> A -> Env -> Env.
  Parameter eval: forall (A:Type), (Expr A) -> Env -> A.

End  ExprLang.

Module Type HoareLogicDefs.

Declare Module E: ExprLang.

Inductive ImpProg: Type := 
  | Iskip: ImpProg
  | Iset (A:Type) (x:E.Var A) (expr:E.Expr A): ImpProg
  | Iif (cond:E.Expr bool) (p1 p2:ImpProg): ImpProg
  | Iseq (p1 p2:ImpProg): ImpProg
  | Iwhile (cond:E.Expr bool) (p:ImpProg): ImpProg.

Inductive exec: E.Env -> ImpProg -> E.Env -> Prop :=
 | exec_Iskip: 
    forall e, (exec e Iskip e)
 | exec_Iset:
    forall (A:Type) e x (expr: E.Expr A), 
     (exec e (Iset x expr) (E.upd x (E.eval expr e) e))
 | exec_Iif:
    forall e (cond: E.Expr bool) p1 p2 e', 
      (exec e (if (E.eval cond e) then p1 else p2) e') 
         -> (exec e (Iif cond p1 p2) e')
 | exec_Iseq:
    forall e p1 p2 e' e'',
      (exec e p1 e') 
       -> (exec e' p2 e'')    
         -> (exec e (Iseq p1 p2) e'')
 | exec_Iwhile:
    forall e cond p e', 
     (exec e (Iif cond (Iseq p (Iwhile cond p)) Iskip) e')
        -> (exec e (Iwhile cond p) e').

Definition Pred := E.Env -> Prop.

Notation "p |= q" := (forall e, (p e) -> (q e)) (at level 80, no associativity).

Definition wlp: ImpProg -> Pred -> Pred
 := fun prog post e => (forall e', (exec e prog e') -> (post e')).

Notation "p {= post =}" := (wlp p post) (at level 70).

Definition wp: ImpProg -> Pred -> Pred
 := fun prog post e => exists e', (exec e prog e') /\ (post e').

Notation "p [= post =]" := (wp p post) (at level 70).

Hint Resolve exec_Iskip exec_Iset exec_Iif exec_Iseq exec_Iwhile: hoare.

Parameter exec_Iif_true:
  forall e cond p1 p2 e', 
     (E.eval cond e)=true
       -> (exec e p1 e') 
         -> (exec e (Iif cond p1 p2) e').

Parameter exec_Iif_false:
  forall e cond p1 p2 e', 
     (E.eval cond e)=false
      -> (exec e p2 e') 
         -> (exec e (Iif cond p1 p2) e').

Hint Resolve exec_Iif_true exec_Iif_false: hoare.

End HoareLogicDefs.

Module Type HoareProofSystem.

Declare Module HLD: HoareLogicDefs.

Import HLD.

Parameter sem_wp: ImpProg -> Pred -> Pred.
Parameter synt_wp: ImpProg -> Pred -> Pred.

Parameter soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= (sem_wp p post).
Parameter completeness: forall pre p post, pre |= (sem_wp p post) -> pre |= (synt_wp p post).

End HoareProofSystem.

Module Type HoareLogicSem.

Declare Module E: ExprLang.

Declare Module HLD: HoareLogicDefs with Module E:=E.
Import HLD.

Declare Module PHL: HoareProofSystem with Module HLD:=HLD with Definition sem_wp:=wlp.
Declare Module THL: HoareProofSystem with Module HLD:=HLD with Definition sem_wp:=wp.

Parameter wp_entails_wlp: forall prog post, prog [= post =] |= prog {= post =}.

End HoareLogicSem. *)
Require Import partialhoarelogic.
(* partialhoarelogic:
Global Set Asymmetric Patterns.
Set Implicit Arguments.
Require Export hoarelogicsemantics.

Module PartialHoareLogic (HD: HoareLogicDefs).

Export HD.
Module HLD:=HD.

Definition sem_wp := wlp.

Fixpoint synt_wp (prog: ImpProg) : Pred -> Pred 
 := fun post e =>
  match prog with
  | Iskip => post e
  | (Iset A x expr) => post (E.upd x (E.eval expr e) e)
  | (Iif cond p1 p2) =>
          ((E.eval cond e)=true -> (synt_wp p1 post e))
       /\ ((E.eval cond e)=false -> (synt_wp p2 post e))
  | (Iseq p1 p2) => synt_wp p1 (synt_wp p2 post) e
  | (Iwhile cond p) =>  
        exists inv:Pred, 
             (inv e)
          /\ (forall e', (inv e') 
                  -> (E.eval cond e')=false -> (post e'))
          /\ (forall e', (inv e') 
                  -> (E.eval cond e')=true -> (synt_wp p inv e'))
  end.

Lemma synt_wp_monotonic: 
  forall (p: ImpProg) (post1 post2: Pred),
   (post1 |= post2) -> (synt_wp p post1) |= (synt_wp p post2).

Hint Resolve synt_wp_monotonic: hoare.

Lemma wp_sound: forall prog post, synt_wp prog post |= prog{=post=}.

Lemma wp_complete: forall prog post, prog{=post=} |= (synt_wp prog post).

Hint Resolve wp_complete wp_sound: hoare.

Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p {=post=}.

Theorem completeness: forall pre p post, pre |= p {=post=} -> pre |= (synt_wp p post).

End PartialHoareLogic. *)
Require Import totalhoarelogic.
(* totalhoarelogic:
Global Set Asymmetric Patterns.
Set Implicit Arguments.
Require Export hoarelogicsemantics.
Require Wf.

Module TotalHoareLogic (HD: HoareLogicDefs).

Export HD.
Module HLD:=HD.

Definition sem_wp := wp.

Export Wf.

Fixpoint synt_wp (prog: ImpProg) : Pred -> Pred 
 := fun post e =>
  match prog with
  | Iskip => post e
  | (Iset A x expr) => post (E.upd x (E.eval expr e) e)
  | (Iif cond p1 p2) =>
          ((E.eval cond e)=true -> (synt_wp p1 post e))
       /\ ((E.eval cond e)=false -> (synt_wp p2 post e))
  | (Iseq p1 p2) => synt_wp p1 (synt_wp p2 post) e
  | (Iwhile cond p) =>  
        exists inv:Pred,
        exists R:E.Env -> E.Env -> Prop,
             (well_founded R)
          /\ (inv e)
          /\ (forall e', (inv e') 
                  -> (E.eval cond e')=false -> post e')
          /\ (forall e', (inv e') 
                  -> (E.eval cond e')=true -> synt_wp p inv e')
          /\ (forall e0, (inv e0)
                  -> (E.eval cond e0)=true -> synt_wp p (fun e1 => R e1 e0) e0)
  end.

Lemma synt_wp_monotonic: 
  forall (p: ImpProg) (post1 post2: Pred),
   (forall e, post1 e -> post2 e)
    -> forall e, (synt_wp p post1 e) -> (synt_wp p post2 e).

Hint Resolve synt_wp_monotonic: hoare.

Ltac dec2 n H := case H; clear H; intros n H.

Lemma synt_wp_conj:
 forall (p: ImpProg) (post1 post2: Pred) e,
   (synt_wp p post1 e) -> (synt_wp p post2 e) 
     -> (synt_wp p (fun e => post1 e /\ post2 e) e).

Lemma wp_sound: forall prog post, synt_wp prog post |= prog [=post=].

Definition aux_wlp (prog: ImpProg) : Pred -> Pred 
 := fun post e =>
  match prog with
  | Iskip => post e
  | (Iset A x expr) => post (E.upd x (E.eval expr e) e)
  | (Iif cond p1 p2) =>
       forall e', exec e (if E.eval cond e then p1 else p2) e' 
          -> post e'
  | (Iseq p1 p2) => forall e1 e2, exec e p1 e1 -> exec e1 p2 e2 -> post e2
  | (Iwhile cond p) => forall e', exec e (Iif cond (Iseq p (Iwhile cond p)) Iskip) e' -> post e'
  end.

Lemma exec_inversion:
  forall prog e e', (exec e prog e') -> forall post, (aux_wlp prog post e) -> post e'.

Lemma exec_test_inversion:
  forall A (x:E.Var A) expr e e',
 
Ltac exec_inversion H :=
  match type of H with
  | (exec ?e ?p ?e') => pattern e'; apply (exec_inversion H); simpl; clear H
  end.

Lemma exec_deterministic: forall ei p ef,
  (exec ei p ef) -> forall ef', (exec ei p ef') -> ef=ef'.

Definition reduces cond p e1 e0 :=
  (E.eval cond e0)=true /\ (exec e0 p e1) /\ exists ef, (exec e1 (Iwhile cond p) ef).

Inductive execn: nat -> E.Env -> ImpProg -> E.Env -> Prop :=
 | execn_Iskip:
    forall e, (execn 0 e Iskip e)
 | execn_Iset:
    forall (A:Type) e x (expr: E.Expr A),
     (execn 0 e (Iset x expr) (E.upd x (E.eval expr e) e))
 | execn_Iif:
    forall n e (cond: E.Expr bool) p1 p2 e',
       (execn n e (if (E.eval cond e) then p1 else p2) e')
         -> (execn n e (Iif cond p1 p2) e')
 | execn_Iseq:
    forall n e p1 p2 e' e'',
      (exec e p1 e')
       -> (execn n e' p2 e'')
         -> (execn n e (Iseq p1 p2) e'')
 | execn_Iwhile:
    forall n e cond p e',
     (execn n e (Iif cond (Iseq p (Iwhile cond p)) Iskip) e')
        -> (execn (S n) e (Iwhile cond p) e').

Hint Resolve execn_Iskip execn_Iset execn_Iif execn_Iseq execn_Iwhile: hoare.

Lemma exec_execn: forall ei p ef,
  (exec ei p ef) -> (exists n, execn n ei p ef).

Lemma reduces_wf: forall cond p, well_founded (reduces cond p).
Hint Resolve reduces_wf: hoare.

Lemma wp_complete: forall prog post, prog [= post =] |= (synt_wp prog post).

Hint Resolve wp_complete wp_sound: hoare.

Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].

Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).

End TotalHoareLogic. *)

Module HoareLogic(Ex: ExprLang)<: HoareLogicSem with Module E:=Ex.

Module E:=Ex.

Module HLD <: HoareLogicDefs with Module E:=E.

Module E:=E.

Inductive ImpProg: Type := 
  | Iskip: ImpProg
  | Iset (A:Type) (v:E.Var A) (expr:E.Expr A): ImpProg
  | Iif (cond:E.Expr bool) (p1 p2:ImpProg): ImpProg
  | Iseq (p1 p2:ImpProg): ImpProg
  | Iwhile (cond:E.Expr bool) (p:ImpProg): ImpProg.

Inductive exec: E.Env -> ImpProg -> E.Env -> Prop :=
 | exec_Iskip: 
    forall e, (exec e Iskip e)
 | exec_Iset:
    forall (A:Type) e x (expr: E.Expr A), 
     (exec e (Iset x expr) (E.upd x (E.eval expr e) e))
 | exec_Iif:
    forall e (cond: E.Expr bool) p1 p2 e', 
      (exec e (if (E.eval cond e) then p1 else p2) e') 
         -> (exec e (Iif cond p1 p2) e')
 | exec_Iseq:
    forall e p1 p2 e' e'',
      (exec e p1 e') 
       -> (exec e' p2 e'')    
         -> (exec e (Iseq p1 p2) e'')
 | exec_Iwhile:
    forall e cond p e', 
     (exec e (Iif cond (Iseq p (Iwhile cond p)) Iskip) e')
        -> (exec e (Iwhile cond p) e').

Lemma exec_Iif_true:
  forall e cond p1 p2 e', 
     (E.eval cond e)=true
      -> (exec e p1 e') 
         -> (exec e (Iif cond p1 p2) e').
Proof.
  intros e cond p1 p2 e' H1 H2.
  apply exec_Iif.
  rewrite H1; auto.
Qed.  

Lemma exec_Iif_false:
  forall e cond p1 p2 e', 
     (E.eval cond e)=false
      -> (exec e p2 e') 
         -> (exec e (Iif cond p1 p2) e').
Proof.
  intros e cond p1 p2 e' H1 H2.
  apply exec_Iif.
  rewrite H1; auto.
Qed.  

Definition Pred := E.Env -> Prop.

Definition wlp: ImpProg -> Pred -> Pred
 := fun prog post e => (forall e', (exec e prog e') -> (post e')).

Definition wp: ImpProg -> Pred -> Pred
 := fun prog post e => exists e', (exec e prog e') /\ (post e').

Notation "p |= q" := (forall e, (p e) -> (q e)) (at level 80, no associativity).
Notation "p {= post =}" := (wlp p post) (at level 70).
Notation "p [= post =]" := (wp p post) (at level 70).

End HLD.

Export HLD.

Module PHL<: HoareProofSystem := PartialHoareLogic(HLD). 
Module THL<: HoareProofSystem := TotalHoareLogic(HLD). 

Import THL.

Lemma wp_entails_wlp: forall prog post, prog [= post =] |= prog {= post =}.
Proof.
  unfold wp, wlp. intros prog post e H e' H'.
  dec2 e0 H.
  dec2 H0 H.
  rewrite (exec_deterministic H' H0).
  auto.
Qed.

End HoareLogic.

