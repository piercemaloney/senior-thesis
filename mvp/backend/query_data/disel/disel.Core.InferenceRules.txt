From mathcomp.ssreflect

Require Import ssreflect ssrbool ssrnat eqtype ssrfun seq.

From mathcomp

Require Import path.

Require Import Eqdep.

Require Import Relation_Operators.

From fcsl

Require Import pred prelude ordtype finmap pcm unionmap heap.

From DiSeL

Require Import Domain Freshness State EqTypeX DepMaps Protocols Worlds NetworkSem Rely.
(* Domain:
From mathcomp.ssreflect
Require Import ssreflect ssrbool ssrfun ssrnat eqtype seq.
From fcsl
Require Import axioms pred prelude.
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Module Poset.

Section RawMixin.

Record mixin_of (T : Type) := Mixin {
  mx_leq : T -> T -> Prop;
  _ : forall x, mx_leq x x;
  _ : forall x y, mx_leq x y -> mx_leq y x -> x = y;
  _ : forall x y z, mx_leq x y -> mx_leq y z -> mx_leq x z}.

End RawMixin.

Section ClassDef.

Record class_of T := Class {mixin : mixin_of T}.

Structure type : Type := Pack {sort : Type; _ : class_of sort; _ : Type}.
Local Coercion sort : type >-> Sortclass.

Variables (T : Type) (cT : type).
Definition class := let: Pack _ c _ as cT' := cT return class_of cT' in c.
Definition clone c of phant_id class c := @Pack T c T.

Definition pack (m0 : mixin_of T) :=
  fun m & phant_id m0 m => Pack (@Class T m) T.

Definition leq := mx_leq (mixin class).

End ClassDef.

Module Exports.
Coercion sort : type >-> Sortclass.
Notation poset := Poset.type.
Notation PosetMixin := Poset.Mixin.
Notation Poset T m := (@pack T _ m id).

Notation "[ 'poset' 'of' T 'for' cT ]" := (@clone T cT _ id)
  (at level 0, format "[ 'poset'  'of'  T  'for'  cT ]") : form_scope.
Notation "[ 'poset' 'of' T ]" := (@clone T _ _ id)
  (at level 0, format "[ 'poset'  'of'  T ]") : form_scope.

Notation "x <== y" := (Poset.leq x y) (at level 70).

Section Laws.
Variable T : poset.

Lemma poset_refl (x : T) : x <== x.

Lemma poset_asym (x y : T) : x <== y -> y <== x -> x = y.

Lemma poset_trans (y x z : T) : x <== y -> y <== z -> x <== z.

End Laws.

Hint Resolve poset_refl.

Add Parametric Relation (T : poset) : T (@Poset.leq T)
  reflexivity proved by (@poset_refl _)
  transitivity proved by (fun x y => @poset_trans _ y x) as poset_rel.

End Exports.

End Poset.

Export Poset.Exports.

Definition monotone (T1 T2 : poset) (f : T1 -> T2) :=
  forall x y, x <== y -> f x <== f y.

Section IdealDef.
Variable T : poset.

Structure ideal (P : T) := Ideal {id_val : T; id_pf : id_val <== P}.

Lemma relaxP (P1 P2 : T) : P1 <== P2 -> forall p, p <== P1 -> p <== P2.

Definition relax (P1 P2 : T) (x : ideal P1) (pf : P1 <== P2) :=
  Ideal (relaxP pf (id_pf x)).

End IdealDef.

Section SubPoset.
Variables (T : poset) (s : Pred T).

Local Notation tp := {x : T | x \In s}.

Definition sub_leq (p1 p2 : tp) := sval p1 <== sval p2.

Lemma sub_refl x : sub_leq x x.

Lemma sub_asym x y : sub_leq x y -> sub_leq y x -> x = y.

Lemma sub_trans x y z : sub_leq x y -> sub_leq y z -> sub_leq x z.

Definition subPosetMixin := PosetMixin sub_refl sub_asym sub_trans.
Definition subPoset := Eval hnf in Poset tp subPosetMixin.

End SubPoset.

Section PairPoset.
Variable (A B : poset).
Local Notation tp := (A * B)%type.

Definition pair_leq (p1 p2 : tp) := p1.1 <== p2.1 /\ p1.2 <== p2.2.

Lemma pair_refl x : pair_leq x x.

Lemma pair_asym x y : pair_leq x y -> pair_leq y x -> x = y.

Lemma pair_trans x y z : pair_leq x y -> pair_leq y z -> pair_leq x z.

Definition pairPosetMixin :=
  PosetMixin pair_refl pair_asym pair_trans.
Canonical pairPoset := Eval hnf in Poset tp pairPosetMixin.

End PairPoset.

Section FunPoset.
Variable (A : Type) (B : poset).
Local Notation tp := (A -> B).

Definition fun_leq (p1 p2 : tp) := forall x, p1 x <== p2 x.

Lemma fun_refl x : fun_leq x x.

Lemma fun_asym x y : fun_leq x y -> fun_leq y x -> x = y.

Lemma fun_trans x y z : fun_leq x y -> fun_leq y z -> fun_leq x z.

Definition funPosetMixin := PosetMixin fun_refl fun_asym fun_trans.
Canonical funPoset := Eval hnf in Poset tp funPosetMixin.

End FunPoset.

Section DFunPoset.
Variables (A : Type) (B : A -> poset).
Local Notation tp := (forall x, B x).

Definition dfun_leq (p1 p2 : tp) := forall x, p1 x <== p2 x.

Lemma dfun_refl x : dfun_leq x x.

Lemma dfun_asym x y : dfun_leq x y -> dfun_leq y x -> x = y.

Lemma dfun_trans x y z : dfun_leq x y -> dfun_leq y z -> dfun_leq x z.

Definition dfunPosetMixin :=
  PosetMixin dfun_refl dfun_asym dfun_trans.
Definition dfunPoset := Eval hnf in Poset tp dfunPosetMixin.

End DFunPoset.

Section IdealPoset.
Variable (T : poset) (P : T).

Definition ideal_leq (p1 p2 : ideal P) := id_val p1 <== id_val p2.

Lemma ideal_refl x : ideal_leq x x.

Lemma ideal_asym x y : ideal_leq x y -> ideal_leq y x -> x = y.

Lemma ideal_trans x y z : ideal_leq x y -> ideal_leq y z -> ideal_leq x z.

Definition idealPosetMixin :=
  PosetMixin ideal_refl ideal_asym ideal_trans.
Canonical idealPoset := Eval hnf in Poset (ideal P) idealPosetMixin.

End IdealPoset.

Section PropPoset.

Definition prop_leq (p1 p2 : Prop) := p1 -> p2.

Lemma prop_refl x : prop_leq x x.

Lemma prop_asym x y : prop_leq x y -> prop_leq y x -> x = y.

Lemma prop_trans x y z : prop_leq x y -> prop_leq y z -> prop_leq x z.

Definition propPosetMixin :=
  PosetMixin prop_refl prop_asym prop_trans.
Canonical propPoset := Eval hnf in Poset Prop propPosetMixin.

End PropPoset.

Module Lattice.

Section RawMixin.

Variable T : poset.

Record mixin_of := Mixin {
  mx_sup : Pred T -> T;
  _ : forall (s : Pred T) x, x \In s -> x <== mx_sup s;
  _ : forall (s : Pred T) x,
        (forall y, y \In s -> y <== x) -> mx_sup s <== x}.

End RawMixin.

Section ClassDef.

Record class_of (T : Type) := Class {
  base : Poset.class_of T;
  mixin : mixin_of (Poset.Pack base T)}.

Local Coercion base : class_of >-> Poset.class_of.

Structure type : Type := Pack {sort : Type; _ : class_of sort; _ : Type}.
Local Coercion sort : type >-> Sortclass.

Variables (T : Type) (cT : type).
Definition class := let: Pack _ c _ as cT' := cT return class_of cT' in c.
Definition clone c of phant_id class c := @Pack T c T.

Definition pack b0 (m0 : mixin_of (Poset.Pack b0 T)) :=
  fun m & phant_id m0 m => Pack (@Class T b0 m) T.

Definition sup (s : Pred cT) : cT := mx_sup (mixin class) s.

Definition poset := Poset.Pack class cT.

End ClassDef.

Module Exports.
Coercion base : class_of >-> Poset.class_of.
Coercion sort : type >-> Sortclass.
Coercion poset : type >-> Poset.type.
Canonical Structure poset.

Notation lattice := Lattice.type.
Notation LatticeMixin := Lattice.Mixin.
Notation Lattice T m := (@pack T _ _ m id).

Notation "[ 'lattice' 'of' T 'for' cT ]" := (@clone T cT _ id)
  (at level 0, format "[ 'lattice'  'of'  T  'for' cT ]") : form_scope.
Notation "[ 'lattice' 'of' T ]" := (@clone T _ _ id)
  (at level 0, format "[ 'lattice'  'of'  T ]") : form_scope.

Arguments Lattice.sup [cT].
Prenex Implicits Lattice.sup.
Notation sup := Lattice.sup.

Section Laws.
Variable T : lattice.

Lemma supP (s : Pred T) x : x \In s -> x <== sup s.

Lemma supM (s : Pred T) x : (forall y, y \In s -> y <== x) -> sup s <== x.

End Laws.

End Exports.

End Lattice.

Export Lattice.Exports.

Section Infimum.
Variable T : lattice.

Definition inf (s : Pred T) :=
  sup [Pred x : T | forall y, y \In s -> x <== y].

Lemma infP s : forall x, x \In s -> inf s <== x.

Lemma infM s : forall x, (forall y, y \In s -> x <== y) -> x <== inf s.

End Infimum.

Section Lat.
Variable T : lattice.

Definition lbot : T := sup Pred0.

Definition tarski_lfp (f : T -> T) := inf [Pred x : T | f x <== x].
Definition tarski_gfp (f : T -> T) := sup [Pred x : T | x <== f x].

Definition sup_closed (T : lattice) :=
  [Pred s : Pred T | forall d, d <=p s -> sup d \In s].

Definition sup_closure (T : lattice) (s : Pred T) :=
  [Pred p : T | forall t : Pred T, s <=p t -> t \In sup_closed T -> p \In t].

End Lat.

Arguments lbot [T].
Arguments sup_closed [T].
Arguments sup_closure [T].
Prenex Implicits sup_closed sup_closure.

Section BasicProperties.
Variable T : lattice.

Lemma sup_mono (s1 s2 : Pred T) : s1 <=p s2 -> sup s1 <== sup s2.

Lemma supE (s1 s2 : Pred T) : s1 =p s2 -> sup s1 = sup s2.

Lemma tarski_lfp_fixed (f : T -> T) :
        monotone f -> f (tarski_lfp f) = tarski_lfp f.

Lemma tarski_lfp_least f : forall x : T, f x = x -> tarski_lfp f <== x.

Lemma tarski_gfp_fixed (f : T -> T) :
        monotone f -> f (tarski_gfp f) = tarski_gfp f.

Lemma tarski_gfp_greatest f : forall x : T, f x = x -> x <== tarski_gfp f.

Lemma sup_clos_sub (s : Pred T) : s <=p sup_closure s.

Lemma sup_clos_min (s : Pred T) :
        forall t, s <=p t -> sup_closed t -> sup_closure s <=p t.

Lemma sup_closP (s : Pred T) : sup_closed (sup_closure s).

Lemma sup_clos_idemp (s : Pred T) : sup_closed s -> sup_closure s =p s.

Lemma sup_clos_mono (s1 s2 : Pred T) :
        s1 <=p s2 -> sup_closure s1 <=p sup_closure s2.

End BasicProperties.

Section SubLattice.
Variables (T : lattice) (s : Pred T) (C : sup_closed s).
Local Notation tp := (subPoset s).

Definition sub_sup' (u : Pred tp) : T :=
  sup [Pred x : T | exists y, y \In u /\ x = sval y].

Lemma sub_supX (u : Pred tp) : sub_sup' u \In s.

Definition sub_sup (u : Pred tp) : tp :=
  exist _ (sub_sup' u) (sub_supX u).

Lemma sub_supP (u : Pred tp) (x : tp) : x \In u -> x <== sub_sup u.

Lemma sub_supM (u : Pred tp) (x : tp) :
        (forall y, y \In u -> y <== x) -> sub_sup u <== x.

Definition subLatticeMixin := LatticeMixin sub_supP sub_supM.
Definition subLattice := Eval hnf in Lattice {x : T | x \In s} subLatticeMixin.

End SubLattice.

Section PairLattice.
Variables (A B : lattice).
Local Notation tp := (A * B)%type.

Definition pair_sup (s : Pred tp) : tp :=
            (sup [Pred p | exists f, p = f.1 /\ f \In s],
             sup [Pred p | exists f, p = f.2 /\ f \In s]).

Lemma pair_supP (s : Pred tp) (p : tp) : p \In s -> p <== pair_sup s.

Lemma pair_supM (s : Pred tp) (p : tp) :
        (forall q, q \In s -> q <== p) -> pair_sup s <== p.

Definition pairLatticeMixin := LatticeMixin pair_supP pair_supM.
Canonical pairLattice := Eval hnf in Lattice tp pairLatticeMixin.

End PairLattice.

Section FunLattice.
Variables (A : Type) (B : lattice).
Local Notation tp := (A -> B).

Definition fun_sup (s : Pred tp) : tp :=
  fun x => sup [Pred p | exists f, f \In s /\ p = f x].

Lemma fun_supP (s : Pred tp) (p : tp) : p \In s -> p <== fun_sup s.

Lemma fun_supM (s : Pred tp) (p : tp) :
        (forall q, q \In s -> q <== p) -> fun_sup s <== p.

Definition funLatticeMixin := LatticeMixin fun_supP fun_supM.
Canonical funLattice := Eval hnf in Lattice tp funLatticeMixin.

End FunLattice.

Section DFunLattice.
Variables (A : Type) (B : A -> lattice).
Local Notation tp := (dfunPoset B).

Definition dfun_sup (s : Pred tp) : tp :=
  fun x => sup [Pred p | exists f, f \In s /\ p = f x].

Lemma dfun_supP (s : Pred tp) (p : tp) :
        p \In s -> p <== dfun_sup s.

Lemma dfun_supM (s : Pred tp) (p : tp) :
       (forall q, q \In s -> q <== p) -> dfun_sup s <== p.

Definition dfunLatticeMixin := LatticeMixin dfun_supP dfun_supM.
Definition dfunLattice := Eval hnf in Lattice (forall x, B x) dfunLatticeMixin.

End DFunLattice.

Lemma sup_appE A (B : lattice) (s : Pred (A -> B)) (x : A) :
        sup s x = sup [Pred y : B | exists f, f \In s /\ y = f x].

Lemma sup_dappE A (B : A -> lattice) (s : Pred (dfunLattice B)) (x : A) :
        sup s x = sup [Pred y : B x | exists f, f \In s /\ y = f x].

Section IdealLattice.
Variables (T : lattice) (P : T).

Definition ideal_sup' (s : Pred (ideal P)) :=
  sup [Pred x | exists p, p \In s /\ id_val p = x].

Lemma ideal_supP' (s : Pred (ideal P)) : ideal_sup' s <== P.

Definition ideal_sup (s : Pred (ideal P)) := Ideal (ideal_supP' s).

Lemma ideal_supP (s : Pred (ideal P)) p :
        p \In s -> p <== ideal_sup s.

Lemma ideal_supM (s : Pred (ideal P)) p :
        (forall q, q \In s -> q <== p) -> ideal_sup s <== p.

Definition idealLatticeMixin := LatticeMixin ideal_supP ideal_supM.
Canonical idealLattice := Eval hnf in Lattice (ideal P) idealLatticeMixin.

End IdealLattice.

Section PropLattice.

Definition prop_sup (s : Pred Prop) : Prop := exists p, p \In s /\ p.

Lemma prop_supP (s : Pred Prop) p : p \In s -> p <== prop_sup s.

Lemma prop_supM (s : Pred Prop) p :
        (forall q, q \In s -> q <== p) -> prop_sup s <== p.

Definition propLatticeMixin := LatticeMixin prop_supP prop_supM.
Canonical propLattice := Eval hnf in Lattice Prop propLatticeMixin.

End PropLattice.

Lemma id_mono (T : poset) : monotone (@id T).

Arguments id_mono [T].
Prenex Implicits id_mono.

Lemma const_mono (T1 T2 : poset) (y : T2) : monotone (fun x : T1 => y).

Arguments const_mono [T1 T2 y].
Prenex Implicits const_mono.

Lemma comp_mono (T1 T2 T3 : poset) (f1 : T2 -> T1) (f2 : T3 -> T2) :
        monotone f1 -> monotone f2 -> monotone (f1 \o f2).

Arguments comp_mono [T1 T2 T3 f1 f2].
Prenex Implicits comp_mono.

Lemma proj1_mono (T1 T2 : poset) : monotone (@fst T1 T2).

Lemma proj2_mono (T1 T2 : poset) : monotone (@snd T1 T2).

Arguments proj1_mono [T1 T2].
Arguments proj2_mono [T1 T2].
Prenex Implicits proj1_mono proj2_mono.

Lemma diag_mono (T : poset) : monotone (fun x : T => (x, x)).

Arguments diag_mono [T].
Prenex Implicits diag_mono.

Lemma app_mono A (T : poset) (x : A) : monotone (fun f : A -> T => f x).

Arguments app_mono [A T].
Prenex Implicits app_mono.

Lemma dapp_mono A (T : A -> poset) (x : A) :
  monotone (fun f : dfunPoset T => f x).

Arguments dapp_mono [A T].
Prenex Implicits dapp_mono.

Lemma prod_mono (S1 S2 T1 T2 : poset) (f1 : S1 -> T1) (f2 : S2 -> T2) :
        monotone f1 -> monotone f2 -> monotone (f1 \* f2).

Arguments prod_mono [S1 S2 T1 T2 f1 f2].
Prenex Implicits prod_mono.

Section Chains.
Variable T : poset.

Definition chain_axiom (s : Pred T) :=
  (exists d, d \In s) /\
  (forall x y, x \In s -> y \In s -> x <== y \/ y <== x).

Structure chain := Chain {
  pred_of :> Pred T;
  _ : chain_axiom pred_of}.

Canonical chainPredType := @mkPredType T chain pred_of.

End Chains.

Lemma chainE (T : poset) (s1 s2 : chain T) :
        s1 = s2 <-> pred_of s1 =p pred_of s2.

Section ImageChain.
Variables (T1 T2 : poset) (s : chain T1) (f : T1 -> T2) (M : monotone f).

Lemma image_chainP :
        chain_axiom [Pred x2 : T2 | exists x1, x2 = f x1 /\ x1 \In s].

Definition image_chain := Chain image_chainP.

End ImageChain.

Notation "[ f '^^' s 'by' M ]" := (@image_chain _ _ s f M)
  (at level 0, format "[ f  '^^'  s  'by'  M ]") : form_scope.

Section ChainId.
Variables (T : poset) (s : chain T).

Lemma id_chainE (M : monotone id) : [id ^^ s by M] = s.

End ChainId.

Section ChainConst.
Variables (T1 T2 : poset) (y : T2).

Lemma const_chainP : chain_axiom (Pred1 y).

Definition const_chain := Chain const_chainP.

Lemma const_chainE s : [_ ^^ s by @const_mono T1 T2 y] = const_chain.

End ChainConst.

Section ChainCompose.
Variables (T1 T2 T3 : poset) (f1 : T2 -> T1) (f2 : T3 -> T2).
Variables (s : chain T3) (M1 : monotone f1) (M2 : monotone f2).

Lemma comp_chainE :
        [f1 ^^ [f2 ^^ s by M2] by M1] = [f1 \o f2 ^^ s by comp_mono M1 M2].

End ChainCompose.

Section ProjChain.
Variables (T1 T2 : poset) (s : chain [poset of T1 * T2]).

Definition proj1_chain := [@fst _ _ ^^ s by proj1_mono].
Definition proj2_chain := [@snd _ _ ^^ s by proj2_mono].

End ProjChain.

Section DiagChain.
Variable (T : poset) (s : chain T).

Definition diag_chain := [_ ^^ s by @diag_mono T].

Lemma proj1_diagE : proj1_chain diag_chain = s.

Lemma proj2_diagE : proj2_chain diag_chain = s.

End DiagChain.

Section AppChain.
Variables (A : Type) (T : poset) (s : chain [poset of A -> T]).

Definition app_chain x := [_ ^^ s by app_mono x].

End AppChain.

Section DAppChain.
Variables (A : Type) (T : A -> poset) (s : chain (dfunPoset T)).

Definition dapp_chain x := [_ ^^ s by dapp_mono x].

End DAppChain.

Section ProdChain.
Variables (S1 S2 T1 T2 : poset) (f1 : S1 -> T1) (f2 : S2 -> T2).
Variables (M1 : monotone f1) (M2 : monotone f2).
Variable (s : chain [poset of S1 * S2]).

Definition prod_chain := [f1 \* f2 ^^ s by prod_mono M1 M2].

Lemma proj1_prodE : proj1_chain prod_chain = [f1 ^^ proj1_chain s by M1].

Lemma proj2_prodE : proj2_chain prod_chain = [f2 ^^ proj2_chain s by M2].

End ProdChain.

Module CPO.

Section RawMixin.

Record mixin_of (T : poset) := Mixin {
  mx_bot : T;
  mx_lim : chain T -> T;
  _ : forall x, mx_bot <== x;
  _ : forall (s : chain T) x, x \In s -> x <== mx_lim s;
  _ : forall (s : chain T) x,
        (forall y, y \In s -> y <== x) -> mx_lim s <== x}.

End RawMixin.

Section ClassDef.

Record class_of (T : Type) := Class {
  base : Poset.class_of T;
  mixin : mixin_of (Poset.Pack base T)}.

Local Coercion base : class_of >-> Poset.class_of.

Structure type : Type := Pack {sort; _ : class_of sort; _ : Type}.
Local Coercion sort : type >-> Sortclass.

Variables (T : Type) (cT : type).
Definition class := let: Pack _ c _ as cT' := cT return class_of cT' in c.
Definition clone c of phant_id class c := @Pack T c T.

Definition pack b0 (m0 : mixin_of (Poset.Pack b0 T)) :=
  fun m & phant_id m0 m => Pack (@Class T b0 m) T.

Definition poset := Poset.Pack class cT.
Definition lim (s : chain poset) : cT := mx_lim (mixin class) s.
Definition bot : cT := mx_bot (mixin class).

End ClassDef.

Module Import Exports.
Coercion base : class_of >-> Poset.class_of.
Coercion sort : type >-> Sortclass.
Coercion poset : type >-> Poset.type.
Canonical Structure poset.

Notation cpo := type.
Notation CPOMixin := Mixin.
Notation CPO T m := (@pack T _ _ m id).

Notation "[ 'cpo' 'of' T 'for' cT ]" := (@clone T cT _ idfun)
  (at level 0, format "[ 'cpo'  'of'  T  'for'  cT ]") : form_scope.
Notation "[ 'cpo' 'of' T ]" := (@clone T _ _ id)
  (at level 0, format "[ 'cpo'  'of'  T ]") : form_scope.

Arguments CPO.bot [cT].
Arguments CPO.lim [cT].
Prenex Implicits CPO.lim.
Prenex Implicits CPO.bot.
Notation lim := CPO.lim.
Notation bot := CPO.bot.

Section Laws.
Variable D : cpo.

Lemma botP (x : D) : bot <== x.

Lemma limP (s : chain D) x : x \In s -> x <== lim s.

Lemma limM (s : chain D) x : (forall y, y \In s -> y <== x) -> lim s <== x.

End Laws.

End Exports.

End CPO.

Export CPO.Exports.

Hint Resolve botP.

Section LiftChain.
Variable (D : cpo) (s : chain D).

Hint Resolve botP.

Lemma lift_chainP : chain_axiom [Pred x : D | x = bot \/ x \In s].

Definition lift_chain := Chain lift_chainP.

End LiftChain.

Section PairCPO.
Variables (A B : cpo).
Local Notation tp := [poset of A * B].

Definition pair_bot : tp := (bot, bot).

Definition pair_lim (s : chain tp) : tp :=
  (lim (proj1_chain s), lim (proj2_chain s)).

Lemma pair_botP x : pair_leq pair_bot x.

Lemma pair_limP (s : chain tp) x : x \In s -> x <== pair_lim s.

Lemma pair_limM (s : chain tp) x :
        (forall y, y \In s -> y <== x) -> pair_lim s <== x.

Definition pairCPOMixin := CPOMixin pair_botP pair_limP pair_limM.
Canonical pairCPO := Eval hnf in CPO (A * B) pairCPOMixin.

End PairCPO.

Section FunCPO.
Variable (A : Type) (B : cpo).
Local Notation tp := [poset of A -> B].

Definition fun_bot : tp := fun x => bot.

Definition fun_lim (s : chain tp) : tp :=
  fun x => lim (app_chain s x).

Lemma fun_botP x : fun_leq fun_bot x.

Lemma fun_limP (s : chain tp) x : x \In s -> x <== fun_lim s.

Lemma fun_limM (s : chain tp) x :
        (forall y, y \In s -> y <== x) -> fun_lim s <== x.

Definition funCPOMixin := CPOMixin fun_botP fun_limP fun_limM.
Canonical funCPO := Eval hnf in CPO (A -> B) funCPOMixin.

End FunCPO.

Section DFunCPO.
Variable (A : Type) (B : A -> cpo).
Local Notation tp := (dfunPoset B).

Definition dfun_bot : tp := fun x => bot.

Definition dfun_lim (s : chain tp) : tp :=
  fun x => lim (dapp_chain s x).

Lemma dfun_botP x : dfun_bot <== x.

Lemma dfun_limP (s : chain tp) x : x \In s -> x <== dfun_lim s.

Lemma dfun_limM (s : chain tp) x :
        (forall y, y \In s -> y <== x) -> dfun_lim s <== x.

Definition dfunCPOMixin := CPOMixin dfun_botP dfun_limP dfun_limM.
Definition dfunCPO := Eval hnf in CPO (forall x, B x) dfunCPOMixin.

End DFunCPO.

Section PropCPO.
Local Notation tp := [poset of Prop].

Definition prop_bot : tp := False.

Definition prop_lim (s : chain tp) : tp := exists p, p \In s /\ p.

Lemma prop_botP x : prop_bot <== x.

Lemma prop_limP (s : chain tp) p : p \In s -> p <== prop_lim s.

Lemma prop_limM (s : chain tp) p :
        (forall q, q \In s -> q <== p) -> prop_lim s <== p.

Definition propCPOMixin := CPOMixin prop_botP prop_limP prop_limM.
Canonical propCPO := Eval hnf in CPO Prop propCPOMixin.

End PropCPO.

Section PredCPO.
Variable A : Type.

Definition predCPOMixin := funCPOMixin A propCPO.
Canonical predCPO := Eval hnf in CPO (Pred A) predCPOMixin.

End PredCPO.

Section LatticeCPO.
Variable A : lattice.
Local Notation tp := (Lattice.poset A).

Definition lat_bot : tp := lbot.

Definition lat_lim (s : chain tp) : tp := sup s.

Lemma lat_botP x : lat_bot <== x.

Lemma lat_limP (s : chain tp) x : x \In s -> x <== lat_lim s.

Lemma lat_limM (s : chain tp) x :
        (forall y, y \In s -> y <== x) -> lat_lim s <== x.

Definition latCPOMixin := CPOMixin lat_botP lat_limP lat_limM.
Definition latCPO := Eval hnf in CPO tp latCPOMixin.

End LatticeCPO.

Section AdmissibleClosure.
Variable T : cpo.

Definition chain_closed :=
  [Pred s : Pred T |
     bot \In s /\ forall d : chain T, d <=p s -> lim d \In s].

Definition chain_closure (s : Pred T) :=
  [Pred p : T | forall t : Pred T, s <=p t -> chain_closed t -> p \In t].

Lemma chain_clos_sub (s : Pred T) : s <=p chain_closure s.

Lemma chain_clos_min (s : Pred T) t :
        s <=p t -> chain_closed t -> chain_closure s <=p t.

Lemma chain_closP (s : Pred T) : chain_closed (chain_closure s).

Lemma chain_clos_idemp (s : Pred T) :
        chain_closed s -> chain_closure s =p s.

Lemma chain_clos_mono (s1 s2 : Pred T) :
        s1 <=p s2 -> chain_closure s1 <=p chain_closure s2.

Lemma chain_closI (s1 s2 : Pred T) :
       chain_closed s1 -> chain_closed s2 -> chain_closed (PredI s1 s2).

End AdmissibleClosure.

Arguments chain_closed [T].
Prenex Implicits chain_closed.

Lemma chain_clos_diag (T : cpo) (s : Pred (T * T)) :
        chain_closed s -> chain_closed [Pred t : T | (t, t) \In s].

Section SubCPO.
Variables (D : cpo) (s : Pred D) (C : chain_closed s).
Local Notation tp := (subPoset s).

Definition sub_bot := exist _ (@bot D) (proj1 C).

Lemma sub_botP (x : tp) : sval sub_bot <== sval x.

Lemma sval_mono : monotone (sval : tp -> D).

Lemma sub_limX (u : chain tp) : lim [sval ^^ u by sval_mono] \In s.

Definition sub_lim (u : chain tp) : tp :=
  exist _ (lim [sval ^^ u by sval_mono]) (sub_limX u).

Lemma sub_limP (u : chain tp) x : x \In u -> x <== sub_lim u.

Lemma sub_limM (u : chain tp) x :
        (forall y, y \In u -> y <== x) -> sub_lim u <== x.

Definition subCPOMixin := CPOMixin sub_botP sub_limP sub_limM.
Definition subCPO := Eval hnf in CPO {x : D | x \In s} subCPOMixin.

End SubCPO.

Lemma lim_mono (D : cpo) (s1 s2 : chain D) :
        s1 <=p s2 -> lim s1 <== lim s2.

Lemma limE (D : cpo) (s1 s2 : chain D) :
        s1 =p s2 -> lim s1 = lim s2.

Lemma lim_liftE (D : cpo) (s : chain D) :
        lim s = lim (lift_chain s).

Lemma lim_appE A (D : cpo) (s : chain [cpo of A -> D]) (x : A) :
        lim s x = lim (app_chain s x).

Lemma lim_dappE A (D : A -> cpo) (s : chain (dfunCPO D)) (x : A) :
        lim s x = lim (dapp_chain s x).

Section Continuity.
Variables (D1 D2 : cpo) (f : D1 -> D2).

Definition continuous :=
  exists M : monotone f,
  forall s : chain D1, f (lim s) = lim [f ^^ s by M].

Lemma cont_mono : continuous -> monotone f.

Lemma contE (s : chain D1) (C : continuous) :
       f (lim s) = lim [f ^^ s by cont_mono C].

Lemma nat_asym x y : x <= y -> y <= x -> x = y.

Lemma nat_trans x y z : x <= y -> y <= z -> x <= z.

Definition natPosetMixin := PosetMixin nat_refl nat_asym nat_trans.
Canonical natPoset := Eval hnf in Poset nat natPosetMixin.

End NatPoset.

Section NatChain.

Lemma nat_chain_axiom : chain_axiom (@PredT nat).

Definition nat_chain := Chain nat_chain_axiom.

End NatChain.

Section Kleene.
Variables (D : cpo) (f : D -> D) (C : continuous f).

Fixpoint pow m := if m is n.+1 then f (pow n) else bot.

Lemma pow_mono : monotone pow.

Definition pow_chain := [pow ^^ nat_chain by pow_mono].

Lemma reindex : pow_chain =p lift_chain [f ^^ pow_chain by cont_mono C].

Definition kleene_lfp := lim pow_chain.

Lemma kleene_lfp_fixed : f kleene_lfp = kleene_lfp.

Lemma kleene_lfp_least : forall x, f x = x -> kleene_lfp <== x.

End Kleene.

Module Exports.
Notation kleene_lfp := kleene_lfp.
Notation kleene_lfp_fixed := kleene_lfp_fixed.
Notation kleene_lfp_least := kleene_lfp_least.
End Exports.

End Kleene.

Export Kleene.Exports.

Lemma id_cont (D : cpo) : continuous (@id D).

Arguments id_cont [D].
Prenex Implicits id_cont.

Lemma const_cont (D1 D2 : cpo) (y : D2) : continuous (fun x : D1 => y).

Arguments const_cont [D1 D2 y].
Prenex Implicits const_cont.

Lemma comp_cont (D1 D2 D3 : cpo) (f1 : D2 -> D1) (f2 : D3 -> D2) :
        continuous f1 -> continuous f2 -> continuous (f1 \o f2).

Arguments comp_cont [D1 D2 D3 f1 f2].
Prenex Implicits comp_cont.

Lemma proj1_cont (D1 D2 : cpo) : continuous (@fst D1 D2).

Lemma proj2_cont (D1 D2 : cpo) : continuous (@snd D1 D2).

Arguments proj1_cont [D1 D2].
Arguments proj2_cont [D1 D2].
Prenex Implicits proj1_cont proj2_cont.

Lemma diag_cont (D : cpo) : continuous (fun x : D => (x, x)).

Arguments diag_cont [D].
Prenex Implicits diag_cont.

Lemma app_cont A (D : cpo) x : continuous (fun f : A -> D => f x).

Lemma dapp_cont A (D : A -> cpo) x : continuous (fun f : dfunCPO D => f x).

Arguments app_cont [A D].
Arguments dapp_cont [A D].
Prenex Implicits app_cont dapp_cont.

Lemma prod_cont (S1 S2 T1 T2 : cpo) (f1 : S1 -> T1) (f2 : S2 -> T2) :
        continuous f1 -> continuous f2 -> continuous (f1 \* f2).

Arguments prod_cont [S1 S2 T1 T2 f1 f2].
Prenex Implicits prod_cont. *)
(* Freshness:
From mathcomp.ssreflect
Require Import ssreflect ssrbool ssrnat eqtype ssrfun seq.
From mathcomp
Require Import path.
From fcsl
Require Import pred prelude ordtype finmap pcm unionmap.
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Section Keys.
Variables (K : ordType) (V : Type) (U : union_map_class K V).
Implicit Types (k : K) (v : V) (f : U).

Lemma keys_last_mono f1 f2 k :
        path oleq k (dom f1) ->
        path oleq k (dom f2) ->
        (forall x, x \in dom f1 -> x \in dom f2) ->
        oleq (last k (dom f1)) (last k (dom f2)).

End Keys.

Section FreshLastKey.
Variable V : Type.
Implicit Type f : union_map [ordType of nat] V.

Definition last_key f := last 0 (dom f).

Lemma last_key0 : last_key Unit = 0.

Lemma last_key_dom f : valid f -> last_key f \notin dom f -> f = Unit.

Lemma dom_last_key f :  valid f -> ~~ empb f -> last_key f \in dom f.

Lemma last_key_max f x : x \in dom f -> x <= last_key f.

Lemma max_key_last f x :
        x \in dom f -> {in dom f, forall y, y <= x} -> last_key f = x.

Lemma last_keyPt (x : nat) v : last_key (x \\-> v) = x.

Lemma hist_path f : path oleq 0 (dom f).

Lemma last_key_mono f1 f2 :
        {subset dom f1 <= dom f2} -> last_key f1 <= last_key f2.

Lemma last_keyfUn f1 f2 :
        valid (f1 \+ f2) -> last_key f1 <= last_key (f1 \+ f2).

Lemma last_keyUnf f1 f2 :
        valid (f1 \+ f2) -> last_key f2 <= last_key (f1 \+ f2).

Definition fresh f := (last_key f).+1.

Lemma dom_ordfresh f x : x \in dom f -> x < fresh f.

Lemma dom_freshn f n : fresh f + n \notin dom f.

Lemma dom_fresh f : fresh f \notin dom f.

Lemma valid_fresh f v : valid (f \+ fresh f \\-> v) = valid f.

Lemma valid_fresh' f v i w :
  valid (f \+ i \\-> w) ->
  valid (f \+ fresh (f \+ i \\-> w) \\-> v).

Lemma last_fresh f v : valid f -> last_key (f \+ fresh f \\-> v) = fresh f.

End FreshLastKey. *)
(* State:
From mathcomp.ssreflect
Require Import ssreflect ssrbool ssrnat eqtype ssrfun seq.
From mathcomp
Require Import path.
Require Import Eqdep.
Require Import Relation_Operators.
From fcsl
Require Import pred prelude ordtype finmap pcm unionmap heap.
From DiSeL
Require Import Freshness DepMaps EqTypeX.
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Section TaggedMessages. 

  Structure TaggedMessage :=
    TMsg {
        tag: nat;
                tms_cont :> seq nat          
      }.

End TaggedMessages.

Section Shared.

  Definition Label := [ordType of nat].

  Structure msg (mtype : Type) :=
    Msg {content  : mtype;
         from     : nat;
         to       : nat;
         active   : bool }.

  Definition mid := [ordType of nat].

  Definition soup : Type :=
    union_map mid (msg (TaggedMessage)).

  Variables (s: soup) (V: valid s).

  Definition post_msg m : soup * mid :=
    let: f := fresh s in (s \+ f \\-> m, f).

  Lemma post_valid m :  valid (post_msg m).1.

  Lemma post_fresh m : (post_msg m).2 \notin dom s.

  Definition mark_msg T (m : msg T) : msg T :=
    Msg (content m) (from m) (to m) false.

  Definition consume_msg (s : soup) (id : mid) : soup :=
    let: mr := find id s in
    if mr is Some m then upd id (mark_msg m) s else s.

  Definition is_active (id : mid) :=
    exists m, find id s = Some m /\ active m.

  Definition is_consumed (id : mid) :=
    exists m, find id s = Some m /\ ~~ active m.

  Lemma find_consume s' (id: mid) m:
    valid s' -> find id s' = Some m ->
    find id (consume_msg s' id) = Some (mark_msg m).

  Lemma find_mark m s' msg :
    valid s' -> find m (consume_msg s' m) = Some msg ->
    exists msg', find m s' = Some msg' /\ msg = mark_msg msg'.

  Lemma mark_other m m' s' :
    valid s' -> m' == m = false -> find m' (consume_msg s' m) = find m' s'.

  Lemma consume_valid s' m : valid s' -> valid (consume_msg s' m).

  Lemma consumeUn (s': soup) (i : mid) mm
        (j : mid) : valid (s' \+ i \\-> mm) ->
    consume_msg (s' \+ i \\-> mm) j = 
    if i == j then s' \+ i \\-> mark_msg mm
    else (consume_msg s' j) \+ (i \\-> mm).

  Notation "'{{' m 'in' s 'at' id '}}'" := (find id s = Some m).
  Notation "'{{' m 'in' s '}}'" := (exists id, {{m in s at id}}).

End Shared.

Section Local.

  Variable U : Type.

  Definition nid := nat.

  Definition lstate_type := union_map [ordType of nid] U.

End Local.

Section Statelets.

  Structure dstatelet  :=
    DStatelet {
                dstate     : lstate_type heap;
        dsoup      : soup
    }.

  Fixpoint empty_lstate (ns : seq nid) :=
    if ns is n :: ns'
    then n \\-> Heap.empty \+ (empty_lstate ns')
    else  Unit.
    
  Definition empty_dstatelet : dstatelet :=
    @DStatelet (empty_lstate [::]) Unit.

  Lemma valid_mt_soup : valid (dsoup empty_dstatelet).

  Lemma valid_mt_state  : valid (dstate empty_dstatelet).

  Lemma mt_nodes : dom (dstate empty_dstatelet) =i [::].

End Statelets.

Module StateGetters.
Section StateGetters.

Definition state := union_map Label dstatelet.

Definition getStatelet (s: state) (i : Label) : dstatelet :=
  match find i s with
  | Some d => d
  | None => empty_dstatelet
  end.

End StateGetters.
End StateGetters.

Export StateGetters. *)
(* EqTypeX:
From mathcomp.ssreflect
Require Import ssreflect ssrbool ssrnat eqtype ssrfun seq.
From mathcomp
Require Import path.
Require Import Eqdep.
Require Import Relation_Operators.

Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Module EqualityX.

Definition axiom T (e : rel T) := forall x y, reflect (x = y) (e x y).

Structure mixin_of T := Mixin {op : rel T; _ : axiom op}.
Notation class_of := mixin_of (only parsing).

Section ClassDef.

Structure type := Pack {sort; _ : class_of sort; _ : Type}.
Local Coercion sort : type >-> Sortclass.
Variables (T : Type) (cT : type).

Definition class := let: Pack _ c _ := cT return class_of cT in c.

Definition pack c := @Pack T c T.
Definition clone := fun c & cT -> T & phant_id (pack c) cT => pack c.

End ClassDef.

Module Exports.
Coercion sort : type >-> Sortclass.
Notation eqTypeX := type.
Notation EqMixinX := Mixin.
Notation EqTypeX T m := (@pack T m).
End Exports.

End EqualityX.
Export EqualityX.Exports.

Section EqualityConversion.

Variable U: eqTypeX.
Definition eq_opX T := EqualityX.op (EqualityX.class T).

Lemma eqxP : Equality.axiom (@eq_opX U).

Canonical eqMixinX := EqMixin eqxP.
Canonical eqTypeX' := EqType U eqMixinX.                                   

End EqualityConversion. *)
(* DepMaps:
From mathcomp.ssreflect
Require Import ssreflect ssrbool ssrnat eqtype ssrfun seq.
From mathcomp
Require Import path.
Require Import Eqdep.
Require Import Relation_Operators.
From fcsl
Require Import pred prelude ordtype finmap pcm unionmap heap.
From DiSeL
Require Import Freshness EqTypeX.
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Module DepMaps.

Section DepMaps.

Definition Label := [ordType of nat].

Variable V : Type.
Variable labF: V -> Label.

Definition dmDom (u : union_map Label V) : bool :=
    all (fun l => if find l u is Some p then (labF p) == l else false) (dom u).

Record depmap := DepMap {
   dmap : union_map Label V;
   pf   : dmDom dmap;
}.

Section PCMOps.

Variable dm : depmap.

Lemma dmDom_unit : dmDom Unit.

Definition unit := DepMap dmDom_unit.

End PCMOps.

Section DJoin.

Variables (dm1 dm2 : depmap). 

Lemma dmDom_join um1 um2:
  dmDom um1 -> dmDom um2 -> dmDom (um1 \+ um2).

Definition join : depmap := DepMap (dmDom_join (@pf dm1) (@pf dm2)).

Definition valid (dm : depmap) := valid (dmap dm).

End DJoin.

End DepMaps.

Section PCMLaws.

Variables (V : Type) (labF: V -> [ordType of nat]).
Implicit Type f : depmap labF.

Local Notation "f1 \+ f2" := (join f1 f2)
                               (at level 43, left associativity).

Local Notation unit := (unit labF).

Lemma joinC f1 f2 : f1 \+ f2 = f2 \+ f1.

Lemma joinCA f1 f2 f3 : f1 \+ (f2 \+ f3) = f2 \+ (f1 \+ f3).

Lemma joinA f1 f2 f3 : f1 \+ (f2 \+ f3) = (f1 \+ f2) \+ f3.

Lemma validL f1 f2 : valid (f1 \+ f2) -> valid f1.

Lemma unitL f : unit \+ f = f.

Lemma validU : valid unit.

End PCMLaws.

Module Exports.
Section Exports.
Variable V : Type.
Variable labF: V -> Label.
Definition depmap := depmap.
Definition DepMap := DepMap.

Lemma dep_unit (d : depmap labF) : dmap d = Unit -> d = unit labF.

Coercion dmap := dmap.
Definition ddom (d : depmap labF) := dom (dmap d).
Definition dfind x (d : depmap labF) := find x (dmap d).

Definition depmap_classPCMMixin :=
  PCMMixin (@joinC V labF) (@joinA V labF) (@unitL V labF) (@validL V labF) (validU labF).

Canonical depmap_classPCM := Eval hnf in PCM (depmap labF) depmap_classPCMMixin.

End Exports.
End Exports.

End DepMaps.

Export DepMaps.Exports. *)
(* Protocols:
From mathcomp.ssreflect
Require Import ssreflect ssrbool ssrnat eqtype ssrfun seq.
From mathcomp
Require Import path.
Require Import Eqdep.
Require Import Relation_Operators.
From fcsl
Require Import pred prelude ordtype finmap pcm unionmap heap.
From DiSeL
Require Import Freshness State EqTypeX.
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Definition getLocal (n : nid) (d : dstatelet) : heap :=
  match find n (dstate d) with
  | Some h => h
  | None => Unit
  end.

Lemma getLocalU n m d s :
  valid (dstate d) -> m \in dom (dstate d) ->
  getLocal n d = (getLocal n {| dstate := upd m (getLocal m d) (dstate d); dsoup := s |}).
        
Module Coherence.

Section CohDef.

Variable nodes: dstatelet -> pred nid.

Notation protocol_soup  := (soup (TaggedMessage)).

Structure mixin_of (coh : Pred dstatelet) := Mixin {
    _   : forall d, coh d -> valid (dstate d);
    _   : forall d, coh d -> valid (dsoup d);
    _   : forall d, coh d -> dom (dstate d) =i nodes d;
}.

End CohDef.

Section ClassDef.

Variable nodes: dstatelet -> pred nid.

Notation class_of := mixin_of (only parsing).

Structure cohpred : Type := Pack {sort : dstatelet -> Prop;
                                  _ : class_of nodes sort}.
Local Coercion sort : cohpred >-> Funclass.

Variables (T : dstatelet -> Prop) (cT : cohpred).

Definition class := let: Pack _ c as cT' := cT
                    return class_of nodes cT' in c.

Definition pack c := @Pack T c.
Definition clone := fun c & T = cT & phant_id (pack c) cT => pack c. 

End ClassDef.

Module Exports.
Section Exports.

Variable Lstate : Type.
Variable nodes: dstatelet -> pred nid.

Coercion sort : cohpred >-> Funclass.
Definition cohpred := cohpred.
Definition CohPredMixin := Mixin.
Definition CohPred T m := (@pack T m).

Notation "[ 'cohPredMixin' 'of' T ]" := (class _ : mixin_of T)
  (at level 0, format "[ 'cohPredMixin'  'of'  T ]") : form_scope.
Notation "[ 'cohpred' 'of' T 'for' C ]" := (@clone T C _ (erefl _) id)
  (at level 0, format "[ 'cohpred'  'of'  T  'for'  C ]") : form_scope.
Notation "[ 'cohpred' 'of' T ]" := (@clone T _ _ (erefl _) id)
  (at level 0, format "[ 'cohpred'  'of'  T ]") : form_scope.

Canonical cohpred_PredType := mkPredType (@sort nodes).

Variable coh : cohpred nodes.

Lemma cohVl d : d \In coh -> valid (dstate d).

Lemma cohVs d : d \In coh -> valid (dsoup d).

Lemma cohDom d : d \In coh -> dom (dstate d) =i nodes d.

End Exports.
End Exports.
End Coherence.

Export Coherence.Exports.

Module Transitions.
Section Transitions.

Variable nodes: dstatelet -> pred nid.

Variable coh : cohpred nodes.

Notation lstate := heap%type.

Definition send_step_t (send_safe : nid -> nid -> dstatelet -> seq nat -> Prop) :=
  forall (this to : nid) (d : dstatelet)
         (msg : seq nat) (pf : send_safe this to d msg),
    option lstate.

Definition s_step_coh_t t_snd
           (send_safe : nid -> nid -> dstatelet -> seq nat -> Prop)
           (send_step : send_step_t send_safe) :=
  forall this to d msg (pf : send_safe this to d msg) b,
    let: f := dstate d in
    let: s := dsoup d  in
    Some b = @send_step this to d msg pf ->         
    let: f' := upd this b f in
    let: tms := TMsg t_snd msg in 
    let: s' := (post_msg s (Msg tms this to true)).1 in 
    coh (DStatelet f' s').

Structure send_trans := SendTrans
    {
      t_snd : nat;

      send_safe : nid -> nid -> dstatelet -> seq nat -> Prop;
      s_safe_coh : forall this to d m, send_safe this to d m -> coh d;
      s_safe_in  : forall this to d m, send_safe this to d m ->
                                       this \in nodes d /\ to \in nodes d;  

      send_step : send_step_t send_safe;

      s_safe_def : forall this to d msg,
          send_safe this to d msg <->
          exists b pf, @send_step this to d msg pf = Some b;

      s_step_coh : s_step_coh_t t_snd send_step 
    }.

Definition receive_step_t :=
  forall (this from: nid) (m : seq nat)
         (d : dstatelet) (pf : coh d)
         (pf' : this \in nodes d), lstate.

Definition r_step_coh_t (msg_wf : forall d, coh d -> nid -> nid -> TaggedMessage -> bool)
           t_rcv (receive_step : receive_step_t) :=
  forall (d : dstatelet) from this i (C : coh d) (pf' : this \in nodes d)
         (m : TaggedMessage),
    let: f := dstate d in
    let: s := dsoup d  in
    this \in dom f ->
    find i s = Some (Msg m from this true) ->
    msg_wf d C this from m -> tag m = t_rcv ->
    let: loc' := receive_step this from m d C pf' in
    let: s'' := consume_msg s i in
    let: f' := upd this loc' f in
    coh (DStatelet f' s'').

Structure receive_trans := ReceiveTrans
    {
      t_rcv : nat;

      msg_wf : forall d, coh d -> nid -> nid -> TaggedMessage -> bool;

      receive_step : receive_step_t;

      r_step_coh : r_step_coh_t msg_wf t_rcv receive_step
    }.

End Transitions.

Module Exports.

Definition SendTrans := SendTrans.
Definition send_trans := send_trans.
Definition ReceiveTrans := ReceiveTrans.
Definition receive_trans := receive_trans.

Definition t_snd := t_snd.
Definition send_safe := send_safe.
Definition send_step := send_step.
Definition send_step_t := send_step_t.

Definition s_safe_coh := s_safe_coh.
Definition s_safe_in := s_safe_in.
Definition s_safe_def := s_safe_def.
Definition s_step_coh := s_step_coh.
Definition s_step_coh_t := s_step_coh_t.

Definition t_rcv := t_rcv.
Definition msg_wf := msg_wf.

Definition receive_step := receive_step.
Definition receive_step_t := receive_step_t.
Definition r_step_coh := r_step_coh.
Definition r_step_coh_t := r_step_coh_t.

End Exports.

End Transitions.

Export Transitions.Exports.

Module Protocols.
Section Protocols.

Definition snd_tags {nodes} {coh : cohpred nodes}
           (sts : seq (send_trans coh)) := 
  map (@t_snd nodes _) sts.

Definition rcv_tags {nodes} {coh : cohpred nodes} (sts : seq (receive_trans coh)) :=
  map (@t_rcv nodes _) sts.

Structure protocol := Protocol {
  nodes: dstatelet -> pred nid;
  plab : Label;                        
  coh : cohpred nodes ;
  snd_trans : seq (send_trans coh);
  rcv_trans : seq (receive_trans coh);

  snd_uniq : uniq (snd_tags snd_trans);
  rcv_uniq : uniq (rcv_tags rcv_trans);
}.

End Protocols.

Module Exports.
Section Exports.

Definition protocol := protocol.
Definition Protocol := Protocol.
Definition plab := plab.
Definition nodes := nodes.
Definition coh := coh.
Definition snd_trans := snd_trans.
Definition rcv_trans := rcv_trans.

Definition snd_tags p := snd_tags (snd_trans p).
Definition rcv_tags p := rcv_tags (rcv_trans p).

Definition snd_uniq := snd_uniq.
Definition rcv_uniq := rcv_uniq.

Definition cohMT d := d = empty_dstatelet.

Lemma pred0v1 d: cohMT d -> valid (dstate d).

Lemma pred0v2 d: cohMT d -> valid (dsoup d).

Lemma pred0v3 d: cohMT d -> dom (dstate d) =i [::].

Definition EmptyProtMixin := CohPredMixin pred0v1 pred0v2 pred0v3.
Definition empty_coh := CohPred EmptyProtMixin.

Lemma snd_uniq0 {nodes} {coh : cohpred nodes} :
  uniq (@Protocols.snd_tags _ coh ([::] : seq (send_trans coh))).

Lemma rcv_uniq0 {nodes} {coh : cohpred nodes} :
  uniq (@Protocols.rcv_tags nodes _ ([::] : seq (receive_trans coh))).

Definition EmptyProt i : protocol :=
  @Protocol (fun _ => pred0) i empty_coh [::] [::] snd_uniq0 rcv_uniq0.

End Exports.
End Exports.

End Protocols.

Export Protocols.Exports. *)
(* Worlds:
From mathcomp.ssreflect
Require Import ssreflect ssrbool ssrnat eqtype ssrfun seq.
From mathcomp
Require Import path.
Require Import Eqdep.
Require Import Relation_Operators.
From fcsl
Require Import pred prelude ordtype finmap pcm unionmap heap.
From DiSeL
Require Import Freshness State EqTypeX Protocols.
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Module WorldGetters.
Section WorldGetters.

Definition context := union_map Label protocol.

Definition hook_domain := [ordType of ((nat * Label) * (Label * nat))%type].

Definition hook_type := heap -> heap -> seq nat -> nid -> Prop.

Definition hooks := union_map hook_domain hook_type.
Definition world := (context * hooks)%type.

Definition getc (w: world) : context := fst w.
Coercion getc : world >-> context.

Definition geth (w: world) : hooks := snd w.
Coercion geth : world >-> hooks.

Variable w : world.

Variables (p : protocol).

Definition getProtocol i : protocol:=
  match find i (getc w) with
  | Some p => p
  | None => EmptyProt i 
  end.

End WorldGetters.
End WorldGetters.

Export WorldGetters.

Module Worlds.

Module Core.
Section Core.

Definition hooks_consistent (c : context) (h : hooks) : Prop :=
  forall z lc ls t, ((z, lc), (ls, t)) \in dom h ->
  (lc \in dom c) && (ls \in dom c).

Definition hook_complete w := hooks_consistent (getc w) (geth w).

Lemma hook_complete0 c : hook_complete (c, Unit).

Definition Coh (w : world) : Pred state := fun s =>
  let: c := fst w in
  let: h := snd w in                                           
  [/\ valid w, valid s, hook_complete w,
      dom c =i dom s &
      forall l, coh (getProtocol w l) (getStatelet s l)].

Lemma cohW w s : Coh w s -> valid w.

Lemma cohS w s : Coh w s -> valid s.

Lemma cohH w s : Coh w s -> hook_complete w.

Lemma cohD w s : Coh w s -> dom (getc w) =i dom s.

Lemma coh_coh w s l : Coh w s -> coh (getProtocol w l) (getStatelet s l).

Lemma unit_coh w s :
  Coh w s -> w = Unit <-> s = Unit.

Lemma Coh0 (w : world) (s : state) :
  w = Unit -> s = Unit -> Coh w s.

Lemma CohUn (w1 w2 : world) (s1 s2 : state) :
  Coh w1 s1 -> Coh w2 s2 ->
  valid (w1 \+ w2) -> Coh (w1 \+ w2) (s1 \+ s2).

Lemma coh_prec w: precise (Coh w).

Lemma locE i n k x y :
  k \in dom i -> valid i -> valid (dstate (getStatelet i k)) ->
  getLocal n (getStatelet (upd k
       {| dstate := upd n x (dstate (getStatelet i k));
          dsoup := y |} i) k) = x.

Lemma locE' d n x y :
  valid (dstate d) ->
  getLocal n {| dstate := upd n x (dstate d);
                dsoup := y |} = x.

Lemma locU n n' x st s :
  n != n' ->
  valid st ->
  getLocal n {| dstate := upd n' x st; dsoup := s |} =
  getLocal n {| dstate := st; dsoup := s |}.

Section MakeWorld.

Variable p : protocol.
Notation l := (plab p).

Definition mkWorld : world := (l \\-> p, Unit).

Lemma prEq : (getProtocol mkWorld l) = p.
                          
End MakeWorld.

End Core.
End Core.

End Worlds.

Export Worlds.Core. *)
(* NetworkSem:
From mathcomp.ssreflect 
Require Import ssreflect ssrbool ssrnat eqtype ssrfun seq.
From mathcomp
Require Import path.
Require Import Eqdep.
Require Import Relation_Operators.
From fcsl
Require Import axioms pred prelude ordtype finmap pcm unionmap heap.
From DiSeL
Require Import Freshness State EqTypeX Protocols Worlds.
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Section NetworkSemantics.

Variable w : world.
Variable this: nid.

Notation getl := (getLocal).
Notation gets := (getStatelet).
Notation getp := (@getProtocol w).

Definition get_coh l := @coh (getp l).
Definition get_st l := @snd_trans (getp l).
Definition get_rt l := @rcv_trans (getp l).

Lemma getsE l s : l \in dom s -> find l s = Some (gets s l).

Lemma coh_s l s: Coh w s -> coh (getp l) (gets s l).

Lemma Coh_dom l s : l \in dom s -> Coh w s -> 
                     dom (dstate (gets s l)) =i nodes (getp l) (gets s l).

Definition all_hooks_fire (h : hooks) l st s n (msg : seq nat) to :=
  
  forall z lc hk, Some hk = find ((z, lc), (l, st)) h ->
  lc \in dom s -> l \in dom s ->               
  let: core_local   := getl n (gets s lc) in
  let: client_local := getl n (gets s l)  in              
  hk core_local client_local msg to.

Inductive network_step (s1 s2 : state) : Prop :=
  
  Idle of s1 \In Coh w /\ s1 = s2

| SendMsg 
          l st (_ : st \In @get_st l) to msg b
          (pf: this \in (nodes (getp l) (gets s1 l)))
          (pf' : l \in dom s1) (C: Coh w s1)
          
          (S : send_safe st this to (gets s1 l) msg)

          (pf_hooks : all_hooks_fire (geth w) l (t_snd st) s1 this msg to)
          
          (spf : Some b = send_step S) of
          
          let: d :=  gets s1 l in

          let: f' := upd this b (dstate d) in
          let: s' := (post_msg (dsoup d) (Msg (TMsg (t_snd st) msg)
                                              this to true)).1 in
          s2 = upd l (DStatelet f' s') s1

| ReceiveMsg l rt (_ : rt \In @get_rt l) i from
             
             (pf: this \in (nodes (getp l)) (gets s1 l))
             (pf': l \in dom s1) (C: Coh w s1)
             (msg : TaggedMessage)
             (pf': tag msg = t_rcv rt) of
             let: d := (gets s1 l) in
             let: f := dstate d in
             let: s := dsoup d  in

             [/\ find i s = Some (Msg msg from this true),
              msg_wf rt (coh_s l C) this from msg &
              
              let loc' := receive_step rt from msg (coh_s l C) pf in
              let: f' := upd this loc' f in
              let: s'' := consume_msg s i in
              s2 = upd l (DStatelet f' s'') s1].

Lemma step_coh s1 s2: network_step s1 s2 ->
                      Coh w s1 /\ Coh w s2.

Lemma step_preserves_labels s1 s2 :
  network_step s1 s2 -> dom s1 =i dom s2.

Lemma step_is_local s1 s2 l: network_step s1 s2 ->
  forall z, z != this ->
  find z (dstate (gets s1 l)) = find z (dstate (gets s2 l)).

Lemma stepV1 s1 s2: network_step s1 s2 -> valid s1.

Lemma stepV2 s1 s2: network_step s1 s2 -> valid s2.

Lemma step_preserves_node_ids s1 s2 l:
  l \in dom s1 -> network_step s1 s2 ->
  dom (dstate (gets s1 l)) =i dom (dstate (gets s2 l)).

End NetworkSemantics. *)
(* Rely:
From mathcomp.ssreflect
Require Import ssreflect ssrbool ssrnat eqtype ssrfun seq.
From mathcomp
Require Import path.
Require Import Eqdep.
Require Import Relation_Operators.
From fcsl
Require Import pred prelude ordtype finmap pcm unionmap heap.
From DiSeL
Require Import Freshness State EqTypeX Protocols Worlds NetworkSem.
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Section Rely.

Variable w : world.
Variable this: nid.

Notation getl := (getLocal).
Notation gets := getStatelet.
Notation getp := (@getProtocol _ w).

Fixpoint network_rely' n s1 s2 :=
  if n is n'.+1
  then exists z s3,
        [/\ this != z, network_step w z s1 s3 & network_rely' n' s3 s2]
    else s1 = s2 /\ s1 \In Coh w.

Definition network_rely s1 s2 := exists n, network_rely' n s1 s2.

Lemma rely_refl s : s \In Coh w -> network_rely s s.

Lemma rely_trans s1 s2 s3 :
  network_rely s1 s2 -> network_rely s2 s3 -> network_rely s1 s3.

Lemma rely_coh' n s1 s2 :
  network_rely' n s1 s2 -> Coh w s1 /\ Coh w s2.

Lemma rely_coh s1 s2 :
  network_rely s1 s2 -> Coh w s1 /\ Coh w s2.

Lemma rely_loc s1 s2 l:
  network_rely s1 s2 -> find this (dstate (gets s1 l)) = find this (dstate (gets s2 l)).

Lemma step_consume_other l s s' m tm from z:
  this != z -> network_step w z s s' ->
  find m (dsoup (gets s l)) = Some (Msg tm from this true) ->
  find m (dsoup (gets s' l)) = Some (Msg tm from this true).

Lemma rely_consume_other l s s' m tm from:
  network_rely s s' ->
  find m (dsoup (gets s l)) = Some (Msg tm from this true) ->
  find m (dsoup (gets s' l)) = Some (Msg tm from this true).

Lemma step_send_other l s s' m tm to b z:
  this != z -> network_step w z s s' ->
  find m (dsoup (gets s' l)) = Some (Msg tm this to b) ->
  exists b', find m (dsoup (gets s l)) = Some (Msg tm this to b') /\ (b -> b').

Lemma rely_send_other l s s' m tm to b:
  network_rely s s' ->
  find m (dsoup (gets s' l)) = Some (Msg tm this to b) ->
  exists b', find m (dsoup (gets s l)) = Some (Msg tm this to b') /\ (b -> b').

Lemma step_send_other' l s s' m tm to b z:
  this != z -> network_step w z s s' ->
  find m (dsoup (gets s l)) = Some (Msg tm this to b) ->
  exists b', find m (dsoup (gets s' l)) = Some (Msg tm this to b') /\ (b' -> b).

Lemma rely_send_other' l s s' m tm to b:
  network_rely s s' ->
  find m (dsoup (gets s l)) = Some (Msg tm this to b) ->
  exists b', find m (dsoup (gets s' l)) = Some (Msg tm this to b') /\ (b' -> b).

Notation loc i l := (getLocal this (getStatelet i l)).
Notation msgs i l := (dsoup (getStatelet i l)).

Lemma rely_loc' l i j : network_rely i j -> loc j l = loc i l.

End Rely. *)

From DiSeL

Require Import Actions Injection Process Always HoareTriples InductiveInv.
(* Actions:
From mathcomp.ssreflect
Require Import ssreflect ssrbool ssrnat eqtype ssrfun seq.
From mathcomp
Require Import path.
Require Import Eqdep.
Require Import Relation_Operators.
From fcsl
Require Import axioms pred prelude ordtype finmap pcm unionmap heap.
From DiSeL
Require Import Freshness State EqTypeX Protocols Worlds NetworkSem.
Require Classical_Prop.

Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Module Actions.

Section Actions.

Variable W : world.
Notation getS s l := (getStatelet s l).

Structure action (V : Type) (this : nid)
  := Action
       {
         
         a_safe : state -> Prop;

         a_safe_coh : forall s, a_safe s -> s \In Coh W;

         a_step : forall s1, (a_safe s1) -> state -> V -> Prop;

         step_total : forall s (pf : a_safe s), exists s' r, a_step pf s' r;

         step_sem  : forall s1 (pf : a_safe s1) s2 r,
             a_step pf s2 r -> network_step W this s1 s2

       }.

Lemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1):
  this != n -> a_step pf s2 r ->
  getLocal n (getS s1 l) = getLocal n (getS s2 l).

End Actions.

Section SkipActionWrapper.

Variable W : world.
Notation getP l := (getProtocol W l).
Notation getS s l := (getStatelet s l).
Variable this : nid.
Variable l : Label.
Variable p : protocol.
Variable pf : getP l = p.

Definition skip_safe s := Coh W s.

Variable V : Type.

Variable f : forall s, coh p (getS s l) -> V.

Lemma safe_local s : skip_safe s -> coh p (getS s l).

Definition skip_step s1 (pf : skip_safe s1) (s2 : state) r :=
  [/\ s1 \In Coh W, s1 = s2 & r = f (safe_local pf)].

Lemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.

Lemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.

Lemma skip_step_sem s1 (S : skip_safe s1) s2 r:
  skip_step S s2 r -> network_step W this s1 s2.

Definition skip_action_wrapper :=
  Action skip_safe_coh skip_step_total skip_step_sem.

End SkipActionWrapper.

Section TryReceiveActionWrapper.

Variable W : world.
Notation getP l := (getProtocol W l).
Notation getS s l := (getStatelet s l).
Variable this : nid.

Variable filter : Label -> nid -> nat -> pred (seq nat).

Variable f_valid_label : forall l n t m ,
    filter l n t m -> l \in dom (getc W).

Definition tryrecv_act_safe (s : state) := s \In Coh W.

Lemma tryrecv_act_safe_coh s : tryrecv_act_safe s -> Coh W s.

Definition tryrecv_act_step s1 s2 (r : option (nid * nat * seq nat)) :=
  exists (pf : s1 \In Coh W),
  
    ([/\ (forall l m tms from rt b,
          this \in nodes (getP l) (getS s1 l) -> 
          Some (Msg tms from this b) = find m (dsoup (getS s1 l)) ->
          rt \In (rcv_trans (getP l)) ->
          tag tms = (t_rcv rt) ->
          
          msg_wf rt (coh_s l pf) this from tms ->
             
          filter l from (t_rcv rt) (tms_cont tms) ->
          ~~b),
    r = None & s2 = s1] \/
   
   exists l m tms from rt (pf' : this \in nodes (getP l) (getS s1 l)),
     let: d :=  getS s1 l in
     [/\ [/\ Some (Msg tms from this true) = find m (dsoup (getS s1 l)),
          rt \In (rcv_trans (getP l)),
          tag tms = (t_rcv rt),
          
          msg_wf rt (coh_s l pf) this from tms &
             
          filter l from (t_rcv rt) (tms_cont tms)],
      let loc' := receive_step rt from tms (coh_s l pf) pf' in
      let: f' := upd this loc' (dstate d) in
      let: s' := consume_msg (dsoup d) m in
      s2 = upd l (DStatelet f' s') s1 &
      r = Some (from, tag tms, tms_cont tms)]).

Import Classical_Prop.

Lemma tryrecv_act_step_total s:
  tryrecv_act_safe s -> exists s' r , tryrecv_act_step s s' r.

Lemma tryrecv_act_step_safe s1 s2 r:
  tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.

Lemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r:
  tryrecv_act_step s1 s2 r -> network_step W this s1 s2.

Definition tryrecv_action_wrapper :=
  Action tryrecv_act_safe_coh tryrecv_act_step_total tryrecv_act_step_sem.

End TryReceiveActionWrapper.

Section SendActionWrapper.

Variable W : world.
Variable p : protocol.
Notation getP l := (getProtocol W l).
Notation getS s l := (getStatelet s l).
Variable this : nid.

Variable l : Label.

Variable pf : (getProtocol W l) = p.

Variable st: send_trans (coh p).

Variable pf' : st \In (snd_trans p).

Variable msg : seq nat.
Variable to  : nid.

Definition can_send (s : state) := (l \in dom s) && (this \in nodes p (getS s l)).

Definition filter_hooks (h : hooks) :=
  um_filter (fun e => e.2 == (l, t_snd st)) h.

Definition send_act_safe s :=
  [/\ Coh W s, send_safe st this to (getS s l) msg, can_send s &
               
      all_hooks_fire (filter_hooks (geth W)) l (t_snd st) s this msg to].

Lemma send_act_safe_coh s : send_act_safe s -> Coh W s.

Lemma safe_safe s : send_act_safe s -> send_safe st this to (getS s l) msg.

Definition send_act_step s1 (S: send_act_safe s1) s2 r :=
   r = msg /\
   exists b,
     Some b = send_step (safe_safe S) /\
     let: d :=  getS s1 l in
     let: f' := upd this b (dstate d) in
     let: s' := (post_msg (dsoup d) (Msg (TMsg (t_snd st) msg)
                                         this to true)).1 in
     s2 = upd l (DStatelet f' s') s1.

Lemma send_act_step_total s (S: send_act_safe s): exists s' r , send_act_step S s' r.

Lemma send_act_step_sem s1 (S : send_act_safe s1) s2 r:
  send_act_step S s2 r -> network_step W this s1 s2.

Definition send_action_wrapper :=
  Action send_act_safe_coh send_act_step_total send_act_step_sem.

End SendActionWrapper.

End Actions.

Module ActionExports.

Definition action := Actions.action.
Definition a_safe := Actions.a_safe.
Definition a_step := Actions.a_step.

Definition a_safe_coh := Actions.a_safe_coh.
Definition a_step_total := Actions.step_total.
Definition a_step_sem := Actions.step_sem.
Definition a_step_other := Actions.step_other.

Definition skip_action_wrapper := Actions.skip_action_wrapper.
Definition send_action_wrapper := Actions.send_action_wrapper.
Definition tryrecv_action_wrapper := Actions.tryrecv_action_wrapper.

End ActionExports.

Export ActionExports. *)
(* Injection:
From mathcomp.ssreflect
Require Import ssreflect ssrbool ssrnat eqtype ssrfun seq.
From mathcomp
Require Import path.
Require Import Eqdep.
Require Import Relation_Operators.
From fcsl
Require Import axioms pred prelude ordtype finmap pcm unionmap heap.
From DiSeL
Require Import Freshness State EqTypeX Protocols Worlds NetworkSem Actions.
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Module Injection.
Section Injection.

Variable W : world.

Structure injects (U V : world) (K : hooks) := Inject {
  
  E : world;
                                       
  _ : hook_complete U /\ hook_complete E;

  _ : V = U \+ E \+ (Unit, K);

  _ : hooks_consistent (getc (U \+ E)) K;
  
  _ : forall s, Coh V s <-> exists s1 s2,
        [/\ s = s1 \+ s2, Coh U s1 & Coh E s2];

  _ : forall s1 s2 s this,
      s1 \+ s \In Coh V -> network_step U this s1 s2 ->
      network_step V this (s1 \+ s) (s2 \+ s);

  _ : forall s1 s2 s1' s2' this,
      s1 \In Coh U -> s2 \In Coh U ->
      network_step V this (s1 \+ s1') (s2 \+ s2') ->
      (network_step U this s1 s2   /\ s1' = s2') \/
      (network_step E this s1' s2' /\ s1 = s2); }.

End Injection.

Module Exports.
Section Exports.

Definition inj_ext := E.
Definition injects := injects. 
Definition Inject := Inject.

Lemma cohK (U V : world) (K : hooks) (w : injects U V K) :
  V = U \+ inj_ext w \+ (Unit, K).

Lemma cohE (U V : world) (K : hooks) (w : injects U V K) s :
  Coh V s <-> exists s1 s2,
      [/\ s = s1 \+ s2, Coh U s1 & Coh (inj_ext w) s2].

Lemma sem_extend (U V : world) (K : hooks) (w : injects U V K) s1 s2 s this: 
      s1 \+ s \In Coh V -> s2 \+ s \In Coh V ->
      network_step U this s1 s2 -> network_step V this (s1 \+ s) (s2 \+ s).

Lemma sem_split (U V : world) (K : hooks) (w : injects U V K) s1 s1' s2 s2' this: 
      s1 \In Coh U -> s2 \In Coh U ->
      network_step V this (s1 \+ s1') (s2 \+ s2') ->
      (network_step U this s1 s2   /\ s1' = s2') \/
      (network_step (inj_ext w) this s1' s2' /\ s1 = s2).

Definition extends (U V : world) (K : hooks) (w : injects U V K) s s1 := 
  exists s2, [/\ s = s1 \+ s2, s1 \In Coh U & s \In Coh V].

Notation dom_filt W := (fun k => k \in dom W).

Definition projectS (W : world) (s : state) :=
  um_filter (dom_filt (getc W)) s.

Lemma projectS_cohL W1 W2 s :
  s \In Coh (W1 \+ W2) -> hook_complete W1 -> projectS W1 s \In Coh W1.

Lemma projectS_cohR W1 W2 s :
  s \In Coh (W1 \+ W2) -> hook_complete W2 -> projectS W2 s \In Coh W2.

Lemma projectSE W1 W2 s :
  s \In Coh (W1 \+ W2) ->
  s = projectS W1 s \+ projectS W2 s.

Lemma coh_split W1 W2 s :
  s \In Coh (W1 \+ W2) ->
  hook_complete W1 -> hook_complete W2 ->
  exists s1 s2 : state,
    [/\ s1 \In Coh W1, s2 \In Coh W2 & s = s1 \+ s2].

Lemma injExtL' (W1 W2 : world) K (pf : injects W1 (W1 \+ W2) K) :
  valid (W1 \+ W2) -> inj_ext pf \+ (Unit, K) = W2.

Lemma injExtR' W1 W2 K (pf : injects W2 (W1 \+ W2) K) :
  valid (W1 \+ W2) -> inj_ext pf \+ (Unit, K) = W1.

Lemma injExtL W1 W2 (pf : injects W1 (W1 \+ W2) Unit) :
  valid (W1 \+ W2) -> inj_ext pf = W2.

Lemma injExtR W1 W2 (pf : injects W2 (W1 \+ W2) Unit) :
  valid (W1 \+ W2) -> inj_ext pf  = W1.

End Exports.
End Exports.

End Injection.

Export Injection.Exports.

Module InjectExtra.

Lemma cohUnKR U W s s':
  s \+ s' \In Coh (U \+ W) -> s \In Coh U ->
  hook_complete W -> s' \In Coh W.

Lemma cohUnKL U W s s':
  s \+ s' \In Coh (U \+ W) -> s' \In Coh W ->
  hook_complete U -> s \In Coh U .

Lemma getPUn (U W : world) l :
  valid (U \+ W) -> l \in dom U.1 ->

Lemma getSUn s1 s2 l :
  valid (s1 \+ s2) -> l \in dom s1 ->
  getStatelet s1 l = getStatelet (s1 \+ s2) l.

Lemma hook_completeL (U : world) K :
  valid (U \+ (Unit, K)) ->
  hook_complete (U \+ (Unit, K)) -> hook_complete U.

Lemma get_protocol_hooks (U: world) K l:
  valid U -> getProtocol (U \+ (Unit, K)) l = getProtocol U l.

Lemma coh_hooks (U : world) K s :
  s \In (Coh (U \+ (Unit, K))) -> s \In (Coh U).

Lemma inj_hooks_complete (U W : world) K:
  valid (U \+ W \+ (Unit, K)) ->
  hook_complete U -> hook_complete W ->
  hooks_consistent (U \+ W).1 K ->

Lemma inject_step U W K this s1 s2 s1' s2' :
  valid (U \+ W) ->
  s1 \In Coh U -> s2 \In Coh U ->
  hook_complete U -> hook_complete W ->
  network_step (U \+ W \+ (Unit, K)) this (s1 \+ s1') (s2 \+ s2') ->
  network_step U this s1 s2 /\ s1' = s2' \/
  network_step W this s1' s2' /\ s1 = s2.

Definition not_hooked_by (K : hooks) l :=
  forall z lc l' st, (z, lc, (l', st)) \in dom K -> l != l'.

Definition world_not_hooked (W: world) K :=
  forall l, l \in dom W.1 -> not_hooked_by K l.

Lemma hooks_frame (U W : world) (K : hooks) l st s s' n msg to :
  hook_complete U -> hook_complete W ->
  hooks_consistent (U \+ W).1 K ->

Lemma inject_frame U W K this s1 s2 s:
  s1 \+ s \In Coh (U \+ W \+ (Unit, K)) ->
  network_step U this s1 s2 ->
  hook_complete U -> hook_complete W ->
  hooks_consistent (U \+ W).1 K ->

Lemma injectL (U W : world) K :
  valid (U \+ W \+ (Unit, K)) ->
  hook_complete U -> hook_complete W ->
  hooks_consistent (getc (U \+ W)) K ->
  world_not_hooked U K ->
  injects U (U \+ W \+ (Unit, K)) K.

Lemma injectR (U W : world) K :
  valid (W \+ U \+ (Unit, K)) ->
  hook_complete U -> hook_complete W ->
  hooks_consistent (getc (U \+ W)) K ->
  world_not_hooked U K ->
  injects U (W \+ U \+ (Unit, K)) K.

Lemma locProjL (W1 W2 : world) l s1 s2:
  (s1 \+ s2) \In Coh (W1 \+ W2) -> l \in dom W1.1 ->

Lemma locProjR (W1 W2 : world) l s1 s2:
  (s1 \+ s2) \In Coh (W1 \+ W2) -> l \in dom W2.1 ->

End InjectExtra.

Export InjectExtra. *)
(* Process:
From mathcomp.ssreflect
Require Import ssreflect ssrbool ssrnat eqtype ssrfun seq.
From mathcomp
Require Import path.
Require Import Eqdep.
Require Import Relation_Operators.
From fcsl
Require Import pred prelude ordtype finmap pcm unionmap heap.
From DiSeL
Require Import Freshness State EqTypeX DepMaps Protocols Worlds NetworkSem.
From DiSeL
Require Import Actions Injection InductiveInv.

Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Section ProcessSyntax.

Variable this : nid.

Inductive proc (W : world) A :=
  Unfinished | Ret of A | Act of action W A this |
  Seq B of proc W B & B -> proc W A |
  Inject V K of injects V W K & proc V A |
  WithInv p I (ii : InductiveInv p I) of
          W = mkWorld (ProtocolWithIndInv ii) & proc (mkWorld p) A.  

Definition pcat W A B (t : proc W A) (k : A -> Pred (proc W B)) :=
  [Pred s | exists q, s = Seq t q /\ forall x, q x \In k x].

Inductive schedule :=
  ActStep | SeqRet | SeqStep of schedule |  
  InjectStep of schedule | InjectRet |
  WithInvStep of schedule | WithInvRet.

End ProcessSyntax.

Arguments Unfinished [this W A].
Arguments Ret [this W A].
Arguments Act [this W A].
Arguments Seq [this W A B].
Arguments WithInv [this W A].

Section ProcessSemantics.

Variable this : nid.

Fixpoint step (W : world) A (s1 : state) (p1 : proc this W A)
         sc (s2 : state) (p2 : proc this W A) : Prop :=
  match sc, p1 with
    
  | ActStep, Act a => exists v pf, @a_step _ _ _ a s1 pf s2 v /\ p2 = Ret v
    
  | SeqRet, Seq _ (Ret v) k => s2 = s1 /\ p2 = k v
  | SeqStep sc', Seq _ p' k1 => 
    exists p'', step s1 p' sc' s2 p'' /\ p2 = Seq p'' k1
  
  | InjectRet, Inject V K pf (Ret v) =>
     exists s1', [/\ s2 = s1, p2 = Ret v & extends pf s1 s1']
  | InjectStep sc', Inject V K pf t1' =>
    exists s1' s2' s t2', 
    [/\ p2 = Inject pf t2', s1 = s1' \+ s, s2 = s2' \+ s, 
     s1' \In Coh V & step s1' t1' sc' s2' t2']
  
  | WithInvRet, WithInv p inv ii pf (Ret v) =>
     exists s1', [/\ s2 = s1, p2 = Ret v & s1 = s1']
  | WithInvStep sc', WithInv p inv ii pf t1' =>
    exists t2', p2 = WithInv p inv ii pf t2' /\  
                     step s1 t1' sc' s2 t2'   
  | _, _ => False
  end.

Fixpoint good (W : world) A (p : proc this W A) sc  : Prop :=
  match sc, p with
  | ActStep, Act _ => True
  | SeqRet, Seq _ (Ret _) _ => True
  | SeqStep sc', Seq _ p' _ => good p' sc'
  | InjectStep sc', Inject _ _ _ p' => good p' sc'
  | InjectRet, Inject _ _ _ (Ret _) => True
  | WithInvStep sc', WithInv _ _ _ _ p' => good p' sc'
  | WithInvRet, WithInv _ _ _ _ (Ret _) => True
  | _, _ => False
  end.

Fixpoint safe (W : world) A (p : proc this W A) sc (s : state)  : Prop :=
  match sc, p with
  | ActStep, Act a => a_safe a s
  | SeqRet, Seq _ (Ret _) _ => True
  | SeqStep sc', Seq _ p' _ => safe p' sc' s
  | InjectStep sc', Inject V K pf p' =>
      exists s', extends pf s s' /\ safe p' sc' s'
  | InjectRet, Inject V K pf (Ret _) => exists s', extends pf s s'
  | WithInvStep sc', WithInv _ _ _ _ p' => safe p' sc' s
  | WithInvRet, WithInv _ _ _ _ (Ret _) => True
  | _, _ => True
  end.

Definition pstep (W : world) A s1 (p1 : proc this W A) sc s2 p2 := 
  [/\ s1 \In Coh W, safe p1 sc s1 & step s1 p1 sc s2 p2].

Lemma pstep_safe (W : world) A s1 (t : proc this W A) sc s2 q : 
        pstep s1 t sc s2 q -> safe t sc s1.

Lemma proc_progress W A s (p : proc this W A) sc : 
        s \In Coh W -> safe p sc s -> good p sc ->  
        exists s' (p' : proc this W A), pstep s p sc s' p'.

Lemma stepUnfin W A s1 sc s2 (t : proc this W A) : 
        pstep s1 Unfinished sc s2 t <-> False.

Lemma stepRet W A s1 sc s2 (t : proc this W A) v : 
        pstep s1 (Ret v) sc s2 t <-> False.

Lemma stepAct W A s1 a sc s2 (t : proc this W A) : 
        pstep s1 (Act a) sc s2 t <->
        exists v pf, [/\ sc = ActStep, t = Ret v & @a_step _ _ _ a s1 pf s2 v].

Lemma stepSeq W A B s1 (t : proc this W B) k sc s2 (q : proc this W A) :
        pstep s1 (Seq t k) sc s2 q <->
        (exists v, [/\ sc = SeqRet, t = Ret v, q = k v, s2 = s1 &
                       s1 \In Coh W]) \/
         exists sc' p',
           [/\ sc = SeqStep sc', q = Seq p' k & pstep s1 t sc' s2 p'].

Lemma stepInject V W K A (em : injects V W K) 
                s1 (t : proc this V A) sc s2 (q : proc this W A) :
  pstep s1 (Inject em t) sc s2 q <->
  
  (exists s1' v, [/\ sc = InjectRet, t = Ret v, q = Ret v, s2 = s1 &
                     extends em s1 s1']) \/
  
  exists sc' t' s1' s2' s, 
    [/\ sc = InjectStep sc', q = Inject em t', 
     s1 = s1' \+ s, s2 = s2' \+ s, s1 \In Coh W &
              pstep s1' t sc' s2' t'].

Lemma stepWithInv W A pr I (ii : InductiveInv pr I) s1 
      (t : proc this (mkWorld pr) A) sc s2 (q : proc this W A) pf :
  pstep s1 (WithInv pr I ii pf t) sc s2 q <-> 
  (exists v, [/\ sc = WithInvRet, t = Ret v, q = Ret v, s2 = s1,
                 s1 \In Coh W & W = mkWorld (ProtocolWithIndInv ii)]) \/
  exists sc' t' , [/\ sc = WithInvStep sc', q = WithInv pr I ii pf t',
                      W = mkWorld (ProtocolWithIndInv ii),
                      s1 \In Coh W & pstep s1 t sc' s2 t'].

Lemma pstep_network_sem (W : world) A s1 (t : proc this W A) sc s2 q :
        pstep s1 t sc s2 q -> network_step W this s1 s2.

Lemma pstep_inv A pr I (ii : InductiveInv pr I) s1 s2 sc
      (t t' : proc this (mkWorld pr) A):
  s1 \In Coh (mkWorld (ProtocolWithIndInv ii)) ->
  pstep s1 t sc s2 t' -> 
  s2 \In Coh (mkWorld (ProtocolWithIndInv ii)).

End ProcessSemantics. *)
(* Always:
From mathcomp.ssreflect
Require Import ssreflect ssrbool ssrnat eqtype ssrfun seq.
From mathcomp
Require Import path.
Require Import Eqdep.
Require Import Relation_Operators.
From fcsl
Require Import axioms pred prelude ordtype finmap pcm unionmap heap.
From DiSeL
Require Import Freshness State EqTypeX DepMaps Protocols Worlds NetworkSem Rely.
From DiSeL
Require Import Actions Injection Process InductiveInv.

Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Section Always.

Variable this : nid.
Variable W : world.

Notation coherent := (Coh W).

Arguments proc [this W].

Fixpoint always_sc A (s1 : state) p scs (P : state -> proc A -> Prop) : Prop :=
  s1 \In coherent /\ 
  if scs is sc :: scs' then 
    forall s2, network_rely W this s1 s2 -> 
      [/\ safe p sc s2, P s2 p &
          forall s3 q, @pstep this W A s2 p sc s3 q -> always_sc s3 q scs' P]
  else forall s2, network_rely W this s1 s2 -> P s2 p.

Definition always A s (p : proc A) P := forall scs, always_sc s p scs P.

Lemma alw_coh' A s (p : proc A) scs P : 
        always_sc s p scs P -> s \In coherent.

Lemma alw_coh A s (p : proc A) P : 
        always s p P -> s \In coherent.

Lemma alw_safe' A s (p : proc A) sc scs P : 
        always_sc s p (sc :: scs) P -> safe p sc s.

Lemma alw_safe A s (p : proc A) P :
        always s p P -> forall sc, safe p sc s.

Lemma alw_refl' A s (p : proc A) sc P : always_sc s p sc P -> P s p.

Lemma alw_refl A s (p : proc A) P : always s p P -> P s p.

Lemma alw_envs' A s1 (p : proc A) scs s2 P : 
        always_sc s1 p scs P -> network_rely W this s1 s2 -> always_sc s2 p scs P.
 
Lemma alw_envs A s1 (p : proc A) s2 P :
        always s1 p P -> network_rely W this s1 s2 -> always s2 p P.

Lemma alw_step A s1 (p : proc A) sc s2 q P :
        always s1 p P -> pstep s1 p sc s2 q -> always s2 q P.

Lemma alwp_envsq A s1 (p1 : proc A) scs (P : _ -> _ -> Prop) : 
        always_sc s1 p1 scs P ->
        always_sc s1 p1 scs 
          (fun s2 p2 => forall s3, network_rely W this s2 s3 -> P s3 p2).

Lemma alw_envsq A s1 (p1 : proc A) (P : _ -> _ -> Prop) : 
        always s1 p1 P ->
        always s1 p1 (fun s2 p2 => forall s3, network_rely W this s2 s3 -> P s3 p2).

Lemma alw_unfin' A s1 scs (P : state -> proc A -> Prop) :
        s1 \In coherent -> 
        (forall s2, network_rely W this s1 s2 -> P s2 Unfinished) -> 
        always_sc s1 Unfinished scs P.

Lemma alw_unfin A s1 (P : state -> proc A -> Prop) :
        s1 \In coherent -> 
        (forall s2, network_rely W this s1 s2 -> P s2 Unfinished) ->
        always s1 Unfinished P.

Lemma alw_ret' A s1 (v : A) scs (P : state -> proc A -> Prop) : 
        s1 \In coherent -> 
        (forall s2, network_rely W this s1 s2 -> P s2 (Ret v)) -> 
        always_sc s1 (Ret v) scs P.

Lemma alw_ret A s1 (v : A) (P : state -> proc A -> Prop) : 
        s1 \In coherent -> 
        (forall s2, network_rely W this s1 s2 -> P s2 (Ret v)) -> 
        always s1 (Ret v) P.

Lemma alw_act A s1 (a : action W A this) (P : state -> proc A -> Prop) :
        s1 \In coherent ->
        (forall s2, network_rely W this s1 s2 -> exists S : a_safe a s2,
        P s2 (Act a) /\
        forall s3 v s4, a_step S s3 v -> 
                        network_rely W this s3 s4 -> P s4 (Ret v)) ->
        always s1 (Act a) P. 

Notation alwsafe_sc s p scs := (always_sc s p scs (fun _ _ => True)).
Notation alwsafe s p := (always s p (fun _ _ => True)).

Lemma alw_imp' A s (p : proc A) scs (P1 P2 : state -> proc A -> Prop) : 
         (forall s p, s \In coherent -> P1 s p -> P2 s p) -> 
         always_sc s p scs P1 -> always_sc s p scs P2.

Lemma alw_imp A s (p : proc A) (P1 P2 : state -> proc A -> Prop) : 
        (forall s p, s \In coherent -> P1 s p -> P2 s p) -> 
        always s p P1 -> always s p P2.

Lemma alwA' A B s (p : proc A) scs (P : B -> state -> proc A -> Prop) : 
        alwsafe_sc s p scs ->
        (always_sc s p scs (fun s' p' => forall x, P x s' p') <->
         forall x, always_sc s p scs (fun s' p' => P x s' p')).

Lemma alwA A B s (p : proc A) (P : B -> state -> proc A -> Prop) : 
        alwsafe s p ->
        (always s p (fun s' p' => forall x, P x s' p') <->
         forall x, always s p (fun s' p' => P x s' p')).

Arguments alwA [A B s p P].

Lemma alwI' A s (p : proc A) scs (P : Prop) (Q : state -> proc A -> Prop) : 
        alwsafe s p ->
        (always_sc s p scs (fun s' p' => P -> Q s' p') <->
         (P -> always_sc s p scs (fun s' p' => Q s' p'))).

Lemma alwI A s (p : proc A) (P : Prop) (Q : state -> proc A -> Prop) : 
        alwsafe s p ->
         always s p (fun s' p' => P -> Q s' p') <->
         (P -> always s p (fun s' p' => Q s' p')). 

Arguments alwI [A s p P Q].

Lemma alw_bnd A B (p1 : proc A) (p12 : proc B) pp2 s1 
                 (P : state -> B -> Prop) :
        p12 \In pcat p1 pp2 -> 
        always s1 p1 (fun s2 p2 =>
                        
          forall p v, p2 = Ret v -> p \In pp2 v -> 
                      always s2 p (fun s q => forall v, q = Ret v -> P s v)) ->
        always s1 p12 (fun s p => forall v, p = Ret v -> P s v).

Lemma alwsafe_bnd A B (p1 : proc A) (p12 : proc B) s1 pp2 :
        p12 \In pcat p1 pp2 ->
        always s1 p1 (fun s2 p2 =>
          forall p v, p2 = Ret v -> p \In pp2 v -> alwsafe s2 p) ->
        alwsafe s1 p12.

Definition after A s (p : proc A) (P : A -> state -> Prop) := 
  always s p (fun s2 p2 => forall v, p2 = Ret v -> P v s2).

Lemma aft_bnd A B (p1 : proc A) (p12 : proc B) pp2 s1 P :
        p12 \In pcat p1 pp2 -> 
        after s1 p1 (fun v s => 
          forall p, p \In pp2 v -> after s p P) ->
        after s1 p12 P.

Lemma aftI A s (p : proc A) (P : Prop) (Q : A -> state -> Prop) : 
        alwsafe s p ->
         after s p (fun v s' => P -> Q v s') <->
         (P -> after s p (fun v s' => Q v s')).

Lemma aft_alwsf A s (p : proc A) :
        alwsafe s p <-> after s p (fun v s => True).

Lemma aft_imp A s (p : proc A) (P1 P2 : A -> state -> Prop) : 
        (forall v s, s \In coherent -> 
                     P1 v s -> P2 v s) -> 
        after s p P1 -> after s p P2.

Lemma aftA A B s (p : proc A) (P : B -> A -> state -> Prop) : 
        alwsafe s p ->
        (after s p (fun v s' => forall x, P x v s') <->
         forall x, after s p (fun v s' => P x v s')).

Arguments aftA [A B s p P].
Arguments aftI [A s p P Q].

End Always.

Section AlwaysInject.
Variables (V W : world) (K : hooks) (A : Type) (w : injects V W K) (this: nid).
Notation W2 := (inj_ext w).

Lemma rely_ext i j s : 
        i \In Coh V -> 
        network_rely W this (i \+ j) s ->  
        exists i' j', s = i' \+ j' /\ i' \In Coh V.

Lemma rely_split' z s1 s1' s2 s2' : 
  s1 \In Coh V -> s2 \In Coh V ->
  network_step W z (s1 \+ s1') (s2 \+ s2') ->
  network_step V z s1 s2 /\ network_step (inj_ext w) z s1' s2'.

Lemma rely_split s1 s1' s2 s2' : 
  s1 \In Coh V -> s2 \In Coh V ->
  network_rely W this (s1 \+ s1') (s2 \+ s2') ->
  network_rely V this s1 s2 /\ network_rely (inj_ext w) this s1' s2'.

Lemma alw_inject (p : proc this V A)
      (P : state -> proc this V A -> Prop) i j :
        i \+ j \In Coh W ->
        always i p P ->
        always (i \+ j) (Inject w p)
          (fun m q => exists i' j', 
             [/\ m = i' \+ j', i' \In Coh V, network_rely W2 this j j' &
                 (exists q', q = Inject w q' /\ P i' q') \/
                 (exists v', q = Ret v' /\ P i' (Ret v'))]).

Lemma aft_inject (p : proc this V A) (P : A -> state -> Prop) i j :
        i \+ j \In Coh W ->
        after i p P ->
        after (i \+ j) (Inject w p)
          (fun v m => exists i' j', 
             [/\ m = i' \+ j', i' \In Coh V, 
                 network_rely W2 this j j' & P v i']).

End AlwaysInject.

Notation alwsafe_sc s p scs := (always_sc s p scs (fun _ _ => True)).
Notation alwsafe s p := (always s p (fun _ _ => True)).

Module AlwaysInductiveInv.
Section AlwaysInductiveInv.
Import InductiveInv.
Variable pr : protocol.

Notation l := (plab pr).
Notation coh := (coh pr).
Variable I : dstatelet -> pred nid -> Prop.
Variable ii : InductiveInv pr I.

Variables (A : Type) (this: nid).
Notation V := (mkWorld pr).
Notation W := (mkWorld (ProtocolWithIndInv ii)).

Lemma alw_ind_inv (p : proc this V A)
      (P : state -> proc this V A -> Prop) i :
        i \In Coh W ->
        always i p P ->
        always i (WithInv pr I ii (erefl _) p)
          (fun m q => m \In Coh W /\
                 ((exists q', q = WithInv pr I ii (erefl _) q' /\ P m q') \/
                  (exists v', q = Ret v' /\ P m (Ret v')))).

Lemma aft_ind_inv (p : proc this V A) (P : A -> state -> Prop) i :
        i \In Coh W ->
        after i p P ->
        after i (WithInv pr I ii (erefl _) p)
          (fun v m => m \In Coh W /\ P v m).

End AlwaysInductiveInv.
End AlwaysInductiveInv.

Export AlwaysInductiveInv. *)
(* HoareTriples:
From mathcomp.ssreflect
Require Import ssreflect ssrbool ssrnat eqtype ssrfun seq.
From mathcomp
Require Import path.
Require Import Eqdep.
Require Import Relation_Operators.
From fcsl
Require Import axioms pred prelude ordtype finmap pcm unionmap heap.
From DiSeL
Require Import Domain Freshness State EqTypeX DepMaps Protocols Worlds NetworkSem Rely.
From DiSeL
Require Import Actions Injection Process Always.
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Structure prog (W : world) A (this : nid) :=
  Prog {
      set_of : proc this W A -> Prop; 
      
      _ : set_of Unfinished
  }.

Section Programs.

Variable this : nid.
Variable W : world.
Variable A : Type.

Notation coherent := (Coh W).

Arguments Prog [W A].
Arguments Prog [W A this].

Coercion set_of : prog >-> Funclass. 
Canonical prog_PredType W A := mkPredType (fun p => @set_of W A this p). 

Lemma progE (T1 T2 : prog W A this) : 
        T1 = T2 <-> set_of T1 = set_of T2.

Definition pre := state -> Prop.

Definition post A := state -> A -> state -> Prop.
Definition cont A := A -> state -> Prop.
Definition spec A := prod pre (post A).

Definition has_spec (s : spec A) := 
  [Pred T : prog W A this | forall i t, 
     s.1 i -> i \In Coh W -> t \In T -> after i t (s.2 i)]. 

End Programs.

Module DTbin.
Section DTbin.

Variable this : nid.

Structure DTbin (W : world) A (s : spec A) := DTbin_make {
  prog_of : prog W A this; 
  _ : prog_of \In has_spec this W s}.

End DTbin.
End DTbin.

Notation DTbin := DTbin.DTbin.
Notation DTbin_make := DTbin.DTbin_make.

Coercion DTbin.prog_of : DTbin >-> prog.

Section Specs.

Variable this : nid.

Lemma stsepE (W : world) A (s : spec A) (e1 e2 : DTbin this W s) : 
        e1 = e2 <-> e1 = e2 :> prog W A this.

Lemma prog_unfin (W : world) A (s : spec A) (e : DTbin this W s) : 
        Unfinished \In DTbin.prog_of e.

Inductive DT (W: world) A :=
  with_spec (s : spec A) of DTbin this W s.

Definition spec_of W A (e : DT W A) := let: with_spec s _ := e in s.
Definition pre_of W A := fun e : DT W A => (spec_of e).1. 
Definition post_of W A := fun e : DT W A => (spec_of e).2. 

Definition code_of (W : world) A (e : DT W A) := 
  let: with_spec _ c := e return DTbin this W (spec_of e) in c.

Arguments pre_of [W A].
Arguments post_of [W A].
Arguments with_spec [W A].
Prenex Implicits pre_of post_of.

Coercion with_spec : DTbin >-> DT.

Definition verify (W : world) A (i : state) (e : DT W A) r := 
  i \In Coh W -> 
  forall p, p \In DTbin.prog_of (code_of e) -> after i p r. 

End Specs.

Module DTLattice.
Section DTLattice.

Variable this : nid.
Variable W : world.
Variables (A : Type) (s : spec A).
Notation prog A := (@prog W A this).
Notation DTbin s := (@DTbin this W A s).

Definition leq (e1 e2 : DTbin s) := 
  set_of (DTbin.prog_of e1) <== set_of (DTbin.prog_of e2).

Lemma leq_refl e : leq e e. 

Lemma leq_trans e1 e2 e3 : leq e1 e2 -> leq e2 e3 -> leq e1 e3.

Lemma leq_asym e1 e2 : leq e1 e2 -> leq e2 e1 -> e1 = e2.

Definition bot_set t := t = @Unfinished this W A. 
Definition bot_prg := @Prog _ _ _ bot_set (erefl _).

Lemma bot_spec : bot_prg \In has_spec this W s.

Definition bot := DTbin_make bot_spec.

Lemma bot_bot e : leq bot e.

Definition sup_set (es : Pred (DTbin s)) t := 
  t = Unfinished \/ exists e : DTbin s, t \In DTbin.prog_of e /\ e \In es.
Definition sup_prog es := @Prog _ _ _ (sup_set es) (or_introl (erefl _)).

Lemma sup_spec es : sup_prog es \In has_spec this W s.

Definition sup es := DTbin_make (@sup_spec es).

Lemma sup_supB es e : e \In es -> leq e (sup es).

Lemma sup_supL es e : (forall c, c \In es -> leq c e) -> leq (sup es) e.

End DTLattice.

Module Exports.
Section Exports.
Variable this : nid.
Variable W : world.
Variables (A : Type) (s : spec A).

Definition stPosetMixin := PosetMixin (@leq_refl this W A s) 
                                      (@leq_asym this W A s) (@leq_trans this W A s).
Canonical stPoset := Eval hnf in Poset (@DTbin this W A s) stPosetMixin.

Definition stLatticeMixin := LatticeMixin (@sup_supB this W A s) (@sup_supL this W A s).
Canonical stLattice := Eval hnf in Lattice (@DTbin this W A s) stLatticeMixin.

End Exports.
End Exports.

End DTLattice.

Export DTLattice.Exports.

Section Fix. 

Variable this : nid.
Variable W : world.
Variables (A : Type)  (B : A -> Type) (s : forall x, spec (B x)).

Notation tp := (forall x, DTbin this W (s x)).
Notation lat := (dfunLattice (fun x => [lattice of DTbin this W (s x)])).
Variable (f : tp -> tp).

Definition f' (e : lat) := sup [Pred t : lat | exists e', e' <== e /\ t = f e'].

Definition ffix : tp := tarski_lfp f'. 

End Fix.

Section Return.
Variable this : nid.
Variable W : world.
Variables (A : Type)  (x : A).

Definition ret_set t := t = Unfinished \/ t = @Ret this W A x.

Definition ret_prog := @Prog _ _ _ ret_set (or_introl (erefl _)).

Definition ret_s : spec A := 
  (fun i => True, fun i y m => network_rely W this i m /\ y = x). 

Lemma ret_has_spec : ret_prog \In has_spec this W ret_s.

Definition ret := with_spec (DTbin_make ret_has_spec). 

End Return.

Section Act.
Variable this : nid.
Variable W : world.
Variables (A : Type)  (x : A).
Variable a : action W A this.

Definition act_set t := t = Unfinished \/ t = @Act this W A a.
Definition act_prog := @Prog _ _ _ act_set (or_introl (erefl _)).

Definition act_s : spec A := 
  (fun i => forall j, network_rely W this i j -> a_safe a j,
   fun i y m => exists j k, 
       [/\ network_rely W this i j,
        exists (S: a_safe a j), a_step S k y & network_rely W this k m]). 

Lemma act_has_spec : act_prog \In has_spec this W act_s.

Definition act := with_spec (DTbin_make act_has_spec).

End Act.

Section Bind.

Variable this : nid.
Variable W : world.
Variables (A B : Type).

Section Prog.
Variables (T : prog W A this) (K : A -> prog W B this).

Definition bnd_set t := 
  t = Unfinished \/ exists t', t \In pcat t' K /\ t' \In T.
Definition bnd_prog := @Prog _ _ _ bnd_set (or_introl (erefl _)).

End Prog.

Variables (e1 : DT this W A) (e2 : A -> DT this W B).

Notation s1 := (spec_of e1).

Notation s2 := (fun x => spec_of (e2 x)).

Definition bind_s : spec B := 
  (fun i => s1.1 i /\ forall x s, s1.2 i x s -> (s2 x).1 s,
   fun i y m => exists x s, s1.2 i x s /\ (s2 x).2 s y m).

Lemma bind_has_spec : 
        bnd_prog (code_of e1) (fun x => let y := e2 x in code_of y) \In has_spec this W bind_s.

Definition bind := with_spec (DTbin_make bind_has_spec).

End Bind.

Section Inject.
Variables (this : nid) (V W : world) (K : hooks) (A : Type) (w : injects V W K). 
Variable (e : DT this V A).
Notation W2 := (inj_ext w). 
Notation s := (spec_of e).

Section Prog.

Variable T : prog V A this.

Definition inject_set t := 
  t = Unfinished \/ exists t', t' \In T /\ t = Inject w t'. 
Definition inject_prog := @Prog _ _ _ inject_set (or_introl (erefl _)).
End Prog.

Definition inject_s : spec A :=
  (fun i => exists i1 i2, i = i1 \+ i2 /\ i1 \In Coh V /\ s.1 i1, 
   fun i y m => forall i1 i2, i = i1 \+ i2 -> i1 \In Coh V -> 
     exists m1 m2, [/\ m = m1 \+ m2, s.2 i1 y m1 &
                       network_rely W2 this i2 m2]).

Lemma inject_has_spec : inject_prog (code_of e) \In has_spec this W inject_s.

Definition inject := with_spec (DTbin_make inject_has_spec).

End Inject.

From DiSeL
Require Import InductiveInv.

Section InductiveInv.
Variable pr : protocol.

Notation l := (plab pr).
Notation coh := (coh pr).
Variable I : dstatelet -> pred nid -> Prop.
Variable ii : InductiveInv pr I.

Variables (A : Type) (this: nid).
Notation V := (mkWorld pr).
Notation W := (mkWorld (ProtocolWithIndInv ii)).

Variable (e : DT this V A).
Notation s := (spec_of e).

Section Prog.

Variable T : prog V A this.

Definition with_inv_set t := 
  t = Unfinished \/ exists t', t' \In T /\ t = WithInv pr I ii (erefl _) t'. 
Definition with_inv_prog := @Prog _ _ _ with_inv_set (or_introl (erefl _)).
End Prog.

Notation getS i := (getStatelet i l).

Definition with_inv_s : spec A :=
  (fun i => s.1 i, 
   fun i y m => m \In Coh W /\ s.2 i y m).

Lemma with_inv_has_spec : with_inv_prog (code_of e) \In has_spec this W with_inv_s.

Definition with_inv := with_spec (DTbin_make with_inv_has_spec).

End InductiveInv.

Definition conseq (W : world) A this (e : DT this W A) (s : spec A) := 
  forall i, s.1 i -> verify i e (s.2 i). 

Lemma conseq_refl (W : world) A this (e : DT this W A) :
  conseq e (spec_of e).

Hint Resolve conseq_refl.

Section Do.

Variable this : nid.
Variables (W : world) (A : Type) (s2 : spec A).
Variables (e : DT this W A) (pf : conseq e s2).

Definition do_prog := DTbin.prog_of (code_of e).

Lemma do_has_spec : do_prog \In has_spec this W s2. 

Definition do' := DTbin_make do_has_spec.

End Do.

Notation iinject x := (@inject _ _ _ _ _ _ x).
Notation uinject x := (@inject _ _ _ Unit _ _ x).

Notation "'Do' e" := (@do' _ _ _ _ e _) (at level 80).

Notation "x '<--' c1 ';' c2" := (bind c1 (fun x => c2)) 
  (at level 81, right associativity).
Notation "c1 ';;' c2" := (bind c1 (fun _ => c2)) 
  (at level 81, right associativity). *)

Set Implicit Arguments.

Unset Strict Implicit.

Import Prenex Implicits.



Definition logvar {B A} (s : A -> spec B) : spec B := 

  (fun i => exists x : A, (s x).1 i, 

   fun y i m => forall x : A, (s x).2 y i m).



Definition binarify {A} (p : pre) (q : cont A) : spec A := 

  (p, fun i y m => p i -> q y m).



Notation "'DHT' [ this , W ] ( p , q ) " := 

  (DTbin this W (binarify p q)) (at level 0, 

   format "'[hv ' DHT  [ this , W ]  ( '[' p , '/' q ']' ) ']'").  



Notation "{ x .. y }, 'DHT' [ this , W ] ( p , q )" :=

  (DTbin this W (logvar (fun x => .. (logvar (fun y => binarify p q)) .. )))

   (at level 0, x binder, y binder, right associativity,

    format "'[hv ' { x .. y }, '/ ' DHT  [ this , W ]  ( '[' p , '/' q ']' ) ']'").



Section BasicRules.



Variable this : nid.



Lemma vrf_coh W A (e : DT this W A) i r : 

        (i \In Coh W -> verify i e r) -> verify i e r.

Proof.

by move=>H C; apply: H.

Qed.



Lemma vrf_pre W A (e : DT this W A) i i' (k : cont A) : 

        verify i e k -> network_rely W this i i' -> verify i' e k. 

Proof.

move=>H M Ci' t H'; case: (rely_coh M)=>Ci _.

by apply: aft_imp (alw_envs (H Ci t H') M).

Qed.



Lemma vrf_post W A (e : DT this W A) i (k : cont A) : 

        verify i e k ->

        verify i e (fun x m => forall m', network_rely W this m m' -> k x m').

Proof.

move=>H Ci t H'; move: (alw_envsq (H Ci t H')).

apply: alw_imp=>s p Cs H2 s3 M v E; apply: H2 E _ M.

Qed.



Lemma bind_rule W A B (e1 : DT this W A) (e2 : A -> DT this W B) i 

             (q : cont A) (r : cont B) : 

        verify i e1 q -> 

        (forall y j, q y j -> j \In Coh W  -> verify j (e2 y) r) ->

        verify i (bind e1 e2) r.

Proof.

move=>H1 H2 Ci t [->|[t'][H3 H4]]. 

- by apply: alw_unfin=>//; move/alw_coh: (H1 Unfinished (prog_unfin e1)). 

by apply: aft_bnd H3 _; move/(H1 Ci): H4; apply: aft_imp=>y j Cj H; apply: H2.

Qed.



Arguments bind_rule [W A B e1 e2 i].



Lemma step W A B (e1 : DT this W A) (e2 : A -> DT this W B) i (r : cont B) : 

        verify i e1 (fun y m => verify m (e2 y) r) ->

        verify i (bind e1 e2) r.

Proof. by move=>H; apply: (bind_rule (fun y m => verify m (e2 y) r)). Qed.



Lemma call_rule' W A i (f : DT this W A) (k : cont A) : 

  

  (i \In Coh W -> pre_of f i) ->

  

  (forall x m, post_of f i x m -> m \In Coh W -> k x m) ->

  verify i f k.

Proof.

case: f=>s [e] /= H H1 H2 Ci t H3.

apply: aft_imp (H i t (H1 Ci) Ci H3). 

by move=>v m Cm H4; apply: H2.

Qed.



Lemma call_rule W A (p : Pred state) (q : A -> Pred state) i

      {e} (k : cont A) : 

        (i \In Coh W -> p i) -> 

        (forall x m, q x m -> m \In Coh W -> k x m) ->

        verify i (@with_spec this W A (binarify p q) e) k.

Proof. 

move=>H1 H2; apply: vrf_coh=>C; apply: call_rule'=>//. 

by move=>x m /(_ (H1 C)); apply: H2.

Qed.



Section GhostRules.



Variables (W : world) (A B C : Type). 



Lemma vrf_mono (e : DT this W A) i (r1 r2 : cont A) : 

        r1 <== r2 -> verify i e r1 -> verify i e r2. 

Proof. by move=>T H1 C' t; move/(H1 C'); apply: aft_imp=>v m _; apply: T. Qed.



Variable (e : DT this W A).



Lemma ghE (s : B -> C -> spec A) : 

        conseq e (logvar (fun x => logvar (s x))) <->

        conseq e (logvar (fun xy => s xy.1 xy.2)).

Proof.

split.

- move=>/= H1 i [[x y]] H2.

  have: exists x1 y1, (s x1 y1).1 i by exists x, y. 

  by move/H1; apply: vrf_mono=>y1 m1 T1 [x2 y2]; apply: (T1 x2 y2). 

move=>/= H1 i [x][y] H2.  

have: exists x, (s x.1 x.2).1 i by exists (x, y). 

by move/H1; apply: vrf_mono=>y1 m1 T1 x2 y2; apply: (T1 (x2, y2)).

Qed.



Lemma ghC (p : B -> pre) (q : B -> A -> pre) :

        (forall i x, p x i -> i \In Coh W -> verify i e (q x)) ->

        conseq e (logvar (fun x => binarify (p x) (q x))).

Proof.

move=>H i /= [x Hp] Ci t Ht. 

have S : alwsafe i t by apply: alw_imp (H i x Hp Ci Ci t Ht). 

by apply/aftA=>// y; apply/aftI=>// /H; apply.

Qed.



Variables (s : C -> spec A) (f : DTbin this W (logvar s)).



Lemma gh_conseq t : conseq f (s t).

Proof.

case E: (s t)=>[a b] h /= H; apply: call_rule'=>[|x m]. 

- by exists t; rewrite E. 

by move/(_ t); rewrite E. 

Qed.



Lemma gh_ex g i (k : cont A) : 

        verify i (do' (@gh_conseq g)) k ->

        verify i (@with_spec this W A (logvar s) f) k.

Proof. by []. Qed.



End GhostRules.



Arguments gh_ex [W A C s f].



Lemma act_rule W A (a: action W A this) i (r : cont A) :

  (forall j, network_rely W this i j -> a_safe a j /\

   forall y k m, (exists pf : a_safe a j, a_step pf k y) -> network_rely W this k m -> r y m) ->

        verify i (act a) r. 

Proof.

move=>H C p; case=>Z; subst p; first by apply: (alw_unfin C).

apply: (alw_act C)=>j R; case: (H j R)=>{H}S H; exists S.

split=>//k v m St R' v'[]<-.

have X: (exists pf : a_safe a j, a_step pf k v) by exists S.

by apply: (H _ _ _ X R').

Qed.



Lemma ret_rule W A i (v : A) (r : cont A) : 

       (forall m, network_rely W this i m -> r v m) ->       

       verify i (ret this W v) r. 

Proof.

move=>H C p; case=>Z; subst p; first by apply: alw_unfin.

by apply: alw_ret=>//m R v'[]<-; apply: H.

Qed.  



End BasicRules.



Section InjectLemmas.



Variable this : nid.

Variables (W V : world) (K : hooks) (A : Type) (w : injects V W K).

Notation W2 := (inj_ext w).



Variable (e1 : DT this V A).



Lemma inject_rule i j (r : cont A) : 

        i \In Coh V -> 

        verify i e1 (fun x i' => forall j', 

          i' \+ j' \In Coh W -> network_rely W2 this j j' -> r x (i' \+ j')) ->

        verify (i \+ j) (inject w e1) r.

Proof.

move=>Ci H C t [->|[t' [H' ->{t}]]]; first by apply: alw_unfin. 

move/aft_inject: {H H'} (H Ci _ H'); move/(_ _ _ w _ C). 

apply: aft_imp=>v s Cs [i'][j'][E] Ci' S'.

by rewrite {s}E in Cs *; apply.

Qed.



End InjectLemmas.



Section InductiveInvLemmas.



Variable pr : protocol.



Notation l := (plab pr).

Variable I : dstatelet -> pred nid -> Prop.

Variable ii : InductiveInv pr I.



Variables (A : Type) (this: nid).

Notation V := (mkWorld pr).

Notation W := (mkWorld (ProtocolWithIndInv ii)).



Variable (e : DT this V A).



Notation getS i := (getStatelet i l).



Lemma with_inv_rule' i (r : cont A) : 

  verify i e (fun x m =>

              I (getS m) (nodes pr (getS m)) -> r x m) ->

        verify i (with_inv ii e) r.

Proof.

move=> H C t [->|[t' [H' ->{t}]]]; first by apply: alw_unfin. 

move/aft_ind_inv: {H H'}(H (with_inv_coh C) _ H')=>/(_ _ _ C).

apply: aft_imp=>v m _[C']; apply.

by case: C'=>_ _ _ _/(_ l); rewrite prEq; case.

Qed.        



Lemma with_inv_rule i (r : cont A) : 

        verify i e (fun x m => r x m) ->

        verify i (with_inv ii e) r.

Proof.

move=>H; apply: with_inv_rule'.

by move=>H1 p H2; move: (H H1 p H2)=>G; apply: (aft_imp _ G).

Qed.



End InductiveInvLemmas.

