From mathcomp.ssreflect

Require Import ssreflect ssrbool ssrnat eqtype ssrfun seq.

From mathcomp

Require Import path.

Require Import Eqdep.

Require Import Relation_Operators.

From fcsl

Require Import pred prelude ordtype finmap pcm unionmap heap.

From DiSeL

Require Import Freshness DepMaps EqTypeX.
(* Freshness:
From mathcomp.ssreflect
Require Import ssreflect ssrbool ssrnat eqtype ssrfun seq.
From mathcomp
Require Import path.
From fcsl
Require Import pred prelude ordtype finmap pcm unionmap.
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Section Keys.
Variables (K : ordType) (V : Type) (U : union_map_class K V).
Implicit Types (k : K) (v : V) (f : U).

Lemma keys_last_mono f1 f2 k :
        path oleq k (dom f1) ->
        path oleq k (dom f2) ->
        (forall x, x \in dom f1 -> x \in dom f2) ->
        oleq (last k (dom f1)) (last k (dom f2)).

End Keys.

Section FreshLastKey.
Variable V : Type.
Implicit Type f : union_map [ordType of nat] V.

Definition last_key f := last 0 (dom f).

Lemma last_key0 : last_key Unit = 0.

Lemma last_key_dom f : valid f -> last_key f \notin dom f -> f = Unit.

Lemma dom_last_key f :  valid f -> ~~ empb f -> last_key f \in dom f.

Lemma last_key_max f x : x \in dom f -> x <= last_key f.

Lemma max_key_last f x :
        x \in dom f -> {in dom f, forall y, y <= x} -> last_key f = x.

Lemma last_keyPt (x : nat) v : last_key (x \\-> v) = x.

Lemma hist_path f : path oleq 0 (dom f).

Lemma last_key_mono f1 f2 :
        {subset dom f1 <= dom f2} -> last_key f1 <= last_key f2.

Lemma last_keyfUn f1 f2 :
        valid (f1 \+ f2) -> last_key f1 <= last_key (f1 \+ f2).

Lemma last_keyUnf f1 f2 :
        valid (f1 \+ f2) -> last_key f2 <= last_key (f1 \+ f2).

Definition fresh f := (last_key f).+1.

Lemma dom_ordfresh f x : x \in dom f -> x < fresh f.

Lemma dom_freshn f n : fresh f + n \notin dom f.

Lemma dom_fresh f : fresh f \notin dom f.

Lemma valid_fresh f v : valid (f \+ fresh f \\-> v) = valid f.

Lemma valid_fresh' f v i w :
  valid (f \+ i \\-> w) ->
  valid (f \+ fresh (f \+ i \\-> w) \\-> v).

Lemma last_fresh f v : valid f -> last_key (f \+ fresh f \\-> v) = fresh f.

End FreshLastKey. *)
(* DepMaps:
From mathcomp.ssreflect
Require Import ssreflect ssrbool ssrnat eqtype ssrfun seq.
From mathcomp
Require Import path.
Require Import Eqdep.
Require Import Relation_Operators.
From fcsl
Require Import pred prelude ordtype finmap pcm unionmap heap.
From DiSeL
Require Import Freshness EqTypeX.
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Module DepMaps.

Section DepMaps.

Definition Label := [ordType of nat].

Variable V : Type.
Variable labF: V -> Label.

Definition dmDom (u : union_map Label V) : bool :=
    all (fun l => if find l u is Some p then (labF p) == l else false) (dom u).

Record depmap := DepMap {
   dmap : union_map Label V;
   pf   : dmDom dmap;
}.

Section PCMOps.

Variable dm : depmap.

Lemma dmDom_unit : dmDom Unit.

Definition unit := DepMap dmDom_unit.

End PCMOps.

Section DJoin.

Variables (dm1 dm2 : depmap). 

Lemma dmDom_join um1 um2:
  dmDom um1 -> dmDom um2 -> dmDom (um1 \+ um2).

Definition join : depmap := DepMap (dmDom_join (@pf dm1) (@pf dm2)).

Definition valid (dm : depmap) := valid (dmap dm).

End DJoin.

End DepMaps.

Section PCMLaws.

Variables (V : Type) (labF: V -> [ordType of nat]).
Implicit Type f : depmap labF.

Local Notation "f1 \+ f2" := (join f1 f2)
                               (at level 43, left associativity).

Local Notation unit := (unit labF).

Lemma joinC f1 f2 : f1 \+ f2 = f2 \+ f1.

Lemma joinCA f1 f2 f3 : f1 \+ (f2 \+ f3) = f2 \+ (f1 \+ f3).

Lemma joinA f1 f2 f3 : f1 \+ (f2 \+ f3) = (f1 \+ f2) \+ f3.

Lemma validL f1 f2 : valid (f1 \+ f2) -> valid f1.

Lemma unitL f : unit \+ f = f.

Lemma validU : valid unit.

End PCMLaws.

Module Exports.
Section Exports.
Variable V : Type.
Variable labF: V -> Label.
Definition depmap := depmap.
Definition DepMap := DepMap.

Lemma dep_unit (d : depmap labF) : dmap d = Unit -> d = unit labF.

Coercion dmap := dmap.
Definition ddom (d : depmap labF) := dom (dmap d).
Definition dfind x (d : depmap labF) := find x (dmap d).

Definition depmap_classPCMMixin :=
  PCMMixin (@joinC V labF) (@joinA V labF) (@unitL V labF) (@validL V labF) (validU labF).

Canonical depmap_classPCM := Eval hnf in PCM (depmap labF) depmap_classPCMMixin.

End Exports.
End Exports.

End DepMaps.

Export DepMaps.Exports. *)
(* EqTypeX:
From mathcomp.ssreflect
Require Import ssreflect ssrbool ssrnat eqtype ssrfun seq.
From mathcomp
Require Import path.
Require Import Eqdep.
Require Import Relation_Operators.

Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Module EqualityX.

Definition axiom T (e : rel T) := forall x y, reflect (x = y) (e x y).

Structure mixin_of T := Mixin {op : rel T; _ : axiom op}.
Notation class_of := mixin_of (only parsing).

Section ClassDef.

Structure type := Pack {sort; _ : class_of sort; _ : Type}.
Local Coercion sort : type >-> Sortclass.
Variables (T : Type) (cT : type).

Definition class := let: Pack _ c _ := cT return class_of cT in c.

Definition pack c := @Pack T c T.
Definition clone := fun c & cT -> T & phant_id (pack c) cT => pack c.

End ClassDef.

Module Exports.
Coercion sort : type >-> Sortclass.
Notation eqTypeX := type.
Notation EqMixinX := Mixin.
Notation EqTypeX T m := (@pack T m).
End Exports.

End EqualityX.
Export EqualityX.Exports.

Section EqualityConversion.

Variable U: eqTypeX.
Definition eq_opX T := EqualityX.op (EqualityX.class T).

Lemma eqxP : Equality.axiom (@eq_opX U).

Canonical eqMixinX := EqMixin eqxP.
Canonical eqTypeX' := EqType U eqMixinX.                                   

End EqualityConversion. *)

Set Implicit Arguments.

Unset Strict Implicit.

Unset Printing Implicit Defensive.



Section TaggedMessages. 



  Structure TaggedMessage :=

    TMsg {

        tag: nat;

        
        tms_cont :> seq nat          

      }.



End TaggedMessages.



Section Shared.



  Definition Label := [ordType of nat].



  Structure msg (mtype : Type) :=

    Msg {content  : mtype;

         from     : nat;

         to       : nat;

         active   : bool }.



  Definition mid := [ordType of nat].



  Definition soup : Type :=

    union_map mid (msg (TaggedMessage)).



  Variables (s: soup) (V: valid s).



  Definition post_msg m : soup * mid :=

    let: f := fresh s in (s \+ f \\-> m, f).



  Lemma post_valid m :  valid (post_msg m).1.

  Proof. by rewrite ?valid_fresh. Qed.



  Lemma post_fresh m : (post_msg m).2 \notin dom s.

  Proof. by rewrite ?dom_fresh. Qed.



  Definition mark_msg T (m : msg T) : msg T :=

    Msg (content m) (from m) (to m) false.



  Definition consume_msg (s : soup) (id : mid) : soup :=

    let: mr := find id s in

    if mr is Some m then upd id (mark_msg m) s else s.



  Definition is_active (id : mid) :=

    exists m, find id s = Some m /\ active m.



  Definition is_consumed (id : mid) :=

    exists m, find id s = Some m /\ ~~ active m.



  Lemma find_consume s' (id: mid) m:

    valid s' -> find id s' = Some m ->

    find id (consume_msg s' id) = Some (mark_msg m).

  Proof. by move=>V' E; rewrite/consume_msg E findU eqxx V'/=. Qed.



  Lemma find_mark m s' msg :

    valid s' -> find m (consume_msg s' m) = Some msg ->

    exists msg', find m s' = Some msg' /\ msg = mark_msg msg'.

  Proof.

  move=>V'; rewrite /consume_msg; case D: (m \in dom s').

  - move/um_eta: D=>[msg'][->]_; rewrite findU eqxx/= V'.

    by case=><-; eexists _.

  by case: dom_find (D)=>//->_; move/find_some=>Z; rewrite Z in D.

  Qed.   



  Lemma mark_other m m' s' :

    valid s' -> m' == m = false -> find m' (consume_msg s' m) = find m' s'.

  Proof.

  move=>V' N; rewrite /consume_msg; case D: (m \in dom s').

  by case: dom_find (D)=>//v->_ _; rewrite findU N.

  by case: dom_find (D)=>//->_.

  Qed.   



  Lemma consume_valid s' m : valid s' -> valid (consume_msg s' m).

  Proof.

  move=>V'; rewrite /consume_msg; case (find m s')=>//v.

  by rewrite /mark_msg validU.

  Qed.



  Lemma consumeUn (s': soup) (i : mid) mm

        (j : mid) : valid (s' \+ i \\-> mm) ->

    consume_msg (s' \+ i \\-> mm) j = 

    if i == j then s' \+ i \\-> mark_msg mm

    else (consume_msg s' j) \+ (i \\-> mm).

  Proof.

  rewrite ![_ \+ i \\-> _]joinC; rewrite eq_sym.

  move=>V'; case B: (j==i); rewrite /consume_msg findPtUn2// B.

  - by move/eqP: B=>?; subst j; rewrite updPtUn.

  by case X: (find j s')=>//; rewrite updUnL domPt inE eq_sym B.   

  Qed.



  Notation "'{{' m 'in' s 'at' id '}}'" := (find id s = Some m).

  Notation "'{{' m 'in' s '}}'" := (exists id, {{m in s at id}}).



End Shared.



Section Local.



  Variable U : Type.



  Definition nid := nat.



  Definition lstate_type := union_map [ordType of nid] U.



End Local.



Section Statelets.



  Structure dstatelet  :=

    DStatelet {

        
        dstate     : lstate_type heap;

        dsoup      : soup

    }.



  Fixpoint empty_lstate (ns : seq nid) :=

    if ns is n :: ns'

    then n \\-> Heap.empty \+ (empty_lstate ns')

    else  Unit.

    

  Definition empty_dstatelet : dstatelet :=

    @DStatelet (empty_lstate [::]) Unit.



  Lemma valid_mt_soup : valid (dsoup empty_dstatelet).

  Proof. by rewrite /= valid_unit. Qed.



  Lemma valid_mt_state  : valid (dstate empty_dstatelet).

  Proof. by rewrite valid_unit. Qed.



  Lemma mt_nodes : dom (dstate empty_dstatelet) =i [::].

  Proof. by rewrite dom0. Qed.



End Statelets.



Module StateGetters.

Section StateGetters.



Definition state := union_map Label dstatelet.



Definition getStatelet (s: state) (i : Label) : dstatelet :=

  match find i s with

  | Some d => d

  | None => empty_dstatelet

  end.



End StateGetters.

End StateGetters.



Export StateGetters.

