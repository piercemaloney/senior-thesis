From mathcomp.ssreflect
Require Import ssreflect ssrbool ssrnat eqtype ssrfun seq.
From mathcomp
Require Import path.
Require Import Eqdep.
Require Import Relation_Operators.
From fcsl
Require Import axioms pred prelude ordtype finmap pcm unionmap heap.
From DiSeL
Require Import Freshness State EqTypeX Protocols Worlds NetworkSem Rely.
(* Freshness:
From mathcomp.ssreflect
Require Import ssreflect ssrbool ssrnat eqtype ssrfun seq.
From mathcomp
Require Import path.
From fcsl
Require Import pred prelude ordtype finmap pcm unionmap.
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Section Keys.
Variables (K : ordType) (V : Type) (U : union_map_class K V).
Implicit Types (k : K) (v : V) (f : U).

Lemma keys_last_mono f1 f2 k :
        path oleq k (dom f1) ->
        path oleq k (dom f2) ->
        (forall x, x \in dom f1 -> x \in dom f2) ->
        oleq (last k (dom f1)) (last k (dom f2)).

End Keys.

Section FreshLastKey.
Variable V : Type.
Implicit Type f : union_map [ordType of nat] V.

Definition last_key f := last 0 (dom f).

Lemma last_key0 : last_key Unit = 0.

Lemma last_key_dom f : valid f -> last_key f \notin dom f -> f = Unit.

Lemma dom_last_key f :  valid f -> ~~ empb f -> last_key f \in dom f.

Lemma last_key_max f x : x \in dom f -> x <= last_key f.

Lemma max_key_last f x :
        x \in dom f -> {in dom f, forall y, y <= x} -> last_key f = x.

Lemma last_keyPt (x : nat) v : last_key (x \\-> v) = x.

Lemma hist_path f : path oleq 0 (dom f).

Lemma last_key_mono f1 f2 :
        {subset dom f1 <= dom f2} -> last_key f1 <= last_key f2.

Lemma last_keyfUn f1 f2 :
        valid (f1 \+ f2) -> last_key f1 <= last_key (f1 \+ f2).

Lemma last_keyUnf f1 f2 :
        valid (f1 \+ f2) -> last_key f2 <= last_key (f1 \+ f2).

Definition fresh f := (last_key f).+1.

Lemma dom_ordfresh f x : x \in dom f -> x < fresh f.

Lemma dom_freshn f n : fresh f + n \notin dom f.

Lemma dom_fresh f : fresh f \notin dom f.

Lemma valid_fresh f v : valid (f \+ fresh f \\-> v) = valid f.

Lemma valid_fresh' f v i w :
  valid (f \+ i \\-> w) ->
  valid (f \+ fresh (f \+ i \\-> w) \\-> v).

Lemma last_fresh f v : valid f -> last_key (f \+ fresh f \\-> v) = fresh f.

End FreshLastKey. *)
(* State:
From mathcomp.ssreflect
Require Import ssreflect ssrbool ssrnat eqtype ssrfun seq.
From mathcomp
Require Import path.
Require Import Eqdep.
Require Import Relation_Operators.
From fcsl
Require Import pred prelude ordtype finmap pcm unionmap heap.
From DiSeL
Require Import Freshness DepMaps EqTypeX.
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Section TaggedMessages. 

  Structure TaggedMessage :=
    TMsg {
        tag: nat;
                tms_cont :> seq nat          
      }.

End TaggedMessages.

Section Shared.

  Definition Label := [ordType of nat].

  Structure msg (mtype : Type) :=
    Msg {content  : mtype;
         from     : nat;
         to       : nat;
         active   : bool }.

  Definition mid := [ordType of nat].

  Definition soup : Type :=
    union_map mid (msg (TaggedMessage)).

  Variables (s: soup) (V: valid s).

  Definition post_msg m : soup * mid :=
    let: f := fresh s in (s \+ f \\-> m, f).

  Lemma post_valid m :  valid (post_msg m).1.

  Lemma post_fresh m : (post_msg m).2 \notin dom s.

  Definition mark_msg T (m : msg T) : msg T :=
    Msg (content m) (from m) (to m) false.

  Definition consume_msg (s : soup) (id : mid) : soup :=
    let: mr := find id s in
    if mr is Some m then upd id (mark_msg m) s else s.

  Definition is_active (id : mid) :=
    exists m, find id s = Some m /\ active m.

  Definition is_consumed (id : mid) :=
    exists m, find id s = Some m /\ ~~ active m.

  Lemma find_consume s' (id: mid) m:
    valid s' -> find id s' = Some m ->
    find id (consume_msg s' id) = Some (mark_msg m).

  Lemma find_mark m s' msg :
    valid s' -> find m (consume_msg s' m) = Some msg ->
    exists msg', find m s' = Some msg' /\ msg = mark_msg msg'.

  Lemma mark_other m m' s' :
    valid s' -> m' == m = false -> find m' (consume_msg s' m) = find m' s'.

  Lemma consume_valid s' m : valid s' -> valid (consume_msg s' m).

  Lemma consumeUn (s': soup) (i : mid) mm
        (j : mid) : valid (s' \+ i \\-> mm) ->
    consume_msg (s' \+ i \\-> mm) j = 
    if i == j then s' \+ i \\-> mark_msg mm
    else (consume_msg s' j) \+ (i \\-> mm).

  Notation "'{{' m 'in' s 'at' id '}}'" := (find id s = Some m).
  Notation "'{{' m 'in' s '}}'" := (exists id, {{m in s at id}}).

End Shared.

Section Local.

  Variable U : Type.

  Definition nid := nat.

  Definition lstate_type := union_map [ordType of nid] U.

End Local.

Section Statelets.

  Structure dstatelet  :=
    DStatelet {
                dstate     : lstate_type heap;
        dsoup      : soup
    }.

  Fixpoint empty_lstate (ns : seq nid) :=
    if ns is n :: ns'
    then n \\-> Heap.empty \+ (empty_lstate ns')
    else  Unit.
    
  Definition empty_dstatelet : dstatelet :=
    @DStatelet (empty_lstate [::]) Unit.

  Lemma valid_mt_soup : valid (dsoup empty_dstatelet).

  Lemma valid_mt_state  : valid (dstate empty_dstatelet).

  Lemma mt_nodes : dom (dstate empty_dstatelet) =i [::].

End Statelets.

Module StateGetters.
Section StateGetters.

Definition state := union_map Label dstatelet.

Definition getStatelet (s: state) (i : Label) : dstatelet :=
  match find i s with
  | Some d => d
  | None => empty_dstatelet
  end.

End StateGetters.
End StateGetters.

Export StateGetters. *)
(* EqTypeX:
From mathcomp.ssreflect
Require Import ssreflect ssrbool ssrnat eqtype ssrfun seq.
From mathcomp
Require Import path.
Require Import Eqdep.
Require Import Relation_Operators.

Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Module EqualityX.

Definition axiom T (e : rel T) := forall x y, reflect (x = y) (e x y).

Structure mixin_of T := Mixin {op : rel T; _ : axiom op}.
Notation class_of := mixin_of (only parsing).

Section ClassDef.

Structure type := Pack {sort; _ : class_of sort; _ : Type}.
Local Coercion sort : type >-> Sortclass.
Variables (T : Type) (cT : type).

Definition class := let: Pack _ c _ := cT return class_of cT in c.

Definition pack c := @Pack T c T.
Definition clone := fun c & cT -> T & phant_id (pack c) cT => pack c.

End ClassDef.

Module Exports.
Coercion sort : type >-> Sortclass.
Notation eqTypeX := type.
Notation EqMixinX := Mixin.
Notation EqTypeX T m := (@pack T m).
End Exports.

End EqualityX.
Export EqualityX.Exports.

Section EqualityConversion.

Variable U: eqTypeX.
Definition eq_opX T := EqualityX.op (EqualityX.class T).

Lemma eqxP : Equality.axiom (@eq_opX U).

Canonical eqMixinX := EqMixin eqxP.
Canonical eqTypeX' := EqType U eqMixinX.                                   

End EqualityConversion. *)
(* Protocols:
From mathcomp.ssreflect
Require Import ssreflect ssrbool ssrnat eqtype ssrfun seq.
From mathcomp
Require Import path.
Require Import Eqdep.
Require Import Relation_Operators.
From fcsl
Require Import pred prelude ordtype finmap pcm unionmap heap.
From DiSeL
Require Import Freshness State EqTypeX.
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Definition getLocal (n : nid) (d : dstatelet) : heap :=
  match find n (dstate d) with
  | Some h => h
  | None => Unit
  end.

Lemma getLocalU n m d s :
  valid (dstate d) -> m \in dom (dstate d) ->
  getLocal n d = (getLocal n {| dstate := upd m (getLocal m d) (dstate d); dsoup := s |}).
        
Module Coherence.

Section CohDef.

Variable nodes: dstatelet -> pred nid.

Notation protocol_soup  := (soup (TaggedMessage)).

Structure mixin_of (coh : Pred dstatelet) := Mixin {
    _   : forall d, coh d -> valid (dstate d);
    _   : forall d, coh d -> valid (dsoup d);
    _   : forall d, coh d -> dom (dstate d) =i nodes d;
}.

End CohDef.

Section ClassDef.

Variable nodes: dstatelet -> pred nid.

Notation class_of := mixin_of (only parsing).

Structure cohpred : Type := Pack {sort : dstatelet -> Prop;
                                  _ : class_of nodes sort}.
Local Coercion sort : cohpred >-> Funclass.

Variables (T : dstatelet -> Prop) (cT : cohpred).

Definition class := let: Pack _ c as cT' := cT
                    return class_of nodes cT' in c.

Definition pack c := @Pack T c.
Definition clone := fun c & T = cT & phant_id (pack c) cT => pack c. 

End ClassDef.

Module Exports.
Section Exports.

Variable Lstate : Type.
Variable nodes: dstatelet -> pred nid.

Coercion sort : cohpred >-> Funclass.
Definition cohpred := cohpred.
Definition CohPredMixin := Mixin.
Definition CohPred T m := (@pack T m).

Notation "[ 'cohPredMixin' 'of' T ]" := (class _ : mixin_of T)
  (at level 0, format "[ 'cohPredMixin'  'of'  T ]") : form_scope.
Notation "[ 'cohpred' 'of' T 'for' C ]" := (@clone T C _ (erefl _) id)
  (at level 0, format "[ 'cohpred'  'of'  T  'for'  C ]") : form_scope.
Notation "[ 'cohpred' 'of' T ]" := (@clone T _ _ (erefl _) id)
  (at level 0, format "[ 'cohpred'  'of'  T ]") : form_scope.

Canonical cohpred_PredType := mkPredType (@sort nodes).

Variable coh : cohpred nodes.

Lemma cohVl d : d \In coh -> valid (dstate d).

Lemma cohVs d : d \In coh -> valid (dsoup d).

Lemma cohDom d : d \In coh -> dom (dstate d) =i nodes d.

End Exports.
End Exports.
End Coherence.

Export Coherence.Exports.

Module Transitions.
Section Transitions.

Variable nodes: dstatelet -> pred nid.

Variable coh : cohpred nodes.

Notation lstate := heap%type.

Definition send_step_t (send_safe : nid -> nid -> dstatelet -> seq nat -> Prop) :=
  forall (this to : nid) (d : dstatelet)
         (msg : seq nat) (pf : send_safe this to d msg),
    option lstate.

Definition s_step_coh_t t_snd
           (send_safe : nid -> nid -> dstatelet -> seq nat -> Prop)
           (send_step : send_step_t send_safe) :=
  forall this to d msg (pf : send_safe this to d msg) b,
    let: f := dstate d in
    let: s := dsoup d  in
    Some b = @send_step this to d msg pf ->         
    let: f' := upd this b f in
    let: tms := TMsg t_snd msg in 
    let: s' := (post_msg s (Msg tms this to true)).1 in 
    coh (DStatelet f' s').

Structure send_trans := SendTrans
    {
      t_snd : nat;

      send_safe : nid -> nid -> dstatelet -> seq nat -> Prop;
      s_safe_coh : forall this to d m, send_safe this to d m -> coh d;
      s_safe_in  : forall this to d m, send_safe this to d m ->
                                       this \in nodes d /\ to \in nodes d;  

      send_step : send_step_t send_safe;

      s_safe_def : forall this to d msg,
          send_safe this to d msg <->
          exists b pf, @send_step this to d msg pf = Some b;

      s_step_coh : s_step_coh_t t_snd send_step 
    }.

Definition receive_step_t :=
  forall (this from: nid) (m : seq nat)
         (d : dstatelet) (pf : coh d)
         (pf' : this \in nodes d), lstate.

Definition r_step_coh_t (msg_wf : forall d, coh d -> nid -> nid -> TaggedMessage -> bool)
           t_rcv (receive_step : receive_step_t) :=
  forall (d : dstatelet) from this i (C : coh d) (pf' : this \in nodes d)
         (m : TaggedMessage),
    let: f := dstate d in
    let: s := dsoup d  in
    this \in dom f ->
    find i s = Some (Msg m from this true) ->
    msg_wf d C this from m -> tag m = t_rcv ->
    let: loc' := receive_step this from m d C pf' in
    let: s'' := consume_msg s i in
    let: f' := upd this loc' f in
    coh (DStatelet f' s'').

Structure receive_trans := ReceiveTrans
    {
      t_rcv : nat;

      msg_wf : forall d, coh d -> nid -> nid -> TaggedMessage -> bool;

      receive_step : receive_step_t;

      r_step_coh : r_step_coh_t msg_wf t_rcv receive_step
    }.

End Transitions.

Module Exports.

Definition SendTrans := SendTrans.
Definition send_trans := send_trans.
Definition ReceiveTrans := ReceiveTrans.
Definition receive_trans := receive_trans.

Definition t_snd := t_snd.
Definition send_safe := send_safe.
Definition send_step := send_step.
Definition send_step_t := send_step_t.

Definition s_safe_coh := s_safe_coh.
Definition s_safe_in := s_safe_in.
Definition s_safe_def := s_safe_def.
Definition s_step_coh := s_step_coh.
Definition s_step_coh_t := s_step_coh_t.

Definition t_rcv := t_rcv.
Definition msg_wf := msg_wf.

Definition receive_step := receive_step.
Definition receive_step_t := receive_step_t.
Definition r_step_coh := r_step_coh.
Definition r_step_coh_t := r_step_coh_t.

End Exports.

End Transitions.

Export Transitions.Exports.

Module Protocols.
Section Protocols.

Definition snd_tags {nodes} {coh : cohpred nodes}
           (sts : seq (send_trans coh)) := 
  map (@t_snd nodes _) sts.

Definition rcv_tags {nodes} {coh : cohpred nodes} (sts : seq (receive_trans coh)) :=
  map (@t_rcv nodes _) sts.

Structure protocol := Protocol {
  nodes: dstatelet -> pred nid;
  plab : Label;                        
  coh : cohpred nodes ;
  snd_trans : seq (send_trans coh);
  rcv_trans : seq (receive_trans coh);

  snd_uniq : uniq (snd_tags snd_trans);
  rcv_uniq : uniq (rcv_tags rcv_trans);
}.

End Protocols.

Module Exports.
Section Exports.

Definition protocol := protocol.
Definition Protocol := Protocol.
Definition plab := plab.
Definition nodes := nodes.
Definition coh := coh.
Definition snd_trans := snd_trans.
Definition rcv_trans := rcv_trans.

Definition snd_tags p := snd_tags (snd_trans p).
Definition rcv_tags p := rcv_tags (rcv_trans p).

Definition snd_uniq := snd_uniq.
Definition rcv_uniq := rcv_uniq.

Definition cohMT d := d = empty_dstatelet.

Lemma pred0v1 d: cohMT d -> valid (dstate d).

Lemma pred0v2 d: cohMT d -> valid (dsoup d).

Lemma pred0v3 d: cohMT d -> dom (dstate d) =i [::].

Definition EmptyProtMixin := CohPredMixin pred0v1 pred0v2 pred0v3.
Definition empty_coh := CohPred EmptyProtMixin.

Lemma snd_uniq0 {nodes} {coh : cohpred nodes} :
  uniq (@Protocols.snd_tags _ coh ([::] : seq (send_trans coh))).

Lemma rcv_uniq0 {nodes} {coh : cohpred nodes} :
  uniq (@Protocols.rcv_tags nodes _ ([::] : seq (receive_trans coh))).

Definition EmptyProt i : protocol :=
  @Protocol (fun _ => pred0) i empty_coh [::] [::] snd_uniq0 rcv_uniq0.

End Exports.
End Exports.

End Protocols.

Export Protocols.Exports. *)
(* Worlds:
From mathcomp.ssreflect
Require Import ssreflect ssrbool ssrnat eqtype ssrfun seq.
From mathcomp
Require Import path.
Require Import Eqdep.
Require Import Relation_Operators.
From fcsl
Require Import pred prelude ordtype finmap pcm unionmap heap.
From DiSeL
Require Import Freshness State EqTypeX Protocols.
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Module WorldGetters.
Section WorldGetters.

Definition context := union_map Label protocol.

Definition hook_domain := [ordType of ((nat * Label) * (Label * nat))%type].

Definition hook_type := heap -> heap -> seq nat -> nid -> Prop.

Definition hooks := union_map hook_domain hook_type.
Definition world := (context * hooks)%type.

Definition getc (w: world) : context := fst w.
Coercion getc : world >-> context.

Definition geth (w: world) : hooks := snd w.
Coercion geth : world >-> hooks.

Variable w : world.

Variables (p : protocol).

Definition getProtocol i : protocol:=
  match find i (getc w) with
  | Some p => p
  | None => EmptyProt i 
  end.

End WorldGetters.
End WorldGetters.

Export WorldGetters.

Module Worlds.

Module Core.
Section Core.

Definition hooks_consistent (c : context) (h : hooks) : Prop :=
  forall z lc ls t, ((z, lc), (ls, t)) \in dom h ->
  (lc \in dom c) && (ls \in dom c).

Definition hook_complete w := hooks_consistent (getc w) (geth w).

Lemma hook_complete0 c : hook_complete (c, Unit).

Definition Coh (w : world) : Pred state := fun s =>
  let: c := fst w in
  let: h := snd w in                                           
  [/\ valid w, valid s, hook_complete w,
      dom c =i dom s &
      forall l, coh (getProtocol w l) (getStatelet s l)].

Lemma cohW w s : Coh w s -> valid w.

Lemma cohS w s : Coh w s -> valid s.

Lemma cohH w s : Coh w s -> hook_complete w.

Lemma cohD w s : Coh w s -> dom (getc w) =i dom s.

Lemma coh_coh w s l : Coh w s -> coh (getProtocol w l) (getStatelet s l).

Lemma unit_coh w s :
  Coh w s -> w = Unit <-> s = Unit.

Lemma Coh0 (w : world) (s : state) :
  w = Unit -> s = Unit -> Coh w s.

Lemma CohUn (w1 w2 : world) (s1 s2 : state) :
  Coh w1 s1 -> Coh w2 s2 ->
  valid (w1 \+ w2) -> Coh (w1 \+ w2) (s1 \+ s2).

Lemma coh_prec w: precise (Coh w).

Lemma locE i n k x y :
  k \in dom i -> valid i -> valid (dstate (getStatelet i k)) ->
  getLocal n (getStatelet (upd k
       {| dstate := upd n x (dstate (getStatelet i k));
          dsoup := y |} i) k) = x.

Lemma locE' d n x y :
  valid (dstate d) ->
  getLocal n {| dstate := upd n x (dstate d);
                dsoup := y |} = x.

Lemma locU n n' x st s :
  n != n' ->
  valid st ->
  getLocal n {| dstate := upd n' x st; dsoup := s |} =
  getLocal n {| dstate := st; dsoup := s |}.

Section MakeWorld.

Variable p : protocol.
Notation l := (plab p).

Definition mkWorld : world := (l \\-> p, Unit).

Lemma prEq : (getProtocol mkWorld l) = p.
                          
End MakeWorld.

End Core.
End Core.

End Worlds.

Export Worlds.Core. *)
(* NetworkSem:
From mathcomp.ssreflect 
Require Import ssreflect ssrbool ssrnat eqtype ssrfun seq.
From mathcomp
Require Import path.
Require Import Eqdep.
Require Import Relation_Operators.
From fcsl
Require Import axioms pred prelude ordtype finmap pcm unionmap heap.
From DiSeL
Require Import Freshness State EqTypeX Protocols Worlds.
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Section NetworkSemantics.

Variable w : world.
Variable this: nid.

Notation getl := (getLocal).
Notation gets := (getStatelet).
Notation getp := (@getProtocol w).

Definition get_coh l := @coh (getp l).
Definition get_st l := @snd_trans (getp l).
Definition get_rt l := @rcv_trans (getp l).

Lemma getsE l s : l \in dom s -> find l s = Some (gets s l).

Lemma coh_s l s: Coh w s -> coh (getp l) (gets s l).

Lemma Coh_dom l s : l \in dom s -> Coh w s -> 
                     dom (dstate (gets s l)) =i nodes (getp l) (gets s l).

Definition all_hooks_fire (h : hooks) l st s n (msg : seq nat) to :=
  
  forall z lc hk, Some hk = find ((z, lc), (l, st)) h ->
  lc \in dom s -> l \in dom s ->               
  let: core_local   := getl n (gets s lc) in
  let: client_local := getl n (gets s l)  in              
  hk core_local client_local msg to.

Inductive network_step (s1 s2 : state) : Prop :=
  
  Idle of s1 \In Coh w /\ s1 = s2

| SendMsg 
          l st (_ : st \In @get_st l) to msg b
          (pf: this \in (nodes (getp l) (gets s1 l)))
          (pf' : l \in dom s1) (C: Coh w s1)
          
          (S : send_safe st this to (gets s1 l) msg)

          (pf_hooks : all_hooks_fire (geth w) l (t_snd st) s1 this msg to)
          
          (spf : Some b = send_step S) of
          
          let: d :=  gets s1 l in

          let: f' := upd this b (dstate d) in
          let: s' := (post_msg (dsoup d) (Msg (TMsg (t_snd st) msg)
                                              this to true)).1 in
          s2 = upd l (DStatelet f' s') s1

| ReceiveMsg l rt (_ : rt \In @get_rt l) i from
             
             (pf: this \in (nodes (getp l)) (gets s1 l))
             (pf': l \in dom s1) (C: Coh w s1)
             (msg : TaggedMessage)
             (pf': tag msg = t_rcv rt) of
             let: d := (gets s1 l) in
             let: f := dstate d in
             let: s := dsoup d  in

             [/\ find i s = Some (Msg msg from this true),
              msg_wf rt (coh_s l C) this from msg &
              
              let loc' := receive_step rt from msg (coh_s l C) pf in
              let: f' := upd this loc' f in
              let: s'' := consume_msg s i in
              s2 = upd l (DStatelet f' s'') s1].

Lemma step_coh s1 s2: network_step s1 s2 ->
                      Coh w s1 /\ Coh w s2.

Lemma step_preserves_labels s1 s2 :
  network_step s1 s2 -> dom s1 =i dom s2.

Lemma step_is_local s1 s2 l: network_step s1 s2 ->
  forall z, z != this ->
  find z (dstate (gets s1 l)) = find z (dstate (gets s2 l)).

Lemma stepV1 s1 s2: network_step s1 s2 -> valid s1.

Lemma stepV2 s1 s2: network_step s1 s2 -> valid s2.

Lemma step_preserves_node_ids s1 s2 l:
  l \in dom s1 -> network_step s1 s2 ->
  dom (dstate (gets s1 l)) =i dom (dstate (gets s2 l)).

End NetworkSemantics. *)
(* Rely:
From mathcomp.ssreflect
Require Import ssreflect ssrbool ssrnat eqtype ssrfun seq.
From mathcomp
Require Import path.
Require Import Eqdep.
Require Import Relation_Operators.
From fcsl
Require Import pred prelude ordtype finmap pcm unionmap heap.
From DiSeL
Require Import Freshness State EqTypeX Protocols Worlds NetworkSem.
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Section Rely.

Variable w : world.
Variable this: nid.

Notation getl := (getLocal).
Notation gets := getStatelet.
Notation getp := (@getProtocol _ w).

Fixpoint network_rely' n s1 s2 :=
  if n is n'.+1
  then exists z s3,
        [/\ this != z, network_step w z s1 s3 & network_rely' n' s3 s2]
    else s1 = s2 /\ s1 \In Coh w.

Definition network_rely s1 s2 := exists n, network_rely' n s1 s2.

Lemma rely_refl s : s \In Coh w -> network_rely s s.

Lemma rely_trans s1 s2 s3 :
  network_rely s1 s2 -> network_rely s2 s3 -> network_rely s1 s3.

Lemma rely_coh' n s1 s2 :
  network_rely' n s1 s2 -> Coh w s1 /\ Coh w s2.

Lemma rely_coh s1 s2 :
  network_rely s1 s2 -> Coh w s1 /\ Coh w s2.

Lemma rely_loc s1 s2 l:
  network_rely s1 s2 -> find this (dstate (gets s1 l)) = find this (dstate (gets s2 l)).

Lemma step_consume_other l s s' m tm from z:
  this != z -> network_step w z s s' ->
  find m (dsoup (gets s l)) = Some (Msg tm from this true) ->
  find m (dsoup (gets s' l)) = Some (Msg tm from this true).

Lemma rely_consume_other l s s' m tm from:
  network_rely s s' ->
  find m (dsoup (gets s l)) = Some (Msg tm from this true) ->
  find m (dsoup (gets s' l)) = Some (Msg tm from this true).

Lemma step_send_other l s s' m tm to b z:
  this != z -> network_step w z s s' ->
  find m (dsoup (gets s' l)) = Some (Msg tm this to b) ->
  exists b', find m (dsoup (gets s l)) = Some (Msg tm this to b') /\ (b -> b').

Lemma rely_send_other l s s' m tm to b:
  network_rely s s' ->
  find m (dsoup (gets s' l)) = Some (Msg tm this to b) ->
  exists b', find m (dsoup (gets s l)) = Some (Msg tm this to b') /\ (b -> b').

Lemma step_send_other' l s s' m tm to b z:
  this != z -> network_step w z s s' ->
  find m (dsoup (gets s l)) = Some (Msg tm this to b) ->
  exists b', find m (dsoup (gets s' l)) = Some (Msg tm this to b') /\ (b' -> b).

Lemma rely_send_other' l s s' m tm to b:
  network_rely s s' ->
  find m (dsoup (gets s l)) = Some (Msg tm this to b) ->
  exists b', find m (dsoup (gets s' l)) = Some (Msg tm this to b') /\ (b' -> b).

Notation loc i l := (getLocal this (getStatelet i l)).
Notation msgs i l := (dsoup (getStatelet i l)).

Lemma rely_loc' l i j : network_rely i j -> loc j l = loc i l.

End Rely. *)
Require FunctionalExtensionality.
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Module ProtocolWithInvariant.
Section ProtocolWithInvariant.

Variable p : protocol.

Notation l := (plab p).
Notation coh := (coh p).

Variable I : dstatelet -> pred nid -> Prop.

Variable d0 : dstatelet.

Definition W := mkWorld p.

Notation toSt d := (l \\-> d).

Definition cohI :=
  [Pred d | coh d /\ I d (nodes p d)].

Lemma cohIVd d : cohI d -> valid (dstate d).
Proof. by case=>/cohVl. Qed.

Lemma cohIVs d : cohI d -> valid (dsoup d).
Proof. by case=>/cohVs. Qed.

Lemma cohIDom d : cohI d -> dom (dstate d) =i nodes p d.
Proof. by case=>/cohDom. Qed.

Definition CohI := CohPred (CohPredMixin cohIVd cohIVs cohIDom).

Lemma st_helper d : (getStatelet (toSt d) l) = d.
Proof. by rewrite /getStatelet findPt. Qed.

Lemma cohSt d : coh d -> Coh W (toSt d).
Proof.
move=>C; split.
- by apply/andP; rewrite valid_unit; split=>//; apply: validPt.
- by apply: validPt.
- by move=>z lc ls st; rewrite dom0.
- by move=>z; rewrite !domPt inE.
move=>k; case B: (k \in dom (toSt d)); last first.
- rewrite /getProtocol /getStatelet.
  case: (dom_find k (toSt d))=>[->|v /find_some]; last by rewrite B.
  rewrite domPt inE/= in B.
  by case: (dom_find k (toSt p))=>[->|? /find_some]//; rewrite domPt inE/= B.
rewrite domPt inE/= in B; move/eqP: B=>B; subst k.
by rewrite /getProtocol /getStatelet !findPt.
Qed.

Section SendInvWrapper.

Variable st : send_trans coh.

Definition send_safeI this to d m :=
  send_safe st this to d m /\ I d (nodes p d).

Lemma s_safe_cohI this to d m : send_safeI this to d m -> CohI d.
Proof. by case=>/s_safe_coh=>[H1]H2. Qed.

Lemma s_safe_inI this to d m : send_safeI this to d m ->
                               this \in nodes p d /\ to \in nodes p d.
Proof. by case=>/s_safe_in. Qed.

Definition send_stepI: send_step_t (send_safeI) :=
  fun this to d msg S => (@send_step _ _ st this to d msg (proj1 S)).

Lemma s_safe_defI this to d msg :
  send_safeI this to d msg <->
  exists b pf, @send_stepI this to d msg pf = Some b.
Proof.
move: (s_safe_def st this to d msg)=>H; split.
- move=>S; case: (S)=>/H[b][pf]E H1; exists b.
  exists (conj pf H1).
  by rewrite /send_stepI (pf_irr (proj1 (conj pf H1)) pf). 
by case=>b[pf]E.
Qed.

Definition S_inv := forall this to d msg (S : send_safe st this to d msg) b,
    I d (nodes p d) -> Some b = send_step S ->
    let: f' := upd this b (dstate d) in
    let: s' := (post_msg (dsoup d) (Msg (TMsg (t_snd st) msg) this to true)).1 in
    let: d' := DStatelet f' s' in
    (forall z, z == this = false -> getLocal z d' = getLocal z d) ->
    I d' (nodes p d').

Hypothesis HIstep : S_inv.

Lemma s_step_cohI : s_step_coh_t CohI (t_snd st) send_stepI.
Proof.
have E1: (getProtocol W l) = p by rewrite /getProtocol/W/=findPt.
move/s_step_coh: (st)=>H.
move=>this to d msg [S]H1 b.
rewrite /send_stepI (pf_irr (proj1 (conj S H1)) S)=>E.
split=>//= ; first by apply: (H this to d msg S b E).
apply: (HIstep H1 E _)=>//.
by move=>z N; rewrite /getLocal/= findU N.
Qed.

Definition snd_transI := SendTrans s_safe_cohI s_safe_inI s_safe_defI s_step_cohI.

End SendInvWrapper.

Section ReceiveInvWrapper.

Variable rt : receive_trans coh.

Definition receive_stepI: receive_step_t CohI :=
  fun this from m d C pf => receive_step rt from m (proj1 C) pf.

Definition R_inv := forall d from this i (C : coh d) m
                           (pf: this \in nodes p d),
    I d (nodes p d) ->
    find i (dsoup d) = Some (Msg m from this true) ->
    this \in dom (dstate d) ->
    msg_wf rt C this from m -> tag m = t_rcv rt ->
    let: loc' := receive_step rt from m C pf in
    let: s'' := consume_msg (dsoup d) i in
    let: f' := upd this loc' (dstate d) in
    let: d' := (DStatelet f' s'') in
    (forall z, z == this = false -> getLocal z d' = getLocal z d) ->
    I d' (nodes p d').

Hypothesis HIstep : R_inv.

Notation msg_wfI := (fun d (C : CohI d) => msg_wf rt (proj1 C)).

Lemma r_step_cohI :
  r_step_coh_t msg_wfI (t_rcv rt) receive_stepI.
Proof. 
have E1: (getProtocol W l) = p by rewrite /getProtocol/W/=findPt.
move=>d from this i C F m D N Wf T.
rewrite /receive_stepI/=.
set d' := {| dstate := upd this (receive_step rt from m (proj1 C) F) (dstate d);
             dsoup := consume_msg (dsoup d) i |}.
split; first by apply: (r_step_coh F D N Wf T).
- apply: (HIstep (proj2 C) N D Wf T)=>//z N'.
  by rewrite /getLocal findU N'.
Qed.

Definition rcv_transI := @ReceiveTrans _ CohI _ msg_wfI _ r_step_cohI.

End ReceiveInvWrapper.

Structure SendInv := SI {
  st : send_trans coh;
  st_inv : S_inv st;
}.

Structure ReceiveInv := RI {
  rt : receive_trans coh;
  rt_inv : R_inv rt;
}.

Structure InductiveInv := II {
  sts : seq SendInv;
  rts : seq ReceiveInv;
  _ : map st sts = snd_trans p;
  _ : map rt rts = rcv_trans p
}.

Definition stsI sts := map (fun stt =>
                          @snd_transI (st stt) (@st_inv stt)) sts.
Definition rtsI rts := map (fun rtt =>
                          @rcv_transI (rt rtt) (@rt_inv rtt)) rts.

Import FunctionalExtensionality.

Variable ii : InductiveInv.

Lemma us : uniq (map (@t_snd _ _) (stsI (sts ii))).
Proof.
case: ii=>sts rts Hs Hr; rewrite /stsI -seq.map_comp/=.
suff E: (t_snd (coh:=CohI) \o
               (fun stt : SendInv => snd_transI (st_inv (s:=stt))))
        = fun stt => t_snd (st stt).
by rewrite E seq.map_comp; rewrite Hs; apply: snd_uniq.

by apply: functional_extensionality=>z. 
Qed.

Lemma ur : uniq (map (@t_rcv _ _) (rtsI (rts ii))).
Proof.
case: ii=>sts rts Hs Hr; rewrite /stsI -seq.map_comp/=.
suff E: (t_rcv (coh:=CohI) \o
               (fun rtt : ReceiveInv => rcv_transI (rt_inv (r:=rtt))))
        = fun rtt => t_rcv (rt rtt).
by rewrite E seq.map_comp; rewrite Hr; apply: rcv_uniq.

by apply: functional_extensionality=>z. 
Qed.

Definition ProtocolWithIndInv := @Protocol _ l _ _ _ us ur.

Lemma stIn (s : SendInv) :
  s \In (sts ii) ->
  (snd_transI (@st_inv s)) \In (snd_trans ProtocolWithIndInv).
Proof. by move=>H; rewrite /stsI/=; apply/Mem_map. Qed.

Lemma rtIn (r : ReceiveInv) :
  r \In (rts ii) ->
  (rcv_transI (@rt_inv r)) \In (rcv_trans ProtocolWithIndInv).
Proof. by move=>H; rewrite /rtsI/=; apply/Mem_map. Qed.

Lemma getInvSendTrans st z to msg s1 h :
  st \In (snd_trans ProtocolWithIndInv) ->
  forall (S : send_safe st z to (getStatelet s1 (plab p)) msg),
  Some h = send_step S ->
  exists st', [/\ st' \In get_st (mkWorld p) (plab p),
     t_snd st' = t_snd st,
     all_hooks_fire (mkWorld p) (plab p) (t_snd st') s1 z msg to &          
     exists S': (send_safe st' z to (getStatelet s1 (plab p)) msg),
       Some h = send_step S'].
Proof.
simpl; case: ii=>sts rts HS HR/=; rewrite /stsI.
case/Mem_map_inv; case=>st' stI/= [->]H1; case=>S Is E.
rewrite /get_st/InMem!prEq; exists st'. split=>//.
- by rewrite -HS/=; apply: (Mem_map ProtocolWithInvariant.st H1).
rewrite/send_step/=/Transitions.send_step/=/send_stepI in E.
- move=>??? F.
  apply sym_eq in F.
  move: F.
  by move/find_some; rewrite dom0.
by exists (proj1 (conj S Is)).
Qed.

End ProtocolWithInvariant.

Section InductiveInvConj.

Variable p : protocol.

Definition s_inv_conj (I1 I2 : dstatelet -> pred nid -> Prop)
           (st : send_trans (coh p)) :=
  S_inv (fun d n => I1 d n /\ I2 d n) st.

Lemma s_inv_conjC I1 I2 st :
  s_inv_conj I1 I2 st <-> s_inv_conj I2 I1 st.
Proof.
by split; move=>H this to d msg S b /and_comm G E N; apply/and_comm; apply: H.
Qed.

Lemma s_inv_conjA I1 I2 I3 st :
  s_inv_conj I1 (fun d n => I2 d n /\ I3 d n) st <->
  s_inv_conj (fun d n => I1 d n /\ I2 d n) I3 st.
Proof.
by split=>H this to d msg S b /and_assoc G E N; apply/and_assoc; apply: H.
Qed.

Definition r_inv_conj (I1 I2 : dstatelet -> pred nid -> Prop)
           (rt : receive_trans (coh p)) :=
  R_inv (fun d n => I1 d n /\ I2 d n) rt.

Lemma r_inv_conjC I1 I2 rt :
  r_inv_conj I1 I2 rt <-> r_inv_conj I2 I1 rt.
Proof.
by split=>H d from this i C m pf/and_comm G E D W T N; apply/and_comm; apply: H.
Qed.

Lemma r_inv_conjA I1 I2 I3 rt :
  r_inv_conj I1 (fun d n => I2 d n /\ I3 d n) rt <->
  r_inv_conj (fun d n => I1 d n /\ I2 d n) I3 rt.
Proof.
by split=>H d from this i C m pf/and_assoc G E D W T N; apply/and_assoc; apply: H.
Qed.

End InductiveInvConj.

End ProtocolWithInvariant.

Module PWIExports.
Section PWIExports.

Import ProtocolWithInvariant.

Definition st_helper := st_helper.
Definition cohSt := cohSt.

Definition S_inv := ProtocolWithInvariant.S_inv.
Definition R_inv := ProtocolWithInvariant.R_inv.

Definition SendInv := SendInv.
Definition SI := SI.
Definition ReceiveInv := ReceiveInv.
Definition RI := RI.

Definition InductiveInv := InductiveInv.

Lemma with_inv_coh pr I (ii : InductiveInv pr I) s:
  s \In Coh (mkWorld (ProtocolWithIndInv ii)) ->    
  s \In Coh (mkWorld pr).
Proof.
case=>G1 G2 Gh G3 G4; split=>//.
- by apply/andP; rewrite valid_unit; split=>//; rewrite !validPt in G1 *.
- by move=>???? ;rewrite dom0.
- by move=>z; move: (G3 z); rewrite !domPt !inE.
move=>l; move: (G4 l).
case X: (l == plab pr); first by move/eqP:X=>X; subst l; rewrite !prEq; case.
rewrite /getProtocol/mkWorld/=.
suff [X1 X2]: l \notin dom (plab pr \\-> ProtocolWithIndInv ii) /\
              l \notin dom (plab pr \\-> pr).
- by case: dom_find X1 X2=>//=->_; case: dom_find=>//=->. 
rewrite !domPt !inE/=; suff: plab pr != l by [].
by apply/negbT; apply/negP=>/eqP Z; subst l; rewrite eqxx in X.
Qed.

Lemma with_inv_nodes pr I (ii : InductiveInv pr I) l :
  nodes (getProtocol (mkWorld (ProtocolWithIndInv ii)) l) =
  nodes (getProtocol (mkWorld pr) l).
Proof.
rewrite /getProtocol/mkWorld/=.
case X: (l == plab pr);
  first by move/eqP:X=>X; subst l; rewrite !findPt.
rewrite /getProtocol/mkWorld/=.
suff [X1 X2]: l \notin dom (plab pr \\-> ProtocolWithIndInv ii) /\
              l \notin dom (plab pr \\-> pr).
by case: dom_find X1 X2=>//=->_; case: dom_find=>//=->. 
rewrite !domPt !inE/=; suff: plab pr != l by [].
by apply/negbT; apply/negP=>/eqP Z; subst l; rewrite eqxx in X.
Qed.

Lemma with_inv_labE pr I (ii : InductiveInv pr I):
  plab (ProtocolWithIndInv ii) = plab pr.
Proof. by []. Qed.

Lemma with_inv_step pr I (ii : InductiveInv pr I) z s1 s2:
  s1 \In Coh (mkWorld (ProtocolWithIndInv ii)) ->
  network_step (mkWorld pr) z s1 s2 ->
  network_step (mkWorld (ProtocolWithIndInv ii)) z s1 s2.
Proof.
move=>C'; move: (with_inv_coh C')=>C.
case; first by case=>_<-; apply: Idle. 

move=>l st Hs to msg h H1 H2 _ S A E ->/=.
have Y : l = plab pr
  by rewrite -(cohD C) domPt inE/= in H2; move/eqP:H2. 
subst l; move: st Hs H1 S E A; rewrite /get_st/InMem!prEq/==>st Hs H1 S E A.
suff X: exists st',
    [/\ st' \In get_st (mkWorld (ProtocolWithIndInv ii)) (plab pr),
     t_snd st' = t_snd st,
     all_hooks_fire (mkWorld (ProtocolWithIndInv ii)) (plab pr) (t_snd st') s1 z msg to &
     exists S': (send_safe st' z to (getStatelet s1 (plab pr)) msg),
                Some h = send_step S'].
case:X=>st'[Hs']Et A'[S']E'; rewrite -Et.
move: (with_inv_nodes ii (plab pr)); rewrite !prEq=>P.
by rewrite -P in H1; apply: (SendMsg (to:=to)(this:=z)(b:=h)(msg:=msg) Hs').

rewrite -(with_inv_labE ii)/get_st/InMem!prEq.
case: ii (@stIn _ _ ii) C' =>sts rts HS HR/= Hi C'.
rewrite -HS in Hs; move/Mem_map_inv: Hs=>[[st' stI]]/=[Es]Si; subst st'.
have G: I (getStatelet s1 (plab pr)) (nodes pr (getStatelet s1 (plab pr))).
+ by case: C'=>_ _ _ _/(_ (plab pr)); rewrite prEq; case.
move:(Hi _ Si)=>/={Hi Si}Hi; exists (@snd_transI pr I st stI); split=>//=.
rewrite /send_safeI /send_stepI/=.
by exists (conj S G); rewrite (pf_irr (proj1 (conj S G)) S).

move=>l rt  Hr i from H1 H2 C1 msg E[F]Hw/=.
have Y : l = plab pr by rewrite -(cohD C) domPt inE/= in H2; move/eqP:H2. 
subst l; move: rt Hr H1 E (coh_s _ C1) Hw.
rewrite /get_rt/InMem/=!prEq=>rt Hr H1 E C1' Hw .
have Hi: (coh (getProtocol (mkWorld (ProtocolWithIndInv ii)) (plab pr)))
           (getStatelet s1 (plab pr)) by case:C'=>_ _ _/(_ (plab pr)).
have Hz : z \in nodes
          (getProtocol (mkWorld (ProtocolWithIndInv ii)) (plab pr))
          (getStatelet s1 (plab pr)) by rewrite (with_inv_nodes ii (plab pr)) prEq.
suff X: exists rt',
     [/\ rt' \In get_rt (mkWorld (ProtocolWithIndInv ii)) (plab pr),
      tag msg = t_rcv rt', msg_wf rt' Hi z from msg &
      receive_step rt from msg C1' H1 = receive_step rt' from msg Hi Hz].
case:X=>rt'[Hr']E' Hw' Gr G.
have pf: (z \in nodes (getProtocol (mkWorld (ProtocolWithIndInv ii)) (plab pr))
                  (getStatelet s1 (plab pr))) by rewrite prEq. 
move: (@ReceiveMsg _ z s1 s2 (plab pr) rt' Hr' i from pf)=>/=.
rewrite -(cohD C) /= domPt inE eqxx/=; move/(_ is_true_true C' msg E')=>X.
subst s2; apply X; split=>//; clear X.
- by rewrite (pf_irr (coh_s (plab pr) C') Hi).
congr (upd _ _); congr {| dstate := _ ; dsoup := _ |}; congr (upd _ _).
rewrite Gr; clear E E' Hw Hw' Hr Hr' Gr rt F H2 H1 C1 C.
rewrite (pf_irr pf Hz).
by rewrite (pf_irr Hi (coh_s (plab pr) C')).

rewrite /get_rt/InMem/=; move: C1' H1 Hi Hz Hw; rewrite !prEq=>C1' H1 Hi Hz Hw.
case: ii (@rtIn _ _ ii) C' Hi Hz=>/=sts rts HS HR/= Hi C'.
rewrite -HR in Hr; move/Mem_map_inv: Hr=>[[rt' rtI]]/=[Er]Ri; subst rt'.
case=>C1'' Inv Hz. exists (@rcv_transI pr I rt rtI); split=>//.
- by move: (@Hi _ Ri).
rewrite /receive_step/=/receive_stepI/=/receive_step/=.
- by rewrite -(pf_irr C1' (proj1 (conj C1'' Inv))).
by rewrite ?(pf_irr C1' (proj1 (conj C1'' Inv)))
           ?(pf_irr H1 Hz).
Qed.

Lemma with_inv_step' pr I (ii : InductiveInv pr I) z s1 s2:
  network_step (mkWorld (ProtocolWithIndInv ii)) z s1 s2 ->
  network_step (mkWorld pr) z s1 s2.
Proof.
case.
- by case=>C'<-; apply: Idle; split=>//; apply: with_inv_coh C'.

move=>l st Hs to msg h H1 H2 C' S A E->{s2}.
have Y : l = plab pr
  by rewrite -(cohD C') domPt inE/= in H2; move/eqP:H2. 
subst l; move: st Hs H1 S E A; rewrite /get_st/InMem!prEq/==>st Hs H1 S E A.
suff X: exists st',
    [/\ st' \In get_st (mkWorld pr) (plab pr),
     t_snd st' = t_snd st,
     all_hooks_fire (mkWorld (ProtocolWithIndInv ii)) (plab pr) (t_snd st') s1 z msg to &
     exists S': (send_safe st' z to (getStatelet s1 (plab pr)) msg),
                Some h = send_step S'].
case:X=>st'[Hs']Et A'[S']E'; rewrite -Et.
apply: (SendMsg (to:=to)(this:=z)(b:=h)(msg:=msg) Hs')=>//;
  [by rewrite prEq| by apply: (with_inv_coh C')].
by apply: (getInvSendTrans (ii := ii)).

move=>l rt  Hr i from H1 H2 C1 msg E[F]Hw/=.
have Y : l = plab pr by rewrite -(cohD C1) domPt inE/= in H2; move/eqP:H2. 
subst l; move: rt Hr H1 E (coh_s _ C1) Hw.
rewrite /get_rt/InMem/=!prEq=>rt Hr H1 E C1' Hw.
have Hi: (coh (getProtocol (mkWorld pr) (plab pr)))
           (getStatelet s1 (plab pr)) by case:(C1'); rewrite prEq.
have Hz : z \in nodes (getProtocol (mkWorld pr) (plab pr))
                      (getStatelet s1 (plab pr))
  by rewrite -(with_inv_nodes ii (plab pr)) prEq.
suff X: exists rt',
     [/\ rt' \In get_rt (mkWorld pr) (plab pr),
      tag msg = t_rcv rt', msg_wf rt' Hi z from msg &
      receive_step rt from msg C1' H1 = receive_step rt' from msg Hi Hz].
case:X=>rt'[Hr']E' Hw' Gr G.
have pf: (z \in nodes (getProtocol (mkWorld pr) (plab pr))
                  (getStatelet s1 (plab pr))) by rewrite prEq. 
move: (@ReceiveMsg _ z s1 s2 (plab pr) rt' Hr' i from pf)=>/=.
rewrite -(cohD C1) domPt inE eqxx/=.
move/(_ is_true_true (with_inv_coh C1) msg E')=>X.
subst s2; apply X; split=>//; clear X.
- by rewrite (pf_irr (coh_s (plab pr) (with_inv_coh C1)) Hi).
congr (upd _ _); congr {| dstate := _ ; dsoup := _ |}; congr (upd _ _).
rewrite Gr; clear E E' Hw Hw' Hr Hr' Gr rt F H2 H1.
rewrite (pf_irr pf Hz).
by rewrite (pf_irr Hi (coh_s (plab pr) (with_inv_coh C1))).

case: ii C1 H2 rt Hr E H1 C1' Hw=>sts rts HS HR/=C1 H2 rt Hr E H1 C1' Hw.
move: Hr; rewrite /rtsI. 
case/Mem_map_inv; case=>rt' rtI/= [Z] H1'; subst rt.
rewrite /get_rt/InMem; move: C1' H1 Hi Hz Hw; rewrite !prEq=>C1' H1 Hi Hz Hw.
exists rt'; split=>//; last first.
- rewrite {1}/receive_step /rcv_transI /receive_stepI/=.
  rewrite (pf_irr H1 Hz).
  by rewrite (pf_irr (proj1 C1') Hi).
- by rewrite -(pf_irr (proj1 C1') Hi).
by rewrite -HR; apply: (Mem_map (@ProtocolWithInvariant.rt pr I) H1').
Qed.

Lemma with_inv_rely' pr I (ii : InductiveInv pr I) z s1 s2:
  network_rely (mkWorld (ProtocolWithIndInv ii)) z s1 s2 ->
  network_rely (mkWorld pr) z s1 s2.
Proof.
case=>n; elim: n s1=>[|n Hi] s1; first by move=>[<-]/with_inv_coh=>C; exists 0. 
case=>z'[s3][N]H/Hi; move/with_inv_step':H=>S; case=>n' R.
by exists n'.+1, z', s3. 
Qed.

Definition ProtocolWithIndInv := ProtocolWithIndInv.

End PWIExports.
End PWIExports.

Export PWIExports.
